commit 642356cb5f4a8c82b5ca5ebac288c327d10df236
Merge: f838767555d4 4ee812f6143d
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Nov 25 19:49:58 2019 -0800

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/herbert/crypto-2.6
    
    Pull crypto updates from Herbert Xu:
     "API:
       - Add library interfaces of certain crypto algorithms for WireGuard
       - Remove the obsolete ablkcipher and blkcipher interfaces
       - Move add_early_randomness() out of rng_mutex
    
      Algorithms:
       - Add blake2b shash algorithm
       - Add blake2s shash algorithm
       - Add curve25519 kpp algorithm
       - Implement 4 way interleave in arm64/gcm-ce
       - Implement ciphertext stealing in powerpc/spe-xts
       - Add Eric Biggers's scalar accelerated ChaCha code for ARM
       - Add accelerated 32r2 code from Zinc for MIPS
       - Add OpenSSL/CRYPTOGRAMS poly1305 implementation for ARM and MIPS
    
      Drivers:
       - Fix entropy reading failures in ks-sa
       - Add support for sam9x60 in atmel
       - Add crypto accelerator for amlogic GXL
       - Add sun8i-ce Crypto Engine
       - Add sun8i-ss cryptographic offloader
       - Add a host of algorithms to inside-secure
       - Add NPCM RNG driver
       - add HiSilicon HPRE accelerator
       - Add HiSilicon TRNG driver"
    
    * git://git.kernel.org/pub/scm/linux/kernel/git/herbert/crypto-2.6: (285 commits)
      crypto: vmx - Avoid weird build failures
      crypto: lib/chacha20poly1305 - use chacha20_crypt()
      crypto: x86/chacha - only unregister algorithms if registered
      crypto: chacha_generic - remove unnecessary setkey() functions
      crypto: amlogic - enable working on big endian kernel
      crypto: sun8i-ce - enable working on big endian
      crypto: mips/chacha - select CRYPTO_SKCIPHER, not CRYPTO_BLKCIPHER
      hwrng: ks-sa - Enable COMPILE_TEST
      crypto: essiv - remove redundant null pointer check before kfree
      crypto: atmel-aes - Change data type for "lastc" buffer
      crypto: atmel-tdes - Set the IV after {en,de}crypt
      crypto: sun4i-ss - fix big endian issues
      crypto: sun4i-ss - hide the Invalid keylen message
      crypto: sun4i-ss - use crypto_ahash_digestsize
      crypto: sun4i-ss - remove dependency on not 64BIT
      crypto: sun4i-ss - Fix 64-bit size_t warnings on sun4i-ss-hash.c
      MAINTAINERS: Add maintainer for HiSilicon SEC V2 driver
      crypto: hisilicon - add DebugFS for HiSilicon SEC
      Documentation: add DebugFS doc for HiSilicon SEC
      crypto: hisilicon - add SRIOV for HiSilicon SEC
      ...

commit 08e97aec700aeff54c4847f170e566cbd7e14e81
Author: Herbert Xu <herbert@gondor.apana.org.au>
Date:   Sun Nov 17 08:48:17 2019 +0800

    Revert "hwrng: core - Freeze khwrng thread during suspend"
    
    This reverts commit 03a3bb7ae631 ("hwrng: core - Freeze khwrng
    thread during suspend"), ff296293b353 ("random: Support freezable
    kthreads in add_hwgenerator_randomness()") and 59b569480dc8 ("random:
    Use wait_event_freezable() in add_hwgenerator_randomness()").
    
    These patches introduced regressions and we need more time to
    get them ready for mainline.
    
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/char/hw_random/core.c b/drivers/char/hw_random/core.c
index 80b850ef1bf6..8d53b8ef545c 100644
--- a/drivers/char/hw_random/core.c
+++ b/drivers/char/hw_random/core.c
@@ -13,7 +13,6 @@
 #include <linux/delay.h>
 #include <linux/device.h>
 #include <linux/err.h>
-#include <linux/freezer.h>
 #include <linux/fs.h>
 #include <linux/hw_random.h>
 #include <linux/kernel.h>
@@ -422,9 +421,7 @@ static int hwrng_fillfn(void *unused)
 {
 	long rc;
 
-	set_freezable();
-
-	while (!kthread_freezable_should_stop(NULL)) {
+	while (!kthread_should_stop()) {
 		struct hwrng *rng;
 
 		rng = get_current_rng();

commit 28443671a468489fb147b31687b2157b6ba59c4a
Author: Laurent Vivier <lvivier@redhat.com>
Date:   Mon Oct 14 13:46:32 2019 +0200

    hwrng: core - Fix use-after-free warning in hwrng_register()
    
    Commit daae28debcb0 has moved add_early_randomness() out of the
    rng_mutex and tries to protect the reference of the new rng device
    by incrementing the reference counter.
    
    But in hwrng_register(), the function can be called with a new device
    that is not set as the current_rng device and the reference has not been
    initialized. This patch fixes the problem by not using the reference
    counter when the device is not the current one: the reference counter
    is only meaningful in the case of the current rng device and a device
    is not used if it is not the current one (except in hwrng_register())
    
    The problem has been reported by Marek Szyprowski on ARM 32bit
    Exynos5420-based Chromebook Peach-Pit board:
    
    WARNING: CPU: 3 PID: 1 at lib/refcount.c:156 hwrng_register+0x13c/0x1b4
    refcount_t: increment on 0; use-after-free.
    Modules linked in:
    CPU: 3 PID: 1 Comm: swapper/0 Not tainted 5.4.0-rc1-00061-gdaae28debcb0
    Hardware name: SAMSUNG EXYNOS (Flattened Device Tree)
    [<c01124c8>] (unwind_backtrace) from [<c010dfb8>] (show_stack+0x10/0x14)
    [<c010dfb8>] (show_stack) from [<c0ae86d8>] (dump_stack+0xa8/0xd4)
    [<c0ae86d8>] (dump_stack) from [<c0127428>] (__warn+0xf4/0x10c)
    [<c0127428>] (__warn) from [<c01274b4>] (warn_slowpath_fmt+0x74/0xb8)
    [<c01274b4>] (warn_slowpath_fmt) from [<c054729c>] (hwrng_register+0x13c/0x1b4)
    [<c054729c>] (hwrng_register) from [<c0547e54>] (tpm_chip_register+0xc4/0x274)
    ...
    
    Reported-by: Marek Szyprowski <m.szyprowski@samsung.com>
    Fixes: daae28debcb0 ("hwrng: core - move add_early_randomness() out of rng_mutex")
    Tested-by: Marek Szyprowski <m.szyprowski@samsung.com>
    Signed-off-by: Laurent Vivier <lvivier@redhat.com>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/char/hw_random/core.c b/drivers/char/hw_random/core.c
index 29f50c045c92..d85c6e18a2d2 100644
--- a/drivers/char/hw_random/core.c
+++ b/drivers/char/hw_random/core.c
@@ -471,17 +471,15 @@ static void start_khwrngd(void)
 int hwrng_register(struct hwrng *rng)
 {
 	int err = -EINVAL;
-	struct hwrng *old_rng, *new_rng, *tmp;
+	struct hwrng *tmp;
 	struct list_head *rng_list_ptr;
+	bool is_new_current = false;
 
 	if (!rng->name || (!rng->data_read && !rng->read))
 		goto out;
 
 	mutex_lock(&rng_mutex);
 
-	old_rng = current_rng;
-	new_rng = NULL;
-
 	/* Must not register two RNGs with the same name. */
 	err = -EEXIST;
 	list_for_each_entry(tmp, &rng_list, list) {
@@ -500,9 +498,8 @@ int hwrng_register(struct hwrng *rng)
 	}
 	list_add_tail(&rng->list, rng_list_ptr);
 
-	err = 0;
-	if (!old_rng ||
-	    (!cur_rng_set_by_user && rng->quality > old_rng->quality)) {
+	if (!current_rng ||
+	    (!cur_rng_set_by_user && rng->quality > current_rng->quality)) {
 		/*
 		 * Set new rng as current as the new rng source
 		 * provides better entropy quality and was not
@@ -511,15 +508,14 @@ int hwrng_register(struct hwrng *rng)
 		err = set_current_rng(rng);
 		if (err)
 			goto out_unlock;
+		/* to use current_rng in add_early_randomness() we need
+		 * to take a ref
+		 */
+		is_new_current = true;
+		kref_get(&rng->ref);
 	}
-
-	new_rng = rng;
-	kref_get(&new_rng->ref);
-out_unlock:
 	mutex_unlock(&rng_mutex);
-
-	if (new_rng) {
-		if (new_rng != old_rng || !rng->init) {
+	if (is_new_current || !rng->init) {
 		/*
 		 * Use a new device's input to add some randomness to
 		 * the system.  If this rng device isn't going to be
@@ -527,10 +523,13 @@ int hwrng_register(struct hwrng *rng)
 		 * called yet by set_current_rng(); so only use the
 		 * randomness from devices that don't need an init callback
 		 */
-			add_early_randomness(new_rng);
-		}
-		put_rng(new_rng);
+		add_early_randomness(rng);
 	}
+	if (is_new_current)
+		put_rng(rng);
+	return 0;
+out_unlock:
+	mutex_unlock(&rng_mutex);
 out:
 	return err;
 }

commit daae28debcb03eee837fadfd20788107b325c5a2
Author: Laurent Vivier <lvivier@redhat.com>
Date:   Thu Sep 12 15:30:22 2019 +0200

    hwrng: core - move add_early_randomness() out of rng_mutex
    
    add_early_randomness() is called every time a new rng backend is added
    and every time it is set as the current rng provider.
    
    add_early_randomness() is called from functions locking rng_mutex,
    and if it hangs all the hw_random framework hangs: we can't read sysfs,
    add or remove a backend.
    
    This patch move add_early_randomness() out of the rng_mutex zone.
    It only needs the reading_mutex.
    
    Signed-off-by: Laurent Vivier <lvivier@redhat.com>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/char/hw_random/core.c b/drivers/char/hw_random/core.c
index 80b850ef1bf6..29f50c045c92 100644
--- a/drivers/char/hw_random/core.c
+++ b/drivers/char/hw_random/core.c
@@ -112,6 +112,14 @@ static void drop_current_rng(void)
 }
 
 /* Returns ERR_PTR(), NULL or refcounted hwrng */
+static struct hwrng *get_current_rng_nolock(void)
+{
+	if (current_rng)
+		kref_get(&current_rng->ref);
+
+	return current_rng;
+}
+
 static struct hwrng *get_current_rng(void)
 {
 	struct hwrng *rng;
@@ -119,9 +127,7 @@ static struct hwrng *get_current_rng(void)
 	if (mutex_lock_interruptible(&rng_mutex))
 		return ERR_PTR(-ERESTARTSYS);
 
-	rng = current_rng;
-	if (rng)
-		kref_get(&rng->ref);
+	rng = get_current_rng_nolock();
 
 	mutex_unlock(&rng_mutex);
 	return rng;
@@ -156,8 +162,6 @@ static int hwrng_init(struct hwrng *rng)
 	reinit_completion(&rng->cleanup_done);
 
 skip_init:
-	add_early_randomness(rng);
-
 	current_quality = rng->quality ? : default_quality;
 	if (current_quality > 1024)
 		current_quality = 1024;
@@ -321,12 +325,13 @@ static ssize_t hwrng_attr_current_store(struct device *dev,
 					const char *buf, size_t len)
 {
 	int err = -ENODEV;
-	struct hwrng *rng;
+	struct hwrng *rng, *old_rng, *new_rng;
 
 	err = mutex_lock_interruptible(&rng_mutex);
 	if (err)
 		return -ERESTARTSYS;
 
+	old_rng = current_rng;
 	if (sysfs_streq(buf, "")) {
 		err = enable_best_rng();
 	} else {
@@ -338,9 +343,15 @@ static ssize_t hwrng_attr_current_store(struct device *dev,
 			}
 		}
 	}
-
+	new_rng = get_current_rng_nolock();
 	mutex_unlock(&rng_mutex);
 
+	if (new_rng) {
+		if (new_rng != old_rng)
+			add_early_randomness(new_rng);
+		put_rng(new_rng);
+	}
+
 	return err ? : len;
 }
 
@@ -460,13 +471,17 @@ static void start_khwrngd(void)
 int hwrng_register(struct hwrng *rng)
 {
 	int err = -EINVAL;
-	struct hwrng *old_rng, *tmp;
+	struct hwrng *old_rng, *new_rng, *tmp;
 	struct list_head *rng_list_ptr;
 
 	if (!rng->name || (!rng->data_read && !rng->read))
 		goto out;
 
 	mutex_lock(&rng_mutex);
+
+	old_rng = current_rng;
+	new_rng = NULL;
+
 	/* Must not register two RNGs with the same name. */
 	err = -EEXIST;
 	list_for_each_entry(tmp, &rng_list, list) {
@@ -485,7 +500,6 @@ int hwrng_register(struct hwrng *rng)
 	}
 	list_add_tail(&rng->list, rng_list_ptr);
 
-	old_rng = current_rng;
 	err = 0;
 	if (!old_rng ||
 	    (!cur_rng_set_by_user && rng->quality > old_rng->quality)) {
@@ -499,19 +513,24 @@ int hwrng_register(struct hwrng *rng)
 			goto out_unlock;
 	}
 
-	if (old_rng && !rng->init) {
+	new_rng = rng;
+	kref_get(&new_rng->ref);
+out_unlock:
+	mutex_unlock(&rng_mutex);
+
+	if (new_rng) {
+		if (new_rng != old_rng || !rng->init) {
 		/*
 		 * Use a new device's input to add some randomness to
 		 * the system.  If this rng device isn't going to be
 		 * used right away, its init function hasn't been
-		 * called yet; so only use the randomness from devices
-		 * that don't need an init callback.
+		 * called yet by set_current_rng(); so only use the
+		 * randomness from devices that don't need an init callback
 		 */
-		add_early_randomness(rng);
+			add_early_randomness(new_rng);
+		}
+		put_rng(new_rng);
 	}
-
-out_unlock:
-	mutex_unlock(&rng_mutex);
 out:
 	return err;
 }
@@ -519,10 +538,12 @@ EXPORT_SYMBOL_GPL(hwrng_register);
 
 void hwrng_unregister(struct hwrng *rng)
 {
+	struct hwrng *old_rng, *new_rng;
 	int err;
 
 	mutex_lock(&rng_mutex);
 
+	old_rng = current_rng;
 	list_del(&rng->list);
 	if (current_rng == rng) {
 		err = enable_best_rng();
@@ -532,6 +553,7 @@ void hwrng_unregister(struct hwrng *rng)
 		}
 	}
 
+	new_rng = get_current_rng_nolock();
 	if (list_empty(&rng_list)) {
 		mutex_unlock(&rng_mutex);
 		if (hwrng_fill)
@@ -539,6 +561,12 @@ void hwrng_unregister(struct hwrng *rng)
 	} else
 		mutex_unlock(&rng_mutex);
 
+	if (new_rng) {
+		if (old_rng != new_rng)
+			add_early_randomness(new_rng);
+		put_rng(new_rng);
+	}
+
 	wait_for_completion(&rng->cleanup_done);
 }
 EXPORT_SYMBOL_GPL(hwrng_unregister);

commit 78887832e76541f77169a24ac238fccb51059b63
Author: Laurent Vivier <lvivier@redhat.com>
Date:   Tue Sep 17 11:54:50 2019 +0200

    hwrng: core - don't wait on add_early_randomness()
    
    add_early_randomness() is called by hwrng_register() when the
    hardware is added. If this hardware and its module are present
    at boot, and if there is no data available the boot hangs until
    data are available and can't be interrupted.
    
    For instance, in the case of virtio-rng, in some cases the host can be
    not able to provide enough entropy for all the guests.
    
    We can have two easy ways to reproduce the problem but they rely on
    misconfiguration of the hypervisor or the egd daemon:
    
    - if virtio-rng device is configured to connect to the egd daemon of the
    host but when the virtio-rng driver asks for data the daemon is not
    connected,
    
    - if virtio-rng device is configured to connect to the egd daemon of the
    host but the egd daemon doesn't provide data.
    
    The guest kernel will hang at boot until the virtio-rng driver provides
    enough data.
    
    To avoid that, call rng_get_data() in non-blocking mode (wait=0)
    from add_early_randomness().
    
    Signed-off-by: Laurent Vivier <lvivier@redhat.com>
    Fixes: d9e797261933 ("hwrng: add randomness to system from rng...")
    Cc: <stable@vger.kernel.org>
    Reviewed-by: Theodore Ts'o <tytso@mit.edu>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/char/hw_random/core.c b/drivers/char/hw_random/core.c
index bdab5d9af8d2..80b850ef1bf6 100644
--- a/drivers/char/hw_random/core.c
+++ b/drivers/char/hw_random/core.c
@@ -68,7 +68,7 @@ static void add_early_randomness(struct hwrng *rng)
 	size_t size = min_t(size_t, 16, rng_buffer_size());
 
 	mutex_lock(&reading_mutex);
-	bytes_read = rng_get_data(rng, rng_buffer, size, 1);
+	bytes_read = rng_get_data(rng, rng_buffer, size, 0);
 	mutex_unlock(&reading_mutex);
 	if (bytes_read > 0)
 		add_device_randomness(rng_buffer, bytes_read);

commit 03a3bb7ae63150230c5de645dc95e673ebf17e1a
Author: Stephen Boyd <swboyd@chromium.org>
Date:   Mon Aug 5 16:32:41 2019 -0700

    hwrng: core - Freeze khwrng thread during suspend
    
    The hwrng_fill() function can run while devices are suspending and
    resuming. If the hwrng is behind a bus such as i2c or SPI and that bus
    is suspended, the hwrng may hang the bus while attempting to add some
    randomness. It's been observed on ChromeOS devices with suspend-to-idle
    (s2idle) and an i2c based hwrng that this kthread may run and ask the
    hwrng device for randomness before the i2c bus has been resumed.
    
    Let's make this kthread freezable so that we don't try to touch the
    hwrng during suspend/resume. This ensures that we can't cause the hwrng
    backing driver to get into a bad state because the device is guaranteed
    to be resumed before the hwrng kthread is thawed.
    
    Cc: Andrey Pronin <apronin@chromium.org>
    Cc: Duncan Laurie <dlaurie@chromium.org>
    Cc: Jason Gunthorpe <jgg@ziepe.ca>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Guenter Roeck <groeck@chromium.org>
    Cc: Alexander Steffen <Alexander.Steffen@infineon.com>
    Signed-off-by: Stephen Boyd <swboyd@chromium.org>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/char/hw_random/core.c b/drivers/char/hw_random/core.c
index 9044d31ab1a1..bdab5d9af8d2 100644
--- a/drivers/char/hw_random/core.c
+++ b/drivers/char/hw_random/core.c
@@ -13,6 +13,7 @@
 #include <linux/delay.h>
 #include <linux/device.h>
 #include <linux/err.h>
+#include <linux/freezer.h>
 #include <linux/fs.h>
 #include <linux/hw_random.h>
 #include <linux/kernel.h>
@@ -421,7 +422,9 @@ static int hwrng_fillfn(void *unused)
 {
 	long rc;
 
-	while (!kthread_should_stop()) {
+	set_freezable();
+
+	while (!kthread_freezable_should_stop(NULL)) {
 		struct hwrng *rng;
 
 		rng = get_current_rng();

commit 4f4cfa6c560c93ba180c30675cf845e1597de44c
Author: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>
Date:   Thu Jun 27 14:56:51 2019 -0300

    docs: admin-guide: add a series of orphaned documents
    
    There are lots of documents that belong to the admin-guide but
    are on random places (most under Documentation root dir).
    
    Move them to the admin guide.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>
    Acked-by: Alexandre Belloni <alexandre.belloni@bootlin.com>
    Acked-by: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>

diff --git a/drivers/char/hw_random/core.c b/drivers/char/hw_random/core.c
index 95be7228f327..9044d31ab1a1 100644
--- a/drivers/char/hw_random/core.c
+++ b/drivers/char/hw_random/core.c
@@ -4,7 +4,7 @@
  * Copyright 2006 Michael Buesch <m@bues.ch>
  * Copyright 2005 (c) MontaVista Software, Inc.
  *
- * Please read Documentation/hw_random.txt for details on use.
+ * Please read Documentation/admin-guide/hw_random.rst for details on use.
  *
  * This software may be used and distributed according to the terms
  * of the GNU General Public License, incorporated herein by reference.

commit fae29f135ef4a86228d3ce13b61babf0d3031118
Author: Michael S. Tsirkin <mst@redhat.com>
Date:   Tue Sep 25 12:35:18 2018 -0400

    hwrng: core - document the quality field
    
    quality field is currently documented as being 'per mill'.  In fact the
    math involved is:
    
                    add_hwgenerator_randomness((void *)rng_fillbuf, rc,
                                               rc * current_quality * 8 >> 10);
    
    thus the actual definition is "bits of entropy per 1024 bits of input".
    
    The current documentation seems to have confused multiple people
    in the past, let's fix the documentation to match code.
    
    An alternative is to change core to match driver expectations, replacing
            rc * current_quality * 8 >> 10
    with
            rc * current_quality / 1000
    but that has performance costs, so probably isn't a good option.
    
    Fixes: 0f734e6e768 ("hwrng: add per-device entropy derating")
    Reported-by: "Dr. David Alan Gilbert" <dgilbert@redhat.com>
    Signed-off-by: Michael S. Tsirkin <mst@redhat.com>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/char/hw_random/core.c b/drivers/char/hw_random/core.c
index aaf9e5afaad4..95be7228f327 100644
--- a/drivers/char/hw_random/core.c
+++ b/drivers/char/hw_random/core.c
@@ -44,10 +44,10 @@ static unsigned short default_quality; /* = 0; default to "off" */
 
 module_param(current_quality, ushort, 0644);
 MODULE_PARM_DESC(current_quality,
-		 "current hwrng entropy estimation per mill");
+		 "current hwrng entropy estimation per 1024 bits of input");
 module_param(default_quality, ushort, 0644);
 MODULE_PARM_DESC(default_quality,
-		 "default entropy content of hwrng per mill");
+		 "default entropy content of hwrng per 1024 bits of input");
 
 static void drop_current_rng(void);
 static int hwrng_init(struct hwrng *rng);

commit 837bf7cc3b7504385ae0e829c72e470dfc27cf6c
Author: Michael Büsch <m@bues.ch>
Date:   Thu Jun 14 20:08:11 2018 +0200

    hwrng: core - Always drop the RNG in hwrng_unregister()
    
    enable_best_rng() is used in hwrng_unregister() to switch away from the
    currently active RNG, if that is the one currently being removed.
    However enable_best_rng() might fail, if the next RNG's init routine
    fails. In that case enable_best_rng() will return an error code and
    the currently active RNG will remain active.
    After unregistering this might lead to crashes due to use-after-free.
    
    Fix this by dropping the currently active RNG, if enable_best_rng()
    failed. This will result in no RNG to be active, if the next-best
    one failed to initialize.
    
    This problem was introduced by 142a27f0a731ddcf467546960a5585970ca98e21
    
    Fixes: 142a27f0a731 ("hwrng: core - Reset user selected rng by...")
    Reported-by: Wirz <spam@lukas-wirz.de>
    Tested-by: Wirz <spam@lukas-wirz.de>
    Signed-off-by: Michael Büsch <m@bues.ch>
    Cc: stable@vger.kernel.org
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/char/hw_random/core.c b/drivers/char/hw_random/core.c
index 91bb98c42a1c..aaf9e5afaad4 100644
--- a/drivers/char/hw_random/core.c
+++ b/drivers/char/hw_random/core.c
@@ -516,11 +516,18 @@ EXPORT_SYMBOL_GPL(hwrng_register);
 
 void hwrng_unregister(struct hwrng *rng)
 {
+	int err;
+
 	mutex_lock(&rng_mutex);
 
 	list_del(&rng->list);
-	if (current_rng == rng)
-		enable_best_rng();
+	if (current_rng == rng) {
+		err = enable_best_rng();
+		if (err) {
+			drop_current_rng();
+			cur_rng_set_by_user = 0;
+		}
+	}
 
 	if (list_empty(&rng_list)) {
 		mutex_unlock(&rng_mutex);

commit 0e4b52942b1c76f89e0dcb829f72e123d0678f54
Author: Gary R Hook <gary.hook@amd.com>
Date:   Fri Dec 15 13:55:59 2017 -0600

    hwrng: core - Clean up RNG list when last hwrng is unregistered
    
    Commit 142a27f0a731 added support for a "best" RNG, and in doing so
    introduced a hang from rmmod/modprobe -r when the last RNG on the list
    was unloaded.
    
    When the hwrng list is depleted, return the global variables to their
    original state and decrement all references to the object.
    
    Fixes: 142a27f0a731 ("hwrng: core - Reset user selected rng by writing "" to rng_current")
    Signed-off-by: Gary R Hook <gary.hook@amd.com>
    Reviewed-by: PrasannaKumar Muralidharan <prasannatsmkumar@gmail.com>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/char/hw_random/core.c b/drivers/char/hw_random/core.c
index 657b8770b6b9..91bb98c42a1c 100644
--- a/drivers/char/hw_random/core.c
+++ b/drivers/char/hw_random/core.c
@@ -306,6 +306,10 @@ static int enable_best_rng(void)
 		ret = ((new_rng == current_rng) ? 0 : set_current_rng(new_rng));
 		if (!ret)
 			cur_rng_set_by_user = 0;
+	} else {
+		drop_current_rng();
+		cur_rng_set_by_user = 0;
+		ret = 0;
 	}
 
 	return ret;

commit 142a27f0a731ddcf467546960a5585970ca98e21
Author: PrasannaKumar Muralidharan <prasannatsmkumar@gmail.com>
Date:   Fri Oct 27 22:34:04 2017 +0530

    hwrng: core - Reset user selected rng by writing "" to rng_current
    
    User is able to select a chosen rng by writing its name to rng_current
    but there is no way to reset it without unbinding the rng. Let user
    write "" to rng_current and delesect the chosen rng.
    
    Signed-off-by: PrasannaKumar Muralidharan <prasannatsmkumar@gmail.com>
    reviewed-by: Harald Freudenberger <freude@linux.vnet.ibm.com>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/char/hw_random/core.c b/drivers/char/hw_random/core.c
index ff79844890ab..657b8770b6b9 100644
--- a/drivers/char/hw_random/core.c
+++ b/drivers/char/hw_random/core.c
@@ -292,26 +292,48 @@ static struct miscdevice rng_miscdev = {
 	.groups		= rng_dev_groups,
 };
 
+static int enable_best_rng(void)
+{
+	int ret = -ENODEV;
+
+	BUG_ON(!mutex_is_locked(&rng_mutex));
+
+	/* rng_list is sorted by quality, use the best (=first) one */
+	if (!list_empty(&rng_list)) {
+		struct hwrng *new_rng;
+
+		new_rng = list_entry(rng_list.next, struct hwrng, list);
+		ret = ((new_rng == current_rng) ? 0 : set_current_rng(new_rng));
+		if (!ret)
+			cur_rng_set_by_user = 0;
+	}
+
+	return ret;
+}
+
 static ssize_t hwrng_attr_current_store(struct device *dev,
 					struct device_attribute *attr,
 					const char *buf, size_t len)
 {
-	int err;
+	int err = -ENODEV;
 	struct hwrng *rng;
 
 	err = mutex_lock_interruptible(&rng_mutex);
 	if (err)
 		return -ERESTARTSYS;
-	err = -ENODEV;
-	list_for_each_entry(rng, &rng_list, list) {
-		if (sysfs_streq(rng->name, buf)) {
-			err = 0;
-			cur_rng_set_by_user = 1;
-			if (rng != current_rng)
+
+	if (sysfs_streq(buf, "")) {
+		err = enable_best_rng();
+	} else {
+		list_for_each_entry(rng, &rng_list, list) {
+			if (sysfs_streq(rng->name, buf)) {
+				cur_rng_set_by_user = 1;
 				err = set_current_rng(rng);
-			break;
+				break;
+			}
 		}
 	}
+
 	mutex_unlock(&rng_mutex);
 
 	return err ? : len;
@@ -493,17 +515,8 @@ void hwrng_unregister(struct hwrng *rng)
 	mutex_lock(&rng_mutex);
 
 	list_del(&rng->list);
-	if (current_rng == rng) {
-		drop_current_rng();
-		cur_rng_set_by_user = 0;
-		/* rng_list is sorted by quality, use the best (=first) one */
-		if (!list_empty(&rng_list)) {
-			struct hwrng *new_rng;
-
-			new_rng = list_entry(rng_list.next, struct hwrng, list);
-			set_current_rng(new_rng);
-		}
-	}
+	if (current_rng == rng)
+		enable_best_rng();
 
 	if (list_empty(&rng_list)) {
 		mutex_unlock(&rng_mutex);

commit 4d0ec22943301f827ac2800b7eb3531fb6d7447b
Author: Arvind Yadav <arvind.yadav.cs@gmail.com>
Date:   Mon Sep 25 13:15:00 2017 +0530

    hwrng: core - pr_err() strings should end with newlines
    
    pr_err() messages should terminated with a new-line to avoid
    other messages being concatenated onto the end.
    
    Signed-off-by: Arvind Yadav <arvind.yadav.cs@gmail.com>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/char/hw_random/core.c b/drivers/char/hw_random/core.c
index 9701ac7d8b47..ff79844890ab 100644
--- a/drivers/char/hw_random/core.c
+++ b/drivers/char/hw_random/core.c
@@ -423,7 +423,7 @@ static void start_khwrngd(void)
 {
 	hwrng_fill = kthread_run(hwrng_fillfn, NULL, "hwrng");
 	if (IS_ERR(hwrng_fill)) {
-		pr_err("hwrng_fill thread creation failed");
+		pr_err("hwrng_fill thread creation failed\n");
 		hwrng_fill = NULL;
 	}
 }

commit 10a515ddb5f19a1ff0b9882c430b4427843169f3
Author: Harald Freudenberger <freude@linux.vnet.ibm.com>
Date:   Tue Jul 11 09:36:23 2017 +0200

    hwrng: remember rng chosen by user
    
    When a user chooses a rng source via sysfs attribute
    this rng should be sticky, even when other sources
    with better quality to register. This patch introduces
    a simple way to remember the user's choice. This is
    reflected by a new sysfs attribute file 'rng_selected'
    which shows if the current rng has been chosen by
    userspace. The new attribute file shows '1' for user
    selected rng and '0' otherwise.
    
    Signed-off-by: Harald Freudenberger <freude@linux.vnet.ibm.com>
    Reviewed-by: PrasannaKumar Muralidharan <prasannatsmkumar@gmail.com>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/char/hw_random/core.c b/drivers/char/hw_random/core.c
index e9dda162d4d2..9701ac7d8b47 100644
--- a/drivers/char/hw_random/core.c
+++ b/drivers/char/hw_random/core.c
@@ -28,6 +28,8 @@
 #define RNG_MODULE_NAME		"hw_random"
 
 static struct hwrng *current_rng;
+/* the current rng has been explicitly chosen by user via sysfs */
+static int cur_rng_set_by_user;
 static struct task_struct *hwrng_fill;
 /* list of registered rngs, sorted decending by quality */
 static LIST_HEAD(rng_list);
@@ -304,6 +306,7 @@ static ssize_t hwrng_attr_current_store(struct device *dev,
 	list_for_each_entry(rng, &rng_list, list) {
 		if (sysfs_streq(rng->name, buf)) {
 			err = 0;
+			cur_rng_set_by_user = 1;
 			if (rng != current_rng)
 				err = set_current_rng(rng);
 			break;
@@ -352,16 +355,27 @@ static ssize_t hwrng_attr_available_show(struct device *dev,
 	return strlen(buf);
 }
 
+static ssize_t hwrng_attr_selected_show(struct device *dev,
+					struct device_attribute *attr,
+					char *buf)
+{
+	return snprintf(buf, PAGE_SIZE, "%d\n", cur_rng_set_by_user);
+}
+
 static DEVICE_ATTR(rng_current, S_IRUGO | S_IWUSR,
 		   hwrng_attr_current_show,
 		   hwrng_attr_current_store);
 static DEVICE_ATTR(rng_available, S_IRUGO,
 		   hwrng_attr_available_show,
 		   NULL);
+static DEVICE_ATTR(rng_selected, S_IRUGO,
+		   hwrng_attr_selected_show,
+		   NULL);
 
 static struct attribute *rng_dev_attrs[] = {
 	&dev_attr_rng_current.attr,
 	&dev_attr_rng_available.attr,
+	&dev_attr_rng_selected.attr,
 	NULL
 };
 
@@ -444,10 +458,12 @@ int hwrng_register(struct hwrng *rng)
 
 	old_rng = current_rng;
 	err = 0;
-	if (!old_rng || (rng->quality > old_rng->quality)) {
+	if (!old_rng ||
+	    (!cur_rng_set_by_user && rng->quality > old_rng->quality)) {
 		/*
 		 * Set new rng as current as the new rng source
-		 * provides better entropy quality.
+		 * provides better entropy quality and was not
+		 * chosen by userspace.
 		 */
 		err = set_current_rng(rng);
 		if (err)
@@ -479,6 +495,7 @@ void hwrng_unregister(struct hwrng *rng)
 	list_del(&rng->list);
 	if (current_rng == rng) {
 		drop_current_rng();
+		cur_rng_set_by_user = 0;
 		/* rng_list is sorted by quality, use the best (=first) one */
 		if (!list_empty(&rng_list)) {
 			struct hwrng *new_rng;

commit 2bbb6983887fefc8026beab01198d30f47b7bd22
Author: Harald Freudenberger <freude@linux.vnet.ibm.com>
Date:   Tue Jul 11 09:36:22 2017 +0200

    hwrng: use rng source with best quality
    
    This patch rewoks the hwrng to always use the
    rng source with best entropy quality.
    
    On registation and unregistration the hwrng now
    tries to choose the best (= highest quality value)
    rng source. The handling of the internal list
    of registered rng sources is now always sorted
    by quality and the top most rng chosen.
    
    Signed-off-by: Harald Freudenberger <freude@linux.vnet.ibm.com>
    Reviewed-by: PrasannaKumar Muralidharan <prasannatsmkumar@gmail.com>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/char/hw_random/core.c b/drivers/char/hw_random/core.c
index 503a41dfa193..e9dda162d4d2 100644
--- a/drivers/char/hw_random/core.c
+++ b/drivers/char/hw_random/core.c
@@ -29,6 +29,7 @@
 
 static struct hwrng *current_rng;
 static struct task_struct *hwrng_fill;
+/* list of registered rngs, sorted decending by quality */
 static LIST_HEAD(rng_list);
 /* Protects rng_list and current_rng */
 static DEFINE_MUTEX(rng_mutex);
@@ -417,6 +418,7 @@ int hwrng_register(struct hwrng *rng)
 {
 	int err = -EINVAL;
 	struct hwrng *old_rng, *tmp;
+	struct list_head *rng_list_ptr;
 
 	if (!rng->name || (!rng->data_read && !rng->read))
 		goto out;
@@ -432,14 +434,25 @@ int hwrng_register(struct hwrng *rng)
 	init_completion(&rng->cleanup_done);
 	complete(&rng->cleanup_done);
 
+	/* rng_list is sorted by decreasing quality */
+	list_for_each(rng_list_ptr, &rng_list) {
+		tmp = list_entry(rng_list_ptr, struct hwrng, list);
+		if (tmp->quality < rng->quality)
+			break;
+	}
+	list_add_tail(&rng->list, rng_list_ptr);
+
 	old_rng = current_rng;
 	err = 0;
-	if (!old_rng) {
+	if (!old_rng || (rng->quality > old_rng->quality)) {
+		/*
+		 * Set new rng as current as the new rng source
+		 * provides better entropy quality.
+		 */
 		err = set_current_rng(rng);
 		if (err)
 			goto out_unlock;
 	}
-	list_add_tail(&rng->list, &rng_list);
 
 	if (old_rng && !rng->init) {
 		/*
@@ -466,12 +479,12 @@ void hwrng_unregister(struct hwrng *rng)
 	list_del(&rng->list);
 	if (current_rng == rng) {
 		drop_current_rng();
+		/* rng_list is sorted by quality, use the best (=first) one */
 		if (!list_empty(&rng_list)) {
-			struct hwrng *tail;
-
-			tail = list_entry(rng_list.prev, struct hwrng, list);
+			struct hwrng *new_rng;
 
-			set_current_rng(tail);
+			new_rng = list_entry(rng_list.next, struct hwrng, list);
+			set_current_rng(new_rng);
 		}
 	}
 

commit 174cd4b1e5fbd0d74c68cf3a74f5bd4923485512
Author: Ingo Molnar <mingo@kernel.org>
Date:   Thu Feb 2 19:15:33 2017 +0100

    sched/headers: Prepare to move signal wakeup & sigpending methods from <linux/sched.h> into <linux/sched/signal.h>
    
    Fix up affected files that include this signal functionality via sched.h.
    
    Acked-by: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Mike Galbraith <efault@gmx.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/drivers/char/hw_random/core.c b/drivers/char/hw_random/core.c
index 5c654b5d4adf..503a41dfa193 100644
--- a/drivers/char/hw_random/core.c
+++ b/drivers/char/hw_random/core.c
@@ -17,6 +17,7 @@
 #include <linux/hw_random.h>
 #include <linux/kernel.h>
 #include <linux/kthread.h>
+#include <linux/sched/signal.h>
 #include <linux/miscdevice.h>
 #include <linux/module.h>
 #include <linux/random.h>

commit 5bcbe22ca47da04cda3a858cef67f55b550c1d13
Merge: 1db934a5b77a 12cb3a1c4184
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Feb 23 09:54:19 2017 -0800

    Merge branch 'linus' of git://git.kernel.org/pub/scm/linux/kernel/git/herbert/crypto-2.6
    
    Pull crypto update from Herbert Xu:
     "API:
       - Try to catch hash output overrun in testmgr
       - Introduce walksize attribute for batched walking
       - Make crypto_xor() and crypto_inc() alignment agnostic
    
      Algorithms:
       - Add time-invariant AES algorithm
       - Add standalone CBCMAC algorithm
    
      Drivers:
       - Add NEON acclerated chacha20 on ARM/ARM64
       - Expose AES-CTR as synchronous skcipher on ARM64
       - Add scalar AES implementation on ARM64
       - Improve scalar AES implementation on ARM
       - Improve NEON AES implementation on ARM/ARM64
       - Merge CRC32 and PMULL instruction based drivers on ARM64
       - Add NEON acclerated CBCMAC/CMAC/XCBC AES on ARM64
       - Add IPsec AUTHENC implementation in atmel
       - Add Support for Octeon-tx CPT Engine
       - Add Broadcom SPU driver
       - Add MediaTek driver"
    
    * 'linus' of git://git.kernel.org/pub/scm/linux/kernel/git/herbert/crypto-2.6: (142 commits)
      crypto: xts - Add ECB dependency
      crypto: cavium - switch to pci_alloc_irq_vectors
      crypto: cavium - switch to pci_alloc_irq_vectors
      crypto: cavium - remove dead MSI-X related define
      crypto: brcm - Avoid double free in ahash_finup()
      crypto: cavium - fix Kconfig dependencies
      crypto: cavium - cpt_bind_vq_to_grp could return an error code
      crypto: doc - fix typo
      hwrng: omap - update Kconfig help description
      crypto: ccm - drop unnecessary minimum 32-bit alignment
      crypto: ccm - honour alignmask of subordinate MAC cipher
      crypto: caam - fix state buffer DMA (un)mapping
      crypto: caam - abstract ahash request double buffering
      crypto: caam - fix error path for ctx_dma mapping failure
      crypto: caam - fix DMA API leaks for multiple setkey() calls
      crypto: caam - don't dma_map key for hash algorithms
      crypto: caam - use dma_map_sg() return code
      crypto: caam - replace sg_count() with sg_nents_for_len()
      crypto: caam - check sg_count() return value
      crypto: caam - fix HW S/G in ablkcipher_giv_edesc_alloc()
      ..

commit 3b802c9455f973fa786eafb4d5bd4634a7dd5130
Author: David Daney <david.daney@cavium.com>
Date:   Tue Feb 7 16:23:31 2017 -0800

    Revert "hwrng: core - zeroize buffers with random data"
    
    This reverts commit 2cc751545854d7bd7eedf4d7e377bb52e176cd07.
    
    With this commit in place I get on a Cavium ThunderX (arm64) system:
    
    $ if=/dev/hwrng bs=256 count=1 | od -t x1 -A x -v > rng-bad.txt
    1+0 records in
    1+0 records out
    256 bytes (256 B) copied, 9.1171e-05 s, 2.8 MB/s
    $ dd if=/dev/hwrng bs=256 count=1 | od -t x1 -A x -v >> rng-bad.txt
    1+0 records in
    1+0 records out
    256 bytes (256 B) copied, 9.6141e-05 s, 2.7 MB/s
    $ cat rng-bad.txt
    000000 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
    000010 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
    000020 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
    000030 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
    000040 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
    000050 00 00 00 00 37 20 46 ae d0 fc 1c 55 25 6e b0 b8
    000060 7c 7e d7 d4 00 0f 6f b2 91 1e 30 a8 fa 3e 52 0e
    000070 06 2d 53 30 be a1 20 0f aa 56 6e 0e 44 6e f4 35
    000080 b7 6a fe d2 52 70 7e 58 56 02 41 ea d1 9c 6a 6a
    000090 d1 bd d8 4c da 35 45 ef 89 55 fc 59 d5 cd 57 ba
    0000a0 4e 3e 02 1c 12 76 43 37 23 e1 9f 7a 9f 9e 99 24
    0000b0 47 b2 de e3 79 85 f6 55 7e ad 76 13 4f a0 b5 41
    0000c0 c6 92 42 01 d9 12 de 8f b4 7b 6e ae d7 24 fc 65
    0000d0 4d af 0a aa 36 d9 17 8d 0e 8b 7a 3b b6 5f 96 47
    0000e0 46 f7 d8 ce 0b e8 3e c6 13 a6 2c b6 d6 cc 17 26
    0000f0 e3 c3 17 8e 9e 45 56 1e 41 ef 29 1a a8 65 c8 3a
    000100
    000000 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
    000010 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
    000020 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
    000030 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
    000040 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
    000050 00 00 00 00 f4 90 65 aa 8b f2 5e 31 01 53 b4 d4
    000060 06 c0 23 a2 99 3d 01 e4 b0 c1 b1 55 0f 80 63 cf
    000070 33 24 d8 3a 1d 5e cd 2c ba c0 d0 18 6f bc 97 46
    000080 1e 19 51 b1 90 15 af 80 5e d1 08 0d eb b0 6c ab
    000090 6a b4 fe 62 37 c5 e1 ee 93 c3 58 78 91 2a d5 23
    0000a0 63 50 eb 1f 3b 84 35 18 cf b2 a4 b8 46 69 9e cf
    0000b0 0c 95 af 03 51 45 a8 42 f1 64 c9 55 fc 69 76 63
    0000c0 98 9d 82 fa 76 85 24 da 80 07 29 fe 4e 76 0c 61
    0000d0 ff 23 94 4f c8 5c ce 0b 50 e8 31 bc 9d ce f4 ca
    0000e0 be ca 28 da e6 fa cc 64 1c ec a8 41 db fe 42 bd
    0000f0 a0 e2 4b 32 b4 52 ba 03 70 8e c1 8e d0 50 3a c6
    000100
    
    To my untrained mental entropy detector, the first several bytes of
    each read from /dev/hwrng seem to not be very random (i.e. all zero).
    
    When I revert the patch (apply this patch), I get back to what we have
    in v4.9, which looks like (much more random appearing):
    
    $ dd if=/dev/hwrng bs=256 count=1 | od -t x1 -A x -v > rng-good.txt
    1+0 records in
    1+0 records out
    256 bytes (256 B) copied, 0.000252233 s, 1.0 MB/s
    $ dd if=/dev/hwrng bs=256 count=1 | od -t x1 -A x -v >> rng-good.txt
    1+0 records in
    1+0 records out
    256 bytes (256 B) copied, 0.000113571 s, 2.3 MB/s
    $ cat rng-good.txt
    000000 75 d1 2d 19 68 1f d2 26 a1 49 22 61 66 e8 09 e5
    000010 e0 4e 10 d0 1a 2c 45 5d 59 04 79 8e e2 b7 2c 2e
    000020 e8 ad da 34 d5 56 51 3d 58 29 c7 7a 8e ed 22 67
    000030 f9 25 b9 fb c6 b7 9c 35 1f 84 21 35 c1 1d 48 34
    000040 45 7c f6 f1 57 63 1a 88 38 e8 81 f0 a9 63 ad 0e
    000050 be 5d 3e 74 2e 4e cb 36 c2 01 a8 14 e1 38 e1 bb
    000060 23 79 09 56 77 19 ff 98 e8 44 f3 27 eb 6e 0a cb
    000070 c9 36 e3 2a 96 13 07 a0 90 3f 3b bd 1d 04 1d 67
    000080 be 33 14 f8 02 c2 a4 02 ab 8b 5b 74 86 17 f0 5e
    000090 a1 d7 aa ef a6 21 7b 93 d1 85 86 eb 4e 8c d0 4c
    0000a0 56 ac e4 45 27 44 84 9f 71 db 36 b9 f7 47 d7 b3
    0000b0 f2 9c 62 41 a3 46 2b 5b e3 80 63 a4 35 b5 3c f4
    0000c0 bc 1e 3a ad e4 59 4a 98 6c e8 8d ff 1b 16 f8 52
    0000d0 05 5c 2f 52 2a 0f 45 5b 51 fb 93 97 a4 49 4f 06
    0000e0 f3 a0 d1 1e ba 3d ed a7 60 8f bb 84 2c 21 94 2d
    0000f0 b3 66 a6 61 1e 58 30 24 85 f8 c8 18 c3 77 00 22
    000100
    000000 73 ca cc a1 d9 bb 21 8d c3 5c f3 ab 43 6d a7 a4
    000010 4a fd c5 f4 9c ba 4a 0f b1 2e 19 15 4e 84 26 e0
    000020 67 c9 f2 52 4d 65 1f 81 b7 8b 6d 2b 56 7b 99 75
    000030 2e cd d0 db 08 0c 4b df f3 83 c6 83 00 2e 2b b8
    000040 0f af 61 1d f2 02 35 74 b5 a4 6f 28 f3 a1 09 12
    000050 f2 53 b5 d2 da 45 01 e5 12 d6 46 f8 0b db ed 51
    000060 7b f4 0d 54 e0 63 ea 22 e2 1d d0 d6 d0 e7 7e e0
    000070 93 91 fb 87 95 43 41 28 de 3d 8b a3 a8 8f c4 9e
    000080 30 95 12 7a b2 27 28 ff 37 04 2e 09 7c dd 7c 12
    000090 e1 50 60 fb 6d 5f a8 65 14 40 89 e3 4c d2 87 8f
    0000a0 34 76 7e 66 7a 8e 6b a3 fc cf 38 52 2e f9 26 f0
    0000b0 98 63 15 06 34 99 b2 88 4f aa d8 14 88 71 f1 81
    0000c0 be 51 11 2b f4 7e a0 1e 12 b2 44 2e f6 8d 84 ea
    0000d0 63 82 2b 66 b3 9a fd 08 73 5a c2 cc ab 5a af b1
    0000e0 88 e3 a6 80 4b fc db ed 71 e0 ae c0 0a a4 8c 35
    0000f0 eb 89 f9 8a 4b 52 59 6f 09 7c 01 3f 56 e7 c7 bf
    000100
    
    Signed-off-by: David Daney <david.daney@cavium.com>
    Acked-by: Herbert Xu <herbert@gondor.apana.org.au>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/char/hw_random/core.c b/drivers/char/hw_random/core.c
index 6ce5ce8be2f2..87fba424817e 100644
--- a/drivers/char/hw_random/core.c
+++ b/drivers/char/hw_random/core.c
@@ -92,7 +92,6 @@ static void add_early_randomness(struct hwrng *rng)
 	mutex_unlock(&reading_mutex);
 	if (bytes_read > 0)
 		add_device_randomness(rng_buffer, bytes_read);
-	memset(rng_buffer, 0, size);
 }
 
 static inline void cleanup_rng(struct kref *kref)
@@ -288,7 +287,6 @@ static ssize_t rng_dev_read(struct file *filp, char __user *buf,
 		}
 	}
 out:
-	memset(rng_buffer, 0, rng_buffer_size());
 	return ret ? : err;
 
 out_unlock_reading:
@@ -427,7 +425,6 @@ static int hwrng_fillfn(void *unused)
 		/* Outside lock, sure, but y'know: randomness. */
 		add_hwgenerator_randomness((void *)rng_fillbuf, rc,
 					   rc * current_quality * 8 >> 10);
-		memset(rng_fillbuf, 0, rng_buffer_size());
 	}
 	hwrng_fill = NULL;
 	return 0;

commit 079840bd13f793b915f6c8e44452eeb4a0aba8ba
Author: Corentin LABBE <clabbe.montjoie@gmail.com>
Date:   Tue Dec 13 15:51:14 2016 +0100

    hwrng: core - remove unused PFX macro
    
    This patch remove the unused PFX macro.
    
    Signed-off-by: Corentin Labbe <clabbe.montjoie@gmail.com>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/char/hw_random/core.c b/drivers/char/hw_random/core.c
index c5f131d90473..68fdc60ddf50 100644
--- a/drivers/char/hw_random/core.c
+++ b/drivers/char/hw_random/core.c
@@ -25,7 +25,6 @@
 #include <linux/uaccess.h>
 
 #define RNG_MODULE_NAME		"hw_random"
-#define PFX			RNG_MODULE_NAME ": "
 
 static struct hwrng *current_rng;
 static struct task_struct *hwrng_fill;

commit fd50d71f94fb1c8614098949db068cd4c8dbb91d
Author: Corentin LABBE <clabbe.montjoie@gmail.com>
Date:   Tue Dec 13 15:51:13 2016 +0100

    hwrng: core - Move hwrng miscdev minor number to include/linux/miscdevice.h
    
    This patch move the define for hwrng's miscdev minor number to
    include/linux/miscdevice.h.
    It's better that all minor number are in the same place.
    Rename it to HWRNG_MINOR (from RNG_MISCDEV_MINOR) in he process since
    no other miscdev define have MISCDEV in their name.
    
    Signed-off-by: Corentin Labbe <clabbe.montjoie@gmail.com>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/char/hw_random/core.c b/drivers/char/hw_random/core.c
index f81fd72b6692..c5f131d90473 100644
--- a/drivers/char/hw_random/core.c
+++ b/drivers/char/hw_random/core.c
@@ -26,7 +26,6 @@
 
 #define RNG_MODULE_NAME		"hw_random"
 #define PFX			RNG_MODULE_NAME ": "
-#define RNG_MISCDEV_MINOR	183 /* official */
 
 static struct hwrng *current_rng;
 static struct task_struct *hwrng_fill;
@@ -285,7 +284,7 @@ static const struct file_operations rng_chrdev_ops = {
 static const struct attribute_group *rng_dev_groups[];
 
 static struct miscdevice rng_miscdev = {
-	.minor		= RNG_MISCDEV_MINOR,
+	.minor		= HWRNG_MINOR,
 	.name		= RNG_MODULE_NAME,
 	.nodename	= "hwrng",
 	.fops		= &rng_chrdev_ops,

commit affdec58dafcf1cd7ff1dfaf2e4539b5532d0e84
Author: Corentin LABBE <clabbe.montjoie@gmail.com>
Date:   Tue Dec 13 15:51:12 2016 +0100

    hwrng: core - Replace asm/uaccess.h by linux/uaccess.h
    
    This patch fix the checkpatch warning about asm/uaccess.h.
    In the same time, we sort the headers in alphabetical order.
    
    Signed-off-by: Corentin Labbe <clabbe.montjoie@gmail.com>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/char/hw_random/core.c b/drivers/char/hw_random/core.c
index 6266d1589bc6..f81fd72b6692 100644
--- a/drivers/char/hw_random/core.c
+++ b/drivers/char/hw_random/core.c
@@ -10,18 +10,18 @@
  * of the GNU General Public License, incorporated herein by reference.
  */
 
+#include <linux/delay.h>
 #include <linux/device.h>
+#include <linux/err.h>
+#include <linux/fs.h>
 #include <linux/hw_random.h>
-#include <linux/module.h>
 #include <linux/kernel.h>
-#include <linux/fs.h>
-#include <linux/sched.h>
-#include <linux/miscdevice.h>
 #include <linux/kthread.h>
-#include <linux/delay.h>
-#include <linux/slab.h>
+#include <linux/miscdevice.h>
+#include <linux/module.h>
 #include <linux/random.h>
-#include <linux/err.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
 #include <linux/uaccess.h>
 
 #define RNG_MODULE_NAME		"hw_random"

commit dd8014830d2b1fdf5328978ada706df3ec180c21
Author: Corentin LABBE <clabbe.montjoie@gmail.com>
Date:   Tue Dec 13 15:51:11 2016 +0100

    hwrng: core - Rewrite the header
    
    checkpatch have lot of complaint about header.
    Furthermore, the header have some offtopic/useless information.
    
    This patch rewrite a proper header.
    
    Signed-off-by: Corentin Labbe <clabbe.montjoie@gmail.com>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/char/hw_random/core.c b/drivers/char/hw_random/core.c
index 3e565e12f397..6266d1589bc6 100644
--- a/drivers/char/hw_random/core.c
+++ b/drivers/char/hw_random/core.c
@@ -1,33 +1,13 @@
 /*
-        Added support for the AMD Geode LX RNG
-	(c) Copyright 2004-2005 Advanced Micro Devices, Inc.
-
-	derived from
-
- 	Hardware driver for the Intel/AMD/VIA Random Number Generators (RNG)
-	(c) Copyright 2003 Red Hat Inc <jgarzik@redhat.com>
-
- 	derived from
-
-        Hardware driver for the AMD 768 Random Number Generator (RNG)
-        (c) Copyright 2001 Red Hat Inc <alan@redhat.com>
-
- 	derived from
-
-	Hardware driver for Intel i810 Random Number Generator (RNG)
-	Copyright 2000,2001 Jeff Garzik <jgarzik@pobox.com>
-	Copyright 2000,2001 Philipp Rumpf <prumpf@mandrakesoft.com>
-
-	Added generic RNG API
-	Copyright 2006 Michael Buesch <m@bues.ch>
-	Copyright 2005 (c) MontaVista Software, Inc.
-
-	Please read Documentation/hw_random.txt for details on use.
-
-	----------------------------------------------------------
-	This software may be used and distributed according to the terms
-        of the GNU General Public License, incorporated herein by reference.
-
+ * hw_random/core.c: HWRNG core API
+ *
+ * Copyright 2006 Michael Buesch <m@bues.ch>
+ * Copyright 2005 (c) MontaVista Software, Inc.
+ *
+ * Please read Documentation/hw_random.txt for details on use.
+ *
+ * This software may be used and distributed according to the terms
+ * of the GNU General Public License, incorporated herein by reference.
  */
 
 #include <linux/device.h>

commit 2a971e3b248775f808950bdc0ac75f12a2853eff
Author: Corentin LABBE <clabbe.montjoie@gmail.com>
Date:   Tue Dec 13 15:51:10 2016 +0100

    hwrng: core - rewrite better comparison to NULL
    
    This patch fix the checkpatch warning "Comparison to NULL could be written "!ptr"
    
    Signed-off-by: Corentin Labbe <clabbe.montjoie@gmail.com>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/char/hw_random/core.c b/drivers/char/hw_random/core.c
index 4d03b9798e25..3e565e12f397 100644
--- a/drivers/char/hw_random/core.c
+++ b/drivers/char/hw_random/core.c
@@ -442,8 +442,7 @@ int hwrng_register(struct hwrng *rng)
 	int err = -EINVAL;
 	struct hwrng *old_rng, *tmp;
 
-	if (rng->name == NULL ||
-	    (rng->data_read == NULL && rng->read == NULL))
+	if (!rng->name || (!rng->data_read && !rng->read))
 		goto out;
 
 	mutex_lock(&rng_mutex);

commit 6bc17d90e62d16828d1a2113b54cfa4e04582fb6
Author: Corentin LABBE <clabbe.montjoie@gmail.com>
Date:   Tue Dec 13 15:51:09 2016 +0100

    hwrng: core - do not use multiple blank lines
    
    This patch fix the checkpatch warning "Please don't use multiple blank lines"
    
    Signed-off-by: Corentin Labbe <clabbe.montjoie@gmail.com>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/char/hw_random/core.c b/drivers/char/hw_random/core.c
index 6ce5ce8be2f2..4d03b9798e25 100644
--- a/drivers/char/hw_random/core.c
+++ b/drivers/char/hw_random/core.c
@@ -30,7 +30,6 @@
 
  */
 
-
 #include <linux/device.h>
 #include <linux/hw_random.h>
 #include <linux/module.h>
@@ -45,12 +44,10 @@
 #include <linux/err.h>
 #include <linux/uaccess.h>
 
-
 #define RNG_MODULE_NAME		"hw_random"
 #define PFX			RNG_MODULE_NAME ": "
 #define RNG_MISCDEV_MINOR	183 /* official */
 
-
 static struct hwrng *current_rng;
 static struct task_struct *hwrng_fill;
 static LIST_HEAD(rng_list);
@@ -298,7 +295,6 @@ static ssize_t rng_dev_read(struct file *filp, char __user *buf,
 	goto out;
 }
 
-
 static const struct file_operations rng_chrdev_ops = {
 	.owner		= THIS_MODULE,
 	.open		= rng_dev_open,
@@ -316,7 +312,6 @@ static struct miscdevice rng_miscdev = {
 	.groups		= rng_dev_groups,
 };
 
-
 static ssize_t hwrng_attr_current_store(struct device *dev,
 					struct device_attribute *attr,
 					const char *buf, size_t len)

commit 7c0f6ba682b9c7632072ffbedf8d328c8f3c42ba
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Dec 24 11:46:01 2016 -0800

    Replace <asm/uaccess.h> with <linux/uaccess.h> globally
    
    This was entirely automated, using the script by Al:
    
      PATT='^[[:blank:]]*#[[:blank:]]*include[[:blank:]]*<asm/uaccess.h>'
      sed -i -e "s!$PATT!#include <linux/uaccess.h>!" \
            $(git grep -l "$PATT"|grep -v ^include/linux/uaccess.h)
    
    to do the replacement at the end of the merge window.
    
    Requested-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/char/hw_random/core.c b/drivers/char/hw_random/core.c
index f9766415ff10..6ce5ce8be2f2 100644
--- a/drivers/char/hw_random/core.c
+++ b/drivers/char/hw_random/core.c
@@ -43,7 +43,7 @@
 #include <linux/slab.h>
 #include <linux/random.h>
 #include <linux/err.h>
-#include <asm/uaccess.h>
+#include <linux/uaccess.h>
 
 
 #define RNG_MODULE_NAME		"hw_random"

commit 2cc751545854d7bd7eedf4d7e377bb52e176cd07
Author: Stephan Mueller <smueller@chronox.de>
Date:   Sat Oct 22 15:57:05 2016 +0200

    hwrng: core - zeroize buffers with random data
    
    The HWRNG core allocates two buffers during initialization which are
    used to obtain random data. After that data is processed, it is now
    zeroized as it is possible that the HWRNG core will not be asked to
    produce more random data for a long time. This prevents leaving such
    sensitive data in memory.
    
    Signed-off-by: Stephan Mueller <smueller@chronox.de>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/char/hw_random/core.c b/drivers/char/hw_random/core.c
index d2d2c89de5b4..f9766415ff10 100644
--- a/drivers/char/hw_random/core.c
+++ b/drivers/char/hw_random/core.c
@@ -92,6 +92,7 @@ static void add_early_randomness(struct hwrng *rng)
 	mutex_unlock(&reading_mutex);
 	if (bytes_read > 0)
 		add_device_randomness(rng_buffer, bytes_read);
+	memset(rng_buffer, 0, size);
 }
 
 static inline void cleanup_rng(struct kref *kref)
@@ -287,6 +288,7 @@ static ssize_t rng_dev_read(struct file *filp, char __user *buf,
 		}
 	}
 out:
+	memset(rng_buffer, 0, rng_buffer_size());
 	return ret ? : err;
 
 out_unlock_reading:
@@ -425,6 +427,7 @@ static int hwrng_fillfn(void *unused)
 		/* Outside lock, sure, but y'know: randomness. */
 		add_hwgenerator_randomness((void *)rng_fillbuf, rc,
 					   rc * current_quality * 8 >> 10);
+		memset(rng_fillbuf, 0, rng_buffer_size());
 	}
 	hwrng_fill = NULL;
 	return 0;

commit 6d4952d9d9d4dc2bb9c0255d95a09405a1e958f7
Author: Andrew Lutomirski <luto@kernel.org>
Date:   Mon Oct 17 10:06:27 2016 -0700

    hwrng: core - Don't use a stack buffer in add_early_randomness()
    
    hw_random carefully avoids using a stack buffer except in
    add_early_randomness().  This causes a crash in virtio_rng if
    CONFIG_VMAP_STACK=y.
    
    Reported-by: Matt Mullins <mmullins@mmlx.us>
    Tested-by: Matt Mullins <mmullins@mmlx.us>
    Fixes: d3cc7996473a ("hwrng: fetch randomness only after device init")
    Signed-off-by: Andy Lutomirski <luto@kernel.org>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/char/hw_random/core.c b/drivers/char/hw_random/core.c
index 482794526e8c..d2d2c89de5b4 100644
--- a/drivers/char/hw_random/core.c
+++ b/drivers/char/hw_random/core.c
@@ -84,14 +84,14 @@ static size_t rng_buffer_size(void)
 
 static void add_early_randomness(struct hwrng *rng)
 {
-	unsigned char bytes[16];
 	int bytes_read;
+	size_t size = min_t(size_t, 16, rng_buffer_size());
 
 	mutex_lock(&reading_mutex);
-	bytes_read = rng_get_data(rng, bytes, sizeof(bytes), 1);
+	bytes_read = rng_get_data(rng, rng_buffer, size, 1);
 	mutex_unlock(&reading_mutex);
 	if (bytes_read > 0)
-		add_device_randomness(bytes, bytes_read);
+		add_device_randomness(rng_buffer, bytes_read);
 }
 
 static inline void cleanup_rng(struct kref *kref)

commit 58b022acac8dd435dad0b162ad92cbe8ec90a703
Author: PrasannaKumar Muralidharan <prasannatsmkumar@gmail.com>
Date:   Wed Sep 7 20:18:02 2016 +0530

    hwrng: core - Allocate memory during module init
    
    In core rng_buffer and rng_fillbuf is allocated in hwrng_register only
    once and it is freed during module exit. This patch moves allocating
    rng_buffer and rng_fillbuf from hwrng_register to rng core's init. This
    avoids checking whether rng_buffer and rng_fillbuf was allocated from
    every hwrng_register call. Also moving them to module init makes it
    explicit that it is freed in module exit.
    
    Change in v2:
    Fix memory leak when register_miscdev fails.
    
    Signed-off-by: PrasannaKumar Muralidharan <prasannatsmkumar@gmail.com>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/char/hw_random/core.c b/drivers/char/hw_random/core.c
index 9203f2d130c0..482794526e8c 100644
--- a/drivers/char/hw_random/core.c
+++ b/drivers/char/hw_random/core.c
@@ -449,22 +449,6 @@ int hwrng_register(struct hwrng *rng)
 		goto out;
 
 	mutex_lock(&rng_mutex);
-
-	/* kmalloc makes this safe for virt_to_page() in virtio_rng.c */
-	err = -ENOMEM;
-	if (!rng_buffer) {
-		rng_buffer = kmalloc(rng_buffer_size(), GFP_KERNEL);
-		if (!rng_buffer)
-			goto out_unlock;
-	}
-	if (!rng_fillbuf) {
-		rng_fillbuf = kmalloc(rng_buffer_size(), GFP_KERNEL);
-		if (!rng_fillbuf) {
-			kfree(rng_buffer);
-			goto out_unlock;
-		}
-	}
-
 	/* Must not register two RNGs with the same name. */
 	err = -EEXIST;
 	list_for_each_entry(tmp, &rng_list, list) {
@@ -573,7 +557,26 @@ EXPORT_SYMBOL_GPL(devm_hwrng_unregister);
 
 static int __init hwrng_modinit(void)
 {
-	return register_miscdev();
+	int ret = -ENOMEM;
+
+	/* kmalloc makes this safe for virt_to_page() in virtio_rng.c */
+	rng_buffer = kmalloc(rng_buffer_size(), GFP_KERNEL);
+	if (!rng_buffer)
+		return -ENOMEM;
+
+	rng_fillbuf = kmalloc(rng_buffer_size(), GFP_KERNEL);
+	if (!rng_fillbuf) {
+		kfree(rng_buffer);
+		return -ENOMEM;
+	}
+
+	ret = register_miscdev();
+	if (ret) {
+		kfree(rng_fillbuf);
+		kfree(rng_buffer);
+	}
+
+	return ret;
 }
 
 static void __exit hwrng_modexit(void)

commit 1ab87298cb59b649d8d648d25dc15b36ab865f5a
Author: Jiri Slaby <jslaby@suse.cz>
Date:   Fri Nov 27 16:50:43 2015 +0100

    hwrng: core - sleep interruptible in read
    
    hwrng kthread can be waiting via hwrng_fillfn for some data from a rng
    like virtio-rng:
    hwrng           D ffff880093e17798     0   382      2 0x00000000
    ...
    Call Trace:
     [<ffffffff817339c6>] wait_for_completion_killable+0x96/0x210
     [<ffffffffa00aa1b7>] virtio_read+0x57/0xf0 [virtio_rng]
     [<ffffffff814f4a35>] hwrng_fillfn+0x75/0x130
     [<ffffffff810aa243>] kthread+0xf3/0x110
    
    And when some user program tries to read the /dev node in this state,
    we get:
    rngd            D ffff880093e17798     0   762      1 0x00000004
    ...
    Call Trace:
     [<ffffffff817351ac>] mutex_lock_nested+0x15c/0x3e0
     [<ffffffff814f478e>] rng_dev_read+0x6e/0x240
     [<ffffffff81231958>] __vfs_read+0x28/0xe0
     [<ffffffff81232393>] vfs_read+0x83/0x130
    
    And this is indeed unkillable. So use mutex_lock_interruptible
    instead of mutex_lock in rng_dev_read and exit immediatelly when
    interrupted. And possibly return already read data, if any (as POSIX
    allows).
    
    v2: use ERESTARTSYS instead of EINTR
    
    Signed-off-by: Jiri Slaby <jslaby@suse.cz>
    Cc: Matt Mackall <mpm@selenic.com>
    Cc: Herbert Xu <herbert@gondor.apana.org.au>
    Cc: <linux-crypto@vger.kernel.org>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/char/hw_random/core.c b/drivers/char/hw_random/core.c
index 6f497aa1b276..9203f2d130c0 100644
--- a/drivers/char/hw_random/core.c
+++ b/drivers/char/hw_random/core.c
@@ -238,7 +238,10 @@ static ssize_t rng_dev_read(struct file *filp, char __user *buf,
 			goto out;
 		}
 
-		mutex_lock(&reading_mutex);
+		if (mutex_lock_interruptible(&reading_mutex)) {
+			err = -ERESTARTSYS;
+			goto out_put;
+		}
 		if (!data_avail) {
 			bytes_read = rng_get_data(rng, rng_buffer,
 				rng_buffer_size(),
@@ -288,6 +291,7 @@ static ssize_t rng_dev_read(struct file *filp, char __user *buf,
 
 out_unlock_reading:
 	mutex_unlock(&reading_mutex);
+out_put:
 	put_rng(rng);
 	goto out;
 }

commit d9a53b01404fa602117220e98bb6c9b2b63f1e7f
Author: Lee Jones <lee.jones@linaro.org>
Date:   Thu Sep 17 14:45:53 2015 +0100

    hwrng: core - Simplify RNG switching from sysfs
    
    If we attempt to use sysfs to change the current RNG in the usual
    way i.e. issuing something like:
    
    `echo 8a8a000.rng > /sys/devices/virtual/misc/hw_random/rng_current`
    
    ... it will fail because the code doesn't currently take the '\n'
    into consideration.  Well, now it does.
    
    Signed-off-by: Lee Jones <lee.jones@linaro.org>
    Acked-by: Peter Korsgaard <peter@korsgaard.com>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/char/hw_random/core.c b/drivers/char/hw_random/core.c
index 5643b65cee20..6f497aa1b276 100644
--- a/drivers/char/hw_random/core.c
+++ b/drivers/char/hw_random/core.c
@@ -323,7 +323,7 @@ static ssize_t hwrng_attr_current_store(struct device *dev,
 		return -ERESTARTSYS;
 	err = -ENODEV;
 	list_for_each_entry(rng, &rng_list, list) {
-		if (strcmp(rng->name, buf) == 0) {
+		if (sysfs_streq(rng->name, buf)) {
 			err = 0;
 			if (rng != current_rng)
 				err = set_current_rng(rng);

commit 17fb874dee093139923af8ed36061faa92cc8e79
Author: Martin Schwidefsky <schwidefsky@de.ibm.com>
Date:   Fri Jul 24 13:13:30 2015 +0200

    hwrng: core - correct error check of kthread_run call
    
    The kthread_run() function can return two different error values
    but the hwrng core only checks for -ENOMEM. If the other error
    value -EINTR is returned it is assigned to hwrng_fill and later
    used on a kthread_stop() call which naturally crashes.
    
    Cc: stable@vger.kernel.org
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/char/hw_random/core.c b/drivers/char/hw_random/core.c
index da8faf78536a..5643b65cee20 100644
--- a/drivers/char/hw_random/core.c
+++ b/drivers/char/hw_random/core.c
@@ -429,7 +429,7 @@ static int hwrng_fillfn(void *unused)
 static void start_khwrngd(void)
 {
 	hwrng_fill = kthread_run(hwrng_fillfn, NULL, "hwrng");
-	if (hwrng_fill == ERR_PTR(-ENOMEM)) {
+	if (IS_ERR(hwrng_fill)) {
 		pr_err("hwrng_fill thread creation failed");
 		hwrng_fill = NULL;
 	}

commit 1fc149933fd49a5b0e7738dc0853dbfbac4ae0e1
Merge: 41d5e08ea86a ea5505fabd3b
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Apr 21 09:42:58 2015 -0700

    Merge tag 'char-misc-4.1-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/char-misc
    
    Pull char/misc driver updates from Greg KH:
     "Here's the big char/misc driver patchset for 4.1-rc1.
    
      Lots of different driver subsystem updates here, nothing major, full
      details are in the shortlog.
    
      All of this has been in linux-next for a while"
    
    * tag 'char-misc-4.1-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/char-misc: (133 commits)
      mei: trace: remove unused TRACE_SYSTEM_STRING
      DTS: ARM: OMAP3-N900: Add lis3lv02d support
      Documentation: DT: lis302: update wakeup binding
      lis3lv02d: DT: add wakeup unit 2 and wakeup threshold
      lis3lv02d: DT: use s32 to support negative values
      Drivers: hv: hv_balloon: correctly handle num_pages>INT_MAX case
      Drivers: hv: hv_balloon: correctly handle val.freeram<num_pages case
      mei: replace check for connection instead of transitioning
      mei: use mei_cl_is_connected consistently
      mei: fix mei_poll operation
      hv_vmbus: Add gradually increased delay for retries in vmbus_post_msg()
      Drivers: hv: hv_balloon: survive ballooning request with num_pages=0
      Drivers: hv: hv_balloon: eliminate jumps in piecewiese linear floor function
      Drivers: hv: hv_balloon: do not online pages in offline blocks
      hv: remove the per-channel workqueue
      hv: don't schedule new works in vmbus_onoffer()/vmbus_onoffer_rescind()
      hv: run non-blocking message handlers in the dispatch tasklet
      coresight: moving to new "hwtracing" directory
      coresight-tmc: Adding a status interface to sysfs
      coresight: remove the unnecessary configuration coresight-default-sink
      ...

commit 0daa7a0afd0fa7aad83cbde0fb341d7fbeac952c
Author: Takashi Iwai <tiwai@suse.de>
Date:   Mon Feb 2 15:44:55 2015 +0100

    hwrng: Avoid manual device_create_file() calls
    
    Use the new group field of struct miscdevice for managing the sysfs
    entries instead of manually adding/removing via device_create_file()
    and device_remove_file().  This simplifies the code a lot and fixes
    the possible races.
    
    Signed-off-by: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/char/hw_random/core.c b/drivers/char/hw_random/core.c
index 32a8a867f7f8..0a8194525baf 100644
--- a/drivers/char/hw_random/core.c
+++ b/drivers/char/hw_random/core.c
@@ -299,11 +299,14 @@ static const struct file_operations rng_chrdev_ops = {
 	.llseek		= noop_llseek,
 };
 
+static const struct attribute_group *rng_dev_groups[];
+
 static struct miscdevice rng_miscdev = {
 	.minor		= RNG_MISCDEV_MINOR,
 	.name		= RNG_MODULE_NAME,
 	.nodename	= "hwrng",
 	.fops		= &rng_chrdev_ops,
+	.groups		= rng_dev_groups,
 };
 
 
@@ -376,37 +379,22 @@ static DEVICE_ATTR(rng_available, S_IRUGO,
 		   hwrng_attr_available_show,
 		   NULL);
 
+static struct attribute *rng_dev_attrs[] = {
+	&dev_attr_rng_current.attr,
+	&dev_attr_rng_available.attr,
+	NULL
+};
+
+ATTRIBUTE_GROUPS(rng_dev);
 
 static void __exit unregister_miscdev(void)
 {
-	device_remove_file(rng_miscdev.this_device, &dev_attr_rng_available);
-	device_remove_file(rng_miscdev.this_device, &dev_attr_rng_current);
 	misc_deregister(&rng_miscdev);
 }
 
 static int __init register_miscdev(void)
 {
-	int err;
-
-	err = misc_register(&rng_miscdev);
-	if (err)
-		goto out;
-	err = device_create_file(rng_miscdev.this_device,
-				 &dev_attr_rng_current);
-	if (err)
-		goto err_misc_dereg;
-	err = device_create_file(rng_miscdev.this_device,
-				 &dev_attr_rng_available);
-	if (err)
-		goto err_remove_current;
-out:
-	return err;
-
-err_remove_current:
-	device_remove_file(rng_miscdev.this_device, &dev_attr_rng_current);
-err_misc_dereg:
-	misc_deregister(&rng_miscdev);
-	goto out;
+	return misc_register(&rng_miscdev);
 }
 
 static int hwrng_fillfn(void *unused)

commit 506bf0c0464ace57169aadcf02ae397999c57bdd
Author: Keith Packard <keithp@keithp.com>
Date:   Wed Mar 18 00:17:00 2015 -0700

    hwrng: core - allow perfect entropy from hardware devices
    
    Hardware random number quality is measured from 0 (no entropy) to 1024
    (perfect entropy). Allow hardware devices to assert the full range by
    truncating the device-provided value at 1024 instead of 1023.
    
    Signed-off-by: Keith Packard <keithp@keithp.com>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/char/hw_random/core.c b/drivers/char/hw_random/core.c
index 83161dde53ee..571ef61f8ea9 100644
--- a/drivers/char/hw_random/core.c
+++ b/drivers/char/hw_random/core.c
@@ -179,7 +179,8 @@ static int hwrng_init(struct hwrng *rng)
 	add_early_randomness(rng);
 
 	current_quality = rng->quality ? : default_quality;
-	current_quality &= 1023;
+	if (current_quality > 1024)
+		current_quality = 1024;
 
 	if (current_quality == 0 && hwrng_fill)
 		kthread_stop(hwrng_fill);

commit 4d9b519c9bcab5718053f8717dadad7b09b41f5e
Author: Dmitry Torokhov <dmitry.torokhov@gmail.com>
Date:   Thu Mar 12 14:00:02 2015 -0700

    hwrng: add devm_* interfaces
    
    This change adds devm_hwrng_register and devm_hwrng_unregister which
    use can simplify error unwinding and unbinding code paths in device
    drivers.
    
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/char/hw_random/core.c b/drivers/char/hw_random/core.c
index 32a8a867f7f8..83161dde53ee 100644
--- a/drivers/char/hw_random/core.c
+++ b/drivers/char/hw_random/core.c
@@ -536,6 +536,48 @@ void hwrng_unregister(struct hwrng *rng)
 }
 EXPORT_SYMBOL_GPL(hwrng_unregister);
 
+static void devm_hwrng_release(struct device *dev, void *res)
+{
+	hwrng_unregister(*(struct hwrng **)res);
+}
+
+static int devm_hwrng_match(struct device *dev, void *res, void *data)
+{
+	struct hwrng **r = res;
+
+	if (WARN_ON(!r || !*r))
+		return 0;
+
+	return *r == data;
+}
+
+int devm_hwrng_register(struct device *dev, struct hwrng *rng)
+{
+	struct hwrng **ptr;
+	int error;
+
+	ptr = devres_alloc(devm_hwrng_release, sizeof(*ptr), GFP_KERNEL);
+	if (!ptr)
+		return -ENOMEM;
+
+	error = hwrng_register(rng);
+	if (error) {
+		devres_free(ptr);
+		return error;
+	}
+
+	*ptr = rng;
+	devres_add(dev, ptr);
+	return 0;
+}
+EXPORT_SYMBOL_GPL(devm_hwrng_register);
+
+void devm_hwrng_unregister(struct device *dev, struct hwrng *rng)
+{
+	devres_release(dev, devm_hwrng_release, devm_hwrng_match, rng);
+}
+EXPORT_SYMBOL_GPL(devm_hwrng_unregister);
+
 static int __init hwrng_modinit(void)
 {
 	return register_miscdev();

commit 90ac41bd40ad0571a10826eb26d53c84bd791f29
Author: Herbert Xu <herbert@gondor.apana.org.au>
Date:   Tue Dec 23 16:40:22 2014 +1100

    hwrng: core - Move hwrng_init call into set_current_rng
    
    We always do hwrng_init in set_current_rng.  In fact, our current
    reference count system relies on this.  So make this explicit by
    moving hwrng_init into set_current_rng.
    
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/char/hw_random/core.c b/drivers/char/hw_random/core.c
index 787ef42a77b9..32a8a867f7f8 100644
--- a/drivers/char/hw_random/core.c
+++ b/drivers/char/hw_random/core.c
@@ -71,6 +71,7 @@ MODULE_PARM_DESC(default_quality,
 		 "default entropy content of hwrng per mill");
 
 static void drop_current_rng(void);
+static int hwrng_init(struct hwrng *rng);
 static void start_khwrngd(void);
 
 static inline int rng_get_data(struct hwrng *rng, u8 *buffer, size_t size,
@@ -103,11 +104,20 @@ static inline void cleanup_rng(struct kref *kref)
 	complete(&rng->cleanup_done);
 }
 
-static void set_current_rng(struct hwrng *rng)
+static int set_current_rng(struct hwrng *rng)
 {
+	int err;
+
 	BUG_ON(!mutex_is_locked(&rng_mutex));
+
+	err = hwrng_init(rng);
+	if (err)
+		return err;
+
 	drop_current_rng();
 	current_rng = rng;
+
+	return 0;
 }
 
 static void drop_current_rng(void)
@@ -149,7 +159,7 @@ static void put_rng(struct hwrng *rng)
 	mutex_unlock(&rng_mutex);
 }
 
-static inline int hwrng_init(struct hwrng *rng)
+static int hwrng_init(struct hwrng *rng)
 {
 	if (kref_get_unless_zero(&rng->ref))
 		goto skip_init;
@@ -310,15 +320,9 @@ static ssize_t hwrng_attr_current_store(struct device *dev,
 	err = -ENODEV;
 	list_for_each_entry(rng, &rng_list, list) {
 		if (strcmp(rng->name, buf) == 0) {
-			if (rng == current_rng) {
-				err = 0;
-				break;
-			}
-			err = hwrng_init(rng);
-			if (err)
-				break;
-			set_current_rng(rng);
 			err = 0;
+			if (rng != current_rng)
+				err = set_current_rng(rng);
 			break;
 		}
 	}
@@ -481,10 +485,9 @@ int hwrng_register(struct hwrng *rng)
 	old_rng = current_rng;
 	err = 0;
 	if (!old_rng) {
-		err = hwrng_init(rng);
+		err = set_current_rng(rng);
 		if (err)
 			goto out_unlock;
-		set_current_rng(rng);
 	}
 	list_add_tail(&rng->list, &rng_list);
 
@@ -518,8 +521,7 @@ void hwrng_unregister(struct hwrng *rng)
 
 			tail = list_entry(rng_list.prev, struct hwrng, list);
 
-			if (hwrng_init(tail) == 0)
-				set_current_rng(tail);
+			set_current_rng(tail);
 		}
 	}
 

commit ff77c150f71b761dcf29b9d1947df3165d2dc83e
Author: Herbert Xu <herbert@gondor.apana.org.au>
Date:   Tue Dec 23 16:40:21 2014 +1100

    hwrng: core - Drop current rng in set_current_rng
    
    Rather than having callers of set_current_rng call drop_current_rng,
    we can do it directly in set_current_rng.
    
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/char/hw_random/core.c b/drivers/char/hw_random/core.c
index 1d342f0cb0c1..787ef42a77b9 100644
--- a/drivers/char/hw_random/core.c
+++ b/drivers/char/hw_random/core.c
@@ -70,6 +70,7 @@ module_param(default_quality, ushort, 0644);
 MODULE_PARM_DESC(default_quality,
 		 "default entropy content of hwrng per mill");
 
+static void drop_current_rng(void);
 static void start_khwrngd(void);
 
 static inline int rng_get_data(struct hwrng *rng, u8 *buffer, size_t size,
@@ -105,6 +106,7 @@ static inline void cleanup_rng(struct kref *kref)
 static void set_current_rng(struct hwrng *rng)
 {
 	BUG_ON(!mutex_is_locked(&rng_mutex));
+	drop_current_rng();
 	current_rng = rng;
 }
 
@@ -315,7 +317,6 @@ static ssize_t hwrng_attr_current_store(struct device *dev,
 			err = hwrng_init(rng);
 			if (err)
 				break;
-			drop_current_rng();
 			set_current_rng(rng);
 			err = 0;
 			break;

commit ac3a497f13e42a99ed6fe188ebf2dcc39eb7ac20
Author: Herbert Xu <herbert@gondor.apana.org.au>
Date:   Tue Dec 23 16:40:19 2014 +1100

    hwrng: core - Do not register device opportunistically
    
    Currently we only register the device when a valid RNG is added.
    However the way it's done is buggy because we test whether there
    is a current RNG to determine whether we need to register.  As
    the current RNG may be missing due to a reinitialisation error
    this can lead to a reregistration of the device.
    
    As the device already has to handle a NULL current RNG anyway,
    let's just register the device always and remove the complexity.
    
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/char/hw_random/core.c b/drivers/char/hw_random/core.c
index 42827fd5f38d..1d342f0cb0c1 100644
--- a/drivers/char/hw_random/core.c
+++ b/drivers/char/hw_random/core.c
@@ -372,14 +372,14 @@ static DEVICE_ATTR(rng_available, S_IRUGO,
 		   NULL);
 
 
-static void unregister_miscdev(void)
+static void __exit unregister_miscdev(void)
 {
 	device_remove_file(rng_miscdev.this_device, &dev_attr_rng_available);
 	device_remove_file(rng_miscdev.this_device, &dev_attr_rng_current);
 	misc_deregister(&rng_miscdev);
 }
 
-static int register_miscdev(void)
+static int __init register_miscdev(void)
 {
 	int err;
 
@@ -484,12 +484,6 @@ int hwrng_register(struct hwrng *rng)
 		if (err)
 			goto out_unlock;
 		set_current_rng(rng);
-
-		err = register_miscdev();
-		if (err) {
-			drop_current_rng();
-			goto out_unlock;
-		}
 	}
 	list_add_tail(&rng->list, &rng_list);
 
@@ -530,7 +524,6 @@ void hwrng_unregister(struct hwrng *rng)
 
 	if (list_empty(&rng_list)) {
 		mutex_unlock(&rng_mutex);
-		unregister_miscdev();
 		if (hwrng_fill)
 			kthread_stop(hwrng_fill);
 	} else
@@ -540,16 +533,24 @@ void hwrng_unregister(struct hwrng *rng)
 }
 EXPORT_SYMBOL_GPL(hwrng_unregister);
 
-static void __exit hwrng_exit(void)
+static int __init hwrng_modinit(void)
+{
+	return register_miscdev();
+}
+
+static void __exit hwrng_modexit(void)
 {
 	mutex_lock(&rng_mutex);
 	BUG_ON(current_rng);
 	kfree(rng_buffer);
 	kfree(rng_fillbuf);
 	mutex_unlock(&rng_mutex);
+
+	unregister_miscdev();
 }
 
-module_exit(hwrng_exit);
+module_init(hwrng_modinit);
+module_exit(hwrng_modexit);
 
 MODULE_DESCRIPTION("H/W Random Number Generator (RNG) driver");
 MODULE_LICENSE("GPL");

commit 15b66cd54291186011f733cc750263f320b8a0a4
Author: Herbert Xu <herbert@gondor.apana.org.au>
Date:   Tue Dec 23 16:40:18 2014 +1100

    hwrng: core - Fix current_rng init/cleanup race yet again
    
    The kref solution is still buggy because we were only focusing
    on the register/unregister race.  The same race affects the
    setting of current_rng through sysfs.
    
    This patch fixes it by using kref_get_unless_zero.
    
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/char/hw_random/core.c b/drivers/char/hw_random/core.c
index 3dba2cf50241..42827fd5f38d 100644
--- a/drivers/char/hw_random/core.c
+++ b/drivers/char/hw_random/core.c
@@ -105,7 +105,6 @@ static inline void cleanup_rng(struct kref *kref)
 static void set_current_rng(struct hwrng *rng)
 {
 	BUG_ON(!mutex_is_locked(&rng_mutex));
-	kref_get(&rng->ref);
 	current_rng = rng;
 }
 
@@ -150,6 +149,9 @@ static void put_rng(struct hwrng *rng)
 
 static inline int hwrng_init(struct hwrng *rng)
 {
+	if (kref_get_unless_zero(&rng->ref))
+		goto skip_init;
+
 	if (rng->init) {
 		int ret;
 
@@ -157,6 +159,11 @@ static inline int hwrng_init(struct hwrng *rng)
 		if (ret)
 			return ret;
 	}
+
+	kref_init(&rng->ref);
+	reinit_completion(&rng->cleanup_done);
+
+skip_init:
 	add_early_randomness(rng);
 
 	current_quality = rng->quality ? : default_quality;
@@ -467,6 +474,9 @@ int hwrng_register(struct hwrng *rng)
 			goto out_unlock;
 	}
 
+	init_completion(&rng->cleanup_done);
+	complete(&rng->cleanup_done);
+
 	old_rng = current_rng;
 	err = 0;
 	if (!old_rng) {
@@ -494,8 +504,6 @@ int hwrng_register(struct hwrng *rng)
 		add_early_randomness(rng);
 	}
 
-	init_completion(&rng->cleanup_done);
-
 out_unlock:
 	mutex_unlock(&rng_mutex);
 out:

commit 77584ee57434813b50fc85cde995a6271a5081b7
Author: Herbert Xu <herbert@gondor.apana.org.au>
Date:   Tue Dec 23 16:40:17 2014 +1100

    hwrng: core - Use struct completion for cleanup_done
    
    There is no point in doing a manual completion for cleanup_done
    when struct completion fits in perfectly.
    
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/char/hw_random/core.c b/drivers/char/hw_random/core.c
index 6ec42252e46e..3dba2cf50241 100644
--- a/drivers/char/hw_random/core.c
+++ b/drivers/char/hw_random/core.c
@@ -60,7 +60,6 @@ static DEFINE_MUTEX(rng_mutex);
 static DEFINE_MUTEX(reading_mutex);
 static int data_avail;
 static u8 *rng_buffer, *rng_fillbuf;
-static DECLARE_WAIT_QUEUE_HEAD(rng_done);
 static unsigned short current_quality;
 static unsigned short default_quality; /* = 0; default to "off" */
 
@@ -100,10 +99,7 @@ static inline void cleanup_rng(struct kref *kref)
 	if (rng->cleanup)
 		rng->cleanup(rng);
 
-	/* cleanup_done should be updated after cleanup finishes */
-	smp_wmb();
-	rng->cleanup_done = true;
-	wake_up_all(&rng_done);
+	complete(&rng->cleanup_done);
 }
 
 static void set_current_rng(struct hwrng *rng)
@@ -498,7 +494,7 @@ int hwrng_register(struct hwrng *rng)
 		add_early_randomness(rng);
 	}
 
-	rng->cleanup_done = false;
+	init_completion(&rng->cleanup_done);
 
 out_unlock:
 	mutex_unlock(&rng_mutex);
@@ -532,9 +528,7 @@ void hwrng_unregister(struct hwrng *rng)
 	} else
 		mutex_unlock(&rng_mutex);
 
-	/* Just in case rng is reading right now, wait. */
-	wait_event(rng_done, rng->cleanup_done &&
-		   atomic_read(&rng->ref.refcount) == 0);
+	wait_for_completion(&rng->cleanup_done);
 }
 EXPORT_SYMBOL_GPL(hwrng_unregister);
 

commit 2d2ec0642a85966b6a299bbcd94707982327ace8
Author: Rusty Russell <rusty@rustcorp.com.au>
Date:   Mon Dec 8 16:50:40 2014 +0800

    hwrng: don't init list element we're about to add to list.
    
    Another interesting anti-pattern.
    
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/char/hw_random/core.c b/drivers/char/hw_random/core.c
index e384ee3ed604..6ec42252e46e 100644
--- a/drivers/char/hw_random/core.c
+++ b/drivers/char/hw_random/core.c
@@ -485,7 +485,6 @@ int hwrng_register(struct hwrng *rng)
 			goto out_unlock;
 		}
 	}
-	INIT_LIST_HEAD(&rng->list);
 	list_add_tail(&rng->list, &rng_list);
 
 	if (old_rng && !rng->init) {

commit ebbbfa248389b176e2e62d8cf91814253849ccc9
Author: Rusty Russell <rusty@rustcorp.com.au>
Date:   Mon Dec 8 16:50:39 2014 +0800

    hwrng: don't double-check old_rng.
    
    Interesting anti-pattern.
    
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/char/hw_random/core.c b/drivers/char/hw_random/core.c
index 8d609a026465..e384ee3ed604 100644
--- a/drivers/char/hw_random/core.c
+++ b/drivers/char/hw_random/core.c
@@ -472,14 +472,13 @@ int hwrng_register(struct hwrng *rng)
 	}
 
 	old_rng = current_rng;
+	err = 0;
 	if (!old_rng) {
 		err = hwrng_init(rng);
 		if (err)
 			goto out_unlock;
 		set_current_rng(rng);
-	}
-	err = 0;
-	if (!old_rng) {
+
 		err = register_miscdev();
 		if (err) {
 			drop_current_rng();

commit a027f30d72f2c4d27d6dd9bd053205d3102de7d1
Author: Rusty Russell <rusty@rustcorp.com.au>
Date:   Mon Dec 8 16:50:38 2014 +0800

    hwrng: fix unregister race.
    
    The previous patch added one potential problem: we can still be
    reading from a hwrng when it's unregistered.  Add a wait for zero
    in the hwrng_unregister path.
    
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>
    Signed-off-by: Amos Kong <akong@redhat.com>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/char/hw_random/core.c b/drivers/char/hw_random/core.c
index 089c18dc579e..8d609a026465 100644
--- a/drivers/char/hw_random/core.c
+++ b/drivers/char/hw_random/core.c
@@ -60,6 +60,7 @@ static DEFINE_MUTEX(rng_mutex);
 static DEFINE_MUTEX(reading_mutex);
 static int data_avail;
 static u8 *rng_buffer, *rng_fillbuf;
+static DECLARE_WAIT_QUEUE_HEAD(rng_done);
 static unsigned short current_quality;
 static unsigned short default_quality; /* = 0; default to "off" */
 
@@ -98,6 +99,11 @@ static inline void cleanup_rng(struct kref *kref)
 
 	if (rng->cleanup)
 		rng->cleanup(rng);
+
+	/* cleanup_done should be updated after cleanup finishes */
+	smp_wmb();
+	rng->cleanup_done = true;
+	wake_up_all(&rng_done);
 }
 
 static void set_current_rng(struct hwrng *rng)
@@ -494,6 +500,8 @@ int hwrng_register(struct hwrng *rng)
 		add_early_randomness(rng);
 	}
 
+	rng->cleanup_done = false;
+
 out_unlock:
 	mutex_unlock(&rng_mutex);
 out:
@@ -525,6 +533,10 @@ void hwrng_unregister(struct hwrng *rng)
 			kthread_stop(hwrng_fill);
 	} else
 		mutex_unlock(&rng_mutex);
+
+	/* Just in case rng is reading right now, wait. */
+	wait_event(rng_done, rng->cleanup_done &&
+		   atomic_read(&rng->ref.refcount) == 0);
 }
 EXPORT_SYMBOL_GPL(hwrng_unregister);
 

commit 3a2c0ba5ad00c018c0bef39a2224aca950aa33f2
Author: Rusty Russell <rusty@rustcorp.com.au>
Date:   Mon Dec 8 16:50:37 2014 +0800

    hwrng: use reference counts on each struct hwrng.
    
    current_rng holds one reference, and we bump it every time we want
    to do a read from it.
    
    This means we only hold the rng_mutex to grab or drop a reference,
    so accessing /sys/devices/virtual/misc/hw_random/rng_current doesn't
    block on read of /dev/hwrng.
    
    Using a kref is overkill (we're always under the rng_mutex), but
    a standard pattern.
    
    This also solves the problem that the hwrng_fillfn thread was
    accessing current_rng without a lock, which could change (eg. to NULL)
    underneath it.
    
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>
    Signed-off-by: Amos Kong <akong@redhat.com>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/char/hw_random/core.c b/drivers/char/hw_random/core.c
index b4c0e873d362..089c18dc579e 100644
--- a/drivers/char/hw_random/core.c
+++ b/drivers/char/hw_random/core.c
@@ -42,6 +42,7 @@
 #include <linux/delay.h>
 #include <linux/slab.h>
 #include <linux/random.h>
+#include <linux/err.h>
 #include <asm/uaccess.h>
 
 
@@ -91,6 +92,60 @@ static void add_early_randomness(struct hwrng *rng)
 		add_device_randomness(bytes, bytes_read);
 }
 
+static inline void cleanup_rng(struct kref *kref)
+{
+	struct hwrng *rng = container_of(kref, struct hwrng, ref);
+
+	if (rng->cleanup)
+		rng->cleanup(rng);
+}
+
+static void set_current_rng(struct hwrng *rng)
+{
+	BUG_ON(!mutex_is_locked(&rng_mutex));
+	kref_get(&rng->ref);
+	current_rng = rng;
+}
+
+static void drop_current_rng(void)
+{
+	BUG_ON(!mutex_is_locked(&rng_mutex));
+	if (!current_rng)
+		return;
+
+	/* decrease last reference for triggering the cleanup */
+	kref_put(&current_rng->ref, cleanup_rng);
+	current_rng = NULL;
+}
+
+/* Returns ERR_PTR(), NULL or refcounted hwrng */
+static struct hwrng *get_current_rng(void)
+{
+	struct hwrng *rng;
+
+	if (mutex_lock_interruptible(&rng_mutex))
+		return ERR_PTR(-ERESTARTSYS);
+
+	rng = current_rng;
+	if (rng)
+		kref_get(&rng->ref);
+
+	mutex_unlock(&rng_mutex);
+	return rng;
+}
+
+static void put_rng(struct hwrng *rng)
+{
+	/*
+	 * Hold rng_mutex here so we serialize in case they set_current_rng
+	 * on rng again immediately.
+	 */
+	mutex_lock(&rng_mutex);
+	if (rng)
+		kref_put(&rng->ref, cleanup_rng);
+	mutex_unlock(&rng_mutex);
+}
+
 static inline int hwrng_init(struct hwrng *rng)
 {
 	if (rng->init) {
@@ -113,12 +168,6 @@ static inline int hwrng_init(struct hwrng *rng)
 	return 0;
 }
 
-static inline void hwrng_cleanup(struct hwrng *rng)
-{
-	if (rng && rng->cleanup)
-		rng->cleanup(rng);
-}
-
 static int rng_dev_open(struct inode *inode, struct file *filp)
 {
 	/* enforce read-only access to this chrdev */
@@ -154,21 +203,22 @@ static ssize_t rng_dev_read(struct file *filp, char __user *buf,
 	ssize_t ret = 0;
 	int err = 0;
 	int bytes_read, len;
+	struct hwrng *rng;
 
 	while (size) {
-		if (mutex_lock_interruptible(&rng_mutex)) {
-			err = -ERESTARTSYS;
+		rng = get_current_rng();
+		if (IS_ERR(rng)) {
+			err = PTR_ERR(rng);
 			goto out;
 		}
-
-		if (!current_rng) {
+		if (!rng) {
 			err = -ENODEV;
-			goto out_unlock;
+			goto out;
 		}
 
 		mutex_lock(&reading_mutex);
 		if (!data_avail) {
-			bytes_read = rng_get_data(current_rng, rng_buffer,
+			bytes_read = rng_get_data(rng, rng_buffer,
 				rng_buffer_size(),
 				!(filp->f_flags & O_NONBLOCK));
 			if (bytes_read < 0) {
@@ -200,8 +250,8 @@ static ssize_t rng_dev_read(struct file *filp, char __user *buf,
 			ret += len;
 		}
 
-		mutex_unlock(&rng_mutex);
 		mutex_unlock(&reading_mutex);
+		put_rng(rng);
 
 		if (need_resched())
 			schedule_timeout_interruptible(1);
@@ -213,12 +263,11 @@ static ssize_t rng_dev_read(struct file *filp, char __user *buf,
 	}
 out:
 	return ret ? : err;
-out_unlock:
-	mutex_unlock(&rng_mutex);
-	goto out;
+
 out_unlock_reading:
 	mutex_unlock(&reading_mutex);
-	goto out_unlock;
+	put_rng(rng);
+	goto out;
 }
 
 
@@ -257,8 +306,8 @@ static ssize_t hwrng_attr_current_store(struct device *dev,
 			err = hwrng_init(rng);
 			if (err)
 				break;
-			hwrng_cleanup(current_rng);
-			current_rng = rng;
+			drop_current_rng();
+			set_current_rng(rng);
 			err = 0;
 			break;
 		}
@@ -272,17 +321,15 @@ static ssize_t hwrng_attr_current_show(struct device *dev,
 				       struct device_attribute *attr,
 				       char *buf)
 {
-	int err;
 	ssize_t ret;
-	const char *name = "none";
+	struct hwrng *rng;
 
-	err = mutex_lock_interruptible(&rng_mutex);
-	if (err)
-		return -ERESTARTSYS;
-	if (current_rng)
-		name = current_rng->name;
-	ret = snprintf(buf, PAGE_SIZE, "%s\n", name);
-	mutex_unlock(&rng_mutex);
+	rng = get_current_rng();
+	if (IS_ERR(rng))
+		return PTR_ERR(rng);
+
+	ret = snprintf(buf, PAGE_SIZE, "%s\n", rng ? rng->name : "none");
+	put_rng(rng);
 
 	return ret;
 }
@@ -353,12 +400,16 @@ static int hwrng_fillfn(void *unused)
 	long rc;
 
 	while (!kthread_should_stop()) {
-		if (!current_rng)
+		struct hwrng *rng;
+
+		rng = get_current_rng();
+		if (IS_ERR(rng) || !rng)
 			break;
 		mutex_lock(&reading_mutex);
-		rc = rng_get_data(current_rng, rng_fillbuf,
+		rc = rng_get_data(rng, rng_fillbuf,
 				  rng_buffer_size(), 1);
 		mutex_unlock(&reading_mutex);
+		put_rng(rng);
 		if (rc <= 0) {
 			pr_warn("hwrng: no data available\n");
 			msleep_interruptible(10000);
@@ -419,14 +470,13 @@ int hwrng_register(struct hwrng *rng)
 		err = hwrng_init(rng);
 		if (err)
 			goto out_unlock;
-		current_rng = rng;
+		set_current_rng(rng);
 	}
 	err = 0;
 	if (!old_rng) {
 		err = register_miscdev();
 		if (err) {
-			hwrng_cleanup(rng);
-			current_rng = NULL;
+			drop_current_rng();
 			goto out_unlock;
 		}
 	}
@@ -453,22 +503,21 @@ EXPORT_SYMBOL_GPL(hwrng_register);
 
 void hwrng_unregister(struct hwrng *rng)
 {
-	int err;
-
 	mutex_lock(&rng_mutex);
 
 	list_del(&rng->list);
 	if (current_rng == rng) {
-		hwrng_cleanup(rng);
-		if (list_empty(&rng_list)) {
-			current_rng = NULL;
-		} else {
-			current_rng = list_entry(rng_list.prev, struct hwrng, list);
-			err = hwrng_init(current_rng);
-			if (err)
-				current_rng = NULL;
+		drop_current_rng();
+		if (!list_empty(&rng_list)) {
+			struct hwrng *tail;
+
+			tail = list_entry(rng_list.prev, struct hwrng, list);
+
+			if (hwrng_init(tail) == 0)
+				set_current_rng(tail);
 		}
 	}
+
 	if (list_empty(&rng_list)) {
 		mutex_unlock(&rng_mutex);
 		unregister_miscdev();

commit 1dacb395d68a14825ee48c0843335e3181aea675
Author: Amos Kong <akong@redhat.com>
Date:   Mon Dec 8 16:50:36 2014 +0800

    hwrng: move some code out mutex_lock for avoiding underlying deadlock
    
    In next patch, we use reference counting for each struct hwrng,
    changing reference count also needs to take mutex_lock. Before
    releasing the lock, if we try to stop a kthread that waits to
    take the lock to reduce the referencing count, deadlock will
    occur.
    
    Signed-off-by: Amos Kong <akong@redhat.com>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/char/hw_random/core.c b/drivers/char/hw_random/core.c
index 2dd3144d69b1..b4c0e873d362 100644
--- a/drivers/char/hw_random/core.c
+++ b/drivers/char/hw_random/core.c
@@ -470,12 +470,12 @@ void hwrng_unregister(struct hwrng *rng)
 		}
 	}
 	if (list_empty(&rng_list)) {
+		mutex_unlock(&rng_mutex);
 		unregister_miscdev();
 		if (hwrng_fill)
 			kthread_stop(hwrng_fill);
-	}
-
-	mutex_unlock(&rng_mutex);
+	} else
+		mutex_unlock(&rng_mutex);
 }
 EXPORT_SYMBOL_GPL(hwrng_unregister);
 

commit 9372b35e11149c5314f56f939775e67d83057604
Author: Rusty Russell <rusty@rustcorp.com.au>
Date:   Mon Dec 8 16:50:35 2014 +0800

    hwrng: place mutex around read functions and buffers.
    
    There's currently a big lock around everything, and it means that we
    can't query sysfs (eg /sys/devices/virtual/misc/hw_random/rng_current)
    while the rng is reading.  This is a real problem when the rng is slow,
    or blocked (eg. virtio_rng with qemu's default /dev/random backend)
    
    This doesn't help (it leaves the current lock untouched), just adds a
    lock to protect the read function and the static buffers, in preparation
    for transition.
    
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/char/hw_random/core.c b/drivers/char/hw_random/core.c
index 1500cfd799a7..2dd3144d69b1 100644
--- a/drivers/char/hw_random/core.c
+++ b/drivers/char/hw_random/core.c
@@ -53,7 +53,10 @@
 static struct hwrng *current_rng;
 static struct task_struct *hwrng_fill;
 static LIST_HEAD(rng_list);
+/* Protects rng_list and current_rng */
 static DEFINE_MUTEX(rng_mutex);
+/* Protects rng read functions, data_avail, rng_buffer and rng_fillbuf */
+static DEFINE_MUTEX(reading_mutex);
 static int data_avail;
 static u8 *rng_buffer, *rng_fillbuf;
 static unsigned short current_quality;
@@ -81,7 +84,9 @@ static void add_early_randomness(struct hwrng *rng)
 	unsigned char bytes[16];
 	int bytes_read;
 
+	mutex_lock(&reading_mutex);
 	bytes_read = rng_get_data(rng, bytes, sizeof(bytes), 1);
+	mutex_unlock(&reading_mutex);
 	if (bytes_read > 0)
 		add_device_randomness(bytes, bytes_read);
 }
@@ -128,6 +133,7 @@ static inline int rng_get_data(struct hwrng *rng, u8 *buffer, size_t size,
 			int wait) {
 	int present;
 
+	BUG_ON(!mutex_is_locked(&reading_mutex));
 	if (rng->read)
 		return rng->read(rng, (void *)buffer, size, wait);
 
@@ -160,13 +166,14 @@ static ssize_t rng_dev_read(struct file *filp, char __user *buf,
 			goto out_unlock;
 		}
 
+		mutex_lock(&reading_mutex);
 		if (!data_avail) {
 			bytes_read = rng_get_data(current_rng, rng_buffer,
 				rng_buffer_size(),
 				!(filp->f_flags & O_NONBLOCK));
 			if (bytes_read < 0) {
 				err = bytes_read;
-				goto out_unlock;
+				goto out_unlock_reading;
 			}
 			data_avail = bytes_read;
 		}
@@ -174,7 +181,7 @@ static ssize_t rng_dev_read(struct file *filp, char __user *buf,
 		if (!data_avail) {
 			if (filp->f_flags & O_NONBLOCK) {
 				err = -EAGAIN;
-				goto out_unlock;
+				goto out_unlock_reading;
 			}
 		} else {
 			len = data_avail;
@@ -186,7 +193,7 @@ static ssize_t rng_dev_read(struct file *filp, char __user *buf,
 			if (copy_to_user(buf + ret, rng_buffer + data_avail,
 								len)) {
 				err = -EFAULT;
-				goto out_unlock;
+				goto out_unlock_reading;
 			}
 
 			size -= len;
@@ -194,6 +201,7 @@ static ssize_t rng_dev_read(struct file *filp, char __user *buf,
 		}
 
 		mutex_unlock(&rng_mutex);
+		mutex_unlock(&reading_mutex);
 
 		if (need_resched())
 			schedule_timeout_interruptible(1);
@@ -208,6 +216,9 @@ static ssize_t rng_dev_read(struct file *filp, char __user *buf,
 out_unlock:
 	mutex_unlock(&rng_mutex);
 	goto out;
+out_unlock_reading:
+	mutex_unlock(&reading_mutex);
+	goto out_unlock;
 }
 
 
@@ -344,13 +355,16 @@ static int hwrng_fillfn(void *unused)
 	while (!kthread_should_stop()) {
 		if (!current_rng)
 			break;
+		mutex_lock(&reading_mutex);
 		rc = rng_get_data(current_rng, rng_fillbuf,
 				  rng_buffer_size(), 1);
+		mutex_unlock(&reading_mutex);
 		if (rc <= 0) {
 			pr_warn("hwrng: no data available\n");
 			msleep_interruptible(10000);
 			continue;
 		}
+		/* Outside lock, sure, but y'know: randomness. */
 		add_hwgenerator_randomness((void *)rng_fillbuf, rc,
 					   rc * current_quality * 8 >> 10);
 	}

commit 61daf055ea42342dea1f7006833bc7cde20eeb34
Author: Rickard Strandqvist <rickard_strandqvist@spectrumdigital.se>
Date:   Thu Oct 16 23:17:23 2014 +0200

    hwrng: core - Changed from using strncat to strlcat
    
    The buf is used to hold the list of hwrng devices registered.
    The old code ensures we don't walk off the end of buf as we
    fill it, but it's unnecessarily complicated and thus difficult
    to maintain. Simplify it by using strlcat.
    
    Signed-off-by: Rickard Strandqvist <rickard_strandqvist@spectrumdigital.se>
    Reviewed-by: Jason Cooper <jason@lakedaemon.net>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/char/hw_random/core.c b/drivers/char/hw_random/core.c
index aa30a25c8d49..1500cfd799a7 100644
--- a/drivers/char/hw_random/core.c
+++ b/drivers/char/hw_random/core.c
@@ -281,7 +281,6 @@ static ssize_t hwrng_attr_available_show(struct device *dev,
 					 char *buf)
 {
 	int err;
-	ssize_t ret = 0;
 	struct hwrng *rng;
 
 	err = mutex_lock_interruptible(&rng_mutex);
@@ -289,16 +288,13 @@ static ssize_t hwrng_attr_available_show(struct device *dev,
 		return -ERESTARTSYS;
 	buf[0] = '\0';
 	list_for_each_entry(rng, &rng_list, list) {
-		strncat(buf, rng->name, PAGE_SIZE - ret - 1);
-		ret += strlen(rng->name);
-		strncat(buf, " ", PAGE_SIZE - ret - 1);
-		ret++;
+		strlcat(buf, rng->name, PAGE_SIZE);
+		strlcat(buf, " ", PAGE_SIZE);
 	}
-	strncat(buf, "\n", PAGE_SIZE - ret - 1);
-	ret++;
+	strlcat(buf, "\n", PAGE_SIZE);
 	mutex_unlock(&rng_mutex);
 
-	return ret;
+	return strlen(buf);
 }
 
 static DEVICE_ATTR(rng_current, S_IRUGO | S_IWUSR,

commit 801a71a858631109a64bf30b1c480b0a18386605
Merge: 155134fef2b6 eeec626366ff
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Aug 10 21:31:04 2014 -0700

    Merge tag 'virtio-next-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/rusty/linux
    
    Pull virtio updates from Rusty Russell.
    
    * tag 'virtio-next-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/rusty/linux:
      Revert "hwrng: virtio - ensure reads happen after successful probe"
      virtio: rng: delay hwrng_register() till driver is ready
      virtio: rng: re-arrange struct elements for better packing
      virtio: rng: remove unused struct element
      virtio: Replace DEFINE_PCI_DEVICE_TABLE macro use
      virtio: console: remove unnecessary null test before debugfs_remove_recursive

commit f4f142ed4ef835709c7e6d12eaca10d190bcebed
Merge: bb2cbf5e9367 e02b87659777
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Aug 6 08:16:24 2014 -0700

    Merge tag 'random_for_linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tytso/random
    
    Pull randomness updates from Ted Ts'o:
     "Cleanups and bug fixes to /dev/random, add a new getrandom(2) system
      call, which is a superset of OpenBSD's getentropy(2) call, for use
      with userspace crypto libraries such as LibreSSL.
    
      Also add the ability to have a kernel thread to pull entropy from
      hardware rng devices into /dev/random"
    
    * tag 'random_for_linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tytso/random:
      hwrng: Pass entropy to add_hwgenerator_randomness() in bits, not bytes
      random: limit the contribution of the hw rng to at most half
      random: introduce getrandom(2) system call
      hw_random: fix sparse warning (NULL vs 0 for pointer)
      random: use registers from interrupted code for CPU's w/o a cycle counter
      hwrng: add per-device entropy derating
      hwrng: create filler thread
      random: add_hwgenerator_randomness() for feeding entropy from devices
      random: use an improved fast_mix() function
      random: clean up interrupt entropy accounting for archs w/o cycle counters
      random: only update the last_pulled time if we actually transferred entropy
      random: remove unneeded hash of a portion of the entropy pool
      random: always update the entropy pool under the spinlock

commit e02b876597777ab26288dd2611a97b597d14d661
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Fri Jul 25 15:19:18 2014 -0700

    hwrng: Pass entropy to add_hwgenerator_randomness() in bits, not bytes
    
    rng_get_data() returns the number of bytes read from the hardware.
    The entropy argument to add_hwgenerator_randomness() is passed
    directly to credit_entropy_bits() so we should be passing the
    number of bits, not bytes here.
    
    Fixes: be4000bc464 "hwrng: create filler thread"
    Acked-by: Torsten Duwe <duwe@suse.de>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>
    Signed-off-by: Theodore Ts'o <tytso@mit.edu>

diff --git a/drivers/char/hw_random/core.c b/drivers/char/hw_random/core.c
index 349a3b852be9..33fd6633586d 100644
--- a/drivers/char/hw_random/core.c
+++ b/drivers/char/hw_random/core.c
@@ -342,7 +342,7 @@ static int hwrng_fillfn(void *unused)
 			continue;
 		}
 		add_hwgenerator_randomness((void *)rng_fillbuf, rc,
-					   (rc*current_quality)>>10);
+					   rc * current_quality * 8 >> 10);
 	}
 	hwrng_fill = NULL;
 	return 0;

commit eeec626366ffe558fc3d5685bd2b49a962acf57d
Author: Amit Shah <amit.shah@redhat.com>
Date:   Sun Jul 27 07:35:01 2014 +0930

    Revert "hwrng: virtio - ensure reads happen after successful probe"
    
    This reverts commit e052dbf554610e2104c5a7518c4d8374bed701bb.
    
    Now that we use the virtio ->scan() function to register with the hwrng
    core, we will not get read requests till probe is successfully finished.
    
    So revert the workaround we had in place to refuse read requests while
    we were not yet setup completely.
    
    Signed-off-by: Amit Shah <amit.shah@redhat.com>
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>

diff --git a/drivers/char/hw_random/core.c b/drivers/char/hw_random/core.c
index c4419ea1ab07..2a451b14b3cc 100644
--- a/drivers/char/hw_random/core.c
+++ b/drivers/char/hw_random/core.c
@@ -68,12 +68,6 @@ static void add_early_randomness(struct hwrng *rng)
 	unsigned char bytes[16];
 	int bytes_read;
 
-	/*
-	 * Currently only virtio-rng cannot return data during device
-	 * probe, and that's handled in virtio-rng.c itself.  If there
-	 * are more such devices, this call to rng_get_data can be
-	 * made conditional here instead of doing it per-device.
-	 */
 	bytes_read = rng_get_data(rng, bytes, sizeof(bytes), 1);
 	if (bytes_read > 0)
 		add_device_randomness(bytes, bytes_read);

commit 9dda727d37ff6ce1628dd2b8557ad011c49db377
Author: Torsten Duwe <duwe@lst.de>
Date:   Mon Jun 16 10:24:09 2014 -0400

    hw_random: fix sparse warning (NULL vs 0 for pointer)
    
    Signed-off-by: Torsten Duwe <duwe@suse.de>
    Signed-off-by: Theodore Ts'o <tytso@mit.edu>

diff --git a/drivers/char/hw_random/core.c b/drivers/char/hw_random/core.c
index 3aaf97c774f1..349a3b852be9 100644
--- a/drivers/char/hw_random/core.c
+++ b/drivers/char/hw_random/core.c
@@ -344,7 +344,7 @@ static int hwrng_fillfn(void *unused)
 		add_hwgenerator_randomness((void *)rng_fillbuf, rc,
 					   (rc*current_quality)>>10);
 	}
-	hwrng_fill = 0;
+	hwrng_fill = NULL;
 	return 0;
 }
 

commit 0f734e6e768b4b66737b3d3e13f1769a12ecff86
Author: Torsten Duwe <duwe@lst.de>
Date:   Sat Jun 14 23:48:41 2014 -0400

    hwrng: add per-device entropy derating
    
    This patch introduces a derating factor to struct hwrng for
    the random bits going into the kernel input pool, and a common
    default derating for drivers which do not specify one.
    
    Signed-off-by: Torsten Duwe <duwe@suse.de>
    Signed-off-by: Theodore Ts'o <tytso@mit.edu>
    Acked-by: H. Peter Anvin <hpa@zytor.com>

diff --git a/drivers/char/hw_random/core.c b/drivers/char/hw_random/core.c
index 48b3c812b9ec..3aaf97c774f1 100644
--- a/drivers/char/hw_random/core.c
+++ b/drivers/char/hw_random/core.c
@@ -56,11 +56,15 @@ static LIST_HEAD(rng_list);
 static DEFINE_MUTEX(rng_mutex);
 static int data_avail;
 static u8 *rng_buffer, *rng_fillbuf;
-static unsigned short current_quality = 700; /* an arbitrary 70% */
+static unsigned short current_quality;
+static unsigned short default_quality; /* = 0; default to "off" */
 
 module_param(current_quality, ushort, 0644);
 MODULE_PARM_DESC(current_quality,
 		 "current hwrng entropy estimation per mill");
+module_param(default_quality, ushort, 0644);
+MODULE_PARM_DESC(default_quality,
+		 "default entropy content of hwrng per mill");
 
 static void start_khwrngd(void);
 
@@ -79,6 +83,11 @@ static inline int hwrng_init(struct hwrng *rng)
 			return err;
 	}
 
+	current_quality = rng->quality ? : default_quality;
+	current_quality &= 1023;
+
+	if (current_quality == 0 && hwrng_fill)
+		kthread_stop(hwrng_fill);
 	if (current_quality > 0 && !hwrng_fill)
 		start_khwrngd();
 

commit be4000bc4644d027c519b6361f5ae3bbfc52c347
Author: Torsten Duwe <duwe@lst.de>
Date:   Sat Jun 14 23:46:03 2014 -0400

    hwrng: create filler thread
    
    This can be viewed as the in-kernel equivalent of hwrngd;
    like FUSE it is a good thing to have a mechanism in user land,
    but for some reasons (simplicity, secrecy, integrity, speed)
    it may be better to have it in kernel space.
    
    This patch creates a thread once a hwrng registers, and uses
    the previously established add_hwgenerator_randomness() to feed
    its data to the input pool as long as needed. A derating factor
    is used to bias the entropy estimation and to disable this
    mechanism entirely when set to zero.
    
    Signed-off-by: Torsten Duwe <duwe@suse.de>
    Signed-off-by: Theodore Ts'o <tytso@mit.edu>
    Acked-by: H. Peter Anvin <hpa@zytor.com>

diff --git a/drivers/char/hw_random/core.c b/drivers/char/hw_random/core.c
index 334601cc81cf..48b3c812b9ec 100644
--- a/drivers/char/hw_random/core.c
+++ b/drivers/char/hw_random/core.c
@@ -38,6 +38,7 @@
 #include <linux/fs.h>
 #include <linux/sched.h>
 #include <linux/miscdevice.h>
+#include <linux/kthread.h>
 #include <linux/delay.h>
 #include <linux/slab.h>
 #include <linux/random.h>
@@ -50,10 +51,18 @@
 
 
 static struct hwrng *current_rng;
+static struct task_struct *hwrng_fill;
 static LIST_HEAD(rng_list);
 static DEFINE_MUTEX(rng_mutex);
 static int data_avail;
-static u8 *rng_buffer;
+static u8 *rng_buffer, *rng_fillbuf;
+static unsigned short current_quality = 700; /* an arbitrary 70% */
+
+module_param(current_quality, ushort, 0644);
+MODULE_PARM_DESC(current_quality,
+		 "current hwrng entropy estimation per mill");
+
+static void start_khwrngd(void);
 
 static size_t rng_buffer_size(void)
 {
@@ -62,9 +71,18 @@ static size_t rng_buffer_size(void)
 
 static inline int hwrng_init(struct hwrng *rng)
 {
-	if (!rng->init)
-		return 0;
-	return rng->init(rng);
+	int err;
+
+	if (rng->init) {
+		err = rng->init(rng);
+		if (err)
+			return err;
+	}
+
+	if (current_quality > 0 && !hwrng_fill)
+		start_khwrngd();
+
+	return 0;
 }
 
 static inline void hwrng_cleanup(struct hwrng *rng)
@@ -300,6 +318,36 @@ static int register_miscdev(void)
 	goto out;
 }
 
+static int hwrng_fillfn(void *unused)
+{
+	long rc;
+
+	while (!kthread_should_stop()) {
+		if (!current_rng)
+			break;
+		rc = rng_get_data(current_rng, rng_fillbuf,
+				  rng_buffer_size(), 1);
+		if (rc <= 0) {
+			pr_warn("hwrng: no data available\n");
+			msleep_interruptible(10000);
+			continue;
+		}
+		add_hwgenerator_randomness((void *)rng_fillbuf, rc,
+					   (rc*current_quality)>>10);
+	}
+	hwrng_fill = 0;
+	return 0;
+}
+
+static void start_khwrngd(void)
+{
+	hwrng_fill = kthread_run(hwrng_fillfn, NULL, "hwrng");
+	if (hwrng_fill == ERR_PTR(-ENOMEM)) {
+		pr_err("hwrng_fill thread creation failed");
+		hwrng_fill = NULL;
+	}
+}
+
 int hwrng_register(struct hwrng *rng)
 {
 	int err = -EINVAL;
@@ -320,6 +368,13 @@ int hwrng_register(struct hwrng *rng)
 		if (!rng_buffer)
 			goto out_unlock;
 	}
+	if (!rng_fillbuf) {
+		rng_fillbuf = kmalloc(rng_buffer_size(), GFP_KERNEL);
+		if (!rng_fillbuf) {
+			kfree(rng_buffer);
+			goto out_unlock;
+		}
+	}
 
 	/* Must not register two RNGs with the same name. */
 	err = -EEXIST;
@@ -375,8 +430,11 @@ void hwrng_unregister(struct hwrng *rng)
 				current_rng = NULL;
 		}
 	}
-	if (list_empty(&rng_list))
+	if (list_empty(&rng_list)) {
 		unregister_miscdev();
+		if (hwrng_fill)
+			kthread_stop(hwrng_fill);
+	}
 
 	mutex_unlock(&rng_mutex);
 }
@@ -387,6 +445,7 @@ static void __exit hwrng_exit(void)
 	mutex_lock(&rng_mutex);
 	BUG_ON(current_rng);
 	kfree(rng_buffer);
+	kfree(rng_fillbuf);
 	mutex_unlock(&rng_mutex);
 }
 

commit e052dbf554610e2104c5a7518c4d8374bed701bb
Author: Amit Shah <amit.shah@redhat.com>
Date:   Thu Jul 10 15:42:35 2014 +0530

    hwrng: virtio - ensure reads happen after successful probe
    
    The hwrng core asks for random data in the hwrng_register() call itself
    from commit d9e7972619.  This doesn't play well with virtio -- the
    DRIVER_OK bit is only set by virtio core on a successful probe, and
    we're not yet out of our probe routine when this call is made.  This
    causes the host to not acknowledge any requests we put in the virtqueue,
    and the insmod or kernel boot process just waits for data to arrive from
    the host, which never happens.
    
    CC: Kees Cook <keescook@chromium.org>
    CC: Jason Cooper <jason@lakedaemon.net>
    CC: Herbert Xu <herbert@gondor.apana.org.au>
    CC: <stable@vger.kernel.org> # For v3.15+
    Reviewed-by: Jason Cooper <jason@lakedaemon.net>
    Signed-off-by: Amit Shah <amit.shah@redhat.com>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/char/hw_random/core.c b/drivers/char/hw_random/core.c
index 2a451b14b3cc..c4419ea1ab07 100644
--- a/drivers/char/hw_random/core.c
+++ b/drivers/char/hw_random/core.c
@@ -68,6 +68,12 @@ static void add_early_randomness(struct hwrng *rng)
 	unsigned char bytes[16];
 	int bytes_read;
 
+	/*
+	 * Currently only virtio-rng cannot return data during device
+	 * probe, and that's handled in virtio-rng.c itself.  If there
+	 * are more such devices, this call to rng_get_data can be
+	 * made conditional here instead of doing it per-device.
+	 */
 	bytes_read = rng_get_data(rng, bytes, sizeof(bytes), 1);
 	if (bytes_read > 0)
 		add_device_randomness(bytes, bytes_read);

commit d3cc7996473a7bdd33256029988ea690754e4e2a
Author: Amit Shah <amit.shah@redhat.com>
Date:   Thu Jul 10 15:42:34 2014 +0530

    hwrng: fetch randomness only after device init
    
    Commit d9e7972619334 "hwrng: add randomness to system from rng sources"
    added a call to rng_get_data() from the hwrng_register() function.
    However, some rng devices need initialization before data can be read
    from them.
    
    This commit makes the call to rng_get_data() depend on no init fn
    pointer being registered by the device.  If an init function is
    registered, this call is made after device init.
    
    CC: Kees Cook <keescook@chromium.org>
    CC: Jason Cooper <jason@lakedaemon.net>
    CC: Herbert Xu <herbert@gondor.apana.org.au>
    CC: <stable@vger.kernel.org> # For v3.15+
    Signed-off-by: Amit Shah <amit.shah@redhat.com>
    Reviewed-by: Jason Cooper <jason@lakedaemon.net>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/char/hw_random/core.c b/drivers/char/hw_random/core.c
index 334601cc81cf..2a451b14b3cc 100644
--- a/drivers/char/hw_random/core.c
+++ b/drivers/char/hw_random/core.c
@@ -55,16 +55,35 @@ static DEFINE_MUTEX(rng_mutex);
 static int data_avail;
 static u8 *rng_buffer;
 
+static inline int rng_get_data(struct hwrng *rng, u8 *buffer, size_t size,
+			       int wait);
+
 static size_t rng_buffer_size(void)
 {
 	return SMP_CACHE_BYTES < 32 ? 32 : SMP_CACHE_BYTES;
 }
 
+static void add_early_randomness(struct hwrng *rng)
+{
+	unsigned char bytes[16];
+	int bytes_read;
+
+	bytes_read = rng_get_data(rng, bytes, sizeof(bytes), 1);
+	if (bytes_read > 0)
+		add_device_randomness(bytes, bytes_read);
+}
+
 static inline int hwrng_init(struct hwrng *rng)
 {
-	if (!rng->init)
-		return 0;
-	return rng->init(rng);
+	if (rng->init) {
+		int ret;
+
+		ret =  rng->init(rng);
+		if (ret)
+			return ret;
+	}
+	add_early_randomness(rng);
+	return 0;
 }
 
 static inline void hwrng_cleanup(struct hwrng *rng)
@@ -304,8 +323,6 @@ int hwrng_register(struct hwrng *rng)
 {
 	int err = -EINVAL;
 	struct hwrng *old_rng, *tmp;
-	unsigned char bytes[16];
-	int bytes_read;
 
 	if (rng->name == NULL ||
 	    (rng->data_read == NULL && rng->read == NULL))
@@ -347,9 +364,17 @@ int hwrng_register(struct hwrng *rng)
 	INIT_LIST_HEAD(&rng->list);
 	list_add_tail(&rng->list, &rng_list);
 
-	bytes_read = rng_get_data(rng, bytes, sizeof(bytes), 1);
-	if (bytes_read > 0)
-		add_device_randomness(bytes, bytes_read);
+	if (old_rng && !rng->init) {
+		/*
+		 * Use a new device's input to add some randomness to
+		 * the system.  If this rng device isn't going to be
+		 * used right away, its init function hasn't been
+		 * called yet; so only use the randomness from devices
+		 * that don't need an init callback.
+		 */
+		add_early_randomness(rng);
+	}
+
 out_unlock:
 	mutex_unlock(&rng_mutex);
 out:

commit 59ecc26004e77e100c700b1d0da7502b0fdadb46
Merge: bea803183e12 8ceee72808d1
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Apr 3 09:28:16 2014 -0700

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/herbert/crypto-2.6
    
    Pull crypto updates from Herbert Xu:
     "Here is the crypto update for 3.15:
       - Added 3DES driver for OMAP4/AM43xx
       - Added AVX2 acceleration for SHA
       - Added hash-only AEAD algorithms in caam
       - Removed tegra driver as it is not functioning and the hardware is
         too slow
       - Allow blkcipher walks over AEAD (needed for ARM)
       - Fixed unprotected FPU/SSE access in ghash-clmulni-intel
       - Fixed highmem crash in omap-sham
       - Add (zero entropy) randomness when initialising hardware RNGs
       - Fixed unaligned ahash comletion functions
       - Added soft module depedency for crc32c for initrds that use crc32c"
    
    * git://git.kernel.org/pub/scm/linux/kernel/git/herbert/crypto-2.6: (60 commits)
      crypto: ghash-clmulni-intel - use C implementation for setkey()
      crypto: x86/sha1 - reduce size of the AVX2 asm implementation
      crypto: x86/sha1 - fix stack alignment of AVX2 variant
      crypto: x86/sha1 - re-enable the AVX variant
      crypto: sha - SHA1 transform x86_64 AVX2
      crypto: crypto_wq - Fix late crypto work queue initialization
      crypto: caam - add missing key_dma unmap
      crypto: caam - add support for aead null encryption
      crypto: testmgr - add aead null encryption test vectors
      crypto: export NULL algorithms defines
      crypto: caam - remove error propagation handling
      crypto: hash - Simplify the ahash_finup implementation
      crypto: hash - Pull out the functions to save/restore request
      crypto: hash - Fix the pointer voodoo in unaligned ahash
      crypto: caam - Fix first parameter to caam_init_rng
      crypto: omap-sham - Map SG pages if they are HIGHMEM before accessing
      crypto: caam - Dynamic memory allocation for caam_rng_ctx object
      crypto: allow blkcipher walks over AEAD data
      crypto: remove direct blkcipher_walk dependency on transform
      hwrng: add randomness to system from rng sources
      ...

commit d9e79726193346569af7953369a638ee2275ade5
Author: Kees Cook <keescook@chromium.org>
Date:   Mon Mar 3 15:51:48 2014 -0800

    hwrng: add randomness to system from rng sources
    
    When bringing a new RNG source online, it seems like it would make sense
    to use some of its bytes to make the system entropy pool more random,
    as done with all sorts of other devices that contain per-device or
    per-boot differences.
    
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Reviewed-by: Jason Cooper <jason@lakedaemon.net>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/char/hw_random/core.c b/drivers/char/hw_random/core.c
index cf49f1c88f01..7ac96fbc06ed 100644
--- a/drivers/char/hw_random/core.c
+++ b/drivers/char/hw_random/core.c
@@ -41,6 +41,7 @@
 #include <linux/miscdevice.h>
 #include <linux/delay.h>
 #include <linux/slab.h>
+#include <linux/random.h>
 #include <asm/uaccess.h>
 
 
@@ -304,6 +305,8 @@ int hwrng_register(struct hwrng *rng)
 {
 	int err = -EINVAL;
 	struct hwrng *old_rng, *tmp;
+	unsigned char bytes[16];
+	int bytes_read;
 
 	if (rng->name == NULL ||
 	    (rng->data_read == NULL && rng->read == NULL))
@@ -344,6 +347,10 @@ int hwrng_register(struct hwrng *rng)
 	}
 	INIT_LIST_HEAD(&rng->list);
 	list_add_tail(&rng->list, &rng_list);
+
+	bytes_read = rng_get_data(rng, bytes, sizeof(bytes), 1);
+	if (bytes_read > 0)
+		add_device_randomness(bytes, bytes_read);
 out_unlock:
 	mutex_unlock(&rng_mutex);
 out:

commit d167b6e1fb8ad386b17485ca88804d14f1695805
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Thu Jan 30 14:49:43 2014 +0300

    hwrng: cleanup in hwrng_register()
    
    My static checker complains that:
    
            drivers/char/hw_random/core.c:341 hwrng_register()
            warn: we tested 'old_rng' before and it was 'false'
    
    The problem is that sometimes we test "if (!old_rng)" and sometimes we
    test "if (must_register_misc)".  The static checker knows they are
    equivalent but a human being reading the code could easily be confused.
    
    I have simplified the code by removing the "must_register_misc" variable
    and I have removed the redundant check on "if (!old_rng)".
    
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Reviewed-by: Rusty Russell <rusty@rustcorp.com.au>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/char/hw_random/core.c b/drivers/char/hw_random/core.c
index a0f7724852eb..cf49f1c88f01 100644
--- a/drivers/char/hw_random/core.c
+++ b/drivers/char/hw_random/core.c
@@ -302,7 +302,6 @@ static int register_miscdev(void)
 
 int hwrng_register(struct hwrng *rng)
 {
-	int must_register_misc;
 	int err = -EINVAL;
 	struct hwrng *old_rng, *tmp;
 
@@ -327,7 +326,6 @@ int hwrng_register(struct hwrng *rng)
 			goto out_unlock;
 	}
 
-	must_register_misc = (current_rng == NULL);
 	old_rng = current_rng;
 	if (!old_rng) {
 		err = hwrng_init(rng);
@@ -336,13 +334,11 @@ int hwrng_register(struct hwrng *rng)
 		current_rng = rng;
 	}
 	err = 0;
-	if (must_register_misc) {
+	if (!old_rng) {
 		err = register_miscdev();
 		if (err) {
-			if (!old_rng) {
-				hwrng_cleanup(rng);
-				current_rng = NULL;
-			}
+			hwrng_cleanup(rng);
+			current_rng = NULL;
 			goto out_unlock;
 		}
 	}

commit 4c020b032b8a15966e1207b71144ffbb75697e29
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Tue Jan 21 16:22:59 2014 -0500

    drivers/char: delete non-required instances of include <linux/init.h>
    
    None of these files are actually using any __init type directives
    and hence don't need to include <linux/init.h>.  Most are just a
    left over from __devinit and __cpuinit removal, or simply due to
    code getting copied from one driver to the next.
    
    Cc: David Airlie <airlied@linux.ie>
    Cc: Matt Mackall <mpm@selenic.com>
    Cc: Herbert Xu <herbert@gondor.apana.org.au>
    Cc: Kukjin Kim <kgene.kim@samsung.com>
    Cc: Corey Minyard <minyard@acm.org>
    Cc: Chris Metcalf <cmetcalf@tilera.com>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Peter Huewe <peterhuewe@gmx.de>
    Cc: Ashley Lai <ashley@ashleylai.com>
    Cc: Marcel Selhorst <tpmdd@selhorst.net>
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/char/hw_random/core.c b/drivers/char/hw_random/core.c
index a0f7724852eb..b9495a8c05c6 100644
--- a/drivers/char/hw_random/core.c
+++ b/drivers/char/hw_random/core.c
@@ -37,7 +37,6 @@
 #include <linux/kernel.h>
 #include <linux/fs.h>
 #include <linux/sched.h>
-#include <linux/init.h>
 #include <linux/miscdevice.h>
 #include <linux/delay.h>
 #include <linux/slab.h>

commit b7d44d9487a11e835de10908f4ab30b4290c0b7f
Author: Satoru Takeuchi <satoru.takeuchi@gmail.com>
Date:   Wed Mar 20 11:28:51 2013 +1030

    hw_random: free rng_buffer at module exit
    
    rng-core module allocates rng_buffer by kmalloc() since commit
    f7f154f1246ccc5a0a7e9ce50932627d60a0c878. But this buffer won't be
    freed and there is a memory leak possibility at module exit.
    
    Signed-off-by: Satoru Takeuchi <satoru.takeuchi@gmail.com>
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>

diff --git a/drivers/char/hw_random/core.c b/drivers/char/hw_random/core.c
index 69ae5972713c..a0f7724852eb 100644
--- a/drivers/char/hw_random/core.c
+++ b/drivers/char/hw_random/core.c
@@ -380,6 +380,15 @@ void hwrng_unregister(struct hwrng *rng)
 }
 EXPORT_SYMBOL_GPL(hwrng_unregister);
 
+static void __exit hwrng_exit(void)
+{
+	mutex_lock(&rng_mutex);
+	BUG_ON(current_rng);
+	kfree(rng_buffer);
+	mutex_unlock(&rng_mutex);
+}
+
+module_exit(hwrng_exit);
 
 MODULE_DESCRIPTION("H/W Random Number Generator (RNG) driver");
 MODULE_LICENSE("GPL");

commit f7f154f1246ccc5a0a7e9ce50932627d60a0c878
Author: Rusty Russell <rusty@rustcorp.com.au>
Date:   Tue Mar 5 10:07:08 2013 +1030

    hw_random: make buffer usable in scatterlist.
    
    virtio_rng feeds the randomness buffer handed by the core directly
    into the scatterlist, since commit bb347d98079a547e80bd4722dee1de61e4dca0e8.
    
    However, if CONFIG_HW_RANDOM=m, the static buffer isn't a linear address
    (at least on most archs).  We could fix this in virtio_rng, but it's actually
    far easier to just do it in the core as virtio_rng would have to allocate
    a buffer every time (it doesn't know how much the core will want to read).
    
    Reported-by: Aurelien Jarno <aurelien@aurel32.net>
    Tested-by: Aurelien Jarno <aurelien@aurel32.net>
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>
    Cc: stable@kernel.org

diff --git a/drivers/char/hw_random/core.c b/drivers/char/hw_random/core.c
index 1bafb40ec8a2..69ae5972713c 100644
--- a/drivers/char/hw_random/core.c
+++ b/drivers/char/hw_random/core.c
@@ -40,6 +40,7 @@
 #include <linux/init.h>
 #include <linux/miscdevice.h>
 #include <linux/delay.h>
+#include <linux/slab.h>
 #include <asm/uaccess.h>
 
 
@@ -52,8 +53,12 @@ static struct hwrng *current_rng;
 static LIST_HEAD(rng_list);
 static DEFINE_MUTEX(rng_mutex);
 static int data_avail;
-static u8 rng_buffer[SMP_CACHE_BYTES < 32 ? 32 : SMP_CACHE_BYTES]
-	__cacheline_aligned;
+static u8 *rng_buffer;
+
+static size_t rng_buffer_size(void)
+{
+	return SMP_CACHE_BYTES < 32 ? 32 : SMP_CACHE_BYTES;
+}
 
 static inline int hwrng_init(struct hwrng *rng)
 {
@@ -116,7 +121,7 @@ static ssize_t rng_dev_read(struct file *filp, char __user *buf,
 
 		if (!data_avail) {
 			bytes_read = rng_get_data(current_rng, rng_buffer,
-				sizeof(rng_buffer),
+				rng_buffer_size(),
 				!(filp->f_flags & O_NONBLOCK));
 			if (bytes_read < 0) {
 				err = bytes_read;
@@ -307,6 +312,14 @@ int hwrng_register(struct hwrng *rng)
 
 	mutex_lock(&rng_mutex);
 
+	/* kmalloc makes this safe for virt_to_page() in virtio_rng.c */
+	err = -ENOMEM;
+	if (!rng_buffer) {
+		rng_buffer = kmalloc(rng_buffer_size(), GFP_KERNEL);
+		if (!rng_buffer)
+			goto out_unlock;
+	}
+
 	/* Must not register two RNGs with the same name. */
 	err = -EEXIST;
 	list_for_each_entry(tmp, &rng_list, list) {

commit eb032b9837a958e21ca000358a5bde5e17192ddb
Author: Michael Büsch <m@bues.ch>
Date:   Mon Jul 4 20:50:05 2011 +0200

    Update my e-mail address
    
    Signed-off-by: Michael Buesch <m@bues.ch>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/char/hw_random/core.c b/drivers/char/hw_random/core.c
index 2016aad85203..1bafb40ec8a2 100644
--- a/drivers/char/hw_random/core.c
+++ b/drivers/char/hw_random/core.c
@@ -19,7 +19,7 @@
 	Copyright 2000,2001 Philipp Rumpf <prumpf@mandrakesoft.com>
 
 	Added generic RNG API
-	Copyright 2006 Michael Buesch <mbuesch@freenet.de>
+	Copyright 2006 Michael Buesch <m@bues.ch>
 	Copyright 2005 (c) MontaVista Software, Inc.
 
 	Please read Documentation/hw_random.txt for details on use.

commit 451a3c24b0135bce54542009b5fde43846c7cf67
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Wed Nov 17 16:26:55 2010 +0100

    BKL: remove extraneous #include <smp_lock.h>
    
    The big kernel lock has been removed from all these files at some point,
    leaving only the #include.
    
    Remove this too as a cleanup.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/char/hw_random/core.c b/drivers/char/hw_random/core.c
index 788da05190cc..2016aad85203 100644
--- a/drivers/char/hw_random/core.c
+++ b/drivers/char/hw_random/core.c
@@ -37,7 +37,6 @@
 #include <linux/kernel.h>
 #include <linux/fs.h>
 #include <linux/sched.h>
-#include <linux/smp_lock.h>
 #include <linux/init.h>
 #include <linux/miscdevice.h>
 #include <linux/delay.h>

commit 6038f373a3dc1f1c26496e60b6c40b164716f07e
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Sun Aug 15 18:52:59 2010 +0200

    llseek: automatically add .llseek fop
    
    All file_operations should get a .llseek operation so we can make
    nonseekable_open the default for future file operations without a
    .llseek pointer.
    
    The three cases that we can automatically detect are no_llseek, seq_lseek
    and default_llseek. For cases where we can we can automatically prove that
    the file offset is always ignored, we use noop_llseek, which maintains
    the current behavior of not returning an error from a seek.
    
    New drivers should normally not use noop_llseek but instead use no_llseek
    and call nonseekable_open at open time.  Existing drivers can be converted
    to do the same when the maintainer knows for certain that no user code
    relies on calling seek on the device file.
    
    The generated code is often incorrectly indented and right now contains
    comments that clarify for each added line why a specific variant was
    chosen. In the version that gets submitted upstream, the comments will
    be gone and I will manually fix the indentation, because there does not
    seem to be a way to do that using coccinelle.
    
    Some amount of new code is currently sitting in linux-next that should get
    the same modifications, which I will do at the end of the merge window.
    
    Many thanks to Julia Lawall for helping me learn to write a semantic
    patch that does all this.
    
    ===== begin semantic patch =====
    // This adds an llseek= method to all file operations,
    // as a preparation for making no_llseek the default.
    //
    // The rules are
    // - use no_llseek explicitly if we do nonseekable_open
    // - use seq_lseek for sequential files
    // - use default_llseek if we know we access f_pos
    // - use noop_llseek if we know we don't access f_pos,
    //   but we still want to allow users to call lseek
    //
    @ open1 exists @
    identifier nested_open;
    @@
    nested_open(...)
    {
    <+...
    nonseekable_open(...)
    ...+>
    }
    
    @ open exists@
    identifier open_f;
    identifier i, f;
    identifier open1.nested_open;
    @@
    int open_f(struct inode *i, struct file *f)
    {
    <+...
    (
    nonseekable_open(...)
    |
    nested_open(...)
    )
    ...+>
    }
    
    @ read disable optional_qualifier exists @
    identifier read_f;
    identifier f, p, s, off;
    type ssize_t, size_t, loff_t;
    expression E;
    identifier func;
    @@
    ssize_t read_f(struct file *f, char *p, size_t s, loff_t *off)
    {
    <+...
    (
       *off = E
    |
       *off += E
    |
       func(..., off, ...)
    |
       E = *off
    )
    ...+>
    }
    
    @ read_no_fpos disable optional_qualifier exists @
    identifier read_f;
    identifier f, p, s, off;
    type ssize_t, size_t, loff_t;
    @@
    ssize_t read_f(struct file *f, char *p, size_t s, loff_t *off)
    {
    ... when != off
    }
    
    @ write @
    identifier write_f;
    identifier f, p, s, off;
    type ssize_t, size_t, loff_t;
    expression E;
    identifier func;
    @@
    ssize_t write_f(struct file *f, const char *p, size_t s, loff_t *off)
    {
    <+...
    (
      *off = E
    |
      *off += E
    |
      func(..., off, ...)
    |
      E = *off
    )
    ...+>
    }
    
    @ write_no_fpos @
    identifier write_f;
    identifier f, p, s, off;
    type ssize_t, size_t, loff_t;
    @@
    ssize_t write_f(struct file *f, const char *p, size_t s, loff_t *off)
    {
    ... when != off
    }
    
    @ fops0 @
    identifier fops;
    @@
    struct file_operations fops = {
     ...
    };
    
    @ has_llseek depends on fops0 @
    identifier fops0.fops;
    identifier llseek_f;
    @@
    struct file_operations fops = {
    ...
     .llseek = llseek_f,
    ...
    };
    
    @ has_read depends on fops0 @
    identifier fops0.fops;
    identifier read_f;
    @@
    struct file_operations fops = {
    ...
     .read = read_f,
    ...
    };
    
    @ has_write depends on fops0 @
    identifier fops0.fops;
    identifier write_f;
    @@
    struct file_operations fops = {
    ...
     .write = write_f,
    ...
    };
    
    @ has_open depends on fops0 @
    identifier fops0.fops;
    identifier open_f;
    @@
    struct file_operations fops = {
    ...
     .open = open_f,
    ...
    };
    
    // use no_llseek if we call nonseekable_open
    ////////////////////////////////////////////
    @ nonseekable1 depends on !has_llseek && has_open @
    identifier fops0.fops;
    identifier nso ~= "nonseekable_open";
    @@
    struct file_operations fops = {
    ...  .open = nso, ...
    +.llseek = no_llseek, /* nonseekable */
    };
    
    @ nonseekable2 depends on !has_llseek @
    identifier fops0.fops;
    identifier open.open_f;
    @@
    struct file_operations fops = {
    ...  .open = open_f, ...
    +.llseek = no_llseek, /* open uses nonseekable */
    };
    
    // use seq_lseek for sequential files
    /////////////////////////////////////
    @ seq depends on !has_llseek @
    identifier fops0.fops;
    identifier sr ~= "seq_read";
    @@
    struct file_operations fops = {
    ...  .read = sr, ...
    +.llseek = seq_lseek, /* we have seq_read */
    };
    
    // use default_llseek if there is a readdir
    ///////////////////////////////////////////
    @ fops1 depends on !has_llseek && !nonseekable1 && !nonseekable2 && !seq @
    identifier fops0.fops;
    identifier readdir_e;
    @@
    // any other fop is used that changes pos
    struct file_operations fops = {
    ... .readdir = readdir_e, ...
    +.llseek = default_llseek, /* readdir is present */
    };
    
    // use default_llseek if at least one of read/write touches f_pos
    /////////////////////////////////////////////////////////////////
    @ fops2 depends on !fops1 && !has_llseek && !nonseekable1 && !nonseekable2 && !seq @
    identifier fops0.fops;
    identifier read.read_f;
    @@
    // read fops use offset
    struct file_operations fops = {
    ... .read = read_f, ...
    +.llseek = default_llseek, /* read accesses f_pos */
    };
    
    @ fops3 depends on !fops1 && !fops2 && !has_llseek && !nonseekable1 && !nonseekable2 && !seq @
    identifier fops0.fops;
    identifier write.write_f;
    @@
    // write fops use offset
    struct file_operations fops = {
    ... .write = write_f, ...
    +       .llseek = default_llseek, /* write accesses f_pos */
    };
    
    // Use noop_llseek if neither read nor write accesses f_pos
    ///////////////////////////////////////////////////////////
    
    @ fops4 depends on !fops1 && !fops2 && !fops3 && !has_llseek && !nonseekable1 && !nonseekable2 && !seq @
    identifier fops0.fops;
    identifier read_no_fpos.read_f;
    identifier write_no_fpos.write_f;
    @@
    // write fops use offset
    struct file_operations fops = {
    ...
     .write = write_f,
     .read = read_f,
    ...
    +.llseek = noop_llseek, /* read and write both use no f_pos */
    };
    
    @ depends on has_write && !has_read && !fops1 && !fops2 && !has_llseek && !nonseekable1 && !nonseekable2 && !seq @
    identifier fops0.fops;
    identifier write_no_fpos.write_f;
    @@
    struct file_operations fops = {
    ... .write = write_f, ...
    +.llseek = noop_llseek, /* write uses no f_pos */
    };
    
    @ depends on has_read && !has_write && !fops1 && !fops2 && !has_llseek && !nonseekable1 && !nonseekable2 && !seq @
    identifier fops0.fops;
    identifier read_no_fpos.read_f;
    @@
    struct file_operations fops = {
    ... .read = read_f, ...
    +.llseek = noop_llseek, /* read uses no f_pos */
    };
    
    @ depends on !has_read && !has_write && !fops1 && !fops2 && !has_llseek && !nonseekable1 && !nonseekable2 && !seq @
    identifier fops0.fops;
    @@
    struct file_operations fops = {
    ...
    +.llseek = noop_llseek, /* no read or write fn */
    };
    ===== End semantic patch =====
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Cc: Julia Lawall <julia@diku.dk>
    Cc: Christoph Hellwig <hch@infradead.org>

diff --git a/drivers/char/hw_random/core.c b/drivers/char/hw_random/core.c
index 3d9c61e5acbf..788da05190cc 100644
--- a/drivers/char/hw_random/core.c
+++ b/drivers/char/hw_random/core.c
@@ -170,6 +170,7 @@ static const struct file_operations rng_chrdev_ops = {
 	.owner		= THIS_MODULE,
 	.open		= rng_dev_open,
 	.read		= rng_dev_read,
+	.llseek		= noop_llseek,
 };
 
 static struct miscdevice rng_miscdev = {

commit f5908267b67917b8cbd98b27fd2be9b5f62ec76f
Author: Herbert Xu <herbert@gondor.apana.org.au>
Date:   Wed Dec 23 23:22:34 2009 +0800

    hwrng: core - Fix double unlock in rng_dev_read
    
    When the loop terminates with size == 0 in rng_dev_read we will
    unlock the rng mutex twice.
    
    Reported-by: Dan Carpenter <error27@gmail.com>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/char/hw_random/core.c b/drivers/char/hw_random/core.c
index e989f67bb61f..3d9c61e5acbf 100644
--- a/drivers/char/hw_random/core.c
+++ b/drivers/char/hw_random/core.c
@@ -158,10 +158,11 @@ static ssize_t rng_dev_read(struct file *filp, char __user *buf,
 			goto out;
 		}
 	}
-out_unlock:
-	mutex_unlock(&rng_mutex);
 out:
 	return ret ? : err;
+out_unlock:
+	mutex_unlock(&rng_mutex);
+	goto out;
 }
 
 

commit 18821b0408efc92ec2804128ba9382a3bcebf132
Merge: 3b8ecd22447c 55e858c8483a
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Dec 9 08:07:38 2009 -0800

    Merge branch 'bkl-drivers-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip
    
    * 'bkl-drivers-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip:
      agp: Remove the BKL from agp_open
      inifiband: Remove BKL from ipath_open()
      mips: Remove BKL from tb0219
      drivers: Remove BKL from scx200_gpio
      drivers: Remove BKL from pc8736x_gpio
      parisc: Remove BKL from eisa_eeprom
      rtc: Remove BKL from efirtc
      input: Remove BKL from hp_sdc_rtc
      hw_random: Remove BKL from core
      macintosh: Remove BKL from ans-lcd
      nvram: Drop the bkl from non-generic nvram_llseek()
      nvram: Drop the bkl from nvram_llseek()
      mem_class: Drop the bkl from memory_open()
      spi: Remove BKL from spidev_open
      drivers: Remove BKL from cs5535_gpio
      drivers: Remove BKL from misc_open

commit eed89d0f9d3383851cec634565a6414fae70fe91
Author: Ian Molton <ian.molton@collabora.co.uk>
Date:   Thu Dec 3 13:50:42 2009 +0800

    hwrng: core - Prevent too-small buffer sizes
    
    This patch prevents the hw_random core using too small of a buffer
    on machines with small cacheline sizes.
    
    Signed-off-by: Ian Molton <ian.molton@collabora.co.uk>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/char/hw_random/core.c b/drivers/char/hw_random/core.c
index 5c2d13c6e189..8b7d56a0fe3a 100644
--- a/drivers/char/hw_random/core.c
+++ b/drivers/char/hw_random/core.c
@@ -53,7 +53,8 @@ static struct hwrng *current_rng;
 static LIST_HEAD(rng_list);
 static DEFINE_MUTEX(rng_mutex);
 static int data_avail;
-static u8 rng_buffer[SMP_CACHE_BYTES] __cacheline_aligned;
+static u8 rng_buffer[SMP_CACHE_BYTES < 32 ? 32 : SMP_CACHE_BYTES]
+	__cacheline_aligned;
 
 static inline int hwrng_init(struct hwrng *rng)
 {

commit 838632438145ac6863377eb12d8b8eef9c55d288
Merge: 9996508b3353 29e553631b2a
Author: Herbert Xu <herbert@gondor.apana.org.au>
Date:   Tue Dec 1 15:16:22 2009 +0800

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux-2.6

commit 9996508b3353063f2d6c48c1a28a84543d72d70b
Author: Ian Molton <ian.molton@collabora.co.uk>
Date:   Tue Dec 1 14:47:32 2009 +0800

    hwrng: core - Replace u32 in driver API with byte array
    
    This patch implements a new method by which hw_random hardware drivers
    can pass data to the core more efficiently, using a shared buffer.
    
    The old methods have been retained as a compatability layer until all the
    drivers have been updated.
    
    Signed-off-by: Ian Molton <ian.molton@collabora.co.uk>
    Acked-by: Matt Mackall <mpm@selenic.com>
    Acked-by: Rusty Russell <rusty@rustcorp.com.au>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/char/hw_random/core.c b/drivers/char/hw_random/core.c
index fc93e2fc7c71..82367262f3a8 100644
--- a/drivers/char/hw_random/core.c
+++ b/drivers/char/hw_random/core.c
@@ -52,7 +52,8 @@
 static struct hwrng *current_rng;
 static LIST_HEAD(rng_list);
 static DEFINE_MUTEX(rng_mutex);
-
+static int data_avail;
+static u8 rng_buffer[SMP_CACHE_BYTES] __cacheline_aligned;
 
 static inline int hwrng_init(struct hwrng *rng)
 {
@@ -67,19 +68,6 @@ static inline void hwrng_cleanup(struct hwrng *rng)
 		rng->cleanup(rng);
 }
 
-static inline int hwrng_data_present(struct hwrng *rng, int wait)
-{
-	if (!rng->data_present)
-		return 1;
-	return rng->data_present(rng, wait);
-}
-
-static inline int hwrng_data_read(struct hwrng *rng, u32 *data)
-{
-	return rng->data_read(rng, data);
-}
-
-
 static int rng_dev_open(struct inode *inode, struct file *filp)
 {
 	/* enforce read-only access to this chrdev */
@@ -91,54 +79,87 @@ static int rng_dev_open(struct inode *inode, struct file *filp)
 	return 0;
 }
 
+static inline int rng_get_data(struct hwrng *rng, u8 *buffer, size_t size,
+			int wait) {
+	int present;
+
+	if (rng->read)
+		return rng->read(rng, (void *)buffer, size, wait);
+
+	if (rng->data_present)
+		present = rng->data_present(rng, wait);
+	else
+		present = 1;
+
+	if (present)
+		return rng->data_read(rng, (u32 *)buffer);
+
+	return 0;
+}
+
 static ssize_t rng_dev_read(struct file *filp, char __user *buf,
 			    size_t size, loff_t *offp)
 {
-	u32 data;
 	ssize_t ret = 0;
 	int err = 0;
-	int bytes_read;
+	int bytes_read, len;
 
 	while (size) {
-		err = -ERESTARTSYS;
-		if (mutex_lock_interruptible(&rng_mutex))
+		if (mutex_lock_interruptible(&rng_mutex)) {
+			err = -ERESTARTSYS;
 			goto out;
+		}
+
 		if (!current_rng) {
-			mutex_unlock(&rng_mutex);
 			err = -ENODEV;
-			goto out;
+			goto out_unlock;
 		}
 
-		bytes_read = 0;
-		if (hwrng_data_present(current_rng,
-				       !(filp->f_flags & O_NONBLOCK)))
-			bytes_read = hwrng_data_read(current_rng, &data);
-		mutex_unlock(&rng_mutex);
-
-		err = -EAGAIN;
-		if (!bytes_read && (filp->f_flags & O_NONBLOCK))
-			goto out;
-		if (bytes_read < 0) {
-			err = bytes_read;
-			goto out;
+		if (!data_avail) {
+			bytes_read = rng_get_data(current_rng, rng_buffer,
+				sizeof(rng_buffer),
+				!(filp->f_flags & O_NONBLOCK));
+			if (bytes_read < 0) {
+				err = bytes_read;
+				goto out_unlock;
+			}
+			data_avail = bytes_read;
 		}
 
-		err = -EFAULT;
-		while (bytes_read && size) {
-			if (put_user((u8)data, buf++))
-				goto out;
-			size--;
-			ret++;
-			bytes_read--;
-			data >>= 8;
+		if (!data_avail) {
+			if (filp->f_flags & O_NONBLOCK) {
+				err = -EAGAIN;
+				goto out_unlock;
+			}
+		} else {
+			len = data_avail;
+			if (len > size)
+				len = size;
+
+			data_avail -= len;
+
+			if (copy_to_user(buf + ret, rng_buffer + data_avail,
+								len)) {
+				err = -EFAULT;
+				goto out_unlock;
+			}
+
+			size -= len;
+			ret += len;
 		}
 
+		mutex_unlock(&rng_mutex);
+
 		if (need_resched())
 			schedule_timeout_interruptible(1);
-		err = -ERESTARTSYS;
-		if (signal_pending(current))
+
+		if (signal_pending(current)) {
+			err = -ERESTARTSYS;
 			goto out;
+		}
 	}
+out_unlock:
+	mutex_unlock(&rng_mutex);
 out:
 	return ret ? : err;
 }
@@ -280,7 +301,7 @@ int hwrng_register(struct hwrng *rng)
 	struct hwrng *old_rng, *tmp;
 
 	if (rng->name == NULL ||
-	    rng->data_read == NULL)
+	    (rng->data_read == NULL && rng->read == NULL))
 		goto out;
 
 	mutex_lock(&rng_mutex);

commit a09ba31a54dbc9a548c4ff90619e4c7128a4282e
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Oct 10 12:36:32 2009 +0200

    hw_random: Remove BKL from core
    
    hw_random core is completely serialized with rng_mutex. No need for
    the cycle_kernel_lock() magic.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    LKML-Reference: <20091010153349.844488872@linutronix.de>
    Cc: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/char/hw_random/core.c b/drivers/char/hw_random/core.c
index 1573aebd54b5..75fb859a50be 100644
--- a/drivers/char/hw_random/core.c
+++ b/drivers/char/hw_random/core.c
@@ -87,7 +87,6 @@ static int rng_dev_open(struct inode *inode, struct file *filp)
 		return -EINVAL;
 	if (filp->f_mode & FMODE_WRITE)
 		return -EINVAL;
-	cycle_kernel_lock();
 	return 0;
 }
 

commit e454cea20bdcff10ee698d11b8882662a0153a47
Author: Kay Sievers <kay.sievers@vrfy.org>
Date:   Fri Sep 18 23:01:12 2009 +0200

    Driver-Core: extend devnode callbacks to provide permissions
    
    This allows subsytems to provide devtmpfs with non-default permissions
    for the device node. Instead of the default mode of 0600, null, zero,
    random, urandom, full, tty, ptmx now have a mode of 0666, which allows
    non-privileged processes to access standard device nodes in case no
    other userspace process applies the expected permissions.
    
    This also fixes a wrong assignment in pktcdvd and a checkpatch.pl complain.
    
    Signed-off-by: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/char/hw_random/core.c b/drivers/char/hw_random/core.c
index fc93e2fc7c71..1573aebd54b5 100644
--- a/drivers/char/hw_random/core.c
+++ b/drivers/char/hw_random/core.c
@@ -153,7 +153,7 @@ static const struct file_operations rng_chrdev_ops = {
 static struct miscdevice rng_miscdev = {
 	.minor		= RNG_MISCDEV_MINOR,
 	.name		= RNG_MODULE_NAME,
-	.devnode	= "hwrng",
+	.nodename	= "hwrng",
 	.fops		= &rng_chrdev_ops,
 };
 

commit d405640539555b601e52f7d18f1f0b1345d18bf5
Author: Kay Sievers <kay.sievers@vrfy.org>
Date:   Thu Apr 30 15:23:42 2009 +0200

    Driver Core: misc: add nodename support for misc devices.
    
    This adds support for misc devices to report their requested nodename to
    userspace.  It also updates a number of misc drivers to provide the
    needed subdirectory and device name to be used for them.
    
    Signed-off-by: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Jan Blunck <jblunck@suse.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/char/hw_random/core.c b/drivers/char/hw_random/core.c
index e5d583c84e4f..fc93e2fc7c71 100644
--- a/drivers/char/hw_random/core.c
+++ b/drivers/char/hw_random/core.c
@@ -153,6 +153,7 @@ static const struct file_operations rng_chrdev_ops = {
 static struct miscdevice rng_miscdev = {
 	.minor		= RNG_MISCDEV_MINOR,
 	.name		= RNG_MODULE_NAME,
+	.devnode	= "hwrng",
 	.fops		= &rng_chrdev_ops,
 };
 

commit a9c4e8f74ba26f10cf78fed7c5b863ea50988856
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Tue May 20 19:16:00 2008 +0200

    hw-random: BKL pushdown
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/drivers/char/hw_random/core.c b/drivers/char/hw_random/core.c
index 662d60e44e9a..e5d583c84e4f 100644
--- a/drivers/char/hw_random/core.c
+++ b/drivers/char/hw_random/core.c
@@ -37,6 +37,7 @@
 #include <linux/kernel.h>
 #include <linux/fs.h>
 #include <linux/sched.h>
+#include <linux/smp_lock.h>
 #include <linux/init.h>
 #include <linux/miscdevice.h>
 #include <linux/delay.h>
@@ -86,6 +87,7 @@ static int rng_dev_open(struct inode *inode, struct file *filp)
 		return -EINVAL;
 	if (filp->f_mode & FMODE_WRITE)
 		return -EINVAL;
+	cycle_kernel_lock();
 	return 0;
 }
 

commit b844eba292b477cda14582bfc6f535deed57a82d
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Sun Mar 23 20:28:24 2008 +0100

    PM: Remove destroy_suspended_device()
    
    After 2.6.24 there was a plan to make the PM core acquire all device
    semaphores during a suspend/hibernation to protect itself from
    concurrent operations involving device objects.  That proved to be
    too heavy-handed and we found a better way to achieve the goal, but
    before it happened, we had introduced the functions
    device_pm_schedule_removal() and destroy_suspended_device() to allow
    drivers to "safely" destroy a suspended device and we had adapted some
    drivers to use them.  Now that these functions are no longer necessary,
    it seems reasonable to remove them and modify their users to use the
    normal device unregistration instead.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/char/hw_random/core.c b/drivers/char/hw_random/core.c
index 349b6edc5794..662d60e44e9a 100644
--- a/drivers/char/hw_random/core.c
+++ b/drivers/char/hw_random/core.c
@@ -238,11 +238,11 @@ static DEVICE_ATTR(rng_available, S_IRUGO,
 		   NULL);
 
 
-static void unregister_miscdev(bool suspended)
+static void unregister_miscdev(void)
 {
 	device_remove_file(rng_miscdev.this_device, &dev_attr_rng_available);
 	device_remove_file(rng_miscdev.this_device, &dev_attr_rng_current);
-	__misc_deregister(&rng_miscdev, suspended);
+	misc_deregister(&rng_miscdev);
 }
 
 static int register_miscdev(void)
@@ -317,7 +317,7 @@ int hwrng_register(struct hwrng *rng)
 }
 EXPORT_SYMBOL_GPL(hwrng_register);
 
-void __hwrng_unregister(struct hwrng *rng, bool suspended)
+void hwrng_unregister(struct hwrng *rng)
 {
 	int err;
 
@@ -336,11 +336,11 @@ void __hwrng_unregister(struct hwrng *rng, bool suspended)
 		}
 	}
 	if (list_empty(&rng_list))
-		unregister_miscdev(suspended);
+		unregister_miscdev();
 
 	mutex_unlock(&rng_mutex);
 }
-EXPORT_SYMBOL_GPL(__hwrng_unregister);
+EXPORT_SYMBOL_GPL(hwrng_unregister);
 
 
 MODULE_DESCRIPTION("H/W Random Number Generator (RNG) driver");

commit 893f11286644780fc7d6d415e537644da7bdaaf8
Author: Ralph Wuerthner <rwuerthn@de.ibm.com>
Date:   Thu Apr 17 07:46:14 2008 +0200

    [S390] hw_random: allow rng_dev_read() to return hardware errors.
    
    The api for hardware random number generators is currently limited to
    devices that never fail. If the hardware is registered as a source for
    random numbers it has to work. This prevents the use of i/o based
    random number devices where the i/o might fail.
    
    Add a check for errors after the read from a hardware random number device.
    
    This patch is required to support large random numbers retrieved
    from the CEX2C cards on System z.
    
    Signed-off-by: Ralph Wuerthner <rwuerthn@de.ibm.com>
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Signed-off-by: Heiko Carstens <heiko.carstens@de.ibm.com>

diff --git a/drivers/char/hw_random/core.c b/drivers/char/hw_random/core.c
index 84cdf9025737..349b6edc5794 100644
--- a/drivers/char/hw_random/core.c
+++ b/drivers/char/hw_random/core.c
@@ -116,6 +116,10 @@ static ssize_t rng_dev_read(struct file *filp, char __user *buf,
 		err = -EAGAIN;
 		if (!bytes_read && (filp->f_flags & O_NONBLOCK))
 			goto out;
+		if (bytes_read < 0) {
+			err = bytes_read;
+			goto out;
+		}
 
 		err = -EFAULT;
 		while (bytes_read && size) {

commit a41e3dc4060cca2599afa14fbd4c745763746ba8
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Mon Feb 4 22:30:13 2008 -0800

    HWRNG: add possibility to remove hwrng devices during suspend/resume
    
    Make it possible to unregister a Hardware Random Number Generator
    device object in a safe way during a suspend/resume cycle.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Michael Buesch <mb@bu3sch.de>
    Cc: Michael Buesch <mb@bu3sch.de>
    Cc: Pavel Machek <pavel@ucw.cz>
    Cc: "John W. Linville" <linville@tuxdriver.com>
    Cc: Alan Stern <stern@rowland.harvard.edu>
    Cc: Len Brown <lenb@kernel.org>
    Cc: Greg KH <greg@kroah.com>
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Cc: Richard Purdie <rpurdie@rpsys.net>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/char/hw_random/core.c b/drivers/char/hw_random/core.c
index 0118b9817a95..84cdf9025737 100644
--- a/drivers/char/hw_random/core.c
+++ b/drivers/char/hw_random/core.c
@@ -234,11 +234,11 @@ static DEVICE_ATTR(rng_available, S_IRUGO,
 		   NULL);
 
 
-static void unregister_miscdev(void)
+static void unregister_miscdev(bool suspended)
 {
 	device_remove_file(rng_miscdev.this_device, &dev_attr_rng_available);
 	device_remove_file(rng_miscdev.this_device, &dev_attr_rng_current);
-	misc_deregister(&rng_miscdev);
+	__misc_deregister(&rng_miscdev, suspended);
 }
 
 static int register_miscdev(void)
@@ -313,7 +313,7 @@ int hwrng_register(struct hwrng *rng)
 }
 EXPORT_SYMBOL_GPL(hwrng_register);
 
-void hwrng_unregister(struct hwrng *rng)
+void __hwrng_unregister(struct hwrng *rng, bool suspended)
 {
 	int err;
 
@@ -332,11 +332,11 @@ void hwrng_unregister(struct hwrng *rng)
 		}
 	}
 	if (list_empty(&rng_list))
-		unregister_miscdev();
+		unregister_miscdev(suspended);
 
 	mutex_unlock(&rng_mutex);
 }
-EXPORT_SYMBOL_GPL(hwrng_unregister);
+EXPORT_SYMBOL_GPL(__hwrng_unregister);
 
 
 MODULE_DESCRIPTION("H/W Random Number Generator (RNG) driver");

commit 984e976f5382ff09351ddd3b023937611396d739
Author: Patrick McHardy <kaber@trash.net>
Date:   Wed Nov 21 12:24:45 2007 +0800

    [HWRNG]: move status polling loop to data_present callbacks
    
    Handle waiting for new random within the drivers themselves, this allows to
    use better suited timeouts for the individual rngs.
    
    Signed-off-by: Patrick McHardy <kaber@trash.net>
    Acked-by: Michael Buesch <mb@bu3sch.de>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/char/hw_random/core.c b/drivers/char/hw_random/core.c
index 26a860adcb38..0118b9817a95 100644
--- a/drivers/char/hw_random/core.c
+++ b/drivers/char/hw_random/core.c
@@ -66,11 +66,11 @@ static inline void hwrng_cleanup(struct hwrng *rng)
 		rng->cleanup(rng);
 }
 
-static inline int hwrng_data_present(struct hwrng *rng)
+static inline int hwrng_data_present(struct hwrng *rng, int wait)
 {
 	if (!rng->data_present)
 		return 1;
-	return rng->data_present(rng);
+	return rng->data_present(rng, wait);
 }
 
 static inline int hwrng_data_read(struct hwrng *rng, u32 *data)
@@ -94,8 +94,7 @@ static ssize_t rng_dev_read(struct file *filp, char __user *buf,
 {
 	u32 data;
 	ssize_t ret = 0;
-	int i, err = 0;
-	int data_present;
+	int err = 0;
 	int bytes_read;
 
 	while (size) {
@@ -107,21 +106,10 @@ static ssize_t rng_dev_read(struct file *filp, char __user *buf,
 			err = -ENODEV;
 			goto out;
 		}
-		if (filp->f_flags & O_NONBLOCK) {
-			data_present = hwrng_data_present(current_rng);
-		} else {
-			/* Some RNG require some time between data_reads to gather
-			 * new entropy. Poll it.
-			 */
-			for (i = 0; i < 20; i++) {
-				data_present = hwrng_data_present(current_rng);
-				if (data_present)
-					break;
-				udelay(10);
-			}
-		}
+
 		bytes_read = 0;
-		if (data_present)
+		if (hwrng_data_present(current_rng,
+				       !(filp->f_flags & O_NONBLOCK)))
 			bytes_read = hwrng_data_read(current_rng, &data);
 		mutex_unlock(&rng_mutex);
 

commit 914e26379decf1fd984b22e51fd2e4209b7a7f1b
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Wed Oct 18 13:55:46 2006 -0400

    [PATCH] severing fs.h, radix-tree.h -> sched.h
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/drivers/char/hw_random/core.c b/drivers/char/hw_random/core.c
index ebace201bec6..26a860adcb38 100644
--- a/drivers/char/hw_random/core.c
+++ b/drivers/char/hw_random/core.c
@@ -36,6 +36,7 @@
 #include <linux/module.h>
 #include <linux/kernel.h>
 #include <linux/fs.h>
+#include <linux/sched.h>
 #include <linux/init.h>
 #include <linux/miscdevice.h>
 #include <linux/delay.h>

commit 94fbcded4ea0dc14cbfb222a5c68372f150d1476
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Thu Jul 27 16:16:04 2006 -0700

    Driver core: change misc class_devices to be real devices
    
    This also ment that some of the misc drivers had to also be fixed
    up as they were assuming the device was a class_device.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/char/hw_random/core.c b/drivers/char/hw_random/core.c
index 154a81d328c1..ebace201bec6 100644
--- a/drivers/char/hw_random/core.c
+++ b/drivers/char/hw_random/core.c
@@ -162,7 +162,8 @@ static struct miscdevice rng_miscdev = {
 };
 
 
-static ssize_t hwrng_attr_current_store(struct class_device *class,
+static ssize_t hwrng_attr_current_store(struct device *dev,
+					struct device_attribute *attr,
 					const char *buf, size_t len)
 {
 	int err;
@@ -192,7 +193,8 @@ static ssize_t hwrng_attr_current_store(struct class_device *class,
 	return err ? : len;
 }
 
-static ssize_t hwrng_attr_current_show(struct class_device *class,
+static ssize_t hwrng_attr_current_show(struct device *dev,
+				       struct device_attribute *attr,
 				       char *buf)
 {
 	int err;
@@ -210,7 +212,8 @@ static ssize_t hwrng_attr_current_show(struct class_device *class,
 	return ret;
 }
 
-static ssize_t hwrng_attr_available_show(struct class_device *class,
+static ssize_t hwrng_attr_available_show(struct device *dev,
+					 struct device_attribute *attr,
 					 char *buf)
 {
 	int err;
@@ -234,20 +237,18 @@ static ssize_t hwrng_attr_available_show(struct class_device *class,
 	return ret;
 }
 
-static CLASS_DEVICE_ATTR(rng_current, S_IRUGO | S_IWUSR,
-			 hwrng_attr_current_show,
-			 hwrng_attr_current_store);
-static CLASS_DEVICE_ATTR(rng_available, S_IRUGO,
-			 hwrng_attr_available_show,
-			 NULL);
+static DEVICE_ATTR(rng_current, S_IRUGO | S_IWUSR,
+		   hwrng_attr_current_show,
+		   hwrng_attr_current_store);
+static DEVICE_ATTR(rng_available, S_IRUGO,
+		   hwrng_attr_available_show,
+		   NULL);
 
 
 static void unregister_miscdev(void)
 {
-	class_device_remove_file(rng_miscdev.class,
-				 &class_device_attr_rng_available);
-	class_device_remove_file(rng_miscdev.class,
-				 &class_device_attr_rng_current);
+	device_remove_file(rng_miscdev.this_device, &dev_attr_rng_available);
+	device_remove_file(rng_miscdev.this_device, &dev_attr_rng_current);
 	misc_deregister(&rng_miscdev);
 }
 
@@ -258,20 +259,19 @@ static int register_miscdev(void)
 	err = misc_register(&rng_miscdev);
 	if (err)
 		goto out;
-	err = class_device_create_file(rng_miscdev.class,
-				       &class_device_attr_rng_current);
+	err = device_create_file(rng_miscdev.this_device,
+				 &dev_attr_rng_current);
 	if (err)
 		goto err_misc_dereg;
-	err = class_device_create_file(rng_miscdev.class,
-				       &class_device_attr_rng_available);
+	err = device_create_file(rng_miscdev.this_device,
+				 &dev_attr_rng_available);
 	if (err)
 		goto err_remove_current;
 out:
 	return err;
 
 err_remove_current:
-	class_device_remove_file(rng_miscdev.class,
-				 &class_device_attr_rng_current);
+	device_remove_file(rng_miscdev.this_device, &dev_attr_rng_current);
 err_misc_dereg:
 	misc_deregister(&rng_miscdev);
 	goto out;

commit 62322d2554d2f9680c8ace7bbf1f97d8fa84ad1a
Author: Arjan van de Ven <arjan@infradead.org>
Date:   Mon Jul 3 00:24:21 2006 -0700

    [PATCH] make more file_operation structs static
    
    Mark the static struct file_operations in drivers/char as const.  Making
    them const prevents accidental bugs, and moves them to the .rodata section
    so that they no longer do any false sharing; in addition with the proper
    debug option they are then protected against corruption..
    
    [akpm@osdl.org: build fix]
    Signed-off-by: Arjan van de Ven <arjan@linux.intel.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/char/hw_random/core.c b/drivers/char/hw_random/core.c
index 88b026639f10..154a81d328c1 100644
--- a/drivers/char/hw_random/core.c
+++ b/drivers/char/hw_random/core.c
@@ -149,7 +149,7 @@ static ssize_t rng_dev_read(struct file *filp, char __user *buf,
 }
 
 
-static struct file_operations rng_chrdev_ops = {
+static const struct file_operations rng_chrdev_ops = {
 	.owner		= THIS_MODULE,
 	.open		= rng_dev_open,
 	.read		= rng_dev_read,

commit 844dd05fec172d98b0dacecd9b9e9f6595204c13
Author: Michael Buesch <mb@bu3sch.de>
Date:   Mon Jun 26 00:24:59 2006 -0700

    [PATCH] Add new generic HW RNG core
    
    Signed-off-by: Michael Buesch <mb@bu3sch.de>
    Cc: Jeff Garzik <jeff@garzik.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/char/hw_random/core.c b/drivers/char/hw_random/core.c
new file mode 100644
index 000000000000..88b026639f10
--- /dev/null
+++ b/drivers/char/hw_random/core.c
@@ -0,0 +1,354 @@
+/*
+        Added support for the AMD Geode LX RNG
+	(c) Copyright 2004-2005 Advanced Micro Devices, Inc.
+
+	derived from
+
+ 	Hardware driver for the Intel/AMD/VIA Random Number Generators (RNG)
+	(c) Copyright 2003 Red Hat Inc <jgarzik@redhat.com>
+
+ 	derived from
+
+        Hardware driver for the AMD 768 Random Number Generator (RNG)
+        (c) Copyright 2001 Red Hat Inc <alan@redhat.com>
+
+ 	derived from
+
+	Hardware driver for Intel i810 Random Number Generator (RNG)
+	Copyright 2000,2001 Jeff Garzik <jgarzik@pobox.com>
+	Copyright 2000,2001 Philipp Rumpf <prumpf@mandrakesoft.com>
+
+	Added generic RNG API
+	Copyright 2006 Michael Buesch <mbuesch@freenet.de>
+	Copyright 2005 (c) MontaVista Software, Inc.
+
+	Please read Documentation/hw_random.txt for details on use.
+
+	----------------------------------------------------------
+	This software may be used and distributed according to the terms
+        of the GNU General Public License, incorporated herein by reference.
+
+ */
+
+
+#include <linux/device.h>
+#include <linux/hw_random.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/fs.h>
+#include <linux/init.h>
+#include <linux/miscdevice.h>
+#include <linux/delay.h>
+#include <asm/uaccess.h>
+
+
+#define RNG_MODULE_NAME		"hw_random"
+#define PFX			RNG_MODULE_NAME ": "
+#define RNG_MISCDEV_MINOR	183 /* official */
+
+
+static struct hwrng *current_rng;
+static LIST_HEAD(rng_list);
+static DEFINE_MUTEX(rng_mutex);
+
+
+static inline int hwrng_init(struct hwrng *rng)
+{
+	if (!rng->init)
+		return 0;
+	return rng->init(rng);
+}
+
+static inline void hwrng_cleanup(struct hwrng *rng)
+{
+	if (rng && rng->cleanup)
+		rng->cleanup(rng);
+}
+
+static inline int hwrng_data_present(struct hwrng *rng)
+{
+	if (!rng->data_present)
+		return 1;
+	return rng->data_present(rng);
+}
+
+static inline int hwrng_data_read(struct hwrng *rng, u32 *data)
+{
+	return rng->data_read(rng, data);
+}
+
+
+static int rng_dev_open(struct inode *inode, struct file *filp)
+{
+	/* enforce read-only access to this chrdev */
+	if ((filp->f_mode & FMODE_READ) == 0)
+		return -EINVAL;
+	if (filp->f_mode & FMODE_WRITE)
+		return -EINVAL;
+	return 0;
+}
+
+static ssize_t rng_dev_read(struct file *filp, char __user *buf,
+			    size_t size, loff_t *offp)
+{
+	u32 data;
+	ssize_t ret = 0;
+	int i, err = 0;
+	int data_present;
+	int bytes_read;
+
+	while (size) {
+		err = -ERESTARTSYS;
+		if (mutex_lock_interruptible(&rng_mutex))
+			goto out;
+		if (!current_rng) {
+			mutex_unlock(&rng_mutex);
+			err = -ENODEV;
+			goto out;
+		}
+		if (filp->f_flags & O_NONBLOCK) {
+			data_present = hwrng_data_present(current_rng);
+		} else {
+			/* Some RNG require some time between data_reads to gather
+			 * new entropy. Poll it.
+			 */
+			for (i = 0; i < 20; i++) {
+				data_present = hwrng_data_present(current_rng);
+				if (data_present)
+					break;
+				udelay(10);
+			}
+		}
+		bytes_read = 0;
+		if (data_present)
+			bytes_read = hwrng_data_read(current_rng, &data);
+		mutex_unlock(&rng_mutex);
+
+		err = -EAGAIN;
+		if (!bytes_read && (filp->f_flags & O_NONBLOCK))
+			goto out;
+
+		err = -EFAULT;
+		while (bytes_read && size) {
+			if (put_user((u8)data, buf++))
+				goto out;
+			size--;
+			ret++;
+			bytes_read--;
+			data >>= 8;
+		}
+
+		if (need_resched())
+			schedule_timeout_interruptible(1);
+		err = -ERESTARTSYS;
+		if (signal_pending(current))
+			goto out;
+	}
+out:
+	return ret ? : err;
+}
+
+
+static struct file_operations rng_chrdev_ops = {
+	.owner		= THIS_MODULE,
+	.open		= rng_dev_open,
+	.read		= rng_dev_read,
+};
+
+static struct miscdevice rng_miscdev = {
+	.minor		= RNG_MISCDEV_MINOR,
+	.name		= RNG_MODULE_NAME,
+	.fops		= &rng_chrdev_ops,
+};
+
+
+static ssize_t hwrng_attr_current_store(struct class_device *class,
+					const char *buf, size_t len)
+{
+	int err;
+	struct hwrng *rng;
+
+	err = mutex_lock_interruptible(&rng_mutex);
+	if (err)
+		return -ERESTARTSYS;
+	err = -ENODEV;
+	list_for_each_entry(rng, &rng_list, list) {
+		if (strcmp(rng->name, buf) == 0) {
+			if (rng == current_rng) {
+				err = 0;
+				break;
+			}
+			err = hwrng_init(rng);
+			if (err)
+				break;
+			hwrng_cleanup(current_rng);
+			current_rng = rng;
+			err = 0;
+			break;
+		}
+	}
+	mutex_unlock(&rng_mutex);
+
+	return err ? : len;
+}
+
+static ssize_t hwrng_attr_current_show(struct class_device *class,
+				       char *buf)
+{
+	int err;
+	ssize_t ret;
+	const char *name = "none";
+
+	err = mutex_lock_interruptible(&rng_mutex);
+	if (err)
+		return -ERESTARTSYS;
+	if (current_rng)
+		name = current_rng->name;
+	ret = snprintf(buf, PAGE_SIZE, "%s\n", name);
+	mutex_unlock(&rng_mutex);
+
+	return ret;
+}
+
+static ssize_t hwrng_attr_available_show(struct class_device *class,
+					 char *buf)
+{
+	int err;
+	ssize_t ret = 0;
+	struct hwrng *rng;
+
+	err = mutex_lock_interruptible(&rng_mutex);
+	if (err)
+		return -ERESTARTSYS;
+	buf[0] = '\0';
+	list_for_each_entry(rng, &rng_list, list) {
+		strncat(buf, rng->name, PAGE_SIZE - ret - 1);
+		ret += strlen(rng->name);
+		strncat(buf, " ", PAGE_SIZE - ret - 1);
+		ret++;
+	}
+	strncat(buf, "\n", PAGE_SIZE - ret - 1);
+	ret++;
+	mutex_unlock(&rng_mutex);
+
+	return ret;
+}
+
+static CLASS_DEVICE_ATTR(rng_current, S_IRUGO | S_IWUSR,
+			 hwrng_attr_current_show,
+			 hwrng_attr_current_store);
+static CLASS_DEVICE_ATTR(rng_available, S_IRUGO,
+			 hwrng_attr_available_show,
+			 NULL);
+
+
+static void unregister_miscdev(void)
+{
+	class_device_remove_file(rng_miscdev.class,
+				 &class_device_attr_rng_available);
+	class_device_remove_file(rng_miscdev.class,
+				 &class_device_attr_rng_current);
+	misc_deregister(&rng_miscdev);
+}
+
+static int register_miscdev(void)
+{
+	int err;
+
+	err = misc_register(&rng_miscdev);
+	if (err)
+		goto out;
+	err = class_device_create_file(rng_miscdev.class,
+				       &class_device_attr_rng_current);
+	if (err)
+		goto err_misc_dereg;
+	err = class_device_create_file(rng_miscdev.class,
+				       &class_device_attr_rng_available);
+	if (err)
+		goto err_remove_current;
+out:
+	return err;
+
+err_remove_current:
+	class_device_remove_file(rng_miscdev.class,
+				 &class_device_attr_rng_current);
+err_misc_dereg:
+	misc_deregister(&rng_miscdev);
+	goto out;
+}
+
+int hwrng_register(struct hwrng *rng)
+{
+	int must_register_misc;
+	int err = -EINVAL;
+	struct hwrng *old_rng, *tmp;
+
+	if (rng->name == NULL ||
+	    rng->data_read == NULL)
+		goto out;
+
+	mutex_lock(&rng_mutex);
+
+	/* Must not register two RNGs with the same name. */
+	err = -EEXIST;
+	list_for_each_entry(tmp, &rng_list, list) {
+		if (strcmp(tmp->name, rng->name) == 0)
+			goto out_unlock;
+	}
+
+	must_register_misc = (current_rng == NULL);
+	old_rng = current_rng;
+	if (!old_rng) {
+		err = hwrng_init(rng);
+		if (err)
+			goto out_unlock;
+		current_rng = rng;
+	}
+	err = 0;
+	if (must_register_misc) {
+		err = register_miscdev();
+		if (err) {
+			if (!old_rng) {
+				hwrng_cleanup(rng);
+				current_rng = NULL;
+			}
+			goto out_unlock;
+		}
+	}
+	INIT_LIST_HEAD(&rng->list);
+	list_add_tail(&rng->list, &rng_list);
+out_unlock:
+	mutex_unlock(&rng_mutex);
+out:
+	return err;
+}
+EXPORT_SYMBOL_GPL(hwrng_register);
+
+void hwrng_unregister(struct hwrng *rng)
+{
+	int err;
+
+	mutex_lock(&rng_mutex);
+
+	list_del(&rng->list);
+	if (current_rng == rng) {
+		hwrng_cleanup(rng);
+		if (list_empty(&rng_list)) {
+			current_rng = NULL;
+		} else {
+			current_rng = list_entry(rng_list.prev, struct hwrng, list);
+			err = hwrng_init(current_rng);
+			if (err)
+				current_rng = NULL;
+		}
+	}
+	if (list_empty(&rng_list))
+		unregister_miscdev();
+
+	mutex_unlock(&rng_mutex);
+}
+EXPORT_SYMBOL_GPL(hwrng_unregister);
+
+
+MODULE_DESCRIPTION("H/W Random Number Generator (RNG) driver");
+MODULE_LICENSE("GPL");
