commit f2f1d75ab725106c4958bda30f87bd39a0e3040a
Author: Anson Huang <Anson.Huang@nxp.com>
Date:   Wed Jul 17 17:04:38 2019 +0800

    hwrng: mxc-rnga - use devm_platform_ioremap_resource() to simplify code
    
    Use the new helper devm_platform_ioremap_resource() which wraps the
    platform_get_resource() and devm_ioremap_resource() together, to
    simplify the code.
    
    Signed-off-by: Anson Huang <Anson.Huang@nxp.com>
    Reviewed-by: Dong Aisheng <aisheng.dong@nxp.com>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/char/hw_random/mxc-rnga.c b/drivers/char/hw_random/mxc-rnga.c
index ea2bf18b1fbb..025083c838f5 100644
--- a/drivers/char/hw_random/mxc-rnga.c
+++ b/drivers/char/hw_random/mxc-rnga.c
@@ -134,7 +134,6 @@ static void mxc_rnga_cleanup(struct hwrng *rng)
 static int __init mxc_rnga_probe(struct platform_device *pdev)
 {
 	int err;
-	struct resource *res;
 	struct mxc_rng *mxc_rng;
 
 	mxc_rng = devm_kzalloc(&pdev->dev, sizeof(*mxc_rng), GFP_KERNEL);
@@ -158,8 +157,7 @@ static int __init mxc_rnga_probe(struct platform_device *pdev)
 	if (err)
 		return err;
 
-	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	mxc_rng->mem = devm_ioremap_resource(&pdev->dev, res);
+	mxc_rng->mem = devm_platform_ioremap_resource(pdev, 0);
 	if (IS_ERR(mxc_rng->mem)) {
 		err = PTR_ERR(mxc_rng->mem);
 		goto err_ioremap;

commit fcaf20360a5992b88603271ab814a200e28d0088
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:08 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 159
    
    Based on 1 normalized pattern(s):
    
      the code contained herein is licensed under the gnu general public
      license you may obtain a copy of the gnu general public license
      version 2 or later at the following locations http www opensource
      org licenses gpl license html http www gnu org copyleft gpl html
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 161 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070033.383790741@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/char/hw_random/mxc-rnga.c b/drivers/char/hw_random/mxc-rnga.c
index f83bee513d91..ea2bf18b1fbb 100644
--- a/drivers/char/hw_random/mxc-rnga.c
+++ b/drivers/char/hw_random/mxc-rnga.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * RNG driver for Freescale RNGA
  *
@@ -6,12 +7,6 @@
  */
 
 /*
- * The code contained herein is licensed under the GNU General Public
- * License. You may obtain a copy of the GNU General Public License
- * Version 2 or later at the following locations:
- *
- * http://www.opensource.org/licenses/gpl-license.html
- * http://www.gnu.org/copyleft/gpl.html
  *
  * This driver is based on other RNG drivers.
  */

commit a6ab6402c4e5ffd3379ba6adfbd2c74101a879c0
Author: Vladimir Zapolskiy <vz@mleia.com>
Date:   Tue Mar 6 00:21:00 2018 +0200

    hwrng: mxc-rnga - add driver support on boards with device tree
    
    The driver works well on i.MX31 powered boards with device description
    taken from board device tree, the only change to add to the driver is
    the missing OF device id, the affected list of included headers and
    indentation in platform driver struct are beautified a little.
    
    Signed-off-by: Vladimir Zapolskiy <vz@mleia.com>
    Reviewed-by: Fabio Estevam <fabio.estevam@nxp.com>
    Reviewed-by: Kim Phillips <kim.phillips@arm.com>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/char/hw_random/mxc-rnga.c b/drivers/char/hw_random/mxc-rnga.c
index 467362262651..f83bee513d91 100644
--- a/drivers/char/hw_random/mxc-rnga.c
+++ b/drivers/char/hw_random/mxc-rnga.c
@@ -16,16 +16,13 @@
  * This driver is based on other RNG drivers.
  */
 
-#include <linux/module.h>
-#include <linux/init.h>
-#include <linux/kernel.h>
 #include <linux/clk.h>
-#include <linux/err.h>
-#include <linux/ioport.h>
-#include <linux/platform_device.h>
-#include <linux/hw_random.h>
 #include <linux/delay.h>
+#include <linux/hw_random.h>
 #include <linux/io.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/platform_device.h>
 
 /* RNGA Registers */
 #define RNGA_CONTROL			0x00
@@ -197,10 +194,18 @@ static int __exit mxc_rnga_remove(struct platform_device *pdev)
 	return 0;
 }
 
+static const struct of_device_id mxc_rnga_of_match[] = {
+	{ .compatible = "fsl,imx21-rnga", },
+	{ .compatible = "fsl,imx31-rnga", },
+	{ /* sentinel */ },
+};
+MODULE_DEVICE_TABLE(of, mxc_rnga_of_match);
+
 static struct platform_driver mxc_rnga_driver = {
 	.driver = {
-		   .name = "mxc_rnga",
-		   },
+		.name = "mxc_rnga",
+		.of_match_table = mxc_rnga_of_match,
+	},
 	.remove = __exit_p(mxc_rnga_remove),
 };
 

commit 05db0ad8656376e341db6120758d04c247c9cf2f
Author: Fabio Estevam <fabio.estevam@freescale.com>
Date:   Sat Sep 12 20:19:53 2015 -0300

    hwrng: mxc-rnga - Use the preferred format for kzalloc
    
    According to Documentation/CodingStyle:
    
    "The preferred form for passing a size of a struct is the following:
    
            p = kmalloc(sizeof(*p), ...);"
    
    ,so do as suggested.
    
    Signed-off-by: Fabio Estevam <fabio.estevam@freescale.com>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/char/hw_random/mxc-rnga.c b/drivers/char/hw_random/mxc-rnga.c
index ed2e3ef9f347..467362262651 100644
--- a/drivers/char/hw_random/mxc-rnga.c
+++ b/drivers/char/hw_random/mxc-rnga.c
@@ -145,8 +145,7 @@ static int __init mxc_rnga_probe(struct platform_device *pdev)
 	struct resource *res;
 	struct mxc_rng *mxc_rng;
 
-	mxc_rng = devm_kzalloc(&pdev->dev, sizeof(struct mxc_rng),
-					GFP_KERNEL);
+	mxc_rng = devm_kzalloc(&pdev->dev, sizeof(*mxc_rng), GFP_KERNEL);
 	if (!mxc_rng)
 		return -ENOMEM;
 

commit eeb322540987d42a480cf8516fb88cda46347882
Author: Fabio Estevam <fabio.estevam@freescale.com>
Date:   Sat Sep 12 20:19:52 2015 -0300

    hwrng: mxc-rnga - Remove unnecessary dev_info message
    
    There is no need to print a message simply saying that a kernel
    driver has been registered, so remove it.
    
    Signed-off-by: Fabio Estevam <fabio.estevam@freescale.com>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/char/hw_random/mxc-rnga.c b/drivers/char/hw_random/mxc-rnga.c
index c7380b80c344..ed2e3ef9f347 100644
--- a/drivers/char/hw_random/mxc-rnga.c
+++ b/drivers/char/hw_random/mxc-rnga.c
@@ -180,8 +180,6 @@ static int __init mxc_rnga_probe(struct platform_device *pdev)
 		goto err_ioremap;
 	}
 
-	dev_info(&pdev->dev, "MXC RNGA Registered.\n");
-
 	return 0;
 
 err_ioremap:

commit c09e2cc69441ef5d99d31aa83f7d2b6239e5b9a7
Author: Fabio Estevam <fabio.estevam@freescale.com>
Date:   Sat Sep 12 20:19:51 2015 -0300

    hwrng: mxc-rnga - Remove uneeded initialization
    
    There is no need to pre-initialize variable 'err' as this
    initial value will be overwritten later on.
    
    Signed-off-by: Fabio Estevam <fabio.estevam@freescale.com>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/char/hw_random/mxc-rnga.c b/drivers/char/hw_random/mxc-rnga.c
index 8803126c3330..c7380b80c344 100644
--- a/drivers/char/hw_random/mxc-rnga.c
+++ b/drivers/char/hw_random/mxc-rnga.c
@@ -141,7 +141,7 @@ static void mxc_rnga_cleanup(struct hwrng *rng)
 
 static int __init mxc_rnga_probe(struct platform_device *pdev)
 {
-	int err = -ENODEV;
+	int err;
 	struct resource *res;
 	struct mxc_rng *mxc_rng;
 

commit 1bf2138e9806ea436933d5a803547833f9524c8f
Author: Fabio Estevam <fabio.estevam@freescale.com>
Date:   Sat Sep 12 20:19:50 2015 -0300

    hwrng: mxc-rnga - Remove unneeded goto label
    
    We can simplify the code by returning the error code immediately
    instead of jumping to a goto label.
    
    Signed-off-by: Fabio Estevam <fabio.estevam@freescale.com>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/char/hw_random/mxc-rnga.c b/drivers/char/hw_random/mxc-rnga.c
index 6cbb72ec6013..8803126c3330 100644
--- a/drivers/char/hw_random/mxc-rnga.c
+++ b/drivers/char/hw_random/mxc-rnga.c
@@ -160,13 +160,12 @@ static int __init mxc_rnga_probe(struct platform_device *pdev)
 	mxc_rng->clk = devm_clk_get(&pdev->dev, NULL);
 	if (IS_ERR(mxc_rng->clk)) {
 		dev_err(&pdev->dev, "Could not get rng_clk!\n");
-		err = PTR_ERR(mxc_rng->clk);
-		goto out;
+		return PTR_ERR(mxc_rng->clk);
 	}
 
 	err = clk_prepare_enable(mxc_rng->clk);
 	if (err)
-		goto out;
+		return err;
 
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	mxc_rng->mem = devm_ioremap_resource(&pdev->dev, res);
@@ -187,8 +186,6 @@ static int __init mxc_rnga_probe(struct platform_device *pdev)
 
 err_ioremap:
 	clk_disable_unprepare(mxc_rng->clk);
-
-out:
 	return err;
 }
 

commit eff54802fe981a378555aebd86af0d11e83899ff
Author: Wolfram Sang <wsa@the-dreams.de>
Date:   Mon Oct 20 16:20:20 2014 +0200

    char: hw_random: drop owner assignment from platform_drivers
    
    A platform_driver does not need to set an owner, it will be populated by the
    driver core.
    
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/char/hw_random/mxc-rnga.c b/drivers/char/hw_random/mxc-rnga.c
index 6a86b6f56af2..6cbb72ec6013 100644
--- a/drivers/char/hw_random/mxc-rnga.c
+++ b/drivers/char/hw_random/mxc-rnga.c
@@ -206,7 +206,6 @@ static int __exit mxc_rnga_remove(struct platform_device *pdev)
 static struct platform_driver mxc_rnga_driver = {
 	.driver = {
 		   .name = "mxc_rnga",
-		   .owner = THIS_MODULE,
 		   },
 	.remove = __exit_p(mxc_rnga_remove),
 };

commit 9e01d0c6f63a59cc756c0028e17effdbadee7227
Author: Fabio Estevam <fabio.estevam@freescale.com>
Date:   Sun Jul 21 14:41:38 2013 -0300

    hwrng: mxc-rnga - Check the return value from clk_prepare_enable()
    
    clk_prepare_enable() may fail, so let's check its return value and propagate it
    in the case of error.
    
    Signed-off-by: Fabio Estevam <fabio.estevam@freescale.com>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/char/hw_random/mxc-rnga.c b/drivers/char/hw_random/mxc-rnga.c
index 19a12ac64a9e..6a86b6f56af2 100644
--- a/drivers/char/hw_random/mxc-rnga.c
+++ b/drivers/char/hw_random/mxc-rnga.c
@@ -164,7 +164,9 @@ static int __init mxc_rnga_probe(struct platform_device *pdev)
 		goto out;
 	}
 
-	clk_prepare_enable(mxc_rng->clk);
+	err = clk_prepare_enable(mxc_rng->clk);
+	if (err)
+		goto out;
 
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	mxc_rng->mem = devm_ioremap_resource(&pdev->dev, res);

commit 2a9ba2ee5f440dd6712ebcb5011e9f00309187c5
Author: Wolfram Sang <wsa@the-dreams.de>
Date:   Sun May 12 15:19:46 2013 +0200

    drivers/char/hw_random: don't check resource with devm_ioremap_resource
    
    devm_ioremap_resource does sanity checks on the given resource. No need to
    duplicate this in the driver.
    
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/char/hw_random/mxc-rnga.c b/drivers/char/hw_random/mxc-rnga.c
index 4ca35e8a5d8c..19a12ac64a9e 100644
--- a/drivers/char/hw_random/mxc-rnga.c
+++ b/drivers/char/hw_random/mxc-rnga.c
@@ -167,11 +167,6 @@ static int __init mxc_rnga_probe(struct platform_device *pdev)
 	clk_prepare_enable(mxc_rng->clk);
 
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	if (!res) {
-		err = -ENOENT;
-		goto err_region;
-	}
-
 	mxc_rng->mem = devm_ioremap_resource(&pdev->dev, res);
 	if (IS_ERR(mxc_rng->mem)) {
 		err = PTR_ERR(mxc_rng->mem);
@@ -189,7 +184,6 @@ static int __init mxc_rnga_probe(struct platform_device *pdev)
 	return 0;
 
 err_ioremap:
-err_region:
 	clk_disable_unprepare(mxc_rng->clk);
 
 out:

commit 797994f81a8b2bdca2eecffa415c1e7a89a4f961
Merge: c8d8566952fd 3862de1f6c44
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu May 2 14:53:12 2013 -0700

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/herbert/crypto-2.6
    
    Pull crypto update from Herbert Xu:
    
     - XTS mode optimisation for twofish/cast6/camellia/aes on x86
    
     - AVX2/x86_64 implementation for blowfish/twofish/serpent/camellia
    
     - SSSE3/AVX/AVX2 optimisations for sha256/sha512
    
     - Added driver for SAHARA2 crypto accelerator
    
     - Fix for GMAC when used in non-IPsec secnarios
    
     - Added generic CMAC implementation (including IPsec glue)
    
     - IP update for crypto/atmel
    
     - Support for more than one device in hwrng/timeriomem
    
     - Added Broadcom BCM2835 RNG driver
    
     - Misc fixes
    
    * git://git.kernel.org/pub/scm/linux/kernel/git/herbert/crypto-2.6: (59 commits)
      crypto: caam - fix job ring cleanup code
      crypto: camellia - add AVX2/AES-NI/x86_64 assembler implementation of camellia cipher
      crypto: serpent - add AVX2/x86_64 assembler implementation of serpent cipher
      crypto: twofish - add AVX2/x86_64 assembler implementation of twofish cipher
      crypto: blowfish - add AVX2/x86_64 implementation of blowfish cipher
      crypto: tcrypt - add async cipher speed tests for blowfish
      crypto: testmgr - extend camellia test-vectors for camellia-aesni/avx2
      crypto: aesni_intel - fix Kconfig problem with CRYPTO_GLUE_HELPER_X86
      crypto: aesni_intel - add more optimized XTS mode for x86-64
      crypto: x86/camellia-aesni-avx - add more optimized XTS code
      crypto: cast6-avx: use new optimized XTS code
      crypto: x86/twofish-avx - use optimized XTS code
      crypto: x86 - add more optimized XTS-mode for serpent-avx
      xfrm: add rfc4494 AES-CMAC-96 support
      crypto: add CMAC support to CryptoAPI
      crypto: testmgr - add empty test vectors for null ciphers
      crypto: testmgr - add AES GMAC test vectors
      crypto: gcm - fix rfc4543 to handle async crypto correctly
      crypto: gcm - make GMAC work when dst and src are different
      hwrng: timeriomem - added devicetree hooks
      ...

commit 264878e6a7eb02841100beb0d999987ef3b5e17f
Author: Fabio Estevam <fabio.estevam@freescale.com>
Date:   Wed Mar 13 00:57:27 2013 -0300

    hwrng: mxc-rnga - Use devm_ioremap_resource()
    
    Using devm_ioremap_resource() can make the code cleaner and simpler.
    
    Signed-off-by: Fabio Estevam <fabio.estevam@freescale.com>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/char/hw_random/mxc-rnga.c b/drivers/char/hw_random/mxc-rnga.c
index f05d85713fd3..93fc74164ee6 100644
--- a/drivers/char/hw_random/mxc-rnga.c
+++ b/drivers/char/hw_random/mxc-rnga.c
@@ -142,7 +142,7 @@ static void mxc_rnga_cleanup(struct hwrng *rng)
 static int __init mxc_rnga_probe(struct platform_device *pdev)
 {
 	int err = -ENODEV;
-	struct resource *res, *mem;
+	struct resource *res;
 	struct mxc_rng *mxc_rng;
 
 	mxc_rng = devm_kzalloc(&pdev->dev, sizeof(struct mxc_rng),
@@ -172,15 +172,9 @@ static int __init mxc_rnga_probe(struct platform_device *pdev)
 		goto err_region;
 	}
 
-	mem = request_mem_region(res->start, resource_size(res), pdev->name);
-	if (mem == NULL) {
-		err = -EBUSY;
-		goto err_region;
-	}
-
-	mxc_rng->mem = ioremap(res->start, resource_size(res));
-	if (!mxc_rng->mem) {
-		err = -ENOMEM;
+	mxc_rng->mem = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(mxc_rng->mem)) {
+		err = PTR_ERR(mxc_rng->mem);
 		goto err_ioremap;
 	}
 
@@ -195,8 +189,6 @@ static int __init mxc_rnga_probe(struct platform_device *pdev)
 	return 0;
 
 err_ioremap:
-	release_mem_region(res->start, resource_size(res));
-
 err_region:
 	clk_disable_unprepare(mxc_rng->clk);
 
@@ -206,15 +198,10 @@ static int __init mxc_rnga_probe(struct platform_device *pdev)
 
 static int __exit mxc_rnga_remove(struct platform_device *pdev)
 {
-	struct resource *res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	struct mxc_rng *mxc_rng = platform_get_drvdata(pdev);
 
 	hwrng_unregister(&mxc_rng->rng);
 
-	iounmap(mxc_rng->mem);
-
-	release_mem_region(res->start, resource_size(res));
-
 	clk_disable_unprepare(mxc_rng->clk);
 
 	return 0;

commit e7c2199ff300fcf88673a1cf6d7229e6c3da09de
Author: Fabio Porcedda <fabio.porcedda@gmail.com>
Date:   Thu Mar 14 18:09:33 2013 +0100

    drivers: char: use module_platform_driver_probe()
    
    This patch converts the drivers to use the
    module_platform_driver_probe() macro which makes the code smaller and
    a bit simpler.
    
    Signed-off-by: Fabio Porcedda <fabio.porcedda@gmail.com>
    Cc: Matt Mackall <mpm@selenic.com>
    Cc: Herbert Xu <herbert@gondor.apana.org.au>
    Cc: Fabio Estevam <fabio.estevam@freescale.com>
    Cc: Sascha Hauer <s.hauer@pengutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/char/hw_random/mxc-rnga.c b/drivers/char/hw_random/mxc-rnga.c
index f05d85713fd3..895d0b8fb9ab 100644
--- a/drivers/char/hw_random/mxc-rnga.c
+++ b/drivers/char/hw_random/mxc-rnga.c
@@ -228,18 +228,7 @@ static struct platform_driver mxc_rnga_driver = {
 	.remove = __exit_p(mxc_rnga_remove),
 };
 
-static int __init mod_init(void)
-{
-	return platform_driver_probe(&mxc_rnga_driver, mxc_rnga_probe);
-}
-
-static void __exit mod_exit(void)
-{
-	platform_driver_unregister(&mxc_rnga_driver);
-}
-
-module_init(mod_init);
-module_exit(mod_exit);
+module_platform_driver_probe(mxc_rnga_driver, mxc_rnga_probe);
 
 MODULE_AUTHOR("Freescale Semiconductor, Inc.");
 MODULE_DESCRIPTION("H/W RNGA driver for i.MX");

commit 821873abc20e28fe3faa98591dab91d9b00700a5
Author: Fabio Estevam <fabio.estevam@freescale.com>
Date:   Tue Sep 4 18:35:22 2012 -0300

    hwrng: mxc-rnga - Access data via structure
    
    In current driver, everytime we need to access the rng clock
    ,ie to enable or disable it, a call to clk_get is done.
    
    This is not correct and the preferred way is to provide a rng data structure
    that could be used for accessing rng resources.
    
    Acked-by: Sascha Hauer <s.hauer@pengutronix.de>
    Signed-off-by: Fabio Estevam <fabio.estevam@freescale.com>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/char/hw_random/mxc-rnga.c b/drivers/char/hw_random/mxc-rnga.c
index 62c7efe375ab..f05d85713fd3 100644
--- a/drivers/char/hw_random/mxc-rnga.c
+++ b/drivers/char/hw_random/mxc-rnga.c
@@ -59,16 +59,21 @@
 #define RNGA_STATUS_LAST_READ_STATUS	0x00000002
 #define RNGA_STATUS_SECURITY_VIOLATION	0x00000001
 
-static struct platform_device *rng_dev;
+struct mxc_rng {
+	struct device *dev;
+	struct hwrng rng;
+	void __iomem *mem;
+	struct clk *clk;
+};
 
 static int mxc_rnga_data_present(struct hwrng *rng, int wait)
 {
-	void __iomem *rng_base = (void __iomem *)rng->priv;
 	int i;
+	struct mxc_rng *mxc_rng = container_of(rng, struct mxc_rng, rng);
 
 	for (i = 0; i < 20; i++) {
 		/* how many random numbers are in FIFO? [0-16] */
-		int level = (__raw_readl(rng_base + RNGA_STATUS) &
+		int level = (__raw_readl(mxc_rng->mem + RNGA_STATUS) &
 				RNGA_STATUS_LEVEL_MASK) >> 8;
 		if (level || !wait)
 			return !!level;
@@ -81,20 +86,20 @@ static int mxc_rnga_data_read(struct hwrng *rng, u32 * data)
 {
 	int err;
 	u32 ctrl;
-	void __iomem *rng_base = (void __iomem *)rng->priv;
+	struct mxc_rng *mxc_rng = container_of(rng, struct mxc_rng, rng);
 
 	/* retrieve a random number from FIFO */
-	*data = __raw_readl(rng_base + RNGA_OUTPUT_FIFO);
+	*data = __raw_readl(mxc_rng->mem + RNGA_OUTPUT_FIFO);
 
 	/* some error while reading this random number? */
-	err = __raw_readl(rng_base + RNGA_STATUS) & RNGA_STATUS_ERROR_INT;
+	err = __raw_readl(mxc_rng->mem + RNGA_STATUS) & RNGA_STATUS_ERROR_INT;
 
 	/* if error: clear error interrupt, but doesn't return random number */
 	if (err) {
-		dev_dbg(&rng_dev->dev, "Error while reading random number!\n");
-		ctrl = __raw_readl(rng_base + RNGA_CONTROL);
+		dev_dbg(mxc_rng->dev, "Error while reading random number!\n");
+		ctrl = __raw_readl(mxc_rng->mem + RNGA_CONTROL);
 		__raw_writel(ctrl | RNGA_CONTROL_CLEAR_INT,
-					rng_base + RNGA_CONTROL);
+					mxc_rng->mem + RNGA_CONTROL);
 		return 0;
 	} else
 		return 4;
@@ -103,22 +108,22 @@ static int mxc_rnga_data_read(struct hwrng *rng, u32 * data)
 static int mxc_rnga_init(struct hwrng *rng)
 {
 	u32 ctrl, osc;
-	void __iomem *rng_base = (void __iomem *)rng->priv;
+	struct mxc_rng *mxc_rng = container_of(rng, struct mxc_rng, rng);
 
 	/* wake up */
-	ctrl = __raw_readl(rng_base + RNGA_CONTROL);
-	__raw_writel(ctrl & ~RNGA_CONTROL_SLEEP, rng_base + RNGA_CONTROL);
+	ctrl = __raw_readl(mxc_rng->mem + RNGA_CONTROL);
+	__raw_writel(ctrl & ~RNGA_CONTROL_SLEEP, mxc_rng->mem + RNGA_CONTROL);
 
 	/* verify if oscillator is working */
-	osc = __raw_readl(rng_base + RNGA_STATUS);
+	osc = __raw_readl(mxc_rng->mem + RNGA_STATUS);
 	if (osc & RNGA_STATUS_OSC_DEAD) {
-		dev_err(&rng_dev->dev, "RNGA Oscillator is dead!\n");
+		dev_err(mxc_rng->dev, "RNGA Oscillator is dead!\n");
 		return -ENODEV;
 	}
 
 	/* go running */
-	ctrl = __raw_readl(rng_base + RNGA_CONTROL);
-	__raw_writel(ctrl | RNGA_CONTROL_GO, rng_base + RNGA_CONTROL);
+	ctrl = __raw_readl(mxc_rng->mem + RNGA_CONTROL);
+	__raw_writel(ctrl | RNGA_CONTROL_GO, mxc_rng->mem + RNGA_CONTROL);
 
 	return 0;
 }
@@ -126,40 +131,40 @@ static int mxc_rnga_init(struct hwrng *rng)
 static void mxc_rnga_cleanup(struct hwrng *rng)
 {
 	u32 ctrl;
-	void __iomem *rng_base = (void __iomem *)rng->priv;
+	struct mxc_rng *mxc_rng = container_of(rng, struct mxc_rng, rng);
 
-	ctrl = __raw_readl(rng_base + RNGA_CONTROL);
+	ctrl = __raw_readl(mxc_rng->mem + RNGA_CONTROL);
 
 	/* stop rnga */
-	__raw_writel(ctrl & ~RNGA_CONTROL_GO, rng_base + RNGA_CONTROL);
+	__raw_writel(ctrl & ~RNGA_CONTROL_GO, mxc_rng->mem + RNGA_CONTROL);
 }
 
-static struct hwrng mxc_rnga = {
-	.name = "mxc-rnga",
-	.init = mxc_rnga_init,
-	.cleanup = mxc_rnga_cleanup,
-	.data_present = mxc_rnga_data_present,
-	.data_read = mxc_rnga_data_read
-};
-
 static int __init mxc_rnga_probe(struct platform_device *pdev)
 {
 	int err = -ENODEV;
-	struct clk *clk;
 	struct resource *res, *mem;
-	void __iomem *rng_base = NULL;
-
-	if (rng_dev)
-		return -EBUSY;
-
-	clk = clk_get(&pdev->dev, NULL);
-	if (IS_ERR(clk)) {
+	struct mxc_rng *mxc_rng;
+
+	mxc_rng = devm_kzalloc(&pdev->dev, sizeof(struct mxc_rng),
+					GFP_KERNEL);
+	if (!mxc_rng)
+		return -ENOMEM;
+
+	mxc_rng->dev = &pdev->dev;
+	mxc_rng->rng.name = "mxc-rnga";
+	mxc_rng->rng.init = mxc_rnga_init;
+	mxc_rng->rng.cleanup = mxc_rnga_cleanup,
+	mxc_rng->rng.data_present = mxc_rnga_data_present,
+	mxc_rng->rng.data_read = mxc_rnga_data_read,
+
+	mxc_rng->clk = devm_clk_get(&pdev->dev, NULL);
+	if (IS_ERR(mxc_rng->clk)) {
 		dev_err(&pdev->dev, "Could not get rng_clk!\n");
-		err = PTR_ERR(clk);
+		err = PTR_ERR(mxc_rng->clk);
 		goto out;
 	}
 
-	clk_prepare_enable(clk);
+	clk_prepare_enable(mxc_rng->clk);
 
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	if (!res) {
@@ -173,36 +178,27 @@ static int __init mxc_rnga_probe(struct platform_device *pdev)
 		goto err_region;
 	}
 
-	rng_base = ioremap(res->start, resource_size(res));
-	if (!rng_base) {
+	mxc_rng->mem = ioremap(res->start, resource_size(res));
+	if (!mxc_rng->mem) {
 		err = -ENOMEM;
 		goto err_ioremap;
 	}
 
-	mxc_rnga.priv = (unsigned long)rng_base;
-
-	err = hwrng_register(&mxc_rnga);
+	err = hwrng_register(&mxc_rng->rng);
 	if (err) {
 		dev_err(&pdev->dev, "MXC RNGA registering failed (%d)\n", err);
-		goto err_register;
+		goto err_ioremap;
 	}
 
-	rng_dev = pdev;
-
 	dev_info(&pdev->dev, "MXC RNGA Registered.\n");
 
 	return 0;
 
-err_register:
-	iounmap(rng_base);
-	rng_base = NULL;
-
 err_ioremap:
 	release_mem_region(res->start, resource_size(res));
 
 err_region:
-	clk_disable_unprepare(clk);
-	clk_put(clk);
+	clk_disable_unprepare(mxc_rng->clk);
 
 out:
 	return err;
@@ -211,17 +207,15 @@ static int __init mxc_rnga_probe(struct platform_device *pdev)
 static int __exit mxc_rnga_remove(struct platform_device *pdev)
 {
 	struct resource *res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	void __iomem *rng_base = (void __iomem *)mxc_rnga.priv;
-	struct clk *clk = clk_get(&pdev->dev, NULL);
+	struct mxc_rng *mxc_rng = platform_get_drvdata(pdev);
 
-	hwrng_unregister(&mxc_rnga);
+	hwrng_unregister(&mxc_rng->rng);
 
-	iounmap(rng_base);
+	iounmap(mxc_rng->mem);
 
 	release_mem_region(res->start, resource_size(res));
 
-	clk_disable_unprepare(clk);
-	clk_put(clk);
+	clk_disable_unprepare(mxc_rng->clk);
 
 	return 0;
 }

commit a9ccb7bd0a781bce85db3b182e4c0c03688553c1
Author: Fabio Estevam <fabio.estevam@freescale.com>
Date:   Tue Sep 4 18:35:21 2012 -0300

    hwrng: mxc-rnga - Adapt clocks to new i.mx clock framework
    
    Adapt clocks to the new i.mx clock framework and fix the following warning:
    
    ------------[ cut here ]------------
    WARNING: at drivers/clk/clk.c:511 __clk_enable+0x9c/0xac()
    Modules linked in:
    Backtrace:
    [<800124c8>] (dump_backtrace+0x0/0x10c) from [<804172dc>] (dump_stack+0x18/0x1c)
     r7:00000009 r6:000001ff r5:8032cb50 r4:00000000
    [<804172c4>] (dump_stack+0x0/0x1c) from [<80021834>] (warn_slowpath_common+0x54)
    [<800217e0>] (warn_slowpath_common+0x0/0x6c) from [<80021870>] (warn_slowpath_n)
     r9:80581cac r8:8700a9c0 r7:805ab070 r6:80000013 r5:806133d4
    r4:8700a9c0
    [<8002184c>] (warn_slowpath_null+0x0/0x2c) from [<8032cb50>] (__clk_enable+0x9c)
    [<8032cab4>] (__clk_enable+0x0/0xac) from [<8032cb88>] (clk_enable+0x28/0x44)
     r5:806133d4 r4:8700a9c0
    [<8032cb60>] (clk_enable+0x0/0x44) from [<80560f14>] (mxc_rnga_probe+0x68/0x164)
     r7:805ab070 r6:8706ec00 r5:80611314 r4:00000000
    [<80560eac>] (mxc_rnga_probe+0x0/0x164) from [<8025914c>] (platform_drv_probe+0)
    [<8025912c>] (platform_drv_probe+0x0/0x24) from [<80257c7c>] (driver_probe_devi)
    [<80257bfc>] (driver_probe_device+0x0/0x204) from [<80257e94>] (__driver_attach)
     r9:80581cac r8:0000008e r7:00000000 r6:8706ec3c r5:805ab070
    r4:8706ec08
    [<80257e00>] (__driver_attach+0x0/0x98) from [<8025642c>] (bus_for_each_dev+0x6)
     r7:00000000 r6:80257e00 r5:87035e98 r4:805ab070
    [<802563c4>] (bus_for_each_dev+0x0/0x94) from [<80257adc>] (driver_attach+0x20/)
     r7:00000000 r6:873f2380 r5:805ab338 r4:805ab070
    [<80257abc>] (driver_attach+0x0/0x28) from [<80256d50>] (bus_add_driver+0x18c/0)
    [<80256bc4>] (bus_add_driver+0x0/0x268) from [<802584c4>] (driver_register+0x80)
    [<80258444>] (driver_register+0x0/0x134) from [<802594f4>] (platform_driver_reg)
     r7:00000000 r6:805c2e00 r5:00000007 r4:805ab05c
    [<802594a8>] (platform_driver_register+0x0/0x60) from [<80259528>] (platform_dr)
    [<80259508>] (platform_driver_probe+0x0/0xa4) from [<80560ea0>] (mod_init+0x18/)
     r7:00000000 r6:805c2e00 r5:00000007 r4:87034000
    [<80560e88>] (mod_init+0x0/0x24) from [<800086b4>] (do_one_initcall+0x40/0x194)
    [<80008674>] (do_one_initcall+0x0/0x194) from [<8053d3f4>] (kernel_init+0xfc/0x)
    [<8053d2f8>] (kernel_init+0x0/0x1cc) from [<80027190>] (do_exit+0x0/0x7ec)
    ---[ end trace 4198eed02050f461 ]---
    
    Acked-by: Sascha Hauer <s.hauer@pengutronix.de>
    Signed-off-by: Fabio Estevam <fabio.estevam@freescale.com>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/char/hw_random/mxc-rnga.c b/drivers/char/hw_random/mxc-rnga.c
index 85074de5042e..62c7efe375ab 100644
--- a/drivers/char/hw_random/mxc-rnga.c
+++ b/drivers/char/hw_random/mxc-rnga.c
@@ -152,14 +152,14 @@ static int __init mxc_rnga_probe(struct platform_device *pdev)
 	if (rng_dev)
 		return -EBUSY;
 
-	clk = clk_get(&pdev->dev, "rng");
+	clk = clk_get(&pdev->dev, NULL);
 	if (IS_ERR(clk)) {
 		dev_err(&pdev->dev, "Could not get rng_clk!\n");
 		err = PTR_ERR(clk);
 		goto out;
 	}
 
-	clk_enable(clk);
+	clk_prepare_enable(clk);
 
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	if (!res) {
@@ -201,7 +201,7 @@ static int __init mxc_rnga_probe(struct platform_device *pdev)
 	release_mem_region(res->start, resource_size(res));
 
 err_region:
-	clk_disable(clk);
+	clk_disable_unprepare(clk);
 	clk_put(clk);
 
 out:
@@ -212,7 +212,7 @@ static int __exit mxc_rnga_remove(struct platform_device *pdev)
 {
 	struct resource *res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	void __iomem *rng_base = (void __iomem *)mxc_rnga.priv;
-	struct clk *clk = clk_get(&pdev->dev, "rng");
+	struct clk *clk = clk_get(&pdev->dev, NULL);
 
 	hwrng_unregister(&mxc_rnga);
 
@@ -220,7 +220,7 @@ static int __exit mxc_rnga_remove(struct platform_device *pdev)
 
 	release_mem_region(res->start, resource_size(res));
 
-	clk_disable(clk);
+	clk_disable_unprepare(clk);
 	clk_put(clk);
 
 	return 0;

commit 3621189064301a5fbb5d06ca17d966a026f4e501
Author: Benoît Thébaudeau <benoit.thebaudeau@advansee.com>
Date:   Wed Jun 13 18:15:34 2012 +0200

    hwrng: mxc-rnga - fix data_present API
    
    Commit 45001e9, which added support for RNGA, ignored the previous commit
    984e976, which changed the data_present API.
    
    Cc: Matt Mackall <mpm@selenic.com>
    Cc: Sascha Hauer <kernel@pengutronix.de>
    Cc: Alan Carvalho de Assis <acassis@gmail.com>
    Cc: <linux-arm-kernel@lists.infradead.org>
    Signed-off-by: Benoît Thébaudeau <benoit.thebaudeau@advansee.com>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/drivers/char/hw_random/mxc-rnga.c b/drivers/char/hw_random/mxc-rnga.c
index 187c6be80f43..85074de5042e 100644
--- a/drivers/char/hw_random/mxc-rnga.c
+++ b/drivers/char/hw_random/mxc-rnga.c
@@ -24,6 +24,7 @@
 #include <linux/ioport.h>
 #include <linux/platform_device.h>
 #include <linux/hw_random.h>
+#include <linux/delay.h>
 #include <linux/io.h>
 
 /* RNGA Registers */
@@ -60,16 +61,20 @@
 
 static struct platform_device *rng_dev;
 
-static int mxc_rnga_data_present(struct hwrng *rng)
+static int mxc_rnga_data_present(struct hwrng *rng, int wait)
 {
-	int level;
 	void __iomem *rng_base = (void __iomem *)rng->priv;
-
-	/* how many random numbers is in FIFO? [0-16] */
-	level = ((__raw_readl(rng_base + RNGA_STATUS) &
-			RNGA_STATUS_LEVEL_MASK) >> 8);
-
-	return level > 0 ? 1 : 0;
+	int i;
+
+	for (i = 0; i < 20; i++) {
+		/* how many random numbers are in FIFO? [0-16] */
+		int level = (__raw_readl(rng_base + RNGA_STATUS) &
+				RNGA_STATUS_LEVEL_MASK) >> 8;
+		if (level || !wait)
+			return !!level;
+		udelay(10);
+	}
+	return 0;
 }
 
 static int mxc_rnga_data_read(struct hwrng *rng, u32 * data)

commit 45001e92d0249a8c4b9f6c3695215652e8e8493d
Author: Alan Carvalho de Assis <acassis@gmail.com>
Date:   Thu Apr 2 12:38:41 2009 -0300

    i.MX31: Add hw-random for RNGA
    
    This hw-random driver add support to RNGA hardware found
    on some i.MX processors.
    
    Signed-off-by: Alan Carvalho de Assis <acassis@gmail.com>
    Acked-by: Matt Mackall <mpm@selenic.com>
    Signed-off-by: Sascha Hauer <s.hauer@pengutronix.de>

diff --git a/drivers/char/hw_random/mxc-rnga.c b/drivers/char/hw_random/mxc-rnga.c
new file mode 100644
index 000000000000..187c6be80f43
--- /dev/null
+++ b/drivers/char/hw_random/mxc-rnga.c
@@ -0,0 +1,247 @@
+/*
+ * RNG driver for Freescale RNGA
+ *
+ * Copyright 2008-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Author: Alan Carvalho de Assis <acassis@gmail.com>
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ *
+ * This driver is based on other RNG drivers.
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/clk.h>
+#include <linux/err.h>
+#include <linux/ioport.h>
+#include <linux/platform_device.h>
+#include <linux/hw_random.h>
+#include <linux/io.h>
+
+/* RNGA Registers */
+#define RNGA_CONTROL			0x00
+#define RNGA_STATUS			0x04
+#define RNGA_ENTROPY			0x08
+#define RNGA_OUTPUT_FIFO		0x0c
+#define RNGA_MODE			0x10
+#define RNGA_VERIFICATION_CONTROL	0x14
+#define RNGA_OSC_CONTROL_COUNTER	0x18
+#define RNGA_OSC1_COUNTER		0x1c
+#define RNGA_OSC2_COUNTER		0x20
+#define RNGA_OSC_COUNTER_STATUS		0x24
+
+/* RNGA Registers Range */
+#define RNG_ADDR_RANGE			0x28
+
+/* RNGA Control Register */
+#define RNGA_CONTROL_SLEEP		0x00000010
+#define RNGA_CONTROL_CLEAR_INT		0x00000008
+#define RNGA_CONTROL_MASK_INTS		0x00000004
+#define RNGA_CONTROL_HIGH_ASSURANCE	0x00000002
+#define RNGA_CONTROL_GO			0x00000001
+
+#define RNGA_STATUS_LEVEL_MASK		0x0000ff00
+
+/* RNGA Status Register */
+#define RNGA_STATUS_OSC_DEAD		0x80000000
+#define RNGA_STATUS_SLEEP		0x00000010
+#define RNGA_STATUS_ERROR_INT		0x00000008
+#define RNGA_STATUS_FIFO_UNDERFLOW	0x00000004
+#define RNGA_STATUS_LAST_READ_STATUS	0x00000002
+#define RNGA_STATUS_SECURITY_VIOLATION	0x00000001
+
+static struct platform_device *rng_dev;
+
+static int mxc_rnga_data_present(struct hwrng *rng)
+{
+	int level;
+	void __iomem *rng_base = (void __iomem *)rng->priv;
+
+	/* how many random numbers is in FIFO? [0-16] */
+	level = ((__raw_readl(rng_base + RNGA_STATUS) &
+			RNGA_STATUS_LEVEL_MASK) >> 8);
+
+	return level > 0 ? 1 : 0;
+}
+
+static int mxc_rnga_data_read(struct hwrng *rng, u32 * data)
+{
+	int err;
+	u32 ctrl;
+	void __iomem *rng_base = (void __iomem *)rng->priv;
+
+	/* retrieve a random number from FIFO */
+	*data = __raw_readl(rng_base + RNGA_OUTPUT_FIFO);
+
+	/* some error while reading this random number? */
+	err = __raw_readl(rng_base + RNGA_STATUS) & RNGA_STATUS_ERROR_INT;
+
+	/* if error: clear error interrupt, but doesn't return random number */
+	if (err) {
+		dev_dbg(&rng_dev->dev, "Error while reading random number!\n");
+		ctrl = __raw_readl(rng_base + RNGA_CONTROL);
+		__raw_writel(ctrl | RNGA_CONTROL_CLEAR_INT,
+					rng_base + RNGA_CONTROL);
+		return 0;
+	} else
+		return 4;
+}
+
+static int mxc_rnga_init(struct hwrng *rng)
+{
+	u32 ctrl, osc;
+	void __iomem *rng_base = (void __iomem *)rng->priv;
+
+	/* wake up */
+	ctrl = __raw_readl(rng_base + RNGA_CONTROL);
+	__raw_writel(ctrl & ~RNGA_CONTROL_SLEEP, rng_base + RNGA_CONTROL);
+
+	/* verify if oscillator is working */
+	osc = __raw_readl(rng_base + RNGA_STATUS);
+	if (osc & RNGA_STATUS_OSC_DEAD) {
+		dev_err(&rng_dev->dev, "RNGA Oscillator is dead!\n");
+		return -ENODEV;
+	}
+
+	/* go running */
+	ctrl = __raw_readl(rng_base + RNGA_CONTROL);
+	__raw_writel(ctrl | RNGA_CONTROL_GO, rng_base + RNGA_CONTROL);
+
+	return 0;
+}
+
+static void mxc_rnga_cleanup(struct hwrng *rng)
+{
+	u32 ctrl;
+	void __iomem *rng_base = (void __iomem *)rng->priv;
+
+	ctrl = __raw_readl(rng_base + RNGA_CONTROL);
+
+	/* stop rnga */
+	__raw_writel(ctrl & ~RNGA_CONTROL_GO, rng_base + RNGA_CONTROL);
+}
+
+static struct hwrng mxc_rnga = {
+	.name = "mxc-rnga",
+	.init = mxc_rnga_init,
+	.cleanup = mxc_rnga_cleanup,
+	.data_present = mxc_rnga_data_present,
+	.data_read = mxc_rnga_data_read
+};
+
+static int __init mxc_rnga_probe(struct platform_device *pdev)
+{
+	int err = -ENODEV;
+	struct clk *clk;
+	struct resource *res, *mem;
+	void __iomem *rng_base = NULL;
+
+	if (rng_dev)
+		return -EBUSY;
+
+	clk = clk_get(&pdev->dev, "rng");
+	if (IS_ERR(clk)) {
+		dev_err(&pdev->dev, "Could not get rng_clk!\n");
+		err = PTR_ERR(clk);
+		goto out;
+	}
+
+	clk_enable(clk);
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		err = -ENOENT;
+		goto err_region;
+	}
+
+	mem = request_mem_region(res->start, resource_size(res), pdev->name);
+	if (mem == NULL) {
+		err = -EBUSY;
+		goto err_region;
+	}
+
+	rng_base = ioremap(res->start, resource_size(res));
+	if (!rng_base) {
+		err = -ENOMEM;
+		goto err_ioremap;
+	}
+
+	mxc_rnga.priv = (unsigned long)rng_base;
+
+	err = hwrng_register(&mxc_rnga);
+	if (err) {
+		dev_err(&pdev->dev, "MXC RNGA registering failed (%d)\n", err);
+		goto err_register;
+	}
+
+	rng_dev = pdev;
+
+	dev_info(&pdev->dev, "MXC RNGA Registered.\n");
+
+	return 0;
+
+err_register:
+	iounmap(rng_base);
+	rng_base = NULL;
+
+err_ioremap:
+	release_mem_region(res->start, resource_size(res));
+
+err_region:
+	clk_disable(clk);
+	clk_put(clk);
+
+out:
+	return err;
+}
+
+static int __exit mxc_rnga_remove(struct platform_device *pdev)
+{
+	struct resource *res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	void __iomem *rng_base = (void __iomem *)mxc_rnga.priv;
+	struct clk *clk = clk_get(&pdev->dev, "rng");
+
+	hwrng_unregister(&mxc_rnga);
+
+	iounmap(rng_base);
+
+	release_mem_region(res->start, resource_size(res));
+
+	clk_disable(clk);
+	clk_put(clk);
+
+	return 0;
+}
+
+static struct platform_driver mxc_rnga_driver = {
+	.driver = {
+		   .name = "mxc_rnga",
+		   .owner = THIS_MODULE,
+		   },
+	.remove = __exit_p(mxc_rnga_remove),
+};
+
+static int __init mod_init(void)
+{
+	return platform_driver_probe(&mxc_rnga_driver, mxc_rnga_probe);
+}
+
+static void __exit mod_exit(void)
+{
+	platform_driver_unregister(&mxc_rnga_driver);
+}
+
+module_init(mod_init);
+module_exit(mod_exit);
+
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_DESCRIPTION("H/W RNGA driver for i.MX");
+MODULE_LICENSE("GPL");
