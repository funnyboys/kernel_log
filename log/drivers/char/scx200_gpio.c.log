commit 09c434b8a0047c69e48499de0107de312901e798
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sun May 19 13:08:20 2019 +0100

    treewide: Add SPDX license identifier for more missed files
    
    Add SPDX license identifiers to all files which:
    
     - Have no license information of any form
    
     - Have MODULE_LICENCE("GPL*") inside which was used in the initial
       scan/conversion to ignore the file
    
    These files fall under the project license, GPL v2 only. The resulting SPDX
    license identifier is:
    
      GPL-2.0-only
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/char/scx200_gpio.c b/drivers/char/scx200_gpio.c
index 903761bc41c9..9f701dcba95c 100644
--- a/drivers/char/scx200_gpio.c
+++ b/drivers/char/scx200_gpio.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /* linux/drivers/char/scx200_gpio.c
 
    National Semiconductor SCx200 GPIO driver.  Allows a user space

commit 7c0f6ba682b9c7632072ffbedf8d328c8f3c42ba
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Dec 24 11:46:01 2016 -0800

    Replace <asm/uaccess.h> with <linux/uaccess.h> globally
    
    This was entirely automated, using the script by Al:
    
      PATT='^[[:blank:]]*#[[:blank:]]*include[[:blank:]]*<asm/uaccess.h>'
      sed -i -e "s!$PATT!#include <linux/uaccess.h>!" \
            $(git grep -l "$PATT"|grep -v ^include/linux/uaccess.h)
    
    to do the replacement at the end of the merge window.
    
    Requested-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/char/scx200_gpio.c b/drivers/char/scx200_gpio.c
index 0bc135b9b16f..903761bc41c9 100644
--- a/drivers/char/scx200_gpio.c
+++ b/drivers/char/scx200_gpio.c
@@ -12,7 +12,7 @@
 #include <linux/kernel.h>
 #include <linux/init.h>
 #include <linux/platform_device.h>
-#include <asm/uaccess.h>
+#include <linux/uaccess.h>
 #include <asm/io.h>
 
 #include <linux/types.h>

commit 6038f373a3dc1f1c26496e60b6c40b164716f07e
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Sun Aug 15 18:52:59 2010 +0200

    llseek: automatically add .llseek fop
    
    All file_operations should get a .llseek operation so we can make
    nonseekable_open the default for future file operations without a
    .llseek pointer.
    
    The three cases that we can automatically detect are no_llseek, seq_lseek
    and default_llseek. For cases where we can we can automatically prove that
    the file offset is always ignored, we use noop_llseek, which maintains
    the current behavior of not returning an error from a seek.
    
    New drivers should normally not use noop_llseek but instead use no_llseek
    and call nonseekable_open at open time.  Existing drivers can be converted
    to do the same when the maintainer knows for certain that no user code
    relies on calling seek on the device file.
    
    The generated code is often incorrectly indented and right now contains
    comments that clarify for each added line why a specific variant was
    chosen. In the version that gets submitted upstream, the comments will
    be gone and I will manually fix the indentation, because there does not
    seem to be a way to do that using coccinelle.
    
    Some amount of new code is currently sitting in linux-next that should get
    the same modifications, which I will do at the end of the merge window.
    
    Many thanks to Julia Lawall for helping me learn to write a semantic
    patch that does all this.
    
    ===== begin semantic patch =====
    // This adds an llseek= method to all file operations,
    // as a preparation for making no_llseek the default.
    //
    // The rules are
    // - use no_llseek explicitly if we do nonseekable_open
    // - use seq_lseek for sequential files
    // - use default_llseek if we know we access f_pos
    // - use noop_llseek if we know we don't access f_pos,
    //   but we still want to allow users to call lseek
    //
    @ open1 exists @
    identifier nested_open;
    @@
    nested_open(...)
    {
    <+...
    nonseekable_open(...)
    ...+>
    }
    
    @ open exists@
    identifier open_f;
    identifier i, f;
    identifier open1.nested_open;
    @@
    int open_f(struct inode *i, struct file *f)
    {
    <+...
    (
    nonseekable_open(...)
    |
    nested_open(...)
    )
    ...+>
    }
    
    @ read disable optional_qualifier exists @
    identifier read_f;
    identifier f, p, s, off;
    type ssize_t, size_t, loff_t;
    expression E;
    identifier func;
    @@
    ssize_t read_f(struct file *f, char *p, size_t s, loff_t *off)
    {
    <+...
    (
       *off = E
    |
       *off += E
    |
       func(..., off, ...)
    |
       E = *off
    )
    ...+>
    }
    
    @ read_no_fpos disable optional_qualifier exists @
    identifier read_f;
    identifier f, p, s, off;
    type ssize_t, size_t, loff_t;
    @@
    ssize_t read_f(struct file *f, char *p, size_t s, loff_t *off)
    {
    ... when != off
    }
    
    @ write @
    identifier write_f;
    identifier f, p, s, off;
    type ssize_t, size_t, loff_t;
    expression E;
    identifier func;
    @@
    ssize_t write_f(struct file *f, const char *p, size_t s, loff_t *off)
    {
    <+...
    (
      *off = E
    |
      *off += E
    |
      func(..., off, ...)
    |
      E = *off
    )
    ...+>
    }
    
    @ write_no_fpos @
    identifier write_f;
    identifier f, p, s, off;
    type ssize_t, size_t, loff_t;
    @@
    ssize_t write_f(struct file *f, const char *p, size_t s, loff_t *off)
    {
    ... when != off
    }
    
    @ fops0 @
    identifier fops;
    @@
    struct file_operations fops = {
     ...
    };
    
    @ has_llseek depends on fops0 @
    identifier fops0.fops;
    identifier llseek_f;
    @@
    struct file_operations fops = {
    ...
     .llseek = llseek_f,
    ...
    };
    
    @ has_read depends on fops0 @
    identifier fops0.fops;
    identifier read_f;
    @@
    struct file_operations fops = {
    ...
     .read = read_f,
    ...
    };
    
    @ has_write depends on fops0 @
    identifier fops0.fops;
    identifier write_f;
    @@
    struct file_operations fops = {
    ...
     .write = write_f,
    ...
    };
    
    @ has_open depends on fops0 @
    identifier fops0.fops;
    identifier open_f;
    @@
    struct file_operations fops = {
    ...
     .open = open_f,
    ...
    };
    
    // use no_llseek if we call nonseekable_open
    ////////////////////////////////////////////
    @ nonseekable1 depends on !has_llseek && has_open @
    identifier fops0.fops;
    identifier nso ~= "nonseekable_open";
    @@
    struct file_operations fops = {
    ...  .open = nso, ...
    +.llseek = no_llseek, /* nonseekable */
    };
    
    @ nonseekable2 depends on !has_llseek @
    identifier fops0.fops;
    identifier open.open_f;
    @@
    struct file_operations fops = {
    ...  .open = open_f, ...
    +.llseek = no_llseek, /* open uses nonseekable */
    };
    
    // use seq_lseek for sequential files
    /////////////////////////////////////
    @ seq depends on !has_llseek @
    identifier fops0.fops;
    identifier sr ~= "seq_read";
    @@
    struct file_operations fops = {
    ...  .read = sr, ...
    +.llseek = seq_lseek, /* we have seq_read */
    };
    
    // use default_llseek if there is a readdir
    ///////////////////////////////////////////
    @ fops1 depends on !has_llseek && !nonseekable1 && !nonseekable2 && !seq @
    identifier fops0.fops;
    identifier readdir_e;
    @@
    // any other fop is used that changes pos
    struct file_operations fops = {
    ... .readdir = readdir_e, ...
    +.llseek = default_llseek, /* readdir is present */
    };
    
    // use default_llseek if at least one of read/write touches f_pos
    /////////////////////////////////////////////////////////////////
    @ fops2 depends on !fops1 && !has_llseek && !nonseekable1 && !nonseekable2 && !seq @
    identifier fops0.fops;
    identifier read.read_f;
    @@
    // read fops use offset
    struct file_operations fops = {
    ... .read = read_f, ...
    +.llseek = default_llseek, /* read accesses f_pos */
    };
    
    @ fops3 depends on !fops1 && !fops2 && !has_llseek && !nonseekable1 && !nonseekable2 && !seq @
    identifier fops0.fops;
    identifier write.write_f;
    @@
    // write fops use offset
    struct file_operations fops = {
    ... .write = write_f, ...
    +       .llseek = default_llseek, /* write accesses f_pos */
    };
    
    // Use noop_llseek if neither read nor write accesses f_pos
    ///////////////////////////////////////////////////////////
    
    @ fops4 depends on !fops1 && !fops2 && !fops3 && !has_llseek && !nonseekable1 && !nonseekable2 && !seq @
    identifier fops0.fops;
    identifier read_no_fpos.read_f;
    identifier write_no_fpos.write_f;
    @@
    // write fops use offset
    struct file_operations fops = {
    ...
     .write = write_f,
     .read = read_f,
    ...
    +.llseek = noop_llseek, /* read and write both use no f_pos */
    };
    
    @ depends on has_write && !has_read && !fops1 && !fops2 && !has_llseek && !nonseekable1 && !nonseekable2 && !seq @
    identifier fops0.fops;
    identifier write_no_fpos.write_f;
    @@
    struct file_operations fops = {
    ... .write = write_f, ...
    +.llseek = noop_llseek, /* write uses no f_pos */
    };
    
    @ depends on has_read && !has_write && !fops1 && !fops2 && !has_llseek && !nonseekable1 && !nonseekable2 && !seq @
    identifier fops0.fops;
    identifier read_no_fpos.read_f;
    @@
    struct file_operations fops = {
    ... .read = read_f, ...
    +.llseek = noop_llseek, /* read uses no f_pos */
    };
    
    @ depends on !has_read && !has_write && !fops1 && !fops2 && !has_llseek && !nonseekable1 && !nonseekable2 && !seq @
    identifier fops0.fops;
    @@
    struct file_operations fops = {
    ...
    +.llseek = noop_llseek, /* no read or write fn */
    };
    ===== End semantic patch =====
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Cc: Julia Lawall <julia@diku.dk>
    Cc: Christoph Hellwig <hch@infradead.org>

diff --git a/drivers/char/scx200_gpio.c b/drivers/char/scx200_gpio.c
index 99e5272e3c53..0bc135b9b16f 100644
--- a/drivers/char/scx200_gpio.c
+++ b/drivers/char/scx200_gpio.c
@@ -67,6 +67,7 @@ static const struct file_operations scx200_gpio_fileops = {
 	.read    = nsc_gpio_read,
 	.open    = scx200_gpio_open,
 	.release = scx200_gpio_release,
+	.llseek  = no_llseek,
 };
 
 static struct cdev scx200_gpio_cdev;  /* use 1 cdev for all pins */

commit 3a8183a2061ba54c4c2b3cd31c3add6fd717e853
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Oct 10 16:02:53 2009 +0200

    drivers: Remove BKL from scx200_gpio
    
    cycle_kernel_lock() was added during the big BKL pushdown. It should
    ensure the serializiation against driver init code. In this case there
    is nothing to serialize. Remove it.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    LKML-Reference: <20091010153350.167321547@linutronix.de>
    Acked-by: Jim Cromie <jim.cromie@gmail.com>

diff --git a/drivers/char/scx200_gpio.c b/drivers/char/scx200_gpio.c
index 1d9100561c8a..99e5272e3c53 100644
--- a/drivers/char/scx200_gpio.c
+++ b/drivers/char/scx200_gpio.c
@@ -12,7 +12,6 @@
 #include <linux/kernel.h>
 #include <linux/init.h>
 #include <linux/platform_device.h>
-#include <linux/smp_lock.h>
 #include <asm/uaccess.h>
 #include <asm/io.h>
 
@@ -52,7 +51,6 @@ static int scx200_gpio_open(struct inode *inode, struct file *file)
 	unsigned m = iminor(inode);
 	file->private_data = &scx200_gpio_ops;
 
-	cycle_kernel_lock();
 	if (m >= MAX_PINS)
 		return -EINVAL;
 	return nonseekable_open(inode, file);

commit f2b9857eee17797541b845782ade4d7a9d50f843
Author: Jonathan Corbet <corbet@lwn.net>
Date:   Sun May 18 15:32:43 2008 -0600

    Add a bunch of cycle_kernel_lock() calls
    
    All of the open() functions which don't need the BKL on their face may
    still depend on its acquisition to serialize opens against driver
    initialization.  So make those functions acquire then release the BKL to be
    on the safe side.
    
    Signed-off-by: Jonathan Corbet <corbet@lwn.net>

diff --git a/drivers/char/scx200_gpio.c b/drivers/char/scx200_gpio.c
index be2c623a9862..1d9100561c8a 100644
--- a/drivers/char/scx200_gpio.c
+++ b/drivers/char/scx200_gpio.c
@@ -12,6 +12,7 @@
 #include <linux/kernel.h>
 #include <linux/init.h>
 #include <linux/platform_device.h>
+#include <linux/smp_lock.h>
 #include <asm/uaccess.h>
 #include <asm/io.h>
 
@@ -46,12 +47,12 @@ struct nsc_gpio_ops scx200_gpio_ops = {
 };
 EXPORT_SYMBOL_GPL(scx200_gpio_ops);
 
-/* No BKL needed here: no global resources used */
 static int scx200_gpio_open(struct inode *inode, struct file *file)
 {
 	unsigned m = iminor(inode);
 	file->private_data = &scx200_gpio_ops;
 
+	cycle_kernel_lock();
 	if (m >= MAX_PINS)
 		return -EINVAL;
 	return nonseekable_open(inode, file);

commit d21c95c569c462da20d491b75d0a45bd70ddc1bf
Author: Jonathan Corbet <corbet@lwn.net>
Date:   Fri May 16 13:40:30 2008 -0600

    Add "no BKL needed" comments to several drivers
    
    This documents the fact that somebody looked at the relevant open()
    functions and concluded that, due to their trivial nature, no locking was
    needed.
    
    Signed-off-by: Jonathan Corbet <corbet@lwn.net>

diff --git a/drivers/char/scx200_gpio.c b/drivers/char/scx200_gpio.c
index 99e5272e3c53..be2c623a9862 100644
--- a/drivers/char/scx200_gpio.c
+++ b/drivers/char/scx200_gpio.c
@@ -46,6 +46,7 @@ struct nsc_gpio_ops scx200_gpio_ops = {
 };
 EXPORT_SYMBOL_GPL(scx200_gpio_ops);
 
+/* No BKL needed here: no global resources used */
 static int scx200_gpio_open(struct inode *inode, struct file *file)
 {
 	unsigned m = iminor(inode);

commit 58012cd788443b9d144bd7c72260a84b6b30f45d
Author: Chris Boot <bootc@bootc.net>
Date:   Fri Sep 29 01:59:07 2006 -0700

    [PATCH] scx200_gpio export cleanups
    
    Use EXPORT_SYMBOL_GPL for new symbols, and declare the struct in the header
    file for access by other modules.
    
    Signed-off-by: Chris Boot <bootc@bootc.net>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/char/scx200_gpio.c b/drivers/char/scx200_gpio.c
index b1f88c66b2b5..99e5272e3c53 100644
--- a/drivers/char/scx200_gpio.c
+++ b/drivers/char/scx200_gpio.c
@@ -44,7 +44,7 @@ struct nsc_gpio_ops scx200_gpio_ops = {
 	.gpio_change	= scx200_gpio_change,
 	.gpio_current	= scx200_gpio_current
 };
-EXPORT_SYMBOL(scx200_gpio_ops);
+EXPORT_SYMBOL_GPL(scx200_gpio_ops);
 
 static int scx200_gpio_open(struct inode *inode, struct file *file)
 {

commit c8ad9681fdec37ad298da6d505f9baba61e5f15c
Author: Jim Cromie <jim.cromie@gmail.com>
Date:   Fri Sep 29 01:59:05 2006 -0700

    [PATCH] drivers/char/scx200_gpio.c: make code static
    
    This patch makes a needlessly global variable static.
    
    Signed-off-by: Adrian Bunk <bunk@stusta.de>
    Signed-off-by: Jim Cromie  <jim.cromie@gmail.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/char/scx200_gpio.c b/drivers/char/scx200_gpio.c
index b956c7babd18..b1f88c66b2b5 100644
--- a/drivers/char/scx200_gpio.c
+++ b/drivers/char/scx200_gpio.c
@@ -69,7 +69,7 @@ static const struct file_operations scx200_gpio_fileops = {
 	.release = scx200_gpio_release,
 };
 
-struct cdev scx200_gpio_cdev;  /* use 1 cdev for all pins */
+static struct cdev scx200_gpio_cdev;  /* use 1 cdev for all pins */
 
 static int __init scx200_gpio_init(void)
 {

commit 2e8f7a3128bb8fac8351a994f1fc325717899308
Author: Jim Cromie <jim.cromie@gmail.com>
Date:   Fri Jul 14 00:24:26 2006 -0700

    [PATCH] gpio: rename exported vtables to better match purpose
    
    - rename EXPORTed gpio vtables from {scx200,pc8736x}_access to _gpio_ops new
      name is much closer to the vtable-name struct nsc_gpio_ops, should be
      clearer.  Also rename the _fops vtable var to _fileops to better
      disambiguate it from the gpio vtable.
    
    Signed-off-by: Jim Cromie <jim.cromie@gmail.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/char/scx200_gpio.c b/drivers/char/scx200_gpio.c
index f65372b5a656..b956c7babd18 100644
--- a/drivers/char/scx200_gpio.c
+++ b/drivers/char/scx200_gpio.c
@@ -35,7 +35,7 @@ MODULE_PARM_DESC(major, "Major device number");
 
 #define MAX_PINS 32		/* 64 later, when known ok */
 
-struct nsc_gpio_ops scx200_access = {
+struct nsc_gpio_ops scx200_gpio_ops = {
 	.owner		= THIS_MODULE,
 	.gpio_config	= scx200_gpio_configure,
 	.gpio_dump	= nsc_gpio_dump,
@@ -44,12 +44,12 @@ struct nsc_gpio_ops scx200_access = {
 	.gpio_change	= scx200_gpio_change,
 	.gpio_current	= scx200_gpio_current
 };
-EXPORT_SYMBOL(scx200_access);
+EXPORT_SYMBOL(scx200_gpio_ops);
 
 static int scx200_gpio_open(struct inode *inode, struct file *file)
 {
 	unsigned m = iminor(inode);
-	file->private_data = &scx200_access;
+	file->private_data = &scx200_gpio_ops;
 
 	if (m >= MAX_PINS)
 		return -EINVAL;
@@ -61,7 +61,7 @@ static int scx200_gpio_release(struct inode *inode, struct file *file)
 	return 0;
 }
 
-static const struct file_operations scx200_gpio_fops = {
+static const struct file_operations scx200_gpio_fileops = {
 	.owner   = THIS_MODULE,
 	.write   = nsc_gpio_write,
 	.read    = nsc_gpio_read,
@@ -91,7 +91,7 @@ static int __init scx200_gpio_init(void)
 		goto undo_malloc;
 
 	/* nsc_gpio uses dev_dbg(), so needs this */
-	scx200_access.dev = &pdev->dev;
+	scx200_gpio_ops.dev = &pdev->dev;
 
 	if (major) {
 		devid = MKDEV(major, 0);
@@ -105,7 +105,7 @@ static int __init scx200_gpio_init(void)
 		goto undo_platform_device_add;
 	}
 
-	cdev_init(&scx200_gpio_cdev, &scx200_gpio_fops);
+	cdev_init(&scx200_gpio_cdev, &scx200_gpio_fileops);
 	cdev_add(&scx200_gpio_cdev, devid, MAX_PINS);
 
 	return 0; /* succeed */

commit 91e260b80d2fec559877f399dfc36b554f207874
Author: Jim Cromie <jim.cromie@gmail.com>
Date:   Fri Jul 14 00:24:25 2006 -0700

    [PATCH] gpio: drop vtable members .gpio_set_high .gpio_set_low gpio_set is enough
    
    drops gpio_set_high, gpio_set_low from the nsc_gpio_ops vtable.  While we
    can't drop them from scx200_gpio (or can we?), we dont need them for new users
    of the exported vtable; gpio_set(1), gpio_set(0) work fine.
    
    Signed-off-by: Jim Cromie <jim.cromie@gmail.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/char/scx200_gpio.c b/drivers/char/scx200_gpio.c
index dd1f997944e6..f65372b5a656 100644
--- a/drivers/char/scx200_gpio.c
+++ b/drivers/char/scx200_gpio.c
@@ -41,8 +41,6 @@ struct nsc_gpio_ops scx200_access = {
 	.gpio_dump	= nsc_gpio_dump,
 	.gpio_get	= scx200_gpio_get,
 	.gpio_set	= scx200_gpio_set,
-	.gpio_set_high	= scx200_gpio_set_high,
-	.gpio_set_low	= scx200_gpio_set_low,
 	.gpio_change	= scx200_gpio_change,
 	.gpio_current	= scx200_gpio_current
 };

commit 635adb6cd25c8f816c9017a0a0349cd389eafcd3
Author: Jim Cromie <jim.cromie@gmail.com>
Date:   Fri Jul 14 00:24:16 2006 -0700

    [PATCH] scx200_gpio: use 1 cdev for N minors, not N for N
    
    Remove the scx200_gpio's cdev-array & ksalloc, replacing it with a single
    static struct cdev, which is sufficient for all the pins.
    
    cdev_put is commented out since kernel wont link properly with it, and its
    apparently not needed.
    
    With these patches, this driver continues to work with Chris Boot's
    leds_48xx driver.
    
    Signed-off-by  Jim Cromie <jim.cromie@gmail.com>
    
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/char/scx200_gpio.c b/drivers/char/scx200_gpio.c
index e7665c1ad134..dd1f997944e6 100644
--- a/drivers/char/scx200_gpio.c
+++ b/drivers/char/scx200_gpio.c
@@ -63,7 +63,6 @@ static int scx200_gpio_release(struct inode *inode, struct file *file)
 	return 0;
 }
 
-
 static const struct file_operations scx200_gpio_fops = {
 	.owner   = THIS_MODULE,
 	.write   = nsc_gpio_write,
@@ -72,11 +71,11 @@ static const struct file_operations scx200_gpio_fops = {
 	.release = scx200_gpio_release,
 };
 
-struct cdev *scx200_devices;
+struct cdev scx200_gpio_cdev;  /* use 1 cdev for all pins */
 
 static int __init scx200_gpio_init(void)
 {
-	int rc, i;
+	int rc;
 	dev_t devid;
 
 	if (!scx200_gpio_present()) {
@@ -107,25 +106,12 @@ static int __init scx200_gpio_init(void)
 		dev_err(&pdev->dev, "SCx200 chrdev_region err: %d\n", rc);
 		goto undo_platform_device_add;
 	}
-	scx200_devices = kzalloc(MAX_PINS * sizeof(struct cdev), GFP_KERNEL);
-	if (!scx200_devices) {
-		rc = -ENOMEM;
-		goto undo_chrdev_region;
-	}
-	for (i = 0; i < MAX_PINS; i++) {
-		struct cdev *cdev = &scx200_devices[i];
-		cdev_init(cdev, &scx200_gpio_fops);
-		cdev->owner = THIS_MODULE;
-		rc = cdev_add(cdev, MKDEV(major, i), 1);
-		/* tolerate 'minor' errors */
-		if (rc)
-			dev_err(&pdev->dev, "Error %d on minor %d", rc, i);
-	}
+
+	cdev_init(&scx200_gpio_cdev, &scx200_gpio_fops);
+	cdev_add(&scx200_gpio_cdev, devid, MAX_PINS);
 
 	return 0; /* succeed */
 
-undo_chrdev_region:
-	unregister_chrdev_region(devid, MAX_PINS);
 undo_platform_device_add:
 	platform_device_del(pdev);
 undo_malloc:
@@ -136,7 +122,9 @@ static int __init scx200_gpio_init(void)
 
 static void __exit scx200_gpio_cleanup(void)
 {
-	kfree(scx200_devices);
+	cdev_del(&scx200_gpio_cdev);
+	/* cdev_put(&scx200_gpio_cdev); */
+
 	unregister_chrdev_region(MKDEV(major, 0), MAX_PINS);
 	platform_device_unregister(pdev);
 }

commit ae2d1f2f5b59d00b39283c52dc4ee675397bbacd
Author: Jim Cromie <jim.cromie@gmail.com>
Date:   Fri Jul 14 00:24:16 2006 -0700

    [PATCH] scx200_gpio: 1 cdev for N minors: cleanup, prep
    
    this patch is mostly cleanup of scx200_gpio :
    - drop #include <linux/config.h>
    - s/DEVNAME/DRVNAME/    apparently a convention
    - replace variable num_pins with  #define MAX_PINS
    - s/dev/devid/   to clarify that its a dev_t, not a struct device dev.
    - move devid = MKDEV(major,0)  into branch where its needed.
    
    2 minor 'changes' :
    
    - reduced MAX_PINS from 64 to 32.  Ive never tested other pins, and
      theyre all multiplexed with other functions, some of which may be in use
      on my soekris 4801, so I dont know what testing should yield.
    
    - +EXPORT_SYMBOL(scx200_access);
    
      This exposes the driver's vtable, which another driver can use along
      with #include <linux/nsc_gpio.h>, to manipulate a gpio-pin.
    
    Signed-off-by  Jim Cromie <jim.cromie@gmail.com>
    
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/char/scx200_gpio.c b/drivers/char/scx200_gpio.c
index 425c58719db6..e7665c1ad134 100644
--- a/drivers/char/scx200_gpio.c
+++ b/drivers/char/scx200_gpio.c
@@ -5,7 +5,6 @@
 
    Copyright (c) 2001,2002 Christer Weinigel <wingel@nano-system.com> */
 
-#include <linux/config.h>
 #include <linux/device.h>
 #include <linux/fs.h>
 #include <linux/module.h>
@@ -22,19 +21,20 @@
 #include <linux/scx200_gpio.h>
 #include <linux/nsc_gpio.h>
 
-#define NAME "scx200_gpio"
-#define DEVNAME NAME
+#define DRVNAME "scx200_gpio"
 
 static struct platform_device *pdev;
 
 MODULE_AUTHOR("Christer Weinigel <wingel@nano-system.com>");
-MODULE_DESCRIPTION("NatSemi SCx200 GPIO Pin Driver");
+MODULE_DESCRIPTION("NatSemi/AMD SCx200 GPIO Pin Driver");
 MODULE_LICENSE("GPL");
 
 static int major = 0;		/* default to dynamic major */
 module_param(major, int, 0);
 MODULE_PARM_DESC(major, "Major device number");
 
+#define MAX_PINS 32		/* 64 later, when known ok */
+
 struct nsc_gpio_ops scx200_access = {
 	.owner		= THIS_MODULE,
 	.gpio_config	= scx200_gpio_configure,
@@ -46,13 +46,14 @@ struct nsc_gpio_ops scx200_access = {
 	.gpio_change	= scx200_gpio_change,
 	.gpio_current	= scx200_gpio_current
 };
+EXPORT_SYMBOL(scx200_access);
 
 static int scx200_gpio_open(struct inode *inode, struct file *file)
 {
 	unsigned m = iminor(inode);
 	file->private_data = &scx200_access;
 
-	if (m > 63)
+	if (m >= MAX_PINS)
 		return -EINVAL;
 	return nonseekable_open(inode, file);
 }
@@ -72,20 +73,19 @@ static const struct file_operations scx200_gpio_fops = {
 };
 
 struct cdev *scx200_devices;
-static int num_pins = 32;
 
 static int __init scx200_gpio_init(void)
 {
 	int rc, i;
-	dev_t dev = MKDEV(major, 0);
+	dev_t devid;
 
 	if (!scx200_gpio_present()) {
-		printk(KERN_ERR NAME ": no SCx200 gpio present\n");
+		printk(KERN_ERR DRVNAME ": no SCx200 gpio present\n");
 		return -ENODEV;
 	}
 
 	/* support dev_dbg() with pdev->dev */
-	pdev = platform_device_alloc(DEVNAME, 0);
+	pdev = platform_device_alloc(DRVNAME, 0);
 	if (!pdev)
 		return -ENOMEM;
 
@@ -96,22 +96,23 @@ static int __init scx200_gpio_init(void)
 	/* nsc_gpio uses dev_dbg(), so needs this */
 	scx200_access.dev = &pdev->dev;
 
-	if (major)
-		rc = register_chrdev_region(dev, num_pins, "scx200_gpio");
-	else {
-		rc = alloc_chrdev_region(&dev, 0, num_pins, "scx200_gpio");
-		major = MAJOR(dev);
+	if (major) {
+		devid = MKDEV(major, 0);
+		rc = register_chrdev_region(devid, MAX_PINS, "scx200_gpio");
+	} else {
+		rc = alloc_chrdev_region(&devid, 0, MAX_PINS, "scx200_gpio");
+		major = MAJOR(devid);
 	}
 	if (rc < 0) {
 		dev_err(&pdev->dev, "SCx200 chrdev_region err: %d\n", rc);
 		goto undo_platform_device_add;
 	}
-	scx200_devices = kzalloc(num_pins * sizeof(struct cdev), GFP_KERNEL);
+	scx200_devices = kzalloc(MAX_PINS * sizeof(struct cdev), GFP_KERNEL);
 	if (!scx200_devices) {
 		rc = -ENOMEM;
 		goto undo_chrdev_region;
 	}
-	for (i = 0; i < num_pins; i++) {
+	for (i = 0; i < MAX_PINS; i++) {
 		struct cdev *cdev = &scx200_devices[i];
 		cdev_init(cdev, &scx200_gpio_fops);
 		cdev->owner = THIS_MODULE;
@@ -124,7 +125,7 @@ static int __init scx200_gpio_init(void)
 	return 0; /* succeed */
 
 undo_chrdev_region:
-	unregister_chrdev_region(dev, num_pins);
+	unregister_chrdev_region(devid, MAX_PINS);
 undo_platform_device_add:
 	platform_device_del(pdev);
 undo_malloc:
@@ -136,9 +137,8 @@ static int __init scx200_gpio_init(void)
 static void __exit scx200_gpio_cleanup(void)
 {
 	kfree(scx200_devices);
-	unregister_chrdev_region(MKDEV(major, 0), num_pins);
+	unregister_chrdev_region(MKDEV(major, 0), MAX_PINS);
 	platform_device_unregister(pdev);
-	/* kfree(pdev); */
 }
 
 module_init(scx200_gpio_init);

commit 62322d2554d2f9680c8ace7bbf1f97d8fa84ad1a
Author: Arjan van de Ven <arjan@infradead.org>
Date:   Mon Jul 3 00:24:21 2006 -0700

    [PATCH] make more file_operation structs static
    
    Mark the static struct file_operations in drivers/char as const.  Making
    them const prevents accidental bugs, and moves them to the .rodata section
    so that they no longer do any false sharing; in addition with the proper
    debug option they are then protected against corruption..
    
    [akpm@osdl.org: build fix]
    Signed-off-by: Arjan van de Ven <arjan@linux.intel.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/char/scx200_gpio.c b/drivers/char/scx200_gpio.c
index 45083e5dd23b..425c58719db6 100644
--- a/drivers/char/scx200_gpio.c
+++ b/drivers/char/scx200_gpio.c
@@ -63,7 +63,7 @@ static int scx200_gpio_release(struct inode *inode, struct file *file)
 }
 
 
-static struct file_operations scx200_gpio_fops = {
+static const struct file_operations scx200_gpio_fops = {
 	.owner   = THIS_MODULE,
 	.write   = nsc_gpio_write,
 	.read    = nsc_gpio_read,

commit 1017f6afd578fe519d316d7148356703c04e8f03
Author: Ingo Molnar <mingo@elte.hu>
Date:   Fri Jun 30 01:55:29 2006 -0700

    [PATCH] fix platform_device_put/del mishaps
    
    This fixes drivers/char/pc8736x_gpio.c and drivers/char/scx200_gpio.c to
    use the platform_device_del/put ops correctly.
    
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Cc: Jim Cromie <jim.cromie@gmail.com>
    Cc: Greg KH <greg@kroah.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/char/scx200_gpio.c b/drivers/char/scx200_gpio.c
index 5a280a330401..45083e5dd23b 100644
--- a/drivers/char/scx200_gpio.c
+++ b/drivers/char/scx200_gpio.c
@@ -126,9 +126,10 @@ static int __init scx200_gpio_init(void)
 undo_chrdev_region:
 	unregister_chrdev_region(dev, num_pins);
 undo_platform_device_add:
-	platform_device_put(pdev);
+	platform_device_del(pdev);
 undo_malloc:
-	kfree(pdev);
+	platform_device_put(pdev);
+
 	return rc;
 }
 
@@ -136,7 +137,6 @@ static void __exit scx200_gpio_cleanup(void)
 {
 	kfree(scx200_devices);
 	unregister_chrdev_region(MKDEV(major, 0), num_pins);
-	platform_device_put(pdev);
 	platform_device_unregister(pdev);
 	/* kfree(pdev); */
 }

commit f31000e573da052b6b8bcc21faff520b4e2eda7a
Author: Jim Cromie <jim.cromie@gmail.com>
Date:   Tue Jun 27 02:54:23 2006 -0700

    [PATCH] chardev: GPIO for SCx200 & PC-8736x: use dev_dbg in common module
    
    Use of dev_dbg() and friends is considered good practice.  dev_dbg() needs a
    struct device *devp, but nsc_gpio is only a helper module, so it doesnt
    have/need its own.  To provide devp to the user-modules (scx200 & pc8736x
    _gpio), we add it to the vtable, and set it during init.
    
    Also squeeze nsc_gpio_dump()'s format a little.
    
    [  199.259879]  pc8736x_gpio.0: io09: 0x0044 TS OD PUE  EDGE LO DEBOUNCE
    
    Signed-off-by: Jim Cromie <jim.cromie@gmail.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/char/scx200_gpio.c b/drivers/char/scx200_gpio.c
index 442367b3f5dc..5a280a330401 100644
--- a/drivers/char/scx200_gpio.c
+++ b/drivers/char/scx200_gpio.c
@@ -35,14 +35,6 @@ static int major = 0;		/* default to dynamic major */
 module_param(major, int, 0);
 MODULE_PARM_DESC(major, "Major device number");
 
-extern void nsc_gpio_dump(unsigned index);
-
-extern ssize_t nsc_gpio_write(struct file *file, const char __user *data,
-			      size_t len, loff_t *ppos);
-
-extern ssize_t nsc_gpio_read(struct file *file, char __user *buf,
-			     size_t len, loff_t *ppos);
-
 struct nsc_gpio_ops scx200_access = {
 	.owner		= THIS_MODULE,
 	.gpio_config	= scx200_gpio_configure,
@@ -101,6 +93,9 @@ static int __init scx200_gpio_init(void)
 	if (rc)
 		goto undo_malloc;
 
+	/* nsc_gpio uses dev_dbg(), so needs this */
+	scx200_access.dev = &pdev->dev;
+
 	if (major)
 		rc = register_chrdev_region(dev, num_pins, "scx200_gpio");
 	else {

commit 0e41ef3c51ea7dbb764616f60a90700647fc8518
Author: Jim Cromie <jim.cromie@gmail.com>
Date:   Tue Jun 27 02:54:20 2006 -0700

    [PATCH] chardev: GPIO for SCx200 & PC-8736x: migrate gpio_dump to common module
    
    Since the meaning of config-bits is the same for scx200 and pc8736x _gpios, we
    can share a function to deliver this to user.  Since it is called via the
    vtable, its also completely replaceable.  For now, we keep using printk...
    
    Signed-off-by: Jim Cromie <jim.cromie@gmail.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/char/scx200_gpio.c b/drivers/char/scx200_gpio.c
index eb9a84777598..442367b3f5dc 100644
--- a/drivers/char/scx200_gpio.c
+++ b/drivers/char/scx200_gpio.c
@@ -35,7 +35,7 @@ static int major = 0;		/* default to dynamic major */
 module_param(major, int, 0);
 MODULE_PARM_DESC(major, "Major device number");
 
-extern void scx200_gpio_dump(unsigned index);
+extern void nsc_gpio_dump(unsigned index);
 
 extern ssize_t nsc_gpio_write(struct file *file, const char __user *data,
 			      size_t len, loff_t *ppos);
@@ -46,7 +46,7 @@ extern ssize_t nsc_gpio_read(struct file *file, char __user *buf,
 struct nsc_gpio_ops scx200_access = {
 	.owner		= THIS_MODULE,
 	.gpio_config	= scx200_gpio_configure,
-	.gpio_dump	= scx200_gpio_dump,
+	.gpio_dump	= nsc_gpio_dump,
 	.gpio_get	= scx200_gpio_get,
 	.gpio_set	= scx200_gpio_set,
 	.gpio_set_high	= scx200_gpio_set_high,

commit 1a66fdf083bf2b60c4d12feb970bc7373b59e33a
Author: Jim Cromie <jim.cromie@gmail.com>
Date:   Tue Jun 27 02:54:20 2006 -0700

    [PATCH] chardev: GPIO for SCx200 & PC-8736x: migrate file-ops to common module
    
    Now that the read(), write() file-ops are dispatching gpio-ops via the vtable,
    they are generic, and can be moved 'verbatim' to the nsc_gpio common-support
    module.  After the move, various symbols are renamed to update 'scx200_' to
    'nsc_', and headers are adjusted accordingly.
    
    Signed-off-by: Jim Cromie <jim.cromie@gmail.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/char/scx200_gpio.c b/drivers/char/scx200_gpio.c
index 15dfb95ebc7e..eb9a84777598 100644
--- a/drivers/char/scx200_gpio.c
+++ b/drivers/char/scx200_gpio.c
@@ -37,6 +37,12 @@ MODULE_PARM_DESC(major, "Major device number");
 
 extern void scx200_gpio_dump(unsigned index);
 
+extern ssize_t nsc_gpio_write(struct file *file, const char __user *data,
+			      size_t len, loff_t *ppos);
+
+extern ssize_t nsc_gpio_read(struct file *file, char __user *buf,
+			     size_t len, loff_t *ppos);
+
 struct nsc_gpio_ops scx200_access = {
 	.owner		= THIS_MODULE,
 	.gpio_config	= scx200_gpio_configure,
@@ -49,84 +55,6 @@ struct nsc_gpio_ops scx200_access = {
 	.gpio_current	= scx200_gpio_current
 };
 
-static ssize_t scx200_gpio_write(struct file *file, const char __user *data,
-				 size_t len, loff_t *ppos)
-{
-	unsigned m = iminor(file->f_dentry->d_inode);
-	struct nsc_gpio_ops *amp = file->private_data;
-	size_t i;
-	int err = 0;
-
-	for (i = 0; i < len; ++i) {
-		char c;
-		if (get_user(c, data + i))
-			return -EFAULT;
-		switch (c) {
-		case '0':
-			amp->gpio_set(m, 0);
-			break;
-		case '1':
-			amp->gpio_set(m, 1);
-			break;
-		case 'O':
-			printk(KERN_INFO NAME ": GPIO%d output enabled\n", m);
-			amp->gpio_config(m, ~1, 1);
-			break;
-		case 'o':
-			printk(KERN_INFO NAME ": GPIO%d output disabled\n", m);
-			amp->gpio_config(m, ~1, 0);
-			break;
-		case 'T':
-			printk(KERN_INFO NAME ": GPIO%d output is push pull\n", m);
-			amp->gpio_config(m, ~2, 2);
-			break;
-		case 't':
-			printk(KERN_INFO NAME ": GPIO%d output is open drain\n", m);
-			amp->gpio_config(m, ~2, 0);
-			break;
-		case 'P':
-			printk(KERN_INFO NAME ": GPIO%d pull up enabled\n", m);
-			amp->gpio_config(m, ~4, 4);
-			break;
-		case 'p':
-			printk(KERN_INFO NAME ": GPIO%d pull up disabled\n", m);
-			amp->gpio_config(m, ~4, 0);
-			break;
-
-		case 'v':
-			/* View Current pin settings */
-			amp->gpio_dump(m);
-			break;
-		case '\n':
-			/* end of settings string, do nothing */
-			break;
-		default:
-			printk(KERN_ERR NAME
-			       ": GPIO-%2d bad setting: chr<0x%2x>\n", m,
-			       (int)c);
-			err++;
-		}
-	}
-	if (err)
-		return -EINVAL;	/* full string handled, report error */
-
-	return len;
-}
-
-static ssize_t scx200_gpio_read(struct file *file, char __user *buf,
-				size_t len, loff_t *ppos)
-{
-	unsigned m = iminor(file->f_dentry->d_inode);
-	int value;
-	struct nsc_gpio_ops *amp = file->private_data;
-
-	value = amp->gpio_get(m);
-	if (put_user(value ? '1' : '0', buf))
-		return -EFAULT;
-
-	return 1;
-}
-
 static int scx200_gpio_open(struct inode *inode, struct file *file)
 {
 	unsigned m = iminor(inode);
@@ -145,8 +73,8 @@ static int scx200_gpio_release(struct inode *inode, struct file *file)
 
 static struct file_operations scx200_gpio_fops = {
 	.owner   = THIS_MODULE,
-	.write   = scx200_gpio_write,
-	.read    = scx200_gpio_read,
+	.write   = nsc_gpio_write,
+	.read    = nsc_gpio_read,
 	.open    = scx200_gpio_open,
 	.release = scx200_gpio_release,
 };

commit c3dc8071eedaac8c8a05c30fe20b78452a818dd9
Author: Jim Cromie <jim.cromie@gmail.com>
Date:   Tue Jun 27 02:54:18 2006 -0700

    [PATCH] chardev: GPIO for SCx200 & PC-8736x: dispatch via vtable
    
    Now actually call the gpio operations thru the vtable.
    
    Signed-off-by: Jim Cromie <jim.cromie@gmail.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/char/scx200_gpio.c b/drivers/char/scx200_gpio.c
index f9994ed01816..15dfb95ebc7e 100644
--- a/drivers/char/scx200_gpio.c
+++ b/drivers/char/scx200_gpio.c
@@ -53,6 +53,7 @@ static ssize_t scx200_gpio_write(struct file *file, const char __user *data,
 				 size_t len, loff_t *ppos)
 {
 	unsigned m = iminor(file->f_dentry->d_inode);
+	struct nsc_gpio_ops *amp = file->private_data;
 	size_t i;
 	int err = 0;
 
@@ -62,39 +63,39 @@ static ssize_t scx200_gpio_write(struct file *file, const char __user *data,
 			return -EFAULT;
 		switch (c) {
 		case '0':
-			scx200_gpio_set(m, 0);
+			amp->gpio_set(m, 0);
 			break;
 		case '1':
-			scx200_gpio_set(m, 1);
+			amp->gpio_set(m, 1);
 			break;
 		case 'O':
 			printk(KERN_INFO NAME ": GPIO%d output enabled\n", m);
-			scx200_gpio_configure(m, ~1, 1);
+			amp->gpio_config(m, ~1, 1);
 			break;
 		case 'o':
 			printk(KERN_INFO NAME ": GPIO%d output disabled\n", m);
-			scx200_gpio_configure(m, ~1, 0);
+			amp->gpio_config(m, ~1, 0);
 			break;
 		case 'T':
 			printk(KERN_INFO NAME ": GPIO%d output is push pull\n", m);
-			scx200_gpio_configure(m, ~2, 2);
+			amp->gpio_config(m, ~2, 2);
 			break;
 		case 't':
 			printk(KERN_INFO NAME ": GPIO%d output is open drain\n", m);
-			scx200_gpio_configure(m, ~2, 0);
+			amp->gpio_config(m, ~2, 0);
 			break;
 		case 'P':
 			printk(KERN_INFO NAME ": GPIO%d pull up enabled\n", m);
-			scx200_gpio_configure(m, ~4, 4);
+			amp->gpio_config(m, ~4, 4);
 			break;
 		case 'p':
 			printk(KERN_INFO NAME ": GPIO%d pull up disabled\n", m);
-			scx200_gpio_configure(m, ~4, 0);
+			amp->gpio_config(m, ~4, 0);
 			break;
 
 		case 'v':
 			/* View Current pin settings */
-			scx200_gpio_dump(m);
+			amp->gpio_dump(m);
 			break;
 		case '\n':
 			/* end of settings string, do nothing */
@@ -117,8 +118,9 @@ static ssize_t scx200_gpio_read(struct file *file, char __user *buf,
 {
 	unsigned m = iminor(file->f_dentry->d_inode);
 	int value;
+	struct nsc_gpio_ops *amp = file->private_data;
 
-	value = scx200_gpio_get(m);
+	value = amp->gpio_get(m);
 	if (put_user(value ? '1' : '0', buf))
 		return -EFAULT;
 
@@ -128,6 +130,8 @@ static ssize_t scx200_gpio_read(struct file *file, char __user *buf,
 static int scx200_gpio_open(struct inode *inode, struct file *file)
 {
 	unsigned m = iminor(inode);
+	file->private_data = &scx200_access;
+
 	if (m > 63)
 		return -EINVAL;
 	return nonseekable_open(inode, file);

commit fe3a168a2ce1c93837cdf8fe27a3e67795155f90
Author: Jim Cromie <jim.cromie@gmail.com>
Date:   Tue Jun 27 02:54:18 2006 -0700

    [PATCH] chardev: GPIO for SCx200 & PC-8736x: add gpio-ops vtable
    
    Abstract the gpio operations into a new nsc_gpio_ops vtable.
    
    Signed-off-by: Jim Cromie <jim.cromie@gmail.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/char/scx200_gpio.c b/drivers/char/scx200_gpio.c
index a1a56c5c8a84..f9994ed01816 100644
--- a/drivers/char/scx200_gpio.c
+++ b/drivers/char/scx200_gpio.c
@@ -20,6 +20,7 @@
 #include <linux/cdev.h>
 
 #include <linux/scx200_gpio.h>
+#include <linux/nsc_gpio.h>
 
 #define NAME "scx200_gpio"
 #define DEVNAME NAME
@@ -36,6 +37,18 @@ MODULE_PARM_DESC(major, "Major device number");
 
 extern void scx200_gpio_dump(unsigned index);
 
+struct nsc_gpio_ops scx200_access = {
+	.owner		= THIS_MODULE,
+	.gpio_config	= scx200_gpio_configure,
+	.gpio_dump	= scx200_gpio_dump,
+	.gpio_get	= scx200_gpio_get,
+	.gpio_set	= scx200_gpio_set,
+	.gpio_set_high	= scx200_gpio_set_high,
+	.gpio_set_low	= scx200_gpio_set_low,
+	.gpio_change	= scx200_gpio_change,
+	.gpio_current	= scx200_gpio_current
+};
+
 static ssize_t scx200_gpio_write(struct file *file, const char __user *data,
 				 size_t len, loff_t *ppos)
 {

commit 9550a339e1ab1709dd53d92a1b76eecae2df9f3c
Author: Jim Cromie <jim.cromie@gmail.com>
Date:   Tue Jun 27 02:54:16 2006 -0700

    [PATCH] chardev: GPIO for SCx200 & PC-8736x: add 'v' command to device-file
    
    Add a new driver command: 'v' which calls gpio_dump() on the pin.  The output
    goes to the log, like all other INFO messages in the original driver.  Giving
    the user control over the feedback they 'need' is construed to be a
    user-friendly feature, and allows us (later) to dial down many INFO messages
    to DEBUG log-level.
    
    Signed-off-by: Jim Cromie <jim.cromie@gmail.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/char/scx200_gpio.c b/drivers/char/scx200_gpio.c
index e6e52c48697b..a1a56c5c8a84 100644
--- a/drivers/char/scx200_gpio.c
+++ b/drivers/char/scx200_gpio.c
@@ -41,6 +41,7 @@ static ssize_t scx200_gpio_write(struct file *file, const char __user *data,
 {
 	unsigned m = iminor(file->f_dentry->d_inode);
 	size_t i;
+	int err = 0;
 
 	for (i = 0; i < len; ++i) {
 		char c;
@@ -77,8 +78,23 @@ static ssize_t scx200_gpio_write(struct file *file, const char __user *data,
 			printk(KERN_INFO NAME ": GPIO%d pull up disabled\n", m);
 			scx200_gpio_configure(m, ~4, 0);
 			break;
+
+		case 'v':
+			/* View Current pin settings */
+			scx200_gpio_dump(m);
+			break;
+		case '\n':
+			/* end of settings string, do nothing */
+			break;
+		default:
+			printk(KERN_ERR NAME
+			       ": GPIO-%2d bad setting: chr<0x%2x>\n", m,
+			       (int)c);
+			err++;
 		}
 	}
+	if (err)
+		return -EINVAL;	/* full string handled, report error */
 
 	return len;
 }

commit 979b5ec3a7055d35b212f657e80257ec1346aa0e
Author: Jim Cromie <jim.cromie@gmail.com>
Date:   Tue Jun 27 02:54:14 2006 -0700

    [PATCH] chardev: GPIO for SCx200 & PC-8736x: add platforn_device for use w dev_dbg
    
    Add a platform-device to scx200_gpio, and use its struct device dev member
    (ie: devp) in dev_dbg() once.
    
    There are 2 alternatives here (Im soliciting guidance/commentary):
    
    - use isa_device, if/when its added to the kernel.
    
    - alter scx200.c to EXPORT_GPL its private devp so that both scx200_gpio,
      and the (to be added) nsc_gpio module can use it.  Since the available devp
      is in 'grandparent', this seems like too much 'action at a distance'.
    
    Signed-off-by: Jim Cromie <jim.cromie@gmail.com>
    Cc: Greg KH <greg@kroah.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/char/scx200_gpio.c b/drivers/char/scx200_gpio.c
index 507a5bf567cb..e6e52c48697b 100644
--- a/drivers/char/scx200_gpio.c
+++ b/drivers/char/scx200_gpio.c
@@ -6,11 +6,13 @@
    Copyright (c) 2001,2002 Christer Weinigel <wingel@nano-system.com> */
 
 #include <linux/config.h>
+#include <linux/device.h>
 #include <linux/fs.h>
 #include <linux/module.h>
 #include <linux/errno.h>
 #include <linux/kernel.h>
 #include <linux/init.h>
+#include <linux/platform_device.h>
 #include <asm/uaccess.h>
 #include <asm/io.h>
 
@@ -20,6 +22,9 @@
 #include <linux/scx200_gpio.h>
 
 #define NAME "scx200_gpio"
+#define DEVNAME NAME
+
+static struct platform_device *pdev;
 
 MODULE_AUTHOR("Christer Weinigel <wingel@nano-system.com>");
 MODULE_DESCRIPTION("NatSemi SCx200 GPIO Pin Driver");
@@ -114,56 +119,70 @@ static struct file_operations scx200_gpio_fops = {
 };
 
 struct cdev *scx200_devices;
-int num_devs = 32;
+static int num_pins = 32;
 
 static int __init scx200_gpio_init(void)
 {
 	int rc, i;
 	dev_t dev = MKDEV(major, 0);
 
-	printk(KERN_DEBUG NAME ": NatSemi SCx200 GPIO Driver\n");
-
 	if (!scx200_gpio_present()) {
 		printk(KERN_ERR NAME ": no SCx200 gpio present\n");
 		return -ENODEV;
 	}
+
+	/* support dev_dbg() with pdev->dev */
+	pdev = platform_device_alloc(DEVNAME, 0);
+	if (!pdev)
+		return -ENOMEM;
+
+	rc = platform_device_add(pdev);
+	if (rc)
+		goto undo_malloc;
+
 	if (major)
-		rc = register_chrdev_region(dev, num_devs, "scx200_gpio");
+		rc = register_chrdev_region(dev, num_pins, "scx200_gpio");
 	else {
-		rc = alloc_chrdev_region(&dev, 0, num_devs, "scx200_gpio");
+		rc = alloc_chrdev_region(&dev, 0, num_pins, "scx200_gpio");
 		major = MAJOR(dev);
 	}
 	if (rc < 0) {
-		printk(KERN_ERR NAME ": SCx200 chrdev_region: %d\n", rc);
-		return rc;
+		dev_err(&pdev->dev, "SCx200 chrdev_region err: %d\n", rc);
+		goto undo_platform_device_add;
 	}
-	scx200_devices = kzalloc(num_devs * sizeof(struct cdev), GFP_KERNEL);
+	scx200_devices = kzalloc(num_pins * sizeof(struct cdev), GFP_KERNEL);
 	if (!scx200_devices) {
 		rc = -ENOMEM;
-		goto fail_malloc;
+		goto undo_chrdev_region;
 	}
-	for (i = 0; i < num_devs; i++) {
+	for (i = 0; i < num_pins; i++) {
 		struct cdev *cdev = &scx200_devices[i];
 		cdev_init(cdev, &scx200_gpio_fops);
 		cdev->owner = THIS_MODULE;
-		cdev->ops = &scx200_gpio_fops;
 		rc = cdev_add(cdev, MKDEV(major, i), 1);
-		/* Fail gracefully if need be */
+		/* tolerate 'minor' errors */
 		if (rc)
-			printk(KERN_ERR NAME "Error %d on minor %d", rc, i);
+			dev_err(&pdev->dev, "Error %d on minor %d", rc, i);
 	}
 
-	return 0;		/* succeed */
+	return 0; /* succeed */
 
-fail_malloc:
-	unregister_chrdev_region(dev, num_devs);
+undo_chrdev_region:
+	unregister_chrdev_region(dev, num_pins);
+undo_platform_device_add:
+	platform_device_put(pdev);
+undo_malloc:
+	kfree(pdev);
 	return rc;
 }
 
 static void __exit scx200_gpio_cleanup(void)
 {
 	kfree(scx200_devices);
-	unregister_chrdev_region(MKDEV(major, 0), num_devs);
+	unregister_chrdev_region(MKDEV(major, 0), num_pins);
+	platform_device_put(pdev);
+	platform_device_unregister(pdev);
+	/* kfree(pdev); */
 }
 
 module_init(scx200_gpio_init);

commit 7d7f212661d68d231fdfaead03dda0dd44d5bbbb
Author: Jim Cromie <jim.cromie@gmail.com>
Date:   Tue Jun 27 02:54:14 2006 -0700

    [PATCH] chardev: GPIO for SCx200 & PC-8736x: modernize driver init to 2.6 api
    
    Adopt many modern 2.6 coding practices, ala LDD3, chapter 3.  Changes are
    limited to initialization calls from module init, ie: cdev_init, cdev_add,
    *_chrdev_region, mkdev.
    
    Signed-off-by: Jim Cromie <jim.cromie@gmail.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/char/scx200_gpio.c b/drivers/char/scx200_gpio.c
index dd051ea6755e..507a5bf567cb 100644
--- a/drivers/char/scx200_gpio.c
+++ b/drivers/char/scx200_gpio.c
@@ -14,6 +14,9 @@
 #include <asm/uaccess.h>
 #include <asm/io.h>
 
+#include <linux/types.h>
+#include <linux/cdev.h>
+
 #include <linux/scx200_gpio.h>
 
 #define NAME "scx200_gpio"
@@ -26,6 +29,8 @@ static int major = 0;		/* default to dynamic major */
 module_param(major, int, 0);
 MODULE_PARM_DESC(major, "Major device number");
 
+extern void scx200_gpio_dump(unsigned index);
+
 static ssize_t scx200_gpio_write(struct file *file, const char __user *data,
 				 size_t len, loff_t *ppos)
 {
@@ -108,33 +113,57 @@ static struct file_operations scx200_gpio_fops = {
 	.release = scx200_gpio_release,
 };
 
+struct cdev *scx200_devices;
+int num_devs = 32;
+
 static int __init scx200_gpio_init(void)
 {
-	int r;
+	int rc, i;
+	dev_t dev = MKDEV(major, 0);
 
 	printk(KERN_DEBUG NAME ": NatSemi SCx200 GPIO Driver\n");
 
 	if (!scx200_gpio_present()) {
-		printk(KERN_ERR NAME ": no SCx200 gpio pins available\n");
+		printk(KERN_ERR NAME ": no SCx200 gpio present\n");
 		return -ENODEV;
 	}
-
-	r = register_chrdev(major, NAME, &scx200_gpio_fops);
-	if (r < 0) {
-		printk(KERN_ERR NAME ": unable to register character device\n");
-		return r;
+	if (major)
+		rc = register_chrdev_region(dev, num_devs, "scx200_gpio");
+	else {
+		rc = alloc_chrdev_region(&dev, 0, num_devs, "scx200_gpio");
+		major = MAJOR(dev);
 	}
-	if (!major) {
-		major = r;
-		printk(KERN_DEBUG NAME ": got dynamic major %d\n", major);
+	if (rc < 0) {
+		printk(KERN_ERR NAME ": SCx200 chrdev_region: %d\n", rc);
+		return rc;
+	}
+	scx200_devices = kzalloc(num_devs * sizeof(struct cdev), GFP_KERNEL);
+	if (!scx200_devices) {
+		rc = -ENOMEM;
+		goto fail_malloc;
+	}
+	for (i = 0; i < num_devs; i++) {
+		struct cdev *cdev = &scx200_devices[i];
+		cdev_init(cdev, &scx200_gpio_fops);
+		cdev->owner = THIS_MODULE;
+		cdev->ops = &scx200_gpio_fops;
+		rc = cdev_add(cdev, MKDEV(major, i), 1);
+		/* Fail gracefully if need be */
+		if (rc)
+			printk(KERN_ERR NAME "Error %d on minor %d", rc, i);
 	}
 
-	return 0;
+	return 0;		/* succeed */
+
+fail_malloc:
+	unregister_chrdev_region(dev, num_devs);
+	return rc;
 }
 
 static void __exit scx200_gpio_cleanup(void)
 {
-	unregister_chrdev(major, NAME);
+	kfree(scx200_devices);
+	unregister_chrdev_region(MKDEV(major, 0), num_devs);
 }
 
 module_init(scx200_gpio_init);

commit 62c83cde9282a9580994a12b3063e677181b5ebe
Author: Jim Cromie <jim.cromie@gmail.com>
Date:   Tue Jun 27 02:54:13 2006 -0700

    [PATCH] chardev: GPIO for SCx200 & PC-8736x: whitespace pre-clean
    
    GPIO SUPPORT FOR SCx200 & PC8736x
    
    The patch-set reworks the 2.4 vintage scx200_gpio driver for modern 2.6, and
    refactors GPIO support to reuse it in a new driver for the GPIO on PC-8736x
    chips.  Its handy for the Soekris.com net-4801, which has both chips.
    
    These patches have been seen recently on Kernel-Mentors, and then
    Kernel-Newbies ML, where Jesper Juhl kindly reviewed it.  His feedback has
    been incorporated.  Thanks Jesper !
    
    Its also gone to soekris-tech@soekris.com for possible testing by linux folks,
    I've gotten 1 promise so far.  Theyre mostly BSD folk over there, but we'll
    see..
    
    Device-file & Sysfs
    
    The driver preserves the existing device-file interface, including the
    write/cmd set, but adds v to 'view' the pin-settings & configs by inducing,
    via gpio_dump(), a dev_info() call.  Its a fairly crappy way to get status,
    but it sticks to the syslog approach, conservatively.
    
    Allowing users to voluntarily trigger logging is good, it gives them a
    familiar way to confirm their app's control & use of the pins, and I've thus
    reduced the pin-mode-updates from dev_info to dev_dbg.
    
    I've recently bolted on a proto sysfs interface for both new drivers.  Im not
    including those patches here; they (the patch + doc-pre-patch) are still quite
    raw (and unreviewed on KNML), and since they 'invent' a convention for GPIO, a
    proper vetting is needed.  Since this patchset is much bigger than my previous
    ones, Id like to keep things simpler, and address it 1st, before bolting on
    more stuff.
    
    The driver-split
    
    The Geode CPU and the PC-87366 Super-IO chip have GPIO units which share a
    common pin-architecture (same pin features, with same bits controlling), but
    with different addressing mechanics and port organizations.
    
    The vintage driver expresses the pin capabilities with pin-mode commands
    [OoPpTt],etc that change the pin configurations, and since the 2 chips share
    pin-arch, we can reuse the read(), write() commands, once the implementation
    is suitably adjusted.
    
    The patchset adds a vtable: struct nsc_gpio_ops, to abstract the existing gpio
    operations, then adjusts fileops.write() code to invoke operations via that
    vtable.  Driver specific open()s set private_data to the vtable so its
    available for use by write().
    
    The vtable gets the gpio_dump() too, since its user-friendly, and (could be
    construed as) part of the current device-file interface.  To support use of
    dev_dbg() in write() & _dump(), the vtable gets a dev ptr too, set by both
    scx200 & pc8736x _gpio drivers.
    
    heres how the pins are presented in syslog:
    
    [ 1890.176223]  scx200_gpio.0: io00: 0x0044 TS OD PUE  EDGE LO DEBOUNCE
    [ 1890.287223]  scx200_gpio.0: io01: 0x0003 OE PP PUD  EDGE LO
    
    nsc_gpio.c: new file is new home of several file-ops methods, which are
    modified to get their vtable from filp->private_data, and use it where needed.
    
    scx200_gpio.c: keeps some of its existing gpio routines, but now wires them up
    via the vtable (they're invoked by nsc_gpio.c:nsc_gpio_write() thru this
    vtable).  A driver-spcific open() initializes filp->private_data with the
    vtable.
    
    Once the split is clean, and the scx200_gpio driver is working, we copy and
    modify the function and variable names, and rework the access-method bodies
    for the different addressing scheme.
    
    Heres a working overview of the patchset:
    
    # series file for GPIO
    
    # Spring Cleaning
    gpio-scx/patch.preclean        # scripts/Lindent fixes, editor-ctrl comments
    
    # API Modernization
    
    gpio-scx/patch.api26        # what I learned from LDD3
    gpio-scx/patch.platform-dev-2    # get pdev, support for dev_dbg()
    gpio-scx/patch.unsigned-minor    # fix to match std practice
    
    # Debuggability
    
    gpio-scx/patch.dump-diet    # shrink gpio_dump()
    gpio-scx/patch.viewpins        # add new 'command' to call dump()
    gpio-scx/patch.init-refactor    # pull shadow-register init to sub
    
    # Access-Abstraction (add vtable)
    
    gpio-scx/patch.access-vtable    # introduce nsg_gpio_ops vtable, w dump
    gpio-scx/patch.vtable-calls    # add & use the vtable in scx200_gpio
    gpio-scx/patch.nscgpio-shell    # add empty driver for common-fops
    
    # move code under abstraction
    gpio-scx/patch.migrate-fops    # move file-ops methods from scx200_gpio
    gpio-scx/patch.common-dump    # mv scx200.c:scx200_gpio_dump() to nsc_gpio.c
    gpio-scx/patch.add-pc8736x-gpio    # add new driver, like old, w chip adapt
    # gpio-scx/patch.add-DEBUG    # enable all dev_dbg()s
    
    # Cleanups
    
    # finish printk -> dev_dbg() etc
    gpio-scx/patch.pdev-pc8736x    # new drvr needs pdev too,
    gpio-scx/patch.devdbg-nscgpio    # add device to 'vtable', use in dev_dbg()
    
    # gpio-scx/patch.pin-config-view    # another 'c' 'command'
    # gpio-scx/quiet-getset        # take out excess dbg stuff (pretty quiet
    now)
    gpio-scx/patch.shadow-current    # imitate scx200_gpio's shadow regs in
    pc87*
    
    # post KMentors-post patches ..
    
    gpio-scx/patch.mutexes        # use mutexes for config-locks
    gpio-scx/patch.viewpins-values    # extend dump to obsolete separate 'c' cmd
    
    gpio-scx/patch.kconfig        # add stuff for kbuild
    
    # TBC
    # combine api26 with pdev, which is just one step.
    # merge c&v commands to single do-all-fn
    # delay viewpins, dump-diet should also un-ifdef it too.
    
    diff.sys-gpio-rollup-1
    
    This patch:
    
    Removed editor format-control comments, and used scripts/Lindent to clean up
    whitespace, then deleted the bogus chunks :-(
    
    Signed-off-by: Jim Cromie <jim.cromie@gmail.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/char/scx200_gpio.c b/drivers/char/scx200_gpio.c
index 664a6e97eb1a..dd051ea6755e 100644
--- a/drivers/char/scx200_gpio.c
+++ b/drivers/char/scx200_gpio.c
@@ -1,4 +1,4 @@
-/* linux/drivers/char/scx200_gpio.c 
+/* linux/drivers/char/scx200_gpio.c
 
    National Semiconductor SCx200 GPIO driver.  Allows a user space
    process to play with the GPIO pins.
@@ -26,7 +26,7 @@ static int major = 0;		/* default to dynamic major */
 module_param(major, int, 0);
 MODULE_PARM_DESC(major, "Major device number");
 
-static ssize_t scx200_gpio_write(struct file *file, const char __user *data, 
+static ssize_t scx200_gpio_write(struct file *file, const char __user *data,
 				 size_t len, loff_t *ppos)
 {
 	unsigned m = iminor(file->f_dentry->d_inode);
@@ -34,15 +34,14 @@ static ssize_t scx200_gpio_write(struct file *file, const char __user *data,
 
 	for (i = 0; i < len; ++i) {
 		char c;
-		if (get_user(c, data+i))
+		if (get_user(c, data + i))
 			return -EFAULT;
-		switch (c)
-		{
-		case '0': 
-			scx200_gpio_set(m, 0); 
+		switch (c) {
+		case '0':
+			scx200_gpio_set(m, 0);
 			break;
-		case '1': 
-			scx200_gpio_set(m, 1); 
+		case '1':
+			scx200_gpio_set(m, 1);
 			break;
 		case 'O':
 			printk(KERN_INFO NAME ": GPIO%d output enabled\n", m);
@@ -83,7 +82,7 @@ static ssize_t scx200_gpio_read(struct file *file, char __user *buf,
 	value = scx200_gpio_get(m);
 	if (put_user(value ? '1' : '0', buf))
 		return -EFAULT;
-	
+
 	return 1;
 }
 
@@ -140,10 +139,3 @@ static void __exit scx200_gpio_cleanup(void)
 
 module_init(scx200_gpio_init);
 module_exit(scx200_gpio_cleanup);
-
-/*
-    Local variables:
-        compile-command: "make -k -C ../.. SUBDIRS=drivers/char modules"
-        c-basic-offset: 8
-    End:
-*/

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/drivers/char/scx200_gpio.c b/drivers/char/scx200_gpio.c
new file mode 100644
index 000000000000..664a6e97eb1a
--- /dev/null
+++ b/drivers/char/scx200_gpio.c
@@ -0,0 +1,149 @@
+/* linux/drivers/char/scx200_gpio.c 
+
+   National Semiconductor SCx200 GPIO driver.  Allows a user space
+   process to play with the GPIO pins.
+
+   Copyright (c) 2001,2002 Christer Weinigel <wingel@nano-system.com> */
+
+#include <linux/config.h>
+#include <linux/fs.h>
+#include <linux/module.h>
+#include <linux/errno.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <asm/uaccess.h>
+#include <asm/io.h>
+
+#include <linux/scx200_gpio.h>
+
+#define NAME "scx200_gpio"
+
+MODULE_AUTHOR("Christer Weinigel <wingel@nano-system.com>");
+MODULE_DESCRIPTION("NatSemi SCx200 GPIO Pin Driver");
+MODULE_LICENSE("GPL");
+
+static int major = 0;		/* default to dynamic major */
+module_param(major, int, 0);
+MODULE_PARM_DESC(major, "Major device number");
+
+static ssize_t scx200_gpio_write(struct file *file, const char __user *data, 
+				 size_t len, loff_t *ppos)
+{
+	unsigned m = iminor(file->f_dentry->d_inode);
+	size_t i;
+
+	for (i = 0; i < len; ++i) {
+		char c;
+		if (get_user(c, data+i))
+			return -EFAULT;
+		switch (c)
+		{
+		case '0': 
+			scx200_gpio_set(m, 0); 
+			break;
+		case '1': 
+			scx200_gpio_set(m, 1); 
+			break;
+		case 'O':
+			printk(KERN_INFO NAME ": GPIO%d output enabled\n", m);
+			scx200_gpio_configure(m, ~1, 1);
+			break;
+		case 'o':
+			printk(KERN_INFO NAME ": GPIO%d output disabled\n", m);
+			scx200_gpio_configure(m, ~1, 0);
+			break;
+		case 'T':
+			printk(KERN_INFO NAME ": GPIO%d output is push pull\n", m);
+			scx200_gpio_configure(m, ~2, 2);
+			break;
+		case 't':
+			printk(KERN_INFO NAME ": GPIO%d output is open drain\n", m);
+			scx200_gpio_configure(m, ~2, 0);
+			break;
+		case 'P':
+			printk(KERN_INFO NAME ": GPIO%d pull up enabled\n", m);
+			scx200_gpio_configure(m, ~4, 4);
+			break;
+		case 'p':
+			printk(KERN_INFO NAME ": GPIO%d pull up disabled\n", m);
+			scx200_gpio_configure(m, ~4, 0);
+			break;
+		}
+	}
+
+	return len;
+}
+
+static ssize_t scx200_gpio_read(struct file *file, char __user *buf,
+				size_t len, loff_t *ppos)
+{
+	unsigned m = iminor(file->f_dentry->d_inode);
+	int value;
+
+	value = scx200_gpio_get(m);
+	if (put_user(value ? '1' : '0', buf))
+		return -EFAULT;
+	
+	return 1;
+}
+
+static int scx200_gpio_open(struct inode *inode, struct file *file)
+{
+	unsigned m = iminor(inode);
+	if (m > 63)
+		return -EINVAL;
+	return nonseekable_open(inode, file);
+}
+
+static int scx200_gpio_release(struct inode *inode, struct file *file)
+{
+	return 0;
+}
+
+
+static struct file_operations scx200_gpio_fops = {
+	.owner   = THIS_MODULE,
+	.write   = scx200_gpio_write,
+	.read    = scx200_gpio_read,
+	.open    = scx200_gpio_open,
+	.release = scx200_gpio_release,
+};
+
+static int __init scx200_gpio_init(void)
+{
+	int r;
+
+	printk(KERN_DEBUG NAME ": NatSemi SCx200 GPIO Driver\n");
+
+	if (!scx200_gpio_present()) {
+		printk(KERN_ERR NAME ": no SCx200 gpio pins available\n");
+		return -ENODEV;
+	}
+
+	r = register_chrdev(major, NAME, &scx200_gpio_fops);
+	if (r < 0) {
+		printk(KERN_ERR NAME ": unable to register character device\n");
+		return r;
+	}
+	if (!major) {
+		major = r;
+		printk(KERN_DEBUG NAME ": got dynamic major %d\n", major);
+	}
+
+	return 0;
+}
+
+static void __exit scx200_gpio_cleanup(void)
+{
+	unregister_chrdev(major, NAME);
+}
+
+module_init(scx200_gpio_init);
+module_exit(scx200_gpio_cleanup);
+
+/*
+    Local variables:
+        compile-command: "make -k -C ../.. SUBDIRS=drivers/char modules"
+        c-basic-offset: 8
+    End:
+*/
