commit aa8ba13cae3134b8ef1c1b6879f66372531da738
Author: Qiushi Wu <wu000273@umn.edu>
Date:   Wed May 27 21:01:09 2020 -0500

    vfio/mdev: Fix reference count leak in add_mdev_supported_type
    
    kobject_init_and_add() takes reference even when it fails.
    If this function returns an error, kobject_put() must be called to
    properly clean up the memory associated with the object. Thus,
    replace kfree() by kobject_put() to fix this issue. Previous
    commit "b8eb718348b8" fixed a similar problem.
    
    Fixes: 7b96953bc640 ("vfio: Mediated device Core driver")
    Signed-off-by: Qiushi Wu <wu000273@umn.edu>
    Reviewed-by: Cornelia Huck <cohuck@redhat.com>
    Reviewed-by: Kirti Wankhede <kwankhede@nvidia.com>
    Signed-off-by: Alex Williamson <alex.williamson@redhat.com>

diff --git a/drivers/vfio/mdev/mdev_sysfs.c b/drivers/vfio/mdev/mdev_sysfs.c
index 8ad14e5c02bf..917fd84c1c6f 100644
--- a/drivers/vfio/mdev/mdev_sysfs.c
+++ b/drivers/vfio/mdev/mdev_sysfs.c
@@ -110,7 +110,7 @@ static struct mdev_type *add_mdev_supported_type(struct mdev_parent *parent,
 				   "%s-%s", dev_driver_string(parent->dev),
 				   group->name);
 	if (ret) {
-		kfree(type);
+		kobject_put(&type->kobj);
 		return ERR_PTR(ret);
 	}
 

commit e10b4f6cd89f3ac2044c8f6b4b0ddc1a48f65e09
Author: Ben Dooks (Codethink) <ben.dooks@codethink.co.uk>
Date:   Wed Dec 18 12:31:19 2019 +0000

    vfio/mdev: make create attribute static
    
    The create attribute is not exported, so make it
    static to avoid the following sparse warning:
    
    drivers/vfio/mdev/mdev_sysfs.c:77:1: warning: symbol 'mdev_type_attr_create' was not declared. Should it be static?
    
    Signed-off-by: Ben Dooks (Codethink) <ben.dooks@codethink.co.uk>
    Reviewed-by: Cornelia Huck <cohuck@redhat.com>
    Signed-off-by: Alex Williamson <alex.williamson@redhat.com>

diff --git a/drivers/vfio/mdev/mdev_sysfs.c b/drivers/vfio/mdev/mdev_sysfs.c
index 7570c7602ab4..8ad14e5c02bf 100644
--- a/drivers/vfio/mdev/mdev_sysfs.c
+++ b/drivers/vfio/mdev/mdev_sysfs.c
@@ -74,7 +74,7 @@ static ssize_t create_store(struct kobject *kobj, struct device *dev,
 	return count;
 }
 
-MDEV_TYPE_ATTR_WO(create);
+static MDEV_TYPE_ATTR_WO(create);
 
 static void mdev_type_release(struct kobject *kobj)
 {

commit d2912cb15bdda8ba4a5dd73396ad62641af2f520
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jun 4 10:11:33 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 500
    
    Based on 2 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation #
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 4122 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Enrico Weigelt <info@metux.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190604081206.933168790@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/vfio/mdev/mdev_sysfs.c b/drivers/vfio/mdev/mdev_sysfs.c
index ffa3dcebf201..7570c7602ab4 100644
--- a/drivers/vfio/mdev/mdev_sysfs.c
+++ b/drivers/vfio/mdev/mdev_sysfs.c
@@ -1,13 +1,10 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * File attributes for Mediated devices
  *
  * Copyright (c) 2016, NVIDIA CORPORATION. All rights reserved.
  *     Author: Neo Jia <cjia@nvidia.com>
  *             Kirti Wankhede <kwankhede@nvidia.com>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
  */
 
 #include <linux/sysfs.h>

commit 26c9e3988eec6b858c08b0fc352d8eb13832d828
Author: Parav Pandit <parav@mellanox.com>
Date:   Thu Jun 6 10:52:33 2019 -0600

    vfio/mdev: Avoid creating sysfs remove file on stale device removal
    
    If device is removal is initiated by two threads as below, mdev core
    attempts to create a syfs remove file on stale device.
    During this flow, below [1] call trace is observed.
    
         cpu-0                                    cpu-1
         -----                                    -----
      mdev_unregister_device()
        device_for_each_child
           mdev_device_remove_cb
              mdev_device_remove
                                           user_syscall
                                             remove_store()
                                               mdev_device_remove()
                                            [..]
       unregister device();
                                           /* not found in list or
                                            * active=false.
                                            */
                                              sysfs_create_file()
                                              ..Call trace
    
    Now that mdev core follows correct device removal sequence of the linux
    bus model, remove shouldn't fail in normal cases. If it fails, there is
    no point of creating a stale file or checking for specific error status.
    
    kernel: WARNING: CPU: 2 PID: 9348 at fs/sysfs/file.c:327
    sysfs_create_file_ns+0x7f/0x90
    kernel: CPU: 2 PID: 9348 Comm: bash Kdump: loaded Not tainted
    5.1.0-rc6-vdevbus+ #6
    kernel: Hardware name: Supermicro SYS-6028U-TR4+/X10DRU-i+, BIOS 2.0b
    08/09/2016
    kernel: RIP: 0010:sysfs_create_file_ns+0x7f/0x90
    kernel: Call Trace:
    kernel: remove_store+0xdc/0x100 [mdev]
    kernel: kernfs_fop_write+0x113/0x1a0
    kernel: vfs_write+0xad/0x1b0
    kernel: ksys_write+0x5a/0xe0
    kernel: do_syscall_64+0x5a/0x210
    kernel: entry_SYSCALL_64_after_hwframe+0x49/0xbe
    
    Reviewed-by: Cornelia Huck <cohuck@redhat.com>
    Signed-off-by: Parav Pandit <parav@mellanox.com>
    Signed-off-by: Alex Williamson <alex.williamson@redhat.com>

diff --git a/drivers/vfio/mdev/mdev_sysfs.c b/drivers/vfio/mdev/mdev_sysfs.c
index 9f774b91d275..ffa3dcebf201 100644
--- a/drivers/vfio/mdev/mdev_sysfs.c
+++ b/drivers/vfio/mdev/mdev_sysfs.c
@@ -237,10 +237,8 @@ static ssize_t remove_store(struct device *dev, struct device_attribute *attr,
 		int ret;
 
 		ret = mdev_device_remove(dev);
-		if (ret) {
-			device_create_file(dev, attr);
+		if (ret)
 			return ret;
-		}
 	}
 
 	return count;

commit 522ecce08ab20b57342d65b05601818e0f95fb2c
Author: Parav Pandit <parav@mellanox.com>
Date:   Thu Jun 6 10:52:32 2019 -0600

    vfio/mdev: Improve the create/remove sequence
    
    This patch addresses below two issues and prepares the code to address
    3rd issue listed below.
    
    1. mdev device is placed on the mdev bus before it is created in the
    vendor driver. Once a device is placed on the mdev bus without creating
    its supporting underlying vendor device, mdev driver's probe() gets
    triggered.  However there isn't a stable mdev available to work on.
    
       create_store()
         mdev_create_device()
           device_register()
              ...
             vfio_mdev_probe()
            [...]
            parent->ops->create()
              vfio_ap_mdev_create()
                mdev_set_drvdata(mdev, matrix_mdev);
                /* Valid pointer set above */
    
    Due to this way of initialization, mdev driver who wants to use the mdev,
    doesn't have a valid mdev to work on.
    
    2. Current creation sequence is,
       parent->ops_create()
       groups_register()
    
    Remove sequence is,
       parent->ops->remove()
       groups_unregister()
    
    However, remove sequence should be exact mirror of creation sequence.
    Once this is achieved, all users of the mdev will be terminated first
    before removing underlying vendor device.
    (Follow standard linux driver model).
    At that point vendor's remove() ops shouldn't fail because taking the
    device off the bus should terminate any usage.
    
    3. When remove operation fails, mdev sysfs removal attempts to add the
    file back on already removed device. Following call trace [1] is observed.
    
    [1] call trace:
    kernel: WARNING: CPU: 2 PID: 9348 at fs/sysfs/file.c:327 sysfs_create_file_ns+0x7f/0x90
    kernel: CPU: 2 PID: 9348 Comm: bash Kdump: loaded Not tainted 5.1.0-rc6-vdevbus+ #6
    kernel: Hardware name: Supermicro SYS-6028U-TR4+/X10DRU-i+, BIOS 2.0b 08/09/2016
    kernel: RIP: 0010:sysfs_create_file_ns+0x7f/0x90
    kernel: Call Trace:
    kernel: remove_store+0xdc/0x100 [mdev]
    kernel: kernfs_fop_write+0x113/0x1a0
    kernel: vfs_write+0xad/0x1b0
    kernel: ksys_write+0x5a/0xe0
    kernel: do_syscall_64+0x5a/0x210
    kernel: entry_SYSCALL_64_after_hwframe+0x49/0xbe
    
    Therefore, mdev core is improved in following ways.
    
    1. Split the device registration/deregistration sequence so that some
    things can be done between initialization of the device and hooking it
    up to the bus respectively after deregistering it from the bus but
    before giving up our final reference.
    In particular, this means invoking the ->create() and ->remove()
    callbacks in those new windows. This gives the vendor driver an
    initialized mdev device to work with during creation.
    At the same time, a bus driver who wish to bind to mdev driver also
    gets initialized mdev device.
    
    This follows standard Linux kernel bus and device model.
    
    2. During remove flow, first remove the device from the bus. This
    ensures that any bus specific devices are removed.
    Once device is taken off the mdev bus, invoke remove() of mdev
    from the vendor driver.
    
    3. The driver core device model provides way to register and auto
    unregister the device sysfs attribute groups at dev->groups.
    Make use of dev->groups to let core create the groups and eliminate
    code to avoid explicit groups creation and removal.
    
    To ensure, that new sequence is solid, a below stack dump of a
    process is taken who attempts to remove the device while device is in
    use by vfio driver and user application.
    This stack dump validates that vfio driver guards against such device
    removal when device is in use.
    
     cat /proc/21962/stack
    [<0>] vfio_del_group_dev+0x216/0x3c0 [vfio]
    [<0>] mdev_remove+0x21/0x40 [mdev]
    [<0>] device_release_driver_internal+0xe8/0x1b0
    [<0>] bus_remove_device+0xf9/0x170
    [<0>] device_del+0x168/0x350
    [<0>] mdev_device_remove_common+0x1d/0x50 [mdev]
    [<0>] mdev_device_remove+0x8c/0xd0 [mdev]
    [<0>] remove_store+0x71/0x90 [mdev]
    [<0>] kernfs_fop_write+0x113/0x1a0
    [<0>] vfs_write+0xad/0x1b0
    [<0>] ksys_write+0x5a/0xe0
    [<0>] do_syscall_64+0x5a/0x210
    [<0>] entry_SYSCALL_64_after_hwframe+0x49/0xbe
    [<0>] 0xffffffffffffffff
    
    This prepares the code to eliminate calling device_create_file() in
    subsequent patch.
    
    Reviewed-by: Cornelia Huck <cohuck@redhat.com>
    Signed-off-by: Parav Pandit <parav@mellanox.com>
    Signed-off-by: Alex Williamson <alex.williamson@redhat.com>

diff --git a/drivers/vfio/mdev/mdev_sysfs.c b/drivers/vfio/mdev/mdev_sysfs.c
index cbf94b8165ea..9f774b91d275 100644
--- a/drivers/vfio/mdev/mdev_sysfs.c
+++ b/drivers/vfio/mdev/mdev_sysfs.c
@@ -236,7 +236,7 @@ static ssize_t remove_store(struct device *dev, struct device_attribute *attr,
 	if (val && device_remove_file_self(dev, attr)) {
 		int ret;
 
-		ret = mdev_device_remove(dev, false);
+		ret = mdev_device_remove(dev);
 		if (ret) {
 			device_create_file(dev, attr);
 			return ret;

commit a6d6f4f160f76d840e59affe664b8d3159e23056
Author: Parav Pandit <parav@mellanox.com>
Date:   Tue Apr 30 17:49:32 2019 -0500

    vfio/mdev: Follow correct remove sequence
    
    mdev_remove_sysfs_files() should follow exact mirror sequence of a
    create, similar to what is followed in error unwinding path of
    mdev_create_sysfs_files().
    
    Fixes: 6a62c1dfb5c7 ("vfio/mdev: Re-order sysfs attribute creation")
    Reviewed-by: Cornelia Huck <cohuck@redhat.com>
    Reviewed-by: Maxim Levitsky <mlevitsk@redhat.com>
    Signed-off-by: Parav Pandit <parav@mellanox.com>
    Signed-off-by: Alex Williamson <alex.williamson@redhat.com>

diff --git a/drivers/vfio/mdev/mdev_sysfs.c b/drivers/vfio/mdev/mdev_sysfs.c
index 5193a0e0ce5a..cbf94b8165ea 100644
--- a/drivers/vfio/mdev/mdev_sysfs.c
+++ b/drivers/vfio/mdev/mdev_sysfs.c
@@ -280,7 +280,7 @@ int  mdev_create_sysfs_files(struct device *dev, struct mdev_type *type)
 
 void mdev_remove_sysfs_files(struct device *dev, struct mdev_type *type)
 {
+	sysfs_remove_files(&dev->kobj, mdev_device_attrs);
 	sysfs_remove_link(&dev->kobj, "mdev_type");
 	sysfs_remove_link(type->devices_kobj, dev_name(dev));
-	sysfs_remove_files(&dev->kobj, mdev_device_attrs);
 }

commit 278bca7f318e6a29f482eabbca52db538dc5d4e6
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Thu Jan 10 21:00:27 2019 +0200

    vfio-mdev: Switch to use new generic UUID API
    
    There are new types and helpers that are supposed to be used in new code.
    
    As a preparation to get rid of legacy types and API functions do
    the conversion here.
    
    Cc: Kirti Wankhede <kwankhede@nvidia.com>
    Cc: Alex Williamson <alex.williamson@redhat.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Alex Williamson <alex.williamson@redhat.com>

diff --git a/drivers/vfio/mdev/mdev_sysfs.c b/drivers/vfio/mdev/mdev_sysfs.c
index ce5dd219f2c8..5193a0e0ce5a 100644
--- a/drivers/vfio/mdev/mdev_sysfs.c
+++ b/drivers/vfio/mdev/mdev_sysfs.c
@@ -55,7 +55,7 @@ static ssize_t create_store(struct kobject *kobj, struct device *dev,
 			    const char *buf, size_t count)
 {
 	char *str;
-	uuid_le uuid;
+	guid_t uuid;
 	int ret;
 
 	if ((count < UUID_STRING_LEN) || (count > UUID_STRING_LEN + 1))
@@ -65,12 +65,12 @@ static ssize_t create_store(struct kobject *kobj, struct device *dev,
 	if (!str)
 		return -ENOMEM;
 
-	ret = uuid_le_to_bin(str, &uuid);
+	ret = guid_parse(str, &uuid);
 	kfree(str);
 	if (ret)
 		return ret;
 
-	ret = mdev_device_create(kobj, dev, uuid);
+	ret = mdev_device_create(kobj, dev, &uuid);
 	if (ret)
 		return ret;
 

commit 9422f5871d5d9ad9e168e1329a43cf9169b04712
Author: Paolo Cretaro <paolocretaro@gmail.com>
Date:   Tue Nov 13 09:45:43 2018 +0100

    vfio/mdev: add static modifier to add_mdev_supported_type
    
    Set add_mdev_supported_type as static since it is only used within
    mdev_sysfs.c.  This fixes -Wmissing-prototypes gcc warning.
    
    Signed-off-by: Paolo Cretaro <paolocretaro@gmail.com>
    Reviewed-by: Cornelia Huck <cohuck@redhat.com>
    Signed-off-by: Alex Williamson <alex.williamson@redhat.com>

diff --git a/drivers/vfio/mdev/mdev_sysfs.c b/drivers/vfio/mdev/mdev_sysfs.c
index 249472f05509..ce5dd219f2c8 100644
--- a/drivers/vfio/mdev/mdev_sysfs.c
+++ b/drivers/vfio/mdev/mdev_sysfs.c
@@ -92,8 +92,8 @@ static struct kobj_type mdev_type_ktype = {
 	.release = mdev_type_release,
 };
 
-struct mdev_type *add_mdev_supported_type(struct mdev_parent *parent,
-					  struct attribute_group *group)
+static struct mdev_type *add_mdev_supported_type(struct mdev_parent *parent,
+						 struct attribute_group *group)
 {
 	struct mdev_type *type;
 	int ret;

commit 6a62c1dfb5c7f6719361180fd0fdf45b15a35d95
Author: Alex Williamson <alex.williamson@redhat.com>
Date:   Fri May 18 11:40:33 2018 -0600

    vfio/mdev: Re-order sysfs attribute creation
    
    There exists a gap at the end of mdev_device_create() where the device
    is visible to userspace, but we're not yet ready to handle removal, as
    triggered through the 'remove' attribute.  We handle this properly in
    mdev_device_remove() with an -EAGAIN return, but we can marginally
    reduce this gap by adding this attribute as a final step of our sysfs
    setup.
    
    Reviewed-by: Kirti Wankhede <kwankhede@nvidia.com>
    Reviewed-by: Cornelia Huck <cohuck@redhat.com>
    Acked-by: Halil Pasic <pasic@linux.ibm.com>
    Signed-off-by: Alex Williamson <alex.williamson@redhat.com>

diff --git a/drivers/vfio/mdev/mdev_sysfs.c b/drivers/vfio/mdev/mdev_sysfs.c
index 802df210929b..249472f05509 100644
--- a/drivers/vfio/mdev/mdev_sysfs.c
+++ b/drivers/vfio/mdev/mdev_sysfs.c
@@ -257,24 +257,24 @@ int  mdev_create_sysfs_files(struct device *dev, struct mdev_type *type)
 {
 	int ret;
 
-	ret = sysfs_create_files(&dev->kobj, mdev_device_attrs);
-	if (ret)
-		return ret;
-
 	ret = sysfs_create_link(type->devices_kobj, &dev->kobj, dev_name(dev));
 	if (ret)
-		goto device_link_failed;
+		return ret;
 
 	ret = sysfs_create_link(&dev->kobj, &type->kobj, "mdev_type");
 	if (ret)
 		goto type_link_failed;
 
+	ret = sysfs_create_files(&dev->kobj, mdev_device_attrs);
+	if (ret)
+		goto create_files_failed;
+
 	return ret;
 
+create_files_failed:
+	sysfs_remove_link(&dev->kobj, "mdev_type");
 type_link_failed:
 	sysfs_remove_link(type->devices_kobj, dev_name(dev));
-device_link_failed:
-	sysfs_remove_files(&dev->kobj, mdev_device_attrs);
 	return ret;
 }
 

commit 42930553a7c11f06351bc08b889808d0f6020f08
Author: Alex Williamson <alex.williamson@redhat.com>
Date:   Fri Dec 30 08:13:38 2016 -0700

    vfio-mdev: de-polute the namespace, rename parent_device & parent_ops
    
    Add an mdev_ prefix so we're not poluting the namespace so much.
    
    Cc: Zhenyu Wang <zhenyuw@linux.intel.com>
    Cc: Zhi Wang <zhi.a.wang@intel.com>
    Cc: Jike Song <jike.song@intel.com>
    Signed-off-by: Alex Williamson <alex.williamson@redhat.com>
    Reviewed by: Kirti Wankhede <kwankhede@nvidia.com>

diff --git a/drivers/vfio/mdev/mdev_sysfs.c b/drivers/vfio/mdev/mdev_sysfs.c
index 1a53deb2ee10..802df210929b 100644
--- a/drivers/vfio/mdev/mdev_sysfs.c
+++ b/drivers/vfio/mdev/mdev_sysfs.c
@@ -92,7 +92,7 @@ static struct kobj_type mdev_type_ktype = {
 	.release = mdev_type_release,
 };
 
-struct mdev_type *add_mdev_supported_type(struct parent_device *parent,
+struct mdev_type *add_mdev_supported_type(struct mdev_parent *parent,
 					  struct attribute_group *group)
 {
 	struct mdev_type *type;
@@ -158,7 +158,7 @@ static void remove_mdev_supported_type(struct mdev_type *type)
 	kobject_put(&type->kobj);
 }
 
-static int add_mdev_supported_type_groups(struct parent_device *parent)
+static int add_mdev_supported_type_groups(struct mdev_parent *parent)
 {
 	int i;
 
@@ -183,7 +183,7 @@ static int add_mdev_supported_type_groups(struct parent_device *parent)
 }
 
 /* mdev sysfs functions */
-void parent_remove_sysfs_files(struct parent_device *parent)
+void parent_remove_sysfs_files(struct mdev_parent *parent)
 {
 	struct mdev_type *type, *tmp;
 
@@ -196,7 +196,7 @@ void parent_remove_sysfs_files(struct parent_device *parent)
 	kset_unregister(parent->mdev_types_kset);
 }
 
-int parent_create_sysfs_files(struct parent_device *parent)
+int parent_create_sysfs_files(struct mdev_parent *parent)
 {
 	int ret;
 

commit 7b96953bc640b6b25665fe17ffca4b668b371f14
Author: Kirti Wankhede <kwankhede@nvidia.com>
Date:   Thu Nov 17 02:16:13 2016 +0530

    vfio: Mediated device Core driver
    
    Design for Mediated Device Driver:
    Main purpose of this driver is to provide a common interface for mediated
    device management that can be used by different drivers of different
    devices.
    
    This module provides a generic interface to create the device, add it to
    mediated bus, add device to IOMMU group and then add it to vfio group.
    
    Below is the high Level block diagram, with Nvidia, Intel and IBM devices
    as example, since these are the devices which are going to actively use
    this module as of now.
    
     +---------------+
     |               |
     | +-----------+ |  mdev_register_driver() +--------------+
     | |           | +<------------------------+ __init()     |
     | |  mdev     | |                         |              |
     | |  bus      | +------------------------>+              |<-> VFIO user
     | |  driver   | |     probe()/remove()    | vfio_mdev.ko |    APIs
     | |           | |                         |              |
     | +-----------+ |                         +--------------+
     |               |
     |  MDEV CORE    |
     |   MODULE      |
     |   mdev.ko     |
     | +-----------+ |  mdev_register_device() +--------------+
     | |           | +<------------------------+              |
     | |           | |                         |  nvidia.ko   |<-> physical
     | |           | +------------------------>+              |    device
     | |           | |        callback         +--------------+
     | | Physical  | |
     | |  device   | |  mdev_register_device() +--------------+
     | | interface | |<------------------------+              |
     | |           | |                         |  i915.ko     |<-> physical
     | |           | +------------------------>+              |    device
     | |           | |        callback         +--------------+
     | |           | |
     | |           | |  mdev_register_device() +--------------+
     | |           | +<------------------------+              |
     | |           | |                         | ccw_device.ko|<-> physical
     | |           | +------------------------>+              |    device
     | |           | |        callback         +--------------+
     | +-----------+ |
     +---------------+
    
    Core driver provides two types of registration interfaces:
    1. Registration interface for mediated bus driver:
    
    /**
      * struct mdev_driver - Mediated device's driver
      * @name: driver name
      * @probe: called when new device created
      * @remove:called when device removed
      * @driver:device driver structure
      *
      **/
    struct mdev_driver {
             const char *name;
             int  (*probe)  (struct device *dev);
             void (*remove) (struct device *dev);
             struct device_driver    driver;
    };
    
    Mediated bus driver for mdev device should use this interface to register
    and unregister with core driver respectively:
    
    int  mdev_register_driver(struct mdev_driver *drv, struct module *owner);
    void mdev_unregister_driver(struct mdev_driver *drv);
    
    Mediated bus driver is responsible to add/delete mediated devices to/from
    VFIO group when devices are bound and unbound to the driver.
    
    2. Physical device driver interface
    This interface provides vendor driver the set APIs to manage physical
    device related work in its driver. APIs are :
    
    * dev_attr_groups: attributes of the parent device.
    * mdev_attr_groups: attributes of the mediated device.
    * supported_type_groups: attributes to define supported type. This is
                             mandatory field.
    * create: to allocate basic resources in vendor driver for a mediated
             device. This is mandatory to be provided by vendor driver.
    * remove: to free resources in vendor driver when mediated device is
             destroyed. This is mandatory to be provided by vendor driver.
    * open: open callback of mediated device
    * release: release callback of mediated device
    * read : read emulation callback.
    * write: write emulation callback.
    * ioctl: ioctl callback.
    * mmap: mmap emulation callback.
    
    Drivers should use these interfaces to register and unregister device to
    mdev core driver respectively:
    
    extern int  mdev_register_device(struct device *dev,
                                     const struct parent_ops *ops);
    extern void mdev_unregister_device(struct device *dev);
    
    There are no locks to serialize above callbacks in mdev driver and
    vfio_mdev driver. If required, vendor driver can have locks to serialize
    above APIs in their driver.
    
    Signed-off-by: Kirti Wankhede <kwankhede@nvidia.com>
    Signed-off-by: Neo Jia <cjia@nvidia.com>
    Reviewed-by: Jike Song <jike.song@intel.com>
    Reviewed-by: Dong Jia Shi <bjsdjshi@linux.vnet.ibm.com>
    Signed-off-by: Alex Williamson <alex.williamson@redhat.com>

diff --git a/drivers/vfio/mdev/mdev_sysfs.c b/drivers/vfio/mdev/mdev_sysfs.c
new file mode 100644
index 000000000000..1a53deb2ee10
--- /dev/null
+++ b/drivers/vfio/mdev/mdev_sysfs.c
@@ -0,0 +1,286 @@
+/*
+ * File attributes for Mediated devices
+ *
+ * Copyright (c) 2016, NVIDIA CORPORATION. All rights reserved.
+ *     Author: Neo Jia <cjia@nvidia.com>
+ *             Kirti Wankhede <kwankhede@nvidia.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/sysfs.h>
+#include <linux/ctype.h>
+#include <linux/device.h>
+#include <linux/slab.h>
+#include <linux/uuid.h>
+#include <linux/mdev.h>
+
+#include "mdev_private.h"
+
+/* Static functions */
+
+static ssize_t mdev_type_attr_show(struct kobject *kobj,
+				     struct attribute *__attr, char *buf)
+{
+	struct mdev_type_attribute *attr = to_mdev_type_attr(__attr);
+	struct mdev_type *type = to_mdev_type(kobj);
+	ssize_t ret = -EIO;
+
+	if (attr->show)
+		ret = attr->show(kobj, type->parent->dev, buf);
+	return ret;
+}
+
+static ssize_t mdev_type_attr_store(struct kobject *kobj,
+				      struct attribute *__attr,
+				      const char *buf, size_t count)
+{
+	struct mdev_type_attribute *attr = to_mdev_type_attr(__attr);
+	struct mdev_type *type = to_mdev_type(kobj);
+	ssize_t ret = -EIO;
+
+	if (attr->store)
+		ret = attr->store(&type->kobj, type->parent->dev, buf, count);
+	return ret;
+}
+
+static const struct sysfs_ops mdev_type_sysfs_ops = {
+	.show = mdev_type_attr_show,
+	.store = mdev_type_attr_store,
+};
+
+static ssize_t create_store(struct kobject *kobj, struct device *dev,
+			    const char *buf, size_t count)
+{
+	char *str;
+	uuid_le uuid;
+	int ret;
+
+	if ((count < UUID_STRING_LEN) || (count > UUID_STRING_LEN + 1))
+		return -EINVAL;
+
+	str = kstrndup(buf, count, GFP_KERNEL);
+	if (!str)
+		return -ENOMEM;
+
+	ret = uuid_le_to_bin(str, &uuid);
+	kfree(str);
+	if (ret)
+		return ret;
+
+	ret = mdev_device_create(kobj, dev, uuid);
+	if (ret)
+		return ret;
+
+	return count;
+}
+
+MDEV_TYPE_ATTR_WO(create);
+
+static void mdev_type_release(struct kobject *kobj)
+{
+	struct mdev_type *type = to_mdev_type(kobj);
+
+	pr_debug("Releasing group %s\n", kobj->name);
+	kfree(type);
+}
+
+static struct kobj_type mdev_type_ktype = {
+	.sysfs_ops = &mdev_type_sysfs_ops,
+	.release = mdev_type_release,
+};
+
+struct mdev_type *add_mdev_supported_type(struct parent_device *parent,
+					  struct attribute_group *group)
+{
+	struct mdev_type *type;
+	int ret;
+
+	if (!group->name) {
+		pr_err("%s: Type name empty!\n", __func__);
+		return ERR_PTR(-EINVAL);
+	}
+
+	type = kzalloc(sizeof(*type), GFP_KERNEL);
+	if (!type)
+		return ERR_PTR(-ENOMEM);
+
+	type->kobj.kset = parent->mdev_types_kset;
+
+	ret = kobject_init_and_add(&type->kobj, &mdev_type_ktype, NULL,
+				   "%s-%s", dev_driver_string(parent->dev),
+				   group->name);
+	if (ret) {
+		kfree(type);
+		return ERR_PTR(ret);
+	}
+
+	ret = sysfs_create_file(&type->kobj, &mdev_type_attr_create.attr);
+	if (ret)
+		goto attr_create_failed;
+
+	type->devices_kobj = kobject_create_and_add("devices", &type->kobj);
+	if (!type->devices_kobj) {
+		ret = -ENOMEM;
+		goto attr_devices_failed;
+	}
+
+	ret = sysfs_create_files(&type->kobj,
+				 (const struct attribute **)group->attrs);
+	if (ret) {
+		ret = -ENOMEM;
+		goto attrs_failed;
+	}
+
+	type->group = group;
+	type->parent = parent;
+	return type;
+
+attrs_failed:
+	kobject_put(type->devices_kobj);
+attr_devices_failed:
+	sysfs_remove_file(&type->kobj, &mdev_type_attr_create.attr);
+attr_create_failed:
+	kobject_del(&type->kobj);
+	kobject_put(&type->kobj);
+	return ERR_PTR(ret);
+}
+
+static void remove_mdev_supported_type(struct mdev_type *type)
+{
+	sysfs_remove_files(&type->kobj,
+			   (const struct attribute **)type->group->attrs);
+	kobject_put(type->devices_kobj);
+	sysfs_remove_file(&type->kobj, &mdev_type_attr_create.attr);
+	kobject_del(&type->kobj);
+	kobject_put(&type->kobj);
+}
+
+static int add_mdev_supported_type_groups(struct parent_device *parent)
+{
+	int i;
+
+	for (i = 0; parent->ops->supported_type_groups[i]; i++) {
+		struct mdev_type *type;
+
+		type = add_mdev_supported_type(parent,
+					parent->ops->supported_type_groups[i]);
+		if (IS_ERR(type)) {
+			struct mdev_type *ltype, *tmp;
+
+			list_for_each_entry_safe(ltype, tmp, &parent->type_list,
+						  next) {
+				list_del(&ltype->next);
+				remove_mdev_supported_type(ltype);
+			}
+			return PTR_ERR(type);
+		}
+		list_add(&type->next, &parent->type_list);
+	}
+	return 0;
+}
+
+/* mdev sysfs functions */
+void parent_remove_sysfs_files(struct parent_device *parent)
+{
+	struct mdev_type *type, *tmp;
+
+	list_for_each_entry_safe(type, tmp, &parent->type_list, next) {
+		list_del(&type->next);
+		remove_mdev_supported_type(type);
+	}
+
+	sysfs_remove_groups(&parent->dev->kobj, parent->ops->dev_attr_groups);
+	kset_unregister(parent->mdev_types_kset);
+}
+
+int parent_create_sysfs_files(struct parent_device *parent)
+{
+	int ret;
+
+	parent->mdev_types_kset = kset_create_and_add("mdev_supported_types",
+					       NULL, &parent->dev->kobj);
+
+	if (!parent->mdev_types_kset)
+		return -ENOMEM;
+
+	INIT_LIST_HEAD(&parent->type_list);
+
+	ret = sysfs_create_groups(&parent->dev->kobj,
+				  parent->ops->dev_attr_groups);
+	if (ret)
+		goto create_err;
+
+	ret = add_mdev_supported_type_groups(parent);
+	if (ret)
+		sysfs_remove_groups(&parent->dev->kobj,
+				    parent->ops->dev_attr_groups);
+	else
+		return ret;
+
+create_err:
+	kset_unregister(parent->mdev_types_kset);
+	return ret;
+}
+
+static ssize_t remove_store(struct device *dev, struct device_attribute *attr,
+			    const char *buf, size_t count)
+{
+	unsigned long val;
+
+	if (kstrtoul(buf, 0, &val) < 0)
+		return -EINVAL;
+
+	if (val && device_remove_file_self(dev, attr)) {
+		int ret;
+
+		ret = mdev_device_remove(dev, false);
+		if (ret) {
+			device_create_file(dev, attr);
+			return ret;
+		}
+	}
+
+	return count;
+}
+
+static DEVICE_ATTR_WO(remove);
+
+static const struct attribute *mdev_device_attrs[] = {
+	&dev_attr_remove.attr,
+	NULL,
+};
+
+int  mdev_create_sysfs_files(struct device *dev, struct mdev_type *type)
+{
+	int ret;
+
+	ret = sysfs_create_files(&dev->kobj, mdev_device_attrs);
+	if (ret)
+		return ret;
+
+	ret = sysfs_create_link(type->devices_kobj, &dev->kobj, dev_name(dev));
+	if (ret)
+		goto device_link_failed;
+
+	ret = sysfs_create_link(&dev->kobj, &type->kobj, "mdev_type");
+	if (ret)
+		goto type_link_failed;
+
+	return ret;
+
+type_link_failed:
+	sysfs_remove_link(type->devices_kobj, dev_name(dev));
+device_link_failed:
+	sysfs_remove_files(&dev->kobj, mdev_device_attrs);
+	return ret;
+}
+
+void mdev_remove_sysfs_files(struct device *dev, struct mdev_type *type)
+{
+	sysfs_remove_link(&dev->kobj, "mdev_type");
+	sysfs_remove_link(type->devices_kobj, dev_name(dev));
+	sysfs_remove_files(&dev->kobj, mdev_device_attrs);
+}
