commit 1a59d1b8e05ea6ab45f7e18897de1ef0e6bc3da6
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:05 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 156
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details you
      should have received a copy of the gnu general public license along
      with this program if not write to the free software foundation inc
      59 temple place suite 330 boston ma 02111 1307 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 1334 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070033.113240726@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/mtd/ubi/misc.c b/drivers/mtd/ubi/misc.c
index 989036c681b8..7b30c8ee3e82 100644
--- a/drivers/mtd/ubi/misc.c
+++ b/drivers/mtd/ubi/misc.c
@@ -1,20 +1,7 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * Copyright (c) International Business Machines Corp., 2006
  *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See
- * the GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
- *
  * Author: Artem Bityutskiy (Битюцкий Артём)
  */
 

commit 58d303def2a1fbfb5c794bafe7da54b900d9694e
Author: Joe Perches <joe@perches.com>
Date:   Thu Feb 25 09:25:20 2016 -0800

    mtd: ubi: Add logging functions ubi_msg, ubi_warn and ubi_err
    
    Using logging functions instead of macros can reduce overall object size.
    
    $ size drivers/mtd/ubi/built-in.o*
       text    data     bss     dec     hex filename
     271620  163364   73696  508680   7c308 drivers/mtd/ubi/built-in.o.allyesconfig.new
     287638  165380   73504  526522   808ba drivers/mtd/ubi/built-in.o.allyesconfig.old
      87728    3780     504   92012   1676c drivers/mtd/ubi/built-in.o.defconfig.new
      97084    3780     504  101368   18bf8 drivers/mtd/ubi/built-in.o.defconfig.old
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Richard Weinberger <richard@nod.at>

diff --git a/drivers/mtd/ubi/misc.c b/drivers/mtd/ubi/misc.c
index 2a45ac210b16..989036c681b8 100644
--- a/drivers/mtd/ubi/misc.c
+++ b/drivers/mtd/ubi/misc.c
@@ -153,3 +153,52 @@ int ubi_check_pattern(const void *buf, uint8_t patt, int size)
 			return 0;
 	return 1;
 }
+
+/* Normal UBI messages */
+void ubi_msg(const struct ubi_device *ubi, const char *fmt, ...)
+{
+	struct va_format vaf;
+	va_list args;
+
+	va_start(args, fmt);
+
+	vaf.fmt = fmt;
+	vaf.va = &args;
+
+	pr_notice(UBI_NAME_STR "%d: %pV\n", ubi->ubi_num, &vaf);
+
+	va_end(args);
+}
+
+/* UBI warning messages */
+void ubi_warn(const struct ubi_device *ubi, const char *fmt, ...)
+{
+	struct va_format vaf;
+	va_list args;
+
+	va_start(args, fmt);
+
+	vaf.fmt = fmt;
+	vaf.va = &args;
+
+	pr_warn(UBI_NAME_STR "%d warning: %ps: %pV\n",
+		ubi->ubi_num, __builtin_return_address(0), &vaf);
+
+	va_end(args);
+}
+
+/* UBI error messages */
+void ubi_err(const struct ubi_device *ubi, const char *fmt, ...)
+{
+	struct va_format vaf;
+	va_list args;
+
+	va_start(args, fmt);
+
+	vaf.fmt = fmt;
+	vaf.va = &args;
+
+	pr_err(UBI_NAME_STR "%d error: %ps: %pV\n",
+	       ubi->ubi_num, __builtin_return_address(0), &vaf);
+	va_end(args);
+}

commit 9aa272b492e7551a9ee0e2c83c720ea013698485
Author: hujianyang <hujianyang@huawei.com>
Date:   Tue Dec 30 11:56:09 2014 +0800

    UBI: fix soft lockup in ubi_check_volume()
    
    Running mtd-utils/tests/ubi-tests/io_basic.c could cause
    soft lockup or watchdog reset. It is because *updatevol*
    will perform ubi_check_volume() after updating finish
    and this function will full scan the updated lebs if the
    volume is initialized as STATIC_VOLUME.
    
    This patch adds *cond_resched()* in the loop of lebs scan
    to avoid soft lockup.
    
    Helped by Richard Weinberger <richard@nod.at>
    
    [ 2158.067096] INFO: rcu_sched self-detected stall on CPU { 1}  (t=2101 jiffies g=1606 c=1605 q=56)
    [ 2158.172867] CPU: 1 PID: 2073 Comm: io_basic Tainted: G           O 3.10.53 #21
    [ 2158.172898] [<c000f624>] (unwind_backtrace+0x0/0x120) from [<c000c294>] (show_stack+0x10/0x14)
    [ 2158.172918] [<c000c294>] (show_stack+0x10/0x14) from [<c008ac3c>] (rcu_check_callbacks+0x1c0/0x660)
    [ 2158.172936] [<c008ac3c>] (rcu_check_callbacks+0x1c0/0x660) from [<c002b480>] (update_process_times+0x38/0x64)
    [ 2158.172953] [<c002b480>] (update_process_times+0x38/0x64) from [<c005ff38>] (tick_sched_handle+0x54/0x60)
    [ 2158.172966] [<c005ff38>] (tick_sched_handle+0x54/0x60) from [<c00601ac>] (tick_sched_timer+0x44/0x74)
    [ 2158.172978] [<c00601ac>] (tick_sched_timer+0x44/0x74) from [<c003f348>] (__run_hrtimer+0xc8/0x1b8)
    [ 2158.172992] [<c003f348>] (__run_hrtimer+0xc8/0x1b8) from [<c003fd9c>] (hrtimer_interrupt+0x128/0x2a4)
    [ 2158.173007] [<c003fd9c>] (hrtimer_interrupt+0x128/0x2a4) from [<c0246f1c>] (arch_timer_handler_virt+0x28/0x30)
    [ 2158.173022] [<c0246f1c>] (arch_timer_handler_virt+0x28/0x30) from [<c0086214>] (handle_percpu_devid_irq+0x9c/0x124)
    [ 2158.173036] [<c0086214>] (handle_percpu_devid_irq+0x9c/0x124) from [<c0082bd8>] (generic_handle_irq+0x20/0x30)
    [ 2158.173049] [<c0082bd8>] (generic_handle_irq+0x20/0x30) from [<c000969c>] (handle_IRQ+0x64/0x8c)
    [ 2158.173060] [<c000969c>] (handle_IRQ+0x64/0x8c) from [<c0008544>] (gic_handle_irq+0x3c/0x60)
    [ 2158.173074] [<c0008544>] (gic_handle_irq+0x3c/0x60) from [<c02f0f80>] (__irq_svc+0x40/0x50)
    [ 2158.173083] Exception stack(0xc4043c98 to 0xc4043ce0)
    [ 2158.173092] 3c80:                                                       c4043ce4 00000019
    [ 2158.173102] 3ca0: 1f8a865f c050ad10 1f8a864c 00000031 c04b5970 0003ebce 00000000 f3550000
    [ 2158.173113] 3cc0: bf00bc68 00000800 0003ebce c4043ce0 c0186d14 c0186cb8 80000013 ffffffff
    [ 2158.173130] [<c02f0f80>] (__irq_svc+0x40/0x50) from [<c0186cb8>] (read_current_timer+0x4/0x38)
    [ 2158.173145] [<c0186cb8>] (read_current_timer+0x4/0x38) from [<1f8a865f>] (0x1f8a865f)
    [ 2183.927097] BUG: soft lockup - CPU#1 stuck for 22s! [io_basic:2073]
    [ 2184.002229] Modules linked in: nandflash(O) [last unloaded: nandflash]
    
    Signed-off-by: Wang Kai <morgan.wang@huawei.com>
    Signed-off-by: hujianyang <hujianyang@huawei.com>
    Signed-off-by: Richard Weinberger <richard@nod.at>

diff --git a/drivers/mtd/ubi/misc.c b/drivers/mtd/ubi/misc.c
index dbda77e556cb..2a45ac210b16 100644
--- a/drivers/mtd/ubi/misc.c
+++ b/drivers/mtd/ubi/misc.c
@@ -74,6 +74,8 @@ int ubi_check_volume(struct ubi_device *ubi, int vol_id)
 	for (i = 0; i < vol->used_ebs; i++) {
 		int size;
 
+		cond_resched();
+
 		if (i == vol->used_ebs - 1)
 			size = vol->last_eb_bytes;
 		else

commit 326087033108e7806e24974f2c8271f95cddaf3a
Author: Tanya Brokhman <tlinder@codeaurora.org>
Date:   Mon Oct 20 19:57:00 2014 +0300

    UBI: Extend UBI layer debug/messaging capabilities
    
    If there is more then one UBI device mounted, there is no way to
    distinguish between messages from different UBI devices.
    Add device number to all ubi layer message types.
    
    The R/O block driver messages were replaced by pr_* since
    ubi_device structure is not used by it.
    
    Amended a bit by Artem.
    
    Signed-off-by: Tanya Brokhman <tlinder@codeaurora.org>
    Signed-off-by: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>

diff --git a/drivers/mtd/ubi/misc.c b/drivers/mtd/ubi/misc.c
index f913d701a5b3..dbda77e556cb 100644
--- a/drivers/mtd/ubi/misc.c
+++ b/drivers/mtd/ubi/misc.c
@@ -111,7 +111,7 @@ void ubi_update_reserved(struct ubi_device *ubi)
 	ubi->avail_pebs -= need;
 	ubi->rsvd_pebs += need;
 	ubi->beb_rsvd_pebs += need;
-	ubi_msg("reserved more %d PEBs for bad PEB handling", need);
+	ubi_msg(ubi, "reserved more %d PEBs for bad PEB handling", need);
 }
 
 /**
@@ -128,7 +128,7 @@ void ubi_calculate_reserved(struct ubi_device *ubi)
 	ubi->beb_rsvd_level = ubi->bad_peb_limit - ubi->bad_peb_count;
 	if (ubi->beb_rsvd_level < 0) {
 		ubi->beb_rsvd_level = 0;
-		ubi_warn("number of bad PEBs (%d) is above the expected limit (%d), not reserving any PEBs for bad PEB handling, will use available PEBs (if any)",
+		ubi_warn(ubi, "number of bad PEBs (%d) is above the expected limit (%d), not reserving any PEBs for bad PEB handling, will use available PEBs (if any)",
 			 ubi->bad_peb_count, ubi->bad_peb_limit);
 	}
 }

commit 049333cecbde11988c49ad4d7861eefbc3534422
Author: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
Date:   Mon Aug 27 14:43:54 2012 +0300

    UBI: comply with coding style
    
    Join all the split printk lines in order to stop checkpatch complaining.
    
    Signed-off-by: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>

diff --git a/drivers/mtd/ubi/misc.c b/drivers/mtd/ubi/misc.c
index d089df055484..f913d701a5b3 100644
--- a/drivers/mtd/ubi/misc.c
+++ b/drivers/mtd/ubi/misc.c
@@ -128,9 +128,7 @@ void ubi_calculate_reserved(struct ubi_device *ubi)
 	ubi->beb_rsvd_level = ubi->bad_peb_limit - ubi->bad_peb_count;
 	if (ubi->beb_rsvd_level < 0) {
 		ubi->beb_rsvd_level = 0;
-		ubi_warn("number of bad PEBs (%d) is above the expected limit "
-			 "(%d), not reserving any PEBs for bad PEB handling, "
-			 "will use available PEBs (if any)",
+		ubi_warn("number of bad PEBs (%d) is above the expected limit (%d), not reserving any PEBs for bad PEB handling, will use available PEBs (if any)",
 			 ubi->bad_peb_count, ubi->bad_peb_limit);
 	}
 }

commit 37f758a036da56c7cff81b68d1d872752079eb6c
Author: Shmulik Ladkani <shmulik.ladkani@gmail.com>
Date:   Wed Jul 4 11:06:01 2012 +0300

    UBI: limit amount of reserved eraseblocks for bad PEB handling
    
    The existing mechanism of reserving PEBs for bad PEB handling has two
    flaws:
    - It is calculated as a percentage of good PEBs instead of total PEBs.
    - There's no limit on the amount of PEBs UBI reserves for future bad
      eraseblock handling.
    
    This patch changes the mechanism to overcome these flaws.
    
    The desired level of PEBs reserved for bad PEB handling (beb_rsvd_level)
    is set to the maximum expected bad eraseblocks (bad_peb_limit) minus the
    existing number of bad eraseblocks (bad_peb_count).
    
    The actual amount of PEBs reserved for bad PEB handling is usually set
    to the desired level (but in some circumstances may be lower than the
    desired level, e.g. when attaching to a device that has too few
    available PEBs to satisfy the desired level).
    
    In the case where the device has too many bad PEBs (above the expected
    limit), then the desired level, and the actual amount of PEBs reserved
    are set to zero. No PEBs will be set aside for future bad eraseblock
    handling - even if some PEBs are made available (e.g. by shrinking a
    volume).
    If another PEB goes bad, and there are available PEBs, then the
    eraseblock will be marked bad (consuming one available PEB). But if
    there are no available PEBs, ubi will go into readonly mode.
    
    Signed-off-by: Shmulik Ladkani <shmulik.ladkani@gmail.com>

diff --git a/drivers/mtd/ubi/misc.c b/drivers/mtd/ubi/misc.c
index 8bbfb444b895..d089df055484 100644
--- a/drivers/mtd/ubi/misc.c
+++ b/drivers/mtd/ubi/misc.c
@@ -121,10 +121,18 @@ void ubi_update_reserved(struct ubi_device *ubi)
  */
 void ubi_calculate_reserved(struct ubi_device *ubi)
 {
-	ubi->beb_rsvd_level = ubi->good_peb_count/100;
-	ubi->beb_rsvd_level *= CONFIG_MTD_UBI_BEB_RESERVE;
-	if (ubi->beb_rsvd_level < MIN_RESEVED_PEBS)
-		ubi->beb_rsvd_level = MIN_RESEVED_PEBS;
+	/*
+	 * Calculate the actual number of PEBs currently needed to be reserved
+	 * for future bad eraseblock handling.
+	 */
+	ubi->beb_rsvd_level = ubi->bad_peb_limit - ubi->bad_peb_count;
+	if (ubi->beb_rsvd_level < 0) {
+		ubi->beb_rsvd_level = 0;
+		ubi_warn("number of bad PEBs (%d) is above the expected limit "
+			 "(%d), not reserving any PEBs for bad PEB handling, "
+			 "will use available PEBs (if any)",
+			 ubi->bad_peb_count, ubi->bad_peb_limit);
+	}
 }
 
 /**

commit 87e773c95eb0b363f2efcc7aff8a347dc18925d0
Author: Shmulik Ladkani <shmulik.ladkani@gmail.com>
Date:   Wed Jul 4 11:06:04 2012 +0300

    UBI: harmonize the update of ubi->beb_rsvd_pebs
    
    Currently, there are several locations where an attempt to reserve more
    PEBs for bad PEB handling is made, with the same code being duplicated.
    
    Harmonize it by introducing 'ubi_update_reserved()'.
    
    Also, improve the debug message issued, making it more descriptive.
    
    Artem: amended the patch a little.
    
    Signed-off-by: Shmulik Ladkani <shmulik.ladkani@gmail.com>
    Signed-off-by: Artem Bityutskiy <Artem.Bityutskiy@linux.intel.com>

diff --git a/drivers/mtd/ubi/misc.c b/drivers/mtd/ubi/misc.c
index b57134d1bdee..8bbfb444b895 100644
--- a/drivers/mtd/ubi/misc.c
+++ b/drivers/mtd/ubi/misc.c
@@ -91,6 +91,29 @@ int ubi_check_volume(struct ubi_device *ubi, int vol_id)
 	return err;
 }
 
+/**
+ * ubi_update_reserved - update bad eraseblock handling accounting data.
+ * @ubi: UBI device description object
+ *
+ * This function calculates the gap between current number of PEBs reserved for
+ * bad eraseblock handling and the required level of PEBs that must be
+ * reserved, and if necessary, reserves more PEBs to fill that gap, according
+ * to availability. Should be called with ubi->volumes_lock held.
+ */
+void ubi_update_reserved(struct ubi_device *ubi)
+{
+	int need = ubi->beb_rsvd_level - ubi->beb_rsvd_pebs;
+
+	if (need <= 0 || ubi->avail_pebs == 0)
+		return;
+
+	need = min_t(int, need, ubi->avail_pebs);
+	ubi->avail_pebs -= need;
+	ubi->rsvd_pebs += need;
+	ubi->beb_rsvd_pebs += need;
+	ubi_msg("reserved more %d PEBs for bad PEB handling", need);
+}
+
 /**
  * ubi_calculate_reserved - calculate how many PEBs must be reserved for bad
  * eraseblock handling.

commit 5c669a5bd8c0f0567127128990d01f9ae320a9ef
Author: Shmulik Ladkani <shmulik.ladkani@gmail.com>
Date:   Wed Jul 4 11:06:03 2012 +0300

    UBI: trivial: fix comment of ubi_calculate_reserved function
    
    The function name within the comment was not aligned with the actual
    function name.
    
    Signed-off-by: Shmulik Ladkani <shmulik.ladkani@gmail.com>
    Signed-off-by: Artem Bityutskiy <Artem.Bityutskiy@linux.intel.com>

diff --git a/drivers/mtd/ubi/misc.c b/drivers/mtd/ubi/misc.c
index f6a7d7ac4b98..b57134d1bdee 100644
--- a/drivers/mtd/ubi/misc.c
+++ b/drivers/mtd/ubi/misc.c
@@ -92,7 +92,7 @@ int ubi_check_volume(struct ubi_device *ubi, int vol_id)
 }
 
 /**
- * ubi_calculate_rsvd_pool - calculate how many PEBs must be reserved for bad
+ * ubi_calculate_reserved - calculate how many PEBs must be reserved for bad
  * eraseblock handling.
  * @ubi: UBI device description object
  */

commit d57f40544a41fdfe90fd863b6865138c5a82f1cc
Author: Brian Norris <computersforpeace@gmail.com>
Date:   Tue Sep 20 18:34:25 2011 -0700

    mtd: utilize `mtd_is_*()' functions
    
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>
    Signed-off-by: Artem Bityutskiy <artem.bityutskiy@intel.com>

diff --git a/drivers/mtd/ubi/misc.c b/drivers/mtd/ubi/misc.c
index ff2a65c37f69..f6a7d7ac4b98 100644
--- a/drivers/mtd/ubi/misc.c
+++ b/drivers/mtd/ubi/misc.c
@@ -81,7 +81,7 @@ int ubi_check_volume(struct ubi_device *ubi, int vol_id)
 
 		err = ubi_eba_read_leb(ubi, vol, i, buf, 0, size, 1);
 		if (err) {
-			if (err == -EBADMSG)
+			if (mtd_is_eccerr(err))
 				err = 1;
 			break;
 		}

commit bb00e180a93a6c8e89c3b2d1f9473781e1e2d2a4
Author: Artem Bityutskiy <Artem.Bityutskiy@nokia.com>
Date:   Sat Jul 31 09:37:34 2010 +0300

    UBI: make check_pattern function non-static
    
    This patch turns static function 'check_pattern()' into a non-static
    'ubi_check_pattern()'. This is just a preparation for the chages which
    are coming in the next patches.
    
    Signed-off-by: Artem Bityutskiy <Artem.Bityutskiy@nokia.com>

diff --git a/drivers/mtd/ubi/misc.c b/drivers/mtd/ubi/misc.c
index 22ad31402945..ff2a65c37f69 100644
--- a/drivers/mtd/ubi/misc.c
+++ b/drivers/mtd/ubi/misc.c
@@ -103,3 +103,22 @@ void ubi_calculate_reserved(struct ubi_device *ubi)
 	if (ubi->beb_rsvd_level < MIN_RESEVED_PEBS)
 		ubi->beb_rsvd_level = MIN_RESEVED_PEBS;
 }
+
+/**
+ * ubi_check_pattern - check if buffer contains only a certain byte pattern.
+ * @buf: buffer to check
+ * @patt: the pattern to check
+ * @size: buffer size in bytes
+ *
+ * This function returns %1 in there are only @patt bytes in @buf, and %0 if
+ * something else was also found.
+ */
+int ubi_check_pattern(const void *buf, uint8_t patt, int size)
+{
+	int i;
+
+	for (i = 0; i < size; i++)
+		if (((const uint8_t *)buf)[i] != patt)
+			return 0;
+	return 1;
+}

commit cadb40ccc16a26a738f1cbc963e35b21edd93e79
Author: Kyungmin Park <kyungmin.park@samsung.com>
Date:   Thu May 22 10:32:18 2008 +0900

    UBI: avoid unnecessary division operations
    
    UBI already checks that @min io size is the power of 2 at io_init.
    It is save to use bit operations then.
    
    Signed-off-by: Kyungmin Park <kyungmin.park@samsung.com>
    Signed-off-by: Artem Bityutskiy <Artem.Bityutskiy@nokia.com>

diff --git a/drivers/mtd/ubi/misc.c b/drivers/mtd/ubi/misc.c
index 93e052812012..22ad31402945 100644
--- a/drivers/mtd/ubi/misc.c
+++ b/drivers/mtd/ubi/misc.c
@@ -37,7 +37,7 @@ int ubi_calc_data_len(const struct ubi_device *ubi, const void *buf,
 {
 	int i;
 
-	ubi_assert(length % ubi->min_io_size == 0);
+	ubi_assert(!(length & (ubi->min_io_size - 1)));
 
 	for (i = length - 1; i >= 0; i--)
 		if (((const uint8_t *)buf)[i] != 0xFF)

commit 89b96b69290668351a33b09372ec1c94cb5748e5
Author: Artem Bityutskiy <Artem.Bityutskiy@nokia.com>
Date:   Sun Dec 16 20:00:38 2007 +0200

    UBI: improve internal interfaces
    
    Pass volume description object to the EBA function which makes
    more sense, and EBA function do not have to find the volume
    description object by volume ID.
    
    Signed-off-by: Artem Bityutskiy <Artem.Bityutskiy@nokia.com>

diff --git a/drivers/mtd/ubi/misc.c b/drivers/mtd/ubi/misc.c
index 9e2338c8e2cf..93e052812012 100644
--- a/drivers/mtd/ubi/misc.c
+++ b/drivers/mtd/ubi/misc.c
@@ -79,7 +79,7 @@ int ubi_check_volume(struct ubi_device *ubi, int vol_id)
 		else
 			size = vol->usable_leb_size;
 
-		err = ubi_eba_read_leb(ubi, vol_id, i, buf, 0, size, 1);
+		err = ubi_eba_read_leb(ubi, vol, i, buf, 0, size, 1);
 		if (err) {
 			if (err == -EBADMSG)
 				err = 1;

commit 92ad8f37509a7d9d5dd6e0092211b092a7ca7fb1
Author: Artem Bityutskiy <Artem.Bityutskiy@nokia.com>
Date:   Sun May 6 16:12:54 2007 +0300

    UBI: use vmalloc for large buffers
    
    UBI allocates temporary buffers of PEB size, which may be 256KiB.
    Use vmalloc instead of kmalloc for such big temporary buffers.
    
    Signed-off-by: Artem Bityutskiy <Artem.Bityutskiy@nokia.com>

diff --git a/drivers/mtd/ubi/misc.c b/drivers/mtd/ubi/misc.c
index 38d4e6757dc7..9e2338c8e2cf 100644
--- a/drivers/mtd/ubi/misc.c
+++ b/drivers/mtd/ubi/misc.c
@@ -67,7 +67,7 @@ int ubi_check_volume(struct ubi_device *ubi, int vol_id)
 	if (vol->vol_type != UBI_STATIC_VOLUME)
 		return 0;
 
-	buf = kmalloc(vol->usable_leb_size, GFP_KERNEL);
+	buf = vmalloc(vol->usable_leb_size);
 	if (!buf)
 		return -ENOMEM;
 
@@ -87,7 +87,7 @@ int ubi_check_volume(struct ubi_device *ubi, int vol_id)
 		}
 	}
 
-	kfree(buf);
+	vfree(buf);
 	return err;
 }
 

commit 801c135ce73d5df1caf3eca35b66a10824ae0707
Author: Artem B. Bityutskiy <dedekind@linutronix.de>
Date:   Tue Jun 27 12:22:22 2006 +0400

    UBI: Unsorted Block Images
    
    UBI (Latin: "where?") manages multiple logical volumes on a single
    flash device, specifically supporting NAND flash devices. UBI provides
    a flexible partitioning concept which still allows for wear-levelling
    across the whole flash device.
    
    In a sense, UBI may be compared to the Logical Volume Manager
    (LVM). Whereas LVM maps logical sector numbers to physical HDD sector
    numbers, UBI maps logical eraseblocks to physical eraseblocks.
    
    More information may be found at
    http://www.linux-mtd.infradead.org/doc/ubi.html
    
    Partitioning/Re-partitioning
    
      An UBI volume occupies a certain number of erase blocks. This is
      limited by a configured maximum volume size, which could also be
      viewed as the partition size. Each individual UBI volume's size can
      be changed independently of the other UBI volumes, provided that the
      sum of all volume sizes doesn't exceed a certain limit.
    
      UBI supports dynamic volumes and static volumes. Static volumes are
      read-only and their contents are protected by CRC check sums.
    
    Bad eraseblocks handling
    
      UBI transparently handles bad eraseblocks. When a physical
      eraseblock becomes bad, it is substituted by a good physical
      eraseblock, and the user does not even notice this.
    
    Scrubbing
    
      On a NAND flash bit flips can occur on any write operation,
      sometimes also on read. If bit flips persist on the device, at first
      they can still be corrected by ECC, but once they accumulate,
      correction will become impossible. Thus it is best to actively scrub
      the affected eraseblock, by first copying it to a free eraseblock
      and then erasing the original. The UBI layer performs this type of
      scrubbing under the covers, transparently to the UBI volume users.
    
    Erase Counts
    
      UBI maintains an erase count header per eraseblock. This frees
      higher-level layers (like file systems) from doing this and allows
      for centralized erase count management instead. The erase counts are
      used by the wear-levelling algorithm in the UBI layer. The algorithm
      itself is exchangeable.
    
    Booting from NAND
    
      For booting directly from NAND flash the hardware must at least be
      capable of fetching and executing a small portion of the NAND
      flash. Some NAND flash controllers have this kind of support. They
      usually limit the window to a few kilobytes in erase block 0. This
      "initial program loader" (IPL) must then contain sufficient logic to
      load and execute the next boot phase.
    
      Due to bad eraseblocks, which may be randomly scattered over the
      flash device, it is problematic to store the "secondary program
      loader" (SPL) statically. Also, due to bit-flips it may become
      corrupted over time. UBI allows to solve this problem gracefully by
      storing the SPL in a small static UBI volume.
    
    UBI volumes vs. static partitions
    
      UBI volumes are still very similar to static MTD partitions:
    
        * both consist of eraseblocks (logical eraseblocks in case of UBI
          volumes, and physical eraseblocks in case of static partitions;
        * both support three basic operations - read, write, erase.
    
      But UBI volumes have the following advantages over traditional
      static MTD partitions:
    
        * there are no eraseblock wear-leveling constraints in case of UBI
          volumes, so the user should not care about this;
        * there are no bit-flips and bad eraseblocks in case of UBI volumes.
    
      So, UBI volumes may be considered as flash devices with relaxed
      restrictions.
    
    Where can it be found?
    
      Documentation, kernel code and applications can be found in the MTD
      gits.
    
    What are the applications for?
    
      The applications help to create binary flash images for two purposes: pfi
      files (partial flash images) for in-system update of UBI volumes, and plain
      binary images, with or without OOB data in case of NAND, for a manufacturing
      step. Furthermore some tools are/and will be created that allow flash content
      analysis after a system has crashed..
    
    Who did UBI?
    
      The original ideas, where UBI is based on, were developed by Andreas
      Arnez, Frank Haverkamp and Thomas Gleixner. Josh W. Boyer and some others
      were involved too. The implementation of the kernel layer was done by Artem
      B. Bityutskiy. The user-space applications and tools were written by Oliver
      Lohmann with contributions from Frank Haverkamp, Andreas Arnez, and Artem.
      Joern Engel contributed a patch which modifies JFFS2 so that it can be run on
      a UBI volume. Thomas Gleixner did modifications to the NAND layer. Alexander
      Schmidt made some testing work as well as core functionality improvements.
    
    Signed-off-by: Artem B. Bityutskiy <dedekind@linutronix.de>
    Signed-off-by: Frank Haverkamp <haver@vnet.ibm.com>

diff --git a/drivers/mtd/ubi/misc.c b/drivers/mtd/ubi/misc.c
new file mode 100644
index 000000000000..38d4e6757dc7
--- /dev/null
+++ b/drivers/mtd/ubi/misc.c
@@ -0,0 +1,105 @@
+/*
+ * Copyright (c) International Business Machines Corp., 2006
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See
+ * the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ * Author: Artem Bityutskiy (Битюцкий Артём)
+ */
+
+/* Here we keep miscellaneous functions which are used all over the UBI code */
+
+#include "ubi.h"
+
+/**
+ * calc_data_len - calculate how much real data is stored in a buffer.
+ * @ubi: UBI device description object
+ * @buf: a buffer with the contents of the physical eraseblock
+ * @length: the buffer length
+ *
+ * This function calculates how much "real data" is stored in @buf and returnes
+ * the length. Continuous 0xFF bytes at the end of the buffer are not
+ * considered as "real data".
+ */
+int ubi_calc_data_len(const struct ubi_device *ubi, const void *buf,
+		      int length)
+{
+	int i;
+
+	ubi_assert(length % ubi->min_io_size == 0);
+
+	for (i = length - 1; i >= 0; i--)
+		if (((const uint8_t *)buf)[i] != 0xFF)
+			break;
+
+	/* The resulting length must be aligned to the minimum flash I/O size */
+	length = ALIGN(i + 1, ubi->min_io_size);
+	return length;
+}
+
+/**
+ * ubi_check_volume - check the contents of a static volume.
+ * @ubi: UBI device description object
+ * @vol_id: ID of the volume to check
+ *
+ * This function checks if static volume @vol_id is corrupted by fully reading
+ * it and checking data CRC. This function returns %0 if the volume is not
+ * corrupted, %1 if it is corrupted and a negative error code in case of
+ * failure. Dynamic volumes are not checked and zero is returned immediately.
+ */
+int ubi_check_volume(struct ubi_device *ubi, int vol_id)
+{
+	void *buf;
+	int err = 0, i;
+	struct ubi_volume *vol = ubi->volumes[vol_id];
+
+	if (vol->vol_type != UBI_STATIC_VOLUME)
+		return 0;
+
+	buf = kmalloc(vol->usable_leb_size, GFP_KERNEL);
+	if (!buf)
+		return -ENOMEM;
+
+	for (i = 0; i < vol->used_ebs; i++) {
+		int size;
+
+		if (i == vol->used_ebs - 1)
+			size = vol->last_eb_bytes;
+		else
+			size = vol->usable_leb_size;
+
+		err = ubi_eba_read_leb(ubi, vol_id, i, buf, 0, size, 1);
+		if (err) {
+			if (err == -EBADMSG)
+				err = 1;
+			break;
+		}
+	}
+
+	kfree(buf);
+	return err;
+}
+
+/**
+ * ubi_calculate_rsvd_pool - calculate how many PEBs must be reserved for bad
+ * eraseblock handling.
+ * @ubi: UBI device description object
+ */
+void ubi_calculate_reserved(struct ubi_device *ubi)
+{
+	ubi->beb_rsvd_level = ubi->good_peb_count/100;
+	ubi->beb_rsvd_level *= CONFIG_MTD_UBI_BEB_RESERVE;
+	if (ubi->beb_rsvd_level < MIN_RESEVED_PEBS)
+		ubi->beb_rsvd_level = MIN_RESEVED_PEBS;
+}
