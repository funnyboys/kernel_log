commit 630e8d5507d9f55dfa98134bfcadefb6cfba4fbb
Author: Kamal Dasu <kdasu.kdev@gmail.com>
Date:   Mon Jun 15 11:51:34 2020 -0400

    mtd: set master partition panic write flag
    
    Check and set master panic write flag so that low level drivers
    can use it to take required action to ensure oops data gets written
    to assigned mtdoops device partition.
    
    Fixes: 9f897bfdd89f ("mtd: Add flag to indicate panic_write")
    Signed-off-by: Kamal Dasu <kdasu.kdev@gmail.com>
    Signed-off-by: Miquel Raynal <miquel.raynal@bootlin.com>
    Link: https://lore.kernel.org/linux-mtd/20200615155134.32007-1-kdasu.kdev@gmail.com

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index 76d832a88e0c..7d930569a7df 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -1273,8 +1273,8 @@ int mtd_panic_write(struct mtd_info *mtd, loff_t to, size_t len, size_t *retlen,
 		return -EROFS;
 	if (!len)
 		return 0;
-	if (!mtd->oops_panic_write)
-		mtd->oops_panic_write = true;
+	if (!master->oops_panic_write)
+		master->oops_panic_write = true;
 
 	return master->_panic_write(master, mtd_get_master_ofs(mtd, to), len,
 				    retlen, buf);

commit 6f51ab9440d131ae424cce27e3170746219f5142
Merge: 6f630784cc0d 5788ccf3c84f
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Jun 10 13:15:17 2020 -0700

    Merge tag 'mtd/for-5.8' of git://git.kernel.org/pub/scm/linux/kernel/git/mtd/linux
    
    Pull MTD updates from Richard Weinberger:
     "MTD core changes:
       - partition parser: Support MTD names containing one or more colons.
       - mtdblock: clear cache_state to avoid writing to bad blocks
         repeatedly.
    
      Raw NAND core changes:
       - Stop using nand_release(), patched all drivers.
       - Give more information about the ECC weakness when not matching the
         chip's requirement.
       - MAINTAINERS updates.
       - Support emulated SLC mode on MLC NANDs.
       - Support "constrained" controllers, adapt the core and ONFI/JEDEC
         table parsing and Micron's code.
       - Take check_only into account.
       - Add an invalid ECC mode to discriminate with valid ones.
       - Return an enum from of_get_nand_ecc_algo().
       - Drop OOB_FIRST placement scheme.
       - Introduce nand_extract_bits().
       - Ensure a consistent bitflips numbering.
       - BCH lib:
          - Allow easy bit swapping.
          - Rework a little bit the exported function names.
       - Fix nand_gpio_waitrdy().
       - Propage CS selection to sub operations.
       - Add a NAND_NO_BBM_QUIRK flag.
       - Give the possibility to verify a read operation is supported.
       - Add a helper to check supported operations.
       - Avoid indirect access to ->data_buf().
       - Rename the use_bufpoi variables.
       - Fix comments about the use of bufpoi.
       - Rename a NAND chip option.
       - Reorder the nand_chip->options flags.
       - Translate obscure bitfields into readable macros.
       - Timings:
          - Fix default values.
          - Add mode information to the timings structure.
    
      Raw NAND controller driver changes:
       - Fixed many error paths.
       - Arasan
          - New driver
       - Au1550nd:
          - Various cleanups
          - Migration to ->exec_op()
       - brcmnand:
          - Misc cleanup.
          - Support v2.1-v2.2 controllers.
          - Remove unused including <linux/version.h>.
          - Correctly verify erased pages.
          - Fix Hamming OOB layout.
       - Cadence
          - Make cadence_nand_attach_chip static.
       - Cafe:
          - Set the NAND_NO_BBM_QUIRK flag
       - cmx270:
          - Remove this controller driver.
       - cs553x:
          - Misc cleanup
          - Migration to ->exec_op()
       - Davinci:
          - Misc cleanup.
          - Migration to ->exec_op()
       - Denali:
          - Add more delays before latching incoming data
       - Diskonchip:
          - Misc cleanup
          - Migration to ->exec_op()
       - Fsmc:
          - Change to non-atomic bit operations.
       - GPMI:
          - Use nand_extract_bits()
          - Fix runtime PM imbalance.
       - Ingenic:
          - Migration to exec_op()
          - Fix the RB gpio active-high property on qi, lb60
          - Make qi_lb60_ooblayout_ops static.
       - Marvell:
          - Misc cleanup and small fixes
       - Nandsim:
          - Fix the error paths, driver wide.
       - Omap_elm:
          - Fix runtime PM imbalance.
       - STM32_FMC2:
          - Misc cleanups (error cases, comments, timeout valus, cosmetic
            changes).
    
      SPI NOR core changes:
       - Add, update support and fix few flashes.
       - Prepare BFPT parsing for JESD216 rev D.
       - Kernel doc fixes.
    
      CFI changes:
       - Support the absence of protection registers for Intel CFI flashes.
       - Replace zero-length array with flexible-arrays"
    
    * tag 'mtd/for-5.8' of git://git.kernel.org/pub/scm/linux/kernel/git/mtd/linux: (208 commits)
      mtd: clear cache_state to avoid writing to bad blocks repeatedly
      mtd: parser: cmdline: Support MTD names containing one or more colons
      mtd: physmap_of_gemini: remove defined but not used symbol 'syscon_match'
      mtd: rawnand: Add an invalid ECC mode to discriminate with valid ones
      mtd: rawnand: Return an enum from of_get_nand_ecc_algo()
      mtd: rawnand: Drop OOB_FIRST placement scheme
      mtd: rawnand: Avoid a typedef
      mtd: Fix typo in mtd_ooblayout_set_databytes() description
      mtd: rawnand: Stop using nand_release()
      mtd: rawnand: nandsim: Reorganize ns_cleanup_module()
      mtd: rawnand: nandsim: Rename a label in ns_init_module()
      mtd: rawnand: nandsim: Manage lists on error in ns_init_module()
      mtd: rawnand: nandsim: Fix the label pointing on nand_cleanup()
      mtd: rawnand: nandsim: Free erase_block_wear on error
      mtd: rawnand: nandsim: Use an additional label when freeing the nandsim object
      mtd: rawnand: nandsim: Stop using nand_release()
      mtd: rawnand: nandsim: Free the partition names in ns_free()
      mtd: rawnand: nandsim: Free the allocated device on error in ns_init()
      mtd: rawnand: nandsim: Free partition names on error in ns_init()
      mtd: rawnand: nandsim: Fix the two ns_alloc_device() error paths
      ...

commit 750a02ab8d3c49ca7d23102be90d3d1db19e2827
Merge: 1966391fa576 abb30460bda2
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Jun 2 15:29:19 2020 -0700

    Merge tag 'for-5.8/block-2020-06-01' of git://git.kernel.dk/linux-block
    
    Pull block updates from Jens Axboe:
     "Core block changes that have been queued up for this release:
    
       - Remove dead blk-throttle and blk-wbt code (Guoqing)
    
       - Include pid in blktrace note traces (Jan)
    
       - Don't spew I/O errors on wouldblock termination (me)
    
       - Zone append addition (Johannes, Keith, Damien)
    
       - IO accounting improvements (Konstantin, Christoph)
    
       - blk-mq hardware map update improvements (Ming)
    
       - Scheduler dispatch improvement (Salman)
    
       - Inline block encryption support (Satya)
    
       - Request map fixes and improvements (Weiping)
    
       - blk-iocost tweaks (Tejun)
    
       - Fix for timeout failing with error injection (Keith)
    
       - Queue re-run fixes (Douglas)
    
       - CPU hotplug improvements (Christoph)
    
       - Queue entry/exit improvements (Christoph)
    
       - Move DMA drain handling to the few drivers that use it (Christoph)
    
       - Partition handling cleanups (Christoph)"
    
    * tag 'for-5.8/block-2020-06-01' of git://git.kernel.dk/linux-block: (127 commits)
      block: mark bio_wouldblock_error() bio with BIO_QUIET
      blk-wbt: rename __wbt_update_limits to wbt_update_limits
      blk-wbt: remove wbt_update_limits
      blk-throttle: remove tg_drain_bios
      blk-throttle: remove blk_throtl_drain
      null_blk: force complete for timeout request
      blk-mq: drain I/O when all CPUs in a hctx are offline
      blk-mq: add blk_mq_all_tag_iter
      blk-mq: open code __blk_mq_alloc_request in blk_mq_alloc_request_hctx
      blk-mq: use BLK_MQ_NO_TAG in more places
      blk-mq: rename BLK_MQ_TAG_FAIL to BLK_MQ_NO_TAG
      blk-mq: move more request initialization to blk_mq_rq_ctx_init
      blk-mq: simplify the blk_mq_get_request calling convention
      blk-mq: remove the bio argument to ->prepare_request
      nvme: force complete cancelled requests
      blk-mq: blk-mq: provide forced completion method
      block: fix a warning when blkdev.h is included for !CONFIG_BLOCK builds
      block: blk-crypto-fallback: remove redundant initialization of variable err
      block: reduce part_stat_lock() scope
      block: use __this_cpu_add() instead of access by smp_processor_id()
      ...

commit a8dfb61d6349b7b7173ec6829b920449239c472f
Merge: 3d77e6a8804a 86f2b225adf4
Author: Richard Weinberger <richard@nod.at>
Date:   Mon Jun 1 19:50:58 2020 +0200

    Merge tag 'nand/for-5.8' of git://git.kernel.org/pub/scm/linux/kernel/git/mtd/linux into mtd/next
    
    Raw NAND core changes:
    * Stop using nand_release(), patched all drivers.
    * Give more information about the ECC weakness when not matching the
      chip's requirement.
    * MAINTAINERS updates.
    * Support emulated SLC mode on MLC NANDs.
    * Support "constrained" controllers, adapt the core and ONFI/JEDEC
      table parsing and Micron's code.
    * Take check_only into account.
    * Add an invalid ECC mode to discriminate with valid ones.
    * Return an enum from of_get_nand_ecc_algo().
    * Drop OOB_FIRST placement scheme.
    * Introduce nand_extract_bits().
    * Ensure a consistent bitflips numbering.
    * BCH lib:
      - Allow easy bit swapping.
      - Rework a little bit the exported function names.
    * Fix nand_gpio_waitrdy().
    * Propage CS selection to sub operations.
    * Add a NAND_NO_BBM_QUIRK flag.
    * Give the possibility to verify a read operation is supported.
    * Add a helper to check supported operations.
    * Avoid indirect access to ->data_buf().
    * Rename the use_bufpoi variables.
    * Fix comments about the use of bufpoi.
    * Rename a NAND chip option.
    * Reorder the nand_chip->options flags.
    * Translate obscure bitfields into readable macros.
    * Timings:
      - Fix default values.
      - Add mode information to the timings structure.
    
    Raw NAND controller driver changes:
    * Fixed many error paths.
    * Arasan
      - New driver
    * Au1550nd:
      - Various cleanups
      - Migration to ->exec_op()
    * brcmnand:
      - Misc cleanup.
      - Support v2.1-v2.2 controllers.
      - Remove unused including <linux/version.h>.
      - Correctly verify erased pages.
      - Fix Hamming OOB layout.
    * Cadence
      - Make cadence_nand_attach_chip static.
    * Cafe:
      - Set the NAND_NO_BBM_QUIRK flag
    * cmx270:
      - Remove this controller driver.
    * cs553x:
      - Misc cleanup
      - Migration to ->exec_op()
    * Davinci:
      - Misc cleanup.
      - Migration to ->exec_op()
    * Denali:
      - Add more delays before latching incoming data
    * Diskonchip:
       - Misc cleanup
       - Migration to ->exec_op()
    * Fsmc:
      - Change to non-atomic bit operations.
    * GPMI:
      - Use nand_extract_bits()
      - Fix runtime PM imbalance.
    * Ingenic:
      - Migration to exec_op()
      - Fix the RB gpio active-high property on qi, lb60
      - Make qi_lb60_ooblayout_ops static.
    * Marvell:
       - Misc cleanup and small fixes
    * Nandsim:
      - Fix the error paths, driver wide.
    * Omap_elm:
      - Fix runtime PM imbalance.
    * STM32_FMC2:
      - Misc cleanups (error cases, comments, timeout valus, cosmetic
        changes).

commit 519494a9afabe68a0a86e4b3e264e3e607193a02
Author: Miquel Raynal <miquel.raynal@bootlin.com>
Date:   Tue May 26 21:56:13 2020 +0200

    mtd: Fix typo in mtd_ooblayout_set_databytes() description
    
    Fix a probable copy/paste error: the function works like
    mtd_ooblayout_set_bytes(), not *_get_bytes().
    
    Signed-off-by: Miquel Raynal <miquel.raynal@bootlin.com>
    Reviewed-by: Boris Brezillon <boris.brezillon@collabora.com>
    Link: https://lore.kernel.org/linux-mtd/20200526195633.11543-2-miquel.raynal@bootlin.com

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index 50437b4ffe76..8c4dcfa49e35 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -1800,7 +1800,7 @@ EXPORT_SYMBOL_GPL(mtd_ooblayout_get_databytes);
  * @start: first ECC byte to set
  * @nbytes: number of ECC bytes to set
  *
- * Works like mtd_ooblayout_get_bytes(), except it acts on free bytes.
+ * Works like mtd_ooblayout_set_bytes(), except it acts on free bytes.
  *
  * Returns zero on success, a negative error code otherwise.
  */

commit 7b01b7239d0dc9832e0d0d23605c1ff047422a2c
Author: Ricardo Ribalda Delgado <ribalda@kernel.org>
Date:   Thu Apr 30 15:17:21 2020 +0200

    mtd: Fix mtd not registered due to nvmem name collision
    
    When the nvmem framework is enabled, a nvmem device is created per mtd
    device/partition.
    
    It is not uncommon that a device can have multiple mtd devices with
    partitions that have the same name. Eg, when there DT overlay is allowed
    and the same device with mtd is attached twice.
    
    Under that circumstances, the mtd fails to register due to a name
    duplication on the nvmem framework.
    
    With this patch we use the mtdX name instead of the partition name,
    which is unique.
    
    [    8.948991] sysfs: cannot create duplicate filename '/bus/nvmem/devices/Production Data'
    [    8.948992] CPU: 7 PID: 246 Comm: systemd-udevd Not tainted 5.5.0-qtec-standard #13
    [    8.948993] Hardware name: AMD Dibbler/Dibbler, BIOS 05.22.04.0019 10/26/2019
    [    8.948994] Call Trace:
    [    8.948996]  dump_stack+0x50/0x70
    [    8.948998]  sysfs_warn_dup.cold+0x17/0x2d
    [    8.949000]  sysfs_do_create_link_sd.isra.0+0xc2/0xd0
    [    8.949002]  bus_add_device+0x74/0x140
    [    8.949004]  device_add+0x34b/0x850
    [    8.949006]  nvmem_register.part.0+0x1bf/0x640
    ...
    [    8.948926] mtd mtd8: Failed to register NVMEM device
    
    Fixes: c4dfa25ab307 ("mtd: add support for reading MTD devices via the nvmem API")
    Signed-off-by: Ricardo Ribalda Delgado <ribalda@kernel.org>
    Acked-by: Miquel Raynal <miquel.raynal@bootlin.com>
    Signed-off-by: Richard Weinberger <richard@nod.at>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index 2916674208b3..29d41003d6e0 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -555,7 +555,7 @@ static int mtd_nvmem_add(struct mtd_info *mtd)
 
 	config.id = -1;
 	config.dev = &mtd->dev;
-	config.name = mtd->name;
+	config.name = dev_name(&mtd->dev);
 	config.owner = THIS_MODULE;
 	config.reg_read = mtd_nvmem_reg_read;
 	config.size = mtd->size;

commit 9e3307a169537a6adc30b13bf9063e94990a5493
Author: Boris Brezillon <bbrezillon@kernel.org>
Date:   Sun May 3 17:53:37 2020 +0200

    mtd: Add support for emulated SLC mode on MLC NANDs
    
    MLC NANDs can be made a bit more reliable if we only program the lower
    page of each pair. At least, this solves the paired-pages corruption
    issue.
    
    Signed-off-by: Boris Brezillon <bbrezillon@kernel.org>
    Signed-off-by: Miquel Raynal <miquel.raynal@bootlin.com>
    Link: https://lore.kernel.org/linux-mtd/20200503155341.16712-5-miquel.raynal@bootlin.com

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index 2916674208b3..50437b4ffe76 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -617,6 +617,19 @@ int add_mtd_device(struct mtd_info *mtd)
 		    !(mtd->flags & MTD_NO_ERASE)))
 		return -EINVAL;
 
+	/*
+	 * MTD_SLC_ON_MLC_EMULATION can only be set on partitions, when the
+	 * master is an MLC NAND and has a proper pairing scheme defined.
+	 * We also reject masters that implement ->_writev() for now, because
+	 * NAND controller drivers don't implement this hook, and adding the
+	 * SLC -> MLC address/length conversion to this path is useless if we
+	 * don't have a user.
+	 */
+	if (mtd->flags & MTD_SLC_ON_MLC_EMULATION &&
+	    (!mtd_is_partition(mtd) || master->type != MTD_MLCNANDFLASH ||
+	     !master->pairing || master->_writev))
+		return -EINVAL;
+
 	mutex_lock(&mtd_table_mutex);
 
 	i = idr_alloc(&mtd_idr, mtd, 0, 0, GFP_KERNEL);
@@ -632,6 +645,14 @@ int add_mtd_device(struct mtd_info *mtd)
 	if (mtd->bitflip_threshold == 0)
 		mtd->bitflip_threshold = mtd->ecc_strength;
 
+	if (mtd->flags & MTD_SLC_ON_MLC_EMULATION) {
+		int ngroups = mtd_pairing_groups(master);
+
+		mtd->erasesize /= ngroups;
+		mtd->size = (u64)mtd_div_by_eb(mtd->size, master) *
+			    mtd->erasesize;
+	}
+
 	if (is_power_of_2(mtd->erasesize))
 		mtd->erasesize_shift = ffs(mtd->erasesize) - 1;
 	else
@@ -1074,9 +1095,11 @@ int mtd_erase(struct mtd_info *mtd, struct erase_info *instr)
 {
 	struct mtd_info *master = mtd_get_master(mtd);
 	u64 mst_ofs = mtd_get_master_ofs(mtd, 0);
+	struct erase_info adjinstr;
 	int ret;
 
 	instr->fail_addr = MTD_FAIL_ADDR_UNKNOWN;
+	adjinstr = *instr;
 
 	if (!mtd->erasesize || !master->_erase)
 		return -ENOTSUPP;
@@ -1091,12 +1114,27 @@ int mtd_erase(struct mtd_info *mtd, struct erase_info *instr)
 
 	ledtrig_mtd_activity();
 
-	instr->addr += mst_ofs;
-	ret = master->_erase(master, instr);
-	if (instr->fail_addr != MTD_FAIL_ADDR_UNKNOWN)
-		instr->fail_addr -= mst_ofs;
+	if (mtd->flags & MTD_SLC_ON_MLC_EMULATION) {
+		adjinstr.addr = (loff_t)mtd_div_by_eb(instr->addr, mtd) *
+				master->erasesize;
+		adjinstr.len = ((u64)mtd_div_by_eb(instr->addr + instr->len, mtd) *
+				master->erasesize) -
+			       adjinstr.addr;
+	}
+
+	adjinstr.addr += mst_ofs;
+
+	ret = master->_erase(master, &adjinstr);
+
+	if (adjinstr.fail_addr != MTD_FAIL_ADDR_UNKNOWN) {
+		instr->fail_addr = adjinstr.fail_addr - mst_ofs;
+		if (mtd->flags & MTD_SLC_ON_MLC_EMULATION) {
+			instr->fail_addr = mtd_div_by_eb(instr->fail_addr,
+							 master);
+			instr->fail_addr *= mtd->erasesize;
+		}
+	}
 
-	instr->addr -= mst_ofs;
 	return ret;
 }
 EXPORT_SYMBOL_GPL(mtd_erase);
@@ -1276,6 +1314,101 @@ static int mtd_check_oob_ops(struct mtd_info *mtd, loff_t offs,
 	return 0;
 }
 
+static int mtd_read_oob_std(struct mtd_info *mtd, loff_t from,
+			    struct mtd_oob_ops *ops)
+{
+	struct mtd_info *master = mtd_get_master(mtd);
+	int ret;
+
+	from = mtd_get_master_ofs(mtd, from);
+	if (master->_read_oob)
+		ret = master->_read_oob(master, from, ops);
+	else
+		ret = master->_read(master, from, ops->len, &ops->retlen,
+				    ops->datbuf);
+
+	return ret;
+}
+
+static int mtd_write_oob_std(struct mtd_info *mtd, loff_t to,
+			     struct mtd_oob_ops *ops)
+{
+	struct mtd_info *master = mtd_get_master(mtd);
+	int ret;
+
+	to = mtd_get_master_ofs(mtd, to);
+	if (master->_write_oob)
+		ret = master->_write_oob(master, to, ops);
+	else
+		ret = master->_write(master, to, ops->len, &ops->retlen,
+				     ops->datbuf);
+
+	return ret;
+}
+
+static int mtd_io_emulated_slc(struct mtd_info *mtd, loff_t start, bool read,
+			       struct mtd_oob_ops *ops)
+{
+	struct mtd_info *master = mtd_get_master(mtd);
+	int ngroups = mtd_pairing_groups(master);
+	int npairs = mtd_wunit_per_eb(master) / ngroups;
+	struct mtd_oob_ops adjops = *ops;
+	unsigned int wunit, oobavail;
+	struct mtd_pairing_info info;
+	int max_bitflips = 0;
+	u32 ebofs, pageofs;
+	loff_t base, pos;
+
+	ebofs = mtd_mod_by_eb(start, mtd);
+	base = (loff_t)mtd_div_by_eb(start, mtd) * master->erasesize;
+	info.group = 0;
+	info.pair = mtd_div_by_ws(ebofs, mtd);
+	pageofs = mtd_mod_by_ws(ebofs, mtd);
+	oobavail = mtd_oobavail(mtd, ops);
+
+	while (ops->retlen < ops->len || ops->oobretlen < ops->ooblen) {
+		int ret;
+
+		if (info.pair >= npairs) {
+			info.pair = 0;
+			base += master->erasesize;
+		}
+
+		wunit = mtd_pairing_info_to_wunit(master, &info);
+		pos = mtd_wunit_to_offset(mtd, base, wunit);
+
+		adjops.len = ops->len - ops->retlen;
+		if (adjops.len > mtd->writesize - pageofs)
+			adjops.len = mtd->writesize - pageofs;
+
+		adjops.ooblen = ops->ooblen - ops->oobretlen;
+		if (adjops.ooblen > oobavail - adjops.ooboffs)
+			adjops.ooblen = oobavail - adjops.ooboffs;
+
+		if (read) {
+			ret = mtd_read_oob_std(mtd, pos + pageofs, &adjops);
+			if (ret > 0)
+				max_bitflips = max(max_bitflips, ret);
+		} else {
+			ret = mtd_write_oob_std(mtd, pos + pageofs, &adjops);
+		}
+
+		if (ret < 0)
+			return ret;
+
+		max_bitflips = max(max_bitflips, ret);
+		ops->retlen += adjops.retlen;
+		ops->oobretlen += adjops.oobretlen;
+		adjops.datbuf += adjops.retlen;
+		adjops.oobbuf += adjops.oobretlen;
+		adjops.ooboffs = 0;
+		pageofs = 0;
+		info.pair++;
+	}
+
+	return max_bitflips;
+}
+
 int mtd_read_oob(struct mtd_info *mtd, loff_t from, struct mtd_oob_ops *ops)
 {
 	struct mtd_info *master = mtd_get_master(mtd);
@@ -1294,12 +1427,10 @@ int mtd_read_oob(struct mtd_info *mtd, loff_t from, struct mtd_oob_ops *ops)
 	if (!master->_read_oob && (!master->_read || ops->oobbuf))
 		return -EOPNOTSUPP;
 
-	from = mtd_get_master_ofs(mtd, from);
-	if (master->_read_oob)
-		ret_code = master->_read_oob(master, from, ops);
+	if (mtd->flags & MTD_SLC_ON_MLC_EMULATION)
+		ret_code = mtd_io_emulated_slc(mtd, from, true, ops);
 	else
-		ret_code = master->_read(master, from, ops->len, &ops->retlen,
-					 ops->datbuf);
+		ret_code = mtd_read_oob_std(mtd, from, ops);
 
 	mtd_update_ecc_stats(mtd, master, &old_stats);
 
@@ -1338,13 +1469,10 @@ int mtd_write_oob(struct mtd_info *mtd, loff_t to,
 	if (!master->_write_oob && (!master->_write || ops->oobbuf))
 		return -EOPNOTSUPP;
 
-	to = mtd_get_master_ofs(mtd, to);
+	if (mtd->flags & MTD_SLC_ON_MLC_EMULATION)
+		return mtd_io_emulated_slc(mtd, to, false, ops);
 
-	if (master->_write_oob)
-		return master->_write_oob(master, to, ops);
-	else
-		return master->_write(master, to, ops->len, &ops->retlen,
-				      ops->datbuf);
+	return mtd_write_oob_std(mtd, to, ops);
 }
 EXPORT_SYMBOL_GPL(mtd_write_oob);
 
@@ -1817,6 +1945,12 @@ int mtd_lock(struct mtd_info *mtd, loff_t ofs, uint64_t len)
 		return -EINVAL;
 	if (!len)
 		return 0;
+
+	if (mtd->flags & MTD_SLC_ON_MLC_EMULATION) {
+		ofs = (loff_t)mtd_div_by_eb(ofs, mtd) * master->erasesize;
+		len = (u64)mtd_div_by_eb(len, mtd) * master->erasesize;
+	}
+
 	return master->_lock(master, mtd_get_master_ofs(mtd, ofs), len);
 }
 EXPORT_SYMBOL_GPL(mtd_lock);
@@ -1831,6 +1965,12 @@ int mtd_unlock(struct mtd_info *mtd, loff_t ofs, uint64_t len)
 		return -EINVAL;
 	if (!len)
 		return 0;
+
+	if (mtd->flags & MTD_SLC_ON_MLC_EMULATION) {
+		ofs = (loff_t)mtd_div_by_eb(ofs, mtd) * master->erasesize;
+		len = (u64)mtd_div_by_eb(len, mtd) * master->erasesize;
+	}
+
 	return master->_unlock(master, mtd_get_master_ofs(mtd, ofs), len);
 }
 EXPORT_SYMBOL_GPL(mtd_unlock);
@@ -1845,6 +1985,12 @@ int mtd_is_locked(struct mtd_info *mtd, loff_t ofs, uint64_t len)
 		return -EINVAL;
 	if (!len)
 		return 0;
+
+	if (mtd->flags & MTD_SLC_ON_MLC_EMULATION) {
+		ofs = (loff_t)mtd_div_by_eb(ofs, mtd) * master->erasesize;
+		len = (u64)mtd_div_by_eb(len, mtd) * master->erasesize;
+	}
+
 	return master->_is_locked(master, mtd_get_master_ofs(mtd, ofs), len);
 }
 EXPORT_SYMBOL_GPL(mtd_is_locked);
@@ -1857,6 +2003,10 @@ int mtd_block_isreserved(struct mtd_info *mtd, loff_t ofs)
 		return -EINVAL;
 	if (!master->_block_isreserved)
 		return 0;
+
+	if (mtd->flags & MTD_SLC_ON_MLC_EMULATION)
+		ofs = (loff_t)mtd_div_by_eb(ofs, mtd) * master->erasesize;
+
 	return master->_block_isreserved(master, mtd_get_master_ofs(mtd, ofs));
 }
 EXPORT_SYMBOL_GPL(mtd_block_isreserved);
@@ -1869,6 +2019,10 @@ int mtd_block_isbad(struct mtd_info *mtd, loff_t ofs)
 		return -EINVAL;
 	if (!master->_block_isbad)
 		return 0;
+
+	if (mtd->flags & MTD_SLC_ON_MLC_EMULATION)
+		ofs = (loff_t)mtd_div_by_eb(ofs, mtd) * master->erasesize;
+
 	return master->_block_isbad(master, mtd_get_master_ofs(mtd, ofs));
 }
 EXPORT_SYMBOL_GPL(mtd_block_isbad);
@@ -1885,6 +2039,9 @@ int mtd_block_markbad(struct mtd_info *mtd, loff_t ofs)
 	if (!(mtd->flags & MTD_WRITEABLE))
 		return -EROFS;
 
+	if (mtd->flags & MTD_SLC_ON_MLC_EMULATION)
+		ofs = (loff_t)mtd_div_by_eb(ofs, mtd) * master->erasesize;
+
 	ret = master->_block_markbad(master, mtd_get_master_ofs(mtd, ofs));
 	if (ret)
 		return ret;

commit 1cd925d583857ee3ead6cfbf1e4b1cd067d28591
Author: Christoph Hellwig <hch@lst.de>
Date:   Mon May 4 14:48:01 2020 +0200

    bdi: remove the name field in struct backing_dev_info
    
    The name is only printed for a not registered bdi in writeback.  Use the
    device name there as is more useful anyway for the unlike case that the
    warning triggers.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Jan Kara <jack@suse.cz>
    Reviewed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Reviewed-by: Bart Van Assche <bvanassche@acm.org>
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index 39ec563d9a14..fcb018ce17c3 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -2040,7 +2040,6 @@ static struct backing_dev_info * __init mtd_bdi_init(char *name)
 	if (!bdi)
 		return ERR_PTR(-ENOMEM);
 
-	bdi->name = name;
 	/*
 	 * We put '-0' suffix to the name to get the same name format as we
 	 * used to get. Since this is called only once, we get a unique name. 

commit aef33c2ff8aa5e24f3f7d93806aa84ca1c2b6832
Author: Christoph Hellwig <hch@lst.de>
Date:   Mon May 4 14:48:00 2020 +0200

    bdi: simplify bdi_alloc
    
    Merge the _node vs normal version and drop the superflous gfp_t argument.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Jan Kara <jack@suse.cz>
    Reviewed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Reviewed-by: Bart Van Assche <bvanassche@acm.org>
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index 2916674208b3..39ec563d9a14 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -2036,7 +2036,7 @@ static struct backing_dev_info * __init mtd_bdi_init(char *name)
 	struct backing_dev_info *bdi;
 	int ret;
 
-	bdi = bdi_alloc(GFP_KERNEL);
+	bdi = bdi_alloc(NUMA_NO_NODE);
 	if (!bdi)
 		return ERR_PTR(-ENOMEM);
 

commit 46b5889cc2c54bac7d7e727a44d28a298df23cef
Author: Miquel Raynal <miquel.raynal@bootlin.com>
Date:   Tue Jan 14 10:09:52 2020 +0100

    mtd: implement proper partition handling
    
    Instead of collecting partitions in a flat list, create a hierarchy
    within the mtd_info structure: use a partitions list to keep track of
    the partitions of an MTD device (which might be itself a partition of
    another MTD device), a pointer to the parent device (NULL when the MTD
    device is the root one, not a partition).
    
    By also saving directly in mtd_info the offset of the partition, we
    can get rid of the mtd_part structure.
    
    While at it, be consistent in the naming of the mtd_info structures to
    ease the understanding of the new hierarchy: these structures are
    usually called 'mtd', unless there are multiple instances of the same
    structure. In this case, there is usually a parent/child bound so we
    will call them 'parent' and 'child'.
    
    Signed-off-by: Miquel Raynal <miquel.raynal@bootlin.com>
    Link: https://lore.kernel.org/linux-mtd/20200114090952.11232-1-miquel.raynal@bootlin.com

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index 5fac4355b9c2..2916674208b3 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -456,13 +456,14 @@ static int mtd_reboot_notifier(struct notifier_block *n, unsigned long state,
 int mtd_wunit_to_pairing_info(struct mtd_info *mtd, int wunit,
 			      struct mtd_pairing_info *info)
 {
-	int npairs = mtd_wunit_per_eb(mtd) / mtd_pairing_groups(mtd);
+	struct mtd_info *master = mtd_get_master(mtd);
+	int npairs = mtd_wunit_per_eb(master) / mtd_pairing_groups(master);
 
 	if (wunit < 0 || wunit >= npairs)
 		return -EINVAL;
 
-	if (mtd->pairing && mtd->pairing->get_info)
-		return mtd->pairing->get_info(mtd, wunit, info);
+	if (master->pairing && master->pairing->get_info)
+		return master->pairing->get_info(master, wunit, info);
 
 	info->group = 0;
 	info->pair = wunit;
@@ -498,15 +499,16 @@ EXPORT_SYMBOL_GPL(mtd_wunit_to_pairing_info);
 int mtd_pairing_info_to_wunit(struct mtd_info *mtd,
 			      const struct mtd_pairing_info *info)
 {
-	int ngroups = mtd_pairing_groups(mtd);
-	int npairs = mtd_wunit_per_eb(mtd) / ngroups;
+	struct mtd_info *master = mtd_get_master(mtd);
+	int ngroups = mtd_pairing_groups(master);
+	int npairs = mtd_wunit_per_eb(master) / ngroups;
 
 	if (!info || info->pair < 0 || info->pair >= npairs ||
 	    info->group < 0 || info->group >= ngroups)
 		return -EINVAL;
 
-	if (mtd->pairing && mtd->pairing->get_wunit)
-		return mtd->pairing->get_wunit(mtd, info);
+	if (master->pairing && master->pairing->get_wunit)
+		return mtd->pairing->get_wunit(master, info);
 
 	return info->pair;
 }
@@ -524,10 +526,12 @@ EXPORT_SYMBOL_GPL(mtd_pairing_info_to_wunit);
  */
 int mtd_pairing_groups(struct mtd_info *mtd)
 {
-	if (!mtd->pairing || !mtd->pairing->ngroups)
+	struct mtd_info *master = mtd_get_master(mtd);
+
+	if (!master->pairing || !master->pairing->ngroups)
 		return 1;
 
-	return mtd->pairing->ngroups;
+	return master->pairing->ngroups;
 }
 EXPORT_SYMBOL_GPL(mtd_pairing_groups);
 
@@ -587,6 +591,7 @@ static int mtd_nvmem_add(struct mtd_info *mtd)
 
 int add_mtd_device(struct mtd_info *mtd)
 {
+	struct mtd_info *master = mtd_get_master(mtd);
 	struct mtd_notifier *not;
 	int i, error;
 
@@ -608,7 +613,7 @@ int add_mtd_device(struct mtd_info *mtd)
 		    (mtd->_read && mtd->_read_oob)))
 		return -EINVAL;
 
-	if (WARN_ON((!mtd->erasesize || !mtd->_erase) &&
+	if (WARN_ON((!mtd->erasesize || !master->_erase) &&
 		    !(mtd->flags & MTD_NO_ERASE)))
 		return -EINVAL;
 
@@ -765,7 +770,8 @@ static void mtd_set_dev_defaults(struct mtd_info *mtd)
 		pr_debug("mtd device won't show a device symlink in sysfs\n");
 	}
 
-	mtd->orig_flags = mtd->flags;
+	INIT_LIST_HEAD(&mtd->partitions);
+	mutex_init(&mtd->master.partitions_lock);
 }
 
 /**
@@ -971,20 +977,26 @@ EXPORT_SYMBOL_GPL(get_mtd_device);
 
 int __get_mtd_device(struct mtd_info *mtd)
 {
+	struct mtd_info *master = mtd_get_master(mtd);
 	int err;
 
-	if (!try_module_get(mtd->owner))
+	if (!try_module_get(master->owner))
 		return -ENODEV;
 
-	if (mtd->_get_device) {
-		err = mtd->_get_device(mtd);
+	if (master->_get_device) {
+		err = master->_get_device(mtd);
 
 		if (err) {
-			module_put(mtd->owner);
+			module_put(master->owner);
 			return err;
 		}
 	}
-	mtd->usecount++;
+
+	while (mtd->parent) {
+		mtd->usecount++;
+		mtd = mtd->parent;
+	}
+
 	return 0;
 }
 EXPORT_SYMBOL_GPL(__get_mtd_device);
@@ -1038,13 +1050,18 @@ EXPORT_SYMBOL_GPL(put_mtd_device);
 
 void __put_mtd_device(struct mtd_info *mtd)
 {
-	--mtd->usecount;
-	BUG_ON(mtd->usecount < 0);
+	struct mtd_info *master = mtd_get_master(mtd);
 
-	if (mtd->_put_device)
-		mtd->_put_device(mtd);
+	while (mtd->parent) {
+		--mtd->usecount;
+		BUG_ON(mtd->usecount < 0);
+		mtd = mtd->parent;
+	}
+
+	if (master->_put_device)
+		master->_put_device(master);
 
-	module_put(mtd->owner);
+	module_put(master->owner);
 }
 EXPORT_SYMBOL_GPL(__put_mtd_device);
 
@@ -1055,9 +1072,13 @@ EXPORT_SYMBOL_GPL(__put_mtd_device);
  */
 int mtd_erase(struct mtd_info *mtd, struct erase_info *instr)
 {
+	struct mtd_info *master = mtd_get_master(mtd);
+	u64 mst_ofs = mtd_get_master_ofs(mtd, 0);
+	int ret;
+
 	instr->fail_addr = MTD_FAIL_ADDR_UNKNOWN;
 
-	if (!mtd->erasesize || !mtd->_erase)
+	if (!mtd->erasesize || !master->_erase)
 		return -ENOTSUPP;
 
 	if (instr->addr >= mtd->size || instr->len > mtd->size - instr->addr)
@@ -1069,7 +1090,14 @@ int mtd_erase(struct mtd_info *mtd, struct erase_info *instr)
 		return 0;
 
 	ledtrig_mtd_activity();
-	return mtd->_erase(mtd, instr);
+
+	instr->addr += mst_ofs;
+	ret = master->_erase(master, instr);
+	if (instr->fail_addr != MTD_FAIL_ADDR_UNKNOWN)
+		instr->fail_addr -= mst_ofs;
+
+	instr->addr -= mst_ofs;
+	return ret;
 }
 EXPORT_SYMBOL_GPL(mtd_erase);
 
@@ -1079,30 +1107,36 @@ EXPORT_SYMBOL_GPL(mtd_erase);
 int mtd_point(struct mtd_info *mtd, loff_t from, size_t len, size_t *retlen,
 	      void **virt, resource_size_t *phys)
 {
+	struct mtd_info *master = mtd_get_master(mtd);
+
 	*retlen = 0;
 	*virt = NULL;
 	if (phys)
 		*phys = 0;
-	if (!mtd->_point)
+	if (!master->_point)
 		return -EOPNOTSUPP;
 	if (from < 0 || from >= mtd->size || len > mtd->size - from)
 		return -EINVAL;
 	if (!len)
 		return 0;
-	return mtd->_point(mtd, from, len, retlen, virt, phys);
+
+	from = mtd_get_master_ofs(mtd, from);
+	return master->_point(master, from, len, retlen, virt, phys);
 }
 EXPORT_SYMBOL_GPL(mtd_point);
 
 /* We probably shouldn't allow XIP if the unpoint isn't a NULL */
 int mtd_unpoint(struct mtd_info *mtd, loff_t from, size_t len)
 {
-	if (!mtd->_unpoint)
+	struct mtd_info *master = mtd_get_master(mtd);
+
+	if (!master->_unpoint)
 		return -EOPNOTSUPP;
 	if (from < 0 || from >= mtd->size || len > mtd->size - from)
 		return -EINVAL;
 	if (!len)
 		return 0;
-	return mtd->_unpoint(mtd, from, len);
+	return master->_unpoint(master, mtd_get_master_ofs(mtd, from), len);
 }
 EXPORT_SYMBOL_GPL(mtd_unpoint);
 
@@ -1129,6 +1163,25 @@ unsigned long mtd_get_unmapped_area(struct mtd_info *mtd, unsigned long len,
 }
 EXPORT_SYMBOL_GPL(mtd_get_unmapped_area);
 
+static void mtd_update_ecc_stats(struct mtd_info *mtd, struct mtd_info *master,
+				 const struct mtd_ecc_stats *old_stats)
+{
+	struct mtd_ecc_stats diff;
+
+	if (master == mtd)
+		return;
+
+	diff = master->ecc_stats;
+	diff.failed -= old_stats->failed;
+	diff.corrected -= old_stats->corrected;
+
+	while (mtd->parent) {
+		mtd->ecc_stats.failed += diff.failed;
+		mtd->ecc_stats.corrected += diff.corrected;
+		mtd = mtd->parent;
+	}
+}
+
 int mtd_read(struct mtd_info *mtd, loff_t from, size_t len, size_t *retlen,
 	     u_char *buf)
 {
@@ -1171,8 +1224,10 @@ EXPORT_SYMBOL_GPL(mtd_write);
 int mtd_panic_write(struct mtd_info *mtd, loff_t to, size_t len, size_t *retlen,
 		    const u_char *buf)
 {
+	struct mtd_info *master = mtd_get_master(mtd);
+
 	*retlen = 0;
-	if (!mtd->_panic_write)
+	if (!master->_panic_write)
 		return -EOPNOTSUPP;
 	if (to < 0 || to >= mtd->size || len > mtd->size - to)
 		return -EINVAL;
@@ -1183,7 +1238,8 @@ int mtd_panic_write(struct mtd_info *mtd, loff_t to, size_t len, size_t *retlen,
 	if (!mtd->oops_panic_write)
 		mtd->oops_panic_write = true;
 
-	return mtd->_panic_write(mtd, to, len, retlen, buf);
+	return master->_panic_write(master, mtd_get_master_ofs(mtd, to), len,
+				    retlen, buf);
 }
 EXPORT_SYMBOL_GPL(mtd_panic_write);
 
@@ -1222,7 +1278,10 @@ static int mtd_check_oob_ops(struct mtd_info *mtd, loff_t offs,
 
 int mtd_read_oob(struct mtd_info *mtd, loff_t from, struct mtd_oob_ops *ops)
 {
+	struct mtd_info *master = mtd_get_master(mtd);
+	struct mtd_ecc_stats old_stats = master->ecc_stats;
 	int ret_code;
+
 	ops->retlen = ops->oobretlen = 0;
 
 	ret_code = mtd_check_oob_ops(mtd, from, ops);
@@ -1232,14 +1291,17 @@ int mtd_read_oob(struct mtd_info *mtd, loff_t from, struct mtd_oob_ops *ops)
 	ledtrig_mtd_activity();
 
 	/* Check the validity of a potential fallback on mtd->_read */
-	if (!mtd->_read_oob && (!mtd->_read || ops->oobbuf))
+	if (!master->_read_oob && (!master->_read || ops->oobbuf))
 		return -EOPNOTSUPP;
 
-	if (mtd->_read_oob)
-		ret_code = mtd->_read_oob(mtd, from, ops);
+	from = mtd_get_master_ofs(mtd, from);
+	if (master->_read_oob)
+		ret_code = master->_read_oob(master, from, ops);
 	else
-		ret_code = mtd->_read(mtd, from, ops->len, &ops->retlen,
-				      ops->datbuf);
+		ret_code = master->_read(master, from, ops->len, &ops->retlen,
+					 ops->datbuf);
+
+	mtd_update_ecc_stats(mtd, master, &old_stats);
 
 	/*
 	 * In cases where ops->datbuf != NULL, mtd->_read_oob() has semantics
@@ -1258,6 +1320,7 @@ EXPORT_SYMBOL_GPL(mtd_read_oob);
 int mtd_write_oob(struct mtd_info *mtd, loff_t to,
 				struct mtd_oob_ops *ops)
 {
+	struct mtd_info *master = mtd_get_master(mtd);
 	int ret;
 
 	ops->retlen = ops->oobretlen = 0;
@@ -1272,14 +1335,16 @@ int mtd_write_oob(struct mtd_info *mtd, loff_t to,
 	ledtrig_mtd_activity();
 
 	/* Check the validity of a potential fallback on mtd->_write */
-	if (!mtd->_write_oob && (!mtd->_write || ops->oobbuf))
+	if (!master->_write_oob && (!master->_write || ops->oobbuf))
 		return -EOPNOTSUPP;
 
-	if (mtd->_write_oob)
-		return mtd->_write_oob(mtd, to, ops);
+	to = mtd_get_master_ofs(mtd, to);
+
+	if (master->_write_oob)
+		return master->_write_oob(master, to, ops);
 	else
-		return mtd->_write(mtd, to, ops->len, &ops->retlen,
-				   ops->datbuf);
+		return master->_write(master, to, ops->len, &ops->retlen,
+				      ops->datbuf);
 }
 EXPORT_SYMBOL_GPL(mtd_write_oob);
 
@@ -1302,15 +1367,17 @@ EXPORT_SYMBOL_GPL(mtd_write_oob);
 int mtd_ooblayout_ecc(struct mtd_info *mtd, int section,
 		      struct mtd_oob_region *oobecc)
 {
+	struct mtd_info *master = mtd_get_master(mtd);
+
 	memset(oobecc, 0, sizeof(*oobecc));
 
-	if (!mtd || section < 0)
+	if (!master || section < 0)
 		return -EINVAL;
 
-	if (!mtd->ooblayout || !mtd->ooblayout->ecc)
+	if (!master->ooblayout || !master->ooblayout->ecc)
 		return -ENOTSUPP;
 
-	return mtd->ooblayout->ecc(mtd, section, oobecc);
+	return master->ooblayout->ecc(master, section, oobecc);
 }
 EXPORT_SYMBOL_GPL(mtd_ooblayout_ecc);
 
@@ -1334,15 +1401,17 @@ EXPORT_SYMBOL_GPL(mtd_ooblayout_ecc);
 int mtd_ooblayout_free(struct mtd_info *mtd, int section,
 		       struct mtd_oob_region *oobfree)
 {
+	struct mtd_info *master = mtd_get_master(mtd);
+
 	memset(oobfree, 0, sizeof(*oobfree));
 
-	if (!mtd || section < 0)
+	if (!master || section < 0)
 		return -EINVAL;
 
-	if (!mtd->ooblayout || !mtd->ooblayout->free)
+	if (!master->ooblayout || !master->ooblayout->free)
 		return -ENOTSUPP;
 
-	return mtd->ooblayout->free(mtd, section, oobfree);
+	return master->ooblayout->free(master, section, oobfree);
 }
 EXPORT_SYMBOL_GPL(mtd_ooblayout_free);
 
@@ -1651,60 +1720,69 @@ EXPORT_SYMBOL_GPL(mtd_ooblayout_count_eccbytes);
 int mtd_get_fact_prot_info(struct mtd_info *mtd, size_t len, size_t *retlen,
 			   struct otp_info *buf)
 {
-	if (!mtd->_get_fact_prot_info)
+	struct mtd_info *master = mtd_get_master(mtd);
+
+	if (!master->_get_fact_prot_info)
 		return -EOPNOTSUPP;
 	if (!len)
 		return 0;
-	return mtd->_get_fact_prot_info(mtd, len, retlen, buf);
+	return master->_get_fact_prot_info(master, len, retlen, buf);
 }
 EXPORT_SYMBOL_GPL(mtd_get_fact_prot_info);
 
 int mtd_read_fact_prot_reg(struct mtd_info *mtd, loff_t from, size_t len,
 			   size_t *retlen, u_char *buf)
 {
+	struct mtd_info *master = mtd_get_master(mtd);
+
 	*retlen = 0;
-	if (!mtd->_read_fact_prot_reg)
+	if (!master->_read_fact_prot_reg)
 		return -EOPNOTSUPP;
 	if (!len)
 		return 0;
-	return mtd->_read_fact_prot_reg(mtd, from, len, retlen, buf);
+	return master->_read_fact_prot_reg(master, from, len, retlen, buf);
 }
 EXPORT_SYMBOL_GPL(mtd_read_fact_prot_reg);
 
 int mtd_get_user_prot_info(struct mtd_info *mtd, size_t len, size_t *retlen,
 			   struct otp_info *buf)
 {
-	if (!mtd->_get_user_prot_info)
+	struct mtd_info *master = mtd_get_master(mtd);
+
+	if (!master->_get_user_prot_info)
 		return -EOPNOTSUPP;
 	if (!len)
 		return 0;
-	return mtd->_get_user_prot_info(mtd, len, retlen, buf);
+	return master->_get_user_prot_info(master, len, retlen, buf);
 }
 EXPORT_SYMBOL_GPL(mtd_get_user_prot_info);
 
 int mtd_read_user_prot_reg(struct mtd_info *mtd, loff_t from, size_t len,
 			   size_t *retlen, u_char *buf)
 {
+	struct mtd_info *master = mtd_get_master(mtd);
+
 	*retlen = 0;
-	if (!mtd->_read_user_prot_reg)
+	if (!master->_read_user_prot_reg)
 		return -EOPNOTSUPP;
 	if (!len)
 		return 0;
-	return mtd->_read_user_prot_reg(mtd, from, len, retlen, buf);
+	return master->_read_user_prot_reg(master, from, len, retlen, buf);
 }
 EXPORT_SYMBOL_GPL(mtd_read_user_prot_reg);
 
 int mtd_write_user_prot_reg(struct mtd_info *mtd, loff_t to, size_t len,
 			    size_t *retlen, u_char *buf)
 {
+	struct mtd_info *master = mtd_get_master(mtd);
 	int ret;
 
 	*retlen = 0;
-	if (!mtd->_write_user_prot_reg)
+	if (!master->_write_user_prot_reg)
 		return -EOPNOTSUPP;
 	if (!len)
 		return 0;
-	ret = mtd->_write_user_prot_reg(mtd, to, len, retlen, buf);
+	ret = master->_write_user_prot_reg(master, to, len, retlen, buf);
 	if (ret)
 		return ret;
 
@@ -1718,80 +1796,105 @@ EXPORT_SYMBOL_GPL(mtd_write_user_prot_reg);
 
 int mtd_lock_user_prot_reg(struct mtd_info *mtd, loff_t from, size_t len)
 {
-	if (!mtd->_lock_user_prot_reg)
+	struct mtd_info *master = mtd_get_master(mtd);
+
+	if (!master->_lock_user_prot_reg)
 		return -EOPNOTSUPP;
 	if (!len)
 		return 0;
-	return mtd->_lock_user_prot_reg(mtd, from, len);
+	return master->_lock_user_prot_reg(master, from, len);
 }
 EXPORT_SYMBOL_GPL(mtd_lock_user_prot_reg);
 
 /* Chip-supported device locking */
 int mtd_lock(struct mtd_info *mtd, loff_t ofs, uint64_t len)
 {
-	if (!mtd->_lock)
+	struct mtd_info *master = mtd_get_master(mtd);
+
+	if (!master->_lock)
 		return -EOPNOTSUPP;
 	if (ofs < 0 || ofs >= mtd->size || len > mtd->size - ofs)
 		return -EINVAL;
 	if (!len)
 		return 0;
-	return mtd->_lock(mtd, ofs, len);
+	return master->_lock(master, mtd_get_master_ofs(mtd, ofs), len);
 }
 EXPORT_SYMBOL_GPL(mtd_lock);
 
 int mtd_unlock(struct mtd_info *mtd, loff_t ofs, uint64_t len)
 {
-	if (!mtd->_unlock)
+	struct mtd_info *master = mtd_get_master(mtd);
+
+	if (!master->_unlock)
 		return -EOPNOTSUPP;
 	if (ofs < 0 || ofs >= mtd->size || len > mtd->size - ofs)
 		return -EINVAL;
 	if (!len)
 		return 0;
-	return mtd->_unlock(mtd, ofs, len);
+	return master->_unlock(master, mtd_get_master_ofs(mtd, ofs), len);
 }
 EXPORT_SYMBOL_GPL(mtd_unlock);
 
 int mtd_is_locked(struct mtd_info *mtd, loff_t ofs, uint64_t len)
 {
-	if (!mtd->_is_locked)
+	struct mtd_info *master = mtd_get_master(mtd);
+
+	if (!master->_is_locked)
 		return -EOPNOTSUPP;
 	if (ofs < 0 || ofs >= mtd->size || len > mtd->size - ofs)
 		return -EINVAL;
 	if (!len)
 		return 0;
-	return mtd->_is_locked(mtd, ofs, len);
+	return master->_is_locked(master, mtd_get_master_ofs(mtd, ofs), len);
 }
 EXPORT_SYMBOL_GPL(mtd_is_locked);
 
 int mtd_block_isreserved(struct mtd_info *mtd, loff_t ofs)
 {
+	struct mtd_info *master = mtd_get_master(mtd);
+
 	if (ofs < 0 || ofs >= mtd->size)
 		return -EINVAL;
-	if (!mtd->_block_isreserved)
+	if (!master->_block_isreserved)
 		return 0;
-	return mtd->_block_isreserved(mtd, ofs);
+	return master->_block_isreserved(master, mtd_get_master_ofs(mtd, ofs));
 }
 EXPORT_SYMBOL_GPL(mtd_block_isreserved);
 
 int mtd_block_isbad(struct mtd_info *mtd, loff_t ofs)
 {
+	struct mtd_info *master = mtd_get_master(mtd);
+
 	if (ofs < 0 || ofs >= mtd->size)
 		return -EINVAL;
-	if (!mtd->_block_isbad)
+	if (!master->_block_isbad)
 		return 0;
-	return mtd->_block_isbad(mtd, ofs);
+	return master->_block_isbad(master, mtd_get_master_ofs(mtd, ofs));
 }
 EXPORT_SYMBOL_GPL(mtd_block_isbad);
 
 int mtd_block_markbad(struct mtd_info *mtd, loff_t ofs)
 {
-	if (!mtd->_block_markbad)
+	struct mtd_info *master = mtd_get_master(mtd);
+	int ret;
+
+	if (!master->_block_markbad)
 		return -EOPNOTSUPP;
 	if (ofs < 0 || ofs >= mtd->size)
 		return -EINVAL;
 	if (!(mtd->flags & MTD_WRITEABLE))
 		return -EROFS;
-	return mtd->_block_markbad(mtd, ofs);
+
+	ret = master->_block_markbad(master, mtd_get_master_ofs(mtd, ofs));
+	if (ret)
+		return ret;
+
+	while (mtd->parent) {
+		mtd->ecc_stats.badblocks++;
+		mtd = mtd->parent;
+	}
+
+	return 0;
 }
 EXPORT_SYMBOL_GPL(mtd_block_markbad);
 
@@ -1841,12 +1944,17 @@ static int default_mtd_writev(struct mtd_info *mtd, const struct kvec *vecs,
 int mtd_writev(struct mtd_info *mtd, const struct kvec *vecs,
 	       unsigned long count, loff_t to, size_t *retlen)
 {
+	struct mtd_info *master = mtd_get_master(mtd);
+
 	*retlen = 0;
 	if (!(mtd->flags & MTD_WRITEABLE))
 		return -EROFS;
-	if (!mtd->_writev)
+
+	if (!master->_writev)
 		return default_mtd_writev(mtd, vecs, count, to, retlen);
-	return mtd->_writev(mtd, vecs, count, to, retlen);
+
+	return master->_writev(master, vecs, count,
+			       mtd_get_master_ofs(mtd, to), retlen);
 }
 EXPORT_SYMBOL_GPL(mtd_writev);
 

commit c2d73ba892eac0275b0d2bd7fae8dd4591a05da9
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Thu Nov 7 09:51:11 2019 +0100

    mtd: no need to check return value of debugfs_create functions
    
    When calling debugfs functions, there is no need to ever check the
    return value.  The function can work or not, but the code logic should
    never do something different based on this.
    
    Cc: David Woodhouse <dwmw2@infradead.org>
    Cc: Brian Norris <computersforpeace@gmail.com>
    Cc: Marek Vasut <marek.vasut@gmail.com>
    Cc: Miquel Raynal <miquel.raynal@bootlin.com>
    Cc: Richard Weinberger <richard@nod.at>
    Cc: Vignesh Raghavendra <vigneshr@ti.com>
    Cc: Artem Bityutskiy <dedekind1@gmail.com>
    Cc: linux-mtd@lists.infradead.org
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Miquel Raynal <miquel.raynal@bootlin.com>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index 6cc7ecb0c788..5fac4355b9c2 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -382,33 +382,21 @@ static struct dentry *dfs_dir_mtd;
 static void mtd_debugfs_populate(struct mtd_info *mtd)
 {
 	struct device *dev = &mtd->dev;
-	struct dentry *root, *dent;
+	struct dentry *root;
 
 	if (IS_ERR_OR_NULL(dfs_dir_mtd))
 		return;
 
 	root = debugfs_create_dir(dev_name(dev), dfs_dir_mtd);
-	if (IS_ERR_OR_NULL(root)) {
-		dev_dbg(dev, "won't show data in debugfs\n");
-		return;
-	}
-
 	mtd->dbg.dfs_dir = root;
 
-	if (mtd->dbg.partid) {
-		dent = debugfs_create_file("partid", 0400, root, mtd,
-					   &mtd_partid_debug_fops);
-		if (IS_ERR_OR_NULL(dent))
-			dev_err(dev, "can't create debugfs entry for partid\n");
-	}
+	if (mtd->dbg.partid)
+		debugfs_create_file("partid", 0400, root, mtd,
+				    &mtd_partid_debug_fops);
 
-	if (mtd->dbg.partname) {
-		dent = debugfs_create_file("partname", 0400, root, mtd,
-					   &mtd_partname_debug_fops);
-		if (IS_ERR_OR_NULL(dent))
-			dev_err(dev,
-				"can't create debugfs entry for partname\n");
-	}
+	if (mtd->dbg.partname)
+		debugfs_create_file("partname", 0400, root, mtd,
+				    &mtd_partname_debug_fops);
 }
 
 #ifndef CONFIG_MMU

commit 1018c94be6ea073115f6bcf993d6492138d2b8e3
Author: Zhuohao Lee <zhuohao@chromium.org>
Date:   Mon Jul 1 00:07:10 2019 +0800

    mtd: mtdcore: add debugfs nodes for querying the flash name and id
    
    Currently, we don't have vfs nodes for querying the underlying flash name
    and flash id. This information is important especially when we want to
    know the flash detail of the defective system. In order to support the
    query, we add mtd_debugfs_populate() to create two debugfs nodes
    (ie. partname and partid). The upper driver can assign the pointer to
    partname and partid before calling mtd_device_register().
    
    Signed-off-by: Zhuohao Lee <zhuohao@chromium.org>
    Reviewed-by: Boris Brezillon <boris.brezillon@collabora.com>
    Signed-off-by: Tudor Ambarus <tudor.ambarus@microchip.com>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index 408615f29e57..6cc7ecb0c788 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -335,6 +335,82 @@ static const struct device_type mtd_devtype = {
 	.release	= mtd_release,
 };
 
+static int mtd_partid_show(struct seq_file *s, void *p)
+{
+	struct mtd_info *mtd = s->private;
+
+	seq_printf(s, "%s\n", mtd->dbg.partid);
+
+	return 0;
+}
+
+static int mtd_partid_debugfs_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, mtd_partid_show, inode->i_private);
+}
+
+static const struct file_operations mtd_partid_debug_fops = {
+	.open           = mtd_partid_debugfs_open,
+	.read           = seq_read,
+	.llseek         = seq_lseek,
+	.release        = single_release,
+};
+
+static int mtd_partname_show(struct seq_file *s, void *p)
+{
+	struct mtd_info *mtd = s->private;
+
+	seq_printf(s, "%s\n", mtd->dbg.partname);
+
+	return 0;
+}
+
+static int mtd_partname_debugfs_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, mtd_partname_show, inode->i_private);
+}
+
+static const struct file_operations mtd_partname_debug_fops = {
+	.open           = mtd_partname_debugfs_open,
+	.read           = seq_read,
+	.llseek         = seq_lseek,
+	.release        = single_release,
+};
+
+static struct dentry *dfs_dir_mtd;
+
+static void mtd_debugfs_populate(struct mtd_info *mtd)
+{
+	struct device *dev = &mtd->dev;
+	struct dentry *root, *dent;
+
+	if (IS_ERR_OR_NULL(dfs_dir_mtd))
+		return;
+
+	root = debugfs_create_dir(dev_name(dev), dfs_dir_mtd);
+	if (IS_ERR_OR_NULL(root)) {
+		dev_dbg(dev, "won't show data in debugfs\n");
+		return;
+	}
+
+	mtd->dbg.dfs_dir = root;
+
+	if (mtd->dbg.partid) {
+		dent = debugfs_create_file("partid", 0400, root, mtd,
+					   &mtd_partid_debug_fops);
+		if (IS_ERR_OR_NULL(dent))
+			dev_err(dev, "can't create debugfs entry for partid\n");
+	}
+
+	if (mtd->dbg.partname) {
+		dent = debugfs_create_file("partname", 0400, root, mtd,
+					   &mtd_partname_debug_fops);
+		if (IS_ERR_OR_NULL(dent))
+			dev_err(dev,
+				"can't create debugfs entry for partname\n");
+	}
+}
+
 #ifndef CONFIG_MMU
 unsigned mtd_mmap_capabilities(struct mtd_info *mtd)
 {
@@ -512,8 +588,6 @@ static int mtd_nvmem_add(struct mtd_info *mtd)
 	return 0;
 }
 
-static struct dentry *dfs_dir_mtd;
-
 /**
  *	add_mtd_device - register an MTD device
  *	@mtd: pointer to new MTD device info structure
@@ -607,13 +681,7 @@ int add_mtd_device(struct mtd_info *mtd)
 	if (error)
 		goto fail_nvmem_add;
 
-	if (!IS_ERR_OR_NULL(dfs_dir_mtd)) {
-		mtd->dbg.dfs_dir = debugfs_create_dir(dev_name(&mtd->dev), dfs_dir_mtd);
-		if (IS_ERR_OR_NULL(mtd->dbg.dfs_dir)) {
-			pr_debug("mtd device %s won't show data in debugfs\n",
-				 dev_name(&mtd->dev));
-		}
-	}
+	mtd_debugfs_populate(mtd);
 
 	device_create(&mtd_class, mtd->dev.parent, MTD_DEVT(i) + 1, NULL,
 		      "mtd%dro", i);

commit 9f897bfdd89f5f08a12fa263a7f57fbf8ad9292f
Author: Kamal Dasu <kdasu.kdev@gmail.com>
Date:   Thu May 16 12:41:46 2019 -0400

    mtd: Add flag to indicate panic_write
    
    Added a flag to indicate a panic_write so that low level drivers can
    use it to take required action where applicable, to ensure oops data
    gets written to assigned mtd device.
    
    Signed-off-by: Kamal Dasu <kdasu.kdev@gmail.com>
    Signed-off-by: Miquel Raynal <miquel.raynal@bootlin.com>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index 453242d6cf56..408615f29e57 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -1124,6 +1124,9 @@ int mtd_panic_write(struct mtd_info *mtd, loff_t to, size_t len, size_t *retlen,
 		return -EROFS;
 	if (!len)
 		return 0;
+	if (!mtd->oops_panic_write)
+		mtd->oops_panic_write = true;
+
 	return mtd->_panic_write(mtd, to, len, retlen, buf);
 }
 EXPORT_SYMBOL_GPL(mtd_panic_write);

commit fd534e9b5fdcf9bab33c03cb3ade1a1ae5b23c20
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu May 23 11:14:39 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 102
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details you
      should have received a copy of the gnu general public license along
      with this program if not write to the free software foundation inc
      51 franklin st fifth floor boston ma 02110 1301 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 50 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190523091649.499889647@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index 76b4264936ff..453242d6cf56 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -1,24 +1,10 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * Core registration and callback routines for MTD
  * drivers and users.
  *
  * Copyright © 1999-2010 David Woodhouse <dwmw2@infradead.org>
  * Copyright © 2006      Red Hat UK Limited 
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
  */
 
 #include <linux/module.h>

commit 811c16a2a2de6fcdeea188a770600210943f8947
Merge: a83b04232cec 9220d7befc9c
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Mar 4 18:59:37 2019 -0800

    Merge tag 'mtd/for-5.1' of git://git.infradead.org/linux-mtd
    
    Pull MTD updates from Boris Brezillon:
     "Core MTD changes:
       - Use struct_size() where appropriate
       - mtd_{read,write}() as wrappers around mtd_{read,write}_oob()
       - Fix misuse of PTR_ERR() in docg3
       - Coding style improvements in mtdcore.c
    
      SPI NOR changes:
        Core changes:
         - Add support of octal mode I/O transfer
         - Add a bunch of SPI NOR entries to the flash_info table
    
        SPI NOR controller driver changes:
         - cadence-quadspi:
            * Add support for Octal SPI controller
            * write upto 8-bytes data in STIG mode
         - mtk-quadspi:
            * rename config to a common one
            * add SNOR_HWCAPS_READ to spi_nor_hwcaps mask
         - Add Tudor as SPI-NOR co-maintainer
    
      NAND changes:
        NAND core changes:
         - Fourth batch of fixes/cleanup to the raw NAND core impacting
           various controller drivers (Sunxi, Marvell, MTK, TMIO, OMAP2).
         - Check the return code of nand_reset() and nand_readid_op().
         - Remove ->legacy.erase and single_erase().
         - Simplify the locking.
         - Several implicit fall through annotations.
    
        Raw NAND controllers drivers changes:
         - Fix various possible object reference leaks (MTK, JZ4780, Atmel)
         - ST:
            * Add support for STM32 FMC2 NAND flash controller
         - Meson:
            * Add support for Amlogic NAND flash controller
         - Denali:
            * Several cleanup patches
         - Sunxi:
            * Several cleanup patches
         - FSMC:
            * Disable NAND on remove()
            * Reset NAND timings on resume()
    
        SPI-NAND drivers changes:
         - Toshiba:
            * Add support for all Toshiba products.
         - Macronix:
            * Fix ECC status read.
         - Gigadevice:
            * Add support for GD5F1GQ4UExxG"
    
    * tag 'mtd/for-5.1' of git://git.infradead.org/linux-mtd: (64 commits)
      mtd: spi-nor: Fix wrong abbreviation HWCPAS
      mtd: spi-nor: cadence-quadspi: fix spelling mistake: "Couldnt't" -> "Couldn't"
      mtd: spi-nor: Add support for en25qh64
      mtd: spi-nor: Add support for MX25V8035F
      mtd: spi-nor: Add support for EN25Q80A
      mtd: spi-nor: cadence-quadspi: Add support for Octal SPI controller
      dt-bindings: cadence-quadspi: Add new compatible for AM654 SoC
      mtd: spi-nor: split s25fl128s into s25fl128s0 and s25fl128s1
      mtd: spi-nor: cadence-quadspi: write upto 8-bytes data in STIG mode
      mtd: spi-nor: Add support for mx25u3235f
      mtd: rawnand: denali_dt: remove single anonymous clock support
      mtd: rawnand: mtk: fix possible object reference leak
      mtd: rawnand: jz4780: fix possible object reference leak
      mtd: rawnand: atmel: fix possible object reference leak
      mtd: rawnand: fsmc: Disable NAND on remove()
      mtd: rawnand: fsmc: Reset NAND timings on resume()
      mtd: spinand: Add support for GigaDevice GD5F1GQ4UExxG
      mtd: rawnand: denali: remove unused dma_addr field from denali_nand_info
      mtd: rawnand: denali: remove unused function argument 'raw'
      mtd: rawnand: denali: remove unneeded denali_reset_irq() call
      ...

commit 6e9526852fad7eb77b7755114951237312258ec7
Author: Aneesh Kumar K.V <aneesh.kumar@linux.ibm.com>
Date:   Mon Feb 11 19:03:37 2019 +0530

    mtd: Use mtd->name when registering nvmem device
    
    With this patch, we use the mtd->name instead of concatenating the name
    with '0'.
    
    Fixes: c4dfa25ab307 ("mtd: add support for reading MTD devices via the nvmem API")
    Signed-off-by: Aneesh Kumar K.V <aneesh.kumar@linux.ibm.com>
    Signed-off-by: Boris Brezillon <boris.brezillon@collabora.com>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index 999b705769a8..3ef01baef9b6 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -507,6 +507,7 @@ static int mtd_nvmem_add(struct mtd_info *mtd)
 {
 	struct nvmem_config config = {};
 
+	config.id = -1;
 	config.dev = &mtd->dev;
 	config.name = mtd->name;
 	config.owner = THIS_MODULE;

commit f7fd818cca0cea3d678f19cd300f06a537ae9e90
Author: Stefan Roese <sr@denx.de>
Date:   Thu Jan 24 16:52:20 2019 +0100

    mtd: Remove empty lines at end of sysfs related functions
    
    Some sysfs functions have empty stray lines after the return statement.
    This patch remove those empty lines.
    
    Signed-off-by: Stefan Roese <sr@denx.de>
    Cc: Boris Brezillon <bbrezillon@kernel.org>
    Signed-off-by: Boris Brezillon <bbrezillon@kernel.org>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index d5a7fc6ea3f3..c69b33cd18f3 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -155,7 +155,6 @@ static ssize_t mtd_flags_show(struct device *dev,
 	struct mtd_info *mtd = dev_get_drvdata(dev);
 
 	return snprintf(buf, PAGE_SIZE, "0x%lx\n", (unsigned long)mtd->flags);
-
 }
 static DEVICE_ATTR(flags, S_IRUGO, mtd_flags_show, NULL);
 
@@ -166,7 +165,6 @@ static ssize_t mtd_size_show(struct device *dev,
 
 	return snprintf(buf, PAGE_SIZE, "%llu\n",
 		(unsigned long long)mtd->size);
-
 }
 static DEVICE_ATTR(size, S_IRUGO, mtd_size_show, NULL);
 
@@ -176,7 +174,6 @@ static ssize_t mtd_erasesize_show(struct device *dev,
 	struct mtd_info *mtd = dev_get_drvdata(dev);
 
 	return snprintf(buf, PAGE_SIZE, "%lu\n", (unsigned long)mtd->erasesize);
-
 }
 static DEVICE_ATTR(erasesize, S_IRUGO, mtd_erasesize_show, NULL);
 
@@ -186,7 +183,6 @@ static ssize_t mtd_writesize_show(struct device *dev,
 	struct mtd_info *mtd = dev_get_drvdata(dev);
 
 	return snprintf(buf, PAGE_SIZE, "%lu\n", (unsigned long)mtd->writesize);
-
 }
 static DEVICE_ATTR(writesize, S_IRUGO, mtd_writesize_show, NULL);
 
@@ -197,7 +193,6 @@ static ssize_t mtd_subpagesize_show(struct device *dev,
 	unsigned int subpagesize = mtd->writesize >> mtd->subpage_sft;
 
 	return snprintf(buf, PAGE_SIZE, "%u\n", subpagesize);
-
 }
 static DEVICE_ATTR(subpagesize, S_IRUGO, mtd_subpagesize_show, NULL);
 
@@ -207,7 +202,6 @@ static ssize_t mtd_oobsize_show(struct device *dev,
 	struct mtd_info *mtd = dev_get_drvdata(dev);
 
 	return snprintf(buf, PAGE_SIZE, "%lu\n", (unsigned long)mtd->oobsize);
-
 }
 static DEVICE_ATTR(oobsize, S_IRUGO, mtd_oobsize_show, NULL);
 
@@ -226,7 +220,6 @@ static ssize_t mtd_numeraseregions_show(struct device *dev,
 	struct mtd_info *mtd = dev_get_drvdata(dev);
 
 	return snprintf(buf, PAGE_SIZE, "%u\n", mtd->numeraseregions);
-
 }
 static DEVICE_ATTR(numeraseregions, S_IRUGO, mtd_numeraseregions_show,
 	NULL);
@@ -237,7 +230,6 @@ static ssize_t mtd_name_show(struct device *dev,
 	struct mtd_info *mtd = dev_get_drvdata(dev);
 
 	return snprintf(buf, PAGE_SIZE, "%s\n", mtd->name);
-
 }
 static DEVICE_ATTR(name, S_IRUGO, mtd_name_show, NULL);
 

commit 2431c4f5b46c32c4ac495456b1ef4ce59c0bb85d
Author: Boris Brezillon <boris.brezillon@bootlin.com>
Date:   Thu Dec 20 15:13:20 2018 +0100

    mtd: Implement mtd_{read,write}() as wrappers around mtd_{read,write}_oob()
    
    mtd_{read,write}_oob() already take care of checking the params and
    calling ->_{read,write}() or  ->_{read,write}_oob() based on the
    request and the operations supported by the MTD device.
    No need to duplicate the logic, we can simply implement
    mtd_{read,write}() as wrappers around mtd_{read,write}_oob().
    
    Signed-off-by: Boris Brezillon <boris.brezillon@bootlin.com>
    Reviewed-by: Miquel Raynal <miquel.raynal@bootlin.com>
    Signed-off-by: Boris Brezillon <bbrezillon@kernel.org>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index 21e3cdc04036..d5a7fc6ea3f3 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -559,6 +559,14 @@ int add_mtd_device(struct mtd_info *mtd)
 
 	BUG_ON(mtd->writesize == 0);
 
+	/*
+	 * MTD drivers should implement ->_{write,read}() or
+	 * ->_{write,read}_oob(), but not both.
+	 */
+	if (WARN_ON((mtd->_write && mtd->_write_oob) ||
+		    (mtd->_read && mtd->_read_oob)))
+		return -EINVAL;
+
 	if (WARN_ON((!mtd->erasesize || !mtd->_erase) &&
 		    !(mtd->flags & MTD_NO_ERASE)))
 		return -EINVAL;
@@ -1089,67 +1097,32 @@ EXPORT_SYMBOL_GPL(mtd_get_unmapped_area);
 int mtd_read(struct mtd_info *mtd, loff_t from, size_t len, size_t *retlen,
 	     u_char *buf)
 {
-	int ret_code;
-	*retlen = 0;
-	if (from < 0 || from >= mtd->size || len > mtd->size - from)
-		return -EINVAL;
-	if (!len)
-		return 0;
+	struct mtd_oob_ops ops = {
+		.len = len,
+		.datbuf = buf,
+	};
+	int ret;
 
-	ledtrig_mtd_activity();
-	/*
-	 * In the absence of an error, drivers return a non-negative integer
-	 * representing the maximum number of bitflips that were corrected on
-	 * any one ecc region (if applicable; zero otherwise).
-	 */
-	if (mtd->_read) {
-		ret_code = mtd->_read(mtd, from, len, retlen, buf);
-	} else if (mtd->_read_oob) {
-		struct mtd_oob_ops ops = {
-			.len = len,
-			.datbuf = buf,
-		};
-
-		ret_code = mtd->_read_oob(mtd, from, &ops);
-		*retlen = ops.retlen;
-	} else {
-		return -ENOTSUPP;
-	}
+	ret = mtd_read_oob(mtd, from, &ops);
+	*retlen = ops.retlen;
 
-	if (unlikely(ret_code < 0))
-		return ret_code;
-	if (mtd->ecc_strength == 0)
-		return 0;	/* device lacks ecc */
-	return ret_code >= mtd->bitflip_threshold ? -EUCLEAN : 0;
+	return ret;
 }
 EXPORT_SYMBOL_GPL(mtd_read);
 
 int mtd_write(struct mtd_info *mtd, loff_t to, size_t len, size_t *retlen,
 	      const u_char *buf)
 {
-	*retlen = 0;
-	if (to < 0 || to >= mtd->size || len > mtd->size - to)
-		return -EINVAL;
-	if ((!mtd->_write && !mtd->_write_oob) ||
-	    !(mtd->flags & MTD_WRITEABLE))
-		return -EROFS;
-	if (!len)
-		return 0;
-	ledtrig_mtd_activity();
-
-	if (!mtd->_write) {
-		struct mtd_oob_ops ops = {
-			.len = len,
-			.datbuf = (u8 *)buf,
-		};
-		int ret;
+	struct mtd_oob_ops ops = {
+		.len = len,
+		.datbuf = (u8 *)buf,
+	};
+	int ret;
 
-		ret = mtd->_write_oob(mtd, to, &ops);
-		*retlen = ops.retlen;
-		return ret;
-	}
+	ret = mtd_write_oob(mtd, to, &ops);
+	*retlen = ops.retlen;
 
-	return mtd->_write(mtd, to, len, retlen, buf);
+	return ret;
 }
 EXPORT_SYMBOL_GPL(mtd_write);
 

commit 19e16fb4f319b84b3220e98abf726218beba8c34
Author: Boris Brezillon <bbrezillon@kernel.org>
Date:   Wed Jan 2 15:36:53 2019 +0100

    mtd: Fix the check on nvmem_register() ret code
    
    Commit 20167b70c894 ("nvmem: use EOPNOTSUPP instead of ENOSYS") changed
    the nvmem_register() ret code from ENOSYS to EOPNOTSUPP when
    CONFIG_NVMEM is not enabled, but the check in mtd_nvmem_add() was not
    adjusted accordingly.
    
    Cc: Bartosz Golaszewski <brgl@bgdev.pl>
    Cc: Alban Bedel <albeu@free.fr>
    Fixes: c4dfa25ab307 ("mtd: add support for reading MTD devices via the nvmem API")
    Reported-by: kernel test robot <rong.a.chen@intel.com>
    Signed-off-by: Boris Brezillon <bbrezillon@kernel.org>
    Reviewed-by: Bartosz Golaszewski <bgolaszewski@baylibre.com>
    Signed-off-by: Boris Brezillon <bbrezillon@kernel.org>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index 21e3cdc04036..999b705769a8 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -522,7 +522,7 @@ static int mtd_nvmem_add(struct mtd_info *mtd)
 	mtd->nvmem = nvmem_register(&config);
 	if (IS_ERR(mtd->nvmem)) {
 		/* Just ignore if there is no NVMEM support in the kernel */
-		if (PTR_ERR(mtd->nvmem) == -ENOSYS) {
+		if (PTR_ERR(mtd->nvmem) == -EOPNOTSUPP) {
 			mtd->nvmem = NULL;
 		} else {
 			dev_err(&mtd->dev, "Failed to register NVMEM device\n");

commit 457fa3469a65a524be04412f5cd497fa3b11c9fd
Merge: b07039b79c9e fbc4904c2877
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Dec 28 20:54:57 2018 -0800

    Merge tag 'char-misc-4.21-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/char-misc
    
    Pull char/misc driver updates from Greg KH:
     "Here is the big set of char and misc driver patches for 4.21-rc1.
    
      Lots of different types of driver things in here, as this tree seems
      to be the "collection of various driver subsystems not big enough to
      have their own git tree" lately.
    
      Anyway, some highlights of the changes in here:
    
       - binderfs: is it a rule that all driver subsystems will eventually
         grow to have their own filesystem? Binder now has one to handle the
         use of it in containerized systems.
    
         This was discussed at the Plumbers conference a few months ago and
         knocked into mergable shape very fast by Christian Brauner. Who
         also has signed up to be another binder maintainer, showing a
         distinct lack of good judgement :)
    
       - binder updates and fixes
    
       - mei driver updates
    
       - fpga driver updates and additions
    
       - thunderbolt driver updates
    
       - soundwire driver updates
    
       - extcon driver updates
    
       - nvmem driver updates
    
       - hyper-v driver updates
    
       - coresight driver updates
    
       - pvpanic driver additions and reworking for more device support
    
       - lp driver updates. Yes really, it's _finally_ moved to the proper
         parallal port driver model, something I never thought I would see
         happen. Good stuff.
    
       - other tiny driver updates and fixes.
    
      All of these have been in linux-next for a while with no reported
      issues"
    
    * tag 'char-misc-4.21-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/char-misc: (116 commits)
      MAINTAINERS: add another Android binder maintainer
      intel_th: msu: Fix an off-by-one in attribute store
      stm class: Add a reference to the SyS-T document
      stm class: Fix a module refcount leak in policy creation error path
      char: lp: use new parport device model
      char: lp: properly count the lp devices
      char: lp: use first unused lp number while registering
      char: lp: detach the device when parallel port is removed
      char: lp: introduce list to save port number
      bus: qcom: remove duplicated include from qcom-ebi2.c
      VMCI: Use memdup_user() rather than duplicating its implementation
      char/rtc: Use of_node_name_eq for node name comparisons
      misc: mic: fix a DMA pool free failure
      ptp: fix an IS_ERR() vs NULL check
      genwqe: Fix size check
      binder: implement binderfs
      binder: fix use-after-free due to ksys_close() during fdget()
      bus: fsl-mc: remove duplicated include files
      bus: fsl-mc: explicitly define the fsl_mc_command endianness
      misc: ti-st: make array read_ver_cmd static, shrinks object size
      ...

commit c4dfa25ab307a277eafa7067cd927fbe4d9be4ba
Author: Alban Bedel <albeu@free.fr>
Date:   Tue Nov 13 15:01:10 2018 +0100

    mtd: add support for reading MTD devices via the nvmem API
    
    Allow drivers that use the nvmem API to read data stored on MTD devices.
    For this the mtd devices are registered as read-only NVMEM providers.
    
    We don't support device tree systems for now.
    
    Signed-off-by: Alban Bedel <albeu@free.fr>
    [Bartosz:
      - include linux/nvmem-provider.h
      - set the name of the nvmem provider
      - set no_of_node to true in nvmem_config
      - don't check the return value of nvmem_unregister() - it cannot fail
      - tweaked the commit message]
    Signed-off-by: Bartosz Golaszewski <bgolaszewski@baylibre.com>
    Acked-by: Boris Brezillon <boris.brezillon@bootlin.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index 97ac219c082e..5f1053d995b0 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -41,6 +41,7 @@
 #include <linux/reboot.h>
 #include <linux/leds.h>
 #include <linux/debugfs.h>
+#include <linux/nvmem-provider.h>
 
 #include <linux/mtd/mtd.h>
 #include <linux/mtd/partitions.h>
@@ -488,6 +489,50 @@ int mtd_pairing_groups(struct mtd_info *mtd)
 }
 EXPORT_SYMBOL_GPL(mtd_pairing_groups);
 
+static int mtd_nvmem_reg_read(void *priv, unsigned int offset,
+			      void *val, size_t bytes)
+{
+	struct mtd_info *mtd = priv;
+	size_t retlen;
+	int err;
+
+	err = mtd_read(mtd, offset, bytes, &retlen, val);
+	if (err && err != -EUCLEAN)
+		return err;
+
+	return retlen == bytes ? 0 : -EIO;
+}
+
+static int mtd_nvmem_add(struct mtd_info *mtd)
+{
+	struct nvmem_config config = {};
+
+	config.dev = &mtd->dev;
+	config.name = mtd->name;
+	config.owner = THIS_MODULE;
+	config.reg_read = mtd_nvmem_reg_read;
+	config.size = mtd->size;
+	config.word_size = 1;
+	config.stride = 1;
+	config.read_only = true;
+	config.root_only = true;
+	config.no_of_node = true;
+	config.priv = mtd;
+
+	mtd->nvmem = nvmem_register(&config);
+	if (IS_ERR(mtd->nvmem)) {
+		/* Just ignore if there is no NVMEM support in the kernel */
+		if (PTR_ERR(mtd->nvmem) == -ENOSYS) {
+			mtd->nvmem = NULL;
+		} else {
+			dev_err(&mtd->dev, "Failed to register NVMEM device\n");
+			return PTR_ERR(mtd->nvmem);
+		}
+	}
+
+	return 0;
+}
+
 static struct dentry *dfs_dir_mtd;
 
 /**
@@ -570,6 +615,11 @@ int add_mtd_device(struct mtd_info *mtd)
 	if (error)
 		goto fail_added;
 
+	/* Add the nvmem provider */
+	error = mtd_nvmem_add(mtd);
+	if (error)
+		goto fail_nvmem_add;
+
 	if (!IS_ERR_OR_NULL(dfs_dir_mtd)) {
 		mtd->dbg.dfs_dir = debugfs_create_dir(dev_name(&mtd->dev), dfs_dir_mtd);
 		if (IS_ERR_OR_NULL(mtd->dbg.dfs_dir)) {
@@ -595,6 +645,8 @@ int add_mtd_device(struct mtd_info *mtd)
 	__module_get(THIS_MODULE);
 	return 0;
 
+fail_nvmem_add:
+	device_unregister(&mtd->dev);
 fail_added:
 	of_node_put(mtd_get_of_node(mtd));
 	idr_remove(&mtd_idr, i);
@@ -637,6 +689,10 @@ int del_mtd_device(struct mtd_info *mtd)
 		       mtd->index, mtd->name, mtd->usecount);
 		ret = -EBUSY;
 	} else {
+		/* Try to remove the NVMEM provider */
+		if (mtd->nvmem)
+			nvmem_unregister(mtd->nvmem);
+
 		device_unregister(&mtd->dev);
 
 		idr_remove(&mtd_idr, mtd->index);

commit 1186af457cc186c5ed01708da71b1ffbdf0a2638
Author: Rafał Miłecki <rafal@milecki.pl>
Date:   Tue Nov 20 09:55:45 2018 +0100

    mtd: keep original flags for every struct mtd_info
    
    When allocating a new partition mtd subsystem runs internal tests in the
    allocate_partition(). They may result in modifying specified flags (e.g.
    dropping some /features/ like write access).
    
    Those constraints don't have to be necessary true for subpartitions. It
    may happen parent partition isn't block aligned (effectively disabling
    write access) while subpartition may fit blocks nicely. In such case all
    checks should be run again (starting with original flags value).
    
    Signed-off-by: Rafał Miłecki <rafal@milecki.pl>
    Signed-off-by: Boris Brezillon <boris.brezillon@bootlin.com>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index afb4b17fb670..b6b93291aba9 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -665,6 +665,8 @@ static void mtd_set_dev_defaults(struct mtd_info *mtd)
 	} else {
 		pr_debug("mtd device won't show a device symlink in sysfs\n");
 	}
+
+	mtd->orig_flags = mtd->flags;
 }
 
 /**

commit 89f706dbd54faf2da1cb5bea9abc07b00c36ef69
Author: Miquel Raynal <miquel.raynal@bootlin.com>
Date:   Sun Nov 18 21:18:31 2018 +0100

    mtd: fix Coverity integer handling issue
    
    A Coverity robot reported an integer handling issue
    (OVERFLOW_BEFORE_WIDEN) in the potentially overflowing expression:
    
        (mtd_div_by_ws(mtd->size, mtd) - mtd_div_by_ws(offs, mtd)) *
        mtd_oobavail(mtd, ops)
    
    While such overflow will certainly never happen due to the numbers
    handled, it is cleaner to fix this operation anyway.
    
    The problem is that all the maths include 32-bit quantities, while the
    result is stored in an explicit 64-bit value.
    
    As maxooblen will just be compared with a size_t, let's change the
    type of the variable to a size_t. This will not fix anything but will
    clarify a bit the situation. Then, do an explicit cast to fix Coverity
    warning.
    
    Signed-off-by: Miquel Raynal <miquel.raynal@bootlin.com>
    Signed-off-by: Boris Brezillon <boris.brezillon@bootlin.com>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index 97ac219c082e..afb4b17fb670 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -1136,13 +1136,13 @@ static int mtd_check_oob_ops(struct mtd_info *mtd, loff_t offs,
 		return -EINVAL;
 
 	if (ops->ooblen) {
-		u64 maxooblen;
+		size_t maxooblen;
 
 		if (ops->ooboffs >= mtd_oobavail(mtd, ops))
 			return -EINVAL;
 
-		maxooblen = ((mtd_div_by_ws(mtd->size, mtd) -
-			      mtd_div_by_ws(offs, mtd)) *
+		maxooblen = ((size_t)(mtd_div_by_ws(mtd->size, mtd) -
+				      mtd_div_by_ws(offs, mtd)) *
 			     mtd_oobavail(mtd, ops)) - ops->ooboffs;
 		if (ops->ooblen > maxooblen)
 			return -EINVAL;

commit 89fd23efa0d7934ed9ec93c77486a047759d6543
Author: Miquel Raynal <miquel.raynal@bootlin.com>
Date:   Sat Jul 14 14:42:00 2018 +0200

    mtd: Fallback to ->_read/write() when ->_read/write_oob() is missing
    
    Some MTD sublayers/drivers are implementing ->_read/write() and
    not ->_read/write_oob().
    
    While for NAND devices both are usually valid, for NOR devices, using
    the _oob variant has no real meaning. But, as the MTD layer is supposed
    to hide as much as possible the flash complexity to the user, there is
    no reason to error out while it is just a matter of rewritting things
    internally.
    
    Add a fallback on mtd->_read() (resp. mtd->_write()) when the user calls
    mtd_read_oob() (resp. mtd_write_oob()) while mtd->_read_oob() (resp.
    mtd->_write_oob) is not implemented. There is already a fallback on the
    _oob variant if the former is used.
    
    Signed-off-by: Miquel Raynal <miquel.raynal@bootlin.com>
    Signed-off-by: Boris Brezillon <boris.brezillon@bootlin.com>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index 42395df06be9..97ac219c082e 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -1155,21 +1155,29 @@ int mtd_read_oob(struct mtd_info *mtd, loff_t from, struct mtd_oob_ops *ops)
 {
 	int ret_code;
 	ops->retlen = ops->oobretlen = 0;
-	if (!mtd->_read_oob)
-		return -EOPNOTSUPP;
 
 	ret_code = mtd_check_oob_ops(mtd, from, ops);
 	if (ret_code)
 		return ret_code;
 
 	ledtrig_mtd_activity();
+
+	/* Check the validity of a potential fallback on mtd->_read */
+	if (!mtd->_read_oob && (!mtd->_read || ops->oobbuf))
+		return -EOPNOTSUPP;
+
+	if (mtd->_read_oob)
+		ret_code = mtd->_read_oob(mtd, from, ops);
+	else
+		ret_code = mtd->_read(mtd, from, ops->len, &ops->retlen,
+				      ops->datbuf);
+
 	/*
 	 * In cases where ops->datbuf != NULL, mtd->_read_oob() has semantics
 	 * similar to mtd->_read(), returning a non-negative integer
 	 * representing max bitflips. In other cases, mtd->_read_oob() may
 	 * return -EUCLEAN. In all cases, perform similar logic to mtd_read().
 	 */
-	ret_code = mtd->_read_oob(mtd, from, ops);
 	if (unlikely(ret_code < 0))
 		return ret_code;
 	if (mtd->ecc_strength == 0)
@@ -1184,8 +1192,7 @@ int mtd_write_oob(struct mtd_info *mtd, loff_t to,
 	int ret;
 
 	ops->retlen = ops->oobretlen = 0;
-	if (!mtd->_write_oob)
-		return -EOPNOTSUPP;
+
 	if (!(mtd->flags & MTD_WRITEABLE))
 		return -EROFS;
 
@@ -1194,7 +1201,16 @@ int mtd_write_oob(struct mtd_info *mtd, loff_t to,
 		return ret;
 
 	ledtrig_mtd_activity();
-	return mtd->_write_oob(mtd, to, ops);
+
+	/* Check the validity of a potential fallback on mtd->_write */
+	if (!mtd->_write_oob && (!mtd->_write || ops->oobbuf))
+		return -EOPNOTSUPP;
+
+	if (mtd->_write_oob)
+		return mtd->_write_oob(mtd, to, ops);
+	else
+		return mtd->_write(mtd, to, ops->len, &ops->retlen,
+				   ops->datbuf);
 }
 EXPORT_SYMBOL_GPL(mtd_write_oob);
 

commit f4e70c2e5f1406e715f6359ae341e76e5004fb98
Merge: ea125dedbc14 b771327a4530
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Jun 8 10:39:20 2018 -0700

    Merge tag 'mtd/for-4.18' of git://git.infradead.org/linux-mtd
    
    Pull MTD updates from Boris Brezillon:
     "Core changes:
       - Add a sysfs attribute to expose available OOB size
    
      Driver changes:
       - Remove HAS_DMA dependency on various drivers
       - Use dev_get_drvdata() instead of platform_get_drvdata() in docg3
       - Replace msleep by usleep_range() in the dataflash driver
       - Avoid VLA usage in nftl layers
       - Remove useless .owner assignment in pismo
       - Fix various issues in the CFI driver
       - Improve TRX partition handling expose a DT compat for this part
         parser
       - Clarify OFFSET_CONTINUOUS meaning
    
      NAND core changes:
       - Add Miquel as a NAND maintainer
       - Add access mode to the nand_page_io_req struct
       - Fix kernel-doc in rawnand.h
       - Support bit-wise majority to recover from corrupted ONFI parameter
         pages
       - Stop checking FAIL bit after a SET_FEATURES, as documented in the
         ONFI spec
    
      Raw NAND Driver changes:
       - Fix and cleanup the error path of many NAND controller drivers
       - GPMI:
          + Cleanup/simplification of a few aspects in the driver
          + Take ECC setup specified in the DT into account
       - sunxi: remove support for GPIO-based R/B polling
       - MTK:
          + Use of_device_get_match_data() instead of of_match_device()
          + Add an entry in MAINTAINERS for this driver
          + Fix nand-ecc-step-size and nand-ecc-strength description in the
            DT bindings doc
       - fsl_ifc: fix ->cmdfunc() to read more than one ONFI parameter page
    
      OneNAND driver changes:
       - samsung: use dev_get_drvdata() instead of platform_get_drvdata()
    
      SPI NOR core changes:
       - Add support for a bunch of SPI NOR chips
       - Clear EAR reg when switching to 3-byte addressing mode on Winbond
         chips
    
      SPI NOR controller driver changes:
       - cadence: Add DMA support for direct mode reads
       - hisi: Prefix a few functions with hisi_
       - intel:
          + Mark the driver as "dangerous" in Kconfig
          + Fix atomic sequence handling
          + Pass a 40us delay (instead of 0us) to readl_poll_timeout()
       - fsl:
          + fix a typo in a function name
          + add support for IP variants embedded in the ls2080a and ls1080a
            SoCs
       - stm32: request exclusive control of the reset line"
    
    * tag 'mtd/for-4.18' of git://git.infradead.org/linux-mtd: (66 commits)
      mtd: nand: Pass mode information to nand_page_io_req
      mtd: cfi_cmdset_0002: Change erase one block to enable XIP once
      mtd: cfi_cmdset_0002: Change erase functions to check chip good only
      mtd: cfi_cmdset_0002: Change erase functions to retry for error
      mtd: cfi_cmdset_0002: Change definition naming to retry write operation
      mtd: cfi_cmdset_0002: Change write buffer to check correct value
      mtd: cmdlinepart: Update comment for introduction of OFFSET_CONTINUOUS
      mtd: bcm47xxpart: add of_match_table with a new DT binding
      dt-bindings: mtd: document Broadcom's BCM47xx partitions
      mtd: spi-nor: Add support for EN25QH32
      mtd: spi-nor: Add support for is25wp series chips
      mtd: spi-nor: Add Winbond w25q32jv support
      mtd: spi-nor: fsl-quadspi: add support for ls2080a/ls1080a
      mtd: spi-nor: stm32-quadspi: explicitly request exclusive reset control
      mtd: spi-nor: intel: provide a range for poll_timout
      mtd: spi-nor: fsl-quadspi: fix api naming typo _init_ahb_read
      mtd: spi-nor: intel-spi: Explicitly mark the driver as dangerous in Kconfig
      mtd: spi-nor: intel-spi: Fix atomic sequence handling
      mtd: rawnand: Do not check FAIL bit when executing a SET_FEATURES op
      mtd: rawnand: use bit-wise majority to recover the ONFI param page
      ...

commit 3f3942aca6da351a12543aa776467791b63b3a78
Author: Christoph Hellwig <hch@lst.de>
Date:   Tue May 15 15:57:23 2018 +0200

    proc: introduce proc_create_single{,_data}
    
    Variants of proc_create{,_data} that directly take a seq_file show
    callback and drastically reduces the boilerplate code in the callers.
    
    All trivial callers converted over.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index 807d17d863b3..64a1fcaafd9a 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -1829,18 +1829,6 @@ static int mtd_proc_show(struct seq_file *m, void *v)
 	mutex_unlock(&mtd_table_mutex);
 	return 0;
 }
-
-static int mtd_proc_open(struct inode *inode, struct file *file)
-{
-	return single_open(file, mtd_proc_show, NULL);
-}
-
-static const struct file_operations mtd_proc_ops = {
-	.open		= mtd_proc_open,
-	.read		= seq_read,
-	.llseek		= seq_lseek,
-	.release	= single_release,
-};
 #endif /* CONFIG_PROC_FS */
 
 /*====================================================================*/
@@ -1883,7 +1871,7 @@ static int __init init_mtd(void)
 		goto err_bdi;
 	}
 
-	proc_mtd = proc_create("mtd", 0, NULL, &mtd_proc_ops);
+	proc_mtd = proc_create_single("mtd", 0, NULL, mtd_proc_show);
 
 	ret = init_mtdchar();
 	if (ret)

commit 5ac67ce36cfe38b4c104a42ce52c5c8d526f1c95
Author: Rafał Miłecki <rafal@milecki.pl>
Date:   Tue Mar 27 22:35:41 2018 +0200

    mtd: move code adding (registering) partitions to the parse_mtd_partitions()
    
    This commit slightly simplifies the code. Every parse_mtd_partitions()
    caller (out of two existing ones) had to add partitions & cleanup parser
    on its own. This moves that responsibility into the function.
    
    That change also allows dropping struct mtd_partitions argument.
    
    There is one minor behavior change caused by this cleanup. If
    parse_mtd_partitions() fails to add partitions (add_mtd_partitions()
    return an error) then mtd_device_parse_register() will still try to
    add (register) fallback partitions. It's a real corner case affecting
    one of uncommon error paths and shouldn't cause any harm.
    
    Signed-off-by: Rafał Miłecki <rafal@milecki.pl>
    Signed-off-by: Boris Brezillon <boris.brezillon@bootlin.com>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index adf18b0d22b5..7b0d105627b1 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -700,7 +700,6 @@ int mtd_device_parse_register(struct mtd_info *mtd, const char * const *types,
 			      const struct mtd_partition *parts,
 			      int nr_parts)
 {
-	struct mtd_partitions parsed = { };
 	int ret;
 
 	mtd_set_dev_defaults(mtd);
@@ -712,13 +711,10 @@ int mtd_device_parse_register(struct mtd_info *mtd, const char * const *types,
 	}
 
 	/* Prefer parsed partitions over driver-provided fallback */
-	ret = parse_mtd_partitions(mtd, types, &parsed, parser_data);
-	if (!ret && parsed.nr_parts) {
-		parts = parsed.parts;
-		nr_parts = parsed.nr_parts;
-	}
-
-	if (nr_parts)
+	ret = parse_mtd_partitions(mtd, types, parser_data);
+	if (ret > 0)
+		ret = 0;
+	else if (nr_parts)
 		ret = add_mtd_partitions(mtd, parts, nr_parts);
 	else if (!device_is_registered(&mtd->dev))
 		ret = add_mtd_device(mtd);
@@ -744,8 +740,6 @@ int mtd_device_parse_register(struct mtd_info *mtd, const char * const *types,
 	}
 
 out:
-	/* Cleanup any parsed partitions */
-	mtd_part_parser_cleanup(&parsed);
 	if (ret && device_is_registered(&mtd->dev))
 		del_mtd_device(mtd);
 

commit 7cc9aa669a5119a8d70b22c57779d1decd4d0d62
Author: Xiaolei Li <xiaolei.li@mediatek.com>
Date:   Mon Apr 2 16:20:10 2018 +0800

    mtd: Add sysfs attribute for mtd OOB available size
    
    Expose mtd OOB available size by sysfs file. Then users can get available
    OOB size by accessing /sys/class/mtd/mtdX/oobavail.
    
    Signed-off-by: Xiaolei Li <xiaolei.li@mediatek.com>
    Signed-off-by: Boris Brezillon <boris.brezillon@bootlin.com>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index 807d17d863b3..adf18b0d22b5 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -210,6 +210,15 @@ static ssize_t mtd_oobsize_show(struct device *dev,
 }
 static DEVICE_ATTR(oobsize, S_IRUGO, mtd_oobsize_show, NULL);
 
+static ssize_t mtd_oobavail_show(struct device *dev,
+				 struct device_attribute *attr, char *buf)
+{
+	struct mtd_info *mtd = dev_get_drvdata(dev);
+
+	return snprintf(buf, PAGE_SIZE, "%u\n", mtd->oobavail);
+}
+static DEVICE_ATTR(oobavail, S_IRUGO, mtd_oobavail_show, NULL);
+
 static ssize_t mtd_numeraseregions_show(struct device *dev,
 		struct device_attribute *attr, char *buf)
 {
@@ -327,6 +336,7 @@ static struct attribute *mtd_attrs[] = {
 	&dev_attr_writesize.attr,
 	&dev_attr_subpagesize.attr,
 	&dev_attr_oobsize.attr,
+	&dev_attr_oobavail.attr,
 	&dev_attr_numeraseregions.attr,
 	&dev_attr_name.attr,
 	&dev_attr_ecc_strength.attr,

commit c77a93120640057bd7c3fd7eca25c427bb6de409
Author: Xiaolei Li <xiaolei.li@mediatek.com>
Date:   Thu Mar 29 09:34:58 2018 +0800

    mtd: Fix some function description mismatches in mtdcore.c
    
    In mtdcore.c, some function descriptions do not match function
    definitions. Just fix these mismatches.
    
    Signed-off-by: Xiaolei Li <xiaolei.li@mediatek.com>
    Signed-off-by: Boris Brezillon <boris.brezillon@bootlin.com>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index 20d5262c5b5c..807d17d863b3 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -419,7 +419,7 @@ int mtd_wunit_to_pairing_info(struct mtd_info *mtd, int wunit,
 EXPORT_SYMBOL_GPL(mtd_wunit_to_pairing_info);
 
 /**
- * mtd_wunit_to_pairing_info - get wunit from pairing information
+ * mtd_pairing_info_to_wunit - get wunit from pairing information
  * @mtd: pointer to new MTD device info structure
  * @info: pairing information struct
  *
@@ -1507,9 +1507,9 @@ int mtd_ooblayout_get_databytes(struct mtd_info *mtd, u8 *databuf,
 EXPORT_SYMBOL_GPL(mtd_ooblayout_get_databytes);
 
 /**
- * mtd_ooblayout_get_eccbytes - set data bytes into the oob buffer
+ * mtd_ooblayout_set_databytes - set data bytes into the oob buffer
  * @mtd: mtd info structure
- * @eccbuf: source buffer to get data bytes from
+ * @databuf: source buffer to get data bytes from
  * @oobbuf: OOB buffer
  * @start: first ECC byte to set
  * @nbytes: number of ECC bytes to set
@@ -1541,7 +1541,7 @@ int mtd_ooblayout_count_freebytes(struct mtd_info *mtd)
 EXPORT_SYMBOL_GPL(mtd_ooblayout_count_freebytes);
 
 /**
- * mtd_ooblayout_count_freebytes - count the number of ECC bytes in OOB
+ * mtd_ooblayout_count_eccbytes - count the number of ECC bytes in OOB
  * @mtd: mtd info structure
  *
  * Works like mtd_ooblayout_count_bytes(), except it count ECC bytes.

commit 55a999a04159dfb33d3d3d293a70cce766f6db27
Author: Rafał Miłecki <rafal@milecki.pl>
Date:   Tue Mar 27 15:36:47 2018 +0200

    mtd: update documentation of mtd_device_parse_register()
    
    In the commit 2c77c57d22adb ("mtd: move code adding master MTD out of
    mtd_add_device_partitions()") behavior of mtd_device_parse_register()
    has very slightly changed. It's a pretty non-significant order change
    to match updated function behavior.
    
    Signed-off-by: Rafał Miłecki <rafal@milecki.pl>
    Reviewed-by: Richard Weinberger <richard@nod.at>
    Signed-off-by: Boris Brezillon <boris.brezillon@bootlin.com>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index f25d65ea7149..20d5262c5b5c 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -673,14 +673,13 @@ static void mtd_set_dev_defaults(struct mtd_info *mtd)
  * 'parse_mtd_partitions()') and MTD device and partitions registering. It
  * basically follows the most common pattern found in many MTD drivers:
  *
- * * It first tries to probe partitions on MTD device @mtd using parsers
+ * * If the MTD_PARTITIONED_MASTER option is set, then the device as a whole is
+ *   registered first.
+ * * Then It tries to probe partitions on MTD device @mtd using parsers
  *   specified in @types (if @types is %NULL, then the default list of parsers
  *   is used, see 'parse_mtd_partitions()' for more information). If none are
  *   found this functions tries to fallback to information specified in
  *   @parts/@nr_parts.
- * * If any partitioning info was found, this function registers the found
- *   partitions. If the MTD_PARTITIONED_MASTER option is set, then the device
- *   as a whole is registered first.
  * * If no partitions were found this function just registers the MTD device
  *   @mtd and exits.
  *

commit e7bfb3fdbde3bfeeeb64e2d73ac6babe59519c9e
Author: Boris Brezillon <boris.brezillon@bootlin.com>
Date:   Mon Feb 12 22:03:11 2018 +0100

    mtd: Stop updating erase_info->state and calling mtd_erase_callback()
    
    MTD users are no longer checking erase_info->state to determine if the
    erase operation failed or succeeded. Moreover, mtd_erase_callback() is
    now a NOP.
    
    We can safely get rid of all mtd_erase_callback() calls and all
    erase_info->state assignments. While at it, get rid of the
    erase_info->state field, all MTD_ERASE_XXX definitions and the
    mtd_erase_callback() function.
    
    Signed-off-by: Boris Brezillon <boris.brezillon@bootlin.com>
    Reviewed-by: Richard Weinberger <richard@nod.at>
    Reviewed-by: Miquel Raynal <miquel.raynal@bootlin.com>
    Acked-by: Bert Kenward <bkenward@solarflare.com>
    ---
    Changes in v2:
    - Address a few coding style issues (reported by Miquel)
    - Remove comments that are no longer valid (reported by Miquel)

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index f92ad02959eb..f25d65ea7149 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -961,11 +961,9 @@ int mtd_erase(struct mtd_info *mtd, struct erase_info *instr)
 	if (!(mtd->flags & MTD_WRITEABLE))
 		return -EROFS;
 
-	if (!instr->len) {
-		instr->state = MTD_ERASE_DONE;
-		mtd_erase_callback(instr);
+	if (!instr->len)
 		return 0;
-	}
+
 	ledtrig_mtd_activity();
 	return mtd->_erase(mtd, instr);
 }

commit 884cfd9023ce6afe8bcf181ec988d8516eb32bf0
Author: Boris Brezillon <boris.brezillon@bootlin.com>
Date:   Mon Feb 12 22:03:09 2018 +0100

    mtd: Stop assuming mtd_erase() is asynchronous
    
    None of the mtd->_erase() implementations work in an asynchronous manner,
    so let's simplify MTD users that call mtd_erase(). All they need to do
    is check the value returned by mtd_erase() and assume that != 0 means
    failure.
    
    Signed-off-by: Boris Brezillon <boris.brezillon@bootlin.com>
    Reviewed-by: Richard Weinberger <richard@nod.at>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index c87859ff338b..f92ad02959eb 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -945,11 +945,9 @@ void __put_mtd_device(struct mtd_info *mtd)
 EXPORT_SYMBOL_GPL(__put_mtd_device);
 
 /*
- * Erase is an asynchronous operation.  Device drivers are supposed
- * to call instr->callback() whenever the operation completes, even
- * if it completes with a failure.
- * Callers are supposed to pass a callback function and wait for it
- * to be called before writing to the block.
+ * Erase is an synchronous operation. Device drivers are epected to return a
+ * negative error code if the operation failed and update instr->fail_addr
+ * to point the portion that was not properly erased.
  */
 int mtd_erase(struct mtd_info *mtd, struct erase_info *instr)
 {

commit c585da9f5f6186739f0b123b8a5b6353e425f51b
Author: Boris Brezillon <boris.brezillon@bootlin.com>
Date:   Mon Feb 12 22:03:07 2018 +0100

    mtd: Initialize ->fail_addr early in mtd_erase()
    
    mtd_erase() can return an error before ->fail_addr is initialized to
    MTD_FAIL_ADDR_UNKNOWN. Move this initialization at the very beginning
    of the function.
    
    Signed-off-by: Boris Brezillon <boris.brezillon@bootlin.com>
    Reviewed-by: Richard Weinberger <richard@nod.at>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index a1c94526fb88..c87859ff338b 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -953,6 +953,8 @@ EXPORT_SYMBOL_GPL(__put_mtd_device);
  */
 int mtd_erase(struct mtd_info *mtd, struct erase_info *instr)
 {
+	instr->fail_addr = MTD_FAIL_ADDR_UNKNOWN;
+
 	if (!mtd->erasesize || !mtd->_erase)
 		return -ENOTSUPP;
 
@@ -961,7 +963,6 @@ int mtd_erase(struct mtd_info *mtd, struct erase_info *instr)
 	if (!(mtd->flags & MTD_WRITEABLE))
 		return -EROFS;
 
-	instr->fail_addr = MTD_FAIL_ADDR_UNKNOWN;
 	if (!instr->len) {
 		instr->state = MTD_ERASE_DONE;
 		mtd_erase_callback(instr);

commit 0dbe4ea78d69756efeb0bba0764f6bd4a9ee9567
Author: Rafał Miłecki <rafal@milecki.pl>
Date:   Tue Jan 16 16:45:42 2018 +0100

    mtd: get rid of the mtd_add_device_partitions()
    
    This simplifies code a bit by:
    1) Avoiding an extra (tiny) function
    2) Checking for amount of parsed (found) partitions just once
    3) Avoiding clearing/filling struct mtd_partitions manually
    
    With this commit proper functions are called directly from the
    mtd_device_parse_register(). It doesn't need to use minor tricks like
    memsetting struct to 0 to trigger an expected
    mtd_add_device_partitions() behavior.
    
    Signed-off-by: Rafał Miłecki <rafal@milecki.pl>
    Signed-off-by: Boris Brezillon <boris.brezillon@bootlin.com>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index c6a53a1e55d9..a1c94526fb88 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -641,21 +641,6 @@ int del_mtd_device(struct mtd_info *mtd)
 	return ret;
 }
 
-static int mtd_add_device_partitions(struct mtd_info *mtd,
-				     struct mtd_partitions *parts)
-{
-	const struct mtd_partition *real_parts = parts->parts;
-	int nbparts = parts->nr_parts;
-
-	if (!nbparts && !device_is_registered(&mtd->dev))
-		return add_mtd_device(mtd);
-
-	if (nbparts > 0)
-		return add_mtd_partitions(mtd, real_parts, nbparts);
-
-	return 0;
-}
-
 /*
  * Set a few defaults based on the parent devices, if not provided by the
  * driver
@@ -706,7 +691,7 @@ int mtd_device_parse_register(struct mtd_info *mtd, const char * const *types,
 			      const struct mtd_partition *parts,
 			      int nr_parts)
 {
-	struct mtd_partitions parsed;
+	struct mtd_partitions parsed = { };
 	int ret;
 
 	mtd_set_dev_defaults(mtd);
@@ -717,24 +702,20 @@ int mtd_device_parse_register(struct mtd_info *mtd, const char * const *types,
 			return ret;
 	}
 
-	memset(&parsed, 0, sizeof(parsed));
-
+	/* Prefer parsed partitions over driver-provided fallback */
 	ret = parse_mtd_partitions(mtd, types, &parsed, parser_data);
-	if ((ret < 0 || parsed.nr_parts == 0) && parts && nr_parts) {
-		/* Fall back to driver-provided partitions */
-		parsed = (struct mtd_partitions){
-			.parts		= parts,
-			.nr_parts	= nr_parts,
-		};
-	} else if (ret < 0) {
-		/* Didn't come up with parsed OR fallback partitions */
-		pr_info("mtd: failed to find partitions; one or more parsers reports errors (%d)\n",
-			ret);
-		/* Don't abort on errors; we can still use unpartitioned MTD */
-		memset(&parsed, 0, sizeof(parsed));
+	if (!ret && parsed.nr_parts) {
+		parts = parsed.parts;
+		nr_parts = parsed.nr_parts;
 	}
 
-	ret = mtd_add_device_partitions(mtd, &parsed);
+	if (nr_parts)
+		ret = add_mtd_partitions(mtd, parts, nr_parts);
+	else if (!device_is_registered(&mtd->dev))
+		ret = add_mtd_device(mtd);
+	else
+		ret = 0;
+
 	if (ret)
 		goto out;
 

commit 2c77c57d22adb05b21cdb333a0c42bdfa0e19835
Author: Rafał Miłecki <rafal@milecki.pl>
Date:   Tue Jan 16 16:45:41 2018 +0100

    mtd: move code adding master MTD out of mtd_add_device_partitions()
    
    This change is a small cleanup of mtd_device_parse_register(). When
    using MTD_PARTITIONED_MASTER it makes sure a master MTD is registered
    before dealing with partitions. The advantage of this is not mixing
    code handling master MTD with code handling partitions.
    
    This commit doesn't change any behavior except from a slightly different
    failure code path. The new code may need to call del_mtd_device when
    something goes wrong.
    
    Signed-off-by: Rafał Miłecki <rafal@milecki.pl>
    Signed-off-by: Boris Brezillon <boris.brezillon@bootlin.com>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index 56cb037a1052..c6a53a1e55d9 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -646,20 +646,12 @@ static int mtd_add_device_partitions(struct mtd_info *mtd,
 {
 	const struct mtd_partition *real_parts = parts->parts;
 	int nbparts = parts->nr_parts;
-	int ret;
 
-	if (nbparts == 0 || IS_ENABLED(CONFIG_MTD_PARTITIONED_MASTER)) {
-		ret = add_mtd_device(mtd);
-		if (ret)
-			return ret;
-	}
+	if (!nbparts && !device_is_registered(&mtd->dev))
+		return add_mtd_device(mtd);
 
-	if (nbparts > 0) {
-		ret = add_mtd_partitions(mtd, real_parts, nbparts);
-		if (ret && IS_ENABLED(CONFIG_MTD_PARTITIONED_MASTER))
-			del_mtd_device(mtd);
-		return ret;
-	}
+	if (nbparts > 0)
+		return add_mtd_partitions(mtd, real_parts, nbparts);
 
 	return 0;
 }
@@ -719,6 +711,12 @@ int mtd_device_parse_register(struct mtd_info *mtd, const char * const *types,
 
 	mtd_set_dev_defaults(mtd);
 
+	if (IS_ENABLED(CONFIG_MTD_PARTITIONED_MASTER)) {
+		ret = add_mtd_device(mtd);
+		if (ret)
+			return ret;
+	}
+
 	memset(&parsed, 0, sizeof(parsed));
 
 	ret = parse_mtd_partitions(mtd, types, &parsed, parser_data);
@@ -758,6 +756,9 @@ int mtd_device_parse_register(struct mtd_info *mtd, const char * const *types,
 out:
 	/* Cleanup any parsed partitions */
 	mtd_part_parser_cleanup(&parsed);
+	if (ret && device_is_registered(&mtd->dev))
+		del_mtd_device(mtd);
+
 	return ret;
 }
 EXPORT_SYMBOL_GPL(mtd_device_parse_register);

commit e6e620f0e15e3bc4b3bc3078c9f3285830f2fd3c
Author: Boris Brezillon <boris.brezillon@free-electrons.com>
Date:   Mon Jan 22 10:38:01 2018 +0100

    mtd: Make sure the device supports erase operations in mtd_erase()
    
    Some devices do not implement ->_erase() or have an invalid ->erasesize
    value. In this case, mtd_erase() should return -ENOTSUPP.
    
    Note that the test is not done on the MTD_NO_ERASE flag because this
    flag means 'erasing a block before writing to it is unnecessary',
    not 'the erase operation is not supported'. Actually, some drivers are
    setting the MTD_NO_ERASE flag but still implementing the ->_erase()
    hook and setting a valid ->erasesize value.
    
    Signed-off-by: Boris Brezillon <boris.brezillon@free-electrons.com>
    Reviewed-by: Miquel Raynal <miquel.raynal@free-electrons.com>
    Signed-off-by: Boris Brezillon <boris.brezillon@bootlin.com>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index 28553c840d32..56cb037a1052 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -971,10 +971,14 @@ EXPORT_SYMBOL_GPL(__put_mtd_device);
  */
 int mtd_erase(struct mtd_info *mtd, struct erase_info *instr)
 {
+	if (!mtd->erasesize || !mtd->_erase)
+		return -ENOTSUPP;
+
 	if (instr->addr >= mtd->size || instr->len > mtd->size - instr->addr)
 		return -EINVAL;
 	if (!(mtd->flags & MTD_WRITEABLE))
 		return -EROFS;
+
 	instr->fail_addr = MTD_FAIL_ADDR_UNKNOWN;
 	if (!instr->len) {
 		instr->state = MTD_ERASE_DONE;

commit 0fc7e74663447682c904fe375bb680b004ddaa14
Merge: aa5e75bc7a7c 571cb17b23ec
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Jan 29 11:11:56 2018 -0800

    Merge tag 'mtd/for-4.16' of git://git.infradead.org/linux-mtd
    
    Pull MTD updates from Boris Brezillon:
     "MTD core changes:
       - Rework core functions to avoid duplicating generic checks in
         NAND/OneNAND sub-layers
       - Update the MAINTAINERS entry to reflect the fact that MTD
         maintainers now use a single git tree
    
      MTD driver changes:
       - CFI: use macros instead of inline functions to limit stack usage
         and make KASAN happy
    
      NAND core changes:
       - Fix NAND_CMD_NONE handling in nand_command[_lp]() hooks
       - Introduce the ->exec_op() infrastructure
       - Rework NAND buffers handling
       - Fix ECC requirements for K9F4G08U0D
       - Fix nand_do_read_oob() to return the number of bitflips
       - Mark K9F1G08U0E as not supporting subpage writes
    
      NAND driver changes:
       - MTK: Rework the driver to support new IP versions
       - OMAP OneNAND: Full rework to use new APIs (libgpio, dmaengine) and
         fix DT support
       - Marvell: Add a new driver to replace the pxa3xx one
    
      SPI NOR core changes:
       - Add support to new ISSI and Cypress/Spansion memory parts.
       - Fix support of Micron memories by checking error bits in the FSR.
       - Fix update of block-protection bits by reading back the SR.
       - Restore the internal state of the SPI flash memory when removing
         the device.
    
      SPI NOR driver changes:
       - Maintenance for Freescale, Intel and Metiatek drivers.
       - Add support of the direct access mode for the Cadence QSPI
         controller"
    
    * tag 'mtd/for-4.16' of git://git.infradead.org/linux-mtd: (93 commits)
      mtd: nand: sunxi: Fix ECC strength choice
      mtd: nand: gpmi: Fix subpage reads
      mtd: nand: Fix build issues due to an anonymous union
      mtd: nand: marvell: Fix missing memory allocation modifier
      mtd: nand: marvell: remove redundant variable 'oob_len'
      mtd: nand: marvell: fix spelling mistake: "suceed"-> "succeed"
      mtd: onenand: omap2: Remove redundant dev_err call in omap2_onenand_probe()
      mtd: Remove duplicate checks on mtd_oob_ops parameter
      mtd: Fallback to ->_read/write_oob() when ->_read/write() is missing
      mtd: mtdpart: Make ECC stat handling consistent
      mtd: onenand: omap2: print resource using %pR format string
      mtd: mtk-nor: modify functions' name more generally
      mtd: onenand: samsung: remove incorrect __iomem annotation
      MAINTAINERS: Add entry for Marvell NAND controller driver
      ARM: OMAP2+: Remove gpmc-onenand
      mtd: onenand: omap2: Configure driver from DT
      mtd: onenand: omap2: Decouple DMA enabling from INT pin availability
      mtd: onenand: omap2: Do not make delay for GPIO OMAP3 specific
      mtd: onenand: omap2: Convert to use dmaengine for memcpy
      mtd: onenand: omap2: Unify OMAP2 and OMAP3 DMA implementation
      ...

commit 24ff12922278573b1e4c54b4898ab7a3c64be960
Author: Boris Brezillon <boris.brezillon@free-electrons.com>
Date:   Tue Jan 9 09:50:34 2018 +0100

    mtd: Fallback to ->_read/write_oob() when ->_read/write() is missing
    
    Some MTD sublayers/drivers are implementing ->_read/write_oob() and
    provide dummy wrappers for their ->_read/write() implementations.
    Let the core handle this case instead of duplicating the logic.
    
    Signed-off-by: Boris Brezillon <boris.brezillon@free-electrons.com>
    Acked-by: Robert Jarzmik <robert.jarzmik@free.fr>
    Acked-by: Brian Norris <computersforpeace@gmail.com>
    Reviewed-by: Miquel Raynal <miquel.raynal@free-electrons.com>
    Tested-by: Ladislav Michl <ladis@linux-mips.org>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index 642c35dde686..d7ab091b36b2 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -1058,7 +1058,20 @@ int mtd_read(struct mtd_info *mtd, loff_t from, size_t len, size_t *retlen,
 	 * representing the maximum number of bitflips that were corrected on
 	 * any one ecc region (if applicable; zero otherwise).
 	 */
-	ret_code = mtd->_read(mtd, from, len, retlen, buf);
+	if (mtd->_read) {
+		ret_code = mtd->_read(mtd, from, len, retlen, buf);
+	} else if (mtd->_read_oob) {
+		struct mtd_oob_ops ops = {
+			.len = len,
+			.datbuf = buf,
+		};
+
+		ret_code = mtd->_read_oob(mtd, from, &ops);
+		*retlen = ops.retlen;
+	} else {
+		return -ENOTSUPP;
+	}
+
 	if (unlikely(ret_code < 0))
 		return ret_code;
 	if (mtd->ecc_strength == 0)
@@ -1073,11 +1086,25 @@ int mtd_write(struct mtd_info *mtd, loff_t to, size_t len, size_t *retlen,
 	*retlen = 0;
 	if (to < 0 || to >= mtd->size || len > mtd->size - to)
 		return -EINVAL;
-	if (!mtd->_write || !(mtd->flags & MTD_WRITEABLE))
+	if ((!mtd->_write && !mtd->_write_oob) ||
+	    !(mtd->flags & MTD_WRITEABLE))
 		return -EROFS;
 	if (!len)
 		return 0;
 	ledtrig_mtd_activity();
+
+	if (!mtd->_write) {
+		struct mtd_oob_ops ops = {
+			.len = len,
+			.datbuf = (u8 *)buf,
+		};
+		int ret;
+
+		ret = mtd->_write_oob(mtd, to, &ops);
+		*retlen = ops.retlen;
+		return ret;
+	}
+
 	return mtd->_write(mtd, to, len, retlen, buf);
 }
 EXPORT_SYMBOL_GPL(mtd_write);

commit 33f45c44d68b3593826524ba6d02bd9cce9e101e
Author: Boris Brezillon <boris.brezillon@free-electrons.com>
Date:   Fri Dec 15 13:39:51 2017 +0100

    mtd: Do not allow MTD devices with inconsistent erase properties
    
    When mtd->erasesize is 0 or mtd->_erase is NULL, that means the device
    does not support the erase operation, which in turn means it should
    have the MTD_NO_ERASE flag set.
    
    Signed-off-by: Boris Brezillon <boris.brezillon@free-electrons.com>
    Reviewed-by: Miquel Raynal <miquel.raynal@free-electrons.com>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index f80e911b8843..642c35dde686 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -503,6 +503,11 @@ int add_mtd_device(struct mtd_info *mtd)
 		return -EEXIST;
 
 	BUG_ON(mtd->writesize == 0);
+
+	if (WARN_ON((!mtd->erasesize || !mtd->_erase) &&
+		    !(mtd->flags & MTD_NO_ERASE)))
+		return -EINVAL;
+
 	mutex_lock(&mtd_table_mutex);
 
 	i = idr_alloc(&mtd_idr, mtd, 0, 0, GFP_KERNEL);

commit d82c3682168431d29ba1741d0cd5ef45c68bf8e0
Author: Miquel Raynal <miquel.raynal@free-electrons.com>
Date:   Mon Dec 18 08:26:28 2017 +0100

    mtd: Fix mtd_check_oob_ops()
    
    The mtd_check_oob_ops() helper verifies if the operation defined by the
    user is correct.
    
    Fix the check that verifies if the entire requested area exists. This
    check is too restrictive and will fail anytime the last data byte of the
    very last page is included in an operation.
    
    Fixes: 5cdd929da53d ("mtd: Add sanity checks in mtd_write/read_oob()")
    Signed-off-by: Miquel Raynal <miquel.raynal@free-electrons.com>
    Acked-by: Boris Brezillon <boris.brezillon@free-electrons.com>
    Signed-off-by: Richard Weinberger <richard@nod.at>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index f80e911b8843..73b605577447 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -1114,7 +1114,7 @@ static int mtd_check_oob_ops(struct mtd_info *mtd, loff_t offs,
 	if (!ops->oobbuf)
 		ops->ooblen = 0;
 
-	if (offs < 0 || offs + ops->len >= mtd->size)
+	if (offs < 0 || offs + ops->len > mtd->size)
 		return -EINVAL;
 
 	if (ops->ooblen) {

commit 5cdd929da53dd7347ec86afd94c3b840909c461e
Author: Boris Brezillon <boris.brezillon@free-electrons.com>
Date:   Tue Jun 27 21:22:21 2017 +0200

    mtd: Add sanity checks in mtd_write/read_oob()
    
    Unlike what's done in mtd_read/write(), there are no checks to make sure
    the parameters passed to mtd_read/write_oob() are consistent, which
    forces implementers of ->_read/write_oob() to do it, which in turn leads
    to code duplication and possibly errors in the logic.
    
    Do general sanity checks, like ops fields consistency and range checking.
    
    Signed-off-by: Boris Brezillon <boris.brezillon@free-electrons.com>
    Cc: Peter Pan <peterpandong@micron.com>
    Signed-off-by: Richard Weinberger <richard@nod.at>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index ecb0380158f9..f80e911b8843 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -1100,6 +1100,39 @@ int mtd_panic_write(struct mtd_info *mtd, loff_t to, size_t len, size_t *retlen,
 }
 EXPORT_SYMBOL_GPL(mtd_panic_write);
 
+static int mtd_check_oob_ops(struct mtd_info *mtd, loff_t offs,
+			     struct mtd_oob_ops *ops)
+{
+	/*
+	 * Some users are setting ->datbuf or ->oobbuf to NULL, but are leaving
+	 * ->len or ->ooblen uninitialized. Force ->len and ->ooblen to 0 in
+	 *  this case.
+	 */
+	if (!ops->datbuf)
+		ops->len = 0;
+
+	if (!ops->oobbuf)
+		ops->ooblen = 0;
+
+	if (offs < 0 || offs + ops->len >= mtd->size)
+		return -EINVAL;
+
+	if (ops->ooblen) {
+		u64 maxooblen;
+
+		if (ops->ooboffs >= mtd_oobavail(mtd, ops))
+			return -EINVAL;
+
+		maxooblen = ((mtd_div_by_ws(mtd->size, mtd) -
+			      mtd_div_by_ws(offs, mtd)) *
+			     mtd_oobavail(mtd, ops)) - ops->ooboffs;
+		if (ops->ooblen > maxooblen)
+			return -EINVAL;
+	}
+
+	return 0;
+}
+
 int mtd_read_oob(struct mtd_info *mtd, loff_t from, struct mtd_oob_ops *ops)
 {
 	int ret_code;
@@ -1107,6 +1140,10 @@ int mtd_read_oob(struct mtd_info *mtd, loff_t from, struct mtd_oob_ops *ops)
 	if (!mtd->_read_oob)
 		return -EOPNOTSUPP;
 
+	ret_code = mtd_check_oob_ops(mtd, from, ops);
+	if (ret_code)
+		return ret_code;
+
 	ledtrig_mtd_activity();
 	/*
 	 * In cases where ops->datbuf != NULL, mtd->_read_oob() has semantics
@@ -1126,11 +1163,18 @@ EXPORT_SYMBOL_GPL(mtd_read_oob);
 int mtd_write_oob(struct mtd_info *mtd, loff_t to,
 				struct mtd_oob_ops *ops)
 {
+	int ret;
+
 	ops->retlen = ops->oobretlen = 0;
 	if (!mtd->_write_oob)
 		return -EOPNOTSUPP;
 	if (!(mtd->flags & MTD_WRITEABLE))
 		return -EROFS;
+
+	ret = mtd_check_oob_ops(mtd, to, ops);
+	if (ret)
+		return ret;
+
 	ledtrig_mtd_activity();
 	return mtd->_write_oob(mtd, to, ops);
 }

commit 9eaa903c06f9f3129f862ef60ce106e4c3211288
Author: Nicolas Pitre <nicolas.pitre@linaro.org>
Date:   Mon Oct 30 14:48:32 2017 -0400

    mtd: implement mtd_get_unmapped_area() using the point method
    
    The mtd->_point method is a superset of mtd->_get_unmapped_area.
    Especially in the NOR flash case, the point method ensures the flash
    memory is in array (data) mode and that it will stay that way which
    is precisely what callers of mtd_get_unmapped_area() would expect.
    
    Implement mtd_get_unmapped_area() in terms of mtd->_point now that all
    drivers that provided a _get_unmapped_area method also have the _point
    method implemented.
    
    Signed-off-by: Nicolas Pitre <nico@linaro.org>
    Reviewed-by: Richard Weinberger <richard@nod.at>
    Acked-by: Boris Brezillon <boris.brezillon@free-electrons.com>
    Signed-off-by: Richard Weinberger <richard@nod.at>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index e7ea842ba3db..ecb0380158f9 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -1022,11 +1022,18 @@ EXPORT_SYMBOL_GPL(mtd_unpoint);
 unsigned long mtd_get_unmapped_area(struct mtd_info *mtd, unsigned long len,
 				    unsigned long offset, unsigned long flags)
 {
-	if (!mtd->_get_unmapped_area)
-		return -EOPNOTSUPP;
-	if (offset >= mtd->size || len > mtd->size - offset)
-		return -EINVAL;
-	return mtd->_get_unmapped_area(mtd, len, offset, flags);
+	size_t retlen;
+	void *virt;
+	int ret;
+
+	ret = mtd_point(mtd, offset, len, &retlen, &virt, NULL);
+	if (ret)
+		return ret;
+	if (retlen != len) {
+		mtd_unpoint(mtd, offset, retlen);
+		return -ENOSYS;
+	}
+	return (unsigned long)virt;
 }
 EXPORT_SYMBOL_GPL(mtd_get_unmapped_area);
 

commit 75864b301c91bf41ec2fb49ce4efb62fcb48b954
Author: Bhumika Goyal <bhumirks@gmail.com>
Date:   Sat Aug 19 13:52:17 2017 +0530

    mtd: make device_type const
    
    Make this const as it is only stored in the type field of a device
    structure, which is const.
    Done using Coccinelle.
    
    Signed-off-by: Bhumika Goyal <bhumirks@gmail.com>
    Signed-off-by: Boris Brezillon <boris.brezillon@free-electrons.com>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index f872a99501ed..e7ea842ba3db 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -340,7 +340,7 @@ static struct attribute *mtd_attrs[] = {
 };
 ATTRIBUTE_GROUPS(mtd);
 
-static struct device_type mtd_devtype = {
+static const struct device_type mtd_devtype = {
 	.name		= "mtd",
 	.groups		= mtd_groups,
 	.release	= mtd_release,

commit e8e3edb95ce6a146bc774b6cfad3553f4383edc8
Author: Mario Rugiero <mrugiero@gmail.com>
Date:   Mon May 29 08:38:41 2017 -0300

    mtd: create per-device and module-scope debugfs entries
    
    Several MTD devices are using debugfs entries created in the root.
    This commit provides the means for a standardized subtree, creating
    one "mtd" entry at root, and one entry per device inside it, named
    after the device.
    The tree is registered in add_mtd_device, and released in
    del_mtd_device.
    Devices docg3, mtdswap and nandsim were updated to use this subtree
    instead of custom ones, and their entries were prefixed with the
    drivers' names.
    
    Signed-off-by: Mario J. Rugiero <mrugiero@gmail.com>
    Acked-by: Boris Brezillon <boris.brezillon@free-electrons.com>
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index 956382cea256..f872a99501ed 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -40,6 +40,7 @@
 #include <linux/slab.h>
 #include <linux/reboot.h>
 #include <linux/leds.h>
+#include <linux/debugfs.h>
 
 #include <linux/mtd/mtd.h>
 #include <linux/mtd/partitions.h>
@@ -477,6 +478,8 @@ int mtd_pairing_groups(struct mtd_info *mtd)
 }
 EXPORT_SYMBOL_GPL(mtd_pairing_groups);
 
+static struct dentry *dfs_dir_mtd;
+
 /**
  *	add_mtd_device - register an MTD device
  *	@mtd: pointer to new MTD device info structure
@@ -552,6 +555,14 @@ int add_mtd_device(struct mtd_info *mtd)
 	if (error)
 		goto fail_added;
 
+	if (!IS_ERR_OR_NULL(dfs_dir_mtd)) {
+		mtd->dbg.dfs_dir = debugfs_create_dir(dev_name(&mtd->dev), dfs_dir_mtd);
+		if (IS_ERR_OR_NULL(mtd->dbg.dfs_dir)) {
+			pr_debug("mtd device %s won't show data in debugfs\n",
+				 dev_name(&mtd->dev));
+		}
+	}
+
 	device_create(&mtd_class, mtd->dev.parent, MTD_DEVT(i) + 1, NULL,
 		      "mtd%dro", i);
 
@@ -594,6 +605,8 @@ int del_mtd_device(struct mtd_info *mtd)
 
 	mutex_lock(&mtd_table_mutex);
 
+	debugfs_remove_recursive(mtd->dbg.dfs_dir);
+
 	if (idr_find(&mtd_idr, mtd->index) != mtd) {
 		ret = -ENODEV;
 		goto out_error;
@@ -1811,6 +1824,8 @@ static int __init init_mtd(void)
 	if (ret)
 		goto out_procfs;
 
+	dfs_dir_mtd = debugfs_create_dir("mtd", NULL);
+
 	return 0;
 
 out_procfs:
@@ -1826,6 +1841,7 @@ static int __init init_mtd(void)
 
 static void __exit cleanup_mtd(void)
 {
+	debugfs_remove_recursive(dfs_dir_mtd);
 	cleanup_mtdchar();
 	if (proc_mtd)
 		remove_proc_entry("mtd", NULL);

commit b9504247a6eb2bd68e3f620ca1f3fbe7309123ea
Author: Boris Brezillon <boris.brezillon@free-electrons.com>
Date:   Sun Jun 25 20:22:57 2017 +0200

    mtd: Fix check in mtd_unpoint()
    
    The code checks that ->_point is not NULL, but we should actually check
    ->_unpoint value which is dereferenced a few lines after the check.
    
    Signed-off-by: Boris Brezillon <boris.brezillon@free-electrons.com>
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index 1517da3ddd7d..956382cea256 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -991,7 +991,7 @@ EXPORT_SYMBOL_GPL(mtd_point);
 /* We probably shouldn't allow XIP if the unpoint isn't a NULL */
 int mtd_unpoint(struct mtd_info *mtd, loff_t from, size_t len)
 {
-	if (!mtd->_point)
+	if (!mtd->_unpoint)
 		return -EOPNOTSUPP;
 	if (from < 0 || from >= mtd->size || len > mtd->size - from)
 		return -EINVAL;

commit 7c4cc30024946dae9530cd6dc0d8d4eb40fca173
Author: Jan Kara <jack@suse.cz>
Date:   Wed Apr 12 12:24:49 2017 +0200

    bdi: Drop 'parent' argument from bdi_register[_va]()
    
    Drop 'parent' argument of bdi_register() and bdi_register_va().  It is
    always NULL.
    
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Jan Kara <jack@suse.cz>
    Signed-off-by: Jens Axboe <axboe@fb.com>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index 23e2e56ca54e..1517da3ddd7d 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -1782,7 +1782,7 @@ static struct backing_dev_info * __init mtd_bdi_init(char *name)
 	 * We put '-0' suffix to the name to get the same name format as we
 	 * used to get. Since this is called only once, we get a unique name. 
 	 */
-	ret = bdi_register(bdi, NULL, "%.28s-0", name);
+	ret = bdi_register(bdi, "%.28s-0", name);
 	if (ret)
 		bdi_put(bdi);
 

commit fa06052d637bf3a76f18cd2304048b866af4096e
Author: Jan Kara <jack@suse.cz>
Date:   Wed Apr 12 12:24:37 2017 +0200

    mtd: Convert to dynamically allocated bdi infrastructure
    
    MTD already allocates backing_dev_info dynamically. Convert it to use
    generic infrastructure for this including proper refcounting. We drop
    mtd->backing_dev_info as its only use was to pass mtd_bdi pointer from
    one file into another and if we wanted to keep that in a clean way, we'd
    have to make mtd hold and drop bdi reference as needed which seems
    pointless for passing one global pointer...
    
    CC: David Woodhouse <dwmw2@infradead.org>
    CC: Brian Norris <computersforpeace@gmail.com>
    CC: linux-mtd@lists.infradead.org
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Jan Kara <jack@suse.cz>
    Signed-off-by: Jens Axboe <axboe@fb.com>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index 66a9dedd1062..23e2e56ca54e 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -46,7 +46,7 @@
 
 #include "mtdcore.h"
 
-static struct backing_dev_info *mtd_bdi;
+struct backing_dev_info *mtd_bdi;
 
 #ifdef CONFIG_PM_SLEEP
 
@@ -496,11 +496,9 @@ int add_mtd_device(struct mtd_info *mtd)
 	 * mtd_device_parse_register() multiple times on the same master MTD,
 	 * especially with CONFIG_MTD_PARTITIONED_MASTER=y.
 	 */
-	if (WARN_ONCE(mtd->backing_dev_info, "MTD already registered\n"))
+	if (WARN_ONCE(mtd->dev.type, "MTD already registered\n"))
 		return -EEXIST;
 
-	mtd->backing_dev_info = mtd_bdi;
-
 	BUG_ON(mtd->writesize == 0);
 	mutex_lock(&mtd_table_mutex);
 
@@ -1775,13 +1773,18 @@ static struct backing_dev_info * __init mtd_bdi_init(char *name)
 	struct backing_dev_info *bdi;
 	int ret;
 
-	bdi = kzalloc(sizeof(*bdi), GFP_KERNEL);
+	bdi = bdi_alloc(GFP_KERNEL);
 	if (!bdi)
 		return ERR_PTR(-ENOMEM);
 
-	ret = bdi_setup_and_register(bdi, name);
+	bdi->name = name;
+	/*
+	 * We put '-0' suffix to the name to get the same name format as we
+	 * used to get. Since this is called only once, we get a unique name. 
+	 */
+	ret = bdi_register(bdi, NULL, "%.28s-0", name);
 	if (ret)
-		kfree(bdi);
+		bdi_put(bdi);
 
 	return ret ? ERR_PTR(ret) : bdi;
 }
@@ -1813,8 +1816,7 @@ static int __init init_mtd(void)
 out_procfs:
 	if (proc_mtd)
 		remove_proc_entry("mtd", NULL);
-	bdi_destroy(mtd_bdi);
-	kfree(mtd_bdi);
+	bdi_put(mtd_bdi);
 err_bdi:
 	class_unregister(&mtd_class);
 err_reg:
@@ -1828,8 +1830,7 @@ static void __exit cleanup_mtd(void)
 	if (proc_mtd)
 		remove_proc_entry("mtd", NULL);
 	class_unregister(&mtd_class);
-	bdi_destroy(mtd_bdi);
-	kfree(mtd_bdi);
+	bdi_put(mtd_bdi);
 	idr_destroy(&mtd_idr);
 }
 

commit 7da0fffb3a4cb76a4869bf12acb750a4f9e2f2c1
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Wed Dec 14 09:31:01 2016 +0900

    mtd: fix typos in ooblayout comment blocks
    
    - "This functions return ..." -> "This function returns ..."
     - "I you want ..." -> "If you want ..."
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Acked-by: Boris Brezillon <boris.brezillon@free-electrons.com>
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index 052772f7caef..66a9dedd1062 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -1128,7 +1128,7 @@ EXPORT_SYMBOL_GPL(mtd_write_oob);
  * @oobecc: OOB region struct filled with the appropriate ECC position
  *	    information
  *
- * This functions return ECC section information in the OOB area. I you want
+ * This function returns ECC section information in the OOB area. If you want
  * to get all the ECC bytes information, then you should call
  * mtd_ooblayout_ecc(mtd, section++, oobecc) until it returns -ERANGE.
  *
@@ -1160,7 +1160,7 @@ EXPORT_SYMBOL_GPL(mtd_ooblayout_ecc);
  * @oobfree: OOB region struct filled with the appropriate free position
  *	     information
  *
- * This functions return free bytes position in the OOB area. I you want
+ * This function returns free bytes position in the OOB area. If you want
  * to get all the free bytes information, then you should call
  * mtd_ooblayout_free(mtd, section++, oobfree) until it returns -ERANGE.
  *
@@ -1190,7 +1190,7 @@ EXPORT_SYMBOL_GPL(mtd_ooblayout_free);
  * @iter: iterator function. Should be either mtd_ooblayout_free or
  *	  mtd_ooblayout_ecc depending on the region type you're searching for
  *
- * This functions returns the section id and oobregion information of a
+ * This function returns the section id and oobregion information of a
  * specific byte. For example, say you want to know where the 4th ECC byte is
  * stored, you'll use:
  *

commit 445caaa20c4d6da74f426464f90513b81157ad77
Author: Steve Longerbeam <steve_longerbeam@mentor.com>
Date:   Thu Aug 4 19:31:15 2016 +0530

    mtd: Allocate bdi objects dynamically
    
    The MTD backing dev info objects mtd_bdi was statically allocated.
    So when MTD is built as a loadable module, this object fall in the
    vmalloc address space.
    
    The problem with that, is that the BDI APIs use wake_up_bit(), which calls
    virt_to_page() to retrieve the memory zone of the page containing the
    wait_queue to wake up, and virt_to_page() is not valid for vmalloc or
    highmem addresses.
    
    Fix this by allocating the BDI objects dynamically with kmalloc. The
    objects now fall in the logical address space so that BDI APIs will
    work in all cases (mtd builtin or module).
    
    Signed-off-by: Steve Longerbeam <steve_longerbeam@mentor.com>
    Signed-off-by: Jim Baxter <jim_baxter@mentor.com>
    Signed-off-by: Sandeep Jain <Sandeep_Jain@mentor.com>
    Reviewed-by: Richard Weinberger <richard@nod.at>
    Reviewed-by: Marek Vasut <marek.vasut@gmail.com>
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index ca661cee9b77..052772f7caef 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -46,8 +46,7 @@
 
 #include "mtdcore.h"
 
-static struct backing_dev_info mtd_bdi = {
-};
+static struct backing_dev_info *mtd_bdi;
 
 #ifdef CONFIG_PM_SLEEP
 
@@ -500,7 +499,7 @@ int add_mtd_device(struct mtd_info *mtd)
 	if (WARN_ONCE(mtd->backing_dev_info, "MTD already registered\n"))
 		return -EEXIST;
 
-	mtd->backing_dev_info = &mtd_bdi;
+	mtd->backing_dev_info = mtd_bdi;
 
 	BUG_ON(mtd->writesize == 0);
 	mutex_lock(&mtd_table_mutex);
@@ -1771,18 +1770,20 @@ static const struct file_operations mtd_proc_ops = {
 /*====================================================================*/
 /* Init code */
 
-static int __init mtd_bdi_init(struct backing_dev_info *bdi, const char *name)
+static struct backing_dev_info * __init mtd_bdi_init(char *name)
 {
+	struct backing_dev_info *bdi;
 	int ret;
 
-	ret = bdi_init(bdi);
-	if (!ret)
-		ret = bdi_register(bdi, NULL, "%s", name);
+	bdi = kzalloc(sizeof(*bdi), GFP_KERNEL);
+	if (!bdi)
+		return ERR_PTR(-ENOMEM);
 
+	ret = bdi_setup_and_register(bdi, name);
 	if (ret)
-		bdi_destroy(bdi);
+		kfree(bdi);
 
-	return ret;
+	return ret ? ERR_PTR(ret) : bdi;
 }
 
 static struct proc_dir_entry *proc_mtd;
@@ -1795,9 +1796,11 @@ static int __init init_mtd(void)
 	if (ret)
 		goto err_reg;
 
-	ret = mtd_bdi_init(&mtd_bdi, "mtd");
-	if (ret)
+	mtd_bdi = mtd_bdi_init("mtd");
+	if (IS_ERR(mtd_bdi)) {
+		ret = PTR_ERR(mtd_bdi);
 		goto err_bdi;
+	}
 
 	proc_mtd = proc_create("mtd", 0, NULL, &mtd_proc_ops);
 
@@ -1810,6 +1813,8 @@ static int __init init_mtd(void)
 out_procfs:
 	if (proc_mtd)
 		remove_proc_entry("mtd", NULL);
+	bdi_destroy(mtd_bdi);
+	kfree(mtd_bdi);
 err_bdi:
 	class_unregister(&mtd_class);
 err_reg:
@@ -1823,7 +1828,8 @@ static void __exit cleanup_mtd(void)
 	if (proc_mtd)
 		remove_proc_entry("mtd", NULL);
 	class_unregister(&mtd_class);
-	bdi_destroy(&mtd_bdi);
+	bdi_destroy(mtd_bdi);
+	kfree(mtd_bdi);
 	idr_destroy(&mtd_idr);
 }
 

commit 4d6aecfb7e26d2e8746e2eb1eab5e0fe378065ab
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Wed Nov 9 11:08:10 2016 +0900

    mtd: remove unneeded initializer in mtd_ooblayout_count_bytes()
    
    There is no need to initialize oobregion since it will be filled by
    the iterator.
    
    This function is called with mtd_ooblayout_free or mtd_ooblayout_ecc
    for the iterator; both of them calls memset() to clear the oobregion.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Reviewed-by: Marek Vasut <marek.vasut@gmail.com>
    Signed-off-by: Boris Brezillon <boris.brezillon@free-electrons.com>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index ca6a89ab4663..ca661cee9b77 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -1354,7 +1354,7 @@ static int mtd_ooblayout_count_bytes(struct mtd_info *mtd,
 					    int section,
 					    struct mtd_oob_region *oobregion))
 {
-	struct mtd_oob_region oobregion = { };
+	struct mtd_oob_region oobregion;
 	int section = 0, ret, nbytes = 0;
 
 	while (1) {

commit 7c295ef9642c107203a485843853b12d6f5cdb39
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Wed Nov 9 11:08:09 2016 +0900

    mtd: use min_t() to refactor mtd_ooblayout_{get, set}_bytes()
    
    I hope this will make the code a little more readable.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Reviewed-by: Marek Vasut <marek.vasut@gmail.com>
    Signed-off-by: Boris Brezillon <boris.brezillon@free-electrons.com>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index cf85f2b2ca2c..ca6a89ab4663 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -1283,7 +1283,7 @@ static int mtd_ooblayout_get_bytes(struct mtd_info *mtd, u8 *buf,
 	while (!ret) {
 		int cnt;
 
-		cnt = oobregion.length > nbytes ? nbytes : oobregion.length;
+		cnt = min_t(int, nbytes, oobregion.length);
 		memcpy(buf, oobbuf + oobregion.offset, cnt);
 		buf += cnt;
 		nbytes -= cnt;
@@ -1326,7 +1326,7 @@ static int mtd_ooblayout_set_bytes(struct mtd_info *mtd, const u8 *buf,
 	while (!ret) {
 		int cnt;
 
-		cnt = oobregion.length > nbytes ? nbytes : oobregion.length;
+		cnt = min_t(int, nbytes, oobregion.length);
 		memcpy(oobbuf + oobregion.offset, buf, cnt);
 		buf += cnt;
 		nbytes -= cnt;

commit 8e8fd4d1e83ef7d64f260b4d8d928ab44cc1ce07
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Wed Nov 9 11:08:08 2016 +0900

    mtd: remove unneeded initializer in mtd_ooblayout_{get, set}_bytes()
    
    There is no need to initialize oobregion and section since they will
    be filled by mtd_ooblayout_find_region().
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Reviewed-by: Marek Vasut <marek.vasut@gmail.com>
    Signed-off-by: Boris Brezillon <boris.brezillon@free-electrons.com>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index d46e4adf6d2b..cf85f2b2ca2c 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -1274,8 +1274,8 @@ static int mtd_ooblayout_get_bytes(struct mtd_info *mtd, u8 *buf,
 					    int section,
 					    struct mtd_oob_region *oobregion))
 {
-	struct mtd_oob_region oobregion = { };
-	int section = 0, ret;
+	struct mtd_oob_region oobregion;
+	int section, ret;
 
 	ret = mtd_ooblayout_find_region(mtd, start, &section,
 					&oobregion, iter);
@@ -1317,8 +1317,8 @@ static int mtd_ooblayout_set_bytes(struct mtd_info *mtd, const u8 *buf,
 					    int section,
 					    struct mtd_oob_region *oobregion))
 {
-	struct mtd_oob_region oobregion = { };
-	int section = 0, ret;
+	struct mtd_oob_region oobregion;
+	int section, ret;
 
 	ret = mtd_ooblayout_find_region(mtd, start, &section,
 					&oobregion, iter);

commit 97139d4a6f26445de47b378cddd5192c0278f863
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Tue Oct 11 13:55:58 2016 -0700

    treewide: remove redundant #include <linux/kconfig.h>
    
    Kernel source files need not include <linux/kconfig.h> explicitly
    because the top Makefile forces to include it with:
    
      -include $(srctree)/include/linux/kconfig.h
    
    This commit removes explicit includes except the following:
    
      * arch/s390/include/asm/facilities_src.h
      * tools/testing/radix-tree/linux/kernel.h
    
    These two are used for host programs.
    
    Link: http://lkml.kernel.org/r/1473656164-11929-1-git-send-email-yamada.masahiro@socionext.com
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index 4f270482cfd0..d46e4adf6d2b 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -39,7 +39,6 @@
 #include <linux/gfp.h>
 #include <linux/slab.h>
 #include <linux/reboot.h>
-#include <linux/kconfig.h>
 #include <linux/leds.h>
 
 #include <linux/mtd/mtd.h>

commit 477b0229ac9bc275f6f8d2c27a2d08b246fccd0e
Author: Boris Brezillon <boris.brezillon@free-electrons.com>
Date:   Mon Nov 16 15:53:13 2015 +0100

    mtd: introduce the mtd_pairing_scheme concept
    
    MLC and TLC NAND devices are using NAND cells exposing more than one bit,
    but instead of attaching all the bits in a given cell to a single NAND
    page, each bit is usually attached to a different page. This concept is
    called 'page pairing', and has significant impacts on the flash storage
    usage.
    The main problem showed by these devices is that interrupting a page
    program operation may not only corrupt the page we are programming
    but also the page it is paired with, hence the need to expose to MTD
    users the pairing scheme information.
    
    The pairing APIs allows one to query pairing information attached to a
    given page (here called wunit), or the other way around (the wunit
    pointed by pairing information).
    It also provides several helpers to help the conversion between absolute
    offsets and wunits, and query the number of pairing groups.
    
    Signed-off-by: Boris Brezillon <boris.brezillon@free-electrons.com>
    Reviewed-by: Brian Norris <computersforpeace@gmail.com>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index e3936b847c6b..4f270482cfd0 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -375,6 +375,110 @@ static int mtd_reboot_notifier(struct notifier_block *n, unsigned long state,
 	return NOTIFY_DONE;
 }
 
+/**
+ * mtd_wunit_to_pairing_info - get pairing information of a wunit
+ * @mtd: pointer to new MTD device info structure
+ * @wunit: write unit we are interested in
+ * @info: returned pairing information
+ *
+ * Retrieve pairing information associated to the wunit.
+ * This is mainly useful when dealing with MLC/TLC NANDs where pages can be
+ * paired together, and where programming a page may influence the page it is
+ * paired with.
+ * The notion of page is replaced by the term wunit (write-unit) to stay
+ * consistent with the ->writesize field.
+ *
+ * The @wunit argument can be extracted from an absolute offset using
+ * mtd_offset_to_wunit(). @info is filled with the pairing information attached
+ * to @wunit.
+ *
+ * From the pairing info the MTD user can find all the wunits paired with
+ * @wunit using the following loop:
+ *
+ * for (i = 0; i < mtd_pairing_groups(mtd); i++) {
+ *	info.pair = i;
+ *	mtd_pairing_info_to_wunit(mtd, &info);
+ *	...
+ * }
+ */
+int mtd_wunit_to_pairing_info(struct mtd_info *mtd, int wunit,
+			      struct mtd_pairing_info *info)
+{
+	int npairs = mtd_wunit_per_eb(mtd) / mtd_pairing_groups(mtd);
+
+	if (wunit < 0 || wunit >= npairs)
+		return -EINVAL;
+
+	if (mtd->pairing && mtd->pairing->get_info)
+		return mtd->pairing->get_info(mtd, wunit, info);
+
+	info->group = 0;
+	info->pair = wunit;
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(mtd_wunit_to_pairing_info);
+
+/**
+ * mtd_wunit_to_pairing_info - get wunit from pairing information
+ * @mtd: pointer to new MTD device info structure
+ * @info: pairing information struct
+ *
+ * Returns a positive number representing the wunit associated to the info
+ * struct, or a negative error code.
+ *
+ * This is the reverse of mtd_wunit_to_pairing_info(), and can help one to
+ * iterate over all wunits of a given pair (see mtd_wunit_to_pairing_info()
+ * doc).
+ *
+ * It can also be used to only program the first page of each pair (i.e.
+ * page attached to group 0), which allows one to use an MLC NAND in
+ * software-emulated SLC mode:
+ *
+ * info.group = 0;
+ * npairs = mtd_wunit_per_eb(mtd) / mtd_pairing_groups(mtd);
+ * for (info.pair = 0; info.pair < npairs; info.pair++) {
+ *	wunit = mtd_pairing_info_to_wunit(mtd, &info);
+ *	mtd_write(mtd, mtd_wunit_to_offset(mtd, blkoffs, wunit),
+ *		  mtd->writesize, &retlen, buf + (i * mtd->writesize));
+ * }
+ */
+int mtd_pairing_info_to_wunit(struct mtd_info *mtd,
+			      const struct mtd_pairing_info *info)
+{
+	int ngroups = mtd_pairing_groups(mtd);
+	int npairs = mtd_wunit_per_eb(mtd) / ngroups;
+
+	if (!info || info->pair < 0 || info->pair >= npairs ||
+	    info->group < 0 || info->group >= ngroups)
+		return -EINVAL;
+
+	if (mtd->pairing && mtd->pairing->get_wunit)
+		return mtd->pairing->get_wunit(mtd, info);
+
+	return info->pair;
+}
+EXPORT_SYMBOL_GPL(mtd_pairing_info_to_wunit);
+
+/**
+ * mtd_pairing_groups - get the number of pairing groups
+ * @mtd: pointer to new MTD device info structure
+ *
+ * Returns the number of pairing groups.
+ *
+ * This number is usually equal to the number of bits exposed by a single
+ * cell, and can be used in conjunction with mtd_pairing_info_to_wunit()
+ * to iterate over all pages of a given pair.
+ */
+int mtd_pairing_groups(struct mtd_info *mtd)
+{
+	if (!mtd->pairing || !mtd->pairing->ngroups)
+		return 1;
+
+	return mtd->pairing->ngroups;
+}
+EXPORT_SYMBOL_GPL(mtd_pairing_groups);
+
 /**
  *	add_mtd_device - register an MTD device
  *	@mtd: pointer to new MTD device info structure

commit aab616e31d1c7ec3726f7f5cbdaaec98759ebe93
Author: Boris Brezillon <boris.brezillon@free-electrons.com>
Date:   Thu Feb 4 10:16:18 2016 +0100

    mtd: kill the nand_ecclayout struct
    
    Now that all MTD drivers have moved to the mtd_ooblayout_ops model we can
    safely remove the struct nand_ecclayout definition, and all the remaining
    places where it was still used.
    
    Signed-off-by: Boris Brezillon <boris.brezillon@free-electrons.com>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index 134ed2f7b919..e3936b847c6b 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -1376,123 +1376,6 @@ int mtd_ooblayout_count_eccbytes(struct mtd_info *mtd)
 }
 EXPORT_SYMBOL_GPL(mtd_ooblayout_count_eccbytes);
 
-/**
- * mtd_ecclayout_ecc - Default ooblayout_ecc iterator implementation
- * @mtd: MTD device structure
- * @section: ECC section. Depending on the layout you may have all the ECC
- *	     bytes stored in a single contiguous section, or one section
- *	     per ECC chunk (and sometime several sections for a single ECC
- *	     ECC chunk)
- * @oobecc: OOB region struct filled with the appropriate ECC position
- *	    information
- *
- * This function is just a wrapper around the mtd->ecclayout field and is
- * here to ease the transition to the mtd_ooblayout_ops approach.
- * All it does is convert the layout->eccpos information into proper oob
- * region definitions.
- *
- * Returns zero on success, a negative error code otherwise.
- */
-static int mtd_ecclayout_ecc(struct mtd_info *mtd, int section,
-			     struct mtd_oob_region *oobecc)
-{
-	int eccbyte = 0, cursection = 0, length = 0, eccpos = 0;
-
-	if (!mtd->ecclayout)
-		return -ENOTSUPP;
-
-	/*
-	 * This logic allows us to reuse the ->ecclayout information and
-	 * expose them as ECC regions (as done for the OOB free regions).
-	 *
-	 * TODO: this should be dropped as soon as we get rid of the
-	 * ->ecclayout field.
-	 */
-	for (eccbyte = 0; eccbyte < mtd->ecclayout->eccbytes; eccbyte++) {
-		eccpos = mtd->ecclayout->eccpos[eccbyte];
-
-		if (eccbyte < mtd->ecclayout->eccbytes - 1) {
-			int neccpos = mtd->ecclayout->eccpos[eccbyte + 1];
-
-			if (eccpos + 1 == neccpos) {
-				length++;
-				continue;
-			}
-		}
-
-		if (section == cursection)
-			break;
-
-		length = 0;
-		cursection++;
-	}
-
-	if (cursection != section || eccbyte >= mtd->ecclayout->eccbytes)
-		return -ERANGE;
-
-	oobecc->length = length + 1;
-	oobecc->offset = eccpos - length;
-
-	return 0;
-}
-
-/**
- * mtd_ecclayout_ecc - Default ooblayout_free iterator implementation
- * @mtd: MTD device structure
- * @section: Free section. Depending on the layout you may have all the free
- *	     bytes stored in a single contiguous section, or one section
- *	     per ECC chunk (and sometime several sections for a single ECC
- *	     ECC chunk)
- * @oobfree: OOB region struct filled with the appropriate free position
- *	     information
- *
- * This function is just a wrapper around the mtd->ecclayout field and is
- * here to ease the transition to the mtd_ooblayout_ops approach.
- * All it does is convert the layout->oobfree information into proper oob
- * region definitions.
- *
- * Returns zero on success, a negative error code otherwise.
- */
-static int mtd_ecclayout_free(struct mtd_info *mtd, int section,
-			      struct mtd_oob_region *oobfree)
-{
-	struct nand_ecclayout *layout = mtd->ecclayout;
-
-	if (!layout)
-		return -ENOTSUPP;
-
-	if (section >= MTD_MAX_OOBFREE_ENTRIES_LARGE ||
-	    !layout->oobfree[section].length)
-		return -ERANGE;
-
-	oobfree->offset = layout->oobfree[section].offset;
-	oobfree->length = layout->oobfree[section].length;
-
-	return 0;
-}
-
-static const struct mtd_ooblayout_ops mtd_ecclayout_wrapper_ops = {
-	.ecc = mtd_ecclayout_ecc,
-	.free = mtd_ecclayout_free,
-};
-
-/**
- * mtd_set_ecclayout - Attach an ecclayout to an MTD device
- * @mtd: MTD device structure
- * @ecclayout: The ecclayout to attach to the device
- *
- * Returns zero on success, a negative error code otherwise.
- */
-void mtd_set_ecclayout(struct mtd_info *mtd, struct nand_ecclayout *ecclayout)
-{
-	if (!mtd || !ecclayout)
-		return;
-
-	mtd->ecclayout = ecclayout;
-	mtd_set_ooblayout(mtd, &mtd_ecclayout_wrapper_ops);
-}
-EXPORT_SYMBOL_GPL(mtd_set_ecclayout);
-
 /*
  * Method to access the protection register area, present in some flash
  * devices. The user data is one time programmable but the factory data is read

commit adbbc3bc827eb1f43a932d783f09ba55c8ec8379
Author: Boris Brezillon <boris.brezillon@free-electrons.com>
Date:   Wed Feb 3 19:01:31 2016 +0100

    mtd: create an mtd_ooblayout_ops struct to ease ECC layout definition
    
    ECC layout definitions are currently exposed using the nand_ecclayout
    struct which embeds oobfree and eccpos arrays with predefined size.
    This approach was acceptable when NAND chips were providing relatively
    small OOB regions, but MLC and TLC now provide OOB regions of several
    hundreds of bytes, which implies a non negligible overhead for everybody
    even those who only need to support legacy NANDs.
    
    Create an mtd_ooblayout_ops interface providing the same functionality
    (expose the ECC and oobfree layout) without the need for this huge
    structure.
    
    The mtd->ecclayout is now deprecated and should be replaced by the
    equivalent mtd_ooblayout_ops. In the meantime we provide a wrapper around
    the ->ecclayout field to ease migration to this new model.
    
    Signed-off-by: Boris Brezillon <boris.brezillon@free-electrons.com>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index 0290c41e44fc..134ed2f7b919 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -1035,49 +1035,15 @@ EXPORT_SYMBOL_GPL(mtd_write_oob);
 int mtd_ooblayout_ecc(struct mtd_info *mtd, int section,
 		      struct mtd_oob_region *oobecc)
 {
-	int eccbyte = 0, cursection = 0, length = 0, eccpos = 0;
-
 	memset(oobecc, 0, sizeof(*oobecc));
 
 	if (!mtd || section < 0)
 		return -EINVAL;
 
-	if (!mtd->ecclayout)
+	if (!mtd->ooblayout || !mtd->ooblayout->ecc)
 		return -ENOTSUPP;
 
-	/*
-	 * This logic allows us to reuse the ->ecclayout information and
-	 * expose them as ECC regions (as done for the OOB free regions).
-	 *
-	 * TODO: this should be dropped as soon as we get rid of the
-	 * ->ecclayout field.
-	 */
-	for (eccbyte = 0; eccbyte < mtd->ecclayout->eccbytes; eccbyte++) {
-		eccpos = mtd->ecclayout->eccpos[eccbyte];
-
-		if (eccbyte < mtd->ecclayout->eccbytes - 1) {
-			int neccpos = mtd->ecclayout->eccpos[eccbyte + 1];
-
-			if (eccpos + 1 == neccpos) {
-				length++;
-				continue;
-			}
-		}
-
-		if (section == cursection)
-			break;
-
-		length = 0;
-		cursection++;
-	}
-
-	if (cursection != section || eccbyte >= mtd->ecclayout->eccbytes)
-		return -ERANGE;
-
-	oobecc->length = length + 1;
-	oobecc->offset = eccpos - length;
-
-	return 0;
+	return mtd->ooblayout->ecc(mtd, section, oobecc);
 }
 EXPORT_SYMBOL_GPL(mtd_ooblayout_ecc);
 
@@ -1106,16 +1072,10 @@ int mtd_ooblayout_free(struct mtd_info *mtd, int section,
 	if (!mtd || section < 0)
 		return -EINVAL;
 
-	if (!mtd->ecclayout)
+	if (!mtd->ooblayout || !mtd->ooblayout->free)
 		return -ENOTSUPP;
 
-	if (section >= MTD_MAX_OOBFREE_ENTRIES_LARGE)
-		return -ERANGE;
-
-	oobfree->offset = mtd->ecclayout->oobfree[section].offset;
-	oobfree->length = mtd->ecclayout->oobfree[section].length;
-
-	return 0;
+	return mtd->ooblayout->free(mtd, section, oobfree);
 }
 EXPORT_SYMBOL_GPL(mtd_ooblayout_free);
 
@@ -1416,6 +1376,123 @@ int mtd_ooblayout_count_eccbytes(struct mtd_info *mtd)
 }
 EXPORT_SYMBOL_GPL(mtd_ooblayout_count_eccbytes);
 
+/**
+ * mtd_ecclayout_ecc - Default ooblayout_ecc iterator implementation
+ * @mtd: MTD device structure
+ * @section: ECC section. Depending on the layout you may have all the ECC
+ *	     bytes stored in a single contiguous section, or one section
+ *	     per ECC chunk (and sometime several sections for a single ECC
+ *	     ECC chunk)
+ * @oobecc: OOB region struct filled with the appropriate ECC position
+ *	    information
+ *
+ * This function is just a wrapper around the mtd->ecclayout field and is
+ * here to ease the transition to the mtd_ooblayout_ops approach.
+ * All it does is convert the layout->eccpos information into proper oob
+ * region definitions.
+ *
+ * Returns zero on success, a negative error code otherwise.
+ */
+static int mtd_ecclayout_ecc(struct mtd_info *mtd, int section,
+			     struct mtd_oob_region *oobecc)
+{
+	int eccbyte = 0, cursection = 0, length = 0, eccpos = 0;
+
+	if (!mtd->ecclayout)
+		return -ENOTSUPP;
+
+	/*
+	 * This logic allows us to reuse the ->ecclayout information and
+	 * expose them as ECC regions (as done for the OOB free regions).
+	 *
+	 * TODO: this should be dropped as soon as we get rid of the
+	 * ->ecclayout field.
+	 */
+	for (eccbyte = 0; eccbyte < mtd->ecclayout->eccbytes; eccbyte++) {
+		eccpos = mtd->ecclayout->eccpos[eccbyte];
+
+		if (eccbyte < mtd->ecclayout->eccbytes - 1) {
+			int neccpos = mtd->ecclayout->eccpos[eccbyte + 1];
+
+			if (eccpos + 1 == neccpos) {
+				length++;
+				continue;
+			}
+		}
+
+		if (section == cursection)
+			break;
+
+		length = 0;
+		cursection++;
+	}
+
+	if (cursection != section || eccbyte >= mtd->ecclayout->eccbytes)
+		return -ERANGE;
+
+	oobecc->length = length + 1;
+	oobecc->offset = eccpos - length;
+
+	return 0;
+}
+
+/**
+ * mtd_ecclayout_ecc - Default ooblayout_free iterator implementation
+ * @mtd: MTD device structure
+ * @section: Free section. Depending on the layout you may have all the free
+ *	     bytes stored in a single contiguous section, or one section
+ *	     per ECC chunk (and sometime several sections for a single ECC
+ *	     ECC chunk)
+ * @oobfree: OOB region struct filled with the appropriate free position
+ *	     information
+ *
+ * This function is just a wrapper around the mtd->ecclayout field and is
+ * here to ease the transition to the mtd_ooblayout_ops approach.
+ * All it does is convert the layout->oobfree information into proper oob
+ * region definitions.
+ *
+ * Returns zero on success, a negative error code otherwise.
+ */
+static int mtd_ecclayout_free(struct mtd_info *mtd, int section,
+			      struct mtd_oob_region *oobfree)
+{
+	struct nand_ecclayout *layout = mtd->ecclayout;
+
+	if (!layout)
+		return -ENOTSUPP;
+
+	if (section >= MTD_MAX_OOBFREE_ENTRIES_LARGE ||
+	    !layout->oobfree[section].length)
+		return -ERANGE;
+
+	oobfree->offset = layout->oobfree[section].offset;
+	oobfree->length = layout->oobfree[section].length;
+
+	return 0;
+}
+
+static const struct mtd_ooblayout_ops mtd_ecclayout_wrapper_ops = {
+	.ecc = mtd_ecclayout_ecc,
+	.free = mtd_ecclayout_free,
+};
+
+/**
+ * mtd_set_ecclayout - Attach an ecclayout to an MTD device
+ * @mtd: MTD device structure
+ * @ecclayout: The ecclayout to attach to the device
+ *
+ * Returns zero on success, a negative error code otherwise.
+ */
+void mtd_set_ecclayout(struct mtd_info *mtd, struct nand_ecclayout *ecclayout)
+{
+	if (!mtd || !ecclayout)
+		return;
+
+	mtd->ecclayout = ecclayout;
+	mtd_set_ooblayout(mtd, &mtd_ecclayout_wrapper_ops);
+}
+EXPORT_SYMBOL_GPL(mtd_set_ecclayout);
+
 /*
  * Method to access the protection register area, present in some flash
  * devices. The user data is one time programmable but the factory data is read

commit 75eb2cec251fda33c9bb716ecc372819abb9278a
Author: Boris Brezillon <boris.brezillon@free-electrons.com>
Date:   Thu Feb 4 09:52:30 2016 +0100

    mtd: add mtd_ooblayout_xxx() helper functions
    
    In order to make the ecclayout definition completely dynamic we need to
    rework the way the OOB layout are defined and iterated.
    
    Create a few mtd_ooblayout_xxx() helpers to ease OOB bytes manipulation
    and hide ecclayout internals to their users.
    
    Signed-off-by: Boris Brezillon <boris.brezillon@free-electrons.com>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index bee180bd11e7..0290c41e44fc 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -1016,6 +1016,406 @@ int mtd_write_oob(struct mtd_info *mtd, loff_t to,
 }
 EXPORT_SYMBOL_GPL(mtd_write_oob);
 
+/**
+ * mtd_ooblayout_ecc - Get the OOB region definition of a specific ECC section
+ * @mtd: MTD device structure
+ * @section: ECC section. Depending on the layout you may have all the ECC
+ *	     bytes stored in a single contiguous section, or one section
+ *	     per ECC chunk (and sometime several sections for a single ECC
+ *	     ECC chunk)
+ * @oobecc: OOB region struct filled with the appropriate ECC position
+ *	    information
+ *
+ * This functions return ECC section information in the OOB area. I you want
+ * to get all the ECC bytes information, then you should call
+ * mtd_ooblayout_ecc(mtd, section++, oobecc) until it returns -ERANGE.
+ *
+ * Returns zero on success, a negative error code otherwise.
+ */
+int mtd_ooblayout_ecc(struct mtd_info *mtd, int section,
+		      struct mtd_oob_region *oobecc)
+{
+	int eccbyte = 0, cursection = 0, length = 0, eccpos = 0;
+
+	memset(oobecc, 0, sizeof(*oobecc));
+
+	if (!mtd || section < 0)
+		return -EINVAL;
+
+	if (!mtd->ecclayout)
+		return -ENOTSUPP;
+
+	/*
+	 * This logic allows us to reuse the ->ecclayout information and
+	 * expose them as ECC regions (as done for the OOB free regions).
+	 *
+	 * TODO: this should be dropped as soon as we get rid of the
+	 * ->ecclayout field.
+	 */
+	for (eccbyte = 0; eccbyte < mtd->ecclayout->eccbytes; eccbyte++) {
+		eccpos = mtd->ecclayout->eccpos[eccbyte];
+
+		if (eccbyte < mtd->ecclayout->eccbytes - 1) {
+			int neccpos = mtd->ecclayout->eccpos[eccbyte + 1];
+
+			if (eccpos + 1 == neccpos) {
+				length++;
+				continue;
+			}
+		}
+
+		if (section == cursection)
+			break;
+
+		length = 0;
+		cursection++;
+	}
+
+	if (cursection != section || eccbyte >= mtd->ecclayout->eccbytes)
+		return -ERANGE;
+
+	oobecc->length = length + 1;
+	oobecc->offset = eccpos - length;
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(mtd_ooblayout_ecc);
+
+/**
+ * mtd_ooblayout_free - Get the OOB region definition of a specific free
+ *			section
+ * @mtd: MTD device structure
+ * @section: Free section you are interested in. Depending on the layout
+ *	     you may have all the free bytes stored in a single contiguous
+ *	     section, or one section per ECC chunk plus an extra section
+ *	     for the remaining bytes (or other funky layout).
+ * @oobfree: OOB region struct filled with the appropriate free position
+ *	     information
+ *
+ * This functions return free bytes position in the OOB area. I you want
+ * to get all the free bytes information, then you should call
+ * mtd_ooblayout_free(mtd, section++, oobfree) until it returns -ERANGE.
+ *
+ * Returns zero on success, a negative error code otherwise.
+ */
+int mtd_ooblayout_free(struct mtd_info *mtd, int section,
+		       struct mtd_oob_region *oobfree)
+{
+	memset(oobfree, 0, sizeof(*oobfree));
+
+	if (!mtd || section < 0)
+		return -EINVAL;
+
+	if (!mtd->ecclayout)
+		return -ENOTSUPP;
+
+	if (section >= MTD_MAX_OOBFREE_ENTRIES_LARGE)
+		return -ERANGE;
+
+	oobfree->offset = mtd->ecclayout->oobfree[section].offset;
+	oobfree->length = mtd->ecclayout->oobfree[section].length;
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(mtd_ooblayout_free);
+
+/**
+ * mtd_ooblayout_find_region - Find the region attached to a specific byte
+ * @mtd: mtd info structure
+ * @byte: the byte we are searching for
+ * @sectionp: pointer where the section id will be stored
+ * @oobregion: used to retrieve the ECC position
+ * @iter: iterator function. Should be either mtd_ooblayout_free or
+ *	  mtd_ooblayout_ecc depending on the region type you're searching for
+ *
+ * This functions returns the section id and oobregion information of a
+ * specific byte. For example, say you want to know where the 4th ECC byte is
+ * stored, you'll use:
+ *
+ * mtd_ooblayout_find_region(mtd, 3, &section, &oobregion, mtd_ooblayout_ecc);
+ *
+ * Returns zero on success, a negative error code otherwise.
+ */
+static int mtd_ooblayout_find_region(struct mtd_info *mtd, int byte,
+				int *sectionp, struct mtd_oob_region *oobregion,
+				int (*iter)(struct mtd_info *,
+					    int section,
+					    struct mtd_oob_region *oobregion))
+{
+	int pos = 0, ret, section = 0;
+
+	memset(oobregion, 0, sizeof(*oobregion));
+
+	while (1) {
+		ret = iter(mtd, section, oobregion);
+		if (ret)
+			return ret;
+
+		if (pos + oobregion->length > byte)
+			break;
+
+		pos += oobregion->length;
+		section++;
+	}
+
+	/*
+	 * Adjust region info to make it start at the beginning at the
+	 * 'start' ECC byte.
+	 */
+	oobregion->offset += byte - pos;
+	oobregion->length -= byte - pos;
+	*sectionp = section;
+
+	return 0;
+}
+
+/**
+ * mtd_ooblayout_find_eccregion - Find the ECC region attached to a specific
+ *				  ECC byte
+ * @mtd: mtd info structure
+ * @eccbyte: the byte we are searching for
+ * @sectionp: pointer where the section id will be stored
+ * @oobregion: OOB region information
+ *
+ * Works like mtd_ooblayout_find_region() except it searches for a specific ECC
+ * byte.
+ *
+ * Returns zero on success, a negative error code otherwise.
+ */
+int mtd_ooblayout_find_eccregion(struct mtd_info *mtd, int eccbyte,
+				 int *section,
+				 struct mtd_oob_region *oobregion)
+{
+	return mtd_ooblayout_find_region(mtd, eccbyte, section, oobregion,
+					 mtd_ooblayout_ecc);
+}
+EXPORT_SYMBOL_GPL(mtd_ooblayout_find_eccregion);
+
+/**
+ * mtd_ooblayout_get_bytes - Extract OOB bytes from the oob buffer
+ * @mtd: mtd info structure
+ * @buf: destination buffer to store OOB bytes
+ * @oobbuf: OOB buffer
+ * @start: first byte to retrieve
+ * @nbytes: number of bytes to retrieve
+ * @iter: section iterator
+ *
+ * Extract bytes attached to a specific category (ECC or free)
+ * from the OOB buffer and copy them into buf.
+ *
+ * Returns zero on success, a negative error code otherwise.
+ */
+static int mtd_ooblayout_get_bytes(struct mtd_info *mtd, u8 *buf,
+				const u8 *oobbuf, int start, int nbytes,
+				int (*iter)(struct mtd_info *,
+					    int section,
+					    struct mtd_oob_region *oobregion))
+{
+	struct mtd_oob_region oobregion = { };
+	int section = 0, ret;
+
+	ret = mtd_ooblayout_find_region(mtd, start, &section,
+					&oobregion, iter);
+
+	while (!ret) {
+		int cnt;
+
+		cnt = oobregion.length > nbytes ? nbytes : oobregion.length;
+		memcpy(buf, oobbuf + oobregion.offset, cnt);
+		buf += cnt;
+		nbytes -= cnt;
+
+		if (!nbytes)
+			break;
+
+		ret = iter(mtd, ++section, &oobregion);
+	}
+
+	return ret;
+}
+
+/**
+ * mtd_ooblayout_set_bytes - put OOB bytes into the oob buffer
+ * @mtd: mtd info structure
+ * @buf: source buffer to get OOB bytes from
+ * @oobbuf: OOB buffer
+ * @start: first OOB byte to set
+ * @nbytes: number of OOB bytes to set
+ * @iter: section iterator
+ *
+ * Fill the OOB buffer with data provided in buf. The category (ECC or free)
+ * is selected by passing the appropriate iterator.
+ *
+ * Returns zero on success, a negative error code otherwise.
+ */
+static int mtd_ooblayout_set_bytes(struct mtd_info *mtd, const u8 *buf,
+				u8 *oobbuf, int start, int nbytes,
+				int (*iter)(struct mtd_info *,
+					    int section,
+					    struct mtd_oob_region *oobregion))
+{
+	struct mtd_oob_region oobregion = { };
+	int section = 0, ret;
+
+	ret = mtd_ooblayout_find_region(mtd, start, &section,
+					&oobregion, iter);
+
+	while (!ret) {
+		int cnt;
+
+		cnt = oobregion.length > nbytes ? nbytes : oobregion.length;
+		memcpy(oobbuf + oobregion.offset, buf, cnt);
+		buf += cnt;
+		nbytes -= cnt;
+
+		if (!nbytes)
+			break;
+
+		ret = iter(mtd, ++section, &oobregion);
+	}
+
+	return ret;
+}
+
+/**
+ * mtd_ooblayout_count_bytes - count the number of bytes in a OOB category
+ * @mtd: mtd info structure
+ * @iter: category iterator
+ *
+ * Count the number of bytes in a given category.
+ *
+ * Returns a positive value on success, a negative error code otherwise.
+ */
+static int mtd_ooblayout_count_bytes(struct mtd_info *mtd,
+				int (*iter)(struct mtd_info *,
+					    int section,
+					    struct mtd_oob_region *oobregion))
+{
+	struct mtd_oob_region oobregion = { };
+	int section = 0, ret, nbytes = 0;
+
+	while (1) {
+		ret = iter(mtd, section++, &oobregion);
+		if (ret) {
+			if (ret == -ERANGE)
+				ret = nbytes;
+			break;
+		}
+
+		nbytes += oobregion.length;
+	}
+
+	return ret;
+}
+
+/**
+ * mtd_ooblayout_get_eccbytes - extract ECC bytes from the oob buffer
+ * @mtd: mtd info structure
+ * @eccbuf: destination buffer to store ECC bytes
+ * @oobbuf: OOB buffer
+ * @start: first ECC byte to retrieve
+ * @nbytes: number of ECC bytes to retrieve
+ *
+ * Works like mtd_ooblayout_get_bytes(), except it acts on ECC bytes.
+ *
+ * Returns zero on success, a negative error code otherwise.
+ */
+int mtd_ooblayout_get_eccbytes(struct mtd_info *mtd, u8 *eccbuf,
+			       const u8 *oobbuf, int start, int nbytes)
+{
+	return mtd_ooblayout_get_bytes(mtd, eccbuf, oobbuf, start, nbytes,
+				       mtd_ooblayout_ecc);
+}
+EXPORT_SYMBOL_GPL(mtd_ooblayout_get_eccbytes);
+
+/**
+ * mtd_ooblayout_set_eccbytes - set ECC bytes into the oob buffer
+ * @mtd: mtd info structure
+ * @eccbuf: source buffer to get ECC bytes from
+ * @oobbuf: OOB buffer
+ * @start: first ECC byte to set
+ * @nbytes: number of ECC bytes to set
+ *
+ * Works like mtd_ooblayout_set_bytes(), except it acts on ECC bytes.
+ *
+ * Returns zero on success, a negative error code otherwise.
+ */
+int mtd_ooblayout_set_eccbytes(struct mtd_info *mtd, const u8 *eccbuf,
+			       u8 *oobbuf, int start, int nbytes)
+{
+	return mtd_ooblayout_set_bytes(mtd, eccbuf, oobbuf, start, nbytes,
+				       mtd_ooblayout_ecc);
+}
+EXPORT_SYMBOL_GPL(mtd_ooblayout_set_eccbytes);
+
+/**
+ * mtd_ooblayout_get_databytes - extract data bytes from the oob buffer
+ * @mtd: mtd info structure
+ * @databuf: destination buffer to store ECC bytes
+ * @oobbuf: OOB buffer
+ * @start: first ECC byte to retrieve
+ * @nbytes: number of ECC bytes to retrieve
+ *
+ * Works like mtd_ooblayout_get_bytes(), except it acts on free bytes.
+ *
+ * Returns zero on success, a negative error code otherwise.
+ */
+int mtd_ooblayout_get_databytes(struct mtd_info *mtd, u8 *databuf,
+				const u8 *oobbuf, int start, int nbytes)
+{
+	return mtd_ooblayout_get_bytes(mtd, databuf, oobbuf, start, nbytes,
+				       mtd_ooblayout_free);
+}
+EXPORT_SYMBOL_GPL(mtd_ooblayout_get_databytes);
+
+/**
+ * mtd_ooblayout_get_eccbytes - set data bytes into the oob buffer
+ * @mtd: mtd info structure
+ * @eccbuf: source buffer to get data bytes from
+ * @oobbuf: OOB buffer
+ * @start: first ECC byte to set
+ * @nbytes: number of ECC bytes to set
+ *
+ * Works like mtd_ooblayout_get_bytes(), except it acts on free bytes.
+ *
+ * Returns zero on success, a negative error code otherwise.
+ */
+int mtd_ooblayout_set_databytes(struct mtd_info *mtd, const u8 *databuf,
+				u8 *oobbuf, int start, int nbytes)
+{
+	return mtd_ooblayout_set_bytes(mtd, databuf, oobbuf, start, nbytes,
+				       mtd_ooblayout_free);
+}
+EXPORT_SYMBOL_GPL(mtd_ooblayout_set_databytes);
+
+/**
+ * mtd_ooblayout_count_freebytes - count the number of free bytes in OOB
+ * @mtd: mtd info structure
+ *
+ * Works like mtd_ooblayout_count_bytes(), except it count free bytes.
+ *
+ * Returns zero on success, a negative error code otherwise.
+ */
+int mtd_ooblayout_count_freebytes(struct mtd_info *mtd)
+{
+	return mtd_ooblayout_count_bytes(mtd, mtd_ooblayout_free);
+}
+EXPORT_SYMBOL_GPL(mtd_ooblayout_count_freebytes);
+
+/**
+ * mtd_ooblayout_count_freebytes - count the number of ECC bytes in OOB
+ * @mtd: mtd info structure
+ *
+ * Works like mtd_ooblayout_count_bytes(), except it count ECC bytes.
+ *
+ * Returns zero on success, a negative error code otherwise.
+ */
+int mtd_ooblayout_count_eccbytes(struct mtd_info *mtd)
+{
+	return mtd_ooblayout_count_bytes(mtd, mtd_ooblayout_ecc);
+}
+EXPORT_SYMBOL_GPL(mtd_ooblayout_count_eccbytes);
+
 /*
  * Method to access the protection register area, present in some flash
  * devices. The user data is one time programmable but the factory data is read

commit fea728c098ee1e6a4a2855962390487ee5d1cdc2
Author: Ezequiel Garcia <ezequiel@vanguardiasur.com.ar>
Date:   Tue Apr 12 17:46:42 2016 -0300

    mtd: Hook I/O activity to the MTD LED trigger
    
    Now that we've added the MTD LED trigger, we need
    to call each I/O path to ledtrig_mtd_activity.
    
    Signed-off-by: Ezequiel Garcia <ezequiel@vanguardiasur.com.ar>
    Acked-by: Boris Brezillon <boris.brezillon@free-electrons.com>
    Signed-off-by: Jacek Anaszewski <j.anaszewski@samsung.com>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index 99d83f3331b0..bee180bd11e7 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -40,6 +40,7 @@
 #include <linux/slab.h>
 #include <linux/reboot.h>
 #include <linux/kconfig.h>
+#include <linux/leds.h>
 
 #include <linux/mtd/mtd.h>
 #include <linux/mtd/partitions.h>
@@ -862,6 +863,7 @@ int mtd_erase(struct mtd_info *mtd, struct erase_info *instr)
 		mtd_erase_callback(instr);
 		return 0;
 	}
+	ledtrig_mtd_activity();
 	return mtd->_erase(mtd, instr);
 }
 EXPORT_SYMBOL_GPL(mtd_erase);
@@ -925,6 +927,7 @@ int mtd_read(struct mtd_info *mtd, loff_t from, size_t len, size_t *retlen,
 	if (!len)
 		return 0;
 
+	ledtrig_mtd_activity();
 	/*
 	 * In the absence of an error, drivers return a non-negative integer
 	 * representing the maximum number of bitflips that were corrected on
@@ -949,6 +952,7 @@ int mtd_write(struct mtd_info *mtd, loff_t to, size_t len, size_t *retlen,
 		return -EROFS;
 	if (!len)
 		return 0;
+	ledtrig_mtd_activity();
 	return mtd->_write(mtd, to, len, retlen, buf);
 }
 EXPORT_SYMBOL_GPL(mtd_write);
@@ -982,6 +986,8 @@ int mtd_read_oob(struct mtd_info *mtd, loff_t from, struct mtd_oob_ops *ops)
 	ops->retlen = ops->oobretlen = 0;
 	if (!mtd->_read_oob)
 		return -EOPNOTSUPP;
+
+	ledtrig_mtd_activity();
 	/*
 	 * In cases where ops->datbuf != NULL, mtd->_read_oob() has semantics
 	 * similar to mtd->_read(), returning a non-negative integer
@@ -1005,6 +1011,7 @@ int mtd_write_oob(struct mtd_info *mtd, loff_t to,
 		return -EOPNOTSUPP;
 	if (!(mtd->flags & MTD_WRITEABLE))
 		return -EROFS;
+	ledtrig_mtd_activity();
 	return mtd->_write_oob(mtd, to, ops);
 }
 EXPORT_SYMBOL_GPL(mtd_write_oob);

commit 0c034fe37718990e0ffdd9622bd6cc5b4f93111f
Author: Ezequiel Garcia <ezequiel@vanguardiasur.com.ar>
Date:   Tue Apr 12 17:46:39 2016 -0300

    mtd: Uninline mtd_write_oob and move it to mtdcore.c
    
    There's no reason for having mtd_write_oob inlined in mtd.h header.
    Move it to mtdcore.c where it belongs.
    
    Signed-off-by: Ezequiel Garcia <ezequiel@vanguardiasur.com.ar>
    Acked-by: Boris Brezillon <boris.brezillon@free-electrons.com>
    Signed-off-by: Jacek Anaszewski <j.anaszewski@samsung.com>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index 309625130b21..99d83f3331b0 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -997,6 +997,18 @@ int mtd_read_oob(struct mtd_info *mtd, loff_t from, struct mtd_oob_ops *ops)
 }
 EXPORT_SYMBOL_GPL(mtd_read_oob);
 
+int mtd_write_oob(struct mtd_info *mtd, loff_t to,
+				struct mtd_oob_ops *ops)
+{
+	ops->retlen = ops->oobretlen = 0;
+	if (!mtd->_write_oob)
+		return -EOPNOTSUPP;
+	if (!(mtd->flags & MTD_WRITEABLE))
+		return -EROFS;
+	return mtd->_write_oob(mtd, to, ops);
+}
+EXPORT_SYMBOL_GPL(mtd_write_oob);
+
 /*
  * Method to access the protection register area, present in some flash
  * devices. The user data is one time programmable but the factory data is read

commit e576330033936d94a00068760a5744e27ce51a32
Merge: 887e9d3a1f3e a32d5b726ff8
Author: Brian Norris <computersforpeace@gmail.com>
Date:   Tue Jan 5 16:04:40 2016 -0800

    mtd: merge MTD development from v4.4 into for-v4.5 development
    
    Small conflict between some bugfixes for 4.4 and some refactoring for
    4.5.
    
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>

commit 472b444eef934eb7e90334efdd7fc7954cfe5132
Author: Brian Norris <computersforpeace@gmail.com>
Date:   Fri Dec 11 15:58:01 2015 -0800

    mtd: fix cmdlinepart parser, early naming for auto-filled MTD
    
    Commit 807f16d4db95 ("mtd: core: set some defaults when dev.parent is
    set") attempted to provide some default settings for MTDs that
     (a) assign the parent device and
     (b) don't provide their own name or owner
    
    However, this isn't a perfect drop-in replacement for the boilerplate
    found in some drivers, because the MTD name is used by partition
    parsers like cmdlinepart, but the name isn't set until add_mtd_device(),
    after the parsing is completed. This means cmdlinepart sees a NULL name
    and therefore will not work properly.
    
    Fix this by moving the default name and owner assignment to be first in
    the MTD registration process.
    
    [Note: this does not fix all reported issues, particularly with NAND
    drivers. Will require an additional fix for drivers/mtd/nand/]
    
    Fixes: 807f16d4db95 ("mtd: core: set some defaults when dev.parent is set")
    Reported-by: Heiko Schocher <hs@denx.de>
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>
    Cc: Heiko Schocher <hs@denx.de>
    Cc: Frans Klaver <fransklaver@gmail.com>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index 95c13b2ffa79..ffa288474820 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -426,15 +426,6 @@ int add_mtd_device(struct mtd_info *mtd)
 	mtd->erasesize_mask = (1 << mtd->erasesize_shift) - 1;
 	mtd->writesize_mask = (1 << mtd->writesize_shift) - 1;
 
-	if (mtd->dev.parent) {
-		if (!mtd->owner && mtd->dev.parent->driver)
-			mtd->owner = mtd->dev.parent->driver->owner;
-		if (!mtd->name)
-			mtd->name = dev_name(mtd->dev.parent);
-	} else {
-		pr_debug("mtd device won't show a device symlink in sysfs\n");
-	}
-
 	/* Some chips always power up locked. Unlock them now */
 	if ((mtd->flags & MTD_WRITEABLE) && (mtd->flags & MTD_POWERUP_LOCK)) {
 		error = mtd_unlock(mtd, 0, mtd->size);
@@ -549,6 +540,21 @@ static int mtd_add_device_partitions(struct mtd_info *mtd,
 	return 0;
 }
 
+/*
+ * Set a few defaults based on the parent devices, if not provided by the
+ * driver
+ */
+static void mtd_set_dev_defaults(struct mtd_info *mtd)
+{
+	if (mtd->dev.parent) {
+		if (!mtd->owner && mtd->dev.parent->driver)
+			mtd->owner = mtd->dev.parent->driver->owner;
+		if (!mtd->name)
+			mtd->name = dev_name(mtd->dev.parent);
+	} else {
+		pr_debug("mtd device won't show a device symlink in sysfs\n");
+	}
+}
 
 /**
  * mtd_device_parse_register - parse partitions and register an MTD device.
@@ -587,6 +593,8 @@ int mtd_device_parse_register(struct mtd_info *mtd, const char * const *types,
 	int ret;
 	struct mtd_partition *real_parts = NULL;
 
+	mtd_set_dev_defaults(mtd);
+
 	ret = parse_mtd_partitions(mtd, types, &real_parts, parser_data);
 	if (ret <= 0 && nr_parts && parts) {
 		real_parts = kmemdup(parts, sizeof(*parts) * nr_parts,

commit adc83bf8896353603213754353dd66dae69e3d7f
Author: Brian Norris <computersforpeace@gmail.com>
Date:   Wed Dec 9 10:24:03 2015 -0800

    mtd: partitions: support a cleanup callback for parsers
    
    If partition parsers need to clean up their resources, we shouldn't
    assume that all memory will fit in a single kmalloc() that the caller
    can kfree(). We should allow the parser to provide a proper cleanup
    routine.
    
    Note that this means we need to keep a hold on the parser's module for a
    bit longer, and release it later with mtd_part_parser_put().
    
    Alongside this, define a default callback that we'll automatically use
    if the parser doesn't provide one, so we can still retain the old
    behavior.
    
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>
    Reviewed-by: Boris Brezillon <boris.brezillon@free-electrons.com>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index 20b2b38247b6..89d811e7b04a 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -630,8 +630,7 @@ int mtd_device_parse_register(struct mtd_info *mtd, const char * const *types,
 
 out:
 	/* Cleanup any parsed partitions */
-	if (parsed.parser)
-		kfree(parsed.parts);
+	mtd_part_parser_cleanup(&parsed);
 	return ret;
 }
 EXPORT_SYMBOL_GPL(mtd_device_parse_register);

commit 07fd2f871c5e3dfb8ff5eb9c4b44fdb4cf1aeff5
Author: Brian Norris <computersforpeace@gmail.com>
Date:   Fri Dec 4 15:25:17 2015 -0800

    mtd: partitions: pass around 'mtd_partitions' wrapper struct
    
    For some of the core partitioning code, it helps to keep info about the
    parsed partition (and who parsed them) together in one place.
    
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index 868ee52d5063..20b2b38247b6 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -532,9 +532,10 @@ int del_mtd_device(struct mtd_info *mtd)
 }
 
 static int mtd_add_device_partitions(struct mtd_info *mtd,
-				     const struct mtd_partition *real_parts,
-				     int nbparts)
+				     struct mtd_partitions *parts)
 {
+	const struct mtd_partition *real_parts = parts->parts;
+	int nbparts = parts->nr_parts;
 	int ret;
 
 	if (nbparts == 0 || IS_ENABLED(CONFIG_MTD_PARTITIONED_MASTER)) {
@@ -588,23 +589,27 @@ int mtd_device_parse_register(struct mtd_info *mtd, const char * const *types,
 			      const struct mtd_partition *parts,
 			      int nr_parts)
 {
+	struct mtd_partitions parsed;
 	int ret;
-	const struct mtd_partition *real_parts = NULL;
 
-	ret = parse_mtd_partitions(mtd, types, &real_parts, parser_data);
-	if (ret <= 0 && nr_parts && parts) {
-		real_parts = parts;
-		ret = nr_parts;
-	}
-	/* Didn't come up with either parsed OR fallback partitions */
-	if (ret < 0) {
+	memset(&parsed, 0, sizeof(parsed));
+
+	ret = parse_mtd_partitions(mtd, types, &parsed, parser_data);
+	if ((ret < 0 || parsed.nr_parts == 0) && parts && nr_parts) {
+		/* Fall back to driver-provided partitions */
+		parsed = (struct mtd_partitions){
+			.parts		= parts,
+			.nr_parts	= nr_parts,
+		};
+	} else if (ret < 0) {
+		/* Didn't come up with parsed OR fallback partitions */
 		pr_info("mtd: failed to find partitions; one or more parsers reports errors (%d)\n",
 			ret);
 		/* Don't abort on errors; we can still use unpartitioned MTD */
-		ret = 0;
+		memset(&parsed, 0, sizeof(parsed));
 	}
 
-	ret = mtd_add_device_partitions(mtd, real_parts, ret);
+	ret = mtd_add_device_partitions(mtd, &parsed);
 	if (ret)
 		goto out;
 
@@ -625,8 +630,8 @@ int mtd_device_parse_register(struct mtd_info *mtd, const char * const *types,
 
 out:
 	/* Cleanup any parsed partitions */
-	if (real_parts != parts)
-		kfree(real_parts);
+	if (parsed.parser)
+		kfree(parsed.parts);
 	return ret;
 }
 EXPORT_SYMBOL_GPL(mtd_device_parse_register);

commit c42c2710d64381fd48d36b278e0744aa683d93fe
Author: Brian Norris <computersforpeace@gmail.com>
Date:   Fri Dec 4 15:25:16 2015 -0800

    mtd: partitions: remove kmemdup()
    
    The use of kmemdup() complicates the error handling a bit. We don't
    actually need to allocate new memory, since this reference is treated as
    const, and it is copied into new memory by the partition registration
    code anyway. So remove it.
    
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>
    Reviewed-by: Boris Brezillon <boris.brezillon@free-electrons.com>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index 62f83b050978..868ee52d5063 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -532,7 +532,7 @@ int del_mtd_device(struct mtd_info *mtd)
 }
 
 static int mtd_add_device_partitions(struct mtd_info *mtd,
-				     struct mtd_partition *real_parts,
+				     const struct mtd_partition *real_parts,
 				     int nbparts)
 {
 	int ret;
@@ -589,16 +589,12 @@ int mtd_device_parse_register(struct mtd_info *mtd, const char * const *types,
 			      int nr_parts)
 {
 	int ret;
-	struct mtd_partition *real_parts = NULL;
+	const struct mtd_partition *real_parts = NULL;
 
 	ret = parse_mtd_partitions(mtd, types, &real_parts, parser_data);
 	if (ret <= 0 && nr_parts && parts) {
-		real_parts = kmemdup(parts, sizeof(*parts) * nr_parts,
-				     GFP_KERNEL);
-		if (!real_parts)
-			ret = -ENOMEM;
-		else
-			ret = nr_parts;
+		real_parts = parts;
+		ret = nr_parts;
 	}
 	/* Didn't come up with either parsed OR fallback partitions */
 	if (ret < 0) {
@@ -628,7 +624,9 @@ int mtd_device_parse_register(struct mtd_info *mtd, const char * const *types,
 	}
 
 out:
-	kfree(real_parts);
+	/* Cleanup any parsed partitions */
+	if (real_parts != parts)
+		kfree(real_parts);
 	return ret;
 }
 EXPORT_SYMBOL_GPL(mtd_device_parse_register);

commit 617f41836c17688141e1c66f4156c2084f8ca86d
Merge: 26add94cd535 8005c49d9aea
Author: Brian Norris <computersforpeace@gmail.com>
Date:   Sun Nov 15 20:30:53 2015 -0800

    Merge v4.4-rc1 into MTD development
    
    Sync up with the upstream development.
    
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>

commit 215a02fd30871d0d888d27a3154588b66f5dbec2
Author: Brian Norris <computersforpeace@gmail.com>
Date:   Wed Nov 11 16:26:04 2015 -0800

    mtd: grab a reference to the MTD of_node before registering it
    
    We now stick the device node representing the current MTD (if any) into
    sysfs, so let's make sure we have a reference to it before doing that.
    
    Suggested-by: Boris Brezillon <boris.brezillon@free-electrons.com>
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>
    Reviewed-by: Boris Brezillon <boris.brezillon@free-electrons.com>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index a91cee90aef9..c393a1155376 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -32,6 +32,7 @@
 #include <linux/err.h>
 #include <linux/ioctl.h>
 #include <linux/init.h>
+#include <linux/of.h>
 #include <linux/proc_fs.h>
 #include <linux/idr.h>
 #include <linux/backing-dev.h>
@@ -454,6 +455,7 @@ int add_mtd_device(struct mtd_info *mtd)
 	mtd->dev.devt = MTD_DEVT(i);
 	dev_set_name(&mtd->dev, "mtd%d", i);
 	dev_set_drvdata(&mtd->dev, mtd);
+	of_node_get(mtd_get_of_node(mtd));
 	error = device_register(&mtd->dev);
 	if (error)
 		goto fail_added;
@@ -476,6 +478,7 @@ int add_mtd_device(struct mtd_info *mtd)
 	return 0;
 
 fail_added:
+	of_node_put(mtd_get_of_node(mtd));
 	idr_remove(&mtd_idr, i);
 fail_locked:
 	mutex_unlock(&mtd_table_mutex);
@@ -517,6 +520,7 @@ int del_mtd_device(struct mtd_info *mtd)
 		device_unregister(&mtd->dev);
 
 		idr_remove(&mtd_idr, mtd->index);
+		of_node_put(mtd_get_of_node(mtd));
 
 		module_put(THIS_MODULE);
 		ret = 0;

commit ad804a0b2a769a0eed29015c53fe395449c09d13
Merge: ab9f2faf8f40 5f2a2d5d423d
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Nov 7 14:32:45 2015 -0800

    Merge branch 'akpm' (patches from Andrew)
    
    Merge second patch-bomb from Andrew Morton:
    
     - most of the rest of MM
    
     - procfs
    
     - lib/ updates
    
     - printk updates
    
     - bitops infrastructure tweaks
    
     - checkpatch updates
    
     - nilfs2 update
    
     - signals
    
     - various other misc bits: coredump, seqfile, kexec, pidns, zlib, ipc,
       dma-debug, dma-mapping, ...
    
    * emailed patches from Andrew Morton <akpm@linux-foundation.org>: (102 commits)
      ipc,msg: drop dst nil validation in copy_msg
      include/linux/zutil.h: fix usage example of zlib_adler32()
      panic: release stale console lock to always get the logbuf printed out
      dma-debug: check nents in dma_sync_sg*
      dma-mapping: tidy up dma_parms default handling
      pidns: fix set/getpriority and ioprio_set/get in PRIO_USER mode
      kexec: use file name as the output message prefix
      fs, seqfile: always allow oom killer
      seq_file: reuse string_escape_str()
      fs/seq_file: use seq_* helpers in seq_hex_dump()
      coredump: change zap_threads() and zap_process() to use for_each_thread()
      coredump: ensure all coredumping tasks have SIGNAL_GROUP_COREDUMP
      signal: remove jffs2_garbage_collect_thread()->allow_signal(SIGCONT)
      signal: introduce kernel_signal_stop() to fix jffs2_garbage_collect_thread()
      signal: turn dequeue_signal_lock() into kernel_dequeue_signal()
      signals: kill block_all_signals() and unblock_all_signals()
      nilfs2: fix gcc uninitialized-variable warnings in powerpc build
      nilfs2: fix gcc unused-but-set-variable warnings
      MAINTAINERS: nilfs2: add header file for tracing
      nilfs2: add tracepoints for analyzing reading and writing metadata files
      ...

commit d0164adc89f6bb374d304ffcc375c6d2652fe67d
Author: Mel Gorman <mgorman@techsingularity.net>
Date:   Fri Nov 6 16:28:21 2015 -0800

    mm, page_alloc: distinguish between being unable to sleep, unwilling to sleep and avoiding waking kswapd
    
    __GFP_WAIT has been used to identify atomic context in callers that hold
    spinlocks or are in interrupts.  They are expected to be high priority and
    have access one of two watermarks lower than "min" which can be referred
    to as the "atomic reserve".  __GFP_HIGH users get access to the first
    lower watermark and can be called the "high priority reserve".
    
    Over time, callers had a requirement to not block when fallback options
    were available.  Some have abused __GFP_WAIT leading to a situation where
    an optimisitic allocation with a fallback option can access atomic
    reserves.
    
    This patch uses __GFP_ATOMIC to identify callers that are truely atomic,
    cannot sleep and have no alternative.  High priority users continue to use
    __GFP_HIGH.  __GFP_DIRECT_RECLAIM identifies callers that can sleep and
    are willing to enter direct reclaim.  __GFP_KSWAPD_RECLAIM to identify
    callers that want to wake kswapd for background reclaim.  __GFP_WAIT is
    redefined as a caller that is willing to enter direct reclaim and wake
    kswapd for background reclaim.
    
    This patch then converts a number of sites
    
    o __GFP_ATOMIC is used by callers that are high priority and have memory
      pools for those requests. GFP_ATOMIC uses this flag.
    
    o Callers that have a limited mempool to guarantee forward progress clear
      __GFP_DIRECT_RECLAIM but keep __GFP_KSWAPD_RECLAIM. bio allocations fall
      into this category where kswapd will still be woken but atomic reserves
      are not used as there is a one-entry mempool to guarantee progress.
    
    o Callers that are checking if they are non-blocking should use the
      helper gfpflags_allow_blocking() where possible. This is because
      checking for __GFP_WAIT as was done historically now can trigger false
      positives. Some exceptions like dm-crypt.c exist where the code intent
      is clearer if __GFP_DIRECT_RECLAIM is used instead of the helper due to
      flag manipulations.
    
    o Callers that built their own GFP flags instead of starting with GFP_KERNEL
      and friends now also need to specify __GFP_KSWAPD_RECLAIM.
    
    The first key hazard to watch out for is callers that removed __GFP_WAIT
    and was depending on access to atomic reserves for inconspicuous reasons.
    In some cases it may be appropriate for them to use __GFP_HIGH.
    
    The second key hazard is callers that assembled their own combination of
    GFP flags instead of starting with something like GFP_KERNEL.  They may
    now wish to specify __GFP_KSWAPD_RECLAIM.  It's almost certainly harmless
    if it's missed in most cases as other activity will wake kswapd.
    
    Signed-off-by: Mel Gorman <mgorman@techsingularity.net>
    Acked-by: Vlastimil Babka <vbabka@suse.cz>
    Acked-by: Michal Hocko <mhocko@suse.com>
    Acked-by: Johannes Weiner <hannes@cmpxchg.org>
    Cc: Christoph Lameter <cl@linux.com>
    Cc: David Rientjes <rientjes@google.com>
    Cc: Vitaly Wool <vitalywool@gmail.com>
    Cc: Rik van Riel <riel@redhat.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index 8bbbb751bf45..2dfb291a47c6 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -1188,8 +1188,7 @@ EXPORT_SYMBOL_GPL(mtd_writev);
  */
 void *mtd_kmalloc_up_to(const struct mtd_info *mtd, size_t *size)
 {
-	gfp_t flags = __GFP_NOWARN | __GFP_WAIT |
-		       __GFP_NORETRY | __GFP_NO_KSWAPD;
+	gfp_t flags = __GFP_NOWARN | __GFP_DIRECT_RECLAIM | __GFP_NORETRY;
 	size_t min_alloc = max_t(size_t, mtd->writesize, PAGE_SIZE);
 	void *kbuf;
 

commit f8479dd6a03cfdc3b14e742045bfd8748cd86bd7
Author: Brian Norris <computersforpeace@gmail.com>
Date:   Tue Nov 3 17:01:53 2015 -0800

    mtd: don't WARN about overloaded users of mtd->reboot_notifier.notifier_call
    
    There are multiple types of users of mtd->reboot_notifier.notifier_call:
    
    (1) A while back, the cfi_cmdset_000{1,2} chip drivers implemented a
    reboot notifier to (on a best effort basis) attempt to reset their flash
    chips before rebooting.
    
    (2) More recently, we implemented a common _reboot() hook so that MTD
    drivers (particularly, NAND flash) could better halt I/O operations
    without having to reimplement the same notifier boilerplate.
    
    Currently, the WARN_ONCE() condition here was written to handle (2), but
    at the same time it mis-diagnosed case (1) as an already-registered MTD.
    Let's fix this by having the WARN_ONCE() condition better imitate the
    condition that immediately follows it. (Wow, I don't know how I missed
    that one.)
    
    (Side note: Unfortunately, we can't yet combine the reboot notifier code
    for (1) and (2) with a patch like [1], because some users of (1) also
    use mtdconcat, and so the mtd_info struct from cfi_cmdset_000{1,2} won't
    actually get registered with mtdcore, and therefore their reboot
    notifier won't get registered.)
    
    [1] http://patchwork.ozlabs.org/patch/417981/
    
    Suggested-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>
    Cc: Jesper Nilsson <jespern@axis.com>
    Cc: linux-cris-kernel@axis.com
    Tested-by: Ezequiel Garcia <ezequiel@vanguardiasur.com.ar>
    Tested-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index b1eea48c501d..a91cee90aef9 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -616,7 +616,8 @@ int mtd_device_parse_register(struct mtd_info *mtd, const char * const *types,
 	 * does cause problems with parse_mtd_partitions() above (e.g.,
 	 * cmdlineparts will register partitions more than once).
 	 */
-	WARN_ONCE(mtd->reboot_notifier.notifier_call, "MTD already registered\n");
+	WARN_ONCE(mtd->_reboot && mtd->reboot_notifier.notifier_call,
+		  "MTD already registered\n");
 	if (mtd->_reboot && !mtd->reboot_notifier.notifier_call) {
 		mtd->reboot_notifier.notifier_call = mtd_reboot_notifier;
 		register_reboot_notifier(&mtd->reboot_notifier);

commit 5a2415b0769233194f20d3906c3ffc6a2033317c
Author: Brian Norris <computersforpeace@gmail.com>
Date:   Sun Oct 11 13:03:47 2015 -0700

    mtd: mtdpart: Do not fail mtd probe when parsing partitions fails
    
    Due to wrong assumption in ofpart ofpart fails on Exynos on SPI chips
    with no partitions because the subnode containing controller data
    confuses the ofpart parser.
    
    Thus compiling in ofpart support automatically fails probing any SPI NOR
    flash without partitions on Exynos.
    
    Compiling in a partitioning scheme should not cause probe of otherwise
    valid device to fail.
    
    Instead, let's do the following:
     * try parsers until one succeeds
     * if no parser succeeds, report the first error we saw
     * even in the failure case, allow MTD to probe, with fallback
       partitions or no partitions at all -- the master device will still be
       registered
    
    Issue report and comments initially by Michal Suchanek.
    
    Reported-by: Michal Suchanek <hramrach@gmail.com>
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index 41dc501cb49a..b1eea48c501d 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -598,8 +598,10 @@ int mtd_device_parse_register(struct mtd_info *mtd, const char * const *types,
 	}
 	/* Didn't come up with either parsed OR fallback partitions */
 	if (ret < 0) {
-		pr_info("mtd: failed to find partitions\n");
-		goto out;
+		pr_info("mtd: failed to find partitions; one or more parsers reports errors (%d)\n",
+			ret);
+		/* Don't abort on errors; we can still use unpartitioned MTD */
+		ret = 0;
 	}
 
 	ret = mtd_add_device_partitions(mtd, real_parts, ret);

commit be0dbff8b46d69bd738f63b4fe0cf64417f776b0
Author: Brian Norris <computersforpeace@gmail.com>
Date:   Mon Jun 1 16:17:20 2015 -0700

    mtd: warn when registering the same master many times
    
    When CONFIG_MTD_PARTITIONED_MASTER=y, it is fatal to call
    mtd_device_parse_register() twice on the same MTD, as we try to register
    the same device/kobject multipile times.
    
    When CONFIG_MTD_PARTITIONED_MASTER=n, calling
    mtd_device_parse_register() is more of just a nuisance, as we can mostly
    navigate around any conflicting actions.
    
    But anyway, doing so is a Bad Thing (TM), and we should complain loudly
    for any drivers that try to do this.
    
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>
    Reviewed-by: Richard Weinberger <richard@nod.at>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index a2e76ac9f1dc..41dc501cb49a 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -387,6 +387,14 @@ int add_mtd_device(struct mtd_info *mtd)
 	struct mtd_notifier *not;
 	int i, error;
 
+	/*
+	 * May occur, for instance, on buggy drivers which call
+	 * mtd_device_parse_register() multiple times on the same master MTD,
+	 * especially with CONFIG_MTD_PARTITIONED_MASTER=y.
+	 */
+	if (WARN_ONCE(mtd->backing_dev_info, "MTD already registered\n"))
+		return -EEXIST;
+
 	mtd->backing_dev_info = &mtd_bdi;
 
 	BUG_ON(mtd->writesize == 0);
@@ -606,6 +614,7 @@ int mtd_device_parse_register(struct mtd_info *mtd, const char * const *types,
 	 * does cause problems with parse_mtd_partitions() above (e.g.,
 	 * cmdlineparts will register partitions more than once).
 	 */
+	WARN_ONCE(mtd->reboot_notifier.notifier_call, "MTD already registered\n");
 	if (mtd->_reboot && !mtd->reboot_notifier.notifier_call) {
 		mtd->reboot_notifier.notifier_call = mtd_reboot_notifier;
 		register_reboot_notifier(&mtd->reboot_notifier);

commit 3e00ed0e984bbec47f5e531bad3cf36885aa5d83
Author: Brian Norris <computersforpeace@gmail.com>
Date:   Mon Jun 1 16:17:19 2015 -0700

    mtd: fixup corner case error handling in mtd_device_parse_register()
    
    Since commit 3efe41be224c ("mtd: implement common reboot notifier
    boilerplate"), we might try to register a reboot notifier for an MTD
    that failed to register. Let's avoid this by making the error path
    clearer.
    
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>
    Reviewed-by: Richard Weinberger <richard@nod.at>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index bbcba0dbd5c3..a2e76ac9f1dc 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -588,9 +588,15 @@ int mtd_device_parse_register(struct mtd_info *mtd, const char * const *types,
 		else
 			ret = nr_parts;
 	}
+	/* Didn't come up with either parsed OR fallback partitions */
+	if (ret < 0) {
+		pr_info("mtd: failed to find partitions\n");
+		goto out;
+	}
 
-	if (ret >= 0)
-		ret = mtd_add_device_partitions(mtd, real_parts, ret);
+	ret = mtd_add_device_partitions(mtd, real_parts, ret);
+	if (ret)
+		goto out;
 
 	/*
 	 * FIXME: some drivers unfortunately call this function more than once.
@@ -605,6 +611,7 @@ int mtd_device_parse_register(struct mtd_info *mtd, const char * const *types,
 		register_reboot_notifier(&mtd->reboot_notifier);
 	}
 
+out:
 	kfree(real_parts);
 	return ret;
 }

commit 807f16d4db956b364ae852a63ad7d79460838866
Author: Frans Klaver <fransklaver@gmail.com>
Date:   Wed Jun 10 22:38:16 2015 +0200

    mtd: core: set some defaults when dev.parent is set
    
    If a parent device is set, add_mtd_device() has enough knowledge to fill
    in some sane default values for the module name and owner. Do so if they
    aren't already set.
    
    Signed-off-by: Frans Klaver <fransklaver@gmail.com>
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index ac280eef5ae8..bbcba0dbd5c3 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -418,6 +418,15 @@ int add_mtd_device(struct mtd_info *mtd)
 	mtd->erasesize_mask = (1 << mtd->erasesize_shift) - 1;
 	mtd->writesize_mask = (1 << mtd->writesize_shift) - 1;
 
+	if (mtd->dev.parent) {
+		if (!mtd->owner && mtd->dev.parent->driver)
+			mtd->owner = mtd->dev.parent->driver->owner;
+		if (!mtd->name)
+			mtd->name = dev_name(mtd->dev.parent);
+	} else {
+		pr_debug("mtd device won't show a device symlink in sysfs\n");
+	}
+
 	/* Some chips always power up locked. Unlock them now */
 	if ((mtd->flags & MTD_WRITEABLE) && (mtd->flags & MTD_POWERUP_LOCK)) {
 		error = mtd_unlock(mtd, 0, mtd->size);

commit 260e89a6e0d6dcaccd484cf13a69285c3d22268f
Author: Frans Klaver <fransklaver@gmail.com>
Date:   Wed Jun 10 22:38:15 2015 +0200

    mtd: core: tone down suggestion that dev.parent should be set
    
    add_mtd_device() has a comment suggesting that the caller should have
    set dev.parent. This is required to have the parent device symlink show
    up in sysfs, but not for proper operation of the mtd device itself.
    Currently we have five drivers registering mtd devices during module
    initialization, so they don't actually provide a parent device to link
    to. That means we cannot WARN_ON() here, as it would trigger false
    positives.
    
    Make the comment a bit less firm in its assertion that dev.parent should
    be set.
    
    Signed-off-by: Frans Klaver <fransklaver@gmail.com>
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index 8598e3b783fe..ac280eef5ae8 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -430,7 +430,7 @@ int add_mtd_device(struct mtd_info *mtd)
 	}
 
 	/* Caller should have set dev.parent to match the
-	 * physical device.
+	 * physical device, if appropriate.
 	 */
 	mtd->dev.type = &mtd_devtype;
 	mtd->dev.class = &mtd_class;

commit 35667b9983a2a89e504377e89388982dc398773d
Author: Johannes Thumshirn <jthumshirn@suse.de>
Date:   Wed Jul 8 17:15:34 2015 +0200

    mtd: Destroy mtd_idr on module_exit
    
    Destroy mtd_idr on module_exit, reclaiming the allocated memory.
    
    This was detected by the following semantic patch (written by Luis Rodriguez
    <mcgrof@suse.com>)
    <SmPL>
    @ defines_module_init @
    declarer name module_init, module_exit;
    declarer name DEFINE_IDR;
    identifier init;
    @@
    
    module_init(init);
    
    @ defines_module_exit @
    identifier exit;
    @@
    
    module_exit(exit);
    
    @ declares_idr depends on defines_module_init && defines_module_exit @
    identifier idr;
    @@
    
    DEFINE_IDR(idr);
    
    @ on_exit_calls_destroy depends on declares_idr && defines_module_exit @
    identifier declares_idr.idr, defines_module_exit.exit;
    @@
    
    exit(void)
    {
     ...
      idr_destroy(&idr);
      ...
    }
    
    @ missing_module_idr_destroy depends on declares_idr && defines_module_exit && !on_exit_calls_destroy @
    identifier declares_idr.idr, defines_module_exit.exit;
    @@
    
    exit(void)
    {
     ...
     +idr_destroy(&idr);
    }
    </SmPL>
    
    Signed-off-by: Johannes Thumshirn <jthumshirn@suse.de>
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index 8bbbb751bf45..8598e3b783fe 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -1301,6 +1301,7 @@ static void __exit cleanup_mtd(void)
 		remove_proc_entry("mtd", NULL);
 	class_unregister(&mtd_class);
 	bdi_destroy(&mtd_bdi);
+	idr_destroy(&mtd_idr);
 }
 
 module_init(init_mtd);

commit 57dd990c5e9c4664f3db4cba271c808ca7adf9e5
Author: Brian Norris <computersforpeace@gmail.com>
Date:   Mon Jun 1 16:17:18 2015 -0700

    mtd: propagate error codes from add_mtd_device()
    
    It makes more sense to return error statuses, not 1/0.
    
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>
    Reviewed-by: Richard Weinberger <richard@nod.at>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index f3ca97f139bc..8bbbb751bf45 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -379,8 +379,7 @@ static int mtd_reboot_notifier(struct notifier_block *n, unsigned long state,
  *
  *	Add a device to the list of MTD devices present in the system, and
  *	notify each currently active MTD 'user' of its arrival. Returns
- *	zero on success or 1 on failure, which currently will only happen
- *	if there is insufficient memory or a sysfs error.
+ *	zero on success or non-zero on failure.
  */
 
 int add_mtd_device(struct mtd_info *mtd)
@@ -394,8 +393,10 @@ int add_mtd_device(struct mtd_info *mtd)
 	mutex_lock(&mtd_table_mutex);
 
 	i = idr_alloc(&mtd_idr, mtd, 0, 0, GFP_KERNEL);
-	if (i < 0)
+	if (i < 0) {
+		error = i;
 		goto fail_locked;
+	}
 
 	mtd->index = i;
 	mtd->usecount = 0;
@@ -424,6 +425,8 @@ int add_mtd_device(struct mtd_info *mtd)
 			printk(KERN_WARNING
 			       "%s: unlock failed, writes may not work\n",
 			       mtd->name);
+		/* Ignore unlock failures? */
+		error = 0;
 	}
 
 	/* Caller should have set dev.parent to match the
@@ -434,7 +437,8 @@ int add_mtd_device(struct mtd_info *mtd)
 	mtd->dev.devt = MTD_DEVT(i);
 	dev_set_name(&mtd->dev, "mtd%d", i);
 	dev_set_drvdata(&mtd->dev, mtd);
-	if (device_register(&mtd->dev) != 0)
+	error = device_register(&mtd->dev);
+	if (error)
 		goto fail_added;
 
 	device_create(&mtd_class, mtd->dev.parent, MTD_DEVT(i) + 1, NULL,
@@ -458,7 +462,7 @@ int add_mtd_device(struct mtd_info *mtd)
 	idr_remove(&mtd_idr, i);
 fail_locked:
 	mutex_unlock(&mtd_table_mutex);
-	return 1;
+	return error;
 }
 
 /**
@@ -514,8 +518,8 @@ static int mtd_add_device_partitions(struct mtd_info *mtd,
 
 	if (nbparts == 0 || IS_ENABLED(CONFIG_MTD_PARTITIONED_MASTER)) {
 		ret = add_mtd_device(mtd);
-		if (ret == 1)
-			return -ENODEV;
+		if (ret)
+			return ret;
 	}
 
 	if (nbparts > 0) {

commit 57b8045d13569b7d8a1861bd61b7b664e417f7bc
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Mon Apr 6 12:00:39 2015 +0200

    mtd: Switch to PM ops
    
    Use dev_pm_ops instead of the legacy suspend/resume callbacks for the MTD
    class suspend and resume operations.
    
    While we are at it slightly reorder things to avoid the need for forward
    declarations.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index d172195fbd15..f3ca97f139bc 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -48,14 +48,34 @@
 static struct backing_dev_info mtd_bdi = {
 };
 
-static int mtd_cls_suspend(struct device *dev, pm_message_t state);
-static int mtd_cls_resume(struct device *dev);
+#ifdef CONFIG_PM_SLEEP
+
+static int mtd_cls_suspend(struct device *dev)
+{
+	struct mtd_info *mtd = dev_get_drvdata(dev);
+
+	return mtd ? mtd_suspend(mtd) : 0;
+}
+
+static int mtd_cls_resume(struct device *dev)
+{
+	struct mtd_info *mtd = dev_get_drvdata(dev);
+
+	if (mtd)
+		mtd_resume(mtd);
+	return 0;
+}
+
+static SIMPLE_DEV_PM_OPS(mtd_cls_pm_ops, mtd_cls_suspend, mtd_cls_resume);
+#define MTD_CLS_PM_OPS (&mtd_cls_pm_ops)
+#else
+#define MTD_CLS_PM_OPS NULL
+#endif
 
 static struct class mtd_class = {
 	.name = "mtd",
 	.owner = THIS_MODULE,
-	.suspend = mtd_cls_suspend,
-	.resume = mtd_cls_resume,
+	.pm = MTD_CLS_PM_OPS,
 };
 
 static DEFINE_IDR(mtd_idr);
@@ -88,22 +108,6 @@ static void mtd_release(struct device *dev)
 	device_destroy(&mtd_class, index + 1);
 }
 
-static int mtd_cls_suspend(struct device *dev, pm_message_t state)
-{
-	struct mtd_info *mtd = dev_get_drvdata(dev);
-
-	return mtd ? mtd_suspend(mtd) : 0;
-}
-
-static int mtd_cls_resume(struct device *dev)
-{
-	struct mtd_info *mtd = dev_get_drvdata(dev);
-
-	if (mtd)
-		mtd_resume(mtd);
-	return 0;
-}
-
 static ssize_t mtd_type_show(struct device *dev,
 		struct device_attribute *attr, char *buf)
 {

commit 727dc612c46b8f3858537ea23805b3e897cf127e
Author: Dan Ehrenberg <dehrenberg@chromium.org>
Date:   Thu Apr 2 15:15:10 2015 -0700

    mtd: part: Create the master device node when partitioned
    
    For many use cases, it helps to have a device node for the entire
    MTD device as well as device nodes for the individual partitions.
    For example, this allows querying the entire device's properties.
    A common idiom is to create an additional partition which spans
    over the whole device.
    
    This patch makes a config option, CONFIG_MTD_PARTITIONED_MASTER,
    which makes the master partition present even when the device is
    partitioned. This isn't turned on by default since it presents
    a backwards-incompatible device numbering.
    
    The patch also makes the parent of a partition device be the master,
    if the config flag is set, now that the master is a full device.
    
    Signed-off-by: Dan Ehrenberg <dehrenberg@chromium.org>
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index 11883bd26d9d..d172195fbd15 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -38,6 +38,7 @@
 #include <linux/gfp.h>
 #include <linux/slab.h>
 #include <linux/reboot.h>
+#include <linux/kconfig.h>
 
 #include <linux/mtd/mtd.h>
 #include <linux/mtd/partitions.h>
@@ -501,6 +502,29 @@ int del_mtd_device(struct mtd_info *mtd)
 	return ret;
 }
 
+static int mtd_add_device_partitions(struct mtd_info *mtd,
+				     struct mtd_partition *real_parts,
+				     int nbparts)
+{
+	int ret;
+
+	if (nbparts == 0 || IS_ENABLED(CONFIG_MTD_PARTITIONED_MASTER)) {
+		ret = add_mtd_device(mtd);
+		if (ret == 1)
+			return -ENODEV;
+	}
+
+	if (nbparts > 0) {
+		ret = add_mtd_partitions(mtd, real_parts, nbparts);
+		if (ret && IS_ENABLED(CONFIG_MTD_PARTITIONED_MASTER))
+			del_mtd_device(mtd);
+		return ret;
+	}
+
+	return 0;
+}
+
+
 /**
  * mtd_device_parse_register - parse partitions and register an MTD device.
  *
@@ -523,7 +547,8 @@ int del_mtd_device(struct mtd_info *mtd)
  *   found this functions tries to fallback to information specified in
  *   @parts/@nr_parts.
  * * If any partitioning info was found, this function registers the found
- *   partitions.
+ *   partitions. If the MTD_PARTITIONED_MASTER option is set, then the device
+ *   as a whole is registered first.
  * * If no partitions were found this function just registers the MTD device
  *   @mtd and exits.
  *
@@ -534,27 +559,21 @@ int mtd_device_parse_register(struct mtd_info *mtd, const char * const *types,
 			      const struct mtd_partition *parts,
 			      int nr_parts)
 {
-	int err;
-	struct mtd_partition *real_parts;
+	int ret;
+	struct mtd_partition *real_parts = NULL;
 
-	err = parse_mtd_partitions(mtd, types, &real_parts, parser_data);
-	if (err <= 0 && nr_parts && parts) {
+	ret = parse_mtd_partitions(mtd, types, &real_parts, parser_data);
+	if (ret <= 0 && nr_parts && parts) {
 		real_parts = kmemdup(parts, sizeof(*parts) * nr_parts,
 				     GFP_KERNEL);
 		if (!real_parts)
-			err = -ENOMEM;
+			ret = -ENOMEM;
 		else
-			err = nr_parts;
+			ret = nr_parts;
 	}
 
-	if (err > 0) {
-		err = add_mtd_partitions(mtd, real_parts, err);
-		kfree(real_parts);
-	} else if (err == 0) {
-		err = add_mtd_device(mtd);
-		if (err == 1)
-			err = -ENODEV;
-	}
+	if (ret >= 0)
+		ret = mtd_add_device_partitions(mtd, real_parts, ret);
 
 	/*
 	 * FIXME: some drivers unfortunately call this function more than once.
@@ -569,7 +588,8 @@ int mtd_device_parse_register(struct mtd_info *mtd, const char * const *types,
 		register_reboot_notifier(&mtd->reboot_notifier);
 	}
 
-	return err;
+	kfree(real_parts);
+	return ret;
 }
 EXPORT_SYMBOL_GPL(mtd_device_parse_register);
 

commit 402521b8f7cc1f4f442418cc98ec6e37388207b0
Merge: f5af19d10d15 eb928d40a93f
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Feb 18 08:01:44 2015 -0800

    Merge tag 'for-linus-20150216' of git://git.infradead.org/linux-mtd
    
    Pull MTD updates from Brian Norris:
     "NAND:
    
       - Add new Hisilicon NAND driver for Hip04
       - Add default reboot handler, to ensure all outstanding erase
         transactions complete in time
       - jz4740: convert to use GPIO descriptor API
       - Atmel: add support for sama5d4
       - Change default bitflip threshold to 75% of correction strength
       - Miscellaneous cleanups and bugfixes
    
      SPI NOR:
    
       - Freescale QuadSPI:
       - Fix a few probe() and remove() issues
       - Add a MAINTAINERS entry for this driver
       - Tweak transfer size to increase read performance
       - Add suspend/resume support
       - Add Micron quad I/O support
       - ST FSM SPI: miscellaneous fixes
    
      JFFS2:
    
       - gracefully handle corrupted 'offset' field found on flash
    
      Other:
    
       - bcm47xxpart: add tweaks for a few new devices
       - mtdconcat: set return lengths properly for mtd_write_oob()
       - map_ram: enable use with mtdoops
       - maps: support fallback to ROM/UBI for write-protected NOR flash"
    
    * tag 'for-linus-20150216' of git://git.infradead.org/linux-mtd: (46 commits)
      mtd: hisilicon: && vs & typo
      jffs2: fix handling of corrupted summary length
      mtd: hisilicon: add device tree binding documentation
      mtd: hisilicon: add a new NAND controller driver for hisilicon hip04 Soc
      mtd: avoid registering reboot notifier twice
      mtd: concat: set the return lengths properly
      mtd: kconfig: replace PPC_OF with PPC
      mtd: denali: remove unnecessary stubs
      mtd: nand: remove redundant local variable
      MAINTAINERS: add maintainer entry for FREESCALE QUAD SPI driver
      mtd: fsl-quadspi: improve read performance by increase AHB transfer size
      mtd: fsl-quadspi: Remove unnecessary 'map_failed' label
      mtd: fsl-quadspi: Remove unneeded success/error messages
      mtd: fsl-quadspi: Fix the error paths
      mtd: nand: omap: drop condition with no effect
      mtd: nand: jz4740: Convert to GPIO descriptor API
      mtd: nand: Request strength instead of bytes for soft BCH
      mtd: nand: default bitflip-reporting threshold to 75% of correction strength
      mtd: atmel_nand: introduce a new compatible string for sama5d4 chip
      mtd: atmel_nand: return max bitflips in all sectors in pmecc_correction()
      ...

commit e1dd8641c8c36ff4aacf24c7e2575770e30afbe5
Author: Niklas Cassel <nks@flawful.org>
Date:   Sun Feb 1 02:08:50 2015 +0100

    mtd: avoid registering reboot notifier twice
    
    Calling mtd_device_parse_register with the same mtd_info
    (e.g. registering several partitions on a single device)
    would add the same reboot notifier twice, causing an
    infinte loop in notifier_chain_register during boot up.
    
    Signed-off-by: Niklas Cassel <nks@flawful.org>
    [Brian: add FIXME comments]
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>
    
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index cbc0fc46d2d6..52eea932c312 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -577,7 +577,15 @@ int mtd_device_parse_register(struct mtd_info *mtd, const char * const *types,
 			err = -ENODEV;
 	}
 
-	if (mtd->_reboot) {
+	/*
+	 * FIXME: some drivers unfortunately call this function more than once.
+	 * So we have to check if we've already assigned the reboot notifier.
+	 *
+	 * Generally, we can make multiple calls work for most cases, but it
+	 * does cause problems with parse_mtd_partitions() above (e.g.,
+	 * cmdlineparts will register partitions more than once).
+	 */
+	if (mtd->_reboot && !mtd->reboot_notifier.notifier_call) {
 		mtd->reboot_notifier.notifier_call = mtd_reboot_notifier;
 		register_reboot_notifier(&mtd->reboot_notifier);
 	}

commit 706a4e5a120aa40b31a22a4ad0cdd738d78a91a3
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Wed Jan 28 11:09:20 2015 -0700

    mtd: export new mtd_mmap_capabilities
    
    The recently added mtd_mmap_capabilities can be used from loadable
    modules, in particular romfs, but is not exported, so we get
    
    ERROR: "mtd_mmap_capabilities" [fs/romfs/romfs.ko] undefined!
    
    This adds the missing export.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Fixes: b4caecd48005f ("fs: introduce f_op->mmap_capabilities for nommu mmap support")
    Acked-by: Christoph Hellwig <hch@lst.de>
    Acked-by: Brian Norris <computersforpeace@gmail.com>
    Signed-off-by: Jens Axboe <axboe@fb.com>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index ff38a1df22f7..0ec4d6ea1e4b 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -353,6 +353,7 @@ unsigned mtd_mmap_capabilities(struct mtd_info *mtd)
 		return NOMMU_MAP_COPY;
 	}
 }
+EXPORT_SYMBOL_GPL(mtd_mmap_capabilities);
 #endif
 
 /**

commit b4caecd48005fbed3949dde6c1cb233142fd69e9
Author: Christoph Hellwig <hch@lst.de>
Date:   Wed Jan 14 10:42:32 2015 +0100

    fs: introduce f_op->mmap_capabilities for nommu mmap support
    
    Since "BDI: Provide backing device capability information [try #3]" the
    backing_dev_info structure also provides flags for the kind of mmap
    operation available in a nommu environment, which is entirely unrelated
    to it's original purpose.
    
    Introduce a new nommu-only file operation to provide this information to
    the nommu mmap code instead.  Splitting this from the backing_dev_info
    structure allows to remove lots of backing_dev_info instance that aren't
    otherwise needed, and entirely gets rid of the concept of providing a
    backing_dev_info for a character device.  It also removes the need for
    the mtd_inodefs filesystem.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Tejun Heo <tj@kernel.org>
    Acked-by: Brian Norris <computersforpeace@gmail.com>
    Signed-off-by: Jens Axboe <axboe@fb.com>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index 4c611871d7e6..ff38a1df22f7 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -43,33 +43,7 @@
 
 #include "mtdcore.h"
 
-/*
- * backing device capabilities for non-mappable devices (such as NAND flash)
- * - permits private mappings, copies are taken of the data
- */
-static struct backing_dev_info mtd_bdi_unmappable = {
-	.capabilities	= BDI_CAP_MAP_COPY,
-};
-
-/*
- * backing device capabilities for R/O mappable devices (such as ROM)
- * - permits private mappings, copies are taken of the data
- * - permits non-writable shared mappings
- */
-static struct backing_dev_info mtd_bdi_ro_mappable = {
-	.capabilities	= (BDI_CAP_MAP_COPY | BDI_CAP_MAP_DIRECT |
-			   BDI_CAP_EXEC_MAP | BDI_CAP_READ_MAP),
-};
-
-/*
- * backing device capabilities for writable mappable devices (such as RAM)
- * - permits private mappings, copies are taken of the data
- * - permits non-writable shared mappings
- */
-static struct backing_dev_info mtd_bdi_rw_mappable = {
-	.capabilities	= (BDI_CAP_MAP_COPY | BDI_CAP_MAP_DIRECT |
-			   BDI_CAP_EXEC_MAP | BDI_CAP_READ_MAP |
-			   BDI_CAP_WRITE_MAP),
+static struct backing_dev_info mtd_bdi = {
 };
 
 static int mtd_cls_suspend(struct device *dev, pm_message_t state);
@@ -365,6 +339,22 @@ static struct device_type mtd_devtype = {
 	.release	= mtd_release,
 };
 
+#ifndef CONFIG_MMU
+unsigned mtd_mmap_capabilities(struct mtd_info *mtd)
+{
+	switch (mtd->type) {
+	case MTD_RAM:
+		return NOMMU_MAP_COPY | NOMMU_MAP_DIRECT | NOMMU_MAP_EXEC |
+			NOMMU_MAP_READ | NOMMU_MAP_WRITE;
+	case MTD_ROM:
+		return NOMMU_MAP_COPY | NOMMU_MAP_DIRECT | NOMMU_MAP_EXEC |
+			NOMMU_MAP_READ;
+	default:
+		return NOMMU_MAP_COPY;
+	}
+}
+#endif
+
 /**
  *	add_mtd_device - register an MTD device
  *	@mtd: pointer to new MTD device info structure
@@ -380,19 +370,7 @@ int add_mtd_device(struct mtd_info *mtd)
 	struct mtd_notifier *not;
 	int i, error;
 
-	if (!mtd->backing_dev_info) {
-		switch (mtd->type) {
-		case MTD_RAM:
-			mtd->backing_dev_info = &mtd_bdi_rw_mappable;
-			break;
-		case MTD_ROM:
-			mtd->backing_dev_info = &mtd_bdi_ro_mappable;
-			break;
-		default:
-			mtd->backing_dev_info = &mtd_bdi_unmappable;
-			break;
-		}
-	}
+	mtd->backing_dev_info = &mtd_bdi;
 
 	BUG_ON(mtd->writesize == 0);
 	mutex_lock(&mtd_table_mutex);
@@ -1237,17 +1215,9 @@ static int __init init_mtd(void)
 	if (ret)
 		goto err_reg;
 
-	ret = mtd_bdi_init(&mtd_bdi_unmappable, "mtd-unmap");
-	if (ret)
-		goto err_bdi1;
-
-	ret = mtd_bdi_init(&mtd_bdi_ro_mappable, "mtd-romap");
-	if (ret)
-		goto err_bdi2;
-
-	ret = mtd_bdi_init(&mtd_bdi_rw_mappable, "mtd-rwmap");
+	ret = mtd_bdi_init(&mtd_bdi, "mtd");
 	if (ret)
-		goto err_bdi3;
+		goto err_bdi;
 
 	proc_mtd = proc_create("mtd", 0, NULL, &mtd_proc_ops);
 
@@ -1260,11 +1230,7 @@ static int __init init_mtd(void)
 out_procfs:
 	if (proc_mtd)
 		remove_proc_entry("mtd", NULL);
-err_bdi3:
-	bdi_destroy(&mtd_bdi_ro_mappable);
-err_bdi2:
-	bdi_destroy(&mtd_bdi_unmappable);
-err_bdi1:
+err_bdi:
 	class_unregister(&mtd_class);
 err_reg:
 	pr_err("Error registering mtd class or bdi: %d\n", ret);
@@ -1277,9 +1243,7 @@ static void __exit cleanup_mtd(void)
 	if (proc_mtd)
 		remove_proc_entry("mtd", NULL);
 	class_unregister(&mtd_class);
-	bdi_destroy(&mtd_bdi_unmappable);
-	bdi_destroy(&mtd_bdi_ro_mappable);
-	bdi_destroy(&mtd_bdi_rw_mappable);
+	bdi_destroy(&mtd_bdi);
 }
 
 module_init(init_mtd);

commit 3efe41be224c4441f2a872a25471a14d85ceb7c6
Author: Brian Norris <computersforpeace@gmail.com>
Date:   Wed Nov 26 01:01:08 2014 -0800

    mtd: implement common reboot notifier boilerplate
    
    cfi_cmdset_000{1,2}.c already implement their own reboot notifiers, and
    we're going to add one for NAND. Let's put the boilerplate in one place.
    
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>
    Tested-by: Scott Branden <sbranden@broadcom.com>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index 4c611871d7e6..cbc0fc46d2d6 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -37,6 +37,7 @@
 #include <linux/backing-dev.h>
 #include <linux/gfp.h>
 #include <linux/slab.h>
+#include <linux/reboot.h>
 
 #include <linux/mtd/mtd.h>
 #include <linux/mtd/partitions.h>
@@ -365,6 +366,17 @@ static struct device_type mtd_devtype = {
 	.release	= mtd_release,
 };
 
+static int mtd_reboot_notifier(struct notifier_block *n, unsigned long state,
+			       void *cmd)
+{
+	struct mtd_info *mtd;
+
+	mtd = container_of(n, struct mtd_info, reboot_notifier);
+	mtd->_reboot(mtd);
+
+	return NOTIFY_DONE;
+}
+
 /**
  *	add_mtd_device - register an MTD device
  *	@mtd: pointer to new MTD device info structure
@@ -565,6 +577,11 @@ int mtd_device_parse_register(struct mtd_info *mtd, const char * const *types,
 			err = -ENODEV;
 	}
 
+	if (mtd->_reboot) {
+		mtd->reboot_notifier.notifier_call = mtd_reboot_notifier;
+		register_reboot_notifier(&mtd->reboot_notifier);
+	}
+
 	return err;
 }
 EXPORT_SYMBOL_GPL(mtd_device_parse_register);
@@ -579,6 +596,9 @@ int mtd_device_unregister(struct mtd_info *master)
 {
 	int err;
 
+	if (master->_reboot)
+		unregister_reboot_notifier(&master->reboot_notifier);
+
 	err = del_mtd_partitions(master);
 	if (err)
 		return err;

commit 5e47212831ac565993d21ebd36216d98f2b58f30
Author: Brian Norris <computersforpeace@gmail.com>
Date:   Mon Jul 21 19:06:47 2014 -0700

    mtd: remove dead non-char logic
    
    MTD used to allow compiling out character device support. This was
    dropped in the following commit, but some of the accompanying logic was
    never dropped:
    
      commit 660685d9d1b4730f0b5ca97fa95f272f99c63bce
      Author: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
      Date:   Thu Mar 14 13:27:40 2013 +0200
    
          mtd: merge mtdchar module with mtdcore
    
    The weird logic was flagged by Coverity.
    
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>
    Cc: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index c1015173f2d9..4c611871d7e6 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -105,12 +105,11 @@ static LIST_HEAD(mtd_notifiers);
  */
 static void mtd_release(struct device *dev)
 {
-	struct mtd_info __maybe_unused *mtd = dev_get_drvdata(dev);
+	struct mtd_info *mtd = dev_get_drvdata(dev);
 	dev_t index = MTD_DEVT(mtd->index);
 
-	/* remove /dev/mtdXro node if needed */
-	if (index)
-		device_destroy(&mtd_class, index + 1);
+	/* remove /dev/mtdXro node */
+	device_destroy(&mtd_class, index + 1);
 }
 
 static int mtd_cls_suspend(struct device *dev, pm_message_t state)
@@ -442,10 +441,8 @@ int add_mtd_device(struct mtd_info *mtd)
 	if (device_register(&mtd->dev) != 0)
 		goto fail_added;
 
-	if (MTD_DEVT(i))
-		device_create(&mtd_class, mtd->dev.parent,
-			      MTD_DEVT(i) + 1,
-			      NULL, "mtd%dro", i);
+	device_create(&mtd_class, mtd->dev.parent, MTD_DEVT(i) + 1, NULL,
+		      "mtd%dro", i);
 
 	pr_debug("mtd: Giving out device %d to %s\n", i, mtd->name);
 	/* No need to get a refcount on the module containing

commit 0c2b4e21444d0e274e91fc7db85caddb30988853
Author: Brian Norris <computersforpeace@gmail.com>
Date:   Mon Jul 21 19:06:27 2014 -0700

    mtd: correct upper bounds check for mtd_*() APIs
    
    When checking the upper boundary (i.e., whether an address is higher
    than the maximum size of the MTD), we should be doing an inclusive check
    (greater or equal). For instance, an address of 16MB (0x1000000) on a
    16MB device is invalid.
    
    The strengthening of this bounds check is redundant for those which
    already have a address+length check and ensure that the length is
    non-zero, but let's just fix them all, for completeness.
    
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index e4831b4159db..c1015173f2d9 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -778,7 +778,7 @@ EXPORT_SYMBOL_GPL(__put_mtd_device);
  */
 int mtd_erase(struct mtd_info *mtd, struct erase_info *instr)
 {
-	if (instr->addr > mtd->size || instr->len > mtd->size - instr->addr)
+	if (instr->addr >= mtd->size || instr->len > mtd->size - instr->addr)
 		return -EINVAL;
 	if (!(mtd->flags & MTD_WRITEABLE))
 		return -EROFS;
@@ -804,7 +804,7 @@ int mtd_point(struct mtd_info *mtd, loff_t from, size_t len, size_t *retlen,
 		*phys = 0;
 	if (!mtd->_point)
 		return -EOPNOTSUPP;
-	if (from < 0 || from > mtd->size || len > mtd->size - from)
+	if (from < 0 || from >= mtd->size || len > mtd->size - from)
 		return -EINVAL;
 	if (!len)
 		return 0;
@@ -817,7 +817,7 @@ int mtd_unpoint(struct mtd_info *mtd, loff_t from, size_t len)
 {
 	if (!mtd->_point)
 		return -EOPNOTSUPP;
-	if (from < 0 || from > mtd->size || len > mtd->size - from)
+	if (from < 0 || from >= mtd->size || len > mtd->size - from)
 		return -EINVAL;
 	if (!len)
 		return 0;
@@ -835,7 +835,7 @@ unsigned long mtd_get_unmapped_area(struct mtd_info *mtd, unsigned long len,
 {
 	if (!mtd->_get_unmapped_area)
 		return -EOPNOTSUPP;
-	if (offset > mtd->size || len > mtd->size - offset)
+	if (offset >= mtd->size || len > mtd->size - offset)
 		return -EINVAL;
 	return mtd->_get_unmapped_area(mtd, len, offset, flags);
 }
@@ -846,7 +846,7 @@ int mtd_read(struct mtd_info *mtd, loff_t from, size_t len, size_t *retlen,
 {
 	int ret_code;
 	*retlen = 0;
-	if (from < 0 || from > mtd->size || len > mtd->size - from)
+	if (from < 0 || from >= mtd->size || len > mtd->size - from)
 		return -EINVAL;
 	if (!len)
 		return 0;
@@ -869,7 +869,7 @@ int mtd_write(struct mtd_info *mtd, loff_t to, size_t len, size_t *retlen,
 	      const u_char *buf)
 {
 	*retlen = 0;
-	if (to < 0 || to > mtd->size || len > mtd->size - to)
+	if (to < 0 || to >= mtd->size || len > mtd->size - to)
 		return -EINVAL;
 	if (!mtd->_write || !(mtd->flags & MTD_WRITEABLE))
 		return -EROFS;
@@ -892,7 +892,7 @@ int mtd_panic_write(struct mtd_info *mtd, loff_t to, size_t len, size_t *retlen,
 	*retlen = 0;
 	if (!mtd->_panic_write)
 		return -EOPNOTSUPP;
-	if (to < 0 || to > mtd->size || len > mtd->size - to)
+	if (to < 0 || to >= mtd->size || len > mtd->size - to)
 		return -EINVAL;
 	if (!(mtd->flags & MTD_WRITEABLE))
 		return -EROFS;
@@ -1011,7 +1011,7 @@ int mtd_lock(struct mtd_info *mtd, loff_t ofs, uint64_t len)
 {
 	if (!mtd->_lock)
 		return -EOPNOTSUPP;
-	if (ofs < 0 || ofs > mtd->size || len > mtd->size - ofs)
+	if (ofs < 0 || ofs >= mtd->size || len > mtd->size - ofs)
 		return -EINVAL;
 	if (!len)
 		return 0;
@@ -1023,7 +1023,7 @@ int mtd_unlock(struct mtd_info *mtd, loff_t ofs, uint64_t len)
 {
 	if (!mtd->_unlock)
 		return -EOPNOTSUPP;
-	if (ofs < 0 || ofs > mtd->size || len > mtd->size - ofs)
+	if (ofs < 0 || ofs >= mtd->size || len > mtd->size - ofs)
 		return -EINVAL;
 	if (!len)
 		return 0;
@@ -1035,7 +1035,7 @@ int mtd_is_locked(struct mtd_info *mtd, loff_t ofs, uint64_t len)
 {
 	if (!mtd->_is_locked)
 		return -EOPNOTSUPP;
-	if (ofs < 0 || ofs > mtd->size || len > mtd->size - ofs)
+	if (ofs < 0 || ofs >= mtd->size || len > mtd->size - ofs)
 		return -EINVAL;
 	if (!len)
 		return 0;
@@ -1045,7 +1045,7 @@ EXPORT_SYMBOL_GPL(mtd_is_locked);
 
 int mtd_block_isreserved(struct mtd_info *mtd, loff_t ofs)
 {
-	if (ofs < 0 || ofs > mtd->size)
+	if (ofs < 0 || ofs >= mtd->size)
 		return -EINVAL;
 	if (!mtd->_block_isreserved)
 		return 0;
@@ -1055,7 +1055,7 @@ EXPORT_SYMBOL_GPL(mtd_block_isreserved);
 
 int mtd_block_isbad(struct mtd_info *mtd, loff_t ofs)
 {
-	if (ofs < 0 || ofs > mtd->size)
+	if (ofs < 0 || ofs >= mtd->size)
 		return -EINVAL;
 	if (!mtd->_block_isbad)
 		return 0;
@@ -1067,7 +1067,7 @@ int mtd_block_markbad(struct mtd_info *mtd, loff_t ofs)
 {
 	if (!mtd->_block_markbad)
 		return -EOPNOTSUPP;
-	if (ofs < 0 || ofs > mtd->size)
+	if (ofs < 0 || ofs >= mtd->size)
 		return -EINVAL;
 	if (!(mtd->flags & MTD_WRITEABLE))
 		return -EROFS;

commit 8471bb73ba10ed6788b4f1e9b8a0f9dc6bdb05b5
Author: Ezequiel Garcia <ezequiel.garcia@free-electrons.com>
Date:   Wed May 21 19:06:12 2014 -0300

    mtd: Introduce mtd_block_isreserved()
    
    In addition to mtd_block_isbad(), which checks if a block is bad or
    reserved, it's needed to check if a block is reserved only (but not
    bad). This commit adds an MTD interface for it, in a similar fashion to
    mtd_block_isbad().
    
    While here, fix mtd_block_isbad() so the out-of-bounds checking is done
    before the callback check.
    
    Signed-off-by: Ezequiel Garcia <ezequiel.garcia@free-electrons.com>
    Tested-by: Pekon Gupta <pekon@ti.com>
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index 11857faa0d96..e4831b4159db 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -1043,12 +1043,22 @@ int mtd_is_locked(struct mtd_info *mtd, loff_t ofs, uint64_t len)
 }
 EXPORT_SYMBOL_GPL(mtd_is_locked);
 
-int mtd_block_isbad(struct mtd_info *mtd, loff_t ofs)
+int mtd_block_isreserved(struct mtd_info *mtd, loff_t ofs)
 {
-	if (!mtd->_block_isbad)
+	if (ofs < 0 || ofs > mtd->size)
+		return -EINVAL;
+	if (!mtd->_block_isreserved)
 		return 0;
+	return mtd->_block_isreserved(mtd, ofs);
+}
+EXPORT_SYMBOL_GPL(mtd_block_isreserved);
+
+int mtd_block_isbad(struct mtd_info *mtd, loff_t ofs)
+{
 	if (ofs < 0 || ofs > mtd->size)
 		return -EINVAL;
+	if (!mtd->_block_isbad)
+		return 0;
 	return mtd->_block_isbad(mtd, ofs);
 }
 EXPORT_SYMBOL_GPL(mtd_block_isbad);

commit 990a3af0c20590954be01a95c2c3fcef9360a836
Author: Ezequiel Garcia <ezequiel.garcia@free-electrons.com>
Date:   Tue Jun 24 10:55:50 2014 -0300

    mtd: Add sysfs attributes to expose the ECC stats fields
    
    These new sysfs device attributes allow us to retrieve the ECC and bad
    block stats by poking a sysfs file, which is often more convenient than
    using the ioctl.
    
    Signed-off-by: Ezequiel Garcia <ezequiel.garcia@free-electrons.com>
    Tested-by: Pekon Gupta <pekon@ti.com>
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index d201feeb3ca6..11857faa0d96 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -298,6 +298,47 @@ static ssize_t mtd_ecc_step_size_show(struct device *dev,
 }
 static DEVICE_ATTR(ecc_step_size, S_IRUGO, mtd_ecc_step_size_show, NULL);
 
+static ssize_t mtd_ecc_stats_corrected_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct mtd_info *mtd = dev_get_drvdata(dev);
+	struct mtd_ecc_stats *ecc_stats = &mtd->ecc_stats;
+
+	return snprintf(buf, PAGE_SIZE, "%u\n", ecc_stats->corrected);
+}
+static DEVICE_ATTR(corrected_bits, S_IRUGO,
+		   mtd_ecc_stats_corrected_show, NULL);
+
+static ssize_t mtd_ecc_stats_errors_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct mtd_info *mtd = dev_get_drvdata(dev);
+	struct mtd_ecc_stats *ecc_stats = &mtd->ecc_stats;
+
+	return snprintf(buf, PAGE_SIZE, "%u\n", ecc_stats->failed);
+}
+static DEVICE_ATTR(ecc_failures, S_IRUGO, mtd_ecc_stats_errors_show, NULL);
+
+static ssize_t mtd_badblocks_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct mtd_info *mtd = dev_get_drvdata(dev);
+	struct mtd_ecc_stats *ecc_stats = &mtd->ecc_stats;
+
+	return snprintf(buf, PAGE_SIZE, "%u\n", ecc_stats->badblocks);
+}
+static DEVICE_ATTR(bad_blocks, S_IRUGO, mtd_badblocks_show, NULL);
+
+static ssize_t mtd_bbtblocks_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct mtd_info *mtd = dev_get_drvdata(dev);
+	struct mtd_ecc_stats *ecc_stats = &mtd->ecc_stats;
+
+	return snprintf(buf, PAGE_SIZE, "%u\n", ecc_stats->bbtblocks);
+}
+static DEVICE_ATTR(bbt_blocks, S_IRUGO, mtd_bbtblocks_show, NULL);
+
 static struct attribute *mtd_attrs[] = {
 	&dev_attr_type.attr,
 	&dev_attr_flags.attr,
@@ -310,6 +351,10 @@ static struct attribute *mtd_attrs[] = {
 	&dev_attr_name.attr,
 	&dev_attr_ecc_strength.attr,
 	&dev_attr_ecc_step_size.attr,
+	&dev_attr_corrected_bits.attr,
+	&dev_attr_ecc_failures.attr,
+	&dev_attr_bad_blocks.attr,
+	&dev_attr_bbt_blocks.attr,
 	&dev_attr_bitflip_threshold.attr,
 	NULL,
 };

commit 9a78bc83b4c31f67202b7b0a77fa25da732f44a3
Author: Christian Riesch <christian.riesch@omicron.at>
Date:   Thu Mar 6 12:42:37 2014 +0100

    mtd: Fix the behavior of OTP write if there is not enough room for data
    
    If a write to one time programmable memory (OTP) hits the end of this
    memory area, no more data can be written. The count variable in
    mtdchar_write() in drivers/mtd/mtdchar.c is not decreased anymore.
    We are trapped in the loop forever, mtdchar_write() will never return
    in this case.
    
    The desired behavior of a write in such a case is described in [1]:
    - Try to write as much data as possible, truncate the write to fit into
      the available memory and return the number of bytes that actually
      have been written.
    - If no data could be written at all, return -ENOSPC.
    
    This patch fixes the behavior of OTP write if there is not enough space
    for all data:
    
    1) mtd_write_user_prot_reg() in drivers/mtd/mtdcore.c is modified to
       return -ENOSPC if no data could be written at all.
    2) mtdchar_write() is modified to handle -ENOSPC correctly. Exit if a
       write returned -ENOSPC and yield the correct return value, either
       then number of bytes that could be written, or -ENOSPC, if no data
       could be written at all.
    
    Furthermore the patch harmonizes the behavior of the OTP memory write
    in drivers/mtd/devices/mtd_dataflash.c with the other implementations
    and the requirements from [1]. Instead of returning -EINVAL if the data
    does not fit into the OTP memory, we try to write as much data as
    possible/truncate the write.
    
    [1] http://pubs.opengroup.org/onlinepubs/9699919799/functions/write.html
    
    Signed-off-by: Christian Riesch <christian.riesch@omicron.at>
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index 0a7d77e65335..d201feeb3ca6 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -932,12 +932,22 @@ EXPORT_SYMBOL_GPL(mtd_read_user_prot_reg);
 int mtd_write_user_prot_reg(struct mtd_info *mtd, loff_t to, size_t len,
 			    size_t *retlen, u_char *buf)
 {
+	int ret;
+
 	*retlen = 0;
 	if (!mtd->_write_user_prot_reg)
 		return -EOPNOTSUPP;
 	if (!len)
 		return 0;
-	return mtd->_write_user_prot_reg(mtd, to, len, retlen, buf);
+	ret = mtd->_write_user_prot_reg(mtd, to, len, retlen, buf);
+	if (ret)
+		return ret;
+
+	/*
+	 * If no data could be written at all, we are out of memory and
+	 * must return -ENOSPC.
+	 */
+	return (*retlen) ? 0 : -ENOSPC;
 }
 EXPORT_SYMBOL_GPL(mtd_write_user_prot_reg);
 

commit 4b78fc42f3e3f07687dc27efc1153d29e360afa1
Author: Christian Riesch <christian.riesch@omicron.at>
Date:   Tue Jan 28 09:29:44 2014 +0100

    mtd: Add a retlen parameter to _get_{fact,user}_prot_info
    
    Signed-off-by: Christian Riesch <christian.riesch@omicron.at>
    Cc: Artem Bityutskiy <Artem.Bityutskiy@linux.intel.com>
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index 34c0b16aed5c..0a7d77e65335 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -883,14 +883,14 @@ EXPORT_SYMBOL_GPL(mtd_read_oob);
  * devices. The user data is one time programmable but the factory data is read
  * only.
  */
-int mtd_get_fact_prot_info(struct mtd_info *mtd, struct otp_info *buf,
-			   size_t len)
+int mtd_get_fact_prot_info(struct mtd_info *mtd, size_t len, size_t *retlen,
+			   struct otp_info *buf)
 {
 	if (!mtd->_get_fact_prot_info)
 		return -EOPNOTSUPP;
 	if (!len)
 		return 0;
-	return mtd->_get_fact_prot_info(mtd, buf, len);
+	return mtd->_get_fact_prot_info(mtd, len, retlen, buf);
 }
 EXPORT_SYMBOL_GPL(mtd_get_fact_prot_info);
 
@@ -906,14 +906,14 @@ int mtd_read_fact_prot_reg(struct mtd_info *mtd, loff_t from, size_t len,
 }
 EXPORT_SYMBOL_GPL(mtd_read_fact_prot_reg);
 
-int mtd_get_user_prot_info(struct mtd_info *mtd, struct otp_info *buf,
-			   size_t len)
+int mtd_get_user_prot_info(struct mtd_info *mtd, size_t len, size_t *retlen,
+			   struct otp_info *buf)
 {
 	if (!mtd->_get_user_prot_info)
 		return -EOPNOTSUPP;
 	if (!len)
 		return 0;
-	return mtd->_get_user_prot_info(mtd, buf, len);
+	return mtd->_get_user_prot_info(mtd, len, retlen, buf);
 }
 EXPORT_SYMBOL_GPL(mtd_get_user_prot_info);
 

commit 54c738f694ab67a007a43482d1dd7cf956fbb6c3
Author: Axel Lin <axel.lin@ingics.com>
Date:   Mon Dec 2 10:12:25 2013 +0800

    mtd: convert to use ATTRIBUTE_GROUPS
    
    Use new ATTRIBUTE_GROUPS macro to declare attribute groups.
    
    Signed-off-by: Axel Lin <axel.lin@ingics.com>
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index 92311a56939f..34c0b16aed5c 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -313,15 +313,7 @@ static struct attribute *mtd_attrs[] = {
 	&dev_attr_bitflip_threshold.attr,
 	NULL,
 };
-
-static struct attribute_group mtd_group = {
-	.attrs		= mtd_attrs,
-};
-
-static const struct attribute_group *mtd_groups[] = {
-	&mtd_group,
-	NULL,
-};
+ATTRIBUTE_GROUPS(mtd);
 
 static struct device_type mtd_devtype = {
 	.name		= "mtd",

commit ca5295f48b25ee58fd9de8830fe4016d1d45eb0a
Author: Wei Yongjun <yongjun_wei@trendmicro.com.cn>
Date:   Wed Oct 30 13:34:22 2013 +0800

    mtd: remove duplicated include from mtdcore.c
    
    Remove duplicated include.
    
    Signed-off-by: Wei Yongjun <yongjun_wei@trendmicro.com.cn>
    Acked-by: Ezequiel Garcia <ezequiel.garcia@free-electrons.com>
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index 7189089d87e3..92311a56939f 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -37,7 +37,6 @@
 #include <linux/backing-dev.h>
 #include <linux/gfp.h>
 #include <linux/slab.h>
-#include <linux/major.h>
 
 #include <linux/mtd/mtd.h>
 #include <linux/mtd/partitions.h>

commit f83c3838b9146b891d0405d3a83660e8f6aed02f
Author: Ezequiel Garcia <ezequiel.garcia@free-electrons.com>
Date:   Sun Oct 13 18:05:23 2013 -0300

    mtd: Move major number definitions to major.h
    
    This patch moves the char and block major number definitions
    to major.h to be with the rest of the major numbers.
    While doing this, include major.h in the files that need it.
    
    Signed-off-by: Ezequiel Garcia <ezequiel.garcia@free-electrons.com>
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index 92311a56939f..7189089d87e3 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -37,6 +37,7 @@
 #include <linux/backing-dev.h>
 #include <linux/gfp.h>
 #include <linux/slab.h>
+#include <linux/major.h>
 
 #include <linux/mtd/mtd.h>
 #include <linux/mtd/partitions.h>

commit f48372465ffdff62a6d75a6f34bc850855fb6470
Author: Huang Shijie <b32955@freescale.com>
Date:   Wed Sep 25 14:58:19 2013 +0800

    mtd: add MTD_MLCNANDFLASH case for mtd_type_show()
    
    The current mtd_type_show() misses the MTD_MLCNANDFLASH case.
    This patch adds the case for it, and also updates the ABI.
    
    Signed-off-by: Huang Shijie <b32955@freescale.com>
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index 5e14d540ba2f..92311a56939f 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -157,6 +157,9 @@ static ssize_t mtd_type_show(struct device *dev,
 	case MTD_UBIVOLUME:
 		type = "ubi";
 		break;
+	case MTD_MLCNANDFLASH:
+		type = "mlc-nand";
+		break;
 	default:
 		type = "unknown";
 	}

commit bf977e3f158dc949fd6e1e4195f80d42232cb5fa
Author: Huang Shijie <b32955@freescale.com>
Date:   Fri Aug 16 10:10:05 2013 +0800

    mtd: add a new sys node to show the ecc step size
    
    Add a new sys node to show the ecc step size.
    The application then can uses this node to get the ecc step
    size.
    
    Signed-off-by: Huang Shijie <b32955@freescale.com>
    Signed-off-by: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index 048c823f5c51..5e14d540ba2f 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -285,6 +285,16 @@ static DEVICE_ATTR(bitflip_threshold, S_IRUGO | S_IWUSR,
 		   mtd_bitflip_threshold_show,
 		   mtd_bitflip_threshold_store);
 
+static ssize_t mtd_ecc_step_size_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct mtd_info *mtd = dev_get_drvdata(dev);
+
+	return snprintf(buf, PAGE_SIZE, "%u\n", mtd->ecc_step_size);
+
+}
+static DEVICE_ATTR(ecc_step_size, S_IRUGO, mtd_ecc_step_size_show, NULL);
+
 static struct attribute *mtd_attrs[] = {
 	&dev_attr_type.attr,
 	&dev_attr_flags.attr,
@@ -296,6 +306,7 @@ static struct attribute *mtd_attrs[] = {
 	&dev_attr_numeraseregions.attr,
 	&dev_attr_name.attr,
 	&dev_attr_ecc_strength.attr,
+	&dev_attr_ecc_step_size.attr,
 	&dev_attr_bitflip_threshold.attr,
 	NULL,
 };

commit 02aa2a37636c8fa4fb9322d91be46ff8225b7de0
Author: Kees Cook <keescook@chromium.org>
Date:   Wed Jul 3 15:04:56 2013 -0700

    drivers: avoid format string in dev_set_name
    
    Calling dev_set_name with a single paramter causes it to be handled as a
    format string.  Many callers are passing potentially dynamic string
    content, so use "%s" in those cases to avoid any potential accidents,
    including wrappers like device_create*() and bdi_register().
    
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index c400c57c394a..048c823f5c51 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -1151,7 +1151,7 @@ static int __init mtd_bdi_init(struct backing_dev_info *bdi, const char *name)
 
 	ret = bdi_init(bdi);
 	if (!ret)
-		ret = bdi_register(bdi, NULL, name);
+		ret = bdi_register(bdi, NULL, "%s", name);
 
 	if (ret)
 		bdi_destroy(bdi);

commit a637b0d45947df686979b85361ad5bfa9d19fdd3
Merge: f78089e87e57 cdb6404cc53a
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu May 9 10:15:46 2013 -0700

    Merge tag 'for-linus-20130509' of git://git.infradead.org/linux-mtd
    
    Pull MTD update from David Woodhouse:
    
     - Lots of cleanups from Artem, including deletion of some obsolete
       drivers
    
     - Support partitions larger than 4GiB in device tree
    
     - Support for new SPI chips
    
    * tag 'for-linus-20130509' of git://git.infradead.org/linux-mtd: (83 commits)
      mtd: omap2: Use module_platform_driver()
      mtd: bf5xx_nand: Use module_platform_driver()
      mtd: denali_dt: Remove redundant use of of_match_ptr
      mtd: denali_dt: Change return value to fix smatch warning
      mtd: denali_dt: Use module_platform_driver()
      mtd: denali_dt: Fix incorrect error check
      mtd: nand: subpage write support for hardware based ECC schemes
      mtd: omap2: use msecs_to_jiffies()
      mtd: nand_ids: use size macros
      mtd: nand_ids: improve LEGACY_ID_NAND macro a bit
      mtd: add 4 Toshiba nand chips for the full-id case
      mtd: add the support to parse out the full-id nand type
      mtd: add new fields to nand_flash_dev{}
      mtd: sh_flctl: Use of_match_ptr() macro
      mtd: gpio: Use of_match_ptr() macro
      mtd: gpio: Use devm_kzalloc()
      mtd: davinci_nand: Use of_match_ptr()
      mtd: dataflash: Use of_match_ptr() macro
      mtd: remove h720x flash support
      mtd: onenand: remove OneNAND simulator
      ...

commit 0d01ff2583086fd532181d2ee16112f5342eb78d
Author: David Howells <dhowells@redhat.com>
Date:   Thu Apr 11 23:51:01 2013 +0100

    Include missing linux/slab.h inclusions
    
    Include missing linux/slab.h inclusions where the source file is currently
    expecting to get kmalloc() and co. through linux/proc_fs.h.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    cc: linux-s390@vger.kernel.org
    cc: sparclinux@vger.kernel.org
    cc: linux-efi@vger.kernel.org
    cc: linux-mtd@lists.infradead.org
    cc: devel@driverdev.osuosl.org
    cc: x86@kernel.org
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index 61d5f56473e1..322ca65b0cc5 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -36,6 +36,7 @@
 #include <linux/idr.h>
 #include <linux/backing-dev.h>
 #include <linux/gfp.h>
+#include <linux/slab.h>
 
 #include <linux/mtd/mtd.h>
 #include <linux/mtd/partitions.h>

commit 660685d9d1b4730f0b5ca97fa95f272f99c63bce
Author: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
Date:   Thu Mar 14 13:27:40 2013 +0200

    mtd: merge mtdchar module with mtdcore
    
    The MTD subsystem has historically tried to be as configurable as possible. The
    side-effect of this is that its configuration menu is rather large, and we are
    gradually shrinking it. For example, we recently merged partitions support with
    the mtdcore.
    
    This patch does the next step - it merges the mtdchar module to mtdcore. And in
    this case this is not only about eliminating too fine-grained separation and
    simplifying the configuration menu. This is also about eliminating seemingly
    useless kernel module.
    
    Indeed, mtdchar is a module that allows user-space making use of MTD devices
    via /dev/mtd* character devices. If users do not enable it, they simply cannot
    use MTD devices at all. They cannot read or write the flash contents. Is it a
    sane and useful setup? I believe not. And everyone just enables mtdchar.
    
    Having mtdchar separate is also a little bit harmful. People sometimes miss the
    fact that they need to enable an additional configuration option to have
    user-space MTD interfaces, and then they wonder why on earth the kernel does
    not allow using the flash? They spend time asking around.
    
    Thus, let's just get rid of this module and make it part of mtd core.
    
    Note, mtdchar had additional configuration option to enable OTP interfaces,
    which are present on some flashes. I removed that option as well - it saves a
    really tiny amount space.
    
    [dwmw2: Strictly speaking, you can mount file systems on MTD devices just
            fine without the mtdchar (or mtdblock) devices; you just can't do
            other manipulations directly on the underlying device. But still I
            agree that it makes sense to make this unconditional. And Yay! we
            get to kill off an instance of checking CONFIG_foo_MODULE, which is
            an abomination that should never happen.]
    
    Signed-off-by: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index 91c2efd22e1f..71877ff77cbf 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -41,6 +41,7 @@
 #include <linux/mtd/partitions.h>
 
 #include "mtdcore.h"
+
 /*
  * backing device capabilities for non-mappable devices (such as NAND flash)
  * - permits private mappings, copies are taken of the data
@@ -96,11 +97,7 @@ EXPORT_SYMBOL_GPL(__mtd_next_device);
 static LIST_HEAD(mtd_notifiers);
 
 
-#if defined(CONFIG_MTD_CHAR) || defined(CONFIG_MTD_CHAR_MODULE)
 #define MTD_DEVT(index) MKDEV(MTD_CHAR_MAJOR, (index)*2)
-#else
-#define MTD_DEVT(index) 0
-#endif
 
 /* REVISIT once MTD uses the driver model better, whoever allocates
  * the mtd_info will probably want to use the release() hook...
@@ -1185,8 +1182,15 @@ static int __init init_mtd(void)
 
 	proc_mtd = proc_create("mtd", 0, NULL, &mtd_proc_ops);
 
+	ret = init_mtdchar();
+	if (ret)
+		goto out_procfs;
+
 	return 0;
 
+out_procfs:
+	if (proc_mtd)
+		remove_proc_entry("mtd", NULL);
 err_bdi3:
 	bdi_destroy(&mtd_bdi_ro_mappable);
 err_bdi2:
@@ -1200,6 +1204,7 @@ static int __init init_mtd(void)
 
 static void __exit cleanup_mtd(void)
 {
+	cleanup_mtdchar();
 	if (proc_mtd)
 		remove_proc_entry("mtd", NULL);
 	class_unregister(&mtd_class);

commit 93e562141ac58452bcea48718af92cc62a20669d
Author: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
Date:   Fri Mar 15 12:56:05 2013 +0200

    mtd: mtdcore: remove few useless #ifdef's
    
    Remove a couple of useles '#ifdef CONFIG_PROC_FS's around procfs functions
    which anyway turn into empty function in 'proc_fs.h' file when CONFIG_PROC_FS
    is not defined.
    
    Signed-off-by: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index 681bb6de6ff9..91c2efd22e1f 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -1116,8 +1116,6 @@ EXPORT_SYMBOL_GPL(mtd_kmalloc_up_to);
 /*====================================================================*/
 /* Support for /proc/mtd */
 
-static struct proc_dir_entry *proc_mtd;
-
 static int mtd_proc_show(struct seq_file *m, void *v)
 {
 	struct mtd_info *mtd;
@@ -1163,6 +1161,8 @@ static int __init mtd_bdi_init(struct backing_dev_info *bdi, const char *name)
 	return ret;
 }
 
+static struct proc_dir_entry *proc_mtd;
+
 static int __init init_mtd(void)
 {
 	int ret;
@@ -1183,9 +1183,8 @@ static int __init init_mtd(void)
 	if (ret)
 		goto err_bdi3;
 
-#ifdef CONFIG_PROC_FS
 	proc_mtd = proc_create("mtd", 0, NULL, &mtd_proc_ops);
-#endif /* CONFIG_PROC_FS */
+
 	return 0;
 
 err_bdi3:
@@ -1201,10 +1200,8 @@ static int __init init_mtd(void)
 
 static void __exit cleanup_mtd(void)
 {
-#ifdef CONFIG_PROC_FS
 	if (proc_mtd)
-		remove_proc_entry( "mtd", NULL);
-#endif /* CONFIG_PROC_FS */
+		remove_proc_entry("mtd", NULL);
 	class_unregister(&mtd_class);
 	bdi_destroy(&mtd_bdi_unmappable);
 	bdi_destroy(&mtd_bdi_ro_mappable);

commit 26a4734623e4f06752014336b05cf3ae77158892
Author: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
Date:   Mon Mar 11 15:38:48 2013 +0200

    mtd: add 'const' qualifier to a couple of register functions
    
    'mtd_device_parse_register()' and 'parse_mtd_partitions()' functions accept a
    an array of character pointers. These functions modify neither the pointers nor
    the characters they point to. The characters are actually names of the MTD
    parsers.
    
    At the moment, the argument type is 'const char **', which means that only the
    names of the parsers are constant. Let's turn the argument type into 'const
    char * const *', which means that both names and the pointers which point to
    them are constant.
    
    Signed-off-by: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index 61d5f56473e1..681bb6de6ff9 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -492,7 +492,7 @@ int del_mtd_device(struct mtd_info *mtd)
  *
  * Returns zero in case of success and a negative error code in case of failure.
  */
-int mtd_device_parse_register(struct mtd_info *mtd, const char **types,
+int mtd_device_parse_register(struct mtd_info *mtd, const char * const *types,
 			      struct mtd_part_parser_data *parser_data,
 			      const struct mtd_partition *parts,
 			      int nr_parts)

commit 589e9c4dace6995440c119486919ce95b180dd38
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Feb 27 17:04:33 2013 -0800

    mtd: convert to idr_alloc()
    
    Convert to the much saner new idr interface.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Tested-by: Ezequiel Garcia <ezequiel.garcia@free-electrons.com>
    Cc: David Woodhouse <dwmw2@infradead.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index ec794a72975d..61d5f56473e1 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -349,13 +349,8 @@ int add_mtd_device(struct mtd_info *mtd)
 	BUG_ON(mtd->writesize == 0);
 	mutex_lock(&mtd_table_mutex);
 
-	do {
-		if (!idr_pre_get(&mtd_idr, GFP_KERNEL))
-			goto fail_locked;
-		error = idr_get_new(&mtd_idr, mtd, &i);
-	} while (error == -EAGAIN);
-
-	if (error)
+	i = idr_alloc(&mtd_idr, mtd, 0, 0, GFP_KERNEL);
+	if (i < 0)
 		goto fail_locked;
 
 	mtd->index = i;

commit caf491916b1c1e939a2c7575efb7a77f11fc9bdf
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Dec 10 10:51:16 2012 -0800

    Revert "revert "Revert "mm: remove __GFP_NO_KSWAPD""" and associated damage
    
    This reverts commits a50915394f1fc02c2861d3b7ce7014788aa5066e and
    d7c3b937bdf45f0b844400b7bf6fd3ed50bac604.
    
    This is a revert of a revert of a revert.  In addition, it reverts the
    even older i915 change to stop using the __GFP_NO_KSWAPD flag due to the
    original commits in linux-next.
    
    It turns out that the original patch really was bogus, and that the
    original revert was the correct thing to do after all.  We thought we
    had fixed the problem, and then reverted the revert, but the problem
    really is fundamental: waking up kswapd simply isn't the right thing to
    do, and direct reclaim sometimes simply _is_ the right thing to do.
    
    When certain allocations fail, we simply should try some direct reclaim,
    and if that fails, fail the allocation.  That's the right thing to do
    for THP allocations, which can easily fail, and the GPU allocations want
    to do that too.
    
    So starting kswapd is sometimes simply wrong, and removing the flag that
    said "don't start kswapd" was a mistake.  Let's hope we never revisit
    this mistake again - and certainly not this many times ;)
    
    Acked-by: Mel Gorman <mgorman@suse.de>
    Acked-by: Johannes Weiner <hannes@cmpxchg.org>
    Cc: Rik van Riel <riel@redhat.com>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index 374c46dff7dd..ec794a72975d 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -1077,7 +1077,8 @@ EXPORT_SYMBOL_GPL(mtd_writev);
  * until the request succeeds or until the allocation size falls below
  * the system page size. This attempts to make sure it does not adversely
  * impact system performance, so when allocating more than one page, we
- * ask the memory allocator to avoid re-trying.
+ * ask the memory allocator to avoid re-trying, swapping, writing back
+ * or performing I/O.
  *
  * Note, this function also makes sure that the allocated buffer is aligned to
  * the MTD device's min. I/O unit, i.e. the "mtd->writesize" value.
@@ -1091,7 +1092,8 @@ EXPORT_SYMBOL_GPL(mtd_writev);
  */
 void *mtd_kmalloc_up_to(const struct mtd_info *mtd, size_t *size)
 {
-	gfp_t flags = __GFP_NOWARN | __GFP_WAIT | __GFP_NORETRY;
+	gfp_t flags = __GFP_NOWARN | __GFP_WAIT |
+		       __GFP_NORETRY | __GFP_NO_KSWAPD;
 	size_t min_alloc = max_t(size_t, mtd->writesize, PAGE_SIZE);
 	void *kbuf;
 

commit a50915394f1fc02c2861d3b7ce7014788aa5066e
Author: Andrew Morton <akpm@linux-foundation.org>
Date:   Thu Nov 29 13:54:27 2012 -0800

    revert "Revert "mm: remove __GFP_NO_KSWAPD""
    
    It apepars that this patch was innocent, and we hope that "mm: avoid
    waking kswapd for THP allocations when compaction is deferred or
    contended" will fix the final kswapd-spinning cause.
    
    Cc: Zdenek Kabelac <zkabelac@redhat.com>
    Cc: Seth Jennings <sjenning@linux.vnet.ibm.com>
    Cc: Valdis Kletnieks <Valdis.Kletnieks@vt.edu>
    Cc: Jiri Slaby <jirislaby@gmail.com>
    Cc: Rik van Riel <riel@redhat.com>
    Cc: Robert Jennings <rcj@linux.vnet.ibm.com>
    Cc: Mel Gorman <mgorman@suse.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index ec794a72975d..374c46dff7dd 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -1077,8 +1077,7 @@ EXPORT_SYMBOL_GPL(mtd_writev);
  * until the request succeeds or until the allocation size falls below
  * the system page size. This attempts to make sure it does not adversely
  * impact system performance, so when allocating more than one page, we
- * ask the memory allocator to avoid re-trying, swapping, writing back
- * or performing I/O.
+ * ask the memory allocator to avoid re-trying.
  *
  * Note, this function also makes sure that the allocated buffer is aligned to
  * the MTD device's min. I/O unit, i.e. the "mtd->writesize" value.
@@ -1092,8 +1091,7 @@ EXPORT_SYMBOL_GPL(mtd_writev);
  */
 void *mtd_kmalloc_up_to(const struct mtd_info *mtd, size_t *size)
 {
-	gfp_t flags = __GFP_NOWARN | __GFP_WAIT |
-		       __GFP_NORETRY | __GFP_NO_KSWAPD;
+	gfp_t flags = __GFP_NOWARN | __GFP_WAIT | __GFP_NORETRY;
 	size_t min_alloc = max_t(size_t, mtd->writesize, PAGE_SIZE);
 	void *kbuf;
 

commit 82b212f40059bffd6808c07266a942d444d5558a
Author: Mel Gorman <mgorman@suse.de>
Date:   Mon Nov 26 16:29:45 2012 -0800

    Revert "mm: remove __GFP_NO_KSWAPD"
    
    With "mm: vmscan: scale number of pages reclaimed by reclaim/compaction
    based on failures" reverted, Zdenek Kabelac reported the following
    
      Hmm,  so it's just took longer to hit the problem and observe
      kswapd0 spinning on my CPU again - it's not as endless like before -
      but still it easily eats minutes - it helps to        turn off  Firefox
      or TB  (memory hungry apps) so kswapd0 stops soon - and restart
      those apps again.  (And I still have like >1GB of cached memory)
    
      kswapd0         R  running task        0    30      2 0x00000000
      Call Trace:
        preempt_schedule+0x42/0x60
        _raw_spin_unlock+0x55/0x60
        put_super+0x31/0x40
        drop_super+0x22/0x30
        prune_super+0x149/0x1b0
        shrink_slab+0xba/0x510
    
    The sysrq+m indicates the system has no swap so it'll never reclaim
    anonymous pages as part of reclaim/compaction.  That is one part of the
    problem but not the root cause as file-backed pages could also be
    reclaimed.
    
    The likely underlying problem is that kswapd is woken up or kept awake
    for each THP allocation request in the page allocator slow path.
    
    If compaction fails for the requesting process then compaction will be
    deferred for a time and direct reclaim is avoided.  However, if there
    are a storm of THP requests that are simply rejected, it will still be
    the the case that kswapd is awake for a prolonged period of time as
    pgdat->kswapd_max_order is updated each time.  This is noticed by the
    main kswapd() loop and it will not call kswapd_try_to_sleep().  Instead
    it will loopp, shrinking a small number of pages and calling
    shrink_slab() on each iteration.
    
    The temptation is to supply a patch that checks if kswapd was woken for
    THP and if so ignore pgdat->kswapd_max_order but it'll be a hack and not
    backed up by proper testing.  As 3.7 is very close to release and this
    is not a bug we should release with, a safer path is to revert "mm:
    remove __GFP_NO_KSWAPD" for now and revisit it with the view to ironing
    out the balance_pgdat() logic in general.
    
    Signed-off-by: Mel Gorman <mgorman@suse.de>
    Cc: Zdenek Kabelac <zkabelac@redhat.com>
    Cc: Seth Jennings <sjenning@linux.vnet.ibm.com>
    Cc: Valdis Kletnieks <Valdis.Kletnieks@vt.edu>
    Cc: Jiri Slaby <jirislaby@gmail.com>
    Cc: Rik van Riel <riel@redhat.com>
    Cc: Robert Jennings <rcj@linux.vnet.ibm.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index 374c46dff7dd..ec794a72975d 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -1077,7 +1077,8 @@ EXPORT_SYMBOL_GPL(mtd_writev);
  * until the request succeeds or until the allocation size falls below
  * the system page size. This attempts to make sure it does not adversely
  * impact system performance, so when allocating more than one page, we
- * ask the memory allocator to avoid re-trying.
+ * ask the memory allocator to avoid re-trying, swapping, writing back
+ * or performing I/O.
  *
  * Note, this function also makes sure that the allocated buffer is aligned to
  * the MTD device's min. I/O unit, i.e. the "mtd->writesize" value.
@@ -1091,7 +1092,8 @@ EXPORT_SYMBOL_GPL(mtd_writev);
  */
 void *mtd_kmalloc_up_to(const struct mtd_info *mtd, size_t *size)
 {
-	gfp_t flags = __GFP_NOWARN | __GFP_WAIT | __GFP_NORETRY;
+	gfp_t flags = __GFP_NOWARN | __GFP_WAIT |
+		       __GFP_NORETRY | __GFP_NO_KSWAPD;
 	size_t min_alloc = max_t(size_t, mtd->writesize, PAGE_SIZE);
 	void *kbuf;
 

commit ffe315012510165ce82e4dd4767f0a5dba9edbf7
Merge: e2d3a35ee427 4a8e43feeac7
Author: David Woodhouse <David.Woodhouse@intel.com>
Date:   Tue Oct 9 15:03:21 2012 +0100

    Merge tag 'disintegrate-mtd-20121009' of git://git.infradead.org/users/dhowells/linux-headers
    
    UAPI Disintegration 2012-10-09
    
    Conflicts:
            MAINTAINERS
            arch/arm/configs/bcmring_defconfig
            arch/arm/mach-imx/clk-imx51-imx53.c
            drivers/mtd/nand/Kconfig
            drivers/mtd/nand/bcm_umi_nand.c
            drivers/mtd/nand/nand_bcm_umi.h
            drivers/mtd/nand/orion_nand.c

commit c654345924f7cce87bb221b89db91cba890421ba
Author: Rik van Riel <riel@redhat.com>
Date:   Mon Oct 8 16:28:21 2012 -0700

    mm: remove __GFP_NO_KSWAPD
    
    When transparent huge pages were introduced, memory compaction and swap
    storms were an issue, and the kernel had to be careful to not make THP
    allocations cause pageout or compaction.
    
    Now that we have working compaction deferral, kswapd is smart enough to
    invoke compaction and the quadratic behaviour around isolate_free_pages
    has been fixed, it should be safe to remove __GFP_NO_KSWAPD.
    
    [minchan@kernel.org: Comment fix]
    [mgorman@suse.de: Avoid direct reclaim for deferred compaction]
    Cc: Andrea Arcangeli <aarcange@redhat.com>
    Signed-off-by: Rik van Riel <riel@redhat.com>
    Signed-off-by: Mel Gorman <mgorman@suse.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index 575730744fdb..b9adff543f5f 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -1056,8 +1056,7 @@ EXPORT_SYMBOL_GPL(mtd_writev);
  * until the request succeeds or until the allocation size falls below
  * the system page size. This attempts to make sure it does not adversely
  * impact system performance, so when allocating more than one page, we
- * ask the memory allocator to avoid re-trying, swapping, writing back
- * or performing I/O.
+ * ask the memory allocator to avoid re-trying.
  *
  * Note, this function also makes sure that the allocated buffer is aligned to
  * the MTD device's min. I/O unit, i.e. the "mtd->writesize" value.
@@ -1071,8 +1070,7 @@ EXPORT_SYMBOL_GPL(mtd_writev);
  */
 void *mtd_kmalloc_up_to(const struct mtd_info *mtd, size_t *size)
 {
-	gfp_t flags = __GFP_NOWARN | __GFP_WAIT |
-		       __GFP_NORETRY | __GFP_NO_KSWAPD;
+	gfp_t flags = __GFP_NOWARN | __GFP_WAIT | __GFP_NORETRY;
 	size_t min_alloc = max_t(size_t, mtd->writesize, PAGE_SIZE);
 	void *kbuf;
 

commit e47f68587b8255410e79166cbdecae290ca8a84e
Author: Brian Norris <computersforpeace@gmail.com>
Date:   Fri Jun 22 16:35:39 2012 -0700

    mtd: check for max_bitflips in mtd_read_oob()
    
    mtd_read_oob() has some unexpected similarities to mtd_read(). For
    instance, when ops->datbuf != NULL, nand_base.c might return max_bitflips;
    however, when ops->datbuf == NULL, nand_base's code potentially could
    return -EUCLEAN (no in-tree drivers do this yet). In any case where the
    driver might return max_bitflips, we should translate this into an
    appropriate return code using the bitflip_threshold.
    
    Essentially, mtd_read_oob() duplicates the logic from mtd_read().
    
    This prevents users of mtd_read_oob() from receiving a positive return
    value (i.e., from max_bitflips) and interpreting it as an unknown error.
    
    Artem: amend comments.
    
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>
    Reviewed-by: Mike Dunn <mikedunn@newsguy.com>
    Reviewed-by: Shmulik Ladkani <shmulik.ladkani@gmail.com>
    Signed-off-by: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index fcfce24f87d1..ec794a72975d 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -860,10 +860,22 @@ EXPORT_SYMBOL_GPL(mtd_panic_write);
 
 int mtd_read_oob(struct mtd_info *mtd, loff_t from, struct mtd_oob_ops *ops)
 {
+	int ret_code;
 	ops->retlen = ops->oobretlen = 0;
 	if (!mtd->_read_oob)
 		return -EOPNOTSUPP;
-	return mtd->_read_oob(mtd, from, ops);
+	/*
+	 * In cases where ops->datbuf != NULL, mtd->_read_oob() has semantics
+	 * similar to mtd->_read(), returning a non-negative integer
+	 * representing max bitflips. In other cases, mtd->_read_oob() may
+	 * return -EUCLEAN. In all cases, perform similar logic to mtd_read().
+	 */
+	ret_code = mtd->_read_oob(mtd, from, ops);
+	if (unlikely(ret_code < 0))
+		return ret_code;
+	if (mtd->ecc_strength == 0)
+		return 0;	/* device lacks ecc */
+	return ret_code >= mtd->bitflip_threshold ? -EUCLEAN : 0;
 }
 EXPORT_SYMBOL_GPL(mtd_read_oob);
 

commit d2d48480d16ab349ae5d4732b4d79ff48b4b4171
Author: Brian Norris <computersforpeace@gmail.com>
Date:   Fri Jun 22 16:35:38 2012 -0700

    mtd: move mtd_read_oob() definition out of mtd.h
    
    mtd_read_oob() will be expanded a little, so don't leave it in the header
    as a static inline function.
    
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>
    Signed-off-by: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index 575730744fdb..fcfce24f87d1 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -858,6 +858,15 @@ int mtd_panic_write(struct mtd_info *mtd, loff_t to, size_t len, size_t *retlen,
 }
 EXPORT_SYMBOL_GPL(mtd_panic_write);
 
+int mtd_read_oob(struct mtd_info *mtd, loff_t from, struct mtd_oob_ops *ops)
+{
+	ops->retlen = ops->oobretlen = 0;
+	if (!mtd->_read_oob)
+		return -EOPNOTSUPP;
+	return mtd->_read_oob(mtd, from, ops);
+}
+EXPORT_SYMBOL_GPL(mtd_read_oob);
+
 /*
  * Method to access the protection register area, present in some flash
  * devices. The user data is one time programmable but the factory data is read

commit edbc4540e02c201bdd4f4d498ebb6ed517fd36e2
Author: Mike Dunn <mikedunn@newsguy.com>
Date:   Wed Apr 25 12:06:11 2012 -0700

    mtd: driver _read() returns max_bitflips; mtd_read() returns -EUCLEAN
    
    The drivers' _read() method, absent an error, returns a non-negative integer
    indicating the maximum number of bit errors that were corrected in any one
    region comprising an ecc step.  MTD returns -EUCLEAN if this is >=
    bitflip_threshold, 0 otherwise.  If bitflip_threshold is zero, the comparison is
    not made since these devices lack ECC and always return zero in the non-error
    case (thanks Brian)¹.  Note that this is a subtle change to the driver
    interface.
    
    This and the preceding patches in this set were tested with ubi on top of the
    nandsim and docg4 devices, running the ubi test io_basic from mtd-utils.
    
    ¹ http://lists.infradead.org/pipermail/linux-mtd/2012-March/040468.html
    
    Signed-off-by: Mike Dunn <mikedunn@newsguy.com>
    Acked-by: Robert Jarzmik <robert.jarzmik@free.fr>
    Acked-by: Brian Norris <computersforpeace@gmail.com>
    Ivan Djelic <ivan.djelic@parrot.com>
    Signed-off-by: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
    
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index 6a7cba1e24e6..575730744fdb 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -800,12 +800,24 @@ EXPORT_SYMBOL_GPL(mtd_get_unmapped_area);
 int mtd_read(struct mtd_info *mtd, loff_t from, size_t len, size_t *retlen,
 	     u_char *buf)
 {
+	int ret_code;
 	*retlen = 0;
 	if (from < 0 || from > mtd->size || len > mtd->size - from)
 		return -EINVAL;
 	if (!len)
 		return 0;
-	return mtd->_read(mtd, from, len, retlen, buf);
+
+	/*
+	 * In the absence of an error, drivers return a non-negative integer
+	 * representing the maximum number of bitflips that were corrected on
+	 * any one ecc region (if applicable; zero otherwise).
+	 */
+	ret_code = mtd->_read(mtd, from, len, retlen, buf);
+	if (unlikely(ret_code < 0))
+		return ret_code;
+	if (mtd->ecc_strength == 0)
+		return 0;	/* device lacks ecc */
+	return ret_code >= mtd->bitflip_threshold ? -EUCLEAN : 0;
 }
 EXPORT_SYMBOL_GPL(mtd_read);
 

commit d062d4ede877fcd2ecc4c6262abad09a6f32950a
Author: Mike Dunn <mikedunn@newsguy.com>
Date:   Wed Apr 25 12:06:08 2012 -0700

    mtd: bitflip_threshold added to mtd_info and sysfs
    
    An element 'bitflip_threshold' is added to struct mtd_info, and also exposed as
    a read/write variable in sysfs.  This will be used to determine whether or not
    mtd_read() returns -EUCLEAN or 0 (absent a hard error).  If the driver leaves it
    as zero, mtd will set it to a default value of ecc_strength.
    
    This v2 adds the line that propagates bitflip_threshold from the master to the
    partitions - thanks Ivan¹.
    
    ¹ http://lists.infradead.org/pipermail/linux-mtd/2012-April/040900.html
    
    Signed-off-by: Mike Dunn <mikedunn@newsguy.com>
    Signed-off-by: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index 090e849d3dcd..6a7cba1e24e6 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -259,6 +259,34 @@ static ssize_t mtd_ecc_strength_show(struct device *dev,
 }
 static DEVICE_ATTR(ecc_strength, S_IRUGO, mtd_ecc_strength_show, NULL);
 
+static ssize_t mtd_bitflip_threshold_show(struct device *dev,
+					  struct device_attribute *attr,
+					  char *buf)
+{
+	struct mtd_info *mtd = dev_get_drvdata(dev);
+
+	return snprintf(buf, PAGE_SIZE, "%u\n", mtd->bitflip_threshold);
+}
+
+static ssize_t mtd_bitflip_threshold_store(struct device *dev,
+					   struct device_attribute *attr,
+					   const char *buf, size_t count)
+{
+	struct mtd_info *mtd = dev_get_drvdata(dev);
+	unsigned int bitflip_threshold;
+	int retval;
+
+	retval = kstrtouint(buf, 0, &bitflip_threshold);
+	if (retval)
+		return retval;
+
+	mtd->bitflip_threshold = bitflip_threshold;
+	return count;
+}
+static DEVICE_ATTR(bitflip_threshold, S_IRUGO | S_IWUSR,
+		   mtd_bitflip_threshold_show,
+		   mtd_bitflip_threshold_store);
+
 static struct attribute *mtd_attrs[] = {
 	&dev_attr_type.attr,
 	&dev_attr_flags.attr,
@@ -270,6 +298,7 @@ static struct attribute *mtd_attrs[] = {
 	&dev_attr_numeraseregions.attr,
 	&dev_attr_name.attr,
 	&dev_attr_ecc_strength.attr,
+	&dev_attr_bitflip_threshold.attr,
 	NULL,
 };
 
@@ -332,6 +361,10 @@ int add_mtd_device(struct mtd_info *mtd)
 	mtd->index = i;
 	mtd->usecount = 0;
 
+	/* default value if not set by driver */
+	if (mtd->bitflip_threshold == 0)
+		mtd->bitflip_threshold = mtd->ecc_strength;
+
 	if (is_power_of_2(mtd->erasesize))
 		mtd->erasesize_shift = ffs(mtd->erasesize) - 1;
 	else

commit a9b672e82bca47bf2b37ee869b8095000cf3ca88
Author: Mike Dunn <mikedunn@newsguy.com>
Date:   Wed Apr 25 12:06:07 2012 -0700

    mtd: expose ecc_strength through sysfs
    
    ecc_strength element of struct mtd_info is exposed as a read-only variable in
    sysfs.
    
    Signed-off-by: Mike Dunn <mikedunn@newsguy.com>
    Signed-off-by: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index c837507dfb1c..090e849d3dcd 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -250,6 +250,15 @@ static ssize_t mtd_name_show(struct device *dev,
 }
 static DEVICE_ATTR(name, S_IRUGO, mtd_name_show, NULL);
 
+static ssize_t mtd_ecc_strength_show(struct device *dev,
+				     struct device_attribute *attr, char *buf)
+{
+	struct mtd_info *mtd = dev_get_drvdata(dev);
+
+	return snprintf(buf, PAGE_SIZE, "%u\n", mtd->ecc_strength);
+}
+static DEVICE_ATTR(ecc_strength, S_IRUGO, mtd_ecc_strength_show, NULL);
+
 static struct attribute *mtd_attrs[] = {
 	&dev_attr_type.attr,
 	&dev_attr_flags.attr,
@@ -260,6 +269,7 @@ static struct attribute *mtd_attrs[] = {
 	&dev_attr_oobsize.attr,
 	&dev_attr_numeraseregions.attr,
 	&dev_attr_name.attr,
+	&dev_attr_ecc_strength.attr,
 	NULL,
 };
 

commit 3b27dac03972c10980ec5480ad8425fc95aae9ad
Author: Shmulik Ladkani <shmulik.ladkani@gmail.com>
Date:   Thu Feb 9 15:36:29 2012 +0200

    mtd: unify initialization of erase_info->fail_addr
    
    Initialization of 'erase_info->fail_addr' to MTD_FAIL_ADDR_UNKNOWN prior
    erase operation is duplicated accross several MTD drivers, and also taken
    care of by some MTD users as well.
    
    Harmonize it: initialize 'fail_addr' within 'mtd_erase()' interface.
    
    Signed-off-by: Shmulik Ladkani <shmulik.ladkani@gmail.com>
    Signed-off-by: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index b274fdf5f358..c837507dfb1c 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -695,6 +695,7 @@ int mtd_erase(struct mtd_info *mtd, struct erase_info *instr)
 		return -EINVAL;
 	if (!(mtd->flags & MTD_WRITEABLE))
 		return -EROFS;
+	instr->fail_addr = MTD_FAIL_ADDR_UNKNOWN;
 	if (!instr->len) {
 		instr->state = MTD_ERASE_DONE;
 		mtd_erase_callback(instr);

commit de3cac9357b5aa9f9f02520e5f2567b06f3f75a7
Author: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
Date:   Wed Feb 8 16:37:14 2012 +0200

    mtd: check for zero length in OTP functions
    
    This patch changes all the OTP functions like 'mtd_get_fact_prot_info()' and
    makes them return zero immediately if the input 'len' parameter is 0. This is
    not really needed currently, but most of the other functions do this, and it is
    just consistent to do the same in the OTP functions.
    
    This patch also moves the OTP functions from the header file to mtdcore.c
    because they become a bit too big for being inlined.
    
    Signed-off-by: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index 6acc4fb254e2..b274fdf5f358 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -802,6 +802,79 @@ int mtd_panic_write(struct mtd_info *mtd, loff_t to, size_t len, size_t *retlen,
 }
 EXPORT_SYMBOL_GPL(mtd_panic_write);
 
+/*
+ * Method to access the protection register area, present in some flash
+ * devices. The user data is one time programmable but the factory data is read
+ * only.
+ */
+int mtd_get_fact_prot_info(struct mtd_info *mtd, struct otp_info *buf,
+			   size_t len)
+{
+	if (!mtd->_get_fact_prot_info)
+		return -EOPNOTSUPP;
+	if (!len)
+		return 0;
+	return mtd->_get_fact_prot_info(mtd, buf, len);
+}
+EXPORT_SYMBOL_GPL(mtd_get_fact_prot_info);
+
+int mtd_read_fact_prot_reg(struct mtd_info *mtd, loff_t from, size_t len,
+			   size_t *retlen, u_char *buf)
+{
+	*retlen = 0;
+	if (!mtd->_read_fact_prot_reg)
+		return -EOPNOTSUPP;
+	if (!len)
+		return 0;
+	return mtd->_read_fact_prot_reg(mtd, from, len, retlen, buf);
+}
+EXPORT_SYMBOL_GPL(mtd_read_fact_prot_reg);
+
+int mtd_get_user_prot_info(struct mtd_info *mtd, struct otp_info *buf,
+			   size_t len)
+{
+	if (!mtd->_get_user_prot_info)
+		return -EOPNOTSUPP;
+	if (!len)
+		return 0;
+	return mtd->_get_user_prot_info(mtd, buf, len);
+}
+EXPORT_SYMBOL_GPL(mtd_get_user_prot_info);
+
+int mtd_read_user_prot_reg(struct mtd_info *mtd, loff_t from, size_t len,
+			   size_t *retlen, u_char *buf)
+{
+	*retlen = 0;
+	if (!mtd->_read_user_prot_reg)
+		return -EOPNOTSUPP;
+	if (!len)
+		return 0;
+	return mtd->_read_user_prot_reg(mtd, from, len, retlen, buf);
+}
+EXPORT_SYMBOL_GPL(mtd_read_user_prot_reg);
+
+int mtd_write_user_prot_reg(struct mtd_info *mtd, loff_t to, size_t len,
+			    size_t *retlen, u_char *buf)
+{
+	*retlen = 0;
+	if (!mtd->_write_user_prot_reg)
+		return -EOPNOTSUPP;
+	if (!len)
+		return 0;
+	return mtd->_write_user_prot_reg(mtd, to, len, retlen, buf);
+}
+EXPORT_SYMBOL_GPL(mtd_write_user_prot_reg);
+
+int mtd_lock_user_prot_reg(struct mtd_info *mtd, loff_t from, size_t len)
+{
+	if (!mtd->_lock_user_prot_reg)
+		return -EOPNOTSUPP;
+	if (!len)
+		return 0;
+	return mtd->_lock_user_prot_reg(mtd, from, len);
+}
+EXPORT_SYMBOL_GPL(mtd_lock_user_prot_reg);
+
 /* Chip-supported device locking */
 int mtd_lock(struct mtd_info *mtd, loff_t ofs, uint64_t len)
 {

commit bcb1d238716d138c9e16347fc32b3c1ae006339e
Author: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
Date:   Mon Feb 6 13:27:43 2012 +0200

    mtd: move zero length verification to MTD API functions
    
    In many places in drivers we verify for the zero length, but this is very
    inconsistent across drivers. This is obviously the right thing to do, though.
    This patch moves the check to the MTD API functions instead and removes a lot
    of duplication.
    
    Signed-off-by: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
    Reviewed-by: Shmulik Ladkani <shmulik.ladkani@gmail.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index b20346e9fecb..6acc4fb254e2 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -695,6 +695,11 @@ int mtd_erase(struct mtd_info *mtd, struct erase_info *instr)
 		return -EINVAL;
 	if (!(mtd->flags & MTD_WRITEABLE))
 		return -EROFS;
+	if (!instr->len) {
+		instr->state = MTD_ERASE_DONE;
+		mtd_erase_callback(instr);
+		return 0;
+	}
 	return mtd->_erase(mtd, instr);
 }
 EXPORT_SYMBOL_GPL(mtd_erase);
@@ -713,6 +718,8 @@ int mtd_point(struct mtd_info *mtd, loff_t from, size_t len, size_t *retlen,
 		return -EOPNOTSUPP;
 	if (from < 0 || from > mtd->size || len > mtd->size - from)
 		return -EINVAL;
+	if (!len)
+		return 0;
 	return mtd->_point(mtd, from, len, retlen, virt, phys);
 }
 EXPORT_SYMBOL_GPL(mtd_point);
@@ -724,6 +731,8 @@ int mtd_unpoint(struct mtd_info *mtd, loff_t from, size_t len)
 		return -EOPNOTSUPP;
 	if (from < 0 || from > mtd->size || len > mtd->size - from)
 		return -EINVAL;
+	if (!len)
+		return 0;
 	return mtd->_unpoint(mtd, from, len);
 }
 EXPORT_SYMBOL_GPL(mtd_unpoint);
@@ -750,6 +759,8 @@ int mtd_read(struct mtd_info *mtd, loff_t from, size_t len, size_t *retlen,
 	*retlen = 0;
 	if (from < 0 || from > mtd->size || len > mtd->size - from)
 		return -EINVAL;
+	if (!len)
+		return 0;
 	return mtd->_read(mtd, from, len, retlen, buf);
 }
 EXPORT_SYMBOL_GPL(mtd_read);
@@ -762,6 +773,8 @@ int mtd_write(struct mtd_info *mtd, loff_t to, size_t len, size_t *retlen,
 		return -EINVAL;
 	if (!mtd->_write || !(mtd->flags & MTD_WRITEABLE))
 		return -EROFS;
+	if (!len)
+		return 0;
 	return mtd->_write(mtd, to, len, retlen, buf);
 }
 EXPORT_SYMBOL_GPL(mtd_write);
@@ -783,6 +796,8 @@ int mtd_panic_write(struct mtd_info *mtd, loff_t to, size_t len, size_t *retlen,
 		return -EINVAL;
 	if (!(mtd->flags & MTD_WRITEABLE))
 		return -EROFS;
+	if (!len)
+		return 0;
 	return mtd->_panic_write(mtd, to, len, retlen, buf);
 }
 EXPORT_SYMBOL_GPL(mtd_panic_write);
@@ -794,6 +809,8 @@ int mtd_lock(struct mtd_info *mtd, loff_t ofs, uint64_t len)
 		return -EOPNOTSUPP;
 	if (ofs < 0 || ofs > mtd->size || len > mtd->size - ofs)
 		return -EINVAL;
+	if (!len)
+		return 0;
 	return mtd->_lock(mtd, ofs, len);
 }
 EXPORT_SYMBOL_GPL(mtd_lock);
@@ -804,6 +821,8 @@ int mtd_unlock(struct mtd_info *mtd, loff_t ofs, uint64_t len)
 		return -EOPNOTSUPP;
 	if (ofs < 0 || ofs > mtd->size || len > mtd->size - ofs)
 		return -EINVAL;
+	if (!len)
+		return 0;
 	return mtd->_unlock(mtd, ofs, len);
 }
 EXPORT_SYMBOL_GPL(mtd_unlock);
@@ -814,6 +833,8 @@ int mtd_is_locked(struct mtd_info *mtd, loff_t ofs, uint64_t len)
 		return -EOPNOTSUPP;
 	if (ofs < 0 || ofs > mtd->size || len > mtd->size - ofs)
 		return -EINVAL;
+	if (!len)
+		return 0;
 	return mtd->_is_locked(mtd, ofs, len);
 }
 EXPORT_SYMBOL_GPL(mtd_is_locked);

commit 0dd5235f51fb0eb0b8cef3fed35be39b8a06d7bd
Author: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
Date:   Wed Feb 8 15:13:26 2012 +0200

    mtd: harmonize mtd_point interface implementation
    
    Some MTD drivers return -EINVAL if the 'phys' parameter is not NULL, trying to
    convey that they cannot return the physical address. However, this is not very
    logical because they still can return the virtual address ('virt'). But some
    drivers (lpddr) just ignore the 'phys' parameter instead, which is a more
    logical thing to do.
    
    Let's harmonize this and:
    
    1. Always initialize 'virt' and 'phys' to 'NULL' in 'mtd_point()'.
    2. Do not return an error if the physical address cannot be found.
    
    So as a result, all drivers will set 'phys' to 'NULL' if it is not supported.
    None of the 'mtd_point()' users use 'phys' anyway, so this should not break
    anything. I guess we could also just delete this parameter later.
    
    Signed-off-by: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index ead52b388492..b20346e9fecb 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -706,6 +706,9 @@ int mtd_point(struct mtd_info *mtd, loff_t from, size_t len, size_t *retlen,
 	      void **virt, resource_size_t *phys)
 {
 	*retlen = 0;
+	*virt = NULL;
+	if (phys)
+		*phys = 0;
 	if (!mtd->_point)
 		return -EOPNOTSUPP;
 	if (from < 0 || from > mtd->size || len > mtd->size - from)

commit 834247ec7e281dee839fe4a04bc1bbf0c7395172
Author: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
Date:   Mon Feb 6 12:39:07 2012 +0200

    mtd: remove retlen zeroing duplication
    
    The MTD API function now zero the 'retlen' parameter before calling
    the driver's method — do not do this again in drivers. This removes
    duplicated '*retlen = 0' assignent from the following methods:
    
        'mtd_point()'
        'mtd_read()'
        'mtd_write()'
        'mtd_writev()'
        'mtd_panic_write()'
    
    Signed-off-by: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index b9b28647adef..ead52b388492 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -744,6 +744,7 @@ EXPORT_SYMBOL_GPL(mtd_get_unmapped_area);
 int mtd_read(struct mtd_info *mtd, loff_t from, size_t len, size_t *retlen,
 	     u_char *buf)
 {
+	*retlen = 0;
 	if (from < 0 || from > mtd->size || len > mtd->size - from)
 		return -EINVAL;
 	return mtd->_read(mtd, from, len, retlen, buf);

commit 664addc248d2fed68d013d26ff2fc796d7134259
Author: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
Date:   Fri Feb 3 18:13:23 2012 +0200

    mtd: remove R/O checking duplication
    
    Many drivers check whether the partition is R/O and return -EROFS if yes.
    Let's stop having duplicated checks and move them to the API functions
    instead.
    
    And again a bit of noise - deleted few too sparse newlines, sorry.
    
    Signed-off-by: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index 8d5e103695f9..b9b28647adef 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -693,6 +693,8 @@ int mtd_erase(struct mtd_info *mtd, struct erase_info *instr)
 {
 	if (instr->addr > mtd->size || instr->len > mtd->size - instr->addr)
 		return -EINVAL;
+	if (!(mtd->flags & MTD_WRITEABLE))
+		return -EROFS;
 	return mtd->_erase(mtd, instr);
 }
 EXPORT_SYMBOL_GPL(mtd_erase);
@@ -752,10 +754,10 @@ int mtd_write(struct mtd_info *mtd, loff_t to, size_t len, size_t *retlen,
 	      const u_char *buf)
 {
 	*retlen = 0;
-	if (!mtd->_write)
-		return -EROFS;
 	if (to < 0 || to > mtd->size || len > mtd->size - to)
 		return -EINVAL;
+	if (!mtd->_write || !(mtd->flags & MTD_WRITEABLE))
+		return -EROFS;
 	return mtd->_write(mtd, to, len, retlen, buf);
 }
 EXPORT_SYMBOL_GPL(mtd_write);
@@ -775,6 +777,8 @@ int mtd_panic_write(struct mtd_info *mtd, loff_t to, size_t len, size_t *retlen,
 		return -EOPNOTSUPP;
 	if (to < 0 || to > mtd->size || len > mtd->size - to)
 		return -EINVAL;
+	if (!(mtd->flags & MTD_WRITEABLE))
+		return -EROFS;
 	return mtd->_panic_write(mtd, to, len, retlen, buf);
 }
 EXPORT_SYMBOL_GPL(mtd_panic_write);
@@ -826,6 +830,8 @@ int mtd_block_markbad(struct mtd_info *mtd, loff_t ofs)
 		return -EOPNOTSUPP;
 	if (ofs < 0 || ofs > mtd->size)
 		return -EINVAL;
+	if (!(mtd->flags & MTD_WRITEABLE))
+		return -EROFS;
 	return mtd->_block_markbad(mtd, ofs);
 }
 EXPORT_SYMBOL_GPL(mtd_block_markbad);
@@ -877,6 +883,8 @@ int mtd_writev(struct mtd_info *mtd, const struct kvec *vecs,
 	       unsigned long count, loff_t to, size_t *retlen)
 {
 	*retlen = 0;
+	if (!(mtd->flags & MTD_WRITEABLE))
+		return -EROFS;
 	if (!mtd->_writev)
 		return default_mtd_writev(mtd, vecs, count, to, retlen);
 	return mtd->_writev(mtd, vecs, count, to, retlen);

commit 8273a0c911d8e068297ef70aa7241ee78db4c712
Author: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
Date:   Fri Feb 3 14:34:14 2012 +0200

    mtd: add offset and length checks to the API function
    
    Add verification of the offset and length to MTD API functions and verify that
    MTD device offset and length are within MTD device size.
    
    The modified API functions are:
    
    'mtd_erase()'
    'mtd_point()'
    'mtd_unpoint()'
    'mtd_get_unmapped_area()'
    'mtd_read()'
    'mtd_write()'
    'mtd_panic_write()'
    'mtd_lock()'
    'mtd_unlock()'
    'mtd_is_locked()'
    'mtd_block_isbad()'
    'mtd_block_markbad()'
    
    This patch also uninlines these functions and exports in mtdcore.c because they
    are not performance-critical and do not have to be inlined.
    
    Signed-off-by: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index 5ea22cf357fb..8d5e103695f9 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -682,6 +682,154 @@ void __put_mtd_device(struct mtd_info *mtd)
 }
 EXPORT_SYMBOL_GPL(__put_mtd_device);
 
+/*
+ * Erase is an asynchronous operation.  Device drivers are supposed
+ * to call instr->callback() whenever the operation completes, even
+ * if it completes with a failure.
+ * Callers are supposed to pass a callback function and wait for it
+ * to be called before writing to the block.
+ */
+int mtd_erase(struct mtd_info *mtd, struct erase_info *instr)
+{
+	if (instr->addr > mtd->size || instr->len > mtd->size - instr->addr)
+		return -EINVAL;
+	return mtd->_erase(mtd, instr);
+}
+EXPORT_SYMBOL_GPL(mtd_erase);
+
+/*
+ * This stuff for eXecute-In-Place. phys is optional and may be set to NULL.
+ */
+int mtd_point(struct mtd_info *mtd, loff_t from, size_t len, size_t *retlen,
+	      void **virt, resource_size_t *phys)
+{
+	*retlen = 0;
+	if (!mtd->_point)
+		return -EOPNOTSUPP;
+	if (from < 0 || from > mtd->size || len > mtd->size - from)
+		return -EINVAL;
+	return mtd->_point(mtd, from, len, retlen, virt, phys);
+}
+EXPORT_SYMBOL_GPL(mtd_point);
+
+/* We probably shouldn't allow XIP if the unpoint isn't a NULL */
+int mtd_unpoint(struct mtd_info *mtd, loff_t from, size_t len)
+{
+	if (!mtd->_point)
+		return -EOPNOTSUPP;
+	if (from < 0 || from > mtd->size || len > mtd->size - from)
+		return -EINVAL;
+	return mtd->_unpoint(mtd, from, len);
+}
+EXPORT_SYMBOL_GPL(mtd_unpoint);
+
+/*
+ * Allow NOMMU mmap() to directly map the device (if not NULL)
+ * - return the address to which the offset maps
+ * - return -ENOSYS to indicate refusal to do the mapping
+ */
+unsigned long mtd_get_unmapped_area(struct mtd_info *mtd, unsigned long len,
+				    unsigned long offset, unsigned long flags)
+{
+	if (!mtd->_get_unmapped_area)
+		return -EOPNOTSUPP;
+	if (offset > mtd->size || len > mtd->size - offset)
+		return -EINVAL;
+	return mtd->_get_unmapped_area(mtd, len, offset, flags);
+}
+EXPORT_SYMBOL_GPL(mtd_get_unmapped_area);
+
+int mtd_read(struct mtd_info *mtd, loff_t from, size_t len, size_t *retlen,
+	     u_char *buf)
+{
+	if (from < 0 || from > mtd->size || len > mtd->size - from)
+		return -EINVAL;
+	return mtd->_read(mtd, from, len, retlen, buf);
+}
+EXPORT_SYMBOL_GPL(mtd_read);
+
+int mtd_write(struct mtd_info *mtd, loff_t to, size_t len, size_t *retlen,
+	      const u_char *buf)
+{
+	*retlen = 0;
+	if (!mtd->_write)
+		return -EROFS;
+	if (to < 0 || to > mtd->size || len > mtd->size - to)
+		return -EINVAL;
+	return mtd->_write(mtd, to, len, retlen, buf);
+}
+EXPORT_SYMBOL_GPL(mtd_write);
+
+/*
+ * In blackbox flight recorder like scenarios we want to make successful writes
+ * in interrupt context. panic_write() is only intended to be called when its
+ * known the kernel is about to panic and we need the write to succeed. Since
+ * the kernel is not going to be running for much longer, this function can
+ * break locks and delay to ensure the write succeeds (but not sleep).
+ */
+int mtd_panic_write(struct mtd_info *mtd, loff_t to, size_t len, size_t *retlen,
+		    const u_char *buf)
+{
+	*retlen = 0;
+	if (!mtd->_panic_write)
+		return -EOPNOTSUPP;
+	if (to < 0 || to > mtd->size || len > mtd->size - to)
+		return -EINVAL;
+	return mtd->_panic_write(mtd, to, len, retlen, buf);
+}
+EXPORT_SYMBOL_GPL(mtd_panic_write);
+
+/* Chip-supported device locking */
+int mtd_lock(struct mtd_info *mtd, loff_t ofs, uint64_t len)
+{
+	if (!mtd->_lock)
+		return -EOPNOTSUPP;
+	if (ofs < 0 || ofs > mtd->size || len > mtd->size - ofs)
+		return -EINVAL;
+	return mtd->_lock(mtd, ofs, len);
+}
+EXPORT_SYMBOL_GPL(mtd_lock);
+
+int mtd_unlock(struct mtd_info *mtd, loff_t ofs, uint64_t len)
+{
+	if (!mtd->_unlock)
+		return -EOPNOTSUPP;
+	if (ofs < 0 || ofs > mtd->size || len > mtd->size - ofs)
+		return -EINVAL;
+	return mtd->_unlock(mtd, ofs, len);
+}
+EXPORT_SYMBOL_GPL(mtd_unlock);
+
+int mtd_is_locked(struct mtd_info *mtd, loff_t ofs, uint64_t len)
+{
+	if (!mtd->_is_locked)
+		return -EOPNOTSUPP;
+	if (ofs < 0 || ofs > mtd->size || len > mtd->size - ofs)
+		return -EINVAL;
+	return mtd->_is_locked(mtd, ofs, len);
+}
+EXPORT_SYMBOL_GPL(mtd_is_locked);
+
+int mtd_block_isbad(struct mtd_info *mtd, loff_t ofs)
+{
+	if (!mtd->_block_isbad)
+		return 0;
+	if (ofs < 0 || ofs > mtd->size)
+		return -EINVAL;
+	return mtd->_block_isbad(mtd, ofs);
+}
+EXPORT_SYMBOL_GPL(mtd_block_isbad);
+
+int mtd_block_markbad(struct mtd_info *mtd, loff_t ofs)
+{
+	if (!mtd->_block_markbad)
+		return -EOPNOTSUPP;
+	if (ofs < 0 || ofs > mtd->size)
+		return -EINVAL;
+	return mtd->_block_markbad(mtd, ofs);
+}
+EXPORT_SYMBOL_GPL(mtd_block_markbad);
+
 /*
  * default_mtd_writev - the default writev method
  * @mtd: mtd device description object pointer

commit 3ee5014185b9041fcb27eef34c83487ce77dd9d3
Author: Brian Norris <computersforpeace@gmail.com>
Date:   Fri Jan 27 12:39:32 2012 -0800

    mtd: mtdcore: remove unnecessary mtd->resume check
    
    We don't need to to check for mtd->resume before calling mtd_resume().
    mtd_resume() should take care of that.
    
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>
    Signed-off-by: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index aafe0ee9c9f3..5ea22cf357fb 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -126,7 +126,7 @@ static int mtd_cls_resume(struct device *dev)
 {
 	struct mtd_info *mtd = dev_get_drvdata(dev);
 
-	if (mtd && mtd->_resume)
+	if (mtd)
 		mtd_resume(mtd);
 	return 0;
 }

commit 3c3c10bba1e4ccb75b41442e45c1a072f6cded19
Author: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
Date:   Mon Jan 30 14:58:32 2012 +0200

    mtd: add leading underscore to all mtd functions
    
    This patch renames all MTD functions by adding a "_" prefix:
    
    mtd->erase -> mtd->_erase
    mtd->read_oob -> mtd->_read_oob
    ...
    
    The reason is that we are re-working the MTD API and from now on it is
    an error to use MTD function pointers directly - we have a corresponding
    API call for every pointer. By adding a leading "_" we achieve the following:
    
    1. Make sure we convert every direct pointer users
    2. A leading "_" suggests that this interface is internal and it becomes
       less likely that people will use them directly
    3. Make sure all the out-of-tree modules stop compiling and the owners
       spot the big API change and amend them.
    
    Signed-off-by: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index de96865b4f96..aafe0ee9c9f3 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -126,7 +126,7 @@ static int mtd_cls_resume(struct device *dev)
 {
 	struct mtd_info *mtd = dev_get_drvdata(dev);
 
-	if (mtd && mtd->resume)
+	if (mtd && mtd->_resume)
 		mtd_resume(mtd);
 	return 0;
 }
@@ -610,8 +610,8 @@ int __get_mtd_device(struct mtd_info *mtd)
 	if (!try_module_get(mtd->owner))
 		return -ENODEV;
 
-	if (mtd->get_device) {
-		err = mtd->get_device(mtd);
+	if (mtd->_get_device) {
+		err = mtd->_get_device(mtd);
 
 		if (err) {
 			module_put(mtd->owner);
@@ -675,8 +675,8 @@ void __put_mtd_device(struct mtd_info *mtd)
 	--mtd->usecount;
 	BUG_ON(mtd->usecount < 0);
 
-	if (mtd->put_device)
-		mtd->put_device(mtd);
+	if (mtd->_put_device)
+		mtd->_put_device(mtd);
 
 	module_put(mtd->owner);
 }
@@ -729,9 +729,9 @@ int mtd_writev(struct mtd_info *mtd, const struct kvec *vecs,
 	       unsigned long count, loff_t to, size_t *retlen)
 {
 	*retlen = 0;
-	if (!mtd->writev)
+	if (!mtd->_writev)
 		return default_mtd_writev(mtd, vecs, count, to, retlen);
-	return mtd->writev(mtd, vecs, count, to, retlen);
+	return mtd->_writev(mtd, vecs, count, to, retlen);
 }
 EXPORT_SYMBOL_GPL(mtd_writev);
 

commit 335a5f409ee3960bda6b112b9d1a89d0a4e0a7eb
Author: Fabio Estevam <festevam@gmail.com>
Date:   Thu Jan 12 01:25:04 2012 -0200

    mtd: mtdcore: Fix build warning when CONFIG_MTD_CHAR is not defined
    
    Fix the following build warning:
    
    drivers/mtd/mtdcore.c: In function ‘mtd_release’:
    drivers/mtd/mtdcore.c:110: warning: unused variable ‘mtd’
    
    This happens when neither CONFIG_MTD_CHAR nor CONFIG_MTD_CHAR_MODULE are defined.
    
    Signed-off-by: Fabio Estevam <fabio.estevam@freescale.com>
    Signed-off-by: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index 9a9ce71a71fc..de96865b4f96 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -107,7 +107,7 @@ static LIST_HEAD(mtd_notifiers);
  */
 static void mtd_release(struct device *dev)
 {
-	struct mtd_info *mtd = dev_get_drvdata(dev);
+	struct mtd_info __maybe_unused *mtd = dev_get_drvdata(dev);
 	dev_t index = MTD_DEVT(mtd->index);
 
 	/* remove /dev/mtdXro node if needed */

commit 1a30871fe635d3e92972e6b93e39ff65bb57e52d
Author: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
Date:   Mon Jan 16 11:07:16 2012 +0200

    mtd: fix MTD suspend
    
    Commits 3fe4bae88460869a8e553397cd9057a4ee7ca341 and
    079c985e7a6f4ce60f931cebfdd5ee3c3 broke MTD suspend in 2 ways:
    
    1. When the '->suspend' method is not present, we return -EOPNOTSUPP, but
       the callers of 'mtd_suspend()' expects 0 instead.
    2. Checking of the 'mtd' parameter against NULL has been incorrectly removed
       in 'mtd_cls_suspend()'.
    
    This patch fixes the breakages. This has been found, analyzed, reported
    and tested by Rafael J. Wysocki <rjw@sisk.pl>.
    
    Note, this patch is not needed in the stable tree because it causes a
    regression introduced during the v3.3 merge window.
    
    Reported-by: Rafael J. Wysocki <rjw@sisk.pl>
    Tested-by: Rafael J. Wysocki <rjw@sisk.pl>
    Tested-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Signed-off-by: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index 6ae9ca01388b..9a9ce71a71fc 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -119,7 +119,7 @@ static int mtd_cls_suspend(struct device *dev, pm_message_t state)
 {
 	struct mtd_info *mtd = dev_get_drvdata(dev);
 
-	return mtd_suspend(mtd);
+	return mtd ? mtd_suspend(mtd) : 0;
 }
 
 static int mtd_cls_resume(struct device *dev)

commit 079c985e7a6f4ce60f931cebfdd5ee3c38347e31
Author: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
Date:   Fri Dec 30 17:15:59 2011 +0200

    mtd: do not use mtd->suspend and mtd->resume directly
    
    Just call the 'mtd_suspend()' and 'mtd_resume()' - they will do nothing
    if the operation is not defined.
    
    Signed-off-by: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index 66494ee5355a..6ae9ca01388b 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -119,10 +119,7 @@ static int mtd_cls_suspend(struct device *dev, pm_message_t state)
 {
 	struct mtd_info *mtd = dev_get_drvdata(dev);
 
-	if (mtd && mtd->suspend)
-		return mtd_suspend(mtd);
-	else
-		return 0;
+	return mtd_suspend(mtd);
 }
 
 static int mtd_cls_resume(struct device *dev)

commit 381345652fca688aeaa967c231e5075cf68d05b6
Author: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
Date:   Fri Dec 30 17:00:35 2011 +0200

    mtd: do not use mtd->lock, unlock and is_locked directly
    
    Instead, call the corresponding MTD API function which will return
    '-EOPNOTSUPP' if the operation is not supported.
    
    Signed-off-by: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index 4d0f3e557bd1..66494ee5355a 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -339,9 +339,9 @@ int add_mtd_device(struct mtd_info *mtd)
 	mtd->writesize_mask = (1 << mtd->writesize_shift) - 1;
 
 	/* Some chips always power up locked. Unlock them now */
-	if ((mtd->flags & MTD_WRITEABLE)
-	    && (mtd->flags & MTD_POWERUP_LOCK) && mtd->unlock) {
-		if (mtd_unlock(mtd, 0, mtd->size))
+	if ((mtd->flags & MTD_WRITEABLE) && (mtd->flags & MTD_POWERUP_LOCK)) {
+		error = mtd_unlock(mtd, 0, mtd->size);
+		if (error && error != -EOPNOTSUPP)
 			printk(KERN_WARNING
 			       "%s: unlock failed, writes may not work\n",
 			       mtd->name);

commit 1dbebd32562b3c2caeca35960e5cb00bfcc12900
Author: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
Date:   Fri Dec 30 16:23:41 2011 +0200

    mtd: harmonize mtd_writev usage
    
    This patch makes the 'mtd_writev()' function more usable and logical. We first
    teach it to fall-back to the 'default_mtd_writev()' function if the MTD driver
    does not define its own '->writev()' method. Then we make block2mtd and JFFS2
    just 'mtd_writev()' instead of 'default_mtd_writev()' function. This means we
    can now stop exporting 'default_mtd_writev()' and instead, export
    'mtd_writev()'. This is much cleaner and more logical, as well as allows us to
    get read of another direct 'mtd->writev' access in JFFS2.
    
    Signed-off-by: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index 53a200f722b6..4d0f3e557bd1 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -696,8 +696,8 @@ EXPORT_SYMBOL_GPL(__put_mtd_device);
  * This function returns zero in case of success and a negative error code in
  * case of failure.
  */
-int default_mtd_writev(struct mtd_info *mtd, const struct kvec *vecs,
-		       unsigned long count, loff_t to, size_t *retlen)
+static int default_mtd_writev(struct mtd_info *mtd, const struct kvec *vecs,
+			      unsigned long count, loff_t to, size_t *retlen)
 {
 	unsigned long i;
 	size_t totlen = 0, thislen;
@@ -716,7 +716,27 @@ int default_mtd_writev(struct mtd_info *mtd, const struct kvec *vecs,
 	*retlen = totlen;
 	return ret;
 }
-EXPORT_SYMBOL_GPL(default_mtd_writev);
+
+/*
+ * mtd_writev - the vector-based MTD write method
+ * @mtd: mtd device description object pointer
+ * @vecs: the vectors to write
+ * @count: count of vectors in @vecs
+ * @to: the MTD device offset to write to
+ * @retlen: on exit contains the count of bytes written to the MTD device.
+ *
+ * This function returns zero in case of success and a negative error code in
+ * case of failure.
+ */
+int mtd_writev(struct mtd_info *mtd, const struct kvec *vecs,
+	       unsigned long count, loff_t to, size_t *retlen)
+{
+	*retlen = 0;
+	if (!mtd->writev)
+		return default_mtd_writev(mtd, vecs, count, to, retlen);
+	return mtd->writev(mtd, vecs, count, to, retlen);
+}
+EXPORT_SYMBOL_GPL(mtd_writev);
 
 /**
  * mtd_kmalloc_up_to - allocate a contiguous buffer up to the specified size

commit 33c87b4a2c820316314542ce3f60b8a8c6a96928
Author: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
Date:   Fri Dec 30 16:11:14 2011 +0200

    mtd: mtdcore: export symbols cleanup
    
    The mtdcore.c file is a bit inconsistent - some EXPORT_SYMBOL_GPL declarations
    follow the corresponding functions, some are placed at the end. This patch
    harmonizes the file so that EXPORT_SYMBOL_GPL declarations follow the
    corresponding function.
    
    It also removes few extra newlines and trailing white-spaces.
    
    Signed-off-by: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index 85a3f197e7f0..53a200f722b6 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -128,7 +128,7 @@ static int mtd_cls_suspend(struct device *dev, pm_message_t state)
 static int mtd_cls_resume(struct device *dev)
 {
 	struct mtd_info *mtd = dev_get_drvdata(dev);
-	
+
 	if (mtd && mtd->resume)
 		mtd_resume(mtd);
 	return 0;
@@ -517,7 +517,6 @@ EXPORT_SYMBOL_GPL(mtd_device_unregister);
  *	or removal of MTD devices. Causes the 'add' callback to be immediately
  *	invoked for each MTD device currently present in the system.
  */
-
 void register_mtd_user (struct mtd_notifier *new)
 {
 	struct mtd_info *mtd;
@@ -533,6 +532,7 @@ void register_mtd_user (struct mtd_notifier *new)
 
 	mutex_unlock(&mtd_table_mutex);
 }
+EXPORT_SYMBOL_GPL(register_mtd_user);
 
 /**
  *	unregister_mtd_user - unregister a 'user' of MTD devices.
@@ -543,7 +543,6 @@ void register_mtd_user (struct mtd_notifier *new)
  *	'remove' callback to be immediately invoked for each MTD device
  *	currently present in the system.
  */
-
 int unregister_mtd_user (struct mtd_notifier *old)
 {
 	struct mtd_info *mtd;
@@ -559,7 +558,7 @@ int unregister_mtd_user (struct mtd_notifier *old)
 	mutex_unlock(&mtd_table_mutex);
 	return 0;
 }
-
+EXPORT_SYMBOL_GPL(unregister_mtd_user);
 
 /**
  *	get_mtd_device - obtain a validated handle for an MTD device
@@ -572,7 +571,6 @@ int unregister_mtd_user (struct mtd_notifier *old)
  *	both, return the num'th driver only if its address matches. Return
  *	error code if not.
  */
-
 struct mtd_info *get_mtd_device(struct mtd_info *mtd, int num)
 {
 	struct mtd_info *ret = NULL, *other;
@@ -605,6 +603,7 @@ struct mtd_info *get_mtd_device(struct mtd_info *mtd, int num)
 	mutex_unlock(&mtd_table_mutex);
 	return ret;
 }
+EXPORT_SYMBOL_GPL(get_mtd_device);
 
 
 int __get_mtd_device(struct mtd_info *mtd)
@@ -625,6 +624,7 @@ int __get_mtd_device(struct mtd_info *mtd)
 	mtd->usecount++;
 	return 0;
 }
+EXPORT_SYMBOL_GPL(__get_mtd_device);
 
 /**
  *	get_mtd_device_nm - obtain a validated handle for an MTD device by
@@ -634,7 +634,6 @@ int __get_mtd_device(struct mtd_info *mtd)
  * 	This function returns MTD device description structure in case of
  * 	success and an error code in case of failure.
  */
-
 struct mtd_info *get_mtd_device_nm(const char *name)
 {
 	int err = -ENODEV;
@@ -663,6 +662,7 @@ struct mtd_info *get_mtd_device_nm(const char *name)
 	mutex_unlock(&mtd_table_mutex);
 	return ERR_PTR(err);
 }
+EXPORT_SYMBOL_GPL(get_mtd_device_nm);
 
 void put_mtd_device(struct mtd_info *mtd)
 {
@@ -671,6 +671,7 @@ void put_mtd_device(struct mtd_info *mtd)
 	mutex_unlock(&mtd_table_mutex);
 
 }
+EXPORT_SYMBOL_GPL(put_mtd_device);
 
 void __put_mtd_device(struct mtd_info *mtd)
 {
@@ -682,6 +683,7 @@ void __put_mtd_device(struct mtd_info *mtd)
 
 	module_put(mtd->owner);
 }
+EXPORT_SYMBOL_GPL(__put_mtd_device);
 
 /*
  * default_mtd_writev - the default writev method
@@ -714,6 +716,7 @@ int default_mtd_writev(struct mtd_info *mtd, const struct kvec *vecs,
 	*retlen = totlen;
 	return ret;
 }
+EXPORT_SYMBOL_GPL(default_mtd_writev);
 
 /**
  * mtd_kmalloc_up_to - allocate a contiguous buffer up to the specified size
@@ -763,15 +766,6 @@ void *mtd_kmalloc_up_to(const struct mtd_info *mtd, size_t *size)
 	 */
 	return kmalloc(*size, GFP_KERNEL);
 }
-
-EXPORT_SYMBOL_GPL(get_mtd_device);
-EXPORT_SYMBOL_GPL(get_mtd_device_nm);
-EXPORT_SYMBOL_GPL(__get_mtd_device);
-EXPORT_SYMBOL_GPL(put_mtd_device);
-EXPORT_SYMBOL_GPL(__put_mtd_device);
-EXPORT_SYMBOL_GPL(register_mtd_user);
-EXPORT_SYMBOL_GPL(unregister_mtd_user);
-EXPORT_SYMBOL_GPL(default_mtd_writev);
 EXPORT_SYMBOL_GPL(mtd_kmalloc_up_to);
 
 #ifdef CONFIG_PROC_FS

commit 52b020317f65114eeba2ee2cfa70a51a286f1d8a
Author: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
Date:   Fri Dec 30 15:57:25 2011 +0200

    mtd: clean-up the default_mtd_writev function
    
    1. Teach 'mtd_write()' function to return '-EROFS' if the write method
       is undefined, and remove the corresponding check from
       'default_mtd_writev()'.
    2. Do not test 'retlen' for NULL - it cannot be NULL.
    3. Few minor coding stile clean-ups.
    4. Add a kerneldoc comment
    
    Additionally, minor fixes to the kerneldoc comments of the neighbor function.
    
    Signed-off-by: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index 8bea2d0fdb20..85a3f197e7f0 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -683,10 +683,17 @@ void __put_mtd_device(struct mtd_info *mtd)
 	module_put(mtd->owner);
 }
 
-/* default_mtd_writev - default mtd writev method for MTD devices that
- *			don't implement their own
+/*
+ * default_mtd_writev - the default writev method
+ * @mtd: mtd device description object pointer
+ * @vecs: the vectors to write
+ * @count: count of vectors in @vecs
+ * @to: the MTD device offset to write to
+ * @retlen: on exit contains the count of bytes written to the MTD device.
+ *
+ * This function returns zero in case of success and a negative error code in
+ * case of failure.
  */
-
 int default_mtd_writev(struct mtd_info *mtd, const struct kvec *vecs,
 		       unsigned long count, loff_t to, size_t *retlen)
 {
@@ -694,28 +701,24 @@ int default_mtd_writev(struct mtd_info *mtd, const struct kvec *vecs,
 	size_t totlen = 0, thislen;
 	int ret = 0;
 
-	if(!mtd->write) {
-		ret = -EROFS;
-	} else {
-		for (i=0; i<count; i++) {
-			if (!vecs[i].iov_len)
-				continue;
-			ret = mtd_write(mtd, to, vecs[i].iov_len, &thislen,
-					vecs[i].iov_base);
-			totlen += thislen;
-			if (ret || thislen != vecs[i].iov_len)
-				break;
-			to += vecs[i].iov_len;
-		}
+	for (i = 0; i < count; i++) {
+		if (!vecs[i].iov_len)
+			continue;
+		ret = mtd_write(mtd, to, vecs[i].iov_len, &thislen,
+				vecs[i].iov_base);
+		totlen += thislen;
+		if (ret || thislen != vecs[i].iov_len)
+			break;
+		to += vecs[i].iov_len;
 	}
-	if (retlen)
-		*retlen = totlen;
+	*retlen = totlen;
 	return ret;
 }
 
 /**
  * mtd_kmalloc_up_to - allocate a contiguous buffer up to the specified size
- * @size: A pointer to the ideal or maximum size of the allocation. Points
+ * @mtd: mtd device description object pointer
+ * @size: a pointer to the ideal or maximum size of the allocation, points
  *        to the actual allocation size on success.
  *
  * This routine attempts to allocate a contiguous kernel buffer up to

commit d5de20a9a1c5ad68c07e017d11f6dbb5e289750c
Author: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
Date:   Thu Dec 29 18:00:29 2011 +0200

    mtd: kill dev_to_mtd helper
    
    ... since it is not needed because the generic 'dev_get_drvdata()' can be
    used instead.
    
    Signed-off-by: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
    Acked-by: Mike Frysinger <vapier@gentoo.org>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index 376fbfdb09aa..8bea2d0fdb20 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -107,7 +107,8 @@ static LIST_HEAD(mtd_notifiers);
  */
 static void mtd_release(struct device *dev)
 {
-	dev_t index = MTD_DEVT(dev_to_mtd(dev)->index);
+	struct mtd_info *mtd = dev_get_drvdata(dev);
+	dev_t index = MTD_DEVT(mtd->index);
 
 	/* remove /dev/mtdXro node if needed */
 	if (index)
@@ -116,7 +117,7 @@ static void mtd_release(struct device *dev)
 
 static int mtd_cls_suspend(struct device *dev, pm_message_t state)
 {
-	struct mtd_info *mtd = dev_to_mtd(dev);
+	struct mtd_info *mtd = dev_get_drvdata(dev);
 
 	if (mtd && mtd->suspend)
 		return mtd_suspend(mtd);
@@ -126,7 +127,7 @@ static int mtd_cls_suspend(struct device *dev, pm_message_t state)
 
 static int mtd_cls_resume(struct device *dev)
 {
-	struct mtd_info *mtd = dev_to_mtd(dev);
+	struct mtd_info *mtd = dev_get_drvdata(dev);
 	
 	if (mtd && mtd->resume)
 		mtd_resume(mtd);
@@ -136,7 +137,7 @@ static int mtd_cls_resume(struct device *dev)
 static ssize_t mtd_type_show(struct device *dev,
 		struct device_attribute *attr, char *buf)
 {
-	struct mtd_info *mtd = dev_to_mtd(dev);
+	struct mtd_info *mtd = dev_get_drvdata(dev);
 	char *type;
 
 	switch (mtd->type) {
@@ -172,7 +173,7 @@ static DEVICE_ATTR(type, S_IRUGO, mtd_type_show, NULL);
 static ssize_t mtd_flags_show(struct device *dev,
 		struct device_attribute *attr, char *buf)
 {
-	struct mtd_info *mtd = dev_to_mtd(dev);
+	struct mtd_info *mtd = dev_get_drvdata(dev);
 
 	return snprintf(buf, PAGE_SIZE, "0x%lx\n", (unsigned long)mtd->flags);
 
@@ -182,7 +183,7 @@ static DEVICE_ATTR(flags, S_IRUGO, mtd_flags_show, NULL);
 static ssize_t mtd_size_show(struct device *dev,
 		struct device_attribute *attr, char *buf)
 {
-	struct mtd_info *mtd = dev_to_mtd(dev);
+	struct mtd_info *mtd = dev_get_drvdata(dev);
 
 	return snprintf(buf, PAGE_SIZE, "%llu\n",
 		(unsigned long long)mtd->size);
@@ -193,7 +194,7 @@ static DEVICE_ATTR(size, S_IRUGO, mtd_size_show, NULL);
 static ssize_t mtd_erasesize_show(struct device *dev,
 		struct device_attribute *attr, char *buf)
 {
-	struct mtd_info *mtd = dev_to_mtd(dev);
+	struct mtd_info *mtd = dev_get_drvdata(dev);
 
 	return snprintf(buf, PAGE_SIZE, "%lu\n", (unsigned long)mtd->erasesize);
 
@@ -203,7 +204,7 @@ static DEVICE_ATTR(erasesize, S_IRUGO, mtd_erasesize_show, NULL);
 static ssize_t mtd_writesize_show(struct device *dev,
 		struct device_attribute *attr, char *buf)
 {
-	struct mtd_info *mtd = dev_to_mtd(dev);
+	struct mtd_info *mtd = dev_get_drvdata(dev);
 
 	return snprintf(buf, PAGE_SIZE, "%lu\n", (unsigned long)mtd->writesize);
 
@@ -213,7 +214,7 @@ static DEVICE_ATTR(writesize, S_IRUGO, mtd_writesize_show, NULL);
 static ssize_t mtd_subpagesize_show(struct device *dev,
 		struct device_attribute *attr, char *buf)
 {
-	struct mtd_info *mtd = dev_to_mtd(dev);
+	struct mtd_info *mtd = dev_get_drvdata(dev);
 	unsigned int subpagesize = mtd->writesize >> mtd->subpage_sft;
 
 	return snprintf(buf, PAGE_SIZE, "%u\n", subpagesize);
@@ -224,7 +225,7 @@ static DEVICE_ATTR(subpagesize, S_IRUGO, mtd_subpagesize_show, NULL);
 static ssize_t mtd_oobsize_show(struct device *dev,
 		struct device_attribute *attr, char *buf)
 {
-	struct mtd_info *mtd = dev_to_mtd(dev);
+	struct mtd_info *mtd = dev_get_drvdata(dev);
 
 	return snprintf(buf, PAGE_SIZE, "%lu\n", (unsigned long)mtd->oobsize);
 
@@ -234,7 +235,7 @@ static DEVICE_ATTR(oobsize, S_IRUGO, mtd_oobsize_show, NULL);
 static ssize_t mtd_numeraseregions_show(struct device *dev,
 		struct device_attribute *attr, char *buf)
 {
-	struct mtd_info *mtd = dev_to_mtd(dev);
+	struct mtd_info *mtd = dev_get_drvdata(dev);
 
 	return snprintf(buf, PAGE_SIZE, "%u\n", mtd->numeraseregions);
 
@@ -245,7 +246,7 @@ static DEVICE_ATTR(numeraseregions, S_IRUGO, mtd_numeraseregions_show,
 static ssize_t mtd_name_show(struct device *dev,
 		struct device_attribute *attr, char *buf)
 {
-	struct mtd_info *mtd = dev_to_mtd(dev);
+	struct mtd_info *mtd = dev_get_drvdata(dev);
 
 	return snprintf(buf, PAGE_SIZE, "%s\n", mtd->name);
 

commit ead995f8d4da1e2f1ef40b0e5f4133fee38a3d3d
Author: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
Date:   Fri Dec 23 19:31:25 2011 +0200

    mtd: introduce mtd_resume interface
    
    Signed-off-by: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index 0db455d31148..376fbfdb09aa 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -129,7 +129,7 @@ static int mtd_cls_resume(struct device *dev)
 	struct mtd_info *mtd = dev_to_mtd(dev);
 	
 	if (mtd && mtd->resume)
-		mtd->resume(mtd);
+		mtd_resume(mtd);
 	return 0;
 }
 

commit 3fe4bae88460869a8e553397cd9057a4ee7ca341
Author: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
Date:   Fri Dec 23 19:25:16 2011 +0200

    mtd: introduce mtd_suspend interface
    
    Signed-off-by: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index 4a2155748fa3..0db455d31148 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -119,7 +119,7 @@ static int mtd_cls_suspend(struct device *dev, pm_message_t state)
 	struct mtd_info *mtd = dev_to_mtd(dev);
 
 	if (mtd && mtd->suspend)
-		return mtd->suspend(mtd);
+		return mtd_suspend(mtd);
 	else
 		return 0;
 }

commit b66005cd3e6f104e0a1b6492110c337269b53ec3
Author: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
Date:   Fri Dec 23 19:18:22 2011 +0200

    mtd: introduce mtd_unlock interface
    
    Signed-off-by: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index e36191ab47c3..4a2155748fa3 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -340,7 +340,7 @@ int add_mtd_device(struct mtd_info *mtd)
 	/* Some chips always power up locked. Unlock them now */
 	if ((mtd->flags & MTD_WRITEABLE)
 	    && (mtd->flags & MTD_POWERUP_LOCK) && mtd->unlock) {
-		if (mtd->unlock(mtd, 0, mtd->size))
+		if (mtd_unlock(mtd, 0, mtd->size))
 			printk(KERN_WARNING
 			       "%s: unlock failed, writes may not work\n",
 			       mtd->name);

commit eda95cbf75193808f62948fb0142ba0901d8bee2
Author: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
Date:   Fri Dec 23 17:35:41 2011 +0200

    mtd: introduce mtd_write interface
    
    Signed-off-by: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index b01993ea260e..e36191ab47c3 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -699,7 +699,8 @@ int default_mtd_writev(struct mtd_info *mtd, const struct kvec *vecs,
 		for (i=0; i<count; i++) {
 			if (!vecs[i].iov_len)
 				continue;
-			ret = mtd->write(mtd, to, vecs[i].iov_len, &thislen, vecs[i].iov_base);
+			ret = mtd_write(mtd, to, vecs[i].iov_len, &thislen,
+					vecs[i].iov_base);
 			totlen += thislen;
 			if (ret || thislen != vecs[i].iov_len)
 				break;

commit 4d523b60ef9d1953d9e12745ca0ed3e2dc98c189
Author: Jason Liu <jason.hui@linaro.org>
Date:   Wed Aug 24 19:26:28 2011 +0800

    mtd: check parts pointer before using it
    
    The code has the check for parts but it called after kmemdup,
    kmemdup(parts, sizeof(*parts) * nr_parts,...)
    if (!parts)
            return -ENOMEM
    
    In fact, we need check parts before safely using it.
    and we also need check the real_parts to make sure kmemdup
    allocation sucessfully.
    
    Signed-off-by: Jason Liu <jason.hui@linaro.org>
    Signed-off-by: Artem Bityutskiy <artem.bityutskiy@intel.com>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index 09bdbac51868..b01993ea260e 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -465,12 +465,13 @@ int mtd_device_parse_register(struct mtd_info *mtd, const char **types,
 	struct mtd_partition *real_parts;
 
 	err = parse_mtd_partitions(mtd, types, &real_parts, parser_data);
-	if (err <= 0 && nr_parts) {
+	if (err <= 0 && nr_parts && parts) {
 		real_parts = kmemdup(parts, sizeof(*parts) * nr_parts,
 				     GFP_KERNEL);
-		err = nr_parts;
-		if (!parts)
+		if (!real_parts)
 			err = -ENOMEM;
+		else
+			err = nr_parts;
 	}
 
 	if (err > 0) {

commit 92394b5c2be774425f255b5c7afbd8b19978fe12
Author: Brian Norris <computersforpeace@gmail.com>
Date:   Wed Jul 20 09:53:42 2011 -0700

    mtd: spelling fixes
    
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>
    Signed-off-by: Artem Bityutskiy <artem.bityutskiy@intel.com>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index 887aed02aa2e..09bdbac51868 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -449,7 +449,7 @@ int del_mtd_device(struct mtd_info *mtd)
  *   is used, see 'parse_mtd_partitions()' for more information). If none are
  *   found this functions tries to fallback to information specified in
  *   @parts/@nr_parts.
- * * If any parititioning info was found, this function registers the found
+ * * If any partitioning info was found, this function registers the found
  *   partitions.
  * * If no partitions were found this function just registers the MTD device
  *   @mtd and exits.

commit 289c05222172b51401dbbb017115655f241d94ab
Author: Brian Norris <computersforpeace@gmail.com>
Date:   Tue Jul 19 10:06:09 2011 -0700

    mtd: replace DEBUG() with pr_debug()
    
    Start moving away from the MTD_DEBUG_LEVEL messages. The dynamic
    debugging feature is a generic kernel feature that provides more
    flexibility.
    
    (See Documentation/dynamic-debug-howto.txt)
    
    Also fix some punctuation, indentation, and capitalization that went
    along with the affected lines.
    
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>
    Signed-off-by: Artem Bityutskiy <artem.bityutskiy@intel.com>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index f9cc2d2cb5cb..887aed02aa2e 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -362,7 +362,7 @@ int add_mtd_device(struct mtd_info *mtd)
 			      MTD_DEVT(i) + 1,
 			      NULL, "mtd%dro", i);
 
-	DEBUG(0, "mtd: Giving out device %d to %s\n", i, mtd->name);
+	pr_debug("mtd: Giving out device %d to %s\n", i, mtd->name);
 	/* No need to get a refcount on the module containing
 	   the notifier, since we hold the mtd_table_mutex */
 	list_for_each_entry(not, &mtd_notifiers, list)

commit 15c60a508ab3393e68b7ccb3528981ccacf9c0f9
Author: Dmitry Eremin-Solenikov <dbaryshkov@gmail.com>
Date:   Thu Jun 23 15:33:15 2011 +0400

    mtd: drop mtd_device_register
    
    mtd_device_register() is a limited version of mtd_device_parse_register.
    Replace it with macro calling mtd_device_parse_register().
    
    Signed-off-by: Dmitry Eremin-Solenikov <dbaryshkov@gmail.com>
    Signed-off-by: Artem Bityutskiy <Artem.Bityutskiy@nokia.com>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index e18639980f7a..f9cc2d2cb5cb 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -428,29 +428,6 @@ int del_mtd_device(struct mtd_info *mtd)
 	return ret;
 }
 
-/**
- * mtd_device_register - register an MTD device.
- *
- * @master: the MTD device to register
- * @parts: the partitions to register - only valid if nr_parts > 0
- * @nr_parts: the number of partitions in parts.  If zero then the full MTD
- *            device is registered
- *
- * Register an MTD device with the system and optionally, a number of
- * partitions.  If nr_parts is 0 then the whole device is registered, otherwise
- * only the partitions are registered.  To register both the full device *and*
- * the partitions, call mtd_device_register() twice, once with nr_parts == 0
- * and once equal to the number of partitions.
- */
-int mtd_device_register(struct mtd_info *master,
-			const struct mtd_partition *parts,
-			int nr_parts)
-{
-	return parts ? add_mtd_partitions(master, parts, nr_parts) :
-		add_mtd_device(master);
-}
-EXPORT_SYMBOL_GPL(mtd_device_register);
-
 /**
  * mtd_device_parse_register - parse partitions and register an MTD device.
  *

commit c7975330154af17aecc167b33ca866b6b3d98918
Author: Dmitry Eremin-Solenikov <dbaryshkov@gmail.com>
Date:   Fri Jun 10 18:18:28 2011 +0400

    mtd: abstract last MTD partition parser argument
    
    Encapsulate last MTD partition parser argument into a separate
    structure. Currently it holds only 'origin' field for RedBoot parser,
    but will be extended in future to contain at least device_node for OF
    devices.
    
    Amended commentary to make kerneldoc happy
    
    Signed-off-by: Dmitry Eremin-Solenikov <dbaryshkov@gmail.com>
    Signed-off-by: Artem Bityutskiy <dedekind1@gmail.com>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index 13267477e4e9..e18639980f7a 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -457,7 +457,7 @@ EXPORT_SYMBOL_GPL(mtd_device_register);
  * @mtd: the MTD device to register
  * @types: the list of MTD partition probes to try, see
  *         'parse_mtd_partitions()' for more information
- * @origin: start address of MTD device, %0 unless you are sure you need this.
+ * @parser_data: MTD partition parser-specific data
  * @parts: fallback partition information to register, if parsing fails;
  *         only valid if %nr_parts > %0
  * @nr_parts: the number of partitions in parts, if zero then the full
@@ -480,14 +480,14 @@ EXPORT_SYMBOL_GPL(mtd_device_register);
  * Returns zero in case of success and a negative error code in case of failure.
  */
 int mtd_device_parse_register(struct mtd_info *mtd, const char **types,
-			      unsigned long origin,
+			      struct mtd_part_parser_data *parser_data,
 			      const struct mtd_partition *parts,
 			      int nr_parts)
 {
 	int err;
 	struct mtd_partition *real_parts;
 
-	err = parse_mtd_partitions(mtd, types, &real_parts, origin);
+	err = parse_mtd_partitions(mtd, types, &real_parts, parser_data);
 	if (err <= 0 && nr_parts) {
 		real_parts = kmemdup(parts, sizeof(*parts) * nr_parts,
 				     GFP_KERNEL);

commit 1c4c215cbdcbfd08183d82b2953591cd00564422
Author: Dmitry Eremin-Solenikov <dbaryshkov@gmail.com>
Date:   Fri Mar 25 22:26:25 2011 +0300

    mtd: add new API for handling MTD registration
    
    Lots (nearly all) mtd drivers contain nearly the similar code that
    calls parse_mtd_partitions, provides some platform-default values, if
    parsing fails, and registers  mtd device.
    
    This is an aim to provide single implementation of this scenario:
    mtd_device_parse_register() which will handle all this parsing and
    defaults.
    
    Artem: amended comments
    
    Signed-off-by: Dmitry Eremin-Solenikov <dbaryshkov@gmail.com>
    Signed-off-by: Artem Bityutskiy <Artem.Bityutskiy@nokia.com>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index c510aff289a8..13267477e4e9 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -451,6 +451,64 @@ int mtd_device_register(struct mtd_info *master,
 }
 EXPORT_SYMBOL_GPL(mtd_device_register);
 
+/**
+ * mtd_device_parse_register - parse partitions and register an MTD device.
+ *
+ * @mtd: the MTD device to register
+ * @types: the list of MTD partition probes to try, see
+ *         'parse_mtd_partitions()' for more information
+ * @origin: start address of MTD device, %0 unless you are sure you need this.
+ * @parts: fallback partition information to register, if parsing fails;
+ *         only valid if %nr_parts > %0
+ * @nr_parts: the number of partitions in parts, if zero then the full
+ *            MTD device is registered if no partition info is found
+ *
+ * This function aggregates MTD partitions parsing (done by
+ * 'parse_mtd_partitions()') and MTD device and partitions registering. It
+ * basically follows the most common pattern found in many MTD drivers:
+ *
+ * * It first tries to probe partitions on MTD device @mtd using parsers
+ *   specified in @types (if @types is %NULL, then the default list of parsers
+ *   is used, see 'parse_mtd_partitions()' for more information). If none are
+ *   found this functions tries to fallback to information specified in
+ *   @parts/@nr_parts.
+ * * If any parititioning info was found, this function registers the found
+ *   partitions.
+ * * If no partitions were found this function just registers the MTD device
+ *   @mtd and exits.
+ *
+ * Returns zero in case of success and a negative error code in case of failure.
+ */
+int mtd_device_parse_register(struct mtd_info *mtd, const char **types,
+			      unsigned long origin,
+			      const struct mtd_partition *parts,
+			      int nr_parts)
+{
+	int err;
+	struct mtd_partition *real_parts;
+
+	err = parse_mtd_partitions(mtd, types, &real_parts, origin);
+	if (err <= 0 && nr_parts) {
+		real_parts = kmemdup(parts, sizeof(*parts) * nr_parts,
+				     GFP_KERNEL);
+		err = nr_parts;
+		if (!parts)
+			err = -ENOMEM;
+	}
+
+	if (err > 0) {
+		err = add_mtd_partitions(mtd, real_parts, err);
+		kfree(real_parts);
+	} else if (err == 0) {
+		err = add_mtd_device(mtd);
+		if (err == 1)
+			err = -ENODEV;
+	}
+
+	return err;
+}
+EXPORT_SYMBOL_GPL(mtd_device_parse_register);
+
 /**
  * mtd_device_unregister - unregister an existing MTD device.
  *

commit eea72d5fdf59879edb2c6639b0b7cc385e0df646
Author: Jamie Iles <jamie@jamieiles.com>
Date:   Mon May 23 10:23:42 2011 +0100

    mtd: remove add_mtd_partitions, add_mtd_device and friends
    
    These symbols are replaced with mtd_device_register() (and removal with
    mtd_device_unregister()) for public registration.
    
    Signed-off-by: Jamie Iles <jamie@jamieiles.com>
    Signed-off-by: Artem Bityutskiy <Artem.Bityutskiy@nokia.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index 9af103bf9218..c510aff289a8 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -393,7 +393,7 @@ int add_mtd_device(struct mtd_info *mtd)
  *	if the requested device does not appear to be present in the list.
  */
 
-int del_mtd_device (struct mtd_info *mtd)
+int del_mtd_device(struct mtd_info *mtd)
 {
 	int ret;
 	struct mtd_notifier *not;
@@ -723,8 +723,6 @@ void *mtd_kmalloc_up_to(const struct mtd_info *mtd, size_t *size)
 	return kmalloc(*size, GFP_KERNEL);
 }
 
-EXPORT_SYMBOL_GPL(add_mtd_device);
-EXPORT_SYMBOL_GPL(del_mtd_device);
 EXPORT_SYMBOL_GPL(get_mtd_device);
 EXPORT_SYMBOL_GPL(get_mtd_device_nm);
 EXPORT_SYMBOL_GPL(__get_mtd_device);

commit f5671ab3f67a10f7234de21464391c20c1ef8ebb
Author: Jamie Iles <jamie@jamieiles.com>
Date:   Mon May 23 17:15:46 2011 +0100

    mtd: introduce mtd_device_(un)register()
    
    To prepare for the removal of add_mtd_device and add_mtd_partitions(),
    introduce mtd_device_register().  This will create partitions if they
    are supplied or register the whole device if there are no partitions.
    
    Once all drivers are converted to use mtd_device_register(),
    add_mtd_device() and add_mtd_partitions() will be made internal only.
    
    v2: move kerneldoc to implementation file and fixup some kerneldoc
    warnings.
    
    Artem: tweak comments: remove junk tabs, use dots consistently.
    
    Signed-off-by: Jamie Iles <jamie@jamieiles.com>
    Signed-off-by: Artem Bityutskiy <Artem.Bityutskiy@nokia.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index f3c94006ffe6..9af103bf9218 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -38,6 +38,7 @@
 #include <linux/gfp.h>
 
 #include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
 
 #include "mtdcore.h"
 /*
@@ -427,6 +428,50 @@ int del_mtd_device (struct mtd_info *mtd)
 	return ret;
 }
 
+/**
+ * mtd_device_register - register an MTD device.
+ *
+ * @master: the MTD device to register
+ * @parts: the partitions to register - only valid if nr_parts > 0
+ * @nr_parts: the number of partitions in parts.  If zero then the full MTD
+ *            device is registered
+ *
+ * Register an MTD device with the system and optionally, a number of
+ * partitions.  If nr_parts is 0 then the whole device is registered, otherwise
+ * only the partitions are registered.  To register both the full device *and*
+ * the partitions, call mtd_device_register() twice, once with nr_parts == 0
+ * and once equal to the number of partitions.
+ */
+int mtd_device_register(struct mtd_info *master,
+			const struct mtd_partition *parts,
+			int nr_parts)
+{
+	return parts ? add_mtd_partitions(master, parts, nr_parts) :
+		add_mtd_device(master);
+}
+EXPORT_SYMBOL_GPL(mtd_device_register);
+
+/**
+ * mtd_device_unregister - unregister an existing MTD device.
+ *
+ * @master: the MTD device to unregister.  This will unregister both the master
+ *          and any partitions if registered.
+ */
+int mtd_device_unregister(struct mtd_info *master)
+{
+	int err;
+
+	err = del_mtd_partitions(master);
+	if (err)
+		return err;
+
+	if (!device_is_registered(&master->dev))
+		return 0;
+
+	return del_mtd_device(master);
+}
+EXPORT_SYMBOL_GPL(mtd_device_unregister);
+
 /**
  *	register_mtd_user - register a 'user' of MTD devices.
  *	@new: pointer to notifier info structure

commit d5ca51292d899a19882cb9bf8f64079209e688fe
Author: Wanlong Gao <wanlong.gao@gmail.com>
Date:   Fri May 20 21:14:30 2011 +0800

    mtd:fix the bad format in the mtdcore.c
    
    Remove the spare spaces in the head of the lines.
    
    Signed-off-by: Wanlong Gao <wanlong.gao@gmail.com>
    Signed-off-by: Artem Bityutskiy <Artem.Bityutskiy@nokia.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index 8e1909115924..f3c94006ffe6 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -444,7 +444,7 @@ void register_mtd_user (struct mtd_notifier *new)
 
 	list_add(&new->list, &mtd_notifiers);
 
- 	__module_get(THIS_MODULE);
+	__module_get(THIS_MODULE);
 
 	mtd_for_each_device(mtd)
 		new->add(mtd);
@@ -707,9 +707,9 @@ static int mtd_proc_show(struct seq_file *m, void *v)
 		seq_printf(m, "mtd%d: %8.8llx %8.8x \"%s\"\n",
 			   mtd->index, (unsigned long long)mtd->size,
 			   mtd->erasesize, mtd->name);
-        }
+	}
 	mutex_unlock(&mtd_table_mutex);
-        return 0;
+	return 0;
 }
 
 static int mtd_proc_open(struct inode *inode, struct file *file)
@@ -781,7 +781,7 @@ static int __init init_mtd(void)
 static void __exit cleanup_mtd(void)
 {
 #ifdef CONFIG_PROC_FS
-        if (proc_mtd)
+	if (proc_mtd)
 		remove_proc_entry( "mtd", NULL);
 #endif /* CONFIG_PROC_FS */
 	class_unregister(&mtd_class);

commit 52534f2dba5d033c0c33e515faa2767d7e8e986a
Author: Wanlong Gao <wanlong.gao@gmail.com>
Date:   Tue May 17 22:36:18 2011 +0800

    mtd: simplify get_mtd_device_nm function
    
    'get_mtd_device_nm()' has a piece of code which equivalent to what
    '__get_mtd_device()' does - remove this duplicated code and use
    ''__get_mtd_device()' instead.
    
    Artem: changed commit message.
    Artem: while on it, remove an unnecessary extra empty line
    
    Signed-off-by: Wanlong Gao <wanlong.gao@gmail.com>
    Signed-off-by: Artem Bityutskiy <Artem.Bityutskiy@nokia.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index d162426416de..8e1909115924 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -533,7 +533,6 @@ int __get_mtd_device(struct mtd_info *mtd)
 		return -ENODEV;
 
 	if (mtd->get_device) {
-
 		err = mtd->get_device(mtd);
 
 		if (err) {
@@ -571,21 +570,13 @@ struct mtd_info *get_mtd_device_nm(const char *name)
 	if (!mtd)
 		goto out_unlock;
 
-	if (!try_module_get(mtd->owner))
+	err = __get_mtd_device(mtd);
+	if (err)
 		goto out_unlock;
 
-	if (mtd->get_device) {
-		err = mtd->get_device(mtd);
-		if (err)
-			goto out_put;
-	}
-
-	mtd->usecount++;
 	mutex_unlock(&mtd_table_mutex);
 	return mtd;
 
-out_put:
-	module_put(mtd->owner);
 out_unlock:
 	mutex_unlock(&mtd_table_mutex);
 	return ERR_PTR(err);

commit 447d9bd82020f159456ee00b011486205205aaa7
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Fri May 13 23:34:19 2011 +0300

    mtd: convert to seq_file interface
    
    ->read_proc interface is going away, switch to seq_file.
    
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Acked-by: Mike Frysinger <vapier@gentoo.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index a50348b60d79..d162426416de 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -24,6 +24,7 @@
 #include <linux/module.h>
 #include <linux/kernel.h>
 #include <linux/ptrace.h>
+#include <linux/seq_file.h>
 #include <linux/string.h>
 #include <linux/timer.h>
 #include <linux/major.h>
@@ -705,44 +706,32 @@ EXPORT_SYMBOL_GPL(mtd_kmalloc_up_to);
 
 static struct proc_dir_entry *proc_mtd;
 
-static inline int mtd_proc_info(char *buf, struct mtd_info *this)
-{
-	return sprintf(buf, "mtd%d: %8.8llx %8.8x \"%s\"\n", this->index,
-		       (unsigned long long)this->size,
-		       this->erasesize, this->name);
-}
-
-static int mtd_read_proc (char *page, char **start, off_t off, int count,
-			  int *eof, void *data_unused)
+static int mtd_proc_show(struct seq_file *m, void *v)
 {
 	struct mtd_info *mtd;
-	int len, l;
-        off_t   begin = 0;
 
+	seq_puts(m, "dev:    size   erasesize  name\n");
 	mutex_lock(&mtd_table_mutex);
-
-	len = sprintf(page, "dev:    size   erasesize  name\n");
 	mtd_for_each_device(mtd) {
-		l = mtd_proc_info(page + len, mtd);
-                len += l;
-                if (len+begin > off+count)
-                        goto done;
-                if (len+begin < off) {
-                        begin += len;
-                        len = 0;
-                }
+		seq_printf(m, "mtd%d: %8.8llx %8.8x \"%s\"\n",
+			   mtd->index, (unsigned long long)mtd->size,
+			   mtd->erasesize, mtd->name);
         }
-
-        *eof = 1;
-
-done:
 	mutex_unlock(&mtd_table_mutex);
-        if (off >= len+begin)
-                return 0;
-        *start = page + (off-begin);
-        return ((count < begin+len-off) ? count : begin+len-off);
+        return 0;
 }
 
+static int mtd_proc_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, mtd_proc_show, NULL);
+}
+
+static const struct file_operations mtd_proc_ops = {
+	.open		= mtd_proc_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
 #endif /* CONFIG_PROC_FS */
 
 /*====================================================================*/
@@ -783,8 +772,7 @@ static int __init init_mtd(void)
 		goto err_bdi3;
 
 #ifdef CONFIG_PROC_FS
-	if ((proc_mtd = create_proc_entry( "mtd", 0, NULL )))
-		proc_mtd->read_proc = mtd_read_proc;
+	proc_mtd = proc_create("mtd", 0, NULL, &mtd_proc_ops);
 #endif /* CONFIG_PROC_FS */
 	return 0;
 

commit 33b53716bc4b3ff3da2bc41581226424443f9d5a
Author: Grant Erickson <marathon96@gmail.com>
Date:   Fri Apr 8 08:51:32 2011 -0700

    mtd: create function to perform large allocations
    
    Introduce a common function to handle large, contiguous kmalloc buffer
    allocations by exponentially backing off on the size of the requested
    kernel transfer buffer until it succeeds or until the requested
    transfer buffer size falls below the page size.
    
    This helps ensure the operation can succeed under low-memory, highly-
    fragmented situations albeit somewhat more slowly.
    
    Artem: so this patch solves the problem that the kernel tries to kmalloc too
    large buffers, which (a) may fail and does fail - people complain about this,
    and (b) slows down the system in case of high memory fragmentation, because
    the kernel starts dropping caches, writing back, swapping, etc. But we do not
    really have to allocate a lot of memory to do the I/O, we may do this even with
    as little as one min. I/O unit (NAND page) of RAM. So the idea of this patch is
    that if the user asks to read or write a lot, we try to kmalloc a lot, with GFP
    flags which make the kernel _not_ drop caches, etc. If we can allocate it - good,
    if not - we try to allocate twice as less, and so on, until we reach the min.
    I/O unit size, which is our last resort allocation and use the normal
    GFP_KERNEL flag.
    
    Artem: re-write the allocation function so that it makes sure the allocated
    buffer is aligned to the min. I/O size of the flash.
    
    Signed-off-by: Grant Erickson <marathon96@gmail.com>
    Tested-by: Ben Gardiner <bengardiner@nanometrics.ca>
    Tested-by: Stefano Babic <sbabic@denx.de>
    Signed-off-by: Artem Bityutskiy <Artem.Bityutskiy@nokia.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index da69bc8a5a7d..a50348b60d79 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -638,6 +638,54 @@ int default_mtd_writev(struct mtd_info *mtd, const struct kvec *vecs,
 	return ret;
 }
 
+/**
+ * mtd_kmalloc_up_to - allocate a contiguous buffer up to the specified size
+ * @size: A pointer to the ideal or maximum size of the allocation. Points
+ *        to the actual allocation size on success.
+ *
+ * This routine attempts to allocate a contiguous kernel buffer up to
+ * the specified size, backing off the size of the request exponentially
+ * until the request succeeds or until the allocation size falls below
+ * the system page size. This attempts to make sure it does not adversely
+ * impact system performance, so when allocating more than one page, we
+ * ask the memory allocator to avoid re-trying, swapping, writing back
+ * or performing I/O.
+ *
+ * Note, this function also makes sure that the allocated buffer is aligned to
+ * the MTD device's min. I/O unit, i.e. the "mtd->writesize" value.
+ *
+ * This is called, for example by mtd_{read,write} and jffs2_scan_medium,
+ * to handle smaller (i.e. degraded) buffer allocations under low- or
+ * fragmented-memory situations where such reduced allocations, from a
+ * requested ideal, are allowed.
+ *
+ * Returns a pointer to the allocated buffer on success; otherwise, NULL.
+ */
+void *mtd_kmalloc_up_to(const struct mtd_info *mtd, size_t *size)
+{
+	gfp_t flags = __GFP_NOWARN | __GFP_WAIT |
+		       __GFP_NORETRY | __GFP_NO_KSWAPD;
+	size_t min_alloc = max_t(size_t, mtd->writesize, PAGE_SIZE);
+	void *kbuf;
+
+	*size = min_t(size_t, *size, KMALLOC_MAX_SIZE);
+
+	while (*size > min_alloc) {
+		kbuf = kmalloc(*size, flags);
+		if (kbuf)
+			return kbuf;
+
+		*size >>= 1;
+		*size = ALIGN(*size, mtd->writesize);
+	}
+
+	/*
+	 * For the last resort allocation allow 'kmalloc()' to do all sorts of
+	 * things (write-back, dropping caches, etc) by using GFP_KERNEL.
+	 */
+	return kmalloc(*size, GFP_KERNEL);
+}
+
 EXPORT_SYMBOL_GPL(add_mtd_device);
 EXPORT_SYMBOL_GPL(del_mtd_device);
 EXPORT_SYMBOL_GPL(get_mtd_device);
@@ -648,6 +696,7 @@ EXPORT_SYMBOL_GPL(__put_mtd_device);
 EXPORT_SYMBOL_GPL(register_mtd_user);
 EXPORT_SYMBOL_GPL(unregister_mtd_user);
 EXPORT_SYMBOL_GPL(default_mtd_writev);
+EXPORT_SYMBOL_GPL(mtd_kmalloc_up_to);
 
 #ifdef CONFIG_PROC_FS
 

commit ca91facf6babe548b5386993bb2820b7dc9b743d
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Tue Jan 11 18:37:25 2011 -0600

    mtd: local symbols should be static
    
    The three backing_dev_info symbols are only used in this file and
    should be static.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Artem Bityutskiy <Artem.Bityutskiy@nokia.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index 527cebf58da4..da69bc8a5a7d 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -43,7 +43,7 @@
  * backing device capabilities for non-mappable devices (such as NAND flash)
  * - permits private mappings, copies are taken of the data
  */
-struct backing_dev_info mtd_bdi_unmappable = {
+static struct backing_dev_info mtd_bdi_unmappable = {
 	.capabilities	= BDI_CAP_MAP_COPY,
 };
 
@@ -52,7 +52,7 @@ struct backing_dev_info mtd_bdi_unmappable = {
  * - permits private mappings, copies are taken of the data
  * - permits non-writable shared mappings
  */
-struct backing_dev_info mtd_bdi_ro_mappable = {
+static struct backing_dev_info mtd_bdi_ro_mappable = {
 	.capabilities	= (BDI_CAP_MAP_COPY | BDI_CAP_MAP_DIRECT |
 			   BDI_CAP_EXEC_MAP | BDI_CAP_READ_MAP),
 };
@@ -62,7 +62,7 @@ struct backing_dev_info mtd_bdi_ro_mappable = {
  * - permits private mappings, copies are taken of the data
  * - permits non-writable shared mappings
  */
-struct backing_dev_info mtd_bdi_rw_mappable = {
+static struct backing_dev_info mtd_bdi_rw_mappable = {
 	.capabilities	= (BDI_CAP_MAP_COPY | BDI_CAP_MAP_DIRECT |
 			   BDI_CAP_EXEC_MAP | BDI_CAP_READ_MAP |
 			   BDI_CAP_WRITE_MAP),

commit 6ae0185fe201eae0548dace2a84acb5050fc8606
Author: David Woodhouse <David.Woodhouse@intel.com>
Date:   Sun Aug 8 21:19:42 2010 +0100

    mtd: Remove obsolete <mtd/compatmac.h> include
    
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index 93a11f3def44..527cebf58da4 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -31,7 +31,6 @@
 #include <linux/err.h>
 #include <linux/ioctl.h>
 #include <linux/init.h>
-#include <linux/mtd/compatmac.h>
 #include <linux/proc_fs.h>
 #include <linux/idr.h>
 #include <linux/backing-dev.h>

commit a1452a3771c4eb85bd779790b040efdc36f4274e
Author: David Woodhouse <David.Woodhouse@intel.com>
Date:   Sun Aug 8 20:58:20 2010 +0100

    mtd: Update copyright notices
    
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index a1b8b70d2d0a..93a11f3def44 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -2,9 +2,23 @@
  * Core registration and callback routines for MTD
  * drivers and users.
  *
- * bdi bits are:
- * Copyright © 2006 Red Hat, Inc. All Rights Reserved.
- * Written by David Howells (dhowells@redhat.com)
+ * Copyright © 1999-2010 David Woodhouse <dwmw2@infradead.org>
+ * Copyright © 2006      Red Hat UK Limited 
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
  */
 
 #include <linux/module.h>

commit 05d71b4625bdadd7c7ae80455e7038e221c76e4d
Author: Tejun Heo <tj@kernel.org>
Date:   Tue Mar 30 02:52:39 2010 +0900

    mtd: update gfp/slab.h includes
    
    Implicit slab.h inclusion via percpu.h is about to go away.  Make sure
    gfp.h or slab.h is included as necessary.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index 3ae06c8935b5..a1b8b70d2d0a 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -21,6 +21,7 @@
 #include <linux/proc_fs.h>
 #include <linux/idr.h>
 #include <linux/backing-dev.h>
+#include <linux/gfp.h>
 
 #include <linux/mtd/mtd.h>
 

commit 0ae28a35bcb7984838acbf28bfba9c030f8b74f0
Merge: 6f1f3d0ab5c3 b57f95a38233
Author: David Woodhouse <David.Woodhouse@intel.com>
Date:   Mon May 10 14:32:46 2010 +0100

    Merge branch 'master' of git://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux-2.6
    
    Conflicts:
            drivers/mtd/mtdcore.c
    
    Pull in the bdi fixes and ARM platform changes that other outstanding
    patches depend on.

commit 0661b1ac5d48eb47c8a5948c0554fea25e0895ab
Author: Jens Axboe <jens.axboe@oracle.com>
Date:   Tue Apr 27 09:49:47 2010 +0200

    mtd: ensure that bdi entries are properly initialized and registered
    
    They will be holding dirty inodes and be responsible for flushing
    them out, so they need to be setup properly.
    
    Signed-off-by: Jens Axboe <jens.axboe@oracle.com>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index 541d556aec7e..b177e750efc3 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -659,20 +659,55 @@ static int mtd_read_proc (char *page, char **start, off_t off, int count,
 /*====================================================================*/
 /* Init code */
 
+static int __init mtd_bdi_init(struct backing_dev_info *bdi, const char *name)
+{
+	int ret;
+
+	ret = bdi_init(bdi);
+	if (!ret)
+		ret = bdi_register(bdi, NULL, name);
+
+	if (ret)
+		bdi_destroy(bdi);
+
+	return ret;
+}
+
 static int __init init_mtd(void)
 {
 	int ret;
+
 	ret = class_register(&mtd_class);
+	if (ret)
+		goto err_reg;
+
+	ret = mtd_bdi_init(&mtd_bdi_unmappable, "mtd-unmap");
+	if (ret)
+		goto err_bdi1;
+
+	ret = mtd_bdi_init(&mtd_bdi_ro_mappable, "mtd-romap");
+	if (ret)
+		goto err_bdi2;
+
+	ret = mtd_bdi_init(&mtd_bdi_rw_mappable, "mtd-rwmap");
+	if (ret)
+		goto err_bdi3;
 
-	if (ret) {
-		pr_err("Error registering mtd class: %d\n", ret);
-		return ret;
-	}
 #ifdef CONFIG_PROC_FS
 	if ((proc_mtd = create_proc_entry( "mtd", 0, NULL )))
 		proc_mtd->read_proc = mtd_read_proc;
 #endif /* CONFIG_PROC_FS */
 	return 0;
+
+err_bdi3:
+	bdi_destroy(&mtd_bdi_ro_mappable);
+err_bdi2:
+	bdi_destroy(&mtd_bdi_unmappable);
+err_bdi1:
+	class_unregister(&mtd_class);
+err_reg:
+	pr_err("Error registering mtd class or bdi: %d\n", ret);
+	return ret;
 }
 
 static void __exit cleanup_mtd(void)
@@ -682,6 +717,9 @@ static void __exit cleanup_mtd(void)
 		remove_proc_entry( "mtd", NULL);
 #endif /* CONFIG_PROC_FS */
 	class_unregister(&mtd_class);
+	bdi_destroy(&mtd_bdi_unmappable);
+	bdi_destroy(&mtd_bdi_ro_mappable);
+	bdi_destroy(&mtd_bdi_rw_mappable);
 }
 
 module_init(init_mtd);

commit a33eb6b91034c95b9b08576f68be170f995b2c7d
Author: Jörn Engel <joern@logfs.org>
Date:   Tue Apr 27 09:40:52 2010 +0200

    Move mtd_bdi_*mappable to mtdcore.c
    
    Removes one .h and one .c file that are never used outside of
    mtdcore.c.
    
    Signed-off-by: Joern Engel <joern@logfs.org>
    
    Edited to remove on leftover debug define.
    Signed-off-by: Jens Axboe <jens.axboe@oracle.com>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index 5b38b17d2229..541d556aec7e 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -2,6 +2,9 @@
  * Core registration and callback routines for MTD
  * drivers and users.
  *
+ * bdi bits are:
+ * Copyright © 2006 Red Hat, Inc. All Rights Reserved.
+ * Written by David Howells (dhowells@redhat.com)
  */
 
 #include <linux/module.h>
@@ -16,11 +19,39 @@
 #include <linux/init.h>
 #include <linux/mtd/compatmac.h>
 #include <linux/proc_fs.h>
+#include <linux/backing-dev.h>
 
 #include <linux/mtd/mtd.h>
-#include "internal.h"
 
 #include "mtdcore.h"
+/*
+ * backing device capabilities for non-mappable devices (such as NAND flash)
+ * - permits private mappings, copies are taken of the data
+ */
+struct backing_dev_info mtd_bdi_unmappable = {
+	.capabilities	= BDI_CAP_MAP_COPY,
+};
+
+/*
+ * backing device capabilities for R/O mappable devices (such as ROM)
+ * - permits private mappings, copies are taken of the data
+ * - permits non-writable shared mappings
+ */
+struct backing_dev_info mtd_bdi_ro_mappable = {
+	.capabilities	= (BDI_CAP_MAP_COPY | BDI_CAP_MAP_DIRECT |
+			   BDI_CAP_EXEC_MAP | BDI_CAP_READ_MAP),
+};
+
+/*
+ * backing device capabilities for writable mappable devices (such as RAM)
+ * - permits private mappings, copies are taken of the data
+ * - permits non-writable shared mappings
+ */
+struct backing_dev_info mtd_bdi_rw_mappable = {
+	.capabilities	= (BDI_CAP_MAP_COPY | BDI_CAP_MAP_DIRECT |
+			   BDI_CAP_EXEC_MAP | BDI_CAP_READ_MAP |
+			   BDI_CAP_WRITE_MAP),
+};
 
 static int mtd_cls_suspend(struct device *dev, pm_message_t state);
 static int mtd_cls_resume(struct device *dev);

commit 5a0e3ad6af8660be21ca98a971cd00f331318c05
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Mar 24 17:04:11 2010 +0900

    include cleanup: Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h
    
    percpu.h is included by sched.h and module.h and thus ends up being
    included when building most .c files.  percpu.h includes slab.h which
    in turn includes gfp.h making everything defined by the two files
    universally available and complicating inclusion dependencies.
    
    percpu.h -> slab.h dependency is about to be removed.  Prepare for
    this change by updating users of gfp and slab facilities include those
    headers directly instead of assuming availability.  As this conversion
    needs to touch large number of source files, the following script is
    used as the basis of conversion.
    
      http://userweb.kernel.org/~tj/misc/slabh-sweep.py
    
    The script does the followings.
    
    * Scan files for gfp and slab usages and update includes such that
      only the necessary includes are there.  ie. if only gfp is used,
      gfp.h, if slab is used, slab.h.
    
    * When the script inserts a new include, it looks at the include
      blocks and try to put the new include such that its order conforms
      to its surrounding.  It's put in the include block which contains
      core kernel includes, in the same order that the rest are ordered -
      alphabetical, Christmas tree, rev-Xmas-tree or at the end if there
      doesn't seem to be any matching order.
    
    * If the script can't find a place to put a new include (mostly
      because the file doesn't have fitting include block), it prints out
      an error message indicating which .h file needs to be added to the
      file.
    
    The conversion was done in the following steps.
    
    1. The initial automatic conversion of all .c files updated slightly
       over 4000 files, deleting around 700 includes and adding ~480 gfp.h
       and ~3000 slab.h inclusions.  The script emitted errors for ~400
       files.
    
    2. Each error was manually checked.  Some didn't need the inclusion,
       some needed manual addition while adding it to implementation .h or
       embedding .c file was more appropriate for others.  This step added
       inclusions to around 150 files.
    
    3. The script was run again and the output was compared to the edits
       from #2 to make sure no file was left behind.
    
    4. Several build tests were done and a couple of problems were fixed.
       e.g. lib/decompress_*.c used malloc/free() wrappers around slab
       APIs requiring slab.h to be added manually.
    
    5. The script was run on all .h files but without automatically
       editing them as sprinkling gfp.h and slab.h inclusions around .h
       files could easily lead to inclusion dependency hell.  Most gfp.h
       inclusion directives were ignored as stuff from gfp.h was usually
       wildly available and often used in preprocessor macros.  Each
       slab.h inclusion directive was examined and added manually as
       necessary.
    
    6. percpu.h was updated not to include slab.h.
    
    7. Build test were done on the following configurations and failures
       were fixed.  CONFIG_GCOV_KERNEL was turned off for all tests (as my
       distributed build env didn't work with gcov compiles) and a few
       more options had to be turned off depending on archs to make things
       build (like ipr on powerpc/64 which failed due to missing writeq).
    
       * x86 and x86_64 UP and SMP allmodconfig and a custom test config.
       * powerpc and powerpc64 SMP allmodconfig
       * sparc and sparc64 SMP allmodconfig
       * ia64 SMP allmodconfig
       * s390 SMP allmodconfig
       * alpha SMP allmodconfig
       * um on x86_64 SMP allmodconfig
    
    8. percpu.h modifications were reverted so that it could be applied as
       a separate patch and serve as bisection point.
    
    Given the fact that I had only a couple of failures from tests on step
    6, I'm fairly confident about the coverage of this conversion patch.
    If there is a breakage, it's likely to be something in one of the arch
    headers which should be easily discoverable easily on most builds of
    the specific arch.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Guess-its-ok-by: Christoph Lameter <cl@linux-foundation.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Lee Schermerhorn <Lee.Schermerhorn@hp.com>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index c356c0a30c3e..5b38b17d2229 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -7,7 +7,6 @@
 #include <linux/module.h>
 #include <linux/kernel.h>
 #include <linux/ptrace.h>
-#include <linux/slab.h>
 #include <linux/string.h>
 #include <linux/timer.h>
 #include <linux/major.h>

commit 75c0b84d41c6f08c0cb083464907005683ef2920
Author: Maxim Levitsky <maximlevitsky@gmail.com>
Date:   Mon Feb 22 20:39:32 2010 +0200

    mtd: call the remove notifiers before assuming it is in use
    
    Now that mtd block common layer is prepared for proper hotplug support,
    enable it here
    
    Now all users of the mtd device have a chance to put the mtd device
    when they are notified to do so, and they have to do so to make hotplug work.
    
    [dwmw2: There's more work to be done to fix hotplug in the general case, but
            this is a reasonable start]
    
    Signed-off-by: Maxim Levitsky <maximlevitsky@gmail.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index 67669a76eaf5..70a78587c3c0 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -350,31 +350,34 @@ int add_mtd_device(struct mtd_info *mtd)
 int del_mtd_device (struct mtd_info *mtd)
 {
 	int ret;
+	struct mtd_notifier *not;
 
 	mutex_lock(&mtd_table_mutex);
 
 	if (idr_find(&mtd_idr, mtd->index) != mtd) {
 		ret = -ENODEV;
-	} else if (mtd->usecount) {
+		goto out_error;
+	}
+
+	/* No need to get a refcount on the module containing
+		the notifier, since we hold the mtd_table_mutex */
+	list_for_each_entry(not, &mtd_notifiers, list)
+		not->remove(mtd);
+
+	if (mtd->usecount) {
 		printk(KERN_NOTICE "Removing MTD device #%d (%s) with use count %d\n",
 		       mtd->index, mtd->name, mtd->usecount);
 		ret = -EBUSY;
 	} else {
-		struct mtd_notifier *not;
-
 		device_unregister(&mtd->dev);
 
-		/* No need to get a refcount on the module containing
-		   the notifier, since we hold the mtd_table_mutex */
-		list_for_each_entry(not, &mtd_notifiers, list)
-			not->remove(mtd);
-
 		idr_remove(&mtd_idr, mtd->index);
 
 		module_put(THIS_MODULE);
 		ret = 0;
 	}
 
+out_error:
 	mutex_unlock(&mtd_table_mutex);
 	return ret;
 }

commit 3bd456576f22acd55fb6c3d3d4261131821f5a3b
Author: Maxim Levitsky <maximlevitsky@gmail.com>
Date:   Mon Feb 22 20:39:28 2010 +0200

    mtd: create unlocked versions of {get,put}_mtd_device
    
    Use these only if you know that you already hold mtd_table_mutex
    
    Signed-off-by: Maxim Levitsky <maximlevitsky@gmail.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index b3b98d1fffc3..67669a76eaf5 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -463,27 +463,38 @@ struct mtd_info *get_mtd_device(struct mtd_info *mtd, int num)
 			ret = NULL;
 	}
 
-	if (!ret)
-		goto out_unlock;
-
-	if (!try_module_get(ret->owner))
-		goto out_unlock;
-
-	if (ret->get_device) {
-		err = ret->get_device(ret);
-		if (err)
-			goto out_put;
+	if (!ret) {
+		ret = ERR_PTR(err);
+		goto out;
 	}
 
-	ret->usecount++;
+	err = __get_mtd_device(ret);
+	if (err)
+		ret = ERR_PTR(err);
+out:
 	mutex_unlock(&mtd_table_mutex);
 	return ret;
+}
 
-out_put:
-	module_put(ret->owner);
-out_unlock:
-	mutex_unlock(&mtd_table_mutex);
-	return ERR_PTR(err);
+
+int __get_mtd_device(struct mtd_info *mtd)
+{
+	int err;
+
+	if (!try_module_get(mtd->owner))
+		return -ENODEV;
+
+	if (mtd->get_device) {
+
+		err = mtd->get_device(mtd);
+
+		if (err) {
+			module_put(mtd->owner);
+			return err;
+		}
+	}
+	mtd->usecount++;
+	return 0;
 }
 
 /**
@@ -534,14 +545,19 @@ struct mtd_info *get_mtd_device_nm(const char *name)
 
 void put_mtd_device(struct mtd_info *mtd)
 {
-	int c;
-
 	mutex_lock(&mtd_table_mutex);
-	c = --mtd->usecount;
+	__put_mtd_device(mtd);
+	mutex_unlock(&mtd_table_mutex);
+
+}
+
+void __put_mtd_device(struct mtd_info *mtd)
+{
+	--mtd->usecount;
+	BUG_ON(mtd->usecount < 0);
+
 	if (mtd->put_device)
 		mtd->put_device(mtd);
-	mutex_unlock(&mtd_table_mutex);
-	BUG_ON(c < 0);
 
 	module_put(mtd->owner);
 }
@@ -579,7 +595,9 @@ EXPORT_SYMBOL_GPL(add_mtd_device);
 EXPORT_SYMBOL_GPL(del_mtd_device);
 EXPORT_SYMBOL_GPL(get_mtd_device);
 EXPORT_SYMBOL_GPL(get_mtd_device_nm);
+EXPORT_SYMBOL_GPL(__get_mtd_device);
 EXPORT_SYMBOL_GPL(put_mtd_device);
+EXPORT_SYMBOL_GPL(__put_mtd_device);
 EXPORT_SYMBOL_GPL(register_mtd_user);
 EXPORT_SYMBOL_GPL(unregister_mtd_user);
 EXPORT_SYMBOL_GPL(default_mtd_writev);

commit b520e412faaaad35641aeedd6059179f9f1b393c
Author: Ben Hutchings <bhutchings@solarflare.com>
Date:   Fri Jan 29 20:59:42 2010 +0000

    mtd: Replace static array of devices with an idr structure
    
    Signed-off-by: Ben Hutchings <bhutchings@solarflare.com>
    Signed-off-by: Artem Bityutskiy <Artem.Bityutskiy@nokia.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index 402d41723c3f..b3b98d1fffc3 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -17,6 +17,7 @@
 #include <linux/init.h>
 #include <linux/mtd/compatmac.h>
 #include <linux/proc_fs.h>
+#include <linux/idr.h>
 
 #include <linux/mtd/mtd.h>
 #include "internal.h"
@@ -33,13 +34,18 @@ static struct class mtd_class = {
 	.resume = mtd_cls_resume,
 };
 
+static DEFINE_IDR(mtd_idr);
+
 /* These are exported solely for the purpose of mtd_blkdevs.c. You
    should not use them for _anything_ else */
 DEFINE_MUTEX(mtd_table_mutex);
-struct mtd_info *mtd_table[MAX_MTD_DEVICES];
-
 EXPORT_SYMBOL_GPL(mtd_table_mutex);
-EXPORT_SYMBOL_GPL(mtd_table);
+
+struct mtd_info *__mtd_next_device(int i)
+{
+	return idr_get_next(&mtd_idr, &i);
+}
+EXPORT_SYMBOL_GPL(__mtd_next_device);
 
 static LIST_HEAD(mtd_notifiers);
 
@@ -235,13 +241,13 @@ static struct device_type mtd_devtype = {
  *	Add a device to the list of MTD devices present in the system, and
  *	notify each currently active MTD 'user' of its arrival. Returns
  *	zero on success or 1 on failure, which currently will only happen
- *	if the number of present devices exceeds MAX_MTD_DEVICES (i.e. 16)
- *	or there's a sysfs error.
+ *	if there is insufficient memory or a sysfs error.
  */
 
 int add_mtd_device(struct mtd_info *mtd)
 {
-	int i;
+	struct mtd_notifier *not;
+	int i, error;
 
 	if (!mtd->backing_dev_info) {
 		switch (mtd->type) {
@@ -260,70 +266,73 @@ int add_mtd_device(struct mtd_info *mtd)
 	BUG_ON(mtd->writesize == 0);
 	mutex_lock(&mtd_table_mutex);
 
-	for (i=0; i < MAX_MTD_DEVICES; i++)
-		if (!mtd_table[i]) {
-			struct mtd_notifier *not;
-
-			mtd_table[i] = mtd;
-			mtd->index = i;
-			mtd->usecount = 0;
-
-			if (is_power_of_2(mtd->erasesize))
-				mtd->erasesize_shift = ffs(mtd->erasesize) - 1;
-			else
-				mtd->erasesize_shift = 0;
-
-			if (is_power_of_2(mtd->writesize))
-				mtd->writesize_shift = ffs(mtd->writesize) - 1;
-			else
-				mtd->writesize_shift = 0;
-
-			mtd->erasesize_mask = (1 << mtd->erasesize_shift) - 1;
-			mtd->writesize_mask = (1 << mtd->writesize_shift) - 1;
-
-			/* Some chips always power up locked. Unlock them now */
-			if ((mtd->flags & MTD_WRITEABLE)
-			    && (mtd->flags & MTD_POWERUP_LOCK) && mtd->unlock) {
-				if (mtd->unlock(mtd, 0, mtd->size))
-					printk(KERN_WARNING
-					       "%s: unlock failed, "
-					       "writes may not work\n",
-					       mtd->name);
-			}
+	do {
+		if (!idr_pre_get(&mtd_idr, GFP_KERNEL))
+			goto fail_locked;
+		error = idr_get_new(&mtd_idr, mtd, &i);
+	} while (error == -EAGAIN);
 
-			/* Caller should have set dev.parent to match the
-			 * physical device.
-			 */
-			mtd->dev.type = &mtd_devtype;
-			mtd->dev.class = &mtd_class;
-			mtd->dev.devt = MTD_DEVT(i);
-			dev_set_name(&mtd->dev, "mtd%d", i);
-			dev_set_drvdata(&mtd->dev, mtd);
-			if (device_register(&mtd->dev) != 0) {
-				mtd_table[i] = NULL;
-				break;
-			}
+	if (error)
+		goto fail_locked;
 
-			if (MTD_DEVT(i))
-				device_create(&mtd_class, mtd->dev.parent,
-						MTD_DEVT(i) + 1,
-						NULL, "mtd%dro", i);
-
-			DEBUG(0, "mtd: Giving out device %d to %s\n",i, mtd->name);
-			/* No need to get a refcount on the module containing
-			   the notifier, since we hold the mtd_table_mutex */
-			list_for_each_entry(not, &mtd_notifiers, list)
-				not->add(mtd);
-
-			mutex_unlock(&mtd_table_mutex);
-			/* We _know_ we aren't being removed, because
-			   our caller is still holding us here. So none
-			   of this try_ nonsense, and no bitching about it
-			   either. :) */
-			__module_get(THIS_MODULE);
-			return 0;
-		}
+	mtd->index = i;
+	mtd->usecount = 0;
+
+	if (is_power_of_2(mtd->erasesize))
+		mtd->erasesize_shift = ffs(mtd->erasesize) - 1;
+	else
+		mtd->erasesize_shift = 0;
+
+	if (is_power_of_2(mtd->writesize))
+		mtd->writesize_shift = ffs(mtd->writesize) - 1;
+	else
+		mtd->writesize_shift = 0;
+
+	mtd->erasesize_mask = (1 << mtd->erasesize_shift) - 1;
+	mtd->writesize_mask = (1 << mtd->writesize_shift) - 1;
+
+	/* Some chips always power up locked. Unlock them now */
+	if ((mtd->flags & MTD_WRITEABLE)
+	    && (mtd->flags & MTD_POWERUP_LOCK) && mtd->unlock) {
+		if (mtd->unlock(mtd, 0, mtd->size))
+			printk(KERN_WARNING
+			       "%s: unlock failed, writes may not work\n",
+			       mtd->name);
+	}
+
+	/* Caller should have set dev.parent to match the
+	 * physical device.
+	 */
+	mtd->dev.type = &mtd_devtype;
+	mtd->dev.class = &mtd_class;
+	mtd->dev.devt = MTD_DEVT(i);
+	dev_set_name(&mtd->dev, "mtd%d", i);
+	dev_set_drvdata(&mtd->dev, mtd);
+	if (device_register(&mtd->dev) != 0)
+		goto fail_added;
+
+	if (MTD_DEVT(i))
+		device_create(&mtd_class, mtd->dev.parent,
+			      MTD_DEVT(i) + 1,
+			      NULL, "mtd%dro", i);
+
+	DEBUG(0, "mtd: Giving out device %d to %s\n", i, mtd->name);
+	/* No need to get a refcount on the module containing
+	   the notifier, since we hold the mtd_table_mutex */
+	list_for_each_entry(not, &mtd_notifiers, list)
+		not->add(mtd);
+
+	mutex_unlock(&mtd_table_mutex);
+	/* We _know_ we aren't being removed, because
+	   our caller is still holding us here. So none
+	   of this try_ nonsense, and no bitching about it
+	   either. :) */
+	__module_get(THIS_MODULE);
+	return 0;
 
+fail_added:
+	idr_remove(&mtd_idr, i);
+fail_locked:
 	mutex_unlock(&mtd_table_mutex);
 	return 1;
 }
@@ -344,7 +353,7 @@ int del_mtd_device (struct mtd_info *mtd)
 
 	mutex_lock(&mtd_table_mutex);
 
-	if (mtd_table[mtd->index] != mtd) {
+	if (idr_find(&mtd_idr, mtd->index) != mtd) {
 		ret = -ENODEV;
 	} else if (mtd->usecount) {
 		printk(KERN_NOTICE "Removing MTD device #%d (%s) with use count %d\n",
@@ -360,7 +369,7 @@ int del_mtd_device (struct mtd_info *mtd)
 		list_for_each_entry(not, &mtd_notifiers, list)
 			not->remove(mtd);
 
-		mtd_table[mtd->index] = NULL;
+		idr_remove(&mtd_idr, mtd->index);
 
 		module_put(THIS_MODULE);
 		ret = 0;
@@ -448,8 +457,8 @@ struct mtd_info *get_mtd_device(struct mtd_info *mtd, int num)
 				break;
 			}
 		}
-	} else if (num >= 0 && num < MAX_MTD_DEVICES) {
-		ret = mtd_table[num];
+	} else if (num >= 0) {
+		ret = idr_find(&mtd_idr, num);
 		if (mtd && mtd != ret)
 			ret = NULL;
 	}

commit f1332ba2f23800bb5d52457ac150c568dfb1f3bf
Author: Ben Hutchings <bhutchings@solarflare.com>
Date:   Fri Jan 29 20:57:11 2010 +0000

    mtd: Introduce and use iteration macro for reading the MTD device table
    
    Signed-off-by: Ben Hutchings <bhutchings@solarflare.com>
    Signed-off-by: Artem Bityutskiy <Artem.Bityutskiy@nokia.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index c356c0a30c3e..402d41723c3f 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -381,7 +381,7 @@ int del_mtd_device (struct mtd_info *mtd)
 
 void register_mtd_user (struct mtd_notifier *new)
 {
-	int i;
+	struct mtd_info *mtd;
 
 	mutex_lock(&mtd_table_mutex);
 
@@ -389,9 +389,8 @@ void register_mtd_user (struct mtd_notifier *new)
 
  	__module_get(THIS_MODULE);
 
-	for (i=0; i< MAX_MTD_DEVICES; i++)
-		if (mtd_table[i])
-			new->add(mtd_table[i]);
+	mtd_for_each_device(mtd)
+		new->add(mtd);
 
 	mutex_unlock(&mtd_table_mutex);
 }
@@ -408,15 +407,14 @@ void register_mtd_user (struct mtd_notifier *new)
 
 int unregister_mtd_user (struct mtd_notifier *old)
 {
-	int i;
+	struct mtd_info *mtd;
 
 	mutex_lock(&mtd_table_mutex);
 
 	module_put(THIS_MODULE);
 
-	for (i=0; i< MAX_MTD_DEVICES; i++)
-		if (mtd_table[i])
-			old->remove(mtd_table[i]);
+	mtd_for_each_device(mtd)
+		old->remove(mtd);
 
 	list_del(&old->list);
 	mutex_unlock(&mtd_table_mutex);
@@ -438,15 +436,18 @@ int unregister_mtd_user (struct mtd_notifier *old)
 
 struct mtd_info *get_mtd_device(struct mtd_info *mtd, int num)
 {
-	struct mtd_info *ret = NULL;
-	int i, err = -ENODEV;
+	struct mtd_info *ret = NULL, *other;
+	int err = -ENODEV;
 
 	mutex_lock(&mtd_table_mutex);
 
 	if (num == -1) {
-		for (i=0; i< MAX_MTD_DEVICES; i++)
-			if (mtd_table[i] == mtd)
-				ret = mtd_table[i];
+		mtd_for_each_device(other) {
+			if (other == mtd) {
+				ret = mtd;
+				break;
+			}
+		}
 	} else if (num >= 0 && num < MAX_MTD_DEVICES) {
 		ret = mtd_table[num];
 		if (mtd && mtd != ret)
@@ -487,14 +488,14 @@ struct mtd_info *get_mtd_device(struct mtd_info *mtd, int num)
 
 struct mtd_info *get_mtd_device_nm(const char *name)
 {
-	int i, err = -ENODEV;
-	struct mtd_info *mtd = NULL;
+	int err = -ENODEV;
+	struct mtd_info *mtd = NULL, *other;
 
 	mutex_lock(&mtd_table_mutex);
 
-	for (i = 0; i < MAX_MTD_DEVICES; i++) {
-		if (mtd_table[i] && !strcmp(name, mtd_table[i]->name)) {
-			mtd = mtd_table[i];
+	mtd_for_each_device(other) {
+		if (!strcmp(name, other->name)) {
+			mtd = other;
 			break;
 		}
 	}
@@ -581,14 +582,9 @@ EXPORT_SYMBOL_GPL(default_mtd_writev);
 
 static struct proc_dir_entry *proc_mtd;
 
-static inline int mtd_proc_info (char *buf, int i)
+static inline int mtd_proc_info(char *buf, struct mtd_info *this)
 {
-	struct mtd_info *this = mtd_table[i];
-
-	if (!this)
-		return 0;
-
-	return sprintf(buf, "mtd%d: %8.8llx %8.8x \"%s\"\n", i,
+	return sprintf(buf, "mtd%d: %8.8llx %8.8x \"%s\"\n", this->index,
 		       (unsigned long long)this->size,
 		       this->erasesize, this->name);
 }
@@ -596,15 +592,15 @@ static inline int mtd_proc_info (char *buf, int i)
 static int mtd_read_proc (char *page, char **start, off_t off, int count,
 			  int *eof, void *data_unused)
 {
-	int len, l, i;
+	struct mtd_info *mtd;
+	int len, l;
         off_t   begin = 0;
 
 	mutex_lock(&mtd_table_mutex);
 
 	len = sprintf(page, "dev:    size   erasesize  name\n");
-        for (i=0; i< MAX_MTD_DEVICES; i++) {
-
-                l = mtd_proc_info(page + len, i);
+	mtd_for_each_device(mtd) {
+		l = mtd_proc_info(page + len, mtd);
                 len += l;
                 if (len+begin > off+count)
                         goto done;

commit 35016dd7e92cf0eb5ae2e811445dd52320c348d0
Author: Roel Kluin <roel.kluin@gmail.com>
Date:   Tue Nov 3 20:49:18 2009 +0100

    mtd: ensure index is positive
    
    The index is signed, make sure it is not negative
    when we read the array element.
    
    Signed-off-by: Roel Kluin <roel.kluin@gmail.com>
    Signed-off-by: Artem Bityutskiy <Artem.Bityutskiy@nokia.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index 467a4f177bfb..c356c0a30c3e 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -447,7 +447,7 @@ struct mtd_info *get_mtd_device(struct mtd_info *mtd, int num)
 		for (i=0; i< MAX_MTD_DEVICES; i++)
 			if (mtd_table[i] == mtd)
 				ret = mtd_table[i];
-	} else if (num < MAX_MTD_DEVICES) {
+	} else if (num >= 0 && num < MAX_MTD_DEVICES) {
 		ret = mtd_table[num];
 		if (mtd && mtd != ret)
 			ret = NULL;

commit 6469f540ea37d53db089c8fea9c0c77a3d9353d4
Merge: 304e6d5fe294 78f28b7c5553
Author: David Woodhouse <David.Woodhouse@intel.com>
Date:   Sun Sep 20 05:55:36 2009 -0700

    Merge branch 'master' of git://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux-2.6
    
    Conflicts:
            drivers/mtd/mtdcore.c
    
    Merged in order that I can apply the Nomadik nand/onenand support patches.

commit a4dbd6740df0872cdf0a86841f75beec8381964d
Author: David Brownell <dbrownell@users.sourceforge.net>
Date:   Wed Jun 24 10:06:31 2009 -0700

    driver model: constify attribute groups
    
    Let attribute group vectors be declared "const".  We'd
    like to let most attribute metadata live in read-only
    sections... this is a start.
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index 00ebf7af7467..69007a6eff50 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -217,7 +217,7 @@ struct attribute_group mtd_group = {
 	.attrs		= mtd_attrs,
 };
 
-struct attribute_group *mtd_groups[] = {
+const struct attribute_group *mtd_groups[] = {
 	&mtd_group,
 	NULL,
 };

commit fca910883324d437a24d447b08f524fa19261a94
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Thu Aug 6 16:05:32 2009 -0700

    mtd: make few symbols static
    
    Make mtd_group and mtd_groups static since they are only used in this
    file.
    
    [Amended by Artem Bityutskiy]
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Artem Bityutskiy <Artem.Bityutskiy@nokia.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index 00ebf7af7467..3f559c0f1879 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -213,11 +213,11 @@ static struct attribute *mtd_attrs[] = {
 	NULL,
 };
 
-struct attribute_group mtd_group = {
+static struct attribute_group mtd_group = {
 	.attrs		= mtd_attrs,
 };
 
-struct attribute_group *mtd_groups[] = {
+static struct attribute_group *mtd_groups[] = {
 	&mtd_group,
 	NULL,
 };

commit 6afc4fdb3e94ba60cd566cb878b60c6c01979277
Author: Saeed Bishara <saeed@marvell.com>
Date:   Tue Jul 28 04:56:43 2009 -0700

    mtd: fix the conversion from dev to mtd_info
    
    The patch fixes a bug when converting dev to mtd_info by using the
    drvdata of the dev, the previous code used
    container_of(dev, struct mtd_info, dev), but won't work for the mtdXro
    devices as they created without being contained inside mtd_info structure.
    
    Signed-off-by: Saeed Bishara <saeed@marvell.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index fac54a3fa3f1..00ebf7af7467 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -65,8 +65,8 @@ static void mtd_release(struct device *dev)
 static int mtd_cls_suspend(struct device *dev, pm_message_t state)
 {
 	struct mtd_info *mtd = dev_to_mtd(dev);
-	
-	if (mtd->suspend)
+
+	if (mtd && mtd->suspend)
 		return mtd->suspend(mtd);
 	else
 		return 0;
@@ -76,7 +76,7 @@ static int mtd_cls_resume(struct device *dev)
 {
 	struct mtd_info *mtd = dev_to_mtd(dev);
 	
-	if (mtd->resume)
+	if (mtd && mtd->resume)
 		mtd->resume(mtd);
 	return 0;
 }
@@ -298,6 +298,7 @@ int add_mtd_device(struct mtd_info *mtd)
 			mtd->dev.class = &mtd_class;
 			mtd->dev.devt = MTD_DEVT(i);
 			dev_set_name(&mtd->dev, "mtd%d", i);
+			dev_set_drvdata(&mtd->dev, mtd);
 			if (device_register(&mtd->dev) != 0) {
 				mtd_table[i] = NULL;
 				break;

commit 15bce40cb3133bcc07d548013df97e4653d363c1
Author: David Woodhouse <David.Woodhouse@intel.com>
Date:   Sun Apr 5 07:40:58 2009 -0700

    [MTD] Restore suspend/resume support for mtd devices
    
    This is intended to suspend/resume the _chip_, while we leave board
    drivers to handle their own suspend/resume for the controller.
    
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index bccb4b1ffc46..fac54a3fa3f1 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -23,8 +23,15 @@
 
 #include "mtdcore.h"
 
-
-static struct class *mtd_class;
+static int mtd_cls_suspend(struct device *dev, pm_message_t state);
+static int mtd_cls_resume(struct device *dev);
+
+static struct class mtd_class = {
+	.name = "mtd",
+	.owner = THIS_MODULE,
+	.suspend = mtd_cls_suspend,
+	.resume = mtd_cls_resume,
+};
 
 /* These are exported solely for the purpose of mtd_blkdevs.c. You
    should not use them for _anything_ else */
@@ -52,7 +59,26 @@ static void mtd_release(struct device *dev)
 
 	/* remove /dev/mtdXro node if needed */
 	if (index)
-		device_destroy(mtd_class, index + 1);
+		device_destroy(&mtd_class, index + 1);
+}
+
+static int mtd_cls_suspend(struct device *dev, pm_message_t state)
+{
+	struct mtd_info *mtd = dev_to_mtd(dev);
+	
+	if (mtd->suspend)
+		return mtd->suspend(mtd);
+	else
+		return 0;
+}
+
+static int mtd_cls_resume(struct device *dev)
+{
+	struct mtd_info *mtd = dev_to_mtd(dev);
+	
+	if (mtd->resume)
+		mtd->resume(mtd);
+	return 0;
 }
 
 static ssize_t mtd_type_show(struct device *dev,
@@ -269,7 +295,7 @@ int add_mtd_device(struct mtd_info *mtd)
 			 * physical device.
 			 */
 			mtd->dev.type = &mtd_devtype;
-			mtd->dev.class = mtd_class;
+			mtd->dev.class = &mtd_class;
 			mtd->dev.devt = MTD_DEVT(i);
 			dev_set_name(&mtd->dev, "mtd%d", i);
 			if (device_register(&mtd->dev) != 0) {
@@ -278,7 +304,7 @@ int add_mtd_device(struct mtd_info *mtd)
 			}
 
 			if (MTD_DEVT(i))
-				device_create(mtd_class, mtd->dev.parent,
+				device_create(&mtd_class, mtd->dev.parent,
 						MTD_DEVT(i) + 1,
 						NULL, "mtd%dro", i);
 
@@ -604,11 +630,12 @@ static int mtd_read_proc (char *page, char **start, off_t off, int count,
 
 static int __init init_mtd(void)
 {
-	mtd_class = class_create(THIS_MODULE, "mtd");
+	int ret;
+	ret = class_register(&mtd_class);
 
-	if (IS_ERR(mtd_class)) {
-		pr_err("Error creating mtd class.\n");
-		return PTR_ERR(mtd_class);
+	if (ret) {
+		pr_err("Error registering mtd class: %d\n", ret);
+		return ret;
 	}
 #ifdef CONFIG_PROC_FS
 	if ((proc_mtd = create_proc_entry( "mtd", 0, NULL )))
@@ -623,7 +650,7 @@ static void __exit cleanup_mtd(void)
         if (proc_mtd)
 		remove_proc_entry( "mtd", NULL);
 #endif /* CONFIG_PROC_FS */
-	class_destroy(mtd_class);
+	class_unregister(&mtd_class);
 }
 
 module_init(init_mtd);

commit e7693548950ea5801d5d8b00414aed37033cf972
Author: Artem Bityutskiy <dedekind@infradead.org>
Date:   Sat Apr 18 12:29:42 2009 +0300

    mtd: expose subpage size via sysfs
    
    MTD has got sysfs support in 2.6.30-rc1. But subpage size is not
    exposed there - do this.
    
    UBI utilities badly need this parameter. At the moment there is
    no way to get subpage size - ioctls do not return it. And we
    just got sysfs support, so we can easilly extend it with this
    additional parameter.
    
    This can be merged late in the development cycle because:
    1. sysfs support has been just added - there are no users for
       it so far, even.
    2. UBI utilities really need this parameter, and it is better
       not to delay this.
    
    Signed-off-by: Artem Bityutskiy <Artem.Bityutskiy@nokia.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index 051b4d4ed21f..bccb4b1ffc46 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -132,6 +132,17 @@ static ssize_t mtd_writesize_show(struct device *dev,
 }
 static DEVICE_ATTR(writesize, S_IRUGO, mtd_writesize_show, NULL);
 
+static ssize_t mtd_subpagesize_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct mtd_info *mtd = dev_to_mtd(dev);
+	unsigned int subpagesize = mtd->writesize >> mtd->subpage_sft;
+
+	return snprintf(buf, PAGE_SIZE, "%u\n", subpagesize);
+
+}
+static DEVICE_ATTR(subpagesize, S_IRUGO, mtd_subpagesize_show, NULL);
+
 static ssize_t mtd_oobsize_show(struct device *dev,
 		struct device_attribute *attr, char *buf)
 {
@@ -169,6 +180,7 @@ static struct attribute *mtd_attrs[] = {
 	&dev_attr_size.attr,
 	&dev_attr_erasesize.attr,
 	&dev_attr_writesize.attr,
+	&dev_attr_subpagesize.attr,
 	&dev_attr_oobsize.attr,
 	&dev_attr_numeraseregions.attr,
 	&dev_attr_name.attr,

commit 2fdb11449ca82f4f1907fce4929df4e0bd267c50
Author: Denis V. Lunev <den@openvz.org>
Date:   Sun Apr 12 08:14:46 2009 +0100

    mtd: mtd in mtd_release is unused without CONFIG_MTD_CHAR
    
    drivers/mtd/mtdcore.c: In function 'mtd_release':
    drivers/mtd/mtdcore.c:51: warning: unused variable 'mtd'
    
    [akpm: make it actually build]
    Signed-off-by: Denis V. Lunev <den@openvz.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index fdd6ae859397..051b4d4ed21f 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -48,11 +48,11 @@ static LIST_HEAD(mtd_notifiers);
  */
 static void mtd_release(struct device *dev)
 {
-	struct mtd_info *mtd = dev_to_mtd(dev);
+	dev_t index = MTD_DEVT(dev_to_mtd(dev)->index);
 
 	/* remove /dev/mtdXro node if needed */
-	if (MTD_DEVT(mtd->index))
-		device_destroy(mtd_class, MTD_DEVT(mtd->index) + 1);
+	if (index)
+		device_destroy(mtd_class, index + 1);
 }
 
 static ssize_t mtd_type_show(struct device *dev,

commit 45b09076149f1360e15919ca7e004e8d3810a0f7
Author: Kevin Cernekee <kpc.mtd@gmail.com>
Date:   Sat Apr 4 11:03:04 2009 -0700

    [MTD] sysfs support should not depend on CONFIG_PROC_FS
    
    Move the driver model init code out of the "#ifdef CONFIG_PROC_FS"
    block.
    
    Tested with both values of CONFIG_PROC_FS .  Tested with CONFIG_MTD=m .
    
    Issue was reported here: http://lkml.org/lkml/2009/4/4/107
    
    Signed-off-by: Kevin Cernekee <kpc.mtd@gmail.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index 89c1e5ddc7c2..fdd6ae859397 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -585,6 +585,8 @@ static int mtd_read_proc (char *page, char **start, off_t off, int count,
         return ((count < begin+len-off) ? count : begin+len-off);
 }
 
+#endif /* CONFIG_PROC_FS */
+
 /*====================================================================*/
 /* Init code */
 
@@ -596,24 +598,25 @@ static int __init init_mtd(void)
 		pr_err("Error creating mtd class.\n");
 		return PTR_ERR(mtd_class);
 	}
+#ifdef CONFIG_PROC_FS
 	if ((proc_mtd = create_proc_entry( "mtd", 0, NULL )))
 		proc_mtd->read_proc = mtd_read_proc;
+#endif /* CONFIG_PROC_FS */
 	return 0;
 }
 
 static void __exit cleanup_mtd(void)
 {
+#ifdef CONFIG_PROC_FS
         if (proc_mtd)
 		remove_proc_entry( "mtd", NULL);
+#endif /* CONFIG_PROC_FS */
 	class_destroy(mtd_class);
 }
 
 module_init(init_mtd);
 module_exit(cleanup_mtd);
 
-#endif /* CONFIG_PROC_FS */
-
-
 MODULE_LICENSE("GPL");
 MODULE_AUTHOR("David Woodhouse <dwmw2@infradead.org>");
 MODULE_DESCRIPTION("Core MTD registration and access routines");

commit 694bb7fc19c6b87e106f4c85a2707072e2f111a0
Author: Kevin Cernekee <kpc.mtd@gmail.com>
Date:   Fri Apr 3 13:00:45 2009 -0700

    [MTD] driver model updates (part 2)
    
    1) Add more sysfs attributes: flags, size, erasesize, writesize,
       oobsize, numeraseregions, name
    
    2) Move core_initcall() code into init_mtd().  The original approach
       does not work if CONFIG_MTD=m .
    
    3) Add device_unregister() in del_mtd_device() so that devices get
       removed from sysfs as each driver is unloaded.
    
    Signed-off-by: Kevin Cernekee <kpc.mtd@gmail.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index a88f8bc9a534..89c1e5ddc7c2 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -89,11 +89,89 @@ static ssize_t mtd_type_show(struct device *dev,
 
 	return snprintf(buf, PAGE_SIZE, "%s\n", type);
 }
-static DEVICE_ATTR(mtd_type, S_IRUGO, mtd_type_show, NULL);
+static DEVICE_ATTR(type, S_IRUGO, mtd_type_show, NULL);
+
+static ssize_t mtd_flags_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct mtd_info *mtd = dev_to_mtd(dev);
+
+	return snprintf(buf, PAGE_SIZE, "0x%lx\n", (unsigned long)mtd->flags);
+
+}
+static DEVICE_ATTR(flags, S_IRUGO, mtd_flags_show, NULL);
+
+static ssize_t mtd_size_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct mtd_info *mtd = dev_to_mtd(dev);
+
+	return snprintf(buf, PAGE_SIZE, "%llu\n",
+		(unsigned long long)mtd->size);
+
+}
+static DEVICE_ATTR(size, S_IRUGO, mtd_size_show, NULL);
+
+static ssize_t mtd_erasesize_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct mtd_info *mtd = dev_to_mtd(dev);
+
+	return snprintf(buf, PAGE_SIZE, "%lu\n", (unsigned long)mtd->erasesize);
+
+}
+static DEVICE_ATTR(erasesize, S_IRUGO, mtd_erasesize_show, NULL);
+
+static ssize_t mtd_writesize_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct mtd_info *mtd = dev_to_mtd(dev);
+
+	return snprintf(buf, PAGE_SIZE, "%lu\n", (unsigned long)mtd->writesize);
+
+}
+static DEVICE_ATTR(writesize, S_IRUGO, mtd_writesize_show, NULL);
+
+static ssize_t mtd_oobsize_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct mtd_info *mtd = dev_to_mtd(dev);
+
+	return snprintf(buf, PAGE_SIZE, "%lu\n", (unsigned long)mtd->oobsize);
+
+}
+static DEVICE_ATTR(oobsize, S_IRUGO, mtd_oobsize_show, NULL);
+
+static ssize_t mtd_numeraseregions_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct mtd_info *mtd = dev_to_mtd(dev);
+
+	return snprintf(buf, PAGE_SIZE, "%u\n", mtd->numeraseregions);
+
+}
+static DEVICE_ATTR(numeraseregions, S_IRUGO, mtd_numeraseregions_show,
+	NULL);
+
+static ssize_t mtd_name_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct mtd_info *mtd = dev_to_mtd(dev);
+
+	return snprintf(buf, PAGE_SIZE, "%s\n", mtd->name);
+
+}
+static DEVICE_ATTR(name, S_IRUGO, mtd_name_show, NULL);
 
 static struct attribute *mtd_attrs[] = {
-	&dev_attr_mtd_type.attr,
-	/* FIXME provide a /proc/mtd superset */
+	&dev_attr_type.attr,
+	&dev_attr_flags.attr,
+	&dev_attr_size.attr,
+	&dev_attr_erasesize.attr,
+	&dev_attr_writesize.attr,
+	&dev_attr_oobsize.attr,
+	&dev_attr_numeraseregions.attr,
+	&dev_attr_name.attr,
 	NULL,
 };
 
@@ -236,6 +314,8 @@ int del_mtd_device (struct mtd_info *mtd)
 	} else {
 		struct mtd_notifier *not;
 
+		device_unregister(&mtd->dev);
+
 		/* No need to get a refcount on the module containing
 		   the notifier, since we hold the mtd_table_mutex */
 		list_for_each_entry(not, &mtd_notifiers, list)
@@ -455,24 +535,6 @@ EXPORT_SYMBOL_GPL(register_mtd_user);
 EXPORT_SYMBOL_GPL(unregister_mtd_user);
 EXPORT_SYMBOL_GPL(default_mtd_writev);
 
-static int __init mtd_setup(void)
-{
-	mtd_class = class_create(THIS_MODULE, "mtd");
-
-	if (IS_ERR(mtd_class)) {
-		pr_err("Error creating mtd class.\n");
-		return PTR_ERR(mtd_class);
-	}
-	return 0;
-}
-core_initcall(mtd_setup);
-
-static void __exit mtd_teardown(void)
-{
-	class_destroy(mtd_class);
-}
-__exitcall(mtd_teardown);
-
 #ifdef CONFIG_PROC_FS
 
 /*====================================================================*/
@@ -528,6 +590,12 @@ static int mtd_read_proc (char *page, char **start, off_t off, int count,
 
 static int __init init_mtd(void)
 {
+	mtd_class = class_create(THIS_MODULE, "mtd");
+
+	if (IS_ERR(mtd_class)) {
+		pr_err("Error creating mtd class.\n");
+		return PTR_ERR(mtd_class);
+	}
 	if ((proc_mtd = create_proc_entry( "mtd", 0, NULL )))
 		proc_mtd->read_proc = mtd_read_proc;
 	return 0;
@@ -537,6 +605,7 @@ static void __exit cleanup_mtd(void)
 {
         if (proc_mtd)
 		remove_proc_entry( "mtd", NULL);
+	class_destroy(mtd_class);
 }
 
 module_init(init_mtd);

commit 1f24b5a8ecbb2a3c7080f418974d40e3ffedb221
Author: David Brownell <dbrownell@users.sourceforge.net>
Date:   Thu Mar 26 00:42:41 2009 -0700

    [MTD] driver model updates
    
    Update driver model support in the MTD framework, so it fits
    better into the current udev-based hotplug framework:
    
     - Each mtd_info now has a device node.  MTD drivers should set
       the dev.parent field to point to the physical device, before
       setting up partitions or otherwise declaring MTDs.
    
     - Those device nodes always map to /sys/class/mtdX device nodes,
       which no longer depend on MTD_CHARDEV.
    
     - Those mtdX sysfs nodes have a "starter set" of attributes;
       it's not yet sufficient to replace /proc/mtd.
    
     - Enabling MTD_CHARDEV provides /sys/class/mtdXro/ nodes and the
       /sys/class/mtd*/dev attributes (for udev, mdev, etc).
    
     - Include a MODULE_ALIAS_CHARDEV_MAJOR macro.  It'll work with
       udev creating the /dev/mtd* nodes, not just a static rootfs.
    
    So the sysfs structure is pretty much what you'd expect, except
    that readonly chardev nodes are a bit quirky.
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index 65a7f3703881..a88f8bc9a534 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -23,6 +23,9 @@
 
 #include "mtdcore.h"
 
+
+static struct class *mtd_class;
+
 /* These are exported solely for the purpose of mtd_blkdevs.c. You
    should not use them for _anything_ else */
 DEFINE_MUTEX(mtd_table_mutex);
@@ -33,6 +36,82 @@ EXPORT_SYMBOL_GPL(mtd_table);
 
 static LIST_HEAD(mtd_notifiers);
 
+
+#if defined(CONFIG_MTD_CHAR) || defined(CONFIG_MTD_CHAR_MODULE)
+#define MTD_DEVT(index) MKDEV(MTD_CHAR_MAJOR, (index)*2)
+#else
+#define MTD_DEVT(index) 0
+#endif
+
+/* REVISIT once MTD uses the driver model better, whoever allocates
+ * the mtd_info will probably want to use the release() hook...
+ */
+static void mtd_release(struct device *dev)
+{
+	struct mtd_info *mtd = dev_to_mtd(dev);
+
+	/* remove /dev/mtdXro node if needed */
+	if (MTD_DEVT(mtd->index))
+		device_destroy(mtd_class, MTD_DEVT(mtd->index) + 1);
+}
+
+static ssize_t mtd_type_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct mtd_info *mtd = dev_to_mtd(dev);
+	char *type;
+
+	switch (mtd->type) {
+	case MTD_ABSENT:
+		type = "absent";
+		break;
+	case MTD_RAM:
+		type = "ram";
+		break;
+	case MTD_ROM:
+		type = "rom";
+		break;
+	case MTD_NORFLASH:
+		type = "nor";
+		break;
+	case MTD_NANDFLASH:
+		type = "nand";
+		break;
+	case MTD_DATAFLASH:
+		type = "dataflash";
+		break;
+	case MTD_UBIVOLUME:
+		type = "ubi";
+		break;
+	default:
+		type = "unknown";
+	}
+
+	return snprintf(buf, PAGE_SIZE, "%s\n", type);
+}
+static DEVICE_ATTR(mtd_type, S_IRUGO, mtd_type_show, NULL);
+
+static struct attribute *mtd_attrs[] = {
+	&dev_attr_mtd_type.attr,
+	/* FIXME provide a /proc/mtd superset */
+	NULL,
+};
+
+struct attribute_group mtd_group = {
+	.attrs		= mtd_attrs,
+};
+
+struct attribute_group *mtd_groups[] = {
+	&mtd_group,
+	NULL,
+};
+
+static struct device_type mtd_devtype = {
+	.name		= "mtd",
+	.groups		= mtd_groups,
+	.release	= mtd_release,
+};
+
 /**
  *	add_mtd_device - register an MTD device
  *	@mtd: pointer to new MTD device info structure
@@ -41,6 +120,7 @@ static LIST_HEAD(mtd_notifiers);
  *	notify each currently active MTD 'user' of its arrival. Returns
  *	zero on success or 1 on failure, which currently will only happen
  *	if the number of present devices exceeds MAX_MTD_DEVICES (i.e. 16)
+ *	or there's a sysfs error.
  */
 
 int add_mtd_device(struct mtd_info *mtd)
@@ -95,6 +175,23 @@ int add_mtd_device(struct mtd_info *mtd)
 					       mtd->name);
 			}
 
+			/* Caller should have set dev.parent to match the
+			 * physical device.
+			 */
+			mtd->dev.type = &mtd_devtype;
+			mtd->dev.class = mtd_class;
+			mtd->dev.devt = MTD_DEVT(i);
+			dev_set_name(&mtd->dev, "mtd%d", i);
+			if (device_register(&mtd->dev) != 0) {
+				mtd_table[i] = NULL;
+				break;
+			}
+
+			if (MTD_DEVT(i))
+				device_create(mtd_class, mtd->dev.parent,
+						MTD_DEVT(i) + 1,
+						NULL, "mtd%dro", i);
+
 			DEBUG(0, "mtd: Giving out device %d to %s\n",i, mtd->name);
 			/* No need to get a refcount on the module containing
 			   the notifier, since we hold the mtd_table_mutex */
@@ -358,6 +455,24 @@ EXPORT_SYMBOL_GPL(register_mtd_user);
 EXPORT_SYMBOL_GPL(unregister_mtd_user);
 EXPORT_SYMBOL_GPL(default_mtd_writev);
 
+static int __init mtd_setup(void)
+{
+	mtd_class = class_create(THIS_MODULE, "mtd");
+
+	if (IS_ERR(mtd_class)) {
+		pr_err("Error creating mtd class.\n");
+		return PTR_ERR(mtd_class);
+	}
+	return 0;
+}
+core_initcall(mtd_setup);
+
+static void __exit mtd_teardown(void)
+{
+	class_destroy(mtd_class);
+}
+__exitcall(mtd_teardown);
+
 #ifdef CONFIG_PROC_FS
 
 /*====================================================================*/

commit 402d326519c1a4859c527702383f4e60f606ef52
Author: David Howells <dhowells@redhat.com>
Date:   Thu Feb 12 10:40:00 2009 +0000

    NOMMU: Present backing device capabilities for MTD chardevs
    
    Present backing device capabilities for MTD character device files to allow
    NOMMU mmap to do direct mapping where possible.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Tested-by: Bernd Schmidt <bernd.schmidt@analog.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index 76fe0a1e7a5e..65a7f3703881 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -19,6 +19,7 @@
 #include <linux/proc_fs.h>
 
 #include <linux/mtd/mtd.h>
+#include "internal.h"
 
 #include "mtdcore.h"
 
@@ -46,6 +47,20 @@ int add_mtd_device(struct mtd_info *mtd)
 {
 	int i;
 
+	if (!mtd->backing_dev_info) {
+		switch (mtd->type) {
+		case MTD_RAM:
+			mtd->backing_dev_info = &mtd_bdi_rw_mappable;
+			break;
+		case MTD_ROM:
+			mtd->backing_dev_info = &mtd_bdi_ro_mappable;
+			break;
+		default:
+			mtd->backing_dev_info = &mtd_bdi_unmappable;
+			break;
+		}
+	}
+
 	BUG_ON(mtd->writesize == 0);
 	mutex_lock(&mtd_table_mutex);
 

commit 69423d99fc182a81f3c5db3eb5c140acc6fc64be
Author: Adrian Hunter <ext-adrian.hunter@nokia.com>
Date:   Wed Dec 10 13:37:21 2008 +0000

    [MTD] update internal API to support 64-bit device size
    
    MTD internal API presently uses 32-bit values to represent
    device size.  This patch updates them to 64-bits but leaves
    the external API unchanged.  Extending the external API
    is a separate issue for several reasons.  First, no one
    needs it at the moment.  Secondly, whether the implementation
    is done with IOCTLs, sysfs or both is still debated.  Thirdly
    external API changes require the internal API to be accepted
    first.
    
    Note that although the MTD API will be able to support 64-bit
    device sizes, existing drivers do not and are not required
    to do so, although NAND base has been updated.
    
    In general, changing from 32-bit to 64-bit values cause little
    or no changes to the majority of the code with the following
    exceptions:
            - printk message formats
            - division and modulus of 64-bit values
            - NAND base support
            - 32-bit local variables used by mtdpart and mtdconcat
            - naughtily assuming one structure maps to another
            in MEMERASE ioctl
    
    Signed-off-by: Adrian Hunter <ext-adrian.hunter@nokia.com>
    Signed-off-by: Artem Bityutskiy <Artem.Bityutskiy@nokia.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index a9d246949820..76fe0a1e7a5e 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -57,6 +57,19 @@ int add_mtd_device(struct mtd_info *mtd)
 			mtd->index = i;
 			mtd->usecount = 0;
 
+			if (is_power_of_2(mtd->erasesize))
+				mtd->erasesize_shift = ffs(mtd->erasesize) - 1;
+			else
+				mtd->erasesize_shift = 0;
+
+			if (is_power_of_2(mtd->writesize))
+				mtd->writesize_shift = ffs(mtd->writesize) - 1;
+			else
+				mtd->writesize_shift = 0;
+
+			mtd->erasesize_mask = (1 << mtd->erasesize_shift) - 1;
+			mtd->writesize_mask = (1 << mtd->writesize_shift) - 1;
+
 			/* Some chips always power up locked. Unlock them now */
 			if ((mtd->flags & MTD_WRITEABLE)
 			    && (mtd->flags & MTD_POWERUP_LOCK) && mtd->unlock) {
@@ -344,7 +357,8 @@ static inline int mtd_proc_info (char *buf, int i)
 	if (!this)
 		return 0;
 
-	return sprintf(buf, "mtd%d: %8.8x %8.8x \"%s\"\n", i, this->size,
+	return sprintf(buf, "mtd%d: %8.8llx %8.8x \"%s\"\n", i,
+		       (unsigned long long)this->size,
 		       this->erasesize, this->name);
 }
 

commit 71a928c0e52cedc43747c64b96a5f74592ab678f
Author: Chris Malley <mail@chrismalley.co.uk>
Date:   Mon May 19 20:11:50 2008 +0100

    [MTD] Use list_for_each_entry[_safe] where appropriate.
    
    Janitorial work to remove temporary pointers and make some functions a bit
    more readable.
    
    Signed-off-by: Chris Malley <mail@chrismalley.co.uk>
    Reviewed-By: Jörn Engel <joern@logfs.org>
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index 4373790401d3..a9d246949820 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -70,9 +70,8 @@ int add_mtd_device(struct mtd_info *mtd)
 			DEBUG(0, "mtd: Giving out device %d to %s\n",i, mtd->name);
 			/* No need to get a refcount on the module containing
 			   the notifier, since we hold the mtd_table_mutex */
-			list_for_each_entry(not, &mtd_notifiers, list) {
+			list_for_each_entry(not, &mtd_notifiers, list)
 				not->add(mtd);
-			}
 
 			mutex_unlock(&mtd_table_mutex);
 			/* We _know_ we aren't being removed, because
@@ -114,9 +113,8 @@ int del_mtd_device (struct mtd_info *mtd)
 
 		/* No need to get a refcount on the module containing
 		   the notifier, since we hold the mtd_table_mutex */
-		list_for_each_entry(not, &mtd_notifiers, list) {
+		list_for_each_entry(not, &mtd_notifiers, list)
 			not->remove(mtd);
-		}
 
 		mtd_table[mtd->index] = NULL;
 

commit 59018b6d2acabb114ab58637e6ab95ba424a89d0
Author: Adrian Bunk <bunk@kernel.org>
Date:   Tue May 20 01:03:52 2008 +0300

    MTD/JFFS2: remove CVS keywords
    
    Once upon a time, the MTD repository was using CVS.
    
    This patch therefore removes all usages of the no longer updated CVS
    keywords from the MTD code.
    
    This also includes code that printed them to the user.
    
    Signed-off-by: Adrian Bunk <bunk@kernel.org>
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index 8c61035b968b..4373790401d3 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -1,6 +1,4 @@
 /*
- * $Id: mtdcore.c,v 1.47 2005/11/07 11:14:20 gleixner Exp $
- *
  * Core registration and callback routines for MTD
  * drivers and users.
  *

commit 856613c98c2f864994d5fb33a62b7a468f68ab9b
Author: matthias@kaehlcke.net <matthias@kaehlcke.net>
Date:   Sat May 31 15:28:10 2008 +0200

    [MTD] use list_for_each_entry() in del_mtd_device()
    
    Signed-off-by: Matthias Kaehlcke <matthias@kaehlcke.net>
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index 4c102f123463..8c61035b968b 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -112,12 +112,11 @@ int del_mtd_device (struct mtd_info *mtd)
 		       mtd->index, mtd->name, mtd->usecount);
 		ret = -EBUSY;
 	} else {
-		struct list_head *this;
+		struct mtd_notifier *not;
 
 		/* No need to get a refcount on the module containing
 		   the notifier, since we hold the mtd_table_mutex */
-		list_for_each(this, &mtd_notifiers) {
-			struct mtd_notifier *not = list_entry(this, struct mtd_notifier, list);
+		list_for_each_entry(not, &mtd_notifiers, list) {
 			not->remove(mtd);
 		}
 

commit 2606c79759e83fd8b1e45bc99b10e65a1dcf1602
Author: matthias@kaehlcke.net <matthias@kaehlcke.net>
Date:   Sat May 31 15:28:09 2008 +0200

    [MTD] use list_for_each_entry() in add_mtd_device()
    
    Signed-off-by: Matthias Kaehlcke <matthias@kaehlcke.net>
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index f7e7890e5bc6..4c102f123463 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -53,7 +53,7 @@ int add_mtd_device(struct mtd_info *mtd)
 
 	for (i=0; i < MAX_MTD_DEVICES; i++)
 		if (!mtd_table[i]) {
-			struct list_head *this;
+			struct mtd_notifier *not;
 
 			mtd_table[i] = mtd;
 			mtd->index = i;
@@ -72,8 +72,7 @@ int add_mtd_device(struct mtd_info *mtd)
 			DEBUG(0, "mtd: Giving out device %d to %s\n",i, mtd->name);
 			/* No need to get a refcount on the module containing
 			   the notifier, since we hold the mtd_table_mutex */
-			list_for_each(this, &mtd_notifiers) {
-				struct mtd_notifier *not = list_entry(this, struct mtd_notifier, list);
+			list_for_each_entry(not, &mtd_notifiers, list) {
 				not->add(mtd);
 			}
 

commit e619a75ff6201b567a539e787aa9af9bc63a3187
Author: Justin Treon <justin_treon@yahoo.com>
Date:   Wed Jan 30 10:25:49 2008 -0800

    [MTD] Unlocking all Intel flash that is locked on power up.
    
    Patch for unlocking all Intel flash that has instant locking on power up.
    The patch has been tested on Intel M18, P30 and J3D Strata Flash.
      1.    The automatic unlocking can be disabled for a particular partition
             in the map or the command line.
         a. For the bit mask in the map it should look like:
             .mask_flags   = MTD_POWERUP_LOCK,
         b. For the command line parsing it should look like:
             mtdparts=0x80000(bootloader)lk
      2.    This will only unlock parts with instant individual block locking.
             Intel parts with legacy unlocking will not be unlocked.
    
    Signed-off-by: Justin Treon <justin_treon@yahoo.com>
    Signed-off-by: Jared Hulbert <jaredeh@gmail.com>
    Acked-by: Nicolas Pitre <nico@cam.org>
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index 6c2645e28371..f7e7890e5bc6 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -61,7 +61,7 @@ int add_mtd_device(struct mtd_info *mtd)
 
 			/* Some chips always power up locked. Unlock them now */
 			if ((mtd->flags & MTD_WRITEABLE)
-			    && (mtd->flags & MTD_STUPID_LOCK) && mtd->unlock) {
+			    && (mtd->flags & MTD_POWERUP_LOCK) && mtd->unlock) {
 				if (mtd->unlock(mtd, 0, mtd->size))
 					printk(KERN_WARNING
 					       "%s: unlock failed, "

commit 356d70f19d949a11320ab626037b2d197a8e8b51
Author: Ben Dooks <ben-linux@fluff.org>
Date:   Mon May 28 20:28:34 2007 +0100

    [MTD] mtdcore.c: share syms with mtd_blkdev.c
    
    Fix the sparse warnings generated by the implicit
    dependency of mtd_blkdevs.c and mtd_core.c for the
    two symbols mtd_table and mtd_table_mutex. This is
    done by adding an local header file mtdcore.h to
    define these (including the warning about the
    non-proliferation of these symbols).
    
    Signed-off-by: Ben Dooks <ben-linux@fluff.org>
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index c153b64a8300..6c2645e28371 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -22,6 +22,8 @@
 
 #include <linux/mtd/mtd.h>
 
+#include "mtdcore.h"
+
 /* These are exported solely for the purpose of mtd_blkdevs.c. You
    should not use them for _anything_ else */
 DEFINE_MUTEX(mtd_table_mutex);

commit cd354f1ae75e6466a7e31b727faede57a1f89ca5
Author: Tim Schmielau <tim@physik3.uni-rostock.de>
Date:   Wed Feb 14 00:33:14 2007 -0800

    [PATCH] remove many unneeded #includes of sched.h
    
    After Al Viro (finally) succeeded in removing the sched.h #include in module.h
    recently, it makes sense again to remove other superfluous sched.h includes.
    There are quite a lot of files which include it but don't actually need
    anything defined in there.  Presumably these includes were once needed for
    macros that used to live in sched.h, but moved to other header files in the
    course of cleaning it up.
    
    To ease the pain, this time I did not fiddle with any header files and only
    removed #includes from .c-files, which tend to cause less trouble.
    
    Compile tested against 2.6.20-rc2 and 2.6.20-rc2-mm2 (with offsets) on alpha,
    arm, i386, ia64, mips, powerpc, and x86_64 with allnoconfig, defconfig,
    allmodconfig, and allyesconfig as well as a few randconfigs on x86_64 and all
    configs in arch/arm/configs on arm.  I also checked that no new warnings were
    introduced by the patch (actually, some warnings are removed that were emitted
    by unnecessarily included header files).
    
    Signed-off-by: Tim Schmielau <tim@physik3.uni-rostock.de>
    Acked-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index 7070110aba2a..c153b64a8300 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -8,7 +8,6 @@
 
 #include <linux/module.h>
 #include <linux/kernel.h>
-#include <linux/sched.h>
 #include <linux/ptrace.h>
 #include <linux/slab.h>
 #include <linux/string.h>

commit dd36f2673573fc027945d488342f2f70664f0448
Author: David Woodhouse <dwmw2@infradead.org>
Date:   Wed Nov 29 16:33:03 2006 +0000

    [MTD] Use EXPORT_SYMBOL_GPL() for exported symbols.
    
    While we're fixing up the newly-added symbol, change the neighbouring ones
    too, for consistency and also to reflect the author's interpretation of
    the GPL -- which is that _no_ non-GPL modules are permitted. The author
    always intended his code to be released under the GPL, and believes that
    any new interpretation of 'EXPORT_SYMBOL' as being any different from
    'EXPORT_SYMBOL_GPL' is entirely invalid; the GPL requires that _all_
    exports have the semantics of the new 'EXPORT_SYMBOL_GPL', which means the
    extra four characters are entirely redundant.
    
    But since those four extra characters trigger the check for illegal
    modules in a way that just EXPORT_SYMBOL does not, it's useful to change
    anyway. This action in no way indicates an admission that there is any
    legal distinction between the two states, and in particular does not
    indicate that the author believes that non-GPL modules may use symbols
    exported with EXPORT_SYMBOL alone.
    
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index 60f237f91bb2..7070110aba2a 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -298,7 +298,7 @@ void put_mtd_device(struct mtd_info *mtd)
 }
 
 /* default_mtd_writev - default mtd writev method for MTD devices that
- *			dont implement their own
+ *			don't implement their own
  */
 
 int default_mtd_writev(struct mtd_info *mtd, const struct kvec *vecs,
@@ -326,14 +326,14 @@ int default_mtd_writev(struct mtd_info *mtd, const struct kvec *vecs,
 	return ret;
 }
 
-EXPORT_SYMBOL(add_mtd_device);
-EXPORT_SYMBOL(del_mtd_device);
-EXPORT_SYMBOL(get_mtd_device);
-EXPORT_SYMBOL(get_mtd_device_nm);
-EXPORT_SYMBOL(put_mtd_device);
-EXPORT_SYMBOL(register_mtd_user);
-EXPORT_SYMBOL(unregister_mtd_user);
-EXPORT_SYMBOL(default_mtd_writev);
+EXPORT_SYMBOL_GPL(add_mtd_device);
+EXPORT_SYMBOL_GPL(del_mtd_device);
+EXPORT_SYMBOL_GPL(get_mtd_device);
+EXPORT_SYMBOL_GPL(get_mtd_device_nm);
+EXPORT_SYMBOL_GPL(put_mtd_device);
+EXPORT_SYMBOL_GPL(register_mtd_user);
+EXPORT_SYMBOL_GPL(unregister_mtd_user);
+EXPORT_SYMBOL_GPL(default_mtd_writev);
 
 #ifdef CONFIG_PROC_FS
 

commit 9c74034f8fc5d93fbe5656421cbbdc4c76ddda28
Author: Artem Bityutskiy <dedekind@infradead.org>
Date:   Wed Oct 11 14:52:47 2006 +0300

    [MTD] return error code from get_mtd_device()
    
    get_mtd_device() returns NULL in case of any failure. Teach it to return an
    error code instead. Fix all users as well.
    
    Signed-off-by: Artem Bityutskiy <dedekind@infradead.org>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index f11f55f02413..60f237f91bb2 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -193,14 +193,14 @@ int unregister_mtd_user (struct mtd_notifier *old)
  *	Given a number and NULL address, return the num'th entry in the device
  *	table, if any.	Given an address and num == -1, search the device table
  *	for a device with that address and return if it's still present. Given
- *	both, return the num'th driver only if its address matches. Return NULL
- *	if not.
+ *	both, return the num'th driver only if its address matches. Return
+ *	error code if not.
  */
 
 struct mtd_info *get_mtd_device(struct mtd_info *mtd, int num)
 {
 	struct mtd_info *ret = NULL;
-	int i;
+	int i, err = -ENODEV;
 
 	mutex_lock(&mtd_table_mutex);
 
@@ -217,22 +217,24 @@ struct mtd_info *get_mtd_device(struct mtd_info *mtd, int num)
 	if (!ret)
 		goto out_unlock;
 
-	if (!try_module_get(ret->owner)) {
-		ret = NULL;
+	if (!try_module_get(ret->owner))
 		goto out_unlock;
-	}
 
-	if (ret->get_device && ret->get_device(ret)) {
-		module_put(ret->owner);
-		ret = NULL;
-		goto out_unlock;
+	if (ret->get_device) {
+		err = ret->get_device(ret);
+		if (err)
+			goto out_put;
 	}
 
 	ret->usecount++;
+	mutex_unlock(&mtd_table_mutex);
+	return ret;
 
+out_put:
+	module_put(ret->owner);
 out_unlock:
 	mutex_unlock(&mtd_table_mutex);
-	return ret;
+	return ERR_PTR(err);
 }
 
 /**

commit 9fe912cea32aec18f860c95e8574410b5892481b
Author: Artem Bityutskiy <dedekind@infradead.org>
Date:   Wed Oct 11 14:52:45 2006 +0300

    [MTD] add get and put methods
    
    This patch adds get_device() and put_device() methods to the MTD description
    structure (struct mtd_info). These methods are called by MTD whenever the MTD
    device is get or put. They are needed when the underlying driver is something
    smarter then just flash chip driver, for example UBI.
    
    Signed-off-by: Artem Bityutskiy <dedekind@infradead.org>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index 06ec9f836ae5..f11f55f02413 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -214,12 +214,23 @@ struct mtd_info *get_mtd_device(struct mtd_info *mtd, int num)
 			ret = NULL;
 	}
 
-	if (ret && !try_module_get(ret->owner))
+	if (!ret)
+		goto out_unlock;
+
+	if (!try_module_get(ret->owner)) {
+		ret = NULL;
+		goto out_unlock;
+	}
+
+	if (ret->get_device && ret->get_device(ret)) {
+		module_put(ret->owner);
 		ret = NULL;
+		goto out_unlock;
+	}
 
-	if (ret)
-		ret->usecount++;
+	ret->usecount++;
 
+out_unlock:
 	mutex_unlock(&mtd_table_mutex);
 	return ret;
 }
@@ -235,8 +246,8 @@ struct mtd_info *get_mtd_device(struct mtd_info *mtd, int num)
 
 struct mtd_info *get_mtd_device_nm(const char *name)
 {
-	int i;
-	struct mtd_info *mtd = ERR_PTR(-ENODEV);
+	int i, err = -ENODEV;
+	struct mtd_info *mtd = NULL;
 
 	mutex_lock(&mtd_table_mutex);
 
@@ -247,17 +258,27 @@ struct mtd_info *get_mtd_device_nm(const char *name)
 		}
 	}
 
-	if (i == MAX_MTD_DEVICES)
+	if (!mtd)
 		goto out_unlock;
 
 	if (!try_module_get(mtd->owner))
 		goto out_unlock;
 
+	if (mtd->get_device) {
+		err = mtd->get_device(mtd);
+		if (err)
+			goto out_put;
+	}
+
 	mtd->usecount++;
+	mutex_unlock(&mtd_table_mutex);
+	return mtd;
 
+out_put:
+	module_put(mtd->owner);
 out_unlock:
 	mutex_unlock(&mtd_table_mutex);
-	return mtd;
+	return ERR_PTR(err);
 }
 
 void put_mtd_device(struct mtd_info *mtd)
@@ -266,6 +287,8 @@ void put_mtd_device(struct mtd_info *mtd)
 
 	mutex_lock(&mtd_table_mutex);
 	c = --mtd->usecount;
+	if (mtd->put_device)
+		mtd->put_device(mtd);
 	mutex_unlock(&mtd_table_mutex);
 	BUG_ON(c < 0);
 

commit 7799308f34d3c3371a319559687c78c0f2506fcf
Author: Artem Bityutskiy <dedekind@infradead.org>
Date:   Wed Oct 11 14:52:44 2006 +0300

    [MTD] add get_mtd_device_nm() function
    
    This patch adds one more function to the MTD interface to make it possible to
    open MTD devices by their names, not only numbers. This is very handy in many
    situations. Also, MTD device number depend on load order and may vary, while
    names are fixed.
    
    Signed-off-by: Artem Bityutskiy <dedekind@infradead.org>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index c4d26de74349..06ec9f836ae5 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -15,6 +15,7 @@
 #include <linux/timer.h>
 #include <linux/major.h>
 #include <linux/fs.h>
+#include <linux/err.h>
 #include <linux/ioctl.h>
 #include <linux/init.h>
 #include <linux/mtd/compatmac.h>
@@ -223,6 +224,42 @@ struct mtd_info *get_mtd_device(struct mtd_info *mtd, int num)
 	return ret;
 }
 
+/**
+ *	get_mtd_device_nm - obtain a validated handle for an MTD device by
+ *	device name
+ *	@name: MTD device name to open
+ *
+ * 	This function returns MTD device description structure in case of
+ * 	success and an error code in case of failure.
+ */
+
+struct mtd_info *get_mtd_device_nm(const char *name)
+{
+	int i;
+	struct mtd_info *mtd = ERR_PTR(-ENODEV);
+
+	mutex_lock(&mtd_table_mutex);
+
+	for (i = 0; i < MAX_MTD_DEVICES; i++) {
+		if (mtd_table[i] && !strcmp(name, mtd_table[i]->name)) {
+			mtd = mtd_table[i];
+			break;
+		}
+	}
+
+	if (i == MAX_MTD_DEVICES)
+		goto out_unlock;
+
+	if (!try_module_get(mtd->owner))
+		goto out_unlock;
+
+	mtd->usecount++;
+
+out_unlock:
+	mutex_unlock(&mtd_table_mutex);
+	return mtd;
+}
+
 void put_mtd_device(struct mtd_info *mtd)
 {
 	int c;
@@ -267,6 +304,7 @@ int default_mtd_writev(struct mtd_info *mtd, const struct kvec *vecs,
 EXPORT_SYMBOL(add_mtd_device);
 EXPORT_SYMBOL(del_mtd_device);
 EXPORT_SYMBOL(get_mtd_device);
+EXPORT_SYMBOL(get_mtd_device_nm);
 EXPORT_SYMBOL(put_mtd_device);
 EXPORT_SYMBOL(register_mtd_user);
 EXPORT_SYMBOL(unregister_mtd_user);

commit 187ef15268e638603dea55a91fdfa29feaed6d13
Author: Håvard Skinnemoen <hskinnemoen@atmel.com>
Date:   Fri Sep 22 10:07:08 2006 +0100

    [MTD] Unlock NOR flash automatically where necessary
    
    Introduce the MTD_STUPID_LOCK flag which indicates that the flash chip is
    always locked after power-up, so all sectors need to be unlocked before it
    is usable.
    
    If this flag is set, and the chip provides an unlock() operation,
    mtd_add_device will unlock the whole MTD device if it's writeable.  This
    means that non-writeable partitions will stay locked.
    
    Set MTD_STUPID_LOCK in fixup_use_atmel_lock() so that these chips will work
    as expected.
    
    Signed-off-by: Håvard Skinnemoen <hskinnemoen@atmel.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index 168d3ba063c3..c4d26de74349 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -57,6 +57,16 @@ int add_mtd_device(struct mtd_info *mtd)
 			mtd->index = i;
 			mtd->usecount = 0;
 
+			/* Some chips always power up locked. Unlock them now */
+			if ((mtd->flags & MTD_WRITEABLE)
+			    && (mtd->flags & MTD_STUPID_LOCK) && mtd->unlock) {
+				if (mtd->unlock(mtd, 0, mtd->size))
+					printk(KERN_WARNING
+					       "%s: unlock failed, "
+					       "writes may not work\n",
+					       mtd->name);
+			}
+
 			DEBUG(0, "mtd: Giving out device %d to %s\n",i, mtd->name);
 			/* No need to get a refcount on the module containing
 			   the notifier, since we hold the mtd_table_mutex */

commit 6ab3d5624e172c553004ecc862bfeac16d9d68b7
Author: Jörn Engel <joern@wohnheim.fh-wedel.de>
Date:   Fri Jun 30 19:25:36 2006 +0200

    Remove obsolete #include <linux/config.h>
    
    Signed-off-by: Jörn Engel <joern@wohnheim.fh-wedel.de>
    Signed-off-by: Adrian Bunk <bunk@stusta.de>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index 16a952dd486a..168d3ba063c3 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -6,7 +6,6 @@
  *
  */
 
-#include <linux/config.h>
 #include <linux/module.h>
 #include <linux/kernel.h>
 #include <linux/sched.h>

commit 783ed81ff39d3f938a6b2efd09fbad96e41e5c1f
Author: Artem B. Bityutskiy <dedekind@sauron.oktetlabs.ru>
Date:   Wed Jun 14 19:53:44 2006 +0400

    [MTD] assume mtd->writesize is 1 for NOR flashes
    
    Signed-off-by: Artem B. Bityitskiy

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index 49bc9fdcb88b..16a952dd486a 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -47,6 +47,7 @@ int add_mtd_device(struct mtd_info *mtd)
 {
 	int i;
 
+	BUG_ON(mtd->writesize == 0);
 	mutex_lock(&mtd_table_mutex);
 
 	for (i=0; i < MAX_MTD_DEVICES; i++)

commit 8546ac4f84b252fff078fab1a992c70504147914
Author: Thomas Gleixner <tglx@cruncher.tec.linutronix.de>
Date:   Thu May 25 13:38:45 2006 +0200

    [MTD] Remove the only useless readv implementation
    
    Removing readv from struct mtd_info broke block2mtd. Remove the
    reference and the useless default implementation.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index 9905870f56e5..49bc9fdcb88b 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -254,37 +254,6 @@ int default_mtd_writev(struct mtd_info *mtd, const struct kvec *vecs,
 	return ret;
 }
 
-
-/* default_mtd_readv - default mtd readv method for MTD devices that dont
- *		       implement their own
- */
-
-int default_mtd_readv(struct mtd_info *mtd, struct kvec *vecs,
-		      unsigned long count, loff_t from, size_t *retlen)
-{
-	unsigned long i;
-	size_t totlen = 0, thislen;
-	int ret = 0;
-
-	if(!mtd->read) {
-		ret = -EIO;
-	} else {
-		for (i=0; i<count; i++) {
-			if (!vecs[i].iov_len)
-				continue;
-			ret = mtd->read(mtd, from, vecs[i].iov_len, &thislen, vecs[i].iov_base);
-			totlen += thislen;
-			if (ret || thislen != vecs[i].iov_len)
-				break;
-			from += vecs[i].iov_len;
-		}
-	}
-	if (retlen)
-		*retlen = totlen;
-	return ret;
-}
-
-
 EXPORT_SYMBOL(add_mtd_device);
 EXPORT_SYMBOL(del_mtd_device);
 EXPORT_SYMBOL(get_mtd_device);
@@ -292,7 +261,6 @@ EXPORT_SYMBOL(put_mtd_device);
 EXPORT_SYMBOL(register_mtd_user);
 EXPORT_SYMBOL(unregister_mtd_user);
 EXPORT_SYMBOL(default_mtd_writev);
-EXPORT_SYMBOL(default_mtd_readv);
 
 #ifdef CONFIG_PROC_FS
 

commit 2d2dce0eb650831046316a9cd091ea5257aa7d4b
Author: Pavel Machek <pavel@ucw.cz>
Date:   Fri Mar 31 02:29:49 2006 -0800

    [PATCH] Kill ifdefs in mtdcore.c
    
    Kill unneccessary ifdefs in mtdcore.c.
    
    Signed-off-by: Pavel Machek <pavel@suse.cz>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Adrian Bunk <bunk@stusta.de>
    Acked-by: David Woodhouse <dwmw2@infradead.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index 9c3813486a1a..9905870f56e5 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -19,9 +19,7 @@
 #include <linux/ioctl.h>
 #include <linux/init.h>
 #include <linux/mtd/compatmac.h>
-#ifdef CONFIG_PROC_FS
 #include <linux/proc_fs.h>
-#endif
 
 #include <linux/mtd/mtd.h>
 
@@ -296,10 +294,11 @@ EXPORT_SYMBOL(unregister_mtd_user);
 EXPORT_SYMBOL(default_mtd_writev);
 EXPORT_SYMBOL(default_mtd_readv);
 
+#ifdef CONFIG_PROC_FS
+
 /*====================================================================*/
 /* Support for /proc/mtd */
 
-#ifdef CONFIG_PROC_FS
 static struct proc_dir_entry *proc_mtd;
 
 static inline int mtd_proc_info (char *buf, int i)
@@ -344,31 +343,27 @@ static int mtd_read_proc (char *page, char **start, off_t off, int count,
         return ((count < begin+len-off) ? count : begin+len-off);
 }
 
-#endif /* CONFIG_PROC_FS */
-
 /*====================================================================*/
 /* Init code */
 
 static int __init init_mtd(void)
 {
-#ifdef CONFIG_PROC_FS
 	if ((proc_mtd = create_proc_entry( "mtd", 0, NULL )))
 		proc_mtd->read_proc = mtd_read_proc;
-#endif
 	return 0;
 }
 
 static void __exit cleanup_mtd(void)
 {
-#ifdef CONFIG_PROC_FS
         if (proc_mtd)
 		remove_proc_entry( "mtd", NULL);
-#endif
 }
 
 module_init(init_mtd);
 module_exit(cleanup_mtd);
 
+#endif /* CONFIG_PROC_FS */
+
 
 MODULE_LICENSE("GPL");
 MODULE_AUTHOR("David Woodhouse <dwmw2@infradead.org>");

commit 48b192686dd20cb1576ae1d8ccd17a07971ef24a
Author: Ingo Molnar <mingo@elte.hu>
Date:   Fri Mar 31 02:29:41 2006 -0800

    [PATCH] sem2mutex: drivers/mtd/
    
    Semaphore to mutex conversion.
    
    The conversion was generated via scripts, and the result was validated
    automatically via a script as well.
    
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: David Woodhouse <dwmw2@infradead.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index dade02ab0687..9c3813486a1a 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -27,7 +27,7 @@
 
 /* These are exported solely for the purpose of mtd_blkdevs.c. You
    should not use them for _anything_ else */
-DECLARE_MUTEX(mtd_table_mutex);
+DEFINE_MUTEX(mtd_table_mutex);
 struct mtd_info *mtd_table[MAX_MTD_DEVICES];
 
 EXPORT_SYMBOL_GPL(mtd_table_mutex);
@@ -49,7 +49,7 @@ int add_mtd_device(struct mtd_info *mtd)
 {
 	int i;
 
-	down(&mtd_table_mutex);
+	mutex_lock(&mtd_table_mutex);
 
 	for (i=0; i < MAX_MTD_DEVICES; i++)
 		if (!mtd_table[i]) {
@@ -67,7 +67,7 @@ int add_mtd_device(struct mtd_info *mtd)
 				not->add(mtd);
 			}
 
-			up(&mtd_table_mutex);
+			mutex_unlock(&mtd_table_mutex);
 			/* We _know_ we aren't being removed, because
 			   our caller is still holding us here. So none
 			   of this try_ nonsense, and no bitching about it
@@ -76,7 +76,7 @@ int add_mtd_device(struct mtd_info *mtd)
 			return 0;
 		}
 
-	up(&mtd_table_mutex);
+	mutex_unlock(&mtd_table_mutex);
 	return 1;
 }
 
@@ -94,7 +94,7 @@ int del_mtd_device (struct mtd_info *mtd)
 {
 	int ret;
 
-	down(&mtd_table_mutex);
+	mutex_lock(&mtd_table_mutex);
 
 	if (mtd_table[mtd->index] != mtd) {
 		ret = -ENODEV;
@@ -118,7 +118,7 @@ int del_mtd_device (struct mtd_info *mtd)
 		ret = 0;
 	}
 
-	up(&mtd_table_mutex);
+	mutex_unlock(&mtd_table_mutex);
 	return ret;
 }
 
@@ -135,7 +135,7 @@ void register_mtd_user (struct mtd_notifier *new)
 {
 	int i;
 
-	down(&mtd_table_mutex);
+	mutex_lock(&mtd_table_mutex);
 
 	list_add(&new->list, &mtd_notifiers);
 
@@ -145,7 +145,7 @@ void register_mtd_user (struct mtd_notifier *new)
 		if (mtd_table[i])
 			new->add(mtd_table[i]);
 
-	up(&mtd_table_mutex);
+	mutex_unlock(&mtd_table_mutex);
 }
 
 /**
@@ -162,7 +162,7 @@ int unregister_mtd_user (struct mtd_notifier *old)
 {
 	int i;
 
-	down(&mtd_table_mutex);
+	mutex_lock(&mtd_table_mutex);
 
 	module_put(THIS_MODULE);
 
@@ -171,7 +171,7 @@ int unregister_mtd_user (struct mtd_notifier *old)
 			old->remove(mtd_table[i]);
 
 	list_del(&old->list);
-	up(&mtd_table_mutex);
+	mutex_unlock(&mtd_table_mutex);
 	return 0;
 }
 
@@ -193,7 +193,7 @@ struct mtd_info *get_mtd_device(struct mtd_info *mtd, int num)
 	struct mtd_info *ret = NULL;
 	int i;
 
-	down(&mtd_table_mutex);
+	mutex_lock(&mtd_table_mutex);
 
 	if (num == -1) {
 		for (i=0; i< MAX_MTD_DEVICES; i++)
@@ -211,7 +211,7 @@ struct mtd_info *get_mtd_device(struct mtd_info *mtd, int num)
 	if (ret)
 		ret->usecount++;
 
-	up(&mtd_table_mutex);
+	mutex_unlock(&mtd_table_mutex);
 	return ret;
 }
 
@@ -219,9 +219,9 @@ void put_mtd_device(struct mtd_info *mtd)
 {
 	int c;
 
-	down(&mtd_table_mutex);
+	mutex_lock(&mtd_table_mutex);
 	c = --mtd->usecount;
-	up(&mtd_table_mutex);
+	mutex_unlock(&mtd_table_mutex);
 	BUG_ON(c < 0);
 
 	module_put(mtd->owner);
@@ -319,7 +319,7 @@ static int mtd_read_proc (char *page, char **start, off_t off, int count,
 	int len, l, i;
         off_t   begin = 0;
 
-	down(&mtd_table_mutex);
+	mutex_lock(&mtd_table_mutex);
 
 	len = sprintf(page, "dev:    size   erasesize  name\n");
         for (i=0; i< MAX_MTD_DEVICES; i++) {
@@ -337,7 +337,7 @@ static int mtd_read_proc (char *page, char **start, off_t off, int count,
         *eof = 1;
 
 done:
-	up(&mtd_table_mutex);
+	mutex_unlock(&mtd_table_mutex);
         if (off >= len+begin)
                 return 0;
         *start = page + (off-begin);

commit 97894cda5773e59bd13e87b72077751099419a9f
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Nov 7 11:15:26 2005 +0000

    [MTD] core: Clean up trailing white spaces
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index 2c16e051c61a..dade02ab0687 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -1,5 +1,5 @@
 /*
- * $Id: mtdcore.c,v 1.46 2005/08/11 17:13:43 gleixner Exp $
+ * $Id: mtdcore.c,v 1.47 2005/11/07 11:14:20 gleixner Exp $
  *
  * Core registration and callback routines for MTD
  * drivers and users.
@@ -25,7 +25,7 @@
 
 #include <linux/mtd/mtd.h>
 
-/* These are exported solely for the purpose of mtd_blkdevs.c. You 
+/* These are exported solely for the purpose of mtd_blkdevs.c. You
    should not use them for _anything_ else */
 DECLARE_MUTEX(mtd_table_mutex);
 struct mtd_info *mtd_table[MAX_MTD_DEVICES];
@@ -66,7 +66,7 @@ int add_mtd_device(struct mtd_info *mtd)
 				struct mtd_notifier *not = list_entry(this, struct mtd_notifier, list);
 				not->add(mtd);
 			}
-			
+
 			up(&mtd_table_mutex);
 			/* We _know_ we aren't being removed, because
 			   our caller is still holding us here. So none
@@ -75,7 +75,7 @@ int add_mtd_device(struct mtd_info *mtd)
 			__module_get(THIS_MODULE);
 			return 0;
 		}
-	
+
 	up(&mtd_table_mutex);
 	return 1;
 }
@@ -93,13 +93,13 @@ int add_mtd_device(struct mtd_info *mtd)
 int del_mtd_device (struct mtd_info *mtd)
 {
 	int ret;
-	
+
 	down(&mtd_table_mutex);
 
 	if (mtd_table[mtd->index] != mtd) {
 		ret = -ENODEV;
 	} else if (mtd->usecount) {
-		printk(KERN_NOTICE "Removing MTD device #%d (%s) with use count %d\n", 
+		printk(KERN_NOTICE "Removing MTD device #%d (%s) with use count %d\n",
 		       mtd->index, mtd->name, mtd->usecount);
 		ret = -EBUSY;
 	} else {
@@ -140,7 +140,7 @@ void register_mtd_user (struct mtd_notifier *new)
 	list_add(&new->list, &mtd_notifiers);
 
  	__module_get(THIS_MODULE);
-	
+
 	for (i=0; i< MAX_MTD_DEVICES; i++)
 		if (mtd_table[i])
 			new->add(mtd_table[i]);
@@ -169,7 +169,7 @@ int unregister_mtd_user (struct mtd_notifier *old)
 	for (i=0; i< MAX_MTD_DEVICES; i++)
 		if (mtd_table[i])
 			old->remove(mtd_table[i]);
-			
+
 	list_del(&old->list);
 	up(&mtd_table_mutex);
 	return 0;
@@ -187,7 +187,7 @@ int unregister_mtd_user (struct mtd_notifier *old)
  *	both, return the num'th driver only if its address matches. Return NULL
  *	if not.
  */
-	
+
 struct mtd_info *get_mtd_device(struct mtd_info *mtd, int num)
 {
 	struct mtd_info *ret = NULL;

commit 2c92d755323514a12c367f52027fb1f53328fcd6
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Aug 11 18:13:46 2005 +0100

    [MTD] Remove deprecated power management functions
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index dc86df18e94b..2c16e051c61a 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -1,5 +1,5 @@
 /*
- * $Id: mtdcore.c,v 1.45 2005/02/18 14:34:50 dedekind Exp $
+ * $Id: mtdcore.c,v 1.46 2005/08/11 17:13:43 gleixner Exp $
  *
  * Core registration and callback routines for MTD
  * drivers and users.
@@ -296,39 +296,6 @@ EXPORT_SYMBOL(unregister_mtd_user);
 EXPORT_SYMBOL(default_mtd_writev);
 EXPORT_SYMBOL(default_mtd_readv);
 
-/*====================================================================*/
-/* Power management code */
-
-#ifdef CONFIG_PM
-
-#include <linux/pm.h>
-
-static struct pm_dev *mtd_pm_dev = NULL;
-
-static int mtd_pm_callback(struct pm_dev *dev, pm_request_t rqst, void *data)
-{
-	int ret = 0, i;
-
-	if (down_trylock(&mtd_table_mutex))
-		return -EAGAIN;
-	if (rqst == PM_SUSPEND) {
-		for (i = 0; ret == 0 && i < MAX_MTD_DEVICES; i++) {
-			if (mtd_table[i] && mtd_table[i]->suspend)
-				ret = mtd_table[i]->suspend(mtd_table[i]);
-		}
-	} else i = MAX_MTD_DEVICES-1;
-
-	if (rqst == PM_RESUME || ret) {
-		for ( ; i >= 0; i--) {
-			if (mtd_table[i] && mtd_table[i]->resume)
-				mtd_table[i]->resume(mtd_table[i]);
-		}
-	}
-	up(&mtd_table_mutex);
-	return ret;
-}
-#endif
-
 /*====================================================================*/
 /* Support for /proc/mtd */
 
@@ -388,22 +355,11 @@ static int __init init_mtd(void)
 	if ((proc_mtd = create_proc_entry( "mtd", 0, NULL )))
 		proc_mtd->read_proc = mtd_read_proc;
 #endif
-
-#ifdef CONFIG_PM
-	mtd_pm_dev = pm_register(PM_UNKNOWN_DEV, 0, mtd_pm_callback);
-#endif
 	return 0;
 }
 
 static void __exit cleanup_mtd(void)
 {
-#ifdef CONFIG_PM
-	if (mtd_pm_dev) {
-		pm_unregister(mtd_pm_dev);
-		mtd_pm_dev = NULL;
-	}
-#endif
-
 #ifdef CONFIG_PROC_FS
         if (proc_mtd)
 		remove_proc_entry( "mtd", NULL);

commit 49450795844daba7867cc215f17532cac2c2b284
Author: Artem B. Bityuckiy <dedekind@infradead.org>
Date:   Fri Feb 18 14:34:54 2005 +0000

    [MTD] Fix unregister_mtd_user() public function documentation.
    
    Signed-off-by: Artem B. Bityuckiy <dedekind@infradead.org>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
index 9c0315d1b1c4..dc86df18e94b 100644
--- a/drivers/mtd/mtdcore.c
+++ b/drivers/mtd/mtdcore.c
@@ -1,5 +1,5 @@
 /*
- * $Id: mtdcore.c,v 1.44 2004/11/16 18:28:59 dwmw2 Exp $
+ * $Id: mtdcore.c,v 1.45 2005/02/18 14:34:50 dedekind Exp $
  *
  * Core registration and callback routines for MTD
  * drivers and users.
@@ -149,8 +149,8 @@ void register_mtd_user (struct mtd_notifier *new)
 }
 
 /**
- *	register_mtd_user - unregister a 'user' of MTD devices.
- *	@new: pointer to notifier info structure
+ *	unregister_mtd_user - unregister a 'user' of MTD devices.
+ *	@old: pointer to notifier info structure
  *
  *	Removes a callback function pair from the list of 'users' to be
  *	notified upon addition or removal of MTD devices. Causes the

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/drivers/mtd/mtdcore.c b/drivers/mtd/mtdcore.c
new file mode 100644
index 000000000000..9c0315d1b1c4
--- /dev/null
+++ b/drivers/mtd/mtdcore.c
@@ -0,0 +1,419 @@
+/*
+ * $Id: mtdcore.c,v 1.44 2004/11/16 18:28:59 dwmw2 Exp $
+ *
+ * Core registration and callback routines for MTD
+ * drivers and users.
+ *
+ */
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/ptrace.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+#include <linux/timer.h>
+#include <linux/major.h>
+#include <linux/fs.h>
+#include <linux/ioctl.h>
+#include <linux/init.h>
+#include <linux/mtd/compatmac.h>
+#ifdef CONFIG_PROC_FS
+#include <linux/proc_fs.h>
+#endif
+
+#include <linux/mtd/mtd.h>
+
+/* These are exported solely for the purpose of mtd_blkdevs.c. You 
+   should not use them for _anything_ else */
+DECLARE_MUTEX(mtd_table_mutex);
+struct mtd_info *mtd_table[MAX_MTD_DEVICES];
+
+EXPORT_SYMBOL_GPL(mtd_table_mutex);
+EXPORT_SYMBOL_GPL(mtd_table);
+
+static LIST_HEAD(mtd_notifiers);
+
+/**
+ *	add_mtd_device - register an MTD device
+ *	@mtd: pointer to new MTD device info structure
+ *
+ *	Add a device to the list of MTD devices present in the system, and
+ *	notify each currently active MTD 'user' of its arrival. Returns
+ *	zero on success or 1 on failure, which currently will only happen
+ *	if the number of present devices exceeds MAX_MTD_DEVICES (i.e. 16)
+ */
+
+int add_mtd_device(struct mtd_info *mtd)
+{
+	int i;
+
+	down(&mtd_table_mutex);
+
+	for (i=0; i < MAX_MTD_DEVICES; i++)
+		if (!mtd_table[i]) {
+			struct list_head *this;
+
+			mtd_table[i] = mtd;
+			mtd->index = i;
+			mtd->usecount = 0;
+
+			DEBUG(0, "mtd: Giving out device %d to %s\n",i, mtd->name);
+			/* No need to get a refcount on the module containing
+			   the notifier, since we hold the mtd_table_mutex */
+			list_for_each(this, &mtd_notifiers) {
+				struct mtd_notifier *not = list_entry(this, struct mtd_notifier, list);
+				not->add(mtd);
+			}
+			
+			up(&mtd_table_mutex);
+			/* We _know_ we aren't being removed, because
+			   our caller is still holding us here. So none
+			   of this try_ nonsense, and no bitching about it
+			   either. :) */
+			__module_get(THIS_MODULE);
+			return 0;
+		}
+	
+	up(&mtd_table_mutex);
+	return 1;
+}
+
+/**
+ *	del_mtd_device - unregister an MTD device
+ *	@mtd: pointer to MTD device info structure
+ *
+ *	Remove a device from the list of MTD devices present in the system,
+ *	and notify each currently active MTD 'user' of its departure.
+ *	Returns zero on success or 1 on failure, which currently will happen
+ *	if the requested device does not appear to be present in the list.
+ */
+
+int del_mtd_device (struct mtd_info *mtd)
+{
+	int ret;
+	
+	down(&mtd_table_mutex);
+
+	if (mtd_table[mtd->index] != mtd) {
+		ret = -ENODEV;
+	} else if (mtd->usecount) {
+		printk(KERN_NOTICE "Removing MTD device #%d (%s) with use count %d\n", 
+		       mtd->index, mtd->name, mtd->usecount);
+		ret = -EBUSY;
+	} else {
+		struct list_head *this;
+
+		/* No need to get a refcount on the module containing
+		   the notifier, since we hold the mtd_table_mutex */
+		list_for_each(this, &mtd_notifiers) {
+			struct mtd_notifier *not = list_entry(this, struct mtd_notifier, list);
+			not->remove(mtd);
+		}
+
+		mtd_table[mtd->index] = NULL;
+
+		module_put(THIS_MODULE);
+		ret = 0;
+	}
+
+	up(&mtd_table_mutex);
+	return ret;
+}
+
+/**
+ *	register_mtd_user - register a 'user' of MTD devices.
+ *	@new: pointer to notifier info structure
+ *
+ *	Registers a pair of callbacks function to be called upon addition
+ *	or removal of MTD devices. Causes the 'add' callback to be immediately
+ *	invoked for each MTD device currently present in the system.
+ */
+
+void register_mtd_user (struct mtd_notifier *new)
+{
+	int i;
+
+	down(&mtd_table_mutex);
+
+	list_add(&new->list, &mtd_notifiers);
+
+ 	__module_get(THIS_MODULE);
+	
+	for (i=0; i< MAX_MTD_DEVICES; i++)
+		if (mtd_table[i])
+			new->add(mtd_table[i]);
+
+	up(&mtd_table_mutex);
+}
+
+/**
+ *	register_mtd_user - unregister a 'user' of MTD devices.
+ *	@new: pointer to notifier info structure
+ *
+ *	Removes a callback function pair from the list of 'users' to be
+ *	notified upon addition or removal of MTD devices. Causes the
+ *	'remove' callback to be immediately invoked for each MTD device
+ *	currently present in the system.
+ */
+
+int unregister_mtd_user (struct mtd_notifier *old)
+{
+	int i;
+
+	down(&mtd_table_mutex);
+
+	module_put(THIS_MODULE);
+
+	for (i=0; i< MAX_MTD_DEVICES; i++)
+		if (mtd_table[i])
+			old->remove(mtd_table[i]);
+			
+	list_del(&old->list);
+	up(&mtd_table_mutex);
+	return 0;
+}
+
+
+/**
+ *	get_mtd_device - obtain a validated handle for an MTD device
+ *	@mtd: last known address of the required MTD device
+ *	@num: internal device number of the required MTD device
+ *
+ *	Given a number and NULL address, return the num'th entry in the device
+ *	table, if any.	Given an address and num == -1, search the device table
+ *	for a device with that address and return if it's still present. Given
+ *	both, return the num'th driver only if its address matches. Return NULL
+ *	if not.
+ */
+	
+struct mtd_info *get_mtd_device(struct mtd_info *mtd, int num)
+{
+	struct mtd_info *ret = NULL;
+	int i;
+
+	down(&mtd_table_mutex);
+
+	if (num == -1) {
+		for (i=0; i< MAX_MTD_DEVICES; i++)
+			if (mtd_table[i] == mtd)
+				ret = mtd_table[i];
+	} else if (num < MAX_MTD_DEVICES) {
+		ret = mtd_table[num];
+		if (mtd && mtd != ret)
+			ret = NULL;
+	}
+
+	if (ret && !try_module_get(ret->owner))
+		ret = NULL;
+
+	if (ret)
+		ret->usecount++;
+
+	up(&mtd_table_mutex);
+	return ret;
+}
+
+void put_mtd_device(struct mtd_info *mtd)
+{
+	int c;
+
+	down(&mtd_table_mutex);
+	c = --mtd->usecount;
+	up(&mtd_table_mutex);
+	BUG_ON(c < 0);
+
+	module_put(mtd->owner);
+}
+
+/* default_mtd_writev - default mtd writev method for MTD devices that
+ *			dont implement their own
+ */
+
+int default_mtd_writev(struct mtd_info *mtd, const struct kvec *vecs,
+		       unsigned long count, loff_t to, size_t *retlen)
+{
+	unsigned long i;
+	size_t totlen = 0, thislen;
+	int ret = 0;
+
+	if(!mtd->write) {
+		ret = -EROFS;
+	} else {
+		for (i=0; i<count; i++) {
+			if (!vecs[i].iov_len)
+				continue;
+			ret = mtd->write(mtd, to, vecs[i].iov_len, &thislen, vecs[i].iov_base);
+			totlen += thislen;
+			if (ret || thislen != vecs[i].iov_len)
+				break;
+			to += vecs[i].iov_len;
+		}
+	}
+	if (retlen)
+		*retlen = totlen;
+	return ret;
+}
+
+
+/* default_mtd_readv - default mtd readv method for MTD devices that dont
+ *		       implement their own
+ */
+
+int default_mtd_readv(struct mtd_info *mtd, struct kvec *vecs,
+		      unsigned long count, loff_t from, size_t *retlen)
+{
+	unsigned long i;
+	size_t totlen = 0, thislen;
+	int ret = 0;
+
+	if(!mtd->read) {
+		ret = -EIO;
+	} else {
+		for (i=0; i<count; i++) {
+			if (!vecs[i].iov_len)
+				continue;
+			ret = mtd->read(mtd, from, vecs[i].iov_len, &thislen, vecs[i].iov_base);
+			totlen += thislen;
+			if (ret || thislen != vecs[i].iov_len)
+				break;
+			from += vecs[i].iov_len;
+		}
+	}
+	if (retlen)
+		*retlen = totlen;
+	return ret;
+}
+
+
+EXPORT_SYMBOL(add_mtd_device);
+EXPORT_SYMBOL(del_mtd_device);
+EXPORT_SYMBOL(get_mtd_device);
+EXPORT_SYMBOL(put_mtd_device);
+EXPORT_SYMBOL(register_mtd_user);
+EXPORT_SYMBOL(unregister_mtd_user);
+EXPORT_SYMBOL(default_mtd_writev);
+EXPORT_SYMBOL(default_mtd_readv);
+
+/*====================================================================*/
+/* Power management code */
+
+#ifdef CONFIG_PM
+
+#include <linux/pm.h>
+
+static struct pm_dev *mtd_pm_dev = NULL;
+
+static int mtd_pm_callback(struct pm_dev *dev, pm_request_t rqst, void *data)
+{
+	int ret = 0, i;
+
+	if (down_trylock(&mtd_table_mutex))
+		return -EAGAIN;
+	if (rqst == PM_SUSPEND) {
+		for (i = 0; ret == 0 && i < MAX_MTD_DEVICES; i++) {
+			if (mtd_table[i] && mtd_table[i]->suspend)
+				ret = mtd_table[i]->suspend(mtd_table[i]);
+		}
+	} else i = MAX_MTD_DEVICES-1;
+
+	if (rqst == PM_RESUME || ret) {
+		for ( ; i >= 0; i--) {
+			if (mtd_table[i] && mtd_table[i]->resume)
+				mtd_table[i]->resume(mtd_table[i]);
+		}
+	}
+	up(&mtd_table_mutex);
+	return ret;
+}
+#endif
+
+/*====================================================================*/
+/* Support for /proc/mtd */
+
+#ifdef CONFIG_PROC_FS
+static struct proc_dir_entry *proc_mtd;
+
+static inline int mtd_proc_info (char *buf, int i)
+{
+	struct mtd_info *this = mtd_table[i];
+
+	if (!this)
+		return 0;
+
+	return sprintf(buf, "mtd%d: %8.8x %8.8x \"%s\"\n", i, this->size,
+		       this->erasesize, this->name);
+}
+
+static int mtd_read_proc (char *page, char **start, off_t off, int count,
+			  int *eof, void *data_unused)
+{
+	int len, l, i;
+        off_t   begin = 0;
+
+	down(&mtd_table_mutex);
+
+	len = sprintf(page, "dev:    size   erasesize  name\n");
+        for (i=0; i< MAX_MTD_DEVICES; i++) {
+
+                l = mtd_proc_info(page + len, i);
+                len += l;
+                if (len+begin > off+count)
+                        goto done;
+                if (len+begin < off) {
+                        begin += len;
+                        len = 0;
+                }
+        }
+
+        *eof = 1;
+
+done:
+	up(&mtd_table_mutex);
+        if (off >= len+begin)
+                return 0;
+        *start = page + (off-begin);
+        return ((count < begin+len-off) ? count : begin+len-off);
+}
+
+#endif /* CONFIG_PROC_FS */
+
+/*====================================================================*/
+/* Init code */
+
+static int __init init_mtd(void)
+{
+#ifdef CONFIG_PROC_FS
+	if ((proc_mtd = create_proc_entry( "mtd", 0, NULL )))
+		proc_mtd->read_proc = mtd_read_proc;
+#endif
+
+#ifdef CONFIG_PM
+	mtd_pm_dev = pm_register(PM_UNKNOWN_DEV, 0, mtd_pm_callback);
+#endif
+	return 0;
+}
+
+static void __exit cleanup_mtd(void)
+{
+#ifdef CONFIG_PM
+	if (mtd_pm_dev) {
+		pm_unregister(mtd_pm_dev);
+		mtd_pm_dev = NULL;
+	}
+#endif
+
+#ifdef CONFIG_PROC_FS
+        if (proc_mtd)
+		remove_proc_entry( "mtd", NULL);
+#endif
+}
+
+module_init(init_mtd);
+module_exit(cleanup_mtd);
+
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("David Woodhouse <dwmw2@infradead.org>");
+MODULE_DESCRIPTION("Core MTD registration and access routines");
