commit 46b5889cc2c54bac7d7e727a44d28a298df23cef
Author: Miquel Raynal <miquel.raynal@bootlin.com>
Date:   Tue Jan 14 10:09:52 2020 +0100

    mtd: implement proper partition handling
    
    Instead of collecting partitions in a flat list, create a hierarchy
    within the mtd_info structure: use a partitions list to keep track of
    the partitions of an MTD device (which might be itself a partition of
    another MTD device), a pointer to the parent device (NULL when the MTD
    device is the root one, not a partition).
    
    By also saving directly in mtd_info the offset of the partition, we
    can get rid of the mtd_part structure.
    
    While at it, be consistent in the naming of the mtd_info structures to
    ease the understanding of the new hierarchy: these structures are
    usually called 'mtd', unless there are multiple instances of the same
    structure. In this case, there is usually a parent/child bound so we
    will call them 'parent' and 'child'.
    
    Signed-off-by: Miquel Raynal <miquel.raynal@bootlin.com>
    Link: https://lore.kernel.org/linux-mtd/20200114090952.11232-1-miquel.raynal@bootlin.com

diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
index b841008a9eb7..c5935b2f9cd1 100644
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -349,6 +349,7 @@ static int mtdchar_writeoob(struct file *file, struct mtd_info *mtd,
 	uint64_t start, uint32_t length, void __user *ptr,
 	uint32_t __user *retp)
 {
+	struct mtd_info *master  = mtd_get_master(mtd);
 	struct mtd_file_info *mfi = file->private_data;
 	struct mtd_oob_ops ops = {};
 	uint32_t retlen;
@@ -360,7 +361,7 @@ static int mtdchar_writeoob(struct file *file, struct mtd_info *mtd,
 	if (length > 4096)
 		return -EINVAL;
 
-	if (!mtd->_write_oob)
+	if (!master->_write_oob)
 		return -EOPNOTSUPP;
 
 	ops.ooblen = length;
@@ -586,6 +587,7 @@ static int mtdchar_blkpg_ioctl(struct mtd_info *mtd,
 static int mtdchar_write_ioctl(struct mtd_info *mtd,
 		struct mtd_write_req __user *argp)
 {
+	struct mtd_info *master = mtd_get_master(mtd);
 	struct mtd_write_req req;
 	struct mtd_oob_ops ops = {};
 	const void __user *usr_data, *usr_oob;
@@ -597,9 +599,8 @@ static int mtdchar_write_ioctl(struct mtd_info *mtd,
 	usr_data = (const void __user *)(uintptr_t)req.usr_data;
 	usr_oob = (const void __user *)(uintptr_t)req.usr_oob;
 
-	if (!mtd->_write_oob)
+	if (!master->_write_oob)
 		return -EOPNOTSUPP;
-
 	ops.mode = req.mode;
 	ops.len = (size_t)req.len;
 	ops.ooblen = (size_t)req.ooblen;
@@ -635,6 +636,7 @@ static int mtdchar_ioctl(struct file *file, u_int cmd, u_long arg)
 {
 	struct mtd_file_info *mfi = file->private_data;
 	struct mtd_info *mtd = mfi->mtd;
+	struct mtd_info *master = mtd_get_master(mtd);
 	void __user *argp = (void __user *)arg;
 	int ret = 0;
 	struct mtd_info_user info;
@@ -824,7 +826,7 @@ static int mtdchar_ioctl(struct file *file, u_int cmd, u_long arg)
 	{
 		struct nand_oobinfo oi;
 
-		if (!mtd->ooblayout)
+		if (!master->ooblayout)
 			return -EOPNOTSUPP;
 
 		ret = get_oobinfo(mtd, &oi);
@@ -918,7 +920,7 @@ static int mtdchar_ioctl(struct file *file, u_int cmd, u_long arg)
 	{
 		struct nand_ecclayout_user *usrlay;
 
-		if (!mtd->ooblayout)
+		if (!master->ooblayout)
 			return -EOPNOTSUPP;
 
 		usrlay = kmalloc(sizeof(*usrlay), GFP_KERNEL);

commit 717bc8a6b4399f3ef907e92a01914fbae0465fd6
Author: Miquel Raynal <miquel.raynal@bootlin.com>
Date:   Thu Sep 19 21:06:21 2019 +0200

    mtd: Initialize all parameters of mtd_oob_ops
    
    Most of the time the ooboffs parameter of the mtd_oob_ops structure
    was initialized only when needed. Since the introduction of the
    SPI-NAND subsystem, this parameter is transferred into
    nand_page_io_req structure automatically and may be used by any
    SPI-NAND user.
    
    Before this happens, initialize all the structure parameters when they
    are created in mtdchar.c.
    
    Signed-off-by: Miquel Raynal <miquel.raynal@bootlin.com>

diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
index 975aed94f06c..b841008a9eb7 100644
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -174,7 +174,7 @@ static ssize_t mtdchar_read(struct file *file, char __user *buf, size_t count,
 			break;
 		case MTD_FILE_MODE_RAW:
 		{
-			struct mtd_oob_ops ops;
+			struct mtd_oob_ops ops = {};
 
 			ops.mode = MTD_OPS_RAW;
 			ops.datbuf = kbuf;
@@ -268,7 +268,7 @@ static ssize_t mtdchar_write(struct file *file, const char __user *buf, size_t c
 
 		case MTD_FILE_MODE_RAW:
 		{
-			struct mtd_oob_ops ops;
+			struct mtd_oob_ops ops = {};
 
 			ops.mode = MTD_OPS_RAW;
 			ops.datbuf = kbuf;
@@ -350,7 +350,7 @@ static int mtdchar_writeoob(struct file *file, struct mtd_info *mtd,
 	uint32_t __user *retp)
 {
 	struct mtd_file_info *mfi = file->private_data;
-	struct mtd_oob_ops ops;
+	struct mtd_oob_ops ops = {};
 	uint32_t retlen;
 	int ret = 0;
 
@@ -394,7 +394,7 @@ static int mtdchar_readoob(struct file *file, struct mtd_info *mtd,
 	uint32_t __user *retp)
 {
 	struct mtd_file_info *mfi = file->private_data;
-	struct mtd_oob_ops ops;
+	struct mtd_oob_ops ops = {};
 	int ret = 0;
 
 	if (length > 4096)
@@ -587,7 +587,7 @@ static int mtdchar_write_ioctl(struct mtd_info *mtd,
 		struct mtd_write_req __user *argp)
 {
 	struct mtd_write_req req;
-	struct mtd_oob_ops ops;
+	struct mtd_oob_ops ops = {};
 	const void __user *usr_data, *usr_oob;
 	int ret;
 

commit fd534e9b5fdcf9bab33c03cb3ade1a1ae5b23c20
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu May 23 11:14:39 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 102
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details you
      should have received a copy of the gnu general public license along
      with this program if not write to the free software foundation inc
      51 franklin st fifth floor boston ma 02110 1301 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 50 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190523091649.499889647@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
index 02389528f622..975aed94f06c 100644
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -1,20 +1,6 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * Copyright Â© 1999-2010 David Woodhouse <dwmw2@infradead.org>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- *
  */
 
 #include <linux/device.h>

commit 6c6bc9ea84d0008024606bf5ba10519e20d851bf
Author: Jann Horn <jannh@google.com>
Date:   Sat Jul 7 05:37:22 2018 +0200

    mtdchar: fix overflows in adjustment of `count`
    
    The first checks in mtdchar_read() and mtdchar_write() attempt to limit
    `count` such that `*ppos + count <= mtd->size`. However, they ignore the
    possibility of `*ppos > mtd->size`, allowing the calculation of `count` to
    wrap around. `mtdchar_lseek()` prevents seeking beyond mtd->size, but the
    pread/pwrite syscalls bypass this.
    
    I haven't found any codepath on which this actually causes dangerous
    behavior, but it seems like a sensible change anyway.
    
    Fixes: 1da177e4c3f4 ("Linux-2.6.12-rc2")
    Signed-off-by: Jann Horn <jannh@google.com>
    Signed-off-by: Boris Brezillon <boris.brezillon@bootlin.com>

diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
index cd67c85cc87d..02389528f622 100644
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -160,8 +160,12 @@ static ssize_t mtdchar_read(struct file *file, char __user *buf, size_t count,
 
 	pr_debug("MTD_read\n");
 
-	if (*ppos + count > mtd->size)
-		count = mtd->size - *ppos;
+	if (*ppos + count > mtd->size) {
+		if (*ppos < mtd->size)
+			count = mtd->size - *ppos;
+		else
+			count = 0;
+	}
 
 	if (!count)
 		return 0;
@@ -246,7 +250,7 @@ static ssize_t mtdchar_write(struct file *file, const char __user *buf, size_t c
 
 	pr_debug("MTD_write\n");
 
-	if (*ppos == mtd->size)
+	if (*ppos >= mtd->size)
 		return -ENOSPC;
 
 	if (*ppos + count > mtd->size)

commit 3fd14cdcc05a682b03743683ce3a726898b20555
Merge: 83c7c18b169b fe5f31a8010a
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Apr 6 12:15:41 2018 -0700

    Merge tag 'mtd/for-4.17' of git://git.infradead.org/linux-mtd
    
    Pull MTD updates from Boris Brezillon:
     "MTD Core:
       - Remove support for asynchronous erase (not implemented by any of
         the existing drivers anyway)
       - Remove Cyrille from the list of SPI NOR and MTD maintainers
       - Fix kernel doc headers
       - Allow users to define the partitions parsers they want to test
         through a DT property (compatible of the partitions subnode)
       - Remove the bfin-async-flash driver (the only architecture using it
         has been removed)
       - Fix pagetest test
       - Add extra checks in mtd_erase()
       - Simplify the MTD partition creation logic and get rid of
         mtd_add_device_partitions()
    
      MTD Drivers:
       - Add endianness information to the physmap DT binding
       - Add Eon EN29LV400A IDs to JEDEC probe logic
       - Use %*ph where appropriate
    
      SPI NOR Drivers:
       - Make fsl-quaspi assign different names to MTD devices connected to
         the same QSPI controller
       - Remove an unneeded driver.bus assigned in the fsl-qspi driver
    
      NAND Core:
       - Prepare arrival of the SPI NAND subsystem by implementing a generic
         (interface-agnostic) layer to ease manipulation of NAND devices
       - Move onenand code base to the drivers/mtd/nand/ dir
       - Rework timing mode selection
       - Provide a generic way for NAND chip drivers to flag a specific
         GET/SET FEATURE operation as supported/unsupported
       - Stop embedding ONFI/JEDEC param page in nand_chip
    
      NAND Drivers:
       - Rework/cleanup of the mxc driver
       - Various cleanups in the vf610 driver
       - Migrate the fsmc and vf610 to ->exec_op()
       - Get rid of the pxa driver (replaced by marvell_nand)
       - Support ->setup_data_interface() in the GPMI driver
       - Fix probe error path in several drivers
       - Remove support for unused hw_syndrome mode in sunxi_nand
       - Various minor improvements"
    
    * tag 'mtd/for-4.17' of git://git.infradead.org/linux-mtd: (89 commits)
      dt-bindings: fsl-quadspi: Add the example of two SPI NOR
      mtd: fsl-quadspi: Distinguish the mtd device names
      mtd: nand: Fix some function description mismatches in core.c
      mtd: fsl-quadspi: Remove unneeded driver.bus assignment
      mtd: rawnand: marvell: Rename ->ecc_clk into ->core_clk
      mtd: rawnand: s3c2410: enhance the probe function error path
      mtd: rawnand: tango: fix probe function error path
      mtd: rawnand: sh_flctl: fix the probe function error path
      mtd: rawnand: omap2: fix the probe function error path
      mtd: rawnand: mxc: fix probe function error path
      mtd: rawnand: denali: fix probe function error path
      mtd: rawnand: davinci: fix probe function error path
      mtd: rawnand: cafe: fix probe function error path
      mtd: rawnand: brcmnand: fix probe function error path
      mtd: rawnand: sunxi: Stop supporting ECC_HW_SYNDROME mode
      mtd: rawnand: marvell: Fix clock resource by adding a register clock
      mtd: ftl: Use DIV_ROUND_UP()
      mtd: Fix some function description mismatches in mtdcore.c
      mtd: physmap_of: update struct map_info's swap as per map requirement
      dt-bindings: mtd-physmap: Add endianness supports
      ...

commit 6de564939e14327148e31ddcf769e34105176447
Author: OuYang ZhiZhong <ouyzz@yealink.com>
Date:   Sun Mar 11 15:59:07 2018 +0800

    mtdchar: fix usage of mtd_ooblayout_ecc()
    
    Section was not properly computed. The value of OOB region definition is
    always ECC section 0 information in the OOB area, but we want to get all
    the ECC bytes information, so we should call
    mtd_ooblayout_ecc(mtd, section++, &oobregion) until it returns -ERANGE.
    
    Fixes: c2b78452a9db ("mtd: use mtd_ooblayout_xxx() helpers where appropriate")
    Cc: <stable@vger.kernel.org>
    Signed-off-by: OuYang ZhiZhong <ouyzz@yealink.com>
    Signed-off-by: Boris Brezillon <boris.brezillon@bootlin.com>

diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
index de8c902059b8..7d80a8bb96fe 100644
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -479,7 +479,7 @@ static int shrink_ecclayout(struct mtd_info *mtd,
 	for (i = 0; i < MTD_MAX_ECCPOS_ENTRIES;) {
 		u32 eccpos;
 
-		ret = mtd_ooblayout_ecc(mtd, section, &oobregion);
+		ret = mtd_ooblayout_ecc(mtd, section++, &oobregion);
 		if (ret < 0) {
 			if (ret != -ERANGE)
 				return ret;
@@ -526,7 +526,7 @@ static int get_oobinfo(struct mtd_info *mtd, struct nand_oobinfo *to)
 	for (i = 0; i < ARRAY_SIZE(to->eccpos);) {
 		u32 eccpos;
 
-		ret = mtd_ooblayout_ecc(mtd, section, &oobregion);
+		ret = mtd_ooblayout_ecc(mtd, section++, &oobregion);
 		if (ret < 0) {
 			if (ret != -ERANGE)
 				return ret;

commit 8f347c4232d5fc097599b711a3385722a6834005
Author: Boris Brezillon <boris.brezillon@bootlin.com>
Date:   Mon Feb 12 22:03:10 2018 +0100

    mtd: Unconditionally update ->fail_addr and ->addr in part_erase()
    
    ->fail_addr and ->addr can be updated no matter the result of
    parent->_erase(), we just need to remove the code doing the same thing
    in mtd_erase_callback() to avoid adjusting those fields twice.
    
    Note that this can be done because all MTD users have been converted to
    not pass an erase_info->callback() and are thus only taking the
    ->addr_fail and ->addr fields into account after part_erase() has
    returned.
    
    While we're at it, get rid of the erase_info->mtd field which was only
    needed to let mtd_erase_callback() get the partition device back.
    
    Signed-off-by: Boris Brezillon <boris.brezillon@bootlin.com>
    Reviewed-by: Richard Weinberger <richard@nod.at>

diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
index 2beb22dd6bbb..c06b33f80e75 100644
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -726,7 +726,6 @@ static int mtdchar_ioctl(struct file *file, u_int cmd, u_long arg)
 				erase->addr = einfo32.start;
 				erase->len = einfo32.length;
 			}
-			erase->mtd = mtd;
 
 			ret = mtd_erase(mtd, erase);
 			kfree(erase);

commit 884cfd9023ce6afe8bcf181ec988d8516eb32bf0
Author: Boris Brezillon <boris.brezillon@bootlin.com>
Date:   Mon Feb 12 22:03:09 2018 +0100

    mtd: Stop assuming mtd_erase() is asynchronous
    
    None of the mtd->_erase() implementations work in an asynchronous manner,
    so let's simplify MTD users that call mtd_erase(). All they need to do
    is check the value returned by mtd_erase() and assume that != 0 means
    failure.
    
    Signed-off-by: Boris Brezillon <boris.brezillon@bootlin.com>
    Reviewed-by: Richard Weinberger <richard@nod.at>

diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
index de8c902059b8..2beb22dd6bbb 100644
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -324,10 +324,6 @@ static ssize_t mtdchar_write(struct file *file, const char __user *buf, size_t c
     IOCTL calls for getting device parameters.
 
 ======================================================================*/
-static void mtdchar_erase_callback (struct erase_info *instr)
-{
-	wake_up((wait_queue_head_t *)instr->priv);
-}
 
 static int otp_select_filemode(struct mtd_file_info *mfi, int mode)
 {
@@ -709,11 +705,6 @@ static int mtdchar_ioctl(struct file *file, u_int cmd, u_long arg)
 		if (!erase)
 			ret = -ENOMEM;
 		else {
-			wait_queue_head_t waitq;
-			DECLARE_WAITQUEUE(wait, current);
-
-			init_waitqueue_head(&waitq);
-
 			if (cmd == MEMERASE64) {
 				struct erase_info_user64 einfo64;
 
@@ -736,30 +727,8 @@ static int mtdchar_ioctl(struct file *file, u_int cmd, u_long arg)
 				erase->len = einfo32.length;
 			}
 			erase->mtd = mtd;
-			erase->callback = mtdchar_erase_callback;
-			erase->priv = (unsigned long)&waitq;
-
-			/*
-			  FIXME: Allow INTERRUPTIBLE. Which means
-			  not having the wait_queue head on the stack.
-
-			  If the wq_head is on the stack, and we
-			  leave because we got interrupted, then the
-			  wq_head is no longer there when the
-			  callback routine tries to wake us up.
-			*/
+
 			ret = mtd_erase(mtd, erase);
-			if (!ret) {
-				set_current_state(TASK_UNINTERRUPTIBLE);
-				add_wait_queue(&waitq, &wait);
-				if (erase->state != MTD_ERASE_DONE &&
-				    erase->state != MTD_ERASE_FAILED)
-					schedule();
-				remove_wait_queue(&waitq, &wait);
-				set_current_state(TASK_RUNNING);
-
-				ret = (erase->state == MTD_ERASE_FAILED)?-EIO:0;
-			}
 			kfree(erase);
 		}
 		break;

commit 0db188f96b69957dec623c10b474d12b8b6038c2
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Sep 29 13:55:19 2017 -0400

    mtdchar: get rid of pointless access_ok()
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
index 3568294d4854..de8c902059b8 100644
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -375,12 +375,7 @@ static int mtdchar_writeoob(struct file *file, struct mtd_info *mtd,
 		return -EINVAL;
 
 	if (!mtd->_write_oob)
-		ret = -EOPNOTSUPP;
-	else
-		ret = access_ok(VERIFY_READ, ptr, length) ? 0 : -EFAULT;
-
-	if (ret)
-		return ret;
+		return -EOPNOTSUPP;
 
 	ops.ooblen = length;
 	ops.ooboffs = start & (mtd->writesize - 1);
@@ -419,9 +414,6 @@ static int mtdchar_readoob(struct file *file, struct mtd_info *mtd,
 	if (length > 4096)
 		return -EINVAL;
 
-	if (!access_ok(VERIFY_WRITE, ptr, length))
-		return -EFAULT;
-
 	ops.ooblen = length;
 	ops.ooboffs = start & (mtd->writesize - 1);
 	ops.datbuf = NULL;
@@ -618,9 +610,6 @@ static int mtdchar_write_ioctl(struct mtd_info *mtd,
 
 	usr_data = (const void __user *)(uintptr_t)req.usr_data;
 	usr_oob = (const void __user *)(uintptr_t)req.usr_oob;
-	if (!access_ok(VERIFY_READ, usr_data, req.len) ||
-	    !access_ok(VERIFY_READ, usr_oob, req.ooblen))
-		return -EFAULT;
 
 	if (!mtd->_write_oob)
 		return -EOPNOTSUPP;
@@ -662,21 +651,10 @@ static int mtdchar_ioctl(struct file *file, u_int cmd, u_long arg)
 	struct mtd_info *mtd = mfi->mtd;
 	void __user *argp = (void __user *)arg;
 	int ret = 0;
-	u_long size;
 	struct mtd_info_user info;
 
 	pr_debug("MTD_ioctl\n");
 
-	size = (cmd & IOCSIZE_MASK) >> IOCSIZE_SHIFT;
-	if (cmd & IOC_IN) {
-		if (!access_ok(VERIFY_READ, argp, size))
-			return -EFAULT;
-	}
-	if (cmd & IOC_OUT) {
-		if (!access_ok(VERIFY_WRITE, argp, size))
-			return -EFAULT;
-	}
-
 	switch (cmd) {
 	case MEMGETREGIONCOUNT:
 		if (copy_to_user(argp, &(mtd->numeraseregions), sizeof(int)))

commit 5d708ecc6c7718c22bcacabff0fbb32ecd19ad6b
Author: Nobuhiro Iwamatsu <nobuhiro.iwamatsu.kw@hitachi.com>
Date:   Fri Jan 27 10:36:38 2017 +0900

    mtd: Fix typo: "occured" -> "occurred"
    
    Trivial typo fix in comment.
    
    Signed-off-by: Nobuhiro Iwamatsu <nobuhiro.iwamatsu.kw@hitachi.com>
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>

diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
index ce5ccc573a9c..3568294d4854 100644
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -451,7 +451,7 @@ static int mtdchar_readoob(struct file *file, struct mtd_info *mtd,
 	 * data. For our userspace tools it is important to dump areas
 	 * with ECC errors!
 	 * For kernel internal usage it also might return -EUCLEAN
-	 * to signal the caller that a bitflip has occured and has
+	 * to signal the caller that a bitflip has occurred and has
 	 * been corrected by the ECC algorithm.
 	 *
 	 * Note: currently the standard NAND function, nand_read_oob_std,

commit 7c0f6ba682b9c7632072ffbedf8d328c8f3c42ba
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Dec 24 11:46:01 2016 -0800

    Replace <asm/uaccess.h> with <linux/uaccess.h> globally
    
    This was entirely automated, using the script by Al:
    
      PATT='^[[:blank:]]*#[[:blank:]]*include[[:blank:]]*<asm/uaccess.h>'
      sed -i -e "s!$PATT!#include <linux/uaccess.h>!" \
            $(git grep -l "$PATT"|grep -v ^include/linux/uaccess.h)
    
    to do the replacement at the end of the merge window.
    
    Requested-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
index 2a47a3f0e730..ce5ccc573a9c 100644
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -37,7 +37,7 @@
 #include <linux/mtd/partitions.h>
 #include <linux/mtd/map.h>
 
-#include <asm/uaccess.h>
+#include <linux/uaccess.h>
 
 #include "mtdcore.h"
 

commit aab616e31d1c7ec3726f7f5cbdaaec98759ebe93
Author: Boris Brezillon <boris.brezillon@free-electrons.com>
Date:   Thu Feb 4 10:16:18 2016 +0100

    mtd: kill the nand_ecclayout struct
    
    Now that all MTD drivers have moved to the mtd_ooblayout_ops model we can
    safely remove the struct nand_ecclayout definition, and all the remaining
    places where it was still used.
    
    Signed-off-by: Boris Brezillon <boris.brezillon@free-electrons.com>

diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
index 3fad2c7425b0..2a47a3f0e730 100644
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -465,12 +465,12 @@ static int mtdchar_readoob(struct file *file, struct mtd_info *mtd,
 }
 
 /*
- * Copies (and truncates, if necessary) data from the larger struct,
- * nand_ecclayout, to the smaller, deprecated layout struct,
- * nand_ecclayout_user. This is necessary only to support the deprecated
- * API ioctl ECCGETLAYOUT while allowing all new functionality to use
- * nand_ecclayout flexibly (i.e. the struct may change size in new
- * releases without requiring major rewrites).
+ * Copies (and truncates, if necessary) OOB layout information to the
+ * deprecated layout struct, nand_ecclayout_user. This is necessary only to
+ * support the deprecated API ioctl ECCGETLAYOUT while allowing all new
+ * functionality to use mtd_ooblayout_ops flexibly (i.e. mtd_ooblayout_ops
+ * can describe any kind of OOB layout with almost zero overhead from a
+ * memory usage point of view).
  */
 static int shrink_ecclayout(struct mtd_info *mtd,
 			    struct nand_ecclayout_user *to)

commit adbbc3bc827eb1f43a932d783f09ba55c8ec8379
Author: Boris Brezillon <boris.brezillon@free-electrons.com>
Date:   Wed Feb 3 19:01:31 2016 +0100

    mtd: create an mtd_ooblayout_ops struct to ease ECC layout definition
    
    ECC layout definitions are currently exposed using the nand_ecclayout
    struct which embeds oobfree and eccpos arrays with predefined size.
    This approach was acceptable when NAND chips were providing relatively
    small OOB regions, but MLC and TLC now provide OOB regions of several
    hundreds of bytes, which implies a non negligible overhead for everybody
    even those who only need to support legacy NANDs.
    
    Create an mtd_ooblayout_ops interface providing the same functionality
    (expose the ECC and oobfree layout) without the need for this huge
    structure.
    
    The mtd->ecclayout is now deprecated and should be replaced by the
    equivalent mtd_ooblayout_ops. In the meantime we provide a wrapper around
    the ->ecclayout field to ease migration to this new model.
    
    Signed-off-by: Boris Brezillon <boris.brezillon@free-electrons.com>

diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
index cd64ab76dd7b..3fad2c7425b0 100644
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -888,7 +888,7 @@ static int mtdchar_ioctl(struct file *file, u_int cmd, u_long arg)
 	{
 		struct nand_oobinfo oi;
 
-		if (!mtd->ecclayout)
+		if (!mtd->ooblayout)
 			return -EOPNOTSUPP;
 
 		ret = get_oobinfo(mtd, &oi);
@@ -982,7 +982,7 @@ static int mtdchar_ioctl(struct file *file, u_int cmd, u_long arg)
 	{
 		struct nand_ecclayout_user *usrlay;
 
-		if (!mtd->ecclayout)
+		if (!mtd->ooblayout)
 			return -EOPNOTSUPP;
 
 		usrlay = kmalloc(sizeof(*usrlay), GFP_KERNEL);

commit c2b78452a9db438d592bf72af7bb2ae3062cb922
Author: Boris Brezillon <boris.brezillon@free-electrons.com>
Date:   Wed Feb 3 20:10:30 2016 +0100

    mtd: use mtd_ooblayout_xxx() helpers where appropriate
    
    The mtd_ooblayout_xxx() helper functions have been added to avoid direct
    accesses to the ecclayout field, and thus ease for future reworks.
    Use these helpers in all places where the oobfree[] and eccpos[] arrays
    where directly accessed.
    
    Signed-off-by: Boris Brezillon <boris.brezillon@free-electrons.com>

diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
index 6d19835b80a9..cd64ab76dd7b 100644
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -472,28 +472,101 @@ static int mtdchar_readoob(struct file *file, struct mtd_info *mtd,
  * nand_ecclayout flexibly (i.e. the struct may change size in new
  * releases without requiring major rewrites).
  */
-static int shrink_ecclayout(const struct nand_ecclayout *from,
-		struct nand_ecclayout_user *to)
+static int shrink_ecclayout(struct mtd_info *mtd,
+			    struct nand_ecclayout_user *to)
 {
-	int i;
+	struct mtd_oob_region oobregion;
+	int i, section = 0, ret;
 
-	if (!from || !to)
+	if (!mtd || !to)
 		return -EINVAL;
 
 	memset(to, 0, sizeof(*to));
 
-	to->eccbytes = min((int)from->eccbytes, MTD_MAX_ECCPOS_ENTRIES);
-	for (i = 0; i < to->eccbytes; i++)
-		to->eccpos[i] = from->eccpos[i];
+	to->eccbytes = 0;
+	for (i = 0; i < MTD_MAX_ECCPOS_ENTRIES;) {
+		u32 eccpos;
+
+		ret = mtd_ooblayout_ecc(mtd, section, &oobregion);
+		if (ret < 0) {
+			if (ret != -ERANGE)
+				return ret;
+
+			break;
+		}
+
+		eccpos = oobregion.offset;
+		for (; i < MTD_MAX_ECCPOS_ENTRIES &&
+		       eccpos < oobregion.offset + oobregion.length; i++) {
+			to->eccpos[i] = eccpos++;
+			to->eccbytes++;
+		}
+	}
 
 	for (i = 0; i < MTD_MAX_OOBFREE_ENTRIES; i++) {
-		if (from->oobfree[i].length == 0 &&
-				from->oobfree[i].offset == 0)
+		ret = mtd_ooblayout_free(mtd, i, &oobregion);
+		if (ret < 0) {
+			if (ret != -ERANGE)
+				return ret;
+
+			break;
+		}
+
+		to->oobfree[i].offset = oobregion.offset;
+		to->oobfree[i].length = oobregion.length;
+		to->oobavail += to->oobfree[i].length;
+	}
+
+	return 0;
+}
+
+static int get_oobinfo(struct mtd_info *mtd, struct nand_oobinfo *to)
+{
+	struct mtd_oob_region oobregion;
+	int i, section = 0, ret;
+
+	if (!mtd || !to)
+		return -EINVAL;
+
+	memset(to, 0, sizeof(*to));
+
+	to->eccbytes = 0;
+	for (i = 0; i < ARRAY_SIZE(to->eccpos);) {
+		u32 eccpos;
+
+		ret = mtd_ooblayout_ecc(mtd, section, &oobregion);
+		if (ret < 0) {
+			if (ret != -ERANGE)
+				return ret;
+
 			break;
-		to->oobavail += from->oobfree[i].length;
-		to->oobfree[i] = from->oobfree[i];
+		}
+
+		if (oobregion.length + i > ARRAY_SIZE(to->eccpos))
+			return -EINVAL;
+
+		eccpos = oobregion.offset;
+		for (; eccpos < oobregion.offset + oobregion.length; i++) {
+			to->eccpos[i] = eccpos++;
+			to->eccbytes++;
+		}
 	}
 
+	for (i = 0; i < 8; i++) {
+		ret = mtd_ooblayout_free(mtd, i, &oobregion);
+		if (ret < 0) {
+			if (ret != -ERANGE)
+				return ret;
+
+			break;
+		}
+
+		to->oobfree[i][0] = oobregion.offset;
+		to->oobfree[i][1] = oobregion.length;
+	}
+
+	to->useecc = MTD_NANDECC_AUTOPLACE;
+
 	return 0;
 }
 
@@ -817,14 +890,10 @@ static int mtdchar_ioctl(struct file *file, u_int cmd, u_long arg)
 
 		if (!mtd->ecclayout)
 			return -EOPNOTSUPP;
-		if (mtd->ecclayout->eccbytes > ARRAY_SIZE(oi.eccpos))
-			return -EINVAL;
 
-		oi.useecc = MTD_NANDECC_AUTOPLACE;
-		memcpy(&oi.eccpos, mtd->ecclayout->eccpos, sizeof(oi.eccpos));
-		memcpy(&oi.oobfree, mtd->ecclayout->oobfree,
-		       sizeof(oi.oobfree));
-		oi.eccbytes = mtd->ecclayout->eccbytes;
+		ret = get_oobinfo(mtd, &oi);
+		if (ret)
+			return ret;
 
 		if (copy_to_user(argp, &oi, sizeof(struct nand_oobinfo)))
 			return -EFAULT;
@@ -920,7 +989,7 @@ static int mtdchar_ioctl(struct file *file, u_int cmd, u_long arg)
 		if (!usrlay)
 			return -ENOMEM;
 
-		shrink_ecclayout(mtd->ecclayout, usrlay);
+		shrink_ecclayout(mtd, usrlay);
 
 		if (copy_to_user(argp, usrlay, sizeof(*usrlay)))
 			ret = -EFAULT;

commit 53bb724f94f57b67213e08a4c155c8c5eb74c644
Author: Brian Norris <computersforpeace@gmail.com>
Date:   Mon Sep 21 13:26:59 2015 -0700

    mtd: provide proper 32/64-bit compat_ioctl() support for BLKPG
    
    After a bit of poking around wondering why my 32-bit user-space can't
    seem to send a proper ioctl(BLKPG) to an MTD on my 64-bit kernel
    (ARM64), I noticed that struct blkpg_ioctl_arg is actually pretty
    unsuitable for use in the ioctl() ABI, due to its use of raw pointers,
    and its lack of alignment/packing restrictions (32-bit arch'es tend to
    pack the 4 fields into 4 32-bit words, whereas 64-bit arch'es would add
    padding after the third int, and make this 6 32-bit words).
    
    Anyway, this means BLKPG deserves some special compat_ioctl handling. Do
    the conversion in a small shim for MTD.
    
    block/compat_ioctl.c already has compat support for the block subsystem,
    but it does so by a re-marshalling data to/from user-space (see
    compat_blkpg_ioctl()). Personally, I think this approach is cleaner.
    
    Tested only on MTD, with an ARM32 user space on an ARM64 kernel.
    
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>

diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
index 55fa27ecf4e1..6d19835b80a9 100644
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -498,21 +498,17 @@ static int shrink_ecclayout(const struct nand_ecclayout *from,
 }
 
 static int mtdchar_blkpg_ioctl(struct mtd_info *mtd,
-			   struct blkpg_ioctl_arg __user *arg)
+			       struct blkpg_ioctl_arg *arg)
 {
-	struct blkpg_ioctl_arg a;
 	struct blkpg_partition p;
 
 	if (!capable(CAP_SYS_ADMIN))
 		return -EPERM;
 
-	if (copy_from_user(&a, arg, sizeof(struct blkpg_ioctl_arg)))
+	if (copy_from_user(&p, arg->data, sizeof(p)))
 		return -EFAULT;
 
-	if (copy_from_user(&p, a.data, sizeof(struct blkpg_partition)))
-		return -EFAULT;
-
-	switch (a.op) {
+	switch (arg->op) {
 	case BLKPG_ADD_PARTITION:
 
 		/* Only master mtd device must be used to add partitions */
@@ -966,8 +962,13 @@ static int mtdchar_ioctl(struct file *file, u_int cmd, u_long arg)
 
 	case BLKPG:
 	{
-		ret = mtdchar_blkpg_ioctl(mtd,
-		      (struct blkpg_ioctl_arg __user *)arg);
+		struct blkpg_ioctl_arg __user *blk_arg = argp;
+		struct blkpg_ioctl_arg a;
+
+		if (copy_from_user(&a, blk_arg, sizeof(a)))
+			ret = -EFAULT;
+		else
+			ret = mtdchar_blkpg_ioctl(mtd, &a);
 		break;
 	}
 
@@ -1046,6 +1047,29 @@ static long mtdchar_compat_ioctl(struct file *file, unsigned int cmd,
 				&buf_user->start);
 		break;
 	}
+
+	case BLKPG:
+	{
+		/* Convert from blkpg_compat_ioctl_arg to blkpg_ioctl_arg */
+		struct blkpg_compat_ioctl_arg __user *uarg = argp;
+		struct blkpg_compat_ioctl_arg compat_arg;
+		struct blkpg_ioctl_arg a;
+
+		if (copy_from_user(&compat_arg, uarg, sizeof(compat_arg))) {
+			ret = -EFAULT;
+			break;
+		}
+
+		memset(&a, 0, sizeof(a));
+		a.op = compat_arg.op;
+		a.flags = compat_arg.flags;
+		a.datalen = compat_arg.datalen;
+		a.data = compat_ptr(compat_arg.data);
+
+		ret = mtdchar_blkpg_ioctl(mtd, &a);
+		break;
+	}
+
 	default:
 		ret = mtdchar_ioctl(file, cmd, (unsigned long)argp);
 	}

commit b4caecd48005fbed3949dde6c1cb233142fd69e9
Author: Christoph Hellwig <hch@lst.de>
Date:   Wed Jan 14 10:42:32 2015 +0100

    fs: introduce f_op->mmap_capabilities for nommu mmap support
    
    Since "BDI: Provide backing device capability information [try #3]" the
    backing_dev_info structure also provides flags for the kind of mmap
    operation available in a nommu environment, which is entirely unrelated
    to it's original purpose.
    
    Introduce a new nommu-only file operation to provide this information to
    the nommu mmap code instead.  Splitting this from the backing_dev_info
    structure allows to remove lots of backing_dev_info instance that aren't
    otherwise needed, and entirely gets rid of the concept of providing a
    backing_dev_info for a character device.  It also removes the need for
    the mtd_inodefs filesystem.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Tejun Heo <tj@kernel.org>
    Acked-by: Brian Norris <computersforpeace@gmail.com>
    Signed-off-by: Jens Axboe <axboe@fb.com>

diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
index 53563955931b..55fa27ecf4e1 100644
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -49,7 +49,6 @@ static DEFINE_MUTEX(mtd_mutex);
  */
 struct mtd_file_info {
 	struct mtd_info *mtd;
-	struct inode *ino;
 	enum mtd_file_modes mode;
 };
 
@@ -59,10 +58,6 @@ static loff_t mtdchar_lseek(struct file *file, loff_t offset, int orig)
 	return fixed_size_llseek(file, offset, orig, mfi->mtd->size);
 }
 
-static int count;
-static struct vfsmount *mnt;
-static struct file_system_type mtd_inodefs_type;
-
 static int mtdchar_open(struct inode *inode, struct file *file)
 {
 	int minor = iminor(inode);
@@ -70,7 +65,6 @@ static int mtdchar_open(struct inode *inode, struct file *file)
 	int ret = 0;
 	struct mtd_info *mtd;
 	struct mtd_file_info *mfi;
-	struct inode *mtd_ino;
 
 	pr_debug("MTD_open\n");
 
@@ -78,10 +72,6 @@ static int mtdchar_open(struct inode *inode, struct file *file)
 	if ((file->f_mode & FMODE_WRITE) && (minor & 1))
 		return -EACCES;
 
-	ret = simple_pin_fs(&mtd_inodefs_type, &mnt, &count);
-	if (ret)
-		return ret;
-
 	mutex_lock(&mtd_mutex);
 	mtd = get_mtd_device(NULL, devnum);
 
@@ -95,43 +85,26 @@ static int mtdchar_open(struct inode *inode, struct file *file)
 		goto out1;
 	}
 
-	mtd_ino = iget_locked(mnt->mnt_sb, devnum);
-	if (!mtd_ino) {
-		ret = -ENOMEM;
-		goto out1;
-	}
-	if (mtd_ino->i_state & I_NEW) {
-		mtd_ino->i_private = mtd;
-		mtd_ino->i_mode = S_IFCHR;
-		mtd_ino->i_data.backing_dev_info = mtd->backing_dev_info;
-		unlock_new_inode(mtd_ino);
-	}
-	file->f_mapping = mtd_ino->i_mapping;
-
 	/* You can't open it RW if it's not a writeable device */
 	if ((file->f_mode & FMODE_WRITE) && !(mtd->flags & MTD_WRITEABLE)) {
 		ret = -EACCES;
-		goto out2;
+		goto out1;
 	}
 
 	mfi = kzalloc(sizeof(*mfi), GFP_KERNEL);
 	if (!mfi) {
 		ret = -ENOMEM;
-		goto out2;
+		goto out1;
 	}
-	mfi->ino = mtd_ino;
 	mfi->mtd = mtd;
 	file->private_data = mfi;
 	mutex_unlock(&mtd_mutex);
 	return 0;
 
-out2:
-	iput(mtd_ino);
 out1:
 	put_mtd_device(mtd);
 out:
 	mutex_unlock(&mtd_mutex);
-	simple_release_fs(&mnt, &count);
 	return ret;
 } /* mtdchar_open */
 
@@ -148,12 +121,9 @@ static int mtdchar_close(struct inode *inode, struct file *file)
 	if ((file->f_mode & FMODE_WRITE))
 		mtd_sync(mtd);
 
-	iput(mfi->ino);
-
 	put_mtd_device(mtd);
 	file->private_data = NULL;
 	kfree(mfi);
-	simple_release_fs(&mnt, &count);
 
 	return 0;
 } /* mtdchar_close */
@@ -1117,6 +1087,13 @@ static unsigned long mtdchar_get_unmapped_area(struct file *file,
 	ret = mtd_get_unmapped_area(mtd, len, offset, flags);
 	return ret == -EOPNOTSUPP ? -ENODEV : ret;
 }
+
+static unsigned mtdchar_mmap_capabilities(struct file *file)
+{
+	struct mtd_file_info *mfi = file->private_data;
+
+	return mtd_mmap_capabilities(mfi->mtd);
+}
 #endif
 
 /*
@@ -1160,27 +1137,10 @@ static const struct file_operations mtd_fops = {
 	.mmap		= mtdchar_mmap,
 #ifndef CONFIG_MMU
 	.get_unmapped_area = mtdchar_get_unmapped_area,
+	.mmap_capabilities = mtdchar_mmap_capabilities,
 #endif
 };
 
-static const struct super_operations mtd_ops = {
-	.drop_inode = generic_delete_inode,
-	.statfs = simple_statfs,
-};
-
-static struct dentry *mtd_inodefs_mount(struct file_system_type *fs_type,
-				int flags, const char *dev_name, void *data)
-{
-	return mount_pseudo(fs_type, "mtd_inode:", &mtd_ops, NULL, MTD_INODE_FS_MAGIC);
-}
-
-static struct file_system_type mtd_inodefs_type = {
-       .name = "mtd_inodefs",
-       .mount = mtd_inodefs_mount,
-       .kill_sb = kill_anon_super,
-};
-MODULE_ALIAS_FS("mtd_inodefs");
-
 int __init init_mtdchar(void)
 {
 	int ret;
@@ -1193,23 +1153,11 @@ int __init init_mtdchar(void)
 		return ret;
 	}
 
-	ret = register_filesystem(&mtd_inodefs_type);
-	if (ret) {
-		pr_err("Can't register mtd_inodefs filesystem, error %d\n",
-		       ret);
-		goto err_unregister_chdev;
-	}
-
-	return ret;
-
-err_unregister_chdev:
-	__unregister_chrdev(MTD_CHAR_MAJOR, 0, 1 << MINORBITS, "mtd");
 	return ret;
 }
 
 void __exit cleanup_mtdchar(void)
 {
-	unregister_filesystem(&mtd_inodefs_type);
 	__unregister_chrdev(MTD_CHAR_MAJOR, 0, 1 << MINORBITS, "mtd");
 }
 

commit 1cc8d8413327a684cd5e93cd52ececb0223bb40b
Author: Brian Norris <computersforpeace@gmail.com>
Date:   Mon Jul 21 19:08:13 2014 -0700

    mtd: terminate user-provided string
    
    Noticed by Coverity as a potential security issue.
    
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>

diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
index a0f54e80670c..53563955931b 100644
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -549,6 +549,9 @@ static int mtdchar_blkpg_ioctl(struct mtd_info *mtd,
 		if (mtd_is_partition(mtd))
 			return -EINVAL;
 
+		/* Sanitize user input */
+		p.devname[BLKPG_DEVNAMELTH - 1] = '\0';
+
 		return mtd_add_partition(mtd, p.devname, p.start, p.length);
 
 	case BLKPG_DEL_PARTITION:

commit f62cde49f9f02d6c205ab310b8fd4a29ddc49329
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Thu May 1 20:40:54 2014 +0200

    mtd: Fix warning in access_ok() parameter passing
    
    On m68k, where access_ok() doesn't cast the address parameter:
    
    drivers/mtd/mtdchar.c: In function 'mtdchar_write_ioctl':
    drivers/mtd/mtdchar.c:575:4: warning: passing argument 2 of 'access_ok' makes pointer from integer without a cast [enabled by default]
    arch/m68k/include/asm/uaccess_mm.h:17:90: note: expected 'const void *' but argument is of type '__u64'
    drivers/mtd/mtdchar.c:576:4: warning: passing argument 2 of 'access_ok' makes pointer from integer without a cast [enabled by default]
    arch/m68k/include/asm/uaccess_mm.h:17:90: note: expected 'const void *' but argument is of type '__u64'
    
    The address parameter of access_ok() is really a userspace pointer.
    On most architectures, access_ok() is a macro that casts the address
    parameter, hiding issues in its users.
    
    Move around and use the existing usr_data and usr_oob temporary variables
    to kill the warnings. Add a few "consts", and make more use of the
    temporaries while we're at it.
    
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>

diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
index 7d4e7b9da3a1..a0f54e80670c 100644
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -568,13 +568,18 @@ static int mtdchar_write_ioctl(struct mtd_info *mtd,
 {
 	struct mtd_write_req req;
 	struct mtd_oob_ops ops;
-	void __user *usr_data, *usr_oob;
+	const void __user *usr_data, *usr_oob;
 	int ret;
 
-	if (copy_from_user(&req, argp, sizeof(req)) ||
-			!access_ok(VERIFY_READ, req.usr_data, req.len) ||
-			!access_ok(VERIFY_READ, req.usr_oob, req.ooblen))
+	if (copy_from_user(&req, argp, sizeof(req)))
 		return -EFAULT;
+
+	usr_data = (const void __user *)(uintptr_t)req.usr_data;
+	usr_oob = (const void __user *)(uintptr_t)req.usr_oob;
+	if (!access_ok(VERIFY_READ, usr_data, req.len) ||
+	    !access_ok(VERIFY_READ, usr_oob, req.ooblen))
+		return -EFAULT;
+
 	if (!mtd->_write_oob)
 		return -EOPNOTSUPP;
 
@@ -583,10 +588,7 @@ static int mtdchar_write_ioctl(struct mtd_info *mtd,
 	ops.ooblen = (size_t)req.ooblen;
 	ops.ooboffs = 0;
 
-	usr_data = (void __user *)(uintptr_t)req.usr_data;
-	usr_oob = (void __user *)(uintptr_t)req.usr_oob;
-
-	if (req.usr_data) {
+	if (usr_data) {
 		ops.datbuf = memdup_user(usr_data, ops.len);
 		if (IS_ERR(ops.datbuf))
 			return PTR_ERR(ops.datbuf);
@@ -594,7 +596,7 @@ static int mtdchar_write_ioctl(struct mtd_info *mtd,
 		ops.datbuf = NULL;
 	}
 
-	if (req.usr_oob) {
+	if (usr_oob) {
 		ops.oobbuf = memdup_user(usr_oob, ops.ooblen);
 		if (IS_ERR(ops.oobbuf)) {
 			kfree(ops.datbuf);

commit 9a78bc83b4c31f67202b7b0a77fa25da732f44a3
Author: Christian Riesch <christian.riesch@omicron.at>
Date:   Thu Mar 6 12:42:37 2014 +0100

    mtd: Fix the behavior of OTP write if there is not enough room for data
    
    If a write to one time programmable memory (OTP) hits the end of this
    memory area, no more data can be written. The count variable in
    mtdchar_write() in drivers/mtd/mtdchar.c is not decreased anymore.
    We are trapped in the loop forever, mtdchar_write() will never return
    in this case.
    
    The desired behavior of a write in such a case is described in [1]:
    - Try to write as much data as possible, truncate the write to fit into
      the available memory and return the number of bytes that actually
      have been written.
    - If no data could be written at all, return -ENOSPC.
    
    This patch fixes the behavior of OTP write if there is not enough space
    for all data:
    
    1) mtd_write_user_prot_reg() in drivers/mtd/mtdcore.c is modified to
       return -ENOSPC if no data could be written at all.
    2) mtdchar_write() is modified to handle -ENOSPC correctly. Exit if a
       write returned -ENOSPC and yield the correct return value, either
       then number of bytes that could be written, or -ENOSPC, if no data
       could be written at all.
    
    Furthermore the patch harmonizes the behavior of the OTP memory write
    in drivers/mtd/devices/mtd_dataflash.c with the other implementations
    and the requirements from [1]. Instead of returning -EINVAL if the data
    does not fit into the OTP memory, we try to write as much data as
    possible/truncate the write.
    
    [1] http://pubs.opengroup.org/onlinepubs/9699919799/functions/write.html
    
    Signed-off-by: Christian Riesch <christian.riesch@omicron.at>
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>

diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
index 250798cf76aa..7d4e7b9da3a1 100644
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -324,6 +324,15 @@ static ssize_t mtdchar_write(struct file *file, const char __user *buf, size_t c
 		default:
 			ret = mtd_write(mtd, *ppos, len, &retlen, kbuf);
 		}
+
+		/*
+		 * Return -ENOSPC only if no data could be written at all.
+		 * Otherwise just return the number of bytes that actually
+		 * have been written.
+		 */
+		if ((ret == -ENOSPC) && (total_retlen))
+			break;
+
 		if (!ret) {
 			*ppos += retlen;
 			total_retlen += retlen;

commit 4b78fc42f3e3f07687dc27efc1153d29e360afa1
Author: Christian Riesch <christian.riesch@omicron.at>
Date:   Tue Jan 28 09:29:44 2014 +0100

    mtd: Add a retlen parameter to _get_{fact,user}_prot_info
    
    Signed-off-by: Christian Riesch <christian.riesch@omicron.at>
    Cc: Artem Bityutskiy <Artem.Bityutskiy@linux.intel.com>
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>

diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
index 2147e733533b..250798cf76aa 100644
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -889,25 +889,26 @@ static int mtdchar_ioctl(struct file *file, u_int cmd, u_long arg)
 	case OTPGETREGIONINFO:
 	{
 		struct otp_info *buf = kmalloc(4096, GFP_KERNEL);
+		size_t retlen;
 		if (!buf)
 			return -ENOMEM;
 		switch (mfi->mode) {
 		case MTD_FILE_MODE_OTP_FACTORY:
-			ret = mtd_get_fact_prot_info(mtd, buf, 4096);
+			ret = mtd_get_fact_prot_info(mtd, 4096, &retlen, buf);
 			break;
 		case MTD_FILE_MODE_OTP_USER:
-			ret = mtd_get_user_prot_info(mtd, buf, 4096);
+			ret = mtd_get_user_prot_info(mtd, 4096, &retlen, buf);
 			break;
 		default:
 			ret = -EINVAL;
 			break;
 		}
-		if (ret >= 0) {
+		if (!ret) {
 			if (cmd == OTPGETREGIONCOUNT) {
-				int nbr = ret / sizeof(struct otp_info);
+				int nbr = retlen / sizeof(struct otp_info);
 				ret = copy_to_user(argp, &nbr, sizeof(int));
 			} else
-				ret = copy_to_user(argp, buf, ret);
+				ret = copy_to_user(argp, buf, retlen);
 			if (ret)
 				ret = -EFAULT;
 		}

commit b99959323732ed0c81da2488252f64c02ad37fbe
Author: Vladimir Zapolskiy <vladimir_zapolskiy@mentor.com>
Date:   Mon Oct 28 18:08:15 2013 +0200

    mtd: mtdchar: return expected errors on mmap() call
    
    According both to POSIX.1-2008 and Linux Programmer's Manual mmap()
    syscall shouldn't return undocumented ENOSYS, this change replaces
    the errno with more appropriate ENODEV and EACCESS.
    
    Signed-off-by: Vladimir Zapolskiy <vladimir_zapolskiy@mentor.com>
    Cc: David Woodhouse <David.Woodhouse@intel.com>
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>

diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
index 9aa0c5e49c1d..2147e733533b 100644
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -1100,7 +1100,7 @@ static unsigned long mtdchar_get_unmapped_area(struct file *file,
 		return (unsigned long) -EINVAL;
 
 	ret = mtd_get_unmapped_area(mtd, len, offset, flags);
-	return ret == -EOPNOTSUPP ? -ENOSYS : ret;
+	return ret == -EOPNOTSUPP ? -ENODEV : ret;
 }
 #endif
 
@@ -1125,9 +1125,9 @@ static int mtdchar_mmap(struct file *file, struct vm_area_struct *vma)
 #endif
 		return vm_iomap_memory(vma, map->phys, map->size);
 	}
-	return -ENOSYS;
+	return -ENODEV;
 #else
-	return vma->vm_flags & VM_SHARED ? 0 : -ENOSYS;
+	return vma->vm_flags & VM_SHARED ? 0 : -EACCES;
 #endif
 }
 

commit f83c3838b9146b891d0405d3a83660e8f6aed02f
Author: Ezequiel Garcia <ezequiel.garcia@free-electrons.com>
Date:   Sun Oct 13 18:05:23 2013 -0300

    mtd: Move major number definitions to major.h
    
    This patch moves the char and block major number definitions
    to major.h to be with the rest of the major numbers.
    While doing this, include major.h in the files that need it.
    
    Signed-off-by: Ezequiel Garcia <ezequiel.garcia@free-electrons.com>
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>

diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
index 684bfa39e4ee..9aa0c5e49c1d 100644
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -32,6 +32,7 @@
 #include <linux/mount.h>
 #include <linux/blkpg.h>
 #include <linux/magic.h>
+#include <linux/major.h>
 #include <linux/mtd/mtd.h>
 #include <linux/mtd/partitions.h>
 #include <linux/mtd/map.h>

commit b959957f9428b05cd5e138beebee04897bfd673d
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sun Jun 16 20:27:42 2013 +0400

    mtdchar: switch to fixed_size_llseek()
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
index c719879284bd..684bfa39e4ee 100644
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -55,25 +55,7 @@ struct mtd_file_info {
 static loff_t mtdchar_lseek(struct file *file, loff_t offset, int orig)
 {
 	struct mtd_file_info *mfi = file->private_data;
-	struct mtd_info *mtd = mfi->mtd;
-
-	switch (orig) {
-	case SEEK_SET:
-		break;
-	case SEEK_CUR:
-		offset += file->f_pos;
-		break;
-	case SEEK_END:
-		offset += mtd->size;
-		break;
-	default:
-		return -EINVAL;
-	}
-
-	if (offset >= 0 && offset <= mtd->size)
-		return file->f_pos = offset;
-
-	return -EINVAL;
+	return fixed_size_llseek(file, offset, orig, mfi->mtd->size);
 }
 
 static int count;

commit a637b0d45947df686979b85361ad5bfa9d19fdd3
Merge: f78089e87e57 cdb6404cc53a
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu May 9 10:15:46 2013 -0700

    Merge tag 'for-linus-20130509' of git://git.infradead.org/linux-mtd
    
    Pull MTD update from David Woodhouse:
    
     - Lots of cleanups from Artem, including deletion of some obsolete
       drivers
    
     - Support partitions larger than 4GiB in device tree
    
     - Support for new SPI chips
    
    * tag 'for-linus-20130509' of git://git.infradead.org/linux-mtd: (83 commits)
      mtd: omap2: Use module_platform_driver()
      mtd: bf5xx_nand: Use module_platform_driver()
      mtd: denali_dt: Remove redundant use of of_match_ptr
      mtd: denali_dt: Change return value to fix smatch warning
      mtd: denali_dt: Use module_platform_driver()
      mtd: denali_dt: Fix incorrect error check
      mtd: nand: subpage write support for hardware based ECC schemes
      mtd: omap2: use msecs_to_jiffies()
      mtd: nand_ids: use size macros
      mtd: nand_ids: improve LEGACY_ID_NAND macro a bit
      mtd: add 4 Toshiba nand chips for the full-id case
      mtd: add the support to parse out the full-id nand type
      mtd: add new fields to nand_flash_dev{}
      mtd: sh_flctl: Use of_match_ptr() macro
      mtd: gpio: Use of_match_ptr() macro
      mtd: gpio: Use devm_kzalloc()
      mtd: davinci_nand: Use of_match_ptr()
      mtd: dataflash: Use of_match_ptr() macro
      mtd: remove h720x flash support
      mtd: onenand: remove OneNAND simulator
      ...

commit f86b11fbc772b5a4926855c6bc1ff3a3d99995a7
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Apr 19 10:05:39 2013 -0700

    mtdchar: remove no-longer-used vma helpers
    
    With the conversion to vm_iomap_memory(), these vma helpers are no
    longer used.
    
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
index 61a1b22c05e7..dc571ebc1aa0 100644
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -1123,33 +1123,6 @@ static unsigned long mtdchar_get_unmapped_area(struct file *file,
 }
 #endif
 
-static inline unsigned long get_vm_size(struct vm_area_struct *vma)
-{
-	return vma->vm_end - vma->vm_start;
-}
-
-static inline resource_size_t get_vm_offset(struct vm_area_struct *vma)
-{
-	return (resource_size_t) vma->vm_pgoff << PAGE_SHIFT;
-}
-
-/*
- * Set a new vm offset.
- *
- * Verify that the incoming offset really works as a page offset,
- * and that the offset and size fit in a resource_size_t.
- */
-static inline int set_vm_offset(struct vm_area_struct *vma, resource_size_t off)
-{
-	pgoff_t pgoff = off >> PAGE_SHIFT;
-	if (off != (resource_size_t) pgoff << PAGE_SHIFT)
-		return -EINVAL;
-	if (off + get_vm_size(vma) - 1 < off)
-		return -EINVAL;
-	vma->vm_pgoff = pgoff;
-	return 0;
-}
-
 /*
  * set up a mapping for shared memory segments
  */

commit 8558e4a26b00225efeb085725bc319f91201b239
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Apr 19 09:53:07 2013 -0700

    vm: convert mtdchar mmap to vm_iomap_memory() helper
    
    This is my example conversion of a few existing mmap users.  The mtdchar
    case is actually disabled right now (and stays disabled), but I did it
    because it showed up on my "git grep", and I was familiar with the code
    due to fixing an overflow problem in the code in commit 9c603e53d380
    ("mtdchar: fix offset overflow detection").
    
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
index 92ab30ab00dc..61a1b22c05e7 100644
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -1159,45 +1159,17 @@ static int mtdchar_mmap(struct file *file, struct vm_area_struct *vma)
 	struct mtd_file_info *mfi = file->private_data;
 	struct mtd_info *mtd = mfi->mtd;
 	struct map_info *map = mtd->priv;
-	resource_size_t start, off;
-	unsigned long len, vma_len;
 
         /* This is broken because it assumes the MTD device is map-based
 	   and that mtd->priv is a valid struct map_info.  It should be
 	   replaced with something that uses the mtd_get_unmapped_area()
 	   operation properly. */
 	if (0 /*mtd->type == MTD_RAM || mtd->type == MTD_ROM*/) {
-		off = get_vm_offset(vma);
-		start = map->phys;
-		len = PAGE_ALIGN((start & ~PAGE_MASK) + map->size);
-		start &= PAGE_MASK;
-		vma_len = get_vm_size(vma);
-
-		/* Overflow in off+len? */
-		if (vma_len + off < off)
-			return -EINVAL;
-		/* Does it fit in the mapping? */
-		if (vma_len + off > len)
-			return -EINVAL;
-
-		off += start;
-		/* Did that overflow? */
-		if (off < start)
-			return -EINVAL;
-		if (set_vm_offset(vma, off) < 0)
-			return -EINVAL;
-		vma->vm_flags |= VM_IO | VM_DONTEXPAND | VM_DONTDUMP;
-
 #ifdef pgprot_noncached
-		if (file->f_flags & O_DSYNC || off >= __pa(high_memory))
+		if (file->f_flags & O_DSYNC || map->phys >= __pa(high_memory))
 			vma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);
 #endif
-		if (io_remap_pfn_range(vma, vma->vm_start, off >> PAGE_SHIFT,
-				       vma->vm_end - vma->vm_start,
-				       vma->vm_page_prot))
-			return -EAGAIN;
-
-		return 0;
+		return vm_iomap_memory(vma, map->phys, map->size);
 	}
 	return -ENOSYS;
 #else

commit 660685d9d1b4730f0b5ca97fa95f272f99c63bce
Author: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
Date:   Thu Mar 14 13:27:40 2013 +0200

    mtd: merge mtdchar module with mtdcore
    
    The MTD subsystem has historically tried to be as configurable as possible. The
    side-effect of this is that its configuration menu is rather large, and we are
    gradually shrinking it. For example, we recently merged partitions support with
    the mtdcore.
    
    This patch does the next step - it merges the mtdchar module to mtdcore. And in
    this case this is not only about eliminating too fine-grained separation and
    simplifying the configuration menu. This is also about eliminating seemingly
    useless kernel module.
    
    Indeed, mtdchar is a module that allows user-space making use of MTD devices
    via /dev/mtd* character devices. If users do not enable it, they simply cannot
    use MTD devices at all. They cannot read or write the flash contents. Is it a
    sane and useful setup? I believe not. And everyone just enables mtdchar.
    
    Having mtdchar separate is also a little bit harmful. People sometimes miss the
    fact that they need to enable an additional configuration option to have
    user-space MTD interfaces, and then they wonder why on earth the kernel does
    not allow using the flash? They spend time asking around.
    
    Thus, let's just get rid of this module and make it part of mtd core.
    
    Note, mtdchar had additional configuration option to enable OTP interfaces,
    which are present on some flashes. I removed that option as well - it saves a
    really tiny amount space.
    
    [dwmw2: Strictly speaking, you can mount file systems on MTD devices just
            fine without the mtdchar (or mtdblock) devices; you just can't do
            other manipulations directly on the underlying device. But still I
            agree that it makes sense to make this unconditional. And Yay! we
            get to kill off an instance of checking CONFIG_foo_MODULE, which is
            an abomination that should never happen.]
    
    Signed-off-by: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
index c7292528c7bb..e0e59bf9b915 100644
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -38,6 +38,8 @@
 
 #include <asm/uaccess.h>
 
+#include "mtdcore.h"
+
 static DEFINE_MUTEX(mtd_mutex);
 
 /*
@@ -365,7 +367,6 @@ static void mtdchar_erase_callback (struct erase_info *instr)
 	wake_up((wait_queue_head_t *)instr->priv);
 }
 
-#ifdef CONFIG_HAVE_MTD_OTP
 static int otp_select_filemode(struct mtd_file_info *mfi, int mode)
 {
 	struct mtd_info *mtd = mfi->mtd;
@@ -395,9 +396,6 @@ static int otp_select_filemode(struct mtd_file_info *mfi, int mode)
 
 	return 0;
 }
-#else
-# define otp_select_filemode(f,m)	-EOPNOTSUPP
-#endif
 
 static int mtdchar_writeoob(struct file *file, struct mtd_info *mtd,
 	uint64_t start, uint32_t length, void __user *ptr,
@@ -890,7 +888,6 @@ static int mtdchar_ioctl(struct file *file, u_int cmd, u_long arg)
 		break;
 	}
 
-#ifdef CONFIG_HAVE_MTD_OTP
 	case OTPSELECT:
 	{
 		int mode;
@@ -946,7 +943,6 @@ static int mtdchar_ioctl(struct file *file, u_int cmd, u_long arg)
 		ret = mtd_lock_user_prot_reg(mtd, oinfo.start, oinfo.length);
 		break;
 	}
-#endif
 
 	/* This ioctl is being deprecated - it truncates the ECC layout */
 	case ECCGETLAYOUT:
@@ -1242,7 +1238,7 @@ static struct file_system_type mtd_inodefs_type = {
 };
 MODULE_ALIAS_FS("mtd_inodefs");
 
-static int __init init_mtdchar(void)
+int __init init_mtdchar(void)
 {
 	int ret;
 
@@ -1268,18 +1264,10 @@ static int __init init_mtdchar(void)
 	return ret;
 }
 
-static void __exit cleanup_mtdchar(void)
+void __exit cleanup_mtdchar(void)
 {
 	unregister_filesystem(&mtd_inodefs_type);
 	__unregister_chrdev(MTD_CHAR_MAJOR, 0, 1 << MINORBITS, "mtd");
 }
 
-module_init(init_mtdchar);
-module_exit(cleanup_mtdchar);
-
-MODULE_ALIAS_CHARDEV_MAJOR(MTD_CHAR_MAJOR);
-
-MODULE_LICENSE("GPL");
-MODULE_AUTHOR("David Woodhouse <dwmw2@infradead.org>");
-MODULE_DESCRIPTION("Direct character-device access to MTD devices");
 MODULE_ALIAS_CHARDEV_MAJOR(MTD_CHAR_MAJOR);

commit 57ae2b609f9338875daf269146f89c176831232c
Author: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
Date:   Fri Mar 15 12:59:36 2013 +0200

    mtd: mtdchar: use proper kernel print level
    
    We normally use 'pr_err()' for error messages, not 'pr_notice()'.
    
    Signed-off-by: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
index c2b6729da496..c7292528c7bb 100644
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -1249,16 +1249,18 @@ static int __init init_mtdchar(void)
 	ret = __register_chrdev(MTD_CHAR_MAJOR, 0, 1 << MINORBITS,
 				   "mtd", &mtd_fops);
 	if (ret < 0) {
-		pr_notice("Can't allocate major number %d for "
-				"Memory Technology Devices.\n", MTD_CHAR_MAJOR);
+		pr_err("Can't allocate major number %d for MTD\n",
+		       MTD_CHAR_MAJOR);
 		return ret;
 	}
 
 	ret = register_filesystem(&mtd_inodefs_type);
 	if (ret) {
-		pr_notice("Can't register mtd_inodefs filesystem: %d\n", ret);
+		pr_err("Can't register mtd_inodefs filesystem, error %d\n",
+		       ret);
 		goto err_unregister_chdev;
 	}
+
 	return ret;
 
 err_unregister_chdev:

commit 5dc63fa2c2e149dd3e8128e54c9ca251d0558ea0
Author: Uwe Kleine-KÃ¶nig <u.kleine-koenig@pengutronix.de>
Date:   Mon Mar 4 17:35:24 2013 +0100

    mtd: mtdchar: handle chips that have user otp but no factory otp
    
    Before this patch mtd_read_fact_prot_reg was used to check availability
    for both MTD_OTP_FACTORY and MTD_OTP_USER access. This made accessing
    user otp for chips that don't have a factory otp area impossible. So use
    the right wrapper depending on the intended area to be accessed.
    
    Signed-off-by: Uwe Kleine-KÃ¶nig <u.kleine-koenig@pengutronix.de>
    Signed-off-by: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
index 92ab30ab00dc..c2b6729da496 100644
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -370,28 +370,30 @@ static int otp_select_filemode(struct mtd_file_info *mfi, int mode)
 {
 	struct mtd_info *mtd = mfi->mtd;
 	size_t retlen;
-	int ret = 0;
-
-	/*
-	 * Make a fake call to mtd_read_fact_prot_reg() to check if OTP
-	 * operations are supported.
-	 */
-	if (mtd_read_fact_prot_reg(mtd, -1, 0, &retlen, NULL) == -EOPNOTSUPP)
-		return -EOPNOTSUPP;
 
 	switch (mode) {
 	case MTD_OTP_FACTORY:
+		if (mtd_read_fact_prot_reg(mtd, -1, 0, &retlen, NULL) ==
+				-EOPNOTSUPP)
+			return -EOPNOTSUPP;
+
 		mfi->mode = MTD_FILE_MODE_OTP_FACTORY;
 		break;
 	case MTD_OTP_USER:
+		if (mtd_read_user_prot_reg(mtd, -1, 0, &retlen, NULL) ==
+				-EOPNOTSUPP)
+			return -EOPNOTSUPP;
+
 		mfi->mode = MTD_FILE_MODE_OTP_USER;
 		break;
-	default:
-		ret = -EINVAL;
 	case MTD_OTP_OFF:
+		mfi->mode = MTD_FILE_MODE_NORMAL;
 		break;
+	default:
+		return -EINVAL;
 	}
-	return ret;
+
+	return 0;
 }
 #else
 # define otp_select_filemode(f,m)	-EOPNOTSUPP

commit 7f78e0351394052e1a6293e175825eb5c7869507
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Sat Mar 2 19:39:14 2013 -0800

    fs: Limit sys_mount to only request filesystem modules.
    
    Modify the request_module to prefix the file system type with "fs-"
    and add aliases to all of the filesystems that can be built as modules
    to match.
    
    A common practice is to build all of the kernel code and leave code
    that is not commonly needed as modules, with the result that many
    users are exposed to any bug anywhere in the kernel.
    
    Looking for filesystems with a fs- prefix limits the pool of possible
    modules that can be loaded by mount to just filesystems trivially
    making things safer with no real cost.
    
    Using aliases means user space can control the policy of which
    filesystem modules are auto-loaded by editing /etc/modprobe.d/*.conf
    with blacklist and alias directives.  Allowing simple, safe,
    well understood work-arounds to known problematic software.
    
    This also addresses a rare but unfortunate problem where the filesystem
    name is not the same as it's module name and module auto-loading
    would not work.  While writing this patch I saw a handful of such
    cases.  The most significant being autofs that lives in the module
    autofs4.
    
    This is relevant to user namespaces because we can reach the request
    module in get_fs_type() without having any special permissions, and
    people get uncomfortable when a user specified string (in this case
    the filesystem type) goes all of the way to request_module.
    
    After having looked at this issue I don't think there is any
    particular reason to perform any filtering or permission checks beyond
    making it clear in the module request that we want a filesystem
    module.  The common pattern in the kernel is to call request_module()
    without regards to the users permissions.  In general all a filesystem
    module does once loaded is call register_filesystem() and go to sleep.
    Which means there is not much attack surface exposed by loading a
    filesytem module unless the filesystem is mounted.  In a user
    namespace filesystems are not mounted unless .fs_flags = FS_USERNS_MOUNT,
    which most filesystems do not set today.
    
    Acked-by: Serge Hallyn <serge.hallyn@canonical.com>
    Acked-by: Kees Cook <keescook@chromium.org>
    Reported-by: Kees Cook <keescook@google.com>
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>

diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
index 82c06165d3d2..92ab30ab00dc 100644
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -1238,6 +1238,7 @@ static struct file_system_type mtd_inodefs_type = {
        .mount = mtd_inodefs_mount,
        .kill_sb = kill_anon_super,
 };
+MODULE_ALIAS_FS("mtd_inodefs");
 
 static int __init init_mtdchar(void)
 {

commit f5cf8f07423b2677cebebcebc863af77223a4972
Author: David Woodhouse <David.Woodhouse@intel.com>
Date:   Tue Oct 9 15:08:10 2012 +0100

    mtd: Disable mtdchar mmap on MMU systems
    
    This code was broken because it assumed that all MTD devices were map-based.
    Disable it for now, until it can be fixed properly for the next merge window.
    
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
index 73ae81a629f2..82c06165d3d2 100644
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -1162,7 +1162,11 @@ static int mtdchar_mmap(struct file *file, struct vm_area_struct *vma)
 	resource_size_t start, off;
 	unsigned long len, vma_len;
 
-	if (mtd->type == MTD_RAM || mtd->type == MTD_ROM) {
+        /* This is broken because it assumes the MTD device is map-based
+	   and that mtd->priv is a valid struct map_info.  It should be
+	   replaced with something that uses the mtd_get_unmapped_area()
+	   operation properly. */
+	if (0 /*mtd->type == MTD_RAM || mtd->type == MTD_ROM*/) {
 		off = get_vm_offset(vma);
 		start = map->phys;
 		len = PAGE_ALIGN((start & ~PAGE_MASK) + map->size);

commit 314e51b9851b4f4e8ab302243ff5a6fc6147f379
Author: Konstantin Khlebnikov <khlebnikov@openvz.org>
Date:   Mon Oct 8 16:29:02 2012 -0700

    mm: kill vma flag VM_RESERVED and mm->reserved_vm counter
    
    A long time ago, in v2.4, VM_RESERVED kept swapout process off VMA,
    currently it lost original meaning but still has some effects:
    
     | effect                 | alternative flags
    -+------------------------+---------------------------------------------
    1| account as reserved_vm | VM_IO
    2| skip in core dump      | VM_IO, VM_DONTDUMP
    3| do not merge or expand | VM_IO, VM_DONTEXPAND, VM_HUGETLB, VM_PFNMAP
    4| do not mlock           | VM_IO, VM_DONTEXPAND, VM_HUGETLB, VM_PFNMAP
    
    This patch removes reserved_vm counter from mm_struct.  Seems like nobody
    cares about it, it does not exported into userspace directly, it only
    reduces total_vm showed in proc.
    
    Thus VM_RESERVED can be replaced with VM_IO or pair VM_DONTEXPAND | VM_DONTDUMP.
    
    remap_pfn_range() and io_remap_pfn_range() set VM_IO|VM_DONTEXPAND|VM_DONTDUMP.
    remap_vmalloc_range() set VM_DONTEXPAND | VM_DONTDUMP.
    
    [akpm@linux-foundation.org: drivers/vfio/pci/vfio_pci.c fixup]
    Signed-off-by: Konstantin Khlebnikov <khlebnikov@openvz.org>
    Cc: Alexander Viro <viro@zeniv.linux.org.uk>
    Cc: Carsten Otte <cotte@de.ibm.com>
    Cc: Chris Metcalf <cmetcalf@tilera.com>
    Cc: Cyrill Gorcunov <gorcunov@openvz.org>
    Cc: Eric Paris <eparis@redhat.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Hugh Dickins <hughd@google.com>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: James Morris <james.l.morris@oracle.com>
    Cc: Jason Baron <jbaron@redhat.com>
    Cc: Kentaro Takeda <takedakn@nttdata.co.jp>
    Cc: Matt Helsley <matthltc@us.ibm.com>
    Cc: Nick Piggin <npiggin@kernel.dk>
    Cc: Oleg Nesterov <oleg@redhat.com>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Robert Richter <robert.richter@amd.com>
    Cc: Suresh Siddha <suresh.b.siddha@intel.com>
    Cc: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
    Cc: Venkatesh Pallipadi <venki@google.com>
    Acked-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
index a6e74514e662..73ae81a629f2 100644
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -1182,7 +1182,7 @@ static int mtdchar_mmap(struct file *file, struct vm_area_struct *vma)
 			return -EINVAL;
 		if (set_vm_offset(vma, off) < 0)
 			return -EINVAL;
-		vma->vm_flags |= VM_IO | VM_RESERVED;
+		vma->vm_flags |= VM_IO | VM_DONTEXPAND | VM_DONTDUMP;
 
 #ifdef pgprot_noncached
 		if (file->f_flags & O_DSYNC || off >= __pa(high_memory))

commit 9c603e53d380459fb62fec7cd085acb0b74ac18f
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Sep 8 12:57:30 2012 -0700

    mtdchar: fix offset overflow detection
    
    Sasha Levin has been running trinity in a KVM tools guest, and was able
    to trigger the BUG_ON() at arch/x86/mm/pat.c:279 (verifying the range of
    the memory type).  The call trace showed that it was mtdchar_mmap() that
    created an invalid remap_pfn_range().
    
    The problem is that mtdchar_mmap() does various really odd and subtle
    things with the vma page offset etc, and uses the wrong types (and the
    wrong overflow) detection for it.
    
    For example, the page offset may well be 32-bit on a 32-bit
    architecture, but after shifting it up by PAGE_SHIFT, we need to use a
    potentially 64-bit resource_size_t to correctly hold the full value.
    
    Also, we need to check that the vma length plus offset doesn't overflow
    before we check that it is smaller than the length of the mtdmap region.
    
    This fixes things up and tries to make the code a bit easier to read.
    
    Reported-and-tested-by: Sasha Levin <levinsasha928@gmail.com>
    Acked-by: Suresh Siddha <suresh.b.siddha@intel.com>
    Acked-by: Artem Bityutskiy <dedekind1@gmail.com>
    Cc: David Woodhouse <dwmw2@infradead.org>
    Cc: linux-mtd@lists.infradead.org
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
index f2f482bec573..a6e74514e662 100644
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -1123,6 +1123,33 @@ static unsigned long mtdchar_get_unmapped_area(struct file *file,
 }
 #endif
 
+static inline unsigned long get_vm_size(struct vm_area_struct *vma)
+{
+	return vma->vm_end - vma->vm_start;
+}
+
+static inline resource_size_t get_vm_offset(struct vm_area_struct *vma)
+{
+	return (resource_size_t) vma->vm_pgoff << PAGE_SHIFT;
+}
+
+/*
+ * Set a new vm offset.
+ *
+ * Verify that the incoming offset really works as a page offset,
+ * and that the offset and size fit in a resource_size_t.
+ */
+static inline int set_vm_offset(struct vm_area_struct *vma, resource_size_t off)
+{
+	pgoff_t pgoff = off >> PAGE_SHIFT;
+	if (off != (resource_size_t) pgoff << PAGE_SHIFT)
+		return -EINVAL;
+	if (off + get_vm_size(vma) - 1 < off)
+		return -EINVAL;
+	vma->vm_pgoff = pgoff;
+	return 0;
+}
+
 /*
  * set up a mapping for shared memory segments
  */
@@ -1132,20 +1159,29 @@ static int mtdchar_mmap(struct file *file, struct vm_area_struct *vma)
 	struct mtd_file_info *mfi = file->private_data;
 	struct mtd_info *mtd = mfi->mtd;
 	struct map_info *map = mtd->priv;
-	unsigned long start;
-	unsigned long off;
-	u32 len;
+	resource_size_t start, off;
+	unsigned long len, vma_len;
 
 	if (mtd->type == MTD_RAM || mtd->type == MTD_ROM) {
-		off = vma->vm_pgoff << PAGE_SHIFT;
+		off = get_vm_offset(vma);
 		start = map->phys;
 		len = PAGE_ALIGN((start & ~PAGE_MASK) + map->size);
 		start &= PAGE_MASK;
-		if ((vma->vm_end - vma->vm_start + off) > len)
+		vma_len = get_vm_size(vma);
+
+		/* Overflow in off+len? */
+		if (vma_len + off < off)
+			return -EINVAL;
+		/* Does it fit in the mapping? */
+		if (vma_len + off > len)
 			return -EINVAL;
 
 		off += start;
-		vma->vm_pgoff = off >> PAGE_SHIFT;
+		/* Did that overflow? */
+		if (off < start)
+			return -EINVAL;
+		if (set_vm_offset(vma, off) < 0)
+			return -EINVAL;
 		vma->vm_flags |= VM_IO | VM_RESERVED;
 
 #ifdef pgprot_noncached

commit 7a84477c4acebf6299b6a8bd6a1d5894eb838ffa
Author: Will Newton <will.newton@gmail.com>
Date:   Fri Mar 30 11:51:02 2012 +0100

    mtd: fix oops in dataflash driver
    
    I'm seeing an oops in mtd_dataflash.c with Linux 3.3. What appears to
    be happening is that otp_select_filemode calls mtd_read_fact_prot_reg
    with -1 for offset and length and a NULL buffer to test if OTP
    operations are supported. This finds its way down to otp_read in
    mtd_dataflash.c and causes an oops when memcpying the returned data
    into the NULL buf.
    
    None of the checks in otp_read catches the negative length and offset.
    Changing the length of the dummy read to 0 prevents the oops.
    
    Cc: stable@kernel.org [3.3+]
    Signed-off-by: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
index 58fc65f5c817..f2f482bec573 100644
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -376,7 +376,7 @@ static int otp_select_filemode(struct mtd_file_info *mfi, int mode)
 	 * Make a fake call to mtd_read_fact_prot_reg() to check if OTP
 	 * operations are supported.
 	 */
-	if (mtd_read_fact_prot_reg(mtd, -1, -1, &retlen, NULL) == -EOPNOTSUPP)
+	if (mtd_read_fact_prot_reg(mtd, -1, 0, &retlen, NULL) == -EOPNOTSUPP)
 		return -EOPNOTSUPP;
 
 	switch (mode) {

commit c65390f4dd49755863f6d772ec538ee4757c08d7
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Mon Apr 9 01:36:28 2012 -0400

    fix breakage in mtdchar_open(), sanitize failure exits
    
    simple_release_fs() should be only done on failure there.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
index 94eb05b1afdf..58fc65f5c817 100644
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -106,16 +106,14 @@ static int mtdchar_open(struct inode *inode, struct file *file)
 	}
 
 	if (mtd->type == MTD_ABSENT) {
-		put_mtd_device(mtd);
 		ret = -ENODEV;
-		goto out;
+		goto out1;
 	}
 
 	mtd_ino = iget_locked(mnt->mnt_sb, devnum);
 	if (!mtd_ino) {
-		put_mtd_device(mtd);
 		ret = -ENOMEM;
-		goto out;
+		goto out1;
 	}
 	if (mtd_ino->i_state & I_NEW) {
 		mtd_ino->i_private = mtd;
@@ -127,23 +125,25 @@ static int mtdchar_open(struct inode *inode, struct file *file)
 
 	/* You can't open it RW if it's not a writeable device */
 	if ((file->f_mode & FMODE_WRITE) && !(mtd->flags & MTD_WRITEABLE)) {
-		iput(mtd_ino);
-		put_mtd_device(mtd);
 		ret = -EACCES;
-		goto out;
+		goto out2;
 	}
 
 	mfi = kzalloc(sizeof(*mfi), GFP_KERNEL);
 	if (!mfi) {
-		iput(mtd_ino);
-		put_mtd_device(mtd);
 		ret = -ENOMEM;
-		goto out;
+		goto out2;
 	}
 	mfi->ino = mtd_ino;
 	mfi->mtd = mtd;
 	file->private_data = mfi;
+	mutex_unlock(&mtd_mutex);
+	return 0;
 
+out2:
+	iput(mtd_ino);
+out1:
+	put_mtd_device(mtd);
 out:
 	mutex_unlock(&mtd_mutex);
 	simple_release_fs(&mnt, &count);

commit 8bb1f229527dee95644e0f8496980bb767c6f620
Merge: f22e08a79f37 c0d0259481cc
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Mar 31 13:42:57 2012 -0700

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull second try at vfs part d#2 from Al Viro:
     "Miklos' first series (with do_lookup() rewrite split into edible
      chunks) + assorted bits and pieces.
    
      The 'untangling of do_lookup()' series is is a splitup of what used to
      be a monolithic patch from Miklos, so this series is basically "how do
      I convince myself that his patch is correct (or find a hole in it)".
      No holes found and I like the resulting cleanup, so in it went..."
    
    Changes from try 1: Fix a boot problem with selinux, and commit messages
    prettied up a bit.
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs: (24 commits)
      vfs: fix out-of-date dentry_unhash() comment
      vfs: split __lookup_hash
      untangling do_lookup() - take __lookup_hash()-calling case out of line.
      untangling do_lookup() - switch to calling __lookup_hash()
      untangling do_lookup() - merge d_alloc_and_lookup() callers
      untangling do_lookup() - merge failure exits in !dentry case
      untangling do_lookup() - massage !dentry case towards __lookup_hash()
      untangling do_lookup() - get rid of need_reval in !dentry case
      untangling do_lookup() - eliminate a loop.
      untangling do_lookup() - expand the area under ->i_mutex
      untangling do_lookup() - isolate !dentry stuff from the rest of it.
      vfs: move MAY_EXEC check from __lookup_hash()
      vfs: don't revalidate just looked up dentry
      vfs: fix d_need_lookup/d_revalidate order in do_lookup
      ext3: move headers to fs/ext3/
      migrate ext2_fs.h guts to fs/ext2/ext2.h
      new helper: ext2_image_size()
      get rid of pointless includes of ext2_fs.h
      ext2: No longer export ext2_fs.h to user space
      mtdchar: kill persistently held vfsmount
      ...

commit 00292bbf769620dea923dbd906afd88955f7ea19
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Mar 23 13:47:52 2012 -0400

    mtdchar: kill persistently held vfsmount
    
    ... and mtdchar_notifier along with it; just have ->drop_inode() that
    will unconditionally get evict them instead of dances on mtd device
    removal and use simple_pin_fs() instead of kern_mount()
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
index c57ae92ebda4..28c585ffc8af 100644
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -39,7 +39,6 @@
 #include <asm/uaccess.h>
 
 static DEFINE_MUTEX(mtd_mutex);
-static struct vfsmount *mtd_inode_mnt __read_mostly;
 
 /*
  * Data structure to hold the pointer to the mtd device as well
@@ -75,7 +74,9 @@ static loff_t mtdchar_lseek(struct file *file, loff_t offset, int orig)
 	return -EINVAL;
 }
 
-
+static int count;
+static struct vfsmount *mnt;
+static struct file_system_type mtd_inodefs_type;
 
 static int mtdchar_open(struct inode *inode, struct file *file)
 {
@@ -92,6 +93,10 @@ static int mtdchar_open(struct inode *inode, struct file *file)
 	if ((file->f_mode & FMODE_WRITE) && (minor & 1))
 		return -EACCES;
 
+	ret = simple_pin_fs(&mtd_inodefs_type, &mnt, &count);
+	if (ret)
+		return ret;
+
 	mutex_lock(&mtd_mutex);
 	mtd = get_mtd_device(NULL, devnum);
 
@@ -106,7 +111,7 @@ static int mtdchar_open(struct inode *inode, struct file *file)
 		goto out;
 	}
 
-	mtd_ino = iget_locked(mtd_inode_mnt->mnt_sb, devnum);
+	mtd_ino = iget_locked(mnt->mnt_sb, devnum);
 	if (!mtd_ino) {
 		put_mtd_device(mtd);
 		ret = -ENOMEM;
@@ -141,6 +146,7 @@ static int mtdchar_open(struct inode *inode, struct file *file)
 
 out:
 	mutex_unlock(&mtd_mutex);
+	simple_release_fs(&mnt, &count);
 	return ret;
 } /* mtdchar_open */
 
@@ -162,6 +168,7 @@ static int mtdchar_close(struct inode *inode, struct file *file)
 	put_mtd_device(mtd);
 	file->private_data = NULL;
 	kfree(mfi);
+	simple_release_fs(&mnt, &count);
 
 	return 0;
 } /* mtdchar_close */
@@ -1175,10 +1182,15 @@ static const struct file_operations mtd_fops = {
 #endif
 };
 
+static const struct super_operations mtd_ops = {
+	.drop_inode = generic_delete_inode,
+	.statfs = simple_statfs,
+};
+
 static struct dentry *mtd_inodefs_mount(struct file_system_type *fs_type,
 				int flags, const char *dev_name, void *data)
 {
-	return mount_pseudo(fs_type, "mtd_inode:", NULL, NULL, MTD_INODE_FS_MAGIC);
+	return mount_pseudo(fs_type, "mtd_inode:", &mtd_ops, NULL, MTD_INODE_FS_MAGIC);
 }
 
 static struct file_system_type mtd_inodefs_type = {
@@ -1187,26 +1199,6 @@ static struct file_system_type mtd_inodefs_type = {
        .kill_sb = kill_anon_super,
 };
 
-static void mtdchar_notify_add(struct mtd_info *mtd)
-{
-}
-
-static void mtdchar_notify_remove(struct mtd_info *mtd)
-{
-	struct inode *mtd_ino = ilookup(mtd_inode_mnt->mnt_sb, mtd->index);
-
-	if (mtd_ino) {
-		/* Destroy the inode if it exists */
-		clear_nlink(mtd_ino);
-		iput(mtd_ino);
-	}
-}
-
-static struct mtd_notifier mtdchar_notifier = {
-	.add = mtdchar_notify_add,
-	.remove = mtdchar_notify_remove,
-};
-
 static int __init init_mtdchar(void)
 {
 	int ret;
@@ -1224,19 +1216,8 @@ static int __init init_mtdchar(void)
 		pr_notice("Can't register mtd_inodefs filesystem: %d\n", ret);
 		goto err_unregister_chdev;
 	}
-
-	mtd_inode_mnt = kern_mount(&mtd_inodefs_type);
-	if (IS_ERR(mtd_inode_mnt)) {
-		ret = PTR_ERR(mtd_inode_mnt);
-		pr_notice("Error mounting mtd_inodefs filesystem: %d\n", ret);
-		goto err_unregister_filesystem;
-	}
-	register_mtd_user(&mtdchar_notifier);
-
 	return ret;
 
-err_unregister_filesystem:
-	unregister_filesystem(&mtd_inodefs_type);
 err_unregister_chdev:
 	__unregister_chrdev(MTD_CHAR_MAJOR, 0, 1 << MINORBITS, "mtd");
 	return ret;
@@ -1244,8 +1225,6 @@ static int __init init_mtdchar(void)
 
 static void __exit cleanup_mtdchar(void)
 {
-	unregister_mtd_user(&mtdchar_notifier);
-	kern_unmount(mtd_inode_mnt);
 	unregister_filesystem(&mtd_inodefs_type);
 	__unregister_chrdev(MTD_CHAR_MAJOR, 0, 1 << MINORBITS, "mtd");
 }

commit 623ff7739e7c00fa3d55dbfd42a492a68298fd7a
Merge: c39e8ede284f 7b0e67f604e1
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Mar 30 17:31:56 2012 -0700

    Merge tag 'for-linus-3.4' of git://git.infradead.org/mtd-2.6
    
    Pull MTD changes from David Woodhouse:
     - Artem's cleanup of the MTD API continues apace.
     - Fixes and improvements for ST FSMC and SuperH FLCTL NAND, amongst
       others.
     - More work on DiskOnChip G3, new driver for DiskOnChip G4.
     - Clean up debug/warning printks in JFFS2 to use pr_<level>.
    
    Fix up various trivial conflicts, largely due to changes in calling
    conventions for things like dmaengine_prep_slave_sg() (new inline
    wrapper to hide new parameter, clashing with rewrite of previously last
    parameter that used to be an 'append' flag, and is now a bitmap of
    'unsigned long flags').
    
    (Also some header file fallout - like so many merges this merge window -
    and silly conflicts with sparse fixes)
    
    * tag 'for-linus-3.4' of git://git.infradead.org/mtd-2.6: (120 commits)
      mtd: docg3 add protection against concurrency
      mtd: docg3 refactor cascade floors structure
      mtd: docg3 increase write/erase timeout
      mtd: docg3 fix inbound calculations
      mtd: nand: gpmi: fix function annotations
      mtd: phram: fix section mismatch for phram_setup
      mtd: unify initialization of erase_info->fail_addr
      mtd: support ONFI multi lun NAND
      mtd: sm_ftl: fix typo in major number.
      mtd: add device-tree support to spear_smi
      mtd: spear_smi: Remove default partition information from driver
      mtd: Add device-tree support to fsmc_nand
      mtd: fix section mismatch for doc_probe_device
      mtd: nand/fsmc: Remove sparse warnings and errors
      mtd: nand/fsmc: Add DMA support
      mtd: nand/fsmc: Access the NAND device word by word whenever possible
      mtd: nand/fsmc: Use dev_err to report error scenario
      mtd: nand/fsmc: Use devm routines
      mtd: nand/fsmc: Modify fsmc driver to accept nand timing parameters via platform
      mtd: fsmc_nand: add pm callbacks to support hibernation
      ...

commit 3c3c10bba1e4ccb75b41442e45c1a072f6cded19
Author: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
Date:   Mon Jan 30 14:58:32 2012 +0200

    mtd: add leading underscore to all mtd functions
    
    This patch renames all MTD functions by adding a "_" prefix:
    
    mtd->erase -> mtd->_erase
    mtd->read_oob -> mtd->_read_oob
    ...
    
    The reason is that we are re-working the MTD API and from now on it is
    an error to use MTD function pointers directly - we have a corresponding
    API call for every pointer. By adding a leading "_" we achieve the following:
    
    1. Make sure we convert every direct pointer users
    2. A leading "_" suggests that this interface is internal and it becomes
       less likely that people will use them directly
    3. Make sure all the out-of-tree modules stop compiling and the owners
       spot the big API change and amend them.
    
    Signed-off-by: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
index 50c6a1e7f675..426640eaf818 100644
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -405,7 +405,7 @@ static int mtdchar_writeoob(struct file *file, struct mtd_info *mtd,
 	if (length > 4096)
 		return -EINVAL;
 
-	if (!mtd->write_oob)
+	if (!mtd->_write_oob)
 		ret = -EOPNOTSUPP;
 	else
 		ret = access_ok(VERIFY_READ, ptr, length) ? 0 : -EFAULT;
@@ -576,7 +576,7 @@ static int mtdchar_write_ioctl(struct mtd_info *mtd,
 			!access_ok(VERIFY_READ, req.usr_data, req.len) ||
 			!access_ok(VERIFY_READ, req.usr_oob, req.ooblen))
 		return -EFAULT;
-	if (!mtd->write_oob)
+	if (!mtd->_write_oob)
 		return -EOPNOTSUPP;
 
 	ops.mode = req.mode;

commit b502bd1152472dc1b98c60434f23c23b280c7b94
Author: Muthu Kumar <muthu.lkml@gmail.com>
Date:   Fri Mar 23 15:01:50 2012 -0700

    magic.h: move some FS magic numbers into magic.h
    
    - Move open-coded filesystem magic numbers into magic.h
    
    - Rearrange magic.h so that the filesystem-related constants are grouped
      together.
    
    Signed-off-by: Muthukumar R <muthur@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
index 50c6a1e7f675..c57ae92ebda4 100644
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -31,13 +31,13 @@
 #include <linux/compat.h>
 #include <linux/mount.h>
 #include <linux/blkpg.h>
+#include <linux/magic.h>
 #include <linux/mtd/mtd.h>
 #include <linux/mtd/partitions.h>
 #include <linux/mtd/map.h>
 
 #include <asm/uaccess.h>
 
-#define MTD_INODE_FS_MAGIC 0x11307854
 static DEFINE_MUTEX(mtd_mutex);
 static struct vfsmount *mtd_inode_mnt __read_mostly;
 

commit 800ffd3496987e91f599a135060ef49731e045ac
Author: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
Date:   Mon Jan 2 13:59:12 2012 +0200

    mtd: do not use mtd->block_markbad directly
    
    Instead, use the new 'mtd_can_have_bb()', or just rely on 'mtd_block_markbad()'
    return code, which will be -EOPNOTSUPP if bad blocks are not supported.
    
    Signed-off-by: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
index 64efcbf087e9..50c6a1e7f675 100644
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -877,10 +877,7 @@ static int mtdchar_ioctl(struct file *file, u_int cmd, u_long arg)
 
 		if (copy_from_user(&offs, argp, sizeof(loff_t)))
 			return -EFAULT;
-		if (!mtd->block_markbad)
-			ret = -EOPNOTSUPP;
-		else
-			return mtd_block_markbad(mtd, offs);
+		return mtd_block_markbad(mtd, offs);
 		break;
 	}
 

commit 8f461a730242c528ca221948edceca49266a3ffb
Author: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
Date:   Mon Jan 2 13:48:54 2012 +0200

    mtd: introduce mtd_can_have_bb helper
    
    This patch introduces new 'mtd_can_have_bb()' helper function which checks
    whether the flash can have bad eraseblocks. Then it changes all the
    direct 'mtd->block_isbad' use cases with 'mtd_can_have_bb()'.
    
    Signed-off-by: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
index 92da621b1425..64efcbf087e9 100644
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -867,10 +867,7 @@ static int mtdchar_ioctl(struct file *file, u_int cmd, u_long arg)
 
 		if (copy_from_user(&offs, argp, sizeof(loff_t)))
 			return -EFAULT;
-		if (!mtd->block_isbad)
-			ret = -EOPNOTSUPP;
-		else
-			return mtd_block_isbad(mtd, offs);
+		return mtd_block_isbad(mtd, offs);
 		break;
 	}
 

commit 381345652fca688aeaa967c231e5075cf68d05b6
Author: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
Date:   Fri Dec 30 17:00:35 2011 +0200

    mtd: do not use mtd->lock, unlock and is_locked directly
    
    Instead, call the corresponding MTD API function which will return
    '-EOPNOTSUPP' if the operation is not supported.
    
    Signed-off-by: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
index 23a51104aeb5..92da621b1425 100644
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -814,10 +814,7 @@ static int mtdchar_ioctl(struct file *file, u_int cmd, u_long arg)
 		if (copy_from_user(&einfo, argp, sizeof(einfo)))
 			return -EFAULT;
 
-		if (!mtd->lock)
-			ret = -EOPNOTSUPP;
-		else
-			ret = mtd_lock(mtd, einfo.start, einfo.length);
+		ret = mtd_lock(mtd, einfo.start, einfo.length);
 		break;
 	}
 
@@ -828,10 +825,7 @@ static int mtdchar_ioctl(struct file *file, u_int cmd, u_long arg)
 		if (copy_from_user(&einfo, argp, sizeof(einfo)))
 			return -EFAULT;
 
-		if (!mtd->unlock)
-			ret = -EOPNOTSUPP;
-		else
-			ret = mtd_unlock(mtd, einfo.start, einfo.length);
+		ret = mtd_unlock(mtd, einfo.start, einfo.length);
 		break;
 	}
 
@@ -842,10 +836,7 @@ static int mtdchar_ioctl(struct file *file, u_int cmd, u_long arg)
 		if (copy_from_user(&einfo, argp, sizeof(einfo)))
 			return -EFAULT;
 
-		if (!mtd->is_locked)
-			ret = -EOPNOTSUPP;
-		else
-			ret = mtd_is_locked(mtd, einfo.start, einfo.length);
+		ret = mtd_is_locked(mtd, einfo.start, einfo.length);
 		break;
 	}
 

commit 327cf2922b4edf0439b219469722d2a502e37349
Author: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
Date:   Fri Dec 30 16:35:35 2011 +0200

    mtd: do not use mtd->sync directly
    
    This patch teaches 'mtd_sync()' to do nothing when the MTD driver does
    not have the '->sync()' method, which allows us to remove all direct
    'mtd->sync' accesses.
    
    Signed-off-by: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
index 2020a169ed9c..23a51104aeb5 100644
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -154,7 +154,7 @@ static int mtdchar_close(struct inode *inode, struct file *file)
 	pr_debug("MTD_close\n");
 
 	/* Only sync if opened RW */
-	if ((file->f_mode & FMODE_WRITE) && mtd->sync)
+	if ((file->f_mode & FMODE_WRITE))
 		mtd_sync(mtd);
 
 	iput(mfi->ino);

commit e2936b2af5562c8c66060e2bc2ae2e209d0acd3d
Author: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
Date:   Thu Dec 29 10:45:04 2011 +0200

    mtd: do not use mtd->lock_user_prot_reg directly
    
    Instead, check the -EOPNOTSUPP return code of 'mtd_lock_user_prot_reg()'.
    
    Signed-off-by: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
index 25bbbc3aa665..2020a169ed9c 100644
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -949,8 +949,6 @@ static int mtdchar_ioctl(struct file *file, u_int cmd, u_long arg)
 			return -EINVAL;
 		if (copy_from_user(&oinfo, argp, sizeof(oinfo)))
 			return -EFAULT;
-		if (!mtd->lock_user_prot_reg)
-			return -EOPNOTSUPP;
 		ret = mtd_lock_user_prot_reg(mtd, oinfo.start, oinfo.length);
 		break;
 	}

commit 27c151a5e52efaa46d0938984f2ef591bdcb6d5b
Author: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
Date:   Thu Dec 29 10:39:20 2011 +0200

    mtd: mtd->write_user_prot_reg directly
    
    Instead, just call 'mtd_write_user_prot_reg()' and check the '-EOPNOTSUPP' return
    code.
    
    Signed-off-by: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
index 4e8e5fbc1e13..25bbbc3aa665 100644
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -310,10 +310,6 @@ static ssize_t mtdchar_write(struct file *file, const char __user *buf, size_t c
 			ret = -EROFS;
 			break;
 		case MTD_FILE_MODE_OTP_USER:
-			if (!mtd->write_user_prot_reg) {
-				ret = -EOPNOTSUPP;
-				break;
-			}
 			ret = mtd_write_user_prot_reg(mtd, *ppos, len,
 						      &retlen, kbuf);
 			break;

commit b6de3d6cb63427178c4f1df88b81d1ceee637e6f
Author: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
Date:   Thu Dec 29 10:06:32 2011 +0200

    mtd: do not use mtd->read_*_prot_reg directly
    
    Instead, call 'mtd_read_*_prot_info()' and check for -EOPNOTSUPP.
    
    Signed-off-by: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
index 49340dc1b107..4e8e5fbc1e13 100644
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -366,20 +366,22 @@ static void mtdchar_erase_callback (struct erase_info *instr)
 static int otp_select_filemode(struct mtd_file_info *mfi, int mode)
 {
 	struct mtd_info *mtd = mfi->mtd;
+	size_t retlen;
 	int ret = 0;
 
+	/*
+	 * Make a fake call to mtd_read_fact_prot_reg() to check if OTP
+	 * operations are supported.
+	 */
+	if (mtd_read_fact_prot_reg(mtd, -1, -1, &retlen, NULL) == -EOPNOTSUPP)
+		return -EOPNOTSUPP;
+
 	switch (mode) {
 	case MTD_OTP_FACTORY:
-		if (!mtd->read_fact_prot_reg)
-			ret = -EOPNOTSUPP;
-		else
-			mfi->mode = MTD_FILE_MODE_OTP_FACTORY;
+		mfi->mode = MTD_FILE_MODE_OTP_FACTORY;
 		break;
 	case MTD_OTP_USER:
-		if (!mtd->read_fact_prot_reg)
-			ret = -EOPNOTSUPP;
-		else
-			mfi->mode = MTD_FILE_MODE_OTP_USER;
+		mfi->mode = MTD_FILE_MODE_OTP_USER;
 		break;
 	default:
 		ret = -EINVAL;

commit 87e858a97e8a7010aedc01db7cd31cc7c02b0b6a
Author: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
Date:   Wed Dec 28 18:47:46 2011 +0200

    mtd: do not use mtd->get_*_prot_info directly
    
    Instead, call 'mtd_get_*_prot_info()' and check for '-EOPNOTSUPP'. While
    on it, fix the return code from '-EOPNOTSUPP' to '-EINVAL' for the case
    when the mode parameter is invalid.
    
    Signed-off-by: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
index 287ff0d35848..49340dc1b107 100644
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -919,17 +919,15 @@ static int mtdchar_ioctl(struct file *file, u_int cmd, u_long arg)
 		struct otp_info *buf = kmalloc(4096, GFP_KERNEL);
 		if (!buf)
 			return -ENOMEM;
-		ret = -EOPNOTSUPP;
 		switch (mfi->mode) {
 		case MTD_FILE_MODE_OTP_FACTORY:
-			if (mtd->get_fact_prot_info)
-				ret = mtd_get_fact_prot_info(mtd, buf, 4096);
+			ret = mtd_get_fact_prot_info(mtd, buf, 4096);
 			break;
 		case MTD_FILE_MODE_OTP_USER:
-			if (mtd->get_user_prot_info)
-				ret = mtd_get_user_prot_info(mtd, buf, 4096);
+			ret = mtd_get_user_prot_info(mtd, buf, 4096);
 			break;
 		default:
+			ret = -EINVAL;
 			break;
 		}
 		if (ret >= 0) {

commit dac2639f9833e858139d7e07f6ee45fb2191a9f2
Author: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
Date:   Wed Dec 28 17:50:34 2011 +0200

    mtd: do not use mtd->read_oob directly
    
    Instead of checking whether 'mtd->read_oob' is defined, just call
    'mtd_read_oob()' and handle the '-EOPNOTSUPP' error which will be returned
    if the function is undefined.
    
    Additionally, make 'mtd_write_oob()' return '-EOPNOTSUPP' if the function
    is undefined.
    
    Signed-off-by: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
index 55f0961103a7..287ff0d35848 100644
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -452,13 +452,8 @@ static int mtdchar_readoob(struct file *file, struct mtd_info *mtd,
 	if (length > 4096)
 		return -EINVAL;
 
-	if (!mtd->read_oob)
-		ret = -EOPNOTSUPP;
-	else
-		ret = access_ok(VERIFY_WRITE, ptr,
-				length) ? 0 : -EFAULT;
-	if (ret)
-		return ret;
+	if (!access_ok(VERIFY_WRITE, ptr, length))
+		return -EFAULT;
 
 	ops.ooblen = length;
 	ops.ooboffs = start & (mtd->writesize - 1);

commit cd621274b0ec747db8dedbf857624c067f481976
Author: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
Date:   Fri Dec 30 14:31:57 2011 +0200

    mtd: do not use mtd->get_unmapped_area directly
    
    Remove direct usage of mtd->get_unmapped_area. Instead, just call
    'mtd_get_unmapped_area()' which will return -EOPNOTSUPP if the function
    is not implemented and test for this error code.
    
    Signed-off-by: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
index c501eec17b38..55f0961103a7 100644
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -1124,25 +1124,21 @@ static unsigned long mtdchar_get_unmapped_area(struct file *file,
 {
 	struct mtd_file_info *mfi = file->private_data;
 	struct mtd_info *mtd = mfi->mtd;
+	unsigned long offset;
+	int ret;
 
-	if (mtd->get_unmapped_area) {
-		unsigned long offset;
-
-		if (addr != 0)
-			return (unsigned long) -EINVAL;
-
-		if (len > mtd->size || pgoff >= (mtd->size >> PAGE_SHIFT))
-			return (unsigned long) -EINVAL;
+	if (addr != 0)
+		return (unsigned long) -EINVAL;
 
-		offset = pgoff << PAGE_SHIFT;
-		if (offset > mtd->size - len)
-			return (unsigned long) -EINVAL;
+	if (len > mtd->size || pgoff >= (mtd->size >> PAGE_SHIFT))
+		return (unsigned long) -EINVAL;
 
-		return mtd_get_unmapped_area(mtd, len, offset, flags);
-	}
+	offset = pgoff << PAGE_SHIFT;
+	if (offset > mtd->size - len)
+		return (unsigned long) -EINVAL;
 
-	/* can't map directly */
-	return (unsigned long) -ENOSYS;
+	ret = mtd_get_unmapped_area(mtd, len, offset, flags);
+	return ret == -EOPNOTSUPP ? -ENOSYS : ret;
 }
 #endif
 

commit fc002e3c320602d0e206f607aca0460540d7637a
Author: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
Date:   Wed Dec 28 18:35:07 2011 +0200

    mtd: introduce mtd_has_oob helper
    
    We are working in the direction of making sure that MTD clients to not
    use 'mtd->func' pointers directly. In some places we want to know if
    OOB operations are supported by an MTD device. Introduce 'mtd_has_oob()'
    helper for these purposes.
    
    Signed-off-by: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
index 83b0c82e9c94..c501eec17b38 100644
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -1004,7 +1004,7 @@ static int mtdchar_ioctl(struct file *file, u_int cmd, u_long arg)
 			break;
 
 		case MTD_FILE_MODE_RAW:
-			if (!mtd->read_oob || !mtd->write_oob)
+			if (!mtd_has_oob(mtd))
 				return -EOPNOTSUPP;
 			mfi->mode = arg;
 

commit 30fa98480b782999248ce8290136aa58f22536cf
Author: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
Date:   Thu Dec 29 15:16:28 2011 +0200

    mtd: remove extra retlen assignment
    
    MTD functions always assign the 'retlen' argument to 0 at the very
    beginning - the callers do not have to do this.
    
    I used the following semantic patch to find these places:
    
    @@
    identifier retlen;
    expression a, b, c, d, e;
    constant C;
    type T;
    @@
    (
    - retlen = C;
    |
    T
    -retlen = C
    + retlen
    ;
    )
    
    ... when != retlen
        when exists
    
    (
    mtd_read(a, b, c, &retlen, d)
    |
    mtd_write(a, b, c, &retlen, d)
    |
    mtd_panic_write(a, b, c, &retlen, d)
    |
    mtd_point(a, b, c, &retlen, d, e)
    |
    mtd_read_fact_prot_reg(a, b, c, &retlen, d)
    |
    mtd_write_user_prot_reg(a, b, c, &retlen, d)
    |
    mtd_read_user_prot_reg(a, b, c, &retlen, d)
    |
    mtd_writev(a, b, c, d, &retlen)
    )
    
    I ran it twice, because there were cases of double zero assigments
    in mtd tests. Then I went through the patch to verify that spatch
    did not find any false positives.
    
    Signed-off-by: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
index 15a3f6224be4..83b0c82e9c94 100644
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -189,7 +189,7 @@ static ssize_t mtdchar_read(struct file *file, char __user *buf, size_t count,
 {
 	struct mtd_file_info *mfi = file->private_data;
 	struct mtd_info *mtd = mfi->mtd;
-	size_t retlen=0;
+	size_t retlen;
 	size_t total_retlen=0;
 	int ret=0;
 	int len;

commit 5942ddbc500d1c9b75e571b656be97f65b26adfe
Author: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
Date:   Fri Dec 23 19:37:38 2011 +0200

    mtd: introduce mtd_block_markbad interface
    
    Signed-off-by: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
index a499bf7a8214..15a3f6224be4 100644
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -899,7 +899,7 @@ static int mtdchar_ioctl(struct file *file, u_int cmd, u_long arg)
 		if (!mtd->block_markbad)
 			ret = -EOPNOTSUPP;
 		else
-			return mtd->block_markbad(mtd, offs);
+			return mtd_block_markbad(mtd, offs);
 		break;
 	}
 

commit 7086c19d07429d697057587caf1e5e0345442d16
Author: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
Date:   Fri Dec 23 19:35:30 2011 +0200

    mtd: introduce mtd_block_isbad interface
    
    Signed-off-by: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
index 6d598b23cf3a..a499bf7a8214 100644
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -886,7 +886,7 @@ static int mtdchar_ioctl(struct file *file, u_int cmd, u_long arg)
 		if (!mtd->block_isbad)
 			ret = -EOPNOTSUPP;
 		else
-			return mtd->block_isbad(mtd, offs);
+			return mtd_block_isbad(mtd, offs);
 		break;
 	}
 

commit e95e9786455c11c8eac30d76e5289d4e40187f9a
Author: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
Date:   Fri Dec 23 19:21:16 2011 +0200

    mtd: introduce mtd_is_locked interface
    
    Signed-off-by: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
index fe09cd2a4540..6d598b23cf3a 100644
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -852,7 +852,7 @@ static int mtdchar_ioctl(struct file *file, u_int cmd, u_long arg)
 		if (!mtd->is_locked)
 			ret = -EOPNOTSUPP;
 		else
-			ret = mtd->is_locked(mtd, einfo.start, einfo.length);
+			ret = mtd_is_locked(mtd, einfo.start, einfo.length);
 		break;
 	}
 

commit b66005cd3e6f104e0a1b6492110c337269b53ec3
Author: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
Date:   Fri Dec 23 19:18:22 2011 +0200

    mtd: introduce mtd_unlock interface
    
    Signed-off-by: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
index 870f2cb415cb..fe09cd2a4540 100644
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -838,7 +838,7 @@ static int mtdchar_ioctl(struct file *file, u_int cmd, u_long arg)
 		if (!mtd->unlock)
 			ret = -EOPNOTSUPP;
 		else
-			ret = mtd->unlock(mtd, einfo.start, einfo.length);
+			ret = mtd_unlock(mtd, einfo.start, einfo.length);
 		break;
 	}
 

commit 7799f9ac8d8ff2db14736950275249df442baeac
Author: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
Date:   Fri Dec 23 19:15:39 2011 +0200

    mtd: introduce mtd_lock interface
    
    Signed-off-by: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
index b5722ecf19d3..870f2cb415cb 100644
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -824,7 +824,7 @@ static int mtdchar_ioctl(struct file *file, u_int cmd, u_long arg)
 		if (!mtd->lock)
 			ret = -EOPNOTSUPP;
 		else
-			ret = mtd->lock(mtd, einfo.start, einfo.length);
+			ret = mtd_lock(mtd, einfo.start, einfo.length);
 		break;
 	}
 

commit 85f2f2a809d658c15b574df02ede92090f45a1f2
Author: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
Date:   Fri Dec 23 19:03:12 2011 +0200

    mtd: introduce mtd_sync interface
    
    Signed-off-by: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
index 86308acb40e0..b5722ecf19d3 100644
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -155,7 +155,7 @@ static int mtdchar_close(struct inode *inode, struct file *file)
 
 	/* Only sync if opened RW */
 	if ((file->f_mode & FMODE_WRITE) && mtd->sync)
-		mtd->sync(mtd);
+		mtd_sync(mtd);
 
 	iput(mfi->ino);
 

commit 4403dbfb4541d34e5db33db709094d57d09f7467
Author: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
Date:   Fri Dec 23 18:55:49 2011 +0200

    mtd: introduce mtd_lock_user_prot_reg interface
    
    Signed-off-by: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
index d8881707ca60..86308acb40e0 100644
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -960,7 +960,7 @@ static int mtdchar_ioctl(struct file *file, u_int cmd, u_long arg)
 			return -EFAULT;
 		if (!mtd->lock_user_prot_reg)
 			return -EOPNOTSUPP;
-		ret = mtd->lock_user_prot_reg(mtd, oinfo.start, oinfo.length);
+		ret = mtd_lock_user_prot_reg(mtd, oinfo.start, oinfo.length);
 		break;
 	}
 #endif

commit 482b43adbb7b124316ec72c161b0d1655e759368
Author: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
Date:   Fri Dec 23 18:50:04 2011 +0200

    mtd: introduce mtd_write_user_prot_reg interface
    
    Signed-off-by: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
index 6aa3fb4a0292..d8881707ca60 100644
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -314,7 +314,8 @@ static ssize_t mtdchar_write(struct file *file, const char __user *buf, size_t c
 				ret = -EOPNOTSUPP;
 				break;
 			}
-			ret = mtd->write_user_prot_reg(mtd, *ppos, len, &retlen, kbuf);
+			ret = mtd_write_user_prot_reg(mtd, *ppos, len,
+						      &retlen, kbuf);
 			break;
 
 		case MTD_FILE_MODE_RAW:

commit 4ea1cabb926f03a8dbd6e3f064538d9a290ee9fd
Author: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
Date:   Fri Dec 23 18:47:59 2011 +0200

    mtd: introduce mtd_read_user_prot_reg interface
    
    Signed-off-by: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
index 002a8b5428cc..6aa3fb4a0292 100644
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -217,7 +217,8 @@ static ssize_t mtdchar_read(struct file *file, char __user *buf, size_t count,
 						     &retlen, kbuf);
 			break;
 		case MTD_FILE_MODE_OTP_USER:
-			ret = mtd->read_user_prot_reg(mtd, *ppos, len, &retlen, kbuf);
+			ret = mtd_read_user_prot_reg(mtd, *ppos, len,
+						     &retlen, kbuf);
 			break;
 		case MTD_FILE_MODE_RAW:
 		{

commit 855e5d8cfebc21f45c9446a88b61e29d94c03781
Author: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
Date:   Fri Dec 23 18:45:11 2011 +0200

    mtd: introduce mtd_get_user_prot_info interface
    
    Signed-off-by: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
index 6afb05469bbd..002a8b5428cc 100644
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -930,7 +930,7 @@ static int mtdchar_ioctl(struct file *file, u_int cmd, u_long arg)
 			break;
 		case MTD_FILE_MODE_OTP_USER:
 			if (mtd->get_user_prot_info)
-				ret = mtd->get_user_prot_info(mtd, buf, 4096);
+				ret = mtd_get_user_prot_info(mtd, buf, 4096);
 			break;
 		default:
 			break;

commit d264f72ae56245358025109d9d066d159589802d
Author: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
Date:   Fri Dec 23 18:40:06 2011 +0200

    mtd: introduce mtd_read_fact_prot_reg interface
    
    Signed-off-by: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
index 4b1772feeafc..6afb05469bbd 100644
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -213,7 +213,8 @@ static ssize_t mtdchar_read(struct file *file, char __user *buf, size_t count,
 
 		switch (mfi->mode) {
 		case MTD_FILE_MODE_OTP_FACTORY:
-			ret = mtd->read_fact_prot_reg(mtd, *ppos, len, &retlen, kbuf);
+			ret = mtd_read_fact_prot_reg(mtd, *ppos, len,
+						     &retlen, kbuf);
 			break;
 		case MTD_FILE_MODE_OTP_USER:
 			ret = mtd->read_user_prot_reg(mtd, *ppos, len, &retlen, kbuf);

commit a750b5ce5e1174ea68f66bf79962c479f7f23998
Author: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
Date:   Fri Dec 23 18:33:28 2011 +0200

    mtd: introduce mtd_get_fact_prot_info interface
    
    Signed-off-by: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
index 234e3d27143c..4b1772feeafc 100644
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -925,7 +925,7 @@ static int mtdchar_ioctl(struct file *file, u_int cmd, u_long arg)
 		switch (mfi->mode) {
 		case MTD_FILE_MODE_OTP_FACTORY:
 			if (mtd->get_fact_prot_info)
-				ret = mtd->get_fact_prot_info(mtd, buf, 4096);
+				ret = mtd_get_fact_prot_info(mtd, buf, 4096);
 			break;
 		case MTD_FILE_MODE_OTP_USER:
 			if (mtd->get_user_prot_info)

commit a2cc5ba075f9bc837d0b4d4ec7328dcefc11859d
Author: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
Date:   Fri Dec 23 18:29:55 2011 +0200

    mtd: introduce mtd_write_oob interface
    
    Signed-off-by: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
index e74f570a7b93..234e3d27143c 100644
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -325,7 +325,7 @@ static ssize_t mtdchar_write(struct file *file, const char __user *buf, size_t c
 			ops.ooboffs = 0;
 			ops.len = len;
 
-			ret = mtd->write_oob(mtd, *ppos, &ops);
+			ret = mtd_write_oob(mtd, *ppos, &ops);
 			retlen = ops.retlen;
 			break;
 		}
@@ -426,7 +426,7 @@ static int mtdchar_writeoob(struct file *file, struct mtd_info *mtd,
 		return PTR_ERR(ops.oobbuf);
 
 	start &= ~((uint64_t)mtd->writesize - 1);
-	ret = mtd->write_oob(mtd, start, &ops);
+	ret = mtd_write_oob(mtd, start, &ops);
 
 	if (ops.oobretlen > 0xFFFFFFFFU)
 		ret = -EOVERFLOW;
@@ -609,7 +609,7 @@ static int mtdchar_write_ioctl(struct mtd_info *mtd,
 		ops.oobbuf = NULL;
 	}
 
-	ret = mtd->write_oob(mtd, (loff_t)req.start, &ops);
+	ret = mtd_write_oob(mtd, (loff_t)req.start, &ops);
 
 	kfree(ops.datbuf);
 	kfree(ops.oobbuf);

commit fd2819bbc92fc98bed5d612e4acbe16b6326f6bf
Author: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
Date:   Fri Dec 23 18:27:05 2011 +0200

    mtd: introduce mtd_read_oob interface
    
    Signed-off-by: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
index 922da31d2c6b..e74f570a7b93 100644
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -227,7 +227,7 @@ static ssize_t mtdchar_read(struct file *file, char __user *buf, size_t count,
 			ops.oobbuf = NULL;
 			ops.len = len;
 
-			ret = mtd->read_oob(mtd, *ppos, &ops);
+			ret = mtd_read_oob(mtd, *ppos, &ops);
 			retlen = ops.retlen;
 			break;
 		}
@@ -471,7 +471,7 @@ static int mtdchar_readoob(struct file *file, struct mtd_info *mtd,
 		return -ENOMEM;
 
 	start &= ~((uint64_t)mtd->writesize - 1);
-	ret = mtd->read_oob(mtd, start, &ops);
+	ret = mtd_read_oob(mtd, start, &ops);
 
 	if (put_user(ops.oobretlen, retp))
 		ret = -EFAULT;

commit eda95cbf75193808f62948fb0142ba0901d8bee2
Author: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
Date:   Fri Dec 23 17:35:41 2011 +0200

    mtd: introduce mtd_write interface
    
    Signed-off-by: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
index c7f484687fa3..922da31d2c6b 100644
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -331,7 +331,7 @@ static ssize_t mtdchar_write(struct file *file, const char __user *buf, size_t c
 		}
 
 		default:
-			ret = (*(mtd->write))(mtd, *ppos, len, &retlen, kbuf);
+			ret = mtd_write(mtd, *ppos, len, &retlen, kbuf);
 		}
 		if (!ret) {
 			*ppos += retlen;

commit 329ad399a9b3adf52c90637b21ca029fcf7f8795
Author: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
Date:   Fri Dec 23 17:30:16 2011 +0200

    mtd: introduce mtd_read interface
    
    Signed-off-by: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
index c51f04a00afb..c7f484687fa3 100644
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -232,7 +232,7 @@ static ssize_t mtdchar_read(struct file *file, char __user *buf, size_t count,
 			break;
 		}
 		default:
-			ret = mtd->read(mtd, *ppos, len, &retlen, kbuf);
+			ret = mtd_read(mtd, *ppos, len, &retlen, kbuf);
 		}
 		/* Nand returns -EBADMSG on ECC errors, but it returns
 		 * the data. For our userspace tools it is important

commit 04c601bfa4cb29c968dcb66e44c799c9c01d8675
Author: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
Date:   Fri Dec 23 17:10:15 2011 +0200

    mtd: introduce mtd_get_unmapped_area interface
    
    Signed-off-by: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
index 41d64ff4c252..c51f04a00afb 100644
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -1135,7 +1135,7 @@ static unsigned long mtdchar_get_unmapped_area(struct file *file,
 		if (offset > mtd->size - len)
 			return (unsigned long) -EINVAL;
 
-		return mtd->get_unmapped_area(mtd, len, offset, flags);
+		return mtd_get_unmapped_area(mtd, len, offset, flags);
 	}
 
 	/* can't map directly */

commit 7e1f0dc0551b99acb5e8fa161a7ac401994d57d8
Author: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
Date:   Fri Dec 23 15:25:39 2011 +0200

    mtd: introduce mtd_erase interface
    
    This patch is part of a patch-set which changes the MTD interface
    from 'mtd->func()' form to 'mtd_func()' form. We need this because
    we want to add common code to to all drivers in the mtd core level,
    which is impossible with the current interface when MTD clients
    call driver functions like 'read()' or 'write()' directly.
    
    At this point we just introduce a new inline wrapper function, but
    later some of them are expected to gain more code. E.g., the input
    parameters check should be moved to the wrappers rather than be
    duplicated at many drivers.
    
    This particular patch introduced the 'mtd_erase()' interface. The
    following patches add all the other interfaces one by one.
    
    Signed-off-by: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
index 00423cc85807..41d64ff4c252 100644
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -731,7 +731,7 @@ static int mtdchar_ioctl(struct file *file, u_int cmd, u_long arg)
 			  wq_head is no longer there when the
 			  callback routine tries to wake us up.
 			*/
-			ret = mtd->erase(mtd, erase);
+			ret = mtd_erase(mtd, erase);
 			if (!ret) {
 				set_current_state(TASK_UNINTERRUPTIBLE);
 				add_wait_queue(&waitq, &wait);

commit 969e57adc2589a0a0ae5edbbe7b92062565ce70b
Author: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
Date:   Fri Dec 23 17:27:46 2011 +0200

    mtd: mtdchar: rename functions
    
    We are going to re-work the MTD interface and change 'mtd->write()' to
    'mtd_write()', 'mtd->read()' to 'mtd_read()' and so forth for all functions
    in the 'struct mtd_info' structure.
    
    However, mtdchar.c has its own 'mtd_read()', 'mtd_write()', etc functions
    which collide with our changes. This patch renames these functions
    to 'mtdchar_read()', 'mtdchar_write()', etc.
    
    Additionally, to make the 'mtdchar.c' file look consistent, rename
    similarly all the other functions starting with 'mtd_'.
    
    Signed-off-by: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
index e7dc732ddabc..00423cc85807 100644
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -51,7 +51,7 @@ struct mtd_file_info {
 	enum mtd_file_modes mode;
 };
 
-static loff_t mtd_lseek (struct file *file, loff_t offset, int orig)
+static loff_t mtdchar_lseek(struct file *file, loff_t offset, int orig)
 {
 	struct mtd_file_info *mfi = file->private_data;
 	struct mtd_info *mtd = mfi->mtd;
@@ -77,7 +77,7 @@ static loff_t mtd_lseek (struct file *file, loff_t offset, int orig)
 
 
 
-static int mtd_open(struct inode *inode, struct file *file)
+static int mtdchar_open(struct inode *inode, struct file *file)
 {
 	int minor = iminor(inode);
 	int devnum = minor >> 1;
@@ -142,11 +142,11 @@ static int mtd_open(struct inode *inode, struct file *file)
 out:
 	mutex_unlock(&mtd_mutex);
 	return ret;
-} /* mtd_open */
+} /* mtdchar_open */
 
 /*====================================================================*/
 
-static int mtd_close(struct inode *inode, struct file *file)
+static int mtdchar_close(struct inode *inode, struct file *file)
 {
 	struct mtd_file_info *mfi = file->private_data;
 	struct mtd_info *mtd = mfi->mtd;
@@ -164,7 +164,7 @@ static int mtd_close(struct inode *inode, struct file *file)
 	kfree(mfi);
 
 	return 0;
-} /* mtd_close */
+} /* mtdchar_close */
 
 /* Back in June 2001, dwmw2 wrote:
  *
@@ -184,7 +184,8 @@ static int mtd_close(struct inode *inode, struct file *file)
  * alignment requirements are not met in the NAND subdriver.
  */
 
-static ssize_t mtd_read(struct file *file, char __user *buf, size_t count,loff_t *ppos)
+static ssize_t mtdchar_read(struct file *file, char __user *buf, size_t count,
+			loff_t *ppos)
 {
 	struct mtd_file_info *mfi = file->private_data;
 	struct mtd_info *mtd = mfi->mtd;
@@ -265,9 +266,10 @@ static ssize_t mtd_read(struct file *file, char __user *buf, size_t count,loff_t
 
 	kfree(kbuf);
 	return total_retlen;
-} /* mtd_read */
+} /* mtdchar_read */
 
-static ssize_t mtd_write(struct file *file, const char __user *buf, size_t count,loff_t *ppos)
+static ssize_t mtdchar_write(struct file *file, const char __user *buf, size_t count,
+			loff_t *ppos)
 {
 	struct mtd_file_info *mfi = file->private_data;
 	struct mtd_info *mtd = mfi->mtd;
@@ -345,7 +347,7 @@ static ssize_t mtd_write(struct file *file, const char __user *buf, size_t count
 
 	kfree(kbuf);
 	return total_retlen;
-} /* mtd_write */
+} /* mtdchar_write */
 
 /*======================================================================
 
@@ -387,7 +389,7 @@ static int otp_select_filemode(struct mtd_file_info *mfi, int mode)
 # define otp_select_filemode(f,m)	-EOPNOTSUPP
 #endif
 
-static int mtd_do_writeoob(struct file *file, struct mtd_info *mtd,
+static int mtdchar_writeoob(struct file *file, struct mtd_info *mtd,
 	uint64_t start, uint32_t length, void __user *ptr,
 	uint32_t __user *retp)
 {
@@ -436,7 +438,7 @@ static int mtd_do_writeoob(struct file *file, struct mtd_info *mtd,
 	return ret;
 }
 
-static int mtd_do_readoob(struct file *file, struct mtd_info *mtd,
+static int mtdchar_readoob(struct file *file, struct mtd_info *mtd,
 	uint64_t start, uint32_t length, void __user *ptr,
 	uint32_t __user *retp)
 {
@@ -530,7 +532,7 @@ static int shrink_ecclayout(const struct nand_ecclayout *from,
 	return 0;
 }
 
-static int mtd_blkpg_ioctl(struct mtd_info *mtd,
+static int mtdchar_blkpg_ioctl(struct mtd_info *mtd,
 			   struct blkpg_ioctl_arg __user *arg)
 {
 	struct blkpg_ioctl_arg a;
@@ -566,7 +568,7 @@ static int mtd_blkpg_ioctl(struct mtd_info *mtd,
 	}
 }
 
-static int mtd_write_ioctl(struct mtd_info *mtd,
+static int mtdchar_write_ioctl(struct mtd_info *mtd,
 		struct mtd_write_req __user *argp)
 {
 	struct mtd_write_req req;
@@ -615,7 +617,7 @@ static int mtd_write_ioctl(struct mtd_info *mtd,
 	return ret;
 }
 
-static int mtd_ioctl(struct file *file, u_int cmd, u_long arg)
+static int mtdchar_ioctl(struct file *file, u_int cmd, u_long arg)
 {
 	struct mtd_file_info *mfi = file->private_data;
 	struct mtd_info *mtd = mfi->mtd;
@@ -755,7 +757,7 @@ static int mtd_ioctl(struct file *file, u_int cmd, u_long arg)
 		if (copy_from_user(&buf, argp, sizeof(buf)))
 			ret = -EFAULT;
 		else
-			ret = mtd_do_writeoob(file, mtd, buf.start, buf.length,
+			ret = mtdchar_writeoob(file, mtd, buf.start, buf.length,
 				buf.ptr, &buf_user->length);
 		break;
 	}
@@ -769,7 +771,7 @@ static int mtd_ioctl(struct file *file, u_int cmd, u_long arg)
 		if (copy_from_user(&buf, argp, sizeof(buf)))
 			ret = -EFAULT;
 		else
-			ret = mtd_do_readoob(file, mtd, buf.start, buf.length,
+			ret = mtdchar_readoob(file, mtd, buf.start, buf.length,
 				buf.ptr, &buf_user->start);
 		break;
 	}
@@ -782,7 +784,7 @@ static int mtd_ioctl(struct file *file, u_int cmd, u_long arg)
 		if (copy_from_user(&buf, argp, sizeof(buf)))
 			ret = -EFAULT;
 		else
-			ret = mtd_do_writeoob(file, mtd, buf.start, buf.length,
+			ret = mtdchar_writeoob(file, mtd, buf.start, buf.length,
 				(void __user *)(uintptr_t)buf.usr_ptr,
 				&buf_user->length);
 		break;
@@ -796,7 +798,7 @@ static int mtd_ioctl(struct file *file, u_int cmd, u_long arg)
 		if (copy_from_user(&buf, argp, sizeof(buf)))
 			ret = -EFAULT;
 		else
-			ret = mtd_do_readoob(file, mtd, buf.start, buf.length,
+			ret = mtdchar_readoob(file, mtd, buf.start, buf.length,
 				(void __user *)(uintptr_t)buf.usr_ptr,
 				&buf_user->length);
 		break;
@@ -804,7 +806,7 @@ static int mtd_ioctl(struct file *file, u_int cmd, u_long arg)
 
 	case MEMWRITE:
 	{
-		ret = mtd_write_ioctl(mtd,
+		ret = mtdchar_write_ioctl(mtd,
 		      (struct mtd_write_req __user *)arg);
 		break;
 	}
@@ -1014,7 +1016,7 @@ static int mtd_ioctl(struct file *file, u_int cmd, u_long arg)
 
 	case BLKPG:
 	{
-		ret = mtd_blkpg_ioctl(mtd,
+		ret = mtdchar_blkpg_ioctl(mtd,
 		      (struct blkpg_ioctl_arg __user *)arg);
 		break;
 	}
@@ -1033,12 +1035,12 @@ static int mtd_ioctl(struct file *file, u_int cmd, u_long arg)
 	return ret;
 } /* memory_ioctl */
 
-static long mtd_unlocked_ioctl(struct file *file, u_int cmd, u_long arg)
+static long mtdchar_unlocked_ioctl(struct file *file, u_int cmd, u_long arg)
 {
 	int ret;
 
 	mutex_lock(&mtd_mutex);
-	ret = mtd_ioctl(file, cmd, arg);
+	ret = mtdchar_ioctl(file, cmd, arg);
 	mutex_unlock(&mtd_mutex);
 
 	return ret;
@@ -1055,7 +1057,7 @@ struct mtd_oob_buf32 {
 #define MEMWRITEOOB32		_IOWR('M', 3, struct mtd_oob_buf32)
 #define MEMREADOOB32		_IOWR('M', 4, struct mtd_oob_buf32)
 
-static long mtd_compat_ioctl(struct file *file, unsigned int cmd,
+static long mtdchar_compat_ioctl(struct file *file, unsigned int cmd,
 	unsigned long arg)
 {
 	struct mtd_file_info *mfi = file->private_data;
@@ -1074,7 +1076,7 @@ static long mtd_compat_ioctl(struct file *file, unsigned int cmd,
 		if (copy_from_user(&buf, argp, sizeof(buf)))
 			ret = -EFAULT;
 		else
-			ret = mtd_do_writeoob(file, mtd, buf.start,
+			ret = mtdchar_writeoob(file, mtd, buf.start,
 				buf.length, compat_ptr(buf.ptr),
 				&buf_user->length);
 		break;
@@ -1089,13 +1091,13 @@ static long mtd_compat_ioctl(struct file *file, unsigned int cmd,
 		if (copy_from_user(&buf, argp, sizeof(buf)))
 			ret = -EFAULT;
 		else
-			ret = mtd_do_readoob(file, mtd, buf.start,
+			ret = mtdchar_readoob(file, mtd, buf.start,
 				buf.length, compat_ptr(buf.ptr),
 				&buf_user->start);
 		break;
 	}
 	default:
-		ret = mtd_ioctl(file, cmd, (unsigned long)argp);
+		ret = mtdchar_ioctl(file, cmd, (unsigned long)argp);
 	}
 
 	mutex_unlock(&mtd_mutex);
@@ -1111,7 +1113,7 @@ static long mtd_compat_ioctl(struct file *file, unsigned int cmd,
  *   mappings)
  */
 #ifndef CONFIG_MMU
-static unsigned long mtd_get_unmapped_area(struct file *file,
+static unsigned long mtdchar_get_unmapped_area(struct file *file,
 					   unsigned long addr,
 					   unsigned long len,
 					   unsigned long pgoff,
@@ -1144,7 +1146,7 @@ static unsigned long mtd_get_unmapped_area(struct file *file,
 /*
  * set up a mapping for shared memory segments
  */
-static int mtd_mmap(struct file *file, struct vm_area_struct *vma)
+static int mtdchar_mmap(struct file *file, struct vm_area_struct *vma)
 {
 #ifdef CONFIG_MMU
 	struct mtd_file_info *mfi = file->private_data;
@@ -1185,18 +1187,18 @@ static int mtd_mmap(struct file *file, struct vm_area_struct *vma)
 
 static const struct file_operations mtd_fops = {
 	.owner		= THIS_MODULE,
-	.llseek		= mtd_lseek,
-	.read		= mtd_read,
-	.write		= mtd_write,
-	.unlocked_ioctl	= mtd_unlocked_ioctl,
+	.llseek		= mtdchar_lseek,
+	.read		= mtdchar_read,
+	.write		= mtdchar_write,
+	.unlocked_ioctl	= mtdchar_unlocked_ioctl,
 #ifdef CONFIG_COMPAT
-	.compat_ioctl	= mtd_compat_ioctl,
+	.compat_ioctl	= mtdchar_compat_ioctl,
 #endif
-	.open		= mtd_open,
-	.release	= mtd_close,
-	.mmap		= mtd_mmap,
+	.open		= mtdchar_open,
+	.release	= mtdchar_close,
+	.mmap		= mtdchar_mmap,
 #ifndef CONFIG_MMU
-	.get_unmapped_area = mtd_get_unmapped_area,
+	.get_unmapped_area = mtdchar_get_unmapped_area,
 #endif
 };
 

commit e0d65113a70f1dc514e625cc4e7a7485a4bf72df
Merge: cf5e15fbd72c 48e546b7f281
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Nov 7 09:11:16 2011 -0800

    Merge git://git.infradead.org/mtd-2.6
    
    * git://git.infradead.org/mtd-2.6: (226 commits)
      mtd: tests: annotate as DANGEROUS in Kconfig
      mtd: tests: don't use mtd0 as a default
      mtd: clean up usage of MTD_DOCPROBE_ADDRESS
      jffs2: add compr=lzo and compr=zlib options
      jffs2: implement mount option parsing and compression overriding
      mtd: nand: initialize ops.mode
      mtd: provide an alias for the redboot module name
      mtd: m25p80: don't probe device which has status of 'disabled'
      mtd: nand_h1900 never worked
      mtd: Add DiskOnChip G3 support
      mtd: m25p80: add EON flash EN25Q32B into spi flash id table
      mtd: mark block device queue as non-rotational
      mtd: r852: make r852_pm_ops static
      mtd: m25p80: add support for at25df321a spi data flash
      mtd: mxc_nand: preset_v1_v2: unlock all NAND flash blocks
      mtd: nand: switch `check_pattern()' to standard `memcmp()'
      mtd: nand: invalidate cache on unaligned reads
      mtd: nand: do not scan bad blocks with NAND_BBT_NO_OOB set
      mtd: nand: wait to set BBT version
      mtd: nand: scrub BBT on ECC errors
      ...
    
    Fix up trivial conflicts:
     - arch/arm/mach-at91/board-usb-a9260.c
            Merged into board-usb-a926x.c
     - drivers/mtd/maps/lantiq-flash.c
            add_mtd_partitions -> mtd_device_register vs changed to use
            mtd_device_parse_register.

commit 6d6b77f163c7eabedbba00ed2abb7d4a570bff76
Author: Miklos Szeredi <mszeredi@suse.cz>
Date:   Fri Oct 28 14:13:28 2011 +0200

    filesystems: add missing nlink wrappers
    
    Replace direct i_nlink updates with the respective updater function
    (inc_nlink, drop_nlink, clear_nlink, inode_dec_link_count).
    
    Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>

diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
index f1af2228a1b1..61086ea3cc6b 100644
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -1144,7 +1144,7 @@ static void mtdchar_notify_remove(struct mtd_info *mtd)
 
 	if (mtd_ino) {
 		/* Destroy the inode if it exists */
-		mtd_ino->i_nlink = 0;
+		clear_nlink(mtd_ino);
 		iput(mtd_ino);
 	}
 }

commit d57f40544a41fdfe90fd863b6865138c5a82f1cc
Author: Brian Norris <computersforpeace@gmail.com>
Date:   Tue Sep 20 18:34:25 2011 -0700

    mtd: utilize `mtd_is_*()' functions
    
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>
    Signed-off-by: Artem Bityutskiy <artem.bityutskiy@intel.com>

diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
index 8feb5fdcd97b..47be6e5cefe4 100644
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -242,7 +242,7 @@ static ssize_t mtd_read(struct file *file, char __user *buf, size_t count,loff_t
 		 * Userspace software which accesses NAND this way
 		 * must be aware of the fact that it deals with NAND
 		 */
-		if (!ret || (ret == -EUCLEAN) || (ret == -EBADMSG)) {
+		if (!ret || mtd_is_bitflip_or_eccerr(ret)) {
 			*ppos += retlen;
 			if (copy_to_user(buf, kbuf, retlen)) {
 				kfree(kbuf);
@@ -491,7 +491,7 @@ static int mtd_do_readoob(struct file *file, struct mtd_info *mtd,
 	 * does not calculate ECC for the OOB area, so do not rely on
 	 * this behavior unless you have replaced it with your own.
 	 */
-	if (ret == -EUCLEAN || ret == -EBADMSG)
+	if (mtd_is_bitflip_or_eccerr(ret))
 		return 0;
 
 	return ret;

commit 19fb4341ad7a72e4c996234a1834e52e1f7954ba
Author: Brian Norris <computersforpeace@gmail.com>
Date:   Tue Aug 30 18:45:46 2011 -0700

    mtd: kill old field for `struct mtd_info_user'
    
    The ecctype and eccsize fields have been obsolete for a while. Since they
    don't have any users, we can kill them and leave padding in their place
    for now.
    
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>
    Signed-off-by: Artem Bityutskiy <artem.bityutskiy@intel.com>

diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
index 1547e2a68279..8feb5fdcd97b 100644
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -672,8 +672,8 @@ static int mtd_ioctl(struct file *file, u_int cmd, u_long arg)
 		info.erasesize	= mtd->erasesize;
 		info.writesize	= mtd->writesize;
 		info.oobsize	= mtd->oobsize;
-		/* The below fields are obsolete */
-		info.ecctype	= -1;
+		/* The below field is obsolete */
+		info.padding	= 0;
 		if (copy_to_user(argp, &info, sizeof(struct mtd_info_user)))
 			return -EFAULT;
 		break;

commit e99d8b089a6c6fd72f022168e3bf8f22d4e5e137
Author: Brian Norris <computersforpeace@gmail.com>
Date:   Fri Sep 9 09:59:03 2011 -0700

    mtd: add MEMWRITE ioctl
    
    Implement a new ioctl for writing both page data and OOB to flash at the
    same time. This ioctl is intended to be a generic interface that can
    replace other ioctls (MEMWRITEOOB and MEMWRITEOOB64) and cover the
    functionality of several other old ones, e.g., MEMWRITE can:
    
    * write autoplaced OOB instead of using ECCGETLAYOUT (deprecated) and
      working around the reserved areas
    * write raw (no ECC) OOB instead of using MTDFILEMODE to set the
      per-file-descriptor MTD_FILE_MODE_RAW
    * write raw (no ECC) data instead of using MTDFILEMODE
      (MTD_FILE_MODE_RAW) and using standard character device "write"
    
    This ioctl is especially useful for MLC NAND, which cannot be written
    twice (i.e., we cannot successfully write the page data and OOB in two
    separate operations). Instead, MEMWRITE can write both in a single
    operation.
    
    Note that this ioctl is not affected by the MTD file mode (i.e.,
    MTD_FILE_MODE_RAW vs. MTD_FILE_MODE_NORMAL), since it receives its write
    mode as an input parameter.
    
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>
    Signed-off-by: Artem Bityutskiy <artem.bityutskiy@intel.com>

diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
index 4004f2b2f403..1547e2a68279 100644
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -566,6 +566,55 @@ static int mtd_blkpg_ioctl(struct mtd_info *mtd,
 	}
 }
 
+static int mtd_write_ioctl(struct mtd_info *mtd,
+		struct mtd_write_req __user *argp)
+{
+	struct mtd_write_req req;
+	struct mtd_oob_ops ops;
+	void __user *usr_data, *usr_oob;
+	int ret;
+
+	if (copy_from_user(&req, argp, sizeof(req)) ||
+			!access_ok(VERIFY_READ, req.usr_data, req.len) ||
+			!access_ok(VERIFY_READ, req.usr_oob, req.ooblen))
+		return -EFAULT;
+	if (!mtd->write_oob)
+		return -EOPNOTSUPP;
+
+	ops.mode = req.mode;
+	ops.len = (size_t)req.len;
+	ops.ooblen = (size_t)req.ooblen;
+	ops.ooboffs = 0;
+
+	usr_data = (void __user *)(uintptr_t)req.usr_data;
+	usr_oob = (void __user *)(uintptr_t)req.usr_oob;
+
+	if (req.usr_data) {
+		ops.datbuf = memdup_user(usr_data, ops.len);
+		if (IS_ERR(ops.datbuf))
+			return PTR_ERR(ops.datbuf);
+	} else {
+		ops.datbuf = NULL;
+	}
+
+	if (req.usr_oob) {
+		ops.oobbuf = memdup_user(usr_oob, ops.ooblen);
+		if (IS_ERR(ops.oobbuf)) {
+			kfree(ops.datbuf);
+			return PTR_ERR(ops.oobbuf);
+		}
+	} else {
+		ops.oobbuf = NULL;
+	}
+
+	ret = mtd->write_oob(mtd, (loff_t)req.start, &ops);
+
+	kfree(ops.datbuf);
+	kfree(ops.oobbuf);
+
+	return ret;
+}
+
 static int mtd_ioctl(struct file *file, u_int cmd, u_long arg)
 {
 	struct mtd_file_info *mfi = file->private_data;
@@ -753,6 +802,13 @@ static int mtd_ioctl(struct file *file, u_int cmd, u_long arg)
 		break;
 	}
 
+	case MEMWRITE:
+	{
+		ret = mtd_write_ioctl(mtd,
+		      (struct mtd_write_req __user *)arg);
+		break;
+	}
+
 	case MEMLOCK:
 	{
 		struct erase_info_user einfo;

commit beb133fc165e1289c858d8f952b982b7d0b313cd
Author: Brian Norris <computersforpeace@gmail.com>
Date:   Tue Aug 30 18:45:41 2011 -0700

    mtd: rename MTD_MODE_* to MTD_FILE_MODE_*
    
    These modes hold their state only for the life of their file descriptor,
    and they overlap functionality with the MTD_OPS_* modes. Particularly,
    MTD_MODE_RAW and MTD_OPS_RAW cover the same function: to provide raw
    (i.e., without ECC) access to the flash. In fact, although it may not be
    clear, MTD_MODE_RAW implied that operations should enable the
    MTD_OPS_RAW mode.
    
    Thus, we should be specific on what each mode means. This is a start,
    where MTD_FILE_MODE_* actually represents a "file mode," not necessarily
    a true global MTD mode.
    
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>
    Signed-off-by: Artem Bityutskiy <artem.bityutskiy@intel.com>

diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
index 9b76438a3c27..4004f2b2f403 100644
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -211,13 +211,13 @@ static ssize_t mtd_read(struct file *file, char __user *buf, size_t count,loff_t
 		len = min_t(size_t, count, size);
 
 		switch (mfi->mode) {
-		case MTD_MODE_OTP_FACTORY:
+		case MTD_FILE_MODE_OTP_FACTORY:
 			ret = mtd->read_fact_prot_reg(mtd, *ppos, len, &retlen, kbuf);
 			break;
-		case MTD_MODE_OTP_USER:
+		case MTD_FILE_MODE_OTP_USER:
 			ret = mtd->read_user_prot_reg(mtd, *ppos, len, &retlen, kbuf);
 			break;
-		case MTD_MODE_RAW:
+		case MTD_FILE_MODE_RAW:
 		{
 			struct mtd_oob_ops ops;
 
@@ -302,10 +302,10 @@ static ssize_t mtd_write(struct file *file, const char __user *buf, size_t count
 		}
 
 		switch (mfi->mode) {
-		case MTD_MODE_OTP_FACTORY:
+		case MTD_FILE_MODE_OTP_FACTORY:
 			ret = -EROFS;
 			break;
-		case MTD_MODE_OTP_USER:
+		case MTD_FILE_MODE_OTP_USER:
 			if (!mtd->write_user_prot_reg) {
 				ret = -EOPNOTSUPP;
 				break;
@@ -313,7 +313,7 @@ static ssize_t mtd_write(struct file *file, const char __user *buf, size_t count
 			ret = mtd->write_user_prot_reg(mtd, *ppos, len, &retlen, kbuf);
 			break;
 
-		case MTD_MODE_RAW:
+		case MTD_FILE_MODE_RAW:
 		{
 			struct mtd_oob_ops ops;
 
@@ -368,13 +368,13 @@ static int otp_select_filemode(struct mtd_file_info *mfi, int mode)
 		if (!mtd->read_fact_prot_reg)
 			ret = -EOPNOTSUPP;
 		else
-			mfi->mode = MTD_MODE_OTP_FACTORY;
+			mfi->mode = MTD_FILE_MODE_OTP_FACTORY;
 		break;
 	case MTD_OTP_USER:
 		if (!mtd->read_fact_prot_reg)
 			ret = -EOPNOTSUPP;
 		else
-			mfi->mode = MTD_MODE_OTP_USER;
+			mfi->mode = MTD_FILE_MODE_OTP_USER;
 		break;
 	default:
 		ret = -EINVAL;
@@ -413,7 +413,7 @@ static int mtd_do_writeoob(struct file *file, struct mtd_info *mtd,
 	ops.ooblen = length;
 	ops.ooboffs = start & (mtd->writesize - 1);
 	ops.datbuf = NULL;
-	ops.mode = (mfi->mode == MTD_MODE_RAW) ? MTD_OPS_RAW :
+	ops.mode = (mfi->mode == MTD_FILE_MODE_RAW) ? MTD_OPS_RAW :
 		MTD_OPS_PLACE_OOB;
 
 	if (ops.ooboffs && ops.ooblen > (mtd->oobsize - ops.ooboffs))
@@ -458,7 +458,7 @@ static int mtd_do_readoob(struct file *file, struct mtd_info *mtd,
 	ops.ooblen = length;
 	ops.ooboffs = start & (mtd->writesize - 1);
 	ops.datbuf = NULL;
-	ops.mode = (mfi->mode == MTD_MODE_RAW) ? MTD_OPS_RAW :
+	ops.mode = (mfi->mode == MTD_FILE_MODE_RAW) ? MTD_OPS_RAW :
 		MTD_OPS_PLACE_OOB;
 
 	if (ops.ooboffs && ops.ooblen > (mtd->oobsize - ops.ooboffs))
@@ -849,7 +849,7 @@ static int mtd_ioctl(struct file *file, u_int cmd, u_long arg)
 		if (copy_from_user(&mode, argp, sizeof(int)))
 			return -EFAULT;
 
-		mfi->mode = MTD_MODE_NORMAL;
+		mfi->mode = MTD_FILE_MODE_NORMAL;
 
 		ret = otp_select_filemode(mfi, mode);
 
@@ -865,11 +865,11 @@ static int mtd_ioctl(struct file *file, u_int cmd, u_long arg)
 			return -ENOMEM;
 		ret = -EOPNOTSUPP;
 		switch (mfi->mode) {
-		case MTD_MODE_OTP_FACTORY:
+		case MTD_FILE_MODE_OTP_FACTORY:
 			if (mtd->get_fact_prot_info)
 				ret = mtd->get_fact_prot_info(mtd, buf, 4096);
 			break;
-		case MTD_MODE_OTP_USER:
+		case MTD_FILE_MODE_OTP_USER:
 			if (mtd->get_user_prot_info)
 				ret = mtd->get_user_prot_info(mtd, buf, 4096);
 			break;
@@ -893,7 +893,7 @@ static int mtd_ioctl(struct file *file, u_int cmd, u_long arg)
 	{
 		struct otp_info oinfo;
 
-		if (mfi->mode != MTD_MODE_OTP_USER)
+		if (mfi->mode != MTD_FILE_MODE_OTP_USER)
 			return -EINVAL;
 		if (copy_from_user(&oinfo, argp, sizeof(oinfo)))
 			return -EFAULT;
@@ -937,17 +937,17 @@ static int mtd_ioctl(struct file *file, u_int cmd, u_long arg)
 		mfi->mode = 0;
 
 		switch(arg) {
-		case MTD_MODE_OTP_FACTORY:
-		case MTD_MODE_OTP_USER:
+		case MTD_FILE_MODE_OTP_FACTORY:
+		case MTD_FILE_MODE_OTP_USER:
 			ret = otp_select_filemode(mfi, arg);
 			break;
 
-		case MTD_MODE_RAW:
+		case MTD_FILE_MODE_RAW:
 			if (!mtd->read_oob || !mtd->write_oob)
 				return -EOPNOTSUPP;
 			mfi->mode = arg;
 
-		case MTD_MODE_NORMAL:
+		case MTD_FILE_MODE_NORMAL:
 			break;
 		default:
 			ret = -EINVAL;

commit 0612b9ddc2eeda014dd805c87c752b342d8f80f0
Author: Brian Norris <computersforpeace@gmail.com>
Date:   Tue Aug 30 18:45:40 2011 -0700

    mtd: rename MTD_OOB_* to MTD_OPS_*
    
    These modes are not necessarily for OOB only. Particularly, MTD_OOB_RAW
    affected operations on in-band page data as well. To clarify these
    options and to emphasize that their effect is applied per-operation, we
    change the primary prefix to MTD_OPS_.
    
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>
    Signed-off-by: Artem Bityutskiy <artem.bityutskiy@intel.com>

diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
index d0eaef67b9bb..9b76438a3c27 100644
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -221,7 +221,7 @@ static ssize_t mtd_read(struct file *file, char __user *buf, size_t count,loff_t
 		{
 			struct mtd_oob_ops ops;
 
-			ops.mode = MTD_OOB_RAW;
+			ops.mode = MTD_OPS_RAW;
 			ops.datbuf = kbuf;
 			ops.oobbuf = NULL;
 			ops.len = len;
@@ -317,7 +317,7 @@ static ssize_t mtd_write(struct file *file, const char __user *buf, size_t count
 		{
 			struct mtd_oob_ops ops;
 
-			ops.mode = MTD_OOB_RAW;
+			ops.mode = MTD_OPS_RAW;
 			ops.datbuf = kbuf;
 			ops.oobbuf = NULL;
 			ops.ooboffs = 0;
@@ -413,7 +413,8 @@ static int mtd_do_writeoob(struct file *file, struct mtd_info *mtd,
 	ops.ooblen = length;
 	ops.ooboffs = start & (mtd->writesize - 1);
 	ops.datbuf = NULL;
-	ops.mode = (mfi->mode == MTD_MODE_RAW) ? MTD_OOB_RAW : MTD_OOB_PLACE;
+	ops.mode = (mfi->mode == MTD_MODE_RAW) ? MTD_OPS_RAW :
+		MTD_OPS_PLACE_OOB;
 
 	if (ops.ooboffs && ops.ooblen > (mtd->oobsize - ops.ooboffs))
 		return -EINVAL;
@@ -457,7 +458,8 @@ static int mtd_do_readoob(struct file *file, struct mtd_info *mtd,
 	ops.ooblen = length;
 	ops.ooboffs = start & (mtd->writesize - 1);
 	ops.datbuf = NULL;
-	ops.mode = (mfi->mode == MTD_MODE_RAW) ? MTD_OOB_RAW : MTD_OOB_PLACE;
+	ops.mode = (mfi->mode == MTD_MODE_RAW) ? MTD_OPS_RAW :
+		MTD_OPS_PLACE_OOB;
 
 	if (ops.ooboffs && ops.ooblen > (mtd->oobsize - ops.ooboffs))
 		return -EINVAL;

commit c46f6483d21e93400e4a110de7902830173d53b0
Author: Brian Norris <computersforpeace@gmail.com>
Date:   Tue Aug 30 18:45:38 2011 -0700

    mtd: support reading OOB without ECC
    
    This fixes issues with `nanddump -n' and the MEMREADOOB[64] ioctls on
    hardware that performs error correction when reading only OOB data. A
    driver for such hardware needs to know when we're doing a RAW vs. a
    normal write, but mtd_do_read_oob does not pass such information to the
    lower layers (e.g., NAND). We should pass MTD_OOB_RAW or MTD_OOB_PLACE
    based on the MTD file mode.
    
    For now, most drivers can get away with just setting:
    
      chip->ecc.read_oob_raw = chip->ecc.read_oob
    
    This is done by default; but for systems that behave as described above,
    you must supply your own replacement function.
    
    This was tested with nandsim as well as on actual SLC NAND.
    
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>
    Cc: Jim Quinlan <jim2101024@gmail.com>
    Signed-off-by: Artem Bityutskiy <artem.bityutskiy@intel.com>

diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
index bcb7f05fd27b..d0eaef67b9bb 100644
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -435,9 +435,11 @@ static int mtd_do_writeoob(struct file *file, struct mtd_info *mtd,
 	return ret;
 }
 
-static int mtd_do_readoob(struct mtd_info *mtd, uint64_t start,
-	uint32_t length, void __user *ptr, uint32_t __user *retp)
+static int mtd_do_readoob(struct file *file, struct mtd_info *mtd,
+	uint64_t start, uint32_t length, void __user *ptr,
+	uint32_t __user *retp)
 {
+	struct mtd_file_info *mfi = file->private_data;
 	struct mtd_oob_ops ops;
 	int ret = 0;
 
@@ -455,7 +457,7 @@ static int mtd_do_readoob(struct mtd_info *mtd, uint64_t start,
 	ops.ooblen = length;
 	ops.ooboffs = start & (mtd->writesize - 1);
 	ops.datbuf = NULL;
-	ops.mode = MTD_OOB_PLACE;
+	ops.mode = (mfi->mode == MTD_MODE_RAW) ? MTD_OOB_RAW : MTD_OOB_PLACE;
 
 	if (ops.ooboffs && ops.ooblen > (mtd->oobsize - ops.ooboffs))
 		return -EINVAL;
@@ -716,7 +718,7 @@ static int mtd_ioctl(struct file *file, u_int cmd, u_long arg)
 		if (copy_from_user(&buf, argp, sizeof(buf)))
 			ret = -EFAULT;
 		else
-			ret = mtd_do_readoob(mtd, buf.start, buf.length,
+			ret = mtd_do_readoob(file, mtd, buf.start, buf.length,
 				buf.ptr, &buf_user->start);
 		break;
 	}
@@ -743,7 +745,7 @@ static int mtd_ioctl(struct file *file, u_int cmd, u_long arg)
 		if (copy_from_user(&buf, argp, sizeof(buf)))
 			ret = -EFAULT;
 		else
-			ret = mtd_do_readoob(mtd, buf.start, buf.length,
+			ret = mtd_do_readoob(file, mtd, buf.start, buf.length,
 				(void __user *)(uintptr_t)buf.usr_ptr,
 				&buf_user->length);
 		break;
@@ -1029,7 +1031,7 @@ static long mtd_compat_ioctl(struct file *file, unsigned int cmd,
 		if (copy_from_user(&buf, argp, sizeof(buf)))
 			ret = -EFAULT;
 		else
-			ret = mtd_do_readoob(mtd, buf.start,
+			ret = mtd_do_readoob(file, mtd, buf.start,
 				buf.length, compat_ptr(buf.ptr),
 				&buf_user->start);
 		break;

commit 9ce244b3fb416ce6600e05612ac46b9692dcc638
Author: Brian Norris <computersforpeace@gmail.com>
Date:   Tue Aug 30 18:45:37 2011 -0700

    mtd: support writing OOB without ECC
    
    This fixes issues with `nandwrite -n -o' and the MEMWRITEOOB[64] ioctls
    on hardware that writes ECC when writing OOB. The problem arises as
    follows: `nandwrite -n' can write page data to flash without applying
    ECC, but when used with the `-o' option, ECC is applied (incorrectly),
    contrary to the `--noecc' option.
    
    I found that this is the case because my hardware computes and writes
    ECC data to flash upon either OOB write or page write. Thus, to support
    a proper "no ECC" write, my driver must know when we're performing a raw
    OOB write vs. a normal ECC OOB write. However, MTD does not pass any raw
    mode information to the write_oob functions.  This patch addresses the
    problems by:
    
    1) Passing MTD_OOB_RAW down to lower layers, instead of just defaulting
       to MTD_OOB_PLACE
    2) Handling MTD_OOB_RAW within the NAND layer's `nand_do_write_oob'
    3) Adding a new (replaceable) function pointer in struct ecc_ctrl; this
       function should support writing OOB without ECC data. Current
       hardware often can use the same OOB write function when writing
       either with or without ECC
    
    This was tested with nandsim as well as on actual SLC NAND.
    
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>
    Cc: Jim Quinlan <jim2101024@gmail.com>
    Signed-off-by: Artem Bityutskiy <artem.bityutskiy@intel.com>

diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
index b20625475132..bcb7f05fd27b 100644
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -391,6 +391,7 @@ static int mtd_do_writeoob(struct file *file, struct mtd_info *mtd,
 	uint64_t start, uint32_t length, void __user *ptr,
 	uint32_t __user *retp)
 {
+	struct mtd_file_info *mfi = file->private_data;
 	struct mtd_oob_ops ops;
 	uint32_t retlen;
 	int ret = 0;
@@ -412,7 +413,7 @@ static int mtd_do_writeoob(struct file *file, struct mtd_info *mtd,
 	ops.ooblen = length;
 	ops.ooboffs = start & (mtd->writesize - 1);
 	ops.datbuf = NULL;
-	ops.mode = MTD_OOB_PLACE;
+	ops.mode = (mfi->mode == MTD_MODE_RAW) ? MTD_OOB_RAW : MTD_OOB_PLACE;
 
 	if (ops.ooboffs && ops.ooblen > (mtd->oobsize - ops.ooboffs))
 		return -EINVAL;

commit 305b93f180b221789a6213bf3d298c6735102da1
Author: Brian Norris <computersforpeace@gmail.com>
Date:   Tue Aug 23 17:17:32 2011 -0700

    mtd: do not assume oobsize is power of 2
    
    Previous generations of MTDs all used OOB sizes that were powers of 2,
    (e.g., 64, 128). However, newer generations of flash, especially NAND,
    use irregular OOB sizes that are not powers of 2 (e.g., 218, 224, 448).
    This means we cannot use masks like "mtd->oobsize - 1" to assume that we
    will get a proper bitmask for OOB operations.
    
    These masks are really only intended to hide the "page" portion of the
    offset, leaving any OOB offset intact, so a masking with the writesize
    (which *is* always a power of 2) is valid and makes more sense.
    
    This has been tested for read/write of NAND devices (nanddump/nandwrite)
    using nandsim and actual NAND flash.
    
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>
    Signed-off-by: Artem Bityutskiy <artem.bityutskiy@intel.com>

diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
index a75d55577e49..b20625475132 100644
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -410,7 +410,7 @@ static int mtd_do_writeoob(struct file *file, struct mtd_info *mtd,
 		return ret;
 
 	ops.ooblen = length;
-	ops.ooboffs = start & (mtd->oobsize - 1);
+	ops.ooboffs = start & (mtd->writesize - 1);
 	ops.datbuf = NULL;
 	ops.mode = MTD_OOB_PLACE;
 
@@ -421,7 +421,7 @@ static int mtd_do_writeoob(struct file *file, struct mtd_info *mtd,
 	if (IS_ERR(ops.oobbuf))
 		return PTR_ERR(ops.oobbuf);
 
-	start &= ~((uint64_t)mtd->oobsize - 1);
+	start &= ~((uint64_t)mtd->writesize - 1);
 	ret = mtd->write_oob(mtd, start, &ops);
 
 	if (ops.oobretlen > 0xFFFFFFFFU)
@@ -452,7 +452,7 @@ static int mtd_do_readoob(struct mtd_info *mtd, uint64_t start,
 		return ret;
 
 	ops.ooblen = length;
-	ops.ooboffs = start & (mtd->oobsize - 1);
+	ops.ooboffs = start & (mtd->writesize - 1);
 	ops.datbuf = NULL;
 	ops.mode = MTD_OOB_PLACE;
 
@@ -463,7 +463,7 @@ static int mtd_do_readoob(struct mtd_info *mtd, uint64_t start,
 	if (!ops.oobbuf)
 		return -ENOMEM;
 
-	start &= ~((uint64_t)mtd->oobsize - 1);
+	start &= ~((uint64_t)mtd->writesize - 1);
 	ret = mtd->read_oob(mtd, start, &ops);
 
 	if (put_user(ops.oobretlen, retp))

commit 92394b5c2be774425f255b5c7afbd8b19978fe12
Author: Brian Norris <computersforpeace@gmail.com>
Date:   Wed Jul 20 09:53:42 2011 -0700

    mtd: spelling fixes
    
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>
    Signed-off-by: Artem Bityutskiy <artem.bityutskiy@intel.com>

diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
index 22526e98b85b..a75d55577e49 100644
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -43,7 +43,7 @@ static struct vfsmount *mtd_inode_mnt __read_mostly;
 
 /*
  * Data structure to hold the pointer to the mtd device as well
- * as mode information ofr various use cases.
+ * as mode information of various use cases.
  */
 struct mtd_file_info {
 	struct mtd_info *mtd;
@@ -495,7 +495,7 @@ static int mtd_do_readoob(struct mtd_info *mtd, uint64_t start,
 /*
  * Copies (and truncates, if necessary) data from the larger struct,
  * nand_ecclayout, to the smaller, deprecated layout struct,
- * nand_ecclayout_user. This is necessary only to suppport the deprecated
+ * nand_ecclayout_user. This is necessary only to support the deprecated
  * API ioctl ECCGETLAYOUT while allowing all new functionality to use
  * nand_ecclayout flexibly (i.e. the struct may change size in new
  * releases without requiring major rewrites).

commit 289c05222172b51401dbbb017115655f241d94ab
Author: Brian Norris <computersforpeace@gmail.com>
Date:   Tue Jul 19 10:06:09 2011 -0700

    mtd: replace DEBUG() with pr_debug()
    
    Start moving away from the MTD_DEBUG_LEVEL messages. The dynamic
    debugging feature is a generic kernel feature that provides more
    flexibility.
    
    (See Documentation/dynamic-debug-howto.txt)
    
    Also fix some punctuation, indentation, and capitalization that went
    along with the affected lines.
    
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>
    Signed-off-by: Artem Bityutskiy <artem.bityutskiy@intel.com>

diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
index e197192331f9..22526e98b85b 100644
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -86,7 +86,7 @@ static int mtd_open(struct inode *inode, struct file *file)
 	struct mtd_file_info *mfi;
 	struct inode *mtd_ino;
 
-	DEBUG(MTD_DEBUG_LEVEL0, "MTD_open\n");
+	pr_debug("MTD_open\n");
 
 	/* You can't open the RO devices RW */
 	if ((file->f_mode & FMODE_WRITE) && (minor & 1))
@@ -151,7 +151,7 @@ static int mtd_close(struct inode *inode, struct file *file)
 	struct mtd_file_info *mfi = file->private_data;
 	struct mtd_info *mtd = mfi->mtd;
 
-	DEBUG(MTD_DEBUG_LEVEL0, "MTD_close\n");
+	pr_debug("MTD_close\n");
 
 	/* Only sync if opened RW */
 	if ((file->f_mode & FMODE_WRITE) && mtd->sync)
@@ -195,7 +195,7 @@ static ssize_t mtd_read(struct file *file, char __user *buf, size_t count,loff_t
 	size_t size = count;
 	char *kbuf;
 
-	DEBUG(MTD_DEBUG_LEVEL0,"MTD_read\n");
+	pr_debug("MTD_read\n");
 
 	if (*ppos + count > mtd->size)
 		count = mtd->size - *ppos;
@@ -278,7 +278,7 @@ static ssize_t mtd_write(struct file *file, const char __user *buf, size_t count
 	int ret=0;
 	int len;
 
-	DEBUG(MTD_DEBUG_LEVEL0,"MTD_write\n");
+	pr_debug("MTD_write\n");
 
 	if (*ppos == mtd->size)
 		return -ENOSPC;
@@ -570,7 +570,7 @@ static int mtd_ioctl(struct file *file, u_int cmd, u_long arg)
 	u_long size;
 	struct mtd_info_user info;
 
-	DEBUG(MTD_DEBUG_LEVEL0, "MTD_ioctl\n");
+	pr_debug("MTD_ioctl\n");
 
 	size = (cmd & IOCSIZE_MASK) >> IOCSIZE_SHIFT;
 	if (cmd & IOC_IN) {

commit c478d7e449508d924628b012e62dee6dddb6b9e9
Author: Brian Norris <computersforpeace@gmail.com>
Date:   Tue Jun 28 16:29:00 2011 -0700

    mtd: edit NAND-related comment
    
    This comment was unclear regarding which NAND functions do and do not
    support ECC on the spare area. This update should reflect the current
    status of the NAND system but can be updated if changes are made in
    the standard functions.
    
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>
    Signed-off-by: Artem Bityutskiy <dedekind1@gmail.com>

diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
index d5924635ead5..e197192331f9 100644
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -482,8 +482,9 @@ static int mtd_do_readoob(struct mtd_info *mtd, uint64_t start,
 	 * to signal the caller that a bitflip has occured and has
 	 * been corrected by the ECC algorithm.
 	 *
-	 * Note: most NAND ECC algorithms do not calculate ECC
-	 * for the OOB area.
+	 * Note: currently the standard NAND function, nand_read_oob_std,
+	 * does not calculate ECC for the OOB area, so do not rely on
+	 * this behavior unless you have replaced it with your own.
 	 */
 	if (ret == -EUCLEAN || ret == -EBADMSG)
 		return 0;

commit 041e4575f03400e045f00a823fcbbbb337de8409
Author: Brian Norris <computersforpeace@gmail.com>
Date:   Thu Jun 23 16:45:24 2011 -0700

    mtd: nand: handle ECC errors in OOB
    
    While the standard NAND OOB functions do not do ECC on the spare area,
    it is possible for a driver to supply its own OOB ECC functions (e.g., HW
    ECC). nand_do_read_oob should act like nand_do_read_ops in checking the
    ECC stats and returning -EBADMSG or -EUCLEAN on uncorrectable errors or
    correctable bitflips, respectively. These error codes could be used in
    flash-based BBT code or in YAFFS, for example.
    
    Doing this, however, messes with the behavior of mtd_do_readoob. Now,
    mtd_do_readoob should check whether we had -EUCLEAN or -EBADMSG errors
    and discard those as "non-fatal" so that the ioctls can still succeed
    with (possibly uncorrected) data.
    
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>
    Signed-off-by: Artem Bityutskiy <Artem.Bityutskiy@nokia.com>

diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
index c60067b1f07a..d5924635ead5 100644
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -473,6 +473,21 @@ static int mtd_do_readoob(struct mtd_info *mtd, uint64_t start,
 		ret = -EFAULT;
 
 	kfree(ops.oobbuf);
+
+	/*
+	 * NAND returns -EBADMSG on ECC errors, but it returns the OOB
+	 * data. For our userspace tools it is important to dump areas
+	 * with ECC errors!
+	 * For kernel internal usage it also might return -EUCLEAN
+	 * to signal the caller that a bitflip has occured and has
+	 * been corrected by the ECC algorithm.
+	 *
+	 * Note: most NAND ECC algorithms do not calculate ECC
+	 * for the OOB area.
+	 */
+	if (ret == -EUCLEAN || ret == -EBADMSG)
+		return 0;
+
 	return ret;
 }
 

commit 7854d3f7495b11be1570cd3e2318674d8f9ed797
Author: Brian Norris <computersforpeace@gmail.com>
Date:   Thu Jun 23 14:12:08 2011 -0700

    mtd: spelling, capitalization, uniformity
    
    Therefor -> Therefore
    [Intern], [Internal] -> [INTERN]
    [REPLACABLE] -> [REPLACEABLE]
    syndrom, syndom -> syndrome
    ecc -> ECC
    buswith -> buswidth
    endianess -> endianness
    dont -> don't
    occures -> occurs
    independend -> independent
    wihin -> within
    erease -> erase
    blockes -> blocks
    ...
    
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>
    Signed-off-by: Artem Bityutskiy <Artem.Bityutskiy@nokia.com>

diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
index 49e20a497084..c60067b1f07a 100644
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -233,9 +233,9 @@ static ssize_t mtd_read(struct file *file, char __user *buf, size_t count,loff_t
 		default:
 			ret = mtd->read(mtd, *ppos, len, &retlen, kbuf);
 		}
-		/* Nand returns -EBADMSG on ecc errors, but it returns
+		/* Nand returns -EBADMSG on ECC errors, but it returns
 		 * the data. For our userspace tools it is important
-		 * to dump areas with ecc errors !
+		 * to dump areas with ECC errors!
 		 * For kernel internal usage it also might return -EUCLEAN
 		 * to signal the caller that a bitflip has occurred and has
 		 * been corrected by the ECC algorithm.
@@ -883,7 +883,7 @@ static int mtd_ioctl(struct file *file, u_int cmd, u_long arg)
 	}
 #endif
 
-	/* This ioctl is being deprecated - it truncates the ecc layout */
+	/* This ioctl is being deprecated - it truncates the ECC layout */
 	case ECCGETLAYOUT:
 	{
 		struct nand_ecclayout_user *usrlay;

commit bf5140817b2d65faac9b32fc9057a097044ac35b
Author: Peter Wippich <pewi@gw-instruments.de>
Date:   Mon Jun 6 15:50:58 2011 +0200

    mtd: mtdchar: add missing initializer on raw write
    
    On writes in MODE_RAW the mtd_oob_ops struct is not sufficiently
    initialized which may cause nandwrite to fail. With this patch
    it is possible to write raw nand/oob data without additional ECC
    (either for testing or when some sectors need different oob layout
    e.g. bootloader) like
    nandwrite  -n -r -o  /dev/mtd0 <myfile>
    
    Signed-off-by: Peter Wippich <pewi@gw-instruments.de>
    Cc: stable@kernel.org
    Tested-by: Ricard Wanderlof <ricardw@axis.com>
    Signed-off-by: Artem Bityutskiy <Artem.Bityutskiy@nokia.com>

diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
index f1af2228a1b1..49e20a497084 100644
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -320,6 +320,7 @@ static ssize_t mtd_write(struct file *file, const char __user *buf, size_t count
 			ops.mode = MTD_OOB_RAW;
 			ops.datbuf = kbuf;
 			ops.oobbuf = NULL;
+			ops.ooboffs = 0;
 			ops.len = len;
 
 			ret = mtd->write_oob(mtd, *ppos, &ops);

commit 423e0ab086ad8b33626e45fa94ac7613146b7ffa
Author: Tim Chen <tim.c.chen@linux.intel.com>
Date:   Tue Jul 19 09:32:38 2011 -0700

    VFS : mount lock scalability for internal mounts
    
    For a number of file systems that don't have a mount point (e.g. sockfs
    and pipefs), they are not marked as long term. Therefore in
    mntput_no_expire, all locks in vfs_mount lock are taken instead of just
    local cpu's lock to aggregate reference counts when we release
    reference to file objects.  In fact, only local lock need to have been
    taken to update ref counts as these file systems are in no danger of
    going away until we are ready to unregister them.
    
    The attached patch marks file systems using kern_mount without
    mount point as long term.  The contentions of vfs_mount lock
    is now eliminated.  Before un-registering such file system,
    kern_unmount should be called to remove the long term flag and
    make the mount point ready to be freed.
    
    Signed-off-by: Tim Chen <tim.c.chen@linux.intel.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
index 3f92731a5b9e..f1af2228a1b1 100644
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -1192,7 +1192,7 @@ static int __init init_mtdchar(void)
 static void __exit cleanup_mtdchar(void)
 {
 	unregister_mtd_user(&mtdchar_notifier);
-	mntput(mtd_inode_mnt);
+	kern_unmount(mtd_inode_mnt);
 	unregister_filesystem(&mtd_inodefs_type);
 	__unregister_chrdev(MTD_CHAR_MAJOR, 0, 1 << MINORBITS, "mtd");
 }

commit 6a8a98b22b10f1560d5f90aded4a54234b9b2724
Author: Jamie Iles <jamie@jamieiles.com>
Date:   Mon May 23 10:23:43 2011 +0100

    mtd: kill CONFIG_MTD_PARTITIONS
    
    Now that none of the drivers use CONFIG_MTD_PARTITIONS we can remove
    it from Kconfig and the last remaining uses.
    
    Signed-off-by: Jamie Iles <jamie@jamieiles.com>
    Signed-off-by: Artem Bityutskiy <Artem.Bityutskiy@nokia.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
index f488eabaa7b5..3f92731a5b9e 100644
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -508,7 +508,6 @@ static int shrink_ecclayout(const struct nand_ecclayout *from,
 	return 0;
 }
 
-#ifdef CONFIG_MTD_PARTITIONS
 static int mtd_blkpg_ioctl(struct mtd_info *mtd,
 			   struct blkpg_ioctl_arg __user *arg)
 {
@@ -544,8 +543,6 @@ static int mtd_blkpg_ioctl(struct mtd_info *mtd,
 		return -EINVAL;
 	}
 }
-#endif
-
 
 static int mtd_ioctl(struct file *file, u_int cmd, u_long arg)
 {
@@ -937,7 +934,6 @@ static int mtd_ioctl(struct file *file, u_int cmd, u_long arg)
 		break;
 	}
 
-#ifdef CONFIG_MTD_PARTITIONS
 	case BLKPG:
 	{
 		ret = mtd_blkpg_ioctl(mtd,
@@ -951,7 +947,6 @@ static int mtd_ioctl(struct file *file, u_int cmd, u_long arg)
 		ret = 0;
 		break;
 	}
-#endif
 
 	default:
 		ret = -ENOTTY;

commit 3e45cf5e85a4f344fc4c8c901ac057a2402db125
Author: Grant Erickson <marathon96@gmail.com>
Date:   Fri Apr 8 08:51:33 2011 -0700

    mtd: mtdchar: retry large buffer allocations
    
    Replace direct call to kmalloc for a potentially large, contiguous
    buffer allocation with one to mtd_kmalloc_up_to which helps ensure the
    operation can succeed under low-memory, highly- fragmented situations
    albeit somewhat more slowly.
    
    Signed-off-by: Grant Erickson <marathon96@gmail.com>
    Tested-by: Ben Gardiner <bengardiner@nanometrics.ca>
    Tested-by: Stefano Babic <sbabic@denx.de>
    Signed-off-by: Artem Bityutskiy <Artem.Bityutskiy@nokia.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
index 4c36ef66a46b..f488eabaa7b5 100644
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -166,10 +166,23 @@ static int mtd_close(struct inode *inode, struct file *file)
 	return 0;
 } /* mtd_close */
 
-/* FIXME: This _really_ needs to die. In 2.5, we should lock the
-   userspace buffer down and use it directly with readv/writev.
-*/
-#define MAX_KMALLOC_SIZE 0x20000
+/* Back in June 2001, dwmw2 wrote:
+ *
+ *   FIXME: This _really_ needs to die. In 2.5, we should lock the
+ *   userspace buffer down and use it directly with readv/writev.
+ *
+ * The implementation below, using mtd_kmalloc_up_to, mitigates
+ * allocation failures when the system is under low-memory situations
+ * or if memory is highly fragmented at the cost of reducing the
+ * performance of the requested transfer due to a smaller buffer size.
+ *
+ * A more complex but more memory-efficient implementation based on
+ * get_user_pages and iovecs to cover extents of those pages is a
+ * longer-term goal, as intimated by dwmw2 above. However, for the
+ * write case, this requires yet more complex head and tail transfer
+ * handling when those head and tail offsets and sizes are such that
+ * alignment requirements are not met in the NAND subdriver.
+ */
 
 static ssize_t mtd_read(struct file *file, char __user *buf, size_t count,loff_t *ppos)
 {
@@ -179,6 +192,7 @@ static ssize_t mtd_read(struct file *file, char __user *buf, size_t count,loff_t
 	size_t total_retlen=0;
 	int ret=0;
 	int len;
+	size_t size = count;
 	char *kbuf;
 
 	DEBUG(MTD_DEBUG_LEVEL0,"MTD_read\n");
@@ -189,23 +203,12 @@ static ssize_t mtd_read(struct file *file, char __user *buf, size_t count,loff_t
 	if (!count)
 		return 0;
 
-	/* FIXME: Use kiovec in 2.5 to lock down the user's buffers
-	   and pass them directly to the MTD functions */
-
-	if (count > MAX_KMALLOC_SIZE)
-		kbuf=kmalloc(MAX_KMALLOC_SIZE, GFP_KERNEL);
-	else
-		kbuf=kmalloc(count, GFP_KERNEL);
-
+	kbuf = mtd_kmalloc_up_to(mtd, &size);
 	if (!kbuf)
 		return -ENOMEM;
 
 	while (count) {
-
-		if (count > MAX_KMALLOC_SIZE)
-			len = MAX_KMALLOC_SIZE;
-		else
-			len = count;
+		len = min_t(size_t, count, size);
 
 		switch (mfi->mode) {
 		case MTD_MODE_OTP_FACTORY:
@@ -268,6 +271,7 @@ static ssize_t mtd_write(struct file *file, const char __user *buf, size_t count
 {
 	struct mtd_file_info *mfi = file->private_data;
 	struct mtd_info *mtd = mfi->mtd;
+	size_t size = count;
 	char *kbuf;
 	size_t retlen;
 	size_t total_retlen=0;
@@ -285,20 +289,12 @@ static ssize_t mtd_write(struct file *file, const char __user *buf, size_t count
 	if (!count)
 		return 0;
 
-	if (count > MAX_KMALLOC_SIZE)
-		kbuf=kmalloc(MAX_KMALLOC_SIZE, GFP_KERNEL);
-	else
-		kbuf=kmalloc(count, GFP_KERNEL);
-
+	kbuf = mtd_kmalloc_up_to(mtd, &size);
 	if (!kbuf)
 		return -ENOMEM;
 
 	while (count) {
-
-		if (count > MAX_KMALLOC_SIZE)
-			len = MAX_KMALLOC_SIZE;
-		else
-			len = count;
+		len = min_t(size_t, count, size);
 
 		if (copy_from_user(kbuf, buf, len)) {
 			kfree(kbuf);

commit 25985edcedea6396277003854657b5f3cb31a628
Author: Lucas De Marchi <lucas.demarchi@profusion.mobi>
Date:   Wed Mar 30 22:57:33 2011 -0300

    Fix common misspellings
    
    Fixes generated by 'codespell' and manually reviewed.
    
    Signed-off-by: Lucas De Marchi <lucas.demarchi@profusion.mobi>

diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
index 145b3d0dc0db..4c36ef66a46b 100644
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -234,7 +234,7 @@ static ssize_t mtd_read(struct file *file, char __user *buf, size_t count,loff_t
 		 * the data. For our userspace tools it is important
 		 * to dump areas with ecc errors !
 		 * For kernel internal usage it also might return -EUCLEAN
-		 * to signal the caller that a bitflip has occured and has
+		 * to signal the caller that a bitflip has occurred and has
 		 * been corrected by the ECC algorithm.
 		 * Userspace software which accesses NAND this way
 		 * must be aware of the fact that it deals with NAND

commit ab2020f2f11fc7fb81e6c71298b0830d85412011
Merge: 235646a486d1 154bf89f5e3e
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Jan 17 11:15:30 2011 -0800

    Merge git://git.infradead.org/mtd-2.6
    
    * git://git.infradead.org/mtd-2.6: (59 commits)
      mtd: mtdpart: disallow reading OOB past the end of the partition
      mtd: pxa3xx_nand: NULL dereference in pxa3xx_nand_probe
      UBI: use mtd->writebufsize to set minimal I/O unit size
      mtd: initialize writebufsize in the MTD object of a partition
      mtd: onenand: add mtd->writebufsize initialization
      mtd: nand: add mtd->writebufsize initialization
      mtd: cfi: add writebufsize initialization
      mtd: add writebufsize field to mtd_info struct
      mtd: OneNAND: OMAP2/3: prevent regulator sleeping while OneNAND is in use
      mtd: OneNAND: add enable / disable methods to onenand_chip
      mtd: m25p80: Fix JEDEC ID for AT26DF321
      mtd: txx9ndfmc: limit transfer bytes to 512 (ECC provides 6 bytes max)
      mtd: cfi_cmdset_0002: add support for Samsung K8D3x16UxC NOR chips
      mtd: cfi_cmdset_0002: add support for Samsung K8D6x16UxM NOR chips
      mtd: nand: ams-delta: drop omap_read/write, use ioremap
      mtd: m25p80: add debugging trace in sst_write
      mtd: nand: ams-delta: select for built-in by default
      mtd: OneNAND: lighten scary initial bad block messages
      mtd: OneNAND: OMAP2/3: add support for command line partitioning
      mtd: nand: rearrange ONFI revision checking, add ONFI 2.3
      ...
    
    Fix up trivial conflict in drivers/mtd/Kconfig as per DavidW.

commit f03c65993b98eeb909a4012ce7833c5857d74755
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Jan 14 22:30:21 2011 -0500

    sanitize vfsmount refcounting changes
    
    Instead of splitting refcount between (per-cpu) mnt_count
    and (SMP-only) mnt_longrefs, make all references contribute
    to mnt_count again and keep track of how many are longterm
    ones.
    
    Accounting rules for longterm count:
            * 1 for each fs_struct.root.mnt
            * 1 for each fs_struct.pwd.mnt
            * 1 for having non-NULL ->mnt_ns
            * decrement to 0 happens only under vfsmount lock exclusive
    
    That allows nice common case for mntput() - since we can't drop the
    final reference until after mnt_longterm has reached 0 due to the rules
    above, mntput() can grab vfsmount lock shared and check mnt_longterm.
    If it turns out to be non-zero (which is the common case), we know
    that this is not the final mntput() and can just blindly decrement
    percpu mnt_count.  Otherwise we grab vfsmount lock exclusive and
    do usual decrement-and-check of percpu mnt_count.
    
    For fs_struct.c we have mnt_make_longterm() and mnt_make_shortterm();
    namespace.c uses the latter in places where we don't already hold
    vfsmount lock exclusive and opencodes a few remaining spots where
    we need to manipulate mnt_longterm.
    
    Note that we mostly revert the code outside of fs/namespace.c back
    to what we used to have; in particular, normal code doesn't need
    to care about two kinds of references, etc.  And we get to keep
    the optimization Nick's variant had bought us...
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
index ee4bb3330bdf..98240575a18d 100644
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -1201,7 +1201,7 @@ static int __init init_mtdchar(void)
 static void __exit cleanup_mtdchar(void)
 {
 	unregister_mtd_user(&mtdchar_notifier);
-	mntput_long(mtd_inode_mnt);
+	mntput(mtd_inode_mnt);
 	unregister_filesystem(&mtd_inodefs_type);
 	__unregister_chrdev(MTD_CHAR_MAJOR, 0, 1 << MINORBITS, "mtd");
 }

commit c74a1cbb3cac348f276fabc381758f5b0b4713b2
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Wed Jan 12 16:59:34 2011 -0500

    pass default dentry_operations to mount_pseudo()
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
index f511dd15fd31..ee4bb3330bdf 100644
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -1134,7 +1134,7 @@ static const struct file_operations mtd_fops = {
 static struct dentry *mtd_inodefs_mount(struct file_system_type *fs_type,
 				int flags, const char *dev_name, void *data)
 {
-	return mount_pseudo(fs_type, "mtd_inode:", NULL, MTD_INODE_FS_MAGIC);
+	return mount_pseudo(fs_type, "mtd_inode:", NULL, NULL, MTD_INODE_FS_MAGIC);
 }
 
 static struct file_system_type mtd_inodefs_type = {

commit b3e19d924b6eaf2ca7d22cba99a517c5171007b6
Author: Nick Piggin <npiggin@kernel.dk>
Date:   Fri Jan 7 17:50:11 2011 +1100

    fs: scale mntget/mntput
    
    The problem that this patch aims to fix is vfsmount refcounting scalability.
    We need to take a reference on the vfsmount for every successful path lookup,
    which often go to the same mount point.
    
    The fundamental difficulty is that a "simple" reference count can never be made
    scalable, because any time a reference is dropped, we must check whether that
    was the last reference. To do that requires communication with all other CPUs
    that may have taken a reference count.
    
    We can make refcounts more scalable in a couple of ways, involving keeping
    distributed counters, and checking for the global-zero condition less
    frequently.
    
    - check the global sum once every interval (this will delay zero detection
      for some interval, so it's probably a showstopper for vfsmounts).
    
    - keep a local count and only taking the global sum when local reaches 0 (this
      is difficult for vfsmounts, because we can't hold preempt off for the life of
      a reference, so a counter would need to be per-thread or tied strongly to a
      particular CPU which requires more locking).
    
    - keep a local difference of increments and decrements, which allows us to sum
      the total difference and hence find the refcount when summing all CPUs. Then,
      keep a single integer "long" refcount for slow and long lasting references,
      and only take the global sum of local counters when the long refcount is 0.
    
    This last scheme is what I implemented here. Attached mounts and process root
    and working directory references are "long" references, and everything else is
    a short reference.
    
    This allows scalable vfsmount references during path walking over mounted
    subtrees and unattached (lazy umounted) mounts with processes still running
    in them.
    
    This results in one fewer atomic op in the fastpath: mntget is now just a
    per-CPU inc, rather than an atomic inc; and mntput just requires a spinlock
    and non-atomic decrement in the common case. However code is otherwise bigger
    and heavier, so single threaded performance is basically a wash.
    
    Signed-off-by: Nick Piggin <npiggin@kernel.dk>

diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
index 4759d827e8c7..f511dd15fd31 100644
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -1201,7 +1201,7 @@ static int __init init_mtdchar(void)
 static void __exit cleanup_mtdchar(void)
 {
 	unregister_mtd_user(&mtdchar_notifier);
-	mntput(mtd_inode_mnt);
+	mntput_long(mtd_inode_mnt);
 	unregister_filesystem(&mtd_inodefs_type);
 	__unregister_chrdev(MTD_CHAR_MAJOR, 0, 1 << MINORBITS, "mtd");
 }

commit a7e93dcd9aacb3ef4acfcc4310577f3ae0741821
Author: Roman Tereshonkov <roman.tereshonkov@nokia.com>
Date:   Tue Nov 23 14:17:17 2010 +0200

    mtd: fix master device identification for mtd repartition
    
    Function mtd_has_master renamed as mtd_is_partition to follow the function logic.
    The patch fixes the problem of checking the right mtd device for partition creation.
    To delete partition checking is not needed here so as it is done in mtd_del_partition.
    By master we consider the mtd device which does not belong to any partition.
    
    Signed-off-by: Roman Tereshonkov <roman.tereshonkov@nokia.com>
    Signed-off-by: Artem Bityutskiy <Artem.Bityutskiy@nokia.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
index cad8fcc7b239..16de17b5b829 100644
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -522,10 +522,6 @@ static int mtd_blkpg_ioctl(struct mtd_info *mtd,
 	if (!capable(CAP_SYS_ADMIN))
 		return -EPERM;
 
-	/* Only master mtd device must be used to control partitions */
-	if (!mtd_is_master(mtd))
-		return -EINVAL;
-
 	if (copy_from_user(&a, arg, sizeof(struct blkpg_ioctl_arg)))
 		return -EFAULT;
 
@@ -535,6 +531,10 @@ static int mtd_blkpg_ioctl(struct mtd_info *mtd,
 	switch (a.op) {
 	case BLKPG_ADD_PARTITION:
 
+		/* Only master mtd device must be used to add partitions */
+		if (mtd_is_partition(mtd))
+			return -EINVAL;
+
 		return mtd_add_partition(mtd, p.devname, p.start, p.length);
 
 	case BLKPG_DEL_PARTITION:

commit a0c5a3944ce121bb2417c771f77b18485cd84e18
Author: Vasiliy Kulikov <segooon@gmail.com>
Date:   Sat Nov 6 17:41:24 2010 +0300

    mtd: mtdchar: fix information leak to userland
    
    Structure mtd_info_user is copied to userland with padding byted
    between "type" and "flags" fields uninitialized.  It leads to leaking
    of contents of kernel stack memory.
    
    Signed-off-by: Vasiliy Kulikov <segooon@gmail.com>
    Signed-off-by: Artem Bityutskiy <Artem.Bityutskiy@nokia.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
index 4759d827e8c7..cad8fcc7b239 100644
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -601,6 +601,7 @@ static int mtd_ioctl(struct file *file, u_int cmd, u_long arg)
 	}
 
 	case MEMGETINFO:
+		memset(&info, 0, sizeof(info));
 		info.type	= mtd->type;
 		info.flags	= mtd->flags;
 		info.size	= mtd->size;
@@ -609,7 +610,6 @@ static int mtd_ioctl(struct file *file, u_int cmd, u_long arg)
 		info.oobsize	= mtd->oobsize;
 		/* The below fields are obsolete */
 		info.ecctype	= -1;
-		info.eccsize	= 0;
 		if (copy_to_user(argp, &info, sizeof(struct mtd_info_user)))
 			return -EFAULT;
 		break;

commit 79346507ad48895f41b438fa562b1965721f36b9
Merge: 706d4b12f8d7 40847437f152
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Oct 30 08:31:35 2010 -0700

    Merge git://git.infradead.org/mtd-2.6
    
    * git://git.infradead.org/mtd-2.6: (82 commits)
      mtd: fix build error in m25p80.c
      mtd: Remove redundant mutex from mtd_blkdevs.c
      MTD: Fix wrong check register_blkdev return value
      Revert "mtd: cleanup Kconfig dependencies"
      mtd: cfi_cmdset_0002: make sector erase command variable
      mtd: cfi_cmdset_0002: add CFI detection for SST 38VF640x chips
      mtd: cfi_util: add support for switching SST 39VF640xB chips into QRY mode
      mtd: cfi_cmdset_0001: use defined value of P_ID_INTEL_PERFORMANCE instead of hardcoded one
      block2mtd: dubious assignment
      P4080/mtd: Fix the freescale lbc issue with 36bit mode
      P4080/eLBC: Make Freescale elbc interrupt common to elbc devices
      mtd: phram: use KBUILD_MODNAME
      mtd: OneNAND: S5PC110: Fix double call suspend & resume function
      mtd: nand: fix MTD_MODE_RAW writes
      jffs2: use kmemdup
      mtd: sm_ftl: cosmetic, use bool when possible
      mtd: r852: remove useless pci powerup/down from suspend/resume routines
      mtd: blktrans: fix a race vs kthread_stop
      mtd: blktrans: kill BKL
      mtd: allow to unload the mtdtrans module if its block devices aren't open
      ...
    
    Fix up trivial whitespace-introduced conflict in drivers/mtd/mtdchar.c

commit 67577927e8d7a1f4b09b4992df640eadc6aacb36
Merge: 6fe4c5903131 51f00a471ce8
Author: David Woodhouse <David.Woodhouse@intel.com>
Date:   Sat Oct 30 12:35:11 2010 +0100

    Merge branch 'master' of git://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux-2.6.git
    
    Conflicts:
            drivers/mtd/mtd_blkdevs.c
    
    Merge Grant's device-tree bits so that we can apply the subsequent fixes.
    
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

commit 51139adac92f7160ad3ca1cab2de1b4b8d19dc96
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sun Jul 25 23:47:46 2010 +0400

    convert get_sb_pseudo() users
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
index 5ef45487b65f..a34a0fe14884 100644
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -1030,17 +1030,15 @@ static const struct file_operations mtd_fops = {
 #endif
 };
 
-static int mtd_inodefs_get_sb(struct file_system_type *fs_type, int flags,
-                               const char *dev_name, void *data,
-                               struct vfsmount *mnt)
+static struct dentry *mtd_inodefs_mount(struct file_system_type *fs_type,
+				int flags, const char *dev_name, void *data)
 {
-        return get_sb_pseudo(fs_type, "mtd_inode:", NULL, MTD_INODE_FS_MAGIC,
-                             mnt);
+        return mount_pseudo(fs_type, "mtd_inode:", NULL, MTD_INODE_FS_MAGIC);
 }
 
 static struct file_system_type mtd_inodefs_type = {
        .name = "mtd_inodefs",
-       .get_sb = mtd_inodefs_get_sb,
+       .mount = mtd_inodefs_mount,
        .kill_sb = kill_anon_super,
 };
 

commit d0f7959e2b708d775c3b6b53cc6a8abb8ff0a00b
Author: Roman Tereshonkov <roman.tereshonkov@nokia.com>
Date:   Fri Sep 17 13:31:42 2010 +0300

    mtd: add BLKPG API based repartition support
    
    Add support for mtd repartition based on the block
    device BLKPG interface:
    BLKPG_ADD_PARTITION - for partition creation;
    BLKPG_DEL_PARTITION - for partition delete
    
    The usage is based on BLKPG ioctl called with
    struct blkpg_ioctl_arg argument which includes the
    reference to struct blkpg_partition discribing the
    partition offset and length.
    
    Disadvantage: there is no implementation for mtd
    flags control. The flags are always borrowed from
    the master device.
    
    Signed-off-by: Roman Tereshonkov <roman.tereshonkov@nokia.com>
    Signed-off-by: Artem Bityutskiy <Artem.Bityutskiy@nokia.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
index 5895de7018d4..b7ed09c57903 100644
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -30,8 +30,9 @@
 #include <linux/backing-dev.h>
 #include <linux/compat.h>
 #include <linux/mount.h>
-
+#include <linux/blkpg.h>
 #include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
 #include <linux/mtd/map.h>
 
 #include <asm/uaccess.h>
@@ -510,6 +511,45 @@ static int shrink_ecclayout(const struct nand_ecclayout *from,
 	return 0;
 }
 
+#ifdef CONFIG_MTD_PARTITIONS
+static int mtd_blkpg_ioctl(struct mtd_info *mtd,
+			   struct blkpg_ioctl_arg __user *arg)
+{
+	struct blkpg_ioctl_arg a;
+	struct blkpg_partition p;
+
+	if (!capable(CAP_SYS_ADMIN))
+		return -EPERM;
+
+	/* Only master mtd device must be used to control partitions */
+	if (!mtd_is_master(mtd))
+		return -EINVAL;
+
+	if (copy_from_user(&a, arg, sizeof(struct blkpg_ioctl_arg)))
+		return -EFAULT;
+
+	if (copy_from_user(&p, a.data, sizeof(struct blkpg_partition)))
+		return -EFAULT;
+
+	switch (a.op) {
+	case BLKPG_ADD_PARTITION:
+
+		return mtd_add_partition(mtd, p.devname, p.start, p.length);
+
+	case BLKPG_DEL_PARTITION:
+
+		if (p.pno < 0)
+			return -EINVAL;
+
+		return mtd_del_partition(mtd, p.pno);
+
+	default:
+		return -EINVAL;
+	}
+}
+#endif
+
+
 static int mtd_ioctl(struct file *file, u_int cmd, u_long arg)
 {
 	struct mtd_file_info *mfi = file->private_data;
@@ -900,6 +940,22 @@ static int mtd_ioctl(struct file *file, u_int cmd, u_long arg)
 		break;
 	}
 
+#ifdef CONFIG_MTD_PARTITIONS
+	case BLKPG:
+	{
+		ret = mtd_blkpg_ioctl(mtd,
+		      (struct blkpg_ioctl_arg __user *)arg);
+		break;
+	}
+
+	case BLKRRPART:
+	{
+		/* No reread partition feature. Just return ok */
+		ret = 0;
+		break;
+	}
+#endif
+
 	default:
 		ret = -ENOTTY;
 	}
@@ -1078,7 +1134,7 @@ static int mtd_inodefs_get_sb(struct file_system_type *fs_type, int flags,
                                const char *dev_name, void *data,
                                struct vfsmount *mnt)
 {
-        return get_sb_pseudo(fs_type, "mtd_inode:", NULL, MTD_INODE_FS_MAGIC,
+	return get_sb_pseudo(fs_type, "mtd_inode:", NULL, MTD_INODE_FS_MAGIC,
                              mnt);
 }
 

commit 5e59be1f351b0ca9c5a43c627e3ed676ae93a941
Author: Dan Carpenter <error27@gmail.com>
Date:   Wed Sep 8 21:39:56 2010 +0200

    mtd: sanity check ioctl input
    
    If "ur_idx" is wrong we could go past the end of the array.  The
    "ur_idx" comes from root so it's not a huge deal, but adding a sanity
    check makes the code more robust.
    
    Signed-off-by: Dan Carpenter <error27@gmail.com>
    Signed-off-by: Artem Bityutskiy <Artem.Bityutskiy@nokia.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
index 1d981a5c1b13..5895de7018d4 100644
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -546,6 +546,9 @@ static int mtd_ioctl(struct file *file, u_int cmd, u_long arg)
 		if (get_user(ur_idx, &(ur->regionindex)))
 			return -EFAULT;
 
+		if (ur_idx >= mtd->numeraseregions)
+			return -EINVAL;
+
 		kr = &(mtd->eraseregions[ur_idx]);
 
 		if (put_user(kr->offset, &(ur->offset))

commit 0ceacf36e9c41859a6072342d27cf6e60776c523
Author: Brian Norris <computersforpeace@gmail.com>
Date:   Sun Sep 19 23:57:12 2010 -0700

    mtd: edit comments on deprecation of ioctl ECCGETLAYOUT
    
    There were some improvements and additions necessary in the
    comments explaining of the expansion of nand_ecclayout, the
    introduction of nand_ecclayout_user, and the deprecation of the
    ioctl ECCGETLAYOUT.
    
    Also, I found a better placement for the macro MTD_MAX_ECCPOS_ENTRIES;
    next to the definition of MTD_MAX_OOBFREE_ENTRIES in mtd-abi.h. The macro
    is really only important for the ioctl code (found in drivers/mtd/mtdchar.c)
    but since there are small edits being made to the user-space header, I
    figured this is a better location.
    
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>
    Signed-off-by: Artem Bityutskiy <Artem.Bityutskiy@nokia.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
index 24d35ba62b84..1d981a5c1b13 100644
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -495,7 +495,7 @@ static int shrink_ecclayout(const struct nand_ecclayout *from,
 
 	memset(to, 0, sizeof(*to));
 
-	to->eccbytes = min((int)from->eccbytes, MTD_MAX_ECCPOS_ENTRIES_OLD);
+	to->eccbytes = min((int)from->eccbytes, MTD_MAX_ECCPOS_ENTRIES);
 	for (i = 0; i < to->eccbytes; i++)
 		to->eccpos[i] = from->eccpos[i];
 

commit cc26c3cd3d1cf40a07f2b19ac4c53d517bee52a5
Author: Brian Norris <computersforpeace@gmail.com>
Date:   Tue Aug 24 18:12:00 2010 -0700

    mtd: nand: expand nand_ecc_layout, deprecate ioctl ECCGETLAYOUT
    
    struct nand_ecclayout is too small for many new chips; OOB regions can be as
    large as 448 bytes and may increase more in the future. Thus, copying that
    struct to user-space with the ECCGETLAYOUT ioctl is not a good idea; the ioctl
    would have to be updated every time there's a change to the current largest
    size.
    
    Instead, the old nand_ecclayout is renamed to nand_ecclayout_user and a
    new struct nand_ecclayout is created that can accomodate larger sizes and
    expand without affecting the user-space. struct nand_ecclayout can still
    be used in board drivers without modification -- at least for now.
    
    A new function is provided to convert from the new to the old in order to
    allow the deprecated ioctl to continue to work with truncated data. Perhaps
    the ioctl, the conversion process, and the struct nand_ecclayout_user can be
    removed altogether in the future.
    
    Note: There are comments in nand/davinci_nand.c::nand_davinci_probe()
    regarding this issue; this driver (and maybe others) can be updated to
    account for extra space. All kernel drivers can use the expanded
    nand_ecclayout as a drop-in replacement and ignore its benefits.
    
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>
    Signed-off-by: Artem Bityutskiy <Artem.Bityutskiy@nokia.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
index a825002123c8..24d35ba62b84 100644
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -477,6 +477,39 @@ static int mtd_do_readoob(struct mtd_info *mtd, uint64_t start,
 	return ret;
 }
 
+/*
+ * Copies (and truncates, if necessary) data from the larger struct,
+ * nand_ecclayout, to the smaller, deprecated layout struct,
+ * nand_ecclayout_user. This is necessary only to suppport the deprecated
+ * API ioctl ECCGETLAYOUT while allowing all new functionality to use
+ * nand_ecclayout flexibly (i.e. the struct may change size in new
+ * releases without requiring major rewrites).
+ */
+static int shrink_ecclayout(const struct nand_ecclayout *from,
+		struct nand_ecclayout_user *to)
+{
+	int i;
+
+	if (!from || !to)
+		return -EINVAL;
+
+	memset(to, 0, sizeof(*to));
+
+	to->eccbytes = min((int)from->eccbytes, MTD_MAX_ECCPOS_ENTRIES_OLD);
+	for (i = 0; i < to->eccbytes; i++)
+		to->eccpos[i] = from->eccpos[i];
+
+	for (i = 0; i < MTD_MAX_OOBFREE_ENTRIES; i++) {
+		if (from->oobfree[i].length == 0 &&
+				from->oobfree[i].offset == 0)
+			break;
+		to->oobavail += from->oobfree[i].length;
+		to->oobfree[i] = from->oobfree[i];
+	}
+
+	return 0;
+}
+
 static int mtd_ioctl(struct file *file, u_int cmd, u_long arg)
 {
 	struct mtd_file_info *mfi = file->private_data;
@@ -812,14 +845,23 @@ static int mtd_ioctl(struct file *file, u_int cmd, u_long arg)
 	}
 #endif
 
+	/* This ioctl is being deprecated - it truncates the ecc layout */
 	case ECCGETLAYOUT:
 	{
+		struct nand_ecclayout_user *usrlay;
+
 		if (!mtd->ecclayout)
 			return -EOPNOTSUPP;
 
-		if (copy_to_user(argp, mtd->ecclayout,
-				 sizeof(struct nand_ecclayout)))
-			return -EFAULT;
+		usrlay = kmalloc(sizeof(*usrlay), GFP_KERNEL);
+		if (!usrlay)
+			return -ENOMEM;
+
+		shrink_ecclayout(mtd->ecclayout, usrlay);
+
+		if (copy_to_user(argp, usrlay, sizeof(*usrlay)))
+			ret = -EFAULT;
+		kfree(usrlay);
 		break;
 	}
 

commit 5aa82940b23d0c6e4083d48e387a16b8ad530a47
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Wed Jun 2 14:28:52 2010 +0200

    mtd: autoconvert trivial BKL users to private mutex
    
    All these files use the big kernel lock in a trivial
    way to serialize their private file operations,
    typically resulting from an earlier semi-automatic
    pushdown from VFS.
    
    None of these drivers appears to want to lock against
    other code, and they all use the BKL as the top-level
    lock in their file operations, meaning that there
    is no lock-order inversion problem.
    
    Consequently, we can remove the BKL completely,
    replacing it with a per-file mutex in every case.
    Using a scripted approach means we can avoid
    typos.
    
    file=$1
    name=$2
    if grep -q lock_kernel ${file} ; then
        if grep -q 'include.*linux.mutex.h' ${file} ; then
                sed -i '/include.*<linux\/smp_lock.h>/d' ${file}
        else
                sed -i 's/include.*<linux\/smp_lock.h>.*$/include <linux\/mutex.h>/g' ${file}
        fi
        sed -i ${file} \
            -e "/^#include.*linux.mutex.h/,$ {
                    1,/^\(static\|int\|long\)/ {
                         /^\(static\|int\|long\)/istatic DEFINE_MUTEX(${name}_mutex);
    
    } }"  \
        -e "s/\(un\)*lock_kernel\>[ ]*()/mutex_\1lock(\&${name}_mutex)/g" \
        -e '/[      ]*cycle_kernel_lock();/d'
    else
        sed -i -e '/include.*\<smp_lock.h\>/d' ${file}  \
                    -e '/cycle_kernel_lock()/d'
    fi
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Cc: David Woodhouse <David.Woodhouse@intel.com>
    Cc: linux-mtd@lists.infradead.org

diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
index a825002123c8..5ef45487b65f 100644
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -26,7 +26,7 @@
 #include <linux/module.h>
 #include <linux/slab.h>
 #include <linux/sched.h>
-#include <linux/smp_lock.h>
+#include <linux/mutex.h>
 #include <linux/backing-dev.h>
 #include <linux/compat.h>
 #include <linux/mount.h>
@@ -37,6 +37,7 @@
 #include <asm/uaccess.h>
 
 #define MTD_INODE_FS_MAGIC 0x11307854
+static DEFINE_MUTEX(mtd_mutex);
 static struct vfsmount *mtd_inode_mnt __read_mostly;
 
 /*
@@ -90,7 +91,7 @@ static int mtd_open(struct inode *inode, struct file *file)
 	if ((file->f_mode & FMODE_WRITE) && (minor & 1))
 		return -EACCES;
 
-	lock_kernel();
+	mutex_lock(&mtd_mutex);
 	mtd = get_mtd_device(NULL, devnum);
 
 	if (IS_ERR(mtd)) {
@@ -138,7 +139,7 @@ static int mtd_open(struct inode *inode, struct file *file)
 	file->private_data = mfi;
 
 out:
-	unlock_kernel();
+	mutex_unlock(&mtd_mutex);
 	return ret;
 } /* mtd_open */
 
@@ -866,9 +867,9 @@ static long mtd_unlocked_ioctl(struct file *file, u_int cmd, u_long arg)
 {
 	int ret;
 
-	lock_kernel();
+	mutex_lock(&mtd_mutex);
 	ret = mtd_ioctl(file, cmd, arg);
-	unlock_kernel();
+	mutex_unlock(&mtd_mutex);
 
 	return ret;
 }
@@ -892,7 +893,7 @@ static long mtd_compat_ioctl(struct file *file, unsigned int cmd,
 	void __user *argp = compat_ptr(arg);
 	int ret = 0;
 
-	lock_kernel();
+	mutex_lock(&mtd_mutex);
 
 	switch (cmd) {
 	case MEMWRITEOOB32:
@@ -927,7 +928,7 @@ static long mtd_compat_ioctl(struct file *file, unsigned int cmd,
 		ret = mtd_ioctl(file, cmd, (unsigned long)argp);
 	}
 
-	unlock_kernel();
+	mutex_unlock(&mtd_mutex);
 
 	return ret;
 }

commit e8a89cebdbaab14caaa26debdb4ffd493b8831af
Merge: 8196867c7489 6ae0185fe201
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Aug 10 11:49:21 2010 -0700

    Merge git://git.infradead.org/mtd-2.6
    
    * git://git.infradead.org/mtd-2.6: (79 commits)
      mtd: Remove obsolete <mtd/compatmac.h> include
      mtd: Update copyright notices
      jffs2: Update copyright notices
      mtd-physmap: add support users can assign the probe type in board files
      mtd: remove redwood map driver
      mxc_nand: Add v3 (i.MX51) Support
      mxc_nand: support 8bit ecc
      mxc_nand: fix correct_data function
      mxc_nand: add V1_V2 namespace to registers
      mxc_nand: factor out a check_int function
      mxc_nand: make some internally used functions overwriteable
      mxc_nand: rework get_dev_status
      mxc_nand: remove 0xe00 offset from registers
      mtd: denali: Add multi connected NAND support
      mtd: denali: Remove set_ecc_config function
      mtd: denali: Remove unuseful code in get_xx_nand_para functions
      mtd: denali: Remove device_info_tag structure
      mtd: m25p80: add support for the Winbond W25Q32 SPI flash chip
      mtd: m25p80: add support for the Intel/Numonyx {16,32,64}0S33B SPI flash chips
      mtd: m25p80: add support for the EON EN25P{32, 64} SPI flash chips
      ...
    
    Fix up trivial conflicts in drivers/mtd/maps/{Kconfig,redwood.c} due to
    redwood driver removal.

commit 6ae0185fe201eae0548dace2a84acb5050fc8606
Author: David Woodhouse <David.Woodhouse@intel.com>
Date:   Sun Aug 8 21:19:42 2010 +0100

    mtd: Remove obsolete <mtd/compatmac.h> include
    
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
index f6d76f1adca0..638827a25b77 100644
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -33,7 +33,6 @@
 
 #include <linux/mtd/mtd.h>
 #include <linux/mtd/map.h>
-#include <linux/mtd/compatmac.h>
 
 #include <asm/uaccess.h>
 

commit a1452a3771c4eb85bd779790b040efdc36f4274e
Author: David Woodhouse <David.Woodhouse@intel.com>
Date:   Sun Aug 8 20:58:20 2010 +0100

    mtd: Update copyright notices
    
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>

diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
index c27e65e3e291..f6d76f1adca0 100644
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -1,5 +1,19 @@
 /*
- * Character-device access to raw MTD devices.
+ * Copyright Â© 1999-2010 David Woodhouse <dwmw2@infradead.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
  *
  */
 

commit dd02b67d5e9e7896891fa27eb5db65f55a290998
Author: Anatolij Gustschin <agust@denx.de>
Date:   Tue Jun 15 09:30:15 2010 +0200

    mtd: mtdchar: fix mmap for MTD RAM/ROM char devices
    
    For no-mmu systems mmap() on RAM/ROM devices already works
    but for systems with mmu it probably was not tested and
    doesn't work.
    
    This patch allows using mmap() on MTD RAM/ROM devices on systems
    with MMU. It has been tested on mpc5121e based platform with
    MR0A16A MRAM device attached over LocalBus.
    
    Signed-off-by: Anatolij Gustschin <agust@denx.de>
    Acked-by: Mike Frysinger <vapier@gentoo.org>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
index a8e69dd2b2e4..c27e65e3e291 100644
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -18,6 +18,7 @@
 #include <linux/mount.h>
 
 #include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
 #include <linux/mtd/compatmac.h>
 
 #include <asm/uaccess.h>
@@ -955,9 +956,34 @@ static int mtd_mmap(struct file *file, struct vm_area_struct *vma)
 #ifdef CONFIG_MMU
 	struct mtd_file_info *mfi = file->private_data;
 	struct mtd_info *mtd = mfi->mtd;
+	struct map_info *map = mtd->priv;
+	unsigned long start;
+	unsigned long off;
+	u32 len;
+
+	if (mtd->type == MTD_RAM || mtd->type == MTD_ROM) {
+		off = vma->vm_pgoff << PAGE_SHIFT;
+		start = map->phys;
+		len = PAGE_ALIGN((start & ~PAGE_MASK) + map->size);
+		start &= PAGE_MASK;
+		if ((vma->vm_end - vma->vm_start + off) > len)
+			return -EINVAL;
+
+		off += start;
+		vma->vm_pgoff = off >> PAGE_SHIFT;
+		vma->vm_flags |= VM_IO | VM_RESERVED;
+
+#ifdef pgprot_noncached
+		if (file->f_flags & O_DSYNC || off >= __pa(high_memory))
+			vma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);
+#endif
+		if (io_remap_pfn_range(vma, vma->vm_start, off >> PAGE_SHIFT,
+				       vma->vm_end - vma->vm_start,
+				       vma->vm_page_prot))
+			return -EAGAIN;
 
-	if (mtd->type == MTD_RAM || mtd->type == MTD_ROM)
 		return 0;
+	}
 	return -ENOSYS;
 #else
 	return vma->vm_flags & VM_SHARED ? 0 : -ENOSYS;

commit 9938424f0c4d208883cbf32083ec2bfcc220f85b
Author: Richard Cochran <richardcochran@gmail.com>
Date:   Mon Jun 14 18:10:33 2010 +0200

    mtd: add an ioctl to query the lock status of a flash sector
    
    This patchs adds a way for user space programs to find out whether a
    flash sector is locked. An optional driver method in the mtd_info struct
    provides the information.
    
    Signed-off-by: Richard Cochran <richard.cochran@omicron.at>
    Signed-off-by: Artem Bityutskiy <Artem.Bityutskiy@nokia.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
index 8b223c0343ee..a8e69dd2b2e4 100644
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -676,6 +676,20 @@ static int mtd_ioctl(struct inode *inode, struct file *file,
 		break;
 	}
 
+	case MEMISLOCKED:
+	{
+		struct erase_info_user einfo;
+
+		if (copy_from_user(&einfo, argp, sizeof(einfo)))
+			return -EFAULT;
+
+		if (!mtd->is_locked)
+			ret = -EOPNOTSUPP;
+		else
+			ret = mtd->is_locked(mtd, einfo.start, einfo.length);
+		break;
+	}
+
 	/* Legacy interface */
 	case MEMGETOOBSEL:
 	{

commit 3975d16760d4be7402d1067c548c30c427971331
Merge: 4d3d769c605e 1c24d06f8e06
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Jun 7 17:10:06 2010 -0700

    Merge git://git.infradead.org/~dwmw2/mtd-2.6.35
    
    * git://git.infradead.org/~dwmw2/mtd-2.6.35:
      jffs2: update ctime when changing the file's permission by setfacl
      jffs2: Fix NFS race by using insert_inode_locked()
      jffs2: Fix in-core inode leaks on error paths
      mtd: Fix NAND submenu
      mtd/r852: update card detect early.
      mtd/r852: Fixes in case of DMA timeout
      mtd/r852: register IRQ as last step
      drivers/mtd: Use memdup_user
      docbook: make mtd nand module init static

commit f13771187b9423b824f32518319f6da85d819003
Merge: 15953654cc31 9f37af654fda
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon May 24 08:01:10 2010 -0700

    Merge branch 'bkl/ioctl' of git://git.kernel.org/pub/scm/linux/kernel/git/frederic/random-tracing
    
    * 'bkl/ioctl' of git://git.kernel.org/pub/scm/linux/kernel/git/frederic/random-tracing:
      uml: Pushdown the bkl from harddog_kern ioctl
      sunrpc: Pushdown the bkl from sunrpc cache ioctl
      sunrpc: Pushdown the bkl from ioctl
      autofs4: Pushdown the bkl from ioctl
      uml: Convert to unlocked_ioctls to remove implicit BKL
      ncpfs: BKL ioctl pushdown
      coda: Clean-up whitespace problems in pioctl.c
      coda: BKL ioctl pushdown
      drivers: Push down BKL into various drivers
      isdn: Push down BKL into ioctl functions
      scsi: Push down BKL into ioctl functions
      dvb: Push down BKL into ioctl functions
      smbfs: Push down BKL into ioctl function
      coda/psdev: Remove BKL from ioctl function
      um/mmapper: Remove BKL usage
      sn_hwperf: Kill BKL usage
      hfsplus: Push down BKL into ioctl function

commit df1f1d1cb43b4ffdef5ba5f0623e2f73e94ce030
Author: Julia Lawall <julia@diku.dk>
Date:   Sat May 22 10:22:49 2010 +0200

    drivers/mtd: Use memdup_user
    
    Use memdup_user when user data is immediately copied into the
    allocated region.
    
    The semantic patch that makes this change is as follows:
    (http://coccinelle.lip6.fr/)
    
    // <smpl>
    @@
    expression from,to,size,flag;
    position p;
    identifier l1,l2;
    @@
    
    -  to = \(kmalloc@p\|kzalloc@p\)(size,flag);
    +  to = memdup_user(from,size);
       if (
    -      to==NULL
    +      IS_ERR(to)
                     || ...) {
       <+... when != goto l1;
    -  -ENOMEM
    +  PTR_ERR(to)
       ...+>
       }
    -  if (copy_from_user(to, from, size) != 0) {
    -    <+... when != goto l2;
    -    -EFAULT
    -    ...+>
    -  }
    // </smpl>
    
    Signed-off-by: Julia Lawall <julia@diku.dk>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
index 8bb5e4a66328..8b223c0343ee 100644
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -404,14 +404,9 @@ static int mtd_do_writeoob(struct file *file, struct mtd_info *mtd,
 	if (ops.ooboffs && ops.ooblen > (mtd->oobsize - ops.ooboffs))
 		return -EINVAL;
 
-	ops.oobbuf = kmalloc(length, GFP_KERNEL);
-	if (!ops.oobbuf)
-		return -ENOMEM;
-
-	if (copy_from_user(ops.oobbuf, ptr, length)) {
-		kfree(ops.oobbuf);
-		return -EFAULT;
-	}
+	ops.oobbuf = memdup_user(ptr, length);
+	if (IS_ERR(ops.oobbuf))
+		return PTR_ERR(ops.oobbuf);
 
 	start &= ~((uint64_t)mtd->oobsize - 1);
 	ret = mtd->write_oob(mtd, start, &ops);

commit cd874237d97f24f601f16a140d20803b6a79202e
Author: Kirill A. Shutemov <kirill@shutemov.name>
Date:   Mon May 17 16:55:47 2010 +0300

    mtd: mtdchar: Do not corrupt backing device of device node inode
    
    We cannot modify file->f_mapping->backing_dev_info, because it will corrupt
    backing device of device node inode, since file->f_mapping is equal to
    inode->i_mapping (see __dentry_open() in fs/open.c).
    
    Let's introduce separate inode for MTD device with appropriate backing
    device.
    
    [dwmw2: Refactor to keep it all entirely within mtdchar.c; use iget_locked()]
    
    Signed-off-by: Kirill A. Shutemov <kirill@shutemov.name>
    Acked-by: Jan Kara <jack@suse.cz>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
index c355491d1326..8bb5e4a66328 100644
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -15,12 +15,15 @@
 #include <linux/smp_lock.h>
 #include <linux/backing-dev.h>
 #include <linux/compat.h>
+#include <linux/mount.h>
 
 #include <linux/mtd/mtd.h>
 #include <linux/mtd/compatmac.h>
 
 #include <asm/uaccess.h>
 
+#define MTD_INODE_FS_MAGIC 0x11307854
+static struct vfsmount *mtd_inode_mnt __read_mostly;
 
 /*
  * Data structure to hold the pointer to the mtd device as well
@@ -28,6 +31,7 @@
  */
 struct mtd_file_info {
 	struct mtd_info *mtd;
+	struct inode *ino;
 	enum mtd_file_modes mode;
 };
 
@@ -64,6 +68,7 @@ static int mtd_open(struct inode *inode, struct file *file)
 	int ret = 0;
 	struct mtd_info *mtd;
 	struct mtd_file_info *mfi;
+	struct inode *mtd_ino;
 
 	DEBUG(MTD_DEBUG_LEVEL0, "MTD_open\n");
 
@@ -85,11 +90,23 @@ static int mtd_open(struct inode *inode, struct file *file)
 		goto out;
 	}
 
-	if (mtd->backing_dev_info)
-		file->f_mapping->backing_dev_info = mtd->backing_dev_info;
+	mtd_ino = iget_locked(mtd_inode_mnt->mnt_sb, devnum);
+	if (!mtd_ino) {
+		put_mtd_device(mtd);
+		ret = -ENOMEM;
+		goto out;
+	}
+	if (mtd_ino->i_state & I_NEW) {
+		mtd_ino->i_private = mtd;
+		mtd_ino->i_mode = S_IFCHR;
+		mtd_ino->i_data.backing_dev_info = mtd->backing_dev_info;
+		unlock_new_inode(mtd_ino);
+	}
+	file->f_mapping = mtd_ino->i_mapping;
 
 	/* You can't open it RW if it's not a writeable device */
 	if ((file->f_mode & FMODE_WRITE) && !(mtd->flags & MTD_WRITEABLE)) {
+		iput(mtd_ino);
 		put_mtd_device(mtd);
 		ret = -EACCES;
 		goto out;
@@ -97,10 +114,12 @@ static int mtd_open(struct inode *inode, struct file *file)
 
 	mfi = kzalloc(sizeof(*mfi), GFP_KERNEL);
 	if (!mfi) {
+		iput(mtd_ino);
 		put_mtd_device(mtd);
 		ret = -ENOMEM;
 		goto out;
 	}
+	mfi->ino = mtd_ino;
 	mfi->mtd = mtd;
 	file->private_data = mfi;
 
@@ -122,6 +141,8 @@ static int mtd_close(struct inode *inode, struct file *file)
 	if ((file->f_mode & FMODE_WRITE) && mtd->sync)
 		mtd->sync(mtd);
 
+	iput(mfi->ino);
+
 	put_mtd_device(mtd);
 	file->private_data = NULL;
 	kfree(mfi);
@@ -951,22 +972,80 @@ static const struct file_operations mtd_fops = {
 #endif
 };
 
+static int mtd_inodefs_get_sb(struct file_system_type *fs_type, int flags,
+                               const char *dev_name, void *data,
+                               struct vfsmount *mnt)
+{
+        return get_sb_pseudo(fs_type, "mtd_inode:", NULL, MTD_INODE_FS_MAGIC,
+                             mnt);
+}
+
+static struct file_system_type mtd_inodefs_type = {
+       .name = "mtd_inodefs",
+       .get_sb = mtd_inodefs_get_sb,
+       .kill_sb = kill_anon_super,
+};
+
+static void mtdchar_notify_add(struct mtd_info *mtd)
+{
+}
+
+static void mtdchar_notify_remove(struct mtd_info *mtd)
+{
+	struct inode *mtd_ino = ilookup(mtd_inode_mnt->mnt_sb, mtd->index);
+
+	if (mtd_ino) {
+		/* Destroy the inode if it exists */
+		mtd_ino->i_nlink = 0;
+		iput(mtd_ino);
+	}
+}
+
+static struct mtd_notifier mtdchar_notifier = {
+	.add = mtdchar_notify_add,
+	.remove = mtdchar_notify_remove,
+};
+
 static int __init init_mtdchar(void)
 {
-	int status;
+	int ret;
 
-	status = __register_chrdev(MTD_CHAR_MAJOR, 0, 1 << MINORBITS,
+	ret = __register_chrdev(MTD_CHAR_MAJOR, 0, 1 << MINORBITS,
 				   "mtd", &mtd_fops);
-	if (status < 0) {
-		printk(KERN_NOTICE "Can't allocate major number %d for Memory Technology Devices.\n",
-		       MTD_CHAR_MAJOR);
+	if (ret < 0) {
+		pr_notice("Can't allocate major number %d for "
+				"Memory Technology Devices.\n", MTD_CHAR_MAJOR);
+		return ret;
 	}
 
-	return status;
+	ret = register_filesystem(&mtd_inodefs_type);
+	if (ret) {
+		pr_notice("Can't register mtd_inodefs filesystem: %d\n", ret);
+		goto err_unregister_chdev;
+	}
+
+	mtd_inode_mnt = kern_mount(&mtd_inodefs_type);
+	if (IS_ERR(mtd_inode_mnt)) {
+		ret = PTR_ERR(mtd_inode_mnt);
+		pr_notice("Error mounting mtd_inodefs filesystem: %d\n", ret);
+		goto err_unregister_filesystem;
+	}
+	register_mtd_user(&mtdchar_notifier);
+
+	return ret;
+
+err_unregister_filesystem:
+	unregister_filesystem(&mtd_inodefs_type);
+err_unregister_chdev:
+	__unregister_chrdev(MTD_CHAR_MAJOR, 0, 1 << MINORBITS, "mtd");
+	return ret;
 }
 
 static void __exit cleanup_mtdchar(void)
 {
+	unregister_mtd_user(&mtdchar_notifier);
+	mntput(mtd_inode_mnt);
+	unregister_filesystem(&mtd_inodefs_type);
 	__unregister_chrdev(MTD_CHAR_MAJOR, 0, 1 << MINORBITS, "mtd");
 }
 

commit 55929332c92e5d34d65a8f784604c92677ea3e15
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Tue Apr 27 00:24:05 2010 +0200

    drivers: Push down BKL into various drivers
    
    These are the last remaining device drivers using
    the ->ioctl file operation in the drivers directory
    (except from v4l drivers).
    
    [fweisbec: drop i8k pushdown as it has been done from
    procfs pushdown branch already]
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Frederic Weisbecker <fweisbec@gmail.com>

diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
index 5b081cb84351..6749c2f96342 100644
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -450,8 +450,7 @@ static int mtd_do_readoob(struct mtd_info *mtd, uint64_t start,
 	return ret;
 }
 
-static int mtd_ioctl(struct inode *inode, struct file *file,
-		     u_int cmd, u_long arg)
+static int mtd_ioctl(struct file *file, u_int cmd, u_long arg)
 {
 	struct mtd_file_info *mfi = file->private_data;
 	struct mtd_info *mtd = mfi->mtd;
@@ -822,6 +821,17 @@ static int mtd_ioctl(struct inode *inode, struct file *file,
 	return ret;
 } /* memory_ioctl */
 
+static long mtd_unlocked_ioctl(struct file *file, u_int cmd, u_long arg)
+{
+	int ret;
+
+	lock_kernel();
+	ret = mtd_ioctl(file, cmd, arg);
+	unlock_kernel();
+
+	return ret;
+}
+
 #ifdef CONFIG_COMPAT
 
 struct mtd_oob_buf32 {
@@ -836,7 +846,6 @@ struct mtd_oob_buf32 {
 static long mtd_compat_ioctl(struct file *file, unsigned int cmd,
 	unsigned long arg)
 {
-	struct inode *inode = file->f_path.dentry->d_inode;
 	struct mtd_file_info *mfi = file->private_data;
 	struct mtd_info *mtd = mfi->mtd;
 	void __user *argp = compat_ptr(arg);
@@ -874,7 +883,7 @@ static long mtd_compat_ioctl(struct file *file, unsigned int cmd,
 		break;
 	}
 	default:
-		ret = mtd_ioctl(inode, file, cmd, (unsigned long)argp);
+		ret = mtd_ioctl(file, cmd, (unsigned long)argp);
 	}
 
 	unlock_kernel();
@@ -942,7 +951,7 @@ static const struct file_operations mtd_fops = {
 	.llseek		= mtd_lseek,
 	.read		= mtd_read,
 	.write		= mtd_write,
-	.ioctl		= mtd_ioctl,
+	.unlocked_ioctl	= mtd_unlocked_ioctl,
 #ifdef CONFIG_COMPAT
 	.compat_ioctl	= mtd_compat_ioctl,
 #endif

commit dad0db318b391ddb9845ac5e52044f921219bf69
Author: Ben Hutchings <bhutchings@solarflare.com>
Date:   Fri Jan 29 21:00:04 2010 +0000

    mtdchar: Register the full range of minor numbers
    
    register_chrdev() registers minor numbers up to 255, but we can now
    potentially have much larger numbers.
    
    Signed-off-by: Ben Hutchings <bhutchings@solarflare.com>
    Signed-off-by: Artem Bityutskiy <Artem.Bityutskiy@nokia.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
index 9f826cda2748..c355491d1326 100644
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -955,7 +955,8 @@ static int __init init_mtdchar(void)
 {
 	int status;
 
-	status = register_chrdev(MTD_CHAR_MAJOR, "mtd", &mtd_fops);
+	status = __register_chrdev(MTD_CHAR_MAJOR, 0, 1 << MINORBITS,
+				   "mtd", &mtd_fops);
 	if (status < 0) {
 		printk(KERN_NOTICE "Can't allocate major number %d for Memory Technology Devices.\n",
 		       MTD_CHAR_MAJOR);
@@ -966,7 +967,7 @@ static int __init init_mtdchar(void)
 
 static void __exit cleanup_mtdchar(void)
 {
-	unregister_chrdev(MTD_CHAR_MAJOR, "mtd");
+	__unregister_chrdev(MTD_CHAR_MAJOR, 0, 1 << MINORBITS, "mtd");
 }
 
 module_init(init_mtdchar);

commit 24c15496771ea1f3902dee23f746042ba34dc2b8
Author: Ben Hutchings <bhutchings@solarflare.com>
Date:   Fri Jan 29 20:58:23 2010 +0000

    mtd: Remove unnecessary comparisons with MAX_MTD_DEVICES
    
    MAX_MTD_DEVICES is about to be removed.
    
    Signed-off-by: Ben Hutchings <bhutchings@solarflare.com>
    Signed-off-by: Artem Bityutskiy <Artem.Bityutskiy@nokia.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
index bce0a07cbac9..9f826cda2748 100644
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -67,9 +67,6 @@ static int mtd_open(struct inode *inode, struct file *file)
 
 	DEBUG(MTD_DEBUG_LEVEL0, "MTD_open\n");
 
-	if (devnum >= MAX_MTD_DEVICES)
-		return -ENODEV;
-
 	/* You can't open the RO devices RW */
 	if ((file->f_mode & FMODE_WRITE) && (minor & 1))
 		return -EACCES;

commit 0040476b0efa99ad0d4ffb81d8e882095420d288
Author: Roel Kluin <roel.kluin@gmail.com>
Date:   Fri Jan 29 10:35:04 2010 +0100

    mtd: change positive error return into negative
    
    Signed-off-by: Roel Kluin <roel.kluin@gmail.com>
    Signed-off-by: Artem Bityutskiy <Artem.Bityutskiy@nokia.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
index 0a85085fe697..bce0a07cbac9 100644
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -373,7 +373,7 @@ static int mtd_do_writeoob(struct file *file, struct mtd_info *mtd,
 	if (!mtd->write_oob)
 		ret = -EOPNOTSUPP;
 	else
-		ret = access_ok(VERIFY_READ, ptr, length) ? 0 : EFAULT;
+		ret = access_ok(VERIFY_READ, ptr, length) ? 0 : -EFAULT;
 
 	if (ret)
 		return ret;

commit bcc98a46eafd38968b05e793326f031988c2b2a8
Author: H Hartley Sweeten <hartleys@visionengravers.com>
Date:   Fri Jan 15 11:25:38 2010 -0700

    mtd: fix different address space noise
    
    In mtd_ioctl MEMGETREGIONINFO the region_user_info pointer ur
    is cast in __kernel space. This produces a number of sparse warnings
    like:
    
    warning: cast removes address space of expression
    warning: incorrect type in initializer (different address spaces)
       expected unsigned int const [noderef] <asn:1>*register __p
       got unsigned int *<noident>
    
    Since argp is already a void __user * just use it dirrectly without
    the cast and make ur a __user *.
    
    Signed-off-by: H Hartley Sweeten <hsweeten@visionengravers.com>
    Signed-off-by: Artem Bityutskiy <Artem.Bityutskiy@nokia.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
index 5b081cb84351..0a85085fe697 100644
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -482,7 +482,7 @@ static int mtd_ioctl(struct inode *inode, struct file *file,
 	{
 		uint32_t ur_idx;
 		struct mtd_erase_region_info *kr;
-		struct region_info_user *ur = (struct region_info_user *) argp;
+		struct region_info_user __user *ur = argp;
 
 		if (get_user(ur_idx, &(ur->regionindex)))
 			return -EFAULT;

commit 0b6585ce05f169f10ce74329e87bd8c5070b4bb9
Author: David Woodhouse <David.Woodhouse@intel.com>
Date:   Fri May 29 16:09:08 2009 +0100

    mtd: Fix pointer handling in compat ioctls to use compat_ptr()
    
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
index 5fff04f3303d..5b081cb84351 100644
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -839,7 +839,7 @@ static long mtd_compat_ioctl(struct file *file, unsigned int cmd,
 	struct inode *inode = file->f_path.dentry->d_inode;
 	struct mtd_file_info *mfi = file->private_data;
 	struct mtd_info *mtd = mfi->mtd;
-	void __user *argp = (void __user *)arg;
+	void __user *argp = compat_ptr(arg);
 	int ret = 0;
 
 	lock_kernel();
@@ -874,7 +874,7 @@ static long mtd_compat_ioctl(struct file *file, unsigned int cmd,
 		break;
 	}
 	default:
-		ret = mtd_ioctl(inode, file, cmd, arg);
+		ret = mtd_ioctl(inode, file, cmd, (unsigned long)argp);
 	}
 
 	unlock_kernel();

commit 668ff9ab45d595222d3f90d7974ccba3518e3bb3
Author: Kevin Cernekee <kpc.mtd@gmail.com>
Date:   Tue Apr 14 21:59:22 2009 -0700

    mtd: Handle compat ioctls directly; remove all trace from compat_ioctl.c
    
    Remove all references to MTD ioctls from fs/compat_ioctl.c and let
    them all be handled by mtd_compat_ioctl().
    
    Signed-off-by: Kevin Cernekee <kpc.mtd@gmail.com>
    Signed-off-by: Artem Bityutskiy <Artem.Bityutskiy@nokia.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
index 99d1fbc95011..5fff04f3303d 100644
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -836,6 +836,7 @@ struct mtd_oob_buf32 {
 static long mtd_compat_ioctl(struct file *file, unsigned int cmd,
 	unsigned long arg)
 {
+	struct inode *inode = file->f_path.dentry->d_inode;
 	struct mtd_file_info *mfi = file->private_data;
 	struct mtd_info *mtd = mfi->mtd;
 	void __user *argp = (void __user *)arg;
@@ -873,7 +874,7 @@ static long mtd_compat_ioctl(struct file *file, unsigned int cmd,
 		break;
 	}
 	default:
-		ret = -ENOIOCTLCMD;
+		ret = mtd_ioctl(inode, file, cmd, arg);
 	}
 
 	unlock_kernel();

commit aea7cea9fa9e39e71f95ad70b3daf98ba9972587
Author: Kevin Cernekee <kpc.mtd@gmail.com>
Date:   Wed Apr 8 22:53:49 2009 -0700

    mtd: add OOB ioctls for >4GiB devices
    
    Signed-off-by: Kevin Cernekee <kpc.mtd@gmail.com>
    Signed-off-by: Artem Bityutskiy <Artem.Bityutskiy@nokia.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
index 51bb0b092003..99d1fbc95011 100644
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -607,6 +607,34 @@ static int mtd_ioctl(struct inode *inode, struct file *file,
 		break;
 	}
 
+	case MEMWRITEOOB64:
+	{
+		struct mtd_oob_buf64 buf;
+		struct mtd_oob_buf64 __user *buf_user = argp;
+
+		if (copy_from_user(&buf, argp, sizeof(buf)))
+			ret = -EFAULT;
+		else
+			ret = mtd_do_writeoob(file, mtd, buf.start, buf.length,
+				(void __user *)(uintptr_t)buf.usr_ptr,
+				&buf_user->length);
+		break;
+	}
+
+	case MEMREADOOB64:
+	{
+		struct mtd_oob_buf64 buf;
+		struct mtd_oob_buf64 __user *buf_user = argp;
+
+		if (copy_from_user(&buf, argp, sizeof(buf)))
+			ret = -EFAULT;
+		else
+			ret = mtd_do_readoob(mtd, buf.start, buf.length,
+				(void __user *)(uintptr_t)buf.usr_ptr,
+				&buf_user->length);
+		break;
+	}
+
 	case MEMLOCK:
 	{
 		struct erase_info_user einfo;

commit 977185404046afb31d2e18fac0a076de1a20bf0e
Author: Kevin Cernekee <kpc.mtd@gmail.com>
Date:   Wed Apr 8 22:53:13 2009 -0700

    mtd: compat_ioctl cleanup
    
    1) Move the MEMREADOOB/MEMWRITEOOB compat_ioctl wrappers from
    fs/compat_ioctl.c into mtdchar.c .  Original request was here:
    
    http://lkml.org/lkml/2009/4/1/295
    
    2) Add missing COMPATIBLE_IOCTL lines, so that mtd-utils does not error
    out when running in 64/32 compatibility mode.
    
    LKML-Reference: <200904011650.22928.arnd@arndb.de>
    Signed-off-by: Kevin Cernekee <kpc.mtd@gmail.com>
    Signed-off-by: Artem Bityutskiy <Artem.Bityutskiy@nokia.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
index ad4b8618977d..51bb0b092003 100644
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -14,6 +14,7 @@
 #include <linux/sched.h>
 #include <linux/smp_lock.h>
 #include <linux/backing-dev.h>
+#include <linux/compat.h>
 
 #include <linux/mtd/mtd.h>
 #include <linux/mtd/compatmac.h>
@@ -355,6 +356,100 @@ static int otp_select_filemode(struct mtd_file_info *mfi, int mode)
 # define otp_select_filemode(f,m)	-EOPNOTSUPP
 #endif
 
+static int mtd_do_writeoob(struct file *file, struct mtd_info *mtd,
+	uint64_t start, uint32_t length, void __user *ptr,
+	uint32_t __user *retp)
+{
+	struct mtd_oob_ops ops;
+	uint32_t retlen;
+	int ret = 0;
+
+	if (!(file->f_mode & FMODE_WRITE))
+		return -EPERM;
+
+	if (length > 4096)
+		return -EINVAL;
+
+	if (!mtd->write_oob)
+		ret = -EOPNOTSUPP;
+	else
+		ret = access_ok(VERIFY_READ, ptr, length) ? 0 : EFAULT;
+
+	if (ret)
+		return ret;
+
+	ops.ooblen = length;
+	ops.ooboffs = start & (mtd->oobsize - 1);
+	ops.datbuf = NULL;
+	ops.mode = MTD_OOB_PLACE;
+
+	if (ops.ooboffs && ops.ooblen > (mtd->oobsize - ops.ooboffs))
+		return -EINVAL;
+
+	ops.oobbuf = kmalloc(length, GFP_KERNEL);
+	if (!ops.oobbuf)
+		return -ENOMEM;
+
+	if (copy_from_user(ops.oobbuf, ptr, length)) {
+		kfree(ops.oobbuf);
+		return -EFAULT;
+	}
+
+	start &= ~((uint64_t)mtd->oobsize - 1);
+	ret = mtd->write_oob(mtd, start, &ops);
+
+	if (ops.oobretlen > 0xFFFFFFFFU)
+		ret = -EOVERFLOW;
+	retlen = ops.oobretlen;
+	if (copy_to_user(retp, &retlen, sizeof(length)))
+		ret = -EFAULT;
+
+	kfree(ops.oobbuf);
+	return ret;
+}
+
+static int mtd_do_readoob(struct mtd_info *mtd, uint64_t start,
+	uint32_t length, void __user *ptr, uint32_t __user *retp)
+{
+	struct mtd_oob_ops ops;
+	int ret = 0;
+
+	if (length > 4096)
+		return -EINVAL;
+
+	if (!mtd->read_oob)
+		ret = -EOPNOTSUPP;
+	else
+		ret = access_ok(VERIFY_WRITE, ptr,
+				length) ? 0 : -EFAULT;
+	if (ret)
+		return ret;
+
+	ops.ooblen = length;
+	ops.ooboffs = start & (mtd->oobsize - 1);
+	ops.datbuf = NULL;
+	ops.mode = MTD_OOB_PLACE;
+
+	if (ops.ooboffs && ops.ooblen > (mtd->oobsize - ops.ooboffs))
+		return -EINVAL;
+
+	ops.oobbuf = kmalloc(length, GFP_KERNEL);
+	if (!ops.oobbuf)
+		return -ENOMEM;
+
+	start &= ~((uint64_t)mtd->oobsize - 1);
+	ret = mtd->read_oob(mtd, start, &ops);
+
+	if (put_user(ops.oobretlen, retp))
+		ret = -EFAULT;
+	else if (ops.oobretlen && copy_to_user(ptr, ops.oobbuf,
+					    ops.oobretlen))
+		ret = -EFAULT;
+
+	kfree(ops.oobbuf);
+	return ret;
+}
+
 static int mtd_ioctl(struct inode *inode, struct file *file,
 		     u_int cmd, u_long arg)
 {
@@ -487,100 +582,28 @@ static int mtd_ioctl(struct inode *inode, struct file *file,
 	case MEMWRITEOOB:
 	{
 		struct mtd_oob_buf buf;
-		struct mtd_oob_ops ops;
-		struct mtd_oob_buf __user *user_buf = argp;
-	        uint32_t retlen;
-
-		if(!(file->f_mode & FMODE_WRITE))
-			return -EPERM;
-
-		if (copy_from_user(&buf, argp, sizeof(struct mtd_oob_buf)))
-			return -EFAULT;
-
-		if (buf.length > 4096)
-			return -EINVAL;
-
-		if (!mtd->write_oob)
-			ret = -EOPNOTSUPP;
-		else
-			ret = access_ok(VERIFY_READ, buf.ptr,
-					buf.length) ? 0 : EFAULT;
-
-		if (ret)
-			return ret;
-
-		ops.ooblen = buf.length;
-		ops.ooboffs = buf.start & (mtd->oobsize - 1);
-		ops.datbuf = NULL;
-		ops.mode = MTD_OOB_PLACE;
-
-		if (ops.ooboffs && ops.ooblen > (mtd->oobsize - ops.ooboffs))
-			return -EINVAL;
-
-		ops.oobbuf = kmalloc(buf.length, GFP_KERNEL);
-		if (!ops.oobbuf)
-			return -ENOMEM;
-
-		if (copy_from_user(ops.oobbuf, buf.ptr, buf.length)) {
-			kfree(ops.oobbuf);
-			return -EFAULT;
-		}
-
-		buf.start &= ~(mtd->oobsize - 1);
-		ret = mtd->write_oob(mtd, buf.start, &ops);
+		struct mtd_oob_buf __user *buf_user = argp;
 
-		if (ops.oobretlen > 0xFFFFFFFFU)
-			ret = -EOVERFLOW;
-		retlen = ops.oobretlen;
-		if (copy_to_user(&user_buf->length, &retlen, sizeof(buf.length)))
+		/* NOTE: writes return length to buf_user->length */
+		if (copy_from_user(&buf, argp, sizeof(buf)))
 			ret = -EFAULT;
-
-		kfree(ops.oobbuf);
+		else
+			ret = mtd_do_writeoob(file, mtd, buf.start, buf.length,
+				buf.ptr, &buf_user->length);
 		break;
-
 	}
 
 	case MEMREADOOB:
 	{
 		struct mtd_oob_buf buf;
-		struct mtd_oob_ops ops;
-
-		if (copy_from_user(&buf, argp, sizeof(struct mtd_oob_buf)))
-			return -EFAULT;
-
-		if (buf.length > 4096)
-			return -EINVAL;
-
-		if (!mtd->read_oob)
-			ret = -EOPNOTSUPP;
-		else
-			ret = access_ok(VERIFY_WRITE, buf.ptr,
-					buf.length) ? 0 : -EFAULT;
-		if (ret)
-			return ret;
-
-		ops.ooblen = buf.length;
-		ops.ooboffs = buf.start & (mtd->oobsize - 1);
-		ops.datbuf = NULL;
-		ops.mode = MTD_OOB_PLACE;
+		struct mtd_oob_buf __user *buf_user = argp;
 
-		if (ops.ooboffs && ops.ooblen > (mtd->oobsize - ops.ooboffs))
-			return -EINVAL;
-
-		ops.oobbuf = kmalloc(buf.length, GFP_KERNEL);
-		if (!ops.oobbuf)
-			return -ENOMEM;
-
-		buf.start &= ~(mtd->oobsize - 1);
-		ret = mtd->read_oob(mtd, buf.start, &ops);
-
-		if (put_user(ops.oobretlen, (uint32_t __user *)argp))
-			ret = -EFAULT;
-		else if (ops.oobretlen && copy_to_user(buf.ptr, ops.oobbuf,
-						    ops.oobretlen))
+		/* NOTE: writes return length to buf_user->start */
+		if (copy_from_user(&buf, argp, sizeof(buf)))
 			ret = -EFAULT;
-
-		kfree(ops.oobbuf);
+		else
+			ret = mtd_do_readoob(mtd, buf.start, buf.length,
+				buf.ptr, &buf_user->start);
 		break;
 	}
 
@@ -771,6 +794,67 @@ static int mtd_ioctl(struct inode *inode, struct file *file,
 	return ret;
 } /* memory_ioctl */
 
+#ifdef CONFIG_COMPAT
+
+struct mtd_oob_buf32 {
+	u_int32_t start;
+	u_int32_t length;
+	compat_caddr_t ptr;	/* unsigned char* */
+};
+
+#define MEMWRITEOOB32		_IOWR('M', 3, struct mtd_oob_buf32)
+#define MEMREADOOB32		_IOWR('M', 4, struct mtd_oob_buf32)
+
+static long mtd_compat_ioctl(struct file *file, unsigned int cmd,
+	unsigned long arg)
+{
+	struct mtd_file_info *mfi = file->private_data;
+	struct mtd_info *mtd = mfi->mtd;
+	void __user *argp = (void __user *)arg;
+	int ret = 0;
+
+	lock_kernel();
+
+	switch (cmd) {
+	case MEMWRITEOOB32:
+	{
+		struct mtd_oob_buf32 buf;
+		struct mtd_oob_buf32 __user *buf_user = argp;
+
+		if (copy_from_user(&buf, argp, sizeof(buf)))
+			ret = -EFAULT;
+		else
+			ret = mtd_do_writeoob(file, mtd, buf.start,
+				buf.length, compat_ptr(buf.ptr),
+				&buf_user->length);
+		break;
+	}
+
+	case MEMREADOOB32:
+	{
+		struct mtd_oob_buf32 buf;
+		struct mtd_oob_buf32 __user *buf_user = argp;
+
+		/* NOTE: writes return length to buf->start */
+		if (copy_from_user(&buf, argp, sizeof(buf)))
+			ret = -EFAULT;
+		else
+			ret = mtd_do_readoob(mtd, buf.start,
+				buf.length, compat_ptr(buf.ptr),
+				&buf_user->start);
+		break;
+	}
+	default:
+		ret = -ENOIOCTLCMD;
+	}
+
+	unlock_kernel();
+
+	return ret;
+}
+
+#endif /* CONFIG_COMPAT */
+
 /*
  * try to determine where a shared mapping can be made
  * - only supported for NOMMU at the moment (MMU can't doesn't copy private
@@ -830,6 +914,9 @@ static const struct file_operations mtd_fops = {
 	.read		= mtd_read,
 	.write		= mtd_write,
 	.ioctl		= mtd_ioctl,
+#ifdef CONFIG_COMPAT
+	.compat_ioctl	= mtd_compat_ioctl,
+#endif
 	.open		= mtd_open,
 	.release	= mtd_close,
 	.mmap		= mtd_mmap,

commit 0dc54e9f33e2fbcea28356bc2c8c931cb307d3b3
Author: Kevin Cernekee <kpc.mtd@gmail.com>
Date:   Wed Apr 8 22:52:28 2009 -0700

    mtd: add MEMERASE64 ioctl for >4GiB devices
    
    New MEMERASE/MEMREADOOB/MEMWRITEOOB ioctls are needed in order to support
    64-bit offsets into large NAND flash devices.
    
    Signed-off-by: Kevin Cernekee <kpc.mtd@gmail.com>
    Signed-off-by: Artem Bityutskiy <Artem.Bityutskiy@nokia.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
index 763d3f0a1f42..ad4b8618977d 100644
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -417,6 +417,7 @@ static int mtd_ioctl(struct inode *inode, struct file *file,
 		break;
 
 	case MEMERASE:
+	case MEMERASE64:
 	{
 		struct erase_info *erase;
 
@@ -427,20 +428,32 @@ static int mtd_ioctl(struct inode *inode, struct file *file,
 		if (!erase)
 			ret = -ENOMEM;
 		else {
-			struct erase_info_user einfo;
-
 			wait_queue_head_t waitq;
 			DECLARE_WAITQUEUE(wait, current);
 
 			init_waitqueue_head(&waitq);
 
-			if (copy_from_user(&einfo, argp,
-				    sizeof(struct erase_info_user))) {
-				kfree(erase);
-				return -EFAULT;
+			if (cmd == MEMERASE64) {
+				struct erase_info_user64 einfo64;
+
+				if (copy_from_user(&einfo64, argp,
+					    sizeof(struct erase_info_user64))) {
+					kfree(erase);
+					return -EFAULT;
+				}
+				erase->addr = einfo64.start;
+				erase->len = einfo64.length;
+			} else {
+				struct erase_info_user einfo32;
+
+				if (copy_from_user(&einfo32, argp,
+					    sizeof(struct erase_info_user))) {
+					kfree(erase);
+					return -EFAULT;
+				}
+				erase->addr = einfo32.start;
+				erase->len = einfo32.length;
 			}
-			erase->addr = einfo.start;
-			erase->len = einfo.length;
 			erase->mtd = mtd;
 			erase->callback = mtdchar_erase_callback;
 			erase->priv = (unsigned long)&waitq;

commit 1f24b5a8ecbb2a3c7080f418974d40e3ffedb221
Author: David Brownell <dbrownell@users.sourceforge.net>
Date:   Thu Mar 26 00:42:41 2009 -0700

    [MTD] driver model updates
    
    Update driver model support in the MTD framework, so it fits
    better into the current udev-based hotplug framework:
    
     - Each mtd_info now has a device node.  MTD drivers should set
       the dev.parent field to point to the physical device, before
       setting up partitions or otherwise declaring MTDs.
    
     - Those device nodes always map to /sys/class/mtdX device nodes,
       which no longer depend on MTD_CHARDEV.
    
     - Those mtdX sysfs nodes have a "starter set" of attributes;
       it's not yet sufficient to replace /proc/mtd.
    
     - Enabling MTD_CHARDEV provides /sys/class/mtdXro/ nodes and the
       /sys/class/mtd*/dev attributes (for udev, mdev, etc).
    
     - Include a MODULE_ALIAS_CHARDEV_MAJOR macro.  It'll work with
       udev creating the /dev/mtd* nodes, not just a static rootfs.
    
    So the sysfs structure is pretty much what you'd expect, except
    that readonly chardev nodes are a bit quirky.
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
index f478f1fc3949..763d3f0a1f42 100644
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -20,33 +20,6 @@
 
 #include <asm/uaccess.h>
 
-static struct class *mtd_class;
-
-static void mtd_notify_add(struct mtd_info* mtd)
-{
-	if (!mtd)
-		return;
-
-	device_create(mtd_class, NULL, MKDEV(MTD_CHAR_MAJOR, mtd->index*2),
-		      NULL, "mtd%d", mtd->index);
-
-	device_create(mtd_class, NULL, MKDEV(MTD_CHAR_MAJOR, mtd->index*2+1),
-		      NULL, "mtd%dro", mtd->index);
-}
-
-static void mtd_notify_remove(struct mtd_info* mtd)
-{
-	if (!mtd)
-		return;
-
-	device_destroy(mtd_class, MKDEV(MTD_CHAR_MAJOR, mtd->index*2));
-	device_destroy(mtd_class, MKDEV(MTD_CHAR_MAJOR, mtd->index*2+1));
-}
-
-static struct mtd_notifier notifier = {
-	.add	= mtd_notify_add,
-	.remove	= mtd_notify_remove,
-};
 
 /*
  * Data structure to hold the pointer to the mtd device as well
@@ -854,34 +827,26 @@ static const struct file_operations mtd_fops = {
 
 static int __init init_mtdchar(void)
 {
-	if (register_chrdev(MTD_CHAR_MAJOR, "mtd", &mtd_fops)) {
+	int status;
+
+	status = register_chrdev(MTD_CHAR_MAJOR, "mtd", &mtd_fops);
+	if (status < 0) {
 		printk(KERN_NOTICE "Can't allocate major number %d for Memory Technology Devices.\n",
 		       MTD_CHAR_MAJOR);
-		return -EAGAIN;
-	}
-
-	mtd_class = class_create(THIS_MODULE, "mtd");
-
-	if (IS_ERR(mtd_class)) {
-		printk(KERN_ERR "Error creating mtd class.\n");
-		unregister_chrdev(MTD_CHAR_MAJOR, "mtd");
-		return PTR_ERR(mtd_class);
 	}
 
-	register_mtd_user(&notifier);
-	return 0;
+	return status;
 }
 
 static void __exit cleanup_mtdchar(void)
 {
-	unregister_mtd_user(&notifier);
-	class_destroy(mtd_class);
 	unregister_chrdev(MTD_CHAR_MAJOR, "mtd");
 }
 
 module_init(init_mtdchar);
 module_exit(cleanup_mtdchar);
 
+MODULE_ALIAS_CHARDEV_MAJOR(MTD_CHAR_MAJOR);
 
 MODULE_LICENSE("GPL");
 MODULE_AUTHOR("David Woodhouse <dwmw2@infradead.org>");

commit 402d326519c1a4859c527702383f4e60f606ef52
Author: David Howells <dhowells@redhat.com>
Date:   Thu Feb 12 10:40:00 2009 +0000

    NOMMU: Present backing device capabilities for MTD chardevs
    
    Present backing device capabilities for MTD character device files to allow
    NOMMU mmap to do direct mapping where possible.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Tested-by: Bernd Schmidt <bernd.schmidt@analog.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
index 2c8a16f49ca2..f478f1fc3949 100644
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -13,6 +13,7 @@
 #include <linux/slab.h>
 #include <linux/sched.h>
 #include <linux/smp_lock.h>
+#include <linux/backing-dev.h>
 
 #include <linux/mtd/mtd.h>
 #include <linux/mtd/compatmac.h>
@@ -107,12 +108,15 @@ static int mtd_open(struct inode *inode, struct file *file)
 		goto out;
 	}
 
-	if (MTD_ABSENT == mtd->type) {
+	if (mtd->type == MTD_ABSENT) {
 		put_mtd_device(mtd);
 		ret = -ENODEV;
 		goto out;
 	}
 
+	if (mtd->backing_dev_info)
+		file->f_mapping->backing_dev_info = mtd->backing_dev_info;
+
 	/* You can't open it RW if it's not a writeable device */
 	if ((file->f_mode & FMODE_WRITE) && !(mtd->flags & MTD_WRITEABLE)) {
 		put_mtd_device(mtd);
@@ -781,6 +785,59 @@ static int mtd_ioctl(struct inode *inode, struct file *file,
 	return ret;
 } /* memory_ioctl */
 
+/*
+ * try to determine where a shared mapping can be made
+ * - only supported for NOMMU at the moment (MMU can't doesn't copy private
+ *   mappings)
+ */
+#ifndef CONFIG_MMU
+static unsigned long mtd_get_unmapped_area(struct file *file,
+					   unsigned long addr,
+					   unsigned long len,
+					   unsigned long pgoff,
+					   unsigned long flags)
+{
+	struct mtd_file_info *mfi = file->private_data;
+	struct mtd_info *mtd = mfi->mtd;
+
+	if (mtd->get_unmapped_area) {
+		unsigned long offset;
+
+		if (addr != 0)
+			return (unsigned long) -EINVAL;
+
+		if (len > mtd->size || pgoff >= (mtd->size >> PAGE_SHIFT))
+			return (unsigned long) -EINVAL;
+
+		offset = pgoff << PAGE_SHIFT;
+		if (offset > mtd->size - len)
+			return (unsigned long) -EINVAL;
+
+		return mtd->get_unmapped_area(mtd, len, offset, flags);
+	}
+
+	/* can't map directly */
+	return (unsigned long) -ENOSYS;
+}
+#endif
+
+/*
+ * set up a mapping for shared memory segments
+ */
+static int mtd_mmap(struct file *file, struct vm_area_struct *vma)
+{
+#ifdef CONFIG_MMU
+	struct mtd_file_info *mfi = file->private_data;
+	struct mtd_info *mtd = mfi->mtd;
+
+	if (mtd->type == MTD_RAM || mtd->type == MTD_ROM)
+		return 0;
+	return -ENOSYS;
+#else
+	return vma->vm_flags & VM_SHARED ? 0 : -ENOSYS;
+#endif
+}
+
 static const struct file_operations mtd_fops = {
 	.owner		= THIS_MODULE,
 	.llseek		= mtd_lseek,
@@ -789,6 +846,10 @@ static const struct file_operations mtd_fops = {
 	.ioctl		= mtd_ioctl,
 	.open		= mtd_open,
 	.release	= mtd_close,
+	.mmap		= mtd_mmap,
+#ifndef CONFIG_MMU
+	.get_unmapped_area = mtd_get_unmapped_area,
+#endif
 };
 
 static int __init init_mtdchar(void)

commit 90160e13b0bfe82d8bfe83541e3aa3961fdeed25
Author: Scott James Remnant <scott@canonical.com>
Date:   Mon Mar 2 18:42:39 2009 +0000

    [MTD] Auto-load mtdchar module when device opened.
    
    The mtdchar module is missing the char-major-90-* alias that would cause
    it to be auto-loaded when a device of that type is opened.  This patch
    adds the alia..
    
    Signed-off-by: Scott James Remnant <scott@canonical.com>
    Signed-off-by: Tim Gardner <tim.gardner@canonical.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
index e9ec59e9a566..2c8a16f49ca2 100644
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -825,3 +825,4 @@ module_exit(cleanup_mtdchar);
 MODULE_LICENSE("GPL");
 MODULE_AUTHOR("David Woodhouse <dwmw2@infradead.org>");
 MODULE_DESCRIPTION("Direct character-device access to MTD devices");
+MODULE_ALIAS_CHARDEV_MAJOR(MTD_CHAR_MAJOR);

commit 69423d99fc182a81f3c5db3eb5c140acc6fc64be
Author: Adrian Hunter <ext-adrian.hunter@nokia.com>
Date:   Wed Dec 10 13:37:21 2008 +0000

    [MTD] update internal API to support 64-bit device size
    
    MTD internal API presently uses 32-bit values to represent
    device size.  This patch updates them to 64-bits but leaves
    the external API unchanged.  Extending the external API
    is a separate issue for several reasons.  First, no one
    needs it at the moment.  Secondly, whether the implementation
    is done with IOCTLs, sysfs or both is still debated.  Thirdly
    external API changes require the internal API to be accepted
    first.
    
    Note that although the MTD API will be able to support 64-bit
    device sizes, existing drivers do not and are not required
    to do so, although NAND base has been updated.
    
    In general, changing from 32-bit to 64-bit values cause little
    or no changes to the majority of the code with the following
    exceptions:
            - printk message formats
            - division and modulus of 64-bit values
            - NAND base support
            - 32-bit local variables used by mtdpart and mtdconcat
            - naughtily assuming one structure maps to another
            in MEMERASE ioctl
    
    Signed-off-by: Adrian Hunter <ext-adrian.hunter@nokia.com>
    Signed-off-by: Artem Bityutskiy <Artem.Bityutskiy@nokia.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
index bcffeda2df3d..e9ec59e9a566 100644
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -450,16 +450,20 @@ static int mtd_ioctl(struct inode *inode, struct file *file,
 		if (!erase)
 			ret = -ENOMEM;
 		else {
+			struct erase_info_user einfo;
+
 			wait_queue_head_t waitq;
 			DECLARE_WAITQUEUE(wait, current);
 
 			init_waitqueue_head(&waitq);
 
-			if (copy_from_user(&erase->addr, argp,
+			if (copy_from_user(&einfo, argp,
 				    sizeof(struct erase_info_user))) {
 				kfree(erase);
 				return -EFAULT;
 			}
+			erase->addr = einfo.start;
+			erase->len = einfo.length;
 			erase->mtd = mtd;
 			erase->callback = mtdchar_erase_callback;
 			erase->priv = (unsigned long)&waitq;

commit aeb5d727062a0238a2f96c9c380fbd2be4640c6f
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Tue Sep 2 15:28:45 2008 -0400

    [PATCH] introduce fmode_t, do annotations
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
index 963840e9b5bf..bcffeda2df3d 100644
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -96,7 +96,7 @@ static int mtd_open(struct inode *inode, struct file *file)
 		return -ENODEV;
 
 	/* You can't open the RO devices RW */
-	if ((file->f_mode & 2) && (minor & 1))
+	if ((file->f_mode & FMODE_WRITE) && (minor & 1))
 		return -EACCES;
 
 	lock_kernel();
@@ -114,7 +114,7 @@ static int mtd_open(struct inode *inode, struct file *file)
 	}
 
 	/* You can't open it RW if it's not a writeable device */
-	if ((file->f_mode & 2) && !(mtd->flags & MTD_WRITEABLE)) {
+	if ((file->f_mode & FMODE_WRITE) && !(mtd->flags & MTD_WRITEABLE)) {
 		put_mtd_device(mtd);
 		ret = -EACCES;
 		goto out;
@@ -144,7 +144,7 @@ static int mtd_close(struct inode *inode, struct file *file)
 	DEBUG(MTD_DEBUG_LEVEL0, "MTD_close\n");
 
 	/* Only sync if opened RW */
-	if ((file->f_mode & 2) && mtd->sync)
+	if ((file->f_mode & FMODE_WRITE) && mtd->sync)
 		mtd->sync(mtd);
 
 	put_mtd_device(mtd);
@@ -443,7 +443,7 @@ static int mtd_ioctl(struct inode *inode, struct file *file,
 	{
 		struct erase_info *erase;
 
-		if(!(file->f_mode & 2))
+		if(!(file->f_mode & FMODE_WRITE))
 			return -EPERM;
 
 		erase=kzalloc(sizeof(struct erase_info),GFP_KERNEL);
@@ -497,7 +497,7 @@ static int mtd_ioctl(struct inode *inode, struct file *file,
 		struct mtd_oob_buf __user *user_buf = argp;
 	        uint32_t retlen;
 
-		if(!(file->f_mode & 2))
+		if(!(file->f_mode & FMODE_WRITE))
 			return -EPERM;
 
 		if (copy_from_user(&buf, argp, sizeof(struct mtd_oob_buf)))

commit 2be508d847392e431759e370d21cea9412848758
Merge: 01e8ef11bc1a 8a1a6272057e
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Oct 20 09:03:12 2008 -0700

    Merge git://git.infradead.org/mtd-2.6
    
    * git://git.infradead.org/mtd-2.6: (69 commits)
      Revert "[MTD] m25p80.c code cleanup"
      [MTD] [NAND] GPIO driver depends on ARM... for now.
      [MTD] [NAND] sh_flctl: fix compile error
      [MTD] [NOR] AT49BV6416 has swapped erase regions
      [MTD] [NAND] GPIO NAND flash driver
      [MTD] cmdlineparts documentation change - explain where mtd-id comes from
      [MTD] cfi_cmdset_0002.c: Add Macronix CFI V1.0 TopBottom detection
      [MTD] [NAND] Fix compilation warnings in drivers/mtd/nand/cs553x_nand.c
      [JFFS2] Write buffer offset adjustment for NOR-ECC (Sibley) flash
      [MTD] mtdoops: Fix a bug where block may not be erased
      [MTD] mtdoops: Add a magic number to logged kernel oops
      [MTD] mtdoops: Fix an off by one error
      [JFFS2] Correct parameter names of jffs2_compress() in comments
      [MTD] [NAND] sh_flctl: add support for Renesas SuperH FLCTL
      [MTD] [NAND] Bug on atmel_nand HW ECC : OOB info not correctly written
      [MTD] [MAPS] Remove unused variable after ROM API cleanup.
      [MTD] m25p80.c extended jedec support (v2)
      [MTD] remove unused mtd parameter in of_mtd_parse_partitions()
      [MTD] [NAND] remove dead Kconfig associated with !CONFIG_PPC_MERGE
      [MTD] [NAND] driver extension to support NAND on TQM85xx modules
      ...

commit a9b12619f7b6f19c871437ec24a088787a04b1de
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon Jul 21 20:03:34 2008 -0700

    device create: misc: convert device_create_drvdata to device_create
    
    Now that device_create() has been audited, rename things back to the
    original call to be sane.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
index e00d424e6575..1c74762dec89 100644
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -26,13 +26,11 @@ static void mtd_notify_add(struct mtd_info* mtd)
 	if (!mtd)
 		return;
 
-	device_create_drvdata(mtd_class, NULL,
-			      MKDEV(MTD_CHAR_MAJOR, mtd->index*2),
-			      NULL, "mtd%d", mtd->index);
+	device_create(mtd_class, NULL, MKDEV(MTD_CHAR_MAJOR, mtd->index*2),
+		      NULL, "mtd%d", mtd->index);
 
-	device_create_drvdata(mtd_class, NULL,
-			      MKDEV(MTD_CHAR_MAJOR, mtd->index*2+1),
-			      NULL, "mtd%dro", mtd->index);
+	device_create(mtd_class, NULL, MKDEV(MTD_CHAR_MAJOR, mtd->index*2+1),
+		      NULL, "mtd%dro", mtd->index);
 }
 
 static void mtd_notify_remove(struct mtd_info* mtd)

commit b67c5f87c13f398ec3f4d6b455cb0bbeda8d7ac0
Author: Zev Weiss <zevweiss@gmail.com>
Date:   Mon Sep 1 05:02:12 2008 -0700

    [MTD] mtdchar.c: Fix regression in MEMGETREGIONINFO ioctl()
    
    The MEMGETREGIONINFO ioctl() in mtdchar.c was clobbering user memory by
    overwriting more than intended, due the size of struct mtd_erase_region_info
    changing in commit 0ecbc81adfcb9f15f86b05ff576b342ce81bbef8 ('Support
    for auto locking flash on power up').
    
    Fix avoids this by copying struct members one by one with put_user(), as there
    is no longer a convenient struct to use the size of as the length argument to
    copy_to_user().
    
    Signed-off-by: Zev Weiss <zevweiss@gmail.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
index d2f331876e4c..e00d424e6575 100644
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -410,16 +410,20 @@ static int mtd_ioctl(struct inode *inode, struct file *file,
 
 	case MEMGETREGIONINFO:
 	{
-		struct region_info_user ur;
+		uint32_t ur_idx;
+		struct mtd_erase_region_info *kr;
+		struct region_info_user *ur = (struct region_info_user *) argp;
 
-		if (copy_from_user(&ur, argp, sizeof(struct region_info_user)))
+		if (get_user(ur_idx, &(ur->regionindex)))
 			return -EFAULT;
 
-		if (ur.regionindex >= mtd->numeraseregions)
-			return -EINVAL;
-		if (copy_to_user(argp, &(mtd->eraseregions[ur.regionindex]),
-				sizeof(struct mtd_erase_region_info)))
+		kr = &(mtd->eraseregions[ur_idx]);
+
+		if (put_user(kr->offset, &(ur->offset))
+		    || put_user(kr->erasesize, &(ur->erasesize))
+		    || put_user(kr->numblocks, &(ur->numblocks)))
 			return -EFAULT;
+
 		break;
 	}
 

commit 34a82443b79dcda4304b229d555586296da40c16
Author: David Brownell <dbrownell@users.sourceforge.net>
Date:   Wed Jul 30 12:35:05 2008 -0700

    [MTD] dataflash OTP support
    
    Now that we can tell when we have one of the newer DataFlash chips,
    optionally expose the 128 bytes of OTP memory they provide.  Tested
    on at45db642 revision B and D chips.
    
    Switch mtdchar over to a generic HAVE_MTD_OTP flag instead of adding
    another #ifdef for each type of chip whose driver has OTP support.
    
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Cc: Bryan Wu <cooloney@kernel.org>
    Cc: Michael Hennerich <michael.hennerich@analog.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
index d2f331876e4c..13cc67ad272a 100644
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -350,7 +350,7 @@ static void mtdchar_erase_callback (struct erase_info *instr)
 	wake_up((wait_queue_head_t *)instr->priv);
 }
 
-#if defined(CONFIG_MTD_OTP) || defined(CONFIG_MTD_ONENAND_OTP)
+#ifdef CONFIG_HAVE_MTD_OTP
 static int otp_select_filemode(struct mtd_file_info *mfi, int mode)
 {
 	struct mtd_info *mtd = mfi->mtd;
@@ -663,7 +663,7 @@ static int mtd_ioctl(struct inode *inode, struct file *file,
 		break;
 	}
 
-#if defined(CONFIG_MTD_OTP) || defined(CONFIG_MTD_ONENAND_OTP)
+#ifdef CONFIG_HAVE_MTD_OTP
 	case OTPSELECT:
 	{
 		int mode;

commit ff877ea80efa2015b6263766f78ee42c2a1b32f9
Merge: 30821fee4f0c d37e6bf68fc1
Author: David Woodhouse <David.Woodhouse@intel.com>
Date:   Fri Jul 25 10:40:14 2008 -0400

    Merge branch 'linux-next' of git://git.infradead.org/~dedekind/ubi-2.6

commit daea34bc6f67cf3872d1b52ba5ccf249f3ceb176
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Wed May 21 12:52:33 2008 -0700

    device create: mtd: convert device_create to device_create_drvdata
    
    device_create() is race-prone, so use the race-free
    device_create_drvdata() instead as device_create() is going away.
    
    Cc: David Woodhouse <dwmw2@infradead.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
index 129d429cd2da..aef9f4b687c9 100644
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -28,10 +28,13 @@ static void mtd_notify_add(struct mtd_info* mtd)
 	if (!mtd)
 		return;
 
-	device_create(mtd_class, NULL, MKDEV(MTD_CHAR_MAJOR, mtd->index*2), "mtd%d", mtd->index);
+	device_create_drvdata(mtd_class, NULL,
+			      MKDEV(MTD_CHAR_MAJOR, mtd->index*2),
+			      NULL, "mtd%d", mtd->index);
 
-	device_create(mtd_class, NULL,
-		      MKDEV(MTD_CHAR_MAJOR, mtd->index*2+1), "mtd%dro", mtd->index);
+	device_create_drvdata(mtd_class, NULL,
+			      MKDEV(MTD_CHAR_MAJOR, mtd->index*2+1),
+			      NULL, "mtd%dro", mtd->index);
 }
 
 static void mtd_notify_remove(struct mtd_info* mtd)

commit 175428b2b3eeacf90dcc171d5915d6b4dc86e917
Author: Harvey Harrison <harvey.harrison@gmail.com>
Date:   Thu Jul 3 23:40:14 2008 -0700

    [MTD] mtdchar.c remove shadowed variable warnings
    
    Use einfo, oinfo for the inner erase_info and otp_info structs used in
    individual case statements.
    
    drivers/mtd/mtdchar.c:582:26: warning: symbol 'info' shadows an earlier one
    drivers/mtd/mtdchar.c:380:23: originally declared here
    drivers/mtd/mtdchar.c:596:26: warning: symbol 'info' shadows an earlier one
    drivers/mtd/mtdchar.c:380:23: originally declared here
    drivers/mtd/mtdchar.c:704:19: warning: symbol 'info' shadows an earlier one
    drivers/mtd/mtdchar.c:380:23: originally declared here
    
    Signed-off-by: Harvey Harrison <harvey.harrison@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
index 5fc2c4216c03..f5061fe72e4c 100644
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -577,29 +577,29 @@ static int mtd_ioctl(struct inode *inode, struct file *file,
 
 	case MEMLOCK:
 	{
-		struct erase_info_user info;
+		struct erase_info_user einfo;
 
-		if (copy_from_user(&info, argp, sizeof(info)))
+		if (copy_from_user(&einfo, argp, sizeof(einfo)))
 			return -EFAULT;
 
 		if (!mtd->lock)
 			ret = -EOPNOTSUPP;
 		else
-			ret = mtd->lock(mtd, info.start, info.length);
+			ret = mtd->lock(mtd, einfo.start, einfo.length);
 		break;
 	}
 
 	case MEMUNLOCK:
 	{
-		struct erase_info_user info;
+		struct erase_info_user einfo;
 
-		if (copy_from_user(&info, argp, sizeof(info)))
+		if (copy_from_user(&einfo, argp, sizeof(einfo)))
 			return -EFAULT;
 
 		if (!mtd->unlock)
 			ret = -EOPNOTSUPP;
 		else
-			ret = mtd->unlock(mtd, info.start, info.length);
+			ret = mtd->unlock(mtd, einfo.start, einfo.length);
 		break;
 	}
 
@@ -699,15 +699,15 @@ static int mtd_ioctl(struct inode *inode, struct file *file,
 
 	case OTPLOCK:
 	{
-		struct otp_info info;
+		struct otp_info oinfo;
 
 		if (mfi->mode != MTD_MODE_OTP_USER)
 			return -EINVAL;
-		if (copy_from_user(&info, argp, sizeof(info)))
+		if (copy_from_user(&oinfo, argp, sizeof(oinfo)))
 			return -EFAULT;
 		if (!mtd->lock_user_prot_reg)
 			return -EOPNOTSUPP;
-		ret = mtd->lock_user_prot_reg(mtd, info.start, info.length);
+		ret = mtd->lock_user_prot_reg(mtd, oinfo.start, oinfo.length);
 		break;
 	}
 #endif

commit 5f6928378b165c4b0d57a711e1c1eb925ad33846
Author: Harvey Harrison <harvey.harrison@gmail.com>
Date:   Thu Jul 3 23:40:13 2008 -0700

    [MTD] mtdchar.c silence sparse warning
    
    The copy_to_user was casting away the address space to get the offset of
    the length member.  Use offsetof() instead and add it to the void __user
    *argp.
    
    drivers/mtd/mtdchar.c:527:23: warning: cast removes address space of expression
    drivers/mtd/mtdchar.c:527:23: warning: incorrect type in argument 1 (different address spaces)
    drivers/mtd/mtdchar.c:527:23:    expected void [noderef] <asn:1>*to
    drivers/mtd/mtdchar.c:527:23:    got unsigned int *<noident>
    
    Signed-off-by: Harvey Harrison <harvey.harrison@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
index 4b3156f9b36f..5fc2c4216c03 100644
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -479,6 +479,7 @@ static int mtd_ioctl(struct inode *inode, struct file *file,
 	{
 		struct mtd_oob_buf buf;
 		struct mtd_oob_ops ops;
+		struct mtd_oob_buf __user *user_buf = argp;
 	        uint32_t retlen;
 
 		if(!(file->f_mode & 2))
@@ -522,8 +523,7 @@ static int mtd_ioctl(struct inode *inode, struct file *file,
 		if (ops.oobretlen > 0xFFFFFFFFU)
 			ret = -EOVERFLOW;
 		retlen = ops.oobretlen;
-		if (copy_to_user(&((struct mtd_oob_buf *)argp)->length,
-				 &retlen, sizeof(buf.length)))
+		if (copy_to_user(&user_buf->length, &retlen, sizeof(buf.length)))
 			ret = -EFAULT;
 
 		kfree(ops.oobbuf);

commit 6071239ef1947914892601e36785c7b1cf8b7dd4
Author: Jonathan Corbet <corbet@lwn.net>
Date:   Thu May 15 10:10:37 2008 -0600

    mtdchar: cdev lock_kernel() pushdown
    
    Signed-off-by: Jonathan Corbet <corbet@lwn.net>

diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
index 5d3ac512ce16..129d429cd2da 100644
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -14,6 +14,7 @@
 #include <linux/module.h>
 #include <linux/slab.h>
 #include <linux/sched.h>
+#include <linux/smp_lock.h>
 
 #include <linux/mtd/mtd.h>
 #include <linux/mtd/compatmac.h>
@@ -86,6 +87,7 @@ static int mtd_open(struct inode *inode, struct file *file)
 {
 	int minor = iminor(inode);
 	int devnum = minor >> 1;
+	int ret = 0;
 	struct mtd_info *mtd;
 	struct mtd_file_info *mfi;
 
@@ -98,31 +100,39 @@ static int mtd_open(struct inode *inode, struct file *file)
 	if ((file->f_mode & 2) && (minor & 1))
 		return -EACCES;
 
+	lock_kernel();
 	mtd = get_mtd_device(NULL, devnum);
 
-	if (IS_ERR(mtd))
-		return PTR_ERR(mtd);
+	if (IS_ERR(mtd)) {
+		ret = PTR_ERR(mtd);
+		goto out;
+	}
 
 	if (MTD_ABSENT == mtd->type) {
 		put_mtd_device(mtd);
-		return -ENODEV;
+		ret = -ENODEV;
+		goto out;
 	}
 
 	/* You can't open it RW if it's not a writeable device */
 	if ((file->f_mode & 2) && !(mtd->flags & MTD_WRITEABLE)) {
 		put_mtd_device(mtd);
-		return -EACCES;
+		ret = -EACCES;
+		goto out;
 	}
 
 	mfi = kzalloc(sizeof(*mfi), GFP_KERNEL);
 	if (!mfi) {
 		put_mtd_device(mtd);
-		return -ENOMEM;
+		ret = -ENOMEM;
+		goto out;
 	}
 	mfi->mtd = mtd;
 	file->private_data = mfi;
 
-	return 0;
+out:
+	unlock_kernel();
+	return ret;
 } /* mtd_open */
 
 /*====================================================================*/

commit 59018b6d2acabb114ab58637e6ab95ba424a89d0
Author: Adrian Bunk <bunk@kernel.org>
Date:   Tue May 20 01:03:52 2008 +0300

    MTD/JFFS2: remove CVS keywords
    
    Once upon a time, the MTD repository was using CVS.
    
    This patch therefore removes all usages of the no longer updated CVS
    keywords from the MTD code.
    
    This also includes code that printed them to the user.
    
    Signed-off-by: Adrian Bunk <bunk@kernel.org>
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>

diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
index 5d3ac512ce16..4b3156f9b36f 100644
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -1,6 +1,4 @@
 /*
- * $Id: mtdchar.c,v 1.76 2005/11/07 11:14:20 gleixner Exp $
- *
  * Character-device access to raw MTD devices.
  *
  */

commit c1f3ee120bb61045b1c0a3ead620d1d65af47130
Merge: e619a75ff620 9135f1901ee6
Author: David Woodhouse <dwmw2@infradead.org>
Date:   Sun Feb 3 18:29:41 2008 +1100

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux-2.6.git

commit a98894ab02bc9a3e2dc8cccab55d7ed200d3b05f
Author: Tony Jones <tonyj@suse.de>
Date:   Tue Sep 25 02:03:03 2007 +0200

    mtd: Convert from class_device to device for MTD/mtdchar
    
    struct class_device is going away, this converts the code to use struct
    device instead.
    
    Signed-off-by: Tony Jones <tonyj@suse.de>
    Cc: David Woodhouse <dwmw2@infradead.org>
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
index 22ed96c4b7bd..a0cee86464ca 100644
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -27,12 +27,10 @@ static void mtd_notify_add(struct mtd_info* mtd)
 	if (!mtd)
 		return;
 
-	class_device_create(mtd_class, NULL, MKDEV(MTD_CHAR_MAJOR, mtd->index*2),
-			    NULL, "mtd%d", mtd->index);
+	device_create(mtd_class, NULL, MKDEV(MTD_CHAR_MAJOR, mtd->index*2), "mtd%d", mtd->index);
 
-	class_device_create(mtd_class, NULL,
-			    MKDEV(MTD_CHAR_MAJOR, mtd->index*2+1),
-			    NULL, "mtd%dro", mtd->index);
+	device_create(mtd_class, NULL,
+		      MKDEV(MTD_CHAR_MAJOR, mtd->index*2+1), "mtd%dro", mtd->index);
 }
 
 static void mtd_notify_remove(struct mtd_info* mtd)
@@ -40,8 +38,8 @@ static void mtd_notify_remove(struct mtd_info* mtd)
 	if (!mtd)
 		return;
 
-	class_device_destroy(mtd_class, MKDEV(MTD_CHAR_MAJOR, mtd->index*2));
-	class_device_destroy(mtd_class, MKDEV(MTD_CHAR_MAJOR, mtd->index*2+1));
+	device_destroy(mtd_class, MKDEV(MTD_CHAR_MAJOR, mtd->index*2));
+	device_destroy(mtd_class, MKDEV(MTD_CHAR_MAJOR, mtd->index*2+1));
 }
 
 static struct mtd_notifier notifier = {

commit e9d8d48253c50106d85b288939e5227083360863
Author: David Scidmore <dscidmore@xes-inc.com>
Date:   Tue Dec 11 17:44:30 2007 -0600

    [MTD] mtdchar.c: ioctl always returns 0 as size written for ppc64
    
    "include/linux/mtd/mtd.h" declares "mtd_oob_ops.retlen" as size_t, which
    is 64 bits on targets with a 64 bit addressing. The MEMWRITEOOB ioctl
    calls copy_to_user() to write it back to "mtd_oob_buf.length", which is
    declared in "include/linux/mtd-abi.h" as uint32_t. Since powerpc is a
    big endian architecture, this only copies the upper 32 bits of the
    address, which is always 0.
    
    Signed-off-by: David Scidmore <dscidmore@xes-inc.com>
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>

diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
index 22ed96c4b7bd..b42553cd9af5 100644
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -483,6 +483,7 @@ static int mtd_ioctl(struct inode *inode, struct file *file,
 	{
 		struct mtd_oob_buf buf;
 		struct mtd_oob_ops ops;
+	        uint32_t retlen;
 
 		if(!(file->f_mode & 2))
 			return -EPERM;
@@ -522,8 +523,11 @@ static int mtd_ioctl(struct inode *inode, struct file *file,
 		buf.start &= ~(mtd->oobsize - 1);
 		ret = mtd->write_oob(mtd, buf.start, &ops);
 
-		if (copy_to_user(argp + sizeof(uint32_t), &ops.oobretlen,
-				 sizeof(uint32_t)))
+		if (ops.oobretlen > 0xFFFFFFFFU)
+			ret = -EOVERFLOW;
+		retlen = ops.oobretlen;
+		if (copy_to_user(&((struct mtd_oob_buf *)argp)->length,
+				 &retlen, sizeof(buf.length)))
 			ret = -EFAULT;
 
 		kfree(ops.oobbuf);

commit ac0c955d5048c2c580fa7166a89133f0fd76c125
Merge: 68d09b1b6780 b377fd3982ad
Author: David Woodhouse <dwmw2@infradead.org>
Date:   Thu Aug 23 10:43:14 2007 +0100

    Merge branch 'master' of git://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux-2.6

commit 0c1eafdb063a3701eff24d21eb245e3b1d4ac7df
Author: Andrew Morton <akpm@linux-foundation.org>
Date:   Fri Aug 10 13:01:06 2007 -0700

    mtdchar build fix
    
    sh:
    
    drivers/mtd/mtdchar.c: In function `mtd_mmap':
    drivers/mtd/mtdchar.c:817: error: dereferencing pointer to incomplete type
    drivers/mtd/mtdchar.c:817: error: `VM_SHARED' undeclared (first use in this function)
    drivers/mtd/mtdchar.c:817: error: (Each undeclared identifier is reported only once
    
    Cc: David Woodhouse <dwmw2@infradead.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
index 8c86b802f212..d091b2430b48 100644
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -7,6 +7,7 @@
 
 #include <linux/device.h>
 #include <linux/fs.h>
+#include <linux/mm.h>
 #include <linux/err.h>
 #include <linux/init.h>
 #include <linux/kernel.h>

commit 7eafaed55f4b8599cfe55449a6ed88d3693954de
Author: Joakim Tjernlund <Joakim.Tjernlund@transmode.se>
Date:   Wed Jun 27 00:56:40 2007 +0200

    [MTD] Only call mtd->sync() method in mtdchar close if opened for write.
    
    Signed-off-by: Joakim Tjernlund <Joakim.Tjernlund@transmode.se>
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>

diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
index 8c86b802f212..942c88ec5b6a 100644
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -135,7 +135,8 @@ static int mtd_close(struct inode *inode, struct file *file)
 
 	DEBUG(MTD_DEBUG_LEVEL0, "MTD_close\n");
 
-	if (mtd->sync)
+	/* Only sync if opened RW */
+	if ((file->f_mode & 2) && mtd->sync)
 		mtd->sync(mtd);
 
 	put_mtd_device(mtd);

commit 408b483d9cc2d839ecbc9134958c42814865081c
Author: Thomas Gleixner <tglx@inhell4.(none)>
Date:   Fri Apr 13 19:50:48 2007 +0200

    [MTD] Fix length comparison in MEMREADOOB
    
    The ops.len member is not initialized, because it is unused for this
    operation. The length check needs to use ops.ooblen instead
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>

diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
index 1592eac64e57..8c86b802f212 100644
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -553,7 +553,7 @@ static int mtd_ioctl(struct inode *inode, struct file *file,
 		ops.datbuf = NULL;
 		ops.mode = MTD_OOB_PLACE;
 
-		if (ops.ooboffs && ops.len > (mtd->oobsize - ops.ooboffs))
+		if (ops.ooboffs && ops.ooblen > (mtd->oobsize - ops.ooboffs))
 			return -EINVAL;
 
 		ops.oobbuf = kmalloc(buf.length, GFP_KERNEL);

commit 4935361766cc73949fe032cd157d314f288922ba
Merge: 2874b391bd78 4f6599238111
Author: Linus Torvalds <torvalds@woody.linux-foundation.org>
Date:   Mon Feb 19 13:34:11 2007 -0800

    Merge git://git.infradead.org/mtd-2.6
    
    * git://git.infradead.org/mtd-2.6: (49 commits)
      [MTD] [NAND] S3C2412 fix hw ecc
      [MTD] [NAND] Work around false compiler warning in CAFÃ driver
      [JFFS2] printk warning fixes
      [MTD] [MAPS] ichxrom warning fix
      [MTD] [MAPS] amd76xrom warning fix
      [MTD] [MAPS] esb2rom warning fixes
      [MTD] [MAPS] ck804xrom warning fix
      [MTD] [MAPS] netsc520 warning fix
      [MTD] [MAPS] sc520cdp warning fix
      [MTD] [ONENAND] onenand_base warning fix
      [MTD] [NAND] eXcite nand flash driver
      [MTD] Improve heuristic for detecting wrong-endian RedBoot partition table
      [MTD] Fix RedBoot partition parsing regression harder.
      [MTD] [NAND] S3C2410: Hardware ECC correction code
      [JFFS2] Use MTD_OOB_AUTO to automatically place cleanmarker on NAND
      [MTD] Clarify OOB-operation interface comments
      [MTD] remove unused ecctype,eccsize fields from struct mtd_info
      [MTD] [NOR] Intel: remove ugly PROGREGION macros
      [MTD] [NOR] STAA: use writesize instead off eccsize to represent ECC block
      [MTD] OneNAND: Invalidate bufferRAM after erase
      ...

commit d54b1fdb1d9f82e375a299e22bd366aad52d4c34
Author: Arjan van de Ven <arjan@linux.intel.com>
Date:   Mon Feb 12 00:55:34 2007 -0800

    [PATCH] mark struct file_operations const 5
    
    Many struct file_operations in the kernel can be "const".  Marking them const
    moves these to the .rodata section, which avoids false sharing with potential
    dirty data.  In addition it'll catch accidental writes at compile time to
    these shared resources.
    
    Signed-off-by: Arjan van de Ven <arjan@linux.intel.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
index 3013d0883b97..61a994ea8af1 100644
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -759,7 +759,7 @@ static int mtd_ioctl(struct inode *inode, struct file *file,
 	return ret;
 } /* memory_ioctl */
 
-static struct file_operations mtd_fops = {
+static const struct file_operations mtd_fops = {
 	.owner		= THIS_MODULE,
 	.llseek		= mtd_lseek,
 	.read		= mtd_read,

commit 64f60710568db5cec1a76c1d1e261b239f9ef809
Author: Artem Bityutskiy <Artem.Bityutskiy@nokia.com>
Date:   Tue Jan 30 10:50:43 2007 +0200

    [MTD] remove unused ecctype,eccsize fields from struct mtd_info
    
    Remove unused and broken mtd->ecctype and mtd->eccsize fields
    from struct mtd_info. Do not remove them from userspace API
    data structures (don't want to breake userspace) but mark them
    as obsolete by a comment. Any userspace program which uses them
    should be half-broken anyway, so this is more about saving
    data structure size.
    
    Signed-off-by: Artem Bityutskiy <Artem.Bityutskiy@nokia.com>
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>

diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
index 3013d0883b97..3731523ec11f 100644
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -419,8 +419,9 @@ static int mtd_ioctl(struct inode *inode, struct file *file,
 		info.erasesize	= mtd->erasesize;
 		info.writesize	= mtd->writesize;
 		info.oobsize	= mtd->oobsize;
-		info.ecctype	= mtd->ecctype;
-		info.eccsize	= mtd->eccsize;
+		/* The below fields are obsolete */
+		info.ecctype	= -1;
+		info.eccsize	= 0;
 		if (copy_to_user(argp, &info, sizeof(struct mtd_info_user)))
 			return -EFAULT;
 		break;

commit 9c74034f8fc5d93fbe5656421cbbdc4c76ddda28
Author: Artem Bityutskiy <dedekind@infradead.org>
Date:   Wed Oct 11 14:52:47 2006 +0300

    [MTD] return error code from get_mtd_device()
    
    get_mtd_device() returns NULL in case of any failure. Teach it to return an
    error code instead. Fix all users as well.
    
    Signed-off-by: Artem Bityutskiy <dedekind@infradead.org>

diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
index 7c4adc641328..3013d0883b97 100644
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -7,6 +7,7 @@
 
 #include <linux/device.h>
 #include <linux/fs.h>
+#include <linux/err.h>
 #include <linux/init.h>
 #include <linux/kernel.h>
 #include <linux/module.h>
@@ -100,8 +101,8 @@ static int mtd_open(struct inode *inode, struct file *file)
 
 	mtd = get_mtd_device(NULL, devnum);
 
-	if (!mtd)
-		return -ENODEV;
+	if (IS_ERR(mtd))
+		return PTR_ERR(mtd);
 
 	if (MTD_ABSENT == mtd->type) {
 		put_mtd_device(mtd);

commit 95b93a0cd46682c6d9e8eea803fda510cb6b863a
Author: Burman Yan <yan_952@hotmail.com>
Date:   Wed Nov 15 21:10:29 2006 +0200

    [MTD] replace kmalloc+memset with kzalloc
    
    Signed-off-by: Yan Burman <yan_952@hotmail.com>
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>

diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
index 07618f51d969..7c4adc641328 100644
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -431,7 +431,7 @@ static int mtd_ioctl(struct inode *inode, struct file *file,
 		if(!(file->f_mode & 2))
 			return -EPERM;
 
-		erase=kmalloc(sizeof(struct erase_info),GFP_KERNEL);
+		erase=kzalloc(sizeof(struct erase_info),GFP_KERNEL);
 		if (!erase)
 			ret = -ENOMEM;
 		else {
@@ -440,7 +440,6 @@ static int mtd_ioctl(struct inode *inode, struct file *file,
 
 			init_waitqueue_head(&waitq);
 
-			memset (erase,0,sizeof(struct erase_info));
 			if (copy_from_user(&erase->addr, argp,
 				    sizeof(struct erase_info_user))) {
 				kfree(erase);

commit 7014568bad55c20b7ee4f439d78c9e875912d51f
Author: Vitaly Wool <vwool@ru.mvista.com>
Date:   Fri Nov 3 18:20:38 2006 +0300

    [MTD] [NAND] remove len/ooblen confusion.
    
    As was discussed between Ricard WanderlÃ¶f, David Woodhouse, Artem
    Bityutskiy and me, the current API for reading/writing OOB is confusing.
    
    The thing that introduces confusion is the need to specify ops.len
    together with ops.ooblen for reads/writes that concern only OOB not data
    area. So, ops.len is overloaded: when ops.datbuf != NULL it serves to
    specify the length of the data read, and when ops.datbuf == NULL, it
    serves to specify the full OOB read length.
    
    The patch inlined below is the slightly updated version of the previous
    patch serving the same purpose, but with the new Artem's comments taken
    into account.
    
    Artem, BTW, thanks a lot for your valuable input!
    
    Signed-off-by: Vitaly Wool <vwool@ru.mvista.com>
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>

diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
index 866c8e0d57e4..07618f51d969 100644
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -499,13 +499,12 @@ static int mtd_ioctl(struct inode *inode, struct file *file,
 		if (ret)
 			return ret;
 
-		ops.len = buf.length;
 		ops.ooblen = buf.length;
 		ops.ooboffs = buf.start & (mtd->oobsize - 1);
 		ops.datbuf = NULL;
 		ops.mode = MTD_OOB_PLACE;
 
-		if (ops.ooboffs && ops.len > (mtd->oobsize - ops.ooboffs))
+		if (ops.ooboffs && ops.ooblen > (mtd->oobsize - ops.ooboffs))
 			return -EINVAL;
 
 		ops.oobbuf = kmalloc(buf.length, GFP_KERNEL);
@@ -520,7 +519,7 @@ static int mtd_ioctl(struct inode *inode, struct file *file,
 		buf.start &= ~(mtd->oobsize - 1);
 		ret = mtd->write_oob(mtd, buf.start, &ops);
 
-		if (copy_to_user(argp + sizeof(uint32_t), &ops.retlen,
+		if (copy_to_user(argp + sizeof(uint32_t), &ops.oobretlen,
 				 sizeof(uint32_t)))
 			ret = -EFAULT;
 
@@ -548,7 +547,6 @@ static int mtd_ioctl(struct inode *inode, struct file *file,
 		if (ret)
 			return ret;
 
-		ops.len = buf.length;
 		ops.ooblen = buf.length;
 		ops.ooboffs = buf.start & (mtd->oobsize - 1);
 		ops.datbuf = NULL;
@@ -564,10 +562,10 @@ static int mtd_ioctl(struct inode *inode, struct file *file,
 		buf.start &= ~(mtd->oobsize - 1);
 		ret = mtd->read_oob(mtd, buf.start, &ops);
 
-		if (put_user(ops.retlen, (uint32_t __user *)argp))
+		if (put_user(ops.oobretlen, (uint32_t __user *)argp))
 			ret = -EFAULT;
-		else if (ops.retlen && copy_to_user(buf.ptr, ops.oobbuf,
-						    ops.retlen))
+		else if (ops.oobretlen && copy_to_user(buf.ptr, ops.oobbuf,
+						    ops.oobretlen))
 			ret = -EFAULT;
 
 		kfree(ops.oobbuf);

commit d25ade71ef80e6312b3e0b53583db518ebb11798
Author: Ricard WanderlÃ¶f <ricard.wanderlof@axis.com>
Date:   Tue Oct 17 17:27:11 2006 +0200

    [MTD] mtdchar: Fix MEMGETOOBSEL and ECCGETLAYOUT ioctls
    
    1. The ECCGETLAYOUT ioctl copy_to_user() call has a superfluous '&'
    causing the resulting information to be garbage rather than the intended
    mtd->ecclayout.
    
    2. The MEMGETOOBSEL misses copying mtd->ecclayout->eccbytes so the
    resulting field of the returned structure contains garbage.
    
    Signed-off-by: Ricard WanderlÃ¶f <ricardw@axis.com>
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>

diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
index 5b6acfcb2b88..866c8e0d57e4 100644
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -616,6 +616,7 @@ static int mtd_ioctl(struct inode *inode, struct file *file,
 		memcpy(&oi.eccpos, mtd->ecclayout->eccpos, sizeof(oi.eccpos));
 		memcpy(&oi.oobfree, mtd->ecclayout->oobfree,
 		       sizeof(oi.oobfree));
+		oi.eccbytes = mtd->ecclayout->eccbytes;
 
 		if (copy_to_user(argp, &oi, sizeof(struct nand_oobinfo)))
 			return -EFAULT;
@@ -715,7 +716,7 @@ static int mtd_ioctl(struct inode *inode, struct file *file,
 		if (!mtd->ecclayout)
 			return -EOPNOTSUPP;
 
-		if (copy_to_user(argp, &mtd->ecclayout,
+		if (copy_to_user(argp, mtd->ecclayout,
 				 sizeof(struct nand_ecclayout)))
 			return -EFAULT;
 		break;

commit ea59830db01b6b3d6bda9f84e3d272a346115e8e
Author: Josef 'Jeff' Sipek <jeffpc@josefsipek.net>
Date:   Sat Sep 16 21:09:29 2006 -0400

    [MTD] Use SEEK_{SET,CUR,END} instead of hardcoded values in mtdchar lseek()
    
    Signed-off-by: Josef 'Jeff' Sipek <jeffpc@josefsipek.net>
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>

diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
index fb8b4f7e48d3..5b6acfcb2b88 100644
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -62,15 +62,12 @@ static loff_t mtd_lseek (struct file *file, loff_t offset, int orig)
 	struct mtd_info *mtd = mfi->mtd;
 
 	switch (orig) {
-	case 0:
-		/* SEEK_SET */
+	case SEEK_SET:
 		break;
-	case 1:
-		/* SEEK_CUR */
+	case SEEK_CUR:
 		offset += file->f_pos;
 		break;
-	case 2:
-		/* SEEK_END */
+	case SEEK_END:
 		offset += mtd->size;
 		break;
 	default:

commit 6ab3d5624e172c553004ecc862bfeac16d9d68b7
Author: JÃ¶rn Engel <joern@wohnheim.fh-wedel.de>
Date:   Fri Jun 30 19:25:36 2006 +0200

    Remove obsolete #include <linux/config.h>
    
    Signed-off-by: JÃ¶rn Engel <joern@wohnheim.fh-wedel.de>
    Signed-off-by: Adrian Bunk <bunk@stusta.de>

diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
index 9a4b59d92525..fb8b4f7e48d3 100644
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -5,7 +5,6 @@
  *
  */
 
-#include <linux/config.h>
 #include <linux/device.h>
 #include <linux/fs.h>
 #include <linux/init.h>

commit 1887f517e3cdf5f1e9c0e4daaa864450415a8f61
Author: Herbert Valerio Riedel <hvr@gnu.org>
Date:   Sat Jun 24 00:03:36 2006 +0200

    [MTD] CORE mtdchar.c: fix off-by-one error in lseek()
    
    Allow lseek(mtdchar_fd, 0, SEEK_END) to succeed, which currently fails
    with EINVAL.
    
    lseek(fd, 0, SEEK_END) should result into the same fileposition as
    lseek(fd, 0, SEEK_SET) + read(fd, buf, length(fd))
    
    Furthermore, lseek(fd, 0, SEEK_CUR) should return the current file position,
    which in case of an encountered EOF should not result in EINVAL
    
    Signed-off-by: Herbert Valerio Riedel <hvr@gnu.org>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>

diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
index aa18d45b264b..9a4b59d92525 100644
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -78,7 +78,7 @@ static loff_t mtd_lseek (struct file *file, loff_t offset, int orig)
 		return -EINVAL;
 	}
 
-	if (offset >= 0 && offset < mtd->size)
+	if (offset >= 0 && offset <= mtd->size)
 		return file->f_pos = offset;
 
 	return -EINVAL;

commit 7bc3312bef4d6f220812500c0de7868fb7625a41
Author: Thomas Gleixner <tglx@cruncher.tec.linutronix.de>
Date:   Tue Jun 20 20:05:05 2006 +0200

    [MTD] NAND: Fix breakage all over the place
    
    Following problems are addressed:
    
    - wrong status caused early break out of nand_wait()
    - removed the bogus status check in nand_wait() which
      is a relict of the abandoned support for interrupted
      erase.
    - status check moved to the correct place in read_oob
    - oob support for syndrom based ecc with strange layouts
    - use given offset in the AUTOOOB based oob operations
    
    Partially based on a patch from Vitaly Vool <vwool@ru.mvista.com>
    Thanks to Savin Zlobec <savin@epico.si> for tracking down the
    status problem.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
index 5dd0b8d72c8b..aa18d45b264b 100644
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -504,12 +504,12 @@ static int mtd_ioctl(struct inode *inode, struct file *file,
 			return ret;
 
 		ops.len = buf.length;
-		ops.ooblen = mtd->oobsize;
+		ops.ooblen = buf.length;
 		ops.ooboffs = buf.start & (mtd->oobsize - 1);
 		ops.datbuf = NULL;
 		ops.mode = MTD_OOB_PLACE;
 
-		if (ops.ooboffs && ops.len > (ops.ooblen - ops.ooboffs))
+		if (ops.ooboffs && ops.len > (mtd->oobsize - ops.ooboffs))
 			return -EINVAL;
 
 		ops.oobbuf = kmalloc(buf.length, GFP_KERNEL);
@@ -553,12 +553,12 @@ static int mtd_ioctl(struct inode *inode, struct file *file,
 			return ret;
 
 		ops.len = buf.length;
-		ops.ooblen = mtd->oobsize;
+		ops.ooblen = buf.length;
 		ops.ooboffs = buf.start & (mtd->oobsize - 1);
 		ops.datbuf = NULL;
 		ops.mode = MTD_OOB_PLACE;
 
-		if (ops.ooboffs && ops.len > (ops.ooblen - ops.ooboffs))
+		if (ops.ooboffs && ops.len > (mtd->oobsize - ops.ooboffs))
 			return -EINVAL;
 
 		ops.oobbuf = kmalloc(buf.length, GFP_KERNEL);

commit 73c619ea0e49c9306afa7ea53c3362fbc56ffd70
Author: Joern Engel <joern@wh.fh-wedel.de>
Date:   Tue May 30 14:25:35 2006 +0200

    [MTD] Disconnect struct mtd_info from ABI
    
    mtdchar.c direcly copied part of struct mtd_info to userspace, thereby
    implicitly making it part of the ABI.  With this patch, struct
    mtd_info is independent of the ABI and can have its fields removed,
    reordered, etc.
    
    Signed-off-by: Joern Engel <joern@wh.fh-wedel.de>

diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
index fdc535b22e39..5dd0b8d72c8b 100644
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -380,6 +380,7 @@ static int mtd_ioctl(struct inode *inode, struct file *file,
 	void __user *argp = (void __user *)arg;
 	int ret = 0;
 	u_long size;
+	struct mtd_info_user info;
 
 	DEBUG(MTD_DEBUG_LEVEL0, "MTD_ioctl\n");
 
@@ -415,7 +416,15 @@ static int mtd_ioctl(struct inode *inode, struct file *file,
 	}
 
 	case MEMGETINFO:
-		if (copy_to_user(argp, mtd, sizeof(struct mtd_info_user)))
+		info.type	= mtd->type;
+		info.flags	= mtd->flags;
+		info.size	= mtd->size;
+		info.erasesize	= mtd->erasesize;
+		info.writesize	= mtd->writesize;
+		info.oobsize	= mtd->oobsize;
+		info.ecctype	= mtd->ecctype;
+		info.eccsize	= mtd->eccsize;
+		if (copy_to_user(argp, &info, sizeof(struct mtd_info_user)))
 			return -EFAULT;
 		break;
 

commit f1a28c02843efcfcc41982149880bac3ac180234
Author: Thomas Gleixner <tglx@cruncher.tec.linutronix.de>
Date:   Tue May 30 00:37:34 2006 +0200

    [MTD] NAND Expose the new raw mode function and status info to userspace
    
    The raw read/write access to NAND (without ECC) has been changed in the
    NAND rework. Expose the new way - setting the file mode via ioctl - to
    userspace. Also allow to read out the ecc statistics information so userspace
    tools can see that bitflips happened and whether errors where correctable
    or not. Also expose the number of bad blocks for the partition, so nandwrite
    can check if the data fits into the parition before writing to it.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
index a48210d58b92..fdc535b22e39 100644
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -49,24 +49,18 @@ static struct mtd_notifier notifier = {
 };
 
 /*
- * We use file->private_data to store a pointer to the MTDdevice.
- * Since alighment is at least 32 bits, we have 2 bits free for OTP
- * modes as well.
+ * Data structure to hold the pointer to the mtd device as well
+ * as mode information ofr various use cases.
  */
-
-#define TO_MTD(file) (struct mtd_info *)((long)((file)->private_data) & ~3L)
-
-#define MTD_MODE_OTP_FACT	1
-#define MTD_MODE_OTP_USER	2
-#define MTD_MODE(file)		((long)((file)->private_data) & 3)
-
-#define SET_MTD_MODE(file, mode) \
-	do { long __p = (long)((file)->private_data); \
-	     (file)->private_data = (void *)((__p & ~3L) | mode); } while (0)
+struct mtd_file_info {
+	struct mtd_info *mtd;
+	enum mtd_file_modes mode;
+};
 
 static loff_t mtd_lseek (struct file *file, loff_t offset, int orig)
 {
-	struct mtd_info *mtd = TO_MTD(file);
+	struct mtd_file_info *mfi = file->private_data;
+	struct mtd_info *mtd = mfi->mtd;
 
 	switch (orig) {
 	case 0:
@@ -97,6 +91,7 @@ static int mtd_open(struct inode *inode, struct file *file)
 	int minor = iminor(inode);
 	int devnum = minor >> 1;
 	struct mtd_info *mtd;
+	struct mtd_file_info *mfi;
 
 	DEBUG(MTD_DEBUG_LEVEL0, "MTD_open\n");
 
@@ -117,14 +112,20 @@ static int mtd_open(struct inode *inode, struct file *file)
 		return -ENODEV;
 	}
 
-	file->private_data = mtd;
-
 	/* You can't open it RW if it's not a writeable device */
 	if ((file->f_mode & 2) && !(mtd->flags & MTD_WRITEABLE)) {
 		put_mtd_device(mtd);
 		return -EACCES;
 	}
 
+	mfi = kzalloc(sizeof(*mfi), GFP_KERNEL);
+	if (!mfi) {
+		put_mtd_device(mtd);
+		return -ENOMEM;
+	}
+	mfi->mtd = mtd;
+	file->private_data = mfi;
+
 	return 0;
 } /* mtd_open */
 
@@ -132,16 +133,17 @@ static int mtd_open(struct inode *inode, struct file *file)
 
 static int mtd_close(struct inode *inode, struct file *file)
 {
-	struct mtd_info *mtd;
+	struct mtd_file_info *mfi = file->private_data;
+	struct mtd_info *mtd = mfi->mtd;
 
 	DEBUG(MTD_DEBUG_LEVEL0, "MTD_close\n");
 
-	mtd = TO_MTD(file);
-
 	if (mtd->sync)
 		mtd->sync(mtd);
 
 	put_mtd_device(mtd);
+	file->private_data = NULL;
+	kfree(mfi);
 
 	return 0;
 } /* mtd_close */
@@ -153,7 +155,8 @@ static int mtd_close(struct inode *inode, struct file *file)
 
 static ssize_t mtd_read(struct file *file, char __user *buf, size_t count,loff_t *ppos)
 {
-	struct mtd_info *mtd = TO_MTD(file);
+	struct mtd_file_info *mfi = file->private_data;
+	struct mtd_info *mtd = mfi->mtd;
 	size_t retlen=0;
 	size_t total_retlen=0;
 	int ret=0;
@@ -186,13 +189,26 @@ static ssize_t mtd_read(struct file *file, char __user *buf, size_t count,loff_t
 		else
 			len = count;
 
-		switch (MTD_MODE(file)) {
-		case MTD_MODE_OTP_FACT:
+		switch (mfi->mode) {
+		case MTD_MODE_OTP_FACTORY:
 			ret = mtd->read_fact_prot_reg(mtd, *ppos, len, &retlen, kbuf);
 			break;
 		case MTD_MODE_OTP_USER:
 			ret = mtd->read_user_prot_reg(mtd, *ppos, len, &retlen, kbuf);
 			break;
+		case MTD_MODE_RAW:
+		{
+			struct mtd_oob_ops ops;
+
+			ops.mode = MTD_OOB_RAW;
+			ops.datbuf = kbuf;
+			ops.oobbuf = NULL;
+			ops.len = len;
+
+			ret = mtd->read_oob(mtd, *ppos, &ops);
+			retlen = ops.retlen;
+			break;
+		}
 		default:
 			ret = mtd->read(mtd, *ppos, len, &retlen, kbuf);
 		}
@@ -232,7 +248,8 @@ static ssize_t mtd_read(struct file *file, char __user *buf, size_t count,loff_t
 
 static ssize_t mtd_write(struct file *file, const char __user *buf, size_t count,loff_t *ppos)
 {
-	struct mtd_info *mtd = TO_MTD(file);
+	struct mtd_file_info *mfi = file->private_data;
+	struct mtd_info *mtd = mfi->mtd;
 	char *kbuf;
 	size_t retlen;
 	size_t total_retlen=0;
@@ -270,8 +287,8 @@ static ssize_t mtd_write(struct file *file, const char __user *buf, size_t count
 			return -EFAULT;
 		}
 
-		switch (MTD_MODE(file)) {
-		case MTD_MODE_OTP_FACT:
+		switch (mfi->mode) {
+		case MTD_MODE_OTP_FACTORY:
 			ret = -EROFS;
 			break;
 		case MTD_MODE_OTP_USER:
@@ -281,6 +298,21 @@ static ssize_t mtd_write(struct file *file, const char __user *buf, size_t count
 			}
 			ret = mtd->write_user_prot_reg(mtd, *ppos, len, &retlen, kbuf);
 			break;
+
+		case MTD_MODE_RAW:
+		{
+			struct mtd_oob_ops ops;
+
+			ops.mode = MTD_OOB_RAW;
+			ops.datbuf = kbuf;
+			ops.oobbuf = NULL;
+			ops.len = len;
+
+			ret = mtd->write_oob(mtd, *ppos, &ops);
+			retlen = ops.retlen;
+			break;
+		}
+
 		default:
 			ret = (*(mtd->write))(mtd, *ppos, len, &retlen, kbuf);
 		}
@@ -310,10 +342,41 @@ static void mtdchar_erase_callback (struct erase_info *instr)
 	wake_up((wait_queue_head_t *)instr->priv);
 }
 
+#if defined(CONFIG_MTD_OTP) || defined(CONFIG_MTD_ONENAND_OTP)
+static int otp_select_filemode(struct mtd_file_info *mfi, int mode)
+{
+	struct mtd_info *mtd = mfi->mtd;
+	int ret = 0;
+
+	switch (mode) {
+	case MTD_OTP_FACTORY:
+		if (!mtd->read_fact_prot_reg)
+			ret = -EOPNOTSUPP;
+		else
+			mfi->mode = MTD_MODE_OTP_FACTORY;
+		break;
+	case MTD_OTP_USER:
+		if (!mtd->read_fact_prot_reg)
+			ret = -EOPNOTSUPP;
+		else
+			mfi->mode = MTD_MODE_OTP_USER;
+		break;
+	default:
+		ret = -EINVAL;
+	case MTD_OTP_OFF:
+		break;
+	}
+	return ret;
+}
+#else
+# define otp_select_filemode(f,m)	-EOPNOTSUPP
+#endif
+
 static int mtd_ioctl(struct inode *inode, struct file *file,
 		     u_int cmd, u_long arg)
 {
-	struct mtd_info *mtd = TO_MTD(file);
+	struct mtd_file_info *mfi = file->private_data;
+	struct mtd_info *mtd = mfi->mtd;
 	void __user *argp = (void __user *)arg;
 	int ret = 0;
 	u_long size;
@@ -554,16 +617,6 @@ static int mtd_ioctl(struct inode *inode, struct file *file,
 		break;
 	}
 
-	case ECCGETLAYOUT:
-
-		if (!mtd->ecclayout)
-			return -EOPNOTSUPP;
-
-		if (copy_to_user(argp, &mtd->ecclayout,
-				 sizeof(struct nand_ecclayout)))
-			return -EFAULT;
-		break;
-
 	case MEMGETBADBLOCK:
 	{
 		loff_t offs;
@@ -596,25 +649,11 @@ static int mtd_ioctl(struct inode *inode, struct file *file,
 		int mode;
 		if (copy_from_user(&mode, argp, sizeof(int)))
 			return -EFAULT;
-		SET_MTD_MODE(file, 0);
-		switch (mode) {
-		case MTD_OTP_FACTORY:
-			if (!mtd->read_fact_prot_reg)
-				ret = -EOPNOTSUPP;
-			else
-				SET_MTD_MODE(file, MTD_MODE_OTP_FACT);
-			break;
-		case MTD_OTP_USER:
-			if (!mtd->read_fact_prot_reg)
-				ret = -EOPNOTSUPP;
-			else
-				SET_MTD_MODE(file, MTD_MODE_OTP_USER);
-			break;
-		default:
-			ret = -EINVAL;
-		case MTD_OTP_OFF:
-			break;
-		}
+
+		mfi->mode = MTD_MODE_NORMAL;
+
+		ret = otp_select_filemode(mfi, mode);
+
 		file->f_pos = 0;
 		break;
 	}
@@ -626,8 +665,8 @@ static int mtd_ioctl(struct inode *inode, struct file *file,
 		if (!buf)
 			return -ENOMEM;
 		ret = -EOPNOTSUPP;
-		switch (MTD_MODE(file)) {
-		case MTD_MODE_OTP_FACT:
+		switch (mfi->mode) {
+		case MTD_MODE_OTP_FACTORY:
 			if (mtd->get_fact_prot_info)
 				ret = mtd->get_fact_prot_info(mtd, buf, 4096);
 			break;
@@ -635,6 +674,8 @@ static int mtd_ioctl(struct inode *inode, struct file *file,
 			if (mtd->get_user_prot_info)
 				ret = mtd->get_user_prot_info(mtd, buf, 4096);
 			break;
+		default:
+			break;
 		}
 		if (ret >= 0) {
 			if (cmd == OTPGETREGIONCOUNT) {
@@ -653,7 +694,7 @@ static int mtd_ioctl(struct inode *inode, struct file *file,
 	{
 		struct otp_info info;
 
-		if (MTD_MODE(file) != MTD_MODE_OTP_USER)
+		if (mfi->mode != MTD_MODE_OTP_USER)
 			return -EINVAL;
 		if (copy_from_user(&info, argp, sizeof(info)))
 			return -EFAULT;
@@ -664,6 +705,49 @@ static int mtd_ioctl(struct inode *inode, struct file *file,
 	}
 #endif
 
+	case ECCGETLAYOUT:
+	{
+		if (!mtd->ecclayout)
+			return -EOPNOTSUPP;
+
+		if (copy_to_user(argp, &mtd->ecclayout,
+				 sizeof(struct nand_ecclayout)))
+			return -EFAULT;
+		break;
+	}
+
+	case ECCGETSTATS:
+	{
+		if (copy_to_user(argp, &mtd->ecc_stats,
+				 sizeof(struct mtd_ecc_stats)))
+			return -EFAULT;
+		break;
+	}
+
+	case MTDFILEMODE:
+	{
+		mfi->mode = 0;
+
+		switch(arg) {
+		case MTD_MODE_OTP_FACTORY:
+		case MTD_MODE_OTP_USER:
+			ret = otp_select_filemode(mfi, arg);
+			break;
+
+		case MTD_MODE_RAW:
+			if (!mtd->read_oob || !mtd->write_oob)
+				return -EOPNOTSUPP;
+			mfi->mode = arg;
+
+		case MTD_MODE_NORMAL:
+			break;
+		default:
+			ret = -EINVAL;
+		}
+		file->f_pos = 0;
+		break;
+	}
+
 	default:
 		ret = -ENOTTY;
 	}

commit 9a1fcdfd4bee27c418424cac47abf7c049541297
Author: Thomas Gleixner <tglx@cruncher.tec.linutronix.de>
Date:   Mon May 29 14:56:39 2006 +0200

    [MTD] NAND Signal that a bitflip was corrected by ECC
    
    Return -EUCLEAN on read when a bitflip was detected and corrected, so the
    clients can react and eventually copy the affected block to a spare one.
    Make all in kernel users aware of the change.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
index 7522fc3a2827..a48210d58b92 100644
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -199,10 +199,13 @@ static ssize_t mtd_read(struct file *file, char __user *buf, size_t count,loff_t
 		/* Nand returns -EBADMSG on ecc errors, but it returns
 		 * the data. For our userspace tools it is important
 		 * to dump areas with ecc errors !
+		 * For kernel internal usage it also might return -EUCLEAN
+		 * to signal the caller that a bitflip has occured and has
+		 * been corrected by the ECC algorithm.
 		 * Userspace software which accesses NAND this way
 		 * must be aware of the fact that it deals with NAND
 		 */
-		if (!ret || (ret == -EBADMSG)) {
+		if (!ret || (ret == -EUCLEAN) || (ret == -EBADMSG)) {
 			*ppos += retlen;
 			if (copy_to_user(buf, kbuf, retlen)) {
 				kfree(kbuf);

commit 8593fbc68b0df1168995de76d1af38eb62fd6b62
Author: Thomas Gleixner <tglx@cruncher.tec.linutronix.de>
Date:   Mon May 29 03:26:58 2006 +0200

    [MTD] Rework the out of band handling completely
    
    Hopefully the last iteration on this!
    
    The handling of out of band data on NAND was accompanied by tons of fruitless
    discussions and halfarsed patches to make it work for a particular
    problem. Sufficiently annoyed by I all those "I know it better" mails and the
    resonable amount of discarded "it solves my problem" patches, I finally decided
    to go for the big rework. After removing the _ecc variants of mtd read/write
    functions the solution to satisfy the various requirements was to refactor the
    read/write _oob functions in mtd.
    
    The major change is that read/write_oob now takes a pointer to an operation
    descriptor structure "struct mtd_oob_ops".instead of having a function with at
    least seven arguments.
    
    read/write_oob which should probably renamed to a more descriptive name, can do
    the following tasks:
    
    - read/write out of band data
    - read/write data content and out of band data
    - read/write raw data content and out of band data (ecc disabled)
    
    struct mtd_oob_ops has a mode field, which determines the oob handling mode.
    
    Aside of the MTD_OOB_RAW mode, which is intended to be especially for
    diagnostic purposes and some internal functions e.g. bad block table creation,
    the other two modes are for mtd clients:
    
    MTD_OOB_PLACE puts/gets the given oob data exactly to/from the place which is
    described by the ooboffs and ooblen fields of the mtd_oob_ops strcuture. It's
    up to the caller to make sure that the byte positions are not used by the ECC
    placement algorithms.
    
    MTD_OOB_AUTO puts/gets the given oob data automaticaly to/from the places in
    the out of band area which are described by the oobfree tuples in the ecclayout
    data structre which is associated to the devicee.
    
    The decision whether data plus oob or oob only handling is done depends on the
    setting of the datbuf member of the data structure. When datbuf == NULL then
    the internal read/write_oob functions are selected, otherwise the read/write
    data routines are invoked.
    
    Tested on a few platforms with all variants. Please be aware of possible
    regressions for your particular device / application scenario
    
    Disclaimer: Any whining will be ignored from those who just contributed "hot
    air blurb" and never sat down to tackle the underlying problem of the mess in
    the NAND driver grown over time and the big chunk of work to fix up the
    existing users. The problem was not the holiness of the existing MTD
    interfaces. The problems was the lack of time to go for the big overhaul. It's
    easy to add more mess to the existing one, but it takes alot of effort to go
    for a real solution.
    
    Improvements and bugfixes are welcome!
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
index b45e7747daa3..7522fc3a2827 100644
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -408,8 +408,7 @@ static int mtd_ioctl(struct inode *inode, struct file *file,
 	case MEMWRITEOOB:
 	{
 		struct mtd_oob_buf buf;
-		void *databuf;
-		ssize_t retlen;
+		struct mtd_oob_ops ops;
 
 		if(!(file->f_mode & 2))
 			return -EPERM;
@@ -417,7 +416,7 @@ static int mtd_ioctl(struct inode *inode, struct file *file,
 		if (copy_from_user(&buf, argp, sizeof(struct mtd_oob_buf)))
 			return -EFAULT;
 
-		if (buf.length > 0x4096)
+		if (buf.length > 4096)
 			return -EINVAL;
 
 		if (!mtd->write_oob)
@@ -429,21 +428,32 @@ static int mtd_ioctl(struct inode *inode, struct file *file,
 		if (ret)
 			return ret;
 
-		databuf = kmalloc(buf.length, GFP_KERNEL);
-		if (!databuf)
+		ops.len = buf.length;
+		ops.ooblen = mtd->oobsize;
+		ops.ooboffs = buf.start & (mtd->oobsize - 1);
+		ops.datbuf = NULL;
+		ops.mode = MTD_OOB_PLACE;
+
+		if (ops.ooboffs && ops.len > (ops.ooblen - ops.ooboffs))
+			return -EINVAL;
+
+		ops.oobbuf = kmalloc(buf.length, GFP_KERNEL);
+		if (!ops.oobbuf)
 			return -ENOMEM;
 
-		if (copy_from_user(databuf, buf.ptr, buf.length)) {
-			kfree(databuf);
+		if (copy_from_user(ops.oobbuf, buf.ptr, buf.length)) {
+			kfree(ops.oobbuf);
 			return -EFAULT;
 		}
 
-		ret = (mtd->write_oob)(mtd, buf.start, buf.length, &retlen, databuf);
+		buf.start &= ~(mtd->oobsize - 1);
+		ret = mtd->write_oob(mtd, buf.start, &ops);
 
-		if (copy_to_user(argp + sizeof(uint32_t), &retlen, sizeof(uint32_t)))
+		if (copy_to_user(argp + sizeof(uint32_t), &ops.retlen,
+				 sizeof(uint32_t)))
 			ret = -EFAULT;
 
-		kfree(databuf);
+		kfree(ops.oobbuf);
 		break;
 
 	}
@@ -451,13 +461,12 @@ static int mtd_ioctl(struct inode *inode, struct file *file,
 	case MEMREADOOB:
 	{
 		struct mtd_oob_buf buf;
-		void *databuf;
-		ssize_t retlen;
+		struct mtd_oob_ops ops;
 
 		if (copy_from_user(&buf, argp, sizeof(struct mtd_oob_buf)))
 			return -EFAULT;
 
-		if (buf.length > 0x4096)
+		if (buf.length > 4096)
 			return -EINVAL;
 
 		if (!mtd->read_oob)
@@ -465,22 +474,32 @@ static int mtd_ioctl(struct inode *inode, struct file *file,
 		else
 			ret = access_ok(VERIFY_WRITE, buf.ptr,
 					buf.length) ? 0 : -EFAULT;
-
 		if (ret)
 			return ret;
 
-		databuf = kmalloc(buf.length, GFP_KERNEL);
-		if (!databuf)
+		ops.len = buf.length;
+		ops.ooblen = mtd->oobsize;
+		ops.ooboffs = buf.start & (mtd->oobsize - 1);
+		ops.datbuf = NULL;
+		ops.mode = MTD_OOB_PLACE;
+
+		if (ops.ooboffs && ops.len > (ops.ooblen - ops.ooboffs))
+			return -EINVAL;
+
+		ops.oobbuf = kmalloc(buf.length, GFP_KERNEL);
+		if (!ops.oobbuf)
 			return -ENOMEM;
 
-		ret = (mtd->read_oob)(mtd, buf.start, buf.length, &retlen, databuf);
+		buf.start &= ~(mtd->oobsize - 1);
+		ret = mtd->read_oob(mtd, buf.start, &ops);
 
-		if (put_user(retlen, (uint32_t __user *)argp))
+		if (put_user(ops.retlen, (uint32_t __user *)argp))
 			ret = -EFAULT;
-		else if (retlen && copy_to_user(buf.ptr, databuf, retlen))
+		else if (ops.retlen && copy_to_user(buf.ptr, ops.oobbuf,
+						    ops.retlen))
 			ret = -EFAULT;
 
-		kfree(databuf);
+		kfree(ops.oobbuf);
 		break;
 	}
 

commit f4a43cfcecfcaeeaa40a9dbc1d1378298c22446e
Author: Thomas Gleixner <tglx@cruncher.tec.linutronix.de>
Date:   Sun May 28 11:01:53 2006 +0200

    [MTD] Remove silly MTD_WRITE/READ macros
    
    Most of those macros are unused and the used ones just obfuscate
    the code. Remove them and fixup all users.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
index e75ec5fe7760..b45e7747daa3 100644
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -194,7 +194,7 @@ static ssize_t mtd_read(struct file *file, char __user *buf, size_t count,loff_t
 			ret = mtd->read_user_prot_reg(mtd, *ppos, len, &retlen, kbuf);
 			break;
 		default:
-			ret = MTD_READ(mtd, *ppos, len, &retlen, kbuf);
+			ret = mtd->read(mtd, *ppos, len, &retlen, kbuf);
 		}
 		/* Nand returns -EBADMSG on ecc errors, but it returns
 		 * the data. For our userspace tools it is important
@@ -205,7 +205,7 @@ static ssize_t mtd_read(struct file *file, char __user *buf, size_t count,loff_t
 		if (!ret || (ret == -EBADMSG)) {
 			*ppos += retlen;
 			if (copy_to_user(buf, kbuf, retlen)) {
-			        kfree(kbuf);
+				kfree(kbuf);
 				return -EFAULT;
 			}
 			else

commit 5bd34c091a044d130601370c370f84b1c59f1627
Author: Thomas Gleixner <tglx@cruncher.tec.linutronix.de>
Date:   Sat May 27 22:16:10 2006 +0200

    [MTD] NAND Replace oobinfo by ecclayout
    
    The nand_oobinfo structure is not fitting the newer error correction
    demands anymore. Replace it by struct nand_ecclayout and fixup the users
    all over the place. Keep the nand_oobinfo based ioctl for user space
    compability reasons.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
index 608f7af679cb..e75ec5fe7760 100644
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -512,14 +512,36 @@ static int mtd_ioctl(struct inode *inode, struct file *file,
 		break;
 	}
 
+	/* Legacy interface */
 	case MEMGETOOBSEL:
 	{
-		if (copy_to_user(argp, mtd->oobinfo,
-				 sizeof(struct nand_oobinfo)))
+		struct nand_oobinfo oi;
+
+		if (!mtd->ecclayout)
+			return -EOPNOTSUPP;
+		if (mtd->ecclayout->eccbytes > ARRAY_SIZE(oi.eccpos))
+			return -EINVAL;
+
+		oi.useecc = MTD_NANDECC_AUTOPLACE;
+		memcpy(&oi.eccpos, mtd->ecclayout->eccpos, sizeof(oi.eccpos));
+		memcpy(&oi.oobfree, mtd->ecclayout->oobfree,
+		       sizeof(oi.oobfree));
+
+		if (copy_to_user(argp, &oi, sizeof(struct nand_oobinfo)))
 			return -EFAULT;
 		break;
 	}
 
+	case ECCGETLAYOUT:
+
+		if (!mtd->ecclayout)
+			return -EOPNOTSUPP;
+
+		if (copy_to_user(argp, &mtd->ecclayout,
+				 sizeof(struct nand_ecclayout)))
+			return -EFAULT;
+		break;
+
 	case MEMGETBADBLOCK:
 	{
 		loff_t offs;

commit ff268fb8791cf18df536113355d7184007c269d9
Author: Thomas Gleixner <tglx@cruncher.tec.linutronix.de>
Date:   Sat May 27 20:36:12 2006 +0200

    [MTD] NAND Consolidate oobinfo handling
    
    The info structure for out of band data was copied into
    the mtd structure. Make it a pointer and remove the ability
    to set it from userspace. The position of ecc bytes is
    defined by the hardware and should not be changed by software.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
index 7a7df851c993..608f7af679cb 100644
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -512,16 +512,10 @@ static int mtd_ioctl(struct inode *inode, struct file *file,
 		break;
 	}
 
-	case MEMSETOOBSEL:
-	{
-		if (copy_from_user(&mtd->oobinfo, argp, sizeof(struct nand_oobinfo)))
-			return -EFAULT;
-		break;
-	}
-
 	case MEMGETOOBSEL:
 	{
-		if (copy_to_user(argp, &(mtd->oobinfo), sizeof(struct nand_oobinfo)))
+		if (copy_to_user(argp, mtd->oobinfo,
+				 sizeof(struct nand_oobinfo)))
 			return -EFAULT;
 		break;
 	}

commit 493c646077ef0b8668ed71b8057f81cb7454af87
Author: Kyungmin Park <kyungmin.park@samsung.com>
Date:   Fri May 12 17:03:07 2006 +0300

    OneNAND: One-Time Programmable (OTP) support
    
    One Block of the NAND Flash Array memory is reserved as
    a One-Time Programmable Block memory area.
    Also, 1st Block of NAND Flash Array can be used as OTP.
    
    The OTP block can be read, programmed and locked using the same
    operations as any other NAND Flash Array memory block.
    OTP block cannot be erased.
    
    OTP block is fully-guaranteed to be a valid block.
    
    Signed-off-by: Kyungmin Park <kyungmin.park@samsung.com>

diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
index 6b83aee8abb8..7a7df851c993 100644
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -552,7 +552,7 @@ static int mtd_ioctl(struct inode *inode, struct file *file,
 		break;
 	}
 
-#ifdef CONFIG_MTD_OTP
+#if defined(CONFIG_MTD_OTP) || defined(CONFIG_MTD_ONENAND_OTP)
 	case OTPSELECT:
 	{
 		int mode;

commit b802c0741103aa92251d536c115874d51f802ec8
Author: Thago Galesi <thiagogalesi@gmail.com>
Date:   Mon Apr 17 17:38:15 2006 +0100

    [PATCH] Remove unnecessary kmalloc/kfree calls in mtdchar
    
    This patch removes repeated calls to kmalloc / kfree in mtd_write /
    mtd_read functions, replacing them by a single kmalloc / kfree pair.
    
    Signed-off-by: Thiago Galesi <thiagogalesi@gmail.com>
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>

diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
index 6f044584bdc6..6b83aee8abb8 100644
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -170,16 +170,22 @@ static ssize_t mtd_read(struct file *file, char __user *buf, size_t count,loff_t
 
 	/* FIXME: Use kiovec in 2.5 to lock down the user's buffers
 	   and pass them directly to the MTD functions */
+
+	if (count > MAX_KMALLOC_SIZE)
+		kbuf=kmalloc(MAX_KMALLOC_SIZE, GFP_KERNEL);
+	else
+		kbuf=kmalloc(count, GFP_KERNEL);
+
+	if (!kbuf)
+		return -ENOMEM;
+
 	while (count) {
+
 		if (count > MAX_KMALLOC_SIZE)
 			len = MAX_KMALLOC_SIZE;
 		else
 			len = count;
 
-		kbuf=kmalloc(len,GFP_KERNEL);
-		if (!kbuf)
-			return -ENOMEM;
-
 		switch (MTD_MODE(file)) {
 		case MTD_MODE_OTP_FACT:
 			ret = mtd->read_fact_prot_reg(mtd, *ppos, len, &retlen, kbuf);
@@ -215,9 +221,9 @@ static ssize_t mtd_read(struct file *file, char __user *buf, size_t count,loff_t
 			return ret;
 		}
 
-		kfree(kbuf);
 	}
 
+	kfree(kbuf);
 	return total_retlen;
 } /* mtd_read */
 
@@ -241,18 +247,21 @@ static ssize_t mtd_write(struct file *file, const char __user *buf, size_t count
 	if (!count)
 		return 0;
 
+	if (count > MAX_KMALLOC_SIZE)
+		kbuf=kmalloc(MAX_KMALLOC_SIZE, GFP_KERNEL);
+	else
+		kbuf=kmalloc(count, GFP_KERNEL);
+
+	if (!kbuf)
+		return -ENOMEM;
+
 	while (count) {
+
 		if (count > MAX_KMALLOC_SIZE)
 			len = MAX_KMALLOC_SIZE;
 		else
 			len = count;
 
-		kbuf=kmalloc(len,GFP_KERNEL);
-		if (!kbuf) {
-			printk("kmalloc is null\n");
-			return -ENOMEM;
-		}
-
 		if (copy_from_user(kbuf, buf, len)) {
 			kfree(kbuf);
 			return -EFAULT;
@@ -282,10 +291,9 @@ static ssize_t mtd_write(struct file *file, const char __user *buf, size_t count
 			kfree(kbuf);
 			return ret;
 		}
-
-		kfree(kbuf);
 	}
 
+	kfree(kbuf);
 	return total_retlen;
 } /* mtd_write */
 

commit 97894cda5773e59bd13e87b72077751099419a9f
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Nov 7 11:15:26 2005 +0000

    [MTD] core: Clean up trailing white spaces
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
index d1ffd246ad55..6f044584bdc6 100644
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -1,5 +1,5 @@
 /*
- * $Id: mtdchar.c,v 1.75 2005/11/06 10:04:37 gleixner Exp $
+ * $Id: mtdchar.c,v 1.76 2005/11/07 11:14:20 gleixner Exp $
  *
  * Character-device access to raw MTD devices.
  *
@@ -28,7 +28,7 @@ static void mtd_notify_add(struct mtd_info* mtd)
 
 	class_device_create(mtd_class, NULL, MKDEV(MTD_CHAR_MAJOR, mtd->index*2),
 			    NULL, "mtd%d", mtd->index);
-	
+
 	class_device_create(mtd_class, NULL,
 			    MKDEV(MTD_CHAR_MAJOR, mtd->index*2+1),
 			    NULL, "mtd%dro", mtd->index);
@@ -108,23 +108,23 @@ static int mtd_open(struct inode *inode, struct file *file)
 		return -EACCES;
 
 	mtd = get_mtd_device(NULL, devnum);
-	
+
 	if (!mtd)
 		return -ENODEV;
-	
+
 	if (MTD_ABSENT == mtd->type) {
 		put_mtd_device(mtd);
 		return -ENODEV;
 	}
 
 	file->private_data = mtd;
-		
+
 	/* You can't open it RW if it's not a writeable device */
 	if ((file->f_mode & 2) && !(mtd->flags & MTD_WRITEABLE)) {
 		put_mtd_device(mtd);
 		return -EACCES;
 	}
-		
+
 	return 0;
 } /* mtd_open */
 
@@ -137,10 +137,10 @@ static int mtd_close(struct inode *inode, struct file *file)
 	DEBUG(MTD_DEBUG_LEVEL0, "MTD_close\n");
 
 	mtd = TO_MTD(file);
-	
+
 	if (mtd->sync)
 		mtd->sync(mtd);
-	
+
 	put_mtd_device(mtd);
 
 	return 0;
@@ -159,7 +159,7 @@ static ssize_t mtd_read(struct file *file, char __user *buf, size_t count,loff_t
 	int ret=0;
 	int len;
 	char *kbuf;
-	
+
 	DEBUG(MTD_DEBUG_LEVEL0,"MTD_read\n");
 
 	if (*ppos + count > mtd->size)
@@ -167,11 +167,11 @@ static ssize_t mtd_read(struct file *file, char __user *buf, size_t count,loff_t
 
 	if (!count)
 		return 0;
-	
+
 	/* FIXME: Use kiovec in 2.5 to lock down the user's buffers
 	   and pass them directly to the MTD functions */
 	while (count) {
-		if (count > MAX_KMALLOC_SIZE) 
+		if (count > MAX_KMALLOC_SIZE)
 			len = MAX_KMALLOC_SIZE;
 		else
 			len = count;
@@ -179,7 +179,7 @@ static ssize_t mtd_read(struct file *file, char __user *buf, size_t count,loff_t
 		kbuf=kmalloc(len,GFP_KERNEL);
 		if (!kbuf)
 			return -ENOMEM;
-		
+
 		switch (MTD_MODE(file)) {
 		case MTD_MODE_OTP_FACT:
 			ret = mtd->read_fact_prot_reg(mtd, *ppos, len, &retlen, kbuf);
@@ -192,7 +192,7 @@ static ssize_t mtd_read(struct file *file, char __user *buf, size_t count,loff_t
 		}
 		/* Nand returns -EBADMSG on ecc errors, but it returns
 		 * the data. For our userspace tools it is important
-		 * to dump areas with ecc errors ! 
+		 * to dump areas with ecc errors !
 		 * Userspace software which accesses NAND this way
 		 * must be aware of the fact that it deals with NAND
 		 */
@@ -214,7 +214,7 @@ static ssize_t mtd_read(struct file *file, char __user *buf, size_t count,loff_t
 			kfree(kbuf);
 			return ret;
 		}
-		
+
 		kfree(kbuf);
 	}
 
@@ -231,10 +231,10 @@ static ssize_t mtd_write(struct file *file, const char __user *buf, size_t count
 	int len;
 
 	DEBUG(MTD_DEBUG_LEVEL0,"MTD_write\n");
-	
+
 	if (*ppos == mtd->size)
 		return -ENOSPC;
-	
+
 	if (*ppos + count > mtd->size)
 		count = mtd->size - *ppos;
 
@@ -242,7 +242,7 @@ static ssize_t mtd_write(struct file *file, const char __user *buf, size_t count
 		return 0;
 
 	while (count) {
-		if (count > MAX_KMALLOC_SIZE) 
+		if (count > MAX_KMALLOC_SIZE)
 			len = MAX_KMALLOC_SIZE;
 		else
 			len = count;
@@ -257,7 +257,7 @@ static ssize_t mtd_write(struct file *file, const char __user *buf, size_t count
 			kfree(kbuf);
 			return -EFAULT;
 		}
-		
+
 		switch (MTD_MODE(file)) {
 		case MTD_MODE_OTP_FACT:
 			ret = -EROFS;
@@ -282,7 +282,7 @@ static ssize_t mtd_write(struct file *file, const char __user *buf, size_t count
 			kfree(kbuf);
 			return ret;
 		}
-		
+
 		kfree(kbuf);
 	}
 
@@ -306,7 +306,7 @@ static int mtd_ioctl(struct inode *inode, struct file *file,
 	void __user *argp = (void __user *)arg;
 	int ret = 0;
 	u_long size;
-	
+
 	DEBUG(MTD_DEBUG_LEVEL0, "MTD_ioctl\n");
 
 	size = (cmd & IOCSIZE_MASK) >> IOCSIZE_SHIFT;
@@ -318,7 +318,7 @@ static int mtd_ioctl(struct inode *inode, struct file *file,
 		if (!access_ok(VERIFY_WRITE, argp, size))
 			return -EFAULT;
 	}
-	
+
 	switch (cmd) {
 	case MEMGETREGIONCOUNT:
 		if (copy_to_user(argp, &(mtd->numeraseregions), sizeof(int)))
@@ -370,11 +370,11 @@ static int mtd_ioctl(struct inode *inode, struct file *file,
 			erase->mtd = mtd;
 			erase->callback = mtdchar_erase_callback;
 			erase->priv = (unsigned long)&waitq;
-			
+
 			/*
 			  FIXME: Allow INTERRUPTIBLE. Which means
 			  not having the wait_queue head on the stack.
-			  
+
 			  If the wq_head is on the stack, and we
 			  leave because we got interrupted, then the
 			  wq_head is no longer there when the
@@ -402,13 +402,13 @@ static int mtd_ioctl(struct inode *inode, struct file *file,
 		struct mtd_oob_buf buf;
 		void *databuf;
 		ssize_t retlen;
-		
+
 		if(!(file->f_mode & 2))
 			return -EPERM;
 
 		if (copy_from_user(&buf, argp, sizeof(struct mtd_oob_buf)))
 			return -EFAULT;
-		
+
 		if (buf.length > 0x4096)
 			return -EINVAL;
 
@@ -424,7 +424,7 @@ static int mtd_ioctl(struct inode *inode, struct file *file,
 		databuf = kmalloc(buf.length, GFP_KERNEL);
 		if (!databuf)
 			return -ENOMEM;
-		
+
 		if (copy_from_user(databuf, buf.ptr, buf.length)) {
 			kfree(databuf);
 			return -EFAULT;
@@ -448,7 +448,7 @@ static int mtd_ioctl(struct inode *inode, struct file *file,
 
 		if (copy_from_user(&buf, argp, sizeof(struct mtd_oob_buf)))
 			return -EFAULT;
-		
+
 		if (buf.length > 0x4096)
 			return -EINVAL;
 
@@ -464,14 +464,14 @@ static int mtd_ioctl(struct inode *inode, struct file *file,
 		databuf = kmalloc(buf.length, GFP_KERNEL);
 		if (!databuf)
 			return -ENOMEM;
-		
+
 		ret = (mtd->read_oob)(mtd, buf.start, buf.length, &retlen, databuf);
 
 		if (put_user(retlen, (uint32_t __user *)argp))
 			ret = -EFAULT;
 		else if (retlen && copy_to_user(buf.ptr, databuf, retlen))
 			ret = -EFAULT;
-		
+
 		kfree(databuf);
 		break;
 	}
@@ -521,7 +521,7 @@ static int mtd_ioctl(struct inode *inode, struct file *file,
 	case MEMGETBADBLOCK:
 	{
 		loff_t offs;
-		
+
 		if (copy_from_user(&offs, argp, sizeof(loff_t)))
 			return -EFAULT;
 		if (!mtd->block_isbad)

commit 15fdc52f35b853e3fa550087987b5ee4ffbd199b
Author: Thomas Gleixner <tglx@mtd.linutronix.de>
Date:   Mon Nov 7 00:14:42 2005 +0100

    [MTD] Tidy up Tims include cleanup
    
    While we are at it, reorder the includes and
    remove the silly /* TASK */ comment
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
index 8c0d94b72b63..d1ffd246ad55 100644
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -1,22 +1,23 @@
 /*
- * $Id: mtdchar.c,v 1.74 2005/08/04 01:05:48 tpoynor Exp $
+ * $Id: mtdchar.c,v 1.75 2005/11/06 10:04:37 gleixner Exp $
  *
  * Character-device access to raw MTD devices.
  *
  */
 
 #include <linux/config.h>
+#include <linux/device.h>
+#include <linux/fs.h>
+#include <linux/init.h>
 #include <linux/kernel.h>
 #include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/sched.h>
+
 #include <linux/mtd/mtd.h>
 #include <linux/mtd/compatmac.h>
-#include <linux/slab.h>
-#include <linux/init.h>
-#include <linux/fs.h>
-#include <linux/sched.h>	/* TASK_* */
-#include <asm/uaccess.h>
 
-#include <linux/device.h>
+#include <asm/uaccess.h>
 
 static struct class *mtd_class;
 

commit 2fc2991175bf77395e6b15fe6b2304d3bf72da40
Merge: 8b491d750885 7015faa7df82
Author: Thomas Gleixner <tglx@mtd.linutronix.de>
Date:   Sun Nov 6 15:36:37 2005 +0100

    Merge branch 'master' of /home/tglx/work/mtd/git/linux-2.6.git/

commit 4e57b6817880946a3a78d5d8cad1ace363f7e449
Author: Tim Schmielau <tim@physik3.uni-rostock.de>
Date:   Sun Oct 30 15:03:48 2005 -0800

    [PATCH] fix missing includes
    
    I recently picked up my older work to remove unnecessary #includes of
    sched.h, starting from a patch by Dave Jones to not include sched.h
    from module.h. This reduces the number of indirect includes of sched.h
    by ~300. Another ~400 pointless direct includes can be removed after
    this disentangling (patch to follow later).
    However, quite a few indirect includes need to be fixed up for this.
    
    In order to feed the patches through -mm with as little disturbance as
    possible, I've split out the fixes I accumulated up to now (complete for
    i386 and x86_64, more archs to follow later) and post them before the real
    patch.  This way this large part of the patch is kept simple with only
    adding #includes, and all hunks are independent of each other.  So if any
    hunk rejects or gets in the way of other patches, just drop it.  My scripts
    will pick it up again in the next round.
    
    Signed-off-by: Tim Schmielau <tim@physik3.uni-rostock.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
index c534fd5d95cb..16df1e4fb0e9 100644
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -13,6 +13,7 @@
 #include <linux/slab.h>
 #include <linux/init.h>
 #include <linux/fs.h>
+#include <linux/sched.h>	/* TASK_* */
 #include <asm/uaccess.h>
 
 #include <linux/device.h>

commit 53f4654272df7c51064825024340554b39c9efba
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Thu Oct 27 22:25:43 2005 -0700

    [PATCH] Driver Core: fix up all callers of class_device_create()
    
    The previous patch adding the ability to nest struct class_device
    changed the paramaters to the call class_device_create().  This patch
    fixes up all in-kernel users of the function.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
index 1ed602a0f24c..c534fd5d95cb 100644
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -24,10 +24,10 @@ static void mtd_notify_add(struct mtd_info* mtd)
 	if (!mtd)
 		return;
 
-	class_device_create(mtd_class, MKDEV(MTD_CHAR_MAJOR, mtd->index*2),
+	class_device_create(mtd_class, NULL, MKDEV(MTD_CHAR_MAJOR, mtd->index*2),
 			    NULL, "mtd%d", mtd->index);
 	
-	class_device_create(mtd_class, 
+	class_device_create(mtd_class, NULL,
 			    MKDEV(MTD_CHAR_MAJOR, mtd->index*2+1),
 			    NULL, "mtd%dro", mtd->index);
 }

commit 8b491d750885ebe8e7d385ce4186c85957d67123
Author: Todd Poynor <tpoynor@mvista.com>
Date:   Thu Aug 4 02:05:51 2005 +0100

    [MTD] mtdchar: Return EINVAL for bad seeks instead of fixing up to valid byte
    
    mtdchar return -EINVAL for seek prior to offset 0 or to beyond the last
    byte in the device/partition, similar to various other seek methods,
    instead of fixing up to first or last byte.
    
    Signed-off-by: Todd Poynor <tpoynor@mvista.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
index 1ed602a0f24c..4b3c6263e7fc 100644
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -1,5 +1,5 @@
 /*
- * $Id: mtdchar.c,v 1.73 2005/07/04 17:36:41 gleixner Exp $
+ * $Id: mtdchar.c,v 1.74 2005/08/04 01:05:48 tpoynor Exp $
  *
  * Character-device access to raw MTD devices.
  *
@@ -69,26 +69,23 @@ static loff_t mtd_lseek (struct file *file, loff_t offset, int orig)
 	switch (orig) {
 	case 0:
 		/* SEEK_SET */
-		file->f_pos = offset;
 		break;
 	case 1:
 		/* SEEK_CUR */
-		file->f_pos += offset;
+		offset += file->f_pos;
 		break;
 	case 2:
 		/* SEEK_END */
-		file->f_pos =mtd->size + offset;
+		offset += mtd->size;
 		break;
 	default:
 		return -EINVAL;
 	}
 
-	if (file->f_pos < 0)
-		file->f_pos = 0;
-	else if (file->f_pos >= mtd->size)
-		file->f_pos = mtd->size - 1;
+	if (offset >= 0 && offset < mtd->size)
+		return file->f_pos = offset;
 
-	return file->f_pos;
+	return -EINVAL;
 }
 
 

commit 3a7a882420d378b59542a048075e40428c771a12
Author: Coywolf Qi Hunt <coywolf@sosdg.org>
Date:   Mon Jul 4 12:15:28 2005 -0500

    [MTD] mtdchar: Return the real error code when create_class() failed
    
    Signed-off-by: Coywolf Qi Hunt <coywolf@sosdg.org>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
index b606f811eeb4..1ed602a0f24c 100644
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -1,5 +1,5 @@
 /*
- * $Id: mtdchar.c,v 1.72 2005/06/30 00:23:24 tpoynor Exp $
+ * $Id: mtdchar.c,v 1.73 2005/07/04 17:36:41 gleixner Exp $
  *
  * Character-device access to raw MTD devices.
  *
@@ -649,7 +649,7 @@ static int __init init_mtdchar(void)
 	if (IS_ERR(mtd_class)) {
 		printk(KERN_ERR "Error creating mtd class.\n");
 		unregister_chrdev(MTD_CHAR_MAJOR, "mtd");
-		return 1;
+		return PTR_ERR(mtd_class);
 	}
 
 	register_mtd_user(&notifier);

commit 9bc7b38731dd1cc1635ab12f8de48866f603b06e
Author: Todd Poynor <tpoynor@mvista.com>
Date:   Thu Jun 30 01:23:27 2005 +0100

    [MTD] mtdchar.c: Replace DEVFS by udev
    
    Switch from DEVFS to udev for dynamic creation of device nodes for mtd
    char devices.
    
    Creates a new LDM class "mtd" with writeable and read-only devices
    registered for each mtdchar device.
    
    From: Paolo Galtieri <pgaltieri@mvista.com>
    Signed-off-by: Todd Poynor <tpoynor@mvista.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
index da3f1a8f756e..b606f811eeb4 100644
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -1,5 +1,5 @@
 /*
- * $Id: mtdchar.c,v 1.70 2005/04/01 15:36:11 nico Exp $
+ * $Id: mtdchar.c,v 1.72 2005/06/30 00:23:24 tpoynor Exp $
  *
  * Character-device access to raw MTD devices.
  *
@@ -15,27 +15,30 @@
 #include <linux/fs.h>
 #include <asm/uaccess.h>
 
-#ifdef CONFIG_DEVFS_FS
-#include <linux/devfs_fs_kernel.h>
+#include <linux/device.h>
+
+static struct class *mtd_class;
 
 static void mtd_notify_add(struct mtd_info* mtd)
 {
 	if (!mtd)
 		return;
 
-	devfs_mk_cdev(MKDEV(MTD_CHAR_MAJOR, mtd->index*2),
-		      S_IFCHR | S_IRUGO | S_IWUGO, "mtd/%d", mtd->index);
-		
-	devfs_mk_cdev(MKDEV(MTD_CHAR_MAJOR, mtd->index*2+1),
-		      S_IFCHR | S_IRUGO, "mtd/%dro", mtd->index);
+	class_device_create(mtd_class, MKDEV(MTD_CHAR_MAJOR, mtd->index*2),
+			    NULL, "mtd%d", mtd->index);
+	
+	class_device_create(mtd_class, 
+			    MKDEV(MTD_CHAR_MAJOR, mtd->index*2+1),
+			    NULL, "mtd%dro", mtd->index);
 }
 
 static void mtd_notify_remove(struct mtd_info* mtd)
 {
 	if (!mtd)
 		return;
-	devfs_remove("mtd/%d", mtd->index);
-	devfs_remove("mtd/%dro", mtd->index);
+
+	class_device_destroy(mtd_class, MKDEV(MTD_CHAR_MAJOR, mtd->index*2));
+	class_device_destroy(mtd_class, MKDEV(MTD_CHAR_MAJOR, mtd->index*2+1));
 }
 
 static struct mtd_notifier notifier = {
@@ -43,22 +46,6 @@ static struct mtd_notifier notifier = {
 	.remove	= mtd_notify_remove,
 };
 
-static inline void mtdchar_devfs_init(void)
-{
-	devfs_mk_dir("mtd");
-	register_mtd_user(&notifier);
-}
-
-static inline void mtdchar_devfs_exit(void)
-{
-	unregister_mtd_user(&notifier);
-	devfs_remove("mtd");
-}
-#else /* !DEVFS */
-#define mtdchar_devfs_init() do { } while(0)
-#define mtdchar_devfs_exit() do { } while(0)
-#endif
-
 /*
  * We use file->private_data to store a pointer to the MTDdevice.
  * Since alighment is at least 32 bits, we have 2 bits free for OTP
@@ -657,13 +644,22 @@ static int __init init_mtdchar(void)
 		return -EAGAIN;
 	}
 
-	mtdchar_devfs_init();
+	mtd_class = class_create(THIS_MODULE, "mtd");
+
+	if (IS_ERR(mtd_class)) {
+		printk(KERN_ERR "Error creating mtd class.\n");
+		unregister_chrdev(MTD_CHAR_MAJOR, "mtd");
+		return 1;
+	}
+
+	register_mtd_user(&notifier);
 	return 0;
 }
 
 static void __exit cleanup_mtdchar(void)
 {
-	mtdchar_devfs_exit();
+	unregister_mtd_user(&notifier);
+	class_destroy(mtd_class);
 	unregister_chrdev(MTD_CHAR_MAJOR, "mtd");
 }
 

commit 81dba488792b29cc8cb2b3d49407be05303dde16
Author: Nicolas Pitre <nico@cam.org>
Date:   Fri Apr 1 16:36:15 2005 +0100

    [MTD] Reset file position when switching OTP mode
    
    Signed-off-by: Nicolas Pitre <nico@cam.org>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
index 548b89204aa2..da3f1a8f756e 100644
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -1,5 +1,5 @@
 /*
- * $Id: mtdchar.c,v 1.68 2005/02/08 19:12:50 nico Exp $
+ * $Id: mtdchar.c,v 1.70 2005/04/01 15:36:11 nico Exp $
  *
  * Character-device access to raw MTD devices.
  *
@@ -583,6 +583,7 @@ static int mtd_ioctl(struct inode *inode, struct file *file,
 		case MTD_OTP_OFF:
 			break;
 		}
+		file->f_pos = 0;
 		break;
 	}
 

commit 045e9a5d51ced27bfcbdb78071534ce6fd36b33d
Author: Nicolas Pitre <nico@cam.org>
Date:   Tue Feb 8 19:12:53 2005 +0000

    [MTD] Unabuse file-f_mode for OTP purpose
    
    Signed-off-by: Nicolas Pitre <nico@cam.org>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
index 6ea2d8058a4a..548b89204aa2 100644
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -1,5 +1,5 @@
 /*
- * $Id: mtdchar.c,v 1.67 2005/02/08 17:45:51 nico Exp $
+ * $Id: mtdchar.c,v 1.68 2005/02/08 19:12:50 nico Exp $
  *
  * Character-device access to raw MTD devices.
  *
@@ -59,15 +59,25 @@ static inline void mtdchar_devfs_exit(void)
 #define mtdchar_devfs_exit() do { } while(0)
 #endif
 
+/*
+ * We use file->private_data to store a pointer to the MTDdevice.
+ * Since alighment is at least 32 bits, we have 2 bits free for OTP
+ * modes as well.
+ */
+
+#define TO_MTD(file) (struct mtd_info *)((long)((file)->private_data) & ~3L)
 
-/* Well... let's abuse the unused bits in file->f_mode for those */
-#define MTD_MODE_OTP_FACT	0x1000
-#define MTD_MODE_OTP_USER	0x2000
-#define MTD_MODE_MASK		0xf000
+#define MTD_MODE_OTP_FACT	1
+#define MTD_MODE_OTP_USER	2
+#define MTD_MODE(file)		((long)((file)->private_data) & 3)
+
+#define SET_MTD_MODE(file, mode) \
+	do { long __p = (long)((file)->private_data); \
+	     (file)->private_data = (void *)((__p & ~3L) | mode); } while (0)
 
 static loff_t mtd_lseek (struct file *file, loff_t offset, int orig)
 {
-	struct mtd_info *mtd = file->private_data;
+	struct mtd_info *mtd = TO_MTD(file);
 
 	switch (orig) {
 	case 0:
@@ -111,10 +121,6 @@ static int mtd_open(struct inode *inode, struct file *file)
 	if ((file->f_mode & 2) && (minor & 1))
 		return -EACCES;
 
-	/* make sure the locally abused bits are initialy clear */
-	if (file->f_mode & MTD_MODE_MASK)
-		return -EWOULDBLOCK;
-
 	mtd = get_mtd_device(NULL, devnum);
 	
 	if (!mtd)
@@ -144,7 +150,7 @@ static int mtd_close(struct inode *inode, struct file *file)
 
 	DEBUG(MTD_DEBUG_LEVEL0, "MTD_close\n");
 
-	mtd = file->private_data;
+	mtd = TO_MTD(file);
 	
 	if (mtd->sync)
 		mtd->sync(mtd);
@@ -161,7 +167,7 @@ static int mtd_close(struct inode *inode, struct file *file)
 
 static ssize_t mtd_read(struct file *file, char __user *buf, size_t count,loff_t *ppos)
 {
-	struct mtd_info *mtd = file->private_data;
+	struct mtd_info *mtd = TO_MTD(file);
 	size_t retlen=0;
 	size_t total_retlen=0;
 	int ret=0;
@@ -188,7 +194,7 @@ static ssize_t mtd_read(struct file *file, char __user *buf, size_t count,loff_t
 		if (!kbuf)
 			return -ENOMEM;
 		
-		switch (file->f_mode & MTD_MODE_MASK) {
+		switch (MTD_MODE(file)) {
 		case MTD_MODE_OTP_FACT:
 			ret = mtd->read_fact_prot_reg(mtd, *ppos, len, &retlen, kbuf);
 			break;
@@ -231,7 +237,7 @@ static ssize_t mtd_read(struct file *file, char __user *buf, size_t count,loff_t
 
 static ssize_t mtd_write(struct file *file, const char __user *buf, size_t count,loff_t *ppos)
 {
-	struct mtd_info *mtd = file->private_data;
+	struct mtd_info *mtd = TO_MTD(file);
 	char *kbuf;
 	size_t retlen;
 	size_t total_retlen=0;
@@ -266,7 +272,7 @@ static ssize_t mtd_write(struct file *file, const char __user *buf, size_t count
 			return -EFAULT;
 		}
 		
-		switch (file->f_mode & MTD_MODE_MASK) {
+		switch (MTD_MODE(file)) {
 		case MTD_MODE_OTP_FACT:
 			ret = -EROFS;
 			break;
@@ -310,7 +316,7 @@ static void mtdchar_erase_callback (struct erase_info *instr)
 static int mtd_ioctl(struct inode *inode, struct file *file,
 		     u_int cmd, u_long arg)
 {
-	struct mtd_info *mtd = file->private_data;
+	struct mtd_info *mtd = TO_MTD(file);
 	void __user *argp = (void __user *)arg;
 	int ret = 0;
 	u_long size;
@@ -558,19 +564,19 @@ static int mtd_ioctl(struct inode *inode, struct file *file,
 		int mode;
 		if (copy_from_user(&mode, argp, sizeof(int)))
 			return -EFAULT;
-		file->f_mode &= ~MTD_MODE_MASK;
+		SET_MTD_MODE(file, 0);
 		switch (mode) {
 		case MTD_OTP_FACTORY:
 			if (!mtd->read_fact_prot_reg)
 				ret = -EOPNOTSUPP;
 			else
-				file->f_mode |= MTD_MODE_OTP_FACT;
+				SET_MTD_MODE(file, MTD_MODE_OTP_FACT);
 			break;
 		case MTD_OTP_USER:
 			if (!mtd->read_fact_prot_reg)
 				ret = -EOPNOTSUPP;
 			else
-				file->f_mode |= MTD_MODE_OTP_USER;
+				SET_MTD_MODE(file, MTD_MODE_OTP_USER);
 			break;
 		default:
 			ret = -EINVAL;
@@ -587,7 +593,7 @@ static int mtd_ioctl(struct inode *inode, struct file *file,
 		if (!buf)
 			return -ENOMEM;
 		ret = -EOPNOTSUPP;
-		switch (file->f_mode & MTD_MODE_MASK) {
+		switch (MTD_MODE(file)) {
 		case MTD_MODE_OTP_FACT:
 			if (mtd->get_fact_prot_info)
 				ret = mtd->get_fact_prot_info(mtd, buf, 4096);
@@ -614,7 +620,7 @@ static int mtd_ioctl(struct inode *inode, struct file *file,
 	{
 		struct otp_info info;
 
-		if ((file->f_mode & MTD_MODE_MASK) != MTD_MODE_OTP_USER)
+		if (MTD_MODE(file) != MTD_MODE_OTP_USER)
 			return -EINVAL;
 		if (copy_from_user(&info, argp, sizeof(info)))
 			return -EFAULT;

commit 31f4233baeaaeb7c563d2766781c6592ad259b6a
Author: Nicolas Pitre <nico@cam.org>
Date:   Tue Feb 8 17:45:55 2005 +0000

    [MTD] User interface to Protection Registers
    
    This is implemented using a ioctl to switch the MTD char device into
    one of the different OTP "modes", at which point read/write/seek can
    operate on the selected OTP area.  Also some extra ioctls to query
    for size and lock protection segments or groups.  Some example user
    space utilities are provided.
    
    Signed-off-by: Nicolas Pitre <nico@cam.org>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
index 510ad78312cc..6ea2d8058a4a 100644
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -1,5 +1,5 @@
 /*
- * $Id: mtdchar.c,v 1.66 2005/01/05 18:05:11 dwmw2 Exp $
+ * $Id: mtdchar.c,v 1.67 2005/02/08 17:45:51 nico Exp $
  *
  * Character-device access to raw MTD devices.
  *
@@ -59,6 +59,12 @@ static inline void mtdchar_devfs_exit(void)
 #define mtdchar_devfs_exit() do { } while(0)
 #endif
 
+
+/* Well... let's abuse the unused bits in file->f_mode for those */
+#define MTD_MODE_OTP_FACT	0x1000
+#define MTD_MODE_OTP_USER	0x2000
+#define MTD_MODE_MASK		0xf000
+
 static loff_t mtd_lseek (struct file *file, loff_t offset, int orig)
 {
 	struct mtd_info *mtd = file->private_data;
@@ -105,6 +111,10 @@ static int mtd_open(struct inode *inode, struct file *file)
 	if ((file->f_mode & 2) && (minor & 1))
 		return -EACCES;
 
+	/* make sure the locally abused bits are initialy clear */
+	if (file->f_mode & MTD_MODE_MASK)
+		return -EWOULDBLOCK;
+
 	mtd = get_mtd_device(NULL, devnum);
 	
 	if (!mtd)
@@ -178,7 +188,16 @@ static ssize_t mtd_read(struct file *file, char __user *buf, size_t count,loff_t
 		if (!kbuf)
 			return -ENOMEM;
 		
-		ret = MTD_READ(mtd, *ppos, len, &retlen, kbuf);
+		switch (file->f_mode & MTD_MODE_MASK) {
+		case MTD_MODE_OTP_FACT:
+			ret = mtd->read_fact_prot_reg(mtd, *ppos, len, &retlen, kbuf);
+			break;
+		case MTD_MODE_OTP_USER:
+			ret = mtd->read_user_prot_reg(mtd, *ppos, len, &retlen, kbuf);
+			break;
+		default:
+			ret = MTD_READ(mtd, *ppos, len, &retlen, kbuf);
+		}
 		/* Nand returns -EBADMSG on ecc errors, but it returns
 		 * the data. For our userspace tools it is important
 		 * to dump areas with ecc errors ! 
@@ -196,6 +215,8 @@ static ssize_t mtd_read(struct file *file, char __user *buf, size_t count,loff_t
 
 			count -= retlen;
 			buf += retlen;
+			if (retlen == 0)
+				count = 0;
 		}
 		else {
 			kfree(kbuf);
@@ -245,7 +266,20 @@ static ssize_t mtd_write(struct file *file, const char __user *buf, size_t count
 			return -EFAULT;
 		}
 		
-	        ret = (*(mtd->write))(mtd, *ppos, len, &retlen, kbuf);
+		switch (file->f_mode & MTD_MODE_MASK) {
+		case MTD_MODE_OTP_FACT:
+			ret = -EROFS;
+			break;
+		case MTD_MODE_OTP_USER:
+			if (!mtd->write_user_prot_reg) {
+				ret = -EOPNOTSUPP;
+				break;
+			}
+			ret = mtd->write_user_prot_reg(mtd, *ppos, len, &retlen, kbuf);
+			break;
+		default:
+			ret = (*(mtd->write))(mtd, *ppos, len, &retlen, kbuf);
+		}
 		if (!ret) {
 			*ppos += retlen;
 			total_retlen += retlen;
@@ -518,6 +552,79 @@ static int mtd_ioctl(struct inode *inode, struct file *file,
 		break;
 	}
 
+#ifdef CONFIG_MTD_OTP
+	case OTPSELECT:
+	{
+		int mode;
+		if (copy_from_user(&mode, argp, sizeof(int)))
+			return -EFAULT;
+		file->f_mode &= ~MTD_MODE_MASK;
+		switch (mode) {
+		case MTD_OTP_FACTORY:
+			if (!mtd->read_fact_prot_reg)
+				ret = -EOPNOTSUPP;
+			else
+				file->f_mode |= MTD_MODE_OTP_FACT;
+			break;
+		case MTD_OTP_USER:
+			if (!mtd->read_fact_prot_reg)
+				ret = -EOPNOTSUPP;
+			else
+				file->f_mode |= MTD_MODE_OTP_USER;
+			break;
+		default:
+			ret = -EINVAL;
+		case MTD_OTP_OFF:
+			break;
+		}
+		break;
+	}
+
+	case OTPGETREGIONCOUNT:
+	case OTPGETREGIONINFO:
+	{
+		struct otp_info *buf = kmalloc(4096, GFP_KERNEL);
+		if (!buf)
+			return -ENOMEM;
+		ret = -EOPNOTSUPP;
+		switch (file->f_mode & MTD_MODE_MASK) {
+		case MTD_MODE_OTP_FACT:
+			if (mtd->get_fact_prot_info)
+				ret = mtd->get_fact_prot_info(mtd, buf, 4096);
+			break;
+		case MTD_MODE_OTP_USER:
+			if (mtd->get_user_prot_info)
+				ret = mtd->get_user_prot_info(mtd, buf, 4096);
+			break;
+		}
+		if (ret >= 0) {
+			if (cmd == OTPGETREGIONCOUNT) {
+				int nbr = ret / sizeof(struct otp_info);
+				ret = copy_to_user(argp, &nbr, sizeof(int));
+			} else
+				ret = copy_to_user(argp, buf, ret);
+			if (ret)
+				ret = -EFAULT;
+		}
+		kfree(buf);
+		break;
+	}
+
+	case OTPLOCK:
+	{
+		struct otp_info info;
+
+		if ((file->f_mode & MTD_MODE_MASK) != MTD_MODE_OTP_USER)
+			return -EINVAL;
+		if (copy_from_user(&info, argp, sizeof(info)))
+			return -EFAULT;
+		if (!mtd->lock_user_prot_reg)
+			return -EOPNOTSUPP;
+		ret = mtd->lock_user_prot_reg(mtd, info.start, info.length);
+		break;
+	}
+#endif
+
 	default:
 		ret = -ENOTTY;
 	}

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
new file mode 100644
index 000000000000..510ad78312cc
--- /dev/null
+++ b/drivers/mtd/mtdchar.c
@@ -0,0 +1,562 @@
+/*
+ * $Id: mtdchar.c,v 1.66 2005/01/05 18:05:11 dwmw2 Exp $
+ *
+ * Character-device access to raw MTD devices.
+ *
+ */
+
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/compatmac.h>
+#include <linux/slab.h>
+#include <linux/init.h>
+#include <linux/fs.h>
+#include <asm/uaccess.h>
+
+#ifdef CONFIG_DEVFS_FS
+#include <linux/devfs_fs_kernel.h>
+
+static void mtd_notify_add(struct mtd_info* mtd)
+{
+	if (!mtd)
+		return;
+
+	devfs_mk_cdev(MKDEV(MTD_CHAR_MAJOR, mtd->index*2),
+		      S_IFCHR | S_IRUGO | S_IWUGO, "mtd/%d", mtd->index);
+		
+	devfs_mk_cdev(MKDEV(MTD_CHAR_MAJOR, mtd->index*2+1),
+		      S_IFCHR | S_IRUGO, "mtd/%dro", mtd->index);
+}
+
+static void mtd_notify_remove(struct mtd_info* mtd)
+{
+	if (!mtd)
+		return;
+	devfs_remove("mtd/%d", mtd->index);
+	devfs_remove("mtd/%dro", mtd->index);
+}
+
+static struct mtd_notifier notifier = {
+	.add	= mtd_notify_add,
+	.remove	= mtd_notify_remove,
+};
+
+static inline void mtdchar_devfs_init(void)
+{
+	devfs_mk_dir("mtd");
+	register_mtd_user(&notifier);
+}
+
+static inline void mtdchar_devfs_exit(void)
+{
+	unregister_mtd_user(&notifier);
+	devfs_remove("mtd");
+}
+#else /* !DEVFS */
+#define mtdchar_devfs_init() do { } while(0)
+#define mtdchar_devfs_exit() do { } while(0)
+#endif
+
+static loff_t mtd_lseek (struct file *file, loff_t offset, int orig)
+{
+	struct mtd_info *mtd = file->private_data;
+
+	switch (orig) {
+	case 0:
+		/* SEEK_SET */
+		file->f_pos = offset;
+		break;
+	case 1:
+		/* SEEK_CUR */
+		file->f_pos += offset;
+		break;
+	case 2:
+		/* SEEK_END */
+		file->f_pos =mtd->size + offset;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	if (file->f_pos < 0)
+		file->f_pos = 0;
+	else if (file->f_pos >= mtd->size)
+		file->f_pos = mtd->size - 1;
+
+	return file->f_pos;
+}
+
+
+
+static int mtd_open(struct inode *inode, struct file *file)
+{
+	int minor = iminor(inode);
+	int devnum = minor >> 1;
+	struct mtd_info *mtd;
+
+	DEBUG(MTD_DEBUG_LEVEL0, "MTD_open\n");
+
+	if (devnum >= MAX_MTD_DEVICES)
+		return -ENODEV;
+
+	/* You can't open the RO devices RW */
+	if ((file->f_mode & 2) && (minor & 1))
+		return -EACCES;
+
+	mtd = get_mtd_device(NULL, devnum);
+	
+	if (!mtd)
+		return -ENODEV;
+	
+	if (MTD_ABSENT == mtd->type) {
+		put_mtd_device(mtd);
+		return -ENODEV;
+	}
+
+	file->private_data = mtd;
+		
+	/* You can't open it RW if it's not a writeable device */
+	if ((file->f_mode & 2) && !(mtd->flags & MTD_WRITEABLE)) {
+		put_mtd_device(mtd);
+		return -EACCES;
+	}
+		
+	return 0;
+} /* mtd_open */
+
+/*====================================================================*/
+
+static int mtd_close(struct inode *inode, struct file *file)
+{
+	struct mtd_info *mtd;
+
+	DEBUG(MTD_DEBUG_LEVEL0, "MTD_close\n");
+
+	mtd = file->private_data;
+	
+	if (mtd->sync)
+		mtd->sync(mtd);
+	
+	put_mtd_device(mtd);
+
+	return 0;
+} /* mtd_close */
+
+/* FIXME: This _really_ needs to die. In 2.5, we should lock the
+   userspace buffer down and use it directly with readv/writev.
+*/
+#define MAX_KMALLOC_SIZE 0x20000
+
+static ssize_t mtd_read(struct file *file, char __user *buf, size_t count,loff_t *ppos)
+{
+	struct mtd_info *mtd = file->private_data;
+	size_t retlen=0;
+	size_t total_retlen=0;
+	int ret=0;
+	int len;
+	char *kbuf;
+	
+	DEBUG(MTD_DEBUG_LEVEL0,"MTD_read\n");
+
+	if (*ppos + count > mtd->size)
+		count = mtd->size - *ppos;
+
+	if (!count)
+		return 0;
+	
+	/* FIXME: Use kiovec in 2.5 to lock down the user's buffers
+	   and pass them directly to the MTD functions */
+	while (count) {
+		if (count > MAX_KMALLOC_SIZE) 
+			len = MAX_KMALLOC_SIZE;
+		else
+			len = count;
+
+		kbuf=kmalloc(len,GFP_KERNEL);
+		if (!kbuf)
+			return -ENOMEM;
+		
+		ret = MTD_READ(mtd, *ppos, len, &retlen, kbuf);
+		/* Nand returns -EBADMSG on ecc errors, but it returns
+		 * the data. For our userspace tools it is important
+		 * to dump areas with ecc errors ! 
+		 * Userspace software which accesses NAND this way
+		 * must be aware of the fact that it deals with NAND
+		 */
+		if (!ret || (ret == -EBADMSG)) {
+			*ppos += retlen;
+			if (copy_to_user(buf, kbuf, retlen)) {
+			        kfree(kbuf);
+				return -EFAULT;
+			}
+			else
+				total_retlen += retlen;
+
+			count -= retlen;
+			buf += retlen;
+		}
+		else {
+			kfree(kbuf);
+			return ret;
+		}
+		
+		kfree(kbuf);
+	}
+
+	return total_retlen;
+} /* mtd_read */
+
+static ssize_t mtd_write(struct file *file, const char __user *buf, size_t count,loff_t *ppos)
+{
+	struct mtd_info *mtd = file->private_data;
+	char *kbuf;
+	size_t retlen;
+	size_t total_retlen=0;
+	int ret=0;
+	int len;
+
+	DEBUG(MTD_DEBUG_LEVEL0,"MTD_write\n");
+	
+	if (*ppos == mtd->size)
+		return -ENOSPC;
+	
+	if (*ppos + count > mtd->size)
+		count = mtd->size - *ppos;
+
+	if (!count)
+		return 0;
+
+	while (count) {
+		if (count > MAX_KMALLOC_SIZE) 
+			len = MAX_KMALLOC_SIZE;
+		else
+			len = count;
+
+		kbuf=kmalloc(len,GFP_KERNEL);
+		if (!kbuf) {
+			printk("kmalloc is null\n");
+			return -ENOMEM;
+		}
+
+		if (copy_from_user(kbuf, buf, len)) {
+			kfree(kbuf);
+			return -EFAULT;
+		}
+		
+	        ret = (*(mtd->write))(mtd, *ppos, len, &retlen, kbuf);
+		if (!ret) {
+			*ppos += retlen;
+			total_retlen += retlen;
+			count -= retlen;
+			buf += retlen;
+		}
+		else {
+			kfree(kbuf);
+			return ret;
+		}
+		
+		kfree(kbuf);
+	}
+
+	return total_retlen;
+} /* mtd_write */
+
+/*======================================================================
+
+    IOCTL calls for getting device parameters.
+
+======================================================================*/
+static void mtdchar_erase_callback (struct erase_info *instr)
+{
+	wake_up((wait_queue_head_t *)instr->priv);
+}
+
+static int mtd_ioctl(struct inode *inode, struct file *file,
+		     u_int cmd, u_long arg)
+{
+	struct mtd_info *mtd = file->private_data;
+	void __user *argp = (void __user *)arg;
+	int ret = 0;
+	u_long size;
+	
+	DEBUG(MTD_DEBUG_LEVEL0, "MTD_ioctl\n");
+
+	size = (cmd & IOCSIZE_MASK) >> IOCSIZE_SHIFT;
+	if (cmd & IOC_IN) {
+		if (!access_ok(VERIFY_READ, argp, size))
+			return -EFAULT;
+	}
+	if (cmd & IOC_OUT) {
+		if (!access_ok(VERIFY_WRITE, argp, size))
+			return -EFAULT;
+	}
+	
+	switch (cmd) {
+	case MEMGETREGIONCOUNT:
+		if (copy_to_user(argp, &(mtd->numeraseregions), sizeof(int)))
+			return -EFAULT;
+		break;
+
+	case MEMGETREGIONINFO:
+	{
+		struct region_info_user ur;
+
+		if (copy_from_user(&ur, argp, sizeof(struct region_info_user)))
+			return -EFAULT;
+
+		if (ur.regionindex >= mtd->numeraseregions)
+			return -EINVAL;
+		if (copy_to_user(argp, &(mtd->eraseregions[ur.regionindex]),
+				sizeof(struct mtd_erase_region_info)))
+			return -EFAULT;
+		break;
+	}
+
+	case MEMGETINFO:
+		if (copy_to_user(argp, mtd, sizeof(struct mtd_info_user)))
+			return -EFAULT;
+		break;
+
+	case MEMERASE:
+	{
+		struct erase_info *erase;
+
+		if(!(file->f_mode & 2))
+			return -EPERM;
+
+		erase=kmalloc(sizeof(struct erase_info),GFP_KERNEL);
+		if (!erase)
+			ret = -ENOMEM;
+		else {
+			wait_queue_head_t waitq;
+			DECLARE_WAITQUEUE(wait, current);
+
+			init_waitqueue_head(&waitq);
+
+			memset (erase,0,sizeof(struct erase_info));
+			if (copy_from_user(&erase->addr, argp,
+				    sizeof(struct erase_info_user))) {
+				kfree(erase);
+				return -EFAULT;
+			}
+			erase->mtd = mtd;
+			erase->callback = mtdchar_erase_callback;
+			erase->priv = (unsigned long)&waitq;
+			
+			/*
+			  FIXME: Allow INTERRUPTIBLE. Which means
+			  not having the wait_queue head on the stack.
+			  
+			  If the wq_head is on the stack, and we
+			  leave because we got interrupted, then the
+			  wq_head is no longer there when the
+			  callback routine tries to wake us up.
+			*/
+			ret = mtd->erase(mtd, erase);
+			if (!ret) {
+				set_current_state(TASK_UNINTERRUPTIBLE);
+				add_wait_queue(&waitq, &wait);
+				if (erase->state != MTD_ERASE_DONE &&
+				    erase->state != MTD_ERASE_FAILED)
+					schedule();
+				remove_wait_queue(&waitq, &wait);
+				set_current_state(TASK_RUNNING);
+
+				ret = (erase->state == MTD_ERASE_FAILED)?-EIO:0;
+			}
+			kfree(erase);
+		}
+		break;
+	}
+
+	case MEMWRITEOOB:
+	{
+		struct mtd_oob_buf buf;
+		void *databuf;
+		ssize_t retlen;
+		
+		if(!(file->f_mode & 2))
+			return -EPERM;
+
+		if (copy_from_user(&buf, argp, sizeof(struct mtd_oob_buf)))
+			return -EFAULT;
+		
+		if (buf.length > 0x4096)
+			return -EINVAL;
+
+		if (!mtd->write_oob)
+			ret = -EOPNOTSUPP;
+		else
+			ret = access_ok(VERIFY_READ, buf.ptr,
+					buf.length) ? 0 : EFAULT;
+
+		if (ret)
+			return ret;
+
+		databuf = kmalloc(buf.length, GFP_KERNEL);
+		if (!databuf)
+			return -ENOMEM;
+		
+		if (copy_from_user(databuf, buf.ptr, buf.length)) {
+			kfree(databuf);
+			return -EFAULT;
+		}
+
+		ret = (mtd->write_oob)(mtd, buf.start, buf.length, &retlen, databuf);
+
+		if (copy_to_user(argp + sizeof(uint32_t), &retlen, sizeof(uint32_t)))
+			ret = -EFAULT;
+
+		kfree(databuf);
+		break;
+
+	}
+
+	case MEMREADOOB:
+	{
+		struct mtd_oob_buf buf;
+		void *databuf;
+		ssize_t retlen;
+
+		if (copy_from_user(&buf, argp, sizeof(struct mtd_oob_buf)))
+			return -EFAULT;
+		
+		if (buf.length > 0x4096)
+			return -EINVAL;
+
+		if (!mtd->read_oob)
+			ret = -EOPNOTSUPP;
+		else
+			ret = access_ok(VERIFY_WRITE, buf.ptr,
+					buf.length) ? 0 : -EFAULT;
+
+		if (ret)
+			return ret;
+
+		databuf = kmalloc(buf.length, GFP_KERNEL);
+		if (!databuf)
+			return -ENOMEM;
+		
+		ret = (mtd->read_oob)(mtd, buf.start, buf.length, &retlen, databuf);
+
+		if (put_user(retlen, (uint32_t __user *)argp))
+			ret = -EFAULT;
+		else if (retlen && copy_to_user(buf.ptr, databuf, retlen))
+			ret = -EFAULT;
+		
+		kfree(databuf);
+		break;
+	}
+
+	case MEMLOCK:
+	{
+		struct erase_info_user info;
+
+		if (copy_from_user(&info, argp, sizeof(info)))
+			return -EFAULT;
+
+		if (!mtd->lock)
+			ret = -EOPNOTSUPP;
+		else
+			ret = mtd->lock(mtd, info.start, info.length);
+		break;
+	}
+
+	case MEMUNLOCK:
+	{
+		struct erase_info_user info;
+
+		if (copy_from_user(&info, argp, sizeof(info)))
+			return -EFAULT;
+
+		if (!mtd->unlock)
+			ret = -EOPNOTSUPP;
+		else
+			ret = mtd->unlock(mtd, info.start, info.length);
+		break;
+	}
+
+	case MEMSETOOBSEL:
+	{
+		if (copy_from_user(&mtd->oobinfo, argp, sizeof(struct nand_oobinfo)))
+			return -EFAULT;
+		break;
+	}
+
+	case MEMGETOOBSEL:
+	{
+		if (copy_to_user(argp, &(mtd->oobinfo), sizeof(struct nand_oobinfo)))
+			return -EFAULT;
+		break;
+	}
+
+	case MEMGETBADBLOCK:
+	{
+		loff_t offs;
+		
+		if (copy_from_user(&offs, argp, sizeof(loff_t)))
+			return -EFAULT;
+		if (!mtd->block_isbad)
+			ret = -EOPNOTSUPP;
+		else
+			return mtd->block_isbad(mtd, offs);
+		break;
+	}
+
+	case MEMSETBADBLOCK:
+	{
+		loff_t offs;
+
+		if (copy_from_user(&offs, argp, sizeof(loff_t)))
+			return -EFAULT;
+		if (!mtd->block_markbad)
+			ret = -EOPNOTSUPP;
+		else
+			return mtd->block_markbad(mtd, offs);
+		break;
+	}
+
+	default:
+		ret = -ENOTTY;
+	}
+
+	return ret;
+} /* memory_ioctl */
+
+static struct file_operations mtd_fops = {
+	.owner		= THIS_MODULE,
+	.llseek		= mtd_lseek,
+	.read		= mtd_read,
+	.write		= mtd_write,
+	.ioctl		= mtd_ioctl,
+	.open		= mtd_open,
+	.release	= mtd_close,
+};
+
+static int __init init_mtdchar(void)
+{
+	if (register_chrdev(MTD_CHAR_MAJOR, "mtd", &mtd_fops)) {
+		printk(KERN_NOTICE "Can't allocate major number %d for Memory Technology Devices.\n",
+		       MTD_CHAR_MAJOR);
+		return -EAGAIN;
+	}
+
+	mtdchar_devfs_init();
+	return 0;
+}
+
+static void __exit cleanup_mtdchar(void)
+{
+	mtdchar_devfs_exit();
+	unregister_chrdev(MTD_CHAR_MAJOR, "mtd");
+}
+
+module_init(init_mtdchar);
+module_exit(cleanup_mtdchar);
+
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("David Woodhouse <dwmw2@infradead.org>");
+MODULE_DESCRIPTION("Direct character-device access to MTD devices");
