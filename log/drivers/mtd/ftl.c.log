commit 42bc47b35320e0e587a88e437e18f80f9c5bcbb2
Author: Kees Cook <keescook@chromium.org>
Date:   Tue Jun 12 14:27:11 2018 -0700

    treewide: Use array_size() in vmalloc()
    
    The vmalloc() function has no 2-factor argument form, so multiplication
    factors need to be wrapped in array_size(). This patch replaces cases of:
    
            vmalloc(a * b)
    
    with:
            vmalloc(array_size(a, b))
    
    as well as handling cases of:
    
            vmalloc(a * b * c)
    
    with:
    
            vmalloc(array3_size(a, b, c))
    
    This does, however, attempt to ignore constant size factors like:
    
            vmalloc(4 * 1024)
    
    though any constants defined via macros get caught up in the conversion.
    
    Any factors with a sizeof() of "unsigned char", "char", and "u8" were
    dropped, since they're redundant.
    
    The Coccinelle script used for this was:
    
    // Fix redundant parens around sizeof().
    @@
    type TYPE;
    expression THING, E;
    @@
    
    (
      vmalloc(
    -       (sizeof(TYPE)) * E
    +       sizeof(TYPE) * E
      , ...)
    |
      vmalloc(
    -       (sizeof(THING)) * E
    +       sizeof(THING) * E
      , ...)
    )
    
    // Drop single-byte sizes and redundant parens.
    @@
    expression COUNT;
    typedef u8;
    typedef __u8;
    @@
    
    (
      vmalloc(
    -       sizeof(u8) * (COUNT)
    +       COUNT
      , ...)
    |
      vmalloc(
    -       sizeof(__u8) * (COUNT)
    +       COUNT
      , ...)
    |
      vmalloc(
    -       sizeof(char) * (COUNT)
    +       COUNT
      , ...)
    |
      vmalloc(
    -       sizeof(unsigned char) * (COUNT)
    +       COUNT
      , ...)
    |
      vmalloc(
    -       sizeof(u8) * COUNT
    +       COUNT
      , ...)
    |
      vmalloc(
    -       sizeof(__u8) * COUNT
    +       COUNT
      , ...)
    |
      vmalloc(
    -       sizeof(char) * COUNT
    +       COUNT
      , ...)
    |
      vmalloc(
    -       sizeof(unsigned char) * COUNT
    +       COUNT
      , ...)
    )
    
    // 2-factor product with sizeof(type/expression) and identifier or constant.
    @@
    type TYPE;
    expression THING;
    identifier COUNT_ID;
    constant COUNT_CONST;
    @@
    
    (
      vmalloc(
    -       sizeof(TYPE) * (COUNT_ID)
    +       array_size(COUNT_ID, sizeof(TYPE))
      , ...)
    |
      vmalloc(
    -       sizeof(TYPE) * COUNT_ID
    +       array_size(COUNT_ID, sizeof(TYPE))
      , ...)
    |
      vmalloc(
    -       sizeof(TYPE) * (COUNT_CONST)
    +       array_size(COUNT_CONST, sizeof(TYPE))
      , ...)
    |
      vmalloc(
    -       sizeof(TYPE) * COUNT_CONST
    +       array_size(COUNT_CONST, sizeof(TYPE))
      , ...)
    |
      vmalloc(
    -       sizeof(THING) * (COUNT_ID)
    +       array_size(COUNT_ID, sizeof(THING))
      , ...)
    |
      vmalloc(
    -       sizeof(THING) * COUNT_ID
    +       array_size(COUNT_ID, sizeof(THING))
      , ...)
    |
      vmalloc(
    -       sizeof(THING) * (COUNT_CONST)
    +       array_size(COUNT_CONST, sizeof(THING))
      , ...)
    |
      vmalloc(
    -       sizeof(THING) * COUNT_CONST
    +       array_size(COUNT_CONST, sizeof(THING))
      , ...)
    )
    
    // 2-factor product, only identifiers.
    @@
    identifier SIZE, COUNT;
    @@
    
      vmalloc(
    -       SIZE * COUNT
    +       array_size(COUNT, SIZE)
      , ...)
    
    // 3-factor product with 1 sizeof(type) or sizeof(expression), with
    // redundant parens removed.
    @@
    expression THING;
    identifier STRIDE, COUNT;
    type TYPE;
    @@
    
    (
      vmalloc(
    -       sizeof(TYPE) * (COUNT) * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      vmalloc(
    -       sizeof(TYPE) * (COUNT) * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      vmalloc(
    -       sizeof(TYPE) * COUNT * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      vmalloc(
    -       sizeof(TYPE) * COUNT * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      vmalloc(
    -       sizeof(THING) * (COUNT) * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    |
      vmalloc(
    -       sizeof(THING) * (COUNT) * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    |
      vmalloc(
    -       sizeof(THING) * COUNT * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    |
      vmalloc(
    -       sizeof(THING) * COUNT * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    )
    
    // 3-factor product with 2 sizeof(variable), with redundant parens removed.
    @@
    expression THING1, THING2;
    identifier COUNT;
    type TYPE1, TYPE2;
    @@
    
    (
      vmalloc(
    -       sizeof(TYPE1) * sizeof(TYPE2) * COUNT
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(TYPE2))
      , ...)
    |
      vmalloc(
    -       sizeof(TYPE1) * sizeof(THING2) * (COUNT)
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(TYPE2))
      , ...)
    |
      vmalloc(
    -       sizeof(THING1) * sizeof(THING2) * COUNT
    +       array3_size(COUNT, sizeof(THING1), sizeof(THING2))
      , ...)
    |
      vmalloc(
    -       sizeof(THING1) * sizeof(THING2) * (COUNT)
    +       array3_size(COUNT, sizeof(THING1), sizeof(THING2))
      , ...)
    |
      vmalloc(
    -       sizeof(TYPE1) * sizeof(THING2) * COUNT
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(THING2))
      , ...)
    |
      vmalloc(
    -       sizeof(TYPE1) * sizeof(THING2) * (COUNT)
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(THING2))
      , ...)
    )
    
    // 3-factor product, only identifiers, with redundant parens removed.
    @@
    identifier STRIDE, SIZE, COUNT;
    @@
    
    (
      vmalloc(
    -       (COUNT) * STRIDE * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      vmalloc(
    -       COUNT * (STRIDE) * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      vmalloc(
    -       COUNT * STRIDE * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      vmalloc(
    -       (COUNT) * (STRIDE) * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      vmalloc(
    -       COUNT * (STRIDE) * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      vmalloc(
    -       (COUNT) * STRIDE * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      vmalloc(
    -       (COUNT) * (STRIDE) * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      vmalloc(
    -       COUNT * STRIDE * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    )
    
    // Any remaining multi-factor products, first at least 3-factor products
    // when they're not all constants...
    @@
    expression E1, E2, E3;
    constant C1, C2, C3;
    @@
    
    (
      vmalloc(C1 * C2 * C3, ...)
    |
      vmalloc(
    -       E1 * E2 * E3
    +       array3_size(E1, E2, E3)
      , ...)
    )
    
    // And then all remaining 2 factors products when they're not all constants.
    @@
    expression E1, E2;
    constant C1, C2;
    @@
    
    (
      vmalloc(C1 * C2, ...)
    |
      vmalloc(
    -       E1 * E2
    +       array_size(E1, E2)
      , ...)
    )
    
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/drivers/mtd/ftl.c b/drivers/mtd/ftl.c
index 1f8063c6aed1..2578f27914ef 100644
--- a/drivers/mtd/ftl.c
+++ b/drivers/mtd/ftl.c
@@ -263,7 +263,7 @@ static int build_maps(partition_t *part)
 
     /* Set up virtual page map */
     blocks = le32_to_cpu(header.FormattedSize) >> header.BlockSize;
-    part->VirtualBlockMap = vmalloc(blocks * sizeof(uint32_t));
+    part->VirtualBlockMap = vmalloc(array_size(blocks, sizeof(uint32_t)));
     if (!part->VirtualBlockMap)
 	    goto out_XferInfo;
 

commit 6da2ec56059c3c7a7e5f729e6349e74ace1e5c57
Author: Kees Cook <keescook@chromium.org>
Date:   Tue Jun 12 13:55:00 2018 -0700

    treewide: kmalloc() -> kmalloc_array()
    
    The kmalloc() function has a 2-factor argument form, kmalloc_array(). This
    patch replaces cases of:
    
            kmalloc(a * b, gfp)
    
    with:
            kmalloc_array(a * b, gfp)
    
    as well as handling cases of:
    
            kmalloc(a * b * c, gfp)
    
    with:
    
            kmalloc(array3_size(a, b, c), gfp)
    
    as it's slightly less ugly than:
    
            kmalloc_array(array_size(a, b), c, gfp)
    
    This does, however, attempt to ignore constant size factors like:
    
            kmalloc(4 * 1024, gfp)
    
    though any constants defined via macros get caught up in the conversion.
    
    Any factors with a sizeof() of "unsigned char", "char", and "u8" were
    dropped, since they're redundant.
    
    The tools/ directory was manually excluded, since it has its own
    implementation of kmalloc().
    
    The Coccinelle script used for this was:
    
    // Fix redundant parens around sizeof().
    @@
    type TYPE;
    expression THING, E;
    @@
    
    (
      kmalloc(
    -       (sizeof(TYPE)) * E
    +       sizeof(TYPE) * E
      , ...)
    |
      kmalloc(
    -       (sizeof(THING)) * E
    +       sizeof(THING) * E
      , ...)
    )
    
    // Drop single-byte sizes and redundant parens.
    @@
    expression COUNT;
    typedef u8;
    typedef __u8;
    @@
    
    (
      kmalloc(
    -       sizeof(u8) * (COUNT)
    +       COUNT
      , ...)
    |
      kmalloc(
    -       sizeof(__u8) * (COUNT)
    +       COUNT
      , ...)
    |
      kmalloc(
    -       sizeof(char) * (COUNT)
    +       COUNT
      , ...)
    |
      kmalloc(
    -       sizeof(unsigned char) * (COUNT)
    +       COUNT
      , ...)
    |
      kmalloc(
    -       sizeof(u8) * COUNT
    +       COUNT
      , ...)
    |
      kmalloc(
    -       sizeof(__u8) * COUNT
    +       COUNT
      , ...)
    |
      kmalloc(
    -       sizeof(char) * COUNT
    +       COUNT
      , ...)
    |
      kmalloc(
    -       sizeof(unsigned char) * COUNT
    +       COUNT
      , ...)
    )
    
    // 2-factor product with sizeof(type/expression) and identifier or constant.
    @@
    type TYPE;
    expression THING;
    identifier COUNT_ID;
    constant COUNT_CONST;
    @@
    
    (
    - kmalloc
    + kmalloc_array
      (
    -       sizeof(TYPE) * (COUNT_ID)
    +       COUNT_ID, sizeof(TYPE)
      , ...)
    |
    - kmalloc
    + kmalloc_array
      (
    -       sizeof(TYPE) * COUNT_ID
    +       COUNT_ID, sizeof(TYPE)
      , ...)
    |
    - kmalloc
    + kmalloc_array
      (
    -       sizeof(TYPE) * (COUNT_CONST)
    +       COUNT_CONST, sizeof(TYPE)
      , ...)
    |
    - kmalloc
    + kmalloc_array
      (
    -       sizeof(TYPE) * COUNT_CONST
    +       COUNT_CONST, sizeof(TYPE)
      , ...)
    |
    - kmalloc
    + kmalloc_array
      (
    -       sizeof(THING) * (COUNT_ID)
    +       COUNT_ID, sizeof(THING)
      , ...)
    |
    - kmalloc
    + kmalloc_array
      (
    -       sizeof(THING) * COUNT_ID
    +       COUNT_ID, sizeof(THING)
      , ...)
    |
    - kmalloc
    + kmalloc_array
      (
    -       sizeof(THING) * (COUNT_CONST)
    +       COUNT_CONST, sizeof(THING)
      , ...)
    |
    - kmalloc
    + kmalloc_array
      (
    -       sizeof(THING) * COUNT_CONST
    +       COUNT_CONST, sizeof(THING)
      , ...)
    )
    
    // 2-factor product, only identifiers.
    @@
    identifier SIZE, COUNT;
    @@
    
    - kmalloc
    + kmalloc_array
      (
    -       SIZE * COUNT
    +       COUNT, SIZE
      , ...)
    
    // 3-factor product with 1 sizeof(type) or sizeof(expression), with
    // redundant parens removed.
    @@
    expression THING;
    identifier STRIDE, COUNT;
    type TYPE;
    @@
    
    (
      kmalloc(
    -       sizeof(TYPE) * (COUNT) * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      kmalloc(
    -       sizeof(TYPE) * (COUNT) * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      kmalloc(
    -       sizeof(TYPE) * COUNT * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      kmalloc(
    -       sizeof(TYPE) * COUNT * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      kmalloc(
    -       sizeof(THING) * (COUNT) * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    |
      kmalloc(
    -       sizeof(THING) * (COUNT) * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    |
      kmalloc(
    -       sizeof(THING) * COUNT * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    |
      kmalloc(
    -       sizeof(THING) * COUNT * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    )
    
    // 3-factor product with 2 sizeof(variable), with redundant parens removed.
    @@
    expression THING1, THING2;
    identifier COUNT;
    type TYPE1, TYPE2;
    @@
    
    (
      kmalloc(
    -       sizeof(TYPE1) * sizeof(TYPE2) * COUNT
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(TYPE2))
      , ...)
    |
      kmalloc(
    -       sizeof(TYPE1) * sizeof(THING2) * (COUNT)
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(TYPE2))
      , ...)
    |
      kmalloc(
    -       sizeof(THING1) * sizeof(THING2) * COUNT
    +       array3_size(COUNT, sizeof(THING1), sizeof(THING2))
      , ...)
    |
      kmalloc(
    -       sizeof(THING1) * sizeof(THING2) * (COUNT)
    +       array3_size(COUNT, sizeof(THING1), sizeof(THING2))
      , ...)
    |
      kmalloc(
    -       sizeof(TYPE1) * sizeof(THING2) * COUNT
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(THING2))
      , ...)
    |
      kmalloc(
    -       sizeof(TYPE1) * sizeof(THING2) * (COUNT)
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(THING2))
      , ...)
    )
    
    // 3-factor product, only identifiers, with redundant parens removed.
    @@
    identifier STRIDE, SIZE, COUNT;
    @@
    
    (
      kmalloc(
    -       (COUNT) * STRIDE * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kmalloc(
    -       COUNT * (STRIDE) * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kmalloc(
    -       COUNT * STRIDE * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kmalloc(
    -       (COUNT) * (STRIDE) * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kmalloc(
    -       COUNT * (STRIDE) * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kmalloc(
    -       (COUNT) * STRIDE * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kmalloc(
    -       (COUNT) * (STRIDE) * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kmalloc(
    -       COUNT * STRIDE * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    )
    
    // Any remaining multi-factor products, first at least 3-factor products,
    // when they're not all constants...
    @@
    expression E1, E2, E3;
    constant C1, C2, C3;
    @@
    
    (
      kmalloc(C1 * C2 * C3, ...)
    |
      kmalloc(
    -       (E1) * E2 * E3
    +       array3_size(E1, E2, E3)
      , ...)
    |
      kmalloc(
    -       (E1) * (E2) * E3
    +       array3_size(E1, E2, E3)
      , ...)
    |
      kmalloc(
    -       (E1) * (E2) * (E3)
    +       array3_size(E1, E2, E3)
      , ...)
    |
      kmalloc(
    -       E1 * E2 * E3
    +       array3_size(E1, E2, E3)
      , ...)
    )
    
    // And then all remaining 2 factors products when they're not all constants,
    // keeping sizeof() as the second factor argument.
    @@
    expression THING, E1, E2;
    type TYPE;
    constant C1, C2, C3;
    @@
    
    (
      kmalloc(sizeof(THING) * C2, ...)
    |
      kmalloc(sizeof(TYPE) * C2, ...)
    |
      kmalloc(C1 * C2 * C3, ...)
    |
      kmalloc(C1 * C2, ...)
    |
    - kmalloc
    + kmalloc_array
      (
    -       sizeof(TYPE) * (E2)
    +       E2, sizeof(TYPE)
      , ...)
    |
    - kmalloc
    + kmalloc_array
      (
    -       sizeof(TYPE) * E2
    +       E2, sizeof(TYPE)
      , ...)
    |
    - kmalloc
    + kmalloc_array
      (
    -       sizeof(THING) * (E2)
    +       E2, sizeof(THING)
      , ...)
    |
    - kmalloc
    + kmalloc_array
      (
    -       sizeof(THING) * E2
    +       E2, sizeof(THING)
      , ...)
    |
    - kmalloc
    + kmalloc_array
      (
    -       (E1) * E2
    +       E1, E2
      , ...)
    |
    - kmalloc
    + kmalloc_array
      (
    -       (E1) * (E2)
    +       E1, E2
      , ...)
    |
    - kmalloc
    + kmalloc_array
      (
    -       E1 * E2
    +       E1, E2
      , ...)
    )
    
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/drivers/mtd/ftl.c b/drivers/mtd/ftl.c
index ef6ad2551d57..1f8063c6aed1 100644
--- a/drivers/mtd/ftl.c
+++ b/drivers/mtd/ftl.c
@@ -201,15 +201,16 @@ static int build_maps(partition_t *part)
     /* Set up erase unit maps */
     part->DataUnits = le16_to_cpu(part->header.NumEraseUnits) -
 	part->header.NumTransferUnits;
-    part->EUNInfo = kmalloc(part->DataUnits * sizeof(struct eun_info_t),
-			    GFP_KERNEL);
+    part->EUNInfo = kmalloc_array(part->DataUnits, sizeof(struct eun_info_t),
+                                  GFP_KERNEL);
     if (!part->EUNInfo)
 	    goto out;
     for (i = 0; i < part->DataUnits; i++)
 	part->EUNInfo[i].Offset = 0xffffffff;
     part->XferInfo =
-	kmalloc(part->header.NumTransferUnits * sizeof(struct xfer_info_t),
-		GFP_KERNEL);
+	kmalloc_array(part->header.NumTransferUnits,
+                      sizeof(struct xfer_info_t),
+                      GFP_KERNEL);
     if (!part->XferInfo)
 	    goto out_EUNInfo;
 
@@ -269,8 +270,8 @@ static int build_maps(partition_t *part)
     memset(part->VirtualBlockMap, 0xff, blocks * sizeof(uint32_t));
     part->BlocksPerUnit = (1 << header.EraseUnitSize) >> header.BlockSize;
 
-    part->bam_cache = kmalloc(part->BlocksPerUnit * sizeof(uint32_t),
-			      GFP_KERNEL);
+    part->bam_cache = kmalloc_array(part->BlocksPerUnit, sizeof(uint32_t),
+                                    GFP_KERNEL);
     if (!part->bam_cache)
 	    goto out_VirtualBlockMap;
 

commit b756816dad0aaca4f57c857a86a6a4a85a9f478b
Author: Arushi Singhal <arushisinghal19971997@gmail.com>
Date:   Sun Mar 25 21:07:43 2018 +0530

    mtd: ftl: Use DIV_ROUND_UP()
    
    The kernel.h macro DIV_ROUND_UP performs the computation
    (((n) + (d) - 1) / (d)) but is perhaps more readable.
    
    Signed-off-by: Arushi Singhal <arushisinghal19971997@gmail.com>
    Signed-off-by: Boris Brezillon <boris.brezillon@bootlin.com>

diff --git a/drivers/mtd/ftl.c b/drivers/mtd/ftl.c
index 0a6adfaec7b5..ef6ad2551d57 100644
--- a/drivers/mtd/ftl.c
+++ b/drivers/mtd/ftl.c
@@ -393,8 +393,8 @@ static int prepare_xfer(partition_t *part, int i)
     }
 
     /* Write the BAM stub */
-    nbam = (part->BlocksPerUnit * sizeof(uint32_t) +
-	    le32_to_cpu(part->header.BAMOffset) + SECTOR_SIZE - 1) / SECTOR_SIZE;
+    nbam = DIV_ROUND_UP(part->BlocksPerUnit * sizeof(uint32_t) +
+			le32_to_cpu(part->header.BAMOffset), SECTOR_SIZE);
 
     offset = xfer->Offset + le32_to_cpu(part->header.BAMOffset);
     ctl = cpu_to_le32(BLOCK_CONTROL);

commit 8f347c4232d5fc097599b711a3385722a6834005
Author: Boris Brezillon <boris.brezillon@bootlin.com>
Date:   Mon Feb 12 22:03:10 2018 +0100

    mtd: Unconditionally update ->fail_addr and ->addr in part_erase()
    
    ->fail_addr and ->addr can be updated no matter the result of
    parent->_erase(), we just need to remove the code doing the same thing
    in mtd_erase_callback() to avoid adjusting those fields twice.
    
    Note that this can be done because all MTD users have been converted to
    not pass an erase_info->callback() and are thus only taking the
    ->addr_fail and ->addr fields into account after part_erase() has
    returned.
    
    While we're at it, get rid of the erase_info->mtd field which was only
    needed to let mtd_erase_callback() get the partition device back.
    
    Signed-off-by: Boris Brezillon <boris.brezillon@bootlin.com>
    Reviewed-by: Richard Weinberger <richard@nod.at>

diff --git a/drivers/mtd/ftl.c b/drivers/mtd/ftl.c
index fcf9907e7987..0a6adfaec7b5 100644
--- a/drivers/mtd/ftl.c
+++ b/drivers/mtd/ftl.c
@@ -342,7 +342,6 @@ static int erase_xfer(partition_t *part,
     if (!erase)
             return -ENOMEM;
 
-    erase->mtd = part->mbd.mtd;
     erase->addr = xfer->Offset;
     erase->len = 1 << part->header.EraseUnitSize;
 

commit 884cfd9023ce6afe8bcf181ec988d8516eb32bf0
Author: Boris Brezillon <boris.brezillon@bootlin.com>
Date:   Mon Feb 12 22:03:09 2018 +0100

    mtd: Stop assuming mtd_erase() is asynchronous
    
    None of the mtd->_erase() implementations work in an asynchronous manner,
    so let's simplify MTD users that call mtd_erase(). All they need to do
    is check the value returned by mtd_erase() and assume that != 0 means
    failure.
    
    Signed-off-by: Boris Brezillon <boris.brezillon@bootlin.com>
    Reviewed-by: Richard Weinberger <richard@nod.at>

diff --git a/drivers/mtd/ftl.c b/drivers/mtd/ftl.c
index 664d206a4cbe..fcf9907e7987 100644
--- a/drivers/mtd/ftl.c
+++ b/drivers/mtd/ftl.c
@@ -140,12 +140,6 @@ typedef struct partition_t {
 #define XFER_PREPARED	0x03
 #define XFER_FAILED	0x04
 
-/*====================================================================*/
-
-
-static void ftl_erase_callback(struct erase_info *done);
-
-
 /*======================================================================
 
     Scan_header() checks to see if a memory region contains an FTL
@@ -349,17 +343,19 @@ static int erase_xfer(partition_t *part,
             return -ENOMEM;
 
     erase->mtd = part->mbd.mtd;
-    erase->callback = ftl_erase_callback;
     erase->addr = xfer->Offset;
     erase->len = 1 << part->header.EraseUnitSize;
-    erase->priv = (u_long)part;
 
     ret = mtd_erase(part->mbd.mtd, erase);
+    if (!ret) {
+	xfer->state = XFER_ERASED;
+	xfer->EraseCount++;
+    } else {
+	xfer->state = XFER_FAILED;
+	pr_notice("ftl_cs: erase failed: err = %d\n", ret);
+    }
 
-    if (!ret)
-	    xfer->EraseCount++;
-    else
-	    kfree(erase);
+    kfree(erase);
 
     return ret;
 } /* erase_xfer */
@@ -371,37 +367,6 @@ static int erase_xfer(partition_t *part,
 
 ======================================================================*/
 
-static void ftl_erase_callback(struct erase_info *erase)
-{
-    partition_t *part;
-    struct xfer_info_t *xfer;
-    int i;
-
-    /* Look up the transfer unit */
-    part = (partition_t *)(erase->priv);
-
-    for (i = 0; i < part->header.NumTransferUnits; i++)
-	if (part->XferInfo[i].Offset == erase->addr) break;
-
-    if (i == part->header.NumTransferUnits) {
-	printk(KERN_NOTICE "ftl_cs: internal error: "
-	       "erase lookup failed!\n");
-	return;
-    }
-
-    xfer = &part->XferInfo[i];
-    if (erase->state == MTD_ERASE_DONE)
-	xfer->state = XFER_ERASED;
-    else {
-	xfer->state = XFER_FAILED;
-	printk(KERN_NOTICE "ftl_cs: erase failed: state = %d\n",
-	       erase->state);
-    }
-
-    kfree(erase);
-
-} /* ftl_erase_callback */
-
 static int prepare_xfer(partition_t *part, int i)
 {
     erase_unit_header_t header;

commit 7c0f6ba682b9c7632072ffbedf8d328c8f3c42ba
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Dec 24 11:46:01 2016 -0800

    Replace <asm/uaccess.h> with <linux/uaccess.h> globally
    
    This was entirely automated, using the script by Al:
    
      PATT='^[[:blank:]]*#[[:blank:]]*include[[:blank:]]*<asm/uaccess.h>'
      sed -i -e "s!$PATT!#include <linux/uaccess.h>!" \
            $(git grep -l "$PATT"|grep -v ^include/linux/uaccess.h)
    
    to do the replacement at the end of the merge window.
    
    Requested-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/mtd/ftl.c b/drivers/mtd/ftl.c
index 9fb3b0dcdac2..664d206a4cbe 100644
--- a/drivers/mtd/ftl.c
+++ b/drivers/mtd/ftl.c
@@ -70,7 +70,7 @@
 #include <linux/hdreg.h>
 #include <linux/vmalloc.h>
 #include <linux/blkpg.h>
-#include <asm/uaccess.h>
+#include <linux/uaccess.h>
 
 #include <linux/mtd/ftl.h>
 

commit 6166a76f5ef7619faa28b38d7817e5fe0e509942
Author: Fabian Frederick <fabf@skynet.be>
Date:   Wed Jun 10 18:31:06 2015 +0200

    mtd: ftl: use swap() in copy_erase_unit()
    
    Use kernel.h macro definition.
    
    Thanks to Julia Lawall for Coccinelle scripting support.
    
    Signed-off-by: Fabian Frederick <fabf@skynet.be>
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>

diff --git a/drivers/mtd/ftl.c b/drivers/mtd/ftl.c
index dabf08450d0b..9fb3b0dcdac2 100644
--- a/drivers/mtd/ftl.c
+++ b/drivers/mtd/ftl.c
@@ -571,12 +571,8 @@ static int copy_erase_unit(partition_t *part, uint16_t srcunit,
 
 
     /* Update the maps and usage stats*/
-    i = xfer->EraseCount;
-    xfer->EraseCount = eun->EraseCount;
-    eun->EraseCount = i;
-    i = xfer->Offset;
-    xfer->Offset = eun->Offset;
-    eun->Offset = i;
+    swap(xfer->EraseCount, eun->EraseCount);
+    swap(xfer->Offset, eun->Offset);
     part->FreeTotal -= eun->Free;
     part->FreeTotal += free;
     eun->Free = free;

commit a152056c912db82860a8b4c23d0bd3a5aa89e363
Author: Kevin Hao <haokexin@gmail.com>
Date:   Thu Jul 3 10:35:26 2014 +0800

    mtd/ftl: fix the double free of the buffers allocated in build_maps()
    
    I got the following panic on my fsl p5020ds board.
    
      Unable to handle kernel paging request for data at address 0x7375627379737465
      Faulting instruction address: 0xc000000000100778
      Oops: Kernel access of bad area, sig: 11 [#1]
      SMP NR_CPUS=24 CoreNet Generic
      Modules linked in:
      CPU: 0 PID: 1 Comm: swapper/0 Not tainted 3.15.0-next-20140613 #145
      task: c0000000fe080000 ti: c0000000fe088000 task.ti: c0000000fe088000
      NIP: c000000000100778 LR: c00000000010073c CTR: 0000000000000000
      REGS: c0000000fe08aa00 TRAP: 0300   Not tainted  (3.15.0-next-20140613)
      MSR: 0000000080029000 <CE,EE,ME>  CR: 24ad2e24  XER: 00000000
      DEAR: 7375627379737465 ESR: 0000000000000000 SOFTE: 1
      GPR00: c0000000000c99b0 c0000000fe08ac80 c0000000009598e0 c0000000fe001d80
      GPR04: 00000000000000d0 0000000000000913 c000000007902b20 0000000000000000
      GPR08: c0000000feaae888 0000000000000000 0000000007091000 0000000000200200
      GPR12: 0000000028ad2e28 c00000000fff4000 c0000000007abe08 0000000000000000
      GPR16: c0000000007ab160 c0000000007aaf98 c00000000060ba68 c0000000007abda8
      GPR20: c0000000007abde8 c0000000feaea6f8 c0000000feaea708 c0000000007abd10
      GPR24: c000000000989370 c0000000008c6228 00000000000041ed c0000000fe00a400
      GPR28: c00000000017c1cc 00000000000000d0 7375627379737465 c0000000fe001d80
      NIP [c000000000100778] .__kmalloc_track_caller+0x70/0x168
      LR [c00000000010073c] .__kmalloc_track_caller+0x34/0x168
      Call Trace:
      [c0000000fe08ac80] [c00000000087e6b8] uevent_sock_list+0x0/0x10 (unreliable)
      [c0000000fe08ad20] [c0000000000c99b0] .kstrdup+0x44/0x90
      [c0000000fe08adc0] [c00000000017c1cc] .__kernfs_new_node+0x4c/0x130
      [c0000000fe08ae70] [c00000000017d7e4] .kernfs_new_node+0x2c/0x64
      [c0000000fe08aef0] [c00000000017db00] .kernfs_create_dir_ns+0x34/0xc8
      [c0000000fe08af80] [c00000000018067c] .sysfs_create_dir_ns+0x58/0xcc
      [c0000000fe08b010] [c0000000002c711c] .kobject_add_internal+0xc8/0x384
      [c0000000fe08b0b0] [c0000000002c7644] .kobject_add+0x64/0xc8
      [c0000000fe08b140] [c000000000355ebc] .device_add+0x11c/0x654
      [c0000000fe08b200] [c0000000002b5988] .add_disk+0x20c/0x4b4
      [c0000000fe08b2c0] [c0000000003a21d4] .add_mtd_blktrans_dev+0x340/0x514
      [c0000000fe08b350] [c0000000003a3410] .mtdblock_add_mtd+0x74/0xb4
      [c0000000fe08b3e0] [c0000000003a32cc] .blktrans_notify_add+0x64/0x94
      [c0000000fe08b470] [c00000000039b5b4] .add_mtd_device+0x1d4/0x368
      [c0000000fe08b520] [c00000000039b830] .mtd_device_parse_register+0xe8/0x104
      [c0000000fe08b5c0] [c0000000003b8408] .of_flash_probe+0x72c/0x734
      [c0000000fe08b750] [c00000000035ba40] .platform_drv_probe+0x38/0x84
      [c0000000fe08b7d0] [c0000000003599a4] .really_probe+0xa4/0x29c
      [c0000000fe08b870] [c000000000359d3c] .__driver_attach+0x100/0x104
      [c0000000fe08b900] [c00000000035746c] .bus_for_each_dev+0x84/0xe4
      [c0000000fe08b9a0] [c0000000003593c0] .driver_attach+0x24/0x38
      [c0000000fe08ba10] [c000000000358f24] .bus_add_driver+0x1c8/0x2ac
      [c0000000fe08bab0] [c00000000035a3a4] .driver_register+0x8c/0x158
      [c0000000fe08bb30] [c00000000035b9f4] .__platform_driver_register+0x6c/0x80
      [c0000000fe08bba0] [c00000000084e080] .of_flash_driver_init+0x1c/0x30
      [c0000000fe08bc10] [c000000000001864] .do_one_initcall+0xbc/0x238
      [c0000000fe08bd00] [c00000000082cdc0] .kernel_init_freeable+0x188/0x268
      [c0000000fe08bdb0] [c0000000000020a0] .kernel_init+0x1c/0xf7c
      [c0000000fe08be30] [c000000000000884] .ret_from_kernel_thread+0x58/0xd4
      Instruction dump:
      41bd0010 480000c8 4bf04eb5 60000000 e94d0028 e93f0000 7cc95214 e8a60008
      7fc9502a 2fbe0000 419e00c8 e93f0022 <7f7e482a> 39200000 88ed06b2 992d06b2
      ---[ end trace b4c9a94804a42d40 ]---
    
    It seems that the corrupted partition header on my mtd device triggers
    a bug in the ftl. In function build_maps() it will allocate the buffers
    needed by the mtd partition, but if something goes wrong such as kmalloc
    failure, mtd read error or invalid partition header parameter, it will
    free all allocated buffers and then return non-zero. In my case, it
    seems that partition header parameter 'NumTransferUnits' is invalid.
    
    And the ftl_freepart() is a function which free all the partition
    buffers allocated by build_maps(). Given the build_maps() is a self
    cleaning function, so there is no need to invoke this function even
    if build_maps() return with error. Otherwise it will causes the
    buffers to be freed twice and then weird things would happen.
    
    Cc: stable@vger.kernel.org
    Signed-off-by: Kevin Hao <haokexin@gmail.com>
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>

diff --git a/drivers/mtd/ftl.c b/drivers/mtd/ftl.c
index 71f2782f03fc..dabf08450d0b 100644
--- a/drivers/mtd/ftl.c
+++ b/drivers/mtd/ftl.c
@@ -1072,7 +1072,6 @@ static void ftl_add_mtd(struct mtd_blktrans_ops *tr, struct mtd_info *mtd)
 			return;
 	}
 
-	ftl_freepart(partition);
 	kfree(partition);
 }
 

commit da90c4ecbc680881741b51c78a51a3b52d142116
Author: Kevin Hao <haokexin@gmail.com>
Date:   Mon Jun 16 15:52:36 2014 +0800

    mtd/ftl: drop the useless VirtualPageMap in partition_t
    
    This is not used by any code now. Just drop it.
    
    Signed-off-by: Kevin Hao <haokexin@gmail.com>
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>

diff --git a/drivers/mtd/ftl.c b/drivers/mtd/ftl.c
index 19d637266fcd..71f2782f03fc 100644
--- a/drivers/mtd/ftl.c
+++ b/drivers/mtd/ftl.c
@@ -111,7 +111,6 @@ typedef struct partition_t {
     struct mtd_blktrans_dev mbd;
     uint32_t		state;
     uint32_t		*VirtualBlockMap;
-    uint32_t		*VirtualPageMap;
     uint32_t		FreeTotal;
     struct eun_info_t {
 	uint32_t		Offset;
@@ -1035,8 +1034,6 @@ static void ftl_freepart(partition_t *part)
 {
 	vfree(part->VirtualBlockMap);
 	part->VirtualBlockMap = NULL;
-	kfree(part->VirtualPageMap);
-	part->VirtualPageMap = NULL;
 	kfree(part->EUNInfo);
 	part->EUNInfo = NULL;
 	kfree(part->XferInfo);

commit 327cf2922b4edf0439b219469722d2a502e37349
Author: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
Date:   Fri Dec 30 16:35:35 2011 +0200

    mtd: do not use mtd->sync directly
    
    This patch teaches 'mtd_sync()' to do nothing when the MTD driver does
    not have the '->sync()' method, which allows us to remove all direct
    'mtd->sync' accesses.
    
    Signed-off-by: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/drivers/mtd/ftl.c b/drivers/mtd/ftl.c
index c9c90299c9e2..19d637266fcd 100644
--- a/drivers/mtd/ftl.c
+++ b/drivers/mtd/ftl.c
@@ -650,8 +650,7 @@ static int reclaim_block(partition_t *part)
 	    if (queued) {
 		pr_debug("ftl_cs: waiting for transfer "
 		      "unit to be prepared...\n");
-		if (part->mbd.mtd->sync)
-			mtd_sync(part->mbd.mtd);
+		mtd_sync(part->mbd.mtd);
 	    } else {
 		static int ne = 0;
 		if (++ne < 5)

commit 85f2f2a809d658c15b574df02ede92090f45a1f2
Author: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
Date:   Fri Dec 23 19:03:12 2011 +0200

    mtd: introduce mtd_sync interface
    
    Signed-off-by: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/drivers/mtd/ftl.c b/drivers/mtd/ftl.c
index d591b1d0a6c1..c9c90299c9e2 100644
--- a/drivers/mtd/ftl.c
+++ b/drivers/mtd/ftl.c
@@ -651,7 +651,7 @@ static int reclaim_block(partition_t *part)
 		pr_debug("ftl_cs: waiting for transfer "
 		      "unit to be prepared...\n");
 		if (part->mbd.mtd->sync)
-			part->mbd.mtd->sync(part->mbd.mtd);
+			mtd_sync(part->mbd.mtd);
 	    } else {
 		static int ne = 0;
 		if (++ne < 5)

commit eda95cbf75193808f62948fb0142ba0901d8bee2
Author: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
Date:   Fri Dec 23 17:35:41 2011 +0200

    mtd: introduce mtd_write interface
    
    Signed-off-by: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/drivers/mtd/ftl.c b/drivers/mtd/ftl.c
index 12fd7ebd3fd8..d591b1d0a6c1 100644
--- a/drivers/mtd/ftl.c
+++ b/drivers/mtd/ftl.c
@@ -422,8 +422,8 @@ static int prepare_xfer(partition_t *part, int i)
     header.LogicalEUN = cpu_to_le16(0xffff);
     header.EraseCount = cpu_to_le32(xfer->EraseCount);
 
-    ret = part->mbd.mtd->write(part->mbd.mtd, xfer->Offset, sizeof(header),
-			   &retlen, (u_char *)&header);
+    ret = mtd_write(part->mbd.mtd, xfer->Offset, sizeof(header), &retlen,
+                    (u_char *)&header);
 
     if (ret) {
 	return ret;
@@ -438,8 +438,8 @@ static int prepare_xfer(partition_t *part, int i)
 
     for (i = 0; i < nbam; i++, offset += sizeof(uint32_t)) {
 
-	ret = part->mbd.mtd->write(part->mbd.mtd, offset, sizeof(uint32_t),
-			       &retlen, (u_char *)&ctl);
+	ret = mtd_write(part->mbd.mtd, offset, sizeof(uint32_t), &retlen,
+                        (u_char *)&ctl);
 
 	if (ret)
 	    return ret;
@@ -503,8 +503,8 @@ static int copy_erase_unit(partition_t *part, uint16_t srcunit,
     offset = xfer->Offset + 20; /* Bad! */
     unit = cpu_to_le16(0x7fff);
 
-    ret = part->mbd.mtd->write(part->mbd.mtd, offset, sizeof(uint16_t),
-			   &retlen, (u_char *) &unit);
+    ret = mtd_write(part->mbd.mtd, offset, sizeof(uint16_t), &retlen,
+                    (u_char *)&unit);
 
     if (ret) {
 	printk( KERN_WARNING "ftl: Failed to write back to BAM cache in copy_erase_unit()!\n");
@@ -531,8 +531,8 @@ static int copy_erase_unit(partition_t *part, uint16_t srcunit,
             }
 
 
-	    ret = part->mbd.mtd->write(part->mbd.mtd, dest, SECTOR_SIZE,
-                        &retlen, (u_char *) buf);
+	    ret = mtd_write(part->mbd.mtd, dest, SECTOR_SIZE, &retlen,
+                            (u_char *)buf);
 	    if (ret)  {
 		printk(KERN_WARNING "ftl: Error writing new xfer unit in copy_erase_unit\n");
 		return ret;
@@ -550,9 +550,11 @@ static int copy_erase_unit(partition_t *part, uint16_t srcunit,
     }
 
     /* Write the BAM to the transfer unit */
-    ret = part->mbd.mtd->write(part->mbd.mtd, xfer->Offset + le32_to_cpu(part->header.BAMOffset),
-                    part->BlocksPerUnit * sizeof(int32_t), &retlen,
-		    (u_char *)part->bam_cache);
+    ret = mtd_write(part->mbd.mtd,
+                    xfer->Offset + le32_to_cpu(part->header.BAMOffset),
+                    part->BlocksPerUnit * sizeof(int32_t),
+                    &retlen,
+                    (u_char *)part->bam_cache);
     if (ret) {
 	printk( KERN_WARNING "ftl: Error writing BAM in copy_erase_unit\n");
 	return ret;
@@ -560,8 +562,8 @@ static int copy_erase_unit(partition_t *part, uint16_t srcunit,
 
 
     /* All clear? Then update the LogicalEUN again */
-    ret = part->mbd.mtd->write(part->mbd.mtd, xfer->Offset + 20, sizeof(uint16_t),
-			   &retlen, (u_char *)&srcunitswap);
+    ret = mtd_write(part->mbd.mtd, xfer->Offset + 20, sizeof(uint16_t),
+                    &retlen, (u_char *)&srcunitswap);
 
     if (ret) {
 	printk(KERN_WARNING "ftl: Error writing new LogicalEUN in copy_erase_unit\n");
@@ -887,8 +889,8 @@ static int set_bam_entry(partition_t *part, uint32_t log_addr,
 #endif
 	part->bam_cache[blk] = le_virt_addr;
     }
-    ret = part->mbd.mtd->write(part->mbd.mtd, offset, sizeof(uint32_t),
-                            &retlen, (u_char *)&le_virt_addr);
+    ret = mtd_write(part->mbd.mtd, offset, sizeof(uint32_t), &retlen,
+                    (u_char *)&le_virt_addr);
 
     if (ret) {
 	printk(KERN_NOTICE "ftl_cs: set_bam_entry() failed!\n");
@@ -947,8 +949,7 @@ static int ftl_write(partition_t *part, caddr_t buffer,
 	part->EUNInfo[part->bam_index].Deleted++;
 	offset = (part->EUNInfo[part->bam_index].Offset +
 		      blk * SECTOR_SIZE);
-	ret = part->mbd.mtd->write(part->mbd.mtd, offset, SECTOR_SIZE, &retlen,
-                                     buffer);
+	ret = mtd_write(part->mbd.mtd, offset, SECTOR_SIZE, &retlen, buffer);
 
 	if (ret) {
 	    printk(KERN_NOTICE "ftl_cs: block write failed!\n");

commit 329ad399a9b3adf52c90637b21ca029fcf7f8795
Author: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
Date:   Fri Dec 23 17:30:16 2011 +0200

    mtd: introduce mtd_read interface
    
    Signed-off-by: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/drivers/mtd/ftl.c b/drivers/mtd/ftl.c
index a982889277c8..12fd7ebd3fd8 100644
--- a/drivers/mtd/ftl.c
+++ b/drivers/mtd/ftl.c
@@ -168,8 +168,8 @@ static int scan_header(partition_t *part)
 	 (offset + sizeof(header)) < max_offset;
 	 offset += part->mbd.mtd->erasesize ? : 0x2000) {
 
-	err = part->mbd.mtd->read(part->mbd.mtd, offset, sizeof(header), &ret,
-			      (unsigned char *)&header);
+	err = mtd_read(part->mbd.mtd, offset, sizeof(header), &ret,
+                       (unsigned char *)&header);
 
 	if (err)
 	    return err;
@@ -224,8 +224,8 @@ static int build_maps(partition_t *part)
     for (i = 0; i < le16_to_cpu(part->header.NumEraseUnits); i++) {
 	offset = ((i + le16_to_cpu(part->header.FirstPhysicalEUN))
 		      << part->header.EraseUnitSize);
-	ret = part->mbd.mtd->read(part->mbd.mtd, offset, sizeof(header), &retval,
-			      (unsigned char *)&header);
+	ret = mtd_read(part->mbd.mtd, offset, sizeof(header), &retval,
+                       (unsigned char *)&header);
 
 	if (ret)
 	    goto out_XferInfo;
@@ -289,9 +289,9 @@ static int build_maps(partition_t *part)
 	part->EUNInfo[i].Deleted = 0;
 	offset = part->EUNInfo[i].Offset + le32_to_cpu(header.BAMOffset);
 
-	ret = part->mbd.mtd->read(part->mbd.mtd, offset,
-			      part->BlocksPerUnit * sizeof(uint32_t), &retval,
-			      (unsigned char *)part->bam_cache);
+	ret = mtd_read(part->mbd.mtd, offset,
+                       part->BlocksPerUnit * sizeof(uint32_t), &retval,
+                       (unsigned char *)part->bam_cache);
 
 	if (ret)
 		goto out_bam_cache;
@@ -485,9 +485,9 @@ static int copy_erase_unit(partition_t *part, uint16_t srcunit,
 
 	offset = eun->Offset + le32_to_cpu(part->header.BAMOffset);
 
-	ret = part->mbd.mtd->read(part->mbd.mtd, offset,
-			      part->BlocksPerUnit * sizeof(uint32_t),
-			      &retlen, (u_char *) (part->bam_cache));
+	ret = mtd_read(part->mbd.mtd, offset,
+                       part->BlocksPerUnit * sizeof(uint32_t), &retlen,
+                       (u_char *)(part->bam_cache));
 
 	/* mark the cache bad, in case we get an error later */
 	part->bam_index = 0xffff;
@@ -523,8 +523,8 @@ static int copy_erase_unit(partition_t *part, uint16_t srcunit,
 	    break;
 	case BLOCK_DATA:
 	case BLOCK_REPLACEMENT:
-	    ret = part->mbd.mtd->read(part->mbd.mtd, src, SECTOR_SIZE,
-                        &retlen, (u_char *) buf);
+	    ret = mtd_read(part->mbd.mtd, src, SECTOR_SIZE, &retlen,
+                           (u_char *)buf);
 	    if (ret) {
 		printk(KERN_WARNING "ftl: Error reading old xfer unit in copy_erase_unit\n");
 		return ret;
@@ -747,10 +747,11 @@ static uint32_t find_free(partition_t *part)
 	/* Invalidate cache */
 	part->bam_index = 0xffff;
 
-	ret = part->mbd.mtd->read(part->mbd.mtd,
-		       part->EUNInfo[eun].Offset + le32_to_cpu(part->header.BAMOffset),
-		       part->BlocksPerUnit * sizeof(uint32_t),
-		       &retlen, (u_char *) (part->bam_cache));
+	ret = mtd_read(part->mbd.mtd,
+                       part->EUNInfo[eun].Offset + le32_to_cpu(part->header.BAMOffset),
+                       part->BlocksPerUnit * sizeof(uint32_t),
+                       &retlen,
+                       (u_char *)(part->bam_cache));
 
 	if (ret) {
 	    printk(KERN_WARNING"ftl: Error reading BAM in find_free\n");
@@ -810,8 +811,8 @@ static int ftl_read(partition_t *part, caddr_t buffer,
 	else {
 	    offset = (part->EUNInfo[log_addr / bsize].Offset
 			  + (log_addr % bsize));
-	    ret = part->mbd.mtd->read(part->mbd.mtd, offset, SECTOR_SIZE,
-			   &retlen, (u_char *) buffer);
+	    ret = mtd_read(part->mbd.mtd, offset, SECTOR_SIZE, &retlen,
+                           (u_char *)buffer);
 
 	    if (ret) {
 		printk(KERN_WARNING "Error reading MTD device in ftl_read()\n");
@@ -849,8 +850,8 @@ static int set_bam_entry(partition_t *part, uint32_t log_addr,
 		  le32_to_cpu(part->header.BAMOffset));
 
 #ifdef PSYCHO_DEBUG
-    ret = part->mbd.mtd->read(part->mbd.mtd, offset, sizeof(uint32_t),
-                        &retlen, (u_char *)&old_addr);
+    ret = mtd_read(part->mbd.mtd, offset, sizeof(uint32_t), &retlen,
+                   (u_char *)&old_addr);
     if (ret) {
 	printk(KERN_WARNING"ftl: Error reading old_addr in set_bam_entry: %d\n",ret);
 	return ret;

commit 7e1f0dc0551b99acb5e8fa161a7ac401994d57d8
Author: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
Date:   Fri Dec 23 15:25:39 2011 +0200

    mtd: introduce mtd_erase interface
    
    This patch is part of a patch-set which changes the MTD interface
    from 'mtd->func()' form to 'mtd_func()' form. We need this because
    we want to add common code to to all drivers in the mtd core level,
    which is impossible with the current interface when MTD clients
    call driver functions like 'read()' or 'write()' directly.
    
    At this point we just introduce a new inline wrapper function, but
    later some of them are expected to gain more code. E.g., the input
    parameters check should be moved to the wrappers rather than be
    duplicated at many drivers.
    
    This particular patch introduced the 'mtd_erase()' interface. The
    following patches add all the other interfaces one by one.
    
    Signed-off-by: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/drivers/mtd/ftl.c b/drivers/mtd/ftl.c
index c7382bb686c6..a982889277c8 100644
--- a/drivers/mtd/ftl.c
+++ b/drivers/mtd/ftl.c
@@ -355,7 +355,7 @@ static int erase_xfer(partition_t *part,
     erase->len = 1 << part->header.EraseUnitSize;
     erase->priv = (u_long)part;
 
-    ret = part->mbd.mtd->erase(part->mbd.mtd, erase);
+    ret = mtd_erase(part->mbd.mtd, erase);
 
     if (!ret)
 	    xfer->EraseCount++;

commit 92394b5c2be774425f255b5c7afbd8b19978fe12
Author: Brian Norris <computersforpeace@gmail.com>
Date:   Wed Jul 20 09:53:42 2011 -0700

    mtd: spelling fixes
    
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>
    Signed-off-by: Artem Bityutskiy <artem.bityutskiy@intel.com>

diff --git a/drivers/mtd/ftl.c b/drivers/mtd/ftl.c
index 95d77680ad15..c7382bb686c6 100644
--- a/drivers/mtd/ftl.c
+++ b/drivers/mtd/ftl.c
@@ -598,7 +598,7 @@ static int copy_erase_unit(partition_t *part, uint16_t srcunit,
     unit with the fewest erases, and usually pick the data unit with
     the most deleted blocks.  But with a small probability, pick the
     oldest data unit instead.  This means that we generally postpone
-    the next reclaimation as long as possible, but shuffle static
+    the next reclamation as long as possible, but shuffle static
     stuff around a bit for wear leveling.
 
 ======================================================================*/

commit 289c05222172b51401dbbb017115655f241d94ab
Author: Brian Norris <computersforpeace@gmail.com>
Date:   Tue Jul 19 10:06:09 2011 -0700

    mtd: replace DEBUG() with pr_debug()
    
    Start moving away from the MTD_DEBUG_LEVEL messages. The dynamic
    debugging feature is a generic kernel feature that provides more
    flexibility.
    
    (See Documentation/dynamic-debug-howto.txt)
    
    Also fix some punctuation, indentation, and capitalization that went
    along with the affected lines.
    
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>
    Signed-off-by: Artem Bityutskiy <artem.bityutskiy@intel.com>

diff --git a/drivers/mtd/ftl.c b/drivers/mtd/ftl.c
index 037b399df3f1..95d77680ad15 100644
--- a/drivers/mtd/ftl.c
+++ b/drivers/mtd/ftl.c
@@ -339,7 +339,7 @@ static int erase_xfer(partition_t *part,
     struct erase_info *erase;
 
     xfer = &part->XferInfo[xfernum];
-    DEBUG(1, "ftl_cs: erasing xfer unit at 0x%x\n", xfer->Offset);
+    pr_debug("ftl_cs: erasing xfer unit at 0x%x\n", xfer->Offset);
     xfer->state = XFER_ERASING;
 
     /* Is there a free erase slot? Always in MTD. */
@@ -415,7 +415,7 @@ static int prepare_xfer(partition_t *part, int i)
     xfer = &part->XferInfo[i];
     xfer->state = XFER_FAILED;
 
-    DEBUG(1, "ftl_cs: preparing xfer unit at 0x%x\n", xfer->Offset);
+    pr_debug("ftl_cs: preparing xfer unit at 0x%x\n", xfer->Offset);
 
     /* Write the transfer unit header */
     header = part->header;
@@ -476,7 +476,7 @@ static int copy_erase_unit(partition_t *part, uint16_t srcunit,
 
     eun = &part->EUNInfo[srcunit];
     xfer = &part->XferInfo[xferunit];
-    DEBUG(2, "ftl_cs: copying block 0x%x to 0x%x\n",
+    pr_debug("ftl_cs: copying block 0x%x to 0x%x\n",
 	  eun->Offset, xfer->Offset);
 
 
@@ -609,8 +609,8 @@ static int reclaim_block(partition_t *part)
     uint32_t best;
     int queued, ret;
 
-    DEBUG(0, "ftl_cs: reclaiming space...\n");
-    DEBUG(3, "NumTransferUnits == %x\n", part->header.NumTransferUnits);
+    pr_debug("ftl_cs: reclaiming space...\n");
+    pr_debug("NumTransferUnits == %x\n", part->header.NumTransferUnits);
     /* Pick the least erased transfer unit */
     best = 0xffffffff; xfer = 0xffff;
     do {
@@ -618,22 +618,22 @@ static int reclaim_block(partition_t *part)
 	for (i = 0; i < part->header.NumTransferUnits; i++) {
 	    int n=0;
 	    if (part->XferInfo[i].state == XFER_UNKNOWN) {
-		DEBUG(3,"XferInfo[%d].state == XFER_UNKNOWN\n",i);
+		pr_debug("XferInfo[%d].state == XFER_UNKNOWN\n",i);
 		n=1;
 		erase_xfer(part, i);
 	    }
 	    if (part->XferInfo[i].state == XFER_ERASING) {
-		DEBUG(3,"XferInfo[%d].state == XFER_ERASING\n",i);
+		pr_debug("XferInfo[%d].state == XFER_ERASING\n",i);
 		n=1;
 		queued = 1;
 	    }
 	    else if (part->XferInfo[i].state == XFER_ERASED) {
-		DEBUG(3,"XferInfo[%d].state == XFER_ERASED\n",i);
+		pr_debug("XferInfo[%d].state == XFER_ERASED\n",i);
 		n=1;
 		prepare_xfer(part, i);
 	    }
 	    if (part->XferInfo[i].state == XFER_PREPARED) {
-		DEBUG(3,"XferInfo[%d].state == XFER_PREPARED\n",i);
+		pr_debug("XferInfo[%d].state == XFER_PREPARED\n",i);
 		n=1;
 		if (part->XferInfo[i].EraseCount <= best) {
 		    best = part->XferInfo[i].EraseCount;
@@ -641,12 +641,12 @@ static int reclaim_block(partition_t *part)
 		}
 	    }
 		if (!n)
-		    DEBUG(3,"XferInfo[%d].state == %x\n",i, part->XferInfo[i].state);
+		    pr_debug("XferInfo[%d].state == %x\n",i, part->XferInfo[i].state);
 
 	}
 	if (xfer == 0xffff) {
 	    if (queued) {
-		DEBUG(1, "ftl_cs: waiting for transfer "
+		pr_debug("ftl_cs: waiting for transfer "
 		      "unit to be prepared...\n");
 		if (part->mbd.mtd->sync)
 			part->mbd.mtd->sync(part->mbd.mtd);
@@ -656,7 +656,7 @@ static int reclaim_block(partition_t *part)
 		    printk(KERN_NOTICE "ftl_cs: reclaim failed: no "
 			   "suitable transfer units!\n");
 		else
-		    DEBUG(1, "ftl_cs: reclaim failed: no "
+		    pr_debug("ftl_cs: reclaim failed: no "
 			  "suitable transfer units!\n");
 
 		return -EIO;
@@ -666,7 +666,7 @@ static int reclaim_block(partition_t *part)
 
     eun = 0;
     if ((jiffies % shuffle_freq) == 0) {
-	DEBUG(1, "ftl_cs: recycling freshest block...\n");
+	pr_debug("ftl_cs: recycling freshest block...\n");
 	best = 0xffffffff;
 	for (i = 0; i < part->DataUnits; i++)
 	    if (part->EUNInfo[i].EraseCount <= best) {
@@ -686,7 +686,7 @@ static int reclaim_block(partition_t *part)
 		printk(KERN_NOTICE "ftl_cs: reclaim failed: "
 		       "no free blocks!\n");
 	    else
-		DEBUG(1,"ftl_cs: reclaim failed: "
+		pr_debug("ftl_cs: reclaim failed: "
 		       "no free blocks!\n");
 
 	    return -EIO;
@@ -771,7 +771,7 @@ static uint32_t find_free(partition_t *part)
 	printk(KERN_NOTICE "ftl_cs: bad free list!\n");
 	return 0;
     }
-    DEBUG(2, "ftl_cs: found free block at %d in %d\n", blk, eun);
+    pr_debug("ftl_cs: found free block at %d in %d\n", blk, eun);
     return blk;
 
 } /* find_free */
@@ -791,7 +791,7 @@ static int ftl_read(partition_t *part, caddr_t buffer,
     int ret;
     size_t offset, retlen;
 
-    DEBUG(2, "ftl_cs: ftl_read(0x%p, 0x%lx, %ld)\n",
+    pr_debug("ftl_cs: ftl_read(0x%p, 0x%lx, %ld)\n",
 	  part, sector, nblocks);
     if (!(part->state & FTL_FORMATTED)) {
 	printk(KERN_NOTICE "ftl_cs: bad partition\n");
@@ -840,7 +840,7 @@ static int set_bam_entry(partition_t *part, uint32_t log_addr,
     int ret;
     size_t retlen, offset;
 
-    DEBUG(2, "ftl_cs: set_bam_entry(0x%p, 0x%x, 0x%x)\n",
+    pr_debug("ftl_cs: set_bam_entry(0x%p, 0x%x, 0x%x)\n",
 	  part, log_addr, virt_addr);
     bsize = 1 << part->header.EraseUnitSize;
     eun = log_addr / bsize;
@@ -905,7 +905,7 @@ static int ftl_write(partition_t *part, caddr_t buffer,
     int ret;
     size_t retlen, offset;
 
-    DEBUG(2, "ftl_cs: ftl_write(0x%p, %ld, %ld)\n",
+    pr_debug("ftl_cs: ftl_write(0x%p, %ld, %ld)\n",
 	  part, sector, nblocks);
     if (!(part->state & FTL_FORMATTED)) {
 	printk(KERN_NOTICE "ftl_cs: bad partition\n");
@@ -1011,7 +1011,7 @@ static int ftl_discardsect(struct mtd_blktrans_dev *dev,
 	partition_t *part = (void *)dev;
 	uint32_t bsize = 1 << part->header.EraseUnitSize;
 
-	DEBUG(1, "FTL erase sector %ld for %d sectors\n",
+	pr_debug("FTL erase sector %ld for %d sectors\n",
 	      sector, nr_sects);
 
 	while (nr_sects) {

commit 631dd1a885b6d7e9f6f51b4e5b311c2bb04c323c
Author: Justin P. Mattock <justinmattock@gmail.com>
Date:   Mon Oct 18 11:03:14 2010 +0200

    Update broken web addresses in the kernel.
    
    The patch below updates broken web addresses in the kernel
    
    Signed-off-by: Justin P. Mattock <justinmattock@gmail.com>
    Cc: Maciej W. Rozycki <macro@linux-mips.org>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Finn Thain <fthain@telegraphics.com.au>
    Cc: Randy Dunlap <rdunlap@xenotime.net>
    Cc: Matt Turner <mattst88@gmail.com>
    Cc: Dimitry Torokhov <dmitry.torokhov@gmail.com>
    Cc: Mike Frysinger <vapier.adi@gmail.com>
    Acked-by: Ben Pfaff <blp@cs.stanford.edu>
    Acked-by: Hans J. Koch <hjk@linutronix.de>
    Reviewed-by: Finn Thain <fthain@telegraphics.com.au>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/mtd/ftl.c b/drivers/mtd/ftl.c
index 4d6a64c387ec..037b399df3f1 100644
--- a/drivers/mtd/ftl.c
+++ b/drivers/mtd/ftl.c
@@ -51,7 +51,7 @@
 
     Use of the FTL format for non-PCMCIA applications may be an
     infringement of these patents.  For additional information,
-    contact M-Systems (http://www.m-sys.com) directly.
+    contact M-Systems directly. M-Systems since acquired by Sandisk. 
 
 ======================================================================*/
 #include <linux/mtd/blktrans.h>

commit a1452a3771c4eb85bd779790b040efdc36f4274e
Author: David Woodhouse <David.Woodhouse@intel.com>
Date:   Sun Aug 8 20:58:20 2010 +0100

    mtd: Update copyright notices
    
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>

diff --git a/drivers/mtd/ftl.c b/drivers/mtd/ftl.c
index 62da9eb7032b..4d6a64c387ec 100644
--- a/drivers/mtd/ftl.c
+++ b/drivers/mtd/ftl.c
@@ -26,7 +26,7 @@
 
     The initial developer of the original code is David A. Hinds
     <dahinds@users.sourceforge.net>.  Portions created by David A. Hinds
-    are Copyright (C) 1999 David A. Hinds.  All Rights Reserved.
+    are Copyright © 1999 David A. Hinds.  All Rights Reserved.
 
     Alternatively, the contents of this file may be used under the
     terms of the GNU General Public License version 2 (the "GPL"), in

commit 048d87199566663e4edc4880df3703c04bcf41d9
Author: Maxim Levitsky <maximlevitsky@gmail.com>
Date:   Mon Feb 22 20:39:30 2010 +0200

    mtd: blktrans: Hotplug fixes
    
    * Add locking where it was missing.
    
    * Don't do a get_mtd_device in blktrans_open because it would lead to a
      deadlock; instead do that in add_mtd_blktrans_dev.
    
    * Only free the mtd_blktrans_dev structure when the last user exits.
    
    * Flush request queue on device removal.
    
    * Track users, and call tr->release in del_mtd_blktrans_dev
      Due to that ->open and release aren't called more that once.
    
    Now it is safe to call del_mtd_blktrans_dev while the device is still in use.
    
    Signed-off-by: Maxim Levitsky <maximlevitsky@gmail.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/drivers/mtd/ftl.c b/drivers/mtd/ftl.c
index e56d6b42f020..62da9eb7032b 100644
--- a/drivers/mtd/ftl.c
+++ b/drivers/mtd/ftl.c
@@ -1082,7 +1082,6 @@ static void ftl_remove_dev(struct mtd_blktrans_dev *dev)
 {
 	del_mtd_blktrans_dev(dev);
 	ftl_freepart((partition_t *)dev);
-	kfree(dev);
 }
 
 static struct mtd_blktrans_ops ftl_tr = {

commit 627df23c61ce28043a0715a941605ab42dfeb05e
Author: Peter Huewe <peterhuewe@gmx.de>
Date:   Thu Jun 11 02:23:33 2009 +0200

    trivial: mtd: add __init/__exit macros to init/exitfunctions
    
    Trivial patch which adds the __init and __exit macros to the module_init /
    module_exit functions to the following modules from drivers/mtd/
     devices/m25p80.c
     devices/slram.c
     linux version 2.6.30
     ftl.c
     nand/cafe_nand.c
     nand/cmx270_nand.c
    
    Signed-off-by: Peter Huewe <peterhuewe@gmx.de>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/mtd/ftl.c b/drivers/mtd/ftl.c
index a790c062af1f..e56d6b42f020 100644
--- a/drivers/mtd/ftl.c
+++ b/drivers/mtd/ftl.c
@@ -1099,7 +1099,7 @@ static struct mtd_blktrans_ops ftl_tr = {
 	.owner		= THIS_MODULE,
 };
 
-static int init_ftl(void)
+static int __init init_ftl(void)
 {
 	return register_mtd_blktrans(&ftl_tr);
 }

commit 3854be7712f7b4bdcaed14664fc7c7124b3fef0d
Author: David Woodhouse <David.Woodhouse@intel.com>
Date:   Wed Dec 10 14:06:42 2008 +0000

    [MTD] Remove strange u_int32_t types from FTL
    
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/drivers/mtd/ftl.c b/drivers/mtd/ftl.c
index 9bf581c4f740..a790c062af1f 100644
--- a/drivers/mtd/ftl.c
+++ b/drivers/mtd/ftl.c
@@ -109,25 +109,25 @@ module_param(shuffle_freq, int, 0);
 /* Each memory region corresponds to a minor device */
 typedef struct partition_t {
     struct mtd_blktrans_dev mbd;
-    u_int32_t		state;
-    u_int32_t		*VirtualBlockMap;
-    u_int32_t		*VirtualPageMap;
-    u_int32_t		FreeTotal;
+    uint32_t		state;
+    uint32_t		*VirtualBlockMap;
+    uint32_t		*VirtualPageMap;
+    uint32_t		FreeTotal;
     struct eun_info_t {
-	u_int32_t		Offset;
-	u_int32_t		EraseCount;
-	u_int32_t		Free;
-	u_int32_t		Deleted;
+	uint32_t		Offset;
+	uint32_t		EraseCount;
+	uint32_t		Free;
+	uint32_t		Deleted;
     } *EUNInfo;
     struct xfer_info_t {
-	u_int32_t		Offset;
-	u_int32_t		EraseCount;
-	u_int16_t		state;
+	uint32_t		Offset;
+	uint32_t		EraseCount;
+	uint16_t		state;
     } *XferInfo;
-    u_int16_t		bam_index;
-    u_int32_t		*bam_cache;
-    u_int16_t		DataUnits;
-    u_int32_t		BlocksPerUnit;
+    uint16_t		bam_index;
+    uint32_t		*bam_cache;
+    uint16_t		DataUnits;
+    uint32_t		BlocksPerUnit;
     erase_unit_header_t	header;
 } partition_t;
 
@@ -199,8 +199,8 @@ static int scan_header(partition_t *part)
 static int build_maps(partition_t *part)
 {
     erase_unit_header_t header;
-    u_int16_t xvalid, xtrans, i;
-    u_int blocks, j;
+    uint16_t xvalid, xtrans, i;
+    unsigned blocks, j;
     int hdr_ok, ret = -1;
     ssize_t retval;
     loff_t offset;
@@ -269,14 +269,14 @@ static int build_maps(partition_t *part)
 
     /* Set up virtual page map */
     blocks = le32_to_cpu(header.FormattedSize) >> header.BlockSize;
-    part->VirtualBlockMap = vmalloc(blocks * sizeof(u_int32_t));
+    part->VirtualBlockMap = vmalloc(blocks * sizeof(uint32_t));
     if (!part->VirtualBlockMap)
 	    goto out_XferInfo;
 
-    memset(part->VirtualBlockMap, 0xff, blocks * sizeof(u_int32_t));
+    memset(part->VirtualBlockMap, 0xff, blocks * sizeof(uint32_t));
     part->BlocksPerUnit = (1 << header.EraseUnitSize) >> header.BlockSize;
 
-    part->bam_cache = kmalloc(part->BlocksPerUnit * sizeof(u_int32_t),
+    part->bam_cache = kmalloc(part->BlocksPerUnit * sizeof(uint32_t),
 			      GFP_KERNEL);
     if (!part->bam_cache)
 	    goto out_VirtualBlockMap;
@@ -290,7 +290,7 @@ static int build_maps(partition_t *part)
 	offset = part->EUNInfo[i].Offset + le32_to_cpu(header.BAMOffset);
 
 	ret = part->mbd.mtd->read(part->mbd.mtd, offset,
-			      part->BlocksPerUnit * sizeof(u_int32_t), &retval,
+			      part->BlocksPerUnit * sizeof(uint32_t), &retval,
 			      (unsigned char *)part->bam_cache);
 
 	if (ret)
@@ -332,7 +332,7 @@ static int build_maps(partition_t *part)
 ======================================================================*/
 
 static int erase_xfer(partition_t *part,
-		      u_int16_t xfernum)
+		      uint16_t xfernum)
 {
     int ret;
     struct xfer_info_t *xfer;
@@ -408,7 +408,7 @@ static int prepare_xfer(partition_t *part, int i)
     erase_unit_header_t header;
     struct xfer_info_t *xfer;
     int nbam, ret;
-    u_int32_t ctl;
+    uint32_t ctl;
     ssize_t retlen;
     loff_t offset;
 
@@ -430,15 +430,15 @@ static int prepare_xfer(partition_t *part, int i)
     }
 
     /* Write the BAM stub */
-    nbam = (part->BlocksPerUnit * sizeof(u_int32_t) +
+    nbam = (part->BlocksPerUnit * sizeof(uint32_t) +
 	    le32_to_cpu(part->header.BAMOffset) + SECTOR_SIZE - 1) / SECTOR_SIZE;
 
     offset = xfer->Offset + le32_to_cpu(part->header.BAMOffset);
     ctl = cpu_to_le32(BLOCK_CONTROL);
 
-    for (i = 0; i < nbam; i++, offset += sizeof(u_int32_t)) {
+    for (i = 0; i < nbam; i++, offset += sizeof(uint32_t)) {
 
-	ret = part->mbd.mtd->write(part->mbd.mtd, offset, sizeof(u_int32_t),
+	ret = part->mbd.mtd->write(part->mbd.mtd, offset, sizeof(uint32_t),
 			       &retlen, (u_char *)&ctl);
 
 	if (ret)
@@ -461,18 +461,18 @@ static int prepare_xfer(partition_t *part, int i)
 
 ======================================================================*/
 
-static int copy_erase_unit(partition_t *part, u_int16_t srcunit,
-			   u_int16_t xferunit)
+static int copy_erase_unit(partition_t *part, uint16_t srcunit,
+			   uint16_t xferunit)
 {
     u_char buf[SECTOR_SIZE];
     struct eun_info_t *eun;
     struct xfer_info_t *xfer;
-    u_int32_t src, dest, free, i;
-    u_int16_t unit;
+    uint32_t src, dest, free, i;
+    uint16_t unit;
     int ret;
     ssize_t retlen;
     loff_t offset;
-    u_int16_t srcunitswap = cpu_to_le16(srcunit);
+    uint16_t srcunitswap = cpu_to_le16(srcunit);
 
     eun = &part->EUNInfo[srcunit];
     xfer = &part->XferInfo[xferunit];
@@ -486,7 +486,7 @@ static int copy_erase_unit(partition_t *part, u_int16_t srcunit,
 	offset = eun->Offset + le32_to_cpu(part->header.BAMOffset);
 
 	ret = part->mbd.mtd->read(part->mbd.mtd, offset,
-			      part->BlocksPerUnit * sizeof(u_int32_t),
+			      part->BlocksPerUnit * sizeof(uint32_t),
 			      &retlen, (u_char *) (part->bam_cache));
 
 	/* mark the cache bad, in case we get an error later */
@@ -503,7 +503,7 @@ static int copy_erase_unit(partition_t *part, u_int16_t srcunit,
     offset = xfer->Offset + 20; /* Bad! */
     unit = cpu_to_le16(0x7fff);
 
-    ret = part->mbd.mtd->write(part->mbd.mtd, offset, sizeof(u_int16_t),
+    ret = part->mbd.mtd->write(part->mbd.mtd, offset, sizeof(uint16_t),
 			   &retlen, (u_char *) &unit);
 
     if (ret) {
@@ -560,7 +560,7 @@ static int copy_erase_unit(partition_t *part, u_int16_t srcunit,
 
 
     /* All clear? Then update the LogicalEUN again */
-    ret = part->mbd.mtd->write(part->mbd.mtd, xfer->Offset + 20, sizeof(u_int16_t),
+    ret = part->mbd.mtd->write(part->mbd.mtd, xfer->Offset + 20, sizeof(uint16_t),
 			   &retlen, (u_char *)&srcunitswap);
 
     if (ret) {
@@ -605,8 +605,8 @@ static int copy_erase_unit(partition_t *part, u_int16_t srcunit,
 
 static int reclaim_block(partition_t *part)
 {
-    u_int16_t i, eun, xfer;
-    u_int32_t best;
+    uint16_t i, eun, xfer;
+    uint32_t best;
     int queued, ret;
 
     DEBUG(0, "ftl_cs: reclaiming space...\n");
@@ -723,10 +723,10 @@ static void dump_lists(partition_t *part)
 }
 #endif
 
-static u_int32_t find_free(partition_t *part)
+static uint32_t find_free(partition_t *part)
 {
-    u_int16_t stop, eun;
-    u_int32_t blk;
+    uint16_t stop, eun;
+    uint32_t blk;
     size_t retlen;
     int ret;
 
@@ -749,7 +749,7 @@ static u_int32_t find_free(partition_t *part)
 
 	ret = part->mbd.mtd->read(part->mbd.mtd,
 		       part->EUNInfo[eun].Offset + le32_to_cpu(part->header.BAMOffset),
-		       part->BlocksPerUnit * sizeof(u_int32_t),
+		       part->BlocksPerUnit * sizeof(uint32_t),
 		       &retlen, (u_char *) (part->bam_cache));
 
 	if (ret) {
@@ -786,7 +786,7 @@ static u_int32_t find_free(partition_t *part)
 static int ftl_read(partition_t *part, caddr_t buffer,
 		    u_long sector, u_long nblocks)
 {
-    u_int32_t log_addr, bsize;
+    uint32_t log_addr, bsize;
     u_long i;
     int ret;
     size_t offset, retlen;
@@ -829,14 +829,14 @@ static int ftl_read(partition_t *part, caddr_t buffer,
 
 ======================================================================*/
 
-static int set_bam_entry(partition_t *part, u_int32_t log_addr,
-			 u_int32_t virt_addr)
+static int set_bam_entry(partition_t *part, uint32_t log_addr,
+			 uint32_t virt_addr)
 {
-    u_int32_t bsize, blk, le_virt_addr;
+    uint32_t bsize, blk, le_virt_addr;
 #ifdef PSYCHO_DEBUG
-    u_int32_t old_addr;
+    uint32_t old_addr;
 #endif
-    u_int16_t eun;
+    uint16_t eun;
     int ret;
     size_t retlen, offset;
 
@@ -845,11 +845,11 @@ static int set_bam_entry(partition_t *part, u_int32_t log_addr,
     bsize = 1 << part->header.EraseUnitSize;
     eun = log_addr / bsize;
     blk = (log_addr % bsize) / SECTOR_SIZE;
-    offset = (part->EUNInfo[eun].Offset + blk * sizeof(u_int32_t) +
+    offset = (part->EUNInfo[eun].Offset + blk * sizeof(uint32_t) +
 		  le32_to_cpu(part->header.BAMOffset));
 
 #ifdef PSYCHO_DEBUG
-    ret = part->mbd.mtd->read(part->mbd.mtd, offset, sizeof(u_int32_t),
+    ret = part->mbd.mtd->read(part->mbd.mtd, offset, sizeof(uint32_t),
                         &retlen, (u_char *)&old_addr);
     if (ret) {
 	printk(KERN_WARNING"ftl: Error reading old_addr in set_bam_entry: %d\n",ret);
@@ -886,7 +886,7 @@ static int set_bam_entry(partition_t *part, u_int32_t log_addr,
 #endif
 	part->bam_cache[blk] = le_virt_addr;
     }
-    ret = part->mbd.mtd->write(part->mbd.mtd, offset, sizeof(u_int32_t),
+    ret = part->mbd.mtd->write(part->mbd.mtd, offset, sizeof(uint32_t),
                             &retlen, (u_char *)&le_virt_addr);
 
     if (ret) {
@@ -900,7 +900,7 @@ static int set_bam_entry(partition_t *part, u_int32_t log_addr,
 static int ftl_write(partition_t *part, caddr_t buffer,
 		     u_long sector, u_long nblocks)
 {
-    u_int32_t bsize, log_addr, virt_addr, old_addr, blk;
+    uint32_t bsize, log_addr, virt_addr, old_addr, blk;
     u_long i;
     int ret;
     size_t retlen, offset;

commit fdc53971bce56d299cb5f1f06ecbff30b34cbaf2
Author: David Woodhouse <David.Woodhouse@intel.com>
Date:   Tue Aug 5 18:08:56 2008 +0100

    Support 'discard sectors' operation.
    
    We can benefit from knowing that the file system no longer cares about
    the contents of certain sectors, by throwing them away immediately and
    then never having to garbage collect them, and using the extra free
    space to make our operations more efficient. Do so.
    
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>
    Signed-off-by: Jens Axboe <jens.axboe@oracle.com>

diff --git a/drivers/mtd/ftl.c b/drivers/mtd/ftl.c
index f34f20c78911..9bf581c4f740 100644
--- a/drivers/mtd/ftl.c
+++ b/drivers/mtd/ftl.c
@@ -1005,6 +1005,29 @@ static int ftl_writesect(struct mtd_blktrans_dev *dev,
 	return ftl_write((void *)dev, buf, block, 1);
 }
 
+static int ftl_discardsect(struct mtd_blktrans_dev *dev,
+			   unsigned long sector, unsigned nr_sects)
+{
+	partition_t *part = (void *)dev;
+	uint32_t bsize = 1 << part->header.EraseUnitSize;
+
+	DEBUG(1, "FTL erase sector %ld for %d sectors\n",
+	      sector, nr_sects);
+
+	while (nr_sects) {
+		uint32_t old_addr = part->VirtualBlockMap[sector];
+		if (old_addr != 0xffffffff) {
+			part->VirtualBlockMap[sector] = 0xffffffff;
+			part->EUNInfo[old_addr/bsize].Deleted++;
+			if (set_bam_entry(part, old_addr, 0))
+				return -EIO;
+		}
+		nr_sects--;
+		sector++;
+	}
+
+	return 0;
+}
 /*====================================================================*/
 
 static void ftl_freepart(partition_t *part)
@@ -1069,6 +1092,7 @@ static struct mtd_blktrans_ops ftl_tr = {
 	.blksize 	= SECTOR_SIZE,
 	.readsect	= ftl_readsect,
 	.writesect	= ftl_writesect,
+	.discard	= ftl_discardsect,
 	.getgeo		= ftl_getgeo,
 	.add_mtd	= ftl_add_mtd,
 	.remove_dev	= ftl_remove_dev,

commit ff877ea80efa2015b6263766f78ee42c2a1b32f9
Merge: 30821fee4f0c d37e6bf68fc1
Author: David Woodhouse <David.Woodhouse@intel.com>
Date:   Fri Jul 25 10:40:14 2008 -0400

    Merge branch 'linux-next' of git://git.infradead.org/~dedekind/ubi-2.6

commit ae49ec9258b1ba0456f5d2e9024d0e4742a0188b
Author: Magnus Damm <damm@opensource.se>
Date:   Thu Jun 19 20:49:41 2008 +0200

    pcmcia: remove unused bulkmem.h
    
    The code in include/pcmcia/bulkmem.h was only kept for compatibility reasons.
    Therefore, move the remaining region_info_t definition to ds.h
    
    [linux@dominikbrodowski.net: do not modify the IOCTL, move definition to
     ds.h, and update changelog]
    Signed-off-by: Magnus Damm <damm@opensource.se>
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/drivers/mtd/ftl.c b/drivers/mtd/ftl.c
index 4a79b187b568..5c29872184e6 100644
--- a/drivers/mtd/ftl.c
+++ b/drivers/mtd/ftl.c
@@ -130,10 +130,6 @@ typedef struct partition_t {
     u_int16_t		DataUnits;
     u_int32_t		BlocksPerUnit;
     erase_unit_header_t	header;
-#if 0
-    region_info_t	region;
-    memory_handle_t	handle;
-#endif
 } partition_t;
 
 /* Partition state flags */

commit 59018b6d2acabb114ab58637e6ab95ba424a89d0
Author: Adrian Bunk <bunk@kernel.org>
Date:   Tue May 20 01:03:52 2008 +0300

    MTD/JFFS2: remove CVS keywords
    
    Once upon a time, the MTD repository was using CVS.
    
    This patch therefore removes all usages of the no longer updated CVS
    keywords from the MTD code.
    
    This also includes code that printed them to the user.
    
    Signed-off-by: Adrian Bunk <bunk@kernel.org>
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>

diff --git a/drivers/mtd/ftl.c b/drivers/mtd/ftl.c
index 4a79b187b568..3fed8f94ac6f 100644
--- a/drivers/mtd/ftl.c
+++ b/drivers/mtd/ftl.c
@@ -1,5 +1,4 @@
 /* This version ported to the Linux-MTD system by dwmw2@infradead.org
- * $Id: ftl.c,v 1.59 2005/11/29 14:48:31 gleixner Exp $
  *
  * Fixes: Arnaldo Carvalho de Melo <acme@conectiva.com.br>
  * - fixes some leaks on failure in build_maps and ftl_notify_add, cleanups
@@ -1082,8 +1081,6 @@ static struct mtd_blktrans_ops ftl_tr = {
 
 static int init_ftl(void)
 {
-	DEBUG(0, "$Id: ftl.c,v 1.59 2005/11/29 14:48:31 gleixner Exp $\n");
-
 	return register_mtd_blktrans(&ftl_tr);
 }
 

commit 5ce45d50056e20aca50f19229d8a7e003569ad26
Author: Adrian Bunk <bunk@kernel.org>
Date:   Mon Apr 14 17:20:24 2008 +0300

    [MTD] ftl.c: make code static
    
    This patch makes the following needlessly global code static:
    - ftl_freepart()
    - struct ftl_tr
    
    Signed-off-by: Adrian Bunk <bunk@kernel.org>
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>

diff --git a/drivers/mtd/ftl.c b/drivers/mtd/ftl.c
index c815d0f38577..4a79b187b568 100644
--- a/drivers/mtd/ftl.c
+++ b/drivers/mtd/ftl.c
@@ -136,8 +136,6 @@ typedef struct partition_t {
 #endif
 } partition_t;
 
-void ftl_freepart(partition_t *part);
-
 /* Partition state flags */
 #define FTL_FORMATTED	0x01
 
@@ -1014,7 +1012,7 @@ static int ftl_writesect(struct mtd_blktrans_dev *dev,
 
 /*====================================================================*/
 
-void ftl_freepart(partition_t *part)
+static void ftl_freepart(partition_t *part)
 {
 	vfree(part->VirtualBlockMap);
 	part->VirtualBlockMap = NULL;
@@ -1069,7 +1067,7 @@ static void ftl_remove_dev(struct mtd_blktrans_dev *dev)
 	kfree(dev);
 }
 
-struct mtd_blktrans_ops ftl_tr = {
+static struct mtd_blktrans_ops ftl_tr = {
 	.name		= "ftl",
 	.major		= FTL_MAJOR,
 	.part_bits	= PART_BITS,

commit cd354f1ae75e6466a7e31b727faede57a1f89ca5
Author: Tim Schmielau <tim@physik3.uni-rostock.de>
Date:   Wed Feb 14 00:33:14 2007 -0800

    [PATCH] remove many unneeded #includes of sched.h
    
    After Al Viro (finally) succeeded in removing the sched.h #include in module.h
    recently, it makes sense again to remove other superfluous sched.h includes.
    There are quite a lot of files which include it but don't actually need
    anything defined in there.  Presumably these includes were once needed for
    macros that used to live in sched.h, but moved to other header files in the
    course of cleaning it up.
    
    To ease the pain, this time I did not fiddle with any header files and only
    removed #includes from .c-files, which tend to cause less trouble.
    
    Compile tested against 2.6.20-rc2 and 2.6.20-rc2-mm2 (with offsets) on alpha,
    arm, i386, ia64, mips, powerpc, and x86_64 with allnoconfig, defconfig,
    allmodconfig, and allyesconfig as well as a few randconfigs on x86_64 and all
    configs in arch/arm/configs on arm.  I also checked that no new warnings were
    introduced by the patch (actually, some warnings are removed that were emitted
    by unnecessarily included header files).
    
    Signed-off-by: Tim Schmielau <tim@physik3.uni-rostock.de>
    Acked-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/mtd/ftl.c b/drivers/mtd/ftl.c
index 24235d4f1d23..c815d0f38577 100644
--- a/drivers/mtd/ftl.c
+++ b/drivers/mtd/ftl.c
@@ -61,7 +61,6 @@
 /*#define PSYCHO_DEBUG */
 
 #include <linux/kernel.h>
-#include <linux/sched.h>
 #include <linux/ptrace.h>
 #include <linux/slab.h>
 #include <linux/string.h>

commit 95b93a0cd46682c6d9e8eea803fda510cb6b863a
Author: Burman Yan <yan_952@hotmail.com>
Date:   Wed Nov 15 21:10:29 2006 +0200

    [MTD] replace kmalloc+memset with kzalloc
    
    Signed-off-by: Yan Burman <yan_952@hotmail.com>
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>

diff --git a/drivers/mtd/ftl.c b/drivers/mtd/ftl.c
index da39355132d8..24235d4f1d23 100644
--- a/drivers/mtd/ftl.c
+++ b/drivers/mtd/ftl.c
@@ -1033,7 +1033,7 @@ static void ftl_add_mtd(struct mtd_blktrans_ops *tr, struct mtd_info *mtd)
 {
 	partition_t *partition;
 
-	partition = kmalloc(sizeof(partition_t), GFP_KERNEL);
+	partition = kzalloc(sizeof(partition_t), GFP_KERNEL);
 
 	if (!partition) {
 		printk(KERN_WARNING "No memory to scan for FTL on %s\n",
@@ -1041,8 +1041,6 @@ static void ftl_add_mtd(struct mtd_blktrans_ops *tr, struct mtd_info *mtd)
 		return;
 	}
 
-	memset(partition, 0, sizeof(partition_t));
-
 	partition->mbd.mtd = mtd;
 
 	if ((scan_header(partition) == 0) &&

commit 191876729901d0c8dab8a331f9a1e4b73a56457b
Author: Richard Purdie <rpurdie@openedhand.com>
Date:   Fri Oct 27 09:09:33 2006 +0100

    [MTD] Allow variable block sizes in mtd_blkdevs
    
    Currently, mtd_blkdevs enforces a block size of 512, even if the drivers
    can seemingly request a different size. This patch fixes mtd_blkdevs so
    block sizes other than 512 work correctly.
    
    Signed-off-by: Richard Purdie <rpurdie@openedhand.com>
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>

diff --git a/drivers/mtd/ftl.c b/drivers/mtd/ftl.c
index 8a878b34eca0..da39355132d8 100644
--- a/drivers/mtd/ftl.c
+++ b/drivers/mtd/ftl.c
@@ -1054,7 +1054,7 @@ static void ftl_add_mtd(struct mtd_blktrans_ops *tr, struct mtd_info *mtd)
 		       le32_to_cpu(partition->header.FormattedSize) >> 10);
 #endif
 		partition->mbd.size = le32_to_cpu(partition->header.FormattedSize) >> 9;
-		partition->mbd.blksize = SECTOR_SIZE;
+
 		partition->mbd.tr = tr;
 		partition->mbd.devnum = -1;
 		if (!add_mtd_blktrans_dev((void *)partition))
@@ -1076,6 +1076,7 @@ struct mtd_blktrans_ops ftl_tr = {
 	.name		= "ftl",
 	.major		= FTL_MAJOR,
 	.part_bits	= PART_BITS,
+	.blksize 	= SECTOR_SIZE,
 	.readsect	= ftl_readsect,
 	.writesect	= ftl_writesect,
 	.getgeo		= ftl_getgeo,

commit 2b9175c174b83b8d97db9398efe948fa9092938f
Author: Adrian Bunk <bunk@stusta.de>
Date:   Tue Nov 29 14:49:38 2005 +0000

    [MTD] Make functions static, include header files with prototypes
    
    This patch contains the following possible cleanups:
    - every file should #include the headers containing the prototypes for
      it's global functions
    - make needlessly global functions static
    
    Signed-off-by: Adrian Bunk <bunk@stusta.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/drivers/mtd/ftl.c b/drivers/mtd/ftl.c
index de7e231d6d18..8a878b34eca0 100644
--- a/drivers/mtd/ftl.c
+++ b/drivers/mtd/ftl.c
@@ -1,5 +1,5 @@
 /* This version ported to the Linux-MTD system by dwmw2@infradead.org
- * $Id: ftl.c,v 1.58 2005/11/07 11:14:19 gleixner Exp $
+ * $Id: ftl.c,v 1.59 2005/11/29 14:48:31 gleixner Exp $
  *
  * Fixes: Arnaldo Carvalho de Melo <acme@conectiva.com.br>
  * - fixes some leaks on failure in build_maps and ftl_notify_add, cleanups
@@ -1084,9 +1084,9 @@ struct mtd_blktrans_ops ftl_tr = {
 	.owner		= THIS_MODULE,
 };
 
-int init_ftl(void)
+static int init_ftl(void)
 {
-	DEBUG(0, "$Id: ftl.c,v 1.58 2005/11/07 11:14:19 gleixner Exp $\n");
+	DEBUG(0, "$Id: ftl.c,v 1.59 2005/11/29 14:48:31 gleixner Exp $\n");
 
 	return register_mtd_blktrans(&ftl_tr);
 }

commit 97894cda5773e59bd13e87b72077751099419a9f
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Nov 7 11:15:26 2005 +0000

    [MTD] core: Clean up trailing white spaces
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/drivers/mtd/ftl.c b/drivers/mtd/ftl.c
index d32c1b3a8ce3..de7e231d6d18 100644
--- a/drivers/mtd/ftl.c
+++ b/drivers/mtd/ftl.c
@@ -1,5 +1,5 @@
 /* This version ported to the Linux-MTD system by dwmw2@infradead.org
- * $Id: ftl.c,v 1.55 2005/01/17 13:47:21 hvr Exp $
+ * $Id: ftl.c,v 1.58 2005/11/07 11:14:19 gleixner Exp $
  *
  * Fixes: Arnaldo Carvalho de Melo <acme@conectiva.com.br>
  * - fixes some leaks on failure in build_maps and ftl_notify_add, cleanups
@@ -53,7 +53,7 @@
     Use of the FTL format for non-PCMCIA applications may be an
     infringement of these patents.  For additional information,
     contact M-Systems (http://www.m-sys.com) directly.
-      
+
 ======================================================================*/
 #include <linux/mtd/blktrans.h>
 #include <linux/module.h>
@@ -160,7 +160,7 @@ static void ftl_erase_callback(struct erase_info *done);
     Scan_header() checks to see if a memory region contains an FTL
     partition.  build_maps() reads all the erase unit headers, builds
     the erase unit map, and then builds the virtual page map.
-    
+
 ======================================================================*/
 
 static int scan_header(partition_t *part)
@@ -176,10 +176,10 @@ static int scan_header(partition_t *part)
 	 (offset + sizeof(header)) < max_offset;
 	 offset += part->mbd.mtd->erasesize ? : 0x2000) {
 
-	err = part->mbd.mtd->read(part->mbd.mtd, offset, sizeof(header), &ret, 
+	err = part->mbd.mtd->read(part->mbd.mtd, offset, sizeof(header), &ret,
 			      (unsigned char *)&header);
-	
-	if (err) 
+
+	if (err)
 	    return err;
 
 	if (strcmp(header.DataOrgTuple+3, "FTL100") == 0) break;
@@ -232,10 +232,10 @@ static int build_maps(partition_t *part)
     for (i = 0; i < le16_to_cpu(part->header.NumEraseUnits); i++) {
 	offset = ((i + le16_to_cpu(part->header.FirstPhysicalEUN))
 		      << part->header.EraseUnitSize);
-	ret = part->mbd.mtd->read(part->mbd.mtd, offset, sizeof(header), &retval, 
+	ret = part->mbd.mtd->read(part->mbd.mtd, offset, sizeof(header), &retval,
 			      (unsigned char *)&header);
-	
-	if (ret) 
+
+	if (ret)
 	    goto out_XferInfo;
 
 	ret = -1;
@@ -274,7 +274,7 @@ static int build_maps(partition_t *part)
 	       "don't add up!\n");
 	goto out_XferInfo;
     }
-    
+
     /* Set up virtual page map */
     blocks = le32_to_cpu(header.FormattedSize) >> header.BlockSize;
     part->VirtualBlockMap = vmalloc(blocks * sizeof(u_int32_t));
@@ -296,12 +296,12 @@ static int build_maps(partition_t *part)
 	part->EUNInfo[i].Free = 0;
 	part->EUNInfo[i].Deleted = 0;
 	offset = part->EUNInfo[i].Offset + le32_to_cpu(header.BAMOffset);
-	
-	ret = part->mbd.mtd->read(part->mbd.mtd, offset,  
-			      part->BlocksPerUnit * sizeof(u_int32_t), &retval, 
+
+	ret = part->mbd.mtd->read(part->mbd.mtd, offset,
+			      part->BlocksPerUnit * sizeof(u_int32_t), &retval,
 			      (unsigned char *)part->bam_cache);
-	
-	if (ret) 
+
+	if (ret)
 		goto out_bam_cache;
 
 	for (j = 0; j < part->BlocksPerUnit; j++) {
@@ -316,7 +316,7 @@ static int build_maps(partition_t *part)
 		part->EUNInfo[i].Deleted++;
 	}
     }
-    
+
     ret = 0;
     goto out;
 
@@ -336,7 +336,7 @@ static int build_maps(partition_t *part)
 
     Erase_xfer() schedules an asynchronous erase operation for a
     transfer unit.
-    
+
 ======================================================================*/
 
 static int erase_xfer(partition_t *part,
@@ -351,10 +351,10 @@ static int erase_xfer(partition_t *part,
     xfer->state = XFER_ERASING;
 
     /* Is there a free erase slot? Always in MTD. */
-    
-    
+
+
     erase=kmalloc(sizeof(struct erase_info), GFP_KERNEL);
-    if (!erase) 
+    if (!erase)
             return -ENOMEM;
 
     erase->mtd = part->mbd.mtd;
@@ -362,7 +362,7 @@ static int erase_xfer(partition_t *part,
     erase->addr = xfer->Offset;
     erase->len = 1 << part->header.EraseUnitSize;
     erase->priv = (u_long)part;
-    
+
     ret = part->mbd.mtd->erase(part->mbd.mtd, erase);
 
     if (!ret)
@@ -377,7 +377,7 @@ static int erase_xfer(partition_t *part,
 
     Prepare_xfer() takes a freshly erased transfer unit and gives
     it an appropriate header.
-    
+
 ======================================================================*/
 
 static void ftl_erase_callback(struct erase_info *erase)
@@ -385,7 +385,7 @@ static void ftl_erase_callback(struct erase_info *erase)
     partition_t *part;
     struct xfer_info_t *xfer;
     int i;
-    
+
     /* Look up the transfer unit */
     part = (partition_t *)(erase->priv);
 
@@ -422,7 +422,7 @@ static int prepare_xfer(partition_t *part, int i)
 
     xfer = &part->XferInfo[i];
     xfer->state = XFER_FAILED;
-    
+
     DEBUG(1, "ftl_cs: preparing xfer unit at 0x%x\n", xfer->Offset);
 
     /* Write the transfer unit header */
@@ -446,7 +446,7 @@ static int prepare_xfer(partition_t *part, int i)
 
     for (i = 0; i < nbam; i++, offset += sizeof(u_int32_t)) {
 
-	ret = part->mbd.mtd->write(part->mbd.mtd, offset, sizeof(u_int32_t), 
+	ret = part->mbd.mtd->write(part->mbd.mtd, offset, sizeof(u_int32_t),
 			       &retlen, (u_char *)&ctl);
 
 	if (ret)
@@ -454,7 +454,7 @@ static int prepare_xfer(partition_t *part, int i)
     }
     xfer->state = XFER_PREPARED;
     return 0;
-    
+
 } /* prepare_xfer */
 
 /*======================================================================
@@ -466,7 +466,7 @@ static int prepare_xfer(partition_t *part, int i)
     All data blocks are copied to the corresponding blocks in the
     target unit, so the virtual block map does not need to be
     updated.
-    
+
 ======================================================================*/
 
 static int copy_erase_unit(partition_t *part, u_int16_t srcunit,
@@ -486,14 +486,14 @@ static int copy_erase_unit(partition_t *part, u_int16_t srcunit,
     xfer = &part->XferInfo[xferunit];
     DEBUG(2, "ftl_cs: copying block 0x%x to 0x%x\n",
 	  eun->Offset, xfer->Offset);
-	
-    
+
+
     /* Read current BAM */
     if (part->bam_index != srcunit) {
 
 	offset = eun->Offset + le32_to_cpu(part->header.BAMOffset);
 
-	ret = part->mbd.mtd->read(part->mbd.mtd, offset, 
+	ret = part->mbd.mtd->read(part->mbd.mtd, offset,
 			      part->BlocksPerUnit * sizeof(u_int32_t),
 			      &retlen, (u_char *) (part->bam_cache));
 
@@ -501,11 +501,11 @@ static int copy_erase_unit(partition_t *part, u_int16_t srcunit,
 	part->bam_index = 0xffff;
 
 	if (ret) {
-	    printk( KERN_WARNING "ftl: Failed to read BAM cache in copy_erase_unit()!\n");                
+	    printk( KERN_WARNING "ftl: Failed to read BAM cache in copy_erase_unit()!\n");
 	    return ret;
 	}
     }
-    
+
     /* Write the LogicalEUN for the transfer unit */
     xfer->state = XFER_UNKNOWN;
     offset = xfer->Offset + 20; /* Bad! */
@@ -513,12 +513,12 @@ static int copy_erase_unit(partition_t *part, u_int16_t srcunit,
 
     ret = part->mbd.mtd->write(part->mbd.mtd, offset, sizeof(u_int16_t),
 			   &retlen, (u_char *) &unit);
-    
+
     if (ret) {
 	printk( KERN_WARNING "ftl: Failed to write back to BAM cache in copy_erase_unit()!\n");
 	return ret;
     }
-    
+
     /* Copy all data blocks from source unit to transfer unit */
     src = eun->Offset; dest = xfer->Offset;
 
@@ -558,15 +558,15 @@ static int copy_erase_unit(partition_t *part, u_int16_t srcunit,
     }
 
     /* Write the BAM to the transfer unit */
-    ret = part->mbd.mtd->write(part->mbd.mtd, xfer->Offset + le32_to_cpu(part->header.BAMOffset), 
-                    part->BlocksPerUnit * sizeof(int32_t), &retlen, 
+    ret = part->mbd.mtd->write(part->mbd.mtd, xfer->Offset + le32_to_cpu(part->header.BAMOffset),
+                    part->BlocksPerUnit * sizeof(int32_t), &retlen,
 		    (u_char *)part->bam_cache);
     if (ret) {
 	printk( KERN_WARNING "ftl: Error writing BAM in copy_erase_unit\n");
 	return ret;
     }
 
-    
+
     /* All clear? Then update the LogicalEUN again */
     ret = part->mbd.mtd->write(part->mbd.mtd, xfer->Offset + 20, sizeof(u_int16_t),
 			   &retlen, (u_char *)&srcunitswap);
@@ -574,9 +574,9 @@ static int copy_erase_unit(partition_t *part, u_int16_t srcunit,
     if (ret) {
 	printk(KERN_WARNING "ftl: Error writing new LogicalEUN in copy_erase_unit\n");
 	return ret;
-    }    
-    
-    
+    }
+
+
     /* Update the maps and usage stats*/
     i = xfer->EraseCount;
     xfer->EraseCount = eun->EraseCount;
@@ -588,10 +588,10 @@ static int copy_erase_unit(partition_t *part, u_int16_t srcunit,
     part->FreeTotal += free;
     eun->Free = free;
     eun->Deleted = 0;
-    
+
     /* Now, the cache should be valid for the new block */
     part->bam_index = srcunit;
-    
+
     return 0;
 } /* copy_erase_unit */
 
@@ -608,7 +608,7 @@ static int copy_erase_unit(partition_t *part, u_int16_t srcunit,
     oldest data unit instead.  This means that we generally postpone
     the next reclaimation as long as possible, but shuffle static
     stuff around a bit for wear leveling.
-    
+
 ======================================================================*/
 
 static int reclaim_block(partition_t *part)
@@ -666,7 +666,7 @@ static int reclaim_block(partition_t *part)
 		else
 		    DEBUG(1, "ftl_cs: reclaim failed: no "
 			  "suitable transfer units!\n");
-			
+
 		return -EIO;
 	    }
 	}
@@ -715,7 +715,7 @@ static int reclaim_block(partition_t *part)
     returns the block index -- the erase unit is just the currently
     cached unit.  If there are no free blocks, it returns 0 -- this
     is never a valid data block because it contains the header.
-    
+
 ======================================================================*/
 
 #ifdef PSYCHO_DEBUG
@@ -737,7 +737,7 @@ static u_int32_t find_free(partition_t *part)
     u_int32_t blk;
     size_t retlen;
     int ret;
-    
+
     /* Find an erase unit with some free space */
     stop = (part->bam_index == 0xffff) ? 0 : part->bam_index;
     eun = stop;
@@ -749,17 +749,17 @@ static u_int32_t find_free(partition_t *part)
 
     if (part->EUNInfo[eun].Free == 0)
 	return 0;
-    
+
     /* Is this unit's BAM cached? */
     if (eun != part->bam_index) {
 	/* Invalidate cache */
 	part->bam_index = 0xffff;
 
-	ret = part->mbd.mtd->read(part->mbd.mtd, 
+	ret = part->mbd.mtd->read(part->mbd.mtd,
 		       part->EUNInfo[eun].Offset + le32_to_cpu(part->header.BAMOffset),
 		       part->BlocksPerUnit * sizeof(u_int32_t),
 		       &retlen, (u_char *) (part->bam_cache));
-	
+
 	if (ret) {
 	    printk(KERN_WARNING"ftl: Error reading BAM in find_free\n");
 	    return 0;
@@ -781,14 +781,14 @@ static u_int32_t find_free(partition_t *part)
     }
     DEBUG(2, "ftl_cs: found free block at %d in %d\n", blk, eun);
     return blk;
-    
+
 } /* find_free */
 
 
 /*======================================================================
 
     Read a series of sectors from an FTL partition.
-    
+
 ======================================================================*/
 
 static int ftl_read(partition_t *part, caddr_t buffer,
@@ -798,7 +798,7 @@ static int ftl_read(partition_t *part, caddr_t buffer,
     u_long i;
     int ret;
     size_t offset, retlen;
-    
+
     DEBUG(2, "ftl_cs: ftl_read(0x%p, 0x%lx, %ld)\n",
 	  part, sector, nblocks);
     if (!(part->state & FTL_FORMATTED)) {
@@ -834,7 +834,7 @@ static int ftl_read(partition_t *part, caddr_t buffer,
 /*======================================================================
 
     Write a series of sectors to an FTL partition
-    
+
 ======================================================================*/
 
 static int set_bam_entry(partition_t *part, u_int32_t log_addr,
@@ -855,7 +855,7 @@ static int set_bam_entry(partition_t *part, u_int32_t log_addr,
     blk = (log_addr % bsize) / SECTOR_SIZE;
     offset = (part->EUNInfo[eun].Offset + blk * sizeof(u_int32_t) +
 		  le32_to_cpu(part->header.BAMOffset));
-    
+
 #ifdef PSYCHO_DEBUG
     ret = part->mbd.mtd->read(part->mbd.mtd, offset, sizeof(u_int32_t),
                         &retlen, (u_char *)&old_addr);
@@ -925,7 +925,7 @@ static int ftl_write(partition_t *part, caddr_t buffer,
 	if (ret)
 	    return ret;
     }
-    
+
     bsize = 1 << part->header.EraseUnitSize;
 
     virt_addr = sector * SECTOR_SIZE | BLOCK_DATA;
@@ -949,12 +949,12 @@ static int ftl_write(partition_t *part, caddr_t buffer,
 	log_addr = part->bam_index * bsize + blk * SECTOR_SIZE;
 	part->EUNInfo[part->bam_index].Free--;
 	part->FreeTotal--;
-	if (set_bam_entry(part, log_addr, 0xfffffffe)) 
+	if (set_bam_entry(part, log_addr, 0xfffffffe))
 	    return -EIO;
 	part->EUNInfo[part->bam_index].Deleted++;
 	offset = (part->EUNInfo[part->bam_index].Offset +
 		      blk * SECTOR_SIZE);
-	ret = part->mbd.mtd->write(part->mbd.mtd, offset, SECTOR_SIZE, &retlen, 
+	ret = part->mbd.mtd->write(part->mbd.mtd, offset, SECTOR_SIZE, &retlen,
                                      buffer);
 
 	if (ret) {
@@ -964,7 +964,7 @@ static int ftl_write(partition_t *part, caddr_t buffer,
 		   offset);
 	    return -EIO;
 	}
-	
+
 	/* Only delete the old entry when the new entry is ready */
 	old_addr = part->VirtualBlockMap[sector+i];
 	if (old_addr != 0xffffffff) {
@@ -979,7 +979,7 @@ static int ftl_write(partition_t *part, caddr_t buffer,
 	    return -EIO;
 	part->VirtualBlockMap[sector+i] = log_addr;
 	part->EUNInfo[part->bam_index].Deleted--;
-	
+
 	buffer += SECTOR_SIZE;
 	virt_addr += SECTOR_SIZE;
     }
@@ -1034,20 +1034,20 @@ static void ftl_add_mtd(struct mtd_blktrans_ops *tr, struct mtd_info *mtd)
 	partition_t *partition;
 
 	partition = kmalloc(sizeof(partition_t), GFP_KERNEL);
-		
+
 	if (!partition) {
 		printk(KERN_WARNING "No memory to scan for FTL on %s\n",
 		       mtd->name);
 		return;
-	}    
+	}
 
 	memset(partition, 0, sizeof(partition_t));
 
 	partition->mbd.mtd = mtd;
 
-	if ((scan_header(partition) == 0) && 
+	if ((scan_header(partition) == 0) &&
 	    (build_maps(partition) == 0)) {
-		
+
 		partition->state = FTL_FORMATTED;
 #ifdef PCMCIA_DEBUG
 		printk(KERN_INFO "ftl_cs: opening %d KiB FTL partition\n",
@@ -1086,7 +1086,7 @@ struct mtd_blktrans_ops ftl_tr = {
 
 int init_ftl(void)
 {
-	DEBUG(0, "$Id: ftl.c,v 1.55 2005/01/17 13:47:21 hvr Exp $\n");
+	DEBUG(0, "$Id: ftl.c,v 1.58 2005/11/07 11:14:19 gleixner Exp $\n");
 
 	return register_mtd_blktrans(&ftl_tr);
 }

commit f9101210e7aa72daf92722d451a2f7e3af5f781f
Author: Jesper Juhl <jesper.juhl@gmail.com>
Date:   Sat Sep 10 00:26:54 2005 -0700

    [PATCH] vfree and kfree cleanup in drivers/
    
    This patch does a full cleanup of 'NULL checks before vfree', and a partial
    cleanup of calls to kfree for all of drivers/ - the kfree bit is partial in
    that I only did the files that also had vfree calls in them.  The patch
    also gets rid of some redundant (void *) casts of pointers being passed to
    [vk]free, and a some tiny whitespace corrections also crept in.
    
    Signed-off-by: Jesper Juhl <jesper.juhl@gmail.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/mtd/ftl.c b/drivers/mtd/ftl.c
index d9ab60b36fd4..d32c1b3a8ce3 100644
--- a/drivers/mtd/ftl.c
+++ b/drivers/mtd/ftl.c
@@ -1017,27 +1017,16 @@ static int ftl_writesect(struct mtd_blktrans_dev *dev,
 
 void ftl_freepart(partition_t *part)
 {
-    if (part->VirtualBlockMap) {
 	vfree(part->VirtualBlockMap);
 	part->VirtualBlockMap = NULL;
-    }
-    if (part->VirtualPageMap) {
 	kfree(part->VirtualPageMap);
 	part->VirtualPageMap = NULL;
-    }
-    if (part->EUNInfo) {
 	kfree(part->EUNInfo);
 	part->EUNInfo = NULL;
-    }
-    if (part->XferInfo) {
 	kfree(part->XferInfo);
 	part->XferInfo = NULL;
-    }
-    if (part->bam_cache) {
 	kfree(part->bam_cache);
 	part->bam_cache = NULL;
-    }
-    
 } /* ftl_freepart */
 
 static void ftl_add_mtd(struct mtd_blktrans_ops *tr, struct mtd_info *mtd)

commit 8ea2e06fc8d2f03b49cef7732ae8e290e2f0b183
Author: Herbert Valerio Riedel <hvr@inso.tuwien.ac.at>
Date:   Mon Jan 17 13:47:24 2005 +0000

    [MTD] FTL Fix missing pointer assignment
    
    For the case that mtd partitions are enabled it would cause a 0-pointer
    dereferencing in mtdpart.c:mtd_erase_callback()
    
    Signed-off-by: Herbert Valerio Riedel <hvr@inso.tuwien.ac.at>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/drivers/mtd/ftl.c b/drivers/mtd/ftl.c
index 18cc8846e733..d9ab60b36fd4 100644
--- a/drivers/mtd/ftl.c
+++ b/drivers/mtd/ftl.c
@@ -1,5 +1,5 @@
 /* This version ported to the Linux-MTD system by dwmw2@infradead.org
- * $Id: ftl.c,v 1.54 2004/11/16 18:33:15 dwmw2 Exp $
+ * $Id: ftl.c,v 1.55 2005/01/17 13:47:21 hvr Exp $
  *
  * Fixes: Arnaldo Carvalho de Melo <acme@conectiva.com.br>
  * - fixes some leaks on failure in build_maps and ftl_notify_add, cleanups
@@ -357,6 +357,7 @@ static int erase_xfer(partition_t *part,
     if (!erase) 
             return -ENOMEM;
 
+    erase->mtd = part->mbd.mtd;
     erase->callback = ftl_erase_callback;
     erase->addr = xfer->Offset;
     erase->len = 1 << part->header.EraseUnitSize;
@@ -1096,7 +1097,7 @@ struct mtd_blktrans_ops ftl_tr = {
 
 int init_ftl(void)
 {
-	DEBUG(0, "$Id: ftl.c,v 1.54 2004/11/16 18:33:15 dwmw2 Exp $\n");
+	DEBUG(0, "$Id: ftl.c,v 1.55 2005/01/17 13:47:21 hvr Exp $\n");
 
 	return register_mtd_blktrans(&ftl_tr);
 }

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/drivers/mtd/ftl.c b/drivers/mtd/ftl.c
new file mode 100644
index 000000000000..18cc8846e733
--- /dev/null
+++ b/drivers/mtd/ftl.c
@@ -0,0 +1,1115 @@
+/* This version ported to the Linux-MTD system by dwmw2@infradead.org
+ * $Id: ftl.c,v 1.54 2004/11/16 18:33:15 dwmw2 Exp $
+ *
+ * Fixes: Arnaldo Carvalho de Melo <acme@conectiva.com.br>
+ * - fixes some leaks on failure in build_maps and ftl_notify_add, cleanups
+ *
+ * Based on:
+ */
+/*======================================================================
+
+    A Flash Translation Layer memory card driver
+
+    This driver implements a disk-like block device driver with an
+    apparent block size of 512 bytes for flash memory cards.
+
+    ftl_cs.c 1.62 2000/02/01 00:59:04
+
+    The contents of this file are subject to the Mozilla Public
+    License Version 1.1 (the "License"); you may not use this file
+    except in compliance with the License. You may obtain a copy of
+    the License at http://www.mozilla.org/MPL/
+
+    Software distributed under the License is distributed on an "AS
+    IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+    implied. See the License for the specific language governing
+    rights and limitations under the License.
+
+    The initial developer of the original code is David A. Hinds
+    <dahinds@users.sourceforge.net>.  Portions created by David A. Hinds
+    are Copyright (C) 1999 David A. Hinds.  All Rights Reserved.
+
+    Alternatively, the contents of this file may be used under the
+    terms of the GNU General Public License version 2 (the "GPL"), in
+    which case the provisions of the GPL are applicable instead of the
+    above.  If you wish to allow the use of your version of this file
+    only under the terms of the GPL and not to allow others to use
+    your version of this file under the MPL, indicate your decision
+    by deleting the provisions above and replace them with the notice
+    and other provisions required by the GPL.  If you do not delete
+    the provisions above, a recipient may use your version of this
+    file under either the MPL or the GPL.
+
+    LEGAL NOTE: The FTL format is patented by M-Systems.  They have
+    granted a license for its use with PCMCIA devices:
+
+     "M-Systems grants a royalty-free, non-exclusive license under
+      any presently existing M-Systems intellectual property rights
+      necessary for the design and development of FTL-compatible
+      drivers, file systems and utilities using the data formats with
+      PCMCIA PC Cards as described in the PCMCIA Flash Translation
+      Layer (FTL) Specification."
+
+    Use of the FTL format for non-PCMCIA applications may be an
+    infringement of these patents.  For additional information,
+    contact M-Systems (http://www.m-sys.com) directly.
+      
+======================================================================*/
+#include <linux/mtd/blktrans.h>
+#include <linux/module.h>
+#include <linux/mtd/mtd.h>
+/*#define PSYCHO_DEBUG */
+
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/ptrace.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+#include <linux/timer.h>
+#include <linux/major.h>
+#include <linux/fs.h>
+#include <linux/init.h>
+#include <linux/hdreg.h>
+#include <linux/vmalloc.h>
+#include <linux/blkpg.h>
+#include <asm/uaccess.h>
+
+#include <linux/mtd/ftl.h>
+
+/*====================================================================*/
+
+/* Parameters that can be set with 'insmod' */
+static int shuffle_freq = 50;
+module_param(shuffle_freq, int, 0);
+
+/*====================================================================*/
+
+/* Major device # for FTL device */
+#ifndef FTL_MAJOR
+#define FTL_MAJOR	44
+#endif
+
+
+/*====================================================================*/
+
+/* Maximum number of separate memory devices we'll allow */
+#define MAX_DEV		4
+
+/* Maximum number of regions per device */
+#define MAX_REGION	4
+
+/* Maximum number of partitions in an FTL region */
+#define PART_BITS	4
+
+/* Maximum number of outstanding erase requests per socket */
+#define MAX_ERASE	8
+
+/* Sector size -- shouldn't need to change */
+#define SECTOR_SIZE	512
+
+
+/* Each memory region corresponds to a minor device */
+typedef struct partition_t {
+    struct mtd_blktrans_dev mbd;
+    u_int32_t		state;
+    u_int32_t		*VirtualBlockMap;
+    u_int32_t		*VirtualPageMap;
+    u_int32_t		FreeTotal;
+    struct eun_info_t {
+	u_int32_t		Offset;
+	u_int32_t		EraseCount;
+	u_int32_t		Free;
+	u_int32_t		Deleted;
+    } *EUNInfo;
+    struct xfer_info_t {
+	u_int32_t		Offset;
+	u_int32_t		EraseCount;
+	u_int16_t		state;
+    } *XferInfo;
+    u_int16_t		bam_index;
+    u_int32_t		*bam_cache;
+    u_int16_t		DataUnits;
+    u_int32_t		BlocksPerUnit;
+    erase_unit_header_t	header;
+#if 0
+    region_info_t	region;
+    memory_handle_t	handle;
+#endif
+} partition_t;
+
+void ftl_freepart(partition_t *part);
+
+/* Partition state flags */
+#define FTL_FORMATTED	0x01
+
+/* Transfer unit states */
+#define XFER_UNKNOWN	0x00
+#define XFER_ERASING	0x01
+#define XFER_ERASED	0x02
+#define XFER_PREPARED	0x03
+#define XFER_FAILED	0x04
+
+/*====================================================================*/
+
+
+static void ftl_erase_callback(struct erase_info *done);
+
+
+/*======================================================================
+
+    Scan_header() checks to see if a memory region contains an FTL
+    partition.  build_maps() reads all the erase unit headers, builds
+    the erase unit map, and then builds the virtual page map.
+    
+======================================================================*/
+
+static int scan_header(partition_t *part)
+{
+    erase_unit_header_t header;
+    loff_t offset, max_offset;
+    size_t ret;
+    int err;
+    part->header.FormattedSize = 0;
+    max_offset = (0x100000<part->mbd.mtd->size)?0x100000:part->mbd.mtd->size;
+    /* Search first megabyte for a valid FTL header */
+    for (offset = 0;
+	 (offset + sizeof(header)) < max_offset;
+	 offset += part->mbd.mtd->erasesize ? : 0x2000) {
+
+	err = part->mbd.mtd->read(part->mbd.mtd, offset, sizeof(header), &ret, 
+			      (unsigned char *)&header);
+	
+	if (err) 
+	    return err;
+
+	if (strcmp(header.DataOrgTuple+3, "FTL100") == 0) break;
+    }
+
+    if (offset == max_offset) {
+	printk(KERN_NOTICE "ftl_cs: FTL header not found.\n");
+	return -ENOENT;
+    }
+    if (header.BlockSize != 9 ||
+	(header.EraseUnitSize < 10) || (header.EraseUnitSize > 31) ||
+	(header.NumTransferUnits >= le16_to_cpu(header.NumEraseUnits))) {
+	printk(KERN_NOTICE "ftl_cs: FTL header corrupt!\n");
+	return -1;
+    }
+    if ((1 << header.EraseUnitSize) != part->mbd.mtd->erasesize) {
+	printk(KERN_NOTICE "ftl: FTL EraseUnitSize %x != MTD erasesize %x\n",
+	       1 << header.EraseUnitSize,part->mbd.mtd->erasesize);
+	return -1;
+    }
+    part->header = header;
+    return 0;
+}
+
+static int build_maps(partition_t *part)
+{
+    erase_unit_header_t header;
+    u_int16_t xvalid, xtrans, i;
+    u_int blocks, j;
+    int hdr_ok, ret = -1;
+    ssize_t retval;
+    loff_t offset;
+
+    /* Set up erase unit maps */
+    part->DataUnits = le16_to_cpu(part->header.NumEraseUnits) -
+	part->header.NumTransferUnits;
+    part->EUNInfo = kmalloc(part->DataUnits * sizeof(struct eun_info_t),
+			    GFP_KERNEL);
+    if (!part->EUNInfo)
+	    goto out;
+    for (i = 0; i < part->DataUnits; i++)
+	part->EUNInfo[i].Offset = 0xffffffff;
+    part->XferInfo =
+	kmalloc(part->header.NumTransferUnits * sizeof(struct xfer_info_t),
+		GFP_KERNEL);
+    if (!part->XferInfo)
+	    goto out_EUNInfo;
+
+    xvalid = xtrans = 0;
+    for (i = 0; i < le16_to_cpu(part->header.NumEraseUnits); i++) {
+	offset = ((i + le16_to_cpu(part->header.FirstPhysicalEUN))
+		      << part->header.EraseUnitSize);
+	ret = part->mbd.mtd->read(part->mbd.mtd, offset, sizeof(header), &retval, 
+			      (unsigned char *)&header);
+	
+	if (ret) 
+	    goto out_XferInfo;
+
+	ret = -1;
+	/* Is this a transfer partition? */
+	hdr_ok = (strcmp(header.DataOrgTuple+3, "FTL100") == 0);
+	if (hdr_ok && (le16_to_cpu(header.LogicalEUN) < part->DataUnits) &&
+	    (part->EUNInfo[le16_to_cpu(header.LogicalEUN)].Offset == 0xffffffff)) {
+	    part->EUNInfo[le16_to_cpu(header.LogicalEUN)].Offset = offset;
+	    part->EUNInfo[le16_to_cpu(header.LogicalEUN)].EraseCount =
+		le32_to_cpu(header.EraseCount);
+	    xvalid++;
+	} else {
+	    if (xtrans == part->header.NumTransferUnits) {
+		printk(KERN_NOTICE "ftl_cs: format error: too many "
+		       "transfer units!\n");
+		goto out_XferInfo;
+	    }
+	    if (hdr_ok && (le16_to_cpu(header.LogicalEUN) == 0xffff)) {
+		part->XferInfo[xtrans].state = XFER_PREPARED;
+		part->XferInfo[xtrans].EraseCount = le32_to_cpu(header.EraseCount);
+	    } else {
+		part->XferInfo[xtrans].state = XFER_UNKNOWN;
+		/* Pick anything reasonable for the erase count */
+		part->XferInfo[xtrans].EraseCount =
+		    le32_to_cpu(part->header.EraseCount);
+	    }
+	    part->XferInfo[xtrans].Offset = offset;
+	    xtrans++;
+	}
+    }
+    /* Check for format trouble */
+    header = part->header;
+    if ((xtrans != header.NumTransferUnits) ||
+	(xvalid+xtrans != le16_to_cpu(header.NumEraseUnits))) {
+	printk(KERN_NOTICE "ftl_cs: format error: erase units "
+	       "don't add up!\n");
+	goto out_XferInfo;
+    }
+    
+    /* Set up virtual page map */
+    blocks = le32_to_cpu(header.FormattedSize) >> header.BlockSize;
+    part->VirtualBlockMap = vmalloc(blocks * sizeof(u_int32_t));
+    if (!part->VirtualBlockMap)
+	    goto out_XferInfo;
+
+    memset(part->VirtualBlockMap, 0xff, blocks * sizeof(u_int32_t));
+    part->BlocksPerUnit = (1 << header.EraseUnitSize) >> header.BlockSize;
+
+    part->bam_cache = kmalloc(part->BlocksPerUnit * sizeof(u_int32_t),
+			      GFP_KERNEL);
+    if (!part->bam_cache)
+	    goto out_VirtualBlockMap;
+
+    part->bam_index = 0xffff;
+    part->FreeTotal = 0;
+
+    for (i = 0; i < part->DataUnits; i++) {
+	part->EUNInfo[i].Free = 0;
+	part->EUNInfo[i].Deleted = 0;
+	offset = part->EUNInfo[i].Offset + le32_to_cpu(header.BAMOffset);
+	
+	ret = part->mbd.mtd->read(part->mbd.mtd, offset,  
+			      part->BlocksPerUnit * sizeof(u_int32_t), &retval, 
+			      (unsigned char *)part->bam_cache);
+	
+	if (ret) 
+		goto out_bam_cache;
+
+	for (j = 0; j < part->BlocksPerUnit; j++) {
+	    if (BLOCK_FREE(le32_to_cpu(part->bam_cache[j]))) {
+		part->EUNInfo[i].Free++;
+		part->FreeTotal++;
+	    } else if ((BLOCK_TYPE(le32_to_cpu(part->bam_cache[j])) == BLOCK_DATA) &&
+		     (BLOCK_NUMBER(le32_to_cpu(part->bam_cache[j])) < blocks))
+		part->VirtualBlockMap[BLOCK_NUMBER(le32_to_cpu(part->bam_cache[j]))] =
+		    (i << header.EraseUnitSize) + (j << header.BlockSize);
+	    else if (BLOCK_DELETED(le32_to_cpu(part->bam_cache[j])))
+		part->EUNInfo[i].Deleted++;
+	}
+    }
+    
+    ret = 0;
+    goto out;
+
+out_bam_cache:
+    kfree(part->bam_cache);
+out_VirtualBlockMap:
+    vfree(part->VirtualBlockMap);
+out_XferInfo:
+    kfree(part->XferInfo);
+out_EUNInfo:
+    kfree(part->EUNInfo);
+out:
+    return ret;
+} /* build_maps */
+
+/*======================================================================
+
+    Erase_xfer() schedules an asynchronous erase operation for a
+    transfer unit.
+    
+======================================================================*/
+
+static int erase_xfer(partition_t *part,
+		      u_int16_t xfernum)
+{
+    int ret;
+    struct xfer_info_t *xfer;
+    struct erase_info *erase;
+
+    xfer = &part->XferInfo[xfernum];
+    DEBUG(1, "ftl_cs: erasing xfer unit at 0x%x\n", xfer->Offset);
+    xfer->state = XFER_ERASING;
+
+    /* Is there a free erase slot? Always in MTD. */
+    
+    
+    erase=kmalloc(sizeof(struct erase_info), GFP_KERNEL);
+    if (!erase) 
+            return -ENOMEM;
+
+    erase->callback = ftl_erase_callback;
+    erase->addr = xfer->Offset;
+    erase->len = 1 << part->header.EraseUnitSize;
+    erase->priv = (u_long)part;
+    
+    ret = part->mbd.mtd->erase(part->mbd.mtd, erase);
+
+    if (!ret)
+	    xfer->EraseCount++;
+    else
+	    kfree(erase);
+
+    return ret;
+} /* erase_xfer */
+
+/*======================================================================
+
+    Prepare_xfer() takes a freshly erased transfer unit and gives
+    it an appropriate header.
+    
+======================================================================*/
+
+static void ftl_erase_callback(struct erase_info *erase)
+{
+    partition_t *part;
+    struct xfer_info_t *xfer;
+    int i;
+    
+    /* Look up the transfer unit */
+    part = (partition_t *)(erase->priv);
+
+    for (i = 0; i < part->header.NumTransferUnits; i++)
+	if (part->XferInfo[i].Offset == erase->addr) break;
+
+    if (i == part->header.NumTransferUnits) {
+	printk(KERN_NOTICE "ftl_cs: internal error: "
+	       "erase lookup failed!\n");
+	return;
+    }
+
+    xfer = &part->XferInfo[i];
+    if (erase->state == MTD_ERASE_DONE)
+	xfer->state = XFER_ERASED;
+    else {
+	xfer->state = XFER_FAILED;
+	printk(KERN_NOTICE "ftl_cs: erase failed: state = %d\n",
+	       erase->state);
+    }
+
+    kfree(erase);
+
+} /* ftl_erase_callback */
+
+static int prepare_xfer(partition_t *part, int i)
+{
+    erase_unit_header_t header;
+    struct xfer_info_t *xfer;
+    int nbam, ret;
+    u_int32_t ctl;
+    ssize_t retlen;
+    loff_t offset;
+
+    xfer = &part->XferInfo[i];
+    xfer->state = XFER_FAILED;
+    
+    DEBUG(1, "ftl_cs: preparing xfer unit at 0x%x\n", xfer->Offset);
+
+    /* Write the transfer unit header */
+    header = part->header;
+    header.LogicalEUN = cpu_to_le16(0xffff);
+    header.EraseCount = cpu_to_le32(xfer->EraseCount);
+
+    ret = part->mbd.mtd->write(part->mbd.mtd, xfer->Offset, sizeof(header),
+			   &retlen, (u_char *)&header);
+
+    if (ret) {
+	return ret;
+    }
+
+    /* Write the BAM stub */
+    nbam = (part->BlocksPerUnit * sizeof(u_int32_t) +
+	    le32_to_cpu(part->header.BAMOffset) + SECTOR_SIZE - 1) / SECTOR_SIZE;
+
+    offset = xfer->Offset + le32_to_cpu(part->header.BAMOffset);
+    ctl = cpu_to_le32(BLOCK_CONTROL);
+
+    for (i = 0; i < nbam; i++, offset += sizeof(u_int32_t)) {
+
+	ret = part->mbd.mtd->write(part->mbd.mtd, offset, sizeof(u_int32_t), 
+			       &retlen, (u_char *)&ctl);
+
+	if (ret)
+	    return ret;
+    }
+    xfer->state = XFER_PREPARED;
+    return 0;
+    
+} /* prepare_xfer */
+
+/*======================================================================
+
+    Copy_erase_unit() takes a full erase block and a transfer unit,
+    copies everything to the transfer unit, then swaps the block
+    pointers.
+
+    All data blocks are copied to the corresponding blocks in the
+    target unit, so the virtual block map does not need to be
+    updated.
+    
+======================================================================*/
+
+static int copy_erase_unit(partition_t *part, u_int16_t srcunit,
+			   u_int16_t xferunit)
+{
+    u_char buf[SECTOR_SIZE];
+    struct eun_info_t *eun;
+    struct xfer_info_t *xfer;
+    u_int32_t src, dest, free, i;
+    u_int16_t unit;
+    int ret;
+    ssize_t retlen;
+    loff_t offset;
+    u_int16_t srcunitswap = cpu_to_le16(srcunit);
+
+    eun = &part->EUNInfo[srcunit];
+    xfer = &part->XferInfo[xferunit];
+    DEBUG(2, "ftl_cs: copying block 0x%x to 0x%x\n",
+	  eun->Offset, xfer->Offset);
+	
+    
+    /* Read current BAM */
+    if (part->bam_index != srcunit) {
+
+	offset = eun->Offset + le32_to_cpu(part->header.BAMOffset);
+
+	ret = part->mbd.mtd->read(part->mbd.mtd, offset, 
+			      part->BlocksPerUnit * sizeof(u_int32_t),
+			      &retlen, (u_char *) (part->bam_cache));
+
+	/* mark the cache bad, in case we get an error later */
+	part->bam_index = 0xffff;
+
+	if (ret) {
+	    printk( KERN_WARNING "ftl: Failed to read BAM cache in copy_erase_unit()!\n");                
+	    return ret;
+	}
+    }
+    
+    /* Write the LogicalEUN for the transfer unit */
+    xfer->state = XFER_UNKNOWN;
+    offset = xfer->Offset + 20; /* Bad! */
+    unit = cpu_to_le16(0x7fff);
+
+    ret = part->mbd.mtd->write(part->mbd.mtd, offset, sizeof(u_int16_t),
+			   &retlen, (u_char *) &unit);
+    
+    if (ret) {
+	printk( KERN_WARNING "ftl: Failed to write back to BAM cache in copy_erase_unit()!\n");
+	return ret;
+    }
+    
+    /* Copy all data blocks from source unit to transfer unit */
+    src = eun->Offset; dest = xfer->Offset;
+
+    free = 0;
+    ret = 0;
+    for (i = 0; i < part->BlocksPerUnit; i++) {
+	switch (BLOCK_TYPE(le32_to_cpu(part->bam_cache[i]))) {
+	case BLOCK_CONTROL:
+	    /* This gets updated later */
+	    break;
+	case BLOCK_DATA:
+	case BLOCK_REPLACEMENT:
+	    ret = part->mbd.mtd->read(part->mbd.mtd, src, SECTOR_SIZE,
+                        &retlen, (u_char *) buf);
+	    if (ret) {
+		printk(KERN_WARNING "ftl: Error reading old xfer unit in copy_erase_unit\n");
+		return ret;
+            }
+
+
+	    ret = part->mbd.mtd->write(part->mbd.mtd, dest, SECTOR_SIZE,
+                        &retlen, (u_char *) buf);
+	    if (ret)  {
+		printk(KERN_WARNING "ftl: Error writing new xfer unit in copy_erase_unit\n");
+		return ret;
+            }
+
+	    break;
+	default:
+	    /* All other blocks must be free */
+	    part->bam_cache[i] = cpu_to_le32(0xffffffff);
+	    free++;
+	    break;
+	}
+	src += SECTOR_SIZE;
+	dest += SECTOR_SIZE;
+    }
+
+    /* Write the BAM to the transfer unit */
+    ret = part->mbd.mtd->write(part->mbd.mtd, xfer->Offset + le32_to_cpu(part->header.BAMOffset), 
+                    part->BlocksPerUnit * sizeof(int32_t), &retlen, 
+		    (u_char *)part->bam_cache);
+    if (ret) {
+	printk( KERN_WARNING "ftl: Error writing BAM in copy_erase_unit\n");
+	return ret;
+    }
+
+    
+    /* All clear? Then update the LogicalEUN again */
+    ret = part->mbd.mtd->write(part->mbd.mtd, xfer->Offset + 20, sizeof(u_int16_t),
+			   &retlen, (u_char *)&srcunitswap);
+
+    if (ret) {
+	printk(KERN_WARNING "ftl: Error writing new LogicalEUN in copy_erase_unit\n");
+	return ret;
+    }    
+    
+    
+    /* Update the maps and usage stats*/
+    i = xfer->EraseCount;
+    xfer->EraseCount = eun->EraseCount;
+    eun->EraseCount = i;
+    i = xfer->Offset;
+    xfer->Offset = eun->Offset;
+    eun->Offset = i;
+    part->FreeTotal -= eun->Free;
+    part->FreeTotal += free;
+    eun->Free = free;
+    eun->Deleted = 0;
+    
+    /* Now, the cache should be valid for the new block */
+    part->bam_index = srcunit;
+    
+    return 0;
+} /* copy_erase_unit */
+
+/*======================================================================
+
+    reclaim_block() picks a full erase unit and a transfer unit and
+    then calls copy_erase_unit() to copy one to the other.  Then, it
+    schedules an erase on the expired block.
+
+    What's a good way to decide which transfer unit and which erase
+    unit to use?  Beats me.  My way is to always pick the transfer
+    unit with the fewest erases, and usually pick the data unit with
+    the most deleted blocks.  But with a small probability, pick the
+    oldest data unit instead.  This means that we generally postpone
+    the next reclaimation as long as possible, but shuffle static
+    stuff around a bit for wear leveling.
+    
+======================================================================*/
+
+static int reclaim_block(partition_t *part)
+{
+    u_int16_t i, eun, xfer;
+    u_int32_t best;
+    int queued, ret;
+
+    DEBUG(0, "ftl_cs: reclaiming space...\n");
+    DEBUG(3, "NumTransferUnits == %x\n", part->header.NumTransferUnits);
+    /* Pick the least erased transfer unit */
+    best = 0xffffffff; xfer = 0xffff;
+    do {
+	queued = 0;
+	for (i = 0; i < part->header.NumTransferUnits; i++) {
+	    int n=0;
+	    if (part->XferInfo[i].state == XFER_UNKNOWN) {
+		DEBUG(3,"XferInfo[%d].state == XFER_UNKNOWN\n",i);
+		n=1;
+		erase_xfer(part, i);
+	    }
+	    if (part->XferInfo[i].state == XFER_ERASING) {
+		DEBUG(3,"XferInfo[%d].state == XFER_ERASING\n",i);
+		n=1;
+		queued = 1;
+	    }
+	    else if (part->XferInfo[i].state == XFER_ERASED) {
+		DEBUG(3,"XferInfo[%d].state == XFER_ERASED\n",i);
+		n=1;
+		prepare_xfer(part, i);
+	    }
+	    if (part->XferInfo[i].state == XFER_PREPARED) {
+		DEBUG(3,"XferInfo[%d].state == XFER_PREPARED\n",i);
+		n=1;
+		if (part->XferInfo[i].EraseCount <= best) {
+		    best = part->XferInfo[i].EraseCount;
+		    xfer = i;
+		}
+	    }
+		if (!n)
+		    DEBUG(3,"XferInfo[%d].state == %x\n",i, part->XferInfo[i].state);
+
+	}
+	if (xfer == 0xffff) {
+	    if (queued) {
+		DEBUG(1, "ftl_cs: waiting for transfer "
+		      "unit to be prepared...\n");
+		if (part->mbd.mtd->sync)
+			part->mbd.mtd->sync(part->mbd.mtd);
+	    } else {
+		static int ne = 0;
+		if (++ne < 5)
+		    printk(KERN_NOTICE "ftl_cs: reclaim failed: no "
+			   "suitable transfer units!\n");
+		else
+		    DEBUG(1, "ftl_cs: reclaim failed: no "
+			  "suitable transfer units!\n");
+			
+		return -EIO;
+	    }
+	}
+    } while (xfer == 0xffff);
+
+    eun = 0;
+    if ((jiffies % shuffle_freq) == 0) {
+	DEBUG(1, "ftl_cs: recycling freshest block...\n");
+	best = 0xffffffff;
+	for (i = 0; i < part->DataUnits; i++)
+	    if (part->EUNInfo[i].EraseCount <= best) {
+		best = part->EUNInfo[i].EraseCount;
+		eun = i;
+	    }
+    } else {
+	best = 0;
+	for (i = 0; i < part->DataUnits; i++)
+	    if (part->EUNInfo[i].Deleted >= best) {
+		best = part->EUNInfo[i].Deleted;
+		eun = i;
+	    }
+	if (best == 0) {
+	    static int ne = 0;
+	    if (++ne < 5)
+		printk(KERN_NOTICE "ftl_cs: reclaim failed: "
+		       "no free blocks!\n");
+	    else
+		DEBUG(1,"ftl_cs: reclaim failed: "
+		       "no free blocks!\n");
+
+	    return -EIO;
+	}
+    }
+    ret = copy_erase_unit(part, eun, xfer);
+    if (!ret)
+	erase_xfer(part, xfer);
+    else
+	printk(KERN_NOTICE "ftl_cs: copy_erase_unit failed!\n");
+    return ret;
+} /* reclaim_block */
+
+/*======================================================================
+
+    Find_free() searches for a free block.  If necessary, it updates
+    the BAM cache for the erase unit containing the free block.  It
+    returns the block index -- the erase unit is just the currently
+    cached unit.  If there are no free blocks, it returns 0 -- this
+    is never a valid data block because it contains the header.
+    
+======================================================================*/
+
+#ifdef PSYCHO_DEBUG
+static void dump_lists(partition_t *part)
+{
+    int i;
+    printk(KERN_DEBUG "ftl_cs: Free total = %d\n", part->FreeTotal);
+    for (i = 0; i < part->DataUnits; i++)
+	printk(KERN_DEBUG "ftl_cs:   unit %d: %d phys, %d free, "
+	       "%d deleted\n", i,
+	       part->EUNInfo[i].Offset >> part->header.EraseUnitSize,
+	       part->EUNInfo[i].Free, part->EUNInfo[i].Deleted);
+}
+#endif
+
+static u_int32_t find_free(partition_t *part)
+{
+    u_int16_t stop, eun;
+    u_int32_t blk;
+    size_t retlen;
+    int ret;
+    
+    /* Find an erase unit with some free space */
+    stop = (part->bam_index == 0xffff) ? 0 : part->bam_index;
+    eun = stop;
+    do {
+	if (part->EUNInfo[eun].Free != 0) break;
+	/* Wrap around at end of table */
+	if (++eun == part->DataUnits) eun = 0;
+    } while (eun != stop);
+
+    if (part->EUNInfo[eun].Free == 0)
+	return 0;
+    
+    /* Is this unit's BAM cached? */
+    if (eun != part->bam_index) {
+	/* Invalidate cache */
+	part->bam_index = 0xffff;
+
+	ret = part->mbd.mtd->read(part->mbd.mtd, 
+		       part->EUNInfo[eun].Offset + le32_to_cpu(part->header.BAMOffset),
+		       part->BlocksPerUnit * sizeof(u_int32_t),
+		       &retlen, (u_char *) (part->bam_cache));
+	
+	if (ret) {
+	    printk(KERN_WARNING"ftl: Error reading BAM in find_free\n");
+	    return 0;
+	}
+	part->bam_index = eun;
+    }
+
+    /* Find a free block */
+    for (blk = 0; blk < part->BlocksPerUnit; blk++)
+	if (BLOCK_FREE(le32_to_cpu(part->bam_cache[blk]))) break;
+    if (blk == part->BlocksPerUnit) {
+#ifdef PSYCHO_DEBUG
+	static int ne = 0;
+	if (++ne == 1)
+	    dump_lists(part);
+#endif
+	printk(KERN_NOTICE "ftl_cs: bad free list!\n");
+	return 0;
+    }
+    DEBUG(2, "ftl_cs: found free block at %d in %d\n", blk, eun);
+    return blk;
+    
+} /* find_free */
+
+
+/*======================================================================
+
+    Read a series of sectors from an FTL partition.
+    
+======================================================================*/
+
+static int ftl_read(partition_t *part, caddr_t buffer,
+		    u_long sector, u_long nblocks)
+{
+    u_int32_t log_addr, bsize;
+    u_long i;
+    int ret;
+    size_t offset, retlen;
+    
+    DEBUG(2, "ftl_cs: ftl_read(0x%p, 0x%lx, %ld)\n",
+	  part, sector, nblocks);
+    if (!(part->state & FTL_FORMATTED)) {
+	printk(KERN_NOTICE "ftl_cs: bad partition\n");
+	return -EIO;
+    }
+    bsize = 1 << part->header.EraseUnitSize;
+
+    for (i = 0; i < nblocks; i++) {
+	if (((sector+i) * SECTOR_SIZE) >= le32_to_cpu(part->header.FormattedSize)) {
+	    printk(KERN_NOTICE "ftl_cs: bad read offset\n");
+	    return -EIO;
+	}
+	log_addr = part->VirtualBlockMap[sector+i];
+	if (log_addr == 0xffffffff)
+	    memset(buffer, 0, SECTOR_SIZE);
+	else {
+	    offset = (part->EUNInfo[log_addr / bsize].Offset
+			  + (log_addr % bsize));
+	    ret = part->mbd.mtd->read(part->mbd.mtd, offset, SECTOR_SIZE,
+			   &retlen, (u_char *) buffer);
+
+	    if (ret) {
+		printk(KERN_WARNING "Error reading MTD device in ftl_read()\n");
+		return ret;
+	    }
+	}
+	buffer += SECTOR_SIZE;
+    }
+    return 0;
+} /* ftl_read */
+
+/*======================================================================
+
+    Write a series of sectors to an FTL partition
+    
+======================================================================*/
+
+static int set_bam_entry(partition_t *part, u_int32_t log_addr,
+			 u_int32_t virt_addr)
+{
+    u_int32_t bsize, blk, le_virt_addr;
+#ifdef PSYCHO_DEBUG
+    u_int32_t old_addr;
+#endif
+    u_int16_t eun;
+    int ret;
+    size_t retlen, offset;
+
+    DEBUG(2, "ftl_cs: set_bam_entry(0x%p, 0x%x, 0x%x)\n",
+	  part, log_addr, virt_addr);
+    bsize = 1 << part->header.EraseUnitSize;
+    eun = log_addr / bsize;
+    blk = (log_addr % bsize) / SECTOR_SIZE;
+    offset = (part->EUNInfo[eun].Offset + blk * sizeof(u_int32_t) +
+		  le32_to_cpu(part->header.BAMOffset));
+    
+#ifdef PSYCHO_DEBUG
+    ret = part->mbd.mtd->read(part->mbd.mtd, offset, sizeof(u_int32_t),
+                        &retlen, (u_char *)&old_addr);
+    if (ret) {
+	printk(KERN_WARNING"ftl: Error reading old_addr in set_bam_entry: %d\n",ret);
+	return ret;
+    }
+    old_addr = le32_to_cpu(old_addr);
+
+    if (((virt_addr == 0xfffffffe) && !BLOCK_FREE(old_addr)) ||
+	((virt_addr == 0) && (BLOCK_TYPE(old_addr) != BLOCK_DATA)) ||
+	(!BLOCK_DELETED(virt_addr) && (old_addr != 0xfffffffe))) {
+	static int ne = 0;
+	if (++ne < 5) {
+	    printk(KERN_NOTICE "ftl_cs: set_bam_entry() inconsistency!\n");
+	    printk(KERN_NOTICE "ftl_cs:   log_addr = 0x%x, old = 0x%x"
+		   ", new = 0x%x\n", log_addr, old_addr, virt_addr);
+	}
+	return -EIO;
+    }
+#endif
+    le_virt_addr = cpu_to_le32(virt_addr);
+    if (part->bam_index == eun) {
+#ifdef PSYCHO_DEBUG
+	if (le32_to_cpu(part->bam_cache[blk]) != old_addr) {
+	    static int ne = 0;
+	    if (++ne < 5) {
+		printk(KERN_NOTICE "ftl_cs: set_bam_entry() "
+		       "inconsistency!\n");
+		printk(KERN_NOTICE "ftl_cs:   log_addr = 0x%x, cache"
+		       " = 0x%x\n",
+		       le32_to_cpu(part->bam_cache[blk]), old_addr);
+	    }
+	    return -EIO;
+	}
+#endif
+	part->bam_cache[blk] = le_virt_addr;
+    }
+    ret = part->mbd.mtd->write(part->mbd.mtd, offset, sizeof(u_int32_t),
+                            &retlen, (u_char *)&le_virt_addr);
+
+    if (ret) {
+	printk(KERN_NOTICE "ftl_cs: set_bam_entry() failed!\n");
+	printk(KERN_NOTICE "ftl_cs:   log_addr = 0x%x, new = 0x%x\n",
+	       log_addr, virt_addr);
+    }
+    return ret;
+} /* set_bam_entry */
+
+static int ftl_write(partition_t *part, caddr_t buffer,
+		     u_long sector, u_long nblocks)
+{
+    u_int32_t bsize, log_addr, virt_addr, old_addr, blk;
+    u_long i;
+    int ret;
+    size_t retlen, offset;
+
+    DEBUG(2, "ftl_cs: ftl_write(0x%p, %ld, %ld)\n",
+	  part, sector, nblocks);
+    if (!(part->state & FTL_FORMATTED)) {
+	printk(KERN_NOTICE "ftl_cs: bad partition\n");
+	return -EIO;
+    }
+    /* See if we need to reclaim space, before we start */
+    while (part->FreeTotal < nblocks) {
+	ret = reclaim_block(part);
+	if (ret)
+	    return ret;
+    }
+    
+    bsize = 1 << part->header.EraseUnitSize;
+
+    virt_addr = sector * SECTOR_SIZE | BLOCK_DATA;
+    for (i = 0; i < nblocks; i++) {
+	if (virt_addr >= le32_to_cpu(part->header.FormattedSize)) {
+	    printk(KERN_NOTICE "ftl_cs: bad write offset\n");
+	    return -EIO;
+	}
+
+	/* Grab a free block */
+	blk = find_free(part);
+	if (blk == 0) {
+	    static int ne = 0;
+	    if (++ne < 5)
+		printk(KERN_NOTICE "ftl_cs: internal error: "
+		       "no free blocks!\n");
+	    return -ENOSPC;
+	}
+
+	/* Tag the BAM entry, and write the new block */
+	log_addr = part->bam_index * bsize + blk * SECTOR_SIZE;
+	part->EUNInfo[part->bam_index].Free--;
+	part->FreeTotal--;
+	if (set_bam_entry(part, log_addr, 0xfffffffe)) 
+	    return -EIO;
+	part->EUNInfo[part->bam_index].Deleted++;
+	offset = (part->EUNInfo[part->bam_index].Offset +
+		      blk * SECTOR_SIZE);
+	ret = part->mbd.mtd->write(part->mbd.mtd, offset, SECTOR_SIZE, &retlen, 
+                                     buffer);
+
+	if (ret) {
+	    printk(KERN_NOTICE "ftl_cs: block write failed!\n");
+	    printk(KERN_NOTICE "ftl_cs:   log_addr = 0x%x, virt_addr"
+		   " = 0x%x, Offset = 0x%zx\n", log_addr, virt_addr,
+		   offset);
+	    return -EIO;
+	}
+	
+	/* Only delete the old entry when the new entry is ready */
+	old_addr = part->VirtualBlockMap[sector+i];
+	if (old_addr != 0xffffffff) {
+	    part->VirtualBlockMap[sector+i] = 0xffffffff;
+	    part->EUNInfo[old_addr/bsize].Deleted++;
+	    if (set_bam_entry(part, old_addr, 0))
+		return -EIO;
+	}
+
+	/* Finally, set up the new pointers */
+	if (set_bam_entry(part, log_addr, virt_addr))
+	    return -EIO;
+	part->VirtualBlockMap[sector+i] = log_addr;
+	part->EUNInfo[part->bam_index].Deleted--;
+	
+	buffer += SECTOR_SIZE;
+	virt_addr += SECTOR_SIZE;
+    }
+    return 0;
+} /* ftl_write */
+
+static int ftl_getgeo(struct mtd_blktrans_dev *dev, struct hd_geometry *geo)
+{
+	partition_t *part = (void *)dev;
+	u_long sect;
+
+	/* Sort of arbitrary: round size down to 4KiB boundary */
+	sect = le32_to_cpu(part->header.FormattedSize)/SECTOR_SIZE;
+
+	geo->heads = 1;
+	geo->sectors = 8;
+	geo->cylinders = sect >> 3;
+
+	return 0;
+}
+
+static int ftl_readsect(struct mtd_blktrans_dev *dev,
+			      unsigned long block, char *buf)
+{
+	return ftl_read((void *)dev, buf, block, 1);
+}
+
+static int ftl_writesect(struct mtd_blktrans_dev *dev,
+			      unsigned long block, char *buf)
+{
+	return ftl_write((void *)dev, buf, block, 1);
+}
+
+/*====================================================================*/
+
+void ftl_freepart(partition_t *part)
+{
+    if (part->VirtualBlockMap) {
+	vfree(part->VirtualBlockMap);
+	part->VirtualBlockMap = NULL;
+    }
+    if (part->VirtualPageMap) {
+	kfree(part->VirtualPageMap);
+	part->VirtualPageMap = NULL;
+    }
+    if (part->EUNInfo) {
+	kfree(part->EUNInfo);
+	part->EUNInfo = NULL;
+    }
+    if (part->XferInfo) {
+	kfree(part->XferInfo);
+	part->XferInfo = NULL;
+    }
+    if (part->bam_cache) {
+	kfree(part->bam_cache);
+	part->bam_cache = NULL;
+    }
+    
+} /* ftl_freepart */
+
+static void ftl_add_mtd(struct mtd_blktrans_ops *tr, struct mtd_info *mtd)
+{
+	partition_t *partition;
+
+	partition = kmalloc(sizeof(partition_t), GFP_KERNEL);
+		
+	if (!partition) {
+		printk(KERN_WARNING "No memory to scan for FTL on %s\n",
+		       mtd->name);
+		return;
+	}    
+
+	memset(partition, 0, sizeof(partition_t));
+
+	partition->mbd.mtd = mtd;
+
+	if ((scan_header(partition) == 0) && 
+	    (build_maps(partition) == 0)) {
+		
+		partition->state = FTL_FORMATTED;
+#ifdef PCMCIA_DEBUG
+		printk(KERN_INFO "ftl_cs: opening %d KiB FTL partition\n",
+		       le32_to_cpu(partition->header.FormattedSize) >> 10);
+#endif
+		partition->mbd.size = le32_to_cpu(partition->header.FormattedSize) >> 9;
+		partition->mbd.blksize = SECTOR_SIZE;
+		partition->mbd.tr = tr;
+		partition->mbd.devnum = -1;
+		if (!add_mtd_blktrans_dev((void *)partition))
+			return;
+	}
+
+	ftl_freepart(partition);
+	kfree(partition);
+}
+
+static void ftl_remove_dev(struct mtd_blktrans_dev *dev)
+{
+	del_mtd_blktrans_dev(dev);
+	ftl_freepart((partition_t *)dev);
+	kfree(dev);
+}
+
+struct mtd_blktrans_ops ftl_tr = {
+	.name		= "ftl",
+	.major		= FTL_MAJOR,
+	.part_bits	= PART_BITS,
+	.readsect	= ftl_readsect,
+	.writesect	= ftl_writesect,
+	.getgeo		= ftl_getgeo,
+	.add_mtd	= ftl_add_mtd,
+	.remove_dev	= ftl_remove_dev,
+	.owner		= THIS_MODULE,
+};
+
+int init_ftl(void)
+{
+	DEBUG(0, "$Id: ftl.c,v 1.54 2004/11/16 18:33:15 dwmw2 Exp $\n");
+
+	return register_mtd_blktrans(&ftl_tr);
+}
+
+static void __exit cleanup_ftl(void)
+{
+	deregister_mtd_blktrans(&ftl_tr);
+}
+
+module_init(init_ftl);
+module_exit(cleanup_ftl);
+
+
+MODULE_LICENSE("Dual MPL/GPL");
+MODULE_AUTHOR("David Hinds <dahinds@users.sourceforge.net>");
+MODULE_DESCRIPTION("Support code for Flash Translation Layer, used on PCMCIA devices");
