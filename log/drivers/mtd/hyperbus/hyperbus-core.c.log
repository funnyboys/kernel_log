commit b6fe8bc67d2d33a9eff1b0785482bccd14979115
Author: Sergei Shtylyov <sergei.shtylyov@cogentembedded.com>
Date:   Wed Jan 29 23:37:37 2020 +0300

    mtd: hyperbus: move direct mapping setup to AM654 HBMC driver
    
    The Hyperbus core expects that HyperFlash is always directly mapped for
    both read and write, but in reality this may not always be the case, e.g.
    Renesas RPC-IF has read only direct mapping. Move the code setting up the
    direct mapping from the Hyperbus core to thh TI AM554 HBMC driver.
    
    Signed-off-by: Sergei Shtylyov <sergei.shtylyov@cogentembedded.com>
    Signed-off-by: Vignesh Raghavendra <vigneshr@ti.com>

diff --git a/drivers/mtd/hyperbus/hyperbus-core.c b/drivers/mtd/hyperbus/hyperbus-core.c
index c1916cca1701..32685e8dd278 100644
--- a/drivers/mtd/hyperbus/hyperbus-core.c
+++ b/drivers/mtd/hyperbus/hyperbus-core.c
@@ -10,7 +10,6 @@
 #include <linux/mtd/map.h>
 #include <linux/mtd/mtd.h>
 #include <linux/of.h>
-#include <linux/of_address.h>
 #include <linux/types.h>
 
 static struct hyperbus_device *map_to_hbdev(struct map_info *map)
@@ -62,7 +61,6 @@ int hyperbus_register_device(struct hyperbus_device *hbdev)
 	struct hyperbus_ctlr *ctlr;
 	struct device_node *np;
 	struct map_info *map;
-	struct resource res;
 	struct device *dev;
 	int ret;
 
@@ -80,17 +78,8 @@ int hyperbus_register_device(struct hyperbus_device *hbdev)
 
 	hbdev->memtype = HYPERFLASH;
 
-	ret = of_address_to_resource(np, 0, &res);
-	if (ret)
-		return ret;
-
 	dev = ctlr->dev;
 	map = &hbdev->map;
-	map->size = resource_size(&res);
-	map->virt = devm_ioremap_resource(dev, &res);
-	if (IS_ERR(map->virt))
-		return PTR_ERR(map->virt);
-
 	map->name = dev_name(dev);
 	map->bankwidth = 2;
 	map->device_node = np;

commit cb6176ef25cef7a54ac1e8701f9dde822fce5cee
Author: Dirk Behme <dirk.behme@de.bosch.com>
Date:   Tue Feb 4 08:10:43 2020 +0100

    mtd: hyperbus: Add proper error message for missing compatible
    
    In case the compatible "cypress,hyperflash" is not given
    output a proper error message.
    
    Signed-off-by: Dirk Behme <dirk.behme@de.bosch.com>
    Signed-off-by: Vignesh Raghavendra <vigneshr@ti.com>

diff --git a/drivers/mtd/hyperbus/hyperbus-core.c b/drivers/mtd/hyperbus/hyperbus-core.c
index 6af9ea34117d..c1916cca1701 100644
--- a/drivers/mtd/hyperbus/hyperbus-core.c
+++ b/drivers/mtd/hyperbus/hyperbus-core.c
@@ -73,8 +73,10 @@ int hyperbus_register_device(struct hyperbus_device *hbdev)
 
 	np = hbdev->np;
 	ctlr = hbdev->ctlr;
-	if (!of_device_is_compatible(np, "cypress,hyperflash"))
+	if (!of_device_is_compatible(np, "cypress,hyperflash")) {
+		dev_err(ctlr->dev, "\"cypress,hyperflash\" compatible missing\n");
 		return -ENODEV;
+	}
 
 	hbdev->memtype = HYPERFLASH;
 

commit dcc7d3446a0fa19bd7e8074920b8f9ef3b7ec00c
Author: Vignesh Raghavendra <vigneshr@ti.com>
Date:   Tue Jun 25 13:27:44 2019 +0530

    mtd: Add support for HyperBus memory devices
    
    Cypress' HyperBus is Low Signal Count, High Performance Double Data Rate
    Bus interface between a host system master and one or more slave
    interfaces. HyperBus is used to connect microprocessor, microcontroller,
    or ASIC devices with random access NOR flash memory (called HyperFlash)
    or self refresh DRAM (called HyperRAM).
    
    Its a 8-bit data bus (DQ[7:0]) with  Read-Write Data Strobe (RWDS)
    signal and either Single-ended clock(3.0V parts) or Differential clock
    (1.8V parts). It uses ChipSelect lines to select b/w multiple slaves.
    At bus level, it follows a separate protocol described in HyperBus
    specification[1].
    
    HyperFlash follows CFI AMD/Fujitsu Extended Command Set (0x0002) similar
    to that of existing parallel NORs. Since HyperBus is x8 DDR bus,
    its equivalent to x16 parallel NOR flash with respect to bits per clock
    cycle. But HyperBus operates at >166MHz frequencies.
    HyperRAM provides direct random read/write access to flash memory
    array.
    
    But, HyperBus memory controllers seem to abstract implementation details
    and expose a simple MMIO interface to access connected flash.
    
    Add support for registering HyperFlash devices with MTD framework. MTD
    maps framework along with CFI chip support framework are used to support
    communicating with flash.
    
    Framework is modelled along the lines of spi-nor framework. HyperBus
    memory controller (HBMC) drivers calls hyperbus_register_device() to
    register a single HyperFlash device. HyperFlash core parses MMIO access
    information from DT, sets up the map_info struct, probes CFI flash and
    registers it with MTD framework.
    
    Some HBMC masters need calibration/training sequence[3] to be carried
    out, in order for DLL inside the controller to lock, by reading a known
    string/pattern. This is done by repeatedly reading CFI Query
    Identification String. Calibration needs to be done before trying to detect
    flash as part of CFI flash probe.
    
    HyperRAM is not supported at the moment.
    
    HyperBus specification can be found at[1]
    HyperFlash datasheet can be found at[2]
    
    [1] https://www.cypress.com/file/213356/download
    [2] https://www.cypress.com/file/213346/download
    [3] http://www.ti.com/lit/ug/spruid7b/spruid7b.pdf
        Table 12-5741. HyperFlash Access Sequence
    
    Signed-off-by: Vignesh Raghavendra <vigneshr@ti.com>
    Signed-off-by: Miquel Raynal <miquel.raynal@bootlin.com>

diff --git a/drivers/mtd/hyperbus/hyperbus-core.c b/drivers/mtd/hyperbus/hyperbus-core.c
new file mode 100644
index 000000000000..6af9ea34117d
--- /dev/null
+++ b/drivers/mtd/hyperbus/hyperbus-core.c
@@ -0,0 +1,153 @@
+// SPDX-License-Identifier: GPL-2.0
+//
+// Copyright (C) 2019 Texas Instruments Incorporated - http://www.ti.com/
+// Author: Vignesh Raghavendra <vigneshr@ti.com>
+
+#include <linux/err.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/mtd/hyperbus.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/mtd.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/types.h>
+
+static struct hyperbus_device *map_to_hbdev(struct map_info *map)
+{
+	return container_of(map, struct hyperbus_device, map);
+}
+
+static map_word hyperbus_read16(struct map_info *map, unsigned long addr)
+{
+	struct hyperbus_device *hbdev = map_to_hbdev(map);
+	struct hyperbus_ctlr *ctlr = hbdev->ctlr;
+	map_word read_data;
+
+	read_data.x[0] = ctlr->ops->read16(hbdev, addr);
+
+	return read_data;
+}
+
+static void hyperbus_write16(struct map_info *map, map_word d,
+			     unsigned long addr)
+{
+	struct hyperbus_device *hbdev = map_to_hbdev(map);
+	struct hyperbus_ctlr *ctlr = hbdev->ctlr;
+
+	ctlr->ops->write16(hbdev, addr, d.x[0]);
+}
+
+static void hyperbus_copy_from(struct map_info *map, void *to,
+			       unsigned long from, ssize_t len)
+{
+	struct hyperbus_device *hbdev = map_to_hbdev(map);
+	struct hyperbus_ctlr *ctlr = hbdev->ctlr;
+
+	ctlr->ops->copy_from(hbdev, to, from, len);
+}
+
+static void hyperbus_copy_to(struct map_info *map, unsigned long to,
+			     const void *from, ssize_t len)
+{
+	struct hyperbus_device *hbdev = map_to_hbdev(map);
+	struct hyperbus_ctlr *ctlr = hbdev->ctlr;
+
+	ctlr->ops->copy_to(hbdev, to, from, len);
+}
+
+int hyperbus_register_device(struct hyperbus_device *hbdev)
+{
+	const struct hyperbus_ops *ops;
+	struct hyperbus_ctlr *ctlr;
+	struct device_node *np;
+	struct map_info *map;
+	struct resource res;
+	struct device *dev;
+	int ret;
+
+	if (!hbdev || !hbdev->np || !hbdev->ctlr || !hbdev->ctlr->dev) {
+		pr_err("hyperbus: please fill all the necessary fields!\n");
+		return -EINVAL;
+	}
+
+	np = hbdev->np;
+	ctlr = hbdev->ctlr;
+	if (!of_device_is_compatible(np, "cypress,hyperflash"))
+		return -ENODEV;
+
+	hbdev->memtype = HYPERFLASH;
+
+	ret = of_address_to_resource(np, 0, &res);
+	if (ret)
+		return ret;
+
+	dev = ctlr->dev;
+	map = &hbdev->map;
+	map->size = resource_size(&res);
+	map->virt = devm_ioremap_resource(dev, &res);
+	if (IS_ERR(map->virt))
+		return PTR_ERR(map->virt);
+
+	map->name = dev_name(dev);
+	map->bankwidth = 2;
+	map->device_node = np;
+
+	simple_map_init(map);
+	ops = ctlr->ops;
+	if (ops) {
+		if (ops->read16)
+			map->read = hyperbus_read16;
+		if (ops->write16)
+			map->write = hyperbus_write16;
+		if (ops->copy_to)
+			map->copy_to = hyperbus_copy_to;
+		if (ops->copy_from)
+			map->copy_from = hyperbus_copy_from;
+
+		if (ops->calibrate && !ctlr->calibrated) {
+			ret = ops->calibrate(hbdev);
+			if (!ret) {
+				dev_err(dev, "Calibration failed\n");
+				return -ENODEV;
+			}
+			ctlr->calibrated = true;
+		}
+	}
+
+	hbdev->mtd = do_map_probe("cfi_probe", map);
+	if (!hbdev->mtd) {
+		dev_err(dev, "probing of hyperbus device failed\n");
+		return -ENODEV;
+	}
+
+	hbdev->mtd->dev.parent = dev;
+	mtd_set_of_node(hbdev->mtd, np);
+
+	ret = mtd_device_register(hbdev->mtd, NULL, 0);
+	if (ret) {
+		dev_err(dev, "failed to register mtd device\n");
+		map_destroy(hbdev->mtd);
+		return ret;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(hyperbus_register_device);
+
+int hyperbus_unregister_device(struct hyperbus_device *hbdev)
+{
+	int ret = 0;
+
+	if (hbdev && hbdev->mtd) {
+		ret = mtd_device_unregister(hbdev->mtd);
+		map_destroy(hbdev->mtd);
+	}
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(hyperbus_unregister_device);
+
+MODULE_DESCRIPTION("HyperBus Framework");
+MODULE_LICENSE("GPL v2");
+MODULE_AUTHOR("Vignesh Raghavendra <vigneshr@ti.com>");
