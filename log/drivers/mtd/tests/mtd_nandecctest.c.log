commit 09c434b8a0047c69e48499de0107de312901e798
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sun May 19 13:08:20 2019 +0100

    treewide: Add SPDX license identifier for more missed files
    
    Add SPDX license identifiers to all files which:
    
     - Have no license information of any form
    
     - Have MODULE_LICENCE("GPL*") inside which was used in the initial
       scan/conversion to ignore the file
    
    These files fall under the project license, GPL v2 only. The resulting SPDX
    license identifier is:
    
      GPL-2.0-only
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/mtd/tests/mtd_nandecctest.c b/drivers/mtd/tests/mtd_nandecctest.c
index 73b06304c975..13bca9ea0cae 100644
--- a/drivers/mtd/tests/mtd_nandecctest.c
+++ b/drivers/mtd/tests/mtd_nandecctest.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-only
 #define pr_fmt(fmt)	KBUILD_MODNAME ": " fmt
 
 #include <linux/kernel.h>

commit 72c5af00272339af6bbed6fe7275cd731f57be2d
Author: Miquel Raynal <miquel.raynal@bootlin.com>
Date:   Wed Feb 6 16:47:44 2019 +0100

    mtd: rawnand: Clarify Kconfig entry MTD_NAND
    
    MTD_NAND is large and encloses much more than what the symbol is
    actually used for: raw NAND. Clarify the symbol by naming it
    MTD_RAW_NAND instead.
    
    Signed-off-by: Miquel Raynal <miquel.raynal@bootlin.com>

diff --git a/drivers/mtd/tests/mtd_nandecctest.c b/drivers/mtd/tests/mtd_nandecctest.c
index 0c0091fb3708..73b06304c975 100644
--- a/drivers/mtd/tests/mtd_nandecctest.c
+++ b/drivers/mtd/tests/mtd_nandecctest.c
@@ -21,7 +21,7 @@
  * or detected.
  */
 
-#if IS_ENABLED(CONFIG_MTD_NAND)
+#if IS_ENABLED(CONFIG_MTD_RAW_NAND)
 
 struct nand_ecc_test {
 	const char *name;

commit 9bb94643b94115990ffec18c8129f1ab970765c1
Author: Miquel Raynal <miquel.raynal@bootlin.com>
Date:   Fri Feb 8 08:48:37 2019 +0100

    mtd: nand: Clarify Kconfig entry for software Hamming ECC entries
    
    The software Hamming ECC correction implementation is referred as
    MTD_NAND_ECC which is too generic. Rename it
    MTD_NAND_ECC_SW_HAMMING. Also rename MTD_NAND_ECC_SMC which is an
    SMC quirk in the Hamming implementation as
    MTD_NAND_ECC_SW_HAMMING_SMC.
    
    Signed-off-by: Miquel Raynal <miquel.raynal@bootlin.com>

diff --git a/drivers/mtd/tests/mtd_nandecctest.c b/drivers/mtd/tests/mtd_nandecctest.c
index c71523e94580..0c0091fb3708 100644
--- a/drivers/mtd/tests/mtd_nandecctest.c
+++ b/drivers/mtd/tests/mtd_nandecctest.c
@@ -122,9 +122,9 @@ static int no_bit_error_verify(void *error_data, void *error_ecc,
 	int ret;
 
 	__nand_calculate_ecc(error_data, size, calc_ecc,
-			     IS_ENABLED(CONFIG_MTD_NAND_ECC_SMC));
+			     IS_ENABLED(CONFIG_MTD_NAND_ECC_SW_HAMMING_SMC));
 	ret = __nand_correct_data(error_data, error_ecc, calc_ecc, size,
-				  IS_ENABLED(CONFIG_MTD_NAND_ECC_SMC));
+				  IS_ENABLED(CONFIG_MTD_NAND_ECC_SW_HAMMING_SMC));
 	if (ret == 0 && !memcmp(correct_data, error_data, size))
 		return 0;
 
@@ -152,9 +152,9 @@ static int single_bit_error_correct(void *error_data, void *error_ecc,
 	int ret;
 
 	__nand_calculate_ecc(error_data, size, calc_ecc,
-			     IS_ENABLED(CONFIG_MTD_NAND_ECC_SMC));
+			     IS_ENABLED(CONFIG_MTD_NAND_ECC_SW_HAMMING_SMC));
 	ret = __nand_correct_data(error_data, error_ecc, calc_ecc, size,
-				  IS_ENABLED(CONFIG_MTD_NAND_ECC_SMC));
+				  IS_ENABLED(CONFIG_MTD_NAND_ECC_SW_HAMMING_SMC));
 	if (ret == 1 && !memcmp(correct_data, error_data, size))
 		return 0;
 
@@ -189,9 +189,9 @@ static int double_bit_error_detect(void *error_data, void *error_ecc,
 	int ret;
 
 	__nand_calculate_ecc(error_data, size, calc_ecc,
-			     IS_ENABLED(CONFIG_MTD_NAND_ECC_SMC));
+			     IS_ENABLED(CONFIG_MTD_NAND_ECC_SW_HAMMING_SMC));
 	ret = __nand_correct_data(error_data, error_ecc, calc_ecc, size,
-				  IS_ENABLED(CONFIG_MTD_NAND_ECC_SMC));
+				  IS_ENABLED(CONFIG_MTD_NAND_ECC_SW_HAMMING_SMC));
 
 	return (ret == -EBADMSG) ? 0 : -EINVAL;
 }
@@ -266,7 +266,7 @@ static int nand_ecc_test_run(const size_t size)
 
 	prandom_bytes(correct_data, size);
 	__nand_calculate_ecc(correct_data, size, correct_ecc,
-			     IS_ENABLED(CONFIG_MTD_NAND_ECC_SMC));
+			     IS_ENABLED(CONFIG_MTD_NAND_ECC_SW_HAMMING_SMC));
 
 	for (i = 0; i < ARRAY_SIZE(nand_ecc_test); i++) {
 		nand_ecc_test[i].prepare(error_data, error_ecc,

commit 309600c14e36d0e78c22fe3df58317965b90f4d1
Author: Boris Brezillon <boris.brezillon@bootlin.com>
Date:   Tue Sep 4 16:23:28 2018 +0200

    mtd: rawnand: Allow selection of ECC byte ordering at runtime
    
    Currently, the selection of ECC byte ordering for software hamming is
    done at compilation time, which doesn't make sense when ECC byte
    calculation is done in hardware and byte ordering is forced by the
    hardware engine.
    In this case, only the correction is done in software and we want to
    force the byte-ordering no matter the value of CONFIG_MTD_NAND_ECC_SMC.
    
    This is typically the case for the FSMC (Smart Media ordering), TMIO and
    TXX9NDFMC (regular byte ordering) blocks.
    
    For all other use cases (pure software implementation, SM FTL and
    nandecctest), we keep selecting the byte ordering based on the
    CONFIG_MTD_NAND_ECC_SMC value. It might not be ideal for SM FTL (I'd
    expect Smart Media ordering to be employed by the Smart Media FTL), but
    this option doesn't seem to be enabled in the existing _defconfig, so
    I can't tell setting sm_order to true is the right choice.
    
    Signed-off-by: Boris Brezillon <boris.brezillon@bootlin.com>
    Signed-off-by: Miquel Raynal <miquel.raynal@bootlin.com>

diff --git a/drivers/mtd/tests/mtd_nandecctest.c b/drivers/mtd/tests/mtd_nandecctest.c
index 88b6c81cebbe..c71523e94580 100644
--- a/drivers/mtd/tests/mtd_nandecctest.c
+++ b/drivers/mtd/tests/mtd_nandecctest.c
@@ -121,8 +121,10 @@ static int no_bit_error_verify(void *error_data, void *error_ecc,
 	unsigned char calc_ecc[3];
 	int ret;
 
-	__nand_calculate_ecc(error_data, size, calc_ecc);
-	ret = __nand_correct_data(error_data, error_ecc, calc_ecc, size);
+	__nand_calculate_ecc(error_data, size, calc_ecc,
+			     IS_ENABLED(CONFIG_MTD_NAND_ECC_SMC));
+	ret = __nand_correct_data(error_data, error_ecc, calc_ecc, size,
+				  IS_ENABLED(CONFIG_MTD_NAND_ECC_SMC));
 	if (ret == 0 && !memcmp(correct_data, error_data, size))
 		return 0;
 
@@ -149,8 +151,10 @@ static int single_bit_error_correct(void *error_data, void *error_ecc,
 	unsigned char calc_ecc[3];
 	int ret;
 
-	__nand_calculate_ecc(error_data, size, calc_ecc);
-	ret = __nand_correct_data(error_data, error_ecc, calc_ecc, size);
+	__nand_calculate_ecc(error_data, size, calc_ecc,
+			     IS_ENABLED(CONFIG_MTD_NAND_ECC_SMC));
+	ret = __nand_correct_data(error_data, error_ecc, calc_ecc, size,
+				  IS_ENABLED(CONFIG_MTD_NAND_ECC_SMC));
 	if (ret == 1 && !memcmp(correct_data, error_data, size))
 		return 0;
 
@@ -184,8 +188,10 @@ static int double_bit_error_detect(void *error_data, void *error_ecc,
 	unsigned char calc_ecc[3];
 	int ret;
 
-	__nand_calculate_ecc(error_data, size, calc_ecc);
-	ret = __nand_correct_data(error_data, error_ecc, calc_ecc, size);
+	__nand_calculate_ecc(error_data, size, calc_ecc,
+			     IS_ENABLED(CONFIG_MTD_NAND_ECC_SMC));
+	ret = __nand_correct_data(error_data, error_ecc, calc_ecc, size,
+				  IS_ENABLED(CONFIG_MTD_NAND_ECC_SMC));
 
 	return (ret == -EBADMSG) ? 0 : -EINVAL;
 }
@@ -259,7 +265,8 @@ static int nand_ecc_test_run(const size_t size)
 	}
 
 	prandom_bytes(correct_data, size);
-	__nand_calculate_ecc(correct_data, size, correct_ecc);
+	__nand_calculate_ecc(correct_data, size, correct_ecc,
+			     IS_ENABLED(CONFIG_MTD_NAND_ECC_SMC));
 
 	for (i = 0; i < ARRAY_SIZE(nand_ecc_test); i++) {
 		nand_ecc_test[i].prepare(error_data, error_ecc,

commit c57753d4541d5104284abbdceb841e690394e55f
Author: Jorge Ramirez-Ortiz <jorge.ramirez-ortiz@linaro.org>
Date:   Tue Mar 1 16:04:00 2016 -0500

    mtd: nand: tests: fix regression introduced in mtd_nandectest
    
    Offending Commit: 6e94119 "mtd: nand: return consistent error codes in
    ecc.correct() implementations"
    
    The new error code was not being handled properly in double bit error
    detection.
    
    Signed-off-by: Jorge Ramirez-Ortiz <jorge.ramirez-ortiz@linaro.org>
    Reviewed-by: Boris Brezillon <boris.brezillon@free-electrons.com>
    Tested-by: Franklin S Cooper Jr <fcooper@ti.com>
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>

diff --git a/drivers/mtd/tests/mtd_nandecctest.c b/drivers/mtd/tests/mtd_nandecctest.c
index 79316159eec6..88b6c81cebbe 100644
--- a/drivers/mtd/tests/mtd_nandecctest.c
+++ b/drivers/mtd/tests/mtd_nandecctest.c
@@ -187,7 +187,7 @@ static int double_bit_error_detect(void *error_data, void *error_ecc,
 	__nand_calculate_ecc(error_data, size, calc_ecc);
 	ret = __nand_correct_data(error_data, error_ecc, calc_ecc, size);
 
-	return (ret == -1) ? 0 : -EINVAL;
+	return (ret == -EBADMSG) ? 0 : -EINVAL;
 }
 
 static const struct nand_ecc_test nand_ecc_test[] = {

commit 2a6a28e7922c07c116ba8f2aa3682c03ef8be678
Author: Richard Weinberger <richard@nod.at>
Date:   Sun Mar 29 21:52:06 2015 +0200

    mtd: Make MTD tests cancelable
    
    I always go nuts when I start an MTD test on a slow device and have to
    wait forever until it finishes. From the debug output I already know
    what the issue is but I have to wait or reset the board hard. Resetting
    is often not an option (remote access, you don't want lose the current
    state, etc...).
    
    The solution is easy, check for pending signals at key positions in the
    code. Using that one can even stop a test by pressing CTRL-C as
    insmod/modprobe have SIGINT pending.
    
    Signed-off-by: Richard Weinberger <richard@nod.at>
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>

diff --git a/drivers/mtd/tests/mtd_nandecctest.c b/drivers/mtd/tests/mtd_nandecctest.c
index e579f9027c47..79316159eec6 100644
--- a/drivers/mtd/tests/mtd_nandecctest.c
+++ b/drivers/mtd/tests/mtd_nandecctest.c
@@ -9,6 +9,8 @@
 #include <linux/slab.h>
 #include <linux/mtd/nand_ecc.h>
 
+#include "mtd_test.h"
+
 /*
  * Test the implementation for software ECC
  *
@@ -274,6 +276,10 @@ static int nand_ecc_test_run(const size_t size)
 		}
 		pr_info("ok - %s-%zd\n",
 			nand_ecc_test[i].name, size);
+
+		err = mtdtest_relax();
+		if (err)
+			break;
 	}
 error:
 	kfree(error_data);

commit 7e8eb8ae6618a82e598fe11ac01839d0bc4a5520
Author: Fabio Estevam <fabio.estevam@freescale.com>
Date:   Mon Dec 2 00:30:27 2013 -0200

    mtd: tests: mtd_nandecctest: Use IS_ENABLED() macro
    
    Using the IS_ENABLED() macro can make the code shorter and simpler.
    
    Signed-off-by: Fabio Estevam <fabio.estevam@freescale.com>
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>

diff --git a/drivers/mtd/tests/mtd_nandecctest.c b/drivers/mtd/tests/mtd_nandecctest.c
index 70106607c247..e579f9027c47 100644
--- a/drivers/mtd/tests/mtd_nandecctest.c
+++ b/drivers/mtd/tests/mtd_nandecctest.c
@@ -19,7 +19,7 @@
  * or detected.
  */
 
-#if defined(CONFIG_MTD_NAND) || defined(CONFIG_MTD_NAND_MODULE)
+#if IS_ENABLED(CONFIG_MTD_NAND)
 
 struct nand_ecc_test {
 	const char *name;

commit 48476df99894492a0f7239f2f3c9a2dde4ff38e2
Merge: 37cae6ad4c48 24dea0c9fecc
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Mar 2 16:33:54 2013 -0800

    Merge tag 'for-linus-20130301' of git://git.infradead.org/linux-mtd
    
    Pull MTD update from David Woodhouse:
     "Fairly unexciting MTD merge for 3.9:
    
       - misc clean-ups in the MTD command-line partitioning parser
         (cmdlinepart)
       - add flash locking support for STmicro chips serial flash chips, as
         well as for CFI command set 2 chips.
       - new driver for the ELM error correction HW module found in various
         TI chips, enable the OMAP NAND driver to use the ELM HW error
         correction
       - added number of new serial flash IDs
       - various fixes and improvements in the gpmi NAND driver
       - bcm47xx NAND driver improvements
       - make the mtdpart module actually removable"
    
    * tag 'for-linus-20130301' of git://git.infradead.org/linux-mtd: (45 commits)
      mtd: map: BUG() in non handled cases
      mtd: bcm47xxnflash: use pr_fmt for module prefix in messages
      mtd: davinci_nand: Use managed resources
      mtd: mtd_torturetest can cause stack overflows
      mtd: physmap_of: Convert device allocation to managed devm_kzalloc()
      mtd: at91: atmel_nand: for PMECC, add code to check the ONFI parameter ECC requirement.
      mtd: atmel_nand: make pmecc-cap, pmecc-sector-size in dts is optional.
      mtd: atmel_nand: avoid to report an error when lookup table offset is 0.
      mtd: bcm47xxsflash: adjust names of bus-specific functions
      mtd: bcm47xxpart: improve probing of nvram partition
      mtd: bcm47xxpart: add support for other erase sizes
      mtd: bcm47xxnflash: register this as normal driver
      mtd: bcm47xxnflash: fix message
      mtd: bcm47xxsflash: register this as normal driver
      mtd: bcm47xxsflash: write number of written bytes
      mtd: gpmi: add sanity check for the ECC
      mtd: gpmi: set the Golois Field bit for mx6q's BCH
      mtd: devices: elm: Removes <xx> literals in elm DT node
      mtd: gpmi: fix a dereferencing freed memory error
      mtd: fix the wrong timeo for panic_nand_wait()
      ...

commit 459a86d83dce6641f66311d37fbfe1419c477a5a
Author: Akinobu Mita <akinobu.mita@gmail.com>
Date:   Wed Feb 27 17:05:31 2013 -0800

    mtd: mtd_nandecctest: use prandom_bytes instead of get_random_bytes()
    
    Using prandom_bytes() is enough.  Because this data is only used
    for testing, not used for cryptographic use.
    
    Signed-off-by: Akinobu Mita <akinobu.mita@gmail.com>
    Cc: Artem Bityutskiy <dedekind1@gmail.com>
    Cc: David Woodhouse <dwmw2@infradead.org>
    Cc: "Theodore Ts'o" <tytso@mit.edu>
    Cc: Adrian Hunter <adrian.hunter@intel.com>
    Cc: David Laight <david.laight@aculab.com>
    Cc: Eilon Greenstein <eilong@broadcom.com>
    Cc: Michel Lespinasse <walken@google.com>
    Cc: Robert Love <robert.w.love@intel.com>
    Cc: Valdis Kletnieks <valdis.kletnieks@vt.edu>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/mtd/tests/mtd_nandecctest.c b/drivers/mtd/tests/mtd_nandecctest.c
index 1eee264509a8..db2f22e7966a 100644
--- a/drivers/mtd/tests/mtd_nandecctest.c
+++ b/drivers/mtd/tests/mtd_nandecctest.c
@@ -256,7 +256,7 @@ static int nand_ecc_test_run(const size_t size)
 		goto error;
 	}
 
-	get_random_bytes(correct_data, size);
+	prandom_bytes(correct_data, size);
 	__nand_calculate_ecc(correct_data, size, correct_ecc);
 
 	for (i = 0; i < ARRAY_SIZE(nand_ecc_test); i++) {

commit aca662a3b1c9b178536267da9fb2f0faa798cb7f
Author: Akinobu Mita <akinobu.mita@gmail.com>
Date:   Thu Jan 3 21:19:13 2013 +0900

    mtd: rename random32() to prandom_u32()
    
    Use more preferable function name which implies using a pseudo-random
    number generator.
    
    Signed-off-by: Akinobu Mita <akinobu.mita@gmail.com>
    Signed-off-by: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>

diff --git a/drivers/mtd/tests/mtd_nandecctest.c b/drivers/mtd/tests/mtd_nandecctest.c
index 1eee264509a8..5015d10591d9 100644
--- a/drivers/mtd/tests/mtd_nandecctest.c
+++ b/drivers/mtd/tests/mtd_nandecctest.c
@@ -44,7 +44,7 @@ struct nand_ecc_test {
 static void single_bit_error_data(void *error_data, void *correct_data,
 				size_t size)
 {
-	unsigned int offset = random32() % (size * BITS_PER_BYTE);
+	unsigned int offset = prandom_u32() % (size * BITS_PER_BYTE);
 
 	memcpy(error_data, correct_data, size);
 	__change_bit_le(offset, error_data);
@@ -55,9 +55,9 @@ static void double_bit_error_data(void *error_data, void *correct_data,
 {
 	unsigned int offset[2];
 
-	offset[0] = random32() % (size * BITS_PER_BYTE);
+	offset[0] = prandom_u32() % (size * BITS_PER_BYTE);
 	do {
-		offset[1] = random32() % (size * BITS_PER_BYTE);
+		offset[1] = prandom_u32() % (size * BITS_PER_BYTE);
 	} while (offset[0] == offset[1]);
 
 	memcpy(error_data, correct_data, size);
@@ -68,7 +68,7 @@ static void double_bit_error_data(void *error_data, void *correct_data,
 
 static unsigned int random_ecc_bit(size_t size)
 {
-	unsigned int offset = random32() % (3 * BITS_PER_BYTE);
+	unsigned int offset = prandom_u32() % (3 * BITS_PER_BYTE);
 
 	if (size == 256) {
 		/*
@@ -76,7 +76,7 @@ static unsigned int random_ecc_bit(size_t size)
 		 * and 17th bit) in ECC code for 256 byte data block
 		 */
 		while (offset == 16 || offset == 17)
-			offset = random32() % (3 * BITS_PER_BYTE);
+			offset = prandom_u32() % (3 * BITS_PER_BYTE);
 	}
 
 	return offset;

commit b6489d9706ca6cb42892571ac82b71ad92675036
Author: Vikram Narayanan <vikram186@gmail.com>
Date:   Wed Oct 10 23:07:19 2012 +0530

    mtd: tests: mtd_nandecctest: Use pr_fmt macro
    
    Use KBUILD_MODNAME instead of hardcoding the filename
    
    Signed-off-by: Vikram Narayanan <vikram186@gmail.com>
    Signed-off-by: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>

diff --git a/drivers/mtd/tests/mtd_nandecctest.c b/drivers/mtd/tests/mtd_nandecctest.c
index b437fa425077..1eee264509a8 100644
--- a/drivers/mtd/tests/mtd_nandecctest.c
+++ b/drivers/mtd/tests/mtd_nandecctest.c
@@ -1,3 +1,5 @@
+#define pr_fmt(fmt)	KBUILD_MODNAME ": " fmt
+
 #include <linux/kernel.h>
 #include <linux/module.h>
 #include <linux/list.h>
@@ -264,13 +266,13 @@ static int nand_ecc_test_run(const size_t size)
 						correct_data, size);
 
 		if (err) {
-			pr_err("mtd_nandecctest: not ok - %s-%zd\n",
+			pr_err("not ok - %s-%zd\n",
 				nand_ecc_test[i].name, size);
 			dump_data_ecc(error_data, error_ecc,
 				correct_data, correct_ecc, size);
 			break;
 		}
-		pr_info("mtd_nandecctest: ok - %s-%zd\n",
+		pr_info("ok - %s-%zd\n",
 			nand_ecc_test[i].name, size);
 	}
 error:

commit 6ed089c0a1bc6f371dbcf97fb4e8218deaa0ae17
Author: Akinobu Mita <akinobu.mita@gmail.com>
Date:   Sat Sep 8 01:48:10 2012 +0900

    mtd: mtd_nandecctest: add double bit error detection tests
    
    This adds the double bit error detection test cases listed below:
    
    * Prepare data block with double bit error and ECC data without
    corruption, and verify that the uncorrectable error is detected by
    __nand_correct_data().
    
    * Prepare data block with single bit error and ECC data with single bit
    error, and verify that the uncorrectable error is detected.
    
    * Prepare data block without corruption and ECC data with double bit
    error, and verify that the uncorrectable error is detected.
    
    Signed-off-by: Akinobu Mita <akinobu.mita@gmail.com>
    Signed-off-by: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/drivers/mtd/tests/mtd_nandecctest.c b/drivers/mtd/tests/mtd_nandecctest.c
index caaeb64acdea..b437fa425077 100644
--- a/drivers/mtd/tests/mtd_nandecctest.c
+++ b/drivers/mtd/tests/mtd_nandecctest.c
@@ -48,6 +48,22 @@ static void single_bit_error_data(void *error_data, void *correct_data,
 	__change_bit_le(offset, error_data);
 }
 
+static void double_bit_error_data(void *error_data, void *correct_data,
+				size_t size)
+{
+	unsigned int offset[2];
+
+	offset[0] = random32() % (size * BITS_PER_BYTE);
+	do {
+		offset[1] = random32() % (size * BITS_PER_BYTE);
+	} while (offset[0] == offset[1]);
+
+	memcpy(error_data, correct_data, size);
+
+	__change_bit_le(offset[0], error_data);
+	__change_bit_le(offset[1], error_data);
+}
+
 static unsigned int random_ecc_bit(size_t size)
 {
 	unsigned int offset = random32() % (3 * BITS_PER_BYTE);
@@ -73,6 +89,21 @@ static void single_bit_error_ecc(void *error_ecc, void *correct_ecc,
 	__change_bit_le(offset, error_ecc);
 }
 
+static void double_bit_error_ecc(void *error_ecc, void *correct_ecc,
+				size_t size)
+{
+	unsigned int offset[2];
+
+	offset[0] = random_ecc_bit(size);
+	do {
+		offset[1] = random_ecc_bit(size);
+	} while (offset[0] == offset[1]);
+
+	memcpy(error_ecc, correct_ecc, 3);
+	__change_bit_le(offset[0], error_ecc);
+	__change_bit_le(offset[1], error_ecc);
+}
+
 static void no_bit_error(void *error_data, void *error_ecc,
 		void *correct_data, void *correct_ecc, const size_t size)
 {
@@ -122,6 +153,39 @@ static int single_bit_error_correct(void *error_data, void *error_ecc,
 	return -EINVAL;
 }
 
+static void double_bit_error_in_data(void *error_data, void *error_ecc,
+		void *correct_data, void *correct_ecc, const size_t size)
+{
+	double_bit_error_data(error_data, correct_data, size);
+	memcpy(error_ecc, correct_ecc, 3);
+}
+
+static void single_bit_error_in_data_and_ecc(void *error_data, void *error_ecc,
+		void *correct_data, void *correct_ecc, const size_t size)
+{
+	single_bit_error_data(error_data, correct_data, size);
+	single_bit_error_ecc(error_ecc, correct_ecc, size);
+}
+
+static void double_bit_error_in_ecc(void *error_data, void *error_ecc,
+		void *correct_data, void *correct_ecc, const size_t size)
+{
+	memcpy(error_data, correct_data, size);
+	double_bit_error_ecc(error_ecc, correct_ecc, size);
+}
+
+static int double_bit_error_detect(void *error_data, void *error_ecc,
+				void *correct_data, const size_t size)
+{
+	unsigned char calc_ecc[3];
+	int ret;
+
+	__nand_calculate_ecc(error_data, size, calc_ecc);
+	ret = __nand_correct_data(error_data, error_ecc, calc_ecc, size);
+
+	return (ret == -1) ? 0 : -EINVAL;
+}
+
 static const struct nand_ecc_test nand_ecc_test[] = {
 	{
 		.name = "no-bit-error",
@@ -138,6 +202,21 @@ static const struct nand_ecc_test nand_ecc_test[] = {
 		.prepare = single_bit_error_in_ecc,
 		.verify = single_bit_error_correct,
 	},
+	{
+		.name = "double-bit-error-in-data-detect",
+		.prepare = double_bit_error_in_data,
+		.verify = double_bit_error_detect,
+	},
+	{
+		.name = "single-bit-error-in-data-and-ecc-detect",
+		.prepare = single_bit_error_in_data_and_ecc,
+		.verify = double_bit_error_detect,
+	},
+	{
+		.name = "double-bit-error-in-ecc-detect",
+		.prepare = double_bit_error_in_ecc,
+		.verify = double_bit_error_detect,
+	},
 };
 
 static void dump_data_ecc(void *error_data, void *error_ecc, void *correct_data,

commit 200ab8454c42c607efd281b2c2398624eccdd2cc
Author: Akinobu Mita <akinobu.mita@gmail.com>
Date:   Sat Sep 8 01:48:09 2012 +0900

    mtd: mtd_nandecctest: add single bit error correction test
    
    This adds the single bit error correction test case listed below:
    
    Prepare data block without corruption and ECC data with single bit error,
    and verify that the data block is preserved by __nand_correct_data().
    
    Signed-off-by: Akinobu Mita <akinobu.mita@gmail.com>
    Signed-off-by: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/drivers/mtd/tests/mtd_nandecctest.c b/drivers/mtd/tests/mtd_nandecctest.c
index ff97b1070235..caaeb64acdea 100644
--- a/drivers/mtd/tests/mtd_nandecctest.c
+++ b/drivers/mtd/tests/mtd_nandecctest.c
@@ -48,6 +48,31 @@ static void single_bit_error_data(void *error_data, void *correct_data,
 	__change_bit_le(offset, error_data);
 }
 
+static unsigned int random_ecc_bit(size_t size)
+{
+	unsigned int offset = random32() % (3 * BITS_PER_BYTE);
+
+	if (size == 256) {
+		/*
+		 * Don't inject a bit error into the insignificant bits (16th
+		 * and 17th bit) in ECC code for 256 byte data block
+		 */
+		while (offset == 16 || offset == 17)
+			offset = random32() % (3 * BITS_PER_BYTE);
+	}
+
+	return offset;
+}
+
+static void single_bit_error_ecc(void *error_ecc, void *correct_ecc,
+				size_t size)
+{
+	unsigned int offset = random_ecc_bit(size);
+
+	memcpy(error_ecc, correct_ecc, 3);
+	__change_bit_le(offset, error_ecc);
+}
+
 static void no_bit_error(void *error_data, void *error_ecc,
 		void *correct_data, void *correct_ecc, const size_t size)
 {
@@ -76,6 +101,13 @@ static void single_bit_error_in_data(void *error_data, void *error_ecc,
 	memcpy(error_ecc, correct_ecc, 3);
 }
 
+static void single_bit_error_in_ecc(void *error_data, void *error_ecc,
+		void *correct_data, void *correct_ecc, const size_t size)
+{
+	memcpy(error_data, correct_data, size);
+	single_bit_error_ecc(error_ecc, correct_ecc, size);
+}
+
 static int single_bit_error_correct(void *error_data, void *error_ecc,
 				void *correct_data, const size_t size)
 {
@@ -101,6 +133,11 @@ static const struct nand_ecc_test nand_ecc_test[] = {
 		.prepare = single_bit_error_in_data,
 		.verify = single_bit_error_correct,
 	},
+	{
+		.name = "single-bit-error-in-ecc-correct",
+		.prepare = single_bit_error_in_ecc,
+		.verify = single_bit_error_correct,
+	},
 };
 
 static void dump_data_ecc(void *error_data, void *error_ecc, void *correct_data,

commit ccaa67956cfef80776d72d134467235f0055c863
Author: Akinobu Mita <akinobu.mita@gmail.com>
Date:   Sat Sep 8 01:48:08 2012 +0900

    mtd: mtd_nandecctest: add no corruption test
    
    This adds no corruptin test case listed below:
    
    Prepare data block and ECC data with no corruption, and verify that
    the data block is preserved by __nand_correct_data()
    
    Signed-off-by: Akinobu Mita <akinobu.mita@gmail.com>
    Signed-off-by: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/drivers/mtd/tests/mtd_nandecctest.c b/drivers/mtd/tests/mtd_nandecctest.c
index 204f796ed3e7..ff97b1070235 100644
--- a/drivers/mtd/tests/mtd_nandecctest.c
+++ b/drivers/mtd/tests/mtd_nandecctest.c
@@ -48,6 +48,27 @@ static void single_bit_error_data(void *error_data, void *correct_data,
 	__change_bit_le(offset, error_data);
 }
 
+static void no_bit_error(void *error_data, void *error_ecc,
+		void *correct_data, void *correct_ecc, const size_t size)
+{
+	memcpy(error_data, correct_data, size);
+	memcpy(error_ecc, correct_ecc, 3);
+}
+
+static int no_bit_error_verify(void *error_data, void *error_ecc,
+				void *correct_data, const size_t size)
+{
+	unsigned char calc_ecc[3];
+	int ret;
+
+	__nand_calculate_ecc(error_data, size, calc_ecc);
+	ret = __nand_correct_data(error_data, error_ecc, calc_ecc, size);
+	if (ret == 0 && !memcmp(correct_data, error_data, size))
+		return 0;
+
+	return -EINVAL;
+}
+
 static void single_bit_error_in_data(void *error_data, void *error_ecc,
 		void *correct_data, void *correct_ecc, const size_t size)
 {
@@ -70,6 +91,11 @@ static int single_bit_error_correct(void *error_data, void *error_ecc,
 }
 
 static const struct nand_ecc_test nand_ecc_test[] = {
+	{
+		.name = "no-bit-error",
+		.prepare = no_bit_error,
+		.verify = no_bit_error_verify,
+	},
 	{
 		.name = "single-bit-error-in-data-correct",
 		.prepare = single_bit_error_in_data,

commit 6060fb42a0bf93015d05c1a857b94894936f40ee
Author: Akinobu Mita <akinobu.mita@gmail.com>
Date:   Sat Sep 8 01:48:07 2012 +0900

    mtd: mtd_nandecctest: rewrite the test routine
    
    This rewrites the entire test routine in order to make it easy to add more
    tests by later changes and minimize duplication of each tests as much as
    possible.
    
    Now that each test is described by the members of struct nand_ecc_test:
    - name: descriptive testname
    - prepare: function to prepare data block and ecc with artifical corruption
    - verify: function to verify the result of correcting data block
    
    Signed-off-by: Akinobu Mita <akinobu.mita@gmail.com>
    Signed-off-by: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/drivers/mtd/tests/mtd_nandecctest.c b/drivers/mtd/tests/mtd_nandecctest.c
index d90daf879c46..204f796ed3e7 100644
--- a/drivers/mtd/tests/mtd_nandecctest.c
+++ b/drivers/mtd/tests/mtd_nandecctest.c
@@ -7,8 +7,24 @@
 #include <linux/slab.h>
 #include <linux/mtd/nand_ecc.h>
 
+/*
+ * Test the implementation for software ECC
+ *
+ * No actual MTD device is needed, So we don't need to warry about losing
+ * important data by human error.
+ *
+ * This covers possible patterns of corruption which can be reliably corrected
+ * or detected.
+ */
+
 #if defined(CONFIG_MTD_NAND) || defined(CONFIG_MTD_NAND_MODULE)
 
+struct nand_ecc_test {
+	const char *name;
+	void (*prepare)(void *, void *, void *, void *, const size_t);
+	int (*verify)(void *, void *, void *, const size_t);
+};
+
 /*
  * The reason for this __change_bit_le() instead of __change_bit() is to inject
  * bit error properly within the region which is not a multiple of
@@ -23,13 +39,44 @@
 #error "Unknown byte order"
 #endif
 
-static void inject_single_bit_error(void *data, size_t size)
+static void single_bit_error_data(void *error_data, void *correct_data,
+				size_t size)
 {
 	unsigned int offset = random32() % (size * BITS_PER_BYTE);
 
-	__change_bit_le(offset, data);
+	memcpy(error_data, correct_data, size);
+	__change_bit_le(offset, error_data);
+}
+
+static void single_bit_error_in_data(void *error_data, void *error_ecc,
+		void *correct_data, void *correct_ecc, const size_t size)
+{
+	single_bit_error_data(error_data, correct_data, size);
+	memcpy(error_ecc, correct_ecc, 3);
+}
+
+static int single_bit_error_correct(void *error_data, void *error_ecc,
+				void *correct_data, const size_t size)
+{
+	unsigned char calc_ecc[3];
+	int ret;
+
+	__nand_calculate_ecc(error_data, size, calc_ecc);
+	ret = __nand_correct_data(error_data, error_ecc, calc_ecc, size);
+	if (ret == 1 && !memcmp(correct_data, error_data, size))
+		return 0;
+
+	return -EINVAL;
 }
 
+static const struct nand_ecc_test nand_ecc_test[] = {
+	{
+		.name = "single-bit-error-in-data-correct",
+		.prepare = single_bit_error_in_data,
+		.verify = single_bit_error_correct,
+	},
+};
+
 static void dump_data_ecc(void *error_data, void *error_ecc, void *correct_data,
 			void *correct_ecc, const size_t size)
 {
@@ -46,14 +93,14 @@ static void dump_data_ecc(void *error_data, void *error_ecc, void *correct_data,
 			DUMP_PREFIX_NONE, 16, 1, correct_ecc, 3, false);
 }
 
-static int nand_ecc_test(const size_t size)
+static int nand_ecc_test_run(const size_t size)
 {
+	int i;
 	int err = 0;
 	void *error_data;
 	void *error_ecc;
 	void *correct_data;
 	void *correct_ecc;
-	char testname[30];
 
 	error_data = kmalloc(size, GFP_KERNEL);
 	error_ecc = kmalloc(3, GFP_KERNEL);
@@ -65,25 +112,25 @@ static int nand_ecc_test(const size_t size)
 		goto error;
 	}
 
-	sprintf(testname, "nand-ecc-%zu", size);
-
 	get_random_bytes(correct_data, size);
-
-	memcpy(error_data, correct_data, size);
-	inject_single_bit_error(error_data, size);
-
 	__nand_calculate_ecc(correct_data, size, correct_ecc);
-	__nand_calculate_ecc(error_data, size, error_ecc);
-	__nand_correct_data(error_data, correct_ecc, error_ecc, size);
-
-	if (memcmp(correct_data, error_data, size)) {
-		pr_err("mtd_nandecctest: not ok - %s\n", testname);
-		dump_data_ecc(error_data, error_ecc, correct_data, correct_ecc,
-				size);
-		err = -EINVAL;
-		goto error;
+
+	for (i = 0; i < ARRAY_SIZE(nand_ecc_test); i++) {
+		nand_ecc_test[i].prepare(error_data, error_ecc,
+				correct_data, correct_ecc, size);
+		err = nand_ecc_test[i].verify(error_data, error_ecc,
+						correct_data, size);
+
+		if (err) {
+			pr_err("mtd_nandecctest: not ok - %s-%zd\n",
+				nand_ecc_test[i].name, size);
+			dump_data_ecc(error_data, error_ecc,
+				correct_data, correct_ecc, size);
+			break;
+		}
+		pr_info("mtd_nandecctest: ok - %s-%zd\n",
+			nand_ecc_test[i].name, size);
 	}
-	pr_info("mtd_nandecctest: ok - %s\n", testname);
 error:
 	kfree(error_data);
 	kfree(error_ecc);
@@ -95,7 +142,7 @@ static int nand_ecc_test(const size_t size)
 
 #else
 
-static int nand_ecc_test(const size_t size)
+static int nand_ecc_test_run(const size_t size)
 {
 	return 0;
 }
@@ -106,11 +153,11 @@ static int __init ecc_test_init(void)
 {
 	int err;
 
-	err = nand_ecc_test(256);
+	err = nand_ecc_test_run(256);
 	if (err)
 		return err;
 
-	return nand_ecc_test(512);
+	return nand_ecc_test_run(512);
 }
 
 static void __exit ecc_test_exit(void)

commit c092b43906098a6879d0fa9f74e5141516b9b856
Author: Akinobu Mita <akinobu.mita@gmail.com>
Date:   Sat Sep 8 01:48:06 2012 +0900

    mtd: mtd_nandecctest: support injecting bit error for ecc code
    
    Currently inject_single_bit_error() is used to inject single bit error
    into randomly selected bit position of the 256 or 512 bytes data block.
    
    Later change will add tests which inject bit errors into the ecc code.
    Unfortunately, inject_single_bit_error() doesn't work for the ecc code
    which is not a multiple of sizeof(unsigned long).
    
    Because bit fliping at random position is done by __change_bit().
    For example, flipping bit position 0 by __change_bit(0, addr) modifies
    3rd byte (32bit) or 7th byte (64bit) on big-endian systems.
    
    Using little-endian version of bitops can fix this issue.  But
    little-endian version of __change_bit is not yet available.
    So this defines __change_bit_le() locally in a similar fashion to
    asm-generic/bitops/le.h and use it.
    
    Signed-off-by: Akinobu Mita <akinobu.mita@gmail.com>
    Signed-off-by: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/drivers/mtd/tests/mtd_nandecctest.c b/drivers/mtd/tests/mtd_nandecctest.c
index d3e8873ad38a..d90daf879c46 100644
--- a/drivers/mtd/tests/mtd_nandecctest.c
+++ b/drivers/mtd/tests/mtd_nandecctest.c
@@ -9,11 +9,25 @@
 
 #if defined(CONFIG_MTD_NAND) || defined(CONFIG_MTD_NAND_MODULE)
 
+/*
+ * The reason for this __change_bit_le() instead of __change_bit() is to inject
+ * bit error properly within the region which is not a multiple of
+ * sizeof(unsigned long) on big-endian systems
+ */
+#ifdef __LITTLE_ENDIAN
+#define __change_bit_le(nr, addr) __change_bit(nr, addr)
+#elif defined(__BIG_ENDIAN)
+#define __change_bit_le(nr, addr) \
+		__change_bit((nr) ^ ((BITS_PER_LONG - 1) & ~0x7), addr)
+#else
+#error "Unknown byte order"
+#endif
+
 static void inject_single_bit_error(void *data, size_t size)
 {
-	unsigned long offset = random32() % (size * BITS_PER_BYTE);
+	unsigned int offset = random32() % (size * BITS_PER_BYTE);
 
-	__change_bit(offset, data);
+	__change_bit_le(offset, data);
 }
 
 static void dump_data_ecc(void *error_data, void *error_ecc, void *correct_data,

commit 1749c00ffc909db4ebf1b2f17fd52cdb6e7b149c
Author: Akinobu Mita <akinobu.mita@gmail.com>
Date:   Mon Sep 3 22:00:01 2012 +0900

    mtd: mtd_nandecctest: ensure alignment requirement for bitops
    
    Currently the data blocks which is used to test single bit error
    correction is allocated statically and injecting single bit error is
    implemented by using __change_bit() which must operate on the memory
    aligned to the size of an "unsigned long".  But there is no such
    guarantee for statically allocated array.
    
    This fix the issue by allocating the data block dynamically by
    kmalloc().  It also allocate the ecc code dynamically instead of
    allocating statically on stack.
    
    The reason to allocate the ecc code dynamically is that later change
    will add tests which inject bit errors into the ecc code by bitops.
    
    Signed-off-by: Akinobu Mita <akinobu.mita@gmail.com>
    Signed-off-by: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/drivers/mtd/tests/mtd_nandecctest.c b/drivers/mtd/tests/mtd_nandecctest.c
index 2b2d1a90417b..d3e8873ad38a 100644
--- a/drivers/mtd/tests/mtd_nandecctest.c
+++ b/drivers/mtd/tests/mtd_nandecctest.c
@@ -4,6 +4,7 @@
 #include <linux/random.h>
 #include <linux/string.h>
 #include <linux/bitops.h>
+#include <linux/slab.h>
 #include <linux/mtd/nand_ecc.h>
 
 #if defined(CONFIG_MTD_NAND) || defined(CONFIG_MTD_NAND_MODULE)
@@ -31,16 +32,24 @@ static void dump_data_ecc(void *error_data, void *error_ecc, void *correct_data,
 			DUMP_PREFIX_NONE, 16, 1, correct_ecc, 3, false);
 }
 
-static unsigned char correct_data[512];
-static unsigned char error_data[512];
-
 static int nand_ecc_test(const size_t size)
 {
-	unsigned char correct_ecc[3];
-	unsigned char error_ecc[3];
+	int err = 0;
+	void *error_data;
+	void *error_ecc;
+	void *correct_data;
+	void *correct_ecc;
 	char testname[30];
 
-	BUG_ON(sizeof(correct_data) < size);
+	error_data = kmalloc(size, GFP_KERNEL);
+	error_ecc = kmalloc(3, GFP_KERNEL);
+	correct_data = kmalloc(size, GFP_KERNEL);
+	correct_ecc = kmalloc(3, GFP_KERNEL);
+
+	if (!error_data || !error_ecc || !correct_data || !correct_ecc) {
+		err = -ENOMEM;
+		goto error;
+	}
 
 	sprintf(testname, "nand-ecc-%zu", size);
 
@@ -53,15 +62,21 @@ static int nand_ecc_test(const size_t size)
 	__nand_calculate_ecc(error_data, size, error_ecc);
 	__nand_correct_data(error_data, correct_ecc, error_ecc, size);
 
-	if (!memcmp(correct_data, error_data, size)) {
-		pr_info("mtd_nandecctest: ok - %s\n", testname);
-		return 0;
+	if (memcmp(correct_data, error_data, size)) {
+		pr_err("mtd_nandecctest: not ok - %s\n", testname);
+		dump_data_ecc(error_data, error_ecc, correct_data, correct_ecc,
+				size);
+		err = -EINVAL;
+		goto error;
 	}
-
-	pr_err("mtd_nandecctest: not ok - %s\n", testname);
-	dump_data_ecc(error_data, error_ecc, correct_data, correct_ecc, size);
-
-	return -EINVAL;
+	pr_info("mtd_nandecctest: ok - %s\n", testname);
+error:
+	kfree(error_data);
+	kfree(error_ecc);
+	kfree(correct_data);
+	kfree(correct_ecc);
+
+	return err;
 }
 
 #else

commit c5b8384abc11fd566a3633b7bd7d476ff04c31af
Author: Akinobu Mita <akinobu.mita@gmail.com>
Date:   Mon Sep 3 22:00:00 2012 +0900

    mtd: mtd_nandecctest: improve message output
    
    This includes the message related changes:
    
    - Use pr_* instead of printk
    - Print hexdump of ECC code if test fails
    - Change log level for hexdump of data from KERN_DEBUG to KERN_INFO
    - Factor out the hexdump code into a separate function
    
    Signed-off-by: Akinobu Mita <akinobu.mita@gmail.com>
    Signed-off-by: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/drivers/mtd/tests/mtd_nandecctest.c b/drivers/mtd/tests/mtd_nandecctest.c
index 128547c5bd55..2b2d1a90417b 100644
--- a/drivers/mtd/tests/mtd_nandecctest.c
+++ b/drivers/mtd/tests/mtd_nandecctest.c
@@ -15,41 +15,51 @@ static void inject_single_bit_error(void *data, size_t size)
 	__change_bit(offset, data);
 }
 
-static unsigned char data[512];
+static void dump_data_ecc(void *error_data, void *error_ecc, void *correct_data,
+			void *correct_ecc, const size_t size)
+{
+	pr_info("hexdump of error data:\n");
+	print_hex_dump(KERN_INFO, "", DUMP_PREFIX_OFFSET, 16, 4,
+			error_data, size, false);
+	print_hex_dump(KERN_INFO, "hexdump of error ecc: ",
+			DUMP_PREFIX_NONE, 16, 1, error_ecc, 3, false);
+
+	pr_info("hexdump of correct data:\n");
+	print_hex_dump(KERN_INFO, "", DUMP_PREFIX_OFFSET, 16, 4,
+			correct_data, size, false);
+	print_hex_dump(KERN_INFO, "hexdump of correct ecc: ",
+			DUMP_PREFIX_NONE, 16, 1, correct_ecc, 3, false);
+}
+
+static unsigned char correct_data[512];
 static unsigned char error_data[512];
 
 static int nand_ecc_test(const size_t size)
 {
-	unsigned char code[3];
-	unsigned char error_code[3];
+	unsigned char correct_ecc[3];
+	unsigned char error_ecc[3];
 	char testname[30];
 
-	BUG_ON(sizeof(data) < size);
+	BUG_ON(sizeof(correct_data) < size);
 
 	sprintf(testname, "nand-ecc-%zu", size);
 
-	get_random_bytes(data, size);
+	get_random_bytes(correct_data, size);
 
-	memcpy(error_data, data, size);
+	memcpy(error_data, correct_data, size);
 	inject_single_bit_error(error_data, size);
 
-	__nand_calculate_ecc(data, size, code);
-	__nand_calculate_ecc(error_data, size, error_code);
-	__nand_correct_data(error_data, code, error_code, size);
+	__nand_calculate_ecc(correct_data, size, correct_ecc);
+	__nand_calculate_ecc(error_data, size, error_ecc);
+	__nand_correct_data(error_data, correct_ecc, error_ecc, size);
 
-	if (!memcmp(data, error_data, size)) {
-		printk(KERN_INFO "mtd_nandecctest: ok - %s\n", testname);
+	if (!memcmp(correct_data, error_data, size)) {
+		pr_info("mtd_nandecctest: ok - %s\n", testname);
 		return 0;
 	}
 
-	printk(KERN_ERR "mtd_nandecctest: not ok - %s\n", testname);
-
-	printk(KERN_DEBUG "hexdump of data:\n");
-	print_hex_dump(KERN_DEBUG, "", DUMP_PREFIX_OFFSET, 16, 4,
-			data, size, false);
-	printk(KERN_DEBUG "hexdump of error data:\n");
-	print_hex_dump(KERN_DEBUG, "", DUMP_PREFIX_OFFSET, 16, 4,
-			error_data, size, false);
+	pr_err("mtd_nandecctest: not ok - %s\n", testname);
+	dump_data_ecc(error_data, error_ecc, correct_data, correct_ecc, size);
 
 	return -EINVAL;
 }

commit bb82477ebede3d0c37a502a899b68eb45fefca4f
Author: Akinobu Mita <akinobu.mita@gmail.com>
Date:   Mon Sep 3 21:59:59 2012 +0900

    mtd: mtd_nandecctest: make module_init() return appropriate errno
    
    Return -EINVAL instead of -1 (-EPERM) when test fails.
    
    Signed-off-by: Akinobu Mita <akinobu.mita@gmail.com>
    Signed-off-by: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/drivers/mtd/tests/mtd_nandecctest.c b/drivers/mtd/tests/mtd_nandecctest.c
index 1051b4814daa..128547c5bd55 100644
--- a/drivers/mtd/tests/mtd_nandecctest.c
+++ b/drivers/mtd/tests/mtd_nandecctest.c
@@ -51,7 +51,7 @@ static int nand_ecc_test(const size_t size)
 	print_hex_dump(KERN_DEBUG, "", DUMP_PREFIX_OFFSET, 16, 4,
 			error_data, size, false);
 
-	return -1;
+	return -EINVAL;
 }
 
 #else

commit 1f6edadcccfa6a213fd2bbe6f193a78925f8312a
Author: Akinobu Mita <akinobu.mita@gmail.com>
Date:   Mon Sep 3 21:59:58 2012 +0900

    mtd: mtd_nandecctest: remove unnecessary include
    
    Including linux/jiffies.h was required for calling srandom32(jiffies)
    that has already been removed.
    
    Signed-off-by: Akinobu Mita <akinobu.mita@gmail.com>
    Signed-off-by: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/drivers/mtd/tests/mtd_nandecctest.c b/drivers/mtd/tests/mtd_nandecctest.c
index f71ed92b932c..1051b4814daa 100644
--- a/drivers/mtd/tests/mtd_nandecctest.c
+++ b/drivers/mtd/tests/mtd_nandecctest.c
@@ -4,7 +4,6 @@
 #include <linux/random.h>
 #include <linux/string.h>
 #include <linux/bitops.h>
-#include <linux/jiffies.h>
 #include <linux/mtd/nand_ecc.h>
 
 #if defined(CONFIG_MTD_NAND) || defined(CONFIG_MTD_NAND_MODULE)

commit f45c2990dc3de65d22e5f3b2f6b5df60a102e493
Author: Akinobu Mita <akinobu.mita@gmail.com>
Date:   Sun Aug 26 21:06:44 2012 +0900

    mtd: mtd_nandecctest: make module_init() return an error code if test fails
    
    Return an error code if test fails in order to detect a test case failure
    by invoking tests repeatedly like this:
    
    while sudo modprobe mtd_nandecctest; do
            sudo modprobe -r mtd_nandecctest
    done
    
    Signed-off-by: Akinobu Mita <akinobu.mita@gmail.com>
    Signed-off-by: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/drivers/mtd/tests/mtd_nandecctest.c b/drivers/mtd/tests/mtd_nandecctest.c
index 4d7b171e825f..f71ed92b932c 100644
--- a/drivers/mtd/tests/mtd_nandecctest.c
+++ b/drivers/mtd/tests/mtd_nandecctest.c
@@ -66,10 +66,13 @@ static int nand_ecc_test(const size_t size)
 
 static int __init ecc_test_init(void)
 {
-	nand_ecc_test(256);
-	nand_ecc_test(512);
+	int err;
 
-	return 0;
+	err = nand_ecc_test(256);
+	if (err)
+		return err;
+
+	return nand_ecc_test(512);
 }
 
 static void __exit ecc_test_exit(void)

commit 0ce0060f103db02edcaa000bbd31cdebcfaa115c
Author: Akinobu Mita <akinobu.mita@gmail.com>
Date:   Sun Aug 26 21:06:43 2012 +0900

    mtd: mtd_nandecctest: remove unnecessary srandom32() call
    
    It is unnecessary for this driver to call srandom32() in module_init.
    
    Signed-off-by: Akinobu Mita <akinobu.mita@gmail.com>
    Signed-off-by: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/drivers/mtd/tests/mtd_nandecctest.c b/drivers/mtd/tests/mtd_nandecctest.c
index 70d6d7d0d656..4d7b171e825f 100644
--- a/drivers/mtd/tests/mtd_nandecctest.c
+++ b/drivers/mtd/tests/mtd_nandecctest.c
@@ -66,8 +66,6 @@ static int nand_ecc_test(const size_t size)
 
 static int __init ecc_test_init(void)
 {
-	srandom32(jiffies);
-
 	nand_ecc_test(256);
 	nand_ecc_test(512);
 

commit 5a0e3ad6af8660be21ca98a971cd00f331318c05
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Mar 24 17:04:11 2010 +0900

    include cleanup: Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h
    
    percpu.h is included by sched.h and module.h and thus ends up being
    included when building most .c files.  percpu.h includes slab.h which
    in turn includes gfp.h making everything defined by the two files
    universally available and complicating inclusion dependencies.
    
    percpu.h -> slab.h dependency is about to be removed.  Prepare for
    this change by updating users of gfp and slab facilities include those
    headers directly instead of assuming availability.  As this conversion
    needs to touch large number of source files, the following script is
    used as the basis of conversion.
    
      http://userweb.kernel.org/~tj/misc/slabh-sweep.py
    
    The script does the followings.
    
    * Scan files for gfp and slab usages and update includes such that
      only the necessary includes are there.  ie. if only gfp is used,
      gfp.h, if slab is used, slab.h.
    
    * When the script inserts a new include, it looks at the include
      blocks and try to put the new include such that its order conforms
      to its surrounding.  It's put in the include block which contains
      core kernel includes, in the same order that the rest are ordered -
      alphabetical, Christmas tree, rev-Xmas-tree or at the end if there
      doesn't seem to be any matching order.
    
    * If the script can't find a place to put a new include (mostly
      because the file doesn't have fitting include block), it prints out
      an error message indicating which .h file needs to be added to the
      file.
    
    The conversion was done in the following steps.
    
    1. The initial automatic conversion of all .c files updated slightly
       over 4000 files, deleting around 700 includes and adding ~480 gfp.h
       and ~3000 slab.h inclusions.  The script emitted errors for ~400
       files.
    
    2. Each error was manually checked.  Some didn't need the inclusion,
       some needed manual addition while adding it to implementation .h or
       embedding .c file was more appropriate for others.  This step added
       inclusions to around 150 files.
    
    3. The script was run again and the output was compared to the edits
       from #2 to make sure no file was left behind.
    
    4. Several build tests were done and a couple of problems were fixed.
       e.g. lib/decompress_*.c used malloc/free() wrappers around slab
       APIs requiring slab.h to be added manually.
    
    5. The script was run on all .h files but without automatically
       editing them as sprinkling gfp.h and slab.h inclusions around .h
       files could easily lead to inclusion dependency hell.  Most gfp.h
       inclusion directives were ignored as stuff from gfp.h was usually
       wildly available and often used in preprocessor macros.  Each
       slab.h inclusion directive was examined and added manually as
       necessary.
    
    6. percpu.h was updated not to include slab.h.
    
    7. Build test were done on the following configurations and failures
       were fixed.  CONFIG_GCOV_KERNEL was turned off for all tests (as my
       distributed build env didn't work with gcov compiles) and a few
       more options had to be turned off depending on archs to make things
       build (like ipr on powerpc/64 which failed due to missing writeq).
    
       * x86 and x86_64 UP and SMP allmodconfig and a custom test config.
       * powerpc and powerpc64 SMP allmodconfig
       * sparc and sparc64 SMP allmodconfig
       * ia64 SMP allmodconfig
       * s390 SMP allmodconfig
       * alpha SMP allmodconfig
       * um on x86_64 SMP allmodconfig
    
    8. percpu.h modifications were reverted so that it could be applied as
       a separate patch and serve as bisection point.
    
    Given the fact that I had only a couple of failures from tests on step
    6, I'm fairly confident about the coverage of this conversion patch.
    If there is a breakage, it's likely to be something in one of the arch
    headers which should be easily discoverable easily on most builds of
    the specific arch.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Guess-its-ok-by: Christoph Lameter <cl@linux-foundation.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Lee Schermerhorn <Lee.Schermerhorn@hp.com>

diff --git a/drivers/mtd/tests/mtd_nandecctest.c b/drivers/mtd/tests/mtd_nandecctest.c
index c1f31051784c..70d6d7d0d656 100644
--- a/drivers/mtd/tests/mtd_nandecctest.c
+++ b/drivers/mtd/tests/mtd_nandecctest.c
@@ -1,7 +1,6 @@
 #include <linux/kernel.h>
 #include <linux/module.h>
 #include <linux/list.h>
-#include <linux/slab.h>
 #include <linux/random.h>
 #include <linux/string.h>
 #include <linux/bitops.h>

commit 7126bd8be4ee009c56c4ec037f07f2c0884413fc
Author: Akinobu Mita <akinobu.mita@gmail.com>
Date:   Thu Oct 22 16:53:33 2009 +0900

    mtd: add nand_ecc test module
    
    This module tests NAND ECC functions.
    
    The test is simple.
    
    1. Create a 256 or 512 bytes block of data filled with random bytes (data)
    2. Duplicate the data block and inject single bit error (error_data)
    3. Try to correct error_data
    4. Compare data and error_data
    
    Signed-off-by: Akinobu Mita <akinobu.mita@gmail.com>
    Acked-by: Vimal Singh <vimalsingh@ti.com>
    Signed-off-by: Artem Bityutskiy <Artem.Bityutskiy@nokia.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/drivers/mtd/tests/mtd_nandecctest.c b/drivers/mtd/tests/mtd_nandecctest.c
new file mode 100644
index 000000000000..c1f31051784c
--- /dev/null
+++ b/drivers/mtd/tests/mtd_nandecctest.c
@@ -0,0 +1,87 @@
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/list.h>
+#include <linux/slab.h>
+#include <linux/random.h>
+#include <linux/string.h>
+#include <linux/bitops.h>
+#include <linux/jiffies.h>
+#include <linux/mtd/nand_ecc.h>
+
+#if defined(CONFIG_MTD_NAND) || defined(CONFIG_MTD_NAND_MODULE)
+
+static void inject_single_bit_error(void *data, size_t size)
+{
+	unsigned long offset = random32() % (size * BITS_PER_BYTE);
+
+	__change_bit(offset, data);
+}
+
+static unsigned char data[512];
+static unsigned char error_data[512];
+
+static int nand_ecc_test(const size_t size)
+{
+	unsigned char code[3];
+	unsigned char error_code[3];
+	char testname[30];
+
+	BUG_ON(sizeof(data) < size);
+
+	sprintf(testname, "nand-ecc-%zu", size);
+
+	get_random_bytes(data, size);
+
+	memcpy(error_data, data, size);
+	inject_single_bit_error(error_data, size);
+
+	__nand_calculate_ecc(data, size, code);
+	__nand_calculate_ecc(error_data, size, error_code);
+	__nand_correct_data(error_data, code, error_code, size);
+
+	if (!memcmp(data, error_data, size)) {
+		printk(KERN_INFO "mtd_nandecctest: ok - %s\n", testname);
+		return 0;
+	}
+
+	printk(KERN_ERR "mtd_nandecctest: not ok - %s\n", testname);
+
+	printk(KERN_DEBUG "hexdump of data:\n");
+	print_hex_dump(KERN_DEBUG, "", DUMP_PREFIX_OFFSET, 16, 4,
+			data, size, false);
+	printk(KERN_DEBUG "hexdump of error data:\n");
+	print_hex_dump(KERN_DEBUG, "", DUMP_PREFIX_OFFSET, 16, 4,
+			error_data, size, false);
+
+	return -1;
+}
+
+#else
+
+static int nand_ecc_test(const size_t size)
+{
+	return 0;
+}
+
+#endif
+
+static int __init ecc_test_init(void)
+{
+	srandom32(jiffies);
+
+	nand_ecc_test(256);
+	nand_ecc_test(512);
+
+	return 0;
+}
+
+static void __exit ecc_test_exit(void)
+{
+}
+
+module_init(ecc_test_init);
+module_exit(ecc_test_exit);
+
+MODULE_DESCRIPTION("NAND ECC function test module");
+MODULE_AUTHOR("Akinobu Mita");
+MODULE_LICENSE("GPL");
