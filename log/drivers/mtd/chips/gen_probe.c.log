commit f454b43a564fab4aae77c0bbc32072201993c349
Author: Sergei Shtylyov <sergei.shtylyov@cogentembedded.com>
Date:   Wed Jul 3 23:26:27 2019 +0300

    mtd: chips: gen_probe: kill useless initializer in mtd_do_chip_probe()
    
    The 'mtd' local variable is initialized but this value is never used,
    thus kill that initializer.
    
    Signed-off-by: Sergei Shtylyov <sergei.shtylyov@cogentembedded.com>
    Signed-off-by: Vignesh Raghavendra <vigneshr@ti.com>

diff --git a/drivers/mtd/chips/gen_probe.c b/drivers/mtd/chips/gen_probe.c
index 839ed40625d6..e5bd3c2bc3b2 100644
--- a/drivers/mtd/chips/gen_probe.c
+++ b/drivers/mtd/chips/gen_probe.c
@@ -20,7 +20,7 @@ static int genprobe_new_chip(struct map_info *map, struct chip_probe *cp,
 
 struct mtd_info *mtd_do_chip_probe(struct map_info *map, struct chip_probe *cp)
 {
-	struct mtd_info *mtd = NULL;
+	struct mtd_info *mtd;
 	struct cfi_private *cfi;
 
 	/* First probe the map to see if we have CFI stuff there. */

commit 9cb76a6aa1a9524866ec1558f08d044506b707fa
Author: Gustavo A. R. Silva <gustavo@embeddedor.com>
Date:   Tue Jan 8 09:36:01 2019 -0600

    mtd: gen_probe: Use struct_size() in kmalloc()
    
    One of the more common cases of allocation size calculations is finding
    the size of a structure that has a zero-sized array at the end, along
    with memory for some number of elements for that array. For example:
    
    struct foo {
        int stuff;
        void *entry[];
    };
    
    instance = kmalloc(sizeof(struct foo) + sizeof(void *) * count, GFP_KERNEL);
    
    Instead of leaving these open-coded and prone to type mistakes, we can
    now use the new struct_size() helper:
    
    instance = kmalloc(struct_size(instance, entry, count), GFP_KERNEL);
    
    This code was detected with the help of Coccinelle.
    
    Signed-off-by: Gustavo A. R. Silva <gustavo@embeddedor.com>
    Signed-off-by: Boris Brezillon <bbrezillon@kernel.org>

diff --git a/drivers/mtd/chips/gen_probe.c b/drivers/mtd/chips/gen_probe.c
index 837b04ab96a9..839ed40625d6 100644
--- a/drivers/mtd/chips/gen_probe.c
+++ b/drivers/mtd/chips/gen_probe.c
@@ -135,7 +135,7 @@ static struct cfi_private *genprobe_ident_chips(struct map_info *map, struct chi
 	 * our caller, and copy the appropriate data into them.
 	 */
 
-	retcfi = kmalloc(sizeof(struct cfi_private) + cfi.numchips * sizeof(struct flchip), GFP_KERNEL);
+	retcfi = kmalloc(struct_size(retcfi, chips, cfi.numchips), GFP_KERNEL);
 
 	if (!retcfi) {
 		kfree(cfi.cfiq);

commit 48360246162b50e84a6e63ed572fdda5e038518b
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Thu Jun 28 10:20:11 2018 +0200

    mtd: Use kasprintf() instead of fixed buffer formatting
    
    Using "%4.4X" in the calculation of the buffer size is misleading, as
    the format string literal has no relation to the actual size needed.
    Hence this is fragile w.r.t. future modification.
    
    As this is not a hot path, fix this by replacing the formatting in a
    fixed buffer by kasprintf().
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Signed-off-by: Boris Brezillon <boris.brezillon@bootlin.com>

diff --git a/drivers/mtd/chips/gen_probe.c b/drivers/mtd/chips/gen_probe.c
index 879bebf9d8b1..837b04ab96a9 100644
--- a/drivers/mtd/chips/gen_probe.c
+++ b/drivers/mtd/chips/gen_probe.c
@@ -202,16 +202,19 @@ static inline struct mtd_info *cfi_cmdset_unknown(struct map_info *map,
 	struct cfi_private *cfi = map->fldrv_priv;
 	__u16 type = primary?cfi->cfiq->P_ID:cfi->cfiq->A_ID;
 #ifdef CONFIG_MODULES
-	char probename[sizeof("cfi_cmdset_%4.4X")];
 	cfi_cmdset_fn_t *probe_function;
+	char *probename;
 
-	sprintf(probename, "cfi_cmdset_%4.4X", type);
+	probename = kasprintf(GFP_KERNEL, "cfi_cmdset_%4.4X", type);
+	if (!probename)
+		return NULL;
 
 	probe_function = __symbol_get(probename);
 	if (!probe_function) {
 		request_module("cfi_cmdset_%4.4X", type);
 		probe_function = __symbol_get(probename);
 	}
+	kfree(probename);
 
 	if (probe_function) {
 		struct mtd_info *mtd;

commit 7a1f1b594a3d102f3766b9866aa081f5480c0be0
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Sun Jun 24 00:35:42 2018 +0900

    mtd: replace VMLINUX_SYMBOL_STR() with string literal
    
    With the special case handling for Blackfin and Metag was removed by
    commit 94e58e0ac312 ("export.h: remove code for prefixing symbols with
    underscore"), VMLINUX_SYMBOL_STR() can be replaced with string literal.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Signed-off-by: Boris Brezillon <boris.brezillon@bootlin.com>

diff --git a/drivers/mtd/chips/gen_probe.c b/drivers/mtd/chips/gen_probe.c
index b57ceea21513..879bebf9d8b1 100644
--- a/drivers/mtd/chips/gen_probe.c
+++ b/drivers/mtd/chips/gen_probe.c
@@ -202,10 +202,10 @@ static inline struct mtd_info *cfi_cmdset_unknown(struct map_info *map,
 	struct cfi_private *cfi = map->fldrv_priv;
 	__u16 type = primary?cfi->cfiq->P_ID:cfi->cfiq->A_ID;
 #ifdef CONFIG_MODULES
-	char probename[sizeof(VMLINUX_SYMBOL_STR(cfi_cmdset_%4.4X))];
+	char probename[sizeof("cfi_cmdset_%4.4X")];
 	cfi_cmdset_fn_t *probe_function;
 
-	sprintf(probename, VMLINUX_SYMBOL_STR(cfi_cmdset_%4.4X), type);
+	sprintf(probename, "cfi_cmdset_%4.4X", type);
 
 	probe_function = __symbol_get(probename);
 	if (!probe_function) {

commit c039bef73b80911d938d2f8fce0fccfb9dda7346
Author: Jingoo Han <jg1.han@samsung.com>
Date:   Thu Feb 6 15:20:31 2014 +0900

    mtd: gen_probe: Remove unnecessary OOM messages
    
    The site-specific OOM messages are unnecessary, because they
    duplicate the MM subsystem generic OOM message.
    
    Signed-off-by: Jingoo Han <jg1.han@samsung.com>
    Signed-off-by: Brian Norris <computersforpeace@gmail.com>

diff --git a/drivers/mtd/chips/gen_probe.c b/drivers/mtd/chips/gen_probe.c
index ffb36ba8a6e0..b57ceea21513 100644
--- a/drivers/mtd/chips/gen_probe.c
+++ b/drivers/mtd/chips/gen_probe.c
@@ -114,7 +114,6 @@ static struct cfi_private *genprobe_ident_chips(struct map_info *map, struct chi
 	mapsize = sizeof(long) * DIV_ROUND_UP(max_chips, BITS_PER_LONG);
 	chip_map = kzalloc(mapsize, GFP_KERNEL);
 	if (!chip_map) {
-		printk(KERN_WARNING "%s: kmalloc failed for CFI chip map\n", map->name);
 		kfree(cfi.cfiq);
 		return NULL;
 	}
@@ -139,7 +138,6 @@ static struct cfi_private *genprobe_ident_chips(struct map_info *map, struct chi
 	retcfi = kmalloc(sizeof(struct cfi_private) + cfi.numchips * sizeof(struct flchip), GFP_KERNEL);
 
 	if (!retcfi) {
-		printk(KERN_WARNING "%s: kmalloc failed for CFI private structure\n", map->name);
 		kfree(cfi.cfiq);
 		kfree(chip_map);
 		return NULL;

commit f9827dde2f6a1b64f8241de18ccf5027a636d8f4
Author: Kees Cook <keescook@chromium.org>
Date:   Mon Jul 8 06:05:12 2013 -0700

    mtd: refactor call to request_module
    
    This reduces the size of the stack frame when calling request_module().
    Performing the sprintf before the call is not needed.
    
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Acked-by: Rusty Russell <rusty@rustcorp.com.au>
    Reviewed-by: James Hogan <james.hogan@imgtec.com>
    Signed-off-by: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/drivers/mtd/chips/gen_probe.c b/drivers/mtd/chips/gen_probe.c
index 74dbb6bcf488..ffb36ba8a6e0 100644
--- a/drivers/mtd/chips/gen_probe.c
+++ b/drivers/mtd/chips/gen_probe.c
@@ -211,9 +211,7 @@ static inline struct mtd_info *cfi_cmdset_unknown(struct map_info *map,
 
 	probe_function = __symbol_get(probename);
 	if (!probe_function) {
-		char modname[sizeof("cfi_cmdset_%4.4X")];
-		sprintf(modname, "cfi_cmdset_%4.4X", type);
-		request_module(modname);
+		request_module("cfi_cmdset_%4.4X", type);
 		probe_function = __symbol_get(probename);
 	}
 

commit b92021b09df70c1609e3547f3d6128dd560be97f
Author: Rusty Russell <rusty@rustcorp.com.au>
Date:   Fri Mar 15 15:04:17 2013 +1030

    CONFIG_SYMBOL_PREFIX: cleanup.
    
    We have CONFIG_SYMBOL_PREFIX, which three archs define to the string
    "_".  But Al Viro broke this in "consolidate cond_syscall and
    SYSCALL_ALIAS declarations" (in linux-next), and he's not the first to
    do so.
    
    Using CONFIG_SYMBOL_PREFIX is awkward, since we usually just want to
    prefix it so something.  So various places define helpers which are
    defined to nothing if CONFIG_SYMBOL_PREFIX isn't set:
    
    1) include/asm-generic/unistd.h defines __SYMBOL_PREFIX.
    2) include/asm-generic/vmlinux.lds.h defines VMLINUX_SYMBOL(sym)
    3) include/linux/export.h defines MODULE_SYMBOL_PREFIX.
    4) include/linux/kernel.h defines SYMBOL_PREFIX (which differs from #7)
    5) kernel/modsign_certificate.S defines ASM_SYMBOL(sym)
    6) scripts/modpost.c defines MODULE_SYMBOL_PREFIX
    7) scripts/Makefile.lib defines SYMBOL_PREFIX on the commandline if
       CONFIG_SYMBOL_PREFIX is set, so that we have a non-string version
       for pasting.
    
    (arch/h8300/include/asm/linkage.h defines SYMBOL_NAME(), too).
    
    Let's solve this properly:
    1) No more generic prefix, just CONFIG_HAVE_UNDERSCORE_SYMBOL_PREFIX.
    2) Make linux/export.h usable from asm.
    3) Define VMLINUX_SYMBOL() and VMLINUX_SYMBOL_STR().
    4) Make everyone use them.
    
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>
    Reviewed-by: James Hogan <james.hogan@imgtec.com>
    Tested-by: James Hogan <james.hogan@imgtec.com> (metag)

diff --git a/drivers/mtd/chips/gen_probe.c b/drivers/mtd/chips/gen_probe.c
index 3b9a2843c5f8..74dbb6bcf488 100644
--- a/drivers/mtd/chips/gen_probe.c
+++ b/drivers/mtd/chips/gen_probe.c
@@ -204,14 +204,16 @@ static inline struct mtd_info *cfi_cmdset_unknown(struct map_info *map,
 	struct cfi_private *cfi = map->fldrv_priv;
 	__u16 type = primary?cfi->cfiq->P_ID:cfi->cfiq->A_ID;
 #ifdef CONFIG_MODULES
-	char probename[16+sizeof(MODULE_SYMBOL_PREFIX)];
+	char probename[sizeof(VMLINUX_SYMBOL_STR(cfi_cmdset_%4.4X))];
 	cfi_cmdset_fn_t *probe_function;
 
-	sprintf(probename, MODULE_SYMBOL_PREFIX "cfi_cmdset_%4.4X", type);
+	sprintf(probename, VMLINUX_SYMBOL_STR(cfi_cmdset_%4.4X), type);
 
 	probe_function = __symbol_get(probename);
 	if (!probe_function) {
-		request_module(probename + sizeof(MODULE_SYMBOL_PREFIX) - 1);
+		char modname[sizeof("cfi_cmdset_%4.4X")];
+		sprintf(modname, "cfi_cmdset_%4.4X", type);
+		request_module(modname);
 		probe_function = __symbol_get(probename);
 	}
 

commit 8046112818b70329e930b1d4557ef0876c1ad2bb
Author: Guillaume LECERF <glecerf@gmail.com>
Date:   Thu May 20 16:54:10 2010 +0200

    mtd: cfi_cmdset_0002: use AMD standard command-set with Winbond flash chips
    
    Tested with W19L320SBT9C [1].
    
    [1] http://www.datasheetarchive.com/pdf-datasheets/Datasheets-40/DSA-795343.pdf
    
    [dwmw2: Fix MODULE_ALIAS and linkage]
    Signed-off-by: Obinou <obconseil@gmail.com>
    Signed-off-by: Guillaume LECERF <glecerf@gmail.com>
    Acked-by: Florian Fainelli <florian@openwrt.org>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/drivers/mtd/chips/gen_probe.c b/drivers/mtd/chips/gen_probe.c
index 75a8f9db8e4f..3b9a2843c5f8 100644
--- a/drivers/mtd/chips/gen_probe.c
+++ b/drivers/mtd/chips/gen_probe.c
@@ -249,6 +249,7 @@ static struct mtd_info *check_cmd_set(struct map_info *map, int primary)
 #ifdef CONFIG_MTD_CFI_AMDSTD
 	case P_ID_AMD_STD:
 	case P_ID_SST_OLD:
+	case P_ID_WINBOND:
 		return cfi_cmdset_0002(map, primary);
 #endif
 #ifdef CONFIG_MTD_CFI_STAA

commit 83dcd3bb1139060fedb15235f8614d2bac82e18d
Author: Guillaume LECERF <glecerf@gmail.com>
Date:   Sat Apr 24 17:58:22 2010 +0200

    mtd: cfi_cmdset_0002: add CFI detection for SST 39VF{16, 32}xx chips
    
    SST 39VF{16,32}xx chips use the 0x0701 command set, fully compatible
    with the AMD one. This patch adds support for detecting them in CFI
    mode.
    
    Signed-off-by: Guillaume LECERF <glecerf@gmail.com>
    Reviewed-by: Wolfram Sang <w.sang@pengutronix.de>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/drivers/mtd/chips/gen_probe.c b/drivers/mtd/chips/gen_probe.c
index 1d56887c839b..75a8f9db8e4f 100644
--- a/drivers/mtd/chips/gen_probe.c
+++ b/drivers/mtd/chips/gen_probe.c
@@ -248,6 +248,7 @@ static struct mtd_info *check_cmd_set(struct map_info *map, int primary)
 #endif
 #ifdef CONFIG_MTD_CFI_AMDSTD
 	case P_ID_AMD_STD:
+	case P_ID_SST_OLD:
 		return cfi_cmdset_0002(map, primary);
 #endif
 #ifdef CONFIG_MTD_CFI_STAA

commit 58598861227877bb481b9035d2a07283577a2274
Author: Guillaume LECERF <glecerf@gmail.com>
Date:   Sat Apr 24 17:58:07 2010 +0200

    mtd: cfi_probe: use P_ID_* definitions instead of hardcoded values
    
    Use P_ID_* definitions already in include/linux/mtd/cfi.h instead of the
    hardcoded values. Make the code more readable.
    
    Signed-off-by: Guillaume LECERF <glecerf@gmail.com>
    Reviewed-by: Wolfram Sang <w.sang@pengutronix.de>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/drivers/mtd/chips/gen_probe.c b/drivers/mtd/chips/gen_probe.c
index fcc1bc02c8a2..1d56887c839b 100644
--- a/drivers/mtd/chips/gen_probe.c
+++ b/drivers/mtd/chips/gen_probe.c
@@ -241,17 +241,17 @@ static struct mtd_info *check_cmd_set(struct map_info *map, int primary)
 		/* We need these for the !CONFIG_MODULES case,
 		   because symbol_get() doesn't work there */
 #ifdef CONFIG_MTD_CFI_INTELEXT
-	case 0x0001:
-	case 0x0003:
-	case 0x0200:
+	case P_ID_INTEL_EXT:
+	case P_ID_INTEL_STD:
+	case P_ID_INTEL_PERFORMANCE:
 		return cfi_cmdset_0001(map, primary);
 #endif
 #ifdef CONFIG_MTD_CFI_AMDSTD
-	case 0x0002:
+	case P_ID_AMD_STD:
 		return cfi_cmdset_0002(map, primary);
 #endif
 #ifdef CONFIG_MTD_CFI_STAA
-        case 0x0020:
+        case P_ID_ST_ADV:
 		return cfi_cmdset_0020(map, primary);
 #endif
 	default:

commit c4e773764cead9358fd4b036d1b883fff3968513
Author: Stefani Seibold <stefani@seibold.net>
Date:   Sun Apr 18 22:46:44 2010 +0200

    mtd: fix a huge latency problem in the MTD CFI and LPDDR flash drivers.
    
    The use of a memcpy() during a spinlock operation will cause very long
    thread context switch delays if the flash chip bandwidth is low and the
    data to be copied large, because a spinlock will disable preemption.
    
    For example: A flash with 6,5 MB/s bandwidth will cause under ubifs,
    which request sometimes 128 KiB (the flash erase size), a preemption delay of
    20 milliseconds. High priority threads will not be served during this
    time, regardless whether this threads access the flash or not. This behavior
    breaks real time.
    
    The patch changes all the use of spin_lock operations for xxxx->mutex
    into mutex operations, which is exact what the name says and means.
    
    I have checked the code of the drivers and there is no use of atomic
    pathes like interrupt or timers. The mtdoops facility will also not be used
    by this drivers. So it is dave to replace the spin_lock against mutex.
    
    There is no performance regression since the mutex is normally not
    acquired.
    
    Changelog:
     06.03.2010 First release
     26.03.2010 Fix mutex[1] issue and tested it for compile failure
    
    Signed-off-by: Stefani Seibold <stefani@seibold.net>
    Signed-off-by: Artem Bityutskiy <Artem.Bityutskiy@nokia.com>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/drivers/mtd/chips/gen_probe.c b/drivers/mtd/chips/gen_probe.c
index e2dc96441e05..fcc1bc02c8a2 100644
--- a/drivers/mtd/chips/gen_probe.c
+++ b/drivers/mtd/chips/gen_probe.c
@@ -155,8 +155,7 @@ static struct cfi_private *genprobe_ident_chips(struct map_info *map, struct chi
 			pchip->start = (i << cfi.chipshift);
 			pchip->state = FL_READY;
 			init_waitqueue_head(&pchip->wq);
-			spin_lock_init(&pchip->_spinlock);
-			pchip->mutex = &pchip->_spinlock;
+			mutex_init(&pchip->mutex);
 		}
 	}
 

commit c8872b069c536976b81bccfc95dda945594bc504
Author: Julia Lawall <julia@diku.dk>
Date:   Sat Aug 2 17:14:21 2008 +0200

    [MTD] Use DIV_ROUND_UP
    
    The kernel.h macro DIV_ROUND_UP performs the computation (((n) + (d) - 1) /
    (d)) but is perhaps more readable.
    
    Signed-off-by: Julia Lawall <julia@diku.dk>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/drivers/mtd/chips/gen_probe.c b/drivers/mtd/chips/gen_probe.c
index f061885b2812..e2dc96441e05 100644
--- a/drivers/mtd/chips/gen_probe.c
+++ b/drivers/mtd/chips/gen_probe.c
@@ -111,7 +111,7 @@ static struct cfi_private *genprobe_ident_chips(struct map_info *map, struct chi
 		max_chips = 1;
 	}
 
-	mapsize = sizeof(long) * ( (max_chips + BITS_PER_LONG-1) / BITS_PER_LONG );
+	mapsize = sizeof(long) * DIV_ROUND_UP(max_chips, BITS_PER_LONG);
 	chip_map = kzalloc(mapsize, GFP_KERNEL);
 	if (!chip_map) {
 		printk(KERN_WARNING "%s: kmalloc failed for CFI chip map\n", map->name);

commit 3a3688b6af103e2c86a7cfc2050988655e184ecc
Author: Jean Delvare <khali@linux-fr.org>
Date:   Thu Jul 10 13:37:08 2008 +0200

    [MTD] [NOR] gen_probe: No debug message when debugging is disabled
    
    Use pr_debug(...) instead of printk(KERN_DEBUG ...) so that the message
    is only printed when debugging is enabled.
    
    Signed-off-by: Jean Delvare <khali@linux-fr.org>
    Tested-by: John stoffel <john@stoffel.org>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/drivers/mtd/chips/gen_probe.c b/drivers/mtd/chips/gen_probe.c
index e53a58ae384f..f061885b2812 100644
--- a/drivers/mtd/chips/gen_probe.c
+++ b/drivers/mtd/chips/gen_probe.c
@@ -70,8 +70,8 @@ static struct cfi_private *genprobe_ident_chips(struct map_info *map, struct chi
 	   interleave and device type, etc. */
 	if (!genprobe_new_chip(map, cp, &cfi)) {
 		/* The probe didn't like it */
-		printk(KERN_DEBUG "%s: Found no %s device at location zero\n",
-		       cp->name, map->name);
+		pr_debug("%s: Found no %s device at location zero\n",
+			 cp->name, map->name);
 		return NULL;
 	}
 

commit 59018b6d2acabb114ab58637e6ab95ba424a89d0
Author: Adrian Bunk <bunk@kernel.org>
Date:   Tue May 20 01:03:52 2008 +0300

    MTD/JFFS2: remove CVS keywords
    
    Once upon a time, the MTD repository was using CVS.
    
    This patch therefore removes all usages of the no longer updated CVS
    keywords from the MTD code.
    
    This also includes code that printed them to the user.
    
    Signed-off-by: Adrian Bunk <bunk@kernel.org>
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>

diff --git a/drivers/mtd/chips/gen_probe.c b/drivers/mtd/chips/gen_probe.c
index d338b8c92780..e53a58ae384f 100644
--- a/drivers/mtd/chips/gen_probe.c
+++ b/drivers/mtd/chips/gen_probe.c
@@ -2,7 +2,6 @@
  * Routines common to all CFI-type probes.
  * (C) 2001-2003 Red Hat, Inc.
  * GPL'd
- * $Id: gen_probe.c,v 1.24 2005/11/07 11:14:23 gleixner Exp $
  */
 
 #include <linux/kernel.h>

commit 484b8e64c848185af0d3671fafba4dd66ca412d2
Author: Rizzo Davide <davide@elpa.it>
Date:   Mon Feb 4 23:44:48 2008 -0800

    [MTD] [NOR] fix startup lock when using multiple nor flash chips
    
    Taken from http://bugzilla.kernel.org/show_bug.cgi?id=9829
    
    I found and solved the problem, at line 115 of drivers/mtd/chips/gen_probe.c
    (kernel 2.6.24): mapsize value must be calculated in bytes, not in long.
    
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>

diff --git a/drivers/mtd/chips/gen_probe.c b/drivers/mtd/chips/gen_probe.c
index 2eb696d7b97b..d338b8c92780 100644
--- a/drivers/mtd/chips/gen_probe.c
+++ b/drivers/mtd/chips/gen_probe.c
@@ -112,7 +112,7 @@ static struct cfi_private *genprobe_ident_chips(struct map_info *map, struct chi
 		max_chips = 1;
 	}
 
-	mapsize = (max_chips + BITS_PER_LONG-1) / BITS_PER_LONG;
+	mapsize = sizeof(long) * ( (max_chips + BITS_PER_LONG-1) / BITS_PER_LONG );
 	chip_map = kzalloc(mapsize, GFP_KERNEL);
 	if (!chip_map) {
 		printk(KERN_WARNING "%s: kmalloc failed for CFI chip map\n", map->name);

commit c9ac5977299dd106ddb759e7e10035770dff185b
Author: David Woodhouse <dwmw2@infradead.org>
Date:   Thu Nov 30 08:17:38 2006 +0000

    [MTD] Remove trailing whitespace
    
    The newly-added cafe_ecc.c had a lot of it because of the way the lookup
    table was auto-generated; clean up the other files too while we're at it.
    
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>

diff --git a/drivers/mtd/chips/gen_probe.c b/drivers/mtd/chips/gen_probe.c
index 77843d560ae4..2eb696d7b97b 100644
--- a/drivers/mtd/chips/gen_probe.c
+++ b/drivers/mtd/chips/gen_probe.c
@@ -40,7 +40,7 @@ struct mtd_info *mtd_do_chip_probe(struct map_info *map, struct chip_probe *cp)
 	if (mtd) {
 		if (mtd->size > map->size) {
 			printk(KERN_WARNING "Reducing visibility of %ldKiB chip to %ldKiB\n",
-			       (unsigned long)mtd->size >> 10, 
+			       (unsigned long)mtd->size >> 10,
 			       (unsigned long)map->size >> 10);
 			mtd->size = map->size;
 		}

commit 95b93a0cd46682c6d9e8eea803fda510cb6b863a
Author: Burman Yan <yan_952@hotmail.com>
Date:   Wed Nov 15 21:10:29 2006 +0200

    [MTD] replace kmalloc+memset with kzalloc
    
    Signed-off-by: Yan Burman <yan_952@hotmail.com>
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>

diff --git a/drivers/mtd/chips/gen_probe.c b/drivers/mtd/chips/gen_probe.c
index cdb0f590b40c..77843d560ae4 100644
--- a/drivers/mtd/chips/gen_probe.c
+++ b/drivers/mtd/chips/gen_probe.c
@@ -113,13 +113,12 @@ static struct cfi_private *genprobe_ident_chips(struct map_info *map, struct chi
 	}
 
 	mapsize = (max_chips + BITS_PER_LONG-1) / BITS_PER_LONG;
-	chip_map = kmalloc(mapsize, GFP_KERNEL);
+	chip_map = kzalloc(mapsize, GFP_KERNEL);
 	if (!chip_map) {
 		printk(KERN_WARNING "%s: kmalloc failed for CFI chip map\n", map->name);
 		kfree(cfi.cfiq);
 		return NULL;
 	}
-	memset (chip_map, 0, mapsize);
 
 	set_bit(0, chip_map); /* Mark first chip valid */
 

commit 615191bb1dfc6980e7c7a85225444d860d74b343
Author: David Woodhouse <dwmw2@infradead.org>
Date:   Sun May 21 19:03:21 2006 +0100

    [MTD] Account for MODULE_SYMBOL_PREFIX when requesting NOR chip driver
    
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>

diff --git a/drivers/mtd/chips/gen_probe.c b/drivers/mtd/chips/gen_probe.c
index 00ca6f591202..cdb0f590b40c 100644
--- a/drivers/mtd/chips/gen_probe.c
+++ b/drivers/mtd/chips/gen_probe.c
@@ -207,14 +207,14 @@ static inline struct mtd_info *cfi_cmdset_unknown(struct map_info *map,
 	struct cfi_private *cfi = map->fldrv_priv;
 	__u16 type = primary?cfi->cfiq->P_ID:cfi->cfiq->A_ID;
 #ifdef CONFIG_MODULES
-	char probename[32];
+	char probename[16+sizeof(MODULE_SYMBOL_PREFIX)];
 	cfi_cmdset_fn_t *probe_function;
 
-	sprintf(probename, "cfi_cmdset_%4.4X", type);
+	sprintf(probename, MODULE_SYMBOL_PREFIX "cfi_cmdset_%4.4X", type);
 
 	probe_function = __symbol_get(probename);
 	if (!probe_function) {
-		request_module(probename);
+		request_module(probename + sizeof(MODULE_SYMBOL_PREFIX) - 1);
 		probe_function = __symbol_get(probename);
 	}
 

commit 5fc3dbc418e01345e25e96b3192a1c46051c3fdc
Author: David Woodhouse <dwmw2@infradead.org>
Date:   Sat May 20 02:41:34 2006 +0100

    [MTD] Use __symbol_get() instead of symbol_get() in NOR chip probe
    
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>

diff --git a/drivers/mtd/chips/gen_probe.c b/drivers/mtd/chips/gen_probe.c
index 52d59d35091d..00ca6f591202 100644
--- a/drivers/mtd/chips/gen_probe.c
+++ b/drivers/mtd/chips/gen_probe.c
@@ -212,10 +212,10 @@ static inline struct mtd_info *cfi_cmdset_unknown(struct map_info *map,
 
 	sprintf(probename, "cfi_cmdset_%4.4X", type);
 
-	probe_function = (void *)symbol_get(probename);
+	probe_function = __symbol_get(probename);
 	if (!probe_function) {
 		request_module(probename);
-		probe_function = (void *)symbol_get(probename);
+		probe_function = __symbol_get(probename);
 	}
 
 	if (probe_function) {

commit f6a673b3f4f93c1c50e1b18f29254b0531b722a8
Author: David Woodhouse <dwmw2@infradead.org>
Date:   Wed May 17 22:03:10 2006 +0100

    [MTD] Fix printk format error in gen_probe.c
    
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>

diff --git a/drivers/mtd/chips/gen_probe.c b/drivers/mtd/chips/gen_probe.c
index b2d30525c04c..52d59d35091d 100644
--- a/drivers/mtd/chips/gen_probe.c
+++ b/drivers/mtd/chips/gen_probe.c
@@ -39,7 +39,7 @@ struct mtd_info *mtd_do_chip_probe(struct map_info *map, struct chip_probe *cp)
 
 	if (mtd) {
 		if (mtd->size > map->size) {
-			printk(KERN_WARNING "Reducing visibility of %lKiB chip to %lKiB\n",
+			printk(KERN_WARNING "Reducing visibility of %ldKiB chip to %ldKiB\n",
 			       (unsigned long)mtd->size >> 10, 
 			       (unsigned long)map->size >> 10);
 			mtd->size = map->size;

commit 0f5ae3d2e9f49af55eb2a9b7cb54b4c0c2373017
Author: David Woodhouse <dwmw2@infradead.org>
Date:   Sun May 14 01:40:50 2006 +0100

    [MTD] Deal correctly with NOR chips which are smaller than the map window
    
    We used to calculate the number of chips to be zero, allocate an array
    of that size, then nasty things would happen when we attempt to access
    the first object in that zero-sized array.
    
    Now, if the number of _full_ chips that would fit into the map is zero,
    we allocate an array of one anyway, and then artificially reduce the
    total size of the resulting MTD device to fit in the map.
    
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>

diff --git a/drivers/mtd/chips/gen_probe.c b/drivers/mtd/chips/gen_probe.c
index 9b252d2e4a70..b2d30525c04c 100644
--- a/drivers/mtd/chips/gen_probe.c
+++ b/drivers/mtd/chips/gen_probe.c
@@ -37,8 +37,15 @@ struct mtd_info *mtd_do_chip_probe(struct map_info *map, struct chip_probe *cp)
 	if (!mtd)
 		mtd = check_cmd_set(map, 0); /* Then the secondary */
 
-	if (mtd)
+	if (mtd) {
+		if (mtd->size > map->size) {
+			printk(KERN_WARNING "Reducing visibility of %lKiB chip to %lKiB\n",
+			       (unsigned long)mtd->size >> 10, 
+			       (unsigned long)map->size >> 10);
+			mtd->size = map->size;
+		}
 		return mtd;
+	}
 
 	printk(KERN_WARNING"gen_probe: No supported Vendor Command Set found\n");
 
@@ -100,7 +107,12 @@ static struct cfi_private *genprobe_ident_chips(struct map_info *map, struct chi
 	 * Align bitmap storage size to full byte.
 	 */
 	max_chips = map->size >> cfi.chipshift;
-	mapsize = (max_chips / 8) + ((max_chips % 8) ? 1 : 0);
+	if (!max_chips) {
+		printk(KERN_WARNING "NOR chip too large to fit in mapping. Attempting to cope...\n");
+		max_chips = 1;
+	}
+
+	mapsize = (max_chips + BITS_PER_LONG-1) / BITS_PER_LONG;
 	chip_map = kmalloc(mapsize, GFP_KERNEL);
 	if (!chip_map) {
 		printk(KERN_WARNING "%s: kmalloc failed for CFI chip map\n", map->name);

commit a15bdeef108d282e540e202fc3c3e4bdf9692074
Author: David Woodhouse <dwmw2@infradead.org>
Date:   Mon May 8 22:35:05 2006 +0100

    Remove use of inter_module_crap in NOR flash chip drivers.
    
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>

diff --git a/drivers/mtd/chips/gen_probe.c b/drivers/mtd/chips/gen_probe.c
index 41bd59d20d85..9b252d2e4a70 100644
--- a/drivers/mtd/chips/gen_probe.c
+++ b/drivers/mtd/chips/gen_probe.c
@@ -194,25 +194,28 @@ static inline struct mtd_info *cfi_cmdset_unknown(struct map_info *map,
 {
 	struct cfi_private *cfi = map->fldrv_priv;
 	__u16 type = primary?cfi->cfiq->P_ID:cfi->cfiq->A_ID;
-#if defined(CONFIG_MODULES) && defined(HAVE_INTER_MODULE)
+#ifdef CONFIG_MODULES
 	char probename[32];
 	cfi_cmdset_fn_t *probe_function;
 
 	sprintf(probename, "cfi_cmdset_%4.4X", type);
 
-	probe_function = inter_module_get_request(probename, probename);
+	probe_function = (void *)symbol_get(probename);
+	if (!probe_function) {
+		request_module(probename);
+		probe_function = (void *)symbol_get(probename);
+	}
 
 	if (probe_function) {
 		struct mtd_info *mtd;
 
 		mtd = (*probe_function)(map, primary);
 		/* If it was happy, it'll have increased its own use count */
-		inter_module_put(probename);
+		symbol_put_addr(probe_function);
 		return mtd;
 	}
 #endif
-	printk(KERN_NOTICE "Support for command set %04X not present\n",
-	       type);
+	printk(KERN_NOTICE "Support for command set %04X not present\n", type);
 
 	return NULL;
 }
@@ -226,12 +229,8 @@ static struct mtd_info *check_cmd_set(struct map_info *map, int primary)
 		return NULL;
 
 	switch(type){
-		/* Urgh. Ifdefs. The version with weak symbols was
-		 * _much_ nicer. Shame it didn't seem to work on
-		 * anything but x86, really.
-		 * But we can't rely in inter_module_get() because
-		 * that'd mean we depend on link order.
-		 */
+		/* We need these for the !CONFIG_MODULES case,
+		   because symbol_get() doesn't work there */
 #ifdef CONFIG_MTD_CFI_INTELEXT
 	case 0x0001:
 	case 0x0003:
@@ -246,9 +245,9 @@ static struct mtd_info *check_cmd_set(struct map_info *map, int primary)
         case 0x0020:
 		return cfi_cmdset_0020(map, primary);
 #endif
+	default:
+		return cfi_cmdset_unknown(map, primary);
 	}
-
-	return cfi_cmdset_unknown(map, primary);
 }
 
 MODULE_LICENSE("GPL");

commit 1f948b43f7b5cf721cf0d03f507843efc1a9bfad
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Nov 7 11:15:37 2005 +0000

    [MTD] chips: Clean up trailing white spaces
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/drivers/mtd/chips/gen_probe.c b/drivers/mtd/chips/gen_probe.c
index 28807eb9fc86..41bd59d20d85 100644
--- a/drivers/mtd/chips/gen_probe.c
+++ b/drivers/mtd/chips/gen_probe.c
@@ -2,7 +2,7 @@
  * Routines common to all CFI-type probes.
  * (C) 2001-2003 Red Hat, Inc.
  * GPL'd
- * $Id: gen_probe.c,v 1.23 2005/08/06 04:40:41 nico Exp $
+ * $Id: gen_probe.c,v 1.24 2005/11/07 11:14:23 gleixner Exp $
  */
 
 #include <linux/kernel.h>
@@ -26,7 +26,7 @@ struct mtd_info *mtd_do_chip_probe(struct map_info *map, struct chip_probe *cp)
 
 	/* First probe the map to see if we have CFI stuff there. */
 	cfi = genprobe_ident_chips(map, cp);
-	
+
 	if (!cfi)
 		return NULL;
 
@@ -36,12 +36,12 @@ struct mtd_info *mtd_do_chip_probe(struct map_info *map, struct chip_probe *cp)
 	mtd = check_cmd_set(map, 1); /* First the primary cmdset */
 	if (!mtd)
 		mtd = check_cmd_set(map, 0); /* Then the secondary */
-	
+
 	if (mtd)
 		return mtd;
 
 	printk(KERN_WARNING"gen_probe: No supported Vendor Command Set found\n");
-	
+
 	kfree(cfi->cfiq);
 	kfree(cfi);
 	map->fldrv_priv = NULL;
@@ -60,14 +60,14 @@ static struct cfi_private *genprobe_ident_chips(struct map_info *map, struct chi
 
 	memset(&cfi, 0, sizeof(cfi));
 
-	/* Call the probetype-specific code with all permutations of 
+	/* Call the probetype-specific code with all permutations of
 	   interleave and device type, etc. */
 	if (!genprobe_new_chip(map, cp, &cfi)) {
 		/* The probe didn't like it */
 		printk(KERN_DEBUG "%s: Found no %s device at location zero\n",
 		       cp->name, map->name);
 		return NULL;
-	}		
+	}
 
 #if 0 /* Let the CFI probe routine do this sanity check. The Intel and AMD
 	 probe routines won't ever return a broken CFI structure anyway,
@@ -92,13 +92,13 @@ static struct cfi_private *genprobe_ident_chips(struct map_info *map, struct chi
 	} else {
 		BUG();
 	}
-		
+
 	cfi.numchips = 1;
 
-	/* 
-	 * Allocate memory for bitmap of valid chips. 
-	 * Align bitmap storage size to full byte. 
-	 */ 
+	/*
+	 * Allocate memory for bitmap of valid chips.
+	 * Align bitmap storage size to full byte.
+	 */
 	max_chips = map->size >> cfi.chipshift;
 	mapsize = (max_chips / 8) + ((max_chips % 8) ? 1 : 0);
 	chip_map = kmalloc(mapsize, GFP_KERNEL);
@@ -122,7 +122,7 @@ static struct cfi_private *genprobe_ident_chips(struct map_info *map, struct chi
 	}
 
 	/*
-	 * Now allocate the space for the structures we need to return to 
+	 * Now allocate the space for the structures we need to return to
 	 * our caller, and copy the appropriate data into them.
 	 */
 
@@ -154,7 +154,7 @@ static struct cfi_private *genprobe_ident_chips(struct map_info *map, struct chi
 	return retcfi;
 }
 
-	
+
 static int genprobe_new_chip(struct map_info *map, struct chip_probe *cp,
 			     struct cfi_private *cfi)
 {
@@ -189,7 +189,7 @@ extern cfi_cmdset_fn_t cfi_cmdset_0001;
 extern cfi_cmdset_fn_t cfi_cmdset_0002;
 extern cfi_cmdset_fn_t cfi_cmdset_0020;
 
-static inline struct mtd_info *cfi_cmdset_unknown(struct map_info *map, 
+static inline struct mtd_info *cfi_cmdset_unknown(struct map_info *map,
 						  int primary)
 {
 	struct cfi_private *cfi = map->fldrv_priv;
@@ -199,7 +199,7 @@ static inline struct mtd_info *cfi_cmdset_unknown(struct map_info *map,
 	cfi_cmdset_fn_t *probe_function;
 
 	sprintf(probename, "cfi_cmdset_%4.4X", type);
-		
+
 	probe_function = inter_module_get_request(probename, probename);
 
 	if (probe_function) {
@@ -221,7 +221,7 @@ static struct mtd_info *check_cmd_set(struct map_info *map, int primary)
 {
 	struct cfi_private *cfi = map->fldrv_priv;
 	__u16 type = primary?cfi->cfiq->P_ID:cfi->cfiq->A_ID;
-	
+
 	if (type == P_ID_NONE || type == P_ID_RESERVED)
 		return NULL;
 

commit 638d983840bb64e02c29bdd6160bb9963f4090f7
Author: Nicolas Pitre <nico@cam.org>
Date:   Sat Aug 6 05:40:46 2005 +0100

    {MTD] add support for Intel's "Sibley" flash
    
    This updates the Primary Vendor-Specific Extended Query parsing to
    version 1.4 in order to get the information about the Configurable
    Programming Mode regions implemented in the Sibley flash, as well as
    selecting the appropriate write command code.
    
    This flash does not behave like traditional NOR flash when writing data.
    While mtdblock should just work, further changes are needed for JFFS2 use.
    
    Signed-off-by: Nicolas Pitre <nico@cam.org>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/drivers/mtd/chips/gen_probe.c b/drivers/mtd/chips/gen_probe.c
index dc065b22f79e..28807eb9fc86 100644
--- a/drivers/mtd/chips/gen_probe.c
+++ b/drivers/mtd/chips/gen_probe.c
@@ -2,7 +2,7 @@
  * Routines common to all CFI-type probes.
  * (C) 2001-2003 Red Hat, Inc.
  * GPL'd
- * $Id: gen_probe.c,v 1.22 2005/01/24 23:49:50 rmk Exp $
+ * $Id: gen_probe.c,v 1.23 2005/08/06 04:40:41 nico Exp $
  */
 
 #include <linux/kernel.h>
@@ -235,6 +235,7 @@ static struct mtd_info *check_cmd_set(struct map_info *map, int primary)
 #ifdef CONFIG_MTD_CFI_INTELEXT
 	case 0x0001:
 	case 0x0003:
+	case 0x0200:
 		return cfi_cmdset_0001(map, primary);
 #endif
 #ifdef CONFIG_MTD_CFI_AMDSTD

commit 6170b43401a3230756ff76287ee07db0d75eddde
Author: Russell King <linux@arm.linux.org.uk>
Date:   Mon Jan 24 23:49:54 2005 +0000

    [MTD] Fix MTD device probing
    
    Try larger numbers of chips before smaller
    numbers of chips across the bus width.
    
    This means we'll avoid misdetecting a 2 x16 array as 1 x32 if the
    high 16-bits happen to read as zeros in the QRY area.
    
    Signed-off-by: Russell King <linux@arm.linux.org.uk>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/drivers/mtd/chips/gen_probe.c b/drivers/mtd/chips/gen_probe.c
index fc982c4671f0..dc065b22f79e 100644
--- a/drivers/mtd/chips/gen_probe.c
+++ b/drivers/mtd/chips/gen_probe.c
@@ -2,7 +2,7 @@
  * Routines common to all CFI-type probes.
  * (C) 2001-2003 Red Hat, Inc.
  * GPL'd
- * $Id: gen_probe.c,v 1.21 2004/08/14 15:14:05 dwmw2 Exp $
+ * $Id: gen_probe.c,v 1.22 2005/01/24 23:49:50 rmk Exp $
  */
 
 #include <linux/kernel.h>
@@ -162,7 +162,7 @@ static int genprobe_new_chip(struct map_info *map, struct chip_probe *cp,
 	int max_chips = map_bankwidth(map); /* And minimum 1 */
 	int nr_chips, type;
 
-	for (nr_chips = min_chips; nr_chips <= max_chips; nr_chips <<= 1) {
+	for (nr_chips = max_chips; nr_chips >= min_chips; nr_chips >>= 1) {
 
 		if (!cfi_interleave_supported(nr_chips))
 		    continue;

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/drivers/mtd/chips/gen_probe.c b/drivers/mtd/chips/gen_probe.c
new file mode 100644
index 000000000000..fc982c4671f0
--- /dev/null
+++ b/drivers/mtd/chips/gen_probe.c
@@ -0,0 +1,255 @@
+/*
+ * Routines common to all CFI-type probes.
+ * (C) 2001-2003 Red Hat, Inc.
+ * GPL'd
+ * $Id: gen_probe.c,v 1.21 2004/08/14 15:14:05 dwmw2 Exp $
+ */
+
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/cfi.h>
+#include <linux/mtd/gen_probe.h>
+
+static struct mtd_info *check_cmd_set(struct map_info *, int);
+static struct cfi_private *genprobe_ident_chips(struct map_info *map,
+						struct chip_probe *cp);
+static int genprobe_new_chip(struct map_info *map, struct chip_probe *cp,
+			     struct cfi_private *cfi);
+
+struct mtd_info *mtd_do_chip_probe(struct map_info *map, struct chip_probe *cp)
+{
+	struct mtd_info *mtd = NULL;
+	struct cfi_private *cfi;
+
+	/* First probe the map to see if we have CFI stuff there. */
+	cfi = genprobe_ident_chips(map, cp);
+	
+	if (!cfi)
+		return NULL;
+
+	map->fldrv_priv = cfi;
+	/* OK we liked it. Now find a driver for the command set it talks */
+
+	mtd = check_cmd_set(map, 1); /* First the primary cmdset */
+	if (!mtd)
+		mtd = check_cmd_set(map, 0); /* Then the secondary */
+	
+	if (mtd)
+		return mtd;
+
+	printk(KERN_WARNING"gen_probe: No supported Vendor Command Set found\n");
+	
+	kfree(cfi->cfiq);
+	kfree(cfi);
+	map->fldrv_priv = NULL;
+	return NULL;
+}
+EXPORT_SYMBOL(mtd_do_chip_probe);
+
+
+static struct cfi_private *genprobe_ident_chips(struct map_info *map, struct chip_probe *cp)
+{
+	struct cfi_private cfi;
+	struct cfi_private *retcfi;
+	unsigned long *chip_map;
+	int i, j, mapsize;
+	int max_chips;
+
+	memset(&cfi, 0, sizeof(cfi));
+
+	/* Call the probetype-specific code with all permutations of 
+	   interleave and device type, etc. */
+	if (!genprobe_new_chip(map, cp, &cfi)) {
+		/* The probe didn't like it */
+		printk(KERN_DEBUG "%s: Found no %s device at location zero\n",
+		       cp->name, map->name);
+		return NULL;
+	}		
+
+#if 0 /* Let the CFI probe routine do this sanity check. The Intel and AMD
+	 probe routines won't ever return a broken CFI structure anyway,
+	 because they make them up themselves.
+      */
+	if (cfi.cfiq->NumEraseRegions == 0) {
+		printk(KERN_WARNING "Number of erase regions is zero\n");
+		kfree(cfi.cfiq);
+		return NULL;
+	}
+#endif
+	cfi.chipshift = cfi.cfiq->DevSize;
+
+	if (cfi_interleave_is_1(&cfi)) {
+		;
+	} else if (cfi_interleave_is_2(&cfi)) {
+		cfi.chipshift++;
+	} else if (cfi_interleave_is_4((&cfi))) {
+		cfi.chipshift += 2;
+	} else if (cfi_interleave_is_8(&cfi)) {
+		cfi.chipshift += 3;
+	} else {
+		BUG();
+	}
+		
+	cfi.numchips = 1;
+
+	/* 
+	 * Allocate memory for bitmap of valid chips. 
+	 * Align bitmap storage size to full byte. 
+	 */ 
+	max_chips = map->size >> cfi.chipshift;
+	mapsize = (max_chips / 8) + ((max_chips % 8) ? 1 : 0);
+	chip_map = kmalloc(mapsize, GFP_KERNEL);
+	if (!chip_map) {
+		printk(KERN_WARNING "%s: kmalloc failed for CFI chip map\n", map->name);
+		kfree(cfi.cfiq);
+		return NULL;
+	}
+	memset (chip_map, 0, mapsize);
+
+	set_bit(0, chip_map); /* Mark first chip valid */
+
+	/*
+	 * Now probe for other chips, checking sensibly for aliases while
+	 * we're at it. The new_chip probe above should have let the first
+	 * chip in read mode.
+	 */
+
+	for (i = 1; i < max_chips; i++) {
+		cp->probe_chip(map, i << cfi.chipshift, chip_map, &cfi);
+	}
+
+	/*
+	 * Now allocate the space for the structures we need to return to 
+	 * our caller, and copy the appropriate data into them.
+	 */
+
+	retcfi = kmalloc(sizeof(struct cfi_private) + cfi.numchips * sizeof(struct flchip), GFP_KERNEL);
+
+	if (!retcfi) {
+		printk(KERN_WARNING "%s: kmalloc failed for CFI private structure\n", map->name);
+		kfree(cfi.cfiq);
+		kfree(chip_map);
+		return NULL;
+	}
+
+	memcpy(retcfi, &cfi, sizeof(cfi));
+	memset(&retcfi->chips[0], 0, sizeof(struct flchip) * cfi.numchips);
+
+	for (i = 0, j = 0; (j < cfi.numchips) && (i < max_chips); i++) {
+		if(test_bit(i, chip_map)) {
+			struct flchip *pchip = &retcfi->chips[j++];
+
+			pchip->start = (i << cfi.chipshift);
+			pchip->state = FL_READY;
+			init_waitqueue_head(&pchip->wq);
+			spin_lock_init(&pchip->_spinlock);
+			pchip->mutex = &pchip->_spinlock;
+		}
+	}
+
+	kfree(chip_map);
+	return retcfi;
+}
+
+	
+static int genprobe_new_chip(struct map_info *map, struct chip_probe *cp,
+			     struct cfi_private *cfi)
+{
+	int min_chips = (map_bankwidth(map)/4?:1); /* At most 4-bytes wide. */
+	int max_chips = map_bankwidth(map); /* And minimum 1 */
+	int nr_chips, type;
+
+	for (nr_chips = min_chips; nr_chips <= max_chips; nr_chips <<= 1) {
+
+		if (!cfi_interleave_supported(nr_chips))
+		    continue;
+
+		cfi->interleave = nr_chips;
+
+		/* Minimum device size. Don't look for one 8-bit device
+		   in a 16-bit bus, etc. */
+		type = map_bankwidth(map) / nr_chips;
+
+		for (; type <= CFI_DEVICETYPE_X32; type<<=1) {
+			cfi->device_type = type;
+
+			if (cp->probe_chip(map, 0, NULL, cfi))
+				return 1;
+		}
+	}
+	return 0;
+}
+
+typedef struct mtd_info *cfi_cmdset_fn_t(struct map_info *, int);
+
+extern cfi_cmdset_fn_t cfi_cmdset_0001;
+extern cfi_cmdset_fn_t cfi_cmdset_0002;
+extern cfi_cmdset_fn_t cfi_cmdset_0020;
+
+static inline struct mtd_info *cfi_cmdset_unknown(struct map_info *map, 
+						  int primary)
+{
+	struct cfi_private *cfi = map->fldrv_priv;
+	__u16 type = primary?cfi->cfiq->P_ID:cfi->cfiq->A_ID;
+#if defined(CONFIG_MODULES) && defined(HAVE_INTER_MODULE)
+	char probename[32];
+	cfi_cmdset_fn_t *probe_function;
+
+	sprintf(probename, "cfi_cmdset_%4.4X", type);
+		
+	probe_function = inter_module_get_request(probename, probename);
+
+	if (probe_function) {
+		struct mtd_info *mtd;
+
+		mtd = (*probe_function)(map, primary);
+		/* If it was happy, it'll have increased its own use count */
+		inter_module_put(probename);
+		return mtd;
+	}
+#endif
+	printk(KERN_NOTICE "Support for command set %04X not present\n",
+	       type);
+
+	return NULL;
+}
+
+static struct mtd_info *check_cmd_set(struct map_info *map, int primary)
+{
+	struct cfi_private *cfi = map->fldrv_priv;
+	__u16 type = primary?cfi->cfiq->P_ID:cfi->cfiq->A_ID;
+	
+	if (type == P_ID_NONE || type == P_ID_RESERVED)
+		return NULL;
+
+	switch(type){
+		/* Urgh. Ifdefs. The version with weak symbols was
+		 * _much_ nicer. Shame it didn't seem to work on
+		 * anything but x86, really.
+		 * But we can't rely in inter_module_get() because
+		 * that'd mean we depend on link order.
+		 */
+#ifdef CONFIG_MTD_CFI_INTELEXT
+	case 0x0001:
+	case 0x0003:
+		return cfi_cmdset_0001(map, primary);
+#endif
+#ifdef CONFIG_MTD_CFI_AMDSTD
+	case 0x0002:
+		return cfi_cmdset_0002(map, primary);
+#endif
+#ifdef CONFIG_MTD_CFI_STAA
+        case 0x0020:
+		return cfi_cmdset_0020(map, primary);
+#endif
+	}
+
+	return cfi_cmdset_unknown(map, primary);
+}
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("David Woodhouse <dwmw2@infradead.org>");
+MODULE_DESCRIPTION("Helper routines for flash chip probe code");
