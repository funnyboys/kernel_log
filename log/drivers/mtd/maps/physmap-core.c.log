commit 0bc448b49e8a017e16edf843baf5b4221e191b1f
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Mon Dec 9 14:48:23 2019 +0100

    mtd: maps: physmap: Add minimal Runtime PM support
    
    Add minimal runtime PM support (enable on probe, disable on remove), to
    ensure proper operation with a parent device that uses runtime PM.
    
    This is needed on systems where the FLASH is connected to a bus
    controller that is contained in a PM domain and/or has a gateable
    functional clock.  In such cases, before accessing any device connected
    to the external bus, the PM domain must be powered up, and/or the
    functional clock must be enabled, which is typically handled through
    runtime PM by the bus controller driver.
    
    An example of this is the Renesas APE6-EVM development board, which has
    an Ethernet controller and a CFI FLASH connected to the Bus State
    Controller (BSC) of an R-Mobile APE6 SoC.
    As long as the Ethernet driver, which had Runtime PM support since
    commit 3a611e26e958b037 ("net/smsc911x: Add minimal runtime PM
    support"), keeps the BSC powered, accessing the FLASH works.
    When the ethernet node in r8a73a4-ape6evm.dts is disabled, the BSC is
    never powered up, and the kernel crashes when trying to access the
    FLASH:
    
        Unhandled fault: imprecise external abort (0x1406) at 0x00000000
        pgd = (ptrval)
        [00000000] *pgd=7fef2835
        Internal error: : 1406 [#1] SMP ARM
        CPU: 0 PID: 122 Comm: hd Tainted: G        W         5.5.0-rc1-ape6evm-00814-g38ca966db25b9dbd-dirty #136
        Hardware name: Generic R8A73A4 (Flattened Device Tree)
        PC is at chip_ready+0x12c/0x380
        LR is at chip_ready+0x10c/0x380
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Signed-off-by: Miquel Raynal <miquel.raynal@bootlin.com>

diff --git a/drivers/mtd/maps/physmap-core.c b/drivers/mtd/maps/physmap-core.c
index a9f7964e2edb..8f7f966fa9a7 100644
--- a/drivers/mtd/maps/physmap-core.c
+++ b/drivers/mtd/maps/physmap-core.c
@@ -38,6 +38,7 @@
 #include <linux/mtd/cfi_endian.h>
 #include <linux/io.h>
 #include <linux/of_device.h>
+#include <linux/pm_runtime.h>
 #include <linux/gpio/consumer.h>
 
 #include "physmap-gemini.h"
@@ -64,16 +65,16 @@ static int physmap_flash_remove(struct platform_device *dev)
 {
 	struct physmap_flash_info *info;
 	struct physmap_flash_data *physmap_data;
-	int i, err;
+	int i, err = 0;
 
 	info = platform_get_drvdata(dev);
 	if (!info)
-		return 0;
+		goto out;
 
 	if (info->cmtd) {
 		err = mtd_device_unregister(info->cmtd);
 		if (err)
-			return err;
+			goto out;
 
 		if (info->cmtd != info->mtds[0])
 			mtd_concat_destroy(info->cmtd);
@@ -88,7 +89,10 @@ static int physmap_flash_remove(struct platform_device *dev)
 	if (physmap_data && physmap_data->exit)
 		physmap_data->exit(dev);
 
-	return 0;
+out:
+	pm_runtime_put(&dev->dev);
+	pm_runtime_disable(&dev->dev);
+	return err;
 }
 
 static void physmap_set_vpp(struct map_info *map, int state)
@@ -484,13 +488,19 @@ static int physmap_flash_probe(struct platform_device *dev)
 		return -EINVAL;
 	}
 
+	pm_runtime_enable(&dev->dev);
+	pm_runtime_get_sync(&dev->dev);
+
 	if (dev->dev.of_node)
 		err = physmap_flash_of_init(dev);
 	else
 		err = physmap_flash_pdata_init(dev);
 
-	if (err)
+	if (err) {
+		pm_runtime_put(&dev->dev);
+		pm_runtime_disable(&dev->dev);
 		return err;
+	}
 
 	for (i = 0; i < info->nmaps; i++) {
 		struct resource *res;

commit 2aba2f2a704d368583e832555b25d88265e62b6d
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Mon Oct 21 01:00:42 2019 +0200

    mtd: physmap_of: add a hook for Intel IXP4xx flash probing
    
    In order to support device tree probing of IXP4xx NOR flash
    chips, a certain big-endian or mixed-endian memory access
    pattern need to be used.
    
    I have opted to use the pattern set by previous plug-ins
    to physmap for Gemini and Versatile, just override some
    functions and reuse most of the physmap core code as it
    is to minimize maintenance.
    
    Parts of drivers/mtd/ixp4xx.c are copied into this file.
    
    After we have IXP4xx converted fully to device tree, the
    drivers/mtd/ixp4xx.c file will be deleted and this will
    be the only access pattern to the IXP4xx flash.
    
    I did not keep the quirk in the flash write function
    after probe, where the old code for a while checks for
    access to odd addresses, fails and assigns a "faster"
    write function once it has convinced probe to only use
    2-byte accesses. As we mandate that this device should
    be using bank-width = <2> this should not be a problem
    unless misconfigured.
    
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Miquel Raynal <miquel.raynal@bootlin.com>

diff --git a/drivers/mtd/maps/physmap-core.c b/drivers/mtd/maps/physmap-core.c
index 21b556afc305..a9f7964e2edb 100644
--- a/drivers/mtd/maps/physmap-core.c
+++ b/drivers/mtd/maps/physmap-core.c
@@ -41,6 +41,7 @@
 #include <linux/gpio/consumer.h>
 
 #include "physmap-gemini.h"
+#include "physmap-ixp4xx.h"
 #include "physmap-versatile.h"
 
 struct physmap_flash_info {
@@ -370,6 +371,10 @@ static int physmap_flash_of_init(struct platform_device *dev)
 		if (err)
 			return err;
 
+		err = of_flash_probe_ixp4xx(dev, dp, &info->maps[i]);
+		if (err)
+			return err;
+
 		err = of_flash_probe_versatile(dev, dp, &info->maps[i]);
 		if (err)
 			return err;

commit 64d14c6fe040361ff6aecb825e392cf97837cd9e
Author: Chris Packham <chris.packham@alliedtelesis.co.nz>
Date:   Fri Mar 29 15:13:21 2019 +1300

    mtd: maps: physmap: Store gpio_values correctly
    
    When the gpio-addr-flash.c driver was merged with physmap-core.c the
    code to store the current gpio_values was lost. This meant that once a
    gpio was asserted it was never de-asserted. Fix this by storing the
    current offset in gpio_values like the old driver used to.
    
    Fixes: commit ba32ce95cbd9 ("mtd: maps: Merge gpio-addr-flash.c into physmap-core.c")
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Chris Packham <chris.packham@alliedtelesis.co.nz>
    Reviewed-by: Boris Brezillon <boris.brezillon@collabora.com>
    Signed-off-by: Richard Weinberger <richard@nod.at>

diff --git a/drivers/mtd/maps/physmap-core.c b/drivers/mtd/maps/physmap-core.c
index d9a3e4bebe5d..21b556afc305 100644
--- a/drivers/mtd/maps/physmap-core.c
+++ b/drivers/mtd/maps/physmap-core.c
@@ -132,6 +132,8 @@ static void physmap_set_addr_gpios(struct physmap_flash_info *info,
 
 		gpiod_set_value(info->gpios->desc[i], !!(BIT(i) & ofs));
 	}
+
+	info->gpio_values = ofs;
 }
 
 #define win_mask(order)		(BIT(order) - 1)

commit b3dd93030c3cdd3f191aa170ccafc2b4d316f4cc
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Tue Nov 27 21:53:57 2018 +0100

    mtd: maps: physmap: Leave assigned complex mappings
    
    SoC-specific drivers might provide their own map->xxx()
    implementations, and calling simple_map_init() unconditionally will
    override those implementations.
    
    Make sure map->read is NULL before calling simple_map_init().
    
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Boris Brezillon <boris.brezillon@bootlin.com>

diff --git a/drivers/mtd/maps/physmap-core.c b/drivers/mtd/maps/physmap-core.c
index e8c3b250d842..d9a3e4bebe5d 100644
--- a/drivers/mtd/maps/physmap-core.c
+++ b/drivers/mtd/maps/physmap-core.c
@@ -514,10 +514,20 @@ static int physmap_flash_probe(struct platform_device *dev)
 			err = physmap_addr_gpios_map_init(&info->maps[i]);
 			if (err)
 				goto err_out;
-		} else {
-			simple_map_init(&info->maps[i]);
 		}
 
+#ifdef CONFIG_MTD_COMPLEX_MAPPINGS
+		/*
+		 * Only use the simple_map implementation if map hooks are not
+		 * implemented. Since map->read() is mandatory checking for its
+		 * presence is enough.
+		 */
+		if (!info->maps[i].read)
+			simple_map_init(&info->maps[i]);
+#else
+		simple_map_init(&info->maps[i]);
+#endif
+
 		if (info->probe_type) {
 			info->mtds[i] = do_map_probe(info->probe_type,
 						     &info->maps[i]);

commit 99f732b3a8656b148b3725192c8eac6982c6c80d
Author: Ricardo Ribalda Delgado <ricardo.ribalda@gmail.com>
Date:   Fri Oct 19 09:49:08 2018 +0200

    mtd: maps: physmap: Invert logic on if/else branch
    
    It is preferred to have the positive statement on an if/else. While we
    are at it we replace the way we access rom_probe_types.
    
    Signed-off-by: Ricardo Ribalda Delgado <ricardo.ribalda@gmail.com>
    Signed-off-by: Boris Brezillon <boris.brezillon@bootlin.com>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/mtd/maps/physmap-core.c b/drivers/mtd/maps/physmap-core.c
index 11e6239aadc7..e8c3b250d842 100644
--- a/drivers/mtd/maps/physmap-core.c
+++ b/drivers/mtd/maps/physmap-core.c
@@ -396,7 +396,7 @@ static int physmap_flash_of_init(struct platform_device *dev)
 #endif /* IS_ENABLED(CONFIG_MTD_PHYSMAP_OF) */
 
 static const char * const rom_probe_types[] = {
-	"cfi_probe", "jedec_probe", "qinfo_probe", "map_rom", NULL
+	"cfi_probe", "jedec_probe", "qinfo_probe", "map_rom",
 };
 
 static const char * const part_probe_types[] = {
@@ -437,7 +437,6 @@ static int physmap_flash_pdata_init(struct platform_device *dev)
 static int physmap_flash_probe(struct platform_device *dev)
 {
 	struct physmap_flash_info *info;
-	const char * const *probe_type;
 	int err = 0;
 	int i;
 
@@ -519,14 +518,18 @@ static int physmap_flash_probe(struct platform_device *dev)
 			simple_map_init(&info->maps[i]);
 		}
 
-		probe_type = rom_probe_types;
-		if (!info->probe_type) {
-			for (; !info->mtds[i] && *probe_type; probe_type++)
-				info->mtds[i] = do_map_probe(*probe_type,
-							     &info->maps[i]);
-		} else {
+		if (info->probe_type) {
 			info->mtds[i] = do_map_probe(info->probe_type,
 						     &info->maps[i]);
+		} else {
+			int j;
+
+			for (j = 0; j < ARRAY_SIZE(rom_probe_types); j++) {
+				info->mtds[i] = do_map_probe(rom_probe_types[j],
+							     &info->maps[i]);
+				if (info->mtds[i])
+					break;
+			}
 		}
 
 		if (!info->mtds[i]) {

commit ba32ce95cbd9876eb7f5ec39af87829c8f13a337
Author: Boris Brezillon <boris.brezillon@bootlin.com>
Date:   Fri Oct 19 09:49:07 2018 +0200

    mtd: maps: Merge gpio-addr-flash.c into physmap-core.c
    
    Controlling some MSB address lines using GPIOs is just a small
    deviation from the generic physmap logic, and merging those two drivers
    allows us to share most of the probe logic, which is a good thing.
    
    Also, the gpio-addr-flash driver is unused since the removal of
    the blackfin arch in v4.17, so we can safely remove the old driver
    without risking breaking existing boards.
    
    Signed-off-by: Boris Brezillon <boris.brezillon@bootlin.com>
    Reviewed-by: Ricardo Ribalda Delgado <ricardo.ribalda@gmail.com>
    Tested-by: Ricardo Ribalda Delgado <ricardo.ribalda@gmail.com>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/mtd/maps/physmap-core.c b/drivers/mtd/maps/physmap-core.c
index 8a8af37576ff..11e6239aadc7 100644
--- a/drivers/mtd/maps/physmap-core.c
+++ b/drivers/mtd/maps/physmap-core.c
@@ -13,6 +13,14 @@
  *
  *    Revised to handle newer style flash binding by:
  *    Copyright (C) 2007 David Gibson, IBM Corporation.
+ *
+ * GPIO address extension:
+ *    Handle the case where a flash device is mostly addressed using physical
+ *    line and supplemented by GPIOs.  This way you can hook up say a 8MiB flash
+ *    to a 2MiB memory range and use the GPIOs to select a particular range.
+ *
+ *    Copyright © 2000 Nicolas Pitre <nico@cam.org>
+ *    Copyright © 2005-2009 Analog Devices Inc.
  */
 
 #include <linux/module.h>
@@ -30,6 +38,7 @@
 #include <linux/mtd/cfi_endian.h>
 #include <linux/io.h>
 #include <linux/of_device.h>
+#include <linux/gpio/consumer.h>
 
 #include "physmap-gemini.h"
 #include "physmap-versatile.h"
@@ -45,6 +54,9 @@ struct physmap_flash_info {
 	const char * const	*part_types;
 	unsigned int		nparts;
 	const struct mtd_partition *parts;
+	struct gpio_descs	*gpios;
+	unsigned int		gpio_values;
+	unsigned int		win_order;
 };
 
 static int physmap_flash_remove(struct platform_device *dev)
@@ -104,6 +116,119 @@ static void physmap_set_vpp(struct map_info *map, int state)
 	spin_unlock_irqrestore(&info->vpp_lock, flags);
 }
 
+#if IS_ENABLED(CONFIG_MTD_PHYSMAP_GPIO_ADDR)
+static void physmap_set_addr_gpios(struct physmap_flash_info *info,
+				   unsigned long ofs)
+{
+	unsigned int i;
+
+	ofs >>= info->win_order;
+	if (info->gpio_values == ofs)
+		return;
+
+	for (i = 0; i < info->gpios->ndescs; i++) {
+		if ((BIT(i) & ofs) == (BIT(i) & info->gpio_values))
+			continue;
+
+		gpiod_set_value(info->gpios->desc[i], !!(BIT(i) & ofs));
+	}
+}
+
+#define win_mask(order)		(BIT(order) - 1)
+
+static map_word physmap_addr_gpios_read(struct map_info *map,
+					unsigned long ofs)
+{
+	struct platform_device *pdev;
+	struct physmap_flash_info *info;
+	map_word mw;
+	u16 word;
+
+	pdev = (struct platform_device *)map->map_priv_1;
+	info = platform_get_drvdata(pdev);
+	physmap_set_addr_gpios(info, ofs);
+
+	word = readw(map->virt + (ofs & win_mask(info->win_order)));
+	mw.x[0] = word;
+	return mw;
+}
+
+static void physmap_addr_gpios_copy_from(struct map_info *map, void *buf,
+					 unsigned long ofs, ssize_t len)
+{
+	struct platform_device *pdev;
+	struct physmap_flash_info *info;
+
+	pdev = (struct platform_device *)map->map_priv_1;
+	info = platform_get_drvdata(pdev);
+
+	while (len) {
+		unsigned int winofs = ofs & win_mask(info->win_order);
+		unsigned int chunklen = min_t(unsigned int, len,
+					      BIT(info->win_order) - winofs);
+
+		physmap_set_addr_gpios(info, ofs);
+		memcpy_fromio(buf, map->virt + winofs, chunklen);
+		len -= chunklen;
+		buf += chunklen;
+		ofs += chunklen;
+	}
+}
+
+static void physmap_addr_gpios_write(struct map_info *map, map_word mw,
+				     unsigned long ofs)
+{
+	struct platform_device *pdev;
+	struct physmap_flash_info *info;
+	u16 word;
+
+	pdev = (struct platform_device *)map->map_priv_1;
+	info = platform_get_drvdata(pdev);
+	physmap_set_addr_gpios(info, ofs);
+
+	word = mw.x[0];
+	writew(word, map->virt + (ofs & win_mask(info->win_order)));
+}
+
+static void physmap_addr_gpios_copy_to(struct map_info *map, unsigned long ofs,
+				       const void *buf, ssize_t len)
+{
+	struct platform_device *pdev;
+	struct physmap_flash_info *info;
+
+	pdev = (struct platform_device *)map->map_priv_1;
+	info = platform_get_drvdata(pdev);
+
+	while (len) {
+		unsigned int winofs = ofs & win_mask(info->win_order);
+		unsigned int chunklen = min_t(unsigned int, len,
+					      BIT(info->win_order) - winofs);
+
+		physmap_set_addr_gpios(info, ofs);
+		memcpy_toio(map->virt + winofs, buf, chunklen);
+		len -= chunklen;
+		buf += chunklen;
+		ofs += chunklen;
+	}
+}
+
+static int physmap_addr_gpios_map_init(struct map_info *map)
+{
+	map->phys = NO_XIP;
+	map->read = physmap_addr_gpios_read;
+	map->copy_from = physmap_addr_gpios_copy_from;
+	map->write = physmap_addr_gpios_write;
+	map->copy_to = physmap_addr_gpios_copy_to;
+
+	return 0;
+}
+#else
+static int physmap_addr_gpios_map_init(struct map_info *map)
+{
+	return -ENOTSUPP;
+}
+#endif
+
 #if IS_ENABLED(CONFIG_MTD_PHYSMAP_OF)
 static const struct of_device_id of_flash_match[] = {
 	{
@@ -343,6 +468,16 @@ static int physmap_flash_probe(struct platform_device *dev)
 
 	platform_set_drvdata(dev, info);
 
+	info->gpios = devm_gpiod_get_array_optional(&dev->dev, "addr",
+						    GPIOD_OUT_LOW);
+	if (IS_ERR(info->gpios))
+		return PTR_ERR(info->gpios);
+
+	if (info->gpios && info->nmaps > 1) {
+		dev_err(&dev->dev, "addr-gpios only supported for nmaps == 1\n");
+		return -EINVAL;
+	}
+
 	if (dev->dev.of_node)
 		err = physmap_flash_of_init(dev);
 	else
@@ -369,10 +504,20 @@ static int physmap_flash_probe(struct platform_device *dev)
 		if (!info->maps[i].phys)
 			info->maps[i].phys = res->start;
 
-		info->maps[i].size = resource_size(res);
+		info->win_order = get_bitmask_order(resource_size(res)) - 1;
+		info->maps[i].size = BIT(info->win_order +
+					 (info->gpios ?
+					  info->gpios->ndescs : 0));
+
 		info->maps[i].map_priv_1 = (unsigned long)dev;
 
-		simple_map_init(&info->maps[i]);
+		if (info->gpios) {
+			err = physmap_addr_gpios_map_init(&info->maps[i]);
+			if (err)
+				goto err_out;
+		} else {
+			simple_map_init(&info->maps[i]);
+		}
 
 		probe_type = rom_probe_types;
 		if (!info->probe_type) {
@@ -497,6 +642,7 @@ module_exit(physmap_exit);
 MODULE_LICENSE("GPL");
 MODULE_AUTHOR("David Woodhouse <dwmw2@infradead.org>");
 MODULE_AUTHOR("Vitaly Wool <vwool@ru.mvista.com>");
+MODULE_AUTHOR("Mike Frysinger <vapier@gentoo.org>");
 MODULE_DESCRIPTION("Generic configurable MTD map driver");
 
 /* legacy platform drivers can't hotplug or coldplg */

commit 6ca15cfa0788ebef365ce31d1e01ea30a389a895
Author: Boris Brezillon <boris.brezillon@bootlin.com>
Date:   Fri Oct 19 09:49:05 2018 +0200

    mtd: maps: Rename physmap_of_{versatile, gemini} into physmap-{versatile, gemini}
    
    Now that the physmap_of driver is gone, the gemini and versative
    extensions are part of the physmap driver. Rename the source files and
    the config option to reflect this.
    
    Signed-off-by: Boris Brezillon <boris.brezillon@bootlin.com>
    Reviewed-by: Ricardo Ribalda Delgado <ricardo.ribalda@gmail.com>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/mtd/maps/physmap-core.c b/drivers/mtd/maps/physmap-core.c
index 07af8368d173..8a8af37576ff 100644
--- a/drivers/mtd/maps/physmap-core.c
+++ b/drivers/mtd/maps/physmap-core.c
@@ -31,8 +31,8 @@
 #include <linux/io.h>
 #include <linux/of_device.h>
 
-#include "physmap_of_gemini.h"
-#include "physmap_of_versatile.h"
+#include "physmap-gemini.h"
+#include "physmap-versatile.h"
 
 struct physmap_flash_info {
 	unsigned int		nmaps;

commit 642b1e8dbed7bbbf8c4deb3c9a0496f17278badc
Author: Boris Brezillon <boris.brezillon@bootlin.com>
Date:   Fri Oct 19 09:49:04 2018 +0200

    mtd: maps: Merge physmap_of.c into physmap-core.c
    
    There's no real reason to have two separate driver for the DT and pdata
    case. Just do what we do everywhere else and handle DT and pdata
    parsing in the same driver.
    
    Signed-off-by: Boris Brezillon <boris.brezillon@bootlin.com>
    Reviewed-by: Ricardo Ribalda Delgado <ricardo.ribalda@gmail.com>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/mtd/maps/physmap-core.c b/drivers/mtd/maps/physmap-core.c
index e27051bc5dc6..07af8368d173 100644
--- a/drivers/mtd/maps/physmap-core.c
+++ b/drivers/mtd/maps/physmap-core.c
@@ -6,6 +6,13 @@
  * Author: Jun Sun, jsun@mvista.com or jsun@junsun.net
  *
  * 031022 - [jsun] add run-time configure and partition setup
+ *
+ * Device tree support:
+ *    Copyright (C) 2006 MontaVista Software Inc.
+ *    Author: Vitaly Wool <vwool@ru.mvista.com>
+ *
+ *    Revised to handle newer style flash binding by:
+ *    Copyright (C) 2007 David Gibson, IBM Corporation.
  */
 
 #include <linux/module.h>
@@ -20,7 +27,12 @@
 #include <linux/mtd/partitions.h>
 #include <linux/mtd/physmap.h>
 #include <linux/mtd/concat.h>
+#include <linux/mtd/cfi_endian.h>
 #include <linux/io.h>
+#include <linux/of_device.h>
+
+#include "physmap_of_gemini.h"
+#include "physmap_of_versatile.h"
 
 struct physmap_flash_info {
 	unsigned int		nmaps;
@@ -29,6 +41,10 @@ struct physmap_flash_info {
 	struct map_info		*maps;
 	spinlock_t		vpp_lock;
 	int			vpp_refcnt;
+	const char		*probe_type;
+	const char * const	*part_types;
+	unsigned int		nparts;
+	const struct mtd_partition *parts;
 };
 
 static int physmap_flash_remove(struct platform_device *dev)
@@ -41,8 +57,6 @@ static int physmap_flash_remove(struct platform_device *dev)
 	if (!info)
 		return 0;
 
-	physmap_data = dev_get_platdata(&dev->dev);
-
 	if (info->cmtd) {
 		err = mtd_device_unregister(info->cmtd);
 		if (err)
@@ -57,7 +71,8 @@ static int physmap_flash_remove(struct platform_device *dev)
 			map_destroy(info->mtds[i]);
 	}
 
-	if (physmap_data->exit)
+	physmap_data = dev_get_platdata(&dev->dev);
+	if (physmap_data && physmap_data->exit)
 		physmap_data->exit(dev);
 
 	return 0;
@@ -89,6 +104,172 @@ static void physmap_set_vpp(struct map_info *map, int state)
 	spin_unlock_irqrestore(&info->vpp_lock, flags);
 }
 
+#if IS_ENABLED(CONFIG_MTD_PHYSMAP_OF)
+static const struct of_device_id of_flash_match[] = {
+	{
+		.compatible = "cfi-flash",
+		.data = "cfi_probe",
+	},
+	{
+		/*
+		 * FIXME: JEDEC chips can't be safely and reliably
+		 * probed, although the mtd code gets it right in
+		 * practice most of the time.  We should use the
+		 * vendor and device ids specified by the binding to
+		 * bypass the heuristic probe code, but the mtd layer
+		 * provides, at present, no interface for doing so
+		 * :(.
+		 */
+		.compatible = "jedec-flash",
+		.data = "jedec_probe",
+	},
+	{
+		.compatible = "mtd-ram",
+		.data = "map_ram",
+	},
+	{
+		.compatible = "mtd-rom",
+		.data = "map_rom",
+	},
+	{
+		.type = "rom",
+		.compatible = "direct-mapped"
+	},
+	{ /* sentinel */ },
+};
+MODULE_DEVICE_TABLE(of, of_flash_match);
+
+static const char * const of_default_part_probes[] = {
+	"cmdlinepart", "RedBoot", "ofpart", "ofoldpart", NULL
+};
+
+static const char * const *of_get_part_probes(struct platform_device *dev)
+{
+	struct device_node *dp = dev->dev.of_node;
+	const char **res;
+	int count;
+
+	count = of_property_count_strings(dp, "linux,part-probe");
+	if (count < 0)
+		return of_default_part_probes;
+
+	res = devm_kcalloc(&dev->dev, count + 1, sizeof(*res), GFP_KERNEL);
+	if (!res)
+		return NULL;
+
+	count = of_property_read_string_array(dp, "linux,part-probe", res,
+					      count);
+	if (count < 0)
+		return NULL;
+
+	return res;
+}
+
+static const char *of_select_probe_type(struct platform_device *dev)
+{
+	struct device_node *dp = dev->dev.of_node;
+	const struct of_device_id *match;
+	const char *probe_type;
+
+	match = of_match_device(of_flash_match, &dev->dev);
+	probe_type = match->data;
+	if (probe_type)
+		return probe_type;
+
+	dev_warn(&dev->dev,
+		 "Device tree uses obsolete \"direct-mapped\" flash binding\n");
+
+	of_property_read_string(dp, "probe-type", &probe_type);
+	if (!probe_type)
+		return NULL;
+
+	if (!strcmp(probe_type, "CFI")) {
+		probe_type = "cfi_probe";
+	} else if (!strcmp(probe_type, "JEDEC")) {
+		probe_type = "jedec_probe";
+	} else if (!strcmp(probe_type, "ROM")) {
+		probe_type = "map_rom";
+	} else {
+		dev_warn(&dev->dev,
+			 "obsolete_probe: don't know probe type '%s', mapping as rom\n",
+			 probe_type);
+		probe_type = "map_rom";
+	}
+
+	return probe_type;
+}
+
+static int physmap_flash_of_init(struct platform_device *dev)
+{
+	struct physmap_flash_info *info = platform_get_drvdata(dev);
+	struct device_node *dp = dev->dev.of_node;
+	const char *mtd_name = NULL;
+	int err, swap = 0;
+	bool map_indirect;
+	unsigned int i;
+	u32 bankwidth;
+
+	if (!dp)
+		return -EINVAL;
+
+	info->probe_type = of_select_probe_type(dev);
+
+	info->part_types = of_get_part_probes(dev);
+	if (!info->part_types)
+		return -ENOMEM;
+
+	of_property_read_string(dp, "linux,mtd-name", &mtd_name);
+
+	map_indirect = of_property_read_bool(dp, "no-unaligned-direct-access");
+
+	err = of_property_read_u32(dp, "bank-width", &bankwidth);
+	if (err) {
+		dev_err(&dev->dev, "Can't get bank width from device tree\n");
+		return err;
+	}
+
+	if (of_property_read_bool(dp, "big-endian"))
+		swap = CFI_BIG_ENDIAN;
+	else if (of_property_read_bool(dp, "little-endian"))
+		swap = CFI_LITTLE_ENDIAN;
+
+	for (i = 0; i < info->nmaps; i++) {
+		info->maps[i].name = mtd_name;
+		info->maps[i].swap = swap;
+		info->maps[i].bankwidth = bankwidth;
+		info->maps[i].device_node = dp;
+
+		err = of_flash_probe_gemini(dev, dp, &info->maps[i]);
+		if (err)
+			return err;
+
+		err = of_flash_probe_versatile(dev, dp, &info->maps[i]);
+		if (err)
+			return err;
+
+		/*
+		 * On some platforms (e.g. MPC5200) a direct 1:1 mapping
+		 * may cause problems with JFFS2 usage, as the local bus (LPB)
+		 * doesn't support unaligned accesses as implemented in the
+		 * JFFS2 code via memcpy(). By setting NO_XIP, the
+		 * flash will not be exposed directly to the MTD users
+		 * (e.g. JFFS2) any more.
+		 */
+		if (map_indirect)
+			info->maps[i].phys = NO_XIP;
+	}
+
+	return 0;
+}
+#else /* IS_ENABLED(CONFIG_MTD_PHYSMAP_OF) */
+#define of_flash_match NULL
+
+static int physmap_flash_of_init(struct platform_device *dev)
+{
+	return -ENOTSUPP;
+}
+#endif /* IS_ENABLED(CONFIG_MTD_PHYSMAP_OF) */
+
 static const char * const rom_probe_types[] = {
 	"cfi_probe", "jedec_probe", "qinfo_probe", "map_rom", NULL
 };
@@ -97,18 +278,46 @@ static const char * const part_probe_types[] = {
 	"cmdlinepart", "RedBoot", "afs", NULL
 };
 
-static int physmap_flash_probe(struct platform_device *dev)
+static int physmap_flash_pdata_init(struct platform_device *dev)
 {
+	struct physmap_flash_info *info = platform_get_drvdata(dev);
 	struct physmap_flash_data *physmap_data;
+	unsigned int i;
+	int err;
+
+	physmap_data = dev_get_platdata(&dev->dev);
+	if (!physmap_data)
+		return -EINVAL;
+
+	info->probe_type = physmap_data->probe_type;
+	info->part_types = physmap_data->part_probe_types ? : part_probe_types;
+	info->parts = physmap_data->parts;
+	info->nparts = physmap_data->nr_parts;
+
+	if (physmap_data->init) {
+		err = physmap_data->init(dev);
+		if (err)
+			return err;
+	}
+
+	for (i = 0; i < info->nmaps; i++) {
+		info->maps[i].bankwidth = physmap_data->width;
+		info->maps[i].pfow_base = physmap_data->pfow_base;
+		info->maps[i].set_vpp = physmap_set_vpp;
+	}
+
+	return 0;
+}
+
+static int physmap_flash_probe(struct platform_device *dev)
+{
 	struct physmap_flash_info *info;
 	const char * const *probe_type;
-	const char * const *part_types;
 	int err = 0;
 	int i;
 
-	physmap_data = dev_get_platdata(&dev->dev);
-	if (!physmap_data)
-		return -ENODEV;
+	if (!dev->dev.of_node && !dev_get_platdata(&dev->dev))
+		return -EINVAL;
 
 	info = devm_kzalloc(&dev->dev, sizeof(*info), GFP_KERNEL);
 	if (!info)
@@ -132,14 +341,16 @@ static int physmap_flash_probe(struct platform_device *dev)
 	if (!info->mtds)
 		return -ENOMEM;
 
-	if (physmap_data->init) {
-		err = physmap_data->init(dev);
-		if (err)
-			goto err_out;
-	}
-
 	platform_set_drvdata(dev, info);
 
+	if (dev->dev.of_node)
+		err = physmap_flash_of_init(dev);
+	else
+		err = physmap_flash_pdata_init(dev);
+
+	if (err)
+		return err;
+
 	for (i = 0; i < info->nmaps; i++) {
 		struct resource *res;
 
@@ -154,22 +365,22 @@ static int physmap_flash_probe(struct platform_device *dev)
 			   res);
 
 		info->maps[i].name = dev_name(&dev->dev);
-		info->maps[i].phys = res->start;
+
+		if (!info->maps[i].phys)
+			info->maps[i].phys = res->start;
+
 		info->maps[i].size = resource_size(res);
-		info->maps[i].bankwidth = physmap_data->width;
-		info->maps[i].set_vpp = physmap_set_vpp;
-		info->maps[i].pfow_base = physmap_data->pfow_base;
 		info->maps[i].map_priv_1 = (unsigned long)dev;
 
 		simple_map_init(&info->maps[i]);
 
 		probe_type = rom_probe_types;
-		if (!physmap_data->probe_type) {
+		if (!info->probe_type) {
 			for (; !info->mtds[i] && *probe_type; probe_type++)
 				info->mtds[i] = do_map_probe(*probe_type,
 							     &info->maps[i]);
 		} else {
-			info->mtds[i] = do_map_probe(physmap_data->probe_type,
+			info->mtds[i] = do_map_probe(info->probe_type,
 						     &info->maps[i]);
 		}
 
@@ -197,11 +408,9 @@ static int physmap_flash_probe(struct platform_device *dev)
 
 	spin_lock_init(&info->vpp_lock);
 
-	part_types = physmap_data->part_probe_types ? : part_probe_types;
-
-	err = mtd_device_parse_register(info->cmtd, part_types, NULL,
-					physmap_data->parts,
-					physmap_data->nr_parts);
+	mtd_set_of_node(info->cmtd, dev->dev.of_node);
+	err = mtd_device_parse_register(info->cmtd, info->part_types, NULL,
+					info->parts, info->nparts);
 	if (err)
 		goto err_out;
 
@@ -232,6 +441,7 @@ static struct platform_driver physmap_flash_driver = {
 	.shutdown	= physmap_flash_shutdown,
 	.driver		= {
 		.name	= "physmap-flash",
+		.of_match_table = of_flash_match,
 	},
 };
 
@@ -286,6 +496,7 @@ module_exit(physmap_exit);
 
 MODULE_LICENSE("GPL");
 MODULE_AUTHOR("David Woodhouse <dwmw2@infradead.org>");
+MODULE_AUTHOR("Vitaly Wool <vwool@ru.mvista.com>");
 MODULE_DESCRIPTION("Generic configurable MTD map driver");
 
 /* legacy platform drivers can't hotplug or coldplg */

commit 0c3def9b58d85ea8a8a8773d1151d8d554842d0a
Author: Boris Brezillon <boris.brezillon@bootlin.com>
Date:   Fri Oct 19 09:49:03 2018 +0200

    mtd: maps: Prepare merging of physmap and physmap_of
    
    We want to merge the physmap and physmap_of driver, but before we can
    do that we must prepare things to create physmap.o out of several .c
    files. Rename physmap.c into physmap-core.c and add a new Makefile
    rule to create physmap.o (right now it only contains physmap-core.o).
    
    Signed-off-by: Boris Brezillon <boris.brezillon@bootlin.com>
    Reviewed-by: Ricardo Ribalda Delgado <ricardo.ribalda@gmail.com>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/mtd/maps/physmap-core.c b/drivers/mtd/maps/physmap-core.c
new file mode 100644
index 000000000000..e27051bc5dc6
--- /dev/null
+++ b/drivers/mtd/maps/physmap-core.c
@@ -0,0 +1,295 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Normal mappings of chips in physical memory
+ *
+ * Copyright (C) 2003 MontaVista Software Inc.
+ * Author: Jun Sun, jsun@mvista.com or jsun@junsun.net
+ *
+ * 031022 - [jsun] add run-time configure and partition setup
+ */
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/device.h>
+#include <linux/platform_device.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+#include <linux/mtd/physmap.h>
+#include <linux/mtd/concat.h>
+#include <linux/io.h>
+
+struct physmap_flash_info {
+	unsigned int		nmaps;
+	struct mtd_info		**mtds;
+	struct mtd_info		*cmtd;
+	struct map_info		*maps;
+	spinlock_t		vpp_lock;
+	int			vpp_refcnt;
+};
+
+static int physmap_flash_remove(struct platform_device *dev)
+{
+	struct physmap_flash_info *info;
+	struct physmap_flash_data *physmap_data;
+	int i, err;
+
+	info = platform_get_drvdata(dev);
+	if (!info)
+		return 0;
+
+	physmap_data = dev_get_platdata(&dev->dev);
+
+	if (info->cmtd) {
+		err = mtd_device_unregister(info->cmtd);
+		if (err)
+			return err;
+
+		if (info->cmtd != info->mtds[0])
+			mtd_concat_destroy(info->cmtd);
+	}
+
+	for (i = 0; i < info->nmaps; i++) {
+		if (info->mtds[i])
+			map_destroy(info->mtds[i]);
+	}
+
+	if (physmap_data->exit)
+		physmap_data->exit(dev);
+
+	return 0;
+}
+
+static void physmap_set_vpp(struct map_info *map, int state)
+{
+	struct platform_device *pdev;
+	struct physmap_flash_data *physmap_data;
+	struct physmap_flash_info *info;
+	unsigned long flags;
+
+	pdev = (struct platform_device *)map->map_priv_1;
+	physmap_data = dev_get_platdata(&pdev->dev);
+
+	if (!physmap_data->set_vpp)
+		return;
+
+	info = platform_get_drvdata(pdev);
+
+	spin_lock_irqsave(&info->vpp_lock, flags);
+	if (state) {
+		if (++info->vpp_refcnt == 1)    /* first nested 'on' */
+			physmap_data->set_vpp(pdev, 1);
+	} else {
+		if (--info->vpp_refcnt == 0)    /* last nested 'off' */
+			physmap_data->set_vpp(pdev, 0);
+	}
+	spin_unlock_irqrestore(&info->vpp_lock, flags);
+}
+
+static const char * const rom_probe_types[] = {
+	"cfi_probe", "jedec_probe", "qinfo_probe", "map_rom", NULL
+};
+
+static const char * const part_probe_types[] = {
+	"cmdlinepart", "RedBoot", "afs", NULL
+};
+
+static int physmap_flash_probe(struct platform_device *dev)
+{
+	struct physmap_flash_data *physmap_data;
+	struct physmap_flash_info *info;
+	const char * const *probe_type;
+	const char * const *part_types;
+	int err = 0;
+	int i;
+
+	physmap_data = dev_get_platdata(&dev->dev);
+	if (!physmap_data)
+		return -ENODEV;
+
+	info = devm_kzalloc(&dev->dev, sizeof(*info), GFP_KERNEL);
+	if (!info)
+		return -ENOMEM;
+
+	while (platform_get_resource(dev, IORESOURCE_MEM, info->nmaps))
+		info->nmaps++;
+
+	if (!info->nmaps)
+		return -ENODEV;
+
+	info->maps = devm_kzalloc(&dev->dev,
+				  sizeof(*info->maps) * info->nmaps,
+				  GFP_KERNEL);
+	if (!info->maps)
+		return -ENOMEM;
+
+	info->mtds = devm_kzalloc(&dev->dev,
+				  sizeof(*info->mtds) * info->nmaps,
+				  GFP_KERNEL);
+	if (!info->mtds)
+		return -ENOMEM;
+
+	if (physmap_data->init) {
+		err = physmap_data->init(dev);
+		if (err)
+			goto err_out;
+	}
+
+	platform_set_drvdata(dev, info);
+
+	for (i = 0; i < info->nmaps; i++) {
+		struct resource *res;
+
+		res = platform_get_resource(dev, IORESOURCE_MEM, i);
+		info->maps[i].virt = devm_ioremap_resource(&dev->dev, res);
+		if (IS_ERR(info->maps[i].virt)) {
+			err = PTR_ERR(info->maps[i].virt);
+			goto err_out;
+		}
+
+		dev_notice(&dev->dev, "physmap platform flash device: %pR\n",
+			   res);
+
+		info->maps[i].name = dev_name(&dev->dev);
+		info->maps[i].phys = res->start;
+		info->maps[i].size = resource_size(res);
+		info->maps[i].bankwidth = physmap_data->width;
+		info->maps[i].set_vpp = physmap_set_vpp;
+		info->maps[i].pfow_base = physmap_data->pfow_base;
+		info->maps[i].map_priv_1 = (unsigned long)dev;
+
+		simple_map_init(&info->maps[i]);
+
+		probe_type = rom_probe_types;
+		if (!physmap_data->probe_type) {
+			for (; !info->mtds[i] && *probe_type; probe_type++)
+				info->mtds[i] = do_map_probe(*probe_type,
+							     &info->maps[i]);
+		} else {
+			info->mtds[i] = do_map_probe(physmap_data->probe_type,
+						     &info->maps[i]);
+		}
+
+		if (!info->mtds[i]) {
+			dev_err(&dev->dev, "map_probe failed\n");
+			err = -ENXIO;
+			goto err_out;
+		}
+		info->mtds[i]->dev.parent = &dev->dev;
+	}
+
+	if (info->nmaps == 1) {
+		info->cmtd = info->mtds[0];
+	} else {
+		/*
+		 * We detected multiple devices. Concatenate them together.
+		 */
+		info->cmtd = mtd_concat_create(info->mtds, info->nmaps,
+					       dev_name(&dev->dev));
+		if (!info->cmtd)
+			err = -ENXIO;
+	}
+	if (err)
+		goto err_out;
+
+	spin_lock_init(&info->vpp_lock);
+
+	part_types = physmap_data->part_probe_types ? : part_probe_types;
+
+	err = mtd_device_parse_register(info->cmtd, part_types, NULL,
+					physmap_data->parts,
+					physmap_data->nr_parts);
+	if (err)
+		goto err_out;
+
+	return 0;
+
+err_out:
+	physmap_flash_remove(dev);
+	return err;
+}
+
+#ifdef CONFIG_PM
+static void physmap_flash_shutdown(struct platform_device *dev)
+{
+	struct physmap_flash_info *info = platform_get_drvdata(dev);
+	int i;
+
+	for (i = 0; i < info->nmaps && info->mtds[i]; i++)
+		if (mtd_suspend(info->mtds[i]) == 0)
+			mtd_resume(info->mtds[i]);
+}
+#else
+#define physmap_flash_shutdown NULL
+#endif
+
+static struct platform_driver physmap_flash_driver = {
+	.probe		= physmap_flash_probe,
+	.remove		= physmap_flash_remove,
+	.shutdown	= physmap_flash_shutdown,
+	.driver		= {
+		.name	= "physmap-flash",
+	},
+};
+
+#ifdef CONFIG_MTD_PHYSMAP_COMPAT
+static struct physmap_flash_data physmap_flash_data = {
+	.width		= CONFIG_MTD_PHYSMAP_BANKWIDTH,
+};
+
+static struct resource physmap_flash_resource = {
+	.start		= CONFIG_MTD_PHYSMAP_START,
+	.end		= CONFIG_MTD_PHYSMAP_START + CONFIG_MTD_PHYSMAP_LEN - 1,
+	.flags		= IORESOURCE_MEM,
+};
+
+static struct platform_device physmap_flash = {
+	.name		= "physmap-flash",
+	.id		= 0,
+	.dev		= {
+		.platform_data	= &physmap_flash_data,
+	},
+	.num_resources	= 1,
+	.resource	= &physmap_flash_resource,
+};
+#endif
+
+static int __init physmap_init(void)
+{
+	int err;
+
+	err = platform_driver_register(&physmap_flash_driver);
+#ifdef CONFIG_MTD_PHYSMAP_COMPAT
+	if (err == 0) {
+		err = platform_device_register(&physmap_flash);
+		if (err)
+			platform_driver_unregister(&physmap_flash_driver);
+	}
+#endif
+
+	return err;
+}
+
+static void __exit physmap_exit(void)
+{
+#ifdef CONFIG_MTD_PHYSMAP_COMPAT
+	platform_device_unregister(&physmap_flash);
+#endif
+	platform_driver_unregister(&physmap_flash_driver);
+}
+
+module_init(physmap_init);
+module_exit(physmap_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("David Woodhouse <dwmw2@infradead.org>");
+MODULE_DESCRIPTION("Generic configurable MTD map driver");
+
+/* legacy platform drivers can't hotplug or coldplg */
+#ifndef CONFIG_MTD_PHYSMAP_COMPAT
+/* work with hotplug and coldplug */
+MODULE_ALIAS("platform:physmap-flash");
+#endif
