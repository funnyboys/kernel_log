commit 694b5a5d313f3997764b67d52bab66ec7e59e714
Merge: 587f17018a2c d2353bad2c1e
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Jun 4 19:47:11 2020 -0700

    Merge tag 'arm-soc-5.8' of git://git.kernel.org/pub/scm/linux/kernel/git/soc/soc
    
    Pull ARM SoC updates from Arnd Bergmann:
     "One new platform gets added, the Realtek RTD1195, which is an older
      Cortex-a7 based relative of the RTD12xx chips that are already
      supported in arch/arm64. The platform may also be extended to support
      running 32-bit kernels on those 64-bit chips for memory-constrained
      machines.
    
      In the Renesas shmobile platform, we gain support for "RZ/G1H" or
      R8A7742, an eight-core chip based on Cortex-A15 and Cortex-A7 cores,
      originally released in 2016 as one of the last high-end 32-bit
      designs.
    
      There is ongoing cleanup for the integrator, tegra, imx, and omap2
      platforms, with integrator getting very close to the goal of having
      zero code in arch/arm/, and omap2 moving more of the chip specifics
      from old board code into device tree files.
    
      The Versatile Express platform is made more modular, with built-in
      drivers now becoming loadable modules. This is part of a greater
      effort for the Android OS to have a common kernel binary for all
      platforms and any platform specific code in loadable modules.
    
      The PXA platform drops support for Compulab's pxa2xx boards that had
      rather unusual flash and PCI drivers but no known users remaining. All
      device drivers specific to those boards can now get removed as well.
    
      Across platforms, there is ongoing cleanup, with Geert and Rob
      revisiting some a lot of Kconfig options"
    
    * tag 'arm-soc-5.8' of git://git.kernel.org/pub/scm/linux/kernel/git/soc/soc: (94 commits)
      ARM: omap2: fix omap5_realtime_timer_init definition
      ARM: zynq: Don't select CONFIG_ICST
      ARM: OMAP2+: Fix regression for using local timer on non-SMP SoCs
      clk: versatile: Fix kconfig dependency on COMMON_CLK_VERSATILE
      ARM: davinci: fix build failure without I2C
      power: reset: vexpress: fix build issue
      power: vexpress: cleanup: use builtin_platform_driver
      power: vexpress: add suppress_bind_attrs to true
      Revert "ARM: vexpress: Don't select VEXPRESS_CONFIG"
      MAINTAINERS: pxa: remove Compulab arm/pxa support
      ARM: pxa: remove Compulab pxa2xx boards
      bus: arm-integrator-lm: Fix return value check in integrator_ap_lm_probe()
      soc: imx: move cpu code to drivers/soc/imx
      ARM: imx: move cpu definitions into a header
      ARM: imx: use device_initcall for imx_soc_device_init
      ARM: imx: pcm037: make pcm970_sja1000_platform_data static
      bus: ti-sysc: Timers no longer need legacy quirk handling
      ARM: OMAP2+: Drop old timer code for dmtimer and 32k counter
      ARM: dts: Configure system timers for omap2
      ARM: dts: Configure system timers for ti81xx
      ...

commit 039599c92d3b2e73689e8b6e519d653fd4770abb
Author: Rob Herring <robh@kernel.org>
Date:   Wed Apr 29 15:58:12 2020 -0500

    amba: Retry adding deferred devices at late_initcall
    
    If amba bus devices defer when adding, the amba bus code simply retries
    adding the devices every 5 seconds. This doesn't work well as it
    completely unsynchronized with starting the init process which can
    happen in less than 5 secs. Add a retry during late_initcall. If the
    amba devices are added, then deferred probe takes over. If the
    dependencies have not probed at this point, then there's no improvement
    over previous behavior. To completely solve this, we'd need to retry
    after every successful probe as deferred probe does.
    
    The list_empty() check now happens outside the mutex, but the mutex
    wasn't necessary in the first place.
    
    This needed to use deferred probe instead of fragile initcall ordering
    on 32-bit VExpress systems where the apb_pclk has a number of probe
    dependencies (vexpress-sysregs, vexpress-config).
    
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: Saravana Kannan <saravanak@google.com>
    Cc: Nicolas Saenz Julienne <nsaenzjulienne@suse.de>
    Cc: Geert Uytterhoeven <geert+renesas@glider.be>
    Cc: Russell King <linux@armlinux.org.uk>
    Tested-by: Sudeep Holla <sudeep.holla@arm.com>
    Reviewed-by: Sudeep Holla <sudeep.holla@arm.com>
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/drivers/amba/bus.c b/drivers/amba/bus.c
index fe1523664816..e797995fc65b 100644
--- a/drivers/amba/bus.c
+++ b/drivers/amba/bus.c
@@ -505,7 +505,7 @@ static DECLARE_DELAYED_WORK(deferred_retry_work, amba_deferred_retry_func);
 
 #define DEFERRED_DEVICE_TIMEOUT (msecs_to_jiffies(5 * 1000))
 
-static void amba_deferred_retry_func(struct work_struct *dummy)
+static int amba_deferred_retry(void)
 {
 	struct deferred_device *ddev, *tmp;
 
@@ -521,11 +521,19 @@ static void amba_deferred_retry_func(struct work_struct *dummy)
 		kfree(ddev);
 	}
 
+	mutex_unlock(&deferred_devices_lock);
+
+	return 0;
+}
+late_initcall(amba_deferred_retry);
+
+static void amba_deferred_retry_func(struct work_struct *dummy)
+{
+	amba_deferred_retry();
+
 	if (!list_empty(&deferred_devices))
 		schedule_delayed_work(&deferred_retry_work,
 				      DEFERRED_DEVICE_TIMEOUT);
-
-	mutex_unlock(&deferred_devices_lock);
 }
 
 /**

commit f458488425f1cc9a396aa1d09bb00c48783936da
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Wed Apr 22 12:10:13 2020 +0200

    amba: Initialize dma_parms for amba devices
    
    It's currently the amba driver's responsibility to initialize the pointer,
    dma_parms, for its corresponding struct device. The benefit with this
    approach allows us to avoid the initialization and to not waste memory for
    the struct device_dma_parameters, as this can be decided on a case by case
    basis.
    
    However, it has turned out that this approach is not very practical. Not
    only does it lead to open coding, but also to real errors. In principle
    callers of dma_set_max_seg_size() doesn't check the error code, but just
    assumes it succeeds.
    
    For these reasons, let's do the initialization from the common amba bus at
    the device registration point. This also follows the way the PCI devices
    are being managed, see pci_device_add().
    
    Suggested-by: Christoph Hellwig <hch@lst.de>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: <stable@vger.kernel.org>
    Tested-by: Haibo Chen <haibo.chen@nxp.com>
    Reviewed-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Link: https://lore.kernel.org/r/20200422101013.31267-1-ulf.hansson@linaro.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/amba/bus.c b/drivers/amba/bus.c
index fe1523664816..8558b629880b 100644
--- a/drivers/amba/bus.c
+++ b/drivers/amba/bus.c
@@ -645,6 +645,7 @@ static void amba_device_initialize(struct amba_device *dev, const char *name)
 	dev->dev.release = amba_device_release;
 	dev->dev.bus = &amba_bustype;
 	dev->dev.dma_mask = &dev->dev.coherent_dma_mask;
+	dev->dev.dma_parms = &dev->dma_parms;
 	dev->res.name = dev_name(&dev->dev);
 }
 

commit e963408e8ff439e2b9da20e5399d7dca21462fcc
Author: Russell King <rmk+kernel@armlinux.org.uk>
Date:   Wed Oct 2 17:45:11 2019 +0100

    drivers/amba: fix reset control error handling
    
    With commit 79bdcb202a35 ("ARM: 8906/1: drivers/amba: add reset control
    to amba bus probe") it is possible for the the amba bus driver to defer
    probing the device for its IDs because the reset driver may be probed
    later.
    
    However when a subsequent probe occurs, the call to request_resource()
    in the driver returns -EBUSY as the driver has not released the resource
    from the initial probe attempt - or cleaned up any of the preceding
    actions.
    
    Fix this both for the deferred probe case as well as a failure to get
    the reset.
    
    Fixes: 79bdcb202a35 ("ARM: 8906/1: drivers/amba: add reset control to amba bus probe")
    Reported-by: Dinh Nguyen <dinguyen@kernel.org>
    Tested-by: Dinh Nguyen <dinguyen@kernel.org>
    Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>

diff --git a/drivers/amba/bus.c b/drivers/amba/bus.c
index f39f075abff9..fe1523664816 100644
--- a/drivers/amba/bus.c
+++ b/drivers/amba/bus.c
@@ -409,9 +409,11 @@ static int amba_device_try_add(struct amba_device *dev, struct resource *parent)
 		 */
 		rstc = of_reset_control_array_get_optional_shared(dev->dev.of_node);
 		if (IS_ERR(rstc)) {
-			if (PTR_ERR(rstc) != -EPROBE_DEFER)
-				dev_err(&dev->dev, "Can't get amba reset!\n");
-			return PTR_ERR(rstc);
+			ret = PTR_ERR(rstc);
+			if (ret != -EPROBE_DEFER)
+				dev_err(&dev->dev, "can't get reset: %d\n",
+					ret);
+			goto err_reset;
 		}
 		reset_control_deassert(rstc);
 		reset_control_put(rstc);
@@ -472,6 +474,12 @@ static int amba_device_try_add(struct amba_device *dev, struct resource *parent)
 	release_resource(&dev->res);
  err_out:
 	return ret;
+
+ err_reset:
+	amba_put_disable_pclk(dev);
+	iounmap(tmp);
+	dev_pm_domain_detach(&dev->dev, true);
+	goto err_release;
 }
 
 /*

commit 79bdcb202a35bf2701779afafa0db07e2852d46b
Author: DINH L NGUYEN <dinguyen@kernel.org>
Date:   Wed Sep 4 02:13:08 2019 +0100

    ARM: 8906/1: drivers/amba: add reset control to amba bus probe
    
    The primecell controller on some SoCs, i.e. SoCFPGA, is held in reset
    by default. Until recently, the DMA controller was brought out of reset by the bootloader(i.e. U-Boot). But a recent change in U-Boot, the peripherals that are not used are held in reset and are left to Linux to bring them out of reset.
    
    Add a mechanism for getting the reset property and de-assert the primecell module from reset if found. This is a not a hard fail if the reset property is not present in the device tree node, so the driver will continue to probe.
    
    Because there are different variants of the controller that may have
    multiple reset signals, the code will find all reset(s) specified and
    de-assert them.
    
    Signed-off-by: Dinh Nguyen <dinguyen@kernel.org>
    Reviewed-by: Rob Herring <robh@kernel.org>
    Reviewed-by: Philipp Zabel <p.zabel@pengutronix.de>
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>

diff --git a/drivers/amba/bus.c b/drivers/amba/bus.c
index 100e798a5c82..f39f075abff9 100644
--- a/drivers/amba/bus.c
+++ b/drivers/amba/bus.c
@@ -18,6 +18,7 @@
 #include <linux/limits.h>
 #include <linux/clk/clk-conf.h>
 #include <linux/platform_device.h>
+#include <linux/reset.h>
 
 #include <asm/irq.h>
 
@@ -401,6 +402,19 @@ static int amba_device_try_add(struct amba_device *dev, struct resource *parent)
 	ret = amba_get_enable_pclk(dev);
 	if (ret == 0) {
 		u32 pid, cid;
+		struct reset_control *rstc;
+
+		/*
+		 * Find reset control(s) of the amba bus and de-assert them.
+		 */
+		rstc = of_reset_control_array_get_optional_shared(dev->dev.of_node);
+		if (IS_ERR(rstc)) {
+			if (PTR_ERR(rstc) != -EPROBE_DEFER)
+				dev_err(&dev->dev, "Can't get amba reset!\n");
+			return PTR_ERR(rstc);
+		}
+		reset_control_deassert(rstc);
+		reset_control_put(rstc);
 
 		/*
 		 * Read pid and cid based on size of resource

commit d2912cb15bdda8ba4a5dd73396ad62641af2f520
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jun 4 10:11:33 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 500
    
    Based on 2 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation #
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 4122 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Enrico Weigelt <info@metux.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190604081206.933168790@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/amba/bus.c b/drivers/amba/bus.c
index b4dae624b9af..100e798a5c82 100644
--- a/drivers/amba/bus.c
+++ b/drivers/amba/bus.c
@@ -1,11 +1,8 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  *  linux/arch/arm/common/amba.c
  *
  *  Copyright (C) 2003 Deep Blue Solutions Ltd, All Rights Reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
  */
 #include <linux/module.h>
 #include <linux/init.h>

commit 4a2910fa80d75dbe18d822482a48ae50a218029c
Author: Mike Leach <mike.leach@linaro.org>
Date:   Wed Feb 13 14:41:50 2019 +0100

    ARM: 8836/1: drivers: amba: Update component matching to use the CoreSight UCI values.
    
    The patches provide an update of amba_device and matching code to handle
    the additional registers required for the Class 0x9 (CoreSight) UCI.
    
    The *data pointer in the amba_id is used by the driver to provide extended
    ID register values for matching.
    
    CoreSight components where PID/CID pair is currently sufficient for
    unique identification need not provide this additional information.
    
    Signed-off-by: Mike Leach <mike.leach@linaro.org>
    Reviewed-by: Mathieu Poirier <mathieu.poirier@linaro.org>
    Reviewed-by: Suzuki K Poulose <suzuki.poulose@arm.com>
    Tested-by: Sai Prakash Ranjan <saiprakash.ranjan@codeaurora.org>
    Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>

diff --git a/drivers/amba/bus.c b/drivers/amba/bus.c
index 41b706403ef7..b4dae624b9af 100644
--- a/drivers/amba/bus.c
+++ b/drivers/amba/bus.c
@@ -26,19 +26,36 @@
 
 #define to_amba_driver(d)	container_of(d, struct amba_driver, drv)
 
-static const struct amba_id *
-amba_lookup(const struct amba_id *table, struct amba_device *dev)
+/* called on periphid match and class 0x9 coresight device. */
+static int
+amba_cs_uci_id_match(const struct amba_id *table, struct amba_device *dev)
 {
 	int ret = 0;
+	struct amba_cs_uci_id *uci;
+
+	uci = table->data;
 
+	/* no table data or zero mask - return match on periphid */
+	if (!uci || (uci->devarch_mask == 0))
+		return 1;
+
+	/* test against read devtype and masked devarch value */
+	ret = (dev->uci.devtype == uci->devtype) &&
+		((dev->uci.devarch & uci->devarch_mask) == uci->devarch);
+	return ret;
+}
+
+static const struct amba_id *
+amba_lookup(const struct amba_id *table, struct amba_device *dev)
+{
 	while (table->mask) {
-		ret = (dev->periphid & table->mask) == table->id;
-		if (ret)
-			break;
+		if (((dev->periphid & table->mask) == table->id) &&
+			((dev->cid != CORESIGHT_CID) ||
+			 (amba_cs_uci_id_match(table, dev))))
+			return table;
 		table++;
 	}
-
-	return ret ? table : NULL;
+	return NULL;
 }
 
 static int amba_match(struct device *dev, struct device_driver *drv)
@@ -399,10 +416,22 @@ static int amba_device_try_add(struct amba_device *dev, struct resource *parent)
 			cid |= (readl(tmp + size - 0x10 + 4 * i) & 255) <<
 				(i * 8);
 
+		if (cid == CORESIGHT_CID) {
+			/* set the base to the start of the last 4k block */
+			void __iomem *csbase = tmp + size - 4096;
+
+			dev->uci.devarch =
+				readl(csbase + UCI_REG_DEVARCH_OFFSET);
+			dev->uci.devtype =
+				readl(csbase + UCI_REG_DEVTYPE_OFFSET) & 0xff;
+		}
+
 		amba_put_disable_pclk(dev);
 
-		if (cid == AMBA_CID || cid == CORESIGHT_CID)
+		if (cid == AMBA_CID || cid == CORESIGHT_CID) {
 			dev->periphid = pid;
+			dev->cid = cid;
+		}
 
 		if (!dev->periphid)
 			ret = -ENODEV;

commit 311da4975894aab7a4bb94aa83f38f052d7ffda4
Merge: ca95bf62fcf5 0ac000e86703
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Jun 6 13:49:25 2018 -0700

    Merge branch 'for-linus' of git://git.armlinux.org.uk/~rmk/linux-arm
    
    Pull ARM updates from Russell King:
    
     - Initial round of Spectre variant 1 and variant 2 fixes for 32-bit ARM
    
     - Clang support improvements
    
     - nommu updates for v8 MPU
    
     - enable ARM_MODULE_PLTS by default to avoid problems loading modules
       with larger kernels
    
     - vmlinux.lds and dma-mapping cleanups
    
    * 'for-linus' of git://git.armlinux.org.uk/~rmk/linux-arm: (31 commits)
      ARM: spectre-v1: fix syscall entry
      ARM: spectre-v1: add array_index_mask_nospec() implementation
      ARM: spectre-v1: add speculation barrier (csdb) macros
      ARM: KVM: report support for SMCCC_ARCH_WORKAROUND_1
      ARM: KVM: Add SMCCC_ARCH_WORKAROUND_1 fast handling
      ARM: spectre-v2: KVM: invalidate icache on guest exit for Brahma B15
      ARM: KVM: invalidate icache on guest exit for Cortex-A15
      ARM: KVM: invalidate BTB on guest exit for Cortex-A12/A17
      ARM: spectre-v2: warn about incorrect context switching functions
      ARM: spectre-v2: add firmware based hardening
      ARM: spectre-v2: harden user aborts in kernel space
      ARM: spectre-v2: add Cortex A8 and A15 validation of the IBE bit
      ARM: spectre-v2: harden branch predictor on context switches
      ARM: spectre: add Kconfig symbol for CPUs vulnerable to Spectre
      ARM: bugs: add support for per-processor bug checking
      ARM: bugs: hook processor bug checking into SMP and suspend paths
      ARM: bugs: prepare processor bug infrastructure
      ARM: add more CPU part numbers for Cortex and Brahma B15 CPUs
      ARM: 8774/1: remove no-op macro VMLINUX_SYMBOL()
      ARM: 8773/1: amba: Export amba_bustype
      ...

commit abf7dba7c4f77d781f6df50fefb19a64c5dc331f
Merge: 07c4dd3435aa b23220fe054e
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Jun 5 16:20:22 2018 -0700

    Merge tag 'char-misc-4.18-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/char-misc
    
    Pull char/misc driver updates from Greg KH:
     "Here is the "big" char and misc driver patches for 4.18-rc1.
    
      It's not a lot of stuff here, but there are some highlights:
    
       - coreboot driver updates
    
       - soundwire driver updates
    
       - android binder updates
    
       - fpga big sync, mostly documentation
    
       - lots of minor driver updates
    
      All of these have been in linux-next for a while with no reported
      issues"
    
    * tag 'char-misc-4.18-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/char-misc: (81 commits)
      vmw_balloon: fixing double free when batching mode is off
      MAINTAINERS: Add driver-api/fpga path
      fpga: clarify that unregister functions also free
      documentation: fpga: move fpga-region.txt to driver-api
      documentation: fpga: add bridge document to driver-api
      documentation: fpga: move fpga-mgr.txt to driver-api
      Documentation: fpga: move fpga overview to driver-api
      fpga: region: kernel-doc fixes
      fpga: bridge: kernel-doc fixes
      fpga: mgr: kernel-doc fixes
      fpga: use SPDX
      fpga: region: change api, add fpga_region_create/free
      fpga: bridge: change api, don't use drvdata
      fpga: manager: change api, don't use drvdata
      fpga: region: don't use drvdata in common fpga code
      Drivers: hv: vmbus: Removed an unnecessary cast from void *
      ver_linux: Drop redundant calls to system() to test if file is readable
      ver_linux: Move stderr redirection from function parameter to function body
      misc: IBM Virtual Management Channel Driver (VMC)
      rpmsg: Correct support for MODULE_DEVICE_TABLE()
      ...

commit 3c89adb0d11117f64d5b501730be7fb2bf53a479
Merge: 11e7c2188061 a24e16b1310c
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Jun 5 09:38:39 2018 -0700

    Merge tag 'pm-4.18-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm
    
    Pull power management updates from Rafael Wysocki:
     "These include a significant update of the generic power domains
      (genpd) and Operating Performance Points (OPP) frameworks, mostly
      related to the introduction of power domain performance levels,
      cpufreq updates (new driver for Qualcomm Kryo processors, updates of
      the existing drivers, some core fixes, schedutil governor
      improvements), PCI power management fixes, ACPI workaround for
      EC-based wakeup events handling on resume from suspend-to-idle, and
      major updates of the turbostat and pm-graph utilities.
    
      Specifics:
    
       - Introduce power domain performance levels into the the generic
         power domains (genpd) and Operating Performance Points (OPP)
         frameworks (Viresh Kumar, Rajendra Nayak, Dan Carpenter).
    
       - Fix two issues in the runtime PM framework related to the
         initialization and removal of devices using device links (Ulf
         Hansson).
    
       - Clean up the initialization of drivers for devices in PM domains
         (Ulf Hansson, Geert Uytterhoeven).
    
       - Fix a cpufreq core issue related to the policy sysfs interface
         causing CPU online to fail for CPUs sharing one cpufreq policy in
         some situations (Tao Wang).
    
       - Make it possible to use platform-specific suspend/resume hooks in
         the cpufreq-dt driver and make the Armada 37xx DVFS use that
         feature (Viresh Kumar, Miquel Raynal).
    
       - Optimize policy transition notifications in cpufreq (Viresh Kumar).
    
       - Improve the iowait boost mechanism in the schedutil cpufreq
         governor (Patrick Bellasi).
    
       - Improve the handling of deferred frequency updates in the schedutil
         cpufreq governor (Joel Fernandes, Dietmar Eggemann, Rafael Wysocki,
         Viresh Kumar).
    
       - Add a new cpufreq driver for Qualcomm Kryo (Ilia Lin).
    
       - Fix and clean up some cpufreq drivers (Colin Ian King, Dmitry
         Osipenko, Doug Smythies, Luc Van Oostenryck, Simon Horman, Viresh
         Kumar).
    
       - Fix the handling of PCI devices with the DPM_SMART_SUSPEND flag set
         and update stale comments in the PCI core PM code (Rafael Wysocki).
    
       - Work around an issue related to the handling of EC-based wakeup
         events in the ACPI PM core during resume from suspend-to-idle if
         the EC has been put into the low-power mode (Rafael Wysocki).
    
       - Improve the handling of wakeup source objects in the PM core (Doug
         Berger, Mahendran Ganesh, Rafael Wysocki).
    
       - Update the driver core to prevent deferred probe from breaking
         suspend/resume ordering (Feng Kan).
    
       - Clean up the PM core somewhat (Bjorn Helgaas, Ulf Hansson, Rafael
         Wysocki).
    
       - Make the core suspend/resume code and cpufreq support the RT patch
         (Sebastian Andrzej Siewior, Thomas Gleixner).
    
       - Consolidate the PM QoS handling in cpuidle governors (Rafael
         Wysocki).
    
       - Fix a possible crash in the hibernation core (Tetsuo Handa).
    
       - Update the rockchip-io Adaptive Voltage Scaling (AVS) driver (David
         Wu).
    
       - Update the turbostat utility (fixes, cleanups, new CPU IDs, new
         command line options, built-in "Low Power Idle" counters support,
         new POLL and POLL% columns) and add an entry for it to MAINTAINERS
         (Len Brown, Artem Bityutskiy, Chen Yu, Laura Abbott, Matt Turner,
         Prarit Bhargava, Srinivas Pandruvada).
    
       - Update the pm-graph to version 5.1 (Todd Brandt).
    
       - Update the intel_pstate_tracer utility (Doug Smythies)"
    
    * tag 'pm-4.18-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm: (128 commits)
      tools/power turbostat: update version number
      tools/power turbostat: Add Node in output
      tools/power turbostat: add node information into turbostat calculations
      tools/power turbostat: remove num_ from cpu_topology struct
      tools/power turbostat: rename num_cores_per_pkg to num_cores_per_node
      tools/power turbostat: track thread ID in cpu_topology
      tools/power turbostat: Calculate additional node information for a package
      tools/power turbostat: Fix node and siblings lookup data
      tools/power turbostat: set max_num_cpus equal to the cpumask length
      tools/power turbostat: if --num_iterations, print for specific number of iterations
      tools/power turbostat: Add Cannon Lake support
      tools/power turbostat: delete duplicate #defines
      x86: msr-index.h: Correct SNB_C1/C3_AUTO_UNDEMOTE defines
      tools/power turbostat: Correct SNB_C1/C3_AUTO_UNDEMOTE defines
      tools/power turbostat: add POLL and POLL% column
      tools/power turbostat: Fix --hide Pk%pc10
      tools/power turbostat: Build-in "Low Power Idle" counters support
      tools/power turbostat: Don't make man pages executable
      tools/power turbostat: remove blank lines
      tools/power turbostat: a small C-states dump readability immprovement
      ...

commit e9ac68c34f70a0c8d51ee63d259f7c8e79b362c1
Author: Kim Phillips <kim.phillips@arm.com>
Date:   Mon May 14 21:51:55 2018 +0100

    ARM: 8773/1: amba: Export amba_bustype
    
    This patch is provided in the context of allowing the Coresight driver
    subsystem to be loaded as modules.  Coresight uses amba_bus in its call
    to bus_find_device() in of_coresight_get_endpoint_device() when
    searching for a configurable endpoint device.  This patch allows
    Coresight to reference amba_bustype when built as a module.
    
    [original LKML submission here: https://lkml.org/lkml/2018/5/9/520]
    
    Cc: Mathieu Poirier <mathieu.poirier@linaro.org>
    Cc: Alex Williamson <alex.williamson@redhat.com>
    Cc: Eric Auger <eric.auger@redhat.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Todd Kjos <tkjos@google.com>
    Cc: Geert Uytterhoeven <geert+renesas@glider.be>
    Cc: Thierry Reding <treding@nvidia.com>
    Reviewed-by: Robin Murphy <robin.murphy@arm.com>
    Signed-off-by: Kim Phillips <kim.phillips@arm.com>
    Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>

diff --git a/drivers/amba/bus.c b/drivers/amba/bus.c
index 594c228d2f02..12283bd06733 100644
--- a/drivers/amba/bus.c
+++ b/drivers/amba/bus.c
@@ -197,6 +197,7 @@ struct bus_type amba_bustype = {
 	.pm		= &amba_pm,
 	.force_dma	= true,
 };
+EXPORT_SYMBOL_GPL(amba_bustype);
 
 static int __init amba_init(void)
 {

commit d21bc89eb98cac7a7af6476f41cbdf10f082dd6b
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Thu Apr 26 10:53:05 2018 +0200

    amba: Respect all error codes from dev_pm_domain_attach()
    
    The limitation of being able to check only for -EPROBE_DEFER from
    dev_pm_domain_attach() has been removed. Hence let's respect all error
    codes and bail out accordingly.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/amba/bus.c b/drivers/amba/bus.c
index 4a3ac31c07d0..b0160b5c5608 100644
--- a/drivers/amba/bus.c
+++ b/drivers/amba/bus.c
@@ -248,7 +248,7 @@ static int amba_probe(struct device *dev)
 			break;
 
 		ret = dev_pm_domain_attach(dev, true);
-		if (ret == -EPROBE_DEFER)
+		if (ret)
 			break;
 
 		ret = amba_get_enable_pclk(pcdev);
@@ -375,7 +375,7 @@ static int amba_device_try_add(struct amba_device *dev, struct resource *parent)
 	}
 
 	ret = dev_pm_domain_attach(&dev->dev, true);
-	if (ret == -EPROBE_DEFER) {
+	if (ret) {
 		iounmap(tmp);
 		goto err_release;
 	}

commit 6be5b5b9c5e0104b009cf6996e4df21877576b91
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Tue Apr 10 15:21:46 2018 +0200

    ARM: amba: Fix wrong indentation in driver_override_store()
    
    Indentation is one TAB and 7 spaces instead of 2 TABs.
    
    Fixes: 3cf385713460eb2b ("ARM: 8256/1: driver coamba: add device binding path 'driver_override'")
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Reviewed-by: Todd Kjos <tkjos@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/amba/bus.c b/drivers/amba/bus.c
index 4a3ac31c07d0..842314a439fd 100644
--- a/drivers/amba/bus.c
+++ b/drivers/amba/bus.c
@@ -101,8 +101,8 @@ static ssize_t driver_override_store(struct device *_dev,
 	if (strlen(driver_override)) {
 		dev->driver_override = driver_override;
 	} else {
-	       kfree(driver_override);
-	       dev->driver_override = NULL;
+		kfree(driver_override);
+		dev->driver_override = NULL;
 	}
 	device_unlock(_dev);
 

commit 3d6ce86ee79465e1b1b6e287f8ea26b553fc768e
Author: Christoph Hellwig <hch@lst.de>
Date:   Thu May 3 16:25:08 2018 +0200

    drivers: remove force dma flag from buses
    
    With each bus implementing its own DMA configuration callback, there is no
    need for bus to explicitly set the force_dma flag.  Modify the
    of_dma_configure function to accept an input parameter which specifies if
    implicit DMA configuration is required when it is not described by the
    firmware.
    
    Signed-off-by: Nipun Gupta <nipun.gupta@nxp.com>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>  # PCI parts
    Reviewed-by: Rob Herring <robh@kernel.org>
    [hch: tweaked the changelog a bit]
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/amba/bus.c b/drivers/amba/bus.c
index b1f41f7d8eeb..3b0118786b43 100644
--- a/drivers/amba/bus.c
+++ b/drivers/amba/bus.c
@@ -204,7 +204,6 @@ struct bus_type amba_bustype = {
 	.uevent		= amba_uevent,
 	.dma_configure	= platform_dma_configure,
 	.pm		= &amba_pm,
-	.force_dma	= true,
 };
 
 static int __init amba_init(void)

commit 07397df29e57cde5799af16e8f148ae10ed75285
Author: Nipun Gupta <nipun.gupta@nxp.com>
Date:   Sat Apr 28 08:21:58 2018 +0530

    dma-mapping: move dma configuration to bus infrastructure
    
    ACPI/OF support for configuration of DMA is a bus specific aspect, and
    thus should be configured by the bus.  Introduces a 'dma_configure' bus
    method so that busses can control their DMA capabilities.
    
    Also update the PCI, Platform, ACPI and host1x buses to use the new
    method.
    
    Suggested-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Nipun Gupta <nipun.gupta@nxp.com>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>  # PCI parts
    Acked-by: Thierry Reding <treding@nvidia.com>
    Reviewed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    [hch: simplified host1x_dma_configure based on a comment from Thierry,
          rewrote changelog]
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/amba/bus.c b/drivers/amba/bus.c
index 4a3ac31c07d0..b1f41f7d8eeb 100644
--- a/drivers/amba/bus.c
+++ b/drivers/amba/bus.c
@@ -20,6 +20,7 @@
 #include <linux/sizes.h>
 #include <linux/limits.h>
 #include <linux/clk/clk-conf.h>
+#include <linux/platform_device.h>
 
 #include <asm/irq.h>
 
@@ -193,12 +194,15 @@ static const struct dev_pm_ops amba_pm = {
 /*
  * Primecells are part of the Advanced Microcontroller Bus Architecture,
  * so we call the bus "amba".
+ * DMA configuration for platform and AMBA bus is same. So here we reuse
+ * platform's DMA config routine.
  */
 struct bus_type amba_bustype = {
 	.name		= "amba",
 	.dev_groups	= amba_dev_groups,
 	.match		= amba_match,
 	.uevent		= amba_uevent,
+	.dma_configure	= platform_dma_configure,
 	.pm		= &amba_pm,
 	.force_dma	= true,
 };

commit 6a7228d90d42bcacfe38786756ba62762b91c20a
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Tue Apr 10 15:21:44 2018 +0200

    ARM: amba: Fix race condition with driver_override
    
    The driver_override implementation is susceptible to a race condition
    when different threads are reading vs storing a different driver
    override.  Add locking to avoid this race condition.
    
    Cfr. commits 6265539776a0810b ("driver core: platform: fix race
    condition with driver_override") and 9561475db680f714 ("PCI: Fix race
    condition with driver_override").
    
    Fixes: 3cf385713460eb2b ("ARM: 8256/1: driver coamba: add device binding path 'driver_override'")
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Reviewed-by: Todd Kjos <tkjos@google.com>
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/amba/bus.c b/drivers/amba/bus.c
index f8c01fbef64d..4a3ac31c07d0 100644
--- a/drivers/amba/bus.c
+++ b/drivers/amba/bus.c
@@ -69,8 +69,12 @@ static ssize_t driver_override_show(struct device *_dev,
 				    struct device_attribute *attr, char *buf)
 {
 	struct amba_device *dev = to_amba_device(_dev);
+	ssize_t len;
 
-	return sprintf(buf, "%s\n", dev->driver_override);
+	device_lock(_dev);
+	len = sprintf(buf, "%s\n", dev->driver_override);
+	device_unlock(_dev);
+	return len;
 }
 
 static ssize_t driver_override_store(struct device *_dev,
@@ -78,7 +82,7 @@ static ssize_t driver_override_store(struct device *_dev,
 				     const char *buf, size_t count)
 {
 	struct amba_device *dev = to_amba_device(_dev);
-	char *driver_override, *old = dev->driver_override, *cp;
+	char *driver_override, *old, *cp;
 
 	/* We need to keep extra room for a newline */
 	if (count >= (PAGE_SIZE - 1))
@@ -92,12 +96,15 @@ static ssize_t driver_override_store(struct device *_dev,
 	if (cp)
 		*cp = '\0';
 
+	device_lock(_dev);
+	old = dev->driver_override;
 	if (strlen(driver_override)) {
 		dev->driver_override = driver_override;
 	} else {
 	       kfree(driver_override);
 	       dev->driver_override = NULL;
 	}
+	device_unlock(_dev);
 
 	kfree(old);
 

commit 5f53624662eaac89598641cee6cd54fc192572d9
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Tue Apr 10 15:21:43 2018 +0200

    ARM: amba: Make driver_override output consistent with other buses
    
    For AMBA devices with unconfigured driver override, the
    "driver_override" sysfs virtual file is empty, while it contains
    "(null)" for platform and PCI devices.
    
    Make AMBA consistent with other buses by dropping the test for a NULL
    pointer.
    
    Note that contrary to popular belief, sprintf() handles NULL pointers
    fine; they are printed as "(null)".
    
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Cc: stable <stable@vger.kernel.org>
    Reviewed-by: Todd Kjos <tkjos@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/amba/bus.c b/drivers/amba/bus.c
index fac8e36de11e..f8c01fbef64d 100644
--- a/drivers/amba/bus.c
+++ b/drivers/amba/bus.c
@@ -70,9 +70,6 @@ static ssize_t driver_override_show(struct device *_dev,
 {
 	struct amba_device *dev = to_amba_device(_dev);
 
-	if (!dev->driver_override)
-		return 0;
-
 	return sprintf(buf, "%s\n", dev->driver_override);
 }
 

commit 2891d4feae7c2cf0a56d84bf38519aae6c5060b5
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Thu Apr 26 10:29:57 2018 +0200

    Revert "ARM: amba: Fix race condition with driver_override"
    
    This reverts commit 6b614a87f3f477571e319281e84dba11e0ea0a76.
    
    My backport was incorrect, as Geert pointed out :(
    
    Reported-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Todd Kjos <tkjos@google.com>
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/amba/bus.c b/drivers/amba/bus.c
index 8e6ac3031662..fac8e36de11e 100644
--- a/drivers/amba/bus.c
+++ b/drivers/amba/bus.c
@@ -69,15 +69,11 @@ static ssize_t driver_override_show(struct device *_dev,
 				    struct device_attribute *attr, char *buf)
 {
 	struct amba_device *dev = to_amba_device(_dev);
-	ssize_t len;
 
 	if (!dev->driver_override)
 		return 0;
 
-	device_lock(_dev);
-	len = sprintf(buf, "%s\n", dev->driver_override);
-	device_unlock(_dev);
-	return len;
+	return sprintf(buf, "%s\n", dev->driver_override);
 }
 
 static ssize_t driver_override_store(struct device *_dev,
@@ -85,7 +81,7 @@ static ssize_t driver_override_store(struct device *_dev,
 				     const char *buf, size_t count)
 {
 	struct amba_device *dev = to_amba_device(_dev);
-	char *driver_override, *old, *cp;
+	char *driver_override, *old = dev->driver_override, *cp;
 
 	/* We need to keep extra room for a newline */
 	if (count >= (PAGE_SIZE - 1))
@@ -99,15 +95,12 @@ static ssize_t driver_override_store(struct device *_dev,
 	if (cp)
 		*cp = '\0';
 
-	device_lock(_dev);
-	old = dev->driver_override;
 	if (strlen(driver_override)) {
 		dev->driver_override = driver_override;
 	} else {
 	       kfree(driver_override);
 	       dev->driver_override = NULL;
 	}
-	device_unlock(_dev);
 
 	kfree(old);
 

commit d2ffed5185df9d8d9ccd150e4340e3b6f96a8381
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Tue Apr 10 15:21:45 2018 +0200

    ARM: amba: Don't read past the end of sysfs "driver_override" buffer
    
    When printing the driver_override parameter when it is 4095 and 4094
    bytes long, the printing code would access invalid memory because we
    need count + 1 bytes for printing.
    
    Cfr. commits 4efe874aace57dba ("PCI: Don't read past the end of sysfs
    "driver_override" buffer") and bf563b01c2895a4b ("driver core: platform:
    Don't read past the end of "driver_override" buffer").
    
    Fixes: 3cf385713460eb2b ("ARM: 8256/1: driver coamba: add device binding path 'driver_override'")
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Reviewed-by: Todd Kjos <tkjos@google.com>
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/amba/bus.c b/drivers/amba/bus.c
index c77eb6e65646..8e6ac3031662 100644
--- a/drivers/amba/bus.c
+++ b/drivers/amba/bus.c
@@ -87,7 +87,8 @@ static ssize_t driver_override_store(struct device *_dev,
 	struct amba_device *dev = to_amba_device(_dev);
 	char *driver_override, *old, *cp;
 
-	if (count > PATH_MAX)
+	/* We need to keep extra room for a newline */
+	if (count >= (PAGE_SIZE - 1))
 		return -EINVAL;
 
 	driver_override = kstrndup(buf, count, GFP_KERNEL);

commit 6b614a87f3f477571e319281e84dba11e0ea0a76
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Tue Apr 10 15:21:44 2018 +0200

    ARM: amba: Fix race condition with driver_override
    
    The driver_override implementation is susceptible to a race condition
    when different threads are reading vs storing a different driver
    override.  Add locking to avoid this race condition.
    
    Cfr. commits 6265539776a0810b ("driver core: platform: fix race
    condition with driver_override") and 9561475db680f714 ("PCI: Fix race
    condition with driver_override").
    
    Fixes: 3cf385713460eb2b ("ARM: 8256/1: driver coamba: add device binding path 'driver_override'")
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Reviewed-by: Todd Kjos <tkjos@google.com>
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/amba/bus.c b/drivers/amba/bus.c
index 594c228d2f02..c77eb6e65646 100644
--- a/drivers/amba/bus.c
+++ b/drivers/amba/bus.c
@@ -69,11 +69,15 @@ static ssize_t driver_override_show(struct device *_dev,
 				    struct device_attribute *attr, char *buf)
 {
 	struct amba_device *dev = to_amba_device(_dev);
+	ssize_t len;
 
 	if (!dev->driver_override)
 		return 0;
 
-	return sprintf(buf, "%s\n", dev->driver_override);
+	device_lock(_dev);
+	len = sprintf(buf, "%s\n", dev->driver_override);
+	device_unlock(_dev);
+	return len;
 }
 
 static ssize_t driver_override_store(struct device *_dev,
@@ -81,7 +85,7 @@ static ssize_t driver_override_store(struct device *_dev,
 				     const char *buf, size_t count)
 {
 	struct amba_device *dev = to_amba_device(_dev);
-	char *driver_override, *old = dev->driver_override, *cp;
+	char *driver_override, *old, *cp;
 
 	if (count > PATH_MAX)
 		return -EINVAL;
@@ -94,12 +98,15 @@ static ssize_t driver_override_store(struct device *_dev,
 	if (cp)
 		*cp = '\0';
 
+	device_lock(_dev);
+	old = dev->driver_override;
 	if (strlen(driver_override)) {
 		dev->driver_override = driver_override;
 	} else {
 	       kfree(driver_override);
 	       dev->driver_override = NULL;
 	}
+	device_unlock(_dev);
 
 	kfree(old);
 

commit d89e2378a97fafdc74cbf997e7c88af75b81610a
Author: Robin Murphy <robin.murphy@arm.com>
Date:   Thu Oct 12 16:56:14 2017 +0100

    drivers: flag buses which demand DMA configuration
    
    We do not want the common dma_configure() pathway to apply
    indiscriminately to all devices, since there are plenty of buses which
    do not have DMA capability, and if their child devices were used for
    DMA API calls it would only be indicative of a driver bug. However,
    there are a number of buses for which DMA is implicitly expected even
    when not described by firmware - those we whitelist with an automatic
    opt-in to dma_configure(), assuming that the DMA address space and the
    physical address space are equivalent if not otherwise specified.
    
    Commit 723288836628 ("of: restrict DMA configuration") introduced a
    short-term fix by comparing explicit bus types, but this approach is far
    from pretty, doesn't scale well, and fails to cope at all with bus
    drivers which may be built as modules, like host1x. Let's refine things
    by making that opt-in a property of the bus type, which neatly addresses
    those problems and lets the decision of whether firmware description of
    DMA capability should be optional or mandatory stay internal to the bus
    drivers themselves.
    
    Signed-off-by: Robin Murphy <robin.murphy@arm.com>
    Acked-by: Rob Herring <robh@kernel.org>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Acked-by: Thierry Reding <treding@nvidia.com>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/amba/bus.c b/drivers/amba/bus.c
index e0f74ddc22b7..594c228d2f02 100644
--- a/drivers/amba/bus.c
+++ b/drivers/amba/bus.c
@@ -195,6 +195,7 @@ struct bus_type amba_bustype = {
 	.match		= amba_match,
 	.uevent		= amba_uevent,
 	.pm		= &amba_pm,
+	.force_dma	= true,
 };
 
 static int __init amba_init(void)

commit 966449a3d8a04e6ca539aba3d247140c130d96b1
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Jun 6 14:16:49 2017 +0200

    amba: use dev_groups and not dev_attrs for bus_type
    
    The dev_attrs field has long been "depreciated" and is finally being
    removed, so move the driver to use the "correct" dev_groups field
    instead for struct bus_type.
    
    Cc: Russell King <linux@armlinux.org.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/amba/bus.c b/drivers/amba/bus.c
index a56fa2a1e9aa..e0f74ddc22b7 100644
--- a/drivers/amba/bus.c
+++ b/drivers/amba/bus.c
@@ -105,6 +105,7 @@ static ssize_t driver_override_store(struct device *_dev,
 
 	return count;
 }
+static DEVICE_ATTR_RW(driver_override);
 
 #define amba_attr_func(name,fmt,arg...)					\
 static ssize_t name##_show(struct device *_dev,				\
@@ -112,25 +113,23 @@ static ssize_t name##_show(struct device *_dev,				\
 {									\
 	struct amba_device *dev = to_amba_device(_dev);			\
 	return sprintf(buf, fmt, arg);					\
-}
-
-#define amba_attr(name,fmt,arg...)	\
-amba_attr_func(name,fmt,arg)		\
-static DEVICE_ATTR(name, S_IRUGO, name##_show, NULL)
+}									\
+static DEVICE_ATTR_RO(name)
 
 amba_attr_func(id, "%08x\n", dev->periphid);
-amba_attr(irq0, "%u\n", dev->irq[0]);
-amba_attr(irq1, "%u\n", dev->irq[1]);
+amba_attr_func(irq0, "%u\n", dev->irq[0]);
+amba_attr_func(irq1, "%u\n", dev->irq[1]);
 amba_attr_func(resource, "\t%016llx\t%016llx\t%016lx\n",
 	 (unsigned long long)dev->res.start, (unsigned long long)dev->res.end,
 	 dev->res.flags);
 
-static struct device_attribute amba_dev_attrs[] = {
-	__ATTR_RO(id),
-	__ATTR_RO(resource),
-	__ATTR_RW(driver_override),
-	__ATTR_NULL,
+static struct attribute *amba_dev_attrs[] = {
+	&dev_attr_id.attr,
+	&dev_attr_resource.attr,
+	&dev_attr_driver_override.attr,
+	NULL,
 };
+ATTRIBUTE_GROUPS(amba_dev);
 
 #ifdef CONFIG_PM
 /*
@@ -192,7 +191,7 @@ static const struct dev_pm_ops amba_pm = {
  */
 struct bus_type amba_bustype = {
 	.name		= "amba",
-	.dev_attrs	= amba_dev_attrs,
+	.dev_groups	= amba_dev_groups,
 	.match		= amba_match,
 	.uevent		= amba_uevent,
 	.pm		= &amba_pm,

commit bcd3006f07ef9c80ac225854c1518c22f2f56d71
Author: Stephen Boyd <sboyd@codeaurora.org>
Date:   Wed Aug 10 20:17:34 2016 +0100

    ARM: 8596/1: amba: Support clk parents and rates assigned in DT
    
    Add the call to of_clk_set_defaults() into the amba probe path so
    that devices on the amba bus can use the assigned rates and
    parents feature of the common clock framework.
    
    Cc: Michael Turquette <mturquette@baylibre.com>
    Tested-by: Jorge Ramirez Ortiz <jorge.ramirez-ortiz@linaro.org>
    Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/drivers/amba/bus.c b/drivers/amba/bus.c
index a5b5c87e2114..a56fa2a1e9aa 100644
--- a/drivers/amba/bus.c
+++ b/drivers/amba/bus.c
@@ -19,6 +19,7 @@
 #include <linux/amba/bus.h>
 #include <linux/sizes.h>
 #include <linux/limits.h>
+#include <linux/clk/clk-conf.h>
 
 #include <asm/irq.h>
 
@@ -237,6 +238,10 @@ static int amba_probe(struct device *dev)
 	int ret;
 
 	do {
+		ret = of_clk_set_defaults(dev->of_node, false);
+		if (ret < 0)
+			break;
+
 		ret = dev_pm_domain_attach(dev, true);
 		if (ret == -EPROBE_DEFER)
 			break;

commit a41980f2a3eb33ed7a2636e83498b47e95ceb05b
Author: Marek Szyprowski <m.szyprowski@samsung.com>
Date:   Thu Apr 21 07:58:35 2016 +0100

    ARM: 8566/1: drivers: amba: properly handle devices with power domains
    
    To read pid/cid registers, the probed device need to be properly turned on.
    When it is inside a power domain, the bus code should ensure that the
    given power domain is enabled before trying to access device's registers.
    However in some cases power domain (or clocks) might not be yet available.
    Returning -EPROBE_DEFER is not a solution in such case, because callers
    don't handle this special error code. Instead such devices are added to the
    special list and their registration is retried from periodic worker until
    all resources are available.
    
    Signed-off-by: Marek Szyprowski <m.szyprowski@samsung.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/drivers/amba/bus.c b/drivers/amba/bus.c
index f0099360039e..a5b5c87e2114 100644
--- a/drivers/amba/bus.c
+++ b/drivers/amba/bus.c
@@ -336,16 +336,7 @@ static void amba_device_release(struct device *dev)
 	kfree(d);
 }
 
-/**
- *	amba_device_add - add a previously allocated AMBA device structure
- *	@dev: AMBA device allocated by amba_device_alloc
- *	@parent: resource parent for this devices resources
- *
- *	Claim the resource, and read the device cell ID if not already
- *	initialized.  Register the AMBA device with the Linux device
- *	manager.
- */
-int amba_device_add(struct amba_device *dev, struct resource *parent)
+static int amba_device_try_add(struct amba_device *dev, struct resource *parent)
 {
 	u32 size;
 	void __iomem *tmp;
@@ -373,6 +364,12 @@ int amba_device_add(struct amba_device *dev, struct resource *parent)
 		goto err_release;
 	}
 
+	ret = dev_pm_domain_attach(&dev->dev, true);
+	if (ret == -EPROBE_DEFER) {
+		iounmap(tmp);
+		goto err_release;
+	}
+
 	ret = amba_get_enable_pclk(dev);
 	if (ret == 0) {
 		u32 pid, cid;
@@ -398,6 +395,7 @@ int amba_device_add(struct amba_device *dev, struct resource *parent)
 	}
 
 	iounmap(tmp);
+	dev_pm_domain_detach(&dev->dev, true);
 
 	if (ret)
 		goto err_release;
@@ -421,6 +419,88 @@ int amba_device_add(struct amba_device *dev, struct resource *parent)
  err_out:
 	return ret;
 }
+
+/*
+ * Registration of AMBA device require reading its pid and cid registers.
+ * To do this, the device must be turned on (if it is a part of power domain)
+ * and have clocks enabled. However in some cases those resources might not be
+ * yet available. Returning EPROBE_DEFER is not a solution in such case,
+ * because callers don't handle this special error code. Instead such devices
+ * are added to the special list and their registration is retried from
+ * periodic worker, until all resources are available and registration succeeds.
+ */
+struct deferred_device {
+	struct amba_device *dev;
+	struct resource *parent;
+	struct list_head node;
+};
+
+static LIST_HEAD(deferred_devices);
+static DEFINE_MUTEX(deferred_devices_lock);
+
+static void amba_deferred_retry_func(struct work_struct *dummy);
+static DECLARE_DELAYED_WORK(deferred_retry_work, amba_deferred_retry_func);
+
+#define DEFERRED_DEVICE_TIMEOUT (msecs_to_jiffies(5 * 1000))
+
+static void amba_deferred_retry_func(struct work_struct *dummy)
+{
+	struct deferred_device *ddev, *tmp;
+
+	mutex_lock(&deferred_devices_lock);
+
+	list_for_each_entry_safe(ddev, tmp, &deferred_devices, node) {
+		int ret = amba_device_try_add(ddev->dev, ddev->parent);
+
+		if (ret == -EPROBE_DEFER)
+			continue;
+
+		list_del_init(&ddev->node);
+		kfree(ddev);
+	}
+
+	if (!list_empty(&deferred_devices))
+		schedule_delayed_work(&deferred_retry_work,
+				      DEFERRED_DEVICE_TIMEOUT);
+
+	mutex_unlock(&deferred_devices_lock);
+}
+
+/**
+ *	amba_device_add - add a previously allocated AMBA device structure
+ *	@dev: AMBA device allocated by amba_device_alloc
+ *	@parent: resource parent for this devices resources
+ *
+ *	Claim the resource, and read the device cell ID if not already
+ *	initialized.  Register the AMBA device with the Linux device
+ *	manager.
+ */
+int amba_device_add(struct amba_device *dev, struct resource *parent)
+{
+	int ret = amba_device_try_add(dev, parent);
+
+	if (ret == -EPROBE_DEFER) {
+		struct deferred_device *ddev;
+
+		ddev = kmalloc(sizeof(*ddev), GFP_KERNEL);
+		if (!ddev)
+			return -ENOMEM;
+
+		ddev->dev = dev;
+		ddev->parent = parent;
+		ret = 0;
+
+		mutex_lock(&deferred_devices_lock);
+
+		if (list_empty(&deferred_devices))
+			schedule_delayed_work(&deferred_retry_work,
+					      DEFERRED_DEVICE_TIMEOUT);
+		list_add_tail(&ddev->node, &deferred_devices);
+
+		mutex_unlock(&deferred_devices_lock);
+	}
+	return ret;
+}
 EXPORT_SYMBOL_GPL(amba_device_add);
 
 static struct amba_device *

commit 3cf385713460eb2bb4cb7ceb8ed89833b00b594b
Author: Antonios Motakis <a.motakis@virtualopensystems.com>
Date:   Tue Jan 6 11:15:11 2015 +0100

    ARM: 8256/1: driver coamba: add device binding path 'driver_override'
    
    As already demonstrated with PCI [1] and the platform bus [2], a
    driver_override property in sysfs can be used to bypass the id
    matching of a device to a AMBA driver. This can be used by VFIO to
    bind to any AMBA device requested by the user.
    
    [1] http://lists-archives.com/linux-kernel/28030441-pci-introduce-new-device-binding-path-using-pci_dev-driver_override.html
    [2] https://www.redhat.com/archives/libvir-list/2014-April/msg00382.html
    
    Signed-off-by: Antonios Motakis <a.motakis@virtualopensystems.com>
    Reviewed-by: Kim Phillips <kim.phillips@freescale.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/drivers/amba/bus.c b/drivers/amba/bus.c
index 52ddd9fbb55e..f0099360039e 100644
--- a/drivers/amba/bus.c
+++ b/drivers/amba/bus.c
@@ -18,6 +18,7 @@
 #include <linux/pm_domain.h>
 #include <linux/amba/bus.h>
 #include <linux/sizes.h>
+#include <linux/limits.h>
 
 #include <asm/irq.h>
 
@@ -43,6 +44,10 @@ static int amba_match(struct device *dev, struct device_driver *drv)
 	struct amba_device *pcdev = to_amba_device(dev);
 	struct amba_driver *pcdrv = to_amba_driver(drv);
 
+	/* When driver_override is set, only bind to the matching driver */
+	if (pcdev->driver_override)
+		return !strcmp(pcdev->driver_override, drv->name);
+
 	return amba_lookup(pcdrv->id_table, pcdev) != NULL;
 }
 
@@ -59,6 +64,47 @@ static int amba_uevent(struct device *dev, struct kobj_uevent_env *env)
 	return retval;
 }
 
+static ssize_t driver_override_show(struct device *_dev,
+				    struct device_attribute *attr, char *buf)
+{
+	struct amba_device *dev = to_amba_device(_dev);
+
+	if (!dev->driver_override)
+		return 0;
+
+	return sprintf(buf, "%s\n", dev->driver_override);
+}
+
+static ssize_t driver_override_store(struct device *_dev,
+				     struct device_attribute *attr,
+				     const char *buf, size_t count)
+{
+	struct amba_device *dev = to_amba_device(_dev);
+	char *driver_override, *old = dev->driver_override, *cp;
+
+	if (count > PATH_MAX)
+		return -EINVAL;
+
+	driver_override = kstrndup(buf, count, GFP_KERNEL);
+	if (!driver_override)
+		return -ENOMEM;
+
+	cp = strchr(driver_override, '\n');
+	if (cp)
+		*cp = '\0';
+
+	if (strlen(driver_override)) {
+		dev->driver_override = driver_override;
+	} else {
+	       kfree(driver_override);
+	       dev->driver_override = NULL;
+	}
+
+	kfree(old);
+
+	return count;
+}
+
 #define amba_attr_func(name,fmt,arg...)					\
 static ssize_t name##_show(struct device *_dev,				\
 			   struct device_attribute *attr, char *buf)	\
@@ -81,6 +127,7 @@ amba_attr_func(resource, "\t%016llx\t%016llx\t%016lx\n",
 static struct device_attribute amba_dev_attrs[] = {
 	__ATTR_RO(id),
 	__ATTR_RO(resource),
+	__ATTR_RW(driver_override),
 	__ATTR_NULL,
 };
 

commit 6ae840e7cc4be0be3aa40d9f67c35c75cfc67d83
Merge: e6b5be2be4e3 91905b6f4afe
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Dec 14 16:43:47 2014 -0800

    Merge tag 'char-misc-3.19-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/char-misc
    
    Pull char/misc driver updates from Greg KH:
     "Here's the big char/misc driver update for 3.19-rc1
    
      Lots of little things all over the place in different drivers, and a
      new subsystem, "coresight" has been added.  Full details are in the
      shortlog"
    
    * tag 'char-misc-3.19-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/char-misc: (73 commits)
      parport: parport_pc, do not remove parent devices early
      spmi: Remove shutdown/suspend/resume kernel-doc
      carma-fpga-program: drop videobuf dependency
      carma-fpga: drop videobuf dependency
      carma-fpga-program.c: fix compile errors
      i8k: Fix temperature bug handling in i8k_get_temp()
      cxl: Name interrupts in /proc/interrupt
      CXL: Return error to PSL if IRQ demultiplexing fails & print clearer warning
      coresight-replicator: remove .owner field for driver
      coresight: fixed comments in coresight.h
      coresight: fix typo in comment in coresight-priv.h
      coresight: bindings for coresight drivers
      coresight: Adding ABI documentation
      w1: support auto-load of w1_bq27000 module.
      w1: avoid potential u16 overflow
      cn: verify msg->len before making callback
      mei: export fw status registers through sysfs
      mei: read and print all six FW status registers
      mei: txe: add cherrytrail device id
      mei: kill cached host and me csr values
      ...

commit 26ceb127f7bcf473db926c6a026b18ddd6f274e8
Merge: 8d1406675559 e9f2d6d66037
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Dec 12 15:26:48 2014 -0800

    Merge branch 'for-linus' of git://ftp.arm.linux.org.uk/~rmk/linux-arm
    
    Pull ARM updates from Russell King:
     "The major updates included in this update are:
    
       - Clang compatible stack pointer accesses by Behan Webster.
       - SA11x0 updates from Dmitry Eremin-Solenikov.
       - kgdb handling of breakpoints with read-only text/modules
       - Support for Privileged-no-execute feature on ARMv7 to prevent
         userspace code execution by the kernel.
       - AMBA primecell bus handling of irq-safe runtime PM
       - Unwinding support for memset/memzero/memmove/memcpy functions
       - VFP fixes for Krait CPUs and improvements in detecting the VFP
         architecture
       - A number of code cleanups (using pr_*, removing or reducing the
         severity of a couple of kernel messages, splitting ftrace asm code
         out to a separate file, etc.)
       - Add machine name to stack dump output"
    
    * 'for-linus' of git://ftp.arm.linux.org.uk/~rmk/linux-arm: (62 commits)
      ARM: 8247/2: pcmcia: sa1100: make use of device clock
      ARM: 8246/2: pcmcia: sa1111: provide device clock
      ARM: 8245/1: pcmcia: soc-common: enable/disable socket clocks
      ARM: 8244/1: fbdev: sa1100fb: make use of device clock
      ARM: 8243/1: sa1100: add a clock alias for sa1111 pcmcia device
      ARM: 8242/1: sa1100: add cpu clock
      ARM: 8221/1: PJ4: allow building in Thumb-2 mode
      ARM: 8234/1: sa1100: reorder IRQ handling code
      ARM: 8233/1: sa1100: switch to hwirq usage
      ARM: 8232/1: sa1100: merge GPIO multiplexer IRQ to "normal" irq domain
      ARM: 8231/1: sa1100: introduce irqdomains support
      ARM: 8230/1: sa1100: shift IRQs by one
      ARM: 8229/1: sa1100: replace irq numbers with names in irq driver
      ARM: 8228/1: sa1100: drop entry-macro.S
      ARM: 8227/1: sa1100: switch to MULTI_IRQ_HANDLER
      ARM: 8241/1: Update processor_modes for hyp and monitor mode
      ARM: 8240/1: MCPM: document mcpm_sync_init()
      ARM: 8239/1: Introduce {set,clear}_pte_bit
      ARM: 8238/1: mm: Refine set_memory_* functions
      ARM: 8237/1: fix flush_pfn_alias
      ...

commit 6ed23b806e73bdd5b17722df507b0f4570c606b6
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Thu Dec 4 00:34:11 2014 +0100

    PM: Merge the SET*_RUNTIME_PM_OPS() macros
    
    The SET_PM_RUNTIME_PM_OPS() and SET_RUNTIME_PM_OPS() macros are
    identical except that one of them is not empty for CONFIG_PM set,
    while the other one is not empty for CONFIG_PM_RUNTIME set,
    respectively.
    
    However, after commit b2b49ccbdd54 (PM: Kconfig: Set PM_RUNTIME if
    PM_SLEEP is selected) PM_RUNTIME is always set if PM is set, so one
    of these macros is now redundant.
    
    For this reason, replace SET_PM_RUNTIME_PM_OPS() with
    SET_RUNTIME_PM_OPS() everywhere and redefine the SET_PM_RUNTIME_PM_OPS
    symbol as SET_RUNTIME_PM_OPS in case new code is starting to use the
    macro being removed here.
    
    Reviewed-by: Ulf Hansson <ulf.hansson@linaro.org>
    Acked-by: Kevin Hilman <khilman@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/amba/bus.c b/drivers/amba/bus.c
index 47bbdc1b5be3..973a3332a85f 100644
--- a/drivers/amba/bus.c
+++ b/drivers/amba/bus.c
@@ -124,7 +124,7 @@ static const struct dev_pm_ops amba_pm = {
 	.thaw		= pm_generic_thaw,
 	.poweroff	= pm_generic_poweroff,
 	.restore	= pm_generic_restore,
-	SET_PM_RUNTIME_PM_OPS(
+	SET_RUNTIME_PM_OPS(
 		amba_pm_runtime_suspend,
 		amba_pm_runtime_resume,
 		NULL

commit 5670c2a52f60418f67dd589e20d30600804fcfde
Author: Krzysztof Kozlowski <k.kozlowski@samsung.com>
Date:   Fri Nov 14 09:48:27 2014 +0100

    ARM: 8201/1: amba: Don't unprepare the clocks if device driver wants IRQ safe runtime PM v12
    
    The AMBA bus driver defines runtime Power Management functions which
    disable and unprepare AMBA bus clock. This is problematic for runtime PM
    because unpreparing a clock might sleep so it is not interrupt safe.
    
    However some drivers may want to implement runtime PM functions in
    interrupt-safe way (see pm_runtime_irq_safe()). In such case the AMBA
    bus driver should only disable/enable the clock in runtime suspend and
    resume callbacks.
    
    Signed-off-by: Krzysztof Kozlowski <k.kozlowski@samsung.com>
    Reviewed-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/drivers/amba/bus.c b/drivers/amba/bus.c
index 47bbdc1b5be3..f8e3bb44938e 100644
--- a/drivers/amba/bus.c
+++ b/drivers/amba/bus.c
@@ -95,8 +95,12 @@ static int amba_pm_runtime_suspend(struct device *dev)
 	struct amba_device *pcdev = to_amba_device(dev);
 	int ret = pm_generic_runtime_suspend(dev);
 
-	if (ret == 0 && dev->driver)
-		clk_disable_unprepare(pcdev->pclk);
+	if (ret == 0 && dev->driver) {
+		if (pm_runtime_is_irq_safe(dev))
+			clk_disable(pcdev->pclk);
+		else
+			clk_disable_unprepare(pcdev->pclk);
+	}
 
 	return ret;
 }
@@ -107,7 +111,10 @@ static int amba_pm_runtime_resume(struct device *dev)
 	int ret;
 
 	if (dev->driver) {
-		ret = clk_prepare_enable(pcdev->pclk);
+		if (pm_runtime_is_irq_safe(dev))
+			ret = clk_enable(pcdev->pclk);
+		else
+			ret = clk_prepare_enable(pcdev->pclk);
 		/* Failure is probably fatal to the system, but... */
 		if (ret)
 			return ret;
@@ -115,7 +122,7 @@ static int amba_pm_runtime_resume(struct device *dev)
 
 	return pm_generic_runtime_resume(dev);
 }
-#endif
+#endif /* CONFIG_PM */
 
 static const struct dev_pm_ops amba_pm = {
 	.suspend	= pm_generic_suspend,

commit a06ae8609b3dd06b957a6e4e965772a8a14d3af5
Author: Pratik Patel <pratikp@codeaurora.org>
Date:   Mon Nov 3 11:07:35 2014 -0700

    coresight: add CoreSight core layer framework
    
    CoreSight components are compliant with the ARM CoreSight
    architecture specification and can be connected in various
    topologies to suit a particular SoC tracing needs. These trace
    components can generally be classified as sources, links and
    sinks. Trace data produced by one or more sources flows through
    the intermediate links connecting the source to the currently
    selected sink.
    
    The CoreSight framework provides an interface for the CoreSight trace
    drivers to register themselves with. It's intended to build up a
    topological view of the CoreSight components and configure the
    correct serie of components on user input via sysfs.
    
    For eg., when enabling a source, the framework builds up a path
    consisting of all the components connecting the source to the
    currently selected sink(s) and enables all of them.
    
    The framework also supports switching between available sinks
    and provides status information to user space applications
    through the debugfs interface.
    
    Signed-off-by: Pratik Patel <pratikp@codeaurora.org>
    Signed-off-by: Mathieu Poirier <mathieu.poirier@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/amba/bus.c b/drivers/amba/bus.c
index 47bbdc1b5be3..a4ac490dd784 100644
--- a/drivers/amba/bus.c
+++ b/drivers/amba/bus.c
@@ -336,7 +336,7 @@ int amba_device_add(struct amba_device *dev, struct resource *parent)
 
 		amba_put_disable_pclk(dev);
 
-		if (cid == AMBA_CID)
+		if (cid == AMBA_CID || cid == CORESIGHT_CID)
 			dev->periphid = pid;
 
 		if (!dev->periphid)

commit f48c767ce8951e30eb716b8ef69142d21aacbd1d
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Mon Sep 29 13:58:47 2014 +0200

    PM / Domains: Move dev_pm_domain_attach|detach() to pm_domain.h
    
    The commit 46420dd73b80 (PM / Domains: Add APIs to attach/detach a PM
    domain for a device) started using errno values in pm.h header file.
    It also failed to include the header for these, thus it caused
    compiler errors.
    
    Instead of including the errno header to pm.h, let's move the functions
    to pm_domain.h, since it's a better match.
    
    Fixes: 46420dd73b80 (PM / Domains: Add APIs to attach/detach a PM domain for a device)
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Acked-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Acked-by: Wolfram Sang <wsa@the-dreams.de>
    Acked-by: Mark Brown <broonie@kernel.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/amba/bus.c b/drivers/amba/bus.c
index 8f5239377f91..47bbdc1b5be3 100644
--- a/drivers/amba/bus.c
+++ b/drivers/amba/bus.c
@@ -15,6 +15,7 @@
 #include <linux/io.h>
 #include <linux/pm.h>
 #include <linux/pm_runtime.h>
+#include <linux/pm_domain.h>
 #include <linux/amba/bus.h>
 #include <linux/sizes.h>
 

commit 207f1a2d294e3781b56d1acecd48aaa3b4b7b2ad
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Fri Sep 19 20:27:42 2014 +0200

    amba: Add support for attach/detach of PM domains
    
    AMBA devices may on some SoCs resides in PM domains. To be able to
    manage these devices from there, let's try to attach devices to their
    corresponding PM domain during the probe phase.
    
    To reverse these actions at the remove phase, we try to detach the
    device from its PM domain.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Reviewed-by: Kevin Hilman <khilman@linaro.org>
    Reviewed-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/drivers/amba/bus.c b/drivers/amba/bus.c
index 3cf61a127ee5..8f5239377f91 100644
--- a/drivers/amba/bus.c
+++ b/drivers/amba/bus.c
@@ -182,9 +182,15 @@ static int amba_probe(struct device *dev)
 	int ret;
 
 	do {
+		ret = dev_pm_domain_attach(dev, true);
+		if (ret == -EPROBE_DEFER)
+			break;
+
 		ret = amba_get_enable_pclk(pcdev);
-		if (ret)
+		if (ret) {
+			dev_pm_domain_detach(dev, true);
 			break;
+		}
 
 		pm_runtime_get_noresume(dev);
 		pm_runtime_set_active(dev);
@@ -199,6 +205,7 @@ static int amba_probe(struct device *dev)
 		pm_runtime_put_noidle(dev);
 
 		amba_put_disable_pclk(pcdev);
+		dev_pm_domain_detach(dev, true);
 	} while (0);
 
 	return ret;
@@ -220,6 +227,7 @@ static int amba_remove(struct device *dev)
 	pm_runtime_put_noidle(dev);
 
 	amba_put_disable_pclk(pcdev);
+	dev_pm_domain_detach(dev, true);
 
 	return ret;
 }

commit f210c53a82ab9ba10574f8121a300d78e618febd
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Wed Feb 12 14:06:43 2014 +0100

    ARM: 7958/1: amba: Let runtime PM callbacks be available for CONFIG_PM
    
    Convert to the SET_PM_RUNTIME_PM macro while defining the runtime PM
    callbacks. This means the callbacks becomes available for both
    CONFIG_PM_SLEEP and CONFIG_PM_RUNTIME, which is needed by drivers and
    power domains.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/drivers/amba/bus.c b/drivers/amba/bus.c
index 9e6029105607..3cf61a127ee5 100644
--- a/drivers/amba/bus.c
+++ b/drivers/amba/bus.c
@@ -83,7 +83,7 @@ static struct device_attribute amba_dev_attrs[] = {
 	__ATTR_NULL,
 };
 
-#ifdef CONFIG_PM_RUNTIME
+#ifdef CONFIG_PM
 /*
  * Hooks to provide runtime PM of the pclk (bus clock).  It is safe to
  * enable/disable the bus clock at runtime PM suspend/resume as this
@@ -123,7 +123,7 @@ static const struct dev_pm_ops amba_pm = {
 	.thaw		= pm_generic_thaw,
 	.poweroff	= pm_generic_poweroff,
 	.restore	= pm_generic_restore,
-	SET_RUNTIME_PM_OPS(
+	SET_PM_RUNTIME_PM_OPS(
 		amba_pm_runtime_suspend,
 		amba_pm_runtime_resume,
 		NULL

commit 5303c0f46c8708fff4148ebcc491f78710356952
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Mon Dec 9 10:40:22 2013 +0100

    ARM: 7916/1: amba: Add clk_prepare|unprepare in runtime PM callbacks
    
    To fully gate the clock and thus potentially also save more power in
    runtime suspend state, extend clock handling with clk_prepare|unprepare
    in the runtime PM callbacks.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/drivers/amba/bus.c b/drivers/amba/bus.c
index ea1d8357f298..9e6029105607 100644
--- a/drivers/amba/bus.c
+++ b/drivers/amba/bus.c
@@ -95,7 +95,7 @@ static int amba_pm_runtime_suspend(struct device *dev)
 	int ret = pm_generic_runtime_suspend(dev);
 
 	if (ret == 0 && dev->driver)
-		clk_disable(pcdev->pclk);
+		clk_disable_unprepare(pcdev->pclk);
 
 	return ret;
 }
@@ -106,7 +106,7 @@ static int amba_pm_runtime_resume(struct device *dev)
 	int ret;
 
 	if (dev->driver) {
-		ret = clk_enable(pcdev->pclk);
+		ret = clk_prepare_enable(pcdev->pclk);
 		/* Failure is probably fatal to the system, but... */
 		if (ret)
 			return ret;

commit 89a5c985f81a0b60f7522044938f76caf28075a6
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Mon Dec 9 10:39:13 2013 +0100

    ARM: 7915/1: amba: Convert to clk_prepare_enable and clk_disable_unprepare
    
    To simplify code and error handling let's use clk_prepare_enable
    and clk_disable_unprepare. No functional change.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/drivers/amba/bus.c b/drivers/amba/bus.c
index b90dc1ec109d..ea1d8357f298 100644
--- a/drivers/amba/bus.c
+++ b/drivers/amba/bus.c
@@ -151,36 +151,23 @@ postcore_initcall(amba_init);
 
 static int amba_get_enable_pclk(struct amba_device *pcdev)
 {
-	struct clk *pclk = clk_get(&pcdev->dev, "apb_pclk");
 	int ret;
 
-	pcdev->pclk = pclk;
+	pcdev->pclk = clk_get(&pcdev->dev, "apb_pclk");
+	if (IS_ERR(pcdev->pclk))
+		return PTR_ERR(pcdev->pclk);
 
-	if (IS_ERR(pclk))
-		return PTR_ERR(pclk);
-
-	ret = clk_prepare(pclk);
-	if (ret) {
-		clk_put(pclk);
-		return ret;
-	}
-
-	ret = clk_enable(pclk);
-	if (ret) {
-		clk_unprepare(pclk);
-		clk_put(pclk);
-	}
+	ret = clk_prepare_enable(pcdev->pclk);
+	if (ret)
+		clk_put(pcdev->pclk);
 
 	return ret;
 }
 
 static void amba_put_disable_pclk(struct amba_device *pcdev)
 {
-	struct clk *pclk = pcdev->pclk;
-
-	clk_disable(pclk);
-	clk_unprepare(pclk);
-	clk_put(pclk);
+	clk_disable_unprepare(pcdev->pclk);
+	clk_put(pcdev->pclk);
 }
 
 /*

commit 26825cfd90f94f47068519901b3670ae7da320fe
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Mon Dec 9 10:38:20 2013 +0100

    ARM: 7914/1: amba: Drop legacy PM support and use the pm_generic functions
    
    All AMBA drivers have converted to use the modern PM ops thus we can
    safely drop the legacy PM support from the bus.
    
    While using the modern PM ops it also makes sense to convert to use the
    pm_generic callback functions.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/drivers/amba/bus.c b/drivers/amba/bus.c
index c4876ac9151a..b90dc1ec109d 100644
--- a/drivers/amba/bus.c
+++ b/drivers/amba/bus.c
@@ -83,162 +83,6 @@ static struct device_attribute amba_dev_attrs[] = {
 	__ATTR_NULL,
 };
 
-#ifdef CONFIG_PM_SLEEP
-
-static int amba_legacy_suspend(struct device *dev, pm_message_t mesg)
-{
-	struct amba_driver *adrv = to_amba_driver(dev->driver);
-	struct amba_device *adev = to_amba_device(dev);
-	int ret = 0;
-
-	if (dev->driver && adrv->suspend)
-		ret = adrv->suspend(adev, mesg);
-
-	return ret;
-}
-
-static int amba_legacy_resume(struct device *dev)
-{
-	struct amba_driver *adrv = to_amba_driver(dev->driver);
-	struct amba_device *adev = to_amba_device(dev);
-	int ret = 0;
-
-	if (dev->driver && adrv->resume)
-		ret = adrv->resume(adev);
-
-	return ret;
-}
-
-#endif /* CONFIG_PM_SLEEP */
-
-#ifdef CONFIG_SUSPEND
-
-static int amba_pm_suspend(struct device *dev)
-{
-	struct device_driver *drv = dev->driver;
-	int ret = 0;
-
-	if (!drv)
-		return 0;
-
-	if (drv->pm) {
-		if (drv->pm->suspend)
-			ret = drv->pm->suspend(dev);
-	} else {
-		ret = amba_legacy_suspend(dev, PMSG_SUSPEND);
-	}
-
-	return ret;
-}
-
-static int amba_pm_resume(struct device *dev)
-{
-	struct device_driver *drv = dev->driver;
-	int ret = 0;
-
-	if (!drv)
-		return 0;
-
-	if (drv->pm) {
-		if (drv->pm->resume)
-			ret = drv->pm->resume(dev);
-	} else {
-		ret = amba_legacy_resume(dev);
-	}
-
-	return ret;
-}
-
-#else /* !CONFIG_SUSPEND */
-
-#define amba_pm_suspend		NULL
-#define amba_pm_resume		NULL
-
-#endif /* !CONFIG_SUSPEND */
-
-#ifdef CONFIG_HIBERNATE_CALLBACKS
-
-static int amba_pm_freeze(struct device *dev)
-{
-	struct device_driver *drv = dev->driver;
-	int ret = 0;
-
-	if (!drv)
-		return 0;
-
-	if (drv->pm) {
-		if (drv->pm->freeze)
-			ret = drv->pm->freeze(dev);
-	} else {
-		ret = amba_legacy_suspend(dev, PMSG_FREEZE);
-	}
-
-	return ret;
-}
-
-static int amba_pm_thaw(struct device *dev)
-{
-	struct device_driver *drv = dev->driver;
-	int ret = 0;
-
-	if (!drv)
-		return 0;
-
-	if (drv->pm) {
-		if (drv->pm->thaw)
-			ret = drv->pm->thaw(dev);
-	} else {
-		ret = amba_legacy_resume(dev);
-	}
-
-	return ret;
-}
-
-static int amba_pm_poweroff(struct device *dev)
-{
-	struct device_driver *drv = dev->driver;
-	int ret = 0;
-
-	if (!drv)
-		return 0;
-
-	if (drv->pm) {
-		if (drv->pm->poweroff)
-			ret = drv->pm->poweroff(dev);
-	} else {
-		ret = amba_legacy_suspend(dev, PMSG_HIBERNATE);
-	}
-
-	return ret;
-}
-
-static int amba_pm_restore(struct device *dev)
-{
-	struct device_driver *drv = dev->driver;
-	int ret = 0;
-
-	if (!drv)
-		return 0;
-
-	if (drv->pm) {
-		if (drv->pm->restore)
-			ret = drv->pm->restore(dev);
-	} else {
-		ret = amba_legacy_resume(dev);
-	}
-
-	return ret;
-}
-
-#else /* !CONFIG_HIBERNATE_CALLBACKS */
-
-#define amba_pm_freeze		NULL
-#define amba_pm_thaw		NULL
-#define amba_pm_poweroff		NULL
-#define amba_pm_restore		NULL
-
-#endif /* !CONFIG_HIBERNATE_CALLBACKS */
-
 #ifdef CONFIG_PM_RUNTIME
 /*
  * Hooks to provide runtime PM of the pclk (bus clock).  It is safe to
@@ -272,15 +116,13 @@ static int amba_pm_runtime_resume(struct device *dev)
 }
 #endif
 
-#ifdef CONFIG_PM
-
 static const struct dev_pm_ops amba_pm = {
-	.suspend	= amba_pm_suspend,
-	.resume		= amba_pm_resume,
-	.freeze		= amba_pm_freeze,
-	.thaw		= amba_pm_thaw,
-	.poweroff	= amba_pm_poweroff,
-	.restore	= amba_pm_restore,
+	.suspend	= pm_generic_suspend,
+	.resume		= pm_generic_resume,
+	.freeze		= pm_generic_freeze,
+	.thaw		= pm_generic_thaw,
+	.poweroff	= pm_generic_poweroff,
+	.restore	= pm_generic_restore,
 	SET_RUNTIME_PM_OPS(
 		amba_pm_runtime_suspend,
 		amba_pm_runtime_resume,
@@ -288,14 +130,6 @@ static const struct dev_pm_ops amba_pm = {
 	)
 };
 
-#define AMBA_PM (&amba_pm)
-
-#else /* !CONFIG_PM */
-
-#define AMBA_PM	NULL
-
-#endif /* !CONFIG_PM */
-
 /*
  * Primecells are part of the Advanced Microcontroller Bus Architecture,
  * so we call the bus "amba".
@@ -305,7 +139,7 @@ struct bus_type amba_bustype = {
 	.dev_attrs	= amba_dev_attrs,
 	.match		= amba_match,
 	.uevent		= amba_uevent,
-	.pm		= AMBA_PM,
+	.pm		= &amba_pm,
 };
 
 static int __init amba_init(void)

commit 446b2a9380b64b9d7410d86ee8226031e03645cf
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Thu Jun 27 10:25:33 2013 +0100

    DMA-API: amba: get rid of separate dma_mask
    
    AMBA Primecell devices always treat streaming and coherent DMA exactly
    the same, so there's no point in having the masks separated.
    
    Acked-by: Grant Likely <grant.likely@linaro.org>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/drivers/amba/bus.c b/drivers/amba/bus.c
index c6707278a6bb..c4876ac9151a 100644
--- a/drivers/amba/bus.c
+++ b/drivers/amba/bus.c
@@ -552,7 +552,6 @@ amba_aphb_device_add(struct device *parent, const char *name,
 	if (!dev)
 		return ERR_PTR(-ENOMEM);
 
-	dev->dma_mask = dma_mask;
 	dev->dev.coherent_dma_mask = dma_mask;
 	dev->irq[0] = irq1;
 	dev->irq[1] = irq2;
@@ -619,7 +618,7 @@ static void amba_device_initialize(struct amba_device *dev, const char *name)
 		dev_set_name(&dev->dev, "%s", name);
 	dev->dev.release = amba_device_release;
 	dev->dev.bus = &amba_bustype;
-	dev->dev.dma_mask = &dev->dma_mask;
+	dev->dev.dma_mask = &dev->dev.coherent_dma_mask;
 	dev->res.name = dev_name(&dev->dev);
 }
 
@@ -663,9 +662,6 @@ int amba_device_register(struct amba_device *dev, struct resource *parent)
 	amba_device_initialize(dev, dev->dev.init_name);
 	dev->dev.init_name = NULL;
 
-	if (!dev->dev.coherent_dma_mask && dev->dma_mask)
-		dev_warn(&dev->dev, "coherent dma mask is unset\n");
-
 	return amba_device_add(dev, parent);
 }
 

commit 45f0a85c8258741d11bda25c0a5669c06267204a
Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Date:   Mon Jun 3 21:49:52 2013 +0200

    PM / Runtime: Rework the "runtime idle" helper routine
    
    The "runtime idle" helper routine, rpm_idle(), currently ignores
    return values from .runtime_idle() callbacks executed by it.
    However, it turns out that many subsystems use
    pm_generic_runtime_idle() which checks the return value of the
    driver's callback and executes pm_runtime_suspend() for the device
    unless that value is not 0.  If that logic is moved to rpm_idle()
    instead, pm_generic_runtime_idle() can be dropped and its users
    will not need any .runtime_idle() callbacks any more.
    
    Moreover, the PCI, SCSI, and SATA subsystems' .runtime_idle()
    routines, pci_pm_runtime_idle(), scsi_runtime_idle(), and
    ata_port_runtime_idle(), respectively, as well as a few drivers'
    ones may be simplified if rpm_idle() calls rpm_suspend() after 0 has
    been returned by the .runtime_idle() callback executed by it.
    
    To reduce overall code bloat, make the changes described above.
    
    Tested-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Tested-by: Kevin Hilman <khilman@linaro.org>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Kevin Hilman <khilman@linaro.org>
    Reviewed-by: Ulf Hansson <ulf.hansson@linaro.org>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>

diff --git a/drivers/amba/bus.c b/drivers/amba/bus.c
index cdbad3a454a0..c6707278a6bb 100644
--- a/drivers/amba/bus.c
+++ b/drivers/amba/bus.c
@@ -284,7 +284,7 @@ static const struct dev_pm_ops amba_pm = {
 	SET_RUNTIME_PM_OPS(
 		amba_pm_runtime_suspend,
 		amba_pm_runtime_resume,
-		pm_generic_runtime_idle
+		NULL
 	)
 };
 

commit c571b211a70bcb04249be5cb7338f95d2ec8100f
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Dec 21 13:16:42 2012 -0800

    Drivers: amba: remove __dev* attributes.
    
    CONFIG_HOTPLUG is going away as an option.  As a result, the __dev*
    markings need to be removed, as well as the use of CONFIG_HOTPLUG.
    
    This patch does both, removing the use of CONFIG_HOTPLUG in the
    amba/bus.c file, and __devinit and __devinitconst in the tegra-ahb.c
    driver.
    
    Cc: Bill Pemberton <wfp5p@virginia.edu>
    Cc: Russell King <linux@arm.linux.org.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/amba/bus.c b/drivers/amba/bus.c
index a2fc56d2e681..cdbad3a454a0 100644
--- a/drivers/amba/bus.c
+++ b/drivers/amba/bus.c
@@ -45,7 +45,6 @@ static int amba_match(struct device *dev, struct device_driver *drv)
 	return amba_lookup(pcdrv->id_table, pcdev) != NULL;
 }
 
-#ifdef CONFIG_HOTPLUG
 static int amba_uevent(struct device *dev, struct kobj_uevent_env *env)
 {
 	struct amba_device *pcdev = to_amba_device(dev);
@@ -58,9 +57,6 @@ static int amba_uevent(struct device *dev, struct kobj_uevent_env *env)
 	retval = add_uevent_var(env, "MODALIAS=amba:d%08X", pcdev->periphid);
 	return retval;
 }
-#else
-#define amba_uevent NULL
-#endif
 
 #define amba_attr_func(name,fmt,arg...)					\
 static ssize_t name##_show(struct device *_dev,				\

commit 3ad909bc8f2ea32fd7d24266c61cd4605feecec8
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Fri Nov 30 16:30:43 2012 +0100

    ARM: 7588/1: amba: create a resource parent registrator
    
    This creates amba_apb_device_add_res() and
    amba_ahb_device_add_res() respectively, to add devices with
    another parent than iomem_resource. This is needed to specify
    that a device is contained in a specific IO range.
    
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/drivers/amba/bus.c b/drivers/amba/bus.c
index e8eb91bd0d28..a2fc56d2e681 100644
--- a/drivers/amba/bus.c
+++ b/drivers/amba/bus.c
@@ -546,7 +546,8 @@ EXPORT_SYMBOL_GPL(amba_device_add);
 static struct amba_device *
 amba_aphb_device_add(struct device *parent, const char *name,
 		     resource_size_t base, size_t size, int irq1, int irq2,
-		     void *pdata, unsigned int periphid, u64 dma_mask)
+		     void *pdata, unsigned int periphid, u64 dma_mask,
+		     struct resource *resbase)
 {
 	struct amba_device *dev;
 	int ret;
@@ -563,7 +564,7 @@ amba_aphb_device_add(struct device *parent, const char *name,
 	dev->dev.platform_data = pdata;
 	dev->dev.parent = parent;
 
-	ret = amba_device_add(dev, &iomem_resource);
+	ret = amba_device_add(dev, resbase);
 	if (ret) {
 		amba_device_put(dev);
 		return ERR_PTR(ret);
@@ -578,7 +579,7 @@ amba_apb_device_add(struct device *parent, const char *name,
 		    void *pdata, unsigned int periphid)
 {
 	return amba_aphb_device_add(parent, name, base, size, irq1, irq2, pdata,
-				    periphid, 0);
+				    periphid, 0, &iomem_resource);
 }
 EXPORT_SYMBOL_GPL(amba_apb_device_add);
 
@@ -588,10 +589,33 @@ amba_ahb_device_add(struct device *parent, const char *name,
 		    void *pdata, unsigned int periphid)
 {
 	return amba_aphb_device_add(parent, name, base, size, irq1, irq2, pdata,
-				    periphid, ~0ULL);
+				    periphid, ~0ULL, &iomem_resource);
 }
 EXPORT_SYMBOL_GPL(amba_ahb_device_add);
 
+struct amba_device *
+amba_apb_device_add_res(struct device *parent, const char *name,
+			resource_size_t base, size_t size, int irq1,
+			int irq2, void *pdata, unsigned int periphid,
+			struct resource *resbase)
+{
+	return amba_aphb_device_add(parent, name, base, size, irq1, irq2, pdata,
+				    periphid, 0, resbase);
+}
+EXPORT_SYMBOL_GPL(amba_apb_device_add_res);
+
+struct amba_device *
+amba_ahb_device_add_res(struct device *parent, const char *name,
+			resource_size_t base, size_t size, int irq1,
+			int irq2, void *pdata, unsigned int periphid,
+			struct resource *resbase)
+{
+	return amba_aphb_device_add(parent, name, base, size, irq1, irq2, pdata,
+				    periphid, ~0ULL, resbase);
+}
+EXPORT_SYMBOL_GPL(amba_ahb_device_add_res);
+
+
 static void amba_device_initialize(struct amba_device *dev, const char *name)
 {
 	device_initialize(&dev->dev);

commit a875cfbb344766232e3a1a54b6e36d11cecee9ec
Author: Alessandro Rubini <rubini@gnudd.com>
Date:   Sun Jun 24 12:46:16 2012 +0100

    ARM: 7431/1: amba: use the new linux/sizes.h
    
    Signed-off-by: Alessandro Rubini <rubini@gnudd.com>
    Acked-by: Giancarlo Asnaghi <giancarlo.asnaghi@st.com>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Cc: Alan Cox <alan@linux.intel.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/drivers/amba/bus.c b/drivers/amba/bus.c
index b7e728517284..e8eb91bd0d28 100644
--- a/drivers/amba/bus.c
+++ b/drivers/amba/bus.c
@@ -16,9 +16,9 @@
 #include <linux/pm.h>
 #include <linux/pm_runtime.h>
 #include <linux/amba/bus.h>
+#include <linux/sizes.h>
 
 #include <asm/irq.h>
-#include <asm/sizes.h>
 
 #define to_amba_driver(d)	container_of(d, struct amba_driver, drv)
 

commit dfb85185bda373a70409c70c2632b02fb0f8f449
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Thu May 3 11:33:15 2012 +0100

    AMBA: get rid of last two uses of NO_IRQ
    
    This gets rid of the last two users of NO_IRQ in AMBA primecell
    drivers.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/drivers/amba/bus.c b/drivers/amba/bus.c
index 9469d8722038..b7e728517284 100644
--- a/drivers/amba/bus.c
+++ b/drivers/amba/bus.c
@@ -527,9 +527,9 @@ int amba_device_add(struct amba_device *dev, struct resource *parent)
 	if (ret)
 		goto err_release;
 
-	if (dev->irq[0] && dev->irq[0] != NO_IRQ)
+	if (dev->irq[0])
 		ret = device_create_file(&dev->dev, &dev_attr_irq0);
-	if (ret == 0 && dev->irq[1] && dev->irq[1] != NO_IRQ)
+	if (ret == 0 && dev->irq[1])
 		ret = device_create_file(&dev->dev, &dev_attr_irq1);
 	if (ret == 0)
 		return ret;

commit 6026aa907b16677d32593c5b7dea134380f51f7f
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Tue Apr 3 11:58:42 2012 +0100

    ARM: 7369/1: amba: add functions to add devices dynamically
    
    Add two functions to add APB and AHB devices to the amba (PrimeCell)
    bus dynamically. This is modeled after the static definition
    macros recently introduced into <linux/amba/bus.h> and can
    help us in factoring out a bunch of code across the kernel.
    Since a lot of call sites seem to be using a returned struct
    amba device* pointer, let's use that.
    
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/drivers/amba/bus.c b/drivers/amba/bus.c
index cc273226dbd0..9469d8722038 100644
--- a/drivers/amba/bus.c
+++ b/drivers/amba/bus.c
@@ -543,6 +543,55 @@ int amba_device_add(struct amba_device *dev, struct resource *parent)
 }
 EXPORT_SYMBOL_GPL(amba_device_add);
 
+static struct amba_device *
+amba_aphb_device_add(struct device *parent, const char *name,
+		     resource_size_t base, size_t size, int irq1, int irq2,
+		     void *pdata, unsigned int periphid, u64 dma_mask)
+{
+	struct amba_device *dev;
+	int ret;
+
+	dev = amba_device_alloc(name, base, size);
+	if (!dev)
+		return ERR_PTR(-ENOMEM);
+
+	dev->dma_mask = dma_mask;
+	dev->dev.coherent_dma_mask = dma_mask;
+	dev->irq[0] = irq1;
+	dev->irq[1] = irq2;
+	dev->periphid = periphid;
+	dev->dev.platform_data = pdata;
+	dev->dev.parent = parent;
+
+	ret = amba_device_add(dev, &iomem_resource);
+	if (ret) {
+		amba_device_put(dev);
+		return ERR_PTR(ret);
+	}
+
+	return dev;
+}
+
+struct amba_device *
+amba_apb_device_add(struct device *parent, const char *name,
+		    resource_size_t base, size_t size, int irq1, int irq2,
+		    void *pdata, unsigned int periphid)
+{
+	return amba_aphb_device_add(parent, name, base, size, irq1, irq2, pdata,
+				    periphid, 0);
+}
+EXPORT_SYMBOL_GPL(amba_apb_device_add);
+
+struct amba_device *
+amba_ahb_device_add(struct device *parent, const char *name,
+		    resource_size_t base, size_t size, int irq1, int irq2,
+		    void *pdata, unsigned int periphid)
+{
+	return amba_aphb_device_add(parent, name, base, size, irq1, irq2, pdata,
+				    periphid, ~0ULL);
+}
+EXPORT_SYMBOL_GPL(amba_ahb_device_add);
+
 static void amba_device_initialize(struct amba_device *dev, const char *name)
 {
 	device_initialize(&dev->dev);

commit 1e45860f541497d73162305d48b638d9b87e1ae3
Author: Mark Brown <broonie@sirena.org.uk>
Date:   Fri Apr 13 13:11:50 2012 +0100

    ARM: 7366/3: amba: Remove AMBA level regulator support
    
    The AMBA bus regulator support is being used to model on/off switches
    for power domains which isn't terribly idiomatic for modern kernels with
    the generic power domain code and creates integration problems on platforms
    which don't use regulators for their power domains as it's hard to tell
    the difference between a regulator that is needed but failed to be provided
    and one that isn't supposed to be there (though DT does make that easier).
    
    Platforms that wish to use the regulator API to manage their power domains
    can indirect via the power domain interface.
    
    This feature is only used with the vape supply of the db8500 PRCMU
    driver which supplies the UARTs and MMC controllers, none of which have
    support for managing vcore at runtime in mainline (only pl022 SPI
    controller does).  Update that supply to have an always_on constraint
    until the power domain support for the system is updated so that it is
    enabled for these users, this is likely to have no impact on practical
    systems as probably at least one of these devices will be active and
    cause AMBA to hold the supply on anyway.
    
    Signed-off-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Tested-by: Shawn Guo <shawn.guo@linaro.org>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/drivers/amba/bus.c b/drivers/amba/bus.c
index 01c2cf4efcdd..cc273226dbd0 100644
--- a/drivers/amba/bus.c
+++ b/drivers/amba/bus.c
@@ -247,8 +247,7 @@ static int amba_pm_restore(struct device *dev)
 /*
  * Hooks to provide runtime PM of the pclk (bus clock).  It is safe to
  * enable/disable the bus clock at runtime PM suspend/resume as this
- * does not result in loss of context.  However, disabling vcore power
- * would do, so we leave that to the driver.
+ * does not result in loss of context.
  */
 static int amba_pm_runtime_suspend(struct device *dev)
 {
@@ -354,39 +353,6 @@ static void amba_put_disable_pclk(struct amba_device *pcdev)
 	clk_put(pclk);
 }
 
-static int amba_get_enable_vcore(struct amba_device *pcdev)
-{
-	struct regulator *vcore = regulator_get(&pcdev->dev, "vcore");
-	int ret;
-
-	pcdev->vcore = vcore;
-
-	if (IS_ERR(vcore)) {
-		/* It is OK not to supply a vcore regulator */
-		if (PTR_ERR(vcore) == -ENODEV)
-			return 0;
-		return PTR_ERR(vcore);
-	}
-
-	ret = regulator_enable(vcore);
-	if (ret) {
-		regulator_put(vcore);
-		pcdev->vcore = ERR_PTR(-ENODEV);
-	}
-
-	return ret;
-}
-
-static void amba_put_disable_vcore(struct amba_device *pcdev)
-{
-	struct regulator *vcore = pcdev->vcore;
-
-	if (!IS_ERR(vcore)) {
-		regulator_disable(vcore);
-		regulator_put(vcore);
-	}
-}
-
 /*
  * These are the device model conversion veneers; they convert the
  * device model structures to our more specific structures.
@@ -399,10 +365,6 @@ static int amba_probe(struct device *dev)
 	int ret;
 
 	do {
-		ret = amba_get_enable_vcore(pcdev);
-		if (ret)
-			break;
-
 		ret = amba_get_enable_pclk(pcdev);
 		if (ret)
 			break;
@@ -420,7 +382,6 @@ static int amba_probe(struct device *dev)
 		pm_runtime_put_noidle(dev);
 
 		amba_put_disable_pclk(pcdev);
-		amba_put_disable_vcore(pcdev);
 	} while (0);
 
 	return ret;
@@ -442,7 +403,6 @@ static int amba_remove(struct device *dev)
 	pm_runtime_put_noidle(dev);
 
 	amba_put_disable_pclk(pcdev);
-	amba_put_disable_vcore(pcdev);
 
 	return ret;
 }

commit 2eac58d5026e4ec8b17ff8b62877fea9e1d2f1b3
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Sun Dec 18 11:43:56 2011 +0000

    ARM: amba: make use of -1 IRQs warn
    
    Make the core warn about the use of -1 (NO_IRQ)
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/drivers/amba/bus.c b/drivers/amba/bus.c
index d15acbb4d59e..01c2cf4efcdd 100644
--- a/drivers/amba/bus.c
+++ b/drivers/amba/bus.c
@@ -511,6 +511,9 @@ int amba_device_add(struct amba_device *dev, struct resource *parent)
 	void __iomem *tmp;
 	int i, ret;
 
+	WARN_ON(dev->irq[0] == (unsigned int)-1);
+	WARN_ON(dev->irq[1] == (unsigned int)-1);
+
 	ret = request_resource(parent, &dev->res);
 	if (ret)
 		goto err_out;

commit 023f117c547719fbc087ad72276aec5a026370df
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Sun Dec 18 11:31:51 2011 +0000

    ARM: amba: make irq 0 invalid
    
    Fix core bus and MMCI such that irq 0 means that there is no IRQ
    attached.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/drivers/amba/bus.c b/drivers/amba/bus.c
index 82b65e1e12bf..d15acbb4d59e 100644
--- a/drivers/amba/bus.c
+++ b/drivers/amba/bus.c
@@ -564,9 +564,9 @@ int amba_device_add(struct amba_device *dev, struct resource *parent)
 	if (ret)
 		goto err_release;
 
-	if (dev->irq[0] != NO_IRQ)
+	if (dev->irq[0] && dev->irq[0] != NO_IRQ)
 		ret = device_create_file(&dev->dev, &dev_attr_irq0);
-	if (ret == 0 && dev->irq[1] != NO_IRQ)
+	if (ret == 0 && dev->irq[1] && dev->irq[1] != NO_IRQ)
 		ret = device_create_file(&dev->dev, &dev_attr_irq1);
 	if (ret == 0)
 		return ret;

commit d5dc9271b25822f36d299f8cab985379743424b9
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Sun Dec 18 11:07:47 2011 +0000

    ARM: amba: add amba_device allocation/add/put functions
    
    Add functions to allocate and initialize AMBA device structures, and
    add them to the Linux device manager.  This allows us to kill this
    type of operation from individual platforms, moving it to core code.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/drivers/amba/bus.c b/drivers/amba/bus.c
index 54eaf96ab217..82b65e1e12bf 100644
--- a/drivers/amba/bus.c
+++ b/drivers/amba/bus.c
@@ -497,38 +497,20 @@ static void amba_device_release(struct device *dev)
 }
 
 /**
- *	amba_device_register - register an AMBA device
- *	@dev: AMBA device to register
- *	@parent: parent memory resource
+ *	amba_device_add - add a previously allocated AMBA device structure
+ *	@dev: AMBA device allocated by amba_device_alloc
+ *	@parent: resource parent for this devices resources
  *
- *	Setup the AMBA device, reading the cell ID if present.
- *	Claim the resource, and register the AMBA device with
- *	the Linux device manager.
+ *	Claim the resource, and read the device cell ID if not already
+ *	initialized.  Register the AMBA device with the Linux device
+ *	manager.
  */
-int amba_device_register(struct amba_device *dev, struct resource *parent)
+int amba_device_add(struct amba_device *dev, struct resource *parent)
 {
 	u32 size;
 	void __iomem *tmp;
 	int i, ret;
 
-	device_initialize(&dev->dev);
-
-	/*
-	 * Copy from device_add
-	 */
-	if (dev->dev.init_name) {
-		dev_set_name(&dev->dev, "%s", dev->dev.init_name);
-		dev->dev.init_name = NULL;
-	}
-
-	dev->dev.release = amba_device_release;
-	dev->dev.bus = &amba_bustype;
-	dev->dev.dma_mask = &dev->dma_mask;
-	dev->res.name = dev_name(&dev->dev);
-
-	if (!dev->dev.coherent_dma_mask && dev->dma_mask)
-		dev_warn(&dev->dev, "coherent dma mask is unset\n");
-
 	ret = request_resource(parent, &dev->res);
 	if (ret)
 		goto err_out;
@@ -596,6 +578,74 @@ int amba_device_register(struct amba_device *dev, struct resource *parent)
  err_out:
 	return ret;
 }
+EXPORT_SYMBOL_GPL(amba_device_add);
+
+static void amba_device_initialize(struct amba_device *dev, const char *name)
+{
+	device_initialize(&dev->dev);
+	if (name)
+		dev_set_name(&dev->dev, "%s", name);
+	dev->dev.release = amba_device_release;
+	dev->dev.bus = &amba_bustype;
+	dev->dev.dma_mask = &dev->dma_mask;
+	dev->res.name = dev_name(&dev->dev);
+}
+
+/**
+ *	amba_device_alloc - allocate an AMBA device
+ *	@name: sysfs name of the AMBA device
+ *	@base: base of AMBA device
+ *	@size: size of AMBA device
+ *
+ *	Allocate and initialize an AMBA device structure.  Returns %NULL
+ *	on failure.
+ */
+struct amba_device *amba_device_alloc(const char *name, resource_size_t base,
+	size_t size)
+{
+	struct amba_device *dev;
+
+	dev = kzalloc(sizeof(*dev), GFP_KERNEL);
+	if (dev) {
+		amba_device_initialize(dev, name);
+		dev->res.start = base;
+		dev->res.end = base + size - 1;
+		dev->res.flags = IORESOURCE_MEM;
+	}
+
+	return dev;
+}
+EXPORT_SYMBOL_GPL(amba_device_alloc);
+
+/**
+ *	amba_device_register - register an AMBA device
+ *	@dev: AMBA device to register
+ *	@parent: parent memory resource
+ *
+ *	Setup the AMBA device, reading the cell ID if present.
+ *	Claim the resource, and register the AMBA device with
+ *	the Linux device manager.
+ */
+int amba_device_register(struct amba_device *dev, struct resource *parent)
+{
+	amba_device_initialize(dev, dev->dev.init_name);
+	dev->dev.init_name = NULL;
+
+	if (!dev->dev.coherent_dma_mask && dev->dma_mask)
+		dev_warn(&dev->dev, "coherent dma mask is unset\n");
+
+	return amba_device_add(dev, parent);
+}
+
+/**
+ *	amba_device_put - put an AMBA device
+ *	@dev: AMBA device to put
+ */
+void amba_device_put(struct amba_device *dev)
+{
+	put_device(&dev->dev);
+}
+EXPORT_SYMBOL_GPL(amba_device_put);
 
 /**
  *	amba_device_unregister - unregister an AMBA device

commit eb59c505f8a5906ad2e053d14fab50eb8574fd6f
Merge: 1619ed8f6095 c233523b3d39
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Jan 8 13:10:57 2012 -0800

    Merge branch 'pm-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm
    
    * 'pm-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm: (76 commits)
      PM / Hibernate: Implement compat_ioctl for /dev/snapshot
      PM / Freezer: fix return value of freezable_schedule_timeout_killable()
      PM / shmobile: Allow the A4R domain to be turned off at run time
      PM / input / touchscreen: Make st1232 use device PM QoS constraints
      PM / QoS: Introduce dev_pm_qos_add_ancestor_request()
      PM / shmobile: Remove the stay_on flag from SH7372's PM domains
      PM / shmobile: Don't include SH7372's INTCS in syscore suspend/resume
      PM / shmobile: Add support for the sh7372 A4S power domain / sleep mode
      PM: Drop generic_subsys_pm_ops
      PM / Sleep: Remove forward-only callbacks from AMBA bus type
      PM / Sleep: Remove forward-only callbacks from platform bus type
      PM: Run the driver callback directly if the subsystem one is not there
      PM / Sleep: Make pm_op() and pm_noirq_op() return callback pointers
      PM/Devfreq: Add Exynos4-bus device DVFS driver for Exynos4210/4212/4412.
      PM / Sleep: Merge internal functions in generic_ops.c
      PM / Sleep: Simplify generic system suspend callbacks
      PM / Hibernate: Remove deprecated hibernation snapshot ioctls
      PM / Sleep: Fix freezer failures due to racy usermodehelper_is_disabled()
      ARM: S3C64XX: Implement basic power domain support
      PM / shmobile: Use common always on power domain governor
      ...
    
    Fix up trivial conflict in fs/xfs/xfs_buf.c due to removal of unused
    XBT_FORCE_SLEEP bit

commit 8114ab763b2d297c8af49bf380a093d76e929692
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Sun Dec 18 00:34:31 2011 +0100

    PM / Sleep: Remove forward-only callbacks from AMBA bus type
    
    The forward-only PM callbacks provided by the AMBA bus type are not
    necessary any more, because the PM core executes driver callbacks
    when the corresponding subsystem callbacks are not present, so drop
    them.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/drivers/amba/bus.c b/drivers/amba/bus.c
index bd230e801131..0304b3fdff5a 100644
--- a/drivers/amba/bus.c
+++ b/drivers/amba/bus.c
@@ -109,31 +109,7 @@ static int amba_legacy_resume(struct device *dev)
 	return ret;
 }
 
-static int amba_pm_prepare(struct device *dev)
-{
-	struct device_driver *drv = dev->driver;
-	int ret = 0;
-
-	if (drv && drv->pm && drv->pm->prepare)
-		ret = drv->pm->prepare(dev);
-
-	return ret;
-}
-
-static void amba_pm_complete(struct device *dev)
-{
-	struct device_driver *drv = dev->driver;
-
-	if (drv && drv->pm && drv->pm->complete)
-		drv->pm->complete(dev);
-}
-
-#else /* !CONFIG_PM_SLEEP */
-
-#define amba_pm_prepare		NULL
-#define amba_pm_complete		NULL
-
-#endif /* !CONFIG_PM_SLEEP */
+#endif /* CONFIG_PM_SLEEP */
 
 #ifdef CONFIG_SUSPEND
 
@@ -155,22 +131,6 @@ static int amba_pm_suspend(struct device *dev)
 	return ret;
 }
 
-static int amba_pm_suspend_noirq(struct device *dev)
-{
-	struct device_driver *drv = dev->driver;
-	int ret = 0;
-
-	if (!drv)
-		return 0;
-
-	if (drv->pm) {
-		if (drv->pm->suspend_noirq)
-			ret = drv->pm->suspend_noirq(dev);
-	}
-
-	return ret;
-}
-
 static int amba_pm_resume(struct device *dev)
 {
 	struct device_driver *drv = dev->driver;
@@ -189,28 +149,10 @@ static int amba_pm_resume(struct device *dev)
 	return ret;
 }
 
-static int amba_pm_resume_noirq(struct device *dev)
-{
-	struct device_driver *drv = dev->driver;
-	int ret = 0;
-
-	if (!drv)
-		return 0;
-
-	if (drv->pm) {
-		if (drv->pm->resume_noirq)
-			ret = drv->pm->resume_noirq(dev);
-	}
-
-	return ret;
-}
-
 #else /* !CONFIG_SUSPEND */
 
 #define amba_pm_suspend		NULL
 #define amba_pm_resume		NULL
-#define amba_pm_suspend_noirq	NULL
-#define amba_pm_resume_noirq	NULL
 
 #endif /* !CONFIG_SUSPEND */
 
@@ -234,22 +176,6 @@ static int amba_pm_freeze(struct device *dev)
 	return ret;
 }
 
-static int amba_pm_freeze_noirq(struct device *dev)
-{
-	struct device_driver *drv = dev->driver;
-	int ret = 0;
-
-	if (!drv)
-		return 0;
-
-	if (drv->pm) {
-		if (drv->pm->freeze_noirq)
-			ret = drv->pm->freeze_noirq(dev);
-	}
-
-	return ret;
-}
-
 static int amba_pm_thaw(struct device *dev)
 {
 	struct device_driver *drv = dev->driver;
@@ -268,22 +194,6 @@ static int amba_pm_thaw(struct device *dev)
 	return ret;
 }
 
-static int amba_pm_thaw_noirq(struct device *dev)
-{
-	struct device_driver *drv = dev->driver;
-	int ret = 0;
-
-	if (!drv)
-		return 0;
-
-	if (drv->pm) {
-		if (drv->pm->thaw_noirq)
-			ret = drv->pm->thaw_noirq(dev);
-	}
-
-	return ret;
-}
-
 static int amba_pm_poweroff(struct device *dev)
 {
 	struct device_driver *drv = dev->driver;
@@ -302,22 +212,6 @@ static int amba_pm_poweroff(struct device *dev)
 	return ret;
 }
 
-static int amba_pm_poweroff_noirq(struct device *dev)
-{
-	struct device_driver *drv = dev->driver;
-	int ret = 0;
-
-	if (!drv)
-		return 0;
-
-	if (drv->pm) {
-		if (drv->pm->poweroff_noirq)
-			ret = drv->pm->poweroff_noirq(dev);
-	}
-
-	return ret;
-}
-
 static int amba_pm_restore(struct device *dev)
 {
 	struct device_driver *drv = dev->driver;
@@ -336,32 +230,12 @@ static int amba_pm_restore(struct device *dev)
 	return ret;
 }
 
-static int amba_pm_restore_noirq(struct device *dev)
-{
-	struct device_driver *drv = dev->driver;
-	int ret = 0;
-
-	if (!drv)
-		return 0;
-
-	if (drv->pm) {
-		if (drv->pm->restore_noirq)
-			ret = drv->pm->restore_noirq(dev);
-	}
-
-	return ret;
-}
-
 #else /* !CONFIG_HIBERNATE_CALLBACKS */
 
 #define amba_pm_freeze		NULL
 #define amba_pm_thaw		NULL
 #define amba_pm_poweroff		NULL
 #define amba_pm_restore		NULL
-#define amba_pm_freeze_noirq	NULL
-#define amba_pm_thaw_noirq		NULL
-#define amba_pm_poweroff_noirq	NULL
-#define amba_pm_restore_noirq	NULL
 
 #endif /* !CONFIG_HIBERNATE_CALLBACKS */
 
@@ -402,20 +276,12 @@ static int amba_pm_runtime_resume(struct device *dev)
 #ifdef CONFIG_PM
 
 static const struct dev_pm_ops amba_pm = {
-	.prepare	= amba_pm_prepare,
-	.complete	= amba_pm_complete,
 	.suspend	= amba_pm_suspend,
 	.resume		= amba_pm_resume,
 	.freeze		= amba_pm_freeze,
 	.thaw		= amba_pm_thaw,
 	.poweroff	= amba_pm_poweroff,
 	.restore	= amba_pm_restore,
-	.suspend_noirq	= amba_pm_suspend_noirq,
-	.resume_noirq	= amba_pm_resume_noirq,
-	.freeze_noirq	= amba_pm_freeze_noirq,
-	.thaw_noirq	= amba_pm_thaw_noirq,
-	.poweroff_noirq	= amba_pm_poweroff_noirq,
-	.restore_noirq	= amba_pm_restore_noirq,
 	SET_RUNTIME_PM_OPS(
 		amba_pm_runtime_suspend,
 		amba_pm_runtime_resume,

commit 523817bd22617cd62199ae4ca2a6f5e1aa250654
Author: Dave Martin <dave.martin@linaro.org>
Date:   Wed Oct 5 14:44:57 2011 +0100

    ARM: amba: Auto-generate AMBA driver module aliases during modpost
    
    This patch adds the necessary support in file2alias.c to define
    suitable aliases based on the amba_id table in AMBA driver modules.
    
    This should be sufficient to allow such modules to be auto-loaded
    via udev.  The AMBA bus driver's uevent hotplug code is also
    modified to pass an approriate MODALIAS string in the event.
    
    For simplicity, the AMBA ID is treated an an opaque 32-bit numeber.
    Module alises use patterns as appropriate to describe the value-
    mask pairs described in the driver's amba_id list.
    
    The proposed alias format is (extended regex):
    
        ^amba:d(HEX){8}$
    
    Where HEX is a single upper-case HEX digit or a pattern (? or []
    expression) matching a single upper-case HEX digit, as expected by
    udev.
    
    "d" is short for "device", following existing alias naming
    conventions for other device types.  This adds some flexibility for
    unambiguously extending the alias format in the future by adding
    additional leading and trailing fields, if this turns out to be
    necessary.
    
    Signed-off-by: Dave Martin <dave.martin@linaro.org>
    Acked-by: Pawel Moll <pawel.moll@arm.com>

diff --git a/drivers/amba/bus.c b/drivers/amba/bus.c
index bd230e801131..936c98cb2475 100644
--- a/drivers/amba/bus.c
+++ b/drivers/amba/bus.c
@@ -52,6 +52,10 @@ static int amba_uevent(struct device *dev, struct kobj_uevent_env *env)
 	int retval = 0;
 
 	retval = add_uevent_var(env, "AMBA_ID=%08x", pcdev->periphid);
+	if (retval)
+		return retval;
+
+	retval = add_uevent_var(env, "MODALIAS=amba:d%08X", pcdev->periphid);
 	return retval;
 }
 #else

commit ac3e2fa6770052a82d42fc4db194a27317518c97
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Thu Sep 22 12:20:55 2011 +0100

    clk: amba bus: convert to clk_prepare()/clk_unprepare()
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/drivers/amba/bus.c b/drivers/amba/bus.c
index 84bdaace56c8..bd230e801131 100644
--- a/drivers/amba/bus.c
+++ b/drivers/amba/bus.c
@@ -460,9 +460,17 @@ static int amba_get_enable_pclk(struct amba_device *pcdev)
 	if (IS_ERR(pclk))
 		return PTR_ERR(pclk);
 
+	ret = clk_prepare(pclk);
+	if (ret) {
+		clk_put(pclk);
+		return ret;
+	}
+
 	ret = clk_enable(pclk);
-	if (ret)
+	if (ret) {
+		clk_unprepare(pclk);
 		clk_put(pclk);
+	}
 
 	return ret;
 }
@@ -472,6 +480,7 @@ static void amba_put_disable_pclk(struct amba_device *pcdev)
 	struct clk *pclk = pcdev->pclk;
 
 	clk_disable(pclk);
+	clk_unprepare(pclk);
 	clk_put(pclk);
 }
 

commit 92b97f0aaccbf9de4a29696e6253bf82e8850d1d
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Sun Aug 14 09:13:48 2011 +0100

    PM: add runtime PM support to core Primecell driver
    
    Add runtime PM support to the core Primecell driver, following the PCI
    model of how this is done.
    
    Rather than having every driver fiddle about with enabling runtime PM,
    that's dealt with in the core and instead, drivers just do a put() in
    their probe and a balancing get() in their remove function to activate
    runtime PM for the device.
    
    As we're dealing with enabling runtime PM in the core, fix up spi-pl022
    as it must not enable and disable runtime PM itself anymore.
    
    Tested-by: Linus Walleij <linus.walleij@linaro.org>
    Acked-by: Rafael J. Wysocki <rjw@sisk.pl>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/drivers/amba/bus.c b/drivers/amba/bus.c
index d74926e0939e..84bdaace56c8 100644
--- a/drivers/amba/bus.c
+++ b/drivers/amba/bus.c
@@ -365,6 +365,40 @@ static int amba_pm_restore_noirq(struct device *dev)
 
 #endif /* !CONFIG_HIBERNATE_CALLBACKS */
 
+#ifdef CONFIG_PM_RUNTIME
+/*
+ * Hooks to provide runtime PM of the pclk (bus clock).  It is safe to
+ * enable/disable the bus clock at runtime PM suspend/resume as this
+ * does not result in loss of context.  However, disabling vcore power
+ * would do, so we leave that to the driver.
+ */
+static int amba_pm_runtime_suspend(struct device *dev)
+{
+	struct amba_device *pcdev = to_amba_device(dev);
+	int ret = pm_generic_runtime_suspend(dev);
+
+	if (ret == 0 && dev->driver)
+		clk_disable(pcdev->pclk);
+
+	return ret;
+}
+
+static int amba_pm_runtime_resume(struct device *dev)
+{
+	struct amba_device *pcdev = to_amba_device(dev);
+	int ret;
+
+	if (dev->driver) {
+		ret = clk_enable(pcdev->pclk);
+		/* Failure is probably fatal to the system, but... */
+		if (ret)
+			return ret;
+	}
+
+	return pm_generic_runtime_resume(dev);
+}
+#endif
+
 #ifdef CONFIG_PM
 
 static const struct dev_pm_ops amba_pm = {
@@ -383,8 +417,8 @@ static const struct dev_pm_ops amba_pm = {
 	.poweroff_noirq	= amba_pm_poweroff_noirq,
 	.restore_noirq	= amba_pm_restore_noirq,
 	SET_RUNTIME_PM_OPS(
-		pm_generic_runtime_suspend,
-		pm_generic_runtime_resume,
+		amba_pm_runtime_suspend,
+		amba_pm_runtime_resume,
 		pm_generic_runtime_idle
 	)
 };
@@ -494,10 +528,18 @@ static int amba_probe(struct device *dev)
 		if (ret)
 			break;
 
+		pm_runtime_get_noresume(dev);
+		pm_runtime_set_active(dev);
+		pm_runtime_enable(dev);
+
 		ret = pcdrv->probe(pcdev, id);
 		if (ret == 0)
 			break;
 
+		pm_runtime_disable(dev);
+		pm_runtime_set_suspended(dev);
+		pm_runtime_put_noidle(dev);
+
 		amba_put_disable_pclk(pcdev);
 		amba_put_disable_vcore(pcdev);
 	} while (0);
@@ -509,7 +551,16 @@ static int amba_remove(struct device *dev)
 {
 	struct amba_device *pcdev = to_amba_device(dev);
 	struct amba_driver *drv = to_amba_driver(dev->driver);
-	int ret = drv->remove(pcdev);
+	int ret;
+
+	pm_runtime_get_sync(dev);
+	ret = drv->remove(pcdev);
+	pm_runtime_put_noidle(dev);
+
+	/* Undo the runtime PM settings in amba_probe() */
+	pm_runtime_disable(dev);
+	pm_runtime_set_suspended(dev);
+	pm_runtime_put_noidle(dev);
 
 	amba_put_disable_pclk(pcdev);
 	amba_put_disable_vcore(pcdev);

commit 97ceed1fc29b601e64af98fd785e25fec4383b12
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Thu Mar 24 16:12:40 2011 +0100

    ARM: 6829/1: amba: make hardcoded periphid override hardware
    
    This makes a hardcoded periphid from the platform override any
    magic number found in the hardware. This shall henceforth be used
    when the information found in the hardware is either missing,
    i.e. not encoding the CID with the magic cookie 0xb105f00d, or
    incorrect such that the revision number should have been bumped in
    hardware, but the silicon designer has failed to do so.
    
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/drivers/amba/bus.c b/drivers/amba/bus.c
index 7025593a58c8..d74926e0939e 100644
--- a/drivers/amba/bus.c
+++ b/drivers/amba/bus.c
@@ -603,6 +603,10 @@ int amba_device_register(struct amba_device *dev, struct resource *parent)
 	if (ret)
 		goto err_out;
 
+	/* Hard-coded primecell ID instead of plug-n-play */
+	if (dev->periphid != 0)
+		goto skip_probe;
+
 	/*
 	 * Dynamically calculate the size of the resource
 	 * and use this for iomap
@@ -643,6 +647,7 @@ int amba_device_register(struct amba_device *dev, struct resource *parent)
 	if (ret)
 		goto err_release;
 
+ skip_probe:
 	ret = device_add(&dev->dev);
 	if (ret)
 		goto err_release;

commit 1f112cee07b314e244ee9e71d9c1e6950dc13327
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Mon Apr 11 22:54:42 2011 +0200

    PM / Hibernate: Introduce CONFIG_HIBERNATE_CALLBACKS
    
    Xen save/restore is going to use hibernate device callbacks for
    quiescing devices and putting them back to normal operations and it
    would need to select CONFIG_HIBERNATION for this purpose.  However,
    that also would cause the hibernate interfaces for user space to be
    enabled, which might confuse user space, because the Xen kernels
    don't support hibernation.  Moreover, it would be wasteful, as it
    would make the Xen kernels include a substantial amount of code that
    they would never use.
    
    To address this issue introduce new power management Kconfig option
    CONFIG_HIBERNATE_CALLBACKS, such that it will only select the code
    that is necessary for the hibernate device callbacks to work and make
    CONFIG_HIBERNATION select it.  Then, Xen save/restore will be able to
    select CONFIG_HIBERNATE_CALLBACKS without dragging the entire
    hibernate code along with it.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>
    Tested-by: Shriram Rajagopalan <rshriram@cs.ubc.ca>

diff --git a/drivers/amba/bus.c b/drivers/amba/bus.c
index 821040503154..7025593a58c8 100644
--- a/drivers/amba/bus.c
+++ b/drivers/amba/bus.c
@@ -214,7 +214,7 @@ static int amba_pm_resume_noirq(struct device *dev)
 
 #endif /* !CONFIG_SUSPEND */
 
-#ifdef CONFIG_HIBERNATION
+#ifdef CONFIG_HIBERNATE_CALLBACKS
 
 static int amba_pm_freeze(struct device *dev)
 {
@@ -352,7 +352,7 @@ static int amba_pm_restore_noirq(struct device *dev)
 	return ret;
 }
 
-#else /* !CONFIG_HIBERNATION */
+#else /* !CONFIG_HIBERNATE_CALLBACKS */
 
 #define amba_pm_freeze		NULL
 #define amba_pm_thaw		NULL
@@ -363,7 +363,7 @@ static int amba_pm_restore_noirq(struct device *dev)
 #define amba_pm_poweroff_noirq	NULL
 #define amba_pm_restore_noirq	NULL
 
-#endif /* !CONFIG_HIBERNATION */
+#endif /* !CONFIG_HIBERNATE_CALLBACKS */
 
 #ifdef CONFIG_PM
 

commit 25985edcedea6396277003854657b5f3cb31a628
Author: Lucas De Marchi <lucas.demarchi@profusion.mobi>
Date:   Wed Mar 30 22:57:33 2011 -0300

    Fix common misspellings
    
    Fixes generated by 'codespell' and manually reviewed.
    
    Signed-off-by: Lucas De Marchi <lucas.demarchi@profusion.mobi>

diff --git a/drivers/amba/bus.c b/drivers/amba/bus.c
index 6d2bb2524b6e..821040503154 100644
--- a/drivers/amba/bus.c
+++ b/drivers/amba/bus.c
@@ -760,7 +760,7 @@ int amba_request_regions(struct amba_device *dev, const char *name)
 }
 
 /**
- *	amba_release_regions - release mem regions assoicated with device
+ *	amba_release_regions - release mem regions associated with device
  *	@dev: amba_device structure for device
  *
  *	Release regions claimed by a successful call to amba_request_regions.

commit ba74ec7f6b2bf9e1b5d0f2c5cef08766944cb2c8
Author: Rabin Vincent <rabin.vincent@stericsson.com>
Date:   Wed Feb 23 04:33:17 2011 +0100

    ARM: 6758/1: amba: support pm ops
    
    Support pm_ops in the AMBA bus, required to allow drivers to use runtime pm.
    The implementation of AMBA bus pm ops is based on the platform bus
    implementation.
    
    Acked-by: Rafael J. Wysocki <rjw@sisk.pl>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Rabin Vincent <rabin.vincent@stericsson.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/drivers/amba/bus.c b/drivers/amba/bus.c
index 43088996a07a..6d2bb2524b6e 100644
--- a/drivers/amba/bus.c
+++ b/drivers/amba/bus.c
@@ -13,12 +13,13 @@
 #include <linux/string.h>
 #include <linux/slab.h>
 #include <linux/io.h>
+#include <linux/pm.h>
+#include <linux/pm_runtime.h>
 #include <linux/amba/bus.h>
 
 #include <asm/irq.h>
 #include <asm/sizes.h>
 
-#define to_amba_device(d)	container_of(d, struct amba_device, dev)
 #define to_amba_driver(d)	container_of(d, struct amba_driver, drv)
 
 static const struct amba_id *
@@ -57,26 +58,6 @@ static int amba_uevent(struct device *dev, struct kobj_uevent_env *env)
 #define amba_uevent NULL
 #endif
 
-static int amba_suspend(struct device *dev, pm_message_t state)
-{
-	struct amba_driver *drv = to_amba_driver(dev->driver);
-	int ret = 0;
-
-	if (dev->driver && drv->suspend)
-		ret = drv->suspend(to_amba_device(dev), state);
-	return ret;
-}
-
-static int amba_resume(struct device *dev)
-{
-	struct amba_driver *drv = to_amba_driver(dev->driver);
-	int ret = 0;
-
-	if (dev->driver && drv->resume)
-		ret = drv->resume(to_amba_device(dev));
-	return ret;
-}
-
 #define amba_attr_func(name,fmt,arg...)					\
 static ssize_t name##_show(struct device *_dev,				\
 			   struct device_attribute *attr, char *buf)	\
@@ -102,6 +83,320 @@ static struct device_attribute amba_dev_attrs[] = {
 	__ATTR_NULL,
 };
 
+#ifdef CONFIG_PM_SLEEP
+
+static int amba_legacy_suspend(struct device *dev, pm_message_t mesg)
+{
+	struct amba_driver *adrv = to_amba_driver(dev->driver);
+	struct amba_device *adev = to_amba_device(dev);
+	int ret = 0;
+
+	if (dev->driver && adrv->suspend)
+		ret = adrv->suspend(adev, mesg);
+
+	return ret;
+}
+
+static int amba_legacy_resume(struct device *dev)
+{
+	struct amba_driver *adrv = to_amba_driver(dev->driver);
+	struct amba_device *adev = to_amba_device(dev);
+	int ret = 0;
+
+	if (dev->driver && adrv->resume)
+		ret = adrv->resume(adev);
+
+	return ret;
+}
+
+static int amba_pm_prepare(struct device *dev)
+{
+	struct device_driver *drv = dev->driver;
+	int ret = 0;
+
+	if (drv && drv->pm && drv->pm->prepare)
+		ret = drv->pm->prepare(dev);
+
+	return ret;
+}
+
+static void amba_pm_complete(struct device *dev)
+{
+	struct device_driver *drv = dev->driver;
+
+	if (drv && drv->pm && drv->pm->complete)
+		drv->pm->complete(dev);
+}
+
+#else /* !CONFIG_PM_SLEEP */
+
+#define amba_pm_prepare		NULL
+#define amba_pm_complete		NULL
+
+#endif /* !CONFIG_PM_SLEEP */
+
+#ifdef CONFIG_SUSPEND
+
+static int amba_pm_suspend(struct device *dev)
+{
+	struct device_driver *drv = dev->driver;
+	int ret = 0;
+
+	if (!drv)
+		return 0;
+
+	if (drv->pm) {
+		if (drv->pm->suspend)
+			ret = drv->pm->suspend(dev);
+	} else {
+		ret = amba_legacy_suspend(dev, PMSG_SUSPEND);
+	}
+
+	return ret;
+}
+
+static int amba_pm_suspend_noirq(struct device *dev)
+{
+	struct device_driver *drv = dev->driver;
+	int ret = 0;
+
+	if (!drv)
+		return 0;
+
+	if (drv->pm) {
+		if (drv->pm->suspend_noirq)
+			ret = drv->pm->suspend_noirq(dev);
+	}
+
+	return ret;
+}
+
+static int amba_pm_resume(struct device *dev)
+{
+	struct device_driver *drv = dev->driver;
+	int ret = 0;
+
+	if (!drv)
+		return 0;
+
+	if (drv->pm) {
+		if (drv->pm->resume)
+			ret = drv->pm->resume(dev);
+	} else {
+		ret = amba_legacy_resume(dev);
+	}
+
+	return ret;
+}
+
+static int amba_pm_resume_noirq(struct device *dev)
+{
+	struct device_driver *drv = dev->driver;
+	int ret = 0;
+
+	if (!drv)
+		return 0;
+
+	if (drv->pm) {
+		if (drv->pm->resume_noirq)
+			ret = drv->pm->resume_noirq(dev);
+	}
+
+	return ret;
+}
+
+#else /* !CONFIG_SUSPEND */
+
+#define amba_pm_suspend		NULL
+#define amba_pm_resume		NULL
+#define amba_pm_suspend_noirq	NULL
+#define amba_pm_resume_noirq	NULL
+
+#endif /* !CONFIG_SUSPEND */
+
+#ifdef CONFIG_HIBERNATION
+
+static int amba_pm_freeze(struct device *dev)
+{
+	struct device_driver *drv = dev->driver;
+	int ret = 0;
+
+	if (!drv)
+		return 0;
+
+	if (drv->pm) {
+		if (drv->pm->freeze)
+			ret = drv->pm->freeze(dev);
+	} else {
+		ret = amba_legacy_suspend(dev, PMSG_FREEZE);
+	}
+
+	return ret;
+}
+
+static int amba_pm_freeze_noirq(struct device *dev)
+{
+	struct device_driver *drv = dev->driver;
+	int ret = 0;
+
+	if (!drv)
+		return 0;
+
+	if (drv->pm) {
+		if (drv->pm->freeze_noirq)
+			ret = drv->pm->freeze_noirq(dev);
+	}
+
+	return ret;
+}
+
+static int amba_pm_thaw(struct device *dev)
+{
+	struct device_driver *drv = dev->driver;
+	int ret = 0;
+
+	if (!drv)
+		return 0;
+
+	if (drv->pm) {
+		if (drv->pm->thaw)
+			ret = drv->pm->thaw(dev);
+	} else {
+		ret = amba_legacy_resume(dev);
+	}
+
+	return ret;
+}
+
+static int amba_pm_thaw_noirq(struct device *dev)
+{
+	struct device_driver *drv = dev->driver;
+	int ret = 0;
+
+	if (!drv)
+		return 0;
+
+	if (drv->pm) {
+		if (drv->pm->thaw_noirq)
+			ret = drv->pm->thaw_noirq(dev);
+	}
+
+	return ret;
+}
+
+static int amba_pm_poweroff(struct device *dev)
+{
+	struct device_driver *drv = dev->driver;
+	int ret = 0;
+
+	if (!drv)
+		return 0;
+
+	if (drv->pm) {
+		if (drv->pm->poweroff)
+			ret = drv->pm->poweroff(dev);
+	} else {
+		ret = amba_legacy_suspend(dev, PMSG_HIBERNATE);
+	}
+
+	return ret;
+}
+
+static int amba_pm_poweroff_noirq(struct device *dev)
+{
+	struct device_driver *drv = dev->driver;
+	int ret = 0;
+
+	if (!drv)
+		return 0;
+
+	if (drv->pm) {
+		if (drv->pm->poweroff_noirq)
+			ret = drv->pm->poweroff_noirq(dev);
+	}
+
+	return ret;
+}
+
+static int amba_pm_restore(struct device *dev)
+{
+	struct device_driver *drv = dev->driver;
+	int ret = 0;
+
+	if (!drv)
+		return 0;
+
+	if (drv->pm) {
+		if (drv->pm->restore)
+			ret = drv->pm->restore(dev);
+	} else {
+		ret = amba_legacy_resume(dev);
+	}
+
+	return ret;
+}
+
+static int amba_pm_restore_noirq(struct device *dev)
+{
+	struct device_driver *drv = dev->driver;
+	int ret = 0;
+
+	if (!drv)
+		return 0;
+
+	if (drv->pm) {
+		if (drv->pm->restore_noirq)
+			ret = drv->pm->restore_noirq(dev);
+	}
+
+	return ret;
+}
+
+#else /* !CONFIG_HIBERNATION */
+
+#define amba_pm_freeze		NULL
+#define amba_pm_thaw		NULL
+#define amba_pm_poweroff		NULL
+#define amba_pm_restore		NULL
+#define amba_pm_freeze_noirq	NULL
+#define amba_pm_thaw_noirq		NULL
+#define amba_pm_poweroff_noirq	NULL
+#define amba_pm_restore_noirq	NULL
+
+#endif /* !CONFIG_HIBERNATION */
+
+#ifdef CONFIG_PM
+
+static const struct dev_pm_ops amba_pm = {
+	.prepare	= amba_pm_prepare,
+	.complete	= amba_pm_complete,
+	.suspend	= amba_pm_suspend,
+	.resume		= amba_pm_resume,
+	.freeze		= amba_pm_freeze,
+	.thaw		= amba_pm_thaw,
+	.poweroff	= amba_pm_poweroff,
+	.restore	= amba_pm_restore,
+	.suspend_noirq	= amba_pm_suspend_noirq,
+	.resume_noirq	= amba_pm_resume_noirq,
+	.freeze_noirq	= amba_pm_freeze_noirq,
+	.thaw_noirq	= amba_pm_thaw_noirq,
+	.poweroff_noirq	= amba_pm_poweroff_noirq,
+	.restore_noirq	= amba_pm_restore_noirq,
+	SET_RUNTIME_PM_OPS(
+		pm_generic_runtime_suspend,
+		pm_generic_runtime_resume,
+		pm_generic_runtime_idle
+	)
+};
+
+#define AMBA_PM (&amba_pm)
+
+#else /* !CONFIG_PM */
+
+#define AMBA_PM	NULL
+
+#endif /* !CONFIG_PM */
+
 /*
  * Primecells are part of the Advanced Microcontroller Bus Architecture,
  * so we call the bus "amba".
@@ -111,8 +406,7 @@ struct bus_type amba_bustype = {
 	.dev_attrs	= amba_dev_attrs,
 	.match		= amba_match,
 	.uevent		= amba_uevent,
-	.suspend	= amba_suspend,
-	.resume		= amba_resume,
+	.pm		= AMBA_PM,
 };
 
 static int __init amba_init(void)

commit c862aab0bc14060bfa8351ff1e93cbce9669abcf
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Sat Feb 19 15:55:26 2011 +0000

    ARM: amba: make internal ID table handling const
    
    As all probe() functions now take a const pointer, we can make the bus
    level code deal with const pointers too.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/drivers/amba/bus.c b/drivers/amba/bus.c
index ca96b0a26303..43088996a07a 100644
--- a/drivers/amba/bus.c
+++ b/drivers/amba/bus.c
@@ -21,8 +21,8 @@
 #define to_amba_device(d)	container_of(d, struct amba_device, dev)
 #define to_amba_driver(d)	container_of(d, struct amba_driver, drv)
 
-static struct amba_id *
-amba_lookup(struct amba_id *table, struct amba_device *dev)
+static const struct amba_id *
+amba_lookup(const struct amba_id *table, struct amba_device *dev)
 {
 	int ret = 0;
 
@@ -188,7 +188,7 @@ static int amba_probe(struct device *dev)
 {
 	struct amba_device *pcdev = to_amba_device(dev);
 	struct amba_driver *pcdrv = to_amba_driver(dev->driver);
-	struct amba_id *id = amba_lookup(pcdrv->id_table, pcdev);
+	const struct amba_id *id = amba_lookup(pcdrv->id_table, pcdev);
 	int ret;
 
 	do {

commit 394d5aefcdecb51bbf7d6df757e73559c9692a08
Author: Rob Herring <rob.herring@calxeda.com>
Date:   Sat Feb 12 15:58:25 2011 +0100

    ARM: 6662/1: amba: make amba_bustype non-static
    
    Export amba_bustype struct so it can be used for things like registering
    bus notifiers.
    
    Signed-off-by: Rob Herring <rob.herring@calxeda.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/drivers/amba/bus.c b/drivers/amba/bus.c
index e7df019d29d4..ca96b0a26303 100644
--- a/drivers/amba/bus.c
+++ b/drivers/amba/bus.c
@@ -106,7 +106,7 @@ static struct device_attribute amba_dev_attrs[] = {
  * Primecells are part of the Advanced Microcontroller Bus Architecture,
  * so we call the bus "amba".
  */
-static struct bus_type amba_bustype = {
+struct bus_type amba_bustype = {
 	.name		= "amba",
 	.dev_attrs	= amba_dev_attrs,
 	.match		= amba_match,

commit 65500fa94aaeb3475e39c0c5180f188014164ca4
Author: Linus Walleij <linus.walleij@stericsson.com>
Date:   Thu Nov 4 13:06:59 2010 +0100

    ARM: 6467/1: amba: optional PrimeCell core voltage switch
    
    On some contemporary sub-micron SoCs, peripherals on the chip have
    power domain switches, i.e. the voltage to the core may be turned
    off to conserve power. In the Ux500 we have this for out PrimeCell
    derivates.
    
    This patch makes it possible to specify an (optional) regulator to
    handle the voltage domain switch on AMBA PrimeCells, modeled very
    similar to how block clocks are handled.
    
    Additional amba_vcore_[enable|disable] calls are supplied to make
    it possible introduce optional powering off of the core voltage.
    Using this will require code to spool/unspool any core HW state.
    
    Cc: Rabin Vincent <rabin.vincent@stericsson.com>
    Cc: Bengt Jonsson <bengt.g.jonsson@stericsson.com>
    Cc: Jonas Aaberg <jonas.aberg@stericsson.com>
    Signed-off-by: Linus Walleij <linus.walleij@stericsson.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/drivers/amba/bus.c b/drivers/amba/bus.c
index 2737b9752205..e7df019d29d4 100644
--- a/drivers/amba/bus.c
+++ b/drivers/amba/bus.c
@@ -147,6 +147,39 @@ static void amba_put_disable_pclk(struct amba_device *pcdev)
 	clk_put(pclk);
 }
 
+static int amba_get_enable_vcore(struct amba_device *pcdev)
+{
+	struct regulator *vcore = regulator_get(&pcdev->dev, "vcore");
+	int ret;
+
+	pcdev->vcore = vcore;
+
+	if (IS_ERR(vcore)) {
+		/* It is OK not to supply a vcore regulator */
+		if (PTR_ERR(vcore) == -ENODEV)
+			return 0;
+		return PTR_ERR(vcore);
+	}
+
+	ret = regulator_enable(vcore);
+	if (ret) {
+		regulator_put(vcore);
+		pcdev->vcore = ERR_PTR(-ENODEV);
+	}
+
+	return ret;
+}
+
+static void amba_put_disable_vcore(struct amba_device *pcdev)
+{
+	struct regulator *vcore = pcdev->vcore;
+
+	if (!IS_ERR(vcore)) {
+		regulator_disable(vcore);
+		regulator_put(vcore);
+	}
+}
+
 /*
  * These are the device model conversion veneers; they convert the
  * device model structures to our more specific structures.
@@ -159,6 +192,10 @@ static int amba_probe(struct device *dev)
 	int ret;
 
 	do {
+		ret = amba_get_enable_vcore(pcdev);
+		if (ret)
+			break;
+
 		ret = amba_get_enable_pclk(pcdev);
 		if (ret)
 			break;
@@ -168,6 +205,7 @@ static int amba_probe(struct device *dev)
 			break;
 
 		amba_put_disable_pclk(pcdev);
+		amba_put_disable_vcore(pcdev);
 	} while (0);
 
 	return ret;
@@ -180,6 +218,7 @@ static int amba_remove(struct device *dev)
 	int ret = drv->remove(pcdev);
 
 	amba_put_disable_pclk(pcdev);
+	amba_put_disable_vcore(pcdev);
 
 	return ret;
 }

commit 01723a9566f9e9ce4c75e5c4c9f6dc20600871a7
Author: Linus Walleij <linus.walleij@stericsson.com>
Date:   Tue Sep 7 22:43:19 2010 +0100

    ARM: 6368/1: move the PrimeCell IDs to use macros
    
    This make four macros for the PrimeCell ID register available to
    drivers that use them witout using the PrimeCell/AMBA bus
    abstraction and struct amba_device. It also moves the magic
    PrimeCell CID "B105F00D" to the bus.h header file.
    
    Signed-off-by: Linus Walleij <linus.walleij@stericsson.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/drivers/amba/bus.c b/drivers/amba/bus.c
index d31590e7011b..2737b9752205 100644
--- a/drivers/amba/bus.c
+++ b/drivers/amba/bus.c
@@ -298,7 +298,7 @@ int amba_device_register(struct amba_device *dev, struct resource *parent)
 
 		amba_put_disable_pclk(dev);
 
-		if (cid == 0xb105f00d)
+		if (cid == AMBA_CID)
 			dev->periphid = pid;
 
 		if (!dev->periphid)

commit 7cfe249475fdd82ad3c2767a9b906cc775dab868
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Thu Jul 15 10:47:14 2010 +0100

    ARM: AMBA: Add pclk support to AMBA bus infrastructure
    
    Some platforms gate the pclk (APB - the bus - clock) to the peripherals
    for power saving, along with the functional clock.  When devices are
    accessed without pclk enabled, the kernel will oops.
    
    This gives them two options:
    
    1. Leave all clocks on all the time.
    2. Attempt to gate pclk along with the functional clock.
    
    (With some hardware, pclk and the functional clock are gated by a single
    bit in a register.)
    
    (1) has the disadvantage that it causes increased power usage, which is
    bad news for battery operated devices.  (2) can lead to kernel oops if
    registers are accessed without the functional clock being enabled.
    
    So, introduce the apb_pclk signal in such a way existing drivers don't
    need to be updated.  Essentially, this means we guarantee that:
    
    1. pclk will be enabled whenever the driver is bound to a device -
       from probe() to remove() time.
    2. pclk will also be enabled when reading the primecell IDs from the device.
    
    In order to allow drivers to be incrementally updated to achieve greater
    power savings, we provide two additional calls to allow drivers to
    manage the pclk - amba_pclk_enable()/amba_pclk_disable().
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/drivers/amba/bus.c b/drivers/amba/bus.c
index f60b2b6a0931..d31590e7011b 100644
--- a/drivers/amba/bus.c
+++ b/drivers/amba/bus.c
@@ -122,6 +122,31 @@ static int __init amba_init(void)
 
 postcore_initcall(amba_init);
 
+static int amba_get_enable_pclk(struct amba_device *pcdev)
+{
+	struct clk *pclk = clk_get(&pcdev->dev, "apb_pclk");
+	int ret;
+
+	pcdev->pclk = pclk;
+
+	if (IS_ERR(pclk))
+		return PTR_ERR(pclk);
+
+	ret = clk_enable(pclk);
+	if (ret)
+		clk_put(pclk);
+
+	return ret;
+}
+
+static void amba_put_disable_pclk(struct amba_device *pcdev)
+{
+	struct clk *pclk = pcdev->pclk;
+
+	clk_disable(pclk);
+	clk_put(pclk);
+}
+
 /*
  * These are the device model conversion veneers; they convert the
  * device model structures to our more specific structures.
@@ -130,17 +155,33 @@ static int amba_probe(struct device *dev)
 {
 	struct amba_device *pcdev = to_amba_device(dev);
 	struct amba_driver *pcdrv = to_amba_driver(dev->driver);
-	struct amba_id *id;
+	struct amba_id *id = amba_lookup(pcdrv->id_table, pcdev);
+	int ret;
 
-	id = amba_lookup(pcdrv->id_table, pcdev);
+	do {
+		ret = amba_get_enable_pclk(pcdev);
+		if (ret)
+			break;
+
+		ret = pcdrv->probe(pcdev, id);
+		if (ret == 0)
+			break;
 
-	return pcdrv->probe(pcdev, id);
+		amba_put_disable_pclk(pcdev);
+	} while (0);
+
+	return ret;
 }
 
 static int amba_remove(struct device *dev)
 {
+	struct amba_device *pcdev = to_amba_device(dev);
 	struct amba_driver *drv = to_amba_driver(dev->driver);
-	return drv->remove(to_amba_device(dev));
+	int ret = drv->remove(pcdev);
+
+	amba_put_disable_pclk(pcdev);
+
+	return ret;
 }
 
 static void amba_shutdown(struct device *dev)
@@ -203,7 +244,6 @@ static void amba_device_release(struct device *dev)
  */
 int amba_device_register(struct amba_device *dev, struct resource *parent)
 {
-	u32 pid, cid;
 	u32 size;
 	void __iomem *tmp;
 	int i, ret;
@@ -241,25 +281,35 @@ int amba_device_register(struct amba_device *dev, struct resource *parent)
 		goto err_release;
 	}
 
-	/*
-	 * Read pid and cid based on size of resource
-	 * they are located at end of region
-	 */
-	for (pid = 0, i = 0; i < 4; i++)
-		pid |= (readl(tmp + size - 0x20 + 4 * i) & 255) << (i * 8);
-	for (cid = 0, i = 0; i < 4; i++)
-		cid |= (readl(tmp + size - 0x10 + 4 * i) & 255) << (i * 8);
+	ret = amba_get_enable_pclk(dev);
+	if (ret == 0) {
+		u32 pid, cid;
 
-	iounmap(tmp);
+		/*
+		 * Read pid and cid based on size of resource
+		 * they are located at end of region
+		 */
+		for (pid = 0, i = 0; i < 4; i++)
+			pid |= (readl(tmp + size - 0x20 + 4 * i) & 255) <<
+				(i * 8);
+		for (cid = 0, i = 0; i < 4; i++)
+			cid |= (readl(tmp + size - 0x10 + 4 * i) & 255) <<
+				(i * 8);
 
-	if (cid == 0xb105f00d)
-		dev->periphid = pid;
+		amba_put_disable_pclk(dev);
 
-	if (!dev->periphid) {
-		ret = -ENODEV;
-		goto err_release;
+		if (cid == 0xb105f00d)
+			dev->periphid = pid;
+
+		if (!dev->periphid)
+			ret = -ENODEV;
 	}
 
+	iounmap(tmp);
+
+	if (ret)
+		goto err_release;
+
 	ret = device_add(&dev->dev);
 	if (ret)
 		goto err_release;

commit cf7a2b4fb6a9b86779930a0a123b0df41aa9208f
Merge: b736b89f8a00 8c3cbd5a2b2c 57a473f2f97c af1057abd7d5 c1cb6b7fb519 65cec8e3db60 8e22676e5667
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Sat Sep 12 12:01:34 2009 +0100

    Merge branches 'arm', 'at91', 'bcmring', 'ep93xx', 'mach-types', 'misc' and 'w90x900' into devel

commit 8afe0b96b36bb967a00658003736ffa97967ee80
Author: Leo Chen <leochen@broadcom.com>
Date:   Tue Jul 28 23:34:59 2009 +0100

    ARM: 5625/1: fix hard coded 4K resource size in amba bus detection
    
    This patch modifies the amba bus detection logic in the kernel
    to detect the AMBA devices using the calculated resource
    size information rather than the hard coded 4K size.
    
    It also calculates the resource size when request mem region
    and release mem region.
    
    Signed-off-by: Leo Chen <leochen@broadcom.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/drivers/amba/bus.c b/drivers/amba/bus.c
index 3d763fdf99b7..768d973d0ded 100644
--- a/drivers/amba/bus.c
+++ b/drivers/amba/bus.c
@@ -204,6 +204,7 @@ static void amba_device_release(struct device *dev)
 int amba_device_register(struct amba_device *dev, struct resource *parent)
 {
 	u32 pid, cid;
+	u32 size;
 	void __iomem *tmp;
 	int i, ret;
 
@@ -219,16 +220,25 @@ int amba_device_register(struct amba_device *dev, struct resource *parent)
 	if (ret)
 		goto err_out;
 
-	tmp = ioremap(dev->res.start, SZ_4K);
+	/*
+	 * Dynamically calculate the size of the resource
+	 * and use this for iomap
+	 */
+	size = resource_size(&dev->res);
+	tmp = ioremap(dev->res.start, size);
 	if (!tmp) {
 		ret = -ENOMEM;
 		goto err_release;
 	}
 
+	/*
+	 * Read pid and cid based on size of resource
+	 * they are located at end of region
+	 */
 	for (pid = 0, i = 0; i < 4; i++)
-		pid |= (readl(tmp + 0xfe0 + 4 * i) & 255) << (i * 8);
+		pid |= (readl(tmp + size - 0x20 + 4 * i) & 255) << (i * 8);
 	for (cid = 0, i = 0; i < 4; i++)
-		cid |= (readl(tmp + 0xff0 + 4 * i) & 255) << (i * 8);
+		cid |= (readl(tmp + size - 0x10 + 4 * i) & 255) << (i * 8);
 
 	iounmap(tmp);
 
@@ -343,11 +353,14 @@ amba_find_device(const char *busid, struct device *parent, unsigned int id,
 int amba_request_regions(struct amba_device *dev, const char *name)
 {
 	int ret = 0;
+	u32 size;
 
 	if (!name)
 		name = dev->dev.driver->name;
 
-	if (!request_mem_region(dev->res.start, SZ_4K, name))
+	size = resource_size(&dev->res);
+
+	if (!request_mem_region(dev->res.start, size, name))
 		ret = -EBUSY;
 
 	return ret;
@@ -361,7 +374,10 @@ int amba_request_regions(struct amba_device *dev, const char *name)
  */
 void amba_release_regions(struct amba_device *dev)
 {
-	release_mem_region(dev->res.start, SZ_4K);
+	u32 size;
+
+	size = resource_size(&dev->res);
+	release_mem_region(dev->res.start, size);
 }
 
 EXPORT_SYMBOL(amba_driver_register);

commit 557dca5f48a45df88a73e69ee0700cfd4e2358c9
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Sun Jul 5 22:39:08 2009 +0100

    [ARM] amba: fix amba device resources
    
    AMBA device resources were being reported as:
    
    10004000-10004fff : <BAD>
    
    This is because dev_name() was returning NULL prior to device_register.
    Ensure that the struct device is properly initialized, and the name is
    set before adding it to the device tree.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/drivers/amba/bus.c b/drivers/amba/bus.c
index 3d763fdf99b7..246650673010 100644
--- a/drivers/amba/bus.c
+++ b/drivers/amba/bus.c
@@ -207,6 +207,16 @@ int amba_device_register(struct amba_device *dev, struct resource *parent)
 	void __iomem *tmp;
 	int i, ret;
 
+	device_initialize(&dev->dev);
+
+	/*
+	 * Copy from device_add
+	 */
+	if (dev->dev.init_name) {
+		dev_set_name(&dev->dev, "%s", dev->dev.init_name);
+		dev->dev.init_name = NULL;
+	}
+
 	dev->dev.release = amba_device_release;
 	dev->dev.bus = &amba_bustype;
 	dev->dev.dma_mask = &dev->dma_mask;
@@ -240,7 +250,7 @@ int amba_device_register(struct amba_device *dev, struct resource *parent)
 		goto err_release;
 	}
 
-	ret = device_register(&dev->dev);
+	ret = device_add(&dev->dev);
 	if (ret)
 		goto err_release;
 

commit 9d6b4c82bffbe6de624ff86cb279166867f46365
Author: Kay Sievers <kay.sievers@vrfy.org>
Date:   Tue Mar 24 16:38:22 2009 -0700

    amba: struct device - replace bus_id with dev_name(), dev_set_name()
    
    Acked-by: Greg Kroah-Hartman <gregkh@suse.de>
    Signed-off-by: Kay Sievers <kay.sievers@vrfy.org>

diff --git a/drivers/amba/bus.c b/drivers/amba/bus.c
index 00c46e0b40e4..3d763fdf99b7 100644
--- a/drivers/amba/bus.c
+++ b/drivers/amba/bus.c
@@ -210,7 +210,7 @@ int amba_device_register(struct amba_device *dev, struct resource *parent)
 	dev->dev.release = amba_device_release;
 	dev->dev.bus = &amba_bustype;
 	dev->dev.dma_mask = &dev->dma_mask;
-	dev->res.name = dev->dev.bus_id;
+	dev->res.name = dev_name(&dev->dev);
 
 	if (!dev->dev.coherent_dma_mask && dev->dma_mask)
 		dev_warn(&dev->dev, "coherent dma mask is unset\n");
@@ -294,7 +294,7 @@ static int amba_find_match(struct device *dev, void *data)
 	if (d->parent)
 		r &= d->parent == dev->parent;
 	if (d->busid)
-		r &= strcmp(dev->bus_id, d->busid) == 0;
+		r &= strcmp(dev_name(dev), d->busid) == 0;
 
 	if (r) {
 		get_device(dev);

commit 934848daa34af53de16cd8125d04346dffee9e87
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Thu Jan 8 09:58:51 2009 +0000

    [ARM] Fix realview build
    
    arch/arm/mach-realview/platsmp.c:140: error: 'jiffies' undeclared (first use in this function)
    drivers/amba/bus.c:246: error: 'NO_IRQ' undeclared (first use in this function)
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/drivers/amba/bus.c b/drivers/amba/bus.c
index 6b94fb7be5f2..00c46e0b40e4 100644
--- a/drivers/amba/bus.c
+++ b/drivers/amba/bus.c
@@ -12,9 +12,10 @@
 #include <linux/device.h>
 #include <linux/string.h>
 #include <linux/slab.h>
+#include <linux/io.h>
 #include <linux/amba/bus.h>
 
-#include <asm/io.h>
+#include <asm/irq.h>
 #include <asm/sizes.h>
 
 #define to_amba_device(d)	container_of(d, struct amba_device, dev)

commit 7eff2e7a8b65c25920207324e56611150eb1cd9a
Author: Kay Sievers <kay.sievers@vrfy.org>
Date:   Tue Aug 14 15:15:12 2007 +0200

    Driver core: change add_uevent_var to use a struct
    
    This changes the uevent buffer functions to use a struct instead of a
    long list of parameters. It does no longer require the caller to do the
    proper buffer termination and size accounting, which is currently wrong
    in some places. It fixes a known bug where parts of the uevent
    environment are overwritten because of wrong index calculations.
    
    Many thanks to Mathieu Desnoyers for finding bugs and improving the
    error handling.
    
    Signed-off-by: Kay Sievers <kay.sievers@vrfy.org>
    Cc: Mathieu Desnoyers <mathieu.desnoyers@polymtl.ca>
    Cc: Cornelia Huck <cornelia.huck@de.ibm.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/amba/bus.c b/drivers/amba/bus.c
index 268e301775fc..6b94fb7be5f2 100644
--- a/drivers/amba/bus.c
+++ b/drivers/amba/bus.c
@@ -44,15 +44,12 @@ static int amba_match(struct device *dev, struct device_driver *drv)
 }
 
 #ifdef CONFIG_HOTPLUG
-static int amba_uevent(struct device *dev, char **envp, int nr_env, char *buf, int bufsz)
+static int amba_uevent(struct device *dev, struct kobj_uevent_env *env)
 {
 	struct amba_device *pcdev = to_amba_device(dev);
-	int retval = 0, i = 0, len = 0;
+	int retval = 0;
 
-	retval = add_uevent_var(envp, nr_env, &i,
-				buf, bufsz, &len,
-				"AMBA_ID=%08x", pcdev->periphid);
-	envp[i] = NULL;
+	retval = add_uevent_var(env, "AMBA_ID=%08x", pcdev->periphid);
 	return retval;
 }
 #else

commit bf62456eb91f3d2ef0736081583d09b0b3c8b7ea
Author: Eric Rannaud <eric.rannaud@gmail.com>
Date:   Fri Mar 30 22:23:12 2007 -0700

    uevent: use add_uevent_var() instead of open coding it
    
    Make use of add_uevent_var() instead of (often incorrectly) open coding it.
    
    Signed-off-by: Michael Ellerman <michael@ellerman.id.au>
    Signed-off-by: Eric Rannaud <eric.rannaud@gmail.com>
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Cc: Cornelia Huck <cornelia.huck@de.ibm.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/amba/bus.c b/drivers/amba/bus.c
index fd5475071acc..268e301775fc 100644
--- a/drivers/amba/bus.c
+++ b/drivers/amba/bus.c
@@ -47,14 +47,13 @@ static int amba_match(struct device *dev, struct device_driver *drv)
 static int amba_uevent(struct device *dev, char **envp, int nr_env, char *buf, int bufsz)
 {
 	struct amba_device *pcdev = to_amba_device(dev);
+	int retval = 0, i = 0, len = 0;
 
-	if (nr_env < 2)
-		return -ENOMEM;
-
-	snprintf(buf, bufsz, "AMBA_ID=%08x", pcdev->periphid);
-	*envp++ = buf;
-	*envp++ = NULL;
-	return 0;
+	retval = add_uevent_var(envp, nr_env, &i,
+				buf, bufsz, &len,
+				"AMBA_ID=%08x", pcdev->periphid);
+	envp[i] = NULL;
+	return retval;
 }
 #else
 #define amba_uevent NULL

commit 96b13f5c074fab56797109aedacc2405544d6f95
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Thu Nov 30 14:04:49 2006 +0000

    [ARM] Fix __must_check warnings in drivers/bus/amba.c
    
    Fix driver model __must_check warnings in drivers/bus/amba.c by
    rearranging how we add attributes to devices.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/drivers/amba/bus.c b/drivers/amba/bus.c
index 9e3e2a69c03a..fd5475071acc 100644
--- a/drivers/amba/bus.c
+++ b/drivers/amba/bus.c
@@ -80,12 +80,38 @@ static int amba_resume(struct device *dev)
 	return ret;
 }
 
+#define amba_attr_func(name,fmt,arg...)					\
+static ssize_t name##_show(struct device *_dev,				\
+			   struct device_attribute *attr, char *buf)	\
+{									\
+	struct amba_device *dev = to_amba_device(_dev);			\
+	return sprintf(buf, fmt, arg);					\
+}
+
+#define amba_attr(name,fmt,arg...)	\
+amba_attr_func(name,fmt,arg)		\
+static DEVICE_ATTR(name, S_IRUGO, name##_show, NULL)
+
+amba_attr_func(id, "%08x\n", dev->periphid);
+amba_attr(irq0, "%u\n", dev->irq[0]);
+amba_attr(irq1, "%u\n", dev->irq[1]);
+amba_attr_func(resource, "\t%016llx\t%016llx\t%016lx\n",
+	 (unsigned long long)dev->res.start, (unsigned long long)dev->res.end,
+	 dev->res.flags);
+
+static struct device_attribute amba_dev_attrs[] = {
+	__ATTR_RO(id),
+	__ATTR_RO(resource),
+	__ATTR_NULL,
+};
+
 /*
  * Primecells are part of the Advanced Microcontroller Bus Architecture,
  * so we call the bus "amba".
  */
 static struct bus_type amba_bustype = {
 	.name		= "amba",
+	.dev_attrs	= amba_dev_attrs,
 	.match		= amba_match,
 	.uevent		= amba_uevent,
 	.suspend	= amba_suspend,
@@ -169,21 +195,6 @@ static void amba_device_release(struct device *dev)
 	kfree(d);
 }
 
-#define amba_attr(name,fmt,arg...)				\
-static ssize_t show_##name(struct device *_dev, struct device_attribute *attr, char *buf)	\
-{								\
-	struct amba_device *dev = to_amba_device(_dev);		\
-	return sprintf(buf, fmt, arg);				\
-}								\
-static DEVICE_ATTR(name, S_IRUGO, show_##name, NULL)
-
-amba_attr(id, "%08x\n", dev->periphid);
-amba_attr(irq0, "%u\n", dev->irq[0]);
-amba_attr(irq1, "%u\n", dev->irq[1]);
-amba_attr(resource, "\t%016llx\t%016llx\t%016lx\n",
-	 (unsigned long long)dev->res.start, (unsigned long long)dev->res.end,
-	 dev->res.flags);
-
 /**
  *	amba_device_register - register an AMBA device
  *	@dev: AMBA device to register
@@ -208,40 +219,46 @@ int amba_device_register(struct amba_device *dev, struct resource *parent)
 		dev_warn(&dev->dev, "coherent dma mask is unset\n");
 
 	ret = request_resource(parent, &dev->res);
-	if (ret == 0) {
-		tmp = ioremap(dev->res.start, SZ_4K);
-		if (!tmp) {
-			ret = -ENOMEM;
-			goto out;
-		}
-
-		for (pid = 0, i = 0; i < 4; i++)
-			pid |= (readl(tmp + 0xfe0 + 4 * i) & 255) << (i * 8);
-		for (cid = 0, i = 0; i < 4; i++)
-			cid |= (readl(tmp + 0xff0 + 4 * i) & 255) << (i * 8);
-
-		iounmap(tmp);
-
-		if (cid == 0xb105f00d)
-			dev->periphid = pid;
-
-		if (dev->periphid)
-			ret = device_register(&dev->dev);
-		else
-			ret = -ENODEV;
-
-		if (ret == 0) {
-			device_create_file(&dev->dev, &dev_attr_id);
-			if (dev->irq[0] != NO_IRQ)
-				device_create_file(&dev->dev, &dev_attr_irq0);
-			if (dev->irq[1] != NO_IRQ)
-				device_create_file(&dev->dev, &dev_attr_irq1);
-			device_create_file(&dev->dev, &dev_attr_resource);
-		} else {
- out:
-			release_resource(&dev->res);
-		}
+	if (ret)
+		goto err_out;
+
+	tmp = ioremap(dev->res.start, SZ_4K);
+	if (!tmp) {
+		ret = -ENOMEM;
+		goto err_release;
 	}
+
+	for (pid = 0, i = 0; i < 4; i++)
+		pid |= (readl(tmp + 0xfe0 + 4 * i) & 255) << (i * 8);
+	for (cid = 0, i = 0; i < 4; i++)
+		cid |= (readl(tmp + 0xff0 + 4 * i) & 255) << (i * 8);
+
+	iounmap(tmp);
+
+	if (cid == 0xb105f00d)
+		dev->periphid = pid;
+
+	if (!dev->periphid) {
+		ret = -ENODEV;
+		goto err_release;
+	}
+
+	ret = device_register(&dev->dev);
+	if (ret)
+		goto err_release;
+
+	if (dev->irq[0] != NO_IRQ)
+		ret = device_create_file(&dev->dev, &dev_attr_irq0);
+	if (ret == 0 && dev->irq[1] != NO_IRQ)
+		ret = device_create_file(&dev->dev, &dev_attr_irq1);
+	if (ret == 0)
+		return ret;
+
+	device_unregister(&dev->dev);
+
+ err_release:
+	release_resource(&dev->res);
+ err_out:
 	return ret;
 }
 

commit e29419fffceb8ec36def3c922040e1ca7bcd3de5
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon Jun 12 15:20:16 2006 -0700

    [PATCH] 64bit resource: fix up printks for resources in misc drivers
    
    This is needed if we wish to change the size of the resource structures.
    
    Based on an original patch from Vivek Goyal <vgoyal@in.ibm.com>
    
    Cc: Vivek Goyal <vgoyal@in.ibm.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/amba/bus.c b/drivers/amba/bus.c
index 889855d8d9f9..9e3e2a69c03a 100644
--- a/drivers/amba/bus.c
+++ b/drivers/amba/bus.c
@@ -180,8 +180,9 @@ static DEVICE_ATTR(name, S_IRUGO, show_##name, NULL)
 amba_attr(id, "%08x\n", dev->periphid);
 amba_attr(irq0, "%u\n", dev->irq[0]);
 amba_attr(irq1, "%u\n", dev->irq[1]);
-amba_attr(resource, "\t%08lx\t%08lx\t%08lx\n",
-	  dev->res.start, dev->res.end, dev->res.flags);
+amba_attr(resource, "\t%016llx\t%016llx\t%016lx\n",
+	 (unsigned long long)dev->res.start, (unsigned long long)dev->res.end,
+	 dev->res.flags);
 
 /**
  *	amba_device_register - register an AMBA device

commit e9368f8288338c25d8a339c91b15e17ebf33752d
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Mon Jan 9 13:56:42 2006 +0000

    [ARM] Remove asm/irq.h includes from ARM drivers
    
    Many ARM drivers do not need to include asm/irq.h - remove this
    unnecessary include from some ARM drivers.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/drivers/amba/bus.c b/drivers/amba/bus.c
index 1bbdd1693d57..889855d8d9f9 100644
--- a/drivers/amba/bus.c
+++ b/drivers/amba/bus.c
@@ -15,7 +15,6 @@
 #include <linux/amba/bus.h>
 
 #include <asm/io.h>
-#include <asm/irq.h>
 #include <asm/sizes.h>
 
 #define to_amba_device(d)	container_of(d, struct amba_device, dev)

commit de1d815fccee1f4766a7e56054ab0ec3f6f3a7db
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Sat Jan 7 14:54:15 2006 +0000

    [ARM] Move AMBA bus code to drivers/amba/
    
    Make the AMBA bus code visible to other architectures.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/drivers/amba/bus.c b/drivers/amba/bus.c
new file mode 100644
index 000000000000..1bbdd1693d57
--- /dev/null
+++ b/drivers/amba/bus.c
@@ -0,0 +1,359 @@
+/*
+ *  linux/arch/arm/common/amba.c
+ *
+ *  Copyright (C) 2003 Deep Blue Solutions Ltd, All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/string.h>
+#include <linux/slab.h>
+#include <linux/amba/bus.h>
+
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/sizes.h>
+
+#define to_amba_device(d)	container_of(d, struct amba_device, dev)
+#define to_amba_driver(d)	container_of(d, struct amba_driver, drv)
+
+static struct amba_id *
+amba_lookup(struct amba_id *table, struct amba_device *dev)
+{
+	int ret = 0;
+
+	while (table->mask) {
+		ret = (dev->periphid & table->mask) == table->id;
+		if (ret)
+			break;
+		table++;
+	}
+
+	return ret ? table : NULL;
+}
+
+static int amba_match(struct device *dev, struct device_driver *drv)
+{
+	struct amba_device *pcdev = to_amba_device(dev);
+	struct amba_driver *pcdrv = to_amba_driver(drv);
+
+	return amba_lookup(pcdrv->id_table, pcdev) != NULL;
+}
+
+#ifdef CONFIG_HOTPLUG
+static int amba_uevent(struct device *dev, char **envp, int nr_env, char *buf, int bufsz)
+{
+	struct amba_device *pcdev = to_amba_device(dev);
+
+	if (nr_env < 2)
+		return -ENOMEM;
+
+	snprintf(buf, bufsz, "AMBA_ID=%08x", pcdev->periphid);
+	*envp++ = buf;
+	*envp++ = NULL;
+	return 0;
+}
+#else
+#define amba_uevent NULL
+#endif
+
+static int amba_suspend(struct device *dev, pm_message_t state)
+{
+	struct amba_driver *drv = to_amba_driver(dev->driver);
+	int ret = 0;
+
+	if (dev->driver && drv->suspend)
+		ret = drv->suspend(to_amba_device(dev), state);
+	return ret;
+}
+
+static int amba_resume(struct device *dev)
+{
+	struct amba_driver *drv = to_amba_driver(dev->driver);
+	int ret = 0;
+
+	if (dev->driver && drv->resume)
+		ret = drv->resume(to_amba_device(dev));
+	return ret;
+}
+
+/*
+ * Primecells are part of the Advanced Microcontroller Bus Architecture,
+ * so we call the bus "amba".
+ */
+static struct bus_type amba_bustype = {
+	.name		= "amba",
+	.match		= amba_match,
+	.uevent		= amba_uevent,
+	.suspend	= amba_suspend,
+	.resume		= amba_resume,
+};
+
+static int __init amba_init(void)
+{
+	return bus_register(&amba_bustype);
+}
+
+postcore_initcall(amba_init);
+
+/*
+ * These are the device model conversion veneers; they convert the
+ * device model structures to our more specific structures.
+ */
+static int amba_probe(struct device *dev)
+{
+	struct amba_device *pcdev = to_amba_device(dev);
+	struct amba_driver *pcdrv = to_amba_driver(dev->driver);
+	struct amba_id *id;
+
+	id = amba_lookup(pcdrv->id_table, pcdev);
+
+	return pcdrv->probe(pcdev, id);
+}
+
+static int amba_remove(struct device *dev)
+{
+	struct amba_driver *drv = to_amba_driver(dev->driver);
+	return drv->remove(to_amba_device(dev));
+}
+
+static void amba_shutdown(struct device *dev)
+{
+	struct amba_driver *drv = to_amba_driver(dev->driver);
+	drv->shutdown(to_amba_device(dev));
+}
+
+/**
+ *	amba_driver_register - register an AMBA device driver
+ *	@drv: amba device driver structure
+ *
+ *	Register an AMBA device driver with the Linux device model
+ *	core.  If devices pre-exist, the drivers probe function will
+ *	be called.
+ */
+int amba_driver_register(struct amba_driver *drv)
+{
+	drv->drv.bus = &amba_bustype;
+
+#define SETFN(fn)	if (drv->fn) drv->drv.fn = amba_##fn
+	SETFN(probe);
+	SETFN(remove);
+	SETFN(shutdown);
+
+	return driver_register(&drv->drv);
+}
+
+/**
+ *	amba_driver_unregister - remove an AMBA device driver
+ *	@drv: AMBA device driver structure to remove
+ *
+ *	Unregister an AMBA device driver from the Linux device
+ *	model.  The device model will call the drivers remove function
+ *	for each device the device driver is currently handling.
+ */
+void amba_driver_unregister(struct amba_driver *drv)
+{
+	driver_unregister(&drv->drv);
+}
+
+
+static void amba_device_release(struct device *dev)
+{
+	struct amba_device *d = to_amba_device(dev);
+
+	if (d->res.parent)
+		release_resource(&d->res);
+	kfree(d);
+}
+
+#define amba_attr(name,fmt,arg...)				\
+static ssize_t show_##name(struct device *_dev, struct device_attribute *attr, char *buf)	\
+{								\
+	struct amba_device *dev = to_amba_device(_dev);		\
+	return sprintf(buf, fmt, arg);				\
+}								\
+static DEVICE_ATTR(name, S_IRUGO, show_##name, NULL)
+
+amba_attr(id, "%08x\n", dev->periphid);
+amba_attr(irq0, "%u\n", dev->irq[0]);
+amba_attr(irq1, "%u\n", dev->irq[1]);
+amba_attr(resource, "\t%08lx\t%08lx\t%08lx\n",
+	  dev->res.start, dev->res.end, dev->res.flags);
+
+/**
+ *	amba_device_register - register an AMBA device
+ *	@dev: AMBA device to register
+ *	@parent: parent memory resource
+ *
+ *	Setup the AMBA device, reading the cell ID if present.
+ *	Claim the resource, and register the AMBA device with
+ *	the Linux device manager.
+ */
+int amba_device_register(struct amba_device *dev, struct resource *parent)
+{
+	u32 pid, cid;
+	void __iomem *tmp;
+	int i, ret;
+
+	dev->dev.release = amba_device_release;
+	dev->dev.bus = &amba_bustype;
+	dev->dev.dma_mask = &dev->dma_mask;
+	dev->res.name = dev->dev.bus_id;
+
+	if (!dev->dev.coherent_dma_mask && dev->dma_mask)
+		dev_warn(&dev->dev, "coherent dma mask is unset\n");
+
+	ret = request_resource(parent, &dev->res);
+	if (ret == 0) {
+		tmp = ioremap(dev->res.start, SZ_4K);
+		if (!tmp) {
+			ret = -ENOMEM;
+			goto out;
+		}
+
+		for (pid = 0, i = 0; i < 4; i++)
+			pid |= (readl(tmp + 0xfe0 + 4 * i) & 255) << (i * 8);
+		for (cid = 0, i = 0; i < 4; i++)
+			cid |= (readl(tmp + 0xff0 + 4 * i) & 255) << (i * 8);
+
+		iounmap(tmp);
+
+		if (cid == 0xb105f00d)
+			dev->periphid = pid;
+
+		if (dev->periphid)
+			ret = device_register(&dev->dev);
+		else
+			ret = -ENODEV;
+
+		if (ret == 0) {
+			device_create_file(&dev->dev, &dev_attr_id);
+			if (dev->irq[0] != NO_IRQ)
+				device_create_file(&dev->dev, &dev_attr_irq0);
+			if (dev->irq[1] != NO_IRQ)
+				device_create_file(&dev->dev, &dev_attr_irq1);
+			device_create_file(&dev->dev, &dev_attr_resource);
+		} else {
+ out:
+			release_resource(&dev->res);
+		}
+	}
+	return ret;
+}
+
+/**
+ *	amba_device_unregister - unregister an AMBA device
+ *	@dev: AMBA device to remove
+ *
+ *	Remove the specified AMBA device from the Linux device
+ *	manager.  All files associated with this object will be
+ *	destroyed, and device drivers notified that the device has
+ *	been removed.  The AMBA device's resources including
+ *	the amba_device structure will be freed once all
+ *	references to it have been dropped.
+ */
+void amba_device_unregister(struct amba_device *dev)
+{
+	device_unregister(&dev->dev);
+}
+
+
+struct find_data {
+	struct amba_device *dev;
+	struct device *parent;
+	const char *busid;
+	unsigned int id;
+	unsigned int mask;
+};
+
+static int amba_find_match(struct device *dev, void *data)
+{
+	struct find_data *d = data;
+	struct amba_device *pcdev = to_amba_device(dev);
+	int r;
+
+	r = (pcdev->periphid & d->mask) == d->id;
+	if (d->parent)
+		r &= d->parent == dev->parent;
+	if (d->busid)
+		r &= strcmp(dev->bus_id, d->busid) == 0;
+
+	if (r) {
+		get_device(dev);
+		d->dev = pcdev;
+	}
+
+	return r;
+}
+
+/**
+ *	amba_find_device - locate an AMBA device given a bus id
+ *	@busid: bus id for device (or NULL)
+ *	@parent: parent device (or NULL)
+ *	@id: peripheral ID (or 0)
+ *	@mask: peripheral ID mask (or 0)
+ *
+ *	Return the AMBA device corresponding to the supplied parameters.
+ *	If no device matches, returns NULL.
+ *
+ *	NOTE: When a valid device is found, its refcount is
+ *	incremented, and must be decremented before the returned
+ *	reference.
+ */
+struct amba_device *
+amba_find_device(const char *busid, struct device *parent, unsigned int id,
+		 unsigned int mask)
+{
+	struct find_data data;
+
+	data.dev = NULL;
+	data.parent = parent;
+	data.busid = busid;
+	data.id = id;
+	data.mask = mask;
+
+	bus_for_each_dev(&amba_bustype, NULL, &data, amba_find_match);
+
+	return data.dev;
+}
+
+/**
+ *	amba_request_regions - request all mem regions associated with device
+ *	@dev: amba_device structure for device
+ *	@name: name, or NULL to use driver name
+ */
+int amba_request_regions(struct amba_device *dev, const char *name)
+{
+	int ret = 0;
+
+	if (!name)
+		name = dev->dev.driver->name;
+
+	if (!request_mem_region(dev->res.start, SZ_4K, name))
+		ret = -EBUSY;
+
+	return ret;
+}
+
+/**
+ *	amba_release_regions - release mem regions assoicated with device
+ *	@dev: amba_device structure for device
+ *
+ *	Release regions claimed by a successful call to amba_request_regions.
+ */
+void amba_release_regions(struct amba_device *dev)
+{
+	release_mem_region(dev->res.start, SZ_4K);
+}
+
+EXPORT_SYMBOL(amba_driver_register);
+EXPORT_SYMBOL(amba_driver_unregister);
+EXPORT_SYMBOL(amba_device_register);
+EXPORT_SYMBOL(amba_device_unregister);
+EXPORT_SYMBOL(amba_find_device);
+EXPORT_SYMBOL(amba_request_regions);
+EXPORT_SYMBOL(amba_release_regions);
