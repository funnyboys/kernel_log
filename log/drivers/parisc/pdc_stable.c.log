commit 4505153954fdb1465d2b178288a9bf646f2a2166
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed May 29 16:57:47 2019 -0700

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 333
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation this program is
      distributed in the hope that it will be useful but without any
      warranty without even the implied warranty of merchantability or
      fitness for a particular purpose see the gnu general public license
      for more details you should have received a copy of the gnu general
      public license along with this program if not write to the free
      software foundation inc 59 temple place suite 330 boston ma 02111
      1307 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 136 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Alexios Zavras <alexios.zavras@intel.com>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190530000436.384967451@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/parisc/pdc_stable.c b/drivers/parisc/pdc_stable.c
index b1ff46fe4547..e090978518f1 100644
--- a/drivers/parisc/pdc_stable.c
+++ b/drivers/parisc/pdc_stable.c
@@ -1,22 +1,9 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /* 
  *    Interfaces to retrieve and set PDC Stable options (firmware)
  *
  *    Copyright (C) 2005-2006 Thibaut VARENE <varenet@parisc-linux.org>
  *
- *    This program is free software; you can redistribute it and/or modify
- *    it under the terms of the GNU General Public License, version 2, as
- *    published by the Free Software Foundation.
- *
- *    This program is distributed in the hope that it will be useful,
- *    but WITHOUT ANY WARRANTY; without even the implied warranty of
- *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *    GNU General Public License for more details.
- *
- *    You should have received a copy of the GNU General Public License
- *    along with this program; if not, write to the Free Software
- *    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
- *
  *    DEV NOTE: the PDC Procedures reference states that:
  *    "A minimum of 96 bytes of Stable Storage is required. Providing more than
  *    96 bytes of Stable Storage is optional [...]. Failure to provide the

commit 93964fd4ea6ab86a2d2853a9ae56ae0c24cbbe16
Author: James Bottomley <James.Bottomley@HansenPartnership.com>
Date:   Mon Jul 31 15:49:54 2017 +0200

    parisc: pdc_stable: Fix locking when creating sysfs links
    
    There's no need to take the write lock when creating sysfs links.
    
    This patch fixes the following BUG:
     BUG: sleeping function called from invalid context at mm/slab.h:416
     in_atomic(): 1, irqs_disabled(): 0, pid: 1, name: swapper/0
     CPU: 2 PID: 1 Comm: swapper/0 Not tainted 4.13.0-rc2-00110-g0b5477d9dabd #111
     Backtrace:
     [<0000000040217ac8>] show_stack+0x20/0x38
     [<00000000406fbbb0>] dump_stack+0xb0/0x128
     [<0000000040274090>] ___might_sleep+0x180/0x1b8
     [<0000000040274144>] __might_sleep+0x7c/0xe8
     [<0000000040373874>] kmem_cache_alloc+0x14c/0x1e0
     [<0000000040419514>] __kernfs_new_node+0x84/0x1b8
     [<000000004041b09c>] kernfs_new_node+0x3c/0x78
     [<000000004041e040>] kernfs_create_link+0x40/0xd8
     [<000000004041f320>] sysfs_do_create_link_sd.isra.0+0xb0/0x130
     [<000000004041f3d4>] sysfs_create_link+0x34/0x58
     [<000000004011b4a4>] pdc_stable_init+0x2c4/0x458
     [<0000000040200250>] do_one_initcall+0x70/0x1d8
     [<0000000040101644>] kernel_init_freeable+0x27c/0x390
     [<000000004020be44>] kernel_init+0x24/0x1c0
    
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>
    Reported-by: Meelis Roos <mroos@linux.ee>
    Signed-off-by: Helge Deller <deller@gmx.de>

diff --git a/drivers/parisc/pdc_stable.c b/drivers/parisc/pdc_stable.c
index 7147aa53e9a2..b1ff46fe4547 100644
--- a/drivers/parisc/pdc_stable.c
+++ b/drivers/parisc/pdc_stable.c
@@ -333,11 +333,11 @@ pdcspath_hwpath_write(struct pdcspath_entry *entry, const char *buf, size_t coun
 	
 	/* Update the symlink to the real device */
 	sysfs_remove_link(&entry->kobj, "device");
+	write_unlock(&entry->rw_lock);
+
 	ret = sysfs_create_link(&entry->kobj, &entry->dev->kobj, "device");
 	WARN_ON(ret);
 
-	write_unlock(&entry->rw_lock);
-	
 	printk(KERN_INFO PDCS_PREFIX ": changed \"%s\" path to \"%s\"\n",
 		entry->name, buf);
 	
@@ -998,6 +998,7 @@ pdcs_register_pathentries(void)
 		/* kobject is now registered */
 		write_lock(&entry->rw_lock);
 		entry->ready = 2;
+		write_unlock(&entry->rw_lock);
 		
 		/* Add a nice symlink to the real device */
 		if (entry->dev) {
@@ -1005,7 +1006,6 @@ pdcs_register_pathentries(void)
 			WARN_ON(err);
 		}
 
-		write_unlock(&entry->rw_lock);
 		kobject_uevent(&entry->kobj, KOBJ_ADD);
 	}
 	

commit 343fdfb7d062a52ff39a004d42e4ad1cf7883bc6
Author: Arvind Yadav <arvind.yadav.cs@gmail.com>
Date:   Tue Jul 11 14:30:34 2017 +0530

    parisc: pdc_stable: constify attribute_group structures.
    
    attribute_groups are not supposed to change at runtime. All functions
    working with attribute_groups provided by <linux/sysfs.h> work
    with const attribute_group. So mark the non-const structs as const.
    
    Signed-off-by: Arvind Yadav <arvind.yadav.cs@gmail.com>
    Signed-off-by: Helge Deller <deller@gmx.de>

diff --git a/drivers/parisc/pdc_stable.c b/drivers/parisc/pdc_stable.c
index 055f83fddc18..7147aa53e9a2 100644
--- a/drivers/parisc/pdc_stable.c
+++ b/drivers/parisc/pdc_stable.c
@@ -954,7 +954,7 @@ static struct attribute *pdcs_subsys_attrs[] = {
 	NULL,
 };
 
-static struct attribute_group pdcs_attr_group = {
+static const struct attribute_group pdcs_attr_group = {
 	.attrs = pdcs_subsys_attrs,
 };
 

commit 7c0f6ba682b9c7632072ffbedf8d328c8f3c42ba
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Dec 24 11:46:01 2016 -0800

    Replace <asm/uaccess.h> with <linux/uaccess.h> globally
    
    This was entirely automated, using the script by Al:
    
      PATT='^[[:blank:]]*#[[:blank:]]*include[[:blank:]]*<asm/uaccess.h>'
      sed -i -e "s!$PATT!#include <linux/uaccess.h>!" \
            $(git grep -l "$PATT"|grep -v ^include/linux/uaccess.h)
    
    to do the replacement at the end of the merge window.
    
    Requested-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/parisc/pdc_stable.c b/drivers/parisc/pdc_stable.c
index 3651c3871d5b..055f83fddc18 100644
--- a/drivers/parisc/pdc_stable.c
+++ b/drivers/parisc/pdc_stable.c
@@ -68,7 +68,7 @@
 
 #include <asm/pdc.h>
 #include <asm/page.h>
-#include <asm/uaccess.h>
+#include <linux/uaccess.h>
 #include <asm/hardware.h>
 
 #define PDCS_VERSION	"0.30"

commit c735483de1a2cd5d6c6b67bf49cfb2991eae6ea6
Author: Helge Deller <deller@gmx.de>
Date:   Sun Sep 21 22:31:08 2014 +0200

    parisc: pdc_stable.c: Avoid potential stack overflows
    
    Signed-off-by: Helge Deller <deller@gmx.de>

diff --git a/drivers/parisc/pdc_stable.c b/drivers/parisc/pdc_stable.c
index e4b73c2a053a..3651c3871d5b 100644
--- a/drivers/parisc/pdc_stable.c
+++ b/drivers/parisc/pdc_stable.c
@@ -278,7 +278,7 @@ pdcspath_hwpath_write(struct pdcspath_entry *entry, const char *buf, size_t coun
 {
 	struct hardware_path hwpath;
 	unsigned short i;
-	char in[count+1], *temp;
+	char in[64], *temp;
 	struct device *dev;
 	int ret;
 
@@ -286,8 +286,9 @@ pdcspath_hwpath_write(struct pdcspath_entry *entry, const char *buf, size_t coun
 		return -EINVAL;
 
 	/* We'll use a local copy of buf */
-	memset(in, 0, count+1);
+	count = min_t(size_t, count, sizeof(in)-1);
 	strncpy(in, buf, count);
+	in[count] = '\0';
 	
 	/* Let's clean up the target. 0xff is a blank pattern */
 	memset(&hwpath, 0xff, sizeof(hwpath));
@@ -393,14 +394,15 @@ pdcspath_layer_write(struct pdcspath_entry *entry, const char *buf, size_t count
 {
 	unsigned int layers[6]; /* device-specific info (ctlr#, unit#, ...) */
 	unsigned short i;
-	char in[count+1], *temp;
+	char in[64], *temp;
 
 	if (!entry || !buf || !count)
 		return -EINVAL;
 
 	/* We'll use a local copy of buf */
-	memset(in, 0, count+1);
+	count = min_t(size_t, count, sizeof(in)-1);
 	strncpy(in, buf, count);
+	in[count] = '\0';
 	
 	/* Let's clean up the target. 0 is a blank pattern */
 	memset(&layers, 0, sizeof(layers));
@@ -765,7 +767,7 @@ static ssize_t pdcs_auto_write(struct kobject *kobj,
 		return -EINVAL;
 
 	/* We'll use a local copy of buf */
-	count = min_t(size_t, count, 7);
+	count = min_t(size_t, count, sizeof(in)-1);
 	strncpy(in, buf, count);
 	in[count] = '\0';
 

commit 94c457deff2a211f8372f69a4d7b0d288183756a
Author: Rickard Strandqvist <rickard_strandqvist@spectrumdigital.se>
Date:   Sun Sep 14 18:02:12 2014 +0200

    parisc: pdc_stable.c: Cleaning up unnecessary use of memset in conjunction with strncpy
    
    Using memset before strncpy just to ensure a trailing null character is
    an unnecessary double writing of a string
    
    Patch modified by Helge Deller to additionally reduce stack usage.
    
    Signed-off-by: Rickard Strandqvist <rickard_strandqvist@spectrumdigital.se>
    Signed-off-by: Helge Deller <deller@gmx.de>

diff --git a/drivers/parisc/pdc_stable.c b/drivers/parisc/pdc_stable.c
index 0f54ab6260df..e4b73c2a053a 100644
--- a/drivers/parisc/pdc_stable.c
+++ b/drivers/parisc/pdc_stable.c
@@ -755,7 +755,7 @@ static ssize_t pdcs_auto_write(struct kobject *kobj,
 {
 	struct pdcspath_entry *pathentry;
 	unsigned char flags;
-	char in[count+1], *temp;
+	char in[8], *temp;
 	char c;
 
 	if (!capable(CAP_SYS_ADMIN))
@@ -765,8 +765,9 @@ static ssize_t pdcs_auto_write(struct kobject *kobj,
 		return -EINVAL;
 
 	/* We'll use a local copy of buf */
-	memset(in, 0, count+1);
+	count = min_t(size_t, count, 7);
 	strncpy(in, buf, count);
+	in[count] = '\0';
 
 	/* Current flags are stored in primary boot path entry */
 	pathentry = &pdcspath_entry_primary;

commit 93c3e913e104c9277e32a0d7e03f268d146c57ee
Author: Julia Lawall <Julia.Lawall@lip6.fr>
Date:   Sat Nov 3 10:58:36 2012 +0000

    drivers/parisc/pdc_stable.c: use WARN
    
    Use WARN rather than printk followed by WARN_ON(1), for conciseness.
    
    Signed-off-by: Julia Lawall <Julia.Lawall@lip6.fr>
    Signed-off-by: Helge Deller <deller@gmx.de>

diff --git a/drivers/parisc/pdc_stable.c b/drivers/parisc/pdc_stable.c
index 246a92f677e4..0f54ab6260df 100644
--- a/drivers/parisc/pdc_stable.c
+++ b/drivers/parisc/pdc_stable.c
@@ -212,12 +212,10 @@ pdcspath_store(struct pdcspath_entry *entry)
 			entry, devpath, entry->addr);
 
 	/* addr, devpath and count must be word aligned */
-	if (pdc_stable_write(entry->addr, devpath, sizeof(*devpath)) != PDC_OK) {
-		printk(KERN_ERR "%s: an error occurred when writing to PDC.\n"
+	if (pdc_stable_write(entry->addr, devpath, sizeof(*devpath)) != PDC_OK)
+		WARN(1, KERN_ERR "%s: an error occurred when writing to PDC.\n"
 				"It is likely that the Stable Storage data has been corrupted.\n"
 				"Please check it carefully upon next reboot.\n", __func__);
-		WARN_ON(1);
-	}
 		
 	/* kobject is already registered */
 	entry->ready = 2;

commit 25985edcedea6396277003854657b5f3cb31a628
Author: Lucas De Marchi <lucas.demarchi@profusion.mobi>
Date:   Wed Mar 30 22:57:33 2011 -0300

    Fix common misspellings
    
    Fixes generated by 'codespell' and manually reviewed.
    
    Signed-off-by: Lucas De Marchi <lucas.demarchi@profusion.mobi>

diff --git a/drivers/parisc/pdc_stable.c b/drivers/parisc/pdc_stable.c
index 1062b8ffe244..246a92f677e4 100644
--- a/drivers/parisc/pdc_stable.c
+++ b/drivers/parisc/pdc_stable.c
@@ -141,7 +141,7 @@ struct pdcspath_attribute paths_attr_##_name = { \
  * @entry: A pointer to an allocated pdcspath_entry.
  * 
  * The general idea is that you don't read from the Stable Storage every time
- * you access the files provided by the facilites. We store a copy of the
+ * you access the files provided by the facilities. We store a copy of the
  * content of the stable storage WRT various paths in these structs. We read
  * these structs when reading the files, and we will write to these structs when
  * writing to the files, and only then write them back to the Stable Storage.
@@ -213,7 +213,7 @@ pdcspath_store(struct pdcspath_entry *entry)
 
 	/* addr, devpath and count must be word aligned */
 	if (pdc_stable_write(entry->addr, devpath, sizeof(*devpath)) != PDC_OK) {
-		printk(KERN_ERR "%s: an error occured when writing to PDC.\n"
+		printk(KERN_ERR "%s: an error occurred when writing to PDC.\n"
 				"It is likely that the Stable Storage data has been corrupted.\n"
 				"Please check it carefully upon next reboot.\n", __func__);
 		WARN_ON(1);

commit 52cf25d0ab7f78eeecc59ac652ed5090f69b619e
Author: Emese Revfy <re.emese@gmail.com>
Date:   Tue Jan 19 02:58:23 2010 +0100

    Driver core: Constify struct sysfs_ops in struct kobj_type
    
    Constify struct sysfs_ops.
    
    This is part of the ops structure constification
    effort started by Arjan van de Ven et al.
    
    Benefits of this constification:
    
     * prevents modification of data that is shared
       (referenced) by many other structure instances
       at runtime
    
     * detects/prevents accidental (but not intentional)
       modification attempts on archs that enforce
       read-only kernel data at runtime
    
     * potentially better optimized code as the compiler
       can assume that the const data cannot be changed
    
     * the compiler/linker move const data into .rodata
       and therefore exclude them from false sharing
    
    Signed-off-by: Emese Revfy <re.emese@gmail.com>
    Acked-by: David Teigland <teigland@redhat.com>
    Acked-by: Matt Domsch <Matt_Domsch@dell.com>
    Acked-by: Maciej Sosnowski <maciej.sosnowski@intel.com>
    Acked-by: Hans J. Koch <hjk@linutronix.de>
    Acked-by: Pekka Enberg <penberg@cs.helsinki.fi>
    Acked-by: Jens Axboe <jens.axboe@oracle.com>
    Acked-by: Stephen Hemminger <shemminger@vyatta.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/parisc/pdc_stable.c b/drivers/parisc/pdc_stable.c
index 0bc5d474b168..1062b8ffe244 100644
--- a/drivers/parisc/pdc_stable.c
+++ b/drivers/parisc/pdc_stable.c
@@ -481,7 +481,7 @@ pdcspath_attr_store(struct kobject *kobj, struct attribute *attr,
 	return ret;
 }
 
-static struct sysfs_ops pdcspath_attr_ops = {
+static const struct sysfs_ops pdcspath_attr_ops = {
 	.show = pdcspath_attr_show,
 	.store = pdcspath_attr_store,
 };

commit e7d2860b690d4f3bed6824757c540579638e3d1e
Author: André Goddard Rosa <andre.goddard@gmail.com>
Date:   Mon Dec 14 18:01:06 2009 -0800

    tree-wide: convert open calls to remove spaces to skip_spaces() lib function
    
    Makes use of skip_spaces() defined in lib/string.c for removing leading
    spaces from strings all over the tree.
    
    It decreases lib.a code size by 47 bytes and reuses the function tree-wide:
       text    data     bss     dec     hex filename
      64688     584     592   65864   10148 (TOTALS-BEFORE)
      64641     584     592   65817   10119 (TOTALS-AFTER)
    
    Also, while at it, if we see (*str && isspace(*str)), we can be sure to
    remove the first condition (*str) as the second one (isspace(*str)) also
    evaluates to 0 whenever *str == 0, making it redundant. In other words,
    "a char equals zero is never a space".
    
    Julia Lawall tried the semantic patch (http://coccinelle.lip6.fr) below,
    and found occurrences of this pattern on 3 more files:
        drivers/leds/led-class.c
        drivers/leds/ledtrig-timer.c
        drivers/video/output.c
    
    @@
    expression str;
    @@
    
    ( // ignore skip_spaces cases
    while (*str &&  isspace(*str)) { \(str++;\|++str;\) }
    |
    - *str &&
    isspace(*str)
    )
    
    Signed-off-by: André Goddard Rosa <andre.goddard@gmail.com>
    Cc: Julia Lawall <julia@diku.dk>
    Cc: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Cc: Jeff Dike <jdike@addtoit.com>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: "H. Peter Anvin" <hpa@zytor.com>
    Cc: Richard Purdie <rpurdie@rpsys.net>
    Cc: Neil Brown <neilb@suse.de>
    Cc: Kyle McMartin <kyle@mcmartin.ca>
    Cc: Henrique de Moraes Holschuh <hmh@hmh.eng.br>
    Cc: David Howells <dhowells@redhat.com>
    Cc: <linux-ext4@vger.kernel.org>
    Cc: Samuel Ortiz <samuel@sortiz.org>
    Cc: Patrick McHardy <kaber@trash.net>
    Cc: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/parisc/pdc_stable.c b/drivers/parisc/pdc_stable.c
index 13a64bc081b6..0bc5d474b168 100644
--- a/drivers/parisc/pdc_stable.c
+++ b/drivers/parisc/pdc_stable.c
@@ -779,12 +779,9 @@ static ssize_t pdcs_auto_write(struct kobject *kobj,
 	read_unlock(&pathentry->rw_lock);
 	
 	DPRINTK("%s: flags before: 0x%X\n", __func__, flags);
-			
-	temp = in;
-	
-	while (*temp && isspace(*temp))
-		temp++;
-	
+
+	temp = skip_spaces(in);
+
 	c = *temp++ - '0';
 	if ((c != 0) && (c != 1))
 		goto parse_error;

commit 447c233da4d109c6194fefd69e5185cbc93cc062
Author: Roel Kluin <roel.kluin@gmail.com>
Date:   Sun Aug 2 08:02:28 2009 +0000

    parisc: Fix read buffer overflow in pdc_stable driver
    
    Check whether index is within bounds before testing the element.
    
    Signed-off-by: Roel Kluin <roel.kluin@gmail.com>
    Signed-off-by: Helge Deller <deller@gmx.de>

diff --git a/drivers/parisc/pdc_stable.c b/drivers/parisc/pdc_stable.c
index f9f9a5f1bbd0..13a64bc081b6 100644
--- a/drivers/parisc/pdc_stable.c
+++ b/drivers/parisc/pdc_stable.c
@@ -370,7 +370,7 @@ pdcspath_layer_read(struct pdcspath_entry *entry, char *buf)
 	if (!i)	/* entry is not ready */
 		return -ENODATA;
 	
-	for (i = 0; devpath->layers[i] && (likely(i < 6)); i++)
+	for (i = 0; i < 6 && devpath->layers[i]; i++)
 		out += sprintf(out, "%u ", devpath->layers[i]);
 
 	out += sprintf(out, "\n");

commit ff451d70593040df1a7c3df80a38e9ce530e12e0
Author: Joel Soete <rubisher@scarlet.be>
Date:   Mon Feb 18 18:26:11 2008 -0800

    [PARISC] pdc_stable: fix compile errors
    
    Signed-off-by: Joel Soete <rubisher@scarlet.be>
    Signed-off-by: Kyle McMartin <kyle@parisc-linux.org>

diff --git a/drivers/parisc/pdc_stable.c b/drivers/parisc/pdc_stable.c
index de34aa9d3136..f9f9a5f1bbd0 100644
--- a/drivers/parisc/pdc_stable.c
+++ b/drivers/parisc/pdc_stable.c
@@ -829,7 +829,7 @@ static ssize_t pdcs_autoboot_write(struct kobject *kobj,
 				   struct kobj_attribute *attr,
 				   const char *buf, size_t count)
 {
-	return pdcs_auto_write(kset, attr, buf, count, PF_AUTOBOOT);
+	return pdcs_auto_write(kobj, attr, buf, count, PF_AUTOBOOT);
 }
 
 /**
@@ -845,7 +845,7 @@ static ssize_t pdcs_autosearch_write(struct kobject *kobj,
 				     struct kobj_attribute *attr,
 				     const char *buf, size_t count)
 {
-	return pdcs_auto_write(kset, attr, buf, count, PF_AUTOSEARCH);
+	return pdcs_auto_write(kobj, attr, buf, count, PF_AUTOSEARCH);
 }
 
 /**
@@ -1066,7 +1066,7 @@ pdc_stable_init(void)
 	}
 
 	/* Don't forget the root entries */
-	error = sysfs_create_group(stable_kobj, pdcs_attr_group);
+	error = sysfs_create_group(stable_kobj, &pdcs_attr_group);
 
 	/* register the paths kset as a child of the stable kset */
 	paths_kset = kset_create_and_add("paths", NULL, stable_kobj);

commit c10997f6575f476ff38442fa18fd4a0d80345f9d
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Thu Dec 20 08:13:05 2007 -0800

    Kobject: convert drivers/* from kobject_unregister() to kobject_put()
    
    There is no need for kobject_unregister() anymore, thanks to Kay's
    kobject cleanup changes, so replace all instances of it with
    kobject_put().
    
    
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/parisc/pdc_stable.c b/drivers/parisc/pdc_stable.c
index 87bc6b73b249..de34aa9d3136 100644
--- a/drivers/parisc/pdc_stable.c
+++ b/drivers/parisc/pdc_stable.c
@@ -1026,7 +1026,7 @@ pdcs_unregister_pathentries(void)
 	for (i = 0; (entry = pdcspath_entries[i]); i++) {
 		read_lock(&entry->rw_lock);
 		if (entry->ready >= 2)
-			kobject_unregister(&entry->kobj);
+			kobject_put(&entry->kobj);
 		read_unlock(&entry->rw_lock);
 	}
 }
@@ -1086,7 +1086,7 @@ pdc_stable_init(void)
 	kset_unregister(paths_kset);
 	
 fail_ksetreg:
-	kobject_unregister(stable_kobj);
+	kobject_put(stable_kobj);
 	
 fail_firmreg:
 	printk(KERN_INFO PDCS_PREFIX " bailing out\n");
@@ -1098,7 +1098,7 @@ pdc_stable_exit(void)
 {
 	pdcs_unregister_pathentries();
 	kset_unregister(paths_kset);
-	kobject_unregister(stable_kobj);
+	kobject_put(stable_kobj);
 }
 
 

commit 73f368cf679babef42e54f0fe19270040ac9d4d7
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon Dec 17 15:54:39 2007 -0400

    Kobject: change drivers/parisc/pdc_stable.c to use kobject_init_and_add
    
    Stop using kobject_register, as this way we can control the sending of
    the uevent properly, after everything is properly initialized.
    
    Cc: Kyle McMartin <kyle@parisc-linux.org>
    Cc: Matthew Wilcox <matthew@wil.cx>
    Cc: Grant Grundler <grundler@parisc-linux.org>
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/parisc/pdc_stable.c b/drivers/parisc/pdc_stable.c
index 880b10b8a311..87bc6b73b249 100644
--- a/drivers/parisc/pdc_stable.c
+++ b/drivers/parisc/pdc_stable.c
@@ -991,13 +991,12 @@ pdcs_register_pathentries(void)
 		if (err < 0)
 			continue;
 
-		if ((err = kobject_set_name(&entry->kobj, "%s", entry->name)))
-			return err;
 		entry->kobj.kset = paths_kset;
-		entry->kobj.ktype = &ktype_pdcspath;
-		if ((err = kobject_register(&entry->kobj)))
+		err = kobject_init_and_add(&entry->kobj, &ktype_pdcspath, NULL,
+					   "%s", entry->name);
+		if (err)
 			return err;
-		
+
 		/* kobject is now registered */
 		write_lock(&entry->rw_lock);
 		entry->ready = 2;
@@ -1009,6 +1008,7 @@ pdcs_register_pathentries(void)
 		}
 
 		write_unlock(&entry->rw_lock);
+		kobject_uevent(&entry->kobj, KOBJ_ADD);
 	}
 	
 	return 0;

commit c829a5b49858a83cc7bb5e1e730796575f5bb261
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Wed Nov 7 13:56:19 2007 -0800

    kobject: convert parisc/pdc_stable to use kobject_create
    
    Using a kset for this simple directory is an overkill.
    
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Cc: Thibaut VARENE <varenet@parisc-linux.org>
    Cc: Matthew Wilcox <matthew@wil.cx>
    Cc: Grant Grundler <grundler@parisc-linux.org>
    Cc: Kyle McMartin <kyle@parisc-linux.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/parisc/pdc_stable.c b/drivers/parisc/pdc_stable.c
index ef1a353e5540..880b10b8a311 100644
--- a/drivers/parisc/pdc_stable.c
+++ b/drivers/parisc/pdc_stable.c
@@ -960,7 +960,7 @@ static struct attribute_group pdcs_attr_group = {
 	.attrs = pdcs_subsys_attrs,
 };
 
-static struct kset *stable_kset;
+static struct kobject *stable_kobj;
 static struct kset *paths_kset;
 
 /**
@@ -1058,18 +1058,18 @@ pdc_stable_init(void)
 	/* the actual result is 16 bits away */
 	pdcs_osid = (u16)(result >> 16);
 
-	/* For now we'll register the stable kset within this driver */
-	stable_kset = kset_create_and_add("stable", NULL, firmware_kobj);
-	if (!stable_kset) {
+	/* For now we'll register the directory at /sys/firmware/stable */
+	stable_kobj = kobject_create_and_add("stable", firmware_kobj);
+	if (!stable_kobj) {
 		rc = -ENOMEM;
 		goto fail_firmreg;
 	}
 
 	/* Don't forget the root entries */
-	error = sysfs_create_group(&stable_kset->kobj, pdcs_attr_group);
+	error = sysfs_create_group(stable_kobj, pdcs_attr_group);
 
 	/* register the paths kset as a child of the stable kset */
-	paths_kset = kset_create_and_add("paths", NULL, &stable_kset->kobj);
+	paths_kset = kset_create_and_add("paths", NULL, stable_kobj);
 	if (!paths_kset) {
 		rc = -ENOMEM;
 		goto fail_ksetreg;
@@ -1086,7 +1086,7 @@ pdc_stable_init(void)
 	kset_unregister(paths_kset);
 	
 fail_ksetreg:
-	kset_unregister(stable_kset);
+	kobject_unregister(stable_kobj);
 	
 fail_firmreg:
 	printk(KERN_INFO PDCS_PREFIX " bailing out\n");
@@ -1098,7 +1098,7 @@ pdc_stable_exit(void)
 {
 	pdcs_unregister_pathentries();
 	kset_unregister(paths_kset);
-	kset_unregister(stable_kset);
+	kobject_unregister(stable_kobj);
 }
 
 

commit f62ed9e33b3ccff54d66b08f82d11940bb9e269b
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon Nov 5 13:16:15 2007 -0800

    firmware: change firmware_kset to firmware_kobj
    
    There is no firmware "subsystem" it's just a directory in /sys that
    other portions of the kernel want to hook into.  So make it a kobject
    not a kset to help alivate anyone who tries to do some odd kset-like
    things with this.
    
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Cc: Cornelia Huck <cornelia.huck@de.ibm.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/parisc/pdc_stable.c b/drivers/parisc/pdc_stable.c
index 444483405abf..ef1a353e5540 100644
--- a/drivers/parisc/pdc_stable.c
+++ b/drivers/parisc/pdc_stable.c
@@ -1059,7 +1059,7 @@ pdc_stable_init(void)
 	pdcs_osid = (u16)(result >> 16);
 
 	/* For now we'll register the stable kset within this driver */
-	stable_kset = kset_create_and_add("stable", NULL, &firmware_kset->kobj);
+	stable_kset = kset_create_and_add("stable", NULL, firmware_kobj);
 	if (!stable_kset) {
 		rc = -ENOMEM;
 		goto fail_firmreg;

commit 4443d07fcfab39c4d2d9d7711cff983f15b374fc
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Fri Nov 2 15:25:00 2007 -0700

    kset: convert parisc/pdc_stable.c to use kset_create
    
    Dynamically create the kset instead of declaring it statically.
    This makes the kobject attributes now work properly that I broke in the
    previous patch.
    
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Cc: Thibaut VARENE <varenet@parisc-linux.org>
    Cc: Matthew Wilcox <matthew@wil.cx>
    Cc: Grant Grundler <grundler@parisc-linux.org>
    Cc: Kyle McMartin <kyle@parisc-linux.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/parisc/pdc_stable.c b/drivers/parisc/pdc_stable.c
index e1b9cbaf4456..444483405abf 100644
--- a/drivers/parisc/pdc_stable.c
+++ b/drivers/parisc/pdc_stable.c
@@ -960,8 +960,8 @@ static struct attribute_group pdcs_attr_group = {
 	.attrs = pdcs_subsys_attrs,
 };
 
-static decl_subsys(paths, NULL);
-static decl_subsys(stable, NULL);
+static struct kset *stable_kset;
+static struct kset *paths_kset;
 
 /**
  * pdcs_register_pathentries - Prepares path entries kobjects for sysfs usage.
@@ -993,7 +993,7 @@ pdcs_register_pathentries(void)
 
 		if ((err = kobject_set_name(&entry->kobj, "%s", entry->name)))
 			return err;
-		entry->kobj.kset = &paths_subsys;
+		entry->kobj.kset = paths_kset;
 		entry->kobj.ktype = &ktype_pdcspath;
 		if ((err = kobject_register(&entry->kobj)))
 			return err;
@@ -1058,19 +1058,24 @@ pdc_stable_init(void)
 	/* the actual result is 16 bits away */
 	pdcs_osid = (u16)(result >> 16);
 
-	/* For now we'll register the stable subsys within this driver */
-	if ((rc = firmware_register(&stable_subsys)))
+	/* For now we'll register the stable kset within this driver */
+	stable_kset = kset_create_and_add("stable", NULL, &firmware_kset->kobj);
+	if (!stable_kset) {
+		rc = -ENOMEM;
 		goto fail_firmreg;
+	}
 
 	/* Don't forget the root entries */
-	error = sysfs_create_group(&stable_subsys.kobj, pdcs_attr_group);
+	error = sysfs_create_group(&stable_kset->kobj, pdcs_attr_group);
 
-	/* register the paths subsys as a subsystem of stable subsys */
-	paths_subsys.kobj.kset = &stable_subsys;
-	if ((rc = subsystem_register(&paths_subsys)))
-		goto fail_subsysreg;
+	/* register the paths kset as a child of the stable kset */
+	paths_kset = kset_create_and_add("paths", NULL, &stable_kset->kobj);
+	if (!paths_kset) {
+		rc = -ENOMEM;
+		goto fail_ksetreg;
+	}
 
-	/* now we create all "files" for the paths subsys */
+	/* now we create all "files" for the paths kset */
 	if ((rc = pdcs_register_pathentries()))
 		goto fail_pdcsreg;
 
@@ -1078,10 +1083,10 @@ pdc_stable_init(void)
 	
 fail_pdcsreg:
 	pdcs_unregister_pathentries();
-	subsystem_unregister(&paths_subsys);
+	kset_unregister(paths_kset);
 	
-fail_subsysreg:
-	firmware_unregister(&stable_subsys);
+fail_ksetreg:
+	kset_unregister(stable_kset);
 	
 fail_firmreg:
 	printk(KERN_INFO PDCS_PREFIX " bailing out\n");
@@ -1092,9 +1097,8 @@ static void __exit
 pdc_stable_exit(void)
 {
 	pdcs_unregister_pathentries();
-	subsystem_unregister(&paths_subsys);
-
-	firmware_unregister(&stable_subsys);
+	kset_unregister(paths_kset);
+	kset_unregister(stable_kset);
 }
 
 

commit 7f548217860a7cf8a345d87792a07512450dfbff
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Fri Nov 2 15:25:00 2007 -0700

    kobject: convert parisc/pdc_stable to kobj_attr interface
    
    This makes the code a bit simpler and and gets us one step closer to
    deleting the deprecated subsys_attr code.
    
    NOTE, this needs the next patch in the series in order to work properly.
    This will build, but the sysfs files will not properly operate.
    
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Cc: Thibaut VARENE <varenet@parisc-linux.org>
    Cc: Matthew Wilcox <matthew@wil.cx>
    Cc: Grant Grundler <grundler@parisc-linux.org>
    Cc: Kyle McMartin <kyle@parisc-linux.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/parisc/pdc_stable.c b/drivers/parisc/pdc_stable.c
index 1382be64cc3f..e1b9cbaf4456 100644
--- a/drivers/parisc/pdc_stable.c
+++ b/drivers/parisc/pdc_stable.c
@@ -120,7 +120,7 @@ struct pdcspath_entry pdcspath_entry_##_name = { \
 };
 
 #define PDCS_ATTR(_name, _mode, _show, _store) \
-struct subsys_attribute pdcs_attr_##_name = { \
+struct kobj_attribute pdcs_attr_##_name = { \
 	.attr = {.name = __stringify(_name), .mode = _mode}, \
 	.show = _show, \
 	.store = _store, \
@@ -523,15 +523,15 @@ static struct pdcspath_entry *pdcspath_entries[] = {
 
 /**
  * pdcs_size_read - Stable Storage size output.
- * @kset: An allocated and populated struct kset. We don't use it tho.
  * @buf: The output buffer to write to.
  */
-static ssize_t
-pdcs_size_read(struct kset *kset, char *buf)
+static ssize_t pdcs_size_read(struct kobject *kobj,
+			      struct kobj_attribute *attr,
+			      char *buf)
 {
 	char *out = buf;
 
-	if (!kset || !buf)
+	if (!buf)
 		return -EINVAL;
 
 	/* show the size of the stable storage */
@@ -542,17 +542,17 @@ pdcs_size_read(struct kset *kset, char *buf)
 
 /**
  * pdcs_auto_read - Stable Storage autoboot/search flag output.
- * @kset: An allocated and populated struct kset. We don't use it tho.
  * @buf: The output buffer to write to.
  * @knob: The PF_AUTOBOOT or PF_AUTOSEARCH flag
  */
-static ssize_t
-pdcs_auto_read(struct kset *kset, char *buf, int knob)
+static ssize_t pdcs_auto_read(struct kobject *kobj,
+			      struct kobj_attribute *attr,
+			      char *buf, int knob)
 {
 	char *out = buf;
 	struct pdcspath_entry *pathentry;
 
-	if (!kset || !buf)
+	if (!buf)
 		return -EINVAL;
 
 	/* Current flags are stored in primary boot path entry */
@@ -568,40 +568,37 @@ pdcs_auto_read(struct kset *kset, char *buf, int knob)
 
 /**
  * pdcs_autoboot_read - Stable Storage autoboot flag output.
- * @kset: An allocated and populated struct kset. We don't use it tho.
  * @buf: The output buffer to write to.
  */
-static inline ssize_t
-pdcs_autoboot_read(struct kset *kset, char *buf)
+static ssize_t pdcs_autoboot_read(struct kobject *kobj,
+				  struct kobj_attribute *attr, char *buf)
 {
-	return pdcs_auto_read(kset, buf, PF_AUTOBOOT);
+	return pdcs_auto_read(kobj, attr, buf, PF_AUTOBOOT);
 }
 
 /**
  * pdcs_autosearch_read - Stable Storage autoboot flag output.
- * @kset: An allocated and populated struct kset. We don't use it tho.
  * @buf: The output buffer to write to.
  */
-static inline ssize_t
-pdcs_autosearch_read(struct kset *kset, char *buf)
+static ssize_t pdcs_autosearch_read(struct kobject *kobj,
+				    struct kobj_attribute *attr, char *buf)
 {
-	return pdcs_auto_read(kset, buf, PF_AUTOSEARCH);
+	return pdcs_auto_read(kobj, attr, buf, PF_AUTOSEARCH);
 }
 
 /**
  * pdcs_timer_read - Stable Storage timer count output (in seconds).
- * @kset: An allocated and populated struct kset. We don't use it tho.
  * @buf: The output buffer to write to.
  *
  * The value of the timer field correponds to a number of seconds in powers of 2.
  */
-static ssize_t
-pdcs_timer_read(struct kset *kset, char *buf)
+static ssize_t pdcs_timer_read(struct kobject *kobj,
+			       struct kobj_attribute *attr, char *buf)
 {
 	char *out = buf;
 	struct pdcspath_entry *pathentry;
 
-	if (!kset || !buf)
+	if (!buf)
 		return -EINVAL;
 
 	/* Current flags are stored in primary boot path entry */
@@ -618,15 +615,14 @@ pdcs_timer_read(struct kset *kset, char *buf)
 
 /**
  * pdcs_osid_read - Stable Storage OS ID register output.
- * @kset: An allocated and populated struct kset. We don't use it tho.
  * @buf: The output buffer to write to.
  */
-static ssize_t
-pdcs_osid_read(struct kset *kset, char *buf)
+static ssize_t pdcs_osid_read(struct kobject *kobj,
+			      struct kobj_attribute *attr, char *buf)
 {
 	char *out = buf;
 
-	if (!kset || !buf)
+	if (!buf)
 		return -EINVAL;
 
 	out += sprintf(out, "%s dependent data (0x%.4x)\n",
@@ -637,18 +633,17 @@ pdcs_osid_read(struct kset *kset, char *buf)
 
 /**
  * pdcs_osdep1_read - Stable Storage OS-Dependent data area 1 output.
- * @kset: An allocated and populated struct kset. We don't use it tho.
  * @buf: The output buffer to write to.
  *
  * This can hold 16 bytes of OS-Dependent data.
  */
-static ssize_t
-pdcs_osdep1_read(struct kset *kset, char *buf)
+static ssize_t pdcs_osdep1_read(struct kobject *kobj,
+				struct kobj_attribute *attr, char *buf)
 {
 	char *out = buf;
 	u32 result[4];
 
-	if (!kset || !buf)
+	if (!buf)
 		return -EINVAL;
 
 	if (pdc_stable_read(PDCS_ADDR_OSD1, &result, sizeof(result)) != PDC_OK)
@@ -664,18 +659,17 @@ pdcs_osdep1_read(struct kset *kset, char *buf)
 
 /**
  * pdcs_diagnostic_read - Stable Storage Diagnostic register output.
- * @kset: An allocated and populated struct kset. We don't use it tho.
  * @buf: The output buffer to write to.
  *
  * I have NFC how to interpret the content of that register ;-).
  */
-static ssize_t
-pdcs_diagnostic_read(struct kset *kset, char *buf)
+static ssize_t pdcs_diagnostic_read(struct kobject *kobj,
+				    struct kobj_attribute *attr, char *buf)
 {
 	char *out = buf;
 	u32 result;
 
-	if (!kset || !buf)
+	if (!buf)
 		return -EINVAL;
 
 	/* get diagnostic */
@@ -689,18 +683,17 @@ pdcs_diagnostic_read(struct kset *kset, char *buf)
 
 /**
  * pdcs_fastsize_read - Stable Storage FastSize register output.
- * @kset: An allocated and populated struct kset. We don't use it tho.
  * @buf: The output buffer to write to.
  *
  * This register holds the amount of system RAM to be tested during boot sequence.
  */
-static ssize_t
-pdcs_fastsize_read(struct kset *kset, char *buf)
+static ssize_t pdcs_fastsize_read(struct kobject *kobj,
+				  struct kobj_attribute *attr, char *buf)
 {
 	char *out = buf;
 	u32 result;
 
-	if (!kset || !buf)
+	if (!buf)
 		return -EINVAL;
 
 	/* get fast-size */
@@ -718,13 +711,12 @@ pdcs_fastsize_read(struct kset *kset, char *buf)
 
 /**
  * pdcs_osdep2_read - Stable Storage OS-Dependent data area 2 output.
- * @kset: An allocated and populated struct kset. We don't use it tho.
  * @buf: The output buffer to write to.
  *
  * This can hold pdcs_size - 224 bytes of OS-Dependent data, when available.
  */
-static ssize_t
-pdcs_osdep2_read(struct kset *kset, char *buf)
+static ssize_t pdcs_osdep2_read(struct kobject *kobj,
+				struct kobj_attribute *attr, char *buf)
 {
 	char *out = buf;
 	unsigned long size;
@@ -736,7 +728,7 @@ pdcs_osdep2_read(struct kset *kset, char *buf)
 
 	size = pdcs_size - 224;
 
-	if (!kset || !buf)
+	if (!buf)
 		return -EINVAL;
 
 	for (i=0; i<size; i+=4) {
@@ -751,7 +743,6 @@ pdcs_osdep2_read(struct kset *kset, char *buf)
 
 /**
  * pdcs_auto_write - This function handles autoboot/search flag modifying.
- * @kset: An allocated and populated struct kset. We don't use it tho.
  * @buf: The input buffer to read from.
  * @count: The number of bytes to be read.
  * @knob: The PF_AUTOBOOT or PF_AUTOSEARCH flag
@@ -760,8 +751,9 @@ pdcs_osdep2_read(struct kset *kset, char *buf)
  * We expect a precise syntax:
  *	\"n\" (n == 0 or 1) to toggle AutoBoot Off or On
  */
-static ssize_t
-pdcs_auto_write(struct kset *kset, const char *buf, size_t count, int knob)
+static ssize_t pdcs_auto_write(struct kobject *kobj,
+			       struct kobj_attribute *attr, const char *buf,
+			       size_t count, int knob)
 {
 	struct pdcspath_entry *pathentry;
 	unsigned char flags;
@@ -771,7 +763,7 @@ pdcs_auto_write(struct kset *kset, const char *buf, size_t count, int knob)
 	if (!capable(CAP_SYS_ADMIN))
 		return -EACCES;
 
-	if (!kset || !buf || !count)
+	if (!buf || !count)
 		return -EINVAL;
 
 	/* We'll use a local copy of buf */
@@ -826,7 +818,6 @@ pdcs_auto_write(struct kset *kset, const char *buf, size_t count, int knob)
 
 /**
  * pdcs_autoboot_write - This function handles autoboot flag modifying.
- * @kset: An allocated and populated struct kset. We don't use it tho.
  * @buf: The input buffer to read from.
  * @count: The number of bytes to be read.
  *
@@ -834,15 +825,15 @@ pdcs_auto_write(struct kset *kset, const char *buf, size_t count, int knob)
  * We expect a precise syntax:
  *	\"n\" (n == 0 or 1) to toggle AutoSearch Off or On
  */
-static inline ssize_t
-pdcs_autoboot_write(struct kset *kset, const char *buf, size_t count)
+static ssize_t pdcs_autoboot_write(struct kobject *kobj,
+				   struct kobj_attribute *attr,
+				   const char *buf, size_t count)
 {
-	return pdcs_auto_write(kset, buf, count, PF_AUTOBOOT);
+	return pdcs_auto_write(kset, attr, buf, count, PF_AUTOBOOT);
 }
 
 /**
  * pdcs_autosearch_write - This function handles autosearch flag modifying.
- * @kset: An allocated and populated struct kset. We don't use it tho.
  * @buf: The input buffer to read from.
  * @count: The number of bytes to be read.
  *
@@ -850,15 +841,15 @@ pdcs_autoboot_write(struct kset *kset, const char *buf, size_t count)
  * We expect a precise syntax:
  *	\"n\" (n == 0 or 1) to toggle AutoSearch Off or On
  */
-static inline ssize_t
-pdcs_autosearch_write(struct kset *kset, const char *buf, size_t count)
+static ssize_t pdcs_autosearch_write(struct kobject *kobj,
+				     struct kobj_attribute *attr,
+				     const char *buf, size_t count)
 {
-	return pdcs_auto_write(kset, buf, count, PF_AUTOSEARCH);
+	return pdcs_auto_write(kset, attr, buf, count, PF_AUTOSEARCH);
 }
 
 /**
  * pdcs_osdep1_write - Stable Storage OS-Dependent data area 1 input.
- * @kset: An allocated and populated struct kset. We don't use it tho.
  * @buf: The input buffer to read from.
  * @count: The number of bytes to be read.
  *
@@ -866,15 +857,16 @@ pdcs_autosearch_write(struct kset *kset, const char *buf, size_t count)
  * write approach. It's up to userspace to deal with it when constructing
  * its input buffer.
  */
-static ssize_t
-pdcs_osdep1_write(struct kset *kset, const char *buf, size_t count)
+static ssize_t pdcs_osdep1_write(struct kobject *kobj,
+				 struct kobj_attribute *attr,
+				 const char *buf, size_t count)
 {
 	u8 in[16];
 
 	if (!capable(CAP_SYS_ADMIN))
 		return -EACCES;
 
-	if (!kset || !buf || !count)
+	if (!buf || !count)
 		return -EINVAL;
 
 	if (unlikely(pdcs_osid != OS_ID_LINUX))
@@ -895,7 +887,6 @@ pdcs_osdep1_write(struct kset *kset, const char *buf, size_t count)
 
 /**
  * pdcs_osdep2_write - Stable Storage OS-Dependent data area 2 input.
- * @kset: An allocated and populated struct kset. We don't use it tho.
  * @buf: The input buffer to read from.
  * @count: The number of bytes to be read.
  *
@@ -903,8 +894,9 @@ pdcs_osdep1_write(struct kset *kset, const char *buf, size_t count)
  * byte-by-byte write approach. It's up to userspace to deal with it when
  * constructing its input buffer.
  */
-static ssize_t
-pdcs_osdep2_write(struct kset *kset, const char *buf, size_t count)
+static ssize_t pdcs_osdep2_write(struct kobject *kobj,
+				 struct kobj_attribute *attr,
+				 const char *buf, size_t count)
 {
 	unsigned long size;
 	unsigned short i;
@@ -913,7 +905,7 @@ pdcs_osdep2_write(struct kset *kset, const char *buf, size_t count)
 	if (!capable(CAP_SYS_ADMIN))
 		return -EACCES;
 
-	if (!kset || !buf || !count)
+	if (!buf || !count)
 		return -EINVAL;
 
 	if (unlikely(pdcs_size <= 224))
@@ -951,19 +943,23 @@ static PDCS_ATTR(diagnostic, 0400, pdcs_diagnostic_read, NULL);
 static PDCS_ATTR(fastsize, 0400, pdcs_fastsize_read, NULL);
 static PDCS_ATTR(osdep2, 0600, pdcs_osdep2_read, pdcs_osdep2_write);
 
-static struct subsys_attribute *pdcs_subsys_attrs[] = {
-	&pdcs_attr_size,
-	&pdcs_attr_autoboot,
-	&pdcs_attr_autosearch,
-	&pdcs_attr_timer,
-	&pdcs_attr_osid,
-	&pdcs_attr_osdep1,
-	&pdcs_attr_diagnostic,
-	&pdcs_attr_fastsize,
-	&pdcs_attr_osdep2,
+static struct attribute *pdcs_subsys_attrs[] = {
+	&pdcs_attr_size.attr,
+	&pdcs_attr_autoboot.attr,
+	&pdcs_attr_autosearch.attr,
+	&pdcs_attr_timer.attr,
+	&pdcs_attr_osid.attr,
+	&pdcs_attr_osdep1.attr,
+	&pdcs_attr_diagnostic.attr,
+	&pdcs_attr_fastsize.attr,
+	&pdcs_attr_osdep2.attr,
 	NULL,
 };
 
+static struct attribute_group pdcs_attr_group = {
+	.attrs = pdcs_subsys_attrs,
+};
+
 static decl_subsys(paths, NULL);
 static decl_subsys(stable, NULL);
 
@@ -1042,8 +1038,7 @@ pdcs_unregister_pathentries(void)
 static int __init
 pdc_stable_init(void)
 {
-	struct subsys_attribute *attr;
-	int i, rc = 0, error = 0;
+	int rc = 0, error = 0;
 	u32 result;
 
 	/* find the size of the stable storage */
@@ -1068,10 +1063,8 @@ pdc_stable_init(void)
 		goto fail_firmreg;
 
 	/* Don't forget the root entries */
-	for (i = 0; (attr = pdcs_subsys_attrs[i]) && !error; i++)
-		if (attr->show)
-			error = subsys_create_file(&stable_subsys, attr);
-	
+	error = sysfs_create_group(&stable_subsys.kobj, pdcs_attr_group);
+
 	/* register the paths subsys as a subsystem of stable subsys */
 	paths_subsys.kobj.kset = &stable_subsys;
 	if ((rc = subsystem_register(&paths_subsys)))

commit 3514faca19a6fdc209734431c509631ea92b094e
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Tue Oct 16 10:11:44 2007 -0600

    kobject: remove struct kobj_type from struct kset
    
    We don't need a "default" ktype for a kset.  We should set this
    explicitly every time for each kset.  This change is needed so that we
    can make ksets dynamic, and cleans up one of the odd, undocumented
    assumption that the kset/kobject/ktype model has.
    
    This patch is based on a lot of help from Kay Sievers.
    
    Nasty bug in the block code was found by Dave Young
    <hidave.darkstar@gmail.com>
    
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Cc: Dave Young <hidave.darkstar@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/parisc/pdc_stable.c b/drivers/parisc/pdc_stable.c
index ebb09e98d215..1382be64cc3f 100644
--- a/drivers/parisc/pdc_stable.c
+++ b/drivers/parisc/pdc_stable.c
@@ -964,8 +964,8 @@ static struct subsys_attribute *pdcs_subsys_attrs[] = {
 	NULL,
 };
 
-static decl_subsys(paths, &ktype_pdcspath, NULL);
-static decl_subsys(stable, NULL, NULL);
+static decl_subsys(paths, NULL);
+static decl_subsys(stable, NULL);
 
 /**
  * pdcs_register_pathentries - Prepares path entries kobjects for sysfs usage.
@@ -997,7 +997,8 @@ pdcs_register_pathentries(void)
 
 		if ((err = kobject_set_name(&entry->kobj, "%s", entry->name)))
 			return err;
-		kobj_set_kset_s(entry, paths_subsys);
+		entry->kobj.kset = &paths_subsys;
+		entry->kobj.ktype = &ktype_pdcspath;
 		if ((err = kobject_register(&entry->kobj)))
 			return err;
 		
@@ -1072,7 +1073,7 @@ pdc_stable_init(void)
 			error = subsys_create_file(&stable_subsys, attr);
 	
 	/* register the paths subsys as a subsystem of stable subsys */
-	kobj_set_kset_s(&paths_subsys, stable_subsys);
+	paths_subsys.kobj.kset = &stable_subsys;
 	if ((rc = subsystem_register(&paths_subsys)))
 		goto fail_subsysreg;
 

commit 26f0324922e50e0ef7677aaf96287b862c2fec61
Author: Kyle McMartin <kyle@mcmartin.ca>
Date:   Thu Oct 18 00:04:06 2007 -0700

    [PARISC] Quiet sysfs_create_link __must_check warnings in pdc_stable
    
    Failing to create the links doesn't seem like a fatal error in these
    paths. WARN_ON seems better than nothing though.
    
    Signed-off-by: Kyle McMartin <kyle@mcmartin.ca>

diff --git a/drivers/parisc/pdc_stable.c b/drivers/parisc/pdc_stable.c
index fc4bde259dc7..ebb09e98d215 100644
--- a/drivers/parisc/pdc_stable.c
+++ b/drivers/parisc/pdc_stable.c
@@ -282,6 +282,7 @@ pdcspath_hwpath_write(struct pdcspath_entry *entry, const char *buf, size_t coun
 	unsigned short i;
 	char in[count+1], *temp;
 	struct device *dev;
+	int ret;
 
 	if (!entry || !buf || !count)
 		return -EINVAL;
@@ -333,7 +334,9 @@ pdcspath_hwpath_write(struct pdcspath_entry *entry, const char *buf, size_t coun
 	
 	/* Update the symlink to the real device */
 	sysfs_remove_link(&entry->kobj, "device");
-	sysfs_create_link(&entry->kobj, &entry->dev->kobj, "device");
+	ret = sysfs_create_link(&entry->kobj, &entry->dev->kobj, "device");
+	WARN_ON(ret);
+
 	write_unlock(&entry->rw_lock);
 	
 	printk(KERN_INFO PDCS_PREFIX ": changed \"%s\" path to \"%s\"\n",
@@ -1003,8 +1006,10 @@ pdcs_register_pathentries(void)
 		entry->ready = 2;
 		
 		/* Add a nice symlink to the real device */
-		if (entry->dev)
-			sysfs_create_link(&entry->kobj, &entry->dev->kobj, "device");
+		if (entry->dev) {
+			err = sysfs_create_link(&entry->kobj, &entry->dev->kobj, "device");
+			WARN_ON(err);
+		}
 
 		write_unlock(&entry->rw_lock);
 	}

commit 7b595756ec1f49e0049a9e01a1298d53a7faaa15
Author: Tejun Heo <htejun@gmail.com>
Date:   Thu Jun 14 03:45:17 2007 +0900

    sysfs: kill unnecessary attribute->owner
    
    sysfs is now completely out of driver/module lifetime game.  After
    deletion, a sysfs node doesn't access anything outside sysfs proper,
    so there's no reason to hold onto the attribute owners.  Note that
    often the wrong modules were accounted for as owners leading to
    accessing removed modules.
    
    This patch kills now unnecessary attribute->owner.  Note that with
    this change, userland holding a sysfs node does not prevent the
    backing module from being unloaded.
    
    For more info regarding lifetime rule cleanup, please read the
    following message.
    
      http://article.gmane.org/gmane.linux.kernel/510293
    
    (tweaked by Greg to not delete the field just yet, to make it easier to
    merge things properly.)
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Cc: Cornelia Huck <cornelia.huck@de.ibm.com>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/parisc/pdc_stable.c b/drivers/parisc/pdc_stable.c
index 924ef0609460..fc4bde259dc7 100644
--- a/drivers/parisc/pdc_stable.c
+++ b/drivers/parisc/pdc_stable.c
@@ -121,14 +121,14 @@ struct pdcspath_entry pdcspath_entry_##_name = { \
 
 #define PDCS_ATTR(_name, _mode, _show, _store) \
 struct subsys_attribute pdcs_attr_##_name = { \
-	.attr = {.name = __stringify(_name), .mode = _mode, .owner = THIS_MODULE}, \
+	.attr = {.name = __stringify(_name), .mode = _mode}, \
 	.show = _show, \
 	.store = _store, \
 };
 
 #define PATHS_ATTR(_name, _mode, _show, _store) \
 struct pdcspath_attribute paths_attr_##_name = { \
-	.attr = {.name = __stringify(_name), .mode = _mode, .owner = THIS_MODULE}, \
+	.attr = {.name = __stringify(_name), .mode = _mode}, \
 	.show = _show, \
 	.store = _store, \
 };

commit ad46c54868078440b4538fa263a5fd2f124b5a57
Author: Kyle McMartin <kyle@parisc-linux.org>
Date:   Fri May 25 19:18:01 2007 -0400

    [PARISC] kobject is embedded in subsys, not kset
    
    Signed-off-by: Kyle McMartin <kyle@parisc-linux.org>

diff --git a/drivers/parisc/pdc_stable.c b/drivers/parisc/pdc_stable.c
index 815e445c3125..924ef0609460 100644
--- a/drivers/parisc/pdc_stable.c
+++ b/drivers/parisc/pdc_stable.c
@@ -1067,7 +1067,7 @@ pdc_stable_init(void)
 			error = subsys_create_file(&stable_subsys, attr);
 	
 	/* register the paths subsys as a subsystem of stable subsys */
-	kset_set_kset_s(&paths_subsys, stable_subsys);
+	kobj_set_kset_s(&paths_subsys, stable_subsys);
 	if ((rc = subsystem_register(&paths_subsys)))
 		goto fail_subsysreg;
 

commit 823bccfc4002296ba88c3ad0f049e1abd8108d30
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Fri Apr 13 13:15:19 2007 -0700

    remove "struct subsystem" as it is no longer needed
    
    We need to work on cleaning up the relationship between kobjects, ksets and
    ktypes.  The removal of 'struct subsystem' is the first step of this,
    especially as it is not really needed at all.
    
    Thanks to Kay for fixing the bugs in this patch.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/parisc/pdc_stable.c b/drivers/parisc/pdc_stable.c
index ea1b7a63598e..815e445c3125 100644
--- a/drivers/parisc/pdc_stable.c
+++ b/drivers/parisc/pdc_stable.c
@@ -520,17 +520,17 @@ static struct pdcspath_entry *pdcspath_entries[] = {
 
 /**
  * pdcs_size_read - Stable Storage size output.
- * @entry: An allocated and populated subsytem struct. We don't use it tho.
+ * @kset: An allocated and populated struct kset. We don't use it tho.
  * @buf: The output buffer to write to.
  */
 static ssize_t
-pdcs_size_read(struct subsystem *entry, char *buf)
+pdcs_size_read(struct kset *kset, char *buf)
 {
 	char *out = buf;
-	
-	if (!entry || !buf)
+
+	if (!kset || !buf)
 		return -EINVAL;
-		
+
 	/* show the size of the stable storage */
 	out += sprintf(out, "%ld\n", pdcs_size);
 
@@ -539,17 +539,17 @@ pdcs_size_read(struct subsystem *entry, char *buf)
 
 /**
  * pdcs_auto_read - Stable Storage autoboot/search flag output.
- * @entry: An allocated and populated subsytem struct. We don't use it tho.
+ * @kset: An allocated and populated struct kset. We don't use it tho.
  * @buf: The output buffer to write to.
  * @knob: The PF_AUTOBOOT or PF_AUTOSEARCH flag
  */
 static ssize_t
-pdcs_auto_read(struct subsystem *entry, char *buf, int knob)
+pdcs_auto_read(struct kset *kset, char *buf, int knob)
 {
 	char *out = buf;
 	struct pdcspath_entry *pathentry;
 
-	if (!entry || !buf)
+	if (!kset || !buf)
 		return -EINVAL;
 
 	/* Current flags are stored in primary boot path entry */
@@ -565,40 +565,40 @@ pdcs_auto_read(struct subsystem *entry, char *buf, int knob)
 
 /**
  * pdcs_autoboot_read - Stable Storage autoboot flag output.
- * @entry: An allocated and populated subsytem struct. We don't use it tho.
+ * @kset: An allocated and populated struct kset. We don't use it tho.
  * @buf: The output buffer to write to.
  */
 static inline ssize_t
-pdcs_autoboot_read(struct subsystem *entry, char *buf)
+pdcs_autoboot_read(struct kset *kset, char *buf)
 {
-	return pdcs_auto_read(entry, buf, PF_AUTOBOOT);
+	return pdcs_auto_read(kset, buf, PF_AUTOBOOT);
 }
 
 /**
  * pdcs_autosearch_read - Stable Storage autoboot flag output.
- * @entry: An allocated and populated subsytem struct. We don't use it tho.
+ * @kset: An allocated and populated struct kset. We don't use it tho.
  * @buf: The output buffer to write to.
  */
 static inline ssize_t
-pdcs_autosearch_read(struct subsystem *entry, char *buf)
+pdcs_autosearch_read(struct kset *kset, char *buf)
 {
-	return pdcs_auto_read(entry, buf, PF_AUTOSEARCH);
+	return pdcs_auto_read(kset, buf, PF_AUTOSEARCH);
 }
 
 /**
  * pdcs_timer_read - Stable Storage timer count output (in seconds).
- * @entry: An allocated and populated subsytem struct. We don't use it tho.
+ * @kset: An allocated and populated struct kset. We don't use it tho.
  * @buf: The output buffer to write to.
  *
  * The value of the timer field correponds to a number of seconds in powers of 2.
  */
 static ssize_t
-pdcs_timer_read(struct subsystem *entry, char *buf)
+pdcs_timer_read(struct kset *kset, char *buf)
 {
 	char *out = buf;
 	struct pdcspath_entry *pathentry;
 
-	if (!entry || !buf)
+	if (!kset || !buf)
 		return -EINVAL;
 
 	/* Current flags are stored in primary boot path entry */
@@ -615,15 +615,15 @@ pdcs_timer_read(struct subsystem *entry, char *buf)
 
 /**
  * pdcs_osid_read - Stable Storage OS ID register output.
- * @entry: An allocated and populated subsytem struct. We don't use it tho.
+ * @kset: An allocated and populated struct kset. We don't use it tho.
  * @buf: The output buffer to write to.
  */
 static ssize_t
-pdcs_osid_read(struct subsystem *entry, char *buf)
+pdcs_osid_read(struct kset *kset, char *buf)
 {
 	char *out = buf;
 
-	if (!entry || !buf)
+	if (!kset || !buf)
 		return -EINVAL;
 
 	out += sprintf(out, "%s dependent data (0x%.4x)\n",
@@ -634,18 +634,18 @@ pdcs_osid_read(struct subsystem *entry, char *buf)
 
 /**
  * pdcs_osdep1_read - Stable Storage OS-Dependent data area 1 output.
- * @entry: An allocated and populated subsytem struct. We don't use it tho.
+ * @kset: An allocated and populated struct kset. We don't use it tho.
  * @buf: The output buffer to write to.
  *
  * This can hold 16 bytes of OS-Dependent data.
  */
 static ssize_t
-pdcs_osdep1_read(struct subsystem *entry, char *buf)
+pdcs_osdep1_read(struct kset *kset, char *buf)
 {
 	char *out = buf;
 	u32 result[4];
 
-	if (!entry || !buf)
+	if (!kset || !buf)
 		return -EINVAL;
 
 	if (pdc_stable_read(PDCS_ADDR_OSD1, &result, sizeof(result)) != PDC_OK)
@@ -661,18 +661,18 @@ pdcs_osdep1_read(struct subsystem *entry, char *buf)
 
 /**
  * pdcs_diagnostic_read - Stable Storage Diagnostic register output.
- * @entry: An allocated and populated subsytem struct. We don't use it tho.
+ * @kset: An allocated and populated struct kset. We don't use it tho.
  * @buf: The output buffer to write to.
  *
  * I have NFC how to interpret the content of that register ;-).
  */
 static ssize_t
-pdcs_diagnostic_read(struct subsystem *entry, char *buf)
+pdcs_diagnostic_read(struct kset *kset, char *buf)
 {
 	char *out = buf;
 	u32 result;
 
-	if (!entry || !buf)
+	if (!kset || !buf)
 		return -EINVAL;
 
 	/* get diagnostic */
@@ -686,18 +686,18 @@ pdcs_diagnostic_read(struct subsystem *entry, char *buf)
 
 /**
  * pdcs_fastsize_read - Stable Storage FastSize register output.
- * @entry: An allocated and populated subsytem struct. We don't use it tho.
+ * @kset: An allocated and populated struct kset. We don't use it tho.
  * @buf: The output buffer to write to.
  *
  * This register holds the amount of system RAM to be tested during boot sequence.
  */
 static ssize_t
-pdcs_fastsize_read(struct subsystem *entry, char *buf)
+pdcs_fastsize_read(struct kset *kset, char *buf)
 {
 	char *out = buf;
 	u32 result;
 
-	if (!entry || !buf)
+	if (!kset || !buf)
 		return -EINVAL;
 
 	/* get fast-size */
@@ -715,13 +715,13 @@ pdcs_fastsize_read(struct subsystem *entry, char *buf)
 
 /**
  * pdcs_osdep2_read - Stable Storage OS-Dependent data area 2 output.
- * @entry: An allocated and populated subsytem struct. We don't use it tho.
+ * @kset: An allocated and populated struct kset. We don't use it tho.
  * @buf: The output buffer to write to.
  *
  * This can hold pdcs_size - 224 bytes of OS-Dependent data, when available.
  */
 static ssize_t
-pdcs_osdep2_read(struct subsystem *entry, char *buf)
+pdcs_osdep2_read(struct kset *kset, char *buf)
 {
 	char *out = buf;
 	unsigned long size;
@@ -733,7 +733,7 @@ pdcs_osdep2_read(struct subsystem *entry, char *buf)
 
 	size = pdcs_size - 224;
 
-	if (!entry || !buf)
+	if (!kset || !buf)
 		return -EINVAL;
 
 	for (i=0; i<size; i+=4) {
@@ -748,7 +748,7 @@ pdcs_osdep2_read(struct subsystem *entry, char *buf)
 
 /**
  * pdcs_auto_write - This function handles autoboot/search flag modifying.
- * @entry: An allocated and populated subsytem struct. We don't use it tho.
+ * @kset: An allocated and populated struct kset. We don't use it tho.
  * @buf: The input buffer to read from.
  * @count: The number of bytes to be read.
  * @knob: The PF_AUTOBOOT or PF_AUTOSEARCH flag
@@ -758,7 +758,7 @@ pdcs_osdep2_read(struct subsystem *entry, char *buf)
  *	\"n\" (n == 0 or 1) to toggle AutoBoot Off or On
  */
 static ssize_t
-pdcs_auto_write(struct subsystem *entry, const char *buf, size_t count, int knob)
+pdcs_auto_write(struct kset *kset, const char *buf, size_t count, int knob)
 {
 	struct pdcspath_entry *pathentry;
 	unsigned char flags;
@@ -768,7 +768,7 @@ pdcs_auto_write(struct subsystem *entry, const char *buf, size_t count, int knob
 	if (!capable(CAP_SYS_ADMIN))
 		return -EACCES;
 
-	if (!entry || !buf || !count)
+	if (!kset || !buf || !count)
 		return -EINVAL;
 
 	/* We'll use a local copy of buf */
@@ -823,7 +823,7 @@ pdcs_auto_write(struct subsystem *entry, const char *buf, size_t count, int knob
 
 /**
  * pdcs_autoboot_write - This function handles autoboot flag modifying.
- * @entry: An allocated and populated subsytem struct. We don't use it tho.
+ * @kset: An allocated and populated struct kset. We don't use it tho.
  * @buf: The input buffer to read from.
  * @count: The number of bytes to be read.
  *
@@ -832,14 +832,14 @@ pdcs_auto_write(struct subsystem *entry, const char *buf, size_t count, int knob
  *	\"n\" (n == 0 or 1) to toggle AutoSearch Off or On
  */
 static inline ssize_t
-pdcs_autoboot_write(struct subsystem *entry, const char *buf, size_t count)
+pdcs_autoboot_write(struct kset *kset, const char *buf, size_t count)
 {
-	return pdcs_auto_write(entry, buf, count, PF_AUTOBOOT);
+	return pdcs_auto_write(kset, buf, count, PF_AUTOBOOT);
 }
 
 /**
  * pdcs_autosearch_write - This function handles autosearch flag modifying.
- * @entry: An allocated and populated subsytem struct. We don't use it tho.
+ * @kset: An allocated and populated struct kset. We don't use it tho.
  * @buf: The input buffer to read from.
  * @count: The number of bytes to be read.
  *
@@ -848,14 +848,14 @@ pdcs_autoboot_write(struct subsystem *entry, const char *buf, size_t count)
  *	\"n\" (n == 0 or 1) to toggle AutoSearch Off or On
  */
 static inline ssize_t
-pdcs_autosearch_write(struct subsystem *entry, const char *buf, size_t count)
+pdcs_autosearch_write(struct kset *kset, const char *buf, size_t count)
 {
-	return pdcs_auto_write(entry, buf, count, PF_AUTOSEARCH);
+	return pdcs_auto_write(kset, buf, count, PF_AUTOSEARCH);
 }
 
 /**
  * pdcs_osdep1_write - Stable Storage OS-Dependent data area 1 input.
- * @entry: An allocated and populated subsytem struct. We don't use it tho.
+ * @kset: An allocated and populated struct kset. We don't use it tho.
  * @buf: The input buffer to read from.
  * @count: The number of bytes to be read.
  *
@@ -864,14 +864,14 @@ pdcs_autosearch_write(struct subsystem *entry, const char *buf, size_t count)
  * its input buffer.
  */
 static ssize_t
-pdcs_osdep1_write(struct subsystem *entry, const char *buf, size_t count)
+pdcs_osdep1_write(struct kset *kset, const char *buf, size_t count)
 {
 	u8 in[16];
 
 	if (!capable(CAP_SYS_ADMIN))
 		return -EACCES;
 
-	if (!entry || !buf || !count)
+	if (!kset || !buf || !count)
 		return -EINVAL;
 
 	if (unlikely(pdcs_osid != OS_ID_LINUX))
@@ -892,7 +892,7 @@ pdcs_osdep1_write(struct subsystem *entry, const char *buf, size_t count)
 
 /**
  * pdcs_osdep2_write - Stable Storage OS-Dependent data area 2 input.
- * @entry: An allocated and populated subsytem struct. We don't use it tho.
+ * @kset: An allocated and populated struct kset. We don't use it tho.
  * @buf: The input buffer to read from.
  * @count: The number of bytes to be read.
  *
@@ -901,7 +901,7 @@ pdcs_osdep1_write(struct subsystem *entry, const char *buf, size_t count)
  * constructing its input buffer.
  */
 static ssize_t
-pdcs_osdep2_write(struct subsystem *entry, const char *buf, size_t count)
+pdcs_osdep2_write(struct kset *kset, const char *buf, size_t count)
 {
 	unsigned long size;
 	unsigned short i;
@@ -910,7 +910,7 @@ pdcs_osdep2_write(struct subsystem *entry, const char *buf, size_t count)
 	if (!capable(CAP_SYS_ADMIN))
 		return -EACCES;
 
-	if (!entry || !buf || !count)
+	if (!kset || !buf || !count)
 		return -EINVAL;
 
 	if (unlikely(pdcs_size <= 224))

commit 67a061a191017f984a1ef0ff73ae988b9b15f6d3
Author: Kyle McMartin <kyle@parisc-linux.org>
Date:   Sun Jun 25 16:58:57 2006 +0000

    [PARISC] Add os_id_to_string helper
    
    Add a helper to asm/pdc.h to translate OS_ID values to strings
    and use it in the pdc_stable driver.
    
    Signed-off-by: Kyle McMartin <kyle@parisc-linux.org>

diff --git a/drivers/parisc/pdc_stable.c b/drivers/parisc/pdc_stable.c
index 97b345858043..ea1b7a63598e 100644
--- a/drivers/parisc/pdc_stable.c
+++ b/drivers/parisc/pdc_stable.c
@@ -622,22 +622,12 @@ static ssize_t
 pdcs_osid_read(struct subsystem *entry, char *buf)
 {
 	char *out = buf;
-	char *tmpstr = NULL;
 
 	if (!entry || !buf)
 		return -EINVAL;
 
-	switch (pdcs_osid) {
-		case 0x0000:	tmpstr = "No OS"; break;
-		case 0x0001:	tmpstr = "HP-UX"; break;
-		case 0x0002:	tmpstr = "MPE-iX"; break;
-		case 0x0003:	tmpstr = "OSF"; break;
-		case 0x0004:	tmpstr = "HP-RT"; break;
-		case 0x0005:	tmpstr = "Novell Netware"; break;
-		case 0x0006:	tmpstr = "Linux"; break;
-		default:	tmpstr = "Unknown"; break;
-	}
-	out += sprintf(out, "%s dependent data (0x%.4x)\n", tmpstr, pdcs_osid);
+	out += sprintf(out, "%s dependent data (0x%.4x)\n",
+		os_id_to_string(pdcs_osid), pdcs_osid);
 
 	return out - buf;
 }

commit ec1fdc24c2ae012b078ba0187ceef208e08a3aec
Author: Kyle McMartin <kyle@parisc-linux.org>
Date:   Wed Jun 21 19:27:29 2006 +0000

    [PARISC] OS_ID_LINUX == 0x0006
    
    We were assigned an OS_ID of 0x0006. Consistently use OS_ID_LINUX
    instead of using the magic number. Also update the OS_ID_ defines in
    asm/pdc.h to reflect this.
    
    Signed-off-by: Kyle McMartin <kyle@parisc-linux.org>

diff --git a/drivers/parisc/pdc_stable.c b/drivers/parisc/pdc_stable.c
index a1094210cd1f..97b345858043 100644
--- a/drivers/parisc/pdc_stable.c
+++ b/drivers/parisc/pdc_stable.c
@@ -884,7 +884,7 @@ pdcs_osdep1_write(struct subsystem *entry, const char *buf, size_t count)
 	if (!entry || !buf || !count)
 		return -EINVAL;
 
-	if (unlikely(pdcs_osid != 0x0006))
+	if (unlikely(pdcs_osid != OS_ID_LINUX))
 		return -EPERM;
 
 	if (count > 16)
@@ -926,7 +926,7 @@ pdcs_osdep2_write(struct subsystem *entry, const char *buf, size_t count)
 	if (unlikely(pdcs_size <= 224))
 		return -ENOSYS;
 
-	if (unlikely(pdcs_osid != 0x0006))
+	if (unlikely(pdcs_osid != OS_ID_LINUX))
 		return -EPERM;
 
 	size = pdcs_size - 224;

commit b0e8bfca2f6cdef6145e377ff0797fc42473b659
Author: Thibaut Varene <varenet@parisc-linux.org>
Date:   Thu May 4 18:43:34 2006 -0600

    [PARISC] Reduce data footprint in pdc_stable.c
    
    No code change - reduce data footprint.
    
    Signed-off-by: Thibaut VARENE <varenet@parisc-linux.org>
    Signed-off-by: Kyle McMartin <kyle@parisc-linux.org>

diff --git a/drivers/parisc/pdc_stable.c b/drivers/parisc/pdc_stable.c
index 4b991d50e578..a1094210cd1f 100644
--- a/drivers/parisc/pdc_stable.c
+++ b/drivers/parisc/pdc_stable.c
@@ -628,16 +628,16 @@ pdcs_osid_read(struct subsystem *entry, char *buf)
 		return -EINVAL;
 
 	switch (pdcs_osid) {
-		case 0x0000:	tmpstr = "No OS-dependent data"; break;
-		case 0x0001:	tmpstr = "HP-UX dependent data"; break;
-		case 0x0002:	tmpstr = "MPE-iX dependent data"; break;
-		case 0x0003:	tmpstr = "OSF dependent data"; break;
-		case 0x0004:	tmpstr = "HP-RT dependent data"; break;
-		case 0x0005:	tmpstr = "Novell Netware dependent data"; break;
-		case 0x0006:	tmpstr = "Linux dependent data"; break;
+		case 0x0000:	tmpstr = "No OS"; break;
+		case 0x0001:	tmpstr = "HP-UX"; break;
+		case 0x0002:	tmpstr = "MPE-iX"; break;
+		case 0x0003:	tmpstr = "OSF"; break;
+		case 0x0004:	tmpstr = "HP-RT"; break;
+		case 0x0005:	tmpstr = "Novell Netware"; break;
+		case 0x0006:	tmpstr = "Linux"; break;
 		default:	tmpstr = "Unknown"; break;
 	}
-	out += sprintf(out, "%s (0x%.4x)\n", tmpstr, pdcs_osid);
+	out += sprintf(out, "%s dependent data (0x%.4x)\n", tmpstr, pdcs_osid);
 
 	return out - buf;
 }

commit 3f9edb53f74b4e18f92783da7b6f5ad1d36e05b2
Author: Thibaut Varene <varenet@parisc-linux.org>
Date:   Thu May 4 18:43:34 2006 -0600

    [PARISC] pdc_stable version 0.30
    
    pdc_stable v0.30:
    
    This patch introduces 3 more files to the /sys/firmware/stable tree:
    - diagnostic, which contains a cryptic hex string
    - osdep1, a 16 bytes os-dependent storage area always available
    - osdep2, another os-dependent storage area which existence/size depends
    on hversion.
    
    This patch also adds code to setup the "Linux" signature in stable
    storage. That is to say that starting with this patch, the kernel will
    now sign its OSID (0x0006, thx LaMont) in Stable Storage upon boot,
    whether pdc_stable is enabled or not.
    
    Signed-off-by: Thibaut VARENE <varenet@parisc-linux.org>
    Signed-off-by: Kyle McMartin <kyle@parisc-linux.org>

diff --git a/drivers/parisc/pdc_stable.c b/drivers/parisc/pdc_stable.c
index bbeabe3fc4c6..4b991d50e578 100644
--- a/drivers/parisc/pdc_stable.c
+++ b/drivers/parisc/pdc_stable.c
@@ -28,8 +28,15 @@
  *    following code can deal with just 96 bytes of Stable Storage, and all
  *    sizes between 96 and 192 bytes (provided they are multiple of struct
  *    device_path size, eg: 128, 160 and 192) to provide full information.
- *    The code makes no use of data above 192 bytes. One last word: there's one
- *    path we can always count on: the primary path.
+ *    One last word: there's one path we can always count on: the primary path.
+ *    Anything above 224 bytes is used for 'osdep2' OS-dependent storage area.
+ *
+ *    The first OS-dependent area should always be available. Obviously, this is
+ *    not true for the other one. Also bear in mind that reading/writing from/to
+ *    osdep2 is much more expensive than from/to osdep1.
+ *    NOTE: We do not handle the 2 bytes OS-dep area at 0x5D, nor the first
+ *    2 bytes of storage available right after OSID. That's a total of 4 bytes
+ *    sacrificed: -ETOOLAZY :P
  *
  *    The current policy wrt file permissions is:
  *	- write: root only
@@ -64,15 +71,18 @@
 #include <asm/uaccess.h>
 #include <asm/hardware.h>
 
-#define PDCS_VERSION	"0.22"
+#define PDCS_VERSION	"0.30"
 #define PDCS_PREFIX	"PDC Stable Storage"
 
 #define PDCS_ADDR_PPRI	0x00
 #define PDCS_ADDR_OSID	0x40
+#define PDCS_ADDR_OSD1	0x48
+#define PDCS_ADDR_DIAG	0x58
 #define PDCS_ADDR_FSIZ	0x5C
 #define PDCS_ADDR_PCON	0x60
 #define PDCS_ADDR_PALT	0x80
 #define PDCS_ADDR_PKBD	0xA0
+#define PDCS_ADDR_OSD2	0xE0
 
 MODULE_AUTHOR("Thibaut VARENE <varenet@parisc-linux.org>");
 MODULE_DESCRIPTION("sysfs interface to HP PDC Stable Storage data");
@@ -82,6 +92,9 @@ MODULE_VERSION(PDCS_VERSION);
 /* holds Stable Storage size. Initialized once and for all, no lock needed */
 static unsigned long pdcs_size __read_mostly;
 
+/* holds OS ID. Initialized once and for all, hopefully to 0x0006 */
+static u16 pdcs_osid __read_mostly;
+
 /* This struct defines what we need to deal with a parisc pdc path entry */
 struct pdcspath_entry {
 	rwlock_t rw_lock;		/* to protect path entry access */
@@ -609,27 +622,74 @@ static ssize_t
 pdcs_osid_read(struct subsystem *entry, char *buf)
 {
 	char *out = buf;
-	__u32 result;
 	char *tmpstr = NULL;
 
 	if (!entry || !buf)
 		return -EINVAL;
 
-	/* get OSID */
-	if (pdc_stable_read(PDCS_ADDR_OSID, &result, sizeof(result)) != PDC_OK)
-		return -EIO;
-
-	/* the actual result is 16 bits away */
-	switch (result >> 16) {
+	switch (pdcs_osid) {
 		case 0x0000:	tmpstr = "No OS-dependent data"; break;
 		case 0x0001:	tmpstr = "HP-UX dependent data"; break;
 		case 0x0002:	tmpstr = "MPE-iX dependent data"; break;
 		case 0x0003:	tmpstr = "OSF dependent data"; break;
 		case 0x0004:	tmpstr = "HP-RT dependent data"; break;
 		case 0x0005:	tmpstr = "Novell Netware dependent data"; break;
+		case 0x0006:	tmpstr = "Linux dependent data"; break;
 		default:	tmpstr = "Unknown"; break;
 	}
-	out += sprintf(out, "%s (0x%.4x)\n", tmpstr, (result >> 16));
+	out += sprintf(out, "%s (0x%.4x)\n", tmpstr, pdcs_osid);
+
+	return out - buf;
+}
+
+/**
+ * pdcs_osdep1_read - Stable Storage OS-Dependent data area 1 output.
+ * @entry: An allocated and populated subsytem struct. We don't use it tho.
+ * @buf: The output buffer to write to.
+ *
+ * This can hold 16 bytes of OS-Dependent data.
+ */
+static ssize_t
+pdcs_osdep1_read(struct subsystem *entry, char *buf)
+{
+	char *out = buf;
+	u32 result[4];
+
+	if (!entry || !buf)
+		return -EINVAL;
+
+	if (pdc_stable_read(PDCS_ADDR_OSD1, &result, sizeof(result)) != PDC_OK)
+		return -EIO;
+
+	out += sprintf(out, "0x%.8x\n", result[0]);
+	out += sprintf(out, "0x%.8x\n", result[1]);
+	out += sprintf(out, "0x%.8x\n", result[2]);
+	out += sprintf(out, "0x%.8x\n", result[3]);
+
+	return out - buf;
+}
+
+/**
+ * pdcs_diagnostic_read - Stable Storage Diagnostic register output.
+ * @entry: An allocated and populated subsytem struct. We don't use it tho.
+ * @buf: The output buffer to write to.
+ *
+ * I have NFC how to interpret the content of that register ;-).
+ */
+static ssize_t
+pdcs_diagnostic_read(struct subsystem *entry, char *buf)
+{
+	char *out = buf;
+	u32 result;
+
+	if (!entry || !buf)
+		return -EINVAL;
+
+	/* get diagnostic */
+	if (pdc_stable_read(PDCS_ADDR_DIAG, &result, sizeof(result)) != PDC_OK)
+		return -EIO;
+
+	out += sprintf(out, "0x%.4x\n", (result >> 16));
 
 	return out - buf;
 }
@@ -645,7 +705,7 @@ static ssize_t
 pdcs_fastsize_read(struct subsystem *entry, char *buf)
 {
 	char *out = buf;
-	__u32 result;
+	u32 result;
 
 	if (!entry || !buf)
 		return -EINVAL;
@@ -663,6 +723,39 @@ pdcs_fastsize_read(struct subsystem *entry, char *buf)
 	return out - buf;
 }
 
+/**
+ * pdcs_osdep2_read - Stable Storage OS-Dependent data area 2 output.
+ * @entry: An allocated and populated subsytem struct. We don't use it tho.
+ * @buf: The output buffer to write to.
+ *
+ * This can hold pdcs_size - 224 bytes of OS-Dependent data, when available.
+ */
+static ssize_t
+pdcs_osdep2_read(struct subsystem *entry, char *buf)
+{
+	char *out = buf;
+	unsigned long size;
+	unsigned short i;
+	u32 result;
+
+	if (unlikely(pdcs_size <= 224))
+		return -ENODATA;
+
+	size = pdcs_size - 224;
+
+	if (!entry || !buf)
+		return -EINVAL;
+
+	for (i=0; i<size; i+=4) {
+		if (unlikely(pdc_stable_read(PDCS_ADDR_OSD2 + i, &result,
+					sizeof(result)) != PDC_OK))
+			return -EIO;
+		out += sprintf(out, "0x%.8x\n", result);
+	}
+
+	return out - buf;
+}
+
 /**
  * pdcs_auto_write - This function handles autoboot/search flag modifying.
  * @entry: An allocated and populated subsytem struct. We don't use it tho.
@@ -770,13 +863,100 @@ pdcs_autosearch_write(struct subsystem *entry, const char *buf, size_t count)
 	return pdcs_auto_write(entry, buf, count, PF_AUTOSEARCH);
 }
 
+/**
+ * pdcs_osdep1_write - Stable Storage OS-Dependent data area 1 input.
+ * @entry: An allocated and populated subsytem struct. We don't use it tho.
+ * @buf: The input buffer to read from.
+ * @count: The number of bytes to be read.
+ *
+ * This can store 16 bytes of OS-Dependent data. We use a byte-by-byte
+ * write approach. It's up to userspace to deal with it when constructing
+ * its input buffer.
+ */
+static ssize_t
+pdcs_osdep1_write(struct subsystem *entry, const char *buf, size_t count)
+{
+	u8 in[16];
+
+	if (!capable(CAP_SYS_ADMIN))
+		return -EACCES;
+
+	if (!entry || !buf || !count)
+		return -EINVAL;
+
+	if (unlikely(pdcs_osid != 0x0006))
+		return -EPERM;
+
+	if (count > 16)
+		return -EMSGSIZE;
+
+	/* We'll use a local copy of buf */
+	memset(in, 0, 16);
+	memcpy(in, buf, count);
+
+	if (pdc_stable_write(PDCS_ADDR_OSD1, &in, sizeof(in)) != PDC_OK)
+		return -EIO;
+
+	return count;
+}
+
+/**
+ * pdcs_osdep2_write - Stable Storage OS-Dependent data area 2 input.
+ * @entry: An allocated and populated subsytem struct. We don't use it tho.
+ * @buf: The input buffer to read from.
+ * @count: The number of bytes to be read.
+ *
+ * This can store pdcs_size - 224 bytes of OS-Dependent data. We use a
+ * byte-by-byte write approach. It's up to userspace to deal with it when
+ * constructing its input buffer.
+ */
+static ssize_t
+pdcs_osdep2_write(struct subsystem *entry, const char *buf, size_t count)
+{
+	unsigned long size;
+	unsigned short i;
+	u8 in[4];
+
+	if (!capable(CAP_SYS_ADMIN))
+		return -EACCES;
+
+	if (!entry || !buf || !count)
+		return -EINVAL;
+
+	if (unlikely(pdcs_size <= 224))
+		return -ENOSYS;
+
+	if (unlikely(pdcs_osid != 0x0006))
+		return -EPERM;
+
+	size = pdcs_size - 224;
+
+	if (count > size)
+		return -EMSGSIZE;
+
+	/* We'll use a local copy of buf */
+
+	for (i=0; i<count; i+=4) {
+		memset(in, 0, 4);
+		memcpy(in, buf+i, (count-i < 4) ? count-i : 4);
+		if (unlikely(pdc_stable_write(PDCS_ADDR_OSD2 + i, &in,
+					sizeof(in)) != PDC_OK))
+			return -EIO;
+	}
+
+	return count;
+}
+
 /* The remaining attributes. */
 static PDCS_ATTR(size, 0444, pdcs_size_read, NULL);
 static PDCS_ATTR(autoboot, 0644, pdcs_autoboot_read, pdcs_autoboot_write);
 static PDCS_ATTR(autosearch, 0644, pdcs_autosearch_read, pdcs_autosearch_write);
 static PDCS_ATTR(timer, 0444, pdcs_timer_read, NULL);
-static PDCS_ATTR(osid, 0400, pdcs_osid_read, NULL);
+static PDCS_ATTR(osid, 0444, pdcs_osid_read, NULL);
+static PDCS_ATTR(osdep1, 0600, pdcs_osdep1_read, pdcs_osdep1_write);
+static PDCS_ATTR(diagnostic, 0400, pdcs_diagnostic_read, NULL);
 static PDCS_ATTR(fastsize, 0400, pdcs_fastsize_read, NULL);
+static PDCS_ATTR(osdep2, 0600, pdcs_osdep2_read, pdcs_osdep2_write);
 
 static struct subsys_attribute *pdcs_subsys_attrs[] = {
 	&pdcs_attr_size,
@@ -784,7 +964,10 @@ static struct subsys_attribute *pdcs_subsys_attrs[] = {
 	&pdcs_attr_autosearch,
 	&pdcs_attr_timer,
 	&pdcs_attr_osid,
+	&pdcs_attr_osdep1,
+	&pdcs_attr_diagnostic,
 	&pdcs_attr_fastsize,
+	&pdcs_attr_osdep2,
 	NULL,
 };
 
@@ -865,6 +1048,7 @@ pdc_stable_init(void)
 {
 	struct subsys_attribute *attr;
 	int i, rc = 0, error = 0;
+	u32 result;
 
 	/* find the size of the stable storage */
 	if (pdc_stable_get_size(&pdcs_size) != PDC_OK) 
@@ -876,6 +1060,13 @@ pdc_stable_init(void)
 
 	printk(KERN_INFO PDCS_PREFIX " facility v%s\n", PDCS_VERSION);
 
+	/* get OSID */
+	if (pdc_stable_read(PDCS_ADDR_OSID, &result, sizeof(result)) != PDC_OK)
+		return -EIO;
+
+	/* the actual result is 16 bits away */
+	pdcs_osid = (u16)(result >> 16);
+
 	/* For now we'll register the stable subsys within this driver */
 	if ((rc = firmware_register(&stable_subsys)))
 		goto fail_firmreg;
@@ -887,7 +1078,7 @@ pdc_stable_init(void)
 	
 	/* register the paths subsys as a subsystem of stable subsys */
 	kset_set_kset_s(&paths_subsys, stable_subsys);
-	if ((rc= subsystem_register(&paths_subsys)))
+	if ((rc = subsystem_register(&paths_subsys)))
 		goto fail_subsysreg;
 
 	/* now we create all "files" for the paths subsys */

commit 67a5a59d3301949f51f2d617d689f005c6d21470
Author: Helge Deller <deller@parisc-linux.org>
Date:   Mon Mar 27 19:52:14 2006 +0000

    [PARISC] Misc. janitorial work
    
    Fix a spelling mistake, add a KERN_INFO flag, and fix some whitespace
    uglies.
    
    Signed-off-by: Helge Deller <deller@parisc-linux.org>
    Signed-off-by: Kyle McMartin <kyle@parisc-linux.org>

diff --git a/drivers/parisc/pdc_stable.c b/drivers/parisc/pdc_stable.c
index 4e53be9c03ab..bbeabe3fc4c6 100644
--- a/drivers/parisc/pdc_stable.c
+++ b/drivers/parisc/pdc_stable.c
@@ -535,7 +535,7 @@ pdcs_auto_read(struct subsystem *entry, char *buf, int knob)
 {
 	char *out = buf;
 	struct pdcspath_entry *pathentry;
-	
+
 	if (!entry || !buf)
 		return -EINVAL;
 

commit a81dd18eb974cc34634c53a6447b2799ec0c3158
Author: Thibaut VARENE <varenet@parisc-linux.org>
Date:   Fri Feb 3 18:06:30 2006 -0700

    [PARISC] Clarify pdc_stable license terms
    
    pdc_stable.c is explicitly licensed under GPL version 2.
    
    Signed-off-by: Thibaut VARENE <varenet@parisc-linux.org>
    Signed-off-by: Kyle McMartin <kyle@parisc-linux.org>

diff --git a/drivers/parisc/pdc_stable.c b/drivers/parisc/pdc_stable.c
index a28e17898fbd..4e53be9c03ab 100644
--- a/drivers/parisc/pdc_stable.c
+++ b/drivers/parisc/pdc_stable.c
@@ -4,9 +4,8 @@
  *    Copyright (C) 2005-2006 Thibaut VARENE <varenet@parisc-linux.org>
  *
  *    This program is free software; you can redistribute it and/or modify
- *    it under the terms of the GNU General Public License as published by
- *    the Free Software Foundation; either version 2 of the License, or
- *    (at your option) any later version.
+ *    it under the terms of the GNU General Public License, version 2, as
+ *    published by the Free Software Foundation.
  *
  *    This program is distributed in the hope that it will be useful,
  *    but WITHOUT ANY WARRANTY; without even the implied warranty of

commit c742842223269eb8eb4b86ac05ad07e6e156526b
Author: Thibaut VARENE <varenet@parisc-linux.org>
Date:   Wed Jan 11 13:59:53 2006 -0700

    [PARISC] pdc_stable version 0.22
    
    pdc_stable v0.22, changes since v0.10:
    
      o renamed root subsystem from 'pdc' to 'stable'
      o split 'info' into several files, one per PDC field
      o implemented 'autoboot' and 'autosearch' write calls to toggle
        these flags
      o grant read permission to all users on "safe" files
      o more code cleanup (removed duplicate code)
      o avoid bad stable storage clobbering by write locking critical sections
      o print consistent data as well
      o SMP cleanups
    
    Signed-off-by: Thibaut VARENE <varenet@parisc-linux.org>
    Signed-off-by: Kyle McMartin <kyle@parisc-linux.org>

diff --git a/drivers/parisc/pdc_stable.c b/drivers/parisc/pdc_stable.c
index 42a3c54e8e6c..a28e17898fbd 100644
--- a/drivers/parisc/pdc_stable.c
+++ b/drivers/parisc/pdc_stable.c
@@ -1,7 +1,7 @@
 /* 
  *    Interfaces to retrieve and set PDC Stable options (firmware)
  *
- *    Copyright (C) 2005 Thibaut VARENE <varenet@parisc-linux.org>
+ *    Copyright (C) 2005-2006 Thibaut VARENE <varenet@parisc-linux.org>
  *
  *    This program is free software; you can redistribute it and/or modify
  *    it under the terms of the GNU General Public License as published by
@@ -26,11 +26,19 @@
  *
  *    Since locations between 96 and 192 are the various paths, most (if not
  *    all) PA-RISC machines should have them. Anyway, for safety reasons, the
- *    following code can deal with only 96 bytes of Stable Storage, and all
+ *    following code can deal with just 96 bytes of Stable Storage, and all
  *    sizes between 96 and 192 bytes (provided they are multiple of struct
  *    device_path size, eg: 128, 160 and 192) to provide full information.
  *    The code makes no use of data above 192 bytes. One last word: there's one
  *    path we can always count on: the primary path.
+ *
+ *    The current policy wrt file permissions is:
+ *	- write: root only
+ *	- read: (reading triggers PDC calls) ? root only : everyone
+ *    The rationale is that PDC calls could hog (DoS) the machine.
+ *
+ *	TODO:
+ *	- timer/fastsize write calls
  */
 
 #undef PDCS_DEBUG
@@ -50,13 +58,15 @@
 #include <linux/kobject.h>
 #include <linux/device.h>
 #include <linux/errno.h>
+#include <linux/spinlock.h>
 
 #include <asm/pdc.h>
 #include <asm/page.h>
 #include <asm/uaccess.h>
 #include <asm/hardware.h>
 
-#define PDCS_VERSION	"0.10"
+#define PDCS_VERSION	"0.22"
+#define PDCS_PREFIX	"PDC Stable Storage"
 
 #define PDCS_ADDR_PPRI	0x00
 #define PDCS_ADDR_OSID	0x40
@@ -70,10 +80,12 @@ MODULE_DESCRIPTION("sysfs interface to HP PDC Stable Storage data");
 MODULE_LICENSE("GPL");
 MODULE_VERSION(PDCS_VERSION);
 
+/* holds Stable Storage size. Initialized once and for all, no lock needed */
 static unsigned long pdcs_size __read_mostly;
 
 /* This struct defines what we need to deal with a parisc pdc path entry */
 struct pdcspath_entry {
+	rwlock_t rw_lock;		/* to protect path entry access */
 	short ready;			/* entry record is valid if != 0 */
 	unsigned long addr;		/* entry address in stable storage */
 	char *name;			/* entry name */
@@ -121,6 +133,8 @@ struct pdcspath_attribute paths_attr_##_name = { \
  * content of the stable storage WRT various paths in these structs. We read
  * these structs when reading the files, and we will write to these structs when
  * writing to the files, and only then write them back to the Stable Storage.
+ *
+ * This function expects to be called with @entry->rw_lock write-hold.
  */
 static int
 pdcspath_fetch(struct pdcspath_entry *entry)
@@ -160,14 +174,15 @@ pdcspath_fetch(struct pdcspath_entry *entry)
  * pointer, from which it'll find out the corresponding hardware path.
  * For now we do not handle the case where there's an error in writing to the
  * Stable Storage area, so you'd better not mess up the data :P
+ *
+ * This function expects to be called with @entry->rw_lock write-hold.
  */
-static int
+static void
 pdcspath_store(struct pdcspath_entry *entry)
 {
 	struct device_path *devpath;
 
-	if (!entry)
-		return -EINVAL;
+	BUG_ON(!entry);
 
 	devpath = &entry->devpath;
 	
@@ -176,10 +191,8 @@ pdcspath_store(struct pdcspath_entry *entry)
 	   First case, we don't have a preset hwpath... */
 	if (!entry->ready) {
 		/* ...but we have a device, map it */
-		if (entry->dev)
-			device_to_hwpath(entry->dev, (struct hardware_path *)devpath);
-		else
-			return -EINVAL;
+		BUG_ON(!entry->dev);
+		device_to_hwpath(entry->dev, (struct hardware_path *)devpath);
 	}
 	/* else, we expect the provided hwpath to be valid. */
 	
@@ -191,15 +204,13 @@ pdcspath_store(struct pdcspath_entry *entry)
 		printk(KERN_ERR "%s: an error occured when writing to PDC.\n"
 				"It is likely that the Stable Storage data has been corrupted.\n"
 				"Please check it carefully upon next reboot.\n", __func__);
-		return -EIO;
+		WARN_ON(1);
 	}
 		
 	/* kobject is already registered */
 	entry->ready = 2;
 	
 	DPRINTK("%s: device: 0x%p\n", __func__, entry->dev);
-	
-	return 0;
 }
 
 /**
@@ -214,14 +225,17 @@ pdcspath_hwpath_read(struct pdcspath_entry *entry, char *buf)
 {
 	char *out = buf;
 	struct device_path *devpath;
-	unsigned short i;
+	short i;
 
 	if (!entry || !buf)
 		return -EINVAL;
 
+	read_lock(&entry->rw_lock);
 	devpath = &entry->devpath;
+	i = entry->ready;
+	read_unlock(&entry->rw_lock);
 
-	if (!entry->ready)
+	if (!i)	/* entry is not ready */
 		return -ENODATA;
 	
 	for (i = 0; i < 6; i++) {
@@ -242,7 +256,7 @@ pdcspath_hwpath_read(struct pdcspath_entry *entry, char *buf)
  * 
  * We will call this function to change the current hardware path.
  * Hardware paths are to be given '/'-delimited, without brackets.
- * We take care to make sure that the provided path actually maps to an existing
+ * We make sure that the provided path actually maps to an existing
  * device, BUT nothing would prevent some foolish user to set the path to some
  * PCI bridge or even a CPU...
  * A better work around would be to make sure we are at the end of a device tree
@@ -298,17 +312,19 @@ pdcspath_hwpath_write(struct pdcspath_entry *entry, const char *buf, size_t coun
 	}
 	
 	/* So far so good, let's get in deep */
+	write_lock(&entry->rw_lock);
 	entry->ready = 0;
 	entry->dev = dev;
 	
 	/* Now, dive in. Write back to the hardware */
-	WARN_ON(pdcspath_store(entry));	/* this warn should *NEVER* happen */
+	pdcspath_store(entry);
 	
 	/* Update the symlink to the real device */
 	sysfs_remove_link(&entry->kobj, "device");
 	sysfs_create_link(&entry->kobj, &entry->dev->kobj, "device");
+	write_unlock(&entry->rw_lock);
 	
-	printk(KERN_INFO "PDC Stable Storage: changed \"%s\" path to \"%s\"\n",
+	printk(KERN_INFO PDCS_PREFIX ": changed \"%s\" path to \"%s\"\n",
 		entry->name, buf);
 	
 	return count;
@@ -326,14 +342,17 @@ pdcspath_layer_read(struct pdcspath_entry *entry, char *buf)
 {
 	char *out = buf;
 	struct device_path *devpath;
-	unsigned short i;
+	short i;
 
 	if (!entry || !buf)
 		return -EINVAL;
 	
+	read_lock(&entry->rw_lock);
 	devpath = &entry->devpath;
+	i = entry->ready;
+	read_unlock(&entry->rw_lock);
 
-	if (!entry->ready)
+	if (!i)	/* entry is not ready */
 		return -ENODATA;
 	
 	for (i = 0; devpath->layers[i] && (likely(i < 6)); i++)
@@ -388,15 +407,17 @@ pdcspath_layer_write(struct pdcspath_entry *entry, const char *buf, size_t count
 	}
 		
 	/* So far so good, let's get in deep */
+	write_lock(&entry->rw_lock);
 	
 	/* First, overwrite the current layers with the new ones, not touching
 	   the hardware path. */
 	memcpy(&entry->devpath.layers, &layers, sizeof(layers));
 	
 	/* Now, dive in. Write back to the hardware */
-	WARN_ON(pdcspath_store(entry));	/* this warn should *NEVER* happen */
+	pdcspath_store(entry);
+	write_unlock(&entry->rw_lock);
 	
-	printk(KERN_INFO "PDC Stable Storage: changed \"%s\" layers to \"%s\"\n",
+	printk(KERN_INFO PDCS_PREFIX ": changed \"%s\" layers to \"%s\"\n",
 		entry->name, buf);
 	
 	return count;
@@ -415,9 +436,6 @@ pdcspath_attr_show(struct kobject *kobj, struct attribute *attr, char *buf)
 	struct pdcspath_attribute *pdcs_attr = to_pdcspath_attribute(attr);
 	ssize_t ret = 0;
 
-	if (!capable(CAP_SYS_ADMIN))
-		return -EACCES;
-
 	if (pdcs_attr->show)
 		ret = pdcs_attr->show(entry, buf);
 
@@ -454,8 +472,8 @@ static struct sysfs_ops pdcspath_attr_ops = {
 };
 
 /* These are the two attributes of any PDC path. */
-static PATHS_ATTR(hwpath, 0600, pdcspath_hwpath_read, pdcspath_hwpath_write);
-static PATHS_ATTR(layer, 0600, pdcspath_layer_read, pdcspath_layer_write);
+static PATHS_ATTR(hwpath, 0644, pdcspath_hwpath_read, pdcspath_hwpath_write);
+static PATHS_ATTR(layer, 0644, pdcspath_layer_read, pdcspath_layer_write);
 
 static struct attribute *paths_subsys_attrs[] = {
 	&paths_attr_hwpath.attr,
@@ -484,36 +502,119 @@ static struct pdcspath_entry *pdcspath_entries[] = {
 	NULL,
 };
 
+
+/* For more insight of what's going on here, refer to PDC Procedures doc,
+ * Section PDC_STABLE */
+
 /**
- * pdcs_info_read - Pretty printing of the remaining useful data.
+ * pdcs_size_read - Stable Storage size output.
  * @entry: An allocated and populated subsytem struct. We don't use it tho.
  * @buf: The output buffer to write to.
- * 
- * We will call this function to format the output of the 'info' attribute file.
- * Please refer to PDC Procedures documentation, section PDC_STABLE to get a
- * better insight of what we're doing here.
  */
 static ssize_t
-pdcs_info_read(struct subsystem *entry, char *buf)
+pdcs_size_read(struct subsystem *entry, char *buf)
 {
 	char *out = buf;
-	__u32 result;
-	struct device_path devpath;
-	char *tmpstr = NULL;
 	
 	if (!entry || !buf)
 		return -EINVAL;
 		
 	/* show the size of the stable storage */
-	out += sprintf(out, "Stable Storage size: %ld bytes\n", pdcs_size);
+	out += sprintf(out, "%ld\n", pdcs_size);
 
-	/* deal with flags */
-	if (pdc_stable_read(PDCS_ADDR_PPRI, &devpath, sizeof(devpath)) != PDC_OK)
-		return -EIO;
+	return out - buf;
+}
+
+/**
+ * pdcs_auto_read - Stable Storage autoboot/search flag output.
+ * @entry: An allocated and populated subsytem struct. We don't use it tho.
+ * @buf: The output buffer to write to.
+ * @knob: The PF_AUTOBOOT or PF_AUTOSEARCH flag
+ */
+static ssize_t
+pdcs_auto_read(struct subsystem *entry, char *buf, int knob)
+{
+	char *out = buf;
+	struct pdcspath_entry *pathentry;
 	
-	out += sprintf(out, "Autoboot: %s\n", (devpath.flags & PF_AUTOBOOT) ? "On" : "Off");
-	out += sprintf(out, "Autosearch: %s\n", (devpath.flags & PF_AUTOSEARCH) ? "On" : "Off");
-	out += sprintf(out, "Timer: %u s\n", (devpath.flags & PF_TIMER) ? (1 << (devpath.flags & PF_TIMER)) : 0);
+	if (!entry || !buf)
+		return -EINVAL;
+
+	/* Current flags are stored in primary boot path entry */
+	pathentry = &pdcspath_entry_primary;
+
+	read_lock(&pathentry->rw_lock);
+	out += sprintf(out, "%s\n", (pathentry->devpath.flags & knob) ?
+					"On" : "Off");
+	read_unlock(&pathentry->rw_lock);
+
+	return out - buf;
+}
+
+/**
+ * pdcs_autoboot_read - Stable Storage autoboot flag output.
+ * @entry: An allocated and populated subsytem struct. We don't use it tho.
+ * @buf: The output buffer to write to.
+ */
+static inline ssize_t
+pdcs_autoboot_read(struct subsystem *entry, char *buf)
+{
+	return pdcs_auto_read(entry, buf, PF_AUTOBOOT);
+}
+
+/**
+ * pdcs_autosearch_read - Stable Storage autoboot flag output.
+ * @entry: An allocated and populated subsytem struct. We don't use it tho.
+ * @buf: The output buffer to write to.
+ */
+static inline ssize_t
+pdcs_autosearch_read(struct subsystem *entry, char *buf)
+{
+	return pdcs_auto_read(entry, buf, PF_AUTOSEARCH);
+}
+
+/**
+ * pdcs_timer_read - Stable Storage timer count output (in seconds).
+ * @entry: An allocated and populated subsytem struct. We don't use it tho.
+ * @buf: The output buffer to write to.
+ *
+ * The value of the timer field correponds to a number of seconds in powers of 2.
+ */
+static ssize_t
+pdcs_timer_read(struct subsystem *entry, char *buf)
+{
+	char *out = buf;
+	struct pdcspath_entry *pathentry;
+
+	if (!entry || !buf)
+		return -EINVAL;
+
+	/* Current flags are stored in primary boot path entry */
+	pathentry = &pdcspath_entry_primary;
+
+	/* print the timer value in seconds */
+	read_lock(&pathentry->rw_lock);
+	out += sprintf(out, "%u\n", (pathentry->devpath.flags & PF_TIMER) ?
+				(1 << (pathentry->devpath.flags & PF_TIMER)) : 0);
+	read_unlock(&pathentry->rw_lock);
+
+	return out - buf;
+}
+
+/**
+ * pdcs_osid_read - Stable Storage OS ID register output.
+ * @entry: An allocated and populated subsytem struct. We don't use it tho.
+ * @buf: The output buffer to write to.
+ */
+static ssize_t
+pdcs_osid_read(struct subsystem *entry, char *buf)
+{
+	char *out = buf;
+	__u32 result;
+	char *tmpstr = NULL;
+
+	if (!entry || !buf)
+		return -EINVAL;
 
 	/* get OSID */
 	if (pdc_stable_read(PDCS_ADDR_OSID, &result, sizeof(result)) != PDC_OK)
@@ -529,13 +630,31 @@ pdcs_info_read(struct subsystem *entry, char *buf)
 		case 0x0005:	tmpstr = "Novell Netware dependent data"; break;
 		default:	tmpstr = "Unknown"; break;
 	}
-	out += sprintf(out, "OS ID: %s (0x%.4x)\n", tmpstr, (result >> 16));
+	out += sprintf(out, "%s (0x%.4x)\n", tmpstr, (result >> 16));
+
+	return out - buf;
+}
+
+/**
+ * pdcs_fastsize_read - Stable Storage FastSize register output.
+ * @entry: An allocated and populated subsytem struct. We don't use it tho.
+ * @buf: The output buffer to write to.
+ *
+ * This register holds the amount of system RAM to be tested during boot sequence.
+ */
+static ssize_t
+pdcs_fastsize_read(struct subsystem *entry, char *buf)
+{
+	char *out = buf;
+	__u32 result;
+
+	if (!entry || !buf)
+		return -EINVAL;
 
 	/* get fast-size */
 	if (pdc_stable_read(PDCS_ADDR_FSIZ, &result, sizeof(result)) != PDC_OK)
 		return -EIO;
 
-	out += sprintf(out, "Memory tested: ");
 	if ((result & 0x0F) < 0x0E)
 		out += sprintf(out, "%d kB", (1<<(result & 0x0F))*256);
 	else
@@ -546,22 +665,18 @@ pdcs_info_read(struct subsystem *entry, char *buf)
 }
 
 /**
- * pdcs_info_write - This function handles boot flag modifying.
+ * pdcs_auto_write - This function handles autoboot/search flag modifying.
  * @entry: An allocated and populated subsytem struct. We don't use it tho.
  * @buf: The input buffer to read from.
  * @count: The number of bytes to be read.
+ * @knob: The PF_AUTOBOOT or PF_AUTOSEARCH flag
  * 
- * We will call this function to change the current boot flags.
+ * We will call this function to change the current autoboot flag.
  * We expect a precise syntax:
- *	\"n n\" (n == 0 or 1) to toggle respectively AutoBoot and AutoSearch
- *
- * As of now there is no incentive on my side to provide more "knobs" to that
- * interface, since modifying the rest of the data is pretty meaningless when
- * the machine is running and for the expected use of that facility, such as
- * PALO setting up the boot disk when installing a Linux distribution...
+ *	\"n\" (n == 0 or 1) to toggle AutoBoot Off or On
  */
 static ssize_t
-pdcs_info_write(struct subsystem *entry, const char *buf, size_t count)
+pdcs_auto_write(struct subsystem *entry, const char *buf, size_t count, int knob)
 {
 	struct pdcspath_entry *pathentry;
 	unsigned char flags;
@@ -582,7 +697,9 @@ pdcs_info_write(struct subsystem *entry, const char *buf, size_t count)
 	pathentry = &pdcspath_entry_primary;
 	
 	/* Be nice to the existing flag record */
+	read_lock(&pathentry->rw_lock);
 	flags = pathentry->devpath.flags;
+	read_unlock(&pathentry->rw_lock);
 	
 	DPRINTK("%s: flags before: 0x%X\n", __func__, flags);
 			
@@ -595,50 +712,85 @@ pdcs_info_write(struct subsystem *entry, const char *buf, size_t count)
 	if ((c != 0) && (c != 1))
 		goto parse_error;
 	if (c == 0)
-		flags &= ~PF_AUTOBOOT;
+		flags &= ~knob;
 	else
-		flags |= PF_AUTOBOOT;
-	
-	if (*temp++ != ' ')
-		goto parse_error;
-	
-	c = *temp++ - '0';
-	if ((c != 0) && (c != 1))
-		goto parse_error;
-	if (c == 0)
-		flags &= ~PF_AUTOSEARCH;
-	else
-		flags |= PF_AUTOSEARCH;
+		flags |= knob;
 	
 	DPRINTK("%s: flags after: 0x%X\n", __func__, flags);
 		
 	/* So far so good, let's get in deep */
+	write_lock(&pathentry->rw_lock);
 	
 	/* Change the path entry flags first */
 	pathentry->devpath.flags = flags;
 		
 	/* Now, dive in. Write back to the hardware */
-	WARN_ON(pdcspath_store(pathentry));	/* this warn should *NEVER* happen */
+	pdcspath_store(pathentry);
+	write_unlock(&pathentry->rw_lock);
 	
-	printk(KERN_INFO "PDC Stable Storage: changed flags to \"%s\"\n", buf);
+	printk(KERN_INFO PDCS_PREFIX ": changed \"%s\" to \"%s\"\n",
+		(knob & PF_AUTOBOOT) ? "autoboot" : "autosearch",
+		(flags & knob) ? "On" : "Off");
 	
 	return count;
 
 parse_error:
-	printk(KERN_WARNING "%s: Parse error: expect \"n n\" (n == 0 or 1) for AB and AS\n", __func__);
+	printk(KERN_WARNING "%s: Parse error: expect \"n\" (n == 0 or 1)\n", __func__);
 	return -EINVAL;
 }
 
-/* The last attribute (the 'root' one actually) with all remaining data. */
-static PDCS_ATTR(info, 0600, pdcs_info_read, pdcs_info_write);
+/**
+ * pdcs_autoboot_write - This function handles autoboot flag modifying.
+ * @entry: An allocated and populated subsytem struct. We don't use it tho.
+ * @buf: The input buffer to read from.
+ * @count: The number of bytes to be read.
+ *
+ * We will call this function to change the current boot flags.
+ * We expect a precise syntax:
+ *	\"n\" (n == 0 or 1) to toggle AutoSearch Off or On
+ */
+static inline ssize_t
+pdcs_autoboot_write(struct subsystem *entry, const char *buf, size_t count)
+{
+	return pdcs_auto_write(entry, buf, count, PF_AUTOBOOT);
+}
+
+/**
+ * pdcs_autosearch_write - This function handles autosearch flag modifying.
+ * @entry: An allocated and populated subsytem struct. We don't use it tho.
+ * @buf: The input buffer to read from.
+ * @count: The number of bytes to be read.
+ *
+ * We will call this function to change the current boot flags.
+ * We expect a precise syntax:
+ *	\"n\" (n == 0 or 1) to toggle AutoSearch Off or On
+ */
+static inline ssize_t
+pdcs_autosearch_write(struct subsystem *entry, const char *buf, size_t count)
+{
+	return pdcs_auto_write(entry, buf, count, PF_AUTOSEARCH);
+}
+
+/* The remaining attributes. */
+static PDCS_ATTR(size, 0444, pdcs_size_read, NULL);
+static PDCS_ATTR(autoboot, 0644, pdcs_autoboot_read, pdcs_autoboot_write);
+static PDCS_ATTR(autosearch, 0644, pdcs_autosearch_read, pdcs_autosearch_write);
+static PDCS_ATTR(timer, 0444, pdcs_timer_read, NULL);
+static PDCS_ATTR(osid, 0400, pdcs_osid_read, NULL);
+static PDCS_ATTR(fastsize, 0400, pdcs_fastsize_read, NULL);
 
 static struct subsys_attribute *pdcs_subsys_attrs[] = {
-	&pdcs_attr_info,
-	NULL,	/* maybe more in the future? */
+	&pdcs_attr_size,
+	&pdcs_attr_autoboot,
+	&pdcs_attr_autosearch,
+	&pdcs_attr_timer,
+	&pdcs_attr_osid,
+	&pdcs_attr_fastsize,
+	NULL,
 };
 
 static decl_subsys(paths, &ktype_pdcspath, NULL);
-static decl_subsys(pdc, NULL, NULL);
+static decl_subsys(stable, NULL, NULL);
 
 /**
  * pdcs_register_pathentries - Prepares path entries kobjects for sysfs usage.
@@ -656,8 +808,16 @@ pdcs_register_pathentries(void)
 	struct pdcspath_entry *entry;
 	int err;
 	
+	/* Initialize the entries rw_lock before anything else */
+	for (i = 0; (entry = pdcspath_entries[i]); i++)
+		rwlock_init(&entry->rw_lock);
+
 	for (i = 0; (entry = pdcspath_entries[i]); i++) {
-		if (pdcspath_fetch(entry) < 0)
+		write_lock(&entry->rw_lock);
+		err = pdcspath_fetch(entry);
+		write_unlock(&entry->rw_lock);
+
+		if (err < 0)
 			continue;
 
 		if ((err = kobject_set_name(&entry->kobj, "%s", entry->name)))
@@ -667,13 +827,14 @@ pdcs_register_pathentries(void)
 			return err;
 		
 		/* kobject is now registered */
+		write_lock(&entry->rw_lock);
 		entry->ready = 2;
 		
-		if (!entry->dev)
-			continue;
-
 		/* Add a nice symlink to the real device */
-		sysfs_create_link(&entry->kobj, &entry->dev->kobj, "device");
+		if (entry->dev)
+			sysfs_create_link(&entry->kobj, &entry->dev->kobj, "device");
+
+		write_unlock(&entry->rw_lock);
 	}
 	
 	return 0;
@@ -688,14 +849,17 @@ pdcs_unregister_pathentries(void)
 	unsigned short i;
 	struct pdcspath_entry *entry;
 	
-	for (i = 0; (entry = pdcspath_entries[i]); i++)
+	for (i = 0; (entry = pdcspath_entries[i]); i++) {
+		read_lock(&entry->rw_lock);
 		if (entry->ready >= 2)
-			kobject_unregister(&entry->kobj);	
+			kobject_unregister(&entry->kobj);
+		read_unlock(&entry->rw_lock);
+	}
 }
 
 /*
- * For now we register the pdc subsystem with the firmware subsystem
- * and the paths subsystem with the pdc subsystem
+ * For now we register the stable subsystem with the firmware subsystem
+ * and the paths subsystem with the stable subsystem
  */
 static int __init
 pdc_stable_init(void)
@@ -707,19 +871,23 @@ pdc_stable_init(void)
 	if (pdc_stable_get_size(&pdcs_size) != PDC_OK) 
 		return -ENODEV;
 
-	printk(KERN_INFO "PDC Stable Storage facility v%s\n", PDCS_VERSION);
+	/* make sure we have enough data */
+	if (pdcs_size < 96)
+		return -ENODATA;
+
+	printk(KERN_INFO PDCS_PREFIX " facility v%s\n", PDCS_VERSION);
 
-	/* For now we'll register the pdc subsys within this driver */
-	if ((rc = firmware_register(&pdc_subsys)))
+	/* For now we'll register the stable subsys within this driver */
+	if ((rc = firmware_register(&stable_subsys)))
 		goto fail_firmreg;
 
-	/* Don't forget the info entry */
+	/* Don't forget the root entries */
 	for (i = 0; (attr = pdcs_subsys_attrs[i]) && !error; i++)
 		if (attr->show)
-			error = subsys_create_file(&pdc_subsys, attr);
+			error = subsys_create_file(&stable_subsys, attr);
 	
-	/* register the paths subsys as a subsystem of pdc subsys */
-	kset_set_kset_s(&paths_subsys, pdc_subsys);
+	/* register the paths subsys as a subsystem of stable subsys */
+	kset_set_kset_s(&paths_subsys, stable_subsys);
 	if ((rc= subsystem_register(&paths_subsys)))
 		goto fail_subsysreg;
 
@@ -734,10 +902,10 @@ pdc_stable_init(void)
 	subsystem_unregister(&paths_subsys);
 	
 fail_subsysreg:
-	firmware_unregister(&pdc_subsys);
+	firmware_unregister(&stable_subsys);
 	
 fail_firmreg:
-	printk(KERN_INFO "PDC Stable Storage bailing out\n");
+	printk(KERN_INFO PDCS_PREFIX " bailing out\n");
 	return rc;
 }
 
@@ -747,7 +915,7 @@ pdc_stable_exit(void)
 	pdcs_unregister_pathentries();
 	subsystem_unregister(&paths_subsys);
 
-	firmware_unregister(&pdc_subsys);
+	firmware_unregister(&stable_subsys);
 }
 
 

commit c59ede7b78db329949d9cdcd7064e22d357560ef
Author: Randy.Dunlap <rdunlap@xenotime.net>
Date:   Wed Jan 11 12:17:46 2006 -0800

    [PATCH] move capable() to capability.h
    
    - Move capable() from sched.h to capability.h;
    
    - Use <linux/capability.h> where capable() is used
            (in include/, block/, ipc/, kernel/, a few drivers/,
            mm/, security/, & sound/;
            many more drivers/ to go)
    
    Signed-off-by: Randy Dunlap <rdunlap@xenotime.net>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/parisc/pdc_stable.c b/drivers/parisc/pdc_stable.c
index 38bdca2fac6b..42a3c54e8e6c 100644
--- a/drivers/parisc/pdc_stable.c
+++ b/drivers/parisc/pdc_stable.c
@@ -42,9 +42,9 @@
 
 #include <linux/module.h>
 #include <linux/init.h>
-#include <linux/sched.h>		/* for capable() */
 #include <linux/kernel.h>
 #include <linux/string.h>
+#include <linux/capability.h>
 #include <linux/ctype.h>
 #include <linux/sysfs.h>
 #include <linux/kobject.h>

commit 4b991da7fec9b87acf86c250332ce15c2811255b
Author: Thibaut VARENE <varenet@parisc-linux.org>
Date:   Tue Jan 10 20:48:01 2006 -0500

    [PARISC] pdc_stable: More robust sysfs error checking
    
    pdc_stable 0.10:
    As mentioned on LKML, pdc_stable wasn't checky enough on the return
    values of some calls. This patch makes it more robust to errors when
    registering objects in sysfs.
    
    Signed-off-by: Thibaut VARENE <varenet@parisc-linux.org>
    Signed-off-by: Kyle McMartin <kyle@parisc-linux.org>

diff --git a/drivers/parisc/pdc_stable.c b/drivers/parisc/pdc_stable.c
index 11750cbb05c6..38bdca2fac6b 100644
--- a/drivers/parisc/pdc_stable.c
+++ b/drivers/parisc/pdc_stable.c
@@ -56,7 +56,7 @@
 #include <asm/uaccess.h>
 #include <asm/hardware.h>
 
-#define PDCS_VERSION	"0.09"
+#define PDCS_VERSION	"0.10"
 
 #define PDCS_ADDR_PPRI	0x00
 #define PDCS_ADDR_OSID	0x40
@@ -194,7 +194,8 @@ pdcspath_store(struct pdcspath_entry *entry)
 		return -EIO;
 	}
 		
-	entry->ready = 1;
+	/* kobject is already registered */
+	entry->ready = 2;
 	
 	DPRINTK("%s: device: 0x%p\n", __func__, entry->dev);
 	
@@ -653,15 +654,21 @@ pdcs_register_pathentries(void)
 {
 	unsigned short i;
 	struct pdcspath_entry *entry;
+	int err;
 	
 	for (i = 0; (entry = pdcspath_entries[i]); i++) {
 		if (pdcspath_fetch(entry) < 0)
 			continue;
 
-		kobject_set_name(&entry->kobj, "%s", entry->name);
+		if ((err = kobject_set_name(&entry->kobj, "%s", entry->name)))
+			return err;
 		kobj_set_kset_s(entry, paths_subsys);
-		kobject_register(&entry->kobj);
-
+		if ((err = kobject_register(&entry->kobj)))
+			return err;
+		
+		/* kobject is now registered */
+		entry->ready = 2;
+		
 		if (!entry->dev)
 			continue;
 
@@ -675,14 +682,14 @@ pdcs_register_pathentries(void)
 /**
  * pdcs_unregister_pathentries - Routine called when unregistering the module.
  */
-static inline void __exit
+static inline void
 pdcs_unregister_pathentries(void)
 {
 	unsigned short i;
 	struct pdcspath_entry *entry;
 	
 	for (i = 0; (entry = pdcspath_entries[i]); i++)
-		if (entry->ready)
+		if (entry->ready >= 2)
 			kobject_unregister(&entry->kobj);	
 }
 
@@ -704,7 +711,7 @@ pdc_stable_init(void)
 
 	/* For now we'll register the pdc subsys within this driver */
 	if ((rc = firmware_register(&pdc_subsys)))
-		return rc;
+		goto fail_firmreg;
 
 	/* Don't forget the info entry */
 	for (i = 0; (attr = pdcs_subsys_attrs[i]) && !error; i++)
@@ -713,12 +720,25 @@ pdc_stable_init(void)
 	
 	/* register the paths subsys as a subsystem of pdc subsys */
 	kset_set_kset_s(&paths_subsys, pdc_subsys);
-	subsystem_register(&paths_subsys);
+	if ((rc= subsystem_register(&paths_subsys)))
+		goto fail_subsysreg;
 
 	/* now we create all "files" for the paths subsys */
-	pdcs_register_pathentries();
+	if ((rc = pdcs_register_pathentries()))
+		goto fail_pdcsreg;
+
+	return rc;
 	
-	return 0;
+fail_pdcsreg:
+	pdcs_unregister_pathentries();
+	subsystem_unregister(&paths_subsys);
+	
+fail_subsysreg:
+	firmware_unregister(&pdc_subsys);
+	
+fail_firmreg:
+	printk(KERN_INFO "PDC Stable Storage bailing out\n");
+	return rc;
 }
 
 static void __exit

commit 8039de10aae3cd4cf0ef0ccebd58aff0e8810df2
Author: Helge Deller <deller@parisc-linux.org>
Date:   Tue Jan 10 20:35:03 2006 -0500

    [PARISC] Add __read_mostly section for parisc
    
    Flag a whole bunch of things as __read_mostly on parisc. Also flag a few
    branches as unlikely() and cleanup a bit of code.
    
    Signed-off-by: Helge Deller <deller@parisc-linux.org>
    Signed-off-by: Kyle McMartin <kyle@parisc-linux.org>

diff --git a/drivers/parisc/pdc_stable.c b/drivers/parisc/pdc_stable.c
index 273a74179720..11750cbb05c6 100644
--- a/drivers/parisc/pdc_stable.c
+++ b/drivers/parisc/pdc_stable.c
@@ -70,7 +70,7 @@ MODULE_DESCRIPTION("sysfs interface to HP PDC Stable Storage data");
 MODULE_LICENSE("GPL");
 MODULE_VERSION(PDCS_VERSION);
 
-static unsigned long pdcs_size = 0;
+static unsigned long pdcs_size __read_mostly;
 
 /* This struct defines what we need to deal with a parisc pdc path entry */
 struct pdcspath_entry {

commit abff75439fd6e9b5774e5984d4c3b3b59cb3038b
Author: Randolph Chung <tausq@parisc-linux.org>
Date:   Fri Oct 21 22:57:13 2005 -0400

    [PARISC] Avoid use of floating point in the kernel
    
    don't use *printf %f in the kernel, mm'kay?
    
    Signed-off-by: Randolph Chung <tausq@parisc-linux.org>
    
    Signed-off-by: Kyle McMartin <kyle@parisc-linux.org>

diff --git a/drivers/parisc/pdc_stable.c b/drivers/parisc/pdc_stable.c
index 67c8f3b44848..273a74179720 100644
--- a/drivers/parisc/pdc_stable.c
+++ b/drivers/parisc/pdc_stable.c
@@ -536,7 +536,7 @@ pdcs_info_read(struct subsystem *entry, char *buf)
 
 	out += sprintf(out, "Memory tested: ");
 	if ((result & 0x0F) < 0x0E)
-		out += sprintf(out, "%.3f MB", 0.256*(1<<(result & 0x0F)));
+		out += sprintf(out, "%d kB", (1<<(result & 0x0F))*256);
 	else
 		out += sprintf(out, "All");
 	out += sprintf(out, "\n");

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/drivers/parisc/pdc_stable.c b/drivers/parisc/pdc_stable.c
new file mode 100644
index 000000000000..67c8f3b44848
--- /dev/null
+++ b/drivers/parisc/pdc_stable.c
@@ -0,0 +1,735 @@
+/* 
+ *    Interfaces to retrieve and set PDC Stable options (firmware)
+ *
+ *    Copyright (C) 2005 Thibaut VARENE <varenet@parisc-linux.org>
+ *
+ *    This program is free software; you can redistribute it and/or modify
+ *    it under the terms of the GNU General Public License as published by
+ *    the Free Software Foundation; either version 2 of the License, or
+ *    (at your option) any later version.
+ *
+ *    This program is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *    GNU General Public License for more details.
+ *
+ *    You should have received a copy of the GNU General Public License
+ *    along with this program; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ *
+ *    DEV NOTE: the PDC Procedures reference states that:
+ *    "A minimum of 96 bytes of Stable Storage is required. Providing more than
+ *    96 bytes of Stable Storage is optional [...]. Failure to provide the
+ *    optional locations from 96 to 192 results in the loss of certain
+ *    functionality during boot."
+ *
+ *    Since locations between 96 and 192 are the various paths, most (if not
+ *    all) PA-RISC machines should have them. Anyway, for safety reasons, the
+ *    following code can deal with only 96 bytes of Stable Storage, and all
+ *    sizes between 96 and 192 bytes (provided they are multiple of struct
+ *    device_path size, eg: 128, 160 and 192) to provide full information.
+ *    The code makes no use of data above 192 bytes. One last word: there's one
+ *    path we can always count on: the primary path.
+ */
+
+#undef PDCS_DEBUG
+#ifdef PDCS_DEBUG
+#define DPRINTK(fmt, args...)	printk(KERN_DEBUG fmt, ## args)
+#else
+#define DPRINTK(fmt, args...)
+#endif
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/sched.h>		/* for capable() */
+#include <linux/kernel.h>
+#include <linux/string.h>
+#include <linux/ctype.h>
+#include <linux/sysfs.h>
+#include <linux/kobject.h>
+#include <linux/device.h>
+#include <linux/errno.h>
+
+#include <asm/pdc.h>
+#include <asm/page.h>
+#include <asm/uaccess.h>
+#include <asm/hardware.h>
+
+#define PDCS_VERSION	"0.09"
+
+#define PDCS_ADDR_PPRI	0x00
+#define PDCS_ADDR_OSID	0x40
+#define PDCS_ADDR_FSIZ	0x5C
+#define PDCS_ADDR_PCON	0x60
+#define PDCS_ADDR_PALT	0x80
+#define PDCS_ADDR_PKBD	0xA0
+
+MODULE_AUTHOR("Thibaut VARENE <varenet@parisc-linux.org>");
+MODULE_DESCRIPTION("sysfs interface to HP PDC Stable Storage data");
+MODULE_LICENSE("GPL");
+MODULE_VERSION(PDCS_VERSION);
+
+static unsigned long pdcs_size = 0;
+
+/* This struct defines what we need to deal with a parisc pdc path entry */
+struct pdcspath_entry {
+	short ready;			/* entry record is valid if != 0 */
+	unsigned long addr;		/* entry address in stable storage */
+	char *name;			/* entry name */
+	struct device_path devpath;	/* device path in parisc representation */
+	struct device *dev;		/* corresponding device */
+	struct kobject kobj;
+};
+
+struct pdcspath_attribute {
+	struct attribute attr;
+	ssize_t (*show)(struct pdcspath_entry *entry, char *buf);
+	ssize_t (*store)(struct pdcspath_entry *entry, const char *buf, size_t count);
+};
+
+#define PDCSPATH_ENTRY(_addr, _name) \
+struct pdcspath_entry pdcspath_entry_##_name = { \
+	.ready = 0, \
+	.addr = _addr, \
+	.name = __stringify(_name), \
+};
+
+#define PDCS_ATTR(_name, _mode, _show, _store) \
+struct subsys_attribute pdcs_attr_##_name = { \
+	.attr = {.name = __stringify(_name), .mode = _mode, .owner = THIS_MODULE}, \
+	.show = _show, \
+	.store = _store, \
+};
+
+#define PATHS_ATTR(_name, _mode, _show, _store) \
+struct pdcspath_attribute paths_attr_##_name = { \
+	.attr = {.name = __stringify(_name), .mode = _mode, .owner = THIS_MODULE}, \
+	.show = _show, \
+	.store = _store, \
+};
+
+#define to_pdcspath_attribute(_attr) container_of(_attr, struct pdcspath_attribute, attr)
+#define to_pdcspath_entry(obj)  container_of(obj, struct pdcspath_entry, kobj)
+
+/**
+ * pdcspath_fetch - This function populates the path entry structs.
+ * @entry: A pointer to an allocated pdcspath_entry.
+ * 
+ * The general idea is that you don't read from the Stable Storage every time
+ * you access the files provided by the facilites. We store a copy of the
+ * content of the stable storage WRT various paths in these structs. We read
+ * these structs when reading the files, and we will write to these structs when
+ * writing to the files, and only then write them back to the Stable Storage.
+ */
+static int
+pdcspath_fetch(struct pdcspath_entry *entry)
+{
+	struct device_path *devpath;
+
+	if (!entry)
+		return -EINVAL;
+
+	devpath = &entry->devpath;
+	
+	DPRINTK("%s: fetch: 0x%p, 0x%p, addr: 0x%lx\n", __func__,
+			entry, devpath, entry->addr);
+
+	/* addr, devpath and count must be word aligned */
+	if (pdc_stable_read(entry->addr, devpath, sizeof(*devpath)) != PDC_OK)
+		return -EIO;
+		
+	/* Find the matching device.
+	   NOTE: hardware_path overlays with device_path, so the nice cast can
+	   be used */
+	entry->dev = hwpath_to_device((struct hardware_path *)devpath);
+
+	entry->ready = 1;
+	
+	DPRINTK("%s: device: 0x%p\n", __func__, entry->dev);
+	
+	return 0;
+}
+
+/**
+ * pdcspath_store - This function writes a path to stable storage.
+ * @entry: A pointer to an allocated pdcspath_entry.
+ * 
+ * It can be used in two ways: either by passing it a preset devpath struct
+ * containing an already computed hardware path, or by passing it a device
+ * pointer, from which it'll find out the corresponding hardware path.
+ * For now we do not handle the case where there's an error in writing to the
+ * Stable Storage area, so you'd better not mess up the data :P
+ */
+static int
+pdcspath_store(struct pdcspath_entry *entry)
+{
+	struct device_path *devpath;
+
+	if (!entry)
+		return -EINVAL;
+
+	devpath = &entry->devpath;
+	
+	/* We expect the caller to set the ready flag to 0 if the hardware
+	   path struct provided is invalid, so that we know we have to fill it.
+	   First case, we don't have a preset hwpath... */
+	if (!entry->ready) {
+		/* ...but we have a device, map it */
+		if (entry->dev)
+			device_to_hwpath(entry->dev, (struct hardware_path *)devpath);
+		else
+			return -EINVAL;
+	}
+	/* else, we expect the provided hwpath to be valid. */
+	
+	DPRINTK("%s: store: 0x%p, 0x%p, addr: 0x%lx\n", __func__,
+			entry, devpath, entry->addr);
+
+	/* addr, devpath and count must be word aligned */
+	if (pdc_stable_write(entry->addr, devpath, sizeof(*devpath)) != PDC_OK) {
+		printk(KERN_ERR "%s: an error occured when writing to PDC.\n"
+				"It is likely that the Stable Storage data has been corrupted.\n"
+				"Please check it carefully upon next reboot.\n", __func__);
+		return -EIO;
+	}
+		
+	entry->ready = 1;
+	
+	DPRINTK("%s: device: 0x%p\n", __func__, entry->dev);
+	
+	return 0;
+}
+
+/**
+ * pdcspath_hwpath_read - This function handles hardware path pretty printing.
+ * @entry: An allocated and populated pdscpath_entry struct.
+ * @buf: The output buffer to write to.
+ * 
+ * We will call this function to format the output of the hwpath attribute file.
+ */
+static ssize_t
+pdcspath_hwpath_read(struct pdcspath_entry *entry, char *buf)
+{
+	char *out = buf;
+	struct device_path *devpath;
+	unsigned short i;
+
+	if (!entry || !buf)
+		return -EINVAL;
+
+	devpath = &entry->devpath;
+
+	if (!entry->ready)
+		return -ENODATA;
+	
+	for (i = 0; i < 6; i++) {
+		if (devpath->bc[i] >= 128)
+			continue;
+		out += sprintf(out, "%u/", (unsigned char)devpath->bc[i]);
+	}
+	out += sprintf(out, "%u\n", (unsigned char)devpath->mod);
+	
+	return out - buf;
+}
+
+/**
+ * pdcspath_hwpath_write - This function handles hardware path modifying.
+ * @entry: An allocated and populated pdscpath_entry struct.
+ * @buf: The input buffer to read from.
+ * @count: The number of bytes to be read.
+ * 
+ * We will call this function to change the current hardware path.
+ * Hardware paths are to be given '/'-delimited, without brackets.
+ * We take care to make sure that the provided path actually maps to an existing
+ * device, BUT nothing would prevent some foolish user to set the path to some
+ * PCI bridge or even a CPU...
+ * A better work around would be to make sure we are at the end of a device tree
+ * for instance, but it would be IMHO beyond the simple scope of that driver.
+ * The aim is to provide a facility. Data correctness is left to userland.
+ */
+static ssize_t
+pdcspath_hwpath_write(struct pdcspath_entry *entry, const char *buf, size_t count)
+{
+	struct hardware_path hwpath;
+	unsigned short i;
+	char in[count+1], *temp;
+	struct device *dev;
+
+	if (!entry || !buf || !count)
+		return -EINVAL;
+
+	/* We'll use a local copy of buf */
+	memset(in, 0, count+1);
+	strncpy(in, buf, count);
+	
+	/* Let's clean up the target. 0xff is a blank pattern */
+	memset(&hwpath, 0xff, sizeof(hwpath));
+	
+	/* First, pick the mod field (the last one of the input string) */
+	if (!(temp = strrchr(in, '/')))
+		return -EINVAL;
+			
+	hwpath.mod = simple_strtoul(temp+1, NULL, 10);
+	in[temp-in] = '\0';	/* truncate the remaining string. just precaution */
+	DPRINTK("%s: mod: %d\n", __func__, hwpath.mod);
+	
+	/* Then, loop for each delimiter, making sure we don't have too many.
+	   we write the bc fields in a down-top way. No matter what, we stop
+	   before writing the last field. If there are too many fields anyway,
+	   then the user is a moron and it'll be caught up later when we'll
+	   check the consistency of the given hwpath. */
+	for (i=5; ((temp = strrchr(in, '/'))) && (temp-in > 0) && (likely(i)); i--) {
+		hwpath.bc[i] = simple_strtoul(temp+1, NULL, 10);
+		in[temp-in] = '\0';
+		DPRINTK("%s: bc[%d]: %d\n", __func__, i, hwpath.bc[i]);
+	}
+	
+	/* Store the final field */		
+	hwpath.bc[i] = simple_strtoul(in, NULL, 10);
+	DPRINTK("%s: bc[%d]: %d\n", __func__, i, hwpath.bc[i]);
+	
+	/* Now we check that the user isn't trying to lure us */
+	if (!(dev = hwpath_to_device((struct hardware_path *)&hwpath))) {
+		printk(KERN_WARNING "%s: attempt to set invalid \"%s\" "
+			"hardware path: %s\n", __func__, entry->name, buf);
+		return -EINVAL;
+	}
+	
+	/* So far so good, let's get in deep */
+	entry->ready = 0;
+	entry->dev = dev;
+	
+	/* Now, dive in. Write back to the hardware */
+	WARN_ON(pdcspath_store(entry));	/* this warn should *NEVER* happen */
+	
+	/* Update the symlink to the real device */
+	sysfs_remove_link(&entry->kobj, "device");
+	sysfs_create_link(&entry->kobj, &entry->dev->kobj, "device");
+	
+	printk(KERN_INFO "PDC Stable Storage: changed \"%s\" path to \"%s\"\n",
+		entry->name, buf);
+	
+	return count;
+}
+
+/**
+ * pdcspath_layer_read - Extended layer (eg. SCSI ids) pretty printing.
+ * @entry: An allocated and populated pdscpath_entry struct.
+ * @buf: The output buffer to write to.
+ * 
+ * We will call this function to format the output of the layer attribute file.
+ */
+static ssize_t
+pdcspath_layer_read(struct pdcspath_entry *entry, char *buf)
+{
+	char *out = buf;
+	struct device_path *devpath;
+	unsigned short i;
+
+	if (!entry || !buf)
+		return -EINVAL;
+	
+	devpath = &entry->devpath;
+
+	if (!entry->ready)
+		return -ENODATA;
+	
+	for (i = 0; devpath->layers[i] && (likely(i < 6)); i++)
+		out += sprintf(out, "%u ", devpath->layers[i]);
+
+	out += sprintf(out, "\n");
+	
+	return out - buf;
+}
+
+/**
+ * pdcspath_layer_write - This function handles extended layer modifying.
+ * @entry: An allocated and populated pdscpath_entry struct.
+ * @buf: The input buffer to read from.
+ * @count: The number of bytes to be read.
+ * 
+ * We will call this function to change the current layer value.
+ * Layers are to be given '.'-delimited, without brackets.
+ * XXX beware we are far less checky WRT input data provided than for hwpath.
+ * Potential harm can be done, since there's no way to check the validity of
+ * the layer fields.
+ */
+static ssize_t
+pdcspath_layer_write(struct pdcspath_entry *entry, const char *buf, size_t count)
+{
+	unsigned int layers[6]; /* device-specific info (ctlr#, unit#, ...) */
+	unsigned short i;
+	char in[count+1], *temp;
+
+	if (!entry || !buf || !count)
+		return -EINVAL;
+
+	/* We'll use a local copy of buf */
+	memset(in, 0, count+1);
+	strncpy(in, buf, count);
+	
+	/* Let's clean up the target. 0 is a blank pattern */
+	memset(&layers, 0, sizeof(layers));
+	
+	/* First, pick the first layer */
+	if (unlikely(!isdigit(*in)))
+		return -EINVAL;
+	layers[0] = simple_strtoul(in, NULL, 10);
+	DPRINTK("%s: layer[0]: %d\n", __func__, layers[0]);
+	
+	temp = in;
+	for (i=1; ((temp = strchr(temp, '.'))) && (likely(i<6)); i++) {
+		if (unlikely(!isdigit(*(++temp))))
+			return -EINVAL;
+		layers[i] = simple_strtoul(temp, NULL, 10);
+		DPRINTK("%s: layer[%d]: %d\n", __func__, i, layers[i]);
+	}
+		
+	/* So far so good, let's get in deep */
+	
+	/* First, overwrite the current layers with the new ones, not touching
+	   the hardware path. */
+	memcpy(&entry->devpath.layers, &layers, sizeof(layers));
+	
+	/* Now, dive in. Write back to the hardware */
+	WARN_ON(pdcspath_store(entry));	/* this warn should *NEVER* happen */
+	
+	printk(KERN_INFO "PDC Stable Storage: changed \"%s\" layers to \"%s\"\n",
+		entry->name, buf);
+	
+	return count;
+}
+
+/**
+ * pdcspath_attr_show - Generic read function call wrapper.
+ * @kobj: The kobject to get info from.
+ * @attr: The attribute looked upon.
+ * @buf: The output buffer.
+ */
+static ssize_t
+pdcspath_attr_show(struct kobject *kobj, struct attribute *attr, char *buf)
+{
+	struct pdcspath_entry *entry = to_pdcspath_entry(kobj);
+	struct pdcspath_attribute *pdcs_attr = to_pdcspath_attribute(attr);
+	ssize_t ret = 0;
+
+	if (!capable(CAP_SYS_ADMIN))
+		return -EACCES;
+
+	if (pdcs_attr->show)
+		ret = pdcs_attr->show(entry, buf);
+
+	return ret;
+}
+
+/**
+ * pdcspath_attr_store - Generic write function call wrapper.
+ * @kobj: The kobject to write info to.
+ * @attr: The attribute to be modified.
+ * @buf: The input buffer.
+ * @count: The size of the buffer.
+ */
+static ssize_t
+pdcspath_attr_store(struct kobject *kobj, struct attribute *attr,
+			const char *buf, size_t count)
+{
+	struct pdcspath_entry *entry = to_pdcspath_entry(kobj);
+	struct pdcspath_attribute *pdcs_attr = to_pdcspath_attribute(attr);
+	ssize_t ret = 0;
+
+	if (!capable(CAP_SYS_ADMIN))
+		return -EACCES;
+
+	if (pdcs_attr->store)
+		ret = pdcs_attr->store(entry, buf, count);
+
+	return ret;
+}
+
+static struct sysfs_ops pdcspath_attr_ops = {
+	.show = pdcspath_attr_show,
+	.store = pdcspath_attr_store,
+};
+
+/* These are the two attributes of any PDC path. */
+static PATHS_ATTR(hwpath, 0600, pdcspath_hwpath_read, pdcspath_hwpath_write);
+static PATHS_ATTR(layer, 0600, pdcspath_layer_read, pdcspath_layer_write);
+
+static struct attribute *paths_subsys_attrs[] = {
+	&paths_attr_hwpath.attr,
+	&paths_attr_layer.attr,
+	NULL,
+};
+
+/* Specific kobject type for our PDC paths */
+static struct kobj_type ktype_pdcspath = {
+	.sysfs_ops = &pdcspath_attr_ops,
+	.default_attrs = paths_subsys_attrs,
+};
+
+/* We hard define the 4 types of path we expect to find */
+static PDCSPATH_ENTRY(PDCS_ADDR_PPRI, primary);
+static PDCSPATH_ENTRY(PDCS_ADDR_PCON, console);
+static PDCSPATH_ENTRY(PDCS_ADDR_PALT, alternative);
+static PDCSPATH_ENTRY(PDCS_ADDR_PKBD, keyboard);
+
+/* An array containing all PDC paths we will deal with */
+static struct pdcspath_entry *pdcspath_entries[] = {
+	&pdcspath_entry_primary,
+	&pdcspath_entry_alternative,
+	&pdcspath_entry_console,
+	&pdcspath_entry_keyboard,
+	NULL,
+};
+
+/**
+ * pdcs_info_read - Pretty printing of the remaining useful data.
+ * @entry: An allocated and populated subsytem struct. We don't use it tho.
+ * @buf: The output buffer to write to.
+ * 
+ * We will call this function to format the output of the 'info' attribute file.
+ * Please refer to PDC Procedures documentation, section PDC_STABLE to get a
+ * better insight of what we're doing here.
+ */
+static ssize_t
+pdcs_info_read(struct subsystem *entry, char *buf)
+{
+	char *out = buf;
+	__u32 result;
+	struct device_path devpath;
+	char *tmpstr = NULL;
+	
+	if (!entry || !buf)
+		return -EINVAL;
+		
+	/* show the size of the stable storage */
+	out += sprintf(out, "Stable Storage size: %ld bytes\n", pdcs_size);
+
+	/* deal with flags */
+	if (pdc_stable_read(PDCS_ADDR_PPRI, &devpath, sizeof(devpath)) != PDC_OK)
+		return -EIO;
+	
+	out += sprintf(out, "Autoboot: %s\n", (devpath.flags & PF_AUTOBOOT) ? "On" : "Off");
+	out += sprintf(out, "Autosearch: %s\n", (devpath.flags & PF_AUTOSEARCH) ? "On" : "Off");
+	out += sprintf(out, "Timer: %u s\n", (devpath.flags & PF_TIMER) ? (1 << (devpath.flags & PF_TIMER)) : 0);
+
+	/* get OSID */
+	if (pdc_stable_read(PDCS_ADDR_OSID, &result, sizeof(result)) != PDC_OK)
+		return -EIO;
+
+	/* the actual result is 16 bits away */
+	switch (result >> 16) {
+		case 0x0000:	tmpstr = "No OS-dependent data"; break;
+		case 0x0001:	tmpstr = "HP-UX dependent data"; break;
+		case 0x0002:	tmpstr = "MPE-iX dependent data"; break;
+		case 0x0003:	tmpstr = "OSF dependent data"; break;
+		case 0x0004:	tmpstr = "HP-RT dependent data"; break;
+		case 0x0005:	tmpstr = "Novell Netware dependent data"; break;
+		default:	tmpstr = "Unknown"; break;
+	}
+	out += sprintf(out, "OS ID: %s (0x%.4x)\n", tmpstr, (result >> 16));
+
+	/* get fast-size */
+	if (pdc_stable_read(PDCS_ADDR_FSIZ, &result, sizeof(result)) != PDC_OK)
+		return -EIO;
+
+	out += sprintf(out, "Memory tested: ");
+	if ((result & 0x0F) < 0x0E)
+		out += sprintf(out, "%.3f MB", 0.256*(1<<(result & 0x0F)));
+	else
+		out += sprintf(out, "All");
+	out += sprintf(out, "\n");
+	
+	return out - buf;
+}
+
+/**
+ * pdcs_info_write - This function handles boot flag modifying.
+ * @entry: An allocated and populated subsytem struct. We don't use it tho.
+ * @buf: The input buffer to read from.
+ * @count: The number of bytes to be read.
+ * 
+ * We will call this function to change the current boot flags.
+ * We expect a precise syntax:
+ *	\"n n\" (n == 0 or 1) to toggle respectively AutoBoot and AutoSearch
+ *
+ * As of now there is no incentive on my side to provide more "knobs" to that
+ * interface, since modifying the rest of the data is pretty meaningless when
+ * the machine is running and for the expected use of that facility, such as
+ * PALO setting up the boot disk when installing a Linux distribution...
+ */
+static ssize_t
+pdcs_info_write(struct subsystem *entry, const char *buf, size_t count)
+{
+	struct pdcspath_entry *pathentry;
+	unsigned char flags;
+	char in[count+1], *temp;
+	char c;
+
+	if (!capable(CAP_SYS_ADMIN))
+		return -EACCES;
+
+	if (!entry || !buf || !count)
+		return -EINVAL;
+
+	/* We'll use a local copy of buf */
+	memset(in, 0, count+1);
+	strncpy(in, buf, count);
+
+	/* Current flags are stored in primary boot path entry */
+	pathentry = &pdcspath_entry_primary;
+	
+	/* Be nice to the existing flag record */
+	flags = pathentry->devpath.flags;
+	
+	DPRINTK("%s: flags before: 0x%X\n", __func__, flags);
+			
+	temp = in;
+	
+	while (*temp && isspace(*temp))
+		temp++;
+	
+	c = *temp++ - '0';
+	if ((c != 0) && (c != 1))
+		goto parse_error;
+	if (c == 0)
+		flags &= ~PF_AUTOBOOT;
+	else
+		flags |= PF_AUTOBOOT;
+	
+	if (*temp++ != ' ')
+		goto parse_error;
+	
+	c = *temp++ - '0';
+	if ((c != 0) && (c != 1))
+		goto parse_error;
+	if (c == 0)
+		flags &= ~PF_AUTOSEARCH;
+	else
+		flags |= PF_AUTOSEARCH;
+	
+	DPRINTK("%s: flags after: 0x%X\n", __func__, flags);
+		
+	/* So far so good, let's get in deep */
+	
+	/* Change the path entry flags first */
+	pathentry->devpath.flags = flags;
+		
+	/* Now, dive in. Write back to the hardware */
+	WARN_ON(pdcspath_store(pathentry));	/* this warn should *NEVER* happen */
+	
+	printk(KERN_INFO "PDC Stable Storage: changed flags to \"%s\"\n", buf);
+	
+	return count;
+
+parse_error:
+	printk(KERN_WARNING "%s: Parse error: expect \"n n\" (n == 0 or 1) for AB and AS\n", __func__);
+	return -EINVAL;
+}
+
+/* The last attribute (the 'root' one actually) with all remaining data. */
+static PDCS_ATTR(info, 0600, pdcs_info_read, pdcs_info_write);
+
+static struct subsys_attribute *pdcs_subsys_attrs[] = {
+	&pdcs_attr_info,
+	NULL,	/* maybe more in the future? */
+};
+
+static decl_subsys(paths, &ktype_pdcspath, NULL);
+static decl_subsys(pdc, NULL, NULL);
+
+/**
+ * pdcs_register_pathentries - Prepares path entries kobjects for sysfs usage.
+ * 
+ * It creates kobjects corresponding to each path entry with nice sysfs
+ * links to the real device. This is where the magic takes place: when
+ * registering the subsystem attributes during module init, each kobject hereby
+ * created will show in the sysfs tree as a folder containing files as defined
+ * by path_subsys_attr[].
+ */
+static inline int __init
+pdcs_register_pathentries(void)
+{
+	unsigned short i;
+	struct pdcspath_entry *entry;
+	
+	for (i = 0; (entry = pdcspath_entries[i]); i++) {
+		if (pdcspath_fetch(entry) < 0)
+			continue;
+
+		kobject_set_name(&entry->kobj, "%s", entry->name);
+		kobj_set_kset_s(entry, paths_subsys);
+		kobject_register(&entry->kobj);
+
+		if (!entry->dev)
+			continue;
+
+		/* Add a nice symlink to the real device */
+		sysfs_create_link(&entry->kobj, &entry->dev->kobj, "device");
+	}
+	
+	return 0;
+}
+
+/**
+ * pdcs_unregister_pathentries - Routine called when unregistering the module.
+ */
+static inline void __exit
+pdcs_unregister_pathentries(void)
+{
+	unsigned short i;
+	struct pdcspath_entry *entry;
+	
+	for (i = 0; (entry = pdcspath_entries[i]); i++)
+		if (entry->ready)
+			kobject_unregister(&entry->kobj);	
+}
+
+/*
+ * For now we register the pdc subsystem with the firmware subsystem
+ * and the paths subsystem with the pdc subsystem
+ */
+static int __init
+pdc_stable_init(void)
+{
+	struct subsys_attribute *attr;
+	int i, rc = 0, error = 0;
+
+	/* find the size of the stable storage */
+	if (pdc_stable_get_size(&pdcs_size) != PDC_OK) 
+		return -ENODEV;
+
+	printk(KERN_INFO "PDC Stable Storage facility v%s\n", PDCS_VERSION);
+
+	/* For now we'll register the pdc subsys within this driver */
+	if ((rc = firmware_register(&pdc_subsys)))
+		return rc;
+
+	/* Don't forget the info entry */
+	for (i = 0; (attr = pdcs_subsys_attrs[i]) && !error; i++)
+		if (attr->show)
+			error = subsys_create_file(&pdc_subsys, attr);
+	
+	/* register the paths subsys as a subsystem of pdc subsys */
+	kset_set_kset_s(&paths_subsys, pdc_subsys);
+	subsystem_register(&paths_subsys);
+
+	/* now we create all "files" for the paths subsys */
+	pdcs_register_pathentries();
+	
+	return 0;
+}
+
+static void __exit
+pdc_stable_exit(void)
+{
+	pdcs_unregister_pathentries();
+	subsystem_unregister(&paths_subsys);
+
+	firmware_unregister(&pdc_subsys);
+}
+
+
+module_init(pdc_stable_init);
+module_exit(pdc_stable_exit);
