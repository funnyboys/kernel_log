commit ebee4b02d073fd47459a6f22cb3a9385364f0454
Author: Helge Deller <deller@gmx.de>
Date:   Thu Sep 5 16:37:38 2019 +0200

    parisc: Convert eisa_enumerator to use pr_cont()
    
    Clean up and beautify kernel output by using pr_cont() and printk
    formats like %pR for resources.
    This was noticed on a HP D350/2 machine.
    
    Signed-off-by: Helge Deller <deller@gmx.de>

diff --git a/drivers/parisc/eisa_enumerator.c b/drivers/parisc/eisa_enumerator.c
index 9c08222c0cc6..f54a6f450391 100644
--- a/drivers/parisc/eisa_enumerator.c
+++ b/drivers/parisc/eisa_enumerator.c
@@ -93,7 +93,7 @@ static int configure_memory(const unsigned char *buf,
 			res->start = mem_parent->start + get_24(buf+len+2);
 			res->end = res->start + get_16(buf+len+5)*1024;
 			res->flags = IORESOURCE_MEM;
-			printk("memory %lx-%lx ", (unsigned long)res->start, (unsigned long)res->end);
+			pr_cont("memory %pR ", res);
 			result = request_resource(mem_parent, res);
 			if (result < 0) {
 				printk(KERN_ERR "EISA Enumerator: failed to claim EISA Bus address space!\n");
@@ -123,7 +123,7 @@ static int configure_irq(const unsigned char *buf)
 	for (i=0;i<HPEE_IRQ_MAX_ENT;i++) {
 		c = get_8(buf+len);
 		
-		printk("IRQ %d ", c & HPEE_IRQ_CHANNEL_MASK);
+		pr_cont("IRQ %d ", c & HPEE_IRQ_CHANNEL_MASK);
 		if (c & HPEE_IRQ_TRIG_LEVEL) {
 			eisa_make_irq_level(c & HPEE_IRQ_CHANNEL_MASK);
 		} else {
@@ -153,7 +153,7 @@ static int configure_dma(const unsigned char *buf)
 	
 	for (i=0;i<HPEE_DMA_MAX_ENT;i++) {
 		c = get_8(buf+len);
-		printk("DMA %d ", c&HPEE_DMA_CHANNEL_MASK);
+		pr_cont("DMA %d ", c&HPEE_DMA_CHANNEL_MASK);
 		/* fixme: maybe initialize the dma channel withthe timing ? */
 		len+=2;      
 		if (!(c & HPEE_DMA_MORE)) {
@@ -183,7 +183,7 @@ static int configure_port(const unsigned char *buf, struct resource *io_parent,
 			res->start = get_16(buf+len+1);
 			res->end = get_16(buf+len+1)+(c&HPEE_PORT_SIZE_MASK)+1;
 			res->flags = IORESOURCE_IO;
-			printk("ioports %lx-%lx ", (unsigned long)res->start, (unsigned long)res->end);
+			pr_cont("ioports %pR ", res);
 			result = request_resource(io_parent, res);
 			if (result < 0) {
 				printk(KERN_ERR "EISA Enumerator: failed to claim EISA Bus address space!\n");
@@ -401,7 +401,7 @@ static int parse_slot_config(int slot,
 		}
 		pos = p0 + function_len;
 	}
-	printk("\n");
+	pr_cont("\n");
 	if (!id_string_used) {
 		kfree(board);
 	}

commit 2874c5fd284268364ece81a7bd936f3c8168e567
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:01 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 152
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 3029 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070032.746973796@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/parisc/eisa_enumerator.c b/drivers/parisc/eisa_enumerator.c
index d9bffe8d29b9..9c08222c0cc6 100644
--- a/drivers/parisc/eisa_enumerator.c
+++ b/drivers/parisc/eisa_enumerator.c
@@ -1,13 +1,8 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * eisa_enumerator.c - provide support for EISA adapters in PA-RISC machines
  *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version
- * 2 of the License, or (at your option) any later version.
- *
  * Copyright (c) 2002 Daniel Engstrom <5116@telia.com>
- *
  */
 
 #include <linux/ioport.h>

commit 7c0f6ba682b9c7632072ffbedf8d328c8f3c42ba
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Dec 24 11:46:01 2016 -0800

    Replace <asm/uaccess.h> with <linux/uaccess.h> globally
    
    This was entirely automated, using the script by Al:
    
      PATT='^[[:blank:]]*#[[:blank:]]*include[[:blank:]]*<asm/uaccess.h>'
      sed -i -e "s!$PATT!#include <linux/uaccess.h>!" \
            $(git grep -l "$PATT"|grep -v ^include/linux/uaccess.h)
    
    to do the replacement at the end of the merge window.
    
    Requested-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/parisc/eisa_enumerator.c b/drivers/parisc/eisa_enumerator.c
index 21905fef2cbf..d9bffe8d29b9 100644
--- a/drivers/parisc/eisa_enumerator.c
+++ b/drivers/parisc/eisa_enumerator.c
@@ -15,7 +15,7 @@
 #include <linux/kernel.h>
 #include <linux/slab.h>
 #include <asm/io.h>
-#include <asm/uaccess.h>
+#include <linux/uaccess.h>
 #include <asm/byteorder.h>
 
 #include <asm/eisa_bus.h>

commit 9a975bee4b3945b271bcff18a520d4863c210f8b
Author: Toshi Kani <toshi.kani@hpe.com>
Date:   Tue Jan 26 21:57:25 2016 +0100

    drivers: Initialize resource entry to zero
    
    I/O resource descriptor, 'desc' in struct resource, needs to be
    initialized to zero by default.  Some drivers call kmalloc() to
    allocate a resource entry, but do not initialize it to zero by
    memset().  Change these drivers to call kzalloc(), instead.
    
    Signed-off-by: Toshi Kani <toshi.kani@hpe.com>
    Signed-off-by: Borislav Petkov <bp@suse.de>
    Acked-by: Alexandre Bounine <alexandre.bounine@idt.com>
    Acked-by: Helge Deller <deller@gmx.de>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Simon Horman <horms+renesas@verge.net.au>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Andy Lutomirski <luto@amacapital.net>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Brian Gerst <brgerst@gmail.com>
    Cc: Denys Vlasenko <dvlasenk@redhat.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Luis R. Rodriguez <mcgrof@suse.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Toshi Kani <toshi.kani@hp.com>
    Cc: linux-acpi@vger.kernel.org
    Cc: linux-arch@vger.kernel.org
    Cc: linux-mm <linux-mm@kvack.org>
    Cc: linux-parisc@vger.kernel.org
    Cc: linux-renesas-soc@vger.kernel.org
    Cc: linux-sh@vger.kernel.org
    Link: http://lkml.kernel.org/r/1453841853-11383-10-git-send-email-bp@alien8.de
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/drivers/parisc/eisa_enumerator.c b/drivers/parisc/eisa_enumerator.c
index a656d9e83343..21905fef2cbf 100644
--- a/drivers/parisc/eisa_enumerator.c
+++ b/drivers/parisc/eisa_enumerator.c
@@ -91,7 +91,7 @@ static int configure_memory(const unsigned char *buf,
 	for (i=0;i<HPEE_MEMORY_MAX_ENT;i++) {
 		c = get_8(buf+len);
 		
-		if (NULL != (res = kmalloc(sizeof(struct resource), GFP_KERNEL))) {
+		if (NULL != (res = kzalloc(sizeof(struct resource), GFP_KERNEL))) {
 			int result;
 			
 			res->name = name;
@@ -183,7 +183,7 @@ static int configure_port(const unsigned char *buf, struct resource *io_parent,
 	for (i=0;i<HPEE_PORT_MAX_ENT;i++) {
 		c = get_8(buf+len);
 		
-		if (NULL != (res = kmalloc(sizeof(struct resource), GFP_KERNEL))) {
+		if (NULL != (res = kzalloc(sizeof(struct resource), GFP_KERNEL))) {
 			res->name = board;
 			res->start = get_16(buf+len+1);
 			res->end = get_16(buf+len+1)+(c&HPEE_PORT_SIZE_MASK)+1;

commit d939be3add4f1410079dad2755d4936cdb70903b
Author: Masanari Iida <standby24x7@gmail.com>
Date:   Fri Feb 27 23:52:31 2015 +0900

    treewide: Fix typo in printk messages
    
    This patch fix spelling typo in printk messages.
    
    Signed-off-by: Masanari Iida <standby24x7@gmail.com>
    Acked-by: Randy Dunlap <rdunlap@infradead.org>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/parisc/eisa_enumerator.c b/drivers/parisc/eisa_enumerator.c
index caa153133754..a656d9e83343 100644
--- a/drivers/parisc/eisa_enumerator.c
+++ b/drivers/parisc/eisa_enumerator.c
@@ -357,7 +357,7 @@ static int parse_slot_config(int slot,
 		}
 		if (flags & HPEE_FUNCTION_INFO_CFG_FREE_FORM) {
 			/* I have no idea how to handle this */
-			printk("function %d have free-form confgiuration, skipping ",
+			printk("function %d have free-form configuration, skipping ",
 				num_func);
 			pos = p0 + function_len;
 			continue;

commit a3bee03e718c9251456676b71a723a34c999e891
Author: Frans Pop <elendil@planet.nl>
Date:   Sat Feb 6 17:47:14 2010 +0000

    parisc: remove trailing space in messages
    
    Signed-off-by: Frans Pop <elendil@planet.nl>
    Cc: linux-parisc@vger.kernel.org
    Cc: Kyle McMartin <kyle@mcmartin.ca>
    Cc: Helge Deller <deller@gmx.de>
    Signed-off-by: Kyle McMartin <kyle@mcmartin.ca>

diff --git a/drivers/parisc/eisa_enumerator.c b/drivers/parisc/eisa_enumerator.c
index 0be1d50645ab..caa153133754 100644
--- a/drivers/parisc/eisa_enumerator.c
+++ b/drivers/parisc/eisa_enumerator.c
@@ -460,7 +460,7 @@ static int init_slot(int slot, struct eeprom_eisa_slot_info *es)
 			       slot, id_string);
 			
 			print_eisa_id(id_string, es->eisa_slot_id);
-			printk(" expected %s \n", id_string);
+			printk(" expected %s\n", id_string);
 		
 			return -1;	
 			

commit ad361c9884e809340f6daca80d56a9e9c871690a
Author: Joe Perches <joe@perches.com>
Date:   Mon Jul 6 13:05:40 2009 -0700

    Remove multiple KERN_ prefixes from printk formats
    
    Commit 5fd29d6ccbc98884569d6f3105aeca70858b3e0f ("printk: clean up
    handling of log-levels and newlines") changed printk semantics.  printk
    lines with multiple KERN_<level> prefixes are no longer emitted as
    before the patch.
    
    <level> is now included in the output on each additional use.
    
    Remove all uses of multiple KERN_<level>s in formats.
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/parisc/eisa_enumerator.c b/drivers/parisc/eisa_enumerator.c
index c709ecc2b7f7..0be1d50645ab 100644
--- a/drivers/parisc/eisa_enumerator.c
+++ b/drivers/parisc/eisa_enumerator.c
@@ -101,7 +101,7 @@ static int configure_memory(const unsigned char *buf,
 			printk("memory %lx-%lx ", (unsigned long)res->start, (unsigned long)res->end);
 			result = request_resource(mem_parent, res);
 			if (result < 0) {
-				printk("\n" KERN_ERR "EISA Enumerator: failed to claim EISA Bus address space!\n");
+				printk(KERN_ERR "EISA Enumerator: failed to claim EISA Bus address space!\n");
 				return result;
 			}
 		}
@@ -191,7 +191,7 @@ static int configure_port(const unsigned char *buf, struct resource *io_parent,
 			printk("ioports %lx-%lx ", (unsigned long)res->start, (unsigned long)res->end);
 			result = request_resource(io_parent, res);
 			if (result < 0) {
-				printk("\n" KERN_ERR "EISA Enumerator: failed to claim EISA Bus address space!\n");
+				printk(KERN_ERR "EISA Enumerator: failed to claim EISA Bus address space!\n");
 				return result;
 			}
 		}
@@ -224,7 +224,7 @@ static int configure_port_init(const unsigned char *buf)
 		 case HPEE_PORT_INIT_WIDTH_BYTE:
 			s=1;
 			if (c & HPEE_PORT_INIT_MASK) {
-				printk("\n" KERN_WARNING "port_init: unverified mask attribute\n");
+				printk(KERN_WARNING "port_init: unverified mask attribute\n");
 				outb((inb(get_16(buf+len+1) & 
 					  get_8(buf+len+3)) | 
 				      get_8(buf+len+4)), get_16(buf+len+1));
@@ -249,7 +249,7 @@ static int configure_port_init(const unsigned char *buf)
 		 case HPEE_PORT_INIT_WIDTH_DWORD:
 			s=4;
 			if (c & HPEE_PORT_INIT_MASK) {
- 				printk("\n" KERN_WARNING "port_init: unverified mask attribute\n");
+ 				printk(KERN_WARNING "port_init: unverified mask attribute\n");
 				outl((inl(get_16(buf+len+1) &
 					  get_32(buf+len+3)) |
 				      get_32(buf+len+7)), get_16(buf+len+1));
@@ -259,7 +259,7 @@ static int configure_port_init(const unsigned char *buf)
 
 			break;
 		 default:
-			printk("\n" KERN_ERR "Invalid port init word %02x\n", c);
+			printk(KERN_ERR "Invalid port init word %02x\n", c);
 			return 0;
 		}
 		
@@ -297,7 +297,7 @@ static int configure_type_string(const unsigned char *buf)
 	/* just skip past the type field */
 	len = get_8(buf);
 	if (len > 80) {
-		printk("\n" KERN_ERR "eisa_enumerator: type info field too long (%d, max is 80)\n", len);
+		printk(KERN_ERR "eisa_enumerator: type info field too long (%d, max is 80)\n", len);
 	}
 	
 	return 1+len;
@@ -398,7 +398,7 @@ static int parse_slot_config(int slot,
 		}
 		
 		if (p0 + function_len < pos) {
-			printk("\n" KERN_ERR "eisa_enumerator: function %d length mis-match "
+			printk(KERN_ERR "eisa_enumerator: function %d length mis-match "
 			       "got %d, expected %d\n",
 			       num_func, pos-p0, function_len);
 			res=-1;

commit c18b4608958ff42ce9a1a55b0a6f40b714f47286
Author: Alexander Beregalov <a.beregalov@gmail.com>
Date:   Thu Mar 19 10:54:07 2009 +0000

    parisc: drivers: fix warnings
    
    ccio-dma.c:456: warning: overflow in implicit constant conversion
    ccio-dma.c:459: warning: overflow in implicit constant conversion
    ccio-dma.c:1032: warning: unused variable 'j'
    ccio-dma.c:1031: warning: unused variable 'max'
    ccio-dma.c:1031: warning: unused variable 'min'
    ccio-dma.c:1031: warning: unused variable 'avg'
    ccio-dma.c:1403: warning: format '%08lx' expects type 'long unsigned int', but argument 3 has type 'resource_size_t'
    ccio-dma.c:1403: warning: format '%08lx' expects type 'long unsigned int', but argument 4 has type 'resource_size_t'
    ccio-dma.c:1554: warning: format '%lx' expects type 'long unsigned int', but argument 3 has type 'resource_size_t'
    dino.c:822: warning: format '%lx' expects type 'long unsigned int', but argument 4 has type 'resource_size_t'
    dino.c:822: warning: format '%lx' expects type 'long unsigned int', but argument 5 has type 'resource_size_t'
    dino.c:902: warning: format '%lx' expects type 'long unsigned int', but argument 3 has type 'resource_size_t'
    dino.c:902: warning: format '%lx' expects type 'long unsigned int', but argument 4 has type 'resource_size_t'
    asp.c:84: warning: format '%lx' expects type 'long unsigned int', but argument 4 has type 'resource_size_t'
    eisa.c:317: warning: format '%08lx' expects type 'long unsigned int', but argument 3 has type 'resource_size_t'
    eisa_enumerator.c:101: warning: format '%lx' expects type 'long unsigned int', but argument 2 has type 'resource_size_t'
    eisa_enumerator.c:101: warning: format '%lx' expects type 'long unsigned int', but argument 3 has type 'resource_size_t'
    eisa_enumerator.c:191: warning: format '%lx' expects type 'long unsigned int', but argument 2 has type 'resource_size_t'
    eisa_enumerator.c:191: warning: format '%lx' expects type 'long unsigned int', but argument 3 has type 'resource_size_t'
    
    Signed-off-by: Alexander Beregalov <a.beregalov@gmail.com>
    Signed-off-by: Kyle McMartin <kyle@mcmartin.ca>

diff --git a/drivers/parisc/eisa_enumerator.c b/drivers/parisc/eisa_enumerator.c
index 6d8aae003f6c..c709ecc2b7f7 100644
--- a/drivers/parisc/eisa_enumerator.c
+++ b/drivers/parisc/eisa_enumerator.c
@@ -98,7 +98,7 @@ static int configure_memory(const unsigned char *buf,
 			res->start = mem_parent->start + get_24(buf+len+2);
 			res->end = res->start + get_16(buf+len+5)*1024;
 			res->flags = IORESOURCE_MEM;
-			printk("memory %lx-%lx ", res->start, res->end);
+			printk("memory %lx-%lx ", (unsigned long)res->start, (unsigned long)res->end);
 			result = request_resource(mem_parent, res);
 			if (result < 0) {
 				printk("\n" KERN_ERR "EISA Enumerator: failed to claim EISA Bus address space!\n");
@@ -188,7 +188,7 @@ static int configure_port(const unsigned char *buf, struct resource *io_parent,
 			res->start = get_16(buf+len+1);
 			res->end = get_16(buf+len+1)+(c&HPEE_PORT_SIZE_MASK)+1;
 			res->flags = IORESOURCE_IO;
-			printk("ioports %lx-%lx ", res->start, res->end);
+			printk("ioports %lx-%lx ", (unsigned long)res->start, (unsigned long)res->end);
 			result = request_resource(io_parent, res);
 			if (result < 0) {
 				printk("\n" KERN_ERR "EISA Enumerator: failed to claim EISA Bus address space!\n");

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/drivers/parisc/eisa_enumerator.c b/drivers/parisc/eisa_enumerator.c
new file mode 100644
index 000000000000..6d8aae003f6c
--- /dev/null
+++ b/drivers/parisc/eisa_enumerator.c
@@ -0,0 +1,521 @@
+/*
+ * eisa_enumerator.c - provide support for EISA adapters in PA-RISC machines
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ *
+ * Copyright (c) 2002 Daniel Engstrom <5116@telia.com>
+ *
+ */
+
+#include <linux/ioport.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <asm/io.h>
+#include <asm/uaccess.h>
+#include <asm/byteorder.h>
+
+#include <asm/eisa_bus.h>
+#include <asm/eisa_eeprom.h>
+
+
+/*
+ * Todo:
+ * 
+ * PORT init with MASK attr and other size than byte
+ * MEMORY with other decode than 20 bit
+ * CRC stuff
+ * FREEFORM stuff
+ */
+
+#define EPI 0xc80
+#define NUM_SLOT 16
+#define SLOT2PORT(x) (x<<12)
+
+
+/* macros to handle unaligned accesses and 
+ * byte swapping. The data in the EEPROM is
+ * little-endian on the big-endian PAROSC */
+#define get_8(x) (*(u_int8_t*)(x))
+
+static inline u_int16_t get_16(const unsigned char *x)
+{ 
+	return (x[1] << 8) | x[0];
+}
+
+static inline u_int32_t get_32(const unsigned char *x)
+{
+	return (x[3] << 24) | (x[2] << 16) | (x[1] << 8) | x[0];
+}
+
+static inline u_int32_t get_24(const unsigned char *x)
+{
+	return (x[2] << 24) | (x[1] << 16) | (x[0] << 8);
+}
+
+static void print_eisa_id(char *s, u_int32_t id)
+{
+	char vendor[4];
+	int rev;
+	int device;
+	
+	rev = id & 0xff;
+	id >>= 8;
+	device = id & 0xff;
+	id >>= 8;
+	vendor[3] = '\0';
+	vendor[2] = '@' + (id & 0x1f);
+	id >>= 5;	
+	vendor[1] = '@' + (id & 0x1f);
+	id >>= 5;	
+	vendor[0] = '@' + (id & 0x1f);
+	id >>= 5;	
+	
+	sprintf(s, "%s%02X%02X", vendor, device, rev);
+}
+       
+static int configure_memory(const unsigned char *buf, 
+		       struct resource *mem_parent,
+		       char *name)
+{
+	int len;
+	u_int8_t c;
+	int i;
+	struct resource *res;
+	
+	len=0;
+	
+	for (i=0;i<HPEE_MEMORY_MAX_ENT;i++) {
+		c = get_8(buf+len);
+		
+		if (NULL != (res = kmalloc(sizeof(struct resource), GFP_KERNEL))) {
+			int result;
+			
+			res->name = name;
+			res->start = mem_parent->start + get_24(buf+len+2);
+			res->end = res->start + get_16(buf+len+5)*1024;
+			res->flags = IORESOURCE_MEM;
+			printk("memory %lx-%lx ", res->start, res->end);
+			result = request_resource(mem_parent, res);
+			if (result < 0) {
+				printk("\n" KERN_ERR "EISA Enumerator: failed to claim EISA Bus address space!\n");
+				return result;
+			}
+		}
+		 	
+		len+=7;      
+	
+		if (!(c & HPEE_MEMORY_MORE)) {
+			break;
+		}
+	}
+	
+	return len;
+}
+
+
+static int configure_irq(const unsigned char *buf)
+{
+	int len;
+	u_int8_t c;
+	int i;
+	
+	len=0;
+	
+	for (i=0;i<HPEE_IRQ_MAX_ENT;i++) {
+		c = get_8(buf+len);
+		
+		printk("IRQ %d ", c & HPEE_IRQ_CHANNEL_MASK);
+		if (c & HPEE_IRQ_TRIG_LEVEL) {
+			eisa_make_irq_level(c & HPEE_IRQ_CHANNEL_MASK);
+		} else {
+			eisa_make_irq_edge(c & HPEE_IRQ_CHANNEL_MASK);
+		}
+		
+		len+=2; 
+		/* hpux seems to allow for
+		 * two bytes of irq data but only defines one of
+		 * them, I think */
+		if  (!(c & HPEE_IRQ_MORE)) {
+			break;
+		}
+	}
+	
+	return len;
+}
+
+
+static int configure_dma(const unsigned char *buf)
+{
+	int len;
+	u_int8_t c;
+	int i;
+	
+	len=0;
+	
+	for (i=0;i<HPEE_DMA_MAX_ENT;i++) {
+		c = get_8(buf+len);
+		printk("DMA %d ", c&HPEE_DMA_CHANNEL_MASK);
+		/* fixme: maybe initialize the dma channel withthe timing ? */
+		len+=2;      
+		if (!(c & HPEE_DMA_MORE)) {
+			break;
+		}
+	}
+	
+	return len;
+}
+
+static int configure_port(const unsigned char *buf, struct resource *io_parent,
+		     char *board)
+{
+	int len;
+	u_int8_t c;
+	int i;
+	struct resource *res;
+	int result;
+	
+	len=0;
+	
+	for (i=0;i<HPEE_PORT_MAX_ENT;i++) {
+		c = get_8(buf+len);
+		
+		if (NULL != (res = kmalloc(sizeof(struct resource), GFP_KERNEL))) {
+			res->name = board;
+			res->start = get_16(buf+len+1);
+			res->end = get_16(buf+len+1)+(c&HPEE_PORT_SIZE_MASK)+1;
+			res->flags = IORESOURCE_IO;
+			printk("ioports %lx-%lx ", res->start, res->end);
+			result = request_resource(io_parent, res);
+			if (result < 0) {
+				printk("\n" KERN_ERR "EISA Enumerator: failed to claim EISA Bus address space!\n");
+				return result;
+			}
+		}
+
+		len+=3;      
+		if (!(c & HPEE_PORT_MORE)) {
+			break;
+		}
+	}
+	
+	return len;
+}
+
+
+/* byte 1 and 2 is the port number to write
+ * and at byte 3 the value to write starts.
+ * I assume that there are and- and or- masks
+ * here when HPEE_PORT_INIT_MASK is set but I have 
+ * not yet encountered this. */
+static int configure_port_init(const unsigned char *buf)
+{
+	int len=0;
+	u_int8_t c;
+	
+	while (len<HPEE_PORT_INIT_MAX_LEN) {
+		int s=0;
+		c = get_8(buf+len);
+		
+		switch (c & HPEE_PORT_INIT_WIDTH_MASK)  {
+		 case HPEE_PORT_INIT_WIDTH_BYTE:
+			s=1;
+			if (c & HPEE_PORT_INIT_MASK) {
+				printk("\n" KERN_WARNING "port_init: unverified mask attribute\n");
+				outb((inb(get_16(buf+len+1) & 
+					  get_8(buf+len+3)) | 
+				      get_8(buf+len+4)), get_16(buf+len+1));
+				      
+			} else {
+				outb(get_8(buf+len+3), get_16(buf+len+1));
+				      
+			}
+			break;
+		 case HPEE_PORT_INIT_WIDTH_WORD:
+			s=2;
+			if (c & HPEE_PORT_INIT_MASK) {
+ 				printk(KERN_WARNING "port_init: unverified mask attribute\n");
+				       outw((inw(get_16(buf+len+1)) &
+					     get_16(buf+len+3)) |
+					    get_16(buf+len+5), 
+					    get_16(buf+len+1));
+			} else {
+				outw(cpu_to_le16(get_16(buf+len+3)), get_16(buf+len+1));
+			}
+			break;
+		 case HPEE_PORT_INIT_WIDTH_DWORD:
+			s=4;
+			if (c & HPEE_PORT_INIT_MASK) {
+ 				printk("\n" KERN_WARNING "port_init: unverified mask attribute\n");
+				outl((inl(get_16(buf+len+1) &
+					  get_32(buf+len+3)) |
+				      get_32(buf+len+7)), get_16(buf+len+1));
+			} else {
+				outl(cpu_to_le32(get_32(buf+len+3)), get_16(buf+len+1));
+			}
+
+			break;
+		 default:
+			printk("\n" KERN_ERR "Invalid port init word %02x\n", c);
+			return 0;
+		}
+		
+		if (c & HPEE_PORT_INIT_MASK) {   
+			s*=2;
+		}
+		
+		len+=s+3;
+		if (!(c & HPEE_PORT_INIT_MORE)) {
+			break;
+		}
+	}
+	
+	return len;
+}
+
+static int configure_choise(const unsigned char *buf, u_int8_t *info)
+{
+	int len;
+	
+	/* theis record contain the value of the functions
+	 * configuration choises and an info byte which 
+	 * describes which other records to expect in this 
+	 * function */
+	len = get_8(buf);
+	*info=get_8(buf+len+1);
+	 
+	return len+2;
+}
+
+static int configure_type_string(const unsigned char *buf) 
+{
+	int len;
+	
+	/* just skip past the type field */
+	len = get_8(buf);
+	if (len > 80) {
+		printk("\n" KERN_ERR "eisa_enumerator: type info field too long (%d, max is 80)\n", len);
+	}
+	
+	return 1+len;
+}
+
+static int configure_function(const unsigned char *buf, int *more) 
+{
+	/* the init field seems to be a two-byte field
+	 * which is non-zero if there are an other function following
+	 * I think it is the length of the function def 
+	 */
+	*more = get_16(buf);
+	
+	return 2;
+}
+
+static int parse_slot_config(int slot,
+			     const unsigned char *buf,
+			     struct eeprom_eisa_slot_info *es, 
+			     struct resource *io_parent,
+			     struct resource *mem_parent)
+{
+	int res=0;
+	int function_len;
+	unsigned int pos=0;
+	unsigned int maxlen;
+	int num_func=0;
+	u_int8_t flags;
+	int p0;
+	
+	char *board;
+	int id_string_used=0;
+	
+	if (NULL == (board = kmalloc(8, GFP_KERNEL))) {
+		return -1;
+	}
+	print_eisa_id(board, es->eisa_slot_id);
+	printk(KERN_INFO "EISA slot %d: %s %s ", 
+	       slot, board, es->flags&HPEE_FLAG_BOARD_IS_ISA ? "ISA" : "EISA");
+	
+	maxlen = es->config_data_length < HPEE_MAX_LENGTH ?
+			 es->config_data_length : HPEE_MAX_LENGTH;
+	while ((pos < maxlen) && (num_func <= es->num_functions)) {
+		pos+=configure_function(buf+pos, &function_len); 
+		
+		if (!function_len) {
+			break;
+		}
+		num_func++;
+		p0 = pos;
+		pos += configure_choise(buf+pos, &flags);
+
+		if (flags & HPEE_FUNCTION_INFO_F_DISABLED) {
+			/* function disabled, skip silently */
+			pos = p0 + function_len;
+			continue;
+		}
+		if (flags & HPEE_FUNCTION_INFO_CFG_FREE_FORM) {
+			/* I have no idea how to handle this */
+			printk("function %d have free-form confgiuration, skipping ",
+				num_func);
+			pos = p0 + function_len;
+			continue;
+		}
+
+		/* the ordering of the sections need
+		 * more investigation.
+		 * Currently I think that memory comaed before IRQ
+		 * I assume the order is LSB to MSB in the 
+		 * info flags 
+		 * eg type, memory, irq, dma, port, HPEE_PORT_init 
+		 */
+
+		if (flags & HPEE_FUNCTION_INFO_HAVE_TYPE) {
+			pos += configure_type_string(buf+pos);
+		}
+		
+		if (flags & HPEE_FUNCTION_INFO_HAVE_MEMORY) {
+			id_string_used=1;
+			pos += configure_memory(buf+pos, mem_parent, board);
+		} 
+		
+		if (flags & HPEE_FUNCTION_INFO_HAVE_IRQ) {
+			pos += configure_irq(buf+pos);
+		} 
+		
+		if (flags & HPEE_FUNCTION_INFO_HAVE_DMA) {
+			pos += configure_dma(buf+pos);
+		} 
+		
+		if (flags & HPEE_FUNCTION_INFO_HAVE_PORT) {
+			id_string_used=1;
+			pos += configure_port(buf+pos, io_parent, board);
+		} 
+		
+		if (flags &  HPEE_FUNCTION_INFO_HAVE_PORT_INIT) {
+			pos += configure_port_init(buf+pos);
+		}
+		
+		if (p0 + function_len < pos) {
+			printk("\n" KERN_ERR "eisa_enumerator: function %d length mis-match "
+			       "got %d, expected %d\n",
+			       num_func, pos-p0, function_len);
+			res=-1;
+			break;
+		}
+		pos = p0 + function_len;
+	}
+	printk("\n");
+	if (!id_string_used) {
+		kfree(board);
+	}
+	
+	if (pos != es->config_data_length) {
+		printk(KERN_ERR "eisa_enumerator: config data length mis-match got %d, expected %d\n",
+			pos, es->config_data_length);
+		res=-1;
+	}
+	
+	if (num_func != es->num_functions) {
+		printk(KERN_ERR "eisa_enumerator: number of functions mis-match got %d, expected %d\n",
+			num_func, es->num_functions);
+		res=-2;
+	}
+	
+	return res;
+	
+}
+
+static int init_slot(int slot, struct eeprom_eisa_slot_info *es)
+{
+	unsigned int id;
+	
+	char id_string[8];
+	
+	if (!(es->slot_info&HPEE_SLOT_INFO_NO_READID)) {
+		/* try to read the id of the board in the slot */
+		id = le32_to_cpu(inl(SLOT2PORT(slot)+EPI));
+		
+		if (0xffffffff == id) {
+			/* Maybe we didn't expect a card to be here... */
+			if (es->eisa_slot_id == 0xffffffff)
+				return -1;
+			
+			/* this board is not here or it does not 
+			 * support readid 
+			 */
+			printk(KERN_ERR "EISA slot %d a configured board was not detected (", 
+			       slot);
+			
+			print_eisa_id(id_string, es->eisa_slot_id);
+			printk(" expected %s)\n", id_string);
+		
+			return -1;	
+
+		}
+		if (es->eisa_slot_id != id) {
+			print_eisa_id(id_string, id);
+			printk(KERN_ERR "EISA slot %d id mis-match: got %s", 
+			       slot, id_string);
+			
+			print_eisa_id(id_string, es->eisa_slot_id);
+			printk(" expected %s \n", id_string);
+		
+			return -1;	
+			
+		}
+	}
+	
+	/* now: we need to enable the board if 
+	 * it supports enabling and run through
+	 * the port init sction if present
+	 * and finally record any interrupt polarity
+	 */
+	if (es->slot_features & HPEE_SLOT_FEATURES_ENABLE) {
+		/* enable board */
+		outb(0x01| inb(SLOT2PORT(slot)+EPI+4),
+		     SLOT2PORT(slot)+EPI+4);
+	}
+	
+	return 0;
+}
+
+
+int eisa_enumerator(unsigned long eeprom_addr,
+		    struct resource *io_parent, struct resource *mem_parent) 
+{
+	int i;
+	struct eeprom_header *eh;
+	static char eeprom_buf[HPEE_MAX_LENGTH];
+	
+	for (i=0; i < HPEE_MAX_LENGTH; i++) {
+		eeprom_buf[i] = gsc_readb(eeprom_addr+i);
+	}
+	
+	printk(KERN_INFO "Enumerating EISA bus\n");
+		    	
+	eh = (struct eeprom_header*)(eeprom_buf);
+	for (i=0;i<eh->num_slots;i++) {
+		struct eeprom_eisa_slot_info *es;
+		
+		es = (struct eeprom_eisa_slot_info*)
+			(&eeprom_buf[HPEE_SLOT_INFO(i)]);
+	        
+		if (-1==init_slot(i+1, es)) {
+			continue;
+		}
+		
+		if (es->config_data_offset < HPEE_MAX_LENGTH) {
+			if (parse_slot_config(i+1, &eeprom_buf[es->config_data_offset],
+					      es, io_parent, mem_parent)) {
+				return -1;
+			}
+		} else {
+			printk (KERN_WARNING "EISA EEPROM offset 0x%x out of range\n",es->config_data_offset);
+			return -1;
+		}
+	}
+	return eh->num_slots;
+}
+
