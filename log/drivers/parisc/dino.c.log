commit 4bdc0d676a643140bdf17dbf7eafedee3d496a3c
Author: Christoph Hellwig <hch@lst.de>
Date:   Mon Jan 6 09:43:50 2020 +0100

    remove ioremap_nocache and devm_ioremap_nocache
    
    ioremap has provided non-cached semantics by default since the Linux 2.6
    days, so remove the additional ioremap_nocache interface.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Acked-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/drivers/parisc/dino.c b/drivers/parisc/dino.c
index 2f1cac89ddf5..889d7ce282eb 100644
--- a/drivers/parisc/dino.c
+++ b/drivers/parisc/dino.c
@@ -974,7 +974,7 @@ static int __init dino_probe(struct parisc_device *dev)
 	}
 
 	dino_dev->hba.dev = dev;
-	dino_dev->hba.base_addr = ioremap_nocache(hpa, 4096);
+	dino_dev->hba.base_addr = ioremap(hpa, 4096);
 	dino_dev->hba.lmmio_space_offset = PCI_F_EXTEND;
 	spin_lock_init(&dino_dev->dinosaur_pen);
 	dino_dev->hba.iommu = ccio_get_iommu(dev);

commit 5fa1659105fac63e0f3c199b476025c2e04111ce
Author: Helge Deller <deller@gmx.de>
Date:   Thu Sep 5 16:44:17 2019 +0200

    parisc: Disable HP HSC-PCI Cards to prevent kernel crash
    
    The HP Dino PCI controller chip can be used in two variants: as on-board
    controller (e.g. in B160L), or on an Add-On card ("Card-Mode") to bridge
    PCI components to systems without a PCI bus, e.g. to a HSC/GSC bus.  One
    such Add-On card is the HP HSC-PCI Card which has one or more DEC Tulip
    PCI NIC chips connected to the on-card Dino PCI controller.
    
    Dino in Card-Mode has a big disadvantage: All PCI memory accesses need
    to go through the DINO_MEM_DATA register, so Linux drivers will not be
    able to use the ioremap() function. Without ioremap() many drivers will
    not work, one example is the tulip driver which then simply crashes the
    kernel if it tries to access the ports on the HP HSC card.
    
    This patch disables the HP HSC card if it finds one, and as such
    fixes the kernel crash on a HP D350/2 machine.
    
    Signed-off-by: Helge Deller <deller@gmx.de>
    Noticed-by: Phil Scarr <phil.scarr@pm.me>
    Cc: stable@vger.kernel.org

diff --git a/drivers/parisc/dino.c b/drivers/parisc/dino.c
index b04493d0e1fa..2f1cac89ddf5 100644
--- a/drivers/parisc/dino.c
+++ b/drivers/parisc/dino.c
@@ -156,6 +156,15 @@ static inline struct dino_device *DINO_DEV(struct pci_hba_data *hba)
 	return container_of(hba, struct dino_device, hba);
 }
 
+/* Check if PCI device is behind a Card-mode Dino. */
+static int pci_dev_is_behind_card_dino(struct pci_dev *dev)
+{
+	struct dino_device *dino_dev;
+
+	dino_dev = DINO_DEV(parisc_walk_tree(dev->bus->bridge));
+	return is_card_dino(&dino_dev->hba.dev->id);
+}
+
 /*
  * Dino Configuration Space Accessor Functions
  */
@@ -437,6 +446,21 @@ static void quirk_cirrus_cardbus(struct pci_dev *dev)
 }
 DECLARE_PCI_FIXUP_ENABLE(PCI_VENDOR_ID_CIRRUS, PCI_DEVICE_ID_CIRRUS_6832, quirk_cirrus_cardbus );
 
+#ifdef CONFIG_TULIP
+static void pci_fixup_tulip(struct pci_dev *dev)
+{
+	if (!pci_dev_is_behind_card_dino(dev))
+		return;
+	if (!(pci_resource_flags(dev, 1) & IORESOURCE_MEM))
+		return;
+	pr_warn("%s: HP HSC-PCI Cards with card-mode Dino not yet supported.\n",
+		pci_name(dev));
+	/* Disable this card by zeroing the PCI resources */
+	memset(&dev->resource[0], 0, sizeof(dev->resource[0]));
+	memset(&dev->resource[1], 0, sizeof(dev->resource[1]));
+}
+DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_DEC, PCI_ANY_ID, pci_fixup_tulip);
+#endif /* CONFIG_TULIP */
 
 static void __init
 dino_bios_init(void)

commit 544f448599134ffee9ef35d685f933bab708a215
Author: Helge Deller <deller@gmx.de>
Date:   Thu Sep 5 16:59:13 2019 +0200

    parisc: Save some bytes in dino driver
    
    Signed-off-by: Helge Deller <deller@gmx.de>

diff --git a/drivers/parisc/dino.c b/drivers/parisc/dino.c
index 3c730103e637..b04493d0e1fa 100644
--- a/drivers/parisc/dino.c
+++ b/drivers/parisc/dino.c
@@ -6,7 +6,7 @@
 **	(c) Copyright 1999 SuSE GmbH
 **	(c) Copyright 1999,2000 Hewlett-Packard Company
 **	(c) Copyright 2000 Grant Grundler
-**	(c) Copyright 2006 Helge Deller
+**	(c) Copyright 2006-2019 Helge Deller
 **
 **
 **	This module provides access to Dino PCI bus (config/IOport spaces)
@@ -863,14 +863,14 @@ static int __init dino_common_init(struct parisc_device *dev,
 #define CUJO_RAVEN_BADPAGE	0x01003000UL
 #define CUJO_FIREHAWK_BADPAGE	0x01607000UL
 
-static const char *dino_vers[] = {
+static const char dino_vers[][4] = {
 	"2.0",
 	"2.1",
 	"3.0",
 	"3.1"
 };
 
-static const char *cujo_vers[] = {
+static const char cujo_vers[][4] = {
 	"1.0",
 	"2.0"
 };

commit 2874c5fd284268364ece81a7bd936f3c8168e567
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:01 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 152
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 3029 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070032.746973796@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/parisc/dino.c b/drivers/parisc/dino.c
index 846b59d15999..3c730103e637 100644
--- a/drivers/parisc/dino.c
+++ b/drivers/parisc/dino.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
 **	DINO manager
 **
@@ -7,10 +8,6 @@
 **	(c) Copyright 2000 Grant Grundler
 **	(c) Copyright 2006 Helge Deller
 **
-**	This program is free software; you can redistribute it and/or modify
-**	it under the terms of the GNU General Public License as published by
-**      the Free Software Foundation; either version 2 of the License, or
-**      (at your option) any later version.
 **
 **	This module provides access to Dino PCI bus (config/IOport spaces)
 **	and helps manage Dino IRQ lines.

commit e2fcabe0ebe0b343b9de53ed0a7a7f2f86eb9863
Author: Christoph Hellwig <hch@lst.de>
Date:   Tue Jan 29 19:13:08 2019 +0100

    parisc/dino: use container_of in DINO_DEV
    
    Use the type safe container_of macros instead of a blind cast in
    DINO_DEV, and turn the macro into an inline function.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Helge Deller <deller@gmx.de>

diff --git a/drivers/parisc/dino.c b/drivers/parisc/dino.c
index 6f348c75687c..846b59d15999 100644
--- a/drivers/parisc/dino.c
+++ b/drivers/parisc/dino.c
@@ -154,12 +154,10 @@ struct dino_device
 #endif
 };
 
-/* Looks nice and keeps the compiler happy */
-#define DINO_DEV(d) ({				\
-	void *__pdata = d;			\
-	BUG_ON(!__pdata);			\
-	(struct dino_device *)__pdata; })
-
+static inline struct dino_device *DINO_DEV(struct pci_hba_data *hba)
+{
+	return container_of(hba, struct dino_device, hba);
+}
 
 /*
  * Dino Configuration Space Accessor Functions

commit 9b8eeab019762fa43c5ffa6e2f8e1039f8e99157
Author: Christoph Hellwig <hch@lst.de>
Date:   Tue Jan 29 19:13:04 2019 +0100

    parisc: move internal implementation details out of <asm/dma-mapping.h>
    
    Move everything that is not required for the public facing DMA API out
    of <asm/dma-mapping.h> and into a new drivers/parisc/iommu.h header.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Helge Deller <deller@gmx.de>

diff --git a/drivers/parisc/dino.c b/drivers/parisc/dino.c
index dfeea458a789..6f348c75687c 100644
--- a/drivers/parisc/dino.c
+++ b/drivers/parisc/dino.c
@@ -59,6 +59,7 @@
 #include <asm/hardware.h>
 
 #include "gsc.h"
+#include "iommu.h"
 
 #undef DINO_DEBUG
 

commit 2e37787df0ed0047848dba2eba53510a9185b991
Author: Helge Deller <deller@gmx.de>
Date:   Sun Oct 7 23:28:45 2018 +0200

    parisc: Ratelimit dino stuck interrupt warnings
    
    While playing with qemu with an emulated RT8139cp NIC, I faced lots of
    the following warnings:
    Dino 0x00810000: stuck interrupt 2
    
    This patch ratelimits this warning and reports back that the IRQ was
    handled.
    
    Signed-off-by: Helge Deller <deller@gmx.de>

diff --git a/drivers/parisc/dino.c b/drivers/parisc/dino.c
index ac646d42b300..dfeea458a789 100644
--- a/drivers/parisc/dino.c
+++ b/drivers/parisc/dino.c
@@ -396,9 +396,8 @@ static irqreturn_t dino_isr(int irq, void *intr_dev)
 	if (mask) {
 		if (--ilr_loop > 0)
 			goto ilr_again;
-		printk(KERN_ERR "Dino 0x%px: stuck interrupt %d\n",
+		pr_warn_ratelimited("Dino 0x%px: stuck interrupt %d\n",
 		       dino_dev->hba.base_addr, mask);
-		return IRQ_NONE;
 	}
 	return IRQ_HANDLED;
 }

commit 35d8be9c563c9b2d6550833ad494f90bffde7ff0
Author: Helge Deller <deller@gmx.de>
Date:   Sun Oct 7 22:59:13 2018 +0200

    parisc: dino: Utilize DINO_MASK_IRQ() macro
    
    Signed-off-by: Helge Deller <deller@gmx.de>

diff --git a/drivers/parisc/dino.c b/drivers/parisc/dino.c
index 7390fb8ca9d1..ac646d42b300 100644
--- a/drivers/parisc/dino.c
+++ b/drivers/parisc/dino.c
@@ -382,7 +382,7 @@ static irqreturn_t dino_isr(int irq, void *intr_dev)
 		DBG(KERN_DEBUG "%s(%d, %p) mask 0x%x\n",
 			__func__, irq, intr_dev, mask);
 		generic_handle_irq(irq);
-		mask &= ~(1 << local_irq);
+		mask &= ~DINO_MASK_IRQ(local_irq);
 	} while (mask);
 
 	/* Support for level triggered IRQ lines.

commit 04903c06b4854d2e85f6e3c368d5d48c4ce55f09
Author: Helge Deller <deller@gmx.de>
Date:   Tue Jan 2 20:45:42 2018 +0100

    parisc: Show unhashed HPA of Dino chip
    
    Fixes: ad67b74d2469d9b8 ("printk: hash addresses printed with %p")
    Signed-off-by: Helge Deller <deller@gmx.de>

diff --git a/drivers/parisc/dino.c b/drivers/parisc/dino.c
index 0b3fb99d9b89..7390fb8ca9d1 100644
--- a/drivers/parisc/dino.c
+++ b/drivers/parisc/dino.c
@@ -303,7 +303,7 @@ static void dino_mask_irq(struct irq_data *d)
 	struct dino_device *dino_dev = irq_data_get_irq_chip_data(d);
 	int local_irq = gsc_find_local_irq(d->irq, dino_dev->global_irq, DINO_LOCAL_IRQS);
 
-	DBG(KERN_WARNING "%s(0x%p, %d)\n", __func__, dino_dev, d->irq);
+	DBG(KERN_WARNING "%s(0x%px, %d)\n", __func__, dino_dev, d->irq);
 
 	/* Clear the matching bit in the IMR register */
 	dino_dev->imr &= ~(DINO_MASK_IRQ(local_irq));
@@ -316,7 +316,7 @@ static void dino_unmask_irq(struct irq_data *d)
 	int local_irq = gsc_find_local_irq(d->irq, dino_dev->global_irq, DINO_LOCAL_IRQS);
 	u32 tmp;
 
-	DBG(KERN_WARNING "%s(0x%p, %d)\n", __func__, dino_dev, d->irq);
+	DBG(KERN_WARNING "%s(0x%px, %d)\n", __func__, dino_dev, d->irq);
 
 	/*
 	** clear pending IRQ bits
@@ -396,7 +396,7 @@ static irqreturn_t dino_isr(int irq, void *intr_dev)
 	if (mask) {
 		if (--ilr_loop > 0)
 			goto ilr_again;
-		printk(KERN_ERR "Dino 0x%p: stuck interrupt %d\n", 
+		printk(KERN_ERR "Dino 0x%px: stuck interrupt %d\n",
 		       dino_dev->hba.base_addr, mask);
 		return IRQ_NONE;
 	}
@@ -553,7 +553,7 @@ dino_fixup_bus(struct pci_bus *bus)
         struct pci_dev *dev;
         struct dino_device *dino_dev = DINO_DEV(parisc_walk_tree(bus->bridge));
 
-	DBG(KERN_WARNING "%s(0x%p) bus %d platform_data 0x%p\n",
+	DBG(KERN_WARNING "%s(0x%px) bus %d platform_data 0x%px\n",
 	    __func__, bus, bus->busn_res.start,
 	    bus->bridge->platform_data);
 
@@ -854,7 +854,7 @@ static int __init dino_common_init(struct parisc_device *dev,
 	res->flags = IORESOURCE_IO; /* do not mark it busy ! */
 	if (request_resource(&ioport_resource, res) < 0) {
 		printk(KERN_ERR "%s: request I/O Port region failed "
-		       "0x%lx/%lx (hpa 0x%p)\n",
+		       "0x%lx/%lx (hpa 0x%px)\n",
 		       name, (unsigned long)res->start, (unsigned long)res->end,
 		       dino_dev->hba.base_addr);
 		return 1;

commit cfe4fbfb23b3280e9a4d1c3b8438c1558a6a614d
Author: Helge Deller <deller@gmx.de>
Date:   Mon Aug 21 22:02:19 2017 +0200

    parisc: Fix section mismatches in parisc core drivers
    
    Signed-off-by: Helge Deller <deller@gmx.de>

diff --git a/drivers/parisc/dino.c b/drivers/parisc/dino.c
index ed92c1254cff..0b3fb99d9b89 100644
--- a/drivers/parisc/dino.c
+++ b/drivers/parisc/dino.c
@@ -1022,7 +1022,7 @@ static int __init dino_probe(struct parisc_device *dev)
  * and 725 firmware misreport it as 0x08080 for no adequately explained
  * reason.
  */
-static struct parisc_device_id dino_tbl[] = {
+static const struct parisc_device_id dino_tbl[] __initconst = {
 	{ HPHW_A_DMA, HVERSION_REV_ANY_ID, 0x004, 0x0009D },/* Card-mode Dino */
 	{ HPHW_A_DMA, HVERSION_REV_ANY_ID, HVERSION_ANY_ID, 0x08080 }, /* XXX */
 	{ HPHW_BRIDGE, HVERSION_REV_ANY_ID, 0x680, 0xa }, /* Bridge-mode Dino */
@@ -1031,7 +1031,7 @@ static struct parisc_device_id dino_tbl[] = {
 	{ 0, }
 };
 
-static struct parisc_driver dino_driver = {
+static struct parisc_driver dino_driver __refdata = {
 	.name =		"dino",
 	.id_table =	dino_tbl,
 	.probe =	dino_probe,

commit 4098116039911e8870d84c975e2ec22dab65a909
Author: Thomas Bogendoerfer <tsbogend@alpha.franken.de>
Date:   Sat Aug 12 23:36:47 2017 +0200

    parisc: pci memory bar assignment fails with 64bit kernels on dino/cujo
    
    For 64bit kernels the lmmio_space_offset of the host bridge window
    isn't set correctly on systems with dino/cujo PCI host bridges.
    This leads to not assigned memory bars and failing drivers, which
    need to use these bars.
    
    Signed-off-by: Thomas Bogendoerfer <tsbogend@alpha.franken.de>
    Cc: <stable@vger.kernel.org>
    Acked-by: Helge Deller <deller@gmx.de>
    Signed-off-by: Helge Deller <deller@gmx.de>

diff --git a/drivers/parisc/dino.c b/drivers/parisc/dino.c
index 5c63b920b471..ed92c1254cff 100644
--- a/drivers/parisc/dino.c
+++ b/drivers/parisc/dino.c
@@ -956,7 +956,7 @@ static int __init dino_probe(struct parisc_device *dev)
 
 	dino_dev->hba.dev = dev;
 	dino_dev->hba.base_addr = ioremap_nocache(hpa, 4096);
-	dino_dev->hba.lmmio_space_offset = 0;	/* CPU addrs == bus addrs */
+	dino_dev->hba.lmmio_space_offset = PCI_F_EXTEND;
 	spin_lock_init(&dino_dev->dinosaur_pen);
 	dino_dev->hba.iommu = ccio_get_iommu(dev);
 

commit 33f9e02495d15a061f0c94ef46f5103a2d0c20f3
Author: Thomas Bogendoerfer <tsbogend@alpha.franken.de>
Date:   Mon Jul 3 10:38:05 2017 +0200

    parisc: DMA API: return error instead of BUG_ON for dma ops on non dma devs
    
    Enabling parport pc driver on a B2600 (and probably other 64bit PARISC
    systems) produced following BUG:
    
    CPU: 0 PID: 1 Comm: swapper Not tainted 4.12.0-rc5-30198-g1132d5e #156
    task: 000000009e050000 task.stack: 000000009e04c000
    
         YZrvWESTHLNXBCVMcbcbcbcbOGFRQPDI
    PSW: 00001000000001101111111100001111 Not tainted
    r00-03  000000ff0806ff0f 000000009e04c990 0000000040871b78 000000009e04cac0
    r04-07  0000000040c14de0 ffffffffffffffff 000000009e07f098 000000009d82d200
    r08-11  000000009d82d210 0000000000000378 0000000000000000 0000000040c345e0
    r12-15  0000000000000005 0000000040c345e0 0000000000000000 0000000040c9d5e0
    r16-19  0000000040c345e0 00000000f00001c4 00000000f00001bc 0000000000000061
    r20-23  000000009e04ce28 0000000000000010 0000000000000010 0000000040b89e40
    r24-27  0000000000000003 0000000000ffffff 000000009d82d210 0000000040c14de0
    r28-31  0000000000000000 000000009e04ca90 000000009e04cb40 0000000000000000
    sr00-03  0000000000000000 0000000000000000 0000000000000000 0000000000000000
    sr04-07  0000000000000000 0000000000000000 0000000000000000 0000000000000000
    
    IASQ: 0000000000000000 0000000000000000 IAOQ: 00000000404aece0 00000000404aece4
     IIR: 03ffe01f    ISR: 0000000010340000  IOR: 000001781304cac8
     CPU:        0   CR30: 000000009e04c000 CR31: 00000000e2976de2
     ORIG_R28: 0000000000000200
     IAOQ[0]: sba_dma_supported+0x80/0xd0
     IAOQ[1]: sba_dma_supported+0x84/0xd0
     RP(r2): parport_pc_probe_port+0x178/0x1200
    
    Cause is a call to dma_coerce_mask_and_coherenet in parport_pc_probe_port,
    which PARISC DMA API doesn't handle very nicely. This commit gives back
    DMA_ERROR_CODE for DMA API calls, if device isn't capable of DMA
    transaction.
    
    Cc: <stable@vger.kernel.org> # v3.13+
    Signed-off-by: Thomas Bogendoerfer <tsbogend@alpha.franken.de>
    Signed-off-by: Helge Deller <deller@gmx.de>

diff --git a/drivers/parisc/dino.c b/drivers/parisc/dino.c
index 1133b5cc88ca..5c63b920b471 100644
--- a/drivers/parisc/dino.c
+++ b/drivers/parisc/dino.c
@@ -154,7 +154,10 @@ struct dino_device
 };
 
 /* Looks nice and keeps the compiler happy */
-#define DINO_DEV(d) ((struct dino_device *) d)
+#define DINO_DEV(d) ({				\
+	void *__pdata = d;			\
+	BUG_ON(!__pdata);			\
+	(struct dino_device *)__pdata; })
 
 
 /*

commit 602c9c9a01a4f0ef091295ac75c74c7fe94d69a4
Author: Helge Deller <deller@gmx.de>
Date:   Mon Dec 21 10:00:49 2015 +0100

    parisc: Initialize PCI bridge cache line and default latency
    
    PCI controllers and pci-pci bridges may have not been fully initialized
    regarding cache line and defaul latency.
    
    This partly reverts
    commit 5f0e9b4 ("parisc: Remove unused pcibios_init_bus()")
    
    Signed-off-by: Helge Deller <deller@gmx.de>

diff --git a/drivers/parisc/dino.c b/drivers/parisc/dino.c
index a0580afe1713..1133b5cc88ca 100644
--- a/drivers/parisc/dino.c
+++ b/drivers/parisc/dino.c
@@ -599,8 +599,10 @@ dino_fixup_bus(struct pci_bus *bus)
 		** P2PB's only have 2 BARs, no IRQs.
 		** I'd like to just ignore them for now.
 		*/
-		if ((dev->class >> 8) == PCI_CLASS_BRIDGE_PCI)
+		if ((dev->class >> 8) == PCI_CLASS_BRIDGE_PCI)  {
+			pcibios_init_bridge(dev);
 			continue;
+		}
 
 		/* null out the ROM resource if there is one (we don't
 		 * care about an expansion rom on parisc, since it

commit 237865f195f6b10e4724ce49eeb3972641da882a
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Tue Sep 15 13:18:04 2015 -0500

    PCI: Revert "PCI: Call pci_read_bridge_bases() from core instead of arch code"
    
    Revert dff22d2054b5 ("PCI: Call pci_read_bridge_bases() from core instead
    of arch code").
    
    Reading PCI bridge windows is not arch-specific in itself, but there is PCI
    core code that doesn't work correctly if we read them too early.  For
    example, Hannes found this case on an ARM Freescale i.mx6 board:
    
      pci_bus 0000:00: root bus resource [mem 0x01000000-0x01efffff]
      pci 0000:00:00.0: PCI bridge to [bus 01-ff]
      pci 0000:00:00.0: BAR 8: no space for [mem size 0x01000000] (mem window)
      pci 0000:01:00.0: BAR 2: failed to assign [mem size 0x00200000]
      pci 0000:01:00.0: BAR 1: failed to assign [mem size 0x00004000]
      pci 0000:01:00.0: BAR 0: failed to assign [mem size 0x00000100]
    
    The 00:00.0 mem window needs to be at least 3MB: the 01:00.0 device needs
    0x204100 of space, and mem windows are megabyte-aligned.
    
    Bus sizing can increase a bridge window size, but never *decrease* it (see
    d65245c3297a ("PCI: don't shrink bridge resources")).  Prior to
    dff22d2054b5, ARM didn't read bridge windows at all, so the "original size"
    was zero, and we assigned a 3MB window.
    
    After dff22d2054b5, we read the bridge windows before sizing the bus.  The
    firmware programmed a 16MB window (size 0x01000000) in 00:00.0, and since
    we never decrease the size, we kept 16MB even though we only needed 3MB.
    But 16MB doesn't fit in the host bridge aperture, so we failed to assign
    space for the window and the downstream devices.
    
    I think this is a defect in the PCI core: we shouldn't rely on the firmware
    to assign sensible windows.
    
    Ray reported a similar problem, also on ARM, with Broadcom iProc.
    
    Issues like this are too hard to fix right now, so revert dff22d2054b5.
    
    Reported-by: Hannes <oe5hpm@gmail.com>
    Reported-by: Ray Jui <rjui@broadcom.com>
    Link: http://lkml.kernel.org/r/CAAa04yFQEUJm7Jj1qMT57-LG7ZGtnhNDBe=PpSRa70Mj+XhW-A@mail.gmail.com
    Link: http://lkml.kernel.org/r/55F75BB8.4070405@broadcom.com
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Yinghai Lu <yinghai@kernel.org>
    Acked-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>

diff --git a/drivers/parisc/dino.c b/drivers/parisc/dino.c
index baec33c4e698..a0580afe1713 100644
--- a/drivers/parisc/dino.c
+++ b/drivers/parisc/dino.c
@@ -560,6 +560,9 @@ dino_fixup_bus(struct pci_bus *bus)
 	} else if (bus->parent) {
 		int i;
 
+		pci_read_bridge_bases(bus);
+
+
 		for(i = PCI_BRIDGE_RESOURCES; i < PCI_NUM_RESOURCES; i++) {
 			if((bus->self->resource[i].flags & 
 			    (IORESOURCE_IO | IORESOURCE_MEM)) == 0)

commit dff22d2054b5dbb1889f20c03959dd0c494fab8c
Author: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
Date:   Thu Jul 9 11:59:16 2015 +0100

    PCI: Call pci_read_bridge_bases() from core instead of arch code
    
    When we scan a PCI bus, we read PCI-PCI bridge window registers with
    pci_read_bridge_bases() so we can validate the resource hierarchy.  Most
    architectures call pci_read_bridge_bases() from pcibios_fixup_bus(), but
    PCI-PCI bridges are not arch-specific, so this doesn't need to be in
    arch-specific code.
    
    Call pci_read_bridge_bases() directly from the PCI core instead of from
    arch code.
    
    For alpha and mips, we now call pci_read_bridge_bases() always; previously
    we only called it if PCI_PROBE_ONLY was set.
    
    [bhelgaas: changelog]
    Signed-off-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    CC: Ralf Baechle <ralf@linux-mips.org>
    CC: James E.J. Bottomley <jejb@parisc-linux.org>
    CC: Michael Ellerman <mpe@ellerman.id.au>
    CC: Bjorn Helgaas <bhelgaas@google.com>
    CC: Richard Henderson <rth@twiddle.net>
    CC: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    CC: David Howells <dhowells@redhat.com>
    CC: Russell King <linux@arm.linux.org.uk>
    CC: Tony Luck <tony.luck@intel.com>
    CC: David S. Miller <davem@davemloft.net>
    CC: Ingo Molnar <mingo@redhat.com>
    CC: Guenter Roeck <linux@roeck-us.net>
    CC: Michal Simek <monstr@monstr.eu>
    CC: Chris Zankel <chris@zankel.net>

diff --git a/drivers/parisc/dino.c b/drivers/parisc/dino.c
index a0580afe1713..baec33c4e698 100644
--- a/drivers/parisc/dino.c
+++ b/drivers/parisc/dino.c
@@ -560,9 +560,6 @@ dino_fixup_bus(struct pci_bus *bus)
 	} else if (bus->parent) {
 		int i;
 
-		pci_read_bridge_bases(bus);
-
-
 		for(i = PCI_BRIDGE_RESOURCES; i < PCI_NUM_RESOURCES; i++) {
 			if((bus->self->resource[i].flags & 
 			    (IORESOURCE_IO | IORESOURCE_MEM)) == 0)

commit 3335f75a8877ac50f27510cda1368108bca0f151
Author: Hans Wennborg <hans@hanshq.net>
Date:   Sun Aug 3 17:20:30 2014 -0700

    parisc: dino: fix %d confusingly prefixed with 0x in format string
    
    Signed-off-by: Hans Wennborg <hans@hanshq.net>
    Signed-off-by: Helge Deller <deller@gmx.de>

diff --git a/drivers/parisc/dino.c b/drivers/parisc/dino.c
index 9eae9834bcc7..a0580afe1713 100644
--- a/drivers/parisc/dino.c
+++ b/drivers/parisc/dino.c
@@ -913,7 +913,7 @@ static int __init dino_probe(struct parisc_device *dev)
 	printk("%s version %s found at 0x%lx\n", name, version, hpa);
 
 	if (!request_mem_region(hpa, PAGE_SIZE, name)) {
-		printk(KERN_ERR "DINO: Hey! Someone took my MMIO space (0x%ld)!\n",
+		printk(KERN_ERR "DINO: Hey! Someone took my MMIO space (0x%lx)!\n",
 			hpa);
 		return 1;
 	}

commit 3fad9b8d597f3a901fde947fc531886f685652c7
Author: Joe Perches <joe@perches.com>
Date:   Fri Nov 12 21:38:00 2010 +0000

    drivers/parisc: Use printf extension %pR for struct resource
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Helge Deller <deller@gmx.de>

diff --git a/drivers/parisc/dino.c b/drivers/parisc/dino.c
index 8e4e86b78428..9eae9834bcc7 100644
--- a/drivers/parisc/dino.c
+++ b/drivers/parisc/dino.c
@@ -580,15 +580,13 @@ dino_fixup_bus(struct pci_bus *bus)
 				
 			}
 					
-			DBG("DEBUG %s assigning %d [0x%lx,0x%lx]\n",
+			DBG("DEBUG %s assigning %d [%pR]\n",
 			    dev_name(&bus->self->dev), i,
-			    bus->self->resource[i].start,
-			    bus->self->resource[i].end);
+			    &bus->self->resource[i]);
 			WARN_ON(pci_assign_resource(bus->self, i));
-			DBG("DEBUG %s after assign %d [0x%lx,0x%lx]\n",
+			DBG("DEBUG %s after assign %d [%pR]\n",
 			    dev_name(&bus->self->dev), i,
-			    bus->self->resource[i].start,
-			    bus->self->resource[i].end);
+			    &bus->self->resource[i]);
 		}
 	}
 
@@ -772,8 +770,7 @@ dino_bridge_init(struct dino_device *dino_dev, const char *name)
 		result = ccio_request_resource(dino_dev->hba.dev, &res[i]);
 		if (result < 0) {
 			printk(KERN_ERR "%s: failed to claim PCI Bus address "
-			       "space %d (0x%lx-0x%lx)!\n", name, i,
-			       (unsigned long)res[i].start, (unsigned long)res[i].end);
+			       "space %d (%pR)!\n", name, i, &res[i]);
 			return result;
 		}
 	}

commit 0fe763c570ad2701c830b9e4e53c65ad89c11c32
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Dec 21 15:14:44 2012 -0800

    Drivers: misc: remove __dev* attributes.
    
    CONFIG_HOTPLUG is going away as an option.  As a result, the __dev*
    markings need to be removed.
    
    This change removes the use of __devinit, __devexit_p, __devinitdata,
    __devinitconst, and __devexit from these drivers.
    
    Based on patches originally written by Bill Pemberton, but redone by me
    in order to handle some of the coding style issues better, by hand.
    
    Cc: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/parisc/dino.c b/drivers/parisc/dino.c
index fb6a1fe21b93..8e4e86b78428 100644
--- a/drivers/parisc/dino.c
+++ b/drivers/parisc/dino.c
@@ -430,7 +430,7 @@ static void dino_choose_irq(struct parisc_device *dev, void *ctrl)
  * Cirrus 6832 Cardbus reports wrong irq on RDI Tadpole PARISC Laptop (deller@gmx.de)
  * (the irqs are off-by-one, not sure yet if this is a cirrus, dino-hardware or dino-driver problem...)
  */
-static void __devinit quirk_cirrus_cardbus(struct pci_dev *dev)
+static void quirk_cirrus_cardbus(struct pci_dev *dev)
 {
 	u8 new_irq = dev->irq - 1;
 	printk(KERN_INFO "PCI: Cirrus Cardbus IRQ fixup for %s, from %d to %d\n",

commit 0b79ca2a800d1a2ed0386886c8358217f3371592
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Thu Aug 16 16:45:02 2012 -0600

    parisc/PCI: Use list_for_each_entry() for bus->devices traversal
    
    Replace list_for_each() + pci_dev_b() with the simpler
    list_for_each_entry().
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Yinghai Lu <yinghai@kernel.org>
    CC: linux-parisc@vger.kernel.org

diff --git a/drivers/parisc/dino.c b/drivers/parisc/dino.c
index ffddc4f64268..fb6a1fe21b93 100644
--- a/drivers/parisc/dino.c
+++ b/drivers/parisc/dino.c
@@ -477,14 +477,12 @@ dino_card_setup(struct pci_bus *bus, void __iomem *base_addr)
 	if (ccio_allocate_resource(dino_dev->hba.dev, res, _8MB,
 				F_EXTEND(0xf0000000UL) | _8MB,
 				F_EXTEND(0xffffffffUL) &~ _8MB, _8MB) < 0) {
-		struct list_head *ln, *tmp_ln;
+		struct pci_dev *dev, *tmp;
 
 		printk(KERN_ERR "Dino: cannot attach bus %s\n",
 		       dev_name(bus->bridge));
 		/* kill the bus, we can't do anything with it */
-		list_for_each_safe(ln, tmp_ln, &bus->devices) {
-			struct pci_dev *dev = pci_dev_b(ln);
-
+		list_for_each_entry_safe(dev, tmp, &bus->devices, bus_list) {
 			list_del(&dev->bus_list);
 		}
 			
@@ -549,7 +547,6 @@ dino_card_fixup(struct pci_dev *dev)
 static void __init
 dino_fixup_bus(struct pci_bus *bus)
 {
-	struct list_head *ln;
         struct pci_dev *dev;
         struct dino_device *dino_dev = DINO_DEV(parisc_walk_tree(bus->bridge));
 
@@ -596,8 +593,7 @@ dino_fixup_bus(struct pci_bus *bus)
 	}
 
 
-	list_for_each(ln, &bus->devices) {
-		dev = pci_dev_b(ln);
+	list_for_each_entry(dev, &bus->devices, bus_list) {
 		if (is_card_dino(&dino_dev->hba.dev->id))
 			dino_card_fixup(dev);
 

commit 30aa80da43a5f23728eae1516e3a1aad40e808dd
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Thu May 17 18:51:12 2012 -0700

    parisc/PCI: register busn_res for root buses
    
    Add the host bridge bus number aperture to the resource list.
    Like the MMIO and I/O port apertures, this is used when assigning
    resources to hot-added devices or in the case of conflicts.
    
    [bhelgaas: changelog, set flags directly, at LBA bus_num init]
    CC: Kyle McMartin <kyle@mcmartin.ca>
    CC: Helge Deller <deller@gmx.de>
    CC: linux-parisc@vger.kernel.org
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/parisc/dino.c b/drivers/parisc/dino.c
index 70517b0f94e6..ffddc4f64268 100644
--- a/drivers/parisc/dino.c
+++ b/drivers/parisc/dino.c
@@ -898,6 +898,7 @@ static int __init dino_probe(struct parisc_device *dev)
 	LIST_HEAD(resources);
 	struct pci_bus *bus;
 	unsigned long hpa = dev->hpa.start;
+	int max;
 
 	name = "Dino";
 	if (is_card_dino(&dev->id)) {
@@ -983,6 +984,10 @@ static int __init dino_probe(struct parisc_device *dev)
 	if (dino_dev->hba.gmmio_space.flags)
 		pci_add_resource(&resources, &dino_dev->hba.gmmio_space);
 
+	dino_dev->hba.bus_num.start = dino_current_bus;
+	dino_dev->hba.bus_num.end = 255;
+	dino_dev->hba.bus_num.flags = IORESOURCE_BUS;
+	pci_add_resource(&resources, &dino_dev->hba.bus_num);
 	/*
 	** It's not used to avoid chicken/egg problems
 	** with configuration accessor functions.
@@ -998,12 +1003,13 @@ static int __init dino_probe(struct parisc_device *dev)
 		return 0;
 	}
 
-	bus->busn_res.end = pci_scan_child_bus(bus);
+	max = pci_scan_child_bus(bus);
+	pci_bus_update_busn_res_end(bus, max);
 
 	/* This code *depends* on scanning being single threaded
 	 * if it isn't, this global bus number count will fail
 	 */
-	dino_current_bus = bus->busn_res.end + 1;
+	dino_current_bus = max + 1;
 	pci_bus_assign_resources(bus);
 	pci_bus_add_devices(bus);
 	return 0;

commit b918c62e086b2130a7bae44110ca516ef10bfe5a
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Thu May 17 18:51:11 2012 -0700

    PCI: replace struct pci_bus secondary/subordinate with busn_res
    
    Replace the struct pci_bus secondary/subordinate members with the
    struct resource busn_res.  Later we'll build a resource tree of these
    bus numbers.
    
    [bhelgaas: changelog]
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/parisc/dino.c b/drivers/parisc/dino.c
index 432d4bbcc62a..70517b0f94e6 100644
--- a/drivers/parisc/dino.c
+++ b/drivers/parisc/dino.c
@@ -174,7 +174,7 @@ static int dino_cfg_read(struct pci_bus *bus, unsigned int devfn, int where,
 		int size, u32 *val)
 {
 	struct dino_device *d = DINO_DEV(parisc_walk_tree(bus->bridge));
-	u32 local_bus = (bus->parent == NULL) ? 0 : bus->secondary;
+	u32 local_bus = (bus->parent == NULL) ? 0 : bus->busn_res.start;
 	u32 v = DINO_CFG_TOK(local_bus, devfn, where & ~3);
 	void __iomem *base_addr = d->hba.base_addr;
 	unsigned long flags;
@@ -209,7 +209,7 @@ static int dino_cfg_write(struct pci_bus *bus, unsigned int devfn, int where,
 	int size, u32 val)
 {
 	struct dino_device *d = DINO_DEV(parisc_walk_tree(bus->bridge));
-	u32 local_bus = (bus->parent == NULL) ? 0 : bus->secondary;
+	u32 local_bus = (bus->parent == NULL) ? 0 : bus->busn_res.start;
 	u32 v = DINO_CFG_TOK(local_bus, devfn, where & ~3);
 	void __iomem *base_addr = d->hba.base_addr;
 	unsigned long flags;
@@ -554,7 +554,7 @@ dino_fixup_bus(struct pci_bus *bus)
         struct dino_device *dino_dev = DINO_DEV(parisc_walk_tree(bus->bridge));
 
 	DBG(KERN_WARNING "%s(0x%p) bus %d platform_data 0x%p\n",
-	    __func__, bus, bus->secondary,
+	    __func__, bus, bus->busn_res.start,
 	    bus->bridge->platform_data);
 
 	/* Firmware doesn't set up card-mode dino, so we have to */
@@ -998,12 +998,12 @@ static int __init dino_probe(struct parisc_device *dev)
 		return 0;
 	}
 
-	bus->subordinate = pci_scan_child_bus(bus);
+	bus->busn_res.end = pci_scan_child_bus(bus);
 
 	/* This code *depends* on scanning being single threaded
 	 * if it isn't, this global bus number count will fail
 	 */
-	dino_current_bus = bus->subordinate + 1;
+	dino_current_bus = bus->busn_res.end + 1;
 	pci_bus_assign_resources(bus);
 	pci_bus_add_devices(bus);
 	return 0;

commit 0195c00244dc2e9f522475868fa278c473ba7339
Merge: f21ce8f8447c 141124c02059
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Mar 28 15:58:21 2012 -0700

    Merge tag 'split-asm_system_h-for-linus-20120328' of git://git.kernel.org/pub/scm/linux/kernel/git/dhowells/linux-asm_system
    
    Pull "Disintegrate and delete asm/system.h" from David Howells:
     "Here are a bunch of patches to disintegrate asm/system.h into a set of
      separate bits to relieve the problem of circular inclusion
      dependencies.
    
      I've built all the working defconfigs from all the arches that I can
      and made sure that they don't break.
    
      The reason for these patches is that I recently encountered a circular
      dependency problem that came about when I produced some patches to
      optimise get_order() by rewriting it to use ilog2().
    
      This uses bitops - and on the SH arch asm/bitops.h drags in
      asm-generic/get_order.h by a circuituous route involving asm/system.h.
    
      The main difficulty seems to be asm/system.h.  It holds a number of
      low level bits with no/few dependencies that are commonly used (eg.
      memory barriers) and a number of bits with more dependencies that
      aren't used in many places (eg.  switch_to()).
    
      These patches break asm/system.h up into the following core pieces:
    
        (1) asm/barrier.h
    
            Move memory barriers here.  This already done for MIPS and Alpha.
    
        (2) asm/switch_to.h
    
            Move switch_to() and related stuff here.
    
        (3) asm/exec.h
    
            Move arch_align_stack() here.  Other process execution related bits
            could perhaps go here from asm/processor.h.
    
        (4) asm/cmpxchg.h
    
            Move xchg() and cmpxchg() here as they're full word atomic ops and
            frequently used by atomic_xchg() and atomic_cmpxchg().
    
        (5) asm/bug.h
    
            Move die() and related bits.
    
        (6) asm/auxvec.h
    
            Move AT_VECTOR_SIZE_ARCH here.
    
      Other arch headers are created as needed on a per-arch basis."
    
    Fixed up some conflicts from other header file cleanups and moving code
    around that has happened in the meantime, so David's testing is somewhat
    weakened by that.  We'll find out anything that got broken and fix it..
    
    * tag 'split-asm_system_h-for-linus-20120328' of git://git.kernel.org/pub/scm/linux/kernel/git/dhowells/linux-asm_system: (38 commits)
      Delete all instances of asm/system.h
      Remove all #inclusions of asm/system.h
      Add #includes needed to permit the removal of asm/system.h
      Move all declarations of free_initmem() to linux/mm.h
      Disintegrate asm/system.h for OpenRISC
      Split arch_align_stack() out from asm-generic/system.h
      Split the switch_to() wrapper out of asm-generic/system.h
      Move the asm-generic/system.h xchg() implementation to asm-generic/cmpxchg.h
      Create asm-generic/barrier.h
      Make asm-generic/cmpxchg.h #include asm-generic/cmpxchg-local.h
      Disintegrate asm/system.h for Xtensa
      Disintegrate asm/system.h for Unicore32 [based on ver #3, changed by gxt]
      Disintegrate asm/system.h for Tile
      Disintegrate asm/system.h for Sparc
      Disintegrate asm/system.h for SH
      Disintegrate asm/system.h for Score
      Disintegrate asm/system.h for S390
      Disintegrate asm/system.h for PowerPC
      Disintegrate asm/system.h for PA-RISC
      Disintegrate asm/system.h for MN10300
      ...

commit 9ffc93f203c18a70623f21950f1dd473c9ec48cd
Author: David Howells <dhowells@redhat.com>
Date:   Wed Mar 28 18:30:03 2012 +0100

    Remove all #inclusions of asm/system.h
    
    Remove all #inclusions of asm/system.h preparatory to splitting and killing
    it.  Performed with the following command:
    
    perl -p -i -e 's!^#\s*include\s*<asm/system[.]h>.*\n!!' `grep -Irl '^#\s*include\s*<asm/system[.]h>' *`
    
    Signed-off-by: David Howells <dhowells@redhat.com>

diff --git a/drivers/parisc/dino.c b/drivers/parisc/dino.c
index 7ff10c1e8664..9c5aae52a3b6 100644
--- a/drivers/parisc/dino.c
+++ b/drivers/parisc/dino.c
@@ -55,7 +55,6 @@
 
 #include <asm/pdc.h>
 #include <asm/page.h>
-#include <asm/system.h>
 #include <asm/io.h>
 #include <asm/hardware.h>
 

commit 39c2462e163448c7df466c7262109ec6a24d5f88
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Thu Feb 23 20:19:03 2012 -0700

    parisc/PCI: get rid of device resource fixups
    
    Tell the PCI core about host bridge address translation so it can take
    care of bus-to-resource conversion for us.
    
    CC: linux-parisc@vger.kernel.org
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/parisc/dino.c b/drivers/parisc/dino.c
index 7ff10c1e8664..0610e91bceb2 100644
--- a/drivers/parisc/dino.c
+++ b/drivers/parisc/dino.c
@@ -553,7 +553,6 @@ dino_fixup_bus(struct pci_bus *bus)
 	struct list_head *ln;
         struct pci_dev *dev;
         struct dino_device *dino_dev = DINO_DEV(parisc_walk_tree(bus->bridge));
-	int port_base = HBA_PORT_BASE(dino_dev->hba.hba_num);
 
 	DBG(KERN_WARNING "%s(0x%p) bus %d platform_data 0x%p\n",
 	    __func__, bus, bus->secondary,
@@ -599,8 +598,6 @@ dino_fixup_bus(struct pci_bus *bus)
 
 
 	list_for_each(ln, &bus->devices) {
-		int i;
-
 		dev = pci_dev_b(ln);
 		if (is_card_dino(&dino_dev->hba.dev->id))
 			dino_card_fixup(dev);
@@ -612,21 +609,6 @@ dino_fixup_bus(struct pci_bus *bus)
 		if ((dev->class >> 8) == PCI_CLASS_BRIDGE_PCI)
 			continue;
 
-		/* Adjust the I/O Port space addresses */
-		for (i = 0; i < PCI_NUM_RESOURCES; i++) {
-			struct resource *res = &dev->resource[i];
-			if (res->flags & IORESOURCE_IO) {
-				res->start |= port_base;
-				res->end |= port_base;
-			}
-#ifdef __LP64__
-			/* Sign Extend MMIO addresses */
-			else if (res->flags & IORESOURCE_MEM) {
-				res->start |= F_EXTEND(0UL);
-				res->end   |= F_EXTEND(0UL);
-			}
-#endif
-		}
 		/* null out the ROM resource if there is one (we don't
 		 * care about an expansion rom on parisc, since it
 		 * usually contains (x86) bios code) */
@@ -991,11 +973,14 @@ static int __init dino_probe(struct parisc_device *dev)
 
 	dev->dev.platform_data = dino_dev;
 
-	pci_add_resource(&resources, &dino_dev->hba.io_space);
+	pci_add_resource_offset(&resources, &dino_dev->hba.io_space,
+				HBA_PORT_BASE(dino_dev->hba.hba_num));
 	if (dino_dev->hba.lmmio_space.flags)
-		pci_add_resource(&resources, &dino_dev->hba.lmmio_space);
+		pci_add_resource_offset(&resources, &dino_dev->hba.lmmio_space,
+					dino_dev->hba.lmmio_space_offset);
 	if (dino_dev->hba.elmmio_space.flags)
-		pci_add_resource(&resources, &dino_dev->hba.elmmio_space);
+		pci_add_resource_offset(&resources, &dino_dev->hba.elmmio_space,
+					dino_dev->hba.lmmio_space_offset);
 	if (dino_dev->hba.gmmio_space.flags)
 		pci_add_resource(&resources, &dino_dev->hba.gmmio_space);
 

commit 7590e500ad83d9ac1e55eed4720e053eff14b8e5
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Oct 28 16:27:12 2011 -0600

    parisc/PCI: dino: convert to pci_create_root_bus() for correct root bus resources
    
    Supply root bus resources to pci_create_root_bus() so they're correct
    immediately.  This fixes the problem of "early" and "header" quirks seeing
    incorrect root bus resources.
    
    CC: linux-parisc@vger.kernel.org
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/parisc/dino.c b/drivers/parisc/dino.c
index 90252c016a08..7ff10c1e8664 100644
--- a/drivers/parisc/dino.c
+++ b/drivers/parisc/dino.c
@@ -562,19 +562,6 @@ dino_fixup_bus(struct pci_bus *bus)
 	/* Firmware doesn't set up card-mode dino, so we have to */
 	if (is_card_dino(&dino_dev->hba.dev->id)) {
 		dino_card_setup(bus, dino_dev->hba.base_addr);
-	} else if(bus->parent == NULL) {
-		/* must have a dino above it, reparent the resources
-		 * into the dino window */
-		int i;
-		struct resource *res = &dino_dev->hba.lmmio_space;
-
-		bus->resource[0] = &(dino_dev->hba.io_space);
-		for(i = 0; i < DINO_MAX_LMMIO_RESOURCES; i++) {
-			if(res[i].flags == 0)
-				break;
-			bus->resource[i+1] = &res[i];
-		}
-
 	} else if (bus->parent) {
 		int i;
 
@@ -927,6 +914,7 @@ static int __init dino_probe(struct parisc_device *dev)
 	const char *version = "unknown";
 	char *name;
 	int is_cujo = 0;
+	LIST_HEAD(resources);
 	struct pci_bus *bus;
 	unsigned long hpa = dev->hpa.start;
 
@@ -1003,15 +991,24 @@ static int __init dino_probe(struct parisc_device *dev)
 
 	dev->dev.platform_data = dino_dev;
 
+	pci_add_resource(&resources, &dino_dev->hba.io_space);
+	if (dino_dev->hba.lmmio_space.flags)
+		pci_add_resource(&resources, &dino_dev->hba.lmmio_space);
+	if (dino_dev->hba.elmmio_space.flags)
+		pci_add_resource(&resources, &dino_dev->hba.elmmio_space);
+	if (dino_dev->hba.gmmio_space.flags)
+		pci_add_resource(&resources, &dino_dev->hba.gmmio_space);
+
 	/*
 	** It's not used to avoid chicken/egg problems
 	** with configuration accessor functions.
 	*/
-	dino_dev->hba.hba_bus = bus = pci_create_bus(&dev->dev,
-			 dino_current_bus, &dino_cfg_ops, NULL);
+	dino_dev->hba.hba_bus = bus = pci_create_root_bus(&dev->dev,
+			 dino_current_bus, &dino_cfg_ops, NULL, &resources);
 	if (!bus) {
 		printk(KERN_ERR "ERROR: failed to scan PCI bus on %s (duplicate bus number %d?)\n",
 		       dev_name(&dev->dev), dino_current_bus);
+		pci_free_resource_list(&resources);
 		/* increment the bus number in case of duplicates */
 		dino_current_bus++;
 		return 0;

commit c4e06576282c5f91549b344fd0f516c421332b68
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Oct 28 16:27:07 2011 -0600

    parisc/PCI: dino: use pci_create_bus() instead of pci_scan_bus_parented()
    
    No functional change here; just converting from pci_scan_bus_parented()
    to pci_create_bus() to make a future patch simpler.
    
    CC: linux-parisc@vger.kernel.org
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/parisc/dino.c b/drivers/parisc/dino.c
index bcd5d54b7d4d..90252c016a08 100644
--- a/drivers/parisc/dino.c
+++ b/drivers/parisc/dino.c
@@ -1007,22 +1007,24 @@ static int __init dino_probe(struct parisc_device *dev)
 	** It's not used to avoid chicken/egg problems
 	** with configuration accessor functions.
 	*/
-	dino_dev->hba.hba_bus = bus = pci_scan_bus_parented(&dev->dev,
+	dino_dev->hba.hba_bus = bus = pci_create_bus(&dev->dev,
 			 dino_current_bus, &dino_cfg_ops, NULL);
-
-	if(bus) {
-		/* This code *depends* on scanning being single threaded
-		 * if it isn't, this global bus number count will fail
-		 */
-		dino_current_bus = bus->subordinate + 1;
-		pci_bus_assign_resources(bus);
-		pci_bus_add_devices(bus);
-	} else {
+	if (!bus) {
 		printk(KERN_ERR "ERROR: failed to scan PCI bus on %s (duplicate bus number %d?)\n",
 		       dev_name(&dev->dev), dino_current_bus);
 		/* increment the bus number in case of duplicates */
 		dino_current_bus++;
+		return 0;
 	}
+
+	bus->subordinate = pci_scan_child_bus(bus);
+
+	/* This code *depends* on scanning being single threaded
+	 * if it isn't, this global bus number count will fail
+	 */
+	dino_current_bus = bus->subordinate + 1;
+	pci_bus_assign_resources(bus);
+	pci_bus_add_devices(bus);
 	return 0;
 }
 

commit 4c4231ea2f794d73bbb50b8d84e00c66a012a607
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sun Feb 6 20:45:52 2011 +0000

    [PARISC] Convert to new irq_chip functions
    
    Convert all the parisc driver interrupt handlers (dino, eisa, gsc,
    iosapic and superio) as well as the cpu interrupts.  Prepare
    show_interrupts for GENERIC_HARDIRQS_NO_DEPRECATED and finally selects
    that Kconfig option
    
    [jejb: compile and testing fixes]
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/drivers/parisc/dino.c b/drivers/parisc/dino.c
index 9383063d2b16..bcd5d54b7d4d 100644
--- a/drivers/parisc/dino.c
+++ b/drivers/parisc/dino.c
@@ -296,25 +296,25 @@ static struct pci_port_ops dino_port_ops = {
 	.outl	= dino_out32
 };
 
-static void dino_mask_irq(unsigned int irq)
+static void dino_mask_irq(struct irq_data *d)
 {
-	struct dino_device *dino_dev = get_irq_chip_data(irq);
-	int local_irq = gsc_find_local_irq(irq, dino_dev->global_irq, DINO_LOCAL_IRQS);
+	struct dino_device *dino_dev = irq_data_get_irq_chip_data(d);
+	int local_irq = gsc_find_local_irq(d->irq, dino_dev->global_irq, DINO_LOCAL_IRQS);
 
-	DBG(KERN_WARNING "%s(0x%p, %d)\n", __func__, dino_dev, irq);
+	DBG(KERN_WARNING "%s(0x%p, %d)\n", __func__, dino_dev, d->irq);
 
 	/* Clear the matching bit in the IMR register */
 	dino_dev->imr &= ~(DINO_MASK_IRQ(local_irq));
 	__raw_writel(dino_dev->imr, dino_dev->hba.base_addr+DINO_IMR);
 }
 
-static void dino_unmask_irq(unsigned int irq)
+static void dino_unmask_irq(struct irq_data *d)
 {
-	struct dino_device *dino_dev = get_irq_chip_data(irq);
-	int local_irq = gsc_find_local_irq(irq, dino_dev->global_irq, DINO_LOCAL_IRQS);
+	struct dino_device *dino_dev = irq_data_get_irq_chip_data(d);
+	int local_irq = gsc_find_local_irq(d->irq, dino_dev->global_irq, DINO_LOCAL_IRQS);
 	u32 tmp;
 
-	DBG(KERN_WARNING "%s(0x%p, %d)\n", __func__, dino_dev, irq);
+	DBG(KERN_WARNING "%s(0x%p, %d)\n", __func__, dino_dev, d->irq);
 
 	/*
 	** clear pending IRQ bits
@@ -346,9 +346,9 @@ static void dino_unmask_irq(unsigned int irq)
 }
 
 static struct irq_chip dino_interrupt_type = {
-	.name	= "GSC-PCI",
-	.unmask	= dino_unmask_irq,
-	.mask	= dino_mask_irq,
+	.name		= "GSC-PCI",
+	.irq_unmask	= dino_unmask_irq,
+	.irq_mask	= dino_mask_irq,
 };
 
 

commit 51890613f2bfa70453a5cc22c91c63946dd311cd
Author: James Bottomley <James.Bottomley@HansenPartnership.com>
Date:   Fri Dec 3 02:01:05 2010 +0000

    parisc: convert the rest of the irq handlers to simple/percpu
    
    The generic conversion eliminates the spurious no_ack and no_end
    routines, converts all the cascaded handlers to handle_simple_irq() and
    makes iosapic use a modified handle_percpu_irq() to become the same as
    the CPU irq's.  This isn't an essential change, but it eliminates the
    mask/unmask overhead of handle_level_irq().
    
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>
    Tested-by: Helge Deller <deller@gmx.de>
    Signed-off-by: Kyle McMartin <kyle@mcmartin.ca>

diff --git a/drivers/parisc/dino.c b/drivers/parisc/dino.c
index d9f51485beee..9383063d2b16 100644
--- a/drivers/parisc/dino.c
+++ b/drivers/parisc/dino.c
@@ -349,7 +349,6 @@ static struct irq_chip dino_interrupt_type = {
 	.name	= "GSC-PCI",
 	.unmask	= dino_unmask_irq,
 	.mask	= dino_mask_irq,
-	.ack	= no_ack_irq,
 };
 
 

commit 7998b3bd156478c35de685f90d4d0dda57916c60
Author: Kyle McMartin <kyle@dreadnought.i.jkkm.org>
Date:   Thu Oct 14 00:58:53 2010 -0400

    parisc: convert gsc and dino pci interrupts to flow handlers
    
    Signed-off-by: Kyle McMartin <kyle@redhat.com>

diff --git a/drivers/parisc/dino.c b/drivers/parisc/dino.c
index 3013c57f1217..d9f51485beee 100644
--- a/drivers/parisc/dino.c
+++ b/drivers/parisc/dino.c
@@ -296,7 +296,7 @@ static struct pci_port_ops dino_port_ops = {
 	.outl	= dino_out32
 };
 
-static void dino_disable_irq(unsigned int irq)
+static void dino_mask_irq(unsigned int irq)
 {
 	struct dino_device *dino_dev = get_irq_chip_data(irq);
 	int local_irq = gsc_find_local_irq(irq, dino_dev->global_irq, DINO_LOCAL_IRQS);
@@ -308,7 +308,7 @@ static void dino_disable_irq(unsigned int irq)
 	__raw_writel(dino_dev->imr, dino_dev->hba.base_addr+DINO_IMR);
 }
 
-static void dino_enable_irq(unsigned int irq)
+static void dino_unmask_irq(unsigned int irq)
 {
 	struct dino_device *dino_dev = get_irq_chip_data(irq);
 	int local_irq = gsc_find_local_irq(irq, dino_dev->global_irq, DINO_LOCAL_IRQS);
@@ -345,20 +345,11 @@ static void dino_enable_irq(unsigned int irq)
 	}
 }
 
-static unsigned int dino_startup_irq(unsigned int irq)
-{
-	dino_enable_irq(irq);
-	return 0;
-}
-
 static struct irq_chip dino_interrupt_type = {
-	.name		= "GSC-PCI",
-	.startup	= dino_startup_irq,
-	.shutdown	= dino_disable_irq,
-	.enable		= dino_enable_irq, 
-	.disable	= dino_disable_irq,
-	.ack		= no_ack_irq,
-	.end		= no_end_irq,
+	.name	= "GSC-PCI",
+	.unmask	= dino_unmask_irq,
+	.mask	= dino_mask_irq,
+	.ack	= no_ack_irq,
 };
 
 

commit ba20085c20f1c9e8af546dea6ad0efa421bdef32
Author: Kyle McMartin <kyle@dreadnought.i.jkkm.org>
Date:   Wed Oct 13 21:00:55 2010 -0400

    parisc: lay groundwork for killing __do_IRQ
    
    Use proper accessors and handlers for generic irq cleanups. We just
    call back into __do_IRQ through desc->handler now, and remove the
    explicit calls.
    
    Signed-off-by: Kyle McMartin <kyle@redhat.com>

diff --git a/drivers/parisc/dino.c b/drivers/parisc/dino.c
index c542c7bb7454..3013c57f1217 100644
--- a/drivers/parisc/dino.c
+++ b/drivers/parisc/dino.c
@@ -298,8 +298,7 @@ static struct pci_port_ops dino_port_ops = {
 
 static void dino_disable_irq(unsigned int irq)
 {
-	struct irq_desc *desc = irq_to_desc(irq);
-	struct dino_device *dino_dev = desc->chip_data;
+	struct dino_device *dino_dev = get_irq_chip_data(irq);
 	int local_irq = gsc_find_local_irq(irq, dino_dev->global_irq, DINO_LOCAL_IRQS);
 
 	DBG(KERN_WARNING "%s(0x%p, %d)\n", __func__, dino_dev, irq);
@@ -311,8 +310,7 @@ static void dino_disable_irq(unsigned int irq)
 
 static void dino_enable_irq(unsigned int irq)
 {
-	struct irq_desc *desc = irq_to_desc(irq);
-	struct dino_device *dino_dev = desc->chip_data;
+	struct dino_device *dino_dev = get_irq_chip_data(irq);
 	int local_irq = gsc_find_local_irq(irq, dino_dev->global_irq, DINO_LOCAL_IRQS);
 	u32 tmp;
 
@@ -391,7 +389,7 @@ static irqreturn_t dino_isr(int irq, void *intr_dev)
 		int irq = dino_dev->global_irq[local_irq];
 		DBG(KERN_DEBUG "%s(%d, %p) mask 0x%x\n",
 			__func__, irq, intr_dev, mask);
-		__do_IRQ(irq);
+		generic_handle_irq(irq);
 		mask &= ~(1 << local_irq);
 	} while (mask);
 

commit d0608b54740c82b08056b7611e38a3fd73be3564
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Nov 17 22:50:59 2009 +0000

    parisc: Fixup last users of irq_chip->typename
    
    The typename member of struct irq_chip was kept for migration purposes
    and is obsolete since more than 2 years. Fix up the leftovers.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Kyle McMartin <kyle@mcmartin.ca>

diff --git a/drivers/parisc/dino.c b/drivers/parisc/dino.c
index d69bde6a2343..c542c7bb7454 100644
--- a/drivers/parisc/dino.c
+++ b/drivers/parisc/dino.c
@@ -354,7 +354,7 @@ static unsigned int dino_startup_irq(unsigned int irq)
 }
 
 static struct irq_chip dino_interrupt_type = {
-	.typename	= "GSC-PCI",
+	.name		= "GSC-PCI",
 	.startup	= dino_startup_irq,
 	.shutdown	= dino_disable_irq,
 	.enable		= dino_enable_irq, 

commit 1e0deabd35f210f22c03cc734a0335c07ae71ff3
Author: Helge Deller <deller@gmx.de>
Date:   Sun Aug 2 15:17:37 2009 +0200

    parisc: dino.c - check return value of pci_assign_resource()
    
    Signed-off-by: Helge Deller <deller@gmx.de>

diff --git a/drivers/parisc/dino.c b/drivers/parisc/dino.c
index c590974e9815..d69bde6a2343 100644
--- a/drivers/parisc/dino.c
+++ b/drivers/parisc/dino.c
@@ -614,7 +614,7 @@ dino_fixup_bus(struct pci_bus *bus)
 			    dev_name(&bus->self->dev), i,
 			    bus->self->resource[i].start,
 			    bus->self->resource[i].end);
-			pci_assign_resource(bus->self, i);
+			WARN_ON(pci_assign_resource(bus->self, i));
 			DBG("DEBUG %s after assign %d [0x%lx,0x%lx]\n",
 			    dev_name(&bus->self->dev), i,
 			    bus->self->resource[i].start,

commit dfe07565021959f0f646e9e775810c1bfbe0f6d6
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Jun 10 19:56:04 2009 +0000

    parisc: remove obsolete hw_interrupt_type
    
    The defines and typedefs (hw_interrupt_type, no_irq_type, irq_desc_t) have
    been kept around for migration reasons.  After more than two years it's
    time to remove them finally.
    
    This patch cleans up one of the remaining users.  When all such patches
    hit mainline we can remove the defines and typedefs finally.
    
    Impact: cleanup
    
    Convert the last remaining users to struct irq_chip and remove the
    define.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Kyle McMartin <kyle@mcmartin.ca>

diff --git a/drivers/parisc/dino.c b/drivers/parisc/dino.c
index d327c2dbf3e0..c590974e9815 100644
--- a/drivers/parisc/dino.c
+++ b/drivers/parisc/dino.c
@@ -353,7 +353,7 @@ static unsigned int dino_startup_irq(unsigned int irq)
 	return 0;
 }
 
-static struct hw_interrupt_type dino_interrupt_type = {
+static struct irq_chip dino_interrupt_type = {
 	.typename	= "GSC-PCI",
 	.startup	= dino_startup_irq,
 	.shutdown	= dino_disable_irq,

commit fed99b1e86f5ff4f1b41e37264bb869da67d3174
Author: Grant Grundler <grundler@parisc-linux.org>
Date:   Mon Apr 20 04:28:22 2009 +0000

    parisc: advertise PCI devs after "assign_resources"
    
    Alex Chiang asked me why PARISC was calling pci_bus_add_devices()
    and pci_bus_assign_resources() in the opposite order from everyone else.
    No reason and I couldn't see any data dependency.
    Patch below applies cleanly to 2.6.30-rc2.
    
    Later, I suspected the code worked only because no drivers would be
    loaded/ready until much later in the system initialization sequence.
    
    Tested "LBA" code on J6000 (32-bit) and A500 (64-bit SMP) with 2.6.30-rc2.
    Not tested with any Dino controllers.
    Not tested with PCI-PCI Bridge (TBD).
    
    Reported-by: Alex Chiang <achiang@hp.com>
    Signed-off-by: Grant Grundler <grundler@parisc-linux.org>
    Signed-off-by: Kyle McMartin <kyle@mcmartin.ca>

diff --git a/drivers/parisc/dino.c b/drivers/parisc/dino.c
index 52ae0b1d470c..d327c2dbf3e0 100644
--- a/drivers/parisc/dino.c
+++ b/drivers/parisc/dino.c
@@ -1019,22 +1019,22 @@ static int __init dino_probe(struct parisc_device *dev)
 	** It's not used to avoid chicken/egg problems
 	** with configuration accessor functions.
 	*/
-	bus = pci_scan_bus_parented(&dev->dev, dino_current_bus,
-				    &dino_cfg_ops, NULL);
+	dino_dev->hba.hba_bus = bus = pci_scan_bus_parented(&dev->dev,
+			 dino_current_bus, &dino_cfg_ops, NULL);
+
 	if(bus) {
-		pci_bus_add_devices(bus);
 		/* This code *depends* on scanning being single threaded
 		 * if it isn't, this global bus number count will fail
 		 */
 		dino_current_bus = bus->subordinate + 1;
 		pci_bus_assign_resources(bus);
+		pci_bus_add_devices(bus);
 	} else {
-		printk(KERN_ERR "ERROR: failed to scan PCI bus on %s (probably duplicate bus number %d)\n",
+		printk(KERN_ERR "ERROR: failed to scan PCI bus on %s (duplicate bus number %d?)\n",
 		       dev_name(&dev->dev), dino_current_bus);
 		/* increment the bus number in case of duplicates */
 		dino_current_bus++;
 	}
-	dino_dev->hba.hba_bus = bus;
 	return 0;
 }
 

commit c18b4608958ff42ce9a1a55b0a6f40b714f47286
Author: Alexander Beregalov <a.beregalov@gmail.com>
Date:   Thu Mar 19 10:54:07 2009 +0000

    parisc: drivers: fix warnings
    
    ccio-dma.c:456: warning: overflow in implicit constant conversion
    ccio-dma.c:459: warning: overflow in implicit constant conversion
    ccio-dma.c:1032: warning: unused variable 'j'
    ccio-dma.c:1031: warning: unused variable 'max'
    ccio-dma.c:1031: warning: unused variable 'min'
    ccio-dma.c:1031: warning: unused variable 'avg'
    ccio-dma.c:1403: warning: format '%08lx' expects type 'long unsigned int', but argument 3 has type 'resource_size_t'
    ccio-dma.c:1403: warning: format '%08lx' expects type 'long unsigned int', but argument 4 has type 'resource_size_t'
    ccio-dma.c:1554: warning: format '%lx' expects type 'long unsigned int', but argument 3 has type 'resource_size_t'
    dino.c:822: warning: format '%lx' expects type 'long unsigned int', but argument 4 has type 'resource_size_t'
    dino.c:822: warning: format '%lx' expects type 'long unsigned int', but argument 5 has type 'resource_size_t'
    dino.c:902: warning: format '%lx' expects type 'long unsigned int', but argument 3 has type 'resource_size_t'
    dino.c:902: warning: format '%lx' expects type 'long unsigned int', but argument 4 has type 'resource_size_t'
    asp.c:84: warning: format '%lx' expects type 'long unsigned int', but argument 4 has type 'resource_size_t'
    eisa.c:317: warning: format '%08lx' expects type 'long unsigned int', but argument 3 has type 'resource_size_t'
    eisa_enumerator.c:101: warning: format '%lx' expects type 'long unsigned int', but argument 2 has type 'resource_size_t'
    eisa_enumerator.c:101: warning: format '%lx' expects type 'long unsigned int', but argument 3 has type 'resource_size_t'
    eisa_enumerator.c:191: warning: format '%lx' expects type 'long unsigned int', but argument 2 has type 'resource_size_t'
    eisa_enumerator.c:191: warning: format '%lx' expects type 'long unsigned int', but argument 3 has type 'resource_size_t'
    
    Signed-off-by: Alexander Beregalov <a.beregalov@gmail.com>
    Signed-off-by: Kyle McMartin <kyle@mcmartin.ca>

diff --git a/drivers/parisc/dino.c b/drivers/parisc/dino.c
index bb5a1c9597cb..52ae0b1d470c 100644
--- a/drivers/parisc/dino.c
+++ b/drivers/parisc/dino.c
@@ -819,7 +819,9 @@ dino_bridge_init(struct dino_device *dino_dev, const char *name)
 
 		result = ccio_request_resource(dino_dev->hba.dev, &res[i]);
 		if (result < 0) {
-			printk(KERN_ERR "%s: failed to claim PCI Bus address space %d (0x%lx-0x%lx)!\n", name, i, res[i].start, res[i].end);
+			printk(KERN_ERR "%s: failed to claim PCI Bus address "
+			       "space %d (0x%lx-0x%lx)!\n", name, i,
+			       (unsigned long)res[i].start, (unsigned long)res[i].end);
 			return result;
 		}
 	}
@@ -899,7 +901,8 @@ static int __init dino_common_init(struct parisc_device *dev,
 	if (request_resource(&ioport_resource, res) < 0) {
 		printk(KERN_ERR "%s: request I/O Port region failed "
 		       "0x%lx/%lx (hpa 0x%p)\n",
-		       name, res->start, res->end, dino_dev->hba.base_addr);
+		       name, (unsigned long)res->start, (unsigned long)res->end,
+		       dino_dev->hba.base_addr);
 		return 1;
 	}
 

commit d4995244bd4c02eb7bea3c63aee81a2f2b64910e
Author: Kay Sievers <kay.sievers@vrfy.org>
Date:   Mon Jan 26 03:53:16 2009 +0000

    parisc: dino: struct device - replace bus_id with dev_name(), dev_set_name()
    
    Acked-by: Greg Kroah-Hartman <gregkh@suse.de>
    Signed-off-by: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Kyle McMartin <kyle@mcmartin.ca>

diff --git a/drivers/parisc/dino.c b/drivers/parisc/dino.c
index f79266cd00e5..bb5a1c9597cb 100644
--- a/drivers/parisc/dino.c
+++ b/drivers/parisc/dino.c
@@ -479,7 +479,7 @@ dino_card_setup(struct pci_bus *bus, void __iomem *base_addr)
 	res = &dino_dev->hba.lmmio_space;
 	res->flags = IORESOURCE_MEM;
 	size = scnprintf(name, sizeof(name), "Dino LMMIO (%s)", 
-			 bus->bridge->bus_id);
+			 dev_name(bus->bridge));
 	res->name = kmalloc(size+1, GFP_KERNEL);
 	if(res->name)
 		strcpy((char *)res->name, name);
@@ -493,7 +493,7 @@ dino_card_setup(struct pci_bus *bus, void __iomem *base_addr)
 		struct list_head *ln, *tmp_ln;
 
 		printk(KERN_ERR "Dino: cannot attach bus %s\n",
-		       bus->bridge->bus_id);
+		       dev_name(bus->bridge));
 		/* kill the bus, we can't do anything with it */
 		list_for_each_safe(ln, tmp_ln, &bus->devices) {
 			struct pci_dev *dev = pci_dev_b(ln);
@@ -611,12 +611,12 @@ dino_fixup_bus(struct pci_bus *bus)
 			}
 					
 			DBG("DEBUG %s assigning %d [0x%lx,0x%lx]\n",
-			    bus->self->dev.bus_id, i,
+			    dev_name(&bus->self->dev), i,
 			    bus->self->resource[i].start,
 			    bus->self->resource[i].end);
 			pci_assign_resource(bus->self, i);
 			DBG("DEBUG %s after assign %d [0x%lx,0x%lx]\n",
-			    bus->self->dev.bus_id, i,
+			    dev_name(&bus->self->dev), i,
 			    bus->self->resource[i].start,
 			    bus->self->resource[i].end);
 		}
@@ -1026,7 +1026,8 @@ static int __init dino_probe(struct parisc_device *dev)
 		dino_current_bus = bus->subordinate + 1;
 		pci_bus_assign_resources(bus);
 	} else {
-		printk(KERN_ERR "ERROR: failed to scan PCI bus on %s (probably duplicate bus number %d)\n", dev->dev.bus_id, dino_current_bus);
+		printk(KERN_ERR "ERROR: failed to scan PCI bus on %s (probably duplicate bus number %d)\n",
+		       dev_name(&dev->dev), dino_current_bus);
 		/* increment the bus number in case of duplicates */
 		dino_current_bus++;
 	}

commit 9785d646c10b0707412516ffe56b71b9eb18861f
Author: Grant Grundler <grundler@parisc-linux.org>
Date:   Wed Jan 28 22:30:55 2009 -0700

    parisc: fix wrong assumption about bus->self
    
    Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com> posted a patch series
    to linux-pci to fix a wrong assumption about pci_bus->self==NULL for
    all PCI host bus controllers. While PARISC platforms to not behave
    this way, I prefer to have the code consistent across architectures.
    The following patch replaces pci_bus->self with pci_bus->parent when
    used as a test to check for "root bus controller".
    
    Signed-off-by: Grant Grundler <grundler@parisc-linux.org>
    Signed-off-by: Kyle McMartin <kyle@mcmartin.ca>

diff --git a/drivers/parisc/dino.c b/drivers/parisc/dino.c
index d539d9df88e7..f79266cd00e5 100644
--- a/drivers/parisc/dino.c
+++ b/drivers/parisc/dino.c
@@ -587,7 +587,7 @@ dino_fixup_bus(struct pci_bus *bus)
 			bus->resource[i+1] = &res[i];
 		}
 
-	} else if(bus->self) {
+	} else if (bus->parent) {
 		int i;
 
 		pci_read_bridge_bases(bus);

commit 29a41e9e029d21c306e3ad6e723700348b04706a
Merge: d9e8a3a5b829 ae16489eb117
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Jan 9 11:53:07 2009 -0800

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/kyle/parisc-2.6
    
    * git://git.kernel.org/pub/scm/linux/kernel/git/kyle/parisc-2.6:
      parisc: export length of os_hpmc vector
      parisc: fix kernel crash (protection id trap) when compiling ruby1.9
      parisc: Use DEFINE_SPINLOCK
      parisc: add uevent helper for parisc bus
      parisc: fix ipv6 checksum
      parisc: quiet palo not-found message from "which"
      parisc: Replace NR_CPUS in parisc code
      parisc: trivial fixes
      parisc: fix braino in commit adding __space_to_prot
      parisc: factor out sid to protid conversion
      parisc: use leX_to_cpu in place of __fswabX
      parisc: fix GFP_KERNEL use while atomic in unwinder
      parisc: remove dead BIO_VMERGE_BOUNDARY and BIO_VMERGE_MAX_SIZE definitions
      parisc: set_time() catch errors
      parisc: use the new byteorder headers
      parisc: drivers/parisc/: make code static
      parisc: lib/: make code static

commit f0e88af855cbc5012f2e796f42686969b82d79d4
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Tue Dec 9 16:12:22 2008 -0700

    PCI: parisc: use generic pci_swizzle_interrupt_pin()
    
    Use the generic pci_swizzle_interrupt_pin() instead of arch-specific code.
    
    Acked-by: Kyle McMartin <kyle@infradead.org>
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/parisc/dino.c b/drivers/parisc/dino.c
index 3bc54b30c3a1..77cc8bfef8c9 100644
--- a/drivers/parisc/dino.c
+++ b/drivers/parisc/dino.c
@@ -547,7 +547,7 @@ dino_card_fixup(struct pci_dev *dev)
 	** The additional "-1" adjusts for skewing the IRQ<->slot.
 	*/
 	dino_cfg_read(dev->bus, dev->devfn, PCI_INTERRUPT_PIN, 1, &irq_pin); 
-	dev->irq = (irq_pin + PCI_SLOT(dev->devfn) - 1) % 4 ;
+	dev->irq = pci_swizzle_interrupt_pin(dev, irq_pin) - 1;
 
 	/* Shouldn't really need to do this but it's in case someone tries
 	** to bypass PCI services and look at the card themselves.
@@ -672,7 +672,7 @@ dino_fixup_bus(struct pci_bus *bus)
 			
 			dino_cfg_read(dev->bus, dev->devfn, 
 				      PCI_INTERRUPT_PIN, 1, &irq_pin);
-			irq_pin = (irq_pin + PCI_SLOT(dev->devfn) - 1) % 4 ;
+			irq_pin = pci_swizzle_interrupt_pin(dev, irq_pin) - 1;
 			printk(KERN_WARNING "Device %s has undefined IRQ, "
 					"setting to %d\n", pci_name(dev), irq_pin);
 			dino_cfg_write(dev->bus, dev->devfn, 

commit df8e5bc6b7b61c8b2aeaf58b6afd762d20a651dd
Author: Adrian Bunk <bunk@kernel.org>
Date:   Tue Dec 2 03:28:16 2008 +0000

    parisc: drivers/parisc/: make code static
    
    Make the following needlessly global code static:
    
    - asp.c: asp_init_chip()
    - ccio-dma.c: ccio_io_pdir_entry()
    - dino.c: struct dino_port_ops
    - dino.c: struct dino_bios_ops
    - hppb.c: struct hppb_card_head
    - lasi.c: lasi_led_init()
    - lasi.c: lasi_init_chip()
    - lba_pci.c: struct lba_bios_ops
    - sba_iommu.c: sba_io_pdir_entry()
    - sba_iommu.c: sba_driver_callback()
    - sba_iommu.c: sba_driver_callback()
    - wax.c: wax_init_chip()
    
    Signed-off-by: Adrian Bunk <bunk@kernel.org>
    Cc: Matthew Wilcox <matthew@wil.cx>
    Cc: Grant Grundler <grundler@parisc-linux.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Kyle McMartin <kyle@mcmartin.ca>

diff --git a/drivers/parisc/dino.c b/drivers/parisc/dino.c
index 3bc54b30c3a1..c5a44ff1f32f 100644
--- a/drivers/parisc/dino.c
+++ b/drivers/parisc/dino.c
@@ -287,7 +287,7 @@ DINO_PORT_OUT(b,  8, 3)
 DINO_PORT_OUT(w, 16, 2)
 DINO_PORT_OUT(l, 32, 0)
 
-struct pci_port_ops dino_port_ops = {
+static struct pci_port_ops dino_port_ops = {
 	.inb	= dino_in8,
 	.inw	= dino_in16,
 	.inl	= dino_in32,
@@ -690,7 +690,7 @@ dino_fixup_bus(struct pci_bus *bus)
 }
 
 
-struct pci_bios_ops dino_bios_ops = {
+static struct pci_bios_ops dino_bios_ops = {
 	.init		= dino_bios_init,
 	.fixup_bus	= dino_fixup_bus
 };

commit 08678b0841267c1d00d771fe01548d86043d065e
Author: Yinghai Lu <yhlu.kernel@gmail.com>
Date:   Tue Aug 19 20:50:05 2008 -0700

    generic: sparse irqs: use irq_desc() together with dyn_array, instead of irq_desc[]
    
    add CONFIG_HAVE_SPARSE_IRQ to for use condensed array.
    Get rid of irq_desc[] array assumptions.
    
    Preallocate 32 irq_desc, and irq_desc() will try to get more.
    
    ( No change in functionality is expected anywhere, except the odd build
      failure where we missed a code site or where a crossing commit itroduces
      new irq_desc[] usage. )
    
    v2: according to Eric, change get_irq_desc() to irq_desc()
    
    Signed-off-by: Yinghai Lu <yhlu.kernel@gmail.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/drivers/parisc/dino.c b/drivers/parisc/dino.c
index fd56128525d1..3bc54b30c3a1 100644
--- a/drivers/parisc/dino.c
+++ b/drivers/parisc/dino.c
@@ -298,7 +298,8 @@ struct pci_port_ops dino_port_ops = {
 
 static void dino_disable_irq(unsigned int irq)
 {
-	struct dino_device *dino_dev = irq_desc[irq].chip_data;
+	struct irq_desc *desc = irq_to_desc(irq);
+	struct dino_device *dino_dev = desc->chip_data;
 	int local_irq = gsc_find_local_irq(irq, dino_dev->global_irq, DINO_LOCAL_IRQS);
 
 	DBG(KERN_WARNING "%s(0x%p, %d)\n", __func__, dino_dev, irq);
@@ -310,7 +311,8 @@ static void dino_disable_irq(unsigned int irq)
 
 static void dino_enable_irq(unsigned int irq)
 {
-	struct dino_device *dino_dev = irq_desc[irq].chip_data;
+	struct irq_desc *desc = irq_to_desc(irq);
+	struct dino_device *dino_dev = desc->chip_data;
 	int local_irq = gsc_find_local_irq(irq, dino_dev->global_irq, DINO_LOCAL_IRQS);
 	u32 tmp;
 

commit a8043ecb17bd2e4b034006bee315efeea3936278
Author: Harvey Harrison <harvey.harrison@gmail.com>
Date:   Wed May 14 16:21:56 2008 -0700

    drivers/parisc: replace remaining __FUNCTION__ occurrences
    
    __FUNCTION__ is gcc-specific, use __func__
    
    Signed-off-by: Harvey Harrison <harvey.harrison@gmail.com>
    Cc: Kyle McMartin <kyle@mcmartin.ca>
    Cc: Matthew Wilcox <willy@debian.org>
    Cc: Grant Grundler <grundler@parisc-linux.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Kyle McMartin <kyle@mcmartin.ca>

diff --git a/drivers/parisc/dino.c b/drivers/parisc/dino.c
index d9c6322a721b..fd56128525d1 100644
--- a/drivers/parisc/dino.c
+++ b/drivers/parisc/dino.c
@@ -180,7 +180,7 @@ static int dino_cfg_read(struct pci_bus *bus, unsigned int devfn, int where,
 	void __iomem *base_addr = d->hba.base_addr;
 	unsigned long flags;
 
-	DBG("%s: %p, %d, %d, %d\n", __FUNCTION__, base_addr, devfn, where,
+	DBG("%s: %p, %d, %d, %d\n", __func__, base_addr, devfn, where,
 									size);
 	spin_lock_irqsave(&d->dinosaur_pen, flags);
 
@@ -215,7 +215,7 @@ static int dino_cfg_write(struct pci_bus *bus, unsigned int devfn, int where,
 	void __iomem *base_addr = d->hba.base_addr;
 	unsigned long flags;
 
-	DBG("%s: %p, %d, %d, %d\n", __FUNCTION__, base_addr, devfn, where,
+	DBG("%s: %p, %d, %d, %d\n", __func__, base_addr, devfn, where,
 									size);
 	spin_lock_irqsave(&d->dinosaur_pen, flags);
 
@@ -301,7 +301,7 @@ static void dino_disable_irq(unsigned int irq)
 	struct dino_device *dino_dev = irq_desc[irq].chip_data;
 	int local_irq = gsc_find_local_irq(irq, dino_dev->global_irq, DINO_LOCAL_IRQS);
 
-	DBG(KERN_WARNING "%s(0x%p, %d)\n", __FUNCTION__, dino_dev, irq);
+	DBG(KERN_WARNING "%s(0x%p, %d)\n", __func__, dino_dev, irq);
 
 	/* Clear the matching bit in the IMR register */
 	dino_dev->imr &= ~(DINO_MASK_IRQ(local_irq));
@@ -314,7 +314,7 @@ static void dino_enable_irq(unsigned int irq)
 	int local_irq = gsc_find_local_irq(irq, dino_dev->global_irq, DINO_LOCAL_IRQS);
 	u32 tmp;
 
-	DBG(KERN_WARNING "%s(0x%p, %d)\n", __FUNCTION__, dino_dev, irq);
+	DBG(KERN_WARNING "%s(0x%p, %d)\n", __func__, dino_dev, irq);
 
 	/*
 	** clear pending IRQ bits
@@ -340,7 +340,7 @@ static void dino_enable_irq(unsigned int irq)
 	tmp = __raw_readl(dino_dev->hba.base_addr+DINO_ILR);
 	if (tmp & DINO_MASK_IRQ(local_irq)) {
 		DBG(KERN_WARNING "%s(): IRQ asserted! (ILR 0x%x)\n",
-				__FUNCTION__, tmp);
+				__func__, tmp);
 		gsc_writel(dino_dev->txn_data, dino_dev->txn_addr);
 	}
 }
@@ -388,7 +388,7 @@ static irqreturn_t dino_isr(int irq, void *intr_dev)
 		int local_irq = __ffs(mask);
 		int irq = dino_dev->global_irq[local_irq];
 		DBG(KERN_DEBUG "%s(%d, %p) mask 0x%x\n",
-			__FUNCTION__, irq, intr_dev, mask);
+			__func__, irq, intr_dev, mask);
 		__do_IRQ(irq);
 		mask &= ~(1 << local_irq);
 	} while (mask);
@@ -566,7 +566,7 @@ dino_fixup_bus(struct pci_bus *bus)
 	int port_base = HBA_PORT_BASE(dino_dev->hba.hba_num);
 
 	DBG(KERN_WARNING "%s(0x%p) bus %d platform_data 0x%p\n",
-	    __FUNCTION__, bus, bus->secondary, 
+	    __func__, bus, bus->secondary,
 	    bus->bridge->platform_data);
 
 	/* Firmware doesn't set up card-mode dino, so we have to */

commit c71c68a04ba7672b9373ef04173114c211bb9f88
Author: James Bottomley <James.Bottomley@HansenPartnership.com>
Date:   Wed Feb 20 15:14:24 2008 -0600

    PCI: remove parisc consumer of the pci global_list
    
    Remove the parisc usage of the global_list, as it's not needed anymore.
    
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/parisc/dino.c b/drivers/parisc/dino.c
index 03c763c2d0e0..d9c6322a721b 100644
--- a/drivers/parisc/dino.c
+++ b/drivers/parisc/dino.c
@@ -496,7 +496,6 @@ dino_card_setup(struct pci_bus *bus, void __iomem *base_addr)
 		list_for_each_safe(ln, tmp_ln, &bus->devices) {
 			struct pci_dev *dev = pci_dev_b(ln);
 
-			list_del(&dev->global_list);
 			list_del(&dev->bus_list);
 		}
 			

commit be577a5220b25e0a6e3fbf96bbfc8b31d63e9ea9
Author: Matthew Wilcox <matthew@wil.cx>
Date:   Fri Oct 6 20:47:23 2006 -0600

    Build fixes for struct pt_regs removal
    
    Signed-off-by: Matthew Wilcox <matthew@wil.cx>

diff --git a/drivers/parisc/dino.c b/drivers/parisc/dino.c
index a0a8fd8d2124..03c763c2d0e0 100644
--- a/drivers/parisc/dino.c
+++ b/drivers/parisc/dino.c
@@ -389,7 +389,7 @@ static irqreturn_t dino_isr(int irq, void *intr_dev)
 		int irq = dino_dev->global_irq[local_irq];
 		DBG(KERN_DEBUG "%s(%d, %p) mask 0x%x\n",
 			__FUNCTION__, irq, intr_dev, mask);
-		__do_IRQ(irq, regs);
+		__do_IRQ(irq);
 		mask &= ~(1 << local_irq);
 	} while (mask);
 

commit 7d12e780e003f93433d49ce78cfedf4b4c52adc5
Author: David Howells <dhowells@redhat.com>
Date:   Thu Oct 5 14:55:46 2006 +0100

    IRQ: Maintain regs pointer globally rather than passing to IRQ handlers
    
    Maintain a per-CPU global "struct pt_regs *" variable which can be used instead
    of passing regs around manually through all ~1800 interrupt handlers in the
    Linux kernel.
    
    The regs pointer is used in few places, but it potentially costs both stack
    space and code to pass it around.  On the FRV arch, removing the regs parameter
    from all the genirq function results in a 20% speed up of the IRQ exit path
    (ie: from leaving timer_interrupt() to leaving do_IRQ()).
    
    Where appropriate, an arch may override the generic storage facility and do
    something different with the variable.  On FRV, for instance, the address is
    maintained in GR28 at all times inside the kernel as part of general exception
    handling.
    
    Having looked over the code, it appears that the parameter may be handed down
    through up to twenty or so layers of functions.  Consider a USB character
    device attached to a USB hub, attached to a USB controller that posts its
    interrupts through a cascaded auxiliary interrupt controller.  A character
    device driver may want to pass regs to the sysrq handler through the input
    layer which adds another few layers of parameter passing.
    
    I've build this code with allyesconfig for x86_64 and i386.  I've runtested the
    main part of the code on FRV and i386, though I can't test most of the drivers.
    I've also done partial conversion for powerpc and MIPS - these at least compile
    with minimal configurations.
    
    This will affect all archs.  Mostly the changes should be relatively easy.
    Take do_IRQ(), store the regs pointer at the beginning, saving the old one:
    
            struct pt_regs *old_regs = set_irq_regs(regs);
    
    And put the old one back at the end:
    
            set_irq_regs(old_regs);
    
    Don't pass regs through to generic_handle_irq() or __do_IRQ().
    
    In timer_interrupt(), this sort of change will be necessary:
    
            -       update_process_times(user_mode(regs));
            -       profile_tick(CPU_PROFILING, regs);
            +       update_process_times(user_mode(get_irq_regs()));
            +       profile_tick(CPU_PROFILING);
    
    I'd like to move update_process_times()'s use of get_irq_regs() into itself,
    except that i386, alone of the archs, uses something other than user_mode().
    
    Some notes on the interrupt handling in the drivers:
    
     (*) input_dev() is now gone entirely.  The regs pointer is no longer stored in
         the input_dev struct.
    
     (*) finish_unlinks() in drivers/usb/host/ohci-q.c needs checking.  It does
         something different depending on whether it's been supplied with a regs
         pointer or not.
    
     (*) Various IRQ handler function pointers have been moved to type
         irq_handler_t.
    
    Signed-Off-By: David Howells <dhowells@redhat.com>
    (cherry picked from 1b16e7ac850969f38b375e511e3fa2f474a33867 commit)

diff --git a/drivers/parisc/dino.c b/drivers/parisc/dino.c
index 0d96c50ffe9c..a0a8fd8d2124 100644
--- a/drivers/parisc/dino.c
+++ b/drivers/parisc/dino.c
@@ -368,8 +368,7 @@ static struct hw_interrupt_type dino_interrupt_type = {
  * ilr_loop counter is a kluge to prevent a "stuck" IRQ line from
  * wedging the CPU. Could be removed or made optional at some point.
  */
-static irqreturn_t
-dino_isr(int irq, void *intr_dev, struct pt_regs *regs)
+static irqreturn_t dino_isr(int irq, void *intr_dev)
 {
 	struct dino_device *dino_dev = intr_dev;
 	u32 mask;

commit 6ab3d5624e172c553004ecc862bfeac16d9d68b7
Author: Jrn Engel <joern@wohnheim.fh-wedel.de>
Date:   Fri Jun 30 19:25:36 2006 +0200

    Remove obsolete #include <linux/config.h>
    
    Signed-off-by: Jrn Engel <joern@wohnheim.fh-wedel.de>
    Signed-off-by: Adrian Bunk <bunk@stusta.de>

diff --git a/drivers/parisc/dino.c b/drivers/parisc/dino.c
index ce0a6ebcff15..0d96c50ffe9c 100644
--- a/drivers/parisc/dino.c
+++ b/drivers/parisc/dino.c
@@ -43,7 +43,6 @@
 **       for PCI drivers devices which implement/use MMIO registers.
 */
 
-#include <linux/config.h>
 #include <linux/delay.h>
 #include <linux/types.h>
 #include <linux/kernel.h>

commit d1bef4ed5faf7d9872337b33c4269e45ae1bf960
Author: Ingo Molnar <mingo@elte.hu>
Date:   Thu Jun 29 02:24:36 2006 -0700

    [PATCH] genirq: rename desc->handler to desc->chip
    
    This patch-queue improves the generic IRQ layer to be truly generic, by adding
    various abstractions and features to it, without impacting existing
    functionality.
    
    While the queue can be best described as "fix and improve everything in the
    generic IRQ layer that we could think of", and thus it consists of many
    smaller features and lots of cleanups, the one feature that stands out most is
    the new 'irq chip' abstraction.
    
    The irq-chip abstraction is about describing and coding and IRQ controller
    driver by mapping its raw hardware capabilities [and quirks, if needed] in a
    straightforward way, without having to think about "IRQ flow"
    (level/edge/etc.) type of details.
    
    This stands in contrast with the current 'irq-type' model of genirq
    architectures, which 'mixes' raw hardware capabilities with 'flow' details.
    The patchset supports both types of irq controller designs at once, and
    converts i386 and x86_64 to the new irq-chip design.
    
    As a bonus side-effect of the irq-chip approach, chained interrupt controllers
    (master/slave PIC constructs, etc.) are now supported by design as well.
    
    The end result of this patchset intends to be simpler architecture-level code
    and more consolidation between architectures.
    
    We reused many bits of code and many concepts from Russell King's ARM IRQ
    layer, the merging of which was one of the motivations for this patchset.
    
    This patch:
    
    rename desc->handler to desc->chip.
    
    Originally i did not want to do this, because it's a big patch.  But having
    both "desc->handler", "desc->handle_irq" and "action->handler" caused a
    large degree of confusion and made the code appear alot less clean than it
    truly is.
    
    I have also attempted a dual approach as well by introducing a
    desc->chip alias - but that just wasnt robust enough and broke
    frequently.
    
    So lets get over with this quickly.  The conversion was done automatically
    via scripts and converts all the code in the kernel.
    
    This renaming patch is the first one amongst the patches, so that the
    remaining patches can stay flexible and can be merged and split up
    without having some big monolithic patch act as a merge barrier.
    
    [akpm@osdl.org: build fix]
    [akpm@osdl.org: another build fix]
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/parisc/dino.c b/drivers/parisc/dino.c
index 6e8ed0c81a6c..ce0a6ebcff15 100644
--- a/drivers/parisc/dino.c
+++ b/drivers/parisc/dino.c
@@ -299,7 +299,7 @@ struct pci_port_ops dino_port_ops = {
 
 static void dino_disable_irq(unsigned int irq)
 {
-	struct dino_device *dino_dev = irq_desc[irq].handler_data;
+	struct dino_device *dino_dev = irq_desc[irq].chip_data;
 	int local_irq = gsc_find_local_irq(irq, dino_dev->global_irq, DINO_LOCAL_IRQS);
 
 	DBG(KERN_WARNING "%s(0x%p, %d)\n", __FUNCTION__, dino_dev, irq);
@@ -311,7 +311,7 @@ static void dino_disable_irq(unsigned int irq)
 
 static void dino_enable_irq(unsigned int irq)
 {
-	struct dino_device *dino_dev = irq_desc[irq].handler_data;
+	struct dino_device *dino_dev = irq_desc[irq].chip_data;
 	int local_irq = gsc_find_local_irq(irq, dino_dev->global_irq, DINO_LOCAL_IRQS);
 	u32 tmp;
 

commit 5076c15862644edb91d2e3436b2fa3e07b28385d
Author: Helge Deller <deller@parisc-linux.org>
Date:   Mon Mar 27 12:52:15 2006 -0700

    [PARISC] I/O-Space must be ioremap_nocache()'d
    
    Addresses in F-space must be accessed uncached on most parisc machines.
    
    Signed-off-by: Helge Deller <deller@parisc-linux.org>
    Signed-off-by: Kyle McMartin <kyle@parisc-linux.org>

diff --git a/drivers/parisc/dino.c b/drivers/parisc/dino.c
index 3d1a7f98c676..6e8ed0c81a6c 100644
--- a/drivers/parisc/dino.c
+++ b/drivers/parisc/dino.c
@@ -5,6 +5,7 @@
 **	(c) Copyright 1999 SuSE GmbH
 **	(c) Copyright 1999,2000 Hewlett-Packard Company
 **	(c) Copyright 2000 Grant Grundler
+**	(c) Copyright 2006 Helge Deller
 **
 **	This program is free software; you can redistribute it and/or modify
 **	it under the terms of the GNU General Public License as published by
@@ -785,7 +786,7 @@ dino_bridge_init(struct dino_device *dino_dev, const char *name)
 		if((io_addr & (1 << i)) == 0)
 			continue;
 
-		start = (unsigned long)(signed int)(0xf0000000 | (i << 23));
+		start = F_EXTEND(0xf0000000UL) | (i << 23);
 		end = start + 8 * 1024 * 1024 - 1;
 
 		DBG("DINO RANGE %d is at 0x%lx-0x%lx\n", count,
@@ -996,7 +997,7 @@ static int __init dino_probe(struct parisc_device *dev)
 	}
 
 	dino_dev->hba.dev = dev;
-	dino_dev->hba.base_addr = ioremap(hpa, 4096);
+	dino_dev->hba.base_addr = ioremap_nocache(hpa, 4096);
 	dino_dev->hba.lmmio_space_offset = 0;	/* CPU addrs == bus addrs */
 	spin_lock_init(&dino_dev->dinosaur_pen);
 	dino_dev->hba.iommu = ccio_get_iommu(dev);

commit cb6fc18e9ca615f03d18e60c49855b434ca2e51e
Author: Helge Deller <deller@parisc-linux.org>
Date:   Tue Jan 17 12:40:40 2006 -0700

    [PARISC] Use kzalloc and other janitor-style cleanups
    
    Helge,
      o Convert a bunch of kmalloc/memset uses to kzalloc.
      o pci.c: Add some __read_mostly annotations.
      o pci.c: Move constant pci_post_reset_delay to asm/pci.h
      o grfioctl.h: Add A4450A to comment of CRT_ID_VISUALIZE_EG.
      o Add some consts to perf.c/perf_images.h
    
    Matthew,
      o sticore.c: Add some consts to suppress compile warnings.
    
    Signed-off-by: Helge Deller <deller@parisc-linux.org>
    Signed-off-by: Matthew Wilcox <willy@parisc-linux.org>
    Signed-off-by: Kyle McMartin <kyle@parisc-linux.org>

diff --git a/drivers/parisc/dino.c b/drivers/parisc/dino.c
index 216d1d859326..3d1a7f98c676 100644
--- a/drivers/parisc/dino.c
+++ b/drivers/parisc/dino.c
@@ -989,14 +989,12 @@ static int __init dino_probe(struct parisc_device *dev)
 */
 	}
 
-	dino_dev = kmalloc(sizeof(struct dino_device), GFP_KERNEL);
+	dino_dev = kzalloc(sizeof(struct dino_device), GFP_KERNEL);
 	if (!dino_dev) {
 		printk("dino_init_chip - couldn't alloc dino_device\n");
 		return 1;
 	}
 
-	memset(dino_dev, 0, sizeof(struct dino_device));
-
 	dino_dev->hba.dev = dev;
 	dino_dev->hba.base_addr = ioremap(hpa, 4096);
 	dino_dev->hba.lmmio_space_offset = 0;	/* CPU addrs == bus addrs */

commit f45adcf977ac3c5512c17fd97b073bda99c81232
Author: Matthew Wilcox <willy@parisc-linux.org>
Date:   Tue Jan 10 20:48:06 2006 -0500

    [PARISC] Fix Dino reporting on J2240
    
    Fix Dino reporting on J2240. This particular machine thought it
    had a Cujo. Also add J2240 Dino chip to the hp_hardware_list.
    
    Signed-off-by: Matthew Wilcox <willy@parisc-linux.org>
    Signed-off-by: Kyle McMartin <kyle@parisc-linux.org>

diff --git a/drivers/parisc/dino.c b/drivers/parisc/dino.c
index 45a1a494c1cc..216d1d859326 100644
--- a/drivers/parisc/dino.c
+++ b/drivers/parisc/dino.c
@@ -83,7 +83,8 @@
 ** bus number for each dino.
 */
 
-#define is_card_dino(id) ((id)->hw_type == HPHW_A_DMA)
+#define is_card_dino(id)	((id)->hw_type == HPHW_A_DMA)
+#define is_cujo(id)		((id)->hversion == 0x682)
 
 #define DINO_IAR0		0x004
 #define DINO_IODC_ADDR		0x008
@@ -682,7 +683,6 @@ dino_fixup_bus(struct pci_bus *bus)
 			printk(KERN_WARNING "Device %s has unassigned IRQ\n", pci_name(dev));
 #endif
 		} else {
-
 			/* Adjust INT_LINE for that busses region */
 			dino_assign_irq(dino_dev, dev->irq, &dev->irq);
 		}
@@ -888,7 +888,7 @@ static int __init dino_common_init(struct parisc_device *dev,
 
 	/* allocate I/O Port resource region */
 	res = &dino_dev->hba.io_space;
-	if (dev->id.hversion == 0x680 || is_card_dino(&dev->id)) {
+	if (!is_cujo(&dev->id)) {
 		res->name = "Dino I/O Port";
 	} else {
 		res->name = "Cujo I/O Port";
@@ -943,7 +943,7 @@ static int __init dino_probe(struct parisc_device *dev)
 	if (is_card_dino(&dev->id)) {
 		version = "3.x (card mode)";
 	} else {
-		if(dev->id.hversion == 0x680) {
+		if (!is_cujo(&dev->id)) {
 			if (dev->id.hversion_rev < 4) {
 				version = dino_vers[dev->id.hversion_rev];
 			}

commit 4d64c9f58e618b1bdbc91cb071e6c8d90f43d620
Author: Helge Deller <deller@parisc-linux.org>
Date:   Tue Jan 10 20:47:54 2006 -0500

    [PARISC] Introduce DINO_LOCAL_IRQS and use it for gsc_find_local_irq
    
    Fix dino by using DINO_LOCAL_IRQS as the limit for gsc_find_local_irq()
    instead of the irq itself.
    
    Signed-off-by: Helge Deller <deller@parisc-linux.org>
    Signed-off-by: Kyle McMartin <kyle@parisc-linux.org>

diff --git a/drivers/parisc/dino.c b/drivers/parisc/dino.c
index 595d1987e997..45a1a494c1cc 100644
--- a/drivers/parisc/dino.c
+++ b/drivers/parisc/dino.c
@@ -124,6 +124,7 @@
 
 #define DINO_IRQS 11		/* bits 0-10 are architected */
 #define DINO_IRR_MASK	0x5ff	/* only 10 bits are implemented */
+#define DINO_LOCAL_IRQS (DINO_IRQS+1)
 
 #define DINO_MASK_IRQ(x)	(1<<(x))
 
@@ -146,7 +147,7 @@ struct dino_device
 	unsigned long		txn_addr; /* EIR addr to generate interrupt */ 
 	u32			txn_data; /* EIR data assign to each dino */ 
 	u32 			imr;	  /* IRQ's which are enabled */ 
-	int			global_irq[12]; /* map IMR bit to global irq */
+	int			global_irq[DINO_LOCAL_IRQS]; /* map IMR bit to global irq */
 #ifdef DINO_DEBUG
 	unsigned int		dino_irr0; /* save most recent IRQ line stat */
 #endif
@@ -297,7 +298,7 @@ struct pci_port_ops dino_port_ops = {
 static void dino_disable_irq(unsigned int irq)
 {
 	struct dino_device *dino_dev = irq_desc[irq].handler_data;
-	int local_irq = gsc_find_local_irq(irq, dino_dev->global_irq, irq);
+	int local_irq = gsc_find_local_irq(irq, dino_dev->global_irq, DINO_LOCAL_IRQS);
 
 	DBG(KERN_WARNING "%s(0x%p, %d)\n", __FUNCTION__, dino_dev, irq);
 
@@ -309,7 +310,7 @@ static void dino_disable_irq(unsigned int irq)
 static void dino_enable_irq(unsigned int irq)
 {
 	struct dino_device *dino_dev = irq_desc[irq].handler_data;
-	int local_irq = gsc_find_local_irq(irq, dino_dev->global_irq, irq);
+	int local_irq = gsc_find_local_irq(irq, dino_dev->global_irq, DINO_LOCAL_IRQS);
 	u32 tmp;
 
 	DBG(KERN_WARNING "%s(0x%p, %d)\n", __FUNCTION__, dino_dev, irq);

commit 04d35d7324ed35983189bd396db7874a50bbea43
Author: Helge Deller <deller@parisc-linux.org>
Date:   Tue Jan 10 20:47:50 2006 -0500

    [PARISC] Fix Cirrus 6832 Cardbus on RDI Tadpole PARISC Laptop
    
    Fix irq-off-by-one for Cirrus 6832 Cardbus on RDI Tadpole PARISC Laptop.
    We just DECLARE_PCI_FIXUP_ENABLE as it is unlikely that this will be
    found in any other parisc system.
    
    Signed-off-by: Helge Deller <deller@parisc-linux.org>
    Signed-off-by: Kyle McMartin <kyle@parisc-linux.org>

diff --git a/drivers/parisc/dino.c b/drivers/parisc/dino.c
index 5ab75334c579..595d1987e997 100644
--- a/drivers/parisc/dino.c
+++ b/drivers/parisc/dino.c
@@ -435,6 +435,21 @@ static void dino_choose_irq(struct parisc_device *dev, void *ctrl)
 	dino_assign_irq(dino, irq, &dev->irq);
 }
 
+
+/*
+ * Cirrus 6832 Cardbus reports wrong irq on RDI Tadpole PARISC Laptop (deller@gmx.de)
+ * (the irqs are off-by-one, not sure yet if this is a cirrus, dino-hardware or dino-driver problem...)
+ */
+static void __devinit quirk_cirrus_cardbus(struct pci_dev *dev)
+{
+	u8 new_irq = dev->irq - 1;
+	printk(KERN_INFO "PCI: Cirrus Cardbus IRQ fixup for %s, from %d to %d\n",
+			pci_name(dev), dev->irq, new_irq);
+	dev->irq = new_irq;
+}
+DECLARE_PCI_FIXUP_ENABLE(PCI_VENDOR_ID_CIRRUS, PCI_DEVICE_ID_CIRRUS_6832, quirk_cirrus_cardbus );
+
+
 static void __init
 dino_bios_init(void)
 {

commit 92b919fe46509820c639a08962cbf78bc8d227d9
Author: Matthew Wilcox <willy@parisc-linux.org>
Date:   Fri Oct 21 22:38:23 2005 -0400

    [PARISC] Update dino from parisc tree
    
    Fix card-mode Dino crashes on 725 (and probably other Snake) systems.
    Dino was coming up in fatal mode after a warm reboot.  Resetting Dino
    brings it out of fatal mode, so do that if the status register indicates
    we're in fatal mode.  Since this was never observed on any later systems,
    I presume firmware does this for us on those.
    
    Signed-off-by: Matthew Wilcox <willy@parisc-linux.org>
    
    Add debug statements in the cfg_read and cfg_write functions
    Fix debug statements from the IRQ overhaul last winter
    Rename dino_driver_callback() to dino_probe()
    
    Signed-off-by: Matthew Wilcox <willy@parisc-linux.org>
    
    Signed-off-by: Kyle McMartin <kyle@parisc-linux.org>

diff --git a/drivers/parisc/dino.c b/drivers/parisc/dino.c
index 37820b0ae5ee..5ab75334c579 100644
--- a/drivers/parisc/dino.c
+++ b/drivers/parisc/dino.c
@@ -178,6 +178,8 @@ static int dino_cfg_read(struct pci_bus *bus, unsigned int devfn, int where,
 	void __iomem *base_addr = d->hba.base_addr;
 	unsigned long flags;
 
+	DBG("%s: %p, %d, %d, %d\n", __FUNCTION__, base_addr, devfn, where,
+									size);
 	spin_lock_irqsave(&d->dinosaur_pen, flags);
 
 	/* tell HW which CFG address */
@@ -211,6 +213,8 @@ static int dino_cfg_write(struct pci_bus *bus, unsigned int devfn, int where,
 	void __iomem *base_addr = d->hba.base_addr;
 	unsigned long flags;
 
+	DBG("%s: %p, %d, %d, %d\n", __FUNCTION__, base_addr, devfn, where,
+									size);
 	spin_lock_irqsave(&d->dinosaur_pen, flags);
 
 	/* avoid address stepping feature */
@@ -295,7 +299,7 @@ static void dino_disable_irq(unsigned int irq)
 	struct dino_device *dino_dev = irq_desc[irq].handler_data;
 	int local_irq = gsc_find_local_irq(irq, dino_dev->global_irq, irq);
 
-	DBG(KERN_WARNING "%s(0x%p, %d)\n", __FUNCTION__, irq_dev, irq);
+	DBG(KERN_WARNING "%s(0x%p, %d)\n", __FUNCTION__, dino_dev, irq);
 
 	/* Clear the matching bit in the IMR register */
 	dino_dev->imr &= ~(DINO_MASK_IRQ(local_irq));
@@ -308,7 +312,7 @@ static void dino_enable_irq(unsigned int irq)
 	int local_irq = gsc_find_local_irq(irq, dino_dev->global_irq, irq);
 	u32 tmp;
 
-	DBG(KERN_WARNING "%s(0x%p, %d)\n", __FUNCTION__, irq_dev, irq);
+	DBG(KERN_WARNING "%s(0x%p, %d)\n", __FUNCTION__, dino_dev, irq);
 
 	/*
 	** clear pending IRQ bits
@@ -490,7 +494,7 @@ dino_card_setup(struct pci_bus *bus, void __iomem *base_addr)
 		if (res->start == F_EXTEND(0xf0000000UL | (i * _8MB)))
 			break;
 	}
-	DBG("DINO GSC WRITE i=%d, start=%lx, dino addr = %lx\n",
+	DBG("DINO GSC WRITE i=%d, start=%lx, dino addr = %p\n",
 	    i, res->start, base_addr + DINO_IO_ADDR_EN);
 	__raw_writel(1 << i, base_addr + DINO_IO_ADDR_EN);
 }
@@ -683,6 +687,14 @@ static void __init
 dino_card_init(struct dino_device *dino_dev)
 {
 	u32 brdg_feat = 0x00784e05;
+	unsigned long status;
+
+	status = __raw_readl(dino_dev->hba.base_addr+DINO_IO_STATUS);
+	if (status & 0x0000ff80) {
+		__raw_writel(0x00000005,
+				dino_dev->hba.base_addr+DINO_IO_COMMAND);
+		udelay(1);
+	}
 
 	__raw_writel(0x00000000, dino_dev->hba.base_addr+DINO_GMASK);
 	__raw_writel(0x00000001, dino_dev->hba.base_addr+DINO_IO_FBB_EN);
@@ -928,11 +940,11 @@ static int __init dino_probe(struct parisc_device *dev)
 		}
 	}
 
-	printk("%s version %s found at 0x%lx\n", name, version, dev->hpa);
+	printk("%s version %s found at 0x%lx\n", name, version, hpa);
 
-	if (!request_mem_region(dev->hpa, PAGE_SIZE, name)) {
+	if (!request_mem_region(hpa, PAGE_SIZE, name)) {
 		printk(KERN_ERR "DINO: Hey! Someone took my MMIO space (0x%ld)!\n",
-			dev->hpa);
+			hpa);
 		return 1;
 	}
 
@@ -940,12 +952,12 @@ static int __init dino_probe(struct parisc_device *dev)
 	if (is_cujo && dev->id.hversion_rev == 1) {
 #ifdef CONFIG_IOMMU_CCIO
 		printk(KERN_WARNING "Enabling Cujo 2.0 bug workaround\n");
-		if (dev->hpa == (unsigned long)CUJO_RAVEN_ADDR) {
+		if (hpa == (unsigned long)CUJO_RAVEN_ADDR) {
 			ccio_cujo20_fixup(dev, CUJO_RAVEN_BADPAGE);
-		} else if (dev->hpa == (unsigned long)CUJO_FIREHAWK_ADDR) {
+		} else if (hpa == (unsigned long)CUJO_FIREHAWK_ADDR) {
 			ccio_cujo20_fixup(dev, CUJO_FIREHAWK_BADPAGE);
 		} else {
-			printk("Don't recognise Cujo at address 0x%lx, not enabling workaround\n", dev->hpa);
+			printk("Don't recognise Cujo at address 0x%lx, not enabling workaround\n", hpa);
 		}
 #endif
 	} else if (!is_cujo && !is_card_dino(&dev->id) &&
@@ -970,7 +982,7 @@ static int __init dino_probe(struct parisc_device *dev)
 	memset(dino_dev, 0, sizeof(struct dino_device));
 
 	dino_dev->hba.dev = dev;
-	dino_dev->hba.base_addr = ioremap(dev->hpa, 4096); /* faster access */
+	dino_dev->hba.base_addr = ioremap(hpa, 4096);
 	dino_dev->hba.lmmio_space_offset = 0;	/* CPU addrs == bus addrs */
 	spin_lock_init(&dino_dev->dinosaur_pen);
 	dino_dev->hba.iommu = ccio_get_iommu(dev);

commit 53f01bba49938f115237fe43a261c31ac13ae5c6
Author: Matthew Wilcox <willy@parisc-linux.org>
Date:   Fri Oct 21 22:36:40 2005 -0400

    [PARISC] Convert parisc_device to use struct resource for hpa
    
    Convert pa_dev->hpa from an unsigned long to a struct resource.
    
    Signed-off-by: Matthew Wilcox <willy@parisc-linux.org>
    
    Fix up users of ->hpa to use ->hpa.start instead.
    
    Signed-off-by: Matthew Wilcox <willy@parisc-linux.org>
    
    Signed-off-by: Kyle McMartin <kyle@parisc-linux.org>

diff --git a/drivers/parisc/dino.c b/drivers/parisc/dino.c
index 8c61705e67a5..37820b0ae5ee 100644
--- a/drivers/parisc/dino.c
+++ b/drivers/parisc/dino.c
@@ -902,15 +902,15 @@ void ccio_cujo20_fixup(struct parisc_device *dev, u32 iovp);
 ** If so, initialize the chip appropriately (card-mode vs bridge mode).
 ** Much of the initialization is common though.
 */
-static int __init
-dino_driver_callback(struct parisc_device *dev)
+static int __init dino_probe(struct parisc_device *dev)
 {
 	struct dino_device *dino_dev;	// Dino specific control struct
 	const char *version = "unknown";
 	char *name;
 	int is_cujo = 0;
 	struct pci_bus *bus;
-	
+	unsigned long hpa = dev->hpa.start;
+
 	name = "Dino";
 	if (is_card_dino(&dev->id)) {
 		version = "3.x (card mode)";

commit bdad1f836ab1ca2b18a625222f63f630cfd14e41
Author: Matthew Wilcox <willy@parisc-linux.org>
Date:   Fri Oct 21 22:36:23 2005 -0400

    [PARISC] Change the driver names so /sys/bus/parisc/drivers/ looks better
    
    Make /sys/bus/parisc/drivers look better by cleaning up parisc_driver
    names.
    
    Signed-off-by: Matthew Wilcox <willy@parisc-linux.org>
    
    Signed-off-by: Kyle McMartin <kyle@parisc-linux.org>

diff --git a/drivers/parisc/dino.c b/drivers/parisc/dino.c
index 2f2dbef2c3b7..8c61705e67a5 100644
--- a/drivers/parisc/dino.c
+++ b/drivers/parisc/dino.c
@@ -1027,9 +1027,9 @@ static struct parisc_device_id dino_tbl[] = {
 };
 
 static struct parisc_driver dino_driver = {
-	.name =		"Dino",
+	.name =		"dino",
 	.id_table =	dino_tbl,
-	.probe =	dino_driver_callback,
+	.probe =	dino_probe,
 };
 
 /*

commit c431ada45d65b305a6aab4557067e564b23ce5a5
Author: Rajesh Shah <rajesh.shah@intel.com>
Date:   Thu Apr 28 00:25:45 2005 -0700

    [PATCH] acpi bridge hotadd: ACPI based root bridge hot-add
    
    When you hot-plug a (root) bridge hierarchy, it may have p2p bridges and
    devices attached to it that have not been configured by firmware.  In this
    case, we need to configure the devices before starting them.  This patch
    separates device start from device scan so that we can introduce the
    configuration step in the middle.
    
    I kept the existing semantics for pci_scan_bus() since there are a huge number
    of callers to that function.
    
    Also, I have no way of testing the changes I made to the parisc files, so this
    needs review by those folks.  Sorry for the massive cross-post, this touches
    files in many different places.
    
    Signed-off-by: Rajesh Shah <rajesh.shah@intel.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/parisc/dino.c b/drivers/parisc/dino.c
index b0d2a73d1d47..2f2dbef2c3b7 100644
--- a/drivers/parisc/dino.c
+++ b/drivers/parisc/dino.c
@@ -993,6 +993,7 @@ dino_driver_callback(struct parisc_device *dev)
 	bus = pci_scan_bus_parented(&dev->dev, dino_current_bus,
 				    &dino_cfg_ops, NULL);
 	if(bus) {
+		pci_bus_add_devices(bus);
 		/* This code *depends* on scanning being single threaded
 		 * if it isn't, this global bus number count will fail
 		 */

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/drivers/parisc/dino.c b/drivers/parisc/dino.c
new file mode 100644
index 000000000000..b0d2a73d1d47
--- /dev/null
+++ b/drivers/parisc/dino.c
@@ -0,0 +1,1044 @@
+/*
+**	DINO manager
+**
+**	(c) Copyright 1999 Red Hat Software
+**	(c) Copyright 1999 SuSE GmbH
+**	(c) Copyright 1999,2000 Hewlett-Packard Company
+**	(c) Copyright 2000 Grant Grundler
+**
+**	This program is free software; you can redistribute it and/or modify
+**	it under the terms of the GNU General Public License as published by
+**      the Free Software Foundation; either version 2 of the License, or
+**      (at your option) any later version.
+**
+**	This module provides access to Dino PCI bus (config/IOport spaces)
+**	and helps manage Dino IRQ lines.
+**
+**	Dino interrupt handling is a bit complicated.
+**	Dino always writes to the broadcast EIR via irr0 for now.
+**	(BIG WARNING: using broadcast EIR is a really bad thing for SMP!)
+**	Only one processor interrupt is used for the 11 IRQ line 
+**	inputs to dino.
+**
+**	The different between Built-in Dino and Card-Mode
+**	dino is in chip initialization and pci device initialization.
+**
+**	Linux drivers can only use Card-Mode Dino if pci devices I/O port
+**	BARs are configured and used by the driver. Programming MMIO address 
+**	requires substantial knowledge of available Host I/O address ranges
+**	is currently not supported.  Port/Config accessor functions are the
+**	same. "BIOS" differences are handled within the existing routines.
+*/
+
+/*	Changes :
+**	2001-06-14 : Clement Moyroud (moyroudc@esiee.fr)
+**		- added support for the integrated RS232. 	
+*/
+
+/*
+** TODO: create a virtual address for each Dino HPA.
+**       GSC code might be able to do this since IODC data tells us
+**       how many pages are used. PCI subsystem could (must?) do this
+**       for PCI drivers devices which implement/use MMIO registers.
+*/
+
+#include <linux/config.h>
+#include <linux/delay.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/pci.h>
+#include <linux/init.h>
+#include <linux/ioport.h>
+#include <linux/slab.h>
+#include <linux/interrupt.h>	/* for struct irqaction */
+#include <linux/spinlock.h>	/* for spinlock_t and prototypes */
+
+#include <asm/pdc.h>
+#include <asm/page.h>
+#include <asm/system.h>
+#include <asm/io.h>
+#include <asm/hardware.h>
+
+#include "gsc.h"
+
+#undef DINO_DEBUG
+
+#ifdef DINO_DEBUG
+#define DBG(x...) printk(x)
+#else
+#define DBG(x...)
+#endif
+
+/*
+** Config accessor functions only pass in the 8-bit bus number
+** and not the 8-bit "PCI Segment" number. Each Dino will be
+** assigned a PCI bus number based on "when" it's discovered.
+**
+** The "secondary" bus number is set to this before calling
+** pci_scan_bus(). If any PPB's are present, the scan will
+** discover them and update the "secondary" and "subordinate"
+** fields in Dino's pci_bus structure.
+**
+** Changes in the configuration *will* result in a different
+** bus number for each dino.
+*/
+
+#define is_card_dino(id) ((id)->hw_type == HPHW_A_DMA)
+
+#define DINO_IAR0		0x004
+#define DINO_IODC_ADDR		0x008
+#define DINO_IODC_DATA_0	0x008
+#define DINO_IODC_DATA_1	0x008
+#define DINO_IRR0		0x00C
+#define DINO_IAR1		0x010
+#define DINO_IRR1		0x014
+#define DINO_IMR		0x018
+#define DINO_IPR		0x01C
+#define DINO_TOC_ADDR		0x020
+#define DINO_ICR		0x024
+#define DINO_ILR		0x028
+#define DINO_IO_COMMAND		0x030
+#define DINO_IO_STATUS		0x034
+#define DINO_IO_CONTROL		0x038
+#define DINO_IO_GSC_ERR_RESP	0x040
+#define DINO_IO_ERR_INFO	0x044
+#define DINO_IO_PCI_ERR_RESP	0x048
+#define DINO_IO_FBB_EN		0x05c
+#define DINO_IO_ADDR_EN		0x060
+#define DINO_PCI_ADDR		0x064
+#define DINO_CONFIG_DATA	0x068
+#define DINO_IO_DATA		0x06c
+#define DINO_MEM_DATA		0x070	/* Dino 3.x only */
+#define DINO_GSC2X_CONFIG	0x7b4
+#define DINO_GMASK		0x800
+#define DINO_PAMR		0x804
+#define DINO_PAPR		0x808
+#define DINO_DAMODE		0x80c
+#define DINO_PCICMD		0x810
+#define DINO_PCISTS		0x814
+#define DINO_MLTIM		0x81c
+#define DINO_BRDG_FEAT		0x820
+#define DINO_PCIROR		0x824
+#define DINO_PCIWOR		0x828
+#define DINO_TLTIM		0x830
+
+#define DINO_IRQS 11		/* bits 0-10 are architected */
+#define DINO_IRR_MASK	0x5ff	/* only 10 bits are implemented */
+
+#define DINO_MASK_IRQ(x)	(1<<(x))
+
+#define PCIINTA   0x001
+#define PCIINTB   0x002
+#define PCIINTC   0x004
+#define PCIINTD   0x008
+#define PCIINTE   0x010
+#define PCIINTF   0x020
+#define GSCEXTINT 0x040
+/* #define xxx       0x080 - bit 7 is "default" */
+/* #define xxx    0x100 - bit 8 not used */
+/* #define xxx    0x200 - bit 9 not used */
+#define RS232INT  0x400
+
+struct dino_device
+{
+	struct pci_hba_data	hba;	/* 'C' inheritance - must be first */
+	spinlock_t		dinosaur_pen;
+	unsigned long		txn_addr; /* EIR addr to generate interrupt */ 
+	u32			txn_data; /* EIR data assign to each dino */ 
+	u32 			imr;	  /* IRQ's which are enabled */ 
+	int			global_irq[12]; /* map IMR bit to global irq */
+#ifdef DINO_DEBUG
+	unsigned int		dino_irr0; /* save most recent IRQ line stat */
+#endif
+};
+
+/* Looks nice and keeps the compiler happy */
+#define DINO_DEV(d) ((struct dino_device *) d)
+
+
+/*
+ * Dino Configuration Space Accessor Functions
+ */
+
+#define DINO_CFG_TOK(bus,dfn,pos) ((u32) ((bus)<<16 | (dfn)<<8 | (pos)))
+
+/*
+ * keep the current highest bus count to assist in allocating busses.  This
+ * tries to keep a global bus count total so that when we discover an 
+ * entirely new bus, it can be given a unique bus number.
+ */
+static int dino_current_bus = 0;
+
+static int dino_cfg_read(struct pci_bus *bus, unsigned int devfn, int where,
+		int size, u32 *val)
+{
+	struct dino_device *d = DINO_DEV(parisc_walk_tree(bus->bridge));
+	u32 local_bus = (bus->parent == NULL) ? 0 : bus->secondary;
+	u32 v = DINO_CFG_TOK(local_bus, devfn, where & ~3);
+	void __iomem *base_addr = d->hba.base_addr;
+	unsigned long flags;
+
+	spin_lock_irqsave(&d->dinosaur_pen, flags);
+
+	/* tell HW which CFG address */
+	__raw_writel(v, base_addr + DINO_PCI_ADDR);
+
+	/* generate cfg read cycle */
+	if (size == 1) {
+		*val = readb(base_addr + DINO_CONFIG_DATA + (where & 3));
+	} else if (size == 2) {
+		*val = readw(base_addr + DINO_CONFIG_DATA + (where & 2));
+	} else if (size == 4) {
+		*val = readl(base_addr + DINO_CONFIG_DATA);
+	}
+
+	spin_unlock_irqrestore(&d->dinosaur_pen, flags);
+	return 0;
+}
+
+/*
+ * Dino address stepping "feature":
+ * When address stepping, Dino attempts to drive the bus one cycle too soon
+ * even though the type of cycle (config vs. MMIO) might be different. 
+ * The read of Ven/Prod ID is harmless and avoids Dino's address stepping.
+ */
+static int dino_cfg_write(struct pci_bus *bus, unsigned int devfn, int where,
+	int size, u32 val)
+{
+	struct dino_device *d = DINO_DEV(parisc_walk_tree(bus->bridge));
+	u32 local_bus = (bus->parent == NULL) ? 0 : bus->secondary;
+	u32 v = DINO_CFG_TOK(local_bus, devfn, where & ~3);
+	void __iomem *base_addr = d->hba.base_addr;
+	unsigned long flags;
+
+	spin_lock_irqsave(&d->dinosaur_pen, flags);
+
+	/* avoid address stepping feature */
+	__raw_writel(v & 0xffffff00, base_addr + DINO_PCI_ADDR);
+	__raw_readl(base_addr + DINO_CONFIG_DATA);
+
+	/* tell HW which CFG address */
+	__raw_writel(v, base_addr + DINO_PCI_ADDR);
+	/* generate cfg read cycle */
+	if (size == 1) {
+		writeb(val, base_addr + DINO_CONFIG_DATA + (where & 3));
+	} else if (size == 2) {
+		writew(val, base_addr + DINO_CONFIG_DATA + (where & 2));
+	} else if (size == 4) {
+		writel(val, base_addr + DINO_CONFIG_DATA);
+	}
+
+	spin_unlock_irqrestore(&d->dinosaur_pen, flags);
+	return 0;
+}
+
+static struct pci_ops dino_cfg_ops = {
+	.read =		dino_cfg_read,
+	.write =	dino_cfg_write,
+};
+
+
+/*
+ * Dino "I/O Port" Space Accessor Functions
+ *
+ * Many PCI devices don't require use of I/O port space (eg Tulip,
+ * NCR720) since they export the same registers to both MMIO and
+ * I/O port space.  Performance is going to stink if drivers use
+ * I/O port instead of MMIO.
+ */
+
+#define DINO_PORT_IN(type, size, mask) \
+static u##size dino_in##size (struct pci_hba_data *d, u16 addr) \
+{ \
+	u##size v; \
+	unsigned long flags; \
+	spin_lock_irqsave(&(DINO_DEV(d)->dinosaur_pen), flags); \
+	/* tell HW which IO Port address */ \
+	__raw_writel((u32) addr, d->base_addr + DINO_PCI_ADDR); \
+	/* generate I/O PORT read cycle */ \
+	v = read##type(d->base_addr+DINO_IO_DATA+(addr&mask)); \
+	spin_unlock_irqrestore(&(DINO_DEV(d)->dinosaur_pen), flags); \
+	return v; \
+}
+
+DINO_PORT_IN(b,  8, 3)
+DINO_PORT_IN(w, 16, 2)
+DINO_PORT_IN(l, 32, 0)
+
+#define DINO_PORT_OUT(type, size, mask) \
+static void dino_out##size (struct pci_hba_data *d, u16 addr, u##size val) \
+{ \
+	unsigned long flags; \
+	spin_lock_irqsave(&(DINO_DEV(d)->dinosaur_pen), flags); \
+	/* tell HW which IO port address */ \
+	__raw_writel((u32) addr, d->base_addr + DINO_PCI_ADDR); \
+	/* generate cfg write cycle */ \
+	write##type(val, d->base_addr+DINO_IO_DATA+(addr&mask)); \
+	spin_unlock_irqrestore(&(DINO_DEV(d)->dinosaur_pen), flags); \
+}
+
+DINO_PORT_OUT(b,  8, 3)
+DINO_PORT_OUT(w, 16, 2)
+DINO_PORT_OUT(l, 32, 0)
+
+struct pci_port_ops dino_port_ops = {
+	.inb	= dino_in8,
+	.inw	= dino_in16,
+	.inl	= dino_in32,
+	.outb	= dino_out8,
+	.outw	= dino_out16,
+	.outl	= dino_out32
+};
+
+static void dino_disable_irq(unsigned int irq)
+{
+	struct dino_device *dino_dev = irq_desc[irq].handler_data;
+	int local_irq = gsc_find_local_irq(irq, dino_dev->global_irq, irq);
+
+	DBG(KERN_WARNING "%s(0x%p, %d)\n", __FUNCTION__, irq_dev, irq);
+
+	/* Clear the matching bit in the IMR register */
+	dino_dev->imr &= ~(DINO_MASK_IRQ(local_irq));
+	__raw_writel(dino_dev->imr, dino_dev->hba.base_addr+DINO_IMR);
+}
+
+static void dino_enable_irq(unsigned int irq)
+{
+	struct dino_device *dino_dev = irq_desc[irq].handler_data;
+	int local_irq = gsc_find_local_irq(irq, dino_dev->global_irq, irq);
+	u32 tmp;
+
+	DBG(KERN_WARNING "%s(0x%p, %d)\n", __FUNCTION__, irq_dev, irq);
+
+	/*
+	** clear pending IRQ bits
+	**
+	** This does NOT change ILR state!
+	** See comment below for ILR usage.
+	*/
+	__raw_readl(dino_dev->hba.base_addr+DINO_IPR);
+
+	/* set the matching bit in the IMR register */
+	dino_dev->imr |= DINO_MASK_IRQ(local_irq);	/* used in dino_isr() */
+	__raw_writel( dino_dev->imr, dino_dev->hba.base_addr+DINO_IMR);
+
+	/* Emulate "Level Triggered" Interrupt
+	** Basically, a driver is blowing it if the IRQ line is asserted
+	** while the IRQ is disabled.  But tulip.c seems to do that....
+	** Give 'em a kluge award and a nice round of applause!
+	**
+	** The gsc_write will generate an interrupt which invokes dino_isr().
+	** dino_isr() will read IPR and find nothing. But then catch this
+	** when it also checks ILR.
+	*/
+	tmp = __raw_readl(dino_dev->hba.base_addr+DINO_ILR);
+	if (tmp & DINO_MASK_IRQ(local_irq)) {
+		DBG(KERN_WARNING "%s(): IRQ asserted! (ILR 0x%x)\n",
+				__FUNCTION__, tmp);
+		gsc_writel(dino_dev->txn_data, dino_dev->txn_addr);
+	}
+}
+
+static unsigned int dino_startup_irq(unsigned int irq)
+{
+	dino_enable_irq(irq);
+	return 0;
+}
+
+static struct hw_interrupt_type dino_interrupt_type = {
+	.typename	= "GSC-PCI",
+	.startup	= dino_startup_irq,
+	.shutdown	= dino_disable_irq,
+	.enable		= dino_enable_irq, 
+	.disable	= dino_disable_irq,
+	.ack		= no_ack_irq,
+	.end		= no_end_irq,
+};
+
+
+/*
+ * Handle a Processor interrupt generated by Dino.
+ *
+ * ilr_loop counter is a kluge to prevent a "stuck" IRQ line from
+ * wedging the CPU. Could be removed or made optional at some point.
+ */
+static irqreturn_t
+dino_isr(int irq, void *intr_dev, struct pt_regs *regs)
+{
+	struct dino_device *dino_dev = intr_dev;
+	u32 mask;
+	int ilr_loop = 100;
+
+	/* read and acknowledge pending interrupts */
+#ifdef DINO_DEBUG
+	dino_dev->dino_irr0 =
+#endif
+	mask = __raw_readl(dino_dev->hba.base_addr+DINO_IRR0) & DINO_IRR_MASK;
+
+	if (mask == 0)
+		return IRQ_NONE;
+
+ilr_again:
+	do {
+		int local_irq = __ffs(mask);
+		int irq = dino_dev->global_irq[local_irq];
+		DBG(KERN_DEBUG "%s(%d, %p) mask 0x%x\n",
+			__FUNCTION__, irq, intr_dev, mask);
+		__do_IRQ(irq, regs);
+		mask &= ~(1 << local_irq);
+	} while (mask);
+
+	/* Support for level triggered IRQ lines.
+	** 
+	** Dropping this support would make this routine *much* faster.
+	** But since PCI requires level triggered IRQ line to share lines...
+	** device drivers may assume lines are level triggered (and not
+	** edge triggered like EISA/ISA can be).
+	*/
+	mask = __raw_readl(dino_dev->hba.base_addr+DINO_ILR) & dino_dev->imr;
+	if (mask) {
+		if (--ilr_loop > 0)
+			goto ilr_again;
+		printk(KERN_ERR "Dino 0x%p: stuck interrupt %d\n", 
+		       dino_dev->hba.base_addr, mask);
+		return IRQ_NONE;
+	}
+	return IRQ_HANDLED;
+}
+
+static void dino_assign_irq(struct dino_device *dino, int local_irq, int *irqp)
+{
+	int irq = gsc_assign_irq(&dino_interrupt_type, dino);
+	if (irq == NO_IRQ)
+		return;
+
+	*irqp = irq;
+	dino->global_irq[local_irq] = irq;
+}
+
+static void dino_choose_irq(struct parisc_device *dev, void *ctrl)
+{
+	int irq;
+	struct dino_device *dino = ctrl;
+
+	switch (dev->id.sversion) {
+		case 0x00084:	irq =  8; break; /* PS/2 */
+		case 0x0008c:	irq = 10; break; /* RS232 */
+		case 0x00096:	irq =  8; break; /* PS/2 */
+		default:	return;		 /* Unknown */
+	}
+
+	dino_assign_irq(dino, irq, &dev->irq);
+}
+
+static void __init
+dino_bios_init(void)
+{
+	DBG("dino_bios_init\n");
+}
+
+/*
+ * dino_card_setup - Set up the memory space for a Dino in card mode.
+ * @bus: the bus under this dino
+ *
+ * Claim an 8MB chunk of unused IO space and call the generic PCI routines
+ * to set up the addresses of the devices on this bus.
+ */
+#define _8MB 0x00800000UL
+static void __init
+dino_card_setup(struct pci_bus *bus, void __iomem *base_addr)
+{
+	int i;
+	struct dino_device *dino_dev = DINO_DEV(parisc_walk_tree(bus->bridge));
+	struct resource *res;
+	char name[128];
+	int size;
+
+	res = &dino_dev->hba.lmmio_space;
+	res->flags = IORESOURCE_MEM;
+	size = scnprintf(name, sizeof(name), "Dino LMMIO (%s)", 
+			 bus->bridge->bus_id);
+	res->name = kmalloc(size+1, GFP_KERNEL);
+	if(res->name)
+		strcpy((char *)res->name, name);
+	else
+		res->name = dino_dev->hba.lmmio_space.name;
+	
+
+	if (ccio_allocate_resource(dino_dev->hba.dev, res, _8MB,
+				F_EXTEND(0xf0000000UL) | _8MB,
+				F_EXTEND(0xffffffffUL) &~ _8MB, _8MB) < 0) {
+		struct list_head *ln, *tmp_ln;
+
+		printk(KERN_ERR "Dino: cannot attach bus %s\n",
+		       bus->bridge->bus_id);
+		/* kill the bus, we can't do anything with it */
+		list_for_each_safe(ln, tmp_ln, &bus->devices) {
+			struct pci_dev *dev = pci_dev_b(ln);
+
+			list_del(&dev->global_list);
+			list_del(&dev->bus_list);
+		}
+			
+		return;
+	}
+	bus->resource[1] = res;
+	bus->resource[0] = &(dino_dev->hba.io_space);
+
+	/* Now tell dino what range it has */
+	for (i = 1; i < 31; i++) {
+		if (res->start == F_EXTEND(0xf0000000UL | (i * _8MB)))
+			break;
+	}
+	DBG("DINO GSC WRITE i=%d, start=%lx, dino addr = %lx\n",
+	    i, res->start, base_addr + DINO_IO_ADDR_EN);
+	__raw_writel(1 << i, base_addr + DINO_IO_ADDR_EN);
+}
+
+static void __init
+dino_card_fixup(struct pci_dev *dev)
+{
+	u32 irq_pin;
+
+	/*
+	** REVISIT: card-mode PCI-PCI expansion chassis do exist.
+	**         Not sure they were ever productized.
+	**         Die here since we'll die later in dino_inb() anyway.
+	*/
+	if ((dev->class >> 8) == PCI_CLASS_BRIDGE_PCI) {
+		panic("Card-Mode Dino: PCI-PCI Bridge not supported\n");
+	}
+
+	/*
+	** Set Latency Timer to 0xff (not a shared bus)
+	** Set CACHELINE_SIZE.
+	*/
+	dino_cfg_write(dev->bus, dev->devfn, 
+		       PCI_CACHE_LINE_SIZE, 2, 0xff00 | L1_CACHE_BYTES/4); 
+
+	/*
+	** Program INT_LINE for card-mode devices.
+	** The cards are hardwired according to this algorithm.
+	** And it doesn't matter if PPB's are present or not since
+	** the IRQ lines bypass the PPB.
+	**
+	** "-1" converts INTA-D (1-4) to PCIINTA-D (0-3) range.
+	** The additional "-1" adjusts for skewing the IRQ<->slot.
+	*/
+	dino_cfg_read(dev->bus, dev->devfn, PCI_INTERRUPT_PIN, 1, &irq_pin); 
+	dev->irq = (irq_pin + PCI_SLOT(dev->devfn) - 1) % 4 ;
+
+	/* Shouldn't really need to do this but it's in case someone tries
+	** to bypass PCI services and look at the card themselves.
+	*/
+	dino_cfg_write(dev->bus, dev->devfn, PCI_INTERRUPT_LINE, 1, dev->irq); 
+}
+
+/* The alignment contraints for PCI bridges under dino */
+#define DINO_BRIDGE_ALIGN 0x100000
+
+
+static void __init
+dino_fixup_bus(struct pci_bus *bus)
+{
+	struct list_head *ln;
+        struct pci_dev *dev;
+        struct dino_device *dino_dev = DINO_DEV(parisc_walk_tree(bus->bridge));
+	int port_base = HBA_PORT_BASE(dino_dev->hba.hba_num);
+
+	DBG(KERN_WARNING "%s(0x%p) bus %d platform_data 0x%p\n",
+	    __FUNCTION__, bus, bus->secondary, 
+	    bus->bridge->platform_data);
+
+	/* Firmware doesn't set up card-mode dino, so we have to */
+	if (is_card_dino(&dino_dev->hba.dev->id)) {
+		dino_card_setup(bus, dino_dev->hba.base_addr);
+	} else if(bus->parent == NULL) {
+		/* must have a dino above it, reparent the resources
+		 * into the dino window */
+		int i;
+		struct resource *res = &dino_dev->hba.lmmio_space;
+
+		bus->resource[0] = &(dino_dev->hba.io_space);
+		for(i = 0; i < DINO_MAX_LMMIO_RESOURCES; i++) {
+			if(res[i].flags == 0)
+				break;
+			bus->resource[i+1] = &res[i];
+		}
+
+	} else if(bus->self) {
+		int i;
+
+		pci_read_bridge_bases(bus);
+
+
+		for(i = PCI_BRIDGE_RESOURCES; i < PCI_NUM_RESOURCES; i++) {
+			if((bus->self->resource[i].flags & 
+			    (IORESOURCE_IO | IORESOURCE_MEM)) == 0)
+				continue;
+			
+			if(bus->self->resource[i].flags & IORESOURCE_MEM) {
+				/* There's a quirk to alignment of
+				 * bridge memory resources: the start
+				 * is the alignment and start-end is
+				 * the size.  However, firmware will
+				 * have assigned start and end, so we
+				 * need to take this into account */
+				bus->self->resource[i].end = bus->self->resource[i].end - bus->self->resource[i].start + DINO_BRIDGE_ALIGN;
+				bus->self->resource[i].start = DINO_BRIDGE_ALIGN;
+				
+			}
+					
+			DBG("DEBUG %s assigning %d [0x%lx,0x%lx]\n",
+			    bus->self->dev.bus_id, i,
+			    bus->self->resource[i].start,
+			    bus->self->resource[i].end);
+			pci_assign_resource(bus->self, i);
+			DBG("DEBUG %s after assign %d [0x%lx,0x%lx]\n",
+			    bus->self->dev.bus_id, i,
+			    bus->self->resource[i].start,
+			    bus->self->resource[i].end);
+		}
+	}
+
+
+	list_for_each(ln, &bus->devices) {
+		int i;
+
+		dev = pci_dev_b(ln);
+		if (is_card_dino(&dino_dev->hba.dev->id))
+			dino_card_fixup(dev);
+
+		/*
+		** P2PB's only have 2 BARs, no IRQs.
+		** I'd like to just ignore them for now.
+		*/
+		if ((dev->class >> 8) == PCI_CLASS_BRIDGE_PCI)
+			continue;
+
+		/* Adjust the I/O Port space addresses */
+		for (i = 0; i < PCI_NUM_RESOURCES; i++) {
+			struct resource *res = &dev->resource[i];
+			if (res->flags & IORESOURCE_IO) {
+				res->start |= port_base;
+				res->end |= port_base;
+			}
+#ifdef __LP64__
+			/* Sign Extend MMIO addresses */
+			else if (res->flags & IORESOURCE_MEM) {
+				res->start |= F_EXTEND(0UL);
+				res->end   |= F_EXTEND(0UL);
+			}
+#endif
+		}
+		/* null out the ROM resource if there is one (we don't
+		 * care about an expansion rom on parisc, since it
+		 * usually contains (x86) bios code) */
+		dev->resource[PCI_ROM_RESOURCE].flags = 0;
+				
+		if(dev->irq == 255) {
+
+#define DINO_FIX_UNASSIGNED_INTERRUPTS
+#ifdef DINO_FIX_UNASSIGNED_INTERRUPTS
+
+			/* This code tries to assign an unassigned
+			 * interrupt.  Leave it disabled unless you
+			 * *really* know what you're doing since the
+			 * pin<->interrupt line mapping varies by bus
+			 * and machine */
+
+			u32 irq_pin;
+			
+			dino_cfg_read(dev->bus, dev->devfn, 
+				      PCI_INTERRUPT_PIN, 1, &irq_pin);
+			irq_pin = (irq_pin + PCI_SLOT(dev->devfn) - 1) % 4 ;
+			printk(KERN_WARNING "Device %s has undefined IRQ, "
+					"setting to %d\n", pci_name(dev), irq_pin);
+			dino_cfg_write(dev->bus, dev->devfn, 
+				       PCI_INTERRUPT_LINE, 1, irq_pin);
+			dino_assign_irq(dino_dev, irq_pin, &dev->irq);
+#else
+			dev->irq = 65535;
+			printk(KERN_WARNING "Device %s has unassigned IRQ\n", pci_name(dev));
+#endif
+		} else {
+
+			/* Adjust INT_LINE for that busses region */
+			dino_assign_irq(dino_dev, dev->irq, &dev->irq);
+		}
+	}
+}
+
+
+struct pci_bios_ops dino_bios_ops = {
+	.init		= dino_bios_init,
+	.fixup_bus	= dino_fixup_bus
+};
+
+
+/*
+ *	Initialise a DINO controller chip
+ */
+static void __init
+dino_card_init(struct dino_device *dino_dev)
+{
+	u32 brdg_feat = 0x00784e05;
+
+	__raw_writel(0x00000000, dino_dev->hba.base_addr+DINO_GMASK);
+	__raw_writel(0x00000001, dino_dev->hba.base_addr+DINO_IO_FBB_EN);
+	__raw_writel(0x00000000, dino_dev->hba.base_addr+DINO_ICR);
+
+#if 1
+/* REVISIT - should be a runtime check (eg if (CPU_IS_PCX_L) ...) */
+	/*
+	** PCX-L processors don't support XQL like Dino wants it.
+	** PCX-L2 ignore XQL signal and it doesn't matter.
+	*/
+	brdg_feat &= ~0x4;	/* UXQL */
+#endif
+	__raw_writel( brdg_feat, dino_dev->hba.base_addr+DINO_BRDG_FEAT);
+
+	/*
+	** Don't enable address decoding until we know which I/O range
+	** currently is available from the host. Only affects MMIO
+	** and not I/O port space.
+	*/
+	__raw_writel(0x00000000, dino_dev->hba.base_addr+DINO_IO_ADDR_EN);
+
+	__raw_writel(0x00000000, dino_dev->hba.base_addr+DINO_DAMODE);
+	__raw_writel(0x00222222, dino_dev->hba.base_addr+DINO_PCIROR);
+	__raw_writel(0x00222222, dino_dev->hba.base_addr+DINO_PCIWOR);
+
+	__raw_writel(0x00000040, dino_dev->hba.base_addr+DINO_MLTIM);
+	__raw_writel(0x00000080, dino_dev->hba.base_addr+DINO_IO_CONTROL);
+	__raw_writel(0x0000008c, dino_dev->hba.base_addr+DINO_TLTIM);
+
+	/* Disable PAMR before writing PAPR */
+	__raw_writel(0x0000007e, dino_dev->hba.base_addr+DINO_PAMR);
+	__raw_writel(0x0000007f, dino_dev->hba.base_addr+DINO_PAPR);
+	__raw_writel(0x00000000, dino_dev->hba.base_addr+DINO_PAMR);
+
+	/*
+	** Dino ERS encourages enabling FBB (0x6f).
+	** We can't until we know *all* devices below us can support it.
+	** (Something in device configuration header tells us).
+	*/
+	__raw_writel(0x0000004f, dino_dev->hba.base_addr+DINO_PCICMD);
+
+	/* Somewhere, the PCI spec says give devices 1 second
+	** to recover from the #RESET being de-asserted.
+	** Experience shows most devices only need 10ms.
+	** This short-cut speeds up booting significantly.
+	*/
+	mdelay(pci_post_reset_delay);
+}
+
+static int __init
+dino_bridge_init(struct dino_device *dino_dev, const char *name)
+{
+	unsigned long io_addr;
+	int result, i, count=0;
+	struct resource *res, *prevres = NULL;
+	/*
+	 * Decoding IO_ADDR_EN only works for Built-in Dino
+	 * since PDC has already initialized this.
+	 */
+
+	io_addr = __raw_readl(dino_dev->hba.base_addr + DINO_IO_ADDR_EN);
+	if (io_addr == 0) {
+		printk(KERN_WARNING "%s: No PCI devices enabled.\n", name);
+		return -ENODEV;
+	}
+
+	res = &dino_dev->hba.lmmio_space;
+	for (i = 0; i < 32; i++) {
+		unsigned long start, end;
+
+		if((io_addr & (1 << i)) == 0)
+			continue;
+
+		start = (unsigned long)(signed int)(0xf0000000 | (i << 23));
+		end = start + 8 * 1024 * 1024 - 1;
+
+		DBG("DINO RANGE %d is at 0x%lx-0x%lx\n", count,
+		    start, end);
+
+		if(prevres && prevres->end + 1 == start) {
+			prevres->end = end;
+		} else {
+			if(count >= DINO_MAX_LMMIO_RESOURCES) {
+				printk(KERN_ERR "%s is out of resource windows for range %d (0x%lx-0x%lx)\n", name, count, start, end);
+				break;
+			}
+			prevres = res;
+			res->start = start;
+			res->end = end;
+			res->flags = IORESOURCE_MEM;
+			res->name = kmalloc(64, GFP_KERNEL);
+			if(res->name)
+				snprintf((char *)res->name, 64, "%s LMMIO %d",
+					 name, count);
+			res++;
+			count++;
+		}
+	}
+
+	res = &dino_dev->hba.lmmio_space;
+
+	for(i = 0; i < DINO_MAX_LMMIO_RESOURCES; i++) {
+		if(res[i].flags == 0)
+			break;
+
+		result = ccio_request_resource(dino_dev->hba.dev, &res[i]);
+		if (result < 0) {
+			printk(KERN_ERR "%s: failed to claim PCI Bus address space %d (0x%lx-0x%lx)!\n", name, i, res[i].start, res[i].end);
+			return result;
+		}
+	}
+	return 0;
+}
+
+static int __init dino_common_init(struct parisc_device *dev,
+		struct dino_device *dino_dev, const char *name)
+{
+	int status;
+	u32 eim;
+	struct gsc_irq gsc_irq;
+	struct resource *res;
+
+	pcibios_register_hba(&dino_dev->hba);
+
+	pci_bios = &dino_bios_ops;   /* used by pci_scan_bus() */
+	pci_port = &dino_port_ops;
+
+	/*
+	** Note: SMP systems can make use of IRR1/IAR1 registers
+	**   But it won't buy much performance except in very
+	**   specific applications/configurations. Note Dino
+	**   still only has 11 IRQ input lines - just map some of them
+	**   to a different processor.
+	*/
+	dev->irq = gsc_alloc_irq(&gsc_irq);
+	dino_dev->txn_addr = gsc_irq.txn_addr;
+	dino_dev->txn_data = gsc_irq.txn_data;
+	eim = ((u32) gsc_irq.txn_addr) | gsc_irq.txn_data;
+
+	/* 
+	** Dino needs a PA "IRQ" to get a processor's attention.
+	** arch/parisc/kernel/irq.c returns an EIRR bit.
+	*/
+	if (dev->irq < 0) {
+		printk(KERN_WARNING "%s: gsc_alloc_irq() failed\n", name);
+		return 1;
+	}
+
+	status = request_irq(dev->irq, dino_isr, 0, name, dino_dev);
+	if (status) {
+		printk(KERN_WARNING "%s: request_irq() failed with %d\n", 
+			name, status);
+		return 1;
+	}
+
+	/* Support the serial port which is sometimes attached on built-in
+	 * Dino / Cujo chips.
+	 */
+
+	gsc_fixup_irqs(dev, dino_dev, dino_choose_irq);
+
+	/*
+	** This enables DINO to generate interrupts when it sees
+	** any of its inputs *change*. Just asserting an IRQ
+	** before it's enabled (ie unmasked) isn't good enough.
+	*/
+	__raw_writel(eim, dino_dev->hba.base_addr+DINO_IAR0);
+
+	/*
+	** Some platforms don't clear Dino's IRR0 register at boot time.
+	** Reading will clear it now.
+	*/
+	__raw_readl(dino_dev->hba.base_addr+DINO_IRR0);
+
+	/* allocate I/O Port resource region */
+	res = &dino_dev->hba.io_space;
+	if (dev->id.hversion == 0x680 || is_card_dino(&dev->id)) {
+		res->name = "Dino I/O Port";
+	} else {
+		res->name = "Cujo I/O Port";
+	}
+	res->start = HBA_PORT_BASE(dino_dev->hba.hba_num);
+	res->end = res->start + (HBA_PORT_SPACE_SIZE - 1);
+	res->flags = IORESOURCE_IO; /* do not mark it busy ! */
+	if (request_resource(&ioport_resource, res) < 0) {
+		printk(KERN_ERR "%s: request I/O Port region failed "
+		       "0x%lx/%lx (hpa 0x%p)\n",
+		       name, res->start, res->end, dino_dev->hba.base_addr);
+		return 1;
+	}
+
+	return 0;
+}
+
+#define CUJO_RAVEN_ADDR		F_EXTEND(0xf1000000UL)
+#define CUJO_FIREHAWK_ADDR	F_EXTEND(0xf1604000UL)
+#define CUJO_RAVEN_BADPAGE	0x01003000UL
+#define CUJO_FIREHAWK_BADPAGE	0x01607000UL
+
+static const char *dino_vers[] = {
+	"2.0",
+	"2.1",
+	"3.0",
+	"3.1"
+};
+
+static const char *cujo_vers[] = {
+	"1.0",
+	"2.0"
+};
+
+void ccio_cujo20_fixup(struct parisc_device *dev, u32 iovp);
+
+/*
+** Determine if dino should claim this chip (return 0) or not (return 1).
+** If so, initialize the chip appropriately (card-mode vs bridge mode).
+** Much of the initialization is common though.
+*/
+static int __init
+dino_driver_callback(struct parisc_device *dev)
+{
+	struct dino_device *dino_dev;	// Dino specific control struct
+	const char *version = "unknown";
+	char *name;
+	int is_cujo = 0;
+	struct pci_bus *bus;
+	
+	name = "Dino";
+	if (is_card_dino(&dev->id)) {
+		version = "3.x (card mode)";
+	} else {
+		if(dev->id.hversion == 0x680) {
+			if (dev->id.hversion_rev < 4) {
+				version = dino_vers[dev->id.hversion_rev];
+			}
+		} else {
+			name = "Cujo";
+			is_cujo = 1;
+			if (dev->id.hversion_rev < 2) {
+				version = cujo_vers[dev->id.hversion_rev];
+			}
+		}
+	}
+
+	printk("%s version %s found at 0x%lx\n", name, version, dev->hpa);
+
+	if (!request_mem_region(dev->hpa, PAGE_SIZE, name)) {
+		printk(KERN_ERR "DINO: Hey! Someone took my MMIO space (0x%ld)!\n",
+			dev->hpa);
+		return 1;
+	}
+
+	/* Check for bugs */
+	if (is_cujo && dev->id.hversion_rev == 1) {
+#ifdef CONFIG_IOMMU_CCIO
+		printk(KERN_WARNING "Enabling Cujo 2.0 bug workaround\n");
+		if (dev->hpa == (unsigned long)CUJO_RAVEN_ADDR) {
+			ccio_cujo20_fixup(dev, CUJO_RAVEN_BADPAGE);
+		} else if (dev->hpa == (unsigned long)CUJO_FIREHAWK_ADDR) {
+			ccio_cujo20_fixup(dev, CUJO_FIREHAWK_BADPAGE);
+		} else {
+			printk("Don't recognise Cujo at address 0x%lx, not enabling workaround\n", dev->hpa);
+		}
+#endif
+	} else if (!is_cujo && !is_card_dino(&dev->id) &&
+			dev->id.hversion_rev < 3) {
+		printk(KERN_WARNING
+"The GSCtoPCI (Dino hrev %d) bus converter found may exhibit\n"
+"data corruption.  See Service Note Numbers: A4190A-01, A4191A-01.\n"
+"Systems shipped after Aug 20, 1997 will not exhibit this problem.\n"
+"Models affected: C180, C160, C160L, B160L, and B132L workstations.\n\n",
+			dev->id.hversion_rev);
+/* REVISIT: why are C200/C240 listed in the README table but not
+**   "Models affected"? Could be an omission in the original literature.
+*/
+	}
+
+	dino_dev = kmalloc(sizeof(struct dino_device), GFP_KERNEL);
+	if (!dino_dev) {
+		printk("dino_init_chip - couldn't alloc dino_device\n");
+		return 1;
+	}
+
+	memset(dino_dev, 0, sizeof(struct dino_device));
+
+	dino_dev->hba.dev = dev;
+	dino_dev->hba.base_addr = ioremap(dev->hpa, 4096); /* faster access */
+	dino_dev->hba.lmmio_space_offset = 0;	/* CPU addrs == bus addrs */
+	spin_lock_init(&dino_dev->dinosaur_pen);
+	dino_dev->hba.iommu = ccio_get_iommu(dev);
+
+	if (is_card_dino(&dev->id)) {
+		dino_card_init(dino_dev);
+	} else {
+		dino_bridge_init(dino_dev, name);
+	}
+
+	if (dino_common_init(dev, dino_dev, name))
+		return 1;
+
+	dev->dev.platform_data = dino_dev;
+
+	/*
+	** It's not used to avoid chicken/egg problems
+	** with configuration accessor functions.
+	*/
+	bus = pci_scan_bus_parented(&dev->dev, dino_current_bus,
+				    &dino_cfg_ops, NULL);
+	if(bus) {
+		/* This code *depends* on scanning being single threaded
+		 * if it isn't, this global bus number count will fail
+		 */
+		dino_current_bus = bus->subordinate + 1;
+		pci_bus_assign_resources(bus);
+	} else {
+		printk(KERN_ERR "ERROR: failed to scan PCI bus on %s (probably duplicate bus number %d)\n", dev->dev.bus_id, dino_current_bus);
+		/* increment the bus number in case of duplicates */
+		dino_current_bus++;
+	}
+	dino_dev->hba.hba_bus = bus;
+	return 0;
+}
+
+/*
+ * Normally, we would just test sversion.  But the Elroy PCI adapter has
+ * the same sversion as Dino, so we have to check hversion as well.
+ * Unfortunately, the J2240 PDC reports the wrong hversion for the first
+ * Dino, so we have to test for Dino, Cujo and Dino-in-a-J2240.
+ * For card-mode Dino, most machines report an sversion of 9D.  But 715
+ * and 725 firmware misreport it as 0x08080 for no adequately explained
+ * reason.
+ */
+static struct parisc_device_id dino_tbl[] = {
+	{ HPHW_A_DMA, HVERSION_REV_ANY_ID, 0x004, 0x0009D },/* Card-mode Dino */
+	{ HPHW_A_DMA, HVERSION_REV_ANY_ID, HVERSION_ANY_ID, 0x08080 }, /* XXX */
+	{ HPHW_BRIDGE, HVERSION_REV_ANY_ID, 0x680, 0xa }, /* Bridge-mode Dino */
+	{ HPHW_BRIDGE, HVERSION_REV_ANY_ID, 0x682, 0xa }, /* Bridge-mode Cujo */
+	{ HPHW_BRIDGE, HVERSION_REV_ANY_ID, 0x05d, 0xa }, /* Dino in a J2240 */
+	{ 0, }
+};
+
+static struct parisc_driver dino_driver = {
+	.name =		"Dino",
+	.id_table =	dino_tbl,
+	.probe =	dino_driver_callback,
+};
+
+/*
+ * One time initialization to let the world know Dino is here.
+ * This is the only routine which is NOT static.
+ * Must be called exactly once before pci_init().
+ */
+int __init dino_init(void)
+{
+	register_parisc_driver(&dino_driver);
+	return 0;
+}
+
