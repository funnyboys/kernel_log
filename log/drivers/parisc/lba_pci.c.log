commit 4bdc0d676a643140bdf17dbf7eafedee3d496a3c
Author: Christoph Hellwig <hch@lst.de>
Date:   Mon Jan 6 09:43:50 2020 +0100

    remove ioremap_nocache and devm_ioremap_nocache
    
    ioremap has provided non-cached semantics by default since the Linux 2.6
    days, so remove the additional ioremap_nocache interface.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Acked-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/drivers/parisc/lba_pci.c b/drivers/parisc/lba_pci.c
index a99e385c68bd..732b516c7bf8 100644
--- a/drivers/parisc/lba_pci.c
+++ b/drivers/parisc/lba_pci.c
@@ -1134,7 +1134,7 @@ lba_pat_resources(struct parisc_device *pa_dev, struct lba_device *lba_dev)
 			** Postable I/O port space is per PCI host adapter.
 			** base of 64MB PIOP region
 			*/
-			lba_dev->iop_base = ioremap_nocache(p->start, 64 * 1024 * 1024);
+			lba_dev->iop_base = ioremap(p->start, 64 * 1024 * 1024);
 
 			sprintf(lba_dev->hba.io_name, "PCI%02x Ports",
 					(int)lba_dev->hba.bus_num.start);
@@ -1476,7 +1476,7 @@ lba_driver_probe(struct parisc_device *dev)
 	u32 func_class;
 	void *tmp_obj;
 	char *version;
-	void __iomem *addr = ioremap_nocache(dev->hpa.start, 4096);
+	void __iomem *addr = ioremap(dev->hpa.start, 4096);
 	int max;
 
 	/* Read HW Rev First */
@@ -1575,7 +1575,7 @@ lba_driver_probe(struct parisc_device *dev)
 	} else {
 		if (!astro_iop_base) {
 			/* Sprockets PDC uses NPIOP region */
-			astro_iop_base = ioremap_nocache(LBA_PORT_BASE, 64 * 1024);
+			astro_iop_base = ioremap(LBA_PORT_BASE, 64 * 1024);
 			pci_port = &lba_astro_port_ops;
 		}
 
@@ -1693,7 +1693,7 @@ void __init lba_init(void)
 */
 void lba_set_iregs(struct parisc_device *lba, u32 ibase, u32 imask)
 {
-	void __iomem * base_addr = ioremap_nocache(lba->hpa.start, 4096);
+	void __iomem * base_addr = ioremap(lba->hpa.start, 4096);
 
 	imask <<= 2;	/* adjust for hints - 2 more bits */
 

commit 2874c5fd284268364ece81a7bd936f3c8168e567
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:01 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 152
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 3029 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070032.746973796@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/parisc/lba_pci.c b/drivers/parisc/lba_pci.c
index d4701589bc8c..a99e385c68bd 100644
--- a/drivers/parisc/lba_pci.c
+++ b/drivers/parisc/lba_pci.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
 **
 **  PCI Lower Bus Adapter (LBA) manager
@@ -5,10 +6,6 @@
 **	(c) Copyright 1999,2000 Grant Grundler
 **	(c) Copyright 1999,2000 Hewlett-Packard Company
 **
-**	This program is free software; you can redistribute it and/or modify
-**	it under the terms of the GNU General Public License as published by
-**      the Free Software Foundation; either version 2 of the License, or
-**      (at your option) any later version.
 **
 **
 ** This module primarily provides access to PCI bus (config/IOport

commit 3654f012115db37d31e3628b26b116dc650922ac
Author: Christoph Hellwig <hch@lst.de>
Date:   Tue Jan 29 19:13:10 2019 +0100

    parisc: remove the HBA_DATA macro
    
    No need to hide a cast in a macro, especially as all users have
    cleaner ways to archive the result than blind casting.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Helge Deller <deller@gmx.de>

diff --git a/drivers/parisc/lba_pci.c b/drivers/parisc/lba_pci.c
index 3c4a2e7f8010..d4701589bc8c 100644
--- a/drivers/parisc/lba_pci.c
+++ b/drivers/parisc/lba_pci.c
@@ -1275,7 +1275,7 @@ lba_legacy_resources(struct parisc_device *pa_dev, struct lba_device *lba_dev)
 		r->flags = IORESOURCE_MEM;
 		/* mmio_mask also clears Enable bit */
 		r->start &= mmio_mask;
-		r->start = PCI_HOST_ADDR(HBA_DATA(lba_dev), r->start);
+		r->start = PCI_HOST_ADDR(&lba_dev->hba, r->start);
 		rsize = ~ READ_REG32(lba_dev->hba.base_addr + LBA_LMMIO_MASK);
 
 		/*
@@ -1321,7 +1321,7 @@ lba_legacy_resources(struct parisc_device *pa_dev, struct lba_device *lba_dev)
 		r->flags = IORESOURCE_MEM;
 		/* mmio_mask also clears Enable bit */
 		r->start &= mmio_mask;
-		r->start = PCI_HOST_ADDR(HBA_DATA(lba_dev), r->start);
+		r->start = PCI_HOST_ADDR(&lba_dev->hba, r->start);
 		rsize = READ_REG32(lba_dev->hba.base_addr + LBA_ELMMIO_MASK);
 		r->end = r->start + ~rsize;
 	}
@@ -1562,7 +1562,7 @@ lba_driver_probe(struct parisc_device *dev)
 
 	/* ------------ Second : initialize common stuff ---------- */
 	pci_bios = &lba_bios_ops;
-	pcibios_register_hba(HBA_DATA(lba_dev));
+	pcibios_register_hba(&lba_dev->hba);
 	spin_lock_init(&lba_dev->lba_lock);
 
 	if (lba_hw_init(lba_dev))

commit 5007526700a0e13b15ef02c7495786f882d0cc0b
Author: Christoph Hellwig <hch@lst.de>
Date:   Tue Jan 29 19:13:09 2019 +0100

    parisc/lba_pci: use container_of in LBA_DEV
    
    Use the type safe container_of macros instead of a blind cast in
    LBA_DEV, and turn the macro into an inline function.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Helge Deller <deller@gmx.de>

diff --git a/drivers/parisc/lba_pci.c b/drivers/parisc/lba_pci.c
index dcea15588833..3c4a2e7f8010 100644
--- a/drivers/parisc/lba_pci.c
+++ b/drivers/parisc/lba_pci.c
@@ -111,12 +111,10 @@ static u32 lba_t32;
 
 #define LBA_SKIP_PROBE(d) ((d)->flags & LBA_FLAG_SKIP_PROBE)
 
-
-/* Looks nice and keeps the compiler happy */
-#define LBA_DEV(d) ({				\
-	void *__pdata = d;			\
-	BUG_ON(!__pdata);			\
-	(struct lba_device *)__pdata; })
+static inline struct lba_device *LBA_DEV(struct pci_hba_data *hba)
+{
+	return container_of(hba, struct lba_device, hba);
+}
 
 /*
 ** Only allow 8 subsidiary busses per LBA

commit 9b8eeab019762fa43c5ffa6e2f8e1039f8e99157
Author: Christoph Hellwig <hch@lst.de>
Date:   Tue Jan 29 19:13:04 2019 +0100

    parisc: move internal implementation details out of <asm/dma-mapping.h>
    
    Move everything that is not required for the public facing DMA API out
    of <asm/dma-mapping.h> and into a new drivers/parisc/iommu.h header.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Helge Deller <deller@gmx.de>

diff --git a/drivers/parisc/lba_pci.c b/drivers/parisc/lba_pci.c
index d376201bc6a0..dcea15588833 100644
--- a/drivers/parisc/lba_pci.c
+++ b/drivers/parisc/lba_pci.c
@@ -49,6 +49,8 @@
 #include <asm/parisc-device.h>
 #include <asm/io.h>		/* read/write stuff */
 
+#include "iommu.h"
+
 #undef DEBUG_LBA	/* general stuff */
 #undef DEBUG_LBA_PORT	/* debug I/O Port access */
 #undef DEBUG_LBA_CFG	/* debug Config Space Access (ie PCI Bus walk) */

commit 81fe5bba88a3fbe34ee6c5d18e327c6aaacd588c
Author: Helge Deller <deller@gmx.de>
Date:   Wed Dec 26 20:46:27 2018 +0100

    parisc: Hide built-in serial aux port of Tosca GSP card
    
    Similar to commit bcf3f1752a62 ("parisc: Hide Diva-built-in serial aux and
    graphics card") it's better to hide the built-in serial AUX port at bootup.
    When not hiding the port, the Linux serial driver will try to manage this port
    and fails on a A500 server like this:
    
     serial 0000:00:05.0: enabling device (0000 -> 0003)
     serial 0000:00:05.0: enabling SERR and PARITY (0003 -> 0143)
     0000:00:05.0: ttyS3 at MMIO 0xfffffffff8005000 (irq = 71, base_baud = 115200) is a 16550A
     serial 0000:00:05.0: Couldn't register serial port 0, irq 71, type 2, error -28
    
    Signed-off-by: Helge Deller <deller@gmx.de>

diff --git a/drivers/parisc/lba_pci.c b/drivers/parisc/lba_pci.c
index 69bd98421eb1..d376201bc6a0 100644
--- a/drivers/parisc/lba_pci.c
+++ b/drivers/parisc/lba_pci.c
@@ -1743,3 +1743,15 @@ static void quirk_diva_aux_disable(struct pci_dev *dev)
 }
 DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_HP, PCI_DEVICE_ID_HP_DIVA_AUX,
 	quirk_diva_aux_disable);
+
+static void quirk_tosca_aux_disable(struct pci_dev *dev)
+{
+	if (dev->subsystem_vendor != PCI_VENDOR_ID_HP ||
+	    dev->subsystem_device != 0x104a)
+		return;
+
+	dev_info(&dev->dev, "Hiding Tosca secondary built-in AUX serial device");
+	dev->device = 0;
+}
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_HP, PCI_DEVICE_ID_HP_DIVA,
+	quirk_tosca_aux_disable);

commit b845f66f78bf42a4ce98e5cfe0e94fab41dd0742
Author: Helge Deller <deller@gmx.de>
Date:   Sun Mar 25 14:04:22 2018 +0200

    parisc/pci: Switch LBA PCI bus from Hard Fail to Soft Fail mode
    
    Carlo Pisani noticed that his C3600 workstation behaved unstable during heavy
    I/O on the PCI bus with a VIA VT6421 IDE/SATA PCI card.
    
    To avoid such instability, this patch switches the LBA PCI bus from Hard Fail
    mode into Soft Fail mode. In this mode the bus will return -1UL for timed out
    MMIO transactions, which is exactly how the x86 (and most other architectures)
    PCI busses behave.
    
    This patch is based on a proposal by Grant Grundler and Kyle McMartin 10
    years ago:
    https://www.spinics.net/lists/linux-parisc/msg01027.html
    
    Cc: Carlo Pisani <carlojpisani@gmail.com>
    Cc: Kyle McMartin <kyle@mcmartin.ca>
    Reviewed-by: Grant Grundler <grantgrundler@gmail.com>
    Signed-off-by: Helge Deller <deller@gmx.de>

diff --git a/drivers/parisc/lba_pci.c b/drivers/parisc/lba_pci.c
index 41b740aed3a3..69bd98421eb1 100644
--- a/drivers/parisc/lba_pci.c
+++ b/drivers/parisc/lba_pci.c
@@ -1403,9 +1403,27 @@ lba_hw_init(struct lba_device *d)
 		WRITE_REG32(stat, d->hba.base_addr + LBA_ERROR_CONFIG);
 	}
 
-	/* Set HF mode as the default (vs. -1 mode). */
+
+	/*
+	 * Hard Fail vs. Soft Fail on PCI "Master Abort".
+	 *
+	 * "Master Abort" means the MMIO transaction timed out - usually due to
+	 * the device not responding to an MMIO read. We would like HF to be
+	 * enabled to find driver problems, though it means the system will
+	 * crash with a HPMC.
+	 *
+	 * In SoftFail mode "~0L" is returned as a result of a timeout on the
+	 * pci bus. This is like how PCI busses on x86 and most other
+	 * architectures behave.  In order to increase compatibility with
+	 * existing (x86) PCI hardware and existing Linux drivers we enable
+	 * Soft Faul mode on PA-RISC now too.
+	 */
         stat = READ_REG32(d->hba.base_addr + LBA_STAT_CTL);
+#if defined(ENABLE_HARDFAIL)
 	WRITE_REG32(stat | HF_ENABLE, d->hba.base_addr + LBA_STAT_CTL);
+#else
+	WRITE_REG32(stat & ~HF_ENABLE, d->hba.base_addr + LBA_STAT_CTL);
+#endif
 
 	/*
 	** Writing a zero to STAT_CTL.rf (bit 0) will clear reset signal

commit bcf3f1752a622f1372d3252d0fea8855d89812e7
Author: Helge Deller <deller@gmx.de>
Date:   Tue Dec 12 21:52:26 2017 +0100

    parisc: Hide Diva-built-in serial aux and graphics card
    
    Diva GSP card has built-in serial AUX port and ATI graphic card which simply
    don't work and which both don't have external connectors.  User Guides even
    mention that those devices shouldn't be used.
    So, prevent that Linux drivers try to enable those devices.
    
    Signed-off-by: Helge Deller <deller@gmx.de>
    Cc: <stable@vger.kernel.org> # v3.0+

diff --git a/drivers/parisc/lba_pci.c b/drivers/parisc/lba_pci.c
index a25fed52f7e9..41b740aed3a3 100644
--- a/drivers/parisc/lba_pci.c
+++ b/drivers/parisc/lba_pci.c
@@ -1692,3 +1692,36 @@ void lba_set_iregs(struct parisc_device *lba, u32 ibase, u32 imask)
 	iounmap(base_addr);
 }
 
+
+/*
+ * The design of the Diva management card in rp34x0 machines (rp3410, rp3440)
+ * seems rushed, so that many built-in components simply don't work.
+ * The following quirks disable the serial AUX port and the built-in ATI RV100
+ * Radeon 7000 graphics card which both don't have any external connectors and
+ * thus are useless, and even worse, e.g. the AUX port occupies ttyS0 and as
+ * such makes those machines the only PARISC machines on which we can't use
+ * ttyS0 as boot console.
+ */
+static void quirk_diva_ati_card(struct pci_dev *dev)
+{
+	if (dev->subsystem_vendor != PCI_VENDOR_ID_HP ||
+	    dev->subsystem_device != 0x1292)
+		return;
+
+	dev_info(&dev->dev, "Hiding Diva built-in ATI card");
+	dev->device = 0;
+}
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_ATI, PCI_DEVICE_ID_ATI_RADEON_QY,
+	quirk_diva_ati_card);
+
+static void quirk_diva_aux_disable(struct pci_dev *dev)
+{
+	if (dev->subsystem_vendor != PCI_VENDOR_ID_HP ||
+	    dev->subsystem_device != 0x1291)
+		return;
+
+	dev_info(&dev->dev, "Hiding Diva built-in AUX serial device");
+	dev->device = 0;
+}
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_HP, PCI_DEVICE_ID_HP_DIVA_AUX,
+	quirk_diva_aux_disable);

commit d81f734462d439291531266c4004ab97e9a033cc
Author: Helge Deller <deller@gmx.de>
Date:   Wed Aug 16 18:53:16 2017 +0200

    parisc: Fix up devices below a PCI-PCI MegaRAID controller bridge
    
    A MegaRAID PCI card in my rp5470 acts as PCI-PCI bridge.
    Resource allocation for PCI devices behind such a bridge is quite incomplete,
    so that syslog reports those warnings:
    
     LBA 0:10: PCI host bridge to bus 0000:50
     pci_bus 0000:50: root bus resource [io  0x80000-0x8ffff] (bus address [0x0000-0xffff])
     pci_bus 0000:50: root bus resource [mem 0xffffffff94000000-0xffffffff95ffffff] (bus address [0x94000000-0x95ffffff])
     pci_bus 0000:50: root bus resource [bus 50-57]
     pci 0000:50:00.0: [8086:0964] type 01 class 0x060400
     pci 0000:50:00.1: [8086:1960] type 00 class 0x0e0001
     pci 0000:50:00.1: reg 0x10: [mem 0x00000000-0x003fffff pref]
     pci 0000:50:00.1: reg 0x30: [mem 0x00000000-0x00007fff pref]
     pci 0000:50:00.0: Changing bridge control from 0x00000000 to 0x00000023
     pci_bus 0000:51: busn_res: can not insert [bus 51-ff] under [bus 50-57] (conflicts with (null) [bus 50-57])
     pci 0000:50:00.0: PCI bridge to [bus 51-ff]
     pci 0000:50:00.0:   bridge window [io  0x80000-0x80fff]
     pci 0000:50:00.0:   bridge window [mem 0x00000000-0x000fffff]
     pci 0000:50:00.0:   bridge window [mem 0x00000000-0x000fffff pref]
     pci 0000:50:00.0: can't claim BAR 14 [mem 0x00000000-0x000fffff]: no compatible bridge window
     pci 0000:50:00.0: can't claim BAR 15 [mem 0x00000000-0x000fffff pref]: no compatible bridge window
     pci 0000:50:00.0: can't claim BAR 16 [??? 0x00000000 flags 0x0]: no compatible bridge window
     pci_bus 0000:51: busn_res: [bus 51-ff] end is updated to 51
     pci 0000:50:00.0: BAR 16: [??? 0x00000000 flags 0x20000000] has bogus alignment
     pci 0000:50:00.1: BAR 0: assigned [mem 0xffffffff94000000-0xffffffff943fffff pref]
     pci 0000:50:00.0: BAR 14: assigned [mem 0xffffffff94400000-0xffffffff944fffff]
     pci 0000:50:00.0: BAR 15: assigned [mem 0xffffffff94500000-0xffffffff945fffff pref]
     pci 0000:50:00.1: BAR 6: assigned [mem 0xffffffff94600000-0xffffffff94607fff pref]
     pci 0000:50:00.0: PCI bridge to [bus 51]
     pci 0000:50:00.0:   bridge window [io  0x80000-0x80fff]
     pci 0000:50:00.0:   bridge window [mem 0xffffffff94400000-0xffffffff944fffff]
     pci 0000:50:00.0:   bridge window [mem 0xffffffff94500000-0xffffffff945fffff pref]
    
    The patch below tries to improve the resource allocation.
    Output is now:
    
     LBA 0:10: PCI host bridge to bus 0000:50
     pci_bus 0000:50: root bus resource [io  0x80000-0x8ffff] (bus address [0x0000-0xffff])
     pci_bus 0000:50: root bus resource [mem 0xffffffff94000000-0xffffffff95ffffff] (bus address [0x94000000-0x95ffffff])
     pci_bus 0000:50: root bus resource [bus 50-57]
     pci 0000:50:00.0: Changing bridge control from 0x00000000 to 0x00000023
     pci 0000:50:00.0: PCI bridge to [bus 51-ff]
     pci 0000:50:00.1: BAR 0: assigned [mem 0xffffffff94000000-0xffffffff943fffff pref]
     pci 0000:50:00.1: BAR 6: assigned [mem 0xffffffff94400000-0xffffffff94407fff pref]
     pci 0000:50:00.0: PCI bridge to [bus 51]
     pci 0000:50:00.0:   bridge window [io  0x80000-0x80fff]
    
    Signed-off-by: Helge Deller <deller@gmx.de>

diff --git a/drivers/parisc/lba_pci.c b/drivers/parisc/lba_pci.c
index 0cc6d5cc5d66..a25fed52f7e9 100644
--- a/drivers/parisc/lba_pci.c
+++ b/drivers/parisc/lba_pci.c
@@ -667,6 +667,42 @@ extend_lmmio_len(unsigned long start, unsigned long end, unsigned long lba_len)
 #define truncate_pat_collision(r,n)  (0)
 #endif
 
+static void pcibios_allocate_bridge_resources(struct pci_dev *dev)
+{
+	int idx;
+	struct resource *r;
+
+	for (idx = PCI_BRIDGE_RESOURCES; idx < PCI_NUM_RESOURCES; idx++) {
+		r = &dev->resource[idx];
+		if (!r->flags)
+			continue;
+		if (r->parent)	/* Already allocated */
+			continue;
+		if (!r->start || pci_claim_bridge_resource(dev, idx) < 0) {
+			/*
+			 * Something is wrong with the region.
+			 * Invalidate the resource to prevent
+			 * child resource allocations in this
+			 * range.
+			 */
+			r->start = r->end = 0;
+			r->flags = 0;
+		}
+	}
+}
+
+static void pcibios_allocate_bus_resources(struct pci_bus *bus)
+{
+	struct pci_bus *child;
+
+	/* Depth-First Search on bus tree */
+	if (bus->self)
+		pcibios_allocate_bridge_resources(bus->self);
+	list_for_each_entry(child, &bus->children, node)
+		pcibios_allocate_bus_resources(child);
+}
+
+
 /*
 ** The algorithm is generic code.
 ** But it needs to access local data structures to get the IRQ base.
@@ -693,11 +729,11 @@ lba_fixup_bus(struct pci_bus *bus)
 	** pci_alloc_primary_bus() mangles this.
 	*/
 	if (bus->parent) {
-		int i;
 		/* PCI-PCI Bridge */
 		pci_read_bridge_bases(bus);
-		for (i = PCI_BRIDGE_RESOURCES; i < PCI_NUM_RESOURCES; i++)
-			pci_claim_bridge_resource(bus->self, i);
+
+		/* check and allocate bridge resources */
+		pcibios_allocate_bus_resources(bus);
 	} else {
 		/* Host-PCI Bridge */
 		int err;

commit cfe4fbfb23b3280e9a4d1c3b8438c1558a6a614d
Author: Helge Deller <deller@gmx.de>
Date:   Mon Aug 21 22:02:19 2017 +0200

    parisc: Fix section mismatches in parisc core drivers
    
    Signed-off-by: Helge Deller <deller@gmx.de>

diff --git a/drivers/parisc/lba_pci.c b/drivers/parisc/lba_pci.c
index bc286cbbbc9b..0cc6d5cc5d66 100644
--- a/drivers/parisc/lba_pci.c
+++ b/drivers/parisc/lba_pci.c
@@ -1613,14 +1613,14 @@ lba_driver_probe(struct parisc_device *dev)
 	return 0;
 }
 
-static struct parisc_device_id lba_tbl[] = {
+static const struct parisc_device_id lba_tbl[] __initconst = {
 	{ HPHW_BRIDGE, HVERSION_REV_ANY_ID, ELROY_HVERS, 0xa },
 	{ HPHW_BRIDGE, HVERSION_REV_ANY_ID, MERCURY_HVERS, 0xa },
 	{ HPHW_BRIDGE, HVERSION_REV_ANY_ID, QUICKSILVER_HVERS, 0xa },
 	{ 0, }
 };
 
-static struct parisc_driver lba_driver = {
+static struct parisc_driver lba_driver __refdata = {
 	.name =		MODULE_NAME,
 	.id_table =	lba_tbl,
 	.probe =	lba_driver_probe,

commit 33f9e02495d15a061f0c94ef46f5103a2d0c20f3
Author: Thomas Bogendoerfer <tsbogend@alpha.franken.de>
Date:   Mon Jul 3 10:38:05 2017 +0200

    parisc: DMA API: return error instead of BUG_ON for dma ops on non dma devs
    
    Enabling parport pc driver on a B2600 (and probably other 64bit PARISC
    systems) produced following BUG:
    
    CPU: 0 PID: 1 Comm: swapper Not tainted 4.12.0-rc5-30198-g1132d5e #156
    task: 000000009e050000 task.stack: 000000009e04c000
    
         YZrvWESTHLNXBCVMcbcbcbcbOGFRQPDI
    PSW: 00001000000001101111111100001111 Not tainted
    r00-03  000000ff0806ff0f 000000009e04c990 0000000040871b78 000000009e04cac0
    r04-07  0000000040c14de0 ffffffffffffffff 000000009e07f098 000000009d82d200
    r08-11  000000009d82d210 0000000000000378 0000000000000000 0000000040c345e0
    r12-15  0000000000000005 0000000040c345e0 0000000000000000 0000000040c9d5e0
    r16-19  0000000040c345e0 00000000f00001c4 00000000f00001bc 0000000000000061
    r20-23  000000009e04ce28 0000000000000010 0000000000000010 0000000040b89e40
    r24-27  0000000000000003 0000000000ffffff 000000009d82d210 0000000040c14de0
    r28-31  0000000000000000 000000009e04ca90 000000009e04cb40 0000000000000000
    sr00-03  0000000000000000 0000000000000000 0000000000000000 0000000000000000
    sr04-07  0000000000000000 0000000000000000 0000000000000000 0000000000000000
    
    IASQ: 0000000000000000 0000000000000000 IAOQ: 00000000404aece0 00000000404aece4
     IIR: 03ffe01f    ISR: 0000000010340000  IOR: 000001781304cac8
     CPU:        0   CR30: 000000009e04c000 CR31: 00000000e2976de2
     ORIG_R28: 0000000000000200
     IAOQ[0]: sba_dma_supported+0x80/0xd0
     IAOQ[1]: sba_dma_supported+0x84/0xd0
     RP(r2): parport_pc_probe_port+0x178/0x1200
    
    Cause is a call to dma_coerce_mask_and_coherenet in parport_pc_probe_port,
    which PARISC DMA API doesn't handle very nicely. This commit gives back
    DMA_ERROR_CODE for DMA API calls, if device isn't capable of DMA
    transaction.
    
    Cc: <stable@vger.kernel.org> # v3.13+
    Signed-off-by: Thomas Bogendoerfer <tsbogend@alpha.franken.de>
    Signed-off-by: Helge Deller <deller@gmx.de>

diff --git a/drivers/parisc/lba_pci.c b/drivers/parisc/lba_pci.c
index 2ec2aef4d211..bc286cbbbc9b 100644
--- a/drivers/parisc/lba_pci.c
+++ b/drivers/parisc/lba_pci.c
@@ -111,8 +111,10 @@ static u32 lba_t32;
 
 
 /* Looks nice and keeps the compiler happy */
-#define LBA_DEV(d) ((struct lba_device *) (d))
-
+#define LBA_DEV(d) ({				\
+	void *__pdata = d;			\
+	BUG_ON(!__pdata);			\
+	(struct lba_device *)__pdata; })
 
 /*
 ** Only allow 8 subsidiary busses per LBA

commit 602c9c9a01a4f0ef091295ac75c74c7fe94d69a4
Author: Helge Deller <deller@gmx.de>
Date:   Mon Dec 21 10:00:49 2015 +0100

    parisc: Initialize PCI bridge cache line and default latency
    
    PCI controllers and pci-pci bridges may have not been fully initialized
    regarding cache line and defaul latency.
    
    This partly reverts
    commit 5f0e9b4 ("parisc: Remove unused pcibios_init_bus()")
    
    Signed-off-by: Helge Deller <deller@gmx.de>

diff --git a/drivers/parisc/lba_pci.c b/drivers/parisc/lba_pci.c
index 42844c2bc065..2ec2aef4d211 100644
--- a/drivers/parisc/lba_pci.c
+++ b/drivers/parisc/lba_pci.c
@@ -790,8 +790,10 @@ lba_fixup_bus(struct pci_bus *bus)
                 /*
 		** P2PB's have no IRQs. ignore them.
 		*/
-		if ((dev->class >> 8) == PCI_CLASS_BRIDGE_PCI)
+		if ((dev->class >> 8) == PCI_CLASS_BRIDGE_PCI) {
+			pcibios_init_bridge(dev);
 			continue;
+		}
 
 		/* Adjust INTERRUPT_LINE for this dev */
 		iosapic_fixup_irq(ldev->iosapic_obj, dev);

commit b696e5e93835cee114f24b5b106c73f9f8503ec0
Author: Helge Deller <deller@gmx.de>
Date:   Thu Oct 22 15:45:18 2015 +0200

    parisc: reduce syslog debug output
    
    Signed-off-by: Helge Deller <deller@gmx.de>

diff --git a/drivers/parisc/lba_pci.c b/drivers/parisc/lba_pci.c
index a32c1f6c252c..42844c2bc065 100644
--- a/drivers/parisc/lba_pci.c
+++ b/drivers/parisc/lba_pci.c
@@ -624,6 +624,10 @@ extend_lmmio_len(unsigned long start, unsigned long end, unsigned long lba_len)
 {
 	struct resource *tmp;
 
+	/* exit if not a C8000 */
+	if (boot_cpu_data.cpu_type < mako)
+		return end;
+
 	pr_debug("LMMIO mismatch: PAT length = 0x%lx, MASK register = 0x%lx\n",
 		end - start, lba_len);
 
@@ -631,10 +635,6 @@ extend_lmmio_len(unsigned long start, unsigned long end, unsigned long lba_len)
 
 	pr_debug("LBA: lmmio_space [0x%lx-0x%lx] - original\n", start, end);
 
-	if (boot_cpu_data.cpu_type < mako) {
-		pr_info("LBA: Not a C8000 system - not extending LMMIO range.\n");
-		return end;
-	}
 
 	end += lba_len;
 	if (end < start) /* fix overflow */
@@ -1557,9 +1557,9 @@ lba_driver_probe(struct parisc_device *dev)
 		pci_add_resource_offset(&resources, &lba_dev->hba.lmmio_space,
 					lba_dev->hba.lmmio_space_offset);
 	if (lba_dev->hba.gmmio_space.flags) {
+		/* Not registering GMMIO space - according to docs it's not
+		 * even used on HP-UX. */
 		/* pci_add_resource(&resources, &lba_dev->hba.gmmio_space); */
-		pr_warn("LBA: Not registering GMMIO space %pR\n",
-			&lba_dev->hba.gmmio_space);
 	}
 
 	pci_add_resource(&resources, &lba_dev->hba.bus_num);

commit 237865f195f6b10e4724ce49eeb3972641da882a
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Tue Sep 15 13:18:04 2015 -0500

    PCI: Revert "PCI: Call pci_read_bridge_bases() from core instead of arch code"
    
    Revert dff22d2054b5 ("PCI: Call pci_read_bridge_bases() from core instead
    of arch code").
    
    Reading PCI bridge windows is not arch-specific in itself, but there is PCI
    core code that doesn't work correctly if we read them too early.  For
    example, Hannes found this case on an ARM Freescale i.mx6 board:
    
      pci_bus 0000:00: root bus resource [mem 0x01000000-0x01efffff]
      pci 0000:00:00.0: PCI bridge to [bus 01-ff]
      pci 0000:00:00.0: BAR 8: no space for [mem size 0x01000000] (mem window)
      pci 0000:01:00.0: BAR 2: failed to assign [mem size 0x00200000]
      pci 0000:01:00.0: BAR 1: failed to assign [mem size 0x00004000]
      pci 0000:01:00.0: BAR 0: failed to assign [mem size 0x00000100]
    
    The 00:00.0 mem window needs to be at least 3MB: the 01:00.0 device needs
    0x204100 of space, and mem windows are megabyte-aligned.
    
    Bus sizing can increase a bridge window size, but never *decrease* it (see
    d65245c3297a ("PCI: don't shrink bridge resources")).  Prior to
    dff22d2054b5, ARM didn't read bridge windows at all, so the "original size"
    was zero, and we assigned a 3MB window.
    
    After dff22d2054b5, we read the bridge windows before sizing the bus.  The
    firmware programmed a 16MB window (size 0x01000000) in 00:00.0, and since
    we never decrease the size, we kept 16MB even though we only needed 3MB.
    But 16MB doesn't fit in the host bridge aperture, so we failed to assign
    space for the window and the downstream devices.
    
    I think this is a defect in the PCI core: we shouldn't rely on the firmware
    to assign sensible windows.
    
    Ray reported a similar problem, also on ARM, with Broadcom iProc.
    
    Issues like this are too hard to fix right now, so revert dff22d2054b5.
    
    Reported-by: Hannes <oe5hpm@gmail.com>
    Reported-by: Ray Jui <rjui@broadcom.com>
    Link: http://lkml.kernel.org/r/CAAa04yFQEUJm7Jj1qMT57-LG7ZGtnhNDBe=PpSRa70Mj+XhW-A@mail.gmail.com
    Link: http://lkml.kernel.org/r/55F75BB8.4070405@broadcom.com
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Yinghai Lu <yinghai@kernel.org>
    Acked-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>

diff --git a/drivers/parisc/lba_pci.c b/drivers/parisc/lba_pci.c
index 7b9e89ba0465..a32c1f6c252c 100644
--- a/drivers/parisc/lba_pci.c
+++ b/drivers/parisc/lba_pci.c
@@ -693,6 +693,7 @@ lba_fixup_bus(struct pci_bus *bus)
 	if (bus->parent) {
 		int i;
 		/* PCI-PCI Bridge */
+		pci_read_bridge_bases(bus);
 		for (i = PCI_BRIDGE_RESOURCES; i < PCI_NUM_RESOURCES; i++)
 			pci_claim_bridge_resource(bus->self, i);
 	} else {

commit e02a653e15d8d32e9e768fd99a3271aafe5c5d77
Author: Helge Deller <deller@gmx.de>
Date:   Wed Sep 2 18:17:29 2015 +0200

    PCI,parisc: Enable 64-bit bus addresses on PA-RISC
    
    Commit 3a9ad0b ("PCI: Add pci_bus_addr_t") unconditionally introduced usage of
    64-bit PCI bus addresses on all 64-bit platforms which broke PA-RISC.
    
    It turned out that due to enabling the 64-bit addresses, the PCI logic decided
    to use the GMMIO instead of the LMMIO region. This commit simply disables
    registering the GMMIO and thus we fall back to use the LMMIO region as before.
    
    Reverts commit 45ea2a5fed6dacb9bb0558d8b21eacc1c45d5bb4
    ("PCI: Don't use 64-bit bus addresses on PA-RISC")
    
    To: linux-parisc@vger.kernel.org
    Cc: linux-pci@vger.kernel.org
    Cc: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Meelis Roos <mroos@linux.ee>
    Cc: stable@vger.kernel.org  # v3.19+
    Signed-off-by: Helge Deller <deller@gmx.de>

diff --git a/drivers/parisc/lba_pci.c b/drivers/parisc/lba_pci.c
index 901e1a3fa4e2..7b9e89ba0465 100644
--- a/drivers/parisc/lba_pci.c
+++ b/drivers/parisc/lba_pci.c
@@ -1555,8 +1555,11 @@ lba_driver_probe(struct parisc_device *dev)
 	if (lba_dev->hba.lmmio_space.flags)
 		pci_add_resource_offset(&resources, &lba_dev->hba.lmmio_space,
 					lba_dev->hba.lmmio_space_offset);
-	if (lba_dev->hba.gmmio_space.flags)
-		pci_add_resource(&resources, &lba_dev->hba.gmmio_space);
+	if (lba_dev->hba.gmmio_space.flags) {
+		/* pci_add_resource(&resources, &lba_dev->hba.gmmio_space); */
+		pr_warn("LBA: Not registering GMMIO space %pR\n",
+			&lba_dev->hba.gmmio_space);
+	}
 
 	pci_add_resource(&resources, &lba_dev->hba.bus_num);
 

commit dff22d2054b5dbb1889f20c03959dd0c494fab8c
Author: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
Date:   Thu Jul 9 11:59:16 2015 +0100

    PCI: Call pci_read_bridge_bases() from core instead of arch code
    
    When we scan a PCI bus, we read PCI-PCI bridge window registers with
    pci_read_bridge_bases() so we can validate the resource hierarchy.  Most
    architectures call pci_read_bridge_bases() from pcibios_fixup_bus(), but
    PCI-PCI bridges are not arch-specific, so this doesn't need to be in
    arch-specific code.
    
    Call pci_read_bridge_bases() directly from the PCI core instead of from
    arch code.
    
    For alpha and mips, we now call pci_read_bridge_bases() always; previously
    we only called it if PCI_PROBE_ONLY was set.
    
    [bhelgaas: changelog]
    Signed-off-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    CC: Ralf Baechle <ralf@linux-mips.org>
    CC: James E.J. Bottomley <jejb@parisc-linux.org>
    CC: Michael Ellerman <mpe@ellerman.id.au>
    CC: Bjorn Helgaas <bhelgaas@google.com>
    CC: Richard Henderson <rth@twiddle.net>
    CC: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    CC: David Howells <dhowells@redhat.com>
    CC: Russell King <linux@arm.linux.org.uk>
    CC: Tony Luck <tony.luck@intel.com>
    CC: David S. Miller <davem@davemloft.net>
    CC: Ingo Molnar <mingo@redhat.com>
    CC: Guenter Roeck <linux@roeck-us.net>
    CC: Michal Simek <monstr@monstr.eu>
    CC: Chris Zankel <chris@zankel.net>

diff --git a/drivers/parisc/lba_pci.c b/drivers/parisc/lba_pci.c
index dceb9ddfd99a..901e1a3fa4e2 100644
--- a/drivers/parisc/lba_pci.c
+++ b/drivers/parisc/lba_pci.c
@@ -693,7 +693,6 @@ lba_fixup_bus(struct pci_bus *bus)
 	if (bus->parent) {
 		int i;
 		/* PCI-PCI Bridge */
-		pci_read_bridge_bases(bus);
 		for (i = PCI_BRIDGE_RESOURCES; i < PCI_NUM_RESOURCES; i++)
 			pci_claim_bridge_resource(bus->self, i);
 	} else {

commit 2e5e804a836ec89e126443c8efe666b56e4e58a9
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Thu Jan 15 16:21:50 2015 -0600

    parisc/PCI: Clip bridge windows to fit in upstream windows
    
    Every PCI-PCI bridge window should fit inside an upstream bridge window
    because orphaned address space is unreachable from the primary side of the
    upstream bridge.  If we inherit invalid bridge windows that overlap an
    upstream window from firmware, clip them to fit and update the bridge
    accordingly.
    
    [bhelgaas: changelog]
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=85491
    Reported-by: Marek Kordik <kordikmarek@gmail.com>
    Fixes: 5b28541552ef ("PCI: Restrict 64-bit prefetchable bridge windows to 64-bit resources")
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    CC: "James E.J. Bottomley" <jejb@parisc-linux.org>
    CC: Helge Deller <deller@gmx.de>
    CC: linux-parisc@vger.kernel.org

diff --git a/drivers/parisc/lba_pci.c b/drivers/parisc/lba_pci.c
index 37e71ff6408d..dceb9ddfd99a 100644
--- a/drivers/parisc/lba_pci.c
+++ b/drivers/parisc/lba_pci.c
@@ -694,9 +694,8 @@ lba_fixup_bus(struct pci_bus *bus)
 		int i;
 		/* PCI-PCI Bridge */
 		pci_read_bridge_bases(bus);
-		for (i = PCI_BRIDGE_RESOURCES; i < PCI_NUM_RESOURCES; i++) {
-			pci_claim_resource(bus->self, i);
-		}
+		for (i = PCI_BRIDGE_RESOURCES; i < PCI_NUM_RESOURCES; i++)
+			pci_claim_bridge_resource(bus->self, i);
 	} else {
 		/* Host-PCI Bridge */
 		int err;

commit 928bea964827d7824b548c1f8e06eccbbc4d0d7d
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Mon Jul 22 14:37:17 2013 -0700

    PCI: Delay enabling bridges until they're needed
    
    We currently enable PCI bridges after scanning a bus and assigning
    resources.  This is often done in arch code.
    
    This patch changes this so we don't enable a bridge until necessary, i.e.,
    until we enable a PCI device behind the bridge.  We do this in the generic
    pci_enable_device() path, so this also removes the arch-specific code to
    enable bridges.
    
    [bhelgaas: changelog]
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/parisc/lba_pci.c b/drivers/parisc/lba_pci.c
index 19f6f70c67d3..37e71ff6408d 100644
--- a/drivers/parisc/lba_pci.c
+++ b/drivers/parisc/lba_pci.c
@@ -1590,7 +1590,6 @@ lba_driver_probe(struct parisc_device *dev)
 		lba_dump_res(&lba_dev->hba.lmmio_space, 2);
 #endif
 	}
-	pci_enable_bridges(lba_bus);
 
 	/*
 	** Once PCI register ops has walked the bus, access to config

commit dac76f1be5beaea4af9afe85fb475c73de0b8731
Author: Helge Deller <deller@gmx.de>
Date:   Tue Jun 18 23:21:25 2013 +0200

    parisc: fix LMMIO mismatch between PAT length and MASK register
    
    The LMMIO length reported by PAT and the length given by the LBA MASK
    register are not consistent. This leads e.g. to a not-working ATI FireGL
    card with the radeon DRM driver since the memory can't be mapped.
    
    Fix this by correctly adjusting the resource sizes.
    
    Signed-off-by: Helge Deller <deller@gmx.de>
    Cc: <stable@vger.kernel.org> # 3.10

diff --git a/drivers/parisc/lba_pci.c b/drivers/parisc/lba_pci.c
index 1f05913ae677..19f6f70c67d3 100644
--- a/drivers/parisc/lba_pci.c
+++ b/drivers/parisc/lba_pci.c
@@ -613,6 +613,54 @@ truncate_pat_collision(struct resource *root, struct resource *new)
 	return 0;	/* truncation successful */
 }
 
+/*
+ * extend_lmmio_len: extend lmmio range to maximum length
+ *
+ * This is needed at least on C8000 systems to get the ATI FireGL card
+ * working. On other systems we will currently not extend the lmmio space.
+ */
+static unsigned long
+extend_lmmio_len(unsigned long start, unsigned long end, unsigned long lba_len)
+{
+	struct resource *tmp;
+
+	pr_debug("LMMIO mismatch: PAT length = 0x%lx, MASK register = 0x%lx\n",
+		end - start, lba_len);
+
+	lba_len = min(lba_len+1, 256UL*1024*1024); /* limit to 256 MB */
+
+	pr_debug("LBA: lmmio_space [0x%lx-0x%lx] - original\n", start, end);
+
+	if (boot_cpu_data.cpu_type < mako) {
+		pr_info("LBA: Not a C8000 system - not extending LMMIO range.\n");
+		return end;
+	}
+
+	end += lba_len;
+	if (end < start) /* fix overflow */
+		end = -1ULL;
+
+	pr_debug("LBA: lmmio_space [0x%lx-0x%lx] - current\n", start, end);
+
+	/* first overlap */
+	for (tmp = iomem_resource.child; tmp; tmp = tmp->sibling) {
+		pr_debug("LBA: testing %pR\n", tmp);
+		if (tmp->start == start)
+			continue; /* ignore ourself */
+		if (tmp->end < start)
+			continue;
+		if (tmp->start > end)
+			continue;
+		if (end >= tmp->start)
+			end = tmp->start - 1;
+	}
+
+	pr_info("LBA: lmmio_space [0x%lx-0x%lx] - new\n", start, end);
+
+	/* return new end */
+	return end;
+}
+
 #else
 #define truncate_pat_collision(r,n)  (0)
 #endif
@@ -994,6 +1042,14 @@ lba_pat_resources(struct parisc_device *pa_dev, struct lba_device *lba_dev)
 		case PAT_LMMIO:
 			/* used to fix up pre-initialized MEM BARs */
 			if (!lba_dev->hba.lmmio_space.flags) {
+				unsigned long lba_len;
+
+				lba_len = ~READ_REG32(lba_dev->hba.base_addr
+						+ LBA_LMMIO_MASK);
+				if ((p->end - p->start) != lba_len)
+					p->end = extend_lmmio_len(p->start,
+						p->end, lba_len);
+
 				sprintf(lba_dev->hba.lmmio_name,
 						"PCI%02x LMMIO",
 						(int)lba_dev->hba.bus_num.start);

commit b204a4d2d4f2061659bb5c33f5a4013fb0f6ffbe
Author: Helge Deller <deller@gmx.de>
Date:   Fri May 31 22:24:58 2013 +0000

    parisc/PCI: lba: fix: convert to pci_create_root_bus() for correct root bus resources (v2)
    
    commit dc7dce280a
    Author: Bjorn Helgaas <bhelgaas@google.com>
    Date:   Fri Oct 28 16:27:27 2011 -0600
       parisc/PCI: lba: convert to pci_create_root_bus() for correct root bus
                        resources
    
      Supply root bus resources to pci_create_root_bus() so they're correct
      immediately.  This fixes the problem of "early" and "header" quirks seeing
      incorrect root bus resources.
    
    added tests for elmmio_space.start while it should use
    elmmio_space.flags.  This for example led to incorrect resource
    assignments and a non-working stifb framebuffer on most parisc machines.
    
    LBA 10:1: PCI host bridge to bus 0000:01
    pci_bus 0000:01: root bus resource [io  0x12000-0x13fff] (bus address [0x2000-0x3fff])
    pci_bus 0000:01: root bus resource [mem 0xfffffffffa000000-0xfffffffffbffffff] (bus address [0xfa000000-0xfbffffff])
    pci_bus 0000:01: root bus resource [mem 0xfffffffff4800000-0xfffffffff4ffffff] (bus address [0xf4800000-0xf4ffffff])
    pci_bus 0000:01: root bus resource [??? 0x00000001 flags 0x0]
    
    Signed-off-by: Helge Deller <deller@gmx.de>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/parisc/lba_pci.c b/drivers/parisc/lba_pci.c
index 5d25038ef4b0..1f05913ae677 100644
--- a/drivers/parisc/lba_pci.c
+++ b/drivers/parisc/lba_pci.c
@@ -668,7 +668,7 @@ lba_fixup_bus(struct pci_bus *bus)
 			BUG();
 		}
 
-		if (ldev->hba.elmmio_space.start) {
+		if (ldev->hba.elmmio_space.flags) {
 			err = request_resource(&iomem_resource,
 					&(ldev->hba.elmmio_space));
 			if (err < 0) {
@@ -993,7 +993,7 @@ lba_pat_resources(struct parisc_device *pa_dev, struct lba_device *lba_dev)
 
 		case PAT_LMMIO:
 			/* used to fix up pre-initialized MEM BARs */
-			if (!lba_dev->hba.lmmio_space.start) {
+			if (!lba_dev->hba.lmmio_space.flags) {
 				sprintf(lba_dev->hba.lmmio_name,
 						"PCI%02x LMMIO",
 						(int)lba_dev->hba.bus_num.start);
@@ -1001,7 +1001,7 @@ lba_pat_resources(struct parisc_device *pa_dev, struct lba_device *lba_dev)
 					io->start;
 				r = &lba_dev->hba.lmmio_space;
 				r->name = lba_dev->hba.lmmio_name;
-			} else if (!lba_dev->hba.elmmio_space.start) {
+			} else if (!lba_dev->hba.elmmio_space.flags) {
 				sprintf(lba_dev->hba.elmmio_name,
 						"PCI%02x ELMMIO",
 						(int)lba_dev->hba.bus_num.start);
@@ -1495,7 +1495,7 @@ lba_driver_probe(struct parisc_device *dev)
 
 	pci_add_resource_offset(&resources, &lba_dev->hba.io_space,
 				HBA_PORT_BASE(lba_dev->hba.hba_num));
-	if (lba_dev->hba.elmmio_space.start)
+	if (lba_dev->hba.elmmio_space.flags)
 		pci_add_resource_offset(&resources, &lba_dev->hba.elmmio_space,
 					lba_dev->hba.lmmio_space_offset);
 	if (lba_dev->hba.lmmio_space.flags)

commit b47d4934e71d918814aee4a1d0211f81329b767e
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Thu May 30 11:45:39 2013 -0600

    parisc/PCI: Set type for LBA bus_num resource
    
    The non-PAT resource probing code failed to set the type of the LBA bus_num
    resource (30aa80da43 "parisc/PCI: register busn_res for root buses" did
    the corresponding thing for the PAT case).
    
    This causes incorrect resource assignments and a non-working stifb
    framebuffer on most parisc machines.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Signed-off-by: Helge Deller <deller@gmx.de>

diff --git a/drivers/parisc/lba_pci.c b/drivers/parisc/lba_pci.c
index 2ef7103270bb..5d25038ef4b0 100644
--- a/drivers/parisc/lba_pci.c
+++ b/drivers/parisc/lba_pci.c
@@ -1096,6 +1096,7 @@ lba_legacy_resources(struct parisc_device *pa_dev, struct lba_device *lba_dev)
 	r->name = "LBA PCI Busses";
 	r->start = lba_num & 0xff;
 	r->end = (lba_num>>8) & 0xff;
+	r->flags = IORESOURCE_BUS;
 
 	/* Set up local PCI Bus resources - we don't need them for
 	** Legacy boxes but it's nice to see in /proc/iomem.

commit 0fe763c570ad2701c830b9e4e53c65ad89c11c32
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Dec 21 15:14:44 2012 -0800

    Drivers: misc: remove __dev* attributes.
    
    CONFIG_HOTPLUG is going away as an option.  As a result, the __dev*
    markings need to be removed.
    
    This change removes the use of __devinit, __devexit_p, __devinitdata,
    __devinitconst, and __devexit from these drivers.
    
    Based on patches originally written by Bill Pemberton, but redone by me
    in order to handle some of the coding style issues better, by hand.
    
    Cc: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/parisc/lba_pci.c b/drivers/parisc/lba_pci.c
index fdd63a6a62d6..2ef7103270bb 100644
--- a/drivers/parisc/lba_pci.c
+++ b/drivers/parisc/lba_pci.c
@@ -34,7 +34,7 @@
 #include <linux/types.h>
 #include <linux/kernel.h>
 #include <linux/spinlock.h>
-#include <linux/init.h>		/* for __init and __devinit */
+#include <linux/init.h>		/* for __init */
 #include <linux/pci.h>
 #include <linux/ioport.h>
 #include <linux/slab.h>

commit 0b79ca2a800d1a2ed0386886c8358217f3371592
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Thu Aug 16 16:45:02 2012 -0600

    parisc/PCI: Use list_for_each_entry() for bus->devices traversal
    
    Replace list_for_each() + pci_dev_b() with the simpler
    list_for_each_entry().
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Yinghai Lu <yinghai@kernel.org>
    CC: linux-parisc@vger.kernel.org

diff --git a/drivers/parisc/lba_pci.c b/drivers/parisc/lba_pci.c
index 4ce57c92e559..fdd63a6a62d6 100644
--- a/drivers/parisc/lba_pci.c
+++ b/drivers/parisc/lba_pci.c
@@ -629,7 +629,6 @@ truncate_pat_collision(struct resource *root, struct resource *new)
 static void
 lba_fixup_bus(struct pci_bus *bus)
 {
-	struct list_head *ln;
 	struct pci_dev *dev;
 #ifdef FBB_SUPPORT
 	u16 status;
@@ -711,10 +710,9 @@ lba_fixup_bus(struct pci_bus *bus)
 
 	}
 
-	list_for_each(ln, &bus->devices) {
+	list_for_each_entry(dev, &bus->devices, bus_list) {
 		int i;
 
-		dev = pci_dev_b(ln);
 		DBG("lba_fixup_bus() %s\n", pci_name(dev));
 
 		/* Virtualize Device/Bridge Resources. */
@@ -771,8 +769,7 @@ lba_fixup_bus(struct pci_bus *bus)
 	}
 
 	/* Lastly enable FBB/PERR/SERR on all devices too */
-	list_for_each(ln, &bus->devices) {
-		dev = pci_dev_b(ln);
+	list_for_each_entry(dev, &bus->devices, bus_list) {
 		(void) pci_read_config_word(dev, PCI_COMMAND, &status);
 		status |= PCI_COMMAND_PARITY | PCI_COMMAND_SERR | fbb_enable;
 		(void) pci_write_config_word(dev, PCI_COMMAND, status);

commit f5725f4d3d9a69c647d6d2d504bd0ae87d9a08df
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Thu Aug 16 16:57:22 2012 -0600

    parisc/PCI: Enable PERR/SERR on all devices
    
    Previously, we enabled PERR & SERR for the first device on the bus, but
    left other devices alone.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Yinghai Lu <yinghai@kernel.org>
    CC: linux-parisc@vger.kernel.org

diff --git a/drivers/parisc/lba_pci.c b/drivers/parisc/lba_pci.c
index 4f9cf2456f4e..4ce57c92e559 100644
--- a/drivers/parisc/lba_pci.c
+++ b/drivers/parisc/lba_pci.c
@@ -630,6 +630,7 @@ static void
 lba_fixup_bus(struct pci_bus *bus)
 {
 	struct list_head *ln;
+	struct pci_dev *dev;
 #ifdef FBB_SUPPORT
 	u16 status;
 #endif
@@ -712,8 +713,8 @@ lba_fixup_bus(struct pci_bus *bus)
 
 	list_for_each(ln, &bus->devices) {
 		int i;
-		struct pci_dev *dev = pci_dev_b(ln);
 
+		dev = pci_dev_b(ln);
 		DBG("lba_fixup_bus() %s\n", pci_name(dev));
 
 		/* Virtualize Device/Bridge Resources. */
@@ -771,6 +772,7 @@ lba_fixup_bus(struct pci_bus *bus)
 
 	/* Lastly enable FBB/PERR/SERR on all devices too */
 	list_for_each(ln, &bus->devices) {
+		dev = pci_dev_b(ln);
 		(void) pci_read_config_word(dev, PCI_COMMAND, &status);
 		status |= PCI_COMMAND_PARITY | PCI_COMMAND_SERR | fbb_enable;
 		(void) pci_write_config_word(dev, PCI_COMMAND, status);

commit 30aa80da43a5f23728eae1516e3a1aad40e808dd
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Thu May 17 18:51:12 2012 -0700

    parisc/PCI: register busn_res for root buses
    
    Add the host bridge bus number aperture to the resource list.
    Like the MMIO and I/O port apertures, this is used when assigning
    resources to hot-added devices or in the case of conflicts.
    
    [bhelgaas: changelog, set flags directly, at LBA bus_num init]
    CC: Kyle McMartin <kyle@mcmartin.ca>
    CC: Helge Deller <deller@gmx.de>
    CC: linux-parisc@vger.kernel.org
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/parisc/lba_pci.c b/drivers/parisc/lba_pci.c
index cd8f9ce8720f..4f9cf2456f4e 100644
--- a/drivers/parisc/lba_pci.c
+++ b/drivers/parisc/lba_pci.c
@@ -989,6 +989,7 @@ lba_pat_resources(struct parisc_device *pa_dev, struct lba_device *lba_dev)
 		case PAT_PBNUM:
 			lba_dev->hba.bus_num.start = p->start;
 			lba_dev->hba.bus_num.end   = p->end;
+			lba_dev->hba.bus_num.flags = IORESOURCE_BUS;
 			break;
 
 		case PAT_LMMIO:
@@ -1366,6 +1367,7 @@ lba_driver_probe(struct parisc_device *dev)
 	void *tmp_obj;
 	char *version;
 	void __iomem *addr = ioremap_nocache(dev->hpa.start, 4096);
+	int max;
 
 	/* Read HW Rev First */
 	func_class = READ_REG32(addr + LBA_FCLASS);
@@ -1502,6 +1504,8 @@ lba_driver_probe(struct parisc_device *dev)
 	if (lba_dev->hba.gmmio_space.flags)
 		pci_add_resource(&resources, &lba_dev->hba.gmmio_space);
 
+	pci_add_resource(&resources, &lba_dev->hba.bus_num);
+
 	dev->dev.platform_data = lba_dev;
 	lba_bus = lba_dev->hba.hba_bus =
 		pci_create_root_bus(&dev->dev, lba_dev->hba.bus_num.start,
@@ -1511,7 +1515,7 @@ lba_driver_probe(struct parisc_device *dev)
 		return 0;
 	}
 
-	lba_bus->busn_res.end = pci_scan_child_bus(lba_bus);
+	max = pci_scan_child_bus(lba_bus);
 
 	/* This is in lieu of calling pci_assign_unassigned_resources() */
 	if (is_pdc_pat()) {
@@ -1541,7 +1545,7 @@ lba_driver_probe(struct parisc_device *dev)
 		lba_dev->flags |= LBA_FLAG_SKIP_PROBE;
 	}
 
-	lba_next_bus = lba_res->busn_res.end + 1;
+	lba_next_bus = max + 1;
 	pci_bus_add_devices(lba_bus);
 
 	/* Whew! Finally done! Tell services we got this one covered. */

commit b918c62e086b2130a7bae44110ca516ef10bfe5a
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Thu May 17 18:51:11 2012 -0700

    PCI: replace struct pci_bus secondary/subordinate with busn_res
    
    Replace the struct pci_bus secondary/subordinate members with the
    struct resource busn_res.  Later we'll build a resource tree of these
    bus numbers.
    
    [bhelgaas: changelog]
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/parisc/lba_pci.c b/drivers/parisc/lba_pci.c
index 052fa230bc77..cd8f9ce8720f 100644
--- a/drivers/parisc/lba_pci.c
+++ b/drivers/parisc/lba_pci.c
@@ -189,8 +189,8 @@ lba_dump_res(struct resource *r, int d)
 
 static int lba_device_present(u8 bus, u8 dfn, struct lba_device *d)
 {
-	u8 first_bus = d->hba.hba_bus->secondary;
-	u8 last_sub_bus = d->hba.hba_bus->subordinate;
+	u8 first_bus = d->hba.hba_bus->busn_res.start;
+	u8 last_sub_bus = d->hba.hba_bus->busn_res.end;
 
 	if ((bus < first_bus) ||
 	    (bus > last_sub_bus) ||
@@ -364,7 +364,7 @@ lba_rd_cfg(struct lba_device *d, u32 tok, u8 reg, u32 size)
 static int elroy_cfg_read(struct pci_bus *bus, unsigned int devfn, int pos, int size, u32 *data)
 {
 	struct lba_device *d = LBA_DEV(parisc_walk_tree(bus->bridge));
-	u32 local_bus = (bus->parent == NULL) ? 0 : bus->secondary;
+	u32 local_bus = (bus->parent == NULL) ? 0 : bus->busn_res.start;
 	u32 tok = LBA_CFG_TOK(local_bus, devfn);
 	void __iomem *data_reg = d->hba.base_addr + LBA_PCI_CFG_DATA;
 
@@ -380,7 +380,7 @@ static int elroy_cfg_read(struct pci_bus *bus, unsigned int devfn, int pos, int
 		return 0;
 	}
 
-	if (LBA_SKIP_PROBE(d) && !lba_device_present(bus->secondary, devfn, d)) {
+	if (LBA_SKIP_PROBE(d) && !lba_device_present(bus->busn_res.start, devfn, d)) {
 		DBG_CFG("%s(%x+%2x) -> -1 (b)\n", __func__, tok, pos);
 		/* either don't want to look or know device isn't present. */
 		*data = ~0U;
@@ -431,7 +431,7 @@ lba_wr_cfg(struct lba_device *d, u32 tok, u8 reg, u32 data, u32 size)
 static int elroy_cfg_write(struct pci_bus *bus, unsigned int devfn, int pos, int size, u32 data)
 {
 	struct lba_device *d = LBA_DEV(parisc_walk_tree(bus->bridge));
-	u32 local_bus = (bus->parent == NULL) ? 0 : bus->secondary;
+	u32 local_bus = (bus->parent == NULL) ? 0 : bus->busn_res.start;
 	u32 tok = LBA_CFG_TOK(local_bus,devfn);
 
 	if ((pos > 255) || (devfn > 255))
@@ -444,7 +444,7 @@ static int elroy_cfg_write(struct pci_bus *bus, unsigned int devfn, int pos, int
 		return 0;
 	}
 
-	if (LBA_SKIP_PROBE(d) && (!lba_device_present(bus->secondary, devfn, d))) {
+	if (LBA_SKIP_PROBE(d) && (!lba_device_present(bus->busn_res.start, devfn, d))) {
 		DBG_CFG("%s(%x+%2x) = 0x%x (b)\n", __func__, tok, pos,data);
 		return 1; /* New Workaround */
 	}
@@ -481,7 +481,7 @@ static struct pci_ops elroy_cfg_ops = {
 static int mercury_cfg_read(struct pci_bus *bus, unsigned int devfn, int pos, int size, u32 *data)
 {
 	struct lba_device *d = LBA_DEV(parisc_walk_tree(bus->bridge));
-	u32 local_bus = (bus->parent == NULL) ? 0 : bus->secondary;
+	u32 local_bus = (bus->parent == NULL) ? 0 : bus->busn_res.start;
 	u32 tok = LBA_CFG_TOK(local_bus, devfn);
 	void __iomem *data_reg = d->hba.base_addr + LBA_PCI_CFG_DATA;
 
@@ -514,7 +514,7 @@ static int mercury_cfg_write(struct pci_bus *bus, unsigned int devfn, int pos, i
 {
 	struct lba_device *d = LBA_DEV(parisc_walk_tree(bus->bridge));
 	void __iomem *data_reg = d->hba.base_addr + LBA_PCI_CFG_DATA;
-	u32 local_bus = (bus->parent == NULL) ? 0 : bus->secondary;
+	u32 local_bus = (bus->parent == NULL) ? 0 : bus->busn_res.start;
 	u32 tok = LBA_CFG_TOK(local_bus,devfn);
 
 	if ((pos > 255) || (devfn > 255))
@@ -636,7 +636,7 @@ lba_fixup_bus(struct pci_bus *bus)
 	struct lba_device *ldev = LBA_DEV(parisc_walk_tree(bus->bridge));
 
 	DBG("lba_fixup_bus(0x%p) bus %d platform_data 0x%p\n",
-		bus, bus->secondary, bus->bridge->platform_data);
+		bus, (int)bus->busn_res.start, bus->bridge->platform_data);
 
 	/*
 	** Properly Setup MMIO resources for this bus.
@@ -1511,7 +1511,7 @@ lba_driver_probe(struct parisc_device *dev)
 		return 0;
 	}
 
-	lba_bus->subordinate = pci_scan_child_bus(lba_bus);
+	lba_bus->busn_res.end = pci_scan_child_bus(lba_bus);
 
 	/* This is in lieu of calling pci_assign_unassigned_resources() */
 	if (is_pdc_pat()) {
@@ -1541,7 +1541,7 @@ lba_driver_probe(struct parisc_device *dev)
 		lba_dev->flags |= LBA_FLAG_SKIP_PROBE;
 	}
 
-	lba_next_bus = lba_bus->subordinate + 1;
+	lba_next_bus = lba_res->busn_res.end + 1;
 	pci_bus_add_devices(lba_bus);
 
 	/* Whew! Finally done! Tell services we got this one covered. */

commit 0195c00244dc2e9f522475868fa278c473ba7339
Merge: f21ce8f8447c 141124c02059
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Mar 28 15:58:21 2012 -0700

    Merge tag 'split-asm_system_h-for-linus-20120328' of git://git.kernel.org/pub/scm/linux/kernel/git/dhowells/linux-asm_system
    
    Pull "Disintegrate and delete asm/system.h" from David Howells:
     "Here are a bunch of patches to disintegrate asm/system.h into a set of
      separate bits to relieve the problem of circular inclusion
      dependencies.
    
      I've built all the working defconfigs from all the arches that I can
      and made sure that they don't break.
    
      The reason for these patches is that I recently encountered a circular
      dependency problem that came about when I produced some patches to
      optimise get_order() by rewriting it to use ilog2().
    
      This uses bitops - and on the SH arch asm/bitops.h drags in
      asm-generic/get_order.h by a circuituous route involving asm/system.h.
    
      The main difficulty seems to be asm/system.h.  It holds a number of
      low level bits with no/few dependencies that are commonly used (eg.
      memory barriers) and a number of bits with more dependencies that
      aren't used in many places (eg.  switch_to()).
    
      These patches break asm/system.h up into the following core pieces:
    
        (1) asm/barrier.h
    
            Move memory barriers here.  This already done for MIPS and Alpha.
    
        (2) asm/switch_to.h
    
            Move switch_to() and related stuff here.
    
        (3) asm/exec.h
    
            Move arch_align_stack() here.  Other process execution related bits
            could perhaps go here from asm/processor.h.
    
        (4) asm/cmpxchg.h
    
            Move xchg() and cmpxchg() here as they're full word atomic ops and
            frequently used by atomic_xchg() and atomic_cmpxchg().
    
        (5) asm/bug.h
    
            Move die() and related bits.
    
        (6) asm/auxvec.h
    
            Move AT_VECTOR_SIZE_ARCH here.
    
      Other arch headers are created as needed on a per-arch basis."
    
    Fixed up some conflicts from other header file cleanups and moving code
    around that has happened in the meantime, so David's testing is somewhat
    weakened by that.  We'll find out anything that got broken and fix it..
    
    * tag 'split-asm_system_h-for-linus-20120328' of git://git.kernel.org/pub/scm/linux/kernel/git/dhowells/linux-asm_system: (38 commits)
      Delete all instances of asm/system.h
      Remove all #inclusions of asm/system.h
      Add #includes needed to permit the removal of asm/system.h
      Move all declarations of free_initmem() to linux/mm.h
      Disintegrate asm/system.h for OpenRISC
      Split arch_align_stack() out from asm-generic/system.h
      Split the switch_to() wrapper out of asm-generic/system.h
      Move the asm-generic/system.h xchg() implementation to asm-generic/cmpxchg.h
      Create asm-generic/barrier.h
      Make asm-generic/cmpxchg.h #include asm-generic/cmpxchg-local.h
      Disintegrate asm/system.h for Xtensa
      Disintegrate asm/system.h for Unicore32 [based on ver #3, changed by gxt]
      Disintegrate asm/system.h for Tile
      Disintegrate asm/system.h for Sparc
      Disintegrate asm/system.h for SH
      Disintegrate asm/system.h for Score
      Disintegrate asm/system.h for S390
      Disintegrate asm/system.h for PowerPC
      Disintegrate asm/system.h for PA-RISC
      Disintegrate asm/system.h for MN10300
      ...

commit 9ffc93f203c18a70623f21950f1dd473c9ec48cd
Author: David Howells <dhowells@redhat.com>
Date:   Wed Mar 28 18:30:03 2012 +0100

    Remove all #inclusions of asm/system.h
    
    Remove all #inclusions of asm/system.h preparatory to splitting and killing
    it.  Performed with the following command:
    
    perl -p -i -e 's!^#\s*include\s*<asm/system[.]h>.*\n!!' `grep -Irl '^#\s*include\s*<asm/system[.]h>' *`
    
    Signed-off-by: David Howells <dhowells@redhat.com>

diff --git a/drivers/parisc/lba_pci.c b/drivers/parisc/lba_pci.c
index d5f3d753a108..320e43a52e9d 100644
--- a/drivers/parisc/lba_pci.c
+++ b/drivers/parisc/lba_pci.c
@@ -43,7 +43,6 @@
 #include <asm/pdc.h>
 #include <asm/pdcpat.h>
 #include <asm/page.h>
-#include <asm/system.h>
 
 #include <asm/ropes.h>
 #include <asm/hardware.h>	/* for register_parisc_driver() stuff */

commit 39c2462e163448c7df466c7262109ec6a24d5f88
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Thu Feb 23 20:19:03 2012 -0700

    parisc/PCI: get rid of device resource fixups
    
    Tell the PCI core about host bridge address translation so it can take
    care of bus-to-resource conversion for us.
    
    CC: linux-parisc@vger.kernel.org
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/drivers/parisc/lba_pci.c b/drivers/parisc/lba_pci.c
index d5f3d753a108..e8857647e210 100644
--- a/drivers/parisc/lba_pci.c
+++ b/drivers/parisc/lba_pci.c
@@ -635,7 +635,6 @@ lba_fixup_bus(struct pci_bus *bus)
 	u16 status;
 #endif
 	struct lba_device *ldev = LBA_DEV(parisc_walk_tree(bus->bridge));
-	int lba_portbase = HBA_PORT_BASE(ldev->hba.hba_num);
 
 	DBG("lba_fixup_bus(0x%p) bus %d platform_data 0x%p\n",
 		bus, bus->secondary, bus->bridge->platform_data);
@@ -726,27 +725,6 @@ lba_fixup_bus(struct pci_bus *bus)
 			if (!res->start)
 				continue;
 
-			if (res->flags & IORESOURCE_IO) {
-				DBG("lba_fixup_bus() I/O Ports [%lx/%lx] -> ",
-					res->start, res->end);
-				res->start |= lba_portbase;
-				res->end   |= lba_portbase;
-				DBG("[%lx/%lx]\n", res->start, res->end);
-			} else if (res->flags & IORESOURCE_MEM) {
-				/*
-				** Convert PCI (IO_VIEW) addresses to
-				** processor (PA_VIEW) addresses
-				 */
-				DBG("lba_fixup_bus() MMIO [%lx/%lx] -> ",
-					res->start, res->end);
-				res->start = PCI_HOST_ADDR(HBA_DATA(ldev), res->start);
-				res->end   = PCI_HOST_ADDR(HBA_DATA(ldev), res->end);
-				DBG("[%lx/%lx]\n", res->start, res->end);
-			} else {
-				DBG("lba_fixup_bus() WTF? 0x%lx [%lx/%lx] XXX",
-					res->flags, res->start, res->end);
-			}
-
 			/*
 			** FIXME: this will result in whinging for devices
 			** that share expansion ROMs (think quad tulip), but
@@ -1514,11 +1492,14 @@ lba_driver_probe(struct parisc_device *dev)
 		lba_dev->hba.lmmio_space.flags = 0;
 	}
 
-	pci_add_resource(&resources, &lba_dev->hba.io_space);
+	pci_add_resource_offset(&resources, &lba_dev->hba.io_space,
+				HBA_PORT_BASE(lba_dev->hba.hba_num));
 	if (lba_dev->hba.elmmio_space.start)
-		pci_add_resource(&resources, &lba_dev->hba.elmmio_space);
+		pci_add_resource_offset(&resources, &lba_dev->hba.elmmio_space,
+					lba_dev->hba.lmmio_space_offset);
 	if (lba_dev->hba.lmmio_space.flags)
-		pci_add_resource(&resources, &lba_dev->hba.lmmio_space);
+		pci_add_resource_offset(&resources, &lba_dev->hba.lmmio_space,
+					lba_dev->hba.lmmio_space_offset);
 	if (lba_dev->hba.gmmio_space.flags)
 		pci_add_resource(&resources, &lba_dev->hba.gmmio_space);
 

commit dc7dce280a26d069ad5a58bf3da86e5e83415c65
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Oct 28 16:27:27 2011 -0600

    parisc/PCI: lba: convert to pci_create_root_bus() for correct root bus resources
    
    Supply root bus resources to pci_create_root_bus() so they're correct
    immediately.  This fixes the problem of "early" and "header" quirks seeing
    incorrect root bus resources.
    
    CC: linux-parisc@vger.kernel.org
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/parisc/lba_pci.c b/drivers/parisc/lba_pci.c
index e5dfa25e2fdd..d5f3d753a108 100644
--- a/drivers/parisc/lba_pci.c
+++ b/drivers/parisc/lba_pci.c
@@ -653,7 +653,7 @@ lba_fixup_bus(struct pci_bus *bus)
 		}
 	} else {
 		/* Host-PCI Bridge */
-		int err, i;
+		int err;
 
 		DBG("lba_fixup_bus() %s [%lx/%lx]/%lx\n",
 			ldev->hba.io_space.name,
@@ -669,9 +669,6 @@ lba_fixup_bus(struct pci_bus *bus)
 			lba_dump_res(&ioport_resource, 2);
 			BUG();
 		}
-		/* advertize Host bridge resources to PCI bus */
-		bus->resource[0] = &(ldev->hba.io_space);
-		i = 1;
 
 		if (ldev->hba.elmmio_space.start) {
 			err = request_resource(&iomem_resource,
@@ -685,8 +682,7 @@ lba_fixup_bus(struct pci_bus *bus)
 
 				/* lba_dump_res(&iomem_resource, 2); */
 				/* BUG(); */
-			} else
-				bus->resource[i++] = &(ldev->hba.elmmio_space);
+			}
 		}
 
 		if (ldev->hba.lmmio_space.flags) {
@@ -696,8 +692,7 @@ lba_fixup_bus(struct pci_bus *bus)
 					"lmmio_space [%lx/%lx]\n",
 					(long)ldev->hba.lmmio_space.start,
 					(long)ldev->hba.lmmio_space.end);
-			} else
-				bus->resource[i++] = &(ldev->hba.lmmio_space);
+			}
 		}
 
 #ifdef CONFIG_64BIT
@@ -712,7 +707,6 @@ lba_fixup_bus(struct pci_bus *bus)
 				lba_dump_res(&iomem_resource, 2);
 				BUG();
 			}
-			bus->resource[i++] = &(ldev->hba.gmmio_space);
 		}
 #endif
 
@@ -1388,6 +1382,7 @@ static int __init
 lba_driver_probe(struct parisc_device *dev)
 {
 	struct lba_device *lba_dev;
+	LIST_HEAD(resources);
 	struct pci_bus *lba_bus;
 	struct pci_ops *cfg_ops;
 	u32 func_class;
@@ -1519,12 +1514,22 @@ lba_driver_probe(struct parisc_device *dev)
 		lba_dev->hba.lmmio_space.flags = 0;
 	}
 
+	pci_add_resource(&resources, &lba_dev->hba.io_space);
+	if (lba_dev->hba.elmmio_space.start)
+		pci_add_resource(&resources, &lba_dev->hba.elmmio_space);
+	if (lba_dev->hba.lmmio_space.flags)
+		pci_add_resource(&resources, &lba_dev->hba.lmmio_space);
+	if (lba_dev->hba.gmmio_space.flags)
+		pci_add_resource(&resources, &lba_dev->hba.gmmio_space);
+
 	dev->dev.platform_data = lba_dev;
 	lba_bus = lba_dev->hba.hba_bus =
-		pci_create_bus(&dev->dev, lba_dev->hba.bus_num.start,
-			       cfg_ops, NULL);
-	if (!lba_bus)
+		pci_create_root_bus(&dev->dev, lba_dev->hba.bus_num.start,
+				    cfg_ops, NULL, &resources);
+	if (!lba_bus) {
+		pci_free_resource_list(&resources);
 		return 0;
+	}
 
 	lba_bus->subordinate = pci_scan_child_bus(lba_bus);
 

commit 42605fa6665ea86bbbd4de61693a0b002830277b
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Oct 28 16:27:22 2011 -0600

    parisc/PCI: lba: use pci_create_bus() instead of pci_scan_bus_parented()
    
    No functional change here; just converting from pci_scan_bus_parented()
    to pci_create_bus() to make a future patch simpler.
    
    CC: linux-parisc@vger.kernel.org
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/parisc/lba_pci.c b/drivers/parisc/lba_pci.c
index 2c7edf3a6cd0..e5dfa25e2fdd 100644
--- a/drivers/parisc/lba_pci.c
+++ b/drivers/parisc/lba_pci.c
@@ -1521,8 +1521,12 @@ lba_driver_probe(struct parisc_device *dev)
 
 	dev->dev.platform_data = lba_dev;
 	lba_bus = lba_dev->hba.hba_bus =
-		pci_scan_bus_parented(&dev->dev, lba_dev->hba.bus_num.start,
-				cfg_ops, NULL);
+		pci_create_bus(&dev->dev, lba_dev->hba.bus_num.start,
+			       cfg_ops, NULL);
+	if (!lba_bus)
+		return 0;
+
+	lba_bus->subordinate = pci_scan_child_bus(lba_bus);
 
 	/* This is in lieu of calling pci_assign_unassigned_resources() */
 	if (is_pdc_pat()) {
@@ -1552,10 +1556,8 @@ lba_driver_probe(struct parisc_device *dev)
 		lba_dev->flags |= LBA_FLAG_SKIP_PROBE;
 	}
 
-	if (lba_bus) {
-		lba_next_bus = lba_bus->subordinate + 1;
-		pci_bus_add_devices(lba_bus);
-	}
+	lba_next_bus = lba_bus->subordinate + 1;
+	pci_bus_add_devices(lba_bus);
 
 	/* Whew! Finally done! Tell services we got this one covered. */
 	return 0;

commit f4d9ea9abf04a6ad9643df5497e6243fbf64196e
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Oct 28 16:27:17 2011 -0600

    parisc/PCI: lba: deal with LMMIO/PAT overlaps before creating PCI root bus
    
    This moves the truncate_pat_collision() call out of the pcibios_fixup_bus()
    path so that when a future patch builds a list of root bus resources for
    pci_create_bus(), it can use the truncated LMMIO range.
    
    truncate_pat_collision() used to be called in this path:
    
        pci_scan_bus_parented
          pci_create_bus
          pci_scan_child_bus
            pcibios_fixup_bus
              lba_fixup_bus
                truncate_pat_collision
    
    All of the PAT and lba_dev resource setup must be done before we call
    pci_scan_bus_parented(), so it should be safe to move the
    truncate_pat_collision() to just before pci_scan_bus_parented().
    
    CC: linux-parisc@vger.kernel.org
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/drivers/parisc/lba_pci.c b/drivers/parisc/lba_pci.c
index 3aeb3279c92a..2c7edf3a6cd0 100644
--- a/drivers/parisc/lba_pci.c
+++ b/drivers/parisc/lba_pci.c
@@ -689,23 +689,7 @@ lba_fixup_bus(struct pci_bus *bus)
 				bus->resource[i++] = &(ldev->hba.elmmio_space);
 		}
 
-
-		/*   Overlaps with elmmio can (and should) fail here.
-		 *   We will prune (or ignore) the distributed range.
-		 *
-		 *   FIXME: SBA code should register all elmmio ranges first.
-		 *      that would take care of elmmio ranges routed
-		 *	to a different rope (already discovered) from
-		 *	getting registered *after* LBA code has already
-		 *	registered it's distributed lmmio range.
-		 */
-		if (truncate_pat_collision(&iomem_resource,
-				       	&(ldev->hba.lmmio_space))) {
-
-			printk(KERN_WARNING "LBA: lmmio_space [%lx/%lx] duplicate!\n",
-					(long)ldev->hba.lmmio_space.start,
-					(long)ldev->hba.lmmio_space.end);
-		} else {
+		if (ldev->hba.lmmio_space.flags) {
 			err = request_resource(&iomem_resource, &(ldev->hba.lmmio_space));
 			if (err < 0) {
 				printk(KERN_ERR "FAILED: lba_fixup_bus() request for "
@@ -1518,6 +1502,23 @@ lba_driver_probe(struct parisc_device *dev)
 	if (lba_dev->hba.bus_num.start < lba_next_bus)
 		lba_dev->hba.bus_num.start = lba_next_bus;
 
+	/*   Overlaps with elmmio can (and should) fail here.
+	 *   We will prune (or ignore) the distributed range.
+	 *
+	 *   FIXME: SBA code should register all elmmio ranges first.
+	 *      that would take care of elmmio ranges routed
+	 *	to a different rope (already discovered) from
+	 *	getting registered *after* LBA code has already
+	 *	registered it's distributed lmmio range.
+	 */
+	if (truncate_pat_collision(&iomem_resource,
+				   &(lba_dev->hba.lmmio_space))) {
+		printk(KERN_WARNING "LBA: lmmio_space [%lx/%lx] duplicate!\n",
+				(long)lba_dev->hba.lmmio_space.start,
+				(long)lba_dev->hba.lmmio_space.end);
+		lba_dev->hba.lmmio_space.flags = 0;
+	}
+
 	dev->dev.platform_data = lba_dev;
 	lba_bus = lba_dev->hba.hba_bus =
 		pci_scan_bus_parented(&dev->dev, lba_dev->hba.bus_num.start,

commit 450d6e306b4717bfae11218a02648509baf04ce1
Author: Stoyan Gaydarov <sgayda2@uiuc.edu>
Date:   Thu Jul 30 10:25:19 2009 +0000

    parisc: fixed faulty check in lba_pci
    
    This patche fixes a spelling error that has resulted from copy and pasting.
    The location of the error was found using a semantic patch but the semantic
    patch was not trying to find these errors. After looking things over it
    seemed logical that this change was needed.
    
    Signed-off-by: Stoyan Gaydarov <sgayda2@uiuc.edu>
    Signed-off-by: Helge Deller <deller@gmx.de>

diff --git a/drivers/parisc/lba_pci.c b/drivers/parisc/lba_pci.c
index ede614616f8e..3aeb3279c92a 100644
--- a/drivers/parisc/lba_pci.c
+++ b/drivers/parisc/lba_pci.c
@@ -992,7 +992,7 @@ lba_pat_resources(struct parisc_device *pa_dev, struct lba_device *lba_dev)
 		return;
 
 	io_pdc_cell = kzalloc(sizeof(pdc_pat_cell_mod_maddr_block_t), GFP_KERNEL);
-	if (!pa_pdc_cell) {
+	if (!io_pdc_cell) {
 		kfree(pa_pdc_cell);
 		return;
 	}

commit e957f608f321a97a60d065bccd01949590eef52e
Author: Grant Grundler <grundler@parisc-linux.org>
Date:   Tue Jun 23 11:03:11 2009 -0400

    parisc: Fix gcc 4.4 warning in lba_pci.c
    
    gcc 4.4 warns about:
    drivers/parisc/lba_pci.c: In function 'lba_pat_resources':
    drivers/parisc/lba_pci.c:1099: warning: the frame size of 8280 bytes is larger than 4096 bytes
    
    The problem is we declare two large structures on the stack. They don't need
    to be on the stack since they are only used during LBA initialization (which
    is serialized). Moving to be "static".
    
    Signed-off-by: Grant Grundler <grundler@parisc-linux.org>
    Signed-off-by: Kyle McMartin <kyle@mcmartin.ca>

diff --git a/drivers/parisc/lba_pci.c b/drivers/parisc/lba_pci.c
index f2661e1255af..ede614616f8e 100644
--- a/drivers/parisc/lba_pci.c
+++ b/drivers/parisc/lba_pci.c
@@ -980,28 +980,38 @@ static void
 lba_pat_resources(struct parisc_device *pa_dev, struct lba_device *lba_dev)
 {
 	unsigned long bytecnt;
-	pdc_pat_cell_mod_maddr_block_t pa_pdc_cell;	/* PA_VIEW */
-	pdc_pat_cell_mod_maddr_block_t io_pdc_cell;	/* IO_VIEW */
 	long io_count;
 	long status;	/* PDC return status */
 	long pa_count;
+	pdc_pat_cell_mod_maddr_block_t *pa_pdc_cell;	/* PA_VIEW */
+	pdc_pat_cell_mod_maddr_block_t *io_pdc_cell;	/* IO_VIEW */
 	int i;
 
+	pa_pdc_cell = kzalloc(sizeof(pdc_pat_cell_mod_maddr_block_t), GFP_KERNEL);
+	if (!pa_pdc_cell)
+		return;
+
+	io_pdc_cell = kzalloc(sizeof(pdc_pat_cell_mod_maddr_block_t), GFP_KERNEL);
+	if (!pa_pdc_cell) {
+		kfree(pa_pdc_cell);
+		return;
+	}
+
 	/* return cell module (IO view) */
 	status = pdc_pat_cell_module(&bytecnt, pa_dev->pcell_loc, pa_dev->mod_index,
-				PA_VIEW, & pa_pdc_cell);
-	pa_count = pa_pdc_cell.mod[1];
+				PA_VIEW, pa_pdc_cell);
+	pa_count = pa_pdc_cell->mod[1];
 
 	status |= pdc_pat_cell_module(&bytecnt, pa_dev->pcell_loc, pa_dev->mod_index,
-				IO_VIEW, &io_pdc_cell);
-	io_count = io_pdc_cell.mod[1];
+				IO_VIEW, io_pdc_cell);
+	io_count = io_pdc_cell->mod[1];
 
 	/* We've already done this once for device discovery...*/
 	if (status != PDC_OK) {
 		panic("pdc_pat_cell_module() call failed for LBA!\n");
 	}
 
-	if (PAT_GET_ENTITY(pa_pdc_cell.mod_info) != PAT_ENTITY_LBA) {
+	if (PAT_GET_ENTITY(pa_pdc_cell->mod_info) != PAT_ENTITY_LBA) {
 		panic("pdc_pat_cell_module() entity returned != PAT_ENTITY_LBA!\n");
 	}
 
@@ -1016,8 +1026,8 @@ lba_pat_resources(struct parisc_device *pa_dev, struct lba_device *lba_dev)
 		} *p, *io;
 		struct resource *r;
 
-		p = (void *) &(pa_pdc_cell.mod[2+i*3]);
-		io = (void *) &(io_pdc_cell.mod[2+i*3]);
+		p = (void *) &(pa_pdc_cell->mod[2+i*3]);
+		io = (void *) &(io_pdc_cell->mod[2+i*3]);
 
 		/* Convert the PAT range data to PCI "struct resource" */
 		switch(p->type & 0xff) {
@@ -1096,6 +1106,9 @@ lba_pat_resources(struct parisc_device *pa_dev, struct lba_device *lba_dev)
 			break;
 		}
 	}
+
+	kfree(pa_pdc_cell);
+	kfree(io_pdc_cell);
 }
 #else
 /* keep compiler from complaining about missing declarations */

commit fed99b1e86f5ff4f1b41e37264bb869da67d3174
Author: Grant Grundler <grundler@parisc-linux.org>
Date:   Mon Apr 20 04:28:22 2009 +0000

    parisc: advertise PCI devs after "assign_resources"
    
    Alex Chiang asked me why PARISC was calling pci_bus_add_devices()
    and pci_bus_assign_resources() in the opposite order from everyone else.
    No reason and I couldn't see any data dependency.
    Patch below applies cleanly to 2.6.30-rc2.
    
    Later, I suspected the code worked only because no drivers would be
    loaded/ready until much later in the system initialization sequence.
    
    Tested "LBA" code on J6000 (32-bit) and A500 (64-bit SMP) with 2.6.30-rc2.
    Not tested with any Dino controllers.
    Not tested with PCI-PCI Bridge (TBD).
    
    Reported-by: Alex Chiang <achiang@hp.com>
    Signed-off-by: Grant Grundler <grundler@parisc-linux.org>
    Signed-off-by: Kyle McMartin <kyle@mcmartin.ca>

diff --git a/drivers/parisc/lba_pci.c b/drivers/parisc/lba_pci.c
index 59fbbf128365..f2661e1255af 100644
--- a/drivers/parisc/lba_pci.c
+++ b/drivers/parisc/lba_pci.c
@@ -1509,10 +1509,6 @@ lba_driver_probe(struct parisc_device *dev)
 	lba_bus = lba_dev->hba.hba_bus =
 		pci_scan_bus_parented(&dev->dev, lba_dev->hba.bus_num.start,
 				cfg_ops, NULL);
-	if (lba_bus) {
-		lba_next_bus = lba_bus->subordinate + 1;
-		pci_bus_add_devices(lba_bus);
-	}
 
 	/* This is in lieu of calling pci_assign_unassigned_resources() */
 	if (is_pdc_pat()) {
@@ -1533,7 +1529,6 @@ lba_driver_probe(struct parisc_device *dev)
 	}
 	pci_enable_bridges(lba_bus);
 
-
 	/*
 	** Once PCI register ops has walked the bus, access to config
 	** space is restricted. Avoids master aborts on config cycles.
@@ -1543,6 +1538,11 @@ lba_driver_probe(struct parisc_device *dev)
 		lba_dev->flags |= LBA_FLAG_SKIP_PROBE;
 	}
 
+	if (lba_bus) {
+		lba_next_bus = lba_bus->subordinate + 1;
+		pci_bus_add_devices(lba_bus);
+	}
+
 	/* Whew! Finally done! Tell services we got this one covered. */
 	return 0;
 }

commit 9785d646c10b0707412516ffe56b71b9eb18861f
Author: Grant Grundler <grundler@parisc-linux.org>
Date:   Wed Jan 28 22:30:55 2009 -0700

    parisc: fix wrong assumption about bus->self
    
    Kenji Kaneshige <kaneshige.kenji@jp.fujitsu.com> posted a patch series
    to linux-pci to fix a wrong assumption about pci_bus->self==NULL for
    all PCI host bus controllers. While PARISC platforms to not behave
    this way, I prefer to have the code consistent across architectures.
    The following patch replaces pci_bus->self with pci_bus->parent when
    used as a test to check for "root bus controller".
    
    Signed-off-by: Grant Grundler <grundler@parisc-linux.org>
    Signed-off-by: Kyle McMartin <kyle@mcmartin.ca>

diff --git a/drivers/parisc/lba_pci.c b/drivers/parisc/lba_pci.c
index d8233de8c75d..59fbbf128365 100644
--- a/drivers/parisc/lba_pci.c
+++ b/drivers/parisc/lba_pci.c
@@ -644,7 +644,7 @@ lba_fixup_bus(struct pci_bus *bus)
 	** Properly Setup MMIO resources for this bus.
 	** pci_alloc_primary_bus() mangles this.
 	*/
-	if (bus->self) {
+	if (bus->parent) {
 		int i;
 		/* PCI-PCI Bridge */
 		pci_read_bridge_bases(bus);
@@ -802,7 +802,7 @@ lba_fixup_bus(struct pci_bus *bus)
 ** Can't fixup here anyway....garr...
 */
 	if (fbb_enable) {
-		if (bus->self) {
+		if (bus->parent) {
 			u8 control;
 			/* enable on PPB */
 			(void) pci_read_config_byte(bus->self, PCI_BRIDGE_CONTROL, &control);

commit df8e5bc6b7b61c8b2aeaf58b6afd762d20a651dd
Author: Adrian Bunk <bunk@kernel.org>
Date:   Tue Dec 2 03:28:16 2008 +0000

    parisc: drivers/parisc/: make code static
    
    Make the following needlessly global code static:
    
    - asp.c: asp_init_chip()
    - ccio-dma.c: ccio_io_pdir_entry()
    - dino.c: struct dino_port_ops
    - dino.c: struct dino_bios_ops
    - hppb.c: struct hppb_card_head
    - lasi.c: lasi_led_init()
    - lasi.c: lasi_init_chip()
    - lba_pci.c: struct lba_bios_ops
    - sba_iommu.c: sba_io_pdir_entry()
    - sba_iommu.c: sba_driver_callback()
    - sba_iommu.c: sba_driver_callback()
    - wax.c: wax_init_chip()
    
    Signed-off-by: Adrian Bunk <bunk@kernel.org>
    Cc: Matthew Wilcox <matthew@wil.cx>
    Cc: Grant Grundler <grundler@parisc-linux.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Kyle McMartin <kyle@mcmartin.ca>

diff --git a/drivers/parisc/lba_pci.c b/drivers/parisc/lba_pci.c
index a28c8946deaa..d8233de8c75d 100644
--- a/drivers/parisc/lba_pci.c
+++ b/drivers/parisc/lba_pci.c
@@ -824,7 +824,7 @@ lba_fixup_bus(struct pci_bus *bus)
 }
 
 
-struct pci_bios_ops lba_bios_ops = {
+static struct pci_bios_ops lba_bios_ops = {
 	.init =		lba_bios_init,
 	.fixup_bus =	lba_fixup_bus,
 };

commit a8043ecb17bd2e4b034006bee315efeea3936278
Author: Harvey Harrison <harvey.harrison@gmail.com>
Date:   Wed May 14 16:21:56 2008 -0700

    drivers/parisc: replace remaining __FUNCTION__ occurrences
    
    __FUNCTION__ is gcc-specific, use __func__
    
    Signed-off-by: Harvey Harrison <harvey.harrison@gmail.com>
    Cc: Kyle McMartin <kyle@mcmartin.ca>
    Cc: Matthew Wilcox <willy@debian.org>
    Cc: Grant Grundler <grundler@parisc-linux.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Kyle McMartin <kyle@mcmartin.ca>

diff --git a/drivers/parisc/lba_pci.c b/drivers/parisc/lba_pci.c
index 66ce61048361..a28c8946deaa 100644
--- a/drivers/parisc/lba_pci.c
+++ b/drivers/parisc/lba_pci.c
@@ -377,12 +377,12 @@ static int elroy_cfg_read(struct pci_bus *bus, unsigned int devfn, int pos, int
 		/* original - Generate config cycle on broken elroy
 		  with risk we will miss PCI bus errors. */
 		*data = lba_rd_cfg(d, tok, pos, size);
-		DBG_CFG("%s(%x+%2x) -> 0x%x (a)\n", __FUNCTION__, tok, pos, *data);
+		DBG_CFG("%s(%x+%2x) -> 0x%x (a)\n", __func__, tok, pos, *data);
 		return 0;
 	}
 
 	if (LBA_SKIP_PROBE(d) && !lba_device_present(bus->secondary, devfn, d)) {
-		DBG_CFG("%s(%x+%2x) -> -1 (b)\n", __FUNCTION__, tok, pos);
+		DBG_CFG("%s(%x+%2x) -> -1 (b)\n", __func__, tok, pos);
 		/* either don't want to look or know device isn't present. */
 		*data = ~0U;
 		return(0);
@@ -398,7 +398,7 @@ static int elroy_cfg_read(struct pci_bus *bus, unsigned int devfn, int pos, int
 	case 2: *data = READ_REG16(data_reg + (pos & 2)); break;
 	case 4: *data = READ_REG32(data_reg); break;
 	}
-	DBG_CFG("%s(%x+%2x) -> 0x%x (c)\n", __FUNCTION__, tok, pos, *data);
+	DBG_CFG("%s(%x+%2x) -> 0x%x (c)\n", __func__, tok, pos, *data);
 	return 0;
 }
 
@@ -441,16 +441,16 @@ static int elroy_cfg_write(struct pci_bus *bus, unsigned int devfn, int pos, int
 	if (!LBA_SKIP_PROBE(d)) {
 		/* Original Workaround */
 		lba_wr_cfg(d, tok, pos, (u32) data, size);
-		DBG_CFG("%s(%x+%2x) = 0x%x (a)\n", __FUNCTION__, tok, pos,data);
+		DBG_CFG("%s(%x+%2x) = 0x%x (a)\n", __func__, tok, pos,data);
 		return 0;
 	}
 
 	if (LBA_SKIP_PROBE(d) && (!lba_device_present(bus->secondary, devfn, d))) {
-		DBG_CFG("%s(%x+%2x) = 0x%x (b)\n", __FUNCTION__, tok, pos,data);
+		DBG_CFG("%s(%x+%2x) = 0x%x (b)\n", __func__, tok, pos,data);
 		return 1; /* New Workaround */
 	}
 
-	DBG_CFG("%s(%x+%2x) = 0x%x (c)\n", __FUNCTION__, tok, pos, data);
+	DBG_CFG("%s(%x+%2x) = 0x%x (c)\n", __func__, tok, pos, data);
 
 	/* Basic Algorithm */
 	LBA_CFG_ADDR_SETUP(d, tok | pos);
@@ -521,7 +521,7 @@ static int mercury_cfg_write(struct pci_bus *bus, unsigned int devfn, int pos, i
 	if ((pos > 255) || (devfn > 255))
 		return -EINVAL;
 
-	DBG_CFG("%s(%x+%2x) <- 0x%x (c)\n", __FUNCTION__, tok, pos, data);
+	DBG_CFG("%s(%x+%2x) <- 0x%x (c)\n", __func__, tok, pos, data);
 
 	LBA_CFG_TR4_ADDR_SETUP(d, tok | pos);
 	switch(size) {
@@ -890,7 +890,7 @@ LBA_PORT_IN(32, 0)
 #define LBA_PORT_OUT(size, mask) \
 static void lba_astro_out##size (struct pci_hba_data *d, u16 addr, u##size val) \
 { \
-	DBG_PORT("%s(0x%p, 0x%x, 0x%x)\n", __FUNCTION__, d, addr, val); \
+	DBG_PORT("%s(0x%p, 0x%x, 0x%x)\n", __func__, d, addr, val); \
 	WRITE_REG##size(val, astro_iop_base + addr); \
 	if (LBA_DEV(d)->hw_rev < 3) \
 		lba_t32 = READ_U32(d->base_addr + LBA_FUNC_ID); \
@@ -932,7 +932,7 @@ static struct pci_port_ops lba_astro_port_ops = {
 static u##size lba_pat_in##size (struct pci_hba_data *l, u16 addr) \
 { \
 	u##size t; \
-	DBG_PORT("%s(0x%p, 0x%x) ->", __FUNCTION__, l, addr); \
+	DBG_PORT("%s(0x%p, 0x%x) ->", __func__, l, addr); \
 	t = READ_REG##size(PIOP_TO_GMMIO(LBA_DEV(l), addr)); \
 	DBG_PORT(" 0x%x\n", t); \
 	return (t); \
@@ -948,7 +948,7 @@ LBA_PORT_IN(32, 0)
 static void lba_pat_out##size (struct pci_hba_data *l, u16 addr, u##size val) \
 { \
 	void __iomem *where = PIOP_TO_GMMIO(LBA_DEV(l), addr); \
-	DBG_PORT("%s(0x%p, 0x%x, 0x%x)\n", __FUNCTION__, l, addr, val); \
+	DBG_PORT("%s(0x%p, 0x%x, 0x%x)\n", __func__, l, addr, val); \
 	WRITE_REG##size(val, where); \
 	/* flush the I/O down to the elroy at least */ \
 	lba_t32 = READ_U32(l->base_addr + LBA_FUNC_ID); \
@@ -1584,7 +1584,7 @@ void lba_set_iregs(struct parisc_device *lba, u32 ibase, u32 imask)
 	WARN_ON((ibase & 0x001fffff) != 0);
 	WARN_ON((imask & 0x001fffff) != 0);
 	
-	DBG("%s() ibase 0x%x imask 0x%x\n", __FUNCTION__, ibase, imask);
+	DBG("%s() ibase 0x%x imask 0x%x\n", __func__, ibase, imask);
 	WRITE_REG32( imask, base_addr + LBA_IMASK);
 	WRITE_REG32( ibase, base_addr + LBA_IBASE);
 	iounmap(base_addr);

commit 84f4506cb788d85a50c97b399f2999f90e6272b0
Author: Kyle McMartin <kyle@shortfin.cabal.ca>
Date:   Thu Dec 6 09:38:26 2007 -0800

    [PARISC] lba_pci: pci_claim_resources disabled expansion roms
    
    radeonfb was HPMC-ing my C8000 by trying to map its expansion rom from
    IO_VIEW, instead of PA_VIEW. Fix seems to be to ensure that its disabled
    ROM is properly inserted into the resource tree.
    
    FIXME: this will result in a whinging printk for cards which share expansion
    ROMS, such as a quad tulip. Thankfully, it isn't harmful.
    
    Signed-off-by: Kyle McMartin <kyle@mcmartin.ca>

diff --git a/drivers/parisc/lba_pci.c b/drivers/parisc/lba_pci.c
index 5eace9e66e14..66ce61048361 100644
--- a/drivers/parisc/lba_pci.c
+++ b/drivers/parisc/lba_pci.c
@@ -768,9 +768,13 @@ lba_fixup_bus(struct pci_bus *bus)
 				DBG("lba_fixup_bus() WTF? 0x%lx [%lx/%lx] XXX",
 					res->flags, res->start, res->end);
 			}
-			if ((i != PCI_ROM_RESOURCE) ||
-			    (res->flags & IORESOURCE_ROM_ENABLE))
-				pci_claim_resource(dev, i);
+
+			/*
+			** FIXME: this will result in whinging for devices
+			** that share expansion ROMs (think quad tulip), but
+			** isn't harmful.
+			*/
+			pci_claim_resource(dev, i);
 		}
 
 #ifdef FBB_SUPPORT

commit 9611f61eb5baf22b6b6ed46c2c196c10e1fade6a
Author: Matthew Wilcox <matthew@wil.cx>
Date:   Sun Oct 14 10:13:31 2007 -0400

    [PARISC] Fix infinite loop in /proc/iomem
    
    pcibios_link_hba_resources() could corrupt the resource tree by inserting
    resources in the wrong place.  Fix this by calling pci_claim_resource()
    for PCI-PCI bridges.  Delete pcibios_link_hba_resources as we shouldn't
    need it any more.  Also get rid of lba_claim_dev_resources() and just
    call pci_claim_resource() directly.
    
    Signed-off-by: Matthew Wilcox <willy@linux.intel.com>
    Signed-off-by: Kyle McMartin <kyle@mcmartin.ca>

diff --git a/drivers/parisc/lba_pci.c b/drivers/parisc/lba_pci.c
index 5b86ee5c1eeb..5eace9e66e14 100644
--- a/drivers/parisc/lba_pci.c
+++ b/drivers/parisc/lba_pci.c
@@ -556,44 +556,6 @@ lba_bios_init(void)
 
 #ifdef CONFIG_64BIT
 
-/*
-** Determine if a device is already configured.
-** If so, reserve it resources.
-**
-** Read PCI cfg command register and see if I/O or MMIO is enabled.
-** PAT has to enable the devices it's using.
-**
-** Note: resources are fixed up before we try to claim them.
-*/
-static void
-lba_claim_dev_resources(struct pci_dev *dev)
-{
-	u16 cmd;
-	int i, srch_flags;
-
-	(void) pci_read_config_word(dev, PCI_COMMAND, &cmd);
-
-	srch_flags  = (cmd & PCI_COMMAND_IO) ? IORESOURCE_IO : 0;
-	if (cmd & PCI_COMMAND_MEMORY)
-		srch_flags |= IORESOURCE_MEM;
-
-	if (!srch_flags)
-		return;
-
-	for (i = 0; i <= PCI_ROM_RESOURCE; i++) {
-		if (dev->resource[i].flags & srch_flags) {
-			pci_claim_resource(dev, i);
-			DBG("   claimed %s %d [%lx,%lx]/%lx\n",
-				pci_name(dev), i,
-				dev->resource[i].start,
-				dev->resource[i].end,
-				dev->resource[i].flags
-				);
-		}
-	}
-}
-
-
 /*
  * truncate_pat_collision:  Deal with overlaps or outright collisions
  *			between PAT PDC reported ranges.
@@ -653,7 +615,6 @@ truncate_pat_collision(struct resource *root, struct resource *new)
 }
 
 #else
-#define lba_claim_dev_resources(dev) do { } while (0)
 #define truncate_pat_collision(r,n)  (0)
 #endif
 
@@ -684,8 +645,12 @@ lba_fixup_bus(struct pci_bus *bus)
 	** pci_alloc_primary_bus() mangles this.
 	*/
 	if (bus->self) {
+		int i;
 		/* PCI-PCI Bridge */
 		pci_read_bridge_bases(bus);
+		for (i = PCI_BRIDGE_RESOURCES; i < PCI_NUM_RESOURCES; i++) {
+			pci_claim_resource(bus->self, i);
+		}
 	} else {
 		/* Host-PCI Bridge */
 		int err, i;
@@ -803,6 +768,9 @@ lba_fixup_bus(struct pci_bus *bus)
 				DBG("lba_fixup_bus() WTF? 0x%lx [%lx/%lx] XXX",
 					res->flags, res->start, res->end);
 			}
+			if ((i != PCI_ROM_RESOURCE) ||
+			    (res->flags & IORESOURCE_ROM_ENABLE))
+				pci_claim_resource(dev, i);
 		}
 
 #ifdef FBB_SUPPORT
@@ -814,11 +782,6 @@ lba_fixup_bus(struct pci_bus *bus)
 		bus->bridge_ctl &= ~(status & PCI_STATUS_FAST_BACK);
 #endif
 
-		if (is_pdc_pat()) {
-			/* Claim resources for PDC's devices */
-			lba_claim_dev_resources(dev);
-		}
-
                 /*
 		** P2PB's have no IRQs. ignore them.
 		*/

commit e63340ae6b6205fef26b40a75673d1c9c0c8bb90
Author: Randy Dunlap <randy.dunlap@oracle.com>
Date:   Tue May 8 00:28:08 2007 -0700

    header cleaning: don't include smp_lock.h when not used
    
    Remove includes of <linux/smp_lock.h> where it is not used/needed.
    Suggested by Al Viro.
    
    Builds cleanly on x86_64, i386, alpha, ia64, powerpc, sparc,
    sparc64, and arm (all 59 defconfigs).
    
    Signed-off-by: Randy Dunlap <randy.dunlap@oracle.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/parisc/lba_pci.c b/drivers/parisc/lba_pci.c
index 21c4c299b3d6..5b86ee5c1eeb 100644
--- a/drivers/parisc/lba_pci.c
+++ b/drivers/parisc/lba_pci.c
@@ -38,7 +38,6 @@
 #include <linux/pci.h>
 #include <linux/ioport.h>
 #include <linux/slab.h>
-#include <linux/smp_lock.h>
 
 #include <asm/byteorder.h>
 #include <asm/pdc.h>

commit 645d11d4baa56c6830daac46a92d63b7093cbc09
Author: Matthew Wilcox <matthew@wil.cx>
Date:   Sun Dec 24 19:28:42 2006 -0700

    [PARISC] lba_pci format warnings
    
    Fix resource_size_t warnings in a variety of ways
    
    Signed-off-by: Matthew Wilcox <matthew@wil.cx>
    Signed-off-by: Kyle McMartin <kyle@parisc-linux.org>

diff --git a/drivers/parisc/lba_pci.c b/drivers/parisc/lba_pci.c
index eae0812f01a5..21c4c299b3d6 100644
--- a/drivers/parisc/lba_pci.c
+++ b/drivers/parisc/lba_pci.c
@@ -168,7 +168,8 @@ lba_dump_res(struct resource *r, int d)
 
 	printk(KERN_DEBUG "(%p)", r->parent);
 	for (i = d; i ; --i) printk(" ");
-	printk(KERN_DEBUG "%p [%lx,%lx]/%lx\n", r, r->start, r->end, r->flags);
+	printk(KERN_DEBUG "%p [%lx,%lx]/%lx\n", r,
+		(long)r->start, (long)r->end, r->flags);
 	lba_dump_res(r->child, d+2);
 	lba_dump_res(r->sibling, d);
 }
@@ -647,7 +648,7 @@ truncate_pat_collision(struct resource *root, struct resource *new)
 	printk(KERN_WARNING "LBA: Truncating lmmio_space [%lx/%lx] "
 					"to [%lx,%lx]\n",
 			start, end,
-			new->start, new->end );
+			(long)new->start, (long)new->end );
 
 	return 0;	/* truncation successful */
 }
@@ -715,8 +716,8 @@ lba_fixup_bus(struct pci_bus *bus)
 
 				printk("FAILED: lba_fixup_bus() request for "
 						"elmmio_space [%lx/%lx]\n",
-						ldev->hba.elmmio_space.start,
-						ldev->hba.elmmio_space.end);
+						(long)ldev->hba.elmmio_space.start,
+						(long)ldev->hba.elmmio_space.end);
 
 				/* lba_dump_res(&iomem_resource, 2); */
 				/* BUG(); */
@@ -738,15 +739,15 @@ lba_fixup_bus(struct pci_bus *bus)
 				       	&(ldev->hba.lmmio_space))) {
 
 			printk(KERN_WARNING "LBA: lmmio_space [%lx/%lx] duplicate!\n",
-					ldev->hba.lmmio_space.start,
-					ldev->hba.lmmio_space.end);
+					(long)ldev->hba.lmmio_space.start,
+					(long)ldev->hba.lmmio_space.end);
 		} else {
 			err = request_resource(&iomem_resource, &(ldev->hba.lmmio_space));
 			if (err < 0) {
 				printk(KERN_ERR "FAILED: lba_fixup_bus() request for "
 					"lmmio_space [%lx/%lx]\n",
-					ldev->hba.lmmio_space.start,
-					ldev->hba.lmmio_space.end);
+					(long)ldev->hba.lmmio_space.start,
+					(long)ldev->hba.lmmio_space.end);
 			} else
 				bus->resource[i++] = &(ldev->hba.lmmio_space);
 		}
@@ -758,8 +759,8 @@ lba_fixup_bus(struct pci_bus *bus)
 			if (err < 0) {
 				printk("FAILED: lba_fixup_bus() request for "
 					"gmmio_space [%lx/%lx]\n",
-					ldev->hba.gmmio_space.start,
-					ldev->hba.gmmio_space.end);
+					(long)ldev->hba.gmmio_space.start,
+					(long)ldev->hba.gmmio_space.end);
 				lba_dump_res(&iomem_resource, 2);
 				BUG();
 			}
@@ -1063,16 +1064,16 @@ lba_pat_resources(struct parisc_device *pa_dev, struct lba_device *lba_dev)
 			/* used to fix up pre-initialized MEM BARs */
 			if (!lba_dev->hba.lmmio_space.start) {
 				sprintf(lba_dev->hba.lmmio_name,
-						"PCI%02lx LMMIO",
-						lba_dev->hba.bus_num.start);
+						"PCI%02x LMMIO",
+						(int)lba_dev->hba.bus_num.start);
 				lba_dev->hba.lmmio_space_offset = p->start -
 					io->start;
 				r = &lba_dev->hba.lmmio_space;
 				r->name = lba_dev->hba.lmmio_name;
 			} else if (!lba_dev->hba.elmmio_space.start) {
 				sprintf(lba_dev->hba.elmmio_name,
-						"PCI%02lx ELMMIO",
-						lba_dev->hba.bus_num.start);
+						"PCI%02x ELMMIO",
+						(int)lba_dev->hba.bus_num.start);
 				r = &lba_dev->hba.elmmio_space;
 				r->name = lba_dev->hba.elmmio_name;
 			} else {
@@ -1089,8 +1090,8 @@ lba_pat_resources(struct parisc_device *pa_dev, struct lba_device *lba_dev)
 
 		case PAT_GMMIO:
 			/* MMIO space > 4GB phys addr; for 64-bit BAR */
-			sprintf(lba_dev->hba.gmmio_name, "PCI%02lx GMMIO",
-					lba_dev->hba.bus_num.start);
+			sprintf(lba_dev->hba.gmmio_name, "PCI%02x GMMIO",
+					(int)lba_dev->hba.bus_num.start);
 			r = &lba_dev->hba.gmmio_space;
 			r->name  = lba_dev->hba.gmmio_name;
 			r->start  = p->start;
@@ -1112,8 +1113,8 @@ lba_pat_resources(struct parisc_device *pa_dev, struct lba_device *lba_dev)
 			*/
 			lba_dev->iop_base = ioremap_nocache(p->start, 64 * 1024 * 1024);
 
-			sprintf(lba_dev->hba.io_name, "PCI%02lx Ports",
-					lba_dev->hba.bus_num.start);
+			sprintf(lba_dev->hba.io_name, "PCI%02x Ports",
+					(int)lba_dev->hba.bus_num.start);
 			r = &lba_dev->hba.io_space;
 			r->name  = lba_dev->hba.io_name;
 			r->start  = HBA_PORT_BASE(lba_dev->hba.hba_num);
@@ -1166,8 +1167,8 @@ lba_legacy_resources(struct parisc_device *pa_dev, struct lba_device *lba_dev)
 	** Legacy boxes but it's nice to see in /proc/iomem.
 	*/
 	r = &(lba_dev->hba.lmmio_space);
-	sprintf(lba_dev->hba.lmmio_name, "PCI%02lx LMMIO",
-					lba_dev->hba.bus_num.start);
+	sprintf(lba_dev->hba.lmmio_name, "PCI%02x LMMIO",
+					(int)lba_dev->hba.bus_num.start);
 	r->name  = lba_dev->hba.lmmio_name;
 
 #if 1
@@ -1275,8 +1276,8 @@ lba_legacy_resources(struct parisc_device *pa_dev, struct lba_device *lba_dev)
 	** an existing (but unused portion of) distributed range.
 	*/
 	r = &(lba_dev->hba.elmmio_space);
-	sprintf(lba_dev->hba.elmmio_name, "PCI%02lx ELMMIO",
-					lba_dev->hba.bus_num.start);
+	sprintf(lba_dev->hba.elmmio_name, "PCI%02x ELMMIO",
+					(int)lba_dev->hba.bus_num.start);
 	r->name  = lba_dev->hba.elmmio_name;
 
 #if 1
@@ -1297,8 +1298,8 @@ lba_legacy_resources(struct parisc_device *pa_dev, struct lba_device *lba_dev)
 #endif
 
 	r = &(lba_dev->hba.io_space);
-	sprintf(lba_dev->hba.io_name, "PCI%02lx Ports",
-					lba_dev->hba.bus_num.start);
+	sprintf(lba_dev->hba.io_name, "PCI%02x Ports",
+					(int)lba_dev->hba.bus_num.start);
 	r->name  = lba_dev->hba.io_name;
 	r->flags = IORESOURCE_IO;
 	r->start = READ_REG32(lba_dev->hba.base_addr + LBA_IOS_BASE) & ~1L;
@@ -1447,7 +1448,7 @@ lba_driver_probe(struct parisc_device *dev)
 		}
 
 		printk(KERN_INFO "Elroy version %s (0x%x) found at 0x%lx\n",
-		       version, func_class & 0xf, dev->hpa.start);
+		       version, func_class & 0xf, (long)dev->hpa.start);
 
 		if (func_class < 2) {
 			printk(KERN_WARNING "Can't support LBA older than "
@@ -1477,11 +1478,12 @@ lba_driver_probe(struct parisc_device *dev)
                  */ 
 		printk(KERN_INFO "%s version TR%d.%d (0x%x) found at 0x%lx\n",
 		       IS_MERCURY(dev) ? "Mercury" : "Quicksilver", major,
-		       minor, func_class, dev->hpa.start);
+		       minor, func_class, (long)dev->hpa.start);
 
 		cfg_ops = &mercury_cfg_ops;
 	} else {
-		printk(KERN_ERR "Unknown LBA found at 0x%lx\n", dev->hpa.start);
+		printk(KERN_ERR "Unknown LBA found at 0x%lx\n",
+			(long)dev->hpa.start);
 		return -ENODEV;
 	}
 

commit 353dfe1290bdce1d40609e35ca6e42829623ff5f
Author: Matthew Wilcox <matthew@wil.cx>
Date:   Sat Nov 18 10:11:03 2006 -0700

    [PARISC] Fix PCI bus numbering in the presence of Cardbus bridges
    
    Firmware ignores Cardbus bridges, so when Linux assigns bus numbers,
    it must override firmware's notion of what the busses are numbered.
    This is not sufficient to support the Cardbus bridge as there is also
    no interrupt routing table entry for them.
    
    Signed-off-by: Matthew Wilcox <matthew@wil.cx>
    Signed-off-by: Kyle McMartin <kyle@parisc-linux.org>

diff --git a/drivers/parisc/lba_pci.c b/drivers/parisc/lba_pci.c
index ad4a1a12a1ae..eae0812f01a5 100644
--- a/drivers/parisc/lba_pci.c
+++ b/drivers/parisc/lba_pci.c
@@ -1406,13 +1406,20 @@ lba_hw_init(struct lba_device *d)
 	return 0;
 }
 
-
+/*
+ * Unfortunately, when firmware numbers busses, it doesn't take into account
+ * Cardbus bridges.  So we have to renumber the busses to suit ourselves.
+ * Elroy/Mercury don't actually know what bus number they're attached to;
+ * we use bus 0 to indicate the directly attached bus and any other bus
+ * number will be taken care of by the PCI-PCI bridge.
+ */
+static unsigned int lba_next_bus = 0;
 
 /*
-** Determine if lba should claim this chip (return 0) or not (return 1).
-** If so, initialize the chip and tell other partners in crime they
-** have work to do.
-*/
+ * Determine if lba should claim this chip (return 0) or not (return 1).
+ * If so, initialize the chip and tell other partners in crime they
+ * have work to do.
+ */
 static int __init
 lba_driver_probe(struct parisc_device *dev)
 {
@@ -1478,9 +1485,7 @@ lba_driver_probe(struct parisc_device *dev)
 		return -ENODEV;
 	}
 
-	/*
-	** Tell I/O SAPIC driver we have a IRQ handler/region.
-	*/
+	/* Tell I/O SAPIC driver we have a IRQ handler/region. */
 	tmp_obj = iosapic_register(dev->hpa.start + LBA_IOSAPIC_BASE);
 
 	/* NOTE: PCI devices (e.g. 103c:1005 graphics card) which don't
@@ -1529,16 +1534,17 @@ lba_driver_probe(struct parisc_device *dev)
 		lba_legacy_resources(dev, lba_dev);
 	}
 
-	/* 
-	** Tell PCI support another PCI bus was found.
-	** Walks PCI bus for us too.
-	*/
+	if (lba_dev->hba.bus_num.start < lba_next_bus)
+		lba_dev->hba.bus_num.start = lba_next_bus;
+
 	dev->dev.platform_data = lba_dev;
 	lba_bus = lba_dev->hba.hba_bus =
 		pci_scan_bus_parented(&dev->dev, lba_dev->hba.bus_num.start,
 				cfg_ops, NULL);
-	if (lba_bus)
+	if (lba_bus) {
+		lba_next_bus = lba_bus->subordinate + 1;
 		pci_bus_add_devices(lba_bus);
+	}
 
 	/* This is in lieu of calling pci_assign_unassigned_resources() */
 	if (is_pdc_pat()) {

commit c2c4798e04ef836b12f5df04e7d1a1710cb39301
Author: Matthew Wilcox <matthew@wil.cx>
Date:   Thu Oct 26 10:06:07 2006 -0600

    [PARISC] sparse fixes
    
    0/NULL, missing __user, missing __iomem, non-ANSI prototype.
    
    Signed-off-by: Matthew Wilcox <willy@parisc-linux.org>
    Signed-off-by: Kyle McMartin <kyle@parisc-linux.org>

diff --git a/drivers/parisc/lba_pci.c b/drivers/parisc/lba_pci.c
index ba6769934c77..ad4a1a12a1ae 100644
--- a/drivers/parisc/lba_pci.c
+++ b/drivers/parisc/lba_pci.c
@@ -980,7 +980,7 @@ LBA_PORT_IN(32, 0)
 #define LBA_PORT_OUT(size, mask) \
 static void lba_pat_out##size (struct pci_hba_data *l, u16 addr, u##size val) \
 { \
-	void *where = (void *) PIOP_TO_GMMIO(LBA_DEV(l), addr); \
+	void __iomem *where = PIOP_TO_GMMIO(LBA_DEV(l), addr); \
 	DBG_PORT("%s(0x%p, 0x%x, 0x%x)\n", __FUNCTION__, l, addr, val); \
 	WRITE_REG##size(val, where); \
 	/* flush the I/O down to the elroy at least */ \

commit 983daeec99f07fca0a8a9180ba1ca65bbd40c820
Author: Kyle McMartin <kyle@parisc-linux.org>
Date:   Fri Aug 25 12:28:24 2006 -0400

    [PARISC] Move LBA and SBA register defines to the common ropes.h
    
    header. This will allow the use of more constants in the
    agpgart driver.
    
    Signed-off-by: Kyle McMartin <kyle@parisc-linux.org>

diff --git a/drivers/parisc/lba_pci.c b/drivers/parisc/lba_pci.c
index 98f03686a710..ba6769934c77 100644
--- a/drivers/parisc/lba_pci.c
+++ b/drivers/parisc/lba_pci.c
@@ -100,71 +100,6 @@
 
 #define MODULE_NAME "LBA"
 
-#define LBA_FUNC_ID	0x0000	/* function id */
-#define LBA_FCLASS	0x0008	/* function class, bist, header, rev... */
-#define LBA_CAPABLE	0x0030	/* capabilities register */
-
-#define LBA_PCI_CFG_ADDR	0x0040	/* poke CFG address here */
-#define LBA_PCI_CFG_DATA	0x0048	/* read or write data here */
-
-#define LBA_PMC_MTLT	0x0050	/* Firmware sets this - read only. */
-#define LBA_FW_SCRATCH	0x0058	/* Firmware writes the PCI bus number here. */
-#define LBA_ERROR_ADDR	0x0070	/* On error, address gets logged here */
-
-#define LBA_ARB_MASK	0x0080	/* bit 0 enable arbitration. PAT/PDC enables */
-#define LBA_ARB_PRI	0x0088	/* firmware sets this. */
-#define LBA_ARB_MODE	0x0090	/* firmware sets this. */
-#define LBA_ARB_MTLT	0x0098	/* firmware sets this. */
-
-#define LBA_MOD_ID	0x0100	/* Module ID. PDC_PAT_CELL reports 4 */
-
-#define LBA_STAT_CTL	0x0108	/* Status & Control */
-#define   LBA_BUS_RESET		0x01	/*  Deassert PCI Bus Reset Signal */
-#define   CLEAR_ERRLOG		0x10	/*  "Clear Error Log" cmd */
-#define   CLEAR_ERRLOG_ENABLE	0x20	/*  "Clear Error Log" Enable */
-#define   HF_ENABLE	0x40	/*    enable HF mode (default is -1 mode) */
-
-#define LBA_LMMIO_BASE	0x0200	/* < 4GB I/O address range */
-#define LBA_LMMIO_MASK	0x0208
-
-#define LBA_GMMIO_BASE	0x0210	/* > 4GB I/O address range */
-#define LBA_GMMIO_MASK	0x0218
-
-#define LBA_WLMMIO_BASE	0x0220	/* All < 4GB ranges under the same *SBA* */
-#define LBA_WLMMIO_MASK	0x0228
-
-#define LBA_WGMMIO_BASE	0x0230	/* All > 4GB ranges under the same *SBA* */
-#define LBA_WGMMIO_MASK	0x0238
-
-#define LBA_IOS_BASE	0x0240	/* I/O port space for this LBA */
-#define LBA_IOS_MASK	0x0248
-
-#define LBA_ELMMIO_BASE	0x0250	/* Extra LMMIO range */
-#define LBA_ELMMIO_MASK	0x0258
-
-#define LBA_EIOS_BASE	0x0260	/* Extra I/O port space */
-#define LBA_EIOS_MASK	0x0268
-
-#define LBA_GLOBAL_MASK	0x0270	/* Mercury only: Global Address Mask */
-#define LBA_DMA_CTL	0x0278	/* firmware sets this */
-
-#define LBA_IBASE	0x0300	/* SBA DMA support */
-#define LBA_IMASK	0x0308
-
-/* FIXME: ignore DMA Hint stuff until we can measure performance */
-#define LBA_HINT_CFG	0x0310
-#define LBA_HINT_BASE	0x0380	/* 14 registers at every 8 bytes. */
-
-#define LBA_BUS_MODE	0x0620
-
-/* ERROR regs are needed for config cycle kluges */
-#define LBA_ERROR_CONFIG 0x0680
-#define     LBA_SMART_MODE 0x20
-#define LBA_ERROR_STATUS 0x0688
-#define LBA_ROPE_CTL     0x06A0
-
-#define LBA_IOSAPIC_BASE	0x800 /* Offset of IRQ logic */
-
 /* non-postable I/O port space, densely packed */
 #define LBA_PORT_BASE	(PCI_F_EXTEND | 0xfee00000UL)
 static void __iomem *astro_iop_base __read_mostly;

commit 1790cf9111f61d360d861901b97eba4de3b5414c
Author: Kyle McMartin <kyle@parisc-linux.org>
Date:   Thu Aug 24 21:32:49 2006 -0400

    [PARISC] Create shared <asm/ropes.h> header
    
    Pull out struct sba_device and struct lba_device into a
    common ropes.h header. Also fold the parisc portion of
    iosapic.h into this file. (Then delete the useless portion
    of iosapic.h)
    
    Signed-off-by: Kyle McMartin <kyle@parisc-linux.org>

diff --git a/drivers/parisc/lba_pci.c b/drivers/parisc/lba_pci.c
index a596dbc804a3..98f03686a710 100644
--- a/drivers/parisc/lba_pci.c
+++ b/drivers/parisc/lba_pci.c
@@ -46,9 +46,9 @@
 #include <asm/page.h>
 #include <asm/system.h>
 
+#include <asm/ropes.h>
 #include <asm/hardware.h>	/* for register_parisc_driver() stuff */
 #include <asm/parisc-device.h>
-#include <asm/iosapic.h>	/* for iosapic_register() */
 #include <asm/io.h>		/* read/write stuff */
 
 #undef DEBUG_LBA	/* general stuff */
@@ -169,44 +169,6 @@
 #define LBA_PORT_BASE	(PCI_F_EXTEND | 0xfee00000UL)
 static void __iomem *astro_iop_base __read_mostly;
 
-#define ELROY_HVERS	0x782
-#define MERCURY_HVERS	0x783
-#define QUICKSILVER_HVERS	0x784
-
-static inline int IS_ELROY(struct parisc_device *d)
-{
-	return (d->id.hversion == ELROY_HVERS);
-}
-
-static inline int IS_MERCURY(struct parisc_device *d)
-{
-	return (d->id.hversion == MERCURY_HVERS);
-}
-
-static inline int IS_QUICKSILVER(struct parisc_device *d)
-{
-	return (d->id.hversion == QUICKSILVER_HVERS);
-}
-
-
-/*
-** lba_device: Per instance Elroy data structure
-*/
-struct lba_device {
-	struct pci_hba_data hba;
-
-	spinlock_t	lba_lock;
-	void		*iosapic_obj;
-
-#ifdef CONFIG_64BIT
-	void __iomem *	iop_base;    /* PA_VIEW - for IO port accessor funcs */
-#endif
-
-	int		flags;       /* state/functionality enabled */
-	int		hw_rev;      /* HW revision of chip */
-};
-
-
 static u32 lba_t32;
 
 /* lba flags */

commit b0eecc4da9c0a5261711e0d83280fd5d1e3db742
Author: Kyle McMartin <kyle@parisc-linux.org>
Date:   Thu Aug 24 21:31:41 2006 -0400

    [PARISC] Stash the lba_device in its struct device drvdata
    
    Signed-off-by: Kyle McMartin <kyle@parisc-linux.org>

diff --git a/drivers/parisc/lba_pci.c b/drivers/parisc/lba_pci.c
index 33d1806a39cc..a596dbc804a3 100644
--- a/drivers/parisc/lba_pci.c
+++ b/drivers/parisc/lba_pci.c
@@ -1604,6 +1604,7 @@ lba_driver_probe(struct parisc_device *dev)
 	lba_dev->hba.dev = dev;
 	lba_dev->iosapic_obj = tmp_obj;  /* save interrupt handle */
 	lba_dev->hba.iommu = sba_get_iommu(dev);  /* get iommu data */
+	parisc_set_drvdata(dev, lba_dev);
 
 	/* ------------ Second : initialize common stuff ---------- */
 	pci_bios = &lba_bios_ops;

commit ba9877b6734fb0313bca99ae2077613f24ff5b5c
Author: Kyle McMartin <kyle@parisc-linux.org>
Date:   Thu Aug 24 21:28:58 2006 -0400

    [PARISC] Pretty print the name of the lba type on kernel boot
    
    (it's pretty useless telling a user they have a whole bunch of
     TR%d.%d LBAs)
    
    Signed-off-by: Kyle McMartin <kyle@parisc-linux.org>

diff --git a/drivers/parisc/lba_pci.c b/drivers/parisc/lba_pci.c
index 3fe4a77fa16a..33d1806a39cc 100644
--- a/drivers/parisc/lba_pci.c
+++ b/drivers/parisc/lba_pci.c
@@ -1542,8 +1542,8 @@ lba_driver_probe(struct parisc_device *dev)
 		default: version = "TR4+";
 		}
 
-		printk(KERN_INFO "%s version %s (0x%x) found at 0x%lx\n",
-			MODULE_NAME, version, func_class & 0xf, dev->hpa.start);
+		printk(KERN_INFO "Elroy version %s (0x%x) found at 0x%lx\n",
+		       version, func_class & 0xf, dev->hpa.start);
 
 		if (func_class < 2) {
 			printk(KERN_WARNING "Can't support LBA older than "
@@ -1563,14 +1563,18 @@ lba_driver_probe(struct parisc_device *dev)
 		}
 
 	} else if (IS_MERCURY(dev) || IS_QUICKSILVER(dev)) {
+		int major, minor;
+
 		func_class &= 0xff;
-		version = kmalloc(6, GFP_KERNEL);
-		snprintf(version, 6, "TR%d.%d",(func_class >> 4),(func_class & 0xf));
+		major = func_class >> 4, minor = func_class & 0xf;
+
 		/* We could use one printk for both Elroy and Mercury,
                  * but for the mask for func_class.
                  */ 
-		printk(KERN_INFO "%s version %s (0x%x) found at 0x%lx\n",
-		       MODULE_NAME, version, func_class & 0xff, dev->hpa.start);
+		printk(KERN_INFO "%s version TR%d.%d (0x%x) found at 0x%lx\n",
+		       IS_MERCURY(dev) ? "Mercury" : "Quicksilver", major,
+		       minor, func_class, dev->hpa.start);
+
 		cfg_ops = &mercury_cfg_ops;
 	} else {
 		printk(KERN_ERR "Unknown LBA found at 0x%lx\n", dev->hpa.start);

commit 5076c15862644edb91d2e3436b2fa3e07b28385d
Author: Helge Deller <deller@parisc-linux.org>
Date:   Mon Mar 27 12:52:15 2006 -0700

    [PARISC] I/O-Space must be ioremap_nocache()'d
    
    Addresses in F-space must be accessed uncached on most parisc machines.
    
    Signed-off-by: Helge Deller <deller@parisc-linux.org>
    Signed-off-by: Kyle McMartin <kyle@parisc-linux.org>

diff --git a/drivers/parisc/lba_pci.c b/drivers/parisc/lba_pci.c
index e8a2a4a852f5..3fe4a77fa16a 100644
--- a/drivers/parisc/lba_pci.c
+++ b/drivers/parisc/lba_pci.c
@@ -1213,7 +1213,7 @@ lba_pat_resources(struct parisc_device *pa_dev, struct lba_device *lba_dev)
 			** Postable I/O port space is per PCI host adapter.
 			** base of 64MB PIOP region
 			*/
-			lba_dev->iop_base = ioremap(p->start, 64 * 1024 * 1024);
+			lba_dev->iop_base = ioremap_nocache(p->start, 64 * 1024 * 1024);
 
 			sprintf(lba_dev->hba.io_name, "PCI%02lx Ports",
 					lba_dev->hba.bus_num.start);
@@ -1525,7 +1525,7 @@ lba_driver_probe(struct parisc_device *dev)
 	u32 func_class;
 	void *tmp_obj;
 	char *version;
-	void __iomem *addr = ioremap(dev->hpa.start, 4096);
+	void __iomem *addr = ioremap_nocache(dev->hpa.start, 4096);
 
 	/* Read HW Rev First */
 	func_class = READ_REG32(addr + LBA_FCLASS);
@@ -1619,7 +1619,7 @@ lba_driver_probe(struct parisc_device *dev)
 	} else {
 		if (!astro_iop_base) {
 			/* Sprockets PDC uses NPIOP region */
-			astro_iop_base = ioremap(LBA_PORT_BASE, 64 * 1024);
+			astro_iop_base = ioremap_nocache(LBA_PORT_BASE, 64 * 1024);
 			pci_port = &lba_astro_port_ops;
 		}
 
@@ -1700,7 +1700,7 @@ void __init lba_init(void)
 */
 void lba_set_iregs(struct parisc_device *lba, u32 ibase, u32 imask)
 {
-	void __iomem * base_addr = ioremap(lba->hpa.start, 4096);
+	void __iomem * base_addr = ioremap_nocache(lba->hpa.start, 4096);
 
 	imask <<= 2;	/* adjust for hints - 2 more bits */
 

commit cb6fc18e9ca615f03d18e60c49855b434ca2e51e
Author: Helge Deller <deller@parisc-linux.org>
Date:   Tue Jan 17 12:40:40 2006 -0700

    [PARISC] Use kzalloc and other janitor-style cleanups
    
    Helge,
      o Convert a bunch of kmalloc/memset uses to kzalloc.
      o pci.c: Add some __read_mostly annotations.
      o pci.c: Move constant pci_post_reset_delay to asm/pci.h
      o grfioctl.h: Add A4450A to comment of CRT_ID_VISUALIZE_EG.
      o Add some consts to perf.c/perf_images.h
    
    Matthew,
      o sticore.c: Add some consts to suppress compile warnings.
    
    Signed-off-by: Helge Deller <deller@parisc-linux.org>
    Signed-off-by: Matthew Wilcox <willy@parisc-linux.org>
    Signed-off-by: Kyle McMartin <kyle@parisc-linux.org>

diff --git a/drivers/parisc/lba_pci.c b/drivers/parisc/lba_pci.c
index cbae8c8963fa..e8a2a4a852f5 100644
--- a/drivers/parisc/lba_pci.c
+++ b/drivers/parisc/lba_pci.c
@@ -1565,7 +1565,7 @@ lba_driver_probe(struct parisc_device *dev)
 	} else if (IS_MERCURY(dev) || IS_QUICKSILVER(dev)) {
 		func_class &= 0xff;
 		version = kmalloc(6, GFP_KERNEL);
-		sprintf(version,"TR%d.%d",(func_class >> 4),(func_class & 0xf));
+		snprintf(version, 6, "TR%d.%d",(func_class >> 4),(func_class & 0xf));
 		/* We could use one printk for both Elroy and Mercury,
                  * but for the mask for func_class.
                  */ 
@@ -1586,14 +1586,12 @@ lba_driver_probe(struct parisc_device *dev)
 	**	have an IRT entry will get NULL back from iosapic code.
 	*/
 	
-	lba_dev = kmalloc(sizeof(struct lba_device), GFP_KERNEL);
+	lba_dev = kzalloc(sizeof(struct lba_device), GFP_KERNEL);
 	if (!lba_dev) {
 		printk(KERN_ERR "lba_init_chip - couldn't alloc lba_device\n");
 		return(1);
 	}
 
-	memset(lba_dev, 0, sizeof(struct lba_device));
-
 
 	/* ---------- First : initialize data we already have --------- */
 

commit 6ca45a24ccb847251f71aec8906746d33e99f33e
Author: Grant Grundler <grundler@parisc-linux.org>
Date:   Tue Jan 10 20:47:56 2006 -0500

    [PARISC] Truncate overlapping PAT PDC reported ranges
    
    Deal with overlapping LBA MMIO resources,
    
    rp3440 PDC BUG: PDC reports lmmio range for the last rope that overlaps
    with the CPU HPA. Console output was:
    
    ...
    Found devices:
    1. Storm Peak Fast at 0xfffffffffe798000 [152] { 0, 0x0, 0x889, 0x00004 }
    2. Storm Peak Fast at 0xfffffffffe799000 [153] { 0, 0x0, 0x889, 0x00004 }
    ...
    FAILED: lba_fixup_bus() request for lmmio_space
    [fffffffff0000000/fffffffffecffffe]
    
    Output is now:
    
    LBA: Truncating lmmio_space [fffffffff0000000/fffffffffecffffe] to
    [fffffffff0000000,fffffffffe797fff]
    
    My only concern with this patch is how C8000 (PAT PDC) will report
    elmmio ranges when a gfx card is installed. I'll have to test this
    another day.
    
    Signed-off-by: Grant Grundler <grundler@parisc-linux.org>
    Signed-off-by: James Bottomley <jejb@parisc-linux.org>
    Signed-off-by: Matthew Wilcox <willy@parisc-linux.org>
    Signed-off-by: Kyle McMartin <kyle@parisc-linux.org>

diff --git a/drivers/parisc/lba_pci.c b/drivers/parisc/lba_pci.c
index 4f6bdf0881b5..cbae8c8963fa 100644
--- a/drivers/parisc/lba_pci.c
+++ b/drivers/parisc/lba_pci.c
@@ -695,11 +695,71 @@ lba_claim_dev_resources(struct pci_dev *dev)
 		}
 	}
 }
+
+
+/*
+ * truncate_pat_collision:  Deal with overlaps or outright collisions
+ *			between PAT PDC reported ranges.
+ *
+ *   Broken PA8800 firmware will report lmmio range that
+ *   overlaps with CPU HPA. Just truncate the lmmio range.
+ *
+ *   BEWARE: conflicts with this lmmio range may be an
+ *   elmmio range which is pointing down another rope.
+ *
+ *  FIXME: only deals with one collision per range...theoretically we
+ *  could have several. Supporting more than one collision will get messy.
+ */
+static unsigned long
+truncate_pat_collision(struct resource *root, struct resource *new)
+{
+	unsigned long start = new->start;
+	unsigned long end = new->end;
+	struct resource *tmp = root->child;
+
+	if (end <= start || start < root->start || !tmp)
+		return 0;
+
+	/* find first overlap */
+	while (tmp && tmp->end < start)
+		tmp = tmp->sibling;
+
+	/* no entries overlap */
+	if (!tmp)  return 0;
+
+	/* found one that starts behind the new one
+	** Don't need to do anything.
+	*/
+	if (tmp->start >= end) return 0;
+
+	if (tmp->start <= start) {
+		/* "front" of new one overlaps */
+		new->start = tmp->end + 1;
+
+		if (tmp->end >= end) {
+			/* AACCKK! totally overlaps! drop this range. */
+			return 1;
+		}
+	} 
+
+	if (tmp->end < end ) {
+		/* "end" of new one overlaps */
+		new->end = tmp->start - 1;
+	}
+
+	printk(KERN_WARNING "LBA: Truncating lmmio_space [%lx/%lx] "
+					"to [%lx,%lx]\n",
+			start, end,
+			new->start, new->end );
+
+	return 0;	/* truncation successful */
+}
+
 #else
-#define lba_claim_dev_resources(dev)
+#define lba_claim_dev_resources(dev) do { } while (0)
+#define truncate_pat_collision(r,n)  (0)
 #endif
 
-
 /*
 ** The algorithm is generic code.
 ** But it needs to access local data structures to get the IRQ base.
@@ -747,6 +807,9 @@ lba_fixup_bus(struct pci_bus *bus)
 			lba_dump_res(&ioport_resource, 2);
 			BUG();
 		}
+		/* advertize Host bridge resources to PCI bus */
+		bus->resource[0] = &(ldev->hba.io_space);
+		i = 1;
 
 		if (ldev->hba.elmmio_space.start) {
 			err = request_resource(&iomem_resource,
@@ -760,23 +823,35 @@ lba_fixup_bus(struct pci_bus *bus)
 
 				/* lba_dump_res(&iomem_resource, 2); */
 				/* BUG(); */
-			}
+			} else
+				bus->resource[i++] = &(ldev->hba.elmmio_space);
 		}
 
-		err = request_resource(&iomem_resource, &(ldev->hba.lmmio_space));
-		if (err < 0) {
-			/*   FIXME  overlaps with elmmio will fail here.
-			 *   Need to prune (or disable) the distributed range.
-			 *
-			 *   BEWARE: conflicts with this lmmio range may be
-			 *   elmmio range which is pointing down another rope.
-			 */
-
-			printk("FAILED: lba_fixup_bus() request for "
+
+		/*   Overlaps with elmmio can (and should) fail here.
+		 *   We will prune (or ignore) the distributed range.
+		 *
+		 *   FIXME: SBA code should register all elmmio ranges first.
+		 *      that would take care of elmmio ranges routed
+		 *	to a different rope (already discovered) from
+		 *	getting registered *after* LBA code has already
+		 *	registered it's distributed lmmio range.
+		 */
+		if (truncate_pat_collision(&iomem_resource,
+				       	&(ldev->hba.lmmio_space))) {
+
+			printk(KERN_WARNING "LBA: lmmio_space [%lx/%lx] duplicate!\n",
+					ldev->hba.lmmio_space.start,
+					ldev->hba.lmmio_space.end);
+		} else {
+			err = request_resource(&iomem_resource, &(ldev->hba.lmmio_space));
+			if (err < 0) {
+				printk(KERN_ERR "FAILED: lba_fixup_bus() request for "
 					"lmmio_space [%lx/%lx]\n",
 					ldev->hba.lmmio_space.start,
 					ldev->hba.lmmio_space.end);
-			/* lba_dump_res(&iomem_resource, 2); */
+			} else
+				bus->resource[i++] = &(ldev->hba.lmmio_space);
 		}
 
 #ifdef CONFIG_64BIT
@@ -791,18 +866,10 @@ lba_fixup_bus(struct pci_bus *bus)
 				lba_dump_res(&iomem_resource, 2);
 				BUG();
 			}
+			bus->resource[i++] = &(ldev->hba.gmmio_space);
 		}
 #endif
 
-		/* advertize Host bridge resources to PCI bus */
-		bus->resource[0] = &(ldev->hba.io_space);
-		bus->resource[1] = &(ldev->hba.lmmio_space);
-		i=2;
-		if (ldev->hba.elmmio_space.start)
-			bus->resource[i++] = &(ldev->hba.elmmio_space);
-		if (ldev->hba.gmmio_space.start)
-			bus->resource[i++] = &(ldev->hba.gmmio_space);
-			
 	}
 
 	list_for_each(ln, &bus->devices) {

commit 8039de10aae3cd4cf0ef0ccebd58aff0e8810df2
Author: Helge Deller <deller@parisc-linux.org>
Date:   Tue Jan 10 20:35:03 2006 -0500

    [PARISC] Add __read_mostly section for parisc
    
    Flag a whole bunch of things as __read_mostly on parisc. Also flag a few
    branches as unlikely() and cleanup a bit of code.
    
    Signed-off-by: Helge Deller <deller@parisc-linux.org>
    Signed-off-by: Kyle McMartin <kyle@parisc-linux.org>

diff --git a/drivers/parisc/lba_pci.c b/drivers/parisc/lba_pci.c
index 5e495dcbc58a..4f6bdf0881b5 100644
--- a/drivers/parisc/lba_pci.c
+++ b/drivers/parisc/lba_pci.c
@@ -167,7 +167,7 @@
 
 /* non-postable I/O port space, densely packed */
 #define LBA_PORT_BASE	(PCI_F_EXTEND | 0xfee00000UL)
-static void __iomem *astro_iop_base;
+static void __iomem *astro_iop_base __read_mostly;
 
 #define ELROY_HVERS	0x782
 #define MERCURY_HVERS	0x783

commit 53f01bba49938f115237fe43a261c31ac13ae5c6
Author: Matthew Wilcox <willy@parisc-linux.org>
Date:   Fri Oct 21 22:36:40 2005 -0400

    [PARISC] Convert parisc_device to use struct resource for hpa
    
    Convert pa_dev->hpa from an unsigned long to a struct resource.
    
    Signed-off-by: Matthew Wilcox <willy@parisc-linux.org>
    
    Fix up users of ->hpa to use ->hpa.start instead.
    
    Signed-off-by: Matthew Wilcox <willy@parisc-linux.org>
    
    Signed-off-by: Kyle McMartin <kyle@parisc-linux.org>

diff --git a/drivers/parisc/lba_pci.c b/drivers/parisc/lba_pci.c
index 7fdd80b7eb47..5e495dcbc58a 100644
--- a/drivers/parisc/lba_pci.c
+++ b/drivers/parisc/lba_pci.c
@@ -1288,7 +1288,7 @@ lba_legacy_resources(struct parisc_device *pa_dev, struct lba_device *lba_dev)
 		** Adjust "window" for this rope.
 		*/
 		rsize /= ROPES_PER_IOC;
-		r->start += (rsize + 1) * LBA_NUM(pa_dev->hpa);
+		r->start += (rsize + 1) * LBA_NUM(pa_dev->hpa.start);
 		r->end = r->start + rsize;
 	} else {
 		r->end = r->start = 0;	/* Not enabled. */
@@ -1458,7 +1458,7 @@ lba_driver_probe(struct parisc_device *dev)
 	u32 func_class;
 	void *tmp_obj;
 	char *version;
-	void __iomem *addr = ioremap(dev->hpa, 4096);
+	void __iomem *addr = ioremap(dev->hpa.start, 4096);
 
 	/* Read HW Rev First */
 	func_class = READ_REG32(addr + LBA_FCLASS);
@@ -1476,7 +1476,7 @@ lba_driver_probe(struct parisc_device *dev)
 		}
 
 		printk(KERN_INFO "%s version %s (0x%x) found at 0x%lx\n",
-			MODULE_NAME, version, func_class & 0xf, dev->hpa);
+			MODULE_NAME, version, func_class & 0xf, dev->hpa.start);
 
 		if (func_class < 2) {
 			printk(KERN_WARNING "Can't support LBA older than "
@@ -1503,17 +1503,17 @@ lba_driver_probe(struct parisc_device *dev)
                  * but for the mask for func_class.
                  */ 
 		printk(KERN_INFO "%s version %s (0x%x) found at 0x%lx\n",
-			MODULE_NAME, version, func_class & 0xff, dev->hpa);
+		       MODULE_NAME, version, func_class & 0xff, dev->hpa.start);
 		cfg_ops = &mercury_cfg_ops;
 	} else {
-		printk(KERN_ERR "Unknown LBA found at 0x%lx\n", dev->hpa);
+		printk(KERN_ERR "Unknown LBA found at 0x%lx\n", dev->hpa.start);
 		return -ENODEV;
 	}
 
 	/*
 	** Tell I/O SAPIC driver we have a IRQ handler/region.
 	*/
-	tmp_obj = iosapic_register(dev->hpa + LBA_IOSAPIC_BASE);
+	tmp_obj = iosapic_register(dev->hpa.start + LBA_IOSAPIC_BASE);
 
 	/* NOTE: PCI devices (e.g. 103c:1005 graphics card) which don't
 	**	have an IRT entry will get NULL back from iosapic code.
@@ -1635,7 +1635,7 @@ void __init lba_init(void)
 */
 void lba_set_iregs(struct parisc_device *lba, u32 ibase, u32 imask)
 {
-	void __iomem * base_addr = ioremap(lba->hpa, 4096);
+	void __iomem * base_addr = ioremap(lba->hpa.start, 4096);
 
 	imask <<= 2;	/* adjust for hints - 2 more bits */
 

commit c431ada45d65b305a6aab4557067e564b23ce5a5
Author: Rajesh Shah <rajesh.shah@intel.com>
Date:   Thu Apr 28 00:25:45 2005 -0700

    [PATCH] acpi bridge hotadd: ACPI based root bridge hot-add
    
    When you hot-plug a (root) bridge hierarchy, it may have p2p bridges and
    devices attached to it that have not been configured by firmware.  In this
    case, we need to configure the devices before starting them.  This patch
    separates device start from device scan so that we can introduce the
    configuration step in the middle.
    
    I kept the existing semantics for pci_scan_bus() since there are a huge number
    of callers to that function.
    
    Also, I have no way of testing the changes I made to the parisc files, so this
    needs review by those folks.  Sorry for the massive cross-post, this touches
    files in many different places.
    
    Signed-off-by: Rajesh Shah <rajesh.shah@intel.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/parisc/lba_pci.c b/drivers/parisc/lba_pci.c
index dc838804c0dd..7fdd80b7eb47 100644
--- a/drivers/parisc/lba_pci.c
+++ b/drivers/parisc/lba_pci.c
@@ -1570,6 +1570,8 @@ lba_driver_probe(struct parisc_device *dev)
 	lba_bus = lba_dev->hba.hba_bus =
 		pci_scan_bus_parented(&dev->dev, lba_dev->hba.bus_num.start,
 				cfg_ops, NULL);
+	if (lba_bus)
+		pci_bus_add_devices(lba_bus);
 
 	/* This is in lieu of calling pci_assign_unassigned_resources() */
 	if (is_pdc_pat()) {

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/drivers/parisc/lba_pci.c b/drivers/parisc/lba_pci.c
new file mode 100644
index 000000000000..dc838804c0dd
--- /dev/null
+++ b/drivers/parisc/lba_pci.c
@@ -0,0 +1,1649 @@
+/*
+**
+**  PCI Lower Bus Adapter (LBA) manager
+**
+**	(c) Copyright 1999,2000 Grant Grundler
+**	(c) Copyright 1999,2000 Hewlett-Packard Company
+**
+**	This program is free software; you can redistribute it and/or modify
+**	it under the terms of the GNU General Public License as published by
+**      the Free Software Foundation; either version 2 of the License, or
+**      (at your option) any later version.
+**
+**
+** This module primarily provides access to PCI bus (config/IOport
+** spaces) on platforms with an SBA/LBA chipset. A/B/C/J/L/N-class
+** with 4 digit model numbers - eg C3000 (and A400...sigh).
+**
+** LBA driver isn't as simple as the Dino driver because:
+**   (a) this chip has substantial bug fixes between revisions
+**       (Only one Dino bug has a software workaround :^(  )
+**   (b) has more options which we don't (yet) support (DMA hints, OLARD)
+**   (c) IRQ support lives in the I/O SAPIC driver (not with PCI driver)
+**   (d) play nicely with both PAT and "Legacy" PA-RISC firmware (PDC).
+**       (dino only deals with "Legacy" PDC)
+**
+** LBA driver passes the I/O SAPIC HPA to the I/O SAPIC driver.
+** (I/O SAPIC is integratd in the LBA chip).
+**
+** FIXME: Add support to SBA and LBA drivers for DMA hint sets
+** FIXME: Add support for PCI card hot-plug (OLARD).
+*/
+
+#include <linux/delay.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/spinlock.h>
+#include <linux/init.h>		/* for __init and __devinit */
+#include <linux/pci.h>
+#include <linux/ioport.h>
+#include <linux/slab.h>
+#include <linux/smp_lock.h>
+
+#include <asm/byteorder.h>
+#include <asm/pdc.h>
+#include <asm/pdcpat.h>
+#include <asm/page.h>
+#include <asm/system.h>
+
+#include <asm/hardware.h>	/* for register_parisc_driver() stuff */
+#include <asm/parisc-device.h>
+#include <asm/iosapic.h>	/* for iosapic_register() */
+#include <asm/io.h>		/* read/write stuff */
+
+#undef DEBUG_LBA	/* general stuff */
+#undef DEBUG_LBA_PORT	/* debug I/O Port access */
+#undef DEBUG_LBA_CFG	/* debug Config Space Access (ie PCI Bus walk) */
+#undef DEBUG_LBA_PAT	/* debug PCI Resource Mgt code - PDC PAT only */
+
+#undef FBB_SUPPORT	/* Fast Back-Back xfers - NOT READY YET */
+
+
+#ifdef DEBUG_LBA
+#define DBG(x...)	printk(x)
+#else
+#define DBG(x...)
+#endif
+
+#ifdef DEBUG_LBA_PORT
+#define DBG_PORT(x...)	printk(x)
+#else
+#define DBG_PORT(x...)
+#endif
+
+#ifdef DEBUG_LBA_CFG
+#define DBG_CFG(x...)	printk(x)
+#else
+#define DBG_CFG(x...)
+#endif
+
+#ifdef DEBUG_LBA_PAT
+#define DBG_PAT(x...)	printk(x)
+#else
+#define DBG_PAT(x...)
+#endif
+
+
+/*
+** Config accessor functions only pass in the 8-bit bus number and not
+** the 8-bit "PCI Segment" number. Each LBA will be assigned a PCI bus
+** number based on what firmware wrote into the scratch register.
+**
+** The "secondary" bus number is set to this before calling
+** pci_register_ops(). If any PPB's are present, the scan will
+** discover them and update the "secondary" and "subordinate"
+** fields in the pci_bus structure.
+**
+** Changes in the configuration *may* result in a different
+** bus number for each LBA depending on what firmware does.
+*/
+
+#define MODULE_NAME "LBA"
+
+#define LBA_FUNC_ID	0x0000	/* function id */
+#define LBA_FCLASS	0x0008	/* function class, bist, header, rev... */
+#define LBA_CAPABLE	0x0030	/* capabilities register */
+
+#define LBA_PCI_CFG_ADDR	0x0040	/* poke CFG address here */
+#define LBA_PCI_CFG_DATA	0x0048	/* read or write data here */
+
+#define LBA_PMC_MTLT	0x0050	/* Firmware sets this - read only. */
+#define LBA_FW_SCRATCH	0x0058	/* Firmware writes the PCI bus number here. */
+#define LBA_ERROR_ADDR	0x0070	/* On error, address gets logged here */
+
+#define LBA_ARB_MASK	0x0080	/* bit 0 enable arbitration. PAT/PDC enables */
+#define LBA_ARB_PRI	0x0088	/* firmware sets this. */
+#define LBA_ARB_MODE	0x0090	/* firmware sets this. */
+#define LBA_ARB_MTLT	0x0098	/* firmware sets this. */
+
+#define LBA_MOD_ID	0x0100	/* Module ID. PDC_PAT_CELL reports 4 */
+
+#define LBA_STAT_CTL	0x0108	/* Status & Control */
+#define   LBA_BUS_RESET		0x01	/*  Deassert PCI Bus Reset Signal */
+#define   CLEAR_ERRLOG		0x10	/*  "Clear Error Log" cmd */
+#define   CLEAR_ERRLOG_ENABLE	0x20	/*  "Clear Error Log" Enable */
+#define   HF_ENABLE	0x40	/*    enable HF mode (default is -1 mode) */
+
+#define LBA_LMMIO_BASE	0x0200	/* < 4GB I/O address range */
+#define LBA_LMMIO_MASK	0x0208
+
+#define LBA_GMMIO_BASE	0x0210	/* > 4GB I/O address range */
+#define LBA_GMMIO_MASK	0x0218
+
+#define LBA_WLMMIO_BASE	0x0220	/* All < 4GB ranges under the same *SBA* */
+#define LBA_WLMMIO_MASK	0x0228
+
+#define LBA_WGMMIO_BASE	0x0230	/* All > 4GB ranges under the same *SBA* */
+#define LBA_WGMMIO_MASK	0x0238
+
+#define LBA_IOS_BASE	0x0240	/* I/O port space for this LBA */
+#define LBA_IOS_MASK	0x0248
+
+#define LBA_ELMMIO_BASE	0x0250	/* Extra LMMIO range */
+#define LBA_ELMMIO_MASK	0x0258
+
+#define LBA_EIOS_BASE	0x0260	/* Extra I/O port space */
+#define LBA_EIOS_MASK	0x0268
+
+#define LBA_GLOBAL_MASK	0x0270	/* Mercury only: Global Address Mask */
+#define LBA_DMA_CTL	0x0278	/* firmware sets this */
+
+#define LBA_IBASE	0x0300	/* SBA DMA support */
+#define LBA_IMASK	0x0308
+
+/* FIXME: ignore DMA Hint stuff until we can measure performance */
+#define LBA_HINT_CFG	0x0310
+#define LBA_HINT_BASE	0x0380	/* 14 registers at every 8 bytes. */
+
+#define LBA_BUS_MODE	0x0620
+
+/* ERROR regs are needed for config cycle kluges */
+#define LBA_ERROR_CONFIG 0x0680
+#define     LBA_SMART_MODE 0x20
+#define LBA_ERROR_STATUS 0x0688
+#define LBA_ROPE_CTL     0x06A0
+
+#define LBA_IOSAPIC_BASE	0x800 /* Offset of IRQ logic */
+
+/* non-postable I/O port space, densely packed */
+#define LBA_PORT_BASE	(PCI_F_EXTEND | 0xfee00000UL)
+static void __iomem *astro_iop_base;
+
+#define ELROY_HVERS	0x782
+#define MERCURY_HVERS	0x783
+#define QUICKSILVER_HVERS	0x784
+
+static inline int IS_ELROY(struct parisc_device *d)
+{
+	return (d->id.hversion == ELROY_HVERS);
+}
+
+static inline int IS_MERCURY(struct parisc_device *d)
+{
+	return (d->id.hversion == MERCURY_HVERS);
+}
+
+static inline int IS_QUICKSILVER(struct parisc_device *d)
+{
+	return (d->id.hversion == QUICKSILVER_HVERS);
+}
+
+
+/*
+** lba_device: Per instance Elroy data structure
+*/
+struct lba_device {
+	struct pci_hba_data hba;
+
+	spinlock_t	lba_lock;
+	void		*iosapic_obj;
+
+#ifdef CONFIG_64BIT
+	void __iomem *	iop_base;    /* PA_VIEW - for IO port accessor funcs */
+#endif
+
+	int		flags;       /* state/functionality enabled */
+	int		hw_rev;      /* HW revision of chip */
+};
+
+
+static u32 lba_t32;
+
+/* lba flags */
+#define LBA_FLAG_SKIP_PROBE	0x10
+
+#define LBA_SKIP_PROBE(d) ((d)->flags & LBA_FLAG_SKIP_PROBE)
+
+
+/* Looks nice and keeps the compiler happy */
+#define LBA_DEV(d) ((struct lba_device *) (d))
+
+
+/*
+** Only allow 8 subsidiary busses per LBA
+** Problem is the PCI bus numbering is globally shared.
+*/
+#define LBA_MAX_NUM_BUSES 8
+
+/************************************
+ * LBA register read and write support
+ *
+ * BE WARNED: register writes are posted.
+ *  (ie follow writes which must reach HW with a read)
+ */
+#define READ_U8(addr)  __raw_readb(addr)
+#define READ_U16(addr) __raw_readw(addr)
+#define READ_U32(addr) __raw_readl(addr)
+#define WRITE_U8(value, addr)  __raw_writeb(value, addr)
+#define WRITE_U16(value, addr) __raw_writew(value, addr)
+#define WRITE_U32(value, addr) __raw_writel(value, addr)
+
+#define READ_REG8(addr)  readb(addr)
+#define READ_REG16(addr) readw(addr)
+#define READ_REG32(addr) readl(addr)
+#define READ_REG64(addr) readq(addr)
+#define WRITE_REG8(value, addr)  writeb(value, addr)
+#define WRITE_REG16(value, addr) writew(value, addr)
+#define WRITE_REG32(value, addr) writel(value, addr)
+
+
+#define LBA_CFG_TOK(bus,dfn) ((u32) ((bus)<<16 | (dfn)<<8))
+#define LBA_CFG_BUS(tok)  ((u8) ((tok)>>16))
+#define LBA_CFG_DEV(tok)  ((u8) ((tok)>>11) & 0x1f)
+#define LBA_CFG_FUNC(tok) ((u8) ((tok)>>8 ) & 0x7)
+
+
+/*
+** Extract LBA (Rope) number from HPA
+** REVISIT: 16 ropes for Stretch/Ike?
+*/
+#define ROPES_PER_IOC	8
+#define LBA_NUM(x)    ((((unsigned long) x) >> 13) & (ROPES_PER_IOC-1))
+
+
+static void
+lba_dump_res(struct resource *r, int d)
+{
+	int i;
+
+	if (NULL == r)
+		return;
+
+	printk(KERN_DEBUG "(%p)", r->parent);
+	for (i = d; i ; --i) printk(" ");
+	printk(KERN_DEBUG "%p [%lx,%lx]/%lx\n", r, r->start, r->end, r->flags);
+	lba_dump_res(r->child, d+2);
+	lba_dump_res(r->sibling, d);
+}
+
+
+/*
+** LBA rev 2.0, 2.1, 2.2, and 3.0 bus walks require a complex
+** workaround for cfg cycles:
+**	-- preserve  LBA state
+**	-- prevent any DMA from occurring
+**	-- turn on smart mode
+**	-- probe with config writes before doing config reads
+**	-- check ERROR_STATUS
+**	-- clear ERROR_STATUS
+**	-- restore LBA state
+**
+** The workaround is only used for device discovery.
+*/
+
+static int lba_device_present(u8 bus, u8 dfn, struct lba_device *d)
+{
+	u8 first_bus = d->hba.hba_bus->secondary;
+	u8 last_sub_bus = d->hba.hba_bus->subordinate;
+
+	if ((bus < first_bus) ||
+	    (bus > last_sub_bus) ||
+	    ((bus - first_bus) >= LBA_MAX_NUM_BUSES)) {
+		return 0;
+	}
+
+	return 1;
+}
+
+
+
+#define LBA_CFG_SETUP(d, tok) {				\
+    /* Save contents of error config register.  */			\
+    error_config = READ_REG32(d->hba.base_addr + LBA_ERROR_CONFIG);		\
+\
+    /* Save contents of status control register.  */			\
+    status_control = READ_REG32(d->hba.base_addr + LBA_STAT_CTL);		\
+\
+    /* For LBA rev 2.0, 2.1, 2.2, and 3.0, we must disable DMA		\
+    ** arbitration for full bus walks.					\
+    */									\
+	/* Save contents of arb mask register. */			\
+	arb_mask = READ_REG32(d->hba.base_addr + LBA_ARB_MASK);		\
+\
+	/*								\
+	 * Turn off all device arbitration bits (i.e. everything	\
+	 * except arbitration enable bit).				\
+	 */								\
+	WRITE_REG32(0x1, d->hba.base_addr + LBA_ARB_MASK);		\
+\
+    /*									\
+     * Set the smart mode bit so that master aborts don't cause		\
+     * LBA to go into PCI fatal mode (required).			\
+     */									\
+    WRITE_REG32(error_config | LBA_SMART_MODE, d->hba.base_addr + LBA_ERROR_CONFIG);	\
+}
+
+
+#define LBA_CFG_PROBE(d, tok) {				\
+    /*									\
+     * Setup Vendor ID write and read back the address register		\
+     * to make sure that LBA is the bus master.				\
+     */									\
+    WRITE_REG32(tok | PCI_VENDOR_ID, (d)->hba.base_addr + LBA_PCI_CFG_ADDR);\
+    /*									\
+     * Read address register to ensure that LBA is the bus master,	\
+     * which implies that DMA traffic has stopped when DMA arb is off.	\
+     */									\
+    lba_t32 = READ_REG32((d)->hba.base_addr + LBA_PCI_CFG_ADDR);	\
+    /*									\
+     * Generate a cfg write cycle (will have no affect on		\
+     * Vendor ID register since read-only).				\
+     */									\
+    WRITE_REG32(~0, (d)->hba.base_addr + LBA_PCI_CFG_DATA);		\
+    /*									\
+     * Make sure write has completed before proceeding further,		\
+     * i.e. before setting clear enable.				\
+     */									\
+    lba_t32 = READ_REG32((d)->hba.base_addr + LBA_PCI_CFG_ADDR);	\
+}
+
+
+/*
+ * HPREVISIT:
+ *   -- Can't tell if config cycle got the error.
+ *
+ *		OV bit is broken until rev 4.0, so can't use OV bit and
+ *		LBA_ERROR_LOG_ADDR to tell if error belongs to config cycle.
+ *
+ *		As of rev 4.0, no longer need the error check.
+ *
+ *   -- Even if we could tell, we still want to return -1
+ *	for **ANY** error (not just master abort).
+ *
+ *   -- Only clear non-fatal errors (we don't want to bring
+ *	LBA out of pci-fatal mode).
+ *
+ *		Actually, there is still a race in which
+ *		we could be clearing a fatal error.  We will
+ *		live with this during our initial bus walk
+ *		until rev 4.0 (no driver activity during
+ *		initial bus walk).  The initial bus walk
+ *		has race conditions concerning the use of
+ *		smart mode as well.
+ */
+
+#define LBA_MASTER_ABORT_ERROR 0xc
+#define LBA_FATAL_ERROR 0x10
+
+#define LBA_CFG_MASTER_ABORT_CHECK(d, base, tok, error) {		\
+    u32 error_status = 0;						\
+    /*									\
+     * Set clear enable (CE) bit. Unset by HW when new			\
+     * errors are logged -- LBA HW ERS section 14.3.3).		\
+     */									\
+    WRITE_REG32(status_control | CLEAR_ERRLOG_ENABLE, base + LBA_STAT_CTL); \
+    error_status = READ_REG32(base + LBA_ERROR_STATUS);		\
+    if ((error_status & 0x1f) != 0) {					\
+	/*								\
+	 * Fail the config read request.				\
+	 */								\
+	error = 1;							\
+	if ((error_status & LBA_FATAL_ERROR) == 0) {			\
+	    /*								\
+	     * Clear error status (if fatal bit not set) by setting	\
+	     * clear error log bit (CL).				\
+	     */								\
+	    WRITE_REG32(status_control | CLEAR_ERRLOG, base + LBA_STAT_CTL); \
+	}								\
+    }									\
+}
+
+#define LBA_CFG_TR4_ADDR_SETUP(d, addr)					\
+	WRITE_REG32(((addr) & ~3), (d)->hba.base_addr + LBA_PCI_CFG_ADDR);
+
+#define LBA_CFG_ADDR_SETUP(d, addr) {					\
+    WRITE_REG32(((addr) & ~3), (d)->hba.base_addr + LBA_PCI_CFG_ADDR);	\
+    /*									\
+     * Read address register to ensure that LBA is the bus master,	\
+     * which implies that DMA traffic has stopped when DMA arb is off.	\
+     */									\
+    lba_t32 = READ_REG32((d)->hba.base_addr + LBA_PCI_CFG_ADDR);	\
+}
+
+
+#define LBA_CFG_RESTORE(d, base) {					\
+    /*									\
+     * Restore status control register (turn off clear enable).		\
+     */									\
+    WRITE_REG32(status_control, base + LBA_STAT_CTL);			\
+    /*									\
+     * Restore error config register (turn off smart mode).		\
+     */									\
+    WRITE_REG32(error_config, base + LBA_ERROR_CONFIG);			\
+	/*								\
+	 * Restore arb mask register (reenables DMA arbitration).	\
+	 */								\
+	WRITE_REG32(arb_mask, base + LBA_ARB_MASK);			\
+}
+
+
+
+static unsigned int
+lba_rd_cfg(struct lba_device *d, u32 tok, u8 reg, u32 size)
+{
+	u32 data = ~0U;
+	int error = 0;
+	u32 arb_mask = 0;	/* used by LBA_CFG_SETUP/RESTORE */
+	u32 error_config = 0;	/* used by LBA_CFG_SETUP/RESTORE */
+	u32 status_control = 0;	/* used by LBA_CFG_SETUP/RESTORE */
+
+	LBA_CFG_SETUP(d, tok);
+	LBA_CFG_PROBE(d, tok);
+	LBA_CFG_MASTER_ABORT_CHECK(d, d->hba.base_addr, tok, error);
+	if (!error) {
+		void __iomem *data_reg = d->hba.base_addr + LBA_PCI_CFG_DATA;
+
+		LBA_CFG_ADDR_SETUP(d, tok | reg);
+		switch (size) {
+		case 1: data = (u32) READ_REG8(data_reg + (reg & 3)); break;
+		case 2: data = (u32) READ_REG16(data_reg+ (reg & 2)); break;
+		case 4: data = READ_REG32(data_reg); break;
+		}
+	}
+	LBA_CFG_RESTORE(d, d->hba.base_addr);
+	return(data);
+}
+
+
+static int elroy_cfg_read(struct pci_bus *bus, unsigned int devfn, int pos, int size, u32 *data)
+{
+	struct lba_device *d = LBA_DEV(parisc_walk_tree(bus->bridge));
+	u32 local_bus = (bus->parent == NULL) ? 0 : bus->secondary;
+	u32 tok = LBA_CFG_TOK(local_bus, devfn);
+	void __iomem *data_reg = d->hba.base_addr + LBA_PCI_CFG_DATA;
+
+	if ((pos > 255) || (devfn > 255))
+		return -EINVAL;
+
+/* FIXME: B2K/C3600 workaround is always use old method... */
+	/* if (!LBA_SKIP_PROBE(d)) */ {
+		/* original - Generate config cycle on broken elroy
+		  with risk we will miss PCI bus errors. */
+		*data = lba_rd_cfg(d, tok, pos, size);
+		DBG_CFG("%s(%x+%2x) -> 0x%x (a)\n", __FUNCTION__, tok, pos, *data);
+		return 0;
+	}
+
+	if (LBA_SKIP_PROBE(d) && !lba_device_present(bus->secondary, devfn, d)) {
+		DBG_CFG("%s(%x+%2x) -> -1 (b)\n", __FUNCTION__, tok, pos);
+		/* either don't want to look or know device isn't present. */
+		*data = ~0U;
+		return(0);
+	}
+
+	/* Basic Algorithm
+	** Should only get here on fully working LBA rev.
+	** This is how simple the code should have been.
+	*/
+	LBA_CFG_ADDR_SETUP(d, tok | pos);
+	switch(size) {
+	case 1: *data = READ_REG8 (data_reg + (pos & 3)); break;
+	case 2: *data = READ_REG16(data_reg + (pos & 2)); break;
+	case 4: *data = READ_REG32(data_reg); break;
+	}
+	DBG_CFG("%s(%x+%2x) -> 0x%x (c)\n", __FUNCTION__, tok, pos, *data);
+	return 0;
+}
+
+
+static void
+lba_wr_cfg(struct lba_device *d, u32 tok, u8 reg, u32 data, u32 size)
+{
+	int error = 0;
+	u32 arb_mask = 0;
+	u32 error_config = 0;
+	u32 status_control = 0;
+	void __iomem *data_reg = d->hba.base_addr + LBA_PCI_CFG_DATA;
+
+	LBA_CFG_SETUP(d, tok);
+	LBA_CFG_ADDR_SETUP(d, tok | reg);
+	switch (size) {
+	case 1: WRITE_REG8 (data, data_reg + (reg & 3)); break;
+	case 2: WRITE_REG16(data, data_reg + (reg & 2)); break;
+	case 4: WRITE_REG32(data, data_reg);             break;
+	}
+	LBA_CFG_MASTER_ABORT_CHECK(d, d->hba.base_addr, tok, error);
+	LBA_CFG_RESTORE(d, d->hba.base_addr);
+}
+
+
+/*
+ * LBA 4.0 config write code implements non-postable semantics
+ * by doing a read of CONFIG ADDR after the write.
+ */
+
+static int elroy_cfg_write(struct pci_bus *bus, unsigned int devfn, int pos, int size, u32 data)
+{
+	struct lba_device *d = LBA_DEV(parisc_walk_tree(bus->bridge));
+	u32 local_bus = (bus->parent == NULL) ? 0 : bus->secondary;
+	u32 tok = LBA_CFG_TOK(local_bus,devfn);
+
+	if ((pos > 255) || (devfn > 255))
+		return -EINVAL;
+
+	if (!LBA_SKIP_PROBE(d)) {
+		/* Original Workaround */
+		lba_wr_cfg(d, tok, pos, (u32) data, size);
+		DBG_CFG("%s(%x+%2x) = 0x%x (a)\n", __FUNCTION__, tok, pos,data);
+		return 0;
+	}
+
+	if (LBA_SKIP_PROBE(d) && (!lba_device_present(bus->secondary, devfn, d))) {
+		DBG_CFG("%s(%x+%2x) = 0x%x (b)\n", __FUNCTION__, tok, pos,data);
+		return 1; /* New Workaround */
+	}
+
+	DBG_CFG("%s(%x+%2x) = 0x%x (c)\n", __FUNCTION__, tok, pos, data);
+
+	/* Basic Algorithm */
+	LBA_CFG_ADDR_SETUP(d, tok | pos);
+	switch(size) {
+	case 1: WRITE_REG8 (data, d->hba.base_addr + LBA_PCI_CFG_DATA + (pos & 3));
+		   break;
+	case 2: WRITE_REG16(data, d->hba.base_addr + LBA_PCI_CFG_DATA + (pos & 2));
+		   break;
+	case 4: WRITE_REG32(data, d->hba.base_addr + LBA_PCI_CFG_DATA);
+		   break;
+	}
+	/* flush posted write */
+	lba_t32 = READ_REG32(d->hba.base_addr + LBA_PCI_CFG_ADDR);
+	return 0;
+}
+
+
+static struct pci_ops elroy_cfg_ops = {
+	.read =		elroy_cfg_read,
+	.write =	elroy_cfg_write,
+};
+
+/*
+ * The mercury_cfg_ops are slightly misnamed; they're also used for Elroy
+ * TR4.0 as no additional bugs were found in this areea between Elroy and
+ * Mercury
+ */
+
+static int mercury_cfg_read(struct pci_bus *bus, unsigned int devfn, int pos, int size, u32 *data)
+{
+	struct lba_device *d = LBA_DEV(parisc_walk_tree(bus->bridge));
+	u32 local_bus = (bus->parent == NULL) ? 0 : bus->secondary;
+	u32 tok = LBA_CFG_TOK(local_bus, devfn);
+	void __iomem *data_reg = d->hba.base_addr + LBA_PCI_CFG_DATA;
+
+	if ((pos > 255) || (devfn > 255))
+		return -EINVAL;
+
+	LBA_CFG_TR4_ADDR_SETUP(d, tok | pos);
+	switch(size) {
+	case 1:
+		*data = READ_REG8(data_reg + (pos & 3));
+		break;
+	case 2:
+		*data = READ_REG16(data_reg + (pos & 2));
+		break;
+	case 4:
+		*data = READ_REG32(data_reg);             break;
+		break;
+	}
+
+	DBG_CFG("mercury_cfg_read(%x+%2x) -> 0x%x\n", tok, pos, *data);
+	return 0;
+}
+
+/*
+ * LBA 4.0 config write code implements non-postable semantics
+ * by doing a read of CONFIG ADDR after the write.
+ */
+
+static int mercury_cfg_write(struct pci_bus *bus, unsigned int devfn, int pos, int size, u32 data)
+{
+	struct lba_device *d = LBA_DEV(parisc_walk_tree(bus->bridge));
+	void __iomem *data_reg = d->hba.base_addr + LBA_PCI_CFG_DATA;
+	u32 local_bus = (bus->parent == NULL) ? 0 : bus->secondary;
+	u32 tok = LBA_CFG_TOK(local_bus,devfn);
+
+	if ((pos > 255) || (devfn > 255))
+		return -EINVAL;
+
+	DBG_CFG("%s(%x+%2x) <- 0x%x (c)\n", __FUNCTION__, tok, pos, data);
+
+	LBA_CFG_TR4_ADDR_SETUP(d, tok | pos);
+	switch(size) {
+	case 1:
+		WRITE_REG8 (data, data_reg + (pos & 3));
+		break;
+	case 2:
+		WRITE_REG16(data, data_reg + (pos & 2));
+		break;
+	case 4:
+		WRITE_REG32(data, data_reg);
+		break;
+	}
+
+	/* flush posted write */
+	lba_t32 = READ_U32(d->hba.base_addr + LBA_PCI_CFG_ADDR);
+	return 0;
+}
+
+static struct pci_ops mercury_cfg_ops = {
+	.read =		mercury_cfg_read,
+	.write =	mercury_cfg_write,
+};
+
+
+static void
+lba_bios_init(void)
+{
+	DBG(MODULE_NAME ": lba_bios_init\n");
+}
+
+
+#ifdef CONFIG_64BIT
+
+/*
+** Determine if a device is already configured.
+** If so, reserve it resources.
+**
+** Read PCI cfg command register and see if I/O or MMIO is enabled.
+** PAT has to enable the devices it's using.
+**
+** Note: resources are fixed up before we try to claim them.
+*/
+static void
+lba_claim_dev_resources(struct pci_dev *dev)
+{
+	u16 cmd;
+	int i, srch_flags;
+
+	(void) pci_read_config_word(dev, PCI_COMMAND, &cmd);
+
+	srch_flags  = (cmd & PCI_COMMAND_IO) ? IORESOURCE_IO : 0;
+	if (cmd & PCI_COMMAND_MEMORY)
+		srch_flags |= IORESOURCE_MEM;
+
+	if (!srch_flags)
+		return;
+
+	for (i = 0; i <= PCI_ROM_RESOURCE; i++) {
+		if (dev->resource[i].flags & srch_flags) {
+			pci_claim_resource(dev, i);
+			DBG("   claimed %s %d [%lx,%lx]/%lx\n",
+				pci_name(dev), i,
+				dev->resource[i].start,
+				dev->resource[i].end,
+				dev->resource[i].flags
+				);
+		}
+	}
+}
+#else
+#define lba_claim_dev_resources(dev)
+#endif
+
+
+/*
+** The algorithm is generic code.
+** But it needs to access local data structures to get the IRQ base.
+** Could make this a "pci_fixup_irq(bus, region)" but not sure
+** it's worth it.
+**
+** Called by do_pci_scan_bus() immediately after each PCI bus is walked.
+** Resources aren't allocated until recursive buswalk below HBA is completed.
+*/
+static void
+lba_fixup_bus(struct pci_bus *bus)
+{
+	struct list_head *ln;
+#ifdef FBB_SUPPORT
+	u16 status;
+#endif
+	struct lba_device *ldev = LBA_DEV(parisc_walk_tree(bus->bridge));
+	int lba_portbase = HBA_PORT_BASE(ldev->hba.hba_num);
+
+	DBG("lba_fixup_bus(0x%p) bus %d platform_data 0x%p\n",
+		bus, bus->secondary, bus->bridge->platform_data);
+
+	/*
+	** Properly Setup MMIO resources for this bus.
+	** pci_alloc_primary_bus() mangles this.
+	*/
+	if (bus->self) {
+		/* PCI-PCI Bridge */
+		pci_read_bridge_bases(bus);
+	} else {
+		/* Host-PCI Bridge */
+		int err, i;
+
+		DBG("lba_fixup_bus() %s [%lx/%lx]/%lx\n",
+			ldev->hba.io_space.name,
+			ldev->hba.io_space.start, ldev->hba.io_space.end,
+			ldev->hba.io_space.flags);
+		DBG("lba_fixup_bus() %s [%lx/%lx]/%lx\n",
+			ldev->hba.lmmio_space.name,
+			ldev->hba.lmmio_space.start, ldev->hba.lmmio_space.end,
+			ldev->hba.lmmio_space.flags);
+
+		err = request_resource(&ioport_resource, &(ldev->hba.io_space));
+		if (err < 0) {
+			lba_dump_res(&ioport_resource, 2);
+			BUG();
+		}
+
+		if (ldev->hba.elmmio_space.start) {
+			err = request_resource(&iomem_resource,
+					&(ldev->hba.elmmio_space));
+			if (err < 0) {
+
+				printk("FAILED: lba_fixup_bus() request for "
+						"elmmio_space [%lx/%lx]\n",
+						ldev->hba.elmmio_space.start,
+						ldev->hba.elmmio_space.end);
+
+				/* lba_dump_res(&iomem_resource, 2); */
+				/* BUG(); */
+			}
+		}
+
+		err = request_resource(&iomem_resource, &(ldev->hba.lmmio_space));
+		if (err < 0) {
+			/*   FIXME  overlaps with elmmio will fail here.
+			 *   Need to prune (or disable) the distributed range.
+			 *
+			 *   BEWARE: conflicts with this lmmio range may be
+			 *   elmmio range which is pointing down another rope.
+			 */
+
+			printk("FAILED: lba_fixup_bus() request for "
+					"lmmio_space [%lx/%lx]\n",
+					ldev->hba.lmmio_space.start,
+					ldev->hba.lmmio_space.end);
+			/* lba_dump_res(&iomem_resource, 2); */
+		}
+
+#ifdef CONFIG_64BIT
+		/* GMMIO is  distributed range. Every LBA/Rope gets part it. */
+		if (ldev->hba.gmmio_space.flags) {
+			err = request_resource(&iomem_resource, &(ldev->hba.gmmio_space));
+			if (err < 0) {
+				printk("FAILED: lba_fixup_bus() request for "
+					"gmmio_space [%lx/%lx]\n",
+					ldev->hba.gmmio_space.start,
+					ldev->hba.gmmio_space.end);
+				lba_dump_res(&iomem_resource, 2);
+				BUG();
+			}
+		}
+#endif
+
+		/* advertize Host bridge resources to PCI bus */
+		bus->resource[0] = &(ldev->hba.io_space);
+		bus->resource[1] = &(ldev->hba.lmmio_space);
+		i=2;
+		if (ldev->hba.elmmio_space.start)
+			bus->resource[i++] = &(ldev->hba.elmmio_space);
+		if (ldev->hba.gmmio_space.start)
+			bus->resource[i++] = &(ldev->hba.gmmio_space);
+			
+	}
+
+	list_for_each(ln, &bus->devices) {
+		int i;
+		struct pci_dev *dev = pci_dev_b(ln);
+
+		DBG("lba_fixup_bus() %s\n", pci_name(dev));
+
+		/* Virtualize Device/Bridge Resources. */
+		for (i = 0; i < PCI_BRIDGE_RESOURCES; i++) {
+			struct resource *res = &dev->resource[i];
+
+			/* If resource not allocated - skip it */
+			if (!res->start)
+				continue;
+
+			if (res->flags & IORESOURCE_IO) {
+				DBG("lba_fixup_bus() I/O Ports [%lx/%lx] -> ",
+					res->start, res->end);
+				res->start |= lba_portbase;
+				res->end   |= lba_portbase;
+				DBG("[%lx/%lx]\n", res->start, res->end);
+			} else if (res->flags & IORESOURCE_MEM) {
+				/*
+				** Convert PCI (IO_VIEW) addresses to
+				** processor (PA_VIEW) addresses
+				 */
+				DBG("lba_fixup_bus() MMIO [%lx/%lx] -> ",
+					res->start, res->end);
+				res->start = PCI_HOST_ADDR(HBA_DATA(ldev), res->start);
+				res->end   = PCI_HOST_ADDR(HBA_DATA(ldev), res->end);
+				DBG("[%lx/%lx]\n", res->start, res->end);
+			} else {
+				DBG("lba_fixup_bus() WTF? 0x%lx [%lx/%lx] XXX",
+					res->flags, res->start, res->end);
+			}
+		}
+
+#ifdef FBB_SUPPORT
+		/*
+		** If one device does not support FBB transfers,
+		** No one on the bus can be allowed to use them.
+		*/
+		(void) pci_read_config_word(dev, PCI_STATUS, &status);
+		bus->bridge_ctl &= ~(status & PCI_STATUS_FAST_BACK);
+#endif
+
+		if (is_pdc_pat()) {
+			/* Claim resources for PDC's devices */
+			lba_claim_dev_resources(dev);
+		}
+
+                /*
+		** P2PB's have no IRQs. ignore them.
+		*/
+		if ((dev->class >> 8) == PCI_CLASS_BRIDGE_PCI)
+			continue;
+
+		/* Adjust INTERRUPT_LINE for this dev */
+		iosapic_fixup_irq(ldev->iosapic_obj, dev);
+	}
+
+#ifdef FBB_SUPPORT
+/* FIXME/REVISIT - finish figuring out to set FBB on both
+** pci_setup_bridge() clobbers PCI_BRIDGE_CONTROL.
+** Can't fixup here anyway....garr...
+*/
+	if (fbb_enable) {
+		if (bus->self) {
+			u8 control;
+			/* enable on PPB */
+			(void) pci_read_config_byte(bus->self, PCI_BRIDGE_CONTROL, &control);
+			(void) pci_write_config_byte(bus->self, PCI_BRIDGE_CONTROL, control | PCI_STATUS_FAST_BACK);
+
+		} else {
+			/* enable on LBA */
+		}
+		fbb_enable = PCI_COMMAND_FAST_BACK;
+	}
+
+	/* Lastly enable FBB/PERR/SERR on all devices too */
+	list_for_each(ln, &bus->devices) {
+		(void) pci_read_config_word(dev, PCI_COMMAND, &status);
+		status |= PCI_COMMAND_PARITY | PCI_COMMAND_SERR | fbb_enable;
+		(void) pci_write_config_word(dev, PCI_COMMAND, status);
+	}
+#endif
+}
+
+
+struct pci_bios_ops lba_bios_ops = {
+	.init =		lba_bios_init,
+	.fixup_bus =	lba_fixup_bus,
+};
+
+
+
+
+/*******************************************************
+**
+** LBA Sprockets "I/O Port" Space Accessor Functions
+**
+** This set of accessor functions is intended for use with
+** "legacy firmware" (ie Sprockets on Allegro/Forte boxes).
+**
+** Many PCI devices don't require use of I/O port space (eg Tulip,
+** NCR720) since they export the same registers to both MMIO and
+** I/O port space. In general I/O port space is slower than
+** MMIO since drivers are designed so PIO writes can be posted.
+**
+********************************************************/
+
+#define LBA_PORT_IN(size, mask) \
+static u##size lba_astro_in##size (struct pci_hba_data *d, u16 addr) \
+{ \
+	u##size t; \
+	t = READ_REG##size(astro_iop_base + addr); \
+	DBG_PORT(" 0x%x\n", t); \
+	return (t); \
+}
+
+LBA_PORT_IN( 8, 3)
+LBA_PORT_IN(16, 2)
+LBA_PORT_IN(32, 0)
+
+
+
+/*
+** BUG X4107:  Ordering broken - DMA RD return can bypass PIO WR
+**
+** Fixed in Elroy 2.2. The READ_U32(..., LBA_FUNC_ID) below is
+** guarantee non-postable completion semantics - not avoid X4107.
+** The READ_U32 only guarantees the write data gets to elroy but
+** out to the PCI bus. We can't read stuff from I/O port space
+** since we don't know what has side-effects. Attempting to read
+** from configuration space would be suicidal given the number of
+** bugs in that elroy functionality.
+**
+**      Description:
+**          DMA read results can improperly pass PIO writes (X4107).  The
+**          result of this bug is that if a processor modifies a location in
+**          memory after having issued PIO writes, the PIO writes are not
+**          guaranteed to be completed before a PCI device is allowed to see
+**          the modified data in a DMA read.
+**
+**          Note that IKE bug X3719 in TR1 IKEs will result in the same
+**          symptom.
+**
+**      Workaround:
+**          The workaround for this bug is to always follow a PIO write with
+**          a PIO read to the same bus before starting DMA on that PCI bus.
+**
+*/
+#define LBA_PORT_OUT(size, mask) \
+static void lba_astro_out##size (struct pci_hba_data *d, u16 addr, u##size val) \
+{ \
+	DBG_PORT("%s(0x%p, 0x%x, 0x%x)\n", __FUNCTION__, d, addr, val); \
+	WRITE_REG##size(val, astro_iop_base + addr); \
+	if (LBA_DEV(d)->hw_rev < 3) \
+		lba_t32 = READ_U32(d->base_addr + LBA_FUNC_ID); \
+}
+
+LBA_PORT_OUT( 8, 3)
+LBA_PORT_OUT(16, 2)
+LBA_PORT_OUT(32, 0)
+
+
+static struct pci_port_ops lba_astro_port_ops = {
+	.inb =	lba_astro_in8,
+	.inw =	lba_astro_in16,
+	.inl =	lba_astro_in32,
+	.outb =	lba_astro_out8,
+	.outw =	lba_astro_out16,
+	.outl =	lba_astro_out32
+};
+
+
+#ifdef CONFIG_64BIT
+#define PIOP_TO_GMMIO(lba, addr) \
+	((lba)->iop_base + (((addr)&0xFFFC)<<10) + ((addr)&3))
+
+/*******************************************************
+**
+** LBA PAT "I/O Port" Space Accessor Functions
+**
+** This set of accessor functions is intended for use with
+** "PAT PDC" firmware (ie Prelude/Rhapsody/Piranha boxes).
+**
+** This uses the PIOP space located in the first 64MB of GMMIO.
+** Each rope gets a full 64*KB* (ie 4 bytes per page) this way.
+** bits 1:0 stay the same.  bits 15:2 become 25:12.
+** Then add the base and we can generate an I/O Port cycle.
+********************************************************/
+#undef LBA_PORT_IN
+#define LBA_PORT_IN(size, mask) \
+static u##size lba_pat_in##size (struct pci_hba_data *l, u16 addr) \
+{ \
+	u##size t; \
+	DBG_PORT("%s(0x%p, 0x%x) ->", __FUNCTION__, l, addr); \
+	t = READ_REG##size(PIOP_TO_GMMIO(LBA_DEV(l), addr)); \
+	DBG_PORT(" 0x%x\n", t); \
+	return (t); \
+}
+
+LBA_PORT_IN( 8, 3)
+LBA_PORT_IN(16, 2)
+LBA_PORT_IN(32, 0)
+
+
+#undef LBA_PORT_OUT
+#define LBA_PORT_OUT(size, mask) \
+static void lba_pat_out##size (struct pci_hba_data *l, u16 addr, u##size val) \
+{ \
+	void *where = (void *) PIOP_TO_GMMIO(LBA_DEV(l), addr); \
+	DBG_PORT("%s(0x%p, 0x%x, 0x%x)\n", __FUNCTION__, l, addr, val); \
+	WRITE_REG##size(val, where); \
+	/* flush the I/O down to the elroy at least */ \
+	lba_t32 = READ_U32(l->base_addr + LBA_FUNC_ID); \
+}
+
+LBA_PORT_OUT( 8, 3)
+LBA_PORT_OUT(16, 2)
+LBA_PORT_OUT(32, 0)
+
+
+static struct pci_port_ops lba_pat_port_ops = {
+	.inb =	lba_pat_in8,
+	.inw =	lba_pat_in16,
+	.inl =	lba_pat_in32,
+	.outb =	lba_pat_out8,
+	.outw =	lba_pat_out16,
+	.outl =	lba_pat_out32
+};
+
+
+
+/*
+** make range information from PDC available to PCI subsystem.
+** We make the PDC call here in order to get the PCI bus range
+** numbers. The rest will get forwarded in pcibios_fixup_bus().
+** We don't have a struct pci_bus assigned to us yet.
+*/
+static void
+lba_pat_resources(struct parisc_device *pa_dev, struct lba_device *lba_dev)
+{
+	unsigned long bytecnt;
+	pdc_pat_cell_mod_maddr_block_t pa_pdc_cell;	/* PA_VIEW */
+	pdc_pat_cell_mod_maddr_block_t io_pdc_cell;	/* IO_VIEW */
+	long io_count;
+	long status;	/* PDC return status */
+	long pa_count;
+	int i;
+
+	/* return cell module (IO view) */
+	status = pdc_pat_cell_module(&bytecnt, pa_dev->pcell_loc, pa_dev->mod_index,
+				PA_VIEW, & pa_pdc_cell);
+	pa_count = pa_pdc_cell.mod[1];
+
+	status |= pdc_pat_cell_module(&bytecnt, pa_dev->pcell_loc, pa_dev->mod_index,
+				IO_VIEW, &io_pdc_cell);
+	io_count = io_pdc_cell.mod[1];
+
+	/* We've already done this once for device discovery...*/
+	if (status != PDC_OK) {
+		panic("pdc_pat_cell_module() call failed for LBA!\n");
+	}
+
+	if (PAT_GET_ENTITY(pa_pdc_cell.mod_info) != PAT_ENTITY_LBA) {
+		panic("pdc_pat_cell_module() entity returned != PAT_ENTITY_LBA!\n");
+	}
+
+	/*
+	** Inspect the resources PAT tells us about
+	*/
+	for (i = 0; i < pa_count; i++) {
+		struct {
+			unsigned long type;
+			unsigned long start;
+			unsigned long end;	/* aka finish */
+		} *p, *io;
+		struct resource *r;
+
+		p = (void *) &(pa_pdc_cell.mod[2+i*3]);
+		io = (void *) &(io_pdc_cell.mod[2+i*3]);
+
+		/* Convert the PAT range data to PCI "struct resource" */
+		switch(p->type & 0xff) {
+		case PAT_PBNUM:
+			lba_dev->hba.bus_num.start = p->start;
+			lba_dev->hba.bus_num.end   = p->end;
+			break;
+
+		case PAT_LMMIO:
+			/* used to fix up pre-initialized MEM BARs */
+			if (!lba_dev->hba.lmmio_space.start) {
+				sprintf(lba_dev->hba.lmmio_name,
+						"PCI%02lx LMMIO",
+						lba_dev->hba.bus_num.start);
+				lba_dev->hba.lmmio_space_offset = p->start -
+					io->start;
+				r = &lba_dev->hba.lmmio_space;
+				r->name = lba_dev->hba.lmmio_name;
+			} else if (!lba_dev->hba.elmmio_space.start) {
+				sprintf(lba_dev->hba.elmmio_name,
+						"PCI%02lx ELMMIO",
+						lba_dev->hba.bus_num.start);
+				r = &lba_dev->hba.elmmio_space;
+				r->name = lba_dev->hba.elmmio_name;
+			} else {
+				printk(KERN_WARNING MODULE_NAME
+					" only supports 2 LMMIO resources!\n");
+				break;
+			}
+
+			r->start  = p->start;
+			r->end    = p->end;
+			r->flags  = IORESOURCE_MEM;
+			r->parent = r->sibling = r->child = NULL;
+			break;
+
+		case PAT_GMMIO:
+			/* MMIO space > 4GB phys addr; for 64-bit BAR */
+			sprintf(lba_dev->hba.gmmio_name, "PCI%02lx GMMIO",
+					lba_dev->hba.bus_num.start);
+			r = &lba_dev->hba.gmmio_space;
+			r->name  = lba_dev->hba.gmmio_name;
+			r->start  = p->start;
+			r->end    = p->end;
+			r->flags  = IORESOURCE_MEM;
+			r->parent = r->sibling = r->child = NULL;
+			break;
+
+		case PAT_NPIOP:
+			printk(KERN_WARNING MODULE_NAME
+				" range[%d] : ignoring NPIOP (0x%lx)\n",
+				i, p->start);
+			break;
+
+		case PAT_PIOP:
+			/*
+			** Postable I/O port space is per PCI host adapter.
+			** base of 64MB PIOP region
+			*/
+			lba_dev->iop_base = ioremap(p->start, 64 * 1024 * 1024);
+
+			sprintf(lba_dev->hba.io_name, "PCI%02lx Ports",
+					lba_dev->hba.bus_num.start);
+			r = &lba_dev->hba.io_space;
+			r->name  = lba_dev->hba.io_name;
+			r->start  = HBA_PORT_BASE(lba_dev->hba.hba_num);
+			r->end    = r->start + HBA_PORT_SPACE_SIZE - 1;
+			r->flags  = IORESOURCE_IO;
+			r->parent = r->sibling = r->child = NULL;
+			break;
+
+		default:
+			printk(KERN_WARNING MODULE_NAME
+				" range[%d] : unknown pat range type (0x%lx)\n",
+				i, p->type & 0xff);
+			break;
+		}
+	}
+}
+#else
+/* keep compiler from complaining about missing declarations */
+#define lba_pat_port_ops lba_astro_port_ops
+#define lba_pat_resources(pa_dev, lba_dev)
+#endif	/* CONFIG_64BIT */
+
+
+extern void sba_distributed_lmmio(struct parisc_device *, struct resource *);
+extern void sba_directed_lmmio(struct parisc_device *, struct resource *);
+
+
+static void
+lba_legacy_resources(struct parisc_device *pa_dev, struct lba_device *lba_dev)
+{
+	struct resource *r;
+	int lba_num;
+
+	lba_dev->hba.lmmio_space_offset = PCI_F_EXTEND;
+
+	/*
+	** With "legacy" firmware, the lowest byte of FW_SCRATCH
+	** represents bus->secondary and the second byte represents
+	** bus->subsidiary (i.e. highest PPB programmed by firmware).
+	** PCI bus walk *should* end up with the same result.
+	** FIXME: But we don't have sanity checks in PCI or LBA.
+	*/
+	lba_num = READ_REG32(lba_dev->hba.base_addr + LBA_FW_SCRATCH);
+	r = &(lba_dev->hba.bus_num);
+	r->name = "LBA PCI Busses";
+	r->start = lba_num & 0xff;
+	r->end = (lba_num>>8) & 0xff;
+
+	/* Set up local PCI Bus resources - we don't need them for
+	** Legacy boxes but it's nice to see in /proc/iomem.
+	*/
+	r = &(lba_dev->hba.lmmio_space);
+	sprintf(lba_dev->hba.lmmio_name, "PCI%02lx LMMIO",
+					lba_dev->hba.bus_num.start);
+	r->name  = lba_dev->hba.lmmio_name;
+
+#if 1
+	/* We want the CPU -> IO routing of addresses.
+	 * The SBA BASE/MASK registers control CPU -> IO routing.
+	 * Ask SBA what is routed to this rope/LBA.
+	 */
+	sba_distributed_lmmio(pa_dev, r);
+#else
+	/*
+	 * The LBA BASE/MASK registers control IO -> System routing.
+	 *
+	 * The following code works but doesn't get us what we want.
+	 * Well, only because firmware (v5.0) on C3000 doesn't program
+	 * the LBA BASE/MASE registers to be the exact inverse of 
+	 * the corresponding SBA registers. Other Astro/Pluto
+	 * based platform firmware may do it right.
+	 *
+	 * Should someone want to mess with MSI, they may need to
+	 * reprogram LBA BASE/MASK registers. Thus preserve the code
+	 * below until MSI is known to work on C3000/A500/N4000/RP3440.
+	 *
+	 * Using the code below, /proc/iomem shows:
+	 * ...
+	 * f0000000-f0ffffff : PCI00 LMMIO
+	 *   f05d0000-f05d0000 : lcd_data
+	 *   f05d0008-f05d0008 : lcd_cmd
+	 * f1000000-f1ffffff : PCI01 LMMIO
+	 * f4000000-f4ffffff : PCI02 LMMIO
+	 *   f4000000-f4001fff : sym53c8xx
+	 *   f4002000-f4003fff : sym53c8xx
+	 *   f4004000-f40043ff : sym53c8xx
+	 *   f4005000-f40053ff : sym53c8xx
+	 *   f4007000-f4007fff : ohci_hcd
+	 *   f4008000-f40083ff : tulip
+	 * f6000000-f6ffffff : PCI03 LMMIO
+	 * f8000000-fbffffff : PCI00 ELMMIO
+	 *   fa100000-fa4fffff : stifb mmio
+	 *   fb000000-fb1fffff : stifb fb
+	 *
+	 * But everything listed under PCI02 actually lives under PCI00.
+	 * This is clearly wrong.
+	 *
+	 * Asking SBA how things are routed tells the correct story:
+	 * LMMIO_BASE/MASK/ROUTE f4000001 fc000000 00000000
+	 * DIR0_BASE/MASK/ROUTE fa000001 fe000000 00000006
+	 * DIR1_BASE/MASK/ROUTE f9000001 ff000000 00000004
+	 * DIR2_BASE/MASK/ROUTE f0000000 fc000000 00000000
+	 * DIR3_BASE/MASK/ROUTE f0000000 fc000000 00000000
+	 *
+	 * Which looks like this in /proc/iomem:
+	 * f4000000-f47fffff : PCI00 LMMIO
+	 *   f4000000-f4001fff : sym53c8xx
+	 *   ...[deteled core devices - same as above]...
+	 *   f4008000-f40083ff : tulip
+	 * f4800000-f4ffffff : PCI01 LMMIO
+	 * f6000000-f67fffff : PCI02 LMMIO
+	 * f7000000-f77fffff : PCI03 LMMIO
+	 * f9000000-f9ffffff : PCI02 ELMMIO
+	 * fa000000-fbffffff : PCI03 ELMMIO
+	 *   fa100000-fa4fffff : stifb mmio
+	 *   fb000000-fb1fffff : stifb fb
+	 *
+	 * ie all Built-in core are under now correctly under PCI00.
+	 * The "PCI02 ELMMIO" directed range is for:
+	 *  +-[02]---03.0  3Dfx Interactive, Inc. Voodoo 2
+	 *
+	 * All is well now.
+	 */
+	r->start = READ_REG32(lba_dev->hba.base_addr + LBA_LMMIO_BASE);
+	if (r->start & 1) {
+		unsigned long rsize;
+
+		r->flags = IORESOURCE_MEM;
+		/* mmio_mask also clears Enable bit */
+		r->start &= mmio_mask;
+		r->start = PCI_HOST_ADDR(HBA_DATA(lba_dev), r->start);
+		rsize = ~ READ_REG32(lba_dev->hba.base_addr + LBA_LMMIO_MASK);
+
+		/*
+		** Each rope only gets part of the distributed range.
+		** Adjust "window" for this rope.
+		*/
+		rsize /= ROPES_PER_IOC;
+		r->start += (rsize + 1) * LBA_NUM(pa_dev->hpa);
+		r->end = r->start + rsize;
+	} else {
+		r->end = r->start = 0;	/* Not enabled. */
+	}
+#endif
+
+	/*
+	** "Directed" ranges are used when the "distributed range" isn't
+	** sufficient for all devices below a given LBA.  Typically devices
+	** like graphics cards or X25 may need a directed range when the
+	** bus has multiple slots (ie multiple devices) or the device
+	** needs more than the typical 4 or 8MB a distributed range offers.
+	**
+	** The main reason for ignoring it now frigging complications.
+	** Directed ranges may overlap (and have precedence) over
+	** distributed ranges. Or a distributed range assigned to a unused
+	** rope may be used by a directed range on a different rope.
+	** Support for graphics devices may require fixing this
+	** since they may be assigned a directed range which overlaps
+	** an existing (but unused portion of) distributed range.
+	*/
+	r = &(lba_dev->hba.elmmio_space);
+	sprintf(lba_dev->hba.elmmio_name, "PCI%02lx ELMMIO",
+					lba_dev->hba.bus_num.start);
+	r->name  = lba_dev->hba.elmmio_name;
+
+#if 1
+	/* See comment which precedes call to sba_directed_lmmio() */
+	sba_directed_lmmio(pa_dev, r);
+#else
+	r->start = READ_REG32(lba_dev->hba.base_addr + LBA_ELMMIO_BASE);
+
+	if (r->start & 1) {
+		unsigned long rsize;
+		r->flags = IORESOURCE_MEM;
+		/* mmio_mask also clears Enable bit */
+		r->start &= mmio_mask;
+		r->start = PCI_HOST_ADDR(HBA_DATA(lba_dev), r->start);
+		rsize = READ_REG32(lba_dev->hba.base_addr + LBA_ELMMIO_MASK);
+		r->end = r->start + ~rsize;
+	}
+#endif
+
+	r = &(lba_dev->hba.io_space);
+	sprintf(lba_dev->hba.io_name, "PCI%02lx Ports",
+					lba_dev->hba.bus_num.start);
+	r->name  = lba_dev->hba.io_name;
+	r->flags = IORESOURCE_IO;
+	r->start = READ_REG32(lba_dev->hba.base_addr + LBA_IOS_BASE) & ~1L;
+	r->end   = r->start + (READ_REG32(lba_dev->hba.base_addr + LBA_IOS_MASK) ^ (HBA_PORT_SPACE_SIZE - 1));
+
+	/* Virtualize the I/O Port space ranges */
+	lba_num = HBA_PORT_BASE(lba_dev->hba.hba_num);
+	r->start |= lba_num;
+	r->end   |= lba_num;
+}
+
+
+/**************************************************************************
+**
+**   LBA initialization code (HW and SW)
+**
+**   o identify LBA chip itself
+**   o initialize LBA chip modes (HardFail)
+**   o FIXME: initialize DMA hints for reasonable defaults
+**   o enable configuration functions
+**   o call pci_register_ops() to discover devs (fixup/fixup_bus get invoked)
+**
+**************************************************************************/
+
+static int __init
+lba_hw_init(struct lba_device *d)
+{
+	u32 stat;
+	u32 bus_reset;	/* PDC_PAT_BUG */
+
+#if 0
+	printk(KERN_DEBUG "LBA %lx  STAT_CTL %Lx  ERROR_CFG %Lx  STATUS %Lx DMA_CTL %Lx\n",
+		d->hba.base_addr,
+		READ_REG64(d->hba.base_addr + LBA_STAT_CTL),
+		READ_REG64(d->hba.base_addr + LBA_ERROR_CONFIG),
+		READ_REG64(d->hba.base_addr + LBA_ERROR_STATUS),
+		READ_REG64(d->hba.base_addr + LBA_DMA_CTL) );
+	printk(KERN_DEBUG "	ARB mask %Lx  pri %Lx  mode %Lx  mtlt %Lx\n",
+		READ_REG64(d->hba.base_addr + LBA_ARB_MASK),
+		READ_REG64(d->hba.base_addr + LBA_ARB_PRI),
+		READ_REG64(d->hba.base_addr + LBA_ARB_MODE),
+		READ_REG64(d->hba.base_addr + LBA_ARB_MTLT) );
+	printk(KERN_DEBUG "	HINT cfg 0x%Lx\n",
+		READ_REG64(d->hba.base_addr + LBA_HINT_CFG));
+	printk(KERN_DEBUG "	HINT reg ");
+	{ int i;
+	for (i=LBA_HINT_BASE; i< (14*8 + LBA_HINT_BASE); i+=8)
+		printk(" %Lx", READ_REG64(d->hba.base_addr + i));
+	}
+	printk("\n");
+#endif	/* DEBUG_LBA_PAT */
+
+#ifdef CONFIG_64BIT
+/*
+ * FIXME add support for PDC_PAT_IO "Get slot status" - OLAR support
+ * Only N-Class and up can really make use of Get slot status.
+ * maybe L-class too but I've never played with it there.
+ */
+#endif
+
+	/* PDC_PAT_BUG: exhibited in rev 40.48  on L2000 */
+	bus_reset = READ_REG32(d->hba.base_addr + LBA_STAT_CTL + 4) & 1;
+	if (bus_reset) {
+		printk(KERN_DEBUG "NOTICE: PCI bus reset still asserted! (clearing)\n");
+	}
+
+	stat = READ_REG32(d->hba.base_addr + LBA_ERROR_CONFIG);
+	if (stat & LBA_SMART_MODE) {
+		printk(KERN_DEBUG "NOTICE: LBA in SMART mode! (cleared)\n");
+		stat &= ~LBA_SMART_MODE;
+		WRITE_REG32(stat, d->hba.base_addr + LBA_ERROR_CONFIG);
+	}
+
+	/* Set HF mode as the default (vs. -1 mode). */
+        stat = READ_REG32(d->hba.base_addr + LBA_STAT_CTL);
+	WRITE_REG32(stat | HF_ENABLE, d->hba.base_addr + LBA_STAT_CTL);
+
+	/*
+	** Writing a zero to STAT_CTL.rf (bit 0) will clear reset signal
+	** if it's not already set. If we just cleared the PCI Bus Reset
+	** signal, wait a bit for the PCI devices to recover and setup.
+	*/
+	if (bus_reset)
+		mdelay(pci_post_reset_delay);
+
+	if (0 == READ_REG32(d->hba.base_addr + LBA_ARB_MASK)) {
+		/*
+		** PDC_PAT_BUG: PDC rev 40.48 on L2000.
+		** B2000/C3600/J6000 also have this problem?
+		** 
+		** Elroys with hot pluggable slots don't get configured
+		** correctly if the slot is empty.  ARB_MASK is set to 0
+		** and we can't master transactions on the bus if it's
+		** not at least one. 0x3 enables elroy and first slot.
+		*/
+		printk(KERN_DEBUG "NOTICE: Enabling PCI Arbitration\n");
+		WRITE_REG32(0x3, d->hba.base_addr + LBA_ARB_MASK);
+	}
+
+	/*
+	** FIXME: Hint registers are programmed with default hint
+	** values by firmware. Hints should be sane even if we
+	** can't reprogram them the way drivers want.
+	*/
+	return 0;
+}
+
+
+
+/*
+** Determine if lba should claim this chip (return 0) or not (return 1).
+** If so, initialize the chip and tell other partners in crime they
+** have work to do.
+*/
+static int __init
+lba_driver_probe(struct parisc_device *dev)
+{
+	struct lba_device *lba_dev;
+	struct pci_bus *lba_bus;
+	struct pci_ops *cfg_ops;
+	u32 func_class;
+	void *tmp_obj;
+	char *version;
+	void __iomem *addr = ioremap(dev->hpa, 4096);
+
+	/* Read HW Rev First */
+	func_class = READ_REG32(addr + LBA_FCLASS);
+
+	if (IS_ELROY(dev)) {	
+		func_class &= 0xf;
+		switch (func_class) {
+		case 0:	version = "TR1.0"; break;
+		case 1:	version = "TR2.0"; break;
+		case 2:	version = "TR2.1"; break;
+		case 3:	version = "TR2.2"; break;
+		case 4:	version = "TR3.0"; break;
+		case 5:	version = "TR4.0"; break;
+		default: version = "TR4+";
+		}
+
+		printk(KERN_INFO "%s version %s (0x%x) found at 0x%lx\n",
+			MODULE_NAME, version, func_class & 0xf, dev->hpa);
+
+		if (func_class < 2) {
+			printk(KERN_WARNING "Can't support LBA older than "
+				"TR2.1 - continuing under adversity.\n");
+		}
+
+#if 0
+/* Elroy TR4.0 should work with simple algorithm.
+   But it doesn't.  Still missing something. *sigh*
+*/
+		if (func_class > 4) {
+			cfg_ops = &mercury_cfg_ops;
+		} else
+#endif
+		{
+			cfg_ops = &elroy_cfg_ops;
+		}
+
+	} else if (IS_MERCURY(dev) || IS_QUICKSILVER(dev)) {
+		func_class &= 0xff;
+		version = kmalloc(6, GFP_KERNEL);
+		sprintf(version,"TR%d.%d",(func_class >> 4),(func_class & 0xf));
+		/* We could use one printk for both Elroy and Mercury,
+                 * but for the mask for func_class.
+                 */ 
+		printk(KERN_INFO "%s version %s (0x%x) found at 0x%lx\n",
+			MODULE_NAME, version, func_class & 0xff, dev->hpa);
+		cfg_ops = &mercury_cfg_ops;
+	} else {
+		printk(KERN_ERR "Unknown LBA found at 0x%lx\n", dev->hpa);
+		return -ENODEV;
+	}
+
+	/*
+	** Tell I/O SAPIC driver we have a IRQ handler/region.
+	*/
+	tmp_obj = iosapic_register(dev->hpa + LBA_IOSAPIC_BASE);
+
+	/* NOTE: PCI devices (e.g. 103c:1005 graphics card) which don't
+	**	have an IRT entry will get NULL back from iosapic code.
+	*/
+	
+	lba_dev = kmalloc(sizeof(struct lba_device), GFP_KERNEL);
+	if (!lba_dev) {
+		printk(KERN_ERR "lba_init_chip - couldn't alloc lba_device\n");
+		return(1);
+	}
+
+	memset(lba_dev, 0, sizeof(struct lba_device));
+
+
+	/* ---------- First : initialize data we already have --------- */
+
+	lba_dev->hw_rev = func_class;
+	lba_dev->hba.base_addr = addr;
+	lba_dev->hba.dev = dev;
+	lba_dev->iosapic_obj = tmp_obj;  /* save interrupt handle */
+	lba_dev->hba.iommu = sba_get_iommu(dev);  /* get iommu data */
+
+	/* ------------ Second : initialize common stuff ---------- */
+	pci_bios = &lba_bios_ops;
+	pcibios_register_hba(HBA_DATA(lba_dev));
+	spin_lock_init(&lba_dev->lba_lock);
+
+	if (lba_hw_init(lba_dev))
+		return(1);
+
+	/* ---------- Third : setup I/O Port and MMIO resources  --------- */
+
+	if (is_pdc_pat()) {
+		/* PDC PAT firmware uses PIOP region of GMMIO space. */
+		pci_port = &lba_pat_port_ops;
+		/* Go ask PDC PAT what resources this LBA has */
+		lba_pat_resources(dev, lba_dev);
+	} else {
+		if (!astro_iop_base) {
+			/* Sprockets PDC uses NPIOP region */
+			astro_iop_base = ioremap(LBA_PORT_BASE, 64 * 1024);
+			pci_port = &lba_astro_port_ops;
+		}
+
+		/* Poke the chip a bit for /proc output */
+		lba_legacy_resources(dev, lba_dev);
+	}
+
+	/* 
+	** Tell PCI support another PCI bus was found.
+	** Walks PCI bus for us too.
+	*/
+	dev->dev.platform_data = lba_dev;
+	lba_bus = lba_dev->hba.hba_bus =
+		pci_scan_bus_parented(&dev->dev, lba_dev->hba.bus_num.start,
+				cfg_ops, NULL);
+
+	/* This is in lieu of calling pci_assign_unassigned_resources() */
+	if (is_pdc_pat()) {
+		/* assign resources to un-initialized devices */
+
+		DBG_PAT("LBA pci_bus_size_bridges()\n");
+		pci_bus_size_bridges(lba_bus);
+
+		DBG_PAT("LBA pci_bus_assign_resources()\n");
+		pci_bus_assign_resources(lba_bus);
+
+#ifdef DEBUG_LBA_PAT
+		DBG_PAT("\nLBA PIOP resource tree\n");
+		lba_dump_res(&lba_dev->hba.io_space, 2);
+		DBG_PAT("\nLBA LMMIO resource tree\n");
+		lba_dump_res(&lba_dev->hba.lmmio_space, 2);
+#endif
+	}
+	pci_enable_bridges(lba_bus);
+
+
+	/*
+	** Once PCI register ops has walked the bus, access to config
+	** space is restricted. Avoids master aborts on config cycles.
+	** Early LBA revs go fatal on *any* master abort.
+	*/
+	if (cfg_ops == &elroy_cfg_ops) {
+		lba_dev->flags |= LBA_FLAG_SKIP_PROBE;
+	}
+
+	/* Whew! Finally done! Tell services we got this one covered. */
+	return 0;
+}
+
+static struct parisc_device_id lba_tbl[] = {
+	{ HPHW_BRIDGE, HVERSION_REV_ANY_ID, ELROY_HVERS, 0xa },
+	{ HPHW_BRIDGE, HVERSION_REV_ANY_ID, MERCURY_HVERS, 0xa },
+	{ HPHW_BRIDGE, HVERSION_REV_ANY_ID, QUICKSILVER_HVERS, 0xa },
+	{ 0, }
+};
+
+static struct parisc_driver lba_driver = {
+	.name =		MODULE_NAME,
+	.id_table =	lba_tbl,
+	.probe =	lba_driver_probe,
+};
+
+/*
+** One time initialization to let the world know the LBA was found.
+** Must be called exactly once before pci_init().
+*/
+void __init lba_init(void)
+{
+	register_parisc_driver(&lba_driver);
+}
+
+/*
+** Initialize the IBASE/IMASK registers for LBA (Elroy).
+** Only called from sba_iommu.c in order to route ranges (MMIO vs DMA).
+** sba_iommu is responsible for locking (none needed at init time).
+*/
+void lba_set_iregs(struct parisc_device *lba, u32 ibase, u32 imask)
+{
+	void __iomem * base_addr = ioremap(lba->hpa, 4096);
+
+	imask <<= 2;	/* adjust for hints - 2 more bits */
+
+	/* Make sure we aren't trying to set bits that aren't writeable. */
+	WARN_ON((ibase & 0x001fffff) != 0);
+	WARN_ON((imask & 0x001fffff) != 0);
+	
+	DBG("%s() ibase 0x%x imask 0x%x\n", __FUNCTION__, ibase, imask);
+	WRITE_REG32( imask, base_addr + LBA_IMASK);
+	WRITE_REG32( ibase, base_addr + LBA_IBASE);
+	iounmap(base_addr);
+}
+
