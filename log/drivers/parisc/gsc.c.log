commit 2874c5fd284268364ece81a7bd936f3c8168e567
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:01 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 152
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 3029 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070032.746973796@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/parisc/gsc.c b/drivers/parisc/gsc.c
index 1bab5a2cd359..ed9371acf37e 100644
--- a/drivers/parisc/gsc.c
+++ b/drivers/parisc/gsc.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * Interrupt management for most GSC and related devices.
  *
@@ -6,11 +7,6 @@
  * (c) Copyright 1999 Matthew Wilcox
  * (c) Copyright 2000 Helge Deller
  * (c) Copyright 2001 Matthew Wilcox for Hewlett-Packard
- *
- *	This program is free software; you can redistribute it and/or modify
- *	it under the terms of the GNU General Public License as published by
- *      the Free Software Foundation; either version 2 of the License, or
- *      (at your option) any later version.
  */
 
 #include <linux/bitops.h>

commit e2f571d294cc5f944539088bed46abae375b75f6
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Mar 24 17:41:44 2011 +0100

    parisc: Convert irq namespace
    
    Convert to the new function names. Scripted with coccinelle.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Kyle McMartin <kyle@mcmartin.ca>
    Cc: linux-parisc@vger.kernel.org

diff --git a/drivers/parisc/gsc.c b/drivers/parisc/gsc.c
index ef31080cf591..1bab5a2cd359 100644
--- a/drivers/parisc/gsc.c
+++ b/drivers/parisc/gsc.c
@@ -152,8 +152,8 @@ int gsc_assign_irq(struct irq_chip *type, void *data)
 	if (irq > GSC_IRQ_MAX)
 		return NO_IRQ;
 
-	set_irq_chip_and_handler(irq, type, handle_simple_irq);
-	set_irq_chip_data(irq, data);
+	irq_set_chip_and_handler(irq, type, handle_simple_irq);
+	irq_set_chip_data(irq, data);
 
 	return irq++;
 }

commit 4c4231ea2f794d73bbb50b8d84e00c66a012a607
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sun Feb 6 20:45:52 2011 +0000

    [PARISC] Convert to new irq_chip functions
    
    Convert all the parisc driver interrupt handlers (dino, eisa, gsc,
    iosapic and superio) as well as the cpu interrupts.  Prepare
    show_interrupts for GENERIC_HARDIRQS_NO_DEPRECATED and finally selects
    that Kconfig option
    
    [jejb: compile and testing fixes]
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/drivers/parisc/gsc.c b/drivers/parisc/gsc.c
index 772b1939ac21..ef31080cf591 100644
--- a/drivers/parisc/gsc.c
+++ b/drivers/parisc/gsc.c
@@ -105,13 +105,13 @@ int gsc_find_local_irq(unsigned int irq, int *global_irqs, int limit)
 	return NO_IRQ;
 }
 
-static void gsc_asic_mask_irq(unsigned int irq)
+static void gsc_asic_mask_irq(struct irq_data *d)
 {
-	struct gsc_asic *irq_dev = get_irq_chip_data(irq);
-	int local_irq = gsc_find_local_irq(irq, irq_dev->global_irq, 32);
+	struct gsc_asic *irq_dev = irq_data_get_irq_chip_data(d);
+	int local_irq = gsc_find_local_irq(d->irq, irq_dev->global_irq, 32);
 	u32 imr;
 
-	DEBPRINTK(KERN_DEBUG "%s(%d) %s: IMR 0x%x\n", __func__, irq,
+	DEBPRINTK(KERN_DEBUG "%s(%d) %s: IMR 0x%x\n", __func__, d->irq,
 			irq_dev->name, imr);
 
 	/* Disable the IRQ line by clearing the bit in the IMR */
@@ -120,13 +120,13 @@ static void gsc_asic_mask_irq(unsigned int irq)
 	gsc_writel(imr, irq_dev->hpa + OFFSET_IMR);
 }
 
-static void gsc_asic_unmask_irq(unsigned int irq)
+static void gsc_asic_unmask_irq(struct irq_data *d)
 {
-	struct gsc_asic *irq_dev = get_irq_chip_data(irq);
-	int local_irq = gsc_find_local_irq(irq, irq_dev->global_irq, 32);
+	struct gsc_asic *irq_dev = irq_data_get_irq_chip_data(d);
+	int local_irq = gsc_find_local_irq(d->irq, irq_dev->global_irq, 32);
 	u32 imr;
 
-	DEBPRINTK(KERN_DEBUG "%s(%d) %s: IMR 0x%x\n", __func__, irq,
+	DEBPRINTK(KERN_DEBUG "%s(%d) %s: IMR 0x%x\n", __func__, d->irq,
 			irq_dev->name, imr);
 
 	/* Enable the IRQ line by setting the bit in the IMR */
@@ -140,9 +140,9 @@ static void gsc_asic_unmask_irq(unsigned int irq)
 }
 
 static struct irq_chip gsc_asic_interrupt_type = {
-	.name	=	"GSC-ASIC",
-	.unmask	=	gsc_asic_unmask_irq,
-	.mask	=	gsc_asic_mask_irq,
+	.name		=	"GSC-ASIC",
+	.irq_unmask	=	gsc_asic_unmask_irq,
+	.irq_mask	=	gsc_asic_mask_irq,
 };
 
 int gsc_assign_irq(struct irq_chip *type, void *data)

commit 51890613f2bfa70453a5cc22c91c63946dd311cd
Author: James Bottomley <James.Bottomley@HansenPartnership.com>
Date:   Fri Dec 3 02:01:05 2010 +0000

    parisc: convert the rest of the irq handlers to simple/percpu
    
    The generic conversion eliminates the spurious no_ack and no_end
    routines, converts all the cascaded handlers to handle_simple_irq() and
    makes iosapic use a modified handle_percpu_irq() to become the same as
    the CPU irq's.  This isn't an essential change, but it eliminates the
    mask/unmask overhead of handle_level_irq().
    
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>
    Tested-by: Helge Deller <deller@gmx.de>
    Signed-off-by: Kyle McMartin <kyle@mcmartin.ca>

diff --git a/drivers/parisc/gsc.c b/drivers/parisc/gsc.c
index e605298e3aee..772b1939ac21 100644
--- a/drivers/parisc/gsc.c
+++ b/drivers/parisc/gsc.c
@@ -143,7 +143,6 @@ static struct irq_chip gsc_asic_interrupt_type = {
 	.name	=	"GSC-ASIC",
 	.unmask	=	gsc_asic_unmask_irq,
 	.mask	=	gsc_asic_mask_irq,
-	.ack	=	no_ack_irq,
 };
 
 int gsc_assign_irq(struct irq_chip *type, void *data)
@@ -153,7 +152,7 @@ int gsc_assign_irq(struct irq_chip *type, void *data)
 	if (irq > GSC_IRQ_MAX)
 		return NO_IRQ;
 
-	set_irq_chip_and_handler(irq, type, handle_level_irq);
+	set_irq_chip_and_handler(irq, type, handle_simple_irq);
 	set_irq_chip_data(irq, data);
 
 	return irq++;

commit 7998b3bd156478c35de685f90d4d0dda57916c60
Author: Kyle McMartin <kyle@dreadnought.i.jkkm.org>
Date:   Thu Oct 14 00:58:53 2010 -0400

    parisc: convert gsc and dino pci interrupts to flow handlers
    
    Signed-off-by: Kyle McMartin <kyle@redhat.com>

diff --git a/drivers/parisc/gsc.c b/drivers/parisc/gsc.c
index 68bccdafa897..e605298e3aee 100644
--- a/drivers/parisc/gsc.c
+++ b/drivers/parisc/gsc.c
@@ -105,7 +105,7 @@ int gsc_find_local_irq(unsigned int irq, int *global_irqs, int limit)
 	return NO_IRQ;
 }
 
-static void gsc_asic_disable_irq(unsigned int irq)
+static void gsc_asic_mask_irq(unsigned int irq)
 {
 	struct gsc_asic *irq_dev = get_irq_chip_data(irq);
 	int local_irq = gsc_find_local_irq(irq, irq_dev->global_irq, 32);
@@ -120,7 +120,7 @@ static void gsc_asic_disable_irq(unsigned int irq)
 	gsc_writel(imr, irq_dev->hpa + OFFSET_IMR);
 }
 
-static void gsc_asic_enable_irq(unsigned int irq)
+static void gsc_asic_unmask_irq(unsigned int irq)
 {
 	struct gsc_asic *irq_dev = get_irq_chip_data(irq);
 	int local_irq = gsc_find_local_irq(irq, irq_dev->global_irq, 32);
@@ -139,20 +139,11 @@ static void gsc_asic_enable_irq(unsigned int irq)
 	 */
 }
 
-static unsigned int gsc_asic_startup_irq(unsigned int irq)
-{
-	gsc_asic_enable_irq(irq);
-	return 0;
-}
-
 static struct irq_chip gsc_asic_interrupt_type = {
-	.name	 =	"GSC-ASIC",
-	.startup =	gsc_asic_startup_irq,
-	.shutdown =	gsc_asic_disable_irq,
-	.enable =	gsc_asic_enable_irq,
-	.disable =	gsc_asic_disable_irq,
-	.ack =		no_ack_irq,
-	.end =		no_end_irq,
+	.name	=	"GSC-ASIC",
+	.unmask	=	gsc_asic_unmask_irq,
+	.mask	=	gsc_asic_mask_irq,
+	.ack	=	no_ack_irq,
 };
 
 int gsc_assign_irq(struct irq_chip *type, void *data)
@@ -162,7 +153,7 @@ int gsc_assign_irq(struct irq_chip *type, void *data)
 	if (irq > GSC_IRQ_MAX)
 		return NO_IRQ;
 
-	set_irq_chip_and_handler(irq, type, parisc_do_IRQ);
+	set_irq_chip_and_handler(irq, type, handle_level_irq);
 	set_irq_chip_data(irq, data);
 
 	return irq++;

commit ba20085c20f1c9e8af546dea6ad0efa421bdef32
Author: Kyle McMartin <kyle@dreadnought.i.jkkm.org>
Date:   Wed Oct 13 21:00:55 2010 -0400

    parisc: lay groundwork for killing __do_IRQ
    
    Use proper accessors and handlers for generic irq cleanups. We just
    call back into __do_IRQ through desc->handler now, and remove the
    explicit calls.
    
    Signed-off-by: Kyle McMartin <kyle@redhat.com>

diff --git a/drivers/parisc/gsc.c b/drivers/parisc/gsc.c
index 20a1bce1a031..68bccdafa897 100644
--- a/drivers/parisc/gsc.c
+++ b/drivers/parisc/gsc.c
@@ -86,7 +86,7 @@ irqreturn_t gsc_asic_intr(int gsc_asic_irq, void *dev)
 	do {
 		int local_irq = __ffs(irr);
 		unsigned int irq = gsc_asic->global_irq[local_irq];
-		__do_IRQ(irq);
+		generic_handle_irq(irq);
 		irr &= ~(1 << local_irq);
 	} while (irr);
 
@@ -107,8 +107,7 @@ int gsc_find_local_irq(unsigned int irq, int *global_irqs, int limit)
 
 static void gsc_asic_disable_irq(unsigned int irq)
 {
-	struct irq_desc *desc = irq_to_desc(irq);
-	struct gsc_asic *irq_dev = desc->chip_data;
+	struct gsc_asic *irq_dev = get_irq_chip_data(irq);
 	int local_irq = gsc_find_local_irq(irq, irq_dev->global_irq, 32);
 	u32 imr;
 
@@ -123,8 +122,7 @@ static void gsc_asic_disable_irq(unsigned int irq)
 
 static void gsc_asic_enable_irq(unsigned int irq)
 {
-	struct irq_desc *desc = irq_to_desc(irq);
-	struct gsc_asic *irq_dev = desc->chip_data;
+	struct gsc_asic *irq_dev = get_irq_chip_data(irq);
 	int local_irq = gsc_find_local_irq(irq, irq_dev->global_irq, 32);
 	u32 imr;
 
@@ -160,14 +158,13 @@ static struct irq_chip gsc_asic_interrupt_type = {
 int gsc_assign_irq(struct irq_chip *type, void *data)
 {
 	static int irq = GSC_IRQ_BASE;
-	struct irq_desc *desc;
 
 	if (irq > GSC_IRQ_MAX)
 		return NO_IRQ;
 
-	desc = irq_to_desc(irq);
-	desc->chip = type;
-	desc->chip_data = data;
+	set_irq_chip_and_handler(irq, type, parisc_do_IRQ);
+	set_irq_chip_data(irq, data);
+
 	return irq++;
 }
 

commit 5a0e3ad6af8660be21ca98a971cd00f331318c05
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Mar 24 17:04:11 2010 +0900

    include cleanup: Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h
    
    percpu.h is included by sched.h and module.h and thus ends up being
    included when building most .c files.  percpu.h includes slab.h which
    in turn includes gfp.h making everything defined by the two files
    universally available and complicating inclusion dependencies.
    
    percpu.h -> slab.h dependency is about to be removed.  Prepare for
    this change by updating users of gfp and slab facilities include those
    headers directly instead of assuming availability.  As this conversion
    needs to touch large number of source files, the following script is
    used as the basis of conversion.
    
      http://userweb.kernel.org/~tj/misc/slabh-sweep.py
    
    The script does the followings.
    
    * Scan files for gfp and slab usages and update includes such that
      only the necessary includes are there.  ie. if only gfp is used,
      gfp.h, if slab is used, slab.h.
    
    * When the script inserts a new include, it looks at the include
      blocks and try to put the new include such that its order conforms
      to its surrounding.  It's put in the include block which contains
      core kernel includes, in the same order that the rest are ordered -
      alphabetical, Christmas tree, rev-Xmas-tree or at the end if there
      doesn't seem to be any matching order.
    
    * If the script can't find a place to put a new include (mostly
      because the file doesn't have fitting include block), it prints out
      an error message indicating which .h file needs to be added to the
      file.
    
    The conversion was done in the following steps.
    
    1. The initial automatic conversion of all .c files updated slightly
       over 4000 files, deleting around 700 includes and adding ~480 gfp.h
       and ~3000 slab.h inclusions.  The script emitted errors for ~400
       files.
    
    2. Each error was manually checked.  Some didn't need the inclusion,
       some needed manual addition while adding it to implementation .h or
       embedding .c file was more appropriate for others.  This step added
       inclusions to around 150 files.
    
    3. The script was run again and the output was compared to the edits
       from #2 to make sure no file was left behind.
    
    4. Several build tests were done and a couple of problems were fixed.
       e.g. lib/decompress_*.c used malloc/free() wrappers around slab
       APIs requiring slab.h to be added manually.
    
    5. The script was run on all .h files but without automatically
       editing them as sprinkling gfp.h and slab.h inclusions around .h
       files could easily lead to inclusion dependency hell.  Most gfp.h
       inclusion directives were ignored as stuff from gfp.h was usually
       wildly available and often used in preprocessor macros.  Each
       slab.h inclusion directive was examined and added manually as
       necessary.
    
    6. percpu.h was updated not to include slab.h.
    
    7. Build test were done on the following configurations and failures
       were fixed.  CONFIG_GCOV_KERNEL was turned off for all tests (as my
       distributed build env didn't work with gcov compiles) and a few
       more options had to be turned off depending on archs to make things
       build (like ipr on powerpc/64 which failed due to missing writeq).
    
       * x86 and x86_64 UP and SMP allmodconfig and a custom test config.
       * powerpc and powerpc64 SMP allmodconfig
       * sparc and sparc64 SMP allmodconfig
       * ia64 SMP allmodconfig
       * s390 SMP allmodconfig
       * alpha SMP allmodconfig
       * um on x86_64 SMP allmodconfig
    
    8. percpu.h modifications were reverted so that it could be applied as
       a separate patch and serve as bisection point.
    
    Given the fact that I had only a couple of failures from tests on step
    6, I'm fairly confident about the coverage of this conversion patch.
    If there is a breakage, it's likely to be something in one of the arch
    headers which should be easily discoverable easily on most builds of
    the specific arch.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Guess-its-ok-by: Christoph Lameter <cl@linux-foundation.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Lee Schermerhorn <Lee.Schermerhorn@hp.com>

diff --git a/drivers/parisc/gsc.c b/drivers/parisc/gsc.c
index c4e1f3c3c2fa..20a1bce1a031 100644
--- a/drivers/parisc/gsc.c
+++ b/drivers/parisc/gsc.c
@@ -19,7 +19,6 @@
 #include <linux/interrupt.h>
 #include <linux/ioport.h>
 #include <linux/module.h>
-#include <linux/slab.h>
 #include <linux/types.h>
 
 #include <asm/hardware.h>

commit d0608b54740c82b08056b7611e38a3fd73be3564
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Nov 17 22:50:59 2009 +0000

    parisc: Fixup last users of irq_chip->typename
    
    The typename member of struct irq_chip was kept for migration purposes
    and is obsolete since more than 2 years. Fix up the leftovers.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Kyle McMartin <kyle@mcmartin.ca>

diff --git a/drivers/parisc/gsc.c b/drivers/parisc/gsc.c
index 647adc9f85ad..c4e1f3c3c2fa 100644
--- a/drivers/parisc/gsc.c
+++ b/drivers/parisc/gsc.c
@@ -149,7 +149,7 @@ static unsigned int gsc_asic_startup_irq(unsigned int irq)
 }
 
 static struct irq_chip gsc_asic_interrupt_type = {
-	.typename =	"GSC-ASIC",
+	.name	 =	"GSC-ASIC",
 	.startup =	gsc_asic_startup_irq,
 	.shutdown =	gsc_asic_disable_irq,
 	.enable =	gsc_asic_enable_irq,

commit dfe07565021959f0f646e9e775810c1bfbe0f6d6
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Jun 10 19:56:04 2009 +0000

    parisc: remove obsolete hw_interrupt_type
    
    The defines and typedefs (hw_interrupt_type, no_irq_type, irq_desc_t) have
    been kept around for migration reasons.  After more than two years it's
    time to remove them finally.
    
    This patch cleans up one of the remaining users.  When all such patches
    hit mainline we can remove the defines and typedefs finally.
    
    Impact: cleanup
    
    Convert the last remaining users to struct irq_chip and remove the
    define.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Kyle McMartin <kyle@mcmartin.ca>

diff --git a/drivers/parisc/gsc.c b/drivers/parisc/gsc.c
index d33632917696..647adc9f85ad 100644
--- a/drivers/parisc/gsc.c
+++ b/drivers/parisc/gsc.c
@@ -148,7 +148,7 @@ static unsigned int gsc_asic_startup_irq(unsigned int irq)
 	return 0;
 }
 
-static struct hw_interrupt_type gsc_asic_interrupt_type = {
+static struct irq_chip gsc_asic_interrupt_type = {
 	.typename =	"GSC-ASIC",
 	.startup =	gsc_asic_startup_irq,
 	.shutdown =	gsc_asic_disable_irq,
@@ -158,7 +158,7 @@ static struct hw_interrupt_type gsc_asic_interrupt_type = {
 	.end =		no_end_irq,
 };
 
-int gsc_assign_irq(struct hw_interrupt_type *type, void *data)
+int gsc_assign_irq(struct irq_chip *type, void *data)
 {
 	static int irq = GSC_IRQ_BASE;
 	struct irq_desc *desc;

commit bfe4f4f800ccbb499a1120735016a20d3feacd4f
Author: James Bottomley <James.Bottomley@HansenPartnership.com>
Date:   Fri Jan 9 18:57:06 2009 -0600

    parisc: remove klist iterators
    
    commit 11c3b5c3e08f4d855cbef52883c266b9ab9df879
    Author: Greg Kroah-Hartman <gregkh@suse.de>
    Date:   Tue Dec 16 12:24:56 2008 -0800
    
        driver core: move klist_children into private structure
    
    Broke our parisc build pretty badly because we touch the klists directly
    in three cases (AGP, SBA and GSC).  Although GregKH will revert this
    patch, there's no reason we should be using the iterators directly, we
    can just move to the standard device_for_each_child() API.
    
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>
    Tested-by: Helge Deller <deller@gmx.de>
    Tested-by: Kyle McMartin <kyle@mcmartin.ca>
    Signed-off-by: Kyle McMartin <kyle@mcmartin.ca>

diff --git a/drivers/parisc/gsc.c b/drivers/parisc/gsc.c
index e76db9e4d504..d33632917696 100644
--- a/drivers/parisc/gsc.c
+++ b/drivers/parisc/gsc.c
@@ -186,29 +186,34 @@ void gsc_asic_assign_irq(struct gsc_asic *asic, int local_irq, int *irqp)
 	*irqp = irq;
 }
 
-static struct device *next_device(struct klist_iter *i)
+struct gsc_fixup_struct {
+	void (*choose_irq)(struct parisc_device *, void *);
+	void *ctrl;
+};
+
+static int gsc_fixup_irqs_callback(struct device *dev, void *data)
 {
-	struct klist_node * n = klist_next(i);
-	return n ? container_of(n, struct device, knode_parent) : NULL;
+	struct parisc_device *padev = to_parisc_device(dev);
+	struct gsc_fixup_struct *gf = data;
+
+	/* work-around for 715/64 and others which have parent
+	   at path [5] and children at path [5/0/x] */
+	if (padev->id.hw_type == HPHW_FAULTY)
+		gsc_fixup_irqs(padev, gf->ctrl, gf->choose_irq);
+	gf->choose_irq(padev, gf->ctrl);
+
+	return 0;
 }
 
 void gsc_fixup_irqs(struct parisc_device *parent, void *ctrl,
 			void (*choose_irq)(struct parisc_device *, void *))
 {
-	struct device *dev;
-	struct klist_iter i;
-
-	klist_iter_init(&parent->dev.klist_children, &i);
-	while ((dev = next_device(&i))) {
-		struct parisc_device *padev = to_parisc_device(dev);
-
-		/* work-around for 715/64 and others which have parent 
-		   at path [5] and children at path [5/0/x] */
-		if (padev->id.hw_type == HPHW_FAULTY)
-			return gsc_fixup_irqs(padev, ctrl, choose_irq);
-		choose_irq(padev, ctrl);
-	}
-	klist_iter_exit(&i);
+	struct gsc_fixup_struct data = {
+		.choose_irq	= choose_irq,
+		.ctrl		= ctrl,
+	};
+
+	device_for_each_child(&parent->dev, &data, gsc_fixup_irqs_callback);
 }
 
 int gsc_common_setup(struct parisc_device *parent, struct gsc_asic *gsc_asic)

commit 08678b0841267c1d00d771fe01548d86043d065e
Author: Yinghai Lu <yhlu.kernel@gmail.com>
Date:   Tue Aug 19 20:50:05 2008 -0700

    generic: sparse irqs: use irq_desc() together with dyn_array, instead of irq_desc[]
    
    add CONFIG_HAVE_SPARSE_IRQ to for use condensed array.
    Get rid of irq_desc[] array assumptions.
    
    Preallocate 32 irq_desc, and irq_desc() will try to get more.
    
    ( No change in functionality is expected anywhere, except the odd build
      failure where we missed a code site or where a crossing commit itroduces
      new irq_desc[] usage. )
    
    v2: according to Eric, change get_irq_desc() to irq_desc()
    
    Signed-off-by: Yinghai Lu <yhlu.kernel@gmail.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/drivers/parisc/gsc.c b/drivers/parisc/gsc.c
index f7d088b897ee..e76db9e4d504 100644
--- a/drivers/parisc/gsc.c
+++ b/drivers/parisc/gsc.c
@@ -108,7 +108,8 @@ int gsc_find_local_irq(unsigned int irq, int *global_irqs, int limit)
 
 static void gsc_asic_disable_irq(unsigned int irq)
 {
-	struct gsc_asic *irq_dev = irq_desc[irq].chip_data;
+	struct irq_desc *desc = irq_to_desc(irq);
+	struct gsc_asic *irq_dev = desc->chip_data;
 	int local_irq = gsc_find_local_irq(irq, irq_dev->global_irq, 32);
 	u32 imr;
 
@@ -123,7 +124,8 @@ static void gsc_asic_disable_irq(unsigned int irq)
 
 static void gsc_asic_enable_irq(unsigned int irq)
 {
-	struct gsc_asic *irq_dev = irq_desc[irq].chip_data;
+	struct irq_desc *desc = irq_to_desc(irq);
+	struct gsc_asic *irq_dev = desc->chip_data;
 	int local_irq = gsc_find_local_irq(irq, irq_dev->global_irq, 32);
 	u32 imr;
 
@@ -159,12 +161,14 @@ static struct hw_interrupt_type gsc_asic_interrupt_type = {
 int gsc_assign_irq(struct hw_interrupt_type *type, void *data)
 {
 	static int irq = GSC_IRQ_BASE;
+	struct irq_desc *desc;
 
 	if (irq > GSC_IRQ_MAX)
 		return NO_IRQ;
 
-	irq_desc[irq].chip = type;
-	irq_desc[irq].chip_data = data;
+	desc = irq_to_desc(irq);
+	desc->chip = type;
+	desc->chip_data = data;
 	return irq++;
 }
 

commit a8043ecb17bd2e4b034006bee315efeea3936278
Author: Harvey Harrison <harvey.harrison@gmail.com>
Date:   Wed May 14 16:21:56 2008 -0700

    drivers/parisc: replace remaining __FUNCTION__ occurrences
    
    __FUNCTION__ is gcc-specific, use __func__
    
    Signed-off-by: Harvey Harrison <harvey.harrison@gmail.com>
    Cc: Kyle McMartin <kyle@mcmartin.ca>
    Cc: Matthew Wilcox <willy@debian.org>
    Cc: Grant Grundler <grundler@parisc-linux.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Kyle McMartin <kyle@mcmartin.ca>

diff --git a/drivers/parisc/gsc.c b/drivers/parisc/gsc.c
index 1b3e3fd12d95..f7d088b897ee 100644
--- a/drivers/parisc/gsc.c
+++ b/drivers/parisc/gsc.c
@@ -112,7 +112,7 @@ static void gsc_asic_disable_irq(unsigned int irq)
 	int local_irq = gsc_find_local_irq(irq, irq_dev->global_irq, 32);
 	u32 imr;
 
-	DEBPRINTK(KERN_DEBUG "%s(%d) %s: IMR 0x%x\n", __FUNCTION__, irq,
+	DEBPRINTK(KERN_DEBUG "%s(%d) %s: IMR 0x%x\n", __func__, irq,
 			irq_dev->name, imr);
 
 	/* Disable the IRQ line by clearing the bit in the IMR */
@@ -127,7 +127,7 @@ static void gsc_asic_enable_irq(unsigned int irq)
 	int local_irq = gsc_find_local_irq(irq, irq_dev->global_irq, 32);
 	u32 imr;
 
-	DEBPRINTK(KERN_DEBUG "%s(%d) %s: IMR 0x%x\n", __FUNCTION__, irq,
+	DEBPRINTK(KERN_DEBUG "%s(%d) %s: IMR 0x%x\n", __func__, irq,
 			irq_dev->name, imr);
 
 	/* Enable the IRQ line by setting the bit in the IMR */

commit 7d12e780e003f93433d49ce78cfedf4b4c52adc5
Author: David Howells <dhowells@redhat.com>
Date:   Thu Oct 5 14:55:46 2006 +0100

    IRQ: Maintain regs pointer globally rather than passing to IRQ handlers
    
    Maintain a per-CPU global "struct pt_regs *" variable which can be used instead
    of passing regs around manually through all ~1800 interrupt handlers in the
    Linux kernel.
    
    The regs pointer is used in few places, but it potentially costs both stack
    space and code to pass it around.  On the FRV arch, removing the regs parameter
    from all the genirq function results in a 20% speed up of the IRQ exit path
    (ie: from leaving timer_interrupt() to leaving do_IRQ()).
    
    Where appropriate, an arch may override the generic storage facility and do
    something different with the variable.  On FRV, for instance, the address is
    maintained in GR28 at all times inside the kernel as part of general exception
    handling.
    
    Having looked over the code, it appears that the parameter may be handed down
    through up to twenty or so layers of functions.  Consider a USB character
    device attached to a USB hub, attached to a USB controller that posts its
    interrupts through a cascaded auxiliary interrupt controller.  A character
    device driver may want to pass regs to the sysrq handler through the input
    layer which adds another few layers of parameter passing.
    
    I've build this code with allyesconfig for x86_64 and i386.  I've runtested the
    main part of the code on FRV and i386, though I can't test most of the drivers.
    I've also done partial conversion for powerpc and MIPS - these at least compile
    with minimal configurations.
    
    This will affect all archs.  Mostly the changes should be relatively easy.
    Take do_IRQ(), store the regs pointer at the beginning, saving the old one:
    
            struct pt_regs *old_regs = set_irq_regs(regs);
    
    And put the old one back at the end:
    
            set_irq_regs(old_regs);
    
    Don't pass regs through to generic_handle_irq() or __do_IRQ().
    
    In timer_interrupt(), this sort of change will be necessary:
    
            -       update_process_times(user_mode(regs));
            -       profile_tick(CPU_PROFILING, regs);
            +       update_process_times(user_mode(get_irq_regs()));
            +       profile_tick(CPU_PROFILING);
    
    I'd like to move update_process_times()'s use of get_irq_regs() into itself,
    except that i386, alone of the archs, uses something other than user_mode().
    
    Some notes on the interrupt handling in the drivers:
    
     (*) input_dev() is now gone entirely.  The regs pointer is no longer stored in
         the input_dev struct.
    
     (*) finish_unlinks() in drivers/usb/host/ohci-q.c needs checking.  It does
         something different depending on whether it's been supplied with a regs
         pointer or not.
    
     (*) Various IRQ handler function pointers have been moved to type
         irq_handler_t.
    
    Signed-Off-By: David Howells <dhowells@redhat.com>
    (cherry picked from 1b16e7ac850969f38b375e511e3fa2f474a33867 commit)

diff --git a/drivers/parisc/gsc.c b/drivers/parisc/gsc.c
index b45aa5c675a0..1b3e3fd12d95 100644
--- a/drivers/parisc/gsc.c
+++ b/drivers/parisc/gsc.c
@@ -73,7 +73,7 @@ EXPORT_SYMBOL(gsc_alloc_irq);
 EXPORT_SYMBOL(gsc_claim_irq);
 
 /* Common interrupt demultiplexer used by Asp, Lasi & Wax.  */
-irqreturn_t gsc_asic_intr(int gsc_asic_irq, void *dev, struct pt_regs *regs)
+irqreturn_t gsc_asic_intr(int gsc_asic_irq, void *dev)
 {
 	unsigned long irr;
 	struct gsc_asic *gsc_asic = dev;
@@ -87,7 +87,7 @@ irqreturn_t gsc_asic_intr(int gsc_asic_irq, void *dev, struct pt_regs *regs)
 	do {
 		int local_irq = __ffs(irr);
 		unsigned int irq = gsc_asic->global_irq[local_irq];
-		__do_IRQ(irq, regs);
+		__do_IRQ(irq);
 		irr &= ~(1 << local_irq);
 	} while (irr);
 

commit 6ab3d5624e172c553004ecc862bfeac16d9d68b7
Author: Jörn Engel <joern@wohnheim.fh-wedel.de>
Date:   Fri Jun 30 19:25:36 2006 +0200

    Remove obsolete #include <linux/config.h>
    
    Signed-off-by: Jörn Engel <joern@wohnheim.fh-wedel.de>
    Signed-off-by: Adrian Bunk <bunk@stusta.de>

diff --git a/drivers/parisc/gsc.c b/drivers/parisc/gsc.c
index 5476ba7709b3..b45aa5c675a0 100644
--- a/drivers/parisc/gsc.c
+++ b/drivers/parisc/gsc.c
@@ -14,7 +14,6 @@
  */
 
 #include <linux/bitops.h>
-#include <linux/config.h>
 #include <linux/errno.h>
 #include <linux/init.h>
 #include <linux/interrupt.h>

commit d1bef4ed5faf7d9872337b33c4269e45ae1bf960
Author: Ingo Molnar <mingo@elte.hu>
Date:   Thu Jun 29 02:24:36 2006 -0700

    [PATCH] genirq: rename desc->handler to desc->chip
    
    This patch-queue improves the generic IRQ layer to be truly generic, by adding
    various abstractions and features to it, without impacting existing
    functionality.
    
    While the queue can be best described as "fix and improve everything in the
    generic IRQ layer that we could think of", and thus it consists of many
    smaller features and lots of cleanups, the one feature that stands out most is
    the new 'irq chip' abstraction.
    
    The irq-chip abstraction is about describing and coding and IRQ controller
    driver by mapping its raw hardware capabilities [and quirks, if needed] in a
    straightforward way, without having to think about "IRQ flow"
    (level/edge/etc.) type of details.
    
    This stands in contrast with the current 'irq-type' model of genirq
    architectures, which 'mixes' raw hardware capabilities with 'flow' details.
    The patchset supports both types of irq controller designs at once, and
    converts i386 and x86_64 to the new irq-chip design.
    
    As a bonus side-effect of the irq-chip approach, chained interrupt controllers
    (master/slave PIC constructs, etc.) are now supported by design as well.
    
    The end result of this patchset intends to be simpler architecture-level code
    and more consolidation between architectures.
    
    We reused many bits of code and many concepts from Russell King's ARM IRQ
    layer, the merging of which was one of the motivations for this patchset.
    
    This patch:
    
    rename desc->handler to desc->chip.
    
    Originally i did not want to do this, because it's a big patch.  But having
    both "desc->handler", "desc->handle_irq" and "action->handler" caused a
    large degree of confusion and made the code appear alot less clean than it
    truly is.
    
    I have also attempted a dual approach as well by introducing a
    desc->chip alias - but that just wasnt robust enough and broke
    frequently.
    
    So lets get over with this quickly.  The conversion was done automatically
    via scripts and converts all the code in the kernel.
    
    This renaming patch is the first one amongst the patches, so that the
    remaining patches can stay flexible and can be merged and split up
    without having some big monolithic patch act as a merge barrier.
    
    [akpm@osdl.org: build fix]
    [akpm@osdl.org: another build fix]
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/parisc/gsc.c b/drivers/parisc/gsc.c
index 16d40f95978d..5476ba7709b3 100644
--- a/drivers/parisc/gsc.c
+++ b/drivers/parisc/gsc.c
@@ -109,7 +109,7 @@ int gsc_find_local_irq(unsigned int irq, int *global_irqs, int limit)
 
 static void gsc_asic_disable_irq(unsigned int irq)
 {
-	struct gsc_asic *irq_dev = irq_desc[irq].handler_data;
+	struct gsc_asic *irq_dev = irq_desc[irq].chip_data;
 	int local_irq = gsc_find_local_irq(irq, irq_dev->global_irq, 32);
 	u32 imr;
 
@@ -124,7 +124,7 @@ static void gsc_asic_disable_irq(unsigned int irq)
 
 static void gsc_asic_enable_irq(unsigned int irq)
 {
-	struct gsc_asic *irq_dev = irq_desc[irq].handler_data;
+	struct gsc_asic *irq_dev = irq_desc[irq].chip_data;
 	int local_irq = gsc_find_local_irq(irq, irq_dev->global_irq, 32);
 	u32 imr;
 
@@ -164,8 +164,8 @@ int gsc_assign_irq(struct hw_interrupt_type *type, void *data)
 	if (irq > GSC_IRQ_MAX)
 		return NO_IRQ;
 
-	irq_desc[irq].handler = type;
-	irq_desc[irq].handler_data = data;
+	irq_desc[irq].chip = type;
+	irq_desc[irq].chip_data = data;
 	return irq++;
 }
 

commit 5658374766d9e0249bd04e9d62bdb8456b916b64
Author: Matthew Wilcox <willy@parisc-linux.org>
Date:   Fri Oct 21 22:33:38 2005 -0400

    [PARISC] Convert parisc_device tree to use struct device klists
    
    Fix parse_tree_node.  much more needs to be done to fix this file.
    
    Signed-off-by: Matthew Wilcox <willy@parisc-linux.org>
    
    Make drivers.c compile based on a patch from Pat Mochel.
    
    From: Patrick Mochel <mochel@digitalimplant.org>
    Signed-off-by: Kyle McMartin <kyle@parisc-linux.org>
    
    Fix drivers.c to create new device tree nodes when no match is found.
    
    Signed-off-by: Richard Hirst <rhirst@parisc-linux.org>
    
    Do a proper depth-first search returning parents before children, using the
    new klist infrastructure.
    
    Signed-off-by: Richard Hirst <rhirst@parisc-linux.org>
    
    Fixed parisc_device traversal so that pdc_stable works again
    Fixed check_dev so it doesn't dereference a parisc_device until it
    has verified the bus type
    
    Signed-off-by: Randolph Chung <tausq@parisc-linux.org>
    
    Convert pa_dev->hpa from an unsigned long to a struct resource.
    Use insert_resource() instead of request_mem_region().
    Request resources at bus walk time instead of driver probe time.
    Don't release the resources as we don't have any hotplug parisc_device
    support yet.
    Add parisc_pathname() to conveniently get the textual representation
    of the hwpath used in sysfs.
    Inline the remnants of claim_device() into its caller.
    
    Signed-off-by: Matthew Wilcox <willy@parisc-linux.org>
    
    I noticed that some of the STI regions weren't showing up in iomem.
    Reading the STI spec indicated that all STI devices occupy at least 32MB.
    So check for STI HPAs and give them 32MB instead of 4kB.
    
    Signed-off-by: Matthew Wilcox <willy@parisc-linux.org>
    
    Signed-off-by: Kyle McMartin <kyle@parisc-linux.org>

diff --git a/drivers/parisc/gsc.c b/drivers/parisc/gsc.c
index af5e02526a18..16d40f95978d 100644
--- a/drivers/parisc/gsc.c
+++ b/drivers/parisc/gsc.c
@@ -183,12 +183,20 @@ void gsc_asic_assign_irq(struct gsc_asic *asic, int local_irq, int *irqp)
 	*irqp = irq;
 }
 
+static struct device *next_device(struct klist_iter *i)
+{
+	struct klist_node * n = klist_next(i);
+	return n ? container_of(n, struct device, knode_parent) : NULL;
+}
+
 void gsc_fixup_irqs(struct parisc_device *parent, void *ctrl,
 			void (*choose_irq)(struct parisc_device *, void *))
 {
 	struct device *dev;
+	struct klist_iter i;
 
-	list_for_each_entry(dev, &parent->dev.children, node) {
+	klist_iter_init(&parent->dev.klist_children, &i);
+	while ((dev = next_device(&i))) {
 		struct parisc_device *padev = to_parisc_device(dev);
 
 		/* work-around for 715/64 and others which have parent 
@@ -197,6 +205,7 @@ void gsc_fixup_irqs(struct parisc_device *parent, void *ctrl,
 			return gsc_fixup_irqs(padev, ctrl, choose_irq);
 		choose_irq(padev, ctrl);
 	}
+	klist_iter_exit(&i);
 }
 
 int gsc_common_setup(struct parisc_device *parent, struct gsc_asic *gsc_asic)

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/drivers/parisc/gsc.c b/drivers/parisc/gsc.c
new file mode 100644
index 000000000000..af5e02526a18
--- /dev/null
+++ b/drivers/parisc/gsc.c
@@ -0,0 +1,245 @@
+/*
+ * Interrupt management for most GSC and related devices.
+ *
+ * (c) Copyright 1999 Alex deVries for The Puffin Group
+ * (c) Copyright 1999 Grant Grundler for Hewlett-Packard
+ * (c) Copyright 1999 Matthew Wilcox
+ * (c) Copyright 2000 Helge Deller
+ * (c) Copyright 2001 Matthew Wilcox for Hewlett-Packard
+ *
+ *	This program is free software; you can redistribute it and/or modify
+ *	it under the terms of the GNU General Public License as published by
+ *      the Free Software Foundation; either version 2 of the License, or
+ *      (at your option) any later version.
+ */
+
+#include <linux/bitops.h>
+#include <linux/config.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/ioport.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/types.h>
+
+#include <asm/hardware.h>
+#include <asm/io.h>
+
+#include "gsc.h"
+
+#undef DEBUG
+
+#ifdef DEBUG
+#define DEBPRINTK printk
+#else
+#define DEBPRINTK(x,...)
+#endif
+
+int gsc_alloc_irq(struct gsc_irq *i)
+{
+	int irq = txn_alloc_irq(GSC_EIM_WIDTH);
+	if (irq < 0) {
+		printk("cannot get irq\n");
+		return irq;
+	}
+
+	i->txn_addr = txn_alloc_addr(irq);
+	i->txn_data = txn_alloc_data(irq);
+	i->irq = irq;
+
+	return irq;
+}
+
+int gsc_claim_irq(struct gsc_irq *i, int irq)
+{
+	int c = irq;
+
+	irq += CPU_IRQ_BASE; /* virtualize the IRQ first */
+
+	irq = txn_claim_irq(irq);
+	if (irq < 0) {
+		printk("cannot claim irq %d\n", c);
+		return irq;
+	}
+
+	i->txn_addr = txn_alloc_addr(irq);
+	i->txn_data = txn_alloc_data(irq);
+	i->irq = irq;
+
+	return irq;
+}
+
+EXPORT_SYMBOL(gsc_alloc_irq);
+EXPORT_SYMBOL(gsc_claim_irq);
+
+/* Common interrupt demultiplexer used by Asp, Lasi & Wax.  */
+irqreturn_t gsc_asic_intr(int gsc_asic_irq, void *dev, struct pt_regs *regs)
+{
+	unsigned long irr;
+	struct gsc_asic *gsc_asic = dev;
+
+	irr = gsc_readl(gsc_asic->hpa + OFFSET_IRR);
+	if (irr == 0)
+		return IRQ_NONE;
+
+	DEBPRINTK("%s intr, mask=0x%x\n", gsc_asic->name, irr);
+
+	do {
+		int local_irq = __ffs(irr);
+		unsigned int irq = gsc_asic->global_irq[local_irq];
+		__do_IRQ(irq, regs);
+		irr &= ~(1 << local_irq);
+	} while (irr);
+
+	return IRQ_HANDLED;
+}
+
+int gsc_find_local_irq(unsigned int irq, int *global_irqs, int limit)
+{
+	int local_irq;
+
+	for (local_irq = 0; local_irq < limit; local_irq++) {
+		if (global_irqs[local_irq] == irq)
+			return local_irq;
+	}
+
+	return NO_IRQ;
+}
+
+static void gsc_asic_disable_irq(unsigned int irq)
+{
+	struct gsc_asic *irq_dev = irq_desc[irq].handler_data;
+	int local_irq = gsc_find_local_irq(irq, irq_dev->global_irq, 32);
+	u32 imr;
+
+	DEBPRINTK(KERN_DEBUG "%s(%d) %s: IMR 0x%x\n", __FUNCTION__, irq,
+			irq_dev->name, imr);
+
+	/* Disable the IRQ line by clearing the bit in the IMR */
+	imr = gsc_readl(irq_dev->hpa + OFFSET_IMR);
+	imr &= ~(1 << local_irq);
+	gsc_writel(imr, irq_dev->hpa + OFFSET_IMR);
+}
+
+static void gsc_asic_enable_irq(unsigned int irq)
+{
+	struct gsc_asic *irq_dev = irq_desc[irq].handler_data;
+	int local_irq = gsc_find_local_irq(irq, irq_dev->global_irq, 32);
+	u32 imr;
+
+	DEBPRINTK(KERN_DEBUG "%s(%d) %s: IMR 0x%x\n", __FUNCTION__, irq,
+			irq_dev->name, imr);
+
+	/* Enable the IRQ line by setting the bit in the IMR */
+	imr = gsc_readl(irq_dev->hpa + OFFSET_IMR);
+	imr |= 1 << local_irq;
+	gsc_writel(imr, irq_dev->hpa + OFFSET_IMR);
+	/*
+	 * FIXME: read IPR to make sure the IRQ isn't already pending.
+	 *   If so, we need to read IRR and manually call do_irq().
+	 */
+}
+
+static unsigned int gsc_asic_startup_irq(unsigned int irq)
+{
+	gsc_asic_enable_irq(irq);
+	return 0;
+}
+
+static struct hw_interrupt_type gsc_asic_interrupt_type = {
+	.typename =	"GSC-ASIC",
+	.startup =	gsc_asic_startup_irq,
+	.shutdown =	gsc_asic_disable_irq,
+	.enable =	gsc_asic_enable_irq,
+	.disable =	gsc_asic_disable_irq,
+	.ack =		no_ack_irq,
+	.end =		no_end_irq,
+};
+
+int gsc_assign_irq(struct hw_interrupt_type *type, void *data)
+{
+	static int irq = GSC_IRQ_BASE;
+
+	if (irq > GSC_IRQ_MAX)
+		return NO_IRQ;
+
+	irq_desc[irq].handler = type;
+	irq_desc[irq].handler_data = data;
+	return irq++;
+}
+
+void gsc_asic_assign_irq(struct gsc_asic *asic, int local_irq, int *irqp)
+{
+	int irq = asic->global_irq[local_irq];
+	
+	if (irq <= 0) {
+		irq = gsc_assign_irq(&gsc_asic_interrupt_type, asic);
+		if (irq == NO_IRQ)
+			return;
+
+		asic->global_irq[local_irq] = irq;
+	}
+	*irqp = irq;
+}
+
+void gsc_fixup_irqs(struct parisc_device *parent, void *ctrl,
+			void (*choose_irq)(struct parisc_device *, void *))
+{
+	struct device *dev;
+
+	list_for_each_entry(dev, &parent->dev.children, node) {
+		struct parisc_device *padev = to_parisc_device(dev);
+
+		/* work-around for 715/64 and others which have parent 
+		   at path [5] and children at path [5/0/x] */
+		if (padev->id.hw_type == HPHW_FAULTY)
+			return gsc_fixup_irqs(padev, ctrl, choose_irq);
+		choose_irq(padev, ctrl);
+	}
+}
+
+int gsc_common_setup(struct parisc_device *parent, struct gsc_asic *gsc_asic)
+{
+	struct resource *res;
+	int i;
+
+	gsc_asic->gsc = parent;
+
+	/* Initialise local irq -> global irq mapping */
+	for (i = 0; i < 32; i++) {
+		gsc_asic->global_irq[i] = NO_IRQ;
+	}
+
+	/* allocate resource region */
+	res = request_mem_region(gsc_asic->hpa, 0x100000, gsc_asic->name);
+	if (res) {
+		res->flags = IORESOURCE_MEM; 	/* do not mark it busy ! */
+	}
+
+#if 0
+	printk(KERN_WARNING "%s IRQ %d EIM 0x%x", gsc_asic->name,
+			parent->irq, gsc_asic->eim);
+	if (gsc_readl(gsc_asic->hpa + OFFSET_IMR))
+		printk("  IMR is non-zero! (0x%x)",
+				gsc_readl(gsc_asic->hpa + OFFSET_IMR));
+	printk("\n");
+#endif
+
+	return 0;
+}
+
+extern struct parisc_driver lasi_driver;
+extern struct parisc_driver asp_driver;
+extern struct parisc_driver wax_driver;
+
+void __init gsc_init(void)
+{
+#ifdef CONFIG_GSC_LASI
+	register_parisc_driver(&lasi_driver);
+	register_parisc_driver(&asp_driver);
+#endif
+#ifdef CONFIG_GSC_WAX
+	register_parisc_driver(&wax_driver);
+#endif
+}
