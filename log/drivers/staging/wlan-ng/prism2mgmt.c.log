commit 4cc41cbce536876678b35e03c4a8a7bb72c78fa9
Author: Colin Ian King <colin.king@canonical.com>
Date:   Tue Jan 14 18:16:04 2020 +0000

    staging: wlan-ng: ensure error return is actually returned
    
    Currently when the call to prism2sta_ifst fails a netdev_err error
    is reported, error return variable result is set to -1 but the
    function always returns 0 for success.  Fix this by returning
    the error value in variable result rather than 0.
    
    Addresses-Coverity: ("Unused value")
    Fixes: 00b3ed168508 ("Staging: add wlan-ng prism2 usb driver")
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Cc: stable <stable@vger.kernel.org>
    Link: https://lore.kernel.org/r/20200114181604.390235-1-colin.king@canonical.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/prism2mgmt.c b/drivers/staging/wlan-ng/prism2mgmt.c
index 7350fe5d96a3..a8860d2aee68 100644
--- a/drivers/staging/wlan-ng/prism2mgmt.c
+++ b/drivers/staging/wlan-ng/prism2mgmt.c
@@ -959,7 +959,7 @@ int prism2mgmt_flashdl_state(struct wlandevice *wlandev, void *msgp)
 		}
 	}
 
-	return 0;
+	return result;
 }
 
 /*----------------------------------------------------------------

commit 460f6f8b24ff94fbd9635502e2339dda7927f556
Author: Tim Collier <osdevtc@gmail.com>
Date:   Fri Jul 6 20:38:15 2018 +0100

    staging: wlan-ng: remove unneeded parentheses from prism2mgmt.c
    
    remove parentheses reported as unnecessary by checkpatch
    
    Signed-off-by: Tim Collier <osdevtc@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/prism2mgmt.c b/drivers/staging/wlan-ng/prism2mgmt.c
index 13fff7b19fb6..7350fe5d96a3 100644
--- a/drivers/staging/wlan-ng/prism2mgmt.c
+++ b/drivers/staging/wlan-ng/prism2mgmt.c
@@ -414,7 +414,7 @@ int prism2mgmt_scan_results(struct wlandevice *wlandev, void *msgp)
 		goto exit;
 	}
 
-	item = &(hw->scanresults->info.hscanresult.result[req->bssindex.data]);
+	item = &hw->scanresults->info.hscanresult.result[req->bssindex.data];
 	/* signal and noise */
 	req->signal.status = P80211ENUM_msgitem_status_data_ok;
 	req->noise.status = P80211ENUM_msgitem_status_data_ok;
@@ -1075,7 +1075,7 @@ int prism2mgmt_autojoin(struct wlandevice *wlandev, void *msgp)
 
 	/* Set the ssid */
 	memset(bytebuf, 0, 256);
-	pstr = (struct p80211pstrd *)&(msg->ssid.data);
+	pstr = (struct p80211pstrd *)&msg->ssid.data;
 	prism2mgmt_pstr2bytestr(p2bytestr, pstr);
 	result = hfa384x_drvr_setconfig(hw, HFA384x_RID_CNFDESIREDSSID,
 					bytebuf,
@@ -1199,7 +1199,7 @@ int prism2mgmt_wlansniff(struct wlandevice *wlandev, void *msgp)
 				/* Save macport 0 state */
 				result = hfa384x_drvr_getconfig16(hw,
 						  HFA384x_RID_CNFPORTTYPE,
-						  &(hw->presniff_port_type));
+						  &hw->presniff_port_type);
 				if (result) {
 					netdev_dbg
 					(wlandev->netdev,
@@ -1210,7 +1210,7 @@ int prism2mgmt_wlansniff(struct wlandevice *wlandev, void *msgp)
 				/* Save the wepflags state */
 				result = hfa384x_drvr_getconfig16(hw,
 						  HFA384x_RID_CNFWEPFLAGS,
-						  &(hw->presniff_wepflags));
+						  &hw->presniff_wepflags);
 				if (result) {
 					netdev_dbg
 					(wlandev->netdev,

commit e47b374ce4bec599f792d55ff9bcaa1f5322778c
Author: Tim Collier <osdevtc@gmail.com>
Date:   Fri Jul 6 20:38:14 2018 +0100

    staging: wlan-ng: fix expression continuation in prism2mgmt.c
    
    checkpatch reports "CHECK: Logical continuations should be on the
    previous line" when a continuation line begins with an
    operator. Reformat the code so that the operator appears at the end of
    the line being continued.
    
    Signed-off-by: Tim Collier <osdevtc@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/prism2mgmt.c b/drivers/staging/wlan-ng/prism2mgmt.c
index ebfe69b138c7..13fff7b19fb6 100644
--- a/drivers/staging/wlan-ng/prism2mgmt.c
+++ b/drivers/staging/wlan-ng/prism2mgmt.c
@@ -1269,9 +1269,8 @@ int prism2mgmt_wlansniff(struct wlandevice *wlandev, void *msgp)
 				goto failed;
 			}
 			if ((msg->keepwepflags.status ==
-			     P80211ENUM_msgitem_status_data_ok)
-			    && (msg->keepwepflags.data !=
-				P80211ENUM_truth_true)) {
+			     P80211ENUM_msgitem_status_data_ok) &&
+			    (msg->keepwepflags.data != P80211ENUM_truth_true)) {
 				/* Set the wepflags for no decryption */
 				word = HFA384x_WEPFLAGS_DISABLE_TXCRYPT |
 				    HFA384x_WEPFLAGS_DISABLE_RXCRYPT;
@@ -1291,8 +1290,9 @@ int prism2mgmt_wlansniff(struct wlandevice *wlandev, void *msgp)
 		}
 
 		/* Do we want to strip the FCS in monitor mode? */
-		if ((msg->stripfcs.status == P80211ENUM_msgitem_status_data_ok)
-		    && (msg->stripfcs.data == P80211ENUM_truth_true)) {
+		if ((msg->stripfcs.status ==
+		     P80211ENUM_msgitem_status_data_ok) &&
+		    (msg->stripfcs.data == P80211ENUM_truth_true)) {
 			hw->sniff_fcs = 0;
 		} else {
 			hw->sniff_fcs = 1;

commit 39b2ef70d6d37db595bb28b372efcf4cd03417b8
Author: Tim Collier <osdevtc@gmail.com>
Date:   Fri Jun 22 20:39:34 2018 +0100

    staging: wlan-ng: add parentheses to macro argument usage in prism2mgmt.c
    
    Fix two "CHECK: Macro argument 'N' may be better as '(N)' to avoid
    precedence issue" messages, reported by checkpatch, by adding
    parentheses around the offending macro argument references.
    
    Signed-off-by: Tim Collier <osdevtc@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/prism2mgmt.c b/drivers/staging/wlan-ng/prism2mgmt.c
index 28e4029d46f6..ebfe69b138c7 100644
--- a/drivers/staging/wlan-ng/prism2mgmt.c
+++ b/drivers/staging/wlan-ng/prism2mgmt.c
@@ -439,7 +439,7 @@ int prism2mgmt_scan_results(struct wlandevice *wlandev, void *msgp)
 
 #define REQBASICRATE(N) \
 	do { \
-		if ((count >= N) && DOT11_RATE5_ISBASIC_GET( \
+		if ((count >= (N)) && DOT11_RATE5_ISBASIC_GET(	\
 			item->supprates[(N) - 1])) { \
 			req->basicrate ## N .data = item->supprates[(N) - 1]; \
 			req->basicrate ## N .status = \
@@ -458,7 +458,7 @@ int prism2mgmt_scan_results(struct wlandevice *wlandev, void *msgp)
 
 #define REQSUPPRATE(N) \
 	do { \
-		if (count >= N) { \
+		if (count >= (N)) {					\
 			req->supprate ## N .data = item->supprates[(N) - 1]; \
 			req->supprate ## N .status = \
 				P80211ENUM_msgitem_status_data_ok; \

commit b2679009fa7def0772bff1af4b7579dc2d8ff442
Author: Tim Collier <osdevtc@gmail.com>
Date:   Fri Jun 22 20:39:33 2018 +0100

    staging: wlan-ng: replace macro with inline function in prism2mgmt.c
    
    checkpatch gives the following message for the p80211rate_to_p2bit
    macro:
    
    CHECK: Macro argument reuse 'n' - possible side-effects?
    
    To fix the message, replace the macro with an equivalent inline
    function.
    
    Signed-off-by: Tim Collier <osdevtc@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/prism2mgmt.c b/drivers/staging/wlan-ng/prism2mgmt.c
index d7de9e9c47a2..28e4029d46f6 100644
--- a/drivers/staging/wlan-ng/prism2mgmt.c
+++ b/drivers/staging/wlan-ng/prism2mgmt.c
@@ -85,10 +85,21 @@
 #include "prism2mgmt.h"
 
 /* Converts 802.11 format rate specifications to prism2 */
-#define p80211rate_to_p2bit(n)	((((n) & ~BIT(7)) == 2) ? BIT(0) :  \
-				 (((n) & ~BIT(7)) == 4) ? BIT(1) : \
-				 (((n) & ~BIT(7)) == 11) ? BIT(2) : \
-				 (((n) & ~BIT(7)) == 22) ? BIT(3) : 0)
+static inline u16 p80211rate_to_p2bit(u32 rate)
+{
+	switch (rate & ~BIT(7)) {
+	case 2:
+		return BIT(0);
+	case 4:
+		return BIT(1);
+	case 11:
+		return BIT(2);
+	case 22:
+		return BIT(3);
+	default:
+		return 0;
+	}
+}
 
 /*----------------------------------------------------------------
  * prism2mgmt_scan

commit beb7b033f4910b092d149d84c60ce49c0deb5935
Author: Yash Omer <yashomer0007@gmail.com>
Date:   Fri Feb 16 13:05:20 2018 +0530

    Staging: wlan-ng: fix unnecessary parantheses in prism2mgmt.c
    
    This patch fixes up a unncessary paratheses warning found by checkpatch.pl script.
    
    Signed-off-by: Yash Omer <yashomer0007@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/prism2mgmt.c b/drivers/staging/wlan-ng/prism2mgmt.c
index 78934e435fcf..d7de9e9c47a2 100644
--- a/drivers/staging/wlan-ng/prism2mgmt.c
+++ b/drivers/staging/wlan-ng/prism2mgmt.c
@@ -563,7 +563,7 @@ int prism2mgmt_start(struct wlandevice *wlandev, void *msgp)
 	/*** STATION ***/
 	/* Set the REQUIRED config items */
 	/* SSID */
-	pstr = (struct p80211pstrd *)&(msg->ssid.data);
+	pstr = (struct p80211pstrd *)&msg->ssid.data;
 	prism2mgmt_pstr2bytestr(p2bytestr, pstr);
 	result = hfa384x_drvr_setconfig(hw, HFA384x_RID_CNFOWNSSID,
 					bytebuf, HFA384x_RID_CNFOWNSSID_LEN);

commit f7056d335d919c15dc9ae26923969673da846e37
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Nov 7 21:07:51 2017 +0100

    staging: wlan-ng: add SPDX identifiers to all wlan-ng driver files
    
    It's good to have SPDX identifiers in all files to make it easier to
    audit the kernel tree for correct licenses.
    
    Update the wlan-ng driver files with the correct SPDX license identifier
    based on the license text in the file itself.  The SPDX identifier is a
    legally binding shorthand, which can be used instead of the full boiler
    plate text.
    
    This work is based on a script and data from Thomas Gleixner, Philippe
    Ombredanne, and Kate Stewart.
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: Philippe Ombredanne <pombredanne@nexb.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/prism2mgmt.c b/drivers/staging/wlan-ng/prism2mgmt.c
index 72070593394a..78934e435fcf 100644
--- a/drivers/staging/wlan-ng/prism2mgmt.c
+++ b/drivers/staging/wlan-ng/prism2mgmt.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: (GPL-2.0 OR MPL-1.1)
 /* src/prism2/driver/prism2mgmt.c
  *
  * Management request handler functions.

commit 0fb8997bac3d0b4643436e5adf20176d62c6137c
Author: Haneen Mohammed <hamohammed.sa@gmail.com>
Date:   Tue Sep 12 22:32:25 2017 -0600

    staging: wlan-ng: Replace pr_debug with netdev_dbg
    
    This patch replace pr_debug with netdev_dbg when appropriate net_device
    structure is found.
    Issue found using the following Coccinelle script:
    
    @r exists@
    identifier f, s, i;
    position p;
    @@
    
    f(...,struct s *i,...) {
    <+... when != i == NULL
    (
    pr_err@p(...);
    |
    pr_info@p(...);
    |
    pr_debug@p(...);
    )
    ...+>
    }
    
    @rr@
    identifier r.s, fld;
    @@
    
    struct s {
            ...
            struct net_device *fld;
            ... };
    
    @@
    identifier r.i, r.s, rr.fld;
    position r.p;
    @@
    (
    -pr_err@p
    +netdev_err
            (
    + i->fld,
    ...)
    |
    -pr_info@p
    +netdev_info
            (
    + i->fld,
    ...)
    |
    -pr_debug@p
    +netdev_dbg
            (
    + i->fld,
    ...)
    )
    
    Signed-off-by: Haneen Mohammed <hamohammed.sa@gmail.com>
    Acked-by: Julia Lawall <julia.lawall@lip6.fr>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/prism2mgmt.c b/drivers/staging/wlan-ng/prism2mgmt.c
index c4aa9e7e7003..72070593394a 100644
--- a/drivers/staging/wlan-ng/prism2mgmt.c
+++ b/drivers/staging/wlan-ng/prism2mgmt.c
@@ -394,8 +394,9 @@ int prism2mgmt_scan_results(struct wlandevice *wlandev, void *msgp)
 		count = HFA384x_SCANRESULT_MAX;
 
 	if (req->bssindex.data >= count) {
-		pr_debug("requested index (%d) out of range (%d)\n",
-			 req->bssindex.data, count);
+		netdev_dbg(wlandev->netdev,
+			   "requested index (%d) out of range (%d)\n",
+			   req->bssindex.data, count);
 		result = 2;
 		req->resultcode.data = P80211ENUM_resultcode_invalid_parameters;
 		goto exit;
@@ -684,7 +685,8 @@ int prism2mgmt_start(struct wlandevice *wlandev, void *msgp)
 
 	goto done;
 failed:
-	pr_debug("Failed to set a config option, result=%d\n", result);
+	netdev_dbg(wlandev->netdev,
+		   "Failed to set a config option, result=%d\n", result);
 	msg->resultcode.data = P80211ENUM_resultcode_invalid_parameters;
 
 done:
@@ -1120,15 +1122,17 @@ int prism2mgmt_wlansniff(struct wlandevice *wlandev, void *msgp)
 		/* Disable monitor mode */
 		result = hfa384x_cmd_monitor(hw, HFA384x_MONITOR_DISABLE);
 		if (result) {
-			pr_debug("failed to disable monitor mode, result=%d\n",
-				 result);
+			netdev_dbg(wlandev->netdev,
+				   "failed to disable monitor mode, result=%d\n",
+				   result);
 			goto failed;
 		}
 		/* Disable port 0 */
 		result = hfa384x_drvr_disable(hw, 0);
 		if (result) {
-			pr_debug
-			("failed to disable port 0 after sniffing, result=%d\n",
+			netdev_dbg
+			(wlandev->netdev,
+			     "failed to disable port 0 after sniffing, result=%d\n",
 			     result);
 			goto failed;
 		}
@@ -1140,8 +1144,9 @@ int prism2mgmt_wlansniff(struct wlandevice *wlandev, void *msgp)
 						  HFA384x_RID_CNFWEPFLAGS,
 						  hw->presniff_wepflags);
 		if (result) {
-			pr_debug
-			    ("failed to restore wepflags=0x%04x, result=%d\n",
+			netdev_dbg
+			    (wlandev->netdev,
+			     "failed to restore wepflags=0x%04x, result=%d\n",
 			     hw->presniff_wepflags, result);
 			goto failed;
 		}
@@ -1153,8 +1158,9 @@ int prism2mgmt_wlansniff(struct wlandevice *wlandev, void *msgp)
 						  HFA384x_RID_CNFPORTTYPE,
 						  word);
 			if (result) {
-				pr_debug
-				    ("failed to restore porttype, result=%d\n",
+				netdev_dbg
+				    (wlandev->netdev,
+				     "failed to restore porttype, result=%d\n",
 				     result);
 				goto failed;
 			}
@@ -1162,8 +1168,9 @@ int prism2mgmt_wlansniff(struct wlandevice *wlandev, void *msgp)
 			/* Enable the port */
 			result = hfa384x_drvr_enable(hw, 0);
 			if (result) {
-				pr_debug("failed to enable port to presniff setting, result=%d\n",
-					 result);
+				netdev_dbg(wlandev->netdev,
+					   "failed to enable port to presniff setting, result=%d\n",
+					   result);
 				goto failed;
 			}
 		} else {
@@ -1182,8 +1189,9 @@ int prism2mgmt_wlansniff(struct wlandevice *wlandev, void *msgp)
 						  HFA384x_RID_CNFPORTTYPE,
 						  &(hw->presniff_port_type));
 				if (result) {
-					pr_debug
-					("failed to read porttype, result=%d\n",
+					netdev_dbg
+					(wlandev->netdev,
+					     "failed to read porttype, result=%d\n",
 					     result);
 					goto failed;
 				}
@@ -1192,24 +1200,27 @@ int prism2mgmt_wlansniff(struct wlandevice *wlandev, void *msgp)
 						  HFA384x_RID_CNFWEPFLAGS,
 						  &(hw->presniff_wepflags));
 				if (result) {
-					pr_debug
-					("failed to read wepflags, result=%d\n",
+					netdev_dbg
+					(wlandev->netdev,
+					     "failed to read wepflags, result=%d\n",
 					     result);
 					goto failed;
 				}
 				hfa384x_drvr_stop(hw);
 				result = hfa384x_drvr_start(hw);
 				if (result) {
-					pr_debug("failed to restart the card for sniffing, result=%d\n",
-						 result);
+					netdev_dbg(wlandev->netdev,
+						   "failed to restart the card for sniffing, result=%d\n",
+						   result);
 					goto failed;
 				}
 			} else {
 				/* Disable the port */
 				result = hfa384x_drvr_disable(hw, 0);
 				if (result) {
-					pr_debug("failed to enable port for sniffing, result=%d\n",
-						 result);
+					netdev_dbg(wlandev->netdev,
+						   "failed to enable port for sniffing, result=%d\n",
+						   result);
 					goto failed;
 				}
 			}
@@ -1225,8 +1236,9 @@ int prism2mgmt_wlansniff(struct wlandevice *wlandev, void *msgp)
 		hw->sniff_channel = word;
 
 		if (result) {
-			pr_debug("failed to set channel %d, result=%d\n",
-				 word, result);
+			netdev_dbg(wlandev->netdev,
+				   "failed to set channel %d, result=%d\n",
+				   word, result);
 			goto failed;
 		}
 
@@ -1238,8 +1250,9 @@ int prism2mgmt_wlansniff(struct wlandevice *wlandev, void *msgp)
 						  HFA384x_RID_CNFPORTTYPE,
 						  word);
 			if (result) {
-				pr_debug
-				    ("failed to set porttype %d, result=%d\n",
+				netdev_dbg
+				    (wlandev->netdev,
+				     "failed to set porttype %d, result=%d\n",
 				     word, result);
 				goto failed;
 			}
@@ -1257,8 +1270,9 @@ int prism2mgmt_wlansniff(struct wlandevice *wlandev, void *msgp)
 			}
 
 			if (result) {
-				pr_debug
-				  ("failed to set wepflags=0x%04x, result=%d\n",
+				netdev_dbg
+				  (wlandev->netdev,
+				   "failed to set wepflags=0x%04x, result=%d\n",
 				   word, result);
 				goto failed;
 			}
@@ -1283,16 +1297,18 @@ int prism2mgmt_wlansniff(struct wlandevice *wlandev, void *msgp)
 		/* Enable the port */
 		result = hfa384x_drvr_enable(hw, 0);
 		if (result) {
-			pr_debug
-			    ("failed to enable port for sniffing, result=%d\n",
+			netdev_dbg
+			    (wlandev->netdev,
+			     "failed to enable port for sniffing, result=%d\n",
 			     result);
 			goto failed;
 		}
 		/* Enable monitor mode */
 		result = hfa384x_cmd_monitor(hw, HFA384x_MONITOR_ENABLE);
 		if (result) {
-			pr_debug("failed to enable monitor mode, result=%d\n",
-				 result);
+			netdev_dbg(wlandev->netdev,
+				   "failed to enable monitor mode, result=%d\n",
+				   result);
 			goto failed;
 		}
 

commit 18cd9021ea035db85519391dbc429a5b1d0dd25b
Author: Suniel Mahesh <sunil.m@techveda.org>
Date:   Fri Jun 16 11:01:45 2017 +0530

    staging: wlan-ng: Fix struct definition's and variable type
    
    le16_to_cpu() accepts argument of type __le16 and cpu_to_le16()
    returns an argument of type __le16. This patch fixes:
    (a) the type of the variable that end's up getting return from
        cpu_to_le16().
    (b) the member types of struct hfa384x_host_scan_request_data,
        struct hfa384x_bytestr32 and struct hfa384x_hscan_result_sub.
    
    The following type mismatch warnings reported by sparse
    have been fixed:
    warning: incorrect type in assignment (different base types)
    warning: cast to restricted __le16
    
    Signed-off-by: Suniel Mahesh <sunil.m@techveda.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/prism2mgmt.c b/drivers/staging/wlan-ng/prism2mgmt.c
index f4d6e4849987..c4aa9e7e7003 100644
--- a/drivers/staging/wlan-ng/prism2mgmt.c
+++ b/drivers/staging/wlan-ng/prism2mgmt.c
@@ -213,7 +213,7 @@ int prism2mgmt_scan(struct wlandevice *wlandev, void *msgp)
 		goto exit;
 	}
 	if (word == HFA384x_PORTSTATUS_DISABLED) {
-		u16 wordbuf[17];
+		__le16 wordbuf[17];
 
 		result = hfa384x_drvr_setconfig16(hw,
 					HFA384x_RID_CNFROAMINGMODE,

commit dea20579a69ab68cdca6adf79bb7c0c162eb9b72
Author: Andrea della Porta <sfaragnaus@gmail.com>
Date:   Sat Apr 29 07:30:23 2017 +0100

    staging: wlan-ng: prism2mgmt.c: fixed a double endian conversion before calling hfa384x_drvr_setconfig16, also fixes relative sparse warning
    
    staging: wlan-ng: prism2mgmt.c: This patches fixes a double endian conversion.
    cpu_to_le16() was called twice first in prism2mgmt_scan and again inside
    hfa384x_drvr_setconfig16() for the same variable, hence it was swapped
    twice. Incidentally, it also fixed the following sparse warning:
    
    drivers/staging/wlan-ng/prism2mgmt.c:173:30: warning: incorrect type in assignment (different base types)
    drivers/staging/wlan-ng/prism2mgmt.c:173:30:    expected unsigned short [unsigned] [usertype] word
    drivers/staging/wlan-ng/prism2mgmt.c:173:30:    got restricted __le16 [usertype] <noident>
    
    Unfortunately, only compile tested.
    
    Signed-off-by: Andrea della Porta <sfaragnaus@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/prism2mgmt.c b/drivers/staging/wlan-ng/prism2mgmt.c
index e23a0d0e7b09..f4d6e4849987 100644
--- a/drivers/staging/wlan-ng/prism2mgmt.c
+++ b/drivers/staging/wlan-ng/prism2mgmt.c
@@ -170,7 +170,7 @@ int prism2mgmt_scan(struct wlandevice *wlandev, void *msgp)
 				     hw->ident_sta_fw.variant) >
 	    HFA384x_FIRMWARE_VERSION(1, 5, 0)) {
 		if (msg->scantype.data != P80211ENUM_scantype_active)
-			word = cpu_to_le16(msg->maxchanneltime.data);
+			word = msg->maxchanneltime.data;
 		else
 			word = 0;
 

commit c519822a8a7d480ecc1b5bb67b80ba73e747c4a4
Author: Georgios Emmanouil <geo.emmnl@gmail.com>
Date:   Thu Feb 16 22:13:32 2017 +0200

    Staging: wlan-ng: prism2mgmt: Removed an empty line
    
    Removed an empty line.
    
    Signed-off-by: Georgios Emmanouil <geo.emmnl@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/prism2mgmt.c b/drivers/staging/wlan-ng/prism2mgmt.c
index 0e671c3b308d..e23a0d0e7b09 100644
--- a/drivers/staging/wlan-ng/prism2mgmt.c
+++ b/drivers/staging/wlan-ng/prism2mgmt.c
@@ -1168,7 +1168,6 @@ int prism2mgmt_wlansniff(struct wlandevice *wlandev, void *msgp)
 			}
 		} else {
 			result = hfa384x_drvr_disable(hw, 0);
-
 		}
 
 		netdev_info(wlandev->netdev, "monitor mode disabled\n");

commit 55dd5a39a982dad9a39fe48a1c0066f46a8a0ba0
Author: Frans Klaver <fransklaver@gmail.com>
Date:   Thu Feb 9 22:58:21 2017 +0100

    staging: wlan_ng: fix logical continuation alignment
    
    It appears that our coding style prefers that logical continuations
    have the operator at the end of the line. Fix that.
    
    While at it, stick the 'if' after 'else' where it belongs.
    
    Signed-off-by: Frans Klaver <fransklaver@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/prism2mgmt.c b/drivers/staging/wlan-ng/prism2mgmt.c
index c558ad656c49..0e671c3b308d 100644
--- a/drivers/staging/wlan-ng/prism2mgmt.c
+++ b/drivers/staging/wlan-ng/prism2mgmt.c
@@ -1303,14 +1303,13 @@ int prism2mgmt_wlansniff(struct wlandevice *wlandev, void *msgp)
 		/* Set the driver state */
 		/* Do we want the prism2 header? */
 		if ((msg->prismheader.status ==
-		     P80211ENUM_msgitem_status_data_ok)
-		    && (msg->prismheader.data == P80211ENUM_truth_true)) {
+		     P80211ENUM_msgitem_status_data_ok) &&
+		    (msg->prismheader.data == P80211ENUM_truth_true)) {
 			hw->sniffhdr = 0;
 			wlandev->netdev->type = ARPHRD_IEEE80211_PRISM;
-		} else
-		    if ((msg->wlanheader.status ==
-			 P80211ENUM_msgitem_status_data_ok)
-			&& (msg->wlanheader.data == P80211ENUM_truth_true)) {
+		} else if ((msg->wlanheader.status ==
+			    P80211ENUM_msgitem_status_data_ok) &&
+			   (msg->wlanheader.data == P80211ENUM_truth_true)) {
 			hw->sniffhdr = 1;
 			wlandev->netdev->type = ARPHRD_IEEE80211_PRISM;
 		} else {

commit 536e973cd76cf0c840fd30216e3a816885f4d11f
Author: Shiva Kerdel <shiva@exdev.nl>
Date:   Fri Nov 18 14:12:42 2016 +0100

    Staging: wlan-ng: prism2mgmt: Fixed operators spacing style issues
    
    Fixed spaces around operators to fix their coding style issues.
    
    Signed-off-by: Shiva Kerdel <shiva@exdev.nl>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/prism2mgmt.c b/drivers/staging/wlan-ng/prism2mgmt.c
index 16fb2d3e0f51..c558ad656c49 100644
--- a/drivers/staging/wlan-ng/prism2mgmt.c
+++ b/drivers/staging/wlan-ng/prism2mgmt.c
@@ -84,10 +84,10 @@
 #include "prism2mgmt.h"
 
 /* Converts 802.11 format rate specifications to prism2 */
-#define p80211rate_to_p2bit(n)	((((n)&~BIT(7)) == 2) ? BIT(0) :  \
-				 (((n)&~BIT(7)) == 4) ? BIT(1) : \
-				 (((n)&~BIT(7)) == 11) ? BIT(2) : \
-				 (((n)&~BIT(7)) == 22) ? BIT(3) : 0)
+#define p80211rate_to_p2bit(n)	((((n) & ~BIT(7)) == 2) ? BIT(0) :  \
+				 (((n) & ~BIT(7)) == 4) ? BIT(1) : \
+				 (((n) & ~BIT(7)) == 11) ? BIT(2) : \
+				 (((n) & ~BIT(7)) == 22) ? BIT(3) : 0)
 
 /*----------------------------------------------------------------
  * prism2mgmt_scan
@@ -427,8 +427,8 @@ int prism2mgmt_scan_results(struct wlandevice *wlandev, void *msgp)
 #define REQBASICRATE(N) \
 	do { \
 		if ((count >= N) && DOT11_RATE5_ISBASIC_GET( \
-			item->supprates[(N)-1])) { \
-			req->basicrate ## N .data = item->supprates[(N)-1]; \
+			item->supprates[(N) - 1])) { \
+			req->basicrate ## N .data = item->supprates[(N) - 1]; \
 			req->basicrate ## N .status = \
 				P80211ENUM_msgitem_status_data_ok; \
 		} \
@@ -446,7 +446,7 @@ int prism2mgmt_scan_results(struct wlandevice *wlandev, void *msgp)
 #define REQSUPPRATE(N) \
 	do { \
 		if (count >= N) { \
-			req->supprate ## N .data = item->supprates[(N)-1]; \
+			req->supprate ## N .data = item->supprates[(N) - 1]; \
 			req->supprate ## N .status = \
 				P80211ENUM_msgitem_status_data_ok; \
 		} \

commit e0e6964805c6427f2c07b5a52820c0163de74010
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Wed Oct 19 17:51:30 2016 +0200

    staging: wlan-ng: Replace data type declaration with variable of same type in prism2mgmt.c
    
    sizeof(var) instead of sizeof(struct XXX) is preferred.
    
    It also fix the following checkpatch.pl script warning:
    WARNING: line over 80 characters
    
    Fix this two in prism2mgmt.c file.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/prism2mgmt.c b/drivers/staging/wlan-ng/prism2mgmt.c
index f63704a54073..16fb2d3e0f51 100644
--- a/drivers/staging/wlan-ng/prism2mgmt.c
+++ b/drivers/staging/wlan-ng/prism2mgmt.c
@@ -293,7 +293,7 @@ int prism2mgmt_scan(struct wlandevice *wlandev, void *msgp)
 
 	result = hfa384x_drvr_setconfig(hw,
 					HFA384x_RID_HOSTSCAN, &scanreq,
-					sizeof(struct hfa384x_host_scan_request_data));
+					sizeof(scanreq));
 	if (result) {
 		netdev_err(wlandev->netdev,
 			   "setconfig(SCANREQUEST) failed. result=%d\n",

commit 8f8149de8c8ed370d516b8660f6fd9880bba0be6
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Wed Oct 19 17:59:18 2016 +0200

    staging: wlan-ng: avoid CamelCase: hfa384x_HScanResultSub
    
    Replace CamelCase struct name with underscores to comply
    with the standard kernel coding style.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/prism2mgmt.c b/drivers/staging/wlan-ng/prism2mgmt.c
index 3a56308332cc..f63704a54073 100644
--- a/drivers/staging/wlan-ng/prism2mgmt.c
+++ b/drivers/staging/wlan-ng/prism2mgmt.c
@@ -373,7 +373,7 @@ int prism2mgmt_scan_results(struct wlandevice *wlandev, void *msgp)
 	int result = 0;
 	struct p80211msg_dot11req_scan_results *req;
 	struct hfa384x *hw = wlandev->priv;
-	struct hfa384x_HScanResultSub *item = NULL;
+	struct hfa384x_hscan_result_sub *item = NULL;
 
 	int count;
 

commit e474b4d4ea6970d3762155c26fb70d3c04450ba6
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Wed Oct 19 17:59:13 2016 +0200

    staging: wlan-ng: avoid CamelCase: hfa384x_HostScanRequest_data
    
    Replace CamelCase struct name and fields with underscores to comply
    with the standard kernel coding style.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/prism2mgmt.c b/drivers/staging/wlan-ng/prism2mgmt.c
index 8be3a74c5419..3a56308332cc 100644
--- a/drivers/staging/wlan-ng/prism2mgmt.c
+++ b/drivers/staging/wlan-ng/prism2mgmt.c
@@ -123,7 +123,7 @@ int prism2mgmt_scan(struct wlandevice *wlandev, void *msgp)
 	int i, timeout;
 	int istmpenable = 0;
 
-	struct hfa384x_HostScanRequest_data scanreq;
+	struct hfa384x_host_scan_request_data scanreq;
 
 	/* gatekeeper check */
 	if (HFA384x_FIRMWARE_VERSION(hw->ident_sta_fw.major,
@@ -185,7 +185,7 @@ int prism2mgmt_scan(struct wlandevice *wlandev, void *msgp)
 
 	/* set up the txrate to be 2MBPS. Should be fastest basicrate... */
 	word = HFA384x_RATEBIT_2;
-	scanreq.txRate = cpu_to_le16(word);
+	scanreq.tx_rate = cpu_to_le16(word);
 
 	/* set up the channel list */
 	word = 0;
@@ -197,7 +197,7 @@ int prism2mgmt_scan(struct wlandevice *wlandev, void *msgp)
 		/* channel 1 is BIT 0 ... channel 14 is BIT 13 */
 		word |= (1 << (channel - 1));
 	}
-	scanreq.channelList = cpu_to_le16(word);
+	scanreq.channel_list = cpu_to_le16(word);
 
 	/* set up the ssid, if present. */
 	scanreq.ssid.len = cpu_to_le16(msg->ssid.data.len);
@@ -293,7 +293,7 @@ int prism2mgmt_scan(struct wlandevice *wlandev, void *msgp)
 
 	result = hfa384x_drvr_setconfig(hw,
 					HFA384x_RID_HOSTSCAN, &scanreq,
-					sizeof(struct hfa384x_HostScanRequest_data));
+					sizeof(struct hfa384x_host_scan_request_data));
 	if (result) {
 		netdev_err(wlandev->netdev,
 			   "setconfig(SCANREQUEST) failed. result=%d\n",

commit b937612f9d0d4586c18a42f9bb7d1623a08d7d13
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Wed Oct 19 17:59:12 2016 +0200

    staging: wlan-ng: avoid CamelCase: HFA384x_RID_CNFAPBCNint
    
    Replace CamelCase define to comply with the standard kernel coding style.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/prism2mgmt.c b/drivers/staging/wlan-ng/prism2mgmt.c
index 90db53dc7196..8be3a74c5419 100644
--- a/drivers/staging/wlan-ng/prism2mgmt.c
+++ b/drivers/staging/wlan-ng/prism2mgmt.c
@@ -583,7 +583,7 @@ int prism2mgmt_start(struct wlandevice *wlandev, void *msgp)
 
 	/* beacon period */
 	word = msg->beaconperiod.data;
-	result = hfa384x_drvr_setconfig16(hw, HFA384x_RID_CNFAPBCNint, word);
+	result = hfa384x_drvr_setconfig16(hw, HFA384x_RID_CNFAPBCNINT, word);
 	if (result) {
 		netdev_err(wlandev->netdev,
 			   "Failed to set beacon period=%d.\n", word);

commit 01fe9c92dff8b0e0f291dc8254e4bd652fa00f0f
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Sun Oct 9 17:10:28 2016 +0200

    staging: wlan-ng: fix block comment warnings in prism2mgmt.c
    
    This patch fix the following checkpatch.pl warnings in prism2mgmt.c:
    WARNING: Block comments should align the * on each line
    WARNING: Block comments use a trailing */ on a separate line
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/prism2mgmt.c b/drivers/staging/wlan-ng/prism2mgmt.c
index 170de1c9eac4..90db53dc7196 100644
--- a/drivers/staging/wlan-ng/prism2mgmt.c
+++ b/drivers/staging/wlan-ng/prism2mgmt.c
@@ -1,61 +1,61 @@
 /* src/prism2/driver/prism2mgmt.c
-*
-* Management request handler functions.
-*
-* Copyright (C) 1999 AbsoluteValue Systems, Inc.  All Rights Reserved.
-* --------------------------------------------------------------------
-*
-* linux-wlan
-*
-*   The contents of this file are subject to the Mozilla Public
-*   License Version 1.1 (the "License"); you may not use this file
-*   except in compliance with the License. You may obtain a copy of
-*   the License at http://www.mozilla.org/MPL/
-*
-*   Software distributed under the License is distributed on an "AS
-*   IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
-*   implied. See the License for the specific language governing
-*   rights and limitations under the License.
-*
-*   Alternatively, the contents of this file may be used under the
-*   terms of the GNU Public License version 2 (the "GPL"), in which
-*   case the provisions of the GPL are applicable instead of the
-*   above.  If you wish to allow the use of your version of this file
-*   only under the terms of the GPL and not to allow others to use
-*   your version of this file under the MPL, indicate your decision
-*   by deleting the provisions above and replace them with the notice
-*   and other provisions required by the GPL.  If you do not delete
-*   the provisions above, a recipient may use your version of this
-*   file under either the MPL or the GPL.
-*
-* --------------------------------------------------------------------
-*
-* Inquiries regarding the linux-wlan Open Source project can be
-* made directly to:
-*
-* AbsoluteValue Systems Inc.
-* info@linux-wlan.com
-* http://www.linux-wlan.com
-*
-* --------------------------------------------------------------------
-*
-* Portions of the development of this software were funded by
-* Intersil Corporation as part of PRISM(R) chipset product development.
-*
-* --------------------------------------------------------------------
-*
-* The functions in this file handle management requests sent from
-* user mode.
-*
-* Most of these functions have two separate blocks of code that are
-* conditional on whether this is a station or an AP.  This is used
-* to separate out the STA and AP responses to these management primitives.
-* It's a choice (good, bad, indifferent?) to have the code in the same
-* place so it's clear that the same primitive is implemented in both
-* cases but has different behavior.
-*
-* --------------------------------------------------------------------
-*/
+ *
+ * Management request handler functions.
+ *
+ * Copyright (C) 1999 AbsoluteValue Systems, Inc.  All Rights Reserved.
+ * --------------------------------------------------------------------
+ *
+ * linux-wlan
+ *
+ *   The contents of this file are subject to the Mozilla Public
+ *   License Version 1.1 (the "License"); you may not use this file
+ *   except in compliance with the License. You may obtain a copy of
+ *   the License at http://www.mozilla.org/MPL/
+ *
+ *   Software distributed under the License is distributed on an "AS
+ *   IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ *   implied. See the License for the specific language governing
+ *   rights and limitations under the License.
+ *
+ *   Alternatively, the contents of this file may be used under the
+ *   terms of the GNU Public License version 2 (the "GPL"), in which
+ *   case the provisions of the GPL are applicable instead of the
+ *   above.  If you wish to allow the use of your version of this file
+ *   only under the terms of the GPL and not to allow others to use
+ *   your version of this file under the MPL, indicate your decision
+ *   by deleting the provisions above and replace them with the notice
+ *   and other provisions required by the GPL.  If you do not delete
+ *   the provisions above, a recipient may use your version of this
+ *   file under either the MPL or the GPL.
+ *
+ * --------------------------------------------------------------------
+ *
+ * Inquiries regarding the linux-wlan Open Source project can be
+ * made directly to:
+ *
+ * AbsoluteValue Systems Inc.
+ * info@linux-wlan.com
+ * http://www.linux-wlan.com
+ *
+ * --------------------------------------------------------------------
+ *
+ * Portions of the development of this software were funded by
+ * Intersil Corporation as part of PRISM(R) chipset product development.
+ *
+ * --------------------------------------------------------------------
+ *
+ * The functions in this file handle management requests sent from
+ * user mode.
+ *
+ * Most of these functions have two separate blocks of code that are
+ * conditional on whether this is a station or an AP.  This is used
+ * to separate out the STA and AP responses to these management primitives.
+ * It's a choice (good, bad, indifferent?) to have the code in the same
+ * place so it's clear that the same primitive is implemented in both
+ * cases but has different behavior.
+ *
+ * --------------------------------------------------------------------
+ */
 
 #include <linux/if_arp.h>
 #include <linux/module.h>
@@ -90,29 +90,30 @@
 				 (((n)&~BIT(7)) == 22) ? BIT(3) : 0)
 
 /*----------------------------------------------------------------
-* prism2mgmt_scan
-*
-* Initiate a scan for BSSs.
-*
-* This function corresponds to MLME-scan.request and part of
-* MLME-scan.confirm.  As far as I can tell in the standard, there
-* are no restrictions on when a scan.request may be issued.  We have
-* to handle in whatever state the driver/MAC happen to be.
-*
-* Arguments:
-*	wlandev		wlan device structure
-*	msgp		ptr to msg buffer
-*
-* Returns:
-*	0	success and done
-*	<0	success, but we're waiting for something to finish.
-*	>0	an error occurred while handling the message.
-* Side effects:
-*
-* Call context:
-*	process thread  (usually)
-*	interrupt
-----------------------------------------------------------------*/
+ * prism2mgmt_scan
+ *
+ * Initiate a scan for BSSs.
+ *
+ * This function corresponds to MLME-scan.request and part of
+ * MLME-scan.confirm.  As far as I can tell in the standard, there
+ * are no restrictions on when a scan.request may be issued.  We have
+ * to handle in whatever state the driver/MAC happen to be.
+ *
+ * Arguments:
+ *	wlandev		wlan device structure
+ *	msgp		ptr to msg buffer
+ *
+ * Returns:
+ *	0	success and done
+ *	<0	success, but we're waiting for something to finish.
+ *	>0	an error occurred while handling the message.
+ * Side effects:
+ *
+ * Call context:
+ *	process thread  (usually)
+ *	interrupt
+ *----------------------------------------------------------------
+ */
 int prism2mgmt_scan(struct wlandevice *wlandev, void *msgp)
 {
 	int result = 0;
@@ -347,25 +348,26 @@ int prism2mgmt_scan(struct wlandevice *wlandev, void *msgp)
 }
 
 /*----------------------------------------------------------------
-* prism2mgmt_scan_results
-*
-* Retrieve the BSS description for one of the BSSs identified in
-* a scan.
-*
-* Arguments:
-*	wlandev		wlan device structure
-*	msgp		ptr to msg buffer
-*
-* Returns:
-*	0	success and done
-*	<0	success, but we're waiting for something to finish.
-*	>0	an error occurred while handling the message.
-* Side effects:
-*
-* Call context:
-*	process thread  (usually)
-*	interrupt
-----------------------------------------------------------------*/
+ * prism2mgmt_scan_results
+ *
+ * Retrieve the BSS description for one of the BSSs identified in
+ * a scan.
+ *
+ * Arguments:
+ *	wlandev		wlan device structure
+ *	msgp		ptr to msg buffer
+ *
+ * Returns:
+ *	0	success and done
+ *	<0	success, but we're waiting for something to finish.
+ *	>0	an error occurred while handling the message.
+ * Side effects:
+ *
+ * Call context:
+ *	process thread  (usually)
+ *	interrupt
+ *----------------------------------------------------------------
+ */
 int prism2mgmt_scan_results(struct wlandevice *wlandev, void *msgp)
 {
 	int result = 0;
@@ -507,24 +509,25 @@ int prism2mgmt_scan_results(struct wlandevice *wlandev, void *msgp)
 }
 
 /*----------------------------------------------------------------
-* prism2mgmt_start
-*
-* Start a BSS.  Any station can do this for IBSS, only AP for ESS.
-*
-* Arguments:
-*	wlandev		wlan device structure
-*	msgp		ptr to msg buffer
-*
-* Returns:
-*	0	success and done
-*	<0	success, but we're waiting for something to finish.
-*	>0	an error occurred while handling the message.
-* Side effects:
-*
-* Call context:
-*	process thread  (usually)
-*	interrupt
-----------------------------------------------------------------*/
+ * prism2mgmt_start
+ *
+ * Start a BSS.  Any station can do this for IBSS, only AP for ESS.
+ *
+ * Arguments:
+ *	wlandev		wlan device structure
+ *	msgp		ptr to msg buffer
+ *
+ * Returns:
+ *	0	success and done
+ *	<0	success, but we're waiting for something to finish.
+ *	>0	an error occurred while handling the message.
+ * Side effects:
+ *
+ * Call context:
+ *	process thread  (usually)
+ *	interrupt
+ *----------------------------------------------------------------
+ */
 int prism2mgmt_start(struct wlandevice *wlandev, void *msgp)
 {
 	int result = 0;
@@ -689,23 +692,24 @@ int prism2mgmt_start(struct wlandevice *wlandev, void *msgp)
 }
 
 /*----------------------------------------------------------------
-* prism2mgmt_readpda
-*
-* Collect the PDA data and put it in the message.
-*
-* Arguments:
-*	wlandev		wlan device structure
-*	msgp		ptr to msg buffer
-*
-* Returns:
-*	0	success and done
-*	<0	success, but we're waiting for something to finish.
-*	>0	an error occurred while handling the message.
-* Side effects:
-*
-* Call context:
-*	process thread  (usually)
-----------------------------------------------------------------*/
+ * prism2mgmt_readpda
+ *
+ * Collect the PDA data and put it in the message.
+ *
+ * Arguments:
+ *	wlandev		wlan device structure
+ *	msgp		ptr to msg buffer
+ *
+ * Returns:
+ *	0	success and done
+ *	<0	success, but we're waiting for something to finish.
+ *	>0	an error occurred while handling the message.
+ * Side effects:
+ *
+ * Call context:
+ *	process thread  (usually)
+ *----------------------------------------------------------------
+ */
 int prism2mgmt_readpda(struct wlandevice *wlandev, void *msgp)
 {
 	struct hfa384x *hw = wlandev->priv;
@@ -748,30 +752,31 @@ int prism2mgmt_readpda(struct wlandevice *wlandev, void *msgp)
 }
 
 /*----------------------------------------------------------------
-* prism2mgmt_ramdl_state
-*
-* Establishes the beginning/end of a card RAM download session.
-*
-* It is expected that the ramdl_write() function will be called
-* one or more times between the 'enable' and 'disable' calls to
-* this function.
-*
-* Note: This function should not be called when a mac comm port
-*       is active.
-*
-* Arguments:
-*	wlandev		wlan device structure
-*	msgp		ptr to msg buffer
-*
-* Returns:
-*	0	success and done
-*	<0	success, but we're waiting for something to finish.
-*	>0	an error occurred while handling the message.
-* Side effects:
-*
-* Call context:
-*	process thread  (usually)
-----------------------------------------------------------------*/
+ * prism2mgmt_ramdl_state
+ *
+ * Establishes the beginning/end of a card RAM download session.
+ *
+ * It is expected that the ramdl_write() function will be called
+ * one or more times between the 'enable' and 'disable' calls to
+ * this function.
+ *
+ * Note: This function should not be called when a mac comm port
+ *       is active.
+ *
+ * Arguments:
+ *	wlandev		wlan device structure
+ *	msgp		ptr to msg buffer
+ *
+ * Returns:
+ *	0	success and done
+ *	<0	success, but we're waiting for something to finish.
+ *	>0	an error occurred while handling the message.
+ * Side effects:
+ *
+ * Call context:
+ *	process thread  (usually)
+ *----------------------------------------------------------------
+ */
 int prism2mgmt_ramdl_state(struct wlandevice *wlandev, void *msgp)
 {
 	struct hfa384x *hw = wlandev->priv;
@@ -808,25 +813,26 @@ int prism2mgmt_ramdl_state(struct wlandevice *wlandev, void *msgp)
 }
 
 /*----------------------------------------------------------------
-* prism2mgmt_ramdl_write
-*
-* Writes a buffer to the card RAM using the download state.  This
-* is for writing code to card RAM.  To just read or write raw data
-* use the aux functions.
-*
-* Arguments:
-*	wlandev		wlan device structure
-*	msgp		ptr to msg buffer
-*
-* Returns:
-*	0	success and done
-*	<0	success, but we're waiting for something to finish.
-*	>0	an error occurred while handling the message.
-* Side effects:
-*
-* Call context:
-*	process thread  (usually)
-----------------------------------------------------------------*/
+ * prism2mgmt_ramdl_write
+ *
+ * Writes a buffer to the card RAM using the download state.  This
+ * is for writing code to card RAM.  To just read or write raw data
+ * use the aux functions.
+ *
+ * Arguments:
+ *	wlandev		wlan device structure
+ *	msgp		ptr to msg buffer
+ *
+ * Returns:
+ *	0	success and done
+ *	<0	success, but we're waiting for something to finish.
+ *	>0	an error occurred while handling the message.
+ * Side effects:
+ *
+ * Call context:
+ *	process thread  (usually)
+ *----------------------------------------------------------------
+ */
 int prism2mgmt_ramdl_write(struct wlandevice *wlandev, void *msgp)
 {
 	struct hfa384x *hw = wlandev->priv;
@@ -864,30 +870,31 @@ int prism2mgmt_ramdl_write(struct wlandevice *wlandev, void *msgp)
 }
 
 /*----------------------------------------------------------------
-* prism2mgmt_flashdl_state
-*
-* Establishes the beginning/end of a card Flash download session.
-*
-* It is expected that the flashdl_write() function will be called
-* one or more times between the 'enable' and 'disable' calls to
-* this function.
-*
-* Note: This function should not be called when a mac comm port
-*       is active.
-*
-* Arguments:
-*	wlandev		wlan device structure
-*	msgp		ptr to msg buffer
-*
-* Returns:
-*	0	success and done
-*	<0	success, but we're waiting for something to finish.
-*	>0	an error occurred while handling the message.
-* Side effects:
-*
-* Call context:
-*	process thread  (usually)
-----------------------------------------------------------------*/
+ * prism2mgmt_flashdl_state
+ *
+ * Establishes the beginning/end of a card Flash download session.
+ *
+ * It is expected that the flashdl_write() function will be called
+ * one or more times between the 'enable' and 'disable' calls to
+ * this function.
+ *
+ * Note: This function should not be called when a mac comm port
+ *       is active.
+ *
+ * Arguments:
+ *	wlandev		wlan device structure
+ *	msgp		ptr to msg buffer
+ *
+ * Returns:
+ *	0	success and done
+ *	<0	success, but we're waiting for something to finish.
+ *	>0	an error occurred while handling the message.
+ * Side effects:
+ *
+ * Call context:
+ *	process thread  (usually)
+ *----------------------------------------------------------------
+ */
 int prism2mgmt_flashdl_state(struct wlandevice *wlandev, void *msgp)
 {
 	int result = 0;
@@ -942,23 +949,24 @@ int prism2mgmt_flashdl_state(struct wlandevice *wlandev, void *msgp)
 }
 
 /*----------------------------------------------------------------
-* prism2mgmt_flashdl_write
-*
-*
-*
-* Arguments:
-*	wlandev		wlan device structure
-*	msgp		ptr to msg buffer
-*
-* Returns:
-*	0	success and done
-*	<0	success, but we're waiting for something to finish.
-*	>0	an error occurred while handling the message.
-* Side effects:
-*
-* Call context:
-*	process thread  (usually)
-----------------------------------------------------------------*/
+ * prism2mgmt_flashdl_write
+ *
+ *
+ *
+ * Arguments:
+ *	wlandev		wlan device structure
+ *	msgp		ptr to msg buffer
+ *
+ * Returns:
+ *	0	success and done
+ *	<0	success, but we're waiting for something to finish.
+ *	>0	an error occurred while handling the message.
+ * Side effects:
+ *
+ * Call context:
+ *	process thread  (usually)
+ *----------------------------------------------------------------
+ */
 int prism2mgmt_flashdl_write(struct wlandevice *wlandev, void *msgp)
 {
 	struct hfa384x *hw = wlandev->priv;
@@ -1001,24 +1009,25 @@ int prism2mgmt_flashdl_write(struct wlandevice *wlandev, void *msgp)
 }
 
 /*----------------------------------------------------------------
-* prism2mgmt_autojoin
-*
-* Associate with an ESS.
-*
-* Arguments:
-*	wlandev		wlan device structure
-*	msgp		ptr to msg buffer
-*
-* Returns:
-*	0	success and done
-*	<0	success, but we're waiting for something to finish.
-*	>0	an error occurred while handling the message.
-* Side effects:
-*
-* Call context:
-*	process thread  (usually)
-*	interrupt
-----------------------------------------------------------------*/
+ * prism2mgmt_autojoin
+ *
+ * Associate with an ESS.
+ *
+ * Arguments:
+ *	wlandev		wlan device structure
+ *	msgp		ptr to msg buffer
+ *
+ * Returns:
+ *	0	success and done
+ *	<0	success, but we're waiting for something to finish.
+ *	>0	an error occurred while handling the message.
+ * Side effects:
+ *
+ * Call context:
+ *	process thread  (usually)
+ *	interrupt
+ *----------------------------------------------------------------
+ */
 int prism2mgmt_autojoin(struct wlandevice *wlandev, void *msgp)
 {
 	struct hfa384x *hw = wlandev->priv;
@@ -1072,24 +1081,25 @@ int prism2mgmt_autojoin(struct wlandevice *wlandev, void *msgp)
 }
 
 /*----------------------------------------------------------------
-* prism2mgmt_wlansniff
-*
-* Start or stop sniffing.
-*
-* Arguments:
-*	wlandev		wlan device structure
-*	msgp		ptr to msg buffer
-*
-* Returns:
-*	0	success and done
-*	<0	success, but we're waiting for something to finish.
-*	>0	an error occurred while handling the message.
-* Side effects:
-*
-* Call context:
-*	process thread  (usually)
-*	interrupt
-----------------------------------------------------------------*/
+ * prism2mgmt_wlansniff
+ *
+ * Start or stop sniffing.
+ *
+ * Arguments:
+ *	wlandev		wlan device structure
+ *	msgp		ptr to msg buffer
+ *
+ * Returns:
+ *	0	success and done
+ *	<0	success, but we're waiting for something to finish.
+ *	>0	an error occurred while handling the message.
+ * Side effects:
+ *
+ * Call context:
+ *	process thread  (usually)
+ *	interrupt
+ *----------------------------------------------------------------
+ */
 int prism2mgmt_wlansniff(struct wlandevice *wlandev, void *msgp)
 {
 	int result = 0;

commit 5a2214e2e02fd24874b68ac7f5b07ad4d7ad1813
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Wed Sep 28 20:20:19 2016 +0200

    staging: wlang-ng: avoid new typedef: hfa384x_t
    
    This patch fixes the following checkpatch.pl warning in hfa384x.h:
    WARNING: do not add new typedefs
    
    It applies for typedef hfa384x_t
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/prism2mgmt.c b/drivers/staging/wlan-ng/prism2mgmt.c
index 1780875170a0..170de1c9eac4 100644
--- a/drivers/staging/wlan-ng/prism2mgmt.c
+++ b/drivers/staging/wlan-ng/prism2mgmt.c
@@ -116,7 +116,7 @@
 int prism2mgmt_scan(struct wlandevice *wlandev, void *msgp)
 {
 	int result = 0;
-	hfa384x_t *hw = wlandev->priv;
+	struct hfa384x *hw = wlandev->priv;
 	struct p80211msg_dot11req_scan *msg = msgp;
 	u16 roamingmode, word;
 	int i, timeout;
@@ -370,7 +370,7 @@ int prism2mgmt_scan_results(struct wlandevice *wlandev, void *msgp)
 {
 	int result = 0;
 	struct p80211msg_dot11req_scan_results *req;
-	hfa384x_t *hw = wlandev->priv;
+	struct hfa384x *hw = wlandev->priv;
 	struct hfa384x_HScanResultSub *item = NULL;
 
 	int count;
@@ -528,7 +528,7 @@ int prism2mgmt_scan_results(struct wlandevice *wlandev, void *msgp)
 int prism2mgmt_start(struct wlandevice *wlandev, void *msgp)
 {
 	int result = 0;
-	hfa384x_t *hw = wlandev->priv;
+	struct hfa384x *hw = wlandev->priv;
 	struct p80211msg_dot11req_start *msg = msgp;
 
 	struct p80211pstrd *pstr;
@@ -708,7 +708,7 @@ int prism2mgmt_start(struct wlandevice *wlandev, void *msgp)
 ----------------------------------------------------------------*/
 int prism2mgmt_readpda(struct wlandevice *wlandev, void *msgp)
 {
-	hfa384x_t *hw = wlandev->priv;
+	struct hfa384x *hw = wlandev->priv;
 	struct p80211msg_p2req_readpda *msg = msgp;
 	int result;
 
@@ -774,7 +774,7 @@ int prism2mgmt_readpda(struct wlandevice *wlandev, void *msgp)
 ----------------------------------------------------------------*/
 int prism2mgmt_ramdl_state(struct wlandevice *wlandev, void *msgp)
 {
-	hfa384x_t *hw = wlandev->priv;
+	struct hfa384x *hw = wlandev->priv;
 	struct p80211msg_p2req_ramdl_state *msg = msgp;
 
 	if (wlandev->msdstate != WLAN_MSD_FWLOAD) {
@@ -829,7 +829,7 @@ int prism2mgmt_ramdl_state(struct wlandevice *wlandev, void *msgp)
 ----------------------------------------------------------------*/
 int prism2mgmt_ramdl_write(struct wlandevice *wlandev, void *msgp)
 {
-	hfa384x_t *hw = wlandev->priv;
+	struct hfa384x *hw = wlandev->priv;
 	struct p80211msg_p2req_ramdl_write *msg = msgp;
 	u32 addr;
 	u32 len;
@@ -891,7 +891,7 @@ int prism2mgmt_ramdl_write(struct wlandevice *wlandev, void *msgp)
 int prism2mgmt_flashdl_state(struct wlandevice *wlandev, void *msgp)
 {
 	int result = 0;
-	hfa384x_t *hw = wlandev->priv;
+	struct hfa384x *hw = wlandev->priv;
 	struct p80211msg_p2req_flashdl_state *msg = msgp;
 
 	if (wlandev->msdstate != WLAN_MSD_FWLOAD) {
@@ -961,7 +961,7 @@ int prism2mgmt_flashdl_state(struct wlandevice *wlandev, void *msgp)
 ----------------------------------------------------------------*/
 int prism2mgmt_flashdl_write(struct wlandevice *wlandev, void *msgp)
 {
-	hfa384x_t *hw = wlandev->priv;
+	struct hfa384x *hw = wlandev->priv;
 	struct p80211msg_p2req_flashdl_write *msg = msgp;
 	u32 addr;
 	u32 len;
@@ -1021,7 +1021,7 @@ int prism2mgmt_flashdl_write(struct wlandevice *wlandev, void *msgp)
 ----------------------------------------------------------------*/
 int prism2mgmt_autojoin(struct wlandevice *wlandev, void *msgp)
 {
-	hfa384x_t *hw = wlandev->priv;
+	struct hfa384x *hw = wlandev->priv;
 	int result = 0;
 	u16 reg;
 	u16 port_type;
@@ -1095,7 +1095,7 @@ int prism2mgmt_wlansniff(struct wlandevice *wlandev, void *msgp)
 	int result = 0;
 	struct p80211msg_lnxreq_wlansniff *msg = msgp;
 
-	hfa384x_t *hw = wlandev->priv;
+	struct hfa384x *hw = wlandev->priv;
 	u16 word;
 
 	msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;

commit b353d11af9a07fbdfe4f98a466bb26405d5aacbb
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Wed Sep 28 20:19:13 2016 +0200

    staging: wlang-ng: avoid new typedef: hfa384x_HScanResultSub_t
    
    This patch fixes the following checkpatch.pl warning in hfa384x.h:
    WARNING: do not add new typedefs
    
    It applies for typedef hfa384x_HScanResultSub_t
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/prism2mgmt.c b/drivers/staging/wlan-ng/prism2mgmt.c
index 1a98d690804f..1780875170a0 100644
--- a/drivers/staging/wlan-ng/prism2mgmt.c
+++ b/drivers/staging/wlan-ng/prism2mgmt.c
@@ -371,7 +371,7 @@ int prism2mgmt_scan_results(struct wlandevice *wlandev, void *msgp)
 	int result = 0;
 	struct p80211msg_dot11req_scan_results *req;
 	hfa384x_t *hw = wlandev->priv;
-	hfa384x_HScanResultSub_t *item = NULL;
+	struct hfa384x_HScanResultSub *item = NULL;
 
 	int count;
 

commit 935cbfb2bd16404c908c0902fa493939d6190de2
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Wed Sep 28 20:18:58 2016 +0200

    staging: wlang-ng: avoid new typedef: hfa384x_HostScanRequest_data_t
    
    This patch fixes the following checkpatch.pl warning in hfa384x.h:
    WARNING: do not add new typedefs
    
    It applies for typedef hfa384x_HostScanRequest_data_t
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/prism2mgmt.c b/drivers/staging/wlan-ng/prism2mgmt.c
index 5e5d0ab1ceee..1a98d690804f 100644
--- a/drivers/staging/wlan-ng/prism2mgmt.c
+++ b/drivers/staging/wlan-ng/prism2mgmt.c
@@ -122,7 +122,7 @@ int prism2mgmt_scan(struct wlandevice *wlandev, void *msgp)
 	int i, timeout;
 	int istmpenable = 0;
 
-	hfa384x_HostScanRequest_data_t scanreq;
+	struct hfa384x_HostScanRequest_data scanreq;
 
 	/* gatekeeper check */
 	if (HFA384x_FIRMWARE_VERSION(hw->ident_sta_fw.major,
@@ -292,7 +292,7 @@ int prism2mgmt_scan(struct wlandevice *wlandev, void *msgp)
 
 	result = hfa384x_drvr_setconfig(hw,
 					HFA384x_RID_HOSTSCAN, &scanreq,
-					sizeof(hfa384x_HostScanRequest_data_t));
+					sizeof(struct hfa384x_HostScanRequest_data));
 	if (result) {
 		netdev_err(wlandev->netdev,
 			   "setconfig(SCANREQUEST) failed. result=%d\n",

commit 3fd1e3fcb929e6b51598f76cfc0615259b8cfe54
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Sun Sep 25 15:34:52 2016 +0200

    staging: wlan-ng: avoid new typedef: p80211pstrd_t
    
    This patch fixes the following checkpatch.pl warning in p80211types.h:
    WARNING: do not add new typedefs
    
    It applies for typedef p80211pstrd_t
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/prism2mgmt.c b/drivers/staging/wlan-ng/prism2mgmt.c
index f6f48d9c6f82..5e5d0ab1ceee 100644
--- a/drivers/staging/wlan-ng/prism2mgmt.c
+++ b/drivers/staging/wlan-ng/prism2mgmt.c
@@ -531,7 +531,7 @@ int prism2mgmt_start(struct wlandevice *wlandev, void *msgp)
 	hfa384x_t *hw = wlandev->priv;
 	struct p80211msg_dot11req_start *msg = msgp;
 
-	p80211pstrd_t *pstr;
+	struct p80211pstrd *pstr;
 	u8 bytebuf[80];
 	struct hfa384x_bytestr *p2bytestr = (struct hfa384x_bytestr *)bytebuf;
 	u16 word;
@@ -558,7 +558,7 @@ int prism2mgmt_start(struct wlandevice *wlandev, void *msgp)
 	/*** STATION ***/
 	/* Set the REQUIRED config items */
 	/* SSID */
-	pstr = (p80211pstrd_t *)&(msg->ssid.data);
+	pstr = (struct p80211pstrd *)&(msg->ssid.data);
 	prism2mgmt_pstr2bytestr(p2bytestr, pstr);
 	result = hfa384x_drvr_setconfig(hw, HFA384x_RID_CNFOWNSSID,
 					bytebuf, HFA384x_RID_CNFOWNSSID_LEN);
@@ -1026,7 +1026,7 @@ int prism2mgmt_autojoin(struct wlandevice *wlandev, void *msgp)
 	u16 reg;
 	u16 port_type;
 	struct p80211msg_lnxreq_autojoin *msg = msgp;
-	p80211pstrd_t *pstr;
+	struct p80211pstrd *pstr;
 	u8 bytebuf[256];
 	struct hfa384x_bytestr *p2bytestr = (struct hfa384x_bytestr *)bytebuf;
 
@@ -1052,7 +1052,7 @@ int prism2mgmt_autojoin(struct wlandevice *wlandev, void *msgp)
 
 	/* Set the ssid */
 	memset(bytebuf, 0, 256);
-	pstr = (p80211pstrd_t *)&(msg->ssid.data);
+	pstr = (struct p80211pstrd *)&(msg->ssid.data);
 	prism2mgmt_pstr2bytestr(p2bytestr, pstr);
 	result = hfa384x_drvr_setconfig(hw, HFA384x_RID_CNFDESIREDSSID,
 					bytebuf,

commit 0e21fa4602078160e03ef210c983df0c257ccbe8
Author: Jannik Becher <becher.jannik@gmail.com>
Date:   Fri Sep 23 01:02:10 2016 +0200

    staging: wlan-ng: remove unnecessary spaces before casts
    
    Fixed a coding style issue by removing unnecessary spaces before casts.
    
    Signed-off-by: Jannik Becher <Becher.Jannik@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/prism2mgmt.c b/drivers/staging/wlan-ng/prism2mgmt.c
index b380c7d119a7..f6f48d9c6f82 100644
--- a/drivers/staging/wlan-ng/prism2mgmt.c
+++ b/drivers/staging/wlan-ng/prism2mgmt.c
@@ -533,7 +533,7 @@ int prism2mgmt_start(struct wlandevice *wlandev, void *msgp)
 
 	p80211pstrd_t *pstr;
 	u8 bytebuf[80];
-	struct hfa384x_bytestr *p2bytestr = (struct hfa384x_bytestr *) bytebuf;
+	struct hfa384x_bytestr *p2bytestr = (struct hfa384x_bytestr *)bytebuf;
 	u16 word;
 
 	wlandev->macmode = WLAN_MACMODE_NONE;
@@ -558,7 +558,7 @@ int prism2mgmt_start(struct wlandevice *wlandev, void *msgp)
 	/*** STATION ***/
 	/* Set the REQUIRED config items */
 	/* SSID */
-	pstr = (p80211pstrd_t *) &(msg->ssid.data);
+	pstr = (p80211pstrd_t *)&(msg->ssid.data);
 	prism2mgmt_pstr2bytestr(p2bytestr, pstr);
 	result = hfa384x_drvr_setconfig(hw, HFA384x_RID_CNFOWNSSID,
 					bytebuf, HFA384x_RID_CNFOWNSSID_LEN);
@@ -1028,7 +1028,7 @@ int prism2mgmt_autojoin(struct wlandevice *wlandev, void *msgp)
 	struct p80211msg_lnxreq_autojoin *msg = msgp;
 	p80211pstrd_t *pstr;
 	u8 bytebuf[256];
-	struct hfa384x_bytestr *p2bytestr = (struct hfa384x_bytestr *) bytebuf;
+	struct hfa384x_bytestr *p2bytestr = (struct hfa384x_bytestr *)bytebuf;
 
 	wlandev->macmode = WLAN_MACMODE_NONE;
 
@@ -1052,7 +1052,7 @@ int prism2mgmt_autojoin(struct wlandevice *wlandev, void *msgp)
 
 	/* Set the ssid */
 	memset(bytebuf, 0, 256);
-	pstr = (p80211pstrd_t *) &(msg->ssid.data);
+	pstr = (p80211pstrd_t *)&(msg->ssid.data);
 	prism2mgmt_pstr2bytestr(p2bytestr, pstr);
 	result = hfa384x_drvr_setconfig(hw, HFA384x_RID_CNFDESIREDSSID,
 					bytebuf,

commit f4353ee3d3af22641beb99a146ef136f33952e80
Author: Rehas Sachdeva <aquannie@gmail.com>
Date:   Tue Sep 20 01:05:54 2016 +0530

    staging: wlan-ng: Remove unnecessary variable usage
    
    Instead of storing the return value into a variable and then returning it, we
    can club the two into a single return statement. This change was made using
    the following semantic patch by Coccinelle:
    
    @@
    local idexpression ret;
    expression e;
    @@
    
    -ret =
    +return
         e;
    -return ret;
    
    Signed-off-by: Rehas Sachdeva <aquannie@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/prism2mgmt.c b/drivers/staging/wlan-ng/prism2mgmt.c
index 73ea1277d08b..b380c7d119a7 100644
--- a/drivers/staging/wlan-ng/prism2mgmt.c
+++ b/drivers/staging/wlan-ng/prism2mgmt.c
@@ -685,9 +685,7 @@ int prism2mgmt_start(struct wlandevice *wlandev, void *msgp)
 	msg->resultcode.data = P80211ENUM_resultcode_invalid_parameters;
 
 done:
-	result = 0;
-
-	return result;
+	return 0;
 }
 
 /*----------------------------------------------------------------

commit c9573a8d1963ba82f163c4d113266da82c048c21
Author: sayli karnik <karniksayli1995@gmail.com>
Date:   Sun Sep 18 15:11:14 2016 +0530

    staging: wlan-ng: Remove the typedef to the 'wlandevice' structure
    
    This patch removes the typedef 'wlandevice_t' to the 'wlandevice'
    structure.
    
    Signed-off-by: sayli karnik <karniksayli1995@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/prism2mgmt.c b/drivers/staging/wlan-ng/prism2mgmt.c
index d8ed9a05789c..73ea1277d08b 100644
--- a/drivers/staging/wlan-ng/prism2mgmt.c
+++ b/drivers/staging/wlan-ng/prism2mgmt.c
@@ -113,7 +113,7 @@
 *	process thread  (usually)
 *	interrupt
 ----------------------------------------------------------------*/
-int prism2mgmt_scan(wlandevice_t *wlandev, void *msgp)
+int prism2mgmt_scan(struct wlandevice *wlandev, void *msgp)
 {
 	int result = 0;
 	hfa384x_t *hw = wlandev->priv;
@@ -366,7 +366,7 @@ int prism2mgmt_scan(wlandevice_t *wlandev, void *msgp)
 *	process thread  (usually)
 *	interrupt
 ----------------------------------------------------------------*/
-int prism2mgmt_scan_results(wlandevice_t *wlandev, void *msgp)
+int prism2mgmt_scan_results(struct wlandevice *wlandev, void *msgp)
 {
 	int result = 0;
 	struct p80211msg_dot11req_scan_results *req;
@@ -525,7 +525,7 @@ int prism2mgmt_scan_results(wlandevice_t *wlandev, void *msgp)
 *	process thread  (usually)
 *	interrupt
 ----------------------------------------------------------------*/
-int prism2mgmt_start(wlandevice_t *wlandev, void *msgp)
+int prism2mgmt_start(struct wlandevice *wlandev, void *msgp)
 {
 	int result = 0;
 	hfa384x_t *hw = wlandev->priv;
@@ -708,7 +708,7 @@ int prism2mgmt_start(wlandevice_t *wlandev, void *msgp)
 * Call context:
 *	process thread  (usually)
 ----------------------------------------------------------------*/
-int prism2mgmt_readpda(wlandevice_t *wlandev, void *msgp)
+int prism2mgmt_readpda(struct wlandevice *wlandev, void *msgp)
 {
 	hfa384x_t *hw = wlandev->priv;
 	struct p80211msg_p2req_readpda *msg = msgp;
@@ -774,7 +774,7 @@ int prism2mgmt_readpda(wlandevice_t *wlandev, void *msgp)
 * Call context:
 *	process thread  (usually)
 ----------------------------------------------------------------*/
-int prism2mgmt_ramdl_state(wlandevice_t *wlandev, void *msgp)
+int prism2mgmt_ramdl_state(struct wlandevice *wlandev, void *msgp)
 {
 	hfa384x_t *hw = wlandev->priv;
 	struct p80211msg_p2req_ramdl_state *msg = msgp;
@@ -829,7 +829,7 @@ int prism2mgmt_ramdl_state(wlandevice_t *wlandev, void *msgp)
 * Call context:
 *	process thread  (usually)
 ----------------------------------------------------------------*/
-int prism2mgmt_ramdl_write(wlandevice_t *wlandev, void *msgp)
+int prism2mgmt_ramdl_write(struct wlandevice *wlandev, void *msgp)
 {
 	hfa384x_t *hw = wlandev->priv;
 	struct p80211msg_p2req_ramdl_write *msg = msgp;
@@ -890,7 +890,7 @@ int prism2mgmt_ramdl_write(wlandevice_t *wlandev, void *msgp)
 * Call context:
 *	process thread  (usually)
 ----------------------------------------------------------------*/
-int prism2mgmt_flashdl_state(wlandevice_t *wlandev, void *msgp)
+int prism2mgmt_flashdl_state(struct wlandevice *wlandev, void *msgp)
 {
 	int result = 0;
 	hfa384x_t *hw = wlandev->priv;
@@ -961,7 +961,7 @@ int prism2mgmt_flashdl_state(wlandevice_t *wlandev, void *msgp)
 * Call context:
 *	process thread  (usually)
 ----------------------------------------------------------------*/
-int prism2mgmt_flashdl_write(wlandevice_t *wlandev, void *msgp)
+int prism2mgmt_flashdl_write(struct wlandevice *wlandev, void *msgp)
 {
 	hfa384x_t *hw = wlandev->priv;
 	struct p80211msg_p2req_flashdl_write *msg = msgp;
@@ -1021,7 +1021,7 @@ int prism2mgmt_flashdl_write(wlandevice_t *wlandev, void *msgp)
 *	process thread  (usually)
 *	interrupt
 ----------------------------------------------------------------*/
-int prism2mgmt_autojoin(wlandevice_t *wlandev, void *msgp)
+int prism2mgmt_autojoin(struct wlandevice *wlandev, void *msgp)
 {
 	hfa384x_t *hw = wlandev->priv;
 	int result = 0;
@@ -1092,7 +1092,7 @@ int prism2mgmt_autojoin(wlandevice_t *wlandev, void *msgp)
 *	process thread  (usually)
 *	interrupt
 ----------------------------------------------------------------*/
-int prism2mgmt_wlansniff(wlandevice_t *wlandev, void *msgp)
+int prism2mgmt_wlansniff(struct wlandevice *wlandev, void *msgp)
 {
 	int result = 0;
 	struct p80211msg_lnxreq_wlansniff *msg = msgp;

commit 3cfcb95c72cf165176ddf66693747a7a7918182c
Author: Janani Ravichandran <janani.rvchndrn@gmail.com>
Date:   Thu Feb 25 14:22:27 2016 -0500

    staging: wlan-ng: prism2mgmt.c: Drop void pointer cast
    
    Void pointers don't need to be cast to other pointer types.
    Semantic patch used:
    
    @r@
    expression x;
    void* e;
    type T;
    identifier f;
    @@
    
    (
      *((T *)e)
    |
      ((T *)x) [...]
    |
      ((T *)x)->f
    |
    - (T *)
      e
    )
    
    Signed-off-by: Janani Ravichandran <janani.rvchndrn@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/prism2mgmt.c b/drivers/staging/wlan-ng/prism2mgmt.c
index 013a6240f193..d8ed9a05789c 100644
--- a/drivers/staging/wlan-ng/prism2mgmt.c
+++ b/drivers/staging/wlan-ng/prism2mgmt.c
@@ -375,7 +375,7 @@ int prism2mgmt_scan_results(wlandevice_t *wlandev, void *msgp)
 
 	int count;
 
-	req = (struct p80211msg_dot11req_scan_results *) msgp;
+	req = msgp;
 
 	req->resultcode.status = P80211ENUM_msgitem_status_data_ok;
 

commit 230fa11f5fab094512b6ad131ae1de86b12466f2
Author: Jeshwanth Kumar N K <jeshkumar555@gmail.com>
Date:   Fri Aug 15 01:41:04 2014 +0530

    staging: wlan-ng: prism2mgmt.c Fix break not useful
    
    Fixed up warnings, break is not useful after return statement.
    And the exit Label is deleted, now returning inline.
    
    Signed-off-by: Jeshwanth Kumar N K <jeshkumar555@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/prism2mgmt.c b/drivers/staging/wlan-ng/prism2mgmt.c
index e6a82d3303c1..013a6240f193 100644
--- a/drivers/staging/wlan-ng/prism2mgmt.c
+++ b/drivers/staging/wlan-ng/prism2mgmt.c
@@ -1107,8 +1107,7 @@ int prism2mgmt_wlansniff(wlandevice_t *wlandev, void *msgp)
 		if (wlandev->netdev->type == ARPHRD_ETHER) {
 			msg->resultcode.data =
 			    P80211ENUM_resultcode_invalid_parameters;
-			result = 0;
-			goto exit;
+			return 0;
 		}
 		/* Disable monitor mode */
 		result = hfa384x_cmd_monitor(hw, HFA384x_MONITOR_DISABLE);
@@ -1166,9 +1165,7 @@ int prism2mgmt_wlansniff(wlandevice_t *wlandev, void *msgp)
 
 		netdev_info(wlandev->netdev, "monitor mode disabled\n");
 		msg->resultcode.data = P80211ENUM_resultcode_success;
-		result = 0;
-		goto exit;
-		break;
+		return 0;
 	case P80211ENUM_truth_true:
 		/* Disable the port (if enabled), only check Port 0 */
 		if (hw->port_enabled[0]) {
@@ -1313,19 +1310,13 @@ int prism2mgmt_wlansniff(wlandevice_t *wlandev, void *msgp)
 		}
 
 		msg->resultcode.data = P80211ENUM_resultcode_success;
-		result = 0;
-		goto exit;
-		break;
+		return 0;
 	default:
 		msg->resultcode.data = P80211ENUM_resultcode_invalid_parameters;
-		result = 0;
-		goto exit;
-		break;
+		return 0;
 	}
 
 failed:
 	msg->resultcode.data = P80211ENUM_resultcode_refused;
-	result = 0;
-exit:
-	return result;
+	return 0;
 }

commit 5d9c8d51c8d65dc050917b076ecb60bf99296992
Author: Johannes Stadlinger <Johannes.Stadlinger@fau.de>
Date:   Thu Jun 19 21:20:15 2014 +0200

    wlan-ng/prism2mgmt:checkpatch: Insert blank line
    
    This patch inserts a blank line after a declaration to avoid checkpatch
    warning.
    
    Signed-off-by: Johannes Stadlinger <Johannes.Stadlinger@fau.de>
    Signed-off-by: Maximilian Eschenbacher <maximilian@eschenbacher.email>
    CC: linux-kernel@i4.cs.fau.de
    Meh-by: Josh Triplett <josh@joshtriplett.org>
    CC: Himangi Saraogi <himangi774@gmail.com>
    CC: Vitaly Osipov <vitaly.osipov@gmail.com>
    CC: devel@driverdev.osuosl.org
    CC: linux-kernel@vger.kernel.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/prism2mgmt.c b/drivers/staging/wlan-ng/prism2mgmt.c
index f90f7da41d68..e6a82d3303c1 100644
--- a/drivers/staging/wlan-ng/prism2mgmt.c
+++ b/drivers/staging/wlan-ng/prism2mgmt.c
@@ -190,6 +190,7 @@ int prism2mgmt_scan(wlandevice_t *wlandev, void *msgp)
 	word = 0;
 	for (i = 0; i < msg->channellist.data.len; i++) {
 		u8 channel = msg->channellist.data.data[i];
+
 		if (channel > 14)
 			continue;
 		/* channel 1 is BIT 0 ... channel 14 is BIT 13 */

commit 17b375461672dc3cc4d495d838a9c93e6c8c9ed3
Author: Johannes Stadlinger <Johannes.Stadlinger@fau.de>
Date:   Thu Jun 19 21:20:14 2014 +0200

    wlan-ng/prism2mgmt:checkpatch: Fix string split
    
    This patch fixes all warnings of checkpatch about string splitting.
    
    Signed-off-by: Johannes Stadlinger <Johannes.Stadlinger@fau.de>
    Signed-off-by: Maximilian Eschenbacher <maximilian@eschenbacher.email>
    CC: linux-kernel@i4.cs.fau.de
    CC: Himangi Saraogi <himangi774@gmail.com>
    CC: Vitaly Osipov <vitaly.osipov@gmail.com>
    CC: devel@driverdev.osuosl.org
    CC: linux-kernel@vger.kernel.org
    Reviewed-by: Josh Triplett <josh@joshtriplett.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/prism2mgmt.c b/drivers/staging/wlan-ng/prism2mgmt.c
index 36a3e1a946d1..f90f7da41d68 100644
--- a/drivers/staging/wlan-ng/prism2mgmt.c
+++ b/drivers/staging/wlan-ng/prism2mgmt.c
@@ -178,8 +178,7 @@ int prism2mgmt_scan(wlandevice_t *wlandev, void *msgp)
 					     word);
 		if (result) {
 			netdev_warn(wlandev->netdev,
-				    "Passive scan not supported with "
-				    "current firmware.  (<1.5.1)\n");
+				    "Passive scan not supported with current firmware.  (<1.5.1)\n");
 		}
 	}
 
@@ -381,8 +380,7 @@ int prism2mgmt_scan_results(wlandevice_t *wlandev, void *msgp)
 
 	if (!hw->scanresults) {
 		netdev_err(wlandev->netdev,
-			   "dot11req_scan_results can only be used after "
-			   "a successful dot11req_scan.\n");
+			   "dot11req_scan_results can only be used after a successful dot11req_scan.\n");
 		result = 2;
 		req->resultcode.data = P80211ENUM_resultcode_invalid_parameters;
 		goto exit;
@@ -733,8 +731,8 @@ int prism2mgmt_readpda(wlandevice_t *wlandev, void *msgp)
 					      HFA384x_PDA_LEN_MAX);
 		if (result) {
 			netdev_err(wlandev->netdev,
-				   "hfa384x_drvr_readpda() failed, "
-				   "result=%d\n", result);
+				   "hfa384x_drvr_readpda() failed, result=%d\n",
+				   result);
 
 			msg->resultcode.data =
 			    P80211ENUM_resultcode_implementation_failure;
@@ -782,8 +780,7 @@ int prism2mgmt_ramdl_state(wlandevice_t *wlandev, void *msgp)
 
 	if (wlandev->msdstate != WLAN_MSD_FWLOAD) {
 		netdev_err(wlandev->netdev,
-			   "ramdl_state(): may only be called "
-			   "in the fwload state.\n");
+			   "ramdl_state(): may only be called in the fwload state.\n");
 		msg->resultcode.data =
 		    P80211ENUM_resultcode_implementation_failure;
 		msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;
@@ -841,8 +838,7 @@ int prism2mgmt_ramdl_write(wlandevice_t *wlandev, void *msgp)
 
 	if (wlandev->msdstate != WLAN_MSD_FWLOAD) {
 		netdev_err(wlandev->netdev,
-			   "ramdl_write(): may only be called "
-			   "in the fwload state.\n");
+			   "ramdl_write(): may only be called in the fwload state.\n");
 		msg->resultcode.data =
 		    P80211ENUM_resultcode_implementation_failure;
 		msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;
@@ -901,8 +897,7 @@ int prism2mgmt_flashdl_state(wlandevice_t *wlandev, void *msgp)
 
 	if (wlandev->msdstate != WLAN_MSD_FWLOAD) {
 		netdev_err(wlandev->netdev,
-			   "flashdl_state(): may only be called "
-			   "in the fwload state.\n");
+			   "flashdl_state(): may only be called in the fwload state.\n");
 		msg->resultcode.data =
 		    P80211ENUM_resultcode_implementation_failure;
 		msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;
@@ -936,8 +931,8 @@ int prism2mgmt_flashdl_state(wlandevice_t *wlandev, void *msgp)
 		result = prism2sta_ifstate(wlandev, P80211ENUM_ifstate_fwload);
 		if (result != P80211ENUM_resultcode_success) {
 			netdev_err(wlandev->netdev,
-				   "prism2sta_ifstate(fwload) failed,"
-				   "P80211ENUM_resultcode=%d\n", result);
+				   "prism2sta_ifstate(fwload) failed, P80211ENUM_resultcode=%d\n",
+				   result);
 			msg->resultcode.data =
 			    P80211ENUM_resultcode_implementation_failure;
 			result = -1;
@@ -975,8 +970,7 @@ int prism2mgmt_flashdl_write(wlandevice_t *wlandev, void *msgp)
 
 	if (wlandev->msdstate != WLAN_MSD_FWLOAD) {
 		netdev_err(wlandev->netdev,
-			   "flashdl_write(): may only be called "
-			   "in the fwload state.\n");
+			   "flashdl_write(): may only be called in the fwload state.\n");
 		msg->resultcode.data =
 		    P80211ENUM_resultcode_implementation_failure;
 		msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;

commit 2cf1ba40c6efb8654fa650efdec4d0773e1c8492
Author: Johannes Stadlinger <Johannes.Stadlinger@fau.de>
Date:   Thu Jun 19 21:20:13 2014 +0200

    wlan-ng/prism2mgmt:checkpatch: Fix long lines
    
    This patch fixes all warnings of checkpatch about lines over 80
    characters.
    
    Signed-off-by: Johannes Stadlinger <Johannes.Stadlinger@fau.de>
    Signed-off-by: Maximilian Eschenbacher <maximilian@eschenbacher.email>
    CC: linux-kernel@i4.cs.fau.de
    CC: Himangi Saraogi <himangi774@gmail.com>
    CC: Vitaly Osipov <vitaly.osipov@gmail.com>
    CC: devel@driverdev.osuosl.org
    CC: linux-kernel@vger.kernel.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/prism2mgmt.c b/drivers/staging/wlan-ng/prism2mgmt.c
index d110b362c3bd..36a3e1a946d1 100644
--- a/drivers/staging/wlan-ng/prism2mgmt.c
+++ b/drivers/staging/wlan-ng/prism2mgmt.c
@@ -156,7 +156,8 @@ int prism2mgmt_scan(wlandevice_t *wlandev, void *msgp)
 					  HFA384x_ROAMMODE_HOSTSCAN_HOSTROAM);
 	if (result) {
 		netdev_err(wlandev->netdev,
-			   "setconfig(ROAMINGMODE) failed. result=%d\n", result);
+			   "setconfig(ROAMINGMODE) failed. result=%d\n",
+			   result);
 		msg->resultcode.data =
 		    P80211ENUM_resultcode_implementation_failure;
 		goto exit;
@@ -273,7 +274,8 @@ int prism2mgmt_scan(wlandevice_t *wlandev, void *msgp)
 		result = hfa384x_drvr_enable(hw, 0);
 		if (result) {
 			netdev_err(wlandev->netdev,
-				   "drvr_enable(0) failed. result=%d\n", result);
+				   "drvr_enable(0) failed. result=%d\n",
+				   result);
 			msg->resultcode.data =
 			    P80211ENUM_resultcode_implementation_failure;
 			goto exit;
@@ -293,7 +295,8 @@ int prism2mgmt_scan(wlandevice_t *wlandev, void *msgp)
 					sizeof(hfa384x_HostScanRequest_data_t));
 	if (result) {
 		netdev_err(wlandev->netdev,
-			   "setconfig(SCANREQUEST) failed. result=%d\n", result);
+			   "setconfig(SCANREQUEST) failed. result=%d\n",
+			   result);
 		msg->resultcode.data =
 		    P80211ENUM_resultcode_implementation_failure;
 		goto exit;
@@ -315,7 +318,8 @@ int prism2mgmt_scan(wlandevice_t *wlandev, void *msgp)
 		result = hfa384x_drvr_disable(hw, 0);
 		if (result) {
 			netdev_err(wlandev->netdev,
-				   "drvr_disable(0) failed. result=%d\n", result);
+				   "drvr_disable(0) failed. result=%d\n",
+				   result);
 			msg->resultcode.data =
 			    P80211ENUM_resultcode_implementation_failure;
 			goto exit;
@@ -654,7 +658,8 @@ int prism2mgmt_start(wlandevice_t *wlandev, void *msgp)
 
 	result = hfa384x_drvr_setconfig16(hw, HFA384x_RID_TXRATECNTL, word);
 	if (result) {
-		netdev_err(wlandev->netdev, "Failed to set txrates=%d.\n", word);
+		netdev_err(wlandev->netdev, "Failed to set txrates=%d.\n",
+			   word);
 		goto failed;
 	}
 

commit 02d9b1eb4b21b9309efdf8c8aee023a59d3f76e0
Author: Vitaly Osipov <vitaly.osipov@gmail.com>
Date:   Sun May 18 16:59:36 2014 +1000

    staging: wlan-ng: use netdev_() instead of printk()
    
    Replaced all uses of printk() in wlan-ng with netdev_err / _warn
    where a netdev exists. If a few cases where a netdev does not yet
    exist, dev_ or pr_ was used.
    
    Checkpatch complains about lines over 80 chars or split string
    constants - the messages are just too long, keeping it completely
    happy would make the code less readable.
    
    Signed-off-by: Vitaly Osipov <vitaly.osipov@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/prism2mgmt.c b/drivers/staging/wlan-ng/prism2mgmt.c
index a9909f6b0001..d110b362c3bd 100644
--- a/drivers/staging/wlan-ng/prism2mgmt.c
+++ b/drivers/staging/wlan-ng/prism2mgmt.c
@@ -129,8 +129,8 @@ int prism2mgmt_scan(wlandevice_t *wlandev, void *msgp)
 				     hw->ident_sta_fw.minor,
 				     hw->ident_sta_fw.variant) <
 	    HFA384x_FIRMWARE_VERSION(1, 3, 2)) {
-		printk(KERN_ERR
-		       "HostScan not supported with current firmware (<1.3.2).\n");
+		netdev_err(wlandev->netdev,
+			   "HostScan not supported with current firmware (<1.3.2).\n");
 		result = 1;
 		msg->resultcode.data = P80211ENUM_resultcode_not_supported;
 		goto exit;
@@ -143,8 +143,8 @@ int prism2mgmt_scan(wlandevice_t *wlandev, void *msgp)
 					  HFA384x_RID_CNFROAMINGMODE,
 					  &roamingmode);
 	if (result) {
-		printk(KERN_ERR "getconfig(ROAMMODE) failed. result=%d\n",
-		       result);
+		netdev_err(wlandev->netdev,
+			   "getconfig(ROAMMODE) failed. result=%d\n", result);
 		msg->resultcode.data =
 		    P80211ENUM_resultcode_implementation_failure;
 		goto exit;
@@ -155,8 +155,8 @@ int prism2mgmt_scan(wlandevice_t *wlandev, void *msgp)
 					  HFA384x_RID_CNFROAMINGMODE,
 					  HFA384x_ROAMMODE_HOSTSCAN_HOSTROAM);
 	if (result) {
-		printk(KERN_ERR "setconfig(ROAMINGMODE) failed. result=%d\n",
-		       result);
+		netdev_err(wlandev->netdev,
+			   "setconfig(ROAMINGMODE) failed. result=%d\n", result);
 		msg->resultcode.data =
 		    P80211ENUM_resultcode_implementation_failure;
 		goto exit;
@@ -176,8 +176,9 @@ int prism2mgmt_scan(wlandevice_t *wlandev, void *msgp)
 		    hfa384x_drvr_setconfig16(hw, HFA384x_RID_CNFPASSIVESCANCTRL,
 					     word);
 		if (result) {
-			printk(KERN_WARNING "Passive scan not supported with "
-			       "current firmware.  (<1.5.1)\n");
+			netdev_warn(wlandev->netdev,
+				    "Passive scan not supported with "
+				    "current firmware.  (<1.5.1)\n");
 		}
 	}
 
@@ -203,8 +204,8 @@ int prism2mgmt_scan(wlandevice_t *wlandev, void *msgp)
 	/* Enable the MAC port if it's not already enabled  */
 	result = hfa384x_drvr_getconfig16(hw, HFA384x_RID_PORTSTATUS, &word);
 	if (result) {
-		printk(KERN_ERR "getconfig(PORTSTATUS) failed. "
-		       "result=%d\n", result);
+		netdev_err(wlandev->netdev,
+			   "getconfig(PORTSTATUS) failed. result=%d\n", result);
 		msg->resultcode.data =
 		    P80211ENUM_resultcode_implementation_failure;
 		goto exit;
@@ -216,9 +217,9 @@ int prism2mgmt_scan(wlandevice_t *wlandev, void *msgp)
 					HFA384x_RID_CNFROAMINGMODE,
 					HFA384x_ROAMMODE_HOSTSCAN_HOSTROAM);
 		if (result) {
-			printk(KERN_ERR
-			       "setconfig(ROAMINGMODE) failed. result=%d\n",
-			       result);
+			netdev_err(wlandev->netdev,
+				   "setconfig(ROAMINGMODE) failed. result=%d\n",
+				   result);
 			msg->resultcode.data =
 			    P80211ENUM_resultcode_implementation_failure;
 			goto exit;
@@ -232,7 +233,7 @@ int prism2mgmt_scan(wlandevice_t *wlandev, void *msgp)
 						wordbuf,
 						HFA384x_RID_CNFOWNSSID_LEN);
 		if (result) {
-			printk(KERN_ERR "Failed to set OwnSSID.\n");
+			netdev_err(wlandev->netdev, "Failed to set OwnSSID.\n");
 			msg->resultcode.data =
 			    P80211ENUM_resultcode_implementation_failure;
 			goto exit;
@@ -241,7 +242,8 @@ int prism2mgmt_scan(wlandevice_t *wlandev, void *msgp)
 						wordbuf,
 						HFA384x_RID_CNFDESIREDSSID_LEN);
 		if (result) {
-			printk(KERN_ERR "Failed to set DesiredSSID.\n");
+			netdev_err(wlandev->netdev,
+				   "Failed to set DesiredSSID.\n");
 			msg->resultcode.data =
 			    P80211ENUM_resultcode_implementation_failure;
 			goto exit;
@@ -251,7 +253,8 @@ int prism2mgmt_scan(wlandevice_t *wlandev, void *msgp)
 						  HFA384x_RID_CNFPORTTYPE,
 						  HFA384x_PORTTYPE_IBSS);
 		if (result) {
-			printk(KERN_ERR "Failed to set CNFPORTTYPE.\n");
+			netdev_err(wlandev->netdev,
+				   "Failed to set CNFPORTTYPE.\n");
 			msg->resultcode.data =
 			    P80211ENUM_resultcode_implementation_failure;
 			goto exit;
@@ -261,15 +264,16 @@ int prism2mgmt_scan(wlandevice_t *wlandev, void *msgp)
 					HFA384x_RID_CREATEIBSS,
 					HFA384x_CREATEIBSS_JOINCREATEIBSS);
 		if (result) {
-			printk(KERN_ERR "Failed to set CREATEIBSS.\n");
+			netdev_err(wlandev->netdev,
+				   "Failed to set CREATEIBSS.\n");
 			msg->resultcode.data =
 			    P80211ENUM_resultcode_implementation_failure;
 			goto exit;
 		}
 		result = hfa384x_drvr_enable(hw, 0);
 		if (result) {
-			printk(KERN_ERR "drvr_enable(0) failed. "
-			       "result=%d\n", result);
+			netdev_err(wlandev->netdev,
+				   "drvr_enable(0) failed. result=%d\n", result);
 			msg->resultcode.data =
 			    P80211ENUM_resultcode_implementation_failure;
 			goto exit;
@@ -288,8 +292,8 @@ int prism2mgmt_scan(wlandevice_t *wlandev, void *msgp)
 					HFA384x_RID_HOSTSCAN, &scanreq,
 					sizeof(hfa384x_HostScanRequest_data_t));
 	if (result) {
-		printk(KERN_ERR "setconfig(SCANREQUEST) failed. result=%d\n",
-		       result);
+		netdev_err(wlandev->netdev,
+			   "setconfig(SCANREQUEST) failed. result=%d\n", result);
 		msg->resultcode.data =
 		    P80211ENUM_resultcode_implementation_failure;
 		goto exit;
@@ -310,8 +314,8 @@ int prism2mgmt_scan(wlandevice_t *wlandev, void *msgp)
 	if (istmpenable) {
 		result = hfa384x_drvr_disable(hw, 0);
 		if (result) {
-			printk(KERN_ERR "drvr_disable(0) failed. "
-			       "result=%d\n", result);
+			netdev_err(wlandev->netdev,
+				   "drvr_disable(0) failed. result=%d\n", result);
 			msg->resultcode.data =
 			    P80211ENUM_resultcode_implementation_failure;
 			goto exit;
@@ -322,8 +326,8 @@ int prism2mgmt_scan(wlandevice_t *wlandev, void *msgp)
 	result = hfa384x_drvr_setconfig16(hw, HFA384x_RID_CNFROAMINGMODE,
 					  roamingmode);
 	if (result) {
-		printk(KERN_ERR "setconfig(ROAMMODE) failed. result=%d\n",
-		       result);
+		netdev_err(wlandev->netdev,
+			   "setconfig(ROAMMODE) failed. result=%d\n", result);
 		msg->resultcode.data =
 		    P80211ENUM_resultcode_implementation_failure;
 		goto exit;
@@ -372,8 +376,9 @@ int prism2mgmt_scan_results(wlandevice_t *wlandev, void *msgp)
 	req->resultcode.status = P80211ENUM_msgitem_status_data_ok;
 
 	if (!hw->scanresults) {
-		printk(KERN_ERR
-		       "dot11req_scan_results can only be used after a successful dot11req_scan.\n");
+		netdev_err(wlandev->netdev,
+			   "dot11req_scan_results can only be used after "
+			   "a successful dot11req_scan.\n");
 		result = 2;
 		req->resultcode.data = P80211ENUM_resultcode_invalid_parameters;
 		goto exit;
@@ -555,14 +560,14 @@ int prism2mgmt_start(wlandevice_t *wlandev, void *msgp)
 	result = hfa384x_drvr_setconfig(hw, HFA384x_RID_CNFOWNSSID,
 					bytebuf, HFA384x_RID_CNFOWNSSID_LEN);
 	if (result) {
-		printk(KERN_ERR "Failed to set CnfOwnSSID\n");
+		netdev_err(wlandev->netdev, "Failed to set CnfOwnSSID\n");
 		goto failed;
 	}
 	result = hfa384x_drvr_setconfig(hw, HFA384x_RID_CNFDESIREDSSID,
 					bytebuf,
 					HFA384x_RID_CNFDESIREDSSID_LEN);
 	if (result) {
-		printk(KERN_ERR "Failed to set CnfDesiredSSID\n");
+		netdev_err(wlandev->netdev, "Failed to set CnfDesiredSSID\n");
 		goto failed;
 	}
 
@@ -574,7 +579,8 @@ int prism2mgmt_start(wlandevice_t *wlandev, void *msgp)
 	word = msg->beaconperiod.data;
 	result = hfa384x_drvr_setconfig16(hw, HFA384x_RID_CNFAPBCNint, word);
 	if (result) {
-		printk(KERN_ERR "Failed to set beacon period=%d.\n", word);
+		netdev_err(wlandev->netdev,
+			   "Failed to set beacon period=%d.\n", word);
 		goto failed;
 	}
 
@@ -582,7 +588,8 @@ int prism2mgmt_start(wlandevice_t *wlandev, void *msgp)
 	word = msg->dschannel.data;
 	result = hfa384x_drvr_setconfig16(hw, HFA384x_RID_CNFOWNCHANNEL, word);
 	if (result) {
-		printk(KERN_ERR "Failed to set channel=%d.\n", word);
+		netdev_err(wlandev->netdev,
+			   "Failed to set channel=%d.\n", word);
 		goto failed;
 	}
 	/* Basic rates */
@@ -610,7 +617,8 @@ int prism2mgmt_start(wlandevice_t *wlandev, void *msgp)
 
 	result = hfa384x_drvr_setconfig16(hw, HFA384x_RID_CNFBASICRATES, word);
 	if (result) {
-		printk(KERN_ERR "Failed to set basicrates=%d.\n", word);
+		netdev_err(wlandev->netdev,
+			   "Failed to set basicrates=%d.\n", word);
 		goto failed;
 	}
 
@@ -639,13 +647,14 @@ int prism2mgmt_start(wlandevice_t *wlandev, void *msgp)
 
 	result = hfa384x_drvr_setconfig16(hw, HFA384x_RID_CNFSUPPRATES, word);
 	if (result) {
-		printk(KERN_ERR "Failed to set supprates=%d.\n", word);
+		netdev_err(wlandev->netdev,
+			   "Failed to set supprates=%d.\n", word);
 		goto failed;
 	}
 
 	result = hfa384x_drvr_setconfig16(hw, HFA384x_RID_TXRATECNTL, word);
 	if (result) {
-		printk(KERN_ERR "Failed to set txrates=%d.\n", word);
+		netdev_err(wlandev->netdev, "Failed to set txrates=%d.\n", word);
 		goto failed;
 	}
 
@@ -659,7 +668,8 @@ int prism2mgmt_start(wlandevice_t *wlandev, void *msgp)
 	/* Enable the Port */
 	result = hfa384x_drvr_enable(hw, 0);
 	if (result) {
-		printk(KERN_ERR "Enable macport failed, result=%d.\n", result);
+		netdev_err(wlandev->netdev,
+			   "Enable macport failed, result=%d.\n", result);
 		goto failed;
 	}
 
@@ -704,8 +714,8 @@ int prism2mgmt_readpda(wlandevice_t *wlandev, void *msgp)
 	 * state.
 	 */
 	if (wlandev->msdstate != WLAN_MSD_FWLOAD) {
-		printk(KERN_ERR
-		       "PDA may only be read " "in the fwload state.\n");
+		netdev_err(wlandev->netdev,
+			   "PDA may only be read in the fwload state.\n");
 		msg->resultcode.data =
 		    P80211ENUM_resultcode_implementation_failure;
 		msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;
@@ -717,9 +727,9 @@ int prism2mgmt_readpda(wlandevice_t *wlandev, void *msgp)
 					      msg->pda.data,
 					      HFA384x_PDA_LEN_MAX);
 		if (result) {
-			printk(KERN_ERR
-			       "hfa384x_drvr_readpda() failed, "
-			       "result=%d\n", result);
+			netdev_err(wlandev->netdev,
+				   "hfa384x_drvr_readpda() failed, "
+				   "result=%d\n", result);
 
 			msg->resultcode.data =
 			    P80211ENUM_resultcode_implementation_failure;
@@ -766,9 +776,9 @@ int prism2mgmt_ramdl_state(wlandevice_t *wlandev, void *msgp)
 	struct p80211msg_p2req_ramdl_state *msg = msgp;
 
 	if (wlandev->msdstate != WLAN_MSD_FWLOAD) {
-		printk(KERN_ERR
-		       "ramdl_state(): may only be called "
-		       "in the fwload state.\n");
+		netdev_err(wlandev->netdev,
+			   "ramdl_state(): may only be called "
+			   "in the fwload state.\n");
 		msg->resultcode.data =
 		    P80211ENUM_resultcode_implementation_failure;
 		msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;
@@ -825,9 +835,9 @@ int prism2mgmt_ramdl_write(wlandevice_t *wlandev, void *msgp)
 	u8 *buf;
 
 	if (wlandev->msdstate != WLAN_MSD_FWLOAD) {
-		printk(KERN_ERR
-		       "ramdl_write(): may only be called "
-		       "in the fwload state.\n");
+		netdev_err(wlandev->netdev,
+			   "ramdl_write(): may only be called "
+			   "in the fwload state.\n");
 		msg->resultcode.data =
 		    P80211ENUM_resultcode_implementation_failure;
 		msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;
@@ -885,9 +895,9 @@ int prism2mgmt_flashdl_state(wlandevice_t *wlandev, void *msgp)
 	struct p80211msg_p2req_flashdl_state *msg = msgp;
 
 	if (wlandev->msdstate != WLAN_MSD_FWLOAD) {
-		printk(KERN_ERR
-		       "flashdl_state(): may only be called "
-		       "in the fwload state.\n");
+		netdev_err(wlandev->netdev,
+			   "flashdl_state(): may only be called "
+			   "in the fwload state.\n");
 		msg->resultcode.data =
 		    P80211ENUM_resultcode_implementation_failure;
 		msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;
@@ -920,8 +930,9 @@ int prism2mgmt_flashdl_state(wlandevice_t *wlandev, void *msgp)
 		wlandev->msdstate = WLAN_MSD_HWPRESENT;
 		result = prism2sta_ifstate(wlandev, P80211ENUM_ifstate_fwload);
 		if (result != P80211ENUM_resultcode_success) {
-			printk(KERN_ERR "prism2sta_ifstate(fwload) failed,"
-			       "P80211ENUM_resultcode=%d\n", result);
+			netdev_err(wlandev->netdev,
+				   "prism2sta_ifstate(fwload) failed,"
+				   "P80211ENUM_resultcode=%d\n", result);
 			msg->resultcode.data =
 			    P80211ENUM_resultcode_implementation_failure;
 			result = -1;
@@ -958,9 +969,9 @@ int prism2mgmt_flashdl_write(wlandevice_t *wlandev, void *msgp)
 	u8 *buf;
 
 	if (wlandev->msdstate != WLAN_MSD_FWLOAD) {
-		printk(KERN_ERR
-		       "flashdl_write(): may only be called "
-		       "in the fwload state.\n");
+		netdev_err(wlandev->netdev,
+			   "flashdl_write(): may only be called "
+			   "in the fwload state.\n");
 		msg->resultcode.data =
 		    P80211ENUM_resultcode_implementation_failure;
 		msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;
@@ -1153,7 +1164,7 @@ int prism2mgmt_wlansniff(wlandevice_t *wlandev, void *msgp)
 
 		}
 
-		printk(KERN_INFO "monitor mode disabled\n");
+		netdev_info(wlandev->netdev, "monitor mode disabled\n");
 		msg->resultcode.data = P80211ENUM_resultcode_success;
 		result = 0;
 		goto exit;
@@ -1282,7 +1293,7 @@ int prism2mgmt_wlansniff(wlandevice_t *wlandev, void *msgp)
 		}
 
 		if (wlandev->netdev->type == ARPHRD_ETHER)
-			printk(KERN_INFO "monitor mode enabled\n");
+			netdev_info(wlandev->netdev, "monitor mode enabled\n");
 
 		/* Set the driver state */
 		/* Do we want the prism2 header? */

commit b21199116a0ed9a27326b0cb85b1cdcc3997b879
Author: Himangi Saraogi <himangi774@gmail.com>
Date:   Sat Nov 2 18:11:44 2013 +0530

    staging:wlan-ng:hfa384x.h: remove typedef struct hfa384x_bytestr __packed hfa384x_bytestr_t
    
    This patch removes the checkpatch.pl warning "do not add new typedefs"
    and changes all source files that use that typedef. Also lines were
    shortened to 80 characters to do away with the checkpatch.pl warning
    "line over 80 characters" generated due to replacement of the
    hfa384x_bytestr_t by struct hfa384x_bytestr in prism2mgmt.c,
    prism2mgmt.h, prism2mib.c, prism2sta.c.
    
    Signed-off-by: Himangi Saraogi <himangi774@gmail.com>
    Reviewed-by: Josh Triplett <josh@joshtriplett.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/prism2mgmt.c b/drivers/staging/wlan-ng/prism2mgmt.c
index d22db43e8031..a9909f6b0001 100644
--- a/drivers/staging/wlan-ng/prism2mgmt.c
+++ b/drivers/staging/wlan-ng/prism2mgmt.c
@@ -525,7 +525,7 @@ int prism2mgmt_start(wlandevice_t *wlandev, void *msgp)
 
 	p80211pstrd_t *pstr;
 	u8 bytebuf[80];
-	hfa384x_bytestr_t *p2bytestr = (hfa384x_bytestr_t *) bytebuf;
+	struct hfa384x_bytestr *p2bytestr = (struct hfa384x_bytestr *) bytebuf;
 	u16 word;
 
 	wlandev->macmode = WLAN_MACMODE_NONE;
@@ -1019,7 +1019,7 @@ int prism2mgmt_autojoin(wlandevice_t *wlandev, void *msgp)
 	struct p80211msg_lnxreq_autojoin *msg = msgp;
 	p80211pstrd_t *pstr;
 	u8 bytebuf[256];
-	hfa384x_bytestr_t *p2bytestr = (hfa384x_bytestr_t *) bytebuf;
+	struct hfa384x_bytestr *p2bytestr = (struct hfa384x_bytestr *) bytebuf;
 
 	wlandev->macmode = WLAN_MACMODE_NONE;
 

commit 8f5f90a872c38b4e78f3cc95e8a25434b98e4db2
Merge: c0cd2da16b43 949db153b646
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Jan 25 21:25:02 2013 -0800

    Merge 3.8-rc5 into staging-next
    
    This resolves a merge issue with a iio driver, and the zram code.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 25c97da8b975d8717a0242c651896b56b2696060
Author: Sebastian Wankerl <sisewank@cip.cs.fau.de>
Date:   Sun Jan 20 16:30:54 2013 +0100

    wlan-ng/prism2mgmt.c: formated too long lines
    
    Formated pr_debug() calls
    
    Signed-off-by: Sebastian Wankerl <sisewank@cip.cs.fau.de>
    Signed-off-by: Sebastian Ehrenfels <qi50dube@cip.cs.fau.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/prism2mgmt.c b/drivers/staging/wlan-ng/prism2mgmt.c
index 62b94b017a60..fba4af805d98 100644
--- a/drivers/staging/wlan-ng/prism2mgmt.c
+++ b/drivers/staging/wlan-ng/prism2mgmt.c
@@ -1144,9 +1144,8 @@ int prism2mgmt_wlansniff(wlandevice_t *wlandev, void *msgp)
 			/* Enable the port */
 			result = hfa384x_drvr_enable(hw, 0);
 			if (result) {
-				pr_debug
-				("failed to enable port to presniff setting, result=%d\n",
-				     result);
+				pr_debug("failed to enable port to presniff setting, result=%d\n",
+					 result);
 				goto failed;
 			}
 		} else {
@@ -1186,18 +1185,16 @@ int prism2mgmt_wlansniff(wlandevice_t *wlandev, void *msgp)
 				hfa384x_drvr_stop(hw);
 				result = hfa384x_drvr_start(hw);
 				if (result) {
-					pr_debug
-					    ("failed to restart the card for sniffing, result=%d\n",
-					     result);
+					pr_debug("failed to restart the card for sniffing, result=%d\n",
+						 result);
 					goto failed;
 				}
 			} else {
 				/* Disable the port */
 				result = hfa384x_drvr_disable(hw, 0);
 				if (result) {
-					pr_debug
-					    ("failed to enable port for sniffing, result=%d\n",
-					     result);
+					pr_debug("failed to enable port for sniffing, result=%d\n",
+						 result);
 					goto failed;
 				}
 			}

commit 52070c709dbc493da550086709934e6028457a7c
Author: Sebastian Wankerl <sisewank@cip.cs.fau.de>
Date:   Sun Jan 20 16:24:45 2013 +0100

    wlan-ng/prism2mgmt.c: added parantheses to macro
    
    Enclose the macro into braces so that it can be closed by a semicolon
    
    Signed-off-by: Sebastian Wankerl <sisewank@cip.cs.fau.de>
    Signed-off-by: Sebastian Ehrenfels <qi50dube@cip.cs.fau.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/prism2mgmt.c b/drivers/staging/wlan-ng/prism2mgmt.c
index 4efa9bc0fcf0..62b94b017a60 100644
--- a/drivers/staging/wlan-ng/prism2mgmt.c
+++ b/drivers/staging/wlan-ng/prism2mgmt.c
@@ -415,11 +415,14 @@ int prism2mgmt_scan_results(wlandevice_t *wlandev, void *msgp)
 			break;
 
 #define REQBASICRATE(N) \
-	if ((count >= N) && DOT11_RATE5_ISBASIC_GET(item->supprates[(N)-1])) { \
-		req->basicrate ## N .data = item->supprates[(N)-1]; \
-		req->basicrate ## N .status = \
-			P80211ENUM_msgitem_status_data_ok; \
-	}
+	do { \
+		if ((count >= N) && DOT11_RATE5_ISBASIC_GET( \
+			item->supprates[(N)-1])) { \
+			req->basicrate ## N .data = item->supprates[(N)-1]; \
+			req->basicrate ## N .status = \
+				P80211ENUM_msgitem_status_data_ok; \
+		} \
+	} while (0)
 
 	REQBASICRATE(1);
 	REQBASICRATE(2);
@@ -431,11 +434,13 @@ int prism2mgmt_scan_results(wlandevice_t *wlandev, void *msgp)
 	REQBASICRATE(8);
 
 #define REQSUPPRATE(N) \
-	if (count >= N) { \
-		req->supprate ## N .data = item->supprates[(N)-1]; \
-		req->supprate ## N .status = \
-			P80211ENUM_msgitem_status_data_ok; \
-	}
+	do { \
+		if (count >= N) { \
+			req->supprate ## N .data = item->supprates[(N)-1]; \
+			req->supprate ## N .status = \
+				P80211ENUM_msgitem_status_data_ok; \
+		} \
+	} while (0)
 
 	REQSUPPRATE(1);
 	REQSUPPRATE(2);

commit 811a37effdb11e54e1ff1ddaa944286c88f58487
Author: Tormod Volden <debian.tormod@gmail.com>
Date:   Wed Jan 9 22:23:32 2013 +0100

    staging: wlan-ng: Fix clamping of returned SSID length
    
    Commit 2e254212 broke listing of available network names, since it
    clamped the length of the returned SSID to WLAN_BSSID_LEN (6) instead of
    WLAN_SSID_MAXLEN (32).
    
    https://bugzilla.kernel.org/show_bug.cgi?id=52501
    
    Signed-off-by: Tormod Volden <debian.tormod@gmail.com>
    Cc: stable <stable@vger.kernel.org> # 3.4+
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/prism2mgmt.c b/drivers/staging/wlan-ng/prism2mgmt.c
index 4efa9bc0fcf0..89bfd858bb28 100644
--- a/drivers/staging/wlan-ng/prism2mgmt.c
+++ b/drivers/staging/wlan-ng/prism2mgmt.c
@@ -406,7 +406,7 @@ int prism2mgmt_scan_results(wlandevice_t *wlandev, void *msgp)
 	/* SSID */
 	req->ssid.status = P80211ENUM_msgitem_status_data_ok;
 	req->ssid.data.len = le16_to_cpu(item->ssid.len);
-	req->ssid.data.len = min_t(u16, req->ssid.data.len, WLAN_BSSID_LEN);
+	req->ssid.data.len = min_t(u16, req->ssid.data.len, WLAN_SSID_MAXLEN);
 	memcpy(req->ssid.data.data, item->ssid.data, req->ssid.data.len);
 
 	/* supported rates */

commit bb46f130a033ed812ccc24f5fd4f34648650d240
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Wed Apr 18 09:48:59 2012 +0300

    Staging: wlan-ng: off by one in prism2mgmt_scan_results()
    
    Count is used to cap "req->bssindex.data" which is used as an offset
    into the hw->scanresults->info.hscanresult.result[] array.  The array
    has only HFA384x_SCANRESULT_MAX (31) elements so the 32 is off by one.
    
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/prism2mgmt.c b/drivers/staging/wlan-ng/prism2mgmt.c
index c3bb05dd744f..4efa9bc0fcf0 100644
--- a/drivers/staging/wlan-ng/prism2mgmt.c
+++ b/drivers/staging/wlan-ng/prism2mgmt.c
@@ -380,8 +380,8 @@ int prism2mgmt_scan_results(wlandevice_t *wlandev, void *msgp)
 	}
 
 	count = (hw->scanresults->framelen - 3) / 32;
-	if (count > 32)
-		count = 32;
+	if (count > HFA384x_SCANRESULT_MAX)
+		count = HFA384x_SCANRESULT_MAX;
 
 	if (req->bssindex.data >= count) {
 		pr_debug("requested index (%d) out of range (%d)\n",

commit 2e254212942e483eba4753830268045ac87ea224
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Tue Jan 31 11:45:15 2012 +0300

    Staging: wlan-ng: cap the ssid length
    
    We're getting the ssid length from the scan here.  Let's cap it before
    doing the memcpy().
    
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/prism2mgmt.c b/drivers/staging/wlan-ng/prism2mgmt.c
index 6675c8226cef..c3bb05dd744f 100644
--- a/drivers/staging/wlan-ng/prism2mgmt.c
+++ b/drivers/staging/wlan-ng/prism2mgmt.c
@@ -406,6 +406,7 @@ int prism2mgmt_scan_results(wlandevice_t *wlandev, void *msgp)
 	/* SSID */
 	req->ssid.status = P80211ENUM_msgitem_status_data_ok;
 	req->ssid.data.len = le16_to_cpu(item->ssid.len);
+	req->ssid.data.len = min_t(u16, req->ssid.data.len, WLAN_BSSID_LEN);
 	memcpy(req->ssid.data.data, item->ssid.data, req->ssid.data.len);
 
 	/* supported rates */

commit f83dfd065817ea3c7387b23afb2fd4d23fb470ff
Author: Johan Meiring <johanmeiring@gmail.com>
Date:   Sat Nov 6 18:23:44 2010 +0200

    Staging: wlan-ng: fix coding style issues in prism2mgmt.c
    
    This is a patch to prism2mgmt.c that fixes coding style issues found by
    checkpatch.pl. Three instances of the 80 char line limit being exceeded
    have been kept as is so that string literals are not split up.
    
    Signed-off-by: Johan Meiring <johanmeiring@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/wlan-ng/prism2mgmt.c b/drivers/staging/wlan-ng/prism2mgmt.c
index 04514a85d101..6675c8226cef 100644
--- a/drivers/staging/wlan-ng/prism2mgmt.c
+++ b/drivers/staging/wlan-ng/prism2mgmt.c
@@ -213,8 +213,8 @@ int prism2mgmt_scan(wlandevice_t *wlandev, void *msgp)
 		u16 wordbuf[17];
 
 		result = hfa384x_drvr_setconfig16(hw,
-						  HFA384x_RID_CNFROAMINGMODE,
-						  HFA384x_ROAMMODE_HOSTSCAN_HOSTROAM);
+					HFA384x_RID_CNFROAMINGMODE,
+					HFA384x_ROAMMODE_HOSTSCAN_HOSTROAM);
 		if (result) {
 			printk(KERN_ERR
 			       "setconfig(ROAMINGMODE) failed. result=%d\n",
@@ -258,8 +258,8 @@ int prism2mgmt_scan(wlandevice_t *wlandev, void *msgp)
 		}
 		/* ibss options */
 		result = hfa384x_drvr_setconfig16(hw,
-						  HFA384x_RID_CREATEIBSS,
-						  HFA384x_CREATEIBSS_JOINCREATEIBSS);
+					HFA384x_RID_CREATEIBSS,
+					HFA384x_CREATEIBSS_JOINCREATEIBSS);
 		if (result) {
 			printk(KERN_ERR "Failed to set CREATEIBSS.\n");
 			msg->resultcode.data =
@@ -416,7 +416,8 @@ int prism2mgmt_scan_results(wlandevice_t *wlandev, void *msgp)
 #define REQBASICRATE(N) \
 	if ((count >= N) && DOT11_RATE5_ISBASIC_GET(item->supprates[(N)-1])) { \
 		req->basicrate ## N .data = item->supprates[(N)-1]; \
-		req->basicrate ## N .status = P80211ENUM_msgitem_status_data_ok; \
+		req->basicrate ## N .status = \
+			P80211ENUM_msgitem_status_data_ok; \
 	}
 
 	REQBASICRATE(1);
@@ -431,7 +432,8 @@ int prism2mgmt_scan_results(wlandevice_t *wlandev, void *msgp)
 #define REQSUPPRATE(N) \
 	if (count >= N) { \
 		req->supprate ## N .data = item->supprates[(N)-1]; \
-		req->supprate ## N .status = P80211ENUM_msgitem_status_data_ok; \
+		req->supprate ## N .status = \
+			P80211ENUM_msgitem_status_data_ok; \
 	}
 
 	REQSUPPRATE(1);
@@ -1102,7 +1104,7 @@ int prism2mgmt_wlansniff(wlandevice_t *wlandev, void *msgp)
 		result = hfa384x_drvr_disable(hw, 0);
 		if (result) {
 			pr_debug
-			    ("failed to disable port 0 after sniffing, result=%d\n",
+			("failed to disable port 0 after sniffing, result=%d\n",
 			     result);
 			goto failed;
 		}
@@ -1137,7 +1139,7 @@ int prism2mgmt_wlansniff(wlandevice_t *wlandev, void *msgp)
 			result = hfa384x_drvr_enable(hw, 0);
 			if (result) {
 				pr_debug
-				    ("failed to enable port to presniff setting, result=%d\n",
+				("failed to enable port to presniff setting, result=%d\n",
 				     result);
 				goto failed;
 			}
@@ -1161,7 +1163,7 @@ int prism2mgmt_wlansniff(wlandevice_t *wlandev, void *msgp)
 						  &(hw->presniff_port_type));
 				if (result) {
 					pr_debug
-					    ("failed to read porttype, result=%d\n",
+					("failed to read porttype, result=%d\n",
 					     result);
 					goto failed;
 				}
@@ -1171,7 +1173,7 @@ int prism2mgmt_wlansniff(wlandevice_t *wlandev, void *msgp)
 						  &(hw->presniff_wepflags));
 				if (result) {
 					pr_debug
-					    ("failed to read wepflags, result=%d\n",
+					("failed to read wepflags, result=%d\n",
 					     result);
 					goto failed;
 				}
@@ -1238,8 +1240,8 @@ int prism2mgmt_wlansniff(wlandevice_t *wlandev, void *msgp)
 
 			if (result) {
 				pr_debug
-				    ("failed to set wepflags=0x%04x, result=%d\n",
-				     word, result);
+				  ("failed to set wepflags=0x%04x, result=%d\n",
+				   word, result);
 				goto failed;
 			}
 		}

commit b6bb56e6aa28085550179335247c649752ff2994
Author: Edgardo Hames <ehames@gmail.com>
Date:   Mon Aug 2 16:20:39 2010 -0300

    Staging: wlan-ng: fix checkpatch issues in headers.
    
    This patch fix errors and warnings reported by checkpatch
    in p80211meta.h and p80211metstruct.h.
    
    Signed-off-by: Edgardo Hames <ehames@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/wlan-ng/prism2mgmt.c b/drivers/staging/wlan-ng/prism2mgmt.c
index ef23f8b1454f..04514a85d101 100644
--- a/drivers/staging/wlan-ng/prism2mgmt.c
+++ b/drivers/staging/wlan-ng/prism2mgmt.c
@@ -117,7 +117,7 @@ int prism2mgmt_scan(wlandevice_t *wlandev, void *msgp)
 {
 	int result = 0;
 	hfa384x_t *hw = wlandev->priv;
-	p80211msg_dot11req_scan_t *msg = msgp;
+	struct p80211msg_dot11req_scan *msg = msgp;
 	u16 roamingmode, word;
 	int i, timeout;
 	int istmpenable = 0;
@@ -361,13 +361,13 @@ int prism2mgmt_scan(wlandevice_t *wlandev, void *msgp)
 int prism2mgmt_scan_results(wlandevice_t *wlandev, void *msgp)
 {
 	int result = 0;
-	p80211msg_dot11req_scan_results_t *req;
+	struct p80211msg_dot11req_scan_results *req;
 	hfa384x_t *hw = wlandev->priv;
 	hfa384x_HScanResultSub_t *item = NULL;
 
 	int count;
 
-	req = (p80211msg_dot11req_scan_results_t *) msgp;
+	req = (struct p80211msg_dot11req_scan_results *) msgp;
 
 	req->resultcode.status = P80211ENUM_msgitem_status_data_ok;
 
@@ -513,7 +513,7 @@ int prism2mgmt_start(wlandevice_t *wlandev, void *msgp)
 {
 	int result = 0;
 	hfa384x_t *hw = wlandev->priv;
-	p80211msg_dot11req_start_t *msg = msgp;
+	struct p80211msg_dot11req_start *msg = msgp;
 
 	p80211pstrd_t *pstr;
 	u8 bytebuf[80];
@@ -689,7 +689,7 @@ int prism2mgmt_start(wlandevice_t *wlandev, void *msgp)
 int prism2mgmt_readpda(wlandevice_t *wlandev, void *msgp)
 {
 	hfa384x_t *hw = wlandev->priv;
-	p80211msg_p2req_readpda_t *msg = msgp;
+	struct p80211msg_p2req_readpda *msg = msgp;
 	int result;
 
 	/* We only support collecting the PDA when in the FWLOAD
@@ -755,7 +755,7 @@ int prism2mgmt_readpda(wlandevice_t *wlandev, void *msgp)
 int prism2mgmt_ramdl_state(wlandevice_t *wlandev, void *msgp)
 {
 	hfa384x_t *hw = wlandev->priv;
-	p80211msg_p2req_ramdl_state_t *msg = msgp;
+	struct p80211msg_p2req_ramdl_state *msg = msgp;
 
 	if (wlandev->msdstate != WLAN_MSD_FWLOAD) {
 		printk(KERN_ERR
@@ -811,7 +811,7 @@ int prism2mgmt_ramdl_state(wlandevice_t *wlandev, void *msgp)
 int prism2mgmt_ramdl_write(wlandevice_t *wlandev, void *msgp)
 {
 	hfa384x_t *hw = wlandev->priv;
-	p80211msg_p2req_ramdl_write_t *msg = msgp;
+	struct p80211msg_p2req_ramdl_write *msg = msgp;
 	u32 addr;
 	u32 len;
 	u8 *buf;
@@ -874,7 +874,7 @@ int prism2mgmt_flashdl_state(wlandevice_t *wlandev, void *msgp)
 {
 	int result = 0;
 	hfa384x_t *hw = wlandev->priv;
-	p80211msg_p2req_flashdl_state_t *msg = msgp;
+	struct p80211msg_p2req_flashdl_state *msg = msgp;
 
 	if (wlandev->msdstate != WLAN_MSD_FWLOAD) {
 		printk(KERN_ERR
@@ -944,7 +944,7 @@ int prism2mgmt_flashdl_state(wlandevice_t *wlandev, void *msgp)
 int prism2mgmt_flashdl_write(wlandevice_t *wlandev, void *msgp)
 {
 	hfa384x_t *hw = wlandev->priv;
-	p80211msg_p2req_flashdl_write_t *msg = msgp;
+	struct p80211msg_p2req_flashdl_write *msg = msgp;
 	u32 addr;
 	u32 len;
 	u8 *buf;
@@ -1008,7 +1008,7 @@ int prism2mgmt_autojoin(wlandevice_t *wlandev, void *msgp)
 	int result = 0;
 	u16 reg;
 	u16 port_type;
-	p80211msg_lnxreq_autojoin_t *msg = msgp;
+	struct p80211msg_lnxreq_autojoin *msg = msgp;
 	p80211pstrd_t *pstr;
 	u8 bytebuf[256];
 	hfa384x_bytestr_t *p2bytestr = (hfa384x_bytestr_t *) bytebuf;
@@ -1076,7 +1076,7 @@ int prism2mgmt_autojoin(wlandevice_t *wlandev, void *msgp)
 int prism2mgmt_wlansniff(wlandevice_t *wlandev, void *msgp)
 {
 	int result = 0;
-	p80211msg_lnxreq_wlansniff_t *msg = msgp;
+	struct p80211msg_lnxreq_wlansniff *msg = msgp;
 
 	hfa384x_t *hw = wlandev->priv;
 	u16 word;

commit cb3126e60ffc1b7658a6ff4f6874585098bf9887
Author: Karl Relton <karllinuxtest.relton@ntlworld.com>
Date:   Thu Jun 3 23:04:06 2010 +0100

    Staging: wlan-ng: Switch from wext to cfg80211
    
    Switch driver over from wext to cfg80211 interface.
    
    Some Notes:
    
    - This patch moves the driver wholesale from wext to cfg80211. Wext
    support is still provided through the cfg80211 provided wext
    compatability layer.
    
    - Currently only infrastructure mode is implemented. Ad hoc mode is not
    yet implemented, but can be added.
    
    - It does not support connecting to a specified bssid, instead roaming
    is handled by the card itself. This matches the behaviour of the
    existing driver.
    
    - It has been tested using NetworkManager (via wpa_supplicant)
    configured to use the wext compatability layer, and then again with the
    native nl80211 layer.
    
    Signed-off-by: Karl Relton <karllinuxtest.relton@ntlworld.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/wlan-ng/prism2mgmt.c b/drivers/staging/wlan-ng/prism2mgmt.c
index 4d1cdfc35420..ef23f8b1454f 100644
--- a/drivers/staging/wlan-ng/prism2mgmt.c
+++ b/drivers/staging/wlan-ng/prism2mgmt.c
@@ -463,6 +463,8 @@ int prism2mgmt_scan_results(wlandevice_t *wlandev, void *msgp)
 
 	/* capinfo bits */
 	count = le16_to_cpu(item->capinfo);
+	req->capinfo.status = P80211ENUM_msgitem_status_data_ok;
+	req->capinfo.data = count;
 
 	/* privacy flag */
 	req->privacy.status = P80211ENUM_msgitem_status_data_ok;

commit 5a0e3ad6af8660be21ca98a971cd00f331318c05
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Mar 24 17:04:11 2010 +0900

    include cleanup: Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h
    
    percpu.h is included by sched.h and module.h and thus ends up being
    included when building most .c files.  percpu.h includes slab.h which
    in turn includes gfp.h making everything defined by the two files
    universally available and complicating inclusion dependencies.
    
    percpu.h -> slab.h dependency is about to be removed.  Prepare for
    this change by updating users of gfp and slab facilities include those
    headers directly instead of assuming availability.  As this conversion
    needs to touch large number of source files, the following script is
    used as the basis of conversion.
    
      http://userweb.kernel.org/~tj/misc/slabh-sweep.py
    
    The script does the followings.
    
    * Scan files for gfp and slab usages and update includes such that
      only the necessary includes are there.  ie. if only gfp is used,
      gfp.h, if slab is used, slab.h.
    
    * When the script inserts a new include, it looks at the include
      blocks and try to put the new include such that its order conforms
      to its surrounding.  It's put in the include block which contains
      core kernel includes, in the same order that the rest are ordered -
      alphabetical, Christmas tree, rev-Xmas-tree or at the end if there
      doesn't seem to be any matching order.
    
    * If the script can't find a place to put a new include (mostly
      because the file doesn't have fitting include block), it prints out
      an error message indicating which .h file needs to be added to the
      file.
    
    The conversion was done in the following steps.
    
    1. The initial automatic conversion of all .c files updated slightly
       over 4000 files, deleting around 700 includes and adding ~480 gfp.h
       and ~3000 slab.h inclusions.  The script emitted errors for ~400
       files.
    
    2. Each error was manually checked.  Some didn't need the inclusion,
       some needed manual addition while adding it to implementation .h or
       embedding .c file was more appropriate for others.  This step added
       inclusions to around 150 files.
    
    3. The script was run again and the output was compared to the edits
       from #2 to make sure no file was left behind.
    
    4. Several build tests were done and a couple of problems were fixed.
       e.g. lib/decompress_*.c used malloc/free() wrappers around slab
       APIs requiring slab.h to be added manually.
    
    5. The script was run on all .h files but without automatically
       editing them as sprinkling gfp.h and slab.h inclusions around .h
       files could easily lead to inclusion dependency hell.  Most gfp.h
       inclusion directives were ignored as stuff from gfp.h was usually
       wildly available and often used in preprocessor macros.  Each
       slab.h inclusion directive was examined and added manually as
       necessary.
    
    6. percpu.h was updated not to include slab.h.
    
    7. Build test were done on the following configurations and failures
       were fixed.  CONFIG_GCOV_KERNEL was turned off for all tests (as my
       distributed build env didn't work with gcov compiles) and a few
       more options had to be turned off depending on archs to make things
       build (like ipr on powerpc/64 which failed due to missing writeq).
    
       * x86 and x86_64 UP and SMP allmodconfig and a custom test config.
       * powerpc and powerpc64 SMP allmodconfig
       * sparc and sparc64 SMP allmodconfig
       * ia64 SMP allmodconfig
       * s390 SMP allmodconfig
       * alpha SMP allmodconfig
       * um on x86_64 SMP allmodconfig
    
    8. percpu.h modifications were reverted so that it could be applied as
       a separate patch and serve as bisection point.
    
    Given the fact that I had only a couple of failures from tests on step
    6, I'm fairly confident about the coverage of this conversion patch.
    If there is a breakage, it's likely to be something in one of the arch
    headers which should be easily discoverable easily on most builds of
    the specific arch.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Guess-its-ok-by: Christoph Lameter <cl@linux-foundation.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Lee Schermerhorn <Lee.Schermerhorn@hp.com>

diff --git a/drivers/staging/wlan-ng/prism2mgmt.c b/drivers/staging/wlan-ng/prism2mgmt.c
index ad163da72ae4..4d1cdfc35420 100644
--- a/drivers/staging/wlan-ng/prism2mgmt.c
+++ b/drivers/staging/wlan-ng/prism2mgmt.c
@@ -63,7 +63,6 @@
 #include <linux/wait.h>
 #include <linux/sched.h>
 #include <linux/types.h>
-#include <linux/slab.h>
 #include <linux/wireless.h>
 #include <linux/netdevice.h>
 #include <linux/delay.h>

commit ef1a0ed7f1793531e5fb3ee489cb1e2b627f76fd
Author: Andrew Elwell <andrew.elwell@gmail.com>
Date:   Thu Feb 18 23:56:12 2010 +0100

    Staging: wlan-ng - checkpatch.pl fixups
    
    Basic fixups in the staging/wlan-ng directory.
    (First kernel patch - thanks to FOSDEM talk)
    
    Signed-off-by: Andrew Elwell <Andrew.Elwell@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/wlan-ng/prism2mgmt.c b/drivers/staging/wlan-ng/prism2mgmt.c
index 9f7d96cae8e3..ad163da72ae4 100644
--- a/drivers/staging/wlan-ng/prism2mgmt.c
+++ b/drivers/staging/wlan-ng/prism2mgmt.c
@@ -67,7 +67,7 @@
 #include <linux/wireless.h>
 #include <linux/netdevice.h>
 #include <linux/delay.h>
-#include <asm/io.h>
+#include <linux/io.h>
 #include <asm/byteorder.h>
 #include <linux/random.h>
 #include <linux/usb.h>
@@ -541,7 +541,7 @@ int prism2mgmt_start(wlandevice_t *wlandev, void *msgp)
 	/*** STATION ***/
 	/* Set the REQUIRED config items */
 	/* SSID */
-	pstr = (p80211pstrd_t *) & (msg->ssid.data);
+	pstr = (p80211pstrd_t *) &(msg->ssid.data);
 	prism2mgmt_pstr2bytestr(p2bytestr, pstr);
 	result = hfa384x_drvr_setconfig(hw, HFA384x_RID_CNFOWNSSID,
 					bytebuf, HFA384x_RID_CNFOWNSSID_LEN);
@@ -1034,7 +1034,7 @@ int prism2mgmt_autojoin(wlandevice_t *wlandev, void *msgp)
 
 	/* Set the ssid */
 	memset(bytebuf, 0, 256);
-	pstr = (p80211pstrd_t *) & (msg->ssid.data);
+	pstr = (p80211pstrd_t *) &(msg->ssid.data);
 	prism2mgmt_pstr2bytestr(p2bytestr, pstr);
 	result = hfa384x_drvr_setconfig(hw, HFA384x_RID_CNFDESIREDSSID,
 					bytebuf,
@@ -1123,8 +1123,8 @@ int prism2mgmt_wlansniff(wlandevice_t *wlandev, void *msgp)
 		if (hw->presniff_port_type != 0) {
 			word = hw->presniff_port_type;
 			result = hfa384x_drvr_setconfig16(hw,
-							  HFA384x_RID_CNFPORTTYPE,
-							  word);
+						  HFA384x_RID_CNFPORTTYPE,
+						  word);
 			if (result) {
 				pr_debug
 				    ("failed to restore porttype, result=%d\n",
@@ -1156,10 +1156,8 @@ int prism2mgmt_wlansniff(wlandevice_t *wlandev, void *msgp)
 			if (wlandev->netdev->type == ARPHRD_ETHER) {
 				/* Save macport 0 state */
 				result = hfa384x_drvr_getconfig16(hw,
-								  HFA384x_RID_CNFPORTTYPE,
-								  &
-								  (hw->
-								   presniff_port_type));
+						  HFA384x_RID_CNFPORTTYPE,
+						  &(hw->presniff_port_type));
 				if (result) {
 					pr_debug
 					    ("failed to read porttype, result=%d\n",
@@ -1168,10 +1166,8 @@ int prism2mgmt_wlansniff(wlandevice_t *wlandev, void *msgp)
 				}
 				/* Save the wepflags state */
 				result = hfa384x_drvr_getconfig16(hw,
-								  HFA384x_RID_CNFWEPFLAGS,
-								  &
-								  (hw->
-								   presniff_wepflags));
+						  HFA384x_RID_CNFWEPFLAGS,
+						  &(hw->presniff_wepflags));
 				if (result) {
 					pr_debug
 					    ("failed to read wepflags, result=%d\n",
@@ -1218,8 +1214,8 @@ int prism2mgmt_wlansniff(wlandevice_t *wlandev, void *msgp)
 			/* Set the port type to pIbss */
 			word = HFA384x_PORTTYPE_PSUEDOIBSS;
 			result = hfa384x_drvr_setconfig16(hw,
-							  HFA384x_RID_CNFPORTTYPE,
-							  word);
+						  HFA384x_RID_CNFPORTTYPE,
+						  word);
 			if (result) {
 				pr_debug
 				    ("failed to set porttype %d, result=%d\n",
@@ -1235,8 +1231,8 @@ int prism2mgmt_wlansniff(wlandevice_t *wlandev, void *msgp)
 				    HFA384x_WEPFLAGS_DISABLE_RXCRYPT;
 				result =
 				    hfa384x_drvr_setconfig16(hw,
-							     HFA384x_RID_CNFWEPFLAGS,
-							     word);
+						     HFA384x_RID_CNFWEPFLAGS,
+						     word);
 			}
 
 			if (result) {

commit 0d0202fd888a0f6e42d14aa903c6d79fc8777125
Author: Moritz Muehlenhoff <jmm@debian.org>
Date:   Sun Jun 21 22:43:44 2009 +0200

    Staging: wlan-ng: Remove some superflous comments
    
    Signed-off-by: Moritz Muehlenhoff <jmm@debian.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/wlan-ng/prism2mgmt.c b/drivers/staging/wlan-ng/prism2mgmt.c
index 591419069115..9f7d96cae8e3 100644
--- a/drivers/staging/wlan-ng/prism2mgmt.c
+++ b/drivers/staging/wlan-ng/prism2mgmt.c
@@ -73,9 +73,6 @@
 #include <linux/usb.h>
 #include <linux/bitops.h>
 
-/*================================================================*/
-/* Project Includes */
-
 #include "p80211types.h"
 #include "p80211hdr.h"
 #include "p80211mgmt.h"

commit 297f06cea635ea4552541a11e7fb7014425110c6
Author: Mithlesh Thukral <mithlesh@linsyssoft.com>
Date:   Wed Jun 10 19:36:11 2009 +0530

    staging: wlan-ng: scripts/checkpatch.pl error fixes.
    
    scripts/checkpatch.pl error fixes. This is a TODO item.
    This patch fixes most of the errors reported by checkpatch.pl in
    wlan-ng directory of staging tree.
    
    Signed-off-by: Mithlesh Thukral <mithlesh@linsyssoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/wlan-ng/prism2mgmt.c b/drivers/staging/wlan-ng/prism2mgmt.c
index 465457653eb3..591419069115 100644
--- a/drivers/staging/wlan-ng/prism2mgmt.c
+++ b/drivers/staging/wlan-ng/prism2mgmt.c
@@ -117,7 +117,7 @@
 *	process thread  (usually)
 *	interrupt
 ----------------------------------------------------------------*/
-int prism2mgmt_scan(wlandevice_t * wlandev, void *msgp)
+int prism2mgmt_scan(wlandevice_t *wlandev, void *msgp)
 {
 	int result = 0;
 	hfa384x_t *hw = wlandev->priv;
@@ -362,7 +362,7 @@ int prism2mgmt_scan(wlandevice_t * wlandev, void *msgp)
 *	process thread  (usually)
 *	interrupt
 ----------------------------------------------------------------*/
-int prism2mgmt_scan_results(wlandevice_t * wlandev, void *msgp)
+int prism2mgmt_scan_results(wlandevice_t *wlandev, void *msgp)
 {
 	int result = 0;
 	p80211msg_dot11req_scan_results_t *req;
@@ -511,7 +511,7 @@ int prism2mgmt_scan_results(wlandevice_t * wlandev, void *msgp)
 *	process thread  (usually)
 *	interrupt
 ----------------------------------------------------------------*/
-int prism2mgmt_start(wlandevice_t * wlandev, void *msgp)
+int prism2mgmt_start(wlandevice_t *wlandev, void *msgp)
 {
 	int result = 0;
 	hfa384x_t *hw = wlandev->priv;
@@ -688,7 +688,7 @@ int prism2mgmt_start(wlandevice_t * wlandev, void *msgp)
 * Call context:
 *	process thread  (usually)
 ----------------------------------------------------------------*/
-int prism2mgmt_readpda(wlandevice_t * wlandev, void *msgp)
+int prism2mgmt_readpda(wlandevice_t *wlandev, void *msgp)
 {
 	hfa384x_t *hw = wlandev->priv;
 	p80211msg_p2req_readpda_t *msg = msgp;
@@ -754,7 +754,7 @@ int prism2mgmt_readpda(wlandevice_t * wlandev, void *msgp)
 * Call context:
 *	process thread  (usually)
 ----------------------------------------------------------------*/
-int prism2mgmt_ramdl_state(wlandevice_t * wlandev, void *msgp)
+int prism2mgmt_ramdl_state(wlandevice_t *wlandev, void *msgp)
 {
 	hfa384x_t *hw = wlandev->priv;
 	p80211msg_p2req_ramdl_state_t *msg = msgp;
@@ -810,7 +810,7 @@ int prism2mgmt_ramdl_state(wlandevice_t * wlandev, void *msgp)
 * Call context:
 *	process thread  (usually)
 ----------------------------------------------------------------*/
-int prism2mgmt_ramdl_write(wlandevice_t * wlandev, void *msgp)
+int prism2mgmt_ramdl_write(wlandevice_t *wlandev, void *msgp)
 {
 	hfa384x_t *hw = wlandev->priv;
 	p80211msg_p2req_ramdl_write_t *msg = msgp;
@@ -872,7 +872,7 @@ int prism2mgmt_ramdl_write(wlandevice_t * wlandev, void *msgp)
 * Call context:
 *	process thread  (usually)
 ----------------------------------------------------------------*/
-int prism2mgmt_flashdl_state(wlandevice_t * wlandev, void *msgp)
+int prism2mgmt_flashdl_state(wlandevice_t *wlandev, void *msgp)
 {
 	int result = 0;
 	hfa384x_t *hw = wlandev->priv;
@@ -943,7 +943,7 @@ int prism2mgmt_flashdl_state(wlandevice_t * wlandev, void *msgp)
 * Call context:
 *	process thread  (usually)
 ----------------------------------------------------------------*/
-int prism2mgmt_flashdl_write(wlandevice_t * wlandev, void *msgp)
+int prism2mgmt_flashdl_write(wlandevice_t *wlandev, void *msgp)
 {
 	hfa384x_t *hw = wlandev->priv;
 	p80211msg_p2req_flashdl_write_t *msg = msgp;
@@ -1004,7 +1004,7 @@ int prism2mgmt_flashdl_write(wlandevice_t * wlandev, void *msgp)
 *	process thread  (usually)
 *	interrupt
 ----------------------------------------------------------------*/
-int prism2mgmt_autojoin(wlandevice_t * wlandev, void *msgp)
+int prism2mgmt_autojoin(wlandevice_t *wlandev, void *msgp)
 {
 	hfa384x_t *hw = wlandev->priv;
 	int result = 0;
@@ -1075,7 +1075,7 @@ int prism2mgmt_autojoin(wlandevice_t * wlandev, void *msgp)
 *	process thread  (usually)
 *	interrupt
 ----------------------------------------------------------------*/
-int prism2mgmt_wlansniff(wlandevice_t * wlandev, void *msgp)
+int prism2mgmt_wlansniff(wlandevice_t *wlandev, void *msgp)
 {
 	int result = 0;
 	p80211msg_lnxreq_wlansniff_t *msg = msgp;

commit 75f49e07520d036c2a0903694fdc0bcfb5523b76
Author: Mithlesh Thukral <mithlesh@linsyssoft.com>
Date:   Mon May 25 19:06:16 2009 +0530

    Staging: wlan-ng: Lindent cleanups
    
    Lindent script cleanups in wlan-ng driver in the staging tree.
    This is a item in the TODO list.
    
    Signed-off-by: Mithlesh Thukral <mithlesh@linsyssoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/wlan-ng/prism2mgmt.c b/drivers/staging/wlan-ng/prism2mgmt.c
index d2e5fccb629f..465457653eb3 100644
--- a/drivers/staging/wlan-ng/prism2mgmt.c
+++ b/drivers/staging/wlan-ng/prism2mgmt.c
@@ -117,7 +117,7 @@
 *	process thread  (usually)
 *	interrupt
 ----------------------------------------------------------------*/
-int prism2mgmt_scan(wlandevice_t *wlandev, void *msgp)
+int prism2mgmt_scan(wlandevice_t * wlandev, void *msgp)
 {
 	int result = 0;
 	hfa384x_t *hw = wlandev->priv;
@@ -362,7 +362,7 @@ int prism2mgmt_scan(wlandevice_t *wlandev, void *msgp)
 *	process thread  (usually)
 *	interrupt
 ----------------------------------------------------------------*/
-int prism2mgmt_scan_results(wlandevice_t *wlandev, void *msgp)
+int prism2mgmt_scan_results(wlandevice_t * wlandev, void *msgp)
 {
 	int result = 0;
 	p80211msg_dot11req_scan_results_t *req;
@@ -389,7 +389,7 @@ int prism2mgmt_scan_results(wlandevice_t *wlandev, void *msgp)
 
 	if (req->bssindex.data >= count) {
 		pr_debug("requested index (%d) out of range (%d)\n",
-		       req->bssindex.data, count);
+			 req->bssindex.data, count);
 		result = 2;
 		req->resultcode.data = P80211ENUM_resultcode_invalid_parameters;
 		goto exit;
@@ -511,7 +511,7 @@ int prism2mgmt_scan_results(wlandevice_t *wlandev, void *msgp)
 *	process thread  (usually)
 *	interrupt
 ----------------------------------------------------------------*/
-int prism2mgmt_start(wlandevice_t *wlandev, void *msgp)
+int prism2mgmt_start(wlandevice_t * wlandev, void *msgp)
 {
 	int result = 0;
 	hfa384x_t *hw = wlandev->priv;
@@ -544,7 +544,7 @@ int prism2mgmt_start(wlandevice_t *wlandev, void *msgp)
 	/*** STATION ***/
 	/* Set the REQUIRED config items */
 	/* SSID */
-	pstr = (p80211pstrd_t *)&(msg->ssid.data);
+	pstr = (p80211pstrd_t *) & (msg->ssid.data);
 	prism2mgmt_pstr2bytestr(p2bytestr, pstr);
 	result = hfa384x_drvr_setconfig(hw, HFA384x_RID_CNFOWNSSID,
 					bytebuf, HFA384x_RID_CNFOWNSSID_LEN);
@@ -688,7 +688,7 @@ int prism2mgmt_start(wlandevice_t *wlandev, void *msgp)
 * Call context:
 *	process thread  (usually)
 ----------------------------------------------------------------*/
-int prism2mgmt_readpda(wlandevice_t *wlandev, void *msgp)
+int prism2mgmt_readpda(wlandevice_t * wlandev, void *msgp)
 {
 	hfa384x_t *hw = wlandev->priv;
 	p80211msg_p2req_readpda_t *msg = msgp;
@@ -754,7 +754,7 @@ int prism2mgmt_readpda(wlandevice_t *wlandev, void *msgp)
 * Call context:
 *	process thread  (usually)
 ----------------------------------------------------------------*/
-int prism2mgmt_ramdl_state(wlandevice_t *wlandev, void *msgp)
+int prism2mgmt_ramdl_state(wlandevice_t * wlandev, void *msgp)
 {
 	hfa384x_t *hw = wlandev->priv;
 	p80211msg_p2req_ramdl_state_t *msg = msgp;
@@ -810,7 +810,7 @@ int prism2mgmt_ramdl_state(wlandevice_t *wlandev, void *msgp)
 * Call context:
 *	process thread  (usually)
 ----------------------------------------------------------------*/
-int prism2mgmt_ramdl_write(wlandevice_t *wlandev, void *msgp)
+int prism2mgmt_ramdl_write(wlandevice_t * wlandev, void *msgp)
 {
 	hfa384x_t *hw = wlandev->priv;
 	p80211msg_p2req_ramdl_write_t *msg = msgp;
@@ -872,7 +872,7 @@ int prism2mgmt_ramdl_write(wlandevice_t *wlandev, void *msgp)
 * Call context:
 *	process thread  (usually)
 ----------------------------------------------------------------*/
-int prism2mgmt_flashdl_state(wlandevice_t *wlandev, void *msgp)
+int prism2mgmt_flashdl_state(wlandevice_t * wlandev, void *msgp)
 {
 	int result = 0;
 	hfa384x_t *hw = wlandev->priv;
@@ -943,7 +943,7 @@ int prism2mgmt_flashdl_state(wlandevice_t *wlandev, void *msgp)
 * Call context:
 *	process thread  (usually)
 ----------------------------------------------------------------*/
-int prism2mgmt_flashdl_write(wlandevice_t *wlandev, void *msgp)
+int prism2mgmt_flashdl_write(wlandevice_t * wlandev, void *msgp)
 {
 	hfa384x_t *hw = wlandev->priv;
 	p80211msg_p2req_flashdl_write_t *msg = msgp;
@@ -1004,7 +1004,7 @@ int prism2mgmt_flashdl_write(wlandevice_t *wlandev, void *msgp)
 *	process thread  (usually)
 *	interrupt
 ----------------------------------------------------------------*/
-int prism2mgmt_autojoin(wlandevice_t *wlandev, void *msgp)
+int prism2mgmt_autojoin(wlandevice_t * wlandev, void *msgp)
 {
 	hfa384x_t *hw = wlandev->priv;
 	int result = 0;
@@ -1037,7 +1037,7 @@ int prism2mgmt_autojoin(wlandevice_t *wlandev, void *msgp)
 
 	/* Set the ssid */
 	memset(bytebuf, 0, 256);
-	pstr = (p80211pstrd_t *)&(msg->ssid.data);
+	pstr = (p80211pstrd_t *) & (msg->ssid.data);
 	prism2mgmt_pstr2bytestr(p2bytestr, pstr);
 	result = hfa384x_drvr_setconfig(hw, HFA384x_RID_CNFDESIREDSSID,
 					bytebuf,
@@ -1075,7 +1075,7 @@ int prism2mgmt_autojoin(wlandevice_t *wlandev, void *msgp)
 *	process thread  (usually)
 *	interrupt
 ----------------------------------------------------------------*/
-int prism2mgmt_wlansniff(wlandevice_t *wlandev, void *msgp)
+int prism2mgmt_wlansniff(wlandevice_t * wlandev, void *msgp)
 {
 	int result = 0;
 	p80211msg_lnxreq_wlansniff_t *msg = msgp;
@@ -1096,17 +1096,16 @@ int prism2mgmt_wlansniff(wlandevice_t *wlandev, void *msgp)
 		/* Disable monitor mode */
 		result = hfa384x_cmd_monitor(hw, HFA384x_MONITOR_DISABLE);
 		if (result) {
-			pr_debug(
-			       "failed to disable monitor mode, result=%d\n",
-			       result);
+			pr_debug("failed to disable monitor mode, result=%d\n",
+				 result);
 			goto failed;
 		}
 		/* Disable port 0 */
 		result = hfa384x_drvr_disable(hw, 0);
 		if (result) {
-			pr_debug(
-			       "failed to disable port 0 after sniffing, result=%d\n",
-			       result);
+			pr_debug
+			    ("failed to disable port 0 after sniffing, result=%d\n",
+			     result);
 			goto failed;
 		}
 		/* Clear the driver state */
@@ -1117,9 +1116,9 @@ int prism2mgmt_wlansniff(wlandevice_t *wlandev, void *msgp)
 						  HFA384x_RID_CNFWEPFLAGS,
 						  hw->presniff_wepflags);
 		if (result) {
-			pr_debug(
-			       "failed to restore wepflags=0x%04x, result=%d\n",
-			       hw->presniff_wepflags, result);
+			pr_debug
+			    ("failed to restore wepflags=0x%04x, result=%d\n",
+			     hw->presniff_wepflags, result);
 			goto failed;
 		}
 
@@ -1130,18 +1129,18 @@ int prism2mgmt_wlansniff(wlandevice_t *wlandev, void *msgp)
 							  HFA384x_RID_CNFPORTTYPE,
 							  word);
 			if (result) {
-				pr_debug(
-				       "failed to restore porttype, result=%d\n",
-				       result);
+				pr_debug
+				    ("failed to restore porttype, result=%d\n",
+				     result);
 				goto failed;
 			}
 
 			/* Enable the port */
 			result = hfa384x_drvr_enable(hw, 0);
 			if (result) {
-				pr_debug(
-				       "failed to enable port to presniff setting, result=%d\n",
-				       result);
+				pr_debug
+				    ("failed to enable port to presniff setting, result=%d\n",
+				     result);
 				goto failed;
 			}
 		} else {
@@ -1161,40 +1160,42 @@ int prism2mgmt_wlansniff(wlandevice_t *wlandev, void *msgp)
 				/* Save macport 0 state */
 				result = hfa384x_drvr_getconfig16(hw,
 								  HFA384x_RID_CNFPORTTYPE,
-								  &(hw->
-								    presniff_port_type));
+								  &
+								  (hw->
+								   presniff_port_type));
 				if (result) {
-					pr_debug(
-					       "failed to read porttype, result=%d\n",
-					       result);
+					pr_debug
+					    ("failed to read porttype, result=%d\n",
+					     result);
 					goto failed;
 				}
 				/* Save the wepflags state */
 				result = hfa384x_drvr_getconfig16(hw,
 								  HFA384x_RID_CNFWEPFLAGS,
-								  &(hw->
-								    presniff_wepflags));
+								  &
+								  (hw->
+								   presniff_wepflags));
 				if (result) {
-					pr_debug(
-					       "failed to read wepflags, result=%d\n",
-					       result);
+					pr_debug
+					    ("failed to read wepflags, result=%d\n",
+					     result);
 					goto failed;
 				}
 				hfa384x_drvr_stop(hw);
 				result = hfa384x_drvr_start(hw);
 				if (result) {
-					pr_debug(
-					       "failed to restart the card for sniffing, result=%d\n",
-					       result);
+					pr_debug
+					    ("failed to restart the card for sniffing, result=%d\n",
+					     result);
 					goto failed;
 				}
 			} else {
 				/* Disable the port */
 				result = hfa384x_drvr_disable(hw, 0);
 				if (result) {
-					pr_debug(
-					       "failed to enable port for sniffing, result=%d\n",
-					       result);
+					pr_debug
+					    ("failed to enable port for sniffing, result=%d\n",
+					     result);
 					goto failed;
 				}
 			}
@@ -1210,9 +1211,8 @@ int prism2mgmt_wlansniff(wlandevice_t *wlandev, void *msgp)
 		hw->sniff_channel = word;
 
 		if (result) {
-			pr_debug(
-			       "failed to set channel %d, result=%d\n",
-			       word, result);
+			pr_debug("failed to set channel %d, result=%d\n",
+				 word, result);
 			goto failed;
 		}
 
@@ -1224,9 +1224,9 @@ int prism2mgmt_wlansniff(wlandevice_t *wlandev, void *msgp)
 							  HFA384x_RID_CNFPORTTYPE,
 							  word);
 			if (result) {
-				pr_debug(
-				       "failed to set porttype %d, result=%d\n",
-				       word, result);
+				pr_debug
+				    ("failed to set porttype %d, result=%d\n",
+				     word, result);
 				goto failed;
 			}
 			if ((msg->keepwepflags.status ==
@@ -1243,9 +1243,9 @@ int prism2mgmt_wlansniff(wlandevice_t *wlandev, void *msgp)
 			}
 
 			if (result) {
-				pr_debug(
-				       "failed to set wepflags=0x%04x, result=%d\n",
-				       word, result);
+				pr_debug
+				    ("failed to set wepflags=0x%04x, result=%d\n",
+				     word, result);
 				goto failed;
 			}
 		}
@@ -1269,17 +1269,16 @@ int prism2mgmt_wlansniff(wlandevice_t *wlandev, void *msgp)
 		/* Enable the port */
 		result = hfa384x_drvr_enable(hw, 0);
 		if (result) {
-			pr_debug(
-			       "failed to enable port for sniffing, result=%d\n",
-			       result);
+			pr_debug
+			    ("failed to enable port for sniffing, result=%d\n",
+			     result);
 			goto failed;
 		}
 		/* Enable monitor mode */
 		result = hfa384x_cmd_monitor(hw, HFA384x_MONITOR_ENABLE);
 		if (result) {
-			pr_debug(
-			       "failed to enable monitor mode, result=%d\n",
-			       result);
+			pr_debug("failed to enable monitor mode, result=%d\n",
+				 result);
 			goto failed;
 		}
 

commit f2b50b40d1241b443da43fa66ae53bae93df910a
Author: Karl Relton <karllinuxtest.relton@ntlworld.com>
Date:   Fri May 8 20:54:17 2009 +0100

    Staging: wlan-ng: Change KERN_DEBUG or pr_debug to match orig driver
    
    Change uses of KERN_DEBUG over to pr_debug to match original driver
    where messages are only needed during driver development.
    
    Signed-off-by: Karl Relton <karllinuxtest.relton@ntlworld.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/wlan-ng/prism2mgmt.c b/drivers/staging/wlan-ng/prism2mgmt.c
index e7a7939b4280..d2e5fccb629f 100644
--- a/drivers/staging/wlan-ng/prism2mgmt.c
+++ b/drivers/staging/wlan-ng/prism2mgmt.c
@@ -1096,7 +1096,7 @@ int prism2mgmt_wlansniff(wlandevice_t *wlandev, void *msgp)
 		/* Disable monitor mode */
 		result = hfa384x_cmd_monitor(hw, HFA384x_MONITOR_DISABLE);
 		if (result) {
-			printk(KERN_DEBUG
+			pr_debug(
 			       "failed to disable monitor mode, result=%d\n",
 			       result);
 			goto failed;
@@ -1104,7 +1104,7 @@ int prism2mgmt_wlansniff(wlandevice_t *wlandev, void *msgp)
 		/* Disable port 0 */
 		result = hfa384x_drvr_disable(hw, 0);
 		if (result) {
-			printk(KERN_DEBUG
+			pr_debug(
 			       "failed to disable port 0 after sniffing, result=%d\n",
 			       result);
 			goto failed;
@@ -1117,7 +1117,7 @@ int prism2mgmt_wlansniff(wlandevice_t *wlandev, void *msgp)
 						  HFA384x_RID_CNFWEPFLAGS,
 						  hw->presniff_wepflags);
 		if (result) {
-			printk(KERN_DEBUG
+			pr_debug(
 			       "failed to restore wepflags=0x%04x, result=%d\n",
 			       hw->presniff_wepflags, result);
 			goto failed;
@@ -1130,7 +1130,7 @@ int prism2mgmt_wlansniff(wlandevice_t *wlandev, void *msgp)
 							  HFA384x_RID_CNFPORTTYPE,
 							  word);
 			if (result) {
-				printk(KERN_DEBUG
+				pr_debug(
 				       "failed to restore porttype, result=%d\n",
 				       result);
 				goto failed;
@@ -1139,7 +1139,7 @@ int prism2mgmt_wlansniff(wlandevice_t *wlandev, void *msgp)
 			/* Enable the port */
 			result = hfa384x_drvr_enable(hw, 0);
 			if (result) {
-				printk(KERN_DEBUG
+				pr_debug(
 				       "failed to enable port to presniff setting, result=%d\n",
 				       result);
 				goto failed;
@@ -1164,7 +1164,7 @@ int prism2mgmt_wlansniff(wlandevice_t *wlandev, void *msgp)
 								  &(hw->
 								    presniff_port_type));
 				if (result) {
-					printk(KERN_DEBUG
+					pr_debug(
 					       "failed to read porttype, result=%d\n",
 					       result);
 					goto failed;
@@ -1175,7 +1175,7 @@ int prism2mgmt_wlansniff(wlandevice_t *wlandev, void *msgp)
 								  &(hw->
 								    presniff_wepflags));
 				if (result) {
-					printk(KERN_DEBUG
+					pr_debug(
 					       "failed to read wepflags, result=%d\n",
 					       result);
 					goto failed;
@@ -1183,7 +1183,7 @@ int prism2mgmt_wlansniff(wlandevice_t *wlandev, void *msgp)
 				hfa384x_drvr_stop(hw);
 				result = hfa384x_drvr_start(hw);
 				if (result) {
-					printk(KERN_DEBUG
+					pr_debug(
 					       "failed to restart the card for sniffing, result=%d\n",
 					       result);
 					goto failed;
@@ -1192,7 +1192,7 @@ int prism2mgmt_wlansniff(wlandevice_t *wlandev, void *msgp)
 				/* Disable the port */
 				result = hfa384x_drvr_disable(hw, 0);
 				if (result) {
-					printk(KERN_DEBUG
+					pr_debug(
 					       "failed to enable port for sniffing, result=%d\n",
 					       result);
 					goto failed;
@@ -1210,7 +1210,7 @@ int prism2mgmt_wlansniff(wlandevice_t *wlandev, void *msgp)
 		hw->sniff_channel = word;
 
 		if (result) {
-			printk(KERN_DEBUG
+			pr_debug(
 			       "failed to set channel %d, result=%d\n",
 			       word, result);
 			goto failed;
@@ -1224,7 +1224,7 @@ int prism2mgmt_wlansniff(wlandevice_t *wlandev, void *msgp)
 							  HFA384x_RID_CNFPORTTYPE,
 							  word);
 			if (result) {
-				printk(KERN_DEBUG
+				pr_debug(
 				       "failed to set porttype %d, result=%d\n",
 				       word, result);
 				goto failed;
@@ -1243,7 +1243,7 @@ int prism2mgmt_wlansniff(wlandevice_t *wlandev, void *msgp)
 			}
 
 			if (result) {
-				printk(KERN_DEBUG
+				pr_debug(
 				       "failed to set wepflags=0x%04x, result=%d\n",
 				       word, result);
 				goto failed;
@@ -1269,7 +1269,7 @@ int prism2mgmt_wlansniff(wlandevice_t *wlandev, void *msgp)
 		/* Enable the port */
 		result = hfa384x_drvr_enable(hw, 0);
 		if (result) {
-			printk(KERN_DEBUG
+			pr_debug(
 			       "failed to enable port for sniffing, result=%d\n",
 			       result);
 			goto failed;
@@ -1277,7 +1277,7 @@ int prism2mgmt_wlansniff(wlandevice_t *wlandev, void *msgp)
 		/* Enable monitor mode */
 		result = hfa384x_cmd_monitor(hw, HFA384x_MONITOR_ENABLE);
 		if (result) {
-			printk(KERN_DEBUG
+			pr_debug(
 			       "failed to enable monitor mode, result=%d\n",
 			       result);
 			goto failed;

commit 18c7f792be75c2430cbf16e22dca1ab6a9881a63
Author: Moritz Muehlenhoff <jmm@debian.org>
Date:   Wed Feb 18 19:50:07 2009 +0100

    Staging: wlan-ng: Replace local byteorder macros
    
    Replace hfa384x2host_16(), hfa384x2host_32(), host2hfa384x_16()
    and host2hfa384x_32() with standard byteorder macros.
    
    Signed-off-by: Moritz Muehlenhoff <jmm@debian.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/wlan-ng/prism2mgmt.c b/drivers/staging/wlan-ng/prism2mgmt.c
index 7dce05de1531..e7a7939b4280 100644
--- a/drivers/staging/wlan-ng/prism2mgmt.c
+++ b/drivers/staging/wlan-ng/prism2mgmt.c
@@ -172,7 +172,7 @@ int prism2mgmt_scan(wlandevice_t *wlandev, void *msgp)
 				     hw->ident_sta_fw.variant) >
 	    HFA384x_FIRMWARE_VERSION(1, 5, 0)) {
 		if (msg->scantype.data != P80211ENUM_scantype_active)
-			word = host2hfa384x_16(msg->maxchanneltime.data);
+			word = cpu_to_le16(msg->maxchanneltime.data);
 		else
 			word = 0;
 
@@ -187,7 +187,7 @@ int prism2mgmt_scan(wlandevice_t *wlandev, void *msgp)
 
 	/* set up the txrate to be 2MBPS. Should be fastest basicrate... */
 	word = HFA384x_RATEBIT_2;
-	scanreq.txRate = host2hfa384x_16(word);
+	scanreq.txRate = cpu_to_le16(word);
 
 	/* set up the channel list */
 	word = 0;
@@ -198,10 +198,10 @@ int prism2mgmt_scan(wlandevice_t *wlandev, void *msgp)
 		/* channel 1 is BIT 0 ... channel 14 is BIT 13 */
 		word |= (1 << (channel - 1));
 	}
-	scanreq.channelList = host2hfa384x_16(word);
+	scanreq.channelList = cpu_to_le16(word);
 
 	/* set up the ssid, if present. */
-	scanreq.ssid.len = host2hfa384x_16(msg->ssid.data.len);
+	scanreq.ssid.len = cpu_to_le16(msg->ssid.data.len);
 	memcpy(scanreq.ssid.data, msg->ssid.data.data, msg->ssid.data.len);
 
 	/* Enable the MAC port if it's not already enabled  */
@@ -230,7 +230,7 @@ int prism2mgmt_scan(wlandevice_t *wlandev, void *msgp)
 		/* Construct a bogus SSID and assign it to OwnSSID and
 		 * DesiredSSID
 		 */
-		wordbuf[0] = host2hfa384x_16(WLAN_SSID_MAXLEN);
+		wordbuf[0] = cpu_to_le16(WLAN_SSID_MAXLEN);
 		get_random_bytes(&wordbuf[1], WLAN_SSID_MAXLEN);
 		result = hfa384x_drvr_setconfig(hw, HFA384x_RID_CNFOWNSSID,
 						wordbuf,
@@ -399,8 +399,8 @@ int prism2mgmt_scan_results(wlandevice_t *wlandev, void *msgp)
 	/* signal and noise */
 	req->signal.status = P80211ENUM_msgitem_status_data_ok;
 	req->noise.status = P80211ENUM_msgitem_status_data_ok;
-	req->signal.data = hfa384x2host_16(item->sl);
-	req->noise.data = hfa384x2host_16(item->anl);
+	req->signal.data = le16_to_cpu(item->sl);
+	req->noise.data = le16_to_cpu(item->anl);
 
 	/* BSSID */
 	req->bssid.status = P80211ENUM_msgitem_status_data_ok;
@@ -409,7 +409,7 @@ int prism2mgmt_scan_results(wlandevice_t *wlandev, void *msgp)
 
 	/* SSID */
 	req->ssid.status = P80211ENUM_msgitem_status_data_ok;
-	req->ssid.data.len = hfa384x2host_16(item->ssid.len);
+	req->ssid.data.len = le16_to_cpu(item->ssid.len);
 	memcpy(req->ssid.data.data, item->ssid.data, req->ssid.data.len);
 
 	/* supported rates */
@@ -449,7 +449,7 @@ int prism2mgmt_scan_results(wlandevice_t *wlandev, void *msgp)
 
 	/* beacon period */
 	req->beaconperiod.status = P80211ENUM_msgitem_status_data_ok;
-	req->beaconperiod.data = hfa384x2host_16(item->bcnint);
+	req->beaconperiod.data = le16_to_cpu(item->bcnint);
 
 	/* timestamps */
 	req->timestamp.status = P80211ENUM_msgitem_status_data_ok;
@@ -459,14 +459,14 @@ int prism2mgmt_scan_results(wlandevice_t *wlandev, void *msgp)
 
 	/* atim window */
 	req->ibssatimwindow.status = P80211ENUM_msgitem_status_data_ok;
-	req->ibssatimwindow.data = hfa384x2host_16(item->atim);
+	req->ibssatimwindow.data = le16_to_cpu(item->atim);
 
 	/* Channel */
 	req->dschannel.status = P80211ENUM_msgitem_status_data_ok;
-	req->dschannel.data = hfa384x2host_16(item->chid);
+	req->dschannel.data = le16_to_cpu(item->chid);
 
 	/* capinfo bits */
-	count = hfa384x2host_16(item->capinfo);
+	count = le16_to_cpu(item->capinfo);
 
 	/* privacy flag */
 	req->privacy.status = P80211ENUM_msgitem_status_data_ok;

commit 465e7417b15348909606c3edce5f018818235a54
Author: Moritz Muehlenhoff <jmm@debian.org>
Date:   Mon Feb 9 19:33:44 2009 +0100

    Staging: wlan-ng: Remove the now empty wlan_compat.h
    
    Signed-off-by: Moritz Muehlenhoff <jmm@debian.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/wlan-ng/prism2mgmt.c b/drivers/staging/wlan-ng/prism2mgmt.c
index 8a36c09694da..7dce05de1531 100644
--- a/drivers/staging/wlan-ng/prism2mgmt.c
+++ b/drivers/staging/wlan-ng/prism2mgmt.c
@@ -73,8 +73,6 @@
 #include <linux/usb.h>
 #include <linux/bitops.h>
 
-#include "wlan_compat.h"
-
 /*================================================================*/
 /* Project Includes */
 

commit 450238eab0dfa656f32a3701d8de5fe5a1b4687d
Author: Moritz Muehlenhoff <jmm@debian.org>
Date:   Sun Feb 8 02:20:48 2009 +0100

    Staging: wlan-ng: prism2mgmt.c: Coding style cleanups
    
    Signed-off-by: Moritz Muehlenhoff <jmm@debian.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/wlan-ng/prism2mgmt.c b/drivers/staging/wlan-ng/prism2mgmt.c
index 953142ae9296..8a36c09694da 100644
--- a/drivers/staging/wlan-ng/prism2mgmt.c
+++ b/drivers/staging/wlan-ng/prism2mgmt.c
@@ -57,9 +57,6 @@
 * --------------------------------------------------------------------
 */
 
-/*================================================================*/
-/* System Includes */
-
 #include <linux/if_arp.h>
 #include <linux/module.h>
 #include <linux/kernel.h>
@@ -124,105 +121,112 @@
 ----------------------------------------------------------------*/
 int prism2mgmt_scan(wlandevice_t *wlandev, void *msgp)
 {
-	int 			result = 0;
-	hfa384x_t		*hw = wlandev->priv;
-	p80211msg_dot11req_scan_t	*msg = msgp;
-        u16                  roamingmode, word;
-	int                     i, timeout;
-	int                     istmpenable = 0;
-
-        hfa384x_HostScanRequest_data_t  scanreq;
-
-        /* gatekeeper check */
-        if (HFA384x_FIRMWARE_VERSION(hw->ident_sta_fw.major,
-                                     hw->ident_sta_fw.minor,
-                                     hw->ident_sta_fw.variant) <
-            HFA384x_FIRMWARE_VERSION(1,3,2)) {
-		printk(KERN_ERR "HostScan not supported with current firmware (<1.3.2).\n");
-                result = 1;
-                msg->resultcode.data = P80211ENUM_resultcode_not_supported;
+	int result = 0;
+	hfa384x_t *hw = wlandev->priv;
+	p80211msg_dot11req_scan_t *msg = msgp;
+	u16 roamingmode, word;
+	int i, timeout;
+	int istmpenable = 0;
+
+	hfa384x_HostScanRequest_data_t scanreq;
+
+	/* gatekeeper check */
+	if (HFA384x_FIRMWARE_VERSION(hw->ident_sta_fw.major,
+				     hw->ident_sta_fw.minor,
+				     hw->ident_sta_fw.variant) <
+	    HFA384x_FIRMWARE_VERSION(1, 3, 2)) {
+		printk(KERN_ERR
+		       "HostScan not supported with current firmware (<1.3.2).\n");
+		result = 1;
+		msg->resultcode.data = P80211ENUM_resultcode_not_supported;
+		goto exit;
+	}
+
+	memset(&scanreq, 0, sizeof(scanreq));
+
+	/* save current roaming mode */
+	result = hfa384x_drvr_getconfig16(hw,
+					  HFA384x_RID_CNFROAMINGMODE,
+					  &roamingmode);
+	if (result) {
+		printk(KERN_ERR "getconfig(ROAMMODE) failed. result=%d\n",
+		       result);
+		msg->resultcode.data =
+		    P80211ENUM_resultcode_implementation_failure;
 		goto exit;
 	}
 
-        memset(&scanreq, 0, sizeof(scanreq));
-
-        /* save current roaming mode */
-        result = hfa384x_drvr_getconfig16(hw,
-                        HFA384x_RID_CNFROAMINGMODE, &roamingmode);
-        if ( result ) {
-                printk(KERN_ERR "getconfig(ROAMMODE) failed. result=%d\n",
-                                result);
-                msg->resultcode.data =
-                        P80211ENUM_resultcode_implementation_failure;
-                goto exit;
-        }
-
-        /* drop into mode 3 for the scan */
-        result = hfa384x_drvr_setconfig16(hw,
-                        HFA384x_RID_CNFROAMINGMODE,
-			HFA384x_ROAMMODE_HOSTSCAN_HOSTROAM);
-        if ( result ) {
-                printk(KERN_ERR "setconfig(ROAMINGMODE) failed. result=%d\n",
-                                result);
-                msg->resultcode.data =
-                        P80211ENUM_resultcode_implementation_failure;
-                goto exit;
-        }
-
-        /* active or passive? */
-        if (HFA384x_FIRMWARE_VERSION(hw->ident_sta_fw.major,
-                                     hw->ident_sta_fw.minor,
-                                     hw->ident_sta_fw.variant) >
-            HFA384x_FIRMWARE_VERSION(1,5,0)) {
-                if (msg->scantype.data != P80211ENUM_scantype_active) {
-                        word = host2hfa384x_16(msg->maxchanneltime.data);
-                } else {
-                        word = 0;
-                }
-                result = hfa384x_drvr_setconfig16(hw, HFA384x_RID_CNFPASSIVESCANCTRL, word);
-                if ( result ) {
-                        printk(KERN_WARNING "Passive scan not supported with "
-					  "current firmware.  (<1.5.1)\n");
-                }
-        }
+	/* drop into mode 3 for the scan */
+	result = hfa384x_drvr_setconfig16(hw,
+					  HFA384x_RID_CNFROAMINGMODE,
+					  HFA384x_ROAMMODE_HOSTSCAN_HOSTROAM);
+	if (result) {
+		printk(KERN_ERR "setconfig(ROAMINGMODE) failed. result=%d\n",
+		       result);
+		msg->resultcode.data =
+		    P80211ENUM_resultcode_implementation_failure;
+		goto exit;
+	}
+
+	/* active or passive? */
+	if (HFA384x_FIRMWARE_VERSION(hw->ident_sta_fw.major,
+				     hw->ident_sta_fw.minor,
+				     hw->ident_sta_fw.variant) >
+	    HFA384x_FIRMWARE_VERSION(1, 5, 0)) {
+		if (msg->scantype.data != P80211ENUM_scantype_active)
+			word = host2hfa384x_16(msg->maxchanneltime.data);
+		else
+			word = 0;
+
+		result =
+		    hfa384x_drvr_setconfig16(hw, HFA384x_RID_CNFPASSIVESCANCTRL,
+					     word);
+		if (result) {
+			printk(KERN_WARNING "Passive scan not supported with "
+			       "current firmware.  (<1.5.1)\n");
+		}
+	}
 
 	/* set up the txrate to be 2MBPS. Should be fastest basicrate... */
 	word = HFA384x_RATEBIT_2;
 	scanreq.txRate = host2hfa384x_16(word);
 
-        /* set up the channel list */
-        word = 0;
-        for (i = 0; i < msg->channellist.data.len; i++) {
-                u8 channel = msg->channellist.data.data[i];
-                if (channel > 14) continue;
-                /* channel 1 is BIT 0 ... channel 14 is BIT 13 */
-                word |= (1 << (channel-1));
-        }
-        scanreq.channelList = host2hfa384x_16(word);
+	/* set up the channel list */
+	word = 0;
+	for (i = 0; i < msg->channellist.data.len; i++) {
+		u8 channel = msg->channellist.data.data[i];
+		if (channel > 14)
+			continue;
+		/* channel 1 is BIT 0 ... channel 14 is BIT 13 */
+		word |= (1 << (channel - 1));
+	}
+	scanreq.channelList = host2hfa384x_16(word);
 
-        /* set up the ssid, if present. */
-        scanreq.ssid.len = host2hfa384x_16(msg->ssid.data.len);
-        memcpy(scanreq.ssid.data, msg->ssid.data.data, msg->ssid.data.len);
+	/* set up the ssid, if present. */
+	scanreq.ssid.len = host2hfa384x_16(msg->ssid.data.len);
+	memcpy(scanreq.ssid.data, msg->ssid.data.data, msg->ssid.data.len);
 
 	/* Enable the MAC port if it's not already enabled  */
 	result = hfa384x_drvr_getconfig16(hw, HFA384x_RID_PORTSTATUS, &word);
-	if ( result ) {
+	if (result) {
 		printk(KERN_ERR "getconfig(PORTSTATUS) failed. "
-				"result=%d\n", result);
+		       "result=%d\n", result);
 		msg->resultcode.data =
-			P80211ENUM_resultcode_implementation_failure;
+		    P80211ENUM_resultcode_implementation_failure;
 		goto exit;
 	}
 	if (word == HFA384x_PORTSTATUS_DISABLED) {
 		u16 wordbuf[17];
 
 		result = hfa384x_drvr_setconfig16(hw,
-			HFA384x_RID_CNFROAMINGMODE,
-			HFA384x_ROAMMODE_HOSTSCAN_HOSTROAM);
-		if ( result ) {
-			printk(KERN_ERR "setconfig(ROAMINGMODE) failed. result=%d\n", result);
+						  HFA384x_RID_CNFROAMINGMODE,
+						  HFA384x_ROAMMODE_HOSTSCAN_HOSTROAM);
+		if (result) {
+			printk(KERN_ERR
+			       "setconfig(ROAMINGMODE) failed. result=%d\n",
+			       result);
 			msg->resultcode.data =
-				P80211ENUM_resultcode_implementation_failure;
+			    P80211ENUM_resultcode_implementation_failure;
 			goto exit;
 		}
 		/* Construct a bogus SSID and assign it to OwnSSID and
@@ -230,73 +234,75 @@ int prism2mgmt_scan(wlandevice_t *wlandev, void *msgp)
 		 */
 		wordbuf[0] = host2hfa384x_16(WLAN_SSID_MAXLEN);
 		get_random_bytes(&wordbuf[1], WLAN_SSID_MAXLEN);
-		result = hfa384x_drvr_setconfig( hw, HFA384x_RID_CNFOWNSSID,
-				wordbuf, HFA384x_RID_CNFOWNSSID_LEN);
-		if ( result ) {
+		result = hfa384x_drvr_setconfig(hw, HFA384x_RID_CNFOWNSSID,
+						wordbuf,
+						HFA384x_RID_CNFOWNSSID_LEN);
+		if (result) {
 			printk(KERN_ERR "Failed to set OwnSSID.\n");
 			msg->resultcode.data =
-				P80211ENUM_resultcode_implementation_failure;
+			    P80211ENUM_resultcode_implementation_failure;
 			goto exit;
 		}
-		result = hfa384x_drvr_setconfig( hw, HFA384x_RID_CNFDESIREDSSID,
-				wordbuf, HFA384x_RID_CNFDESIREDSSID_LEN);
-		if ( result ) {
+		result = hfa384x_drvr_setconfig(hw, HFA384x_RID_CNFDESIREDSSID,
+						wordbuf,
+						HFA384x_RID_CNFDESIREDSSID_LEN);
+		if (result) {
 			printk(KERN_ERR "Failed to set DesiredSSID.\n");
 			msg->resultcode.data =
-				P80211ENUM_resultcode_implementation_failure;
+			    P80211ENUM_resultcode_implementation_failure;
 			goto exit;
 		}
 		/* bsstype */
 		result = hfa384x_drvr_setconfig16(hw,
-				HFA384x_RID_CNFPORTTYPE,
-				HFA384x_PORTTYPE_IBSS);
-		if ( result ) {
+						  HFA384x_RID_CNFPORTTYPE,
+						  HFA384x_PORTTYPE_IBSS);
+		if (result) {
 			printk(KERN_ERR "Failed to set CNFPORTTYPE.\n");
 			msg->resultcode.data =
-				P80211ENUM_resultcode_implementation_failure;
+			    P80211ENUM_resultcode_implementation_failure;
 			goto exit;
 		}
 		/* ibss options */
 		result = hfa384x_drvr_setconfig16(hw,
-				HFA384x_RID_CREATEIBSS,
-				HFA384x_CREATEIBSS_JOINCREATEIBSS);
-		if ( result ) {
+						  HFA384x_RID_CREATEIBSS,
+						  HFA384x_CREATEIBSS_JOINCREATEIBSS);
+		if (result) {
 			printk(KERN_ERR "Failed to set CREATEIBSS.\n");
 			msg->resultcode.data =
-				P80211ENUM_resultcode_implementation_failure;
+			    P80211ENUM_resultcode_implementation_failure;
 			goto exit;
 		}
 		result = hfa384x_drvr_enable(hw, 0);
-		if ( result ) {
+		if (result) {
 			printk(KERN_ERR "drvr_enable(0) failed. "
-					"result=%d\n", result);
+			       "result=%d\n", result);
 			msg->resultcode.data =
-			P80211ENUM_resultcode_implementation_failure;
+			    P80211ENUM_resultcode_implementation_failure;
 			goto exit;
 		}
 		istmpenable = 1;
 	}
 
-        /* Figure out our timeout first Kus, then HZ */
-        timeout = msg->channellist.data.len * msg->maxchanneltime.data;
-	timeout = (timeout * HZ)/1000;
+	/* Figure out our timeout first Kus, then HZ */
+	timeout = msg->channellist.data.len * msg->maxchanneltime.data;
+	timeout = (timeout * HZ) / 1000;
 
-        /* Issue the scan request */
-        hw->scanflag = 0;
+	/* Issue the scan request */
+	hw->scanflag = 0;
 
-        result = hfa384x_drvr_setconfig( hw,
-                        HFA384x_RID_HOSTSCAN, &scanreq,
-                        sizeof(hfa384x_HostScanRequest_data_t));
-        if ( result ) {
-                printk(KERN_ERR "setconfig(SCANREQUEST) failed. result=%d\n",
-                                result);
-                msg->resultcode.data =
-                        P80211ENUM_resultcode_implementation_failure;
-                goto exit;
-        }
+	result = hfa384x_drvr_setconfig(hw,
+					HFA384x_RID_HOSTSCAN, &scanreq,
+					sizeof(hfa384x_HostScanRequest_data_t));
+	if (result) {
+		printk(KERN_ERR "setconfig(SCANREQUEST) failed. result=%d\n",
+		       result);
+		msg->resultcode.data =
+		    P80211ENUM_resultcode_implementation_failure;
+		goto exit;
+	}
 
-        /* sleep until info frame arrives */
-        wait_event_interruptible_timeout(hw->cmdq, hw->scanflag, timeout);
+	/* sleep until info frame arrives */
+	wait_event_interruptible_timeout(hw->cmdq, hw->scanflag, timeout);
 
 	msg->numbss.status = P80211ENUM_msgitem_status_data_ok;
 	if (hw->scanflag == -1)
@@ -304,16 +310,16 @@ int prism2mgmt_scan(wlandevice_t *wlandev, void *msgp)
 
 	msg->numbss.data = hw->scanflag;
 
-        hw->scanflag = 0;
+	hw->scanflag = 0;
 
 	/* Disable port if we temporarily enabled it. */
 	if (istmpenable) {
 		result = hfa384x_drvr_disable(hw, 0);
-		if ( result ) {
+		if (result) {
 			printk(KERN_ERR "drvr_disable(0) failed. "
-					"result=%d\n", result);
+			       "result=%d\n", result);
 			msg->resultcode.data =
-			P80211ENUM_resultcode_implementation_failure;
+			    P80211ENUM_resultcode_implementation_failure;
 			goto exit;
 		}
 	}
@@ -321,24 +327,23 @@ int prism2mgmt_scan(wlandevice_t *wlandev, void *msgp)
 	/* restore original roaming mode */
 	result = hfa384x_drvr_setconfig16(hw, HFA384x_RID_CNFROAMINGMODE,
 					  roamingmode);
-        if ( result ) {
-                printk(KERN_ERR "setconfig(ROAMMODE) failed. result=%d\n",
-                                result);
-                msg->resultcode.data =
-                        P80211ENUM_resultcode_implementation_failure;
-                goto exit;
-        }
-
-        result = 0;
-        msg->resultcode.data = P80211ENUM_resultcode_success;
-
- exit:
+	if (result) {
+		printk(KERN_ERR "setconfig(ROAMMODE) failed. result=%d\n",
+		       result);
+		msg->resultcode.data =
+		    P80211ENUM_resultcode_implementation_failure;
+		goto exit;
+	}
+
+	result = 0;
+	msg->resultcode.data = P80211ENUM_resultcode_success;
+
+exit:
 	msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;
 
 	return result;
 }
 
-
 /*----------------------------------------------------------------
 * prism2mgmt_scan_results
 *
@@ -361,30 +366,32 @@ int prism2mgmt_scan(wlandevice_t *wlandev, void *msgp)
 ----------------------------------------------------------------*/
 int prism2mgmt_scan_results(wlandevice_t *wlandev, void *msgp)
 {
-	int 			result = 0;
-        p80211msg_dot11req_scan_results_t       *req;
-	hfa384x_t		*hw = wlandev->priv;
+	int result = 0;
+	p80211msg_dot11req_scan_results_t *req;
+	hfa384x_t *hw = wlandev->priv;
 	hfa384x_HScanResultSub_t *item = NULL;
 
 	int count;
 
-        req = (p80211msg_dot11req_scan_results_t *) msgp;
+	req = (p80211msg_dot11req_scan_results_t *) msgp;
 
 	req->resultcode.status = P80211ENUM_msgitem_status_data_ok;
 
-	if (! hw->scanresults) {
-		printk(KERN_ERR "dot11req_scan_results can only be used after a successful dot11req_scan.\n");
+	if (!hw->scanresults) {
+		printk(KERN_ERR
+		       "dot11req_scan_results can only be used after a successful dot11req_scan.\n");
 		result = 2;
 		req->resultcode.data = P80211ENUM_resultcode_invalid_parameters;
 		goto exit;
 	}
 
-        count = (hw->scanresults->framelen - 3) / 32;
-	if (count > 32)  count = 32;
+	count = (hw->scanresults->framelen - 3) / 32;
+	if (count > 32)
+		count = 32;
 
 	if (req->bssindex.data >= count) {
 		pr_debug("requested index (%d) out of range (%d)\n",
-				req->bssindex.data, count);
+		       req->bssindex.data, count);
 		result = 2;
 		req->resultcode.data = P80211ENUM_resultcode_invalid_parameters;
 		goto exit;
@@ -408,9 +415,9 @@ int prism2mgmt_scan_results(wlandevice_t *wlandev, void *msgp)
 	memcpy(req->ssid.data.data, item->ssid.data, req->ssid.data.len);
 
 	/* supported rates */
-        for (count = 0; count < 10 ; count++)
-                if (item->supprates[count] == 0)
-                        break;
+	for (count = 0; count < 10; count++)
+		if (item->supprates[count] == 0)
+			break;
 
 #define REQBASICRATE(N) \
 	if ((count >= N) && DOT11_RATE5_ISBASIC_GET(item->supprates[(N)-1])) { \
@@ -476,24 +483,14 @@ int prism2mgmt_scan_results(wlandevice_t *wlandev, void *msgp)
 	req->cfpollreq.data = WLAN_GET_MGMT_CAP_INFO_CFPOLLREQ(count);
 
 	/* bsstype */
-	req->bsstype.status =  P80211ENUM_msgitem_status_data_ok;
+	req->bsstype.status = P80211ENUM_msgitem_status_data_ok;
 	req->bsstype.data = (WLAN_GET_MGMT_CAP_INFO_ESS(count)) ?
-		P80211ENUM_bsstype_infrastructure :
-		P80211ENUM_bsstype_independent;
-
-	// item->proberesp_rate
-/*
-	req->fhdwelltime
-	req->fhhopset
-	req->fhhoppattern
-	req->fhhopindex
-        req->cfpdurremaining
-*/
+	    P80211ENUM_bsstype_infrastructure : P80211ENUM_bsstype_independent;
 
 	result = 0;
 	req->resultcode.data = P80211ENUM_resultcode_success;
 
- exit:
+exit:
 	return result;
 }
 
@@ -518,14 +515,14 @@ int prism2mgmt_scan_results(wlandevice_t *wlandev, void *msgp)
 ----------------------------------------------------------------*/
 int prism2mgmt_start(wlandevice_t *wlandev, void *msgp)
 {
-	int 			result = 0;
-	hfa384x_t		*hw = wlandev->priv;
-	p80211msg_dot11req_start_t	*msg = msgp;
+	int result = 0;
+	hfa384x_t *hw = wlandev->priv;
+	p80211msg_dot11req_start_t *msg = msgp;
 
-	p80211pstrd_t		*pstr;
-	u8			bytebuf[80];
-	hfa384x_bytestr_t	*p2bytestr = (hfa384x_bytestr_t*)bytebuf;
-	u16			word;
+	p80211pstrd_t *pstr;
+	u8 bytebuf[80];
+	hfa384x_bytestr_t *p2bytestr = (hfa384x_bytestr_t *) bytebuf;
+	u16 word;
 
 	wlandev->macmode = WLAN_MACMODE_NONE;
 
@@ -537,7 +534,7 @@ int prism2mgmt_start(wlandevice_t *wlandev, void *msgp)
 	if (HFA384x_FIRMWARE_VERSION(hw->ident_sta_fw.major,
 				     hw->ident_sta_fw.minor,
 				     hw->ident_sta_fw.variant) <
-	    HFA384x_FIRMWARE_VERSION(0,8,3)) {
+	    HFA384x_FIRMWARE_VERSION(0, 8, 3)) {
 		/* Ad-Hoc not quite supported on Prism2 */
 		msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;
 		msg->resultcode.data = P80211ENUM_resultcode_not_supported;
@@ -549,17 +546,18 @@ int prism2mgmt_start(wlandevice_t *wlandev, void *msgp)
 	/*** STATION ***/
 	/* Set the REQUIRED config items */
 	/* SSID */
-	pstr = (p80211pstrd_t*)&(msg->ssid.data);
+	pstr = (p80211pstrd_t *)&(msg->ssid.data);
 	prism2mgmt_pstr2bytestr(p2bytestr, pstr);
-	result = hfa384x_drvr_setconfig( hw, HFA384x_RID_CNFOWNSSID,
-					 bytebuf, HFA384x_RID_CNFOWNSSID_LEN);
-	if ( result ) {
+	result = hfa384x_drvr_setconfig(hw, HFA384x_RID_CNFOWNSSID,
+					bytebuf, HFA384x_RID_CNFOWNSSID_LEN);
+	if (result) {
 		printk(KERN_ERR "Failed to set CnfOwnSSID\n");
 		goto failed;
 	}
-	result = hfa384x_drvr_setconfig( hw, HFA384x_RID_CNFDESIREDSSID,
-					 bytebuf, HFA384x_RID_CNFDESIREDSSID_LEN);
-	if ( result ) {
+	result = hfa384x_drvr_setconfig(hw, HFA384x_RID_CNFDESIREDSSID,
+					bytebuf,
+					HFA384x_RID_CNFDESIREDSSID_LEN);
+	if (result) {
 		printk(KERN_ERR "Failed to set CnfDesiredSSID\n");
 		goto failed;
 	}
@@ -571,7 +569,7 @@ int prism2mgmt_start(wlandevice_t *wlandev, void *msgp)
 	/* beacon period */
 	word = msg->beaconperiod.data;
 	result = hfa384x_drvr_setconfig16(hw, HFA384x_RID_CNFAPBCNint, word);
-	if ( result ) {
+	if (result) {
 		printk(KERN_ERR "Failed to set beacon period=%d.\n", word);
 		goto failed;
 	}
@@ -579,76 +577,76 @@ int prism2mgmt_start(wlandevice_t *wlandev, void *msgp)
 	/* dschannel */
 	word = msg->dschannel.data;
 	result = hfa384x_drvr_setconfig16(hw, HFA384x_RID_CNFOWNCHANNEL, word);
-	if ( result ) {
+	if (result) {
 		printk(KERN_ERR "Failed to set channel=%d.\n", word);
 		goto failed;
 	}
 	/* Basic rates */
 	word = p80211rate_to_p2bit(msg->basicrate1.data);
-	if ( msg->basicrate2.status == P80211ENUM_msgitem_status_data_ok ) {
+	if (msg->basicrate2.status == P80211ENUM_msgitem_status_data_ok)
 		word |= p80211rate_to_p2bit(msg->basicrate2.data);
-	}
-	if ( msg->basicrate3.status == P80211ENUM_msgitem_status_data_ok ) {
+
+	if (msg->basicrate3.status == P80211ENUM_msgitem_status_data_ok)
 		word |= p80211rate_to_p2bit(msg->basicrate3.data);
-	}
-	if ( msg->basicrate4.status == P80211ENUM_msgitem_status_data_ok ) {
+
+	if (msg->basicrate4.status == P80211ENUM_msgitem_status_data_ok)
 		word |= p80211rate_to_p2bit(msg->basicrate4.data);
-	}
-	if ( msg->basicrate5.status == P80211ENUM_msgitem_status_data_ok ) {
+
+	if (msg->basicrate5.status == P80211ENUM_msgitem_status_data_ok)
 		word |= p80211rate_to_p2bit(msg->basicrate5.data);
-	}
-	if ( msg->basicrate6.status == P80211ENUM_msgitem_status_data_ok ) {
+
+	if (msg->basicrate6.status == P80211ENUM_msgitem_status_data_ok)
 		word |= p80211rate_to_p2bit(msg->basicrate6.data);
-	}
-	if ( msg->basicrate7.status == P80211ENUM_msgitem_status_data_ok ) {
+
+	if (msg->basicrate7.status == P80211ENUM_msgitem_status_data_ok)
 		word |= p80211rate_to_p2bit(msg->basicrate7.data);
-	}
-	if ( msg->basicrate8.status == P80211ENUM_msgitem_status_data_ok ) {
+
+	if (msg->basicrate8.status == P80211ENUM_msgitem_status_data_ok)
 		word |= p80211rate_to_p2bit(msg->basicrate8.data);
-	}
+
 	result = hfa384x_drvr_setconfig16(hw, HFA384x_RID_CNFBASICRATES, word);
-	if ( result ) {
+	if (result) {
 		printk(KERN_ERR "Failed to set basicrates=%d.\n", word);
 		goto failed;
 	}
 
 	/* Operational rates (supprates and txratecontrol) */
 	word = p80211rate_to_p2bit(msg->operationalrate1.data);
-	if ( msg->operationalrate2.status == P80211ENUM_msgitem_status_data_ok ) {
+	if (msg->operationalrate2.status == P80211ENUM_msgitem_status_data_ok)
 		word |= p80211rate_to_p2bit(msg->operationalrate2.data);
-	}
-	if ( msg->operationalrate3.status == P80211ENUM_msgitem_status_data_ok ) {
+
+	if (msg->operationalrate3.status == P80211ENUM_msgitem_status_data_ok)
 		word |= p80211rate_to_p2bit(msg->operationalrate3.data);
-	}
-	if ( msg->operationalrate4.status == P80211ENUM_msgitem_status_data_ok ) {
+
+	if (msg->operationalrate4.status == P80211ENUM_msgitem_status_data_ok)
 		word |= p80211rate_to_p2bit(msg->operationalrate4.data);
-	}
-	if ( msg->operationalrate5.status == P80211ENUM_msgitem_status_data_ok ) {
+
+	if (msg->operationalrate5.status == P80211ENUM_msgitem_status_data_ok)
 		word |= p80211rate_to_p2bit(msg->operationalrate5.data);
-	}
-	if ( msg->operationalrate6.status == P80211ENUM_msgitem_status_data_ok ) {
+
+	if (msg->operationalrate6.status == P80211ENUM_msgitem_status_data_ok)
 		word |= p80211rate_to_p2bit(msg->operationalrate6.data);
-	}
-	if ( msg->operationalrate7.status == P80211ENUM_msgitem_status_data_ok ) {
+
+	if (msg->operationalrate7.status == P80211ENUM_msgitem_status_data_ok)
 		word |= p80211rate_to_p2bit(msg->operationalrate7.data);
-	}
-	if ( msg->operationalrate8.status == P80211ENUM_msgitem_status_data_ok ) {
+
+	if (msg->operationalrate8.status == P80211ENUM_msgitem_status_data_ok)
 		word |= p80211rate_to_p2bit(msg->operationalrate8.data);
-	}
+
 	result = hfa384x_drvr_setconfig16(hw, HFA384x_RID_CNFSUPPRATES, word);
-	if ( result ) {
+	if (result) {
 		printk(KERN_ERR "Failed to set supprates=%d.\n", word);
 		goto failed;
 	}
 
 	result = hfa384x_drvr_setconfig16(hw, HFA384x_RID_TXRATECNTL, word);
-	if ( result ) {
+	if (result) {
 		printk(KERN_ERR "Failed to set txrates=%d.\n", word);
 		goto failed;
 	}
 
 	/* Set the macmode so the frame setup code knows what to do */
-	if ( msg->bsstype.data == P80211ENUM_bsstype_independent ) {
+	if (msg->bsstype.data == P80211ENUM_bsstype_independent) {
 		wlandev->macmode = WLAN_MACMODE_IBSS_STA;
 		/* lets extend the data length a bit */
 		hfa384x_drvr_setconfig16(hw, HFA384x_RID_CNFMAXDATALEN, 2304);
@@ -656,7 +654,7 @@ int prism2mgmt_start(wlandevice_t *wlandev, void *msgp)
 
 	/* Enable the Port */
 	result = hfa384x_drvr_enable(hw, 0);
-	if ( result ) {
+	if (result) {
 		printk(KERN_ERR "Enable macport failed, result=%d.\n", result);
 		goto failed;
 	}
@@ -694,38 +692,35 @@ int prism2mgmt_start(wlandevice_t *wlandev, void *msgp)
 ----------------------------------------------------------------*/
 int prism2mgmt_readpda(wlandevice_t *wlandev, void *msgp)
 {
-	hfa384x_t		*hw = wlandev->priv;
-	p80211msg_p2req_readpda_t	*msg = msgp;
-	int				result;
+	hfa384x_t *hw = wlandev->priv;
+	p80211msg_p2req_readpda_t *msg = msgp;
+	int result;
 
 	/* We only support collecting the PDA when in the FWLOAD
 	 * state.
 	 */
 	if (wlandev->msdstate != WLAN_MSD_FWLOAD) {
 		printk(KERN_ERR
-			"PDA may only be read "
-			"in the fwload state.\n");
+		       "PDA may only be read " "in the fwload state.\n");
 		msg->resultcode.data =
-			P80211ENUM_resultcode_implementation_failure;
+		    P80211ENUM_resultcode_implementation_failure;
 		msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;
 	} else {
 		/*  Call drvr_readpda(), it handles the auxport enable
 		 *  and validating the returned PDA.
 		 */
-		result = hfa384x_drvr_readpda(
-			hw,
-			msg->pda.data,
-			HFA384x_PDA_LEN_MAX);
+		result = hfa384x_drvr_readpda(hw,
+					      msg->pda.data,
+					      HFA384x_PDA_LEN_MAX);
 		if (result) {
 			printk(KERN_ERR
-				"hfa384x_drvr_readpda() failed, "
-				"result=%d\n",
-				result);
+			       "hfa384x_drvr_readpda() failed, "
+			       "result=%d\n", result);
 
 			msg->resultcode.data =
-				P80211ENUM_resultcode_implementation_failure;
+			    P80211ENUM_resultcode_implementation_failure;
 			msg->resultcode.status =
-				P80211ENUM_msgitem_status_data_ok;
+			    P80211ENUM_msgitem_status_data_ok;
 			return 0;
 		}
 		msg->pda.status = P80211ENUM_msgitem_status_data_ok;
@@ -763,28 +758,29 @@ int prism2mgmt_readpda(wlandevice_t *wlandev, void *msgp)
 ----------------------------------------------------------------*/
 int prism2mgmt_ramdl_state(wlandevice_t *wlandev, void *msgp)
 {
-	hfa384x_t		*hw = wlandev->priv;
-	p80211msg_p2req_ramdl_state_t	*msg = msgp;
+	hfa384x_t *hw = wlandev->priv;
+	p80211msg_p2req_ramdl_state_t *msg = msgp;
 
 	if (wlandev->msdstate != WLAN_MSD_FWLOAD) {
 		printk(KERN_ERR
-			"ramdl_state(): may only be called "
-			"in the fwload state.\n");
+		       "ramdl_state(): may only be called "
+		       "in the fwload state.\n");
 		msg->resultcode.data =
-			P80211ENUM_resultcode_implementation_failure;
+		    P80211ENUM_resultcode_implementation_failure;
 		msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;
 		return 0;
 	}
 
 	/*
-	** Note: Interrupts are locked out if this is an AP and are NOT
-	** locked out if this is a station.
-	*/
+	 ** Note: Interrupts are locked out if this is an AP and are NOT
+	 ** locked out if this is a station.
+	 */
 
 	msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;
-	if  ( msg->enable.data == P80211ENUM_truth_true ) {
-		if ( hfa384x_drvr_ramdl_enable(hw, msg->exeaddr.data) ) {
-			msg->resultcode.data = P80211ENUM_resultcode_implementation_failure;
+	if (msg->enable.data == P80211ENUM_truth_true) {
+		if (hfa384x_drvr_ramdl_enable(hw, msg->exeaddr.data)) {
+			msg->resultcode.data =
+			    P80211ENUM_resultcode_implementation_failure;
 		} else {
 			msg->resultcode.data = P80211ENUM_resultcode_success;
 		}
@@ -796,7 +792,6 @@ int prism2mgmt_ramdl_state(wlandevice_t *wlandev, void *msgp)
 	return 0;
 }
 
-
 /*----------------------------------------------------------------
 * prism2mgmt_ramdl_write
 *
@@ -819,42 +814,41 @@ int prism2mgmt_ramdl_state(wlandevice_t *wlandev, void *msgp)
 ----------------------------------------------------------------*/
 int prism2mgmt_ramdl_write(wlandevice_t *wlandev, void *msgp)
 {
-	hfa384x_t		*hw = wlandev->priv;
-	p80211msg_p2req_ramdl_write_t	*msg = msgp;
-	u32			addr;
-	u32			len;
-	u8			*buf;
+	hfa384x_t *hw = wlandev->priv;
+	p80211msg_p2req_ramdl_write_t *msg = msgp;
+	u32 addr;
+	u32 len;
+	u8 *buf;
 
 	if (wlandev->msdstate != WLAN_MSD_FWLOAD) {
 		printk(KERN_ERR
-			"ramdl_write(): may only be called "
-			"in the fwload state.\n");
+		       "ramdl_write(): may only be called "
+		       "in the fwload state.\n");
 		msg->resultcode.data =
-			P80211ENUM_resultcode_implementation_failure;
+		    P80211ENUM_resultcode_implementation_failure;
 		msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;
 		return 0;
 	}
 
 	msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;
 	/* first validate the length */
-	if  ( msg->len.data > sizeof(msg->data.data) ) {
-		msg->resultcode.status = P80211ENUM_resultcode_invalid_parameters;
+	if (msg->len.data > sizeof(msg->data.data)) {
+		msg->resultcode.status =
+		    P80211ENUM_resultcode_invalid_parameters;
 		return 0;
 	}
 	/* call the hfa384x function to do the write */
 	addr = msg->addr.data;
 	len = msg->len.data;
 	buf = msg->data.data;
-	if ( hfa384x_drvr_ramdl_write(hw, addr, buf, len) ) {
+	if (hfa384x_drvr_ramdl_write(hw, addr, buf, len))
 		msg->resultcode.data = P80211ENUM_resultcode_refused;
 
-	}
 	msg->resultcode.data = P80211ENUM_resultcode_success;
 
 	return 0;
 }
 
-
 /*----------------------------------------------------------------
 * prism2mgmt_flashdl_state
 *
@@ -882,29 +876,30 @@ int prism2mgmt_ramdl_write(wlandevice_t *wlandev, void *msgp)
 ----------------------------------------------------------------*/
 int prism2mgmt_flashdl_state(wlandevice_t *wlandev, void *msgp)
 {
-	int			result = 0;
-	hfa384x_t		*hw = wlandev->priv;
-	p80211msg_p2req_flashdl_state_t	*msg = msgp;
+	int result = 0;
+	hfa384x_t *hw = wlandev->priv;
+	p80211msg_p2req_flashdl_state_t *msg = msgp;
 
 	if (wlandev->msdstate != WLAN_MSD_FWLOAD) {
 		printk(KERN_ERR
-			"flashdl_state(): may only be called "
-			"in the fwload state.\n");
+		       "flashdl_state(): may only be called "
+		       "in the fwload state.\n");
 		msg->resultcode.data =
-			P80211ENUM_resultcode_implementation_failure;
+		    P80211ENUM_resultcode_implementation_failure;
 		msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;
 		return 0;
 	}
 
 	/*
-	** Note: Interrupts are locked out if this is an AP and are NOT
-	** locked out if this is a station.
-	*/
+	 ** Note: Interrupts are locked out if this is an AP and are NOT
+	 ** locked out if this is a station.
+	 */
 
 	msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;
-	if  ( msg->enable.data == P80211ENUM_truth_true ) {
-		if ( hfa384x_drvr_flashdl_enable(hw) ) {
-			msg->resultcode.data = P80211ENUM_resultcode_implementation_failure;
+	if (msg->enable.data == P80211ENUM_truth_true) {
+		if (hfa384x_drvr_flashdl_enable(hw)) {
+			msg->resultcode.data =
+			    P80211ENUM_resultcode_implementation_failure;
 		} else {
 			msg->resultcode.data = P80211ENUM_resultcode_success;
 		}
@@ -922,9 +917,9 @@ int prism2mgmt_flashdl_state(wlandevice_t *wlandev, void *msgp)
 		result = prism2sta_ifstate(wlandev, P80211ENUM_ifstate_fwload);
 		if (result != P80211ENUM_resultcode_success) {
 			printk(KERN_ERR "prism2sta_ifstate(fwload) failed,"
-				"P80211ENUM_resultcode=%d\n", result);
+			       "P80211ENUM_resultcode=%d\n", result);
 			msg->resultcode.data =
-				P80211ENUM_resultcode_implementation_failure;
+			    P80211ENUM_resultcode_implementation_failure;
 			result = -1;
 		}
 	}
@@ -932,7 +927,6 @@ int prism2mgmt_flashdl_state(wlandevice_t *wlandev, void *msgp)
 	return 0;
 }
 
-
 /*----------------------------------------------------------------
 * prism2mgmt_flashdl_write
 *
@@ -953,42 +947,41 @@ int prism2mgmt_flashdl_state(wlandevice_t *wlandev, void *msgp)
 ----------------------------------------------------------------*/
 int prism2mgmt_flashdl_write(wlandevice_t *wlandev, void *msgp)
 {
-	hfa384x_t		*hw = wlandev->priv;
-	p80211msg_p2req_flashdl_write_t	*msg = msgp;
-	u32			addr;
-	u32			len;
-	u8			*buf;
+	hfa384x_t *hw = wlandev->priv;
+	p80211msg_p2req_flashdl_write_t *msg = msgp;
+	u32 addr;
+	u32 len;
+	u8 *buf;
 
 	if (wlandev->msdstate != WLAN_MSD_FWLOAD) {
 		printk(KERN_ERR
-			"flashdl_write(): may only be called "
-			"in the fwload state.\n");
+		       "flashdl_write(): may only be called "
+		       "in the fwload state.\n");
 		msg->resultcode.data =
-			P80211ENUM_resultcode_implementation_failure;
+		    P80211ENUM_resultcode_implementation_failure;
 		msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;
 		return 0;
 	}
 
 	/*
-	** Note: Interrupts are locked out if this is an AP and are NOT
-	** locked out if this is a station.
-	*/
+	 ** Note: Interrupts are locked out if this is an AP and are NOT
+	 ** locked out if this is a station.
+	 */
 
 	msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;
 	/* first validate the length */
-	if  ( msg->len.data > sizeof(msg->data.data) ) {
+	if (msg->len.data > sizeof(msg->data.data)) {
 		msg->resultcode.status =
-			P80211ENUM_resultcode_invalid_parameters;
+		    P80211ENUM_resultcode_invalid_parameters;
 		return 0;
 	}
 	/* call the hfa384x function to do the write */
 	addr = msg->addr.data;
 	len = msg->len.data;
 	buf = msg->data.data;
-	if ( hfa384x_drvr_flashdl_write(hw, addr, buf, len) ) {
+	if (hfa384x_drvr_flashdl_write(hw, addr, buf, len))
 		msg->resultcode.data = P80211ENUM_resultcode_refused;
 
-	}
 	msg->resultcode.data = P80211ENUM_resultcode_success;
 
 	return 0;
@@ -1015,14 +1008,14 @@ int prism2mgmt_flashdl_write(wlandevice_t *wlandev, void *msgp)
 ----------------------------------------------------------------*/
 int prism2mgmt_autojoin(wlandevice_t *wlandev, void *msgp)
 {
-	hfa384x_t			*hw = wlandev->priv;
-	int 			result = 0;
-	u16			reg;
-	u16			port_type;
-	p80211msg_lnxreq_autojoin_t	*msg = msgp;
-	p80211pstrd_t		*pstr;
-	u8			bytebuf[256];
-	hfa384x_bytestr_t	*p2bytestr = (hfa384x_bytestr_t*)bytebuf;
+	hfa384x_t *hw = wlandev->priv;
+	int result = 0;
+	u16 reg;
+	u16 port_type;
+	p80211msg_lnxreq_autojoin_t *msg = msgp;
+	p80211pstrd_t *pstr;
+	u8 bytebuf[256];
+	hfa384x_bytestr_t *p2bytestr = (hfa384x_bytestr_t *) bytebuf;
 
 	wlandev->macmode = WLAN_MACMODE_NONE;
 
@@ -1037,20 +1030,20 @@ int prism2mgmt_autojoin(wlandevice_t *wlandev, void *msgp)
 	hfa384x_drvr_setconfig16(hw, HFA384x_RID_TXRATECNTL, 0x000f);
 
 	/* Set the auth type */
-	if ( msg->authtype.data == P80211ENUM_authalg_sharedkey ) {
+	if (msg->authtype.data == P80211ENUM_authalg_sharedkey)
 		reg = HFA384x_CNFAUTHENTICATION_SHAREDKEY;
-	} else {
+	else
 		reg = HFA384x_CNFAUTHENTICATION_OPENSYSTEM;
-	}
+
 	hfa384x_drvr_setconfig16(hw, HFA384x_RID_CNFAUTHENTICATION, reg);
 
 	/* Set the ssid */
 	memset(bytebuf, 0, 256);
-	pstr = (p80211pstrd_t*)&(msg->ssid.data);
+	pstr = (p80211pstrd_t *)&(msg->ssid.data);
 	prism2mgmt_pstr2bytestr(p2bytestr, pstr);
-        result = hfa384x_drvr_setconfig(
-			hw, HFA384x_RID_CNFDESIREDSSID,
-			bytebuf, HFA384x_RID_CNFDESIREDSSID_LEN);
+	result = hfa384x_drvr_setconfig(hw, HFA384x_RID_CNFDESIREDSSID,
+					bytebuf,
+					HFA384x_RID_CNFDESIREDSSID_LEN);
 	port_type = HFA384x_PORTTYPE_BSS;
 	/* Set the PortType */
 	hfa384x_drvr_setconfig16(hw, HFA384x_RID_CNFPORTTYPE, port_type);
@@ -1065,7 +1058,6 @@ int prism2mgmt_autojoin(wlandevice_t *wlandev, void *msgp)
 	return result;
 }
 
-
 /*----------------------------------------------------------------
 * prism2mgmt_wlansniff
 *
@@ -1087,36 +1079,36 @@ int prism2mgmt_autojoin(wlandevice_t *wlandev, void *msgp)
 ----------------------------------------------------------------*/
 int prism2mgmt_wlansniff(wlandevice_t *wlandev, void *msgp)
 {
-	int 			result = 0;
-	p80211msg_lnxreq_wlansniff_t	*msg = msgp;
+	int result = 0;
+	p80211msg_lnxreq_wlansniff_t *msg = msgp;
 
-	hfa384x_t			*hw = wlandev->priv;
-	u16			word;
+	hfa384x_t *hw = wlandev->priv;
+	u16 word;
 
 	msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;
-	switch (msg->enable.data)
-	{
+	switch (msg->enable.data) {
 	case P80211ENUM_truth_false:
 		/* Confirm that we're in monitor mode */
-		if ( wlandev->netdev->type == ARPHRD_ETHER ) {
-			msg->resultcode.data = P80211ENUM_resultcode_invalid_parameters;
+		if (wlandev->netdev->type == ARPHRD_ETHER) {
+			msg->resultcode.data =
+			    P80211ENUM_resultcode_invalid_parameters;
 			result = 0;
 			goto exit;
 		}
 		/* Disable monitor mode */
 		result = hfa384x_cmd_monitor(hw, HFA384x_MONITOR_DISABLE);
-		if ( result ) {
-			pr_debug(
-				"failed to disable monitor mode, result=%d\n",
-				result);
+		if (result) {
+			printk(KERN_DEBUG
+			       "failed to disable monitor mode, result=%d\n",
+			       result);
 			goto failed;
 		}
 		/* Disable port 0 */
 		result = hfa384x_drvr_disable(hw, 0);
-		if ( result ) {
-			pr_debug(
-			"failed to disable port 0 after sniffing, result=%d\n",
-			result);
+		if (result) {
+			printk(KERN_DEBUG
+			       "failed to disable port 0 after sniffing, result=%d\n",
+			       result);
 			goto failed;
 		}
 		/* Clear the driver state */
@@ -1124,32 +1116,34 @@ int prism2mgmt_wlansniff(wlandevice_t *wlandev, void *msgp)
 
 		/* Restore the wepflags */
 		result = hfa384x_drvr_setconfig16(hw,
-				HFA384x_RID_CNFWEPFLAGS,
-				hw->presniff_wepflags);
-		if ( result ) {
-			pr_debug(
-			"failed to restore wepflags=0x%04x, result=%d\n",
-			hw->presniff_wepflags,
-			result);
+						  HFA384x_RID_CNFWEPFLAGS,
+						  hw->presniff_wepflags);
+		if (result) {
+			printk(KERN_DEBUG
+			       "failed to restore wepflags=0x%04x, result=%d\n",
+			       hw->presniff_wepflags, result);
 			goto failed;
 		}
 
 		/* Set the port to its prior type and enable (if necessary) */
-		if (hw->presniff_port_type != 0 ) {
+		if (hw->presniff_port_type != 0) {
 			word = hw->presniff_port_type;
 			result = hfa384x_drvr_setconfig16(hw,
-				HFA384x_RID_CNFPORTTYPE, word);
-			if ( result ) {
-				pr_debug(
-				"failed to restore porttype, result=%d\n",
-				result);
+							  HFA384x_RID_CNFPORTTYPE,
+							  word);
+			if (result) {
+				printk(KERN_DEBUG
+				       "failed to restore porttype, result=%d\n",
+				       result);
 				goto failed;
 			}
 
 			/* Enable the port */
 			result = hfa384x_drvr_enable(hw, 0);
-			if ( result ) {
-				pr_debug("failed to enable port to presniff setting, result=%d\n", result);
+			if (result) {
+				printk(KERN_DEBUG
+				       "failed to enable port to presniff setting, result=%d\n",
+				       result);
 				goto failed;
 			}
 		} else {
@@ -1164,39 +1158,45 @@ int prism2mgmt_wlansniff(wlandevice_t *wlandev, void *msgp)
 		break;
 	case P80211ENUM_truth_true:
 		/* Disable the port (if enabled), only check Port 0 */
-		if ( hw->port_enabled[0]) {
+		if (hw->port_enabled[0]) {
 			if (wlandev->netdev->type == ARPHRD_ETHER) {
 				/* Save macport 0 state */
 				result = hfa384x_drvr_getconfig16(hw,
 								  HFA384x_RID_CNFPORTTYPE,
-								  &(hw->presniff_port_type));
-				if ( result ) {
-					pr_debug("failed to read porttype, result=%d\n", result);
+								  &(hw->
+								    presniff_port_type));
+				if (result) {
+					printk(KERN_DEBUG
+					       "failed to read porttype, result=%d\n",
+					       result);
 					goto failed;
 				}
 				/* Save the wepflags state */
 				result = hfa384x_drvr_getconfig16(hw,
 								  HFA384x_RID_CNFWEPFLAGS,
-								  &(hw->presniff_wepflags));
-				if ( result ) {
-					pr_debug("failed to read wepflags, result=%d\n", result);
+								  &(hw->
+								    presniff_wepflags));
+				if (result) {
+					printk(KERN_DEBUG
+					       "failed to read wepflags, result=%d\n",
+					       result);
 					goto failed;
 				}
 				hfa384x_drvr_stop(hw);
 				result = hfa384x_drvr_start(hw);
-				if ( result ) {
-					pr_debug(
-						       "failed to restart the card for sniffing, result=%d\n",
-						       result);
+				if (result) {
+					printk(KERN_DEBUG
+					       "failed to restart the card for sniffing, result=%d\n",
+					       result);
 					goto failed;
 				}
 			} else {
 				/* Disable the port */
 				result = hfa384x_drvr_disable(hw, 0);
-				if ( result ) {
-					pr_debug(
-						       "failed to enable port for sniffing, result=%d\n",
-						       result);
+				if (result) {
+					printk(KERN_DEBUG
+					       "failed to enable port for sniffing, result=%d\n",
+					       result);
 					goto failed;
 				}
 			}
@@ -1207,14 +1207,14 @@ int prism2mgmt_wlansniff(wlandevice_t *wlandev, void *msgp)
 		/* Set the channel we wish to sniff  */
 		word = msg->channel.data;
 		result = hfa384x_drvr_setconfig16(hw,
-						  HFA384x_RID_CNFOWNCHANNEL, word);
-		hw->sniff_channel=word;
+						  HFA384x_RID_CNFOWNCHANNEL,
+						  word);
+		hw->sniff_channel = word;
 
-		if ( result ) {
-			pr_debug(
-				       "failed to set channel %d, result=%d\n",
-					       word,
-				       result);
+		if (result) {
+			printk(KERN_DEBUG
+			       "failed to set channel %d, result=%d\n",
+			       word, result);
 			goto failed;
 		}
 
@@ -1223,39 +1223,46 @@ int prism2mgmt_wlansniff(wlandevice_t *wlandev, void *msgp)
 			/* Set the port type to pIbss */
 			word = HFA384x_PORTTYPE_PSUEDOIBSS;
 			result = hfa384x_drvr_setconfig16(hw,
-							  HFA384x_RID_CNFPORTTYPE, word);
-			if ( result ) {
-				pr_debug(
-					       "failed to set porttype %d, result=%d\n",
-					       word,
-					       result);
+							  HFA384x_RID_CNFPORTTYPE,
+							  word);
+			if (result) {
+				printk(KERN_DEBUG
+				       "failed to set porttype %d, result=%d\n",
+				       word, result);
 				goto failed;
 			}
-			if ((msg->keepwepflags.status == P80211ENUM_msgitem_status_data_ok) && (msg->keepwepflags.data != P80211ENUM_truth_true)) {
+			if ((msg->keepwepflags.status ==
+			     P80211ENUM_msgitem_status_data_ok)
+			    && (msg->keepwepflags.data !=
+				P80211ENUM_truth_true)) {
 				/* Set the wepflags for no decryption */
 				word = HFA384x_WEPFLAGS_DISABLE_TXCRYPT |
-					HFA384x_WEPFLAGS_DISABLE_RXCRYPT;
-				result = hfa384x_drvr_setconfig16(hw, HFA384x_RID_CNFWEPFLAGS, word);
+				    HFA384x_WEPFLAGS_DISABLE_RXCRYPT;
+				result =
+				    hfa384x_drvr_setconfig16(hw,
+							     HFA384x_RID_CNFWEPFLAGS,
+							     word);
 			}
 
-			if ( result ) {
-				pr_debug(
-					       "failed to set wepflags=0x%04x, result=%d\n",
-					       word,
-					       result);
+			if (result) {
+				printk(KERN_DEBUG
+				       "failed to set wepflags=0x%04x, result=%d\n",
+				       word, result);
 				goto failed;
 			}
 		}
 
 		/* Do we want to strip the FCS in monitor mode? */
-		if ((msg->stripfcs.status == P80211ENUM_msgitem_status_data_ok) && (msg->stripfcs.data == P80211ENUM_truth_true)) {
+		if ((msg->stripfcs.status == P80211ENUM_msgitem_status_data_ok)
+		    && (msg->stripfcs.data == P80211ENUM_truth_true)) {
 			hw->sniff_fcs = 0;
 		} else {
 			hw->sniff_fcs = 1;
 		}
 
 		/* Do we want to truncate the packets? */
-		if (msg->packet_trunc.status == P80211ENUM_msgitem_status_data_ok) {
+		if (msg->packet_trunc.status ==
+		    P80211ENUM_msgitem_status_data_ok) {
 			hw->sniff_truncate = msg->packet_trunc.data;
 		} else {
 			hw->sniff_truncate = 0;
@@ -1263,31 +1270,35 @@ int prism2mgmt_wlansniff(wlandevice_t *wlandev, void *msgp)
 
 		/* Enable the port */
 		result = hfa384x_drvr_enable(hw, 0);
-		if ( result ) {
-			pr_debug(
-			"failed to enable port for sniffing, result=%d\n",
-			result);
+		if (result) {
+			printk(KERN_DEBUG
+			       "failed to enable port for sniffing, result=%d\n",
+			       result);
 			goto failed;
 		}
 		/* Enable monitor mode */
 		result = hfa384x_cmd_monitor(hw, HFA384x_MONITOR_ENABLE);
-		if ( result ) {
-			pr_debug(
-			"failed to enable monitor mode, result=%d\n",
-			result);
+		if (result) {
+			printk(KERN_DEBUG
+			       "failed to enable monitor mode, result=%d\n",
+			       result);
 			goto failed;
 		}
 
-		if (wlandev->netdev->type == ARPHRD_ETHER) {
+		if (wlandev->netdev->type == ARPHRD_ETHER)
 			printk(KERN_INFO "monitor mode enabled\n");
-		}
 
 		/* Set the driver state */
 		/* Do we want the prism2 header? */
-		if ((msg->prismheader.status == P80211ENUM_msgitem_status_data_ok) && (msg->prismheader.data == P80211ENUM_truth_true)) {
+		if ((msg->prismheader.status ==
+		     P80211ENUM_msgitem_status_data_ok)
+		    && (msg->prismheader.data == P80211ENUM_truth_true)) {
 			hw->sniffhdr = 0;
 			wlandev->netdev->type = ARPHRD_IEEE80211_PRISM;
-		} else if ((msg->wlanheader.status == P80211ENUM_msgitem_status_data_ok) && (msg->wlanheader.data == P80211ENUM_truth_true)) {
+		} else
+		    if ((msg->wlanheader.status ==
+			 P80211ENUM_msgitem_status_data_ok)
+			&& (msg->wlanheader.data == P80211ENUM_truth_true)) {
 			hw->sniffhdr = 1;
 			wlandev->netdev->type = ARPHRD_IEEE80211_PRISM;
 		} else {

commit a7cf7bae3297f16bb4a2f00310377fec06d0ecd6
Author: Moritz Muehlenhoff <jmm@debian.org>
Date:   Sun Feb 8 02:01:00 2009 +0100

    Staging: wlan-ng: Replace WLAN_LOG_DEBUG() with printk(KERN_DEBUG
    
    Signed-off-by: Moritz Muehlenhoff <jmm@debian.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/wlan-ng/prism2mgmt.c b/drivers/staging/wlan-ng/prism2mgmt.c
index 12055226d2c4..953142ae9296 100644
--- a/drivers/staging/wlan-ng/prism2mgmt.c
+++ b/drivers/staging/wlan-ng/prism2mgmt.c
@@ -284,8 +284,6 @@ int prism2mgmt_scan(wlandevice_t *wlandev, void *msgp)
         /* Issue the scan request */
         hw->scanflag = 0;
 
-	WLAN_HEX_DUMP(5,"hscanreq", &scanreq, sizeof(scanreq));
-
         result = hfa384x_drvr_setconfig( hw,
                         HFA384x_RID_HOSTSCAN, &scanreq,
                         sizeof(hfa384x_HostScanRequest_data_t));
@@ -385,7 +383,7 @@ int prism2mgmt_scan_results(wlandevice_t *wlandev, void *msgp)
 	if (count > 32)  count = 32;
 
 	if (req->bssindex.data >= count) {
-		WLAN_LOG_DEBUG(0, "requested index (%d) out of range (%d)\n",
+		pr_debug("requested index (%d) out of range (%d)\n",
 				req->bssindex.data, count);
 		result = 2;
 		req->resultcode.data = P80211ENUM_resultcode_invalid_parameters;
@@ -667,7 +665,7 @@ int prism2mgmt_start(wlandevice_t *wlandev, void *msgp)
 
 	goto done;
 failed:
-	WLAN_LOG_DEBUG(1, "Failed to set a config option, result=%d\n", result);
+	pr_debug("Failed to set a config option, result=%d\n", result);
 	msg->resultcode.data = P80211ENUM_resultcode_invalid_parameters;
 
 done:
@@ -1108,7 +1106,7 @@ int prism2mgmt_wlansniff(wlandevice_t *wlandev, void *msgp)
 		/* Disable monitor mode */
 		result = hfa384x_cmd_monitor(hw, HFA384x_MONITOR_DISABLE);
 		if ( result ) {
-			WLAN_LOG_DEBUG(1,
+			pr_debug(
 				"failed to disable monitor mode, result=%d\n",
 				result);
 			goto failed;
@@ -1116,7 +1114,7 @@ int prism2mgmt_wlansniff(wlandevice_t *wlandev, void *msgp)
 		/* Disable port 0 */
 		result = hfa384x_drvr_disable(hw, 0);
 		if ( result ) {
-			WLAN_LOG_DEBUG(1,
+			pr_debug(
 			"failed to disable port 0 after sniffing, result=%d\n",
 			result);
 			goto failed;
@@ -1129,7 +1127,7 @@ int prism2mgmt_wlansniff(wlandevice_t *wlandev, void *msgp)
 				HFA384x_RID_CNFWEPFLAGS,
 				hw->presniff_wepflags);
 		if ( result ) {
-			WLAN_LOG_DEBUG(1,
+			pr_debug(
 			"failed to restore wepflags=0x%04x, result=%d\n",
 			hw->presniff_wepflags,
 			result);
@@ -1142,7 +1140,7 @@ int prism2mgmt_wlansniff(wlandevice_t *wlandev, void *msgp)
 			result = hfa384x_drvr_setconfig16(hw,
 				HFA384x_RID_CNFPORTTYPE, word);
 			if ( result ) {
-				WLAN_LOG_DEBUG(1,
+				pr_debug(
 				"failed to restore porttype, result=%d\n",
 				result);
 				goto failed;
@@ -1151,7 +1149,7 @@ int prism2mgmt_wlansniff(wlandevice_t *wlandev, void *msgp)
 			/* Enable the port */
 			result = hfa384x_drvr_enable(hw, 0);
 			if ( result ) {
-				WLAN_LOG_DEBUG(1, "failed to enable port to presniff setting, result=%d\n", result);
+				pr_debug("failed to enable port to presniff setting, result=%d\n", result);
 				goto failed;
 			}
 		} else {
@@ -1173,7 +1171,7 @@ int prism2mgmt_wlansniff(wlandevice_t *wlandev, void *msgp)
 								  HFA384x_RID_CNFPORTTYPE,
 								  &(hw->presniff_port_type));
 				if ( result ) {
-					WLAN_LOG_DEBUG(1,"failed to read porttype, result=%d\n", result);
+					pr_debug("failed to read porttype, result=%d\n", result);
 					goto failed;
 				}
 				/* Save the wepflags state */
@@ -1181,13 +1179,13 @@ int prism2mgmt_wlansniff(wlandevice_t *wlandev, void *msgp)
 								  HFA384x_RID_CNFWEPFLAGS,
 								  &(hw->presniff_wepflags));
 				if ( result ) {
-					WLAN_LOG_DEBUG(1,"failed to read wepflags, result=%d\n", result);
+					pr_debug("failed to read wepflags, result=%d\n", result);
 					goto failed;
 				}
 				hfa384x_drvr_stop(hw);
 				result = hfa384x_drvr_start(hw);
 				if ( result ) {
-					WLAN_LOG_DEBUG(1,
+					pr_debug(
 						       "failed to restart the card for sniffing, result=%d\n",
 						       result);
 					goto failed;
@@ -1196,7 +1194,7 @@ int prism2mgmt_wlansniff(wlandevice_t *wlandev, void *msgp)
 				/* Disable the port */
 				result = hfa384x_drvr_disable(hw, 0);
 				if ( result ) {
-					WLAN_LOG_DEBUG(1,
+					pr_debug(
 						       "failed to enable port for sniffing, result=%d\n",
 						       result);
 					goto failed;
@@ -1213,7 +1211,7 @@ int prism2mgmt_wlansniff(wlandevice_t *wlandev, void *msgp)
 		hw->sniff_channel=word;
 
 		if ( result ) {
-			WLAN_LOG_DEBUG(1,
+			pr_debug(
 				       "failed to set channel %d, result=%d\n",
 					       word,
 				       result);
@@ -1227,7 +1225,7 @@ int prism2mgmt_wlansniff(wlandevice_t *wlandev, void *msgp)
 			result = hfa384x_drvr_setconfig16(hw,
 							  HFA384x_RID_CNFPORTTYPE, word);
 			if ( result ) {
-				WLAN_LOG_DEBUG(1,
+				pr_debug(
 					       "failed to set porttype %d, result=%d\n",
 					       word,
 					       result);
@@ -1241,7 +1239,7 @@ int prism2mgmt_wlansniff(wlandevice_t *wlandev, void *msgp)
 			}
 
 			if ( result ) {
-				WLAN_LOG_DEBUG(1,
+				pr_debug(
 					       "failed to set wepflags=0x%04x, result=%d\n",
 					       word,
 					       result);
@@ -1266,7 +1264,7 @@ int prism2mgmt_wlansniff(wlandevice_t *wlandev, void *msgp)
 		/* Enable the port */
 		result = hfa384x_drvr_enable(hw, 0);
 		if ( result ) {
-			WLAN_LOG_DEBUG(1,
+			pr_debug(
 			"failed to enable port for sniffing, result=%d\n",
 			result);
 			goto failed;
@@ -1274,7 +1272,7 @@ int prism2mgmt_wlansniff(wlandevice_t *wlandev, void *msgp)
 		/* Enable monitor mode */
 		result = hfa384x_cmd_monitor(hw, HFA384x_MONITOR_ENABLE);
 		if ( result ) {
-			WLAN_LOG_DEBUG(1,
+			pr_debug(
 			"failed to enable monitor mode, result=%d\n",
 			result);
 			goto failed;

commit ea045ba02086c008505ab1a6a7a60856072be65f
Author: Moritz Muehlenhoff <jmm@debian.org>
Date:   Thu Feb 5 23:55:54 2009 +0100

    Staging: wlan-ng: Remove WLAN_INCLUDE_DEBUG and some related, mostly unused
    
    Signed-off-by: Moritz Muehlenhoff <jmm@debian.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/wlan-ng/prism2mgmt.c b/drivers/staging/wlan-ng/prism2mgmt.c
index fe4e7ffddf24..12055226d2c4 100644
--- a/drivers/staging/wlan-ng/prism2mgmt.c
+++ b/drivers/staging/wlan-ng/prism2mgmt.c
@@ -59,8 +59,6 @@
 
 /*================================================================*/
 /* System Includes */
-#define WLAN_DBVAR	prism2_debug
-
 
 #include <linux/if_arp.h>
 #include <linux/module.h>

commit 7dd33a43d5a8fe6f30697ac8295894e21d4cdc46
Author: Moritz Muehlenhoff <jmm@debian.org>
Date:   Sun Feb 1 13:29:02 2009 +0100

    Staging: wlan-ng: Remove dead code from prism2mgmt.c
    
    Signed-off-by: Moritz Muehlenhoff <jmm@debian.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/wlan-ng/prism2mgmt.c b/drivers/staging/wlan-ng/prism2mgmt.c
index 3d9478c4a4b4..fe4e7ffddf24 100644
--- a/drivers/staging/wlan-ng/prism2mgmt.c
+++ b/drivers/staging/wlan-ng/prism2mgmt.c
@@ -1055,25 +1055,7 @@ int prism2mgmt_autojoin(wlandevice_t *wlandev, void *msgp)
         result = hfa384x_drvr_setconfig(
 			hw, HFA384x_RID_CNFDESIREDSSID,
 			bytebuf, HFA384x_RID_CNFDESIREDSSID_LEN);
-#if 0
-	/* we can use the new-fangled auto-unknown mode if the firmware
-	   is 1.3.3 or newer */
-	if (HFA384x_FIRMARE_VERSION(hw->ident_sta_fw.major,
-				    hw->ident_sta_fw.minor,
-				    hw->ident_sta_fw.variant) >=
-	    HFA384x_FIRMWARE_VERSION(1,3,3)) {
-		/* Set up the IBSS options */
-		reg =  HFA384x_CREATEIBSS_JOINESS_JOINCREATEIBSS;
-		hfa384x_drvr_setconfig16(hw, HFA384x_RID_CREATEIBSS, reg);
-
-		/* Set the PortType */
-		port_type = HFA384x_PORTTYPE_IBSS;
-	} else {
-		port_type = HFA384x_PORTTYPE_BSS;
-	}
-#else
 	port_type = HFA384x_PORTTYPE_BSS;
-#endif
 	/* Set the PortType */
 	hfa384x_drvr_setconfig16(hw, HFA384x_RID_CNFPORTTYPE, port_type);
 

commit 9b9556ecc4bd8279aec195de84fd7d45a9883547
Author: Moritz Muehlenhoff <jmm@debian.org>
Date:   Sun Jan 25 21:55:01 2009 +0100

    Staging: wlan-ng: Replace WLAN_LOG_WARNING() with printk()
    
    Signed-off-by: Moritz Muehlenhoff <jmm@debian.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/wlan-ng/prism2mgmt.c b/drivers/staging/wlan-ng/prism2mgmt.c
index 9432a19bc1ae..3d9478c4a4b4 100644
--- a/drivers/staging/wlan-ng/prism2mgmt.c
+++ b/drivers/staging/wlan-ng/prism2mgmt.c
@@ -183,7 +183,7 @@ int prism2mgmt_scan(wlandevice_t *wlandev, void *msgp)
                 }
                 result = hfa384x_drvr_setconfig16(hw, HFA384x_RID_CNFPASSIVESCANCTRL, word);
                 if ( result ) {
-                        WLAN_LOG_WARNING("Passive scan not supported with "
+                        printk(KERN_WARNING "Passive scan not supported with "
 					  "current firmware.  (<1.5.1)\n");
                 }
         }

commit edbd606c4671fcd439164c8d63e896044d706156
Author: Moritz Muehlenhoff <jmm@debian.org>
Date:   Sun Jan 25 21:55:00 2009 +0100

    Staging: wlan-ng: Replace WLAN_LOG_ERROR() with printk()
    
    Signed-off-by: Moritz Muehlenhoff <jmm@debian.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/wlan-ng/prism2mgmt.c b/drivers/staging/wlan-ng/prism2mgmt.c
index 785801e16fd5..9432a19bc1ae 100644
--- a/drivers/staging/wlan-ng/prism2mgmt.c
+++ b/drivers/staging/wlan-ng/prism2mgmt.c
@@ -140,7 +140,7 @@ int prism2mgmt_scan(wlandevice_t *wlandev, void *msgp)
                                      hw->ident_sta_fw.minor,
                                      hw->ident_sta_fw.variant) <
             HFA384x_FIRMWARE_VERSION(1,3,2)) {
-		WLAN_LOG_ERROR("HostScan not supported with current firmware (<1.3.2).\n");
+		printk(KERN_ERR "HostScan not supported with current firmware (<1.3.2).\n");
                 result = 1;
                 msg->resultcode.data = P80211ENUM_resultcode_not_supported;
 		goto exit;
@@ -152,7 +152,7 @@ int prism2mgmt_scan(wlandevice_t *wlandev, void *msgp)
         result = hfa384x_drvr_getconfig16(hw,
                         HFA384x_RID_CNFROAMINGMODE, &roamingmode);
         if ( result ) {
-                WLAN_LOG_ERROR("getconfig(ROAMMODE) failed. result=%d\n",
+                printk(KERN_ERR "getconfig(ROAMMODE) failed. result=%d\n",
                                 result);
                 msg->resultcode.data =
                         P80211ENUM_resultcode_implementation_failure;
@@ -164,7 +164,7 @@ int prism2mgmt_scan(wlandevice_t *wlandev, void *msgp)
                         HFA384x_RID_CNFROAMINGMODE,
 			HFA384x_ROAMMODE_HOSTSCAN_HOSTROAM);
         if ( result ) {
-                WLAN_LOG_ERROR("setconfig(ROAMINGMODE) failed. result=%d\n",
+                printk(KERN_ERR "setconfig(ROAMINGMODE) failed. result=%d\n",
                                 result);
                 msg->resultcode.data =
                         P80211ENUM_resultcode_implementation_failure;
@@ -209,7 +209,7 @@ int prism2mgmt_scan(wlandevice_t *wlandev, void *msgp)
 	/* Enable the MAC port if it's not already enabled  */
 	result = hfa384x_drvr_getconfig16(hw, HFA384x_RID_PORTSTATUS, &word);
 	if ( result ) {
-		WLAN_LOG_ERROR("getconfig(PORTSTATUS) failed. "
+		printk(KERN_ERR "getconfig(PORTSTATUS) failed. "
 				"result=%d\n", result);
 		msg->resultcode.data =
 			P80211ENUM_resultcode_implementation_failure;
@@ -222,7 +222,7 @@ int prism2mgmt_scan(wlandevice_t *wlandev, void *msgp)
 			HFA384x_RID_CNFROAMINGMODE,
 			HFA384x_ROAMMODE_HOSTSCAN_HOSTROAM);
 		if ( result ) {
-			WLAN_LOG_ERROR("setconfig(ROAMINGMODE) failed. result=%d\n", result);
+			printk(KERN_ERR "setconfig(ROAMINGMODE) failed. result=%d\n", result);
 			msg->resultcode.data =
 				P80211ENUM_resultcode_implementation_failure;
 			goto exit;
@@ -235,7 +235,7 @@ int prism2mgmt_scan(wlandevice_t *wlandev, void *msgp)
 		result = hfa384x_drvr_setconfig( hw, HFA384x_RID_CNFOWNSSID,
 				wordbuf, HFA384x_RID_CNFOWNSSID_LEN);
 		if ( result ) {
-			WLAN_LOG_ERROR("Failed to set OwnSSID.\n");
+			printk(KERN_ERR "Failed to set OwnSSID.\n");
 			msg->resultcode.data =
 				P80211ENUM_resultcode_implementation_failure;
 			goto exit;
@@ -243,7 +243,7 @@ int prism2mgmt_scan(wlandevice_t *wlandev, void *msgp)
 		result = hfa384x_drvr_setconfig( hw, HFA384x_RID_CNFDESIREDSSID,
 				wordbuf, HFA384x_RID_CNFDESIREDSSID_LEN);
 		if ( result ) {
-			WLAN_LOG_ERROR("Failed to set DesiredSSID.\n");
+			printk(KERN_ERR "Failed to set DesiredSSID.\n");
 			msg->resultcode.data =
 				P80211ENUM_resultcode_implementation_failure;
 			goto exit;
@@ -253,7 +253,7 @@ int prism2mgmt_scan(wlandevice_t *wlandev, void *msgp)
 				HFA384x_RID_CNFPORTTYPE,
 				HFA384x_PORTTYPE_IBSS);
 		if ( result ) {
-			WLAN_LOG_ERROR("Failed to set CNFPORTTYPE.\n");
+			printk(KERN_ERR "Failed to set CNFPORTTYPE.\n");
 			msg->resultcode.data =
 				P80211ENUM_resultcode_implementation_failure;
 			goto exit;
@@ -263,14 +263,14 @@ int prism2mgmt_scan(wlandevice_t *wlandev, void *msgp)
 				HFA384x_RID_CREATEIBSS,
 				HFA384x_CREATEIBSS_JOINCREATEIBSS);
 		if ( result ) {
-			WLAN_LOG_ERROR("Failed to set CREATEIBSS.\n");
+			printk(KERN_ERR "Failed to set CREATEIBSS.\n");
 			msg->resultcode.data =
 				P80211ENUM_resultcode_implementation_failure;
 			goto exit;
 		}
 		result = hfa384x_drvr_enable(hw, 0);
 		if ( result ) {
-			WLAN_LOG_ERROR("drvr_enable(0) failed. "
+			printk(KERN_ERR "drvr_enable(0) failed. "
 					"result=%d\n", result);
 			msg->resultcode.data =
 			P80211ENUM_resultcode_implementation_failure;
@@ -292,7 +292,7 @@ int prism2mgmt_scan(wlandevice_t *wlandev, void *msgp)
                         HFA384x_RID_HOSTSCAN, &scanreq,
                         sizeof(hfa384x_HostScanRequest_data_t));
         if ( result ) {
-                WLAN_LOG_ERROR("setconfig(SCANREQUEST) failed. result=%d\n",
+                printk(KERN_ERR "setconfig(SCANREQUEST) failed. result=%d\n",
                                 result);
                 msg->resultcode.data =
                         P80211ENUM_resultcode_implementation_failure;
@@ -314,7 +314,7 @@ int prism2mgmt_scan(wlandevice_t *wlandev, void *msgp)
 	if (istmpenable) {
 		result = hfa384x_drvr_disable(hw, 0);
 		if ( result ) {
-			WLAN_LOG_ERROR("drvr_disable(0) failed. "
+			printk(KERN_ERR "drvr_disable(0) failed. "
 					"result=%d\n", result);
 			msg->resultcode.data =
 			P80211ENUM_resultcode_implementation_failure;
@@ -326,7 +326,7 @@ int prism2mgmt_scan(wlandevice_t *wlandev, void *msgp)
 	result = hfa384x_drvr_setconfig16(hw, HFA384x_RID_CNFROAMINGMODE,
 					  roamingmode);
         if ( result ) {
-                WLAN_LOG_ERROR("setconfig(ROAMMODE) failed. result=%d\n",
+                printk(KERN_ERR "setconfig(ROAMMODE) failed. result=%d\n",
                                 result);
                 msg->resultcode.data =
                         P80211ENUM_resultcode_implementation_failure;
@@ -377,7 +377,7 @@ int prism2mgmt_scan_results(wlandevice_t *wlandev, void *msgp)
 	req->resultcode.status = P80211ENUM_msgitem_status_data_ok;
 
 	if (! hw->scanresults) {
-		WLAN_LOG_ERROR("dot11req_scan_results can only be used after a successful dot11req_scan.\n");
+		printk(KERN_ERR "dot11req_scan_results can only be used after a successful dot11req_scan.\n");
 		result = 2;
 		req->resultcode.data = P80211ENUM_resultcode_invalid_parameters;
 		goto exit;
@@ -558,13 +558,13 @@ int prism2mgmt_start(wlandevice_t *wlandev, void *msgp)
 	result = hfa384x_drvr_setconfig( hw, HFA384x_RID_CNFOWNSSID,
 					 bytebuf, HFA384x_RID_CNFOWNSSID_LEN);
 	if ( result ) {
-		WLAN_LOG_ERROR("Failed to set CnfOwnSSID\n");
+		printk(KERN_ERR "Failed to set CnfOwnSSID\n");
 		goto failed;
 	}
 	result = hfa384x_drvr_setconfig( hw, HFA384x_RID_CNFDESIREDSSID,
 					 bytebuf, HFA384x_RID_CNFDESIREDSSID_LEN);
 	if ( result ) {
-		WLAN_LOG_ERROR("Failed to set CnfDesiredSSID\n");
+		printk(KERN_ERR "Failed to set CnfDesiredSSID\n");
 		goto failed;
 	}
 
@@ -576,7 +576,7 @@ int prism2mgmt_start(wlandevice_t *wlandev, void *msgp)
 	word = msg->beaconperiod.data;
 	result = hfa384x_drvr_setconfig16(hw, HFA384x_RID_CNFAPBCNint, word);
 	if ( result ) {
-		WLAN_LOG_ERROR("Failed to set beacon period=%d.\n", word);
+		printk(KERN_ERR "Failed to set beacon period=%d.\n", word);
 		goto failed;
 	}
 
@@ -584,7 +584,7 @@ int prism2mgmt_start(wlandevice_t *wlandev, void *msgp)
 	word = msg->dschannel.data;
 	result = hfa384x_drvr_setconfig16(hw, HFA384x_RID_CNFOWNCHANNEL, word);
 	if ( result ) {
-		WLAN_LOG_ERROR("Failed to set channel=%d.\n", word);
+		printk(KERN_ERR "Failed to set channel=%d.\n", word);
 		goto failed;
 	}
 	/* Basic rates */
@@ -612,7 +612,7 @@ int prism2mgmt_start(wlandevice_t *wlandev, void *msgp)
 	}
 	result = hfa384x_drvr_setconfig16(hw, HFA384x_RID_CNFBASICRATES, word);
 	if ( result ) {
-		WLAN_LOG_ERROR("Failed to set basicrates=%d.\n", word);
+		printk(KERN_ERR "Failed to set basicrates=%d.\n", word);
 		goto failed;
 	}
 
@@ -641,13 +641,13 @@ int prism2mgmt_start(wlandevice_t *wlandev, void *msgp)
 	}
 	result = hfa384x_drvr_setconfig16(hw, HFA384x_RID_CNFSUPPRATES, word);
 	if ( result ) {
-		WLAN_LOG_ERROR("Failed to set supprates=%d.\n", word);
+		printk(KERN_ERR "Failed to set supprates=%d.\n", word);
 		goto failed;
 	}
 
 	result = hfa384x_drvr_setconfig16(hw, HFA384x_RID_TXRATECNTL, word);
 	if ( result ) {
-		WLAN_LOG_ERROR("Failed to set txrates=%d.\n", word);
+		printk(KERN_ERR "Failed to set txrates=%d.\n", word);
 		goto failed;
 	}
 
@@ -661,7 +661,7 @@ int prism2mgmt_start(wlandevice_t *wlandev, void *msgp)
 	/* Enable the Port */
 	result = hfa384x_drvr_enable(hw, 0);
 	if ( result ) {
-		WLAN_LOG_ERROR("Enable macport failed, result=%d.\n", result);
+		printk(KERN_ERR "Enable macport failed, result=%d.\n", result);
 		goto failed;
 	}
 
@@ -706,7 +706,7 @@ int prism2mgmt_readpda(wlandevice_t *wlandev, void *msgp)
 	 * state.
 	 */
 	if (wlandev->msdstate != WLAN_MSD_FWLOAD) {
-		WLAN_LOG_ERROR(
+		printk(KERN_ERR
 			"PDA may only be read "
 			"in the fwload state.\n");
 		msg->resultcode.data =
@@ -721,7 +721,7 @@ int prism2mgmt_readpda(wlandevice_t *wlandev, void *msgp)
 			msg->pda.data,
 			HFA384x_PDA_LEN_MAX);
 		if (result) {
-			WLAN_LOG_ERROR(
+			printk(KERN_ERR
 				"hfa384x_drvr_readpda() failed, "
 				"result=%d\n",
 				result);
@@ -771,7 +771,7 @@ int prism2mgmt_ramdl_state(wlandevice_t *wlandev, void *msgp)
 	p80211msg_p2req_ramdl_state_t	*msg = msgp;
 
 	if (wlandev->msdstate != WLAN_MSD_FWLOAD) {
-		WLAN_LOG_ERROR(
+		printk(KERN_ERR
 			"ramdl_state(): may only be called "
 			"in the fwload state.\n");
 		msg->resultcode.data =
@@ -830,7 +830,7 @@ int prism2mgmt_ramdl_write(wlandevice_t *wlandev, void *msgp)
 	u8			*buf;
 
 	if (wlandev->msdstate != WLAN_MSD_FWLOAD) {
-		WLAN_LOG_ERROR(
+		printk(KERN_ERR
 			"ramdl_write(): may only be called "
 			"in the fwload state.\n");
 		msg->resultcode.data =
@@ -891,7 +891,7 @@ int prism2mgmt_flashdl_state(wlandevice_t *wlandev, void *msgp)
 	p80211msg_p2req_flashdl_state_t	*msg = msgp;
 
 	if (wlandev->msdstate != WLAN_MSD_FWLOAD) {
-		WLAN_LOG_ERROR(
+		printk(KERN_ERR
 			"flashdl_state(): may only be called "
 			"in the fwload state.\n");
 		msg->resultcode.data =
@@ -925,7 +925,7 @@ int prism2mgmt_flashdl_state(wlandevice_t *wlandev, void *msgp)
 		wlandev->msdstate = WLAN_MSD_HWPRESENT;
 		result = prism2sta_ifstate(wlandev, P80211ENUM_ifstate_fwload);
 		if (result != P80211ENUM_resultcode_success) {
-			WLAN_LOG_ERROR("prism2sta_ifstate(fwload) failed,"
+			printk(KERN_ERR "prism2sta_ifstate(fwload) failed,"
 				"P80211ENUM_resultcode=%d\n", result);
 			msg->resultcode.data =
 				P80211ENUM_resultcode_implementation_failure;
@@ -964,7 +964,7 @@ int prism2mgmt_flashdl_write(wlandevice_t *wlandev, void *msgp)
 	u8			*buf;
 
 	if (wlandev->msdstate != WLAN_MSD_FWLOAD) {
-		WLAN_LOG_ERROR(
+		printk(KERN_ERR
 			"flashdl_write(): may only be called "
 			"in the fwload state.\n");
 		msg->resultcode.data =

commit 350f2f4bd6570f6f1996516ddd135ab2a95484de
Author: Moritz Muehlenhoff <jmm@debian.org>
Date:   Sun Jan 25 21:54:57 2009 +0100

    Staging: wlan-ng: Remove WLAN_LOG_INFO
    
    Replace WLAN_LOG_INFO with printk() and remove it.
    
    Signed-off-by: Moritz Muehlenhoff <jmm@debian.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/wlan-ng/prism2mgmt.c b/drivers/staging/wlan-ng/prism2mgmt.c
index 6f0d39f2ea68..785801e16fd5 100644
--- a/drivers/staging/wlan-ng/prism2mgmt.c
+++ b/drivers/staging/wlan-ng/prism2mgmt.c
@@ -1179,7 +1179,7 @@ int prism2mgmt_wlansniff(wlandevice_t *wlandev, void *msgp)
 
 		}
 
-		WLAN_LOG_INFO("monitor mode disabled\n");
+		printk(KERN_INFO "monitor mode disabled\n");
 		msg->resultcode.data = P80211ENUM_resultcode_success;
 		result = 0;
 		goto exit;
@@ -1301,7 +1301,7 @@ int prism2mgmt_wlansniff(wlandevice_t *wlandev, void *msgp)
 		}
 
 		if (wlandev->netdev->type == ARPHRD_ETHER) {
-			WLAN_LOG_INFO("monitor mode enabled\n");
+			printk(KERN_INFO "monitor mode enabled\n");
 		}
 
 		/* Set the driver state */

commit 7f6e0e449c00bafe1c46471409fa1b8e4222dcf2
Author: Moritz Muehlenhoff <jmm@debian.org>
Date:   Sun Jan 25 21:54:55 2009 +0100

    Staging: wlan-ng: Replace BITx with the generic BIT(x)
    
    Signed-off-by: Moritz Muehlenhoff <jmm@debian.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/wlan-ng/prism2mgmt.c b/drivers/staging/wlan-ng/prism2mgmt.c
index b1055af8c249..6f0d39f2ea68 100644
--- a/drivers/staging/wlan-ng/prism2mgmt.c
+++ b/drivers/staging/wlan-ng/prism2mgmt.c
@@ -76,6 +76,7 @@
 #include <asm/byteorder.h>
 #include <linux/random.h>
 #include <linux/usb.h>
+#include <linux/bitops.h>
 
 #include "wlan_compat.h"
 
@@ -94,10 +95,10 @@
 #include "prism2mgmt.h"
 
 /* Converts 802.11 format rate specifications to prism2 */
-#define p80211rate_to_p2bit(n)	((((n)&~BIT7) == 2) ? BIT0 : \
-				 (((n)&~BIT7) == 4) ? BIT1 : \
-				 (((n)&~BIT7) == 11) ? BIT2 : \
-				 (((n)&~BIT7) == 22) ? BIT3 : 0)
+#define p80211rate_to_p2bit(n)	((((n)&~BIT(7)) == 2) ? BIT(0) :  \
+				 (((n)&~BIT(7)) == 4) ? BIT(1) : \
+				 (((n)&~BIT(7)) == 11) ? BIT(2) : \
+				 (((n)&~BIT(7)) == 22) ? BIT(3) : 0)
 
 /*----------------------------------------------------------------
 * prism2mgmt_scan
@@ -196,7 +197,7 @@ int prism2mgmt_scan(wlandevice_t *wlandev, void *msgp)
         for (i = 0; i < msg->channellist.data.len; i++) {
                 u8 channel = msg->channellist.data.data[i];
                 if (channel > 14) continue;
-                /* channel 1 is BIT0 ... channel 14 is BIT13 */
+                /* channel 1 is BIT 0 ... channel 14 is BIT 13 */
                 word |= (1 << (channel-1));
         }
         scanreq.channelList = host2hfa384x_16(word);

commit 8a251b55ef34c2a03e8ddf6d17bb125b92bb4a54
Author: Moritz Muehlenhoff <jmm@debian.org>
Date:   Wed Jan 21 22:00:44 2009 +0100

    Staging: wlan-ng: Remove DBFENTER/DBFEXIT macros
    
    Remove the ugly DBFENTER/DBFEXIT macros, which are only inserted to add "<---" and
    "--->" at the function start/end at higher debug levels and which make the code
    a lot less readable.
    
    Signed-off-by: Moritz Muehlenhoff <jmm@debian.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/wlan-ng/prism2mgmt.c b/drivers/staging/wlan-ng/prism2mgmt.c
index f1727ba6ec6f..b1055af8c249 100644
--- a/drivers/staging/wlan-ng/prism2mgmt.c
+++ b/drivers/staging/wlan-ng/prism2mgmt.c
@@ -134,8 +134,6 @@ int prism2mgmt_scan(wlandevice_t *wlandev, void *msgp)
 
         hfa384x_HostScanRequest_data_t  scanreq;
 
-	DBFENTER;
-
         /* gatekeeper check */
         if (HFA384x_FIRMWARE_VERSION(hw->ident_sta_fw.major,
                                      hw->ident_sta_fw.minor,
@@ -340,7 +338,6 @@ int prism2mgmt_scan(wlandevice_t *wlandev, void *msgp)
  exit:
 	msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;
 
-	DBFEXIT;
 	return result;
 }
 
@@ -374,8 +371,6 @@ int prism2mgmt_scan_results(wlandevice_t *wlandev, void *msgp)
 
 	int count;
 
-	DBFENTER;
-
         req = (p80211msg_dot11req_scan_results_t *) msgp;
 
 	req->resultcode.status = P80211ENUM_msgitem_status_data_ok;
@@ -502,7 +497,6 @@ int prism2mgmt_scan_results(wlandevice_t *wlandev, void *msgp)
 	req->resultcode.data = P80211ENUM_resultcode_success;
 
  exit:
-	DBFEXIT;
 	return result;
 }
 
@@ -535,7 +529,6 @@ int prism2mgmt_start(wlandevice_t *wlandev, void *msgp)
 	u8			bytebuf[80];
 	hfa384x_bytestr_t	*p2bytestr = (hfa384x_bytestr_t*)bytebuf;
 	u16			word;
-	DBFENTER;
 
 	wlandev->macmode = WLAN_MACMODE_NONE;
 
@@ -681,7 +674,6 @@ int prism2mgmt_start(wlandevice_t *wlandev, void *msgp)
 done:
 	result = 0;
 
-	DBFEXIT;
 	return result;
 }
 
@@ -708,7 +700,6 @@ int prism2mgmt_readpda(wlandevice_t *wlandev, void *msgp)
 	hfa384x_t		*hw = wlandev->priv;
 	p80211msg_p2req_readpda_t	*msg = msgp;
 	int				result;
-	DBFENTER;
 
 	/* We only support collecting the PDA when in the FWLOAD
 	 * state.
@@ -738,7 +729,6 @@ int prism2mgmt_readpda(wlandevice_t *wlandev, void *msgp)
 				P80211ENUM_resultcode_implementation_failure;
 			msg->resultcode.status =
 				P80211ENUM_msgitem_status_data_ok;
-			DBFEXIT;
 			return 0;
 		}
 		msg->pda.status = P80211ENUM_msgitem_status_data_ok;
@@ -746,7 +736,6 @@ int prism2mgmt_readpda(wlandevice_t *wlandev, void *msgp)
 		msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;
 	}
 
-	DBFEXIT;
 	return 0;
 }
 
@@ -779,7 +768,6 @@ int prism2mgmt_ramdl_state(wlandevice_t *wlandev, void *msgp)
 {
 	hfa384x_t		*hw = wlandev->priv;
 	p80211msg_p2req_ramdl_state_t	*msg = msgp;
-	DBFENTER;
 
 	if (wlandev->msdstate != WLAN_MSD_FWLOAD) {
 		WLAN_LOG_ERROR(
@@ -788,7 +776,6 @@ int prism2mgmt_ramdl_state(wlandevice_t *wlandev, void *msgp)
 		msg->resultcode.data =
 			P80211ENUM_resultcode_implementation_failure;
 		msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;
-		DBFEXIT;
 		return 0;
 	}
 
@@ -809,7 +796,6 @@ int prism2mgmt_ramdl_state(wlandevice_t *wlandev, void *msgp)
 		msg->resultcode.data = P80211ENUM_resultcode_success;
 	}
 
-	DBFEXIT;
 	return 0;
 }
 
@@ -841,7 +827,6 @@ int prism2mgmt_ramdl_write(wlandevice_t *wlandev, void *msgp)
 	u32			addr;
 	u32			len;
 	u8			*buf;
-	DBFENTER;
 
 	if (wlandev->msdstate != WLAN_MSD_FWLOAD) {
 		WLAN_LOG_ERROR(
@@ -850,7 +835,6 @@ int prism2mgmt_ramdl_write(wlandevice_t *wlandev, void *msgp)
 		msg->resultcode.data =
 			P80211ENUM_resultcode_implementation_failure;
 		msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;
-		DBFEXIT;
 		return 0;
 	}
 
@@ -870,7 +854,6 @@ int prism2mgmt_ramdl_write(wlandevice_t *wlandev, void *msgp)
 	}
 	msg->resultcode.data = P80211ENUM_resultcode_success;
 
-	DBFEXIT;
 	return 0;
 }
 
@@ -905,7 +888,6 @@ int prism2mgmt_flashdl_state(wlandevice_t *wlandev, void *msgp)
 	int			result = 0;
 	hfa384x_t		*hw = wlandev->priv;
 	p80211msg_p2req_flashdl_state_t	*msg = msgp;
-	DBFENTER;
 
 	if (wlandev->msdstate != WLAN_MSD_FWLOAD) {
 		WLAN_LOG_ERROR(
@@ -914,7 +896,6 @@ int prism2mgmt_flashdl_state(wlandevice_t *wlandev, void *msgp)
 		msg->resultcode.data =
 			P80211ENUM_resultcode_implementation_failure;
 		msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;
-		DBFEXIT;
 		return 0;
 	}
 
@@ -951,7 +932,6 @@ int prism2mgmt_flashdl_state(wlandevice_t *wlandev, void *msgp)
 		}
 	}
 
-	DBFEXIT;
 	return 0;
 }
 
@@ -981,7 +961,6 @@ int prism2mgmt_flashdl_write(wlandevice_t *wlandev, void *msgp)
 	u32			addr;
 	u32			len;
 	u8			*buf;
-	DBFENTER;
 
 	if (wlandev->msdstate != WLAN_MSD_FWLOAD) {
 		WLAN_LOG_ERROR(
@@ -990,7 +969,6 @@ int prism2mgmt_flashdl_write(wlandevice_t *wlandev, void *msgp)
 		msg->resultcode.data =
 			P80211ENUM_resultcode_implementation_failure;
 		msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;
-		DBFEXIT;
 		return 0;
 	}
 
@@ -1016,7 +994,6 @@ int prism2mgmt_flashdl_write(wlandevice_t *wlandev, void *msgp)
 	}
 	msg->resultcode.data = P80211ENUM_resultcode_success;
 
-	DBFEXIT;
 	return 0;
 }
 
@@ -1049,7 +1026,6 @@ int prism2mgmt_autojoin(wlandevice_t *wlandev, void *msgp)
 	p80211pstrd_t		*pstr;
 	u8			bytebuf[256];
 	hfa384x_bytestr_t	*p2bytestr = (hfa384x_bytestr_t*)bytebuf;
-	DBFENTER;
 
 	wlandev->macmode = WLAN_MACMODE_NONE;
 
@@ -1107,7 +1083,6 @@ int prism2mgmt_autojoin(wlandevice_t *wlandev, void *msgp)
 	msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;
 	msg->resultcode.data = P80211ENUM_resultcode_success;
 
-	DBFEXIT;
 	return result;
 }
 
@@ -1139,8 +1114,6 @@ int prism2mgmt_wlansniff(wlandevice_t *wlandev, void *msgp)
 	hfa384x_t			*hw = wlandev->priv;
 	u16			word;
 
-	DBFENTER;
-
 	msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;
 	switch (msg->enable.data)
 	{
@@ -1357,7 +1330,5 @@ int prism2mgmt_wlansniff(wlandevice_t *wlandev, void *msgp)
 	msg->resultcode.data = P80211ENUM_resultcode_refused;
 	result = 0;
 exit:
-
-	DBFEXIT;
 	return result;
 }

commit d11e5f22ac9330ebe8f6157395a1a55645064322
Author: Huang Weiyi <weiyi.huang@gmail.com>
Date:   Fri Oct 31 22:49:56 2008 +0800

    Staging: wlan-ng: remove unused #include <version.h>
    
    The file(s) below do not use LINUX_VERSION_CODE nor KERNEL_VERSION.
      drivers/staging/wlan-ng/p80211conv.c
      drivers/staging/wlan-ng/p80211req.c
      drivers/staging/wlan-ng/p80211wext.c
      drivers/staging/wlan-ng/prism2mgmt.c
    
    This patch removes the said #include <version.h>.
    
    Signed-off-by: Huang Weiyi <weiyi.huang@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/wlan-ng/prism2mgmt.c b/drivers/staging/wlan-ng/prism2mgmt.c
index 1195bcb7cad5..f1727ba6ec6f 100644
--- a/drivers/staging/wlan-ng/prism2mgmt.c
+++ b/drivers/staging/wlan-ng/prism2mgmt.c
@@ -61,7 +61,6 @@
 /* System Includes */
 #define WLAN_DBVAR	prism2_debug
 
-#include <linux/version.h>
 
 #include <linux/if_arp.h>
 #include <linux/module.h>

commit cbec30c4c00c9f5a7357f5c5dacb63ae2378afb4
Author: Solomon Peachy <pizza@shaftnet.org>
Date:   Wed Oct 29 10:42:57 2008 -0400

    Staging: wlan-ng: Delete a large pile of now-unused code.
    
    Signed-off-by: Solomon Peachy <pizza@shaftnet.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/wlan-ng/prism2mgmt.c b/drivers/staging/wlan-ng/prism2mgmt.c
index df5dc204893c..1195bcb7cad5 100644
--- a/drivers/staging/wlan-ng/prism2mgmt.c
+++ b/drivers/staging/wlan-ng/prism2mgmt.c
@@ -507,301 +507,6 @@ int prism2mgmt_scan_results(wlandevice_t *wlandev, void *msgp)
 	return result;
 }
 
-/*----------------------------------------------------------------
-* prism2mgmt_p2_join
-*
-* Join a specific BSS
-*
-* Arguments:
-*	wlandev		wlan device structure
-*	msgp		ptr to msg buffer
-*
-* Returns:
-*	0	success and done
-*	<0	success, but we're waiting for something to finish.
-*	>0	an error occurred while handling the message.
-* Side effects:
-*
-* Call context:
-*	process thread  (usually)
-*	interrupt
-----------------------------------------------------------------*/
-int prism2mgmt_p2_join(wlandevice_t *wlandev, void *msgp)
-{
-	int 			result = 0;
-	hfa384x_t		*hw = wlandev->priv;
-	p80211msg_p2req_join_t	*msg = msgp;
-	u16			reg;
-	p80211pstrd_t		*pstr;
-	u8			bytebuf[256];
-	hfa384x_bytestr_t	*p2bytestr = (hfa384x_bytestr_t*)bytebuf;
-        hfa384x_JoinRequest_data_t	joinreq;
-	DBFENTER;
-
-	wlandev->macmode = WLAN_MACMODE_NONE;
-
-	/* Set the PortType */
-	msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;
-	msg->resultcode.data = P80211ENUM_resultcode_success;
-
-	/* ess port */
-	result = hfa384x_drvr_setconfig16(hw, HFA384x_RID_CNFPORTTYPE, 1);
-	if ( result ) {
-		WLAN_LOG_ERROR("Failed to set Port Type\n");
-		goto failed;
-	}
-
-	/* Set the auth type */
-	if ( msg->authtype.data == P80211ENUM_authalg_sharedkey ) {
-		reg = HFA384x_CNFAUTHENTICATION_SHAREDKEY;
-	} else {
-		reg = HFA384x_CNFAUTHENTICATION_OPENSYSTEM;
-	}
-	result = hfa384x_drvr_setconfig16(hw, HFA384x_RID_CNFAUTHENTICATION, reg);
-	if ( result ) {
-		WLAN_LOG_ERROR("Failed to set Authentication\n");
-		goto failed;
-	}
-
-	/* Turn off all roaming */
-	hfa384x_drvr_setconfig16(hw, HFA384x_RID_CNFROAMINGMODE, 3);
-	if ( result ) {
-		WLAN_LOG_ERROR("Failed to Turn off Roaming\n");
-		goto failed;
-	}
-
-	/* Basic rates */
-	reg = 0;
-	if ( msg->basicrate1.status == P80211ENUM_msgitem_status_data_ok ) {
-		reg = p80211rate_to_p2bit(msg->basicrate1.data);
-	}
-	if ( msg->basicrate2.status == P80211ENUM_msgitem_status_data_ok ) {
-		reg |= p80211rate_to_p2bit(msg->basicrate2.data);
-	}
-	if ( msg->basicrate3.status == P80211ENUM_msgitem_status_data_ok ) {
-		reg |= p80211rate_to_p2bit(msg->basicrate3.data);
-	}
-	if ( msg->basicrate4.status == P80211ENUM_msgitem_status_data_ok ) {
-		reg |= p80211rate_to_p2bit(msg->basicrate4.data);
-	}
-	if ( msg->basicrate5.status == P80211ENUM_msgitem_status_data_ok ) {
-		reg |= p80211rate_to_p2bit(msg->basicrate5.data);
-	}
-	if ( msg->basicrate6.status == P80211ENUM_msgitem_status_data_ok ) {
-		reg |= p80211rate_to_p2bit(msg->basicrate6.data);
-	}
-	if ( msg->basicrate7.status == P80211ENUM_msgitem_status_data_ok ) {
-		reg |= p80211rate_to_p2bit(msg->basicrate7.data);
-	}
-	if ( msg->basicrate8.status == P80211ENUM_msgitem_status_data_ok ) {
-		reg |= p80211rate_to_p2bit(msg->basicrate8.data);
-	}
-	if( reg == 0)
-		reg = 0x03;
-	result = hfa384x_drvr_setconfig16(hw, HFA384x_RID_CNFBASICRATES, reg);
-	if ( result ) {
-		WLAN_LOG_ERROR("Failed to set basicrates=%d.\n", reg);
-		goto failed;
-	}
-
-	/* Operational rates (supprates and txratecontrol) */
-	reg = 0;
-	if ( msg->operationalrate1.status == P80211ENUM_msgitem_status_data_ok ) {
-		reg = p80211rate_to_p2bit(msg->operationalrate1.data);
-	}
-	if ( msg->operationalrate2.status == P80211ENUM_msgitem_status_data_ok ) {
-		reg |= p80211rate_to_p2bit(msg->operationalrate2.data);
-	}
-	if ( msg->operationalrate3.status == P80211ENUM_msgitem_status_data_ok ) {
-		reg |= p80211rate_to_p2bit(msg->operationalrate3.data);
-	}
-	if ( msg->operationalrate4.status == P80211ENUM_msgitem_status_data_ok ) {
-		reg |= p80211rate_to_p2bit(msg->operationalrate4.data);
-	}
-	if ( msg->operationalrate5.status == P80211ENUM_msgitem_status_data_ok ) {
-		reg |= p80211rate_to_p2bit(msg->operationalrate5.data);
-	}
-	if ( msg->operationalrate6.status == P80211ENUM_msgitem_status_data_ok ) {
-		reg |= p80211rate_to_p2bit(msg->operationalrate6.data);
-	}
-	if ( msg->operationalrate7.status == P80211ENUM_msgitem_status_data_ok ) {
-		reg |= p80211rate_to_p2bit(msg->operationalrate7.data);
-	}
-	if ( msg->operationalrate8.status == P80211ENUM_msgitem_status_data_ok ) {
-		reg |= p80211rate_to_p2bit(msg->operationalrate8.data);
-	}
-	if( reg == 0)
-		reg = 0x0f;
-	result = hfa384x_drvr_setconfig16(hw, HFA384x_RID_CNFSUPPRATES, reg);
-	if ( result ) {
-		WLAN_LOG_ERROR("Failed to set supprates=%d.\n", reg);
-		goto failed;
-	}
-
-	result = hfa384x_drvr_setconfig16(hw, HFA384x_RID_TXRATECNTL, reg);
-	if ( result ) {
-		WLAN_LOG_ERROR("Failed to set txrates=%d.\n", reg);
-		goto failed;
-	}
-
-	/* Set the ssid */
-	memset(bytebuf, 0, 256);
-	pstr = (p80211pstrd_t*)&(msg->ssid.data);
-	prism2mgmt_pstr2bytestr(p2bytestr, pstr);
-	result = hfa384x_drvr_setconfig(
-		hw, HFA384x_RID_CNFDESIREDSSID,
-		bytebuf, HFA384x_RID_CNFDESIREDSSID_LEN);
-	if ( result ) {
-		WLAN_LOG_ERROR("Failed to set SSID\n");
-		goto failed;
-	}
-
-	/* Enable the Port */
-	result = hfa384x_cmd_enable(hw, 0);
-	if ( result ) {
-		WLAN_LOG_ERROR("Enable macport failed, result=%d.\n", result);
-		goto failed;
-	}
-
-	/* Fill in the join request */
-	joinreq.channel = msg->channel.data;
-	memcpy( joinreq.bssid, ((unsigned char *) &msg->bssid.data) + 1, WLAN_BSSID_LEN);
-	hw->joinreq = joinreq;
-	hw->join_ap = 1;
-
-	/* Send the join request */
-	result = hfa384x_drvr_setconfig( hw,
-					 HFA384x_RID_JOINREQUEST,
-					 &joinreq, HFA384x_RID_JOINREQUEST_LEN);
-	if(result != 0) {
-		WLAN_LOG_ERROR("Join request failed, result=%d.\n", result);
-		goto failed;
-	}
-
-        goto done;
-failed:
-	WLAN_LOG_DEBUG(1, "Failed to set a config option, result=%d\n", result);
-	msg->resultcode.data = P80211ENUM_resultcode_invalid_parameters;
-
-done:
-        result = 0;
-
-	DBFEXIT;
-	return result;
-}
-
-/*----------------------------------------------------------------
-* prism2mgmt_associate
-*
-* Associate with an ESS.
-*
-* Arguments:
-*	wlandev		wlan device structure
-*	msgp		ptr to msg buffer
-*
-* Returns:
-*	0	success and done
-*	<0	success, but we're waiting for something to finish.
-*	>0	an error occurred while handling the message.
-* Side effects:
-*
-* Call context:
-*	process thread  (usually)
-*	interrupt
-----------------------------------------------------------------*/
-int prism2mgmt_associate(wlandevice_t *wlandev, void *msgp)
-{
-	hfa384x_t		*hw = wlandev->priv;
-	int 			result = 0;
-	p80211msg_dot11req_associate_t	*msg = msgp;
-	DBFENTER;
-
-#if 0
-	/* Set the TxRates */
-	reg = 0x000f;
-	hfa384x_drvr_setconfig16(hw, HFA384x_RID_TXRATECNTL, reg);
-#endif
-
-	/* Set the PortType */
-	/* ess port */
-	hfa384x_drvr_setconfig16(hw, HFA384x_RID_CNFPORTTYPE, 1);
-
-	/* Enable the Port */
-	hfa384x_drvr_enable(hw, 0);
-
-	/* Set the resultcode */
-	msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;
-	msg->resultcode.data = P80211ENUM_resultcode_success;
-
-	DBFEXIT;
-	return result;
-}
-
-/*----------------------------------------------------------------
-* prism2mgmt_reset
-*
-* Reset the MAC and MSD.  The p80211 layer has it's own handling
-* that should be done before and after this function.
-* Procedure:
-*   - disable system interrupts ??
-*   - disable MAC interrupts
-*   - restore system interrupts
-*   - issue the MAC initialize command
-*   - clear any MSD level state (including timers, queued events,
-*     etc.).  Note that if we're removing timer'd/queue events, we may
-*     need to have remained in the system interrupt disabled state.
-*     We should be left in the same state that we're in following
-*     driver initialization.
-*
-* Arguments:
-*	wlandev		wlan device structure
-*	msgp		ptr to msg buffer, MAY BE NULL! for a driver local
-*			call.
-*
-* Returns:
-*	0	success and done
-*	<0	success, but we're waiting for something to finish.
-*	>0	an error occurred while handling the message.
-* Side effects:
-*
-* Call context:
-*	process thread, commonly wlanctl, but might be rmmod/pci_close.
-----------------------------------------------------------------*/
-int prism2mgmt_reset(wlandevice_t *wlandev, void *msgp)
-{
-	int 			result = 0;
-	hfa384x_t		*hw = wlandev->priv;
-	p80211msg_dot11req_reset_t	*msg = msgp;
-	DBFENTER;
-
-	/*
-	 * This is supported on both AP and STA and it's not allowed
-	 * to fail.
-	 */
-	if ( msgp ) {
-		msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;
-		msg->resultcode.data = P80211ENUM_resultcode_success;
-		WLAN_LOG_INFO("dot11req_reset: the macaddress and "
-			"setdefaultmib arguments are currently unsupported.\n");
-	}
-
-	/*
-	 * If we got this far, the MSD must be in the MSDRUNNING state
-	 * therefore, we must stop and then restart the hw/MAC combo.
-	 */
-	hfa384x_drvr_stop(hw);
-	result = hfa384x_drvr_start(hw);
-	if (result != 0) {
-		WLAN_LOG_ERROR("dot11req_reset: Initialize command failed,"
-				" bad things will happen from here.\n");
-		return 0;
-	}
-
-	DBFEXIT;
-	return 0;
-}
-
-
 /*----------------------------------------------------------------
 * prism2mgmt_start
 *
@@ -1046,322 +751,6 @@ int prism2mgmt_readpda(wlandevice_t *wlandev, void *msgp)
 	return 0;
 }
 
-/*----------------------------------------------------------------
-* prism2mgmt_readcis
-*
-* Collect the CIS data and put it in the message.
-*
-* Arguments:
-*	wlandev		wlan device structure
-*	msgp		ptr to msg buffer
-*
-* Returns:
-*	0	success and done
-*	<0	success, but we're waiting for something to finish.
-*	>0	an error occurred while handling the message.
-* Side effects:
-*
-* Call context:
-*	process thread  (usually)
-----------------------------------------------------------------*/
-int prism2mgmt_readcis(wlandevice_t *wlandev, void *msgp)
-{
-	int			result;
-	hfa384x_t		*hw = wlandev->priv;
-	p80211msg_p2req_readcis_t	*msg = msgp;
-
-	DBFENTER;
-
-        memset(msg->cis.data, 0, sizeof(msg->cis.data));
-
-	result = hfa384x_drvr_getconfig(hw, HFA384x_RID_CIS,
-					msg->cis.data, HFA384x_RID_CIS_LEN);
-	if ( result ) {
-		WLAN_LOG_INFO("prism2mgmt_readcis: read(cis) failed.\n");
-		msg->cis.status = P80211ENUM_msgitem_status_no_value;
-		msg->resultcode.data = P80211ENUM_resultcode_implementation_failure;
-
-		}
-	else {
-		msg->cis.status = P80211ENUM_msgitem_status_data_ok;
-		msg->resultcode.data = P80211ENUM_resultcode_success;
-		}
-
-	msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;
-
-	DBFEXIT;
-	return 0;
-}
-
-/*----------------------------------------------------------------
-* prism2mgmt_auxport_state
-*
-* Enables/Disables the card's auxiliary port.  Should be called
-* before and after a sequence of auxport_read()/auxport_write()
-* calls.
-*
-* Arguments:
-*	wlandev		wlan device structure
-*	msgp		ptr to msg buffer
-*
-* Returns:
-*	0	success and done
-*	<0	success, but we're waiting for something to finish.
-*	>0	an error occurred while handling the message.
-* Side effects:
-*
-* Call context:
-*	process thread  (usually)
-----------------------------------------------------------------*/
-int prism2mgmt_auxport_state(wlandevice_t *wlandev, void *msgp)
-{
-	p80211msg_p2req_auxport_state_t	*msg = msgp;
-
-	DBFENTER;
-
-	msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;
-	msg->resultcode.data = P80211ENUM_resultcode_not_supported;
-
-	DBFEXIT;
-	return 0;
-}
-
-
-/*----------------------------------------------------------------
-* prism2mgmt_auxport_read
-*
-* Copies data from the card using the auxport.  The auxport must
-* have previously been enabled.  Note: this is not the way to
-* do downloads, see the [ram|flash]dl functions.
-*
-* Arguments:
-*	wlandev		wlan device structure
-*	msgp		ptr to msg buffer
-*
-* Returns:
-*	0	success and done
-*	<0	success, but we're waiting for something to finish.
-*	>0	an error occurred while handling the message.
-* Side effects:
-*
-* Call context:
-*	process thread  (usually)
-----------------------------------------------------------------*/
-int prism2mgmt_auxport_read(wlandevice_t *wlandev, void *msgp)
-{
-	DBFENTER;
-
-	WLAN_LOG_ERROR("prism2mgmt_auxport_read: Not supported on USB.\n");
-
-	DBFEXIT;
-	return 0;
-}
-
-
-/*----------------------------------------------------------------
-* prism2mgmt_auxport_write
-*
-* Copies data to the card using the auxport.  The auxport must
-* have previously been enabled.  Note: this is not the way to
-* do downloads, see the [ram|flash]dl functions.
-*
-* Arguments:
-*	wlandev		wlan device structure
-*	msgp		ptr to msg buffer
-*
-* Returns:
-*	0	success and done
-*	<0	success, but we're waiting for something to finish.
-*	>0	an error occurred while handling the message.
-* Side effects:
-*
-* Call context:
-*	process thread  (usually)
-----------------------------------------------------------------*/
-int prism2mgmt_auxport_write(wlandevice_t *wlandev, void *msgp)
-{
-	DBFENTER;
-	WLAN_LOG_ERROR("prism2mgmt_auxport_read: Not supported on USB.\n");
-	DBFEXIT;
-	return 0;
-}
-
-/*----------------------------------------------------------------
-* prism2mgmt_low_level
-*
-* Puts the card into the desired test mode.
-*
-* Arguments:
-*       wlandev         wlan device structure
-*       msgp            ptr to msg buffer
-*
-* Returns:
-*       0       success and done
-*       <0      success, but we're waiting for something to finish.
-*       >0      an error occurred while handling the message.
-* Side effects:
-*
-* Call context:
-*       process thread  (usually)
-----------------------------------------------------------------*/
-int prism2mgmt_low_level(wlandevice_t *wlandev, void *msgp)
-{
-	hfa384x_t		*hw = wlandev->priv;
-        p80211msg_p2req_low_level_t     *msg = msgp;
-	hfa384x_metacmd_t cmd;
-        DBFENTER;
-
-        msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;
-
-        /* call some routine to execute the test command */
-	cmd.cmd = (u16) msg->command.data;
-	cmd.parm0 = (u16) msg->param0.data;
-	cmd.parm1 = (u16) msg->param1.data;
-	cmd.parm2 = (u16) msg->param2.data;
-
-        hfa384x_drvr_low_level(hw,&cmd);
-
-        msg->resp0.data = (u32) cmd.result.resp0;
-        msg->resp1.data = (u32) cmd.result.resp1;
-        msg->resp2.data = (u32) cmd.result.resp2;
-
-        msg->resultcode.data = P80211ENUM_resultcode_success;
-
-        DBFEXIT;
-        return 0;
-}
-
-/*----------------------------------------------------------------
-* prism2mgmt_test_command
-*
-* Puts the card into the desired test mode.
-*
-* Arguments:
-*	wlandev		wlan device structure
-*	msgp		ptr to msg buffer
-*
-* Returns:
-*	0	success and done
-*	<0	success, but we're waiting for something to finish.
-*	>0	an error occurred while handling the message.
-* Side effects:
-*
-* Call context:
-*	process thread  (usually)
-----------------------------------------------------------------*/
-int prism2mgmt_test_command(wlandevice_t *wlandev, void *msgp)
-{
-	hfa384x_t		*hw = wlandev->priv;
-	p80211msg_p2req_test_command_t	*msg = msgp;
-	hfa384x_metacmd_t cmd;
-
-        DBFENTER;
-
-	cmd.cmd = ((u16) msg->testcode.data) << 8 | 0x38;
-	cmd.parm0 = (u16) msg->testparam.data;
-	cmd.parm1 = 0;
-	cmd.parm2 = 0;
-
-        /* call some routine to execute the test command */
-
-        hfa384x_drvr_low_level(hw,&cmd);
-
-        msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;
-        msg->resultcode.data = P80211ENUM_resultcode_success;
-
-        msg->status.status = P80211ENUM_msgitem_status_data_ok;
-        msg->status.data = cmd.result.status;
-        msg->resp0.status = P80211ENUM_msgitem_status_data_ok;
-        msg->resp0.data = cmd.result.resp0;
-        msg->resp1.status = P80211ENUM_msgitem_status_data_ok;
-        msg->resp1.data = cmd.result.resp1;
-        msg->resp2.status = P80211ENUM_msgitem_status_data_ok;
-        msg->resp2.data = cmd.result.resp2;
-
-	DBFEXIT;
-	return 0;
-}
-
-
-/*----------------------------------------------------------------
-* prism2mgmt_mmi_read
-*
-* Read from one of the MMI registers.
-*
-* Arguments:
-*	wlandev		wlan device structure
-*	msgp		ptr to msg buffer
-*
-* Returns:
-*	0	success and done
-*	<0	success, but we're waiting for something to finish.
-*	>0	an error occurred while handling the message.
-* Side effects:
-*
-* Call context:
-*	process thread  (usually)
-----------------------------------------------------------------*/
-int prism2mgmt_mmi_read(wlandevice_t *wlandev, void *msgp)
-{
-	hfa384x_t		*hw = wlandev->priv;
-	p80211msg_p2req_mmi_read_t	*msg = msgp;
-	u32 resp = 0;
-
-	DBFENTER;
-
-	msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;
-
-	/* call some routine to execute the test command */
-
-	hfa384x_drvr_mmi_read(hw, msg->addr.data, &resp);
-
-	/* I'm not sure if this is "architecturally" correct, but it
-           is expedient. */
-
-	msg->value.status = P80211ENUM_msgitem_status_data_ok;
-	msg->value.data = resp;
-	msg->resultcode.data = P80211ENUM_resultcode_success;
-
-	DBFEXIT;
-	return 0;
-}
-
-/*----------------------------------------------------------------
-* prism2mgmt_mmi_write
-*
-* Write a data value to one of the MMI registers.
-*
-* Arguments:
-*	wlandev		wlan device structure
-*	msgp		ptr to msg buffer
-*
-* Returns:
-*	0	success and done
-*	<0	success, but we're waiting for something to finish.
-*	>0	an error occurred while handling the message.
-* Side effects:
-*
-* Call context:
-*	process thread  (usually)
-----------------------------------------------------------------*/
-int prism2mgmt_mmi_write(wlandevice_t *wlandev, void *msgp)
-{
-	hfa384x_t		*hw = wlandev->priv;
-	p80211msg_p2req_mmi_write_t	*msg = msgp;
-	DBFENTER;
-
-	msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;
-
-	/* call some routine to execute the test command */
-
-	hfa384x_drvr_mmi_write(hw, msg->addr.data, msg->data.data);
-
-	msg->resultcode.data = P80211ENUM_resultcode_success;
-
-	DBFEXIT;
-	return 0;
-}
-
 /*----------------------------------------------------------------
 * prism2mgmt_ramdl_state
 *
@@ -1632,42 +1021,6 @@ int prism2mgmt_flashdl_write(wlandevice_t *wlandev, void *msgp)
 	return 0;
 }
 
-
-/*----------------------------------------------------------------
-* prism2mgmt_dump_state
-*
-* Dumps the driver's and hardware's current state via the kernel
-* log at KERN_NOTICE level.
-*
-* Arguments:
-*	wlandev		wlan device structure
-*	msgp		ptr to msg buffer
-*
-* Returns:
-*	0	success and done
-*	<0	success, but we're waiting for something to finish.
-*	>0	an error occurred while handling the message.
-* Side effects:
-*
-* Call context:
-*	process thread  (usually)
-----------------------------------------------------------------*/
-int prism2mgmt_dump_state(wlandevice_t *wlandev, void *msgp)
-{
-	p80211msg_p2req_dump_state_t	*msg = msgp;
-	int				result = 0;
-
-	DBFENTER;
-
-	msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;
-	msg->resultcode.data = P80211ENUM_resultcode_not_supported;
-	goto failed;
-
-failed:
-	DBFEXIT;
-	return result;
-}
-
 /*----------------------------------------------------------------
 * prism2mgmt_autojoin
 *

commit aaad430378dd128ee015c8ed6e77809317c496a5
Author: Solomon Peachy <pizza@shaftnet.org>
Date:   Wed Oct 29 10:42:53 2008 -0400

    Staging: wlan-ng: Use standard kernel integer (u32/s32/etc) types.
    
    wlan-ng needed to interact with userspace, and support very old kernels,
    so it used to define its own types for integers to ensure consistency.
    
    It's all rather irrelevant now.
    
    Signed-off-by: Solomon Peachy <pizza@shaftnet.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/wlan-ng/prism2mgmt.c b/drivers/staging/wlan-ng/prism2mgmt.c
index c2f61ede0c61..df5dc204893c 100644
--- a/drivers/staging/wlan-ng/prism2mgmt.c
+++ b/drivers/staging/wlan-ng/prism2mgmt.c
@@ -129,7 +129,7 @@ int prism2mgmt_scan(wlandevice_t *wlandev, void *msgp)
 	int 			result = 0;
 	hfa384x_t		*hw = wlandev->priv;
 	p80211msg_dot11req_scan_t	*msg = msgp;
-        UINT16                  roamingmode, word;
+        u16                  roamingmode, word;
 	int                     i, timeout;
 	int                     istmpenable = 0;
 
@@ -197,7 +197,7 @@ int prism2mgmt_scan(wlandevice_t *wlandev, void *msgp)
         /* set up the channel list */
         word = 0;
         for (i = 0; i < msg->channellist.data.len; i++) {
-                UINT8 channel = msg->channellist.data.data[i];
+                u8 channel = msg->channellist.data.data[i];
                 if (channel > 14) continue;
                 /* channel 1 is BIT0 ... channel 14 is BIT13 */
                 word |= (1 << (channel-1));
@@ -218,7 +218,7 @@ int prism2mgmt_scan(wlandevice_t *wlandev, void *msgp)
 		goto exit;
 	}
 	if (word == HFA384x_PORTSTATUS_DISABLED) {
-		UINT16 wordbuf[17];
+		u16 wordbuf[17];
 
 		result = hfa384x_drvr_setconfig16(hw,
 			HFA384x_RID_CNFROAMINGMODE,
@@ -531,9 +531,9 @@ int prism2mgmt_p2_join(wlandevice_t *wlandev, void *msgp)
 	int 			result = 0;
 	hfa384x_t		*hw = wlandev->priv;
 	p80211msg_p2req_join_t	*msg = msgp;
-	UINT16			reg;
+	u16			reg;
 	p80211pstrd_t		*pstr;
-	UINT8			bytebuf[256];
+	u8			bytebuf[256];
 	hfa384x_bytestr_t	*p2bytestr = (hfa384x_bytestr_t*)bytebuf;
         hfa384x_JoinRequest_data_t	joinreq;
 	DBFENTER;
@@ -828,9 +828,9 @@ int prism2mgmt_start(wlandevice_t *wlandev, void *msgp)
 	p80211msg_dot11req_start_t	*msg = msgp;
 
 	p80211pstrd_t		*pstr;
-	UINT8			bytebuf[80];
+	u8			bytebuf[80];
 	hfa384x_bytestr_t	*p2bytestr = (hfa384x_bytestr_t*)bytebuf;
-	UINT16			word;
+	u16			word;
 	DBFENTER;
 
 	wlandev->macmode = WLAN_MACMODE_NONE;
@@ -876,7 +876,7 @@ int prism2mgmt_start(wlandevice_t *wlandev, void *msgp)
 
 	/* beacon period */
 	word = msg->beaconperiod.data;
-	result = hfa384x_drvr_setconfig16(hw, HFA384x_RID_CNFAPBCNINT, word);
+	result = hfa384x_drvr_setconfig16(hw, HFA384x_RID_CNFAPBCNint, word);
 	if ( result ) {
 		WLAN_LOG_ERROR("Failed to set beacon period=%d.\n", word);
 		goto failed;
@@ -1214,16 +1214,16 @@ int prism2mgmt_low_level(wlandevice_t *wlandev, void *msgp)
         msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;
 
         /* call some routine to execute the test command */
-	cmd.cmd = (UINT16) msg->command.data;
-	cmd.parm0 = (UINT16) msg->param0.data;
-	cmd.parm1 = (UINT16) msg->param1.data;
-	cmd.parm2 = (UINT16) msg->param2.data;
+	cmd.cmd = (u16) msg->command.data;
+	cmd.parm0 = (u16) msg->param0.data;
+	cmd.parm1 = (u16) msg->param1.data;
+	cmd.parm2 = (u16) msg->param2.data;
 
         hfa384x_drvr_low_level(hw,&cmd);
 
-        msg->resp0.data = (UINT32) cmd.result.resp0;
-        msg->resp1.data = (UINT32) cmd.result.resp1;
-        msg->resp2.data = (UINT32) cmd.result.resp2;
+        msg->resp0.data = (u32) cmd.result.resp0;
+        msg->resp1.data = (u32) cmd.result.resp1;
+        msg->resp2.data = (u32) cmd.result.resp2;
 
         msg->resultcode.data = P80211ENUM_resultcode_success;
 
@@ -1257,8 +1257,8 @@ int prism2mgmt_test_command(wlandevice_t *wlandev, void *msgp)
 
         DBFENTER;
 
-	cmd.cmd = ((UINT16) msg->testcode.data) << 8 | 0x38;
-	cmd.parm0 = (UINT16) msg->testparam.data;
+	cmd.cmd = ((u16) msg->testcode.data) << 8 | 0x38;
+	cmd.parm0 = (u16) msg->testparam.data;
 	cmd.parm1 = 0;
 	cmd.parm2 = 0;
 
@@ -1305,7 +1305,7 @@ int prism2mgmt_mmi_read(wlandevice_t *wlandev, void *msgp)
 {
 	hfa384x_t		*hw = wlandev->priv;
 	p80211msg_p2req_mmi_read_t	*msg = msgp;
-	UINT32 resp = 0;
+	u32 resp = 0;
 
 	DBFENTER;
 
@@ -1450,9 +1450,9 @@ int prism2mgmt_ramdl_write(wlandevice_t *wlandev, void *msgp)
 {
 	hfa384x_t		*hw = wlandev->priv;
 	p80211msg_p2req_ramdl_write_t	*msg = msgp;
-	UINT32			addr;
-	UINT32			len;
-	UINT8			*buf;
+	u32			addr;
+	u32			len;
+	u8			*buf;
 	DBFENTER;
 
 	if (wlandev->msdstate != WLAN_MSD_FWLOAD) {
@@ -1590,9 +1590,9 @@ int prism2mgmt_flashdl_write(wlandevice_t *wlandev, void *msgp)
 {
 	hfa384x_t		*hw = wlandev->priv;
 	p80211msg_p2req_flashdl_write_t	*msg = msgp;
-	UINT32			addr;
-	UINT32			len;
-	UINT8			*buf;
+	u32			addr;
+	u32			len;
+	u8			*buf;
 	DBFENTER;
 
 	if (wlandev->msdstate != WLAN_MSD_FWLOAD) {
@@ -1691,11 +1691,11 @@ int prism2mgmt_autojoin(wlandevice_t *wlandev, void *msgp)
 {
 	hfa384x_t			*hw = wlandev->priv;
 	int 			result = 0;
-	UINT16			reg;
-	UINT16			port_type;
+	u16			reg;
+	u16			port_type;
 	p80211msg_lnxreq_autojoin_t	*msg = msgp;
 	p80211pstrd_t		*pstr;
-	UINT8			bytebuf[256];
+	u8			bytebuf[256];
 	hfa384x_bytestr_t	*p2bytestr = (hfa384x_bytestr_t*)bytebuf;
 	DBFENTER;
 
@@ -1785,7 +1785,7 @@ int prism2mgmt_wlansniff(wlandevice_t *wlandev, void *msgp)
 	p80211msg_lnxreq_wlansniff_t	*msg = msgp;
 
 	hfa384x_t			*hw = wlandev->priv;
-	UINT16			word;
+	u16			word;
 
 	DBFENTER;
 

commit ff1ae8f3c1b972ff850400abdd5f7da36270f408
Author: Solomon Peachy <pizza@shaftnet.org>
Date:   Mon Oct 27 11:14:05 2008 -0400

    Staging: wlan-ng: Eliminate local 'version.h'
    
    The kernel provides us with the proper version of this file.
    
    Signed-off-by: Solomon Peachy <pizza@shaftnet.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/wlan-ng/prism2mgmt.c b/drivers/staging/wlan-ng/prism2mgmt.c
index de2ec1e7c9de..c2f61ede0c61 100644
--- a/drivers/staging/wlan-ng/prism2mgmt.c
+++ b/drivers/staging/wlan-ng/prism2mgmt.c
@@ -61,9 +61,6 @@
 /* System Includes */
 #define WLAN_DBVAR	prism2_debug
 
-#include "version.h"
-
-
 #include <linux/version.h>
 
 #include <linux/if_arp.h>

commit 5db8dcc98baaa5ef5fe53b411e40348ce31a1418
Author: Solomon Peachy <pizza@shaftnet.org>
Date:   Mon Oct 27 11:14:02 2008 -0400

    Staging: wlan-ng: Remove AP-only code from MLME functions.
    
    It is not needed in this driver.
    
    Signed-off-by: Solomon Peachy <pizza@shaftnet.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/wlan-ng/prism2mgmt.c b/drivers/staging/wlan-ng/prism2mgmt.c
index 5996b640ab3f..de2ec1e7c9de 100644
--- a/drivers/staging/wlan-ng/prism2mgmt.c
+++ b/drivers/staging/wlan-ng/prism2mgmt.c
@@ -97,89 +97,12 @@
 #include "hfa384x.h"
 #include "prism2mgmt.h"
 
-/*================================================================*/
-/* Local Constants */
-
-
-/*================================================================*/
-/* Local Macros */
-
 /* Converts 802.11 format rate specifications to prism2 */
 #define p80211rate_to_p2bit(n)	((((n)&~BIT7) == 2) ? BIT0 : \
 				 (((n)&~BIT7) == 4) ? BIT1 : \
 				 (((n)&~BIT7) == 11) ? BIT2 : \
 				 (((n)&~BIT7) == 22) ? BIT3 : 0)
 
-/*================================================================*/
-/* Local Types */
-
-
-/*================================================================*/
-/* Local Static Definitions */
-
-
-/*================================================================*/
-/* Local Function Declarations */
-
-
-/*================================================================*/
-/* Function Definitions */
-
-
-/*----------------------------------------------------------------
-* prism2mgmt_powermgmt
-*
-* Set the power management state of this station's MAC.
-*
-* Arguments:
-*	wlandev		wlan device structure
-*	msgp		ptr to msg buffer
-*
-* Returns:
-*	0	success and done
-*	<0	success, but we're waiting for something to finish.
-*	>0	an error occurred while handling the message.
-* Side effects:
-*
-* Call context:
-*	process thread  (usually)
-*	interrupt
-----------------------------------------------------------------*/
-int prism2mgmt_powermgmt(wlandevice_t *wlandev, void *msgp)
-{
-	int 			result = 0;
-	hfa384x_t		*hw = wlandev->priv;
-	p80211msg_dot11req_powermgmt_t	*msg = msgp;
-
-	DBFENTER;
-
-	if (!hw->ap) {
-
-		/*** STATION ***/
-
-		/*
-		 * Set CNFPMENABLED (on or off)
-		 * Set CNFMULTICASTRX (if PM on, otherwise clear)
-		 * Spout a notice stating that SleepDuration and
-		 * HoldoverDuration and PMEPS also have an impact.
-		 */
-		/* Powermgmt is currently unsupported for STA */
-		msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;
-		msg->resultcode.data = P80211ENUM_resultcode_not_supported;
-	} else {
-
-		/*** ACCESS POINT ***/
-
-		/* Powermgmt is never supported for AP */
-		msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;
-		msg->resultcode.data = P80211ENUM_resultcode_not_supported;
-	}
-
-	DBFEXIT;
-	return result;
-}
-
-
 /*----------------------------------------------------------------
 * prism2mgmt_scan
 *
@@ -217,13 +140,6 @@ int prism2mgmt_scan(wlandevice_t *wlandev, void *msgp)
 
 	DBFENTER;
 
-        if (hw->ap) {
-                WLAN_LOG_ERROR("Prism2 in AP mode cannot perform scans.\n");
-                result = 1;
-                msg->resultcode.data = P80211ENUM_resultcode_not_supported;
-                goto exit;
-        }
-
         /* gatekeeper check */
         if (HFA384x_FIRMWARE_VERSION(hw->ident_sta_fw.major,
                                      hw->ident_sta_fw.minor,
@@ -468,12 +384,6 @@ int prism2mgmt_scan_results(wlandevice_t *wlandev, void *msgp)
 
 	req->resultcode.status = P80211ENUM_msgitem_status_data_ok;
 
-	if (hw->ap) {
-		result = 1;
-		req->resultcode.data = P80211ENUM_resultcode_not_supported;
-		goto exit;
-	}
-
 	if (! hw->scanresults) {
 		WLAN_LOG_ERROR("dot11req_scan_results can only be used after a successful dot11req_scan.\n");
 		result = 2;
@@ -600,55 +510,6 @@ int prism2mgmt_scan_results(wlandevice_t *wlandev, void *msgp)
 	return result;
 }
 
-
-/*----------------------------------------------------------------
-* prism2mgmt_join
-*
-* Join a BSS whose BSS description was previously obtained with
-* a scan.
-*
-* Arguments:
-*	wlandev		wlan device structure
-*	msgp		ptr to msg buffer
-*
-* Returns:
-*	0	success and done
-*	<0	success, but we're waiting for something to finish.
-*	>0	an error occurred while handling the message.
-* Side effects:
-*
-* Call context:
-*	process thread  (usually)
-*	interrupt
-----------------------------------------------------------------*/
-int prism2mgmt_join(wlandevice_t *wlandev, void *msgp)
-{
-	int 			result = 0;
-	hfa384x_t		*hw = wlandev->priv;
-	p80211msg_dot11req_join_t	*msg = msgp;
-	DBFENTER;
-
-	if (!hw->ap) {
-
-		/*** STATION ***/
-
-		/* TODO: Implement after scan */
-		msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;
-		msg->resultcode.data = P80211ENUM_resultcode_not_supported;
-	} else {
-
-		/*** ACCESS POINT ***/
-
-		/* Never supported by APs */
-		msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;
-		msg->resultcode.data = P80211ENUM_resultcode_not_supported;
-	}
-
-	DBFEXIT;
-	return result;
-}
-
-
 /*----------------------------------------------------------------
 * prism2mgmt_p2_join
 *
@@ -680,380 +541,162 @@ int prism2mgmt_p2_join(wlandevice_t *wlandev, void *msgp)
         hfa384x_JoinRequest_data_t	joinreq;
 	DBFENTER;
 
-	if (!hw->ap) {
-
-		wlandev->macmode = WLAN_MACMODE_NONE;
-
-		/*** STATION ***/
-		/* Set the PortType */
-		msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;
-		msg->resultcode.data = P80211ENUM_resultcode_success;
-
-		/* ess port */
-		result = hfa384x_drvr_setconfig16(hw, HFA384x_RID_CNFPORTTYPE, 1);
-		if ( result ) {
-			WLAN_LOG_ERROR("Failed to set Port Type\n");
-			goto failed;
-		}
-
-		/* Set the auth type */
-		if ( msg->authtype.data == P80211ENUM_authalg_sharedkey ) {
-			reg = HFA384x_CNFAUTHENTICATION_SHAREDKEY;
-		} else {
-			reg = HFA384x_CNFAUTHENTICATION_OPENSYSTEM;
-		}
-		result = hfa384x_drvr_setconfig16(hw, HFA384x_RID_CNFAUTHENTICATION, reg);
-		if ( result ) {
-			WLAN_LOG_ERROR("Failed to set Authentication\n");
-			goto failed;
-		}
-
-		/* Turn off all roaming */
-		hfa384x_drvr_setconfig16(hw, HFA384x_RID_CNFROAMINGMODE, 3);
-		if ( result ) {
-			WLAN_LOG_ERROR("Failed to Turn off Roaming\n");
-			goto failed;
-		}
-
-		/* Basic rates */
-                reg = 0;
-		if ( msg->basicrate1.status == P80211ENUM_msgitem_status_data_ok ) {
-			reg = p80211rate_to_p2bit(msg->basicrate1.data);
-		}
-		if ( msg->basicrate2.status == P80211ENUM_msgitem_status_data_ok ) {
-			reg |= p80211rate_to_p2bit(msg->basicrate2.data);
-		}
-		if ( msg->basicrate3.status == P80211ENUM_msgitem_status_data_ok ) {
-			reg |= p80211rate_to_p2bit(msg->basicrate3.data);
-		}
-		if ( msg->basicrate4.status == P80211ENUM_msgitem_status_data_ok ) {
-			reg |= p80211rate_to_p2bit(msg->basicrate4.data);
-		}
-		if ( msg->basicrate5.status == P80211ENUM_msgitem_status_data_ok ) {
-			reg |= p80211rate_to_p2bit(msg->basicrate5.data);
-		}
-		if ( msg->basicrate6.status == P80211ENUM_msgitem_status_data_ok ) {
-			reg |= p80211rate_to_p2bit(msg->basicrate6.data);
-		}
-		if ( msg->basicrate7.status == P80211ENUM_msgitem_status_data_ok ) {
-			reg |= p80211rate_to_p2bit(msg->basicrate7.data);
-		}
-		if ( msg->basicrate8.status == P80211ENUM_msgitem_status_data_ok ) {
-			reg |= p80211rate_to_p2bit(msg->basicrate8.data);
-		}
-		if( reg == 0)
-			 reg = 0x03;
-		result = hfa384x_drvr_setconfig16(hw, HFA384x_RID_CNFBASICRATES, reg);
-		if ( result ) {
-			WLAN_LOG_ERROR("Failed to set basicrates=%d.\n", reg);
-			goto failed;
-		}
-
-		/* Operational rates (supprates and txratecontrol) */
-		reg = 0;
-		if ( msg->operationalrate1.status == P80211ENUM_msgitem_status_data_ok ) {
-			reg = p80211rate_to_p2bit(msg->operationalrate1.data);
-		}
-		if ( msg->operationalrate2.status == P80211ENUM_msgitem_status_data_ok ) {
-			reg |= p80211rate_to_p2bit(msg->operationalrate2.data);
-		}
-		if ( msg->operationalrate3.status == P80211ENUM_msgitem_status_data_ok ) {
-			reg |= p80211rate_to_p2bit(msg->operationalrate3.data);
-		}
-		if ( msg->operationalrate4.status == P80211ENUM_msgitem_status_data_ok ) {
-			reg |= p80211rate_to_p2bit(msg->operationalrate4.data);
-		}
-		if ( msg->operationalrate5.status == P80211ENUM_msgitem_status_data_ok ) {
-			reg |= p80211rate_to_p2bit(msg->operationalrate5.data);
-		}
-		if ( msg->operationalrate6.status == P80211ENUM_msgitem_status_data_ok ) {
-			reg |= p80211rate_to_p2bit(msg->operationalrate6.data);
-		}
-		if ( msg->operationalrate7.status == P80211ENUM_msgitem_status_data_ok ) {
-			reg |= p80211rate_to_p2bit(msg->operationalrate7.data);
-		}
-		if ( msg->operationalrate8.status == P80211ENUM_msgitem_status_data_ok ) {
-			reg |= p80211rate_to_p2bit(msg->operationalrate8.data);
-		}
-		if( reg == 0)
-			 reg = 0x0f;
-		result = hfa384x_drvr_setconfig16(hw, HFA384x_RID_CNFSUPPRATES, reg);
-		if ( result ) {
-			WLAN_LOG_ERROR("Failed to set supprates=%d.\n", reg);
-			goto failed;
-		}
-
- 		result = hfa384x_drvr_setconfig16(hw, HFA384x_RID_TXRATECNTL, reg);
-		if ( result ) {
-			WLAN_LOG_ERROR("Failed to set txrates=%d.\n", reg);
-			goto failed;
-		}
-
-		/* Set the ssid */
-		memset(bytebuf, 0, 256);
-		pstr = (p80211pstrd_t*)&(msg->ssid.data);
-		prism2mgmt_pstr2bytestr(p2bytestr, pstr);
-		result = hfa384x_drvr_setconfig(
-			hw, HFA384x_RID_CNFDESIREDSSID,
-			bytebuf, HFA384x_RID_CNFDESIREDSSID_LEN);
-		if ( result ) {
-			WLAN_LOG_ERROR("Failed to set SSID\n");
-			goto failed;
-		}
-
-		/* Enable the Port */
-		result = hfa384x_cmd_enable(hw, 0);
-		if ( result ) {
-			WLAN_LOG_ERROR("Enable macport failed, result=%d.\n", result);
-			goto failed;
-		}
-
-		/* Fill in the join request */
-		joinreq.channel = msg->channel.data;
-		memcpy( joinreq.bssid, ((unsigned char *) &msg->bssid.data) + 1, WLAN_BSSID_LEN);
-		hw->joinreq = joinreq;
-		hw->join_ap = 1;
-
-		/* Send the join request */
-		result = hfa384x_drvr_setconfig( hw,
-			HFA384x_RID_JOINREQUEST,
-			&joinreq, HFA384x_RID_JOINREQUEST_LEN);
-                if(result != 0) {
-			WLAN_LOG_ERROR("Join request failed, result=%d.\n", result);
-			goto failed;
-		}
-
-	} else {
+	wlandev->macmode = WLAN_MACMODE_NONE;
 
-		/*** ACCESS POINT ***/
+	/* Set the PortType */
+	msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;
+	msg->resultcode.data = P80211ENUM_resultcode_success;
 
-		/* Never supported by APs */
-		msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;
-		msg->resultcode.data = P80211ENUM_resultcode_not_supported;
+	/* ess port */
+	result = hfa384x_drvr_setconfig16(hw, HFA384x_RID_CNFPORTTYPE, 1);
+	if ( result ) {
+		WLAN_LOG_ERROR("Failed to set Port Type\n");
+		goto failed;
 	}
 
-        goto done;
-failed:
-	WLAN_LOG_DEBUG(1, "Failed to set a config option, result=%d\n", result);
-	msg->resultcode.data = P80211ENUM_resultcode_invalid_parameters;
-
-done:
-        result = 0;
-
-	DBFEXIT;
-	return result;
-}
-
-
-/*----------------------------------------------------------------
-* prism2mgmt_authenticate
-*
-* Station should be begin an authentication exchange.
-*
-* Arguments:
-*	wlandev		wlan device structure
-*	msgp		ptr to msg buffer
-*
-* Returns:
-*	0	success and done
-*	<0	success, but we're waiting for something to finish.
-*	>0	an error occurred while handling the message.
-* Side effects:
-*
-* Call context:
-*	process thread  (usually)
-*	interrupt
-----------------------------------------------------------------*/
-int prism2mgmt_authenticate(wlandevice_t *wlandev, void *msgp)
-{
-	int 			result = 0;
-	hfa384x_t		*hw = wlandev->priv;
-	p80211msg_dot11req_authenticate_t	*msg = msgp;
-	DBFENTER;
-
-	if (!hw->ap) {
-
-		/*** STATION ***/
-
-		/* TODO: Decide how we're going to handle this one w/ Prism2 */
-		/*       It could be entertaining since Prism2 doesn't have  */
-		/*       an explicit way to control this */
-		msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;
-		msg->resultcode.data = P80211ENUM_resultcode_not_supported;
+	/* Set the auth type */
+	if ( msg->authtype.data == P80211ENUM_authalg_sharedkey ) {
+		reg = HFA384x_CNFAUTHENTICATION_SHAREDKEY;
 	} else {
-
-		/*** ACCESS POINT ***/
-
-		/* Never supported by APs */
-		msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;
-		msg->resultcode.data = P80211ENUM_resultcode_not_supported;
+		reg = HFA384x_CNFAUTHENTICATION_OPENSYSTEM;
 	}
-
-	DBFEXIT;
-	return result;
-}
-
-
-/*----------------------------------------------------------------
-* prism2mgmt_deauthenticate
-*
-* Send a deauthenticate notification.
-*
-* Arguments:
-*	wlandev		wlan device structure
-*	msgp		ptr to msg buffer
-*
-* Returns:
-*	0	success and done
-*	<0	success, but we're waiting for something to finish.
-*	>0	an error occurred while handling the message.
-* Side effects:
-*
-* Call context:
-*	process thread  (usually)
-*	interrupt
-----------------------------------------------------------------*/
-int prism2mgmt_deauthenticate(wlandevice_t *wlandev, void *msgp)
-{
-	int 			result = 0;
-	hfa384x_t		*hw = wlandev->priv;
-	p80211msg_dot11req_deauthenticate_t	*msg = msgp;
-	DBFENTER;
-
-	if (!hw->ap) {
-
-		/*** STATION ***/
-
-		/* TODO: Decide how we're going to handle this one w/ Prism2 */
-		/*       It could be entertaining since Prism2 doesn't have  */
-		/*       an explicit way to control this */
-		msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;
-		msg->resultcode.data = P80211ENUM_resultcode_not_supported;
-	} else {
-
-		/*** ACCESS POINT ***/
-		hfa384x_drvr_handover(hw, msg->peerstaaddress.data.data);
-		msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;
-		msg->resultcode.data = P80211ENUM_resultcode_success;
+	result = hfa384x_drvr_setconfig16(hw, HFA384x_RID_CNFAUTHENTICATION, reg);
+	if ( result ) {
+		WLAN_LOG_ERROR("Failed to set Authentication\n");
+		goto failed;
 	}
 
-	DBFEXIT;
-	return result;
-}
-
-
-/*----------------------------------------------------------------
-* prism2mgmt_associate
-*
-* Associate with an ESS.
-*
-* Arguments:
-*	wlandev		wlan device structure
-*	msgp		ptr to msg buffer
-*
-* Returns:
-*	0	success and done
-*	<0	success, but we're waiting for something to finish.
-*	>0	an error occurred while handling the message.
-* Side effects:
-*
-* Call context:
-*	process thread  (usually)
-*	interrupt
-----------------------------------------------------------------*/
-int prism2mgmt_associate(wlandevice_t *wlandev, void *msgp)
-{
-	hfa384x_t		*hw = wlandev->priv;
-	int 			result = 0;
-	p80211msg_dot11req_associate_t	*msg = msgp;
-	DBFENTER;
-
-	if (!hw->ap) {
-
-		/*** STATION ***/
-
-#if 0
-		/* Set the TxRates */
-		reg = 0x000f;
-		hfa384x_drvr_setconfig16(hw, HFA384x_RID_TXRATECNTL, reg);
-#endif
-
-		/* Set the PortType */
-		/* ess port */
-		hfa384x_drvr_setconfig16(hw, HFA384x_RID_CNFPORTTYPE, 1);
-
-		/* Enable the Port */
-		hfa384x_drvr_enable(hw, 0);
-
-		/* Set the resultcode */
-		msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;
-		msg->resultcode.data = P80211ENUM_resultcode_success;
-
-	} else {
+	/* Turn off all roaming */
+	hfa384x_drvr_setconfig16(hw, HFA384x_RID_CNFROAMINGMODE, 3);
+	if ( result ) {
+		WLAN_LOG_ERROR("Failed to Turn off Roaming\n");
+		goto failed;
+	}
 
-		/*** ACCESS POINT ***/
+	/* Basic rates */
+	reg = 0;
+	if ( msg->basicrate1.status == P80211ENUM_msgitem_status_data_ok ) {
+		reg = p80211rate_to_p2bit(msg->basicrate1.data);
+	}
+	if ( msg->basicrate2.status == P80211ENUM_msgitem_status_data_ok ) {
+		reg |= p80211rate_to_p2bit(msg->basicrate2.data);
+	}
+	if ( msg->basicrate3.status == P80211ENUM_msgitem_status_data_ok ) {
+		reg |= p80211rate_to_p2bit(msg->basicrate3.data);
+	}
+	if ( msg->basicrate4.status == P80211ENUM_msgitem_status_data_ok ) {
+		reg |= p80211rate_to_p2bit(msg->basicrate4.data);
+	}
+	if ( msg->basicrate5.status == P80211ENUM_msgitem_status_data_ok ) {
+		reg |= p80211rate_to_p2bit(msg->basicrate5.data);
+	}
+	if ( msg->basicrate6.status == P80211ENUM_msgitem_status_data_ok ) {
+		reg |= p80211rate_to_p2bit(msg->basicrate6.data);
+	}
+	if ( msg->basicrate7.status == P80211ENUM_msgitem_status_data_ok ) {
+		reg |= p80211rate_to_p2bit(msg->basicrate7.data);
+	}
+	if ( msg->basicrate8.status == P80211ENUM_msgitem_status_data_ok ) {
+		reg |= p80211rate_to_p2bit(msg->basicrate8.data);
+	}
+	if( reg == 0)
+		reg = 0x03;
+	result = hfa384x_drvr_setconfig16(hw, HFA384x_RID_CNFBASICRATES, reg);
+	if ( result ) {
+		WLAN_LOG_ERROR("Failed to set basicrates=%d.\n", reg);
+		goto failed;
+	}
 
-		/* Never supported on AP */
-		msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;
-		msg->resultcode.data = P80211ENUM_resultcode_not_supported;
+	/* Operational rates (supprates and txratecontrol) */
+	reg = 0;
+	if ( msg->operationalrate1.status == P80211ENUM_msgitem_status_data_ok ) {
+		reg = p80211rate_to_p2bit(msg->operationalrate1.data);
+	}
+	if ( msg->operationalrate2.status == P80211ENUM_msgitem_status_data_ok ) {
+		reg |= p80211rate_to_p2bit(msg->operationalrate2.data);
+	}
+	if ( msg->operationalrate3.status == P80211ENUM_msgitem_status_data_ok ) {
+		reg |= p80211rate_to_p2bit(msg->operationalrate3.data);
+	}
+	if ( msg->operationalrate4.status == P80211ENUM_msgitem_status_data_ok ) {
+		reg |= p80211rate_to_p2bit(msg->operationalrate4.data);
+	}
+	if ( msg->operationalrate5.status == P80211ENUM_msgitem_status_data_ok ) {
+		reg |= p80211rate_to_p2bit(msg->operationalrate5.data);
+	}
+	if ( msg->operationalrate6.status == P80211ENUM_msgitem_status_data_ok ) {
+		reg |= p80211rate_to_p2bit(msg->operationalrate6.data);
+	}
+	if ( msg->operationalrate7.status == P80211ENUM_msgitem_status_data_ok ) {
+		reg |= p80211rate_to_p2bit(msg->operationalrate7.data);
+	}
+	if ( msg->operationalrate8.status == P80211ENUM_msgitem_status_data_ok ) {
+		reg |= p80211rate_to_p2bit(msg->operationalrate8.data);
+	}
+	if( reg == 0)
+		reg = 0x0f;
+	result = hfa384x_drvr_setconfig16(hw, HFA384x_RID_CNFSUPPRATES, reg);
+	if ( result ) {
+		WLAN_LOG_ERROR("Failed to set supprates=%d.\n", reg);
+		goto failed;
 	}
 
-	DBFEXIT;
-	return result;
-}
-
+	result = hfa384x_drvr_setconfig16(hw, HFA384x_RID_TXRATECNTL, reg);
+	if ( result ) {
+		WLAN_LOG_ERROR("Failed to set txrates=%d.\n", reg);
+		goto failed;
+	}
 
-/*----------------------------------------------------------------
-* prism2mgmt_reassociate
-*
-* Renew association because of a BSS change.
-*
-* Arguments:
-*	wlandev		wlan device structure
-*	msgp		ptr to msg buffer
-*
-* Returns:
-*	0	success and done
-*	<0	success, but we're waiting for something to finish.
-*	>0	an error occurred while handling the message.
-* Side effects:
-*
-* Call context:
-*	process thread  (usually)
-*	interrupt
-----------------------------------------------------------------*/
-int prism2mgmt_reassociate(wlandevice_t *wlandev, void *msgp)
-{
-	int 			result = 0;
-	hfa384x_t		*hw = wlandev->priv;
-	p80211msg_dot11req_reassociate_t	*msg = msgp;
-	DBFENTER;
+	/* Set the ssid */
+	memset(bytebuf, 0, 256);
+	pstr = (p80211pstrd_t*)&(msg->ssid.data);
+	prism2mgmt_pstr2bytestr(p2bytestr, pstr);
+	result = hfa384x_drvr_setconfig(
+		hw, HFA384x_RID_CNFDESIREDSSID,
+		bytebuf, HFA384x_RID_CNFDESIREDSSID_LEN);
+	if ( result ) {
+		WLAN_LOG_ERROR("Failed to set SSID\n");
+		goto failed;
+	}
 
-	if (!hw->ap) {
+	/* Enable the Port */
+	result = hfa384x_cmd_enable(hw, 0);
+	if ( result ) {
+		WLAN_LOG_ERROR("Enable macport failed, result=%d.\n", result);
+		goto failed;
+	}
 
-		/*** STATION ***/
+	/* Fill in the join request */
+	joinreq.channel = msg->channel.data;
+	memcpy( joinreq.bssid, ((unsigned char *) &msg->bssid.data) + 1, WLAN_BSSID_LEN);
+	hw->joinreq = joinreq;
+	hw->join_ap = 1;
 
-		/* TODO: Not supported yet...not sure how we're going to do it */
-		msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;
-		msg->resultcode.data = P80211ENUM_resultcode_not_supported;
-	} else {
+	/* Send the join request */
+	result = hfa384x_drvr_setconfig( hw,
+					 HFA384x_RID_JOINREQUEST,
+					 &joinreq, HFA384x_RID_JOINREQUEST_LEN);
+	if(result != 0) {
+		WLAN_LOG_ERROR("Join request failed, result=%d.\n", result);
+		goto failed;
+	}
 
-		/*** ACCESS POINT ***/
+        goto done;
+failed:
+	WLAN_LOG_DEBUG(1, "Failed to set a config option, result=%d\n", result);
+	msg->resultcode.data = P80211ENUM_resultcode_invalid_parameters;
 
-		/* Never supported on AP */
-		msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;
-		msg->resultcode.data = P80211ENUM_resultcode_not_supported;
-	}
+done:
+        result = 0;
 
 	DBFEXIT;
 	return result;
 }
 
-
 /*----------------------------------------------------------------
-* prism2mgmt_disassociate
+* prism2mgmt_associate
 *
-* Send a disassociation notification.
+* Associate with an ESS.
 *
 * Arguments:
 *	wlandev		wlan device structure
@@ -1069,33 +712,34 @@ int prism2mgmt_reassociate(wlandevice_t *wlandev, void *msgp)
 *	process thread  (usually)
 *	interrupt
 ----------------------------------------------------------------*/
-int prism2mgmt_disassociate(wlandevice_t *wlandev, void *msgp)
+int prism2mgmt_associate(wlandevice_t *wlandev, void *msgp)
 {
-	int 			result = 0;
 	hfa384x_t		*hw = wlandev->priv;
-	p80211msg_dot11req_disassociate_t	*msg = msgp;
+	int 			result = 0;
+	p80211msg_dot11req_associate_t	*msg = msgp;
 	DBFENTER;
 
-	if (!hw->ap) {
+#if 0
+	/* Set the TxRates */
+	reg = 0x000f;
+	hfa384x_drvr_setconfig16(hw, HFA384x_RID_TXRATECNTL, reg);
+#endif
 
-		/*** STATION ***/
+	/* Set the PortType */
+	/* ess port */
+	hfa384x_drvr_setconfig16(hw, HFA384x_RID_CNFPORTTYPE, 1);
 
-		/* TODO: Not supported yet...not sure how to do it */
-		msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;
-		msg->resultcode.data = P80211ENUM_resultcode_not_supported;
-	} else {
+	/* Enable the Port */
+	hfa384x_drvr_enable(hw, 0);
 
-		/*** ACCESS POINT ***/
-		hfa384x_drvr_handover(hw, msg->peerstaaddress.data.data);
-		msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;
-		msg->resultcode.data = P80211ENUM_resultcode_success;
-	}
+	/* Set the resultcode */
+	msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;
+	msg->resultcode.data = P80211ENUM_resultcode_success;
 
 	DBFEXIT;
 	return result;
 }
 
-
 /*----------------------------------------------------------------
 * prism2mgmt_reset
 *
@@ -1189,7 +833,6 @@ int prism2mgmt_start(wlandevice_t *wlandev, void *msgp)
 	p80211pstrd_t		*pstr;
 	UINT8			bytebuf[80];
 	hfa384x_bytestr_t	*p2bytestr = (hfa384x_bytestr_t*)bytebuf;
-	hfa384x_PCFInfo_data_t	*pcfinfo = (hfa384x_PCFInfo_data_t*)bytebuf;
 	UINT16			word;
 	DBFENTER;
 
@@ -1198,166 +841,41 @@ int prism2mgmt_start(wlandevice_t *wlandev, void *msgp)
 	/* Set the SSID */
 	memcpy(&wlandev->ssid, &msg->ssid.data, sizeof(msg->ssid.data));
 
-	if (!hw->ap) {
-		/*** ADHOC IBSS ***/
-		/* see if current f/w is less than 8c3 */
-		if (HFA384x_FIRMWARE_VERSION(hw->ident_sta_fw.major,
-					     hw->ident_sta_fw.minor,
-					     hw->ident_sta_fw.variant) <
-		    HFA384x_FIRMWARE_VERSION(0,8,3)) {
-			/* Ad-Hoc not quite supported on Prism2 */
-			msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;
-			msg->resultcode.data = P80211ENUM_resultcode_not_supported;
-			goto done;
-		}
-
-  		msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;
-
-		/*** STATION ***/
-		/* Set the REQUIRED config items */
-		/* SSID */
-		pstr = (p80211pstrd_t*)&(msg->ssid.data);
-		prism2mgmt_pstr2bytestr(p2bytestr, pstr);
-		result = hfa384x_drvr_setconfig( hw, HFA384x_RID_CNFOWNSSID,
-				bytebuf, HFA384x_RID_CNFOWNSSID_LEN);
-		if ( result ) {
-			WLAN_LOG_ERROR("Failed to set CnfOwnSSID\n");
-			goto failed;
-		}
-		result = hfa384x_drvr_setconfig( hw, HFA384x_RID_CNFDESIREDSSID,
-				bytebuf, HFA384x_RID_CNFDESIREDSSID_LEN);
-		if ( result ) {
-			WLAN_LOG_ERROR("Failed to set CnfDesiredSSID\n");
-			goto failed;
-		}
-
-		/* bsstype - we use the default in the ap firmware */
-		/* IBSS port */
-		hfa384x_drvr_setconfig16(hw, HFA384x_RID_CNFPORTTYPE, 0);
-
-		/* beacon period */
-		word = msg->beaconperiod.data;
-		result = hfa384x_drvr_setconfig16(hw, HFA384x_RID_CNFAPBCNINT, word);
-		if ( result ) {
-			WLAN_LOG_ERROR("Failed to set beacon period=%d.\n", word);
-			goto failed;
-		}
-
-		/* dschannel */
-		word = msg->dschannel.data;
-		result = hfa384x_drvr_setconfig16(hw, HFA384x_RID_CNFOWNCHANNEL, word);
-		if ( result ) {
-			WLAN_LOG_ERROR("Failed to set channel=%d.\n", word);
-			goto failed;
-		}
-		/* Basic rates */
-		word = p80211rate_to_p2bit(msg->basicrate1.data);
-		if ( msg->basicrate2.status == P80211ENUM_msgitem_status_data_ok ) {
-			word |= p80211rate_to_p2bit(msg->basicrate2.data);
-		}
-		if ( msg->basicrate3.status == P80211ENUM_msgitem_status_data_ok ) {
-			word |= p80211rate_to_p2bit(msg->basicrate3.data);
-		}
-		if ( msg->basicrate4.status == P80211ENUM_msgitem_status_data_ok ) {
-			word |= p80211rate_to_p2bit(msg->basicrate4.data);
-		}
-		if ( msg->basicrate5.status == P80211ENUM_msgitem_status_data_ok ) {
-			word |= p80211rate_to_p2bit(msg->basicrate5.data);
-		}
-		if ( msg->basicrate6.status == P80211ENUM_msgitem_status_data_ok ) {
-			word |= p80211rate_to_p2bit(msg->basicrate6.data);
-		}
-		if ( msg->basicrate7.status == P80211ENUM_msgitem_status_data_ok ) {
-			word |= p80211rate_to_p2bit(msg->basicrate7.data);
-		}
-		if ( msg->basicrate8.status == P80211ENUM_msgitem_status_data_ok ) {
-			word |= p80211rate_to_p2bit(msg->basicrate8.data);
-		}
-		result = hfa384x_drvr_setconfig16(hw, HFA384x_RID_CNFBASICRATES, word);
-		if ( result ) {
-			WLAN_LOG_ERROR("Failed to set basicrates=%d.\n", word);
-			goto failed;
-		}
-
-		/* Operational rates (supprates and txratecontrol) */
-		word = p80211rate_to_p2bit(msg->operationalrate1.data);
-		if ( msg->operationalrate2.status == P80211ENUM_msgitem_status_data_ok ) {
-			word |= p80211rate_to_p2bit(msg->operationalrate2.data);
-		}
-		if ( msg->operationalrate3.status == P80211ENUM_msgitem_status_data_ok ) {
-			word |= p80211rate_to_p2bit(msg->operationalrate3.data);
-		}
-		if ( msg->operationalrate4.status == P80211ENUM_msgitem_status_data_ok ) {
-			word |= p80211rate_to_p2bit(msg->operationalrate4.data);
-		}
-		if ( msg->operationalrate5.status == P80211ENUM_msgitem_status_data_ok ) {
-			word |= p80211rate_to_p2bit(msg->operationalrate5.data);
-		}
-		if ( msg->operationalrate6.status == P80211ENUM_msgitem_status_data_ok ) {
-			word |= p80211rate_to_p2bit(msg->operationalrate6.data);
-		}
-		if ( msg->operationalrate7.status == P80211ENUM_msgitem_status_data_ok ) {
-			word |= p80211rate_to_p2bit(msg->operationalrate7.data);
-		}
-		if ( msg->operationalrate8.status == P80211ENUM_msgitem_status_data_ok ) {
-			word |= p80211rate_to_p2bit(msg->operationalrate8.data);
-		}
-		result = hfa384x_drvr_setconfig16(hw, HFA384x_RID_CNFSUPPRATES, word);
-		if ( result ) {
-			WLAN_LOG_ERROR("Failed to set supprates=%d.\n", word);
-			goto failed;
-		}
-
- 		result = hfa384x_drvr_setconfig16(hw, HFA384x_RID_TXRATECNTL, word);
-		if ( result ) {
-			WLAN_LOG_ERROR("Failed to set txrates=%d.\n", word);
-			goto failed;
-		}
-
-		/* Set the macmode so the frame setup code knows what to do */
-		if ( msg->bsstype.data == P80211ENUM_bsstype_independent ) {
-			wlandev->macmode = WLAN_MACMODE_IBSS_STA;
-			/* lets extend the data length a bit */
-			hfa384x_drvr_setconfig16(hw, HFA384x_RID_CNFMAXDATALEN, 2304);
-		}
-
-		/* Enable the Port */
-		result = hfa384x_drvr_enable(hw, 0);
-		if ( result ) {
-			WLAN_LOG_ERROR("Enable macport failed, result=%d.\n", result);
-			goto failed;
-		}
-
-		msg->resultcode.data = P80211ENUM_resultcode_success;
-
+	/*** ADHOC IBSS ***/
+	/* see if current f/w is less than 8c3 */
+	if (HFA384x_FIRMWARE_VERSION(hw->ident_sta_fw.major,
+				     hw->ident_sta_fw.minor,
+				     hw->ident_sta_fw.variant) <
+	    HFA384x_FIRMWARE_VERSION(0,8,3)) {
+		/* Ad-Hoc not quite supported on Prism2 */
+		msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;
+		msg->resultcode.data = P80211ENUM_resultcode_not_supported;
 		goto done;
 	}
 
-	/*** ACCESS POINT ***/
-
 	msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;
 
-	/* Validate the command, if BSStype=infra is the tertiary loaded? */
-	if ( msg->bsstype.data == P80211ENUM_bsstype_independent ) {
-		WLAN_LOG_ERROR("AP driver cannot create IBSS.\n");
-		goto failed;
-	} else if ( hw->cap_sup_sta.id != 5) {
-		WLAN_LOG_ERROR("AP driver failed to detect AP firmware.\n");
-		goto failed;
-	}
-
+	/*** STATION ***/
 	/* Set the REQUIRED config items */
 	/* SSID */
 	pstr = (p80211pstrd_t*)&(msg->ssid.data);
 	prism2mgmt_pstr2bytestr(p2bytestr, pstr);
 	result = hfa384x_drvr_setconfig( hw, HFA384x_RID_CNFOWNSSID,
-				bytebuf, HFA384x_RID_CNFOWNSSID_LEN);
+					 bytebuf, HFA384x_RID_CNFOWNSSID_LEN);
 	if ( result ) {
-		WLAN_LOG_ERROR("Failed to set SSID, result=0x%04x\n", result);
+		WLAN_LOG_ERROR("Failed to set CnfOwnSSID\n");
+		goto failed;
+	}
+	result = hfa384x_drvr_setconfig( hw, HFA384x_RID_CNFDESIREDSSID,
+					 bytebuf, HFA384x_RID_CNFDESIREDSSID_LEN);
+	if ( result ) {
+		WLAN_LOG_ERROR("Failed to set CnfDesiredSSID\n");
 		goto failed;
 	}
 
 	/* bsstype - we use the default in the ap firmware */
+	/* IBSS port */
+	hfa384x_drvr_setconfig16(hw, HFA384x_RID_CNFPORTTYPE, 0);
 
 	/* beacon period */
 	word = msg->beaconperiod.data;
@@ -1431,98 +949,20 @@ int prism2mgmt_start(wlandevice_t *wlandev, void *msgp)
 		WLAN_LOG_ERROR("Failed to set supprates=%d.\n", word);
 		goto failed;
 	}
-	result = hfa384x_drvr_setconfig16(hw, HFA384x_RID_TXRATECNTL0, word);
-	if ( result ) {
-		WLAN_LOG_ERROR("Failed to set txrates=%d.\n", word);
-		goto failed;
-	}
-
-	/* ibssatimwindow */
-	if (msg->ibssatimwindow.status == P80211ENUM_msgitem_status_data_ok) {
-		WLAN_LOG_INFO("prism2mgmt_start: atimwindow not used in "
-			       "Infrastructure mode, ignored.\n");
-	}
-
-	/* DTIM period */
-	word = msg->dtimperiod.data;
-	result = hfa384x_drvr_setconfig16(hw, HFA384x_RID_CNFOWNDTIMPER, word);
-	if ( result ) {
-		WLAN_LOG_ERROR("Failed to set dtim period=%d.\n", word);
-		goto failed;
-	}
-
-	/* probedelay */
-	if (msg->probedelay.status == P80211ENUM_msgitem_status_data_ok) {
-		WLAN_LOG_INFO("prism2mgmt_start: probedelay not "
-			       "supported in prism2, ignored.\n");
-	}
-
-	/* cfpollable, cfpollreq, cfpperiod, cfpmaxduration */
-	if (msg->cfpollable.data == P80211ENUM_truth_true &&
-	    msg->cfpollreq.data == P80211ENUM_truth_true ) {
-		WLAN_LOG_ERROR("cfpollable=cfpollreq=true is illegal.\n");
-		result = -1;
-		goto failed;
-	}
-
-	/* read the PCFInfo and update */
-	result = hfa384x_drvr_getconfig(hw, HFA384x_RID_CNFAPPCFINFO,
-					pcfinfo, HFA384x_RID_CNFAPPCFINFO_LEN);
-	if ( result ) {
-		WLAN_LOG_INFO("prism2mgmt_start: read(pcfinfo) failed, "
-				"assume it's "
-				"not supported, pcf settings ignored.\n");
-		goto pcf_skip;
-	}
-	if ((msg->cfpollable.data == P80211ENUM_truth_false &&
-	     msg->cfpollreq.data == P80211ENUM_truth_false) ) {
-	    	pcfinfo->MediumOccupancyLimit = 0;
-		pcfinfo->CFPPeriod = 0;
-		pcfinfo->CFPMaxDuration = 0;
-		pcfinfo->CFPFlags &= host2hfa384x_16((UINT16)~BIT0);
-
-		if ( msg->cfpperiod.status == P80211ENUM_msgitem_status_data_ok ||
-		     msg->cfpmaxduration.status == P80211ENUM_msgitem_status_data_ok ) {
-			WLAN_LOG_WARNING(
-				"Setting cfpperiod or cfpmaxduration when "
-				"cfpollable and cfreq are false is pointless.\n");
-		}
-	}
-	if ((msg->cfpollable.data == P80211ENUM_truth_true ||
-	     msg->cfpollreq.data == P80211ENUM_truth_true) ) {
-		if ( msg->cfpollable.data == P80211ENUM_truth_true) {
-			pcfinfo->CFPFlags |= host2hfa384x_16((UINT16)BIT0);
-		}
-
-		if ( msg->cfpperiod.status == P80211ENUM_msgitem_status_data_ok) {
-			pcfinfo->CFPPeriod = msg->cfpperiod.data;
-			pcfinfo->CFPPeriod = host2hfa384x_16(pcfinfo->CFPPeriod);
-		}
 
-		if ( msg->cfpmaxduration.status == P80211ENUM_msgitem_status_data_ok) {
-			pcfinfo->CFPMaxDuration = msg->cfpmaxduration.data;
-			pcfinfo->CFPMaxDuration = host2hfa384x_16(pcfinfo->CFPMaxDuration);
-			pcfinfo->MediumOccupancyLimit = pcfinfo->CFPMaxDuration;
-		}
-	}
-	result = hfa384x_drvr_setconfig(hw, HFA384x_RID_CNFAPPCFINFO,
-					pcfinfo, HFA384x_RID_CNFAPPCFINFO_LEN);
+	result = hfa384x_drvr_setconfig16(hw, HFA384x_RID_TXRATECNTL, word);
 	if ( result ) {
-		WLAN_LOG_ERROR("write(pcfinfo) failed.\n");
+		WLAN_LOG_ERROR("Failed to set txrates=%d.\n", word);
 		goto failed;
 	}
 
-pcf_skip:
 	/* Set the macmode so the frame setup code knows what to do */
-	if ( msg->bsstype.data == P80211ENUM_bsstype_infrastructure ) {
-		wlandev->macmode = WLAN_MACMODE_ESS_AP;
+	if ( msg->bsstype.data == P80211ENUM_bsstype_independent ) {
+		wlandev->macmode = WLAN_MACMODE_IBSS_STA;
 		/* lets extend the data length a bit */
 		hfa384x_drvr_setconfig16(hw, HFA384x_RID_CNFMAXDATALEN, 2304);
 	}
 
-	/* Set the BSSID to the same as our MAC */
-	memcpy( wlandev->bssid, wlandev->netdev->dev_addr, WLAN_BSSID_LEN);
-
 	/* Enable the Port */
 	result = hfa384x_drvr_enable(hw, 0);
 	if ( result ) {
@@ -1544,80 +984,6 @@ int prism2mgmt_start(wlandevice_t *wlandev, void *msgp)
 	return result;
 }
 
-
-/*----------------------------------------------------------------
-* prism2mgmt_enable
-*
-* Start a BSS.  Any station can do this for IBSS, only AP for ESS.
-*
-* Arguments:
-*	wlandev		wlan device structure
-*	msgp		ptr to msg buffer
-*
-* Returns:
-*	0	success and done
-*	<0	success, but we're waiting for something to finish.
-*	>0	an error occurred while handling the message.
-* Side effects:
-*
-* Call context:
-*	process thread  (usually)
-*	interrupt
-----------------------------------------------------------------*/
-int prism2mgmt_enable(wlandevice_t *wlandev, void *msgp)
-{
-	int			result = 0;
-	hfa384x_t		*hw = wlandev->priv;
-	p80211msg_p2req_enable_t	*msg = msgp;
-	DBFENTER;
-
-	if (!hw->ap) {
-
-		/*** STATION ***/
-
-		/* Ad-Hoc not quite supported on Prism2 */
-		msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;
-		msg->resultcode.data = P80211ENUM_resultcode_not_supported;
-		goto done;
-	}
-
-	/*** ACCESS POINT ***/
-
-	msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;
-
-	/* Is the tertiary loaded? */
-	if ( hw->cap_sup_sta.id != 5) {
-		WLAN_LOG_ERROR("AP driver failed to detect AP firmware.\n");
-		goto failed;
-	}
-
-	/* Set the macmode so the frame setup code knows what to do */
-	wlandev->macmode = WLAN_MACMODE_ESS_AP;
-
-	/* Set the BSSID to the same as our MAC */
-	memcpy( wlandev->bssid, wlandev->netdev->dev_addr, WLAN_BSSID_LEN);
-
-	/* Enable the Port */
-	result = hfa384x_drvr_enable(hw, 0);
-	if ( result ) {
-		WLAN_LOG_ERROR("Enable macport failed, result=%d.\n", result);
-		goto failed;
-	}
-
-	msg->resultcode.data = P80211ENUM_resultcode_success;
-
-	goto done;
-failed:
-	msg->resultcode.data = P80211ENUM_resultcode_invalid_parameters;
-
-done:
-	result = 0;
-
-	DBFEXIT;
-	return result;
-}
-
-
 /*----------------------------------------------------------------
 * prism2mgmt_readpda
 *
@@ -2341,16 +1707,6 @@ int prism2mgmt_autojoin(wlandevice_t *wlandev, void *msgp)
 	/* Set the SSID */
 	memcpy(&wlandev->ssid, &msg->ssid.data, sizeof(msg->ssid.data));
 
-	if (hw->ap) {
-
-		/*** ACCESS POINT ***/
-
-		/* Never supported on AP */
-		msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;
-		msg->resultcode.data = P80211ENUM_resultcode_not_supported;
-		goto done;
-	}
-
 	/* Disable the Port */
 	hfa384x_drvr_disable(hw, 0);
 
@@ -2402,7 +1758,6 @@ int prism2mgmt_autojoin(wlandevice_t *wlandev, void *msgp)
 	msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;
 	msg->resultcode.data = P80211ENUM_resultcode_success;
 
-done:
 	DBFEXIT;
 	return result;
 }

commit f980c178ea9d631d17be73b2384ad692a9f64706
Author: Solomon Peachy <pizza@shaftnet.org>
Date:   Mon Oct 27 11:14:01 2008 -0400

    Staging: wlan-ng: Eliminate a boatload of tertiaryAP-only code.
    
    Signed-off-by: Solomon Peachy <pizza@shaftnet.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/wlan-ng/prism2mgmt.c b/drivers/staging/wlan-ng/prism2mgmt.c
index f850cf8607c1..5996b640ab3f 100644
--- a/drivers/staging/wlan-ng/prism2mgmt.c
+++ b/drivers/staging/wlan-ng/prism2mgmt.c
@@ -2305,175 +2305,6 @@ int prism2mgmt_dump_state(wlandevice_t *wlandev, void *msgp)
 	return result;
 }
 
-/*----------------------------------------------------------------
-* prism2mgmt_channel_info
-*
-* Issues a ChannelInfoRequest.
-*
-* Arguments:
-*	wlandev		wlan device structure
-*	msgp		ptr to msg buffer
-*
-* Returns:
-*	0	success and done
-*	<0	success, but we're waiting for something to finish.
-*	>0	an error occurred while handling the message.
-* Side effects:
-*
-* Call context:
-*	process thread  (usually)
-----------------------------------------------------------------*/
-int prism2mgmt_channel_info(wlandevice_t *wlandev, void *msgp)
-{
-	p80211msg_p2req_channel_info_t	*msg=msgp;
-	hfa384x_t			*hw = wlandev->priv;
-	int				result, i, n=0;
-	UINT16				channel_mask=0;
-	hfa384x_ChannelInfoRequest_data_t	chinforeq;
-	// unsigned long 			now;
-
-	DBFENTER;
-
-	if (!hw->ap) {
-
-		/*** STATION ***/
-
-		/* Not supported in STA f/w */
-		P80211_SET_INT(msg->resultcode, P80211ENUM_resultcode_not_supported);
-		goto done;
-	}
-
-	/*** ACCESS POINT ***/
-
-#define CHINFO_TIMEOUT 2
-
-	P80211_SET_INT(msg->resultcode, P80211ENUM_resultcode_success);
-
-	/* setting default value for channellist = all channels */
-	if (!msg->channellist.data) {
-		P80211_SET_INT(msg->channellist, 0x00007FFE);
-	}
-	/* setting default value for channeldwelltime = 100 ms */
-	if (!msg->channeldwelltime.data) {
-		P80211_SET_INT(msg->channeldwelltime, 100);
-	}
-	channel_mask = (UINT16) (msg->channellist.data >> 1);
-	for (i=0, n=0; i < 14; i++) {
-		if (channel_mask & (1<<i)) {
-			n++;
-		}
-	}
-	P80211_SET_INT(msg->numchinfo, n);
-	chinforeq.channelList = host2hfa384x_16(channel_mask);
-	chinforeq.channelDwellTime = host2hfa384x_16(msg->channeldwelltime.data);
-
-	atomic_set(&hw->channel_info.done, 1);
-
-	result = hfa384x_drvr_setconfig( hw, HFA384x_RID_CHANNELINFOREQUEST,
-					 &chinforeq, HFA384x_RID_CHANNELINFOREQUEST_LEN);
-	if ( result ) {
-		WLAN_LOG_ERROR("setconfig(CHANNELINFOREQUEST) failed. result=%d\n",
-				result);
-		msg->resultcode.data = P80211ENUM_resultcode_not_supported;
-		goto done;
-	}
-	/*
-	now = jiffies;
-	while (atomic_read(&hw->channel_info.done) != 1) {
-		if ((jiffies - now) > CHINFO_TIMEOUT*HZ) {
-			WLAN_LOG_NOTICE("ChannelInfo results not received in %d seconds, aborting.\n",
-					CHINFO_TIMEOUT);
-			msg->resultcode.data = P80211ENUM_resultcode_timeout;
-			goto done;
-		}
-		current->state = TASK_INTERRUPTIBLE;
-		schedule_timeout(HZ/4);
-		current->state = TASK_RUNNING;
-	}
-	*/
-
-done:
-
-	DBFEXIT;
-	return 0;
-}
-
-/*----------------------------------------------------------------
-* prism2mgmt_channel_info_results
-*
-* Returns required ChannelInfo result.
-*
-* Arguments:
-*	wlandev		wlan device structure
-*	msgp		ptr to msg buffer
-*
-* Returns:
-*	0	success and done
-*	<0	success, but we're waiting for something to finish.
-*	>0	an error occurred while handling the message.
-* Side effects:
-*
-* Call context:
-*	process thread  (usually)
-----------------------------------------------------------------*/
-int prism2mgmt_channel_info_results(wlandevice_t *wlandev, void *msgp)
-{
-	hfa384x_t			*hw = wlandev->priv;
-
-	p80211msg_p2req_channel_info_results_t	*msg=msgp;
-	int				result=0;
-	int		channel;
-
-	DBFENTER;
-
-	if (!hw->ap) {
-
-		/*** STATION ***/
-
-		/* Not supported in STA f/w */
-		P80211_SET_INT(msg->resultcode, P80211ENUM_resultcode_not_supported);
-		goto done;
-	}
-
-	/*** ACCESS POINT ***/
-
-	switch (atomic_read(&hw->channel_info.done)) {
-	case 0: msg->resultcode.status = P80211ENUM_msgitem_status_no_value;
-		goto done;
-	case 1: msg->resultcode.status = P80211ENUM_msgitem_status_incomplete_itemdata;
-		goto done;
-	}
-
-	P80211_SET_INT(msg->resultcode, P80211ENUM_resultcode_success);
-	channel=msg->channel.data-1;
-
-	if (channel < 0 || ! (hw->channel_info.results.scanchannels & 1<<channel) ) {
-		msg->resultcode.data = P80211ENUM_resultcode_invalid_parameters;
-		goto done;
-	}
-	WLAN_LOG_DEBUG(2, "chinfo_results: channel %d, avg/peak level=%d/%d dB, active=%d\n",
-			channel+1,
-			hw->channel_info.results.result[channel].anl,
-			hw->channel_info.results.result[channel].pnl,
-			hw->channel_info.results.result[channel].active
-		);
-	P80211_SET_INT(msg->avgnoiselevel, hw->channel_info.results.result[channel].anl);
-	P80211_SET_INT(msg->peaknoiselevel, hw->channel_info.results.result[channel].pnl);
-	P80211_SET_INT(msg->bssactive, hw->channel_info.results.result[channel].active &
-		HFA384x_CHINFORESULT_BSSACTIVE
-                ? P80211ENUM_truth_true
-                : P80211ENUM_truth_false) ;
-	P80211_SET_INT(msg->pcfactive, hw->channel_info.results.result[channel].active &
-		HFA384x_CHINFORESULT_PCFACTIVE
-                ? P80211ENUM_truth_true
-                : P80211ENUM_truth_false) ;
-
-done:
-	DBFEXIT;
-	return result;
-}
-
-
 /*----------------------------------------------------------------
 * prism2mgmt_autojoin
 *

commit dff1dc8caaa42774ea82201cb3698b70f1f173c9
Author: Solomon Peachy <pizza@shaftnet.org>
Date:   Mon Oct 27 11:13:57 2008 -0400

    Staging: wlan-ng: Delete PCI/PLX/PCMCIA-specific code.
    
    Also delete a large pile of code that existed to support <2.6 kernels.
    
    Signed-off-by: Solomon Peachy <pizza@shaftnet.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/wlan-ng/prism2mgmt.c b/drivers/staging/wlan-ng/prism2mgmt.c
index c975025b6ae0..f850cf8607c1 100644
--- a/drivers/staging/wlan-ng/prism2mgmt.c
+++ b/drivers/staging/wlan-ng/prism2mgmt.c
@@ -79,19 +79,7 @@
 #include <asm/io.h>
 #include <asm/byteorder.h>
 #include <linux/random.h>
-
-#if (WLAN_HOSTIF == WLAN_USB)
 #include <linux/usb.h>
-#endif
-
-#if (WLAN_HOSTIF == WLAN_PCMCIA)
-#include <pcmcia/version.h>
-#include <pcmcia/cs_types.h>
-#include <pcmcia/cs.h>
-#include <pcmcia/cistpl.h>
-#include <pcmcia/ds.h>
-#include <pcmcia/cisreg.h>
-#endif
 
 #include "wlan_compat.h"
 
@@ -1766,30 +1754,11 @@ int prism2mgmt_auxport_state(wlandevice_t *wlandev, void *msgp)
 {
 	p80211msg_p2req_auxport_state_t	*msg = msgp;
 
-#if (WLAN_HOSTIF != WLAN_USB)
-	hfa384x_t		*hw = wlandev->priv;
-	DBFENTER;
-
-	msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;
-	if (msg->enable.data == P80211ENUM_truth_true) {
-		if ( hfa384x_cmd_aux_enable(hw, 0) ) {
-			msg->resultcode.data = P80211ENUM_resultcode_implementation_failure;
-		} else {
-			msg->resultcode.data = P80211ENUM_resultcode_success;
-		}
-	} else {
-		hfa384x_cmd_aux_disable(hw);
-		msg->resultcode.data = P80211ENUM_resultcode_success;
-	}
-
-#else /* !USB */
 	DBFENTER;
 
 	msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;
 	msg->resultcode.data = P80211ENUM_resultcode_not_supported;
 
-#endif /* WLAN_HOSTIF != WLAN_USB */
-
 	DBFEXIT;
 	return 0;
 }
@@ -1817,43 +1786,12 @@ int prism2mgmt_auxport_state(wlandevice_t *wlandev, void *msgp)
 ----------------------------------------------------------------*/
 int prism2mgmt_auxport_read(wlandevice_t *wlandev, void *msgp)
 {
-#if (WLAN_HOSTIF != WLAN_USB)
-	hfa384x_t		*hw = wlandev->priv;
-	p80211msg_p2req_auxport_read_t	*msg = msgp;
-	UINT32			addr;
-	UINT32			len;
-	UINT8*			buf;
-	UINT32			maxlen = sizeof(msg->data.data);
-	DBFENTER;
-
-	if ( hw->auxen ) {
-		addr = msg->addr.data;
-		len = msg->len.data;
-		buf = msg->data.data;
-		if ( len <= maxlen ) {  /* max read/write size */
-			hfa384x_copy_from_aux(hw, addr, HFA384x_AUX_CTL_EXTDS, buf, len);
-			msg->resultcode.data = P80211ENUM_resultcode_success;
-		} else {
-			WLAN_LOG_DEBUG(1,"Attempt to read > maxlen from auxport.\n");
-			msg->resultcode.data = P80211ENUM_resultcode_refused;
-		}
-
-	} else {
-		msg->resultcode.data = P80211ENUM_resultcode_refused;
-	}
-	msg->data.status = P80211ENUM_msgitem_status_data_ok;
-	msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;
-
-	DBFEXIT;
-	return 0;
-#else
 	DBFENTER;
 
 	WLAN_LOG_ERROR("prism2mgmt_auxport_read: Not supported on USB.\n");
 
 	DBFEXIT;
 	return 0;
-#endif
 }
 
 
@@ -1879,40 +1817,10 @@ int prism2mgmt_auxport_read(wlandevice_t *wlandev, void *msgp)
 ----------------------------------------------------------------*/
 int prism2mgmt_auxport_write(wlandevice_t *wlandev, void *msgp)
 {
-#if (WLAN_HOSTIF != WLAN_USB)
-	hfa384x_t		*hw = wlandev->priv;
-	p80211msg_p2req_auxport_write_t	*msg = msgp;
-	UINT32			addr;
-	UINT32			len;
-	UINT8*			buf;
-	UINT32			maxlen = sizeof(msg->data.data);
-	DBFENTER;
-
-	if ( hw->auxen ) {
-		addr = msg->addr.data;
-		len = msg->len.data;
-		buf = msg->data.data;
-		if ( len <= maxlen ) {  /* max read/write size */
-			hfa384x_copy_to_aux(hw, addr, HFA384x_AUX_CTL_EXTDS, buf, len);
-		} else {
-			WLAN_LOG_DEBUG(1,"Attempt to write > maxlen from auxport.\n");
-			msg->resultcode.data = P80211ENUM_resultcode_refused;
-		}
-
-	} else {
-		msg->resultcode.data = P80211ENUM_resultcode_refused;
-	}
-	msg->data.status = P80211ENUM_msgitem_status_data_ok;
-	msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;
-
-	DBFEXIT;
-	return 0;
-#else
 	DBFENTER;
 	WLAN_LOG_ERROR("prism2mgmt_auxport_read: Not supported on USB.\n");
 	DBFEXIT;
 	return 0;
-#endif
 }
 
 /*----------------------------------------------------------------
@@ -2386,48 +2294,12 @@ int prism2mgmt_dump_state(wlandevice_t *wlandev, void *msgp)
 	p80211msg_p2req_dump_state_t	*msg = msgp;
 	int				result = 0;
 
-#if (WLAN_HOSTIF != WLAN_USB)
-	hfa384x_t		*hw = wlandev->priv;
-	UINT16				auxbuf[15];
-	DBFENTER;
-
-	WLAN_LOG_NOTICE("prism2 driver and hardware state:\n");
-	if  ( (result = hfa384x_cmd_aux_enable(hw, 0)) ) {
-		WLAN_LOG_ERROR("aux_enable failed, result=%d\n", result);
-		goto failed;
-	}
-	hfa384x_copy_from_aux(hw,
-		0x01e2,
-		HFA384x_AUX_CTL_EXTDS,
-		auxbuf,
-		sizeof(auxbuf));
-	hfa384x_cmd_aux_disable(hw);
-	WLAN_LOG_NOTICE("  cmac: FreeBlocks=%d\n", auxbuf[5]);
-	WLAN_LOG_NOTICE("  cmac: IntEn=0x%02x EvStat=0x%02x\n",
-		hfa384x_getreg(hw, HFA384x_INTEN),
-		hfa384x_getreg(hw, HFA384x_EVSTAT));
-
-	#ifdef USE_FID_STACK
-	WLAN_LOG_NOTICE("  drvr: txfid_top=%d stacksize=%d\n",
-		hw->txfid_top,HFA384x_DRVR_FIDSTACKLEN_MAX);
-	#else
-	WLAN_LOG_NOTICE("  drvr: txfid_head=%d txfid_tail=%d txfid_N=%d\n",
-		hw->txfid_head, hw->txfid_tail, hw->txfid_N);
-	#endif
-
-	msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;
-	msg->resultcode.data = P80211ENUM_resultcode_success;
-
-#else /* (WLAN_HOSTIF == WLAN_USB) */
-
 	DBFENTER;
 
 	msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;
 	msg->resultcode.data = P80211ENUM_resultcode_not_supported;
 	goto failed;
 
-#endif /* (WLAN_HOSTIF != WLAN_USB) */
-
 failed:
 	DBFEXIT;
 	return result;

commit 00b3ed1685089ff52169a715de11106ed37df087
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Thu Oct 2 11:29:28 2008 -0700

    Staging: add wlan-ng prism2 usb driver
    
    This adds the wlan-ng prism2 USB driver to the drivers/staging tree.
    
    The code was originally written by the linux-wlan-ng team, patched by
    some Novell engineers to properly work on newer kernels, and then hacked
    into place in order to get it to build properly in a single subdirectory
    within the kernel tree by me.
    
    It supports a wide range of older USB prism2 devices, and contains a
    80211 stack to support this single driver.
    
    Cc: Christian Zoz <zoz@suse.de>
    Cc: Andreas Gruenbacher <agruen@suse.de>
    Cc: linux-wireless <linux-wireless@vger.kernel.org>
    Cc: John Linville <linville@tuxdriver.com>
    Cc: Helmut Schaa <helmut.schaa@googlemail.com>
    Cc: linux-wlan-ng <solomon@linux-wlan.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/wlan-ng/prism2mgmt.c b/drivers/staging/wlan-ng/prism2mgmt.c
new file mode 100644
index 000000000000..c975025b6ae0
--- /dev/null
+++ b/drivers/staging/wlan-ng/prism2mgmt.c
@@ -0,0 +1,2956 @@
+/* src/prism2/driver/prism2mgmt.c
+*
+* Management request handler functions.
+*
+* Copyright (C) 1999 AbsoluteValue Systems, Inc.  All Rights Reserved.
+* --------------------------------------------------------------------
+*
+* linux-wlan
+*
+*   The contents of this file are subject to the Mozilla Public
+*   License Version 1.1 (the "License"); you may not use this file
+*   except in compliance with the License. You may obtain a copy of
+*   the License at http://www.mozilla.org/MPL/
+*
+*   Software distributed under the License is distributed on an "AS
+*   IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+*   implied. See the License for the specific language governing
+*   rights and limitations under the License.
+*
+*   Alternatively, the contents of this file may be used under the
+*   terms of the GNU Public License version 2 (the "GPL"), in which
+*   case the provisions of the GPL are applicable instead of the
+*   above.  If you wish to allow the use of your version of this file
+*   only under the terms of the GPL and not to allow others to use
+*   your version of this file under the MPL, indicate your decision
+*   by deleting the provisions above and replace them with the notice
+*   and other provisions required by the GPL.  If you do not delete
+*   the provisions above, a recipient may use your version of this
+*   file under either the MPL or the GPL.
+*
+* --------------------------------------------------------------------
+*
+* Inquiries regarding the linux-wlan Open Source project can be
+* made directly to:
+*
+* AbsoluteValue Systems Inc.
+* info@linux-wlan.com
+* http://www.linux-wlan.com
+*
+* --------------------------------------------------------------------
+*
+* Portions of the development of this software were funded by
+* Intersil Corporation as part of PRISM(R) chipset product development.
+*
+* --------------------------------------------------------------------
+*
+* The functions in this file handle management requests sent from
+* user mode.
+*
+* Most of these functions have two separate blocks of code that are
+* conditional on whether this is a station or an AP.  This is used
+* to separate out the STA and AP responses to these management primitives.
+* It's a choice (good, bad, indifferent?) to have the code in the same
+* place so it's clear that the same primitive is implemented in both
+* cases but has different behavior.
+*
+* --------------------------------------------------------------------
+*/
+
+/*================================================================*/
+/* System Includes */
+#define WLAN_DBVAR	prism2_debug
+
+#include "version.h"
+
+
+#include <linux/version.h>
+
+#include <linux/if_arp.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/wait.h>
+#include <linux/sched.h>
+#include <linux/types.h>
+#include <linux/slab.h>
+#include <linux/wireless.h>
+#include <linux/netdevice.h>
+#include <linux/delay.h>
+#include <asm/io.h>
+#include <asm/byteorder.h>
+#include <linux/random.h>
+
+#if (WLAN_HOSTIF == WLAN_USB)
+#include <linux/usb.h>
+#endif
+
+#if (WLAN_HOSTIF == WLAN_PCMCIA)
+#include <pcmcia/version.h>
+#include <pcmcia/cs_types.h>
+#include <pcmcia/cs.h>
+#include <pcmcia/cistpl.h>
+#include <pcmcia/ds.h>
+#include <pcmcia/cisreg.h>
+#endif
+
+#include "wlan_compat.h"
+
+/*================================================================*/
+/* Project Includes */
+
+#include "p80211types.h"
+#include "p80211hdr.h"
+#include "p80211mgmt.h"
+#include "p80211conv.h"
+#include "p80211msg.h"
+#include "p80211netdev.h"
+#include "p80211metadef.h"
+#include "p80211metastruct.h"
+#include "hfa384x.h"
+#include "prism2mgmt.h"
+
+/*================================================================*/
+/* Local Constants */
+
+
+/*================================================================*/
+/* Local Macros */
+
+/* Converts 802.11 format rate specifications to prism2 */
+#define p80211rate_to_p2bit(n)	((((n)&~BIT7) == 2) ? BIT0 : \
+				 (((n)&~BIT7) == 4) ? BIT1 : \
+				 (((n)&~BIT7) == 11) ? BIT2 : \
+				 (((n)&~BIT7) == 22) ? BIT3 : 0)
+
+/*================================================================*/
+/* Local Types */
+
+
+/*================================================================*/
+/* Local Static Definitions */
+
+
+/*================================================================*/
+/* Local Function Declarations */
+
+
+/*================================================================*/
+/* Function Definitions */
+
+
+/*----------------------------------------------------------------
+* prism2mgmt_powermgmt
+*
+* Set the power management state of this station's MAC.
+*
+* Arguments:
+*	wlandev		wlan device structure
+*	msgp		ptr to msg buffer
+*
+* Returns:
+*	0	success and done
+*	<0	success, but we're waiting for something to finish.
+*	>0	an error occurred while handling the message.
+* Side effects:
+*
+* Call context:
+*	process thread  (usually)
+*	interrupt
+----------------------------------------------------------------*/
+int prism2mgmt_powermgmt(wlandevice_t *wlandev, void *msgp)
+{
+	int 			result = 0;
+	hfa384x_t		*hw = wlandev->priv;
+	p80211msg_dot11req_powermgmt_t	*msg = msgp;
+
+	DBFENTER;
+
+	if (!hw->ap) {
+
+		/*** STATION ***/
+
+		/*
+		 * Set CNFPMENABLED (on or off)
+		 * Set CNFMULTICASTRX (if PM on, otherwise clear)
+		 * Spout a notice stating that SleepDuration and
+		 * HoldoverDuration and PMEPS also have an impact.
+		 */
+		/* Powermgmt is currently unsupported for STA */
+		msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;
+		msg->resultcode.data = P80211ENUM_resultcode_not_supported;
+	} else {
+
+		/*** ACCESS POINT ***/
+
+		/* Powermgmt is never supported for AP */
+		msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;
+		msg->resultcode.data = P80211ENUM_resultcode_not_supported;
+	}
+
+	DBFEXIT;
+	return result;
+}
+
+
+/*----------------------------------------------------------------
+* prism2mgmt_scan
+*
+* Initiate a scan for BSSs.
+*
+* This function corresponds to MLME-scan.request and part of
+* MLME-scan.confirm.  As far as I can tell in the standard, there
+* are no restrictions on when a scan.request may be issued.  We have
+* to handle in whatever state the driver/MAC happen to be.
+*
+* Arguments:
+*	wlandev		wlan device structure
+*	msgp		ptr to msg buffer
+*
+* Returns:
+*	0	success and done
+*	<0	success, but we're waiting for something to finish.
+*	>0	an error occurred while handling the message.
+* Side effects:
+*
+* Call context:
+*	process thread  (usually)
+*	interrupt
+----------------------------------------------------------------*/
+int prism2mgmt_scan(wlandevice_t *wlandev, void *msgp)
+{
+	int 			result = 0;
+	hfa384x_t		*hw = wlandev->priv;
+	p80211msg_dot11req_scan_t	*msg = msgp;
+        UINT16                  roamingmode, word;
+	int                     i, timeout;
+	int                     istmpenable = 0;
+
+        hfa384x_HostScanRequest_data_t  scanreq;
+
+	DBFENTER;
+
+        if (hw->ap) {
+                WLAN_LOG_ERROR("Prism2 in AP mode cannot perform scans.\n");
+                result = 1;
+                msg->resultcode.data = P80211ENUM_resultcode_not_supported;
+                goto exit;
+        }
+
+        /* gatekeeper check */
+        if (HFA384x_FIRMWARE_VERSION(hw->ident_sta_fw.major,
+                                     hw->ident_sta_fw.minor,
+                                     hw->ident_sta_fw.variant) <
+            HFA384x_FIRMWARE_VERSION(1,3,2)) {
+		WLAN_LOG_ERROR("HostScan not supported with current firmware (<1.3.2).\n");
+                result = 1;
+                msg->resultcode.data = P80211ENUM_resultcode_not_supported;
+		goto exit;
+	}
+
+        memset(&scanreq, 0, sizeof(scanreq));
+
+        /* save current roaming mode */
+        result = hfa384x_drvr_getconfig16(hw,
+                        HFA384x_RID_CNFROAMINGMODE, &roamingmode);
+        if ( result ) {
+                WLAN_LOG_ERROR("getconfig(ROAMMODE) failed. result=%d\n",
+                                result);
+                msg->resultcode.data =
+                        P80211ENUM_resultcode_implementation_failure;
+                goto exit;
+        }
+
+        /* drop into mode 3 for the scan */
+        result = hfa384x_drvr_setconfig16(hw,
+                        HFA384x_RID_CNFROAMINGMODE,
+			HFA384x_ROAMMODE_HOSTSCAN_HOSTROAM);
+        if ( result ) {
+                WLAN_LOG_ERROR("setconfig(ROAMINGMODE) failed. result=%d\n",
+                                result);
+                msg->resultcode.data =
+                        P80211ENUM_resultcode_implementation_failure;
+                goto exit;
+        }
+
+        /* active or passive? */
+        if (HFA384x_FIRMWARE_VERSION(hw->ident_sta_fw.major,
+                                     hw->ident_sta_fw.minor,
+                                     hw->ident_sta_fw.variant) >
+            HFA384x_FIRMWARE_VERSION(1,5,0)) {
+                if (msg->scantype.data != P80211ENUM_scantype_active) {
+                        word = host2hfa384x_16(msg->maxchanneltime.data);
+                } else {
+                        word = 0;
+                }
+                result = hfa384x_drvr_setconfig16(hw, HFA384x_RID_CNFPASSIVESCANCTRL, word);
+                if ( result ) {
+                        WLAN_LOG_WARNING("Passive scan not supported with "
+					  "current firmware.  (<1.5.1)\n");
+                }
+        }
+
+	/* set up the txrate to be 2MBPS. Should be fastest basicrate... */
+	word = HFA384x_RATEBIT_2;
+	scanreq.txRate = host2hfa384x_16(word);
+
+        /* set up the channel list */
+        word = 0;
+        for (i = 0; i < msg->channellist.data.len; i++) {
+                UINT8 channel = msg->channellist.data.data[i];
+                if (channel > 14) continue;
+                /* channel 1 is BIT0 ... channel 14 is BIT13 */
+                word |= (1 << (channel-1));
+        }
+        scanreq.channelList = host2hfa384x_16(word);
+
+        /* set up the ssid, if present. */
+        scanreq.ssid.len = host2hfa384x_16(msg->ssid.data.len);
+        memcpy(scanreq.ssid.data, msg->ssid.data.data, msg->ssid.data.len);
+
+	/* Enable the MAC port if it's not already enabled  */
+	result = hfa384x_drvr_getconfig16(hw, HFA384x_RID_PORTSTATUS, &word);
+	if ( result ) {
+		WLAN_LOG_ERROR("getconfig(PORTSTATUS) failed. "
+				"result=%d\n", result);
+		msg->resultcode.data =
+			P80211ENUM_resultcode_implementation_failure;
+		goto exit;
+	}
+	if (word == HFA384x_PORTSTATUS_DISABLED) {
+		UINT16 wordbuf[17];
+
+		result = hfa384x_drvr_setconfig16(hw,
+			HFA384x_RID_CNFROAMINGMODE,
+			HFA384x_ROAMMODE_HOSTSCAN_HOSTROAM);
+		if ( result ) {
+			WLAN_LOG_ERROR("setconfig(ROAMINGMODE) failed. result=%d\n", result);
+			msg->resultcode.data =
+				P80211ENUM_resultcode_implementation_failure;
+			goto exit;
+		}
+		/* Construct a bogus SSID and assign it to OwnSSID and
+		 * DesiredSSID
+		 */
+		wordbuf[0] = host2hfa384x_16(WLAN_SSID_MAXLEN);
+		get_random_bytes(&wordbuf[1], WLAN_SSID_MAXLEN);
+		result = hfa384x_drvr_setconfig( hw, HFA384x_RID_CNFOWNSSID,
+				wordbuf, HFA384x_RID_CNFOWNSSID_LEN);
+		if ( result ) {
+			WLAN_LOG_ERROR("Failed to set OwnSSID.\n");
+			msg->resultcode.data =
+				P80211ENUM_resultcode_implementation_failure;
+			goto exit;
+		}
+		result = hfa384x_drvr_setconfig( hw, HFA384x_RID_CNFDESIREDSSID,
+				wordbuf, HFA384x_RID_CNFDESIREDSSID_LEN);
+		if ( result ) {
+			WLAN_LOG_ERROR("Failed to set DesiredSSID.\n");
+			msg->resultcode.data =
+				P80211ENUM_resultcode_implementation_failure;
+			goto exit;
+		}
+		/* bsstype */
+		result = hfa384x_drvr_setconfig16(hw,
+				HFA384x_RID_CNFPORTTYPE,
+				HFA384x_PORTTYPE_IBSS);
+		if ( result ) {
+			WLAN_LOG_ERROR("Failed to set CNFPORTTYPE.\n");
+			msg->resultcode.data =
+				P80211ENUM_resultcode_implementation_failure;
+			goto exit;
+		}
+		/* ibss options */
+		result = hfa384x_drvr_setconfig16(hw,
+				HFA384x_RID_CREATEIBSS,
+				HFA384x_CREATEIBSS_JOINCREATEIBSS);
+		if ( result ) {
+			WLAN_LOG_ERROR("Failed to set CREATEIBSS.\n");
+			msg->resultcode.data =
+				P80211ENUM_resultcode_implementation_failure;
+			goto exit;
+		}
+		result = hfa384x_drvr_enable(hw, 0);
+		if ( result ) {
+			WLAN_LOG_ERROR("drvr_enable(0) failed. "
+					"result=%d\n", result);
+			msg->resultcode.data =
+			P80211ENUM_resultcode_implementation_failure;
+			goto exit;
+		}
+		istmpenable = 1;
+	}
+
+        /* Figure out our timeout first Kus, then HZ */
+        timeout = msg->channellist.data.len * msg->maxchanneltime.data;
+	timeout = (timeout * HZ)/1000;
+
+        /* Issue the scan request */
+        hw->scanflag = 0;
+
+	WLAN_HEX_DUMP(5,"hscanreq", &scanreq, sizeof(scanreq));
+
+        result = hfa384x_drvr_setconfig( hw,
+                        HFA384x_RID_HOSTSCAN, &scanreq,
+                        sizeof(hfa384x_HostScanRequest_data_t));
+        if ( result ) {
+                WLAN_LOG_ERROR("setconfig(SCANREQUEST) failed. result=%d\n",
+                                result);
+                msg->resultcode.data =
+                        P80211ENUM_resultcode_implementation_failure;
+                goto exit;
+        }
+
+        /* sleep until info frame arrives */
+        wait_event_interruptible_timeout(hw->cmdq, hw->scanflag, timeout);
+
+	msg->numbss.status = P80211ENUM_msgitem_status_data_ok;
+	if (hw->scanflag == -1)
+		hw->scanflag = 0;
+
+	msg->numbss.data = hw->scanflag;
+
+        hw->scanflag = 0;
+
+	/* Disable port if we temporarily enabled it. */
+	if (istmpenable) {
+		result = hfa384x_drvr_disable(hw, 0);
+		if ( result ) {
+			WLAN_LOG_ERROR("drvr_disable(0) failed. "
+					"result=%d\n", result);
+			msg->resultcode.data =
+			P80211ENUM_resultcode_implementation_failure;
+			goto exit;
+		}
+	}
+
+	/* restore original roaming mode */
+	result = hfa384x_drvr_setconfig16(hw, HFA384x_RID_CNFROAMINGMODE,
+					  roamingmode);
+        if ( result ) {
+                WLAN_LOG_ERROR("setconfig(ROAMMODE) failed. result=%d\n",
+                                result);
+                msg->resultcode.data =
+                        P80211ENUM_resultcode_implementation_failure;
+                goto exit;
+        }
+
+        result = 0;
+        msg->resultcode.data = P80211ENUM_resultcode_success;
+
+ exit:
+	msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;
+
+	DBFEXIT;
+	return result;
+}
+
+
+/*----------------------------------------------------------------
+* prism2mgmt_scan_results
+*
+* Retrieve the BSS description for one of the BSSs identified in
+* a scan.
+*
+* Arguments:
+*	wlandev		wlan device structure
+*	msgp		ptr to msg buffer
+*
+* Returns:
+*	0	success and done
+*	<0	success, but we're waiting for something to finish.
+*	>0	an error occurred while handling the message.
+* Side effects:
+*
+* Call context:
+*	process thread  (usually)
+*	interrupt
+----------------------------------------------------------------*/
+int prism2mgmt_scan_results(wlandevice_t *wlandev, void *msgp)
+{
+	int 			result = 0;
+        p80211msg_dot11req_scan_results_t       *req;
+	hfa384x_t		*hw = wlandev->priv;
+	hfa384x_HScanResultSub_t *item = NULL;
+
+	int count;
+
+	DBFENTER;
+
+        req = (p80211msg_dot11req_scan_results_t *) msgp;
+
+	req->resultcode.status = P80211ENUM_msgitem_status_data_ok;
+
+	if (hw->ap) {
+		result = 1;
+		req->resultcode.data = P80211ENUM_resultcode_not_supported;
+		goto exit;
+	}
+
+	if (! hw->scanresults) {
+		WLAN_LOG_ERROR("dot11req_scan_results can only be used after a successful dot11req_scan.\n");
+		result = 2;
+		req->resultcode.data = P80211ENUM_resultcode_invalid_parameters;
+		goto exit;
+	}
+
+        count = (hw->scanresults->framelen - 3) / 32;
+	if (count > 32)  count = 32;
+
+	if (req->bssindex.data >= count) {
+		WLAN_LOG_DEBUG(0, "requested index (%d) out of range (%d)\n",
+				req->bssindex.data, count);
+		result = 2;
+		req->resultcode.data = P80211ENUM_resultcode_invalid_parameters;
+		goto exit;
+	}
+
+	item = &(hw->scanresults->info.hscanresult.result[req->bssindex.data]);
+	/* signal and noise */
+	req->signal.status = P80211ENUM_msgitem_status_data_ok;
+	req->noise.status = P80211ENUM_msgitem_status_data_ok;
+	req->signal.data = hfa384x2host_16(item->sl);
+	req->noise.data = hfa384x2host_16(item->anl);
+
+	/* BSSID */
+	req->bssid.status = P80211ENUM_msgitem_status_data_ok;
+	req->bssid.data.len = WLAN_BSSID_LEN;
+	memcpy(req->bssid.data.data, item->bssid, WLAN_BSSID_LEN);
+
+	/* SSID */
+	req->ssid.status = P80211ENUM_msgitem_status_data_ok;
+	req->ssid.data.len = hfa384x2host_16(item->ssid.len);
+	memcpy(req->ssid.data.data, item->ssid.data, req->ssid.data.len);
+
+	/* supported rates */
+        for (count = 0; count < 10 ; count++)
+                if (item->supprates[count] == 0)
+                        break;
+
+#define REQBASICRATE(N) \
+	if ((count >= N) && DOT11_RATE5_ISBASIC_GET(item->supprates[(N)-1])) { \
+		req->basicrate ## N .data = item->supprates[(N)-1]; \
+		req->basicrate ## N .status = P80211ENUM_msgitem_status_data_ok; \
+	}
+
+	REQBASICRATE(1);
+	REQBASICRATE(2);
+	REQBASICRATE(3);
+	REQBASICRATE(4);
+	REQBASICRATE(5);
+	REQBASICRATE(6);
+	REQBASICRATE(7);
+	REQBASICRATE(8);
+
+#define REQSUPPRATE(N) \
+	if (count >= N) { \
+		req->supprate ## N .data = item->supprates[(N)-1]; \
+		req->supprate ## N .status = P80211ENUM_msgitem_status_data_ok; \
+	}
+
+	REQSUPPRATE(1);
+	REQSUPPRATE(2);
+	REQSUPPRATE(3);
+	REQSUPPRATE(4);
+	REQSUPPRATE(5);
+	REQSUPPRATE(6);
+	REQSUPPRATE(7);
+	REQSUPPRATE(8);
+
+	/* beacon period */
+	req->beaconperiod.status = P80211ENUM_msgitem_status_data_ok;
+	req->beaconperiod.data = hfa384x2host_16(item->bcnint);
+
+	/* timestamps */
+	req->timestamp.status = P80211ENUM_msgitem_status_data_ok;
+	req->timestamp.data = jiffies;
+	req->localtime.status = P80211ENUM_msgitem_status_data_ok;
+	req->localtime.data = jiffies;
+
+	/* atim window */
+	req->ibssatimwindow.status = P80211ENUM_msgitem_status_data_ok;
+	req->ibssatimwindow.data = hfa384x2host_16(item->atim);
+
+	/* Channel */
+	req->dschannel.status = P80211ENUM_msgitem_status_data_ok;
+	req->dschannel.data = hfa384x2host_16(item->chid);
+
+	/* capinfo bits */
+	count = hfa384x2host_16(item->capinfo);
+
+	/* privacy flag */
+	req->privacy.status = P80211ENUM_msgitem_status_data_ok;
+	req->privacy.data = WLAN_GET_MGMT_CAP_INFO_PRIVACY(count);
+
+	/* cfpollable */
+	req->cfpollable.status = P80211ENUM_msgitem_status_data_ok;
+	req->cfpollable.data = WLAN_GET_MGMT_CAP_INFO_CFPOLLABLE(count);
+
+	/* cfpollreq */
+	req->cfpollreq.status = P80211ENUM_msgitem_status_data_ok;
+	req->cfpollreq.data = WLAN_GET_MGMT_CAP_INFO_CFPOLLREQ(count);
+
+	/* bsstype */
+	req->bsstype.status =  P80211ENUM_msgitem_status_data_ok;
+	req->bsstype.data = (WLAN_GET_MGMT_CAP_INFO_ESS(count)) ?
+		P80211ENUM_bsstype_infrastructure :
+		P80211ENUM_bsstype_independent;
+
+	// item->proberesp_rate
+/*
+	req->fhdwelltime
+	req->fhhopset
+	req->fhhoppattern
+	req->fhhopindex
+        req->cfpdurremaining
+*/
+
+	result = 0;
+	req->resultcode.data = P80211ENUM_resultcode_success;
+
+ exit:
+	DBFEXIT;
+	return result;
+}
+
+
+/*----------------------------------------------------------------
+* prism2mgmt_join
+*
+* Join a BSS whose BSS description was previously obtained with
+* a scan.
+*
+* Arguments:
+*	wlandev		wlan device structure
+*	msgp		ptr to msg buffer
+*
+* Returns:
+*	0	success and done
+*	<0	success, but we're waiting for something to finish.
+*	>0	an error occurred while handling the message.
+* Side effects:
+*
+* Call context:
+*	process thread  (usually)
+*	interrupt
+----------------------------------------------------------------*/
+int prism2mgmt_join(wlandevice_t *wlandev, void *msgp)
+{
+	int 			result = 0;
+	hfa384x_t		*hw = wlandev->priv;
+	p80211msg_dot11req_join_t	*msg = msgp;
+	DBFENTER;
+
+	if (!hw->ap) {
+
+		/*** STATION ***/
+
+		/* TODO: Implement after scan */
+		msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;
+		msg->resultcode.data = P80211ENUM_resultcode_not_supported;
+	} else {
+
+		/*** ACCESS POINT ***/
+
+		/* Never supported by APs */
+		msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;
+		msg->resultcode.data = P80211ENUM_resultcode_not_supported;
+	}
+
+	DBFEXIT;
+	return result;
+}
+
+
+/*----------------------------------------------------------------
+* prism2mgmt_p2_join
+*
+* Join a specific BSS
+*
+* Arguments:
+*	wlandev		wlan device structure
+*	msgp		ptr to msg buffer
+*
+* Returns:
+*	0	success and done
+*	<0	success, but we're waiting for something to finish.
+*	>0	an error occurred while handling the message.
+* Side effects:
+*
+* Call context:
+*	process thread  (usually)
+*	interrupt
+----------------------------------------------------------------*/
+int prism2mgmt_p2_join(wlandevice_t *wlandev, void *msgp)
+{
+	int 			result = 0;
+	hfa384x_t		*hw = wlandev->priv;
+	p80211msg_p2req_join_t	*msg = msgp;
+	UINT16			reg;
+	p80211pstrd_t		*pstr;
+	UINT8			bytebuf[256];
+	hfa384x_bytestr_t	*p2bytestr = (hfa384x_bytestr_t*)bytebuf;
+        hfa384x_JoinRequest_data_t	joinreq;
+	DBFENTER;
+
+	if (!hw->ap) {
+
+		wlandev->macmode = WLAN_MACMODE_NONE;
+
+		/*** STATION ***/
+		/* Set the PortType */
+		msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;
+		msg->resultcode.data = P80211ENUM_resultcode_success;
+
+		/* ess port */
+		result = hfa384x_drvr_setconfig16(hw, HFA384x_RID_CNFPORTTYPE, 1);
+		if ( result ) {
+			WLAN_LOG_ERROR("Failed to set Port Type\n");
+			goto failed;
+		}
+
+		/* Set the auth type */
+		if ( msg->authtype.data == P80211ENUM_authalg_sharedkey ) {
+			reg = HFA384x_CNFAUTHENTICATION_SHAREDKEY;
+		} else {
+			reg = HFA384x_CNFAUTHENTICATION_OPENSYSTEM;
+		}
+		result = hfa384x_drvr_setconfig16(hw, HFA384x_RID_CNFAUTHENTICATION, reg);
+		if ( result ) {
+			WLAN_LOG_ERROR("Failed to set Authentication\n");
+			goto failed;
+		}
+
+		/* Turn off all roaming */
+		hfa384x_drvr_setconfig16(hw, HFA384x_RID_CNFROAMINGMODE, 3);
+		if ( result ) {
+			WLAN_LOG_ERROR("Failed to Turn off Roaming\n");
+			goto failed;
+		}
+
+		/* Basic rates */
+                reg = 0;
+		if ( msg->basicrate1.status == P80211ENUM_msgitem_status_data_ok ) {
+			reg = p80211rate_to_p2bit(msg->basicrate1.data);
+		}
+		if ( msg->basicrate2.status == P80211ENUM_msgitem_status_data_ok ) {
+			reg |= p80211rate_to_p2bit(msg->basicrate2.data);
+		}
+		if ( msg->basicrate3.status == P80211ENUM_msgitem_status_data_ok ) {
+			reg |= p80211rate_to_p2bit(msg->basicrate3.data);
+		}
+		if ( msg->basicrate4.status == P80211ENUM_msgitem_status_data_ok ) {
+			reg |= p80211rate_to_p2bit(msg->basicrate4.data);
+		}
+		if ( msg->basicrate5.status == P80211ENUM_msgitem_status_data_ok ) {
+			reg |= p80211rate_to_p2bit(msg->basicrate5.data);
+		}
+		if ( msg->basicrate6.status == P80211ENUM_msgitem_status_data_ok ) {
+			reg |= p80211rate_to_p2bit(msg->basicrate6.data);
+		}
+		if ( msg->basicrate7.status == P80211ENUM_msgitem_status_data_ok ) {
+			reg |= p80211rate_to_p2bit(msg->basicrate7.data);
+		}
+		if ( msg->basicrate8.status == P80211ENUM_msgitem_status_data_ok ) {
+			reg |= p80211rate_to_p2bit(msg->basicrate8.data);
+		}
+		if( reg == 0)
+			 reg = 0x03;
+		result = hfa384x_drvr_setconfig16(hw, HFA384x_RID_CNFBASICRATES, reg);
+		if ( result ) {
+			WLAN_LOG_ERROR("Failed to set basicrates=%d.\n", reg);
+			goto failed;
+		}
+
+		/* Operational rates (supprates and txratecontrol) */
+		reg = 0;
+		if ( msg->operationalrate1.status == P80211ENUM_msgitem_status_data_ok ) {
+			reg = p80211rate_to_p2bit(msg->operationalrate1.data);
+		}
+		if ( msg->operationalrate2.status == P80211ENUM_msgitem_status_data_ok ) {
+			reg |= p80211rate_to_p2bit(msg->operationalrate2.data);
+		}
+		if ( msg->operationalrate3.status == P80211ENUM_msgitem_status_data_ok ) {
+			reg |= p80211rate_to_p2bit(msg->operationalrate3.data);
+		}
+		if ( msg->operationalrate4.status == P80211ENUM_msgitem_status_data_ok ) {
+			reg |= p80211rate_to_p2bit(msg->operationalrate4.data);
+		}
+		if ( msg->operationalrate5.status == P80211ENUM_msgitem_status_data_ok ) {
+			reg |= p80211rate_to_p2bit(msg->operationalrate5.data);
+		}
+		if ( msg->operationalrate6.status == P80211ENUM_msgitem_status_data_ok ) {
+			reg |= p80211rate_to_p2bit(msg->operationalrate6.data);
+		}
+		if ( msg->operationalrate7.status == P80211ENUM_msgitem_status_data_ok ) {
+			reg |= p80211rate_to_p2bit(msg->operationalrate7.data);
+		}
+		if ( msg->operationalrate8.status == P80211ENUM_msgitem_status_data_ok ) {
+			reg |= p80211rate_to_p2bit(msg->operationalrate8.data);
+		}
+		if( reg == 0)
+			 reg = 0x0f;
+		result = hfa384x_drvr_setconfig16(hw, HFA384x_RID_CNFSUPPRATES, reg);
+		if ( result ) {
+			WLAN_LOG_ERROR("Failed to set supprates=%d.\n", reg);
+			goto failed;
+		}
+
+ 		result = hfa384x_drvr_setconfig16(hw, HFA384x_RID_TXRATECNTL, reg);
+		if ( result ) {
+			WLAN_LOG_ERROR("Failed to set txrates=%d.\n", reg);
+			goto failed;
+		}
+
+		/* Set the ssid */
+		memset(bytebuf, 0, 256);
+		pstr = (p80211pstrd_t*)&(msg->ssid.data);
+		prism2mgmt_pstr2bytestr(p2bytestr, pstr);
+		result = hfa384x_drvr_setconfig(
+			hw, HFA384x_RID_CNFDESIREDSSID,
+			bytebuf, HFA384x_RID_CNFDESIREDSSID_LEN);
+		if ( result ) {
+			WLAN_LOG_ERROR("Failed to set SSID\n");
+			goto failed;
+		}
+
+		/* Enable the Port */
+		result = hfa384x_cmd_enable(hw, 0);
+		if ( result ) {
+			WLAN_LOG_ERROR("Enable macport failed, result=%d.\n", result);
+			goto failed;
+		}
+
+		/* Fill in the join request */
+		joinreq.channel = msg->channel.data;
+		memcpy( joinreq.bssid, ((unsigned char *) &msg->bssid.data) + 1, WLAN_BSSID_LEN);
+		hw->joinreq = joinreq;
+		hw->join_ap = 1;
+
+		/* Send the join request */
+		result = hfa384x_drvr_setconfig( hw,
+			HFA384x_RID_JOINREQUEST,
+			&joinreq, HFA384x_RID_JOINREQUEST_LEN);
+                if(result != 0) {
+			WLAN_LOG_ERROR("Join request failed, result=%d.\n", result);
+			goto failed;
+		}
+
+	} else {
+
+		/*** ACCESS POINT ***/
+
+		/* Never supported by APs */
+		msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;
+		msg->resultcode.data = P80211ENUM_resultcode_not_supported;
+	}
+
+        goto done;
+failed:
+	WLAN_LOG_DEBUG(1, "Failed to set a config option, result=%d\n", result);
+	msg->resultcode.data = P80211ENUM_resultcode_invalid_parameters;
+
+done:
+        result = 0;
+
+	DBFEXIT;
+	return result;
+}
+
+
+/*----------------------------------------------------------------
+* prism2mgmt_authenticate
+*
+* Station should be begin an authentication exchange.
+*
+* Arguments:
+*	wlandev		wlan device structure
+*	msgp		ptr to msg buffer
+*
+* Returns:
+*	0	success and done
+*	<0	success, but we're waiting for something to finish.
+*	>0	an error occurred while handling the message.
+* Side effects:
+*
+* Call context:
+*	process thread  (usually)
+*	interrupt
+----------------------------------------------------------------*/
+int prism2mgmt_authenticate(wlandevice_t *wlandev, void *msgp)
+{
+	int 			result = 0;
+	hfa384x_t		*hw = wlandev->priv;
+	p80211msg_dot11req_authenticate_t	*msg = msgp;
+	DBFENTER;
+
+	if (!hw->ap) {
+
+		/*** STATION ***/
+
+		/* TODO: Decide how we're going to handle this one w/ Prism2 */
+		/*       It could be entertaining since Prism2 doesn't have  */
+		/*       an explicit way to control this */
+		msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;
+		msg->resultcode.data = P80211ENUM_resultcode_not_supported;
+	} else {
+
+		/*** ACCESS POINT ***/
+
+		/* Never supported by APs */
+		msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;
+		msg->resultcode.data = P80211ENUM_resultcode_not_supported;
+	}
+
+	DBFEXIT;
+	return result;
+}
+
+
+/*----------------------------------------------------------------
+* prism2mgmt_deauthenticate
+*
+* Send a deauthenticate notification.
+*
+* Arguments:
+*	wlandev		wlan device structure
+*	msgp		ptr to msg buffer
+*
+* Returns:
+*	0	success and done
+*	<0	success, but we're waiting for something to finish.
+*	>0	an error occurred while handling the message.
+* Side effects:
+*
+* Call context:
+*	process thread  (usually)
+*	interrupt
+----------------------------------------------------------------*/
+int prism2mgmt_deauthenticate(wlandevice_t *wlandev, void *msgp)
+{
+	int 			result = 0;
+	hfa384x_t		*hw = wlandev->priv;
+	p80211msg_dot11req_deauthenticate_t	*msg = msgp;
+	DBFENTER;
+
+	if (!hw->ap) {
+
+		/*** STATION ***/
+
+		/* TODO: Decide how we're going to handle this one w/ Prism2 */
+		/*       It could be entertaining since Prism2 doesn't have  */
+		/*       an explicit way to control this */
+		msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;
+		msg->resultcode.data = P80211ENUM_resultcode_not_supported;
+	} else {
+
+		/*** ACCESS POINT ***/
+		hfa384x_drvr_handover(hw, msg->peerstaaddress.data.data);
+		msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;
+		msg->resultcode.data = P80211ENUM_resultcode_success;
+	}
+
+	DBFEXIT;
+	return result;
+}
+
+
+/*----------------------------------------------------------------
+* prism2mgmt_associate
+*
+* Associate with an ESS.
+*
+* Arguments:
+*	wlandev		wlan device structure
+*	msgp		ptr to msg buffer
+*
+* Returns:
+*	0	success and done
+*	<0	success, but we're waiting for something to finish.
+*	>0	an error occurred while handling the message.
+* Side effects:
+*
+* Call context:
+*	process thread  (usually)
+*	interrupt
+----------------------------------------------------------------*/
+int prism2mgmt_associate(wlandevice_t *wlandev, void *msgp)
+{
+	hfa384x_t		*hw = wlandev->priv;
+	int 			result = 0;
+	p80211msg_dot11req_associate_t	*msg = msgp;
+	DBFENTER;
+
+	if (!hw->ap) {
+
+		/*** STATION ***/
+
+#if 0
+		/* Set the TxRates */
+		reg = 0x000f;
+		hfa384x_drvr_setconfig16(hw, HFA384x_RID_TXRATECNTL, reg);
+#endif
+
+		/* Set the PortType */
+		/* ess port */
+		hfa384x_drvr_setconfig16(hw, HFA384x_RID_CNFPORTTYPE, 1);
+
+		/* Enable the Port */
+		hfa384x_drvr_enable(hw, 0);
+
+		/* Set the resultcode */
+		msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;
+		msg->resultcode.data = P80211ENUM_resultcode_success;
+
+	} else {
+
+		/*** ACCESS POINT ***/
+
+		/* Never supported on AP */
+		msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;
+		msg->resultcode.data = P80211ENUM_resultcode_not_supported;
+	}
+
+	DBFEXIT;
+	return result;
+}
+
+
+/*----------------------------------------------------------------
+* prism2mgmt_reassociate
+*
+* Renew association because of a BSS change.
+*
+* Arguments:
+*	wlandev		wlan device structure
+*	msgp		ptr to msg buffer
+*
+* Returns:
+*	0	success and done
+*	<0	success, but we're waiting for something to finish.
+*	>0	an error occurred while handling the message.
+* Side effects:
+*
+* Call context:
+*	process thread  (usually)
+*	interrupt
+----------------------------------------------------------------*/
+int prism2mgmt_reassociate(wlandevice_t *wlandev, void *msgp)
+{
+	int 			result = 0;
+	hfa384x_t		*hw = wlandev->priv;
+	p80211msg_dot11req_reassociate_t	*msg = msgp;
+	DBFENTER;
+
+	if (!hw->ap) {
+
+		/*** STATION ***/
+
+		/* TODO: Not supported yet...not sure how we're going to do it */
+		msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;
+		msg->resultcode.data = P80211ENUM_resultcode_not_supported;
+	} else {
+
+		/*** ACCESS POINT ***/
+
+		/* Never supported on AP */
+		msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;
+		msg->resultcode.data = P80211ENUM_resultcode_not_supported;
+	}
+
+	DBFEXIT;
+	return result;
+}
+
+
+/*----------------------------------------------------------------
+* prism2mgmt_disassociate
+*
+* Send a disassociation notification.
+*
+* Arguments:
+*	wlandev		wlan device structure
+*	msgp		ptr to msg buffer
+*
+* Returns:
+*	0	success and done
+*	<0	success, but we're waiting for something to finish.
+*	>0	an error occurred while handling the message.
+* Side effects:
+*
+* Call context:
+*	process thread  (usually)
+*	interrupt
+----------------------------------------------------------------*/
+int prism2mgmt_disassociate(wlandevice_t *wlandev, void *msgp)
+{
+	int 			result = 0;
+	hfa384x_t		*hw = wlandev->priv;
+	p80211msg_dot11req_disassociate_t	*msg = msgp;
+	DBFENTER;
+
+	if (!hw->ap) {
+
+		/*** STATION ***/
+
+		/* TODO: Not supported yet...not sure how to do it */
+		msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;
+		msg->resultcode.data = P80211ENUM_resultcode_not_supported;
+	} else {
+
+		/*** ACCESS POINT ***/
+		hfa384x_drvr_handover(hw, msg->peerstaaddress.data.data);
+		msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;
+		msg->resultcode.data = P80211ENUM_resultcode_success;
+	}
+
+	DBFEXIT;
+	return result;
+}
+
+
+/*----------------------------------------------------------------
+* prism2mgmt_reset
+*
+* Reset the MAC and MSD.  The p80211 layer has it's own handling
+* that should be done before and after this function.
+* Procedure:
+*   - disable system interrupts ??
+*   - disable MAC interrupts
+*   - restore system interrupts
+*   - issue the MAC initialize command
+*   - clear any MSD level state (including timers, queued events,
+*     etc.).  Note that if we're removing timer'd/queue events, we may
+*     need to have remained in the system interrupt disabled state.
+*     We should be left in the same state that we're in following
+*     driver initialization.
+*
+* Arguments:
+*	wlandev		wlan device structure
+*	msgp		ptr to msg buffer, MAY BE NULL! for a driver local
+*			call.
+*
+* Returns:
+*	0	success and done
+*	<0	success, but we're waiting for something to finish.
+*	>0	an error occurred while handling the message.
+* Side effects:
+*
+* Call context:
+*	process thread, commonly wlanctl, but might be rmmod/pci_close.
+----------------------------------------------------------------*/
+int prism2mgmt_reset(wlandevice_t *wlandev, void *msgp)
+{
+	int 			result = 0;
+	hfa384x_t		*hw = wlandev->priv;
+	p80211msg_dot11req_reset_t	*msg = msgp;
+	DBFENTER;
+
+	/*
+	 * This is supported on both AP and STA and it's not allowed
+	 * to fail.
+	 */
+	if ( msgp ) {
+		msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;
+		msg->resultcode.data = P80211ENUM_resultcode_success;
+		WLAN_LOG_INFO("dot11req_reset: the macaddress and "
+			"setdefaultmib arguments are currently unsupported.\n");
+	}
+
+	/*
+	 * If we got this far, the MSD must be in the MSDRUNNING state
+	 * therefore, we must stop and then restart the hw/MAC combo.
+	 */
+	hfa384x_drvr_stop(hw);
+	result = hfa384x_drvr_start(hw);
+	if (result != 0) {
+		WLAN_LOG_ERROR("dot11req_reset: Initialize command failed,"
+				" bad things will happen from here.\n");
+		return 0;
+	}
+
+	DBFEXIT;
+	return 0;
+}
+
+
+/*----------------------------------------------------------------
+* prism2mgmt_start
+*
+* Start a BSS.  Any station can do this for IBSS, only AP for ESS.
+*
+* Arguments:
+*	wlandev		wlan device structure
+*	msgp		ptr to msg buffer
+*
+* Returns:
+*	0	success and done
+*	<0	success, but we're waiting for something to finish.
+*	>0	an error occurred while handling the message.
+* Side effects:
+*
+* Call context:
+*	process thread  (usually)
+*	interrupt
+----------------------------------------------------------------*/
+int prism2mgmt_start(wlandevice_t *wlandev, void *msgp)
+{
+	int 			result = 0;
+	hfa384x_t		*hw = wlandev->priv;
+	p80211msg_dot11req_start_t	*msg = msgp;
+
+	p80211pstrd_t		*pstr;
+	UINT8			bytebuf[80];
+	hfa384x_bytestr_t	*p2bytestr = (hfa384x_bytestr_t*)bytebuf;
+	hfa384x_PCFInfo_data_t	*pcfinfo = (hfa384x_PCFInfo_data_t*)bytebuf;
+	UINT16			word;
+	DBFENTER;
+
+	wlandev->macmode = WLAN_MACMODE_NONE;
+
+	/* Set the SSID */
+	memcpy(&wlandev->ssid, &msg->ssid.data, sizeof(msg->ssid.data));
+
+	if (!hw->ap) {
+		/*** ADHOC IBSS ***/
+		/* see if current f/w is less than 8c3 */
+		if (HFA384x_FIRMWARE_VERSION(hw->ident_sta_fw.major,
+					     hw->ident_sta_fw.minor,
+					     hw->ident_sta_fw.variant) <
+		    HFA384x_FIRMWARE_VERSION(0,8,3)) {
+			/* Ad-Hoc not quite supported on Prism2 */
+			msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;
+			msg->resultcode.data = P80211ENUM_resultcode_not_supported;
+			goto done;
+		}
+
+  		msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;
+
+		/*** STATION ***/
+		/* Set the REQUIRED config items */
+		/* SSID */
+		pstr = (p80211pstrd_t*)&(msg->ssid.data);
+		prism2mgmt_pstr2bytestr(p2bytestr, pstr);
+		result = hfa384x_drvr_setconfig( hw, HFA384x_RID_CNFOWNSSID,
+				bytebuf, HFA384x_RID_CNFOWNSSID_LEN);
+		if ( result ) {
+			WLAN_LOG_ERROR("Failed to set CnfOwnSSID\n");
+			goto failed;
+		}
+		result = hfa384x_drvr_setconfig( hw, HFA384x_RID_CNFDESIREDSSID,
+				bytebuf, HFA384x_RID_CNFDESIREDSSID_LEN);
+		if ( result ) {
+			WLAN_LOG_ERROR("Failed to set CnfDesiredSSID\n");
+			goto failed;
+		}
+
+		/* bsstype - we use the default in the ap firmware */
+		/* IBSS port */
+		hfa384x_drvr_setconfig16(hw, HFA384x_RID_CNFPORTTYPE, 0);
+
+		/* beacon period */
+		word = msg->beaconperiod.data;
+		result = hfa384x_drvr_setconfig16(hw, HFA384x_RID_CNFAPBCNINT, word);
+		if ( result ) {
+			WLAN_LOG_ERROR("Failed to set beacon period=%d.\n", word);
+			goto failed;
+		}
+
+		/* dschannel */
+		word = msg->dschannel.data;
+		result = hfa384x_drvr_setconfig16(hw, HFA384x_RID_CNFOWNCHANNEL, word);
+		if ( result ) {
+			WLAN_LOG_ERROR("Failed to set channel=%d.\n", word);
+			goto failed;
+		}
+		/* Basic rates */
+		word = p80211rate_to_p2bit(msg->basicrate1.data);
+		if ( msg->basicrate2.status == P80211ENUM_msgitem_status_data_ok ) {
+			word |= p80211rate_to_p2bit(msg->basicrate2.data);
+		}
+		if ( msg->basicrate3.status == P80211ENUM_msgitem_status_data_ok ) {
+			word |= p80211rate_to_p2bit(msg->basicrate3.data);
+		}
+		if ( msg->basicrate4.status == P80211ENUM_msgitem_status_data_ok ) {
+			word |= p80211rate_to_p2bit(msg->basicrate4.data);
+		}
+		if ( msg->basicrate5.status == P80211ENUM_msgitem_status_data_ok ) {
+			word |= p80211rate_to_p2bit(msg->basicrate5.data);
+		}
+		if ( msg->basicrate6.status == P80211ENUM_msgitem_status_data_ok ) {
+			word |= p80211rate_to_p2bit(msg->basicrate6.data);
+		}
+		if ( msg->basicrate7.status == P80211ENUM_msgitem_status_data_ok ) {
+			word |= p80211rate_to_p2bit(msg->basicrate7.data);
+		}
+		if ( msg->basicrate8.status == P80211ENUM_msgitem_status_data_ok ) {
+			word |= p80211rate_to_p2bit(msg->basicrate8.data);
+		}
+		result = hfa384x_drvr_setconfig16(hw, HFA384x_RID_CNFBASICRATES, word);
+		if ( result ) {
+			WLAN_LOG_ERROR("Failed to set basicrates=%d.\n", word);
+			goto failed;
+		}
+
+		/* Operational rates (supprates and txratecontrol) */
+		word = p80211rate_to_p2bit(msg->operationalrate1.data);
+		if ( msg->operationalrate2.status == P80211ENUM_msgitem_status_data_ok ) {
+			word |= p80211rate_to_p2bit(msg->operationalrate2.data);
+		}
+		if ( msg->operationalrate3.status == P80211ENUM_msgitem_status_data_ok ) {
+			word |= p80211rate_to_p2bit(msg->operationalrate3.data);
+		}
+		if ( msg->operationalrate4.status == P80211ENUM_msgitem_status_data_ok ) {
+			word |= p80211rate_to_p2bit(msg->operationalrate4.data);
+		}
+		if ( msg->operationalrate5.status == P80211ENUM_msgitem_status_data_ok ) {
+			word |= p80211rate_to_p2bit(msg->operationalrate5.data);
+		}
+		if ( msg->operationalrate6.status == P80211ENUM_msgitem_status_data_ok ) {
+			word |= p80211rate_to_p2bit(msg->operationalrate6.data);
+		}
+		if ( msg->operationalrate7.status == P80211ENUM_msgitem_status_data_ok ) {
+			word |= p80211rate_to_p2bit(msg->operationalrate7.data);
+		}
+		if ( msg->operationalrate8.status == P80211ENUM_msgitem_status_data_ok ) {
+			word |= p80211rate_to_p2bit(msg->operationalrate8.data);
+		}
+		result = hfa384x_drvr_setconfig16(hw, HFA384x_RID_CNFSUPPRATES, word);
+		if ( result ) {
+			WLAN_LOG_ERROR("Failed to set supprates=%d.\n", word);
+			goto failed;
+		}
+
+ 		result = hfa384x_drvr_setconfig16(hw, HFA384x_RID_TXRATECNTL, word);
+		if ( result ) {
+			WLAN_LOG_ERROR("Failed to set txrates=%d.\n", word);
+			goto failed;
+		}
+
+		/* Set the macmode so the frame setup code knows what to do */
+		if ( msg->bsstype.data == P80211ENUM_bsstype_independent ) {
+			wlandev->macmode = WLAN_MACMODE_IBSS_STA;
+			/* lets extend the data length a bit */
+			hfa384x_drvr_setconfig16(hw, HFA384x_RID_CNFMAXDATALEN, 2304);
+		}
+
+		/* Enable the Port */
+		result = hfa384x_drvr_enable(hw, 0);
+		if ( result ) {
+			WLAN_LOG_ERROR("Enable macport failed, result=%d.\n", result);
+			goto failed;
+		}
+
+		msg->resultcode.data = P80211ENUM_resultcode_success;
+
+		goto done;
+	}
+
+	/*** ACCESS POINT ***/
+
+	msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;
+
+	/* Validate the command, if BSStype=infra is the tertiary loaded? */
+	if ( msg->bsstype.data == P80211ENUM_bsstype_independent ) {
+		WLAN_LOG_ERROR("AP driver cannot create IBSS.\n");
+		goto failed;
+	} else if ( hw->cap_sup_sta.id != 5) {
+		WLAN_LOG_ERROR("AP driver failed to detect AP firmware.\n");
+		goto failed;
+	}
+
+	/* Set the REQUIRED config items */
+	/* SSID */
+	pstr = (p80211pstrd_t*)&(msg->ssid.data);
+	prism2mgmt_pstr2bytestr(p2bytestr, pstr);
+	result = hfa384x_drvr_setconfig( hw, HFA384x_RID_CNFOWNSSID,
+				bytebuf, HFA384x_RID_CNFOWNSSID_LEN);
+	if ( result ) {
+		WLAN_LOG_ERROR("Failed to set SSID, result=0x%04x\n", result);
+		goto failed;
+	}
+
+	/* bsstype - we use the default in the ap firmware */
+
+	/* beacon period */
+	word = msg->beaconperiod.data;
+	result = hfa384x_drvr_setconfig16(hw, HFA384x_RID_CNFAPBCNINT, word);
+	if ( result ) {
+		WLAN_LOG_ERROR("Failed to set beacon period=%d.\n", word);
+		goto failed;
+	}
+
+	/* dschannel */
+	word = msg->dschannel.data;
+	result = hfa384x_drvr_setconfig16(hw, HFA384x_RID_CNFOWNCHANNEL, word);
+	if ( result ) {
+		WLAN_LOG_ERROR("Failed to set channel=%d.\n", word);
+		goto failed;
+	}
+	/* Basic rates */
+	word = p80211rate_to_p2bit(msg->basicrate1.data);
+	if ( msg->basicrate2.status == P80211ENUM_msgitem_status_data_ok ) {
+		word |= p80211rate_to_p2bit(msg->basicrate2.data);
+	}
+	if ( msg->basicrate3.status == P80211ENUM_msgitem_status_data_ok ) {
+		word |= p80211rate_to_p2bit(msg->basicrate3.data);
+	}
+	if ( msg->basicrate4.status == P80211ENUM_msgitem_status_data_ok ) {
+		word |= p80211rate_to_p2bit(msg->basicrate4.data);
+	}
+	if ( msg->basicrate5.status == P80211ENUM_msgitem_status_data_ok ) {
+		word |= p80211rate_to_p2bit(msg->basicrate5.data);
+	}
+	if ( msg->basicrate6.status == P80211ENUM_msgitem_status_data_ok ) {
+		word |= p80211rate_to_p2bit(msg->basicrate6.data);
+	}
+	if ( msg->basicrate7.status == P80211ENUM_msgitem_status_data_ok ) {
+		word |= p80211rate_to_p2bit(msg->basicrate7.data);
+	}
+	if ( msg->basicrate8.status == P80211ENUM_msgitem_status_data_ok ) {
+		word |= p80211rate_to_p2bit(msg->basicrate8.data);
+	}
+	result = hfa384x_drvr_setconfig16(hw, HFA384x_RID_CNFBASICRATES, word);
+	if ( result ) {
+		WLAN_LOG_ERROR("Failed to set basicrates=%d.\n", word);
+		goto failed;
+	}
+
+	/* Operational rates (supprates and txratecontrol) */
+	word = p80211rate_to_p2bit(msg->operationalrate1.data);
+	if ( msg->operationalrate2.status == P80211ENUM_msgitem_status_data_ok ) {
+		word |= p80211rate_to_p2bit(msg->operationalrate2.data);
+	}
+	if ( msg->operationalrate3.status == P80211ENUM_msgitem_status_data_ok ) {
+		word |= p80211rate_to_p2bit(msg->operationalrate3.data);
+	}
+	if ( msg->operationalrate4.status == P80211ENUM_msgitem_status_data_ok ) {
+		word |= p80211rate_to_p2bit(msg->operationalrate4.data);
+	}
+	if ( msg->operationalrate5.status == P80211ENUM_msgitem_status_data_ok ) {
+		word |= p80211rate_to_p2bit(msg->operationalrate5.data);
+	}
+	if ( msg->operationalrate6.status == P80211ENUM_msgitem_status_data_ok ) {
+		word |= p80211rate_to_p2bit(msg->operationalrate6.data);
+	}
+	if ( msg->operationalrate7.status == P80211ENUM_msgitem_status_data_ok ) {
+		word |= p80211rate_to_p2bit(msg->operationalrate7.data);
+	}
+	if ( msg->operationalrate8.status == P80211ENUM_msgitem_status_data_ok ) {
+		word |= p80211rate_to_p2bit(msg->operationalrate8.data);
+	}
+	result = hfa384x_drvr_setconfig16(hw, HFA384x_RID_CNFSUPPRATES, word);
+	if ( result ) {
+		WLAN_LOG_ERROR("Failed to set supprates=%d.\n", word);
+		goto failed;
+	}
+	result = hfa384x_drvr_setconfig16(hw, HFA384x_RID_TXRATECNTL0, word);
+	if ( result ) {
+		WLAN_LOG_ERROR("Failed to set txrates=%d.\n", word);
+		goto failed;
+	}
+
+	/* ibssatimwindow */
+	if (msg->ibssatimwindow.status == P80211ENUM_msgitem_status_data_ok) {
+		WLAN_LOG_INFO("prism2mgmt_start: atimwindow not used in "
+			       "Infrastructure mode, ignored.\n");
+	}
+
+	/* DTIM period */
+	word = msg->dtimperiod.data;
+	result = hfa384x_drvr_setconfig16(hw, HFA384x_RID_CNFOWNDTIMPER, word);
+	if ( result ) {
+		WLAN_LOG_ERROR("Failed to set dtim period=%d.\n", word);
+		goto failed;
+	}
+
+	/* probedelay */
+	if (msg->probedelay.status == P80211ENUM_msgitem_status_data_ok) {
+		WLAN_LOG_INFO("prism2mgmt_start: probedelay not "
+			       "supported in prism2, ignored.\n");
+	}
+
+	/* cfpollable, cfpollreq, cfpperiod, cfpmaxduration */
+	if (msg->cfpollable.data == P80211ENUM_truth_true &&
+	    msg->cfpollreq.data == P80211ENUM_truth_true ) {
+		WLAN_LOG_ERROR("cfpollable=cfpollreq=true is illegal.\n");
+		result = -1;
+		goto failed;
+	}
+
+	/* read the PCFInfo and update */
+	result = hfa384x_drvr_getconfig(hw, HFA384x_RID_CNFAPPCFINFO,
+					pcfinfo, HFA384x_RID_CNFAPPCFINFO_LEN);
+	if ( result ) {
+		WLAN_LOG_INFO("prism2mgmt_start: read(pcfinfo) failed, "
+				"assume it's "
+				"not supported, pcf settings ignored.\n");
+		goto pcf_skip;
+	}
+	if ((msg->cfpollable.data == P80211ENUM_truth_false &&
+	     msg->cfpollreq.data == P80211ENUM_truth_false) ) {
+	    	pcfinfo->MediumOccupancyLimit = 0;
+		pcfinfo->CFPPeriod = 0;
+		pcfinfo->CFPMaxDuration = 0;
+		pcfinfo->CFPFlags &= host2hfa384x_16((UINT16)~BIT0);
+
+		if ( msg->cfpperiod.status == P80211ENUM_msgitem_status_data_ok ||
+		     msg->cfpmaxduration.status == P80211ENUM_msgitem_status_data_ok ) {
+			WLAN_LOG_WARNING(
+				"Setting cfpperiod or cfpmaxduration when "
+				"cfpollable and cfreq are false is pointless.\n");
+		}
+	}
+	if ((msg->cfpollable.data == P80211ENUM_truth_true ||
+	     msg->cfpollreq.data == P80211ENUM_truth_true) ) {
+		if ( msg->cfpollable.data == P80211ENUM_truth_true) {
+			pcfinfo->CFPFlags |= host2hfa384x_16((UINT16)BIT0);
+		}
+
+		if ( msg->cfpperiod.status == P80211ENUM_msgitem_status_data_ok) {
+			pcfinfo->CFPPeriod = msg->cfpperiod.data;
+			pcfinfo->CFPPeriod = host2hfa384x_16(pcfinfo->CFPPeriod);
+		}
+
+		if ( msg->cfpmaxduration.status == P80211ENUM_msgitem_status_data_ok) {
+			pcfinfo->CFPMaxDuration = msg->cfpmaxduration.data;
+			pcfinfo->CFPMaxDuration = host2hfa384x_16(pcfinfo->CFPMaxDuration);
+			pcfinfo->MediumOccupancyLimit = pcfinfo->CFPMaxDuration;
+		}
+	}
+	result = hfa384x_drvr_setconfig(hw, HFA384x_RID_CNFAPPCFINFO,
+					pcfinfo, HFA384x_RID_CNFAPPCFINFO_LEN);
+	if ( result ) {
+		WLAN_LOG_ERROR("write(pcfinfo) failed.\n");
+		goto failed;
+	}
+
+pcf_skip:
+	/* Set the macmode so the frame setup code knows what to do */
+	if ( msg->bsstype.data == P80211ENUM_bsstype_infrastructure ) {
+		wlandev->macmode = WLAN_MACMODE_ESS_AP;
+		/* lets extend the data length a bit */
+		hfa384x_drvr_setconfig16(hw, HFA384x_RID_CNFMAXDATALEN, 2304);
+	}
+
+	/* Set the BSSID to the same as our MAC */
+	memcpy( wlandev->bssid, wlandev->netdev->dev_addr, WLAN_BSSID_LEN);
+
+	/* Enable the Port */
+	result = hfa384x_drvr_enable(hw, 0);
+	if ( result ) {
+		WLAN_LOG_ERROR("Enable macport failed, result=%d.\n", result);
+		goto failed;
+	}
+
+	msg->resultcode.data = P80211ENUM_resultcode_success;
+
+	goto done;
+failed:
+	WLAN_LOG_DEBUG(1, "Failed to set a config option, result=%d\n", result);
+	msg->resultcode.data = P80211ENUM_resultcode_invalid_parameters;
+
+done:
+	result = 0;
+
+	DBFEXIT;
+	return result;
+}
+
+
+/*----------------------------------------------------------------
+* prism2mgmt_enable
+*
+* Start a BSS.  Any station can do this for IBSS, only AP for ESS.
+*
+* Arguments:
+*	wlandev		wlan device structure
+*	msgp		ptr to msg buffer
+*
+* Returns:
+*	0	success and done
+*	<0	success, but we're waiting for something to finish.
+*	>0	an error occurred while handling the message.
+* Side effects:
+*
+* Call context:
+*	process thread  (usually)
+*	interrupt
+----------------------------------------------------------------*/
+int prism2mgmt_enable(wlandevice_t *wlandev, void *msgp)
+{
+	int			result = 0;
+	hfa384x_t		*hw = wlandev->priv;
+	p80211msg_p2req_enable_t	*msg = msgp;
+	DBFENTER;
+
+	if (!hw->ap) {
+
+		/*** STATION ***/
+
+		/* Ad-Hoc not quite supported on Prism2 */
+		msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;
+		msg->resultcode.data = P80211ENUM_resultcode_not_supported;
+		goto done;
+	}
+
+	/*** ACCESS POINT ***/
+
+	msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;
+
+	/* Is the tertiary loaded? */
+	if ( hw->cap_sup_sta.id != 5) {
+		WLAN_LOG_ERROR("AP driver failed to detect AP firmware.\n");
+		goto failed;
+	}
+
+	/* Set the macmode so the frame setup code knows what to do */
+	wlandev->macmode = WLAN_MACMODE_ESS_AP;
+
+	/* Set the BSSID to the same as our MAC */
+	memcpy( wlandev->bssid, wlandev->netdev->dev_addr, WLAN_BSSID_LEN);
+
+	/* Enable the Port */
+	result = hfa384x_drvr_enable(hw, 0);
+	if ( result ) {
+		WLAN_LOG_ERROR("Enable macport failed, result=%d.\n", result);
+		goto failed;
+	}
+
+	msg->resultcode.data = P80211ENUM_resultcode_success;
+
+	goto done;
+failed:
+	msg->resultcode.data = P80211ENUM_resultcode_invalid_parameters;
+
+done:
+	result = 0;
+
+	DBFEXIT;
+	return result;
+}
+
+
+/*----------------------------------------------------------------
+* prism2mgmt_readpda
+*
+* Collect the PDA data and put it in the message.
+*
+* Arguments:
+*	wlandev		wlan device structure
+*	msgp		ptr to msg buffer
+*
+* Returns:
+*	0	success and done
+*	<0	success, but we're waiting for something to finish.
+*	>0	an error occurred while handling the message.
+* Side effects:
+*
+* Call context:
+*	process thread  (usually)
+----------------------------------------------------------------*/
+int prism2mgmt_readpda(wlandevice_t *wlandev, void *msgp)
+{
+	hfa384x_t		*hw = wlandev->priv;
+	p80211msg_p2req_readpda_t	*msg = msgp;
+	int				result;
+	DBFENTER;
+
+	/* We only support collecting the PDA when in the FWLOAD
+	 * state.
+	 */
+	if (wlandev->msdstate != WLAN_MSD_FWLOAD) {
+		WLAN_LOG_ERROR(
+			"PDA may only be read "
+			"in the fwload state.\n");
+		msg->resultcode.data =
+			P80211ENUM_resultcode_implementation_failure;
+		msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;
+	} else {
+		/*  Call drvr_readpda(), it handles the auxport enable
+		 *  and validating the returned PDA.
+		 */
+		result = hfa384x_drvr_readpda(
+			hw,
+			msg->pda.data,
+			HFA384x_PDA_LEN_MAX);
+		if (result) {
+			WLAN_LOG_ERROR(
+				"hfa384x_drvr_readpda() failed, "
+				"result=%d\n",
+				result);
+
+			msg->resultcode.data =
+				P80211ENUM_resultcode_implementation_failure;
+			msg->resultcode.status =
+				P80211ENUM_msgitem_status_data_ok;
+			DBFEXIT;
+			return 0;
+		}
+		msg->pda.status = P80211ENUM_msgitem_status_data_ok;
+		msg->resultcode.data = P80211ENUM_resultcode_success;
+		msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;
+	}
+
+	DBFEXIT;
+	return 0;
+}
+
+/*----------------------------------------------------------------
+* prism2mgmt_readcis
+*
+* Collect the CIS data and put it in the message.
+*
+* Arguments:
+*	wlandev		wlan device structure
+*	msgp		ptr to msg buffer
+*
+* Returns:
+*	0	success and done
+*	<0	success, but we're waiting for something to finish.
+*	>0	an error occurred while handling the message.
+* Side effects:
+*
+* Call context:
+*	process thread  (usually)
+----------------------------------------------------------------*/
+int prism2mgmt_readcis(wlandevice_t *wlandev, void *msgp)
+{
+	int			result;
+	hfa384x_t		*hw = wlandev->priv;
+	p80211msg_p2req_readcis_t	*msg = msgp;
+
+	DBFENTER;
+
+        memset(msg->cis.data, 0, sizeof(msg->cis.data));
+
+	result = hfa384x_drvr_getconfig(hw, HFA384x_RID_CIS,
+					msg->cis.data, HFA384x_RID_CIS_LEN);
+	if ( result ) {
+		WLAN_LOG_INFO("prism2mgmt_readcis: read(cis) failed.\n");
+		msg->cis.status = P80211ENUM_msgitem_status_no_value;
+		msg->resultcode.data = P80211ENUM_resultcode_implementation_failure;
+
+		}
+	else {
+		msg->cis.status = P80211ENUM_msgitem_status_data_ok;
+		msg->resultcode.data = P80211ENUM_resultcode_success;
+		}
+
+	msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;
+
+	DBFEXIT;
+	return 0;
+}
+
+/*----------------------------------------------------------------
+* prism2mgmt_auxport_state
+*
+* Enables/Disables the card's auxiliary port.  Should be called
+* before and after a sequence of auxport_read()/auxport_write()
+* calls.
+*
+* Arguments:
+*	wlandev		wlan device structure
+*	msgp		ptr to msg buffer
+*
+* Returns:
+*	0	success and done
+*	<0	success, but we're waiting for something to finish.
+*	>0	an error occurred while handling the message.
+* Side effects:
+*
+* Call context:
+*	process thread  (usually)
+----------------------------------------------------------------*/
+int prism2mgmt_auxport_state(wlandevice_t *wlandev, void *msgp)
+{
+	p80211msg_p2req_auxport_state_t	*msg = msgp;
+
+#if (WLAN_HOSTIF != WLAN_USB)
+	hfa384x_t		*hw = wlandev->priv;
+	DBFENTER;
+
+	msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;
+	if (msg->enable.data == P80211ENUM_truth_true) {
+		if ( hfa384x_cmd_aux_enable(hw, 0) ) {
+			msg->resultcode.data = P80211ENUM_resultcode_implementation_failure;
+		} else {
+			msg->resultcode.data = P80211ENUM_resultcode_success;
+		}
+	} else {
+		hfa384x_cmd_aux_disable(hw);
+		msg->resultcode.data = P80211ENUM_resultcode_success;
+	}
+
+#else /* !USB */
+	DBFENTER;
+
+	msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;
+	msg->resultcode.data = P80211ENUM_resultcode_not_supported;
+
+#endif /* WLAN_HOSTIF != WLAN_USB */
+
+	DBFEXIT;
+	return 0;
+}
+
+
+/*----------------------------------------------------------------
+* prism2mgmt_auxport_read
+*
+* Copies data from the card using the auxport.  The auxport must
+* have previously been enabled.  Note: this is not the way to
+* do downloads, see the [ram|flash]dl functions.
+*
+* Arguments:
+*	wlandev		wlan device structure
+*	msgp		ptr to msg buffer
+*
+* Returns:
+*	0	success and done
+*	<0	success, but we're waiting for something to finish.
+*	>0	an error occurred while handling the message.
+* Side effects:
+*
+* Call context:
+*	process thread  (usually)
+----------------------------------------------------------------*/
+int prism2mgmt_auxport_read(wlandevice_t *wlandev, void *msgp)
+{
+#if (WLAN_HOSTIF != WLAN_USB)
+	hfa384x_t		*hw = wlandev->priv;
+	p80211msg_p2req_auxport_read_t	*msg = msgp;
+	UINT32			addr;
+	UINT32			len;
+	UINT8*			buf;
+	UINT32			maxlen = sizeof(msg->data.data);
+	DBFENTER;
+
+	if ( hw->auxen ) {
+		addr = msg->addr.data;
+		len = msg->len.data;
+		buf = msg->data.data;
+		if ( len <= maxlen ) {  /* max read/write size */
+			hfa384x_copy_from_aux(hw, addr, HFA384x_AUX_CTL_EXTDS, buf, len);
+			msg->resultcode.data = P80211ENUM_resultcode_success;
+		} else {
+			WLAN_LOG_DEBUG(1,"Attempt to read > maxlen from auxport.\n");
+			msg->resultcode.data = P80211ENUM_resultcode_refused;
+		}
+
+	} else {
+		msg->resultcode.data = P80211ENUM_resultcode_refused;
+	}
+	msg->data.status = P80211ENUM_msgitem_status_data_ok;
+	msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;
+
+	DBFEXIT;
+	return 0;
+#else
+	DBFENTER;
+
+	WLAN_LOG_ERROR("prism2mgmt_auxport_read: Not supported on USB.\n");
+
+	DBFEXIT;
+	return 0;
+#endif
+}
+
+
+/*----------------------------------------------------------------
+* prism2mgmt_auxport_write
+*
+* Copies data to the card using the auxport.  The auxport must
+* have previously been enabled.  Note: this is not the way to
+* do downloads, see the [ram|flash]dl functions.
+*
+* Arguments:
+*	wlandev		wlan device structure
+*	msgp		ptr to msg buffer
+*
+* Returns:
+*	0	success and done
+*	<0	success, but we're waiting for something to finish.
+*	>0	an error occurred while handling the message.
+* Side effects:
+*
+* Call context:
+*	process thread  (usually)
+----------------------------------------------------------------*/
+int prism2mgmt_auxport_write(wlandevice_t *wlandev, void *msgp)
+{
+#if (WLAN_HOSTIF != WLAN_USB)
+	hfa384x_t		*hw = wlandev->priv;
+	p80211msg_p2req_auxport_write_t	*msg = msgp;
+	UINT32			addr;
+	UINT32			len;
+	UINT8*			buf;
+	UINT32			maxlen = sizeof(msg->data.data);
+	DBFENTER;
+
+	if ( hw->auxen ) {
+		addr = msg->addr.data;
+		len = msg->len.data;
+		buf = msg->data.data;
+		if ( len <= maxlen ) {  /* max read/write size */
+			hfa384x_copy_to_aux(hw, addr, HFA384x_AUX_CTL_EXTDS, buf, len);
+		} else {
+			WLAN_LOG_DEBUG(1,"Attempt to write > maxlen from auxport.\n");
+			msg->resultcode.data = P80211ENUM_resultcode_refused;
+		}
+
+	} else {
+		msg->resultcode.data = P80211ENUM_resultcode_refused;
+	}
+	msg->data.status = P80211ENUM_msgitem_status_data_ok;
+	msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;
+
+	DBFEXIT;
+	return 0;
+#else
+	DBFENTER;
+	WLAN_LOG_ERROR("prism2mgmt_auxport_read: Not supported on USB.\n");
+	DBFEXIT;
+	return 0;
+#endif
+}
+
+/*----------------------------------------------------------------
+* prism2mgmt_low_level
+*
+* Puts the card into the desired test mode.
+*
+* Arguments:
+*       wlandev         wlan device structure
+*       msgp            ptr to msg buffer
+*
+* Returns:
+*       0       success and done
+*       <0      success, but we're waiting for something to finish.
+*       >0      an error occurred while handling the message.
+* Side effects:
+*
+* Call context:
+*       process thread  (usually)
+----------------------------------------------------------------*/
+int prism2mgmt_low_level(wlandevice_t *wlandev, void *msgp)
+{
+	hfa384x_t		*hw = wlandev->priv;
+        p80211msg_p2req_low_level_t     *msg = msgp;
+	hfa384x_metacmd_t cmd;
+        DBFENTER;
+
+        msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;
+
+        /* call some routine to execute the test command */
+	cmd.cmd = (UINT16) msg->command.data;
+	cmd.parm0 = (UINT16) msg->param0.data;
+	cmd.parm1 = (UINT16) msg->param1.data;
+	cmd.parm2 = (UINT16) msg->param2.data;
+
+        hfa384x_drvr_low_level(hw,&cmd);
+
+        msg->resp0.data = (UINT32) cmd.result.resp0;
+        msg->resp1.data = (UINT32) cmd.result.resp1;
+        msg->resp2.data = (UINT32) cmd.result.resp2;
+
+        msg->resultcode.data = P80211ENUM_resultcode_success;
+
+        DBFEXIT;
+        return 0;
+}
+
+/*----------------------------------------------------------------
+* prism2mgmt_test_command
+*
+* Puts the card into the desired test mode.
+*
+* Arguments:
+*	wlandev		wlan device structure
+*	msgp		ptr to msg buffer
+*
+* Returns:
+*	0	success and done
+*	<0	success, but we're waiting for something to finish.
+*	>0	an error occurred while handling the message.
+* Side effects:
+*
+* Call context:
+*	process thread  (usually)
+----------------------------------------------------------------*/
+int prism2mgmt_test_command(wlandevice_t *wlandev, void *msgp)
+{
+	hfa384x_t		*hw = wlandev->priv;
+	p80211msg_p2req_test_command_t	*msg = msgp;
+	hfa384x_metacmd_t cmd;
+
+        DBFENTER;
+
+	cmd.cmd = ((UINT16) msg->testcode.data) << 8 | 0x38;
+	cmd.parm0 = (UINT16) msg->testparam.data;
+	cmd.parm1 = 0;
+	cmd.parm2 = 0;
+
+        /* call some routine to execute the test command */
+
+        hfa384x_drvr_low_level(hw,&cmd);
+
+        msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;
+        msg->resultcode.data = P80211ENUM_resultcode_success;
+
+        msg->status.status = P80211ENUM_msgitem_status_data_ok;
+        msg->status.data = cmd.result.status;
+        msg->resp0.status = P80211ENUM_msgitem_status_data_ok;
+        msg->resp0.data = cmd.result.resp0;
+        msg->resp1.status = P80211ENUM_msgitem_status_data_ok;
+        msg->resp1.data = cmd.result.resp1;
+        msg->resp2.status = P80211ENUM_msgitem_status_data_ok;
+        msg->resp2.data = cmd.result.resp2;
+
+	DBFEXIT;
+	return 0;
+}
+
+
+/*----------------------------------------------------------------
+* prism2mgmt_mmi_read
+*
+* Read from one of the MMI registers.
+*
+* Arguments:
+*	wlandev		wlan device structure
+*	msgp		ptr to msg buffer
+*
+* Returns:
+*	0	success and done
+*	<0	success, but we're waiting for something to finish.
+*	>0	an error occurred while handling the message.
+* Side effects:
+*
+* Call context:
+*	process thread  (usually)
+----------------------------------------------------------------*/
+int prism2mgmt_mmi_read(wlandevice_t *wlandev, void *msgp)
+{
+	hfa384x_t		*hw = wlandev->priv;
+	p80211msg_p2req_mmi_read_t	*msg = msgp;
+	UINT32 resp = 0;
+
+	DBFENTER;
+
+	msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;
+
+	/* call some routine to execute the test command */
+
+	hfa384x_drvr_mmi_read(hw, msg->addr.data, &resp);
+
+	/* I'm not sure if this is "architecturally" correct, but it
+           is expedient. */
+
+	msg->value.status = P80211ENUM_msgitem_status_data_ok;
+	msg->value.data = resp;
+	msg->resultcode.data = P80211ENUM_resultcode_success;
+
+	DBFEXIT;
+	return 0;
+}
+
+/*----------------------------------------------------------------
+* prism2mgmt_mmi_write
+*
+* Write a data value to one of the MMI registers.
+*
+* Arguments:
+*	wlandev		wlan device structure
+*	msgp		ptr to msg buffer
+*
+* Returns:
+*	0	success and done
+*	<0	success, but we're waiting for something to finish.
+*	>0	an error occurred while handling the message.
+* Side effects:
+*
+* Call context:
+*	process thread  (usually)
+----------------------------------------------------------------*/
+int prism2mgmt_mmi_write(wlandevice_t *wlandev, void *msgp)
+{
+	hfa384x_t		*hw = wlandev->priv;
+	p80211msg_p2req_mmi_write_t	*msg = msgp;
+	DBFENTER;
+
+	msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;
+
+	/* call some routine to execute the test command */
+
+	hfa384x_drvr_mmi_write(hw, msg->addr.data, msg->data.data);
+
+	msg->resultcode.data = P80211ENUM_resultcode_success;
+
+	DBFEXIT;
+	return 0;
+}
+
+/*----------------------------------------------------------------
+* prism2mgmt_ramdl_state
+*
+* Establishes the beginning/end of a card RAM download session.
+*
+* It is expected that the ramdl_write() function will be called
+* one or more times between the 'enable' and 'disable' calls to
+* this function.
+*
+* Note: This function should not be called when a mac comm port
+*       is active.
+*
+* Arguments:
+*	wlandev		wlan device structure
+*	msgp		ptr to msg buffer
+*
+* Returns:
+*	0	success and done
+*	<0	success, but we're waiting for something to finish.
+*	>0	an error occurred while handling the message.
+* Side effects:
+*
+* Call context:
+*	process thread  (usually)
+----------------------------------------------------------------*/
+int prism2mgmt_ramdl_state(wlandevice_t *wlandev, void *msgp)
+{
+	hfa384x_t		*hw = wlandev->priv;
+	p80211msg_p2req_ramdl_state_t	*msg = msgp;
+	DBFENTER;
+
+	if (wlandev->msdstate != WLAN_MSD_FWLOAD) {
+		WLAN_LOG_ERROR(
+			"ramdl_state(): may only be called "
+			"in the fwload state.\n");
+		msg->resultcode.data =
+			P80211ENUM_resultcode_implementation_failure;
+		msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;
+		DBFEXIT;
+		return 0;
+	}
+
+	/*
+	** Note: Interrupts are locked out if this is an AP and are NOT
+	** locked out if this is a station.
+	*/
+
+	msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;
+	if  ( msg->enable.data == P80211ENUM_truth_true ) {
+		if ( hfa384x_drvr_ramdl_enable(hw, msg->exeaddr.data) ) {
+			msg->resultcode.data = P80211ENUM_resultcode_implementation_failure;
+		} else {
+			msg->resultcode.data = P80211ENUM_resultcode_success;
+		}
+	} else {
+		hfa384x_drvr_ramdl_disable(hw);
+		msg->resultcode.data = P80211ENUM_resultcode_success;
+	}
+
+	DBFEXIT;
+	return 0;
+}
+
+
+/*----------------------------------------------------------------
+* prism2mgmt_ramdl_write
+*
+* Writes a buffer to the card RAM using the download state.  This
+* is for writing code to card RAM.  To just read or write raw data
+* use the aux functions.
+*
+* Arguments:
+*	wlandev		wlan device structure
+*	msgp		ptr to msg buffer
+*
+* Returns:
+*	0	success and done
+*	<0	success, but we're waiting for something to finish.
+*	>0	an error occurred while handling the message.
+* Side effects:
+*
+* Call context:
+*	process thread  (usually)
+----------------------------------------------------------------*/
+int prism2mgmt_ramdl_write(wlandevice_t *wlandev, void *msgp)
+{
+	hfa384x_t		*hw = wlandev->priv;
+	p80211msg_p2req_ramdl_write_t	*msg = msgp;
+	UINT32			addr;
+	UINT32			len;
+	UINT8			*buf;
+	DBFENTER;
+
+	if (wlandev->msdstate != WLAN_MSD_FWLOAD) {
+		WLAN_LOG_ERROR(
+			"ramdl_write(): may only be called "
+			"in the fwload state.\n");
+		msg->resultcode.data =
+			P80211ENUM_resultcode_implementation_failure;
+		msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;
+		DBFEXIT;
+		return 0;
+	}
+
+	msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;
+	/* first validate the length */
+	if  ( msg->len.data > sizeof(msg->data.data) ) {
+		msg->resultcode.status = P80211ENUM_resultcode_invalid_parameters;
+		return 0;
+	}
+	/* call the hfa384x function to do the write */
+	addr = msg->addr.data;
+	len = msg->len.data;
+	buf = msg->data.data;
+	if ( hfa384x_drvr_ramdl_write(hw, addr, buf, len) ) {
+		msg->resultcode.data = P80211ENUM_resultcode_refused;
+
+	}
+	msg->resultcode.data = P80211ENUM_resultcode_success;
+
+	DBFEXIT;
+	return 0;
+}
+
+
+/*----------------------------------------------------------------
+* prism2mgmt_flashdl_state
+*
+* Establishes the beginning/end of a card Flash download session.
+*
+* It is expected that the flashdl_write() function will be called
+* one or more times between the 'enable' and 'disable' calls to
+* this function.
+*
+* Note: This function should not be called when a mac comm port
+*       is active.
+*
+* Arguments:
+*	wlandev		wlan device structure
+*	msgp		ptr to msg buffer
+*
+* Returns:
+*	0	success and done
+*	<0	success, but we're waiting for something to finish.
+*	>0	an error occurred while handling the message.
+* Side effects:
+*
+* Call context:
+*	process thread  (usually)
+----------------------------------------------------------------*/
+int prism2mgmt_flashdl_state(wlandevice_t *wlandev, void *msgp)
+{
+	int			result = 0;
+	hfa384x_t		*hw = wlandev->priv;
+	p80211msg_p2req_flashdl_state_t	*msg = msgp;
+	DBFENTER;
+
+	if (wlandev->msdstate != WLAN_MSD_FWLOAD) {
+		WLAN_LOG_ERROR(
+			"flashdl_state(): may only be called "
+			"in the fwload state.\n");
+		msg->resultcode.data =
+			P80211ENUM_resultcode_implementation_failure;
+		msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;
+		DBFEXIT;
+		return 0;
+	}
+
+	/*
+	** Note: Interrupts are locked out if this is an AP and are NOT
+	** locked out if this is a station.
+	*/
+
+	msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;
+	if  ( msg->enable.data == P80211ENUM_truth_true ) {
+		if ( hfa384x_drvr_flashdl_enable(hw) ) {
+			msg->resultcode.data = P80211ENUM_resultcode_implementation_failure;
+		} else {
+			msg->resultcode.data = P80211ENUM_resultcode_success;
+		}
+	} else {
+		hfa384x_drvr_flashdl_disable(hw);
+		msg->resultcode.data = P80211ENUM_resultcode_success;
+		/* NOTE: At this point, the MAC is in the post-reset
+		 * state and the driver is in the fwload state.
+		 * We need to get the MAC back into the fwload
+		 * state.  To do this, we set the nsdstate to HWPRESENT
+		 * and then call the ifstate function to redo everything
+		 * that got us into the fwload state.
+		 */
+		wlandev->msdstate = WLAN_MSD_HWPRESENT;
+		result = prism2sta_ifstate(wlandev, P80211ENUM_ifstate_fwload);
+		if (result != P80211ENUM_resultcode_success) {
+			WLAN_LOG_ERROR("prism2sta_ifstate(fwload) failed,"
+				"P80211ENUM_resultcode=%d\n", result);
+			msg->resultcode.data =
+				P80211ENUM_resultcode_implementation_failure;
+			result = -1;
+		}
+	}
+
+	DBFEXIT;
+	return 0;
+}
+
+
+/*----------------------------------------------------------------
+* prism2mgmt_flashdl_write
+*
+*
+*
+* Arguments:
+*	wlandev		wlan device structure
+*	msgp		ptr to msg buffer
+*
+* Returns:
+*	0	success and done
+*	<0	success, but we're waiting for something to finish.
+*	>0	an error occurred while handling the message.
+* Side effects:
+*
+* Call context:
+*	process thread  (usually)
+----------------------------------------------------------------*/
+int prism2mgmt_flashdl_write(wlandevice_t *wlandev, void *msgp)
+{
+	hfa384x_t		*hw = wlandev->priv;
+	p80211msg_p2req_flashdl_write_t	*msg = msgp;
+	UINT32			addr;
+	UINT32			len;
+	UINT8			*buf;
+	DBFENTER;
+
+	if (wlandev->msdstate != WLAN_MSD_FWLOAD) {
+		WLAN_LOG_ERROR(
+			"flashdl_write(): may only be called "
+			"in the fwload state.\n");
+		msg->resultcode.data =
+			P80211ENUM_resultcode_implementation_failure;
+		msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;
+		DBFEXIT;
+		return 0;
+	}
+
+	/*
+	** Note: Interrupts are locked out if this is an AP and are NOT
+	** locked out if this is a station.
+	*/
+
+	msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;
+	/* first validate the length */
+	if  ( msg->len.data > sizeof(msg->data.data) ) {
+		msg->resultcode.status =
+			P80211ENUM_resultcode_invalid_parameters;
+		return 0;
+	}
+	/* call the hfa384x function to do the write */
+	addr = msg->addr.data;
+	len = msg->len.data;
+	buf = msg->data.data;
+	if ( hfa384x_drvr_flashdl_write(hw, addr, buf, len) ) {
+		msg->resultcode.data = P80211ENUM_resultcode_refused;
+
+	}
+	msg->resultcode.data = P80211ENUM_resultcode_success;
+
+	DBFEXIT;
+	return 0;
+}
+
+
+/*----------------------------------------------------------------
+* prism2mgmt_dump_state
+*
+* Dumps the driver's and hardware's current state via the kernel
+* log at KERN_NOTICE level.
+*
+* Arguments:
+*	wlandev		wlan device structure
+*	msgp		ptr to msg buffer
+*
+* Returns:
+*	0	success and done
+*	<0	success, but we're waiting for something to finish.
+*	>0	an error occurred while handling the message.
+* Side effects:
+*
+* Call context:
+*	process thread  (usually)
+----------------------------------------------------------------*/
+int prism2mgmt_dump_state(wlandevice_t *wlandev, void *msgp)
+{
+	p80211msg_p2req_dump_state_t	*msg = msgp;
+	int				result = 0;
+
+#if (WLAN_HOSTIF != WLAN_USB)
+	hfa384x_t		*hw = wlandev->priv;
+	UINT16				auxbuf[15];
+	DBFENTER;
+
+	WLAN_LOG_NOTICE("prism2 driver and hardware state:\n");
+	if  ( (result = hfa384x_cmd_aux_enable(hw, 0)) ) {
+		WLAN_LOG_ERROR("aux_enable failed, result=%d\n", result);
+		goto failed;
+	}
+	hfa384x_copy_from_aux(hw,
+		0x01e2,
+		HFA384x_AUX_CTL_EXTDS,
+		auxbuf,
+		sizeof(auxbuf));
+	hfa384x_cmd_aux_disable(hw);
+	WLAN_LOG_NOTICE("  cmac: FreeBlocks=%d\n", auxbuf[5]);
+	WLAN_LOG_NOTICE("  cmac: IntEn=0x%02x EvStat=0x%02x\n",
+		hfa384x_getreg(hw, HFA384x_INTEN),
+		hfa384x_getreg(hw, HFA384x_EVSTAT));
+
+	#ifdef USE_FID_STACK
+	WLAN_LOG_NOTICE("  drvr: txfid_top=%d stacksize=%d\n",
+		hw->txfid_top,HFA384x_DRVR_FIDSTACKLEN_MAX);
+	#else
+	WLAN_LOG_NOTICE("  drvr: txfid_head=%d txfid_tail=%d txfid_N=%d\n",
+		hw->txfid_head, hw->txfid_tail, hw->txfid_N);
+	#endif
+
+	msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;
+	msg->resultcode.data = P80211ENUM_resultcode_success;
+
+#else /* (WLAN_HOSTIF == WLAN_USB) */
+
+	DBFENTER;
+
+	msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;
+	msg->resultcode.data = P80211ENUM_resultcode_not_supported;
+	goto failed;
+
+#endif /* (WLAN_HOSTIF != WLAN_USB) */
+
+failed:
+	DBFEXIT;
+	return result;
+}
+
+/*----------------------------------------------------------------
+* prism2mgmt_channel_info
+*
+* Issues a ChannelInfoRequest.
+*
+* Arguments:
+*	wlandev		wlan device structure
+*	msgp		ptr to msg buffer
+*
+* Returns:
+*	0	success and done
+*	<0	success, but we're waiting for something to finish.
+*	>0	an error occurred while handling the message.
+* Side effects:
+*
+* Call context:
+*	process thread  (usually)
+----------------------------------------------------------------*/
+int prism2mgmt_channel_info(wlandevice_t *wlandev, void *msgp)
+{
+	p80211msg_p2req_channel_info_t	*msg=msgp;
+	hfa384x_t			*hw = wlandev->priv;
+	int				result, i, n=0;
+	UINT16				channel_mask=0;
+	hfa384x_ChannelInfoRequest_data_t	chinforeq;
+	// unsigned long 			now;
+
+	DBFENTER;
+
+	if (!hw->ap) {
+
+		/*** STATION ***/
+
+		/* Not supported in STA f/w */
+		P80211_SET_INT(msg->resultcode, P80211ENUM_resultcode_not_supported);
+		goto done;
+	}
+
+	/*** ACCESS POINT ***/
+
+#define CHINFO_TIMEOUT 2
+
+	P80211_SET_INT(msg->resultcode, P80211ENUM_resultcode_success);
+
+	/* setting default value for channellist = all channels */
+	if (!msg->channellist.data) {
+		P80211_SET_INT(msg->channellist, 0x00007FFE);
+	}
+	/* setting default value for channeldwelltime = 100 ms */
+	if (!msg->channeldwelltime.data) {
+		P80211_SET_INT(msg->channeldwelltime, 100);
+	}
+	channel_mask = (UINT16) (msg->channellist.data >> 1);
+	for (i=0, n=0; i < 14; i++) {
+		if (channel_mask & (1<<i)) {
+			n++;
+		}
+	}
+	P80211_SET_INT(msg->numchinfo, n);
+	chinforeq.channelList = host2hfa384x_16(channel_mask);
+	chinforeq.channelDwellTime = host2hfa384x_16(msg->channeldwelltime.data);
+
+	atomic_set(&hw->channel_info.done, 1);
+
+	result = hfa384x_drvr_setconfig( hw, HFA384x_RID_CHANNELINFOREQUEST,
+					 &chinforeq, HFA384x_RID_CHANNELINFOREQUEST_LEN);
+	if ( result ) {
+		WLAN_LOG_ERROR("setconfig(CHANNELINFOREQUEST) failed. result=%d\n",
+				result);
+		msg->resultcode.data = P80211ENUM_resultcode_not_supported;
+		goto done;
+	}
+	/*
+	now = jiffies;
+	while (atomic_read(&hw->channel_info.done) != 1) {
+		if ((jiffies - now) > CHINFO_TIMEOUT*HZ) {
+			WLAN_LOG_NOTICE("ChannelInfo results not received in %d seconds, aborting.\n",
+					CHINFO_TIMEOUT);
+			msg->resultcode.data = P80211ENUM_resultcode_timeout;
+			goto done;
+		}
+		current->state = TASK_INTERRUPTIBLE;
+		schedule_timeout(HZ/4);
+		current->state = TASK_RUNNING;
+	}
+	*/
+
+done:
+
+	DBFEXIT;
+	return 0;
+}
+
+/*----------------------------------------------------------------
+* prism2mgmt_channel_info_results
+*
+* Returns required ChannelInfo result.
+*
+* Arguments:
+*	wlandev		wlan device structure
+*	msgp		ptr to msg buffer
+*
+* Returns:
+*	0	success and done
+*	<0	success, but we're waiting for something to finish.
+*	>0	an error occurred while handling the message.
+* Side effects:
+*
+* Call context:
+*	process thread  (usually)
+----------------------------------------------------------------*/
+int prism2mgmt_channel_info_results(wlandevice_t *wlandev, void *msgp)
+{
+	hfa384x_t			*hw = wlandev->priv;
+
+	p80211msg_p2req_channel_info_results_t	*msg=msgp;
+	int				result=0;
+	int		channel;
+
+	DBFENTER;
+
+	if (!hw->ap) {
+
+		/*** STATION ***/
+
+		/* Not supported in STA f/w */
+		P80211_SET_INT(msg->resultcode, P80211ENUM_resultcode_not_supported);
+		goto done;
+	}
+
+	/*** ACCESS POINT ***/
+
+	switch (atomic_read(&hw->channel_info.done)) {
+	case 0: msg->resultcode.status = P80211ENUM_msgitem_status_no_value;
+		goto done;
+	case 1: msg->resultcode.status = P80211ENUM_msgitem_status_incomplete_itemdata;
+		goto done;
+	}
+
+	P80211_SET_INT(msg->resultcode, P80211ENUM_resultcode_success);
+	channel=msg->channel.data-1;
+
+	if (channel < 0 || ! (hw->channel_info.results.scanchannels & 1<<channel) ) {
+		msg->resultcode.data = P80211ENUM_resultcode_invalid_parameters;
+		goto done;
+	}
+	WLAN_LOG_DEBUG(2, "chinfo_results: channel %d, avg/peak level=%d/%d dB, active=%d\n",
+			channel+1,
+			hw->channel_info.results.result[channel].anl,
+			hw->channel_info.results.result[channel].pnl,
+			hw->channel_info.results.result[channel].active
+		);
+	P80211_SET_INT(msg->avgnoiselevel, hw->channel_info.results.result[channel].anl);
+	P80211_SET_INT(msg->peaknoiselevel, hw->channel_info.results.result[channel].pnl);
+	P80211_SET_INT(msg->bssactive, hw->channel_info.results.result[channel].active &
+		HFA384x_CHINFORESULT_BSSACTIVE
+                ? P80211ENUM_truth_true
+                : P80211ENUM_truth_false) ;
+	P80211_SET_INT(msg->pcfactive, hw->channel_info.results.result[channel].active &
+		HFA384x_CHINFORESULT_PCFACTIVE
+                ? P80211ENUM_truth_true
+                : P80211ENUM_truth_false) ;
+
+done:
+	DBFEXIT;
+	return result;
+}
+
+
+/*----------------------------------------------------------------
+* prism2mgmt_autojoin
+*
+* Associate with an ESS.
+*
+* Arguments:
+*	wlandev		wlan device structure
+*	msgp		ptr to msg buffer
+*
+* Returns:
+*	0	success and done
+*	<0	success, but we're waiting for something to finish.
+*	>0	an error occurred while handling the message.
+* Side effects:
+*
+* Call context:
+*	process thread  (usually)
+*	interrupt
+----------------------------------------------------------------*/
+int prism2mgmt_autojoin(wlandevice_t *wlandev, void *msgp)
+{
+	hfa384x_t			*hw = wlandev->priv;
+	int 			result = 0;
+	UINT16			reg;
+	UINT16			port_type;
+	p80211msg_lnxreq_autojoin_t	*msg = msgp;
+	p80211pstrd_t		*pstr;
+	UINT8			bytebuf[256];
+	hfa384x_bytestr_t	*p2bytestr = (hfa384x_bytestr_t*)bytebuf;
+	DBFENTER;
+
+	wlandev->macmode = WLAN_MACMODE_NONE;
+
+	/* Set the SSID */
+	memcpy(&wlandev->ssid, &msg->ssid.data, sizeof(msg->ssid.data));
+
+	if (hw->ap) {
+
+		/*** ACCESS POINT ***/
+
+		/* Never supported on AP */
+		msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;
+		msg->resultcode.data = P80211ENUM_resultcode_not_supported;
+		goto done;
+	}
+
+	/* Disable the Port */
+	hfa384x_drvr_disable(hw, 0);
+
+	/*** STATION ***/
+	/* Set the TxRates */
+	hfa384x_drvr_setconfig16(hw, HFA384x_RID_TXRATECNTL, 0x000f);
+
+	/* Set the auth type */
+	if ( msg->authtype.data == P80211ENUM_authalg_sharedkey ) {
+		reg = HFA384x_CNFAUTHENTICATION_SHAREDKEY;
+	} else {
+		reg = HFA384x_CNFAUTHENTICATION_OPENSYSTEM;
+	}
+	hfa384x_drvr_setconfig16(hw, HFA384x_RID_CNFAUTHENTICATION, reg);
+
+	/* Set the ssid */
+	memset(bytebuf, 0, 256);
+	pstr = (p80211pstrd_t*)&(msg->ssid.data);
+	prism2mgmt_pstr2bytestr(p2bytestr, pstr);
+        result = hfa384x_drvr_setconfig(
+			hw, HFA384x_RID_CNFDESIREDSSID,
+			bytebuf, HFA384x_RID_CNFDESIREDSSID_LEN);
+#if 0
+	/* we can use the new-fangled auto-unknown mode if the firmware
+	   is 1.3.3 or newer */
+	if (HFA384x_FIRMARE_VERSION(hw->ident_sta_fw.major,
+				    hw->ident_sta_fw.minor,
+				    hw->ident_sta_fw.variant) >=
+	    HFA384x_FIRMWARE_VERSION(1,3,3)) {
+		/* Set up the IBSS options */
+		reg =  HFA384x_CREATEIBSS_JOINESS_JOINCREATEIBSS;
+		hfa384x_drvr_setconfig16(hw, HFA384x_RID_CREATEIBSS, reg);
+
+		/* Set the PortType */
+		port_type = HFA384x_PORTTYPE_IBSS;
+	} else {
+		port_type = HFA384x_PORTTYPE_BSS;
+	}
+#else
+	port_type = HFA384x_PORTTYPE_BSS;
+#endif
+	/* Set the PortType */
+	hfa384x_drvr_setconfig16(hw, HFA384x_RID_CNFPORTTYPE, port_type);
+
+	/* Enable the Port */
+	hfa384x_drvr_enable(hw, 0);
+
+	/* Set the resultcode */
+	msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;
+	msg->resultcode.data = P80211ENUM_resultcode_success;
+
+done:
+	DBFEXIT;
+	return result;
+}
+
+
+/*----------------------------------------------------------------
+* prism2mgmt_wlansniff
+*
+* Start or stop sniffing.
+*
+* Arguments:
+*	wlandev		wlan device structure
+*	msgp		ptr to msg buffer
+*
+* Returns:
+*	0	success and done
+*	<0	success, but we're waiting for something to finish.
+*	>0	an error occurred while handling the message.
+* Side effects:
+*
+* Call context:
+*	process thread  (usually)
+*	interrupt
+----------------------------------------------------------------*/
+int prism2mgmt_wlansniff(wlandevice_t *wlandev, void *msgp)
+{
+	int 			result = 0;
+	p80211msg_lnxreq_wlansniff_t	*msg = msgp;
+
+	hfa384x_t			*hw = wlandev->priv;
+	UINT16			word;
+
+	DBFENTER;
+
+	msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;
+	switch (msg->enable.data)
+	{
+	case P80211ENUM_truth_false:
+		/* Confirm that we're in monitor mode */
+		if ( wlandev->netdev->type == ARPHRD_ETHER ) {
+			msg->resultcode.data = P80211ENUM_resultcode_invalid_parameters;
+			result = 0;
+			goto exit;
+		}
+		/* Disable monitor mode */
+		result = hfa384x_cmd_monitor(hw, HFA384x_MONITOR_DISABLE);
+		if ( result ) {
+			WLAN_LOG_DEBUG(1,
+				"failed to disable monitor mode, result=%d\n",
+				result);
+			goto failed;
+		}
+		/* Disable port 0 */
+		result = hfa384x_drvr_disable(hw, 0);
+		if ( result ) {
+			WLAN_LOG_DEBUG(1,
+			"failed to disable port 0 after sniffing, result=%d\n",
+			result);
+			goto failed;
+		}
+		/* Clear the driver state */
+		wlandev->netdev->type = ARPHRD_ETHER;
+
+		/* Restore the wepflags */
+		result = hfa384x_drvr_setconfig16(hw,
+				HFA384x_RID_CNFWEPFLAGS,
+				hw->presniff_wepflags);
+		if ( result ) {
+			WLAN_LOG_DEBUG(1,
+			"failed to restore wepflags=0x%04x, result=%d\n",
+			hw->presniff_wepflags,
+			result);
+			goto failed;
+		}
+
+		/* Set the port to its prior type and enable (if necessary) */
+		if (hw->presniff_port_type != 0 ) {
+			word = hw->presniff_port_type;
+			result = hfa384x_drvr_setconfig16(hw,
+				HFA384x_RID_CNFPORTTYPE, word);
+			if ( result ) {
+				WLAN_LOG_DEBUG(1,
+				"failed to restore porttype, result=%d\n",
+				result);
+				goto failed;
+			}
+
+			/* Enable the port */
+			result = hfa384x_drvr_enable(hw, 0);
+			if ( result ) {
+				WLAN_LOG_DEBUG(1, "failed to enable port to presniff setting, result=%d\n", result);
+				goto failed;
+			}
+		} else {
+			result = hfa384x_drvr_disable(hw, 0);
+
+		}
+
+		WLAN_LOG_INFO("monitor mode disabled\n");
+		msg->resultcode.data = P80211ENUM_resultcode_success;
+		result = 0;
+		goto exit;
+		break;
+	case P80211ENUM_truth_true:
+		/* Disable the port (if enabled), only check Port 0 */
+		if ( hw->port_enabled[0]) {
+			if (wlandev->netdev->type == ARPHRD_ETHER) {
+				/* Save macport 0 state */
+				result = hfa384x_drvr_getconfig16(hw,
+								  HFA384x_RID_CNFPORTTYPE,
+								  &(hw->presniff_port_type));
+				if ( result ) {
+					WLAN_LOG_DEBUG(1,"failed to read porttype, result=%d\n", result);
+					goto failed;
+				}
+				/* Save the wepflags state */
+				result = hfa384x_drvr_getconfig16(hw,
+								  HFA384x_RID_CNFWEPFLAGS,
+								  &(hw->presniff_wepflags));
+				if ( result ) {
+					WLAN_LOG_DEBUG(1,"failed to read wepflags, result=%d\n", result);
+					goto failed;
+				}
+				hfa384x_drvr_stop(hw);
+				result = hfa384x_drvr_start(hw);
+				if ( result ) {
+					WLAN_LOG_DEBUG(1,
+						       "failed to restart the card for sniffing, result=%d\n",
+						       result);
+					goto failed;
+				}
+			} else {
+				/* Disable the port */
+				result = hfa384x_drvr_disable(hw, 0);
+				if ( result ) {
+					WLAN_LOG_DEBUG(1,
+						       "failed to enable port for sniffing, result=%d\n",
+						       result);
+					goto failed;
+				}
+			}
+		} else {
+			hw->presniff_port_type = 0;
+		}
+
+		/* Set the channel we wish to sniff  */
+		word = msg->channel.data;
+		result = hfa384x_drvr_setconfig16(hw,
+						  HFA384x_RID_CNFOWNCHANNEL, word);
+		hw->sniff_channel=word;
+
+		if ( result ) {
+			WLAN_LOG_DEBUG(1,
+				       "failed to set channel %d, result=%d\n",
+					       word,
+				       result);
+			goto failed;
+		}
+
+		/* Now if we're already sniffing, we can skip the rest */
+		if (wlandev->netdev->type != ARPHRD_ETHER) {
+			/* Set the port type to pIbss */
+			word = HFA384x_PORTTYPE_PSUEDOIBSS;
+			result = hfa384x_drvr_setconfig16(hw,
+							  HFA384x_RID_CNFPORTTYPE, word);
+			if ( result ) {
+				WLAN_LOG_DEBUG(1,
+					       "failed to set porttype %d, result=%d\n",
+					       word,
+					       result);
+				goto failed;
+			}
+			if ((msg->keepwepflags.status == P80211ENUM_msgitem_status_data_ok) && (msg->keepwepflags.data != P80211ENUM_truth_true)) {
+				/* Set the wepflags for no decryption */
+				word = HFA384x_WEPFLAGS_DISABLE_TXCRYPT |
+					HFA384x_WEPFLAGS_DISABLE_RXCRYPT;
+				result = hfa384x_drvr_setconfig16(hw, HFA384x_RID_CNFWEPFLAGS, word);
+			}
+
+			if ( result ) {
+				WLAN_LOG_DEBUG(1,
+					       "failed to set wepflags=0x%04x, result=%d\n",
+					       word,
+					       result);
+				goto failed;
+			}
+		}
+
+		/* Do we want to strip the FCS in monitor mode? */
+		if ((msg->stripfcs.status == P80211ENUM_msgitem_status_data_ok) && (msg->stripfcs.data == P80211ENUM_truth_true)) {
+			hw->sniff_fcs = 0;
+		} else {
+			hw->sniff_fcs = 1;
+		}
+
+		/* Do we want to truncate the packets? */
+		if (msg->packet_trunc.status == P80211ENUM_msgitem_status_data_ok) {
+			hw->sniff_truncate = msg->packet_trunc.data;
+		} else {
+			hw->sniff_truncate = 0;
+		}
+
+		/* Enable the port */
+		result = hfa384x_drvr_enable(hw, 0);
+		if ( result ) {
+			WLAN_LOG_DEBUG(1,
+			"failed to enable port for sniffing, result=%d\n",
+			result);
+			goto failed;
+		}
+		/* Enable monitor mode */
+		result = hfa384x_cmd_monitor(hw, HFA384x_MONITOR_ENABLE);
+		if ( result ) {
+			WLAN_LOG_DEBUG(1,
+			"failed to enable monitor mode, result=%d\n",
+			result);
+			goto failed;
+		}
+
+		if (wlandev->netdev->type == ARPHRD_ETHER) {
+			WLAN_LOG_INFO("monitor mode enabled\n");
+		}
+
+		/* Set the driver state */
+		/* Do we want the prism2 header? */
+		if ((msg->prismheader.status == P80211ENUM_msgitem_status_data_ok) && (msg->prismheader.data == P80211ENUM_truth_true)) {
+			hw->sniffhdr = 0;
+			wlandev->netdev->type = ARPHRD_IEEE80211_PRISM;
+		} else if ((msg->wlanheader.status == P80211ENUM_msgitem_status_data_ok) && (msg->wlanheader.data == P80211ENUM_truth_true)) {
+			hw->sniffhdr = 1;
+			wlandev->netdev->type = ARPHRD_IEEE80211_PRISM;
+		} else {
+			wlandev->netdev->type = ARPHRD_IEEE80211;
+		}
+
+		msg->resultcode.data = P80211ENUM_resultcode_success;
+		result = 0;
+		goto exit;
+		break;
+	default:
+		msg->resultcode.data = P80211ENUM_resultcode_invalid_parameters;
+		result = 0;
+		goto exit;
+		break;
+	}
+
+failed:
+	msg->resultcode.data = P80211ENUM_resultcode_refused;
+	result = 0;
+exit:
+
+	DBFEXIT;
+	return result;
+}
