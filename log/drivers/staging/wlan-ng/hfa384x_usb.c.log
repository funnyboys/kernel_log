commit 1165dd73e811a07d947aee218510571f516081f6
Author: Qiujun Huang <hqjagain@gmail.com>
Date:   Thu Mar 26 21:18:50 2020 +0800

    staging: wlan-ng: fix use-after-free Read in hfa384x_usbin_callback
    
    We can't handle the case length > WLAN_DATA_MAXLEN.
    Because the size of rxfrm->data is WLAN_DATA_MAXLEN(2312), and we can't
    read more than that.
    
    Thanks-to: Hillf Danton <hdanton@sina.com>
    Reported-and-tested-by: syzbot+7d42d68643a35f71ac8a@syzkaller.appspotmail.com
    Signed-off-by: Qiujun Huang <hqjagain@gmail.com>
    Cc: stable <stable@vger.kernel.org>
    Link: https://lore.kernel.org/r/20200326131850.17711-1-hqjagain@gmail.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/hfa384x_usb.c b/drivers/staging/wlan-ng/hfa384x_usb.c
index e38acb58cd5e..fa1bf8b069fd 100644
--- a/drivers/staging/wlan-ng/hfa384x_usb.c
+++ b/drivers/staging/wlan-ng/hfa384x_usb.c
@@ -3376,6 +3376,8 @@ static void hfa384x_int_rxmonitor(struct wlandevice *wlandev,
 	     WLAN_HDR_A4_LEN + WLAN_DATA_MAXLEN + WLAN_CRC_LEN)) {
 		pr_debug("overlen frm: len=%zd\n",
 			 skblen - sizeof(struct p80211_caphdr));
+
+		return;
 	}
 
 	skb = dev_alloc_skb(skblen);

commit 759411a0e0f35c8ae1778a838a97cec9d0140f7f
Author: John B. Wyatt IV <jbwyatt4@gmail.com>
Date:   Sat Mar 21 15:58:08 2020 -0700

    staging: wlan-ng: Fix third argument going over 80 characters
    
    Create a new 'status' variable to store the value of a long argument
    that goes over 80 characters. The status variable is also used for
    an if check. Replacing that long statement in both places makes the
    code much easier to read.
    
    Note: the status variable is assigned after a needed byte order
    conversion for usbin->rxfrm.desc.status, which uses a reference.
    
    Issue reported by checkpatch.
    
    Suggested-by: Stefano Brivio <sbrivio@redhat.com>
    Signed-off-by: John B. Wyatt IV <jbwyatt4@gmail.com>
    Reviewed-by: Stefano Brivio <sbrivio@redhat.com>
    Link: https://lore.kernel.org/r/20200321225808.2494564-1-jbwyatt4@gmail.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/hfa384x_usb.c b/drivers/staging/wlan-ng/hfa384x_usb.c
index f8485601aead..e38acb58cd5e 100644
--- a/drivers/staging/wlan-ng/hfa384x_usb.c
+++ b/drivers/staging/wlan-ng/hfa384x_usb.c
@@ -3254,13 +3254,16 @@ static void hfa384x_usbin_rx(struct wlandevice *wlandev, struct sk_buff *skb)
 	struct p80211_rxmeta *rxmeta;
 	u16 data_len;
 	u16 fc;
+	u16 status;
 
 	/* Byte order convert once up front. */
 	le16_to_cpus(&usbin->rxfrm.desc.status);
 	le32_to_cpus(&usbin->rxfrm.desc.time);
 
 	/* Now handle frame based on port# */
-	switch (HFA384x_RXSTATUS_MACPORT_GET(usbin->rxfrm.desc.status)) {
+	status = HFA384x_RXSTATUS_MACPORT_GET(usbin->rxfrm.desc.status);
+
+	switch (status) {
 	case 0:
 		fc = le16_to_cpu(usbin->rxfrm.desc.frame_control);
 
@@ -3319,7 +3322,7 @@ static void hfa384x_usbin_rx(struct wlandevice *wlandev, struct sk_buff *skb)
 	default:
 		netdev_warn(hw->wlandev->netdev,
 			    "Received frame on unsupported port=%d\n",
-			    HFA384x_RXSTATUS_MACPORT_GET(usbin->rxfrm.desc.status));
+			    status);
 		break;
 	}
 }

commit 928b2dc0c899d3335a54704ba0ec2f0cf7bf7356
Author: John B. Wyatt IV <jbwyatt4@gmail.com>
Date:   Mon Mar 16 15:15:44 2020 -0700

    staging: wlan-ng: Fix line going over 80 characters
    
    Add a newline before the second argument for style, readability, and
    consistency.
    
    Please note: checkpatch reports the third argument as being over 80
    characters, but not the second argument.
    
    Signed-off-by: John B. Wyatt IV <jbwyatt4@gmail.com>
    Link: https://lore.kernel.org/r/20200316221544.1251350-1-jbwyatt4@gmail.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/hfa384x_usb.c b/drivers/staging/wlan-ng/hfa384x_usb.c
index b71756ab0394..f8485601aead 100644
--- a/drivers/staging/wlan-ng/hfa384x_usb.c
+++ b/drivers/staging/wlan-ng/hfa384x_usb.c
@@ -3317,7 +3317,8 @@ static void hfa384x_usbin_rx(struct wlandevice *wlandev, struct sk_buff *skb)
 		break;
 
 	default:
-		netdev_warn(hw->wlandev->netdev, "Received frame on unsupported port=%d\n",
+		netdev_warn(hw->wlandev->netdev,
+			    "Received frame on unsupported port=%d\n",
 			    HFA384x_RXSTATUS_MACPORT_GET(usbin->rxfrm.desc.status));
 		break;
 	}

commit bbf358ec1bd6e57c899e6c28623da1c24ca4b951
Author: Tim Collier <osdevtc@gmail.com>
Date:   Fri Oct 25 09:41:25 2019 +0100

    staging: wlan-ng: fix compilation for USB debugging
    
    Fix compilation errors (remove references to 2 undefined fields in the
    URB struct) when DEBUG_USB is defined for the wlan-ng driver.
    
    Signed-off-by: Tim Collier <osdevtc@gmail.com>
    Link: https://lore.kernel.org/r/20191025084126.9181-5-osdevtc@gmail.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/hfa384x_usb.c b/drivers/staging/wlan-ng/hfa384x_usb.c
index 28d372a0663a..b71756ab0394 100644
--- a/drivers/staging/wlan-ng/hfa384x_usb.c
+++ b/drivers/staging/wlan-ng/hfa384x_usb.c
@@ -293,13 +293,11 @@ void dbprint_urb(struct urb *urb)
 	pr_debug("urb->transfer_buffer_length=0x%08x\n",
 		 urb->transfer_buffer_length);
 	pr_debug("urb->actual_length=0x%08x\n", urb->actual_length);
-	pr_debug("urb->bandwidth=0x%08x\n", urb->bandwidth);
 	pr_debug("urb->setup_packet(ctl)=0x%08x\n",
 		 (unsigned int)urb->setup_packet);
 	pr_debug("urb->start_frame(iso/irq)=0x%08x\n", urb->start_frame);
 	pr_debug("urb->interval(irq)=0x%08x\n", urb->interval);
 	pr_debug("urb->error_count(iso)=0x%08x\n", urb->error_count);
-	pr_debug("urb->timeout=0x%08x\n", urb->timeout);
 	pr_debug("urb->context=0x%08x\n", (unsigned int)urb->context);
 	pr_debug("urb->complete=0x%08x\n", (unsigned int)urb->complete);
 }

commit 68336404aa5123401133c9433a8c91e4b96322e6
Author: Nishka Dasgupta <nishkadg.linux@gmail.com>
Date:   Fri Jul 12 11:58:07 2019 +0530

    staging: wlan-ng: Replace function hfa384x_dowmem()
    
    Remove parameters mode, cmdcb, usercb, and usercb_data from
    hfa384x_dowmem as these parameters are only assigned the same constant
    values (DOWAIT, NULL, NULL, NULL respectively).
    Modify hfa384x_dowmem to use these constants directly. Remove check for
    value of mode (as it will always be DOWAIT).
    Remove function hfa384x_dowmem_wait as it does nothing except call
    hfa384x_dowmem with these extra arguments.
    Modify call sites of hfa384x_dowmem_wait to call hfa384x_dowmem instead.
    Issue found with Coccinelle.
    
    Signed-off-by: Nishka Dasgupta <nishkadg.linux@gmail.com>
    Link: https://lore.kernel.org/r/20190712062807.9361-10-nishkadg.linux@gmail.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/hfa384x_usb.c b/drivers/staging/wlan-ng/hfa384x_usb.c
index 9be06a33268c..28d372a0663a 100644
--- a/drivers/staging/wlan-ng/hfa384x_usb.c
+++ b/drivers/staging/wlan-ng/hfa384x_usb.c
@@ -255,12 +255,10 @@ hfa384x_dormem(struct hfa384x *hw,
 
 static int
 hfa384x_dowmem(struct hfa384x *hw,
-	       enum cmd_mode mode,
 	       u16 page,
 	       u16 offset,
 	       void *data,
-	       unsigned int len,
-	       ctlx_cmdcb_t cmdcb, ctlx_usercb_t usercb, void *usercb_data);
+	       unsigned int len);
 
 static int hfa384x_isgood_pdrcode(u16 pdrcode);
 
@@ -816,14 +814,6 @@ static void hfa384x_cb_status(struct hfa384x *hw,
 	}
 }
 
-static inline int
-hfa384x_dowmem_wait(struct hfa384x *hw,
-		    u16 page, u16 offset, void *data, unsigned int len)
-{
-	return hfa384x_dowmem(hw, DOWAIT,
-			      page, offset, data, len, NULL, NULL, NULL);
-}
-
 /*----------------------------------------------------------------
  * hfa384x_cmd_initialize
  *
@@ -1529,14 +1519,10 @@ hfa384x_dormem(struct hfa384x *hw,
  *
  * Arguments:
  *	hw		device structure
- *	mode		DOWAIT or DOASYNC
  *	page		MAC address space page (CMD format)
  *	offset		MAC address space offset
  *	data		Ptr to data buffer containing write data
  *	len		Length of the data to read (max == 2048)
- *	cmdcb		command callback for async calls, NULL for DOWAIT calls
- *	usercb		user callback for async calls, NULL for DOWAIT calls
- *	usercb_data	user supplied data pointer for async calls.
  *
  * Returns:
  *	0		success
@@ -1549,17 +1535,15 @@ hfa384x_dormem(struct hfa384x *hw,
  *
  * Call context:
  *	interrupt (DOWAIT)
- *	process (DOWAIT or DOASYNC)
+ *	process (DOWAIT)
  *----------------------------------------------------------------
  */
 static int
 hfa384x_dowmem(struct hfa384x *hw,
-	       enum cmd_mode mode,
 	       u16 page,
 	       u16 offset,
 	       void *data,
-	       unsigned int len,
-	       ctlx_cmdcb_t cmdcb, ctlx_usercb_t usercb, void *usercb_data)
+	       unsigned int len)
 {
 	int result;
 	struct hfa384x_usbctlx *ctlx;
@@ -1586,15 +1570,15 @@ hfa384x_dowmem(struct hfa384x *hw,
 	    sizeof(ctlx->outbuf.wmemreq.offset) +
 	    sizeof(ctlx->outbuf.wmemreq.page) + len;
 
-	ctlx->reapable = mode;
-	ctlx->cmdcb = cmdcb;
-	ctlx->usercb = usercb;
-	ctlx->usercb_data = usercb_data;
+	ctlx->reapable = DOWAIT;
+	ctlx->cmdcb = NULL;
+	ctlx->usercb = NULL;
+	ctlx->usercb_data = NULL;
 
 	result = hfa384x_usbctlx_submit(hw, ctlx);
 	if (result != 0) {
 		kfree(ctlx);
-	} else if (mode == DOWAIT) {
+	} else {
 		struct usbctlx_cmd_completor completor;
 		struct hfa384x_cmdresult wmemresult;
 
@@ -1901,10 +1885,10 @@ int hfa384x_drvr_flashdl_write(struct hfa384x *hw, u32 daddr,
 			writelen = writelen > HFA384x_USB_RWMEM_MAXLEN ?
 			    HFA384x_USB_RWMEM_MAXLEN : writelen;
 
-			result = hfa384x_dowmem_wait(hw,
-						     writepage,
-						     writeoffset,
-						     writebuf, writelen);
+			result = hfa384x_dowmem(hw,
+						writepage,
+						writeoffset,
+						writebuf, writelen);
 		}
 
 		/* set the download 'write flash' mode */
@@ -2158,12 +2142,11 @@ int hfa384x_drvr_ramdl_write(struct hfa384x *hw, u32 daddr, void *buf, u32 len)
 			currlen = HFA384x_USB_RWMEM_MAXLEN;
 
 		/* Do blocking ctlx */
-		result = hfa384x_dowmem_wait(hw,
-					     currpage,
-					     curroffset,
-					     data +
-					     (i * HFA384x_USB_RWMEM_MAXLEN),
-					     currlen);
+		result = hfa384x_dowmem(hw,
+					currpage,
+					curroffset,
+					data + (i * HFA384x_USB_RWMEM_MAXLEN),
+					currlen);
 
 		if (result)
 			break;

commit 28c03f82607730901830170259a4a17b33d5152e
Author: Nishka Dasgupta <nishkadg.linux@gmail.com>
Date:   Fri Jul 12 11:58:06 2019 +0530

    staging: wlan-ng: Replace function hfa384x_dormem()
    
    Remove parameters mode, cmdcb, usercb, and usercb_data from
    hfa384x_dormem as these parameters are only assigned the same constant
    values (DOWAIT, NULL, NULL, NULL respectively).
    Modify hfa384x_dormem to use these constants directly. Remove check for
    value of mode (as it will always be DOWAIT).
    Remove function hfa384x_dormem_wait as it does nothing except call
    hfa384x_dormem with these extra arguments.
    Modify call sites of hfa384x_dormem_wait to call hfa384x_dormem instead.
    Issue found with Coccinelle.
    
    Signed-off-by: Nishka Dasgupta <nishkadg.linux@gmail.com>
    Link: https://lore.kernel.org/r/20190712062807.9361-9-nishkadg.linux@gmail.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/hfa384x_usb.c b/drivers/staging/wlan-ng/hfa384x_usb.c
index c469b89948e6..9be06a33268c 100644
--- a/drivers/staging/wlan-ng/hfa384x_usb.c
+++ b/drivers/staging/wlan-ng/hfa384x_usb.c
@@ -248,12 +248,10 @@ hfa384x_dowrid(struct hfa384x *hw,
 
 static int
 hfa384x_dormem(struct hfa384x *hw,
-	       enum cmd_mode mode,
 	       u16 page,
 	       u16 offset,
 	       void *data,
-	       unsigned int len,
-	       ctlx_cmdcb_t cmdcb, ctlx_usercb_t usercb, void *usercb_data);
+	       unsigned int len);
 
 static int
 hfa384x_dowmem(struct hfa384x *hw,
@@ -818,14 +816,6 @@ static void hfa384x_cb_status(struct hfa384x *hw,
 	}
 }
 
-static inline int
-hfa384x_dormem_wait(struct hfa384x *hw,
-		    u16 page, u16 offset, void *data, unsigned int len)
-{
-	return hfa384x_dormem(hw, DOWAIT,
-			      page, offset, data, len, NULL, NULL, NULL);
-}
-
 static inline int
 hfa384x_dowmem_wait(struct hfa384x *hw,
 		    u16 page, u16 offset, void *data, unsigned int len)
@@ -1454,14 +1444,10 @@ hfa384x_dowrid(struct hfa384x *hw,
  *
  * Arguments:
  *	hw		device structure
- *	mode		DOWAIT or DOASYNC
  *	page		MAC address space page (CMD format)
  *	offset		MAC address space offset
  *	data		Ptr to data buffer to receive read
  *	len		Length of the data to read (max == 2048)
- *	cmdcb		command callback for async calls, NULL for DOWAIT calls
- *	usercb		user callback for async calls, NULL for DOWAIT calls
- *	usercb_data	user supplied data pointer for async calls
  *
  * Returns:
  *	0		success
@@ -1473,18 +1459,15 @@ hfa384x_dowrid(struct hfa384x *hw,
  * Side effects:
  *
  * Call context:
- *	interrupt (DOASYNC)
- *	process (DOWAIT or DOASYNC)
+ *	process (DOWAIT)
  *----------------------------------------------------------------
  */
 static int
 hfa384x_dormem(struct hfa384x *hw,
-	       enum cmd_mode mode,
 	       u16 page,
 	       u16 offset,
 	       void *data,
-	       unsigned int len,
-	       ctlx_cmdcb_t cmdcb, ctlx_usercb_t usercb, void *usercb_data)
+	       unsigned int len)
 {
 	int result;
 	struct hfa384x_usbctlx *ctlx;
@@ -1512,15 +1495,15 @@ hfa384x_dormem(struct hfa384x *hw,
 
 	pr_debug("pktsize=%zd\n", ROUNDUP64(sizeof(ctlx->outbuf.rmemreq)));
 
-	ctlx->reapable = mode;
-	ctlx->cmdcb = cmdcb;
-	ctlx->usercb = usercb;
-	ctlx->usercb_data = usercb_data;
+	ctlx->reapable = DOWAIT;
+	ctlx->cmdcb = NULL;
+	ctlx->usercb = NULL;
+	ctlx->usercb_data = NULL;
 
 	result = hfa384x_usbctlx_submit(hw, ctlx);
 	if (result != 0) {
 		kfree(ctlx);
-	} else if (mode == DOWAIT) {
+	} else {
 		struct usbctlx_rmem_completor completor;
 
 		result =
@@ -2252,8 +2235,8 @@ int hfa384x_drvr_readpda(struct hfa384x *hw, void *buf, unsigned int len)
 		curroffset = HFA384x_ADDR_CMD_MKOFF(pdaloc[i].cardaddr);
 
 		/* units of bytes */
-		result = hfa384x_dormem_wait(hw, currpage, curroffset, buf,
-					     len);
+		result = hfa384x_dormem(hw, currpage, curroffset, buf,
+					len);
 
 		if (result) {
 			netdev_warn(hw->wlandev->netdev,

commit 53055d6a915cb1753334dc18d6249f8b4ac62d88
Author: Nishka Dasgupta <nishkadg.linux@gmail.com>
Date:   Fri Jul 12 11:58:05 2019 +0530

    staging: wlan-ng: Remove function hfa384x_docmd_wait()
    
    As hfa384x_docmd is only called by hfa384x_docmd_wait, and
    hfa384x_docmd_wait always passes 4 constant arguments (DOWAIT,
    NULL, NULL, NULL) to hfa384x_docmd, these constant parameters may be
    removed from hfa384x_docmd and their values used directly instead.
    Remove check for one of these constant parameters of hfa384x_docmd as
    it is no longer necessary.
    Remove hfa384x_docmd_wait as it does nothing except call hfa384x_docmd.
    Modify call sites of hfa384x_docmd_wait to call hfa384x_docmd instead.
    Change type of hfa384x_docmd to inline to match type of former
    hfa384x_docmd_wait.
    Issue found with Coccinelle.
    
    Signed-off-by: Nishka Dasgupta <nishkadg.linux@gmail.com>
    Link: https://lore.kernel.org/r/20190712062807.9361-8-nishkadg.linux@gmail.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/hfa384x_usb.c b/drivers/staging/wlan-ng/hfa384x_usb.c
index ce1a9ee995a0..c469b89948e6 100644
--- a/drivers/staging/wlan-ng/hfa384x_usb.c
+++ b/drivers/staging/wlan-ng/hfa384x_usb.c
@@ -226,11 +226,9 @@ usbctlx_get_rridresult(const struct hfa384x_usb_rridresp *rridresp,
 
 /*---------------------------------------------------*/
 /* Low level req/resp CTLX formatters and submitters */
-static int
+static inline int
 hfa384x_docmd(struct hfa384x *hw,
-	      enum cmd_mode mode,
-	      struct hfa384x_metacmd *cmd,
-	      ctlx_cmdcb_t cmdcb, ctlx_usercb_t usercb, void *usercb_data);
+	      struct hfa384x_metacmd *cmd);
 
 static int
 hfa384x_dorrid(struct hfa384x *hw,
@@ -820,12 +818,6 @@ static void hfa384x_cb_status(struct hfa384x *hw,
 	}
 }
 
-static inline int hfa384x_docmd_wait(struct hfa384x *hw,
-				     struct hfa384x_metacmd *cmd)
-{
-	return hfa384x_docmd(hw, DOWAIT, cmd, NULL, NULL, NULL);
-}
-
 static inline int
 hfa384x_dormem_wait(struct hfa384x *hw,
 		    u16 page, u16 offset, void *data, unsigned int len)
@@ -873,7 +865,7 @@ int hfa384x_cmd_initialize(struct hfa384x *hw)
 	cmd.parm1 = 0;
 	cmd.parm2 = 0;
 
-	result = hfa384x_docmd_wait(hw, &cmd);
+	result = hfa384x_docmd(hw, &cmd);
 
 	pr_debug("cmdresp.init: status=0x%04x, resp0=0x%04x, resp1=0x%04x, resp2=0x%04x\n",
 		 cmd.result.status,
@@ -919,7 +911,7 @@ int hfa384x_cmd_disable(struct hfa384x *hw, u16 macport)
 	cmd.parm1 = 0;
 	cmd.parm2 = 0;
 
-	return hfa384x_docmd_wait(hw, &cmd);
+	return hfa384x_docmd(hw, &cmd);
 }
 
 /*----------------------------------------------------------------
@@ -953,7 +945,7 @@ int hfa384x_cmd_enable(struct hfa384x *hw, u16 macport)
 	cmd.parm1 = 0;
 	cmd.parm2 = 0;
 
-	return hfa384x_docmd_wait(hw, &cmd);
+	return hfa384x_docmd(hw, &cmd);
 }
 
 /*----------------------------------------------------------------
@@ -996,7 +988,7 @@ int hfa384x_cmd_monitor(struct hfa384x *hw, u16 enable)
 	cmd.parm1 = 0;
 	cmd.parm2 = 0;
 
-	return hfa384x_docmd_wait(hw, &cmd);
+	return hfa384x_docmd(hw, &cmd);
 }
 
 /*----------------------------------------------------------------
@@ -1053,7 +1045,7 @@ int hfa384x_cmd_download(struct hfa384x *hw, u16 mode, u16 lowaddr,
 	cmd.parm1 = highaddr;
 	cmd.parm2 = codelen;
 
-	return hfa384x_docmd_wait(hw, &cmd);
+	return hfa384x_docmd(hw, &cmd);
 }
 
 /*----------------------------------------------------------------
@@ -1213,13 +1205,8 @@ static int hfa384x_usbctlx_complete_sync(struct hfa384x *hw,
  *
  * Arguments:
  *	hw		device structure
- *	mode		DOWAIT or DOASYNC
  *       cmd             cmd structure.  Includes all arguments and result
  *                       data points.  All in host order. in host order
- *	cmdcb		command-specific callback
- *	usercb		user callback for async calls, NULL for DOWAIT calls
- *	usercb_data	user supplied data pointer for async calls, NULL
- *			for DOWAIT calls
  *
  * Returns:
  *	0		success
@@ -1235,11 +1222,9 @@ static int hfa384x_usbctlx_complete_sync(struct hfa384x *hw,
  *	process
  *----------------------------------------------------------------
  */
-static int
+static inline int
 hfa384x_docmd(struct hfa384x *hw,
-	      enum cmd_mode mode,
-	      struct hfa384x_metacmd *cmd,
-	      ctlx_cmdcb_t cmdcb, ctlx_usercb_t usercb, void *usercb_data)
+	      struct hfa384x_metacmd *cmd)
 {
 	int result;
 	struct hfa384x_usbctlx *ctlx;
@@ -1262,15 +1247,15 @@ hfa384x_docmd(struct hfa384x *hw,
 	pr_debug("cmdreq: cmd=0x%04x parm0=0x%04x parm1=0x%04x parm2=0x%04x\n",
 		 cmd->cmd, cmd->parm0, cmd->parm1, cmd->parm2);
 
-	ctlx->reapable = mode;
-	ctlx->cmdcb = cmdcb;
-	ctlx->usercb = usercb;
-	ctlx->usercb_data = usercb_data;
+	ctlx->reapable = DOWAIT;
+	ctlx->cmdcb = NULL;
+	ctlx->usercb = NULL;
+	ctlx->usercb_data = NULL;
 
 	result = hfa384x_usbctlx_submit(hw, ctlx);
 	if (result != 0) {
 		kfree(ctlx);
-	} else if (mode == DOWAIT) {
+	} else {
 		struct usbctlx_cmd_completor cmd_completor;
 		struct usbctlx_completor *completor;
 

commit aef29ca497f005fe3cd38aefc77639dc551bbd18
Author: Nishka Dasgupta <nishkadg.linux@gmail.com>
Date:   Fri Jul 12 11:58:04 2019 +0530

    staging: wlan-ng: Remove unused function hfa384x_docmd_async()
    
    Remove unused function hfa384x_docmd_async.
    Issue found with Coccinelle.
    
    Signed-off-by: Nishka Dasgupta <nishkadg.linux@gmail.com>
    Link: https://lore.kernel.org/r/20190712062807.9361-7-nishkadg.linux@gmail.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/hfa384x_usb.c b/drivers/staging/wlan-ng/hfa384x_usb.c
index 20ac2dbd8a00..ce1a9ee995a0 100644
--- a/drivers/staging/wlan-ng/hfa384x_usb.c
+++ b/drivers/staging/wlan-ng/hfa384x_usb.c
@@ -826,14 +826,6 @@ static inline int hfa384x_docmd_wait(struct hfa384x *hw,
 	return hfa384x_docmd(hw, DOWAIT, cmd, NULL, NULL, NULL);
 }
 
-static inline int
-hfa384x_docmd_async(struct hfa384x *hw,
-		    struct hfa384x_metacmd *cmd,
-		    ctlx_cmdcb_t cmdcb, ctlx_usercb_t usercb, void *usercb_data)
-{
-	return hfa384x_docmd(hw, DOASYNC, cmd, cmdcb, usercb, usercb_data);
-}
-
 static inline int
 hfa384x_dormem_wait(struct hfa384x *hw,
 		    u16 page, u16 offset, void *data, unsigned int len)

commit 71b289cc5aa6b3bbe7e1a87612037b2c5bae9649
Author: Nishka Dasgupta <nishkadg.linux@gmail.com>
Date:   Fri Jul 12 11:58:03 2019 +0530

    staging: wlan-ng: Remove function hfa384x_dowmem_async()
    
    Remove unused function hfa384x_dowmem_async.
    Issue found with Coccinelle.
    
    Signed-off-by: Nishka Dasgupta <nishkadg.linux@gmail.com>
    Link: https://lore.kernel.org/r/20190712062807.9361-6-nishkadg.linux@gmail.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/hfa384x_usb.c b/drivers/staging/wlan-ng/hfa384x_usb.c
index 95dae0b271fc..20ac2dbd8a00 100644
--- a/drivers/staging/wlan-ng/hfa384x_usb.c
+++ b/drivers/staging/wlan-ng/hfa384x_usb.c
@@ -850,20 +850,6 @@ hfa384x_dowmem_wait(struct hfa384x *hw,
 			      page, offset, data, len, NULL, NULL, NULL);
 }
 
-static inline int
-hfa384x_dowmem_async(struct hfa384x *hw,
-		     u16 page,
-		     u16 offset,
-		     void *data,
-		     unsigned int len,
-		     ctlx_cmdcb_t cmdcb,
-		     ctlx_usercb_t usercb, void *usercb_data)
-{
-	return hfa384x_dowmem(hw, DOASYNC,
-			      page, offset, data, len,
-			      cmdcb, usercb, usercb_data);
-}
-
 /*----------------------------------------------------------------
  * hfa384x_cmd_initialize
  *

commit f2a82b0941ea0075fa402792ea8bc9c6c5db7bfe
Author: Nishka Dasgupta <nishkadg.linux@gmail.com>
Date:   Fri Jul 12 11:58:02 2019 +0530

    staging: wlan-ng: Remove unused function hfa384x_dormem_async()
    
    Remove unused function hfa384x_dormem_async.
    Issue found with Coccinelle.
    
    Signed-off-by: Nishka Dasgupta <nishkadg.linux@gmail.com>
    Link: https://lore.kernel.org/r/20190712062807.9361-5-nishkadg.linux@gmail.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/hfa384x_usb.c b/drivers/staging/wlan-ng/hfa384x_usb.c
index c1a315bf5a81..95dae0b271fc 100644
--- a/drivers/staging/wlan-ng/hfa384x_usb.c
+++ b/drivers/staging/wlan-ng/hfa384x_usb.c
@@ -842,17 +842,6 @@ hfa384x_dormem_wait(struct hfa384x *hw,
 			      page, offset, data, len, NULL, NULL, NULL);
 }
 
-static inline int
-hfa384x_dormem_async(struct hfa384x *hw,
-		     u16 page, u16 offset, void *data, unsigned int len,
-		     ctlx_cmdcb_t cmdcb,
-		     ctlx_usercb_t usercb, void *usercb_data)
-{
-	return hfa384x_dormem(hw, DOASYNC,
-			      page, offset, data, len,
-			      cmdcb, usercb, usercb_data);
-}
-
 static inline int
 hfa384x_dowmem_wait(struct hfa384x *hw,
 		    u16 page, u16 offset, void *data, unsigned int len)

commit bb75c586cabd0d192b9e713143f49b44112e64cb
Author: Nishka Dasgupta <nishkadg.linux@gmail.com>
Date:   Fri Jul 12 11:58:01 2019 +0530

    staging: wlan-ng: Remove unused function hfa384x_dorrid_async()
    
    Remove unused function hfa384x_dorrid_async.
    
    Signed-off-by: Nishka Dasgupta <nishkadg.linux@gmail.com>
    Link: https://lore.kernel.org/r/20190712062807.9361-4-nishkadg.linux@gmail.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/hfa384x_usb.c b/drivers/staging/wlan-ng/hfa384x_usb.c
index 732ffb6aab0b..c1a315bf5a81 100644
--- a/drivers/staging/wlan-ng/hfa384x_usb.c
+++ b/drivers/staging/wlan-ng/hfa384x_usb.c
@@ -834,17 +834,6 @@ hfa384x_docmd_async(struct hfa384x *hw,
 	return hfa384x_docmd(hw, DOASYNC, cmd, cmdcb, usercb, usercb_data);
 }
 
-static inline int
-hfa384x_dorrid_async(struct hfa384x *hw,
-		     u16 rid, void *riddata, unsigned int riddatalen,
-		     ctlx_cmdcb_t cmdcb,
-		     ctlx_usercb_t usercb, void *usercb_data)
-{
-	return hfa384x_dorrid(hw, DOASYNC,
-			      rid, riddata, riddatalen,
-			      cmdcb, usercb, usercb_data);
-}
-
 static inline int
 hfa384x_dormem_wait(struct hfa384x *hw,
 		    u16 page, u16 offset, void *data, unsigned int len)

commit 57d100b8aa686ce7bccc74e702aa1f3e8051d518
Author: Nishka Dasgupta <nishkadg.linux@gmail.com>
Date:   Fri Jul 12 11:58:00 2019 +0530

    staging: wlan-ng: Remove function hfa384x_dowrid_async()
    
    Remove function hfa384x_dowrid_async as it does nothing except call
    hfa384x_dowrid, and itself is called only once.
    Move the contents of hfa384x_dowrid_async (i.e the call to
    hfa384x_dowrid) to its call site.
    Issue found with Coccinelle.
    
    Signed-off-by: Nishka Dasgupta <nishkadg.linux@gmail.com>
    Link: https://lore.kernel.org/r/20190712062807.9361-3-nishkadg.linux@gmail.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/hfa384x_usb.c b/drivers/staging/wlan-ng/hfa384x_usb.c
index dc6abc654165..732ffb6aab0b 100644
--- a/drivers/staging/wlan-ng/hfa384x_usb.c
+++ b/drivers/staging/wlan-ng/hfa384x_usb.c
@@ -845,17 +845,6 @@ hfa384x_dorrid_async(struct hfa384x *hw,
 			      cmdcb, usercb, usercb_data);
 }
 
-static inline int
-hfa384x_dowrid_async(struct hfa384x *hw,
-		     u16 rid, void *riddata, unsigned int riddatalen,
-		     ctlx_cmdcb_t cmdcb,
-		     ctlx_usercb_t usercb, void *usercb_data)
-{
-	return hfa384x_dowrid(hw, DOASYNC,
-			      rid, riddata, riddatalen,
-			      cmdcb, usercb, usercb_data);
-}
-
 static inline int
 hfa384x_dormem_wait(struct hfa384x *hw,
 		    u16 page, u16 offset, void *data, unsigned int len)
@@ -2078,8 +2067,8 @@ hfa384x_drvr_setconfig_async(struct hfa384x *hw,
 			     void *buf,
 			     u16 len, ctlx_usercb_t usercb, void *usercb_data)
 {
-	return hfa384x_dowrid_async(hw, rid, buf, len,
-				    hfa384x_cb_status, usercb, usercb_data);
+	return hfa384x_dowrid(hw, DOASYNC, rid, buf, len, hfa384x_cb_status,
+			      usercb, usercb_data);
 }
 
 /*----------------------------------------------------------------

commit 83c23c8e79ee85c0e7f71844a50aab0c1156a788
Author: Nishka Dasgupta <nishkadg.linux@gmail.com>
Date:   Fri Jul 12 11:57:59 2019 +0530

    staging: wlan-ng: Remove function hfa384x_dowrid_wait()
    
    Remove inline function hfa384x_dowrid_wait as it is only called once (in
    hfa384x_drvr_setconfig) and its contents are only a single line (a call
    to hfa384x_dowrid).
    Replace the call to hfa384x_dowrid_wait with its contents i.e the call
    to hfa384x_dowrid.
    Issue found with Coccinelle.
    
    Signed-off-by: Nishka Dasgupta <nishkadg.linux@gmail.com>
    Link: https://lore.kernel.org/r/20190712062807.9361-2-nishkadg.linux@gmail.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/hfa384x_usb.c b/drivers/staging/wlan-ng/hfa384x_usb.c
index 4befc615d8e2..dc6abc654165 100644
--- a/drivers/staging/wlan-ng/hfa384x_usb.c
+++ b/drivers/staging/wlan-ng/hfa384x_usb.c
@@ -845,14 +845,6 @@ hfa384x_dorrid_async(struct hfa384x *hw,
 			      cmdcb, usercb, usercb_data);
 }
 
-static inline int
-hfa384x_dowrid_wait(struct hfa384x *hw, u16 rid, void *riddata,
-		    unsigned int riddatalen)
-{
-	return hfa384x_dowrid(hw, DOWAIT,
-			      rid, riddata, riddatalen, NULL, NULL, NULL);
-}
-
 static inline int
 hfa384x_dowrid_async(struct hfa384x *hw,
 		     u16 rid, void *riddata, unsigned int riddatalen,
@@ -2414,7 +2406,7 @@ int hfa384x_drvr_readpda(struct hfa384x *hw, void *buf, unsigned int len)
  */
 int hfa384x_drvr_setconfig(struct hfa384x *hw, u16 rid, void *buf, u16 len)
 {
-	return hfa384x_dowrid_wait(hw, rid, buf, len);
+	return hfa384x_dowrid(hw, DOWAIT, rid, buf, len, NULL, NULL, NULL);
 }
 
 /*----------------------------------------------------------------

commit 72da91bc590a3a789b2130718c9dc810851273fe
Author: Nishka Dasgupta <nishkadg.linux@gmail.com>
Date:   Fri Jul 12 11:57:58 2019 +0530

    staging: wlan-ng: Remove function hfa384x_dorrid_wait()
    
    Remove function hfa384x_dorrid_wait as it is only called once and it
    does nothing except call hfa384x_dorrid.
    Move contents of hfa384x_dorrid_wait to its only call site to maintain
    functionality.
    Issue found with Coccinelle.
    
    Signed-off-by: Nishka Dasgupta <nishkadg.linux@gmail.com>
    Link: https://lore.kernel.org/r/20190712062807.9361-1-nishkadg.linux@gmail.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/hfa384x_usb.c b/drivers/staging/wlan-ng/hfa384x_usb.c
index ab734534093b..4befc615d8e2 100644
--- a/drivers/staging/wlan-ng/hfa384x_usb.c
+++ b/drivers/staging/wlan-ng/hfa384x_usb.c
@@ -834,14 +834,6 @@ hfa384x_docmd_async(struct hfa384x *hw,
 	return hfa384x_docmd(hw, DOASYNC, cmd, cmdcb, usercb, usercb_data);
 }
 
-static inline int
-hfa384x_dorrid_wait(struct hfa384x *hw, u16 rid, void *riddata,
-		    unsigned int riddatalen)
-{
-	return hfa384x_dorrid(hw, DOWAIT,
-			      rid, riddata, riddatalen, NULL, NULL, NULL);
-}
-
 static inline int
 hfa384x_dorrid_async(struct hfa384x *hw,
 		     u16 rid, void *riddata, unsigned int riddatalen,
@@ -2061,7 +2053,7 @@ int hfa384x_drvr_flashdl_write(struct hfa384x *hw, u32 daddr,
  */
 int hfa384x_drvr_getconfig(struct hfa384x *hw, u16 rid, void *buf, u16 len)
 {
-	return hfa384x_dorrid_wait(hw, rid, buf, len);
+	return hfa384x_dorrid(hw, DOWAIT, rid, buf, len, NULL, NULL, NULL);
 }
 
 /*----------------------------------------------------------------

commit a67fedd788182764dc8ed59037c604b7e60349f1
Author: Tim Collier <osdevtc@gmail.com>
Date:   Sat May 11 18:40:46 2019 +0100

    staging: wlan-ng: fix adapter initialization failure
    
    Commit e895f00a8496 ("Staging: wlan-ng: hfa384x_usb.c Fixed too long
    code line warnings.") moved the retrieval of the transfer buffer from
    the URB from the top of function hfa384x_usbin_callback to a point
    after reposting of the URB via a call to submit_rx_urb. The reposting
    of the URB allocates a new transfer buffer so the new buffer is
    retrieved instead of the buffer containing the response passed into
    the callback. This results in failure to initialize the adapter with
    an error reported in the system log (something like "CTLX[1] error:
    state(Request failed)").
    
    This change moves the retrieval to just before the point where the URB
    is reposted so that the correct transfer buffer is retrieved and
    initialization of the device succeeds.
    
    Signed-off-by: Tim Collier <osdevtc@gmail.com>
    Fixes: e895f00a8496 ("Staging: wlan-ng: hfa384x_usb.c Fixed too long code line warnings.")
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/hfa384x_usb.c b/drivers/staging/wlan-ng/hfa384x_usb.c
index 6fde75d4f064..ab734534093b 100644
--- a/drivers/staging/wlan-ng/hfa384x_usb.c
+++ b/drivers/staging/wlan-ng/hfa384x_usb.c
@@ -3119,7 +3119,9 @@ static void hfa384x_usbin_callback(struct urb *urb)
 		break;
 	}
 
+	/* Save values from the RX URB before reposting overwrites it. */
 	urb_status = urb->status;
+	usbin = (union hfa384x_usbin *)urb->transfer_buffer;
 
 	if (action != ABORT) {
 		/* Repost the RX URB */
@@ -3136,7 +3138,6 @@ static void hfa384x_usbin_callback(struct urb *urb)
 	/* Note: the check of the sw_support field, the type field doesn't
 	 *       have bit 12 set like the docs suggest.
 	 */
-	usbin = (union hfa384x_usbin *)urb->transfer_buffer;
 	type = le16_to_cpu(usbin->type);
 	if (HFA384x_USB_ISRXFRM(type)) {
 		if (action == HANDLE) {

commit 2d394ab79b9d53e104c6071f6e0ecf97e851b6d0
Author: Himadri Pandya <himadri18.07@gmail.com>
Date:   Thu May 2 15:34:12 2019 +0530

    staging: wlan-ng: Fix improper SPDX comment style
    
    The SPDX license identifier should have the form
    // SPDX-License-Identifier: <SPDX License Expression>
    for a .c source file. File hfa384x_usb.c has instead the form
    /* SPDX-License-Identifier: <SPDX License Expression> */
    which is the form for C header files. Hence this patch corrects it.
    Issue identified by checkpatch.
    
    Signed-off-by: Himadri Pandya <himadri18.07@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/hfa384x_usb.c b/drivers/staging/wlan-ng/hfa384x_usb.c
index 81a6b0324641..6fde75d4f064 100644
--- a/drivers/staging/wlan-ng/hfa384x_usb.c
+++ b/drivers/staging/wlan-ng/hfa384x_usb.c
@@ -1,4 +1,4 @@
-/* SPDX-License-Identifier: (GPL-2.0 OR MPL-1.1) */
+// SPDX-License-Identifier: (GPL-2.0 OR MPL-1.1)
 /* src/prism2/driver/hfa384x_usb.c
  *
  * Functions that talk to the USB variant of the Intersil hfa384x MAC

commit 737e061563b0580f3c74d4c08cbc7f5ab64a77b1
Author: Branden Bonaby <brandonbonaby94@gmail.com>
Date:   Wed Mar 20 13:22:07 2019 -0400

    staging: wlan-ng: Correct typo in comment message
    
    Add space between two words for better readability in the
    comments.
    
    Signed-off-by: Branden Bonaby <brandonbonaby94@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/hfa384x_usb.c b/drivers/staging/wlan-ng/hfa384x_usb.c
index 75acdfc30f6a..81a6b0324641 100644
--- a/drivers/staging/wlan-ng/hfa384x_usb.c
+++ b/drivers/staging/wlan-ng/hfa384x_usb.c
@@ -1,7 +1,7 @@
 /* SPDX-License-Identifier: (GPL-2.0 OR MPL-1.1) */
 /* src/prism2/driver/hfa384x_usb.c
  *
- * Functions that talk to the USB variantof the Intersil hfa384x MAC
+ * Functions that talk to the USB variant of the Intersil hfa384x MAC
  *
  * Copyright (C) 1999 AbsoluteValue Systems, Inc.  All Rights Reserved.
  * --------------------------------------------------------------------

commit 82c6f68090b7d56f98c9f9e59f4b3be3b0d014a8
Author: Branden Bonaby <brandonbonaby94@gmail.com>
Date:   Wed Mar 20 13:22:06 2019 -0400

    staging: wlan-ng: malformed SPDX-License-Identifier
    
    Correct malformed SPDX-License-Identifier so that it
    matches Linux kernel comment coding style.
    
    Signed-off-by: Branden Bonaby <brandonbonaby94@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/hfa384x_usb.c b/drivers/staging/wlan-ng/hfa384x_usb.c
index 6261881e9bcd..75acdfc30f6a 100644
--- a/drivers/staging/wlan-ng/hfa384x_usb.c
+++ b/drivers/staging/wlan-ng/hfa384x_usb.c
@@ -1,4 +1,4 @@
-// SPDX-License-Identifier: (GPL-2.0 OR MPL-1.1)
+/* SPDX-License-Identifier: (GPL-2.0 OR MPL-1.1) */
 /* src/prism2/driver/hfa384x_usb.c
  *
  * Functions that talk to the USB variantof the Intersil hfa384x MAC

commit 82ade3e5755643148af937f4cf930e52de03ea9c
Author: Tim Collier <osdevtc@gmail.com>
Date:   Wed Sep 26 23:06:29 2018 +0100

    staging: wlan-ng: rejoin split lines shortened by case changes
    
    The reformatting of case blocks has shortened some lines such that
    previously split lines can be rejoined without exceeding 80
    characters. Rejoined those lines.
    
    Signed-off-by: Tim Collier <osdevtc@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/hfa384x_usb.c b/drivers/staging/wlan-ng/hfa384x_usb.c
index fb32aaf13628..6261881e9bcd 100644
--- a/drivers/staging/wlan-ng/hfa384x_usb.c
+++ b/drivers/staging/wlan-ng/hfa384x_usb.c
@@ -3611,8 +3611,7 @@ static void hfa384x_usbout_callback(struct urb *urb)
 			netdev_warn(hw->wlandev->netdev,
 				    "%s tx pipe stalled: requesting reset\n",
 				    wlandev->netdev->name);
-			if (!test_and_set_bit
-			    (WORK_TX_HALT, &hw->usb_flags))
+			if (!test_and_set_bit(WORK_TX_HALT, &hw->usb_flags))
 				schedule_work(&hw->usb_work);
 			wlandev->netdev->stats.tx_errors++;
 			break;
@@ -3623,8 +3622,7 @@ static void hfa384x_usbout_callback(struct urb *urb)
 		case -EILSEQ: {
 			struct hfa384x *hw = wlandev->priv;
 
-			if (!test_and_set_bit
-			    (THROTTLE_TX, &hw->usb_flags) &&
+			if (!test_and_set_bit(THROTTLE_TX, &hw->usb_flags) &&
 			    !timer_pending(&hw->throttle)) {
 				mod_timer(&hw->throttle,
 					  jiffies + THROTTLE_JIFFIES);

commit 27575665f39c8c23d2a55d96665acf7151aad005
Author: Tim Collier <osdevtc@gmail.com>
Date:   Wed Sep 26 23:06:28 2018 +0100

    staging: wlan-ng: make switch case block format consistent
    
    For switch statements with case blocks make the format consistent by
    applying K&R formatting, a space before the opening brace, single
    indentation of contained code, break inside the block and closing
    brace aligned with case.
    
    Signed-off-by: Tim Collier <osdevtc@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/hfa384x_usb.c b/drivers/staging/wlan-ng/hfa384x_usb.c
index 16f7dd266e3b..fb32aaf13628 100644
--- a/drivers/staging/wlan-ng/hfa384x_usb.c
+++ b/drivers/staging/wlan-ng/hfa384x_usb.c
@@ -3605,36 +3605,34 @@ static void hfa384x_usbout_callback(struct urb *urb)
 			prism2sta_ev_alloc(wlandev);
 			break;
 
-		case -EPIPE:
-			{
-				struct hfa384x *hw = wlandev->priv;
+		case -EPIPE: {
+			struct hfa384x *hw = wlandev->priv;
 
-				netdev_warn(hw->wlandev->netdev,
-					    "%s tx pipe stalled: requesting reset\n",
-					    wlandev->netdev->name);
-				if (!test_and_set_bit
-				    (WORK_TX_HALT, &hw->usb_flags))
-					schedule_work(&hw->usb_work);
-				wlandev->netdev->stats.tx_errors++;
-				break;
-			}
+			netdev_warn(hw->wlandev->netdev,
+				    "%s tx pipe stalled: requesting reset\n",
+				    wlandev->netdev->name);
+			if (!test_and_set_bit
+			    (WORK_TX_HALT, &hw->usb_flags))
+				schedule_work(&hw->usb_work);
+			wlandev->netdev->stats.tx_errors++;
+			break;
+		}
 
 		case -EPROTO:
 		case -ETIMEDOUT:
-		case -EILSEQ:
-			{
-				struct hfa384x *hw = wlandev->priv;
-
-				if (!test_and_set_bit
-				    (THROTTLE_TX, &hw->usb_flags) &&
-				    !timer_pending(&hw->throttle)) {
-					mod_timer(&hw->throttle,
-						  jiffies + THROTTLE_JIFFIES);
-				}
-				wlandev->netdev->stats.tx_errors++;
-				netif_stop_queue(wlandev->netdev);
-				break;
+		case -EILSEQ: {
+			struct hfa384x *hw = wlandev->priv;
+
+			if (!test_and_set_bit
+			    (THROTTLE_TX, &hw->usb_flags) &&
+			    !timer_pending(&hw->throttle)) {
+				mod_timer(&hw->throttle,
+					  jiffies + THROTTLE_JIFFIES);
 			}
+			wlandev->netdev->stats.tx_errors++;
+			netif_stop_queue(wlandev->netdev);
+			break;
+		}
 
 		case -ENOENT:
 		case -ESHUTDOWN:

commit d47b10e6f90de6f0275eb3c9ffbc68c5534af9e4
Author: Tim Collier <osdevtc@gmail.com>
Date:   Wed Jul 25 20:30:32 2018 +0100

    staging: wlan-ng: correction to comment in hfa384x_usb
    
    The comment for hfa384x_docmd incorrectly states that usercb_data
    should be NULL for DOASYNC calls; in fact, it should be NULL for
    DOWAIT calls (this is consistent with the other similar functions and
    the rest of the comment text).
    
    Signed-off-by: Tim Collier <osdevtc@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/hfa384x_usb.c b/drivers/staging/wlan-ng/hfa384x_usb.c
index 33e97ffbb436..16f7dd266e3b 100644
--- a/drivers/staging/wlan-ng/hfa384x_usb.c
+++ b/drivers/staging/wlan-ng/hfa384x_usb.c
@@ -1290,7 +1290,7 @@ static int hfa384x_usbctlx_complete_sync(struct hfa384x *hw,
  *	cmdcb		command-specific callback
  *	usercb		user callback for async calls, NULL for DOWAIT calls
  *	usercb_data	user supplied data pointer for async calls, NULL
- *			for DOASYNC calls
+ *			for DOWAIT calls
  *
  * Returns:
  *	0		success

commit 173ffd0993fd3e6ec7e0e24424350a807605e6d0
Author: Tim Collier <osdevtc@gmail.com>
Date:   Wed May 23 08:30:25 2018 +0100

    staging: wlan-ng: convert P80211SKB_RXMETA to inline function in p80211conv
    
    To avoid possible issues with repeated reference to the macro argument
    as reported by checkpatch, macro P80211SKB_RXMETA is replaced with an
    equivalent inline function. The function is named p80211skb_rxmeta to
    follow the coding style guidelines; references to the macro are
    updated to reference the new function.
    
    This change depends on the similar change for P80211SKB_FRMMETA having
    been applied.
    
    Signed-off-by: Tim Collier <osdevtc@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/hfa384x_usb.c b/drivers/staging/wlan-ng/hfa384x_usb.c
index c1e88b8b751f..33e97ffbb436 100644
--- a/drivers/staging/wlan-ng/hfa384x_usb.c
+++ b/drivers/staging/wlan-ng/hfa384x_usb.c
@@ -3417,7 +3417,7 @@ static void hfa384x_usbin_rx(struct wlandevice *wlandev, struct sk_buff *skb)
 
 		/* Attach the rxmeta, set some stuff */
 		p80211skb_rxmeta_attach(wlandev, skb);
-		rxmeta = P80211SKB_RXMETA(skb);
+		rxmeta = p80211skb_rxmeta(skb);
 		rxmeta->mactime = usbin->rxfrm.desc.time;
 		rxmeta->rxrate = usbin->rxfrm.desc.rate;
 		rxmeta->signal = usbin->rxfrm.desc.signal - hw->dbmadjust;

commit d4b9a864dea322088535300c12c09cd654d3a1fc
Author: Tim Collier <osdevtc@gmail.com>
Date:   Wed May 2 20:30:50 2018 +0100

    staging: wlan-ng: fix line-break style issue
    
    Fix checkpatch warning due to line break after '(', leaving an over 80
    character warning due to long macro name.
    
    Signed-off-by: Tim Collier <osdevtc@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/hfa384x_usb.c b/drivers/staging/wlan-ng/hfa384x_usb.c
index a1b1d06d01bd..c1e88b8b751f 100644
--- a/drivers/staging/wlan-ng/hfa384x_usb.c
+++ b/drivers/staging/wlan-ng/hfa384x_usb.c
@@ -3439,8 +3439,7 @@ static void hfa384x_usbin_rx(struct wlandevice *wlandev, struct sk_buff *skb)
 
 	default:
 		netdev_warn(hw->wlandev->netdev, "Received frame on unsupported port=%d\n",
-			    HFA384x_RXSTATUS_MACPORT_GET(
-				    usbin->rxfrm.desc.status));
+			    HFA384x_RXSTATUS_MACPORT_GET(usbin->rxfrm.desc.status));
 		break;
 	}
 }

commit e163a0a8b9b8d286a4db15fa686c543b18f5b3d9
Author: Tim Collier <osdevtc@gmail.com>
Date:   Wed May 2 20:30:49 2018 +0100

    staging: wlan-ng: add missing parameter name to prototype
    
    Fix checkpatch warning for missing parameter name for function
    prototype.
    
    Signed-off-by: Tim Collier <osdevtc@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/hfa384x_usb.c b/drivers/staging/wlan-ng/hfa384x_usb.c
index 555711bc12f0..a1b1d06d01bd 100644
--- a/drivers/staging/wlan-ng/hfa384x_usb.c
+++ b/drivers/staging/wlan-ng/hfa384x_usb.c
@@ -202,7 +202,7 @@ static void unlocked_usbctlx_complete(struct hfa384x *hw,
 				      struct hfa384x_usbctlx *ctlx);
 
 struct usbctlx_completor {
-	int (*complete)(struct usbctlx_completor *);
+	int (*complete)(struct usbctlx_completor *completor);
 };
 
 static int

commit 8f3614c5c67237ad9b3916c8150b098f133ac808
Author: Andy Pusch <drag@black-pixel.net>
Date:   Sat Dec 23 16:37:56 2017 +0100

    Staging: wlan-ng: hfa384x_usb: fixed two line limit coding style issues
    
    Fixed two coding style issues.
    
    Signed-off-by: Andy Pusch <drag@black-pixel.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/hfa384x_usb.c b/drivers/staging/wlan-ng/hfa384x_usb.c
index 84f3657e26a2..555711bc12f0 100644
--- a/drivers/staging/wlan-ng/hfa384x_usb.c
+++ b/drivers/staging/wlan-ng/hfa384x_usb.c
@@ -2458,7 +2458,8 @@ int hfa384x_drvr_start(struct hfa384x *hw)
 	 * ok
 	 */
 	result =
-	    usb_get_std_status(hw->usb, USB_RECIP_ENDPOINT, hw->endp_in, &status);
+	    usb_get_std_status(hw->usb, USB_RECIP_ENDPOINT, hw->endp_in,
+			       &status);
 	if (result < 0) {
 		netdev_err(hw->wlandev->netdev, "Cannot get bulk in endpoint status.\n");
 		goto done;
@@ -2467,7 +2468,8 @@ int hfa384x_drvr_start(struct hfa384x *hw)
 		netdev_err(hw->wlandev->netdev, "Failed to reset bulk in endpoint.\n");
 
 	result =
-	    usb_get_std_status(hw->usb, USB_RECIP_ENDPOINT, hw->endp_out, &status);
+	    usb_get_std_status(hw->usb, USB_RECIP_ENDPOINT, hw->endp_out,
+			       &status);
 	if (result < 0) {
 		netdev_err(hw->wlandev->netdev, "Cannot get bulk out endpoint status.\n");
 		goto done;

commit f7056d335d919c15dc9ae26923969673da846e37
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Nov 7 21:07:51 2017 +0100

    staging: wlan-ng: add SPDX identifiers to all wlan-ng driver files
    
    It's good to have SPDX identifiers in all files to make it easier to
    audit the kernel tree for correct licenses.
    
    Update the wlan-ng driver files with the correct SPDX license identifier
    based on the license text in the file itself.  The SPDX identifier is a
    legally binding shorthand, which can be used instead of the full boiler
    plate text.
    
    This work is based on a script and data from Thomas Gleixner, Philippe
    Ombredanne, and Kate Stewart.
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: Philippe Ombredanne <pombredanne@nexb.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/hfa384x_usb.c b/drivers/staging/wlan-ng/hfa384x_usb.c
index 197f5a914e8f..84f3657e26a2 100644
--- a/drivers/staging/wlan-ng/hfa384x_usb.c
+++ b/drivers/staging/wlan-ng/hfa384x_usb.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: (GPL-2.0 OR MPL-1.1)
 /* src/prism2/driver/hfa384x_usb.c
  *
  * Functions that talk to the USB variantof the Intersil hfa384x MAC

commit 894025f24bd028942da3e602b87d9f7223109b14
Merge: fb0255fb2941 cdafb6d8b8da
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Nov 13 21:14:07 2017 -0800

    Merge tag 'usb-4.15-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/usb
    
    Pull USB/PHY updates from Greg KH:
     "Here is the big set of USB and PHY driver updates for 4.15-rc1.
    
      There is the usual amount of gadget and xhci driver updates, along
      with phy and chipidea enhancements. There's also a lot of SPDX tags
      and license boilerplate cleanups as well, which provide some churn in
      the diffstat.
    
      Other major thing is the typec code that moved out of staging and into
      the "real" part of the drivers/usb/ tree, which was nice to see
      happen.
    
      All of these have been in linux-next with no reported issues for a
      while"
    
    * tag 'usb-4.15-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/usb: (263 commits)
      usb: gadget: f_fs: Fix use-after-free in ffs_free_inst
      USB: usbfs: compute urb->actual_length for isochronous
      usb: core: message: remember to reset 'ret' to 0 when necessary
      USB: typec: Remove remaining redundant license text
      USB: typec: add SPDX identifiers to some files
      USB: renesas_usbhs: rcar?.h: add SPDX tags
      USB: chipidea: ci_hdrc_tegra.c: add SPDX line
      USB: host: xhci-debugfs: add SPDX lines
      USB: add SPDX identifiers to all remaining Makefiles
      usb: host: isp1362-hcd: remove a couple of redundant assignments
      USB: adutux: remove redundant variable minor
      usb: core: add a new usb_get_ptm_status() helper
      usb: core: add a 'type' parameter to usb_get_status()
      usb: core: introduce a new usb_get_std_status() helper
      usb: core: rename usb_get_status() 'type' argument to 'recip'
      usb: core: add Status Type definitions
      USB: gadget: Remove redundant license text
      USB: gadget: function: Remove redundant license text
      USB: gadget: udc: Remove redundant license text
      USB: gadget: legacy: Remove redundant license text
      ...

commit d9e1e1484ade396b3a979ba6c68798dbaceed1b9
Author: Felipe Balbi <felipe.balbi@linux.intel.com>
Date:   Thu Nov 2 10:57:40 2017 +0200

    usb: core: introduce a new usb_get_std_status() helper
    
    This new helper is a simple wrapper around usb_get_status(). This
    patch is in preparation to adding support for fetching PTM_STATUS
    types. No functional changes.
    
    Signed-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/hfa384x_usb.c b/drivers/staging/wlan-ng/hfa384x_usb.c
index d1e8218f96fb..d24f5eba9375 100644
--- a/drivers/staging/wlan-ng/hfa384x_usb.c
+++ b/drivers/staging/wlan-ng/hfa384x_usb.c
@@ -2460,7 +2460,7 @@ int hfa384x_drvr_start(struct hfa384x *hw)
 	 * ok
 	 */
 	result =
-	    usb_get_status(hw->usb, USB_RECIP_ENDPOINT, hw->endp_in, &status);
+	    usb_get_std_status(hw->usb, USB_RECIP_ENDPOINT, hw->endp_in, &status);
 	if (result < 0) {
 		netdev_err(hw->wlandev->netdev, "Cannot get bulk in endpoint status.\n");
 		goto done;
@@ -2469,7 +2469,7 @@ int hfa384x_drvr_start(struct hfa384x *hw)
 		netdev_err(hw->wlandev->netdev, "Failed to reset bulk in endpoint.\n");
 
 	result =
-	    usb_get_status(hw->usb, USB_RECIP_ENDPOINT, hw->endp_out, &status);
+	    usb_get_std_status(hw->usb, USB_RECIP_ENDPOINT, hw->endp_out, &status);
 	if (result < 0) {
 		netdev_err(hw->wlandev->netdev, "Cannot get bulk out endpoint status.\n");
 		goto done;

commit 5eb54a9997596ce1192e3416ccacc9acd17c34ef
Author: Kees Cook <keescook@chromium.org>
Date:   Wed Oct 18 13:23:31 2017 -0700

    staging: wlan-ng: Convert timers to use timer_setup()
    
    In preparation for unconditionally passing the struct timer_list pointer to
    all timer callbacks, switch to using the new timer_setup() and from_timer()
    to pass the timer pointer explicitly.
    
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Cc: Adrien Descamps <adrien.descamps@gmail.com>
    Cc: Thibaut SAUTEREAU <thibaut.sautereau@telecom-sudparis.eu>
    Cc: devel@driverdev.osuosl.org
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/hfa384x_usb.c b/drivers/staging/wlan-ng/hfa384x_usb.c
index d1e8218f96fb..5975d47dfa71 100644
--- a/drivers/staging/wlan-ng/hfa384x_usb.c
+++ b/drivers/staging/wlan-ng/hfa384x_usb.c
@@ -184,11 +184,11 @@ static void hfa384x_usbin_ctlx(struct hfa384x *hw, union hfa384x_usbin *usbin,
 
 static void hfa384x_usbctlxq_run(struct hfa384x *hw);
 
-static void hfa384x_usbctlx_reqtimerfn(unsigned long data);
+static void hfa384x_usbctlx_reqtimerfn(struct timer_list *t);
 
-static void hfa384x_usbctlx_resptimerfn(unsigned long data);
+static void hfa384x_usbctlx_resptimerfn(struct timer_list *t);
 
-static void hfa384x_usb_throttlefn(unsigned long data);
+static void hfa384x_usb_throttlefn(struct timer_list *t);
 
 static void hfa384x_usbctlx_completion_task(unsigned long data);
 
@@ -558,13 +558,11 @@ void hfa384x_create(struct hfa384x *hw, struct usb_device *usb)
 	INIT_WORK(&hw->link_bh, prism2sta_processing_defer);
 	INIT_WORK(&hw->usb_work, hfa384x_usb_defer);
 
-	setup_timer(&hw->throttle, hfa384x_usb_throttlefn, (unsigned long)hw);
+	timer_setup(&hw->throttle, hfa384x_usb_throttlefn, 0);
 
-	setup_timer(&hw->resptimer, hfa384x_usbctlx_resptimerfn,
-		    (unsigned long)hw);
+	timer_setup(&hw->resptimer, hfa384x_usbctlx_resptimerfn, 0);
 
-	setup_timer(&hw->reqtimer, hfa384x_usbctlx_reqtimerfn,
-		    (unsigned long)hw);
+	timer_setup(&hw->reqtimer, hfa384x_usbctlx_reqtimerfn, 0);
 
 	usb_init_urb(&hw->rx_urb);
 	usb_init_urb(&hw->tx_urb);
@@ -574,8 +572,7 @@ void hfa384x_create(struct hfa384x *hw, struct usb_device *usb)
 	hw->state = HFA384x_STATE_INIT;
 
 	INIT_WORK(&hw->commsqual_bh, prism2sta_commsqual_defer);
-	setup_timer(&hw->commsqual_timer, prism2sta_commsqual_timer,
-		    (unsigned long)hw);
+	timer_setup(&hw->commsqual_timer, prism2sta_commsqual_timer, 0);
 }
 
 /*----------------------------------------------------------------
@@ -3800,9 +3797,9 @@ static void hfa384x_ctlxout_callback(struct urb *urb)
  *	interrupt
  *----------------------------------------------------------------
  */
-static void hfa384x_usbctlx_reqtimerfn(unsigned long data)
+static void hfa384x_usbctlx_reqtimerfn(struct timer_list *t)
 {
-	struct hfa384x *hw = (struct hfa384x *)data;
+	struct hfa384x *hw = from_timer(hw, t, reqtimer);
 	unsigned long flags;
 
 	spin_lock_irqsave(&hw->ctlxq.lock, flags);
@@ -3859,9 +3856,9 @@ static void hfa384x_usbctlx_reqtimerfn(unsigned long data)
  *	interrupt
  *----------------------------------------------------------------
  */
-static void hfa384x_usbctlx_resptimerfn(unsigned long data)
+static void hfa384x_usbctlx_resptimerfn(struct timer_list *t)
 {
-	struct hfa384x *hw = (struct hfa384x *)data;
+	struct hfa384x *hw = from_timer(hw, t, resptimer);
 	unsigned long flags;
 
 	spin_lock_irqsave(&hw->ctlxq.lock, flags);
@@ -3899,9 +3896,9 @@ static void hfa384x_usbctlx_resptimerfn(unsigned long data)
  *	Interrupt
  *----------------------------------------------------------------
  */
-static void hfa384x_usb_throttlefn(unsigned long data)
+static void hfa384x_usb_throttlefn(struct timer_list *t)
 {
-	struct hfa384x *hw = (struct hfa384x *)data;
+	struct hfa384x *hw = from_timer(hw, t, throttle);
 	unsigned long flags;
 
 	spin_lock_irqsave(&hw->ctlxq.lock, flags);

commit bf334c024fd215db3395342cac579aa3e9ac46ac
Author: Alex Briskin <br.shurik@gmail.com>
Date:   Fri Aug 18 15:27:35 2017 +0300

    staging: wlan-ng: hfa384x_usb: Fix multiple line dereference
    
    Refactor code to be more readable and eliminate the checkpatch
    warning
    
    Signed-off-by: Alex Briskin <br.shurik@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/hfa384x_usb.c b/drivers/staging/wlan-ng/hfa384x_usb.c
index ee5fa86e941d..d1e8218f96fb 100644
--- a/drivers/staging/wlan-ng/hfa384x_usb.c
+++ b/drivers/staging/wlan-ng/hfa384x_usb.c
@@ -1344,16 +1344,14 @@ hfa384x_docmd(struct hfa384x *hw,
 	if (result != 0) {
 		kfree(ctlx);
 	} else if (mode == DOWAIT) {
-		struct usbctlx_cmd_completor completor;
+		struct usbctlx_cmd_completor cmd_completor;
+		struct usbctlx_completor *completor;
 
-		result =
-		    hfa384x_usbctlx_complete_sync(hw, ctlx,
-						  init_cmd_completor(&completor,
-								     &ctlx->
-								     inbuf.
-								     cmdresp,
-								     &cmd->
-								     result));
+		completor = init_cmd_completor(&cmd_completor,
+					       &ctlx->inbuf.cmdresp,
+					       &cmd->result);
+
+		result = hfa384x_usbctlx_complete_sync(hw, ctlx, completor);
 	}
 
 done:

commit 5518b69b76680a4f2df96b1deca260059db0c2de
Merge: 8ad06e56dcbc 0e72582270c0
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Jul 5 12:31:59 2017 -0700

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/davem/net-next
    
    Pull networking updates from David Miller:
     "Reasonably busy this cycle, but perhaps not as busy as in the 4.12
      merge window:
    
       1) Several optimizations for UDP processing under high load from
          Paolo Abeni.
    
       2) Support pacing internally in TCP when using the sch_fq packet
          scheduler for this is not practical. From Eric Dumazet.
    
       3) Support mutliple filter chains per qdisc, from Jiri Pirko.
    
       4) Move to 1ms TCP timestamp clock, from Eric Dumazet.
    
       5) Add batch dequeueing to vhost_net, from Jason Wang.
    
       6) Flesh out more completely SCTP checksum offload support, from
          Davide Caratti.
    
       7) More plumbing of extended netlink ACKs, from David Ahern, Pablo
          Neira Ayuso, and Matthias Schiffer.
    
       8) Add devlink support to nfp driver, from Simon Horman.
    
       9) Add RTM_F_FIB_MATCH flag to RTM_GETROUTE queries, from Roopa
          Prabhu.
    
      10) Add stack depth tracking to BPF verifier and use this information
          in the various eBPF JITs. From Alexei Starovoitov.
    
      11) Support XDP on qed device VFs, from Yuval Mintz.
    
      12) Introduce BPF PROG ID for better introspection of installed BPF
          programs. From Martin KaFai Lau.
    
      13) Add bpf_set_hash helper for TC bpf programs, from Daniel Borkmann.
    
      14) For loads, allow narrower accesses in bpf verifier checking, from
          Yonghong Song.
    
      15) Support MIPS in the BPF selftests and samples infrastructure, the
          MIPS eBPF JIT will be merged in via the MIPS GIT tree. From David
          Daney.
    
      16) Support kernel based TLS, from Dave Watson and others.
    
      17) Remove completely DST garbage collection, from Wei Wang.
    
      18) Allow installing TCP MD5 rules using prefixes, from Ivan
          Delalande.
    
      19) Add XDP support to Intel i40e driver, from Björn Töpel
    
      20) Add support for TC flower offload in nfp driver, from Simon
          Horman, Pieter Jansen van Vuuren, Benjamin LaHaise, Jakub
          Kicinski, and Bert van Leeuwen.
    
      21) IPSEC offloading support in mlx5, from Ilan Tayari.
    
      22) Add HW PTP support to macb driver, from Rafal Ozieblo.
    
      23) Networking refcount_t conversions, From Elena Reshetova.
    
      24) Add sock_ops support to BPF, from Lawrence Brako. This is useful
          for tuning the TCP sockopt settings of a group of applications,
          currently via CGROUPs"
    
    * git://git.kernel.org/pub/scm/linux/kernel/git/davem/net-next: (1899 commits)
      net: phy: dp83867: add workaround for incorrect RX_CTRL pin strap
      dt-bindings: phy: dp83867: provide a workaround for incorrect RX_CTRL pin strap
      cxgb4: Support for get_ts_info ethtool method
      cxgb4: Add PTP Hardware Clock (PHC) support
      cxgb4: time stamping interface for PTP
      nfp: default to chained metadata prepend format
      nfp: remove legacy MAC address lookup
      nfp: improve order of interfaces in breakout mode
      net: macb: remove extraneous return when MACB_EXT_DESC is defined
      bpf: add missing break in for the TCP_BPF_SNDCWND_CLAMP case
      bpf: fix return in load_bpf_file
      mpls: fix rtm policy in mpls_getroute
      net, ax25: convert ax25_cb.refcount from atomic_t to refcount_t
      net, ax25: convert ax25_route.refcount from atomic_t to refcount_t
      net, ax25: convert ax25_uid_assoc.refcount from atomic_t to refcount_t
      net, sctp: convert sctp_ep_common.refcnt from atomic_t to refcount_t
      net, sctp: convert sctp_transport.refcnt from atomic_t to refcount_t
      net, sctp: convert sctp_chunk.refcnt from atomic_t to refcount_t
      net, sctp: convert sctp_datamsg.refcnt from atomic_t to refcount_t
      net, sctp: convert sctp_auth_bytes.refcnt from atomic_t to refcount_t
      ...

commit b952f4dff2751252db073c27c0f8a16a416a2ddc
Author: yuan linyu <Linyu.Yuan@alcatel-sbell.com.cn>
Date:   Sun Jun 18 22:52:04 2017 +0800

    net: manual clean code which call skb_put_[data:zero]
    
    Signed-off-by: yuan linyu <Linyu.Yuan@alcatel-sbell.com.cn>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/staging/wlan-ng/hfa384x_usb.c b/drivers/staging/wlan-ng/hfa384x_usb.c
index 1de67f209f2c..83ea8ab4f2f4 100644
--- a/drivers/staging/wlan-ng/hfa384x_usb.c
+++ b/drivers/staging/wlan-ng/hfa384x_usb.c
@@ -3530,7 +3530,7 @@ static void hfa384x_int_rxmonitor(struct wlandevice *wlandev,
 	/* Copy the 802.11 header to the skb
 	 * (ctl frames may be less than a full header)
 	 */
-	datap = skb_put_data(skb, &rxdesc->frame_control, hdrlen);
+	skb_put_data(skb, &rxdesc->frame_control, hdrlen);
 
 	/* If any, copy the data from the card to the skb */
 	if (datalen > 0) {

commit 59ae1d127ac0ae404baf414c434ba2651b793f46
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Fri Jun 16 14:29:20 2017 +0200

    networking: introduce and use skb_put_data()
    
    A common pattern with skb_put() is to just want to memcpy()
    some data into the new space, introduce skb_put_data() for
    this.
    
    An spatch similar to the one for skb_put_zero() converts many
    of the places using it:
    
        @@
        identifier p, p2;
        expression len, skb, data;
        type t, t2;
        @@
        (
        -p = skb_put(skb, len);
        +p = skb_put_data(skb, data, len);
        |
        -p = (t)skb_put(skb, len);
        +p = skb_put_data(skb, data, len);
        )
        (
        p2 = (t2)p;
        -memcpy(p2, data, len);
        |
        -memcpy(p, data, len);
        )
    
        @@
        type t, t2;
        identifier p, p2;
        expression skb, data;
        @@
        t *p;
        ...
        (
        -p = skb_put(skb, sizeof(t));
        +p = skb_put_data(skb, data, sizeof(t));
        |
        -p = (t *)skb_put(skb, sizeof(t));
        +p = skb_put_data(skb, data, sizeof(t));
        )
        (
        p2 = (t2)p;
        -memcpy(p2, data, sizeof(*p));
        |
        -memcpy(p, data, sizeof(*p));
        )
    
        @@
        expression skb, len, data;
        @@
        -memcpy(skb_put(skb, len), data, len);
        +skb_put_data(skb, data, len);
    
    (again, manually post-processed to retain some comments)
    
    Reviewed-by: Stephen Hemminger <stephen@networkplumber.org>
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/staging/wlan-ng/hfa384x_usb.c b/drivers/staging/wlan-ng/hfa384x_usb.c
index a812e55ba1b0..1de67f209f2c 100644
--- a/drivers/staging/wlan-ng/hfa384x_usb.c
+++ b/drivers/staging/wlan-ng/hfa384x_usb.c
@@ -3530,13 +3530,11 @@ static void hfa384x_int_rxmonitor(struct wlandevice *wlandev,
 	/* Copy the 802.11 header to the skb
 	 * (ctl frames may be less than a full header)
 	 */
-	datap = skb_put(skb, hdrlen);
-	memcpy(datap, &rxdesc->frame_control, hdrlen);
+	datap = skb_put_data(skb, &rxdesc->frame_control, hdrlen);
 
 	/* If any, copy the data from the card to the skb */
 	if (datalen > 0) {
-		datap = skb_put(skb, datalen);
-		memcpy(datap, rxfrm->data, datalen);
+		datap = skb_put_data(skb, rxfrm->data, datalen);
 
 		/* check for unencrypted stuff if WEP bit set. */
 		if (*(datap - hdrlen + 1) & 0x40)	/* wep set */

commit 126ef7760b53585850c9091f35c552e65c209d57
Author: Nikola Jelic <nikola.jelic83@gmail.com>
Date:   Tue May 23 23:02:45 2017 +0200

    staging: wlan-ng: hfa384x: fix several type issues.
    
    There were several in-place conversions of 16 and 32-bit data, which caused
    sparse to detect them. Changed them to the in situ versions, such as:
    le16_to_cpu -> le16_to_cpus
    
    Signed-off-by: Nikola Jelic <nikola.jelic83@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/hfa384x_usb.c b/drivers/staging/wlan-ng/hfa384x_usb.c
index a812e55ba1b0..d3d1958675ed 100644
--- a/drivers/staging/wlan-ng/hfa384x_usb.c
+++ b/drivers/staging/wlan-ng/hfa384x_usb.c
@@ -1840,15 +1840,15 @@ int hfa384x_drvr_flashdl_enable(struct hfa384x *hw)
 	if (result)
 		return result;
 
-	hw->bufinfo.page = le16_to_cpu(hw->bufinfo.page);
-	hw->bufinfo.offset = le16_to_cpu(hw->bufinfo.offset);
-	hw->bufinfo.len = le16_to_cpu(hw->bufinfo.len);
+	le16_to_cpus(&hw->bufinfo.page);
+	le16_to_cpus(&hw->bufinfo.offset);
+	le16_to_cpus(&hw->bufinfo.len);
 	result = hfa384x_drvr_getconfig16(hw, HFA384x_RID_MAXLOADTIME,
 					  &hw->dltimeout);
 	if (result)
 		return result;
 
-	hw->dltimeout = le16_to_cpu(hw->dltimeout);
+	le16_to_cpus(&hw->dltimeout);
 
 	pr_debug("flashdl_enable\n");
 
@@ -2644,8 +2644,7 @@ int hfa384x_drvr_txframe(struct hfa384x *hw, struct sk_buff *skb,
 	    HFA384x_TX_MACPORT_SET(0) | HFA384x_TX_STRUCTYPE_SET(1) |
 	    HFA384x_TX_TXEX_SET(0) | HFA384x_TX_TXOK_SET(0);
 #endif
-	hw->txbuff.txfrm.desc.tx_control =
-	    cpu_to_le16(hw->txbuff.txfrm.desc.tx_control);
+	cpu_to_le16s(&hw->txbuff.txfrm.desc.tx_control);
 
 	/* copy the header over to the txdesc */
 	memcpy(&hw->txbuff.txfrm.desc.frame_control, p80211_hdr,
@@ -3380,8 +3379,8 @@ static void hfa384x_usbin_rx(struct wlandevice *wlandev, struct sk_buff *skb)
 	u16 fc;
 
 	/* Byte order convert once up front. */
-	usbin->rxfrm.desc.status = le16_to_cpu(usbin->rxfrm.desc.status);
-	usbin->rxfrm.desc.time = le32_to_cpu(usbin->rxfrm.desc.time);
+	le16_to_cpus(&usbin->rxfrm.desc.status);
+	le32_to_cpus(&usbin->rxfrm.desc.time);
 
 	/* Now handle frame based on port# */
 	switch (HFA384x_RXSTATUS_MACPORT_GET(usbin->rxfrm.desc.status)) {
@@ -3576,8 +3575,7 @@ static void hfa384x_int_rxmonitor(struct wlandevice *wlandev,
 static void hfa384x_usbin_info(struct wlandevice *wlandev,
 			       union hfa384x_usbin *usbin)
 {
-	usbin->infofrm.info.framelen =
-	    le16_to_cpu(usbin->infofrm.info.framelen);
+	le16_to_cpus(&usbin->infofrm.info.framelen);
 	prism2sta_ev_info(wlandev, &usbin->infofrm.info);
 }
 

commit 68e009ed1cc699a32557705d76877c5209400103
Author: Adrien Descamps <adrien.descamps@gmail.com>
Date:   Thu Mar 9 21:15:19 2017 +0100

    Staging: wlan-ng: Fix endian error
    
    sparse report fixed:
    drivers/staging//wlan-ng//hfa384x_usb.c:3517:35: warning: restricted __be64 degrades to integer
    drivers/staging//wlan-ng//hfa384x_usb.c:3517:33: warning: incorrect type in assignment (different base types)
    drivers/staging//wlan-ng//hfa384x_usb.c:3517:33:    expected restricted __be64 [usertype] mactime
    drivers/staging//wlan-ng//hfa384x_usb.c:3517:33:    got unsigned long long
    
    Computation on the value should be done when in machine format, not in big endian format.
    
    Signed-off-by: Adrien Descamps <adrien.descamps@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/hfa384x_usb.c b/drivers/staging/wlan-ng/hfa384x_usb.c
index 64848778834c..a812e55ba1b0 100644
--- a/drivers/staging/wlan-ng/hfa384x_usb.c
+++ b/drivers/staging/wlan-ng/hfa384x_usb.c
@@ -3513,7 +3513,7 @@ static void hfa384x_int_rxmonitor(struct wlandevice *wlandev,
 
 		caphdr->version = htonl(P80211CAPTURE_VERSION);
 		caphdr->length = htonl(sizeof(struct p80211_caphdr));
-		caphdr->mactime = __cpu_to_be64(rxdesc->time) * 1000;
+		caphdr->mactime = __cpu_to_be64(rxdesc->time * 1000);
 		caphdr->hosttime = __cpu_to_be64(jiffies);
 		caphdr->phytype = htonl(4);	/* dss_dot11_b */
 		caphdr->channel = htonl(hw->sniff_channel);

commit a18ffdf4ea7c6ac496f940d0852d42e1074c3450
Author: Adrien Descamps <adrien.descamps@gmail.com>
Date:   Thu Mar 9 21:15:18 2017 +0100

    Staging: wlan-ng: Fix sparse warnings by using appropriate endian types
    
    Fix some sparse warning by using correct endian types in structs and
    local variables.
    This patch only fix sparse warnings and do not change the logic.
    
    Signed-off-by: Adrien Descamps <adrien.descamps@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/hfa384x_usb.c b/drivers/staging/wlan-ng/hfa384x_usb.c
index 6134eba5cad4..64848778834c 100644
--- a/drivers/staging/wlan-ng/hfa384x_usb.c
+++ b/drivers/staging/wlan-ng/hfa384x_usb.c
@@ -2316,7 +2316,7 @@ int hfa384x_drvr_ramdl_write(struct hfa384x *hw, u32 daddr, void *buf, u32 len)
 int hfa384x_drvr_readpda(struct hfa384x *hw, void *buf, unsigned int len)
 {
 	int result = 0;
-	u16 *pda = buf;
+	__le16 *pda = buf;
 	int pdaok = 0;
 	int morepdrs = 1;
 	int currpdr = 0;	/* word offset of the current pdr */

commit 4a7c972644c1151f6dd34ff4b5f7eacb239e22ee
Author: Tobias Klauser <tklauser@distanz.ch>
Date:   Wed Jan 18 17:45:01 2017 +0100

    net: Remove usage of net_device last_rx member
    
    The network stack no longer uses the last_rx member of struct net_device
    since the bonding driver switched to use its own private last_rx in
    commit 9f242738376d ("bonding: use last_arp_rx in slave_last_rx()").
    
    However, some drivers still (ab)use the field for their own purposes and
    some driver just update it without actually using it.
    
    Previously, there was an accompanying comment for the last_rx member
    added in commit 4dc89133f49b ("net: add a comment on netdev->last_rx")
    which asked drivers not to update is, unless really needed. However,
    this commend was removed in commit f8ff080dacec ("bonding: remove
    useless updating of slave->dev->last_rx"), so some drivers added later
    on still did update last_rx.
    
    Remove all usage of last_rx and switch three drivers (sky2, atp and
    smc91c92_cs) which actually read and write it to use their own private
    copy in netdev_priv.
    
    Compile-tested with allyesconfig and allmodconfig on x86 and arm.
    
    Cc: Eric Dumazet <eric.dumazet@gmail.com>
    Cc: Jay Vosburgh <j.vosburgh@gmail.com>
    Cc: Veaceslav Falico <vfalico@gmail.com>
    Cc: Andy Gospodarek <andy@greyhouse.net>
    Cc: Mirko Lindner <mlindner@marvell.com>
    Cc: Stephen Hemminger <stephen@networkplumber.org>
    Signed-off-by: Tobias Klauser <tklauser@distanz.ch>
    Acked-by: Eric Dumazet <edumazet@google.com>
    Reviewed-by: Jay Vosburgh <jay.vosburgh@canonical.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/staging/wlan-ng/hfa384x_usb.c b/drivers/staging/wlan-ng/hfa384x_usb.c
index 4fe037aeef12..6134eba5cad4 100644
--- a/drivers/staging/wlan-ng/hfa384x_usb.c
+++ b/drivers/staging/wlan-ng/hfa384x_usb.c
@@ -3409,7 +3409,6 @@ static void hfa384x_usbin_rx(struct wlandevice *wlandev, struct sk_buff *skb)
 			&usbin->rxfrm.desc.frame_control, hdrlen);
 
 		skb->dev = wlandev->netdev;
-		skb->dev->last_rx = jiffies;
 
 		/* And set the frame length properly */
 		skb_trim(skb, data_len + hdrlen);

commit e895f00a84965a2fef2cee0cb06f2f59154186f0
Author: Yan Laijun <yan.laijun@gmail.com>
Date:   Mon Dec 5 21:21:39 2016 +0800

    Staging: wlan-ng: hfa384x_usb.c Fixed too long code line warnings.
    
    Fixed checkpatch warning "line over 80 characters" in
    wlan-ng/hfa384x_usb.c file.
    
    Signed-off-by: Yan Laijun <yan.laijun@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/hfa384x_usb.c b/drivers/staging/wlan-ng/hfa384x_usb.c
index 5f11f6ef8cbd..4fe037aeef12 100644
--- a/drivers/staging/wlan-ng/hfa384x_usb.c
+++ b/drivers/staging/wlan-ng/hfa384x_usb.c
@@ -3037,7 +3037,7 @@ static void hfa384x_usbin_callback(struct urb *urb)
 {
 	struct wlandevice *wlandev = urb->context;
 	struct hfa384x *hw;
-	union hfa384x_usbin *usbin = (union hfa384x_usbin *)urb->transfer_buffer;
+	union hfa384x_usbin *usbin;
 	struct sk_buff *skb = NULL;
 	int result;
 	int urb_status;
@@ -3139,6 +3139,7 @@ static void hfa384x_usbin_callback(struct urb *urb)
 	/* Note: the check of the sw_support field, the type field doesn't
 	 *       have bit 12 set like the docs suggest.
 	 */
+	usbin = (union hfa384x_usbin *)urb->transfer_buffer;
 	type = le16_to_cpu(usbin->type);
 	if (HFA384x_USB_ISRXFRM(type)) {
 		if (action == HANDLE) {

commit d1866af104b5282581045e461d9f94c7273e6879
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Mon Nov 7 18:55:22 2016 +0100

    staging: wlan-ng: match open parenthesis alignment in hfa384x_usb.c
    
    This patch fix open parenthesis alignment in hfa384x_usb.c file to
    comply with the standard kernel coding style.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/hfa384x_usb.c b/drivers/staging/wlan-ng/hfa384x_usb.c
index 349f12250d77..5f11f6ef8cbd 100644
--- a/drivers/staging/wlan-ng/hfa384x_usb.c
+++ b/drivers/staging/wlan-ng/hfa384x_usb.c
@@ -676,8 +676,8 @@ static inline int usbctlx_cmd_completor_fn(struct usbctlx_completor *head)
 
 static inline struct usbctlx_completor *
 init_cmd_completor(struct usbctlx_cmd_completor *completor,
-			const struct hfa384x_usb_statusresp *cmdresp,
-			struct hfa384x_cmdresult *result)
+		   const struct hfa384x_usb_statusresp *cmdresp,
+		   struct hfa384x_cmdresult *result)
 {
 	completor->head.complete = usbctlx_cmd_completor_fn;
 	completor->cmdresp = cmdresp;
@@ -721,9 +721,9 @@ static int usbctlx_rrid_completor_fn(struct usbctlx_completor *head)
 
 static inline struct usbctlx_completor *
 init_rrid_completor(struct usbctlx_rrid_completor *completor,
-			const struct hfa384x_usb_rridresp *rridresp,
-			void *riddata,
-			unsigned int riddatalen)
+		    const struct hfa384x_usb_rridresp *rridresp,
+		    void *riddata,
+		    unsigned int riddatalen)
 {
 	completor->head.complete = usbctlx_rrid_completor_fn;
 	completor->rridresp = rridresp;
@@ -771,9 +771,9 @@ static int usbctlx_rmem_completor_fn(struct usbctlx_completor *head)
 
 static inline struct usbctlx_completor *
 init_rmem_completor(struct usbctlx_rmem_completor *completor,
-			struct hfa384x_usb_rmemresp *rmemresp,
-			void *data,
-			unsigned int len)
+		    struct hfa384x_usb_rmemresp *rmemresp,
+		    void *data,
+		    unsigned int len)
 {
 	completor->head.complete = usbctlx_rmem_completor_fn;
 	completor->rmemresp = rmemresp;
@@ -2343,7 +2343,7 @@ int hfa384x_drvr_readpda(struct hfa384x *hw, void *buf, unsigned int len)
 
 		/* units of bytes */
 		result = hfa384x_dormem_wait(hw, currpage, curroffset, buf,
-						len);
+					     len);
 
 		if (result) {
 			netdev_warn(hw->wlandev->netdev,

commit 1bca0df4ab8649ec875cbc1b2808367fa9587ad0
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Mon Nov 7 18:55:21 2016 +0100

    staging: wlan-ng: replace BUG_ON() into WARN_ON() on hfa384x_usbin_callback
    
    This patch avoids using BUG_ON() from driver,
    and return from hfa384x_usbin_callback with WARN_ON()
    if skb was NULL or data in skb is different from expected one.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/hfa384x_usb.c b/drivers/staging/wlan-ng/hfa384x_usb.c
index d234ed76ab1a..349f12250d77 100644
--- a/drivers/staging/wlan-ng/hfa384x_usb.c
+++ b/drivers/staging/wlan-ng/hfa384x_usb.c
@@ -3057,7 +3057,10 @@ static void hfa384x_usbin_callback(struct urb *urb)
 		goto exit;
 
 	skb = hw->rx_urb_skb;
-	BUG_ON(!skb || (skb->data != urb->transfer_buffer));
+	if (!skb || (skb->data != urb->transfer_buffer)) {
+		WARN_ON(1);
+		return;
+	}
 
 	hw->rx_urb_skb = NULL;
 

commit 3883cd56b536f4ed3c1abd24bfea798ffb7164e1
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Mon Nov 7 18:55:20 2016 +0100

    staging: wlan-ng: remove unnecessary parenthesis in hfa384x_usb.c
    
    This patch removes unnecessary parentheses in different statements of
    hfa384x_usb.c file in order to to comply with the standard kernel
    coding style.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/hfa384x_usb.c b/drivers/staging/wlan-ng/hfa384x_usb.c
index a83026e74c63..d234ed76ab1a 100644
--- a/drivers/staging/wlan-ng/hfa384x_usb.c
+++ b/drivers/staging/wlan-ng/hfa384x_usb.c
@@ -682,7 +682,7 @@ init_cmd_completor(struct usbctlx_cmd_completor *completor,
 	completor->head.complete = usbctlx_cmd_completor_fn;
 	completor->cmdresp = cmdresp;
 	completor->result = result;
-	return &(completor->head);
+	return &completor->head;
 }
 
 /*----------------------------------------------------------------
@@ -729,7 +729,7 @@ init_rrid_completor(struct usbctlx_rrid_completor *completor,
 	completor->rridresp = rridresp;
 	completor->riddata = riddata;
 	completor->riddatalen = riddatalen;
-	return &(completor->head);
+	return &completor->head;
 }
 
 /*----------------------------------------------------------------
@@ -779,7 +779,7 @@ init_rmem_completor(struct usbctlx_rmem_completor *completor,
 	completor->rmemresp = rmemresp;
 	completor->data = data;
 	completor->len = len;
-	return &(completor->head);
+	return &completor->head;
 }
 
 /*----------------------------------------------------------------
@@ -1836,7 +1836,7 @@ int hfa384x_drvr_flashdl_enable(struct hfa384x *hw)
 
 	/* Retrieve the buffer loc&size and timeout */
 	result = hfa384x_drvr_getconfig(hw, HFA384x_RID_DOWNLOADBUFFER,
-					&(hw->bufinfo), sizeof(hw->bufinfo));
+					&hw->bufinfo, sizeof(hw->bufinfo));
 	if (result)
 		return result;
 
@@ -1844,7 +1844,7 @@ int hfa384x_drvr_flashdl_enable(struct hfa384x *hw)
 	hw->bufinfo.offset = le16_to_cpu(hw->bufinfo.offset);
 	hw->bufinfo.len = le16_to_cpu(hw->bufinfo.len);
 	result = hfa384x_drvr_getconfig16(hw, HFA384x_RID_MAXLOADTIME,
-					  &(hw->dltimeout));
+					  &hw->dltimeout);
 	if (result)
 		return result;
 
@@ -2648,7 +2648,7 @@ int hfa384x_drvr_txframe(struct hfa384x *hw, struct sk_buff *skb,
 	    cpu_to_le16(hw->txbuff.txfrm.desc.tx_control);
 
 	/* copy the header over to the txdesc */
-	memcpy(&(hw->txbuff.txfrm.desc.frame_control), p80211_hdr,
+	memcpy(&hw->txbuff.txfrm.desc.frame_control, p80211_hdr,
 	       sizeof(union p80211_hdr));
 
 	/* if we're using host WEP, increase size by IV+ICV */
@@ -2678,9 +2678,9 @@ int hfa384x_drvr_txframe(struct hfa384x *hw, struct sk_buff *skb,
 		memcpy(ptr, p80211_wep->icv, sizeof(p80211_wep->icv));
 
 	/* Send the USB packet */
-	usb_fill_bulk_urb(&(hw->tx_urb), hw->usb,
+	usb_fill_bulk_urb(&hw->tx_urb, hw->usb,
 			  hw->endp_out,
-			  &(hw->txbuff), ROUNDUP64(usbpktlen),
+			  &hw->txbuff, ROUNDUP64(usbpktlen),
 			  hfa384x_usbout_callback, hw->wlandev);
 	hw->tx_urb.transfer_flags |= USB_QUEUE_BULK;
 
@@ -2962,9 +2962,9 @@ static void hfa384x_usbctlxq_run(struct hfa384x *hw)
 		list_move_tail(&head->list, &hw->ctlxq.active);
 
 		/* Fill the out packet */
-		usb_fill_bulk_urb(&(hw->ctlx_urb), hw->usb,
+		usb_fill_bulk_urb(&hw->ctlx_urb, hw->usb,
 				  hw->endp_out,
-				  &(head->outbuf), ROUNDUP64(head->outbufsize),
+				  &head->outbuf, ROUNDUP64(head->outbufsize),
 				  hfa384x_ctlxout_callback, hw);
 		hw->ctlx_urb.transfer_flags |= USB_QUEUE_BULK;
 
@@ -3470,7 +3470,7 @@ static void hfa384x_usbin_rx(struct wlandevice *wlandev, struct sk_buff *skb)
 static void hfa384x_int_rxmonitor(struct wlandevice *wlandev,
 				  struct hfa384x_usb_rxfrm *rxfrm)
 {
-	struct hfa384x_rx_frame *rxdesc = &(rxfrm->desc);
+	struct hfa384x_rx_frame *rxdesc = &rxfrm->desc;
 	unsigned int hdrlen = 0;
 	unsigned int datalen = 0;
 	unsigned int skblen = 0;
@@ -3528,7 +3528,7 @@ static void hfa384x_int_rxmonitor(struct wlandevice *wlandev,
 	 * (ctl frames may be less than a full header)
 	 */
 	datap = skb_put(skb, hdrlen);
-	memcpy(datap, &(rxdesc->frame_control), hdrlen);
+	memcpy(datap, &rxdesc->frame_control, hdrlen);
 
 	/* If any, copy the data from the card to the skb */
 	if (datalen > 0) {

commit a567d0d47ffb31d1f8d8c206db998043911fa256
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Mon Oct 10 16:02:19 2016 +0200

    staging: wlan-ng: Replace data type declaration with variable of same type in hfa384x_usb.c
    
    sizeof(var) instead of sizeof(struct XXX) is preferred.
    Fix it in hfa384x_usb.c file.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/hfa384x_usb.c b/drivers/staging/wlan-ng/hfa384x_usb.c
index fbd9dc6b81ee..a83026e74c63 100644
--- a/drivers/staging/wlan-ng/hfa384x_usb.c
+++ b/drivers/staging/wlan-ng/hfa384x_usb.c
@@ -531,7 +531,7 @@ static void hfa384x_usb_defer(struct work_struct *data)
  */
 void hfa384x_create(struct hfa384x *hw, struct usb_device *usb)
 {
-	memset(hw, 0, sizeof(struct hfa384x));
+	memset(hw, 0, sizeof(*hw));
 	hw->usb = usb;
 
 	/* set up the endpoints */

commit 173bf7e37f71173f1645161ee849dfdc3d577300
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Sun Oct 9 17:13:21 2016 +0200

    staging: wlan-ng: avoid new typedef CTLX_STATE
    
    This patch fixes the following checkpatch.pl warning in hfa384x.h:
    WARNING: do not add new typedefs
    
    It applies for typedef CTLX_STATE
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/hfa384x_usb.c b/drivers/staging/wlan-ng/hfa384x_usb.c
index 1bfea8db3374..fbd9dc6b81ee 100644
--- a/drivers/staging/wlan-ng/hfa384x_usb.c
+++ b/drivers/staging/wlan-ng/hfa384x_usb.c
@@ -267,7 +267,7 @@ hfa384x_dowmem(struct hfa384x *hw,
 
 static int hfa384x_isgood_pdrcode(u16 pdrcode);
 
-static inline const char *ctlxstr(CTLX_STATE s)
+static inline const char *ctlxstr(enum ctlx_state s)
 {
 	static const char * const ctlx_str[] = {
 		"Initial state",

commit d3fcb8a2769a01cff359de693d2864ae2b43dc8f
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Sun Oct 9 17:10:19 2016 +0200

    staging: wlan-ng: fix block comment warnings in hfa384x_usb.c
    
     This patch fix the following checkpatch.pl warnings in hfa384x_usb.c:
     WARNING: Block comments should align the * on each line
     WARNING: Block comments use a trailing */ on a separate line
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/hfa384x_usb.c b/drivers/staging/wlan-ng/hfa384x_usb.c
index 395690fd0285..1bfea8db3374 100644
--- a/drivers/staging/wlan-ng/hfa384x_usb.c
+++ b/drivers/staging/wlan-ng/hfa384x_usb.c
@@ -1,114 +1,114 @@
 /* src/prism2/driver/hfa384x_usb.c
-*
-* Functions that talk to the USB variantof the Intersil hfa384x MAC
-*
-* Copyright (C) 1999 AbsoluteValue Systems, Inc.  All Rights Reserved.
-* --------------------------------------------------------------------
-*
-* linux-wlan
-*
-*   The contents of this file are subject to the Mozilla Public
-*   License Version 1.1 (the "License"); you may not use this file
-*   except in compliance with the License. You may obtain a copy of
-*   the License at http://www.mozilla.org/MPL/
-*
-*   Software distributed under the License is distributed on an "AS
-*   IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
-*   implied. See the License for the specific language governing
-*   rights and limitations under the License.
-*
-*   Alternatively, the contents of this file may be used under the
-*   terms of the GNU Public License version 2 (the "GPL"), in which
-*   case the provisions of the GPL are applicable instead of the
-*   above.  If you wish to allow the use of your version of this file
-*   only under the terms of the GPL and not to allow others to use
-*   your version of this file under the MPL, indicate your decision
-*   by deleting the provisions above and replace them with the notice
-*   and other provisions required by the GPL.  If you do not delete
-*   the provisions above, a recipient may use your version of this
-*   file under either the MPL or the GPL.
-*
-* --------------------------------------------------------------------
-*
-* Inquiries regarding the linux-wlan Open Source project can be
-* made directly to:
-*
-* AbsoluteValue Systems Inc.
-* info@linux-wlan.com
-* http://www.linux-wlan.com
-*
-* --------------------------------------------------------------------
-*
-* Portions of the development of this software were funded by
-* Intersil Corporation as part of PRISM(R) chipset product development.
-*
-* --------------------------------------------------------------------
-*
-* This file implements functions that correspond to the prism2/hfa384x
-* 802.11 MAC hardware and firmware host interface.
-*
-* The functions can be considered to represent several levels of
-* abstraction.  The lowest level functions are simply C-callable wrappers
-* around the register accesses.  The next higher level represents C-callable
-* prism2 API functions that match the Intersil documentation as closely
-* as is reasonable.  The next higher layer implements common sequences
-* of invocations of the API layer (e.g. write to bap, followed by cmd).
-*
-* Common sequences:
-* hfa384x_drvr_xxx	Highest level abstractions provided by the
-*			hfa384x code.  They are driver defined wrappers
-*			for common sequences.  These functions generally
-*			use the services of the lower levels.
-*
-* hfa384x_drvr_xxxconfig  An example of the drvr level abstraction. These
-*			functions are wrappers for the RID get/set
-*			sequence. They call copy_[to|from]_bap() and
-*			cmd_access(). These functions operate on the
-*			RIDs and buffers without validation. The caller
-*			is responsible for that.
-*
-* API wrapper functions:
-* hfa384x_cmd_xxx	functions that provide access to the f/w commands.
-*			The function arguments correspond to each command
-*			argument, even command arguments that get packed
-*			into single registers.  These functions _just_
-*			issue the command by setting the cmd/parm regs
-*			& reading the status/resp regs.  Additional
-*			activities required to fully use a command
-*			(read/write from/to bap, get/set int status etc.)
-*			are implemented separately.  Think of these as
-*			C-callable prism2 commands.
-*
-* Lowest Layer Functions:
-* hfa384x_docmd_xxx	These functions implement the sequence required
-*			to issue any prism2 command.  Primarily used by the
-*			hfa384x_cmd_xxx functions.
-*
-* hfa384x_bap_xxx	BAP read/write access functions.
-*			Note: we usually use BAP0 for non-interrupt context
-*			 and BAP1 for interrupt context.
-*
-* hfa384x_dl_xxx	download related functions.
-*
-* Driver State Issues:
-* Note that there are two pairs of functions that manage the
-* 'initialized' and 'running' states of the hw/MAC combo.  The four
-* functions are create(), destroy(), start(), and stop().  create()
-* sets up the data structures required to support the hfa384x_*
-* functions and destroy() cleans them up.  The start() function gets
-* the actual hardware running and enables the interrupts.  The stop()
-* function shuts the hardware down.  The sequence should be:
-* create()
-* start()
-*  .
-*  .  Do interesting things w/ the hardware
-*  .
-* stop()
-* destroy()
-*
-* Note that destroy() can be called without calling stop() first.
-* --------------------------------------------------------------------
-*/
+ *
+ * Functions that talk to the USB variantof the Intersil hfa384x MAC
+ *
+ * Copyright (C) 1999 AbsoluteValue Systems, Inc.  All Rights Reserved.
+ * --------------------------------------------------------------------
+ *
+ * linux-wlan
+ *
+ *   The contents of this file are subject to the Mozilla Public
+ *   License Version 1.1 (the "License"); you may not use this file
+ *   except in compliance with the License. You may obtain a copy of
+ *   the License at http://www.mozilla.org/MPL/
+ *
+ *   Software distributed under the License is distributed on an "AS
+ *   IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ *   implied. See the License for the specific language governing
+ *   rights and limitations under the License.
+ *
+ *   Alternatively, the contents of this file may be used under the
+ *   terms of the GNU Public License version 2 (the "GPL"), in which
+ *   case the provisions of the GPL are applicable instead of the
+ *   above.  If you wish to allow the use of your version of this file
+ *   only under the terms of the GPL and not to allow others to use
+ *   your version of this file under the MPL, indicate your decision
+ *   by deleting the provisions above and replace them with the notice
+ *   and other provisions required by the GPL.  If you do not delete
+ *   the provisions above, a recipient may use your version of this
+ *   file under either the MPL or the GPL.
+ *
+ * --------------------------------------------------------------------
+ *
+ * Inquiries regarding the linux-wlan Open Source project can be
+ * made directly to:
+ *
+ * AbsoluteValue Systems Inc.
+ * info@linux-wlan.com
+ * http://www.linux-wlan.com
+ *
+ * --------------------------------------------------------------------
+ *
+ * Portions of the development of this software were funded by
+ * Intersil Corporation as part of PRISM(R) chipset product development.
+ *
+ * --------------------------------------------------------------------
+ *
+ * This file implements functions that correspond to the prism2/hfa384x
+ * 802.11 MAC hardware and firmware host interface.
+ *
+ * The functions can be considered to represent several levels of
+ * abstraction.  The lowest level functions are simply C-callable wrappers
+ * around the register accesses.  The next higher level represents C-callable
+ * prism2 API functions that match the Intersil documentation as closely
+ * as is reasonable.  The next higher layer implements common sequences
+ * of invocations of the API layer (e.g. write to bap, followed by cmd).
+ *
+ * Common sequences:
+ * hfa384x_drvr_xxx	Highest level abstractions provided by the
+ *			hfa384x code.  They are driver defined wrappers
+ *			for common sequences.  These functions generally
+ *			use the services of the lower levels.
+ *
+ * hfa384x_drvr_xxxconfig  An example of the drvr level abstraction. These
+ *			functions are wrappers for the RID get/set
+ *			sequence. They call copy_[to|from]_bap() and
+ *			cmd_access(). These functions operate on the
+ *			RIDs and buffers without validation. The caller
+ *			is responsible for that.
+ *
+ * API wrapper functions:
+ * hfa384x_cmd_xxx	functions that provide access to the f/w commands.
+ *			The function arguments correspond to each command
+ *			argument, even command arguments that get packed
+ *			into single registers.  These functions _just_
+ *			issue the command by setting the cmd/parm regs
+ *			& reading the status/resp regs.  Additional
+ *			activities required to fully use a command
+ *			(read/write from/to bap, get/set int status etc.)
+ *			are implemented separately.  Think of these as
+ *			C-callable prism2 commands.
+ *
+ * Lowest Layer Functions:
+ * hfa384x_docmd_xxx	These functions implement the sequence required
+ *			to issue any prism2 command.  Primarily used by the
+ *			hfa384x_cmd_xxx functions.
+ *
+ * hfa384x_bap_xxx	BAP read/write access functions.
+ *			Note: we usually use BAP0 for non-interrupt context
+ *			 and BAP1 for interrupt context.
+ *
+ * hfa384x_dl_xxx	download related functions.
+ *
+ * Driver State Issues:
+ * Note that there are two pairs of functions that manage the
+ * 'initialized' and 'running' states of the hw/MAC combo.  The four
+ * functions are create(), destroy(), start(), and stop().  create()
+ * sets up the data structures required to support the hfa384x_*
+ * functions and destroy() cleans them up.  The start() function gets
+ * the actual hardware running and enables the interrupts.  The stop()
+ * function shuts the hardware down.  The sequence should be:
+ * create()
+ * start()
+ *  .
+ *  .  Do interesting things w/ the hardware
+ *  .
+ * stop()
+ * destroy()
+ *
+ * Note that destroy() can be called without calling stop() first.
+ * --------------------------------------------------------------------
+ */
 
 #include <linux/module.h>
 #include <linux/kernel.h>
@@ -311,21 +311,22 @@ void dbprint_urb(struct urb *urb)
 #endif
 
 /*----------------------------------------------------------------
-* submit_rx_urb
-*
-* Listen for input data on the BULK-IN pipe. If the pipe has
-* stalled then schedule it to be reset.
-*
-* Arguments:
-*	hw		device struct
-*	memflags	memory allocation flags
-*
-* Returns:
-*	error code from submission
-*
-* Call context:
-*	Any
-----------------------------------------------------------------*/
+ * submit_rx_urb
+ *
+ * Listen for input data on the BULK-IN pipe. If the pipe has
+ * stalled then schedule it to be reset.
+ *
+ * Arguments:
+ *	hw		device struct
+ *	memflags	memory allocation flags
+ *
+ * Returns:
+ *	error code from submission
+ *
+ * Call context:
+ *	Any
+ *----------------------------------------------------------------
+ */
 static int submit_rx_urb(struct hfa384x *hw, gfp_t memflags)
 {
 	struct sk_buff *skb;
@@ -371,23 +372,24 @@ static int submit_rx_urb(struct hfa384x *hw, gfp_t memflags)
 }
 
 /*----------------------------------------------------------------
-* submit_tx_urb
-*
-* Prepares and submits the URB of transmitted data. If the
-* submission fails then it will schedule the output pipe to
-* be reset.
-*
-* Arguments:
-*	hw		device struct
-*	tx_urb		URB of data for transmission
-*	memflags	memory allocation flags
-*
-* Returns:
-*	error code from submission
-*
-* Call context:
-*	Any
-----------------------------------------------------------------*/
+ * submit_tx_urb
+ *
+ * Prepares and submits the URB of transmitted data. If the
+ * submission fails then it will schedule the output pipe to
+ * be reset.
+ *
+ * Arguments:
+ *	hw		device struct
+ *	tx_urb		URB of data for transmission
+ *	memflags	memory allocation flags
+ *
+ * Returns:
+ *	error code from submission
+ *
+ * Call context:
+ *	Any
+ *----------------------------------------------------------------
+ */
 static int submit_tx_urb(struct hfa384x *hw, struct urb *tx_urb, gfp_t memflags)
 {
 	struct net_device *netdev = hw->wlandev->netdev;
@@ -416,21 +418,22 @@ static int submit_tx_urb(struct hfa384x *hw, struct urb *tx_urb, gfp_t memflags)
 }
 
 /*----------------------------------------------------------------
-* hfa394x_usb_defer
-*
-* There are some things that the USB stack cannot do while
-* in interrupt context, so we arrange this function to run
-* in process context.
-*
-* Arguments:
-*	hw	device structure
-*
-* Returns:
-*	nothing
-*
-* Call context:
-*	process (by design)
-----------------------------------------------------------------*/
+ * hfa394x_usb_defer
+ *
+ * There are some things that the USB stack cannot do while
+ * in interrupt context, so we arrange this function to run
+ * in process context.
+ *
+ * Arguments:
+ *	hw	device structure
+ *
+ * Returns:
+ *	nothing
+ *
+ * Call context:
+ *	process (by design)
+ *----------------------------------------------------------------
+ */
 static void hfa384x_usb_defer(struct work_struct *data)
 {
 	struct hfa384x *hw = container_of(data, struct hfa384x, usb_work);
@@ -505,26 +508,27 @@ static void hfa384x_usb_defer(struct work_struct *data)
 }
 
 /*----------------------------------------------------------------
-* hfa384x_create
-*
-* Sets up the struct hfa384x data structure for use.  Note this
-* does _not_ initialize the actual hardware, just the data structures
-* we use to keep track of its state.
-*
-* Arguments:
-*	hw		device structure
-*	irq		device irq number
-*	iobase		i/o base address for register access
-*	membase		memory base address for register access
-*
-* Returns:
-*	nothing
-*
-* Side effects:
-*
-* Call context:
-*	process
-----------------------------------------------------------------*/
+ * hfa384x_create
+ *
+ * Sets up the struct hfa384x data structure for use.  Note this
+ * does _not_ initialize the actual hardware, just the data structures
+ * we use to keep track of its state.
+ *
+ * Arguments:
+ *	hw		device structure
+ *	irq		device irq number
+ *	iobase		i/o base address for register access
+ *	membase		memory base address for register access
+ *
+ * Returns:
+ *	nothing
+ *
+ * Side effects:
+ *
+ * Call context:
+ *	process
+ *----------------------------------------------------------------
+ */
 void hfa384x_create(struct hfa384x *hw, struct usb_device *usb)
 {
 	memset(hw, 0, sizeof(struct hfa384x));
@@ -575,27 +579,28 @@ void hfa384x_create(struct hfa384x *hw, struct usb_device *usb)
 }
 
 /*----------------------------------------------------------------
-* hfa384x_destroy
-*
-* Partner to hfa384x_create().  This function cleans up the hw
-* structure so that it can be freed by the caller using a simple
-* kfree.  Currently, this function is just a placeholder.  If, at some
-* point in the future, an hw in the 'shutdown' state requires a 'deep'
-* kfree, this is where it should be done.  Note that if this function
-* is called on a _running_ hw structure, the drvr_stop() function is
-* called.
-*
-* Arguments:
-*	hw		device structure
-*
-* Returns:
-*	nothing, this function is not allowed to fail.
-*
-* Side effects:
-*
-* Call context:
-*	process
-----------------------------------------------------------------*/
+ * hfa384x_destroy
+ *
+ * Partner to hfa384x_create().  This function cleans up the hw
+ * structure so that it can be freed by the caller using a simple
+ * kfree.  Currently, this function is just a placeholder.  If, at some
+ * point in the future, an hw in the 'shutdown' state requires a 'deep'
+ * kfree, this is where it should be done.  Note that if this function
+ * is called on a _running_ hw structure, the drvr_stop() function is
+ * called.
+ *
+ * Arguments:
+ *	hw		device structure
+ *
+ * Returns:
+ *	nothing, this function is not allowed to fail.
+ *
+ * Side effects:
+ *
+ * Call context:
+ *	process
+ *----------------------------------------------------------------
+ */
 void hfa384x_destroy(struct hfa384x *hw)
 {
 	struct sk_buff *skb;
@@ -649,10 +654,11 @@ usbctlx_get_rridresult(const struct hfa384x_usb_rridresp *rridresp,
 }
 
 /*----------------------------------------------------------------
-* Completor object:
-* This completor must be passed to hfa384x_usbctlx_complete_sync()
-* when processing a CTLX that returns a struct hfa384x_cmdresult structure.
-----------------------------------------------------------------*/
+ * Completor object:
+ * This completor must be passed to hfa384x_usbctlx_complete_sync()
+ * when processing a CTLX that returns a struct hfa384x_cmdresult structure.
+ *----------------------------------------------------------------
+ */
 struct usbctlx_cmd_completor {
 	struct usbctlx_completor head;
 
@@ -680,10 +686,11 @@ init_cmd_completor(struct usbctlx_cmd_completor *completor,
 }
 
 /*----------------------------------------------------------------
-* Completor object:
-* This completor must be passed to hfa384x_usbctlx_complete_sync()
-* when processing a CTLX that reads a RID.
-----------------------------------------------------------------*/
+ * Completor object:
+ * This completor must be passed to hfa384x_usbctlx_complete_sync()
+ * when processing a CTLX that reads a RID.
+ *----------------------------------------------------------------
+ */
 struct usbctlx_rrid_completor {
 	struct usbctlx_completor head;
 
@@ -726,21 +733,24 @@ init_rrid_completor(struct usbctlx_rrid_completor *completor,
 }
 
 /*----------------------------------------------------------------
-* Completor object:
-* Interprets the results of a synchronous RID-write
-----------------------------------------------------------------*/
+ * Completor object:
+ * Interprets the results of a synchronous RID-write
+ *----------------------------------------------------------------
+ */
 #define init_wrid_completor  init_cmd_completor
 
 /*----------------------------------------------------------------
-* Completor object:
-* Interprets the results of a synchronous memory-write
-----------------------------------------------------------------*/
+ * Completor object:
+ * Interprets the results of a synchronous memory-write
+ *----------------------------------------------------------------
+ */
 #define init_wmem_completor  init_cmd_completor
 
 /*----------------------------------------------------------------
-* Completor object:
-* Interprets the results of a synchronous memory-read
-----------------------------------------------------------------*/
+ * Completor object:
+ * Interprets the results of a synchronous memory-read
+ *----------------------------------------------------------------
+ */
 struct usbctlx_rmem_completor {
 	struct usbctlx_completor head;
 
@@ -773,26 +783,27 @@ init_rmem_completor(struct usbctlx_rmem_completor *completor,
 }
 
 /*----------------------------------------------------------------
-* hfa384x_cb_status
-*
-* Ctlx_complete handler for async CMD type control exchanges.
-* mark the hw struct as such.
-*
-* Note: If the handling is changed here, it should probably be
-*       changed in docmd as well.
-*
-* Arguments:
-*	hw		hw struct
-*	ctlx		completed CTLX
-*
-* Returns:
-*	nothing
-*
-* Side effects:
-*
-* Call context:
-*	interrupt
-----------------------------------------------------------------*/
+ * hfa384x_cb_status
+ *
+ * Ctlx_complete handler for async CMD type control exchanges.
+ * mark the hw struct as such.
+ *
+ * Note: If the handling is changed here, it should probably be
+ *       changed in docmd as well.
+ *
+ * Arguments:
+ *	hw		hw struct
+ *	ctlx		completed CTLX
+ *
+ * Returns:
+ *	nothing
+ *
+ * Side effects:
+ *
+ * Call context:
+ *	interrupt
+ *----------------------------------------------------------------
+ */
 static void hfa384x_cb_status(struct hfa384x *hw,
 			      const struct hfa384x_usbctlx *ctlx)
 {
@@ -905,24 +916,25 @@ hfa384x_dowmem_async(struct hfa384x *hw,
 }
 
 /*----------------------------------------------------------------
-* hfa384x_cmd_initialize
-*
-* Issues the initialize command and sets the hw->state based
-* on the result.
-*
-* Arguments:
-*	hw		device structure
-*
-* Returns:
-*	0		success
-*	>0		f/w reported error - f/w status code
-*	<0		driver reported error
-*
-* Side effects:
-*
-* Call context:
-*	process
-----------------------------------------------------------------*/
+ * hfa384x_cmd_initialize
+ *
+ * Issues the initialize command and sets the hw->state based
+ * on the result.
+ *
+ * Arguments:
+ *	hw		device structure
+ *
+ * Returns:
+ *	0		success
+ *	>0		f/w reported error - f/w status code
+ *	<0		driver reported error
+ *
+ * Side effects:
+ *
+ * Call context:
+ *	process
+ *----------------------------------------------------------------
+ */
 int hfa384x_cmd_initialize(struct hfa384x *hw)
 {
 	int result = 0;
@@ -950,25 +962,26 @@ int hfa384x_cmd_initialize(struct hfa384x *hw)
 }
 
 /*----------------------------------------------------------------
-* hfa384x_cmd_disable
-*
-* Issues the disable command to stop communications on one of
-* the MACs 'ports'.
-*
-* Arguments:
-*	hw		device structure
-*	macport		MAC port number (host order)
-*
-* Returns:
-*	0		success
-*	>0		f/w reported failure - f/w status code
-*	<0		driver reported error (timeout|bad arg)
-*
-* Side effects:
-*
-* Call context:
-*	process
-----------------------------------------------------------------*/
+ * hfa384x_cmd_disable
+ *
+ * Issues the disable command to stop communications on one of
+ * the MACs 'ports'.
+ *
+ * Arguments:
+ *	hw		device structure
+ *	macport		MAC port number (host order)
+ *
+ * Returns:
+ *	0		success
+ *	>0		f/w reported failure - f/w status code
+ *	<0		driver reported error (timeout|bad arg)
+ *
+ * Side effects:
+ *
+ * Call context:
+ *	process
+ *----------------------------------------------------------------
+ */
 int hfa384x_cmd_disable(struct hfa384x *hw, u16 macport)
 {
 	struct hfa384x_metacmd cmd;
@@ -983,25 +996,26 @@ int hfa384x_cmd_disable(struct hfa384x *hw, u16 macport)
 }
 
 /*----------------------------------------------------------------
-* hfa384x_cmd_enable
-*
-* Issues the enable command to enable communications on one of
-* the MACs 'ports'.
-*
-* Arguments:
-*	hw		device structure
-*	macport		MAC port number
-*
-* Returns:
-*	0		success
-*	>0		f/w reported failure - f/w status code
-*	<0		driver reported error (timeout|bad arg)
-*
-* Side effects:
-*
-* Call context:
-*	process
-----------------------------------------------------------------*/
+ * hfa384x_cmd_enable
+ *
+ * Issues the enable command to enable communications on one of
+ * the MACs 'ports'.
+ *
+ * Arguments:
+ *	hw		device structure
+ *	macport		MAC port number
+ *
+ * Returns:
+ *	0		success
+ *	>0		f/w reported failure - f/w status code
+ *	<0		driver reported error (timeout|bad arg)
+ *
+ * Side effects:
+ *
+ * Call context:
+ *	process
+ *----------------------------------------------------------------
+ */
 int hfa384x_cmd_enable(struct hfa384x *hw, u16 macport)
 {
 	struct hfa384x_metacmd cmd;
@@ -1016,34 +1030,35 @@ int hfa384x_cmd_enable(struct hfa384x *hw, u16 macport)
 }
 
 /*----------------------------------------------------------------
-* hfa384x_cmd_monitor
-*
-* Enables the 'monitor mode' of the MAC.  Here's the description of
-* monitor mode that I've received thus far:
-*
-*  "The "monitor mode" of operation is that the MAC passes all
-*  frames for which the PLCP checks are correct. All received
-*  MPDUs are passed to the host with MAC Port = 7, with a
-*  receive status of good, FCS error, or undecryptable. Passing
-*  certain MPDUs is a violation of the 802.11 standard, but useful
-*  for a debugging tool."  Normal communication is not possible
-*  while monitor mode is enabled.
-*
-* Arguments:
-*	hw		device structure
-*	enable		a code (0x0b|0x0f) that enables/disables
-*			monitor mode. (host order)
-*
-* Returns:
-*	0		success
-*	>0		f/w reported failure - f/w status code
-*	<0		driver reported error (timeout|bad arg)
-*
-* Side effects:
-*
-* Call context:
-*	process
-----------------------------------------------------------------*/
+ * hfa384x_cmd_monitor
+ *
+ * Enables the 'monitor mode' of the MAC.  Here's the description of
+ * monitor mode that I've received thus far:
+ *
+ *  "The "monitor mode" of operation is that the MAC passes all
+ *  frames for which the PLCP checks are correct. All received
+ *  MPDUs are passed to the host with MAC Port = 7, with a
+ *  receive status of good, FCS error, or undecryptable. Passing
+ *  certain MPDUs is a violation of the 802.11 standard, but useful
+ *  for a debugging tool."  Normal communication is not possible
+ *  while monitor mode is enabled.
+ *
+ * Arguments:
+ *	hw		device structure
+ *	enable		a code (0x0b|0x0f) that enables/disables
+ *			monitor mode. (host order)
+ *
+ * Returns:
+ *	0		success
+ *	>0		f/w reported failure - f/w status code
+ *	<0		driver reported error (timeout|bad arg)
+ *
+ * Side effects:
+ *
+ * Call context:
+ *	process
+ *----------------------------------------------------------------
+ */
 int hfa384x_cmd_monitor(struct hfa384x *hw, u16 enable)
 {
 	struct hfa384x_metacmd cmd;
@@ -1058,43 +1073,44 @@ int hfa384x_cmd_monitor(struct hfa384x *hw, u16 enable)
 }
 
 /*----------------------------------------------------------------
-* hfa384x_cmd_download
-*
-* Sets the controls for the MAC controller code/data download
-* process.  The arguments set the mode and address associated
-* with a download.  Note that the aux registers should be enabled
-* prior to setting one of the download enable modes.
-*
-* Arguments:
-*	hw		device structure
-*	mode		0 - Disable programming and begin code exec
-*			1 - Enable volatile mem programming
-*			2 - Enable non-volatile mem programming
-*			3 - Program non-volatile section from NV download
-*			    buffer.
-*			(host order)
-*	lowaddr
-*	highaddr	For mode 1, sets the high & low order bits of
-*			the "destination address".  This address will be
-*			the execution start address when download is
-*			subsequently disabled.
-*			For mode 2, sets the high & low order bits of
-*			the destination in NV ram.
-*			For modes 0 & 3, should be zero. (host order)
-*			NOTE: these are CMD format.
-*	codelen		Length of the data to write in mode 2,
-*			zero otherwise. (host order)
-*
-* Returns:
-*	0		success
-*	>0		f/w reported failure - f/w status code
-*	<0		driver reported error (timeout|bad arg)
-*
-* Side effects:
-*
-* Call context:
-*	process
-----------------------------------------------------------------*/
+ * hfa384x_cmd_download
+ *
+ * Sets the controls for the MAC controller code/data download
+ * process.  The arguments set the mode and address associated
+ * with a download.  Note that the aux registers should be enabled
+ * prior to setting one of the download enable modes.
+ *
+ * Arguments:
+ *	hw		device structure
+ *	mode		0 - Disable programming and begin code exec
+ *			1 - Enable volatile mem programming
+ *			2 - Enable non-volatile mem programming
+ *			3 - Program non-volatile section from NV download
+ *			    buffer.
+ *			(host order)
+ *	lowaddr
+ *	highaddr	For mode 1, sets the high & low order bits of
+ *			the "destination address".  This address will be
+ *			the execution start address when download is
+ *			subsequently disabled.
+ *			For mode 2, sets the high & low order bits of
+ *			the destination in NV ram.
+ *			For modes 0 & 3, should be zero. (host order)
+ *			NOTE: these are CMD format.
+ *	codelen		Length of the data to write in mode 2,
+ *			zero otherwise. (host order)
+ *
+ * Returns:
+ *	0		success
+ *	>0		f/w reported failure - f/w status code
+ *	<0		driver reported error (timeout|bad arg)
+ *
+ * Side effects:
+ *
+ * Call context:
+ *	process
+ *----------------------------------------------------------------
+ */
 int hfa384x_cmd_download(struct hfa384x *hw, u16 mode, u16 lowaddr,
 			 u16 highaddr, u16 codelen)
 {
@@ -1114,28 +1130,29 @@ int hfa384x_cmd_download(struct hfa384x *hw, u16 mode, u16 lowaddr,
 }
 
 /*----------------------------------------------------------------
-* hfa384x_corereset
-*
-* Perform a reset of the hfa38xx MAC core.  We assume that the hw
-* structure is in its "created" state.  That is, it is initialized
-* with proper values.  Note that if a reset is done after the
-* device has been active for awhile, the caller might have to clean
-* up some leftover cruft in the hw structure.
-*
-* Arguments:
-*	hw		device structure
-*	holdtime	how long (in ms) to hold the reset
-*	settletime	how long (in ms) to wait after releasing
-*			the reset
-*
-* Returns:
-*	nothing
-*
-* Side effects:
-*
-* Call context:
-*	process
-----------------------------------------------------------------*/
+ * hfa384x_corereset
+ *
+ * Perform a reset of the hfa38xx MAC core.  We assume that the hw
+ * structure is in its "created" state.  That is, it is initialized
+ * with proper values.  Note that if a reset is done after the
+ * device has been active for awhile, the caller might have to clean
+ * up some leftover cruft in the hw structure.
+ *
+ * Arguments:
+ *	hw		device structure
+ *	holdtime	how long (in ms) to hold the reset
+ *	settletime	how long (in ms) to wait after releasing
+ *			the reset
+ *
+ * Returns:
+ *	nothing
+ *
+ * Side effects:
+ *
+ * Call context:
+ *	process
+ *----------------------------------------------------------------
+ */
 int hfa384x_corereset(struct hfa384x *hw, int holdtime,
 		      int settletime, int genesis)
 {
@@ -1151,29 +1168,30 @@ int hfa384x_corereset(struct hfa384x *hw, int holdtime,
 }
 
 /*----------------------------------------------------------------
-* hfa384x_usbctlx_complete_sync
-*
-* Waits for a synchronous CTLX object to complete,
-* and then handles the response.
-*
-* Arguments:
-*	hw		device structure
-*	ctlx		CTLX ptr
-*	completor	functor object to decide what to
-*			do with the CTLX's result.
-*
-* Returns:
-*	0		Success
-*	-ERESTARTSYS	Interrupted by a signal
-*	-EIO		CTLX failed
-*	-ENODEV		Adapter was unplugged
-*	???		Result from completor
-*
-* Side effects:
-*
-* Call context:
-*	process
-----------------------------------------------------------------*/
+ * hfa384x_usbctlx_complete_sync
+ *
+ * Waits for a synchronous CTLX object to complete,
+ * and then handles the response.
+ *
+ * Arguments:
+ *	hw		device structure
+ *	ctlx		CTLX ptr
+ *	completor	functor object to decide what to
+ *			do with the CTLX's result.
+ *
+ * Returns:
+ *	0		Success
+ *	-ERESTARTSYS	Interrupted by a signal
+ *	-EIO		CTLX failed
+ *	-ENODEV		Adapter was unplugged
+ *	???		Result from completor
+ *
+ * Side effects:
+ *
+ * Call context:
+ *	process
+ *----------------------------------------------------------------
+ */
 static int hfa384x_usbctlx_complete_sync(struct hfa384x *hw,
 					 struct hfa384x_usbctlx *ctlx,
 					 struct usbctlx_completor *completor)
@@ -1258,37 +1276,38 @@ static int hfa384x_usbctlx_complete_sync(struct hfa384x *hw,
 }
 
 /*----------------------------------------------------------------
-* hfa384x_docmd
-*
-* Constructs a command CTLX and submits it.
-*
-* NOTE: Any changes to the 'post-submit' code in this function
-*       need to be carried over to hfa384x_cbcmd() since the handling
-*       is virtually identical.
-*
-* Arguments:
-*	hw		device structure
-*	mode		DOWAIT or DOASYNC
-*       cmd             cmd structure.  Includes all arguments and result
-*                       data points.  All in host order. in host order
-*	cmdcb		command-specific callback
-*	usercb		user callback for async calls, NULL for DOWAIT calls
-*	usercb_data	user supplied data pointer for async calls, NULL
-*			for DOASYNC calls
-*
-* Returns:
-*	0		success
-*	-EIO		CTLX failure
-*	-ERESTARTSYS	Awakened on signal
-*	>0		command indicated error, Status and Resp0-2 are
-*			in hw structure.
-*
-* Side effects:
-*
-*
-* Call context:
-*	process
-----------------------------------------------------------------*/
+ * hfa384x_docmd
+ *
+ * Constructs a command CTLX and submits it.
+ *
+ * NOTE: Any changes to the 'post-submit' code in this function
+ *       need to be carried over to hfa384x_cbcmd() since the handling
+ *       is virtually identical.
+ *
+ * Arguments:
+ *	hw		device structure
+ *	mode		DOWAIT or DOASYNC
+ *       cmd             cmd structure.  Includes all arguments and result
+ *                       data points.  All in host order. in host order
+ *	cmdcb		command-specific callback
+ *	usercb		user callback for async calls, NULL for DOWAIT calls
+ *	usercb_data	user supplied data pointer for async calls, NULL
+ *			for DOASYNC calls
+ *
+ * Returns:
+ *	0		success
+ *	-EIO		CTLX failure
+ *	-ERESTARTSYS	Awakened on signal
+ *	>0		command indicated error, Status and Resp0-2 are
+ *			in hw structure.
+ *
+ * Side effects:
+ *
+ *
+ * Call context:
+ *	process
+ *----------------------------------------------------------------
+ */
 static int
 hfa384x_docmd(struct hfa384x *hw,
 	      enum cmd_mode mode,
@@ -1342,41 +1361,42 @@ hfa384x_docmd(struct hfa384x *hw,
 }
 
 /*----------------------------------------------------------------
-* hfa384x_dorrid
-*
-* Constructs a read rid CTLX and issues it.
-*
-* NOTE: Any changes to the 'post-submit' code in this function
-*       need to be carried over to hfa384x_cbrrid() since the handling
-*       is virtually identical.
-*
-* Arguments:
-*	hw		device structure
-*	mode		DOWAIT or DOASYNC
-*	rid		Read RID number (host order)
-*	riddata		Caller supplied buffer that MAC formatted RID.data
-*			record will be written to for DOWAIT calls. Should
-*			be NULL for DOASYNC calls.
-*	riddatalen	Buffer length for DOWAIT calls. Zero for DOASYNC calls.
-*	cmdcb		command callback for async calls, NULL for DOWAIT calls
-*	usercb		user callback for async calls, NULL for DOWAIT calls
-*	usercb_data	user supplied data pointer for async calls, NULL
-*			for DOWAIT calls
-*
-* Returns:
-*	0		success
-*	-EIO		CTLX failure
-*	-ERESTARTSYS	Awakened on signal
-*	-ENODATA	riddatalen != macdatalen
-*	>0		command indicated error, Status and Resp0-2 are
-*			in hw structure.
-*
-* Side effects:
-*
-* Call context:
-*	interrupt (DOASYNC)
-*	process (DOWAIT or DOASYNC)
-----------------------------------------------------------------*/
+ * hfa384x_dorrid
+ *
+ * Constructs a read rid CTLX and issues it.
+ *
+ * NOTE: Any changes to the 'post-submit' code in this function
+ *       need to be carried over to hfa384x_cbrrid() since the handling
+ *       is virtually identical.
+ *
+ * Arguments:
+ *	hw		device structure
+ *	mode		DOWAIT or DOASYNC
+ *	rid		Read RID number (host order)
+ *	riddata		Caller supplied buffer that MAC formatted RID.data
+ *			record will be written to for DOWAIT calls. Should
+ *			be NULL for DOASYNC calls.
+ *	riddatalen	Buffer length for DOWAIT calls. Zero for DOASYNC calls.
+ *	cmdcb		command callback for async calls, NULL for DOWAIT calls
+ *	usercb		user callback for async calls, NULL for DOWAIT calls
+ *	usercb_data	user supplied data pointer for async calls, NULL
+ *			for DOWAIT calls
+ *
+ * Returns:
+ *	0		success
+ *	-EIO		CTLX failure
+ *	-ERESTARTSYS	Awakened on signal
+ *	-ENODATA	riddatalen != macdatalen
+ *	>0		command indicated error, Status and Resp0-2 are
+ *			in hw structure.
+ *
+ * Side effects:
+ *
+ * Call context:
+ *	interrupt (DOASYNC)
+ *	process (DOWAIT or DOASYNC)
+ *----------------------------------------------------------------
+ */
 static int
 hfa384x_dorrid(struct hfa384x *hw,
 	       enum cmd_mode mode,
@@ -1427,37 +1447,38 @@ hfa384x_dorrid(struct hfa384x *hw,
 }
 
 /*----------------------------------------------------------------
-* hfa384x_dowrid
-*
-* Constructs a write rid CTLX and issues it.
-*
-* NOTE: Any changes to the 'post-submit' code in this function
-*       need to be carried over to hfa384x_cbwrid() since the handling
-*       is virtually identical.
-*
-* Arguments:
-*	hw		device structure
-*	enum cmd_mode	DOWAIT or DOASYNC
-*	rid		RID code
-*	riddata		Data portion of RID formatted for MAC
-*	riddatalen	Length of the data portion in bytes
-*       cmdcb           command callback for async calls, NULL for DOWAIT calls
-*	usercb		user callback for async calls, NULL for DOWAIT calls
-*	usercb_data	user supplied data pointer for async calls
-*
-* Returns:
-*	0		success
-*	-ETIMEDOUT	timed out waiting for register ready or
-*			command completion
-*	>0		command indicated error, Status and Resp0-2 are
-*			in hw structure.
-*
-* Side effects:
-*
-* Call context:
-*	interrupt (DOASYNC)
-*	process (DOWAIT or DOASYNC)
-----------------------------------------------------------------*/
+ * hfa384x_dowrid
+ *
+ * Constructs a write rid CTLX and issues it.
+ *
+ * NOTE: Any changes to the 'post-submit' code in this function
+ *       need to be carried over to hfa384x_cbwrid() since the handling
+ *       is virtually identical.
+ *
+ * Arguments:
+ *	hw		device structure
+ *	enum cmd_mode	DOWAIT or DOASYNC
+ *	rid		RID code
+ *	riddata		Data portion of RID formatted for MAC
+ *	riddatalen	Length of the data portion in bytes
+ *       cmdcb           command callback for async calls, NULL for DOWAIT calls
+ *	usercb		user callback for async calls, NULL for DOWAIT calls
+ *	usercb_data	user supplied data pointer for async calls
+ *
+ * Returns:
+ *	0		success
+ *	-ETIMEDOUT	timed out waiting for register ready or
+ *			command completion
+ *	>0		command indicated error, Status and Resp0-2 are
+ *			in hw structure.
+ *
+ * Side effects:
+ *
+ * Call context:
+ *	interrupt (DOASYNC)
+ *	process (DOWAIT or DOASYNC)
+ *----------------------------------------------------------------
+ */
 static int
 hfa384x_dowrid(struct hfa384x *hw,
 	       enum cmd_mode mode,
@@ -1513,38 +1534,39 @@ hfa384x_dowrid(struct hfa384x *hw,
 }
 
 /*----------------------------------------------------------------
-* hfa384x_dormem
-*
-* Constructs a readmem CTLX and issues it.
-*
-* NOTE: Any changes to the 'post-submit' code in this function
-*       need to be carried over to hfa384x_cbrmem() since the handling
-*       is virtually identical.
-*
-* Arguments:
-*	hw		device structure
-*	mode		DOWAIT or DOASYNC
-*	page		MAC address space page (CMD format)
-*	offset		MAC address space offset
-*	data		Ptr to data buffer to receive read
-*	len		Length of the data to read (max == 2048)
-*	cmdcb		command callback for async calls, NULL for DOWAIT calls
-*	usercb		user callback for async calls, NULL for DOWAIT calls
-*	usercb_data	user supplied data pointer for async calls
-*
-* Returns:
-*	0		success
-*	-ETIMEDOUT	timed out waiting for register ready or
-*			command completion
-*	>0		command indicated error, Status and Resp0-2 are
-*			in hw structure.
-*
-* Side effects:
-*
-* Call context:
-*	interrupt (DOASYNC)
-*	process (DOWAIT or DOASYNC)
-----------------------------------------------------------------*/
+ * hfa384x_dormem
+ *
+ * Constructs a readmem CTLX and issues it.
+ *
+ * NOTE: Any changes to the 'post-submit' code in this function
+ *       need to be carried over to hfa384x_cbrmem() since the handling
+ *       is virtually identical.
+ *
+ * Arguments:
+ *	hw		device structure
+ *	mode		DOWAIT or DOASYNC
+ *	page		MAC address space page (CMD format)
+ *	offset		MAC address space offset
+ *	data		Ptr to data buffer to receive read
+ *	len		Length of the data to read (max == 2048)
+ *	cmdcb		command callback for async calls, NULL for DOWAIT calls
+ *	usercb		user callback for async calls, NULL for DOWAIT calls
+ *	usercb_data	user supplied data pointer for async calls
+ *
+ * Returns:
+ *	0		success
+ *	-ETIMEDOUT	timed out waiting for register ready or
+ *			command completion
+ *	>0		command indicated error, Status and Resp0-2 are
+ *			in hw structure.
+ *
+ * Side effects:
+ *
+ * Call context:
+ *	interrupt (DOASYNC)
+ *	process (DOWAIT or DOASYNC)
+ *----------------------------------------------------------------
+ */
 static int
 hfa384x_dormem(struct hfa384x *hw,
 	       enum cmd_mode mode,
@@ -1604,38 +1626,39 @@ hfa384x_dormem(struct hfa384x *hw,
 }
 
 /*----------------------------------------------------------------
-* hfa384x_dowmem
-*
-* Constructs a writemem CTLX and issues it.
-*
-* NOTE: Any changes to the 'post-submit' code in this function
-*       need to be carried over to hfa384x_cbwmem() since the handling
-*       is virtually identical.
-*
-* Arguments:
-*	hw		device structure
-*	mode		DOWAIT or DOASYNC
-*	page		MAC address space page (CMD format)
-*	offset		MAC address space offset
-*	data		Ptr to data buffer containing write data
-*	len		Length of the data to read (max == 2048)
-*	cmdcb		command callback for async calls, NULL for DOWAIT calls
-*	usercb		user callback for async calls, NULL for DOWAIT calls
-*	usercb_data	user supplied data pointer for async calls.
-*
-* Returns:
-*	0		success
-*	-ETIMEDOUT	timed out waiting for register ready or
-*			command completion
-*	>0		command indicated error, Status and Resp0-2 are
-*			in hw structure.
-*
-* Side effects:
-*
-* Call context:
-*	interrupt (DOWAIT)
-*	process (DOWAIT or DOASYNC)
-----------------------------------------------------------------*/
+ * hfa384x_dowmem
+ *
+ * Constructs a writemem CTLX and issues it.
+ *
+ * NOTE: Any changes to the 'post-submit' code in this function
+ *       need to be carried over to hfa384x_cbwmem() since the handling
+ *       is virtually identical.
+ *
+ * Arguments:
+ *	hw		device structure
+ *	mode		DOWAIT or DOASYNC
+ *	page		MAC address space page (CMD format)
+ *	offset		MAC address space offset
+ *	data		Ptr to data buffer containing write data
+ *	len		Length of the data to read (max == 2048)
+ *	cmdcb		command callback for async calls, NULL for DOWAIT calls
+ *	usercb		user callback for async calls, NULL for DOWAIT calls
+ *	usercb_data	user supplied data pointer for async calls.
+ *
+ * Returns:
+ *	0		success
+ *	-ETIMEDOUT	timed out waiting for register ready or
+ *			command completion
+ *	>0		command indicated error, Status and Resp0-2 are
+ *			in hw structure.
+ *
+ * Side effects:
+ *
+ * Call context:
+ *	interrupt (DOWAIT)
+ *	process (DOWAIT or DOASYNC)
+ *----------------------------------------------------------------
+ */
 static int
 hfa384x_dowmem(struct hfa384x *hw,
 	       enum cmd_mode mode,
@@ -1695,27 +1718,28 @@ hfa384x_dowmem(struct hfa384x *hw,
 }
 
 /*----------------------------------------------------------------
-* hfa384x_drvr_disable
-*
-* Issues the disable command to stop communications on one of
-* the MACs 'ports'.  Only macport 0 is valid  for stations.
-* APs may also disable macports 1-6.  Only ports that have been
-* previously enabled may be disabled.
-*
-* Arguments:
-*	hw		device structure
-*	macport		MAC port number (host order)
-*
-* Returns:
-*	0		success
-*	>0		f/w reported failure - f/w status code
-*	<0		driver reported error (timeout|bad arg)
-*
-* Side effects:
-*
-* Call context:
-*	process
-----------------------------------------------------------------*/
+ * hfa384x_drvr_disable
+ *
+ * Issues the disable command to stop communications on one of
+ * the MACs 'ports'.  Only macport 0 is valid  for stations.
+ * APs may also disable macports 1-6.  Only ports that have been
+ * previously enabled may be disabled.
+ *
+ * Arguments:
+ *	hw		device structure
+ *	macport		MAC port number (host order)
+ *
+ * Returns:
+ *	0		success
+ *	>0		f/w reported failure - f/w status code
+ *	<0		driver reported error (timeout|bad arg)
+ *
+ * Side effects:
+ *
+ * Call context:
+ *	process
+ *----------------------------------------------------------------
+ */
 int hfa384x_drvr_disable(struct hfa384x *hw, u16 macport)
 {
 	int result = 0;
@@ -1733,27 +1757,28 @@ int hfa384x_drvr_disable(struct hfa384x *hw, u16 macport)
 }
 
 /*----------------------------------------------------------------
-* hfa384x_drvr_enable
-*
-* Issues the enable command to enable communications on one of
-* the MACs 'ports'.  Only macport 0 is valid  for stations.
-* APs may also enable macports 1-6.  Only ports that are currently
-* disabled may be enabled.
-*
-* Arguments:
-*	hw		device structure
-*	macport		MAC port number
-*
-* Returns:
-*	0		success
-*	>0		f/w reported failure - f/w status code
-*	<0		driver reported error (timeout|bad arg)
-*
-* Side effects:
-*
-* Call context:
-*	process
-----------------------------------------------------------------*/
+ * hfa384x_drvr_enable
+ *
+ * Issues the enable command to enable communications on one of
+ * the MACs 'ports'.  Only macport 0 is valid  for stations.
+ * APs may also enable macports 1-6.  Only ports that are currently
+ * disabled may be enabled.
+ *
+ * Arguments:
+ *	hw		device structure
+ *	macport		MAC port number
+ *
+ * Returns:
+ *	0		success
+ *	>0		f/w reported failure - f/w status code
+ *	<0		driver reported error (timeout|bad arg)
+ *
+ * Side effects:
+ *
+ * Call context:
+ *	process
+ *----------------------------------------------------------------
+ */
 int hfa384x_drvr_enable(struct hfa384x *hw, u16 macport)
 {
 	int result = 0;
@@ -1771,26 +1796,27 @@ int hfa384x_drvr_enable(struct hfa384x *hw, u16 macport)
 }
 
 /*----------------------------------------------------------------
-* hfa384x_drvr_flashdl_enable
-*
-* Begins the flash download state.  Checks to see that we're not
-* already in a download state and that a port isn't enabled.
-* Sets the download state and retrieves the flash download
-* buffer location, buffer size, and timeout length.
-*
-* Arguments:
-*	hw		device structure
-*
-* Returns:
-*	0		success
-*	>0		f/w reported error - f/w status code
-*	<0		driver reported error
-*
-* Side effects:
-*
-* Call context:
-*	process
-----------------------------------------------------------------*/
+ * hfa384x_drvr_flashdl_enable
+ *
+ * Begins the flash download state.  Checks to see that we're not
+ * already in a download state and that a port isn't enabled.
+ * Sets the download state and retrieves the flash download
+ * buffer location, buffer size, and timeout length.
+ *
+ * Arguments:
+ *	hw		device structure
+ *
+ * Returns:
+ *	0		success
+ *	>0		f/w reported error - f/w status code
+ *	<0		driver reported error
+ *
+ * Side effects:
+ *
+ * Call context:
+ *	process
+ *----------------------------------------------------------------
+ */
 int hfa384x_drvr_flashdl_enable(struct hfa384x *hw)
 {
 	int result = 0;
@@ -1832,24 +1858,25 @@ int hfa384x_drvr_flashdl_enable(struct hfa384x *hw)
 }
 
 /*----------------------------------------------------------------
-* hfa384x_drvr_flashdl_disable
-*
-* Ends the flash download state.  Note that this will cause the MAC
-* firmware to restart.
-*
-* Arguments:
-*	hw		device structure
-*
-* Returns:
-*	0		success
-*	>0		f/w reported error - f/w status code
-*	<0		driver reported error
-*
-* Side effects:
-*
-* Call context:
-*	process
-----------------------------------------------------------------*/
+ * hfa384x_drvr_flashdl_disable
+ *
+ * Ends the flash download state.  Note that this will cause the MAC
+ * firmware to restart.
+ *
+ * Arguments:
+ *	hw		device structure
+ *
+ * Returns:
+ *	0		success
+ *	>0		f/w reported error - f/w status code
+ *	<0		driver reported error
+ *
+ * Side effects:
+ *
+ * Call context:
+ *	process
+ *----------------------------------------------------------------
+ */
 int hfa384x_drvr_flashdl_disable(struct hfa384x *hw)
 {
 	/* Check that we're already in the download state */
@@ -1867,34 +1894,35 @@ int hfa384x_drvr_flashdl_disable(struct hfa384x *hw)
 }
 
 /*----------------------------------------------------------------
-* hfa384x_drvr_flashdl_write
-*
-* Performs a FLASH download of a chunk of data. First checks to see
-* that we're in the FLASH download state, then sets the download
-* mode, uses the aux functions to 1) copy the data to the flash
-* buffer, 2) sets the download 'write flash' mode, 3) readback and
-* compare.  Lather rinse, repeat as many times an necessary to get
-* all the given data into flash.
-* When all data has been written using this function (possibly
-* repeatedly), call drvr_flashdl_disable() to end the download state
-* and restart the MAC.
-*
-* Arguments:
-*	hw		device structure
-*	daddr		Card address to write to. (host order)
-*	buf		Ptr to data to write.
-*	len		Length of data (host order).
-*
-* Returns:
-*	0		success
-*	>0		f/w reported error - f/w status code
-*	<0		driver reported error
-*
-* Side effects:
-*
-* Call context:
-*	process
-----------------------------------------------------------------*/
+ * hfa384x_drvr_flashdl_write
+ *
+ * Performs a FLASH download of a chunk of data. First checks to see
+ * that we're in the FLASH download state, then sets the download
+ * mode, uses the aux functions to 1) copy the data to the flash
+ * buffer, 2) sets the download 'write flash' mode, 3) readback and
+ * compare.  Lather rinse, repeat as many times an necessary to get
+ * all the given data into flash.
+ * When all data has been written using this function (possibly
+ * repeatedly), call drvr_flashdl_disable() to end the download state
+ * and restart the MAC.
+ *
+ * Arguments:
+ *	hw		device structure
+ *	daddr		Card address to write to. (host order)
+ *	buf		Ptr to data to write.
+ *	len		Length of data (host order).
+ *
+ * Returns:
+ *	0		success
+ *	>0		f/w reported error - f/w status code
+ *	<0		driver reported error
+ *
+ * Side effects:
+ *
+ * Call context:
+ *	process
+ *----------------------------------------------------------------
+ */
 int hfa384x_drvr_flashdl_write(struct hfa384x *hw, u32 daddr,
 			       void *buf, u32 len)
 {
@@ -2010,30 +2038,31 @@ int hfa384x_drvr_flashdl_write(struct hfa384x *hw, u32 daddr,
 }
 
 /*----------------------------------------------------------------
-* hfa384x_drvr_getconfig
-*
-* Performs the sequence necessary to read a config/info item.
-*
-* Arguments:
-*	hw		device structure
-*	rid		config/info record id (host order)
-*	buf		host side record buffer.  Upon return it will
-*			contain the body portion of the record (minus the
-*			RID and len).
-*	len		buffer length (in bytes, should match record length)
-*
-* Returns:
-*	0		success
-*	>0		f/w reported error - f/w status code
-*	<0		driver reported error
-*	-ENODATA	length mismatch between argument and retrieved
-*			record.
-*
-* Side effects:
-*
-* Call context:
-*	process
-----------------------------------------------------------------*/
+ * hfa384x_drvr_getconfig
+ *
+ * Performs the sequence necessary to read a config/info item.
+ *
+ * Arguments:
+ *	hw		device structure
+ *	rid		config/info record id (host order)
+ *	buf		host side record buffer.  Upon return it will
+ *			contain the body portion of the record (minus the
+ *			RID and len).
+ *	len		buffer length (in bytes, should match record length)
+ *
+ * Returns:
+ *	0		success
+ *	>0		f/w reported error - f/w status code
+ *	<0		driver reported error
+ *	-ENODATA	length mismatch between argument and retrieved
+ *			record.
+ *
+ * Side effects:
+ *
+ * Call context:
+ *	process
+ *----------------------------------------------------------------
+ */
 int hfa384x_drvr_getconfig(struct hfa384x *hw, u16 rid, void *buf, u16 len)
 {
 	return hfa384x_dorrid_wait(hw, rid, buf, len);
@@ -2061,7 +2090,8 @@ int hfa384x_drvr_getconfig(struct hfa384x *hw, u16 rid, void *buf, u16 len)
  *
  * Call context:
  *       process
- ----------------------------------------------------------------*/
+ *----------------------------------------------------------------
+ */
 int
 hfa384x_drvr_setconfig_async(struct hfa384x *hw,
 			     u16 rid,
@@ -2073,23 +2103,24 @@ hfa384x_drvr_setconfig_async(struct hfa384x *hw,
 }
 
 /*----------------------------------------------------------------
-* hfa384x_drvr_ramdl_disable
-*
-* Ends the ram download state.
-*
-* Arguments:
-*	hw		device structure
-*
-* Returns:
-*	0		success
-*	>0		f/w reported error - f/w status code
-*	<0		driver reported error
-*
-* Side effects:
-*
-* Call context:
-*	process
-----------------------------------------------------------------*/
+ * hfa384x_drvr_ramdl_disable
+ *
+ * Ends the ram download state.
+ *
+ * Arguments:
+ *	hw		device structure
+ *
+ * Returns:
+ *	0		success
+ *	>0		f/w reported error - f/w status code
+ *	<0		driver reported error
+ *
+ * Side effects:
+ *
+ * Call context:
+ *	process
+ *----------------------------------------------------------------
+ */
 int hfa384x_drvr_ramdl_disable(struct hfa384x *hw)
 {
 	/* Check that we're already in the download state */
@@ -2107,29 +2138,30 @@ int hfa384x_drvr_ramdl_disable(struct hfa384x *hw)
 }
 
 /*----------------------------------------------------------------
-* hfa384x_drvr_ramdl_enable
-*
-* Begins the ram download state.  Checks to see that we're not
-* already in a download state and that a port isn't enabled.
-* Sets the download state and calls cmd_download with the
-* ENABLE_VOLATILE subcommand and the exeaddr argument.
-*
-* Arguments:
-*	hw		device structure
-*	exeaddr		the card execution address that will be
-*                       jumped to when ramdl_disable() is called
-*			(host order).
-*
-* Returns:
-*	0		success
-*	>0		f/w reported error - f/w status code
-*	<0		driver reported error
-*
-* Side effects:
-*
-* Call context:
-*	process
-----------------------------------------------------------------*/
+ * hfa384x_drvr_ramdl_enable
+ *
+ * Begins the ram download state.  Checks to see that we're not
+ * already in a download state and that a port isn't enabled.
+ * Sets the download state and calls cmd_download with the
+ * ENABLE_VOLATILE subcommand and the exeaddr argument.
+ *
+ * Arguments:
+ *	hw		device structure
+ *	exeaddr		the card execution address that will be
+ *                       jumped to when ramdl_disable() is called
+ *			(host order).
+ *
+ * Returns:
+ *	0		success
+ *	>0		f/w reported error - f/w status code
+ *	<0		driver reported error
+ *
+ * Side effects:
+ *
+ * Call context:
+ *	process
+ *----------------------------------------------------------------
+ */
 int hfa384x_drvr_ramdl_enable(struct hfa384x *hw, u32 exeaddr)
 {
 	int result = 0;
@@ -2174,31 +2206,32 @@ int hfa384x_drvr_ramdl_enable(struct hfa384x *hw, u32 exeaddr)
 }
 
 /*----------------------------------------------------------------
-* hfa384x_drvr_ramdl_write
-*
-* Performs a RAM download of a chunk of data. First checks to see
-* that we're in the RAM download state, then uses the [read|write]mem USB
-* commands to 1) copy the data, 2) readback and compare.  The download
-* state is unaffected.  When all data has been written using
-* this function, call drvr_ramdl_disable() to end the download state
-* and restart the MAC.
-*
-* Arguments:
-*	hw		device structure
-*	daddr		Card address to write to. (host order)
-*	buf		Ptr to data to write.
-*	len		Length of data (host order).
-*
-* Returns:
-*	0		success
-*	>0		f/w reported error - f/w status code
-*	<0		driver reported error
-*
-* Side effects:
-*
-* Call context:
-*	process
-----------------------------------------------------------------*/
+ * hfa384x_drvr_ramdl_write
+ *
+ * Performs a RAM download of a chunk of data. First checks to see
+ * that we're in the RAM download state, then uses the [read|write]mem USB
+ * commands to 1) copy the data, 2) readback and compare.  The download
+ * state is unaffected.  When all data has been written using
+ * this function, call drvr_ramdl_disable() to end the download state
+ * and restart the MAC.
+ *
+ * Arguments:
+ *	hw		device structure
+ *	daddr		Card address to write to. (host order)
+ *	buf		Ptr to data to write.
+ *	len		Length of data (host order).
+ *
+ * Returns:
+ *	0		success
+ *	>0		f/w reported error - f/w status code
+ *	<0		driver reported error
+ *
+ * Side effects:
+ *
+ * Call context:
+ *	process
+ *----------------------------------------------------------------
+ */
 int hfa384x_drvr_ramdl_write(struct hfa384x *hw, u32 daddr, void *buf, u32 len)
 {
 	int result = 0;
@@ -2249,36 +2282,37 @@ int hfa384x_drvr_ramdl_write(struct hfa384x *hw, u32 daddr, void *buf, u32 len)
 }
 
 /*----------------------------------------------------------------
-* hfa384x_drvr_readpda
-*
-* Performs the sequence to read the PDA space.  Note there is no
-* drvr_writepda() function.  Writing a PDA is
-* generally implemented by a calling component via calls to
-* cmd_download and writing to the flash download buffer via the
-* aux regs.
-*
-* Arguments:
-*	hw		device structure
-*	buf		buffer to store PDA in
-*	len		buffer length
-*
-* Returns:
-*	0		success
-*	>0		f/w reported error - f/w status code
-*	<0		driver reported error
-*	-ETIMEDOUT	timeout waiting for the cmd regs to become
-*			available, or waiting for the control reg
-*			to indicate the Aux port is enabled.
-*	-ENODATA	the buffer does NOT contain a valid PDA.
-*			Either the card PDA is bad, or the auxdata
-*			reads are giving us garbage.
-
-*
-* Side effects:
-*
-* Call context:
-*	process or non-card interrupt.
-----------------------------------------------------------------*/
+ * hfa384x_drvr_readpda
+ *
+ * Performs the sequence to read the PDA space.  Note there is no
+ * drvr_writepda() function.  Writing a PDA is
+ * generally implemented by a calling component via calls to
+ * cmd_download and writing to the flash download buffer via the
+ * aux regs.
+ *
+ * Arguments:
+ *	hw		device structure
+ *	buf		buffer to store PDA in
+ *	len		buffer length
+ *
+ * Returns:
+ *	0		success
+ *	>0		f/w reported error - f/w status code
+ *	<0		driver reported error
+ *	-ETIMEDOUT	timeout waiting for the cmd regs to become
+ *			available, or waiting for the control reg
+ *			to indicate the Aux port is enabled.
+ *	-ENODATA	the buffer does NOT contain a valid PDA.
+ *			Either the card PDA is bad, or the auxdata
+ *			reads are giving us garbage.
+ *
+ *
+ * Side effects:
+ *
+ * Call context:
+ *	process or non-card interrupt.
+ *----------------------------------------------------------------
+ */
 int hfa384x_drvr_readpda(struct hfa384x *hw, void *buf, unsigned int len)
 {
 	int result = 0;
@@ -2369,51 +2403,52 @@ int hfa384x_drvr_readpda(struct hfa384x *hw, void *buf, unsigned int len)
 }
 
 /*----------------------------------------------------------------
-* hfa384x_drvr_setconfig
-*
-* Performs the sequence necessary to write a config/info item.
-*
-* Arguments:
-*	hw		device structure
-*	rid		config/info record id (in host order)
-*	buf		host side record buffer
-*	len		buffer length (in bytes)
-*
-* Returns:
-*	0		success
-*	>0		f/w reported error - f/w status code
-*	<0		driver reported error
-*
-* Side effects:
-*
-* Call context:
-*	process
-----------------------------------------------------------------*/
+ * hfa384x_drvr_setconfig
+ *
+ * Performs the sequence necessary to write a config/info item.
+ *
+ * Arguments:
+ *	hw		device structure
+ *	rid		config/info record id (in host order)
+ *	buf		host side record buffer
+ *	len		buffer length (in bytes)
+ *
+ * Returns:
+ *	0		success
+ *	>0		f/w reported error - f/w status code
+ *	<0		driver reported error
+ *
+ * Side effects:
+ *
+ * Call context:
+ *	process
+ *----------------------------------------------------------------
+ */
 int hfa384x_drvr_setconfig(struct hfa384x *hw, u16 rid, void *buf, u16 len)
 {
 	return hfa384x_dowrid_wait(hw, rid, buf, len);
 }
 
 /*----------------------------------------------------------------
-* hfa384x_drvr_start
-*
-* Issues the MAC initialize command, sets up some data structures,
-* and enables the interrupts.  After this function completes, the
-* low-level stuff should be ready for any/all commands.
-*
-* Arguments:
-*	hw		device structure
-* Returns:
-*	0		success
-*	>0		f/w reported error - f/w status code
-*	<0		driver reported error
-*
-* Side effects:
-*
-* Call context:
-*	process
-----------------------------------------------------------------*/
-
+ * hfa384x_drvr_start
+ *
+ * Issues the MAC initialize command, sets up some data structures,
+ * and enables the interrupts.  After this function completes, the
+ * low-level stuff should be ready for any/all commands.
+ *
+ * Arguments:
+ *	hw		device structure
+ * Returns:
+ *	0		success
+ *	>0		f/w reported error - f/w status code
+ *	<0		driver reported error
+ *
+ * Side effects:
+ *
+ * Call context:
+ *	process
+ *----------------------------------------------------------------
+ */
 int hfa384x_drvr_start(struct hfa384x *hw)
 {
 	int result, result1, result2;
@@ -2497,24 +2532,25 @@ int hfa384x_drvr_start(struct hfa384x *hw)
 }
 
 /*----------------------------------------------------------------
-* hfa384x_drvr_stop
-*
-* Shuts down the MAC to the point where it is safe to unload the
-* driver.  Any subsystem that may be holding a data or function
-* ptr into the driver must be cleared/deinitialized.
-*
-* Arguments:
-*	hw		device structure
-* Returns:
-*	0		success
-*	>0		f/w reported error - f/w status code
-*	<0		driver reported error
-*
-* Side effects:
-*
-* Call context:
-*	process
-----------------------------------------------------------------*/
+ * hfa384x_drvr_stop
+ *
+ * Shuts down the MAC to the point where it is safe to unload the
+ * driver.  Any subsystem that may be holding a data or function
+ * ptr into the driver must be cleared/deinitialized.
+ *
+ * Arguments:
+ *	hw		device structure
+ * Returns:
+ *	0		success
+ *	>0		f/w reported error - f/w status code
+ *	<0		driver reported error
+ *
+ * Side effects:
+ *
+ * Call context:
+ *	process
+ *----------------------------------------------------------------
+ */
 int hfa384x_drvr_stop(struct hfa384x *hw)
 {
 	int i;
@@ -2545,26 +2581,27 @@ int hfa384x_drvr_stop(struct hfa384x *hw)
 }
 
 /*----------------------------------------------------------------
-* hfa384x_drvr_txframe
-*
-* Takes a frame from prism2sta and queues it for transmission.
-*
-* Arguments:
-*	hw		device structure
-*	skb		packet buffer struct.  Contains an 802.11
-*			data frame.
-*       p80211_hdr      points to the 802.11 header for the packet.
-* Returns:
-*	0		Success and more buffs available
-*	1		Success but no more buffs
-*	2		Allocation failure
-*	4		Buffer full or queue busy
-*
-* Side effects:
-*
-* Call context:
-*	interrupt
-----------------------------------------------------------------*/
+ * hfa384x_drvr_txframe
+ *
+ * Takes a frame from prism2sta and queues it for transmission.
+ *
+ * Arguments:
+ *	hw		device structure
+ *	skb		packet buffer struct.  Contains an 802.11
+ *			data frame.
+ *       p80211_hdr      points to the 802.11 header for the packet.
+ * Returns:
+ *	0		Success and more buffs available
+ *	1		Success but no more buffs
+ *	2		Allocation failure
+ *	4		Buffer full or queue busy
+ *
+ * Side effects:
+ *
+ * Call context:
+ *	interrupt
+ *----------------------------------------------------------------
+ */
 int hfa384x_drvr_txframe(struct hfa384x *hw, struct sk_buff *skb,
 			 union p80211_hdr *p80211_hdr,
 			 struct p80211_metawep *p80211_wep)
@@ -2679,18 +2716,19 @@ void hfa384x_tx_timeout(struct wlandevice *wlandev)
 }
 
 /*----------------------------------------------------------------
-* hfa384x_usbctlx_reaper_task
-*
-* Tasklet to delete dead CTLX objects
-*
-* Arguments:
-*	data	ptr to a struct hfa384x
-*
-* Returns:
-*
-* Call context:
-*	Interrupt
-----------------------------------------------------------------*/
+ * hfa384x_usbctlx_reaper_task
+ *
+ * Tasklet to delete dead CTLX objects
+ *
+ * Arguments:
+ *	data	ptr to a struct hfa384x
+ *
+ * Returns:
+ *
+ * Call context:
+ *	Interrupt
+ *----------------------------------------------------------------
+ */
 static void hfa384x_usbctlx_reaper_task(unsigned long data)
 {
 	struct hfa384x *hw = (struct hfa384x *)data;
@@ -2711,19 +2749,20 @@ static void hfa384x_usbctlx_reaper_task(unsigned long data)
 }
 
 /*----------------------------------------------------------------
-* hfa384x_usbctlx_completion_task
-*
-* Tasklet to call completion handlers for returned CTLXs
-*
-* Arguments:
-*	data	ptr to struct hfa384x
-*
-* Returns:
-*	Nothing
-*
-* Call context:
-*	Interrupt
-----------------------------------------------------------------*/
+ * hfa384x_usbctlx_completion_task
+ *
+ * Tasklet to call completion handlers for returned CTLXs
+ *
+ * Arguments:
+ *	data	ptr to struct hfa384x
+ *
+ * Returns:
+ *	Nothing
+ *
+ * Call context:
+ *	Interrupt
+ *----------------------------------------------------------------
+ */
 static void hfa384x_usbctlx_completion_task(unsigned long data)
 {
 	struct hfa384x *hw = (struct hfa384x *)data;
@@ -2784,22 +2823,23 @@ static void hfa384x_usbctlx_completion_task(unsigned long data)
 }
 
 /*----------------------------------------------------------------
-* unlocked_usbctlx_cancel_async
-*
-* Mark the CTLX dead asynchronously, and ensure that the
-* next command on the queue is run afterwards.
-*
-* Arguments:
-*	hw	ptr to the struct hfa384x structure
-*	ctlx	ptr to a CTLX structure
-*
-* Returns:
-*	0	the CTLX's URB is inactive
-* -EINPROGRESS	the URB is currently being unlinked
-*
-* Call context:
-*	Either process or interrupt, but presumably interrupt
-----------------------------------------------------------------*/
+ * unlocked_usbctlx_cancel_async
+ *
+ * Mark the CTLX dead asynchronously, and ensure that the
+ * next command on the queue is run afterwards.
+ *
+ * Arguments:
+ *	hw	ptr to the struct hfa384x structure
+ *	ctlx	ptr to a CTLX structure
+ *
+ * Returns:
+ *	0	the CTLX's URB is inactive
+ * -EINPROGRESS	the URB is currently being unlinked
+ *
+ * Call context:
+ *	Either process or interrupt, but presumably interrupt
+ *----------------------------------------------------------------
+ */
 static int unlocked_usbctlx_cancel_async(struct hfa384x *hw,
 					 struct hfa384x_usbctlx *ctlx)
 {
@@ -2829,27 +2869,28 @@ static int unlocked_usbctlx_cancel_async(struct hfa384x *hw,
 }
 
 /*----------------------------------------------------------------
-* unlocked_usbctlx_complete
-*
-* A CTLX has completed.  It may have been successful, it may not
-* have been. At this point, the CTLX should be quiescent.  The URBs
-* aren't active and the timers should have been stopped.
-*
-* The CTLX is migrated to the "completing" queue, and the completing
-* tasklet is scheduled.
-*
-* Arguments:
-*	hw		ptr to a struct hfa384x structure
-*	ctlx		ptr to a ctlx structure
-*
-* Returns:
-*	nothing
-*
-* Side effects:
-*
-* Call context:
-*	Either, assume interrupt
-----------------------------------------------------------------*/
+ * unlocked_usbctlx_complete
+ *
+ * A CTLX has completed.  It may have been successful, it may not
+ * have been. At this point, the CTLX should be quiescent.  The URBs
+ * aren't active and the timers should have been stopped.
+ *
+ * The CTLX is migrated to the "completing" queue, and the completing
+ * tasklet is scheduled.
+ *
+ * Arguments:
+ *	hw		ptr to a struct hfa384x structure
+ *	ctlx		ptr to a ctlx structure
+ *
+ * Returns:
+ *	nothing
+ *
+ * Side effects:
+ *
+ * Call context:
+ *	Either, assume interrupt
+ *----------------------------------------------------------------
+ */
 static void unlocked_usbctlx_complete(struct hfa384x *hw,
 				      struct hfa384x_usbctlx *ctlx)
 {
@@ -2875,21 +2916,22 @@ static void unlocked_usbctlx_complete(struct hfa384x *hw,
 }
 
 /*----------------------------------------------------------------
-* hfa384x_usbctlxq_run
-*
-* Checks to see if the head item is running.  If not, starts it.
-*
-* Arguments:
-*	hw	ptr to struct hfa384x
-*
-* Returns:
-*	nothing
-*
-* Side effects:
-*
-* Call context:
-*	any
-----------------------------------------------------------------*/
+ * hfa384x_usbctlxq_run
+ *
+ * Checks to see if the head item is running.  If not, starts it.
+ *
+ * Arguments:
+ *	hw	ptr to struct hfa384x
+ *
+ * Returns:
+ *	nothing
+ *
+ * Side effects:
+ *
+ * Call context:
+ *	any
+ *----------------------------------------------------------------
+ */
 static void hfa384x_usbctlxq_run(struct hfa384x *hw)
 {
 	unsigned long flags;
@@ -2975,21 +3017,22 @@ static void hfa384x_usbctlxq_run(struct hfa384x *hw)
 }
 
 /*----------------------------------------------------------------
-* hfa384x_usbin_callback
-*
-* Callback for URBs on the BULKIN endpoint.
-*
-* Arguments:
-*	urb		ptr to the completed urb
-*
-* Returns:
-*	nothing
-*
-* Side effects:
-*
-* Call context:
-*	interrupt
-----------------------------------------------------------------*/
+ * hfa384x_usbin_callback
+ *
+ * Callback for URBs on the BULKIN endpoint.
+ *
+ * Arguments:
+ *	urb		ptr to the completed urb
+ *
+ * Returns:
+ *	nothing
+ *
+ * Side effects:
+ *
+ * Call context:
+ *	interrupt
+ *----------------------------------------------------------------
+ */
 static void hfa384x_usbin_callback(struct urb *urb)
 {
 	struct wlandevice *wlandev = urb->context;
@@ -3151,25 +3194,26 @@ static void hfa384x_usbin_callback(struct urb *urb)
 }
 
 /*----------------------------------------------------------------
-* hfa384x_usbin_ctlx
-*
-* We've received a URB containing a Prism2 "response" message.
-* This message needs to be matched up with a CTLX on the active
-* queue and our state updated accordingly.
-*
-* Arguments:
-*	hw		ptr to struct hfa384x
-*	usbin		ptr to USB IN packet
-*	urb_status	status of this Bulk-In URB
-*
-* Returns:
-*	nothing
-*
-* Side effects:
-*
-* Call context:
-*	interrupt
-----------------------------------------------------------------*/
+ * hfa384x_usbin_ctlx
+ *
+ * We've received a URB containing a Prism2 "response" message.
+ * This message needs to be matched up with a CTLX on the active
+ * queue and our state updated accordingly.
+ *
+ * Arguments:
+ *	hw		ptr to struct hfa384x
+ *	usbin		ptr to USB IN packet
+ *	urb_status	status of this Bulk-In URB
+ *
+ * Returns:
+ *	nothing
+ *
+ * Side effects:
+ *
+ * Call context:
+ *	interrupt
+ *----------------------------------------------------------------
+ */
 static void hfa384x_usbin_ctlx(struct hfa384x *hw, union hfa384x_usbin *usbin,
 			       int urb_status)
 {
@@ -3273,22 +3317,23 @@ static void hfa384x_usbin_ctlx(struct hfa384x *hw, union hfa384x_usbin *usbin,
 }
 
 /*----------------------------------------------------------------
-* hfa384x_usbin_txcompl
-*
-* At this point we have the results of a previous transmit.
-*
-* Arguments:
-*	wlandev		wlan device
-*	usbin		ptr to the usb transfer buffer
-*
-* Returns:
-*	nothing
-*
-* Side effects:
-*
-* Call context:
-*	interrupt
-----------------------------------------------------------------*/
+ * hfa384x_usbin_txcompl
+ *
+ * At this point we have the results of a previous transmit.
+ *
+ * Arguments:
+ *	wlandev		wlan device
+ *	usbin		ptr to the usb transfer buffer
+ *
+ * Returns:
+ *	nothing
+ *
+ * Side effects:
+ *
+ * Call context:
+ *	interrupt
+ *----------------------------------------------------------------
+ */
 static void hfa384x_usbin_txcompl(struct wlandevice *wlandev,
 				  union hfa384x_usbin *usbin)
 {
@@ -3304,22 +3349,23 @@ static void hfa384x_usbin_txcompl(struct wlandevice *wlandev,
 }
 
 /*----------------------------------------------------------------
-* hfa384x_usbin_rx
-*
-* At this point we have a successful received a rx frame packet.
-*
-* Arguments:
-*	wlandev		wlan device
-*	usbin		ptr to the usb transfer buffer
-*
-* Returns:
-*	nothing
-*
-* Side effects:
-*
-* Call context:
-*	interrupt
-----------------------------------------------------------------*/
+ * hfa384x_usbin_rx
+ *
+ * At this point we have a successful received a rx frame packet.
+ *
+ * Arguments:
+ *	wlandev		wlan device
+ *	usbin		ptr to the usb transfer buffer
+ *
+ * Returns:
+ *	nothing
+ *
+ * Side effects:
+ *
+ * Call context:
+ *	interrupt
+ *----------------------------------------------------------------
+ */
 static void hfa384x_usbin_rx(struct wlandevice *wlandev, struct sk_buff *skb)
 {
 	union hfa384x_usbin *usbin = (union hfa384x_usbin *)skb->data;
@@ -3400,26 +3446,27 @@ static void hfa384x_usbin_rx(struct wlandevice *wlandev, struct sk_buff *skb)
 }
 
 /*----------------------------------------------------------------
-* hfa384x_int_rxmonitor
-*
-* Helper function for int_rx.  Handles monitor frames.
-* Note that this function allocates space for the FCS and sets it
-* to 0xffffffff.  The hfa384x doesn't give us the FCS value but the
-* higher layers expect it.  0xffffffff is used as a flag to indicate
-* the FCS is bogus.
-*
-* Arguments:
-*	wlandev		wlan device structure
-*	rxfrm		rx descriptor read from card in int_rx
-*
-* Returns:
-*	nothing
-*
-* Side effects:
-*	Allocates an skb and passes it up via the PF_PACKET interface.
-* Call context:
-*	interrupt
-----------------------------------------------------------------*/
+ * hfa384x_int_rxmonitor
+ *
+ * Helper function for int_rx.  Handles monitor frames.
+ * Note that this function allocates space for the FCS and sets it
+ * to 0xffffffff.  The hfa384x doesn't give us the FCS value but the
+ * higher layers expect it.  0xffffffff is used as a flag to indicate
+ * the FCS is bogus.
+ *
+ * Arguments:
+ *	wlandev		wlan device structure
+ *	rxfrm		rx descriptor read from card in int_rx
+ *
+ * Returns:
+ *	nothing
+ *
+ * Side effects:
+ *	Allocates an skb and passes it up via the PF_PACKET interface.
+ * Call context:
+ *	interrupt
+ *----------------------------------------------------------------
+ */
 static void hfa384x_int_rxmonitor(struct wlandevice *wlandev,
 				  struct hfa384x_usb_rxfrm *rxfrm)
 {
@@ -3478,7 +3525,8 @@ static void hfa384x_int_rxmonitor(struct wlandevice *wlandev,
 	}
 
 	/* Copy the 802.11 header to the skb
-	   (ctl frames may be less than a full header) */
+	 * (ctl frames may be less than a full header)
+	 */
 	datap = skb_put(skb, hdrlen);
 	memcpy(datap, &(rxdesc->frame_control), hdrlen);
 
@@ -3505,22 +3553,23 @@ static void hfa384x_int_rxmonitor(struct wlandevice *wlandev,
 }
 
 /*----------------------------------------------------------------
-* hfa384x_usbin_info
-*
-* At this point we have a successful received a Prism2 info frame.
-*
-* Arguments:
-*	wlandev		wlan device
-*	usbin		ptr to the usb transfer buffer
-*
-* Returns:
-*	nothing
-*
-* Side effects:
-*
-* Call context:
-*	interrupt
-----------------------------------------------------------------*/
+ * hfa384x_usbin_info
+ *
+ * At this point we have a successful received a Prism2 info frame.
+ *
+ * Arguments:
+ *	wlandev		wlan device
+ *	usbin		ptr to the usb transfer buffer
+ *
+ * Returns:
+ *	nothing
+ *
+ * Side effects:
+ *
+ * Call context:
+ *	interrupt
+ *----------------------------------------------------------------
+ */
 static void hfa384x_usbin_info(struct wlandevice *wlandev,
 			       union hfa384x_usbin *usbin)
 {
@@ -3530,21 +3579,22 @@ static void hfa384x_usbin_info(struct wlandevice *wlandev,
 }
 
 /*----------------------------------------------------------------
-* hfa384x_usbout_callback
-*
-* Callback for URBs on the BULKOUT endpoint.
-*
-* Arguments:
-*	urb		ptr to the completed urb
-*
-* Returns:
-*	nothing
-*
-* Side effects:
-*
-* Call context:
-*	interrupt
-----------------------------------------------------------------*/
+ * hfa384x_usbout_callback
+ *
+ * Callback for URBs on the BULKOUT endpoint.
+ *
+ * Arguments:
+ *	urb		ptr to the completed urb
+ *
+ * Returns:
+ *	nothing
+ *
+ * Side effects:
+ *
+ * Call context:
+ *	interrupt
+ *----------------------------------------------------------------
+ */
 static void hfa384x_usbout_callback(struct urb *urb)
 {
 	struct wlandevice *wlandev = urb->context;
@@ -3605,21 +3655,22 @@ static void hfa384x_usbout_callback(struct urb *urb)
 }
 
 /*----------------------------------------------------------------
-* hfa384x_ctlxout_callback
-*
-* Callback for control data on the BULKOUT endpoint.
-*
-* Arguments:
-*	urb		ptr to the completed urb
-*
-* Returns:
-* nothing
-*
-* Side effects:
-*
-* Call context:
-* interrupt
-----------------------------------------------------------------*/
+ * hfa384x_ctlxout_callback
+ *
+ * Callback for control data on the BULKOUT endpoint.
+ *
+ * Arguments:
+ *	urb		ptr to the completed urb
+ *
+ * Returns:
+ * nothing
+ *
+ * Side effects:
+ *
+ * Call context:
+ * interrupt
+ *----------------------------------------------------------------
+ */
 static void hfa384x_ctlxout_callback(struct urb *urb)
 {
 	struct hfa384x *hw = urb->context;
@@ -3734,23 +3785,24 @@ static void hfa384x_ctlxout_callback(struct urb *urb)
 }
 
 /*----------------------------------------------------------------
-* hfa384x_usbctlx_reqtimerfn
-*
-* Timer response function for CTLX request timeouts.  If this
-* function is called, it means that the callback for the OUT
-* URB containing a Prism2.x XXX_Request was never called.
-*
-* Arguments:
-*	data		a ptr to the struct hfa384x
-*
-* Returns:
-*	nothing
-*
-* Side effects:
-*
-* Call context:
-*	interrupt
-----------------------------------------------------------------*/
+ * hfa384x_usbctlx_reqtimerfn
+ *
+ * Timer response function for CTLX request timeouts.  If this
+ * function is called, it means that the callback for the OUT
+ * URB containing a Prism2.x XXX_Request was never called.
+ *
+ * Arguments:
+ *	data		a ptr to the struct hfa384x
+ *
+ * Returns:
+ *	nothing
+ *
+ * Side effects:
+ *
+ * Call context:
+ *	interrupt
+ *----------------------------------------------------------------
+ */
 static void hfa384x_usbctlx_reqtimerfn(unsigned long data)
 {
 	struct hfa384x *hw = (struct hfa384x *)data;
@@ -3792,23 +3844,24 @@ static void hfa384x_usbctlx_reqtimerfn(unsigned long data)
 }
 
 /*----------------------------------------------------------------
-* hfa384x_usbctlx_resptimerfn
-*
-* Timer response function for CTLX response timeouts.  If this
-* function is called, it means that the callback for the IN
-* URB containing a Prism2.x XXX_Response was never called.
-*
-* Arguments:
-*	data		a ptr to the struct hfa384x
-*
-* Returns:
-*	nothing
-*
-* Side effects:
-*
-* Call context:
-*	interrupt
-----------------------------------------------------------------*/
+ * hfa384x_usbctlx_resptimerfn
+ *
+ * Timer response function for CTLX response timeouts.  If this
+ * function is called, it means that the callback for the IN
+ * URB containing a Prism2.x XXX_Response was never called.
+ *
+ * Arguments:
+ *	data		a ptr to the struct hfa384x
+ *
+ * Returns:
+ *	nothing
+ *
+ * Side effects:
+ *
+ * Call context:
+ *	interrupt
+ *----------------------------------------------------------------
+ */
 static void hfa384x_usbctlx_resptimerfn(unsigned long data)
 {
 	struct hfa384x *hw = (struct hfa384x *)data;
@@ -3834,20 +3887,21 @@ static void hfa384x_usbctlx_resptimerfn(unsigned long data)
 }
 
 /*----------------------------------------------------------------
-* hfa384x_usb_throttlefn
-*
-*
-* Arguments:
-*	data	ptr to hw
-*
-* Returns:
-*	Nothing
-*
-* Side effects:
-*
-* Call context:
-*	Interrupt
-----------------------------------------------------------------*/
+ * hfa384x_usb_throttlefn
+ *
+ *
+ * Arguments:
+ *	data	ptr to hw
+ *
+ * Returns:
+ *	Nothing
+ *
+ * Side effects:
+ *
+ * Call context:
+ *	Interrupt
+ *----------------------------------------------------------------
+ */
 static void hfa384x_usb_throttlefn(unsigned long data)
 {
 	struct hfa384x *hw = (struct hfa384x *)data;
@@ -3873,23 +3927,24 @@ static void hfa384x_usb_throttlefn(unsigned long data)
 }
 
 /*----------------------------------------------------------------
-* hfa384x_usbctlx_submit
-*
-* Called from the doxxx functions to submit a CTLX to the queue
-*
-* Arguments:
-*	hw		ptr to the hw struct
-*	ctlx		ctlx structure to enqueue
-*
-* Returns:
-*	-ENODEV if the adapter is unplugged
-*	0
-*
-* Side effects:
-*
-* Call context:
-*	process or interrupt
-----------------------------------------------------------------*/
+ * hfa384x_usbctlx_submit
+ *
+ * Called from the doxxx functions to submit a CTLX to the queue
+ *
+ * Arguments:
+ *	hw		ptr to the hw struct
+ *	ctlx		ctlx structure to enqueue
+ *
+ * Returns:
+ *	-ENODEV if the adapter is unplugged
+ *	0
+ *
+ * Side effects:
+ *
+ * Call context:
+ *	process or interrupt
+ *----------------------------------------------------------------
+ */
 static int hfa384x_usbctlx_submit(struct hfa384x *hw,
 				  struct hfa384x_usbctlx *ctlx)
 {
@@ -3911,21 +3966,22 @@ static int hfa384x_usbctlx_submit(struct hfa384x *hw,
 }
 
 /*----------------------------------------------------------------
-* hfa384x_isgood_pdrcore
-*
-* Quick check of PDR codes.
-*
-* Arguments:
-*	pdrcode		PDR code number (host order)
-*
-* Returns:
-*	zero		not good.
-*	one		is good.
-*
-* Side effects:
-*
-* Call context:
-----------------------------------------------------------------*/
+ * hfa384x_isgood_pdrcore
+ *
+ * Quick check of PDR codes.
+ *
+ * Arguments:
+ *	pdrcode		PDR code number (host order)
+ *
+ * Returns:
+ *	zero		not good.
+ *	one		is good.
+ *
+ * Side effects:
+ *
+ * Call context:
+ *----------------------------------------------------------------
+ */
 static int hfa384x_isgood_pdrcode(u16 pdrcode)
 {
 	switch (pdrcode) {

commit 5a919c78871d1cd568e8d6ce4844c67c95eccf63
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Sun Oct 9 17:10:18 2016 +0200

    staging: wlan-ng: fix line style warnings in hfa384x_usb.c
    
    This patch fix the following checkpatch.pl warnings in hfa384x_usb.c:
    WARNING: line over 80 characters
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/hfa384x_usb.c b/drivers/staging/wlan-ng/hfa384x_usb.c
index 6a107f8a06e2..395690fd0285 100644
--- a/drivers/staging/wlan-ng/hfa384x_usb.c
+++ b/drivers/staging/wlan-ng/hfa384x_usb.c
@@ -153,8 +153,8 @@ enum cmd_mode {
 static void dbprint_urb(struct urb *urb);
 #endif
 
-static void
-hfa384x_int_rxmonitor(struct wlandevice *wlandev, struct hfa384x_usb_rxfrm *rxfrm);
+static void hfa384x_int_rxmonitor(struct wlandevice *wlandev,
+				  struct hfa384x_usb_rxfrm *rxfrm);
 
 static void hfa384x_usb_defer(struct work_struct *data);
 
@@ -173,7 +173,8 @@ hfa384x_usbin_txcompl(struct wlandevice *wlandev, union hfa384x_usbin *usbin);
 
 static void hfa384x_usbin_rx(struct wlandevice *wlandev, struct sk_buff *skb);
 
-static void hfa384x_usbin_info(struct wlandevice *wlandev, union hfa384x_usbin *usbin);
+static void hfa384x_usbin_info(struct wlandevice *wlandev,
+			       union hfa384x_usbin *usbin);
 
 static void hfa384x_usbin_ctlx(struct hfa384x *hw, union hfa384x_usbin *usbin,
 			       int urb_status);
@@ -193,9 +194,11 @@ static void hfa384x_usbctlx_completion_task(unsigned long data);
 
 static void hfa384x_usbctlx_reaper_task(unsigned long data);
 
-static int hfa384x_usbctlx_submit(struct hfa384x *hw, struct hfa384x_usbctlx *ctlx);
+static int hfa384x_usbctlx_submit(struct hfa384x *hw,
+				  struct hfa384x_usbctlx *ctlx);
 
-static void unlocked_usbctlx_complete(struct hfa384x *hw, struct hfa384x_usbctlx *ctlx);
+static void unlocked_usbctlx_complete(struct hfa384x *hw,
+				      struct hfa384x_usbctlx *ctlx);
 
 struct usbctlx_completor {
 	int (*complete)(struct usbctlx_completor *);
@@ -209,7 +212,8 @@ hfa384x_usbctlx_complete_sync(struct hfa384x *hw,
 static int
 unlocked_usbctlx_cancel_async(struct hfa384x *hw, struct hfa384x_usbctlx *ctlx);
 
-static void hfa384x_cb_status(struct hfa384x *hw, const struct hfa384x_usbctlx *ctlx);
+static void hfa384x_cb_status(struct hfa384x *hw,
+			      const struct hfa384x_usbctlx *ctlx);
 
 static int
 usbctlx_get_status(const struct hfa384x_usb_statusresp *cmdresp,
@@ -664,12 +668,10 @@ static inline int usbctlx_cmd_completor_fn(struct usbctlx_completor *head)
 	return usbctlx_get_status(complete->cmdresp, complete->result);
 }
 
-static inline struct usbctlx_completor *init_cmd_completor(
-						struct usbctlx_cmd_completor
-							*completor,
-						const struct hfa384x_usb_statusresp
-							*cmdresp,
-						struct hfa384x_cmdresult *result)
+static inline struct usbctlx_completor *
+init_cmd_completor(struct usbctlx_cmd_completor *completor,
+			const struct hfa384x_usb_statusresp *cmdresp,
+			struct hfa384x_cmdresult *result)
 {
 	completor->head.complete = usbctlx_cmd_completor_fn;
 	completor->cmdresp = cmdresp;
@@ -710,13 +712,11 @@ static int usbctlx_rrid_completor_fn(struct usbctlx_completor *head)
 	return 0;
 }
 
-static inline struct usbctlx_completor *init_rrid_completor(
-						struct usbctlx_rrid_completor
-							*completor,
-						const struct hfa384x_usb_rridresp
-							*rridresp,
-						void *riddata,
-						unsigned int riddatalen)
+static inline struct usbctlx_completor *
+init_rrid_completor(struct usbctlx_rrid_completor *completor,
+			const struct hfa384x_usb_rridresp *rridresp,
+			void *riddata,
+			unsigned int riddatalen)
 {
 	completor->head.complete = usbctlx_rrid_completor_fn;
 	completor->rridresp = rridresp;
@@ -759,13 +759,11 @@ static int usbctlx_rmem_completor_fn(struct usbctlx_completor *head)
 	return 0;
 }
 
-static inline struct usbctlx_completor *init_rmem_completor(
-						struct usbctlx_rmem_completor
-							*completor,
-						struct hfa384x_usb_rmemresp
-							*rmemresp,
-						void *data,
-						unsigned int len)
+static inline struct usbctlx_completor *
+init_rmem_completor(struct usbctlx_rmem_completor *completor,
+			struct hfa384x_usb_rmemresp *rmemresp,
+			void *data,
+			unsigned int len)
 {
 	completor->head.complete = usbctlx_rmem_completor_fn;
 	completor->rmemresp = rmemresp;
@@ -795,7 +793,8 @@ static inline struct usbctlx_completor *init_rmem_completor(
 * Call context:
 *	interrupt
 ----------------------------------------------------------------*/
-static void hfa384x_cb_status(struct hfa384x *hw, const struct hfa384x_usbctlx *ctlx)
+static void hfa384x_cb_status(struct hfa384x *hw,
+			      const struct hfa384x_usbctlx *ctlx)
 {
 	if (ctlx->usercb) {
 		struct hfa384x_cmdresult cmdresult;
@@ -812,7 +811,8 @@ static void hfa384x_cb_status(struct hfa384x *hw, const struct hfa384x_usbctlx *
 	}
 }
 
-static inline int hfa384x_docmd_wait(struct hfa384x *hw, struct hfa384x_metacmd *cmd)
+static inline int hfa384x_docmd_wait(struct hfa384x *hw,
+				     struct hfa384x_metacmd *cmd)
 {
 	return hfa384x_docmd(hw, DOWAIT, cmd, NULL, NULL, NULL);
 }
@@ -1136,7 +1136,8 @@ int hfa384x_cmd_download(struct hfa384x *hw, u16 mode, u16 lowaddr,
 * Call context:
 *	process
 ----------------------------------------------------------------*/
-int hfa384x_corereset(struct hfa384x *hw, int holdtime, int settletime, int genesis)
+int hfa384x_corereset(struct hfa384x *hw, int holdtime,
+		      int settletime, int genesis)
 {
 	int result;
 
@@ -1894,7 +1895,8 @@ int hfa384x_drvr_flashdl_disable(struct hfa384x *hw)
 * Call context:
 *	process
 ----------------------------------------------------------------*/
-int hfa384x_drvr_flashdl_write(struct hfa384x *hw, u32 daddr, void *buf, u32 len)
+int hfa384x_drvr_flashdl_write(struct hfa384x *hw, u32 daddr,
+			       void *buf, u32 len)
 {
 	int result = 0;
 	u32 dlbufaddr;
@@ -2146,7 +2148,8 @@ int hfa384x_drvr_ramdl_enable(struct hfa384x *hw, u32 exeaddr)
 
 	/* Check that we're not already in a download state */
 	if (hw->dlstate != HFA384x_DLSTATE_DISABLED) {
-		netdev_err(hw->wlandev->netdev, "Download state not disabled.\n");
+		netdev_err(hw->wlandev->netdev,
+			   "Download state not disabled.\n");
 		return -EINVAL;
 	}
 
@@ -2847,7 +2850,8 @@ static int unlocked_usbctlx_cancel_async(struct hfa384x *hw,
 * Call context:
 *	Either, assume interrupt
 ----------------------------------------------------------------*/
-static void unlocked_usbctlx_complete(struct hfa384x *hw, struct hfa384x_usbctlx *ctlx)
+static void unlocked_usbctlx_complete(struct hfa384x *hw,
+				      struct hfa384x_usbctlx *ctlx)
 {
 	/* Timers have been stopped, and ctlx should be in
 	 * a terminal state. Retire it from the "active"
@@ -3886,7 +3890,8 @@ static void hfa384x_usb_throttlefn(unsigned long data)
 * Call context:
 *	process or interrupt
 ----------------------------------------------------------------*/
-static int hfa384x_usbctlx_submit(struct hfa384x *hw, struct hfa384x_usbctlx *ctlx)
+static int hfa384x_usbctlx_submit(struct hfa384x *hw,
+				  struct hfa384x_usbctlx *ctlx)
 {
 	unsigned long flags;
 

commit 5a2214e2e02fd24874b68ac7f5b07ad4d7ad1813
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Wed Sep 28 20:20:19 2016 +0200

    staging: wlang-ng: avoid new typedef: hfa384x_t
    
    This patch fixes the following checkpatch.pl warning in hfa384x.h:
    WARNING: do not add new typedefs
    
    It applies for typedef hfa384x_t
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/hfa384x_usb.c b/drivers/staging/wlan-ng/hfa384x_usb.c
index 7b0aae5dab20..6a107f8a06e2 100644
--- a/drivers/staging/wlan-ng/hfa384x_usb.c
+++ b/drivers/staging/wlan-ng/hfa384x_usb.c
@@ -158,9 +158,9 @@ hfa384x_int_rxmonitor(struct wlandevice *wlandev, struct hfa384x_usb_rxfrm *rxfr
 
 static void hfa384x_usb_defer(struct work_struct *data);
 
-static int submit_rx_urb(hfa384x_t *hw, gfp_t flags);
+static int submit_rx_urb(struct hfa384x *hw, gfp_t flags);
 
-static int submit_tx_urb(hfa384x_t *hw, struct urb *tx_urb, gfp_t flags);
+static int submit_tx_urb(struct hfa384x *hw, struct urb *tx_urb, gfp_t flags);
 
 /*---------------------------------------------------*/
 /* Callbacks */
@@ -175,13 +175,13 @@ static void hfa384x_usbin_rx(struct wlandevice *wlandev, struct sk_buff *skb);
 
 static void hfa384x_usbin_info(struct wlandevice *wlandev, union hfa384x_usbin *usbin);
 
-static void hfa384x_usbin_ctlx(hfa384x_t *hw, union hfa384x_usbin *usbin,
+static void hfa384x_usbin_ctlx(struct hfa384x *hw, union hfa384x_usbin *usbin,
 			       int urb_status);
 
 /*---------------------------------------------------*/
 /* Functions to support the prism2 usb command queue */
 
-static void hfa384x_usbctlxq_run(hfa384x_t *hw);
+static void hfa384x_usbctlxq_run(struct hfa384x *hw);
 
 static void hfa384x_usbctlx_reqtimerfn(unsigned long data);
 
@@ -193,23 +193,23 @@ static void hfa384x_usbctlx_completion_task(unsigned long data);
 
 static void hfa384x_usbctlx_reaper_task(unsigned long data);
 
-static int hfa384x_usbctlx_submit(hfa384x_t *hw, struct hfa384x_usbctlx *ctlx);
+static int hfa384x_usbctlx_submit(struct hfa384x *hw, struct hfa384x_usbctlx *ctlx);
 
-static void unlocked_usbctlx_complete(hfa384x_t *hw, struct hfa384x_usbctlx *ctlx);
+static void unlocked_usbctlx_complete(struct hfa384x *hw, struct hfa384x_usbctlx *ctlx);
 
 struct usbctlx_completor {
 	int (*complete)(struct usbctlx_completor *);
 };
 
 static int
-hfa384x_usbctlx_complete_sync(hfa384x_t *hw,
+hfa384x_usbctlx_complete_sync(struct hfa384x *hw,
 			      struct hfa384x_usbctlx *ctlx,
 			      struct usbctlx_completor *completor);
 
 static int
-unlocked_usbctlx_cancel_async(hfa384x_t *hw, struct hfa384x_usbctlx *ctlx);
+unlocked_usbctlx_cancel_async(struct hfa384x *hw, struct hfa384x_usbctlx *ctlx);
 
-static void hfa384x_cb_status(hfa384x_t *hw, const struct hfa384x_usbctlx *ctlx);
+static void hfa384x_cb_status(struct hfa384x *hw, const struct hfa384x_usbctlx *ctlx);
 
 static int
 usbctlx_get_status(const struct hfa384x_usb_statusresp *cmdresp,
@@ -222,13 +222,13 @@ usbctlx_get_rridresult(const struct hfa384x_usb_rridresp *rridresp,
 /*---------------------------------------------------*/
 /* Low level req/resp CTLX formatters and submitters */
 static int
-hfa384x_docmd(hfa384x_t *hw,
+hfa384x_docmd(struct hfa384x *hw,
 	      enum cmd_mode mode,
 	      struct hfa384x_metacmd *cmd,
 	      ctlx_cmdcb_t cmdcb, ctlx_usercb_t usercb, void *usercb_data);
 
 static int
-hfa384x_dorrid(hfa384x_t *hw,
+hfa384x_dorrid(struct hfa384x *hw,
 	       enum cmd_mode mode,
 	       u16 rid,
 	       void *riddata,
@@ -236,7 +236,7 @@ hfa384x_dorrid(hfa384x_t *hw,
 	       ctlx_cmdcb_t cmdcb, ctlx_usercb_t usercb, void *usercb_data);
 
 static int
-hfa384x_dowrid(hfa384x_t *hw,
+hfa384x_dowrid(struct hfa384x *hw,
 	       enum cmd_mode mode,
 	       u16 rid,
 	       void *riddata,
@@ -244,7 +244,7 @@ hfa384x_dowrid(hfa384x_t *hw,
 	       ctlx_cmdcb_t cmdcb, ctlx_usercb_t usercb, void *usercb_data);
 
 static int
-hfa384x_dormem(hfa384x_t *hw,
+hfa384x_dormem(struct hfa384x *hw,
 	       enum cmd_mode mode,
 	       u16 page,
 	       u16 offset,
@@ -253,7 +253,7 @@ hfa384x_dormem(hfa384x_t *hw,
 	       ctlx_cmdcb_t cmdcb, ctlx_usercb_t usercb, void *usercb_data);
 
 static int
-hfa384x_dowmem(hfa384x_t *hw,
+hfa384x_dowmem(struct hfa384x *hw,
 	       enum cmd_mode mode,
 	       u16 page,
 	       u16 offset,
@@ -278,7 +278,7 @@ static inline const char *ctlxstr(CTLX_STATE s)
 	return ctlx_str[s];
 };
 
-static inline struct hfa384x_usbctlx *get_active_ctlx(hfa384x_t *hw)
+static inline struct hfa384x_usbctlx *get_active_ctlx(struct hfa384x *hw)
 {
 	return list_entry(hw->ctlxq.active.next, struct hfa384x_usbctlx, list);
 }
@@ -322,7 +322,7 @@ void dbprint_urb(struct urb *urb)
 * Call context:
 *	Any
 ----------------------------------------------------------------*/
-static int submit_rx_urb(hfa384x_t *hw, gfp_t memflags)
+static int submit_rx_urb(struct hfa384x *hw, gfp_t memflags)
 {
 	struct sk_buff *skb;
 	int result;
@@ -384,7 +384,7 @@ static int submit_rx_urb(hfa384x_t *hw, gfp_t memflags)
 * Call context:
 *	Any
 ----------------------------------------------------------------*/
-static int submit_tx_urb(hfa384x_t *hw, struct urb *tx_urb, gfp_t memflags)
+static int submit_tx_urb(struct hfa384x *hw, struct urb *tx_urb, gfp_t memflags)
 {
 	struct net_device *netdev = hw->wlandev->netdev;
 	int result;
@@ -429,7 +429,7 @@ static int submit_tx_urb(hfa384x_t *hw, struct urb *tx_urb, gfp_t memflags)
 ----------------------------------------------------------------*/
 static void hfa384x_usb_defer(struct work_struct *data)
 {
-	hfa384x_t *hw = container_of(data, struct hfa384x, usb_work);
+	struct hfa384x *hw = container_of(data, struct hfa384x, usb_work);
 	struct net_device *netdev = hw->wlandev->netdev;
 
 	/* Don't bother trying to reset anything if the plug
@@ -503,7 +503,7 @@ static void hfa384x_usb_defer(struct work_struct *data)
 /*----------------------------------------------------------------
 * hfa384x_create
 *
-* Sets up the hfa384x_t data structure for use.  Note this
+* Sets up the struct hfa384x data structure for use.  Note this
 * does _not_ initialize the actual hardware, just the data structures
 * we use to keep track of its state.
 *
@@ -521,9 +521,9 @@ static void hfa384x_usb_defer(struct work_struct *data)
 * Call context:
 *	process
 ----------------------------------------------------------------*/
-void hfa384x_create(hfa384x_t *hw, struct usb_device *usb)
+void hfa384x_create(struct hfa384x *hw, struct usb_device *usb)
 {
-	memset(hw, 0, sizeof(hfa384x_t));
+	memset(hw, 0, sizeof(struct hfa384x));
 	hw->usb = usb;
 
 	/* set up the endpoints */
@@ -592,7 +592,7 @@ void hfa384x_create(hfa384x_t *hw, struct usb_device *usb)
 * Call context:
 *	process
 ----------------------------------------------------------------*/
-void hfa384x_destroy(hfa384x_t *hw)
+void hfa384x_destroy(struct hfa384x *hw)
 {
 	struct sk_buff *skb;
 
@@ -795,7 +795,7 @@ static inline struct usbctlx_completor *init_rmem_completor(
 * Call context:
 *	interrupt
 ----------------------------------------------------------------*/
-static void hfa384x_cb_status(hfa384x_t *hw, const struct hfa384x_usbctlx *ctlx)
+static void hfa384x_cb_status(struct hfa384x *hw, const struct hfa384x_usbctlx *ctlx)
 {
 	if (ctlx->usercb) {
 		struct hfa384x_cmdresult cmdresult;
@@ -812,13 +812,13 @@ static void hfa384x_cb_status(hfa384x_t *hw, const struct hfa384x_usbctlx *ctlx)
 	}
 }
 
-static inline int hfa384x_docmd_wait(hfa384x_t *hw, struct hfa384x_metacmd *cmd)
+static inline int hfa384x_docmd_wait(struct hfa384x *hw, struct hfa384x_metacmd *cmd)
 {
 	return hfa384x_docmd(hw, DOWAIT, cmd, NULL, NULL, NULL);
 }
 
 static inline int
-hfa384x_docmd_async(hfa384x_t *hw,
+hfa384x_docmd_async(struct hfa384x *hw,
 		    struct hfa384x_metacmd *cmd,
 		    ctlx_cmdcb_t cmdcb, ctlx_usercb_t usercb, void *usercb_data)
 {
@@ -826,7 +826,7 @@ hfa384x_docmd_async(hfa384x_t *hw,
 }
 
 static inline int
-hfa384x_dorrid_wait(hfa384x_t *hw, u16 rid, void *riddata,
+hfa384x_dorrid_wait(struct hfa384x *hw, u16 rid, void *riddata,
 		    unsigned int riddatalen)
 {
 	return hfa384x_dorrid(hw, DOWAIT,
@@ -834,7 +834,7 @@ hfa384x_dorrid_wait(hfa384x_t *hw, u16 rid, void *riddata,
 }
 
 static inline int
-hfa384x_dorrid_async(hfa384x_t *hw,
+hfa384x_dorrid_async(struct hfa384x *hw,
 		     u16 rid, void *riddata, unsigned int riddatalen,
 		     ctlx_cmdcb_t cmdcb,
 		     ctlx_usercb_t usercb, void *usercb_data)
@@ -845,7 +845,7 @@ hfa384x_dorrid_async(hfa384x_t *hw,
 }
 
 static inline int
-hfa384x_dowrid_wait(hfa384x_t *hw, u16 rid, void *riddata,
+hfa384x_dowrid_wait(struct hfa384x *hw, u16 rid, void *riddata,
 		    unsigned int riddatalen)
 {
 	return hfa384x_dowrid(hw, DOWAIT,
@@ -853,7 +853,7 @@ hfa384x_dowrid_wait(hfa384x_t *hw, u16 rid, void *riddata,
 }
 
 static inline int
-hfa384x_dowrid_async(hfa384x_t *hw,
+hfa384x_dowrid_async(struct hfa384x *hw,
 		     u16 rid, void *riddata, unsigned int riddatalen,
 		     ctlx_cmdcb_t cmdcb,
 		     ctlx_usercb_t usercb, void *usercb_data)
@@ -864,7 +864,7 @@ hfa384x_dowrid_async(hfa384x_t *hw,
 }
 
 static inline int
-hfa384x_dormem_wait(hfa384x_t *hw,
+hfa384x_dormem_wait(struct hfa384x *hw,
 		    u16 page, u16 offset, void *data, unsigned int len)
 {
 	return hfa384x_dormem(hw, DOWAIT,
@@ -872,7 +872,7 @@ hfa384x_dormem_wait(hfa384x_t *hw,
 }
 
 static inline int
-hfa384x_dormem_async(hfa384x_t *hw,
+hfa384x_dormem_async(struct hfa384x *hw,
 		     u16 page, u16 offset, void *data, unsigned int len,
 		     ctlx_cmdcb_t cmdcb,
 		     ctlx_usercb_t usercb, void *usercb_data)
@@ -883,7 +883,7 @@ hfa384x_dormem_async(hfa384x_t *hw,
 }
 
 static inline int
-hfa384x_dowmem_wait(hfa384x_t *hw,
+hfa384x_dowmem_wait(struct hfa384x *hw,
 		    u16 page, u16 offset, void *data, unsigned int len)
 {
 	return hfa384x_dowmem(hw, DOWAIT,
@@ -891,7 +891,7 @@ hfa384x_dowmem_wait(hfa384x_t *hw,
 }
 
 static inline int
-hfa384x_dowmem_async(hfa384x_t *hw,
+hfa384x_dowmem_async(struct hfa384x *hw,
 		     u16 page,
 		     u16 offset,
 		     void *data,
@@ -923,7 +923,7 @@ hfa384x_dowmem_async(hfa384x_t *hw,
 * Call context:
 *	process
 ----------------------------------------------------------------*/
-int hfa384x_cmd_initialize(hfa384x_t *hw)
+int hfa384x_cmd_initialize(struct hfa384x *hw)
 {
 	int result = 0;
 	int i;
@@ -969,7 +969,7 @@ int hfa384x_cmd_initialize(hfa384x_t *hw)
 * Call context:
 *	process
 ----------------------------------------------------------------*/
-int hfa384x_cmd_disable(hfa384x_t *hw, u16 macport)
+int hfa384x_cmd_disable(struct hfa384x *hw, u16 macport)
 {
 	struct hfa384x_metacmd cmd;
 
@@ -1002,7 +1002,7 @@ int hfa384x_cmd_disable(hfa384x_t *hw, u16 macport)
 * Call context:
 *	process
 ----------------------------------------------------------------*/
-int hfa384x_cmd_enable(hfa384x_t *hw, u16 macport)
+int hfa384x_cmd_enable(struct hfa384x *hw, u16 macport)
 {
 	struct hfa384x_metacmd cmd;
 
@@ -1044,7 +1044,7 @@ int hfa384x_cmd_enable(hfa384x_t *hw, u16 macport)
 * Call context:
 *	process
 ----------------------------------------------------------------*/
-int hfa384x_cmd_monitor(hfa384x_t *hw, u16 enable)
+int hfa384x_cmd_monitor(struct hfa384x *hw, u16 enable)
 {
 	struct hfa384x_metacmd cmd;
 
@@ -1095,7 +1095,7 @@ int hfa384x_cmd_monitor(hfa384x_t *hw, u16 enable)
 * Call context:
 *	process
 ----------------------------------------------------------------*/
-int hfa384x_cmd_download(hfa384x_t *hw, u16 mode, u16 lowaddr,
+int hfa384x_cmd_download(struct hfa384x *hw, u16 mode, u16 lowaddr,
 			 u16 highaddr, u16 codelen)
 {
 	struct hfa384x_metacmd cmd;
@@ -1136,7 +1136,7 @@ int hfa384x_cmd_download(hfa384x_t *hw, u16 mode, u16 lowaddr,
 * Call context:
 *	process
 ----------------------------------------------------------------*/
-int hfa384x_corereset(hfa384x_t *hw, int holdtime, int settletime, int genesis)
+int hfa384x_corereset(struct hfa384x *hw, int holdtime, int settletime, int genesis)
 {
 	int result;
 
@@ -1173,7 +1173,7 @@ int hfa384x_corereset(hfa384x_t *hw, int holdtime, int settletime, int genesis)
 * Call context:
 *	process
 ----------------------------------------------------------------*/
-static int hfa384x_usbctlx_complete_sync(hfa384x_t *hw,
+static int hfa384x_usbctlx_complete_sync(struct hfa384x *hw,
 					 struct hfa384x_usbctlx *ctlx,
 					 struct usbctlx_completor *completor)
 {
@@ -1289,7 +1289,7 @@ static int hfa384x_usbctlx_complete_sync(hfa384x_t *hw,
 *	process
 ----------------------------------------------------------------*/
 static int
-hfa384x_docmd(hfa384x_t *hw,
+hfa384x_docmd(struct hfa384x *hw,
 	      enum cmd_mode mode,
 	      struct hfa384x_metacmd *cmd,
 	      ctlx_cmdcb_t cmdcb, ctlx_usercb_t usercb, void *usercb_data)
@@ -1377,7 +1377,7 @@ hfa384x_docmd(hfa384x_t *hw,
 *	process (DOWAIT or DOASYNC)
 ----------------------------------------------------------------*/
 static int
-hfa384x_dorrid(hfa384x_t *hw,
+hfa384x_dorrid(struct hfa384x *hw,
 	       enum cmd_mode mode,
 	       u16 rid,
 	       void *riddata,
@@ -1458,7 +1458,7 @@ hfa384x_dorrid(hfa384x_t *hw,
 *	process (DOWAIT or DOASYNC)
 ----------------------------------------------------------------*/
 static int
-hfa384x_dowrid(hfa384x_t *hw,
+hfa384x_dowrid(struct hfa384x *hw,
 	       enum cmd_mode mode,
 	       u16 rid,
 	       void *riddata,
@@ -1545,7 +1545,7 @@ hfa384x_dowrid(hfa384x_t *hw,
 *	process (DOWAIT or DOASYNC)
 ----------------------------------------------------------------*/
 static int
-hfa384x_dormem(hfa384x_t *hw,
+hfa384x_dormem(struct hfa384x *hw,
 	       enum cmd_mode mode,
 	       u16 page,
 	       u16 offset,
@@ -1636,7 +1636,7 @@ hfa384x_dormem(hfa384x_t *hw,
 *	process (DOWAIT or DOASYNC)
 ----------------------------------------------------------------*/
 static int
-hfa384x_dowmem(hfa384x_t *hw,
+hfa384x_dowmem(struct hfa384x *hw,
 	       enum cmd_mode mode,
 	       u16 page,
 	       u16 offset,
@@ -1715,7 +1715,7 @@ hfa384x_dowmem(hfa384x_t *hw,
 * Call context:
 *	process
 ----------------------------------------------------------------*/
-int hfa384x_drvr_disable(hfa384x_t *hw, u16 macport)
+int hfa384x_drvr_disable(struct hfa384x *hw, u16 macport)
 {
 	int result = 0;
 
@@ -1753,7 +1753,7 @@ int hfa384x_drvr_disable(hfa384x_t *hw, u16 macport)
 * Call context:
 *	process
 ----------------------------------------------------------------*/
-int hfa384x_drvr_enable(hfa384x_t *hw, u16 macport)
+int hfa384x_drvr_enable(struct hfa384x *hw, u16 macport)
 {
 	int result = 0;
 
@@ -1790,7 +1790,7 @@ int hfa384x_drvr_enable(hfa384x_t *hw, u16 macport)
 * Call context:
 *	process
 ----------------------------------------------------------------*/
-int hfa384x_drvr_flashdl_enable(hfa384x_t *hw)
+int hfa384x_drvr_flashdl_enable(struct hfa384x *hw)
 {
 	int result = 0;
 	int i;
@@ -1849,7 +1849,7 @@ int hfa384x_drvr_flashdl_enable(hfa384x_t *hw)
 * Call context:
 *	process
 ----------------------------------------------------------------*/
-int hfa384x_drvr_flashdl_disable(hfa384x_t *hw)
+int hfa384x_drvr_flashdl_disable(struct hfa384x *hw)
 {
 	/* Check that we're already in the download state */
 	if (hw->dlstate != HFA384x_DLSTATE_FLASHENABLED)
@@ -1894,7 +1894,7 @@ int hfa384x_drvr_flashdl_disable(hfa384x_t *hw)
 * Call context:
 *	process
 ----------------------------------------------------------------*/
-int hfa384x_drvr_flashdl_write(hfa384x_t *hw, u32 daddr, void *buf, u32 len)
+int hfa384x_drvr_flashdl_write(struct hfa384x *hw, u32 daddr, void *buf, u32 len)
 {
 	int result = 0;
 	u32 dlbufaddr;
@@ -2032,7 +2032,7 @@ int hfa384x_drvr_flashdl_write(hfa384x_t *hw, u32 daddr, void *buf, u32 len)
 * Call context:
 *	process
 ----------------------------------------------------------------*/
-int hfa384x_drvr_getconfig(hfa384x_t *hw, u16 rid, void *buf, u16 len)
+int hfa384x_drvr_getconfig(struct hfa384x *hw, u16 rid, void *buf, u16 len)
 {
 	return hfa384x_dorrid_wait(hw, rid, buf, len);
 }
@@ -2061,7 +2061,7 @@ int hfa384x_drvr_getconfig(hfa384x_t *hw, u16 rid, void *buf, u16 len)
  *       process
  ----------------------------------------------------------------*/
 int
-hfa384x_drvr_setconfig_async(hfa384x_t *hw,
+hfa384x_drvr_setconfig_async(struct hfa384x *hw,
 			     u16 rid,
 			     void *buf,
 			     u16 len, ctlx_usercb_t usercb, void *usercb_data)
@@ -2088,7 +2088,7 @@ hfa384x_drvr_setconfig_async(hfa384x_t *hw,
 * Call context:
 *	process
 ----------------------------------------------------------------*/
-int hfa384x_drvr_ramdl_disable(hfa384x_t *hw)
+int hfa384x_drvr_ramdl_disable(struct hfa384x *hw)
 {
 	/* Check that we're already in the download state */
 	if (hw->dlstate != HFA384x_DLSTATE_RAMENABLED)
@@ -2128,7 +2128,7 @@ int hfa384x_drvr_ramdl_disable(hfa384x_t *hw)
 * Call context:
 *	process
 ----------------------------------------------------------------*/
-int hfa384x_drvr_ramdl_enable(hfa384x_t *hw, u32 exeaddr)
+int hfa384x_drvr_ramdl_enable(struct hfa384x *hw, u32 exeaddr)
 {
 	int result = 0;
 	u16 lowaddr;
@@ -2196,7 +2196,7 @@ int hfa384x_drvr_ramdl_enable(hfa384x_t *hw, u32 exeaddr)
 * Call context:
 *	process
 ----------------------------------------------------------------*/
-int hfa384x_drvr_ramdl_write(hfa384x_t *hw, u32 daddr, void *buf, u32 len)
+int hfa384x_drvr_ramdl_write(struct hfa384x *hw, u32 daddr, void *buf, u32 len)
 {
 	int result = 0;
 	int nwrites;
@@ -2276,7 +2276,7 @@ int hfa384x_drvr_ramdl_write(hfa384x_t *hw, u32 daddr, void *buf, u32 len)
 * Call context:
 *	process or non-card interrupt.
 ----------------------------------------------------------------*/
-int hfa384x_drvr_readpda(hfa384x_t *hw, void *buf, unsigned int len)
+int hfa384x_drvr_readpda(struct hfa384x *hw, void *buf, unsigned int len)
 {
 	int result = 0;
 	u16 *pda = buf;
@@ -2386,7 +2386,7 @@ int hfa384x_drvr_readpda(hfa384x_t *hw, void *buf, unsigned int len)
 * Call context:
 *	process
 ----------------------------------------------------------------*/
-int hfa384x_drvr_setconfig(hfa384x_t *hw, u16 rid, void *buf, u16 len)
+int hfa384x_drvr_setconfig(struct hfa384x *hw, u16 rid, void *buf, u16 len)
 {
 	return hfa384x_dowrid_wait(hw, rid, buf, len);
 }
@@ -2411,7 +2411,7 @@ int hfa384x_drvr_setconfig(hfa384x_t *hw, u16 rid, void *buf, u16 len)
 *	process
 ----------------------------------------------------------------*/
 
-int hfa384x_drvr_start(hfa384x_t *hw)
+int hfa384x_drvr_start(struct hfa384x *hw)
 {
 	int result, result1, result2;
 	u16 status;
@@ -2512,7 +2512,7 @@ int hfa384x_drvr_start(hfa384x_t *hw)
 * Call context:
 *	process
 ----------------------------------------------------------------*/
-int hfa384x_drvr_stop(hfa384x_t *hw)
+int hfa384x_drvr_stop(struct hfa384x *hw)
 {
 	int i;
 
@@ -2562,7 +2562,7 @@ int hfa384x_drvr_stop(hfa384x_t *hw)
 * Call context:
 *	interrupt
 ----------------------------------------------------------------*/
-int hfa384x_drvr_txframe(hfa384x_t *hw, struct sk_buff *skb,
+int hfa384x_drvr_txframe(struct hfa384x *hw, struct sk_buff *skb,
 			 union p80211_hdr *p80211_hdr,
 			 struct p80211_metawep *p80211_wep)
 {
@@ -2658,7 +2658,7 @@ int hfa384x_drvr_txframe(hfa384x_t *hw, struct sk_buff *skb,
 
 void hfa384x_tx_timeout(struct wlandevice *wlandev)
 {
-	hfa384x_t *hw = wlandev->priv;
+	struct hfa384x *hw = wlandev->priv;
 	unsigned long flags;
 
 	spin_lock_irqsave(&hw->ctlxq.lock, flags);
@@ -2681,7 +2681,7 @@ void hfa384x_tx_timeout(struct wlandevice *wlandev)
 * Tasklet to delete dead CTLX objects
 *
 * Arguments:
-*	data	ptr to a hfa384x_t
+*	data	ptr to a struct hfa384x
 *
 * Returns:
 *
@@ -2690,7 +2690,7 @@ void hfa384x_tx_timeout(struct wlandevice *wlandev)
 ----------------------------------------------------------------*/
 static void hfa384x_usbctlx_reaper_task(unsigned long data)
 {
-	hfa384x_t *hw = (hfa384x_t *)data;
+	struct hfa384x *hw = (struct hfa384x *)data;
 	struct hfa384x_usbctlx *ctlx, *temp;
 	unsigned long flags;
 
@@ -2713,7 +2713,7 @@ static void hfa384x_usbctlx_reaper_task(unsigned long data)
 * Tasklet to call completion handlers for returned CTLXs
 *
 * Arguments:
-*	data	ptr to hfa384x_t
+*	data	ptr to struct hfa384x
 *
 * Returns:
 *	Nothing
@@ -2723,7 +2723,7 @@ static void hfa384x_usbctlx_reaper_task(unsigned long data)
 ----------------------------------------------------------------*/
 static void hfa384x_usbctlx_completion_task(unsigned long data)
 {
-	hfa384x_t *hw = (hfa384x_t *)data;
+	struct hfa384x *hw = (struct hfa384x *)data;
 	struct hfa384x_usbctlx *ctlx, *temp;
 	unsigned long flags;
 
@@ -2787,7 +2787,7 @@ static void hfa384x_usbctlx_completion_task(unsigned long data)
 * next command on the queue is run afterwards.
 *
 * Arguments:
-*	hw	ptr to the hfa384x_t structure
+*	hw	ptr to the struct hfa384x structure
 *	ctlx	ptr to a CTLX structure
 *
 * Returns:
@@ -2797,7 +2797,7 @@ static void hfa384x_usbctlx_completion_task(unsigned long data)
 * Call context:
 *	Either process or interrupt, but presumably interrupt
 ----------------------------------------------------------------*/
-static int unlocked_usbctlx_cancel_async(hfa384x_t *hw,
+static int unlocked_usbctlx_cancel_async(struct hfa384x *hw,
 					 struct hfa384x_usbctlx *ctlx)
 {
 	int ret;
@@ -2836,7 +2836,7 @@ static int unlocked_usbctlx_cancel_async(hfa384x_t *hw,
 * tasklet is scheduled.
 *
 * Arguments:
-*	hw		ptr to a hfa384x_t structure
+*	hw		ptr to a struct hfa384x structure
 *	ctlx		ptr to a ctlx structure
 *
 * Returns:
@@ -2847,7 +2847,7 @@ static int unlocked_usbctlx_cancel_async(hfa384x_t *hw,
 * Call context:
 *	Either, assume interrupt
 ----------------------------------------------------------------*/
-static void unlocked_usbctlx_complete(hfa384x_t *hw, struct hfa384x_usbctlx *ctlx)
+static void unlocked_usbctlx_complete(struct hfa384x *hw, struct hfa384x_usbctlx *ctlx)
 {
 	/* Timers have been stopped, and ctlx should be in
 	 * a terminal state. Retire it from the "active"
@@ -2876,7 +2876,7 @@ static void unlocked_usbctlx_complete(hfa384x_t *hw, struct hfa384x_usbctlx *ctl
 * Checks to see if the head item is running.  If not, starts it.
 *
 * Arguments:
-*	hw	ptr to hfa384x_t
+*	hw	ptr to struct hfa384x
 *
 * Returns:
 *	nothing
@@ -2886,7 +2886,7 @@ static void unlocked_usbctlx_complete(hfa384x_t *hw, struct hfa384x_usbctlx *ctl
 * Call context:
 *	any
 ----------------------------------------------------------------*/
-static void hfa384x_usbctlxq_run(hfa384x_t *hw)
+static void hfa384x_usbctlxq_run(struct hfa384x *hw)
 {
 	unsigned long flags;
 
@@ -2989,7 +2989,7 @@ static void hfa384x_usbctlxq_run(hfa384x_t *hw)
 static void hfa384x_usbin_callback(struct urb *urb)
 {
 	struct wlandevice *wlandev = urb->context;
-	hfa384x_t *hw;
+	struct hfa384x *hw;
 	union hfa384x_usbin *usbin = (union hfa384x_usbin *)urb->transfer_buffer;
 	struct sk_buff *skb = NULL;
 	int result;
@@ -3154,7 +3154,7 @@ static void hfa384x_usbin_callback(struct urb *urb)
 * queue and our state updated accordingly.
 *
 * Arguments:
-*	hw		ptr to hfa384x_t
+*	hw		ptr to struct hfa384x
 *	usbin		ptr to USB IN packet
 *	urb_status	status of this Bulk-In URB
 *
@@ -3166,7 +3166,7 @@ static void hfa384x_usbin_callback(struct urb *urb)
 * Call context:
 *	interrupt
 ----------------------------------------------------------------*/
-static void hfa384x_usbin_ctlx(hfa384x_t *hw, union hfa384x_usbin *usbin,
+static void hfa384x_usbin_ctlx(struct hfa384x *hw, union hfa384x_usbin *usbin,
 			       int urb_status)
 {
 	struct hfa384x_usbctlx *ctlx;
@@ -3319,7 +3319,7 @@ static void hfa384x_usbin_txcompl(struct wlandevice *wlandev,
 static void hfa384x_usbin_rx(struct wlandevice *wlandev, struct sk_buff *skb)
 {
 	union hfa384x_usbin *usbin = (union hfa384x_usbin *)skb->data;
-	hfa384x_t *hw = wlandev->priv;
+	struct hfa384x *hw = wlandev->priv;
 	int hdrlen;
 	struct p80211_rxmeta *rxmeta;
 	u16 data_len;
@@ -3426,7 +3426,7 @@ static void hfa384x_int_rxmonitor(struct wlandevice *wlandev,
 	u8 *datap;
 	u16 fc;
 	struct sk_buff *skb;
-	hfa384x_t *hw = wlandev->priv;
+	struct hfa384x *hw = wlandev->priv;
 
 	/* Remember the status, time, and data_len fields are in host order */
 	/* Figure out how big the frame is */
@@ -3557,7 +3557,7 @@ static void hfa384x_usbout_callback(struct urb *urb)
 
 		case -EPIPE:
 			{
-				hfa384x_t *hw = wlandev->priv;
+				struct hfa384x *hw = wlandev->priv;
 
 				netdev_warn(hw->wlandev->netdev,
 					    "%s tx pipe stalled: requesting reset\n",
@@ -3573,7 +3573,7 @@ static void hfa384x_usbout_callback(struct urb *urb)
 		case -ETIMEDOUT:
 		case -EILSEQ:
 			{
-				hfa384x_t *hw = wlandev->priv;
+				struct hfa384x *hw = wlandev->priv;
 
 				if (!test_and_set_bit
 				    (THROTTLE_TX, &hw->usb_flags) &&
@@ -3618,7 +3618,7 @@ static void hfa384x_usbout_callback(struct urb *urb)
 ----------------------------------------------------------------*/
 static void hfa384x_ctlxout_callback(struct urb *urb)
 {
-	hfa384x_t *hw = urb->context;
+	struct hfa384x *hw = urb->context;
 	int delete_resptimer = 0;
 	int timer_ok = 1;
 	int run_queue = 0;
@@ -3737,7 +3737,7 @@ static void hfa384x_ctlxout_callback(struct urb *urb)
 * URB containing a Prism2.x XXX_Request was never called.
 *
 * Arguments:
-*	data		a ptr to the hfa384x_t
+*	data		a ptr to the struct hfa384x
 *
 * Returns:
 *	nothing
@@ -3749,7 +3749,7 @@ static void hfa384x_ctlxout_callback(struct urb *urb)
 ----------------------------------------------------------------*/
 static void hfa384x_usbctlx_reqtimerfn(unsigned long data)
 {
-	hfa384x_t *hw = (hfa384x_t *)data;
+	struct hfa384x *hw = (struct hfa384x *)data;
 	unsigned long flags;
 
 	spin_lock_irqsave(&hw->ctlxq.lock, flags);
@@ -3795,7 +3795,7 @@ static void hfa384x_usbctlx_reqtimerfn(unsigned long data)
 * URB containing a Prism2.x XXX_Response was never called.
 *
 * Arguments:
-*	data		a ptr to the hfa384x_t
+*	data		a ptr to the struct hfa384x
 *
 * Returns:
 *	nothing
@@ -3807,7 +3807,7 @@ static void hfa384x_usbctlx_reqtimerfn(unsigned long data)
 ----------------------------------------------------------------*/
 static void hfa384x_usbctlx_resptimerfn(unsigned long data)
 {
-	hfa384x_t *hw = (hfa384x_t *)data;
+	struct hfa384x *hw = (struct hfa384x *)data;
 	unsigned long flags;
 
 	spin_lock_irqsave(&hw->ctlxq.lock, flags);
@@ -3846,7 +3846,7 @@ static void hfa384x_usbctlx_resptimerfn(unsigned long data)
 ----------------------------------------------------------------*/
 static void hfa384x_usb_throttlefn(unsigned long data)
 {
-	hfa384x_t *hw = (hfa384x_t *)data;
+	struct hfa384x *hw = (struct hfa384x *)data;
 	unsigned long flags;
 
 	spin_lock_irqsave(&hw->ctlxq.lock, flags);
@@ -3886,7 +3886,7 @@ static void hfa384x_usb_throttlefn(unsigned long data)
 * Call context:
 *	process or interrupt
 ----------------------------------------------------------------*/
-static int hfa384x_usbctlx_submit(hfa384x_t *hw, struct hfa384x_usbctlx *ctlx)
+static int hfa384x_usbctlx_submit(struct hfa384x *hw, struct hfa384x_usbctlx *ctlx)
 {
 	unsigned long flags;
 

commit e2f503c40dcc4d2a772612dc9e4e4c6373bc1f73
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Wed Sep 28 20:20:18 2016 +0200

    staging: wlang-ng: avoid new typedef: hfa384x_metacmd_t
    
    This patch fixes the following checkpatch.pl warning in hfa384x.h:
    WARNING: do not add new typedefs
    
    It applies for typedef hfa384x_metacmd_t
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/hfa384x_usb.c b/drivers/staging/wlan-ng/hfa384x_usb.c
index 1f0c428045d0..7b0aae5dab20 100644
--- a/drivers/staging/wlan-ng/hfa384x_usb.c
+++ b/drivers/staging/wlan-ng/hfa384x_usb.c
@@ -224,7 +224,7 @@ usbctlx_get_rridresult(const struct hfa384x_usb_rridresp *rridresp,
 static int
 hfa384x_docmd(hfa384x_t *hw,
 	      enum cmd_mode mode,
-	      hfa384x_metacmd_t *cmd,
+	      struct hfa384x_metacmd *cmd,
 	      ctlx_cmdcb_t cmdcb, ctlx_usercb_t usercb, void *usercb_data);
 
 static int
@@ -812,14 +812,14 @@ static void hfa384x_cb_status(hfa384x_t *hw, const struct hfa384x_usbctlx *ctlx)
 	}
 }
 
-static inline int hfa384x_docmd_wait(hfa384x_t *hw, hfa384x_metacmd_t *cmd)
+static inline int hfa384x_docmd_wait(hfa384x_t *hw, struct hfa384x_metacmd *cmd)
 {
 	return hfa384x_docmd(hw, DOWAIT, cmd, NULL, NULL, NULL);
 }
 
 static inline int
 hfa384x_docmd_async(hfa384x_t *hw,
-		    hfa384x_metacmd_t *cmd,
+		    struct hfa384x_metacmd *cmd,
 		    ctlx_cmdcb_t cmdcb, ctlx_usercb_t usercb, void *usercb_data)
 {
 	return hfa384x_docmd(hw, DOASYNC, cmd, cmdcb, usercb, usercb_data);
@@ -927,7 +927,7 @@ int hfa384x_cmd_initialize(hfa384x_t *hw)
 {
 	int result = 0;
 	int i;
-	hfa384x_metacmd_t cmd;
+	struct hfa384x_metacmd cmd;
 
 	cmd.cmd = HFA384x_CMDCODE_INIT;
 	cmd.parm0 = 0;
@@ -971,7 +971,7 @@ int hfa384x_cmd_initialize(hfa384x_t *hw)
 ----------------------------------------------------------------*/
 int hfa384x_cmd_disable(hfa384x_t *hw, u16 macport)
 {
-	hfa384x_metacmd_t cmd;
+	struct hfa384x_metacmd cmd;
 
 	cmd.cmd = HFA384x_CMD_CMDCODE_SET(HFA384x_CMDCODE_DISABLE) |
 	    HFA384x_CMD_MACPORT_SET(macport);
@@ -1004,7 +1004,7 @@ int hfa384x_cmd_disable(hfa384x_t *hw, u16 macport)
 ----------------------------------------------------------------*/
 int hfa384x_cmd_enable(hfa384x_t *hw, u16 macport)
 {
-	hfa384x_metacmd_t cmd;
+	struct hfa384x_metacmd cmd;
 
 	cmd.cmd = HFA384x_CMD_CMDCODE_SET(HFA384x_CMDCODE_ENABLE) |
 	    HFA384x_CMD_MACPORT_SET(macport);
@@ -1046,7 +1046,7 @@ int hfa384x_cmd_enable(hfa384x_t *hw, u16 macport)
 ----------------------------------------------------------------*/
 int hfa384x_cmd_monitor(hfa384x_t *hw, u16 enable)
 {
-	hfa384x_metacmd_t cmd;
+	struct hfa384x_metacmd cmd;
 
 	cmd.cmd = HFA384x_CMD_CMDCODE_SET(HFA384x_CMDCODE_MONITOR) |
 	    HFA384x_CMD_AINFO_SET(enable);
@@ -1098,7 +1098,7 @@ int hfa384x_cmd_monitor(hfa384x_t *hw, u16 enable)
 int hfa384x_cmd_download(hfa384x_t *hw, u16 mode, u16 lowaddr,
 			 u16 highaddr, u16 codelen)
 {
-	hfa384x_metacmd_t cmd;
+	struct hfa384x_metacmd cmd;
 
 	pr_debug("mode=%d, lowaddr=0x%04x, highaddr=0x%04x, codelen=%d\n",
 		 mode, lowaddr, highaddr, codelen);
@@ -1291,7 +1291,7 @@ static int hfa384x_usbctlx_complete_sync(hfa384x_t *hw,
 static int
 hfa384x_docmd(hfa384x_t *hw,
 	      enum cmd_mode mode,
-	      hfa384x_metacmd_t *cmd,
+	      struct hfa384x_metacmd *cmd,
 	      ctlx_cmdcb_t cmdcb, ctlx_usercb_t usercb, void *usercb_data)
 {
 	int result;

commit a10d36b08355d44acd9f0c391f0f01bd631d2d9d
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Wed Sep 28 20:20:16 2016 +0200

    staging: wlang-ng: avoid new typedef: hfa384x_usbctlx_t
    
    This patch fixes the following checkpatch.pl warning in hfa384x.h:
    WARNING: do not add new typedefs
    
    It applies for typedef hfa384x_usbctlx_t
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/hfa384x_usb.c b/drivers/staging/wlan-ng/hfa384x_usb.c
index 17a90c58b6fe..1f0c428045d0 100644
--- a/drivers/staging/wlan-ng/hfa384x_usb.c
+++ b/drivers/staging/wlan-ng/hfa384x_usb.c
@@ -193,9 +193,9 @@ static void hfa384x_usbctlx_completion_task(unsigned long data);
 
 static void hfa384x_usbctlx_reaper_task(unsigned long data);
 
-static int hfa384x_usbctlx_submit(hfa384x_t *hw, hfa384x_usbctlx_t *ctlx);
+static int hfa384x_usbctlx_submit(hfa384x_t *hw, struct hfa384x_usbctlx *ctlx);
 
-static void unlocked_usbctlx_complete(hfa384x_t *hw, hfa384x_usbctlx_t *ctlx);
+static void unlocked_usbctlx_complete(hfa384x_t *hw, struct hfa384x_usbctlx *ctlx);
 
 struct usbctlx_completor {
 	int (*complete)(struct usbctlx_completor *);
@@ -203,13 +203,13 @@ struct usbctlx_completor {
 
 static int
 hfa384x_usbctlx_complete_sync(hfa384x_t *hw,
-			      hfa384x_usbctlx_t *ctlx,
+			      struct hfa384x_usbctlx *ctlx,
 			      struct usbctlx_completor *completor);
 
 static int
-unlocked_usbctlx_cancel_async(hfa384x_t *hw, hfa384x_usbctlx_t *ctlx);
+unlocked_usbctlx_cancel_async(hfa384x_t *hw, struct hfa384x_usbctlx *ctlx);
 
-static void hfa384x_cb_status(hfa384x_t *hw, const hfa384x_usbctlx_t *ctlx);
+static void hfa384x_cb_status(hfa384x_t *hw, const struct hfa384x_usbctlx *ctlx);
 
 static int
 usbctlx_get_status(const struct hfa384x_usb_statusresp *cmdresp,
@@ -278,9 +278,9 @@ static inline const char *ctlxstr(CTLX_STATE s)
 	return ctlx_str[s];
 };
 
-static inline hfa384x_usbctlx_t *get_active_ctlx(hfa384x_t *hw)
+static inline struct hfa384x_usbctlx *get_active_ctlx(hfa384x_t *hw)
 {
-	return list_entry(hw->ctlxq.active.next, hfa384x_usbctlx_t, list);
+	return list_entry(hw->ctlxq.active.next, struct hfa384x_usbctlx, list);
 }
 
 #ifdef DEBUG_USB
@@ -608,9 +608,9 @@ void hfa384x_destroy(hfa384x_t *hw)
 		dev_kfree_skb(skb);
 }
 
-static hfa384x_usbctlx_t *usbctlx_alloc(void)
+static struct hfa384x_usbctlx *usbctlx_alloc(void)
 {
-	hfa384x_usbctlx_t *ctlx;
+	struct hfa384x_usbctlx *ctlx;
 
 	ctlx = kzalloc(sizeof(*ctlx),
 		       in_interrupt() ? GFP_ATOMIC : GFP_KERNEL);
@@ -795,7 +795,7 @@ static inline struct usbctlx_completor *init_rmem_completor(
 * Call context:
 *	interrupt
 ----------------------------------------------------------------*/
-static void hfa384x_cb_status(hfa384x_t *hw, const hfa384x_usbctlx_t *ctlx)
+static void hfa384x_cb_status(hfa384x_t *hw, const struct hfa384x_usbctlx *ctlx)
 {
 	if (ctlx->usercb) {
 		struct hfa384x_cmdresult cmdresult;
@@ -1174,7 +1174,7 @@ int hfa384x_corereset(hfa384x_t *hw, int holdtime, int settletime, int genesis)
 *	process
 ----------------------------------------------------------------*/
 static int hfa384x_usbctlx_complete_sync(hfa384x_t *hw,
-					 hfa384x_usbctlx_t *ctlx,
+					 struct hfa384x_usbctlx *ctlx,
 					 struct usbctlx_completor *completor)
 {
 	unsigned long flags;
@@ -1295,7 +1295,7 @@ hfa384x_docmd(hfa384x_t *hw,
 	      ctlx_cmdcb_t cmdcb, ctlx_usercb_t usercb, void *usercb_data)
 {
 	int result;
-	hfa384x_usbctlx_t *ctlx;
+	struct hfa384x_usbctlx *ctlx;
 
 	ctlx = usbctlx_alloc();
 	if (!ctlx) {
@@ -1385,7 +1385,7 @@ hfa384x_dorrid(hfa384x_t *hw,
 	       ctlx_cmdcb_t cmdcb, ctlx_usercb_t usercb, void *usercb_data)
 {
 	int result;
-	hfa384x_usbctlx_t *ctlx;
+	struct hfa384x_usbctlx *ctlx;
 
 	ctlx = usbctlx_alloc();
 	if (!ctlx) {
@@ -1466,7 +1466,7 @@ hfa384x_dowrid(hfa384x_t *hw,
 	       ctlx_cmdcb_t cmdcb, ctlx_usercb_t usercb, void *usercb_data)
 {
 	int result;
-	hfa384x_usbctlx_t *ctlx;
+	struct hfa384x_usbctlx *ctlx;
 
 	ctlx = usbctlx_alloc();
 	if (!ctlx) {
@@ -1554,7 +1554,7 @@ hfa384x_dormem(hfa384x_t *hw,
 	       ctlx_cmdcb_t cmdcb, ctlx_usercb_t usercb, void *usercb_data)
 {
 	int result;
-	hfa384x_usbctlx_t *ctlx;
+	struct hfa384x_usbctlx *ctlx;
 
 	ctlx = usbctlx_alloc();
 	if (!ctlx) {
@@ -1645,7 +1645,7 @@ hfa384x_dowmem(hfa384x_t *hw,
 	       ctlx_cmdcb_t cmdcb, ctlx_usercb_t usercb, void *usercb_data)
 {
 	int result;
-	hfa384x_usbctlx_t *ctlx;
+	struct hfa384x_usbctlx *ctlx;
 
 	pr_debug("page=0x%04x offset=0x%04x len=%d\n", page, offset, len);
 
@@ -2691,7 +2691,7 @@ void hfa384x_tx_timeout(struct wlandevice *wlandev)
 static void hfa384x_usbctlx_reaper_task(unsigned long data)
 {
 	hfa384x_t *hw = (hfa384x_t *)data;
-	hfa384x_usbctlx_t *ctlx, *temp;
+	struct hfa384x_usbctlx *ctlx, *temp;
 	unsigned long flags;
 
 	spin_lock_irqsave(&hw->ctlxq.lock, flags);
@@ -2724,7 +2724,7 @@ static void hfa384x_usbctlx_reaper_task(unsigned long data)
 static void hfa384x_usbctlx_completion_task(unsigned long data)
 {
 	hfa384x_t *hw = (hfa384x_t *)data;
-	hfa384x_usbctlx_t *ctlx, *temp;
+	struct hfa384x_usbctlx *ctlx, *temp;
 	unsigned long flags;
 
 	int reap = 0;
@@ -2798,7 +2798,7 @@ static void hfa384x_usbctlx_completion_task(unsigned long data)
 *	Either process or interrupt, but presumably interrupt
 ----------------------------------------------------------------*/
 static int unlocked_usbctlx_cancel_async(hfa384x_t *hw,
-					 hfa384x_usbctlx_t *ctlx)
+					 struct hfa384x_usbctlx *ctlx)
 {
 	int ret;
 
@@ -2847,7 +2847,7 @@ static int unlocked_usbctlx_cancel_async(hfa384x_t *hw,
 * Call context:
 *	Either, assume interrupt
 ----------------------------------------------------------------*/
-static void unlocked_usbctlx_complete(hfa384x_t *hw, hfa384x_usbctlx_t *ctlx)
+static void unlocked_usbctlx_complete(hfa384x_t *hw, struct hfa384x_usbctlx *ctlx)
 {
 	/* Timers have been stopped, and ctlx should be in
 	 * a terminal state. Retire it from the "active"
@@ -2905,12 +2905,12 @@ static void hfa384x_usbctlxq_run(hfa384x_t *hw)
 		goto unlock;
 
 	while (!list_empty(&hw->ctlxq.pending)) {
-		hfa384x_usbctlx_t *head;
+		struct hfa384x_usbctlx *head;
 		int result;
 
 		/* This is the first pending command */
 		head = list_entry(hw->ctlxq.pending.next,
-				  hfa384x_usbctlx_t, list);
+				  struct hfa384x_usbctlx, list);
 
 		/* We need to split this off to avoid a race condition */
 		list_move_tail(&head->list, &hw->ctlxq.active);
@@ -3169,7 +3169,7 @@ static void hfa384x_usbin_callback(struct urb *urb)
 static void hfa384x_usbin_ctlx(hfa384x_t *hw, union hfa384x_usbin *usbin,
 			       int urb_status)
 {
-	hfa384x_usbctlx_t *ctlx;
+	struct hfa384x_usbctlx *ctlx;
 	int run_queue = 0;
 	unsigned long flags;
 
@@ -3622,7 +3622,7 @@ static void hfa384x_ctlxout_callback(struct urb *urb)
 	int delete_resptimer = 0;
 	int timer_ok = 1;
 	int run_queue = 0;
-	hfa384x_usbctlx_t *ctlx;
+	struct hfa384x_usbctlx *ctlx;
 	unsigned long flags;
 
 	pr_debug("urb->status=%d\n", urb->status);
@@ -3766,7 +3766,7 @@ static void hfa384x_usbctlx_reqtimerfn(unsigned long data)
 		 */
 		hw->ctlx_urb.transfer_flags |= URB_ASYNC_UNLINK;
 		if (usb_unlink_urb(&hw->ctlx_urb) == -EINPROGRESS) {
-			hfa384x_usbctlx_t *ctlx = get_active_ctlx(hw);
+			struct hfa384x_usbctlx *ctlx = get_active_ctlx(hw);
 
 			ctlx->state = CTLX_REQ_FAILED;
 
@@ -3818,7 +3818,7 @@ static void hfa384x_usbctlx_resptimerfn(unsigned long data)
 	 * adapter has been unplugged ...
 	 */
 	if (!list_empty(&hw->ctlxq.active)) {
-		hfa384x_usbctlx_t *ctlx = get_active_ctlx(hw);
+		struct hfa384x_usbctlx *ctlx = get_active_ctlx(hw);
 
 		if (unlocked_usbctlx_cancel_async(hw, ctlx) == 0) {
 			spin_unlock_irqrestore(&hw->ctlxq.lock, flags);
@@ -3886,7 +3886,7 @@ static void hfa384x_usb_throttlefn(unsigned long data)
 * Call context:
 *	process or interrupt
 ----------------------------------------------------------------*/
-static int hfa384x_usbctlx_submit(hfa384x_t *hw, hfa384x_usbctlx_t *ctlx)
+static int hfa384x_usbctlx_submit(hfa384x_t *hw, struct hfa384x_usbctlx *ctlx)
 {
 	unsigned long flags;
 

commit b3fd890e1b4fc2fb0ff72c3663ccff18ba47046b
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Wed Sep 28 20:20:15 2016 +0200

    staging: wlang-ng: avoid new typedef: hfa384x_rridresult_t
    
    This patch fixes the following checkpatch.pl warning in hfa384x.h:
    WARNING: do not add new typedefs
    
    It applies for typedef hfa384x_rridresult_t
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/hfa384x_usb.c b/drivers/staging/wlan-ng/hfa384x_usb.c
index 1e5f74c3a218..17a90c58b6fe 100644
--- a/drivers/staging/wlan-ng/hfa384x_usb.c
+++ b/drivers/staging/wlan-ng/hfa384x_usb.c
@@ -217,7 +217,7 @@ usbctlx_get_status(const struct hfa384x_usb_statusresp *cmdresp,
 
 static void
 usbctlx_get_rridresult(const struct hfa384x_usb_rridresp *rridresp,
-		       hfa384x_rridresult_t *result);
+		       struct hfa384x_rridresult *result);
 
 /*---------------------------------------------------*/
 /* Low level req/resp CTLX formatters and submitters */
@@ -637,7 +637,7 @@ usbctlx_get_status(const struct hfa384x_usb_statusresp *cmdresp,
 
 static void
 usbctlx_get_rridresult(const struct hfa384x_usb_rridresp *rridresp,
-		       hfa384x_rridresult_t *result)
+		       struct hfa384x_rridresult *result)
 {
 	result->rid = le16_to_cpu(rridresp->rid);
 	result->riddata = rridresp->data;
@@ -693,7 +693,7 @@ struct usbctlx_rrid_completor {
 static int usbctlx_rrid_completor_fn(struct usbctlx_completor *head)
 {
 	struct usbctlx_rrid_completor *complete;
-	hfa384x_rridresult_t rridresult;
+	struct hfa384x_rridresult rridresult;
 
 	complete = (struct usbctlx_rrid_completor *)head;
 	usbctlx_get_rridresult(complete->rridresp, &rridresult);

commit 501f5f96b3bd70348c5e9f71f3c17ddbab73522d
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Wed Sep 28 20:20:14 2016 +0200

    staging: wlang-ng: avoid new typedef: hfa384x_cmdresult_t
    
    This patch fixes the following checkpatch.pl warning in hfa384x.h:
    WARNING: do not add new typedefs
    
    It applies for typedef hfa384x_cmdresult_t
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/hfa384x_usb.c b/drivers/staging/wlan-ng/hfa384x_usb.c
index 9203880ba970..1e5f74c3a218 100644
--- a/drivers/staging/wlan-ng/hfa384x_usb.c
+++ b/drivers/staging/wlan-ng/hfa384x_usb.c
@@ -213,7 +213,7 @@ static void hfa384x_cb_status(hfa384x_t *hw, const hfa384x_usbctlx_t *ctlx);
 
 static int
 usbctlx_get_status(const struct hfa384x_usb_statusresp *cmdresp,
-		   hfa384x_cmdresult_t *result);
+		   struct hfa384x_cmdresult *result);
 
 static void
 usbctlx_get_rridresult(const struct hfa384x_usb_rridresp *rridresp,
@@ -622,7 +622,7 @@ static hfa384x_usbctlx_t *usbctlx_alloc(void)
 
 static int
 usbctlx_get_status(const struct hfa384x_usb_statusresp *cmdresp,
-		   hfa384x_cmdresult_t *result)
+		   struct hfa384x_cmdresult *result)
 {
 	result->status = le16_to_cpu(cmdresp->status);
 	result->resp0 = le16_to_cpu(cmdresp->resp0);
@@ -647,13 +647,13 @@ usbctlx_get_rridresult(const struct hfa384x_usb_rridresp *rridresp,
 /*----------------------------------------------------------------
 * Completor object:
 * This completor must be passed to hfa384x_usbctlx_complete_sync()
-* when processing a CTLX that returns a hfa384x_cmdresult_t structure.
+* when processing a CTLX that returns a struct hfa384x_cmdresult structure.
 ----------------------------------------------------------------*/
 struct usbctlx_cmd_completor {
 	struct usbctlx_completor head;
 
 	const struct hfa384x_usb_statusresp *cmdresp;
-	hfa384x_cmdresult_t *result;
+	struct hfa384x_cmdresult *result;
 };
 
 static inline int usbctlx_cmd_completor_fn(struct usbctlx_completor *head)
@@ -669,7 +669,7 @@ static inline struct usbctlx_completor *init_cmd_completor(
 							*completor,
 						const struct hfa384x_usb_statusresp
 							*cmdresp,
-						hfa384x_cmdresult_t *result)
+						struct hfa384x_cmdresult *result)
 {
 	completor->head.complete = usbctlx_cmd_completor_fn;
 	completor->cmdresp = cmdresp;
@@ -798,7 +798,7 @@ static inline struct usbctlx_completor *init_rmem_completor(
 static void hfa384x_cb_status(hfa384x_t *hw, const hfa384x_usbctlx_t *ctlx)
 {
 	if (ctlx->usercb) {
-		hfa384x_cmdresult_t cmdresult;
+		struct hfa384x_cmdresult cmdresult;
 
 		if (ctlx->state != CTLX_COMPLETE) {
 			memset(&cmdresult, 0, sizeof(cmdresult));
@@ -1497,7 +1497,7 @@ hfa384x_dowrid(hfa384x_t *hw,
 		kfree(ctlx);
 	} else if (mode == DOWAIT) {
 		struct usbctlx_cmd_completor completor;
-		hfa384x_cmdresult_t wridresult;
+		struct hfa384x_cmdresult wridresult;
 
 		result = hfa384x_usbctlx_complete_sync(hw,
 						       ctlx,
@@ -1679,7 +1679,7 @@ hfa384x_dowmem(hfa384x_t *hw,
 		kfree(ctlx);
 	} else if (mode == DOWAIT) {
 		struct usbctlx_cmd_completor completor;
-		hfa384x_cmdresult_t wmemresult;
+		struct hfa384x_cmdresult wmemresult;
 
 		result = hfa384x_usbctlx_complete_sync(hw,
 						       ctlx,

commit 3e4180c3e8fe17518ce1a3b7ecd49b318217541f
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Wed Sep 28 20:19:38 2016 +0200

    staging: wlang-ng: avoid new typedef: hfa384x_usbin_t
    
    This patch fixes the following checkpatch.pl warning in hfa384x.h:
    WARNING: do not add new typedefs
    
    It applies for typedef hfa384x_usbin_t
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/hfa384x_usb.c b/drivers/staging/wlan-ng/hfa384x_usb.c
index d76ec2a1410b..9203880ba970 100644
--- a/drivers/staging/wlan-ng/hfa384x_usb.c
+++ b/drivers/staging/wlan-ng/hfa384x_usb.c
@@ -169,13 +169,13 @@ static void hfa384x_ctlxout_callback(struct urb *urb);
 static void hfa384x_usbin_callback(struct urb *urb);
 
 static void
-hfa384x_usbin_txcompl(struct wlandevice *wlandev, hfa384x_usbin_t *usbin);
+hfa384x_usbin_txcompl(struct wlandevice *wlandev, union hfa384x_usbin *usbin);
 
 static void hfa384x_usbin_rx(struct wlandevice *wlandev, struct sk_buff *skb);
 
-static void hfa384x_usbin_info(struct wlandevice *wlandev, hfa384x_usbin_t *usbin);
+static void hfa384x_usbin_info(struct wlandevice *wlandev, union hfa384x_usbin *usbin);
 
-static void hfa384x_usbin_ctlx(hfa384x_t *hw, hfa384x_usbin_t *usbin,
+static void hfa384x_usbin_ctlx(hfa384x_t *hw, union hfa384x_usbin *usbin,
 			       int urb_status);
 
 /*---------------------------------------------------*/
@@ -327,7 +327,7 @@ static int submit_rx_urb(hfa384x_t *hw, gfp_t memflags)
 	struct sk_buff *skb;
 	int result;
 
-	skb = dev_alloc_skb(sizeof(hfa384x_usbin_t));
+	skb = dev_alloc_skb(sizeof(union hfa384x_usbin));
 	if (!skb) {
 		result = -ENOMEM;
 		goto done;
@@ -336,7 +336,7 @@ static int submit_rx_urb(hfa384x_t *hw, gfp_t memflags)
 	/* Post the IN urb */
 	usb_fill_bulk_urb(&hw->rx_urb, hw->usb,
 			  hw->endp_in,
-			  skb->data, sizeof(hfa384x_usbin_t),
+			  skb->data, sizeof(union hfa384x_usbin),
 			  hfa384x_usbin_callback, hw->wlandev);
 
 	hw->rx_urb_skb = skb;
@@ -2990,7 +2990,7 @@ static void hfa384x_usbin_callback(struct urb *urb)
 {
 	struct wlandevice *wlandev = urb->context;
 	hfa384x_t *hw;
-	hfa384x_usbin_t *usbin = (hfa384x_usbin_t *)urb->transfer_buffer;
+	union hfa384x_usbin *usbin = (union hfa384x_usbin *)urb->transfer_buffer;
 	struct sk_buff *skb = NULL;
 	int result;
 	int urb_status;
@@ -3166,7 +3166,7 @@ static void hfa384x_usbin_callback(struct urb *urb)
 * Call context:
 *	interrupt
 ----------------------------------------------------------------*/
-static void hfa384x_usbin_ctlx(hfa384x_t *hw, hfa384x_usbin_t *usbin,
+static void hfa384x_usbin_ctlx(hfa384x_t *hw, union hfa384x_usbin *usbin,
 			       int urb_status)
 {
 	hfa384x_usbctlx_t *ctlx;
@@ -3286,7 +3286,7 @@ static void hfa384x_usbin_ctlx(hfa384x_t *hw, hfa384x_usbin_t *usbin,
 *	interrupt
 ----------------------------------------------------------------*/
 static void hfa384x_usbin_txcompl(struct wlandevice *wlandev,
-				  hfa384x_usbin_t *usbin)
+				  union hfa384x_usbin *usbin)
 {
 	u16 status;
 
@@ -3318,7 +3318,7 @@ static void hfa384x_usbin_txcompl(struct wlandevice *wlandev,
 ----------------------------------------------------------------*/
 static void hfa384x_usbin_rx(struct wlandevice *wlandev, struct sk_buff *skb)
 {
-	hfa384x_usbin_t *usbin = (hfa384x_usbin_t *)skb->data;
+	union hfa384x_usbin *usbin = (union hfa384x_usbin *)skb->data;
 	hfa384x_t *hw = wlandev->priv;
 	int hdrlen;
 	struct p80211_rxmeta *rxmeta;
@@ -3517,7 +3517,8 @@ static void hfa384x_int_rxmonitor(struct wlandevice *wlandev,
 * Call context:
 *	interrupt
 ----------------------------------------------------------------*/
-static void hfa384x_usbin_info(struct wlandevice *wlandev, hfa384x_usbin_t *usbin)
+static void hfa384x_usbin_info(struct wlandevice *wlandev,
+			       union hfa384x_usbin *usbin)
 {
 	usbin->infofrm.info.framelen =
 	    le16_to_cpu(usbin->infofrm.info.framelen);

commit 1ed548063b66242f655c8fb759f3dc32dd511e5e
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Wed Sep 28 20:19:34 2016 +0200

    staging: wlang-ng: avoid new typedef: hfa384x_usb_rmemresp_t
    
    This patch fixes the following checkpatch.pl warning in hfa384x.h:
    WARNING: do not add new typedefs
    
    It applies for typedef hfa384x_usb_rmemresp_t
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/hfa384x_usb.c b/drivers/staging/wlan-ng/hfa384x_usb.c
index c21c591973f6..d76ec2a1410b 100644
--- a/drivers/staging/wlan-ng/hfa384x_usb.c
+++ b/drivers/staging/wlan-ng/hfa384x_usb.c
@@ -744,7 +744,7 @@ static inline struct usbctlx_completor *init_rrid_completor(
 struct usbctlx_rmem_completor {
 	struct usbctlx_completor head;
 
-	const hfa384x_usb_rmemresp_t *rmemresp;
+	const struct hfa384x_usb_rmemresp *rmemresp;
 	void *data;
 	unsigned int len;
 };
@@ -762,7 +762,7 @@ static int usbctlx_rmem_completor_fn(struct usbctlx_completor *head)
 static inline struct usbctlx_completor *init_rmem_completor(
 						struct usbctlx_rmem_completor
 							*completor,
-						hfa384x_usb_rmemresp_t
+						struct hfa384x_usb_rmemresp
 							*rmemresp,
 						void *data,
 						unsigned int len)

commit a988c9f3ea35e3a6b532ebe30d2724c55b427c9d
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Wed Sep 28 20:19:32 2016 +0200

    staging: wlang-ng: avoid new typedef: hfa384x_usb_rridresp_t
    
    This patch fixes the following checkpatch.pl warning in hfa384x.h:
    WARNING: do not add new typedefs
    
    It applies for typedef hfa384x_usb_rridresp_t
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/hfa384x_usb.c b/drivers/staging/wlan-ng/hfa384x_usb.c
index 7d09f250c0be..c21c591973f6 100644
--- a/drivers/staging/wlan-ng/hfa384x_usb.c
+++ b/drivers/staging/wlan-ng/hfa384x_usb.c
@@ -216,7 +216,7 @@ usbctlx_get_status(const struct hfa384x_usb_statusresp *cmdresp,
 		   hfa384x_cmdresult_t *result);
 
 static void
-usbctlx_get_rridresult(const hfa384x_usb_rridresp_t *rridresp,
+usbctlx_get_rridresult(const struct hfa384x_usb_rridresp *rridresp,
 		       hfa384x_rridresult_t *result);
 
 /*---------------------------------------------------*/
@@ -636,7 +636,7 @@ usbctlx_get_status(const struct hfa384x_usb_statusresp *cmdresp,
 }
 
 static void
-usbctlx_get_rridresult(const hfa384x_usb_rridresp_t *rridresp,
+usbctlx_get_rridresult(const struct hfa384x_usb_rridresp *rridresp,
 		       hfa384x_rridresult_t *result)
 {
 	result->rid = le16_to_cpu(rridresp->rid);
@@ -685,7 +685,7 @@ static inline struct usbctlx_completor *init_cmd_completor(
 struct usbctlx_rrid_completor {
 	struct usbctlx_completor head;
 
-	const hfa384x_usb_rridresp_t *rridresp;
+	const struct hfa384x_usb_rridresp *rridresp;
 	void *riddata;
 	unsigned int riddatalen;
 };
@@ -713,7 +713,7 @@ static int usbctlx_rrid_completor_fn(struct usbctlx_completor *head)
 static inline struct usbctlx_completor *init_rrid_completor(
 						struct usbctlx_rrid_completor
 							*completor,
-						const hfa384x_usb_rridresp_t
+						const struct hfa384x_usb_rridresp
 							*rridresp,
 						void *riddata,
 						unsigned int riddatalen)

commit 385a79df4b8863ba0e30ec364656a4bc7ceceb0d
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Wed Sep 28 20:19:30 2016 +0200

    staging: wlang-ng: avoid new typedef: hfa384x_usb_cmdresp_t
    
    This patch fixes the following checkpatch.pl warning in hfa384x.h:
    WARNING: do not add new typedefs
    
    It applies for typedef hfa384x_usb_cmdresp_t
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/hfa384x_usb.c b/drivers/staging/wlan-ng/hfa384x_usb.c
index 76d1223f812f..7d09f250c0be 100644
--- a/drivers/staging/wlan-ng/hfa384x_usb.c
+++ b/drivers/staging/wlan-ng/hfa384x_usb.c
@@ -212,7 +212,7 @@ unlocked_usbctlx_cancel_async(hfa384x_t *hw, hfa384x_usbctlx_t *ctlx);
 static void hfa384x_cb_status(hfa384x_t *hw, const hfa384x_usbctlx_t *ctlx);
 
 static int
-usbctlx_get_status(const hfa384x_usb_cmdresp_t *cmdresp,
+usbctlx_get_status(const struct hfa384x_usb_statusresp *cmdresp,
 		   hfa384x_cmdresult_t *result);
 
 static void
@@ -621,7 +621,7 @@ static hfa384x_usbctlx_t *usbctlx_alloc(void)
 }
 
 static int
-usbctlx_get_status(const hfa384x_usb_cmdresp_t *cmdresp,
+usbctlx_get_status(const struct hfa384x_usb_statusresp *cmdresp,
 		   hfa384x_cmdresult_t *result)
 {
 	result->status = le16_to_cpu(cmdresp->status);
@@ -652,7 +652,7 @@ usbctlx_get_rridresult(const hfa384x_usb_rridresp_t *rridresp,
 struct usbctlx_cmd_completor {
 	struct usbctlx_completor head;
 
-	const hfa384x_usb_cmdresp_t *cmdresp;
+	const struct hfa384x_usb_statusresp *cmdresp;
 	hfa384x_cmdresult_t *result;
 };
 
@@ -667,7 +667,7 @@ static inline int usbctlx_cmd_completor_fn(struct usbctlx_completor *head)
 static inline struct usbctlx_completor *init_cmd_completor(
 						struct usbctlx_cmd_completor
 							*completor,
-						const hfa384x_usb_cmdresp_t
+						const struct hfa384x_usb_statusresp
 							*cmdresp,
 						hfa384x_cmdresult_t *result)
 {

commit 684b2e087fa6ce45f8cfd6e672cf1ee4f24abffa
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Wed Sep 28 20:19:28 2016 +0200

    staging: wlang-ng: avoid new typedef: hfa384x_usb_rxfrm_t
    
    This patch fixes the following checkpatch.pl warning in hfa384x.h:
    WARNING: do not add new typedefs
    
    It applies for typedef hfa384x_usb_rxfrm_t
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/hfa384x_usb.c b/drivers/staging/wlan-ng/hfa384x_usb.c
index f1809af0b760..76d1223f812f 100644
--- a/drivers/staging/wlan-ng/hfa384x_usb.c
+++ b/drivers/staging/wlan-ng/hfa384x_usb.c
@@ -154,7 +154,7 @@ static void dbprint_urb(struct urb *urb);
 #endif
 
 static void
-hfa384x_int_rxmonitor(struct wlandevice *wlandev, hfa384x_usb_rxfrm_t *rxfrm);
+hfa384x_int_rxmonitor(struct wlandevice *wlandev, struct hfa384x_usb_rxfrm *rxfrm);
 
 static void hfa384x_usb_defer(struct work_struct *data);
 
@@ -3417,7 +3417,7 @@ static void hfa384x_usbin_rx(struct wlandevice *wlandev, struct sk_buff *skb)
 *	interrupt
 ----------------------------------------------------------------*/
 static void hfa384x_int_rxmonitor(struct wlandevice *wlandev,
-				  hfa384x_usb_rxfrm_t *rxfrm)
+				  struct hfa384x_usb_rxfrm *rxfrm)
 {
 	struct hfa384x_rx_frame *rxdesc = &(rxfrm->desc);
 	unsigned int hdrlen = 0;

commit 70adf50956a47a2aeb7fa99015ea96f2632c7193
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Wed Sep 28 20:19:06 2016 +0200

    staging: wlang-ng: avoid new typedef: hfa384x_rx_frame_t
    
    This patch fixes the following checkpatch.pl warning in hfa384x.h:
    WARNING: do not add new typedefs
    
    It applies for typedef hfa384x_rx_frame_t
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/hfa384x_usb.c b/drivers/staging/wlan-ng/hfa384x_usb.c
index 044ca4d9ac9a..f1809af0b760 100644
--- a/drivers/staging/wlan-ng/hfa384x_usb.c
+++ b/drivers/staging/wlan-ng/hfa384x_usb.c
@@ -3346,7 +3346,7 @@ static void hfa384x_usbin_rx(struct wlandevice *wlandev, struct sk_buff *skb)
 		hdrlen = p80211_headerlen(fc);
 
 		/* Pull off the descriptor */
-		skb_pull(skb, sizeof(hfa384x_rx_frame_t));
+		skb_pull(skb, sizeof(struct hfa384x_rx_frame));
 
 		/* Now shunt the header block up against the data block
 		 * with an "overlapping" copy
@@ -3419,7 +3419,7 @@ static void hfa384x_usbin_rx(struct wlandevice *wlandev, struct sk_buff *skb)
 static void hfa384x_int_rxmonitor(struct wlandevice *wlandev,
 				  hfa384x_usb_rxfrm_t *rxfrm)
 {
-	hfa384x_rx_frame_t *rxdesc = &(rxfrm->desc);
+	struct hfa384x_rx_frame *rxdesc = &(rxfrm->desc);
 	unsigned int hdrlen = 0;
 	unsigned int datalen = 0;
 	unsigned int skblen = 0;

commit eb76afc917fd7acc8b33061f39d3f1b566b7c77c
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Wed Sep 28 20:19:05 2016 +0200

    staging: wlang-ng: avoid new typedef: hfa384x_tx_frame_t
    
    This patch fixes the following checkpatch.pl warning in hfa384x.h:
    WARNING: do not add new typedefs
    
    It applies for typedef hfa384x_tx_frame_t
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/hfa384x_usb.c b/drivers/staging/wlan-ng/hfa384x_usb.c
index 9c2931171ec2..044ca4d9ac9a 100644
--- a/drivers/staging/wlan-ng/hfa384x_usb.c
+++ b/drivers/staging/wlan-ng/hfa384x_usb.c
@@ -2566,7 +2566,7 @@ int hfa384x_drvr_txframe(hfa384x_t *hw, struct sk_buff *skb,
 			 union p80211_hdr *p80211_hdr,
 			 struct p80211_metawep *p80211_wep)
 {
-	int usbpktlen = sizeof(hfa384x_tx_frame_t);
+	int usbpktlen = sizeof(struct hfa384x_tx_frame);
 	int result;
 	int ret;
 	char *ptr;

commit c9573a8d1963ba82f163c4d113266da82c048c21
Author: sayli karnik <karniksayli1995@gmail.com>
Date:   Sun Sep 18 15:11:14 2016 +0530

    staging: wlan-ng: Remove the typedef to the 'wlandevice' structure
    
    This patch removes the typedef 'wlandevice_t' to the 'wlandevice'
    structure.
    
    Signed-off-by: sayli karnik <karniksayli1995@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/hfa384x_usb.c b/drivers/staging/wlan-ng/hfa384x_usb.c
index 337810750f2b..9c2931171ec2 100644
--- a/drivers/staging/wlan-ng/hfa384x_usb.c
+++ b/drivers/staging/wlan-ng/hfa384x_usb.c
@@ -154,7 +154,7 @@ static void dbprint_urb(struct urb *urb);
 #endif
 
 static void
-hfa384x_int_rxmonitor(wlandevice_t *wlandev, hfa384x_usb_rxfrm_t *rxfrm);
+hfa384x_int_rxmonitor(struct wlandevice *wlandev, hfa384x_usb_rxfrm_t *rxfrm);
 
 static void hfa384x_usb_defer(struct work_struct *data);
 
@@ -169,11 +169,11 @@ static void hfa384x_ctlxout_callback(struct urb *urb);
 static void hfa384x_usbin_callback(struct urb *urb);
 
 static void
-hfa384x_usbin_txcompl(wlandevice_t *wlandev, hfa384x_usbin_t *usbin);
+hfa384x_usbin_txcompl(struct wlandevice *wlandev, hfa384x_usbin_t *usbin);
 
-static void hfa384x_usbin_rx(wlandevice_t *wlandev, struct sk_buff *skb);
+static void hfa384x_usbin_rx(struct wlandevice *wlandev, struct sk_buff *skb);
 
-static void hfa384x_usbin_info(wlandevice_t *wlandev, hfa384x_usbin_t *usbin);
+static void hfa384x_usbin_info(struct wlandevice *wlandev, hfa384x_usbin_t *usbin);
 
 static void hfa384x_usbin_ctlx(hfa384x_t *hw, hfa384x_usbin_t *usbin,
 			       int urb_status);
@@ -2656,7 +2656,7 @@ int hfa384x_drvr_txframe(hfa384x_t *hw, struct sk_buff *skb,
 	return result;
 }
 
-void hfa384x_tx_timeout(wlandevice_t *wlandev)
+void hfa384x_tx_timeout(struct wlandevice *wlandev)
 {
 	hfa384x_t *hw = wlandev->priv;
 	unsigned long flags;
@@ -2988,7 +2988,7 @@ static void hfa384x_usbctlxq_run(hfa384x_t *hw)
 ----------------------------------------------------------------*/
 static void hfa384x_usbin_callback(struct urb *urb)
 {
-	wlandevice_t *wlandev = urb->context;
+	struct wlandevice *wlandev = urb->context;
 	hfa384x_t *hw;
 	hfa384x_usbin_t *usbin = (hfa384x_usbin_t *)urb->transfer_buffer;
 	struct sk_buff *skb = NULL;
@@ -3285,7 +3285,7 @@ static void hfa384x_usbin_ctlx(hfa384x_t *hw, hfa384x_usbin_t *usbin,
 * Call context:
 *	interrupt
 ----------------------------------------------------------------*/
-static void hfa384x_usbin_txcompl(wlandevice_t *wlandev,
+static void hfa384x_usbin_txcompl(struct wlandevice *wlandev,
 				  hfa384x_usbin_t *usbin)
 {
 	u16 status;
@@ -3316,7 +3316,7 @@ static void hfa384x_usbin_txcompl(wlandevice_t *wlandev,
 * Call context:
 *	interrupt
 ----------------------------------------------------------------*/
-static void hfa384x_usbin_rx(wlandevice_t *wlandev, struct sk_buff *skb)
+static void hfa384x_usbin_rx(struct wlandevice *wlandev, struct sk_buff *skb)
 {
 	hfa384x_usbin_t *usbin = (hfa384x_usbin_t *)skb->data;
 	hfa384x_t *hw = wlandev->priv;
@@ -3416,7 +3416,7 @@ static void hfa384x_usbin_rx(wlandevice_t *wlandev, struct sk_buff *skb)
 * Call context:
 *	interrupt
 ----------------------------------------------------------------*/
-static void hfa384x_int_rxmonitor(wlandevice_t *wlandev,
+static void hfa384x_int_rxmonitor(struct wlandevice *wlandev,
 				  hfa384x_usb_rxfrm_t *rxfrm)
 {
 	hfa384x_rx_frame_t *rxdesc = &(rxfrm->desc);
@@ -3517,7 +3517,7 @@ static void hfa384x_int_rxmonitor(wlandevice_t *wlandev,
 * Call context:
 *	interrupt
 ----------------------------------------------------------------*/
-static void hfa384x_usbin_info(wlandevice_t *wlandev, hfa384x_usbin_t *usbin)
+static void hfa384x_usbin_info(struct wlandevice *wlandev, hfa384x_usbin_t *usbin)
 {
 	usbin->infofrm.info.framelen =
 	    le16_to_cpu(usbin->infofrm.info.framelen);
@@ -3542,7 +3542,7 @@ static void hfa384x_usbin_info(wlandevice_t *wlandev, hfa384x_usbin_t *usbin)
 ----------------------------------------------------------------*/
 static void hfa384x_usbout_callback(struct urb *urb)
 {
-	wlandevice_t *wlandev = urb->context;
+	struct wlandevice *wlandev = urb->context;
 
 #ifdef DEBUG_USB
 	dbprint_urb(urb);

commit 02e020480daf3a7726db493ff28f9391ff6bb9c4
Author: Nicholas Sim <nicholassimws@gmail.com>
Date:   Tue Apr 5 17:37:12 2016 +0100

    staging: wlan-ng: rewrite NULL comparison
    
    It is not necessary to compare explicitly to NULL. Rewrite if condition
    as (!dev) or (dev) as suggested in Documentation/CodingStyle
    
    Signed-off-by: Nicholas Sim <nicholassimws@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/hfa384x_usb.c b/drivers/staging/wlan-ng/hfa384x_usb.c
index 21a92df85931..337810750f2b 100644
--- a/drivers/staging/wlan-ng/hfa384x_usb.c
+++ b/drivers/staging/wlan-ng/hfa384x_usb.c
@@ -614,7 +614,7 @@ static hfa384x_usbctlx_t *usbctlx_alloc(void)
 
 	ctlx = kzalloc(sizeof(*ctlx),
 		       in_interrupt() ? GFP_ATOMIC : GFP_KERNEL);
-	if (ctlx != NULL)
+	if (ctlx)
 		init_completion(&ctlx->done);
 
 	return ctlx;
@@ -797,7 +797,7 @@ static inline struct usbctlx_completor *init_rmem_completor(
 ----------------------------------------------------------------*/
 static void hfa384x_cb_status(hfa384x_t *hw, const hfa384x_usbctlx_t *ctlx)
 {
-	if (ctlx->usercb != NULL) {
+	if (ctlx->usercb) {
 		hfa384x_cmdresult_t cmdresult;
 
 		if (ctlx->state != CTLX_COMPLETE) {
@@ -2738,7 +2738,7 @@ static void hfa384x_usbctlx_completion_task(unsigned long data)
 		/* Call the completion function that this
 		 * command was assigned, assuming it has one.
 		 */
-		if (ctlx->cmdcb != NULL) {
+		if (ctlx->cmdcb) {
 			spin_unlock_irqrestore(&hw->ctlxq.lock, flags);
 			ctlx->cmdcb(hw, ctlx);
 			spin_lock_irqsave(&hw->ctlxq.lock, flags);
@@ -3629,7 +3629,7 @@ static void hfa384x_ctlxout_callback(struct urb *urb)
 	dbprint_urb(urb);
 #endif
 	if ((urb->status == -ESHUTDOWN) ||
-	    (urb->status == -ENODEV) || (hw == NULL))
+	    (urb->status == -ENODEV) || !hw)
 		return;
 
 retry:

commit e2e77528a7dc80a9b5ff978a84b40e403ba9809d
Author: Eva Rachel Retuya <eraretuya@gmail.com>
Date:   Sat Feb 27 20:39:25 2016 +0800

    staging: wlan-ng: simplify NULL tests
    
    Replace direct comparisons to NULL i.e. 'x == NULL' with '!x' for
    consistency. Coccinelle semantic patch used:
    
    @@
    identifier func;
    expression x;
    statement Z;
    @@
    
    x = func(...);
    
    if (
    (
    +       !
            x
    -       == NULL
    |
    +       !
    -       NULL ==
            x
    )
       ) Z
    
    Signed-off-by: Eva Rachel Retuya <eraretuya@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/hfa384x_usb.c b/drivers/staging/wlan-ng/hfa384x_usb.c
index 602c3f379c82..21a92df85931 100644
--- a/drivers/staging/wlan-ng/hfa384x_usb.c
+++ b/drivers/staging/wlan-ng/hfa384x_usb.c
@@ -328,7 +328,7 @@ static int submit_rx_urb(hfa384x_t *hw, gfp_t memflags)
 	int result;
 
 	skb = dev_alloc_skb(sizeof(hfa384x_usbin_t));
-	if (skb == NULL) {
+	if (!skb) {
 		result = -ENOMEM;
 		goto done;
 	}
@@ -1298,7 +1298,7 @@ hfa384x_docmd(hfa384x_t *hw,
 	hfa384x_usbctlx_t *ctlx;
 
 	ctlx = usbctlx_alloc();
-	if (ctlx == NULL) {
+	if (!ctlx) {
 		result = -ENOMEM;
 		goto done;
 	}
@@ -1388,7 +1388,7 @@ hfa384x_dorrid(hfa384x_t *hw,
 	hfa384x_usbctlx_t *ctlx;
 
 	ctlx = usbctlx_alloc();
-	if (ctlx == NULL) {
+	if (!ctlx) {
 		result = -ENOMEM;
 		goto done;
 	}
@@ -1469,7 +1469,7 @@ hfa384x_dowrid(hfa384x_t *hw,
 	hfa384x_usbctlx_t *ctlx;
 
 	ctlx = usbctlx_alloc();
-	if (ctlx == NULL) {
+	if (!ctlx) {
 		result = -ENOMEM;
 		goto done;
 	}
@@ -1557,7 +1557,7 @@ hfa384x_dormem(hfa384x_t *hw,
 	hfa384x_usbctlx_t *ctlx;
 
 	ctlx = usbctlx_alloc();
-	if (ctlx == NULL) {
+	if (!ctlx) {
 		result = -ENOMEM;
 		goto done;
 	}
@@ -1650,7 +1650,7 @@ hfa384x_dowmem(hfa384x_t *hw,
 	pr_debug("page=0x%04x offset=0x%04x len=%d\n", page, offset, len);
 
 	ctlx = usbctlx_alloc();
-	if (ctlx == NULL) {
+	if (!ctlx) {
 		result = -ENOMEM;
 		goto done;
 	}
@@ -3446,7 +3446,7 @@ static void hfa384x_int_rxmonitor(wlandevice_t *wlandev,
 	}
 
 	skb = dev_alloc_skb(skblen);
-	if (skb == NULL)
+	if (!skb)
 		return;
 
 	/* only prepend the prism header if in the right mode */

commit 5850c251faab28a9f76260ae1566d9c5179d37ab
Author: Amitoj Kaur Chawla <amitoj1606@gmail.com>
Date:   Wed Feb 24 21:55:49 2016 +0530

    staging: wlan-ng: Remove unnecessary macro
    
    Remove unnecessary macro SUBMIT_URB by replacing it with a direct call
    to usb_submit_urb()
    
    This change was made with the help of the following Coccinelle semantic
    patch:
    
    //<smpl>
    @@
    identifier f,g;
    @@
    * #define f(...) g(...)
    // </smpl>
    
    Signed-off-by: Amitoj Kaur Chawla <amitoj1606@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/hfa384x_usb.c b/drivers/staging/wlan-ng/hfa384x_usb.c
index 09b4b2cfc97d..602c3f379c82 100644
--- a/drivers/staging/wlan-ng/hfa384x_usb.c
+++ b/drivers/staging/wlan-ng/hfa384x_usb.c
@@ -126,8 +126,6 @@
 #include <linux/usb.h>
 #include <linux/byteorder/generic.h>
 
-#define SUBMIT_URB(u, f)  usb_submit_urb(u, f)
-
 #include "p80211types.h"
 #include "p80211hdr.h"
 #include "p80211mgmt.h"
@@ -346,7 +344,7 @@ static int submit_rx_urb(hfa384x_t *hw, gfp_t memflags)
 	result = -ENOLINK;
 	if (!hw->wlandev->hwremoved &&
 	    !test_bit(WORK_RX_HALT, &hw->usb_flags)) {
-		result = SUBMIT_URB(&hw->rx_urb, memflags);
+		result = usb_submit_urb(&hw->rx_urb, memflags);
 
 		/* Check whether we need to reset the RX pipe */
 		if (result == -EPIPE) {
@@ -395,7 +393,7 @@ static int submit_tx_urb(hfa384x_t *hw, struct urb *tx_urb, gfp_t memflags)
 	if (netif_running(netdev)) {
 		if (!hw->wlandev->hwremoved &&
 		    !test_bit(WORK_TX_HALT, &hw->usb_flags)) {
-			result = SUBMIT_URB(tx_urb, memflags);
+			result = usb_submit_urb(tx_urb, memflags);
 
 			/* Test whether we need to reset the TX pipe */
 			if (result == -EPIPE) {
@@ -2925,7 +2923,7 @@ static void hfa384x_usbctlxq_run(hfa384x_t *hw)
 		hw->ctlx_urb.transfer_flags |= USB_QUEUE_BULK;
 
 		/* Now submit the URB and update the CTLX's state */
-		result = SUBMIT_URB(&hw->ctlx_urb, GFP_ATOMIC);
+		result = usb_submit_urb(&hw->ctlx_urb, GFP_ATOMIC);
 		if (result == 0) {
 			/* This CTLX is now running on the active queue */
 			head->state = CTLX_REQ_SUBMITTED;

commit 896774f631d8377a674fd2b79097b57bab297c16
Author: Bhumika Goyal <bhumirks@gmail.com>
Date:   Wed Feb 17 22:20:09 2016 +0530

    Staging: wlan-ng: Remove unused functions and prototypes
    
    hfa384x_drvr_getconfig_async is not used anywhere in the kernel
    so remove it. Also remove its prototype from the header file. Also
    the function hfa384x_cb_rrid was only used by hfa384x_drvr_getconfig_async
    so remove its definition and prototype as well.
    
    Signed-off-by: Bhumika Goyal <bhumirks@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/hfa384x_usb.c b/drivers/staging/wlan-ng/hfa384x_usb.c
index 5271d42be623..09b4b2cfc97d 100644
--- a/drivers/staging/wlan-ng/hfa384x_usb.c
+++ b/drivers/staging/wlan-ng/hfa384x_usb.c
@@ -213,8 +213,6 @@ unlocked_usbctlx_cancel_async(hfa384x_t *hw, hfa384x_usbctlx_t *ctlx);
 
 static void hfa384x_cb_status(hfa384x_t *hw, const hfa384x_usbctlx_t *ctlx);
 
-static void hfa384x_cb_rrid(hfa384x_t *hw, const hfa384x_usbctlx_t *ctlx);
-
 static int
 usbctlx_get_status(const hfa384x_usb_cmdresp_t *cmdresp,
 		   hfa384x_cmdresult_t *result);
@@ -816,43 +814,6 @@ static void hfa384x_cb_status(hfa384x_t *hw, const hfa384x_usbctlx_t *ctlx)
 	}
 }
 
-/*----------------------------------------------------------------
-* hfa384x_cb_rrid
-*
-* CTLX completion handler for async RRID type control exchanges.
-*
-* Note: If the handling is changed here, it should probably be
-*       changed in dorrid as well.
-*
-* Arguments:
-*	hw		hw struct
-*	ctlx		completed CTLX
-*
-* Returns:
-*	nothing
-*
-* Side effects:
-*
-* Call context:
-*	interrupt
-----------------------------------------------------------------*/
-static void hfa384x_cb_rrid(hfa384x_t *hw, const hfa384x_usbctlx_t *ctlx)
-{
-	if (ctlx->usercb != NULL) {
-		hfa384x_rridresult_t rridresult;
-
-		if (ctlx->state != CTLX_COMPLETE) {
-			memset(&rridresult, 0, sizeof(rridresult));
-			rridresult.rid = le16_to_cpu(ctlx->outbuf.rridreq.rid);
-		} else {
-			usbctlx_get_rridresult(&ctlx->inbuf.rridresp,
-					       &rridresult);
-		}
-
-		ctlx->usercb(hw, &rridresult, ctlx->usercb_data);
-	}
-}
-
 static inline int hfa384x_docmd_wait(hfa384x_t *hw, hfa384x_metacmd_t *cmd)
 {
 	return hfa384x_docmd(hw, DOWAIT, cmd, NULL, NULL, NULL);
@@ -2078,41 +2039,6 @@ int hfa384x_drvr_getconfig(hfa384x_t *hw, u16 rid, void *buf, u16 len)
 	return hfa384x_dorrid_wait(hw, rid, buf, len);
 }
 
-/*----------------------------------------------------------------
- * hfa384x_drvr_getconfig_async
- *
- * Performs the sequence necessary to perform an async read of
- * of a config/info item.
- *
- * Arguments:
- *       hw              device structure
- *       rid             config/info record id (host order)
- *       buf             host side record buffer.  Upon return it will
- *                       contain the body portion of the record (minus the
- *                       RID and len).
- *       len             buffer length (in bytes, should match record length)
- *       cbfn            caller supplied callback, called when the command
- *                       is done (successful or not).
- *       cbfndata        pointer to some caller supplied data that will be
- *                       passed in as an argument to the cbfn.
- *
- * Returns:
- *       nothing         the cbfn gets a status argument identifying if
- *                       any errors occur.
- * Side effects:
- *       Queues an hfa384x_usbcmd_t for subsequent execution.
- *
- * Call context:
- *       Any
- ----------------------------------------------------------------*/
-int
-hfa384x_drvr_getconfig_async(hfa384x_t *hw,
-			     u16 rid, ctlx_usercb_t usercb, void *usercb_data)
-{
-	return hfa384x_dorrid_async(hw, rid, NULL, 0,
-				    hfa384x_cb_rrid, usercb, usercb_data);
-}
-
 /*----------------------------------------------------------------
  * hfa384x_drvr_setconfig_async
  *

commit 49e845a0878b62c1c67cf585486085572a2b9603
Author: Bhumika Goyal <bhumirks@gmail.com>
Date:   Wed Feb 17 22:20:08 2016 +0530

    Staging: wlan-ng: Remove function hfa384x_drvr_commtallies
    
    The function hfa384x_drvr_commtallies is not used anywhere in the kernel
    so remove it. Also remove its prototype from the header file.
    
    Signed-off-by: Bhumika Goyal <bhumirks@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/hfa384x_usb.c b/drivers/staging/wlan-ng/hfa384x_usb.c
index fda8a95cb721..5271d42be623 100644
--- a/drivers/staging/wlan-ng/hfa384x_usb.c
+++ b/drivers/staging/wlan-ng/hfa384x_usb.c
@@ -1734,37 +1734,6 @@ hfa384x_dowmem(hfa384x_t *hw,
 	return result;
 }
 
-/*----------------------------------------------------------------
-* hfa384x_drvr_commtallies
-*
-* Send a commtallies inquiry to the MAC.  Note that this is an async
-* call that will result in an info frame arriving sometime later.
-*
-* Arguments:
-*	hw		device structure
-*
-* Returns:
-*	zero		success.
-*
-* Side effects:
-*
-* Call context:
-*	process
-----------------------------------------------------------------*/
-int hfa384x_drvr_commtallies(hfa384x_t *hw)
-{
-	hfa384x_metacmd_t cmd;
-
-	cmd.cmd = HFA384x_CMDCODE_INQ;
-	cmd.parm0 = HFA384x_IT_COMMTALLIES;
-	cmd.parm1 = 0;
-	cmd.parm2 = 0;
-
-	hfa384x_docmd_async(hw, &cmd, NULL, NULL, NULL);
-
-	return 0;
-}
-
 /*----------------------------------------------------------------
 * hfa384x_drvr_disable
 *

commit ca026a3504c2033821b672a09b26d467ae017eb2
Author: Bhumika Goyal <bhumirks@gmail.com>
Date:   Tue Feb 9 01:28:10 2016 +0530

    Staging:wlan-ng:Merged two lines into one
    
    The last two lines of these functions are compressed into one.
    Also removed the variable ret as it is now not used.
    Found using coccinelle:
    @@
    expression e, ret;
    @@
    
    -ret =
    +return
         e;
    -return ret;
    
    Signed-off-by: Bhumika Goyal <bhumirks@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/hfa384x_usb.c b/drivers/staging/wlan-ng/hfa384x_usb.c
index 682de77e7561..fda8a95cb721 100644
--- a/drivers/staging/wlan-ng/hfa384x_usb.c
+++ b/drivers/staging/wlan-ng/hfa384x_usb.c
@@ -1012,7 +1012,6 @@ int hfa384x_cmd_initialize(hfa384x_t *hw)
 ----------------------------------------------------------------*/
 int hfa384x_cmd_disable(hfa384x_t *hw, u16 macport)
 {
-	int result = 0;
 	hfa384x_metacmd_t cmd;
 
 	cmd.cmd = HFA384x_CMD_CMDCODE_SET(HFA384x_CMDCODE_DISABLE) |
@@ -1021,9 +1020,7 @@ int hfa384x_cmd_disable(hfa384x_t *hw, u16 macport)
 	cmd.parm1 = 0;
 	cmd.parm2 = 0;
 
-	result = hfa384x_docmd_wait(hw, &cmd);
-
-	return result;
+	return hfa384x_docmd_wait(hw, &cmd);
 }
 
 /*----------------------------------------------------------------
@@ -1048,7 +1045,6 @@ int hfa384x_cmd_disable(hfa384x_t *hw, u16 macport)
 ----------------------------------------------------------------*/
 int hfa384x_cmd_enable(hfa384x_t *hw, u16 macport)
 {
-	int result = 0;
 	hfa384x_metacmd_t cmd;
 
 	cmd.cmd = HFA384x_CMD_CMDCODE_SET(HFA384x_CMDCODE_ENABLE) |
@@ -1057,9 +1053,7 @@ int hfa384x_cmd_enable(hfa384x_t *hw, u16 macport)
 	cmd.parm1 = 0;
 	cmd.parm2 = 0;
 
-	result = hfa384x_docmd_wait(hw, &cmd);
-
-	return result;
+	return hfa384x_docmd_wait(hw, &cmd);
 }
 
 /*----------------------------------------------------------------
@@ -1093,7 +1087,6 @@ int hfa384x_cmd_enable(hfa384x_t *hw, u16 macport)
 ----------------------------------------------------------------*/
 int hfa384x_cmd_monitor(hfa384x_t *hw, u16 enable)
 {
-	int result = 0;
 	hfa384x_metacmd_t cmd;
 
 	cmd.cmd = HFA384x_CMD_CMDCODE_SET(HFA384x_CMDCODE_MONITOR) |
@@ -1102,9 +1095,7 @@ int hfa384x_cmd_monitor(hfa384x_t *hw, u16 enable)
 	cmd.parm1 = 0;
 	cmd.parm2 = 0;
 
-	result = hfa384x_docmd_wait(hw, &cmd);
-
-	return result;
+	return hfa384x_docmd_wait(hw, &cmd);
 }
 
 /*----------------------------------------------------------------
@@ -1148,7 +1139,6 @@ int hfa384x_cmd_monitor(hfa384x_t *hw, u16 enable)
 int hfa384x_cmd_download(hfa384x_t *hw, u16 mode, u16 lowaddr,
 			 u16 highaddr, u16 codelen)
 {
-	int result = 0;
 	hfa384x_metacmd_t cmd;
 
 	pr_debug("mode=%d, lowaddr=0x%04x, highaddr=0x%04x, codelen=%d\n",
@@ -1161,9 +1151,7 @@ int hfa384x_cmd_download(hfa384x_t *hw, u16 mode, u16 lowaddr,
 	cmd.parm1 = highaddr;
 	cmd.parm2 = codelen;
 
-	result = hfa384x_docmd_wait(hw, &cmd);
-
-	return result;
+	return hfa384x_docmd_wait(hw, &cmd);
 }
 
 /*----------------------------------------------------------------

commit 57477bf0d9c2d311afe5a4e6b75040aabb3a426e
Author: Geliang Tang <geliangtang@163.com>
Date:   Tue Dec 15 23:29:32 2015 +0800

    staging: wlan-ng: use list_for_each_entry*
    
    Use list_for_each_entry*() instead of list_for_each*() to simplify
    the code.
    
    Signed-off-by: Geliang Tang <geliangtang@163.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/hfa384x_usb.c b/drivers/staging/wlan-ng/hfa384x_usb.c
index a5626df2bebc..682de77e7561 100644
--- a/drivers/staging/wlan-ng/hfa384x_usb.c
+++ b/drivers/staging/wlan-ng/hfa384x_usb.c
@@ -2810,8 +2810,7 @@ void hfa384x_tx_timeout(wlandevice_t *wlandev)
 static void hfa384x_usbctlx_reaper_task(unsigned long data)
 {
 	hfa384x_t *hw = (hfa384x_t *)data;
-	struct list_head *entry;
-	struct list_head *temp;
+	hfa384x_usbctlx_t *ctlx, *temp;
 	unsigned long flags;
 
 	spin_lock_irqsave(&hw->ctlxq.lock, flags);
@@ -2819,10 +2818,7 @@ static void hfa384x_usbctlx_reaper_task(unsigned long data)
 	/* This list is guaranteed to be empty if someone
 	 * has unplugged the adapter.
 	 */
-	list_for_each_safe(entry, temp, &hw->ctlxq.reapable) {
-		hfa384x_usbctlx_t *ctlx;
-
-		ctlx = list_entry(entry, hfa384x_usbctlx_t, list);
+	list_for_each_entry_safe(ctlx, temp, &hw->ctlxq.reapable, list) {
 		list_del(&ctlx->list);
 		kfree(ctlx);
 	}
@@ -2847,8 +2843,7 @@ static void hfa384x_usbctlx_reaper_task(unsigned long data)
 static void hfa384x_usbctlx_completion_task(unsigned long data)
 {
 	hfa384x_t *hw = (hfa384x_t *)data;
-	struct list_head *entry;
-	struct list_head *temp;
+	hfa384x_usbctlx_t *ctlx, *temp;
 	unsigned long flags;
 
 	int reap = 0;
@@ -2858,11 +2853,7 @@ static void hfa384x_usbctlx_completion_task(unsigned long data)
 	/* This list is guaranteed to be empty if someone
 	 * has unplugged the adapter ...
 	 */
-	list_for_each_safe(entry, temp, &hw->ctlxq.completing) {
-		hfa384x_usbctlx_t *ctlx;
-
-		ctlx = list_entry(entry, hfa384x_usbctlx_t, list);
-
+	list_for_each_entry_safe(ctlx, temp, &hw->ctlxq.completing, list) {
 		/* Call the completion function that this
 		 * command was assigned, assuming it has one.
 		 */

commit 6c37e1f957be5f67b520e004e196b0e6a9ec2950
Author: Bogicevic Sasa <brutallesale@gmail.com>
Date:   Mon Dec 14 06:25:59 2015 -0800

    drivers:staging:wlan-ng Fix space preferred around that messages
    
    This fixes all "space preferred around that ..." messages from
    checkpatch.pl
    
    Signed-off-by: Bogicevic Sasa <brutallesale@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/hfa384x_usb.c b/drivers/staging/wlan-ng/hfa384x_usb.c
index 7551ac25d89d..a5626df2bebc 100644
--- a/drivers/staging/wlan-ng/hfa384x_usb.c
+++ b/drivers/staging/wlan-ng/hfa384x_usb.c
@@ -145,11 +145,11 @@ enum cmd_mode {
 	DOASYNC
 };
 
-#define THROTTLE_JIFFIES	(HZ/8)
+#define THROTTLE_JIFFIES	(HZ / 8)
 #define URB_ASYNC_UNLINK 0
 #define USB_QUEUE_BULK 0
 
-#define ROUNDUP64(a) (((a)+63)&~63)
+#define ROUNDUP64(a) (((a) + 63) & ~63)
 
 #ifdef DEBUG_USB
 static void dbprint_urb(struct urb *urb);
@@ -3985,8 +3985,7 @@ static void hfa384x_usb_throttlefn(unsigned long data)
 	pr_debug("flags=0x%lx\n", hw->usb_flags);
 	if (!hw->wlandev->hwremoved &&
 	    ((test_and_clear_bit(THROTTLE_RX, &hw->usb_flags) &&
-	      !test_and_set_bit(WORK_RX_RESUME, &hw->usb_flags))
-	     |
+	      !test_and_set_bit(WORK_RX_RESUME, &hw->usb_flags)) |
 	     (test_and_clear_bit(THROTTLE_TX, &hw->usb_flags) &&
 	      !test_and_set_bit(WORK_TX_RESUME, &hw->usb_flags))
 	    )) {

commit 6ba714bb5f78d8d5647e8b8afbb739223c5a4620
Author: Amitoj Kaur Chawla <amitoj1606@gmail.com>
Date:   Sat Oct 31 15:47:38 2015 +0530

    staging: wlan-ng: hfa384x_usb: Remove wrapper function
    
    Remove wrapper function that can be replaced by a single line of code.
    
    As a result of the change, there is an unused variable which has also
    been removed in this patch.
    
    Signed-off-by: Amitoj Kaur Chawla <amitoj1606@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/hfa384x_usb.c b/drivers/staging/wlan-ng/hfa384x_usb.c
index e3c9860fb2cb..7551ac25d89d 100644
--- a/drivers/staging/wlan-ng/hfa384x_usb.c
+++ b/drivers/staging/wlan-ng/hfa384x_usb.c
@@ -177,9 +177,6 @@ static void hfa384x_usbin_rx(wlandevice_t *wlandev, struct sk_buff *skb);
 
 static void hfa384x_usbin_info(wlandevice_t *wlandev, hfa384x_usbin_t *usbin);
 
-static void
-hfa384x_usbout_tx(wlandevice_t *wlandev, hfa384x_usbout_t *usbout);
-
 static void hfa384x_usbin_ctlx(hfa384x_t *hw, hfa384x_usbin_t *usbin,
 			       int urb_status);
 
@@ -3674,7 +3671,6 @@ static void hfa384x_usbin_info(wlandevice_t *wlandev, hfa384x_usbin_t *usbin)
 static void hfa384x_usbout_callback(struct urb *urb)
 {
 	wlandevice_t *wlandev = urb->context;
-	hfa384x_usbout_t *usbout = urb->transfer_buffer;
 
 #ifdef DEBUG_USB
 	dbprint_urb(urb);
@@ -3683,7 +3679,7 @@ static void hfa384x_usbout_callback(struct urb *urb)
 	if (wlandev && wlandev->netdev) {
 		switch (urb->status) {
 		case 0:
-			hfa384x_usbout_tx(wlandev, usbout);
+			prism2sta_ev_alloc(wlandev);
 			break;
 
 		case -EPIPE:
@@ -4037,30 +4033,6 @@ static int hfa384x_usbctlx_submit(hfa384x_t *hw, hfa384x_usbctlx_t *ctlx)
 	return 0;
 }
 
-/*----------------------------------------------------------------
-* hfa384x_usbout_tx
-*
-* At this point we have finished a send of a frame.  Mark the URB
-* as available and call ev_alloc to notify higher layers we're
-* ready for more.
-*
-* Arguments:
-*	wlandev		wlan device
-*	usbout		ptr to the usb transfer buffer
-*
-* Returns:
-*	nothing
-*
-* Side effects:
-*
-* Call context:
-*	interrupt
-----------------------------------------------------------------*/
-static void hfa384x_usbout_tx(wlandevice_t *wlandev, hfa384x_usbout_t *usbout)
-{
-	prism2sta_ev_alloc(wlandev);
-}
-
 /*----------------------------------------------------------------
 * hfa384x_isgood_pdrcore
 *

commit 4e2cdf9324e93eef2e06f640d001979368f1e2b7
Author: Amitoj Kaur Chawla <amitoj1606@gmail.com>
Date:   Sat Oct 31 15:51:04 2015 +0530

    staging: wlan-ng: Remove wrapper function
    
    Remove wrapper function that can be replaced by a single line of code.
    
    Signed-off-by: Amitoj Kaur Chawla <amitoj1606@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/hfa384x_usb.c b/drivers/staging/wlan-ng/hfa384x_usb.c
index 444ebed7313a..e3c9860fb2cb 100644
--- a/drivers/staging/wlan-ng/hfa384x_usb.c
+++ b/drivers/staging/wlan-ng/hfa384x_usb.c
@@ -3504,7 +3504,7 @@ static void hfa384x_usbin_rx(wlandevice_t *wlandev, struct sk_buff *skb)
 		rxmeta->signal = usbin->rxfrm.desc.signal - hw->dbmadjust;
 		rxmeta->noise = usbin->rxfrm.desc.silence - hw->dbmadjust;
 
-		prism2sta_ev_rx(wlandev, skb);
+		p80211netdev_rx(wlandev, skb);
 
 		break;
 
@@ -3628,7 +3628,7 @@ static void hfa384x_int_rxmonitor(wlandevice_t *wlandev,
 	}
 
 	/* pass it back up */
-	prism2sta_ev_rx(wlandev, skb);
+	p80211netdev_rx(wlandev, skb);
 }
 
 /*----------------------------------------------------------------

commit df18b9304e3c8db6753519068cc2b8fb8cc6a40b
Author: Amitoj Kaur Chawla <amitoj1606@gmail.com>
Date:   Thu Oct 15 01:42:11 2015 +0530

    staging: wlan-ng: Remove useless initialization
    
    Remove intialisation of a variable that is immediately reassigned.
    
    The semantic patch used to find this is:
    
    // <smpl>
    @@
    type T;
    identifier x;
    constant C;
    expression e;
    @@
    
    T x
    - = C
     ;
    x = e;
    // </smpl>
    
    Signed-off-by: Amitoj Kaur Chawla <amitoj1606@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/hfa384x_usb.c b/drivers/staging/wlan-ng/hfa384x_usb.c
index e109a7fd422f..444ebed7313a 100644
--- a/drivers/staging/wlan-ng/hfa384x_usb.c
+++ b/drivers/staging/wlan-ng/hfa384x_usb.c
@@ -1194,7 +1194,7 @@ int hfa384x_cmd_download(hfa384x_t *hw, u16 mode, u16 lowaddr,
 ----------------------------------------------------------------*/
 int hfa384x_corereset(hfa384x_t *hw, int holdtime, int settletime, int genesis)
 {
-	int result = 0;
+	int result;
 
 	result = usb_reset_device(hw->usb);
 	if (result < 0) {

commit d0edf4bcfa67702e821acb8592bc9b33a328f13a
Author: Navya Sri Nizamkari <navyasri.tech@gmail.com>
Date:   Tue Mar 10 17:55:40 2015 +0530

    staging: wlan-ng: Use kzalloc instead of kmalloc.
    
    This patch uses kzalloc instead of kmalloc function.
    A coccinelle script was used to make this change.
    
    Signed-off-by: Navya Sri Nizamkari <navyasri.tech@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/hfa384x_usb.c b/drivers/staging/wlan-ng/hfa384x_usb.c
index c85b1b55fdb3..e109a7fd422f 100644
--- a/drivers/staging/wlan-ng/hfa384x_usb.c
+++ b/drivers/staging/wlan-ng/hfa384x_usb.c
@@ -619,11 +619,10 @@ static hfa384x_usbctlx_t *usbctlx_alloc(void)
 {
 	hfa384x_usbctlx_t *ctlx;
 
-	ctlx = kmalloc(sizeof(*ctlx), in_interrupt() ? GFP_ATOMIC : GFP_KERNEL);
-	if (ctlx != NULL) {
-		memset(ctlx, 0, sizeof(*ctlx));
+	ctlx = kzalloc(sizeof(*ctlx),
+		       in_interrupt() ? GFP_ATOMIC : GFP_KERNEL);
+	if (ctlx != NULL)
 		init_completion(&ctlx->done);
-	}
 
 	return ctlx;
 }

commit 2f83aeda567a9f5347153fb21f29e0b09b3aa83a
Author: Aya Mahfouz <mahfouz.saif.elyazal@gmail.com>
Date:   Thu Feb 19 07:55:43 2015 +0200

    staging: wlan-ng: replace init_timer by setup_timer
    
    This patch replaces init_timer and the 2 step initialization of function
    and data by setup_timer to make the code more concise.
    
    The issue was discovered using the following coccinelle script:
    
    @@
    expression ds, e1, e2;
    @@
    
    -init_timer (&ds);
    +setup_timer (&ds, e1, e2);
    ...
    (
    -ds.function = e1;
    ...
    -ds.data = e2;
    |
    -ds.data = e2;
    ...
    -ds.function = e1;
    )
    
    Signed-off-by: Aya Mahfouz <mahfouz.saif.elyazal@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/hfa384x_usb.c b/drivers/staging/wlan-ng/hfa384x_usb.c
index 28cd1c4c02c8..c85b1b55fdb3 100644
--- a/drivers/staging/wlan-ng/hfa384x_usb.c
+++ b/drivers/staging/wlan-ng/hfa384x_usb.c
@@ -557,17 +557,13 @@ void hfa384x_create(hfa384x_t *hw, struct usb_device *usb)
 	INIT_WORK(&hw->link_bh, prism2sta_processing_defer);
 	INIT_WORK(&hw->usb_work, hfa384x_usb_defer);
 
-	init_timer(&hw->throttle);
-	hw->throttle.function = hfa384x_usb_throttlefn;
-	hw->throttle.data = (unsigned long)hw;
+	setup_timer(&hw->throttle, hfa384x_usb_throttlefn, (unsigned long)hw);
 
-	init_timer(&hw->resptimer);
-	hw->resptimer.function = hfa384x_usbctlx_resptimerfn;
-	hw->resptimer.data = (unsigned long)hw;
+	setup_timer(&hw->resptimer, hfa384x_usbctlx_resptimerfn,
+		    (unsigned long)hw);
 
-	init_timer(&hw->reqtimer);
-	hw->reqtimer.function = hfa384x_usbctlx_reqtimerfn;
-	hw->reqtimer.data = (unsigned long)hw;
+	setup_timer(&hw->reqtimer, hfa384x_usbctlx_reqtimerfn,
+		    (unsigned long)hw);
 
 	usb_init_urb(&hw->rx_urb);
 	usb_init_urb(&hw->tx_urb);
@@ -577,9 +573,8 @@ void hfa384x_create(hfa384x_t *hw, struct usb_device *usb)
 	hw->state = HFA384x_STATE_INIT;
 
 	INIT_WORK(&hw->commsqual_bh, prism2sta_commsqual_defer);
-	init_timer(&hw->commsqual_timer);
-	hw->commsqual_timer.data = (unsigned long)hw;
-	hw->commsqual_timer.function = prism2sta_commsqual_timer;
+	setup_timer(&hw->commsqual_timer, prism2sta_commsqual_timer,
+		    (unsigned long)hw);
 }
 
 /*----------------------------------------------------------------

commit a78d131265661bcc6a022b0d0cc4904a58abd362
Author: Asaf Vertz <asaf.vertz@tandemg.com>
Date:   Sun Jan 18 09:11:39 2015 +0200

    staging: wlan-ng: hfa384x_usb: fix sparse endianness warnings
    
    Fixed the following warnings (reported by sparse):
    drivers/staging/wlan-ng/hfa384x_usb.c:3828:36: warning: cast to restricted __le16
    drivers/staging/wlan-ng/hfa384x_usb.c:3229:16: warning: cast to restricted __le16
    drivers/staging/wlan-ng/hfa384x_usb.c:3430:18: warning: cast to restricted __le16
    drivers/staging/wlan-ng/hfa384x_usb.c:3349:51: warning: restricted __le16 degrades to integer
    drivers/staging/wlan-ng/hfa384x_usb.c:3357:37: warning: cast to restricted __le16
    drivers/staging/wlan-ng/hfa384x_usb.c:3358:37: warning: cast to restricted __le16
    drivers/staging/wlan-ng/hfa384x_usb.c:3393:36: warning: cast to restricted __le16
    drivers/staging/wlan-ng/hfa384x_usb.c:3102:28: warning: cast to restricted __le16
    drivers/staging/wlan-ng/hfa384x_usb.c:3004:28: warning: cast to restricted __le16
    drivers/staging/wlan-ng/hfa384x_usb.c:1308:37: warning: cast to restricted __le16
    drivers/staging/wlan-ng/hfa384x_usb.c:2713:25: warning: incorrect type in assignment (different base types)
    drivers/staging/wlan-ng/hfa384x_usb.c:2713:25:    expected unsigned short [unsigned] [usertype] type
    drivers/staging/wlan-ng/hfa384x_usb.c:2713:25:    got restricted __le16 [usertype] <noident>
    
    Signed-off-by: Asaf Vertz <asaf.vertz@tandemg.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/hfa384x_usb.c b/drivers/staging/wlan-ng/hfa384x_usb.c
index 2245339eb6a2..28cd1c4c02c8 100644
--- a/drivers/staging/wlan-ng/hfa384x_usb.c
+++ b/drivers/staging/wlan-ng/hfa384x_usb.c
@@ -3346,7 +3346,7 @@ static void hfa384x_usbin_ctlx(hfa384x_t *hw, hfa384x_usbin_t *usbin,
 		if (unlocked_usbctlx_cancel_async(hw, ctlx) == 0)
 			run_queue = 1;
 	} else {
-		const u16 intype = (usbin->type & ~cpu_to_le16(0x8000));
+		const __le16 intype = (usbin->type & ~cpu_to_le16(0x8000));
 
 		/*
 		 * Check that our message is what we're expecting ...

commit 1a6dfce737cc7d8f7a99c79ca7c15c64fb840534
Author: Masanari Iida <standby24x7@gmail.com>
Date:   Mon Dec 1 00:29:00 2014 +0900

    staging: wlan-ng: Fix typo in comments and printk
    
    This patch fix spelling typo in comments and print.
    
    Signed-off-by: Masanari Iida <standby24x7@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/hfa384x_usb.c b/drivers/staging/wlan-ng/hfa384x_usb.c
index de33a07904f2..2245339eb6a2 100644
--- a/drivers/staging/wlan-ng/hfa384x_usb.c
+++ b/drivers/staging/wlan-ng/hfa384x_usb.c
@@ -382,7 +382,7 @@ static int submit_rx_urb(hfa384x_t *hw, gfp_t memflags)
 *
 * Arguments:
 *	hw		device struct
-*	tx_urb		URB of data for tranmission
+*	tx_urb		URB of data for transmission
 *	memflags	memory allocation flags
 *
 * Returns:
@@ -2391,7 +2391,7 @@ int hfa384x_drvr_ramdl_write(hfa384x_t *hw, u32 daddr, void *buf, u32 len)
 *	0		success
 *	>0		f/w reported error - f/w status code
 *	<0		driver reported error
-*	-ETIMEDOUT	timout waiting for the cmd regs to become
+*	-ETIMEDOUT	timeout waiting for the cmd regs to become
 *			available, or waiting for the control reg
 *			to indicate the Aux port is enabled.
 *	-ENODATA	the buffer does NOT contain a valid PDA.

commit 81980c16e27cc87c10265e7c62779ccabcaf456b
Author: Eduardo Barretto <edusbarretto@gmail.com>
Date:   Fri Dec 19 23:34:33 2014 -0200

    Staging: wlan-ng: hfa384x_usb: fixed an 'else' statement coding style issue
    
    Removed useless 'else' statement that followed an 'if' statement that
    had a return 1 and moved all the content from the 'else' to outside of
    the switch case, this way if any case is sufficient it returns '1',
    otherwise it will return 0.
    
    Signed-off-by: Eduardo Barretto <edusbarretto@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/hfa384x_usb.c b/drivers/staging/wlan-ng/hfa384x_usb.c
index 55d2f563e308..de33a07904f2 100644
--- a/drivers/staging/wlan-ng/hfa384x_usb.c
+++ b/drivers/staging/wlan-ng/hfa384x_usb.c
@@ -4123,12 +4123,11 @@ static int hfa384x_isgood_pdrcode(u16 pdrcode)
 			pr_debug("Encountered unknown PDR#=0x%04x, assuming it's ok.\n",
 				 pdrcode);
 			return 1;
-		} else {
-			/* bad code */
-			pr_debug("Encountered unknown PDR#=0x%04x, (>=0x1000), assuming it's bad.\n",
-				 pdrcode);
-			return 0;
 		}
+		break;
 	}
-	return 0;		/* avoid compiler warnings */
+	/* bad code */
+	pr_debug("Encountered unknown PDR#=0x%04x, (>=0x1000), assuming it's bad.\n",
+		 pdrcode);
+	return 0;
 }

commit fb282bcd9c957387097cde370905784993281df6
Author: Melike Yurtoglu <aysemelikeyurtoglu@gmail.com>
Date:   Sat Oct 4 02:30:35 2014 +0300

    staging: wlan-ng: remove unnecessary 'out of memory' message
    
    This patch fixes "Possible unnecessary 'out of memory' message"
    checkpatch.pl warning in hfa384x_usb.c
    
    Signed-off-by: Melike Yurtoglu <aysemelikeyurtoglu@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/hfa384x_usb.c b/drivers/staging/wlan-ng/hfa384x_usb.c
index 898bde73c59a..55d2f563e308 100644
--- a/drivers/staging/wlan-ng/hfa384x_usb.c
+++ b/drivers/staging/wlan-ng/hfa384x_usb.c
@@ -3583,12 +3583,8 @@ static void hfa384x_int_rxmonitor(wlandevice_t *wlandev,
 	}
 
 	skb = dev_alloc_skb(skblen);
-	if (skb == NULL) {
-		netdev_err(hw->wlandev->netdev,
-			   "alloc_skb failed trying to allocate %d bytes\n",
-			   skblen);
+	if (skb == NULL)
 		return;
-	}
 
 	/* only prepend the prism header if in the right mode */
 	if ((wlandev->netdev->type == ARPHRD_IEEE80211_PRISM) &&

commit 34c376fe07342e06f531504b01d3b953962e456c
Author: Aybuke Ozdemir <aybuke.147@gmail.com>
Date:   Thu Sep 18 01:03:28 2014 +0300

    Staging: wlan-ng: Fix return in void function warning
    
    This fixes checkpatch.pl warning:
    WARNING: void function return statements are not generally useful
    
    Signed-off-by: Aybuke Ozdemir <aybuke.147@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/hfa384x_usb.c b/drivers/staging/wlan-ng/hfa384x_usb.c
index cac55c60d52d..898bde73c59a 100644
--- a/drivers/staging/wlan-ng/hfa384x_usb.c
+++ b/drivers/staging/wlan-ng/hfa384x_usb.c
@@ -3530,8 +3530,6 @@ static void hfa384x_usbin_rx(wlandevice_t *wlandev, struct sk_buff *skb)
 				    usbin->rxfrm.desc.status));
 		break;
 	}
-
-	return;
 }
 
 /*----------------------------------------------------------------
@@ -3641,8 +3639,6 @@ static void hfa384x_int_rxmonitor(wlandevice_t *wlandev,
 
 	/* pass it back up */
 	prism2sta_ev_rx(wlandev, skb);
-
-	return;
 }
 
 /*----------------------------------------------------------------

commit cc5bcbbdbf29914e1ab679548c7da68ea46829cf
Author: Ilja Sidoroff <ilja.sidoroff@iki.fi>
Date:   Mon Sep 8 17:37:53 2014 +0300

    Staging: wlan-ng: Remove redundant break/goto statements in hfa384x_usb.c
    
    This patch removes redundant goto or break statements in hfa384x_usb.c as found by checkpatch.pl
    
    Signed-off-by: Ilja Sidoroff <ilja.sidoroff@iki.fi>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/hfa384x_usb.c b/drivers/staging/wlan-ng/hfa384x_usb.c
index 2f63e0c6d445..cac55c60d52d 100644
--- a/drivers/staging/wlan-ng/hfa384x_usb.c
+++ b/drivers/staging/wlan-ng/hfa384x_usb.c
@@ -3474,7 +3474,7 @@ static void hfa384x_usbin_rx(wlandevice_t *wlandev, struct sk_buff *skb)
 		/* If exclude and we receive an unencrypted, drop it */
 		if ((wlandev->hostwep & HOSTWEP_EXCLUDEUNENCRYPTED) &&
 		    !WLAN_GET_FC_ISWEP(fc)) {
-			goto done;
+			break;
 		}
 
 		data_len = le16_to_cpu(usbin->rxfrm.desc.data_len);
@@ -3528,11 +3528,9 @@ static void hfa384x_usbin_rx(wlandevice_t *wlandev, struct sk_buff *skb)
 		netdev_warn(hw->wlandev->netdev, "Received frame on unsupported port=%d\n",
 			    HFA384x_RXSTATUS_MACPORT_GET(
 				    usbin->rxfrm.desc.status));
-		goto done;
 		break;
 	}
 
-done:
 	return;
 }
 
@@ -4127,7 +4125,6 @@ static int hfa384x_isgood_pdrcode(u16 pdrcode)
 	case HFA384x_PDR_HFA3861_MANF_TESTI:
 		/* code is OK */
 		return 1;
-		break;
 	default:
 		if (pdrcode < 0x1000) {
 			/* code is OK, but we don't know exactly what it is */
@@ -4140,7 +4137,6 @@ static int hfa384x_isgood_pdrcode(u16 pdrcode)
 				 pdrcode);
 			return 0;
 		}
-		break;
 	}
 	return 0;		/* avoid compiler warnings */
 }

commit 9630f6b97a5918c7a14803954ae2ff5ff3f9fb3c
Author: Tobias Klauser <tklauser@distanz.ch>
Date:   Tue Jul 8 08:37:00 2014 +0200

    staging: wlan-ng: Use net_device_stats from struct net_device
    
    Instead of using an own copy of struct net_device_stats in struct
    wlandevice, use stats from struct net_device. Also remove the thus
    unnecessary .ndo_get_stats function, as it would now just return
    netdev->stats, which is the default in dev_get_stats().
    
    Furthermore, convert prefix increment of stats counters to the more
    common postfix increment idiom.
    
    Signed-off-by: Tobias Klauser <tklauser@distanz.ch>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/hfa384x_usb.c b/drivers/staging/wlan-ng/hfa384x_usb.c
index 07cee5637276..2f63e0c6d445 100644
--- a/drivers/staging/wlan-ng/hfa384x_usb.c
+++ b/drivers/staging/wlan-ng/hfa384x_usb.c
@@ -3158,8 +3158,8 @@ static void hfa384x_usbin_callback(struct urb *urb)
 
 		/* Check for short packet */
 		if (urb->actual_length == 0) {
-			++(wlandev->linux_stats.rx_errors);
-			++(wlandev->linux_stats.rx_length_errors);
+			wlandev->netdev->stats.rx_errors++;
+			wlandev->netdev->stats.rx_length_errors++;
 			action = RESUBMIT;
 		}
 		break;
@@ -3169,7 +3169,7 @@ static void hfa384x_usbin_callback(struct urb *urb)
 			    wlandev->netdev->name);
 		if (!test_and_set_bit(WORK_RX_HALT, &hw->usb_flags))
 			schedule_work(&hw->usb_work);
-		++(wlandev->linux_stats.rx_errors);
+		wlandev->netdev->stats.rx_errors++;
 		action = ABORT;
 		break;
 
@@ -3180,12 +3180,12 @@ static void hfa384x_usbin_callback(struct urb *urb)
 		    !timer_pending(&hw->throttle)) {
 			mod_timer(&hw->throttle, jiffies + THROTTLE_JIFFIES);
 		}
-		++(wlandev->linux_stats.rx_errors);
+		wlandev->netdev->stats.rx_errors++;
 		action = ABORT;
 		break;
 
 	case -EOVERFLOW:
-		++(wlandev->linux_stats.rx_over_errors);
+		wlandev->netdev->stats.rx_over_errors++;
 		action = RESUBMIT;
 		break;
 
@@ -3204,7 +3204,7 @@ static void hfa384x_usbin_callback(struct urb *urb)
 	default:
 		pr_debug("urb status=%d, transfer flags=0x%x\n",
 			 urb->status, urb->transfer_flags);
-		++(wlandev->linux_stats.rx_errors);
+		wlandev->netdev->stats.rx_errors++;
 		action = RESUBMIT;
 		break;
 	}
@@ -3712,7 +3712,7 @@ static void hfa384x_usbout_callback(struct urb *urb)
 				if (!test_and_set_bit
 				    (WORK_TX_HALT, &hw->usb_flags))
 					schedule_work(&hw->usb_work);
-				++(wlandev->linux_stats.tx_errors);
+				wlandev->netdev->stats.tx_errors++;
 				break;
 			}
 
@@ -3728,7 +3728,7 @@ static void hfa384x_usbout_callback(struct urb *urb)
 					mod_timer(&hw->throttle,
 						  jiffies + THROTTLE_JIFFIES);
 				}
-				++(wlandev->linux_stats.tx_errors);
+				wlandev->netdev->stats.tx_errors++;
 				netif_stop_queue(wlandev->netdev);
 				break;
 			}
@@ -3741,7 +3741,7 @@ static void hfa384x_usbout_callback(struct urb *urb)
 		default:
 			netdev_info(wlandev->netdev, "unknown urb->status=%d\n",
 				    urb->status);
-			++(wlandev->linux_stats.tx_errors);
+			wlandev->netdev->stats.tx_errors++;
 			break;
 		}		/* switch */
 	}

commit 4d525ef61fd7bed7ef7c34c1398ffcdead0ac53c
Author: Cheng-Wei Lee <lee.rhapsody@gmail.com>
Date:   Fri Jun 27 19:42:14 2014 +0800

    staging: wlan-ng/hfa384x_usb.c: add blank line after declarations
    
    This patch fixes the following checkpatch.pl issues in hfa384x_usb.c:
    WARNING: Missing a blank line after declarations
    
    Signed-off-by: Quentin Lee <lee.rhapsody@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/hfa384x_usb.c b/drivers/staging/wlan-ng/hfa384x_usb.c
index 98343ff70615..07cee5637276 100644
--- a/drivers/staging/wlan-ng/hfa384x_usb.c
+++ b/drivers/staging/wlan-ng/hfa384x_usb.c
@@ -3705,6 +3705,7 @@ static void hfa384x_usbout_callback(struct urb *urb)
 		case -EPIPE:
 			{
 				hfa384x_t *hw = wlandev->priv;
+
 				netdev_warn(hw->wlandev->netdev,
 					    "%s tx pipe stalled: requesting reset\n",
 					    wlandev->netdev->name);

commit 4764ca981b040048766e4f39a45a4b9c5cecff9c
Author: Peter Senna Tschudin <peter.senna@gmail.com>
Date:   Mon May 26 16:08:50 2014 +0200

    drivers/staging: Remove useless return variables
    
    This patch remove variables that are initialized with a constant,
    are never updated, and are only used as parameter of return.
    Return the constant instead of using a variable.
    
    Verified by compilation only.
    
    The coccinelle script that find and fixes this issue is:
    // <smpl>
    @@
    type T;
    constant C;
    identifier ret;
    @@
    - T ret = C;
    ... when != ret
        when strict
    return
    - ret
    + C
    ;
    // </smpl>
    
    Signed-off-by: Peter Senna Tschudin <peter.senna@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/hfa384x_usb.c b/drivers/staging/wlan-ng/hfa384x_usb.c
index f0ab5a27015e..98343ff70615 100644
--- a/drivers/staging/wlan-ng/hfa384x_usb.c
+++ b/drivers/staging/wlan-ng/hfa384x_usb.c
@@ -2642,7 +2642,6 @@ int hfa384x_drvr_start(hfa384x_t *hw)
 ----------------------------------------------------------------*/
 int hfa384x_drvr_stop(hfa384x_t *hw)
 {
-	int result = 0;
 	int i;
 
 	might_sleep();
@@ -2667,7 +2666,7 @@ int hfa384x_drvr_stop(hfa384x_t *hw)
 	for (i = 0; i < HFA384x_NUMPORTS_MAX; i++)
 		hw->port_enabled[i] = 0;
 
-	return result;
+	return 0;
 }
 
 /*----------------------------------------------------------------

commit 5d85fe346fc34e1d5932974a95440297cd7a009f
Author: Sherif Shehab Aldin <shehabaldin.sherif@gmail.com>
Date:   Sat Apr 5 23:35:15 2014 +0200

    driver: staging: wlan-ng: Removed unnecessary spaces after cast from hfa384x_usb.c
    
    Fixed: No space is necessary after a cast
    
    Signed-off-by: Sherif Shehab Aldin <shehabaldin.sherif@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/hfa384x_usb.c b/drivers/staging/wlan-ng/hfa384x_usb.c
index 867edb4354d6..f0ab5a27015e 100644
--- a/drivers/staging/wlan-ng/hfa384x_usb.c
+++ b/drivers/staging/wlan-ng/hfa384x_usb.c
@@ -673,7 +673,7 @@ static inline int usbctlx_cmd_completor_fn(struct usbctlx_completor *head)
 {
 	struct usbctlx_cmd_completor *complete;
 
-	complete = (struct usbctlx_cmd_completor *) head;
+	complete = (struct usbctlx_cmd_completor *)head;
 	return usbctlx_get_status(complete->cmdresp, complete->result);
 }
 
@@ -708,7 +708,7 @@ static int usbctlx_rrid_completor_fn(struct usbctlx_completor *head)
 	struct usbctlx_rrid_completor *complete;
 	hfa384x_rridresult_t rridresult;
 
-	complete = (struct usbctlx_rrid_completor *) head;
+	complete = (struct usbctlx_rrid_completor *)head;
 	usbctlx_get_rridresult(complete->rridresp, &rridresult);
 
 	/* Validate the length, note body len calculation in bytes */
@@ -2819,7 +2819,7 @@ void hfa384x_tx_timeout(wlandevice_t *wlandev)
 ----------------------------------------------------------------*/
 static void hfa384x_usbctlx_reaper_task(unsigned long data)
 {
-	hfa384x_t *hw = (hfa384x_t *) data;
+	hfa384x_t *hw = (hfa384x_t *)data;
 	struct list_head *entry;
 	struct list_head *temp;
 	unsigned long flags;
@@ -2856,7 +2856,7 @@ static void hfa384x_usbctlx_reaper_task(unsigned long data)
 ----------------------------------------------------------------*/
 static void hfa384x_usbctlx_completion_task(unsigned long data)
 {
-	hfa384x_t *hw = (hfa384x_t *) data;
+	hfa384x_t *hw = (hfa384x_t *)data;
 	struct list_head *entry;
 	struct list_head *temp;
 	unsigned long flags;
@@ -3128,7 +3128,7 @@ static void hfa384x_usbin_callback(struct urb *urb)
 {
 	wlandevice_t *wlandev = urb->context;
 	hfa384x_t *hw;
-	hfa384x_usbin_t *usbin = (hfa384x_usbin_t *) urb->transfer_buffer;
+	hfa384x_usbin_t *usbin = (hfa384x_usbin_t *)urb->transfer_buffer;
 	struct sk_buff *skb = NULL;
 	int result;
 	int urb_status;
@@ -3456,7 +3456,7 @@ static void hfa384x_usbin_txcompl(wlandevice_t *wlandev,
 ----------------------------------------------------------------*/
 static void hfa384x_usbin_rx(wlandevice_t *wlandev, struct sk_buff *skb)
 {
-	hfa384x_usbin_t *usbin = (hfa384x_usbin_t *) skb->data;
+	hfa384x_usbin_t *usbin = (hfa384x_usbin_t *)skb->data;
 	hfa384x_t *hw = wlandev->priv;
 	int hdrlen;
 	struct p80211_rxmeta *rxmeta;
@@ -3601,7 +3601,7 @@ static void hfa384x_int_rxmonitor(wlandevice_t *wlandev,
 		struct p80211_caphdr *caphdr;
 		/* The NEW header format! */
 		datap = skb_put(skb, sizeof(struct p80211_caphdr));
-		caphdr = (struct p80211_caphdr *) datap;
+		caphdr = (struct p80211_caphdr *)datap;
 
 		caphdr->version = htonl(P80211CAPTURE_VERSION);
 		caphdr->length = htonl(sizeof(struct p80211_caphdr));
@@ -3896,7 +3896,7 @@ static void hfa384x_ctlxout_callback(struct urb *urb)
 ----------------------------------------------------------------*/
 static void hfa384x_usbctlx_reqtimerfn(unsigned long data)
 {
-	hfa384x_t *hw = (hfa384x_t *) data;
+	hfa384x_t *hw = (hfa384x_t *)data;
 	unsigned long flags;
 
 	spin_lock_irqsave(&hw->ctlxq.lock, flags);
@@ -3954,7 +3954,7 @@ static void hfa384x_usbctlx_reqtimerfn(unsigned long data)
 ----------------------------------------------------------------*/
 static void hfa384x_usbctlx_resptimerfn(unsigned long data)
 {
-	hfa384x_t *hw = (hfa384x_t *) data;
+	hfa384x_t *hw = (hfa384x_t *)data;
 	unsigned long flags;
 
 	spin_lock_irqsave(&hw->ctlxq.lock, flags);
@@ -3993,7 +3993,7 @@ static void hfa384x_usbctlx_resptimerfn(unsigned long data)
 ----------------------------------------------------------------*/
 static void hfa384x_usb_throttlefn(unsigned long data)
 {
-	hfa384x_t *hw = (hfa384x_t *) data;
+	hfa384x_t *hw = (hfa384x_t *)data;
 	unsigned long flags;
 
 	spin_lock_irqsave(&hw->ctlxq.lock, flags);

commit 638f81b849a306e4a897f99f51e22ba515338e21
Author: Sherif Shehab Aldin <shehabaldin.sherif@gmail.com>
Date:   Sat Apr 5 23:35:06 2014 +0200

    driver: staging: wlan-ng: Removed #if 0 lines from hfa384x_usb.c
    
    Removed lines that were ignored by #if 0
    
    Signed-off-by: Sherif Shehab Aldin <shehabaldin.sherif@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/hfa384x_usb.c b/drivers/staging/wlan-ng/hfa384x_usb.c
index cf2703062e96..867edb4354d6 100644
--- a/drivers/staging/wlan-ng/hfa384x_usb.c
+++ b/drivers/staging/wlan-ng/hfa384x_usb.c
@@ -2019,12 +2019,6 @@ int hfa384x_drvr_flashdl_write(hfa384x_t *hw, u32 daddr, void *buf, u32 len)
 	    HFA384x_ADDR_AUX_MKFLAT(hw->bufinfo.page, hw->bufinfo.offset);
 	pr_debug("dlbuf.page=0x%04x dlbuf.offset=0x%04x dlbufaddr=0x%08x\n",
 		 hw->bufinfo.page, hw->bufinfo.offset, dlbufaddr);
-
-#if 0
-	netdev_warn(hw->wlandev->netdev,
-		    "dlbuf@0x%06lx len=%d to=%d\n", dlbufaddr,
-		    hw->bufinfo.len, hw->dltimeout);
-#endif
 	/* Calculations to determine how many fills of the dlbuffer to do
 	 * and how many USB wmemreq's to do for each fill.  At this point
 	 * in time, the dlbuffer size and the wmemreq size are the same.

commit 96b1971ace70c563048d341bfc1bd55754b95183
Author: Sherif Shehab Aldin <shehabaldin.sherif@gmail.com>
Date:   Sat Apr 5 23:34:56 2014 +0200

    driver: staging: wlan-ng: Removed multiple assignments
    
    Removed multiple assignments from hfa384x_usb.c
    
    Signed-off-by: Sherif Shehab Aldin <shehabaldin.sherif@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/hfa384x_usb.c b/drivers/staging/wlan-ng/hfa384x_usb.c
index 1a6116a5093c..cf2703062e96 100644
--- a/drivers/staging/wlan-ng/hfa384x_usb.c
+++ b/drivers/staging/wlan-ng/hfa384x_usb.c
@@ -2599,7 +2599,8 @@ int hfa384x_drvr_start(hfa384x_t *hw)
 	 */
 	result1 = hfa384x_cmd_initialize(hw);
 	msleep(1000);
-	result = result2 = hfa384x_cmd_initialize(hw);
+	result = hfa384x_cmd_initialize(hw);
+	result2 = result;
 	if (result1 != 0) {
 		if (result2 != 0) {
 			netdev_err(hw->wlandev->netdev,

commit a3542e664bb10c10c52088efc460371225a939b0
Author: Sherif Shehab Aldin <shehabaldin.sherif@gmail.com>
Date:   Sat Apr 5 23:34:48 2014 +0200

    driver: staging: wlan-ng: Fixed white spaces issues
    
    In hfa384x_usb.c:
    Moved Logical continuations to the correct lines
    Removed unnecessary blank lines
    
    Signed-off-by: Sherif Shehab Aldin <shehabaldin.sherif@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/hfa384x_usb.c b/drivers/staging/wlan-ng/hfa384x_usb.c
index a6684b67f8f4..1a6116a5093c 100644
--- a/drivers/staging/wlan-ng/hfa384x_usb.c
+++ b/drivers/staging/wlan-ng/hfa384x_usb.c
@@ -398,9 +398,8 @@ static int submit_tx_urb(hfa384x_t *hw, struct urb *tx_urb, gfp_t memflags)
 
 	result = -ENOLINK;
 	if (netif_running(netdev)) {
-
-		if (!hw->wlandev->hwremoved
-		    && !test_bit(WORK_TX_HALT, &hw->usb_flags)) {
+		if (!hw->wlandev->hwremoved &&
+		    !test_bit(WORK_TX_HALT, &hw->usb_flags)) {
 			result = SUBMIT_URB(tx_urb, memflags);
 
 			/* Test whether we need to reset the TX pipe */
@@ -656,7 +655,6 @@ usbctlx_get_rridresult(const hfa384x_usb_rridresp_t *rridresp,
 	result->rid = le16_to_cpu(rridresp->rid);
 	result->riddata = rridresp->data;
 	result->riddata_len = ((le16_to_cpu(rridresp->frmlen) - 1) * 2);
-
 }
 
 /*----------------------------------------------------------------
@@ -2845,7 +2843,6 @@ static void hfa384x_usbctlx_reaper_task(unsigned long data)
 	}
 
 	spin_unlock_irqrestore(&hw->ctlxq.lock, flags);
-
 }
 
 /*----------------------------------------------------------------
@@ -3706,7 +3703,6 @@ static void hfa384x_usbout_callback(struct urb *urb)
 #endif
 
 	if (wlandev && wlandev->netdev) {
-
 		switch (urb->status) {
 		case 0:
 			hfa384x_usbout_tx(wlandev, usbout);
@@ -3732,8 +3728,8 @@ static void hfa384x_usbout_callback(struct urb *urb)
 				hfa384x_t *hw = wlandev->priv;
 
 				if (!test_and_set_bit
-				    (THROTTLE_TX, &hw->usb_flags)
-				    && !timer_pending(&hw->throttle)) {
+				    (THROTTLE_TX, &hw->usb_flags) &&
+				    !timer_pending(&hw->throttle)) {
 					mod_timer(&hw->throttle,
 						  jiffies + THROTTLE_JIFFIES);
 				}

commit 3f2d656481c64bad30f1f92b3834c6c2b5851916
Author: Sherif Shehab Aldin <shehabaldin.sherif@gmail.com>
Date:   Sat Apr 5 23:34:40 2014 +0200

    driver: staging: wlan-ng: Fixed Alignment to match open parenthesis
    
    Fixed Alignment to match open parenthesis in hfa384x_usb.c
    
    Signed-off-by: Sherif Shehab Aldin <shehabaldin.sherif@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/hfa384x_usb.c b/drivers/staging/wlan-ng/hfa384x_usb.c
index 22f0f1da52fa..a6684b67f8f4 100644
--- a/drivers/staging/wlan-ng/hfa384x_usb.c
+++ b/drivers/staging/wlan-ng/hfa384x_usb.c
@@ -350,14 +350,14 @@ static int submit_rx_urb(hfa384x_t *hw, gfp_t memflags)
 
 	result = -ENOLINK;
 	if (!hw->wlandev->hwremoved &&
-			!test_bit(WORK_RX_HALT, &hw->usb_flags)) {
+	    !test_bit(WORK_RX_HALT, &hw->usb_flags)) {
 		result = SUBMIT_URB(&hw->rx_urb, memflags);
 
 		/* Check whether we need to reset the RX pipe */
 		if (result == -EPIPE) {
 			netdev_warn(hw->wlandev->netdev,
-			       "%s rx pipe stalled: requesting reset\n",
-			       hw->wlandev->netdev->name);
+				    "%s rx pipe stalled: requesting reset\n",
+				    hw->wlandev->netdev->name);
 			if (!test_and_set_bit(WORK_RX_HALT, &hw->usb_flags))
 				schedule_work(&hw->usb_work);
 		}
@@ -406,8 +406,8 @@ static int submit_tx_urb(hfa384x_t *hw, struct urb *tx_urb, gfp_t memflags)
 			/* Test whether we need to reset the TX pipe */
 			if (result == -EPIPE) {
 				netdev_warn(hw->wlandev->netdev,
-				       "%s tx pipe stalled: requesting reset\n",
-				       netdev->name);
+					    "%s tx pipe stalled: requesting reset\n",
+					    netdev->name);
 				set_bit(WORK_TX_HALT, &hw->usb_flags);
 				schedule_work(&hw->usb_work);
 			} else if (result == 0) {
@@ -455,11 +455,11 @@ static void hfa384x_usb_defer(struct work_struct *data)
 		ret = usb_clear_halt(hw->usb, hw->endp_in);
 		if (ret != 0) {
 			netdev_err(hw->wlandev->netdev,
-			       "Failed to clear rx pipe for %s: err=%d\n",
-			       netdev->name, ret);
+				   "Failed to clear rx pipe for %s: err=%d\n",
+				   netdev->name, ret);
 		} else {
 			netdev_info(hw->wlandev->netdev, "%s rx pipe reset complete.\n",
-			       netdev->name);
+				    netdev->name);
 			clear_bit(WORK_RX_HALT, &hw->usb_flags);
 			set_bit(WORK_RX_RESUME, &hw->usb_flags);
 		}
@@ -472,7 +472,8 @@ static void hfa384x_usb_defer(struct work_struct *data)
 		ret = submit_rx_urb(hw, GFP_KERNEL);
 		if (ret != 0) {
 			netdev_err(hw->wlandev->netdev,
-			       "Failed to resume %s rx pipe.\n", netdev->name);
+				   "Failed to resume %s rx pipe.\n",
+				   netdev->name);
 		} else {
 			clear_bit(WORK_RX_RESUME, &hw->usb_flags);
 		}
@@ -486,11 +487,11 @@ static void hfa384x_usb_defer(struct work_struct *data)
 		ret = usb_clear_halt(hw->usb, hw->endp_out);
 		if (ret != 0) {
 			netdev_err(hw->wlandev->netdev,
-			       "Failed to clear tx pipe for %s: err=%d\n",
-			       netdev->name, ret);
+				   "Failed to clear tx pipe for %s: err=%d\n",
+				   netdev->name, ret);
 		} else {
 			netdev_info(hw->wlandev->netdev, "%s tx pipe reset complete.\n",
-			       netdev->name);
+				    netdev->name);
 			clear_bit(WORK_TX_HALT, &hw->usb_flags);
 			set_bit(WORK_TX_RESUME, &hw->usb_flags);
 
@@ -1206,7 +1207,7 @@ int hfa384x_corereset(hfa384x_t *hw, int holdtime, int settletime, int genesis)
 	result = usb_reset_device(hw->usb);
 	if (result < 0) {
 		netdev_err(hw->wlandev->netdev, "usb_reset_device() failed, result=%d.\n",
-		       result);
+			   result);
 	}
 
 	return result;
@@ -1306,8 +1307,8 @@ static int hfa384x_usbctlx_complete_sync(hfa384x_t *hw,
 			result = completor->complete(completor);
 		} else {
 			netdev_warn(hw->wlandev->netdev, "CTLX[%d] error: state(%s)\n",
-			       le16_to_cpu(ctlx->outbuf.type),
-			       ctlxstr(ctlx->state));
+				    le16_to_cpu(ctlx->outbuf.type),
+				    ctlxstr(ctlx->state));
 			result = -EIO;
 		}
 
@@ -2051,7 +2052,7 @@ int hfa384x_drvr_flashdl_write(hfa384x_t *hw, u32 daddr, void *buf, u32 len)
 		burnhi = HFA384x_ADDR_CMD_MKPAGE(burndaddr);
 
 		netdev_info(hw->wlandev->netdev, "Writing %d bytes to flash @0x%06x\n",
-		       burnlen, burndaddr);
+			    burnlen, burndaddr);
 
 		/* Set the download mode */
 		result = hfa384x_cmd_download(hw, HFA384x_PROGMODE_NV,
@@ -2090,8 +2091,8 @@ int hfa384x_drvr_flashdl_write(hfa384x_t *hw, u32 daddr, void *buf, u32 len)
 					      0, 0, 0);
 		if (result) {
 			netdev_err(hw->wlandev->netdev,
-			       "download(NVWRITE,lo=%x,hi=%x,len=%x) cmd failed, result=%d. Aborting d/l\n",
-			       burnlo, burnhi, burnlen, result);
+				   "download(NVWRITE,lo=%x,hi=%x,len=%x) cmd failed, result=%d. Aborting d/l\n",
+				   burnlo, burnhi, burnlen, result);
 			goto exit_proc;
 		}
 
@@ -2274,7 +2275,7 @@ int hfa384x_drvr_ramdl_enable(hfa384x_t *hw, u32 exeaddr)
 	for (i = 0; i < HFA384x_PORTID_MAX; i++) {
 		if (hw->port_enabled[i]) {
 			netdev_err(hw->wlandev->netdev,
-			       "Can't download with a macport enabled.\n");
+				   "Can't download with a macport enabled.\n");
 			return -EINVAL;
 		}
 	}
@@ -2445,7 +2446,8 @@ int hfa384x_drvr_readpda(hfa384x_t *hw, void *buf, unsigned int len)
 
 		if (result) {
 			netdev_warn(hw->wlandev->netdev,
-			       "Read from index %zd failed, continuing\n", i);
+				    "Read from index %zd failed, continuing\n",
+				    i);
 			continue;
 		}
 
@@ -2465,7 +2467,7 @@ int hfa384x_drvr_readpda(hfa384x_t *hw, void *buf, unsigned int len)
 			/* Test the code */
 			if (!hfa384x_isgood_pdrcode(pdrcode)) {
 				netdev_err(hw->wlandev->netdev, "pdrcode invalid=%d\n",
-				       pdrcode);
+					   pdrcode);
 				pdaok = 0;
 				break;
 			}
@@ -2481,13 +2483,13 @@ int hfa384x_drvr_readpda(hfa384x_t *hw, void *buf, unsigned int len)
 		}
 		if (pdaok) {
 			netdev_info(hw->wlandev->netdev,
-			       "PDA Read from 0x%08x in %s space.\n",
-			       pdaloc[i].cardaddr,
-			       pdaloc[i].auxctl == 0 ? "EXTDS" :
-			       pdaloc[i].auxctl == 1 ? "NV" :
-			       pdaloc[i].auxctl == 2 ? "PHY" :
-			       pdaloc[i].auxctl == 3 ? "ICSRAM" :
-			       "<bogus auxctl>");
+				    "PDA Read from 0x%08x in %s space.\n",
+				    pdaloc[i].cardaddr,
+				    pdaloc[i].auxctl == 0 ? "EXTDS" :
+				    pdaloc[i].auxctl == 1 ? "NV" :
+				    pdaloc[i].auxctl == 2 ? "PHY" :
+				    pdaloc[i].auxctl == 3 ? "ICSRAM" :
+				    "<bogus auxctl>");
 			break;
 		}
 	}
@@ -2582,7 +2584,8 @@ int hfa384x_drvr_start(hfa384x_t *hw)
 	result = submit_rx_urb(hw, GFP_KERNEL);
 	if (result != 0) {
 		netdev_err(hw->wlandev->netdev,
-		       "Fatal, failed to submit RX URB, result=%d\n", result);
+			   "Fatal, failed to submit RX URB, result=%d\n",
+			   result);
 		goto done;
 	}
 
@@ -2602,8 +2605,8 @@ int hfa384x_drvr_start(hfa384x_t *hw)
 	if (result1 != 0) {
 		if (result2 != 0) {
 			netdev_err(hw->wlandev->netdev,
-				"cmd_initialize() failed on two attempts, results %d and %d\n",
-				result1, result2);
+				   "cmd_initialize() failed on two attempts, results %d and %d\n",
+				   result1, result2);
 			usb_kill_urb(&hw->rx_urb);
 			goto done;
 		} else {
@@ -2613,9 +2616,9 @@ int hfa384x_drvr_start(hfa384x_t *hw)
 		}
 	} else if (result2 != 0) {
 		netdev_warn(hw->wlandev->netdev, "First cmd_initialize() succeeded, but second attempt failed (result=%d)\n",
-			result2);
+			    result2);
 		netdev_warn(hw->wlandev->netdev,
-		       "Most likely the card will be functional\n");
+			    "Most likely the card will be functional\n");
 		goto done;
 	}
 
@@ -3007,7 +3010,8 @@ static void unlocked_usbctlx_complete(hfa384x_t *hw, hfa384x_usbctlx_t *ctlx)
 
 	default:
 		netdev_err(hw->wlandev->netdev, "CTLX[%d] not in a terminating state(%s)\n",
-		       le16_to_cpu(ctlx->outbuf.type), ctlxstr(ctlx->state));
+			   le16_to_cpu(ctlx->outbuf.type),
+			   ctlxstr(ctlx->state));
 		break;
 	}			/* switch */
 }
@@ -3089,8 +3093,8 @@ static void hfa384x_usbctlxq_run(hfa384x_t *hw)
 			 * and schedule a reset ...
 			 */
 			netdev_warn(hw->wlandev->netdev,
-			       "%s tx pipe stalled: requesting reset\n",
-			       hw->wlandev->netdev->name);
+				    "%s tx pipe stalled: requesting reset\n",
+				    hw->wlandev->netdev->name);
 			list_move(&head->list, &hw->ctlxq.pending);
 			set_bit(WORK_TX_HALT, &hw->usb_flags);
 			schedule_work(&hw->usb_work);
@@ -3099,12 +3103,12 @@ static void hfa384x_usbctlxq_run(hfa384x_t *hw)
 
 		if (result == -ESHUTDOWN) {
 			netdev_warn(hw->wlandev->netdev, "%s urb shutdown!\n",
-			       hw->wlandev->netdev->name);
+				    hw->wlandev->netdev->name);
 			break;
 		}
 
 		netdev_err(hw->wlandev->netdev, "Failed to submit CTLX[%d]: error=%d\n",
-		       le16_to_cpu(head->outbuf.type), result);
+			   le16_to_cpu(head->outbuf.type), result);
 		unlocked_usbctlx_complete(hw, head);
 	}			/* while */
 
@@ -3171,7 +3175,7 @@ static void hfa384x_usbin_callback(struct urb *urb)
 
 	case -EPIPE:
 		netdev_warn(hw->wlandev->netdev, "%s rx pipe stalled: requesting reset\n",
-		       wlandev->netdev->name);
+			    wlandev->netdev->name);
 		if (!test_and_set_bit(WORK_RX_HALT, &hw->usb_flags))
 			schedule_work(&hw->usb_work);
 		++(wlandev->linux_stats.rx_errors);
@@ -3222,8 +3226,8 @@ static void hfa384x_usbin_callback(struct urb *urb)
 
 		if (result != 0) {
 			netdev_err(hw->wlandev->netdev,
-			       "Fatal, failed to resubmit rx_urb. error=%d\n",
-			       result);
+				   "Fatal, failed to resubmit rx_urb. error=%d\n",
+				   result);
 		}
 	}
 
@@ -3358,9 +3362,9 @@ static void hfa384x_usbin_ctlx(hfa384x_t *hw, hfa384x_usbin_t *usbin,
 		 */
 		if (ctlx->outbuf.type != intype) {
 			netdev_warn(hw->wlandev->netdev,
-			       "Expected IN[%d], received IN[%d] - ignored.\n",
-			       le16_to_cpu(ctlx->outbuf.type),
-			       le16_to_cpu(intype));
+				    "Expected IN[%d], received IN[%d] - ignored.\n",
+				    le16_to_cpu(ctlx->outbuf.type),
+				    le16_to_cpu(intype));
 			goto unlock;
 		}
 
@@ -3394,9 +3398,9 @@ static void hfa384x_usbin_ctlx(hfa384x_t *hw, hfa384x_usbin_t *usbin,
 			 * Throw this CTLX away ...
 			 */
 			netdev_err(hw->wlandev->netdev,
-			       "Matched IN URB, CTLX[%d] in invalid state(%s). Discarded.\n",
-			       le16_to_cpu(ctlx->outbuf.type),
-			       ctlxstr(ctlx->state));
+				   "Matched IN URB, CTLX[%d] in invalid state(%s). Discarded.\n",
+				   le16_to_cpu(ctlx->outbuf.type),
+				   ctlxstr(ctlx->state));
 			if (unlocked_usbctlx_cancel_async(hw, ctlx) == 0)
 				run_queue = 1;
 			break;
@@ -3531,7 +3535,8 @@ static void hfa384x_usbin_rx(wlandevice_t *wlandev, struct sk_buff *skb)
 
 	default:
 		netdev_warn(hw->wlandev->netdev, "Received frame on unsupported port=%d\n",
-		       HFA384x_RXSTATUS_MACPORT_GET(usbin->rxfrm.desc.status));
+			    HFA384x_RXSTATUS_MACPORT_GET(
+				    usbin->rxfrm.desc.status));
 		goto done;
 		break;
 	}
@@ -3593,8 +3598,8 @@ static void hfa384x_int_rxmonitor(wlandevice_t *wlandev,
 	skb = dev_alloc_skb(skblen);
 	if (skb == NULL) {
 		netdev_err(hw->wlandev->netdev,
-		       "alloc_skb failed trying to allocate %d bytes\n",
-		       skblen);
+			   "alloc_skb failed trying to allocate %d bytes\n",
+			   skblen);
 		return;
 	}
 
@@ -3711,8 +3716,8 @@ static void hfa384x_usbout_callback(struct urb *urb)
 			{
 				hfa384x_t *hw = wlandev->priv;
 				netdev_warn(hw->wlandev->netdev,
-				       "%s tx pipe stalled: requesting reset\n",
-				       wlandev->netdev->name);
+					    "%s tx pipe stalled: requesting reset\n",
+					    wlandev->netdev->name);
 				if (!test_and_set_bit
 				    (WORK_TX_HALT, &hw->usb_flags))
 					schedule_work(&hw->usb_work);
@@ -3744,7 +3749,7 @@ static void hfa384x_usbout_callback(struct urb *urb)
 
 		default:
 			netdev_info(wlandev->netdev, "unknown urb->status=%d\n",
-			       urb->status);
+				    urb->status);
 			++(wlandev->linux_stats.tx_errors);
 			break;
 		}		/* switch */
@@ -3838,9 +3843,9 @@ static void hfa384x_ctlxout_callback(struct urb *urb)
 		default:
 			/* This is NOT a valid CTLX "success" state! */
 			netdev_err(hw->wlandev->netdev,
-				"Illegal CTLX[%d] success state(%s, %d) in OUT URB\n",
-				le16_to_cpu(ctlx->outbuf.type),
-				ctlxstr(ctlx->state), urb->status);
+				   "Illegal CTLX[%d] success state(%s, %d) in OUT URB\n",
+				   le16_to_cpu(ctlx->outbuf.type),
+				   ctlxstr(ctlx->state), urb->status);
 			break;
 		}		/* switch */
 	} else {
@@ -3848,8 +3853,8 @@ static void hfa384x_ctlxout_callback(struct urb *urb)
 		if ((urb->status == -EPIPE) &&
 		    !test_and_set_bit(WORK_TX_HALT, &hw->usb_flags)) {
 			netdev_warn(hw->wlandev->netdev,
-			       "%s tx pipe stalled: requesting reset\n",
-			       hw->wlandev->netdev->name);
+				    "%s tx pipe stalled: requesting reset\n",
+				    hw->wlandev->netdev->name);
 			schedule_work(&hw->usb_work);
 		}
 

commit 83f91687b0922511eceddb9831e9f86c08bb3873
Author: Sherif Shehab Aldin <shehabaldin.sherif@gmail.com>
Date:   Sat Apr 5 23:34:12 2014 +0200

    driver: staging: wlan-ng: Removed Unnecessary space after function pointer name
    
    Removed Unnecessary space after function pointer name
    
    Signed-off-by: Sherif Shehab Aldin <shehabaldin.sherif@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/hfa384x_usb.c b/drivers/staging/wlan-ng/hfa384x_usb.c
index 74db234977a8..22f0f1da52fa 100644
--- a/drivers/staging/wlan-ng/hfa384x_usb.c
+++ b/drivers/staging/wlan-ng/hfa384x_usb.c
@@ -203,7 +203,7 @@ static int hfa384x_usbctlx_submit(hfa384x_t *hw, hfa384x_usbctlx_t *ctlx);
 static void unlocked_usbctlx_complete(hfa384x_t *hw, hfa384x_usbctlx_t *ctlx);
 
 struct usbctlx_completor {
-	int (*complete) (struct usbctlx_completor *);
+	int (*complete)(struct usbctlx_completor *);
 };
 
 static int

commit d6ae4a9995fa19ecde23f425a027f445074ba1ec
Author: Sherif Shehab Aldin <shehabaldin.sherif@gmail.com>
Date:   Sat Apr 5 23:34:01 2014 +0200

    driver: staging: wlan-ng: Setting character pointers as const
    
    changed declaration of ctlx_str to:
    static const char * const ctlx_str[]
    
    Signed-off-by: Sherif Shehab Aldin <shehabaldin.sherif@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/hfa384x_usb.c b/drivers/staging/wlan-ng/hfa384x_usb.c
index 01284ea01cf9..74db234977a8 100644
--- a/drivers/staging/wlan-ng/hfa384x_usb.c
+++ b/drivers/staging/wlan-ng/hfa384x_usb.c
@@ -272,7 +272,7 @@ static int hfa384x_isgood_pdrcode(u16 pdrcode);
 
 static inline const char *ctlxstr(CTLX_STATE s)
 {
-	static const char *ctlx_str[] = {
+	static const char * const ctlx_str[] = {
 		"Initial state",
 		"Complete",
 		"Request failed",

commit baa8a6c008329de5dd6909658c7f892340e4b5f0
Author: Sherif Shehab Aldin <shehabaldin.sherif@gmail.com>
Date:   Sat Apr 5 23:33:53 2014 +0200

    driver: staging: wlan-ng: switched to pr_warn
    
    changed printk(KERN_WARNING .. to pr_warn
    
    Signed-off-by: Sherif Shehab Aldin <shehabaldin.sherif@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/hfa384x_usb.c b/drivers/staging/wlan-ng/hfa384x_usb.c
index 943de9c18634..01284ea01cf9 100644
--- a/drivers/staging/wlan-ng/hfa384x_usb.c
+++ b/drivers/staging/wlan-ng/hfa384x_usb.c
@@ -714,10 +714,9 @@ static int usbctlx_rrid_completor_fn(struct usbctlx_completor *head)
 
 	/* Validate the length, note body len calculation in bytes */
 	if (rridresult.riddata_len != complete->riddatalen) {
-		printk(KERN_WARNING
-		       "RID len mismatch, rid=0x%04x hlen=%d fwlen=%d\n",
-		       rridresult.rid,
-		       complete->riddatalen, rridresult.riddata_len);
+		pr_warn("RID len mismatch, rid=0x%04x hlen=%d fwlen=%d\n",
+			rridresult.rid,
+			complete->riddatalen, rridresult.riddata_len);
 		return -ENODATA;
 	}
 

commit a03742ac96fceac7b103aff7b9714605a21b8a3e
Author: Sherif Shehab Aldin <shehabaldin.sherif@gmail.com>
Date:   Sat Apr 5 23:33:45 2014 +0200

    driver: staging: wlan-ng: Removed unnecessary typedefs from hfa384x_usb.c
    
    Removed unnecessary typedefs from hfa384x_usb.c
    
    Signed-off-by: Sherif Shehab Aldin <shehabaldin.sherif@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/hfa384x_usb.c b/drivers/staging/wlan-ng/hfa384x_usb.c
index 646c29e7f4fd..943de9c18634 100644
--- a/drivers/staging/wlan-ng/hfa384x_usb.c
+++ b/drivers/staging/wlan-ng/hfa384x_usb.c
@@ -744,14 +744,12 @@ static inline struct usbctlx_completor *init_rrid_completor(
 * Completor object:
 * Interprets the results of a synchronous RID-write
 ----------------------------------------------------------------*/
-typedef struct usbctlx_cmd_completor usbctlx_wrid_completor_t;
 #define init_wrid_completor  init_cmd_completor
 
 /*----------------------------------------------------------------
 * Completor object:
 * Interprets the results of a synchronous memory-write
 ----------------------------------------------------------------*/
-typedef struct usbctlx_cmd_completor usbctlx_wmem_completor_t;
 #define init_wmem_completor  init_cmd_completor
 
 /*----------------------------------------------------------------
@@ -765,11 +763,11 @@ struct usbctlx_rmem_completor {
 	void *data;
 	unsigned int len;
 };
-typedef struct usbctlx_rmem_completor usbctlx_rmem_completor_t;
 
 static int usbctlx_rmem_completor_fn(struct usbctlx_completor *head)
 {
-	usbctlx_rmem_completor_t *complete = (usbctlx_rmem_completor_t *) head;
+	struct usbctlx_rmem_completor *complete =
+		(struct usbctlx_rmem_completor *)head;
 
 	pr_debug("rmemresp:len=%d\n", complete->rmemresp->frmlen);
 	memcpy(complete->data, complete->rmemresp->data, complete->len);
@@ -777,7 +775,7 @@ static int usbctlx_rmem_completor_fn(struct usbctlx_completor *head)
 }
 
 static inline struct usbctlx_completor *init_rmem_completor(
-						usbctlx_rmem_completor_t
+						struct usbctlx_rmem_completor
 							*completor,
 						hfa384x_usb_rmemresp_t
 							*rmemresp,
@@ -1562,7 +1560,7 @@ hfa384x_dowrid(hfa384x_t *hw,
 	if (result != 0) {
 		kfree(ctlx);
 	} else if (mode == DOWAIT) {
-		usbctlx_wrid_completor_t completor;
+		struct usbctlx_cmd_completor completor;
 		hfa384x_cmdresult_t wridresult;
 
 		result = hfa384x_usbctlx_complete_sync(hw,
@@ -1654,7 +1652,7 @@ hfa384x_dormem(hfa384x_t *hw,
 	if (result != 0) {
 		kfree(ctlx);
 	} else if (mode == DOWAIT) {
-		usbctlx_rmem_completor_t completor;
+		struct usbctlx_rmem_completor completor;
 
 		result =
 		    hfa384x_usbctlx_complete_sync(hw, ctlx,
@@ -1744,7 +1742,7 @@ hfa384x_dowmem(hfa384x_t *hw,
 	if (result != 0) {
 		kfree(ctlx);
 	} else if (mode == DOWAIT) {
-		usbctlx_wmem_completor_t completor;
+		struct usbctlx_cmd_completor completor;
 		hfa384x_cmdresult_t wmemresult;
 
 		result = hfa384x_usbctlx_complete_sync(hw,

commit a21201369568a4e5bd23fb5cb9a966a1008637a6
Author: Sherif Shehab Aldin <shehabaldin.sherif@gmail.com>
Date:   Sat Apr 5 23:33:16 2014 +0200

    driver: staging: wlan-ng: Fixed Breaking long lines and strings style rule
    
    Fixed coding style rule "Breaking long lines and strings" for hfa384x_usb.c
    
    Signed-off-by: Sherif Shehab Aldin <shehabaldin.sherif@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/hfa384x_usb.c b/drivers/staging/wlan-ng/hfa384x_usb.c
index 5b8b094c8726..646c29e7f4fd 100644
--- a/drivers/staging/wlan-ng/hfa384x_usb.c
+++ b/drivers/staging/wlan-ng/hfa384x_usb.c
@@ -642,8 +642,7 @@ usbctlx_get_status(const hfa384x_usb_cmdresp_t *cmdresp,
 	result->resp1 = le16_to_cpu(cmdresp->resp1);
 	result->resp2 = le16_to_cpu(cmdresp->resp2);
 
-	pr_debug("cmdresult:status=0x%04x "
-		 "resp0=0x%04x resp1=0x%04x resp2=0x%04x\n",
+	pr_debug("cmdresult:status=0x%04x resp0=0x%04x resp1=0x%04x resp2=0x%04x\n",
 		 result->status, result->resp0, result->resp1, result->resp2);
 
 	return result->status & HFA384x_STATUS_RESULT;
@@ -991,9 +990,7 @@ int hfa384x_cmd_initialize(hfa384x_t *hw)
 
 	result = hfa384x_docmd_wait(hw, &cmd);
 
-	pr_debug("cmdresp.init: "
-		 "status=0x%04x, resp0=0x%04x, "
-		 "resp1=0x%04x, resp2=0x%04x\n",
+	pr_debug("cmdresp.init: status=0x%04x, resp0=0x%04x, resp1=0x%04x, resp2=0x%04x\n",
 		 cmd.result.status,
 		 cmd.result.resp0, cmd.result.resp1, cmd.result.resp2);
 	if (result == 0) {
@@ -1381,8 +1378,7 @@ hfa384x_docmd(hfa384x_t *hw,
 
 	ctlx->outbufsize = sizeof(ctlx->outbuf.cmdreq);
 
-	pr_debug("cmdreq: cmd=0x%04x "
-		 "parm0=0x%04x parm1=0x%04x parm2=0x%04x\n",
+	pr_debug("cmdreq: cmd=0x%04x parm0=0x%04x parm1=0x%04x parm2=0x%04x\n",
 		 cmd->cmd, cmd->parm0, cmd->parm1, cmd->parm2);
 
 	ctlx->reapable = mode;
@@ -2018,7 +2014,8 @@ int hfa384x_drvr_flashdl_write(hfa384x_t *hw, u32 daddr, void *buf, u32 len)
 	if (hw->dlstate != HFA384x_DLSTATE_FLASHENABLED)
 		return -EINVAL;
 
-	netdev_info(hw->wlandev->netdev, "Download %d bytes to flash @0x%06x\n", len, daddr);
+	netdev_info(hw->wlandev->netdev,
+		    "Download %d bytes to flash @0x%06x\n", len, daddr);
 
 	/* Convert to flat address for arithmetic */
 	/* NOTE: dlbuffer RID stores the address in AUX format */
@@ -2028,8 +2025,9 @@ int hfa384x_drvr_flashdl_write(hfa384x_t *hw, u32 daddr, void *buf, u32 len)
 		 hw->bufinfo.page, hw->bufinfo.offset, dlbufaddr);
 
 #if 0
-	netdev_warn(hw->wlandev->netdev, "dlbuf@0x%06lx len=%d to=%d\n", dlbufaddr,
-	       hw->bufinfo.len, hw->dltimeout);
+	netdev_warn(hw->wlandev->netdev,
+		    "dlbuf@0x%06lx len=%d to=%d\n", dlbufaddr,
+		    hw->bufinfo.len, hw->dltimeout);
 #endif
 	/* Calculations to determine how many fills of the dlbuffer to do
 	 * and how many USB wmemreq's to do for each fill.  At this point
@@ -2062,9 +2060,9 @@ int hfa384x_drvr_flashdl_write(hfa384x_t *hw, u32 daddr, void *buf, u32 len)
 		result = hfa384x_cmd_download(hw, HFA384x_PROGMODE_NV,
 					      burnlo, burnhi, burnlen);
 		if (result) {
-			netdev_err(hw->wlandev->netdev, "download(NV,lo=%x,hi=%x,len=%x) "
-			       "cmd failed, result=%d. Aborting d/l\n",
-			       burnlo, burnhi, burnlen, result);
+			netdev_err(hw->wlandev->netdev,
+				   "download(NV,lo=%x,hi=%x,len=%x) cmd failed, result=%d. Aborting d/l\n",
+				   burnlo, burnhi, burnlen, result);
 			goto exit_proc;
 		}
 
@@ -2095,8 +2093,7 @@ int hfa384x_drvr_flashdl_write(hfa384x_t *hw, u32 daddr, void *buf, u32 len)
 					      0, 0, 0);
 		if (result) {
 			netdev_err(hw->wlandev->netdev,
-			       "download(NVWRITE,lo=%x,hi=%x,len=%x) "
-			       "cmd failed, result=%d. Aborting d/l\n",
+			       "download(NVWRITE,lo=%x,hi=%x,len=%x) cmd failed, result=%d. Aborting d/l\n",
 			       burnlo, burnhi, burnlen, result);
 			goto exit_proc;
 		}
@@ -2352,7 +2349,8 @@ int hfa384x_drvr_ramdl_write(hfa384x_t *hw, u32 daddr, void *buf, u32 len)
 	if (hw->dlstate != HFA384x_DLSTATE_RAMENABLED)
 		return -EINVAL;
 
-	netdev_info(hw->wlandev->netdev, "Writing %d bytes to ram @0x%06x\n", len, daddr);
+	netdev_info(hw->wlandev->netdev, "Writing %d bytes to ram @0x%06x\n",
+		    len, daddr);
 
 	/* How many dowmem calls?  */
 	nwrites = len / HFA384x_USB_RWMEM_MAXLEN;
@@ -2462,7 +2460,8 @@ int hfa384x_drvr_readpda(hfa384x_t *hw, void *buf, unsigned int len)
 			pdrcode = le16_to_cpu(pda[currpdr + 1]);
 			/* Test the record length */
 			if (pdrlen > HFA384x_PDR_LEN_MAX || pdrlen == 0) {
-				netdev_err(hw->wlandev->netdev, "pdrlen invalid=%d\n", pdrlen);
+				netdev_err(hw->wlandev->netdev,
+					   "pdrlen invalid=%d\n", pdrlen);
 				pdaok = 0;
 				break;
 			}
@@ -2784,7 +2783,8 @@ int hfa384x_drvr_txframe(hfa384x_t *hw, struct sk_buff *skb,
 	result = 1;
 	ret = submit_tx_urb(hw, &hw->tx_urb, GFP_ATOMIC);
 	if (ret != 0) {
-		netdev_err(hw->wlandev->netdev, "submit_tx_urb() failed, error=%d\n", ret);
+		netdev_err(hw->wlandev->netdev,
+			   "submit_tx_urb() failed, error=%d\n", ret);
 		result = 3;
 	}
 
@@ -3397,8 +3397,7 @@ static void hfa384x_usbin_ctlx(hfa384x_t *hw, hfa384x_usbin_t *usbin,
 			 * Throw this CTLX away ...
 			 */
 			netdev_err(hw->wlandev->netdev,
-			       "Matched IN URB, CTLX[%d] in invalid state(%s)."
-			       " Discarded.\n",
+			       "Matched IN URB, CTLX[%d] in invalid state(%s). Discarded.\n",
 			       le16_to_cpu(ctlx->outbuf.type),
 			       ctlxstr(ctlx->state));
 			if (unlocked_usbctlx_cancel_async(hw, ctlx) == 0)
@@ -4139,13 +4138,13 @@ static int hfa384x_isgood_pdrcode(u16 pdrcode)
 	default:
 		if (pdrcode < 0x1000) {
 			/* code is OK, but we don't know exactly what it is */
-			pr_debug("Encountered unknown PDR#=0x%04x, "
-				 "assuming it's ok.\n", pdrcode);
+			pr_debug("Encountered unknown PDR#=0x%04x, assuming it's ok.\n",
+				 pdrcode);
 			return 1;
 		} else {
 			/* bad code */
-			pr_debug("Encountered unknown PDR#=0x%04x, "
-				 "(>=0x1000), assuming it's bad.\n", pdrcode);
+			pr_debug("Encountered unknown PDR#=0x%04x, (>=0x1000), assuming it's bad.\n",
+				 pdrcode);
 			return 0;
 		}
 		break;

commit 263b8bb9106a574f066d7a949aaee29a21c6b99f
Author: Avinash Kumar <avi.kp.137@gmail.com>
Date:   Fri Sep 6 22:21:49 2013 +0530

    staging: wlan-ng: hfa384x_usb.c: replaced printk() debugs with netdev_warn()/netdev_err()
    
    replaced the printk debug lines with respective netdev_warn()/netdev_err()
    
    Signed-off-by: Avinash kumar <avi.kp.137@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/hfa384x_usb.c b/drivers/staging/wlan-ng/hfa384x_usb.c
index c1a8cb625154..5b8b094c8726 100644
--- a/drivers/staging/wlan-ng/hfa384x_usb.c
+++ b/drivers/staging/wlan-ng/hfa384x_usb.c
@@ -355,7 +355,7 @@ static int submit_rx_urb(hfa384x_t *hw, gfp_t memflags)
 
 		/* Check whether we need to reset the RX pipe */
 		if (result == -EPIPE) {
-			printk(KERN_WARNING
+			netdev_warn(hw->wlandev->netdev,
 			       "%s rx pipe stalled: requesting reset\n",
 			       hw->wlandev->netdev->name);
 			if (!test_and_set_bit(WORK_RX_HALT, &hw->usb_flags))
@@ -405,7 +405,7 @@ static int submit_tx_urb(hfa384x_t *hw, struct urb *tx_urb, gfp_t memflags)
 
 			/* Test whether we need to reset the TX pipe */
 			if (result == -EPIPE) {
-				printk(KERN_WARNING
+				netdev_warn(hw->wlandev->netdev,
 				       "%s tx pipe stalled: requesting reset\n",
 				       netdev->name);
 				set_bit(WORK_TX_HALT, &hw->usb_flags);
@@ -454,11 +454,11 @@ static void hfa384x_usb_defer(struct work_struct *data)
 
 		ret = usb_clear_halt(hw->usb, hw->endp_in);
 		if (ret != 0) {
-			printk(KERN_ERR
+			netdev_err(hw->wlandev->netdev,
 			       "Failed to clear rx pipe for %s: err=%d\n",
 			       netdev->name, ret);
 		} else {
-			printk(KERN_INFO "%s rx pipe reset complete.\n",
+			netdev_info(hw->wlandev->netdev, "%s rx pipe reset complete.\n",
 			       netdev->name);
 			clear_bit(WORK_RX_HALT, &hw->usb_flags);
 			set_bit(WORK_RX_RESUME, &hw->usb_flags);
@@ -471,7 +471,7 @@ static void hfa384x_usb_defer(struct work_struct *data)
 
 		ret = submit_rx_urb(hw, GFP_KERNEL);
 		if (ret != 0) {
-			printk(KERN_ERR
+			netdev_err(hw->wlandev->netdev,
 			       "Failed to resume %s rx pipe.\n", netdev->name);
 		} else {
 			clear_bit(WORK_RX_RESUME, &hw->usb_flags);
@@ -485,11 +485,11 @@ static void hfa384x_usb_defer(struct work_struct *data)
 		usb_kill_urb(&hw->tx_urb);
 		ret = usb_clear_halt(hw->usb, hw->endp_out);
 		if (ret != 0) {
-			printk(KERN_ERR
+			netdev_err(hw->wlandev->netdev,
 			       "Failed to clear tx pipe for %s: err=%d\n",
 			       netdev->name, ret);
 		} else {
-			printk(KERN_INFO "%s tx pipe reset complete.\n",
+			netdev_info(hw->wlandev->netdev, "%s tx pipe reset complete.\n",
 			       netdev->name);
 			clear_bit(WORK_TX_HALT, &hw->usb_flags);
 			set_bit(WORK_TX_RESUME, &hw->usb_flags);
@@ -1211,7 +1211,7 @@ int hfa384x_corereset(hfa384x_t *hw, int holdtime, int settletime, int genesis)
 
 	result = usb_reset_device(hw->usb);
 	if (result < 0) {
-		printk(KERN_ERR "usb_reset_device() failed, result=%d.\n",
+		netdev_err(hw->wlandev->netdev, "usb_reset_device() failed, result=%d.\n",
 		       result);
 	}
 
@@ -1311,7 +1311,7 @@ static int hfa384x_usbctlx_complete_sync(hfa384x_t *hw,
 		if (ctlx->state == CTLX_COMPLETE) {
 			result = completor->complete(completor);
 		} else {
-			printk(KERN_WARNING "CTLX[%d] error: state(%s)\n",
+			netdev_warn(hw->wlandev->netdev, "CTLX[%d] error: state(%s)\n",
 			       le16_to_cpu(ctlx->outbuf.type),
 			       ctlxstr(ctlx->state));
 			result = -EIO;
@@ -2018,7 +2018,7 @@ int hfa384x_drvr_flashdl_write(hfa384x_t *hw, u32 daddr, void *buf, u32 len)
 	if (hw->dlstate != HFA384x_DLSTATE_FLASHENABLED)
 		return -EINVAL;
 
-	printk(KERN_INFO "Download %d bytes to flash @0x%06x\n", len, daddr);
+	netdev_info(hw->wlandev->netdev, "Download %d bytes to flash @0x%06x\n", len, daddr);
 
 	/* Convert to flat address for arithmetic */
 	/* NOTE: dlbuffer RID stores the address in AUX format */
@@ -2028,7 +2028,7 @@ int hfa384x_drvr_flashdl_write(hfa384x_t *hw, u32 daddr, void *buf, u32 len)
 		 hw->bufinfo.page, hw->bufinfo.offset, dlbufaddr);
 
 #if 0
-	printk(KERN_WARNING "dlbuf@0x%06lx len=%d to=%d\n", dlbufaddr,
+	netdev_warn(hw->wlandev->netdev, "dlbuf@0x%06lx len=%d to=%d\n", dlbufaddr,
 	       hw->bufinfo.len, hw->dltimeout);
 #endif
 	/* Calculations to determine how many fills of the dlbuffer to do
@@ -2055,14 +2055,14 @@ int hfa384x_drvr_flashdl_write(hfa384x_t *hw, u32 daddr, void *buf, u32 len)
 		burnlo = HFA384x_ADDR_CMD_MKOFF(burndaddr);
 		burnhi = HFA384x_ADDR_CMD_MKPAGE(burndaddr);
 
-		printk(KERN_INFO "Writing %d bytes to flash @0x%06x\n",
+		netdev_info(hw->wlandev->netdev, "Writing %d bytes to flash @0x%06x\n",
 		       burnlen, burndaddr);
 
 		/* Set the download mode */
 		result = hfa384x_cmd_download(hw, HFA384x_PROGMODE_NV,
 					      burnlo, burnhi, burnlen);
 		if (result) {
-			printk(KERN_ERR "download(NV,lo=%x,hi=%x,len=%x) "
+			netdev_err(hw->wlandev->netdev, "download(NV,lo=%x,hi=%x,len=%x) "
 			       "cmd failed, result=%d. Aborting d/l\n",
 			       burnlo, burnhi, burnlen, result);
 			goto exit_proc;
@@ -2094,7 +2094,7 @@ int hfa384x_drvr_flashdl_write(hfa384x_t *hw, u32 daddr, void *buf, u32 len)
 					      HFA384x_PROGMODE_NVWRITE,
 					      0, 0, 0);
 		if (result) {
-			printk(KERN_ERR
+			netdev_err(hw->wlandev->netdev,
 			       "download(NVWRITE,lo=%x,hi=%x,len=%x) "
 			       "cmd failed, result=%d. Aborting d/l\n",
 			       burnlo, burnhi, burnlen, result);
@@ -2279,7 +2279,7 @@ int hfa384x_drvr_ramdl_enable(hfa384x_t *hw, u32 exeaddr)
 	/* Check that a port isn't active */
 	for (i = 0; i < HFA384x_PORTID_MAX; i++) {
 		if (hw->port_enabled[i]) {
-			printk(KERN_ERR
+			netdev_err(hw->wlandev->netdev,
 			       "Can't download with a macport enabled.\n");
 			return -EINVAL;
 		}
@@ -2287,7 +2287,7 @@ int hfa384x_drvr_ramdl_enable(hfa384x_t *hw, u32 exeaddr)
 
 	/* Check that we're not already in a download state */
 	if (hw->dlstate != HFA384x_DLSTATE_DISABLED) {
-		printk(KERN_ERR "Download state not disabled.\n");
+		netdev_err(hw->wlandev->netdev, "Download state not disabled.\n");
 		return -EINVAL;
 	}
 
@@ -2352,7 +2352,7 @@ int hfa384x_drvr_ramdl_write(hfa384x_t *hw, u32 daddr, void *buf, u32 len)
 	if (hw->dlstate != HFA384x_DLSTATE_RAMENABLED)
 		return -EINVAL;
 
-	printk(KERN_INFO "Writing %d bytes to ram @0x%06x\n", len, daddr);
+	netdev_info(hw->wlandev->netdev, "Writing %d bytes to ram @0x%06x\n", len, daddr);
 
 	/* How many dowmem calls?  */
 	nwrites = len / HFA384x_USB_RWMEM_MAXLEN;
@@ -2449,7 +2449,7 @@ int hfa384x_drvr_readpda(hfa384x_t *hw, void *buf, unsigned int len)
 						len);
 
 		if (result) {
-			printk(KERN_WARNING
+			netdev_warn(hw->wlandev->netdev,
 			       "Read from index %zd failed, continuing\n", i);
 			continue;
 		}
@@ -2462,13 +2462,13 @@ int hfa384x_drvr_readpda(hfa384x_t *hw, void *buf, unsigned int len)
 			pdrcode = le16_to_cpu(pda[currpdr + 1]);
 			/* Test the record length */
 			if (pdrlen > HFA384x_PDR_LEN_MAX || pdrlen == 0) {
-				printk(KERN_ERR "pdrlen invalid=%d\n", pdrlen);
+				netdev_err(hw->wlandev->netdev, "pdrlen invalid=%d\n", pdrlen);
 				pdaok = 0;
 				break;
 			}
 			/* Test the code */
 			if (!hfa384x_isgood_pdrcode(pdrcode)) {
-				printk(KERN_ERR "pdrcode invalid=%d\n",
+				netdev_err(hw->wlandev->netdev, "pdrcode invalid=%d\n",
 				       pdrcode);
 				pdaok = 0;
 				break;
@@ -2484,7 +2484,7 @@ int hfa384x_drvr_readpda(hfa384x_t *hw, void *buf, unsigned int len)
 			}
 		}
 		if (pdaok) {
-			printk(KERN_INFO
+			netdev_info(hw->wlandev->netdev,
 			       "PDA Read from 0x%08x in %s space.\n",
 			       pdaloc[i].cardaddr,
 			       pdaloc[i].auxctl == 0 ? "EXTDS" :
@@ -2564,20 +2564,20 @@ int hfa384x_drvr_start(hfa384x_t *hw)
 	result =
 	    usb_get_status(hw->usb, USB_RECIP_ENDPOINT, hw->endp_in, &status);
 	if (result < 0) {
-		printk(KERN_ERR "Cannot get bulk in endpoint status.\n");
+		netdev_err(hw->wlandev->netdev, "Cannot get bulk in endpoint status.\n");
 		goto done;
 	}
 	if ((status == 1) && usb_clear_halt(hw->usb, hw->endp_in))
-		printk(KERN_ERR "Failed to reset bulk in endpoint.\n");
+		netdev_err(hw->wlandev->netdev, "Failed to reset bulk in endpoint.\n");
 
 	result =
 	    usb_get_status(hw->usb, USB_RECIP_ENDPOINT, hw->endp_out, &status);
 	if (result < 0) {
-		printk(KERN_ERR "Cannot get bulk out endpoint status.\n");
+		netdev_err(hw->wlandev->netdev, "Cannot get bulk out endpoint status.\n");
 		goto done;
 	}
 	if ((status == 1) && usb_clear_halt(hw->usb, hw->endp_out))
-		printk(KERN_ERR "Failed to reset bulk out endpoint.\n");
+		netdev_err(hw->wlandev->netdev, "Failed to reset bulk out endpoint.\n");
 
 	/* Synchronous unlink, in case we're trying to restart the driver */
 	usb_kill_urb(&hw->rx_urb);
@@ -2585,7 +2585,7 @@ int hfa384x_drvr_start(hfa384x_t *hw)
 	/* Post the IN urb */
 	result = submit_rx_urb(hw, GFP_KERNEL);
 	if (result != 0) {
-		printk(KERN_ERR
+		netdev_err(hw->wlandev->netdev,
 		       "Fatal, failed to submit RX URB, result=%d\n", result);
 		goto done;
 	}
@@ -2605,7 +2605,7 @@ int hfa384x_drvr_start(hfa384x_t *hw)
 	result = result2 = hfa384x_cmd_initialize(hw);
 	if (result1 != 0) {
 		if (result2 != 0) {
-			printk(KERN_ERR
+			netdev_err(hw->wlandev->netdev,
 				"cmd_initialize() failed on two attempts, results %d and %d\n",
 				result1, result2);
 			usb_kill_urb(&hw->rx_urb);
@@ -2616,9 +2616,9 @@ int hfa384x_drvr_start(hfa384x_t *hw)
 			pr_debug("but second attempt succeeded. All should be ok\n");
 		}
 	} else if (result2 != 0) {
-		printk(KERN_WARNING "First cmd_initialize() succeeded, but second attempt failed (result=%d)\n",
+		netdev_warn(hw->wlandev->netdev, "First cmd_initialize() succeeded, but second attempt failed (result=%d)\n",
 			result2);
-		printk(KERN_WARNING
+		netdev_warn(hw->wlandev->netdev,
 		       "Most likely the card will be functional\n");
 		goto done;
 	}
@@ -2709,7 +2709,7 @@ int hfa384x_drvr_txframe(hfa384x_t *hw, struct sk_buff *skb,
 	char *ptr;
 
 	if (hw->tx_urb.status == -EINPROGRESS) {
-		printk(KERN_WARNING "TX URB already in use\n");
+		netdev_warn(hw->wlandev->netdev, "TX URB already in use\n");
 		result = 3;
 		goto exit;
 	}
@@ -2784,7 +2784,7 @@ int hfa384x_drvr_txframe(hfa384x_t *hw, struct sk_buff *skb,
 	result = 1;
 	ret = submit_tx_urb(hw, &hw->tx_urb, GFP_ATOMIC);
 	if (ret != 0) {
-		printk(KERN_ERR "submit_tx_urb() failed, error=%d\n", ret);
+		netdev_err(hw->wlandev->netdev, "submit_tx_urb() failed, error=%d\n", ret);
 		result = 3;
 	}
 
@@ -3009,7 +3009,7 @@ static void unlocked_usbctlx_complete(hfa384x_t *hw, hfa384x_usbctlx_t *ctlx)
 		break;
 
 	default:
-		printk(KERN_ERR "CTLX[%d] not in a terminating state(%s)\n",
+		netdev_err(hw->wlandev->netdev, "CTLX[%d] not in a terminating state(%s)\n",
 		       le16_to_cpu(ctlx->outbuf.type), ctlxstr(ctlx->state));
 		break;
 	}			/* switch */
@@ -3091,7 +3091,7 @@ static void hfa384x_usbctlxq_run(hfa384x_t *hw)
 			 * this CTLX back in the "pending" queue
 			 * and schedule a reset ...
 			 */
-			printk(KERN_WARNING
+			netdev_warn(hw->wlandev->netdev,
 			       "%s tx pipe stalled: requesting reset\n",
 			       hw->wlandev->netdev->name);
 			list_move(&head->list, &hw->ctlxq.pending);
@@ -3101,12 +3101,12 @@ static void hfa384x_usbctlxq_run(hfa384x_t *hw)
 		}
 
 		if (result == -ESHUTDOWN) {
-			printk(KERN_WARNING "%s urb shutdown!\n",
+			netdev_warn(hw->wlandev->netdev, "%s urb shutdown!\n",
 			       hw->wlandev->netdev->name);
 			break;
 		}
 
-		printk(KERN_ERR "Failed to submit CTLX[%d]: error=%d\n",
+		netdev_err(hw->wlandev->netdev, "Failed to submit CTLX[%d]: error=%d\n",
 		       le16_to_cpu(head->outbuf.type), result);
 		unlocked_usbctlx_complete(hw, head);
 	}			/* while */
@@ -3173,7 +3173,7 @@ static void hfa384x_usbin_callback(struct urb *urb)
 		break;
 
 	case -EPIPE:
-		printk(KERN_WARNING "%s rx pipe stalled: requesting reset\n",
+		netdev_warn(hw->wlandev->netdev, "%s rx pipe stalled: requesting reset\n",
 		       wlandev->netdev->name);
 		if (!test_and_set_bit(WORK_RX_HALT, &hw->usb_flags))
 			schedule_work(&hw->usb_work);
@@ -3224,7 +3224,7 @@ static void hfa384x_usbin_callback(struct urb *urb)
 		result = submit_rx_urb(hw, GFP_ATOMIC);
 
 		if (result != 0) {
-			printk(KERN_ERR
+			netdev_err(hw->wlandev->netdev,
 			       "Fatal, failed to resubmit rx_urb. error=%d\n",
 			       result);
 		}
@@ -3360,7 +3360,7 @@ static void hfa384x_usbin_ctlx(hfa384x_t *hw, hfa384x_usbin_t *usbin,
 		 * Check that our message is what we're expecting ...
 		 */
 		if (ctlx->outbuf.type != intype) {
-			printk(KERN_WARNING
+			netdev_warn(hw->wlandev->netdev,
 			       "Expected IN[%d], received IN[%d] - ignored.\n",
 			       le16_to_cpu(ctlx->outbuf.type),
 			       le16_to_cpu(intype));
@@ -3396,7 +3396,7 @@ static void hfa384x_usbin_ctlx(hfa384x_t *hw, hfa384x_usbin_t *usbin,
 			/*
 			 * Throw this CTLX away ...
 			 */
-			printk(KERN_ERR
+			netdev_err(hw->wlandev->netdev,
 			       "Matched IN URB, CTLX[%d] in invalid state(%s)."
 			       " Discarded.\n",
 			       le16_to_cpu(ctlx->outbuf.type),
@@ -3534,7 +3534,7 @@ static void hfa384x_usbin_rx(wlandevice_t *wlandev, struct sk_buff *skb)
 		break;
 
 	default:
-		printk(KERN_WARNING "Received frame on unsupported port=%d\n",
+		netdev_warn(hw->wlandev->netdev, "Received frame on unsupported port=%d\n",
 		       HFA384x_RXSTATUS_MACPORT_GET(usbin->rxfrm.desc.status));
 		goto done;
 		break;
@@ -3596,7 +3596,7 @@ static void hfa384x_int_rxmonitor(wlandevice_t *wlandev,
 
 	skb = dev_alloc_skb(skblen);
 	if (skb == NULL) {
-		printk(KERN_ERR
+		netdev_err(hw->wlandev->netdev,
 		       "alloc_skb failed trying to allocate %d bytes\n",
 		       skblen);
 		return;
@@ -3714,7 +3714,7 @@ static void hfa384x_usbout_callback(struct urb *urb)
 		case -EPIPE:
 			{
 				hfa384x_t *hw = wlandev->priv;
-				printk(KERN_WARNING
+				netdev_warn(hw->wlandev->netdev,
 				       "%s tx pipe stalled: requesting reset\n",
 				       wlandev->netdev->name);
 				if (!test_and_set_bit
@@ -3747,7 +3747,7 @@ static void hfa384x_usbout_callback(struct urb *urb)
 			break;
 
 		default:
-			printk(KERN_INFO "unknown urb->status=%d\n",
+			netdev_info(wlandev->netdev, "unknown urb->status=%d\n",
 			       urb->status);
 			++(wlandev->linux_stats.tx_errors);
 			break;
@@ -3841,7 +3841,7 @@ static void hfa384x_ctlxout_callback(struct urb *urb)
 
 		default:
 			/* This is NOT a valid CTLX "success" state! */
-			printk(KERN_ERR
+			netdev_err(hw->wlandev->netdev,
 				"Illegal CTLX[%d] success state(%s, %d) in OUT URB\n",
 				le16_to_cpu(ctlx->outbuf.type),
 				ctlxstr(ctlx->state), urb->status);
@@ -3851,7 +3851,7 @@ static void hfa384x_ctlxout_callback(struct urb *urb)
 		/* If the pipe has stalled then we need to reset it */
 		if ((urb->status == -EPIPE) &&
 		    !test_and_set_bit(WORK_TX_HALT, &hw->usb_flags)) {
-			printk(KERN_WARNING
+			netdev_warn(hw->wlandev->netdev,
 			       "%s tx pipe stalled: requesting reset\n",
 			       hw->wlandev->netdev->name);
 			schedule_work(&hw->usb_work);

commit 32adf1e5533c9cb9fa8c2ad04a806500c518fb1f
Author: Kumar Amit Mehta <gmate.amit@gmail.com>
Date:   Fri Nov 2 02:19:45 2012 -0700

    staging: wlan-ng: hfa384x_usb.c: fixed a coding style issue
    
    checkpatch.pl throws error message for the current code. This patch fixes
    coding style issue.
    
    Signed-off-by: Kumar Amit Mehta <gmate.amit@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/hfa384x_usb.c b/drivers/staging/wlan-ng/hfa384x_usb.c
index f180c3d8b012..c1a8cb625154 100644
--- a/drivers/staging/wlan-ng/hfa384x_usb.c
+++ b/drivers/staging/wlan-ng/hfa384x_usb.c
@@ -171,11 +171,11 @@ static void hfa384x_ctlxout_callback(struct urb *urb);
 static void hfa384x_usbin_callback(struct urb *urb);
 
 static void
-hfa384x_usbin_txcompl(wlandevice_t *wlandev, hfa384x_usbin_t * usbin);
+hfa384x_usbin_txcompl(wlandevice_t *wlandev, hfa384x_usbin_t *usbin);
 
 static void hfa384x_usbin_rx(wlandevice_t *wlandev, struct sk_buff *skb);
 
-static void hfa384x_usbin_info(wlandevice_t *wlandev, hfa384x_usbin_t * usbin);
+static void hfa384x_usbin_info(wlandevice_t *wlandev, hfa384x_usbin_t *usbin);
 
 static void
 hfa384x_usbout_tx(wlandevice_t *wlandev, hfa384x_usbout_t *usbout);
@@ -285,7 +285,7 @@ static inline const char *ctlxstr(CTLX_STATE s)
 	return ctlx_str[s];
 };
 
-static inline hfa384x_usbctlx_t *get_active_ctlx(hfa384x_t * hw)
+static inline hfa384x_usbctlx_t *get_active_ctlx(hfa384x_t *hw)
 {
 	return list_entry(hw->ctlxq.active.next, hfa384x_usbctlx_t, list);
 }

commit 675be12f45f3f90ed22949fe08ad164316f75316
Author: Devendra Naga <devendra.aaru@gmail.com>
Date:   Thu Sep 13 15:00:54 2012 +0530

    staging:wlan-ng: clean hfa384x_usbctlx_submit
    
    else is not required as such we can do with just with a single if
    
    Signed-off-by: Devendra Naga <devendra.aaru@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/hfa384x_usb.c b/drivers/staging/wlan-ng/hfa384x_usb.c
index bdc63a61c663..f180c3d8b012 100644
--- a/drivers/staging/wlan-ng/hfa384x_usb.c
+++ b/drivers/staging/wlan-ng/hfa384x_usb.c
@@ -4045,23 +4045,20 @@ static void hfa384x_usb_throttlefn(unsigned long data)
 static int hfa384x_usbctlx_submit(hfa384x_t *hw, hfa384x_usbctlx_t *ctlx)
 {
 	unsigned long flags;
-	int ret;
 
 	spin_lock_irqsave(&hw->ctlxq.lock, flags);
 
 	if (hw->wlandev->hwremoved) {
 		spin_unlock_irqrestore(&hw->ctlxq.lock, flags);
-		ret = -ENODEV;
-	} else {
-		ctlx->state = CTLX_PENDING;
-		list_add_tail(&ctlx->list, &hw->ctlxq.pending);
-
-		spin_unlock_irqrestore(&hw->ctlxq.lock, flags);
-		hfa384x_usbctlxq_run(hw);
-		ret = 0;
+		return -ENODEV;
 	}
 
-	return ret;
+	ctlx->state = CTLX_PENDING;
+	list_add_tail(&ctlx->list, &hw->ctlxq.pending);
+	spin_unlock_irqrestore(&hw->ctlxq.lock, flags);
+	hfa384x_usbctlxq_run(hw);
+
+	return 0;
 }
 
 /*----------------------------------------------------------------

commit 102db1fc4a87668d0021395e6f7af996cf0c78d5
Author: Devendra Naga <devendra.aaru@gmail.com>
Date:   Sun Sep 9 18:41:00 2012 +0530

    staging:wlan-ng: cleanup prism2sta_commsqual_defer and hfa384x_drvr_getconfig
    
    the function prism2sta_commsqual_defer defines a goto done lable, which just
    jumps to end of function, which we can achieve with out it
    
    the hfa384x_drvr_getconfig doesn't need the result variable, we can
    remove and just return the function
    
    Signed-off-by: Devendra Naga <devendra.aaru@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/hfa384x_usb.c b/drivers/staging/wlan-ng/hfa384x_usb.c
index 25dd2639805c..bdc63a61c663 100644
--- a/drivers/staging/wlan-ng/hfa384x_usb.c
+++ b/drivers/staging/wlan-ng/hfa384x_usb.c
@@ -2140,11 +2140,7 @@ int hfa384x_drvr_flashdl_write(hfa384x_t *hw, u32 daddr, void *buf, u32 len)
 ----------------------------------------------------------------*/
 int hfa384x_drvr_getconfig(hfa384x_t *hw, u16 rid, void *buf, u16 len)
 {
-	int result;
-
-	result = hfa384x_dorrid_wait(hw, rid, buf, len);
-
-	return result;
+	return hfa384x_dorrid_wait(hw, rid, buf, len);
 }
 
 /*----------------------------------------------------------------

commit 89e6302ce7125d3be40637c2080be2b4728e4510
Author: Devendra Naga <devendra.aaru@gmail.com>
Date:   Sun Sep 9 18:40:54 2012 +0530

    staging:wlan-ng: cleanup hfa384x_ctlxout_callback
    
    goto done is not required and actually having goto done does
    jumps the program to end of the function and calls return.
    instead call return directly
    
    Signed-off-by: Devendra Naga <devendra.aaru@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/hfa384x_usb.c b/drivers/staging/wlan-ng/hfa384x_usb.c
index 01a20d5ba6d7..25dd2639805c 100644
--- a/drivers/staging/wlan-ng/hfa384x_usb.c
+++ b/drivers/staging/wlan-ng/hfa384x_usb.c
@@ -3790,7 +3790,7 @@ static void hfa384x_ctlxout_callback(struct urb *urb)
 #endif
 	if ((urb->status == -ESHUTDOWN) ||
 	    (urb->status == -ENODEV) || (hw == NULL))
-		goto done;
+		return;
 
 retry:
 	spin_lock_irqsave(&hw->ctlxq.lock, flags);
@@ -3803,7 +3803,7 @@ static void hfa384x_ctlxout_callback(struct urb *urb)
 	 */
 	if (list_empty(&hw->ctlxq.active)) {
 		spin_unlock_irqrestore(&hw->ctlxq.lock, flags);
-		goto done;
+		return;
 	}
 
 	/*
@@ -3886,9 +3886,6 @@ static void hfa384x_ctlxout_callback(struct urb *urb)
 
 	if (run_queue)
 		hfa384x_usbctlxq_run(hw);
-
-done:
-	;
 }
 
 /*----------------------------------------------------------------

commit 3f5142583066d6d9a9484b060779dad419780720
Author: Devendra Naga <devendra.aaru@gmail.com>
Date:   Sun Sep 9 18:40:53 2012 +0530

    staging:wlan-ng: cleanup hfa384x_usbctlx_resptimerfn
    
    goto done is not required and simple return is fine
    
    Signed-off-by: Devendra Naga <devendra.aaru@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/hfa384x_usb.c b/drivers/staging/wlan-ng/hfa384x_usb.c
index 7843dfdaa3cf..01a20d5ba6d7 100644
--- a/drivers/staging/wlan-ng/hfa384x_usb.c
+++ b/drivers/staging/wlan-ng/hfa384x_usb.c
@@ -3985,15 +3985,10 @@ static void hfa384x_usbctlx_resptimerfn(unsigned long data)
 		if (unlocked_usbctlx_cancel_async(hw, ctlx) == 0) {
 			spin_unlock_irqrestore(&hw->ctlxq.lock, flags);
 			hfa384x_usbctlxq_run(hw);
-			goto done;
+			return;
 		}
 	}
-
 	spin_unlock_irqrestore(&hw->ctlxq.lock, flags);
-
-done:
-	;
-
 }
 
 /*----------------------------------------------------------------

commit a6f9c48fdd566e09d437e104c5b5963133db1be4
Author: Ilia Mirkin <imirkin@alum.mit.edu>
Date:   Sun Mar 13 00:29:17 2011 -0500

    staging: wlan-ng: Remove NULL check before kfree
    
    This patch was generated by the following semantic patch:
    // <smpl>
    @@ expression E; @@
    - if (E != NULL) { kfree(E); }
    + kfree(E);
    
    @@ expression E; @@
    - if (E != NULL) { kfree(E); E = NULL; }
    + kfree(E);
    + E = NULL;
    // </smpl>
    
    Signed-off-by: Ilia Mirkin <imirkin@alum.mit.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/wlan-ng/hfa384x_usb.c b/drivers/staging/wlan-ng/hfa384x_usb.c
index a6efc033fe10..7843dfdaa3cf 100644
--- a/drivers/staging/wlan-ng/hfa384x_usb.c
+++ b/drivers/staging/wlan-ng/hfa384x_usb.c
@@ -612,10 +612,8 @@ void hfa384x_destroy(hfa384x_t *hw)
 		hfa384x_drvr_stop(hw);
 	hw->state = HFA384x_STATE_PREINIT;
 
-	if (hw->scanresults) {
-		kfree(hw->scanresults);
-		hw->scanresults = NULL;
-	}
+	kfree(hw->scanresults);
+	hw->scanresults = NULL;
 
 	/* Now to clean out the auth queue */
 	while ((skb = skb_dequeue(&hw->authq)))

commit 9b0131cb24182ef6cc478a89fc56fc6e004651e7
Author: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
Date:   Wed Sep 1 15:40:25 2010 +0200

    staging/trivial: fix typos concerning "initiali[zs]e"
    
    Signed-off-by: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/wlan-ng/hfa384x_usb.c b/drivers/staging/wlan-ng/hfa384x_usb.c
index ea81cb547bb1..a6efc033fe10 100644
--- a/drivers/staging/wlan-ng/hfa384x_usb.c
+++ b/drivers/staging/wlan-ng/hfa384x_usb.c
@@ -511,7 +511,7 @@ static void hfa384x_usb_defer(struct work_struct *data)
 * hfa384x_create
 *
 * Sets up the hfa384x_t data structure for use.  Note this
-* does _not_ intialize the actual hardware, just the data structures
+* does _not_ initialize the actual hardware, just the data structures
 * we use to keep track of its state.
 *
 * Arguments:

commit 51e4896adad00a066fad65649405c1c9fa108157
Author: Edgardo Hames <ehames@gmail.com>
Date:   Sat Jul 31 13:06:52 2010 -0300

    Staging: wlan-ng: fix style issues in p80211conv.h
    
    This patch removes typedefs in p80211conv.h.
    
    Signed-off-by: Edgardo Hames <ehames@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/wlan-ng/hfa384x_usb.c b/drivers/staging/wlan-ng/hfa384x_usb.c
index 925a7c50ba33..ea81cb547bb1 100644
--- a/drivers/staging/wlan-ng/hfa384x_usb.c
+++ b/drivers/staging/wlan-ng/hfa384x_usb.c
@@ -2707,7 +2707,7 @@ int hfa384x_drvr_stop(hfa384x_t *hw)
 ----------------------------------------------------------------*/
 int hfa384x_drvr_txframe(hfa384x_t *hw, struct sk_buff *skb,
 			 union p80211_hdr *p80211_hdr,
-			 p80211_metawep_t *p80211_wep)
+			 struct p80211_metawep *p80211_wep)
 {
 	int usbpktlen = sizeof(hfa384x_tx_frame_t);
 	int result;
@@ -3473,7 +3473,7 @@ static void hfa384x_usbin_rx(wlandevice_t *wlandev, struct sk_buff *skb)
 	hfa384x_usbin_t *usbin = (hfa384x_usbin_t *) skb->data;
 	hfa384x_t *hw = wlandev->priv;
 	int hdrlen;
-	p80211_rxmeta_t *rxmeta;
+	struct p80211_rxmeta *rxmeta;
 	u16 data_len;
 	u16 fc;
 
@@ -3590,14 +3590,14 @@ static void hfa384x_int_rxmonitor(wlandevice_t *wlandev,
 	datalen = le16_to_cpu(rxdesc->data_len);
 
 	/* Allocate an ind message+framesize skb */
-	skblen = sizeof(p80211_caphdr_t) + hdrlen + datalen + WLAN_CRC_LEN;
+	skblen = sizeof(struct p80211_caphdr) + hdrlen + datalen + WLAN_CRC_LEN;
 
 	/* sanity check the length */
 	if (skblen >
-	    (sizeof(p80211_caphdr_t) +
+	    (sizeof(struct p80211_caphdr) +
 	     WLAN_HDR_A4_LEN + WLAN_DATA_MAXLEN + WLAN_CRC_LEN)) {
 		pr_debug("overlen frm: len=%zd\n",
-			 skblen - sizeof(p80211_caphdr_t));
+			 skblen - sizeof(struct p80211_caphdr));
 	}
 
 	skb = dev_alloc_skb(skblen);
@@ -3611,13 +3611,13 @@ static void hfa384x_int_rxmonitor(wlandevice_t *wlandev,
 	/* only prepend the prism header if in the right mode */
 	if ((wlandev->netdev->type == ARPHRD_IEEE80211_PRISM) &&
 	    (hw->sniffhdr != 0)) {
-		p80211_caphdr_t *caphdr;
+		struct p80211_caphdr *caphdr;
 		/* The NEW header format! */
-		datap = skb_put(skb, sizeof(p80211_caphdr_t));
-		caphdr = (p80211_caphdr_t *) datap;
+		datap = skb_put(skb, sizeof(struct p80211_caphdr));
+		caphdr = (struct p80211_caphdr *) datap;
 
 		caphdr->version = htonl(P80211CAPTURE_VERSION);
-		caphdr->length = htonl(sizeof(p80211_caphdr_t));
+		caphdr->length = htonl(sizeof(struct p80211_caphdr));
 		caphdr->mactime = __cpu_to_be64(rxdesc->time) * 1000;
 		caphdr->hosttime = __cpu_to_be64(jiffies);
 		caphdr->phytype = htonl(4);	/* dss_dot11_b */

commit 93df38e593d949de83a6447d016cc4b07d392f47
Author: Edgardo Hames <ehames@gmail.com>
Date:   Fri Jul 30 22:51:55 2010 -0300

    Staging: wlan-ng: fix style issues for p80211hdr.h
    
    Removed typedef and other style issues.
    
    Signed-off-by: Edgardo Hames <ehames@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/wlan-ng/hfa384x_usb.c b/drivers/staging/wlan-ng/hfa384x_usb.c
index 563017aaa363..925a7c50ba33 100644
--- a/drivers/staging/wlan-ng/hfa384x_usb.c
+++ b/drivers/staging/wlan-ng/hfa384x_usb.c
@@ -2706,7 +2706,7 @@ int hfa384x_drvr_stop(hfa384x_t *hw)
 *	interrupt
 ----------------------------------------------------------------*/
 int hfa384x_drvr_txframe(hfa384x_t *hw, struct sk_buff *skb,
-			 p80211_hdr_t *p80211_hdr,
+			 union p80211_hdr *p80211_hdr,
 			 p80211_metawep_t *p80211_wep)
 {
 	int usbpktlen = sizeof(hfa384x_tx_frame_t);
@@ -2752,7 +2752,7 @@ int hfa384x_drvr_txframe(hfa384x_t *hw, struct sk_buff *skb,
 
 	/* copy the header over to the txdesc */
 	memcpy(&(hw->txbuff.txfrm.desc.frame_control), p80211_hdr,
-	       sizeof(p80211_hdr_t));
+	       sizeof(union p80211_hdr));
 
 	/* if we're using host WEP, increase size by IV+ICV */
 	if (p80211_wep->data) {

commit 594578979d0e25e178e0243eca9aa53499b89b05
Author: Dan Carpenter <error27@gmail.com>
Date:   Thu Jun 17 14:08:47 2010 +0200

    Staging: wlan-ng: silence a sparse warning
    
    This doesn't change the behavior.  It just silences a sparse warning.
    
    drivers/staging/wlan-ng/hfa384x_usb.c:2810:62: warning: dubious: !x | !y
    
    The point of the bitwise OR is so that a logical OR could short circuit
    the second call to test_and_set_bit().
    
    Signed-off-by: Dan Carpenter <error27@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/wlan-ng/hfa384x_usb.c b/drivers/staging/wlan-ng/hfa384x_usb.c
index a41db5dc8c7c..563017aaa363 100644
--- a/drivers/staging/wlan-ng/hfa384x_usb.c
+++ b/drivers/staging/wlan-ng/hfa384x_usb.c
@@ -2805,11 +2805,13 @@ void hfa384x_tx_timeout(wlandevice_t *wlandev)
 
 	spin_lock_irqsave(&hw->ctlxq.lock, flags);
 
-	if (!hw->wlandev->hwremoved &&
-	    /* Note the bitwise OR, not the logical OR. */
-	    (!test_and_set_bit(WORK_TX_HALT, &hw->usb_flags) |
-	     !test_and_set_bit(WORK_RX_HALT, &hw->usb_flags))) {
-		schedule_work(&hw->usb_work);
+	if (!hw->wlandev->hwremoved) {
+		int sched;
+
+		sched = !test_and_set_bit(WORK_TX_HALT, &hw->usb_flags);
+		sched |= !test_and_set_bit(WORK_RX_HALT, &hw->usb_flags);
+		if (sched)
+			schedule_work(&hw->usb_work);
 	}
 
 	spin_unlock_irqrestore(&hw->ctlxq.lock, flags);

commit 4ffab688827361bcdaca6ac83bbda195c53bd098
Author: Edgardo Hames <ehames@gmail.com>
Date:   Mon Mar 15 23:00:40 2010 -0300

    Staging: wlan-ng: rework code style after feedback
    
    This patch includes the feedback received from Richard Kennedy.
    
    Signed-off-by: Edgardo Hames <ehames@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/wlan-ng/hfa384x_usb.c b/drivers/staging/wlan-ng/hfa384x_usb.c
index 2400242e2d87..a41db5dc8c7c 100644
--- a/drivers/staging/wlan-ng/hfa384x_usb.c
+++ b/drivers/staging/wlan-ng/hfa384x_usb.c
@@ -2612,19 +2612,18 @@ int hfa384x_drvr_start(hfa384x_t *hw)
 	if (result1 != 0) {
 		if (result2 != 0) {
 			printk(KERN_ERR
-				"cmd_initialize() failed on two attempts,"
-				" results %d and %d\n", result1, result2);
+				"cmd_initialize() failed on two attempts, results %d and %d\n",
+				result1, result2);
 			usb_kill_urb(&hw->rx_urb);
 			goto done;
 		} else {
 			pr_debug("First cmd_initialize() failed (result %d),\n",
 				 result1);
-			pr_debug("but second attempt succeeded."
-				 " All should be ok\n");
+			pr_debug("but second attempt succeeded. All should be ok\n");
 		}
 	} else if (result2 != 0) {
-		printk(KERN_WARNING "First cmd_initialize() succeeded,"
-			" but second attempt failed (result=%d)\n", result2);
+		printk(KERN_WARNING "First cmd_initialize() succeeded, but second attempt failed (result=%d)\n",
+			result2);
 		printk(KERN_WARNING
 		       "Most likely the card will be functional\n");
 		goto done;
@@ -3382,9 +3381,7 @@ static void hfa384x_usbin_ctlx(hfa384x_t *hw, hfa384x_usbin_t *usbin,
 			 * our request has been acknowledged. Odd,
 			 * but our OUT URB is still alive...
 			 */
-			pr_debug("Causality violation: "
-				 "please reboot Universe, or email "
-				 "linux-wlan-devel@lists.linux-wlan.com\n");
+			pr_debug("Causality violation: please reboot Universe\n");
 			ctlx->state = CTLX_RESP_COMPLETE;
 			break;
 
@@ -3848,8 +3845,8 @@ static void hfa384x_ctlxout_callback(struct urb *urb)
 
 		default:
 			/* This is NOT a valid CTLX "success" state! */
-			printk(KERN_ERR "Illegal CTLX[%d]"
-				" success state(%s, %d) in OUT URB\n",
+			printk(KERN_ERR
+				"Illegal CTLX[%d] success state(%s, %d) in OUT URB\n",
 				le16_to_cpu(ctlx->outbuf.type),
 				ctlxstr(ctlx->state), urb->status);
 			break;

commit 631c8dec075c16b60c3e0a334c027196b07252b8
Author: Edgardo Hames <ehames@gmail.com>
Date:   Mon Mar 8 17:02:37 2010 -0800

    Staging: wlan-ng: fix coding style in hfa834x_usb.c
    
    This is a patch in hfa834x_usb.c to fix typedef declarations and long lines.
    
    Signed-off-by: Edgardo Hames <ehames@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/wlan-ng/hfa384x_usb.c b/drivers/staging/wlan-ng/hfa384x_usb.c
index 5df56f0238d6..2400242e2d87 100644
--- a/drivers/staging/wlan-ng/hfa384x_usb.c
+++ b/drivers/staging/wlan-ng/hfa384x_usb.c
@@ -62,9 +62,9 @@
 *
 * hfa384x_drvr_xxxconfig  An example of the drvr level abstraction. These
 *			functions are wrappers for the RID get/set
-*			sequence. They 	call copy_[to|from]_bap() and
-*			cmd_access().	These functions operate on the
-*			RIDs and buffers without validation.  The caller
+*			sequence. They call copy_[to|from]_bap() and
+*			cmd_access(). These functions operate on the
+*			RIDs and buffers without validation. The caller
 *			is responsible for that.
 *
 * API wrapper functions:
@@ -144,7 +144,6 @@ enum cmd_mode {
 	DOWAIT = 0,
 	DOASYNC
 };
-typedef enum cmd_mode CMD_MODE;
 
 #define THROTTLE_JIFFIES	(HZ/8)
 #define URB_ASYNC_UNLINK 0
@@ -206,12 +205,11 @@ static void unlocked_usbctlx_complete(hfa384x_t *hw, hfa384x_usbctlx_t *ctlx);
 struct usbctlx_completor {
 	int (*complete) (struct usbctlx_completor *);
 };
-typedef struct usbctlx_completor usbctlx_completor_t;
 
 static int
 hfa384x_usbctlx_complete_sync(hfa384x_t *hw,
 			      hfa384x_usbctlx_t *ctlx,
-			      usbctlx_completor_t *completor);
+			      struct usbctlx_completor *completor);
 
 static int
 unlocked_usbctlx_cancel_async(hfa384x_t *hw, hfa384x_usbctlx_t *ctlx);
@@ -232,13 +230,13 @@ usbctlx_get_rridresult(const hfa384x_usb_rridresp_t *rridresp,
 /* Low level req/resp CTLX formatters and submitters */
 static int
 hfa384x_docmd(hfa384x_t *hw,
-	      CMD_MODE mode,
+	      enum cmd_mode mode,
 	      hfa384x_metacmd_t *cmd,
 	      ctlx_cmdcb_t cmdcb, ctlx_usercb_t usercb, void *usercb_data);
 
 static int
 hfa384x_dorrid(hfa384x_t *hw,
-	       CMD_MODE mode,
+	       enum cmd_mode mode,
 	       u16 rid,
 	       void *riddata,
 	       unsigned int riddatalen,
@@ -246,7 +244,7 @@ hfa384x_dorrid(hfa384x_t *hw,
 
 static int
 hfa384x_dowrid(hfa384x_t *hw,
-	       CMD_MODE mode,
+	       enum cmd_mode mode,
 	       u16 rid,
 	       void *riddata,
 	       unsigned int riddatalen,
@@ -254,7 +252,7 @@ hfa384x_dowrid(hfa384x_t *hw,
 
 static int
 hfa384x_dormem(hfa384x_t *hw,
-	       CMD_MODE mode,
+	       enum cmd_mode mode,
 	       u16 page,
 	       u16 offset,
 	       void *data,
@@ -263,7 +261,7 @@ hfa384x_dormem(hfa384x_t *hw,
 
 static int
 hfa384x_dowmem(hfa384x_t *hw,
-	       CMD_MODE mode,
+	       enum cmd_mode mode,
 	       u16 page,
 	       u16 offset,
 	       void *data,
@@ -351,7 +349,8 @@ static int submit_rx_urb(hfa384x_t *hw, gfp_t memflags)
 	hw->rx_urb_skb = skb;
 
 	result = -ENOLINK;
-	if (!hw->wlandev->hwremoved && !test_bit(WORK_RX_HALT, &hw->usb_flags)) {
+	if (!hw->wlandev->hwremoved &&
+			!test_bit(WORK_RX_HALT, &hw->usb_flags)) {
 		result = SUBMIT_URB(&hw->rx_urb, memflags);
 
 		/* Check whether we need to reset the RX pipe */
@@ -451,7 +450,7 @@ static void hfa384x_usb_defer(struct work_struct *data)
 	if (test_bit(WORK_RX_HALT, &hw->usb_flags)) {
 		int ret;
 
-		usb_kill_urb(&hw->rx_urb);	/* Cannot be holding spinlock! */
+		usb_kill_urb(&hw->rx_urb); /* Cannot be holding spinlock! */
 
 		ret = usb_clear_halt(hw->usb, hw->endp_in);
 		if (ret != 0) {
@@ -668,26 +667,26 @@ usbctlx_get_rridresult(const hfa384x_usb_rridresp_t *rridresp,
 * when processing a CTLX that returns a hfa384x_cmdresult_t structure.
 ----------------------------------------------------------------*/
 struct usbctlx_cmd_completor {
-	usbctlx_completor_t head;
+	struct usbctlx_completor head;
 
 	const hfa384x_usb_cmdresp_t *cmdresp;
 	hfa384x_cmdresult_t *result;
 };
-typedef struct usbctlx_cmd_completor usbctlx_cmd_completor_t;
 
-static int usbctlx_cmd_completor_fn(usbctlx_completor_t *head)
+static inline int usbctlx_cmd_completor_fn(struct usbctlx_completor *head)
 {
-	usbctlx_cmd_completor_t *complete = (usbctlx_cmd_completor_t *) head;
+	struct usbctlx_cmd_completor *complete;
+
+	complete = (struct usbctlx_cmd_completor *) head;
 	return usbctlx_get_status(complete->cmdresp, complete->result);
 }
 
-static inline usbctlx_completor_t *init_cmd_completor(usbctlx_cmd_completor_t *
-						      completor,
-						      const
-						      hfa384x_usb_cmdresp_t *
-						      cmdresp,
-						      hfa384x_cmdresult_t *
-						      result)
+static inline struct usbctlx_completor *init_cmd_completor(
+						struct usbctlx_cmd_completor
+							*completor,
+						const hfa384x_usb_cmdresp_t
+							*cmdresp,
+						hfa384x_cmdresult_t *result)
 {
 	completor->head.complete = usbctlx_cmd_completor_fn;
 	completor->cmdresp = cmdresp;
@@ -701,19 +700,19 @@ static inline usbctlx_completor_t *init_cmd_completor(usbctlx_cmd_completor_t *
 * when processing a CTLX that reads a RID.
 ----------------------------------------------------------------*/
 struct usbctlx_rrid_completor {
-	usbctlx_completor_t head;
+	struct usbctlx_completor head;
 
 	const hfa384x_usb_rridresp_t *rridresp;
 	void *riddata;
 	unsigned int riddatalen;
 };
-typedef struct usbctlx_rrid_completor usbctlx_rrid_completor_t;
 
-static int usbctlx_rrid_completor_fn(usbctlx_completor_t *head)
+static int usbctlx_rrid_completor_fn(struct usbctlx_completor *head)
 {
-	usbctlx_rrid_completor_t *complete = (usbctlx_rrid_completor_t *) head;
+	struct usbctlx_rrid_completor *complete;
 	hfa384x_rridresult_t rridresult;
 
+	complete = (struct usbctlx_rrid_completor *) head;
 	usbctlx_get_rridresult(complete->rridresp, &rridresult);
 
 	/* Validate the length, note body len calculation in bytes */
@@ -729,12 +728,13 @@ static int usbctlx_rrid_completor_fn(usbctlx_completor_t *head)
 	return 0;
 }
 
-static inline usbctlx_completor_t *init_rrid_completor(usbctlx_rrid_completor_t
-						       *completor,
-						       const
-						       hfa384x_usb_rridresp_t *
-						       rridresp, void *riddata,
-						       unsigned int riddatalen)
+static inline struct usbctlx_completor *init_rrid_completor(
+						struct usbctlx_rrid_completor
+							*completor,
+						const hfa384x_usb_rridresp_t
+							*rridresp,
+						void *riddata,
+						unsigned int riddatalen)
 {
 	completor->head.complete = usbctlx_rrid_completor_fn;
 	completor->rridresp = rridresp;
@@ -747,14 +747,14 @@ static inline usbctlx_completor_t *init_rrid_completor(usbctlx_rrid_completor_t
 * Completor object:
 * Interprets the results of a synchronous RID-write
 ----------------------------------------------------------------*/
-typedef usbctlx_cmd_completor_t usbctlx_wrid_completor_t;
+typedef struct usbctlx_cmd_completor usbctlx_wrid_completor_t;
 #define init_wrid_completor  init_cmd_completor
 
 /*----------------------------------------------------------------
 * Completor object:
 * Interprets the results of a synchronous memory-write
 ----------------------------------------------------------------*/
-typedef usbctlx_cmd_completor_t usbctlx_wmem_completor_t;
+typedef struct usbctlx_cmd_completor usbctlx_wmem_completor_t;
 #define init_wmem_completor  init_cmd_completor
 
 /*----------------------------------------------------------------
@@ -762,7 +762,7 @@ typedef usbctlx_cmd_completor_t usbctlx_wmem_completor_t;
 * Interprets the results of a synchronous memory-read
 ----------------------------------------------------------------*/
 struct usbctlx_rmem_completor {
-	usbctlx_completor_t head;
+	struct usbctlx_completor head;
 
 	const hfa384x_usb_rmemresp_t *rmemresp;
 	void *data;
@@ -770,7 +770,7 @@ struct usbctlx_rmem_completor {
 };
 typedef struct usbctlx_rmem_completor usbctlx_rmem_completor_t;
 
-static int usbctlx_rmem_completor_fn(usbctlx_completor_t *head)
+static int usbctlx_rmem_completor_fn(struct usbctlx_completor *head)
 {
 	usbctlx_rmem_completor_t *complete = (usbctlx_rmem_completor_t *) head;
 
@@ -779,11 +779,13 @@ static int usbctlx_rmem_completor_fn(usbctlx_completor_t *head)
 	return 0;
 }
 
-static inline usbctlx_completor_t *init_rmem_completor(usbctlx_rmem_completor_t
-						       *completor,
-						       hfa384x_usb_rmemresp_t
-						       *rmemresp, void *data,
-						       unsigned int len)
+static inline struct usbctlx_completor *init_rmem_completor(
+						usbctlx_rmem_completor_t
+							*completor,
+						hfa384x_usb_rmemresp_t
+							*rmemresp,
+						void *data,
+						unsigned int len)
 {
 	completor->head.complete = usbctlx_rmem_completor_fn;
 	completor->rmemresp = rmemresp;
@@ -1226,7 +1228,7 @@ int hfa384x_corereset(hfa384x_t *hw, int holdtime, int settletime, int genesis)
 *
 * Arguments:
 *	hw		device structure
-*	ctlx	 	CTLX ptr
+*	ctlx		CTLX ptr
 *	completor	functor object to decide what to
 *			do with the CTLX's result.
 *
@@ -1244,7 +1246,7 @@ int hfa384x_corereset(hfa384x_t *hw, int holdtime, int settletime, int genesis)
 ----------------------------------------------------------------*/
 static int hfa384x_usbctlx_complete_sync(hfa384x_t *hw,
 					 hfa384x_usbctlx_t *ctlx,
-					 usbctlx_completor_t *completor)
+					 struct usbctlx_completor *completor)
 {
 	unsigned long flags;
 	int result;
@@ -1359,7 +1361,7 @@ static int hfa384x_usbctlx_complete_sync(hfa384x_t *hw,
 ----------------------------------------------------------------*/
 static int
 hfa384x_docmd(hfa384x_t *hw,
-	      CMD_MODE mode,
+	      enum cmd_mode mode,
 	      hfa384x_metacmd_t *cmd,
 	      ctlx_cmdcb_t cmdcb, ctlx_usercb_t usercb, void *usercb_data)
 {
@@ -1394,7 +1396,7 @@ hfa384x_docmd(hfa384x_t *hw,
 	if (result != 0) {
 		kfree(ctlx);
 	} else if (mode == DOWAIT) {
-		usbctlx_cmd_completor_t completor;
+		struct usbctlx_cmd_completor completor;
 
 		result =
 		    hfa384x_usbctlx_complete_sync(hw, ctlx,
@@ -1448,7 +1450,7 @@ hfa384x_docmd(hfa384x_t *hw,
 ----------------------------------------------------------------*/
 static int
 hfa384x_dorrid(hfa384x_t *hw,
-	       CMD_MODE mode,
+	       enum cmd_mode mode,
 	       u16 rid,
 	       void *riddata,
 	       unsigned int riddatalen,
@@ -1481,7 +1483,7 @@ hfa384x_dorrid(hfa384x_t *hw,
 	if (result != 0) {
 		kfree(ctlx);
 	} else if (mode == DOWAIT) {
-		usbctlx_rrid_completor_t completor;
+		struct usbctlx_rrid_completor completor;
 
 		result =
 		    hfa384x_usbctlx_complete_sync(hw, ctlx,
@@ -1506,7 +1508,7 @@ hfa384x_dorrid(hfa384x_t *hw,
 *
 * Arguments:
 *	hw		device structure
-*	CMD_MODE	DOWAIT or DOASYNC
+*	enum cmd_mode	DOWAIT or DOASYNC
 *	rid		RID code
 *	riddata		Data portion of RID formatted for MAC
 *	riddatalen	Length of the data portion in bytes
@@ -1529,7 +1531,7 @@ hfa384x_dorrid(hfa384x_t *hw,
 ----------------------------------------------------------------*/
 static int
 hfa384x_dowrid(hfa384x_t *hw,
-	       CMD_MODE mode,
+	       enum cmd_mode mode,
 	       u16 rid,
 	       void *riddata,
 	       unsigned int riddatalen,
@@ -1616,7 +1618,7 @@ hfa384x_dowrid(hfa384x_t *hw,
 ----------------------------------------------------------------*/
 static int
 hfa384x_dormem(hfa384x_t *hw,
-	       CMD_MODE mode,
+	       enum cmd_mode mode,
 	       u16 page,
 	       u16 offset,
 	       void *data,
@@ -1707,7 +1709,7 @@ hfa384x_dormem(hfa384x_t *hw,
 ----------------------------------------------------------------*/
 static int
 hfa384x_dowmem(hfa384x_t *hw,
-	       CMD_MODE mode,
+	       enum cmd_mode mode,
 	       u16 page,
 	       u16 offset,
 	       void *data,
@@ -2075,12 +2077,9 @@ int hfa384x_drvr_flashdl_write(hfa384x_t *hw, u32 daddr, void *buf, u32 len)
 			    (j * HFA384x_USB_RWMEM_MAXLEN);
 
 			writepage = HFA384x_ADDR_CMD_MKPAGE(dlbufaddr +
-							    (j *
-							     HFA384x_USB_RWMEM_MAXLEN));
-			writeoffset =
-			    HFA384x_ADDR_CMD_MKOFF(dlbufaddr +
-						   (j *
-						    HFA384x_USB_RWMEM_MAXLEN));
+						(j * HFA384x_USB_RWMEM_MAXLEN));
+			writeoffset = HFA384x_ADDR_CMD_MKOFF(dlbufaddr +
+						(j * HFA384x_USB_RWMEM_MAXLEN));
 
 			writelen = burnlen - (j * HFA384x_USB_RWMEM_MAXLEN);
 			writelen = writelen > HFA384x_USB_RWMEM_MAXLEN ?
@@ -2133,7 +2132,7 @@ int hfa384x_drvr_flashdl_write(hfa384x_t *hw, u32 daddr, void *buf, u32 len)
 *	0		success
 *	>0		f/w reported error - f/w status code
 *	<0		driver reported error
-*	-ENODATA 	length mismatch between argument and retrieved
+*	-ENODATA	length mismatch between argument and retrieved
 *			record.
 *
 * Side effects:
@@ -2451,7 +2450,9 @@ int hfa384x_drvr_readpda(hfa384x_t *hw, void *buf, unsigned int len)
 		currpage = HFA384x_ADDR_CMD_MKPAGE(pdaloc[i].cardaddr);
 		curroffset = HFA384x_ADDR_CMD_MKOFF(pdaloc[i].cardaddr);
 
-		result = hfa384x_dormem_wait(hw, currpage, curroffset, buf, len);	/* units of bytes */
+		/* units of bytes */
+		result = hfa384x_dormem_wait(hw, currpage, curroffset, buf,
+						len);
 
 		if (result) {
 			printk(KERN_WARNING
@@ -2611,20 +2612,19 @@ int hfa384x_drvr_start(hfa384x_t *hw)
 	if (result1 != 0) {
 		if (result2 != 0) {
 			printk(KERN_ERR
-			       "cmd_initialize() failed on two attempts, results %d and %d\n",
-			       result1, result2);
+				"cmd_initialize() failed on two attempts,"
+				" results %d and %d\n", result1, result2);
 			usb_kill_urb(&hw->rx_urb);
 			goto done;
 		} else {
 			pr_debug("First cmd_initialize() failed (result %d),\n",
 				 result1);
-			pr_debug
-			    ("but second attempt succeeded. All should be ok\n");
+			pr_debug("but second attempt succeeded."
+				 " All should be ok\n");
 		}
 	} else if (result2 != 0) {
-		printk(KERN_WARNING
-		       "First cmd_initialize() succeeded, but second attempt failed (result=%d)\n",
-		       result2);
+		printk(KERN_WARNING "First cmd_initialize() succeeded,"
+			" but second attempt failed (result=%d)\n", result2);
 		printk(KERN_WARNING
 		       "Most likely the card will be functional\n");
 		goto done;
@@ -3382,8 +3382,9 @@ static void hfa384x_usbin_ctlx(hfa384x_t *hw, hfa384x_usbin_t *usbin,
 			 * our request has been acknowledged. Odd,
 			 * but our OUT URB is still alive...
 			 */
-			pr_debug
-			    ("Causality violation: please reboot Universe, or email linux-wlan-devel@lists.linux-wlan.com\n");
+			pr_debug("Causality violation: "
+				 "please reboot Universe, or email "
+				 "linux-wlan-devel@lists.linux-wlan.com\n");
 			ctlx->state = CTLX_RESP_COMPLETE;
 			break;
 
@@ -3442,7 +3443,7 @@ static void hfa384x_usbin_txcompl(wlandevice_t *wlandev,
 {
 	u16 status;
 
-	status = le16_to_cpu(usbin->type);	/* yeah I know it says type... */
+	status = le16_to_cpu(usbin->type); /* yeah I know it says type... */
 
 	/* Was there an error? */
 	if (HFA384x_TXSTATUS_ISERROR(status))
@@ -3583,7 +3584,7 @@ static void hfa384x_int_rxmonitor(wlandevice_t *wlandev,
 	struct sk_buff *skb;
 	hfa384x_t *hw = wlandev->priv;
 
-	/* Don't forget the status, time, and data_len fields are in host order */
+	/* Remember the status, time, and data_len fields are in host order */
 	/* Figure out how big the frame is */
 	fc = le16_to_cpu(rxdesc->frame_control);
 	hdrlen = p80211_headerlen(fc);
@@ -3632,7 +3633,8 @@ static void hfa384x_int_rxmonitor(wlandevice_t *wlandev,
 		caphdr->encoding = htonl(1);	/* cck */
 	}
 
-	/* Copy the 802.11 header to the skb (ctl frames may be less than a full header) */
+	/* Copy the 802.11 header to the skb
+	   (ctl frames may be less than a full header) */
 	datap = skb_put(skb, hdrlen);
 	memcpy(datap, &(rxdesc->frame_control), hdrlen);
 
@@ -3644,7 +3646,8 @@ static void hfa384x_int_rxmonitor(wlandevice_t *wlandev,
 		/* check for unencrypted stuff if WEP bit set. */
 		if (*(datap - hdrlen + 1) & 0x40)	/* wep set */
 			if ((*(datap) == 0xaa) && (*(datap + 1) == 0xaa))
-				*(datap - hdrlen + 1) &= 0xbf;	/* clear wep; it's the 802.2 header! */
+				/* clear wep; it's the 802.2 header! */
+				*(datap - hdrlen + 1) &= 0xbf;
 	}
 
 	if (hw->sniff_fcs) {
@@ -3845,10 +3848,10 @@ static void hfa384x_ctlxout_callback(struct urb *urb)
 
 		default:
 			/* This is NOT a valid CTLX "success" state! */
-			printk(KERN_ERR
-			       "Illegal CTLX[%d] success state(%s, %d) in OUT URB\n",
-			       le16_to_cpu(ctlx->outbuf.type),
-			       ctlxstr(ctlx->state), urb->status);
+			printk(KERN_ERR "Illegal CTLX[%d]"
+				" success state(%s, %d) in OUT URB\n",
+				le16_to_cpu(ctlx->outbuf.type),
+				ctlxstr(ctlx->state), urb->status);
 			break;
 		}		/* switch */
 	} else {

commit b02957d58a27525499ab10d272d3b44682a7ae50
Merge: 3a8954e8f22c b94c765ac31f
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Thu Mar 4 08:14:54 2010 -0800

    Staging: Merge two branches of coding style fixes together
    
    Turns out that multiple people sent pretty much the same patch
    for the same staging drivers.  Commit these in two different
    branches and merge them together to get a more complete coverage
    of the cleanup and properly credit everyone for the work that they
    did.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 3f4b4e779714ae2dd55757617a8033ab338fa7f0
Author: Andrew Elwell <andrew.elwell@gmail.com>
Date:   Thu Feb 18 23:56:13 2010 +0100

    Staging: wlan-ng: More checkpatch.pl error cleanups
    
    Signed-off-by: Andrew Elwell <Andrew.Elwell@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/wlan-ng/hfa384x_usb.c b/drivers/staging/wlan-ng/hfa384x_usb.c
index 730d085c3f87..d3a85f249e96 100644
--- a/drivers/staging/wlan-ng/hfa384x_usb.c
+++ b/drivers/staging/wlan-ng/hfa384x_usb.c
@@ -1909,18 +1909,19 @@ int hfa384x_drvr_flashdl_enable(hfa384x_t *hw)
 		return -EINVAL;
 
 	/* Retrieve the buffer loc&size and timeout */
-	if ((result = hfa384x_drvr_getconfig(hw, HFA384x_RID_DOWNLOADBUFFER,
-					     &(hw->bufinfo),
-					     sizeof(hw->bufinfo)))) {
+	result = hfa384x_drvr_getconfig(hw, HFA384x_RID_DOWNLOADBUFFER,
+					&(hw->bufinfo), sizeof(hw->bufinfo));
+	if (result)
 		return result;
-	}
+
 	hw->bufinfo.page = le16_to_cpu(hw->bufinfo.page);
 	hw->bufinfo.offset = le16_to_cpu(hw->bufinfo.offset);
 	hw->bufinfo.len = le16_to_cpu(hw->bufinfo.len);
-	if ((result = hfa384x_drvr_getconfig16(hw, HFA384x_RID_MAXLOADTIME,
-					       &(hw->dltimeout)))) {
+	result = hfa384x_drvr_getconfig16(hw, HFA384x_RID_MAXLOADTIME,
+					  &(hw->dltimeout));
+	if (result)
 		return result;
-	}
+
 	hw->dltimeout = le16_to_cpu(hw->dltimeout);
 
 	pr_debug("flashdl_enable\n");
@@ -3071,9 +3072,9 @@ static void hfa384x_usbctlxq_run(hfa384x_t *hw)
 				  hfa384x_ctlxout_callback, hw);
 		hw->ctlx_urb.transfer_flags |= USB_QUEUE_BULK;
 
-		/* Now submit the URB and update the CTLX's state
-		 */
-		if ((result = SUBMIT_URB(&hw->ctlx_urb, GFP_ATOMIC)) == 0) {
+		/* Now submit the URB and update the CTLX's state */
+		result = SUBMIT_URB(&hw->ctlx_urb, GFP_ATOMIC);
+		if (result == 0) {
 			/* This CTLX is now running on the active queue */
 			head->state = CTLX_REQ_SUBMITTED;
 
@@ -3599,7 +3600,8 @@ static void hfa384x_int_rxmonitor(wlandevice_t *wlandev,
 			 skblen - sizeof(p80211_caphdr_t));
 	}
 
-	if ((skb = dev_alloc_skb(skblen)) == NULL) {
+	skb = dev_alloc_skb(skblen);
+	if (skb == NULL) {
 		printk(KERN_ERR
 		       "alloc_skb failed trying to allocate %d bytes\n",
 		       skblen);
@@ -3870,9 +3872,9 @@ static void hfa384x_ctlxout_callback(struct urb *urb)
 
 delresp:
 	if (delete_resptimer) {
-		if ((timer_ok = del_timer(&hw->resptimer)) != 0) {
+		timer_ok = del_timer(&hw->resptimer);
+		if (timer_ok != 0)
 			hw->resp_timer_done = 1;
-		}
 	}
 
 	spin_unlock_irqrestore(&hw->ctlxq.lock, flags);

commit ef1a0ed7f1793531e5fb3ee489cb1e2b627f76fd
Author: Andrew Elwell <andrew.elwell@gmail.com>
Date:   Thu Feb 18 23:56:12 2010 +0100

    Staging: wlan-ng - checkpatch.pl fixups
    
    Basic fixups in the staging/wlan-ng directory.
    (First kernel patch - thanks to FOSDEM talk)
    
    Signed-off-by: Andrew Elwell <Andrew.Elwell@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/wlan-ng/hfa384x_usb.c b/drivers/staging/wlan-ng/hfa384x_usb.c
index 925678babd9e..730d085c3f87 100644
--- a/drivers/staging/wlan-ng/hfa384x_usb.c
+++ b/drivers/staging/wlan-ng/hfa384x_usb.c
@@ -118,15 +118,15 @@
 #include <linux/wireless.h>
 #include <linux/netdevice.h>
 #include <linux/timer.h>
-#include <asm/io.h>
+#include <linux/io.h>
 #include <linux/delay.h>
 #include <asm/byteorder.h>
-#include <asm/bitops.h>
+#include <linux/bitops.h>
 #include <linux/list.h>
 #include <linux/usb.h>
 #include <linux/byteorder/generic.h>
 
-#define SUBMIT_URB(u,f)  usb_submit_urb(u,f)
+#define SUBMIT_URB(u, f)  usb_submit_urb(u, f)
 
 #include "p80211types.h"
 #include "p80211hdr.h"
@@ -627,7 +627,7 @@ static hfa384x_usbctlx_t *usbctlx_alloc(void)
 {
 	hfa384x_usbctlx_t *ctlx;
 
-	ctlx = kmalloc(sizeof(*ctlx), in_interrupt()? GFP_ATOMIC : GFP_KERNEL);
+	ctlx = kmalloc(sizeof(*ctlx), in_interrupt() ? GFP_ATOMIC : GFP_KERNEL);
 	if (ctlx != NULL) {
 		memset(ctlx, 0, sizeof(*ctlx));
 		init_completion(&ctlx->done);
@@ -675,7 +675,7 @@ struct usbctlx_cmd_completor {
 };
 typedef struct usbctlx_cmd_completor usbctlx_cmd_completor_t;
 
-static int usbctlx_cmd_completor_fn(usbctlx_completor_t * head)
+static int usbctlx_cmd_completor_fn(usbctlx_completor_t *head)
 {
 	usbctlx_cmd_completor_t *complete = (usbctlx_cmd_completor_t *) head;
 	return usbctlx_get_status(complete->cmdresp, complete->result);
@@ -3642,7 +3642,7 @@ static void hfa384x_int_rxmonitor(wlandevice_t *wlandev,
 		/* check for unencrypted stuff if WEP bit set. */
 		if (*(datap - hdrlen + 1) & 0x40)	/* wep set */
 			if ((*(datap) == 0xaa) && (*(datap + 1) == 0xaa))
-				*(datap - hdrlen + 1) &= 0xbf;	// clear wep; it's the 802.2 header!
+				*(datap - hdrlen + 1) &= 0xbf;	/* clear wep; it's the 802.2 header! */
 	}
 
 	if (hw->sniff_fcs) {

commit 5dd8acc8fd6b0476a2dc49bc6de4712d22c368c0
Author: Svenne Krap <svenne@krap.dk>
Date:   Sun Feb 14 18:59:00 2010 +0100

    Staging: wlan-ng: multiple safe style cleanups
    
    Cleanups as suggested by checkpatch.pl utiltiy.
    .o's from before and after cleanup have matching SHA1s.
    
    Signed-off-by: Svenne Krap <svenne@krap.dk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/wlan-ng/hfa384x_usb.c b/drivers/staging/wlan-ng/hfa384x_usb.c
index bd2eba304842..612995b3d576 100644
--- a/drivers/staging/wlan-ng/hfa384x_usb.c
+++ b/drivers/staging/wlan-ng/hfa384x_usb.c
@@ -126,7 +126,7 @@
 #include <linux/usb.h>
 #include <linux/byteorder/generic.h>
 
-#define SUBMIT_URB(u,f)  usb_submit_urb(u,f)
+#define SUBMIT_URB(u, f)  usb_submit_urb(u, f)
 
 #include "p80211types.h"
 #include "p80211hdr.h"
@@ -627,7 +627,7 @@ static hfa384x_usbctlx_t *usbctlx_alloc(void)
 {
 	hfa384x_usbctlx_t *ctlx;
 
-	ctlx = kmalloc(sizeof(*ctlx), in_interrupt()? GFP_ATOMIC : GFP_KERNEL);
+	ctlx = kmalloc(sizeof(*ctlx), in_interrupt() ? GFP_ATOMIC : GFP_KERNEL);
 	if (ctlx != NULL) {
 		memset(ctlx, 0, sizeof(*ctlx));
 		init_completion(&ctlx->done);
@@ -675,7 +675,7 @@ struct usbctlx_cmd_completor {
 };
 typedef struct usbctlx_cmd_completor usbctlx_cmd_completor_t;
 
-static int usbctlx_cmd_completor_fn(usbctlx_completor_t * head)
+static int usbctlx_cmd_completor_fn(usbctlx_completor_t *head)
 {
 	usbctlx_cmd_completor_t *complete = (usbctlx_cmd_completor_t *) head;
 	return usbctlx_get_status(complete->cmdresp, complete->result);
@@ -3649,7 +3649,7 @@ static void hfa384x_int_rxmonitor(wlandevice_t *wlandev,
 		/* check for unencrypted stuff if WEP bit set. */
 		if (*(datap - hdrlen + 1) & 0x40)	/* wep set */
 			if ((*(datap) == 0xaa) && (*(datap + 1) == 0xaa))
-				*(datap - hdrlen + 1) &= 0xbf;	// clear wep; it's the 802.2 header!
+				*(datap - hdrlen + 1) &= 0xbf;	/* clear wep; it's the 802.2 header! */
 	}
 
 	if (hw->sniff_fcs) {

commit 46800b225f8c9dc264e1e9c15b1e104b9e0af5b5
Author: Svenne Krap <svenne@krap.dk>
Date:   Sun Feb 14 18:59:42 2010 +0100

    Staging: wlan-ng: clean up assignments in if statements
    
    Trivial changes to code-paths.
    
    Signed-off-by: Svenne Krap <svenne@krap.dk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/wlan-ng/hfa384x_usb.c b/drivers/staging/wlan-ng/hfa384x_usb.c
index c6a9e17ec79b..bd2eba304842 100644
--- a/drivers/staging/wlan-ng/hfa384x_usb.c
+++ b/drivers/staging/wlan-ng/hfa384x_usb.c
@@ -1909,16 +1909,20 @@ int hfa384x_drvr_flashdl_enable(hfa384x_t *hw)
 		return -EINVAL;
 
 	/* Retrieve the buffer loc&size and timeout */
-	if ((result = hfa384x_drvr_getconfig(hw, HFA384x_RID_DOWNLOADBUFFER,
-					     &(hw->bufinfo),
-					     sizeof(hw->bufinfo)))) {
+
+	result = hfa384x_drvr_getconfig(hw, HFA384x_RID_DOWNLOADBUFFER,
+		&(hw->bufinfo), sizeof(hw->bufinfo));
+	if (result) {
 		return result;
 	}
 	hw->bufinfo.page = le16_to_cpu(hw->bufinfo.page);
 	hw->bufinfo.offset = le16_to_cpu(hw->bufinfo.offset);
 	hw->bufinfo.len = le16_to_cpu(hw->bufinfo.len);
-	if ((result = hfa384x_drvr_getconfig16(hw, HFA384x_RID_MAXLOADTIME,
-					       &(hw->dltimeout)))) {
+
+	result = hfa384x_drvr_getconfig16(hw, HFA384x_RID_MAXLOADTIME,
+		&(hw->dltimeout));
+
+	if (result) {
 		return result;
 	}
 	hw->dltimeout = le16_to_cpu(hw->dltimeout);
@@ -3073,7 +3077,9 @@ static void hfa384x_usbctlxq_run(hfa384x_t *hw)
 
 		/* Now submit the URB and update the CTLX's state
 		 */
-		if ((result = SUBMIT_URB(&hw->ctlx_urb, GFP_ATOMIC)) == 0) {
+
+		result = SUBMIT_URB(&hw->ctlx_urb, GFP_ATOMIC);
+		if (result == 0) {
 			/* This CTLX is now running on the active queue */
 			head->state = CTLX_REQ_SUBMITTED;
 
@@ -3599,7 +3605,8 @@ static void hfa384x_int_rxmonitor(wlandevice_t *wlandev,
 			 skblen - sizeof(p80211_caphdr_t));
 	}
 
-	if ((skb = dev_alloc_skb(skblen)) == NULL) {
+	skb = dev_alloc_skb(skblen);
+	if (skb == NULL) {
 		printk(KERN_ERR
 		       "alloc_skb failed trying to allocate %d bytes\n",
 		       skblen);
@@ -3870,7 +3877,8 @@ static void hfa384x_ctlxout_callback(struct urb *urb)
 
 delresp:
 	if (delete_resptimer) {
-		if ((timer_ok = del_timer(&hw->resptimer)) != 0) {
+		timer_ok = del_timer(&hw->resptimer);
+		if (timer_ok != 0) {
 			hw->resp_timer_done = 1;
 		}
 	}

commit 3fc0d278e3198c8aa9baa71c49a8364d31686ba9
Author: Adam Buchbinder <adam.buchbinder@gmail.com>
Date:   Fri Dec 18 15:43:52 2009 -0500

    staging: Fix misspelling of "invocation" in comment.
    
    A comment misspells "invocation"; this fixes it. No code changes.
    
    Signed-off-by: Adam Buchbinder <adam.buchbinder@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/wlan-ng/hfa384x_usb.c b/drivers/staging/wlan-ng/hfa384x_usb.c
index 925678babd9e..c6a9e17ec79b 100644
--- a/drivers/staging/wlan-ng/hfa384x_usb.c
+++ b/drivers/staging/wlan-ng/hfa384x_usb.c
@@ -52,7 +52,7 @@
 * around the register accesses.  The next higher level represents C-callable
 * prism2 API functions that match the Intersil documentation as closely
 * as is reasonable.  The next higher layer implements common sequences
-* of invokations of the API layer (e.g. write to bap, followed by cmd).
+* of invocations of the API layer (e.g. write to bap, followed by cmd).
 *
 * Common sequences:
 * hfa384x_drvr_xxx	Highest level abstractions provided by the

commit 0d0202fd888a0f6e42d14aa903c6d79fc8777125
Author: Moritz Muehlenhoff <jmm@debian.org>
Date:   Sun Jun 21 22:43:44 2009 +0200

    Staging: wlan-ng: Remove some superflous comments
    
    Signed-off-by: Moritz Muehlenhoff <jmm@debian.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/wlan-ng/hfa384x_usb.c b/drivers/staging/wlan-ng/hfa384x_usb.c
index deb8ba97f854..925678babd9e 100644
--- a/drivers/staging/wlan-ng/hfa384x_usb.c
+++ b/drivers/staging/wlan-ng/hfa384x_usb.c
@@ -128,9 +128,6 @@
 
 #define SUBMIT_URB(u,f)  usb_submit_urb(u,f)
 
-/*================================================================*/
-/* Project Includes */
-
 #include "p80211types.h"
 #include "p80211hdr.h"
 #include "p80211mgmt.h"

commit 297f06cea635ea4552541a11e7fb7014425110c6
Author: Mithlesh Thukral <mithlesh@linsyssoft.com>
Date:   Wed Jun 10 19:36:11 2009 +0530

    staging: wlan-ng: scripts/checkpatch.pl error fixes.
    
    scripts/checkpatch.pl error fixes. This is a TODO item.
    This patch fixes most of the errors reported by checkpatch.pl in
    wlan-ng directory of staging tree.
    
    Signed-off-by: Mithlesh Thukral <mithlesh@linsyssoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/wlan-ng/hfa384x_usb.c b/drivers/staging/wlan-ng/hfa384x_usb.c
index 51d9e520d52a..deb8ba97f854 100644
--- a/drivers/staging/wlan-ng/hfa384x_usb.c
+++ b/drivers/staging/wlan-ng/hfa384x_usb.c
@@ -160,13 +160,13 @@ static void dbprint_urb(struct urb *urb);
 #endif
 
 static void
-hfa384x_int_rxmonitor(wlandevice_t * wlandev, hfa384x_usb_rxfrm_t * rxfrm);
+hfa384x_int_rxmonitor(wlandevice_t *wlandev, hfa384x_usb_rxfrm_t *rxfrm);
 
 static void hfa384x_usb_defer(struct work_struct *data);
 
-static int submit_rx_urb(hfa384x_t * hw, gfp_t flags);
+static int submit_rx_urb(hfa384x_t *hw, gfp_t flags);
 
-static int submit_tx_urb(hfa384x_t * hw, struct urb *tx_urb, gfp_t flags);
+static int submit_tx_urb(hfa384x_t *hw, struct urb *tx_urb, gfp_t flags);
 
 /*---------------------------------------------------*/
 /* Callbacks */
@@ -175,22 +175,22 @@ static void hfa384x_ctlxout_callback(struct urb *urb);
 static void hfa384x_usbin_callback(struct urb *urb);
 
 static void
-hfa384x_usbin_txcompl(wlandevice_t * wlandev, hfa384x_usbin_t * usbin);
+hfa384x_usbin_txcompl(wlandevice_t *wlandev, hfa384x_usbin_t * usbin);
 
-static void hfa384x_usbin_rx(wlandevice_t * wlandev, struct sk_buff *skb);
+static void hfa384x_usbin_rx(wlandevice_t *wlandev, struct sk_buff *skb);
 
-static void hfa384x_usbin_info(wlandevice_t * wlandev, hfa384x_usbin_t * usbin);
+static void hfa384x_usbin_info(wlandevice_t *wlandev, hfa384x_usbin_t * usbin);
 
 static void
-hfa384x_usbout_tx(wlandevice_t * wlandev, hfa384x_usbout_t * usbout);
+hfa384x_usbout_tx(wlandevice_t *wlandev, hfa384x_usbout_t *usbout);
 
-static void hfa384x_usbin_ctlx(hfa384x_t * hw, hfa384x_usbin_t * usbin,
+static void hfa384x_usbin_ctlx(hfa384x_t *hw, hfa384x_usbin_t *usbin,
 			       int urb_status);
 
 /*---------------------------------------------------*/
 /* Functions to support the prism2 usb command queue */
 
-static void hfa384x_usbctlxq_run(hfa384x_t * hw);
+static void hfa384x_usbctlxq_run(hfa384x_t *hw);
 
 static void hfa384x_usbctlx_reqtimerfn(unsigned long data);
 
@@ -202,9 +202,9 @@ static void hfa384x_usbctlx_completion_task(unsigned long data);
 
 static void hfa384x_usbctlx_reaper_task(unsigned long data);
 
-static int hfa384x_usbctlx_submit(hfa384x_t * hw, hfa384x_usbctlx_t * ctlx);
+static int hfa384x_usbctlx_submit(hfa384x_t *hw, hfa384x_usbctlx_t *ctlx);
 
-static void unlocked_usbctlx_complete(hfa384x_t * hw, hfa384x_usbctlx_t * ctlx);
+static void unlocked_usbctlx_complete(hfa384x_t *hw, hfa384x_usbctlx_t *ctlx);
 
 struct usbctlx_completor {
 	int (*complete) (struct usbctlx_completor *);
@@ -212,35 +212,35 @@ struct usbctlx_completor {
 typedef struct usbctlx_completor usbctlx_completor_t;
 
 static int
-hfa384x_usbctlx_complete_sync(hfa384x_t * hw,
-			      hfa384x_usbctlx_t * ctlx,
-			      usbctlx_completor_t * completor);
+hfa384x_usbctlx_complete_sync(hfa384x_t *hw,
+			      hfa384x_usbctlx_t *ctlx,
+			      usbctlx_completor_t *completor);
 
 static int
-unlocked_usbctlx_cancel_async(hfa384x_t * hw, hfa384x_usbctlx_t * ctlx);
+unlocked_usbctlx_cancel_async(hfa384x_t *hw, hfa384x_usbctlx_t *ctlx);
 
-static void hfa384x_cb_status(hfa384x_t * hw, const hfa384x_usbctlx_t * ctlx);
+static void hfa384x_cb_status(hfa384x_t *hw, const hfa384x_usbctlx_t *ctlx);
 
-static void hfa384x_cb_rrid(hfa384x_t * hw, const hfa384x_usbctlx_t * ctlx);
+static void hfa384x_cb_rrid(hfa384x_t *hw, const hfa384x_usbctlx_t *ctlx);
 
 static int
-usbctlx_get_status(const hfa384x_usb_cmdresp_t * cmdresp,
-		   hfa384x_cmdresult_t * result);
+usbctlx_get_status(const hfa384x_usb_cmdresp_t *cmdresp,
+		   hfa384x_cmdresult_t *result);
 
 static void
-usbctlx_get_rridresult(const hfa384x_usb_rridresp_t * rridresp,
-		       hfa384x_rridresult_t * result);
+usbctlx_get_rridresult(const hfa384x_usb_rridresp_t *rridresp,
+		       hfa384x_rridresult_t *result);
 
 /*---------------------------------------------------*/
 /* Low level req/resp CTLX formatters and submitters */
 static int
-hfa384x_docmd(hfa384x_t * hw,
+hfa384x_docmd(hfa384x_t *hw,
 	      CMD_MODE mode,
-	      hfa384x_metacmd_t * cmd,
+	      hfa384x_metacmd_t *cmd,
 	      ctlx_cmdcb_t cmdcb, ctlx_usercb_t usercb, void *usercb_data);
 
 static int
-hfa384x_dorrid(hfa384x_t * hw,
+hfa384x_dorrid(hfa384x_t *hw,
 	       CMD_MODE mode,
 	       u16 rid,
 	       void *riddata,
@@ -248,7 +248,7 @@ hfa384x_dorrid(hfa384x_t * hw,
 	       ctlx_cmdcb_t cmdcb, ctlx_usercb_t usercb, void *usercb_data);
 
 static int
-hfa384x_dowrid(hfa384x_t * hw,
+hfa384x_dowrid(hfa384x_t *hw,
 	       CMD_MODE mode,
 	       u16 rid,
 	       void *riddata,
@@ -256,7 +256,7 @@ hfa384x_dowrid(hfa384x_t * hw,
 	       ctlx_cmdcb_t cmdcb, ctlx_usercb_t usercb, void *usercb_data);
 
 static int
-hfa384x_dormem(hfa384x_t * hw,
+hfa384x_dormem(hfa384x_t *hw,
 	       CMD_MODE mode,
 	       u16 page,
 	       u16 offset,
@@ -265,7 +265,7 @@ hfa384x_dormem(hfa384x_t * hw,
 	       ctlx_cmdcb_t cmdcb, ctlx_usercb_t usercb, void *usercb_data);
 
 static int
-hfa384x_dowmem(hfa384x_t * hw,
+hfa384x_dowmem(hfa384x_t *hw,
 	       CMD_MODE mode,
 	       u16 page,
 	       u16 offset,
@@ -334,7 +334,7 @@ void dbprint_urb(struct urb *urb)
 * Call context:
 *	Any
 ----------------------------------------------------------------*/
-static int submit_rx_urb(hfa384x_t * hw, gfp_t memflags)
+static int submit_rx_urb(hfa384x_t *hw, gfp_t memflags)
 {
 	struct sk_buff *skb;
 	int result;
@@ -395,7 +395,7 @@ static int submit_rx_urb(hfa384x_t * hw, gfp_t memflags)
 * Call context:
 *	Any
 ----------------------------------------------------------------*/
-static int submit_tx_urb(hfa384x_t * hw, struct urb *tx_urb, gfp_t memflags)
+static int submit_tx_urb(hfa384x_t *hw, struct urb *tx_urb, gfp_t memflags)
 {
 	struct net_device *netdev = hw->wlandev->netdev;
 	int result;
@@ -532,7 +532,7 @@ static void hfa384x_usb_defer(struct work_struct *data)
 * Call context:
 *	process
 ----------------------------------------------------------------*/
-void hfa384x_create(hfa384x_t * hw, struct usb_device *usb)
+void hfa384x_create(hfa384x_t *hw, struct usb_device *usb)
 {
 	memset(hw, 0, sizeof(hfa384x_t));
 	hw->usb = usb;
@@ -608,7 +608,7 @@ void hfa384x_create(hfa384x_t * hw, struct usb_device *usb)
 * Call context:
 *	process
 ----------------------------------------------------------------*/
-void hfa384x_destroy(hfa384x_t * hw)
+void hfa384x_destroy(hfa384x_t *hw)
 {
 	struct sk_buff *skb;
 
@@ -640,8 +640,8 @@ static hfa384x_usbctlx_t *usbctlx_alloc(void)
 }
 
 static int
-usbctlx_get_status(const hfa384x_usb_cmdresp_t * cmdresp,
-		   hfa384x_cmdresult_t * result)
+usbctlx_get_status(const hfa384x_usb_cmdresp_t *cmdresp,
+		   hfa384x_cmdresult_t *result)
 {
 	result->status = le16_to_cpu(cmdresp->status);
 	result->resp0 = le16_to_cpu(cmdresp->resp0);
@@ -656,8 +656,8 @@ usbctlx_get_status(const hfa384x_usb_cmdresp_t * cmdresp,
 }
 
 static void
-usbctlx_get_rridresult(const hfa384x_usb_rridresp_t * rridresp,
-		       hfa384x_rridresult_t * result)
+usbctlx_get_rridresult(const hfa384x_usb_rridresp_t *rridresp,
+		       hfa384x_rridresult_t *result)
 {
 	result->rid = le16_to_cpu(rridresp->rid);
 	result->riddata = rridresp->data;
@@ -712,7 +712,7 @@ struct usbctlx_rrid_completor {
 };
 typedef struct usbctlx_rrid_completor usbctlx_rrid_completor_t;
 
-static int usbctlx_rrid_completor_fn(usbctlx_completor_t * head)
+static int usbctlx_rrid_completor_fn(usbctlx_completor_t *head)
 {
 	usbctlx_rrid_completor_t *complete = (usbctlx_rrid_completor_t *) head;
 	hfa384x_rridresult_t rridresult;
@@ -733,7 +733,7 @@ static int usbctlx_rrid_completor_fn(usbctlx_completor_t * head)
 }
 
 static inline usbctlx_completor_t *init_rrid_completor(usbctlx_rrid_completor_t
-						       * completor,
+						       *completor,
 						       const
 						       hfa384x_usb_rridresp_t *
 						       rridresp, void *riddata,
@@ -773,7 +773,7 @@ struct usbctlx_rmem_completor {
 };
 typedef struct usbctlx_rmem_completor usbctlx_rmem_completor_t;
 
-static int usbctlx_rmem_completor_fn(usbctlx_completor_t * head)
+static int usbctlx_rmem_completor_fn(usbctlx_completor_t *head)
 {
 	usbctlx_rmem_completor_t *complete = (usbctlx_rmem_completor_t *) head;
 
@@ -783,9 +783,9 @@ static int usbctlx_rmem_completor_fn(usbctlx_completor_t * head)
 }
 
 static inline usbctlx_completor_t *init_rmem_completor(usbctlx_rmem_completor_t
-						       * completor,
+						       *completor,
 						       hfa384x_usb_rmemresp_t
-						       * rmemresp, void *data,
+						       *rmemresp, void *data,
 						       unsigned int len)
 {
 	completor->head.complete = usbctlx_rmem_completor_fn;
@@ -816,7 +816,7 @@ static inline usbctlx_completor_t *init_rmem_completor(usbctlx_rmem_completor_t
 * Call context:
 *	interrupt
 ----------------------------------------------------------------*/
-static void hfa384x_cb_status(hfa384x_t * hw, const hfa384x_usbctlx_t * ctlx)
+static void hfa384x_cb_status(hfa384x_t *hw, const hfa384x_usbctlx_t *ctlx)
 {
 	if (ctlx->usercb != NULL) {
 		hfa384x_cmdresult_t cmdresult;
@@ -853,7 +853,7 @@ static void hfa384x_cb_status(hfa384x_t * hw, const hfa384x_usbctlx_t * ctlx)
 * Call context:
 *	interrupt
 ----------------------------------------------------------------*/
-static void hfa384x_cb_rrid(hfa384x_t * hw, const hfa384x_usbctlx_t * ctlx)
+static void hfa384x_cb_rrid(hfa384x_t *hw, const hfa384x_usbctlx_t *ctlx)
 {
 	if (ctlx->usercb != NULL) {
 		hfa384x_rridresult_t rridresult;
@@ -870,21 +870,21 @@ static void hfa384x_cb_rrid(hfa384x_t * hw, const hfa384x_usbctlx_t * ctlx)
 	}
 }
 
-static inline int hfa384x_docmd_wait(hfa384x_t * hw, hfa384x_metacmd_t * cmd)
+static inline int hfa384x_docmd_wait(hfa384x_t *hw, hfa384x_metacmd_t *cmd)
 {
 	return hfa384x_docmd(hw, DOWAIT, cmd, NULL, NULL, NULL);
 }
 
 static inline int
-hfa384x_docmd_async(hfa384x_t * hw,
-		    hfa384x_metacmd_t * cmd,
+hfa384x_docmd_async(hfa384x_t *hw,
+		    hfa384x_metacmd_t *cmd,
 		    ctlx_cmdcb_t cmdcb, ctlx_usercb_t usercb, void *usercb_data)
 {
 	return hfa384x_docmd(hw, DOASYNC, cmd, cmdcb, usercb, usercb_data);
 }
 
 static inline int
-hfa384x_dorrid_wait(hfa384x_t * hw, u16 rid, void *riddata,
+hfa384x_dorrid_wait(hfa384x_t *hw, u16 rid, void *riddata,
 		    unsigned int riddatalen)
 {
 	return hfa384x_dorrid(hw, DOWAIT,
@@ -892,7 +892,7 @@ hfa384x_dorrid_wait(hfa384x_t * hw, u16 rid, void *riddata,
 }
 
 static inline int
-hfa384x_dorrid_async(hfa384x_t * hw,
+hfa384x_dorrid_async(hfa384x_t *hw,
 		     u16 rid, void *riddata, unsigned int riddatalen,
 		     ctlx_cmdcb_t cmdcb,
 		     ctlx_usercb_t usercb, void *usercb_data)
@@ -903,7 +903,7 @@ hfa384x_dorrid_async(hfa384x_t * hw,
 }
 
 static inline int
-hfa384x_dowrid_wait(hfa384x_t * hw, u16 rid, void *riddata,
+hfa384x_dowrid_wait(hfa384x_t *hw, u16 rid, void *riddata,
 		    unsigned int riddatalen)
 {
 	return hfa384x_dowrid(hw, DOWAIT,
@@ -911,7 +911,7 @@ hfa384x_dowrid_wait(hfa384x_t * hw, u16 rid, void *riddata,
 }
 
 static inline int
-hfa384x_dowrid_async(hfa384x_t * hw,
+hfa384x_dowrid_async(hfa384x_t *hw,
 		     u16 rid, void *riddata, unsigned int riddatalen,
 		     ctlx_cmdcb_t cmdcb,
 		     ctlx_usercb_t usercb, void *usercb_data)
@@ -922,7 +922,7 @@ hfa384x_dowrid_async(hfa384x_t * hw,
 }
 
 static inline int
-hfa384x_dormem_wait(hfa384x_t * hw,
+hfa384x_dormem_wait(hfa384x_t *hw,
 		    u16 page, u16 offset, void *data, unsigned int len)
 {
 	return hfa384x_dormem(hw, DOWAIT,
@@ -930,7 +930,7 @@ hfa384x_dormem_wait(hfa384x_t * hw,
 }
 
 static inline int
-hfa384x_dormem_async(hfa384x_t * hw,
+hfa384x_dormem_async(hfa384x_t *hw,
 		     u16 page, u16 offset, void *data, unsigned int len,
 		     ctlx_cmdcb_t cmdcb,
 		     ctlx_usercb_t usercb, void *usercb_data)
@@ -941,7 +941,7 @@ hfa384x_dormem_async(hfa384x_t * hw,
 }
 
 static inline int
-hfa384x_dowmem_wait(hfa384x_t * hw,
+hfa384x_dowmem_wait(hfa384x_t *hw,
 		    u16 page, u16 offset, void *data, unsigned int len)
 {
 	return hfa384x_dowmem(hw, DOWAIT,
@@ -949,7 +949,7 @@ hfa384x_dowmem_wait(hfa384x_t * hw,
 }
 
 static inline int
-hfa384x_dowmem_async(hfa384x_t * hw,
+hfa384x_dowmem_async(hfa384x_t *hw,
 		     u16 page,
 		     u16 offset,
 		     void *data,
@@ -981,7 +981,7 @@ hfa384x_dowmem_async(hfa384x_t * hw,
 * Call context:
 *	process
 ----------------------------------------------------------------*/
-int hfa384x_cmd_initialize(hfa384x_t * hw)
+int hfa384x_cmd_initialize(hfa384x_t *hw)
 {
 	int result = 0;
 	int i;
@@ -1029,7 +1029,7 @@ int hfa384x_cmd_initialize(hfa384x_t * hw)
 * Call context:
 *	process
 ----------------------------------------------------------------*/
-int hfa384x_cmd_disable(hfa384x_t * hw, u16 macport)
+int hfa384x_cmd_disable(hfa384x_t *hw, u16 macport)
 {
 	int result = 0;
 	hfa384x_metacmd_t cmd;
@@ -1065,7 +1065,7 @@ int hfa384x_cmd_disable(hfa384x_t * hw, u16 macport)
 * Call context:
 *	process
 ----------------------------------------------------------------*/
-int hfa384x_cmd_enable(hfa384x_t * hw, u16 macport)
+int hfa384x_cmd_enable(hfa384x_t *hw, u16 macport)
 {
 	int result = 0;
 	hfa384x_metacmd_t cmd;
@@ -1110,7 +1110,7 @@ int hfa384x_cmd_enable(hfa384x_t * hw, u16 macport)
 * Call context:
 *	process
 ----------------------------------------------------------------*/
-int hfa384x_cmd_monitor(hfa384x_t * hw, u16 enable)
+int hfa384x_cmd_monitor(hfa384x_t *hw, u16 enable)
 {
 	int result = 0;
 	hfa384x_metacmd_t cmd;
@@ -1164,7 +1164,7 @@ int hfa384x_cmd_monitor(hfa384x_t * hw, u16 enable)
 * Call context:
 *	process
 ----------------------------------------------------------------*/
-int hfa384x_cmd_download(hfa384x_t * hw, u16 mode, u16 lowaddr,
+int hfa384x_cmd_download(hfa384x_t *hw, u16 mode, u16 lowaddr,
 			 u16 highaddr, u16 codelen)
 {
 	int result = 0;
@@ -1208,7 +1208,7 @@ int hfa384x_cmd_download(hfa384x_t * hw, u16 mode, u16 lowaddr,
 * Call context:
 *	process
 ----------------------------------------------------------------*/
-int hfa384x_corereset(hfa384x_t * hw, int holdtime, int settletime, int genesis)
+int hfa384x_corereset(hfa384x_t *hw, int holdtime, int settletime, int genesis)
 {
 	int result = 0;
 
@@ -1245,9 +1245,9 @@ int hfa384x_corereset(hfa384x_t * hw, int holdtime, int settletime, int genesis)
 * Call context:
 *	process
 ----------------------------------------------------------------*/
-static int hfa384x_usbctlx_complete_sync(hfa384x_t * hw,
-					 hfa384x_usbctlx_t * ctlx,
-					 usbctlx_completor_t * completor)
+static int hfa384x_usbctlx_complete_sync(hfa384x_t *hw,
+					 hfa384x_usbctlx_t *ctlx,
+					 usbctlx_completor_t *completor)
 {
 	unsigned long flags;
 	int result;
@@ -1361,9 +1361,9 @@ static int hfa384x_usbctlx_complete_sync(hfa384x_t * hw,
 *	process
 ----------------------------------------------------------------*/
 static int
-hfa384x_docmd(hfa384x_t * hw,
+hfa384x_docmd(hfa384x_t *hw,
 	      CMD_MODE mode,
-	      hfa384x_metacmd_t * cmd,
+	      hfa384x_metacmd_t *cmd,
 	      ctlx_cmdcb_t cmdcb, ctlx_usercb_t usercb, void *usercb_data)
 {
 	int result;
@@ -1450,7 +1450,7 @@ hfa384x_docmd(hfa384x_t * hw,
 *	process (DOWAIT or DOASYNC)
 ----------------------------------------------------------------*/
 static int
-hfa384x_dorrid(hfa384x_t * hw,
+hfa384x_dorrid(hfa384x_t *hw,
 	       CMD_MODE mode,
 	       u16 rid,
 	       void *riddata,
@@ -1531,7 +1531,7 @@ hfa384x_dorrid(hfa384x_t * hw,
 *	process (DOWAIT or DOASYNC)
 ----------------------------------------------------------------*/
 static int
-hfa384x_dowrid(hfa384x_t * hw,
+hfa384x_dowrid(hfa384x_t *hw,
 	       CMD_MODE mode,
 	       u16 rid,
 	       void *riddata,
@@ -1618,7 +1618,7 @@ hfa384x_dowrid(hfa384x_t * hw,
 *	process (DOWAIT or DOASYNC)
 ----------------------------------------------------------------*/
 static int
-hfa384x_dormem(hfa384x_t * hw,
+hfa384x_dormem(hfa384x_t *hw,
 	       CMD_MODE mode,
 	       u16 page,
 	       u16 offset,
@@ -1709,7 +1709,7 @@ hfa384x_dormem(hfa384x_t * hw,
 *	process (DOWAIT or DOASYNC)
 ----------------------------------------------------------------*/
 static int
-hfa384x_dowmem(hfa384x_t * hw,
+hfa384x_dowmem(hfa384x_t *hw,
 	       CMD_MODE mode,
 	       u16 page,
 	       u16 offset,
@@ -1783,7 +1783,7 @@ hfa384x_dowmem(hfa384x_t * hw,
 * Call context:
 *	process
 ----------------------------------------------------------------*/
-int hfa384x_drvr_commtallies(hfa384x_t * hw)
+int hfa384x_drvr_commtallies(hfa384x_t *hw)
 {
 	hfa384x_metacmd_t cmd;
 
@@ -1819,7 +1819,7 @@ int hfa384x_drvr_commtallies(hfa384x_t * hw)
 * Call context:
 *	process
 ----------------------------------------------------------------*/
-int hfa384x_drvr_disable(hfa384x_t * hw, u16 macport)
+int hfa384x_drvr_disable(hfa384x_t *hw, u16 macport)
 {
 	int result = 0;
 
@@ -1857,7 +1857,7 @@ int hfa384x_drvr_disable(hfa384x_t * hw, u16 macport)
 * Call context:
 *	process
 ----------------------------------------------------------------*/
-int hfa384x_drvr_enable(hfa384x_t * hw, u16 macport)
+int hfa384x_drvr_enable(hfa384x_t *hw, u16 macport)
 {
 	int result = 0;
 
@@ -1894,7 +1894,7 @@ int hfa384x_drvr_enable(hfa384x_t * hw, u16 macport)
 * Call context:
 *	process
 ----------------------------------------------------------------*/
-int hfa384x_drvr_flashdl_enable(hfa384x_t * hw)
+int hfa384x_drvr_flashdl_enable(hfa384x_t *hw)
 {
 	int result = 0;
 	int i;
@@ -1952,7 +1952,7 @@ int hfa384x_drvr_flashdl_enable(hfa384x_t * hw)
 * Call context:
 *	process
 ----------------------------------------------------------------*/
-int hfa384x_drvr_flashdl_disable(hfa384x_t * hw)
+int hfa384x_drvr_flashdl_disable(hfa384x_t *hw)
 {
 	/* Check that we're already in the download state */
 	if (hw->dlstate != HFA384x_DLSTATE_FLASHENABLED)
@@ -1997,7 +1997,7 @@ int hfa384x_drvr_flashdl_disable(hfa384x_t * hw)
 * Call context:
 *	process
 ----------------------------------------------------------------*/
-int hfa384x_drvr_flashdl_write(hfa384x_t * hw, u32 daddr, void *buf, u32 len)
+int hfa384x_drvr_flashdl_write(hfa384x_t *hw, u32 daddr, void *buf, u32 len)
 {
 	int result = 0;
 	u32 dlbufaddr;
@@ -2143,7 +2143,7 @@ int hfa384x_drvr_flashdl_write(hfa384x_t * hw, u32 daddr, void *buf, u32 len)
 * Call context:
 *	process
 ----------------------------------------------------------------*/
-int hfa384x_drvr_getconfig(hfa384x_t * hw, u16 rid, void *buf, u16 len)
+int hfa384x_drvr_getconfig(hfa384x_t *hw, u16 rid, void *buf, u16 len)
 {
 	int result;
 
@@ -2180,7 +2180,7 @@ int hfa384x_drvr_getconfig(hfa384x_t * hw, u16 rid, void *buf, u16 len)
  *       Any
  ----------------------------------------------------------------*/
 int
-hfa384x_drvr_getconfig_async(hfa384x_t * hw,
+hfa384x_drvr_getconfig_async(hfa384x_t *hw,
 			     u16 rid, ctlx_usercb_t usercb, void *usercb_data)
 {
 	return hfa384x_dorrid_async(hw, rid, NULL, 0,
@@ -2211,7 +2211,7 @@ hfa384x_drvr_getconfig_async(hfa384x_t * hw,
  *       process
  ----------------------------------------------------------------*/
 int
-hfa384x_drvr_setconfig_async(hfa384x_t * hw,
+hfa384x_drvr_setconfig_async(hfa384x_t *hw,
 			     u16 rid,
 			     void *buf,
 			     u16 len, ctlx_usercb_t usercb, void *usercb_data)
@@ -2238,7 +2238,7 @@ hfa384x_drvr_setconfig_async(hfa384x_t * hw,
 * Call context:
 *	process
 ----------------------------------------------------------------*/
-int hfa384x_drvr_ramdl_disable(hfa384x_t * hw)
+int hfa384x_drvr_ramdl_disable(hfa384x_t *hw)
 {
 	/* Check that we're already in the download state */
 	if (hw->dlstate != HFA384x_DLSTATE_RAMENABLED)
@@ -2278,7 +2278,7 @@ int hfa384x_drvr_ramdl_disable(hfa384x_t * hw)
 * Call context:
 *	process
 ----------------------------------------------------------------*/
-int hfa384x_drvr_ramdl_enable(hfa384x_t * hw, u32 exeaddr)
+int hfa384x_drvr_ramdl_enable(hfa384x_t *hw, u32 exeaddr)
 {
 	int result = 0;
 	u16 lowaddr;
@@ -2346,7 +2346,7 @@ int hfa384x_drvr_ramdl_enable(hfa384x_t * hw, u32 exeaddr)
 * Call context:
 *	process
 ----------------------------------------------------------------*/
-int hfa384x_drvr_ramdl_write(hfa384x_t * hw, u32 daddr, void *buf, u32 len)
+int hfa384x_drvr_ramdl_write(hfa384x_t *hw, u32 daddr, void *buf, u32 len)
 {
 	int result = 0;
 	int nwrites;
@@ -2425,7 +2425,7 @@ int hfa384x_drvr_ramdl_write(hfa384x_t * hw, u32 daddr, void *buf, u32 len)
 * Call context:
 *	process or non-card interrupt.
 ----------------------------------------------------------------*/
-int hfa384x_drvr_readpda(hfa384x_t * hw, void *buf, unsigned int len)
+int hfa384x_drvr_readpda(hfa384x_t *hw, void *buf, unsigned int len)
 {
 	int result = 0;
 	u16 *pda = buf;
@@ -2531,7 +2531,7 @@ int hfa384x_drvr_readpda(hfa384x_t * hw, void *buf, unsigned int len)
 * Call context:
 *	process
 ----------------------------------------------------------------*/
-int hfa384x_drvr_setconfig(hfa384x_t * hw, u16 rid, void *buf, u16 len)
+int hfa384x_drvr_setconfig(hfa384x_t *hw, u16 rid, void *buf, u16 len)
 {
 	return hfa384x_dowrid_wait(hw, rid, buf, len);
 }
@@ -2556,7 +2556,7 @@ int hfa384x_drvr_setconfig(hfa384x_t * hw, u16 rid, void *buf, u16 len)
 *	process
 ----------------------------------------------------------------*/
 
-int hfa384x_drvr_start(hfa384x_t * hw)
+int hfa384x_drvr_start(hfa384x_t *hw)
 {
 	int result, result1, result2;
 	u16 status;
@@ -2657,7 +2657,7 @@ int hfa384x_drvr_start(hfa384x_t * hw)
 * Call context:
 *	process
 ----------------------------------------------------------------*/
-int hfa384x_drvr_stop(hfa384x_t * hw)
+int hfa384x_drvr_stop(hfa384x_t *hw)
 {
 	int result = 0;
 	int i;
@@ -2708,9 +2708,9 @@ int hfa384x_drvr_stop(hfa384x_t * hw)
 * Call context:
 *	interrupt
 ----------------------------------------------------------------*/
-int hfa384x_drvr_txframe(hfa384x_t * hw, struct sk_buff *skb,
-			 p80211_hdr_t * p80211_hdr,
-			 p80211_metawep_t * p80211_wep)
+int hfa384x_drvr_txframe(hfa384x_t *hw, struct sk_buff *skb,
+			 p80211_hdr_t *p80211_hdr,
+			 p80211_metawep_t *p80211_wep)
 {
 	int usbpktlen = sizeof(hfa384x_tx_frame_t);
 	int result;
@@ -2801,7 +2801,7 @@ int hfa384x_drvr_txframe(hfa384x_t * hw, struct sk_buff *skb,
 	return result;
 }
 
-void hfa384x_tx_timeout(wlandevice_t * wlandev)
+void hfa384x_tx_timeout(wlandevice_t *wlandev)
 {
 	hfa384x_t *hw = wlandev->priv;
 	unsigned long flags;
@@ -2950,8 +2950,8 @@ static void hfa384x_usbctlx_completion_task(unsigned long data)
 * Call context:
 *	Either process or interrupt, but presumably interrupt
 ----------------------------------------------------------------*/
-static int unlocked_usbctlx_cancel_async(hfa384x_t * hw,
-					 hfa384x_usbctlx_t * ctlx)
+static int unlocked_usbctlx_cancel_async(hfa384x_t *hw,
+					 hfa384x_usbctlx_t *ctlx)
 {
 	int ret;
 
@@ -3000,7 +3000,7 @@ static int unlocked_usbctlx_cancel_async(hfa384x_t * hw,
 * Call context:
 *	Either, assume interrupt
 ----------------------------------------------------------------*/
-static void unlocked_usbctlx_complete(hfa384x_t * hw, hfa384x_usbctlx_t * ctlx)
+static void unlocked_usbctlx_complete(hfa384x_t *hw, hfa384x_usbctlx_t *ctlx)
 {
 	/* Timers have been stopped, and ctlx should be in
 	 * a terminal state. Retire it from the "active"
@@ -3038,7 +3038,7 @@ static void unlocked_usbctlx_complete(hfa384x_t * hw, hfa384x_usbctlx_t * ctlx)
 * Call context:
 *	any
 ----------------------------------------------------------------*/
-static void hfa384x_usbctlxq_run(hfa384x_t * hw)
+static void hfa384x_usbctlxq_run(hfa384x_t *hw)
 {
 	unsigned long flags;
 
@@ -3318,7 +3318,7 @@ static void hfa384x_usbin_callback(struct urb *urb)
 * Call context:
 *	interrupt
 ----------------------------------------------------------------*/
-static void hfa384x_usbin_ctlx(hfa384x_t * hw, hfa384x_usbin_t * usbin,
+static void hfa384x_usbin_ctlx(hfa384x_t *hw, hfa384x_usbin_t *usbin,
 			       int urb_status)
 {
 	hfa384x_usbctlx_t *ctlx;
@@ -3439,8 +3439,8 @@ static void hfa384x_usbin_ctlx(hfa384x_t * hw, hfa384x_usbin_t * usbin,
 * Call context:
 *	interrupt
 ----------------------------------------------------------------*/
-static void hfa384x_usbin_txcompl(wlandevice_t * wlandev,
-				  hfa384x_usbin_t * usbin)
+static void hfa384x_usbin_txcompl(wlandevice_t *wlandev,
+				  hfa384x_usbin_t *usbin)
 {
 	u16 status;
 
@@ -3470,7 +3470,7 @@ static void hfa384x_usbin_txcompl(wlandevice_t * wlandev,
 * Call context:
 *	interrupt
 ----------------------------------------------------------------*/
-static void hfa384x_usbin_rx(wlandevice_t * wlandev, struct sk_buff *skb)
+static void hfa384x_usbin_rx(wlandevice_t *wlandev, struct sk_buff *skb)
 {
 	hfa384x_usbin_t *usbin = (hfa384x_usbin_t *) skb->data;
 	hfa384x_t *hw = wlandev->priv;
@@ -3573,8 +3573,8 @@ static void hfa384x_usbin_rx(wlandevice_t * wlandev, struct sk_buff *skb)
 * Call context:
 *	interrupt
 ----------------------------------------------------------------*/
-static void hfa384x_int_rxmonitor(wlandevice_t * wlandev,
-				  hfa384x_usb_rxfrm_t * rxfrm)
+static void hfa384x_int_rxmonitor(wlandevice_t *wlandev,
+				  hfa384x_usb_rxfrm_t *rxfrm)
 {
 	hfa384x_rx_frame_t *rxdesc = &(rxfrm->desc);
 	unsigned int hdrlen = 0;
@@ -3677,7 +3677,7 @@ static void hfa384x_int_rxmonitor(wlandevice_t * wlandev,
 * Call context:
 *	interrupt
 ----------------------------------------------------------------*/
-static void hfa384x_usbin_info(wlandevice_t * wlandev, hfa384x_usbin_t * usbin)
+static void hfa384x_usbin_info(wlandevice_t *wlandev, hfa384x_usbin_t *usbin)
 {
 	usbin->infofrm.info.framelen =
 	    le16_to_cpu(usbin->infofrm.info.framelen);
@@ -4055,7 +4055,7 @@ static void hfa384x_usb_throttlefn(unsigned long data)
 * Call context:
 *	process or interrupt
 ----------------------------------------------------------------*/
-static int hfa384x_usbctlx_submit(hfa384x_t * hw, hfa384x_usbctlx_t * ctlx)
+static int hfa384x_usbctlx_submit(hfa384x_t *hw, hfa384x_usbctlx_t *ctlx)
 {
 	unsigned long flags;
 	int ret;
@@ -4096,7 +4096,7 @@ static int hfa384x_usbctlx_submit(hfa384x_t * hw, hfa384x_usbctlx_t * ctlx)
 * Call context:
 *	interrupt
 ----------------------------------------------------------------*/
-static void hfa384x_usbout_tx(wlandevice_t * wlandev, hfa384x_usbout_t * usbout)
+static void hfa384x_usbout_tx(wlandevice_t *wlandev, hfa384x_usbout_t *usbout)
 {
 	prism2sta_ev_alloc(wlandev);
 }

commit 75f49e07520d036c2a0903694fdc0bcfb5523b76
Author: Mithlesh Thukral <mithlesh@linsyssoft.com>
Date:   Mon May 25 19:06:16 2009 +0530

    Staging: wlan-ng: Lindent cleanups
    
    Lindent script cleanups in wlan-ng driver in the staging tree.
    This is a item in the TODO list.
    
    Signed-off-by: Mithlesh Thukral <mithlesh@linsyssoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/wlan-ng/hfa384x_usb.c b/drivers/staging/wlan-ng/hfa384x_usb.c
index be297b9cac3e..51d9e520d52a 100644
--- a/drivers/staging/wlan-ng/hfa384x_usb.c
+++ b/drivers/staging/wlan-ng/hfa384x_usb.c
@@ -110,7 +110,6 @@
 * --------------------------------------------------------------------
 */
 
-
 #include <linux/module.h>
 #include <linux/kernel.h>
 #include <linux/sched.h>
@@ -161,13 +160,13 @@ static void dbprint_urb(struct urb *urb);
 #endif
 
 static void
-hfa384x_int_rxmonitor(wlandevice_t *wlandev, hfa384x_usb_rxfrm_t *rxfrm);
+hfa384x_int_rxmonitor(wlandevice_t * wlandev, hfa384x_usb_rxfrm_t * rxfrm);
 
 static void hfa384x_usb_defer(struct work_struct *data);
 
-static int submit_rx_urb(hfa384x_t *hw, gfp_t flags);
+static int submit_rx_urb(hfa384x_t * hw, gfp_t flags);
 
-static int submit_tx_urb(hfa384x_t *hw, struct urb *tx_urb, gfp_t flags);
+static int submit_tx_urb(hfa384x_t * hw, struct urb *tx_urb, gfp_t flags);
 
 /*---------------------------------------------------*/
 /* Callbacks */
@@ -176,22 +175,22 @@ static void hfa384x_ctlxout_callback(struct urb *urb);
 static void hfa384x_usbin_callback(struct urb *urb);
 
 static void
-hfa384x_usbin_txcompl(wlandevice_t *wlandev, hfa384x_usbin_t *usbin);
+hfa384x_usbin_txcompl(wlandevice_t * wlandev, hfa384x_usbin_t * usbin);
 
-static void hfa384x_usbin_rx(wlandevice_t *wlandev, struct sk_buff *skb);
+static void hfa384x_usbin_rx(wlandevice_t * wlandev, struct sk_buff *skb);
 
-static void hfa384x_usbin_info(wlandevice_t *wlandev, hfa384x_usbin_t *usbin);
+static void hfa384x_usbin_info(wlandevice_t * wlandev, hfa384x_usbin_t * usbin);
 
 static void
-hfa384x_usbout_tx(wlandevice_t *wlandev, hfa384x_usbout_t *usbout);
+hfa384x_usbout_tx(wlandevice_t * wlandev, hfa384x_usbout_t * usbout);
 
-static void hfa384x_usbin_ctlx(hfa384x_t *hw, hfa384x_usbin_t *usbin,
+static void hfa384x_usbin_ctlx(hfa384x_t * hw, hfa384x_usbin_t * usbin,
 			       int urb_status);
 
 /*---------------------------------------------------*/
 /* Functions to support the prism2 usb command queue */
 
-static void hfa384x_usbctlxq_run(hfa384x_t *hw);
+static void hfa384x_usbctlxq_run(hfa384x_t * hw);
 
 static void hfa384x_usbctlx_reqtimerfn(unsigned long data);
 
@@ -203,9 +202,9 @@ static void hfa384x_usbctlx_completion_task(unsigned long data);
 
 static void hfa384x_usbctlx_reaper_task(unsigned long data);
 
-static int hfa384x_usbctlx_submit(hfa384x_t *hw, hfa384x_usbctlx_t *ctlx);
+static int hfa384x_usbctlx_submit(hfa384x_t * hw, hfa384x_usbctlx_t * ctlx);
 
-static void unlocked_usbctlx_complete(hfa384x_t *hw, hfa384x_usbctlx_t *ctlx);
+static void unlocked_usbctlx_complete(hfa384x_t * hw, hfa384x_usbctlx_t * ctlx);
 
 struct usbctlx_completor {
 	int (*complete) (struct usbctlx_completor *);
@@ -213,35 +212,35 @@ struct usbctlx_completor {
 typedef struct usbctlx_completor usbctlx_completor_t;
 
 static int
-hfa384x_usbctlx_complete_sync(hfa384x_t *hw,
-			      hfa384x_usbctlx_t *ctlx,
-			      usbctlx_completor_t *completor);
+hfa384x_usbctlx_complete_sync(hfa384x_t * hw,
+			      hfa384x_usbctlx_t * ctlx,
+			      usbctlx_completor_t * completor);
 
 static int
-unlocked_usbctlx_cancel_async(hfa384x_t *hw, hfa384x_usbctlx_t *ctlx);
+unlocked_usbctlx_cancel_async(hfa384x_t * hw, hfa384x_usbctlx_t * ctlx);
 
-static void hfa384x_cb_status(hfa384x_t *hw, const hfa384x_usbctlx_t *ctlx);
+static void hfa384x_cb_status(hfa384x_t * hw, const hfa384x_usbctlx_t * ctlx);
 
-static void hfa384x_cb_rrid(hfa384x_t *hw, const hfa384x_usbctlx_t *ctlx);
+static void hfa384x_cb_rrid(hfa384x_t * hw, const hfa384x_usbctlx_t * ctlx);
 
 static int
-usbctlx_get_status(const hfa384x_usb_cmdresp_t *cmdresp,
-		   hfa384x_cmdresult_t *result);
+usbctlx_get_status(const hfa384x_usb_cmdresp_t * cmdresp,
+		   hfa384x_cmdresult_t * result);
 
 static void
-usbctlx_get_rridresult(const hfa384x_usb_rridresp_t *rridresp,
-		       hfa384x_rridresult_t *result);
+usbctlx_get_rridresult(const hfa384x_usb_rridresp_t * rridresp,
+		       hfa384x_rridresult_t * result);
 
 /*---------------------------------------------------*/
 /* Low level req/resp CTLX formatters and submitters */
 static int
-hfa384x_docmd(hfa384x_t *hw,
+hfa384x_docmd(hfa384x_t * hw,
 	      CMD_MODE mode,
-	      hfa384x_metacmd_t *cmd,
+	      hfa384x_metacmd_t * cmd,
 	      ctlx_cmdcb_t cmdcb, ctlx_usercb_t usercb, void *usercb_data);
 
 static int
-hfa384x_dorrid(hfa384x_t *hw,
+hfa384x_dorrid(hfa384x_t * hw,
 	       CMD_MODE mode,
 	       u16 rid,
 	       void *riddata,
@@ -249,7 +248,7 @@ hfa384x_dorrid(hfa384x_t *hw,
 	       ctlx_cmdcb_t cmdcb, ctlx_usercb_t usercb, void *usercb_data);
 
 static int
-hfa384x_dowrid(hfa384x_t *hw,
+hfa384x_dowrid(hfa384x_t * hw,
 	       CMD_MODE mode,
 	       u16 rid,
 	       void *riddata,
@@ -257,7 +256,7 @@ hfa384x_dowrid(hfa384x_t *hw,
 	       ctlx_cmdcb_t cmdcb, ctlx_usercb_t usercb, void *usercb_data);
 
 static int
-hfa384x_dormem(hfa384x_t *hw,
+hfa384x_dormem(hfa384x_t * hw,
 	       CMD_MODE mode,
 	       u16 page,
 	       u16 offset,
@@ -266,7 +265,7 @@ hfa384x_dormem(hfa384x_t *hw,
 	       ctlx_cmdcb_t cmdcb, ctlx_usercb_t usercb, void *usercb_data);
 
 static int
-hfa384x_dowmem(hfa384x_t *hw,
+hfa384x_dowmem(hfa384x_t * hw,
 	       CMD_MODE mode,
 	       u16 page,
 	       u16 offset,
@@ -291,7 +290,7 @@ static inline const char *ctlxstr(CTLX_STATE s)
 	return ctlx_str[s];
 };
 
-static inline hfa384x_usbctlx_t *get_active_ctlx(hfa384x_t *hw)
+static inline hfa384x_usbctlx_t *get_active_ctlx(hfa384x_t * hw)
 {
 	return list_entry(hw->ctlxq.active.next, hfa384x_usbctlx_t, list);
 }
@@ -303,21 +302,19 @@ void dbprint_urb(struct urb *urb)
 	pr_debug("urb->status=0x%08x\n", urb->status);
 	pr_debug("urb->transfer_flags=0x%08x\n", urb->transfer_flags);
 	pr_debug("urb->transfer_buffer=0x%08x\n",
-	       (unsigned int)urb->transfer_buffer);
+		 (unsigned int)urb->transfer_buffer);
 	pr_debug("urb->transfer_buffer_length=0x%08x\n",
-	       urb->transfer_buffer_length);
+		 urb->transfer_buffer_length);
 	pr_debug("urb->actual_length=0x%08x\n", urb->actual_length);
 	pr_debug("urb->bandwidth=0x%08x\n", urb->bandwidth);
 	pr_debug("urb->setup_packet(ctl)=0x%08x\n",
-	       (unsigned int)urb->setup_packet);
-	pr_debug("urb->start_frame(iso/irq)=0x%08x\n",
-	       urb->start_frame);
+		 (unsigned int)urb->setup_packet);
+	pr_debug("urb->start_frame(iso/irq)=0x%08x\n", urb->start_frame);
 	pr_debug("urb->interval(irq)=0x%08x\n", urb->interval);
 	pr_debug("urb->error_count(iso)=0x%08x\n", urb->error_count);
 	pr_debug("urb->timeout=0x%08x\n", urb->timeout);
 	pr_debug("urb->context=0x%08x\n", (unsigned int)urb->context);
-	pr_debug("urb->complete=0x%08x\n",
-	       (unsigned int)urb->complete);
+	pr_debug("urb->complete=0x%08x\n", (unsigned int)urb->complete);
 }
 #endif
 
@@ -337,7 +334,7 @@ void dbprint_urb(struct urb *urb)
 * Call context:
 *	Any
 ----------------------------------------------------------------*/
-static int submit_rx_urb(hfa384x_t *hw, gfp_t memflags)
+static int submit_rx_urb(hfa384x_t * hw, gfp_t memflags)
 {
 	struct sk_buff *skb;
 	int result;
@@ -398,7 +395,7 @@ static int submit_rx_urb(hfa384x_t *hw, gfp_t memflags)
 * Call context:
 *	Any
 ----------------------------------------------------------------*/
-static int submit_tx_urb(hfa384x_t *hw, struct urb *tx_urb, gfp_t memflags)
+static int submit_tx_urb(hfa384x_t * hw, struct urb *tx_urb, gfp_t memflags)
 {
 	struct net_device *netdev = hw->wlandev->netdev;
 	int result;
@@ -535,7 +532,7 @@ static void hfa384x_usb_defer(struct work_struct *data)
 * Call context:
 *	process
 ----------------------------------------------------------------*/
-void hfa384x_create(hfa384x_t *hw, struct usb_device *usb)
+void hfa384x_create(hfa384x_t * hw, struct usb_device *usb)
 {
 	memset(hw, 0, sizeof(hfa384x_t));
 	hw->usb = usb;
@@ -611,7 +608,7 @@ void hfa384x_create(hfa384x_t *hw, struct usb_device *usb)
 * Call context:
 *	process
 ----------------------------------------------------------------*/
-void hfa384x_destroy(hfa384x_t *hw)
+void hfa384x_destroy(hfa384x_t * hw)
 {
 	struct sk_buff *skb;
 
@@ -633,7 +630,7 @@ static hfa384x_usbctlx_t *usbctlx_alloc(void)
 {
 	hfa384x_usbctlx_t *ctlx;
 
-	ctlx = kmalloc(sizeof(*ctlx), in_interrupt() ? GFP_ATOMIC : GFP_KERNEL);
+	ctlx = kmalloc(sizeof(*ctlx), in_interrupt()? GFP_ATOMIC : GFP_KERNEL);
 	if (ctlx != NULL) {
 		memset(ctlx, 0, sizeof(*ctlx));
 		init_completion(&ctlx->done);
@@ -643,8 +640,8 @@ static hfa384x_usbctlx_t *usbctlx_alloc(void)
 }
 
 static int
-usbctlx_get_status(const hfa384x_usb_cmdresp_t *cmdresp,
-		   hfa384x_cmdresult_t *result)
+usbctlx_get_status(const hfa384x_usb_cmdresp_t * cmdresp,
+		   hfa384x_cmdresult_t * result)
 {
 	result->status = le16_to_cpu(cmdresp->status);
 	result->resp0 = le16_to_cpu(cmdresp->resp0);
@@ -652,15 +649,15 @@ usbctlx_get_status(const hfa384x_usb_cmdresp_t *cmdresp,
 	result->resp2 = le16_to_cpu(cmdresp->resp2);
 
 	pr_debug("cmdresult:status=0x%04x "
-	       "resp0=0x%04x resp1=0x%04x resp2=0x%04x\n",
-	       result->status, result->resp0, result->resp1, result->resp2);
+		 "resp0=0x%04x resp1=0x%04x resp2=0x%04x\n",
+		 result->status, result->resp0, result->resp1, result->resp2);
 
 	return result->status & HFA384x_STATUS_RESULT;
 }
 
 static void
-usbctlx_get_rridresult(const hfa384x_usb_rridresp_t *rridresp,
-		       hfa384x_rridresult_t *result)
+usbctlx_get_rridresult(const hfa384x_usb_rridresp_t * rridresp,
+		       hfa384x_rridresult_t * result)
 {
 	result->rid = le16_to_cpu(rridresp->rid);
 	result->riddata = rridresp->data;
@@ -681,7 +678,7 @@ struct usbctlx_cmd_completor {
 };
 typedef struct usbctlx_cmd_completor usbctlx_cmd_completor_t;
 
-static int usbctlx_cmd_completor_fn(usbctlx_completor_t *head)
+static int usbctlx_cmd_completor_fn(usbctlx_completor_t * head)
 {
 	usbctlx_cmd_completor_t *complete = (usbctlx_cmd_completor_t *) head;
 	return usbctlx_get_status(complete->cmdresp, complete->result);
@@ -715,7 +712,7 @@ struct usbctlx_rrid_completor {
 };
 typedef struct usbctlx_rrid_completor usbctlx_rrid_completor_t;
 
-static int usbctlx_rrid_completor_fn(usbctlx_completor_t *head)
+static int usbctlx_rrid_completor_fn(usbctlx_completor_t * head)
 {
 	usbctlx_rrid_completor_t *complete = (usbctlx_rrid_completor_t *) head;
 	hfa384x_rridresult_t rridresult;
@@ -736,7 +733,7 @@ static int usbctlx_rrid_completor_fn(usbctlx_completor_t *head)
 }
 
 static inline usbctlx_completor_t *init_rrid_completor(usbctlx_rrid_completor_t
-						       *completor,
+						       * completor,
 						       const
 						       hfa384x_usb_rridresp_t *
 						       rridresp, void *riddata,
@@ -776,7 +773,7 @@ struct usbctlx_rmem_completor {
 };
 typedef struct usbctlx_rmem_completor usbctlx_rmem_completor_t;
 
-static int usbctlx_rmem_completor_fn(usbctlx_completor_t *head)
+static int usbctlx_rmem_completor_fn(usbctlx_completor_t * head)
 {
 	usbctlx_rmem_completor_t *complete = (usbctlx_rmem_completor_t *) head;
 
@@ -786,9 +783,9 @@ static int usbctlx_rmem_completor_fn(usbctlx_completor_t *head)
 }
 
 static inline usbctlx_completor_t *init_rmem_completor(usbctlx_rmem_completor_t
-						       *completor,
+						       * completor,
 						       hfa384x_usb_rmemresp_t
-                                                       *rmemresp, void *data,
+						       * rmemresp, void *data,
 						       unsigned int len)
 {
 	completor->head.complete = usbctlx_rmem_completor_fn;
@@ -819,7 +816,7 @@ static inline usbctlx_completor_t *init_rmem_completor(usbctlx_rmem_completor_t
 * Call context:
 *	interrupt
 ----------------------------------------------------------------*/
-static void hfa384x_cb_status(hfa384x_t *hw, const hfa384x_usbctlx_t *ctlx)
+static void hfa384x_cb_status(hfa384x_t * hw, const hfa384x_usbctlx_t * ctlx)
 {
 	if (ctlx->usercb != NULL) {
 		hfa384x_cmdresult_t cmdresult;
@@ -856,15 +853,14 @@ static void hfa384x_cb_status(hfa384x_t *hw, const hfa384x_usbctlx_t *ctlx)
 * Call context:
 *	interrupt
 ----------------------------------------------------------------*/
-static void hfa384x_cb_rrid(hfa384x_t *hw, const hfa384x_usbctlx_t *ctlx)
+static void hfa384x_cb_rrid(hfa384x_t * hw, const hfa384x_usbctlx_t * ctlx)
 {
 	if (ctlx->usercb != NULL) {
 		hfa384x_rridresult_t rridresult;
 
 		if (ctlx->state != CTLX_COMPLETE) {
 			memset(&rridresult, 0, sizeof(rridresult));
-			rridresult.rid =
-			    le16_to_cpu(ctlx->outbuf.rridreq.rid);
+			rridresult.rid = le16_to_cpu(ctlx->outbuf.rridreq.rid);
 		} else {
 			usbctlx_get_rridresult(&ctlx->inbuf.rridresp,
 					       &rridresult);
@@ -874,21 +870,21 @@ static void hfa384x_cb_rrid(hfa384x_t *hw, const hfa384x_usbctlx_t *ctlx)
 	}
 }
 
-static inline int hfa384x_docmd_wait(hfa384x_t *hw, hfa384x_metacmd_t *cmd)
+static inline int hfa384x_docmd_wait(hfa384x_t * hw, hfa384x_metacmd_t * cmd)
 {
 	return hfa384x_docmd(hw, DOWAIT, cmd, NULL, NULL, NULL);
 }
 
 static inline int
-hfa384x_docmd_async(hfa384x_t *hw,
-		    hfa384x_metacmd_t *cmd,
+hfa384x_docmd_async(hfa384x_t * hw,
+		    hfa384x_metacmd_t * cmd,
 		    ctlx_cmdcb_t cmdcb, ctlx_usercb_t usercb, void *usercb_data)
 {
 	return hfa384x_docmd(hw, DOASYNC, cmd, cmdcb, usercb, usercb_data);
 }
 
 static inline int
-hfa384x_dorrid_wait(hfa384x_t *hw, u16 rid, void *riddata,
+hfa384x_dorrid_wait(hfa384x_t * hw, u16 rid, void *riddata,
 		    unsigned int riddatalen)
 {
 	return hfa384x_dorrid(hw, DOWAIT,
@@ -896,7 +892,7 @@ hfa384x_dorrid_wait(hfa384x_t *hw, u16 rid, void *riddata,
 }
 
 static inline int
-hfa384x_dorrid_async(hfa384x_t *hw,
+hfa384x_dorrid_async(hfa384x_t * hw,
 		     u16 rid, void *riddata, unsigned int riddatalen,
 		     ctlx_cmdcb_t cmdcb,
 		     ctlx_usercb_t usercb, void *usercb_data)
@@ -907,7 +903,7 @@ hfa384x_dorrid_async(hfa384x_t *hw,
 }
 
 static inline int
-hfa384x_dowrid_wait(hfa384x_t *hw, u16 rid, void *riddata,
+hfa384x_dowrid_wait(hfa384x_t * hw, u16 rid, void *riddata,
 		    unsigned int riddatalen)
 {
 	return hfa384x_dowrid(hw, DOWAIT,
@@ -915,7 +911,7 @@ hfa384x_dowrid_wait(hfa384x_t *hw, u16 rid, void *riddata,
 }
 
 static inline int
-hfa384x_dowrid_async(hfa384x_t *hw,
+hfa384x_dowrid_async(hfa384x_t * hw,
 		     u16 rid, void *riddata, unsigned int riddatalen,
 		     ctlx_cmdcb_t cmdcb,
 		     ctlx_usercb_t usercb, void *usercb_data)
@@ -926,7 +922,7 @@ hfa384x_dowrid_async(hfa384x_t *hw,
 }
 
 static inline int
-hfa384x_dormem_wait(hfa384x_t *hw,
+hfa384x_dormem_wait(hfa384x_t * hw,
 		    u16 page, u16 offset, void *data, unsigned int len)
 {
 	return hfa384x_dormem(hw, DOWAIT,
@@ -934,7 +930,7 @@ hfa384x_dormem_wait(hfa384x_t *hw,
 }
 
 static inline int
-hfa384x_dormem_async(hfa384x_t *hw,
+hfa384x_dormem_async(hfa384x_t * hw,
 		     u16 page, u16 offset, void *data, unsigned int len,
 		     ctlx_cmdcb_t cmdcb,
 		     ctlx_usercb_t usercb, void *usercb_data)
@@ -945,7 +941,7 @@ hfa384x_dormem_async(hfa384x_t *hw,
 }
 
 static inline int
-hfa384x_dowmem_wait(hfa384x_t *hw,
+hfa384x_dowmem_wait(hfa384x_t * hw,
 		    u16 page, u16 offset, void *data, unsigned int len)
 {
 	return hfa384x_dowmem(hw, DOWAIT,
@@ -953,7 +949,7 @@ hfa384x_dowmem_wait(hfa384x_t *hw,
 }
 
 static inline int
-hfa384x_dowmem_async(hfa384x_t *hw,
+hfa384x_dowmem_async(hfa384x_t * hw,
 		     u16 page,
 		     u16 offset,
 		     void *data,
@@ -985,7 +981,7 @@ hfa384x_dowmem_async(hfa384x_t *hw,
 * Call context:
 *	process
 ----------------------------------------------------------------*/
-int hfa384x_cmd_initialize(hfa384x_t *hw)
+int hfa384x_cmd_initialize(hfa384x_t * hw)
 {
 	int result = 0;
 	int i;
@@ -999,10 +995,10 @@ int hfa384x_cmd_initialize(hfa384x_t *hw)
 	result = hfa384x_docmd_wait(hw, &cmd);
 
 	pr_debug("cmdresp.init: "
-	       "status=0x%04x, resp0=0x%04x, "
-	       "resp1=0x%04x, resp2=0x%04x\n",
-	       cmd.result.status,
-	       cmd.result.resp0, cmd.result.resp1, cmd.result.resp2);
+		 "status=0x%04x, resp0=0x%04x, "
+		 "resp1=0x%04x, resp2=0x%04x\n",
+		 cmd.result.status,
+		 cmd.result.resp0, cmd.result.resp1, cmd.result.resp2);
 	if (result == 0) {
 		for (i = 0; i < HFA384x_NUMPORTS_MAX; i++)
 			hw->port_enabled[i] = 0;
@@ -1033,7 +1029,7 @@ int hfa384x_cmd_initialize(hfa384x_t *hw)
 * Call context:
 *	process
 ----------------------------------------------------------------*/
-int hfa384x_cmd_disable(hfa384x_t *hw, u16 macport)
+int hfa384x_cmd_disable(hfa384x_t * hw, u16 macport)
 {
 	int result = 0;
 	hfa384x_metacmd_t cmd;
@@ -1069,7 +1065,7 @@ int hfa384x_cmd_disable(hfa384x_t *hw, u16 macport)
 * Call context:
 *	process
 ----------------------------------------------------------------*/
-int hfa384x_cmd_enable(hfa384x_t *hw, u16 macport)
+int hfa384x_cmd_enable(hfa384x_t * hw, u16 macport)
 {
 	int result = 0;
 	hfa384x_metacmd_t cmd;
@@ -1114,7 +1110,7 @@ int hfa384x_cmd_enable(hfa384x_t *hw, u16 macport)
 * Call context:
 *	process
 ----------------------------------------------------------------*/
-int hfa384x_cmd_monitor(hfa384x_t *hw, u16 enable)
+int hfa384x_cmd_monitor(hfa384x_t * hw, u16 enable)
 {
 	int result = 0;
 	hfa384x_metacmd_t cmd;
@@ -1168,15 +1164,14 @@ int hfa384x_cmd_monitor(hfa384x_t *hw, u16 enable)
 * Call context:
 *	process
 ----------------------------------------------------------------*/
-int hfa384x_cmd_download(hfa384x_t *hw, u16 mode, u16 lowaddr,
+int hfa384x_cmd_download(hfa384x_t * hw, u16 mode, u16 lowaddr,
 			 u16 highaddr, u16 codelen)
 {
 	int result = 0;
 	hfa384x_metacmd_t cmd;
 
-	pr_debug(
-	       "mode=%d, lowaddr=0x%04x, highaddr=0x%04x, codelen=%d\n",
-	       mode, lowaddr, highaddr, codelen);
+	pr_debug("mode=%d, lowaddr=0x%04x, highaddr=0x%04x, codelen=%d\n",
+		 mode, lowaddr, highaddr, codelen);
 
 	cmd.cmd = (HFA384x_CMD_CMDCODE_SET(HFA384x_CMDCODE_DOWNLD) |
 		   HFA384x_CMD_PROGMODE_SET(mode));
@@ -1213,7 +1208,7 @@ int hfa384x_cmd_download(hfa384x_t *hw, u16 mode, u16 lowaddr,
 * Call context:
 *	process
 ----------------------------------------------------------------*/
-int hfa384x_corereset(hfa384x_t *hw, int holdtime, int settletime, int genesis)
+int hfa384x_corereset(hfa384x_t * hw, int holdtime, int settletime, int genesis)
 {
 	int result = 0;
 
@@ -1250,9 +1245,9 @@ int hfa384x_corereset(hfa384x_t *hw, int holdtime, int settletime, int genesis)
 * Call context:
 *	process
 ----------------------------------------------------------------*/
-static int hfa384x_usbctlx_complete_sync(hfa384x_t *hw,
-					 hfa384x_usbctlx_t *ctlx,
-					 usbctlx_completor_t *completor)
+static int hfa384x_usbctlx_complete_sync(hfa384x_t * hw,
+					 hfa384x_usbctlx_t * ctlx,
+					 usbctlx_completor_t * completor)
 {
 	unsigned long flags;
 	int result;
@@ -1366,9 +1361,9 @@ static int hfa384x_usbctlx_complete_sync(hfa384x_t *hw,
 *	process
 ----------------------------------------------------------------*/
 static int
-hfa384x_docmd(hfa384x_t *hw,
+hfa384x_docmd(hfa384x_t * hw,
 	      CMD_MODE mode,
-	      hfa384x_metacmd_t *cmd,
+	      hfa384x_metacmd_t * cmd,
 	      ctlx_cmdcb_t cmdcb, ctlx_usercb_t usercb, void *usercb_data)
 {
 	int result;
@@ -1390,8 +1385,8 @@ hfa384x_docmd(hfa384x_t *hw,
 	ctlx->outbufsize = sizeof(ctlx->outbuf.cmdreq);
 
 	pr_debug("cmdreq: cmd=0x%04x "
-	       "parm0=0x%04x parm1=0x%04x parm2=0x%04x\n",
-	       cmd->cmd, cmd->parm0, cmd->parm1, cmd->parm2);
+		 "parm0=0x%04x parm1=0x%04x parm2=0x%04x\n",
+		 cmd->cmd, cmd->parm0, cmd->parm1, cmd->parm2);
 
 	ctlx->reapable = mode;
 	ctlx->cmdcb = cmdcb;
@@ -1455,7 +1450,7 @@ hfa384x_docmd(hfa384x_t *hw,
 *	process (DOWAIT or DOASYNC)
 ----------------------------------------------------------------*/
 static int
-hfa384x_dorrid(hfa384x_t *hw,
+hfa384x_dorrid(hfa384x_t * hw,
 	       CMD_MODE mode,
 	       u16 rid,
 	       void *riddata,
@@ -1536,7 +1531,7 @@ hfa384x_dorrid(hfa384x_t *hw,
 *	process (DOWAIT or DOASYNC)
 ----------------------------------------------------------------*/
 static int
-hfa384x_dowrid(hfa384x_t *hw,
+hfa384x_dowrid(hfa384x_t * hw,
 	       CMD_MODE mode,
 	       u16 rid,
 	       void *riddata,
@@ -1555,9 +1550,8 @@ hfa384x_dowrid(hfa384x_t *hw,
 	/* Initialize the command */
 	ctlx->outbuf.wridreq.type = cpu_to_le16(HFA384x_USB_WRIDREQ);
 	ctlx->outbuf.wridreq.frmlen = cpu_to_le16((sizeof
-						       (ctlx->outbuf.wridreq.
-							rid) + riddatalen +
-						       1) / 2);
+						   (ctlx->outbuf.wridreq.rid) +
+						   riddatalen + 1) / 2);
 	ctlx->outbuf.wridreq.rid = cpu_to_le16(rid);
 	memcpy(ctlx->outbuf.wridreq.data, riddata, riddatalen);
 
@@ -1624,7 +1618,7 @@ hfa384x_dowrid(hfa384x_t *hw,
 *	process (DOWAIT or DOASYNC)
 ----------------------------------------------------------------*/
 static int
-hfa384x_dormem(hfa384x_t *hw,
+hfa384x_dormem(hfa384x_t * hw,
 	       CMD_MODE mode,
 	       u16 page,
 	       u16 offset,
@@ -1645,20 +1639,18 @@ hfa384x_dormem(hfa384x_t *hw,
 	ctlx->outbuf.rmemreq.type = cpu_to_le16(HFA384x_USB_RMEMREQ);
 	ctlx->outbuf.rmemreq.frmlen =
 	    cpu_to_le16(sizeof(ctlx->outbuf.rmemreq.offset) +
-			    sizeof(ctlx->outbuf.rmemreq.page) + len);
+			sizeof(ctlx->outbuf.rmemreq.page) + len);
 	ctlx->outbuf.rmemreq.offset = cpu_to_le16(offset);
 	ctlx->outbuf.rmemreq.page = cpu_to_le16(page);
 
 	ctlx->outbufsize = sizeof(ctlx->outbuf.rmemreq);
 
-	pr_debug(
-	       "type=0x%04x frmlen=%d offset=0x%04x page=0x%04x\n",
-	       ctlx->outbuf.rmemreq.type,
-	       ctlx->outbuf.rmemreq.frmlen,
-	       ctlx->outbuf.rmemreq.offset, ctlx->outbuf.rmemreq.page);
+	pr_debug("type=0x%04x frmlen=%d offset=0x%04x page=0x%04x\n",
+		 ctlx->outbuf.rmemreq.type,
+		 ctlx->outbuf.rmemreq.frmlen,
+		 ctlx->outbuf.rmemreq.offset, ctlx->outbuf.rmemreq.page);
 
-	pr_debug("pktsize=%zd\n",
-	       ROUNDUP64(sizeof(ctlx->outbuf.rmemreq)));
+	pr_debug("pktsize=%zd\n", ROUNDUP64(sizeof(ctlx->outbuf.rmemreq)));
 
 	ctlx->reapable = mode;
 	ctlx->cmdcb = cmdcb;
@@ -1717,7 +1709,7 @@ hfa384x_dormem(hfa384x_t *hw,
 *	process (DOWAIT or DOASYNC)
 ----------------------------------------------------------------*/
 static int
-hfa384x_dowmem(hfa384x_t *hw,
+hfa384x_dowmem(hfa384x_t * hw,
 	       CMD_MODE mode,
 	       u16 page,
 	       u16 offset,
@@ -1728,8 +1720,7 @@ hfa384x_dowmem(hfa384x_t *hw,
 	int result;
 	hfa384x_usbctlx_t *ctlx;
 
-	pr_debug("page=0x%04x offset=0x%04x len=%d\n",
-	       page, offset, len);
+	pr_debug("page=0x%04x offset=0x%04x len=%d\n", page, offset, len);
 
 	ctlx = usbctlx_alloc();
 	if (ctlx == NULL) {
@@ -1741,7 +1732,7 @@ hfa384x_dowmem(hfa384x_t *hw,
 	ctlx->outbuf.wmemreq.type = cpu_to_le16(HFA384x_USB_WMEMREQ);
 	ctlx->outbuf.wmemreq.frmlen =
 	    cpu_to_le16(sizeof(ctlx->outbuf.wmemreq.offset) +
-			    sizeof(ctlx->outbuf.wmemreq.page) + len);
+			sizeof(ctlx->outbuf.wmemreq.page) + len);
 	ctlx->outbuf.wmemreq.offset = cpu_to_le16(offset);
 	ctlx->outbuf.wmemreq.page = cpu_to_le16(page);
 	memcpy(ctlx->outbuf.wmemreq.data, data, len);
@@ -1792,7 +1783,7 @@ hfa384x_dowmem(hfa384x_t *hw,
 * Call context:
 *	process
 ----------------------------------------------------------------*/
-int hfa384x_drvr_commtallies(hfa384x_t *hw)
+int hfa384x_drvr_commtallies(hfa384x_t * hw)
 {
 	hfa384x_metacmd_t cmd;
 
@@ -1828,7 +1819,7 @@ int hfa384x_drvr_commtallies(hfa384x_t *hw)
 * Call context:
 *	process
 ----------------------------------------------------------------*/
-int hfa384x_drvr_disable(hfa384x_t *hw, u16 macport)
+int hfa384x_drvr_disable(hfa384x_t * hw, u16 macport)
 {
 	int result = 0;
 
@@ -1866,7 +1857,7 @@ int hfa384x_drvr_disable(hfa384x_t *hw, u16 macport)
 * Call context:
 *	process
 ----------------------------------------------------------------*/
-int hfa384x_drvr_enable(hfa384x_t *hw, u16 macport)
+int hfa384x_drvr_enable(hfa384x_t * hw, u16 macport)
 {
 	int result = 0;
 
@@ -1903,7 +1894,7 @@ int hfa384x_drvr_enable(hfa384x_t *hw, u16 macport)
 * Call context:
 *	process
 ----------------------------------------------------------------*/
-int hfa384x_drvr_flashdl_enable(hfa384x_t *hw)
+int hfa384x_drvr_flashdl_enable(hfa384x_t * hw)
 {
 	int result = 0;
 	int i;
@@ -1961,7 +1952,7 @@ int hfa384x_drvr_flashdl_enable(hfa384x_t *hw)
 * Call context:
 *	process
 ----------------------------------------------------------------*/
-int hfa384x_drvr_flashdl_disable(hfa384x_t *hw)
+int hfa384x_drvr_flashdl_disable(hfa384x_t * hw)
 {
 	/* Check that we're already in the download state */
 	if (hw->dlstate != HFA384x_DLSTATE_FLASHENABLED)
@@ -2006,7 +1997,7 @@ int hfa384x_drvr_flashdl_disable(hfa384x_t *hw)
 * Call context:
 *	process
 ----------------------------------------------------------------*/
-int hfa384x_drvr_flashdl_write(hfa384x_t *hw, u32 daddr, void *buf, u32 len)
+int hfa384x_drvr_flashdl_write(hfa384x_t * hw, u32 daddr, void *buf, u32 len)
 {
 	int result = 0;
 	u32 dlbufaddr;
@@ -2035,9 +2026,8 @@ int hfa384x_drvr_flashdl_write(hfa384x_t *hw, u32 daddr, void *buf, u32 len)
 	/* NOTE: dlbuffer RID stores the address in AUX format */
 	dlbufaddr =
 	    HFA384x_ADDR_AUX_MKFLAT(hw->bufinfo.page, hw->bufinfo.offset);
-	pr_debug(
-	       "dlbuf.page=0x%04x dlbuf.offset=0x%04x dlbufaddr=0x%08x\n",
-	       hw->bufinfo.page, hw->bufinfo.offset, dlbufaddr);
+	pr_debug("dlbuf.page=0x%04x dlbuf.offset=0x%04x dlbufaddr=0x%08x\n",
+		 hw->bufinfo.page, hw->bufinfo.offset, dlbufaddr);
 
 #if 0
 	printk(KERN_WARNING "dlbuf@0x%06lx len=%d to=%d\n", dlbufaddr,
@@ -2153,7 +2143,7 @@ int hfa384x_drvr_flashdl_write(hfa384x_t *hw, u32 daddr, void *buf, u32 len)
 * Call context:
 *	process
 ----------------------------------------------------------------*/
-int hfa384x_drvr_getconfig(hfa384x_t *hw, u16 rid, void *buf, u16 len)
+int hfa384x_drvr_getconfig(hfa384x_t * hw, u16 rid, void *buf, u16 len)
 {
 	int result;
 
@@ -2190,7 +2180,7 @@ int hfa384x_drvr_getconfig(hfa384x_t *hw, u16 rid, void *buf, u16 len)
  *       Any
  ----------------------------------------------------------------*/
 int
-hfa384x_drvr_getconfig_async(hfa384x_t *hw,
+hfa384x_drvr_getconfig_async(hfa384x_t * hw,
 			     u16 rid, ctlx_usercb_t usercb, void *usercb_data)
 {
 	return hfa384x_dorrid_async(hw, rid, NULL, 0,
@@ -2221,7 +2211,7 @@ hfa384x_drvr_getconfig_async(hfa384x_t *hw,
  *       process
  ----------------------------------------------------------------*/
 int
-hfa384x_drvr_setconfig_async(hfa384x_t *hw,
+hfa384x_drvr_setconfig_async(hfa384x_t * hw,
 			     u16 rid,
 			     void *buf,
 			     u16 len, ctlx_usercb_t usercb, void *usercb_data)
@@ -2248,7 +2238,7 @@ hfa384x_drvr_setconfig_async(hfa384x_t *hw,
 * Call context:
 *	process
 ----------------------------------------------------------------*/
-int hfa384x_drvr_ramdl_disable(hfa384x_t *hw)
+int hfa384x_drvr_ramdl_disable(hfa384x_t * hw)
 {
 	/* Check that we're already in the download state */
 	if (hw->dlstate != HFA384x_DLSTATE_RAMENABLED)
@@ -2288,7 +2278,7 @@ int hfa384x_drvr_ramdl_disable(hfa384x_t *hw)
 * Call context:
 *	process
 ----------------------------------------------------------------*/
-int hfa384x_drvr_ramdl_enable(hfa384x_t *hw, u32 exeaddr)
+int hfa384x_drvr_ramdl_enable(hfa384x_t * hw, u32 exeaddr)
 {
 	int result = 0;
 	u16 lowaddr;
@@ -2323,9 +2313,8 @@ int hfa384x_drvr_ramdl_enable(hfa384x_t *hw, u32 exeaddr)
 		/* Set the download state */
 		hw->dlstate = HFA384x_DLSTATE_RAMENABLED;
 	} else {
-		pr_debug(
-		       "cmd_download(0x%04x, 0x%04x) failed, result=%d.\n",
-		       lowaddr, hiaddr, result);
+		pr_debug("cmd_download(0x%04x, 0x%04x) failed, result=%d.\n",
+			 lowaddr, hiaddr, result);
 	}
 
 	return result;
@@ -2357,7 +2346,7 @@ int hfa384x_drvr_ramdl_enable(hfa384x_t *hw, u32 exeaddr)
 * Call context:
 *	process
 ----------------------------------------------------------------*/
-int hfa384x_drvr_ramdl_write(hfa384x_t *hw, u32 daddr, void *buf, u32 len)
+int hfa384x_drvr_ramdl_write(hfa384x_t * hw, u32 daddr, void *buf, u32 len)
 {
 	int result = 0;
 	int nwrites;
@@ -2436,7 +2425,7 @@ int hfa384x_drvr_ramdl_write(hfa384x_t *hw, u32 daddr, void *buf, u32 len)
 * Call context:
 *	process or non-card interrupt.
 ----------------------------------------------------------------*/
-int hfa384x_drvr_readpda(hfa384x_t *hw, void *buf, unsigned int len)
+int hfa384x_drvr_readpda(hfa384x_t * hw, void *buf, unsigned int len)
 {
 	int result = 0;
 	u16 *pda = buf;
@@ -2542,7 +2531,7 @@ int hfa384x_drvr_readpda(hfa384x_t *hw, void *buf, unsigned int len)
 * Call context:
 *	process
 ----------------------------------------------------------------*/
-int hfa384x_drvr_setconfig(hfa384x_t *hw, u16 rid, void *buf, u16 len)
+int hfa384x_drvr_setconfig(hfa384x_t * hw, u16 rid, void *buf, u16 len)
 {
 	return hfa384x_dowrid_wait(hw, rid, buf, len);
 }
@@ -2567,7 +2556,7 @@ int hfa384x_drvr_setconfig(hfa384x_t *hw, u16 rid, void *buf, u16 len)
 *	process
 ----------------------------------------------------------------*/
 
-int hfa384x_drvr_start(hfa384x_t *hw)
+int hfa384x_drvr_start(hfa384x_t * hw)
 {
 	int result, result1, result2;
 	u16 status;
@@ -2629,11 +2618,10 @@ int hfa384x_drvr_start(hfa384x_t *hw)
 			usb_kill_urb(&hw->rx_urb);
 			goto done;
 		} else {
-			pr_debug(
-			       "First cmd_initialize() failed (result %d),\n",
-			       result1);
-			pr_debug(
-			       "but second attempt succeeded. All should be ok\n");
+			pr_debug("First cmd_initialize() failed (result %d),\n",
+				 result1);
+			pr_debug
+			    ("but second attempt succeeded. All should be ok\n");
 		}
 	} else if (result2 != 0) {
 		printk(KERN_WARNING
@@ -2669,7 +2657,7 @@ int hfa384x_drvr_start(hfa384x_t *hw)
 * Call context:
 *	process
 ----------------------------------------------------------------*/
-int hfa384x_drvr_stop(hfa384x_t *hw)
+int hfa384x_drvr_stop(hfa384x_t * hw)
 {
 	int result = 0;
 	int i;
@@ -2720,9 +2708,9 @@ int hfa384x_drvr_stop(hfa384x_t *hw)
 * Call context:
 *	interrupt
 ----------------------------------------------------------------*/
-int hfa384x_drvr_txframe(hfa384x_t *hw, struct sk_buff *skb,
-			 p80211_hdr_t *p80211_hdr,
-			 p80211_metawep_t *p80211_wep)
+int hfa384x_drvr_txframe(hfa384x_t * hw, struct sk_buff *skb,
+			 p80211_hdr_t * p80211_hdr,
+			 p80211_metawep_t * p80211_wep)
 {
 	int usbpktlen = sizeof(hfa384x_tx_frame_t);
 	int result;
@@ -2813,7 +2801,7 @@ int hfa384x_drvr_txframe(hfa384x_t *hw, struct sk_buff *skb,
 	return result;
 }
 
-void hfa384x_tx_timeout(wlandevice_t *wlandev)
+void hfa384x_tx_timeout(wlandevice_t * wlandev)
 {
 	hfa384x_t *hw = wlandev->priv;
 	unsigned long flags;
@@ -2962,8 +2950,8 @@ static void hfa384x_usbctlx_completion_task(unsigned long data)
 * Call context:
 *	Either process or interrupt, but presumably interrupt
 ----------------------------------------------------------------*/
-static int unlocked_usbctlx_cancel_async(hfa384x_t *hw,
-					 hfa384x_usbctlx_t *ctlx)
+static int unlocked_usbctlx_cancel_async(hfa384x_t * hw,
+					 hfa384x_usbctlx_t * ctlx)
 {
 	int ret;
 
@@ -3012,7 +3000,7 @@ static int unlocked_usbctlx_cancel_async(hfa384x_t *hw,
 * Call context:
 *	Either, assume interrupt
 ----------------------------------------------------------------*/
-static void unlocked_usbctlx_complete(hfa384x_t *hw, hfa384x_usbctlx_t *ctlx)
+static void unlocked_usbctlx_complete(hfa384x_t * hw, hfa384x_usbctlx_t * ctlx)
 {
 	/* Timers have been stopped, and ctlx should be in
 	 * a terminal state. Retire it from the "active"
@@ -3029,8 +3017,7 @@ static void unlocked_usbctlx_complete(hfa384x_t *hw, hfa384x_usbctlx_t *ctlx)
 
 	default:
 		printk(KERN_ERR "CTLX[%d] not in a terminating state(%s)\n",
-		       le16_to_cpu(ctlx->outbuf.type),
-		       ctlxstr(ctlx->state));
+		       le16_to_cpu(ctlx->outbuf.type), ctlxstr(ctlx->state));
 		break;
 	}			/* switch */
 }
@@ -3051,7 +3038,7 @@ static void unlocked_usbctlx_complete(hfa384x_t *hw, hfa384x_usbctlx_t *ctlx)
 * Call context:
 *	any
 ----------------------------------------------------------------*/
-static void hfa384x_usbctlxq_run(hfa384x_t *hw)
+static void hfa384x_usbctlxq_run(hfa384x_t * hw)
 {
 	unsigned long flags;
 
@@ -3225,14 +3212,13 @@ static void hfa384x_usbin_callback(struct urb *urb)
 
 	case -ENOENT:
 	case -ECONNRESET:
-		pr_debug("status=%d, urb explicitly unlinked.\n",
-		       urb->status);
+		pr_debug("status=%d, urb explicitly unlinked.\n", urb->status);
 		action = ABORT;
 		break;
 
 	default:
 		pr_debug("urb status=%d, transfer flags=0x%x\n",
-		       urb->status, urb->transfer_flags);
+			 urb->status, urb->transfer_flags);
 		++(wlandev->linux_stats.rx_errors);
 		action = RESUBMIT;
 		break;
@@ -3292,18 +3278,17 @@ static void hfa384x_usbin_callback(struct urb *urb)
 
 	case HFA384x_USB_BUFAVAIL:
 		pr_debug("Received BUFAVAIL packet, frmlen=%d\n",
-		       usbin->bufavail.frmlen);
+			 usbin->bufavail.frmlen);
 		break;
 
 	case HFA384x_USB_ERROR:
 		pr_debug("Received USB_ERROR packet, errortype=%d\n",
-		       usbin->usberror.errortype);
+			 usbin->usberror.errortype);
 		break;
 
 	default:
-		pr_debug(
-		       "Unrecognized USBIN packet, type=%x, status=%d\n",
-		       usbin->type, urb_status);
+		pr_debug("Unrecognized USBIN packet, type=%x, status=%d\n",
+			 usbin->type, urb_status);
 		break;
 	}			/* switch */
 
@@ -3333,7 +3318,7 @@ static void hfa384x_usbin_callback(struct urb *urb)
 * Call context:
 *	interrupt
 ----------------------------------------------------------------*/
-static void hfa384x_usbin_ctlx(hfa384x_t *hw, hfa384x_usbin_t *usbin,
+static void hfa384x_usbin_ctlx(hfa384x_t * hw, hfa384x_usbin_t * usbin,
 			       int urb_status)
 {
 	hfa384x_usbctlx_t *ctlx;
@@ -3399,8 +3384,8 @@ static void hfa384x_usbin_ctlx(hfa384x_t *hw, hfa384x_usbin_t *usbin,
 			 * our request has been acknowledged. Odd,
 			 * but our OUT URB is still alive...
 			 */
-			pr_debug(
-			       "Causality violation: please reboot Universe, or email linux-wlan-devel@lists.linux-wlan.com\n");
+			pr_debug
+			    ("Causality violation: please reboot Universe, or email linux-wlan-devel@lists.linux-wlan.com\n");
 			ctlx->state = CTLX_RESP_COMPLETE;
 			break;
 
@@ -3454,8 +3439,8 @@ static void hfa384x_usbin_ctlx(hfa384x_t *hw, hfa384x_usbin_t *usbin,
 * Call context:
 *	interrupt
 ----------------------------------------------------------------*/
-static void hfa384x_usbin_txcompl(wlandevice_t *wlandev,
-				  hfa384x_usbin_t *usbin)
+static void hfa384x_usbin_txcompl(wlandevice_t * wlandev,
+				  hfa384x_usbin_t * usbin)
 {
 	u16 status;
 
@@ -3485,7 +3470,7 @@ static void hfa384x_usbin_txcompl(wlandevice_t *wlandev,
 * Call context:
 *	interrupt
 ----------------------------------------------------------------*/
-static void hfa384x_usbin_rx(wlandevice_t *wlandev, struct sk_buff *skb)
+static void hfa384x_usbin_rx(wlandevice_t * wlandev, struct sk_buff *skb)
 {
 	hfa384x_usbin_t *usbin = (hfa384x_usbin_t *) skb->data;
 	hfa384x_t *hw = wlandev->priv;
@@ -3552,8 +3537,7 @@ static void hfa384x_usbin_rx(wlandevice_t *wlandev, struct sk_buff *skb)
 			hfa384x_int_rxmonitor(wlandev, &usbin->rxfrm);
 			dev_kfree_skb(skb);
 		} else {
-			pr_debug(
-			       "Received monitor frame: FCSerr set\n");
+			pr_debug("Received monitor frame: FCSerr set\n");
 		}
 		break;
 
@@ -3589,8 +3573,8 @@ static void hfa384x_usbin_rx(wlandevice_t *wlandev, struct sk_buff *skb)
 * Call context:
 *	interrupt
 ----------------------------------------------------------------*/
-static void hfa384x_int_rxmonitor(wlandevice_t *wlandev,
-				  hfa384x_usb_rxfrm_t *rxfrm)
+static void hfa384x_int_rxmonitor(wlandevice_t * wlandev,
+				  hfa384x_usb_rxfrm_t * rxfrm)
 {
 	hfa384x_rx_frame_t *rxdesc = &(rxfrm->desc);
 	unsigned int hdrlen = 0;
@@ -3615,7 +3599,7 @@ static void hfa384x_int_rxmonitor(wlandevice_t *wlandev,
 	    (sizeof(p80211_caphdr_t) +
 	     WLAN_HDR_A4_LEN + WLAN_DATA_MAXLEN + WLAN_CRC_LEN)) {
 		pr_debug("overlen frm: len=%zd\n",
-		       skblen - sizeof(p80211_caphdr_t));
+			 skblen - sizeof(p80211_caphdr_t));
 	}
 
 	if ((skb = dev_alloc_skb(skblen)) == NULL) {
@@ -4071,7 +4055,7 @@ static void hfa384x_usb_throttlefn(unsigned long data)
 * Call context:
 *	process or interrupt
 ----------------------------------------------------------------*/
-static int hfa384x_usbctlx_submit(hfa384x_t *hw, hfa384x_usbctlx_t *ctlx)
+static int hfa384x_usbctlx_submit(hfa384x_t * hw, hfa384x_usbctlx_t * ctlx)
 {
 	unsigned long flags;
 	int ret;
@@ -4112,7 +4096,7 @@ static int hfa384x_usbctlx_submit(hfa384x_t *hw, hfa384x_usbctlx_t *ctlx)
 * Call context:
 *	interrupt
 ----------------------------------------------------------------*/
-static void hfa384x_usbout_tx(wlandevice_t *wlandev, hfa384x_usbout_t *usbout)
+static void hfa384x_usbout_tx(wlandevice_t * wlandev, hfa384x_usbout_t * usbout)
 {
 	prism2sta_ev_alloc(wlandev);
 }
@@ -4171,15 +4155,13 @@ static int hfa384x_isgood_pdrcode(u16 pdrcode)
 	default:
 		if (pdrcode < 0x1000) {
 			/* code is OK, but we don't know exactly what it is */
-			pr_debug(
-			       "Encountered unknown PDR#=0x%04x, "
-			       "assuming it's ok.\n", pdrcode);
+			pr_debug("Encountered unknown PDR#=0x%04x, "
+				 "assuming it's ok.\n", pdrcode);
 			return 1;
 		} else {
 			/* bad code */
-			pr_debug(
-			       "Encountered unknown PDR#=0x%04x, "
-			       "(>=0x1000), assuming it's bad.\n", pdrcode);
+			pr_debug("Encountered unknown PDR#=0x%04x, "
+				 "(>=0x1000), assuming it's bad.\n", pdrcode);
 			return 0;
 		}
 		break;

commit f2b50b40d1241b443da43fa66ae53bae93df910a
Author: Karl Relton <karllinuxtest.relton@ntlworld.com>
Date:   Fri May 8 20:54:17 2009 +0100

    Staging: wlan-ng: Change KERN_DEBUG or pr_debug to match orig driver
    
    Change uses of KERN_DEBUG over to pr_debug to match original driver
    where messages are only needed during driver development.
    
    Signed-off-by: Karl Relton <karllinuxtest.relton@ntlworld.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/wlan-ng/hfa384x_usb.c b/drivers/staging/wlan-ng/hfa384x_usb.c
index 6790bc5efe5b..be297b9cac3e 100644
--- a/drivers/staging/wlan-ng/hfa384x_usb.c
+++ b/drivers/staging/wlan-ng/hfa384x_usb.c
@@ -1174,7 +1174,7 @@ int hfa384x_cmd_download(hfa384x_t *hw, u16 mode, u16 lowaddr,
 	int result = 0;
 	hfa384x_metacmd_t cmd;
 
-	printk(KERN_DEBUG
+	pr_debug(
 	       "mode=%d, lowaddr=0x%04x, highaddr=0x%04x, codelen=%d\n",
 	       mode, lowaddr, highaddr, codelen);
 
@@ -1651,7 +1651,7 @@ hfa384x_dormem(hfa384x_t *hw,
 
 	ctlx->outbufsize = sizeof(ctlx->outbuf.rmemreq);
 
-	printk(KERN_DEBUG
+	pr_debug(
 	       "type=0x%04x frmlen=%d offset=0x%04x page=0x%04x\n",
 	       ctlx->outbuf.rmemreq.type,
 	       ctlx->outbuf.rmemreq.frmlen,
@@ -2035,7 +2035,7 @@ int hfa384x_drvr_flashdl_write(hfa384x_t *hw, u32 daddr, void *buf, u32 len)
 	/* NOTE: dlbuffer RID stores the address in AUX format */
 	dlbufaddr =
 	    HFA384x_ADDR_AUX_MKFLAT(hw->bufinfo.page, hw->bufinfo.offset);
-	printk(KERN_DEBUG
+	pr_debug(
 	       "dlbuf.page=0x%04x dlbuf.offset=0x%04x dlbufaddr=0x%08x\n",
 	       hw->bufinfo.page, hw->bufinfo.offset, dlbufaddr);
 
@@ -2323,7 +2323,7 @@ int hfa384x_drvr_ramdl_enable(hfa384x_t *hw, u32 exeaddr)
 		/* Set the download state */
 		hw->dlstate = HFA384x_DLSTATE_RAMENABLED;
 	} else {
-		printk(KERN_DEBUG
+		pr_debug(
 		       "cmd_download(0x%04x, 0x%04x) failed, result=%d.\n",
 		       lowaddr, hiaddr, result);
 	}
@@ -2629,10 +2629,10 @@ int hfa384x_drvr_start(hfa384x_t *hw)
 			usb_kill_urb(&hw->rx_urb);
 			goto done;
 		} else {
-			printk(KERN_DEBUG
+			pr_debug(
 			       "First cmd_initialize() failed (result %d),\n",
 			       result1);
-			printk(KERN_DEBUG
+			pr_debug(
 			       "but second attempt succeeded. All should be ok\n");
 		}
 	} else if (result2 != 0) {
@@ -3301,7 +3301,7 @@ static void hfa384x_usbin_callback(struct urb *urb)
 		break;
 
 	default:
-		printk(KERN_DEBUG
+		pr_debug(
 		       "Unrecognized USBIN packet, type=%x, status=%d\n",
 		       usbin->type, urb_status);
 		break;
@@ -3399,7 +3399,7 @@ static void hfa384x_usbin_ctlx(hfa384x_t *hw, hfa384x_usbin_t *usbin,
 			 * our request has been acknowledged. Odd,
 			 * but our OUT URB is still alive...
 			 */
-			printk(KERN_DEBUG
+			pr_debug(
 			       "Causality violation: please reboot Universe, or email linux-wlan-devel@lists.linux-wlan.com\n");
 			ctlx->state = CTLX_RESP_COMPLETE;
 			break;
@@ -3552,7 +3552,7 @@ static void hfa384x_usbin_rx(wlandevice_t *wlandev, struct sk_buff *skb)
 			hfa384x_int_rxmonitor(wlandev, &usbin->rxfrm);
 			dev_kfree_skb(skb);
 		} else {
-			printk(KERN_DEBUG
+			pr_debug(
 			       "Received monitor frame: FCSerr set\n");
 		}
 		break;
@@ -4171,13 +4171,13 @@ static int hfa384x_isgood_pdrcode(u16 pdrcode)
 	default:
 		if (pdrcode < 0x1000) {
 			/* code is OK, but we don't know exactly what it is */
-			printk(KERN_DEBUG
+			pr_debug(
 			       "Encountered unknown PDR#=0x%04x, "
 			       "assuming it's ok.\n", pdrcode);
 			return 1;
 		} else {
 			/* bad code */
-			printk(KERN_DEBUG
+			pr_debug(
 			       "Encountered unknown PDR#=0x%04x, "
 			       "(>=0x1000), assuming it's bad.\n", pdrcode);
 			return 0;

commit 727cbafa51bfaab788250bd3a3ba5e09f3bccf0b
Author: Huang Weiyi <weiyi.huang@gmail.com>
Date:   Mon Apr 6 17:20:29 2009 +0800

    Staging: remove unused #include <linux/version.h>'s
    
    Remove unused #include <linux/version.h>'s.
    
    Signed-off-by: Huang Weiyi <weiyi.huang@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/wlan-ng/hfa384x_usb.c b/drivers/staging/wlan-ng/hfa384x_usb.c
index 824e65bdc433..6790bc5efe5b 100644
--- a/drivers/staging/wlan-ng/hfa384x_usb.c
+++ b/drivers/staging/wlan-ng/hfa384x_usb.c
@@ -110,7 +110,6 @@
 * --------------------------------------------------------------------
 */
 
-#include <linux/version.h>
 
 #include <linux/module.h>
 #include <linux/kernel.h>

commit 3ac49a1c9928b4a242b3cb1d83bc1d5c9b8fcb50
Author: Jean Delvare <khali@linux-fr.org>
Date:   Thu Jun 4 16:20:28 2009 +0200

    trivial: fix ETIMEOUT -> ETIMEDOUT typos
    
    fix ETIMEOUT -> ETIMEDOUT typos
    
    Signed-off-by: Jean Delvare <khali@linux-fr.org>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/staging/wlan-ng/hfa384x_usb.c b/drivers/staging/wlan-ng/hfa384x_usb.c
index 888198c9a106..824e65bdc433 100644
--- a/drivers/staging/wlan-ng/hfa384x_usb.c
+++ b/drivers/staging/wlan-ng/hfa384x_usb.c
@@ -2424,7 +2424,7 @@ int hfa384x_drvr_ramdl_write(hfa384x_t *hw, u32 daddr, void *buf, u32 len)
 *	0		success
 *	>0		f/w reported error - f/w status code
 *	<0		driver reported error
-*	-ETIMEOUT	timout waiting for the cmd regs to become
+*	-ETIMEDOUT	timout waiting for the cmd regs to become
 *			available, or waiting for the control reg
 *			to indicate the Aux port is enabled.
 *	-ENODATA	the buffer does NOT contain a valid PDA.

commit 2961f24f78f456a0a2d0dada56ee795232fe21b3
Author: Stoyan Gaydarov <stoyboyker@gmail.com>
Date:   Tue Mar 10 00:10:27 2009 -0500

    Staging: BUG to BUG_ON changes
    
    Signed-off-by: Stoyan Gaydarov <stoyboyker@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/wlan-ng/hfa384x_usb.c b/drivers/staging/wlan-ng/hfa384x_usb.c
index 13a8ace1a03c..888198c9a106 100644
--- a/drivers/staging/wlan-ng/hfa384x_usb.c
+++ b/drivers/staging/wlan-ng/hfa384x_usb.c
@@ -3176,8 +3176,7 @@ static void hfa384x_usbin_callback(struct urb *urb)
 		goto exit;
 
 	skb = hw->rx_urb_skb;
-	if (!skb || (skb->data != urb->transfer_buffer))
-		BUG();
+	BUG_ON(!skb || (skb->data != urb->transfer_buffer));
 
 	hw->rx_urb_skb = NULL;
 

commit 18c7f792be75c2430cbf16e22dca1ab6a9881a63
Author: Moritz Muehlenhoff <jmm@debian.org>
Date:   Wed Feb 18 19:50:07 2009 +0100

    Staging: wlan-ng: Replace local byteorder macros
    
    Replace hfa384x2host_16(), hfa384x2host_32(), host2hfa384x_16()
    and host2hfa384x_32() with standard byteorder macros.
    
    Signed-off-by: Moritz Muehlenhoff <jmm@debian.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/wlan-ng/hfa384x_usb.c b/drivers/staging/wlan-ng/hfa384x_usb.c
index b986a6f817a2..13a8ace1a03c 100644
--- a/drivers/staging/wlan-ng/hfa384x_usb.c
+++ b/drivers/staging/wlan-ng/hfa384x_usb.c
@@ -647,10 +647,10 @@ static int
 usbctlx_get_status(const hfa384x_usb_cmdresp_t *cmdresp,
 		   hfa384x_cmdresult_t *result)
 {
-	result->status = hfa384x2host_16(cmdresp->status);
-	result->resp0 = hfa384x2host_16(cmdresp->resp0);
-	result->resp1 = hfa384x2host_16(cmdresp->resp1);
-	result->resp2 = hfa384x2host_16(cmdresp->resp2);
+	result->status = le16_to_cpu(cmdresp->status);
+	result->resp0 = le16_to_cpu(cmdresp->resp0);
+	result->resp1 = le16_to_cpu(cmdresp->resp1);
+	result->resp2 = le16_to_cpu(cmdresp->resp2);
 
 	pr_debug("cmdresult:status=0x%04x "
 	       "resp0=0x%04x resp1=0x%04x resp2=0x%04x\n",
@@ -663,9 +663,9 @@ static void
 usbctlx_get_rridresult(const hfa384x_usb_rridresp_t *rridresp,
 		       hfa384x_rridresult_t *result)
 {
-	result->rid = hfa384x2host_16(rridresp->rid);
+	result->rid = le16_to_cpu(rridresp->rid);
 	result->riddata = rridresp->data;
-	result->riddata_len = ((hfa384x2host_16(rridresp->frmlen) - 1) * 2);
+	result->riddata_len = ((le16_to_cpu(rridresp->frmlen) - 1) * 2);
 
 }
 
@@ -865,7 +865,7 @@ static void hfa384x_cb_rrid(hfa384x_t *hw, const hfa384x_usbctlx_t *ctlx)
 		if (ctlx->state != CTLX_COMPLETE) {
 			memset(&rridresult, 0, sizeof(rridresult));
 			rridresult.rid =
-			    hfa384x2host_16(ctlx->outbuf.rridreq.rid);
+			    le16_to_cpu(ctlx->outbuf.rridreq.rid);
 		} else {
 			usbctlx_get_rridresult(&ctlx->inbuf.rridresp,
 					       &rridresult);
@@ -1321,7 +1321,7 @@ static int hfa384x_usbctlx_complete_sync(hfa384x_t *hw,
 			result = completor->complete(completor);
 		} else {
 			printk(KERN_WARNING "CTLX[%d] error: state(%s)\n",
-			       hfa384x2host_16(ctlx->outbuf.type),
+			       le16_to_cpu(ctlx->outbuf.type),
 			       ctlxstr(ctlx->state));
 			result = -EIO;
 		}
@@ -1382,11 +1382,11 @@ hfa384x_docmd(hfa384x_t *hw,
 	}
 
 	/* Initialize the command */
-	ctlx->outbuf.cmdreq.type = host2hfa384x_16(HFA384x_USB_CMDREQ);
-	ctlx->outbuf.cmdreq.cmd = host2hfa384x_16(cmd->cmd);
-	ctlx->outbuf.cmdreq.parm0 = host2hfa384x_16(cmd->parm0);
-	ctlx->outbuf.cmdreq.parm1 = host2hfa384x_16(cmd->parm1);
-	ctlx->outbuf.cmdreq.parm2 = host2hfa384x_16(cmd->parm2);
+	ctlx->outbuf.cmdreq.type = cpu_to_le16(HFA384x_USB_CMDREQ);
+	ctlx->outbuf.cmdreq.cmd = cpu_to_le16(cmd->cmd);
+	ctlx->outbuf.cmdreq.parm0 = cpu_to_le16(cmd->parm0);
+	ctlx->outbuf.cmdreq.parm1 = cpu_to_le16(cmd->parm1);
+	ctlx->outbuf.cmdreq.parm2 = cpu_to_le16(cmd->parm2);
 
 	ctlx->outbufsize = sizeof(ctlx->outbuf.cmdreq);
 
@@ -1473,10 +1473,10 @@ hfa384x_dorrid(hfa384x_t *hw,
 	}
 
 	/* Initialize the command */
-	ctlx->outbuf.rridreq.type = host2hfa384x_16(HFA384x_USB_RRIDREQ);
+	ctlx->outbuf.rridreq.type = cpu_to_le16(HFA384x_USB_RRIDREQ);
 	ctlx->outbuf.rridreq.frmlen =
-	    host2hfa384x_16(sizeof(ctlx->outbuf.rridreq.rid));
-	ctlx->outbuf.rridreq.rid = host2hfa384x_16(rid);
+	    cpu_to_le16(sizeof(ctlx->outbuf.rridreq.rid));
+	ctlx->outbuf.rridreq.rid = cpu_to_le16(rid);
 
 	ctlx->outbufsize = sizeof(ctlx->outbuf.rridreq);
 
@@ -1554,12 +1554,12 @@ hfa384x_dowrid(hfa384x_t *hw,
 	}
 
 	/* Initialize the command */
-	ctlx->outbuf.wridreq.type = host2hfa384x_16(HFA384x_USB_WRIDREQ);
-	ctlx->outbuf.wridreq.frmlen = host2hfa384x_16((sizeof
+	ctlx->outbuf.wridreq.type = cpu_to_le16(HFA384x_USB_WRIDREQ);
+	ctlx->outbuf.wridreq.frmlen = cpu_to_le16((sizeof
 						       (ctlx->outbuf.wridreq.
 							rid) + riddatalen +
 						       1) / 2);
-	ctlx->outbuf.wridreq.rid = host2hfa384x_16(rid);
+	ctlx->outbuf.wridreq.rid = cpu_to_le16(rid);
 	memcpy(ctlx->outbuf.wridreq.data, riddata, riddatalen);
 
 	ctlx->outbufsize = sizeof(ctlx->outbuf.wridreq.type) +
@@ -1643,12 +1643,12 @@ hfa384x_dormem(hfa384x_t *hw,
 	}
 
 	/* Initialize the command */
-	ctlx->outbuf.rmemreq.type = host2hfa384x_16(HFA384x_USB_RMEMREQ);
+	ctlx->outbuf.rmemreq.type = cpu_to_le16(HFA384x_USB_RMEMREQ);
 	ctlx->outbuf.rmemreq.frmlen =
-	    host2hfa384x_16(sizeof(ctlx->outbuf.rmemreq.offset) +
+	    cpu_to_le16(sizeof(ctlx->outbuf.rmemreq.offset) +
 			    sizeof(ctlx->outbuf.rmemreq.page) + len);
-	ctlx->outbuf.rmemreq.offset = host2hfa384x_16(offset);
-	ctlx->outbuf.rmemreq.page = host2hfa384x_16(page);
+	ctlx->outbuf.rmemreq.offset = cpu_to_le16(offset);
+	ctlx->outbuf.rmemreq.page = cpu_to_le16(page);
 
 	ctlx->outbufsize = sizeof(ctlx->outbuf.rmemreq);
 
@@ -1739,12 +1739,12 @@ hfa384x_dowmem(hfa384x_t *hw,
 	}
 
 	/* Initialize the command */
-	ctlx->outbuf.wmemreq.type = host2hfa384x_16(HFA384x_USB_WMEMREQ);
+	ctlx->outbuf.wmemreq.type = cpu_to_le16(HFA384x_USB_WMEMREQ);
 	ctlx->outbuf.wmemreq.frmlen =
-	    host2hfa384x_16(sizeof(ctlx->outbuf.wmemreq.offset) +
+	    cpu_to_le16(sizeof(ctlx->outbuf.wmemreq.offset) +
 			    sizeof(ctlx->outbuf.wmemreq.page) + len);
-	ctlx->outbuf.wmemreq.offset = host2hfa384x_16(offset);
-	ctlx->outbuf.wmemreq.page = host2hfa384x_16(page);
+	ctlx->outbuf.wmemreq.offset = cpu_to_le16(offset);
+	ctlx->outbuf.wmemreq.page = cpu_to_le16(page);
 	memcpy(ctlx->outbuf.wmemreq.data, data, len);
 
 	ctlx->outbufsize = sizeof(ctlx->outbuf.wmemreq.type) +
@@ -1927,14 +1927,14 @@ int hfa384x_drvr_flashdl_enable(hfa384x_t *hw)
 					     sizeof(hw->bufinfo)))) {
 		return result;
 	}
-	hw->bufinfo.page = hfa384x2host_16(hw->bufinfo.page);
-	hw->bufinfo.offset = hfa384x2host_16(hw->bufinfo.offset);
-	hw->bufinfo.len = hfa384x2host_16(hw->bufinfo.len);
+	hw->bufinfo.page = le16_to_cpu(hw->bufinfo.page);
+	hw->bufinfo.offset = le16_to_cpu(hw->bufinfo.offset);
+	hw->bufinfo.len = le16_to_cpu(hw->bufinfo.len);
 	if ((result = hfa384x_drvr_getconfig16(hw, HFA384x_RID_MAXLOADTIME,
 					       &(hw->dltimeout)))) {
 		return result;
 	}
-	hw->dltimeout = hfa384x2host_16(hw->dltimeout);
+	hw->dltimeout = le16_to_cpu(hw->dltimeout);
 
 	pr_debug("flashdl_enable\n");
 
@@ -2477,8 +2477,8 @@ int hfa384x_drvr_readpda(hfa384x_t *hw, void *buf, unsigned int len)
 		pdaok = 1;	/* initially assume good */
 		morepdrs = 1;
 		while (pdaok && morepdrs) {
-			pdrlen = hfa384x2host_16(pda[currpdr]) * 2;
-			pdrcode = hfa384x2host_16(pda[currpdr + 1]);
+			pdrlen = le16_to_cpu(pda[currpdr]) * 2;
+			pdrcode = le16_to_cpu(pda[currpdr + 1]);
 			/* Test the record length */
 			if (pdrlen > HFA384x_PDR_LEN_MAX || pdrlen == 0) {
 				printk(KERN_ERR "pdrlen invalid=%d\n", pdrlen);
@@ -2499,7 +2499,7 @@ int hfa384x_drvr_readpda(hfa384x_t *hw, void *buf, unsigned int len)
 			/* Move to the next pdr (if necessary) */
 			if (morepdrs) {
 				/* note the access to pda[], need words here */
-				currpdr += hfa384x2host_16(pda[currpdr]) + 1;
+				currpdr += le16_to_cpu(pda[currpdr]) + 1;
 			}
 		}
 		if (pdaok) {
@@ -2741,7 +2741,7 @@ int hfa384x_drvr_txframe(hfa384x_t *hw, struct sk_buff *skb,
 	memset(&hw->txbuff.txfrm.desc, 0, sizeof(hw->txbuff.txfrm.desc));
 
 	/* Setup the usb type field */
-	hw->txbuff.type = host2hfa384x_16(HFA384x_USB_TXFRM);
+	hw->txbuff.type = cpu_to_le16(HFA384x_USB_TXFRM);
 
 	/* Set up the sw_support field to identify this frame */
 	hw->txbuff.txfrm.desc.sw_support = 0x0123;
@@ -2764,7 +2764,7 @@ int hfa384x_drvr_txframe(hfa384x_t *hw, struct sk_buff *skb,
 	    HFA384x_TX_TXEX_SET(0) | HFA384x_TX_TXOK_SET(0);
 #endif
 	hw->txbuff.txfrm.desc.tx_control =
-	    host2hfa384x_16(hw->txbuff.txfrm.desc.tx_control);
+	    cpu_to_le16(hw->txbuff.txfrm.desc.tx_control);
 
 	/* copy the header over to the txdesc */
 	memcpy(&(hw->txbuff.txfrm.desc.frame_control), p80211_hdr,
@@ -2772,10 +2772,10 @@ int hfa384x_drvr_txframe(hfa384x_t *hw, struct sk_buff *skb,
 
 	/* if we're using host WEP, increase size by IV+ICV */
 	if (p80211_wep->data) {
-		hw->txbuff.txfrm.desc.data_len = host2hfa384x_16(skb->len + 8);
+		hw->txbuff.txfrm.desc.data_len = cpu_to_le16(skb->len + 8);
 		usbpktlen += 8;
 	} else {
-		hw->txbuff.txfrm.desc.data_len = host2hfa384x_16(skb->len);
+		hw->txbuff.txfrm.desc.data_len = cpu_to_le16(skb->len);
 	}
 
 	usbpktlen += skb->len;
@@ -3030,7 +3030,7 @@ static void unlocked_usbctlx_complete(hfa384x_t *hw, hfa384x_usbctlx_t *ctlx)
 
 	default:
 		printk(KERN_ERR "CTLX[%d] not in a terminating state(%s)\n",
-		       hfa384x2host_16(ctlx->outbuf.type),
+		       le16_to_cpu(ctlx->outbuf.type),
 		       ctlxstr(ctlx->state));
 		break;
 	}			/* switch */
@@ -3128,7 +3128,7 @@ static void hfa384x_usbctlxq_run(hfa384x_t *hw)
 		}
 
 		printk(KERN_ERR "Failed to submit CTLX[%d]: error=%d\n",
-		       hfa384x2host_16(head->outbuf.type), result);
+		       le16_to_cpu(head->outbuf.type), result);
 		unlocked_usbctlx_complete(hw, head);
 	}			/* while */
 
@@ -3257,7 +3257,7 @@ static void hfa384x_usbin_callback(struct urb *urb)
 	/* Note: the check of the sw_support field, the type field doesn't
 	 *       have bit 12 set like the docs suggest.
 	 */
-	type = hfa384x2host_16(usbin->type);
+	type = le16_to_cpu(usbin->type);
 	if (HFA384x_USB_ISRXFRM(type)) {
 		if (action == HANDLE) {
 			if (usbin->txfrm.desc.sw_support == 0x0123) {
@@ -3378,7 +3378,7 @@ static void hfa384x_usbin_ctlx(hfa384x_t *hw, hfa384x_usbin_t *usbin,
 		if (unlocked_usbctlx_cancel_async(hw, ctlx) == 0)
 			run_queue = 1;
 	} else {
-		const u16 intype = (usbin->type & ~host2hfa384x_16(0x8000));
+		const u16 intype = (usbin->type & ~cpu_to_le16(0x8000));
 
 		/*
 		 * Check that our message is what we're expecting ...
@@ -3386,8 +3386,8 @@ static void hfa384x_usbin_ctlx(hfa384x_t *hw, hfa384x_usbin_t *usbin,
 		if (ctlx->outbuf.type != intype) {
 			printk(KERN_WARNING
 			       "Expected IN[%d], received IN[%d] - ignored.\n",
-			       hfa384x2host_16(ctlx->outbuf.type),
-			       hfa384x2host_16(intype));
+			       le16_to_cpu(ctlx->outbuf.type),
+			       le16_to_cpu(intype));
 			goto unlock;
 		}
 
@@ -3424,7 +3424,7 @@ static void hfa384x_usbin_ctlx(hfa384x_t *hw, hfa384x_usbin_t *usbin,
 			printk(KERN_ERR
 			       "Matched IN URB, CTLX[%d] in invalid state(%s)."
 			       " Discarded.\n",
-			       hfa384x2host_16(ctlx->outbuf.type),
+			       le16_to_cpu(ctlx->outbuf.type),
 			       ctlxstr(ctlx->state));
 			if (unlocked_usbctlx_cancel_async(hw, ctlx) == 0)
 				run_queue = 1;
@@ -3461,7 +3461,7 @@ static void hfa384x_usbin_txcompl(wlandevice_t *wlandev,
 {
 	u16 status;
 
-	status = hfa384x2host_16(usbin->type);	/* yeah I know it says type... */
+	status = le16_to_cpu(usbin->type);	/* yeah I know it says type... */
 
 	/* Was there an error? */
 	if (HFA384x_TXSTATUS_ISERROR(status))
@@ -3497,8 +3497,8 @@ static void hfa384x_usbin_rx(wlandevice_t *wlandev, struct sk_buff *skb)
 	u16 fc;
 
 	/* Byte order convert once up front. */
-	usbin->rxfrm.desc.status = hfa384x2host_16(usbin->rxfrm.desc.status);
-	usbin->rxfrm.desc.time = hfa384x2host_32(usbin->rxfrm.desc.time);
+	usbin->rxfrm.desc.status = le16_to_cpu(usbin->rxfrm.desc.status);
+	usbin->rxfrm.desc.time = le32_to_cpu(usbin->rxfrm.desc.time);
 
 	/* Now handle frame based on port# */
 	switch (HFA384x_RXSTATUS_MACPORT_GET(usbin->rxfrm.desc.status)) {
@@ -3511,7 +3511,7 @@ static void hfa384x_usbin_rx(wlandevice_t *wlandev, struct sk_buff *skb)
 			goto done;
 		}
 
-		data_len = hfa384x2host_16(usbin->rxfrm.desc.data_len);
+		data_len = le16_to_cpu(usbin->rxfrm.desc.data_len);
 
 		/* How much header data do we have? */
 		hdrlen = p80211_headerlen(fc);
@@ -3607,7 +3607,7 @@ static void hfa384x_int_rxmonitor(wlandevice_t *wlandev,
 	/* Figure out how big the frame is */
 	fc = le16_to_cpu(rxdesc->frame_control);
 	hdrlen = p80211_headerlen(fc);
-	datalen = hfa384x2host_16(rxdesc->data_len);
+	datalen = le16_to_cpu(rxdesc->data_len);
 
 	/* Allocate an ind message+framesize skb */
 	skblen = sizeof(p80211_caphdr_t) + hdrlen + datalen + WLAN_CRC_LEN;
@@ -3698,7 +3698,7 @@ static void hfa384x_int_rxmonitor(wlandevice_t *wlandev,
 static void hfa384x_usbin_info(wlandevice_t * wlandev, hfa384x_usbin_t * usbin)
 {
 	usbin->infofrm.info.framelen =
-	    hfa384x2host_16(usbin->infofrm.info.framelen);
+	    le16_to_cpu(usbin->infofrm.info.framelen);
 	prism2sta_ev_info(wlandev, &usbin->infofrm.info);
 }
 
@@ -3866,7 +3866,7 @@ static void hfa384x_ctlxout_callback(struct urb *urb)
 			/* This is NOT a valid CTLX "success" state! */
 			printk(KERN_ERR
 			       "Illegal CTLX[%d] success state(%s, %d) in OUT URB\n",
-			       hfa384x2host_16(ctlx->outbuf.type),
+			       le16_to_cpu(ctlx->outbuf.type),
 			       ctlxstr(ctlx->state), urb->status);
 			break;
 		}		/* switch */

commit 465e7417b15348909606c3edce5f018818235a54
Author: Moritz Muehlenhoff <jmm@debian.org>
Date:   Mon Feb 9 19:33:44 2009 +0100

    Staging: wlan-ng: Remove the now empty wlan_compat.h
    
    Signed-off-by: Moritz Muehlenhoff <jmm@debian.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/wlan-ng/hfa384x_usb.c b/drivers/staging/wlan-ng/hfa384x_usb.c
index dd1e1d949969..b986a6f817a2 100644
--- a/drivers/staging/wlan-ng/hfa384x_usb.c
+++ b/drivers/staging/wlan-ng/hfa384x_usb.c
@@ -128,8 +128,6 @@
 #include <linux/usb.h>
 #include <linux/byteorder/generic.h>
 
-#include "wlan_compat.h"
-
 #define SUBMIT_URB(u,f)  usb_submit_urb(u,f)
 
 /*================================================================*/

commit e469ee7f561657e260690ae202a32adb60e26730
Author: Moritz Muehlenhoff <jmm@debian.org>
Date:   Mon Feb 9 19:33:41 2009 +0100

    Staging: wlan-ng: Remove more dead code from hfa384x_usb.c
    
    Signed-off-by: Moritz Muehlenhoff <jmm@debian.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/wlan-ng/hfa384x_usb.c b/drivers/staging/wlan-ng/hfa384x_usb.c
index 67157dbbf7cb..dd1e1d949969 100644
--- a/drivers/staging/wlan-ng/hfa384x_usb.c
+++ b/drivers/staging/wlan-ng/hfa384x_usb.c
@@ -1193,68 +1193,6 @@ int hfa384x_cmd_download(hfa384x_t *hw, u16 mode, u16 lowaddr,
 	return result;
 }
 
-/*----------------------------------------------------------------
-* hfa384x_copy_from_aux
-*
-* Copies a collection of bytes from the controller memory.  The
-* Auxiliary port MUST be enabled prior to calling this function.
-* We _might_ be in a download state.
-*
-* Arguments:
-*	hw		device structure
-*	cardaddr	address in hfa384x data space to read
-*	auxctl		address space select
-*	buf		ptr to destination host buffer
-*	len		length of data to transfer (in bytes)
-*
-* Returns:
-*	nothing
-*
-* Side effects:
-*	buf contains the data copied
-*
-* Call context:
-*	process
-*	interrupt
-----------------------------------------------------------------*/
-void
-hfa384x_copy_from_aux(hfa384x_t *hw, u32 cardaddr, u32 auxctl, void *buf,
-		      unsigned int len)
-{
-	printk(KERN_ERR "not used in USB.\n");
-}
-
-/*----------------------------------------------------------------
-* hfa384x_copy_to_aux
-*
-* Copies a collection of bytes to the controller memory.  The
-* Auxiliary port MUST be enabled prior to calling this function.
-* We _might_ be in a download state.
-*
-* Arguments:
-*	hw		device structure
-*	cardaddr	address in hfa384x data space to read
-*	auxctl		address space select
-*	buf		ptr to destination host buffer
-*	len		length of data to transfer (in bytes)
-*
-* Returns:
-*	nothing
-*
-* Side effects:
-*	Controller memory now contains a copy of buf
-*
-* Call context:
-*	process
-*	interrupt
-----------------------------------------------------------------*/
-void
-hfa384x_copy_to_aux(hfa384x_t *hw, u32 cardaddr, u32 auxctl, void *buf,
-		    unsigned int len)
-{
-	printk(KERN_ERR "not used in USB.\n");
-}
-
 /*----------------------------------------------------------------
 * hfa384x_corereset
 *
@@ -2295,31 +2233,6 @@ hfa384x_drvr_setconfig_async(hfa384x_t *hw,
 				    hfa384x_cb_status, usercb, usercb_data);
 }
 
-/*----------------------------------------------------------------
-* hfa384x_drvr_handover
-*
-* Sends a handover notification to the MAC.
-*
-* Arguments:
-*	hw		device structure
-*	addr		address of station that's left
-*
-* Returns:
-*	zero		success.
-*	-ERESTARTSYS	received signal while waiting for semaphore.
-*	-EIO		failed to write to bap, or failed in cmd.
-*
-* Side effects:
-*
-* Call context:
-*	process
-----------------------------------------------------------------*/
-int hfa384x_drvr_handover(hfa384x_t *hw, u8 *addr)
-{
-	printk(KERN_ERR "Not currently supported in USB!\n");
-	return -EIO;
-}
-
 /*----------------------------------------------------------------
 * hfa384x_drvr_ramdl_disable
 *

commit 21dc0f898792df85780c9334f26edc28ff0ee30a
Author: Moritz Muehlenhoff <jmm@debian.org>
Date:   Sun Feb 8 02:21:00 2009 +0100

    Staging: wlan-ng: hfa384x_usb.c: Coding style cleanups
    
    Signed-off-by: Moritz Muehlenhoff <jmm@debian.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/wlan-ng/hfa384x_usb.c b/drivers/staging/wlan-ng/hfa384x_usb.c
index c37d002ee923..67157dbbf7cb 100644
--- a/drivers/staging/wlan-ng/hfa384x_usb.c
+++ b/drivers/staging/wlan-ng/hfa384x_usb.c
@@ -110,9 +110,6 @@
 * --------------------------------------------------------------------
 */
 
-/*================================================================*/
-/* System Includes */
-
 #include <linux/version.h>
 
 #include <linux/module.h>
@@ -150,13 +147,9 @@
 #include "hfa384x.h"
 #include "prism2mgmt.h"
 
-/*================================================================*/
-/* Local Constants */
-
-enum cmd_mode
-{
-  DOWAIT = 0,
-  DOASYNC
+enum cmd_mode {
+	DOWAIT = 0,
+	DOASYNC
 };
 typedef enum cmd_mode CMD_MODE;
 
@@ -164,50 +157,33 @@ typedef enum cmd_mode CMD_MODE;
 #define URB_ASYNC_UNLINK 0
 #define USB_QUEUE_BULK 0
 
-/*================================================================*/
-/* Local Macros */
-
 #define ROUNDUP64(a) (((a)+63)&~63)
 
-/*================================================================*/
-/* Local Function Declarations */
-
 #ifdef DEBUG_USB
-static void
-dbprint_urb(struct urb* urb);
+static void dbprint_urb(struct urb *urb);
 #endif
 
 static void
-hfa384x_int_rxmonitor(
-	wlandevice_t *wlandev,
-	hfa384x_usb_rxfrm_t *rxfrm);
+hfa384x_int_rxmonitor(wlandevice_t *wlandev, hfa384x_usb_rxfrm_t *rxfrm);
 
-static void
-hfa384x_usb_defer(struct work_struct *data);
+static void hfa384x_usb_defer(struct work_struct *data);
 
-static int
-submit_rx_urb(hfa384x_t *hw, gfp_t flags);
+static int submit_rx_urb(hfa384x_t *hw, gfp_t flags);
 
-static int
-submit_tx_urb(hfa384x_t *hw, struct urb *tx_urb, gfp_t flags);
+static int submit_tx_urb(hfa384x_t *hw, struct urb *tx_urb, gfp_t flags);
 
 /*---------------------------------------------------*/
 /* Callbacks */
-static void
-hfa384x_usbout_callback(struct urb *urb);
-static void
-hfa384x_ctlxout_callback(struct urb *urb);
-static void
-hfa384x_usbin_callback(struct urb *urb);
+static void hfa384x_usbout_callback(struct urb *urb);
+static void hfa384x_ctlxout_callback(struct urb *urb);
+static void hfa384x_usbin_callback(struct urb *urb);
 
 static void
 hfa384x_usbin_txcompl(wlandevice_t *wlandev, hfa384x_usbin_t *usbin);
 
-static void
-hfa384x_usbin_rx(wlandevice_t *wlandev, struct sk_buff *skb);
+static void hfa384x_usbin_rx(wlandevice_t *wlandev, struct sk_buff *skb);
 
-static void
-hfa384x_usbin_info(wlandevice_t *wlandev, hfa384x_usbin_t *usbin);
+static void hfa384x_usbin_info(wlandevice_t *wlandev, hfa384x_usbin_t *usbin);
 
 static void
 hfa384x_usbout_tx(wlandevice_t *wlandev, hfa384x_usbout_t *usbout);
@@ -218,123 +194,94 @@ static void hfa384x_usbin_ctlx(hfa384x_t *hw, hfa384x_usbin_t *usbin,
 /*---------------------------------------------------*/
 /* Functions to support the prism2 usb command queue */
 
-static void
-hfa384x_usbctlxq_run(hfa384x_t *hw);
+static void hfa384x_usbctlxq_run(hfa384x_t *hw);
 
-static void
-hfa384x_usbctlx_reqtimerfn(unsigned long data);
+static void hfa384x_usbctlx_reqtimerfn(unsigned long data);
 
-static void
-hfa384x_usbctlx_resptimerfn(unsigned long data);
+static void hfa384x_usbctlx_resptimerfn(unsigned long data);
 
-static void
-hfa384x_usb_throttlefn(unsigned long data);
+static void hfa384x_usb_throttlefn(unsigned long data);
 
-static void
-hfa384x_usbctlx_completion_task(unsigned long data);
+static void hfa384x_usbctlx_completion_task(unsigned long data);
 
-static void
-hfa384x_usbctlx_reaper_task(unsigned long data);
+static void hfa384x_usbctlx_reaper_task(unsigned long data);
 
-static int
-hfa384x_usbctlx_submit(hfa384x_t *hw, hfa384x_usbctlx_t *ctlx);
+static int hfa384x_usbctlx_submit(hfa384x_t *hw, hfa384x_usbctlx_t *ctlx);
 
-static void
-unlocked_usbctlx_complete(hfa384x_t *hw, hfa384x_usbctlx_t *ctlx);
+static void unlocked_usbctlx_complete(hfa384x_t *hw, hfa384x_usbctlx_t *ctlx);
 
-struct usbctlx_completor
-{
-	int (*complete)(struct usbctlx_completor*);
+struct usbctlx_completor {
+	int (*complete) (struct usbctlx_completor *);
 };
 typedef struct usbctlx_completor usbctlx_completor_t;
 
 static int
 hfa384x_usbctlx_complete_sync(hfa384x_t *hw,
-                              hfa384x_usbctlx_t *ctlx,
-                              usbctlx_completor_t *completor);
+			      hfa384x_usbctlx_t *ctlx,
+			      usbctlx_completor_t *completor);
 
 static int
 unlocked_usbctlx_cancel_async(hfa384x_t *hw, hfa384x_usbctlx_t *ctlx);
 
-static void
-hfa384x_cb_status(hfa384x_t *hw, const hfa384x_usbctlx_t *ctlx);
+static void hfa384x_cb_status(hfa384x_t *hw, const hfa384x_usbctlx_t *ctlx);
 
-static void
-hfa384x_cb_rrid(hfa384x_t *hw, const hfa384x_usbctlx_t *ctlx);
+static void hfa384x_cb_rrid(hfa384x_t *hw, const hfa384x_usbctlx_t *ctlx);
 
 static int
 usbctlx_get_status(const hfa384x_usb_cmdresp_t *cmdresp,
-                   hfa384x_cmdresult_t *result);
+		   hfa384x_cmdresult_t *result);
 
 static void
 usbctlx_get_rridresult(const hfa384x_usb_rridresp_t *rridresp,
-                       hfa384x_rridresult_t *result);
+		       hfa384x_rridresult_t *result);
 
 /*---------------------------------------------------*/
 /* Low level req/resp CTLX formatters and submitters */
 static int
-hfa384x_docmd(
-	hfa384x_t *hw,
-	CMD_MODE mode,
-	hfa384x_metacmd_t *cmd,
-	ctlx_cmdcb_t cmdcb,
-	ctlx_usercb_t usercb,
-	void	*usercb_data);
+hfa384x_docmd(hfa384x_t *hw,
+	      CMD_MODE mode,
+	      hfa384x_metacmd_t *cmd,
+	      ctlx_cmdcb_t cmdcb, ctlx_usercb_t usercb, void *usercb_data);
 
 static int
-hfa384x_dorrid(
-	hfa384x_t *hw,
-	CMD_MODE mode,
-	u16	rid,
-	void	*riddata,
-	unsigned int	riddatalen,
-	ctlx_cmdcb_t cmdcb,
-	ctlx_usercb_t usercb,
-	void	*usercb_data);
+hfa384x_dorrid(hfa384x_t *hw,
+	       CMD_MODE mode,
+	       u16 rid,
+	       void *riddata,
+	       unsigned int riddatalen,
+	       ctlx_cmdcb_t cmdcb, ctlx_usercb_t usercb, void *usercb_data);
 
 static int
-hfa384x_dowrid(
-	hfa384x_t *hw,
-	CMD_MODE mode,
-	u16	rid,
-	void	*riddata,
-	unsigned int	riddatalen,
-	ctlx_cmdcb_t cmdcb,
-	ctlx_usercb_t usercb,
-	void	*usercb_data);
+hfa384x_dowrid(hfa384x_t *hw,
+	       CMD_MODE mode,
+	       u16 rid,
+	       void *riddata,
+	       unsigned int riddatalen,
+	       ctlx_cmdcb_t cmdcb, ctlx_usercb_t usercb, void *usercb_data);
 
 static int
-hfa384x_dormem(
-	hfa384x_t *hw,
-	CMD_MODE mode,
-	u16	page,
-	u16	offset,
-	void	*data,
-	unsigned int	len,
-	ctlx_cmdcb_t cmdcb,
-	ctlx_usercb_t usercb,
-	void	*usercb_data);
+hfa384x_dormem(hfa384x_t *hw,
+	       CMD_MODE mode,
+	       u16 page,
+	       u16 offset,
+	       void *data,
+	       unsigned int len,
+	       ctlx_cmdcb_t cmdcb, ctlx_usercb_t usercb, void *usercb_data);
 
 static int
-hfa384x_dowmem(
-	hfa384x_t *hw,
-	CMD_MODE mode,
-	u16	page,
-	u16	offset,
-	void	*data,
-	unsigned int	len,
-	ctlx_cmdcb_t cmdcb,
-	ctlx_usercb_t usercb,
-	void	*usercb_data);
+hfa384x_dowmem(hfa384x_t *hw,
+	       CMD_MODE mode,
+	       u16 page,
+	       u16 offset,
+	       void *data,
+	       unsigned int len,
+	       ctlx_cmdcb_t cmdcb, ctlx_usercb_t usercb, void *usercb_data);
 
-static int
-hfa384x_isgood_pdrcode(u16 pdrcode);
+static int hfa384x_isgood_pdrcode(u16 pdrcode);
 
-/*================================================================*/
-/* Function Definitions */
-static inline const char* ctlxstr(CTLX_STATE s)
+static inline const char *ctlxstr(CTLX_STATE s)
 {
-	static const char* ctlx_str[] = {
+	static const char *ctlx_str[] = {
 		"Initial state",
 		"Complete",
 		"Request failed",
@@ -347,36 +294,36 @@ static inline const char* ctlxstr(CTLX_STATE s)
 	return ctlx_str[s];
 };
 
-
-static inline hfa384x_usbctlx_t*
-get_active_ctlx(hfa384x_t *hw)
+static inline hfa384x_usbctlx_t *get_active_ctlx(hfa384x_t *hw)
 {
 	return list_entry(hw->ctlxq.active.next, hfa384x_usbctlx_t, list);
 }
 
-
 #ifdef DEBUG_USB
-void
-dbprint_urb(struct urb* urb)
+void dbprint_urb(struct urb *urb)
 {
 	pr_debug("urb->pipe=0x%08x\n", urb->pipe);
 	pr_debug("urb->status=0x%08x\n", urb->status);
 	pr_debug("urb->transfer_flags=0x%08x\n", urb->transfer_flags);
-	pr_debug("urb->transfer_buffer=0x%08x\n", (unsigned int)urb->transfer_buffer);
-	pr_debug("urb->transfer_buffer_length=0x%08x\n", urb->transfer_buffer_length);
+	pr_debug("urb->transfer_buffer=0x%08x\n",
+	       (unsigned int)urb->transfer_buffer);
+	pr_debug("urb->transfer_buffer_length=0x%08x\n",
+	       urb->transfer_buffer_length);
 	pr_debug("urb->actual_length=0x%08x\n", urb->actual_length);
 	pr_debug("urb->bandwidth=0x%08x\n", urb->bandwidth);
-	pr_debug("urb->setup_packet(ctl)=0x%08x\n", (unsigned int)urb->setup_packet);
-	pr_debug("urb->start_frame(iso/irq)=0x%08x\n", urb->start_frame);
+	pr_debug("urb->setup_packet(ctl)=0x%08x\n",
+	       (unsigned int)urb->setup_packet);
+	pr_debug("urb->start_frame(iso/irq)=0x%08x\n",
+	       urb->start_frame);
 	pr_debug("urb->interval(irq)=0x%08x\n", urb->interval);
 	pr_debug("urb->error_count(iso)=0x%08x\n", urb->error_count);
 	pr_debug("urb->timeout=0x%08x\n", urb->timeout);
 	pr_debug("urb->context=0x%08x\n", (unsigned int)urb->context);
-	pr_debug("urb->complete=0x%08x\n", (unsigned int)urb->complete);
+	pr_debug("urb->complete=0x%08x\n",
+	       (unsigned int)urb->complete);
 }
 #endif
 
-
 /*----------------------------------------------------------------
 * submit_rx_urb
 *
@@ -393,8 +340,7 @@ dbprint_urb(struct urb* urb)
 * Call context:
 *	Any
 ----------------------------------------------------------------*/
-static int
-submit_rx_urb(hfa384x_t *hw, gfp_t memflags)
+static int submit_rx_urb(hfa384x_t *hw, gfp_t memflags)
 {
 	struct sk_buff *skb;
 	int result;
@@ -407,21 +353,22 @@ submit_rx_urb(hfa384x_t *hw, gfp_t memflags)
 
 	/* Post the IN urb */
 	usb_fill_bulk_urb(&hw->rx_urb, hw->usb,
-	              hw->endp_in,
-	              skb->data, sizeof(hfa384x_usbin_t),
-	              hfa384x_usbin_callback, hw->wlandev);
+			  hw->endp_in,
+			  skb->data, sizeof(hfa384x_usbin_t),
+			  hfa384x_usbin_callback, hw->wlandev);
 
 	hw->rx_urb_skb = skb;
 
 	result = -ENOLINK;
-	if ( !hw->wlandev->hwremoved && !test_bit(WORK_RX_HALT, &hw->usb_flags)) {
+	if (!hw->wlandev->hwremoved && !test_bit(WORK_RX_HALT, &hw->usb_flags)) {
 		result = SUBMIT_URB(&hw->rx_urb, memflags);
 
 		/* Check whether we need to reset the RX pipe */
 		if (result == -EPIPE) {
-			printk(KERN_WARNING "%s rx pipe stalled: requesting reset\n",
-			                 hw->wlandev->netdev->name);
-			if ( !test_and_set_bit(WORK_RX_HALT, &hw->usb_flags) )
+			printk(KERN_WARNING
+			       "%s rx pipe stalled: requesting reset\n",
+			       hw->wlandev->netdev->name);
+			if (!test_and_set_bit(WORK_RX_HALT, &hw->usb_flags))
 				schedule_work(&hw->usb_work);
 		}
 	}
@@ -432,7 +379,7 @@ submit_rx_urb(hfa384x_t *hw, gfp_t memflags)
 		hw->rx_urb_skb = NULL;
 	}
 
- done:
+done:
 	return result;
 }
 
@@ -454,22 +401,23 @@ submit_rx_urb(hfa384x_t *hw, gfp_t memflags)
 * Call context:
 *	Any
 ----------------------------------------------------------------*/
-static int
-submit_tx_urb(hfa384x_t *hw, struct urb *tx_urb, gfp_t memflags)
+static int submit_tx_urb(hfa384x_t *hw, struct urb *tx_urb, gfp_t memflags)
 {
 	struct net_device *netdev = hw->wlandev->netdev;
 	int result;
 
 	result = -ENOLINK;
-	if ( netif_running(netdev) ) {
+	if (netif_running(netdev)) {
 
-		if ( !hw->wlandev->hwremoved && !test_bit(WORK_TX_HALT, &hw->usb_flags) ) {
+		if (!hw->wlandev->hwremoved
+		    && !test_bit(WORK_TX_HALT, &hw->usb_flags)) {
 			result = SUBMIT_URB(tx_urb, memflags);
 
 			/* Test whether we need to reset the TX pipe */
 			if (result == -EPIPE) {
-				printk(KERN_WARNING "%s tx pipe stalled: requesting reset\n",
-				                 netdev->name);
+				printk(KERN_WARNING
+				       "%s tx pipe stalled: requesting reset\n",
+				       netdev->name);
 				set_bit(WORK_TX_HALT, &hw->usb_flags);
 				schedule_work(&hw->usb_work);
 			} else if (result == 0) {
@@ -497,8 +445,7 @@ submit_tx_urb(hfa384x_t *hw, struct urb *tx_urb, gfp_t memflags)
 * Call context:
 *	process (by design)
 ----------------------------------------------------------------*/
-static void
-hfa384x_usb_defer(struct work_struct *data)
+static void hfa384x_usb_defer(struct work_struct *data)
 {
 	hfa384x_t *hw = container_of(data, struct hfa384x, usb_work);
 	struct net_device *netdev = hw->wlandev->netdev;
@@ -506,15 +453,14 @@ hfa384x_usb_defer(struct work_struct *data)
 	/* Don't bother trying to reset anything if the plug
 	 * has been pulled ...
 	 */
-	if ( hw->wlandev->hwremoved ) {
+	if (hw->wlandev->hwremoved)
 		return;
-	}
 
 	/* Reception has stopped: try to reset the input pipe */
 	if (test_bit(WORK_RX_HALT, &hw->usb_flags)) {
 		int ret;
 
-		usb_kill_urb(&hw->rx_urb);  /* Cannot be holding spinlock! */
+		usb_kill_urb(&hw->rx_urb);	/* Cannot be holding spinlock! */
 
 		ret = usb_clear_halt(hw->usb, hw->endp_in);
 		if (ret != 0) {
@@ -523,14 +469,14 @@ hfa384x_usb_defer(struct work_struct *data)
 			       netdev->name, ret);
 		} else {
 			printk(KERN_INFO "%s rx pipe reset complete.\n",
-			                 netdev->name);
+			       netdev->name);
 			clear_bit(WORK_RX_HALT, &hw->usb_flags);
 			set_bit(WORK_RX_RESUME, &hw->usb_flags);
 		}
 	}
 
 	/* Resume receiving data back from the device. */
-	if ( test_bit(WORK_RX_RESUME, &hw->usb_flags) ) {
+	if (test_bit(WORK_RX_RESUME, &hw->usb_flags)) {
 		int ret;
 
 		ret = submit_rx_urb(hw, GFP_KERNEL);
@@ -554,7 +500,7 @@ hfa384x_usb_defer(struct work_struct *data)
 			       netdev->name, ret);
 		} else {
 			printk(KERN_INFO "%s tx pipe reset complete.\n",
-			                 netdev->name);
+			       netdev->name);
 			clear_bit(WORK_TX_HALT, &hw->usb_flags);
 			set_bit(WORK_TX_RESUME, &hw->usb_flags);
 
@@ -567,12 +513,10 @@ hfa384x_usb_defer(struct work_struct *data)
 	}
 
 	/* Resume transmitting. */
-	if ( test_and_clear_bit(WORK_TX_RESUME, &hw->usb_flags) ) {
+	if (test_and_clear_bit(WORK_TX_RESUME, &hw->usb_flags))
 		netif_wake_queue(hw->wlandev->netdev);
-	}
 }
 
-
 /*----------------------------------------------------------------
 * hfa384x_create
 *
@@ -594,8 +538,7 @@ hfa384x_usb_defer(struct work_struct *data)
 * Call context:
 *	process
 ----------------------------------------------------------------*/
-void
-hfa384x_create( hfa384x_t *hw, struct usb_device *usb)
+void hfa384x_create(hfa384x_t *hw, struct usb_device *usb)
 {
 	memset(hw, 0, sizeof(hfa384x_t));
 	hw->usb = usb;
@@ -618,11 +561,9 @@ hfa384x_create( hfa384x_t *hw, struct usb_device *usb)
 	skb_queue_head_init(&hw->authq);
 
 	tasklet_init(&hw->reaper_bh,
-	             hfa384x_usbctlx_reaper_task,
-	             (unsigned long)hw);
+		     hfa384x_usbctlx_reaper_task, (unsigned long)hw);
 	tasklet_init(&hw->completion_bh,
-	             hfa384x_usbctlx_completion_task,
-	             (unsigned long)hw);
+		     hfa384x_usbctlx_completion_task, (unsigned long)hw);
 	INIT_WORK(&hw->link_bh, prism2sta_processing_defer);
 	INIT_WORK(&hw->usb_work, hfa384x_usb_defer);
 
@@ -645,13 +586,12 @@ hfa384x_create( hfa384x_t *hw, struct usb_device *usb)
 	hw->link_status = HFA384x_LINK_NOTCONNECTED;
 	hw->state = HFA384x_STATE_INIT;
 
-        INIT_WORK(&hw->commsqual_bh, prism2sta_commsqual_defer);
+	INIT_WORK(&hw->commsqual_bh, prism2sta_commsqual_defer);
 	init_timer(&hw->commsqual_timer);
-	hw->commsqual_timer.data = (unsigned long) hw;
+	hw->commsqual_timer.data = (unsigned long)hw;
 	hw->commsqual_timer.function = prism2sta_commsqual_timer;
 }
 
-
 /*----------------------------------------------------------------
 * hfa384x_destroy
 *
@@ -674,14 +614,12 @@ hfa384x_create( hfa384x_t *hw, struct usb_device *usb)
 * Call context:
 *	process
 ----------------------------------------------------------------*/
-void
-hfa384x_destroy( hfa384x_t *hw)
+void hfa384x_destroy(hfa384x_t *hw)
 {
 	struct sk_buff *skb;
 
-	if ( hw->state == HFA384x_STATE_RUNNING ) {
+	if (hw->state == HFA384x_STATE_RUNNING)
 		hfa384x_drvr_stop(hw);
-	}
 	hw->state = HFA384x_STATE_PREINIT;
 
 	if (hw->scanresults) {
@@ -690,21 +628,16 @@ hfa384x_destroy( hfa384x_t *hw)
 	}
 
 	/* Now to clean out the auth queue */
-        while ( (skb = skb_dequeue(&hw->authq)) ) {
-                dev_kfree_skb(skb);
-        }
+	while ((skb = skb_dequeue(&hw->authq)))
+		dev_kfree_skb(skb);
 }
 
-
-/*----------------------------------------------------------------
- */
-static hfa384x_usbctlx_t* usbctlx_alloc(void)
+static hfa384x_usbctlx_t *usbctlx_alloc(void)
 {
 	hfa384x_usbctlx_t *ctlx;
 
 	ctlx = kmalloc(sizeof(*ctlx), in_interrupt() ? GFP_ATOMIC : GFP_KERNEL);
-	if (ctlx != NULL)
-	{
+	if (ctlx != NULL) {
 		memset(ctlx, 0, sizeof(*ctlx));
 		init_completion(&ctlx->done);
 	}
@@ -712,13 +645,9 @@ static hfa384x_usbctlx_t* usbctlx_alloc(void)
 	return ctlx;
 }
 
-
-/*----------------------------------------------------------------
- *
-----------------------------------------------------------------*/
 static int
 usbctlx_get_status(const hfa384x_usb_cmdresp_t *cmdresp,
-                   hfa384x_cmdresult_t *result)
+		   hfa384x_cmdresult_t *result)
 {
 	result->status = hfa384x2host_16(cmdresp->status);
 	result->resp0 = hfa384x2host_16(cmdresp->resp0);
@@ -726,18 +655,15 @@ usbctlx_get_status(const hfa384x_usb_cmdresp_t *cmdresp,
 	result->resp2 = hfa384x2host_16(cmdresp->resp2);
 
 	pr_debug("cmdresult:status=0x%04x "
-	                  "resp0=0x%04x resp1=0x%04x resp2=0x%04x\n",
-	                result->status,
-	                result->resp0,
-	                result->resp1,
-	                result->resp2);
+	       "resp0=0x%04x resp1=0x%04x resp2=0x%04x\n",
+	       result->status, result->resp0, result->resp1, result->resp2);
 
-	return (result->status & HFA384x_STATUS_RESULT);
+	return result->status & HFA384x_STATUS_RESULT;
 }
 
 static void
 usbctlx_get_rridresult(const hfa384x_usb_rridresp_t *rridresp,
-                       hfa384x_rridresult_t *result)
+		       hfa384x_rridresult_t *result)
 {
 	result->rid = hfa384x2host_16(rridresp->rid);
 	result->riddata = rridresp->data;
@@ -745,31 +671,32 @@ usbctlx_get_rridresult(const hfa384x_usb_rridresp_t *rridresp,
 
 }
 
-
 /*----------------------------------------------------------------
 * Completor object:
 * This completor must be passed to hfa384x_usbctlx_complete_sync()
 * when processing a CTLX that returns a hfa384x_cmdresult_t structure.
 ----------------------------------------------------------------*/
-struct usbctlx_cmd_completor
-{
-	usbctlx_completor_t	head;
+struct usbctlx_cmd_completor {
+	usbctlx_completor_t head;
 
-	const hfa384x_usb_cmdresp_t	*cmdresp;
-	hfa384x_cmdresult_t	*result;
+	const hfa384x_usb_cmdresp_t *cmdresp;
+	hfa384x_cmdresult_t *result;
 };
 typedef struct usbctlx_cmd_completor usbctlx_cmd_completor_t;
 
 static int usbctlx_cmd_completor_fn(usbctlx_completor_t *head)
 {
-	usbctlx_cmd_completor_t *complete = (usbctlx_cmd_completor_t*)head;
+	usbctlx_cmd_completor_t *complete = (usbctlx_cmd_completor_t *) head;
 	return usbctlx_get_status(complete->cmdresp, complete->result);
 }
 
-static inline usbctlx_completor_t*
-init_cmd_completor(usbctlx_cmd_completor_t *completor,
-                   const hfa384x_usb_cmdresp_t *cmdresp,
-                   hfa384x_cmdresult_t *result)
+static inline usbctlx_completor_t *init_cmd_completor(usbctlx_cmd_completor_t *
+						      completor,
+						      const
+						      hfa384x_usb_cmdresp_t *
+						      cmdresp,
+						      hfa384x_cmdresult_t *
+						      result)
 {
 	completor->head.complete = usbctlx_cmd_completor_fn;
 	completor->cmdresp = cmdresp;
@@ -782,44 +709,41 @@ init_cmd_completor(usbctlx_cmd_completor_t *completor,
 * This completor must be passed to hfa384x_usbctlx_complete_sync()
 * when processing a CTLX that reads a RID.
 ----------------------------------------------------------------*/
-struct usbctlx_rrid_completor
-{
-	usbctlx_completor_t	head;
+struct usbctlx_rrid_completor {
+	usbctlx_completor_t head;
 
-	const hfa384x_usb_rridresp_t	*rridresp;
-	void			*riddata;
-	unsigned int			riddatalen;
+	const hfa384x_usb_rridresp_t *rridresp;
+	void *riddata;
+	unsigned int riddatalen;
 };
 typedef struct usbctlx_rrid_completor usbctlx_rrid_completor_t;
 
 static int usbctlx_rrid_completor_fn(usbctlx_completor_t *head)
 {
-	usbctlx_rrid_completor_t *complete = (usbctlx_rrid_completor_t*)head;
+	usbctlx_rrid_completor_t *complete = (usbctlx_rrid_completor_t *) head;
 	hfa384x_rridresult_t rridresult;
 
 	usbctlx_get_rridresult(complete->rridresp, &rridresult);
 
 	/* Validate the length, note body len calculation in bytes */
-	if ( rridresult.riddata_len != complete->riddatalen ) {
+	if (rridresult.riddata_len != complete->riddatalen) {
 		printk(KERN_WARNING
-			"RID len mismatch, rid=0x%04x hlen=%d fwlen=%d\n",
-		        rridresult.rid,
-		        complete->riddatalen,
-		        rridresult.riddata_len);
+		       "RID len mismatch, rid=0x%04x hlen=%d fwlen=%d\n",
+		       rridresult.rid,
+		       complete->riddatalen, rridresult.riddata_len);
 		return -ENODATA;
 	}
 
-	memcpy(complete->riddata,
-	       rridresult.riddata,
-	       complete->riddatalen);
+	memcpy(complete->riddata, rridresult.riddata, complete->riddatalen);
 	return 0;
 }
 
-static inline usbctlx_completor_t*
-init_rrid_completor(usbctlx_rrid_completor_t *completor,
-                    const hfa384x_usb_rridresp_t *rridresp,
-                    void *riddata,
-                    unsigned int riddatalen)
+static inline usbctlx_completor_t *init_rrid_completor(usbctlx_rrid_completor_t
+						       *completor,
+						       const
+						       hfa384x_usb_rridresp_t *
+						       rridresp, void *riddata,
+						       unsigned int riddatalen)
 {
 	completor->head.complete = usbctlx_rrid_completor_fn;
 	completor->rridresp = rridresp;
@@ -846,30 +770,29 @@ typedef usbctlx_cmd_completor_t usbctlx_wmem_completor_t;
 * Completor object:
 * Interprets the results of a synchronous memory-read
 ----------------------------------------------------------------*/
-struct usbctlx_rmem_completor
-{
-        usbctlx_completor_t           head;
+struct usbctlx_rmem_completor {
+	usbctlx_completor_t head;
 
-        const hfa384x_usb_rmemresp_t  *rmemresp;
-        void                          *data;
-        unsigned int                          len;
+	const hfa384x_usb_rmemresp_t *rmemresp;
+	void *data;
+	unsigned int len;
 };
 typedef struct usbctlx_rmem_completor usbctlx_rmem_completor_t;
 
 static int usbctlx_rmem_completor_fn(usbctlx_completor_t *head)
 {
-	usbctlx_rmem_completor_t *complete = (usbctlx_rmem_completor_t*)head;
+	usbctlx_rmem_completor_t *complete = (usbctlx_rmem_completor_t *) head;
 
 	pr_debug("rmemresp:len=%d\n", complete->rmemresp->frmlen);
 	memcpy(complete->data, complete->rmemresp->data, complete->len);
 	return 0;
 }
 
-static inline usbctlx_completor_t*
-init_rmem_completor(usbctlx_rmem_completor_t *completor,
-                    hfa384x_usb_rmemresp_t *rmemresp,
-                    void *data,
-                    unsigned int len)
+static inline usbctlx_completor_t *init_rmem_completor(usbctlx_rmem_completor_t
+						       *completor,
+						       hfa384x_usb_rmemresp_t
+                                                       *rmemresp, void *data,
+						       unsigned int len)
 {
 	completor->head.complete = usbctlx_rmem_completor_fn;
 	completor->rmemresp = rmemresp;
@@ -899,15 +822,15 @@ init_rmem_completor(usbctlx_rmem_completor_t *completor,
 * Call context:
 *	interrupt
 ----------------------------------------------------------------*/
-static void
-hfa384x_cb_status(hfa384x_t *hw, const hfa384x_usbctlx_t *ctlx)
+static void hfa384x_cb_status(hfa384x_t *hw, const hfa384x_usbctlx_t *ctlx)
 {
-	if ( ctlx->usercb != NULL ) {
+	if (ctlx->usercb != NULL) {
 		hfa384x_cmdresult_t cmdresult;
 
 		if (ctlx->state != CTLX_COMPLETE) {
 			memset(&cmdresult, 0, sizeof(cmdresult));
-			cmdresult.status = HFA384x_STATUS_RESULT_SET(HFA384x_CMD_ERR);
+			cmdresult.status =
+			    HFA384x_STATUS_RESULT_SET(HFA384x_CMD_ERR);
 		} else {
 			usbctlx_get_status(&ctlx->inbuf.cmdresp, &cmdresult);
 		}
@@ -916,7 +839,6 @@ hfa384x_cb_status(hfa384x_t *hw, const hfa384x_usbctlx_t *ctlx)
 	}
 }
 
-
 /*----------------------------------------------------------------
 * hfa384x_cb_rrid
 *
@@ -937,128 +859,114 @@ hfa384x_cb_status(hfa384x_t *hw, const hfa384x_usbctlx_t *ctlx)
 * Call context:
 *	interrupt
 ----------------------------------------------------------------*/
-static void
-hfa384x_cb_rrid(hfa384x_t *hw, const hfa384x_usbctlx_t *ctlx)
+static void hfa384x_cb_rrid(hfa384x_t *hw, const hfa384x_usbctlx_t *ctlx)
 {
-	if ( ctlx->usercb != NULL ) {
+	if (ctlx->usercb != NULL) {
 		hfa384x_rridresult_t rridresult;
 
 		if (ctlx->state != CTLX_COMPLETE) {
 			memset(&rridresult, 0, sizeof(rridresult));
-			rridresult.rid = hfa384x2host_16(ctlx->outbuf.rridreq.rid);
+			rridresult.rid =
+			    hfa384x2host_16(ctlx->outbuf.rridreq.rid);
 		} else {
-			usbctlx_get_rridresult(&ctlx->inbuf.rridresp, &rridresult);
+			usbctlx_get_rridresult(&ctlx->inbuf.rridresp,
+					       &rridresult);
 		}
 
 		ctlx->usercb(hw, &rridresult, ctlx->usercb_data);
 	}
 }
 
-static inline int
-hfa384x_docmd_wait(hfa384x_t *hw, hfa384x_metacmd_t *cmd)
+static inline int hfa384x_docmd_wait(hfa384x_t *hw, hfa384x_metacmd_t *cmd)
 {
 	return hfa384x_docmd(hw, DOWAIT, cmd, NULL, NULL, NULL);
 }
 
 static inline int
 hfa384x_docmd_async(hfa384x_t *hw,
-                    hfa384x_metacmd_t *cmd,
-                    ctlx_cmdcb_t cmdcb,
-                    ctlx_usercb_t usercb,
-                    void *usercb_data)
+		    hfa384x_metacmd_t *cmd,
+		    ctlx_cmdcb_t cmdcb, ctlx_usercb_t usercb, void *usercb_data)
 {
-	return hfa384x_docmd(hw, DOASYNC, cmd,
-	                        cmdcb, usercb, usercb_data);
+	return hfa384x_docmd(hw, DOASYNC, cmd, cmdcb, usercb, usercb_data);
 }
 
 static inline int
-hfa384x_dorrid_wait(hfa384x_t *hw, u16 rid, void *riddata, unsigned int riddatalen)
+hfa384x_dorrid_wait(hfa384x_t *hw, u16 rid, void *riddata,
+		    unsigned int riddatalen)
 {
 	return hfa384x_dorrid(hw, DOWAIT,
-	                      rid, riddata, riddatalen,
-	                      NULL, NULL, NULL);
+			      rid, riddata, riddatalen, NULL, NULL, NULL);
 }
 
 static inline int
 hfa384x_dorrid_async(hfa384x_t *hw,
-                     u16 rid, void *riddata, unsigned int riddatalen,
-                     ctlx_cmdcb_t cmdcb,
-                     ctlx_usercb_t usercb,
-                     void *usercb_data)
+		     u16 rid, void *riddata, unsigned int riddatalen,
+		     ctlx_cmdcb_t cmdcb,
+		     ctlx_usercb_t usercb, void *usercb_data)
 {
 	return hfa384x_dorrid(hw, DOASYNC,
-	                      rid, riddata, riddatalen,
-	                      cmdcb, usercb, usercb_data);
+			      rid, riddata, riddatalen,
+			      cmdcb, usercb, usercb_data);
 }
 
 static inline int
-hfa384x_dowrid_wait(hfa384x_t *hw, u16 rid, void *riddata, unsigned int riddatalen)
+hfa384x_dowrid_wait(hfa384x_t *hw, u16 rid, void *riddata,
+		    unsigned int riddatalen)
 {
 	return hfa384x_dowrid(hw, DOWAIT,
-	                      rid, riddata, riddatalen,
-	                      NULL, NULL, NULL);
+			      rid, riddata, riddatalen, NULL, NULL, NULL);
 }
 
 static inline int
 hfa384x_dowrid_async(hfa384x_t *hw,
-                     u16 rid, void *riddata, unsigned int riddatalen,
-                     ctlx_cmdcb_t cmdcb,
-                     ctlx_usercb_t usercb,
-                     void *usercb_data)
+		     u16 rid, void *riddata, unsigned int riddatalen,
+		     ctlx_cmdcb_t cmdcb,
+		     ctlx_usercb_t usercb, void *usercb_data)
 {
 	return hfa384x_dowrid(hw, DOASYNC,
-	                      rid, riddata, riddatalen,
-	                      cmdcb, usercb, usercb_data);
+			      rid, riddata, riddatalen,
+			      cmdcb, usercb, usercb_data);
 }
 
 static inline int
 hfa384x_dormem_wait(hfa384x_t *hw,
-                    u16 page, u16 offset, void *data, unsigned int len)
+		    u16 page, u16 offset, void *data, unsigned int len)
 {
 	return hfa384x_dormem(hw, DOWAIT,
-	                      page, offset, data, len,
-	                      NULL, NULL, NULL);
+			      page, offset, data, len, NULL, NULL, NULL);
 }
 
 static inline int
 hfa384x_dormem_async(hfa384x_t *hw,
-                     u16 page, u16 offset, void *data, unsigned int len,
-                     ctlx_cmdcb_t cmdcb,
-                     ctlx_usercb_t usercb,
-                     void *usercb_data)
+		     u16 page, u16 offset, void *data, unsigned int len,
+		     ctlx_cmdcb_t cmdcb,
+		     ctlx_usercb_t usercb, void *usercb_data)
 {
 	return hfa384x_dormem(hw, DOASYNC,
-	                      page, offset, data, len,
-	                      cmdcb, usercb, usercb_data);
+			      page, offset, data, len,
+			      cmdcb, usercb, usercb_data);
 }
 
 static inline int
-hfa384x_dowmem_wait(
-        hfa384x_t *hw,
-        u16  page,
-        u16  offset,
-        void    *data,
-        unsigned int    len)
+hfa384x_dowmem_wait(hfa384x_t *hw,
+		    u16 page, u16 offset, void *data, unsigned int len)
 {
 	return hfa384x_dowmem(hw, DOWAIT,
-                                  page, offset, data, len,
-	                          NULL, NULL, NULL);
+			      page, offset, data, len, NULL, NULL, NULL);
 }
 
 static inline int
-hfa384x_dowmem_async(
-        hfa384x_t *hw,
-        u16  page,
-        u16  offset,
-        void    *data,
-        unsigned int    len,
-        ctlx_cmdcb_t cmdcb,
-        ctlx_usercb_t usercb,
-        void    *usercb_data)
+hfa384x_dowmem_async(hfa384x_t *hw,
+		     u16 page,
+		     u16 offset,
+		     void *data,
+		     unsigned int len,
+		     ctlx_cmdcb_t cmdcb,
+		     ctlx_usercb_t usercb, void *usercb_data)
 {
 	return hfa384x_dowmem(hw, DOASYNC,
-                                  page, offset, data, len,
-	                          cmdcb, usercb, usercb_data);
+			      page, offset, data, len,
+			      cmdcb, usercb, usercb_data);
 }
 
 /*----------------------------------------------------------------
@@ -1080,11 +988,10 @@ hfa384x_dowmem_async(
 * Call context:
 *	process
 ----------------------------------------------------------------*/
-int
-hfa384x_cmd_initialize(hfa384x_t *hw)
+int hfa384x_cmd_initialize(hfa384x_t *hw)
 {
-	int	result = 0;
-	int	i;
+	int result = 0;
+	int i;
 	hfa384x_metacmd_t cmd;
 
 	cmd.cmd = HFA384x_CMDCODE_INIT;
@@ -1094,26 +1001,21 @@ hfa384x_cmd_initialize(hfa384x_t *hw)
 
 	result = hfa384x_docmd_wait(hw, &cmd);
 
-
 	pr_debug("cmdresp.init: "
-		"status=0x%04x, resp0=0x%04x, "
-		"resp1=0x%04x, resp2=0x%04x\n",
-		cmd.result.status,
-		cmd.result.resp0,
-		cmd.result.resp1,
-		cmd.result.resp2);
-	if ( result == 0 ) {
-		for ( i = 0; i < HFA384x_NUMPORTS_MAX; i++) {
+	       "status=0x%04x, resp0=0x%04x, "
+	       "resp1=0x%04x, resp2=0x%04x\n",
+	       cmd.result.status,
+	       cmd.result.resp0, cmd.result.resp1, cmd.result.resp2);
+	if (result == 0) {
+		for (i = 0; i < HFA384x_NUMPORTS_MAX; i++)
 			hw->port_enabled[i] = 0;
-		}
 	}
 
-        hw->link_status = HFA384x_LINK_NOTCONNECTED;
+	hw->link_status = HFA384x_LINK_NOTCONNECTED;
 
 	return result;
 }
 
-
 /*----------------------------------------------------------------
 * hfa384x_cmd_disable
 *
@@ -1136,11 +1038,11 @@ hfa384x_cmd_initialize(hfa384x_t *hw)
 ----------------------------------------------------------------*/
 int hfa384x_cmd_disable(hfa384x_t *hw, u16 macport)
 {
-	int	result = 0;
+	int result = 0;
 	hfa384x_metacmd_t cmd;
 
 	cmd.cmd = HFA384x_CMD_CMDCODE_SET(HFA384x_CMDCODE_DISABLE) |
-		  HFA384x_CMD_MACPORT_SET(macport);
+	    HFA384x_CMD_MACPORT_SET(macport);
 	cmd.parm0 = 0;
 	cmd.parm1 = 0;
 	cmd.parm2 = 0;
@@ -1150,7 +1052,6 @@ int hfa384x_cmd_disable(hfa384x_t *hw, u16 macport)
 	return result;
 }
 
-
 /*----------------------------------------------------------------
 * hfa384x_cmd_enable
 *
@@ -1173,11 +1074,11 @@ int hfa384x_cmd_disable(hfa384x_t *hw, u16 macport)
 ----------------------------------------------------------------*/
 int hfa384x_cmd_enable(hfa384x_t *hw, u16 macport)
 {
-	int	result = 0;
+	int result = 0;
 	hfa384x_metacmd_t cmd;
 
 	cmd.cmd = HFA384x_CMD_CMDCODE_SET(HFA384x_CMDCODE_ENABLE) |
-		  HFA384x_CMD_MACPORT_SET(macport);
+	    HFA384x_CMD_MACPORT_SET(macport);
 	cmd.parm0 = 0;
 	cmd.parm1 = 0;
 	cmd.parm2 = 0;
@@ -1218,11 +1119,11 @@ int hfa384x_cmd_enable(hfa384x_t *hw, u16 macport)
 ----------------------------------------------------------------*/
 int hfa384x_cmd_monitor(hfa384x_t *hw, u16 enable)
 {
-	int	result = 0;
+	int result = 0;
 	hfa384x_metacmd_t cmd;
 
 	cmd.cmd = HFA384x_CMD_CMDCODE_SET(HFA384x_CMDCODE_MONITOR) |
-		HFA384x_CMD_AINFO_SET(enable);
+	    HFA384x_CMD_AINFO_SET(enable);
 	cmd.parm0 = 0;
 	cmd.parm1 = 0;
 	cmd.parm2 = 0;
@@ -1232,7 +1133,6 @@ int hfa384x_cmd_monitor(hfa384x_t *hw, u16 enable)
 	return result;
 }
 
-
 /*----------------------------------------------------------------
 * hfa384x_cmd_download
 *
@@ -1272,14 +1172,14 @@ int hfa384x_cmd_monitor(hfa384x_t *hw, u16 enable)
 *	process
 ----------------------------------------------------------------*/
 int hfa384x_cmd_download(hfa384x_t *hw, u16 mode, u16 lowaddr,
-				u16 highaddr, u16 codelen)
+			 u16 highaddr, u16 codelen)
 {
-	int	result = 0;
+	int result = 0;
 	hfa384x_metacmd_t cmd;
 
 	printk(KERN_DEBUG
-		"mode=%d, lowaddr=0x%04x, highaddr=0x%04x, codelen=%d\n",
-		mode, lowaddr, highaddr, codelen);
+	       "mode=%d, lowaddr=0x%04x, highaddr=0x%04x, codelen=%d\n",
+	       mode, lowaddr, highaddr, codelen);
 
 	cmd.cmd = (HFA384x_CMD_CMDCODE_SET(HFA384x_CMDCODE_DOWNLD) |
 		   HFA384x_CMD_PROGMODE_SET(mode));
@@ -1293,7 +1193,6 @@ int hfa384x_cmd_download(hfa384x_t *hw, u16 mode, u16 lowaddr,
 	return result;
 }
 
-
 /*----------------------------------------------------------------
 * hfa384x_copy_from_aux
 *
@@ -1319,13 +1218,12 @@ int hfa384x_cmd_download(hfa384x_t *hw, u16 mode, u16 lowaddr,
 *	interrupt
 ----------------------------------------------------------------*/
 void
-hfa384x_copy_from_aux(
-	hfa384x_t *hw, u32 cardaddr, u32 auxctl, void *buf, unsigned int len)
+hfa384x_copy_from_aux(hfa384x_t *hw, u32 cardaddr, u32 auxctl, void *buf,
+		      unsigned int len)
 {
 	printk(KERN_ERR "not used in USB.\n");
 }
 
-
 /*----------------------------------------------------------------
 * hfa384x_copy_to_aux
 *
@@ -1351,13 +1249,12 @@ hfa384x_copy_from_aux(
 *	interrupt
 ----------------------------------------------------------------*/
 void
-hfa384x_copy_to_aux(
-	hfa384x_t *hw, u32 cardaddr, u32 auxctl, void *buf, unsigned int len)
+hfa384x_copy_to_aux(hfa384x_t *hw, u32 cardaddr, u32 auxctl, void *buf,
+		    unsigned int len)
 {
 	printk(KERN_ERR "not used in USB.\n");
 }
 
-
 /*----------------------------------------------------------------
 * hfa384x_corereset
 *
@@ -1383,17 +1280,17 @@ hfa384x_copy_to_aux(
 ----------------------------------------------------------------*/
 int hfa384x_corereset(hfa384x_t *hw, int holdtime, int settletime, int genesis)
 {
-	int 			result = 0;
+	int result = 0;
 
-	result=usb_reset_device(hw->usb);
-	if(result<0) {
-		printk(KERN_ERR "usb_reset_device() failed, result=%d.\n",result);
+	result = usb_reset_device(hw->usb);
+	if (result < 0) {
+		printk(KERN_ERR "usb_reset_device() failed, result=%d.\n",
+		       result);
 	}
 
 	return result;
 }
 
-
 /*----------------------------------------------------------------
 * hfa384x_usbctlx_complete_sync
 *
@@ -1433,14 +1330,11 @@ static int hfa384x_usbctlx_complete_sync(hfa384x_t *hw,
 	 * We can only handle the CTLX if the USB disconnect
 	 * function has not run yet ...
 	 */
-	cleanup:
-	if ( hw->wlandev->hwremoved )
-	{
+cleanup:
+	if (hw->wlandev->hwremoved) {
 		spin_unlock_irqrestore(&hw->ctlxq.lock, flags);
 		result = -ENODEV;
-	}
-	else if ( result != 0 )
-	{
+	} else if (result != 0) {
 		int runqueue = 0;
 
 		/*
@@ -1452,8 +1346,7 @@ static int hfa384x_usbctlx_complete_sync(hfa384x_t *hw,
 		 * NOTE: We can only delete the timers and
 		 *       the URB if this CTLX is active.
 		 */
-		if (ctlx == get_active_ctlx(hw))
-		{
+		if (ctlx == get_active_ctlx(hw)) {
 			spin_unlock_irqrestore(&hw->ctlxq.lock, flags);
 
 			del_singleshot_timer_sync(&hw->reqtimer);
@@ -1470,7 +1363,7 @@ static int hfa384x_usbctlx_complete_sync(hfa384x_t *hw,
 			 * This scenario is so unlikely that I'm
 			 * happy with a grubby "goto" solution ...
 			 */
-			if ( hw->wlandev->hwremoved )
+			if (hw->wlandev->hwremoved)
 				goto cleanup;
 		}
 
@@ -1492,8 +1385,8 @@ static int hfa384x_usbctlx_complete_sync(hfa384x_t *hw,
 			result = completor->complete(completor);
 		} else {
 			printk(KERN_WARNING "CTLX[%d] error: state(%s)\n",
-			                 hfa384x2host_16(ctlx->outbuf.type),
-			                 ctlxstr(ctlx->state));
+			       hfa384x2host_16(ctlx->outbuf.type),
+			       ctlxstr(ctlx->state));
 			result = -EIO;
 		}
 
@@ -1538,38 +1431,32 @@ static int hfa384x_usbctlx_complete_sync(hfa384x_t *hw,
 *	process
 ----------------------------------------------------------------*/
 static int
-hfa384x_docmd(
-	hfa384x_t *hw,
-	CMD_MODE mode,
-	hfa384x_metacmd_t *cmd,
-	ctlx_cmdcb_t	cmdcb,
-	ctlx_usercb_t	usercb,
-	void	*usercb_data)
+hfa384x_docmd(hfa384x_t *hw,
+	      CMD_MODE mode,
+	      hfa384x_metacmd_t *cmd,
+	      ctlx_cmdcb_t cmdcb, ctlx_usercb_t usercb, void *usercb_data)
 {
-	int			result;
-	hfa384x_usbctlx_t	*ctlx;
+	int result;
+	hfa384x_usbctlx_t *ctlx;
 
 	ctlx = usbctlx_alloc();
-	if ( ctlx == NULL ) {
+	if (ctlx == NULL) {
 		result = -ENOMEM;
 		goto done;
 	}
 
 	/* Initialize the command */
-	ctlx->outbuf.cmdreq.type = 	host2hfa384x_16(HFA384x_USB_CMDREQ);
-	ctlx->outbuf.cmdreq.cmd =	host2hfa384x_16(cmd->cmd);
-	ctlx->outbuf.cmdreq.parm0 =	host2hfa384x_16(cmd->parm0);
-	ctlx->outbuf.cmdreq.parm1 =	host2hfa384x_16(cmd->parm1);
-	ctlx->outbuf.cmdreq.parm2 =	host2hfa384x_16(cmd->parm2);
+	ctlx->outbuf.cmdreq.type = host2hfa384x_16(HFA384x_USB_CMDREQ);
+	ctlx->outbuf.cmdreq.cmd = host2hfa384x_16(cmd->cmd);
+	ctlx->outbuf.cmdreq.parm0 = host2hfa384x_16(cmd->parm0);
+	ctlx->outbuf.cmdreq.parm1 = host2hfa384x_16(cmd->parm1);
+	ctlx->outbuf.cmdreq.parm2 = host2hfa384x_16(cmd->parm2);
 
 	ctlx->outbufsize = sizeof(ctlx->outbuf.cmdreq);
 
 	pr_debug("cmdreq: cmd=0x%04x "
-		"parm0=0x%04x parm1=0x%04x parm2=0x%04x\n",
-		cmd->cmd,
-		cmd->parm0,
-		cmd->parm1,
-		cmd->parm2);
+	       "parm0=0x%04x parm1=0x%04x parm2=0x%04x\n",
+	       cmd->cmd, cmd->parm0, cmd->parm1, cmd->parm2);
 
 	ctlx->reapable = mode;
 	ctlx->cmdcb = cmdcb;
@@ -1582,17 +1469,20 @@ hfa384x_docmd(
 	} else if (mode == DOWAIT) {
 		usbctlx_cmd_completor_t completor;
 
-		result = hfa384x_usbctlx_complete_sync(
-		             hw, ctlx, init_cmd_completor(&completor,
-		                                          &ctlx->inbuf.cmdresp,
-		                                          &cmd->result) );
+		result =
+		    hfa384x_usbctlx_complete_sync(hw, ctlx,
+						  init_cmd_completor(&completor,
+								     &ctlx->
+								     inbuf.
+								     cmdresp,
+								     &cmd->
+								     result));
 	}
 
 done:
 	return result;
 }
 
-
 /*----------------------------------------------------------------
 * hfa384x_dorrid
 *
@@ -1630,30 +1520,27 @@ hfa384x_docmd(
 *	process (DOWAIT or DOASYNC)
 ----------------------------------------------------------------*/
 static int
-hfa384x_dorrid(
-	hfa384x_t *hw,
-	CMD_MODE mode,
-	u16	rid,
-	void	*riddata,
-	unsigned int	riddatalen,
-        ctlx_cmdcb_t cmdcb,
-	ctlx_usercb_t usercb,
-	void	*usercb_data)
+hfa384x_dorrid(hfa384x_t *hw,
+	       CMD_MODE mode,
+	       u16 rid,
+	       void *riddata,
+	       unsigned int riddatalen,
+	       ctlx_cmdcb_t cmdcb, ctlx_usercb_t usercb, void *usercb_data)
 {
-	int			result;
-	hfa384x_usbctlx_t	*ctlx;
+	int result;
+	hfa384x_usbctlx_t *ctlx;
 
 	ctlx = usbctlx_alloc();
-	if ( ctlx == NULL ) {
+	if (ctlx == NULL) {
 		result = -ENOMEM;
 		goto done;
 	}
 
 	/* Initialize the command */
-	ctlx->outbuf.rridreq.type =   host2hfa384x_16(HFA384x_USB_RRIDREQ);
+	ctlx->outbuf.rridreq.type = host2hfa384x_16(HFA384x_USB_RRIDREQ);
 	ctlx->outbuf.rridreq.frmlen =
-		host2hfa384x_16(sizeof(ctlx->outbuf.rridreq.rid));
-	ctlx->outbuf.rridreq.rid =    host2hfa384x_16(rid);
+	    host2hfa384x_16(sizeof(ctlx->outbuf.rridreq.rid));
+	ctlx->outbuf.rridreq.rid = host2hfa384x_16(rid);
 
 	ctlx->outbufsize = sizeof(ctlx->outbuf.rridreq);
 
@@ -1669,18 +1556,18 @@ hfa384x_dorrid(
 	} else if (mode == DOWAIT) {
 		usbctlx_rrid_completor_t completor;
 
-		result = hfa384x_usbctlx_complete_sync(
-		           hw, ctlx, init_rrid_completor(&completor,
-		                                         &ctlx->inbuf.rridresp,
-		                                         riddata,
-		                                         riddatalen) );
+		result =
+		    hfa384x_usbctlx_complete_sync(hw, ctlx,
+						  init_rrid_completor
+						  (&completor,
+						   &ctlx->inbuf.rridresp,
+						   riddata, riddatalen));
 	}
 
 done:
 	return result;
 }
 
-
 /*----------------------------------------------------------------
 * hfa384x_dowrid
 *
@@ -1714,37 +1601,34 @@ hfa384x_dorrid(
 *	process (DOWAIT or DOASYNC)
 ----------------------------------------------------------------*/
 static int
-hfa384x_dowrid(
-	hfa384x_t *hw,
-	CMD_MODE mode,
-	u16	rid,
-	void	*riddata,
-	unsigned int	riddatalen,
-	ctlx_cmdcb_t cmdcb,
-	ctlx_usercb_t usercb,
-	void	*usercb_data)
+hfa384x_dowrid(hfa384x_t *hw,
+	       CMD_MODE mode,
+	       u16 rid,
+	       void *riddata,
+	       unsigned int riddatalen,
+	       ctlx_cmdcb_t cmdcb, ctlx_usercb_t usercb, void *usercb_data)
 {
-	int			result;
-	hfa384x_usbctlx_t	*ctlx;
+	int result;
+	hfa384x_usbctlx_t *ctlx;
 
 	ctlx = usbctlx_alloc();
-	if ( ctlx == NULL ) {
+	if (ctlx == NULL) {
 		result = -ENOMEM;
 		goto done;
 	}
 
 	/* Initialize the command */
-	ctlx->outbuf.wridreq.type =   host2hfa384x_16(HFA384x_USB_WRIDREQ);
-	ctlx->outbuf.wridreq.frmlen = host2hfa384x_16(
-					(sizeof(ctlx->outbuf.wridreq.rid) +
-					riddatalen + 1) / 2);
-	ctlx->outbuf.wridreq.rid =    host2hfa384x_16(rid);
+	ctlx->outbuf.wridreq.type = host2hfa384x_16(HFA384x_USB_WRIDREQ);
+	ctlx->outbuf.wridreq.frmlen = host2hfa384x_16((sizeof
+						       (ctlx->outbuf.wridreq.
+							rid) + riddatalen +
+						       1) / 2);
+	ctlx->outbuf.wridreq.rid = host2hfa384x_16(rid);
 	memcpy(ctlx->outbuf.wridreq.data, riddata, riddatalen);
 
 	ctlx->outbufsize = sizeof(ctlx->outbuf.wridreq.type) +
-	                   sizeof(ctlx->outbuf.wridreq.frmlen) +
-	                   sizeof(ctlx->outbuf.wridreq.rid) +
-	                   riddatalen;
+	    sizeof(ctlx->outbuf.wridreq.frmlen) +
+	    sizeof(ctlx->outbuf.wridreq.rid) + riddatalen;
 
 	ctlx->reapable = mode;
 	ctlx->cmdcb = cmdcb;
@@ -1759,12 +1643,12 @@ hfa384x_dowrid(
 		usbctlx_wrid_completor_t completor;
 		hfa384x_cmdresult_t wridresult;
 
-		result = hfa384x_usbctlx_complete_sync(
-		               hw,
-		               ctlx,
-		               init_wrid_completor(&completor,
-		                                   &ctlx->inbuf.wridresp,
-		                                   &wridresult) );
+		result = hfa384x_usbctlx_complete_sync(hw,
+						       ctlx,
+						       init_wrid_completor
+						       (&completor,
+							&ctlx->inbuf.wridresp,
+							&wridresult));
 	}
 
 done:
@@ -1805,46 +1689,41 @@ hfa384x_dowrid(
 *	process (DOWAIT or DOASYNC)
 ----------------------------------------------------------------*/
 static int
-hfa384x_dormem(
-	hfa384x_t *hw,
-	CMD_MODE mode,
-	u16	page,
-	u16	offset,
-	void	*data,
-	unsigned int	len,
-	ctlx_cmdcb_t cmdcb,
-	ctlx_usercb_t usercb,
-	void	*usercb_data)
+hfa384x_dormem(hfa384x_t *hw,
+	       CMD_MODE mode,
+	       u16 page,
+	       u16 offset,
+	       void *data,
+	       unsigned int len,
+	       ctlx_cmdcb_t cmdcb, ctlx_usercb_t usercb, void *usercb_data)
 {
-	int			result;
-	hfa384x_usbctlx_t	*ctlx;
+	int result;
+	hfa384x_usbctlx_t *ctlx;
 
 	ctlx = usbctlx_alloc();
-	if ( ctlx == NULL ) {
+	if (ctlx == NULL) {
 		result = -ENOMEM;
 		goto done;
 	}
 
 	/* Initialize the command */
-	ctlx->outbuf.rmemreq.type =    host2hfa384x_16(HFA384x_USB_RMEMREQ);
-	ctlx->outbuf.rmemreq.frmlen =  host2hfa384x_16(
-					sizeof(ctlx->outbuf.rmemreq.offset) +
-					sizeof(ctlx->outbuf.rmemreq.page) +
-					len);
-	ctlx->outbuf.rmemreq.offset =	host2hfa384x_16(offset);
-	ctlx->outbuf.rmemreq.page =	host2hfa384x_16(page);
+	ctlx->outbuf.rmemreq.type = host2hfa384x_16(HFA384x_USB_RMEMREQ);
+	ctlx->outbuf.rmemreq.frmlen =
+	    host2hfa384x_16(sizeof(ctlx->outbuf.rmemreq.offset) +
+			    sizeof(ctlx->outbuf.rmemreq.page) + len);
+	ctlx->outbuf.rmemreq.offset = host2hfa384x_16(offset);
+	ctlx->outbuf.rmemreq.page = host2hfa384x_16(page);
 
 	ctlx->outbufsize = sizeof(ctlx->outbuf.rmemreq);
 
-	pr_debug(
-		"type=0x%04x frmlen=%d offset=0x%04x page=0x%04x\n",
-		ctlx->outbuf.rmemreq.type,
-		ctlx->outbuf.rmemreq.frmlen,
-		ctlx->outbuf.rmemreq.offset,
-		ctlx->outbuf.rmemreq.page);
+	printk(KERN_DEBUG
+	       "type=0x%04x frmlen=%d offset=0x%04x page=0x%04x\n",
+	       ctlx->outbuf.rmemreq.type,
+	       ctlx->outbuf.rmemreq.frmlen,
+	       ctlx->outbuf.rmemreq.offset, ctlx->outbuf.rmemreq.page);
 
 	pr_debug("pktsize=%zd\n",
-		ROUNDUP64(sizeof(ctlx->outbuf.rmemreq)));
+	       ROUNDUP64(sizeof(ctlx->outbuf.rmemreq)));
 
 	ctlx->reapable = mode;
 	ctlx->cmdcb = cmdcb;
@@ -1854,22 +1733,21 @@ hfa384x_dormem(
 	result = hfa384x_usbctlx_submit(hw, ctlx);
 	if (result != 0) {
 		kfree(ctlx);
-	} else if ( mode == DOWAIT ) {
-                usbctlx_rmem_completor_t completor;
-
-                result = hfa384x_usbctlx_complete_sync(
-                           hw, ctlx, init_rmem_completor(&completor,
-                                                         &ctlx->inbuf.rmemresp,
-                                                         data,
-                                                         len) );
+	} else if (mode == DOWAIT) {
+		usbctlx_rmem_completor_t completor;
+
+		result =
+		    hfa384x_usbctlx_complete_sync(hw, ctlx,
+						  init_rmem_completor
+						  (&completor,
+						   &ctlx->inbuf.rmemresp, data,
+						   len));
 	}
 
 done:
 	return result;
 }
 
-
-
 /*----------------------------------------------------------------
 * hfa384x_dowmem
 *
@@ -1904,44 +1782,39 @@ hfa384x_dormem(
 *	process (DOWAIT or DOASYNC)
 ----------------------------------------------------------------*/
 static int
-hfa384x_dowmem(
-	hfa384x_t *hw,
-	CMD_MODE mode,
-	u16	page,
-	u16	offset,
-	void	*data,
-	unsigned int	len,
-	ctlx_cmdcb_t cmdcb,
-	ctlx_usercb_t usercb,
-	void	*usercb_data)
+hfa384x_dowmem(hfa384x_t *hw,
+	       CMD_MODE mode,
+	       u16 page,
+	       u16 offset,
+	       void *data,
+	       unsigned int len,
+	       ctlx_cmdcb_t cmdcb, ctlx_usercb_t usercb, void *usercb_data)
 {
-	int			result;
-	hfa384x_usbctlx_t	*ctlx;
+	int result;
+	hfa384x_usbctlx_t *ctlx;
 
 	pr_debug("page=0x%04x offset=0x%04x len=%d\n",
-		page,offset,len);
+	       page, offset, len);
 
 	ctlx = usbctlx_alloc();
-	if ( ctlx == NULL ) {
+	if (ctlx == NULL) {
 		result = -ENOMEM;
 		goto done;
 	}
 
 	/* Initialize the command */
-	ctlx->outbuf.wmemreq.type =   host2hfa384x_16(HFA384x_USB_WMEMREQ);
-	ctlx->outbuf.wmemreq.frmlen = host2hfa384x_16(
-					sizeof(ctlx->outbuf.wmemreq.offset) +
-					sizeof(ctlx->outbuf.wmemreq.page) +
-					len);
+	ctlx->outbuf.wmemreq.type = host2hfa384x_16(HFA384x_USB_WMEMREQ);
+	ctlx->outbuf.wmemreq.frmlen =
+	    host2hfa384x_16(sizeof(ctlx->outbuf.wmemreq.offset) +
+			    sizeof(ctlx->outbuf.wmemreq.page) + len);
 	ctlx->outbuf.wmemreq.offset = host2hfa384x_16(offset);
-	ctlx->outbuf.wmemreq.page =   host2hfa384x_16(page);
+	ctlx->outbuf.wmemreq.page = host2hfa384x_16(page);
 	memcpy(ctlx->outbuf.wmemreq.data, data, len);
 
 	ctlx->outbufsize = sizeof(ctlx->outbuf.wmemreq.type) +
-	                   sizeof(ctlx->outbuf.wmemreq.frmlen) +
-	                   sizeof(ctlx->outbuf.wmemreq.offset) +
-	                   sizeof(ctlx->outbuf.wmemreq.page) +
-	                   len;
+	    sizeof(ctlx->outbuf.wmemreq.frmlen) +
+	    sizeof(ctlx->outbuf.wmemreq.offset) +
+	    sizeof(ctlx->outbuf.wmemreq.page) + len;
 
 	ctlx->reapable = mode;
 	ctlx->cmdcb = cmdcb;
@@ -1951,23 +1824,22 @@ hfa384x_dowmem(
 	result = hfa384x_usbctlx_submit(hw, ctlx);
 	if (result != 0) {
 		kfree(ctlx);
-	} else if ( mode == DOWAIT ) {
-                usbctlx_wmem_completor_t completor;
-                hfa384x_cmdresult_t wmemresult;
-
-                result = hfa384x_usbctlx_complete_sync(
-                               hw,
-                               ctlx,
-                               init_wmem_completor(&completor,
-                                                   &ctlx->inbuf.wmemresp,
-                                                   &wmemresult) );
+	} else if (mode == DOWAIT) {
+		usbctlx_wmem_completor_t completor;
+		hfa384x_cmdresult_t wmemresult;
+
+		result = hfa384x_usbctlx_complete_sync(hw,
+						       ctlx,
+						       init_wmem_completor
+						       (&completor,
+							&ctlx->inbuf.wmemresp,
+							&wmemresult));
 	}
 
 done:
 	return result;
 }
 
-
 /*----------------------------------------------------------------
 * hfa384x_drvr_commtallies
 *
@@ -1985,7 +1857,7 @@ hfa384x_dowmem(
 * Call context:
 *	process
 ----------------------------------------------------------------*/
-int hfa384x_drvr_commtallies( hfa384x_t *hw )
+int hfa384x_drvr_commtallies(hfa384x_t *hw)
 {
 	hfa384x_metacmd_t cmd;
 
@@ -1999,7 +1871,6 @@ int hfa384x_drvr_commtallies( hfa384x_t *hw )
 	return 0;
 }
 
-
 /*----------------------------------------------------------------
 * hfa384x_drvr_disable
 *
@@ -2024,22 +1895,20 @@ int hfa384x_drvr_commtallies( hfa384x_t *hw )
 ----------------------------------------------------------------*/
 int hfa384x_drvr_disable(hfa384x_t *hw, u16 macport)
 {
-	int	result = 0;
+	int result = 0;
 
 	if ((!hw->isap && macport != 0) ||
 	    (hw->isap && !(macport <= HFA384x_PORTID_MAX)) ||
-	    !(hw->port_enabled[macport]) ){
+	    !(hw->port_enabled[macport])) {
 		result = -EINVAL;
 	} else {
 		result = hfa384x_cmd_disable(hw, macport);
-		if ( result == 0 ) {
+		if (result == 0)
 			hw->port_enabled[macport] = 0;
-		}
 	}
 	return result;
 }
 
-
 /*----------------------------------------------------------------
 * hfa384x_drvr_enable
 *
@@ -2064,22 +1933,20 @@ int hfa384x_drvr_disable(hfa384x_t *hw, u16 macport)
 ----------------------------------------------------------------*/
 int hfa384x_drvr_enable(hfa384x_t *hw, u16 macport)
 {
-	int	result = 0;
+	int result = 0;
 
 	if ((!hw->isap && macport != 0) ||
 	    (hw->isap && !(macport <= HFA384x_PORTID_MAX)) ||
-	    (hw->port_enabled[macport]) ){
+	    (hw->port_enabled[macport])) {
 		result = -EINVAL;
 	} else {
 		result = hfa384x_cmd_enable(hw, macport);
-		if ( result == 0 ) {
+		if (result == 0)
 			hw->port_enabled[macport] = 1;
-		}
 	}
 	return result;
 }
 
-
 /*----------------------------------------------------------------
 * hfa384x_drvr_flashdl_enable
 *
@@ -2103,32 +1970,32 @@ int hfa384x_drvr_enable(hfa384x_t *hw, u16 macport)
 ----------------------------------------------------------------*/
 int hfa384x_drvr_flashdl_enable(hfa384x_t *hw)
 {
-	int		result = 0;
-	int		i;
+	int result = 0;
+	int i;
 
 	/* Check that a port isn't active */
-	for ( i = 0; i < HFA384x_PORTID_MAX; i++) {
-		if ( hw->port_enabled[i] ) {
+	for (i = 0; i < HFA384x_PORTID_MAX; i++) {
+		if (hw->port_enabled[i]) {
 			pr_debug("called when port enabled.\n");
 			return -EINVAL;
 		}
 	}
 
 	/* Check that we're not already in a download state */
-	if ( hw->dlstate != HFA384x_DLSTATE_DISABLED ) {
+	if (hw->dlstate != HFA384x_DLSTATE_DISABLED)
 		return -EINVAL;
-	}
 
 	/* Retrieve the buffer loc&size and timeout */
-	if ( (result = hfa384x_drvr_getconfig(hw, HFA384x_RID_DOWNLOADBUFFER,
-				&(hw->bufinfo), sizeof(hw->bufinfo))) ) {
+	if ((result = hfa384x_drvr_getconfig(hw, HFA384x_RID_DOWNLOADBUFFER,
+					     &(hw->bufinfo),
+					     sizeof(hw->bufinfo)))) {
 		return result;
 	}
 	hw->bufinfo.page = hfa384x2host_16(hw->bufinfo.page);
 	hw->bufinfo.offset = hfa384x2host_16(hw->bufinfo.offset);
 	hw->bufinfo.len = hfa384x2host_16(hw->bufinfo.len);
-	if ( (result = hfa384x_drvr_getconfig16(hw, HFA384x_RID_MAXLOADTIME,
-				&(hw->dltimeout))) ) {
+	if ((result = hfa384x_drvr_getconfig16(hw, HFA384x_RID_MAXLOADTIME,
+					       &(hw->dltimeout)))) {
 		return result;
 	}
 	hw->dltimeout = hfa384x2host_16(hw->dltimeout);
@@ -2140,7 +2007,6 @@ int hfa384x_drvr_flashdl_enable(hfa384x_t *hw)
 	return result;
 }
 
-
 /*----------------------------------------------------------------
 * hfa384x_drvr_flashdl_disable
 *
@@ -2163,21 +2029,19 @@ int hfa384x_drvr_flashdl_enable(hfa384x_t *hw)
 int hfa384x_drvr_flashdl_disable(hfa384x_t *hw)
 {
 	/* Check that we're already in the download state */
-	if ( hw->dlstate != HFA384x_DLSTATE_FLASHENABLED ) {
+	if (hw->dlstate != HFA384x_DLSTATE_FLASHENABLED)
 		return -EINVAL;
-	}
 
 	pr_debug("flashdl_enable\n");
 
 	/* There isn't much we can do at this point, so I don't */
 	/*  bother  w/ the return value */
-	hfa384x_cmd_download(hw, HFA384x_PROGMODE_DISABLE, 0, 0 , 0);
+	hfa384x_cmd_download(hw, HFA384x_PROGMODE_DISABLE, 0, 0, 0);
 	hw->dlstate = HFA384x_DLSTATE_DISABLED;
 
 	return 0;
 }
 
-
 /*----------------------------------------------------------------
 * hfa384x_drvr_flashdl_write
 *
@@ -2207,47 +2071,42 @@ int hfa384x_drvr_flashdl_disable(hfa384x_t *hw)
 * Call context:
 *	process
 ----------------------------------------------------------------*/
-int
-hfa384x_drvr_flashdl_write(
-	hfa384x_t	*hw,
-	u32		daddr,
-	void		*buf,
-	u32		len)
+int hfa384x_drvr_flashdl_write(hfa384x_t *hw, u32 daddr, void *buf, u32 len)
 {
-	int		result = 0;
-	u32		dlbufaddr;
-	int		nburns;
-	u32		burnlen;
-	u32		burndaddr;
-	u16		burnlo;
-	u16		burnhi;
-	int		nwrites;
-	u8		*writebuf;
-	u16		writepage;
-	u16		writeoffset;
-	u32		writelen;
-	int		i;
-	int		j;
+	int result = 0;
+	u32 dlbufaddr;
+	int nburns;
+	u32 burnlen;
+	u32 burndaddr;
+	u16 burnlo;
+	u16 burnhi;
+	int nwrites;
+	u8 *writebuf;
+	u16 writepage;
+	u16 writeoffset;
+	u32 writelen;
+	int i;
+	int j;
 
 	pr_debug("daddr=0x%08x len=%d\n", daddr, len);
 
 	/* Check that we're in the flash download state */
-	if ( hw->dlstate != HFA384x_DLSTATE_FLASHENABLED ) {
+	if (hw->dlstate != HFA384x_DLSTATE_FLASHENABLED)
 		return -EINVAL;
-	}
 
 	printk(KERN_INFO "Download %d bytes to flash @0x%06x\n", len, daddr);
 
 	/* Convert to flat address for arithmetic */
 	/* NOTE: dlbuffer RID stores the address in AUX format */
-	dlbufaddr = HFA384x_ADDR_AUX_MKFLAT(
-			hw->bufinfo.page, hw->bufinfo.offset);
-	pr_debug(
-		"dlbuf.page=0x%04x dlbuf.offset=0x%04x dlbufaddr=0x%08x\n",
-		hw->bufinfo.page, hw->bufinfo.offset, dlbufaddr);
+	dlbufaddr =
+	    HFA384x_ADDR_AUX_MKFLAT(hw->bufinfo.page, hw->bufinfo.offset);
+	printk(KERN_DEBUG
+	       "dlbuf.page=0x%04x dlbuf.offset=0x%04x dlbufaddr=0x%08x\n",
+	       hw->bufinfo.page, hw->bufinfo.offset, dlbufaddr);
 
 #if 0
-printk(KERN_WARNING "dlbuf@0x%06lx len=%d to=%d\n", dlbufaddr, hw->bufinfo.len, hw->dltimeout);
+	printk(KERN_WARNING "dlbuf@0x%06lx len=%d to=%d\n", dlbufaddr,
+	       hw->bufinfo.len, hw->dltimeout);
 #endif
 	/* Calculations to determine how many fills of the dlbuffer to do
 	 * and how many USB wmemreq's to do for each fill.  At this point
@@ -2265,62 +2124,60 @@ printk(KERN_WARNING "dlbuf@0x%06lx len=%d to=%d\n", dlbufaddr, hw->bufinfo.len,
 	nwrites += (hw->bufinfo.len % HFA384x_USB_RWMEM_MAXLEN) ? 1 : 0;
 
 	/* For each burn */
-	for ( i = 0; i < nburns; i++) {
+	for (i = 0; i < nburns; i++) {
 		/* Get the dest address and len */
 		burnlen = (len - (hw->bufinfo.len * i)) > hw->bufinfo.len ?
-				hw->bufinfo.len :
-				(len - (hw->bufinfo.len * i));
+		    hw->bufinfo.len : (len - (hw->bufinfo.len * i));
 		burndaddr = daddr + (hw->bufinfo.len * i);
 		burnlo = HFA384x_ADDR_CMD_MKOFF(burndaddr);
 		burnhi = HFA384x_ADDR_CMD_MKPAGE(burndaddr);
 
 		printk(KERN_INFO "Writing %d bytes to flash @0x%06x\n",
-			burnlen, burndaddr);
+		       burnlen, burndaddr);
 
 		/* Set the download mode */
 		result = hfa384x_cmd_download(hw, HFA384x_PROGMODE_NV,
-				burnlo, burnhi, burnlen);
-		if ( result ) {
+					      burnlo, burnhi, burnlen);
+		if (result) {
 			printk(KERN_ERR "download(NV,lo=%x,hi=%x,len=%x) "
-				"cmd failed, result=%d. Aborting d/l\n",
-				burnlo, burnhi, burnlen, result);
+			       "cmd failed, result=%d. Aborting d/l\n",
+			       burnlo, burnhi, burnlen, result);
 			goto exit_proc;
 		}
 
 		/* copy the data to the flash download buffer */
-		for ( j=0; j < nwrites; j++) {
+		for (j = 0; j < nwrites; j++) {
 			writebuf = buf +
-				(i*hw->bufinfo.len) +
-				(j*HFA384x_USB_RWMEM_MAXLEN);
-
-			writepage = HFA384x_ADDR_CMD_MKPAGE(
-					dlbufaddr +
-					(j*HFA384x_USB_RWMEM_MAXLEN));
-			writeoffset = HFA384x_ADDR_CMD_MKOFF(
-					dlbufaddr +
-					(j*HFA384x_USB_RWMEM_MAXLEN));
-
-			writelen = burnlen-(j*HFA384x_USB_RWMEM_MAXLEN);
-			writelen = writelen  > HFA384x_USB_RWMEM_MAXLEN ?
-					HFA384x_USB_RWMEM_MAXLEN :
-					writelen;
-
-			result = hfa384x_dowmem_wait( hw,
-					writepage,
-					writeoffset,
-					writebuf,
-					writelen );
+			    (i * hw->bufinfo.len) +
+			    (j * HFA384x_USB_RWMEM_MAXLEN);
+
+			writepage = HFA384x_ADDR_CMD_MKPAGE(dlbufaddr +
+							    (j *
+							     HFA384x_USB_RWMEM_MAXLEN));
+			writeoffset =
+			    HFA384x_ADDR_CMD_MKOFF(dlbufaddr +
+						   (j *
+						    HFA384x_USB_RWMEM_MAXLEN));
+
+			writelen = burnlen - (j * HFA384x_USB_RWMEM_MAXLEN);
+			writelen = writelen > HFA384x_USB_RWMEM_MAXLEN ?
+			    HFA384x_USB_RWMEM_MAXLEN : writelen;
+
+			result = hfa384x_dowmem_wait(hw,
+						     writepage,
+						     writeoffset,
+						     writebuf, writelen);
 		}
 
 		/* set the download 'write flash' mode */
 		result = hfa384x_cmd_download(hw,
-				HFA384x_PROGMODE_NVWRITE,
-				0,0,0);
-		if ( result ) {
+					      HFA384x_PROGMODE_NVWRITE,
+					      0, 0, 0);
+		if (result) {
 			printk(KERN_ERR
-				"download(NVWRITE,lo=%x,hi=%x,len=%x) "
-				"cmd failed, result=%d. Aborting d/l\n",
-				burnlo, burnhi, burnlen, result);
+			       "download(NVWRITE,lo=%x,hi=%x,len=%x) "
+			       "cmd failed, result=%d. Aborting d/l\n",
+			       burnlo, burnhi, burnlen, result);
 			goto exit_proc;
 		}
 
@@ -2336,7 +2193,6 @@ printk(KERN_WARNING "dlbuf@0x%06lx len=%d to=%d\n", dlbufaddr, hw->bufinfo.len,
 	return result;
 }
 
-
 /*----------------------------------------------------------------
 * hfa384x_drvr_getconfig
 *
@@ -2364,7 +2220,7 @@ printk(KERN_WARNING "dlbuf@0x%06lx len=%d to=%d\n", dlbufaddr, hw->bufinfo.len,
 ----------------------------------------------------------------*/
 int hfa384x_drvr_getconfig(hfa384x_t *hw, u16 rid, void *buf, u16 len)
 {
-	int 			result;
+	int result;
 
 	result = hfa384x_dorrid_wait(hw, rid, buf, len);
 
@@ -2399,14 +2255,11 @@ int hfa384x_drvr_getconfig(hfa384x_t *hw, u16 rid, void *buf, u16 len)
  *       Any
  ----------------------------------------------------------------*/
 int
-hfa384x_drvr_getconfig_async(
-         hfa384x_t               *hw,
-         u16                  rid,
-         ctlx_usercb_t           usercb,
-         void                    *usercb_data)
+hfa384x_drvr_getconfig_async(hfa384x_t *hw,
+			     u16 rid, ctlx_usercb_t usercb, void *usercb_data)
 {
-         return hfa384x_dorrid_async(hw, rid, NULL, 0,
-				     hfa384x_cb_rrid, usercb, usercb_data);
+	return hfa384x_dorrid_async(hw, rid, NULL, 0,
+				    hfa384x_cb_rrid, usercb, usercb_data);
 }
 
 /*----------------------------------------------------------------
@@ -2433,13 +2286,10 @@ hfa384x_drvr_getconfig_async(
  *       process
  ----------------------------------------------------------------*/
 int
-hfa384x_drvr_setconfig_async(
-         hfa384x_t       *hw,
-         u16          rid,
-         void            *buf,
-         u16          len,
-         ctlx_usercb_t   usercb,
-         void            *usercb_data)
+hfa384x_drvr_setconfig_async(hfa384x_t *hw,
+			     u16 rid,
+			     void *buf,
+			     u16 len, ctlx_usercb_t usercb, void *usercb_data)
 {
 	return hfa384x_dowrid_async(hw, rid, buf, len,
 				    hfa384x_cb_status, usercb, usercb_data);
@@ -2464,7 +2314,7 @@ hfa384x_drvr_setconfig_async(
 * Call context:
 *	process
 ----------------------------------------------------------------*/
-int hfa384x_drvr_handover( hfa384x_t *hw, u8 *addr)
+int hfa384x_drvr_handover(hfa384x_t *hw, u8 *addr)
 {
 	printk(KERN_ERR "Not currently supported in USB!\n");
 	return -EIO;
@@ -2488,25 +2338,22 @@ int hfa384x_drvr_handover( hfa384x_t *hw, u8 *addr)
 * Call context:
 *	process
 ----------------------------------------------------------------*/
-int
-hfa384x_drvr_ramdl_disable(hfa384x_t *hw)
+int hfa384x_drvr_ramdl_disable(hfa384x_t *hw)
 {
 	/* Check that we're already in the download state */
-	if ( hw->dlstate != HFA384x_DLSTATE_RAMENABLED ) {
+	if (hw->dlstate != HFA384x_DLSTATE_RAMENABLED)
 		return -EINVAL;
-	}
 
 	pr_debug("ramdl_disable()\n");
 
 	/* There isn't much we can do at this point, so I don't */
 	/*  bother  w/ the return value */
-	hfa384x_cmd_download(hw, HFA384x_PROGMODE_DISABLE, 0, 0 , 0);
+	hfa384x_cmd_download(hw, HFA384x_PROGMODE_DISABLE, 0, 0, 0);
 	hw->dlstate = HFA384x_DLSTATE_DISABLED;
 
 	return 0;
 }
 
-
 /*----------------------------------------------------------------
 * hfa384x_drvr_ramdl_enable
 *
@@ -2531,27 +2378,25 @@ hfa384x_drvr_ramdl_disable(hfa384x_t *hw)
 * Call context:
 *	process
 ----------------------------------------------------------------*/
-int
-hfa384x_drvr_ramdl_enable(hfa384x_t *hw, u32 exeaddr)
+int hfa384x_drvr_ramdl_enable(hfa384x_t *hw, u32 exeaddr)
 {
-	int		result = 0;
-	u16		lowaddr;
-	u16		hiaddr;
-	int		i;
+	int result = 0;
+	u16 lowaddr;
+	u16 hiaddr;
+	int i;
 
 	/* Check that a port isn't active */
-	for ( i = 0; i < HFA384x_PORTID_MAX; i++) {
-		if ( hw->port_enabled[i] ) {
+	for (i = 0; i < HFA384x_PORTID_MAX; i++) {
+		if (hw->port_enabled[i]) {
 			printk(KERN_ERR
-				"Can't download with a macport enabled.\n");
+			       "Can't download with a macport enabled.\n");
 			return -EINVAL;
 		}
 	}
 
 	/* Check that we're not already in a download state */
-	if ( hw->dlstate != HFA384x_DLSTATE_DISABLED ) {
-		printk(KERN_ERR
-			"Download state not disabled.\n");
+	if (hw->dlstate != HFA384x_DLSTATE_DISABLED) {
+		printk(KERN_ERR "Download state not disabled.\n");
 		return -EINVAL;
 	}
 
@@ -2559,26 +2404,23 @@ hfa384x_drvr_ramdl_enable(hfa384x_t *hw, u32 exeaddr)
 
 	/* Call the download(1,addr) function */
 	lowaddr = HFA384x_ADDR_CMD_MKOFF(exeaddr);
-	hiaddr =  HFA384x_ADDR_CMD_MKPAGE(exeaddr);
+	hiaddr = HFA384x_ADDR_CMD_MKPAGE(exeaddr);
 
 	result = hfa384x_cmd_download(hw, HFA384x_PROGMODE_RAM,
-			lowaddr, hiaddr, 0);
+				      lowaddr, hiaddr, 0);
 
-	if ( result == 0) {
+	if (result == 0) {
 		/* Set the download state */
 		hw->dlstate = HFA384x_DLSTATE_RAMENABLED;
 	} else {
-		pr_debug(
-			"cmd_download(0x%04x, 0x%04x) failed, result=%d.\n",
-			lowaddr,
-			hiaddr,
-			result);
+		printk(KERN_DEBUG
+		       "cmd_download(0x%04x, 0x%04x) failed, result=%d.\n",
+		       lowaddr, hiaddr, result);
 	}
 
 	return result;
 }
 
-
 /*----------------------------------------------------------------
 * hfa384x_drvr_ramdl_write
 *
@@ -2605,22 +2447,20 @@ hfa384x_drvr_ramdl_enable(hfa384x_t *hw, u32 exeaddr)
 * Call context:
 *	process
 ----------------------------------------------------------------*/
-int
-hfa384x_drvr_ramdl_write(hfa384x_t *hw, u32 daddr, void* buf, u32 len)
+int hfa384x_drvr_ramdl_write(hfa384x_t *hw, u32 daddr, void *buf, u32 len)
 {
-	int		result = 0;
-	int		nwrites;
-	u8		*data = buf;
-	int		i;
-	u32		curraddr;
-	u16		currpage;
-	u16		curroffset;
-	u16		currlen;
+	int result = 0;
+	int nwrites;
+	u8 *data = buf;
+	int i;
+	u32 curraddr;
+	u16 currpage;
+	u16 curroffset;
+	u16 currlen;
 
 	/* Check that we're in the ram download state */
-	if ( hw->dlstate != HFA384x_DLSTATE_RAMENABLED ) {
+	if (hw->dlstate != HFA384x_DLSTATE_RAMENABLED)
 		return -EINVAL;
-	}
 
 	printk(KERN_INFO "Writing %d bytes to ram @0x%06x\n", len, daddr);
 
@@ -2629,24 +2469,25 @@ hfa384x_drvr_ramdl_write(hfa384x_t *hw, u32 daddr, void* buf, u32 len)
 	nwrites += len % HFA384x_USB_RWMEM_MAXLEN ? 1 : 0;
 
 	/* Do blocking wmem's */
-	for(i=0; i < nwrites; i++) {
+	for (i = 0; i < nwrites; i++) {
 		/* make address args */
 		curraddr = daddr + (i * HFA384x_USB_RWMEM_MAXLEN);
 		currpage = HFA384x_ADDR_CMD_MKPAGE(curraddr);
 		curroffset = HFA384x_ADDR_CMD_MKOFF(curraddr);
 		currlen = len - (i * HFA384x_USB_RWMEM_MAXLEN);
-		if ( currlen > HFA384x_USB_RWMEM_MAXLEN) {
+		if (currlen > HFA384x_USB_RWMEM_MAXLEN)
 			currlen = HFA384x_USB_RWMEM_MAXLEN;
-		}
 
-	 	/* Do blocking ctlx */
-		result = hfa384x_dowmem_wait( hw,
-				currpage,
-				curroffset,
-				data + (i*HFA384x_USB_RWMEM_MAXLEN),
-				currlen );
+		/* Do blocking ctlx */
+		result = hfa384x_dowmem_wait(hw,
+					     currpage,
+					     curroffset,
+					     data +
+					     (i * HFA384x_USB_RWMEM_MAXLEN),
+					     currlen);
 
-		if (result) break;
+		if (result)
+			break;
 
 		/* TODO: We really should have a readback. */
 	}
@@ -2654,7 +2495,6 @@ hfa384x_drvr_ramdl_write(hfa384x_t *hw, u32 daddr, void* buf, u32 len)
 	return result;
 }
 
-
 /*----------------------------------------------------------------
 * hfa384x_drvr_readpda
 *
@@ -2688,98 +2528,89 @@ hfa384x_drvr_ramdl_write(hfa384x_t *hw, u32 daddr, void* buf, u32 len)
 ----------------------------------------------------------------*/
 int hfa384x_drvr_readpda(hfa384x_t *hw, void *buf, unsigned int len)
 {
-	int		result = 0;
-	u16		*pda = buf;
-	int		pdaok = 0;
-	int		morepdrs = 1;
-	int		currpdr = 0;	/* word offset of the current pdr */
-	size_t		i;
-	u16		pdrlen;		/* pdr length in bytes, host order */
-	u16		pdrcode;	/* pdr code, host order */
-	u16		currpage;
-	u16		curroffset;
+	int result = 0;
+	u16 *pda = buf;
+	int pdaok = 0;
+	int morepdrs = 1;
+	int currpdr = 0;	/* word offset of the current pdr */
+	size_t i;
+	u16 pdrlen;		/* pdr length in bytes, host order */
+	u16 pdrcode;		/* pdr code, host order */
+	u16 currpage;
+	u16 curroffset;
 	struct pdaloc {
-		u32	cardaddr;
-		u16	auxctl;
-	} pdaloc[] =
-	{
-		{ HFA3842_PDA_BASE,		0},
-		{ HFA3841_PDA_BASE,		0},
-		{ HFA3841_PDA_BOGUS_BASE,	0}
+		u32 cardaddr;
+		u16 auxctl;
+	} pdaloc[] = {
+		{
+		HFA3842_PDA_BASE, 0}, {
+		HFA3841_PDA_BASE, 0}, {
+		HFA3841_PDA_BOGUS_BASE, 0}
 	};
 
 	/* Read the pda from each known address.  */
-	for ( i = 0; i < ARRAY_SIZE(pdaloc); i++) {
+	for (i = 0; i < ARRAY_SIZE(pdaloc); i++) {
 		/* Make address */
 		currpage = HFA384x_ADDR_CMD_MKPAGE(pdaloc[i].cardaddr);
 		curroffset = HFA384x_ADDR_CMD_MKOFF(pdaloc[i].cardaddr);
 
-		result = hfa384x_dormem_wait(hw,
-			currpage,
-			curroffset,
-			buf,
-			len);		/* units of bytes */
+		result = hfa384x_dormem_wait(hw, currpage, curroffset, buf, len);	/* units of bytes */
 
 		if (result) {
 			printk(KERN_WARNING
-					  "Read from index %zd failed, continuing\n",
-				i );
+			       "Read from index %zd failed, continuing\n", i);
 			continue;
 		}
 
 		/* Test for garbage */
 		pdaok = 1;	/* initially assume good */
 		morepdrs = 1;
-		while ( pdaok && morepdrs ) {
+		while (pdaok && morepdrs) {
 			pdrlen = hfa384x2host_16(pda[currpdr]) * 2;
-			pdrcode = hfa384x2host_16(pda[currpdr+1]);
+			pdrcode = hfa384x2host_16(pda[currpdr + 1]);
 			/* Test the record length */
-			if ( pdrlen > HFA384x_PDR_LEN_MAX || pdrlen == 0) {
-				printk(KERN_ERR "pdrlen invalid=%d\n",
-					pdrlen);
+			if (pdrlen > HFA384x_PDR_LEN_MAX || pdrlen == 0) {
+				printk(KERN_ERR "pdrlen invalid=%d\n", pdrlen);
 				pdaok = 0;
 				break;
 			}
 			/* Test the code */
-			if ( !hfa384x_isgood_pdrcode(pdrcode) ) {
+			if (!hfa384x_isgood_pdrcode(pdrcode)) {
 				printk(KERN_ERR "pdrcode invalid=%d\n",
-					pdrcode);
+				       pdrcode);
 				pdaok = 0;
 				break;
 			}
 			/* Test for completion */
-			if ( pdrcode == HFA384x_PDR_END_OF_PDA) {
+			if (pdrcode == HFA384x_PDR_END_OF_PDA)
 				morepdrs = 0;
-			}
 
 			/* Move to the next pdr (if necessary) */
-			if ( morepdrs ) {
+			if (morepdrs) {
 				/* note the access to pda[], need words here */
 				currpdr += hfa384x2host_16(pda[currpdr]) + 1;
 			}
 		}
-		if ( pdaok ) {
+		if (pdaok) {
 			printk(KERN_INFO
-				"PDA Read from 0x%08x in %s space.\n",
-				pdaloc[i].cardaddr,
-				pdaloc[i].auxctl == 0 ? "EXTDS" :
-				pdaloc[i].auxctl == 1 ? "NV" :
-				pdaloc[i].auxctl == 2 ? "PHY" :
-				pdaloc[i].auxctl == 3 ? "ICSRAM" :
-				"<bogus auxctl>");
+			       "PDA Read from 0x%08x in %s space.\n",
+			       pdaloc[i].cardaddr,
+			       pdaloc[i].auxctl == 0 ? "EXTDS" :
+			       pdaloc[i].auxctl == 1 ? "NV" :
+			       pdaloc[i].auxctl == 2 ? "PHY" :
+			       pdaloc[i].auxctl == 3 ? "ICSRAM" :
+			       "<bogus auxctl>");
 			break;
 		}
 	}
 	result = pdaok ? 0 : -ENODATA;
 
-	if ( result ) {
+	if (result)
 		pr_debug("Failure: pda is not okay\n");
-	}
 
 	return result;
 }
 
-
 /*----------------------------------------------------------------
 * hfa384x_drvr_setconfig
 *
@@ -2828,8 +2659,8 @@ int hfa384x_drvr_setconfig(hfa384x_t *hw, u16 rid, void *buf, u16 len)
 
 int hfa384x_drvr_start(hfa384x_t *hw)
 {
-	int		result, result1, result2;
-	u16		status;
+	int result, result1, result2;
+	u16 status;
 
 	might_sleep();
 
@@ -2838,27 +2669,23 @@ int hfa384x_drvr_start(hfa384x_t *hw)
 	 * badly if a clear_halt is called when the endpoint is already
 	 * ok
 	 */
-	result = usb_get_status(hw->usb, USB_RECIP_ENDPOINT, hw->endp_in, &status);
+	result =
+	    usb_get_status(hw->usb, USB_RECIP_ENDPOINT, hw->endp_in, &status);
 	if (result < 0) {
-		printk(KERN_ERR
-			"Cannot get bulk in endpoint status.\n");
+		printk(KERN_ERR "Cannot get bulk in endpoint status.\n");
 		goto done;
 	}
-	if ((status == 1) && usb_clear_halt(hw->usb, hw->endp_in)) {
-		printk(KERN_ERR
-			"Failed to reset bulk in endpoint.\n");
-	}
+	if ((status == 1) && usb_clear_halt(hw->usb, hw->endp_in))
+		printk(KERN_ERR "Failed to reset bulk in endpoint.\n");
 
-	result = usb_get_status(hw->usb, USB_RECIP_ENDPOINT, hw->endp_out, &status);
+	result =
+	    usb_get_status(hw->usb, USB_RECIP_ENDPOINT, hw->endp_out, &status);
 	if (result < 0) {
-		printk(KERN_ERR
-			"Cannot get bulk out endpoint status.\n");
+		printk(KERN_ERR "Cannot get bulk out endpoint status.\n");
 		goto done;
 	}
-	if ((status == 1) && usb_clear_halt(hw->usb, hw->endp_out)) {
-		printk(KERN_ERR
-			"Failed to reset bulk out endpoint.\n");
-	}
+	if ((status == 1) && usb_clear_halt(hw->usb, hw->endp_out))
+		printk(KERN_ERR "Failed to reset bulk out endpoint.\n");
 
 	/* Synchronous unlink, in case we're trying to restart the driver */
 	usb_kill_urb(&hw->rx_urb);
@@ -2867,8 +2694,7 @@ int hfa384x_drvr_start(hfa384x_t *hw)
 	result = submit_rx_urb(hw, GFP_KERNEL);
 	if (result != 0) {
 		printk(KERN_ERR
-			"Fatal, failed to submit RX URB, result=%d\n",
-			result);
+		       "Fatal, failed to submit RX URB, result=%d\n", result);
 		goto done;
 	}
 
@@ -2888,21 +2714,24 @@ int hfa384x_drvr_start(hfa384x_t *hw)
 	if (result1 != 0) {
 		if (result2 != 0) {
 			printk(KERN_ERR
-				"cmd_initialize() failed on two attempts, results %d and %d\n",
-				result1, result2);
+			       "cmd_initialize() failed on two attempts, results %d and %d\n",
+			       result1, result2);
 			usb_kill_urb(&hw->rx_urb);
 			goto done;
 		} else {
-			pr_debug("First cmd_initialize() failed (result %d),\n",
-				result1);
-			pr_debug("but second attempt succeeded. All should be ok\n");
+			printk(KERN_DEBUG
+			       "First cmd_initialize() failed (result %d),\n",
+			       result1);
+			printk(KERN_DEBUG
+			       "but second attempt succeeded. All should be ok\n");
 		}
 	} else if (result2 != 0) {
 		printk(KERN_WARNING
-			"First cmd_initialize() succeeded, but second attempt failed (result=%d)\n",
-			result2);
-		printk(KERN_WARNING "Most likely the card will be functional\n");
-			goto done;
+		       "First cmd_initialize() succeeded, but second attempt failed (result=%d)\n",
+		       result2);
+		printk(KERN_WARNING
+		       "Most likely the card will be functional\n");
+		goto done;
 	}
 
 	hw->state = HFA384x_STATE_RUNNING;
@@ -2911,7 +2740,6 @@ int hfa384x_drvr_start(hfa384x_t *hw)
 	return result;
 }
 
-
 /*----------------------------------------------------------------
 * hfa384x_drvr_stop
 *
@@ -2931,18 +2759,17 @@ int hfa384x_drvr_start(hfa384x_t *hw)
 * Call context:
 *	process
 ----------------------------------------------------------------*/
-int
-hfa384x_drvr_stop(hfa384x_t *hw)
+int hfa384x_drvr_stop(hfa384x_t *hw)
 {
-	int	result = 0;
-	int	i;
+	int result = 0;
+	int i;
 
 	might_sleep();
 
 	/* There's no need for spinlocks here. The USB "disconnect"
 	 * function sets this "removed" flag and then calls us.
 	 */
-	if ( !hw->wlandev->hwremoved ) {
+	if (!hw->wlandev->hwremoved) {
 		/* Call initialize to leave the MAC in its 'reset' state */
 		hfa384x_cmd_initialize(hw);
 
@@ -2956,9 +2783,8 @@ hfa384x_drvr_stop(hfa384x_t *hw)
 	del_timer_sync(&hw->commsqual_timer);
 
 	/* Clear all the port status */
-	for ( i = 0; i < HFA384x_NUMPORTS_MAX; i++) {
+	for (i = 0; i < HFA384x_NUMPORTS_MAX; i++)
 		hw->port_enabled[i] = 0;
-	}
 
 	return result;
 }
@@ -2984,13 +2810,14 @@ hfa384x_drvr_stop(hfa384x_t *hw)
 * Call context:
 *	interrupt
 ----------------------------------------------------------------*/
-int hfa384x_drvr_txframe(hfa384x_t *hw, struct sk_buff *skb, p80211_hdr_t *p80211_hdr, p80211_metawep_t *p80211_wep)
-
+int hfa384x_drvr_txframe(hfa384x_t *hw, struct sk_buff *skb,
+			 p80211_hdr_t *p80211_hdr,
+			 p80211_metawep_t *p80211_wep)
 {
-	int		usbpktlen = sizeof(hfa384x_tx_frame_t);
-	int		result;
-	int		ret;
-	char		*ptr;
+	int usbpktlen = sizeof(hfa384x_tx_frame_t);
+	int result;
+	int ret;
+	char *ptr;
 
 	if (hw->tx_urb.status == -EINPROGRESS) {
 		printk(KERN_WARNING "TX URB already in use\n");
@@ -3011,30 +2838,31 @@ int hfa384x_drvr_txframe(hfa384x_t *hw, struct sk_buff *skb, p80211_hdr_t *p8021
 /* Tx complete and Tx exception disable per dleach.  Might be causing
  * buf depletion
  */
-//#define DOEXC  SLP -- doboth breaks horribly under load, doexc less so.
+/* #define DOEXC  SLP -- doboth breaks horribly under load, doexc less so. */
 #if defined(DOBOTH)
 	hw->txbuff.txfrm.desc.tx_control =
-		HFA384x_TX_MACPORT_SET(0) | HFA384x_TX_STRUCTYPE_SET(1) |
-		HFA384x_TX_TXEX_SET(1) | HFA384x_TX_TXOK_SET(1);
+	    HFA384x_TX_MACPORT_SET(0) | HFA384x_TX_STRUCTYPE_SET(1) |
+	    HFA384x_TX_TXEX_SET(1) | HFA384x_TX_TXOK_SET(1);
 #elif defined(DOEXC)
 	hw->txbuff.txfrm.desc.tx_control =
-		HFA384x_TX_MACPORT_SET(0) | HFA384x_TX_STRUCTYPE_SET(1) |
-		HFA384x_TX_TXEX_SET(1) | HFA384x_TX_TXOK_SET(0);
+	    HFA384x_TX_MACPORT_SET(0) | HFA384x_TX_STRUCTYPE_SET(1) |
+	    HFA384x_TX_TXEX_SET(1) | HFA384x_TX_TXOK_SET(0);
 #else
 	hw->txbuff.txfrm.desc.tx_control =
-		HFA384x_TX_MACPORT_SET(0) | HFA384x_TX_STRUCTYPE_SET(1) |
-		HFA384x_TX_TXEX_SET(0) | HFA384x_TX_TXOK_SET(0);
+	    HFA384x_TX_MACPORT_SET(0) | HFA384x_TX_STRUCTYPE_SET(1) |
+	    HFA384x_TX_TXEX_SET(0) | HFA384x_TX_TXOK_SET(0);
 #endif
 	hw->txbuff.txfrm.desc.tx_control =
-		host2hfa384x_16(hw->txbuff.txfrm.desc.tx_control);
+	    host2hfa384x_16(hw->txbuff.txfrm.desc.tx_control);
 
 	/* copy the header over to the txdesc */
-	memcpy(&(hw->txbuff.txfrm.desc.frame_control), p80211_hdr, sizeof(p80211_hdr_t));
+	memcpy(&(hw->txbuff.txfrm.desc.frame_control), p80211_hdr,
+	       sizeof(p80211_hdr_t));
 
 	/* if we're using host WEP, increase size by IV+ICV */
 	if (p80211_wep->data) {
-		hw->txbuff.txfrm.desc.data_len = host2hfa384x_16(skb->len+8);
-		usbpktlen+=8;
+		hw->txbuff.txfrm.desc.data_len = host2hfa384x_16(skb->len + 8);
+		usbpktlen += 8;
 	} else {
 		hw->txbuff.txfrm.desc.data_len = host2hfa384x_16(skb->len);
 	}
@@ -3045,50 +2873,47 @@ int hfa384x_drvr_txframe(hfa384x_t *hw, struct sk_buff *skb, p80211_hdr_t *p8021
 	ptr = hw->txbuff.txfrm.data;
 	if (p80211_wep->data) {
 		memcpy(ptr, p80211_wep->iv, sizeof(p80211_wep->iv));
-		ptr+= sizeof(p80211_wep->iv);
+		ptr += sizeof(p80211_wep->iv);
 		memcpy(ptr, p80211_wep->data, skb->len);
 	} else {
 		memcpy(ptr, skb->data, skb->len);
 	}
 	/* copy over the packet data */
-	ptr+= skb->len;
+	ptr += skb->len;
 
 	/* copy over the WEP ICV if we are using host WEP */
-	if (p80211_wep->data) {
+	if (p80211_wep->data)
 		memcpy(ptr, p80211_wep->icv, sizeof(p80211_wep->icv));
-	}
 
 	/* Send the USB packet */
-	usb_fill_bulk_urb( &(hw->tx_urb), hw->usb,
-	               hw->endp_out,
-	               &(hw->txbuff), ROUNDUP64(usbpktlen),
-	               hfa384x_usbout_callback, hw->wlandev );
+	usb_fill_bulk_urb(&(hw->tx_urb), hw->usb,
+			  hw->endp_out,
+			  &(hw->txbuff), ROUNDUP64(usbpktlen),
+			  hfa384x_usbout_callback, hw->wlandev);
 	hw->tx_urb.transfer_flags |= USB_QUEUE_BULK;
 
 	result = 1;
 	ret = submit_tx_urb(hw, &hw->tx_urb, GFP_ATOMIC);
-	if ( ret != 0 ) {
-		printk(KERN_ERR
-			"submit_tx_urb() failed, error=%d\n", ret);
+	if (ret != 0) {
+		printk(KERN_ERR "submit_tx_urb() failed, error=%d\n", ret);
 		result = 3;
 	}
 
- exit:
+exit:
 	return result;
 }
 
 void hfa384x_tx_timeout(wlandevice_t *wlandev)
 {
-	hfa384x_t	*hw = wlandev->priv;
+	hfa384x_t *hw = wlandev->priv;
 	unsigned long flags;
 
 	spin_lock_irqsave(&hw->ctlxq.lock, flags);
 
-	if ( !hw->wlandev->hwremoved &&
-	     /* Note the bitwise OR, not the logical OR. */
-	     ( !test_and_set_bit(WORK_TX_HALT, &hw->usb_flags) |
-	       !test_and_set_bit(WORK_RX_HALT, &hw->usb_flags) ) )
-	{
+	if (!hw->wlandev->hwremoved &&
+	    /* Note the bitwise OR, not the logical OR. */
+	    (!test_and_set_bit(WORK_TX_HALT, &hw->usb_flags) |
+	     !test_and_set_bit(WORK_RX_HALT, &hw->usb_flags))) {
 		schedule_work(&hw->usb_work);
 	}
 
@@ -3110,10 +2935,10 @@ void hfa384x_tx_timeout(wlandevice_t *wlandev)
 ----------------------------------------------------------------*/
 static void hfa384x_usbctlx_reaper_task(unsigned long data)
 {
-	hfa384x_t	*hw = (hfa384x_t*)data;
+	hfa384x_t *hw = (hfa384x_t *) data;
 	struct list_head *entry;
 	struct list_head *temp;
-	unsigned long	flags;
+	unsigned long flags;
 
 	spin_lock_irqsave(&hw->ctlxq.lock, flags);
 
@@ -3121,7 +2946,7 @@ static void hfa384x_usbctlx_reaper_task(unsigned long data)
 	 * has unplugged the adapter.
 	 */
 	list_for_each_safe(entry, temp, &hw->ctlxq.reapable) {
-		hfa384x_usbctlx_t	*ctlx;
+		hfa384x_usbctlx_t *ctlx;
 
 		ctlx = list_entry(entry, hfa384x_usbctlx_t, list);
 		list_del(&ctlx->list);
@@ -3148,7 +2973,7 @@ static void hfa384x_usbctlx_reaper_task(unsigned long data)
 ----------------------------------------------------------------*/
 static void hfa384x_usbctlx_completion_task(unsigned long data)
 {
-	hfa384x_t *hw = (hfa384x_t*)data;
+	hfa384x_t *hw = (hfa384x_t *) data;
 	struct list_head *entry;
 	struct list_head *temp;
 	unsigned long flags;
@@ -3168,7 +2993,7 @@ static void hfa384x_usbctlx_completion_task(unsigned long data)
 		/* Call the completion function that this
 		 * command was assigned, assuming it has one.
 		 */
-		if ( ctlx->cmdcb != NULL ) {
+		if (ctlx->cmdcb != NULL) {
 			spin_unlock_irqrestore(&hw->ctlxq.lock, flags);
 			ctlx->cmdcb(hw, ctlx);
 			spin_lock_irqsave(&hw->ctlxq.lock, flags);
@@ -3181,8 +3006,7 @@ static void hfa384x_usbctlx_completion_task(unsigned long data)
 			/* Did someone yank the adapter out
 			 * while our list was (briefly) unlocked?
 			 */
-			if ( hw->wlandev->hwremoved )
-			{
+			if (hw->wlandev->hwremoved) {
 				reap = 0;
 				break;
 			}
@@ -3193,7 +3017,7 @@ static void hfa384x_usbctlx_completion_task(unsigned long data)
 		 * threads waiting for them to die. Hence they must
 		 * be delivered to The Reaper!
 		 */
-		if ( ctlx->reapable ) {
+		if (ctlx->reapable) {
 			/* Move the CTLX off the "completing" list (hopefully)
 			 * on to the "reapable" list where the reaper task
 			 * can find it. And "reapable" means that this CTLX
@@ -3228,7 +3052,8 @@ static void hfa384x_usbctlx_completion_task(unsigned long data)
 * Call context:
 *	Either process or interrupt, but presumably interrupt
 ----------------------------------------------------------------*/
-static int unlocked_usbctlx_cancel_async(hfa384x_t *hw, hfa384x_usbctlx_t *ctlx)
+static int unlocked_usbctlx_cancel_async(hfa384x_t *hw,
+					 hfa384x_usbctlx_t *ctlx)
 {
 	int ret;
 
@@ -3294,10 +3119,10 @@ static void unlocked_usbctlx_complete(hfa384x_t *hw, hfa384x_usbctlx_t *ctlx)
 
 	default:
 		printk(KERN_ERR "CTLX[%d] not in a terminating state(%s)\n",
-		               hfa384x2host_16(ctlx->outbuf.type),
-		               ctlxstr(ctlx->state));
+		       hfa384x2host_16(ctlx->outbuf.type),
+		       ctlxstr(ctlx->state));
 		break;
-	} /* switch */
+	}			/* switch */
 }
 
 /*----------------------------------------------------------------
@@ -3316,10 +3141,9 @@ static void unlocked_usbctlx_complete(hfa384x_t *hw, hfa384x_usbctlx_t *ctlx)
 * Call context:
 *	any
 ----------------------------------------------------------------*/
-static void
-hfa384x_usbctlxq_run(hfa384x_t	*hw)
+static void hfa384x_usbctlxq_run(hfa384x_t *hw)
 {
-	unsigned long		flags;
+	unsigned long flags;
 
 	/* acquire lock */
 	spin_lock_irqsave(&hw->ctlxq.lock, flags);
@@ -3331,28 +3155,26 @@ hfa384x_usbctlxq_run(hfa384x_t	*hw)
 	 * Don't touch any of these CTLXs if the hardware
 	 * has been removed or the USB subsystem is stalled.
 	 */
-	if ( !list_empty(&hw->ctlxq.active) ||
-	     test_bit(WORK_TX_HALT, &hw->usb_flags) ||
-	     hw->wlandev->hwremoved )
+	if (!list_empty(&hw->ctlxq.active) ||
+	    test_bit(WORK_TX_HALT, &hw->usb_flags) || hw->wlandev->hwremoved)
 		goto unlock;
 
-	while ( !list_empty(&hw->ctlxq.pending) ) {
-		hfa384x_usbctlx_t	*head;
-		int			result;
+	while (!list_empty(&hw->ctlxq.pending)) {
+		hfa384x_usbctlx_t *head;
+		int result;
 
 		/* This is the first pending command */
 		head = list_entry(hw->ctlxq.pending.next,
-		                  hfa384x_usbctlx_t,
-		                  list);
+				  hfa384x_usbctlx_t, list);
 
 		/* We need to split this off to avoid a race condition */
 		list_move_tail(&head->list, &hw->ctlxq.active);
 
 		/* Fill the out packet */
-		usb_fill_bulk_urb( &(hw->ctlx_urb), hw->usb,
-		                   hw->endp_out,
-		                   &(head->outbuf), ROUNDUP64(head->outbufsize),
-		                   hfa384x_ctlxout_callback, hw);
+		usb_fill_bulk_urb(&(hw->ctlx_urb), hw->usb,
+				  hw->endp_out,
+				  &(head->outbuf), ROUNDUP64(head->outbufsize),
+				  hfa384x_ctlxout_callback, hw);
 		hw->ctlx_urb.transfer_flags |= USB_QUEUE_BULK;
 
 		/* Now submit the URB and update the CTLX's state
@@ -3368,7 +3190,7 @@ hfa384x_usbctlxq_run(hfa384x_t	*hw)
 
 			/* Start the IN wait timer */
 			hw->resp_timer_done = 0;
-			hw->resptimer.expires = jiffies + 2*HZ;
+			hw->resptimer.expires = jiffies + 2 * HZ;
 			add_timer(&hw->resptimer);
 
 			break;
@@ -3379,8 +3201,9 @@ hfa384x_usbctlxq_run(hfa384x_t	*hw)
 			 * this CTLX back in the "pending" queue
 			 * and schedule a reset ...
 			 */
-			printk(KERN_WARNING "%s tx pipe stalled: requesting reset\n",
-			                 hw->wlandev->netdev->name);
+			printk(KERN_WARNING
+			       "%s tx pipe stalled: requesting reset\n",
+			       hw->wlandev->netdev->name);
 			list_move(&head->list, &hw->ctlxq.pending);
 			set_bit(WORK_TX_HALT, &hw->usb_flags);
 			schedule_work(&hw->usb_work);
@@ -3389,20 +3212,19 @@ hfa384x_usbctlxq_run(hfa384x_t	*hw)
 
 		if (result == -ESHUTDOWN) {
 			printk(KERN_WARNING "%s urb shutdown!\n",
-					 hw->wlandev->netdev->name);
+			       hw->wlandev->netdev->name);
 			break;
 		}
 
 		printk(KERN_ERR "Failed to submit CTLX[%d]: error=%d\n",
-		               hfa384x2host_16(head->outbuf.type), result);
+		       hfa384x2host_16(head->outbuf.type), result);
 		unlocked_usbctlx_complete(hw, head);
-	} /* while */
+	}			/* while */
 
-	unlock:
+unlock:
 	spin_unlock_irqrestore(&hw->ctlxq.lock, flags);
 }
 
-
 /*----------------------------------------------------------------
 * hfa384x_usbin_callback
 *
@@ -3421,13 +3243,13 @@ hfa384x_usbctlxq_run(hfa384x_t	*hw)
 ----------------------------------------------------------------*/
 static void hfa384x_usbin_callback(struct urb *urb)
 {
-	wlandevice_t		*wlandev = urb->context;
-	hfa384x_t		*hw;
-	hfa384x_usbin_t		*usbin = (hfa384x_usbin_t *) urb->transfer_buffer;
-	struct sk_buff          *skb = NULL;
-	int			result;
-	int                     urb_status;
-	u16			type;
+	wlandevice_t *wlandev = urb->context;
+	hfa384x_t *hw;
+	hfa384x_usbin_t *usbin = (hfa384x_usbin_t *) urb->transfer_buffer;
+	struct sk_buff *skb = NULL;
+	int result;
+	int urb_status;
+	u16 type;
 
 	enum USBIN_ACTION {
 		HANDLE,
@@ -3435,9 +3257,7 @@ static void hfa384x_usbin_callback(struct urb *urb)
 		ABORT
 	} action;
 
-	if ( !wlandev ||
-	     !wlandev->netdev ||
-	     wlandev->hwremoved )
+	if (!wlandev || !wlandev->netdev || wlandev->hwremoved)
 		goto exit;
 
 	hw = wlandev->priv;
@@ -3445,9 +3265,9 @@ static void hfa384x_usbin_callback(struct urb *urb)
 		goto exit;
 
 	skb = hw->rx_urb_skb;
-	if (!skb || (skb->data != urb->transfer_buffer)) {
+	if (!skb || (skb->data != urb->transfer_buffer))
 		BUG();
-	}
+
 	hw->rx_urb_skb = NULL;
 
 	/* Check for error conditions within the URB */
@@ -3456,7 +3276,7 @@ static void hfa384x_usbin_callback(struct urb *urb)
 		action = HANDLE;
 
 		/* Check for short packet */
-		if ( urb->actual_length == 0 ) {
+		if (urb->actual_length == 0) {
 			++(wlandev->linux_stats.rx_errors);
 			++(wlandev->linux_stats.rx_length_errors);
 			action = RESUBMIT;
@@ -3465,8 +3285,8 @@ static void hfa384x_usbin_callback(struct urb *urb)
 
 	case -EPIPE:
 		printk(KERN_WARNING "%s rx pipe stalled: requesting reset\n",
-		                 wlandev->netdev->name);
-		if ( !test_and_set_bit(WORK_RX_HALT, &hw->usb_flags) )
+		       wlandev->netdev->name);
+		if (!test_and_set_bit(WORK_RX_HALT, &hw->usb_flags))
 			schedule_work(&hw->usb_work);
 		++(wlandev->linux_stats.rx_errors);
 		action = ABORT;
@@ -3475,8 +3295,8 @@ static void hfa384x_usbin_callback(struct urb *urb)
 	case -EILSEQ:
 	case -ETIMEDOUT:
 	case -EPROTO:
-		if ( !test_and_set_bit(THROTTLE_RX, &hw->usb_flags) &&
-		     !timer_pending(&hw->throttle) ) {
+		if (!test_and_set_bit(THROTTLE_RX, &hw->usb_flags) &&
+		    !timer_pending(&hw->throttle)) {
 			mod_timer(&hw->throttle, jiffies + THROTTLE_JIFFIES);
 		}
 		++(wlandev->linux_stats.rx_errors);
@@ -3496,13 +3316,14 @@ static void hfa384x_usbin_callback(struct urb *urb)
 
 	case -ENOENT:
 	case -ECONNRESET:
-		pr_debug("status=%d, urb explicitly unlinked.\n", urb->status);
+		pr_debug("status=%d, urb explicitly unlinked.\n",
+		       urb->status);
 		action = ABORT;
 		break;
 
 	default:
 		pr_debug("urb status=%d, transfer flags=0x%x\n",
-		                 urb->status, urb->transfer_flags);
+		       urb->status, urb->transfer_flags);
 		++(wlandev->linux_stats.rx_errors);
 		action = RESUBMIT;
 		break;
@@ -3516,8 +3337,8 @@ static void hfa384x_usbin_callback(struct urb *urb)
 
 		if (result != 0) {
 			printk(KERN_ERR
-				"Fatal, failed to resubmit rx_urb. error=%d\n",
-				result);
+			       "Fatal, failed to resubmit rx_urb. error=%d\n",
+			       result);
 		}
 	}
 
@@ -3562,19 +3383,20 @@ static void hfa384x_usbin_callback(struct urb *urb)
 
 	case HFA384x_USB_BUFAVAIL:
 		pr_debug("Received BUFAVAIL packet, frmlen=%d\n",
-			usbin->bufavail.frmlen);
+		       usbin->bufavail.frmlen);
 		break;
 
 	case HFA384x_USB_ERROR:
 		pr_debug("Received USB_ERROR packet, errortype=%d\n",
-			usbin->usberror.errortype);
+		       usbin->usberror.errortype);
 		break;
 
 	default:
-		pr_debug("Unrecognized USBIN packet, type=%x, status=%d\n",
-			usbin->type, urb_status);
+		printk(KERN_DEBUG
+		       "Unrecognized USBIN packet, type=%x, status=%d\n",
+		       usbin->type, urb_status);
 		break;
-	} /* switch */
+	}			/* switch */
 
 exit:
 
@@ -3582,7 +3404,6 @@ static void hfa384x_usbin_callback(struct urb *urb)
 		dev_kfree_skb(skb);
 }
 
-
 /*----------------------------------------------------------------
 * hfa384x_usbin_ctlx
 *
@@ -3606,9 +3427,9 @@ static void hfa384x_usbin_callback(struct urb *urb)
 static void hfa384x_usbin_ctlx(hfa384x_t *hw, hfa384x_usbin_t *usbin,
 			       int urb_status)
 {
-	hfa384x_usbctlx_t	*ctlx;
-	int			run_queue = 0;
-	unsigned long		flags;
+	hfa384x_usbctlx_t *ctlx;
+	int run_queue = 0;
+	unsigned long flags;
 
 retry:
 	spin_lock_irqsave(&hw->ctlxq.lock, flags);
@@ -3617,9 +3438,8 @@ static void hfa384x_usbin_ctlx(hfa384x_t *hw, hfa384x_usbin_t *usbin,
 	 * at any one time, and this is the CTLX that the
 	 * timers are waiting for.
 	 */
-	if ( list_empty(&hw->ctlxq.active) ) {
+	if (list_empty(&hw->ctlxq.active))
 		goto unlock;
-	}
 
 	/* Remove the "response timeout". It's possible that
 	 * we are already too late, and that the timeout is
@@ -3632,8 +3452,7 @@ static void hfa384x_usbin_ctlx(hfa384x_t *hw, hfa384x_usbin_t *usbin,
 			spin_unlock_irqrestore(&hw->ctlxq.lock, flags);
 			goto retry;
 		}
-	}
-	else {
+	} else {
 		hw->resp_timer_done = 1;
 	}
 
@@ -3648,15 +3467,16 @@ static void hfa384x_usbin_ctlx(hfa384x_t *hw, hfa384x_usbin_t *usbin,
 		if (unlocked_usbctlx_cancel_async(hw, ctlx) == 0)
 			run_queue = 1;
 	} else {
-		const u16 intype = (usbin->type&~host2hfa384x_16(0x8000));
+		const u16 intype = (usbin->type & ~host2hfa384x_16(0x8000));
 
 		/*
 		 * Check that our message is what we're expecting ...
 		 */
 		if (ctlx->outbuf.type != intype) {
-			printk(KERN_WARNING "Expected IN[%d], received IN[%d] - ignored.\n",
-			                 hfa384x2host_16(ctlx->outbuf.type),
-			                 hfa384x2host_16(intype));
+			printk(KERN_WARNING
+			       "Expected IN[%d], received IN[%d] - ignored.\n",
+			       hfa384x2host_16(ctlx->outbuf.type),
+			       hfa384x2host_16(intype));
 			goto unlock;
 		}
 
@@ -3670,7 +3490,8 @@ static void hfa384x_usbin_ctlx(hfa384x_t *hw, hfa384x_usbin_t *usbin,
 			 * our request has been acknowledged. Odd,
 			 * but our OUT URB is still alive...
 			 */
-			pr_debug("Causality violation: please reboot Universe, or email linux-wlan-devel@lists.linux-wlan.com\n");
+			printk(KERN_DEBUG
+			       "Causality violation: please reboot Universe, or email linux-wlan-devel@lists.linux-wlan.com\n");
 			ctlx->state = CTLX_RESP_COMPLETE;
 			break;
 
@@ -3689,14 +3510,15 @@ static void hfa384x_usbin_ctlx(hfa384x_t *hw, hfa384x_usbin_t *usbin,
 			/*
 			 * Throw this CTLX away ...
 			 */
-			printk(KERN_ERR "Matched IN URB, CTLX[%d] in invalid state(%s)."
-			               " Discarded.\n",
-			               hfa384x2host_16(ctlx->outbuf.type),
-			               ctlxstr(ctlx->state));
+			printk(KERN_ERR
+			       "Matched IN URB, CTLX[%d] in invalid state(%s)."
+			       " Discarded.\n",
+			       hfa384x2host_16(ctlx->outbuf.type),
+			       ctlxstr(ctlx->state));
 			if (unlocked_usbctlx_cancel_async(hw, ctlx) == 0)
 				run_queue = 1;
 			break;
-		} /* switch */
+		}		/* switch */
 	}
 
 unlock:
@@ -3706,7 +3528,6 @@ static void hfa384x_usbin_ctlx(hfa384x_t *hw, hfa384x_usbin_t *usbin,
 		hfa384x_usbctlxq_run(hw);
 }
 
-
 /*----------------------------------------------------------------
 * hfa384x_usbin_txcompl
 *
@@ -3724,22 +3545,20 @@ static void hfa384x_usbin_ctlx(hfa384x_t *hw, hfa384x_usbin_t *usbin,
 * Call context:
 *	interrupt
 ----------------------------------------------------------------*/
-static void hfa384x_usbin_txcompl(wlandevice_t *wlandev, hfa384x_usbin_t *usbin)
+static void hfa384x_usbin_txcompl(wlandevice_t *wlandev,
+				  hfa384x_usbin_t *usbin)
 {
-	u16			status;
+	u16 status;
 
-	status = hfa384x2host_16(usbin->type); /* yeah I know it says type...*/
+	status = hfa384x2host_16(usbin->type);	/* yeah I know it says type... */
 
 	/* Was there an error? */
-	if (HFA384x_TXSTATUS_ISERROR(status)) {
+	if (HFA384x_TXSTATUS_ISERROR(status))
 		prism2sta_ev_txexc(wlandev, status);
-	} else {
+	else
 		prism2sta_ev_tx(wlandev, status);
-	}
-	// prism2sta_ev_alloc(wlandev);
 }
 
-
 /*----------------------------------------------------------------
 * hfa384x_usbin_rx
 *
@@ -3759,28 +3578,25 @@ static void hfa384x_usbin_txcompl(wlandevice_t *wlandev, hfa384x_usbin_t *usbin)
 ----------------------------------------------------------------*/
 static void hfa384x_usbin_rx(wlandevice_t *wlandev, struct sk_buff *skb)
 {
-	hfa384x_usbin_t         *usbin = (hfa384x_usbin_t *) skb->data;
-	hfa384x_t               *hw = wlandev->priv;
-	int                     hdrlen;
-	p80211_rxmeta_t         *rxmeta;
-	u16                  data_len;
-	u16                  fc;
+	hfa384x_usbin_t *usbin = (hfa384x_usbin_t *) skb->data;
+	hfa384x_t *hw = wlandev->priv;
+	int hdrlen;
+	p80211_rxmeta_t *rxmeta;
+	u16 data_len;
+	u16 fc;
 
 	/* Byte order convert once up front. */
-	usbin->rxfrm.desc.status =
-		hfa384x2host_16(usbin->rxfrm.desc.status);
-	usbin->rxfrm.desc.time =
-		hfa384x2host_32(usbin->rxfrm.desc.time);
+	usbin->rxfrm.desc.status = hfa384x2host_16(usbin->rxfrm.desc.status);
+	usbin->rxfrm.desc.time = hfa384x2host_32(usbin->rxfrm.desc.time);
 
 	/* Now handle frame based on port# */
-	switch( HFA384x_RXSTATUS_MACPORT_GET(usbin->rxfrm.desc.status) )
-	{
+	switch (HFA384x_RXSTATUS_MACPORT_GET(usbin->rxfrm.desc.status)) {
 	case 0:
 		fc = le16_to_cpu(usbin->rxfrm.desc.frame_control);
 
 		/* If exclude and we receive an unencrypted, drop it */
-		if ( (wlandev->hostwep & HOSTWEP_EXCLUDEUNENCRYPTED) &&
-		     !WLAN_GET_FC_ISWEP(fc)){
+		if ((wlandev->hostwep & HOSTWEP_EXCLUDEUNENCRYPTED) &&
+		    !WLAN_GET_FC_ISWEP(fc)) {
 			goto done;
 		}
 
@@ -3796,8 +3612,7 @@ static void hfa384x_usbin_rx(wlandevice_t *wlandev, struct sk_buff *skb)
 		 * with an "overlapping" copy
 		 */
 		memmove(skb_push(skb, hdrlen),
-		        &usbin->rxfrm.desc.frame_control,
-		        hdrlen);
+			&usbin->rxfrm.desc.frame_control, hdrlen);
 
 		skb->dev = wlandev->netdev;
 		skb->dev->last_rx = jiffies;
@@ -3823,18 +3638,19 @@ static void hfa384x_usbin_rx(wlandevice_t *wlandev, struct sk_buff *skb)
 		break;
 
 	case 7:
-		if ( ! HFA384x_RXSTATUS_ISFCSERR(usbin->rxfrm.desc.status) ) {
+		if (!HFA384x_RXSTATUS_ISFCSERR(usbin->rxfrm.desc.status)) {
 			/* Copy to wlansnif skb */
-			hfa384x_int_rxmonitor( wlandev, &usbin->rxfrm);
+			hfa384x_int_rxmonitor(wlandev, &usbin->rxfrm);
 			dev_kfree_skb(skb);
 		} else {
-			pr_debug("Received monitor frame: FCSerr set\n");
+			printk(KERN_DEBUG
+			       "Received monitor frame: FCSerr set\n");
 		}
 		break;
 
 	default:
 		printk(KERN_WARNING "Received frame on unsupported port=%d\n",
-			HFA384x_RXSTATUS_MACPORT_GET(usbin->rxfrm.desc.status) );
+		       HFA384x_RXSTATUS_MACPORT_GET(usbin->rxfrm.desc.status));
 		goto done;
 		break;
 	}
@@ -3864,16 +3680,17 @@ static void hfa384x_usbin_rx(wlandevice_t *wlandev, struct sk_buff *skb)
 * Call context:
 *	interrupt
 ----------------------------------------------------------------*/
-static void hfa384x_int_rxmonitor( wlandevice_t *wlandev, hfa384x_usb_rxfrm_t *rxfrm)
+static void hfa384x_int_rxmonitor(wlandevice_t *wlandev,
+				  hfa384x_usb_rxfrm_t *rxfrm)
 {
-	hfa384x_rx_frame_t              *rxdesc = &(rxfrm->desc);
-	unsigned int				hdrlen = 0;
-	unsigned int				datalen = 0;
-	unsigned int				skblen = 0;
-	u8				*datap;
-	u16				fc;
-	struct sk_buff			*skb;
-	hfa384x_t		        *hw = wlandev->priv;
+	hfa384x_rx_frame_t *rxdesc = &(rxfrm->desc);
+	unsigned int hdrlen = 0;
+	unsigned int datalen = 0;
+	unsigned int skblen = 0;
+	u8 *datap;
+	u16 fc;
+	struct sk_buff *skb;
+	hfa384x_t *hw = wlandev->priv;
 
 	/* Don't forget the status, time, and data_len fields are in host order */
 	/* Figure out how big the frame is */
@@ -3882,66 +3699,66 @@ static void hfa384x_int_rxmonitor( wlandevice_t *wlandev, hfa384x_usb_rxfrm_t *r
 	datalen = hfa384x2host_16(rxdesc->data_len);
 
 	/* Allocate an ind message+framesize skb */
-	skblen = sizeof(p80211_caphdr_t) +
-		hdrlen + datalen + WLAN_CRC_LEN;
+	skblen = sizeof(p80211_caphdr_t) + hdrlen + datalen + WLAN_CRC_LEN;
 
 	/* sanity check the length */
-	if ( skblen >
-	     (sizeof(p80211_caphdr_t) +
-	      WLAN_HDR_A4_LEN + WLAN_DATA_MAXLEN + WLAN_CRC_LEN) ) {
+	if (skblen >
+	    (sizeof(p80211_caphdr_t) +
+	     WLAN_HDR_A4_LEN + WLAN_DATA_MAXLEN + WLAN_CRC_LEN)) {
 		pr_debug("overlen frm: len=%zd\n",
-			       skblen - sizeof(p80211_caphdr_t));
+		       skblen - sizeof(p80211_caphdr_t));
 	}
 
-	if ( (skb = dev_alloc_skb(skblen)) == NULL ) {
-		printk(KERN_ERR "alloc_skb failed trying to allocate %d bytes\n", skblen);
+	if ((skb = dev_alloc_skb(skblen)) == NULL) {
+		printk(KERN_ERR
+		       "alloc_skb failed trying to allocate %d bytes\n",
+		       skblen);
 		return;
 	}
 
 	/* only prepend the prism header if in the right mode */
 	if ((wlandev->netdev->type == ARPHRD_IEEE80211_PRISM) &&
 	    (hw->sniffhdr != 0)) {
-		p80211_caphdr_t		*caphdr;
+		p80211_caphdr_t *caphdr;
 		/* The NEW header format! */
 		datap = skb_put(skb, sizeof(p80211_caphdr_t));
-		caphdr = (p80211_caphdr_t*) datap;
-
-		caphdr->version =	htonl(P80211CAPTURE_VERSION);
-		caphdr->length =	htonl(sizeof(p80211_caphdr_t));
-		caphdr->mactime =	__cpu_to_be64(rxdesc->time) * 1000;
-		caphdr->hosttime =	__cpu_to_be64(jiffies);
-		caphdr->phytype =	htonl(4); /* dss_dot11_b */
-		caphdr->channel =	htonl(hw->sniff_channel);
-		caphdr->datarate =	htonl(rxdesc->rate);
-		caphdr->antenna =	htonl(0); /* unknown */
-		caphdr->priority =	htonl(0); /* unknown */
-		caphdr->ssi_type =	htonl(3); /* rssi_raw */
-		caphdr->ssi_signal =	htonl(rxdesc->signal);
-		caphdr->ssi_noise =	htonl(rxdesc->silence);
-		caphdr->preamble =	htonl(0); /* unknown */
-		caphdr->encoding =	htonl(1); /* cck */
+		caphdr = (p80211_caphdr_t *) datap;
+
+		caphdr->version = htonl(P80211CAPTURE_VERSION);
+		caphdr->length = htonl(sizeof(p80211_caphdr_t));
+		caphdr->mactime = __cpu_to_be64(rxdesc->time) * 1000;
+		caphdr->hosttime = __cpu_to_be64(jiffies);
+		caphdr->phytype = htonl(4);	/* dss_dot11_b */
+		caphdr->channel = htonl(hw->sniff_channel);
+		caphdr->datarate = htonl(rxdesc->rate);
+		caphdr->antenna = htonl(0);	/* unknown */
+		caphdr->priority = htonl(0);	/* unknown */
+		caphdr->ssi_type = htonl(3);	/* rssi_raw */
+		caphdr->ssi_signal = htonl(rxdesc->signal);
+		caphdr->ssi_noise = htonl(rxdesc->silence);
+		caphdr->preamble = htonl(0);	/* unknown */
+		caphdr->encoding = htonl(1);	/* cck */
 	}
 
 	/* Copy the 802.11 header to the skb (ctl frames may be less than a full header) */
 	datap = skb_put(skb, hdrlen);
-	memcpy( datap, &(rxdesc->frame_control), hdrlen);
+	memcpy(datap, &(rxdesc->frame_control), hdrlen);
 
 	/* If any, copy the data from the card to the skb */
-	if ( datalen > 0 )
-	{
+	if (datalen > 0) {
 		datap = skb_put(skb, datalen);
 		memcpy(datap, rxfrm->data, datalen);
 
 		/* check for unencrypted stuff if WEP bit set. */
-		if (*(datap - hdrlen + 1) & 0x40) // wep set
-		  if ((*(datap) == 0xaa) && (*(datap+1) == 0xaa))
-		    *(datap - hdrlen + 1) &= 0xbf; // clear wep; it's the 802.2 header!
+		if (*(datap - hdrlen + 1) & 0x40)	/* wep set */
+			if ((*(datap) == 0xaa) && (*(datap + 1) == 0xaa))
+				*(datap - hdrlen + 1) &= 0xbf;	// clear wep; it's the 802.2 header!
 	}
 
 	if (hw->sniff_fcs) {
 		/* Set the FCS */
 		datap = skb_put(skb, WLAN_CRC_LEN);
-		memset( datap, 0xff, WLAN_CRC_LEN);
+		memset(datap, 0xff, WLAN_CRC_LEN);
 	}
 
 	/* pass it back up */
@@ -3950,8 +3767,6 @@ static void hfa384x_int_rxmonitor( wlandevice_t *wlandev, hfa384x_usb_rxfrm_t *r
 	return;
 }
 
-
-
 /*----------------------------------------------------------------
 * hfa384x_usbin_info
 *
@@ -3969,14 +3784,13 @@ static void hfa384x_int_rxmonitor( wlandevice_t *wlandev, hfa384x_usb_rxfrm_t *r
 * Call context:
 *	interrupt
 ----------------------------------------------------------------*/
-static void hfa384x_usbin_info(wlandevice_t *wlandev, hfa384x_usbin_t *usbin)
+static void hfa384x_usbin_info(wlandevice_t * wlandev, hfa384x_usbin_t * usbin)
 {
-	usbin->infofrm.info.framelen = hfa384x2host_16(usbin->infofrm.info.framelen);
+	usbin->infofrm.info.framelen =
+	    hfa384x2host_16(usbin->infofrm.info.framelen);
 	prism2sta_ev_info(wlandev, &usbin->infofrm.info);
 }
 
-
-
 /*----------------------------------------------------------------
 * hfa384x_usbout_callback
 *
@@ -3995,47 +3809,49 @@ static void hfa384x_usbin_info(wlandevice_t *wlandev, hfa384x_usbin_t *usbin)
 ----------------------------------------------------------------*/
 static void hfa384x_usbout_callback(struct urb *urb)
 {
-	wlandevice_t		*wlandev = urb->context;
-	hfa384x_usbout_t	*usbout = urb->transfer_buffer;
+	wlandevice_t *wlandev = urb->context;
+	hfa384x_usbout_t *usbout = urb->transfer_buffer;
 
 #ifdef DEBUG_USB
 	dbprint_urb(urb);
 #endif
 
-	if ( wlandev &&
-	     wlandev->netdev ) {
+	if (wlandev && wlandev->netdev) {
 
-		switch(urb->status) {
+		switch (urb->status) {
 		case 0:
 			hfa384x_usbout_tx(wlandev, usbout);
 			break;
 
 		case -EPIPE:
-		{
-			hfa384x_t *hw = wlandev->priv;
-			printk(KERN_WARNING "%s tx pipe stalled: requesting reset\n",
-			                 wlandev->netdev->name);
-			if ( !test_and_set_bit(WORK_TX_HALT, &hw->usb_flags) )
-				schedule_work(&hw->usb_work);
-			++(wlandev->linux_stats.tx_errors);
-			break;
-		}
+			{
+				hfa384x_t *hw = wlandev->priv;
+				printk(KERN_WARNING
+				       "%s tx pipe stalled: requesting reset\n",
+				       wlandev->netdev->name);
+				if (!test_and_set_bit
+				    (WORK_TX_HALT, &hw->usb_flags))
+					schedule_work(&hw->usb_work);
+				++(wlandev->linux_stats.tx_errors);
+				break;
+			}
 
 		case -EPROTO:
 		case -ETIMEDOUT:
 		case -EILSEQ:
-		{
-			hfa384x_t *hw = wlandev->priv;
-
-			if ( !test_and_set_bit(THROTTLE_TX, &hw->usb_flags)
-			     && !timer_pending(&hw->throttle) ) {
-				mod_timer(&hw->throttle,
-				          jiffies + THROTTLE_JIFFIES);
+			{
+				hfa384x_t *hw = wlandev->priv;
+
+				if (!test_and_set_bit
+				    (THROTTLE_TX, &hw->usb_flags)
+				    && !timer_pending(&hw->throttle)) {
+					mod_timer(&hw->throttle,
+						  jiffies + THROTTLE_JIFFIES);
+				}
+				++(wlandev->linux_stats.tx_errors);
+				netif_stop_queue(wlandev->netdev);
+				break;
 			}
-			++(wlandev->linux_stats.tx_errors);
-			netif_stop_queue(wlandev->netdev);
-			break;
-		}
 
 		case -ENOENT:
 		case -ESHUTDOWN:
@@ -4043,14 +3859,14 @@ static void hfa384x_usbout_callback(struct urb *urb)
 			break;
 
 		default:
-			printk(KERN_INFO "unknown urb->status=%d\n", urb->status);
+			printk(KERN_INFO "unknown urb->status=%d\n",
+			       urb->status);
 			++(wlandev->linux_stats.tx_errors);
 			break;
-		} /* switch */
+		}		/* switch */
 	}
 }
 
-
 /*----------------------------------------------------------------
 * hfa384x_ctlxout_callback
 *
@@ -4069,20 +3885,19 @@ static void hfa384x_usbout_callback(struct urb *urb)
 ----------------------------------------------------------------*/
 static void hfa384x_ctlxout_callback(struct urb *urb)
 {
-	hfa384x_t	*hw = urb->context;
-	int             delete_resptimer = 0;
-	int             timer_ok = 1;
-	int		run_queue = 0;
-	hfa384x_usbctlx_t	*ctlx;
-	unsigned long	flags;
+	hfa384x_t *hw = urb->context;
+	int delete_resptimer = 0;
+	int timer_ok = 1;
+	int run_queue = 0;
+	hfa384x_usbctlx_t *ctlx;
+	unsigned long flags;
 
 	pr_debug("urb->status=%d\n", urb->status);
 #ifdef DEBUG_USB
 	dbprint_urb(urb);
 #endif
-	if ( (urb->status == -ESHUTDOWN) ||
-	     (urb->status == -ENODEV) ||
-	     (hw == NULL) )
+	if ((urb->status == -ESHUTDOWN) ||
+	    (urb->status == -ENODEV) || (hw == NULL))
 		goto done;
 
 retry:
@@ -4094,7 +3909,7 @@ static void hfa384x_ctlxout_callback(struct urb *urb)
 	 * rely on the disconnect function to clean everything
 	 * up if someone unplugged the adapter.
 	 */
-	if ( list_empty(&hw->ctlxq.active) ) {
+	if (list_empty(&hw->ctlxq.active)) {
 		spin_unlock_irqrestore(&hw->ctlxq.lock, flags);
 		goto done;
 	}
@@ -4113,16 +3928,15 @@ static void hfa384x_ctlxout_callback(struct urb *urb)
 			spin_unlock_irqrestore(&hw->ctlxq.lock, flags);
 			goto retry;
 		}
-	}
-	else {
+	} else {
 		hw->req_timer_done = 1;
 	}
 
 	ctlx = get_active_ctlx(hw);
 
-	if ( urb->status == 0 ) {
+	if (urb->status == 0) {
 		/* Request portion of a CTLX is successful */
-		switch ( ctlx->state ) {
+		switch (ctlx->state) {
 		case CTLX_REQ_SUBMITTED:
 			/* This OUT-ACK received before IN */
 			ctlx->state = CTLX_REQ_COMPLETE;
@@ -4140,17 +3954,18 @@ static void hfa384x_ctlxout_callback(struct urb *urb)
 		default:
 			/* This is NOT a valid CTLX "success" state! */
 			printk(KERN_ERR
-			    "Illegal CTLX[%d] success state(%s, %d) in OUT URB\n",
-			    hfa384x2host_16(ctlx->outbuf.type),
-			    ctlxstr(ctlx->state), urb->status);
+			       "Illegal CTLX[%d] success state(%s, %d) in OUT URB\n",
+			       hfa384x2host_16(ctlx->outbuf.type),
+			       ctlxstr(ctlx->state), urb->status);
 			break;
-		} /* switch */
+		}		/* switch */
 	} else {
 		/* If the pipe has stalled then we need to reset it */
-		if ( (urb->status == -EPIPE) &&
-		      !test_and_set_bit(WORK_TX_HALT, &hw->usb_flags) ) {
-			printk(KERN_WARNING "%s tx pipe stalled: requesting reset\n",
-			                 hw->wlandev->netdev->name);
+		if ((urb->status == -EPIPE) &&
+		    !test_and_set_bit(WORK_TX_HALT, &hw->usb_flags)) {
+			printk(KERN_WARNING
+			       "%s tx pipe stalled: requesting reset\n",
+			       hw->wlandev->netdev->name);
 			schedule_work(&hw->usb_work);
 		}
 
@@ -4163,7 +3978,7 @@ static void hfa384x_ctlxout_callback(struct urb *urb)
 		run_queue = 1;
 	}
 
- delresp:
+delresp:
 	if (delete_resptimer) {
 		if ((timer_ok = del_timer(&hw->resptimer)) != 0) {
 			hw->resp_timer_done = 1;
@@ -4172,7 +3987,7 @@ static void hfa384x_ctlxout_callback(struct urb *urb)
 
 	spin_unlock_irqrestore(&hw->ctlxq.lock, flags);
 
-	if ( !timer_ok && (hw->resp_timer_done == 0) ) {
+	if (!timer_ok && (hw->resp_timer_done == 0)) {
 		spin_lock_irqsave(&hw->ctlxq.lock, flags);
 		goto delresp;
 	}
@@ -4180,11 +3995,10 @@ static void hfa384x_ctlxout_callback(struct urb *urb)
 	if (run_queue)
 		hfa384x_usbctlxq_run(hw);
 
- done:
-        ;
+done:
+	;
 }
 
-
 /*----------------------------------------------------------------
 * hfa384x_usbctlx_reqtimerfn
 *
@@ -4203,11 +4017,10 @@ static void hfa384x_ctlxout_callback(struct urb *urb)
 * Call context:
 *	interrupt
 ----------------------------------------------------------------*/
-static void
-hfa384x_usbctlx_reqtimerfn(unsigned long data)
+static void hfa384x_usbctlx_reqtimerfn(unsigned long data)
 {
-	hfa384x_t	*hw = (hfa384x_t*)data;
-	unsigned long   flags;
+	hfa384x_t *hw = (hfa384x_t *) data;
+	unsigned long flags;
 
 	spin_lock_irqsave(&hw->ctlxq.lock, flags);
 
@@ -4216,15 +4029,13 @@ hfa384x_usbctlx_reqtimerfn(unsigned long data)
 	/* Removing the hardware automatically empties
 	 * the active list ...
 	 */
-	if ( !list_empty(&hw->ctlxq.active) )
-	{
+	if (!list_empty(&hw->ctlxq.active)) {
 		/*
 		 * We must ensure that our URB is removed from
 		 * the system, if it hasn't already expired.
 		 */
 		hw->ctlx_urb.transfer_flags |= URB_ASYNC_UNLINK;
-		if (usb_unlink_urb(&hw->ctlx_urb) == -EINPROGRESS)
-		{
+		if (usb_unlink_urb(&hw->ctlx_urb) == -EINPROGRESS) {
 			hfa384x_usbctlx_t *ctlx = get_active_ctlx(hw);
 
 			ctlx->state = CTLX_REQ_FAILED;
@@ -4246,7 +4057,6 @@ hfa384x_usbctlx_reqtimerfn(unsigned long data)
 	spin_unlock_irqrestore(&hw->ctlxq.lock, flags);
 }
 
-
 /*----------------------------------------------------------------
 * hfa384x_usbctlx_resptimerfn
 *
@@ -4265,11 +4075,10 @@ hfa384x_usbctlx_reqtimerfn(unsigned long data)
 * Call context:
 *	interrupt
 ----------------------------------------------------------------*/
-static void
-hfa384x_usbctlx_resptimerfn(unsigned long data)
+static void hfa384x_usbctlx_resptimerfn(unsigned long data)
 {
-	hfa384x_t *hw = (hfa384x_t*)data;
-	unsigned long   flags;
+	hfa384x_t *hw = (hfa384x_t *) data;
+	unsigned long flags;
 
 	spin_lock_irqsave(&hw->ctlxq.lock, flags);
 
@@ -4278,12 +4087,10 @@ hfa384x_usbctlx_resptimerfn(unsigned long data)
 	/* The active list will be empty if the
 	 * adapter has been unplugged ...
 	 */
-	if ( !list_empty(&hw->ctlxq.active) )
-	{
+	if (!list_empty(&hw->ctlxq.active)) {
 		hfa384x_usbctlx_t *ctlx = get_active_ctlx(hw);
 
-		if ( unlocked_usbctlx_cancel_async(hw, ctlx) == 0 )
-		{
+		if (unlocked_usbctlx_cancel_async(hw, ctlx) == 0) {
 			spin_unlock_irqrestore(&hw->ctlxq.lock, flags);
 			hfa384x_usbctlxq_run(hw);
 			goto done;
@@ -4292,8 +4099,8 @@ hfa384x_usbctlx_resptimerfn(unsigned long data)
 
 	spin_unlock_irqrestore(&hw->ctlxq.lock, flags);
 
- done:
-        ;
+done:
+	;
 
 }
 
@@ -4312,11 +4119,10 @@ hfa384x_usbctlx_resptimerfn(unsigned long data)
 * Call context:
 *	Interrupt
 ----------------------------------------------------------------*/
-static void
-hfa384x_usb_throttlefn(unsigned long data)
+static void hfa384x_usb_throttlefn(unsigned long data)
 {
-	hfa384x_t *hw = (hfa384x_t*)data;
-	unsigned long   flags;
+	hfa384x_t *hw = (hfa384x_t *) data;
+	unsigned long flags;
 
 	spin_lock_irqsave(&hw->ctlxq.lock, flags);
 
@@ -4325,22 +4131,19 @@ hfa384x_usb_throttlefn(unsigned long data)
 	 * so we use the bitwise OR instead of the logical OR.
 	 */
 	pr_debug("flags=0x%lx\n", hw->usb_flags);
-	if ( !hw->wlandev->hwremoved &&
-	     (
-	       (test_and_clear_bit(THROTTLE_RX, &hw->usb_flags) &&
-	       !test_and_set_bit(WORK_RX_RESUME, &hw->usb_flags))
-	       |
-	       (test_and_clear_bit(THROTTLE_TX, &hw->usb_flags) &&
-	        !test_and_set_bit(WORK_TX_RESUME, &hw->usb_flags))
-	     ) )
-	{
+	if (!hw->wlandev->hwremoved &&
+	    ((test_and_clear_bit(THROTTLE_RX, &hw->usb_flags) &&
+	      !test_and_set_bit(WORK_RX_RESUME, &hw->usb_flags))
+	     |
+	     (test_and_clear_bit(THROTTLE_TX, &hw->usb_flags) &&
+	      !test_and_set_bit(WORK_TX_RESUME, &hw->usb_flags))
+	    )) {
 		schedule_work(&hw->usb_work);
 	}
 
 	spin_unlock_irqrestore(&hw->ctlxq.lock, flags);
 }
 
-
 /*----------------------------------------------------------------
 * hfa384x_usbctlx_submit
 *
@@ -4359,10 +4162,7 @@ hfa384x_usb_throttlefn(unsigned long data)
 * Call context:
 *	process or interrupt
 ----------------------------------------------------------------*/
-static int
-hfa384x_usbctlx_submit(
-	hfa384x_t		*hw,
-	hfa384x_usbctlx_t	*ctlx)
+static int hfa384x_usbctlx_submit(hfa384x_t *hw, hfa384x_usbctlx_t *ctlx)
 {
 	unsigned long flags;
 	int ret;
@@ -4384,7 +4184,6 @@ hfa384x_usbctlx_submit(
 	return ret;
 }
 
-
 /*----------------------------------------------------------------
 * hfa384x_usbout_tx
 *
@@ -4425,10 +4224,9 @@ static void hfa384x_usbout_tx(wlandevice_t *wlandev, hfa384x_usbout_t *usbout)
 *
 * Call context:
 ----------------------------------------------------------------*/
-static int
-hfa384x_isgood_pdrcode(u16 pdrcode)
+static int hfa384x_isgood_pdrcode(u16 pdrcode)
 {
-	switch(pdrcode) {
+	switch (pdrcode) {
 	case HFA384x_PDR_END_OF_PDA:
 	case HFA384x_PDR_PCB_PARTNUM:
 	case HFA384x_PDR_PDAVER:
@@ -4462,23 +4260,20 @@ hfa384x_isgood_pdrcode(u16 pdrcode)
 		return 1;
 		break;
 	default:
-		if ( pdrcode < 0x1000 ) {
+		if (pdrcode < 0x1000) {
 			/* code is OK, but we don't know exactly what it is */
-			pr_debug(
-				"Encountered unknown PDR#=0x%04x, "
-				"assuming it's ok.\n",
-				pdrcode);
+			printk(KERN_DEBUG
+			       "Encountered unknown PDR#=0x%04x, "
+			       "assuming it's ok.\n", pdrcode);
 			return 1;
 		} else {
 			/* bad code */
-			pr_debug(
-				"Encountered unknown PDR#=0x%04x, "
-				"(>=0x1000), assuming it's bad.\n",
-				pdrcode);
+			printk(KERN_DEBUG
+			       "Encountered unknown PDR#=0x%04x, "
+			       "(>=0x1000), assuming it's bad.\n", pdrcode);
 			return 0;
 		}
 		break;
 	}
-	return 0; /* avoid compiler warnings */
+	return 0;		/* avoid compiler warnings */
 }
-

commit a7cf7bae3297f16bb4a2f00310377fec06d0ecd6
Author: Moritz Muehlenhoff <jmm@debian.org>
Date:   Sun Feb 8 02:01:00 2009 +0100

    Staging: wlan-ng: Replace WLAN_LOG_DEBUG() with printk(KERN_DEBUG
    
    Signed-off-by: Moritz Muehlenhoff <jmm@debian.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/wlan-ng/hfa384x_usb.c b/drivers/staging/wlan-ng/hfa384x_usb.c
index 036518e3b9ca..c37d002ee923 100644
--- a/drivers/staging/wlan-ng/hfa384x_usb.c
+++ b/drivers/staging/wlan-ng/hfa384x_usb.c
@@ -359,20 +359,20 @@ get_active_ctlx(hfa384x_t *hw)
 void
 dbprint_urb(struct urb* urb)
 {
-	WLAN_LOG_DEBUG(3,"urb->pipe=0x%08x\n", urb->pipe);
-	WLAN_LOG_DEBUG(3,"urb->status=0x%08x\n", urb->status);
-	WLAN_LOG_DEBUG(3,"urb->transfer_flags=0x%08x\n", urb->transfer_flags);
-	WLAN_LOG_DEBUG(3,"urb->transfer_buffer=0x%08x\n", (unsigned int)urb->transfer_buffer);
-	WLAN_LOG_DEBUG(3,"urb->transfer_buffer_length=0x%08x\n", urb->transfer_buffer_length);
-	WLAN_LOG_DEBUG(3,"urb->actual_length=0x%08x\n", urb->actual_length);
-	WLAN_LOG_DEBUG(3,"urb->bandwidth=0x%08x\n", urb->bandwidth);
-	WLAN_LOG_DEBUG(3,"urb->setup_packet(ctl)=0x%08x\n", (unsigned int)urb->setup_packet);
-	WLAN_LOG_DEBUG(3,"urb->start_frame(iso/irq)=0x%08x\n", urb->start_frame);
-	WLAN_LOG_DEBUG(3,"urb->interval(irq)=0x%08x\n", urb->interval);
-	WLAN_LOG_DEBUG(3,"urb->error_count(iso)=0x%08x\n", urb->error_count);
-	WLAN_LOG_DEBUG(3,"urb->timeout=0x%08x\n", urb->timeout);
-	WLAN_LOG_DEBUG(3,"urb->context=0x%08x\n", (unsigned int)urb->context);
-	WLAN_LOG_DEBUG(3,"urb->complete=0x%08x\n", (unsigned int)urb->complete);
+	pr_debug("urb->pipe=0x%08x\n", urb->pipe);
+	pr_debug("urb->status=0x%08x\n", urb->status);
+	pr_debug("urb->transfer_flags=0x%08x\n", urb->transfer_flags);
+	pr_debug("urb->transfer_buffer=0x%08x\n", (unsigned int)urb->transfer_buffer);
+	pr_debug("urb->transfer_buffer_length=0x%08x\n", urb->transfer_buffer_length);
+	pr_debug("urb->actual_length=0x%08x\n", urb->actual_length);
+	pr_debug("urb->bandwidth=0x%08x\n", urb->bandwidth);
+	pr_debug("urb->setup_packet(ctl)=0x%08x\n", (unsigned int)urb->setup_packet);
+	pr_debug("urb->start_frame(iso/irq)=0x%08x\n", urb->start_frame);
+	pr_debug("urb->interval(irq)=0x%08x\n", urb->interval);
+	pr_debug("urb->error_count(iso)=0x%08x\n", urb->error_count);
+	pr_debug("urb->timeout=0x%08x\n", urb->timeout);
+	pr_debug("urb->context=0x%08x\n", (unsigned int)urb->context);
+	pr_debug("urb->complete=0x%08x\n", (unsigned int)urb->complete);
 }
 #endif
 
@@ -725,7 +725,7 @@ usbctlx_get_status(const hfa384x_usb_cmdresp_t *cmdresp,
 	result->resp1 = hfa384x2host_16(cmdresp->resp1);
 	result->resp2 = hfa384x2host_16(cmdresp->resp2);
 
-	WLAN_LOG_DEBUG(4, "cmdresult:status=0x%04x "
+	pr_debug("cmdresult:status=0x%04x "
 	                  "resp0=0x%04x resp1=0x%04x resp2=0x%04x\n",
 	                result->status,
 	                result->resp0,
@@ -860,7 +860,7 @@ static int usbctlx_rmem_completor_fn(usbctlx_completor_t *head)
 {
 	usbctlx_rmem_completor_t *complete = (usbctlx_rmem_completor_t*)head;
 
-	WLAN_LOG_DEBUG(4,"rmemresp:len=%d\n", complete->rmemresp->frmlen);
+	pr_debug("rmemresp:len=%d\n", complete->rmemresp->frmlen);
 	memcpy(complete->data, complete->rmemresp->data, complete->len);
 	return 0;
 }
@@ -1095,7 +1095,7 @@ hfa384x_cmd_initialize(hfa384x_t *hw)
 	result = hfa384x_docmd_wait(hw, &cmd);
 
 
-	WLAN_LOG_DEBUG(3,"cmdresp.init: "
+	pr_debug("cmdresp.init: "
 		"status=0x%04x, resp0=0x%04x, "
 		"resp1=0x%04x, resp2=0x%04x\n",
 		cmd.result.status,
@@ -1277,7 +1277,7 @@ int hfa384x_cmd_download(hfa384x_t *hw, u16 mode, u16 lowaddr,
 	int	result = 0;
 	hfa384x_metacmd_t cmd;
 
-	WLAN_LOG_DEBUG(5,
+	printk(KERN_DEBUG
 		"mode=%d, lowaddr=0x%04x, highaddr=0x%04x, codelen=%d\n",
 		mode, lowaddr, highaddr, codelen);
 
@@ -1564,7 +1564,7 @@ hfa384x_docmd(
 
 	ctlx->outbufsize = sizeof(ctlx->outbuf.cmdreq);
 
-	WLAN_LOG_DEBUG(4, "cmdreq: cmd=0x%04x "
+	pr_debug("cmdreq: cmd=0x%04x "
 		"parm0=0x%04x parm1=0x%04x parm2=0x%04x\n",
 		cmd->cmd,
 		cmd->parm0,
@@ -1836,14 +1836,14 @@ hfa384x_dormem(
 
 	ctlx->outbufsize = sizeof(ctlx->outbuf.rmemreq);
 
-	WLAN_LOG_DEBUG(4,
+	pr_debug(
 		"type=0x%04x frmlen=%d offset=0x%04x page=0x%04x\n",
 		ctlx->outbuf.rmemreq.type,
 		ctlx->outbuf.rmemreq.frmlen,
 		ctlx->outbuf.rmemreq.offset,
 		ctlx->outbuf.rmemreq.page);
 
-	WLAN_LOG_DEBUG(4,"pktsize=%zd\n",
+	pr_debug("pktsize=%zd\n",
 		ROUNDUP64(sizeof(ctlx->outbuf.rmemreq)));
 
 	ctlx->reapable = mode;
@@ -1918,7 +1918,7 @@ hfa384x_dowmem(
 	int			result;
 	hfa384x_usbctlx_t	*ctlx;
 
-	WLAN_LOG_DEBUG(5, "page=0x%04x offset=0x%04x len=%d\n",
+	pr_debug("page=0x%04x offset=0x%04x len=%d\n",
 		page,offset,len);
 
 	ctlx = usbctlx_alloc();
@@ -2109,7 +2109,7 @@ int hfa384x_drvr_flashdl_enable(hfa384x_t *hw)
 	/* Check that a port isn't active */
 	for ( i = 0; i < HFA384x_PORTID_MAX; i++) {
 		if ( hw->port_enabled[i] ) {
-			WLAN_LOG_DEBUG(1,"called when port enabled.\n");
+			pr_debug("called when port enabled.\n");
 			return -EINVAL;
 		}
 	}
@@ -2133,7 +2133,7 @@ int hfa384x_drvr_flashdl_enable(hfa384x_t *hw)
 	}
 	hw->dltimeout = hfa384x2host_16(hw->dltimeout);
 
-	WLAN_LOG_DEBUG(1,"flashdl_enable\n");
+	pr_debug("flashdl_enable\n");
 
 	hw->dlstate = HFA384x_DLSTATE_FLASHENABLED;
 
@@ -2167,7 +2167,7 @@ int hfa384x_drvr_flashdl_disable(hfa384x_t *hw)
 		return -EINVAL;
 	}
 
-	WLAN_LOG_DEBUG(1,"flashdl_enable\n");
+	pr_debug("flashdl_enable\n");
 
 	/* There isn't much we can do at this point, so I don't */
 	/*  bother  w/ the return value */
@@ -2229,7 +2229,7 @@ hfa384x_drvr_flashdl_write(
 	int		i;
 	int		j;
 
-	WLAN_LOG_DEBUG(5,"daddr=0x%08x len=%d\n", daddr, len);
+	pr_debug("daddr=0x%08x len=%d\n", daddr, len);
 
 	/* Check that we're in the flash download state */
 	if ( hw->dlstate != HFA384x_DLSTATE_FLASHENABLED ) {
@@ -2242,7 +2242,7 @@ hfa384x_drvr_flashdl_write(
 	/* NOTE: dlbuffer RID stores the address in AUX format */
 	dlbufaddr = HFA384x_ADDR_AUX_MKFLAT(
 			hw->bufinfo.page, hw->bufinfo.offset);
-	WLAN_LOG_DEBUG(5,
+	pr_debug(
 		"dlbuf.page=0x%04x dlbuf.offset=0x%04x dlbufaddr=0x%08x\n",
 		hw->bufinfo.page, hw->bufinfo.offset, dlbufaddr);
 
@@ -2496,7 +2496,7 @@ hfa384x_drvr_ramdl_disable(hfa384x_t *hw)
 		return -EINVAL;
 	}
 
-	WLAN_LOG_DEBUG(3,"ramdl_disable()\n");
+	pr_debug("ramdl_disable()\n");
 
 	/* There isn't much we can do at this point, so I don't */
 	/*  bother  w/ the return value */
@@ -2555,7 +2555,7 @@ hfa384x_drvr_ramdl_enable(hfa384x_t *hw, u32 exeaddr)
 		return -EINVAL;
 	}
 
-	WLAN_LOG_DEBUG(3,"ramdl_enable, exeaddr=0x%08x\n", exeaddr);
+	pr_debug("ramdl_enable, exeaddr=0x%08x\n", exeaddr);
 
 	/* Call the download(1,addr) function */
 	lowaddr = HFA384x_ADDR_CMD_MKOFF(exeaddr);
@@ -2568,7 +2568,7 @@ hfa384x_drvr_ramdl_enable(hfa384x_t *hw, u32 exeaddr)
 		/* Set the download state */
 		hw->dlstate = HFA384x_DLSTATE_RAMENABLED;
 	} else {
-		WLAN_LOG_DEBUG(1,
+		pr_debug(
 			"cmd_download(0x%04x, 0x%04x) failed, result=%d.\n",
 			lowaddr,
 			hiaddr,
@@ -2773,7 +2773,7 @@ int hfa384x_drvr_readpda(hfa384x_t *hw, void *buf, unsigned int len)
 	result = pdaok ? 0 : -ENODATA;
 
 	if ( result ) {
-		WLAN_LOG_DEBUG(3,"Failure: pda is not okay\n");
+		pr_debug("Failure: pda is not okay\n");
 	}
 
 	return result;
@@ -2893,9 +2893,9 @@ int hfa384x_drvr_start(hfa384x_t *hw)
 			usb_kill_urb(&hw->rx_urb);
 			goto done;
 		} else {
-			WLAN_LOG_DEBUG(0, "First cmd_initialize() failed (result %d),\n",
+			pr_debug("First cmd_initialize() failed (result %d),\n",
 				result1);
-			WLAN_LOG_DEBUG(0, "but second attempt succeeded. All should be ok\n");
+			pr_debug("but second attempt succeeded. All should be ok\n");
 		}
 	} else if (result2 != 0) {
 		printk(KERN_WARNING
@@ -3490,18 +3490,18 @@ static void hfa384x_usbin_callback(struct urb *urb)
 
 	case -ENODEV:
 	case -ESHUTDOWN:
-		WLAN_LOG_DEBUG(3,"status=%d, device removed.\n", urb->status);
+		pr_debug("status=%d, device removed.\n", urb->status);
 		action = ABORT;
 		break;
 
 	case -ENOENT:
 	case -ECONNRESET:
-		WLAN_LOG_DEBUG(3,"status=%d, urb explicitly unlinked.\n", urb->status);
+		pr_debug("status=%d, urb explicitly unlinked.\n", urb->status);
 		action = ABORT;
 		break;
 
 	default:
-		WLAN_LOG_DEBUG(3,"urb status=%d, transfer flags=0x%x\n",
+		pr_debug("urb status=%d, transfer flags=0x%x\n",
 		                 urb->status, urb->transfer_flags);
 		++(wlandev->linux_stats.rx_errors);
 		action = RESUBMIT;
@@ -3561,17 +3561,17 @@ static void hfa384x_usbin_callback(struct urb *urb)
 		break;
 
 	case HFA384x_USB_BUFAVAIL:
-		WLAN_LOG_DEBUG(3,"Received BUFAVAIL packet, frmlen=%d\n",
+		pr_debug("Received BUFAVAIL packet, frmlen=%d\n",
 			usbin->bufavail.frmlen);
 		break;
 
 	case HFA384x_USB_ERROR:
-		WLAN_LOG_DEBUG(3,"Received USB_ERROR packet, errortype=%d\n",
+		pr_debug("Received USB_ERROR packet, errortype=%d\n",
 			usbin->usberror.errortype);
 		break;
 
 	default:
-		WLAN_LOG_DEBUG(3,"Unrecognized USBIN packet, type=%x, status=%d\n",
+		pr_debug("Unrecognized USBIN packet, type=%x, status=%d\n",
 			usbin->type, urb_status);
 		break;
 	} /* switch */
@@ -3670,7 +3670,7 @@ static void hfa384x_usbin_ctlx(hfa384x_t *hw, hfa384x_usbin_t *usbin,
 			 * our request has been acknowledged. Odd,
 			 * but our OUT URB is still alive...
 			 */
-			WLAN_LOG_DEBUG(0, "Causality violation: please reboot Universe, or email linux-wlan-devel@lists.linux-wlan.com\n");
+			pr_debug("Causality violation: please reboot Universe, or email linux-wlan-devel@lists.linux-wlan.com\n");
 			ctlx->state = CTLX_RESP_COMPLETE;
 			break;
 
@@ -3828,7 +3828,7 @@ static void hfa384x_usbin_rx(wlandevice_t *wlandev, struct sk_buff *skb)
 			hfa384x_int_rxmonitor( wlandev, &usbin->rxfrm);
 			dev_kfree_skb(skb);
 		} else {
-			WLAN_LOG_DEBUG(3,"Received monitor frame: FCSerr set\n");
+			pr_debug("Received monitor frame: FCSerr set\n");
 		}
 		break;
 
@@ -3889,7 +3889,7 @@ static void hfa384x_int_rxmonitor( wlandevice_t *wlandev, hfa384x_usb_rxfrm_t *r
 	if ( skblen >
 	     (sizeof(p80211_caphdr_t) +
 	      WLAN_HDR_A4_LEN + WLAN_DATA_MAXLEN + WLAN_CRC_LEN) ) {
-		WLAN_LOG_DEBUG(1, "overlen frm: len=%zd\n",
+		pr_debug("overlen frm: len=%zd\n",
 			       skblen - sizeof(p80211_caphdr_t));
 	}
 
@@ -4076,7 +4076,7 @@ static void hfa384x_ctlxout_callback(struct urb *urb)
 	hfa384x_usbctlx_t	*ctlx;
 	unsigned long	flags;
 
-	WLAN_LOG_DEBUG(3,"urb->status=%d\n", urb->status);
+	pr_debug("urb->status=%d\n", urb->status);
 #ifdef DEBUG_USB
 	dbprint_urb(urb);
 #endif
@@ -4324,7 +4324,7 @@ hfa384x_usb_throttlefn(unsigned long data)
 	 * We need to check BOTH the RX and the TX throttle controls,
 	 * so we use the bitwise OR instead of the logical OR.
 	 */
-	WLAN_LOG_DEBUG(3, "flags=0x%lx\n", hw->usb_flags);
+	pr_debug("flags=0x%lx\n", hw->usb_flags);
 	if ( !hw->wlandev->hwremoved &&
 	     (
 	       (test_and_clear_bit(THROTTLE_RX, &hw->usb_flags) &&
@@ -4464,14 +4464,14 @@ hfa384x_isgood_pdrcode(u16 pdrcode)
 	default:
 		if ( pdrcode < 0x1000 ) {
 			/* code is OK, but we don't know exactly what it is */
-			WLAN_LOG_DEBUG(3,
+			pr_debug(
 				"Encountered unknown PDR#=0x%04x, "
 				"assuming it's ok.\n",
 				pdrcode);
 			return 1;
 		} else {
 			/* bad code */
-			WLAN_LOG_DEBUG(3,
+			pr_debug(
 				"Encountered unknown PDR#=0x%04x, "
 				"(>=0x1000), assuming it's bad.\n",
 				pdrcode);

commit ea045ba02086c008505ab1a6a7a60856072be65f
Author: Moritz Muehlenhoff <jmm@debian.org>
Date:   Thu Feb 5 23:55:54 2009 +0100

    Staging: wlan-ng: Remove WLAN_INCLUDE_DEBUG and some related, mostly unused
    
    Signed-off-by: Moritz Muehlenhoff <jmm@debian.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/wlan-ng/hfa384x_usb.c b/drivers/staging/wlan-ng/hfa384x_usb.c
index 60820da4aebf..036518e3b9ca 100644
--- a/drivers/staging/wlan-ng/hfa384x_usb.c
+++ b/drivers/staging/wlan-ng/hfa384x_usb.c
@@ -112,7 +112,6 @@
 
 /*================================================================*/
 /* System Includes */
-#define WLAN_DBVAR	prism2_debug
 
 #include <linux/version.h>
 
@@ -170,13 +169,6 @@ typedef enum cmd_mode CMD_MODE;
 
 #define ROUNDUP64(a) (((a)+63)&~63)
 
-/*================================================================*/
-/* Local Types */
-
-/*================================================================*/
-/* Local Static Definitions */
-extern int prism2_debug;
-
 /*================================================================*/
 /* Local Function Declarations */
 

commit acb7e24208124d1a268b78ba5c9b94f80d427c45
Author: Moritz Muehlenhoff <jmm@debian.org>
Date:   Sun Feb 1 13:29:07 2009 +0100

    Staging: wlan-ng: Remove dead/unused code from hfa384x.h and p80211metamsg.h
    
    Signed-off-by: Moritz Muehlenhoff <jmm@debian.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/wlan-ng/hfa384x_usb.c b/drivers/staging/wlan-ng/hfa384x_usb.c
index b6b1e9c27842..60820da4aebf 100644
--- a/drivers/staging/wlan-ng/hfa384x_usb.c
+++ b/drivers/staging/wlan-ng/hfa384x_usb.c
@@ -3042,7 +3042,6 @@ int hfa384x_drvr_txframe(hfa384x_t *hw, struct sk_buff *skb, p80211_hdr_t *p8021
 	/* if we're using host WEP, increase size by IV+ICV */
 	if (p80211_wep->data) {
 		hw->txbuff.txfrm.desc.data_len = host2hfa384x_16(skb->len+8);
-		// hw->txbuff.txfrm.desc.tx_control |= HFA384x_TX_NOENCRYPT_SET(1);
 		usbpktlen+=8;
 	} else {
 		hw->txbuff.txfrm.desc.data_len = host2hfa384x_16(skb->len);

commit 28aed9e3692efdb6d91bdd413288ffb9691cba46
Author: Moritz Muehlenhoff <jmm@debian.org>
Date:   Sun Feb 1 13:29:03 2009 +0100

    Staging: wlan-ng: Remove dead code from hfa384x_usb.c
    
    Signed-off-by: Moritz Muehlenhoff <jmm@debian.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/wlan-ng/hfa384x_usb.c b/drivers/staging/wlan-ng/hfa384x_usb.c
index 6dfbac33aed5..b6b1e9c27842 100644
--- a/drivers/staging/wlan-ng/hfa384x_usb.c
+++ b/drivers/staging/wlan-ng/hfa384x_usb.c
@@ -2318,18 +2318,6 @@ printk(KERN_WARNING "dlbuf@0x%06lx len=%d to=%d\n", dlbufaddr, hw->bufinfo.len,
 					writeoffset,
 					writebuf,
 					writelen );
-#if 0
-
-Comment out for debugging, assume the write was successful.
-			if (result) {
-				printk(KERN_ERR
-					"Write to dl buffer failed, "
-					"result=0x%04x. Aborting.\n",
-					result);
-				goto exit_proc;
-			}
-#endif
-
 		}
 
 		/* set the download 'write flash' mode */
@@ -2490,29 +2478,6 @@ int hfa384x_drvr_handover( hfa384x_t *hw, u8 *addr)
 	return -EIO;
 }
 
-/*----------------------------------------------------------------
-* hfa384x_drvr_low_level
-*
-* Write test commands to the card.  Some test commands don't make
-* sense without prior set-up.  For example, continous TX isn't very
-* useful until you set the channel.  That functionality should be
-*
-* Side effects:
-*
-* Call context:
-*      process thread
-* -----------------------------------------------------------------*/
-int hfa384x_drvr_low_level(hfa384x_t *hw, hfa384x_metacmd_t *cmd)
-{
-	int             result;
-
-	/* Do i need a host2hfa... conversion ? */
-
-	result = hfa384x_docmd_wait(hw, cmd);
-
-	return result;
-}
-
 /*----------------------------------------------------------------
 * hfa384x_drvr_ramdl_disable
 *

commit 9b9556ecc4bd8279aec195de84fd7d45a9883547
Author: Moritz Muehlenhoff <jmm@debian.org>
Date:   Sun Jan 25 21:55:01 2009 +0100

    Staging: wlan-ng: Replace WLAN_LOG_WARNING() with printk()
    
    Signed-off-by: Moritz Muehlenhoff <jmm@debian.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/wlan-ng/hfa384x_usb.c b/drivers/staging/wlan-ng/hfa384x_usb.c
index bdbb2125f216..6dfbac33aed5 100644
--- a/drivers/staging/wlan-ng/hfa384x_usb.c
+++ b/drivers/staging/wlan-ng/hfa384x_usb.c
@@ -427,7 +427,7 @@ submit_rx_urb(hfa384x_t *hw, gfp_t memflags)
 
 		/* Check whether we need to reset the RX pipe */
 		if (result == -EPIPE) {
-			WLAN_LOG_WARNING("%s rx pipe stalled: requesting reset\n",
+			printk(KERN_WARNING "%s rx pipe stalled: requesting reset\n",
 			                 hw->wlandev->netdev->name);
 			if ( !test_and_set_bit(WORK_RX_HALT, &hw->usb_flags) )
 				schedule_work(&hw->usb_work);
@@ -476,7 +476,7 @@ submit_tx_urb(hfa384x_t *hw, struct urb *tx_urb, gfp_t memflags)
 
 			/* Test whether we need to reset the TX pipe */
 			if (result == -EPIPE) {
-				WLAN_LOG_WARNING("%s tx pipe stalled: requesting reset\n",
+				printk(KERN_WARNING "%s tx pipe stalled: requesting reset\n",
 				                 netdev->name);
 				set_bit(WORK_TX_HALT, &hw->usb_flags);
 				schedule_work(&hw->usb_work);
@@ -809,7 +809,7 @@ static int usbctlx_rrid_completor_fn(usbctlx_completor_t *head)
 
 	/* Validate the length, note body len calculation in bytes */
 	if ( rridresult.riddata_len != complete->riddatalen ) {
-		WLAN_LOG_WARNING(
+		printk(KERN_WARNING
 			"RID len mismatch, rid=0x%04x hlen=%d fwlen=%d\n",
 		        rridresult.rid,
 		        complete->riddatalen,
@@ -1499,7 +1499,7 @@ static int hfa384x_usbctlx_complete_sync(hfa384x_t *hw,
 		if (ctlx->state == CTLX_COMPLETE) {
 			result = completor->complete(completor);
 		} else {
-			WLAN_LOG_WARNING("CTLX[%d] error: state(%s)\n",
+			printk(KERN_WARNING "CTLX[%d] error: state(%s)\n",
 			                 hfa384x2host_16(ctlx->outbuf.type),
 			                 ctlxstr(ctlx->state));
 			result = -EIO;
@@ -2255,7 +2255,7 @@ hfa384x_drvr_flashdl_write(
 		hw->bufinfo.page, hw->bufinfo.offset, dlbufaddr);
 
 #if 0
-WLAN_LOG_WARNING("dlbuf@0x%06lx len=%d to=%d\n", dlbufaddr, hw->bufinfo.len, hw->dltimeout);
+printk(KERN_WARNING "dlbuf@0x%06lx len=%d to=%d\n", dlbufaddr, hw->bufinfo.len, hw->dltimeout);
 #endif
 	/* Calculations to determine how many fills of the dlbuffer to do
 	 * and how many USB wmemreq's to do for each fill.  At this point
@@ -2764,7 +2764,7 @@ int hfa384x_drvr_readpda(hfa384x_t *hw, void *buf, unsigned int len)
 			len);		/* units of bytes */
 
 		if (result) {
-			WLAN_LOG_WARNING(
+			printk(KERN_WARNING
 					  "Read from index %zd failed, continuing\n",
 				i );
 			continue;
@@ -2941,10 +2941,10 @@ int hfa384x_drvr_start(hfa384x_t *hw)
 			WLAN_LOG_DEBUG(0, "but second attempt succeeded. All should be ok\n");
 		}
 	} else if (result2 != 0) {
-		WLAN_LOG_WARNING(
+		printk(KERN_WARNING
 			"First cmd_initialize() succeeded, but second attempt failed (result=%d)\n",
 			result2);
-		WLAN_LOG_WARNING("Most likely the card will be functional\n");
+		printk(KERN_WARNING "Most likely the card will be functional\n");
 			goto done;
 	}
 
@@ -3036,7 +3036,7 @@ int hfa384x_drvr_txframe(hfa384x_t *hw, struct sk_buff *skb, p80211_hdr_t *p8021
 	char		*ptr;
 
 	if (hw->tx_urb.status == -EINPROGRESS) {
-		WLAN_LOG_WARNING("TX URB already in use\n");
+		printk(KERN_WARNING "TX URB already in use\n");
 		result = 3;
 		goto exit;
 	}
@@ -3423,7 +3423,7 @@ hfa384x_usbctlxq_run(hfa384x_t	*hw)
 			 * this CTLX back in the "pending" queue
 			 * and schedule a reset ...
 			 */
-			WLAN_LOG_WARNING("%s tx pipe stalled: requesting reset\n",
+			printk(KERN_WARNING "%s tx pipe stalled: requesting reset\n",
 			                 hw->wlandev->netdev->name);
 			list_move(&head->list, &hw->ctlxq.pending);
 			set_bit(WORK_TX_HALT, &hw->usb_flags);
@@ -3432,7 +3432,7 @@ hfa384x_usbctlxq_run(hfa384x_t	*hw)
 		}
 
 		if (result == -ESHUTDOWN) {
-			WLAN_LOG_WARNING("%s urb shutdown!\n",
+			printk(KERN_WARNING "%s urb shutdown!\n",
 					 hw->wlandev->netdev->name);
 			break;
 		}
@@ -3508,7 +3508,7 @@ static void hfa384x_usbin_callback(struct urb *urb)
 		break;
 
 	case -EPIPE:
-		WLAN_LOG_WARNING("%s rx pipe stalled: requesting reset\n",
+		printk(KERN_WARNING "%s rx pipe stalled: requesting reset\n",
 		                 wlandev->netdev->name);
 		if ( !test_and_set_bit(WORK_RX_HALT, &hw->usb_flags) )
 			schedule_work(&hw->usb_work);
@@ -3698,7 +3698,7 @@ static void hfa384x_usbin_ctlx(hfa384x_t *hw, hfa384x_usbin_t *usbin,
 		 * Check that our message is what we're expecting ...
 		 */
 		if (ctlx->outbuf.type != intype) {
-			WLAN_LOG_WARNING("Expected IN[%d], received IN[%d] - ignored.\n",
+			printk(KERN_WARNING "Expected IN[%d], received IN[%d] - ignored.\n",
 			                 hfa384x2host_16(ctlx->outbuf.type),
 			                 hfa384x2host_16(intype));
 			goto unlock;
@@ -3877,7 +3877,7 @@ static void hfa384x_usbin_rx(wlandevice_t *wlandev, struct sk_buff *skb)
 		break;
 
 	default:
-		WLAN_LOG_WARNING("Received frame on unsupported port=%d\n",
+		printk(KERN_WARNING "Received frame on unsupported port=%d\n",
 			HFA384x_RXSTATUS_MACPORT_GET(usbin->rxfrm.desc.status) );
 		goto done;
 		break;
@@ -4057,7 +4057,7 @@ static void hfa384x_usbout_callback(struct urb *urb)
 		case -EPIPE:
 		{
 			hfa384x_t *hw = wlandev->priv;
-			WLAN_LOG_WARNING("%s tx pipe stalled: requesting reset\n",
+			printk(KERN_WARNING "%s tx pipe stalled: requesting reset\n",
 			                 wlandev->netdev->name);
 			if ( !test_and_set_bit(WORK_TX_HALT, &hw->usb_flags) )
 				schedule_work(&hw->usb_work);
@@ -4193,7 +4193,7 @@ static void hfa384x_ctlxout_callback(struct urb *urb)
 		/* If the pipe has stalled then we need to reset it */
 		if ( (urb->status == -EPIPE) &&
 		      !test_and_set_bit(WORK_TX_HALT, &hw->usb_flags) ) {
-			WLAN_LOG_WARNING("%s tx pipe stalled: requesting reset\n",
+			printk(KERN_WARNING "%s tx pipe stalled: requesting reset\n",
 			                 hw->wlandev->netdev->name);
 			schedule_work(&hw->usb_work);
 		}

commit edbd606c4671fcd439164c8d63e896044d706156
Author: Moritz Muehlenhoff <jmm@debian.org>
Date:   Sun Jan 25 21:55:00 2009 +0100

    Staging: wlan-ng: Replace WLAN_LOG_ERROR() with printk()
    
    Signed-off-by: Moritz Muehlenhoff <jmm@debian.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/wlan-ng/hfa384x_usb.c b/drivers/staging/wlan-ng/hfa384x_usb.c
index 495cd12f5e6c..bdbb2125f216 100644
--- a/drivers/staging/wlan-ng/hfa384x_usb.c
+++ b/drivers/staging/wlan-ng/hfa384x_usb.c
@@ -1330,7 +1330,7 @@ void
 hfa384x_copy_from_aux(
 	hfa384x_t *hw, u32 cardaddr, u32 auxctl, void *buf, unsigned int len)
 {
-	WLAN_LOG_ERROR("not used in USB.\n");
+	printk(KERN_ERR "not used in USB.\n");
 }
 
 
@@ -1362,7 +1362,7 @@ void
 hfa384x_copy_to_aux(
 	hfa384x_t *hw, u32 cardaddr, u32 auxctl, void *buf, unsigned int len)
 {
-	WLAN_LOG_ERROR("not used in USB.\n");
+	printk(KERN_ERR "not used in USB.\n");
 }
 
 
@@ -1395,7 +1395,7 @@ int hfa384x_corereset(hfa384x_t *hw, int holdtime, int settletime, int genesis)
 
 	result=usb_reset_device(hw->usb);
 	if(result<0) {
-		WLAN_LOG_ERROR("usb_reset_device() failed, result=%d.\n",result);
+		printk(KERN_ERR "usb_reset_device() failed, result=%d.\n",result);
 	}
 
 	return result;
@@ -2289,7 +2289,7 @@ WLAN_LOG_WARNING("dlbuf@0x%06lx len=%d to=%d\n", dlbufaddr, hw->bufinfo.len, hw-
 		result = hfa384x_cmd_download(hw, HFA384x_PROGMODE_NV,
 				burnlo, burnhi, burnlen);
 		if ( result ) {
-			WLAN_LOG_ERROR("download(NV,lo=%x,hi=%x,len=%x) "
+			printk(KERN_ERR "download(NV,lo=%x,hi=%x,len=%x) "
 				"cmd failed, result=%d. Aborting d/l\n",
 				burnlo, burnhi, burnlen, result);
 			goto exit_proc;
@@ -2322,7 +2322,7 @@ WLAN_LOG_WARNING("dlbuf@0x%06lx len=%d to=%d\n", dlbufaddr, hw->bufinfo.len, hw-
 
 Comment out for debugging, assume the write was successful.
 			if (result) {
-				WLAN_LOG_ERROR(
+				printk(KERN_ERR
 					"Write to dl buffer failed, "
 					"result=0x%04x. Aborting.\n",
 					result);
@@ -2337,7 +2337,7 @@ Comment out for debugging, assume the write was successful.
 				HFA384x_PROGMODE_NVWRITE,
 				0,0,0);
 		if ( result ) {
-			WLAN_LOG_ERROR(
+			printk(KERN_ERR
 				"download(NVWRITE,lo=%x,hi=%x,len=%x) "
 				"cmd failed, result=%d. Aborting d/l\n",
 				burnlo, burnhi, burnlen, result);
@@ -2486,7 +2486,7 @@ hfa384x_drvr_setconfig_async(
 ----------------------------------------------------------------*/
 int hfa384x_drvr_handover( hfa384x_t *hw, u8 *addr)
 {
-	WLAN_LOG_ERROR("Not currently supported in USB!\n");
+	printk(KERN_ERR "Not currently supported in USB!\n");
 	return -EIO;
 }
 
@@ -2585,7 +2585,7 @@ hfa384x_drvr_ramdl_enable(hfa384x_t *hw, u32 exeaddr)
 	/* Check that a port isn't active */
 	for ( i = 0; i < HFA384x_PORTID_MAX; i++) {
 		if ( hw->port_enabled[i] ) {
-			WLAN_LOG_ERROR(
+			printk(KERN_ERR
 				"Can't download with a macport enabled.\n");
 			return -EINVAL;
 		}
@@ -2593,7 +2593,7 @@ hfa384x_drvr_ramdl_enable(hfa384x_t *hw, u32 exeaddr)
 
 	/* Check that we're not already in a download state */
 	if ( hw->dlstate != HFA384x_DLSTATE_DISABLED ) {
-		WLAN_LOG_ERROR(
+		printk(KERN_ERR
 			"Download state not disabled.\n");
 		return -EINVAL;
 	}
@@ -2778,14 +2778,14 @@ int hfa384x_drvr_readpda(hfa384x_t *hw, void *buf, unsigned int len)
 			pdrcode = hfa384x2host_16(pda[currpdr+1]);
 			/* Test the record length */
 			if ( pdrlen > HFA384x_PDR_LEN_MAX || pdrlen == 0) {
-				WLAN_LOG_ERROR("pdrlen invalid=%d\n",
+				printk(KERN_ERR "pdrlen invalid=%d\n",
 					pdrlen);
 				pdaok = 0;
 				break;
 			}
 			/* Test the code */
 			if ( !hfa384x_isgood_pdrcode(pdrcode) ) {
-				WLAN_LOG_ERROR("pdrcode invalid=%d\n",
+				printk(KERN_ERR "pdrcode invalid=%d\n",
 					pdrcode);
 				pdaok = 0;
 				break;
@@ -2883,23 +2883,23 @@ int hfa384x_drvr_start(hfa384x_t *hw)
 	 */
 	result = usb_get_status(hw->usb, USB_RECIP_ENDPOINT, hw->endp_in, &status);
 	if (result < 0) {
-		WLAN_LOG_ERROR(
+		printk(KERN_ERR
 			"Cannot get bulk in endpoint status.\n");
 		goto done;
 	}
 	if ((status == 1) && usb_clear_halt(hw->usb, hw->endp_in)) {
-		WLAN_LOG_ERROR(
+		printk(KERN_ERR
 			"Failed to reset bulk in endpoint.\n");
 	}
 
 	result = usb_get_status(hw->usb, USB_RECIP_ENDPOINT, hw->endp_out, &status);
 	if (result < 0) {
-		WLAN_LOG_ERROR(
+		printk(KERN_ERR
 			"Cannot get bulk out endpoint status.\n");
 		goto done;
 	}
 	if ((status == 1) && usb_clear_halt(hw->usb, hw->endp_out)) {
-		WLAN_LOG_ERROR(
+		printk(KERN_ERR
 			"Failed to reset bulk out endpoint.\n");
 	}
 
@@ -2909,7 +2909,7 @@ int hfa384x_drvr_start(hfa384x_t *hw)
 	/* Post the IN urb */
 	result = submit_rx_urb(hw, GFP_KERNEL);
 	if (result != 0) {
-		WLAN_LOG_ERROR(
+		printk(KERN_ERR
 			"Fatal, failed to submit RX URB, result=%d\n",
 			result);
 		goto done;
@@ -2930,7 +2930,7 @@ int hfa384x_drvr_start(hfa384x_t *hw)
 	result = result2 = hfa384x_cmd_initialize(hw);
 	if (result1 != 0) {
 		if (result2 != 0) {
-			WLAN_LOG_ERROR(
+			printk(KERN_ERR
 				"cmd_initialize() failed on two attempts, results %d and %d\n",
 				result1, result2);
 			usb_kill_urb(&hw->rx_urb);
@@ -3112,7 +3112,7 @@ int hfa384x_drvr_txframe(hfa384x_t *hw, struct sk_buff *skb, p80211_hdr_t *p8021
 	result = 1;
 	ret = submit_tx_urb(hw, &hw->tx_urb, GFP_ATOMIC);
 	if ( ret != 0 ) {
-		WLAN_LOG_ERROR(
+		printk(KERN_ERR
 			"submit_tx_urb() failed, error=%d\n", ret);
 		result = 3;
 	}
@@ -3337,7 +3337,7 @@ static void unlocked_usbctlx_complete(hfa384x_t *hw, hfa384x_usbctlx_t *ctlx)
 		break;
 
 	default:
-		WLAN_LOG_ERROR("CTLX[%d] not in a terminating state(%s)\n",
+		printk(KERN_ERR "CTLX[%d] not in a terminating state(%s)\n",
 		               hfa384x2host_16(ctlx->outbuf.type),
 		               ctlxstr(ctlx->state));
 		break;
@@ -3437,7 +3437,7 @@ hfa384x_usbctlxq_run(hfa384x_t	*hw)
 			break;
 		}
 
-		WLAN_LOG_ERROR("Failed to submit CTLX[%d]: error=%d\n",
+		printk(KERN_ERR "Failed to submit CTLX[%d]: error=%d\n",
 		               hfa384x2host_16(head->outbuf.type), result);
 		unlocked_usbctlx_complete(hw, head);
 	} /* while */
@@ -3559,7 +3559,7 @@ static void hfa384x_usbin_callback(struct urb *urb)
 		result = submit_rx_urb(hw, GFP_ATOMIC);
 
 		if (result != 0) {
-			WLAN_LOG_ERROR(
+			printk(KERN_ERR
 				"Fatal, failed to resubmit rx_urb. error=%d\n",
 				result);
 		}
@@ -3733,7 +3733,7 @@ static void hfa384x_usbin_ctlx(hfa384x_t *hw, hfa384x_usbin_t *usbin,
 			/*
 			 * Throw this CTLX away ...
 			 */
-			WLAN_LOG_ERROR("Matched IN URB, CTLX[%d] in invalid state(%s)."
+			printk(KERN_ERR "Matched IN URB, CTLX[%d] in invalid state(%s)."
 			               " Discarded.\n",
 			               hfa384x2host_16(ctlx->outbuf.type),
 			               ctlxstr(ctlx->state));
@@ -3938,7 +3938,7 @@ static void hfa384x_int_rxmonitor( wlandevice_t *wlandev, hfa384x_usb_rxfrm_t *r
 	}
 
 	if ( (skb = dev_alloc_skb(skblen)) == NULL ) {
-		WLAN_LOG_ERROR("alloc_skb failed trying to allocate %d bytes\n", skblen);
+		printk(KERN_ERR "alloc_skb failed trying to allocate %d bytes\n", skblen);
 		return;
 	}
 
@@ -4183,7 +4183,7 @@ static void hfa384x_ctlxout_callback(struct urb *urb)
 
 		default:
 			/* This is NOT a valid CTLX "success" state! */
-			WLAN_LOG_ERROR(
+			printk(KERN_ERR
 			    "Illegal CTLX[%d] success state(%s, %d) in OUT URB\n",
 			    hfa384x2host_16(ctlx->outbuf.type),
 			    ctlxstr(ctlx->state), urb->status);

commit 350f2f4bd6570f6f1996516ddd135ab2a95484de
Author: Moritz Muehlenhoff <jmm@debian.org>
Date:   Sun Jan 25 21:54:57 2009 +0100

    Staging: wlan-ng: Remove WLAN_LOG_INFO
    
    Replace WLAN_LOG_INFO with printk() and remove it.
    
    Signed-off-by: Moritz Muehlenhoff <jmm@debian.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/wlan-ng/hfa384x_usb.c b/drivers/staging/wlan-ng/hfa384x_usb.c
index 57180ee2067a..495cd12f5e6c 100644
--- a/drivers/staging/wlan-ng/hfa384x_usb.c
+++ b/drivers/staging/wlan-ng/hfa384x_usb.c
@@ -2244,7 +2244,7 @@ hfa384x_drvr_flashdl_write(
 		return -EINVAL;
 	}
 
-	WLAN_LOG_INFO("Download %d bytes to flash @0x%06x\n", len, daddr);
+	printk(KERN_INFO "Download %d bytes to flash @0x%06x\n", len, daddr);
 
 	/* Convert to flat address for arithmetic */
 	/* NOTE: dlbuffer RID stores the address in AUX format */
@@ -2282,7 +2282,7 @@ WLAN_LOG_WARNING("dlbuf@0x%06lx len=%d to=%d\n", dlbufaddr, hw->bufinfo.len, hw-
 		burnlo = HFA384x_ADDR_CMD_MKOFF(burndaddr);
 		burnhi = HFA384x_ADDR_CMD_MKPAGE(burndaddr);
 
-		WLAN_LOG_INFO("Writing %d bytes to flash @0x%06x\n",
+		printk(KERN_INFO "Writing %d bytes to flash @0x%06x\n",
 			burnlen, burndaddr);
 
 		/* Set the download mode */
@@ -2665,7 +2665,7 @@ hfa384x_drvr_ramdl_write(hfa384x_t *hw, u32 daddr, void* buf, u32 len)
 		return -EINVAL;
 	}
 
-	WLAN_LOG_INFO("Writing %d bytes to ram @0x%06x\n", len, daddr);
+	printk(KERN_INFO "Writing %d bytes to ram @0x%06x\n", len, daddr);
 
 	/* How many dowmem calls?  */
 	nwrites = len / HFA384x_USB_RWMEM_MAXLEN;
@@ -2802,7 +2802,7 @@ int hfa384x_drvr_readpda(hfa384x_t *hw, void *buf, unsigned int len)
 			}
 		}
 		if ( pdaok ) {
-			WLAN_LOG_INFO(
+			printk(KERN_INFO
 				"PDA Read from 0x%08x in %s space.\n",
 				pdaloc[i].cardaddr,
 				pdaloc[i].auxctl == 0 ? "EXTDS" :
@@ -4087,7 +4087,7 @@ static void hfa384x_usbout_callback(struct urb *urb)
 			break;
 
 		default:
-			WLAN_LOG_INFO("unknown urb->status=%d\n", urb->status);
+			printk(KERN_INFO "unknown urb->status=%d\n", urb->status);
 			++(wlandev->linux_stats.tx_errors);
 			break;
 		} /* switch */

commit 2d200d9f63786f7dd18d47e28c7b3eb8d261aae4
Author: Moritz Muehlenhoff <jmm@debian.org>
Date:   Sun Jan 25 21:54:56 2009 +0100

    Staging: wlan-ng: Move URB_ASYNC_UNLINK and USB_QUEUE_BULK out of wlan_compat.h
    
    Signed-off-by: Moritz Muehlenhoff <jmm@debian.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/wlan-ng/hfa384x_usb.c b/drivers/staging/wlan-ng/hfa384x_usb.c
index cea033411e47..57180ee2067a 100644
--- a/drivers/staging/wlan-ng/hfa384x_usb.c
+++ b/drivers/staging/wlan-ng/hfa384x_usb.c
@@ -162,6 +162,8 @@ enum cmd_mode
 typedef enum cmd_mode CMD_MODE;
 
 #define THROTTLE_JIFFIES	(HZ/8)
+#define URB_ASYNC_UNLINK 0
+#define USB_QUEUE_BULK 0
 
 /*================================================================*/
 /* Local Macros */

commit ae26230bf93d37de73febdd1990090dcbd489b38
Author: Moritz Muehlenhoff <jmm@debian.org>
Date:   Wed Jan 21 22:00:45 2009 +0100

    Staging: wlan-ng: Use generic byteorder macros
    
    This patch removes the ieee2host16(), ieee2host32(), host2ieee16()
    and host2ieee32() macros and replaces them with the generic ones.
    
    Signed-off-by: Moritz Muehlenhoff <jmm@debian.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/wlan-ng/hfa384x_usb.c b/drivers/staging/wlan-ng/hfa384x_usb.c
index a2dddae66c92..cea033411e47 100644
--- a/drivers/staging/wlan-ng/hfa384x_usb.c
+++ b/drivers/staging/wlan-ng/hfa384x_usb.c
@@ -130,6 +130,7 @@
 #include <asm/bitops.h>
 #include <linux/list.h>
 #include <linux/usb.h>
+#include <linux/byteorder/generic.h>
 
 #include "wlan_compat.h"
 
@@ -3817,7 +3818,7 @@ static void hfa384x_usbin_rx(wlandevice_t *wlandev, struct sk_buff *skb)
 	switch( HFA384x_RXSTATUS_MACPORT_GET(usbin->rxfrm.desc.status) )
 	{
 	case 0:
-		fc = ieee2host16(usbin->rxfrm.desc.frame_control);
+		fc = le16_to_cpu(usbin->rxfrm.desc.frame_control);
 
 		/* If exclude and we receive an unencrypted, drop it */
 		if ( (wlandev->hostwep & HOSTWEP_EXCLUDEUNENCRYPTED) &&
@@ -3918,7 +3919,7 @@ static void hfa384x_int_rxmonitor( wlandevice_t *wlandev, hfa384x_usb_rxfrm_t *r
 
 	/* Don't forget the status, time, and data_len fields are in host order */
 	/* Figure out how big the frame is */
-	fc = ieee2host16(rxdesc->frame_control);
+	fc = le16_to_cpu(rxdesc->frame_control);
 	hdrlen = p80211_headerlen(fc);
 	datalen = hfa384x2host_16(rxdesc->data_len);
 

commit 8a251b55ef34c2a03e8ddf6d17bb125b92bb4a54
Author: Moritz Muehlenhoff <jmm@debian.org>
Date:   Wed Jan 21 22:00:44 2009 +0100

    Staging: wlan-ng: Remove DBFENTER/DBFEXIT macros
    
    Remove the ugly DBFENTER/DBFEXIT macros, which are only inserted to add "<---" and
    "--->" at the function start/end at higher debug levels and which make the code
    a lot less readable.
    
    Signed-off-by: Moritz Muehlenhoff <jmm@debian.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/wlan-ng/hfa384x_usb.c b/drivers/staging/wlan-ng/hfa384x_usb.c
index 8a75b50f8635..a2dddae66c92 100644
--- a/drivers/staging/wlan-ng/hfa384x_usb.c
+++ b/drivers/staging/wlan-ng/hfa384x_usb.c
@@ -404,8 +404,6 @@ submit_rx_urb(hfa384x_t *hw, gfp_t memflags)
 	struct sk_buff *skb;
 	int result;
 
-	DBFENTER;
-
 	skb = dev_alloc_skb(sizeof(hfa384x_usbin_t));
 	if (skb == NULL) {
 		result = -ENOMEM;
@@ -440,8 +438,6 @@ submit_rx_urb(hfa384x_t *hw, gfp_t memflags)
 	}
 
  done:
-
-	DBFEXIT;
 	return result;
 }
 
@@ -469,8 +465,6 @@ submit_tx_urb(hfa384x_t *hw, struct urb *tx_urb, gfp_t memflags)
 	struct net_device *netdev = hw->wlandev->netdev;
 	int result;
 
-	DBFENTER;
-
 	result = -ENOLINK;
 	if ( netif_running(netdev) ) {
 
@@ -489,8 +483,6 @@ submit_tx_urb(hfa384x_t *hw, struct urb *tx_urb, gfp_t memflags)
 		}
 	}
 
-	DBFEXIT;
-
 	return result;
 }
 
@@ -516,13 +508,10 @@ hfa384x_usb_defer(struct work_struct *data)
 	hfa384x_t *hw = container_of(data, struct hfa384x, usb_work);
 	struct net_device *netdev = hw->wlandev->netdev;
 
-	DBFENTER;
-
 	/* Don't bother trying to reset anything if the plug
 	 * has been pulled ...
 	 */
 	if ( hw->wlandev->hwremoved ) {
-		DBFEXIT;
 		return;
 	}
 
@@ -586,8 +575,6 @@ hfa384x_usb_defer(struct work_struct *data)
 	if ( test_and_clear_bit(WORK_TX_RESUME, &hw->usb_flags) ) {
 		netif_wake_queue(hw->wlandev->netdev);
 	}
-
-	DBFEXIT;
 }
 
 
@@ -615,8 +602,6 @@ hfa384x_usb_defer(struct work_struct *data)
 void
 hfa384x_create( hfa384x_t *hw, struct usb_device *usb)
 {
-	DBFENTER;
-
 	memset(hw, 0, sizeof(hfa384x_t));
 	hw->usb = usb;
 
@@ -669,8 +654,6 @@ hfa384x_create( hfa384x_t *hw, struct usb_device *usb)
 	init_timer(&hw->commsqual_timer);
 	hw->commsqual_timer.data = (unsigned long) hw;
 	hw->commsqual_timer.function = prism2sta_commsqual_timer;
-
-	DBFEXIT;
 }
 
 
@@ -701,8 +684,6 @@ hfa384x_destroy( hfa384x_t *hw)
 {
 	struct sk_buff *skb;
 
-	DBFENTER;
-
 	if ( hw->state == HFA384x_STATE_RUNNING ) {
 		hfa384x_drvr_stop(hw);
 	}
@@ -717,8 +698,6 @@ hfa384x_destroy( hfa384x_t *hw)
         while ( (skb = skb_dequeue(&hw->authq)) ) {
                 dev_kfree_skb(skb);
         }
-
-	DBFEXIT;
 }
 
 
@@ -746,8 +725,6 @@ static int
 usbctlx_get_status(const hfa384x_usb_cmdresp_t *cmdresp,
                    hfa384x_cmdresult_t *result)
 {
-	DBFENTER;
-
 	result->status = hfa384x2host_16(cmdresp->status);
 	result->resp0 = hfa384x2host_16(cmdresp->resp0);
 	result->resp1 = hfa384x2host_16(cmdresp->resp1);
@@ -760,7 +737,6 @@ usbctlx_get_status(const hfa384x_usb_cmdresp_t *cmdresp,
 	                result->resp1,
 	                result->resp2);
 
-	DBFEXIT;
 	return (result->status & HFA384x_STATUS_RESULT);
 }
 
@@ -768,13 +744,10 @@ static void
 usbctlx_get_rridresult(const hfa384x_usb_rridresp_t *rridresp,
                        hfa384x_rridresult_t *result)
 {
-	DBFENTER;
-
 	result->rid = hfa384x2host_16(rridresp->rid);
 	result->riddata = rridresp->data;
 	result->riddata_len = ((hfa384x2host_16(rridresp->frmlen) - 1) * 2);
 
-	DBFEXIT;
 }
 
 
@@ -934,8 +907,6 @@ init_rmem_completor(usbctlx_rmem_completor_t *completor,
 static void
 hfa384x_cb_status(hfa384x_t *hw, const hfa384x_usbctlx_t *ctlx)
 {
-	DBFENTER;
-
 	if ( ctlx->usercb != NULL ) {
 		hfa384x_cmdresult_t cmdresult;
 
@@ -948,8 +919,6 @@ hfa384x_cb_status(hfa384x_t *hw, const hfa384x_usbctlx_t *ctlx)
 
 		ctlx->usercb(hw, &cmdresult, ctlx->usercb_data);
 	}
-
-	DBFEXIT;
 }
 
 
@@ -976,8 +945,6 @@ hfa384x_cb_status(hfa384x_t *hw, const hfa384x_usbctlx_t *ctlx)
 static void
 hfa384x_cb_rrid(hfa384x_t *hw, const hfa384x_usbctlx_t *ctlx)
 {
-	DBFENTER;
-
 	if ( ctlx->usercb != NULL ) {
 		hfa384x_rridresult_t rridresult;
 
@@ -990,8 +957,6 @@ hfa384x_cb_rrid(hfa384x_t *hw, const hfa384x_usbctlx_t *ctlx)
 
 		ctlx->usercb(hw, &rridresult, ctlx->usercb_data);
 	}
-
-	DBFEXIT;
 }
 
 static inline int
@@ -1127,9 +1092,6 @@ hfa384x_cmd_initialize(hfa384x_t *hw)
 	int	i;
 	hfa384x_metacmd_t cmd;
 
-	DBFENTER;
-
-
 	cmd.cmd = HFA384x_CMDCODE_INIT;
 	cmd.parm0 = 0;
 	cmd.parm1 = 0;
@@ -1153,7 +1115,6 @@ hfa384x_cmd_initialize(hfa384x_t *hw)
 
         hw->link_status = HFA384x_LINK_NOTCONNECTED;
 
-	DBFEXIT;
 	return result;
 }
 
@@ -1183,8 +1144,6 @@ int hfa384x_cmd_disable(hfa384x_t *hw, u16 macport)
 	int	result = 0;
 	hfa384x_metacmd_t cmd;
 
-	DBFENTER;
-
 	cmd.cmd = HFA384x_CMD_CMDCODE_SET(HFA384x_CMDCODE_DISABLE) |
 		  HFA384x_CMD_MACPORT_SET(macport);
 	cmd.parm0 = 0;
@@ -1193,7 +1152,6 @@ int hfa384x_cmd_disable(hfa384x_t *hw, u16 macport)
 
 	result = hfa384x_docmd_wait(hw, &cmd);
 
-	DBFEXIT;
 	return result;
 }
 
@@ -1223,8 +1181,6 @@ int hfa384x_cmd_enable(hfa384x_t *hw, u16 macport)
 	int	result = 0;
 	hfa384x_metacmd_t cmd;
 
-	DBFENTER;
-
 	cmd.cmd = HFA384x_CMD_CMDCODE_SET(HFA384x_CMDCODE_ENABLE) |
 		  HFA384x_CMD_MACPORT_SET(macport);
 	cmd.parm0 = 0;
@@ -1233,7 +1189,6 @@ int hfa384x_cmd_enable(hfa384x_t *hw, u16 macport)
 
 	result = hfa384x_docmd_wait(hw, &cmd);
 
-	DBFEXIT;
 	return result;
 }
 
@@ -1271,8 +1226,6 @@ int hfa384x_cmd_monitor(hfa384x_t *hw, u16 enable)
 	int	result = 0;
 	hfa384x_metacmd_t cmd;
 
-	DBFENTER;
-
 	cmd.cmd = HFA384x_CMD_CMDCODE_SET(HFA384x_CMDCODE_MONITOR) |
 		HFA384x_CMD_AINFO_SET(enable);
 	cmd.parm0 = 0;
@@ -1281,7 +1234,6 @@ int hfa384x_cmd_monitor(hfa384x_t *hw, u16 enable)
 
 	result = hfa384x_docmd_wait(hw, &cmd);
 
-	DBFEXIT;
 	return result;
 }
 
@@ -1330,7 +1282,6 @@ int hfa384x_cmd_download(hfa384x_t *hw, u16 mode, u16 lowaddr,
 	int	result = 0;
 	hfa384x_metacmd_t cmd;
 
-	DBFENTER;
 	WLAN_LOG_DEBUG(5,
 		"mode=%d, lowaddr=0x%04x, highaddr=0x%04x, codelen=%d\n",
 		mode, lowaddr, highaddr, codelen);
@@ -1344,7 +1295,6 @@ int hfa384x_cmd_download(hfa384x_t *hw, u16 mode, u16 lowaddr,
 
 	result = hfa384x_docmd_wait(hw, &cmd);
 
-	DBFEXIT;
 	return result;
 }
 
@@ -1377,9 +1327,7 @@ void
 hfa384x_copy_from_aux(
 	hfa384x_t *hw, u32 cardaddr, u32 auxctl, void *buf, unsigned int len)
 {
-	DBFENTER;
 	WLAN_LOG_ERROR("not used in USB.\n");
-	DBFEXIT;
 }
 
 
@@ -1411,9 +1359,7 @@ void
 hfa384x_copy_to_aux(
 	hfa384x_t *hw, u32 cardaddr, u32 auxctl, void *buf, unsigned int len)
 {
-	DBFENTER;
 	WLAN_LOG_ERROR("not used in USB.\n");
-	DBFEXIT;
 }
 
 
@@ -1444,14 +1390,11 @@ int hfa384x_corereset(hfa384x_t *hw, int holdtime, int settletime, int genesis)
 {
 	int 			result = 0;
 
-	DBFENTER;
-
 	result=usb_reset_device(hw->usb);
 	if(result<0) {
 		WLAN_LOG_ERROR("usb_reset_device() failed, result=%d.\n",result);
 	}
 
-	DBFEXIT;
 	return result;
 }
 
@@ -1487,8 +1430,6 @@ static int hfa384x_usbctlx_complete_sync(hfa384x_t *hw,
 	unsigned long flags;
 	int result;
 
-	DBFENTER;
-
 	result = wait_for_completion_interruptible(&ctlx->done);
 
 	spin_lock_irqsave(&hw->ctlxq.lock, flags);
@@ -1566,7 +1507,6 @@ static int hfa384x_usbctlx_complete_sync(hfa384x_t *hw,
 		kfree(ctlx);
 	}
 
-	DBFEXIT;
 	return result;
 }
 
@@ -1614,7 +1554,6 @@ hfa384x_docmd(
 	int			result;
 	hfa384x_usbctlx_t	*ctlx;
 
-	DBFENTER;
 	ctlx = usbctlx_alloc();
 	if ( ctlx == NULL ) {
 		result = -ENOMEM;
@@ -1655,7 +1594,6 @@ hfa384x_docmd(
 	}
 
 done:
-	DBFEXIT;
 	return result;
 }
 
@@ -1710,7 +1648,6 @@ hfa384x_dorrid(
 	int			result;
 	hfa384x_usbctlx_t	*ctlx;
 
-	DBFENTER;
 	ctlx = usbctlx_alloc();
 	if ( ctlx == NULL ) {
 		result = -ENOMEM;
@@ -1745,7 +1682,6 @@ hfa384x_dorrid(
 	}
 
 done:
-	DBFEXIT;
 	return result;
 }
 
@@ -1796,7 +1732,6 @@ hfa384x_dowrid(
 	int			result;
 	hfa384x_usbctlx_t	*ctlx;
 
-	DBFENTER;
 	ctlx = usbctlx_alloc();
 	if ( ctlx == NULL ) {
 		result = -ENOMEM;
@@ -1838,7 +1773,6 @@ hfa384x_dowrid(
 	}
 
 done:
-	DBFEXIT;
 	return result;
 }
 
@@ -1890,7 +1824,6 @@ hfa384x_dormem(
 	int			result;
 	hfa384x_usbctlx_t	*ctlx;
 
-	DBFENTER;
 	ctlx = usbctlx_alloc();
 	if ( ctlx == NULL ) {
 		result = -ENOMEM;
@@ -1937,7 +1870,6 @@ hfa384x_dormem(
 	}
 
 done:
-	DBFEXIT;
 	return result;
 }
 
@@ -1991,7 +1923,6 @@ hfa384x_dowmem(
 	int			result;
 	hfa384x_usbctlx_t	*ctlx;
 
-	DBFENTER;
 	WLAN_LOG_DEBUG(5, "page=0x%04x offset=0x%04x len=%d\n",
 		page,offset,len);
 
@@ -2038,7 +1969,6 @@ hfa384x_dowmem(
 	}
 
 done:
-	DBFEXIT;
 	return result;
 }
 
@@ -2064,8 +1994,6 @@ int hfa384x_drvr_commtallies( hfa384x_t *hw )
 {
 	hfa384x_metacmd_t cmd;
 
-	DBFENTER;
-
 	cmd.cmd = HFA384x_CMDCODE_INQ;
 	cmd.parm0 = HFA384x_IT_COMMTALLIES;
 	cmd.parm1 = 0;
@@ -2073,7 +2001,6 @@ int hfa384x_drvr_commtallies( hfa384x_t *hw )
 
 	hfa384x_docmd_async(hw, &cmd, NULL, NULL, NULL);
 
-	DBFEXIT;
 	return 0;
 }
 
@@ -2104,7 +2031,6 @@ int hfa384x_drvr_disable(hfa384x_t *hw, u16 macport)
 {
 	int	result = 0;
 
-	DBFENTER;
 	if ((!hw->isap && macport != 0) ||
 	    (hw->isap && !(macport <= HFA384x_PORTID_MAX)) ||
 	    !(hw->port_enabled[macport]) ){
@@ -2115,7 +2041,6 @@ int hfa384x_drvr_disable(hfa384x_t *hw, u16 macport)
 			hw->port_enabled[macport] = 0;
 		}
 	}
-	DBFEXIT;
 	return result;
 }
 
@@ -2146,7 +2071,6 @@ int hfa384x_drvr_enable(hfa384x_t *hw, u16 macport)
 {
 	int	result = 0;
 
-	DBFENTER;
 	if ((!hw->isap && macport != 0) ||
 	    (hw->isap && !(macport <= HFA384x_PORTID_MAX)) ||
 	    (hw->port_enabled[macport]) ){
@@ -2157,7 +2081,6 @@ int hfa384x_drvr_enable(hfa384x_t *hw, u16 macport)
 			hw->port_enabled[macport] = 1;
 		}
 	}
-	DBFEXIT;
 	return result;
 }
 
@@ -2188,7 +2111,6 @@ int hfa384x_drvr_flashdl_enable(hfa384x_t *hw)
 	int		result = 0;
 	int		i;
 
-	DBFENTER;
 	/* Check that a port isn't active */
 	for ( i = 0; i < HFA384x_PORTID_MAX; i++) {
 		if ( hw->port_enabled[i] ) {
@@ -2219,7 +2141,7 @@ int hfa384x_drvr_flashdl_enable(hfa384x_t *hw)
 	WLAN_LOG_DEBUG(1,"flashdl_enable\n");
 
 	hw->dlstate = HFA384x_DLSTATE_FLASHENABLED;
-	DBFEXIT;
+
 	return result;
 }
 
@@ -2245,7 +2167,6 @@ int hfa384x_drvr_flashdl_enable(hfa384x_t *hw)
 ----------------------------------------------------------------*/
 int hfa384x_drvr_flashdl_disable(hfa384x_t *hw)
 {
-	DBFENTER;
 	/* Check that we're already in the download state */
 	if ( hw->dlstate != HFA384x_DLSTATE_FLASHENABLED ) {
 		return -EINVAL;
@@ -2258,7 +2179,6 @@ int hfa384x_drvr_flashdl_disable(hfa384x_t *hw)
 	hfa384x_cmd_download(hw, HFA384x_PROGMODE_DISABLE, 0, 0 , 0);
 	hw->dlstate = HFA384x_DLSTATE_DISABLED;
 
-	DBFEXIT;
 	return 0;
 }
 
@@ -2314,7 +2234,6 @@ hfa384x_drvr_flashdl_write(
 	int		i;
 	int		j;
 
-	DBFENTER;
 	WLAN_LOG_DEBUG(5,"daddr=0x%08x len=%d\n", daddr, len);
 
 	/* Check that we're in the flash download state */
@@ -2431,7 +2350,6 @@ Comment out for debugging, assume the write was successful.
 	/*  actually disable programming mode.  Remember, that will cause the */
 	/*  the firmware to effectively reset itself. */
 
-	DBFEXIT;
 	return result;
 }
 
@@ -2464,11 +2382,9 @@ Comment out for debugging, assume the write was successful.
 int hfa384x_drvr_getconfig(hfa384x_t *hw, u16 rid, void *buf, u16 len)
 {
 	int 			result;
-	DBFENTER;
 
 	result = hfa384x_dorrid_wait(hw, rid, buf, len);
 
-	DBFEXIT;
 	return result;
 }
 
@@ -2567,9 +2483,7 @@ hfa384x_drvr_setconfig_async(
 ----------------------------------------------------------------*/
 int hfa384x_drvr_handover( hfa384x_t *hw, u8 *addr)
 {
-        DBFENTER;
 	WLAN_LOG_ERROR("Not currently supported in USB!\n");
-	DBFEXIT;
 	return -EIO;
 }
 
@@ -2588,13 +2502,11 @@ int hfa384x_drvr_handover( hfa384x_t *hw, u8 *addr)
 int hfa384x_drvr_low_level(hfa384x_t *hw, hfa384x_metacmd_t *cmd)
 {
 	int             result;
-	DBFENTER;
 
 	/* Do i need a host2hfa... conversion ? */
 
 	result = hfa384x_docmd_wait(hw, cmd);
 
-	DBFEXIT;
 	return result;
 }
 
@@ -2619,7 +2531,6 @@ int hfa384x_drvr_low_level(hfa384x_t *hw, hfa384x_metacmd_t *cmd)
 int
 hfa384x_drvr_ramdl_disable(hfa384x_t *hw)
 {
-	DBFENTER;
 	/* Check that we're already in the download state */
 	if ( hw->dlstate != HFA384x_DLSTATE_RAMENABLED ) {
 		return -EINVAL;
@@ -2632,7 +2543,6 @@ hfa384x_drvr_ramdl_disable(hfa384x_t *hw)
 	hfa384x_cmd_download(hw, HFA384x_PROGMODE_DISABLE, 0, 0 , 0);
 	hw->dlstate = HFA384x_DLSTATE_DISABLED;
 
-	DBFEXIT;
 	return 0;
 }
 
@@ -2668,7 +2578,7 @@ hfa384x_drvr_ramdl_enable(hfa384x_t *hw, u32 exeaddr)
 	u16		lowaddr;
 	u16		hiaddr;
 	int		i;
-	DBFENTER;
+
 	/* Check that a port isn't active */
 	for ( i = 0; i < HFA384x_PORTID_MAX; i++) {
 		if ( hw->port_enabled[i] ) {
@@ -2705,7 +2615,6 @@ hfa384x_drvr_ramdl_enable(hfa384x_t *hw, u32 exeaddr)
 			result);
 	}
 
-	DBFEXIT;
 	return result;
 }
 
@@ -2747,7 +2656,7 @@ hfa384x_drvr_ramdl_write(hfa384x_t *hw, u32 daddr, void* buf, u32 len)
 	u16		currpage;
 	u16		curroffset;
 	u16		currlen;
-	DBFENTER;
+
 	/* Check that we're in the ram download state */
 	if ( hw->dlstate != HFA384x_DLSTATE_RAMENABLED ) {
 		return -EINVAL;
@@ -2782,7 +2691,6 @@ hfa384x_drvr_ramdl_write(hfa384x_t *hw, u32 daddr, void* buf, u32 len)
 		/* TODO: We really should have a readback. */
 	}
 
-	DBFEXIT;
 	return result;
 }
 
@@ -2840,8 +2748,6 @@ int hfa384x_drvr_readpda(hfa384x_t *hw, void *buf, unsigned int len)
 		{ HFA3841_PDA_BOGUS_BASE,	0}
 	};
 
-	DBFENTER;
-
 	/* Read the pda from each known address.  */
 	for ( i = 0; i < ARRAY_SIZE(pdaloc); i++) {
 		/* Make address */
@@ -2910,7 +2816,6 @@ int hfa384x_drvr_readpda(hfa384x_t *hw, void *buf, unsigned int len)
 		WLAN_LOG_DEBUG(3,"Failure: pda is not okay\n");
 	}
 
-	DBFEXIT;
 	return result;
 }
 
@@ -2965,7 +2870,6 @@ int hfa384x_drvr_start(hfa384x_t *hw)
 {
 	int		result, result1, result2;
 	u16		status;
-	DBFENTER;
 
 	might_sleep();
 
@@ -3044,7 +2948,6 @@ int hfa384x_drvr_start(hfa384x_t *hw)
 	hw->state = HFA384x_STATE_RUNNING;
 
 done:
-	DBFEXIT;
 	return result;
 }
 
@@ -3073,7 +2976,6 @@ hfa384x_drvr_stop(hfa384x_t *hw)
 {
 	int	result = 0;
 	int	i;
-	DBFENTER;
 
 	might_sleep();
 
@@ -3098,7 +3000,6 @@ hfa384x_drvr_stop(hfa384x_t *hw)
 		hw->port_enabled[i] = 0;
 	}
 
-	DBFEXIT;
 	return result;
 }
 
@@ -3131,8 +3032,6 @@ int hfa384x_drvr_txframe(hfa384x_t *hw, struct sk_buff *skb, p80211_hdr_t *p8021
 	int		ret;
 	char		*ptr;
 
-	DBFENTER;
-
 	if (hw->tx_urb.status == -EINPROGRESS) {
 		WLAN_LOG_WARNING("TX URB already in use\n");
 		result = 3;
@@ -3216,7 +3115,6 @@ int hfa384x_drvr_txframe(hfa384x_t *hw, struct sk_buff *skb, p80211_hdr_t *p8021
 	}
 
  exit:
-	DBFEXIT;
 	return result;
 }
 
@@ -3225,8 +3123,6 @@ void hfa384x_tx_timeout(wlandevice_t *wlandev)
 	hfa384x_t	*hw = wlandev->priv;
 	unsigned long flags;
 
-	DBFENTER;
-
 	spin_lock_irqsave(&hw->ctlxq.lock, flags);
 
 	if ( !hw->wlandev->hwremoved &&
@@ -3238,8 +3134,6 @@ void hfa384x_tx_timeout(wlandevice_t *wlandev)
 	}
 
 	spin_unlock_irqrestore(&hw->ctlxq.lock, flags);
-
-	DBFEXIT;
 }
 
 /*----------------------------------------------------------------
@@ -3262,8 +3156,6 @@ static void hfa384x_usbctlx_reaper_task(unsigned long data)
 	struct list_head *temp;
 	unsigned long	flags;
 
-	DBFENTER;
-
 	spin_lock_irqsave(&hw->ctlxq.lock, flags);
 
 	/* This list is guaranteed to be empty if someone
@@ -3279,7 +3171,6 @@ static void hfa384x_usbctlx_reaper_task(unsigned long data)
 
 	spin_unlock_irqrestore(&hw->ctlxq.lock, flags);
 
-	DBFEXIT;
 }
 
 /*----------------------------------------------------------------
@@ -3305,8 +3196,6 @@ static void hfa384x_usbctlx_completion_task(unsigned long data)
 
 	int reap = 0;
 
-	DBFENTER;
-
 	spin_lock_irqsave(&hw->ctlxq.lock, flags);
 
 	/* This list is guaranteed to be empty if someone
@@ -3361,8 +3250,6 @@ static void hfa384x_usbctlx_completion_task(unsigned long data)
 
 	if (reap)
 		tasklet_schedule(&hw->reaper_bh);
-
-	DBFEXIT;
 }
 
 /*----------------------------------------------------------------
@@ -3386,8 +3273,6 @@ static int unlocked_usbctlx_cancel_async(hfa384x_t *hw, hfa384x_usbctlx_t *ctlx)
 {
 	int ret;
 
-	DBFENTER;
-
 	/*
 	 * Try to delete the URB containing our request packet.
 	 * If we succeed, then its completion handler will be
@@ -3408,8 +3293,6 @@ static int unlocked_usbctlx_cancel_async(hfa384x_t *hw, hfa384x_usbctlx_t *ctlx)
 		ret = 0;
 	}
 
-	DBFEXIT;
-
 	return ret;
 }
 
@@ -3437,8 +3320,6 @@ static int unlocked_usbctlx_cancel_async(hfa384x_t *hw, hfa384x_usbctlx_t *ctlx)
 ----------------------------------------------------------------*/
 static void unlocked_usbctlx_complete(hfa384x_t *hw, hfa384x_usbctlx_t *ctlx)
 {
-	DBFENTER;
-
 	/* Timers have been stopped, and ctlx should be in
 	 * a terminal state. Retire it from the "active"
 	 * queue.
@@ -3458,8 +3339,6 @@ static void unlocked_usbctlx_complete(hfa384x_t *hw, hfa384x_usbctlx_t *ctlx)
 		               ctlxstr(ctlx->state));
 		break;
 	} /* switch */
-
-	DBFEXIT;
 }
 
 /*----------------------------------------------------------------
@@ -3482,7 +3361,6 @@ static void
 hfa384x_usbctlxq_run(hfa384x_t	*hw)
 {
 	unsigned long		flags;
-	DBFENTER;
 
 	/* acquire lock */
 	spin_lock_irqsave(&hw->ctlxq.lock, flags);
@@ -3563,8 +3441,6 @@ hfa384x_usbctlxq_run(hfa384x_t	*hw)
 
 	unlock:
 	spin_unlock_irqrestore(&hw->ctlxq.lock, flags);
-
-	DBFEXIT;
 }
 
 
@@ -3600,8 +3476,6 @@ static void hfa384x_usbin_callback(struct urb *urb)
 		ABORT
 	} action;
 
-	DBFENTER;
-
 	if ( !wlandev ||
 	     !wlandev->netdev ||
 	     wlandev->hwremoved )
@@ -3747,8 +3621,6 @@ static void hfa384x_usbin_callback(struct urb *urb)
 
 	if (skb)
 		dev_kfree_skb(skb);
-
-	DBFEXIT;
 }
 
 
@@ -3779,8 +3651,6 @@ static void hfa384x_usbin_ctlx(hfa384x_t *hw, hfa384x_usbin_t *usbin,
 	int			run_queue = 0;
 	unsigned long		flags;
 
-	DBFENTER;
-
 retry:
 	spin_lock_irqsave(&hw->ctlxq.lock, flags);
 
@@ -3875,8 +3745,6 @@ static void hfa384x_usbin_ctlx(hfa384x_t *hw, hfa384x_usbin_t *usbin,
 
 	if (run_queue)
 		hfa384x_usbctlxq_run(hw);
-
-	DBFEXIT;
 }
 
 
@@ -3900,7 +3768,6 @@ static void hfa384x_usbin_ctlx(hfa384x_t *hw, hfa384x_usbin_t *usbin,
 static void hfa384x_usbin_txcompl(wlandevice_t *wlandev, hfa384x_usbin_t *usbin)
 {
 	u16			status;
-	DBFENTER;
 
 	status = hfa384x2host_16(usbin->type); /* yeah I know it says type...*/
 
@@ -3911,8 +3778,6 @@ static void hfa384x_usbin_txcompl(wlandevice_t *wlandev, hfa384x_usbin_t *usbin)
 		prism2sta_ev_tx(wlandev, status);
 	}
 	// prism2sta_ev_alloc(wlandev);
-
-	DBFEXIT;
 }
 
 
@@ -3942,8 +3807,6 @@ static void hfa384x_usbin_rx(wlandevice_t *wlandev, struct sk_buff *skb)
 	u16                  data_len;
 	u16                  fc;
 
-	DBFENTER;
-
 	/* Byte order convert once up front. */
 	usbin->rxfrm.desc.status =
 		hfa384x2host_16(usbin->rxfrm.desc.status);
@@ -4018,7 +3881,6 @@ static void hfa384x_usbin_rx(wlandevice_t *wlandev, struct sk_buff *skb)
 	}
 
 done:
-	DBFEXIT;
 	return;
 }
 
@@ -4054,8 +3916,6 @@ static void hfa384x_int_rxmonitor( wlandevice_t *wlandev, hfa384x_usb_rxfrm_t *r
 	struct sk_buff			*skb;
 	hfa384x_t		        *hw = wlandev->priv;
 
-
-	DBFENTER;
 	/* Don't forget the status, time, and data_len fields are in host order */
 	/* Figure out how big the frame is */
 	fc = ieee2host16(rxdesc->frame_control);
@@ -4128,7 +3988,6 @@ static void hfa384x_int_rxmonitor( wlandevice_t *wlandev, hfa384x_usb_rxfrm_t *r
 	/* pass it back up */
 	prism2sta_ev_rx(wlandev, skb);
 
-	DBFEXIT;
 	return;
 }
 
@@ -4153,12 +4012,8 @@ static void hfa384x_int_rxmonitor( wlandevice_t *wlandev, hfa384x_usb_rxfrm_t *r
 ----------------------------------------------------------------*/
 static void hfa384x_usbin_info(wlandevice_t *wlandev, hfa384x_usbin_t *usbin)
 {
-	DBFENTER;
-
 	usbin->infofrm.info.framelen = hfa384x2host_16(usbin->infofrm.info.framelen);
 	prism2sta_ev_info(wlandev, &usbin->infofrm.info);
-
-	DBFEXIT;
 }
 
 
@@ -4183,7 +4038,6 @@ static void hfa384x_usbout_callback(struct urb *urb)
 {
 	wlandevice_t		*wlandev = urb->context;
 	hfa384x_usbout_t	*usbout = urb->transfer_buffer;
-	DBFENTER;
 
 #ifdef DEBUG_USB
 	dbprint_urb(urb);
@@ -4235,8 +4089,6 @@ static void hfa384x_usbout_callback(struct urb *urb)
 			break;
 		} /* switch */
 	}
-
-	DBFEXIT;
 }
 
 
@@ -4265,8 +4117,6 @@ static void hfa384x_ctlxout_callback(struct urb *urb)
 	hfa384x_usbctlx_t	*ctlx;
 	unsigned long	flags;
 
-	DBFENTER;
-
 	WLAN_LOG_DEBUG(3,"urb->status=%d\n", urb->status);
 #ifdef DEBUG_USB
 	dbprint_urb(urb);
@@ -4372,7 +4222,7 @@ static void hfa384x_ctlxout_callback(struct urb *urb)
 		hfa384x_usbctlxq_run(hw);
 
  done:
-	DBFEXIT;
+        ;
 }
 
 
@@ -4399,7 +4249,6 @@ hfa384x_usbctlx_reqtimerfn(unsigned long data)
 {
 	hfa384x_t	*hw = (hfa384x_t*)data;
 	unsigned long   flags;
-	DBFENTER;
 
 	spin_lock_irqsave(&hw->ctlxq.lock, flags);
 
@@ -4436,8 +4285,6 @@ hfa384x_usbctlx_reqtimerfn(unsigned long data)
 	}
 
 	spin_unlock_irqrestore(&hw->ctlxq.lock, flags);
-
-	DBFEXIT;
 }
 
 
@@ -4465,8 +4312,6 @@ hfa384x_usbctlx_resptimerfn(unsigned long data)
 	hfa384x_t *hw = (hfa384x_t*)data;
 	unsigned long   flags;
 
-	DBFENTER;
-
 	spin_lock_irqsave(&hw->ctlxq.lock, flags);
 
 	hw->resp_timer_done = 1;
@@ -4489,7 +4334,8 @@ hfa384x_usbctlx_resptimerfn(unsigned long data)
 	spin_unlock_irqrestore(&hw->ctlxq.lock, flags);
 
  done:
-	DBFEXIT;
+        ;
+
 }
 
 /*----------------------------------------------------------------
@@ -4513,8 +4359,6 @@ hfa384x_usb_throttlefn(unsigned long data)
 	hfa384x_t *hw = (hfa384x_t*)data;
 	unsigned long   flags;
 
-	DBFENTER;
-
 	spin_lock_irqsave(&hw->ctlxq.lock, flags);
 
 	/*
@@ -4535,8 +4379,6 @@ hfa384x_usb_throttlefn(unsigned long data)
 	}
 
 	spin_unlock_irqrestore(&hw->ctlxq.lock, flags);
-
-	DBFEXIT;
 }
 
 
@@ -4566,8 +4408,6 @@ hfa384x_usbctlx_submit(
 	unsigned long flags;
 	int ret;
 
-	DBFENTER;
-
 	spin_lock_irqsave(&hw->ctlxq.lock, flags);
 
 	if (hw->wlandev->hwremoved) {
@@ -4582,7 +4422,6 @@ hfa384x_usbctlx_submit(
 		ret = 0;
 	}
 
-	DBFEXIT;
 	return ret;
 }
 
@@ -4608,11 +4447,7 @@ hfa384x_usbctlx_submit(
 ----------------------------------------------------------------*/
 static void hfa384x_usbout_tx(wlandevice_t *wlandev, hfa384x_usbout_t *usbout)
 {
-	DBFENTER;
-
 	prism2sta_ev_alloc(wlandev);
-
-	DBFEXIT;
 }
 
 /*----------------------------------------------------------------

commit 8636cdedc5be050fd83afa3b3681a0889d9058a9
Author: Richard Kennedy <richard@rsk.demon.co.uk>
Date:   Mon Nov 3 11:22:43 2008 +0000

    Staging: wlan-ng: hfa384x_usbin_callback: check for hardware removed
    
    hfa384x_usbin_callback: check for hardware removed
    
    copied from latest wlan-ng-devel version
    
    Signed-off-by: Richard Kennedy <richard@rsk.demon.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/wlan-ng/hfa384x_usb.c b/drivers/staging/wlan-ng/hfa384x_usb.c
index a26609bdc4a5..8a75b50f8635 100644
--- a/drivers/staging/wlan-ng/hfa384x_usb.c
+++ b/drivers/staging/wlan-ng/hfa384x_usb.c
@@ -3604,7 +3604,7 @@ static void hfa384x_usbin_callback(struct urb *urb)
 
 	if ( !wlandev ||
 	     !wlandev->netdev ||
-	     !netif_device_present(wlandev->netdev) )
+	     wlandev->hwremoved )
 		goto exit;
 
 	hw = wlandev->priv;

commit 7b7e7e84bdba1553c4a8a0d6b0fa4ebddfbac420
Author: Richard Kennedy <richard@rsk.demon.co.uk>
Date:   Mon Nov 3 11:16:09 2008 +0000

    Staging: wlan-ng: hfa384x_usb.c use newest version of 384x_drvr_start
    
    include the needed fixes from Karl Relton
    <karllinuxtest.relton@ntlworld.com>
    
    see thread on linux-wlan-devel mailing list
    "Possible cause of those pesky hfa384x_usbctlx_complete_sync errors"
    
    Signed-off-by: Richard Kennedy <richard@rsk.demon.co.uk>
    Cc: Karl Relton <karllinuxtest.relton@ntlworld.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/wlan-ng/hfa384x_usb.c b/drivers/staging/wlan-ng/hfa384x_usb.c
index 0df9a67c85da..a26609bdc4a5 100644
--- a/drivers/staging/wlan-ng/hfa384x_usb.c
+++ b/drivers/staging/wlan-ng/hfa384x_usb.c
@@ -2960,19 +2960,38 @@ int hfa384x_drvr_setconfig(hfa384x_t *hw, u16 rid, void *buf, u16 len)
 * Call context:
 *	process
 ----------------------------------------------------------------*/
+
 int hfa384x_drvr_start(hfa384x_t *hw)
 {
-	int		result;
+	int		result, result1, result2;
+	u16		status;
 	DBFENTER;
 
 	might_sleep();
 
-	if (usb_clear_halt(hw->usb, hw->endp_in)) {
+	/* Clear endpoint stalls - but only do this if the endpoint
+	 * is showing a stall status. Some prism2 cards seem to behave
+	 * badly if a clear_halt is called when the endpoint is already
+	 * ok
+	 */
+	result = usb_get_status(hw->usb, USB_RECIP_ENDPOINT, hw->endp_in, &status);
+	if (result < 0) {
+		WLAN_LOG_ERROR(
+			"Cannot get bulk in endpoint status.\n");
+		goto done;
+	}
+	if ((status == 1) && usb_clear_halt(hw->usb, hw->endp_in)) {
 		WLAN_LOG_ERROR(
 			"Failed to reset bulk in endpoint.\n");
 	}
 
-	if (usb_clear_halt(hw->usb, hw->endp_out)) {
+	result = usb_get_status(hw->usb, USB_RECIP_ENDPOINT, hw->endp_out, &status);
+	if (result < 0) {
+		WLAN_LOG_ERROR(
+			"Cannot get bulk out endpoint status.\n");
+		goto done;
+	}
+	if ((status == 1) && usb_clear_halt(hw->usb, hw->endp_out)) {
 		WLAN_LOG_ERROR(
 			"Failed to reset bulk out endpoint.\n");
 	}
@@ -2989,14 +3008,37 @@ int hfa384x_drvr_start(hfa384x_t *hw)
 		goto done;
 	}
 
-	/* call initialize */
-	result = hfa384x_cmd_initialize(hw);
-	if (result != 0) {
-		usb_kill_urb(&hw->rx_urb);
-		WLAN_LOG_ERROR(
-			"cmd_initialize() failed, result=%d\n",
-			result);
-		goto done;
+	/* Call initialize twice, with a 1 second sleep in between.
+	 * This is a nasty work-around since many prism2 cards seem to
+	 * need time to settle after an init from cold. The second
+	 * call to initialize in theory is not necessary - but we call
+	 * it anyway as a double insurance policy:
+	 * 1) If the first init should fail, the second may well succeed
+	 *    and the card can still be used
+	 * 2) It helps ensures all is well with the card after the first
+	 *    init and settle time.
+	 */
+	result1 = hfa384x_cmd_initialize(hw);
+	msleep(1000);
+	result = result2 = hfa384x_cmd_initialize(hw);
+	if (result1 != 0) {
+		if (result2 != 0) {
+			WLAN_LOG_ERROR(
+				"cmd_initialize() failed on two attempts, results %d and %d\n",
+				result1, result2);
+			usb_kill_urb(&hw->rx_urb);
+			goto done;
+		} else {
+			WLAN_LOG_DEBUG(0, "First cmd_initialize() failed (result %d),\n",
+				result1);
+			WLAN_LOG_DEBUG(0, "but second attempt succeeded. All should be ok\n");
+		}
+	} else if (result2 != 0) {
+		WLAN_LOG_WARNING(
+			"First cmd_initialize() succeeded, but second attempt failed (result=%d)\n",
+			result2);
+		WLAN_LOG_WARNING("Most likely the card will be functional\n");
+			goto done;
 	}
 
 	hw->state = HFA384x_STATE_RUNNING;

commit cbec30c4c00c9f5a7357f5c5dacb63ae2378afb4
Author: Solomon Peachy <pizza@shaftnet.org>
Date:   Wed Oct 29 10:42:57 2008 -0400

    Staging: wlan-ng: Delete a large pile of now-unused code.
    
    Signed-off-by: Solomon Peachy <pizza@shaftnet.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/wlan-ng/hfa384x_usb.c b/drivers/staging/wlan-ng/hfa384x_usb.c
index 1fcf8d12c0d0..0df9a67c85da 100644
--- a/drivers/staging/wlan-ng/hfa384x_usb.c
+++ b/drivers/staging/wlan-ng/hfa384x_usb.c
@@ -584,7 +584,7 @@ hfa384x_usb_defer(struct work_struct *data)
 
 	/* Resume transmitting. */
 	if ( test_and_clear_bit(WORK_TX_RESUME, &hw->usb_flags) ) {
-		p80211netdev_wake_queue(hw->wlandev);
+		netif_wake_queue(hw->wlandev->netdev);
 	}
 
 	DBFEXIT;
@@ -1237,95 +1237,6 @@ int hfa384x_cmd_enable(hfa384x_t *hw, u16 macport)
 	return result;
 }
 
-
-/*----------------------------------------------------------------
-* hfa384x_cmd_notify
-*
-* Sends an info frame to the firmware to alter the behavior
-* of the f/w asynch processes.  Can only be called when the MAC
-* is in the enabled state.
-*
-* Arguments:
-*	hw		device structure
-*	reclaim		[0|1] indicates whether the given FID will
-*			be handed back (via Alloc event) for reuse.
-*			(host order)
-*	fid		FID of buffer containing the frame that was
-*			previously copied to MAC memory via the bap.
-*			(host order)
-*
-* Returns:
-*	0		success
-*	>0		f/w reported failure - f/w status code
-*	<0		driver reported error (timeout|bad arg)
-*
-* Side effects:
-*	hw->resp0 will contain the FID being used by async notify
-*	process.  If reclaim==0, resp0 will be the same as the fid
-*	argument.  If reclaim==1, resp0 will be the different.
-*
-* Call context:
-*	process
-----------------------------------------------------------------*/
-int hfa384x_cmd_notify(hfa384x_t *hw, u16 reclaim, u16 fid,
-		       void *buf, u16 len)
-{
-#if 0
-	int	result = 0;
-	u16	cmd;
-	DBFENTER;
-	cmd =	HFA384x_CMD_CMDCODE_SET(HFA384x_CMDCODE_NOTIFY) |
-		HFA384x_CMD_RECL_SET(reclaim);
-	result = hfa384x_docmd_wait(hw, cmd);
-
-	DBFEXIT;
-	return result;
-#endif
-return 0;
-}
-
-
-#if 0
-/*----------------------------------------------------------------
-* hfa384x_cmd_inquiry
-*
-* Requests an info frame from the firmware.  The info frame will
-* be delivered asynchronously via the Info event.
-*
-* Arguments:
-*	hw		device structure
-*	fid		FID of the info frame requested. (host order)
-*
-* Returns:
-*	0		success
-*	>0		f/w reported failure - f/w status code
-*	<0		driver reported error (timeout|bad arg)
-*
-* Side effects:
-*
-* Call context:
-*	process
-----------------------------------------------------------------*/
-int hfa384x_cmd_inquiry(hfa384x_t *hw, u16 fid)
-{
-	int	result = 0;
-	hfa384x_metacmd_t cmd;
-
-	DBFENTER;
-
-	cmd.cmd = HFA384x_CMD_CMDCODE_SET(HFA384x_CMDCODE_INQ);
-	cmd.parm0 = 0;
-	cmd.parm1 = 0;
-	cmd.parm2 = 0;
-
-	result = hfa384x_docmd_wait(hw, &cmd);
-
-	DBFEXIT;
-	return result;
-}
-#endif
-
-
 /*----------------------------------------------------------------
 * hfa384x_cmd_monitor
 *
@@ -2687,88 +2598,6 @@ int hfa384x_drvr_low_level(hfa384x_t *hw, hfa384x_metacmd_t *cmd)
 	return result;
 }
 
-/*----------------------------------------------------------------
-* hfa384x_drvr_mmi_read
-*
-* Read mmi registers.  mmi is intersil-speak for the baseband
-* processor registers.
-*
-* Arguments:
-*       hw              device structure
-*       register        The test register to be accessed (must be even #).
-*
-* Returns:
-*       0               success
-*       >0              f/w reported error - f/w status code
-*       <0              driver reported error
-*
-* Side effects:
-*
-* Call context:
-*       process
-----------------------------------------------------------------*/
-int hfa384x_drvr_mmi_read(hfa384x_t *hw, u32 addr, u32 *resp)
-{
-#if 0
-        int             result = 0;
-        u16  cmd_code = (u16) 0x30;
-        u16 param = (u16) addr;
-        DBFENTER;
-
-        /* Do i need a host2hfa... conversion ? */
-        result = hfa384x_docmd_wait(hw, cmd_code);
-
-        DBFEXIT;
-        return result;
-#endif
-return 0;
-}
-
-/*----------------------------------------------------------------
-* hfa384x_drvr_mmi_write
-*
-* Read mmi registers.  mmi is intersil-speak for the baseband
-* processor registers.
-*
-* Arguments:
-*       hw              device structure
-*       addr            The test register to be accessed (must be even #).
-*       data            The data value to write to the register.
-*
-* Returns:
-*       0               success
-*       >0              f/w reported error - f/w status code
-*       <0              driver reported error
-*
-* Side effects:
-*
-* Call context:
-*       process
-----------------------------------------------------------------*/
-
-int
-hfa384x_drvr_mmi_write(hfa384x_t *hw, u32 addr, u32 data)
-{
-#if 0
-        int             result = 0;
-        u16  cmd_code = (u16) 0x31;
-        u16 param0 = (u16) addr;
-        u16 param1 = (u16) data;
-        DBFENTER;
-
-        WLAN_LOG_DEBUG(1,"mmi write : addr = 0x%08lx\n", addr);
-        WLAN_LOG_DEBUG(1,"mmi write : data = 0x%08lx\n", data);
-
-        /* Do i need a host2hfa... conversion ? */
-        result = hfa384x_docmd_wait(hw, cmd_code);
-
-        DBFEXIT;
-        return result;
-#endif
-return 0;
-}
-
-
 /*----------------------------------------------------------------
 * hfa384x_drvr_ramdl_disable
 *
@@ -4178,7 +4007,6 @@ static void hfa384x_int_rxmonitor( wlandevice_t *wlandev, hfa384x_usb_rxfrm_t *r
 	unsigned int				hdrlen = 0;
 	unsigned int				datalen = 0;
 	unsigned int				skblen = 0;
-	p80211msg_lnxind_wlansniffrm_t	*msg;
 	u8				*datap;
 	u16				fc;
 	struct sk_buff			*skb;
@@ -4193,15 +4021,15 @@ static void hfa384x_int_rxmonitor( wlandevice_t *wlandev, hfa384x_usb_rxfrm_t *r
 	datalen = hfa384x2host_16(rxdesc->data_len);
 
 	/* Allocate an ind message+framesize skb */
-	skblen = sizeof(p80211msg_lnxind_wlansniffrm_t) +
+	skblen = sizeof(p80211_caphdr_t) +
 		hdrlen + datalen + WLAN_CRC_LEN;
 
 	/* sanity check the length */
 	if ( skblen >
-		(sizeof(p80211msg_lnxind_wlansniffrm_t) +
-		WLAN_HDR_A4_LEN + WLAN_DATA_MAXLEN + WLAN_CRC_LEN) ) {
+	     (sizeof(p80211_caphdr_t) +
+	      WLAN_HDR_A4_LEN + WLAN_DATA_MAXLEN + WLAN_CRC_LEN) ) {
 		WLAN_LOG_DEBUG(1, "overlen frm: len=%zd\n",
-			skblen - sizeof(p80211msg_lnxind_wlansniffrm_t));
+			       skblen - sizeof(p80211_caphdr_t));
 	}
 
 	if ( (skb = dev_alloc_skb(skblen)) == NULL ) {
@@ -4211,66 +4039,7 @@ static void hfa384x_int_rxmonitor( wlandevice_t *wlandev, hfa384x_usb_rxfrm_t *r
 
 	/* only prepend the prism header if in the right mode */
 	if ((wlandev->netdev->type == ARPHRD_IEEE80211_PRISM) &&
-	    (hw->sniffhdr == 0)) {
-		datap = skb_put(skb, sizeof(p80211msg_lnxind_wlansniffrm_t));
-		msg = (p80211msg_lnxind_wlansniffrm_t*) datap;
-
-		/* Initialize the message members */
-		msg->msgcode = DIDmsg_lnxind_wlansniffrm;
-		msg->msglen = sizeof(p80211msg_lnxind_wlansniffrm_t);
-		strcpy(msg->devname, wlandev->name);
-
-		msg->hosttime.did = DIDmsg_lnxind_wlansniffrm_hosttime;
-		msg->hosttime.status = 0;
-		msg->hosttime.len = 4;
-		msg->hosttime.data = jiffies;
-
-		msg->mactime.did = DIDmsg_lnxind_wlansniffrm_mactime;
-		msg->mactime.status = 0;
-		msg->mactime.len = 4;
-		msg->mactime.data = rxdesc->time;
-
-		msg->channel.did = DIDmsg_lnxind_wlansniffrm_channel;
-		msg->channel.status = 0;
-		msg->channel.len = 4;
-		msg->channel.data = hw->sniff_channel;
-
-		msg->rssi.did = DIDmsg_lnxind_wlansniffrm_rssi;
-		msg->rssi.status = P80211ENUM_msgitem_status_no_value;
-		msg->rssi.len = 4;
-		msg->rssi.data = 0;
-
-		msg->sq.did = DIDmsg_lnxind_wlansniffrm_sq;
-		msg->sq.status = P80211ENUM_msgitem_status_no_value;
-		msg->sq.len = 4;
-		msg->sq.data = 0;
-
-		msg->signal.did = DIDmsg_lnxind_wlansniffrm_signal;
-		msg->signal.status = 0;
-		msg->signal.len = 4;
-		msg->signal.data = rxdesc->signal;
-
-		msg->noise.did = DIDmsg_lnxind_wlansniffrm_noise;
-		msg->noise.status = 0;
-		msg->noise.len = 4;
-		msg->noise.data = rxdesc->silence;
-
-		msg->rate.did = DIDmsg_lnxind_wlansniffrm_rate;
-		msg->rate.status = 0;
-		msg->rate.len = 4;
-		msg->rate.data = rxdesc->rate / 5; /* set to 802.11 units */
-
-		msg->istx.did = DIDmsg_lnxind_wlansniffrm_istx;
-		msg->istx.status = 0;
-		msg->istx.len = 4;
-		msg->istx.data = P80211ENUM_truth_false;
-
-		msg->frmlen.did = DIDmsg_lnxind_wlansniffrm_frmlen;
-		msg->frmlen.status = 0;
-		msg->frmlen.len = 4;
-		msg->frmlen.data = hdrlen + datalen + WLAN_CRC_LEN;
-	} else if ((wlandev->netdev->type == ARPHRD_IEEE80211_PRISM) &&
-		   (hw->sniffhdr != 0)) {
+	    (hw->sniffhdr != 0)) {
 		p80211_caphdr_t		*caphdr;
 		/* The NEW header format! */
 		datap = skb_put(skb, sizeof(p80211_caphdr_t));

commit 575a8a5c28005838fa82c228cd77138379df87ba
Author: Solomon Peachy <pizza@shaftnet.org>
Date:   Wed Oct 29 10:42:54 2008 -0400

    Staging: wlan-ng: Eliminate all backwards-compatible kernel code.
    
    It's not needed at all anymore now that we are in the kernel tree.
    
    Signed-off-by: Solomon Peachy <pizza@shaftnet.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/wlan-ng/hfa384x_usb.c b/drivers/staging/wlan-ng/hfa384x_usb.c
index ccb4f152a9bf..1fcf8d12c0d0 100644
--- a/drivers/staging/wlan-ng/hfa384x_usb.c
+++ b/drivers/staging/wlan-ng/hfa384x_usb.c
@@ -198,21 +198,12 @@ submit_tx_urb(hfa384x_t *hw, struct urb *tx_urb, gfp_t flags);
 
 /*---------------------------------------------------*/
 /* Callbacks */
-#ifdef URB_ONLY_CALLBACK
 static void
 hfa384x_usbout_callback(struct urb *urb);
 static void
 hfa384x_ctlxout_callback(struct urb *urb);
 static void
 hfa384x_usbin_callback(struct urb *urb);
-#else
-static void
-hfa384x_usbout_callback(struct urb *urb, struct pt_regs *regs);
-static void
-hfa384x_ctlxout_callback(struct urb *urb, struct pt_regs *regs);
-static void
-hfa384x_usbin_callback(struct urb *urb, struct pt_regs *regs);
-#endif
 
 static void
 hfa384x_usbin_txcompl(wlandevice_t *wlandev, hfa384x_usbin_t *usbin);
@@ -652,8 +643,8 @@ hfa384x_create( hfa384x_t *hw, struct usb_device *usb)
 	tasklet_init(&hw->completion_bh,
 	             hfa384x_usbctlx_completion_task,
 	             (unsigned long)hw);
-	INIT_WORK2(&hw->link_bh, prism2sta_processing_defer);
-	INIT_WORK2(&hw->usb_work, hfa384x_usb_defer);
+	INIT_WORK(&hw->link_bh, prism2sta_processing_defer);
+	INIT_WORK(&hw->usb_work, hfa384x_usb_defer);
 
 	init_timer(&hw->throttle);
 	hw->throttle.function = hfa384x_usb_throttlefn;
@@ -674,7 +665,7 @@ hfa384x_create( hfa384x_t *hw, struct usb_device *usb)
 	hw->link_status = HFA384x_LINK_NOTCONNECTED;
 	hw->state = HFA384x_STATE_INIT;
 
-        INIT_WORK2(&hw->commsqual_bh, prism2sta_commsqual_defer);
+        INIT_WORK(&hw->commsqual_bh, prism2sta_commsqual_defer);
 	init_timer(&hw->commsqual_timer);
 	hw->commsqual_timer.data = (unsigned long) hw;
 	hw->commsqual_timer.function = prism2sta_commsqual_timer;
@@ -3722,11 +3713,7 @@ hfa384x_usbctlxq_run(hfa384x_t	*hw)
 * Call context:
 *	interrupt
 ----------------------------------------------------------------*/
-#ifdef URB_ONLY_CALLBACK
 static void hfa384x_usbin_callback(struct urb *urb)
-#else
-static void hfa384x_usbin_callback(struct urb *urb, struct pt_regs *regs)
-#endif
 {
 	wlandevice_t		*wlandev = urb->context;
 	hfa384x_t		*hw;
@@ -4381,11 +4368,7 @@ static void hfa384x_usbin_info(wlandevice_t *wlandev, hfa384x_usbin_t *usbin)
 * Call context:
 *	interrupt
 ----------------------------------------------------------------*/
-#ifdef URB_ONLY_CALLBACK
 static void hfa384x_usbout_callback(struct urb *urb)
-#else
-static void hfa384x_usbout_callback(struct urb *urb, struct pt_regs *regs)
-#endif
 {
 	wlandevice_t		*wlandev = urb->context;
 	hfa384x_usbout_t	*usbout = urb->transfer_buffer;
@@ -4462,11 +4445,7 @@ static void hfa384x_usbout_callback(struct urb *urb, struct pt_regs *regs)
 * Call context:
 * interrupt
 ----------------------------------------------------------------*/
-#ifdef URB_ONLY_CALLBACK
 static void hfa384x_ctlxout_callback(struct urb *urb)
-#else
-static void hfa384x_ctlxout_callback(struct urb *urb, struct pt_regs *regs)
-#endif
 {
 	hfa384x_t	*hw = urb->context;
 	int             delete_resptimer = 0;

commit aaad430378dd128ee015c8ed6e77809317c496a5
Author: Solomon Peachy <pizza@shaftnet.org>
Date:   Wed Oct 29 10:42:53 2008 -0400

    Staging: wlan-ng: Use standard kernel integer (u32/s32/etc) types.
    
    wlan-ng needed to interact with userspace, and support very old kernels,
    so it used to define its own types for integers to ensure consistency.
    
    It's all rather irrelevant now.
    
    Signed-off-by: Solomon Peachy <pizza@shaftnet.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/wlan-ng/hfa384x_usb.c b/drivers/staging/wlan-ng/hfa384x_usb.c
index 53c547d36ed9..ccb4f152a9bf 100644
--- a/drivers/staging/wlan-ng/hfa384x_usb.c
+++ b/drivers/staging/wlan-ng/hfa384x_usb.c
@@ -299,9 +299,9 @@ static int
 hfa384x_dorrid(
 	hfa384x_t *hw,
 	CMD_MODE mode,
-	UINT16	rid,
+	u16	rid,
 	void	*riddata,
-	UINT	riddatalen,
+	unsigned int	riddatalen,
 	ctlx_cmdcb_t cmdcb,
 	ctlx_usercb_t usercb,
 	void	*usercb_data);
@@ -310,9 +310,9 @@ static int
 hfa384x_dowrid(
 	hfa384x_t *hw,
 	CMD_MODE mode,
-	UINT16	rid,
+	u16	rid,
 	void	*riddata,
-	UINT	riddatalen,
+	unsigned int	riddatalen,
 	ctlx_cmdcb_t cmdcb,
 	ctlx_usercb_t usercb,
 	void	*usercb_data);
@@ -321,10 +321,10 @@ static int
 hfa384x_dormem(
 	hfa384x_t *hw,
 	CMD_MODE mode,
-	UINT16	page,
-	UINT16	offset,
+	u16	page,
+	u16	offset,
 	void	*data,
-	UINT	len,
+	unsigned int	len,
 	ctlx_cmdcb_t cmdcb,
 	ctlx_usercb_t usercb,
 	void	*usercb_data);
@@ -333,16 +333,16 @@ static int
 hfa384x_dowmem(
 	hfa384x_t *hw,
 	CMD_MODE mode,
-	UINT16	page,
-	UINT16	offset,
+	u16	page,
+	u16	offset,
 	void	*data,
-	UINT	len,
+	unsigned int	len,
 	ctlx_cmdcb_t cmdcb,
 	ctlx_usercb_t usercb,
 	void	*usercb_data);
 
 static int
-hfa384x_isgood_pdrcode(UINT16 pdrcode);
+hfa384x_isgood_pdrcode(u16 pdrcode);
 
 /*================================================================*/
 /* Function Definitions */
@@ -376,17 +376,17 @@ dbprint_urb(struct urb* urb)
 	WLAN_LOG_DEBUG(3,"urb->pipe=0x%08x\n", urb->pipe);
 	WLAN_LOG_DEBUG(3,"urb->status=0x%08x\n", urb->status);
 	WLAN_LOG_DEBUG(3,"urb->transfer_flags=0x%08x\n", urb->transfer_flags);
-	WLAN_LOG_DEBUG(3,"urb->transfer_buffer=0x%08x\n", (UINT)urb->transfer_buffer);
+	WLAN_LOG_DEBUG(3,"urb->transfer_buffer=0x%08x\n", (unsigned int)urb->transfer_buffer);
 	WLAN_LOG_DEBUG(3,"urb->transfer_buffer_length=0x%08x\n", urb->transfer_buffer_length);
 	WLAN_LOG_DEBUG(3,"urb->actual_length=0x%08x\n", urb->actual_length);
 	WLAN_LOG_DEBUG(3,"urb->bandwidth=0x%08x\n", urb->bandwidth);
-	WLAN_LOG_DEBUG(3,"urb->setup_packet(ctl)=0x%08x\n", (UINT)urb->setup_packet);
+	WLAN_LOG_DEBUG(3,"urb->setup_packet(ctl)=0x%08x\n", (unsigned int)urb->setup_packet);
 	WLAN_LOG_DEBUG(3,"urb->start_frame(iso/irq)=0x%08x\n", urb->start_frame);
 	WLAN_LOG_DEBUG(3,"urb->interval(irq)=0x%08x\n", urb->interval);
 	WLAN_LOG_DEBUG(3,"urb->error_count(iso)=0x%08x\n", urb->error_count);
 	WLAN_LOG_DEBUG(3,"urb->timeout=0x%08x\n", urb->timeout);
-	WLAN_LOG_DEBUG(3,"urb->context=0x%08x\n", (UINT)urb->context);
-	WLAN_LOG_DEBUG(3,"urb->complete=0x%08x\n", (UINT)urb->complete);
+	WLAN_LOG_DEBUG(3,"urb->context=0x%08x\n", (unsigned int)urb->context);
+	WLAN_LOG_DEBUG(3,"urb->complete=0x%08x\n", (unsigned int)urb->complete);
 }
 #endif
 
@@ -829,7 +829,7 @@ struct usbctlx_rrid_completor
 
 	const hfa384x_usb_rridresp_t	*rridresp;
 	void			*riddata;
-	UINT			riddatalen;
+	unsigned int			riddatalen;
 };
 typedef struct usbctlx_rrid_completor usbctlx_rrid_completor_t;
 
@@ -860,7 +860,7 @@ static inline usbctlx_completor_t*
 init_rrid_completor(usbctlx_rrid_completor_t *completor,
                     const hfa384x_usb_rridresp_t *rridresp,
                     void *riddata,
-                    UINT riddatalen)
+                    unsigned int riddatalen)
 {
 	completor->head.complete = usbctlx_rrid_completor_fn;
 	completor->rridresp = rridresp;
@@ -893,7 +893,7 @@ struct usbctlx_rmem_completor
 
         const hfa384x_usb_rmemresp_t  *rmemresp;
         void                          *data;
-        UINT                          len;
+        unsigned int                          len;
 };
 typedef struct usbctlx_rmem_completor usbctlx_rmem_completor_t;
 
@@ -910,7 +910,7 @@ static inline usbctlx_completor_t*
 init_rmem_completor(usbctlx_rmem_completor_t *completor,
                     hfa384x_usb_rmemresp_t *rmemresp,
                     void *data,
-                    UINT len)
+                    unsigned int len)
 {
 	completor->head.complete = usbctlx_rmem_completor_fn;
 	completor->rmemresp = rmemresp;
@@ -1021,7 +1021,7 @@ hfa384x_docmd_async(hfa384x_t *hw,
 }
 
 static inline int
-hfa384x_dorrid_wait(hfa384x_t *hw, UINT16 rid, void *riddata, UINT riddatalen)
+hfa384x_dorrid_wait(hfa384x_t *hw, u16 rid, void *riddata, unsigned int riddatalen)
 {
 	return hfa384x_dorrid(hw, DOWAIT,
 	                      rid, riddata, riddatalen,
@@ -1030,7 +1030,7 @@ hfa384x_dorrid_wait(hfa384x_t *hw, UINT16 rid, void *riddata, UINT riddatalen)
 
 static inline int
 hfa384x_dorrid_async(hfa384x_t *hw,
-                     UINT16 rid, void *riddata, UINT riddatalen,
+                     u16 rid, void *riddata, unsigned int riddatalen,
                      ctlx_cmdcb_t cmdcb,
                      ctlx_usercb_t usercb,
                      void *usercb_data)
@@ -1041,7 +1041,7 @@ hfa384x_dorrid_async(hfa384x_t *hw,
 }
 
 static inline int
-hfa384x_dowrid_wait(hfa384x_t *hw, UINT16 rid, void *riddata, UINT riddatalen)
+hfa384x_dowrid_wait(hfa384x_t *hw, u16 rid, void *riddata, unsigned int riddatalen)
 {
 	return hfa384x_dowrid(hw, DOWAIT,
 	                      rid, riddata, riddatalen,
@@ -1050,7 +1050,7 @@ hfa384x_dowrid_wait(hfa384x_t *hw, UINT16 rid, void *riddata, UINT riddatalen)
 
 static inline int
 hfa384x_dowrid_async(hfa384x_t *hw,
-                     UINT16 rid, void *riddata, UINT riddatalen,
+                     u16 rid, void *riddata, unsigned int riddatalen,
                      ctlx_cmdcb_t cmdcb,
                      ctlx_usercb_t usercb,
                      void *usercb_data)
@@ -1062,7 +1062,7 @@ hfa384x_dowrid_async(hfa384x_t *hw,
 
 static inline int
 hfa384x_dormem_wait(hfa384x_t *hw,
-                    UINT16 page, UINT16 offset, void *data, UINT len)
+                    u16 page, u16 offset, void *data, unsigned int len)
 {
 	return hfa384x_dormem(hw, DOWAIT,
 	                      page, offset, data, len,
@@ -1071,7 +1071,7 @@ hfa384x_dormem_wait(hfa384x_t *hw,
 
 static inline int
 hfa384x_dormem_async(hfa384x_t *hw,
-                     UINT16 page, UINT16 offset, void *data, UINT len,
+                     u16 page, u16 offset, void *data, unsigned int len,
                      ctlx_cmdcb_t cmdcb,
                      ctlx_usercb_t usercb,
                      void *usercb_data)
@@ -1084,10 +1084,10 @@ hfa384x_dormem_async(hfa384x_t *hw,
 static inline int
 hfa384x_dowmem_wait(
         hfa384x_t *hw,
-        UINT16  page,
-        UINT16  offset,
+        u16  page,
+        u16  offset,
         void    *data,
-        UINT    len)
+        unsigned int    len)
 {
 	return hfa384x_dowmem(hw, DOWAIT,
                                   page, offset, data, len,
@@ -1097,10 +1097,10 @@ hfa384x_dowmem_wait(
 static inline int
 hfa384x_dowmem_async(
         hfa384x_t *hw,
-        UINT16  page,
-        UINT16  offset,
+        u16  page,
+        u16  offset,
         void    *data,
-        UINT    len,
+        unsigned int    len,
         ctlx_cmdcb_t cmdcb,
         ctlx_usercb_t usercb,
         void    *usercb_data)
@@ -1187,7 +1187,7 @@ hfa384x_cmd_initialize(hfa384x_t *hw)
 * Call context:
 *	process
 ----------------------------------------------------------------*/
-int hfa384x_cmd_disable(hfa384x_t *hw, UINT16 macport)
+int hfa384x_cmd_disable(hfa384x_t *hw, u16 macport)
 {
 	int	result = 0;
 	hfa384x_metacmd_t cmd;
@@ -1227,7 +1227,7 @@ int hfa384x_cmd_disable(hfa384x_t *hw, UINT16 macport)
 * Call context:
 *	process
 ----------------------------------------------------------------*/
-int hfa384x_cmd_enable(hfa384x_t *hw, UINT16 macport)
+int hfa384x_cmd_enable(hfa384x_t *hw, u16 macport)
 {
 	int	result = 0;
 	hfa384x_metacmd_t cmd;
@@ -1276,12 +1276,12 @@ int hfa384x_cmd_enable(hfa384x_t *hw, UINT16 macport)
 * Call context:
 *	process
 ----------------------------------------------------------------*/
-int hfa384x_cmd_notify(hfa384x_t *hw, UINT16 reclaim, UINT16 fid,
-		       void *buf, UINT16 len)
+int hfa384x_cmd_notify(hfa384x_t *hw, u16 reclaim, u16 fid,
+		       void *buf, u16 len)
 {
 #if 0
 	int	result = 0;
-	UINT16	cmd;
+	u16	cmd;
 	DBFENTER;
 	cmd =	HFA384x_CMD_CMDCODE_SET(HFA384x_CMDCODE_NOTIFY) |
 		HFA384x_CMD_RECL_SET(reclaim);
@@ -1315,7 +1315,7 @@ return 0;
 * Call context:
 *	process
 ----------------------------------------------------------------*/
-int hfa384x_cmd_inquiry(hfa384x_t *hw, UINT16 fid)
+int hfa384x_cmd_inquiry(hfa384x_t *hw, u16 fid)
 {
 	int	result = 0;
 	hfa384x_metacmd_t cmd;
@@ -1364,7 +1364,7 @@ int hfa384x_cmd_inquiry(hfa384x_t *hw, UINT16 fid)
 * Call context:
 *	process
 ----------------------------------------------------------------*/
-int hfa384x_cmd_monitor(hfa384x_t *hw, UINT16 enable)
+int hfa384x_cmd_monitor(hfa384x_t *hw, u16 enable)
 {
 	int	result = 0;
 	hfa384x_metacmd_t cmd;
@@ -1422,8 +1422,8 @@ int hfa384x_cmd_monitor(hfa384x_t *hw, UINT16 enable)
 * Call context:
 *	process
 ----------------------------------------------------------------*/
-int hfa384x_cmd_download(hfa384x_t *hw, UINT16 mode, UINT16 lowaddr,
-				UINT16 highaddr, UINT16 codelen)
+int hfa384x_cmd_download(hfa384x_t *hw, u16 mode, u16 lowaddr,
+				u16 highaddr, u16 codelen)
 {
 	int	result = 0;
 	hfa384x_metacmd_t cmd;
@@ -1473,7 +1473,7 @@ int hfa384x_cmd_download(hfa384x_t *hw, UINT16 mode, UINT16 lowaddr,
 ----------------------------------------------------------------*/
 void
 hfa384x_copy_from_aux(
-	hfa384x_t *hw, UINT32 cardaddr, UINT32 auxctl, void *buf, UINT len)
+	hfa384x_t *hw, u32 cardaddr, u32 auxctl, void *buf, unsigned int len)
 {
 	DBFENTER;
 	WLAN_LOG_ERROR("not used in USB.\n");
@@ -1507,7 +1507,7 @@ hfa384x_copy_from_aux(
 ----------------------------------------------------------------*/
 void
 hfa384x_copy_to_aux(
-	hfa384x_t *hw, UINT32 cardaddr, UINT32 auxctl, void *buf, UINT len)
+	hfa384x_t *hw, u32 cardaddr, u32 auxctl, void *buf, unsigned int len)
 {
 	DBFENTER;
 	WLAN_LOG_ERROR("not used in USB.\n");
@@ -1798,9 +1798,9 @@ static int
 hfa384x_dorrid(
 	hfa384x_t *hw,
 	CMD_MODE mode,
-	UINT16	rid,
+	u16	rid,
 	void	*riddata,
-	UINT	riddatalen,
+	unsigned int	riddatalen,
         ctlx_cmdcb_t cmdcb,
 	ctlx_usercb_t usercb,
 	void	*usercb_data)
@@ -1884,9 +1884,9 @@ static int
 hfa384x_dowrid(
 	hfa384x_t *hw,
 	CMD_MODE mode,
-	UINT16	rid,
+	u16	rid,
 	void	*riddata,
-	UINT	riddatalen,
+	unsigned int	riddatalen,
 	ctlx_cmdcb_t cmdcb,
 	ctlx_usercb_t usercb,
 	void	*usercb_data)
@@ -1977,10 +1977,10 @@ static int
 hfa384x_dormem(
 	hfa384x_t *hw,
 	CMD_MODE mode,
-	UINT16	page,
-	UINT16	offset,
+	u16	page,
+	u16	offset,
 	void	*data,
-	UINT	len,
+	unsigned int	len,
 	ctlx_cmdcb_t cmdcb,
 	ctlx_usercb_t usercb,
 	void	*usercb_data)
@@ -2078,10 +2078,10 @@ static int
 hfa384x_dowmem(
 	hfa384x_t *hw,
 	CMD_MODE mode,
-	UINT16	page,
-	UINT16	offset,
+	u16	page,
+	u16	offset,
 	void	*data,
-	UINT	len,
+	unsigned int	len,
 	ctlx_cmdcb_t cmdcb,
 	ctlx_usercb_t usercb,
 	void	*usercb_data)
@@ -2198,7 +2198,7 @@ int hfa384x_drvr_commtallies( hfa384x_t *hw )
 * Call context:
 *	process
 ----------------------------------------------------------------*/
-int hfa384x_drvr_disable(hfa384x_t *hw, UINT16 macport)
+int hfa384x_drvr_disable(hfa384x_t *hw, u16 macport)
 {
 	int	result = 0;
 
@@ -2240,7 +2240,7 @@ int hfa384x_drvr_disable(hfa384x_t *hw, UINT16 macport)
 * Call context:
 *	process
 ----------------------------------------------------------------*/
-int hfa384x_drvr_enable(hfa384x_t *hw, UINT16 macport)
+int hfa384x_drvr_enable(hfa384x_t *hw, u16 macport)
 {
 	int	result = 0;
 
@@ -2393,22 +2393,22 @@ int hfa384x_drvr_flashdl_disable(hfa384x_t *hw)
 int
 hfa384x_drvr_flashdl_write(
 	hfa384x_t	*hw,
-	UINT32		daddr,
+	u32		daddr,
 	void		*buf,
-	UINT32		len)
+	u32		len)
 {
 	int		result = 0;
-	UINT32		dlbufaddr;
+	u32		dlbufaddr;
 	int		nburns;
-	UINT32		burnlen;
-	UINT32		burndaddr;
-	UINT16		burnlo;
-	UINT16		burnhi;
+	u32		burnlen;
+	u32		burndaddr;
+	u16		burnlo;
+	u16		burnhi;
 	int		nwrites;
-	UINT8		*writebuf;
-	UINT16		writepage;
-	UINT16		writeoffset;
-	UINT32		writelen;
+	u8		*writebuf;
+	u16		writepage;
+	u16		writeoffset;
+	u32		writelen;
 	int		i;
 	int		j;
 
@@ -2559,7 +2559,7 @@ Comment out for debugging, assume the write was successful.
 * Call context:
 *	process
 ----------------------------------------------------------------*/
-int hfa384x_drvr_getconfig(hfa384x_t *hw, UINT16 rid, void *buf, UINT16 len)
+int hfa384x_drvr_getconfig(hfa384x_t *hw, u16 rid, void *buf, u16 len)
 {
 	int 			result;
 	DBFENTER;
@@ -2600,7 +2600,7 @@ int hfa384x_drvr_getconfig(hfa384x_t *hw, UINT16 rid, void *buf, UINT16 len)
 int
 hfa384x_drvr_getconfig_async(
          hfa384x_t               *hw,
-         UINT16                  rid,
+         u16                  rid,
          ctlx_usercb_t           usercb,
          void                    *usercb_data)
 {
@@ -2634,9 +2634,9 @@ hfa384x_drvr_getconfig_async(
 int
 hfa384x_drvr_setconfig_async(
          hfa384x_t       *hw,
-         UINT16          rid,
+         u16          rid,
          void            *buf,
-         UINT16          len,
+         u16          len,
          ctlx_usercb_t   usercb,
          void            *usercb_data)
 {
@@ -2663,7 +2663,7 @@ hfa384x_drvr_setconfig_async(
 * Call context:
 *	process
 ----------------------------------------------------------------*/
-int hfa384x_drvr_handover( hfa384x_t *hw, UINT8 *addr)
+int hfa384x_drvr_handover( hfa384x_t *hw, u8 *addr)
 {
         DBFENTER;
 	WLAN_LOG_ERROR("Not currently supported in USB!\n");
@@ -2716,12 +2716,12 @@ int hfa384x_drvr_low_level(hfa384x_t *hw, hfa384x_metacmd_t *cmd)
 * Call context:
 *       process
 ----------------------------------------------------------------*/
-int hfa384x_drvr_mmi_read(hfa384x_t *hw, UINT32 addr, UINT32 *resp)
+int hfa384x_drvr_mmi_read(hfa384x_t *hw, u32 addr, u32 *resp)
 {
 #if 0
         int             result = 0;
-        UINT16  cmd_code = (UINT16) 0x30;
-        UINT16 param = (UINT16) addr;
+        u16  cmd_code = (u16) 0x30;
+        u16 param = (u16) addr;
         DBFENTER;
 
         /* Do i need a host2hfa... conversion ? */
@@ -2756,13 +2756,13 @@ return 0;
 ----------------------------------------------------------------*/
 
 int
-hfa384x_drvr_mmi_write(hfa384x_t *hw, UINT32 addr, UINT32 data)
+hfa384x_drvr_mmi_write(hfa384x_t *hw, u32 addr, u32 data)
 {
 #if 0
         int             result = 0;
-        UINT16  cmd_code = (UINT16) 0x31;
-        UINT16 param0 = (UINT16) addr;
-        UINT16 param1 = (UINT16) data;
+        u16  cmd_code = (u16) 0x31;
+        u16 param0 = (u16) addr;
+        u16 param1 = (u16) data;
         DBFENTER;
 
         WLAN_LOG_DEBUG(1,"mmi write : addr = 0x%08lx\n", addr);
@@ -2842,11 +2842,11 @@ hfa384x_drvr_ramdl_disable(hfa384x_t *hw)
 *	process
 ----------------------------------------------------------------*/
 int
-hfa384x_drvr_ramdl_enable(hfa384x_t *hw, UINT32 exeaddr)
+hfa384x_drvr_ramdl_enable(hfa384x_t *hw, u32 exeaddr)
 {
 	int		result = 0;
-	UINT16		lowaddr;
-	UINT16		hiaddr;
+	u16		lowaddr;
+	u16		hiaddr;
 	int		i;
 	DBFENTER;
 	/* Check that a port isn't active */
@@ -2917,16 +2917,16 @@ hfa384x_drvr_ramdl_enable(hfa384x_t *hw, UINT32 exeaddr)
 *	process
 ----------------------------------------------------------------*/
 int
-hfa384x_drvr_ramdl_write(hfa384x_t *hw, UINT32 daddr, void* buf, UINT32 len)
+hfa384x_drvr_ramdl_write(hfa384x_t *hw, u32 daddr, void* buf, u32 len)
 {
 	int		result = 0;
 	int		nwrites;
-	UINT8		*data = buf;
+	u8		*data = buf;
 	int		i;
-	UINT32		curraddr;
-	UINT16		currpage;
-	UINT16		curroffset;
-	UINT16		currlen;
+	u32		curraddr;
+	u16		currpage;
+	u16		curroffset;
+	u16		currlen;
 	DBFENTER;
 	/* Check that we're in the ram download state */
 	if ( hw->dlstate != HFA384x_DLSTATE_RAMENABLED ) {
@@ -2998,21 +2998,21 @@ hfa384x_drvr_ramdl_write(hfa384x_t *hw, UINT32 daddr, void* buf, UINT32 len)
 * Call context:
 *	process or non-card interrupt.
 ----------------------------------------------------------------*/
-int hfa384x_drvr_readpda(hfa384x_t *hw, void *buf, UINT len)
+int hfa384x_drvr_readpda(hfa384x_t *hw, void *buf, unsigned int len)
 {
 	int		result = 0;
-	UINT16		*pda = buf;
+	u16		*pda = buf;
 	int		pdaok = 0;
 	int		morepdrs = 1;
 	int		currpdr = 0;	/* word offset of the current pdr */
 	size_t		i;
-	UINT16		pdrlen;		/* pdr length in bytes, host order */
-	UINT16		pdrcode;	/* pdr code, host order */
-	UINT16		currpage;
-	UINT16		curroffset;
+	u16		pdrlen;		/* pdr length in bytes, host order */
+	u16		pdrcode;	/* pdr code, host order */
+	u16		currpage;
+	u16		curroffset;
 	struct pdaloc {
-		UINT32	cardaddr;
-		UINT16	auxctl;
+		u32	cardaddr;
+		u16	auxctl;
 	} pdaloc[] =
 	{
 		{ HFA3842_PDA_BASE,		0},
@@ -3116,7 +3116,7 @@ int hfa384x_drvr_readpda(hfa384x_t *hw, void *buf, UINT len)
 * Call context:
 *	process
 ----------------------------------------------------------------*/
-int hfa384x_drvr_setconfig(hfa384x_t *hw, UINT16 rid, void *buf, UINT16 len)
+int hfa384x_drvr_setconfig(hfa384x_t *hw, u16 rid, void *buf, u16 len)
 {
 	return hfa384x_dowrid_wait(hw, rid, buf, len);
 }
@@ -3734,7 +3734,7 @@ static void hfa384x_usbin_callback(struct urb *urb, struct pt_regs *regs)
 	struct sk_buff          *skb = NULL;
 	int			result;
 	int                     urb_status;
-	UINT16			type;
+	u16			type;
 
 	enum USBIN_ACTION {
 		HANDLE,
@@ -3961,7 +3961,7 @@ static void hfa384x_usbin_ctlx(hfa384x_t *hw, hfa384x_usbin_t *usbin,
 		if (unlocked_usbctlx_cancel_async(hw, ctlx) == 0)
 			run_queue = 1;
 	} else {
-		const UINT16 intype = (usbin->type&~host2hfa384x_16(0x8000));
+		const u16 intype = (usbin->type&~host2hfa384x_16(0x8000));
 
 		/*
 		 * Check that our message is what we're expecting ...
@@ -4041,7 +4041,7 @@ static void hfa384x_usbin_ctlx(hfa384x_t *hw, hfa384x_usbin_t *usbin,
 ----------------------------------------------------------------*/
 static void hfa384x_usbin_txcompl(wlandevice_t *wlandev, hfa384x_usbin_t *usbin)
 {
-	UINT16			status;
+	u16			status;
 	DBFENTER;
 
 	status = hfa384x2host_16(usbin->type); /* yeah I know it says type...*/
@@ -4081,8 +4081,8 @@ static void hfa384x_usbin_rx(wlandevice_t *wlandev, struct sk_buff *skb)
 	hfa384x_t               *hw = wlandev->priv;
 	int                     hdrlen;
 	p80211_rxmeta_t         *rxmeta;
-	UINT16                  data_len;
-	UINT16                  fc;
+	u16                  data_len;
+	u16                  fc;
 
 	DBFENTER;
 
@@ -4188,12 +4188,12 @@ static void hfa384x_usbin_rx(wlandevice_t *wlandev, struct sk_buff *skb)
 static void hfa384x_int_rxmonitor( wlandevice_t *wlandev, hfa384x_usb_rxfrm_t *rxfrm)
 {
 	hfa384x_rx_frame_t              *rxdesc = &(rxfrm->desc);
-	UINT				hdrlen = 0;
-	UINT				datalen = 0;
-	UINT				skblen = 0;
+	unsigned int				hdrlen = 0;
+	unsigned int				datalen = 0;
+	unsigned int				skblen = 0;
 	p80211msg_lnxind_wlansniffrm_t	*msg;
-	UINT8				*datap;
-	UINT16				fc;
+	u8				*datap;
+	u16				fc;
 	struct sk_buff			*skb;
 	hfa384x_t		        *hw = wlandev->priv;
 
@@ -4842,7 +4842,7 @@ static void hfa384x_usbout_tx(wlandevice_t *wlandev, hfa384x_usbout_t *usbout)
 * Call context:
 ----------------------------------------------------------------*/
 static int
-hfa384x_isgood_pdrcode(UINT16 pdrcode)
+hfa384x_isgood_pdrcode(u16 pdrcode)
 {
 	switch(pdrcode) {
 	case HFA384x_PDR_END_OF_PDA:

commit ff1ae8f3c1b972ff850400abdd5f7da36270f408
Author: Solomon Peachy <pizza@shaftnet.org>
Date:   Mon Oct 27 11:14:05 2008 -0400

    Staging: wlan-ng: Eliminate local 'version.h'
    
    The kernel provides us with the proper version of this file.
    
    Signed-off-by: Solomon Peachy <pizza@shaftnet.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/wlan-ng/hfa384x_usb.c b/drivers/staging/wlan-ng/hfa384x_usb.c
index 06700683f0a0..53c547d36ed9 100644
--- a/drivers/staging/wlan-ng/hfa384x_usb.c
+++ b/drivers/staging/wlan-ng/hfa384x_usb.c
@@ -114,9 +114,6 @@
 /* System Includes */
 #define WLAN_DBVAR	prism2_debug
 
-#include "version.h"
-
-
 #include <linux/version.h>
 
 #include <linux/module.h>

commit 8a1396ef7ee4045bcbf0f9b9d8763e1b383ec690
Author: Solomon Peachy <pizza@shaftnet.org>
Date:   Mon Oct 27 11:14:00 2008 -0400

    Staging: wlan-ng: Eliminate all backwards-compatibility for <2.6.13 kernels.
    
    Signed-off-by: Solomon Peachy <pizza@shaftnet.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/wlan-ng/hfa384x_usb.c b/drivers/staging/wlan-ng/hfa384x_usb.c
index 2cd376ea431e..06700683f0a0 100644
--- a/drivers/staging/wlan-ng/hfa384x_usb.c
+++ b/drivers/staging/wlan-ng/hfa384x_usb.c
@@ -136,41 +136,6 @@
 
 #include "wlan_compat.h"
 
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,10)
-static int
-wait_for_completion_interruptible(struct completion *x)
-{
-  int ret = 0;
-
-  might_sleep();
-
-  spin_lock_irq(&x->wait.lock);
-  if (!x->done) {
-    DECLARE_WAITQUEUE(wait, current);
-
-    wait.flags |= WQ_FLAG_EXCLUSIVE;
-    __add_wait_queue_tail(&x->wait, &wait);
-    do {
-      if (signal_pending(current)) {
-        ret = -ERESTARTSYS;
-        __remove_wait_queue(&x->wait, &wait);
-        goto out;
-      }
-      __set_current_state(TASK_INTERRUPTIBLE);
-      spin_unlock_irq(&x->wait.lock);
-      schedule();
-      spin_lock_irq(&x->wait.lock);
-    } while (!x->done);
-    __remove_wait_queue(&x->wait, &wait);
-  }
-  x->done--;
-out:
-  spin_unlock_irq(&x->wait.lock);
-
-  return ret;
-}
-#endif
-
 #define SUBMIT_URB(u,f)  usb_submit_urb(u,f)
 
 /*================================================================*/

commit 68a193e4bb4e96fa58d11566b75bb9bcc34ea50b
Author: Solomon Peachy <pizza@shaftnet.org>
Date:   Mon Oct 27 11:13:59 2008 -0400

    Staging: wlan-ng: Eliminate more <2.6 kernel support.
    
    Signed-off-by: Solomon Peachy <pizza@shaftnet.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/wlan-ng/hfa384x_usb.c b/drivers/staging/wlan-ng/hfa384x_usb.c
index 376ba58fcb99..2cd376ea431e 100644
--- a/drivers/staging/wlan-ng/hfa384x_usb.c
+++ b/drivers/staging/wlan-ng/hfa384x_usb.c
@@ -171,23 +171,7 @@ wait_for_completion_interruptible(struct completion *x)
 }
 #endif
 
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,69)
-static void
-usb_init_urb(struct urb *urb)
-{
-	memset(urb, 0, sizeof(*urb));
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0) /* tune me! */
-	urb->count = (atomic_t)ATOMIC_INIT(1);
-#endif
-	spin_lock_init(&urb->lock);
-}
-#endif
-
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0) /* tune me! */
-#  define SUBMIT_URB(u,f)  usb_submit_urb(u,f)
-#else
-#  define SUBMIT_URB(u,f)  usb_submit_urb(u)
-#endif
+#define SUBMIT_URB(u,f)  usb_submit_urb(u,f)
 
 /*================================================================*/
 /* Project Includes */
@@ -1594,78 +1578,10 @@ hfa384x_copy_to_aux(
 ----------------------------------------------------------------*/
 int hfa384x_corereset(hfa384x_t *hw, int holdtime, int settletime, int genesis)
 {
-#if 0
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0))
-	struct usb_device	*parent = hw->usb->parent;
-	int			i;
-	int			port = -1;
-#endif
-#endif
 	int 			result = 0;
 
-
-#define P2_USB_RT_PORT		(USB_TYPE_CLASS | USB_RECIP_OTHER)
-#define P2_USB_FEAT_RESET	4
-#define P2_USB_FEAT_C_RESET	20
-
 	DBFENTER;
 
-#if 0
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0))
-	/* Find the hub port */
-	for ( i = 0; i < parent->maxchild; i++) {
-		if (parent->children[i] == hw->usb) {
-			port = i;
-			break;
-		}
-	}
-	if (port < 0) return -ENOENT;
-
-	/* Set and clear the reset */
-	usb_control_msg(parent, usb_sndctrlpipe(parent, 0),
-		USB_REQ_SET_FEATURE, P2_USB_RT_PORT, P2_USB_FEAT_RESET,
-		port+1, NULL, 0, 1*HZ);
-	wait_ms(holdtime);
-	usb_control_msg(parent, usb_sndctrlpipe(parent, 0),
-		USB_REQ_CLEAR_FEATURE, P2_USB_RT_PORT, P2_USB_FEAT_C_RESET,
-		port+1, NULL, 0, 1*HZ);
-	wait_ms(settletime);
-
-	/* Set the device address */
-	result=usb_set_address(hw->usb);
-	if (result < 0) {
-		WLAN_LOG_ERROR("reset_usbdev: Dev not accepting address, "
-			"result=%d\n", result);
-		clear_bit(hw->usb->devnum, &hw->usb->bus->devmap.devicemap);
-		hw->usb->devnum = -1;
-		goto done;
-	}
-	/* Let the address settle */
-	wait_ms(20);
-
-	/* Assume we're reusing the original descriptor data */
-
-	/* Set the configuration. */
-	WLAN_LOG_DEBUG(3, "Setting Configuration %d\n",
-		hw->usb->config[0].bConfigurationValue);
-	result=usb_set_configuration(hw->usb, hw->usb->config[0].bConfigurationValue);
-	if ( result ) {
-		WLAN_LOG_ERROR("usb_set_configuration() failed, result=%d.\n",
-				result);
-		goto done;
-	}
-	/* Let the configuration settle */
-	wait_ms(20);
-
- done:
-#else
-	result=usb_reset_device(hw->usb);
-	if(result<0) {
-		WLAN_LOG_ERROR("usb_reset_device() failed, result=%d.\n",result);
-	}
-#endif
-#endif
-
 	result=usb_reset_device(hw->usb);
 	if(result<0) {
 		WLAN_LOG_ERROR("usb_reset_device() failed, result=%d.\n",result);

commit dff1dc8caaa42774ea82201cb3698b70f1f173c9
Author: Solomon Peachy <pizza@shaftnet.org>
Date:   Mon Oct 27 11:13:57 2008 -0400

    Staging: wlan-ng: Delete PCI/PLX/PCMCIA-specific code.
    
    Also delete a large pile of code that existed to support <2.6 kernels.
    
    Signed-off-by: Solomon Peachy <pizza@shaftnet.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/wlan-ng/hfa384x_usb.c b/drivers/staging/wlan-ng/hfa384x_usb.c
index db0c502f5d90..376ba58fcb99 100644
--- a/drivers/staging/wlan-ng/hfa384x_usb.c
+++ b/drivers/staging/wlan-ng/hfa384x_usb.c
@@ -136,11 +136,6 @@
 
 #include "wlan_compat.h"
 
-#if (WLAN_HOSTIF != WLAN_USB)
-#error "This file is specific to USB"
-#endif
-
-
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,10)
 static int
 wait_for_completion_interruptible(struct completion *x)

commit 00b3ed1685089ff52169a715de11106ed37df087
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Thu Oct 2 11:29:28 2008 -0700

    Staging: add wlan-ng prism2 usb driver
    
    This adds the wlan-ng prism2 USB driver to the drivers/staging tree.
    
    The code was originally written by the linux-wlan-ng team, patched by
    some Novell engineers to properly work on newer kernels, and then hacked
    into place in order to get it to build properly in a single subdirectory
    within the kernel tree by me.
    
    It supports a wide range of older USB prism2 devices, and contains a
    80211 stack to support this single driver.
    
    Cc: Christian Zoz <zoz@suse.de>
    Cc: Andreas Gruenbacher <agruen@suse.de>
    Cc: linux-wireless <linux-wireless@vger.kernel.org>
    Cc: John Linville <linville@tuxdriver.com>
    Cc: Helmut Schaa <helmut.schaa@googlemail.com>
    Cc: linux-wlan-ng <solomon@linux-wlan.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/wlan-ng/hfa384x_usb.c b/drivers/staging/wlan-ng/hfa384x_usb.c
new file mode 100644
index 000000000000..db0c502f5d90
--- /dev/null
+++ b/drivers/staging/wlan-ng/hfa384x_usb.c
@@ -0,0 +1,5027 @@
+/* src/prism2/driver/hfa384x_usb.c
+*
+* Functions that talk to the USB variantof the Intersil hfa384x MAC
+*
+* Copyright (C) 1999 AbsoluteValue Systems, Inc.  All Rights Reserved.
+* --------------------------------------------------------------------
+*
+* linux-wlan
+*
+*   The contents of this file are subject to the Mozilla Public
+*   License Version 1.1 (the "License"); you may not use this file
+*   except in compliance with the License. You may obtain a copy of
+*   the License at http://www.mozilla.org/MPL/
+*
+*   Software distributed under the License is distributed on an "AS
+*   IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+*   implied. See the License for the specific language governing
+*   rights and limitations under the License.
+*
+*   Alternatively, the contents of this file may be used under the
+*   terms of the GNU Public License version 2 (the "GPL"), in which
+*   case the provisions of the GPL are applicable instead of the
+*   above.  If you wish to allow the use of your version of this file
+*   only under the terms of the GPL and not to allow others to use
+*   your version of this file under the MPL, indicate your decision
+*   by deleting the provisions above and replace them with the notice
+*   and other provisions required by the GPL.  If you do not delete
+*   the provisions above, a recipient may use your version of this
+*   file under either the MPL or the GPL.
+*
+* --------------------------------------------------------------------
+*
+* Inquiries regarding the linux-wlan Open Source project can be
+* made directly to:
+*
+* AbsoluteValue Systems Inc.
+* info@linux-wlan.com
+* http://www.linux-wlan.com
+*
+* --------------------------------------------------------------------
+*
+* Portions of the development of this software were funded by
+* Intersil Corporation as part of PRISM(R) chipset product development.
+*
+* --------------------------------------------------------------------
+*
+* This file implements functions that correspond to the prism2/hfa384x
+* 802.11 MAC hardware and firmware host interface.
+*
+* The functions can be considered to represent several levels of
+* abstraction.  The lowest level functions are simply C-callable wrappers
+* around the register accesses.  The next higher level represents C-callable
+* prism2 API functions that match the Intersil documentation as closely
+* as is reasonable.  The next higher layer implements common sequences
+* of invokations of the API layer (e.g. write to bap, followed by cmd).
+*
+* Common sequences:
+* hfa384x_drvr_xxx	Highest level abstractions provided by the
+*			hfa384x code.  They are driver defined wrappers
+*			for common sequences.  These functions generally
+*			use the services of the lower levels.
+*
+* hfa384x_drvr_xxxconfig  An example of the drvr level abstraction. These
+*			functions are wrappers for the RID get/set
+*			sequence. They 	call copy_[to|from]_bap() and
+*			cmd_access().	These functions operate on the
+*			RIDs and buffers without validation.  The caller
+*			is responsible for that.
+*
+* API wrapper functions:
+* hfa384x_cmd_xxx	functions that provide access to the f/w commands.
+*			The function arguments correspond to each command
+*			argument, even command arguments that get packed
+*			into single registers.  These functions _just_
+*			issue the command by setting the cmd/parm regs
+*			& reading the status/resp regs.  Additional
+*			activities required to fully use a command
+*			(read/write from/to bap, get/set int status etc.)
+*			are implemented separately.  Think of these as
+*			C-callable prism2 commands.
+*
+* Lowest Layer Functions:
+* hfa384x_docmd_xxx	These functions implement the sequence required
+*			to issue any prism2 command.  Primarily used by the
+*			hfa384x_cmd_xxx functions.
+*
+* hfa384x_bap_xxx	BAP read/write access functions.
+*			Note: we usually use BAP0 for non-interrupt context
+*			 and BAP1 for interrupt context.
+*
+* hfa384x_dl_xxx	download related functions.
+*
+* Driver State Issues:
+* Note that there are two pairs of functions that manage the
+* 'initialized' and 'running' states of the hw/MAC combo.  The four
+* functions are create(), destroy(), start(), and stop().  create()
+* sets up the data structures required to support the hfa384x_*
+* functions and destroy() cleans them up.  The start() function gets
+* the actual hardware running and enables the interrupts.  The stop()
+* function shuts the hardware down.  The sequence should be:
+* create()
+* start()
+*  .
+*  .  Do interesting things w/ the hardware
+*  .
+* stop()
+* destroy()
+*
+* Note that destroy() can be called without calling stop() first.
+* --------------------------------------------------------------------
+*/
+
+/*================================================================*/
+/* System Includes */
+#define WLAN_DBVAR	prism2_debug
+
+#include "version.h"
+
+
+#include <linux/version.h>
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/types.h>
+#include <linux/slab.h>
+#include <linux/wireless.h>
+#include <linux/netdevice.h>
+#include <linux/timer.h>
+#include <asm/io.h>
+#include <linux/delay.h>
+#include <asm/byteorder.h>
+#include <asm/bitops.h>
+#include <linux/list.h>
+#include <linux/usb.h>
+
+#include "wlan_compat.h"
+
+#if (WLAN_HOSTIF != WLAN_USB)
+#error "This file is specific to USB"
+#endif
+
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,10)
+static int
+wait_for_completion_interruptible(struct completion *x)
+{
+  int ret = 0;
+
+  might_sleep();
+
+  spin_lock_irq(&x->wait.lock);
+  if (!x->done) {
+    DECLARE_WAITQUEUE(wait, current);
+
+    wait.flags |= WQ_FLAG_EXCLUSIVE;
+    __add_wait_queue_tail(&x->wait, &wait);
+    do {
+      if (signal_pending(current)) {
+        ret = -ERESTARTSYS;
+        __remove_wait_queue(&x->wait, &wait);
+        goto out;
+      }
+      __set_current_state(TASK_INTERRUPTIBLE);
+      spin_unlock_irq(&x->wait.lock);
+      schedule();
+      spin_lock_irq(&x->wait.lock);
+    } while (!x->done);
+    __remove_wait_queue(&x->wait, &wait);
+  }
+  x->done--;
+out:
+  spin_unlock_irq(&x->wait.lock);
+
+  return ret;
+}
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,69)
+static void
+usb_init_urb(struct urb *urb)
+{
+	memset(urb, 0, sizeof(*urb));
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0) /* tune me! */
+	urb->count = (atomic_t)ATOMIC_INIT(1);
+#endif
+	spin_lock_init(&urb->lock);
+}
+#endif
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0) /* tune me! */
+#  define SUBMIT_URB(u,f)  usb_submit_urb(u,f)
+#else
+#  define SUBMIT_URB(u,f)  usb_submit_urb(u)
+#endif
+
+/*================================================================*/
+/* Project Includes */
+
+#include "p80211types.h"
+#include "p80211hdr.h"
+#include "p80211mgmt.h"
+#include "p80211conv.h"
+#include "p80211msg.h"
+#include "p80211netdev.h"
+#include "p80211req.h"
+#include "p80211metadef.h"
+#include "p80211metastruct.h"
+#include "hfa384x.h"
+#include "prism2mgmt.h"
+
+/*================================================================*/
+/* Local Constants */
+
+enum cmd_mode
+{
+  DOWAIT = 0,
+  DOASYNC
+};
+typedef enum cmd_mode CMD_MODE;
+
+#define THROTTLE_JIFFIES	(HZ/8)
+
+/*================================================================*/
+/* Local Macros */
+
+#define ROUNDUP64(a) (((a)+63)&~63)
+
+/*================================================================*/
+/* Local Types */
+
+/*================================================================*/
+/* Local Static Definitions */
+extern int prism2_debug;
+
+/*================================================================*/
+/* Local Function Declarations */
+
+#ifdef DEBUG_USB
+static void
+dbprint_urb(struct urb* urb);
+#endif
+
+static void
+hfa384x_int_rxmonitor(
+	wlandevice_t *wlandev,
+	hfa384x_usb_rxfrm_t *rxfrm);
+
+static void
+hfa384x_usb_defer(struct work_struct *data);
+
+static int
+submit_rx_urb(hfa384x_t *hw, gfp_t flags);
+
+static int
+submit_tx_urb(hfa384x_t *hw, struct urb *tx_urb, gfp_t flags);
+
+/*---------------------------------------------------*/
+/* Callbacks */
+#ifdef URB_ONLY_CALLBACK
+static void
+hfa384x_usbout_callback(struct urb *urb);
+static void
+hfa384x_ctlxout_callback(struct urb *urb);
+static void
+hfa384x_usbin_callback(struct urb *urb);
+#else
+static void
+hfa384x_usbout_callback(struct urb *urb, struct pt_regs *regs);
+static void
+hfa384x_ctlxout_callback(struct urb *urb, struct pt_regs *regs);
+static void
+hfa384x_usbin_callback(struct urb *urb, struct pt_regs *regs);
+#endif
+
+static void
+hfa384x_usbin_txcompl(wlandevice_t *wlandev, hfa384x_usbin_t *usbin);
+
+static void
+hfa384x_usbin_rx(wlandevice_t *wlandev, struct sk_buff *skb);
+
+static void
+hfa384x_usbin_info(wlandevice_t *wlandev, hfa384x_usbin_t *usbin);
+
+static void
+hfa384x_usbout_tx(wlandevice_t *wlandev, hfa384x_usbout_t *usbout);
+
+static void hfa384x_usbin_ctlx(hfa384x_t *hw, hfa384x_usbin_t *usbin,
+			       int urb_status);
+
+/*---------------------------------------------------*/
+/* Functions to support the prism2 usb command queue */
+
+static void
+hfa384x_usbctlxq_run(hfa384x_t *hw);
+
+static void
+hfa384x_usbctlx_reqtimerfn(unsigned long data);
+
+static void
+hfa384x_usbctlx_resptimerfn(unsigned long data);
+
+static void
+hfa384x_usb_throttlefn(unsigned long data);
+
+static void
+hfa384x_usbctlx_completion_task(unsigned long data);
+
+static void
+hfa384x_usbctlx_reaper_task(unsigned long data);
+
+static int
+hfa384x_usbctlx_submit(hfa384x_t *hw, hfa384x_usbctlx_t *ctlx);
+
+static void
+unlocked_usbctlx_complete(hfa384x_t *hw, hfa384x_usbctlx_t *ctlx);
+
+struct usbctlx_completor
+{
+	int (*complete)(struct usbctlx_completor*);
+};
+typedef struct usbctlx_completor usbctlx_completor_t;
+
+static int
+hfa384x_usbctlx_complete_sync(hfa384x_t *hw,
+                              hfa384x_usbctlx_t *ctlx,
+                              usbctlx_completor_t *completor);
+
+static int
+unlocked_usbctlx_cancel_async(hfa384x_t *hw, hfa384x_usbctlx_t *ctlx);
+
+static void
+hfa384x_cb_status(hfa384x_t *hw, const hfa384x_usbctlx_t *ctlx);
+
+static void
+hfa384x_cb_rrid(hfa384x_t *hw, const hfa384x_usbctlx_t *ctlx);
+
+static int
+usbctlx_get_status(const hfa384x_usb_cmdresp_t *cmdresp,
+                   hfa384x_cmdresult_t *result);
+
+static void
+usbctlx_get_rridresult(const hfa384x_usb_rridresp_t *rridresp,
+                       hfa384x_rridresult_t *result);
+
+/*---------------------------------------------------*/
+/* Low level req/resp CTLX formatters and submitters */
+static int
+hfa384x_docmd(
+	hfa384x_t *hw,
+	CMD_MODE mode,
+	hfa384x_metacmd_t *cmd,
+	ctlx_cmdcb_t cmdcb,
+	ctlx_usercb_t usercb,
+	void	*usercb_data);
+
+static int
+hfa384x_dorrid(
+	hfa384x_t *hw,
+	CMD_MODE mode,
+	UINT16	rid,
+	void	*riddata,
+	UINT	riddatalen,
+	ctlx_cmdcb_t cmdcb,
+	ctlx_usercb_t usercb,
+	void	*usercb_data);
+
+static int
+hfa384x_dowrid(
+	hfa384x_t *hw,
+	CMD_MODE mode,
+	UINT16	rid,
+	void	*riddata,
+	UINT	riddatalen,
+	ctlx_cmdcb_t cmdcb,
+	ctlx_usercb_t usercb,
+	void	*usercb_data);
+
+static int
+hfa384x_dormem(
+	hfa384x_t *hw,
+	CMD_MODE mode,
+	UINT16	page,
+	UINT16	offset,
+	void	*data,
+	UINT	len,
+	ctlx_cmdcb_t cmdcb,
+	ctlx_usercb_t usercb,
+	void	*usercb_data);
+
+static int
+hfa384x_dowmem(
+	hfa384x_t *hw,
+	CMD_MODE mode,
+	UINT16	page,
+	UINT16	offset,
+	void	*data,
+	UINT	len,
+	ctlx_cmdcb_t cmdcb,
+	ctlx_usercb_t usercb,
+	void	*usercb_data);
+
+static int
+hfa384x_isgood_pdrcode(UINT16 pdrcode);
+
+/*================================================================*/
+/* Function Definitions */
+static inline const char* ctlxstr(CTLX_STATE s)
+{
+	static const char* ctlx_str[] = {
+		"Initial state",
+		"Complete",
+		"Request failed",
+		"Request pending",
+		"Request packet submitted",
+		"Request packet completed",
+		"Response packet completed"
+	};
+
+	return ctlx_str[s];
+};
+
+
+static inline hfa384x_usbctlx_t*
+get_active_ctlx(hfa384x_t *hw)
+{
+	return list_entry(hw->ctlxq.active.next, hfa384x_usbctlx_t, list);
+}
+
+
+#ifdef DEBUG_USB
+void
+dbprint_urb(struct urb* urb)
+{
+	WLAN_LOG_DEBUG(3,"urb->pipe=0x%08x\n", urb->pipe);
+	WLAN_LOG_DEBUG(3,"urb->status=0x%08x\n", urb->status);
+	WLAN_LOG_DEBUG(3,"urb->transfer_flags=0x%08x\n", urb->transfer_flags);
+	WLAN_LOG_DEBUG(3,"urb->transfer_buffer=0x%08x\n", (UINT)urb->transfer_buffer);
+	WLAN_LOG_DEBUG(3,"urb->transfer_buffer_length=0x%08x\n", urb->transfer_buffer_length);
+	WLAN_LOG_DEBUG(3,"urb->actual_length=0x%08x\n", urb->actual_length);
+	WLAN_LOG_DEBUG(3,"urb->bandwidth=0x%08x\n", urb->bandwidth);
+	WLAN_LOG_DEBUG(3,"urb->setup_packet(ctl)=0x%08x\n", (UINT)urb->setup_packet);
+	WLAN_LOG_DEBUG(3,"urb->start_frame(iso/irq)=0x%08x\n", urb->start_frame);
+	WLAN_LOG_DEBUG(3,"urb->interval(irq)=0x%08x\n", urb->interval);
+	WLAN_LOG_DEBUG(3,"urb->error_count(iso)=0x%08x\n", urb->error_count);
+	WLAN_LOG_DEBUG(3,"urb->timeout=0x%08x\n", urb->timeout);
+	WLAN_LOG_DEBUG(3,"urb->context=0x%08x\n", (UINT)urb->context);
+	WLAN_LOG_DEBUG(3,"urb->complete=0x%08x\n", (UINT)urb->complete);
+}
+#endif
+
+
+/*----------------------------------------------------------------
+* submit_rx_urb
+*
+* Listen for input data on the BULK-IN pipe. If the pipe has
+* stalled then schedule it to be reset.
+*
+* Arguments:
+*	hw		device struct
+*	memflags	memory allocation flags
+*
+* Returns:
+*	error code from submission
+*
+* Call context:
+*	Any
+----------------------------------------------------------------*/
+static int
+submit_rx_urb(hfa384x_t *hw, gfp_t memflags)
+{
+	struct sk_buff *skb;
+	int result;
+
+	DBFENTER;
+
+	skb = dev_alloc_skb(sizeof(hfa384x_usbin_t));
+	if (skb == NULL) {
+		result = -ENOMEM;
+		goto done;
+	}
+
+	/* Post the IN urb */
+	usb_fill_bulk_urb(&hw->rx_urb, hw->usb,
+	              hw->endp_in,
+	              skb->data, sizeof(hfa384x_usbin_t),
+	              hfa384x_usbin_callback, hw->wlandev);
+
+	hw->rx_urb_skb = skb;
+
+	result = -ENOLINK;
+	if ( !hw->wlandev->hwremoved && !test_bit(WORK_RX_HALT, &hw->usb_flags)) {
+		result = SUBMIT_URB(&hw->rx_urb, memflags);
+
+		/* Check whether we need to reset the RX pipe */
+		if (result == -EPIPE) {
+			WLAN_LOG_WARNING("%s rx pipe stalled: requesting reset\n",
+			                 hw->wlandev->netdev->name);
+			if ( !test_and_set_bit(WORK_RX_HALT, &hw->usb_flags) )
+				schedule_work(&hw->usb_work);
+		}
+	}
+
+	/* Don't leak memory if anything should go wrong */
+	if (result != 0) {
+		dev_kfree_skb(skb);
+		hw->rx_urb_skb = NULL;
+	}
+
+ done:
+
+	DBFEXIT;
+	return result;
+}
+
+/*----------------------------------------------------------------
+* submit_tx_urb
+*
+* Prepares and submits the URB of transmitted data. If the
+* submission fails then it will schedule the output pipe to
+* be reset.
+*
+* Arguments:
+*	hw		device struct
+*	tx_urb		URB of data for tranmission
+*	memflags	memory allocation flags
+*
+* Returns:
+*	error code from submission
+*
+* Call context:
+*	Any
+----------------------------------------------------------------*/
+static int
+submit_tx_urb(hfa384x_t *hw, struct urb *tx_urb, gfp_t memflags)
+{
+	struct net_device *netdev = hw->wlandev->netdev;
+	int result;
+
+	DBFENTER;
+
+	result = -ENOLINK;
+	if ( netif_running(netdev) ) {
+
+		if ( !hw->wlandev->hwremoved && !test_bit(WORK_TX_HALT, &hw->usb_flags) ) {
+			result = SUBMIT_URB(tx_urb, memflags);
+
+			/* Test whether we need to reset the TX pipe */
+			if (result == -EPIPE) {
+				WLAN_LOG_WARNING("%s tx pipe stalled: requesting reset\n",
+				                 netdev->name);
+				set_bit(WORK_TX_HALT, &hw->usb_flags);
+				schedule_work(&hw->usb_work);
+			} else if (result == 0) {
+				netif_stop_queue(netdev);
+			}
+		}
+	}
+
+	DBFEXIT;
+
+	return result;
+}
+
+/*----------------------------------------------------------------
+* hfa394x_usb_defer
+*
+* There are some things that the USB stack cannot do while
+* in interrupt context, so we arrange this function to run
+* in process context.
+*
+* Arguments:
+*	hw	device structure
+*
+* Returns:
+*	nothing
+*
+* Call context:
+*	process (by design)
+----------------------------------------------------------------*/
+static void
+hfa384x_usb_defer(struct work_struct *data)
+{
+	hfa384x_t *hw = container_of(data, struct hfa384x, usb_work);
+	struct net_device *netdev = hw->wlandev->netdev;
+
+	DBFENTER;
+
+	/* Don't bother trying to reset anything if the plug
+	 * has been pulled ...
+	 */
+	if ( hw->wlandev->hwremoved ) {
+		DBFEXIT;
+		return;
+	}
+
+	/* Reception has stopped: try to reset the input pipe */
+	if (test_bit(WORK_RX_HALT, &hw->usb_flags)) {
+		int ret;
+
+		usb_kill_urb(&hw->rx_urb);  /* Cannot be holding spinlock! */
+
+		ret = usb_clear_halt(hw->usb, hw->endp_in);
+		if (ret != 0) {
+			printk(KERN_ERR
+			       "Failed to clear rx pipe for %s: err=%d\n",
+			       netdev->name, ret);
+		} else {
+			printk(KERN_INFO "%s rx pipe reset complete.\n",
+			                 netdev->name);
+			clear_bit(WORK_RX_HALT, &hw->usb_flags);
+			set_bit(WORK_RX_RESUME, &hw->usb_flags);
+		}
+	}
+
+	/* Resume receiving data back from the device. */
+	if ( test_bit(WORK_RX_RESUME, &hw->usb_flags) ) {
+		int ret;
+
+		ret = submit_rx_urb(hw, GFP_KERNEL);
+		if (ret != 0) {
+			printk(KERN_ERR
+			       "Failed to resume %s rx pipe.\n", netdev->name);
+		} else {
+			clear_bit(WORK_RX_RESUME, &hw->usb_flags);
+		}
+	}
+
+	/* Transmission has stopped: try to reset the output pipe */
+	if (test_bit(WORK_TX_HALT, &hw->usb_flags)) {
+		int ret;
+
+		usb_kill_urb(&hw->tx_urb);
+		ret = usb_clear_halt(hw->usb, hw->endp_out);
+		if (ret != 0) {
+			printk(KERN_ERR
+			       "Failed to clear tx pipe for %s: err=%d\n",
+			       netdev->name, ret);
+		} else {
+			printk(KERN_INFO "%s tx pipe reset complete.\n",
+			                 netdev->name);
+			clear_bit(WORK_TX_HALT, &hw->usb_flags);
+			set_bit(WORK_TX_RESUME, &hw->usb_flags);
+
+			/* Stopping the BULK-OUT pipe also blocked
+			 * us from sending any more CTLX URBs, so
+			 * we need to re-run our queue ...
+			 */
+			hfa384x_usbctlxq_run(hw);
+		}
+	}
+
+	/* Resume transmitting. */
+	if ( test_and_clear_bit(WORK_TX_RESUME, &hw->usb_flags) ) {
+		p80211netdev_wake_queue(hw->wlandev);
+	}
+
+	DBFEXIT;
+}
+
+
+/*----------------------------------------------------------------
+* hfa384x_create
+*
+* Sets up the hfa384x_t data structure for use.  Note this
+* does _not_ intialize the actual hardware, just the data structures
+* we use to keep track of its state.
+*
+* Arguments:
+*	hw		device structure
+*	irq		device irq number
+*	iobase		i/o base address for register access
+*	membase		memory base address for register access
+*
+* Returns:
+*	nothing
+*
+* Side effects:
+*
+* Call context:
+*	process
+----------------------------------------------------------------*/
+void
+hfa384x_create( hfa384x_t *hw, struct usb_device *usb)
+{
+	DBFENTER;
+
+	memset(hw, 0, sizeof(hfa384x_t));
+	hw->usb = usb;
+
+	/* set up the endpoints */
+	hw->endp_in = usb_rcvbulkpipe(usb, 1);
+	hw->endp_out = usb_sndbulkpipe(usb, 2);
+
+	/* Set up the waitq */
+	init_waitqueue_head(&hw->cmdq);
+
+	/* Initialize the command queue */
+	spin_lock_init(&hw->ctlxq.lock);
+	INIT_LIST_HEAD(&hw->ctlxq.pending);
+	INIT_LIST_HEAD(&hw->ctlxq.active);
+	INIT_LIST_HEAD(&hw->ctlxq.completing);
+	INIT_LIST_HEAD(&hw->ctlxq.reapable);
+
+	/* Initialize the authentication queue */
+	skb_queue_head_init(&hw->authq);
+
+	tasklet_init(&hw->reaper_bh,
+	             hfa384x_usbctlx_reaper_task,
+	             (unsigned long)hw);
+	tasklet_init(&hw->completion_bh,
+	             hfa384x_usbctlx_completion_task,
+	             (unsigned long)hw);
+	INIT_WORK2(&hw->link_bh, prism2sta_processing_defer);
+	INIT_WORK2(&hw->usb_work, hfa384x_usb_defer);
+
+	init_timer(&hw->throttle);
+	hw->throttle.function = hfa384x_usb_throttlefn;
+	hw->throttle.data = (unsigned long)hw;
+
+	init_timer(&hw->resptimer);
+	hw->resptimer.function = hfa384x_usbctlx_resptimerfn;
+	hw->resptimer.data = (unsigned long)hw;
+
+	init_timer(&hw->reqtimer);
+	hw->reqtimer.function = hfa384x_usbctlx_reqtimerfn;
+	hw->reqtimer.data = (unsigned long)hw;
+
+	usb_init_urb(&hw->rx_urb);
+	usb_init_urb(&hw->tx_urb);
+	usb_init_urb(&hw->ctlx_urb);
+
+	hw->link_status = HFA384x_LINK_NOTCONNECTED;
+	hw->state = HFA384x_STATE_INIT;
+
+        INIT_WORK2(&hw->commsqual_bh, prism2sta_commsqual_defer);
+	init_timer(&hw->commsqual_timer);
+	hw->commsqual_timer.data = (unsigned long) hw;
+	hw->commsqual_timer.function = prism2sta_commsqual_timer;
+
+	DBFEXIT;
+}
+
+
+/*----------------------------------------------------------------
+* hfa384x_destroy
+*
+* Partner to hfa384x_create().  This function cleans up the hw
+* structure so that it can be freed by the caller using a simple
+* kfree.  Currently, this function is just a placeholder.  If, at some
+* point in the future, an hw in the 'shutdown' state requires a 'deep'
+* kfree, this is where it should be done.  Note that if this function
+* is called on a _running_ hw structure, the drvr_stop() function is
+* called.
+*
+* Arguments:
+*	hw		device structure
+*
+* Returns:
+*	nothing, this function is not allowed to fail.
+*
+* Side effects:
+*
+* Call context:
+*	process
+----------------------------------------------------------------*/
+void
+hfa384x_destroy( hfa384x_t *hw)
+{
+	struct sk_buff *skb;
+
+	DBFENTER;
+
+	if ( hw->state == HFA384x_STATE_RUNNING ) {
+		hfa384x_drvr_stop(hw);
+	}
+	hw->state = HFA384x_STATE_PREINIT;
+
+	if (hw->scanresults) {
+		kfree(hw->scanresults);
+		hw->scanresults = NULL;
+	}
+
+	/* Now to clean out the auth queue */
+        while ( (skb = skb_dequeue(&hw->authq)) ) {
+                dev_kfree_skb(skb);
+        }
+
+	DBFEXIT;
+}
+
+
+/*----------------------------------------------------------------
+ */
+static hfa384x_usbctlx_t* usbctlx_alloc(void)
+{
+	hfa384x_usbctlx_t *ctlx;
+
+	ctlx = kmalloc(sizeof(*ctlx), in_interrupt() ? GFP_ATOMIC : GFP_KERNEL);
+	if (ctlx != NULL)
+	{
+		memset(ctlx, 0, sizeof(*ctlx));
+		init_completion(&ctlx->done);
+	}
+
+	return ctlx;
+}
+
+
+/*----------------------------------------------------------------
+ *
+----------------------------------------------------------------*/
+static int
+usbctlx_get_status(const hfa384x_usb_cmdresp_t *cmdresp,
+                   hfa384x_cmdresult_t *result)
+{
+	DBFENTER;
+
+	result->status = hfa384x2host_16(cmdresp->status);
+	result->resp0 = hfa384x2host_16(cmdresp->resp0);
+	result->resp1 = hfa384x2host_16(cmdresp->resp1);
+	result->resp2 = hfa384x2host_16(cmdresp->resp2);
+
+	WLAN_LOG_DEBUG(4, "cmdresult:status=0x%04x "
+	                  "resp0=0x%04x resp1=0x%04x resp2=0x%04x\n",
+	                result->status,
+	                result->resp0,
+	                result->resp1,
+	                result->resp2);
+
+	DBFEXIT;
+	return (result->status & HFA384x_STATUS_RESULT);
+}
+
+static void
+usbctlx_get_rridresult(const hfa384x_usb_rridresp_t *rridresp,
+                       hfa384x_rridresult_t *result)
+{
+	DBFENTER;
+
+	result->rid = hfa384x2host_16(rridresp->rid);
+	result->riddata = rridresp->data;
+	result->riddata_len = ((hfa384x2host_16(rridresp->frmlen) - 1) * 2);
+
+	DBFEXIT;
+}
+
+
+/*----------------------------------------------------------------
+* Completor object:
+* This completor must be passed to hfa384x_usbctlx_complete_sync()
+* when processing a CTLX that returns a hfa384x_cmdresult_t structure.
+----------------------------------------------------------------*/
+struct usbctlx_cmd_completor
+{
+	usbctlx_completor_t	head;
+
+	const hfa384x_usb_cmdresp_t	*cmdresp;
+	hfa384x_cmdresult_t	*result;
+};
+typedef struct usbctlx_cmd_completor usbctlx_cmd_completor_t;
+
+static int usbctlx_cmd_completor_fn(usbctlx_completor_t *head)
+{
+	usbctlx_cmd_completor_t *complete = (usbctlx_cmd_completor_t*)head;
+	return usbctlx_get_status(complete->cmdresp, complete->result);
+}
+
+static inline usbctlx_completor_t*
+init_cmd_completor(usbctlx_cmd_completor_t *completor,
+                   const hfa384x_usb_cmdresp_t *cmdresp,
+                   hfa384x_cmdresult_t *result)
+{
+	completor->head.complete = usbctlx_cmd_completor_fn;
+	completor->cmdresp = cmdresp;
+	completor->result = result;
+	return &(completor->head);
+}
+
+/*----------------------------------------------------------------
+* Completor object:
+* This completor must be passed to hfa384x_usbctlx_complete_sync()
+* when processing a CTLX that reads a RID.
+----------------------------------------------------------------*/
+struct usbctlx_rrid_completor
+{
+	usbctlx_completor_t	head;
+
+	const hfa384x_usb_rridresp_t	*rridresp;
+	void			*riddata;
+	UINT			riddatalen;
+};
+typedef struct usbctlx_rrid_completor usbctlx_rrid_completor_t;
+
+static int usbctlx_rrid_completor_fn(usbctlx_completor_t *head)
+{
+	usbctlx_rrid_completor_t *complete = (usbctlx_rrid_completor_t*)head;
+	hfa384x_rridresult_t rridresult;
+
+	usbctlx_get_rridresult(complete->rridresp, &rridresult);
+
+	/* Validate the length, note body len calculation in bytes */
+	if ( rridresult.riddata_len != complete->riddatalen ) {
+		WLAN_LOG_WARNING(
+			"RID len mismatch, rid=0x%04x hlen=%d fwlen=%d\n",
+		        rridresult.rid,
+		        complete->riddatalen,
+		        rridresult.riddata_len);
+		return -ENODATA;
+	}
+
+	memcpy(complete->riddata,
+	       rridresult.riddata,
+	       complete->riddatalen);
+	return 0;
+}
+
+static inline usbctlx_completor_t*
+init_rrid_completor(usbctlx_rrid_completor_t *completor,
+                    const hfa384x_usb_rridresp_t *rridresp,
+                    void *riddata,
+                    UINT riddatalen)
+{
+	completor->head.complete = usbctlx_rrid_completor_fn;
+	completor->rridresp = rridresp;
+	completor->riddata = riddata;
+	completor->riddatalen = riddatalen;
+	return &(completor->head);
+}
+
+/*----------------------------------------------------------------
+* Completor object:
+* Interprets the results of a synchronous RID-write
+----------------------------------------------------------------*/
+typedef usbctlx_cmd_completor_t usbctlx_wrid_completor_t;
+#define init_wrid_completor  init_cmd_completor
+
+/*----------------------------------------------------------------
+* Completor object:
+* Interprets the results of a synchronous memory-write
+----------------------------------------------------------------*/
+typedef usbctlx_cmd_completor_t usbctlx_wmem_completor_t;
+#define init_wmem_completor  init_cmd_completor
+
+/*----------------------------------------------------------------
+* Completor object:
+* Interprets the results of a synchronous memory-read
+----------------------------------------------------------------*/
+struct usbctlx_rmem_completor
+{
+        usbctlx_completor_t           head;
+
+        const hfa384x_usb_rmemresp_t  *rmemresp;
+        void                          *data;
+        UINT                          len;
+};
+typedef struct usbctlx_rmem_completor usbctlx_rmem_completor_t;
+
+static int usbctlx_rmem_completor_fn(usbctlx_completor_t *head)
+{
+	usbctlx_rmem_completor_t *complete = (usbctlx_rmem_completor_t*)head;
+
+	WLAN_LOG_DEBUG(4,"rmemresp:len=%d\n", complete->rmemresp->frmlen);
+	memcpy(complete->data, complete->rmemresp->data, complete->len);
+	return 0;
+}
+
+static inline usbctlx_completor_t*
+init_rmem_completor(usbctlx_rmem_completor_t *completor,
+                    hfa384x_usb_rmemresp_t *rmemresp,
+                    void *data,
+                    UINT len)
+{
+	completor->head.complete = usbctlx_rmem_completor_fn;
+	completor->rmemresp = rmemresp;
+	completor->data = data;
+	completor->len = len;
+	return &(completor->head);
+}
+
+/*----------------------------------------------------------------
+* hfa384x_cb_status
+*
+* Ctlx_complete handler for async CMD type control exchanges.
+* mark the hw struct as such.
+*
+* Note: If the handling is changed here, it should probably be
+*       changed in docmd as well.
+*
+* Arguments:
+*	hw		hw struct
+*	ctlx		completed CTLX
+*
+* Returns:
+*	nothing
+*
+* Side effects:
+*
+* Call context:
+*	interrupt
+----------------------------------------------------------------*/
+static void
+hfa384x_cb_status(hfa384x_t *hw, const hfa384x_usbctlx_t *ctlx)
+{
+	DBFENTER;
+
+	if ( ctlx->usercb != NULL ) {
+		hfa384x_cmdresult_t cmdresult;
+
+		if (ctlx->state != CTLX_COMPLETE) {
+			memset(&cmdresult, 0, sizeof(cmdresult));
+			cmdresult.status = HFA384x_STATUS_RESULT_SET(HFA384x_CMD_ERR);
+		} else {
+			usbctlx_get_status(&ctlx->inbuf.cmdresp, &cmdresult);
+		}
+
+		ctlx->usercb(hw, &cmdresult, ctlx->usercb_data);
+	}
+
+	DBFEXIT;
+}
+
+
+/*----------------------------------------------------------------
+* hfa384x_cb_rrid
+*
+* CTLX completion handler for async RRID type control exchanges.
+*
+* Note: If the handling is changed here, it should probably be
+*       changed in dorrid as well.
+*
+* Arguments:
+*	hw		hw struct
+*	ctlx		completed CTLX
+*
+* Returns:
+*	nothing
+*
+* Side effects:
+*
+* Call context:
+*	interrupt
+----------------------------------------------------------------*/
+static void
+hfa384x_cb_rrid(hfa384x_t *hw, const hfa384x_usbctlx_t *ctlx)
+{
+	DBFENTER;
+
+	if ( ctlx->usercb != NULL ) {
+		hfa384x_rridresult_t rridresult;
+
+		if (ctlx->state != CTLX_COMPLETE) {
+			memset(&rridresult, 0, sizeof(rridresult));
+			rridresult.rid = hfa384x2host_16(ctlx->outbuf.rridreq.rid);
+		} else {
+			usbctlx_get_rridresult(&ctlx->inbuf.rridresp, &rridresult);
+		}
+
+		ctlx->usercb(hw, &rridresult, ctlx->usercb_data);
+	}
+
+	DBFEXIT;
+}
+
+static inline int
+hfa384x_docmd_wait(hfa384x_t *hw, hfa384x_metacmd_t *cmd)
+{
+	return hfa384x_docmd(hw, DOWAIT, cmd, NULL, NULL, NULL);
+}
+
+static inline int
+hfa384x_docmd_async(hfa384x_t *hw,
+                    hfa384x_metacmd_t *cmd,
+                    ctlx_cmdcb_t cmdcb,
+                    ctlx_usercb_t usercb,
+                    void *usercb_data)
+{
+	return hfa384x_docmd(hw, DOASYNC, cmd,
+	                        cmdcb, usercb, usercb_data);
+}
+
+static inline int
+hfa384x_dorrid_wait(hfa384x_t *hw, UINT16 rid, void *riddata, UINT riddatalen)
+{
+	return hfa384x_dorrid(hw, DOWAIT,
+	                      rid, riddata, riddatalen,
+	                      NULL, NULL, NULL);
+}
+
+static inline int
+hfa384x_dorrid_async(hfa384x_t *hw,
+                     UINT16 rid, void *riddata, UINT riddatalen,
+                     ctlx_cmdcb_t cmdcb,
+                     ctlx_usercb_t usercb,
+                     void *usercb_data)
+{
+	return hfa384x_dorrid(hw, DOASYNC,
+	                      rid, riddata, riddatalen,
+	                      cmdcb, usercb, usercb_data);
+}
+
+static inline int
+hfa384x_dowrid_wait(hfa384x_t *hw, UINT16 rid, void *riddata, UINT riddatalen)
+{
+	return hfa384x_dowrid(hw, DOWAIT,
+	                      rid, riddata, riddatalen,
+	                      NULL, NULL, NULL);
+}
+
+static inline int
+hfa384x_dowrid_async(hfa384x_t *hw,
+                     UINT16 rid, void *riddata, UINT riddatalen,
+                     ctlx_cmdcb_t cmdcb,
+                     ctlx_usercb_t usercb,
+                     void *usercb_data)
+{
+	return hfa384x_dowrid(hw, DOASYNC,
+	                      rid, riddata, riddatalen,
+	                      cmdcb, usercb, usercb_data);
+}
+
+static inline int
+hfa384x_dormem_wait(hfa384x_t *hw,
+                    UINT16 page, UINT16 offset, void *data, UINT len)
+{
+	return hfa384x_dormem(hw, DOWAIT,
+	                      page, offset, data, len,
+	                      NULL, NULL, NULL);
+}
+
+static inline int
+hfa384x_dormem_async(hfa384x_t *hw,
+                     UINT16 page, UINT16 offset, void *data, UINT len,
+                     ctlx_cmdcb_t cmdcb,
+                     ctlx_usercb_t usercb,
+                     void *usercb_data)
+{
+	return hfa384x_dormem(hw, DOASYNC,
+	                      page, offset, data, len,
+	                      cmdcb, usercb, usercb_data);
+}
+
+static inline int
+hfa384x_dowmem_wait(
+        hfa384x_t *hw,
+        UINT16  page,
+        UINT16  offset,
+        void    *data,
+        UINT    len)
+{
+	return hfa384x_dowmem(hw, DOWAIT,
+                                  page, offset, data, len,
+	                          NULL, NULL, NULL);
+}
+
+static inline int
+hfa384x_dowmem_async(
+        hfa384x_t *hw,
+        UINT16  page,
+        UINT16  offset,
+        void    *data,
+        UINT    len,
+        ctlx_cmdcb_t cmdcb,
+        ctlx_usercb_t usercb,
+        void    *usercb_data)
+{
+	return hfa384x_dowmem(hw, DOASYNC,
+                                  page, offset, data, len,
+	                          cmdcb, usercb, usercb_data);
+}
+
+/*----------------------------------------------------------------
+* hfa384x_cmd_initialize
+*
+* Issues the initialize command and sets the hw->state based
+* on the result.
+*
+* Arguments:
+*	hw		device structure
+*
+* Returns:
+*	0		success
+*	>0		f/w reported error - f/w status code
+*	<0		driver reported error
+*
+* Side effects:
+*
+* Call context:
+*	process
+----------------------------------------------------------------*/
+int
+hfa384x_cmd_initialize(hfa384x_t *hw)
+{
+	int	result = 0;
+	int	i;
+	hfa384x_metacmd_t cmd;
+
+	DBFENTER;
+
+
+	cmd.cmd = HFA384x_CMDCODE_INIT;
+	cmd.parm0 = 0;
+	cmd.parm1 = 0;
+	cmd.parm2 = 0;
+
+	result = hfa384x_docmd_wait(hw, &cmd);
+
+
+	WLAN_LOG_DEBUG(3,"cmdresp.init: "
+		"status=0x%04x, resp0=0x%04x, "
+		"resp1=0x%04x, resp2=0x%04x\n",
+		cmd.result.status,
+		cmd.result.resp0,
+		cmd.result.resp1,
+		cmd.result.resp2);
+	if ( result == 0 ) {
+		for ( i = 0; i < HFA384x_NUMPORTS_MAX; i++) {
+			hw->port_enabled[i] = 0;
+		}
+	}
+
+        hw->link_status = HFA384x_LINK_NOTCONNECTED;
+
+	DBFEXIT;
+	return result;
+}
+
+
+/*----------------------------------------------------------------
+* hfa384x_cmd_disable
+*
+* Issues the disable command to stop communications on one of
+* the MACs 'ports'.
+*
+* Arguments:
+*	hw		device structure
+*	macport		MAC port number (host order)
+*
+* Returns:
+*	0		success
+*	>0		f/w reported failure - f/w status code
+*	<0		driver reported error (timeout|bad arg)
+*
+* Side effects:
+*
+* Call context:
+*	process
+----------------------------------------------------------------*/
+int hfa384x_cmd_disable(hfa384x_t *hw, UINT16 macport)
+{
+	int	result = 0;
+	hfa384x_metacmd_t cmd;
+
+	DBFENTER;
+
+	cmd.cmd = HFA384x_CMD_CMDCODE_SET(HFA384x_CMDCODE_DISABLE) |
+		  HFA384x_CMD_MACPORT_SET(macport);
+	cmd.parm0 = 0;
+	cmd.parm1 = 0;
+	cmd.parm2 = 0;
+
+	result = hfa384x_docmd_wait(hw, &cmd);
+
+	DBFEXIT;
+	return result;
+}
+
+
+/*----------------------------------------------------------------
+* hfa384x_cmd_enable
+*
+* Issues the enable command to enable communications on one of
+* the MACs 'ports'.
+*
+* Arguments:
+*	hw		device structure
+*	macport		MAC port number
+*
+* Returns:
+*	0		success
+*	>0		f/w reported failure - f/w status code
+*	<0		driver reported error (timeout|bad arg)
+*
+* Side effects:
+*
+* Call context:
+*	process
+----------------------------------------------------------------*/
+int hfa384x_cmd_enable(hfa384x_t *hw, UINT16 macport)
+{
+	int	result = 0;
+	hfa384x_metacmd_t cmd;
+
+	DBFENTER;
+
+	cmd.cmd = HFA384x_CMD_CMDCODE_SET(HFA384x_CMDCODE_ENABLE) |
+		  HFA384x_CMD_MACPORT_SET(macport);
+	cmd.parm0 = 0;
+	cmd.parm1 = 0;
+	cmd.parm2 = 0;
+
+	result = hfa384x_docmd_wait(hw, &cmd);
+
+	DBFEXIT;
+	return result;
+}
+
+
+/*----------------------------------------------------------------
+* hfa384x_cmd_notify
+*
+* Sends an info frame to the firmware to alter the behavior
+* of the f/w asynch processes.  Can only be called when the MAC
+* is in the enabled state.
+*
+* Arguments:
+*	hw		device structure
+*	reclaim		[0|1] indicates whether the given FID will
+*			be handed back (via Alloc event) for reuse.
+*			(host order)
+*	fid		FID of buffer containing the frame that was
+*			previously copied to MAC memory via the bap.
+*			(host order)
+*
+* Returns:
+*	0		success
+*	>0		f/w reported failure - f/w status code
+*	<0		driver reported error (timeout|bad arg)
+*
+* Side effects:
+*	hw->resp0 will contain the FID being used by async notify
+*	process.  If reclaim==0, resp0 will be the same as the fid
+*	argument.  If reclaim==1, resp0 will be the different.
+*
+* Call context:
+*	process
+----------------------------------------------------------------*/
+int hfa384x_cmd_notify(hfa384x_t *hw, UINT16 reclaim, UINT16 fid,
+		       void *buf, UINT16 len)
+{
+#if 0
+	int	result = 0;
+	UINT16	cmd;
+	DBFENTER;
+	cmd =	HFA384x_CMD_CMDCODE_SET(HFA384x_CMDCODE_NOTIFY) |
+		HFA384x_CMD_RECL_SET(reclaim);
+	result = hfa384x_docmd_wait(hw, cmd);
+
+	DBFEXIT;
+	return result;
+#endif
+return 0;
+}
+
+
+#if 0
+/*----------------------------------------------------------------
+* hfa384x_cmd_inquiry
+*
+* Requests an info frame from the firmware.  The info frame will
+* be delivered asynchronously via the Info event.
+*
+* Arguments:
+*	hw		device structure
+*	fid		FID of the info frame requested. (host order)
+*
+* Returns:
+*	0		success
+*	>0		f/w reported failure - f/w status code
+*	<0		driver reported error (timeout|bad arg)
+*
+* Side effects:
+*
+* Call context:
+*	process
+----------------------------------------------------------------*/
+int hfa384x_cmd_inquiry(hfa384x_t *hw, UINT16 fid)
+{
+	int	result = 0;
+	hfa384x_metacmd_t cmd;
+
+	DBFENTER;
+
+	cmd.cmd = HFA384x_CMD_CMDCODE_SET(HFA384x_CMDCODE_INQ);
+	cmd.parm0 = 0;
+	cmd.parm1 = 0;
+	cmd.parm2 = 0;
+
+	result = hfa384x_docmd_wait(hw, &cmd);
+
+	DBFEXIT;
+	return result;
+}
+#endif
+
+
+/*----------------------------------------------------------------
+* hfa384x_cmd_monitor
+*
+* Enables the 'monitor mode' of the MAC.  Here's the description of
+* monitor mode that I've received thus far:
+*
+*  "The "monitor mode" of operation is that the MAC passes all
+*  frames for which the PLCP checks are correct. All received
+*  MPDUs are passed to the host with MAC Port = 7, with a
+*  receive status of good, FCS error, or undecryptable. Passing
+*  certain MPDUs is a violation of the 802.11 standard, but useful
+*  for a debugging tool."  Normal communication is not possible
+*  while monitor mode is enabled.
+*
+* Arguments:
+*	hw		device structure
+*	enable		a code (0x0b|0x0f) that enables/disables
+*			monitor mode. (host order)
+*
+* Returns:
+*	0		success
+*	>0		f/w reported failure - f/w status code
+*	<0		driver reported error (timeout|bad arg)
+*
+* Side effects:
+*
+* Call context:
+*	process
+----------------------------------------------------------------*/
+int hfa384x_cmd_monitor(hfa384x_t *hw, UINT16 enable)
+{
+	int	result = 0;
+	hfa384x_metacmd_t cmd;
+
+	DBFENTER;
+
+	cmd.cmd = HFA384x_CMD_CMDCODE_SET(HFA384x_CMDCODE_MONITOR) |
+		HFA384x_CMD_AINFO_SET(enable);
+	cmd.parm0 = 0;
+	cmd.parm1 = 0;
+	cmd.parm2 = 0;
+
+	result = hfa384x_docmd_wait(hw, &cmd);
+
+	DBFEXIT;
+	return result;
+}
+
+
+/*----------------------------------------------------------------
+* hfa384x_cmd_download
+*
+* Sets the controls for the MAC controller code/data download
+* process.  The arguments set the mode and address associated
+* with a download.  Note that the aux registers should be enabled
+* prior to setting one of the download enable modes.
+*
+* Arguments:
+*	hw		device structure
+*	mode		0 - Disable programming and begin code exec
+*			1 - Enable volatile mem programming
+*			2 - Enable non-volatile mem programming
+*			3 - Program non-volatile section from NV download
+*			    buffer.
+*			(host order)
+*	lowaddr
+*	highaddr	For mode 1, sets the high & low order bits of
+*			the "destination address".  This address will be
+*			the execution start address when download is
+*			subsequently disabled.
+*			For mode 2, sets the high & low order bits of
+*			the destination in NV ram.
+*			For modes 0 & 3, should be zero. (host order)
+*			NOTE: these are CMD format.
+*	codelen		Length of the data to write in mode 2,
+*			zero otherwise. (host order)
+*
+* Returns:
+*	0		success
+*	>0		f/w reported failure - f/w status code
+*	<0		driver reported error (timeout|bad arg)
+*
+* Side effects:
+*
+* Call context:
+*	process
+----------------------------------------------------------------*/
+int hfa384x_cmd_download(hfa384x_t *hw, UINT16 mode, UINT16 lowaddr,
+				UINT16 highaddr, UINT16 codelen)
+{
+	int	result = 0;
+	hfa384x_metacmd_t cmd;
+
+	DBFENTER;
+	WLAN_LOG_DEBUG(5,
+		"mode=%d, lowaddr=0x%04x, highaddr=0x%04x, codelen=%d\n",
+		mode, lowaddr, highaddr, codelen);
+
+	cmd.cmd = (HFA384x_CMD_CMDCODE_SET(HFA384x_CMDCODE_DOWNLD) |
+		   HFA384x_CMD_PROGMODE_SET(mode));
+
+	cmd.parm0 = lowaddr;
+	cmd.parm1 = highaddr;
+	cmd.parm2 = codelen;
+
+	result = hfa384x_docmd_wait(hw, &cmd);
+
+	DBFEXIT;
+	return result;
+}
+
+
+/*----------------------------------------------------------------
+* hfa384x_copy_from_aux
+*
+* Copies a collection of bytes from the controller memory.  The
+* Auxiliary port MUST be enabled prior to calling this function.
+* We _might_ be in a download state.
+*
+* Arguments:
+*	hw		device structure
+*	cardaddr	address in hfa384x data space to read
+*	auxctl		address space select
+*	buf		ptr to destination host buffer
+*	len		length of data to transfer (in bytes)
+*
+* Returns:
+*	nothing
+*
+* Side effects:
+*	buf contains the data copied
+*
+* Call context:
+*	process
+*	interrupt
+----------------------------------------------------------------*/
+void
+hfa384x_copy_from_aux(
+	hfa384x_t *hw, UINT32 cardaddr, UINT32 auxctl, void *buf, UINT len)
+{
+	DBFENTER;
+	WLAN_LOG_ERROR("not used in USB.\n");
+	DBFEXIT;
+}
+
+
+/*----------------------------------------------------------------
+* hfa384x_copy_to_aux
+*
+* Copies a collection of bytes to the controller memory.  The
+* Auxiliary port MUST be enabled prior to calling this function.
+* We _might_ be in a download state.
+*
+* Arguments:
+*	hw		device structure
+*	cardaddr	address in hfa384x data space to read
+*	auxctl		address space select
+*	buf		ptr to destination host buffer
+*	len		length of data to transfer (in bytes)
+*
+* Returns:
+*	nothing
+*
+* Side effects:
+*	Controller memory now contains a copy of buf
+*
+* Call context:
+*	process
+*	interrupt
+----------------------------------------------------------------*/
+void
+hfa384x_copy_to_aux(
+	hfa384x_t *hw, UINT32 cardaddr, UINT32 auxctl, void *buf, UINT len)
+{
+	DBFENTER;
+	WLAN_LOG_ERROR("not used in USB.\n");
+	DBFEXIT;
+}
+
+
+/*----------------------------------------------------------------
+* hfa384x_corereset
+*
+* Perform a reset of the hfa38xx MAC core.  We assume that the hw
+* structure is in its "created" state.  That is, it is initialized
+* with proper values.  Note that if a reset is done after the
+* device has been active for awhile, the caller might have to clean
+* up some leftover cruft in the hw structure.
+*
+* Arguments:
+*	hw		device structure
+*	holdtime	how long (in ms) to hold the reset
+*	settletime	how long (in ms) to wait after releasing
+*			the reset
+*
+* Returns:
+*	nothing
+*
+* Side effects:
+*
+* Call context:
+*	process
+----------------------------------------------------------------*/
+int hfa384x_corereset(hfa384x_t *hw, int holdtime, int settletime, int genesis)
+{
+#if 0
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0))
+	struct usb_device	*parent = hw->usb->parent;
+	int			i;
+	int			port = -1;
+#endif
+#endif
+	int 			result = 0;
+
+
+#define P2_USB_RT_PORT		(USB_TYPE_CLASS | USB_RECIP_OTHER)
+#define P2_USB_FEAT_RESET	4
+#define P2_USB_FEAT_C_RESET	20
+
+	DBFENTER;
+
+#if 0
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0))
+	/* Find the hub port */
+	for ( i = 0; i < parent->maxchild; i++) {
+		if (parent->children[i] == hw->usb) {
+			port = i;
+			break;
+		}
+	}
+	if (port < 0) return -ENOENT;
+
+	/* Set and clear the reset */
+	usb_control_msg(parent, usb_sndctrlpipe(parent, 0),
+		USB_REQ_SET_FEATURE, P2_USB_RT_PORT, P2_USB_FEAT_RESET,
+		port+1, NULL, 0, 1*HZ);
+	wait_ms(holdtime);
+	usb_control_msg(parent, usb_sndctrlpipe(parent, 0),
+		USB_REQ_CLEAR_FEATURE, P2_USB_RT_PORT, P2_USB_FEAT_C_RESET,
+		port+1, NULL, 0, 1*HZ);
+	wait_ms(settletime);
+
+	/* Set the device address */
+	result=usb_set_address(hw->usb);
+	if (result < 0) {
+		WLAN_LOG_ERROR("reset_usbdev: Dev not accepting address, "
+			"result=%d\n", result);
+		clear_bit(hw->usb->devnum, &hw->usb->bus->devmap.devicemap);
+		hw->usb->devnum = -1;
+		goto done;
+	}
+	/* Let the address settle */
+	wait_ms(20);
+
+	/* Assume we're reusing the original descriptor data */
+
+	/* Set the configuration. */
+	WLAN_LOG_DEBUG(3, "Setting Configuration %d\n",
+		hw->usb->config[0].bConfigurationValue);
+	result=usb_set_configuration(hw->usb, hw->usb->config[0].bConfigurationValue);
+	if ( result ) {
+		WLAN_LOG_ERROR("usb_set_configuration() failed, result=%d.\n",
+				result);
+		goto done;
+	}
+	/* Let the configuration settle */
+	wait_ms(20);
+
+ done:
+#else
+	result=usb_reset_device(hw->usb);
+	if(result<0) {
+		WLAN_LOG_ERROR("usb_reset_device() failed, result=%d.\n",result);
+	}
+#endif
+#endif
+
+	result=usb_reset_device(hw->usb);
+	if(result<0) {
+		WLAN_LOG_ERROR("usb_reset_device() failed, result=%d.\n",result);
+	}
+
+	DBFEXIT;
+	return result;
+}
+
+
+/*----------------------------------------------------------------
+* hfa384x_usbctlx_complete_sync
+*
+* Waits for a synchronous CTLX object to complete,
+* and then handles the response.
+*
+* Arguments:
+*	hw		device structure
+*	ctlx	 	CTLX ptr
+*	completor	functor object to decide what to
+*			do with the CTLX's result.
+*
+* Returns:
+*	0		Success
+*	-ERESTARTSYS	Interrupted by a signal
+*	-EIO		CTLX failed
+*	-ENODEV		Adapter was unplugged
+*	???		Result from completor
+*
+* Side effects:
+*
+* Call context:
+*	process
+----------------------------------------------------------------*/
+static int hfa384x_usbctlx_complete_sync(hfa384x_t *hw,
+					 hfa384x_usbctlx_t *ctlx,
+					 usbctlx_completor_t *completor)
+{
+	unsigned long flags;
+	int result;
+
+	DBFENTER;
+
+	result = wait_for_completion_interruptible(&ctlx->done);
+
+	spin_lock_irqsave(&hw->ctlxq.lock, flags);
+
+	/*
+	 * We can only handle the CTLX if the USB disconnect
+	 * function has not run yet ...
+	 */
+	cleanup:
+	if ( hw->wlandev->hwremoved )
+	{
+		spin_unlock_irqrestore(&hw->ctlxq.lock, flags);
+		result = -ENODEV;
+	}
+	else if ( result != 0 )
+	{
+		int runqueue = 0;
+
+		/*
+		 * We were probably interrupted, so delete
+		 * this CTLX asynchronously, kill the timers
+		 * and the URB, and then start the next
+		 * pending CTLX.
+		 *
+		 * NOTE: We can only delete the timers and
+		 *       the URB if this CTLX is active.
+		 */
+		if (ctlx == get_active_ctlx(hw))
+		{
+			spin_unlock_irqrestore(&hw->ctlxq.lock, flags);
+
+			del_singleshot_timer_sync(&hw->reqtimer);
+			del_singleshot_timer_sync(&hw->resptimer);
+			hw->req_timer_done = 1;
+			hw->resp_timer_done = 1;
+			usb_kill_urb(&hw->ctlx_urb);
+
+			spin_lock_irqsave(&hw->ctlxq.lock, flags);
+
+			runqueue = 1;
+
+			/*
+			 * This scenario is so unlikely that I'm
+			 * happy with a grubby "goto" solution ...
+			 */
+			if ( hw->wlandev->hwremoved )
+				goto cleanup;
+		}
+
+		/*
+		 * The completion task will send this CTLX
+		 * to the reaper the next time it runs. We
+		 * are no longer in a hurry.
+		 */
+		ctlx->reapable = 1;
+		ctlx->state = CTLX_REQ_FAILED;
+		list_move_tail(&ctlx->list, &hw->ctlxq.completing);
+
+		spin_unlock_irqrestore(&hw->ctlxq.lock, flags);
+
+		if (runqueue)
+			hfa384x_usbctlxq_run(hw);
+	} else {
+		if (ctlx->state == CTLX_COMPLETE) {
+			result = completor->complete(completor);
+		} else {
+			WLAN_LOG_WARNING("CTLX[%d] error: state(%s)\n",
+			                 hfa384x2host_16(ctlx->outbuf.type),
+			                 ctlxstr(ctlx->state));
+			result = -EIO;
+		}
+
+		list_del(&ctlx->list);
+		spin_unlock_irqrestore(&hw->ctlxq.lock, flags);
+		kfree(ctlx);
+	}
+
+	DBFEXIT;
+	return result;
+}
+
+/*----------------------------------------------------------------
+* hfa384x_docmd
+*
+* Constructs a command CTLX and submits it.
+*
+* NOTE: Any changes to the 'post-submit' code in this function
+*       need to be carried over to hfa384x_cbcmd() since the handling
+*       is virtually identical.
+*
+* Arguments:
+*	hw		device structure
+*	mode		DOWAIT or DOASYNC
+*       cmd             cmd structure.  Includes all arguments and result
+*                       data points.  All in host order. in host order
+*	cmdcb		command-specific callback
+*	usercb		user callback for async calls, NULL for DOWAIT calls
+*	usercb_data	user supplied data pointer for async calls, NULL
+*			for DOASYNC calls
+*
+* Returns:
+*	0		success
+*	-EIO		CTLX failure
+*	-ERESTARTSYS	Awakened on signal
+*	>0		command indicated error, Status and Resp0-2 are
+*			in hw structure.
+*
+* Side effects:
+*
+*
+* Call context:
+*	process
+----------------------------------------------------------------*/
+static int
+hfa384x_docmd(
+	hfa384x_t *hw,
+	CMD_MODE mode,
+	hfa384x_metacmd_t *cmd,
+	ctlx_cmdcb_t	cmdcb,
+	ctlx_usercb_t	usercb,
+	void	*usercb_data)
+{
+	int			result;
+	hfa384x_usbctlx_t	*ctlx;
+
+	DBFENTER;
+	ctlx = usbctlx_alloc();
+	if ( ctlx == NULL ) {
+		result = -ENOMEM;
+		goto done;
+	}
+
+	/* Initialize the command */
+	ctlx->outbuf.cmdreq.type = 	host2hfa384x_16(HFA384x_USB_CMDREQ);
+	ctlx->outbuf.cmdreq.cmd =	host2hfa384x_16(cmd->cmd);
+	ctlx->outbuf.cmdreq.parm0 =	host2hfa384x_16(cmd->parm0);
+	ctlx->outbuf.cmdreq.parm1 =	host2hfa384x_16(cmd->parm1);
+	ctlx->outbuf.cmdreq.parm2 =	host2hfa384x_16(cmd->parm2);
+
+	ctlx->outbufsize = sizeof(ctlx->outbuf.cmdreq);
+
+	WLAN_LOG_DEBUG(4, "cmdreq: cmd=0x%04x "
+		"parm0=0x%04x parm1=0x%04x parm2=0x%04x\n",
+		cmd->cmd,
+		cmd->parm0,
+		cmd->parm1,
+		cmd->parm2);
+
+	ctlx->reapable = mode;
+	ctlx->cmdcb = cmdcb;
+	ctlx->usercb = usercb;
+	ctlx->usercb_data = usercb_data;
+
+	result = hfa384x_usbctlx_submit(hw, ctlx);
+	if (result != 0) {
+		kfree(ctlx);
+	} else if (mode == DOWAIT) {
+		usbctlx_cmd_completor_t completor;
+
+		result = hfa384x_usbctlx_complete_sync(
+		             hw, ctlx, init_cmd_completor(&completor,
+		                                          &ctlx->inbuf.cmdresp,
+		                                          &cmd->result) );
+	}
+
+done:
+	DBFEXIT;
+	return result;
+}
+
+
+/*----------------------------------------------------------------
+* hfa384x_dorrid
+*
+* Constructs a read rid CTLX and issues it.
+*
+* NOTE: Any changes to the 'post-submit' code in this function
+*       need to be carried over to hfa384x_cbrrid() since the handling
+*       is virtually identical.
+*
+* Arguments:
+*	hw		device structure
+*	mode		DOWAIT or DOASYNC
+*	rid		Read RID number (host order)
+*	riddata		Caller supplied buffer that MAC formatted RID.data
+*			record will be written to for DOWAIT calls. Should
+*			be NULL for DOASYNC calls.
+*	riddatalen	Buffer length for DOWAIT calls. Zero for DOASYNC calls.
+*	cmdcb		command callback for async calls, NULL for DOWAIT calls
+*	usercb		user callback for async calls, NULL for DOWAIT calls
+*	usercb_data	user supplied data pointer for async calls, NULL
+*			for DOWAIT calls
+*
+* Returns:
+*	0		success
+*	-EIO		CTLX failure
+*	-ERESTARTSYS	Awakened on signal
+*	-ENODATA	riddatalen != macdatalen
+*	>0		command indicated error, Status and Resp0-2 are
+*			in hw structure.
+*
+* Side effects:
+*
+* Call context:
+*	interrupt (DOASYNC)
+*	process (DOWAIT or DOASYNC)
+----------------------------------------------------------------*/
+static int
+hfa384x_dorrid(
+	hfa384x_t *hw,
+	CMD_MODE mode,
+	UINT16	rid,
+	void	*riddata,
+	UINT	riddatalen,
+        ctlx_cmdcb_t cmdcb,
+	ctlx_usercb_t usercb,
+	void	*usercb_data)
+{
+	int			result;
+	hfa384x_usbctlx_t	*ctlx;
+
+	DBFENTER;
+	ctlx = usbctlx_alloc();
+	if ( ctlx == NULL ) {
+		result = -ENOMEM;
+		goto done;
+	}
+
+	/* Initialize the command */
+	ctlx->outbuf.rridreq.type =   host2hfa384x_16(HFA384x_USB_RRIDREQ);
+	ctlx->outbuf.rridreq.frmlen =
+		host2hfa384x_16(sizeof(ctlx->outbuf.rridreq.rid));
+	ctlx->outbuf.rridreq.rid =    host2hfa384x_16(rid);
+
+	ctlx->outbufsize = sizeof(ctlx->outbuf.rridreq);
+
+	ctlx->reapable = mode;
+	ctlx->cmdcb = cmdcb;
+	ctlx->usercb = usercb;
+	ctlx->usercb_data = usercb_data;
+
+	/* Submit the CTLX */
+	result = hfa384x_usbctlx_submit(hw, ctlx);
+	if (result != 0) {
+		kfree(ctlx);
+	} else if (mode == DOWAIT) {
+		usbctlx_rrid_completor_t completor;
+
+		result = hfa384x_usbctlx_complete_sync(
+		           hw, ctlx, init_rrid_completor(&completor,
+		                                         &ctlx->inbuf.rridresp,
+		                                         riddata,
+		                                         riddatalen) );
+	}
+
+done:
+	DBFEXIT;
+	return result;
+}
+
+
+/*----------------------------------------------------------------
+* hfa384x_dowrid
+*
+* Constructs a write rid CTLX and issues it.
+*
+* NOTE: Any changes to the 'post-submit' code in this function
+*       need to be carried over to hfa384x_cbwrid() since the handling
+*       is virtually identical.
+*
+* Arguments:
+*	hw		device structure
+*	CMD_MODE	DOWAIT or DOASYNC
+*	rid		RID code
+*	riddata		Data portion of RID formatted for MAC
+*	riddatalen	Length of the data portion in bytes
+*       cmdcb           command callback for async calls, NULL for DOWAIT calls
+*	usercb		user callback for async calls, NULL for DOWAIT calls
+*	usercb_data	user supplied data pointer for async calls
+*
+* Returns:
+*	0		success
+*	-ETIMEDOUT	timed out waiting for register ready or
+*			command completion
+*	>0		command indicated error, Status and Resp0-2 are
+*			in hw structure.
+*
+* Side effects:
+*
+* Call context:
+*	interrupt (DOASYNC)
+*	process (DOWAIT or DOASYNC)
+----------------------------------------------------------------*/
+static int
+hfa384x_dowrid(
+	hfa384x_t *hw,
+	CMD_MODE mode,
+	UINT16	rid,
+	void	*riddata,
+	UINT	riddatalen,
+	ctlx_cmdcb_t cmdcb,
+	ctlx_usercb_t usercb,
+	void	*usercb_data)
+{
+	int			result;
+	hfa384x_usbctlx_t	*ctlx;
+
+	DBFENTER;
+	ctlx = usbctlx_alloc();
+	if ( ctlx == NULL ) {
+		result = -ENOMEM;
+		goto done;
+	}
+
+	/* Initialize the command */
+	ctlx->outbuf.wridreq.type =   host2hfa384x_16(HFA384x_USB_WRIDREQ);
+	ctlx->outbuf.wridreq.frmlen = host2hfa384x_16(
+					(sizeof(ctlx->outbuf.wridreq.rid) +
+					riddatalen + 1) / 2);
+	ctlx->outbuf.wridreq.rid =    host2hfa384x_16(rid);
+	memcpy(ctlx->outbuf.wridreq.data, riddata, riddatalen);
+
+	ctlx->outbufsize = sizeof(ctlx->outbuf.wridreq.type) +
+	                   sizeof(ctlx->outbuf.wridreq.frmlen) +
+	                   sizeof(ctlx->outbuf.wridreq.rid) +
+	                   riddatalen;
+
+	ctlx->reapable = mode;
+	ctlx->cmdcb = cmdcb;
+	ctlx->usercb = usercb;
+	ctlx->usercb_data = usercb_data;
+
+	/* Submit the CTLX */
+	result = hfa384x_usbctlx_submit(hw, ctlx);
+	if (result != 0) {
+		kfree(ctlx);
+	} else if (mode == DOWAIT) {
+		usbctlx_wrid_completor_t completor;
+		hfa384x_cmdresult_t wridresult;
+
+		result = hfa384x_usbctlx_complete_sync(
+		               hw,
+		               ctlx,
+		               init_wrid_completor(&completor,
+		                                   &ctlx->inbuf.wridresp,
+		                                   &wridresult) );
+	}
+
+done:
+	DBFEXIT;
+	return result;
+}
+
+/*----------------------------------------------------------------
+* hfa384x_dormem
+*
+* Constructs a readmem CTLX and issues it.
+*
+* NOTE: Any changes to the 'post-submit' code in this function
+*       need to be carried over to hfa384x_cbrmem() since the handling
+*       is virtually identical.
+*
+* Arguments:
+*	hw		device structure
+*	mode		DOWAIT or DOASYNC
+*	page		MAC address space page (CMD format)
+*	offset		MAC address space offset
+*	data		Ptr to data buffer to receive read
+*	len		Length of the data to read (max == 2048)
+*	cmdcb		command callback for async calls, NULL for DOWAIT calls
+*	usercb		user callback for async calls, NULL for DOWAIT calls
+*	usercb_data	user supplied data pointer for async calls
+*
+* Returns:
+*	0		success
+*	-ETIMEDOUT	timed out waiting for register ready or
+*			command completion
+*	>0		command indicated error, Status and Resp0-2 are
+*			in hw structure.
+*
+* Side effects:
+*
+* Call context:
+*	interrupt (DOASYNC)
+*	process (DOWAIT or DOASYNC)
+----------------------------------------------------------------*/
+static int
+hfa384x_dormem(
+	hfa384x_t *hw,
+	CMD_MODE mode,
+	UINT16	page,
+	UINT16	offset,
+	void	*data,
+	UINT	len,
+	ctlx_cmdcb_t cmdcb,
+	ctlx_usercb_t usercb,
+	void	*usercb_data)
+{
+	int			result;
+	hfa384x_usbctlx_t	*ctlx;
+
+	DBFENTER;
+	ctlx = usbctlx_alloc();
+	if ( ctlx == NULL ) {
+		result = -ENOMEM;
+		goto done;
+	}
+
+	/* Initialize the command */
+	ctlx->outbuf.rmemreq.type =    host2hfa384x_16(HFA384x_USB_RMEMREQ);
+	ctlx->outbuf.rmemreq.frmlen =  host2hfa384x_16(
+					sizeof(ctlx->outbuf.rmemreq.offset) +
+					sizeof(ctlx->outbuf.rmemreq.page) +
+					len);
+	ctlx->outbuf.rmemreq.offset =	host2hfa384x_16(offset);
+	ctlx->outbuf.rmemreq.page =	host2hfa384x_16(page);
+
+	ctlx->outbufsize = sizeof(ctlx->outbuf.rmemreq);
+
+	WLAN_LOG_DEBUG(4,
+		"type=0x%04x frmlen=%d offset=0x%04x page=0x%04x\n",
+		ctlx->outbuf.rmemreq.type,
+		ctlx->outbuf.rmemreq.frmlen,
+		ctlx->outbuf.rmemreq.offset,
+		ctlx->outbuf.rmemreq.page);
+
+	WLAN_LOG_DEBUG(4,"pktsize=%zd\n",
+		ROUNDUP64(sizeof(ctlx->outbuf.rmemreq)));
+
+	ctlx->reapable = mode;
+	ctlx->cmdcb = cmdcb;
+	ctlx->usercb = usercb;
+	ctlx->usercb_data = usercb_data;
+
+	result = hfa384x_usbctlx_submit(hw, ctlx);
+	if (result != 0) {
+		kfree(ctlx);
+	} else if ( mode == DOWAIT ) {
+                usbctlx_rmem_completor_t completor;
+
+                result = hfa384x_usbctlx_complete_sync(
+                           hw, ctlx, init_rmem_completor(&completor,
+                                                         &ctlx->inbuf.rmemresp,
+                                                         data,
+                                                         len) );
+	}
+
+done:
+	DBFEXIT;
+	return result;
+}
+
+
+
+/*----------------------------------------------------------------
+* hfa384x_dowmem
+*
+* Constructs a writemem CTLX and issues it.
+*
+* NOTE: Any changes to the 'post-submit' code in this function
+*       need to be carried over to hfa384x_cbwmem() since the handling
+*       is virtually identical.
+*
+* Arguments:
+*	hw		device structure
+*	mode		DOWAIT or DOASYNC
+*	page		MAC address space page (CMD format)
+*	offset		MAC address space offset
+*	data		Ptr to data buffer containing write data
+*	len		Length of the data to read (max == 2048)
+*	cmdcb		command callback for async calls, NULL for DOWAIT calls
+*	usercb		user callback for async calls, NULL for DOWAIT calls
+*	usercb_data	user supplied data pointer for async calls.
+*
+* Returns:
+*	0		success
+*	-ETIMEDOUT	timed out waiting for register ready or
+*			command completion
+*	>0		command indicated error, Status and Resp0-2 are
+*			in hw structure.
+*
+* Side effects:
+*
+* Call context:
+*	interrupt (DOWAIT)
+*	process (DOWAIT or DOASYNC)
+----------------------------------------------------------------*/
+static int
+hfa384x_dowmem(
+	hfa384x_t *hw,
+	CMD_MODE mode,
+	UINT16	page,
+	UINT16	offset,
+	void	*data,
+	UINT	len,
+	ctlx_cmdcb_t cmdcb,
+	ctlx_usercb_t usercb,
+	void	*usercb_data)
+{
+	int			result;
+	hfa384x_usbctlx_t	*ctlx;
+
+	DBFENTER;
+	WLAN_LOG_DEBUG(5, "page=0x%04x offset=0x%04x len=%d\n",
+		page,offset,len);
+
+	ctlx = usbctlx_alloc();
+	if ( ctlx == NULL ) {
+		result = -ENOMEM;
+		goto done;
+	}
+
+	/* Initialize the command */
+	ctlx->outbuf.wmemreq.type =   host2hfa384x_16(HFA384x_USB_WMEMREQ);
+	ctlx->outbuf.wmemreq.frmlen = host2hfa384x_16(
+					sizeof(ctlx->outbuf.wmemreq.offset) +
+					sizeof(ctlx->outbuf.wmemreq.page) +
+					len);
+	ctlx->outbuf.wmemreq.offset = host2hfa384x_16(offset);
+	ctlx->outbuf.wmemreq.page =   host2hfa384x_16(page);
+	memcpy(ctlx->outbuf.wmemreq.data, data, len);
+
+	ctlx->outbufsize = sizeof(ctlx->outbuf.wmemreq.type) +
+	                   sizeof(ctlx->outbuf.wmemreq.frmlen) +
+	                   sizeof(ctlx->outbuf.wmemreq.offset) +
+	                   sizeof(ctlx->outbuf.wmemreq.page) +
+	                   len;
+
+	ctlx->reapable = mode;
+	ctlx->cmdcb = cmdcb;
+	ctlx->usercb = usercb;
+	ctlx->usercb_data = usercb_data;
+
+	result = hfa384x_usbctlx_submit(hw, ctlx);
+	if (result != 0) {
+		kfree(ctlx);
+	} else if ( mode == DOWAIT ) {
+                usbctlx_wmem_completor_t completor;
+                hfa384x_cmdresult_t wmemresult;
+
+                result = hfa384x_usbctlx_complete_sync(
+                               hw,
+                               ctlx,
+                               init_wmem_completor(&completor,
+                                                   &ctlx->inbuf.wmemresp,
+                                                   &wmemresult) );
+	}
+
+done:
+	DBFEXIT;
+	return result;
+}
+
+
+/*----------------------------------------------------------------
+* hfa384x_drvr_commtallies
+*
+* Send a commtallies inquiry to the MAC.  Note that this is an async
+* call that will result in an info frame arriving sometime later.
+*
+* Arguments:
+*	hw		device structure
+*
+* Returns:
+*	zero		success.
+*
+* Side effects:
+*
+* Call context:
+*	process
+----------------------------------------------------------------*/
+int hfa384x_drvr_commtallies( hfa384x_t *hw )
+{
+	hfa384x_metacmd_t cmd;
+
+	DBFENTER;
+
+	cmd.cmd = HFA384x_CMDCODE_INQ;
+	cmd.parm0 = HFA384x_IT_COMMTALLIES;
+	cmd.parm1 = 0;
+	cmd.parm2 = 0;
+
+	hfa384x_docmd_async(hw, &cmd, NULL, NULL, NULL);
+
+	DBFEXIT;
+	return 0;
+}
+
+
+/*----------------------------------------------------------------
+* hfa384x_drvr_disable
+*
+* Issues the disable command to stop communications on one of
+* the MACs 'ports'.  Only macport 0 is valid  for stations.
+* APs may also disable macports 1-6.  Only ports that have been
+* previously enabled may be disabled.
+*
+* Arguments:
+*	hw		device structure
+*	macport		MAC port number (host order)
+*
+* Returns:
+*	0		success
+*	>0		f/w reported failure - f/w status code
+*	<0		driver reported error (timeout|bad arg)
+*
+* Side effects:
+*
+* Call context:
+*	process
+----------------------------------------------------------------*/
+int hfa384x_drvr_disable(hfa384x_t *hw, UINT16 macport)
+{
+	int	result = 0;
+
+	DBFENTER;
+	if ((!hw->isap && macport != 0) ||
+	    (hw->isap && !(macport <= HFA384x_PORTID_MAX)) ||
+	    !(hw->port_enabled[macport]) ){
+		result = -EINVAL;
+	} else {
+		result = hfa384x_cmd_disable(hw, macport);
+		if ( result == 0 ) {
+			hw->port_enabled[macport] = 0;
+		}
+	}
+	DBFEXIT;
+	return result;
+}
+
+
+/*----------------------------------------------------------------
+* hfa384x_drvr_enable
+*
+* Issues the enable command to enable communications on one of
+* the MACs 'ports'.  Only macport 0 is valid  for stations.
+* APs may also enable macports 1-6.  Only ports that are currently
+* disabled may be enabled.
+*
+* Arguments:
+*	hw		device structure
+*	macport		MAC port number
+*
+* Returns:
+*	0		success
+*	>0		f/w reported failure - f/w status code
+*	<0		driver reported error (timeout|bad arg)
+*
+* Side effects:
+*
+* Call context:
+*	process
+----------------------------------------------------------------*/
+int hfa384x_drvr_enable(hfa384x_t *hw, UINT16 macport)
+{
+	int	result = 0;
+
+	DBFENTER;
+	if ((!hw->isap && macport != 0) ||
+	    (hw->isap && !(macport <= HFA384x_PORTID_MAX)) ||
+	    (hw->port_enabled[macport]) ){
+		result = -EINVAL;
+	} else {
+		result = hfa384x_cmd_enable(hw, macport);
+		if ( result == 0 ) {
+			hw->port_enabled[macport] = 1;
+		}
+	}
+	DBFEXIT;
+	return result;
+}
+
+
+/*----------------------------------------------------------------
+* hfa384x_drvr_flashdl_enable
+*
+* Begins the flash download state.  Checks to see that we're not
+* already in a download state and that a port isn't enabled.
+* Sets the download state and retrieves the flash download
+* buffer location, buffer size, and timeout length.
+*
+* Arguments:
+*	hw		device structure
+*
+* Returns:
+*	0		success
+*	>0		f/w reported error - f/w status code
+*	<0		driver reported error
+*
+* Side effects:
+*
+* Call context:
+*	process
+----------------------------------------------------------------*/
+int hfa384x_drvr_flashdl_enable(hfa384x_t *hw)
+{
+	int		result = 0;
+	int		i;
+
+	DBFENTER;
+	/* Check that a port isn't active */
+	for ( i = 0; i < HFA384x_PORTID_MAX; i++) {
+		if ( hw->port_enabled[i] ) {
+			WLAN_LOG_DEBUG(1,"called when port enabled.\n");
+			return -EINVAL;
+		}
+	}
+
+	/* Check that we're not already in a download state */
+	if ( hw->dlstate != HFA384x_DLSTATE_DISABLED ) {
+		return -EINVAL;
+	}
+
+	/* Retrieve the buffer loc&size and timeout */
+	if ( (result = hfa384x_drvr_getconfig(hw, HFA384x_RID_DOWNLOADBUFFER,
+				&(hw->bufinfo), sizeof(hw->bufinfo))) ) {
+		return result;
+	}
+	hw->bufinfo.page = hfa384x2host_16(hw->bufinfo.page);
+	hw->bufinfo.offset = hfa384x2host_16(hw->bufinfo.offset);
+	hw->bufinfo.len = hfa384x2host_16(hw->bufinfo.len);
+	if ( (result = hfa384x_drvr_getconfig16(hw, HFA384x_RID_MAXLOADTIME,
+				&(hw->dltimeout))) ) {
+		return result;
+	}
+	hw->dltimeout = hfa384x2host_16(hw->dltimeout);
+
+	WLAN_LOG_DEBUG(1,"flashdl_enable\n");
+
+	hw->dlstate = HFA384x_DLSTATE_FLASHENABLED;
+	DBFEXIT;
+	return result;
+}
+
+
+/*----------------------------------------------------------------
+* hfa384x_drvr_flashdl_disable
+*
+* Ends the flash download state.  Note that this will cause the MAC
+* firmware to restart.
+*
+* Arguments:
+*	hw		device structure
+*
+* Returns:
+*	0		success
+*	>0		f/w reported error - f/w status code
+*	<0		driver reported error
+*
+* Side effects:
+*
+* Call context:
+*	process
+----------------------------------------------------------------*/
+int hfa384x_drvr_flashdl_disable(hfa384x_t *hw)
+{
+	DBFENTER;
+	/* Check that we're already in the download state */
+	if ( hw->dlstate != HFA384x_DLSTATE_FLASHENABLED ) {
+		return -EINVAL;
+	}
+
+	WLAN_LOG_DEBUG(1,"flashdl_enable\n");
+
+	/* There isn't much we can do at this point, so I don't */
+	/*  bother  w/ the return value */
+	hfa384x_cmd_download(hw, HFA384x_PROGMODE_DISABLE, 0, 0 , 0);
+	hw->dlstate = HFA384x_DLSTATE_DISABLED;
+
+	DBFEXIT;
+	return 0;
+}
+
+
+/*----------------------------------------------------------------
+* hfa384x_drvr_flashdl_write
+*
+* Performs a FLASH download of a chunk of data. First checks to see
+* that we're in the FLASH download state, then sets the download
+* mode, uses the aux functions to 1) copy the data to the flash
+* buffer, 2) sets the download 'write flash' mode, 3) readback and
+* compare.  Lather rinse, repeat as many times an necessary to get
+* all the given data into flash.
+* When all data has been written using this function (possibly
+* repeatedly), call drvr_flashdl_disable() to end the download state
+* and restart the MAC.
+*
+* Arguments:
+*	hw		device structure
+*	daddr		Card address to write to. (host order)
+*	buf		Ptr to data to write.
+*	len		Length of data (host order).
+*
+* Returns:
+*	0		success
+*	>0		f/w reported error - f/w status code
+*	<0		driver reported error
+*
+* Side effects:
+*
+* Call context:
+*	process
+----------------------------------------------------------------*/
+int
+hfa384x_drvr_flashdl_write(
+	hfa384x_t	*hw,
+	UINT32		daddr,
+	void		*buf,
+	UINT32		len)
+{
+	int		result = 0;
+	UINT32		dlbufaddr;
+	int		nburns;
+	UINT32		burnlen;
+	UINT32		burndaddr;
+	UINT16		burnlo;
+	UINT16		burnhi;
+	int		nwrites;
+	UINT8		*writebuf;
+	UINT16		writepage;
+	UINT16		writeoffset;
+	UINT32		writelen;
+	int		i;
+	int		j;
+
+	DBFENTER;
+	WLAN_LOG_DEBUG(5,"daddr=0x%08x len=%d\n", daddr, len);
+
+	/* Check that we're in the flash download state */
+	if ( hw->dlstate != HFA384x_DLSTATE_FLASHENABLED ) {
+		return -EINVAL;
+	}
+
+	WLAN_LOG_INFO("Download %d bytes to flash @0x%06x\n", len, daddr);
+
+	/* Convert to flat address for arithmetic */
+	/* NOTE: dlbuffer RID stores the address in AUX format */
+	dlbufaddr = HFA384x_ADDR_AUX_MKFLAT(
+			hw->bufinfo.page, hw->bufinfo.offset);
+	WLAN_LOG_DEBUG(5,
+		"dlbuf.page=0x%04x dlbuf.offset=0x%04x dlbufaddr=0x%08x\n",
+		hw->bufinfo.page, hw->bufinfo.offset, dlbufaddr);
+
+#if 0
+WLAN_LOG_WARNING("dlbuf@0x%06lx len=%d to=%d\n", dlbufaddr, hw->bufinfo.len, hw->dltimeout);
+#endif
+	/* Calculations to determine how many fills of the dlbuffer to do
+	 * and how many USB wmemreq's to do for each fill.  At this point
+	 * in time, the dlbuffer size and the wmemreq size are the same.
+	 * Therefore, nwrites should always be 1.  The extra complexity
+	 * here is a hedge against future changes.
+	 */
+
+	/* Figure out how many times to do the flash programming */
+	nburns = len / hw->bufinfo.len;
+	nburns += (len % hw->bufinfo.len) ? 1 : 0;
+
+	/* For each flash program cycle, how many USB wmemreq's are needed? */
+	nwrites = hw->bufinfo.len / HFA384x_USB_RWMEM_MAXLEN;
+	nwrites += (hw->bufinfo.len % HFA384x_USB_RWMEM_MAXLEN) ? 1 : 0;
+
+	/* For each burn */
+	for ( i = 0; i < nburns; i++) {
+		/* Get the dest address and len */
+		burnlen = (len - (hw->bufinfo.len * i)) > hw->bufinfo.len ?
+				hw->bufinfo.len :
+				(len - (hw->bufinfo.len * i));
+		burndaddr = daddr + (hw->bufinfo.len * i);
+		burnlo = HFA384x_ADDR_CMD_MKOFF(burndaddr);
+		burnhi = HFA384x_ADDR_CMD_MKPAGE(burndaddr);
+
+		WLAN_LOG_INFO("Writing %d bytes to flash @0x%06x\n",
+			burnlen, burndaddr);
+
+		/* Set the download mode */
+		result = hfa384x_cmd_download(hw, HFA384x_PROGMODE_NV,
+				burnlo, burnhi, burnlen);
+		if ( result ) {
+			WLAN_LOG_ERROR("download(NV,lo=%x,hi=%x,len=%x) "
+				"cmd failed, result=%d. Aborting d/l\n",
+				burnlo, burnhi, burnlen, result);
+			goto exit_proc;
+		}
+
+		/* copy the data to the flash download buffer */
+		for ( j=0; j < nwrites; j++) {
+			writebuf = buf +
+				(i*hw->bufinfo.len) +
+				(j*HFA384x_USB_RWMEM_MAXLEN);
+
+			writepage = HFA384x_ADDR_CMD_MKPAGE(
+					dlbufaddr +
+					(j*HFA384x_USB_RWMEM_MAXLEN));
+			writeoffset = HFA384x_ADDR_CMD_MKOFF(
+					dlbufaddr +
+					(j*HFA384x_USB_RWMEM_MAXLEN));
+
+			writelen = burnlen-(j*HFA384x_USB_RWMEM_MAXLEN);
+			writelen = writelen  > HFA384x_USB_RWMEM_MAXLEN ?
+					HFA384x_USB_RWMEM_MAXLEN :
+					writelen;
+
+			result = hfa384x_dowmem_wait( hw,
+					writepage,
+					writeoffset,
+					writebuf,
+					writelen );
+#if 0
+
+Comment out for debugging, assume the write was successful.
+			if (result) {
+				WLAN_LOG_ERROR(
+					"Write to dl buffer failed, "
+					"result=0x%04x. Aborting.\n",
+					result);
+				goto exit_proc;
+			}
+#endif
+
+		}
+
+		/* set the download 'write flash' mode */
+		result = hfa384x_cmd_download(hw,
+				HFA384x_PROGMODE_NVWRITE,
+				0,0,0);
+		if ( result ) {
+			WLAN_LOG_ERROR(
+				"download(NVWRITE,lo=%x,hi=%x,len=%x) "
+				"cmd failed, result=%d. Aborting d/l\n",
+				burnlo, burnhi, burnlen, result);
+			goto exit_proc;
+		}
+
+		/* TODO: We really should do a readback and compare. */
+	}
+
+exit_proc:
+
+	/* Leave the firmware in the 'post-prog' mode.  flashdl_disable will */
+	/*  actually disable programming mode.  Remember, that will cause the */
+	/*  the firmware to effectively reset itself. */
+
+	DBFEXIT;
+	return result;
+}
+
+
+/*----------------------------------------------------------------
+* hfa384x_drvr_getconfig
+*
+* Performs the sequence necessary to read a config/info item.
+*
+* Arguments:
+*	hw		device structure
+*	rid		config/info record id (host order)
+*	buf		host side record buffer.  Upon return it will
+*			contain the body portion of the record (minus the
+*			RID and len).
+*	len		buffer length (in bytes, should match record length)
+*
+* Returns:
+*	0		success
+*	>0		f/w reported error - f/w status code
+*	<0		driver reported error
+*	-ENODATA 	length mismatch between argument and retrieved
+*			record.
+*
+* Side effects:
+*
+* Call context:
+*	process
+----------------------------------------------------------------*/
+int hfa384x_drvr_getconfig(hfa384x_t *hw, UINT16 rid, void *buf, UINT16 len)
+{
+	int 			result;
+	DBFENTER;
+
+	result = hfa384x_dorrid_wait(hw, rid, buf, len);
+
+	DBFEXIT;
+	return result;
+}
+
+/*----------------------------------------------------------------
+ * hfa384x_drvr_getconfig_async
+ *
+ * Performs the sequence necessary to perform an async read of
+ * of a config/info item.
+ *
+ * Arguments:
+ *       hw              device structure
+ *       rid             config/info record id (host order)
+ *       buf             host side record buffer.  Upon return it will
+ *                       contain the body portion of the record (minus the
+ *                       RID and len).
+ *       len             buffer length (in bytes, should match record length)
+ *       cbfn            caller supplied callback, called when the command
+ *                       is done (successful or not).
+ *       cbfndata        pointer to some caller supplied data that will be
+ *                       passed in as an argument to the cbfn.
+ *
+ * Returns:
+ *       nothing         the cbfn gets a status argument identifying if
+ *                       any errors occur.
+ * Side effects:
+ *       Queues an hfa384x_usbcmd_t for subsequent execution.
+ *
+ * Call context:
+ *       Any
+ ----------------------------------------------------------------*/
+int
+hfa384x_drvr_getconfig_async(
+         hfa384x_t               *hw,
+         UINT16                  rid,
+         ctlx_usercb_t           usercb,
+         void                    *usercb_data)
+{
+         return hfa384x_dorrid_async(hw, rid, NULL, 0,
+				     hfa384x_cb_rrid, usercb, usercb_data);
+}
+
+/*----------------------------------------------------------------
+ * hfa384x_drvr_setconfig_async
+ *
+ * Performs the sequence necessary to write a config/info item.
+ *
+ * Arguments:
+ *       hw              device structure
+ *       rid             config/info record id (in host order)
+ *       buf             host side record buffer
+ *       len             buffer length (in bytes)
+ *       usercb          completion callback
+ *       usercb_data     completion callback argument
+ *
+ * Returns:
+ *       0               success
+ *       >0              f/w reported error - f/w status code
+ *       <0              driver reported error
+ *
+ * Side effects:
+ *
+ * Call context:
+ *       process
+ ----------------------------------------------------------------*/
+int
+hfa384x_drvr_setconfig_async(
+         hfa384x_t       *hw,
+         UINT16          rid,
+         void            *buf,
+         UINT16          len,
+         ctlx_usercb_t   usercb,
+         void            *usercb_data)
+{
+	return hfa384x_dowrid_async(hw, rid, buf, len,
+				    hfa384x_cb_status, usercb, usercb_data);
+}
+
+/*----------------------------------------------------------------
+* hfa384x_drvr_handover
+*
+* Sends a handover notification to the MAC.
+*
+* Arguments:
+*	hw		device structure
+*	addr		address of station that's left
+*
+* Returns:
+*	zero		success.
+*	-ERESTARTSYS	received signal while waiting for semaphore.
+*	-EIO		failed to write to bap, or failed in cmd.
+*
+* Side effects:
+*
+* Call context:
+*	process
+----------------------------------------------------------------*/
+int hfa384x_drvr_handover( hfa384x_t *hw, UINT8 *addr)
+{
+        DBFENTER;
+	WLAN_LOG_ERROR("Not currently supported in USB!\n");
+	DBFEXIT;
+	return -EIO;
+}
+
+/*----------------------------------------------------------------
+* hfa384x_drvr_low_level
+*
+* Write test commands to the card.  Some test commands don't make
+* sense without prior set-up.  For example, continous TX isn't very
+* useful until you set the channel.  That functionality should be
+*
+* Side effects:
+*
+* Call context:
+*      process thread
+* -----------------------------------------------------------------*/
+int hfa384x_drvr_low_level(hfa384x_t *hw, hfa384x_metacmd_t *cmd)
+{
+	int             result;
+	DBFENTER;
+
+	/* Do i need a host2hfa... conversion ? */
+
+	result = hfa384x_docmd_wait(hw, cmd);
+
+	DBFEXIT;
+	return result;
+}
+
+/*----------------------------------------------------------------
+* hfa384x_drvr_mmi_read
+*
+* Read mmi registers.  mmi is intersil-speak for the baseband
+* processor registers.
+*
+* Arguments:
+*       hw              device structure
+*       register        The test register to be accessed (must be even #).
+*
+* Returns:
+*       0               success
+*       >0              f/w reported error - f/w status code
+*       <0              driver reported error
+*
+* Side effects:
+*
+* Call context:
+*       process
+----------------------------------------------------------------*/
+int hfa384x_drvr_mmi_read(hfa384x_t *hw, UINT32 addr, UINT32 *resp)
+{
+#if 0
+        int             result = 0;
+        UINT16  cmd_code = (UINT16) 0x30;
+        UINT16 param = (UINT16) addr;
+        DBFENTER;
+
+        /* Do i need a host2hfa... conversion ? */
+        result = hfa384x_docmd_wait(hw, cmd_code);
+
+        DBFEXIT;
+        return result;
+#endif
+return 0;
+}
+
+/*----------------------------------------------------------------
+* hfa384x_drvr_mmi_write
+*
+* Read mmi registers.  mmi is intersil-speak for the baseband
+* processor registers.
+*
+* Arguments:
+*       hw              device structure
+*       addr            The test register to be accessed (must be even #).
+*       data            The data value to write to the register.
+*
+* Returns:
+*       0               success
+*       >0              f/w reported error - f/w status code
+*       <0              driver reported error
+*
+* Side effects:
+*
+* Call context:
+*       process
+----------------------------------------------------------------*/
+
+int
+hfa384x_drvr_mmi_write(hfa384x_t *hw, UINT32 addr, UINT32 data)
+{
+#if 0
+        int             result = 0;
+        UINT16  cmd_code = (UINT16) 0x31;
+        UINT16 param0 = (UINT16) addr;
+        UINT16 param1 = (UINT16) data;
+        DBFENTER;
+
+        WLAN_LOG_DEBUG(1,"mmi write : addr = 0x%08lx\n", addr);
+        WLAN_LOG_DEBUG(1,"mmi write : data = 0x%08lx\n", data);
+
+        /* Do i need a host2hfa... conversion ? */
+        result = hfa384x_docmd_wait(hw, cmd_code);
+
+        DBFEXIT;
+        return result;
+#endif
+return 0;
+}
+
+
+/*----------------------------------------------------------------
+* hfa384x_drvr_ramdl_disable
+*
+* Ends the ram download state.
+*
+* Arguments:
+*	hw		device structure
+*
+* Returns:
+*	0		success
+*	>0		f/w reported error - f/w status code
+*	<0		driver reported error
+*
+* Side effects:
+*
+* Call context:
+*	process
+----------------------------------------------------------------*/
+int
+hfa384x_drvr_ramdl_disable(hfa384x_t *hw)
+{
+	DBFENTER;
+	/* Check that we're already in the download state */
+	if ( hw->dlstate != HFA384x_DLSTATE_RAMENABLED ) {
+		return -EINVAL;
+	}
+
+	WLAN_LOG_DEBUG(3,"ramdl_disable()\n");
+
+	/* There isn't much we can do at this point, so I don't */
+	/*  bother  w/ the return value */
+	hfa384x_cmd_download(hw, HFA384x_PROGMODE_DISABLE, 0, 0 , 0);
+	hw->dlstate = HFA384x_DLSTATE_DISABLED;
+
+	DBFEXIT;
+	return 0;
+}
+
+
+/*----------------------------------------------------------------
+* hfa384x_drvr_ramdl_enable
+*
+* Begins the ram download state.  Checks to see that we're not
+* already in a download state and that a port isn't enabled.
+* Sets the download state and calls cmd_download with the
+* ENABLE_VOLATILE subcommand and the exeaddr argument.
+*
+* Arguments:
+*	hw		device structure
+*	exeaddr		the card execution address that will be
+*                       jumped to when ramdl_disable() is called
+*			(host order).
+*
+* Returns:
+*	0		success
+*	>0		f/w reported error - f/w status code
+*	<0		driver reported error
+*
+* Side effects:
+*
+* Call context:
+*	process
+----------------------------------------------------------------*/
+int
+hfa384x_drvr_ramdl_enable(hfa384x_t *hw, UINT32 exeaddr)
+{
+	int		result = 0;
+	UINT16		lowaddr;
+	UINT16		hiaddr;
+	int		i;
+	DBFENTER;
+	/* Check that a port isn't active */
+	for ( i = 0; i < HFA384x_PORTID_MAX; i++) {
+		if ( hw->port_enabled[i] ) {
+			WLAN_LOG_ERROR(
+				"Can't download with a macport enabled.\n");
+			return -EINVAL;
+		}
+	}
+
+	/* Check that we're not already in a download state */
+	if ( hw->dlstate != HFA384x_DLSTATE_DISABLED ) {
+		WLAN_LOG_ERROR(
+			"Download state not disabled.\n");
+		return -EINVAL;
+	}
+
+	WLAN_LOG_DEBUG(3,"ramdl_enable, exeaddr=0x%08x\n", exeaddr);
+
+	/* Call the download(1,addr) function */
+	lowaddr = HFA384x_ADDR_CMD_MKOFF(exeaddr);
+	hiaddr =  HFA384x_ADDR_CMD_MKPAGE(exeaddr);
+
+	result = hfa384x_cmd_download(hw, HFA384x_PROGMODE_RAM,
+			lowaddr, hiaddr, 0);
+
+	if ( result == 0) {
+		/* Set the download state */
+		hw->dlstate = HFA384x_DLSTATE_RAMENABLED;
+	} else {
+		WLAN_LOG_DEBUG(1,
+			"cmd_download(0x%04x, 0x%04x) failed, result=%d.\n",
+			lowaddr,
+			hiaddr,
+			result);
+	}
+
+	DBFEXIT;
+	return result;
+}
+
+
+/*----------------------------------------------------------------
+* hfa384x_drvr_ramdl_write
+*
+* Performs a RAM download of a chunk of data. First checks to see
+* that we're in the RAM download state, then uses the [read|write]mem USB
+* commands to 1) copy the data, 2) readback and compare.  The download
+* state is unaffected.  When all data has been written using
+* this function, call drvr_ramdl_disable() to end the download state
+* and restart the MAC.
+*
+* Arguments:
+*	hw		device structure
+*	daddr		Card address to write to. (host order)
+*	buf		Ptr to data to write.
+*	len		Length of data (host order).
+*
+* Returns:
+*	0		success
+*	>0		f/w reported error - f/w status code
+*	<0		driver reported error
+*
+* Side effects:
+*
+* Call context:
+*	process
+----------------------------------------------------------------*/
+int
+hfa384x_drvr_ramdl_write(hfa384x_t *hw, UINT32 daddr, void* buf, UINT32 len)
+{
+	int		result = 0;
+	int		nwrites;
+	UINT8		*data = buf;
+	int		i;
+	UINT32		curraddr;
+	UINT16		currpage;
+	UINT16		curroffset;
+	UINT16		currlen;
+	DBFENTER;
+	/* Check that we're in the ram download state */
+	if ( hw->dlstate != HFA384x_DLSTATE_RAMENABLED ) {
+		return -EINVAL;
+	}
+
+	WLAN_LOG_INFO("Writing %d bytes to ram @0x%06x\n", len, daddr);
+
+	/* How many dowmem calls?  */
+	nwrites = len / HFA384x_USB_RWMEM_MAXLEN;
+	nwrites += len % HFA384x_USB_RWMEM_MAXLEN ? 1 : 0;
+
+	/* Do blocking wmem's */
+	for(i=0; i < nwrites; i++) {
+		/* make address args */
+		curraddr = daddr + (i * HFA384x_USB_RWMEM_MAXLEN);
+		currpage = HFA384x_ADDR_CMD_MKPAGE(curraddr);
+		curroffset = HFA384x_ADDR_CMD_MKOFF(curraddr);
+		currlen = len - (i * HFA384x_USB_RWMEM_MAXLEN);
+		if ( currlen > HFA384x_USB_RWMEM_MAXLEN) {
+			currlen = HFA384x_USB_RWMEM_MAXLEN;
+		}
+
+	 	/* Do blocking ctlx */
+		result = hfa384x_dowmem_wait( hw,
+				currpage,
+				curroffset,
+				data + (i*HFA384x_USB_RWMEM_MAXLEN),
+				currlen );
+
+		if (result) break;
+
+		/* TODO: We really should have a readback. */
+	}
+
+	DBFEXIT;
+	return result;
+}
+
+
+/*----------------------------------------------------------------
+* hfa384x_drvr_readpda
+*
+* Performs the sequence to read the PDA space.  Note there is no
+* drvr_writepda() function.  Writing a PDA is
+* generally implemented by a calling component via calls to
+* cmd_download and writing to the flash download buffer via the
+* aux regs.
+*
+* Arguments:
+*	hw		device structure
+*	buf		buffer to store PDA in
+*	len		buffer length
+*
+* Returns:
+*	0		success
+*	>0		f/w reported error - f/w status code
+*	<0		driver reported error
+*	-ETIMEOUT	timout waiting for the cmd regs to become
+*			available, or waiting for the control reg
+*			to indicate the Aux port is enabled.
+*	-ENODATA	the buffer does NOT contain a valid PDA.
+*			Either the card PDA is bad, or the auxdata
+*			reads are giving us garbage.
+
+*
+* Side effects:
+*
+* Call context:
+*	process or non-card interrupt.
+----------------------------------------------------------------*/
+int hfa384x_drvr_readpda(hfa384x_t *hw, void *buf, UINT len)
+{
+	int		result = 0;
+	UINT16		*pda = buf;
+	int		pdaok = 0;
+	int		morepdrs = 1;
+	int		currpdr = 0;	/* word offset of the current pdr */
+	size_t		i;
+	UINT16		pdrlen;		/* pdr length in bytes, host order */
+	UINT16		pdrcode;	/* pdr code, host order */
+	UINT16		currpage;
+	UINT16		curroffset;
+	struct pdaloc {
+		UINT32	cardaddr;
+		UINT16	auxctl;
+	} pdaloc[] =
+	{
+		{ HFA3842_PDA_BASE,		0},
+		{ HFA3841_PDA_BASE,		0},
+		{ HFA3841_PDA_BOGUS_BASE,	0}
+	};
+
+	DBFENTER;
+
+	/* Read the pda from each known address.  */
+	for ( i = 0; i < ARRAY_SIZE(pdaloc); i++) {
+		/* Make address */
+		currpage = HFA384x_ADDR_CMD_MKPAGE(pdaloc[i].cardaddr);
+		curroffset = HFA384x_ADDR_CMD_MKOFF(pdaloc[i].cardaddr);
+
+		result = hfa384x_dormem_wait(hw,
+			currpage,
+			curroffset,
+			buf,
+			len);		/* units of bytes */
+
+		if (result) {
+			WLAN_LOG_WARNING(
+					  "Read from index %zd failed, continuing\n",
+				i );
+			continue;
+		}
+
+		/* Test for garbage */
+		pdaok = 1;	/* initially assume good */
+		morepdrs = 1;
+		while ( pdaok && morepdrs ) {
+			pdrlen = hfa384x2host_16(pda[currpdr]) * 2;
+			pdrcode = hfa384x2host_16(pda[currpdr+1]);
+			/* Test the record length */
+			if ( pdrlen > HFA384x_PDR_LEN_MAX || pdrlen == 0) {
+				WLAN_LOG_ERROR("pdrlen invalid=%d\n",
+					pdrlen);
+				pdaok = 0;
+				break;
+			}
+			/* Test the code */
+			if ( !hfa384x_isgood_pdrcode(pdrcode) ) {
+				WLAN_LOG_ERROR("pdrcode invalid=%d\n",
+					pdrcode);
+				pdaok = 0;
+				break;
+			}
+			/* Test for completion */
+			if ( pdrcode == HFA384x_PDR_END_OF_PDA) {
+				morepdrs = 0;
+			}
+
+			/* Move to the next pdr (if necessary) */
+			if ( morepdrs ) {
+				/* note the access to pda[], need words here */
+				currpdr += hfa384x2host_16(pda[currpdr]) + 1;
+			}
+		}
+		if ( pdaok ) {
+			WLAN_LOG_INFO(
+				"PDA Read from 0x%08x in %s space.\n",
+				pdaloc[i].cardaddr,
+				pdaloc[i].auxctl == 0 ? "EXTDS" :
+				pdaloc[i].auxctl == 1 ? "NV" :
+				pdaloc[i].auxctl == 2 ? "PHY" :
+				pdaloc[i].auxctl == 3 ? "ICSRAM" :
+				"<bogus auxctl>");
+			break;
+		}
+	}
+	result = pdaok ? 0 : -ENODATA;
+
+	if ( result ) {
+		WLAN_LOG_DEBUG(3,"Failure: pda is not okay\n");
+	}
+
+	DBFEXIT;
+	return result;
+}
+
+
+/*----------------------------------------------------------------
+* hfa384x_drvr_setconfig
+*
+* Performs the sequence necessary to write a config/info item.
+*
+* Arguments:
+*	hw		device structure
+*	rid		config/info record id (in host order)
+*	buf		host side record buffer
+*	len		buffer length (in bytes)
+*
+* Returns:
+*	0		success
+*	>0		f/w reported error - f/w status code
+*	<0		driver reported error
+*
+* Side effects:
+*
+* Call context:
+*	process
+----------------------------------------------------------------*/
+int hfa384x_drvr_setconfig(hfa384x_t *hw, UINT16 rid, void *buf, UINT16 len)
+{
+	return hfa384x_dowrid_wait(hw, rid, buf, len);
+}
+
+/*----------------------------------------------------------------
+* hfa384x_drvr_start
+*
+* Issues the MAC initialize command, sets up some data structures,
+* and enables the interrupts.  After this function completes, the
+* low-level stuff should be ready for any/all commands.
+*
+* Arguments:
+*	hw		device structure
+* Returns:
+*	0		success
+*	>0		f/w reported error - f/w status code
+*	<0		driver reported error
+*
+* Side effects:
+*
+* Call context:
+*	process
+----------------------------------------------------------------*/
+int hfa384x_drvr_start(hfa384x_t *hw)
+{
+	int		result;
+	DBFENTER;
+
+	might_sleep();
+
+	if (usb_clear_halt(hw->usb, hw->endp_in)) {
+		WLAN_LOG_ERROR(
+			"Failed to reset bulk in endpoint.\n");
+	}
+
+	if (usb_clear_halt(hw->usb, hw->endp_out)) {
+		WLAN_LOG_ERROR(
+			"Failed to reset bulk out endpoint.\n");
+	}
+
+	/* Synchronous unlink, in case we're trying to restart the driver */
+	usb_kill_urb(&hw->rx_urb);
+
+	/* Post the IN urb */
+	result = submit_rx_urb(hw, GFP_KERNEL);
+	if (result != 0) {
+		WLAN_LOG_ERROR(
+			"Fatal, failed to submit RX URB, result=%d\n",
+			result);
+		goto done;
+	}
+
+	/* call initialize */
+	result = hfa384x_cmd_initialize(hw);
+	if (result != 0) {
+		usb_kill_urb(&hw->rx_urb);
+		WLAN_LOG_ERROR(
+			"cmd_initialize() failed, result=%d\n",
+			result);
+		goto done;
+	}
+
+	hw->state = HFA384x_STATE_RUNNING;
+
+done:
+	DBFEXIT;
+	return result;
+}
+
+
+/*----------------------------------------------------------------
+* hfa384x_drvr_stop
+*
+* Shuts down the MAC to the point where it is safe to unload the
+* driver.  Any subsystem that may be holding a data or function
+* ptr into the driver must be cleared/deinitialized.
+*
+* Arguments:
+*	hw		device structure
+* Returns:
+*	0		success
+*	>0		f/w reported error - f/w status code
+*	<0		driver reported error
+*
+* Side effects:
+*
+* Call context:
+*	process
+----------------------------------------------------------------*/
+int
+hfa384x_drvr_stop(hfa384x_t *hw)
+{
+	int	result = 0;
+	int	i;
+	DBFENTER;
+
+	might_sleep();
+
+	/* There's no need for spinlocks here. The USB "disconnect"
+	 * function sets this "removed" flag and then calls us.
+	 */
+	if ( !hw->wlandev->hwremoved ) {
+		/* Call initialize to leave the MAC in its 'reset' state */
+		hfa384x_cmd_initialize(hw);
+
+		/* Cancel the rxurb */
+		usb_kill_urb(&hw->rx_urb);
+	}
+
+	hw->link_status = HFA384x_LINK_NOTCONNECTED;
+	hw->state = HFA384x_STATE_INIT;
+
+	del_timer_sync(&hw->commsqual_timer);
+
+	/* Clear all the port status */
+	for ( i = 0; i < HFA384x_NUMPORTS_MAX; i++) {
+		hw->port_enabled[i] = 0;
+	}
+
+	DBFEXIT;
+	return result;
+}
+
+/*----------------------------------------------------------------
+* hfa384x_drvr_txframe
+*
+* Takes a frame from prism2sta and queues it for transmission.
+*
+* Arguments:
+*	hw		device structure
+*	skb		packet buffer struct.  Contains an 802.11
+*			data frame.
+*       p80211_hdr      points to the 802.11 header for the packet.
+* Returns:
+*	0		Success and more buffs available
+*	1		Success but no more buffs
+*	2		Allocation failure
+*	4		Buffer full or queue busy
+*
+* Side effects:
+*
+* Call context:
+*	interrupt
+----------------------------------------------------------------*/
+int hfa384x_drvr_txframe(hfa384x_t *hw, struct sk_buff *skb, p80211_hdr_t *p80211_hdr, p80211_metawep_t *p80211_wep)
+
+{
+	int		usbpktlen = sizeof(hfa384x_tx_frame_t);
+	int		result;
+	int		ret;
+	char		*ptr;
+
+	DBFENTER;
+
+	if (hw->tx_urb.status == -EINPROGRESS) {
+		WLAN_LOG_WARNING("TX URB already in use\n");
+		result = 3;
+		goto exit;
+	}
+
+	/* Build Tx frame structure */
+	/* Set up the control field */
+	memset(&hw->txbuff.txfrm.desc, 0, sizeof(hw->txbuff.txfrm.desc));
+
+	/* Setup the usb type field */
+	hw->txbuff.type = host2hfa384x_16(HFA384x_USB_TXFRM);
+
+	/* Set up the sw_support field to identify this frame */
+	hw->txbuff.txfrm.desc.sw_support = 0x0123;
+
+/* Tx complete and Tx exception disable per dleach.  Might be causing
+ * buf depletion
+ */
+//#define DOEXC  SLP -- doboth breaks horribly under load, doexc less so.
+#if defined(DOBOTH)
+	hw->txbuff.txfrm.desc.tx_control =
+		HFA384x_TX_MACPORT_SET(0) | HFA384x_TX_STRUCTYPE_SET(1) |
+		HFA384x_TX_TXEX_SET(1) | HFA384x_TX_TXOK_SET(1);
+#elif defined(DOEXC)
+	hw->txbuff.txfrm.desc.tx_control =
+		HFA384x_TX_MACPORT_SET(0) | HFA384x_TX_STRUCTYPE_SET(1) |
+		HFA384x_TX_TXEX_SET(1) | HFA384x_TX_TXOK_SET(0);
+#else
+	hw->txbuff.txfrm.desc.tx_control =
+		HFA384x_TX_MACPORT_SET(0) | HFA384x_TX_STRUCTYPE_SET(1) |
+		HFA384x_TX_TXEX_SET(0) | HFA384x_TX_TXOK_SET(0);
+#endif
+	hw->txbuff.txfrm.desc.tx_control =
+		host2hfa384x_16(hw->txbuff.txfrm.desc.tx_control);
+
+	/* copy the header over to the txdesc */
+	memcpy(&(hw->txbuff.txfrm.desc.frame_control), p80211_hdr, sizeof(p80211_hdr_t));
+
+	/* if we're using host WEP, increase size by IV+ICV */
+	if (p80211_wep->data) {
+		hw->txbuff.txfrm.desc.data_len = host2hfa384x_16(skb->len+8);
+		// hw->txbuff.txfrm.desc.tx_control |= HFA384x_TX_NOENCRYPT_SET(1);
+		usbpktlen+=8;
+	} else {
+		hw->txbuff.txfrm.desc.data_len = host2hfa384x_16(skb->len);
+	}
+
+	usbpktlen += skb->len;
+
+	/* copy over the WEP IV if we are using host WEP */
+	ptr = hw->txbuff.txfrm.data;
+	if (p80211_wep->data) {
+		memcpy(ptr, p80211_wep->iv, sizeof(p80211_wep->iv));
+		ptr+= sizeof(p80211_wep->iv);
+		memcpy(ptr, p80211_wep->data, skb->len);
+	} else {
+		memcpy(ptr, skb->data, skb->len);
+	}
+	/* copy over the packet data */
+	ptr+= skb->len;
+
+	/* copy over the WEP ICV if we are using host WEP */
+	if (p80211_wep->data) {
+		memcpy(ptr, p80211_wep->icv, sizeof(p80211_wep->icv));
+	}
+
+	/* Send the USB packet */
+	usb_fill_bulk_urb( &(hw->tx_urb), hw->usb,
+	               hw->endp_out,
+	               &(hw->txbuff), ROUNDUP64(usbpktlen),
+	               hfa384x_usbout_callback, hw->wlandev );
+	hw->tx_urb.transfer_flags |= USB_QUEUE_BULK;
+
+	result = 1;
+	ret = submit_tx_urb(hw, &hw->tx_urb, GFP_ATOMIC);
+	if ( ret != 0 ) {
+		WLAN_LOG_ERROR(
+			"submit_tx_urb() failed, error=%d\n", ret);
+		result = 3;
+	}
+
+ exit:
+	DBFEXIT;
+	return result;
+}
+
+void hfa384x_tx_timeout(wlandevice_t *wlandev)
+{
+	hfa384x_t	*hw = wlandev->priv;
+	unsigned long flags;
+
+	DBFENTER;
+
+	spin_lock_irqsave(&hw->ctlxq.lock, flags);
+
+	if ( !hw->wlandev->hwremoved &&
+	     /* Note the bitwise OR, not the logical OR. */
+	     ( !test_and_set_bit(WORK_TX_HALT, &hw->usb_flags) |
+	       !test_and_set_bit(WORK_RX_HALT, &hw->usb_flags) ) )
+	{
+		schedule_work(&hw->usb_work);
+	}
+
+	spin_unlock_irqrestore(&hw->ctlxq.lock, flags);
+
+	DBFEXIT;
+}
+
+/*----------------------------------------------------------------
+* hfa384x_usbctlx_reaper_task
+*
+* Tasklet to delete dead CTLX objects
+*
+* Arguments:
+*	data	ptr to a hfa384x_t
+*
+* Returns:
+*
+* Call context:
+*	Interrupt
+----------------------------------------------------------------*/
+static void hfa384x_usbctlx_reaper_task(unsigned long data)
+{
+	hfa384x_t	*hw = (hfa384x_t*)data;
+	struct list_head *entry;
+	struct list_head *temp;
+	unsigned long	flags;
+
+	DBFENTER;
+
+	spin_lock_irqsave(&hw->ctlxq.lock, flags);
+
+	/* This list is guaranteed to be empty if someone
+	 * has unplugged the adapter.
+	 */
+	list_for_each_safe(entry, temp, &hw->ctlxq.reapable) {
+		hfa384x_usbctlx_t	*ctlx;
+
+		ctlx = list_entry(entry, hfa384x_usbctlx_t, list);
+		list_del(&ctlx->list);
+		kfree(ctlx);
+	}
+
+	spin_unlock_irqrestore(&hw->ctlxq.lock, flags);
+
+	DBFEXIT;
+}
+
+/*----------------------------------------------------------------
+* hfa384x_usbctlx_completion_task
+*
+* Tasklet to call completion handlers for returned CTLXs
+*
+* Arguments:
+*	data	ptr to hfa384x_t
+*
+* Returns:
+*	Nothing
+*
+* Call context:
+*	Interrupt
+----------------------------------------------------------------*/
+static void hfa384x_usbctlx_completion_task(unsigned long data)
+{
+	hfa384x_t *hw = (hfa384x_t*)data;
+	struct list_head *entry;
+	struct list_head *temp;
+	unsigned long flags;
+
+	int reap = 0;
+
+	DBFENTER;
+
+	spin_lock_irqsave(&hw->ctlxq.lock, flags);
+
+	/* This list is guaranteed to be empty if someone
+	 * has unplugged the adapter ...
+	 */
+	list_for_each_safe(entry, temp, &hw->ctlxq.completing) {
+		hfa384x_usbctlx_t *ctlx;
+
+		ctlx = list_entry(entry, hfa384x_usbctlx_t, list);
+
+		/* Call the completion function that this
+		 * command was assigned, assuming it has one.
+		 */
+		if ( ctlx->cmdcb != NULL ) {
+			spin_unlock_irqrestore(&hw->ctlxq.lock, flags);
+			ctlx->cmdcb(hw, ctlx);
+			spin_lock_irqsave(&hw->ctlxq.lock, flags);
+
+			/* Make sure we don't try and complete
+			 * this CTLX more than once!
+			 */
+			ctlx->cmdcb = NULL;
+
+			/* Did someone yank the adapter out
+			 * while our list was (briefly) unlocked?
+			 */
+			if ( hw->wlandev->hwremoved )
+			{
+				reap = 0;
+				break;
+			}
+		}
+
+		/*
+		 * "Reapable" CTLXs are ones which don't have any
+		 * threads waiting for them to die. Hence they must
+		 * be delivered to The Reaper!
+		 */
+		if ( ctlx->reapable ) {
+			/* Move the CTLX off the "completing" list (hopefully)
+			 * on to the "reapable" list where the reaper task
+			 * can find it. And "reapable" means that this CTLX
+			 * isn't sitting on a wait-queue somewhere.
+			 */
+			list_move_tail(&ctlx->list, &hw->ctlxq.reapable);
+			reap = 1;
+		}
+
+		complete(&ctlx->done);
+	}
+	spin_unlock_irqrestore(&hw->ctlxq.lock, flags);
+
+	if (reap)
+		tasklet_schedule(&hw->reaper_bh);
+
+	DBFEXIT;
+}
+
+/*----------------------------------------------------------------
+* unlocked_usbctlx_cancel_async
+*
+* Mark the CTLX dead asynchronously, and ensure that the
+* next command on the queue is run afterwards.
+*
+* Arguments:
+*	hw	ptr to the hfa384x_t structure
+*	ctlx	ptr to a CTLX structure
+*
+* Returns:
+*	0	the CTLX's URB is inactive
+* -EINPROGRESS	the URB is currently being unlinked
+*
+* Call context:
+*	Either process or interrupt, but presumably interrupt
+----------------------------------------------------------------*/
+static int unlocked_usbctlx_cancel_async(hfa384x_t *hw, hfa384x_usbctlx_t *ctlx)
+{
+	int ret;
+
+	DBFENTER;
+
+	/*
+	 * Try to delete the URB containing our request packet.
+	 * If we succeed, then its completion handler will be
+	 * called with a status of -ECONNRESET.
+	 */
+	hw->ctlx_urb.transfer_flags |= URB_ASYNC_UNLINK;
+	ret = usb_unlink_urb(&hw->ctlx_urb);
+
+	if (ret != -EINPROGRESS) {
+		/*
+		 * The OUT URB had either already completed
+		 * or was still in the pending queue, so the
+		 * URB's completion function will not be called.
+		 * We will have to complete the CTLX ourselves.
+		 */
+		ctlx->state = CTLX_REQ_FAILED;
+		unlocked_usbctlx_complete(hw, ctlx);
+		ret = 0;
+	}
+
+	DBFEXIT;
+
+	return ret;
+}
+
+/*----------------------------------------------------------------
+* unlocked_usbctlx_complete
+*
+* A CTLX has completed.  It may have been successful, it may not
+* have been. At this point, the CTLX should be quiescent.  The URBs
+* aren't active and the timers should have been stopped.
+*
+* The CTLX is migrated to the "completing" queue, and the completing
+* tasklet is scheduled.
+*
+* Arguments:
+*	hw		ptr to a hfa384x_t structure
+*	ctlx		ptr to a ctlx structure
+*
+* Returns:
+*	nothing
+*
+* Side effects:
+*
+* Call context:
+*	Either, assume interrupt
+----------------------------------------------------------------*/
+static void unlocked_usbctlx_complete(hfa384x_t *hw, hfa384x_usbctlx_t *ctlx)
+{
+	DBFENTER;
+
+	/* Timers have been stopped, and ctlx should be in
+	 * a terminal state. Retire it from the "active"
+	 * queue.
+	 */
+	list_move_tail(&ctlx->list, &hw->ctlxq.completing);
+	tasklet_schedule(&hw->completion_bh);
+
+	switch (ctlx->state) {
+	case CTLX_COMPLETE:
+	case CTLX_REQ_FAILED:
+		/* This are the correct terminating states. */
+		break;
+
+	default:
+		WLAN_LOG_ERROR("CTLX[%d] not in a terminating state(%s)\n",
+		               hfa384x2host_16(ctlx->outbuf.type),
+		               ctlxstr(ctlx->state));
+		break;
+	} /* switch */
+
+	DBFEXIT;
+}
+
+/*----------------------------------------------------------------
+* hfa384x_usbctlxq_run
+*
+* Checks to see if the head item is running.  If not, starts it.
+*
+* Arguments:
+*	hw	ptr to hfa384x_t
+*
+* Returns:
+*	nothing
+*
+* Side effects:
+*
+* Call context:
+*	any
+----------------------------------------------------------------*/
+static void
+hfa384x_usbctlxq_run(hfa384x_t	*hw)
+{
+	unsigned long		flags;
+	DBFENTER;
+
+	/* acquire lock */
+	spin_lock_irqsave(&hw->ctlxq.lock, flags);
+
+	/* Only one active CTLX at any one time, because there's no
+	 * other (reliable) way to match the response URB to the
+	 * correct CTLX.
+	 *
+	 * Don't touch any of these CTLXs if the hardware
+	 * has been removed or the USB subsystem is stalled.
+	 */
+	if ( !list_empty(&hw->ctlxq.active) ||
+	     test_bit(WORK_TX_HALT, &hw->usb_flags) ||
+	     hw->wlandev->hwremoved )
+		goto unlock;
+
+	while ( !list_empty(&hw->ctlxq.pending) ) {
+		hfa384x_usbctlx_t	*head;
+		int			result;
+
+		/* This is the first pending command */
+		head = list_entry(hw->ctlxq.pending.next,
+		                  hfa384x_usbctlx_t,
+		                  list);
+
+		/* We need to split this off to avoid a race condition */
+		list_move_tail(&head->list, &hw->ctlxq.active);
+
+		/* Fill the out packet */
+		usb_fill_bulk_urb( &(hw->ctlx_urb), hw->usb,
+		                   hw->endp_out,
+		                   &(head->outbuf), ROUNDUP64(head->outbufsize),
+		                   hfa384x_ctlxout_callback, hw);
+		hw->ctlx_urb.transfer_flags |= USB_QUEUE_BULK;
+
+		/* Now submit the URB and update the CTLX's state
+		 */
+		if ((result = SUBMIT_URB(&hw->ctlx_urb, GFP_ATOMIC)) == 0) {
+			/* This CTLX is now running on the active queue */
+			head->state = CTLX_REQ_SUBMITTED;
+
+			/* Start the OUT wait timer */
+			hw->req_timer_done = 0;
+			hw->reqtimer.expires = jiffies + HZ;
+			add_timer(&hw->reqtimer);
+
+			/* Start the IN wait timer */
+			hw->resp_timer_done = 0;
+			hw->resptimer.expires = jiffies + 2*HZ;
+			add_timer(&hw->resptimer);
+
+			break;
+		}
+
+		if (result == -EPIPE) {
+			/* The OUT pipe needs resetting, so put
+			 * this CTLX back in the "pending" queue
+			 * and schedule a reset ...
+			 */
+			WLAN_LOG_WARNING("%s tx pipe stalled: requesting reset\n",
+			                 hw->wlandev->netdev->name);
+			list_move(&head->list, &hw->ctlxq.pending);
+			set_bit(WORK_TX_HALT, &hw->usb_flags);
+			schedule_work(&hw->usb_work);
+			break;
+		}
+
+		if (result == -ESHUTDOWN) {
+			WLAN_LOG_WARNING("%s urb shutdown!\n",
+					 hw->wlandev->netdev->name);
+			break;
+		}
+
+		WLAN_LOG_ERROR("Failed to submit CTLX[%d]: error=%d\n",
+		               hfa384x2host_16(head->outbuf.type), result);
+		unlocked_usbctlx_complete(hw, head);
+	} /* while */
+
+	unlock:
+	spin_unlock_irqrestore(&hw->ctlxq.lock, flags);
+
+	DBFEXIT;
+}
+
+
+/*----------------------------------------------------------------
+* hfa384x_usbin_callback
+*
+* Callback for URBs on the BULKIN endpoint.
+*
+* Arguments:
+*	urb		ptr to the completed urb
+*
+* Returns:
+*	nothing
+*
+* Side effects:
+*
+* Call context:
+*	interrupt
+----------------------------------------------------------------*/
+#ifdef URB_ONLY_CALLBACK
+static void hfa384x_usbin_callback(struct urb *urb)
+#else
+static void hfa384x_usbin_callback(struct urb *urb, struct pt_regs *regs)
+#endif
+{
+	wlandevice_t		*wlandev = urb->context;
+	hfa384x_t		*hw;
+	hfa384x_usbin_t		*usbin = (hfa384x_usbin_t *) urb->transfer_buffer;
+	struct sk_buff          *skb = NULL;
+	int			result;
+	int                     urb_status;
+	UINT16			type;
+
+	enum USBIN_ACTION {
+		HANDLE,
+		RESUBMIT,
+		ABORT
+	} action;
+
+	DBFENTER;
+
+	if ( !wlandev ||
+	     !wlandev->netdev ||
+	     !netif_device_present(wlandev->netdev) )
+		goto exit;
+
+	hw = wlandev->priv;
+	if (!hw)
+		goto exit;
+
+	skb = hw->rx_urb_skb;
+	if (!skb || (skb->data != urb->transfer_buffer)) {
+		BUG();
+	}
+	hw->rx_urb_skb = NULL;
+
+	/* Check for error conditions within the URB */
+	switch (urb->status) {
+	case 0:
+		action = HANDLE;
+
+		/* Check for short packet */
+		if ( urb->actual_length == 0 ) {
+			++(wlandev->linux_stats.rx_errors);
+			++(wlandev->linux_stats.rx_length_errors);
+			action = RESUBMIT;
+		}
+		break;
+
+	case -EPIPE:
+		WLAN_LOG_WARNING("%s rx pipe stalled: requesting reset\n",
+		                 wlandev->netdev->name);
+		if ( !test_and_set_bit(WORK_RX_HALT, &hw->usb_flags) )
+			schedule_work(&hw->usb_work);
+		++(wlandev->linux_stats.rx_errors);
+		action = ABORT;
+		break;
+
+	case -EILSEQ:
+	case -ETIMEDOUT:
+	case -EPROTO:
+		if ( !test_and_set_bit(THROTTLE_RX, &hw->usb_flags) &&
+		     !timer_pending(&hw->throttle) ) {
+			mod_timer(&hw->throttle, jiffies + THROTTLE_JIFFIES);
+		}
+		++(wlandev->linux_stats.rx_errors);
+		action = ABORT;
+		break;
+
+	case -EOVERFLOW:
+		++(wlandev->linux_stats.rx_over_errors);
+		action = RESUBMIT;
+		break;
+
+	case -ENODEV:
+	case -ESHUTDOWN:
+		WLAN_LOG_DEBUG(3,"status=%d, device removed.\n", urb->status);
+		action = ABORT;
+		break;
+
+	case -ENOENT:
+	case -ECONNRESET:
+		WLAN_LOG_DEBUG(3,"status=%d, urb explicitly unlinked.\n", urb->status);
+		action = ABORT;
+		break;
+
+	default:
+		WLAN_LOG_DEBUG(3,"urb status=%d, transfer flags=0x%x\n",
+		                 urb->status, urb->transfer_flags);
+		++(wlandev->linux_stats.rx_errors);
+		action = RESUBMIT;
+		break;
+	}
+
+	urb_status = urb->status;
+
+	if (action != ABORT) {
+		/* Repost the RX URB */
+		result = submit_rx_urb(hw, GFP_ATOMIC);
+
+		if (result != 0) {
+			WLAN_LOG_ERROR(
+				"Fatal, failed to resubmit rx_urb. error=%d\n",
+				result);
+		}
+	}
+
+	/* Handle any USB-IN packet */
+	/* Note: the check of the sw_support field, the type field doesn't
+	 *       have bit 12 set like the docs suggest.
+	 */
+	type = hfa384x2host_16(usbin->type);
+	if (HFA384x_USB_ISRXFRM(type)) {
+		if (action == HANDLE) {
+			if (usbin->txfrm.desc.sw_support == 0x0123) {
+				hfa384x_usbin_txcompl(wlandev, usbin);
+			} else {
+				skb_put(skb, sizeof(*usbin));
+				hfa384x_usbin_rx(wlandev, skb);
+				skb = NULL;
+			}
+		}
+		goto exit;
+	}
+	if (HFA384x_USB_ISTXFRM(type)) {
+		if (action == HANDLE)
+			hfa384x_usbin_txcompl(wlandev, usbin);
+		goto exit;
+	}
+	switch (type) {
+	case HFA384x_USB_INFOFRM:
+		if (action == ABORT)
+			goto exit;
+		if (action == HANDLE)
+			hfa384x_usbin_info(wlandev, usbin);
+		break;
+
+	case HFA384x_USB_CMDRESP:
+	case HFA384x_USB_WRIDRESP:
+	case HFA384x_USB_RRIDRESP:
+	case HFA384x_USB_WMEMRESP:
+	case HFA384x_USB_RMEMRESP:
+		/* ALWAYS, ALWAYS, ALWAYS handle this CTLX!!!! */
+		hfa384x_usbin_ctlx(hw, usbin, urb_status);
+		break;
+
+	case HFA384x_USB_BUFAVAIL:
+		WLAN_LOG_DEBUG(3,"Received BUFAVAIL packet, frmlen=%d\n",
+			usbin->bufavail.frmlen);
+		break;
+
+	case HFA384x_USB_ERROR:
+		WLAN_LOG_DEBUG(3,"Received USB_ERROR packet, errortype=%d\n",
+			usbin->usberror.errortype);
+		break;
+
+	default:
+		WLAN_LOG_DEBUG(3,"Unrecognized USBIN packet, type=%x, status=%d\n",
+			usbin->type, urb_status);
+		break;
+	} /* switch */
+
+exit:
+
+	if (skb)
+		dev_kfree_skb(skb);
+
+	DBFEXIT;
+}
+
+
+/*----------------------------------------------------------------
+* hfa384x_usbin_ctlx
+*
+* We've received a URB containing a Prism2 "response" message.
+* This message needs to be matched up with a CTLX on the active
+* queue and our state updated accordingly.
+*
+* Arguments:
+*	hw		ptr to hfa384x_t
+*	usbin		ptr to USB IN packet
+*	urb_status	status of this Bulk-In URB
+*
+* Returns:
+*	nothing
+*
+* Side effects:
+*
+* Call context:
+*	interrupt
+----------------------------------------------------------------*/
+static void hfa384x_usbin_ctlx(hfa384x_t *hw, hfa384x_usbin_t *usbin,
+			       int urb_status)
+{
+	hfa384x_usbctlx_t	*ctlx;
+	int			run_queue = 0;
+	unsigned long		flags;
+
+	DBFENTER;
+
+retry:
+	spin_lock_irqsave(&hw->ctlxq.lock, flags);
+
+	/* There can be only one CTLX on the active queue
+	 * at any one time, and this is the CTLX that the
+	 * timers are waiting for.
+	 */
+	if ( list_empty(&hw->ctlxq.active) ) {
+		goto unlock;
+	}
+
+	/* Remove the "response timeout". It's possible that
+	 * we are already too late, and that the timeout is
+	 * already running. And that's just too bad for us,
+	 * because we could lose our CTLX from the active
+	 * queue here ...
+	 */
+	if (del_timer(&hw->resptimer) == 0) {
+		if (hw->resp_timer_done == 0) {
+			spin_unlock_irqrestore(&hw->ctlxq.lock, flags);
+			goto retry;
+		}
+	}
+	else {
+		hw->resp_timer_done = 1;
+	}
+
+	ctlx = get_active_ctlx(hw);
+
+	if (urb_status != 0) {
+		/*
+		 * Bad CTLX, so get rid of it. But we only
+		 * remove it from the active queue if we're no
+		 * longer expecting the OUT URB to complete.
+		 */
+		if (unlocked_usbctlx_cancel_async(hw, ctlx) == 0)
+			run_queue = 1;
+	} else {
+		const UINT16 intype = (usbin->type&~host2hfa384x_16(0x8000));
+
+		/*
+		 * Check that our message is what we're expecting ...
+		 */
+		if (ctlx->outbuf.type != intype) {
+			WLAN_LOG_WARNING("Expected IN[%d], received IN[%d] - ignored.\n",
+			                 hfa384x2host_16(ctlx->outbuf.type),
+			                 hfa384x2host_16(intype));
+			goto unlock;
+		}
+
+		/* This URB has succeeded, so grab the data ... */
+		memcpy(&ctlx->inbuf, usbin, sizeof(ctlx->inbuf));
+
+		switch (ctlx->state) {
+		case CTLX_REQ_SUBMITTED:
+			/*
+			 * We have received our response URB before
+			 * our request has been acknowledged. Odd,
+			 * but our OUT URB is still alive...
+			 */
+			WLAN_LOG_DEBUG(0, "Causality violation: please reboot Universe, or email linux-wlan-devel@lists.linux-wlan.com\n");
+			ctlx->state = CTLX_RESP_COMPLETE;
+			break;
+
+		case CTLX_REQ_COMPLETE:
+			/*
+			 * This is the usual path: our request
+			 * has already been acknowledged, and
+			 * now we have received the reply too.
+			 */
+			ctlx->state = CTLX_COMPLETE;
+			unlocked_usbctlx_complete(hw, ctlx);
+			run_queue = 1;
+			break;
+
+		default:
+			/*
+			 * Throw this CTLX away ...
+			 */
+			WLAN_LOG_ERROR("Matched IN URB, CTLX[%d] in invalid state(%s)."
+			               " Discarded.\n",
+			               hfa384x2host_16(ctlx->outbuf.type),
+			               ctlxstr(ctlx->state));
+			if (unlocked_usbctlx_cancel_async(hw, ctlx) == 0)
+				run_queue = 1;
+			break;
+		} /* switch */
+	}
+
+unlock:
+	spin_unlock_irqrestore(&hw->ctlxq.lock, flags);
+
+	if (run_queue)
+		hfa384x_usbctlxq_run(hw);
+
+	DBFEXIT;
+}
+
+
+/*----------------------------------------------------------------
+* hfa384x_usbin_txcompl
+*
+* At this point we have the results of a previous transmit.
+*
+* Arguments:
+*	wlandev		wlan device
+*	usbin		ptr to the usb transfer buffer
+*
+* Returns:
+*	nothing
+*
+* Side effects:
+*
+* Call context:
+*	interrupt
+----------------------------------------------------------------*/
+static void hfa384x_usbin_txcompl(wlandevice_t *wlandev, hfa384x_usbin_t *usbin)
+{
+	UINT16			status;
+	DBFENTER;
+
+	status = hfa384x2host_16(usbin->type); /* yeah I know it says type...*/
+
+	/* Was there an error? */
+	if (HFA384x_TXSTATUS_ISERROR(status)) {
+		prism2sta_ev_txexc(wlandev, status);
+	} else {
+		prism2sta_ev_tx(wlandev, status);
+	}
+	// prism2sta_ev_alloc(wlandev);
+
+	DBFEXIT;
+}
+
+
+/*----------------------------------------------------------------
+* hfa384x_usbin_rx
+*
+* At this point we have a successful received a rx frame packet.
+*
+* Arguments:
+*	wlandev		wlan device
+*	usbin		ptr to the usb transfer buffer
+*
+* Returns:
+*	nothing
+*
+* Side effects:
+*
+* Call context:
+*	interrupt
+----------------------------------------------------------------*/
+static void hfa384x_usbin_rx(wlandevice_t *wlandev, struct sk_buff *skb)
+{
+	hfa384x_usbin_t         *usbin = (hfa384x_usbin_t *) skb->data;
+	hfa384x_t               *hw = wlandev->priv;
+	int                     hdrlen;
+	p80211_rxmeta_t         *rxmeta;
+	UINT16                  data_len;
+	UINT16                  fc;
+
+	DBFENTER;
+
+	/* Byte order convert once up front. */
+	usbin->rxfrm.desc.status =
+		hfa384x2host_16(usbin->rxfrm.desc.status);
+	usbin->rxfrm.desc.time =
+		hfa384x2host_32(usbin->rxfrm.desc.time);
+
+	/* Now handle frame based on port# */
+	switch( HFA384x_RXSTATUS_MACPORT_GET(usbin->rxfrm.desc.status) )
+	{
+	case 0:
+		fc = ieee2host16(usbin->rxfrm.desc.frame_control);
+
+		/* If exclude and we receive an unencrypted, drop it */
+		if ( (wlandev->hostwep & HOSTWEP_EXCLUDEUNENCRYPTED) &&
+		     !WLAN_GET_FC_ISWEP(fc)){
+			goto done;
+		}
+
+		data_len = hfa384x2host_16(usbin->rxfrm.desc.data_len);
+
+		/* How much header data do we have? */
+		hdrlen = p80211_headerlen(fc);
+
+		/* Pull off the descriptor */
+		skb_pull(skb, sizeof(hfa384x_rx_frame_t));
+
+		/* Now shunt the header block up against the data block
+		 * with an "overlapping" copy
+		 */
+		memmove(skb_push(skb, hdrlen),
+		        &usbin->rxfrm.desc.frame_control,
+		        hdrlen);
+
+		skb->dev = wlandev->netdev;
+		skb->dev->last_rx = jiffies;
+
+		/* And set the frame length properly */
+		skb_trim(skb, data_len + hdrlen);
+
+		/* The prism2 series does not return the CRC */
+		memset(skb_put(skb, WLAN_CRC_LEN), 0xff, WLAN_CRC_LEN);
+
+		skb_reset_mac_header(skb);
+
+		/* Attach the rxmeta, set some stuff */
+		p80211skb_rxmeta_attach(wlandev, skb);
+		rxmeta = P80211SKB_RXMETA(skb);
+		rxmeta->mactime = usbin->rxfrm.desc.time;
+		rxmeta->rxrate = usbin->rxfrm.desc.rate;
+		rxmeta->signal = usbin->rxfrm.desc.signal - hw->dbmadjust;
+		rxmeta->noise = usbin->rxfrm.desc.silence - hw->dbmadjust;
+
+		prism2sta_ev_rx(wlandev, skb);
+
+		break;
+
+	case 7:
+		if ( ! HFA384x_RXSTATUS_ISFCSERR(usbin->rxfrm.desc.status) ) {
+			/* Copy to wlansnif skb */
+			hfa384x_int_rxmonitor( wlandev, &usbin->rxfrm);
+			dev_kfree_skb(skb);
+		} else {
+			WLAN_LOG_DEBUG(3,"Received monitor frame: FCSerr set\n");
+		}
+		break;
+
+	default:
+		WLAN_LOG_WARNING("Received frame on unsupported port=%d\n",
+			HFA384x_RXSTATUS_MACPORT_GET(usbin->rxfrm.desc.status) );
+		goto done;
+		break;
+	}
+
+done:
+	DBFEXIT;
+	return;
+}
+
+/*----------------------------------------------------------------
+* hfa384x_int_rxmonitor
+*
+* Helper function for int_rx.  Handles monitor frames.
+* Note that this function allocates space for the FCS and sets it
+* to 0xffffffff.  The hfa384x doesn't give us the FCS value but the
+* higher layers expect it.  0xffffffff is used as a flag to indicate
+* the FCS is bogus.
+*
+* Arguments:
+*	wlandev		wlan device structure
+*	rxfrm		rx descriptor read from card in int_rx
+*
+* Returns:
+*	nothing
+*
+* Side effects:
+*	Allocates an skb and passes it up via the PF_PACKET interface.
+* Call context:
+*	interrupt
+----------------------------------------------------------------*/
+static void hfa384x_int_rxmonitor( wlandevice_t *wlandev, hfa384x_usb_rxfrm_t *rxfrm)
+{
+	hfa384x_rx_frame_t              *rxdesc = &(rxfrm->desc);
+	UINT				hdrlen = 0;
+	UINT				datalen = 0;
+	UINT				skblen = 0;
+	p80211msg_lnxind_wlansniffrm_t	*msg;
+	UINT8				*datap;
+	UINT16				fc;
+	struct sk_buff			*skb;
+	hfa384x_t		        *hw = wlandev->priv;
+
+
+	DBFENTER;
+	/* Don't forget the status, time, and data_len fields are in host order */
+	/* Figure out how big the frame is */
+	fc = ieee2host16(rxdesc->frame_control);
+	hdrlen = p80211_headerlen(fc);
+	datalen = hfa384x2host_16(rxdesc->data_len);
+
+	/* Allocate an ind message+framesize skb */
+	skblen = sizeof(p80211msg_lnxind_wlansniffrm_t) +
+		hdrlen + datalen + WLAN_CRC_LEN;
+
+	/* sanity check the length */
+	if ( skblen >
+		(sizeof(p80211msg_lnxind_wlansniffrm_t) +
+		WLAN_HDR_A4_LEN + WLAN_DATA_MAXLEN + WLAN_CRC_LEN) ) {
+		WLAN_LOG_DEBUG(1, "overlen frm: len=%zd\n",
+			skblen - sizeof(p80211msg_lnxind_wlansniffrm_t));
+	}
+
+	if ( (skb = dev_alloc_skb(skblen)) == NULL ) {
+		WLAN_LOG_ERROR("alloc_skb failed trying to allocate %d bytes\n", skblen);
+		return;
+	}
+
+	/* only prepend the prism header if in the right mode */
+	if ((wlandev->netdev->type == ARPHRD_IEEE80211_PRISM) &&
+	    (hw->sniffhdr == 0)) {
+		datap = skb_put(skb, sizeof(p80211msg_lnxind_wlansniffrm_t));
+		msg = (p80211msg_lnxind_wlansniffrm_t*) datap;
+
+		/* Initialize the message members */
+		msg->msgcode = DIDmsg_lnxind_wlansniffrm;
+		msg->msglen = sizeof(p80211msg_lnxind_wlansniffrm_t);
+		strcpy(msg->devname, wlandev->name);
+
+		msg->hosttime.did = DIDmsg_lnxind_wlansniffrm_hosttime;
+		msg->hosttime.status = 0;
+		msg->hosttime.len = 4;
+		msg->hosttime.data = jiffies;
+
+		msg->mactime.did = DIDmsg_lnxind_wlansniffrm_mactime;
+		msg->mactime.status = 0;
+		msg->mactime.len = 4;
+		msg->mactime.data = rxdesc->time;
+
+		msg->channel.did = DIDmsg_lnxind_wlansniffrm_channel;
+		msg->channel.status = 0;
+		msg->channel.len = 4;
+		msg->channel.data = hw->sniff_channel;
+
+		msg->rssi.did = DIDmsg_lnxind_wlansniffrm_rssi;
+		msg->rssi.status = P80211ENUM_msgitem_status_no_value;
+		msg->rssi.len = 4;
+		msg->rssi.data = 0;
+
+		msg->sq.did = DIDmsg_lnxind_wlansniffrm_sq;
+		msg->sq.status = P80211ENUM_msgitem_status_no_value;
+		msg->sq.len = 4;
+		msg->sq.data = 0;
+
+		msg->signal.did = DIDmsg_lnxind_wlansniffrm_signal;
+		msg->signal.status = 0;
+		msg->signal.len = 4;
+		msg->signal.data = rxdesc->signal;
+
+		msg->noise.did = DIDmsg_lnxind_wlansniffrm_noise;
+		msg->noise.status = 0;
+		msg->noise.len = 4;
+		msg->noise.data = rxdesc->silence;
+
+		msg->rate.did = DIDmsg_lnxind_wlansniffrm_rate;
+		msg->rate.status = 0;
+		msg->rate.len = 4;
+		msg->rate.data = rxdesc->rate / 5; /* set to 802.11 units */
+
+		msg->istx.did = DIDmsg_lnxind_wlansniffrm_istx;
+		msg->istx.status = 0;
+		msg->istx.len = 4;
+		msg->istx.data = P80211ENUM_truth_false;
+
+		msg->frmlen.did = DIDmsg_lnxind_wlansniffrm_frmlen;
+		msg->frmlen.status = 0;
+		msg->frmlen.len = 4;
+		msg->frmlen.data = hdrlen + datalen + WLAN_CRC_LEN;
+	} else if ((wlandev->netdev->type == ARPHRD_IEEE80211_PRISM) &&
+		   (hw->sniffhdr != 0)) {
+		p80211_caphdr_t		*caphdr;
+		/* The NEW header format! */
+		datap = skb_put(skb, sizeof(p80211_caphdr_t));
+		caphdr = (p80211_caphdr_t*) datap;
+
+		caphdr->version =	htonl(P80211CAPTURE_VERSION);
+		caphdr->length =	htonl(sizeof(p80211_caphdr_t));
+		caphdr->mactime =	__cpu_to_be64(rxdesc->time) * 1000;
+		caphdr->hosttime =	__cpu_to_be64(jiffies);
+		caphdr->phytype =	htonl(4); /* dss_dot11_b */
+		caphdr->channel =	htonl(hw->sniff_channel);
+		caphdr->datarate =	htonl(rxdesc->rate);
+		caphdr->antenna =	htonl(0); /* unknown */
+		caphdr->priority =	htonl(0); /* unknown */
+		caphdr->ssi_type =	htonl(3); /* rssi_raw */
+		caphdr->ssi_signal =	htonl(rxdesc->signal);
+		caphdr->ssi_noise =	htonl(rxdesc->silence);
+		caphdr->preamble =	htonl(0); /* unknown */
+		caphdr->encoding =	htonl(1); /* cck */
+	}
+
+	/* Copy the 802.11 header to the skb (ctl frames may be less than a full header) */
+	datap = skb_put(skb, hdrlen);
+	memcpy( datap, &(rxdesc->frame_control), hdrlen);
+
+	/* If any, copy the data from the card to the skb */
+	if ( datalen > 0 )
+	{
+		datap = skb_put(skb, datalen);
+		memcpy(datap, rxfrm->data, datalen);
+
+		/* check for unencrypted stuff if WEP bit set. */
+		if (*(datap - hdrlen + 1) & 0x40) // wep set
+		  if ((*(datap) == 0xaa) && (*(datap+1) == 0xaa))
+		    *(datap - hdrlen + 1) &= 0xbf; // clear wep; it's the 802.2 header!
+	}
+
+	if (hw->sniff_fcs) {
+		/* Set the FCS */
+		datap = skb_put(skb, WLAN_CRC_LEN);
+		memset( datap, 0xff, WLAN_CRC_LEN);
+	}
+
+	/* pass it back up */
+	prism2sta_ev_rx(wlandev, skb);
+
+	DBFEXIT;
+	return;
+}
+
+
+
+/*----------------------------------------------------------------
+* hfa384x_usbin_info
+*
+* At this point we have a successful received a Prism2 info frame.
+*
+* Arguments:
+*	wlandev		wlan device
+*	usbin		ptr to the usb transfer buffer
+*
+* Returns:
+*	nothing
+*
+* Side effects:
+*
+* Call context:
+*	interrupt
+----------------------------------------------------------------*/
+static void hfa384x_usbin_info(wlandevice_t *wlandev, hfa384x_usbin_t *usbin)
+{
+	DBFENTER;
+
+	usbin->infofrm.info.framelen = hfa384x2host_16(usbin->infofrm.info.framelen);
+	prism2sta_ev_info(wlandev, &usbin->infofrm.info);
+
+	DBFEXIT;
+}
+
+
+
+/*----------------------------------------------------------------
+* hfa384x_usbout_callback
+*
+* Callback for URBs on the BULKOUT endpoint.
+*
+* Arguments:
+*	urb		ptr to the completed urb
+*
+* Returns:
+*	nothing
+*
+* Side effects:
+*
+* Call context:
+*	interrupt
+----------------------------------------------------------------*/
+#ifdef URB_ONLY_CALLBACK
+static void hfa384x_usbout_callback(struct urb *urb)
+#else
+static void hfa384x_usbout_callback(struct urb *urb, struct pt_regs *regs)
+#endif
+{
+	wlandevice_t		*wlandev = urb->context;
+	hfa384x_usbout_t	*usbout = urb->transfer_buffer;
+	DBFENTER;
+
+#ifdef DEBUG_USB
+	dbprint_urb(urb);
+#endif
+
+	if ( wlandev &&
+	     wlandev->netdev ) {
+
+		switch(urb->status) {
+		case 0:
+			hfa384x_usbout_tx(wlandev, usbout);
+			break;
+
+		case -EPIPE:
+		{
+			hfa384x_t *hw = wlandev->priv;
+			WLAN_LOG_WARNING("%s tx pipe stalled: requesting reset\n",
+			                 wlandev->netdev->name);
+			if ( !test_and_set_bit(WORK_TX_HALT, &hw->usb_flags) )
+				schedule_work(&hw->usb_work);
+			++(wlandev->linux_stats.tx_errors);
+			break;
+		}
+
+		case -EPROTO:
+		case -ETIMEDOUT:
+		case -EILSEQ:
+		{
+			hfa384x_t *hw = wlandev->priv;
+
+			if ( !test_and_set_bit(THROTTLE_TX, &hw->usb_flags)
+			     && !timer_pending(&hw->throttle) ) {
+				mod_timer(&hw->throttle,
+				          jiffies + THROTTLE_JIFFIES);
+			}
+			++(wlandev->linux_stats.tx_errors);
+			netif_stop_queue(wlandev->netdev);
+			break;
+		}
+
+		case -ENOENT:
+		case -ESHUTDOWN:
+			/* Ignorable errors */
+			break;
+
+		default:
+			WLAN_LOG_INFO("unknown urb->status=%d\n", urb->status);
+			++(wlandev->linux_stats.tx_errors);
+			break;
+		} /* switch */
+	}
+
+	DBFEXIT;
+}
+
+
+/*----------------------------------------------------------------
+* hfa384x_ctlxout_callback
+*
+* Callback for control data on the BULKOUT endpoint.
+*
+* Arguments:
+*	urb		ptr to the completed urb
+*
+* Returns:
+* nothing
+*
+* Side effects:
+*
+* Call context:
+* interrupt
+----------------------------------------------------------------*/
+#ifdef URB_ONLY_CALLBACK
+static void hfa384x_ctlxout_callback(struct urb *urb)
+#else
+static void hfa384x_ctlxout_callback(struct urb *urb, struct pt_regs *regs)
+#endif
+{
+	hfa384x_t	*hw = urb->context;
+	int             delete_resptimer = 0;
+	int             timer_ok = 1;
+	int		run_queue = 0;
+	hfa384x_usbctlx_t	*ctlx;
+	unsigned long	flags;
+
+	DBFENTER;
+
+	WLAN_LOG_DEBUG(3,"urb->status=%d\n", urb->status);
+#ifdef DEBUG_USB
+	dbprint_urb(urb);
+#endif
+	if ( (urb->status == -ESHUTDOWN) ||
+	     (urb->status == -ENODEV) ||
+	     (hw == NULL) )
+		goto done;
+
+retry:
+	spin_lock_irqsave(&hw->ctlxq.lock, flags);
+
+	/*
+	 * Only one CTLX at a time on the "active" list, and
+	 * none at all if we are unplugged. However, we can
+	 * rely on the disconnect function to clean everything
+	 * up if someone unplugged the adapter.
+	 */
+	if ( list_empty(&hw->ctlxq.active) ) {
+		spin_unlock_irqrestore(&hw->ctlxq.lock, flags);
+		goto done;
+	}
+
+	/*
+	 * Having something on the "active" queue means
+	 * that we have timers to worry about ...
+	 */
+	if (del_timer(&hw->reqtimer) == 0) {
+		if (hw->req_timer_done == 0) {
+			/*
+			 * This timer was actually running while we
+			 * were trying to delete it. Let it terminate
+			 * gracefully instead.
+			 */
+			spin_unlock_irqrestore(&hw->ctlxq.lock, flags);
+			goto retry;
+		}
+	}
+	else {
+		hw->req_timer_done = 1;
+	}
+
+	ctlx = get_active_ctlx(hw);
+
+	if ( urb->status == 0 ) {
+		/* Request portion of a CTLX is successful */
+		switch ( ctlx->state ) {
+		case CTLX_REQ_SUBMITTED:
+			/* This OUT-ACK received before IN */
+			ctlx->state = CTLX_REQ_COMPLETE;
+			break;
+
+		case CTLX_RESP_COMPLETE:
+			/* IN already received before this OUT-ACK,
+			 * so this command must now be complete.
+			 */
+			ctlx->state = CTLX_COMPLETE;
+			unlocked_usbctlx_complete(hw, ctlx);
+			run_queue = 1;
+			break;
+
+		default:
+			/* This is NOT a valid CTLX "success" state! */
+			WLAN_LOG_ERROR(
+			    "Illegal CTLX[%d] success state(%s, %d) in OUT URB\n",
+			    hfa384x2host_16(ctlx->outbuf.type),
+			    ctlxstr(ctlx->state), urb->status);
+			break;
+		} /* switch */
+	} else {
+		/* If the pipe has stalled then we need to reset it */
+		if ( (urb->status == -EPIPE) &&
+		      !test_and_set_bit(WORK_TX_HALT, &hw->usb_flags) ) {
+			WLAN_LOG_WARNING("%s tx pipe stalled: requesting reset\n",
+			                 hw->wlandev->netdev->name);
+			schedule_work(&hw->usb_work);
+		}
+
+		/* If someone cancels the OUT URB then its status
+		 * should be either -ECONNRESET or -ENOENT.
+		 */
+		ctlx->state = CTLX_REQ_FAILED;
+		unlocked_usbctlx_complete(hw, ctlx);
+		delete_resptimer = 1;
+		run_queue = 1;
+	}
+
+ delresp:
+	if (delete_resptimer) {
+		if ((timer_ok = del_timer(&hw->resptimer)) != 0) {
+			hw->resp_timer_done = 1;
+		}
+	}
+
+	spin_unlock_irqrestore(&hw->ctlxq.lock, flags);
+
+	if ( !timer_ok && (hw->resp_timer_done == 0) ) {
+		spin_lock_irqsave(&hw->ctlxq.lock, flags);
+		goto delresp;
+	}
+
+	if (run_queue)
+		hfa384x_usbctlxq_run(hw);
+
+ done:
+	DBFEXIT;
+}
+
+
+/*----------------------------------------------------------------
+* hfa384x_usbctlx_reqtimerfn
+*
+* Timer response function for CTLX request timeouts.  If this
+* function is called, it means that the callback for the OUT
+* URB containing a Prism2.x XXX_Request was never called.
+*
+* Arguments:
+*	data		a ptr to the hfa384x_t
+*
+* Returns:
+*	nothing
+*
+* Side effects:
+*
+* Call context:
+*	interrupt
+----------------------------------------------------------------*/
+static void
+hfa384x_usbctlx_reqtimerfn(unsigned long data)
+{
+	hfa384x_t	*hw = (hfa384x_t*)data;
+	unsigned long   flags;
+	DBFENTER;
+
+	spin_lock_irqsave(&hw->ctlxq.lock, flags);
+
+	hw->req_timer_done = 1;
+
+	/* Removing the hardware automatically empties
+	 * the active list ...
+	 */
+	if ( !list_empty(&hw->ctlxq.active) )
+	{
+		/*
+		 * We must ensure that our URB is removed from
+		 * the system, if it hasn't already expired.
+		 */
+		hw->ctlx_urb.transfer_flags |= URB_ASYNC_UNLINK;
+		if (usb_unlink_urb(&hw->ctlx_urb) == -EINPROGRESS)
+		{
+			hfa384x_usbctlx_t *ctlx = get_active_ctlx(hw);
+
+			ctlx->state = CTLX_REQ_FAILED;
+
+			/* This URB was active, but has now been
+			 * cancelled. It will now have a status of
+			 * -ECONNRESET in the callback function.
+			 *
+			 * We are cancelling this CTLX, so we're
+			 * not going to need to wait for a response.
+			 * The URB's callback function will check
+			 * that this timer is truly dead.
+			 */
+			if (del_timer(&hw->resptimer) != 0)
+				hw->resp_timer_done = 1;
+		}
+	}
+
+	spin_unlock_irqrestore(&hw->ctlxq.lock, flags);
+
+	DBFEXIT;
+}
+
+
+/*----------------------------------------------------------------
+* hfa384x_usbctlx_resptimerfn
+*
+* Timer response function for CTLX response timeouts.  If this
+* function is called, it means that the callback for the IN
+* URB containing a Prism2.x XXX_Response was never called.
+*
+* Arguments:
+*	data		a ptr to the hfa384x_t
+*
+* Returns:
+*	nothing
+*
+* Side effects:
+*
+* Call context:
+*	interrupt
+----------------------------------------------------------------*/
+static void
+hfa384x_usbctlx_resptimerfn(unsigned long data)
+{
+	hfa384x_t *hw = (hfa384x_t*)data;
+	unsigned long   flags;
+
+	DBFENTER;
+
+	spin_lock_irqsave(&hw->ctlxq.lock, flags);
+
+	hw->resp_timer_done = 1;
+
+	/* The active list will be empty if the
+	 * adapter has been unplugged ...
+	 */
+	if ( !list_empty(&hw->ctlxq.active) )
+	{
+		hfa384x_usbctlx_t *ctlx = get_active_ctlx(hw);
+
+		if ( unlocked_usbctlx_cancel_async(hw, ctlx) == 0 )
+		{
+			spin_unlock_irqrestore(&hw->ctlxq.lock, flags);
+			hfa384x_usbctlxq_run(hw);
+			goto done;
+		}
+	}
+
+	spin_unlock_irqrestore(&hw->ctlxq.lock, flags);
+
+ done:
+	DBFEXIT;
+}
+
+/*----------------------------------------------------------------
+* hfa384x_usb_throttlefn
+*
+*
+* Arguments:
+*	data	ptr to hw
+*
+* Returns:
+*	Nothing
+*
+* Side effects:
+*
+* Call context:
+*	Interrupt
+----------------------------------------------------------------*/
+static void
+hfa384x_usb_throttlefn(unsigned long data)
+{
+	hfa384x_t *hw = (hfa384x_t*)data;
+	unsigned long   flags;
+
+	DBFENTER;
+
+	spin_lock_irqsave(&hw->ctlxq.lock, flags);
+
+	/*
+	 * We need to check BOTH the RX and the TX throttle controls,
+	 * so we use the bitwise OR instead of the logical OR.
+	 */
+	WLAN_LOG_DEBUG(3, "flags=0x%lx\n", hw->usb_flags);
+	if ( !hw->wlandev->hwremoved &&
+	     (
+	       (test_and_clear_bit(THROTTLE_RX, &hw->usb_flags) &&
+	       !test_and_set_bit(WORK_RX_RESUME, &hw->usb_flags))
+	       |
+	       (test_and_clear_bit(THROTTLE_TX, &hw->usb_flags) &&
+	        !test_and_set_bit(WORK_TX_RESUME, &hw->usb_flags))
+	     ) )
+	{
+		schedule_work(&hw->usb_work);
+	}
+
+	spin_unlock_irqrestore(&hw->ctlxq.lock, flags);
+
+	DBFEXIT;
+}
+
+
+/*----------------------------------------------------------------
+* hfa384x_usbctlx_submit
+*
+* Called from the doxxx functions to submit a CTLX to the queue
+*
+* Arguments:
+*	hw		ptr to the hw struct
+*	ctlx		ctlx structure to enqueue
+*
+* Returns:
+*	-ENODEV if the adapter is unplugged
+*	0
+*
+* Side effects:
+*
+* Call context:
+*	process or interrupt
+----------------------------------------------------------------*/
+static int
+hfa384x_usbctlx_submit(
+	hfa384x_t		*hw,
+	hfa384x_usbctlx_t	*ctlx)
+{
+	unsigned long flags;
+	int ret;
+
+	DBFENTER;
+
+	spin_lock_irqsave(&hw->ctlxq.lock, flags);
+
+	if (hw->wlandev->hwremoved) {
+		spin_unlock_irqrestore(&hw->ctlxq.lock, flags);
+		ret = -ENODEV;
+	} else {
+		ctlx->state = CTLX_PENDING;
+		list_add_tail(&ctlx->list, &hw->ctlxq.pending);
+
+		spin_unlock_irqrestore(&hw->ctlxq.lock, flags);
+		hfa384x_usbctlxq_run(hw);
+		ret = 0;
+	}
+
+	DBFEXIT;
+	return ret;
+}
+
+
+/*----------------------------------------------------------------
+* hfa384x_usbout_tx
+*
+* At this point we have finished a send of a frame.  Mark the URB
+* as available and call ev_alloc to notify higher layers we're
+* ready for more.
+*
+* Arguments:
+*	wlandev		wlan device
+*	usbout		ptr to the usb transfer buffer
+*
+* Returns:
+*	nothing
+*
+* Side effects:
+*
+* Call context:
+*	interrupt
+----------------------------------------------------------------*/
+static void hfa384x_usbout_tx(wlandevice_t *wlandev, hfa384x_usbout_t *usbout)
+{
+	DBFENTER;
+
+	prism2sta_ev_alloc(wlandev);
+
+	DBFEXIT;
+}
+
+/*----------------------------------------------------------------
+* hfa384x_isgood_pdrcore
+*
+* Quick check of PDR codes.
+*
+* Arguments:
+*	pdrcode		PDR code number (host order)
+*
+* Returns:
+*	zero		not good.
+*	one		is good.
+*
+* Side effects:
+*
+* Call context:
+----------------------------------------------------------------*/
+static int
+hfa384x_isgood_pdrcode(UINT16 pdrcode)
+{
+	switch(pdrcode) {
+	case HFA384x_PDR_END_OF_PDA:
+	case HFA384x_PDR_PCB_PARTNUM:
+	case HFA384x_PDR_PDAVER:
+	case HFA384x_PDR_NIC_SERIAL:
+	case HFA384x_PDR_MKK_MEASUREMENTS:
+	case HFA384x_PDR_NIC_RAMSIZE:
+	case HFA384x_PDR_MFISUPRANGE:
+	case HFA384x_PDR_CFISUPRANGE:
+	case HFA384x_PDR_NICID:
+	case HFA384x_PDR_MAC_ADDRESS:
+	case HFA384x_PDR_REGDOMAIN:
+	case HFA384x_PDR_ALLOWED_CHANNEL:
+	case HFA384x_PDR_DEFAULT_CHANNEL:
+	case HFA384x_PDR_TEMPTYPE:
+	case HFA384x_PDR_IFR_SETTING:
+	case HFA384x_PDR_RFR_SETTING:
+	case HFA384x_PDR_HFA3861_BASELINE:
+	case HFA384x_PDR_HFA3861_SHADOW:
+	case HFA384x_PDR_HFA3861_IFRF:
+	case HFA384x_PDR_HFA3861_CHCALSP:
+	case HFA384x_PDR_HFA3861_CHCALI:
+	case HFA384x_PDR_3842_NIC_CONFIG:
+	case HFA384x_PDR_USB_ID:
+	case HFA384x_PDR_PCI_ID:
+	case HFA384x_PDR_PCI_IFCONF:
+	case HFA384x_PDR_PCI_PMCONF:
+	case HFA384x_PDR_RFENRGY:
+	case HFA384x_PDR_HFA3861_MANF_TESTSP:
+	case HFA384x_PDR_HFA3861_MANF_TESTI:
+		/* code is OK */
+		return 1;
+		break;
+	default:
+		if ( pdrcode < 0x1000 ) {
+			/* code is OK, but we don't know exactly what it is */
+			WLAN_LOG_DEBUG(3,
+				"Encountered unknown PDR#=0x%04x, "
+				"assuming it's ok.\n",
+				pdrcode);
+			return 1;
+		} else {
+			/* bad code */
+			WLAN_LOG_DEBUG(3,
+				"Encountered unknown PDR#=0x%04x, "
+				"(>=0x1000), assuming it's bad.\n",
+				pdrcode);
+			return 0;
+		}
+		break;
+	}
+	return 0; /* avoid compiler warnings */
+}
+
