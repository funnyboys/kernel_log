commit 9a47dc5f7eb3ad9a7145f43e19a2bc19b1073bfc
Author: Prathamesh Deshpande <prathameshdeshpande7@gmail.com>
Date:   Mon Dec 24 08:53:46 2018 -0800

    staging: wlan-ng: prism2fw.c: Fix "Possible unnecessary 'out of memory' message" checkpatch.pl warning"
    
    This patch removes unnecessary out of memory warning
    message from wlan-ng prism2fw.c file.
    
    Signed-off-by: Prathamesh Deshpande <prathameshdeshpande7@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/prism2fw.c b/drivers/staging/wlan-ng/prism2fw.c
index bb572b7fdfee..94800c007162 100644
--- a/drivers/staging/wlan-ng/prism2fw.c
+++ b/drivers/staging/wlan-ng/prism2fw.c
@@ -556,10 +556,9 @@ static int mkimage(struct imgchunk *clist, unsigned int *ccnt)
 	/* Allocate buffer space for chunks */
 	for (i = 0; i < *ccnt; i++) {
 		clist[i].data = kzalloc(clist[i].len, GFP_KERNEL);
-		if (!clist[i].data) {
-			pr_err("failed to allocate image space, exiting.\n");
+		if (!clist[i].data)
 			return 1;
-		}
+
 		pr_debug("chunk[%d]: addr=0x%06x len=%d\n",
 			 i, clist[i].addr, clist[i].len);
 	}

commit 700fe657dd09159710778bec394e5a11ca6c93d9
Author: Tim Collier <osdevtc@gmail.com>
Date:   Mon Nov 19 08:41:31 2018 +0000

    staging: wlan-ng: remove unused variable in prism2fw.c
    
    Remove the unused crcend variable from the crcimage function.
    
    Signed-off-by: Tim Collier <osdevtc@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/prism2fw.c b/drivers/staging/wlan-ng/prism2fw.c
index a2c851c74bef..bb572b7fdfee 100644
--- a/drivers/staging/wlan-ng/prism2fw.c
+++ b/drivers/staging/wlan-ng/prism2fw.c
@@ -406,7 +406,6 @@ static int crcimage(struct imgchunk *fchunk, unsigned int nfchunks,
 	int i;
 	int c;
 	u32 crcstart;
-	u32 crcend;
 	u32 cstart = 0;
 	u32 cend;
 	u8 *dest;
@@ -416,7 +415,6 @@ static int crcimage(struct imgchunk *fchunk, unsigned int nfchunks,
 		if (!s3crc[i].dowrite)
 			continue;
 		crcstart = s3crc[i].addr;
-		crcend = s3crc[i].addr + s3crc[i].len;
 		/* Find chunk */
 		for (c = 0; c < nfchunks; c++) {
 			cstart = fchunk[c].addr;

commit c677b19653b8787be9e331619842f2255dd7b3e8
Author: Rohit Sarkar <rohitsarkar5398@gmail.com>
Date:   Tue Nov 6 23:53:00 2018 +0530

    staging: wlan-ng: Fix a typo.
    
    "Exiting" instead of "Exitting"
    
    Signed-off-by: Rohit Sarkar <rohitsarkar5398@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/prism2fw.c b/drivers/staging/wlan-ng/prism2fw.c
index f99626ca6bdc..a2c851c74bef 100644
--- a/drivers/staging/wlan-ng/prism2fw.c
+++ b/drivers/staging/wlan-ng/prism2fw.c
@@ -559,7 +559,7 @@ static int mkimage(struct imgchunk *clist, unsigned int *ccnt)
 	for (i = 0; i < *ccnt; i++) {
 		clist[i].data = kzalloc(clist[i].len, GFP_KERNEL);
 		if (!clist[i].data) {
-			pr_err("failed to allocate image space, exitting.\n");
+			pr_err("failed to allocate image space, exiting.\n");
 			return 1;
 		}
 		pr_debug("chunk[%d]: addr=0x%06x len=%d\n",

commit 7ae2637abad9737a008292411d56c4b7a6ab2f98
Author: Tim Collier <osdevtc@gmail.com>
Date:   Wed Sep 26 23:06:24 2018 +0100

    staging: wlan-ng: rename DIDmib_p2_p2NIC_p2PRISupRange in p80211metadef.h
    
    Rename DIDmib_p2_p2NIC_p2PRISupRange in p80211metadef.h to
    DIDMIB_P2_NIC_PRISUPRANGE to fix "Avoid CamelCase" message from
    checkpatch and conform to the coding style guidelines. Also shorten
    name by removing repeated use of "P2" to ease readability and reduce
    long lines.
    
    Signed-off-by: Tim Collier <osdevtc@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/prism2fw.c b/drivers/staging/wlan-ng/prism2fw.c
index d79d8623a1db..f99626ca6bdc 100644
--- a/drivers/staging/wlan-ng/prism2fw.c
+++ b/drivers/staging/wlan-ng/prism2fw.c
@@ -304,7 +304,7 @@ static int prism2_fwapply(const struct ihex_binrec *rfptr,
 	getmsg.resultcode.status = P80211ENUM_msgitem_status_no_value;
 
 	item = (struct p80211itemd *)getmsg.mibattribute.data;
-	item->did = DIDmib_p2_p2NIC_p2PRISupRange;
+	item->did = DIDMIB_P2_NIC_PRISUPRANGE;
 	item->status = P80211ENUM_msgitem_status_no_value;
 
 	data = (u32 *)item->data;

commit 8fb830b56d243a540ac2a3cd7e038e8df8ecb9af
Author: Tim Collier <osdevtc@gmail.com>
Date:   Wed Sep 26 23:05:56 2018 +0100

    staging: wlan-ng: rename DIDmsg_p2req_ramdl_write_resultcode in p80211metadef.h
    
    Rename DIDmsg_p2req_ramdl_write_resultcode in p80211metadef.h to
    DIDMSG_P2REQ_RAMDL_WRITE_RESULTCODE to fix "Avoid CamelCase" message
    from checkpatch and conform to the coding style guidelines.
    
    Signed-off-by: Tim Collier <osdevtc@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/prism2fw.c b/drivers/staging/wlan-ng/prism2fw.c
index 76662f4e690d..d79d8623a1db 100644
--- a/drivers/staging/wlan-ng/prism2fw.c
+++ b/drivers/staging/wlan-ng/prism2fw.c
@@ -1039,7 +1039,7 @@ static int writeimage(struct wlandevice *wlandev, struct imgchunk *fchunk,
 	rwrmsg->addr.did = DIDMSG_P2REQ_RAMDL_WRITE_ADDR;
 	rwrmsg->len.did = DIDMSG_P2REQ_RAMDL_WRITE_LEN;
 	rwrmsg->data.did = DIDMSG_P2REQ_RAMDL_WRITE_DATA;
-	rwrmsg->resultcode.did = DIDmsg_p2req_ramdl_write_resultcode;
+	rwrmsg->resultcode.did = DIDMSG_P2REQ_RAMDL_WRITE_RESULTCODE;
 	rwrmsg->addr.status = P80211ENUM_msgitem_status_data_ok;
 	rwrmsg->len.status = P80211ENUM_msgitem_status_data_ok;
 	rwrmsg->data.status = P80211ENUM_msgitem_status_data_ok;

commit 74f11efc08d426a760803901b3fee10716408f0e
Author: Tim Collier <osdevtc@gmail.com>
Date:   Wed Sep 26 23:05:55 2018 +0100

    staging: wlan-ng: rename DIDmsg_p2req_ramdl_write_data in p80211metadef.h
    
    Rename DIDmsg_p2req_ramdl_write_data in p80211metadef.h to
    DIDMSG_P2REQ_RAMDL_WRITE_DATA to fix "Avoid CamelCase" message from
    checkpatch and conform to the coding style guidelines.
    
    Signed-off-by: Tim Collier <osdevtc@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/prism2fw.c b/drivers/staging/wlan-ng/prism2fw.c
index ab7d45023263..76662f4e690d 100644
--- a/drivers/staging/wlan-ng/prism2fw.c
+++ b/drivers/staging/wlan-ng/prism2fw.c
@@ -1038,7 +1038,7 @@ static int writeimage(struct wlandevice *wlandev, struct imgchunk *fchunk,
 	rwrmsg->msglen = sizeof(*rwrmsg);
 	rwrmsg->addr.did = DIDMSG_P2REQ_RAMDL_WRITE_ADDR;
 	rwrmsg->len.did = DIDMSG_P2REQ_RAMDL_WRITE_LEN;
-	rwrmsg->data.did = DIDmsg_p2req_ramdl_write_data;
+	rwrmsg->data.did = DIDMSG_P2REQ_RAMDL_WRITE_DATA;
 	rwrmsg->resultcode.did = DIDmsg_p2req_ramdl_write_resultcode;
 	rwrmsg->addr.status = P80211ENUM_msgitem_status_data_ok;
 	rwrmsg->len.status = P80211ENUM_msgitem_status_data_ok;

commit 9940d6b6f90505f78813f9bce9e8d934fdc312dc
Author: Tim Collier <osdevtc@gmail.com>
Date:   Wed Sep 26 23:05:54 2018 +0100

    staging: wlan-ng: rename DIDmsg_p2req_ramdl_write_len in p80211metadef.h
    
    Rename DIDmsg_p2req_ramdl_write_len to DIDMSG_P2REQ_RAMDL_WRITE_LEN to
    fix "Avoid CamelCase" message from checkpatch and conform to the
    coding style guidelines.
    
    Signed-off-by: Tim Collier <osdevtc@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/prism2fw.c b/drivers/staging/wlan-ng/prism2fw.c
index 067bcf2af3fc..ab7d45023263 100644
--- a/drivers/staging/wlan-ng/prism2fw.c
+++ b/drivers/staging/wlan-ng/prism2fw.c
@@ -1037,7 +1037,7 @@ static int writeimage(struct wlandevice *wlandev, struct imgchunk *fchunk,
 	rwrmsg->msgcode = DIDMSG_P2REQ_RAMDL_WRITE;
 	rwrmsg->msglen = sizeof(*rwrmsg);
 	rwrmsg->addr.did = DIDMSG_P2REQ_RAMDL_WRITE_ADDR;
-	rwrmsg->len.did = DIDmsg_p2req_ramdl_write_len;
+	rwrmsg->len.did = DIDMSG_P2REQ_RAMDL_WRITE_LEN;
 	rwrmsg->data.did = DIDmsg_p2req_ramdl_write_data;
 	rwrmsg->resultcode.did = DIDmsg_p2req_ramdl_write_resultcode;
 	rwrmsg->addr.status = P80211ENUM_msgitem_status_data_ok;

commit c2a348b838ac12170c40ee63c0e4b605e6c6591d
Author: Tim Collier <osdevtc@gmail.com>
Date:   Wed Sep 26 23:05:53 2018 +0100

    staging: wlan-ng: rename DIDmsg_p2req_ramdl_write_addr in p80211metadef.h
    
    Rename DIDmsg_p2req_ramdl_write_addr in p80211metadef.h to
    DIDMSG_P2REQ_RAMDL_WRITE_ADDR to fix "Avoid CamelCase" message from
    checkpatch and conform to the coding style guidelines.
    
    Signed-off-by: Tim Collier <osdevtc@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/prism2fw.c b/drivers/staging/wlan-ng/prism2fw.c
index 55c9b58082c7..067bcf2af3fc 100644
--- a/drivers/staging/wlan-ng/prism2fw.c
+++ b/drivers/staging/wlan-ng/prism2fw.c
@@ -1036,7 +1036,7 @@ static int writeimage(struct wlandevice *wlandev, struct imgchunk *fchunk,
 	strcpy(rwrmsg->devname, wlandev->name);
 	rwrmsg->msgcode = DIDMSG_P2REQ_RAMDL_WRITE;
 	rwrmsg->msglen = sizeof(*rwrmsg);
-	rwrmsg->addr.did = DIDmsg_p2req_ramdl_write_addr;
+	rwrmsg->addr.did = DIDMSG_P2REQ_RAMDL_WRITE_ADDR;
 	rwrmsg->len.did = DIDmsg_p2req_ramdl_write_len;
 	rwrmsg->data.did = DIDmsg_p2req_ramdl_write_data;
 	rwrmsg->resultcode.did = DIDmsg_p2req_ramdl_write_resultcode;

commit e0959e9b7a398f53aadfd48ba09bad7e6d76efc3
Author: Tim Collier <osdevtc@gmail.com>
Date:   Wed Sep 26 23:05:52 2018 +0100

    staging: wlan-ng: rename DIDmsg_p2req_ramdl_write in p80211metadef.h
    
    Rename DIDmsg_p2req_ramdl_write in p80211metadef.h to
    DIDMSG_P2REQ_RAMDL_WRITE to fix "Avoid CamelCase" message from
    checkpatch and conform to the coding style guidelines.
    
    Signed-off-by: Tim Collier <osdevtc@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/prism2fw.c b/drivers/staging/wlan-ng/prism2fw.c
index 9c3eb90035e6..55c9b58082c7 100644
--- a/drivers/staging/wlan-ng/prism2fw.c
+++ b/drivers/staging/wlan-ng/prism2fw.c
@@ -1034,7 +1034,7 @@ static int writeimage(struct wlandevice *wlandev, struct imgchunk *fchunk,
 	rstmsg->resultcode.len = sizeof(u32);
 
 	strcpy(rwrmsg->devname, wlandev->name);
-	rwrmsg->msgcode = DIDmsg_p2req_ramdl_write;
+	rwrmsg->msgcode = DIDMSG_P2REQ_RAMDL_WRITE;
 	rwrmsg->msglen = sizeof(*rwrmsg);
 	rwrmsg->addr.did = DIDmsg_p2req_ramdl_write_addr;
 	rwrmsg->len.did = DIDmsg_p2req_ramdl_write_len;

commit 8843c1fb98c940a60431ab12c9c504147b88ea99
Author: Tim Collier <osdevtc@gmail.com>
Date:   Wed Sep 26 23:05:51 2018 +0100

    staging: wlan-ng: rename DIDmsg_p2req_ramdl_state_resultcode in p80211metadef.h
    
    Rename DIDmsg_p2req_ramdl_state_resultcode in p80211metadef.h to
    DIDMSG_P2REQ_RAMDL_STATE_RESULTCODE to fix "Avoid CamelCase" message
    from checkpatch and conform to the coding style guidelines.
    
    Signed-off-by: Tim Collier <osdevtc@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/prism2fw.c b/drivers/staging/wlan-ng/prism2fw.c
index eb3ca52e5da2..9c3eb90035e6 100644
--- a/drivers/staging/wlan-ng/prism2fw.c
+++ b/drivers/staging/wlan-ng/prism2fw.c
@@ -1025,7 +1025,7 @@ static int writeimage(struct wlandevice *wlandev, struct imgchunk *fchunk,
 	rstmsg->msglen = sizeof(*rstmsg);
 	rstmsg->enable.did = DIDMSG_P2REQ_RAMDL_STATE_ENABLE;
 	rstmsg->exeaddr.did = DIDMSG_P2REQ_RAMDL_STATE_EXEADDR;
-	rstmsg->resultcode.did = DIDmsg_p2req_ramdl_state_resultcode;
+	rstmsg->resultcode.did = DIDMSG_P2REQ_RAMDL_STATE_RESULTCODE;
 	rstmsg->enable.status = P80211ENUM_msgitem_status_data_ok;
 	rstmsg->exeaddr.status = P80211ENUM_msgitem_status_data_ok;
 	rstmsg->resultcode.status = P80211ENUM_msgitem_status_no_value;

commit 9ea4ffecf1146e9df748b8f83d437f5666e88e6d
Author: Tim Collier <osdevtc@gmail.com>
Date:   Wed Sep 26 23:05:50 2018 +0100

    staging: wlan-ng: rename DIDmsg_p2req_ramdl_state_exeaddr in p80211metadef.h
    
    Rename DIDmsg_p2req_ramdl_state_exeaddr in p80211metadef.h to
    DIDMSG_P2REQ_RAMDL_STATE_EXEADDR to fix "Avoid CamelCase" message from
    checkpatch and conform to the coding style guidelines.
    
    Signed-off-by: Tim Collier <osdevtc@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/prism2fw.c b/drivers/staging/wlan-ng/prism2fw.c
index 5df3c954b4e1..eb3ca52e5da2 100644
--- a/drivers/staging/wlan-ng/prism2fw.c
+++ b/drivers/staging/wlan-ng/prism2fw.c
@@ -1024,7 +1024,7 @@ static int writeimage(struct wlandevice *wlandev, struct imgchunk *fchunk,
 	rstmsg->msgcode = DIDMSG_P2REQ_RAMDL_STATE;
 	rstmsg->msglen = sizeof(*rstmsg);
 	rstmsg->enable.did = DIDMSG_P2REQ_RAMDL_STATE_ENABLE;
-	rstmsg->exeaddr.did = DIDmsg_p2req_ramdl_state_exeaddr;
+	rstmsg->exeaddr.did = DIDMSG_P2REQ_RAMDL_STATE_EXEADDR;
 	rstmsg->resultcode.did = DIDmsg_p2req_ramdl_state_resultcode;
 	rstmsg->enable.status = P80211ENUM_msgitem_status_data_ok;
 	rstmsg->exeaddr.status = P80211ENUM_msgitem_status_data_ok;

commit 380ad4f6779478210f2dd4a98cec9723cbc9cb58
Author: Tim Collier <osdevtc@gmail.com>
Date:   Wed Sep 26 23:05:49 2018 +0100

    staging: wlan-ng: rename DIDmsg_p2req_ramdl_state_enable in p80211metadef.h
    
    Rename DIDmsg_p2req_ramdl_state_enable in p80211metadef.h to
    DIDMSG_P2REQ_RAMDL_STATE_ENABLE to fix "Avoid CamelCase" message from
    checkpatch and conform to the coding style guidelines.
    
    Signed-off-by: Tim Collier <osdevtc@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/prism2fw.c b/drivers/staging/wlan-ng/prism2fw.c
index 37f63988d5c9..5df3c954b4e1 100644
--- a/drivers/staging/wlan-ng/prism2fw.c
+++ b/drivers/staging/wlan-ng/prism2fw.c
@@ -1023,7 +1023,7 @@ static int writeimage(struct wlandevice *wlandev, struct imgchunk *fchunk,
 	strcpy(rstmsg->devname, wlandev->name);
 	rstmsg->msgcode = DIDMSG_P2REQ_RAMDL_STATE;
 	rstmsg->msglen = sizeof(*rstmsg);
-	rstmsg->enable.did = DIDmsg_p2req_ramdl_state_enable;
+	rstmsg->enable.did = DIDMSG_P2REQ_RAMDL_STATE_ENABLE;
 	rstmsg->exeaddr.did = DIDmsg_p2req_ramdl_state_exeaddr;
 	rstmsg->resultcode.did = DIDmsg_p2req_ramdl_state_resultcode;
 	rstmsg->enable.status = P80211ENUM_msgitem_status_data_ok;

commit f1364a0d5404fa39195f4fe9c03528f455c12c98
Author: Tim Collier <osdevtc@gmail.com>
Date:   Wed Sep 26 23:05:48 2018 +0100

    staging: wlan-ng: rename DIDmsg_p2req_ramdl_state in p80211metadef.h
    
    Rename DIDmsg_p2req_ramdl_state to DIDMSG_P2REQ_RAMDL_STATE in
    p80211metadef.h to fix "Avoid CamelCase" message from checkpatch and
    conform to the coding style guidelines.
    
    Signed-off-by: Tim Collier <osdevtc@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/prism2fw.c b/drivers/staging/wlan-ng/prism2fw.c
index d8f66dd13fc8..37f63988d5c9 100644
--- a/drivers/staging/wlan-ng/prism2fw.c
+++ b/drivers/staging/wlan-ng/prism2fw.c
@@ -1021,7 +1021,7 @@ static int writeimage(struct wlandevice *wlandev, struct imgchunk *fchunk,
 
 	/* Initialize the messages */
 	strcpy(rstmsg->devname, wlandev->name);
-	rstmsg->msgcode = DIDmsg_p2req_ramdl_state;
+	rstmsg->msgcode = DIDMSG_P2REQ_RAMDL_STATE;
 	rstmsg->msglen = sizeof(*rstmsg);
 	rstmsg->enable.did = DIDmsg_p2req_ramdl_state_enable;
 	rstmsg->exeaddr.did = DIDmsg_p2req_ramdl_state_exeaddr;

commit 020600ae8dbad42aac0a297221538d3c88492482
Author: Tim Collier <osdevtc@gmail.com>
Date:   Wed Sep 26 23:05:47 2018 +0100

    staging: wlan-ng: rename DIDmsg_p2req_readpda_resultcode in p80211metadef.h
    
    Rename DIDmsg_p2req_readpda_resultcode in p80211metadef.h to
    DIDMSG_P2REQ_READPDA_RESULTCODE to fix "Avoid CamelCase" message from
    checkpatch and conform to the coding style guidelines.
    
    Signed-off-by: Tim Collier <osdevtc@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/prism2fw.c b/drivers/staging/wlan-ng/prism2fw.c
index f85e2fea4544..d8f66dd13fc8 100644
--- a/drivers/staging/wlan-ng/prism2fw.c
+++ b/drivers/staging/wlan-ng/prism2fw.c
@@ -793,7 +793,7 @@ static int read_cardpda(struct pda *pda, struct wlandevice *wlandev)
 	msg->pda.did = DIDMSG_P2REQ_READPDA_PDA;
 	msg->pda.len = HFA384x_PDA_LEN_MAX;
 	msg->pda.status = P80211ENUM_msgitem_status_no_value;
-	msg->resultcode.did = DIDmsg_p2req_readpda_resultcode;
+	msg->resultcode.did = DIDMSG_P2REQ_READPDA_RESULTCODE;
 	msg->resultcode.len = sizeof(u32);
 	msg->resultcode.status = P80211ENUM_msgitem_status_no_value;
 

commit 5a16b37eb1392936de66731d77034d765bf36018
Author: Tim Collier <osdevtc@gmail.com>
Date:   Wed Sep 26 23:05:45 2018 +0100

    staging: wlan-ng: rename DIDmsg_p2req_readpda_pda in p80211metadef.h
    
    Rename DIDmsg_p2req_readpda_pda in p80211metadef.h to
    DIDMSG_P2REQ_READPDA_PDA to fix "Avoid CamelCase" message from
    checkpatch and conform to the coding style guidelines.
    
    Signed-off-by: Tim Collier <osdevtc@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/prism2fw.c b/drivers/staging/wlan-ng/prism2fw.c
index b33eac4dd57e..f85e2fea4544 100644
--- a/drivers/staging/wlan-ng/prism2fw.c
+++ b/drivers/staging/wlan-ng/prism2fw.c
@@ -790,7 +790,7 @@ static int read_cardpda(struct pda *pda, struct wlandevice *wlandev)
 	msg->msgcode = DIDMSG_P2REQ_READPDA;
 	msg->msglen = sizeof(msg);
 	strcpy(msg->devname, wlandev->name);
-	msg->pda.did = DIDmsg_p2req_readpda_pda;
+	msg->pda.did = DIDMSG_P2REQ_READPDA_PDA;
 	msg->pda.len = HFA384x_PDA_LEN_MAX;
 	msg->pda.status = P80211ENUM_msgitem_status_no_value;
 	msg->resultcode.did = DIDmsg_p2req_readpda_resultcode;

commit f9f0e98fee80ca2b285b230418444e49120bdaa1
Author: Tim Collier <osdevtc@gmail.com>
Date:   Wed Sep 26 23:05:44 2018 +0100

    staging: wlan-ng: rename DIDmsg_p2req_readpda in p80211metadef.h
    
    Rename DIDmsg_p2req_readpda in p80211metadef.h to DIDMSG_P2REQ_READPDA
    to fix "Avoid CamelCase" message from checkpatch and conform to the
    coding style guidelines.
    
    Signed-off-by: Tim Collier <osdevtc@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/prism2fw.c b/drivers/staging/wlan-ng/prism2fw.c
index 511cf5efca63..b33eac4dd57e 100644
--- a/drivers/staging/wlan-ng/prism2fw.c
+++ b/drivers/staging/wlan-ng/prism2fw.c
@@ -787,7 +787,7 @@ static int read_cardpda(struct pda *pda, struct wlandevice *wlandev)
 		return -ENOMEM;
 
 	/* set up the msg */
-	msg->msgcode = DIDmsg_p2req_readpda;
+	msg->msgcode = DIDMSG_P2REQ_READPDA;
 	msg->msglen = sizeof(msg);
 	strcpy(msg->devname, wlandev->name);
 	msg->pda.did = DIDmsg_p2req_readpda_pda;

commit 42ccd88bcde7accab3c8f1a1ae3181d5451e3bf7
Author: Tim Collier <osdevtc@gmail.com>
Date:   Wed Sep 26 23:05:31 2018 +0100

    staging: wlan-ng: rename DIDmsg_dot11req_mibget_resultcode in p80211metadef.h
    
    Rename DIDmsg_dot11req_mibget_resultcode in p80211metadef.h to
    DIDMSG_DOT11REQ_MIBGET_RESULTCODE to fix "Avoid CamelCase" message
    from checkpatch and conform to the coding style guidelines.
    
    Signed-off-by: Tim Collier <osdevtc@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/prism2fw.c b/drivers/staging/wlan-ng/prism2fw.c
index a2939969f0f7..511cf5efca63 100644
--- a/drivers/staging/wlan-ng/prism2fw.c
+++ b/drivers/staging/wlan-ng/prism2fw.c
@@ -300,7 +300,7 @@ static int prism2_fwapply(const struct ihex_binrec *rfptr,
 
 	getmsg.mibattribute.did = DIDMSG_DOT11REQ_MIBGET_MIBATTRIBUTE;
 	getmsg.mibattribute.status = P80211ENUM_msgitem_status_data_ok;
-	getmsg.resultcode.did = DIDmsg_dot11req_mibget_resultcode;
+	getmsg.resultcode.did = DIDMSG_DOT11REQ_MIBGET_RESULTCODE;
 	getmsg.resultcode.status = P80211ENUM_msgitem_status_no_value;
 
 	item = (struct p80211itemd *)getmsg.mibattribute.data;

commit 86ec606270426d07dee6dfc15a7c6397de9cc492
Author: Tim Collier <osdevtc@gmail.com>
Date:   Wed Sep 26 23:05:30 2018 +0100

    staging: wlan-ng: rename DIDmsg_dot11req_mibget_mibattribute in p80211metadef.h
    
    Rename DIDmsg_dot11req_mibget_mibattribute in p80211metadef.h to
    DIDMSG_DOT11REQ_MIBGET_MIBATTRIBUTE to fix "Avoid CamelCase" message
    from checkpatch and conform to the coding style guidelines.
    
    Signed-off-by: Tim Collier <osdevtc@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/prism2fw.c b/drivers/staging/wlan-ng/prism2fw.c
index 375e30f34041..a2939969f0f7 100644
--- a/drivers/staging/wlan-ng/prism2fw.c
+++ b/drivers/staging/wlan-ng/prism2fw.c
@@ -298,7 +298,7 @@ static int prism2_fwapply(const struct ihex_binrec *rfptr,
 	getmsg.msglen = sizeof(getmsg);
 	strcpy(getmsg.devname, wlandev->name);
 
-	getmsg.mibattribute.did = DIDmsg_dot11req_mibget_mibattribute;
+	getmsg.mibattribute.did = DIDMSG_DOT11REQ_MIBGET_MIBATTRIBUTE;
 	getmsg.mibattribute.status = P80211ENUM_msgitem_status_data_ok;
 	getmsg.resultcode.did = DIDmsg_dot11req_mibget_resultcode;
 	getmsg.resultcode.status = P80211ENUM_msgitem_status_no_value;

commit 08ac857363f17df313d9d177e5646ab3c7cd354f
Author: Tim Collier <osdevtc@gmail.com>
Date:   Wed Sep 26 23:05:29 2018 +0100

    staging: wlan-ng: rename DIDmsg_dot11req_mibget in p80211metadef.h
    
    Rename DIDmsg_dot11req_mibget in p80211metadef.h to
    DIDMSG_DOT11REQ_MIBGET to fix "Avoid CamelCase" message from
    checkpatch and conform to the coding style guidelines.
    
    Signed-off-by: Tim Collier <osdevtc@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/prism2fw.c b/drivers/staging/wlan-ng/prism2fw.c
index ddcaac648bd5..375e30f34041 100644
--- a/drivers/staging/wlan-ng/prism2fw.c
+++ b/drivers/staging/wlan-ng/prism2fw.c
@@ -294,7 +294,7 @@ static int prism2_fwapply(const struct ihex_binrec *rfptr,
 
 	/* read the card's PRI-SUP */
 	memset(&getmsg, 0, sizeof(getmsg));
-	getmsg.msgcode = DIDmsg_dot11req_mibget;
+	getmsg.msgcode = DIDMSG_DOT11REQ_MIBGET;
 	getmsg.msglen = sizeof(getmsg);
 	strcpy(getmsg.devname, wlandev->name);
 

commit 8627995cf711ed0e9ff84cf34b5b389fa01fa4c9
Author: Tim Collier <osdevtc@gmail.com>
Date:   Tue Aug 28 20:26:12 2018 +0100

    staging: wlan-ng: remove redundant code in "#if 0" blocks
    
    Remove two blocks of code that checkpatch identified as redundant
    because they were enclosed in "#if...#endif". In the case of
    prism2fw.c the associated "TODO" comment was retained.
    
    Signed-off-by: Tim Collier <osdevtc@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/prism2fw.c b/drivers/staging/wlan-ng/prism2fw.c
index 4fb91294570d..ddcaac648bd5 100644
--- a/drivers/staging/wlan-ng/prism2fw.c
+++ b/drivers/staging/wlan-ng/prism2fw.c
@@ -706,7 +706,7 @@ static int plugimage(struct imgchunk *fchunk, unsigned int nfchunks,
 			pr_warn("warning: Failed to find PDR for plugrec 0x%04x.\n",
 				s3plug[i].itemcode);
 			continue;	/* and move on to the next PDR */
-#if 0
+
 			/* MSM: They swear that unless it's the MAC address,
 			 * the serial number, or the TX calibration records,
 			 * then there's reasonable defaults in the f/w
@@ -714,9 +714,6 @@ static int plugimage(struct imgchunk *fchunk, unsigned int nfchunks,
 			 * should only be a warning, not fatal.
 			 * TODO: add fatals for the PDRs mentioned above.
 			 */
-			result = 1;
-			continue;
-#endif
 		}
 
 		/* Validate plug len against PDR len */

commit 0148f49c118ad786fedf64621ac0037475a027fa
Author: Tim Collier <osdevtc@gmail.com>
Date:   Fri Jul 6 20:38:13 2018 +0100

    staging: wlan-ng: fix expression continuation in prism2fw.c
    
    checkpatch reports "CHECK: Logical continuations should be on the
    previous line" when a continuation line begins with an
    operator. Reformat the code so that the operator appears at the end of
    the line being continued.
    
    Signed-off-by: Tim Collier <osdevtc@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/prism2fw.c b/drivers/staging/wlan-ng/prism2fw.c
index 5860d0d65841..4fb91294570d 100644
--- a/drivers/staging/wlan-ng/prism2fw.c
+++ b/drivers/staging/wlan-ng/prism2fw.c
@@ -1189,9 +1189,10 @@ static int validate_identity(void)
 			/* PRI compat range */
 			if ((s3info[i].info.compat.role == 1) &&
 			    (s3info[i].info.compat.id == 3)) {
-				if ((s3info[i].info.compat.bottom > priid.top)
-				    || (s3info[i].info.compat.top <
-					priid.bottom)) {
+				if ((s3info[i].info.compat.bottom >
+				     priid.top) ||
+				    (s3info[i].info.compat.top <
+				     priid.bottom)) {
 					result = 3;
 				}
 			}

commit f7056d335d919c15dc9ae26923969673da846e37
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Nov 7 21:07:51 2017 +0100

    staging: wlan-ng: add SPDX identifiers to all wlan-ng driver files
    
    It's good to have SPDX identifiers in all files to make it easier to
    audit the kernel tree for correct licenses.
    
    Update the wlan-ng driver files with the correct SPDX license identifier
    based on the license text in the file itself.  The SPDX identifier is a
    legally binding shorthand, which can be used instead of the full boiler
    plate text.
    
    This work is based on a script and data from Thomas Gleixner, Philippe
    Ombredanne, and Kate Stewart.
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: Philippe Ombredanne <pombredanne@nexb.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/prism2fw.c b/drivers/staging/wlan-ng/prism2fw.c
index 344bec8cc31b..5860d0d65841 100644
--- a/drivers/staging/wlan-ng/prism2fw.c
+++ b/drivers/staging/wlan-ng/prism2fw.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: (GPL-2.0 OR MPL-1.1)
 /* from src/prism2/download/prism2dl.c
  *
  * utility for downloading prism2 images moved into kernelspace

commit d6d6fc83f822d8e0f6f38a046b2db13941be3dc0
Author: Simo Koskinen <koskisoft@gmail.com>
Date:   Tue Jul 18 10:23:45 2017 +0200

    Staging: wlan-ng: Fixing coding style warnings
    
    Removes following warnings found by checkpatch.pl script:
    
    WARNING: Prefer using '"%s...", __func__' to using 'xxx',
    this function's name, in a string
    
    Signed-off-by: Simo Koskinen <koskisoft@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/prism2fw.c b/drivers/staging/wlan-ng/prism2fw.c
index 1a0c786c7616..344bec8cc31b 100644
--- a/drivers/staging/wlan-ng/prism2fw.c
+++ b/drivers/staging/wlan-ng/prism2fw.c
@@ -1016,7 +1016,8 @@ static int writeimage(struct wlandevice *wlandev, struct imgchunk *fchunk,
 		kfree(rstmsg);
 		kfree(rwrmsg);
 		netdev_err(wlandev->netdev,
-			   "writeimage: no memory for firmware download, aborting download\n");
+			   "%s: no memory for firmware download, aborting download\n",
+			   __func__);
 		return -ENOMEM;
 	}
 
@@ -1058,15 +1059,15 @@ static int writeimage(struct wlandevice *wlandev, struct imgchunk *fchunk,
 	result = prism2mgmt_ramdl_state(wlandev, rstmsg);
 	if (result) {
 		netdev_err(wlandev->netdev,
-			   "writeimage state enable failed w/ result=%d, aborting download\n",
-			   result);
+			   "%s state enable failed w/ result=%d, aborting download\n",
+			   __func__, result);
 		goto free_result;
 	}
 	resultcode = rstmsg->resultcode.data;
 	if (resultcode != P80211ENUM_resultcode_success) {
 		netdev_err(wlandev->netdev,
-			   "writeimage()->xxxdl_state msg indicates failure, w/ resultcode=%d, aborting download.\n",
-			   resultcode);
+			   "%s()->xxxdl_state msg indicates failure, w/ resultcode=%d, aborting download.\n",
+			   __func__, resultcode);
 		result = 1;
 		goto free_result;
 	}
@@ -1102,14 +1103,14 @@ static int writeimage(struct wlandevice *wlandev, struct imgchunk *fchunk,
 			/* Check the results */
 			if (result) {
 				netdev_err(wlandev->netdev,
-					   "writeimage chunk write failed w/ result=%d, aborting download\n",
-					   result);
+					   "%s chunk write failed w/ result=%d, aborting download\n",
+					   __func__, result);
 				goto free_result;
 			}
 			resultcode = rstmsg->resultcode.data;
 			if (resultcode != P80211ENUM_resultcode_success) {
-				pr_err("writeimage()->xxxdl_write msg indicates failure, w/ resultcode=%d, aborting download.\n",
-				       resultcode);
+				pr_err("%s()->xxxdl_write msg indicates failure, w/ resultcode=%d, aborting download.\n",
+				       __func__, resultcode);
 				result = 1;
 				goto free_result;
 			}
@@ -1124,15 +1125,15 @@ static int writeimage(struct wlandevice *wlandev, struct imgchunk *fchunk,
 	result = prism2mgmt_ramdl_state(wlandev, rstmsg);
 	if (result) {
 		netdev_err(wlandev->netdev,
-			   "writeimage state disable failed w/ result=%d, aborting download\n",
-			   result);
+			   "%s state disable failed w/ result=%d, aborting download\n",
+			   __func__, result);
 		goto free_result;
 	}
 	resultcode = rstmsg->resultcode.data;
 	if (resultcode != P80211ENUM_resultcode_success) {
 		netdev_err(wlandev->netdev,
-			   "writeimage()->xxxdl_state msg indicates failure, w/ resultcode=%d, aborting download.\n",
-			   resultcode);
+			   "%s()->xxxdl_state msg indicates failure, w/ resultcode=%d, aborting download.\n",
+			   __func__, resultcode);
 		result = 1;
 		goto free_result;
 	}

commit b1bb2e33ae1fa93a8e00c2625fa344e6e6c234a6
Author: Thibaut SAUTEREAU <thibaut.sautereau@telecom-sudparis.eu>
Date:   Fri May 12 11:37:54 2017 +0200

    staging: wlan-ng: convert endianness in situ for prism2fw
    
    Fix several sparse warnings about casts to restricted
    little-endian.
    
    Signed-off-by: Thibaut SAUTEREAU <thibaut.sautereau@telecom-sudparis.eu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/prism2fw.c b/drivers/staging/wlan-ng/prism2fw.c
index afd877fb4557..1a0c786c7616 100644
--- a/drivers/staging/wlan-ng/prism2fw.c
+++ b/drivers/staging/wlan-ng/prism2fw.c
@@ -617,28 +617,28 @@ static int mkpdrlist(struct pda *pda)
 		    HFA384x_PDR_NICID) {
 			memcpy(&nicid, &pda->rec[pda->nrec]->data.nicid,
 			       sizeof(nicid));
-			nicid.id = le16_to_cpu(nicid.id);
-			nicid.variant = le16_to_cpu(nicid.variant);
-			nicid.major = le16_to_cpu(nicid.major);
-			nicid.minor = le16_to_cpu(nicid.minor);
+			le16_to_cpus(&nicid.id);
+			le16_to_cpus(&nicid.variant);
+			le16_to_cpus(&nicid.major);
+			le16_to_cpus(&nicid.minor);
 		}
 		if (le16_to_cpu(pda->rec[pda->nrec]->code) ==
 		    HFA384x_PDR_MFISUPRANGE) {
 			memcpy(&rfid, &pda->rec[pda->nrec]->data.mfisuprange,
 			       sizeof(rfid));
-			rfid.id = le16_to_cpu(rfid.id);
-			rfid.variant = le16_to_cpu(rfid.variant);
-			rfid.bottom = le16_to_cpu(rfid.bottom);
-			rfid.top = le16_to_cpu(rfid.top);
+			le16_to_cpus(&rfid.id);
+			le16_to_cpus(&rfid.variant);
+			le16_to_cpus(&rfid.bottom);
+			le16_to_cpus(&rfid.top);
 		}
 		if (le16_to_cpu(pda->rec[pda->nrec]->code) ==
 		    HFA384x_PDR_CFISUPRANGE) {
 			memcpy(&macid, &pda->rec[pda->nrec]->data.cfisuprange,
 			       sizeof(macid));
-			macid.id = le16_to_cpu(macid.id);
-			macid.variant = le16_to_cpu(macid.variant);
-			macid.bottom = le16_to_cpu(macid.bottom);
-			macid.top = le16_to_cpu(macid.top);
+			le16_to_cpus(&macid.id);
+			le16_to_cpus(&macid.variant);
+			le16_to_cpus(&macid.bottom);
+			le16_to_cpus(&macid.top);
 		}
 
 		(pda->nrec)++;

commit 76b4580bf4eaf1c7d5a603c0da405e72a89b3927
Author: Maciek Borzecki <maciek.borzecki@gmail.com>
Date:   Sat Apr 8 16:04:42 2017 +0200

    staging wlan-ng: fix type mismatch warnings in mkpdrlist()
    
    struct  hfa384x_pdrec len and code fields as clearly little endian,
    mark both fields as such. pda->buf is also clearly little endian.
    
    Fixes sparse warnings:
    
      drivers/staging/wlan-ng/prism2fw.c:613:16: warning: cast to restricted __le16
      drivers/staging/wlan-ng/prism2fw.c:616:21: warning: cast to restricted __le16
      drivers/staging/wlan-ng/prism2fw.c:625:21: warning: cast to restricted __le16
    
    Signed-off-by: Maciek Borzecki <maciek.borzecki@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/prism2fw.c b/drivers/staging/wlan-ng/prism2fw.c
index 2e349f87e738..afd877fb4557 100644
--- a/drivers/staging/wlan-ng/prism2fw.c
+++ b/drivers/staging/wlan-ng/prism2fw.c
@@ -604,7 +604,7 @@ static int mkimage(struct imgchunk *clist, unsigned int *ccnt)
  */
 static int mkpdrlist(struct pda *pda)
 {
-	u16 *pda16 = (u16 *)pda->buf;
+	__le16 *pda16 = (__le16 *)pda->buf;
 	int curroff;		/* in 'words' */
 
 	pda->nrec = 0;

commit b586fbd3968a3273c9998796c3c2f6cd9f1948dd
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Mon Nov 7 18:55:28 2016 +0100

    staging: wlan-ng: remove unnecessary parenthesis in prism2fw.c
    
    This patch removes unnecessary parentheses in different statements of
    prism2fw.c file in order to to comply with the standard kernel
    coding style.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/prism2fw.c b/drivers/staging/wlan-ng/prism2fw.c
index 2ea96bef8022..2e349f87e738 100644
--- a/drivers/staging/wlan-ng/prism2fw.c
+++ b/drivers/staging/wlan-ng/prism2fw.c
@@ -611,7 +611,7 @@ static int mkpdrlist(struct pda *pda)
 	curroff = 0;
 	while (curroff < (HFA384x_PDA_LEN_MAX / 2 - 1) &&
 	       le16_to_cpu(pda16[curroff + 1]) != HFA384x_PDR_END_OF_PDA) {
-		pda->rec[pda->nrec] = (struct hfa384x_pdrec *)&(pda16[curroff]);
+		pda->rec[pda->nrec] = (struct hfa384x_pdrec *)&pda16[curroff];
 
 		if (le16_to_cpu(pda->rec[pda->nrec]->code) ==
 		    HFA384x_PDR_NICID) {
@@ -649,7 +649,7 @@ static int mkpdrlist(struct pda *pda)
 		       curroff, pda->nrec);
 		return 1;
 	}
-	pda->rec[pda->nrec] = (struct hfa384x_pdrec *)&(pda16[curroff]);
+	pda->rec[pda->nrec] = (struct hfa384x_pdrec *)&pda16[curroff];
 	(pda->nrec)++;
 	return 0;
 }
@@ -754,7 +754,7 @@ static int plugimage(struct imgchunk *fchunk, unsigned int nfchunks,
 			memset(dest, 0, s3plug[i].len);
 			strncpy(dest, PRISM2_USB_FWFILE, s3plug[i].len - 1);
 		} else {	/* plug a PDR */
-			memcpy(dest, &(pda->rec[j]->data), s3plug[i].len);
+			memcpy(dest, &pda->rec[j]->data, s3plug[i].len);
 		}
 	}
 	return result;
@@ -950,7 +950,7 @@ static int read_fwfile(const struct ihex_binrec *record)
 				return 1;
 			}
 
-			tmpinfo = (u16 *)&(s3info[ns3info].info.version);
+			tmpinfo = (u16 *)&s3info[ns3info].info.version;
 			pr_debug("            info=");
 			for (i = 0; i < s3info[ns3info].len - 1; i++) {
 				tmpinfo[i] = *(ptr16 + 2 + i);

commit 98c1a778def031a3c09634215f915203bdd2fb9c
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Mon Nov 7 18:55:27 2016 +0100

    staging: wlan-ng: remove unnecessary blank lines in prism2fw.c
    
    This patch removes unnecessary blank lines in prism2fw.c file to
    comply with the standard kernel coding style.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/prism2fw.c b/drivers/staging/wlan-ng/prism2fw.c
index 68c894bf5ffc..2ea96bef8022 100644
--- a/drivers/staging/wlan-ng/prism2fw.c
+++ b/drivers/staging/wlan-ng/prism2fw.c
@@ -443,7 +443,6 @@ static int crcimage(struct imgchunk *fchunk, unsigned int nfchunks,
 		dest = fchunk[c].data + chunkoff;
 		*dest = 0xde;
 		*(dest + 1) = 0xc0;
-
 	}
 	return result;
 }
@@ -469,7 +468,6 @@ static void free_chunks(struct imgchunk *fchunk, unsigned int *nfchunks)
 
 	*nfchunks = 0;
 	memset(fchunk, 0, sizeof(*fchunk));
-
 }
 
 /*----------------------------------------------------------------
@@ -645,7 +643,6 @@ static int mkpdrlist(struct pda *pda)
 
 		(pda->nrec)++;
 		curroff += le16_to_cpu(pda16[curroff]) + 1;
-
 	}
 	if (curroff >= (HFA384x_PDA_LEN_MAX / 2 - 1)) {
 		pr_err("no end record found or invalid lengths in PDR data, exiting. %x %d\n",
@@ -761,7 +758,6 @@ static int plugimage(struct imgchunk *fchunk, unsigned int nfchunks,
 		}
 	}
 	return result;
-
 }
 
 /*----------------------------------------------------------------
@@ -890,7 +886,6 @@ static int read_fwfile(const struct ihex_binrec *record)
 	pr_debug("Reading fw file ...\n");
 
 	while (record) {
-
 		rcnt++;
 
 		len = be16_to_cpu(record->len);
@@ -1118,7 +1113,6 @@ static int writeimage(struct wlandevice *wlandev, struct imgchunk *fchunk,
 				result = 1;
 				goto free_result;
 			}
-
 		}
 	}
 

commit 86605dd0e7e1c11087594b67552f850a6684eb73
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Mon Nov 7 18:55:26 2016 +0100

    staging: wlan-ng: fix parenthesis alignment in prism2fw.c
    
    This patch fix open parenthesis alignment matching in prism2fw.c file
    to comply with the standard kernel coding style.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/prism2fw.c b/drivers/staging/wlan-ng/prism2fw.c
index d90b1f47a558..68c894bf5ffc 100644
--- a/drivers/staging/wlan-ng/prism2fw.c
+++ b/drivers/staging/wlan-ng/prism2fw.c
@@ -161,7 +161,7 @@ static struct hfa384x_caplevel priid;
 /* Local Function Declarations */
 
 static int prism2_fwapply(const struct ihex_binrec *rfptr,
-struct wlandevice *wlandev);
+			  struct wlandevice *wlandev);
 
 static int read_fwfile(const struct ihex_binrec *rfptr);
 
@@ -172,13 +172,15 @@ static int read_cardpda(struct pda *pda, struct wlandevice *wlandev);
 static int mkpdrlist(struct pda *pda);
 
 static int plugimage(struct imgchunk *fchunk, unsigned int nfchunks,
-	      struct s3plugrec *s3plug, unsigned int ns3plug, struct pda *pda);
+		     struct s3plugrec *s3plug, unsigned int ns3plug,
+		     struct pda *pda);
 
 static int crcimage(struct imgchunk *fchunk, unsigned int nfchunks,
-	     struct s3crcrec *s3crc, unsigned int ns3crc);
+		    struct s3crcrec *s3crc, unsigned int ns3crc);
 
 static int writeimage(struct wlandevice *wlandev, struct imgchunk *fchunk,
-	       unsigned int nfchunks);
+		      unsigned int nfchunks);
+
 static void free_chunks(struct imgchunk *fchunk, unsigned int *nfchunks);
 
 static void free_srecs(void);
@@ -207,13 +209,13 @@ static int prism2_fwtry(struct usb_device *udev, struct wlandevice *wlandev)
 	const struct firmware *fw_entry = NULL;
 
 	netdev_info(wlandev->netdev, "prism2_usb: Checking for firmware %s\n",
-	       PRISM2_USB_FWFILE);
+		    PRISM2_USB_FWFILE);
 	if (request_ihex_firmware(&fw_entry,
 				  PRISM2_USB_FWFILE, &udev->dev) != 0) {
 		netdev_info(wlandev->netdev,
-		       "prism2_usb: Firmware not available, but not essential\n");
+			    "prism2_usb: Firmware not available, but not essential\n");
 		netdev_info(wlandev->netdev,
-		       "prism2_usb: can continue to use card anyway.\n");
+			    "prism2_usb: can continue to use card anyway.\n");
 		return 1;
 	}
 
@@ -397,7 +399,7 @@ static int prism2_fwapply(const struct ihex_binrec *rfptr,
  *----------------------------------------------------------------
  */
 static int crcimage(struct imgchunk *fchunk, unsigned int nfchunks,
-	     struct s3crcrec *s3crc, unsigned int ns3crc)
+		    struct s3crcrec *s3crc, unsigned int ns3crc)
 {
 	int result = 0;
 	int i;
@@ -674,7 +676,8 @@ static int mkpdrlist(struct pda *pda)
  *----------------------------------------------------------------
  */
 static int plugimage(struct imgchunk *fchunk, unsigned int nfchunks,
-	      struct s3plugrec *s3plug, unsigned int ns3plug, struct pda *pda)
+		     struct s3plugrec *s3plug, unsigned int ns3plug,
+		     struct pda *pda)
 {
 	int result = 0;
 	int i;			/* plug index */
@@ -902,8 +905,8 @@ static int read_fwfile(const struct ihex_binrec *record)
 		case S3ADDR_START:
 			startaddr = *ptr32;
 			pr_debug("  S7 start addr, record=%d addr=0x%08x\n",
-				      rcnt,
-				      startaddr);
+				 rcnt,
+				 startaddr);
 			break;
 		case S3ADDR_PLUG:
 			s3plug[ns3plug].itemcode = *ptr32;
@@ -911,10 +914,10 @@ static int read_fwfile(const struct ihex_binrec *record)
 			s3plug[ns3plug].len = *(ptr32 + 2);
 
 			pr_debug("  S3 plugrec, record=%d itemcode=0x%08x addr=0x%08x len=%d\n",
-				      rcnt,
-				      s3plug[ns3plug].itemcode,
-				      s3plug[ns3plug].addr,
-				      s3plug[ns3plug].len);
+				 rcnt,
+				 s3plug[ns3plug].itemcode,
+				 s3plug[ns3plug].addr,
+				 s3plug[ns3plug].len);
 
 			ns3plug++;
 			if (ns3plug == S3PLUG_MAX) {
@@ -928,10 +931,10 @@ static int read_fwfile(const struct ihex_binrec *record)
 			s3crc[ns3crc].dowrite = *(ptr32 + 2);
 
 			pr_debug("  S3 crcrec, record=%d addr=0x%08x len=%d write=0x%08x\n",
-				      rcnt,
-				      s3crc[ns3crc].addr,
-				      s3crc[ns3crc].len,
-				      s3crc[ns3crc].dowrite);
+				 rcnt,
+				 s3crc[ns3crc].addr,
+				 s3crc[ns3crc].len,
+				 s3crc[ns3crc].dowrite);
 			ns3crc++;
 			if (ns3crc == S3CRC_MAX) {
 				pr_err("S3 crcrec limit reached - aborting\n");
@@ -943,9 +946,9 @@ static int read_fwfile(const struct ihex_binrec *record)
 			s3info[ns3info].type = *(ptr16 + 1);
 
 			pr_debug("  S3 inforec, record=%d len=0x%04x type=0x%04x\n",
-				      rcnt,
-				      s3info[ns3info].len,
-				      s3info[ns3info].type);
+				 rcnt,
+				 s3info[ns3info].len,
+				 s3info[ns3info].type);
 			if (((s3info[ns3info].len - 1) * sizeof(u16)) >
 			   sizeof(s3info[ns3info].info)) {
 				pr_err("S3 inforec length too long - aborting\n");
@@ -999,7 +1002,7 @@ static int read_fwfile(const struct ihex_binrec *record)
  *----------------------------------------------------------------
  */
 static int writeimage(struct wlandevice *wlandev, struct imgchunk *fchunk,
-	       unsigned int nfchunks)
+		      unsigned int nfchunks)
 {
 	int result = 0;
 	struct p80211msg_p2req_ramdl_state *rstmsg;

commit cfea8abf67e57dbe430338895fbb127374672da1
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Sun Oct 9 17:29:22 2016 +0200

    staging: wlan-ng: get memory from kernel allocators instead of big static buffer
    
    This patch fix the following sparse warnings in prism2fw.c:
    warning: memset with byte count of 120000
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/prism2fw.c b/drivers/staging/wlan-ng/prism2fw.c
index 2454a787b177..d90b1f47a558 100644
--- a/drivers/staging/wlan-ng/prism2fw.c
+++ b/drivers/staging/wlan-ng/prism2fw.c
@@ -124,7 +124,7 @@ struct imgchunk {
 
 /* Data records */
 static unsigned int ns3data;
-static struct s3datarec s3data[S3DATA_MAX];
+static struct s3datarec *s3data;
 
 /* Plug records */
 static unsigned int ns3plug;
@@ -250,7 +250,12 @@ static int prism2_fwapply(const struct ihex_binrec *rfptr,
 
 	/* Initialize the data structures */
 	ns3data = 0;
-	memset(s3data, 0, sizeof(s3data));
+	s3data = kcalloc(S3DATA_MAX, sizeof(*s3data), GFP_KERNEL);
+	if (!s3data) {
+		result = -ENOMEM;
+		goto out;
+	}
+
 	ns3plug = 0;
 	memset(s3plug, 0, sizeof(s3plug));
 	ns3crc = 0;
@@ -480,7 +485,7 @@ static void free_chunks(struct imgchunk *fchunk, unsigned int *nfchunks)
 static void free_srecs(void)
 {
 	ns3data = 0;
-	memset(s3data, 0, sizeof(s3data));
+	kfree(s3data);
 	ns3plug = 0;
 	memset(s3plug, 0, sizeof(s3plug));
 	ns3crc = 0;

commit 33630b00183d6e1aa0b196e12d5fdb55a44749c1
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Sun Oct 9 17:10:32 2016 +0200

    staging: wlan-ng: fix block comment warnings in prism2fw.c
    
    This patch fix the following checkpatch.pl warnings in prism2fw.c
    
    WARNING: Block comments should align the * on each line
    WARNING: Block comments use a trailing */ on a separate line
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/prism2fw.c b/drivers/staging/wlan-ng/prism2fw.c
index 96aa21188669..2454a787b177 100644
--- a/drivers/staging/wlan-ng/prism2fw.c
+++ b/drivers/staging/wlan-ng/prism2fw.c
@@ -1,49 +1,49 @@
 /* from src/prism2/download/prism2dl.c
-*
-* utility for downloading prism2 images moved into kernelspace
-*
-* Copyright (C) 1999 AbsoluteValue Systems, Inc.  All Rights Reserved.
-* --------------------------------------------------------------------
-*
-* linux-wlan
-*
-*   The contents of this file are subject to the Mozilla Public
-*   License Version 1.1 (the "License"); you may not use this file
-*   except in compliance with the License. You may obtain a copy of
-*   the License at http://www.mozilla.org/MPL/
-*
-*   Software distributed under the License is distributed on an "AS
-*   IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
-*   implied. See the License for the specific language governing
-*   rights and limitations under the License.
-*
-*   Alternatively, the contents of this file may be used under the
-*   terms of the GNU Public License version 2 (the "GPL"), in which
-*   case the provisions of the GPL are applicable instead of the
-*   above.  If you wish to allow the use of your version of this file
-*   only under the terms of the GPL and not to allow others to use
-*   your version of this file under the MPL, indicate your decision
-*   by deleting the provisions above and replace them with the notice
-*   and other provisions required by the GPL.  If you do not delete
-*   the provisions above, a recipient may use your version of this
-*   file under either the MPL or the GPL.
-*
-* --------------------------------------------------------------------
-*
-* Inquiries regarding the linux-wlan Open Source project can be
-* made directly to:
-*
-* AbsoluteValue Systems Inc.
-* info@linux-wlan.com
-* http://www.linux-wlan.com
-*
-* --------------------------------------------------------------------
-*
-* Portions of the development of this software were funded by
-* Intersil Corporation as part of PRISM(R) chipset product development.
-*
-* --------------------------------------------------------------------
-*/
+ *
+ * utility for downloading prism2 images moved into kernelspace
+ *
+ * Copyright (C) 1999 AbsoluteValue Systems, Inc.  All Rights Reserved.
+ * --------------------------------------------------------------------
+ *
+ * linux-wlan
+ *
+ *   The contents of this file are subject to the Mozilla Public
+ *   License Version 1.1 (the "License"); you may not use this file
+ *   except in compliance with the License. You may obtain a copy of
+ *   the License at http://www.mozilla.org/MPL/
+ *
+ *   Software distributed under the License is distributed on an "AS
+ *   IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ *   implied. See the License for the specific language governing
+ *   rights and limitations under the License.
+ *
+ *   Alternatively, the contents of this file may be used under the
+ *   terms of the GNU Public License version 2 (the "GPL"), in which
+ *   case the provisions of the GPL are applicable instead of the
+ *   above.  If you wish to allow the use of your version of this file
+ *   only under the terms of the GPL and not to allow others to use
+ *   your version of this file under the MPL, indicate your decision
+ *   by deleting the provisions above and replace them with the notice
+ *   and other provisions required by the GPL.  If you do not delete
+ *   the provisions above, a recipient may use your version of this
+ *   file under either the MPL or the GPL.
+ *
+ * --------------------------------------------------------------------
+ *
+ * Inquiries regarding the linux-wlan Open Source project can be
+ * made directly to:
+ *
+ * AbsoluteValue Systems Inc.
+ * info@linux-wlan.com
+ * http://www.linux-wlan.com
+ *
+ * --------------------------------------------------------------------
+ *
+ * Portions of the development of this software were funded by
+ * Intersil Corporation as part of PRISM(R) chipset product development.
+ *
+ * --------------------------------------------------------------------
+ */
 
 /*================================================================*/
 /* System Includes */
@@ -189,18 +189,19 @@ static int validate_identity(void);
 /* Function Definitions */
 
 /*----------------------------------------------------------------
-* prism2_fwtry
-*
-* Try and get firmware into memory
-*
-* Arguments:
-*	udev	usb device structure
-*	wlandev wlan device structure
-*
-* Returns:
-*	0	- success
-*	~0	- failure
-----------------------------------------------------------------*/
+ * prism2_fwtry
+ *
+ * Try and get firmware into memory
+ *
+ * Arguments:
+ *	udev	usb device structure
+ *	wlandev wlan device structure
+ *
+ * Returns:
+ *	0	- success
+ *	~0	- failure
+ *----------------------------------------------------------------
+ */
 static int prism2_fwtry(struct usb_device *udev, struct wlandevice *wlandev)
 {
 	const struct firmware *fw_entry = NULL;
@@ -226,18 +227,19 @@ static int prism2_fwtry(struct usb_device *udev, struct wlandevice *wlandev)
 }
 
 /*----------------------------------------------------------------
-* prism2_fwapply
-*
-* Apply the firmware loaded into memory
-*
-* Arguments:
-*	rfptr	firmware image in kernel memory
-*	wlandev device
-*
-* Returns:
-*	0	- success
-*	~0	- failure
-----------------------------------------------------------------*/
+ * prism2_fwapply
+ *
+ * Apply the firmware loaded into memory
+ *
+ * Arguments:
+ *	rfptr	firmware image in kernel memory
+ *	wlandev device
+ *
+ * Returns:
+ *	0	- success
+ *	~0	- failure
+ *----------------------------------------------------------------
+ */
 static int prism2_fwapply(const struct ihex_binrec *rfptr,
 			  struct wlandevice *wlandev)
 {
@@ -372,22 +374,23 @@ static int prism2_fwapply(const struct ihex_binrec *rfptr,
 }
 
 /*----------------------------------------------------------------
-* crcimage
-*
-* Adds a CRC16 in the two bytes prior to each block identified by
-* an S3 CRC record.  Currently, we don't actually do a CRC we just
-* insert the value 0xC0DE in hfa384x order.
-*
-* Arguments:
-*	fchunk		Array of image chunks
-*	nfchunks	Number of image chunks
-*	s3crc		Array of crc records
-*	ns3crc		Number of crc records
-*
-* Returns:
-*	0	success
-*	~0	failure
-----------------------------------------------------------------*/
+ * crcimage
+ *
+ * Adds a CRC16 in the two bytes prior to each block identified by
+ * an S3 CRC record.  Currently, we don't actually do a CRC we just
+ * insert the value 0xC0DE in hfa384x order.
+ *
+ * Arguments:
+ *	fchunk		Array of image chunks
+ *	nfchunks	Number of image chunks
+ *	s3crc		Array of crc records
+ *	ns3crc		Number of crc records
+ *
+ * Returns:
+ *	0	success
+ *	~0	failure
+ *----------------------------------------------------------------
+ */
 static int crcimage(struct imgchunk *fchunk, unsigned int nfchunks,
 	     struct s3crcrec *s3crc, unsigned int ns3crc)
 {
@@ -439,16 +442,17 @@ static int crcimage(struct imgchunk *fchunk, unsigned int nfchunks,
 }
 
 /*----------------------------------------------------------------
-* free_chunks
-*
-* Clears the chunklist data structures in preparation for a new file.
-*
-* Arguments:
-*	none
-*
-* Returns:
-*	nothing
-----------------------------------------------------------------*/
+ * free_chunks
+ *
+ * Clears the chunklist data structures in preparation for a new file.
+ *
+ * Arguments:
+ *	none
+ *
+ * Returns:
+ *	nothing
+ *----------------------------------------------------------------
+ */
 static void free_chunks(struct imgchunk *fchunk, unsigned int *nfchunks)
 {
 	int i;
@@ -462,16 +466,17 @@ static void free_chunks(struct imgchunk *fchunk, unsigned int *nfchunks)
 }
 
 /*----------------------------------------------------------------
-* free_srecs
-*
-* Clears the srec data structures in preparation for a new file.
-*
-* Arguments:
-*	none
-*
-* Returns:
-*	nothing
-----------------------------------------------------------------*/
+ * free_srecs
+ *
+ * Clears the srec data structures in preparation for a new file.
+ *
+ * Arguments:
+ *	none
+ *
+ * Returns:
+ *	nothing
+ *----------------------------------------------------------------
+ */
 static void free_srecs(void)
 {
 	ns3data = 0;
@@ -486,19 +491,20 @@ static void free_srecs(void)
 }
 
 /*----------------------------------------------------------------
-* mkimage
-*
-* Scans the currently loaded set of S records for data residing
-* in contiguous memory regions.  Each contiguous region is then
-* made into a 'chunk'.  This function assumes that we're building
-* a new chunk list.  Assumes the s3data items are in sorted order.
-*
-* Arguments:	none
-*
-* Returns:
-*	0	- success
-*	~0	- failure (probably an errno)
-----------------------------------------------------------------*/
+ * mkimage
+ *
+ * Scans the currently loaded set of S records for data residing
+ * in contiguous memory regions.  Each contiguous region is then
+ * made into a 'chunk'.  This function assumes that we're building
+ * a new chunk list.  Assumes the s3data items are in sorted order.
+ *
+ * Arguments:	none
+ *
+ * Returns:
+ *	0	- success
+ *	~0	- failure (probably an errno)
+ *----------------------------------------------------------------
+ */
 static int mkimage(struct imgchunk *clist, unsigned int *ccnt)
 {
 	int result = 0;
@@ -577,19 +583,20 @@ static int mkimage(struct imgchunk *clist, unsigned int *ccnt)
 }
 
 /*----------------------------------------------------------------
-* mkpdrlist
-*
-* Reads a raw PDA and builds an array of pdrec_t structures.
-*
-* Arguments:
-*	pda	buffer containing raw PDA bytes
-*	pdrec	ptr to an array of pdrec_t's.  Will be filled on exit.
-*	nrec	ptr to a variable that will contain the count of PDRs
-*
-* Returns:
-*	0	- success
-*	~0	- failure (probably an errno)
-----------------------------------------------------------------*/
+ * mkpdrlist
+ *
+ * Reads a raw PDA and builds an array of pdrec_t structures.
+ *
+ * Arguments:
+ *	pda	buffer containing raw PDA bytes
+ *	pdrec	ptr to an array of pdrec_t's.  Will be filled on exit.
+ *	nrec	ptr to a variable that will contain the count of PDRs
+ *
+ * Returns:
+ *	0	- success
+ *	~0	- failure (probably an errno)
+ *----------------------------------------------------------------
+ */
 static int mkpdrlist(struct pda *pda)
 {
 	u16 *pda16 = (u16 *)pda->buf;
@@ -644,22 +651,23 @@ static int mkpdrlist(struct pda *pda)
 }
 
 /*----------------------------------------------------------------
-* plugimage
-*
-* Plugs the given image using the given plug records from the given
-* PDA and filename.
-*
-* Arguments:
-*	fchunk		Array of image chunks
-*	nfchunks	Number of image chunks
-*	s3plug		Array of plug records
-*	ns3plug		Number of plug records
-*	pda		Current pda data
-*
-* Returns:
-*	0	success
-*	~0	failure
-----------------------------------------------------------------*/
+ * plugimage
+ *
+ * Plugs the given image using the given plug records from the given
+ * PDA and filename.
+ *
+ * Arguments:
+ *	fchunk		Array of image chunks
+ *	nfchunks	Number of image chunks
+ *	s3plug		Array of plug records
+ *	ns3plug		Number of plug records
+ *	pda		Current pda data
+ *
+ * Returns:
+ *	0	success
+ *	~0	failure
+ *----------------------------------------------------------------
+ */
 static int plugimage(struct imgchunk *fchunk, unsigned int nfchunks,
 	      struct s3plugrec *s3plug, unsigned int ns3plug, struct pda *pda)
 {
@@ -749,23 +757,24 @@ static int plugimage(struct imgchunk *fchunk, unsigned int nfchunks,
 }
 
 /*----------------------------------------------------------------
-* read_cardpda
-*
-* Sends the command for the driver to read the pda from the card
-* named in the device variable.  Upon success, the card pda is
-* stored in the "cardpda" variables.  Note that the pda structure
-* is considered 'well formed' after this function.  That means
-* that the nrecs is valid, the rec array has been set up, and there's
-* a valid PDAEND record in the raw PDA data.
-*
-* Arguments:
-*	pda		pda structure
-*	wlandev		device
-*
-* Returns:
-*	0	- success
-*	~0	- failure (probably an errno)
-----------------------------------------------------------------*/
+ * read_cardpda
+ *
+ * Sends the command for the driver to read the pda from the card
+ * named in the device variable.  Upon success, the card pda is
+ * stored in the "cardpda" variables.  Note that the pda structure
+ * is considered 'well formed' after this function.  That means
+ * that the nrecs is valid, the rec array has been set up, and there's
+ * a valid PDAEND record in the raw PDA data.
+ *
+ * Arguments:
+ *	pda		pda structure
+ *	wlandev		device
+ *
+ * Returns:
+ *	0	- success
+ *	~0	- failure (probably an errno)
+ *----------------------------------------------------------------
+ */
 static int read_cardpda(struct pda *pda, struct wlandevice *wlandev)
 {
 	int result = 0;
@@ -802,65 +811,66 @@ static int read_cardpda(struct pda *pda, struct wlandevice *wlandev)
 }
 
 /*----------------------------------------------------------------
-* read_fwfile
-*
-* Reads the given fw file which should have been compiled from an srec
-* file. Each record in the fw file will either be a plain data record,
-* a start address record, or other records used for plugging.
-*
-* Note that data records are expected to be sorted into
-* ascending address order in the fw file.
-*
-* Note also that the start address record, originally an S7 record in
-* the srec file, is expected in the fw file to be like a data record but
-* with a certain address to make it identifiable.
-*
-* Here's the SREC format that the fw should have come from:
-* S[37]nnaaaaaaaaddd...dddcc
-*
-*       nn - number of bytes starting with the address field
-* aaaaaaaa - address in readable (or big endian) format
-* dd....dd - 0-245 data bytes (two chars per byte)
-*       cc - checksum
-*
-* The S7 record's (there should be only one) address value gets
-* converted to an S3 record with address of 0xff400000, with the
-* start address being stored as a 4 byte data word. That address is
-* the start execution address used for RAM downloads.
-*
-* The S3 records have a collection of subformats indicated by the
-* value of aaaaaaaa:
-*   0xff000000 - Plug record, data field format:
-*                xxxxxxxxaaaaaaaassssssss
-*                x - PDR code number (little endian)
-*                a - Address in load image to plug (little endian)
-*                s - Length of plug data area (little endian)
-*
-*   0xff100000 - CRC16 generation record, data field format:
-*                aaaaaaaassssssssbbbbbbbb
-*                a - Start address for CRC calculation (little endian)
-*                s - Length of data to  calculate over (little endian)
-*                b - Boolean, true=write crc, false=don't write
-*
-*   0xff200000 - Info record, data field format:
-*                ssssttttdd..dd
-*                s - Size in words (little endian)
-*                t - Info type (little endian), see #defines and
-*                    struct s3inforec for details about types.
-*                d - (s - 1) little endian words giving the contents of
-*                    the given info type.
-*
-*   0xff400000 - Start address record, data field format:
-*                aaaaaaaa
-*                a - Address in load image to plug (little endian)
-*
-* Arguments:
-*	record	firmware image (ihex record structure) in kernel memory
-*
-* Returns:
-*	0	- success
-*	~0	- failure (probably an errno)
-----------------------------------------------------------------*/
+ * read_fwfile
+ *
+ * Reads the given fw file which should have been compiled from an srec
+ * file. Each record in the fw file will either be a plain data record,
+ * a start address record, or other records used for plugging.
+ *
+ * Note that data records are expected to be sorted into
+ * ascending address order in the fw file.
+ *
+ * Note also that the start address record, originally an S7 record in
+ * the srec file, is expected in the fw file to be like a data record but
+ * with a certain address to make it identifiable.
+ *
+ * Here's the SREC format that the fw should have come from:
+ * S[37]nnaaaaaaaaddd...dddcc
+ *
+ *       nn - number of bytes starting with the address field
+ * aaaaaaaa - address in readable (or big endian) format
+ * dd....dd - 0-245 data bytes (two chars per byte)
+ *       cc - checksum
+ *
+ * The S7 record's (there should be only one) address value gets
+ * converted to an S3 record with address of 0xff400000, with the
+ * start address being stored as a 4 byte data word. That address is
+ * the start execution address used for RAM downloads.
+ *
+ * The S3 records have a collection of subformats indicated by the
+ * value of aaaaaaaa:
+ *   0xff000000 - Plug record, data field format:
+ *                xxxxxxxxaaaaaaaassssssss
+ *                x - PDR code number (little endian)
+ *                a - Address in load image to plug (little endian)
+ *                s - Length of plug data area (little endian)
+ *
+ *   0xff100000 - CRC16 generation record, data field format:
+ *                aaaaaaaassssssssbbbbbbbb
+ *                a - Start address for CRC calculation (little endian)
+ *                s - Length of data to  calculate over (little endian)
+ *                b - Boolean, true=write crc, false=don't write
+ *
+ *   0xff200000 - Info record, data field format:
+ *                ssssttttdd..dd
+ *                s - Size in words (little endian)
+ *                t - Info type (little endian), see #defines and
+ *                    struct s3inforec for details about types.
+ *                d - (s - 1) little endian words giving the contents of
+ *                    the given info type.
+ *
+ *   0xff400000 - Start address record, data field format:
+ *                aaaaaaaa
+ *                a - Address in load image to plug (little endian)
+ *
+ * Arguments:
+ *	record	firmware image (ihex record structure) in kernel memory
+ *
+ * Returns:
+ *	0	- success
+ *	~0	- failure (probably an errno)
+ *----------------------------------------------------------------
+ */
 static int read_fwfile(const struct ihex_binrec *record)
 {
 	int		i;
@@ -968,20 +978,21 @@ static int read_fwfile(const struct ihex_binrec *record)
 }
 
 /*----------------------------------------------------------------
-* writeimage
-*
-* Takes the chunks, builds p80211 messages and sends them down
-* to the driver for writing to the card.
-*
-* Arguments:
-*	wlandev		device
-*	fchunk		Array of image chunks
-*	nfchunks	Number of image chunks
-*
-* Returns:
-*	0	success
-*	~0	failure
-----------------------------------------------------------------*/
+ * writeimage
+ *
+ * Takes the chunks, builds p80211 messages and sends them down
+ * to the driver for writing to the card.
+ *
+ * Arguments:
+ *	wlandev		device
+ *	fchunk		Array of image chunks
+ *	nfchunks	Number of image chunks
+ *
+ * Returns:
+ *	0	success
+ *	~0	failure
+ *----------------------------------------------------------------
+ */
 static int writeimage(struct wlandevice *wlandev, struct imgchunk *fchunk,
 	       unsigned int nfchunks)
 {

commit 4f026e894da368a3dbb7454ac696b25e8f4dcbf7
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Wed Sep 28 20:20:13 2016 +0200

    staging: wlang-ng: avoid new typedef: hfa384x_pdrec_t
    
    This patch fixes the following checkpatch.pl warning in hfa384x.h:
    WARNING: do not add new typedefs
    
    It applies for typedef hfa384x_pdrec_t
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/prism2fw.c b/drivers/staging/wlan-ng/prism2fw.c
index ca322fa3d43c..96aa21188669 100644
--- a/drivers/staging/wlan-ng/prism2fw.c
+++ b/drivers/staging/wlan-ng/prism2fw.c
@@ -105,7 +105,7 @@ struct s3inforec {
 
 struct pda {
 	u8 buf[HFA384x_PDA_LEN_MAX];
-	hfa384x_pdrec_t *rec[HFA384x_PDA_RECS_MAX];
+	struct hfa384x_pdrec *rec[HFA384x_PDA_RECS_MAX];
 	unsigned int nrec;
 };
 
@@ -266,7 +266,7 @@ static int prism2_fwapply(const struct ihex_binrec *rfptr,
 
 	/* clear the pda and add an initial END record */
 	memset(&pda, 0, sizeof(pda));
-	pda.rec[0] = (hfa384x_pdrec_t *)pda.buf;
+	pda.rec[0] = (struct hfa384x_pdrec *)pda.buf;
 	pda.rec[0]->len = cpu_to_le16(2);	/* len in words */
 	pda.rec[0]->code = cpu_to_le16(HFA384x_PDR_END_OF_PDA);
 	pda.nrec = 1;
@@ -599,7 +599,7 @@ static int mkpdrlist(struct pda *pda)
 	curroff = 0;
 	while (curroff < (HFA384x_PDA_LEN_MAX / 2 - 1) &&
 	       le16_to_cpu(pda16[curroff + 1]) != HFA384x_PDR_END_OF_PDA) {
-		pda->rec[pda->nrec] = (hfa384x_pdrec_t *)&(pda16[curroff]);
+		pda->rec[pda->nrec] = (struct hfa384x_pdrec *)&(pda16[curroff]);
 
 		if (le16_to_cpu(pda->rec[pda->nrec]->code) ==
 		    HFA384x_PDR_NICID) {
@@ -638,7 +638,7 @@ static int mkpdrlist(struct pda *pda)
 		       curroff, pda->nrec);
 		return 1;
 	}
-	pda->rec[pda->nrec] = (hfa384x_pdrec_t *)&(pda16[curroff]);
+	pda->rec[pda->nrec] = (struct hfa384x_pdrec *)&(pda16[curroff]);
 	(pda->nrec)++;
 	return 0;
 }

commit 65f170c661d9419db74c6710baaa9df72c1f95b3
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Wed Sep 28 20:18:57 2016 +0200

    staging: wlang-ng: avoid new typedef: hfa384x_caplevel_t
    
    This patch fixes the following checkpatch.pl warning in hfa384x.h:
    WARNING: do not add new typedefs
    
    It applies for typedef hfa384x_caplevel_t
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/prism2fw.c b/drivers/staging/wlan-ng/prism2fw.c
index 35b0ff996df7..ca322fa3d43c 100644
--- a/drivers/staging/wlan-ng/prism2fw.c
+++ b/drivers/staging/wlan-ng/prism2fw.c
@@ -97,7 +97,7 @@ struct s3inforec {
 	u16 type;
 	union {
 		struct hfa384x_compident version;
-		hfa384x_caplevel_t compat;
+		struct hfa384x_caplevel compat;
 		u16 buildseq;
 		struct hfa384x_compident platform;
 	} info;
@@ -153,9 +153,9 @@ static struct imgchunk fchunk[CHUNKS_MAX];
 
 static struct pda pda;
 static struct hfa384x_compident nicid;
-static hfa384x_caplevel_t rfid;
-static hfa384x_caplevel_t macid;
-static hfa384x_caplevel_t priid;
+static struct hfa384x_caplevel rfid;
+static struct hfa384x_caplevel macid;
+static struct hfa384x_caplevel priid;
 
 /*================================================================*/
 /* Local Function Declarations */

commit 5f04645672c3dabf263939ab0454590e4e18fdff
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Wed Sep 28 20:18:55 2016 +0200

    staging: wlang-ng: avoid new typedef: hfa384x_compident_t
    
    This patch fixes the following checkpatch.pl warning in hfa384x.h:
    WARNING: do not add new typedefs
    
    It applies for typedef hfa384x_compident_t
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/prism2fw.c b/drivers/staging/wlan-ng/prism2fw.c
index 7c5d3e713681..35b0ff996df7 100644
--- a/drivers/staging/wlan-ng/prism2fw.c
+++ b/drivers/staging/wlan-ng/prism2fw.c
@@ -96,10 +96,10 @@ struct s3inforec {
 	u16 len;
 	u16 type;
 	union {
-		hfa384x_compident_t version;
+		struct hfa384x_compident version;
 		hfa384x_caplevel_t compat;
 		u16 buildseq;
-		hfa384x_compident_t platform;
+		struct hfa384x_compident platform;
 	} info;
 };
 
@@ -152,7 +152,7 @@ static struct imgchunk fchunk[CHUNKS_MAX];
 /* PDA, built from [card|newfile]+[addfile1+addfile2...] */
 
 static struct pda pda;
-static hfa384x_compident_t nicid;
+static struct hfa384x_compident nicid;
 static hfa384x_caplevel_t rfid;
 static hfa384x_caplevel_t macid;
 static hfa384x_caplevel_t priid;

commit ac033ec9f71a7107b64390fd9b52f799a22acedf
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Sun Sep 25 15:34:59 2016 +0200

    staging: wlan-ng: avoid new typedef: p80211itemd_t
    
    This patch fixes the following checkpatch.pl warning in p80211types.h:
    WARNING: do not add new typedefs
    
    It applies for typedef p80211itemd_t
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/prism2fw.c b/drivers/staging/wlan-ng/prism2fw.c
index 870bad92d9b6..7c5d3e713681 100644
--- a/drivers/staging/wlan-ng/prism2fw.c
+++ b/drivers/staging/wlan-ng/prism2fw.c
@@ -243,7 +243,7 @@ static int prism2_fwapply(const struct ihex_binrec *rfptr,
 {
 	signed int result = 0;
 	struct p80211msg_dot11req_mibget getmsg;
-	p80211itemd_t *item;
+	struct p80211itemd *item;
 	u32 *data;
 
 	/* Initialize the data structures */
@@ -293,7 +293,7 @@ static int prism2_fwapply(const struct ihex_binrec *rfptr,
 	getmsg.resultcode.did = DIDmsg_dot11req_mibget_resultcode;
 	getmsg.resultcode.status = P80211ENUM_msgitem_status_no_value;
 
-	item = (p80211itemd_t *)getmsg.mibattribute.data;
+	item = (struct p80211itemd *)getmsg.mibattribute.data;
 	item->did = DIDmib_p2_p2NIC_p2PRISupRange;
 	item->status = P80211ENUM_msgitem_status_no_value;
 

commit 0e21fa4602078160e03ef210c983df0c257ccbe8
Author: Jannik Becher <becher.jannik@gmail.com>
Date:   Fri Sep 23 01:02:10 2016 +0200

    staging: wlan-ng: remove unnecessary spaces before casts
    
    Fixed a coding style issue by removing unnecessary spaces before casts.
    
    Signed-off-by: Jannik Becher <Becher.Jannik@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/prism2fw.c b/drivers/staging/wlan-ng/prism2fw.c
index 161637b6abdf..870bad92d9b6 100644
--- a/drivers/staging/wlan-ng/prism2fw.c
+++ b/drivers/staging/wlan-ng/prism2fw.c
@@ -266,7 +266,7 @@ static int prism2_fwapply(const struct ihex_binrec *rfptr,
 
 	/* clear the pda and add an initial END record */
 	memset(&pda, 0, sizeof(pda));
-	pda.rec[0] = (hfa384x_pdrec_t *) pda.buf;
+	pda.rec[0] = (hfa384x_pdrec_t *)pda.buf;
 	pda.rec[0]->len = cpu_to_le16(2);	/* len in words */
 	pda.rec[0]->code = cpu_to_le16(HFA384x_PDR_END_OF_PDA);
 	pda.nrec = 1;
@@ -293,11 +293,11 @@ static int prism2_fwapply(const struct ihex_binrec *rfptr,
 	getmsg.resultcode.did = DIDmsg_dot11req_mibget_resultcode;
 	getmsg.resultcode.status = P80211ENUM_msgitem_status_no_value;
 
-	item = (p80211itemd_t *) getmsg.mibattribute.data;
+	item = (p80211itemd_t *)getmsg.mibattribute.data;
 	item->did = DIDmib_p2_p2NIC_p2PRISupRange;
 	item->status = P80211ENUM_msgitem_status_no_value;
 
-	data = (u32 *) item->data;
+	data = (u32 *)item->data;
 
 	/* DIDmsg_dot11req_mibget */
 	prism2mgmt_mibset_mibget(wlandev, &getmsg);
@@ -592,14 +592,14 @@ static int mkimage(struct imgchunk *clist, unsigned int *ccnt)
 ----------------------------------------------------------------*/
 static int mkpdrlist(struct pda *pda)
 {
-	u16 *pda16 = (u16 *) pda->buf;
+	u16 *pda16 = (u16 *)pda->buf;
 	int curroff;		/* in 'words' */
 
 	pda->nrec = 0;
 	curroff = 0;
 	while (curroff < (HFA384x_PDA_LEN_MAX / 2 - 1) &&
 	       le16_to_cpu(pda16[curroff + 1]) != HFA384x_PDR_END_OF_PDA) {
-		pda->rec[pda->nrec] = (hfa384x_pdrec_t *) &(pda16[curroff]);
+		pda->rec[pda->nrec] = (hfa384x_pdrec_t *)&(pda16[curroff]);
 
 		if (le16_to_cpu(pda->rec[pda->nrec]->code) ==
 		    HFA384x_PDR_NICID) {
@@ -638,7 +638,7 @@ static int mkpdrlist(struct pda *pda)
 		       curroff, pda->nrec);
 		return 1;
 	}
-	pda->rec[pda->nrec] = (hfa384x_pdrec_t *) &(pda16[curroff]);
+	pda->rec[pda->nrec] = (hfa384x_pdrec_t *)&(pda16[curroff]);
 	(pda->nrec)++;
 	return 0;
 }
@@ -879,8 +879,8 @@ static int read_fwfile(const struct ihex_binrec *record)
 		addr = be32_to_cpu(record->addr);
 
 		/* Point into data for different word lengths */
-		ptr32 = (u32 *) record->data;
-		ptr16 = (u16 *) record->data;
+		ptr32 = (u32 *)record->data;
+		ptr16 = (u16 *)record->data;
 
 		/* parse what was an S3 srec and put it in the right array */
 		switch (addr) {
@@ -954,7 +954,7 @@ static int read_fwfile(const struct ihex_binrec *record)
 		default:	/* Data record */
 			s3data[ns3data].addr = addr;
 			s3data[ns3data].len = len;
-			s3data[ns3data].data = (uint8_t *) record->data;
+			s3data[ns3data].data = (uint8_t *)record->data;
 			ns3data++;
 			if (ns3data == S3DATA_MAX) {
 				pr_err("S3 datarec limit reached - aborting\n");

commit c9573a8d1963ba82f163c4d113266da82c048c21
Author: sayli karnik <karniksayli1995@gmail.com>
Date:   Sun Sep 18 15:11:14 2016 +0530

    staging: wlan-ng: Remove the typedef to the 'wlandevice' structure
    
    This patch removes the typedef 'wlandevice_t' to the 'wlandevice'
    structure.
    
    Signed-off-by: sayli karnik <karniksayli1995@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/prism2fw.c b/drivers/staging/wlan-ng/prism2fw.c
index 56bffd93c982..161637b6abdf 100644
--- a/drivers/staging/wlan-ng/prism2fw.c
+++ b/drivers/staging/wlan-ng/prism2fw.c
@@ -161,13 +161,13 @@ static hfa384x_caplevel_t priid;
 /* Local Function Declarations */
 
 static int prism2_fwapply(const struct ihex_binrec *rfptr,
-wlandevice_t *wlandev);
+struct wlandevice *wlandev);
 
 static int read_fwfile(const struct ihex_binrec *rfptr);
 
 static int mkimage(struct imgchunk *clist, unsigned int *ccnt);
 
-static int read_cardpda(struct pda *pda, wlandevice_t *wlandev);
+static int read_cardpda(struct pda *pda, struct wlandevice *wlandev);
 
 static int mkpdrlist(struct pda *pda);
 
@@ -177,7 +177,7 @@ static int plugimage(struct imgchunk *fchunk, unsigned int nfchunks,
 static int crcimage(struct imgchunk *fchunk, unsigned int nfchunks,
 	     struct s3crcrec *s3crc, unsigned int ns3crc);
 
-static int writeimage(wlandevice_t *wlandev, struct imgchunk *fchunk,
+static int writeimage(struct wlandevice *wlandev, struct imgchunk *fchunk,
 	       unsigned int nfchunks);
 static void free_chunks(struct imgchunk *fchunk, unsigned int *nfchunks);
 
@@ -201,7 +201,7 @@ static int validate_identity(void);
 *	0	- success
 *	~0	- failure
 ----------------------------------------------------------------*/
-static int prism2_fwtry(struct usb_device *udev, wlandevice_t *wlandev)
+static int prism2_fwtry(struct usb_device *udev, struct wlandevice *wlandev)
 {
 	const struct firmware *fw_entry = NULL;
 
@@ -239,7 +239,7 @@ static int prism2_fwtry(struct usb_device *udev, wlandevice_t *wlandev)
 *	~0	- failure
 ----------------------------------------------------------------*/
 static int prism2_fwapply(const struct ihex_binrec *rfptr,
-			  wlandevice_t *wlandev)
+			  struct wlandevice *wlandev)
 {
 	signed int result = 0;
 	struct p80211msg_dot11req_mibget getmsg;
@@ -766,7 +766,7 @@ static int plugimage(struct imgchunk *fchunk, unsigned int nfchunks,
 *	0	- success
 *	~0	- failure (probably an errno)
 ----------------------------------------------------------------*/
-static int read_cardpda(struct pda *pda, wlandevice_t *wlandev)
+static int read_cardpda(struct pda *pda, struct wlandevice *wlandev)
 {
 	int result = 0;
 	struct p80211msg_p2req_readpda *msg;
@@ -982,7 +982,7 @@ static int read_fwfile(const struct ihex_binrec *record)
 *	0	success
 *	~0	failure
 ----------------------------------------------------------------*/
-static int writeimage(wlandevice_t *wlandev, struct imgchunk *fchunk,
+static int writeimage(struct wlandevice *wlandev, struct imgchunk *fchunk,
 	       unsigned int nfchunks)
 {
 	int result = 0;

commit e26eaf457989326a41eb58754f18333308cab321
Author: Claudiu Beznea <claudiu.beznea@gmail.com>
Date:   Sun Apr 24 19:40:13 2016 +0300

    Staging: wlan-ng: memory allocated inside mkimage() is not freed if subsequent calls fails.
    
    This patch frees memory allocated inside mkimage() in case mkimage()
    or any other subsequent calls inside prism2_fwapply() from prism2fw.c
    file fails. To fix this I introduces goto labels where the free
    operation is done in case some operations fails. After the introduction
    of goto labels has been done, in order to use the same return path,
    "return x" instuctions were replaced with "goto" instuctions.
    
    Signed-off-by: Claudiu Beznea <claudiu.beznea@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/prism2fw.c b/drivers/staging/wlan-ng/prism2fw.c
index 8564d9eb918f..56bffd93c982 100644
--- a/drivers/staging/wlan-ng/prism2fw.c
+++ b/drivers/staging/wlan-ng/prism2fw.c
@@ -278,7 +278,8 @@ static int prism2_fwapply(const struct ihex_binrec *rfptr,
 	/* Build the PDA we're going to use. */
 	if (read_cardpda(&pda, wlandev)) {
 		netdev_err(wlandev->netdev, "load_cardpda failed, exiting.\n");
-		return 1;
+		result = 1;
+		goto out;
 	}
 
 	/* read the card's PRI-SUP */
@@ -315,55 +316,58 @@ static int prism2_fwapply(const struct ihex_binrec *rfptr,
 	if (result) {
 		netdev_err(wlandev->netdev,
 			   "Failed to read the data exiting.\n");
-		return 1;
+		goto out;
 	}
 
 	result = validate_identity();
-
 	if (result) {
 		netdev_err(wlandev->netdev, "Incompatible firmware image.\n");
-		return 1;
+		goto out;
 	}
 
 	if (startaddr == 0x00000000) {
 		netdev_err(wlandev->netdev,
 			   "Can't RAM download a Flash image!\n");
-		return 1;
+		result = 1;
+		goto out;
 	}
 
 	/* Make the image chunks */
 	result = mkimage(fchunk, &nfchunks);
 	if (result) {
 		netdev_err(wlandev->netdev, "Failed to make image chunk.\n");
-		return 1;
+		goto free_chunks;
 	}
 
 	/* Do any plugging */
 	result = plugimage(fchunk, nfchunks, s3plug, ns3plug, &pda);
 	if (result) {
 		netdev_err(wlandev->netdev, "Failed to plug data.\n");
-		return 1;
+		goto free_chunks;
 	}
 
 	/* Insert any CRCs */
-	if (crcimage(fchunk, nfchunks, s3crc, ns3crc)) {
+	result = crcimage(fchunk, nfchunks, s3crc, ns3crc);
+	if (result) {
 		netdev_err(wlandev->netdev, "Failed to insert all CRCs\n");
-		return 1;
+		goto free_chunks;
 	}
 
 	/* Write the image */
 	result = writeimage(wlandev, fchunk, nfchunks);
 	if (result) {
 		netdev_err(wlandev->netdev, "Failed to ramwrite image data.\n");
-		return 1;
+		goto free_chunks;
 	}
 
+	netdev_info(wlandev->netdev, "prism2_usb: firmware loading finished.\n");
+
+free_chunks:
 	/* clear any allocated memory */
 	free_chunks(fchunk, &nfchunks);
 	free_srecs();
 
-	netdev_info(wlandev->netdev, "prism2_usb: firmware loading finished.\n");
-
+out:
 	return result;
 }
 

commit c631cb07b4ac6a6c513591a581ac92a7f99da9d1
Author: Sandhya Bankar <bankarsandhya512@gmail.com>
Date:   Mon Mar 7 16:15:59 2016 +0530

    Staging: wlan-ng: Handle error condition.
    
    Handle error condition.
    
    Signed-off-by: Sandhya Bankar <bankarsandhya512@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/prism2fw.c b/drivers/staging/wlan-ng/prism2fw.c
index 8d6ab727fd45..8564d9eb918f 100644
--- a/drivers/staging/wlan-ng/prism2fw.c
+++ b/drivers/staging/wlan-ng/prism2fw.c
@@ -333,6 +333,10 @@ static int prism2_fwapply(const struct ihex_binrec *rfptr,
 
 	/* Make the image chunks */
 	result = mkimage(fchunk, &nfchunks);
+	if (result) {
+		netdev_err(wlandev->netdev, "Failed to make image chunk.\n");
+		return 1;
+	}
 
 	/* Do any plugging */
 	result = plugimage(fchunk, nfchunks, s3plug, ns3plug, &pda);

commit e2e77528a7dc80a9b5ff978a84b40e403ba9809d
Author: Eva Rachel Retuya <eraretuya@gmail.com>
Date:   Sat Feb 27 20:39:25 2016 +0800

    staging: wlan-ng: simplify NULL tests
    
    Replace direct comparisons to NULL i.e. 'x == NULL' with '!x' for
    consistency. Coccinelle semantic patch used:
    
    @@
    identifier func;
    expression x;
    statement Z;
    @@
    
    x = func(...);
    
    if (
    (
    +       !
            x
    -       == NULL
    |
    +       !
    -       NULL ==
            x
    )
       ) Z
    
    Signed-off-by: Eva Rachel Retuya <eraretuya@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/prism2fw.c b/drivers/staging/wlan-ng/prism2fw.c
index 8fc80df0b53e..8d6ab727fd45 100644
--- a/drivers/staging/wlan-ng/prism2fw.c
+++ b/drivers/staging/wlan-ng/prism2fw.c
@@ -538,7 +538,7 @@ static int mkimage(struct imgchunk *clist, unsigned int *ccnt)
 	/* Allocate buffer space for chunks */
 	for (i = 0; i < *ccnt; i++) {
 		clist[i].data = kzalloc(clist[i].len, GFP_KERNEL);
-		if (clist[i].data == NULL) {
+		if (!clist[i].data) {
 			pr_err("failed to allocate image space, exitting.\n");
 			return 1;
 		}

commit 3ac8480ad61a45c2a9e3ee003d2cf4ce37ef4795
Author: Tillmann Heidsieck <theidsieck@leenox.de>
Date:   Wed Sep 23 22:07:55 2015 +0200

    staging: wlan-ng remove unnessecary variable
    
    The result variable is not set anywhere beyond its initialization,
    therefore it can be remove.
    
    Signed-off-by: Tillmann Heidsieck <theidsieck@leenox.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/prism2fw.c b/drivers/staging/wlan-ng/prism2fw.c
index f5b97273164d..8fc80df0b53e 100644
--- a/drivers/staging/wlan-ng/prism2fw.c
+++ b/drivers/staging/wlan-ng/prism2fw.c
@@ -584,7 +584,6 @@ static int mkimage(struct imgchunk *clist, unsigned int *ccnt)
 ----------------------------------------------------------------*/
 static int mkpdrlist(struct pda *pda)
 {
-	int result = 0;
 	u16 *pda16 = (u16 *) pda->buf;
 	int curroff;		/* in 'words' */
 
@@ -633,7 +632,7 @@ static int mkpdrlist(struct pda *pda)
 	}
 	pda->rec[pda->nrec] = (hfa384x_pdrec_t *) &(pda16[curroff]);
 	(pda->nrec)++;
-	return result;
+	return 0;
 }
 
 /*----------------------------------------------------------------

commit c739c987c1e19b924b252ebb12ffeac3ef9b1d5c
Author: Tillmann Heidsieck <theidsieck@leenox.de>
Date:   Wed Sep 23 22:07:54 2015 +0200

    staging: wlan-ng remove redundant conditional
    
    We exit the above loop either if curroff >= (HFA384x_PDA_LEN_MAX / 2 - 1)
    or if we found the END marker in the element beyond the current one. The
    first case is checked for in the preceding if statement, therefore the
    second if statement is redundant and can be removed.
    
    Signed-off-by: Tillmann Heidsieck <theidsieck@leenox.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/prism2fw.c b/drivers/staging/wlan-ng/prism2fw.c
index d357b7ecb1fc..f5b97273164d 100644
--- a/drivers/staging/wlan-ng/prism2fw.c
+++ b/drivers/staging/wlan-ng/prism2fw.c
@@ -631,10 +631,8 @@ static int mkpdrlist(struct pda *pda)
 		       curroff, pda->nrec);
 		return 1;
 	}
-	if (le16_to_cpu(pda16[curroff + 1]) == HFA384x_PDR_END_OF_PDA) {
-		pda->rec[pda->nrec] = (hfa384x_pdrec_t *) &(pda16[curroff]);
-		(pda->nrec)++;
-	}
+	pda->rec[pda->nrec] = (hfa384x_pdrec_t *) &(pda16[curroff]);
+	(pda->nrec)++;
 	return result;
 }
 

commit 4ccb726c728cb414d9abc65a11a6453e75204503
Author: Tillmann Heidsieck <theidsieck@leenox.de>
Date:   Wed Sep 23 22:07:53 2015 +0200

    staging: wlan-ng fix buffer overflow in firmware handling
    
    We test for an END marker in the element beyond the current one, this
    effectively limits the size of the array to be HFA384x_PDA_LEN_MAX/2 - 1
    not HFA384x_PDR_END_OF_PDA/2. This patch fixes a possible buffer
    overflow in case there was no END marker.
    
    Signed-off-by: Tillmann Heidsieck <theidsieck@leenox.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/prism2fw.c b/drivers/staging/wlan-ng/prism2fw.c
index fe36613589ae..d357b7ecb1fc 100644
--- a/drivers/staging/wlan-ng/prism2fw.c
+++ b/drivers/staging/wlan-ng/prism2fw.c
@@ -590,7 +590,7 @@ static int mkpdrlist(struct pda *pda)
 
 	pda->nrec = 0;
 	curroff = 0;
-	while (curroff < (HFA384x_PDA_LEN_MAX / 2) &&
+	while (curroff < (HFA384x_PDA_LEN_MAX / 2 - 1) &&
 	       le16_to_cpu(pda16[curroff + 1]) != HFA384x_PDR_END_OF_PDA) {
 		pda->rec[pda->nrec] = (hfa384x_pdrec_t *) &(pda16[curroff]);
 
@@ -626,7 +626,7 @@ static int mkpdrlist(struct pda *pda)
 		curroff += le16_to_cpu(pda16[curroff]) + 1;
 
 	}
-	if (curroff >= (HFA384x_PDA_LEN_MAX / 2)) {
+	if (curroff >= (HFA384x_PDA_LEN_MAX / 2 - 1)) {
 		pr_err("no end record found or invalid lengths in PDR data, exiting. %x %d\n",
 		       curroff, pda->nrec);
 		return 1;

commit cfa6954ced97004242057b48b0e30113a02c19c4
Author: Douglas Barbonaglia Sathler Figueiredo <eng.douglasfigueiredo@gmail.com>
Date:   Mon Jun 1 10:37:11 2015 -0300

    staging: wlan-ng: fix long line
    
    Style (line over 80 chars) in drivers/staging/wlan-ng/prism2fw.c
    
    Signed-off-by: Douglas Barbonaglia Sathler Figueiredo <eng.douglasfigueiredo@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/prism2fw.c b/drivers/staging/wlan-ng/prism2fw.c
index 9408644cc8b8..fe36613589ae 100644
--- a/drivers/staging/wlan-ng/prism2fw.c
+++ b/drivers/staging/wlan-ng/prism2fw.c
@@ -708,7 +708,10 @@ static int plugimage(struct imgchunk *fchunk, unsigned int nfchunks,
 			continue;
 		}
 
-		/* Validate plug address against chunk data and identify chunk */
+		/*
+		 * Validate plug address against
+		 * chunk data and identify chunk
+		 */
 		for (c = 0; c < nfchunks; c++) {
 			cstart = fchunk[c].addr;
 			cend = fchunk[c].addr + fchunk[c].len;
@@ -923,7 +926,8 @@ static int read_fwfile(const struct ihex_binrec *record)
 				      rcnt,
 				      s3info[ns3info].len,
 				      s3info[ns3info].type);
-			if (((s3info[ns3info].len - 1) * sizeof(u16)) > sizeof(s3info[ns3info].info)) {
+			if (((s3info[ns3info].len - 1) * sizeof(u16)) >
+			   sizeof(s3info[ns3info].info)) {
 				pr_err("S3 inforec length too long - aborting\n");
 				return 1;
 			}

commit e3c2b451b42e143f265e40cafa4e08d051123436
Author: Aede Symen Hoekstra <aedesymen@gmail.com>
Date:   Sun Nov 16 16:48:49 2014 +0100

    staging: wlan-ng: prism2fw: fixed code style issue
    
    Fixed checkpatch.pl warning message: line over 80 characters
    
    Signed-off-by: Aede Symen Hoekstra <aedesymen@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/prism2fw.c b/drivers/staging/wlan-ng/prism2fw.c
index e907380f9163..9408644cc8b8 100644
--- a/drivers/staging/wlan-ng/prism2fw.c
+++ b/drivers/staging/wlan-ng/prism2fw.c
@@ -238,7 +238,8 @@ static int prism2_fwtry(struct usb_device *udev, wlandevice_t *wlandev)
 *	0	- success
 *	~0	- failure
 ----------------------------------------------------------------*/
-static int prism2_fwapply(const struct ihex_binrec *rfptr, wlandevice_t *wlandev)
+static int prism2_fwapply(const struct ihex_binrec *rfptr,
+			  wlandevice_t *wlandev)
 {
 	signed int result = 0;
 	struct p80211msg_dot11req_mibget getmsg;

commit ad96f37f06596c6a7bd4dae3cf364bbb4ab7d7a4
Author: Tapasweni Pathak <tapaswenipathak@gmail.com>
Date:   Wed Oct 8 23:33:40 2014 +0530

    staging: wlan-ng: replace kmalloc and memset with kzalloc
    
    Replace kmalloc and memset with a single call of kzalloc in
    file of wlan-ng.
    
    Signed-off-by: Tapasweni Pathak <tapaswenipathak@gmail.com>
    Reviewed-by: Josh Triplett <josh@joshtriplett.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/prism2fw.c b/drivers/staging/wlan-ng/prism2fw.c
index 6c38f797d1ab..e907380f9163 100644
--- a/drivers/staging/wlan-ng/prism2fw.c
+++ b/drivers/staging/wlan-ng/prism2fw.c
@@ -986,8 +986,8 @@ static int writeimage(wlandevice_t *wlandev, struct imgchunk *fchunk,
 	u32 currlen;
 	u32 currdaddr;
 
-	rstmsg = kmalloc(sizeof(*rstmsg), GFP_KERNEL);
-	rwrmsg = kmalloc(sizeof(*rwrmsg), GFP_KERNEL);
+	rstmsg = kzalloc(sizeof(*rstmsg), GFP_KERNEL);
+	rwrmsg = kzalloc(sizeof(*rwrmsg), GFP_KERNEL);
 	if (!rstmsg || !rwrmsg) {
 		kfree(rstmsg);
 		kfree(rwrmsg);
@@ -997,7 +997,6 @@ static int writeimage(wlandevice_t *wlandev, struct imgchunk *fchunk,
 	}
 
 	/* Initialize the messages */
-	memset(rstmsg, 0, sizeof(*rstmsg));
 	strcpy(rstmsg->devname, wlandev->name);
 	rstmsg->msgcode = DIDmsg_p2req_ramdl_state;
 	rstmsg->msglen = sizeof(*rstmsg);
@@ -1011,7 +1010,6 @@ static int writeimage(wlandevice_t *wlandev, struct imgchunk *fchunk,
 	rstmsg->exeaddr.len = sizeof(u32);
 	rstmsg->resultcode.len = sizeof(u32);
 
-	memset(rwrmsg, 0, sizeof(*rwrmsg));
 	strcpy(rwrmsg->devname, wlandev->name);
 	rwrmsg->msgcode = DIDmsg_p2req_ramdl_write;
 	rwrmsg->msglen = sizeof(*rwrmsg);

commit d41b7b74cfab08cf7a5c07fafac474af9dd51d9c
Author: Artemiy Volkov <artemiyv@acm.org>
Date:   Thu Aug 14 16:20:09 2014 +1000

    Staging: wlan-ng: Merge string literals on adjacent lines in prism2fw.c
    
    This patch fixes the 'quoted string split across lines' checkpatch.pl
    warning in prism2fw.c.
    
    Signed-off-by: Artemiy Volkov <artemiyv@acm.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/prism2fw.c b/drivers/staging/wlan-ng/prism2fw.c
index 3f5f7cc105f8..6c38f797d1ab 100644
--- a/drivers/staging/wlan-ng/prism2fw.c
+++ b/drivers/staging/wlan-ng/prism2fw.c
@@ -413,9 +413,7 @@ static int crcimage(struct imgchunk *fchunk, unsigned int nfchunks,
 				break;
 		}
 		if (c >= nfchunks) {
-			pr_err("Failed to find chunk for "
-			       "crcrec[%d], addr=0x%06x len=%d , "
-			       "aborting crc.\n",
+			pr_err("Failed to find chunk for crcrec[%d], addr=0x%06x len=%d , aborting crc.\n",
 			       i, s3crc[i].addr, s3crc[i].len);
 			return 1;
 		}
@@ -628,8 +626,8 @@ static int mkpdrlist(struct pda *pda)
 
 	}
 	if (curroff >= (HFA384x_PDA_LEN_MAX / 2)) {
-		pr_err("no end record found or invalid lengths in "
-		       "PDR data, exiting. %x %d\n", curroff, pda->nrec);
+		pr_err("no end record found or invalid lengths in PDR data, exiting. %x %d\n",
+		       curroff, pda->nrec);
 		return 1;
 	}
 	if (le16_to_cpu(pda16[curroff + 1]) == HFA384x_PDR_END_OF_PDA) {
@@ -685,8 +683,8 @@ static int plugimage(struct imgchunk *fchunk, unsigned int nfchunks,
 			j = -1;
 		}
 		if (j >= pda->nrec && j != -1) { /*  if no matching PDR, fail */
-			pr_warn("warning: Failed to find PDR for "
-			       "plugrec 0x%04x.\n", s3plug[i].itemcode);
+			pr_warn("warning: Failed to find PDR for plugrec 0x%04x.\n",
+				s3plug[i].itemcode);
 			continue;	/* and move on to the next PDR */
 #if 0
 			/* MSM: They swear that unless it's the MAC address,
@@ -703,8 +701,7 @@ static int plugimage(struct imgchunk *fchunk, unsigned int nfchunks,
 
 		/* Validate plug len against PDR len */
 		if (j != -1 && s3plug[i].len < le16_to_cpu(pda->rec[j]->len)) {
-			pr_err("error: Plug vs. PDR len mismatch for "
-			       "plugrec 0x%04x, abort plugging.\n",
+			pr_err("error: Plug vs. PDR len mismatch for plugrec 0x%04x, abort plugging.\n",
 			       s3plug[i].itemcode);
 			result = 1;
 			continue;
@@ -718,8 +715,8 @@ static int plugimage(struct imgchunk *fchunk, unsigned int nfchunks,
 				break;
 		}
 		if (c >= nfchunks) {
-			pr_err("error: Failed to find image chunk for "
-			       "plugrec 0x%04x.\n", s3plug[i].itemcode);
+			pr_err("error: Failed to find image chunk for plugrec 0x%04x.\n",
+			       s3plug[i].itemcode);
 			result = 1;
 			continue;
 		}
@@ -727,8 +724,7 @@ static int plugimage(struct imgchunk *fchunk, unsigned int nfchunks,
 		/* Plug data */
 		chunkoff = pstart - cstart;
 		dest = fchunk[c].data + chunkoff;
-		pr_debug("Plugging item 0x%04x @ 0x%06x, len=%d, "
-			 "cnum=%d coff=0x%06x\n",
+		pr_debug("Plugging item 0x%04x @ 0x%06x, len=%d, cnum=%d coff=0x%06x\n",
 			 s3plug[i].itemcode, pstart, s3plug[i].len,
 			 c, chunkoff);
 
@@ -881,8 +877,7 @@ static int read_fwfile(const struct ihex_binrec *record)
 		switch (addr) {
 		case S3ADDR_START:
 			startaddr = *ptr32;
-			pr_debug("  S7 start addr, record=%d "
-				      " addr=0x%08x\n",
+			pr_debug("  S7 start addr, record=%d addr=0x%08x\n",
 				      rcnt,
 				      startaddr);
 			break;
@@ -891,8 +886,7 @@ static int read_fwfile(const struct ihex_binrec *record)
 			s3plug[ns3plug].addr = *(ptr32 + 1);
 			s3plug[ns3plug].len = *(ptr32 + 2);
 
-			pr_debug("  S3 plugrec, record=%d "
-				      "itemcode=0x%08x addr=0x%08x len=%d\n",
+			pr_debug("  S3 plugrec, record=%d itemcode=0x%08x addr=0x%08x len=%d\n",
 				      rcnt,
 				      s3plug[ns3plug].itemcode,
 				      s3plug[ns3plug].addr,
@@ -909,8 +903,7 @@ static int read_fwfile(const struct ihex_binrec *record)
 			s3crc[ns3crc].len = *(ptr32 + 1);
 			s3crc[ns3crc].dowrite = *(ptr32 + 2);
 
-			pr_debug("  S3 crcrec, record=%d "
-				      "addr=0x%08x len=%d write=0x%08x\n",
+			pr_debug("  S3 crcrec, record=%d addr=0x%08x len=%d write=0x%08x\n",
 				      rcnt,
 				      s3crc[ns3crc].addr,
 				      s3crc[ns3crc].len,
@@ -925,8 +918,7 @@ static int read_fwfile(const struct ihex_binrec *record)
 			s3info[ns3info].len = *ptr16;
 			s3info[ns3info].type = *(ptr16 + 1);
 
-			pr_debug("  S3 inforec, record=%d "
-			      "len=0x%04x type=0x%04x\n",
+			pr_debug("  S3 inforec, record=%d len=0x%04x type=0x%04x\n",
 				      rcnt,
 				      s3info[ns3info].len,
 				      s3info[ns3info].type);
@@ -1000,8 +992,7 @@ static int writeimage(wlandevice_t *wlandev, struct imgchunk *fchunk,
 		kfree(rstmsg);
 		kfree(rwrmsg);
 		netdev_err(wlandev->netdev,
-			   "writeimage: no memory for firmware download, "
-			   "aborting download\n");
+			   "writeimage: no memory for firmware download, aborting download\n");
 		return -ENOMEM;
 	}
 
@@ -1045,15 +1036,15 @@ static int writeimage(wlandevice_t *wlandev, struct imgchunk *fchunk,
 	result = prism2mgmt_ramdl_state(wlandev, rstmsg);
 	if (result) {
 		netdev_err(wlandev->netdev,
-			   "writeimage state enable failed w/ result=%d, "
-			   "aborting download\n", result);
+			   "writeimage state enable failed w/ result=%d, aborting download\n",
+			   result);
 		goto free_result;
 	}
 	resultcode = rstmsg->resultcode.data;
 	if (resultcode != P80211ENUM_resultcode_success) {
 		netdev_err(wlandev->netdev,
-			   "writeimage()->xxxdl_state msg indicates failure, "
-			   "w/ resultcode=%d, aborting download.\n", resultcode);
+			   "writeimage()->xxxdl_state msg indicates failure, w/ resultcode=%d, aborting download.\n",
+			   resultcode);
 		result = 1;
 		goto free_result;
 	}
@@ -1089,14 +1080,13 @@ static int writeimage(wlandevice_t *wlandev, struct imgchunk *fchunk,
 			/* Check the results */
 			if (result) {
 				netdev_err(wlandev->netdev,
-					   "writeimage chunk write failed w/ "
-					   "result=%d, aborting download\n", result);
+					   "writeimage chunk write failed w/ result=%d, aborting download\n",
+					   result);
 				goto free_result;
 			}
 			resultcode = rstmsg->resultcode.data;
 			if (resultcode != P80211ENUM_resultcode_success) {
-				pr_err("writeimage()->xxxdl_write msg indicates failure, "
-				       "w/ resultcode=%d, aborting download.\n",
+				pr_err("writeimage()->xxxdl_write msg indicates failure, w/ resultcode=%d, aborting download.\n",
 				       resultcode);
 				result = 1;
 				goto free_result;
@@ -1113,15 +1103,15 @@ static int writeimage(wlandevice_t *wlandev, struct imgchunk *fchunk,
 	result = prism2mgmt_ramdl_state(wlandev, rstmsg);
 	if (result) {
 		netdev_err(wlandev->netdev,
-			   "writeimage state disable failed w/ result=%d, "
-			   "aborting download\n", result);
+			   "writeimage state disable failed w/ result=%d, aborting download\n",
+			   result);
 		goto free_result;
 	}
 	resultcode = rstmsg->resultcode.data;
 	if (resultcode != P80211ENUM_resultcode_success) {
 		netdev_err(wlandev->netdev,
-			   "writeimage()->xxxdl_state msg indicates failure, "
-			   "w/ resultcode=%d, aborting download.\n", resultcode);
+			   "writeimage()->xxxdl_state msg indicates failure, w/ resultcode=%d, aborting download.\n",
+			   resultcode);
 		result = 1;
 		goto free_result;
 	}

commit 41cb65c4854e14f12b1cbb8215e509d8ad4d0c88
Author: A Raghavendra Rao <raghav3276@gmail.com>
Date:   Thu Aug 7 14:10:39 2014 +0530

    Staging: wlan-ng: fix sparse warning in prism2fw.c
    
    Fix the following sparse warning :
    
    In file included from drivers/staging/wlan-ng/prism2usb.c:5:0:
    drivers/staging/wlan-ng/prism2fw.c: In function
    read_cardpda.constprop.43:
    drivers/staging/wlan-ng/prism2fw.c:792:1: warning: the frame size of
    1068 bytes is larger than 1024 bytes [-Wframe-larger-than=]
    
    The variable to 'struct p80211msg_p2req_readpda' was previously being created
    on the stack, which inturn exeeded the frame size limit, resulting in a
    sparse warning. This patch alloctes the memory to the structure dynamically
    and the operations are left unchanged.
    
    Signed-off-by: A Raghavendra Rao <arrao@cdac.in>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/prism2fw.c b/drivers/staging/wlan-ng/prism2fw.c
index 42c14b0b6833..3f5f7cc105f8 100644
--- a/drivers/staging/wlan-ng/prism2fw.c
+++ b/drivers/staging/wlan-ng/prism2fw.c
@@ -764,30 +764,35 @@ static int plugimage(struct imgchunk *fchunk, unsigned int nfchunks,
 static int read_cardpda(struct pda *pda, wlandevice_t *wlandev)
 {
 	int result = 0;
-	struct p80211msg_p2req_readpda msg;
+	struct p80211msg_p2req_readpda *msg;
+
+	msg = kzalloc(sizeof(*msg), GFP_KERNEL);
+	if (!msg)
+		return -ENOMEM;
 
 	/* set up the msg */
-	msg.msgcode = DIDmsg_p2req_readpda;
-	msg.msglen = sizeof(msg);
-	strcpy(msg.devname, wlandev->name);
-	msg.pda.did = DIDmsg_p2req_readpda_pda;
-	msg.pda.len = HFA384x_PDA_LEN_MAX;
-	msg.pda.status = P80211ENUM_msgitem_status_no_value;
-	msg.resultcode.did = DIDmsg_p2req_readpda_resultcode;
-	msg.resultcode.len = sizeof(u32);
-	msg.resultcode.status = P80211ENUM_msgitem_status_no_value;
-
-	if (prism2mgmt_readpda(wlandev, &msg) != 0) {
+	msg->msgcode = DIDmsg_p2req_readpda;
+	msg->msglen = sizeof(msg);
+	strcpy(msg->devname, wlandev->name);
+	msg->pda.did = DIDmsg_p2req_readpda_pda;
+	msg->pda.len = HFA384x_PDA_LEN_MAX;
+	msg->pda.status = P80211ENUM_msgitem_status_no_value;
+	msg->resultcode.did = DIDmsg_p2req_readpda_resultcode;
+	msg->resultcode.len = sizeof(u32);
+	msg->resultcode.status = P80211ENUM_msgitem_status_no_value;
+
+	if (prism2mgmt_readpda(wlandev, msg) != 0) {
 		/* prism2mgmt_readpda prints an errno if appropriate */
 		result = -1;
-	} else if (msg.resultcode.data == P80211ENUM_resultcode_success) {
-		memcpy(pda->buf, msg.pda.data, HFA384x_PDA_LEN_MAX);
+	} else if (msg->resultcode.data == P80211ENUM_resultcode_success) {
+		memcpy(pda->buf, msg->pda.data, HFA384x_PDA_LEN_MAX);
 		result = mkpdrlist(pda);
 	} else {
 		/* resultcode must've been something other than success */
 		result = -1;
 	}
 
+	kfree(msg);
 	return result;
 }
 

commit 1177ce46a1231d66ba67409bbfabf2b7b2f90de0
Author: Matt Kurz <matt@ninezulu.com>
Date:   Wed Jul 2 05:59:54 2014 +1000

    staging: wlan-ng/prism2fw.c: Add blank line after declarations
    
    Fix checkpatch.pl warnings due to missing blank line after declarations
    
    Signed-off-by: Matt Kurz <matt@ninezulu.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/prism2fw.c b/drivers/staging/wlan-ng/prism2fw.c
index f7870355c69f..42c14b0b6833 100644
--- a/drivers/staging/wlan-ng/prism2fw.c
+++ b/drivers/staging/wlan-ng/prism2fw.c
@@ -445,6 +445,7 @@ static int crcimage(struct imgchunk *fchunk, unsigned int nfchunks,
 static void free_chunks(struct imgchunk *fchunk, unsigned int *nfchunks)
 {
 	int i;
+
 	for (i = 0; i < *nfchunks; i++)
 		kfree(fchunk[i].data);
 
@@ -1060,6 +1061,7 @@ static int writeimage(wlandevice_t *wlandev, struct imgchunk *fchunk,
 		for (j = 0; j < nwrites; j++) {
 			/* TODO Move this to a separate function */
 			int lenleft = fchunk[i].len - (WRITESIZE_MAX * j);
+
 			if (fchunk[i].len > WRITESIZE_MAX)
 				currlen = WRITESIZE_MAX;
 			else

commit 02d9b1eb4b21b9309efdf8c8aee023a59d3f76e0
Author: Vitaly Osipov <vitaly.osipov@gmail.com>
Date:   Sun May 18 16:59:36 2014 +1000

    staging: wlan-ng: use netdev_() instead of printk()
    
    Replaced all uses of printk() in wlan-ng with netdev_err / _warn
    where a netdev exists. If a few cases where a netdev does not yet
    exist, dev_ or pr_ was used.
    
    Checkpatch complains about lines over 80 chars or split string
    constants - the messages are just too long, keeping it completely
    happy would make the code less readable.
    
    Signed-off-by: Vitaly Osipov <vitaly.osipov@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/prism2fw.c b/drivers/staging/wlan-ng/prism2fw.c
index 2b0c23587dfc..f7870355c69f 100644
--- a/drivers/staging/wlan-ng/prism2fw.c
+++ b/drivers/staging/wlan-ng/prism2fw.c
@@ -205,19 +205,20 @@ static int prism2_fwtry(struct usb_device *udev, wlandevice_t *wlandev)
 {
 	const struct firmware *fw_entry = NULL;
 
-	printk(KERN_INFO "prism2_usb: Checking for firmware %s\n",
+	netdev_info(wlandev->netdev, "prism2_usb: Checking for firmware %s\n",
 	       PRISM2_USB_FWFILE);
 	if (request_ihex_firmware(&fw_entry,
 				  PRISM2_USB_FWFILE, &udev->dev) != 0) {
-		printk(KERN_INFO
+		netdev_info(wlandev->netdev,
 		       "prism2_usb: Firmware not available, but not essential\n");
-		printk(KERN_INFO
+		netdev_info(wlandev->netdev,
 		       "prism2_usb: can continue to use card anyway.\n");
 		return 1;
 	}
 
-	printk(KERN_INFO "prism2_usb: %s will be processed, size %zu\n",
-	       PRISM2_USB_FWFILE, fw_entry->size);
+	netdev_info(wlandev->netdev,
+		    "prism2_usb: %s will be processed, size %zu\n",
+		    PRISM2_USB_FWFILE, fw_entry->size);
 	prism2_fwapply((const struct ihex_binrec *)fw_entry->data, wlandev);
 
 	release_firmware(fw_entry);
@@ -275,7 +276,7 @@ static int prism2_fwapply(const struct ihex_binrec *rfptr, wlandevice_t *wlandev
 
 	/* Build the PDA we're going to use. */
 	if (read_cardpda(&pda, wlandev)) {
-		printk(KERN_ERR "load_cardpda failed, exiting.\n");
+		netdev_err(wlandev->netdev, "load_cardpda failed, exiting.\n");
 		return 1;
 	}
 
@@ -299,7 +300,7 @@ static int prism2_fwapply(const struct ihex_binrec *rfptr, wlandevice_t *wlandev
 	/* DIDmsg_dot11req_mibget */
 	prism2mgmt_mibset_mibget(wlandev, &getmsg);
 	if (getmsg.resultcode.data != P80211ENUM_resultcode_success)
-		printk(KERN_ERR "Couldn't fetch PRI-SUP info\n");
+		netdev_err(wlandev->netdev, "Couldn't fetch PRI-SUP info\n");
 
 	/* Already in host order */
 	priid.role = *data++;
@@ -311,19 +312,21 @@ static int prism2_fwapply(const struct ihex_binrec *rfptr, wlandevice_t *wlandev
 	/* Read the S3 file */
 	result = read_fwfile(rfptr);
 	if (result) {
-		printk(KERN_ERR "Failed to read the data exiting.\n");
+		netdev_err(wlandev->netdev,
+			   "Failed to read the data exiting.\n");
 		return 1;
 	}
 
 	result = validate_identity();
 
 	if (result) {
-		printk(KERN_ERR "Incompatible firmware image.\n");
+		netdev_err(wlandev->netdev, "Incompatible firmware image.\n");
 		return 1;
 	}
 
 	if (startaddr == 0x00000000) {
-		printk(KERN_ERR "Can't RAM download a Flash image!\n");
+		netdev_err(wlandev->netdev,
+			   "Can't RAM download a Flash image!\n");
 		return 1;
 	}
 
@@ -333,20 +336,20 @@ static int prism2_fwapply(const struct ihex_binrec *rfptr, wlandevice_t *wlandev
 	/* Do any plugging */
 	result = plugimage(fchunk, nfchunks, s3plug, ns3plug, &pda);
 	if (result) {
-		printk(KERN_ERR "Failed to plug data.\n");
+		netdev_err(wlandev->netdev, "Failed to plug data.\n");
 		return 1;
 	}
 
 	/* Insert any CRCs */
 	if (crcimage(fchunk, nfchunks, s3crc, ns3crc)) {
-		printk(KERN_ERR "Failed to insert all CRCs\n");
+		netdev_err(wlandev->netdev, "Failed to insert all CRCs\n");
 		return 1;
 	}
 
 	/* Write the image */
 	result = writeimage(wlandev, fchunk, nfchunks);
 	if (result) {
-		printk(KERN_ERR "Failed to ramwrite image data.\n");
+		netdev_err(wlandev->netdev, "Failed to ramwrite image data.\n");
 		return 1;
 	}
 
@@ -354,7 +357,7 @@ static int prism2_fwapply(const struct ihex_binrec *rfptr, wlandevice_t *wlandev
 	free_chunks(fchunk, &nfchunks);
 	free_srecs();
 
-	printk(KERN_INFO "prism2_usb: firmware loading finished.\n");
+	netdev_info(wlandev->netdev, "prism2_usb: firmware loading finished.\n");
 
 	return result;
 }
@@ -410,8 +413,7 @@ static int crcimage(struct imgchunk *fchunk, unsigned int nfchunks,
 				break;
 		}
 		if (c >= nfchunks) {
-			printk(KERN_ERR
-			       "Failed to find chunk for "
+			pr_err("Failed to find chunk for "
 			       "crcrec[%d], addr=0x%06x len=%d , "
 			       "aborting crc.\n",
 			       i, s3crc[i].addr, s3crc[i].len);
@@ -537,8 +539,7 @@ static int mkimage(struct imgchunk *clist, unsigned int *ccnt)
 	for (i = 0; i < *ccnt; i++) {
 		clist[i].data = kzalloc(clist[i].len, GFP_KERNEL);
 		if (clist[i].data == NULL) {
-			printk(KERN_ERR
-			       "failed to allocate image space, exitting.\n");
+			pr_err("failed to allocate image space, exitting.\n");
 			return 1;
 		}
 		pr_debug("chunk[%d]: addr=0x%06x len=%d\n",
@@ -556,8 +557,7 @@ static int mkimage(struct imgchunk *clist, unsigned int *ccnt)
 				break;
 		}
 		if (((unsigned int)j) >= (*ccnt)) {
-			printk(KERN_ERR
-			       "s3rec(a=0x%06x,l=%d), no chunk match, exiting.\n",
+			pr_err("s3rec(a=0x%06x,l=%d), no chunk match, exiting.\n",
 			       s3start, s3data[i].len);
 			return 1;
 		}
@@ -627,8 +627,7 @@ static int mkpdrlist(struct pda *pda)
 
 	}
 	if (curroff >= (HFA384x_PDA_LEN_MAX / 2)) {
-		printk(KERN_ERR
-		       "no end record found or invalid lengths in "
+		pr_err("no end record found or invalid lengths in "
 		       "PDR data, exiting. %x %d\n", curroff, pda->nrec);
 		return 1;
 	}
@@ -685,8 +684,7 @@ static int plugimage(struct imgchunk *fchunk, unsigned int nfchunks,
 			j = -1;
 		}
 		if (j >= pda->nrec && j != -1) { /*  if no matching PDR, fail */
-			printk(KERN_WARNING
-			       "warning: Failed to find PDR for "
+			pr_warn("warning: Failed to find PDR for "
 			       "plugrec 0x%04x.\n", s3plug[i].itemcode);
 			continue;	/* and move on to the next PDR */
 #if 0
@@ -704,8 +702,7 @@ static int plugimage(struct imgchunk *fchunk, unsigned int nfchunks,
 
 		/* Validate plug len against PDR len */
 		if (j != -1 && s3plug[i].len < le16_to_cpu(pda->rec[j]->len)) {
-			printk(KERN_ERR
-			       "error: Plug vs. PDR len mismatch for "
+			pr_err("error: Plug vs. PDR len mismatch for "
 			       "plugrec 0x%04x, abort plugging.\n",
 			       s3plug[i].itemcode);
 			result = 1;
@@ -720,8 +717,7 @@ static int plugimage(struct imgchunk *fchunk, unsigned int nfchunks,
 				break;
 		}
 		if (c >= nfchunks) {
-			printk(KERN_ERR
-			       "error: Failed to find image chunk for "
+			pr_err("error: Failed to find image chunk for "
 			       "plugrec 0x%04x.\n", s3plug[i].itemcode);
 			result = 1;
 			continue;
@@ -898,7 +894,7 @@ static int read_fwfile(const struct ihex_binrec *record)
 
 			ns3plug++;
 			if (ns3plug == S3PLUG_MAX) {
-				printk(KERN_ERR "S3 plugrec limit reached - aborting\n");
+				pr_err("S3 plugrec limit reached - aborting\n");
 				return 1;
 			}
 			break;
@@ -915,7 +911,7 @@ static int read_fwfile(const struct ihex_binrec *record)
 				      s3crc[ns3crc].dowrite);
 			ns3crc++;
 			if (ns3crc == S3CRC_MAX) {
-				printk(KERN_ERR "S3 crcrec limit reached - aborting\n");
+				pr_err("S3 crcrec limit reached - aborting\n");
 				return 1;
 			}
 			break;
@@ -929,7 +925,7 @@ static int read_fwfile(const struct ihex_binrec *record)
 				      s3info[ns3info].len,
 				      s3info[ns3info].type);
 			if (((s3info[ns3info].len - 1) * sizeof(u16)) > sizeof(s3info[ns3info].info)) {
-				printk(KERN_ERR " S3 inforec length too long - aborting\n");
+				pr_err("S3 inforec length too long - aborting\n");
 				return 1;
 			}
 
@@ -943,7 +939,7 @@ static int read_fwfile(const struct ihex_binrec *record)
 
 			ns3info++;
 			if (ns3info == S3INFO_MAX) {
-				printk(KERN_ERR "S3 inforec limit reached - aborting\n");
+				pr_err("S3 inforec limit reached - aborting\n");
 				return 1;
 			}
 			break;
@@ -953,7 +949,7 @@ static int read_fwfile(const struct ihex_binrec *record)
 			s3data[ns3data].data = (uint8_t *) record->data;
 			ns3data++;
 			if (ns3data == S3DATA_MAX) {
-				printk(KERN_ERR "S3 datarec limit reached - aborting\n");
+				pr_err("S3 datarec limit reached - aborting\n");
 				return 1;
 			}
 			break;
@@ -997,9 +993,9 @@ static int writeimage(wlandevice_t *wlandev, struct imgchunk *fchunk,
 	if (!rstmsg || !rwrmsg) {
 		kfree(rstmsg);
 		kfree(rwrmsg);
-		printk(KERN_ERR
-		       "writeimage: no memory for firmware download, "
-		       "aborting download\n");
+		netdev_err(wlandev->netdev,
+			   "writeimage: no memory for firmware download, "
+			   "aborting download\n");
 		return -ENOMEM;
 	}
 
@@ -1042,16 +1038,16 @@ static int writeimage(wlandevice_t *wlandev, struct imgchunk *fchunk,
 
 	result = prism2mgmt_ramdl_state(wlandev, rstmsg);
 	if (result) {
-		printk(KERN_ERR
-		       "writeimage state enable failed w/ result=%d, "
-		       "aborting download\n", result);
+		netdev_err(wlandev->netdev,
+			   "writeimage state enable failed w/ result=%d, "
+			   "aborting download\n", result);
 		goto free_result;
 	}
 	resultcode = rstmsg->resultcode.data;
 	if (resultcode != P80211ENUM_resultcode_success) {
-		printk(KERN_ERR
-		       "writeimage()->xxxdl_state msg indicates failure, "
-		       "w/ resultcode=%d, aborting download.\n", resultcode);
+		netdev_err(wlandev->netdev,
+			   "writeimage()->xxxdl_state msg indicates failure, "
+			   "w/ resultcode=%d, aborting download.\n", resultcode);
 		result = 1;
 		goto free_result;
 	}
@@ -1085,15 +1081,14 @@ static int writeimage(wlandevice_t *wlandev, struct imgchunk *fchunk,
 
 			/* Check the results */
 			if (result) {
-				printk(KERN_ERR
-				       "writeimage chunk write failed w/ result=%d, "
-				       "aborting download\n", result);
+				netdev_err(wlandev->netdev,
+					   "writeimage chunk write failed w/ "
+					   "result=%d, aborting download\n", result);
 				goto free_result;
 			}
 			resultcode = rstmsg->resultcode.data;
 			if (resultcode != P80211ENUM_resultcode_success) {
-				printk(KERN_ERR
-				       "writeimage()->xxxdl_write msg indicates failure, "
+				pr_err("writeimage()->xxxdl_write msg indicates failure, "
 				       "w/ resultcode=%d, aborting download.\n",
 				       resultcode);
 				result = 1;
@@ -1110,16 +1105,16 @@ static int writeimage(wlandevice_t *wlandev, struct imgchunk *fchunk,
 
 	result = prism2mgmt_ramdl_state(wlandev, rstmsg);
 	if (result) {
-		printk(KERN_ERR
-		       "writeimage state disable failed w/ result=%d, "
-		       "aborting download\n", result);
+		netdev_err(wlandev->netdev,
+			   "writeimage state disable failed w/ result=%d, "
+			   "aborting download\n", result);
 		goto free_result;
 	}
 	resultcode = rstmsg->resultcode.data;
 	if (resultcode != P80211ENUM_resultcode_success) {
-		printk(KERN_ERR
-		       "writeimage()->xxxdl_state msg indicates failure, "
-		       "w/ resultcode=%d, aborting download.\n", resultcode);
+		netdev_err(wlandev->netdev,
+			   "writeimage()->xxxdl_state msg indicates failure, "
+			   "w/ resultcode=%d, aborting download.\n", resultcode);
 		result = 1;
 		goto free_result;
 	}

commit 4d8c1d0fdf7eda1570c00a89ce21037a2f0cd003
Author: Tugce Sirin <ztugcesirin@gmail.com>
Date:   Mon Mar 3 02:39:45 2014 +0200

    Staging: wlan-ng: Fix Sparse warning should it be static?
    
    This patch fixes following Sparse warning should it be static? in
    staging/wlan-ng.
    
    Signed-off-by: Tugce Sirin <ztugcesirin@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/prism2fw.c b/drivers/staging/wlan-ng/prism2fw.c
index 0dfd2a4933ef..2b0c23587dfc 100644
--- a/drivers/staging/wlan-ng/prism2fw.c
+++ b/drivers/staging/wlan-ng/prism2fw.c
@@ -201,7 +201,7 @@ static int validate_identity(void);
 *	0	- success
 *	~0	- failure
 ----------------------------------------------------------------*/
-int prism2_fwtry(struct usb_device *udev, wlandevice_t *wlandev)
+static int prism2_fwtry(struct usb_device *udev, wlandevice_t *wlandev)
 {
 	const struct firmware *fw_entry = NULL;
 

commit d34602de3ba29b3ceafe4e15e27a25c6a5bccc38
Author: Justin P. Mattock <justinmattock@gmail.com>
Date:   Mon Sep 24 09:16:57 2012 -0700

    staging "wlan-ng" Fix typos.
    
    Signed-off-by: Justin P. Mattock <justinmattock@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/prism2fw.c b/drivers/staging/wlan-ng/prism2fw.c
index e22784e74efe..0dfd2a4933ef 100644
--- a/drivers/staging/wlan-ng/prism2fw.c
+++ b/drivers/staging/wlan-ng/prism2fw.c
@@ -806,7 +806,7 @@ static int read_cardpda(struct pda *pda, wlandevice_t *wlandev)
 *
 * Note also that the start address record, originally an S7 record in
 * the srec file, is expected in the fw file to be like a data record but
-* with a certain address to make it identiable.
+* with a certain address to make it identifiable.
 *
 * Here's the SREC format that the fw should have come from:
 * S[37]nnaaaaaaaaddd...dddcc

commit ae24e13a6485a65802e0483ace9f657a89680c6a
Author: Devendra Naga <devendra.aaru@gmail.com>
Date:   Sun Sep 9 18:40:52 2012 +0530

    staging:wlan-ng: fix sparse warnings
    
    drivers/staging/wlan-ng/prism2fw.c:240:5: warning: symbol 'prism2_fwapply' was not declared. Should it be static?
    drivers/staging/wlan-ng/prism2fw.c:379:5: warning: symbol 'crcimage' was not declared. Should it be static?
    drivers/staging/wlan-ng/prism2fw.c:443:6: warning: symbol 'free_chunks' was not declared. Should it be static?
    drivers/staging/wlan-ng/prism2fw.c:465:6: warning: symbol 'free_srecs' was not declared. Should it be static?
    drivers/staging/wlan-ng/prism2fw.c:492:5: warning: symbol 'mkimage' was not declared. Should it be static?
    drivers/staging/wlan-ng/prism2fw.c:585:5: warning: symbol 'mkpdrlist' was not declared. Should it be static?
    drivers/staging/wlan-ng/prism2fw.c:659:5: warning: symbol 'plugimage' was not declared. Should it be static?
    drivers/staging/wlan-ng/prism2fw.c:767:5: warning: symbol 'read_cardpda' was not declared. Should it be static?
    drivers/staging/wlan-ng/prism2fw.c:857:5: warning: symbol 'read_fwfile' was not declared. Should it be static?
    drivers/staging/wlan-ng/prism2fw.c:981:5: warning: symbol 'writeimage' was not declared. Should it be static?
    drivers/staging/wlan-ng/prism2fw.c:1133:5: warning: symbol 'validate_identity' was not declared. Should it be static?
    
    Signed-off-by: Devendra Naga <devendra.aaru@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/prism2fw.c b/drivers/staging/wlan-ng/prism2fw.c
index 9d04e2c8c72f..e22784e74efe 100644
--- a/drivers/staging/wlan-ng/prism2fw.c
+++ b/drivers/staging/wlan-ng/prism2fw.c
@@ -237,7 +237,7 @@ int prism2_fwtry(struct usb_device *udev, wlandevice_t *wlandev)
 *	0	- success
 *	~0	- failure
 ----------------------------------------------------------------*/
-int prism2_fwapply(const struct ihex_binrec *rfptr, wlandevice_t *wlandev)
+static int prism2_fwapply(const struct ihex_binrec *rfptr, wlandevice_t *wlandev)
 {
 	signed int result = 0;
 	struct p80211msg_dot11req_mibget getmsg;
@@ -376,7 +376,7 @@ int prism2_fwapply(const struct ihex_binrec *rfptr, wlandevice_t *wlandev)
 *	0	success
 *	~0	failure
 ----------------------------------------------------------------*/
-int crcimage(struct imgchunk *fchunk, unsigned int nfchunks,
+static int crcimage(struct imgchunk *fchunk, unsigned int nfchunks,
 	     struct s3crcrec *s3crc, unsigned int ns3crc)
 {
 	int result = 0;
@@ -440,7 +440,7 @@ int crcimage(struct imgchunk *fchunk, unsigned int nfchunks,
 * Returns:
 *	nothing
 ----------------------------------------------------------------*/
-void free_chunks(struct imgchunk *fchunk, unsigned int *nfchunks)
+static void free_chunks(struct imgchunk *fchunk, unsigned int *nfchunks)
 {
 	int i;
 	for (i = 0; i < *nfchunks; i++)
@@ -462,7 +462,7 @@ void free_chunks(struct imgchunk *fchunk, unsigned int *nfchunks)
 * Returns:
 *	nothing
 ----------------------------------------------------------------*/
-void free_srecs(void)
+static void free_srecs(void)
 {
 	ns3data = 0;
 	memset(s3data, 0, sizeof(s3data));
@@ -489,7 +489,7 @@ void free_srecs(void)
 *	0	- success
 *	~0	- failure (probably an errno)
 ----------------------------------------------------------------*/
-int mkimage(struct imgchunk *clist, unsigned int *ccnt)
+static int mkimage(struct imgchunk *clist, unsigned int *ccnt)
 {
 	int result = 0;
 	int i;
@@ -582,7 +582,7 @@ int mkimage(struct imgchunk *clist, unsigned int *ccnt)
 *	0	- success
 *	~0	- failure (probably an errno)
 ----------------------------------------------------------------*/
-int mkpdrlist(struct pda *pda)
+static int mkpdrlist(struct pda *pda)
 {
 	int result = 0;
 	u16 *pda16 = (u16 *) pda->buf;
@@ -656,7 +656,7 @@ int mkpdrlist(struct pda *pda)
 *	0	success
 *	~0	failure
 ----------------------------------------------------------------*/
-int plugimage(struct imgchunk *fchunk, unsigned int nfchunks,
+static int plugimage(struct imgchunk *fchunk, unsigned int nfchunks,
 	      struct s3plugrec *s3plug, unsigned int ns3plug, struct pda *pda)
 {
 	int result = 0;
@@ -764,7 +764,7 @@ int plugimage(struct imgchunk *fchunk, unsigned int nfchunks,
 *	0	- success
 *	~0	- failure (probably an errno)
 ----------------------------------------------------------------*/
-int read_cardpda(struct pda *pda, wlandevice_t *wlandev)
+static int read_cardpda(struct pda *pda, wlandevice_t *wlandev)
 {
 	int result = 0;
 	struct p80211msg_p2req_readpda msg;
@@ -854,7 +854,7 @@ int read_cardpda(struct pda *pda, wlandevice_t *wlandev)
 *	0	- success
 *	~0	- failure (probably an errno)
 ----------------------------------------------------------------*/
-int read_fwfile(const struct ihex_binrec *record)
+static int read_fwfile(const struct ihex_binrec *record)
 {
 	int		i;
 	int		rcnt = 0;
@@ -978,7 +978,7 @@ int read_fwfile(const struct ihex_binrec *record)
 *	0	success
 *	~0	failure
 ----------------------------------------------------------------*/
-int writeimage(wlandevice_t *wlandev, struct imgchunk *fchunk,
+static int writeimage(wlandevice_t *wlandev, struct imgchunk *fchunk,
 	       unsigned int nfchunks)
 {
 	int result = 0;
@@ -1130,7 +1130,7 @@ int writeimage(wlandevice_t *wlandev, struct imgchunk *fchunk,
 	return result;
 }
 
-int validate_identity(void)
+static int validate_identity(void)
 {
 	int i;
 	int result = 1;

commit 023aeaa496557193743ccfab313fcb9c148f1079
Author: Devendra Naga <devendra.aaru@gmail.com>
Date:   Sun Sep 9 18:40:51 2012 +0530

    staging:wlan-ng: slove sparse warnings
    
    drivers/staging/wlan-ng/prism2fw.c:127:18: warning: symbol 's3data' was not declared. Should it be static?
    drivers/staging/wlan-ng/prism2fw.c:130:14: warning: symbol 'ns3plug' was not declared. Should it be static?
    drivers/staging/wlan-ng/prism2fw.c:131:18: warning: symbol 's3plug' was not declared. Should it be static?
    drivers/staging/wlan-ng/prism2fw.c:134:14: warning: symbol 'ns3crc' was not declared. Should it be static?
    drivers/staging/wlan-ng/prism2fw.c:135:17: warning: symbol 's3crc' was not declared. Should it be static?
    drivers/staging/wlan-ng/prism2fw.c:138:14: warning: symbol 'ns3info' was not declared. Should it be static?
    drivers/staging/wlan-ng/prism2fw.c:139:18: warning: symbol 's3info' was not declared. Should it be static?
    drivers/staging/wlan-ng/prism2fw.c:142:5: warning: symbol 'startaddr' was not declared. Should it be static?
    drivers/staging/wlan-ng/prism2fw.c:145:14: warning: symbol 'nfchunks' was not declared. Should it be static?
    drivers/staging/wlan-ng/prism2fw.c:146:17: warning: symbol 'fchunk' was not declared. Should it be static?
    drivers/staging/wlan-ng/prism2fw.c:154:12: warning: symbol 'pda' was not declared. Should it be static?
    drivers/staging/wlan-ng/prism2fw.c:155:21: warning: symbol 'nicid' was not declared. Should it be static?
    drivers/staging/wlan-ng/prism2fw.c:156:20: warning: symbol 'rfid' was not declared. Should it be static?
    drivers/staging/wlan-ng/prism2fw.c:157:20: warning: symbol 'macid' was not declared. Should it be static?
    drivers/staging/wlan-ng/prism2fw.c:158:20: warning: symbol 'priid' was not declared. Should it be static?
    
    Signed-off-by: Devendra Naga <devendra.aaru@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/prism2fw.c b/drivers/staging/wlan-ng/prism2fw.c
index 66c9aa972310..9d04e2c8c72f 100644
--- a/drivers/staging/wlan-ng/prism2fw.c
+++ b/drivers/staging/wlan-ng/prism2fw.c
@@ -123,27 +123,27 @@ struct imgchunk {
 /* s-record image processing */
 
 /* Data records */
-unsigned int ns3data;
-struct s3datarec s3data[S3DATA_MAX];
+static unsigned int ns3data;
+static struct s3datarec s3data[S3DATA_MAX];
 
 /* Plug records */
-unsigned int ns3plug;
-struct s3plugrec s3plug[S3PLUG_MAX];
+static unsigned int ns3plug;
+static struct s3plugrec s3plug[S3PLUG_MAX];
 
 /* CRC records */
-unsigned int ns3crc;
-struct s3crcrec s3crc[S3CRC_MAX];
+static unsigned int ns3crc;
+static struct s3crcrec s3crc[S3CRC_MAX];
 
 /* Info records */
-unsigned int ns3info;
-struct s3inforec s3info[S3INFO_MAX];
+static unsigned int ns3info;
+static struct s3inforec s3info[S3INFO_MAX];
 
 /* S7 record (there _better_ be only one) */
-u32 startaddr;
+static u32 startaddr;
 
 /* Load image chunks */
-unsigned int nfchunks;
-struct imgchunk fchunk[CHUNKS_MAX];
+static unsigned int nfchunks;
+static struct imgchunk fchunk[CHUNKS_MAX];
 
 /* Note that for the following pdrec_t arrays, the len and code */
 /*   fields are stored in HOST byte order. The mkpdrlist() function */
@@ -151,11 +151,11 @@ struct imgchunk fchunk[CHUNKS_MAX];
 /*----------------------------------------------------------------*/
 /* PDA, built from [card|newfile]+[addfile1+addfile2...] */
 
-struct pda pda;
-hfa384x_compident_t nicid;
-hfa384x_caplevel_t rfid;
-hfa384x_caplevel_t macid;
-hfa384x_caplevel_t priid;
+static struct pda pda;
+static hfa384x_compident_t nicid;
+static hfa384x_caplevel_t rfid;
+static hfa384x_caplevel_t macid;
+static hfa384x_caplevel_t priid;
 
 /*================================================================*/
 /* Local Function Declarations */

commit c90e3e80b9751335cc98934ae32188fa7de6bccd
Author: Randy Dunlap <rdunlap@xenotime.net>
Date:   Sun Jun 24 21:35:29 2012 -0700

    staging: reduce stack usage in prism2fw.c
    
    Fix frame size (stack usage) warning by allocating and freeing
    pointers to the data.
    
    drivers/staging/wlan-ng/prism2fw.c:1115:1: warning: the frame size of 4288 bytes is larger than 2048 bytes
    
    Signed-off-by: Randy Dunlap <rdunlap@xenotime.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/prism2fw.c b/drivers/staging/wlan-ng/prism2fw.c
index f13cdc9ab412..66c9aa972310 100644
--- a/drivers/staging/wlan-ng/prism2fw.c
+++ b/drivers/staging/wlan-ng/prism2fw.c
@@ -982,9 +982,8 @@ int writeimage(wlandevice_t *wlandev, struct imgchunk *fchunk,
 	       unsigned int nfchunks)
 {
 	int result = 0;
-	struct p80211msg_p2req_ramdl_state rstatemsg;
-	struct p80211msg_p2req_ramdl_write rwritemsg;
-	struct p80211msg *msgp;
+	struct p80211msg_p2req_ramdl_state *rstmsg;
+	struct p80211msg_p2req_ramdl_write *rwrmsg;
 	u32 resultcode;
 	int i;
 	int j;
@@ -993,57 +992,68 @@ int writeimage(wlandevice_t *wlandev, struct imgchunk *fchunk,
 	u32 currlen;
 	u32 currdaddr;
 
+	rstmsg = kmalloc(sizeof(*rstmsg), GFP_KERNEL);
+	rwrmsg = kmalloc(sizeof(*rwrmsg), GFP_KERNEL);
+	if (!rstmsg || !rwrmsg) {
+		kfree(rstmsg);
+		kfree(rwrmsg);
+		printk(KERN_ERR
+		       "writeimage: no memory for firmware download, "
+		       "aborting download\n");
+		return -ENOMEM;
+	}
+
 	/* Initialize the messages */
-	memset(&rstatemsg, 0, sizeof(rstatemsg));
-	strcpy(rstatemsg.devname, wlandev->name);
-	rstatemsg.msgcode = DIDmsg_p2req_ramdl_state;
-	rstatemsg.msglen = sizeof(rstatemsg);
-	rstatemsg.enable.did = DIDmsg_p2req_ramdl_state_enable;
-	rstatemsg.exeaddr.did = DIDmsg_p2req_ramdl_state_exeaddr;
-	rstatemsg.resultcode.did = DIDmsg_p2req_ramdl_state_resultcode;
-	rstatemsg.enable.status = P80211ENUM_msgitem_status_data_ok;
-	rstatemsg.exeaddr.status = P80211ENUM_msgitem_status_data_ok;
-	rstatemsg.resultcode.status = P80211ENUM_msgitem_status_no_value;
-	rstatemsg.enable.len = sizeof(u32);
-	rstatemsg.exeaddr.len = sizeof(u32);
-	rstatemsg.resultcode.len = sizeof(u32);
-
-	memset(&rwritemsg, 0, sizeof(rwritemsg));
-	strcpy(rwritemsg.devname, wlandev->name);
-	rwritemsg.msgcode = DIDmsg_p2req_ramdl_write;
-	rwritemsg.msglen = sizeof(rwritemsg);
-	rwritemsg.addr.did = DIDmsg_p2req_ramdl_write_addr;
-	rwritemsg.len.did = DIDmsg_p2req_ramdl_write_len;
-	rwritemsg.data.did = DIDmsg_p2req_ramdl_write_data;
-	rwritemsg.resultcode.did = DIDmsg_p2req_ramdl_write_resultcode;
-	rwritemsg.addr.status = P80211ENUM_msgitem_status_data_ok;
-	rwritemsg.len.status = P80211ENUM_msgitem_status_data_ok;
-	rwritemsg.data.status = P80211ENUM_msgitem_status_data_ok;
-	rwritemsg.resultcode.status = P80211ENUM_msgitem_status_no_value;
-	rwritemsg.addr.len = sizeof(u32);
-	rwritemsg.len.len = sizeof(u32);
-	rwritemsg.data.len = WRITESIZE_MAX;
-	rwritemsg.resultcode.len = sizeof(u32);
+	memset(rstmsg, 0, sizeof(*rstmsg));
+	strcpy(rstmsg->devname, wlandev->name);
+	rstmsg->msgcode = DIDmsg_p2req_ramdl_state;
+	rstmsg->msglen = sizeof(*rstmsg);
+	rstmsg->enable.did = DIDmsg_p2req_ramdl_state_enable;
+	rstmsg->exeaddr.did = DIDmsg_p2req_ramdl_state_exeaddr;
+	rstmsg->resultcode.did = DIDmsg_p2req_ramdl_state_resultcode;
+	rstmsg->enable.status = P80211ENUM_msgitem_status_data_ok;
+	rstmsg->exeaddr.status = P80211ENUM_msgitem_status_data_ok;
+	rstmsg->resultcode.status = P80211ENUM_msgitem_status_no_value;
+	rstmsg->enable.len = sizeof(u32);
+	rstmsg->exeaddr.len = sizeof(u32);
+	rstmsg->resultcode.len = sizeof(u32);
+
+	memset(rwrmsg, 0, sizeof(*rwrmsg));
+	strcpy(rwrmsg->devname, wlandev->name);
+	rwrmsg->msgcode = DIDmsg_p2req_ramdl_write;
+	rwrmsg->msglen = sizeof(*rwrmsg);
+	rwrmsg->addr.did = DIDmsg_p2req_ramdl_write_addr;
+	rwrmsg->len.did = DIDmsg_p2req_ramdl_write_len;
+	rwrmsg->data.did = DIDmsg_p2req_ramdl_write_data;
+	rwrmsg->resultcode.did = DIDmsg_p2req_ramdl_write_resultcode;
+	rwrmsg->addr.status = P80211ENUM_msgitem_status_data_ok;
+	rwrmsg->len.status = P80211ENUM_msgitem_status_data_ok;
+	rwrmsg->data.status = P80211ENUM_msgitem_status_data_ok;
+	rwrmsg->resultcode.status = P80211ENUM_msgitem_status_no_value;
+	rwrmsg->addr.len = sizeof(u32);
+	rwrmsg->len.len = sizeof(u32);
+	rwrmsg->data.len = WRITESIZE_MAX;
+	rwrmsg->resultcode.len = sizeof(u32);
 
 	/* Send xxx_state(enable) */
 	pr_debug("Sending dl_state(enable) message.\n");
-	rstatemsg.enable.data = P80211ENUM_truth_true;
-	rstatemsg.exeaddr.data = startaddr;
+	rstmsg->enable.data = P80211ENUM_truth_true;
+	rstmsg->exeaddr.data = startaddr;
 
-	msgp = (struct p80211msg *) &rstatemsg;
-	result = prism2mgmt_ramdl_state(wlandev, msgp);
+	result = prism2mgmt_ramdl_state(wlandev, rstmsg);
 	if (result) {
 		printk(KERN_ERR
 		       "writeimage state enable failed w/ result=%d, "
 		       "aborting download\n", result);
-		return result;
+		goto free_result;
 	}
-	resultcode = rstatemsg.resultcode.data;
+	resultcode = rstmsg->resultcode.data;
 	if (resultcode != P80211ENUM_resultcode_success) {
 		printk(KERN_ERR
 		       "writeimage()->xxxdl_state msg indicates failure, "
 		       "w/ resultcode=%d, aborting download.\n", resultcode);
-		return 1;
+		result = 1;
+		goto free_result;
 	}
 
 	/* Now, loop through the data chunks and send WRITESIZE_MAX data */
@@ -1061,9 +1071,9 @@ int writeimage(wlandevice_t *wlandev, struct imgchunk *fchunk,
 			curroff = j * WRITESIZE_MAX;
 			currdaddr = fchunk[i].addr + curroff;
 			/* Setup the message */
-			rwritemsg.addr.data = currdaddr;
-			rwritemsg.len.data = currlen;
-			memcpy(rwritemsg.data.data,
+			rwrmsg->addr.data = currdaddr;
+			rwrmsg->len.data = currlen;
+			memcpy(rwrmsg->data.data,
 			       fchunk[i].data + curroff, currlen);
 
 			/* Send flashdl_write(pda) */
@@ -1071,23 +1081,23 @@ int writeimage(wlandevice_t *wlandev, struct imgchunk *fchunk,
 			    ("Sending xxxdl_write message addr=%06x len=%d.\n",
 			     currdaddr, currlen);
 
-			msgp = (struct p80211msg *) &rwritemsg;
-			result = prism2mgmt_ramdl_write(wlandev, msgp);
+			result = prism2mgmt_ramdl_write(wlandev, rwrmsg);
 
 			/* Check the results */
 			if (result) {
 				printk(KERN_ERR
 				       "writeimage chunk write failed w/ result=%d, "
 				       "aborting download\n", result);
-				return result;
+				goto free_result;
 			}
-			resultcode = rstatemsg.resultcode.data;
+			resultcode = rstmsg->resultcode.data;
 			if (resultcode != P80211ENUM_resultcode_success) {
 				printk(KERN_ERR
 				       "writeimage()->xxxdl_write msg indicates failure, "
 				       "w/ resultcode=%d, aborting download.\n",
 				       resultcode);
-				return 1;
+				result = 1;
+				goto free_result;
 			}
 
 		}
@@ -1095,24 +1105,28 @@ int writeimage(wlandevice_t *wlandev, struct imgchunk *fchunk,
 
 	/* Send xxx_state(disable) */
 	pr_debug("Sending dl_state(disable) message.\n");
-	rstatemsg.enable.data = P80211ENUM_truth_false;
-	rstatemsg.exeaddr.data = 0;
+	rstmsg->enable.data = P80211ENUM_truth_false;
+	rstmsg->exeaddr.data = 0;
 
-	msgp = (struct p80211msg *) &rstatemsg;
-	result = prism2mgmt_ramdl_state(wlandev, msgp);
+	result = prism2mgmt_ramdl_state(wlandev, rstmsg);
 	if (result) {
 		printk(KERN_ERR
 		       "writeimage state disable failed w/ result=%d, "
 		       "aborting download\n", result);
-		return result;
+		goto free_result;
 	}
-	resultcode = rstatemsg.resultcode.data;
+	resultcode = rstmsg->resultcode.data;
 	if (resultcode != P80211ENUM_resultcode_success) {
 		printk(KERN_ERR
 		       "writeimage()->xxxdl_state msg indicates failure, "
 		       "w/ resultcode=%d, aborting download.\n", resultcode);
-		return 1;
+		result = 1;
+		goto free_result;
 	}
+
+free_result:
+	kfree(rstmsg);
+	kfree(rwrmsg);
 	return result;
 }
 

commit cf66823dd224294f40ad6ddced70e80bae940741
Author: Devendra Naga <devendra.aaru@gmail.com>
Date:   Wed Jun 6 01:12:06 2012 +0530

    staging/wlan-ng: prsim2fw.c coding style cleanup
    
    this patch fixes the coding style problems found by using checkpatch.pl
    
    drivers/staging/wlan-ng/prism2fw.c:175: ERROR: "foo * bar" should be "foo *bar"
    drivers/staging/wlan-ng/prism2fw.c:210: WARNING: line over 80 characters
    drivers/staging/wlan-ng/prism2fw.c:596: WARNING: line over 80 characters
    drivers/staging/wlan-ng/prism2fw.c:658: ERROR: "foo * bar" should be "foo *bar"
    
    Signed-off-by: Devendra Naga <devendra.aaru@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/prism2fw.c b/drivers/staging/wlan-ng/prism2fw.c
index 3c40096f0c05..f13cdc9ab412 100644
--- a/drivers/staging/wlan-ng/prism2fw.c
+++ b/drivers/staging/wlan-ng/prism2fw.c
@@ -172,7 +172,7 @@ static int read_cardpda(struct pda *pda, wlandevice_t *wlandev);
 static int mkpdrlist(struct pda *pda);
 
 static int plugimage(struct imgchunk *fchunk, unsigned int nfchunks,
-	      struct s3plugrec *s3plug, unsigned int ns3plug, struct pda * pda);
+	      struct s3plugrec *s3plug, unsigned int ns3plug, struct pda *pda);
 
 static int crcimage(struct imgchunk *fchunk, unsigned int nfchunks,
 	     struct s3crcrec *s3crc, unsigned int ns3crc);
@@ -207,7 +207,8 @@ int prism2_fwtry(struct usb_device *udev, wlandevice_t *wlandev)
 
 	printk(KERN_INFO "prism2_usb: Checking for firmware %s\n",
 	       PRISM2_USB_FWFILE);
-	if (request_ihex_firmware(&fw_entry, PRISM2_USB_FWFILE, &udev->dev) != 0) {
+	if (request_ihex_firmware(&fw_entry,
+				  PRISM2_USB_FWFILE, &udev->dev) != 0) {
 		printk(KERN_INFO
 		       "prism2_usb: Firmware not available, but not essential\n");
 		printk(KERN_INFO
@@ -593,7 +594,8 @@ int mkpdrlist(struct pda *pda)
 	       le16_to_cpu(pda16[curroff + 1]) != HFA384x_PDR_END_OF_PDA) {
 		pda->rec[pda->nrec] = (hfa384x_pdrec_t *) &(pda16[curroff]);
 
-		if (le16_to_cpu(pda->rec[pda->nrec]->code) == HFA384x_PDR_NICID) {
+		if (le16_to_cpu(pda->rec[pda->nrec]->code) ==
+		    HFA384x_PDR_NICID) {
 			memcpy(&nicid, &pda->rec[pda->nrec]->data.nicid,
 			       sizeof(nicid));
 			nicid.id = le16_to_cpu(nicid.id);
@@ -655,7 +657,7 @@ int mkpdrlist(struct pda *pda)
 *	~0	failure
 ----------------------------------------------------------------*/
 int plugimage(struct imgchunk *fchunk, unsigned int nfchunks,
-	      struct s3plugrec *s3plug, unsigned int ns3plug, struct pda * pda)
+	      struct s3plugrec *s3plug, unsigned int ns3plug, struct pda *pda)
 {
 	int result = 0;
 	int i;			/* plug index */

commit 23567c75286f63f77e5ec6bab7f46e0161d75356
Author: Joseph Salisbury <salisbury.joseph@googlemail.com>
Date:   Sun Jun 5 17:28:12 2011 +0100

    Staging: wlan-ng: fix brace coding style issue in prism2fw.c
    
    This is a patch to the prism2fw.c file that fixes up a brace
    warning found by the checkpatch.pl tool.
    
    Signed-off-by: Joseph Salisbury <salisbury.joseph@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/wlan-ng/prism2fw.c b/drivers/staging/wlan-ng/prism2fw.c
index 729d03d28d75..3c40096f0c05 100644
--- a/drivers/staging/wlan-ng/prism2fw.c
+++ b/drivers/staging/wlan-ng/prism2fw.c
@@ -442,9 +442,9 @@ int crcimage(struct imgchunk *fchunk, unsigned int nfchunks,
 void free_chunks(struct imgchunk *fchunk, unsigned int *nfchunks)
 {
 	int i;
-	for (i = 0; i < *nfchunks; i++) {
+	for (i = 0; i < *nfchunks; i++)
 		kfree(fchunk[i].data);
-	}
+
 	*nfchunks = 0;
 	memset(fchunk, 0, sizeof(*fchunk));
 

commit a6f9c48fdd566e09d437e104c5b5963133db1be4
Author: Ilia Mirkin <imirkin@alum.mit.edu>
Date:   Sun Mar 13 00:29:17 2011 -0500

    staging: wlan-ng: Remove NULL check before kfree
    
    This patch was generated by the following semantic patch:
    // <smpl>
    @@ expression E; @@
    - if (E != NULL) { kfree(E); }
    + kfree(E);
    
    @@ expression E; @@
    - if (E != NULL) { kfree(E); E = NULL; }
    + kfree(E);
    + E = NULL;
    // </smpl>
    
    Signed-off-by: Ilia Mirkin <imirkin@alum.mit.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/wlan-ng/prism2fw.c b/drivers/staging/wlan-ng/prism2fw.c
index fd5ddb29436c..729d03d28d75 100644
--- a/drivers/staging/wlan-ng/prism2fw.c
+++ b/drivers/staging/wlan-ng/prism2fw.c
@@ -443,8 +443,7 @@ void free_chunks(struct imgchunk *fchunk, unsigned int *nfchunks)
 {
 	int i;
 	for (i = 0; i < *nfchunks; i++) {
-		if (fchunk[i].data != NULL)
-			kfree(fchunk[i].data);
+		kfree(fchunk[i].data);
 	}
 	*nfchunks = 0;
 	memset(fchunk, 0, sizeof(*fchunk));

commit 3d049431e08a847a222e20f406332529751b4365
Author: Edgardo Hames <ehames@gmail.com>
Date:   Mon Aug 2 17:17:17 2010 -0300

    Staging: wlan-ng: remove typedef in p80211hdr.h
    
    This patch removes the only typedef in p80211hdr.h.
    
    Signed-off-by: Edgardo Hames <ehames@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/wlan-ng/prism2fw.c b/drivers/staging/wlan-ng/prism2fw.c
index 5b97c4afa2ac..fd5ddb29436c 100644
--- a/drivers/staging/wlan-ng/prism2fw.c
+++ b/drivers/staging/wlan-ng/prism2fw.c
@@ -983,7 +983,7 @@ int writeimage(wlandevice_t *wlandev, struct imgchunk *fchunk,
 	int result = 0;
 	struct p80211msg_p2req_ramdl_state rstatemsg;
 	struct p80211msg_p2req_ramdl_write rwritemsg;
-	p80211msg_t *msgp;
+	struct p80211msg *msgp;
 	u32 resultcode;
 	int i;
 	int j;
@@ -1029,7 +1029,7 @@ int writeimage(wlandevice_t *wlandev, struct imgchunk *fchunk,
 	rstatemsg.enable.data = P80211ENUM_truth_true;
 	rstatemsg.exeaddr.data = startaddr;
 
-	msgp = (p80211msg_t *) &rstatemsg;
+	msgp = (struct p80211msg *) &rstatemsg;
 	result = prism2mgmt_ramdl_state(wlandev, msgp);
 	if (result) {
 		printk(KERN_ERR
@@ -1070,7 +1070,7 @@ int writeimage(wlandevice_t *wlandev, struct imgchunk *fchunk,
 			    ("Sending xxxdl_write message addr=%06x len=%d.\n",
 			     currdaddr, currlen);
 
-			msgp = (p80211msg_t *) &rwritemsg;
+			msgp = (struct p80211msg *) &rwritemsg;
 			result = prism2mgmt_ramdl_write(wlandev, msgp);
 
 			/* Check the results */
@@ -1097,7 +1097,7 @@ int writeimage(wlandevice_t *wlandev, struct imgchunk *fchunk,
 	rstatemsg.enable.data = P80211ENUM_truth_false;
 	rstatemsg.exeaddr.data = 0;
 
-	msgp = (p80211msg_t *) &rstatemsg;
+	msgp = (struct p80211msg *) &rstatemsg;
 	result = prism2mgmt_ramdl_state(wlandev, msgp);
 	if (result) {
 		printk(KERN_ERR

commit b6bb56e6aa28085550179335247c649752ff2994
Author: Edgardo Hames <ehames@gmail.com>
Date:   Mon Aug 2 16:20:39 2010 -0300

    Staging: wlan-ng: fix checkpatch issues in headers.
    
    This patch fix errors and warnings reported by checkpatch
    in p80211meta.h and p80211metstruct.h.
    
    Signed-off-by: Edgardo Hames <ehames@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/wlan-ng/prism2fw.c b/drivers/staging/wlan-ng/prism2fw.c
index f8fe17f4e188..5b97c4afa2ac 100644
--- a/drivers/staging/wlan-ng/prism2fw.c
+++ b/drivers/staging/wlan-ng/prism2fw.c
@@ -239,7 +239,7 @@ int prism2_fwtry(struct usb_device *udev, wlandevice_t *wlandev)
 int prism2_fwapply(const struct ihex_binrec *rfptr, wlandevice_t *wlandev)
 {
 	signed int result = 0;
-	p80211msg_dot11req_mibget_t getmsg;
+	struct p80211msg_dot11req_mibget getmsg;
 	p80211itemd_t *item;
 	u32 *data;
 
@@ -766,7 +766,7 @@ int plugimage(struct imgchunk *fchunk, unsigned int nfchunks,
 int read_cardpda(struct pda *pda, wlandevice_t *wlandev)
 {
 	int result = 0;
-	p80211msg_p2req_readpda_t msg;
+	struct p80211msg_p2req_readpda msg;
 
 	/* set up the msg */
 	msg.msgcode = DIDmsg_p2req_readpda;
@@ -981,8 +981,8 @@ int writeimage(wlandevice_t *wlandev, struct imgchunk *fchunk,
 	       unsigned int nfchunks)
 {
 	int result = 0;
-	p80211msg_p2req_ramdl_state_t rstatemsg;
-	p80211msg_p2req_ramdl_write_t rwritemsg;
+	struct p80211msg_p2req_ramdl_state rstatemsg;
+	struct p80211msg_p2req_ramdl_write rwritemsg;
 	p80211msg_t *msgp;
 	u32 resultcode;
 	int i;

commit e02644184c0e925206f3cf19fd681065a507f05c
Author: Edgardo Hames <ehames@gmail.com>
Date:   Wed Jul 21 22:31:56 2010 -0300

    Staging: wlan-ng: removed typedef from prism2fw.c
    
    Removed multiple typedef and fixed long lines.
    
    Signed-off-by: Edgardo Hames <ehames@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/wlan-ng/prism2fw.c b/drivers/staging/wlan-ng/prism2fw.c
index d20c8797bcc7..f8fe17f4e188 100644
--- a/drivers/staging/wlan-ng/prism2fw.c
+++ b/drivers/staging/wlan-ng/prism2fw.c
@@ -73,26 +73,26 @@ MODULE_FIRMWARE(PRISM2_USB_FWFILE);
 /*================================================================*/
 /* Local Types */
 
-typedef struct s3datarec {
+struct s3datarec {
 	u32 len;
 	u32 addr;
 	u8 checksum;
 	u8 *data;
-} s3datarec_t;
+};
 
-typedef struct s3plugrec {
+struct s3plugrec {
 	u32 itemcode;
 	u32 addr;
 	u32 len;
-} s3plugrec_t;
+};
 
-typedef struct s3crcrec {
+struct s3crcrec {
 	u32 addr;
 	u32 len;
 	unsigned int dowrite;
-} s3crcrec_t;
+};
 
-typedef struct s3inforec {
+struct s3inforec {
 	u16 len;
 	u16 type;
 	union {
@@ -101,20 +101,20 @@ typedef struct s3inforec {
 		u16 buildseq;
 		hfa384x_compident_t platform;
 	} info;
-} s3inforec_t;
+};
 
-typedef struct pda {
+struct pda {
 	u8 buf[HFA384x_PDA_LEN_MAX];
 	hfa384x_pdrec_t *rec[HFA384x_PDA_RECS_MAX];
 	unsigned int nrec;
-} pda_t;
+};
 
-typedef struct imgchunk {
+struct imgchunk {
 	u32 addr;	/* start address */
 	u32 len;	/* in bytes */
 	u16 crc;	/* CRC value (if it falls at a chunk boundary) */
 	u8 *data;
-} imgchunk_t;
+};
 
 /*================================================================*/
 /* Local Static Definitions */
@@ -124,26 +124,26 @@ typedef struct imgchunk {
 
 /* Data records */
 unsigned int ns3data;
-s3datarec_t s3data[S3DATA_MAX];
+struct s3datarec s3data[S3DATA_MAX];
 
 /* Plug records */
 unsigned int ns3plug;
-s3plugrec_t s3plug[S3PLUG_MAX];
+struct s3plugrec s3plug[S3PLUG_MAX];
 
 /* CRC records */
 unsigned int ns3crc;
-s3crcrec_t s3crc[S3CRC_MAX];
+struct s3crcrec s3crc[S3CRC_MAX];
 
 /* Info records */
 unsigned int ns3info;
-s3inforec_t s3info[S3INFO_MAX];
+struct s3inforec s3info[S3INFO_MAX];
 
 /* S7 record (there _better_ be only one) */
 u32 startaddr;
 
 /* Load image chunks */
 unsigned int nfchunks;
-imgchunk_t fchunk[CHUNKS_MAX];
+struct imgchunk fchunk[CHUNKS_MAX];
 
 /* Note that for the following pdrec_t arrays, the len and code */
 /*   fields are stored in HOST byte order. The mkpdrlist() function */
@@ -151,7 +151,7 @@ imgchunk_t fchunk[CHUNKS_MAX];
 /*----------------------------------------------------------------*/
 /* PDA, built from [card|newfile]+[addfile1+addfile2...] */
 
-pda_t pda;
+struct pda pda;
 hfa384x_compident_t nicid;
 hfa384x_caplevel_t rfid;
 hfa384x_caplevel_t macid;
@@ -165,21 +165,21 @@ wlandevice_t *wlandev);
 
 static int read_fwfile(const struct ihex_binrec *rfptr);
 
-static int mkimage(imgchunk_t *clist, unsigned int *ccnt);
+static int mkimage(struct imgchunk *clist, unsigned int *ccnt);
 
-static int read_cardpda(pda_t *pda, wlandevice_t *wlandev);
+static int read_cardpda(struct pda *pda, wlandevice_t *wlandev);
 
-static int mkpdrlist(pda_t *pda);
+static int mkpdrlist(struct pda *pda);
 
-static int plugimage(imgchunk_t *fchunk, unsigned int nfchunks,
-	      s3plugrec_t *s3plug, unsigned int ns3plug, pda_t * pda);
+static int plugimage(struct imgchunk *fchunk, unsigned int nfchunks,
+	      struct s3plugrec *s3plug, unsigned int ns3plug, struct pda * pda);
 
-static int crcimage(imgchunk_t *fchunk, unsigned int nfchunks,
-	     s3crcrec_t *s3crc, unsigned int ns3crc);
+static int crcimage(struct imgchunk *fchunk, unsigned int nfchunks,
+	     struct s3crcrec *s3crc, unsigned int ns3crc);
 
-static int writeimage(wlandevice_t *wlandev, imgchunk_t *fchunk,
+static int writeimage(wlandevice_t *wlandev, struct imgchunk *fchunk,
 	       unsigned int nfchunks);
-static void free_chunks(imgchunk_t *fchunk, unsigned int *nfchunks);
+static void free_chunks(struct imgchunk *fchunk, unsigned int *nfchunks);
 
 static void free_srecs(void);
 
@@ -375,8 +375,8 @@ int prism2_fwapply(const struct ihex_binrec *rfptr, wlandevice_t *wlandev)
 *	0	success
 *	~0	failure
 ----------------------------------------------------------------*/
-int crcimage(imgchunk_t *fchunk, unsigned int nfchunks, s3crcrec_t *s3crc,
-	     unsigned int ns3crc)
+int crcimage(struct imgchunk *fchunk, unsigned int nfchunks,
+	     struct s3crcrec *s3crc, unsigned int ns3crc)
 {
 	int result = 0;
 	int i;
@@ -397,15 +397,14 @@ int crcimage(imgchunk_t *fchunk, unsigned int nfchunks, s3crcrec_t *s3crc,
 		for (c = 0; c < nfchunks; c++) {
 			cstart = fchunk[c].addr;
 			cend = fchunk[c].addr + fchunk[c].len;
-			/*  the line below does an address & len match search */
-			/*  unfortunately, I've found that the len fields of */
-			/*  some crc records don't match with the length of */
-			/*  the actual data, so we're not checking right */
-			/*  now */
-			/* if ( crcstart-2 >= cstart && crcend <= cend ) break; */
+			/* the line below does an address & len match search */
+			/* unfortunately, I've found that the len fields of */
+			/* some crc records don't match with the length of */
+			/* the actual data, so we're not checking right now */
+			/* if (crcstart-2 >= cstart && crcend <= cend) break; */
 
 			/* note the -2 below, it's to make sure the chunk has */
-			/*   space for the CRC value */
+			/* space for the CRC value */
 			if (crcstart - 2 >= cstart && crcstart < cend)
 				break;
 		}
@@ -440,7 +439,7 @@ int crcimage(imgchunk_t *fchunk, unsigned int nfchunks, s3crcrec_t *s3crc,
 * Returns:
 *	nothing
 ----------------------------------------------------------------*/
-void free_chunks(imgchunk_t *fchunk, unsigned int *nfchunks)
+void free_chunks(struct imgchunk *fchunk, unsigned int *nfchunks)
 {
 	int i;
 	for (i = 0; i < *nfchunks; i++) {
@@ -490,7 +489,7 @@ void free_srecs(void)
 *	0	- success
 *	~0	- failure (probably an errno)
 ----------------------------------------------------------------*/
-int mkimage(imgchunk_t *clist, unsigned int *ccnt)
+int mkimage(struct imgchunk *clist, unsigned int *ccnt)
 {
 	int result = 0;
 	int i;
@@ -583,7 +582,7 @@ int mkimage(imgchunk_t *clist, unsigned int *ccnt)
 *	0	- success
 *	~0	- failure (probably an errno)
 ----------------------------------------------------------------*/
-int mkpdrlist(pda_t *pda)
+int mkpdrlist(struct pda *pda)
 {
 	int result = 0;
 	u16 *pda16 = (u16 *) pda->buf;
@@ -656,8 +655,8 @@ int mkpdrlist(pda_t *pda)
 *	0	success
 *	~0	failure
 ----------------------------------------------------------------*/
-int plugimage(imgchunk_t *fchunk, unsigned int nfchunks,
-	      s3plugrec_t *s3plug, unsigned int ns3plug, pda_t * pda)
+int plugimage(struct imgchunk *fchunk, unsigned int nfchunks,
+	      struct s3plugrec *s3plug, unsigned int ns3plug, struct pda * pda)
 {
 	int result = 0;
 	int i;			/* plug index */
@@ -675,7 +674,7 @@ int plugimage(imgchunk_t *fchunk, unsigned int nfchunks,
 		pstart = s3plug[i].addr;
 		pend = s3plug[i].addr + s3plug[i].len;
 		/* find the matching PDR (or filename) */
-		if (s3plug[i].itemcode != 0xffffffffUL) {	/* not filename */
+		if (s3plug[i].itemcode != 0xffffffffUL) { /* not filename */
 			for (j = 0; j < pda->nrec; j++) {
 				if (s3plug[i].itemcode ==
 				    le16_to_cpu(pda->rec[j]->code))
@@ -684,7 +683,7 @@ int plugimage(imgchunk_t *fchunk, unsigned int nfchunks,
 		} else {
 			j = -1;
 		}
-		if (j >= pda->nrec && j != -1) {	/*  if no matching PDR, fail */
+		if (j >= pda->nrec && j != -1) { /*  if no matching PDR, fail */
 			printk(KERN_WARNING
 			       "warning: Failed to find PDR for "
 			       "plugrec 0x%04x.\n", s3plug[i].itemcode);
@@ -764,7 +763,7 @@ int plugimage(imgchunk_t *fchunk, unsigned int nfchunks,
 *	0	- success
 *	~0	- failure (probably an errno)
 ----------------------------------------------------------------*/
-int read_cardpda(pda_t *pda, wlandevice_t *wlandev)
+int read_cardpda(struct pda *pda, wlandevice_t *wlandev)
 {
 	int result = 0;
 	p80211msg_p2req_readpda_t msg;
@@ -839,7 +838,7 @@ int read_cardpda(pda_t *pda, wlandevice_t *wlandev)
 *                ssssttttdd..dd
 *                s - Size in words (little endian)
 *                t - Info type (little endian), see #defines and
-*                    s3inforec_t for details about types.
+*                    struct s3inforec for details about types.
 *                d - (s - 1) little endian words giving the contents of
 *                    the given info type.
 *
@@ -978,7 +977,7 @@ int read_fwfile(const struct ihex_binrec *record)
 *	0	success
 *	~0	failure
 ----------------------------------------------------------------*/
-int writeimage(wlandevice_t *wlandev, imgchunk_t *fchunk,
+int writeimage(wlandevice_t *wlandev, struct imgchunk *fchunk,
 	       unsigned int nfchunks)
 {
 	int result = 0;
@@ -1052,11 +1051,12 @@ int writeimage(wlandevice_t *wlandev, imgchunk_t *fchunk,
 		nwrites += (fchunk[i].len % WRITESIZE_MAX) ? 1 : 0;
 		curroff = 0;
 		for (j = 0; j < nwrites; j++) {
-			currlen =
-			    (fchunk[i].len - (WRITESIZE_MAX * j)) >
-			    WRITESIZE_MAX ? WRITESIZE_MAX : (fchunk[i].len -
-							     (WRITESIZE_MAX *
-							      j));
+			/* TODO Move this to a separate function */
+			int lenleft = fchunk[i].len - (WRITESIZE_MAX * j);
+			if (fchunk[i].len > WRITESIZE_MAX)
+				currlen = WRITESIZE_MAX;
+			else
+				currlen = lenleft;
 			curroff = j * WRITESIZE_MAX;
 			currdaddr = fchunk[i].addr + curroff;
 			/* Setup the message */

commit 7a6cb0d5497418599d2125b670926b75e673861c
Author: Julia Lawall <julia@diku.dk>
Date:   Thu May 13 22:00:05 2010 +0200

    Staging: Use kcalloc or kzalloc
    
    Use kcalloc or kzalloc rather than the combination of kmalloc and memset.
    
    The semantic patch that makes this change is as follows:
    (http://coccinelle.lip6.fr/)
    
    // <smpl>
    @@
    expression x,y,flags;
    statement S;
    type T;
    @@
    
    x =
    -   kmalloc
    +   kcalloc
               (
    -           y * sizeof(T),
    +           y, sizeof(T),
                    flags);
     if (x == NULL) S
    -memset(x, 0, y * sizeof(T));
    
    @@
    expression x,size,flags;
    statement S;
    @@
    
    -x = kmalloc(size,flags);
    +x = kzalloc(size,flags);
     if (x == NULL) S
    -memset(x, 0, size);
    // </smpl>
    
    Signed-off-by: Julia Lawall <julia@diku.dk>

diff --git a/drivers/staging/wlan-ng/prism2fw.c b/drivers/staging/wlan-ng/prism2fw.c
index fc2d8f40edd4..d20c8797bcc7 100644
--- a/drivers/staging/wlan-ng/prism2fw.c
+++ b/drivers/staging/wlan-ng/prism2fw.c
@@ -536,13 +536,12 @@ int mkimage(imgchunk_t *clist, unsigned int *ccnt)
 
 	/* Allocate buffer space for chunks */
 	for (i = 0; i < *ccnt; i++) {
-		clist[i].data = kmalloc(clist[i].len, GFP_KERNEL);
+		clist[i].data = kzalloc(clist[i].len, GFP_KERNEL);
 		if (clist[i].data == NULL) {
 			printk(KERN_ERR
 			       "failed to allocate image space, exitting.\n");
 			return 1;
 		}
-		memset(clist[i].data, 0, clist[i].len);
 		pr_debug("chunk[%d]: addr=0x%06x len=%d\n",
 			 i, clist[i].addr, clist[i].len);
 	}

commit a05d08c40c0775e4691cffcfbfceeb4270987208
Author: Zachary Richey <zr.public@gmail.com>
Date:   Tue May 11 14:16:41 2010 -0400

    Staging: wlan-ng: Fixed non static functions in prism2fw.c
    
    Fixed non static functions in prism2fw.c
    
    Signed-off-by: Zachary Richey <zr.public@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/wlan-ng/prism2fw.c b/drivers/staging/wlan-ng/prism2fw.c
index d383ea85c9bc..fc2d8f40edd4 100644
--- a/drivers/staging/wlan-ng/prism2fw.c
+++ b/drivers/staging/wlan-ng/prism2fw.c
@@ -160,21 +160,30 @@ hfa384x_caplevel_t priid;
 /*================================================================*/
 /* Local Function Declarations */
 
-int prism2_fwapply(const struct ihex_binrec *rfptr, wlandevice_t *wlandev);
-int read_fwfile(const struct ihex_binrec *rfptr);
-int mkimage(imgchunk_t *clist, unsigned int *ccnt);
-int read_cardpda(pda_t *pda, wlandevice_t *wlandev);
-int mkpdrlist(pda_t *pda);
-int plugimage(imgchunk_t *fchunk, unsigned int nfchunks,
+static int prism2_fwapply(const struct ihex_binrec *rfptr,
+wlandevice_t *wlandev);
+
+static int read_fwfile(const struct ihex_binrec *rfptr);
+
+static int mkimage(imgchunk_t *clist, unsigned int *ccnt);
+
+static int read_cardpda(pda_t *pda, wlandevice_t *wlandev);
+
+static int mkpdrlist(pda_t *pda);
+
+static int plugimage(imgchunk_t *fchunk, unsigned int nfchunks,
 	      s3plugrec_t *s3plug, unsigned int ns3plug, pda_t * pda);
-int crcimage(imgchunk_t *fchunk, unsigned int nfchunks,
+
+static int crcimage(imgchunk_t *fchunk, unsigned int nfchunks,
 	     s3crcrec_t *s3crc, unsigned int ns3crc);
-int writeimage(wlandevice_t *wlandev, imgchunk_t *fchunk,
+
+static int writeimage(wlandevice_t *wlandev, imgchunk_t *fchunk,
 	       unsigned int nfchunks);
-void free_chunks(imgchunk_t *fchunk, unsigned int *nfchunks);
-void free_srecs(void);
+static void free_chunks(imgchunk_t *fchunk, unsigned int *nfchunks);
+
+static void free_srecs(void);
 
-int validate_identity(void);
+static int validate_identity(void);
 
 /*================================================================*/
 /* Function Definitions */
@@ -255,7 +264,7 @@ int prism2_fwapply(const struct ihex_binrec *rfptr, wlandevice_t *wlandev)
 	/* clear the pda and add an initial END record */
 	memset(&pda, 0, sizeof(pda));
 	pda.rec[0] = (hfa384x_pdrec_t *) pda.buf;
-	pda.rec[0]->len = cpu_to_le16(2);	/* len in words *//* len in words */
+	pda.rec[0]->len = cpu_to_le16(2);	/* len in words */
 	pda.rec[0]->code = cpu_to_le16(HFA384x_PDR_END_OF_PDA);
 	pda.nrec = 1;
 

commit 5a0e3ad6af8660be21ca98a971cd00f331318c05
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Mar 24 17:04:11 2010 +0900

    include cleanup: Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h
    
    percpu.h is included by sched.h and module.h and thus ends up being
    included when building most .c files.  percpu.h includes slab.h which
    in turn includes gfp.h making everything defined by the two files
    universally available and complicating inclusion dependencies.
    
    percpu.h -> slab.h dependency is about to be removed.  Prepare for
    this change by updating users of gfp and slab facilities include those
    headers directly instead of assuming availability.  As this conversion
    needs to touch large number of source files, the following script is
    used as the basis of conversion.
    
      http://userweb.kernel.org/~tj/misc/slabh-sweep.py
    
    The script does the followings.
    
    * Scan files for gfp and slab usages and update includes such that
      only the necessary includes are there.  ie. if only gfp is used,
      gfp.h, if slab is used, slab.h.
    
    * When the script inserts a new include, it looks at the include
      blocks and try to put the new include such that its order conforms
      to its surrounding.  It's put in the include block which contains
      core kernel includes, in the same order that the rest are ordered -
      alphabetical, Christmas tree, rev-Xmas-tree or at the end if there
      doesn't seem to be any matching order.
    
    * If the script can't find a place to put a new include (mostly
      because the file doesn't have fitting include block), it prints out
      an error message indicating which .h file needs to be added to the
      file.
    
    The conversion was done in the following steps.
    
    1. The initial automatic conversion of all .c files updated slightly
       over 4000 files, deleting around 700 includes and adding ~480 gfp.h
       and ~3000 slab.h inclusions.  The script emitted errors for ~400
       files.
    
    2. Each error was manually checked.  Some didn't need the inclusion,
       some needed manual addition while adding it to implementation .h or
       embedding .c file was more appropriate for others.  This step added
       inclusions to around 150 files.
    
    3. The script was run again and the output was compared to the edits
       from #2 to make sure no file was left behind.
    
    4. Several build tests were done and a couple of problems were fixed.
       e.g. lib/decompress_*.c used malloc/free() wrappers around slab
       APIs requiring slab.h to be added manually.
    
    5. The script was run on all .h files but without automatically
       editing them as sprinkling gfp.h and slab.h inclusions around .h
       files could easily lead to inclusion dependency hell.  Most gfp.h
       inclusion directives were ignored as stuff from gfp.h was usually
       wildly available and often used in preprocessor macros.  Each
       slab.h inclusion directive was examined and added manually as
       necessary.
    
    6. percpu.h was updated not to include slab.h.
    
    7. Build test were done on the following configurations and failures
       were fixed.  CONFIG_GCOV_KERNEL was turned off for all tests (as my
       distributed build env didn't work with gcov compiles) and a few
       more options had to be turned off depending on archs to make things
       build (like ipr on powerpc/64 which failed due to missing writeq).
    
       * x86 and x86_64 UP and SMP allmodconfig and a custom test config.
       * powerpc and powerpc64 SMP allmodconfig
       * sparc and sparc64 SMP allmodconfig
       * ia64 SMP allmodconfig
       * s390 SMP allmodconfig
       * alpha SMP allmodconfig
       * um on x86_64 SMP allmodconfig
    
    8. percpu.h modifications were reverted so that it could be applied as
       a separate patch and serve as bisection point.
    
    Given the fact that I had only a couple of failures from tests on step
    6, I'm fairly confident about the coverage of this conversion patch.
    If there is a breakage, it's likely to be something in one of the arch
    headers which should be easily discoverable easily on most builds of
    the specific arch.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Guess-its-ok-by: Christoph Lameter <cl@linux-foundation.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Lee Schermerhorn <Lee.Schermerhorn@hp.com>

diff --git a/drivers/staging/wlan-ng/prism2fw.c b/drivers/staging/wlan-ng/prism2fw.c
index 4be54cea6ad7..d383ea85c9bc 100644
--- a/drivers/staging/wlan-ng/prism2fw.c
+++ b/drivers/staging/wlan-ng/prism2fw.c
@@ -48,6 +48,7 @@
 /*================================================================*/
 /* System Includes */
 #include <linux/ihex.h>
+#include <linux/slab.h>
 
 /*================================================================*/
 /* Local Constants */

commit b02957d58a27525499ab10d272d3b44682a7ae50
Merge: 3a8954e8f22c b94c765ac31f
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Thu Mar 4 08:14:54 2010 -0800

    Staging: Merge two branches of coding style fixes together
    
    Turns out that multiple people sent pretty much the same patch
    for the same staging drivers.  Commit these in two different
    branches and merge them together to get a more complete coverage
    of the cleanup and properly credit everyone for the work that they
    did.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit ef1a0ed7f1793531e5fb3ee489cb1e2b627f76fd
Author: Andrew Elwell <andrew.elwell@gmail.com>
Date:   Thu Feb 18 23:56:12 2010 +0100

    Staging: wlan-ng - checkpatch.pl fixups
    
    Basic fixups in the staging/wlan-ng directory.
    (First kernel patch - thanks to FOSDEM talk)
    
    Signed-off-by: Andrew Elwell <Andrew.Elwell@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/wlan-ng/prism2fw.c b/drivers/staging/wlan-ng/prism2fw.c
index aaa70ed57710..343614561f4c 100644
--- a/drivers/staging/wlan-ng/prism2fw.c
+++ b/drivers/staging/wlan-ng/prism2fw.c
@@ -108,9 +108,9 @@ typedef struct pda {
 } pda_t;
 
 typedef struct imgchunk {
-	u32 addr;		/* start address */
-	u32 len;		/* in bytes */
-	u16 crc;		/* CRC value (if it falls at a chunk boundary) */
+	u32 addr;	/* start address */
+	u32 len;	/* in bytes */
+	u16 crc;	/* CRC value (if it falls at a chunk boundary) */
 	u8 *data;
 } imgchunk_t;
 
@@ -264,7 +264,7 @@ int prism2_fwapply(const struct ihex_binrec *rfptr, wlandevice_t *wlandev)
 	/* Build the PDA we're going to use. */
 	if (read_cardpda(&pda, wlandev)) {
 		printk(KERN_ERR "load_cardpda failed, exiting.\n");
-		return (1);
+		return 1;
 	}
 
 	/* read the card's PRI-SUP */
@@ -286,9 +286,8 @@ int prism2_fwapply(const struct ihex_binrec *rfptr, wlandevice_t *wlandev)
 
 	/* DIDmsg_dot11req_mibget */
 	prism2mgmt_mibset_mibget(wlandev, &getmsg);
-	if (getmsg.resultcode.data != P80211ENUM_resultcode_success) {
+	if (getmsg.resultcode.data != P80211ENUM_resultcode_success)
 		printk(KERN_ERR "Couldn't fetch PRI-SUP info\n");
-	}
 
 	/* Already in host order */
 	priid.role = *data++;
@@ -301,19 +300,19 @@ int prism2_fwapply(const struct ihex_binrec *rfptr, wlandevice_t *wlandev)
 	result = read_fwfile(rfptr);
 	if (result) {
 		printk(KERN_ERR "Failed to read the data exiting.\n");
-		return (1);
+		return 1;
 	}
 
 	result = validate_identity();
 
 	if (result) {
 		printk(KERN_ERR "Incompatible firmware image.\n");
-		return (1);
+		return 1;
 	}
 
 	if (startaddr == 0x00000000) {
 		printk(KERN_ERR "Can't RAM download a Flash image!\n");
-		return (1);
+		return 1;
 	}
 
 	/* Make the image chunks */
@@ -323,20 +322,20 @@ int prism2_fwapply(const struct ihex_binrec *rfptr, wlandevice_t *wlandev)
 	result = plugimage(fchunk, nfchunks, s3plug, ns3plug, &pda);
 	if (result) {
 		printk(KERN_ERR "Failed to plug data.\n");
-		return (1);
+		return 1;
 	}
 
 	/* Insert any CRCs */
 	if (crcimage(fchunk, nfchunks, s3crc, ns3crc)) {
 		printk(KERN_ERR "Failed to insert all CRCs\n");
-		return (1);
+		return 1;
 	}
 
 	/* Write the image */
 	result = writeimage(wlandev, fchunk, nfchunks);
 	if (result) {
 		printk(KERN_ERR "Failed to ramwrite image data.\n");
-		return (1);
+		return 1;
 	}
 
 	/* clear any allocated memory */
@@ -434,9 +433,8 @@ void free_chunks(imgchunk_t *fchunk, unsigned int *nfchunks)
 {
 	int i;
 	for (i = 0; i < *nfchunks; i++) {
-		if (fchunk[i].data != NULL) {
+		if (fchunk[i].data != NULL)
 			kfree(fchunk[i].data);
-		}
 	}
 	*nfchunks = 0;
 	memset(fchunk, 0, sizeof(*fchunk));
@@ -531,7 +529,7 @@ int mkimage(imgchunk_t *clist, unsigned int *ccnt)
 		if (clist[i].data == NULL) {
 			printk(KERN_ERR
 			       "failed to allocate image space, exitting.\n");
-			return (1);
+			return 1;
 		}
 		memset(clist[i].data, 0, clist[i].len);
 		pr_debug("chunk[%d]: addr=0x%06x len=%d\n",
@@ -545,15 +543,14 @@ int mkimage(imgchunk_t *clist, unsigned int *ccnt)
 		for (j = 0; j < *ccnt; j++) {
 			cstart = clist[j].addr;
 			cend = cstart + clist[j].len - 1;
-			if (s3start >= cstart && s3end <= cend) {
+			if (s3start >= cstart && s3end <= cend)
 				break;
-			}
 		}
 		if (((unsigned int)j) >= (*ccnt)) {
 			printk(KERN_ERR
 			       "s3rec(a=0x%06x,l=%d), no chunk match, exiting.\n",
 			       s3start, s3data[i].len);
-			return (1);
+			return 1;
 		}
 		coffset = s3start - cstart;
 		memcpy(clist[j].data + coffset, s3data[i].data, s3data[i].len);
@@ -586,7 +583,7 @@ int mkpdrlist(pda_t *pda)
 	curroff = 0;
 	while (curroff < (HFA384x_PDA_LEN_MAX / 2) &&
 	       le16_to_cpu(pda16[curroff + 1]) != HFA384x_PDR_END_OF_PDA) {
-		pda->rec[pda->nrec] = (hfa384x_pdrec_t *) & (pda16[curroff]);
+		pda->rec[pda->nrec] = (hfa384x_pdrec_t *) &(pda16[curroff]);
 
 		if (le16_to_cpu(pda->rec[pda->nrec]->code) == HFA384x_PDR_NICID) {
 			memcpy(&nicid, &pda->rec[pda->nrec]->data.nicid,
@@ -623,10 +620,10 @@ int mkpdrlist(pda_t *pda)
 		printk(KERN_ERR
 		       "no end record found or invalid lengths in "
 		       "PDR data, exiting. %x %d\n", curroff, pda->nrec);
-		return (1);
+		return 1;
 	}
 	if (le16_to_cpu(pda16[curroff + 1]) == HFA384x_PDR_END_OF_PDA) {
-		pda->rec[pda->nrec] = (hfa384x_pdrec_t *) & (pda16[curroff]);
+		pda->rec[pda->nrec] = (hfa384x_pdrec_t *) &(pda16[curroff]);
 		(pda->nrec)++;
 	}
 	return result;
@@ -869,7 +866,7 @@ int read_fwfile(const struct ihex_binrec *record)
 		ptr16 = (u16 *) record->data;
 
 		/* parse what was an S3 srec and put it in the right array */
-		switch(addr) {
+		switch (addr) {
 		case S3ADDR_START:
 			startaddr = *ptr32;
 			pr_debug("  S7 start addr, record=%d "
@@ -890,7 +887,7 @@ int read_fwfile(const struct ihex_binrec *record)
 				      s3plug[ns3plug].len);
 
 			ns3plug++;
-			if ( ns3plug == S3PLUG_MAX ) {
+			if (ns3plug == S3PLUG_MAX) {
 				printk(KERN_ERR "S3 plugrec limit reached - aborting\n");
 				return 1;
 			}
@@ -907,7 +904,7 @@ int read_fwfile(const struct ihex_binrec *record)
 				      s3crc[ns3crc].len,
 				      s3crc[ns3crc].dowrite);
 			ns3crc++;
-			if ( ns3crc == S3CRC_MAX ) {
+			if (ns3crc == S3CRC_MAX) {
 				printk(KERN_ERR "S3 crcrec limit reached - aborting\n");
 				return 1;
 			}
@@ -921,12 +918,12 @@ int read_fwfile(const struct ihex_binrec *record)
 				      rcnt,
 				      s3info[ns3info].len,
 				      s3info[ns3info].type);
-			if ( ((s3info[ns3info].len - 1) * sizeof(u16)) > sizeof(s3info[ns3info].info) ) {
+			if (((s3info[ns3info].len - 1) * sizeof(u16)) > sizeof(s3info[ns3info].info)) {
 				printk(KERN_ERR " S3 inforec length too long - aborting\n");
 				return 1;
 			}
 
-			tmpinfo = (u16*)&(s3info[ns3info].info.version);
+			tmpinfo = (u16 *)&(s3info[ns3info].info.version);
 			pr_debug("            info=");
 			for (i = 0; i < s3info[ns3info].len - 1; i++) {
 				tmpinfo[i] = *(ptr16 + 2 + i);
@@ -935,7 +932,7 @@ int read_fwfile(const struct ihex_binrec *record)
 			pr_debug("\n");
 
 			ns3info++;
-			if ( ns3info == S3INFO_MAX ) {
+			if (ns3info == S3INFO_MAX) {
 				printk(KERN_ERR "S3 inforec limit reached - aborting\n");
 				return 1;
 			}
@@ -945,7 +942,7 @@ int read_fwfile(const struct ihex_binrec *record)
 			s3data[ns3data].len = len;
 			s3data[ns3data].data = (uint8_t *) record->data;
 			ns3data++;
-			if ( ns3data == S3DATA_MAX ) {
+			if (ns3data == S3DATA_MAX) {
 				printk(KERN_ERR "S3 datarec limit reached - aborting\n");
 				return 1;
 			}
@@ -1023,7 +1020,7 @@ int writeimage(wlandevice_t *wlandev, imgchunk_t *fchunk,
 	rstatemsg.enable.data = P80211ENUM_truth_true;
 	rstatemsg.exeaddr.data = startaddr;
 
-	msgp = (p80211msg_t *) & rstatemsg;
+	msgp = (p80211msg_t *) &rstatemsg;
 	result = prism2mgmt_ramdl_state(wlandev, msgp);
 	if (result) {
 		printk(KERN_ERR
@@ -1063,7 +1060,7 @@ int writeimage(wlandevice_t *wlandev, imgchunk_t *fchunk,
 			    ("Sending xxxdl_write message addr=%06x len=%d.\n",
 			     currdaddr, currlen);
 
-			msgp = (p80211msg_t *) & rwritemsg;
+			msgp = (p80211msg_t *) &rwritemsg;
 			result = prism2mgmt_ramdl_write(wlandev, msgp);
 
 			/* Check the results */
@@ -1090,7 +1087,7 @@ int writeimage(wlandevice_t *wlandev, imgchunk_t *fchunk,
 	rstatemsg.enable.data = P80211ENUM_truth_false;
 	rstatemsg.exeaddr.data = 0;
 
-	msgp = (p80211msg_t *) & rstatemsg;
+	msgp = (p80211msg_t *) &rstatemsg;
 	result = prism2mgmt_ramdl_state(wlandev, msgp);
 	if (result) {
 		printk(KERN_ERR
@@ -1160,10 +1157,7 @@ int validate_identity(void)
 			}
 			/* SEC compat range */
 			if ((s3info[i].info.compat.role == 1) &&
-			    (s3info[i].info.compat.id == 4)) {
-
-			}
-
+			    (s3info[i].info.compat.id == 4))
 			break;
 		case 3:
 			pr_debug("Seq: %#x\n", s3info[i].info.buildseq);
@@ -1196,8 +1190,9 @@ int validate_identity(void)
 			pr_debug("Unknown inforec type %d\n", s3info[i].type);
 		}
 	}
-	// walk through
+	/* walk through */
 
-	if (trump && (result != 2)) result = 0;
+	if (trump && (result != 2))
+		result = 0;
 	return result;
 }

commit 83a0f9bc658b20b06740691d9ee711c5d14b6e8a
Author: Randy Dunlap <randy.dunlap@oracle.com>
Date:   Thu Feb 25 09:55:03 2010 -0800

    Staging: fix wlan-ng printk format warning
    
    Fix prism2fw.c printk format warning:
    
    drivers/staging/wlan-ng/prism2fw.c:209: warning: format '%d' expects type 'int', but argument 3 has type 'size_t'
    
    Signed-off-by: Randy Dunlap <randy.dunlap@oracle.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/wlan-ng/prism2fw.c b/drivers/staging/wlan-ng/prism2fw.c
index baa20a7c930d..b57601250dc7 100644
--- a/drivers/staging/wlan-ng/prism2fw.c
+++ b/drivers/staging/wlan-ng/prism2fw.c
@@ -205,7 +205,7 @@ int prism2_fwtry(struct usb_device *udev, wlandevice_t *wlandev)
 		return 1;
 	}
 
-	printk(KERN_INFO "prism2_usb: %s will be processed, size %d\n",
+	printk(KERN_INFO "prism2_usb: %s will be processed, size %zu\n",
 	       PRISM2_USB_FWFILE, fw_entry->size);
 	prism2_fwapply((const struct ihex_binrec *)fw_entry->data, wlandev);
 

commit 5dd8acc8fd6b0476a2dc49bc6de4712d22c368c0
Author: Svenne Krap <svenne@krap.dk>
Date:   Sun Feb 14 18:59:00 2010 +0100

    Staging: wlan-ng: multiple safe style cleanups
    
    Cleanups as suggested by checkpatch.pl utiltiy.
    .o's from before and after cleanup have matching SHA1s.
    
    Signed-off-by: Svenne Krap <svenne@krap.dk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/wlan-ng/prism2fw.c b/drivers/staging/wlan-ng/prism2fw.c
index 5e95c482fb7b..baa20a7c930d 100644
--- a/drivers/staging/wlan-ng/prism2fw.c
+++ b/drivers/staging/wlan-ng/prism2fw.c
@@ -265,7 +265,7 @@ int prism2_fwapply(const struct ihex_binrec *rfptr, wlandevice_t *wlandev)
 	/* Build the PDA we're going to use. */
 	if (read_cardpda(&pda, wlandev)) {
 		printk(KERN_ERR "load_cardpda failed, exiting.\n");
-		return (1);
+		return 1;
 	}
 
 	/* read the card's PRI-SUP */
@@ -287,9 +287,8 @@ int prism2_fwapply(const struct ihex_binrec *rfptr, wlandevice_t *wlandev)
 
 	/* DIDmsg_dot11req_mibget */
 	prism2mgmt_mibset_mibget(wlandev, &getmsg);
-	if (getmsg.resultcode.data != P80211ENUM_resultcode_success) {
+	if (getmsg.resultcode.data != P80211ENUM_resultcode_success)
 		printk(KERN_ERR "Couldn't fetch PRI-SUP info\n");
-	}
 
 	/* Already in host order */
 	priid.role = *data++;
@@ -302,19 +301,19 @@ int prism2_fwapply(const struct ihex_binrec *rfptr, wlandevice_t *wlandev)
 	result = read_fwfile(rfptr);
 	if (result) {
 		printk(KERN_ERR "Failed to read the data exiting.\n");
-		return (1);
+		return 1;
 	}
 
 	result = validate_identity();
 
 	if (result) {
 		printk(KERN_ERR "Incompatible firmware image.\n");
-		return (1);
+		return 1;
 	}
 
 	if (startaddr == 0x00000000) {
 		printk(KERN_ERR "Can't RAM download a Flash image!\n");
-		return (1);
+		return 1;
 	}
 
 	/* Make the image chunks */
@@ -324,20 +323,20 @@ int prism2_fwapply(const struct ihex_binrec *rfptr, wlandevice_t *wlandev)
 	result = plugimage(fchunk, nfchunks, s3plug, ns3plug, &pda);
 	if (result) {
 		printk(KERN_ERR "Failed to plug data.\n");
-		return (1);
+		return 1;
 	}
 
 	/* Insert any CRCs */
 	if (crcimage(fchunk, nfchunks, s3crc, ns3crc)) {
 		printk(KERN_ERR "Failed to insert all CRCs\n");
-		return (1);
+		return 1;
 	}
 
 	/* Write the image */
 	result = writeimage(wlandev, fchunk, nfchunks);
 	if (result) {
 		printk(KERN_ERR "Failed to ramwrite image data.\n");
-		return (1);
+		return 1;
 	}
 
 	/* clear any allocated memory */
@@ -435,9 +434,8 @@ void free_chunks(imgchunk_t *fchunk, unsigned int *nfchunks)
 {
 	int i;
 	for (i = 0; i < *nfchunks; i++) {
-		if (fchunk[i].data != NULL) {
+		if (fchunk[i].data != NULL)
 			kfree(fchunk[i].data);
-		}
 	}
 	*nfchunks = 0;
 	memset(fchunk, 0, sizeof(*fchunk));
@@ -532,7 +530,7 @@ int mkimage(imgchunk_t *clist, unsigned int *ccnt)
 		if (clist[i].data == NULL) {
 			printk(KERN_ERR
 			       "failed to allocate image space, exitting.\n");
-			return (1);
+			return 1;
 		}
 		memset(clist[i].data, 0, clist[i].len);
 		pr_debug("chunk[%d]: addr=0x%06x len=%d\n",
@@ -546,15 +544,14 @@ int mkimage(imgchunk_t *clist, unsigned int *ccnt)
 		for (j = 0; j < *ccnt; j++) {
 			cstart = clist[j].addr;
 			cend = cstart + clist[j].len - 1;
-			if (s3start >= cstart && s3end <= cend) {
+			if (s3start >= cstart && s3end <= cend)
 				break;
-			}
 		}
 		if (((unsigned int)j) >= (*ccnt)) {
 			printk(KERN_ERR
 			       "s3rec(a=0x%06x,l=%d), no chunk match, exiting.\n",
 			       s3start, s3data[i].len);
-			return (1);
+			return 1;
 		}
 		coffset = s3start - cstart;
 		memcpy(clist[j].data + coffset, s3data[i].data, s3data[i].len);
@@ -587,7 +584,7 @@ int mkpdrlist(pda_t *pda)
 	curroff = 0;
 	while (curroff < (HFA384x_PDA_LEN_MAX / 2) &&
 	       le16_to_cpu(pda16[curroff + 1]) != HFA384x_PDR_END_OF_PDA) {
-		pda->rec[pda->nrec] = (hfa384x_pdrec_t *) & (pda16[curroff]);
+		pda->rec[pda->nrec] = (hfa384x_pdrec_t *) &(pda16[curroff]);
 
 		if (le16_to_cpu(pda->rec[pda->nrec]->code) == HFA384x_PDR_NICID) {
 			memcpy(&nicid, &pda->rec[pda->nrec]->data.nicid,
@@ -624,10 +621,10 @@ int mkpdrlist(pda_t *pda)
 		printk(KERN_ERR
 		       "no end record found or invalid lengths in "
 		       "PDR data, exiting. %x %d\n", curroff, pda->nrec);
-		return (1);
+		return 1;
 	}
 	if (le16_to_cpu(pda16[curroff + 1]) == HFA384x_PDR_END_OF_PDA) {
-		pda->rec[pda->nrec] = (hfa384x_pdrec_t *) & (pda16[curroff]);
+		pda->rec[pda->nrec] = (hfa384x_pdrec_t *) &(pda16[curroff]);
 		(pda->nrec)++;
 	}
 	return result;
@@ -870,7 +867,7 @@ int read_fwfile(const struct ihex_binrec *record)
 		ptr16 = (u16 *) record->data;
 
 		/* parse what was an S3 srec and put it in the right array */
-		switch(addr) {
+		switch (addr) {
 		case S3ADDR_START:
 			startaddr = *ptr32;
 			pr_debug("  S7 start addr, record=%d "
@@ -891,7 +888,7 @@ int read_fwfile(const struct ihex_binrec *record)
 				      s3plug[ns3plug].len);
 
 			ns3plug++;
-			if ( ns3plug == S3PLUG_MAX ) {
+			if (ns3plug == S3PLUG_MAX) {
 				printk(KERN_ERR "S3 plugrec limit reached - aborting\n");
 				return 1;
 			}
@@ -908,7 +905,7 @@ int read_fwfile(const struct ihex_binrec *record)
 				      s3crc[ns3crc].len,
 				      s3crc[ns3crc].dowrite);
 			ns3crc++;
-			if ( ns3crc == S3CRC_MAX ) {
+			if (ns3crc == S3CRC_MAX) {
 				printk(KERN_ERR "S3 crcrec limit reached - aborting\n");
 				return 1;
 			}
@@ -922,12 +919,12 @@ int read_fwfile(const struct ihex_binrec *record)
 				      rcnt,
 				      s3info[ns3info].len,
 				      s3info[ns3info].type);
-			if ( ((s3info[ns3info].len - 1) * sizeof(u16)) > sizeof(s3info[ns3info].info) ) {
+			if (((s3info[ns3info].len - 1) * sizeof(u16)) > sizeof(s3info[ns3info].info)) {
 				printk(KERN_ERR " S3 inforec length too long - aborting\n");
 				return 1;
 			}
 
-			tmpinfo = (u16*)&(s3info[ns3info].info.version);
+			tmpinfo = (u16 *)&(s3info[ns3info].info.version);
 			pr_debug("            info=");
 			for (i = 0; i < s3info[ns3info].len - 1; i++) {
 				tmpinfo[i] = *(ptr16 + 2 + i);
@@ -936,7 +933,7 @@ int read_fwfile(const struct ihex_binrec *record)
 			pr_debug("\n");
 
 			ns3info++;
-			if ( ns3info == S3INFO_MAX ) {
+			if (ns3info == S3INFO_MAX) {
 				printk(KERN_ERR "S3 inforec limit reached - aborting\n");
 				return 1;
 			}
@@ -946,7 +943,7 @@ int read_fwfile(const struct ihex_binrec *record)
 			s3data[ns3data].len = len;
 			s3data[ns3data].data = (uint8_t *) record->data;
 			ns3data++;
-			if ( ns3data == S3DATA_MAX ) {
+			if (ns3data == S3DATA_MAX) {
 				printk(KERN_ERR "S3 datarec limit reached - aborting\n");
 				return 1;
 			}
@@ -1024,7 +1021,7 @@ int writeimage(wlandevice_t *wlandev, imgchunk_t *fchunk,
 	rstatemsg.enable.data = P80211ENUM_truth_true;
 	rstatemsg.exeaddr.data = startaddr;
 
-	msgp = (p80211msg_t *) & rstatemsg;
+	msgp = (p80211msg_t *) &rstatemsg;
 	result = prism2mgmt_ramdl_state(wlandev, msgp);
 	if (result) {
 		printk(KERN_ERR
@@ -1064,7 +1061,7 @@ int writeimage(wlandevice_t *wlandev, imgchunk_t *fchunk,
 			    ("Sending xxxdl_write message addr=%06x len=%d.\n",
 			     currdaddr, currlen);
 
-			msgp = (p80211msg_t *) & rwritemsg;
+			msgp = (p80211msg_t *) &rwritemsg;
 			result = prism2mgmt_ramdl_write(wlandev, msgp);
 
 			/* Check the results */
@@ -1091,7 +1088,7 @@ int writeimage(wlandevice_t *wlandev, imgchunk_t *fchunk,
 	rstatemsg.enable.data = P80211ENUM_truth_false;
 	rstatemsg.exeaddr.data = 0;
 
-	msgp = (p80211msg_t *) & rstatemsg;
+	msgp = (p80211msg_t *) &rstatemsg;
 	result = prism2mgmt_ramdl_state(wlandev, msgp);
 	if (result) {
 		printk(KERN_ERR
@@ -1162,7 +1159,7 @@ int validate_identity(void)
 			/* SEC compat range */
 			if ((s3info[i].info.compat.role == 1) &&
 			    (s3info[i].info.compat.id == 4)) {
-
+                /* FIXME: isn't something missing here? */
 			}
 
 			break;
@@ -1197,8 +1194,9 @@ int validate_identity(void)
 			pr_debug("Unknown inforec type %d\n", s3info[i].type);
 		}
 	}
-	// walk through
+	/* walk through */
 
-	if (trump && (result != 2)) result = 0;
+	if (trump && (result != 2))
+		result = 0;
 	return result;
 }

commit 5d929a71908968905331cda0d52c44570d402110
Author: Ben Hutchings <ben@decadent.org.uk>
Date:   Wed Jan 13 23:36:09 2010 +0000

    staging: declare MODULE_FIRMWARE in various drivers
    
    Signed-off-by: Ben Hutchings <ben@decadent.org.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/wlan-ng/prism2fw.c b/drivers/staging/wlan-ng/prism2fw.c
index aaa70ed57710..5e95c482fb7b 100644
--- a/drivers/staging/wlan-ng/prism2fw.c
+++ b/drivers/staging/wlan-ng/prism2fw.c
@@ -53,6 +53,7 @@
 /* Local Constants */
 
 #define PRISM2_USB_FWFILE	"prism2_ru.fw"
+MODULE_FIRMWARE(PRISM2_USB_FWFILE);
 
 #define S3DATA_MAX		5000
 #define S3PLUG_MAX		200

commit 4068fe8b2aa3e12643db0ad5dd4bcf6755a7320f
Author: Julia Lawall <julia@diku.dk>
Date:   Wed Dec 9 20:25:04 2009 +0100

    Staging: wlan-ng: fix Correct size given to memset
    
    Memset should be given the size of the structure, not the size of the pointer.
    
    The semantic patch that makes this change is as follows:
    (http://coccinelle.lip6.fr/)
    
    // <smpl>
    @@
    type T;
    T *x;
    expression E;
    @@
    
    memset(x, E, sizeof(
    + *
     x))
    // </smpl>
    
    Signed-off-by: Julia Lawall <julia@diku.dk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/wlan-ng/prism2fw.c b/drivers/staging/wlan-ng/prism2fw.c
index 7d76a7f92a33..aaa70ed57710 100644
--- a/drivers/staging/wlan-ng/prism2fw.c
+++ b/drivers/staging/wlan-ng/prism2fw.c
@@ -439,7 +439,7 @@ void free_chunks(imgchunk_t *fchunk, unsigned int *nfchunks)
 		}
 	}
 	*nfchunks = 0;
-	memset(fchunk, 0, sizeof(fchunk));
+	memset(fchunk, 0, sizeof(*fchunk));
 
 }
 

commit d89505998e007f88e08e84381dcc720a8990507d
Author: Karl Relton <karllinuxtest.relton@ntlworld.com>
Date:   Wed Aug 19 08:06:39 2009 +0100

    Staging: wlan-ng: Convert firmware loading to load binary ihex format
    
    Convert prism2_usb firmware loading to load firmware in pre-compiled
    binary 'ihex' format rather than ascii 'srec' format. This moves the
    srec processing and sorting of records out of kernel space into a
    pre-compiler. The driver now just works with the binary image, but
    still does the 'pda plugging' of that image at runtime, as required
    by the prism hardware.
    
    Some Notes:
    
    - The firmware is now expected to be in the same 'ihex' (.fw) format
      used by other drivers.
    
    - The now driver assumes the data records are already sorted into ascending
      address order.
    
    - Plug and crc records are still recognised by special address locations
      as in original srec processing.
    
    - The srec S7 start address record is assumed to have been converted
      into a data record with another special address location (0xff400000),
      with the original start address being stored as a 4 byte data word
      (little endian).
    
    Signed-off-by: Karl Relton <karllinuxtest.relton@ntlworld.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/wlan-ng/prism2fw.c b/drivers/staging/wlan-ng/prism2fw.c
index c62b4759b3da..7d76a7f92a33 100644
--- a/drivers/staging/wlan-ng/prism2fw.c
+++ b/drivers/staging/wlan-ng/prism2fw.c
@@ -47,83 +47,27 @@
 
 /*================================================================*/
 /* System Includes */
-#include <linux/sort.h>
-#include <linux/firmware.h>
+#include <linux/ihex.h>
 
 /*================================================================*/
 /* Local Constants */
 
-#define PRISM2_USB_FWFILE	"prism2_ru.hex"
+#define PRISM2_USB_FWFILE	"prism2_ru.fw"
 
 #define S3DATA_MAX		5000
 #define S3PLUG_MAX		200
 #define S3CRC_MAX		200
 #define S3INFO_MAX		50
-#define SREC_LINE_MAX		264
-#define S3LEN_TXTOFFSET		2
-#define S3LEN_TXTLEN		2
-#define S3ADDR_TXTOFFSET	4
-#define S3ADDR_TXTLEN		8
-#define S3DATA_TXTOFFSET	12
-/*S3DATA_TXTLEN			variable, depends on len field */
-/*S3CKSUM_TXTOFFSET		variable, depends on len field */
-#define S3CKSUM_TXTLEN		2
-#define SERNUM_LEN_MAX		12
-
-#define S3PLUG_ITEMCODE_TXTOFFSET	(S3DATA_TXTOFFSET)
-#define S3PLUG_ITEMCODE_TXTLEN		8
-#define S3PLUG_ADDR_TXTOFFSET		(S3DATA_TXTOFFSET+8)
-#define S3PLUG_ADDR_TXTLEN		8
-#define S3PLUG_LEN_TXTOFFSET		(S3DATA_TXTOFFSET+16)
-#define S3PLUG_LEN_TXTLEN		8
-
-#define S3CRC_ADDR_TXTOFFSET		(S3DATA_TXTOFFSET)
-#define S3CRC_ADDR_TXTLEN		8
-#define S3CRC_LEN_TXTOFFSET		(S3DATA_TXTOFFSET+8)
-#define S3CRC_LEN_TXTLEN		8
-#define S3CRC_DOWRITE_TXTOFFSET		(S3DATA_TXTOFFSET+16)
-#define S3CRC_DOWRITE_TXTLEN		8
-
-#define S3INFO_LEN_TXTOFFSET		(S3DATA_TXTOFFSET)
-#define S3INFO_LEN_TXTLEN		4
-#define S3INFO_TYPE_TXTOFFSET		(S3DATA_TXTOFFSET+4)
-#define S3INFO_TYPE_TXTLEN		4
-#define S3INFO_DATA_TXTOFFSET		(S3DATA_TXTOFFSET+8)
-/* S3INFO_DATA_TXTLEN			variable, depends on INFO_LEN field */
 
 #define S3ADDR_PLUG		(0xff000000UL)
 #define S3ADDR_CRC		(0xff100000UL)
 #define S3ADDR_INFO		(0xff200000UL)
-
-#define PDAFILE_LINE_MAX	1024
+#define S3ADDR_START		(0xff400000UL)
 
 #define CHUNKS_MAX		100
 
 #define WRITESIZE_MAX		4096
 
-/*================================================================*/
-/* Local Macros */
-
-#define bswap_16(x) \
-     (__extension__							      \
-      ({ register unsigned short int __v, __x = (x);			      \
-	   __asm__ ("rorw $8, %w0"					      \
-		    : "=r" (__v)					      \
-		    : "0" (__x)						      \
-		    : "cc");						      \
-	 __v; }))
-
-#define bswap_32(x) \
-     (__extension__							      \
-      ({ register unsigned int __v, __x = (x);				      \
-	   __asm__ ("rorw $8, %w0;"					      \
-		    "rorl $16, %0;"					      \
-		    "rorw $8, %w0"					      \
-		    : "=r" (__v)					      \
-		    : "0" (__x)						      \
-		    : "cc");						      \
-	 __v; }))
-
 /*================================================================*/
 /* Local Types */
 
@@ -214,12 +158,11 @@ hfa384x_caplevel_t priid;
 /*================================================================*/
 /* Local Function Declarations */
 
-int prism2_fwapply(char *rfptr, int rfsize, wlandevice_t * wlandev);
-int read_srecfile(char *rfptr, int rfsize);
+int prism2_fwapply(const struct ihex_binrec *rfptr, wlandevice_t *wlandev);
+int read_fwfile(const struct ihex_binrec *rfptr);
 int mkimage(imgchunk_t *clist, unsigned int *ccnt);
 int read_cardpda(pda_t *pda, wlandevice_t *wlandev);
 int mkpdrlist(pda_t *pda);
-int s3datarec_compare(const void *p1, const void *p2);
 int plugimage(imgchunk_t *fchunk, unsigned int nfchunks,
 	      s3plugrec_t *s3plug, unsigned int ns3plug, pda_t * pda);
 int crcimage(imgchunk_t *fchunk, unsigned int nfchunks,
@@ -253,7 +196,7 @@ int prism2_fwtry(struct usb_device *udev, wlandevice_t *wlandev)
 
 	printk(KERN_INFO "prism2_usb: Checking for firmware %s\n",
 	       PRISM2_USB_FWFILE);
-	if (request_firmware(&fw_entry, PRISM2_USB_FWFILE, &udev->dev) != 0) {
+	if (request_ihex_firmware(&fw_entry, PRISM2_USB_FWFILE, &udev->dev) != 0) {
 		printk(KERN_INFO
 		       "prism2_usb: Firmware not available, but not essential\n");
 		printk(KERN_INFO
@@ -263,7 +206,7 @@ int prism2_fwtry(struct usb_device *udev, wlandevice_t *wlandev)
 
 	printk(KERN_INFO "prism2_usb: %s will be processed, size %d\n",
 	       PRISM2_USB_FWFILE, fw_entry->size);
-	prism2_fwapply((char *)fw_entry->data, fw_entry->size, wlandev);
+	prism2_fwapply((const struct ihex_binrec *)fw_entry->data, wlandev);
 
 	release_firmware(fw_entry);
 	return 0;
@@ -276,14 +219,13 @@ int prism2_fwtry(struct usb_device *udev, wlandevice_t *wlandev)
 *
 * Arguments:
 *	rfptr	firmware image in kernel memory
-*	rfsize	firmware size in kernel memory
 *	wlandev device
 *
 * Returns:
 *	0	- success
 *	~0	- failure
 ----------------------------------------------------------------*/
-int prism2_fwapply(char *rfptr, int rfsize, wlandevice_t *wlandev)
+int prism2_fwapply(const struct ihex_binrec *rfptr, wlandevice_t *wlandev)
 {
 	signed int result = 0;
 	p80211msg_dot11req_mibget_t getmsg;
@@ -356,13 +298,11 @@ int prism2_fwapply(char *rfptr, int rfsize, wlandevice_t *wlandev)
 	priid.top = *data++;
 
 	/* Read the S3 file */
-	result = read_srecfile(rfptr, rfsize);
+	result = read_fwfile(rfptr);
 	if (result) {
 		printk(KERN_ERR "Failed to read the data exiting.\n");
 		return (1);
 	}
-	/* Sort the S3 data records */
-	sort(s3data, ns3data, sizeof(s3datarec_t), s3datarec_compare, NULL);
 
 	result = validate_identity();
 
@@ -516,10 +456,6 @@ void free_chunks(imgchunk_t *fchunk, unsigned int *nfchunks)
 ----------------------------------------------------------------*/
 void free_srecs(void)
 {
-	int i;
-	for (i = 0; i < ns3data; i++) {
-		kfree(s3data[i].data);
-	}
 	ns3data = 0;
 	memset(s3data, 0, sizeof(s3data));
 	ns3plug = 0;
@@ -598,10 +534,6 @@ int mkimage(imgchunk_t *clist, unsigned int *ccnt)
 			return (1);
 		}
 		memset(clist[i].data, 0, clist[i].len);
-	}
-
-	/* Display chunks */
-	for (i = 0; i < *ccnt; i++) {
 		pr_debug("chunk[%d]: addr=0x%06x len=%d\n",
 			 i, clist[i].addr, clist[i].len);
 	}
@@ -856,44 +788,20 @@ int read_cardpda(pda_t *pda, wlandevice_t *wlandev)
 }
 
 /*----------------------------------------------------------------
-* copy_line
+* read_fwfile
 *
-* Copies a line of text, up to \n, \0, or SREC_LINE_MAX, or limit of
-* From array
+* Reads the given fw file which should have been compiled from an srec
+* file. Each record in the fw file will either be a plain data record,
+* a start address record, or other records used for plugging.
 *
-* Arguments:
-*	from	From addr
-*	to	To addr
-*	limit	Addr of last character in From array that can be copied
-*
-* Returns:
-*	Num characters copied
-----------------------------------------------------------------*/
-int copyline(char *from, char *to, char *limit)
-{
-	int c = 0;
-
-	while ((c < SREC_LINE_MAX - 1) && (from + c <= limit) &&
-	       (from[c] != '\n') && (from[c] != '\0')) {
-		to[c] = from[c];
-		c++;
-	}
-
-	to[c] = '\0';
-	return (c < SREC_LINE_MAX - 1) ? c + 1 : c;
-}
-
-/*----------------------------------------------------------------
-* read_srecfile
+* Note that data records are expected to be sorted into
+* ascending address order in the fw file.
 *
-* Reads the given srecord file and loads the records into the
-* s3xxx arrays.  This function can be called repeatedly (once for
-* each of a set of files), if necessary.  This function performs
-* no validation of the data except for the grossest of S-record
-* line format checks.  Don't forget that these will be DOS files...
-* CR/LF at the end of each line.
+* Note also that the start address record, originally an S7 record in
+* the srec file, is expected in the fw file to be like a data record but
+* with a certain address to make it identiable.
 *
-* Here's the SREC format we're dealing with:
+* Here's the SREC format that the fw should have come from:
 * S[37]nnaaaaaaaaddd...dddcc
 *
 *       nn - number of bytes starting with the address field
@@ -902,8 +810,9 @@ int copyline(char *from, char *to, char *limit)
 *       cc - checksum
 *
 * The S7 record's (there should be only one) address value gets
-* saved in startaddr.  It's the start execution address used
-* for RAM downloads.
+* converted to an S3 record with address of 0xff400000, with the
+* start address being stored as a 4 byte data word. That address is
+* the start execution address used for RAM downloads.
 *
 * The S3 records have a collection of subformats indicated by the
 * value of aaaaaaaa:
@@ -927,237 +836,124 @@ int copyline(char *from, char *to, char *limit)
 *                d - (s - 1) little endian words giving the contents of
 *                    the given info type.
 *
+*   0xff400000 - Start address record, data field format:
+*                aaaaaaaa
+*                a - Address in load image to plug (little endian)
+*
 * Arguments:
-*	rfptr	firmware image (s-record structure) in kernel memory
-*	rfsize	firmware size in kernel memory
+*	record	firmware image (ihex record structure) in kernel memory
 *
 * Returns:
 *	0	- success
 *	~0	- failure (probably an errno)
 ----------------------------------------------------------------*/
-int read_srecfile(char *rfptr, int rfsize)
+int read_fwfile(const struct ihex_binrec *record)
 {
-	int result = 0;
-	char buf[SREC_LINE_MAX];
-	char tmpbuf[30];
-	s3datarec_t tmprec;
-	int i, c;
-	int line = 0;
-	u16 *tmpinfo;
-	char *endptr = rfptr + rfsize;
-
-	pr_debug("Reading S-record file ...\n");
-
-	while ((c = copyline(rfptr, buf, endptr)) >= 12) {
-		rfptr = rfptr + c;
-		line++;
-		if (buf[0] != 'S') {
-			printk(KERN_ERR "%d warning: No initial \'S\'\n", line);
-			return 1;
-		}
-		if (buf[1] == '7') {	/* S7 record, start address */
-			buf[12] = '\0';
-			startaddr = simple_strtoul(buf + 4, NULL, 16);
-			pr_debug("  S7 start addr, line=%d "
-				 " addr=0x%08x\n", line, startaddr);
-			continue;
-		} else if (buf[1] == '3') {
-			/* Ok, it's an S3, parse and put it in the right array */
-			/* Record Length field (we only want datalen) */
-			memcpy(tmpbuf, buf + S3LEN_TXTOFFSET, S3LEN_TXTLEN);
-			tmpbuf[S3LEN_TXTLEN] = '\0';
-			tmprec.len = simple_strtoul(tmpbuf, NULL, 16) - 4 - 1;	/* 4=addr, 1=cksum */
-			/* Address field */
-			memcpy(tmpbuf, buf + S3ADDR_TXTOFFSET, S3ADDR_TXTLEN);
-			tmpbuf[S3ADDR_TXTLEN] = '\0';
-			tmprec.addr = simple_strtoul(tmpbuf, NULL, 16);
-			/* Checksum field */
-			tmprec.checksum =
-			    simple_strtoul(buf + strlen(buf) - 2, NULL, 16);
-
-			switch (tmprec.addr) {
-			case S3ADDR_PLUG:
-				memcpy(tmpbuf, buf + S3PLUG_ITEMCODE_TXTOFFSET,
-				       S3PLUG_ITEMCODE_TXTLEN);
-				tmpbuf[S3PLUG_ITEMCODE_TXTLEN] = '\0';
-				s3plug[ns3plug].itemcode =
-				    simple_strtoul(tmpbuf, NULL, 16);
-				s3plug[ns3plug].itemcode =
-				    bswap_32(s3plug[ns3plug].itemcode);
-
-				memcpy(tmpbuf, buf + S3PLUG_ADDR_TXTOFFSET,
-				       S3PLUG_ADDR_TXTLEN);
-				tmpbuf[S3PLUG_ADDR_TXTLEN] = '\0';
-				s3plug[ns3plug].addr =
-				    simple_strtoul(tmpbuf, NULL, 16);
-				s3plug[ns3plug].addr =
-				    bswap_32(s3plug[ns3plug].addr);
-
-				memcpy(tmpbuf, buf + S3PLUG_LEN_TXTOFFSET,
-				       S3PLUG_LEN_TXTLEN);
-				tmpbuf[S3PLUG_LEN_TXTLEN] = '\0';
-				s3plug[ns3plug].len =
-				    simple_strtoul(tmpbuf, NULL, 16);
-				s3plug[ns3plug].len =
-				    bswap_32(s3plug[ns3plug].len);
-
-				pr_debug("  S3 plugrec, line=%d "
-					 "itemcode=0x%04x addr=0x%08x len=%d\n",
-					 line,
-					 s3plug[ns3plug].itemcode,
-					 s3plug[ns3plug].addr,
-					 s3plug[ns3plug].len);
-
-				ns3plug++;
-				if (ns3plug == S3PLUG_MAX) {
-					printk(KERN_ERR
-					       "S3 plugrec limit reached - aborting\n");
-					return 1;
-				}
-				break;
-			case S3ADDR_CRC:
-				memcpy(tmpbuf, buf + S3CRC_ADDR_TXTOFFSET,
-				       S3CRC_ADDR_TXTLEN);
-				tmpbuf[S3CRC_ADDR_TXTLEN] = '\0';
-				s3crc[ns3crc].addr =
-				    simple_strtoul(tmpbuf, NULL, 16);
-				s3crc[ns3crc].addr =
-				    bswap_32(s3crc[ns3crc].addr);
-
-				memcpy(tmpbuf, buf + S3CRC_LEN_TXTOFFSET,
-				       S3CRC_LEN_TXTLEN);
-				tmpbuf[S3CRC_LEN_TXTLEN] = '\0';
-				s3crc[ns3crc].len =
-				    simple_strtoul(tmpbuf, NULL, 16);
-				s3crc[ns3crc].len = bswap_32(s3crc[ns3crc].len);
-
-				memcpy(tmpbuf, buf + S3CRC_DOWRITE_TXTOFFSET,
-				       S3CRC_DOWRITE_TXTLEN);
-				tmpbuf[S3CRC_DOWRITE_TXTLEN] = '\0';
-				s3crc[ns3crc].dowrite =
-				    simple_strtoul(tmpbuf, NULL, 16);
-				s3crc[ns3crc].dowrite =
-				    bswap_32(s3crc[ns3crc].dowrite);
-
-				pr_debug("  S3 crcrec, line=%d "
-					 "addr=0x%08x len=%d write=0x%08x\n",
-					 line,
-					 s3crc[ns3crc].addr,
-					 s3crc[ns3crc].len,
-					 s3crc[ns3crc].dowrite);
-				ns3crc++;
-				if (ns3crc == S3CRC_MAX) {
-					printk(KERN_ERR
-					       "S3 crcrec limit reached - aborting\n");
-					return 1;
-				}
-				break;
-			case S3ADDR_INFO:
-				memcpy(tmpbuf, buf + S3INFO_LEN_TXTOFFSET,
-				       S3INFO_LEN_TXTLEN);
-				tmpbuf[S3INFO_LEN_TXTLEN] = '\0';
-				s3info[ns3info].len =
-				    simple_strtoul(tmpbuf, NULL, 16);
-				s3info[ns3info].len =
-				    bswap_16(s3info[ns3info].len);
-
-				memcpy(tmpbuf, buf + S3INFO_TYPE_TXTOFFSET,
-				       S3INFO_TYPE_TXTLEN);
-				tmpbuf[S3INFO_TYPE_TXTLEN] = '\0';
-				s3info[ns3info].type =
-				    simple_strtoul(tmpbuf, NULL, 16);
-				s3info[ns3info].type =
-				    bswap_16(s3info[ns3info].type);
-
-				pr_debug("  S3 inforec, line=%d "
-					 "len=0x%04x type=0x%04x\n",
-					 line,
-					 s3info[ns3info].len,
-					 s3info[ns3info].type);
-				if (((s3info[ns3info].len - 1) * sizeof(u16)) >
-				    sizeof(s3info[ns3info].info)) {
-					printk(KERN_ERR
-					       " S3 inforec length too long - aborting\n");
-					return 1;
-				}
+	int		i;
+	int		rcnt = 0;
+	u16		*tmpinfo;
+	u16		*ptr16;
+	u32		*ptr32, len, addr;
 
-				tmpinfo =
-				    (u16 *) & (s3info[ns3info].info.version);
-				for (i = 0; i < s3info[ns3info].len - 1; i++) {
-					memcpy(tmpbuf,
-					       buf + S3INFO_DATA_TXTOFFSET +
-					       (i * 4), 4);
-					tmpbuf[4] = '\0';
-					tmpinfo[i] =
-					    simple_strtoul(tmpbuf, NULL, 16);
-					tmpinfo[i] = bswap_16(tmpinfo[i]);
-				}
-				pr_debug("            info=");
-				for (i = 0; i < s3info[ns3info].len - 1; i++) {
-					pr_debug("%04x ", tmpinfo[i]);
-				}
-				pr_debug("\n");
+	pr_debug("Reading fw file ...\n");
 
-				ns3info++;
-				if (ns3info == S3INFO_MAX) {
-					printk(KERN_ERR
-					       "S3 inforec limit reached - aborting\n");
-					return 1;
-				}
-				break;
-			default:	/* Data record */
-				s3data[ns3data].addr = tmprec.addr;
-				s3data[ns3data].len = tmprec.len;
-				s3data[ns3data].checksum = tmprec.checksum;
-				s3data[ns3data].data =
-				    kmalloc(tmprec.len, GFP_KERNEL);
-				for (i = 0; i < tmprec.len; i++) {
-					memcpy(tmpbuf,
-					       buf + S3DATA_TXTOFFSET + (i * 2),
-					       2);
-					tmpbuf[2] = '\0';
-					s3data[ns3data].data[i] =
-					    simple_strtoul(tmpbuf, NULL, 16);
-				}
-				ns3data++;
-				if (ns3data == S3DATA_MAX) {
-					printk(KERN_ERR
-					       "S3 datarec limit reached - aborting\n");
-					return 1;
-				}
-				break;
+	while (record) {
+
+		rcnt++;
+
+		len = be16_to_cpu(record->len);
+		addr = be32_to_cpu(record->addr);
+
+		/* Point into data for different word lengths */
+		ptr32 = (u32 *) record->data;
+		ptr16 = (u16 *) record->data;
+
+		/* parse what was an S3 srec and put it in the right array */
+		switch(addr) {
+		case S3ADDR_START:
+			startaddr = *ptr32;
+			pr_debug("  S7 start addr, record=%d "
+				      " addr=0x%08x\n",
+				      rcnt,
+				      startaddr);
+			break;
+		case S3ADDR_PLUG:
+			s3plug[ns3plug].itemcode = *ptr32;
+			s3plug[ns3plug].addr = *(ptr32 + 1);
+			s3plug[ns3plug].len = *(ptr32 + 2);
+
+			pr_debug("  S3 plugrec, record=%d "
+				      "itemcode=0x%08x addr=0x%08x len=%d\n",
+				      rcnt,
+				      s3plug[ns3plug].itemcode,
+				      s3plug[ns3plug].addr,
+				      s3plug[ns3plug].len);
+
+			ns3plug++;
+			if ( ns3plug == S3PLUG_MAX ) {
+				printk(KERN_ERR "S3 plugrec limit reached - aborting\n");
+				return 1;
 			}
-		} else {
-			printk(KERN_WARNING
-			       "%d warning: Unknown S-record detected.\n",
-			       line);
+			break;
+		case S3ADDR_CRC:
+			s3crc[ns3crc].addr = *ptr32;
+			s3crc[ns3crc].len = *(ptr32 + 1);
+			s3crc[ns3crc].dowrite = *(ptr32 + 2);
+
+			pr_debug("  S3 crcrec, record=%d "
+				      "addr=0x%08x len=%d write=0x%08x\n",
+				      rcnt,
+				      s3crc[ns3crc].addr,
+				      s3crc[ns3crc].len,
+				      s3crc[ns3crc].dowrite);
+			ns3crc++;
+			if ( ns3crc == S3CRC_MAX ) {
+				printk(KERN_ERR "S3 crcrec limit reached - aborting\n");
+				return 1;
+			}
+			break;
+		case S3ADDR_INFO:
+			s3info[ns3info].len = *ptr16;
+			s3info[ns3info].type = *(ptr16 + 1);
+
+			pr_debug("  S3 inforec, record=%d "
+			      "len=0x%04x type=0x%04x\n",
+				      rcnt,
+				      s3info[ns3info].len,
+				      s3info[ns3info].type);
+			if ( ((s3info[ns3info].len - 1) * sizeof(u16)) > sizeof(s3info[ns3info].info) ) {
+				printk(KERN_ERR " S3 inforec length too long - aborting\n");
+				return 1;
+			}
+
+			tmpinfo = (u16*)&(s3info[ns3info].info.version);
+			pr_debug("            info=");
+			for (i = 0; i < s3info[ns3info].len - 1; i++) {
+				tmpinfo[i] = *(ptr16 + 2 + i);
+				pr_debug("%04x ", tmpinfo[i]);
+			}
+			pr_debug("\n");
+
+			ns3info++;
+			if ( ns3info == S3INFO_MAX ) {
+				printk(KERN_ERR "S3 inforec limit reached - aborting\n");
+				return 1;
+			}
+			break;
+		default:	/* Data record */
+			s3data[ns3data].addr = addr;
+			s3data[ns3data].len = len;
+			s3data[ns3data].data = (uint8_t *) record->data;
+			ns3data++;
+			if ( ns3data == S3DATA_MAX ) {
+				printk(KERN_ERR "S3 datarec limit reached - aborting\n");
+				return 1;
+			}
+			break;
 		}
+		record = ihex_next_binrec(record);
 	}
-	return result;
-}
-
-/*----------------------------------------------------------------
-* s3datarec_compare
-*
-* Comparison function for sort().
-*
-* Arguments:
-*	p1	ptr to the first item
-*	p2	ptr to the second item
-* Returns:
-*	0	items are equal
-*	<0	p1 < p2
-*	>0	p1 > p2
-----------------------------------------------------------------*/
-int s3datarec_compare(const void *p1, const void *p2)
-{
-	const s3datarec_t *s1 = p1;
-	const s3datarec_t *s2 = p2;
-	if (s1->addr == s2->addr)
-		return 0;
-	if (s1->addr < s2->addr)
-		return -1;
-	return 1;
+	return 0;
 }
 
 /*----------------------------------------------------------------
@@ -1316,6 +1112,7 @@ int validate_identity(void)
 {
 	int i;
 	int result = 1;
+	int trump = 0;
 
 	pr_debug("NIC ID: %#x v%d.%d.%d\n",
 		 nicid.id, nicid.major, nicid.minor, nicid.variant);
@@ -1389,8 +1186,7 @@ int validate_identity(void)
 			    (nicid.id != 0x8008))
 				continue;
 
-			if (result != 2)
-				result = 0;
+			trump = 1;
 			break;
 		case 0x8001:
 			pr_debug("name inforec len %d\n", s3info[i].len);
@@ -1402,5 +1198,6 @@ int validate_identity(void)
 	}
 	// walk through
 
+	if (trump && (result != 2)) result = 0;
 	return result;
 }

commit 297f06cea635ea4552541a11e7fb7014425110c6
Author: Mithlesh Thukral <mithlesh@linsyssoft.com>
Date:   Wed Jun 10 19:36:11 2009 +0530

    staging: wlan-ng: scripts/checkpatch.pl error fixes.
    
    scripts/checkpatch.pl error fixes. This is a TODO item.
    This patch fixes most of the errors reported by checkpatch.pl in
    wlan-ng directory of staging tree.
    
    Signed-off-by: Mithlesh Thukral <mithlesh@linsyssoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/wlan-ng/prism2fw.c b/drivers/staging/wlan-ng/prism2fw.c
index 608b234b6a44..c62b4759b3da 100644
--- a/drivers/staging/wlan-ng/prism2fw.c
+++ b/drivers/staging/wlan-ng/prism2fw.c
@@ -177,19 +177,19 @@ typedef struct imgchunk {
 /* s-record image processing */
 
 /* Data records */
-unsigned int ns3data = 0;
+unsigned int ns3data;
 s3datarec_t s3data[S3DATA_MAX];
 
 /* Plug records */
-unsigned int ns3plug = 0;
+unsigned int ns3plug;
 s3plugrec_t s3plug[S3PLUG_MAX];
 
 /* CRC records */
-unsigned int ns3crc = 0;
+unsigned int ns3crc;
 s3crcrec_t s3crc[S3CRC_MAX];
 
 /* Info records */
-unsigned int ns3info = 0;
+unsigned int ns3info;
 s3inforec_t s3info[S3INFO_MAX];
 
 /* S7 record (there _better_ be only one) */
@@ -216,17 +216,17 @@ hfa384x_caplevel_t priid;
 
 int prism2_fwapply(char *rfptr, int rfsize, wlandevice_t * wlandev);
 int read_srecfile(char *rfptr, int rfsize);
-int mkimage(imgchunk_t * clist, unsigned int *ccnt);
-int read_cardpda(pda_t * pda, wlandevice_t * wlandev);
-int mkpdrlist(pda_t * pda);
+int mkimage(imgchunk_t *clist, unsigned int *ccnt);
+int read_cardpda(pda_t *pda, wlandevice_t *wlandev);
+int mkpdrlist(pda_t *pda);
 int s3datarec_compare(const void *p1, const void *p2);
-int plugimage(imgchunk_t * fchunk, unsigned int nfchunks,
-	      s3plugrec_t * s3plug, unsigned int ns3plug, pda_t * pda);
-int crcimage(imgchunk_t * fchunk, unsigned int nfchunks,
-	     s3crcrec_t * s3crc, unsigned int ns3crc);
-int writeimage(wlandevice_t * wlandev, imgchunk_t * fchunk,
+int plugimage(imgchunk_t *fchunk, unsigned int nfchunks,
+	      s3plugrec_t *s3plug, unsigned int ns3plug, pda_t * pda);
+int crcimage(imgchunk_t *fchunk, unsigned int nfchunks,
+	     s3crcrec_t *s3crc, unsigned int ns3crc);
+int writeimage(wlandevice_t *wlandev, imgchunk_t *fchunk,
 	       unsigned int nfchunks);
-void free_chunks(imgchunk_t * fchunk, unsigned int *nfchunks);
+void free_chunks(imgchunk_t *fchunk, unsigned int *nfchunks);
 void free_srecs(void);
 
 int validate_identity(void);
@@ -247,7 +247,7 @@ int validate_identity(void);
 *	0	- success
 *	~0	- failure
 ----------------------------------------------------------------*/
-int prism2_fwtry(struct usb_device *udev, wlandevice_t * wlandev)
+int prism2_fwtry(struct usb_device *udev, wlandevice_t *wlandev)
 {
 	const struct firmware *fw_entry = NULL;
 
@@ -283,7 +283,7 @@ int prism2_fwtry(struct usb_device *udev, wlandevice_t * wlandev)
 *	0	- success
 *	~0	- failure
 ----------------------------------------------------------------*/
-int prism2_fwapply(char *rfptr, int rfsize, wlandevice_t * wlandev)
+int prism2_fwapply(char *rfptr, int rfsize, wlandevice_t *wlandev)
 {
 	signed int result = 0;
 	p80211msg_dot11req_mibget_t getmsg;
@@ -425,7 +425,7 @@ int prism2_fwapply(char *rfptr, int rfsize, wlandevice_t * wlandev)
 *	0	success
 *	~0	failure
 ----------------------------------------------------------------*/
-int crcimage(imgchunk_t * fchunk, unsigned int nfchunks, s3crcrec_t * s3crc,
+int crcimage(imgchunk_t *fchunk, unsigned int nfchunks, s3crcrec_t *s3crc,
 	     unsigned int ns3crc)
 {
 	int result = 0;
@@ -490,7 +490,7 @@ int crcimage(imgchunk_t * fchunk, unsigned int nfchunks, s3crcrec_t * s3crc,
 * Returns:
 *	nothing
 ----------------------------------------------------------------*/
-void free_chunks(imgchunk_t * fchunk, unsigned int *nfchunks)
+void free_chunks(imgchunk_t *fchunk, unsigned int *nfchunks)
 {
 	int i;
 	for (i = 0; i < *nfchunks; i++) {
@@ -545,7 +545,7 @@ void free_srecs(void)
 *	0	- success
 *	~0	- failure (probably an errno)
 ----------------------------------------------------------------*/
-int mkimage(imgchunk_t * clist, unsigned int *ccnt)
+int mkimage(imgchunk_t *clist, unsigned int *ccnt)
 {
 	int result = 0;
 	int i;
@@ -644,7 +644,7 @@ int mkimage(imgchunk_t * clist, unsigned int *ccnt)
 *	0	- success
 *	~0	- failure (probably an errno)
 ----------------------------------------------------------------*/
-int mkpdrlist(pda_t * pda)
+int mkpdrlist(pda_t *pda)
 {
 	int result = 0;
 	u16 *pda16 = (u16 *) pda->buf;
@@ -717,8 +717,8 @@ int mkpdrlist(pda_t * pda)
 *	0	success
 *	~0	failure
 ----------------------------------------------------------------*/
-int plugimage(imgchunk_t * fchunk, unsigned int nfchunks,
-	      s3plugrec_t * s3plug, unsigned int ns3plug, pda_t * pda)
+int plugimage(imgchunk_t *fchunk, unsigned int nfchunks,
+	      s3plugrec_t *s3plug, unsigned int ns3plug, pda_t * pda)
 {
 	int result = 0;
 	int i;			/* plug index */
@@ -825,7 +825,7 @@ int plugimage(imgchunk_t * fchunk, unsigned int nfchunks,
 *	0	- success
 *	~0	- failure (probably an errno)
 ----------------------------------------------------------------*/
-int read_cardpda(pda_t * pda, wlandevice_t * wlandev)
+int read_cardpda(pda_t *pda, wlandevice_t *wlandev)
 {
 	int result = 0;
 	p80211msg_p2req_readpda_t msg;
@@ -1175,7 +1175,7 @@ int s3datarec_compare(const void *p1, const void *p2)
 *	0	success
 *	~0	failure
 ----------------------------------------------------------------*/
-int writeimage(wlandevice_t * wlandev, imgchunk_t * fchunk,
+int writeimage(wlandevice_t *wlandev, imgchunk_t *fchunk,
 	       unsigned int nfchunks)
 {
 	int result = 0;

commit 75f49e07520d036c2a0903694fdc0bcfb5523b76
Author: Mithlesh Thukral <mithlesh@linsyssoft.com>
Date:   Mon May 25 19:06:16 2009 +0530

    Staging: wlan-ng: Lindent cleanups
    
    Lindent script cleanups in wlan-ng driver in the staging tree.
    This is a item in the TODO list.
    
    Signed-off-by: Mithlesh Thukral <mithlesh@linsyssoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/wlan-ng/prism2fw.c b/drivers/staging/wlan-ng/prism2fw.c
index 48bfb8331ddb..608b234b6a44 100644
--- a/drivers/staging/wlan-ng/prism2fw.c
+++ b/drivers/staging/wlan-ng/prism2fw.c
@@ -50,7 +50,6 @@
 #include <linux/sort.h>
 #include <linux/firmware.h>
 
-
 /*================================================================*/
 /* Local Constants */
 
@@ -125,89 +124,80 @@
 		    : "cc");						      \
 	 __v; }))
 
-
-
 /*================================================================*/
 /* Local Types */
 
-typedef struct s3datarec
-{
-	u32	len;
-	u32	addr;
-	u8	checksum;
-	u8	*data;
+typedef struct s3datarec {
+	u32 len;
+	u32 addr;
+	u8 checksum;
+	u8 *data;
 } s3datarec_t;
 
-typedef struct s3plugrec
-{
-	u32	itemcode;
-	u32	addr;
-	u32	len;
+typedef struct s3plugrec {
+	u32 itemcode;
+	u32 addr;
+	u32 len;
 } s3plugrec_t;
 
-typedef struct s3crcrec
-{
-	u32		addr;
-	u32		len;
-	unsigned int	dowrite;
+typedef struct s3crcrec {
+	u32 addr;
+	u32 len;
+	unsigned int dowrite;
 } s3crcrec_t;
 
-typedef struct s3inforec
-{
-	u16	len;
-	u16	type;
+typedef struct s3inforec {
+	u16 len;
+	u16 type;
 	union {
-		hfa384x_compident_t	version;
-		hfa384x_caplevel_t	compat;
-		u16			buildseq;
-		hfa384x_compident_t	platform;
-	}	info;
+		hfa384x_compident_t version;
+		hfa384x_caplevel_t compat;
+		u16 buildseq;
+		hfa384x_compident_t platform;
+	} info;
 } s3inforec_t;
 
-typedef struct pda
-{
-	u8		buf[HFA384x_PDA_LEN_MAX];
-	hfa384x_pdrec_t	*rec[HFA384x_PDA_RECS_MAX];
-	unsigned int	nrec;
+typedef struct pda {
+	u8 buf[HFA384x_PDA_LEN_MAX];
+	hfa384x_pdrec_t *rec[HFA384x_PDA_RECS_MAX];
+	unsigned int nrec;
 } pda_t;
 
-typedef struct imgchunk
-{
-	u32	addr;	/* start address */
-	u32	len;	/* in bytes */
-	u16	crc;	/* CRC value (if it falls at a chunk boundary) */
-	u8	*data;
+typedef struct imgchunk {
+	u32 addr;		/* start address */
+	u32 len;		/* in bytes */
+	u16 crc;		/* CRC value (if it falls at a chunk boundary) */
+	u8 *data;
 } imgchunk_t;
 
 /*================================================================*/
 /* Local Static Definitions */
 
-
 /*----------------------------------------------------------------*/
 /* s-record image processing */
 
 /* Data records */
-unsigned int	ns3data = 0;
-s3datarec_t	s3data[S3DATA_MAX];
+unsigned int ns3data = 0;
+s3datarec_t s3data[S3DATA_MAX];
 
 /* Plug records */
-unsigned int	ns3plug = 0;
-s3plugrec_t	s3plug[S3PLUG_MAX];
+unsigned int ns3plug = 0;
+s3plugrec_t s3plug[S3PLUG_MAX];
 
 /* CRC records */
-unsigned int	ns3crc = 0;
-s3crcrec_t	s3crc[S3CRC_MAX];
+unsigned int ns3crc = 0;
+s3crcrec_t s3crc[S3CRC_MAX];
 
 /* Info records */
-unsigned int	ns3info = 0;
-s3inforec_t	s3info[S3INFO_MAX];
+unsigned int ns3info = 0;
+s3inforec_t s3info[S3INFO_MAX];
 
 /* S7 record (there _better_ be only one) */
-u32		startaddr;
+u32 startaddr;
 
 /* Load image chunks */
-unsigned int	nfchunks;
-imgchunk_t	fchunk[CHUNKS_MAX];
+unsigned int nfchunks;
+imgchunk_t fchunk[CHUNKS_MAX];
 
 /* Note that for the following pdrec_t arrays, the len and code */
 /*   fields are stored in HOST byte order. The mkpdrlist() function */
@@ -215,36 +205,35 @@ imgchunk_t	fchunk[CHUNKS_MAX];
 /*----------------------------------------------------------------*/
 /* PDA, built from [card|newfile]+[addfile1+addfile2...] */
 
-pda_t		pda;
+pda_t pda;
 hfa384x_compident_t nicid;
-hfa384x_caplevel_t  rfid;
-hfa384x_caplevel_t  macid;
-hfa384x_caplevel_t  priid;
-
+hfa384x_caplevel_t rfid;
+hfa384x_caplevel_t macid;
+hfa384x_caplevel_t priid;
 
 /*================================================================*/
 /* Local Function Declarations */
 
-int	prism2_fwapply(char *rfptr, int rfsize, wlandevice_t *wlandev);
-int	read_srecfile(char *rfptr, int rfsize);
-int	mkimage(imgchunk_t *clist, unsigned int *ccnt);
-int	read_cardpda(pda_t *pda, wlandevice_t *wlandev);
-int	mkpdrlist( pda_t *pda);
-int	s3datarec_compare(const void *p1, const void *p2);
-int	plugimage( imgchunk_t *fchunk, unsigned int nfchunks,
-		s3plugrec_t* s3plug, unsigned int ns3plug, pda_t *pda);
-int	crcimage( imgchunk_t *fchunk, unsigned int nfchunks,
-		s3crcrec_t *s3crc, unsigned int ns3crc);
-int	writeimage(wlandevice_t *wlandev, imgchunk_t *fchunk, unsigned int nfchunks);
-void	free_chunks(imgchunk_t *fchunk, unsigned int *nfchunks);
-void	free_srecs(void);
-
-int     validate_identity(void);
+int prism2_fwapply(char *rfptr, int rfsize, wlandevice_t * wlandev);
+int read_srecfile(char *rfptr, int rfsize);
+int mkimage(imgchunk_t * clist, unsigned int *ccnt);
+int read_cardpda(pda_t * pda, wlandevice_t * wlandev);
+int mkpdrlist(pda_t * pda);
+int s3datarec_compare(const void *p1, const void *p2);
+int plugimage(imgchunk_t * fchunk, unsigned int nfchunks,
+	      s3plugrec_t * s3plug, unsigned int ns3plug, pda_t * pda);
+int crcimage(imgchunk_t * fchunk, unsigned int nfchunks,
+	     s3crcrec_t * s3crc, unsigned int ns3crc);
+int writeimage(wlandevice_t * wlandev, imgchunk_t * fchunk,
+	       unsigned int nfchunks);
+void free_chunks(imgchunk_t * fchunk, unsigned int *nfchunks);
+void free_srecs(void);
+
+int validate_identity(void);
 
 /*================================================================*/
 /* Function Definitions */
 
-
 /*----------------------------------------------------------------
 * prism2_fwtry
 *
@@ -258,13 +247,13 @@ int     validate_identity(void);
 *	0	- success
 *	~0	- failure
 ----------------------------------------------------------------*/
-int prism2_fwtry(struct usb_device *udev, wlandevice_t *wlandev)
+int prism2_fwtry(struct usb_device *udev, wlandevice_t * wlandev)
 {
 	const struct firmware *fw_entry = NULL;
 
-	printk(KERN_INFO "prism2_usb: Checking for firmware %s\n", PRISM2_USB_FWFILE);
-	if(request_firmware(&fw_entry, PRISM2_USB_FWFILE, &udev->dev) != 0)
-	{
+	printk(KERN_INFO "prism2_usb: Checking for firmware %s\n",
+	       PRISM2_USB_FWFILE);
+	if (request_firmware(&fw_entry, PRISM2_USB_FWFILE, &udev->dev) != 0) {
 		printk(KERN_INFO
 		       "prism2_usb: Firmware not available, but not essential\n");
 		printk(KERN_INFO
@@ -272,14 +261,14 @@ int prism2_fwtry(struct usb_device *udev, wlandevice_t *wlandev)
 		return 1;
 	}
 
-	printk(KERN_INFO "prism2_usb: %s will be processed, size %d\n", PRISM2_USB_FWFILE, fw_entry->size);
+	printk(KERN_INFO "prism2_usb: %s will be processed, size %d\n",
+	       PRISM2_USB_FWFILE, fw_entry->size);
 	prism2_fwapply((char *)fw_entry->data, fw_entry->size, wlandev);
 
 	release_firmware(fw_entry);
 	return 0;
 }
 
-
 /*----------------------------------------------------------------
 * prism2_fwapply
 *
@@ -294,12 +283,12 @@ int prism2_fwtry(struct usb_device *udev, wlandevice_t *wlandev)
 *	0	- success
 *	~0	- failure
 ----------------------------------------------------------------*/
-int prism2_fwapply(char *rfptr, int rfsize, wlandevice_t *wlandev)
+int prism2_fwapply(char *rfptr, int rfsize, wlandevice_t * wlandev)
 {
-	signed int	result = 0;
+	signed int result = 0;
 	p80211msg_dot11req_mibget_t getmsg;
 	p80211itemd_t *item;
-	u32        *data;
+	u32 *data;
 
 	/* Initialize the data structures */
 	ns3data = 0;
@@ -313,20 +302,19 @@ int prism2_fwapply(char *rfptr, int rfsize, wlandevice_t *wlandev)
 	startaddr = 0;
 
 	nfchunks = 0;
-	memset( fchunk, 0, sizeof(fchunk));
-	memset( &nicid, 0, sizeof(nicid));
-	memset( &rfid, 0, sizeof(rfid));
-	memset( &macid, 0, sizeof(macid));
-	memset( &priid, 0, sizeof(priid));
+	memset(fchunk, 0, sizeof(fchunk));
+	memset(&nicid, 0, sizeof(nicid));
+	memset(&rfid, 0, sizeof(rfid));
+	memset(&macid, 0, sizeof(macid));
+	memset(&priid, 0, sizeof(priid));
 
 	/* clear the pda and add an initial END record */
 	memset(&pda, 0, sizeof(pda));
-	pda.rec[0] = (hfa384x_pdrec_t*)pda.buf;
-	pda.rec[0]->len = cpu_to_le16(2);  	/* len in words */  			/* len in words */
+	pda.rec[0] = (hfa384x_pdrec_t *) pda.buf;
+	pda.rec[0]->len = cpu_to_le16(2);	/* len in words *//* len in words */
 	pda.rec[0]->code = cpu_to_le16(HFA384x_PDR_END_OF_PDA);
 	pda.nrec = 1;
 
-
 	/*-----------------------------------------------------*/
 	/* Put card into fwload state */
 	prism2sta_ifstate(wlandev, P80211ENUM_ifstate_fwload);
@@ -334,7 +322,7 @@ int prism2_fwapply(char *rfptr, int rfsize, wlandevice_t *wlandev)
 	/* Build the PDA we're going to use. */
 	if (read_cardpda(&pda, wlandev)) {
 		printk(KERN_ERR "load_cardpda failed, exiting.\n");
-		return(1);
+		return (1);
 	}
 
 	/* read the card's PRI-SUP */
@@ -352,7 +340,7 @@ int prism2_fwapply(char *rfptr, int rfsize, wlandevice_t *wlandev)
 	item->did = DIDmib_p2_p2NIC_p2PRISupRange;
 	item->status = P80211ENUM_msgitem_status_no_value;
 
-	data = (u32*) item->data;
+	data = (u32 *) item->data;
 
 	/* DIDmsg_dot11req_mibget */
 	prism2mgmt_mibset_mibget(wlandev, &getmsg);
@@ -367,53 +355,48 @@ int prism2_fwapply(char *rfptr, int rfsize, wlandevice_t *wlandev)
 	priid.bottom = *data++;
 	priid.top = *data++;
 
-
 	/* Read the S3 file */
 	result = read_srecfile(rfptr, rfsize);
-	if ( result ) {
+	if (result) {
 		printk(KERN_ERR "Failed to read the data exiting.\n");
-		return(1);
+		return (1);
 	}
 	/* Sort the S3 data records */
-	sort( s3data,
-		ns3data,
-		sizeof(s3datarec_t),
-		s3datarec_compare, NULL);
+	sort(s3data, ns3data, sizeof(s3datarec_t), s3datarec_compare, NULL);
 
 	result = validate_identity();
 
-	if ( result ) {
+	if (result) {
 		printk(KERN_ERR "Incompatible firmware image.\n");
-		return(1);
+		return (1);
 	}
 
 	if (startaddr == 0x00000000) {
 		printk(KERN_ERR "Can't RAM download a Flash image!\n");
-		return(1);
+		return (1);
 	}
 
 	/* Make the image chunks */
 	result = mkimage(fchunk, &nfchunks);
 
 	/* Do any plugging */
-	result = plugimage(fchunk, nfchunks, s3plug, ns3plug,
-						&pda);
-	if ( result ) {
+	result = plugimage(fchunk, nfchunks, s3plug, ns3plug, &pda);
+	if (result) {
 		printk(KERN_ERR "Failed to plug data.\n");
-		return(1);
+		return (1);
 	}
 
 	/* Insert any CRCs */
-	if (crcimage(fchunk, nfchunks, s3crc, ns3crc) ) {
+	if (crcimage(fchunk, nfchunks, s3crc, ns3crc)) {
 		printk(KERN_ERR "Failed to insert all CRCs\n");
-		return(1);
+		return (1);
 	}
 
 	/* Write the image */
 	result = writeimage(wlandev, fchunk, nfchunks);
-	if ( result ) {
+	if (result) {
 		printk(KERN_ERR "Failed to ramwrite image data.\n");
-		return(1);
+		return (1);
 	}
 
 	/* clear any allocated memory */
@@ -425,7 +408,6 @@ int prism2_fwapply(char *rfptr, int rfsize, wlandevice_t *wlandev)
 	return result;
 }
 
-
 /*----------------------------------------------------------------
 * crcimage
 *
@@ -443,59 +425,60 @@ int prism2_fwapply(char *rfptr, int rfsize, wlandevice_t *wlandev)
 *	0	success
 *	~0	failure
 ----------------------------------------------------------------*/
-int crcimage(imgchunk_t *fchunk, unsigned int nfchunks, s3crcrec_t *s3crc,
+int crcimage(imgchunk_t * fchunk, unsigned int nfchunks, s3crcrec_t * s3crc,
 	     unsigned int ns3crc)
 {
-	int	result = 0;
-	int	i;
-	int	c;
-	u32	crcstart;
-	u32	crcend;
-	u32	cstart = 0;
-	u32	cend;
-	u8	*dest;
-	u32	chunkoff;
-
-	for ( i = 0; i < ns3crc; i++ ) {
-		if ( !s3crc[i].dowrite ) continue;
+	int result = 0;
+	int i;
+	int c;
+	u32 crcstart;
+	u32 crcend;
+	u32 cstart = 0;
+	u32 cend;
+	u8 *dest;
+	u32 chunkoff;
+
+	for (i = 0; i < ns3crc; i++) {
+		if (!s3crc[i].dowrite)
+			continue;
 		crcstart = s3crc[i].addr;
-		crcend =   s3crc[i].addr + s3crc[i].len;
+		crcend = s3crc[i].addr + s3crc[i].len;
 		/* Find chunk */
-		for ( c = 0; c < nfchunks; c++) {
+		for (c = 0; c < nfchunks; c++) {
 			cstart = fchunk[c].addr;
-			cend =	 fchunk[c].addr + fchunk[c].len;
+			cend = fchunk[c].addr + fchunk[c].len;
 			/*  the line below does an address & len match search */
 			/*  unfortunately, I've found that the len fields of */
 			/*  some crc records don't match with the length of */
 			/*  the actual data, so we're not checking right */
 			/*  now */
-			/* if ( crcstart-2 >= cstart && crcend <= cend ) break;*/
+			/* if ( crcstart-2 >= cstart && crcend <= cend ) break; */
 
 			/* note the -2 below, it's to make sure the chunk has */
 			/*   space for the CRC value */
-			if ( crcstart-2 >= cstart && crcstart < cend ) break;
+			if (crcstart - 2 >= cstart && crcstart < cend)
+				break;
 		}
-		if ( c >= nfchunks ) {
+		if (c >= nfchunks) {
 			printk(KERN_ERR
-				"Failed to find chunk for "
-				"crcrec[%d], addr=0x%06x len=%d , "
-				"aborting crc.\n",
-				i, s3crc[i].addr, s3crc[i].len);
+			       "Failed to find chunk for "
+			       "crcrec[%d], addr=0x%06x len=%d , "
+			       "aborting crc.\n",
+			       i, s3crc[i].addr, s3crc[i].len);
 			return 1;
 		}
 
 		/* Insert crc */
-		pr_debug("Adding crc @ 0x%06x\n", s3crc[i].addr-2);
+		pr_debug("Adding crc @ 0x%06x\n", s3crc[i].addr - 2);
 		chunkoff = crcstart - cstart - 2;
 		dest = fchunk[c].data + chunkoff;
-		*dest =     0xde;
-		*(dest+1) = 0xc0;
+		*dest = 0xde;
+		*(dest + 1) = 0xc0;
 
 	}
 	return result;
 }
 
-
 /*----------------------------------------------------------------
 * free_chunks
 *
@@ -507,20 +490,19 @@ int crcimage(imgchunk_t *fchunk, unsigned int nfchunks, s3crcrec_t *s3crc,
 * Returns:
 *	nothing
 ----------------------------------------------------------------*/
-void free_chunks(imgchunk_t *fchunk, unsigned int *nfchunks)
+void free_chunks(imgchunk_t * fchunk, unsigned int *nfchunks)
 {
 	int i;
-	for ( i = 0; i < *nfchunks; i++) {
-		if ( fchunk[i].data != NULL ) {
+	for (i = 0; i < *nfchunks; i++) {
+		if (fchunk[i].data != NULL) {
 			kfree(fchunk[i].data);
 		}
 	}
 	*nfchunks = 0;
-	memset( fchunk, 0, sizeof(fchunk));
+	memset(fchunk, 0, sizeof(fchunk));
 
 }
 
-
 /*----------------------------------------------------------------
 * free_srecs
 *
@@ -535,7 +517,7 @@ void free_chunks(imgchunk_t *fchunk, unsigned int *nfchunks)
 void free_srecs(void)
 {
 	int i;
-	for ( i = 0; i < ns3data; i++) {
+	for (i = 0; i < ns3data; i++) {
 		kfree(s3data[i].data);
 	}
 	ns3data = 0;
@@ -549,7 +531,6 @@ void free_srecs(void)
 	startaddr = 0;
 }
 
-
 /*----------------------------------------------------------------
 * mkimage
 *
@@ -564,25 +545,25 @@ void free_srecs(void)
 *	0	- success
 *	~0	- failure (probably an errno)
 ----------------------------------------------------------------*/
-int mkimage(imgchunk_t *clist, unsigned int *ccnt)
+int mkimage(imgchunk_t * clist, unsigned int *ccnt)
 {
-	int		result = 0;
-	int		i;
-	int		j;
-	int		currchunk = 0;
-	u32		nextaddr = 0;
-	u32		s3start;
-	u32		s3end;
-	u32		cstart = 0;
-	u32		cend;
-	u32		coffset;
+	int result = 0;
+	int i;
+	int j;
+	int currchunk = 0;
+	u32 nextaddr = 0;
+	u32 s3start;
+	u32 s3end;
+	u32 cstart = 0;
+	u32 cend;
+	u32 coffset;
 
 	/* There may already be data in the chunklist */
 	*ccnt = 0;
 
 	/* Establish the location and size of each chunk */
-	for ( i = 0; i < ns3data; i++) {
-		if ( s3data[i].addr == nextaddr ) {
+	for (i = 0; i < ns3data; i++) {
+		if (s3data[i].addr == nextaddr) {
 			/* existing chunk, grow it */
 			clist[currchunk].len += s3data[i].len;
 			nextaddr += s3data[i].len;
@@ -595,9 +576,9 @@ int mkimage(imgchunk_t *clist, unsigned int *ccnt)
 			nextaddr = s3data[i].addr + s3data[i].len;
 			/* Expand the chunk if there is a CRC record at */
 			/* their beginning bound */
-			for ( j = 0; j < ns3crc; j++) {
-				if ( s3crc[j].dowrite &&
-				     s3crc[j].addr == clist[currchunk].addr ) {
+			for (j = 0; j < ns3crc; j++) {
+				if (s3crc[j].dowrite &&
+				    s3crc[j].addr == clist[currchunk].addr) {
 					clist[currchunk].addr -= 2;
 					clist[currchunk].len += 2;
 				}
@@ -609,41 +590,41 @@ int mkimage(imgchunk_t *clist, unsigned int *ccnt)
 	/*  if this proves false, we'll need to add code to coalesce. */
 
 	/* Allocate buffer space for chunks */
-	for ( i = 0; i < *ccnt; i++) {
+	for (i = 0; i < *ccnt; i++) {
 		clist[i].data = kmalloc(clist[i].len, GFP_KERNEL);
-		if  ( clist[i].data == NULL ) {
-			printk(KERN_ERR "failed to allocate image space, exitting.\n");
-			return(1);
+		if (clist[i].data == NULL) {
+			printk(KERN_ERR
+			       "failed to allocate image space, exitting.\n");
+			return (1);
 		}
 		memset(clist[i].data, 0, clist[i].len);
 	}
 
-
 	/* Display chunks */
-	for ( i = 0; i < *ccnt;  i++) {
+	for (i = 0; i < *ccnt; i++) {
 		pr_debug("chunk[%d]: addr=0x%06x len=%d\n",
-			i, clist[i].addr, clist[i].len);
+			 i, clist[i].addr, clist[i].len);
 	}
 
 	/* Copy srec data to chunks */
-	for ( i = 0; i < ns3data; i++) {
+	for (i = 0; i < ns3data; i++) {
 		s3start = s3data[i].addr;
-		s3end   = s3start + s3data[i].len - 1;
-		for ( j = 0; j < *ccnt; j++) {
+		s3end = s3start + s3data[i].len - 1;
+		for (j = 0; j < *ccnt; j++) {
 			cstart = clist[j].addr;
 			cend = cstart + clist[j].len - 1;
-			if ( s3start >= cstart && s3end <= cend ) {
+			if (s3start >= cstart && s3end <= cend) {
 				break;
 			}
 		}
-		if ( ((unsigned int)j) >= (*ccnt) ) {
+		if (((unsigned int)j) >= (*ccnt)) {
 			printk(KERN_ERR
-				"s3rec(a=0x%06x,l=%d), no chunk match, exiting.\n",
-				s3start, s3data[i].len);
-			return(1);
+			       "s3rec(a=0x%06x,l=%d), no chunk match, exiting.\n",
+			       s3start, s3data[i].len);
+			return (1);
 		}
 		coffset = s3start - cstart;
-		memcpy( clist[j].data + coffset, s3data[i].data, s3data[i].len);
+		memcpy(clist[j].data + coffset, s3data[i].data, s3data[i].len);
 	}
 
 	return result;
@@ -663,21 +644,19 @@ int mkimage(imgchunk_t *clist, unsigned int *ccnt)
 *	0	- success
 *	~0	- failure (probably an errno)
 ----------------------------------------------------------------*/
-int mkpdrlist( pda_t *pda)
+int mkpdrlist(pda_t * pda)
 {
-	int	result = 0;
-	u16	*pda16 = (u16*)pda->buf;
-	int	curroff;	/* in 'words' */
+	int result = 0;
+	u16 *pda16 = (u16 *) pda->buf;
+	int curroff;		/* in 'words' */
 
 	pda->nrec = 0;
 	curroff = 0;
-	while ( curroff < (HFA384x_PDA_LEN_MAX / 2) &&
-		le16_to_cpu(pda16[curroff + 1]) !=
-		HFA384x_PDR_END_OF_PDA ) {
-		pda->rec[pda->nrec] = (hfa384x_pdrec_t*)&(pda16[curroff]);
+	while (curroff < (HFA384x_PDA_LEN_MAX / 2) &&
+	       le16_to_cpu(pda16[curroff + 1]) != HFA384x_PDR_END_OF_PDA) {
+		pda->rec[pda->nrec] = (hfa384x_pdrec_t *) & (pda16[curroff]);
 
-		if (le16_to_cpu(pda->rec[pda->nrec]->code) ==
-				HFA384x_PDR_NICID) {
+		if (le16_to_cpu(pda->rec[pda->nrec]->code) == HFA384x_PDR_NICID) {
 			memcpy(&nicid, &pda->rec[pda->nrec]->data.nicid,
 			       sizeof(nicid));
 			nicid.id = le16_to_cpu(nicid.id);
@@ -686,7 +665,7 @@ int mkpdrlist( pda_t *pda)
 			nicid.minor = le16_to_cpu(nicid.minor);
 		}
 		if (le16_to_cpu(pda->rec[pda->nrec]->code) ==
-				HFA384x_PDR_MFISUPRANGE) {
+		    HFA384x_PDR_MFISUPRANGE) {
 			memcpy(&rfid, &pda->rec[pda->nrec]->data.mfisuprange,
 			       sizeof(rfid));
 			rfid.id = le16_to_cpu(rfid.id);
@@ -695,7 +674,7 @@ int mkpdrlist( pda_t *pda)
 			rfid.top = le16_to_cpu(rfid.top);
 		}
 		if (le16_to_cpu(pda->rec[pda->nrec]->code) ==
-				HFA384x_PDR_CFISUPRANGE) {
+		    HFA384x_PDR_CFISUPRANGE) {
 			memcpy(&macid, &pda->rec[pda->nrec]->data.cfisuprange,
 			       sizeof(macid));
 			macid.id = le16_to_cpu(macid.id);
@@ -708,21 +687,19 @@ int mkpdrlist( pda_t *pda)
 		curroff += le16_to_cpu(pda16[curroff]) + 1;
 
 	}
-	if ( curroff >= (HFA384x_PDA_LEN_MAX / 2) ) {
+	if (curroff >= (HFA384x_PDA_LEN_MAX / 2)) {
 		printk(KERN_ERR
-			"no end record found or invalid lengths in "
-			"PDR data, exiting. %x %d\n", curroff, pda->nrec);
-		return(1);
+		       "no end record found or invalid lengths in "
+		       "PDR data, exiting. %x %d\n", curroff, pda->nrec);
+		return (1);
 	}
-	if (le16_to_cpu(pda16[curroff + 1]) == HFA384x_PDR_END_OF_PDA ) {
-		pda->rec[pda->nrec] = (hfa384x_pdrec_t*)&(pda16[curroff]);
+	if (le16_to_cpu(pda16[curroff + 1]) == HFA384x_PDR_END_OF_PDA) {
+		pda->rec[pda->nrec] = (hfa384x_pdrec_t *) & (pda16[curroff]);
 		(pda->nrec)++;
 	}
 	return result;
 }
 
-
-
 /*----------------------------------------------------------------
 * plugimage
 *
@@ -740,39 +717,39 @@ int mkpdrlist( pda_t *pda)
 *	0	success
 *	~0	failure
 ----------------------------------------------------------------*/
-int plugimage( imgchunk_t *fchunk, unsigned int nfchunks,
-		s3plugrec_t* s3plug, unsigned int ns3plug, pda_t *pda)
+int plugimage(imgchunk_t * fchunk, unsigned int nfchunks,
+	      s3plugrec_t * s3plug, unsigned int ns3plug, pda_t * pda)
 {
-	int	result = 0;
-	int	i;	/* plug index */
-	int	j;	/* index of PDR or -1 if fname plug */
-	int	c;	/* chunk index */
-	u32	pstart;
-	u32	pend;
-	u32	cstart = 0;
-	u32	cend;
-	u32	chunkoff;
-	u8	*dest;
+	int result = 0;
+	int i;			/* plug index */
+	int j;			/* index of PDR or -1 if fname plug */
+	int c;			/* chunk index */
+	u32 pstart;
+	u32 pend;
+	u32 cstart = 0;
+	u32 cend;
+	u32 chunkoff;
+	u8 *dest;
 
 	/* for each plug record */
-	for ( i = 0; i < ns3plug; i++) {
+	for (i = 0; i < ns3plug; i++) {
 		pstart = s3plug[i].addr;
-		pend = 	 s3plug[i].addr + s3plug[i].len;
+		pend = s3plug[i].addr + s3plug[i].len;
 		/* find the matching PDR (or filename) */
-		if ( s3plug[i].itemcode != 0xffffffffUL ) { /* not filename */
-			for ( j = 0; j < pda->nrec; j++) {
-				if ( s3plug[i].itemcode ==
-				     le16_to_cpu(pda->rec[j]->code) ) break;
+		if (s3plug[i].itemcode != 0xffffffffUL) {	/* not filename */
+			for (j = 0; j < pda->nrec; j++) {
+				if (s3plug[i].itemcode ==
+				    le16_to_cpu(pda->rec[j]->code))
+					break;
 			}
 		} else {
 			j = -1;
 		}
-		if ( j >= pda->nrec && j != -1 ) { /*  if no matching PDR, fail */
+		if (j >= pda->nrec && j != -1) {	/*  if no matching PDR, fail */
 			printk(KERN_WARNING
-				"warning: Failed to find PDR for "
-				"plugrec 0x%04x.\n",
-				s3plug[i].itemcode);
-			continue; /* and move on to the next PDR */
+			       "warning: Failed to find PDR for "
+			       "plugrec 0x%04x.\n", s3plug[i].itemcode);
+			continue;	/* and move on to the next PDR */
 #if 0
 			/* MSM: They swear that unless it's the MAC address,
 			 * the serial number, or the TX calibration records,
@@ -787,27 +764,26 @@ int plugimage( imgchunk_t *fchunk, unsigned int nfchunks,
 		}
 
 		/* Validate plug len against PDR len */
-		if ( j != -1 &&
-		     s3plug[i].len < le16_to_cpu(pda->rec[j]->len) ) {
+		if (j != -1 && s3plug[i].len < le16_to_cpu(pda->rec[j]->len)) {
 			printk(KERN_ERR
-				"error: Plug vs. PDR len mismatch for "
-				"plugrec 0x%04x, abort plugging.\n",
-				s3plug[i].itemcode);
+			       "error: Plug vs. PDR len mismatch for "
+			       "plugrec 0x%04x, abort plugging.\n",
+			       s3plug[i].itemcode);
 			result = 1;
 			continue;
 		}
 
 		/* Validate plug address against chunk data and identify chunk */
-		for ( c = 0; c < nfchunks; c++) {
+		for (c = 0; c < nfchunks; c++) {
 			cstart = fchunk[c].addr;
-			cend =	 fchunk[c].addr + fchunk[c].len;
-			if ( pstart >= cstart && pend <= cend ) break;
+			cend = fchunk[c].addr + fchunk[c].len;
+			if (pstart >= cstart && pend <= cend)
+				break;
 		}
-		if ( c >= nfchunks ) {
+		if (c >= nfchunks) {
 			printk(KERN_ERR
-				"error: Failed to find image chunk for "
-				"plugrec 0x%04x.\n",
-				s3plug[i].itemcode);
+			       "error: Failed to find image chunk for "
+			       "plugrec 0x%04x.\n", s3plug[i].itemcode);
 			result = 1;
 			continue;
 		}
@@ -816,22 +792,21 @@ int plugimage( imgchunk_t *fchunk, unsigned int nfchunks,
 		chunkoff = pstart - cstart;
 		dest = fchunk[c].data + chunkoff;
 		pr_debug("Plugging item 0x%04x @ 0x%06x, len=%d, "
-			      "cnum=%d coff=0x%06x\n",
-			      s3plug[i].itemcode, pstart, s3plug[i].len,
-			      c, chunkoff);
+			 "cnum=%d coff=0x%06x\n",
+			 s3plug[i].itemcode, pstart, s3plug[i].len,
+			 c, chunkoff);
 
-		if ( j == -1 ) { /* plug the filename */
+		if (j == -1) {	/* plug the filename */
 			memset(dest, 0, s3plug[i].len);
 			strncpy(dest, PRISM2_USB_FWFILE, s3plug[i].len - 1);
-		} else { /* plug a PDR */
-			memcpy( dest, &(pda->rec[j]->data), s3plug[i].len);
+		} else {	/* plug a PDR */
+			memcpy(dest, &(pda->rec[j]->data), s3plug[i].len);
 		}
 	}
 	return result;
 
 }
 
-
 /*----------------------------------------------------------------
 * read_cardpda
 *
@@ -850,10 +825,10 @@ int plugimage( imgchunk_t *fchunk, unsigned int nfchunks,
 *	0	- success
 *	~0	- failure (probably an errno)
 ----------------------------------------------------------------*/
-int read_cardpda(pda_t *pda, wlandevice_t *wlandev)
+int read_cardpda(pda_t * pda, wlandevice_t * wlandev)
 {
-	int				result = 0;
-	p80211msg_p2req_readpda_t	msg;
+	int result = 0;
+	p80211msg_p2req_readpda_t msg;
 
 	/* set up the msg */
 	msg.msgcode = DIDmsg_p2req_readpda;
@@ -866,10 +841,10 @@ int read_cardpda(pda_t *pda, wlandevice_t *wlandev)
 	msg.resultcode.len = sizeof(u32);
 	msg.resultcode.status = P80211ENUM_msgitem_status_no_value;
 
-	if ( prism2mgmt_readpda(wlandev, &msg) != 0 ) {
+	if (prism2mgmt_readpda(wlandev, &msg) != 0) {
 		/* prism2mgmt_readpda prints an errno if appropriate */
 		result = -1;
-	} else if ( msg.resultcode.data == P80211ENUM_resultcode_success ) {
+	} else if (msg.resultcode.data == P80211ENUM_resultcode_success) {
 		memcpy(pda->buf, msg.pda.data, HFA384x_PDA_LEN_MAX);
 		result = mkpdrlist(pda);
 	} else {
@@ -880,7 +855,6 @@ int read_cardpda(pda_t *pda, wlandevice_t *wlandev)
 	return result;
 }
 
-
 /*----------------------------------------------------------------
 * copy_line
 *
@@ -909,7 +883,6 @@ int copyline(char *from, char *to, char *limit)
 	return (c < SREC_LINE_MAX - 1) ? c + 1 : c;
 }
 
-
 /*----------------------------------------------------------------
 * read_srecfile
 *
@@ -964,131 +937,159 @@ int copyline(char *from, char *to, char *limit)
 ----------------------------------------------------------------*/
 int read_srecfile(char *rfptr, int rfsize)
 {
-	int		result = 0;
-	char		buf[SREC_LINE_MAX];
-	char		tmpbuf[30];
-	s3datarec_t	tmprec;
-	int		i, c;
-	int		line = 0;
-	u16		*tmpinfo;
-	char		*endptr = rfptr + rfsize;
-
+	int result = 0;
+	char buf[SREC_LINE_MAX];
+	char tmpbuf[30];
+	s3datarec_t tmprec;
+	int i, c;
+	int line = 0;
+	u16 *tmpinfo;
+	char *endptr = rfptr + rfsize;
 
 	pr_debug("Reading S-record file ...\n");
 
-	while ( (c = copyline(rfptr, buf, endptr)) >= 12 ) {
+	while ((c = copyline(rfptr, buf, endptr)) >= 12) {
 		rfptr = rfptr + c;
 		line++;
-		if ( buf[0] != 'S' ) {
+		if (buf[0] != 'S') {
 			printk(KERN_ERR "%d warning: No initial \'S\'\n", line);
 			return 1;
 		}
-		if ( buf[1] == '7' ) {	/* S7 record, start address */
+		if (buf[1] == '7') {	/* S7 record, start address */
 			buf[12] = '\0';
-			startaddr = simple_strtoul(buf+4, NULL, 16);
+			startaddr = simple_strtoul(buf + 4, NULL, 16);
 			pr_debug("  S7 start addr, line=%d "
-				      " addr=0x%08x\n",
-				      line,
-				      startaddr);
+				 " addr=0x%08x\n", line, startaddr);
 			continue;
-		} else if ( buf[1] == '3') {
+		} else if (buf[1] == '3') {
 			/* Ok, it's an S3, parse and put it in the right array */
 			/* Record Length field (we only want datalen) */
-			memcpy(tmpbuf, buf+S3LEN_TXTOFFSET, S3LEN_TXTLEN);
+			memcpy(tmpbuf, buf + S3LEN_TXTOFFSET, S3LEN_TXTLEN);
 			tmpbuf[S3LEN_TXTLEN] = '\0';
-			tmprec.len = simple_strtoul( tmpbuf, NULL, 16) - 4 - 1; /* 4=addr, 1=cksum */
+			tmprec.len = simple_strtoul(tmpbuf, NULL, 16) - 4 - 1;	/* 4=addr, 1=cksum */
 			/* Address field */
-			memcpy(tmpbuf, buf+S3ADDR_TXTOFFSET, S3ADDR_TXTLEN);
+			memcpy(tmpbuf, buf + S3ADDR_TXTOFFSET, S3ADDR_TXTLEN);
 			tmpbuf[S3ADDR_TXTLEN] = '\0';
-			tmprec.addr = simple_strtoul( tmpbuf, NULL, 16);
+			tmprec.addr = simple_strtoul(tmpbuf, NULL, 16);
 			/* Checksum field */
-			tmprec.checksum = simple_strtoul( buf+strlen(buf)-2, NULL, 16);
+			tmprec.checksum =
+			    simple_strtoul(buf + strlen(buf) - 2, NULL, 16);
 
-			switch(  tmprec.addr )
-			{
+			switch (tmprec.addr) {
 			case S3ADDR_PLUG:
-				memcpy(tmpbuf, buf+S3PLUG_ITEMCODE_TXTOFFSET, S3PLUG_ITEMCODE_TXTLEN);
+				memcpy(tmpbuf, buf + S3PLUG_ITEMCODE_TXTOFFSET,
+				       S3PLUG_ITEMCODE_TXTLEN);
 				tmpbuf[S3PLUG_ITEMCODE_TXTLEN] = '\0';
-				s3plug[ns3plug].itemcode = simple_strtoul(tmpbuf,NULL,16);
-				s3plug[ns3plug].itemcode = bswap_32(s3plug[ns3plug].itemcode);
+				s3plug[ns3plug].itemcode =
+				    simple_strtoul(tmpbuf, NULL, 16);
+				s3plug[ns3plug].itemcode =
+				    bswap_32(s3plug[ns3plug].itemcode);
 
-				memcpy(tmpbuf, buf+S3PLUG_ADDR_TXTOFFSET, S3PLUG_ADDR_TXTLEN);
+				memcpy(tmpbuf, buf + S3PLUG_ADDR_TXTOFFSET,
+				       S3PLUG_ADDR_TXTLEN);
 				tmpbuf[S3PLUG_ADDR_TXTLEN] = '\0';
-				s3plug[ns3plug].addr = simple_strtoul(tmpbuf,NULL,16);
-				s3plug[ns3plug].addr = bswap_32(s3plug[ns3plug].addr);
+				s3plug[ns3plug].addr =
+				    simple_strtoul(tmpbuf, NULL, 16);
+				s3plug[ns3plug].addr =
+				    bswap_32(s3plug[ns3plug].addr);
 
-				memcpy(tmpbuf, buf+S3PLUG_LEN_TXTOFFSET, S3PLUG_LEN_TXTLEN);
+				memcpy(tmpbuf, buf + S3PLUG_LEN_TXTOFFSET,
+				       S3PLUG_LEN_TXTLEN);
 				tmpbuf[S3PLUG_LEN_TXTLEN] = '\0';
-				s3plug[ns3plug].len = simple_strtoul(tmpbuf,NULL,16);
-				s3plug[ns3plug].len = bswap_32(s3plug[ns3plug].len);
+				s3plug[ns3plug].len =
+				    simple_strtoul(tmpbuf, NULL, 16);
+				s3plug[ns3plug].len =
+				    bswap_32(s3plug[ns3plug].len);
 
 				pr_debug("  S3 plugrec, line=%d "
-					      "itemcode=0x%04x addr=0x%08x len=%d\n",
-					      line,
-					      s3plug[ns3plug].itemcode,
-					      s3plug[ns3plug].addr,
-					      s3plug[ns3plug].len);
+					 "itemcode=0x%04x addr=0x%08x len=%d\n",
+					 line,
+					 s3plug[ns3plug].itemcode,
+					 s3plug[ns3plug].addr,
+					 s3plug[ns3plug].len);
 
 				ns3plug++;
-				if ( ns3plug == S3PLUG_MAX ) {
-					printk(KERN_ERR "S3 plugrec limit reached - aborting\n");
+				if (ns3plug == S3PLUG_MAX) {
+					printk(KERN_ERR
+					       "S3 plugrec limit reached - aborting\n");
 					return 1;
 				}
 				break;
 			case S3ADDR_CRC:
-				memcpy(tmpbuf, buf+S3CRC_ADDR_TXTOFFSET, S3CRC_ADDR_TXTLEN);
+				memcpy(tmpbuf, buf + S3CRC_ADDR_TXTOFFSET,
+				       S3CRC_ADDR_TXTLEN);
 				tmpbuf[S3CRC_ADDR_TXTLEN] = '\0';
-				s3crc[ns3crc].addr = simple_strtoul(tmpbuf,NULL,16);
-				s3crc[ns3crc].addr = bswap_32(s3crc[ns3crc].addr);
+				s3crc[ns3crc].addr =
+				    simple_strtoul(tmpbuf, NULL, 16);
+				s3crc[ns3crc].addr =
+				    bswap_32(s3crc[ns3crc].addr);
 
-				memcpy(tmpbuf, buf+S3CRC_LEN_TXTOFFSET, S3CRC_LEN_TXTLEN);
+				memcpy(tmpbuf, buf + S3CRC_LEN_TXTOFFSET,
+				       S3CRC_LEN_TXTLEN);
 				tmpbuf[S3CRC_LEN_TXTLEN] = '\0';
-				s3crc[ns3crc].len = simple_strtoul(tmpbuf,NULL,16);
+				s3crc[ns3crc].len =
+				    simple_strtoul(tmpbuf, NULL, 16);
 				s3crc[ns3crc].len = bswap_32(s3crc[ns3crc].len);
 
-				memcpy(tmpbuf, buf+S3CRC_DOWRITE_TXTOFFSET, S3CRC_DOWRITE_TXTLEN);
+				memcpy(tmpbuf, buf + S3CRC_DOWRITE_TXTOFFSET,
+				       S3CRC_DOWRITE_TXTLEN);
 				tmpbuf[S3CRC_DOWRITE_TXTLEN] = '\0';
-				s3crc[ns3crc].dowrite = simple_strtoul(tmpbuf,NULL,16);
-				s3crc[ns3crc].dowrite = bswap_32(s3crc[ns3crc].dowrite);
+				s3crc[ns3crc].dowrite =
+				    simple_strtoul(tmpbuf, NULL, 16);
+				s3crc[ns3crc].dowrite =
+				    bswap_32(s3crc[ns3crc].dowrite);
 
 				pr_debug("  S3 crcrec, line=%d "
-					      "addr=0x%08x len=%d write=0x%08x\n",
-					      line,
-					      s3crc[ns3crc].addr,
-					      s3crc[ns3crc].len,
-					      s3crc[ns3crc].dowrite);
+					 "addr=0x%08x len=%d write=0x%08x\n",
+					 line,
+					 s3crc[ns3crc].addr,
+					 s3crc[ns3crc].len,
+					 s3crc[ns3crc].dowrite);
 				ns3crc++;
-				if ( ns3crc == S3CRC_MAX ) {
-					printk(KERN_ERR "S3 crcrec limit reached - aborting\n");
+				if (ns3crc == S3CRC_MAX) {
+					printk(KERN_ERR
+					       "S3 crcrec limit reached - aborting\n");
 					return 1;
 				}
 				break;
 			case S3ADDR_INFO:
-				memcpy(tmpbuf, buf+S3INFO_LEN_TXTOFFSET, S3INFO_LEN_TXTLEN);
+				memcpy(tmpbuf, buf + S3INFO_LEN_TXTOFFSET,
+				       S3INFO_LEN_TXTLEN);
 				tmpbuf[S3INFO_LEN_TXTLEN] = '\0';
-				s3info[ns3info].len = simple_strtoul(tmpbuf,NULL,16);
-				s3info[ns3info].len = bswap_16(s3info[ns3info].len);
+				s3info[ns3info].len =
+				    simple_strtoul(tmpbuf, NULL, 16);
+				s3info[ns3info].len =
+				    bswap_16(s3info[ns3info].len);
 
-				memcpy(tmpbuf, buf+S3INFO_TYPE_TXTOFFSET, S3INFO_TYPE_TXTLEN);
+				memcpy(tmpbuf, buf + S3INFO_TYPE_TXTOFFSET,
+				       S3INFO_TYPE_TXTLEN);
 				tmpbuf[S3INFO_TYPE_TXTLEN] = '\0';
-				s3info[ns3info].type = simple_strtoul(tmpbuf,NULL,16);
-				s3info[ns3info].type = bswap_16(s3info[ns3info].type);
+				s3info[ns3info].type =
+				    simple_strtoul(tmpbuf, NULL, 16);
+				s3info[ns3info].type =
+				    bswap_16(s3info[ns3info].type);
 
 				pr_debug("  S3 inforec, line=%d "
-					      "len=0x%04x type=0x%04x\n",
-					      line,
-					      s3info[ns3info].len,
-					      s3info[ns3info].type);
-				if ( ((s3info[ns3info].len - 1) * sizeof(u16)) > sizeof(s3info[ns3info].info) ) {
-					printk(KERN_ERR " S3 inforec length too long - aborting\n");
+					 "len=0x%04x type=0x%04x\n",
+					 line,
+					 s3info[ns3info].len,
+					 s3info[ns3info].type);
+				if (((s3info[ns3info].len - 1) * sizeof(u16)) >
+				    sizeof(s3info[ns3info].info)) {
+					printk(KERN_ERR
+					       " S3 inforec length too long - aborting\n");
 					return 1;
 				}
 
-				tmpinfo = (u16*)&(s3info[ns3info].info.version);
+				tmpinfo =
+				    (u16 *) & (s3info[ns3info].info.version);
 				for (i = 0; i < s3info[ns3info].len - 1; i++) {
-					memcpy( tmpbuf, buf+S3INFO_DATA_TXTOFFSET+(i*4), 4);
+					memcpy(tmpbuf,
+					       buf + S3INFO_DATA_TXTOFFSET +
+					       (i * 4), 4);
 					tmpbuf[4] = '\0';
-					tmpinfo[i] = simple_strtoul(tmpbuf,NULL,16);
+					tmpinfo[i] =
+					    simple_strtoul(tmpbuf, NULL, 16);
 					tmpinfo[i] = bswap_16(tmpinfo[i]);
 				}
 				pr_debug("            info=");
@@ -1098,8 +1099,9 @@ int read_srecfile(char *rfptr, int rfsize)
 				pr_debug("\n");
 
 				ns3info++;
-				if ( ns3info == S3INFO_MAX ) {
-					printk(KERN_ERR "S3 inforec limit reached - aborting\n");
+				if (ns3info == S3INFO_MAX) {
+					printk(KERN_ERR
+					       "S3 inforec limit reached - aborting\n");
 					return 1;
 				}
 				break;
@@ -1107,27 +1109,33 @@ int read_srecfile(char *rfptr, int rfsize)
 				s3data[ns3data].addr = tmprec.addr;
 				s3data[ns3data].len = tmprec.len;
 				s3data[ns3data].checksum = tmprec.checksum;
-				s3data[ns3data].data = kmalloc(tmprec.len, GFP_KERNEL);
-				for ( i = 0; i < tmprec.len; i++) {
-					memcpy(tmpbuf, buf+S3DATA_TXTOFFSET+(i*2), 2);
+				s3data[ns3data].data =
+				    kmalloc(tmprec.len, GFP_KERNEL);
+				for (i = 0; i < tmprec.len; i++) {
+					memcpy(tmpbuf,
+					       buf + S3DATA_TXTOFFSET + (i * 2),
+					       2);
 					tmpbuf[2] = '\0';
-					s3data[ns3data].data[i] = simple_strtoul(tmpbuf, NULL, 16);
+					s3data[ns3data].data[i] =
+					    simple_strtoul(tmpbuf, NULL, 16);
 				}
 				ns3data++;
-				if ( ns3data == S3DATA_MAX ) {
-					printk(KERN_ERR "S3 datarec limit reached - aborting\n");
+				if (ns3data == S3DATA_MAX) {
+					printk(KERN_ERR
+					       "S3 datarec limit reached - aborting\n");
 					return 1;
 				}
 				break;
 			}
 		} else {
-			printk(KERN_WARNING "%d warning: Unknown S-record detected.\n", line);
+			printk(KERN_WARNING
+			       "%d warning: Unknown S-record detected.\n",
+			       line);
 		}
 	}
 	return result;
 }
 
-
 /*----------------------------------------------------------------
 * s3datarec_compare
 *
@@ -1143,14 +1151,15 @@ int read_srecfile(char *rfptr, int rfsize)
 ----------------------------------------------------------------*/
 int s3datarec_compare(const void *p1, const void *p2)
 {
-	const s3datarec_t	*s1 = p1;
-	const s3datarec_t	*s2 = p2;
-	if ( s1->addr == s2->addr ) return 0;
-	if ( s1->addr < s2->addr ) return -1;
+	const s3datarec_t *s1 = p1;
+	const s3datarec_t *s2 = p2;
+	if (s1->addr == s2->addr)
+		return 0;
+	if (s1->addr < s2->addr)
+		return -1;
 	return 1;
 }
 
-
 /*----------------------------------------------------------------
 * writeimage
 *
@@ -1166,113 +1175,114 @@ int s3datarec_compare(const void *p1, const void *p2)
 *	0	success
 *	~0	failure
 ----------------------------------------------------------------*/
-int writeimage(wlandevice_t *wlandev, imgchunk_t *fchunk, unsigned int nfchunks)
+int writeimage(wlandevice_t * wlandev, imgchunk_t * fchunk,
+	       unsigned int nfchunks)
 {
-	int					result = 0;
-	p80211msg_p2req_ramdl_state_t		rstatemsg;
-	p80211msg_p2req_ramdl_write_t		rwritemsg;
-	p80211msg_t				*msgp;
-	u32					resultcode;
-	int					i;
-	int					j;
-	unsigned int				nwrites;
-	u32					curroff;
-	u32					currlen;
-	u32					currdaddr;
+	int result = 0;
+	p80211msg_p2req_ramdl_state_t rstatemsg;
+	p80211msg_p2req_ramdl_write_t rwritemsg;
+	p80211msg_t *msgp;
+	u32 resultcode;
+	int i;
+	int j;
+	unsigned int nwrites;
+	u32 curroff;
+	u32 currlen;
+	u32 currdaddr;
 
 	/* Initialize the messages */
 	memset(&rstatemsg, 0, sizeof(rstatemsg));
 	strcpy(rstatemsg.devname, wlandev->name);
-	rstatemsg.msgcode =		DIDmsg_p2req_ramdl_state;
-	rstatemsg.msglen =		sizeof(rstatemsg);
-	rstatemsg.enable.did =		DIDmsg_p2req_ramdl_state_enable;
-	rstatemsg.exeaddr.did =		DIDmsg_p2req_ramdl_state_exeaddr;
-	rstatemsg.resultcode.did =	DIDmsg_p2req_ramdl_state_resultcode;
-	rstatemsg.enable.status =	P80211ENUM_msgitem_status_data_ok;
-	rstatemsg.exeaddr.status =	P80211ENUM_msgitem_status_data_ok;
-	rstatemsg.resultcode.status =	P80211ENUM_msgitem_status_no_value;
-	rstatemsg.enable.len =		sizeof(u32);
-	rstatemsg.exeaddr.len =		sizeof(u32);
-	rstatemsg.resultcode.len =	sizeof(u32);
+	rstatemsg.msgcode = DIDmsg_p2req_ramdl_state;
+	rstatemsg.msglen = sizeof(rstatemsg);
+	rstatemsg.enable.did = DIDmsg_p2req_ramdl_state_enable;
+	rstatemsg.exeaddr.did = DIDmsg_p2req_ramdl_state_exeaddr;
+	rstatemsg.resultcode.did = DIDmsg_p2req_ramdl_state_resultcode;
+	rstatemsg.enable.status = P80211ENUM_msgitem_status_data_ok;
+	rstatemsg.exeaddr.status = P80211ENUM_msgitem_status_data_ok;
+	rstatemsg.resultcode.status = P80211ENUM_msgitem_status_no_value;
+	rstatemsg.enable.len = sizeof(u32);
+	rstatemsg.exeaddr.len = sizeof(u32);
+	rstatemsg.resultcode.len = sizeof(u32);
 
 	memset(&rwritemsg, 0, sizeof(rwritemsg));
 	strcpy(rwritemsg.devname, wlandev->name);
-	rwritemsg.msgcode =		DIDmsg_p2req_ramdl_write;
-	rwritemsg.msglen =		sizeof(rwritemsg);
-	rwritemsg.addr.did =		DIDmsg_p2req_ramdl_write_addr;
-	rwritemsg.len.did =		DIDmsg_p2req_ramdl_write_len;
-	rwritemsg.data.did =		DIDmsg_p2req_ramdl_write_data;
-	rwritemsg.resultcode.did =	DIDmsg_p2req_ramdl_write_resultcode;
-	rwritemsg.addr.status =		P80211ENUM_msgitem_status_data_ok;
-	rwritemsg.len.status =		P80211ENUM_msgitem_status_data_ok;
-	rwritemsg.data.status =		P80211ENUM_msgitem_status_data_ok;
-	rwritemsg.resultcode.status =	P80211ENUM_msgitem_status_no_value;
-	rwritemsg.addr.len =		sizeof(u32);
-	rwritemsg.len.len =		sizeof(u32);
-	rwritemsg.data.len =		WRITESIZE_MAX;
-	rwritemsg.resultcode.len =	sizeof(u32);
+	rwritemsg.msgcode = DIDmsg_p2req_ramdl_write;
+	rwritemsg.msglen = sizeof(rwritemsg);
+	rwritemsg.addr.did = DIDmsg_p2req_ramdl_write_addr;
+	rwritemsg.len.did = DIDmsg_p2req_ramdl_write_len;
+	rwritemsg.data.did = DIDmsg_p2req_ramdl_write_data;
+	rwritemsg.resultcode.did = DIDmsg_p2req_ramdl_write_resultcode;
+	rwritemsg.addr.status = P80211ENUM_msgitem_status_data_ok;
+	rwritemsg.len.status = P80211ENUM_msgitem_status_data_ok;
+	rwritemsg.data.status = P80211ENUM_msgitem_status_data_ok;
+	rwritemsg.resultcode.status = P80211ENUM_msgitem_status_no_value;
+	rwritemsg.addr.len = sizeof(u32);
+	rwritemsg.len.len = sizeof(u32);
+	rwritemsg.data.len = WRITESIZE_MAX;
+	rwritemsg.resultcode.len = sizeof(u32);
 
 	/* Send xxx_state(enable) */
 	pr_debug("Sending dl_state(enable) message.\n");
 	rstatemsg.enable.data = P80211ENUM_truth_true;
 	rstatemsg.exeaddr.data = startaddr;
 
-	msgp = (p80211msg_t*)&rstatemsg;
+	msgp = (p80211msg_t *) & rstatemsg;
 	result = prism2mgmt_ramdl_state(wlandev, msgp);
-	if ( result ) {
+	if (result) {
 		printk(KERN_ERR
-			"writeimage state enable failed w/ result=%d, "
-			"aborting download\n", result);
+		       "writeimage state enable failed w/ result=%d, "
+		       "aborting download\n", result);
 		return result;
 	}
 	resultcode = rstatemsg.resultcode.data;
-	if ( resultcode != P80211ENUM_resultcode_success ) {
+	if (resultcode != P80211ENUM_resultcode_success) {
 		printk(KERN_ERR
-			"writeimage()->xxxdl_state msg indicates failure, "
-			"w/ resultcode=%d, aborting download.\n",
-			resultcode);
+		       "writeimage()->xxxdl_state msg indicates failure, "
+		       "w/ resultcode=%d, aborting download.\n", resultcode);
 		return 1;
 	}
 
 	/* Now, loop through the data chunks and send WRITESIZE_MAX data */
-	for ( i = 0; i < nfchunks; i++) {
+	for (i = 0; i < nfchunks; i++) {
 		nwrites = fchunk[i].len / WRITESIZE_MAX;
 		nwrites += (fchunk[i].len % WRITESIZE_MAX) ? 1 : 0;
 		curroff = 0;
-		for ( j = 0; j < nwrites; j++) {
+		for (j = 0; j < nwrites; j++) {
 			currlen =
-			  (fchunk[i].len - (WRITESIZE_MAX * j)) > WRITESIZE_MAX ?
-			  WRITESIZE_MAX :
-			  (fchunk[i].len - (WRITESIZE_MAX * j));
+			    (fchunk[i].len - (WRITESIZE_MAX * j)) >
+			    WRITESIZE_MAX ? WRITESIZE_MAX : (fchunk[i].len -
+							     (WRITESIZE_MAX *
+							      j));
 			curroff = j * WRITESIZE_MAX;
 			currdaddr = fchunk[i].addr + curroff;
 			/* Setup the message */
 			rwritemsg.addr.data = currdaddr;
 			rwritemsg.len.data = currlen;
 			memcpy(rwritemsg.data.data,
-				fchunk[i].data + curroff,
-				currlen);
+			       fchunk[i].data + curroff, currlen);
 
 			/* Send flashdl_write(pda) */
-			pr_debug("Sending xxxdl_write message addr=%06x len=%d.\n",
-				      currdaddr, currlen);
+			pr_debug
+			    ("Sending xxxdl_write message addr=%06x len=%d.\n",
+			     currdaddr, currlen);
 
-			msgp = (p80211msg_t*)&rwritemsg;
+			msgp = (p80211msg_t *) & rwritemsg;
 			result = prism2mgmt_ramdl_write(wlandev, msgp);
 
 			/* Check the results */
-			if ( result ) {
+			if (result) {
 				printk(KERN_ERR
-					"writeimage chunk write failed w/ result=%d, "
-					"aborting download\n", result);
+				       "writeimage chunk write failed w/ result=%d, "
+				       "aborting download\n", result);
 				return result;
 			}
 			resultcode = rstatemsg.resultcode.data;
-			if ( resultcode != P80211ENUM_resultcode_success ) {
+			if (resultcode != P80211ENUM_resultcode_success) {
 				printk(KERN_ERR
-					"writeimage()->xxxdl_write msg indicates failure, "
-					"w/ resultcode=%d, aborting download.\n",
-					resultcode);
+				       "writeimage()->xxxdl_write msg indicates failure, "
+				       "w/ resultcode=%d, aborting download.\n",
+				       resultcode);
 				return 1;
 			}
 
@@ -1284,69 +1294,54 @@ int writeimage(wlandevice_t *wlandev, imgchunk_t *fchunk, unsigned int nfchunks)
 	rstatemsg.enable.data = P80211ENUM_truth_false;
 	rstatemsg.exeaddr.data = 0;
 
-	msgp = (p80211msg_t*)&rstatemsg;
+	msgp = (p80211msg_t *) & rstatemsg;
 	result = prism2mgmt_ramdl_state(wlandev, msgp);
-	if ( result ) {
+	if (result) {
 		printk(KERN_ERR
-			"writeimage state disable failed w/ result=%d, "
-			"aborting download\n", result);
+		       "writeimage state disable failed w/ result=%d, "
+		       "aborting download\n", result);
 		return result;
 	}
 	resultcode = rstatemsg.resultcode.data;
-	if ( resultcode != P80211ENUM_resultcode_success ) {
+	if (resultcode != P80211ENUM_resultcode_success) {
 		printk(KERN_ERR
-			"writeimage()->xxxdl_state msg indicates failure, "
-			"w/ resultcode=%d, aborting download.\n",
-			resultcode);
+		       "writeimage()->xxxdl_state msg indicates failure, "
+		       "w/ resultcode=%d, aborting download.\n", resultcode);
 		return 1;
 	}
 	return result;
 }
 
-
-
 int validate_identity(void)
 {
 	int i;
 	int result = 1;
 
 	pr_debug("NIC ID: %#x v%d.%d.%d\n",
-	       nicid.id,
-	       nicid.major,
-	       nicid.minor,
-	       nicid.variant);
+		 nicid.id, nicid.major, nicid.minor, nicid.variant);
 	pr_debug("MFI ID: %#x v%d %d->%d\n",
-	       rfid.id,
-	       rfid.variant,
-	       rfid.bottom,
-	       rfid.top);
+		 rfid.id, rfid.variant, rfid.bottom, rfid.top);
 	pr_debug("CFI ID: %#x v%d %d->%d\n",
-	       macid.id,
-	       macid.variant,
-	       macid.bottom,
-	       macid.top);
+		 macid.id, macid.variant, macid.bottom, macid.top);
 	pr_debug("PRI ID: %#x v%d %d->%d\n",
-	       priid.id,
-	       priid.variant,
-	       priid.bottom,
-	       priid.top);
+		 priid.id, priid.variant, priid.bottom, priid.top);
 
-	for (i = 0 ; i < ns3info ; i ++) {
+	for (i = 0; i < ns3info; i++) {
 		switch (s3info[i].type) {
 		case 1:
 			pr_debug("Version:  ID %#x %d.%d.%d\n",
-			       s3info[i].info.version.id,
-			       s3info[i].info.version.major,
-				       s3info[i].info.version.minor,
-			       s3info[i].info.version.variant);
+				 s3info[i].info.version.id,
+				 s3info[i].info.version.major,
+				 s3info[i].info.version.minor,
+				 s3info[i].info.version.variant);
 			break;
 		case 2:
 			pr_debug("Compat: Role %#x Id %#x v%d %d->%d\n",
-			       s3info[i].info.compat.role,
-			       s3info[i].info.compat.id,
-			       s3info[i].info.compat.variant,
-			       s3info[i].info.compat.bottom,
-			       s3info[i].info.compat.top);
+				 s3info[i].info.compat.role,
+				 s3info[i].info.compat.id,
+				 s3info[i].info.compat.variant,
+				 s3info[i].info.compat.bottom,
+				 s3info[i].info.compat.top);
 
 			/* MAC compat range */
 			if ((s3info[i].info.compat.role == 1) &&
@@ -1360,8 +1355,9 @@ int validate_identity(void)
 			/* PRI compat range */
 			if ((s3info[i].info.compat.role == 1) &&
 			    (s3info[i].info.compat.id == 3)) {
-				if ((s3info[i].info.compat.bottom > priid.top) ||
-				    (s3info[i].info.compat.top < priid.bottom)){
+				if ((s3info[i].info.compat.bottom > priid.top)
+				    || (s3info[i].info.compat.top <
+					priid.bottom)) {
 					result = 3;
 				}
 			}
@@ -1373,15 +1369,15 @@ int validate_identity(void)
 
 			break;
 		case 3:
-				pr_debug("Seq: %#x\n", s3info[i].info.buildseq);
+			pr_debug("Seq: %#x\n", s3info[i].info.buildseq);
 
-				break;
+			break;
 		case 4:
 			pr_debug("Platform:  ID %#x %d.%d.%d\n",
-			       s3info[i].info.version.id,
-			       s3info[i].info.version.major,
-			       s3info[i].info.version.minor,
-			       s3info[i].info.version.variant);
+				 s3info[i].info.version.id,
+				 s3info[i].info.version.major,
+				 s3info[i].info.version.minor,
+				 s3info[i].info.version.variant);
 
 			if (nicid.id != s3info[i].info.version.id)
 				continue;

commit 76e3e7c4095237ceeb962e3bd8bdc0797fb943e1
Author: Karl Relton <karllinuxtest.relton@ntlworld.com>
Date:   Fri Apr 17 10:15:34 2009 +0100

    Staging: wlan-ng: Move firmware loading into driver
    
    Move prism2 firmware loading from userspace into driver, using linux
    request_firmware(). Firmware is now loaded (if available) on device
    probing, before it is registered as a netdevice and advertised to userspace.
    
    Signed-off-by: Karl Relton <karllinuxtest.relton@ntlworld.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/wlan-ng/prism2fw.c b/drivers/staging/wlan-ng/prism2fw.c
new file mode 100644
index 000000000000..48bfb8331ddb
--- /dev/null
+++ b/drivers/staging/wlan-ng/prism2fw.c
@@ -0,0 +1,1410 @@
+/* from src/prism2/download/prism2dl.c
+*
+* utility for downloading prism2 images moved into kernelspace
+*
+* Copyright (C) 1999 AbsoluteValue Systems, Inc.  All Rights Reserved.
+* --------------------------------------------------------------------
+*
+* linux-wlan
+*
+*   The contents of this file are subject to the Mozilla Public
+*   License Version 1.1 (the "License"); you may not use this file
+*   except in compliance with the License. You may obtain a copy of
+*   the License at http://www.mozilla.org/MPL/
+*
+*   Software distributed under the License is distributed on an "AS
+*   IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+*   implied. See the License for the specific language governing
+*   rights and limitations under the License.
+*
+*   Alternatively, the contents of this file may be used under the
+*   terms of the GNU Public License version 2 (the "GPL"), in which
+*   case the provisions of the GPL are applicable instead of the
+*   above.  If you wish to allow the use of your version of this file
+*   only under the terms of the GPL and not to allow others to use
+*   your version of this file under the MPL, indicate your decision
+*   by deleting the provisions above and replace them with the notice
+*   and other provisions required by the GPL.  If you do not delete
+*   the provisions above, a recipient may use your version of this
+*   file under either the MPL or the GPL.
+*
+* --------------------------------------------------------------------
+*
+* Inquiries regarding the linux-wlan Open Source project can be
+* made directly to:
+*
+* AbsoluteValue Systems Inc.
+* info@linux-wlan.com
+* http://www.linux-wlan.com
+*
+* --------------------------------------------------------------------
+*
+* Portions of the development of this software were funded by
+* Intersil Corporation as part of PRISM(R) chipset product development.
+*
+* --------------------------------------------------------------------
+*/
+
+/*================================================================*/
+/* System Includes */
+#include <linux/sort.h>
+#include <linux/firmware.h>
+
+
+/*================================================================*/
+/* Local Constants */
+
+#define PRISM2_USB_FWFILE	"prism2_ru.hex"
+
+#define S3DATA_MAX		5000
+#define S3PLUG_MAX		200
+#define S3CRC_MAX		200
+#define S3INFO_MAX		50
+#define SREC_LINE_MAX		264
+#define S3LEN_TXTOFFSET		2
+#define S3LEN_TXTLEN		2
+#define S3ADDR_TXTOFFSET	4
+#define S3ADDR_TXTLEN		8
+#define S3DATA_TXTOFFSET	12
+/*S3DATA_TXTLEN			variable, depends on len field */
+/*S3CKSUM_TXTOFFSET		variable, depends on len field */
+#define S3CKSUM_TXTLEN		2
+#define SERNUM_LEN_MAX		12
+
+#define S3PLUG_ITEMCODE_TXTOFFSET	(S3DATA_TXTOFFSET)
+#define S3PLUG_ITEMCODE_TXTLEN		8
+#define S3PLUG_ADDR_TXTOFFSET		(S3DATA_TXTOFFSET+8)
+#define S3PLUG_ADDR_TXTLEN		8
+#define S3PLUG_LEN_TXTOFFSET		(S3DATA_TXTOFFSET+16)
+#define S3PLUG_LEN_TXTLEN		8
+
+#define S3CRC_ADDR_TXTOFFSET		(S3DATA_TXTOFFSET)
+#define S3CRC_ADDR_TXTLEN		8
+#define S3CRC_LEN_TXTOFFSET		(S3DATA_TXTOFFSET+8)
+#define S3CRC_LEN_TXTLEN		8
+#define S3CRC_DOWRITE_TXTOFFSET		(S3DATA_TXTOFFSET+16)
+#define S3CRC_DOWRITE_TXTLEN		8
+
+#define S3INFO_LEN_TXTOFFSET		(S3DATA_TXTOFFSET)
+#define S3INFO_LEN_TXTLEN		4
+#define S3INFO_TYPE_TXTOFFSET		(S3DATA_TXTOFFSET+4)
+#define S3INFO_TYPE_TXTLEN		4
+#define S3INFO_DATA_TXTOFFSET		(S3DATA_TXTOFFSET+8)
+/* S3INFO_DATA_TXTLEN			variable, depends on INFO_LEN field */
+
+#define S3ADDR_PLUG		(0xff000000UL)
+#define S3ADDR_CRC		(0xff100000UL)
+#define S3ADDR_INFO		(0xff200000UL)
+
+#define PDAFILE_LINE_MAX	1024
+
+#define CHUNKS_MAX		100
+
+#define WRITESIZE_MAX		4096
+
+/*================================================================*/
+/* Local Macros */
+
+#define bswap_16(x) \
+     (__extension__							      \
+      ({ register unsigned short int __v, __x = (x);			      \
+	   __asm__ ("rorw $8, %w0"					      \
+		    : "=r" (__v)					      \
+		    : "0" (__x)						      \
+		    : "cc");						      \
+	 __v; }))
+
+#define bswap_32(x) \
+     (__extension__							      \
+      ({ register unsigned int __v, __x = (x);				      \
+	   __asm__ ("rorw $8, %w0;"					      \
+		    "rorl $16, %0;"					      \
+		    "rorw $8, %w0"					      \
+		    : "=r" (__v)					      \
+		    : "0" (__x)						      \
+		    : "cc");						      \
+	 __v; }))
+
+
+
+/*================================================================*/
+/* Local Types */
+
+typedef struct s3datarec
+{
+	u32	len;
+	u32	addr;
+	u8	checksum;
+	u8	*data;
+} s3datarec_t;
+
+typedef struct s3plugrec
+{
+	u32	itemcode;
+	u32	addr;
+	u32	len;
+} s3plugrec_t;
+
+typedef struct s3crcrec
+{
+	u32		addr;
+	u32		len;
+	unsigned int	dowrite;
+} s3crcrec_t;
+
+typedef struct s3inforec
+{
+	u16	len;
+	u16	type;
+	union {
+		hfa384x_compident_t	version;
+		hfa384x_caplevel_t	compat;
+		u16			buildseq;
+		hfa384x_compident_t	platform;
+	}	info;
+} s3inforec_t;
+
+typedef struct pda
+{
+	u8		buf[HFA384x_PDA_LEN_MAX];
+	hfa384x_pdrec_t	*rec[HFA384x_PDA_RECS_MAX];
+	unsigned int	nrec;
+} pda_t;
+
+typedef struct imgchunk
+{
+	u32	addr;	/* start address */
+	u32	len;	/* in bytes */
+	u16	crc;	/* CRC value (if it falls at a chunk boundary) */
+	u8	*data;
+} imgchunk_t;
+
+/*================================================================*/
+/* Local Static Definitions */
+
+
+/*----------------------------------------------------------------*/
+/* s-record image processing */
+
+/* Data records */
+unsigned int	ns3data = 0;
+s3datarec_t	s3data[S3DATA_MAX];
+
+/* Plug records */
+unsigned int	ns3plug = 0;
+s3plugrec_t	s3plug[S3PLUG_MAX];
+
+/* CRC records */
+unsigned int	ns3crc = 0;
+s3crcrec_t	s3crc[S3CRC_MAX];
+
+/* Info records */
+unsigned int	ns3info = 0;
+s3inforec_t	s3info[S3INFO_MAX];
+
+/* S7 record (there _better_ be only one) */
+u32		startaddr;
+
+/* Load image chunks */
+unsigned int	nfchunks;
+imgchunk_t	fchunk[CHUNKS_MAX];
+
+/* Note that for the following pdrec_t arrays, the len and code */
+/*   fields are stored in HOST byte order. The mkpdrlist() function */
+/*   does the conversion.  */
+/*----------------------------------------------------------------*/
+/* PDA, built from [card|newfile]+[addfile1+addfile2...] */
+
+pda_t		pda;
+hfa384x_compident_t nicid;
+hfa384x_caplevel_t  rfid;
+hfa384x_caplevel_t  macid;
+hfa384x_caplevel_t  priid;
+
+
+/*================================================================*/
+/* Local Function Declarations */
+
+int	prism2_fwapply(char *rfptr, int rfsize, wlandevice_t *wlandev);
+int	read_srecfile(char *rfptr, int rfsize);
+int	mkimage(imgchunk_t *clist, unsigned int *ccnt);
+int	read_cardpda(pda_t *pda, wlandevice_t *wlandev);
+int	mkpdrlist( pda_t *pda);
+int	s3datarec_compare(const void *p1, const void *p2);
+int	plugimage( imgchunk_t *fchunk, unsigned int nfchunks,
+		s3plugrec_t* s3plug, unsigned int ns3plug, pda_t *pda);
+int	crcimage( imgchunk_t *fchunk, unsigned int nfchunks,
+		s3crcrec_t *s3crc, unsigned int ns3crc);
+int	writeimage(wlandevice_t *wlandev, imgchunk_t *fchunk, unsigned int nfchunks);
+void	free_chunks(imgchunk_t *fchunk, unsigned int *nfchunks);
+void	free_srecs(void);
+
+int     validate_identity(void);
+
+/*================================================================*/
+/* Function Definitions */
+
+
+/*----------------------------------------------------------------
+* prism2_fwtry
+*
+* Try and get firmware into memory
+*
+* Arguments:
+*	udev	usb device structure
+*	wlandev wlan device structure
+*
+* Returns:
+*	0	- success
+*	~0	- failure
+----------------------------------------------------------------*/
+int prism2_fwtry(struct usb_device *udev, wlandevice_t *wlandev)
+{
+	const struct firmware *fw_entry = NULL;
+
+	printk(KERN_INFO "prism2_usb: Checking for firmware %s\n", PRISM2_USB_FWFILE);
+	if(request_firmware(&fw_entry, PRISM2_USB_FWFILE, &udev->dev) != 0)
+	{
+		printk(KERN_INFO
+		       "prism2_usb: Firmware not available, but not essential\n");
+		printk(KERN_INFO
+		       "prism2_usb: can continue to use card anyway.\n");
+		return 1;
+	}
+
+	printk(KERN_INFO "prism2_usb: %s will be processed, size %d\n", PRISM2_USB_FWFILE, fw_entry->size);
+	prism2_fwapply((char *)fw_entry->data, fw_entry->size, wlandev);
+
+	release_firmware(fw_entry);
+	return 0;
+}
+
+
+/*----------------------------------------------------------------
+* prism2_fwapply
+*
+* Apply the firmware loaded into memory
+*
+* Arguments:
+*	rfptr	firmware image in kernel memory
+*	rfsize	firmware size in kernel memory
+*	wlandev device
+*
+* Returns:
+*	0	- success
+*	~0	- failure
+----------------------------------------------------------------*/
+int prism2_fwapply(char *rfptr, int rfsize, wlandevice_t *wlandev)
+{
+	signed int	result = 0;
+	p80211msg_dot11req_mibget_t getmsg;
+	p80211itemd_t *item;
+	u32        *data;
+
+	/* Initialize the data structures */
+	ns3data = 0;
+	memset(s3data, 0, sizeof(s3data));
+	ns3plug = 0;
+	memset(s3plug, 0, sizeof(s3plug));
+	ns3crc = 0;
+	memset(s3crc, 0, sizeof(s3crc));
+	ns3info = 0;
+	memset(s3info, 0, sizeof(s3info));
+	startaddr = 0;
+
+	nfchunks = 0;
+	memset( fchunk, 0, sizeof(fchunk));
+	memset( &nicid, 0, sizeof(nicid));
+	memset( &rfid, 0, sizeof(rfid));
+	memset( &macid, 0, sizeof(macid));
+	memset( &priid, 0, sizeof(priid));
+
+	/* clear the pda and add an initial END record */
+	memset(&pda, 0, sizeof(pda));
+	pda.rec[0] = (hfa384x_pdrec_t*)pda.buf;
+	pda.rec[0]->len = cpu_to_le16(2);  	/* len in words */  			/* len in words */
+	pda.rec[0]->code = cpu_to_le16(HFA384x_PDR_END_OF_PDA);
+	pda.nrec = 1;
+
+
+	/*-----------------------------------------------------*/
+	/* Put card into fwload state */
+	prism2sta_ifstate(wlandev, P80211ENUM_ifstate_fwload);
+
+	/* Build the PDA we're going to use. */
+	if (read_cardpda(&pda, wlandev)) {
+		printk(KERN_ERR "load_cardpda failed, exiting.\n");
+		return(1);
+	}
+
+	/* read the card's PRI-SUP */
+	memset(&getmsg, 0, sizeof(getmsg));
+	getmsg.msgcode = DIDmsg_dot11req_mibget;
+	getmsg.msglen = sizeof(getmsg);
+	strcpy(getmsg.devname, wlandev->name);
+
+	getmsg.mibattribute.did = DIDmsg_dot11req_mibget_mibattribute;
+	getmsg.mibattribute.status = P80211ENUM_msgitem_status_data_ok;
+	getmsg.resultcode.did = DIDmsg_dot11req_mibget_resultcode;
+	getmsg.resultcode.status = P80211ENUM_msgitem_status_no_value;
+
+	item = (p80211itemd_t *) getmsg.mibattribute.data;
+	item->did = DIDmib_p2_p2NIC_p2PRISupRange;
+	item->status = P80211ENUM_msgitem_status_no_value;
+
+	data = (u32*) item->data;
+
+	/* DIDmsg_dot11req_mibget */
+	prism2mgmt_mibset_mibget(wlandev, &getmsg);
+	if (getmsg.resultcode.data != P80211ENUM_resultcode_success) {
+		printk(KERN_ERR "Couldn't fetch PRI-SUP info\n");
+	}
+
+	/* Already in host order */
+	priid.role = *data++;
+	priid.id = *data++;
+	priid.variant = *data++;
+	priid.bottom = *data++;
+	priid.top = *data++;
+
+
+	/* Read the S3 file */
+	result = read_srecfile(rfptr, rfsize);
+	if ( result ) {
+		printk(KERN_ERR "Failed to read the data exiting.\n");
+		return(1);
+	}
+	/* Sort the S3 data records */
+	sort( s3data,
+		ns3data,
+		sizeof(s3datarec_t),
+		s3datarec_compare, NULL);
+
+	result = validate_identity();
+
+	if ( result ) {
+		printk(KERN_ERR "Incompatible firmware image.\n");
+		return(1);
+	}
+
+	if (startaddr == 0x00000000) {
+		printk(KERN_ERR "Can't RAM download a Flash image!\n");
+		return(1);
+	}
+
+	/* Make the image chunks */
+	result = mkimage(fchunk, &nfchunks);
+
+	/* Do any plugging */
+	result = plugimage(fchunk, nfchunks, s3plug, ns3plug,
+						&pda);
+	if ( result ) {
+		printk(KERN_ERR "Failed to plug data.\n");
+		return(1);
+	}
+
+	/* Insert any CRCs */
+	if (crcimage(fchunk, nfchunks, s3crc, ns3crc) ) {
+		printk(KERN_ERR "Failed to insert all CRCs\n");
+		return(1);
+	}
+
+	/* Write the image */
+	result = writeimage(wlandev, fchunk, nfchunks);
+	if ( result ) {
+		printk(KERN_ERR "Failed to ramwrite image data.\n");
+		return(1);
+	}
+
+	/* clear any allocated memory */
+	free_chunks(fchunk, &nfchunks);
+	free_srecs();
+
+	printk(KERN_INFO "prism2_usb: firmware loading finished.\n");
+
+	return result;
+}
+
+
+/*----------------------------------------------------------------
+* crcimage
+*
+* Adds a CRC16 in the two bytes prior to each block identified by
+* an S3 CRC record.  Currently, we don't actually do a CRC we just
+* insert the value 0xC0DE in hfa384x order.
+*
+* Arguments:
+*	fchunk		Array of image chunks
+*	nfchunks	Number of image chunks
+*	s3crc		Array of crc records
+*	ns3crc		Number of crc records
+*
+* Returns:
+*	0	success
+*	~0	failure
+----------------------------------------------------------------*/
+int crcimage(imgchunk_t *fchunk, unsigned int nfchunks, s3crcrec_t *s3crc,
+	     unsigned int ns3crc)
+{
+	int	result = 0;
+	int	i;
+	int	c;
+	u32	crcstart;
+	u32	crcend;
+	u32	cstart = 0;
+	u32	cend;
+	u8	*dest;
+	u32	chunkoff;
+
+	for ( i = 0; i < ns3crc; i++ ) {
+		if ( !s3crc[i].dowrite ) continue;
+		crcstart = s3crc[i].addr;
+		crcend =   s3crc[i].addr + s3crc[i].len;
+		/* Find chunk */
+		for ( c = 0; c < nfchunks; c++) {
+			cstart = fchunk[c].addr;
+			cend =	 fchunk[c].addr + fchunk[c].len;
+			/*  the line below does an address & len match search */
+			/*  unfortunately, I've found that the len fields of */
+			/*  some crc records don't match with the length of */
+			/*  the actual data, so we're not checking right */
+			/*  now */
+			/* if ( crcstart-2 >= cstart && crcend <= cend ) break;*/
+
+			/* note the -2 below, it's to make sure the chunk has */
+			/*   space for the CRC value */
+			if ( crcstart-2 >= cstart && crcstart < cend ) break;
+		}
+		if ( c >= nfchunks ) {
+			printk(KERN_ERR
+				"Failed to find chunk for "
+				"crcrec[%d], addr=0x%06x len=%d , "
+				"aborting crc.\n",
+				i, s3crc[i].addr, s3crc[i].len);
+			return 1;
+		}
+
+		/* Insert crc */
+		pr_debug("Adding crc @ 0x%06x\n", s3crc[i].addr-2);
+		chunkoff = crcstart - cstart - 2;
+		dest = fchunk[c].data + chunkoff;
+		*dest =     0xde;
+		*(dest+1) = 0xc0;
+
+	}
+	return result;
+}
+
+
+/*----------------------------------------------------------------
+* free_chunks
+*
+* Clears the chunklist data structures in preparation for a new file.
+*
+* Arguments:
+*	none
+*
+* Returns:
+*	nothing
+----------------------------------------------------------------*/
+void free_chunks(imgchunk_t *fchunk, unsigned int *nfchunks)
+{
+	int i;
+	for ( i = 0; i < *nfchunks; i++) {
+		if ( fchunk[i].data != NULL ) {
+			kfree(fchunk[i].data);
+		}
+	}
+	*nfchunks = 0;
+	memset( fchunk, 0, sizeof(fchunk));
+
+}
+
+
+/*----------------------------------------------------------------
+* free_srecs
+*
+* Clears the srec data structures in preparation for a new file.
+*
+* Arguments:
+*	none
+*
+* Returns:
+*	nothing
+----------------------------------------------------------------*/
+void free_srecs(void)
+{
+	int i;
+	for ( i = 0; i < ns3data; i++) {
+		kfree(s3data[i].data);
+	}
+	ns3data = 0;
+	memset(s3data, 0, sizeof(s3data));
+	ns3plug = 0;
+	memset(s3plug, 0, sizeof(s3plug));
+	ns3crc = 0;
+	memset(s3crc, 0, sizeof(s3crc));
+	ns3info = 0;
+	memset(s3info, 0, sizeof(s3info));
+	startaddr = 0;
+}
+
+
+/*----------------------------------------------------------------
+* mkimage
+*
+* Scans the currently loaded set of S records for data residing
+* in contiguous memory regions.  Each contiguous region is then
+* made into a 'chunk'.  This function assumes that we're building
+* a new chunk list.  Assumes the s3data items are in sorted order.
+*
+* Arguments:	none
+*
+* Returns:
+*	0	- success
+*	~0	- failure (probably an errno)
+----------------------------------------------------------------*/
+int mkimage(imgchunk_t *clist, unsigned int *ccnt)
+{
+	int		result = 0;
+	int		i;
+	int		j;
+	int		currchunk = 0;
+	u32		nextaddr = 0;
+	u32		s3start;
+	u32		s3end;
+	u32		cstart = 0;
+	u32		cend;
+	u32		coffset;
+
+	/* There may already be data in the chunklist */
+	*ccnt = 0;
+
+	/* Establish the location and size of each chunk */
+	for ( i = 0; i < ns3data; i++) {
+		if ( s3data[i].addr == nextaddr ) {
+			/* existing chunk, grow it */
+			clist[currchunk].len += s3data[i].len;
+			nextaddr += s3data[i].len;
+		} else {
+			/* New chunk */
+			(*ccnt)++;
+			currchunk = *ccnt - 1;
+			clist[currchunk].addr = s3data[i].addr;
+			clist[currchunk].len = s3data[i].len;
+			nextaddr = s3data[i].addr + s3data[i].len;
+			/* Expand the chunk if there is a CRC record at */
+			/* their beginning bound */
+			for ( j = 0; j < ns3crc; j++) {
+				if ( s3crc[j].dowrite &&
+				     s3crc[j].addr == clist[currchunk].addr ) {
+					clist[currchunk].addr -= 2;
+					clist[currchunk].len += 2;
+				}
+			}
+		}
+	}
+
+	/* We're currently assuming there aren't any overlapping chunks */
+	/*  if this proves false, we'll need to add code to coalesce. */
+
+	/* Allocate buffer space for chunks */
+	for ( i = 0; i < *ccnt; i++) {
+		clist[i].data = kmalloc(clist[i].len, GFP_KERNEL);
+		if  ( clist[i].data == NULL ) {
+			printk(KERN_ERR "failed to allocate image space, exitting.\n");
+			return(1);
+		}
+		memset(clist[i].data, 0, clist[i].len);
+	}
+
+
+	/* Display chunks */
+	for ( i = 0; i < *ccnt;  i++) {
+		pr_debug("chunk[%d]: addr=0x%06x len=%d\n",
+			i, clist[i].addr, clist[i].len);
+	}
+
+	/* Copy srec data to chunks */
+	for ( i = 0; i < ns3data; i++) {
+		s3start = s3data[i].addr;
+		s3end   = s3start + s3data[i].len - 1;
+		for ( j = 0; j < *ccnt; j++) {
+			cstart = clist[j].addr;
+			cend = cstart + clist[j].len - 1;
+			if ( s3start >= cstart && s3end <= cend ) {
+				break;
+			}
+		}
+		if ( ((unsigned int)j) >= (*ccnt) ) {
+			printk(KERN_ERR
+				"s3rec(a=0x%06x,l=%d), no chunk match, exiting.\n",
+				s3start, s3data[i].len);
+			return(1);
+		}
+		coffset = s3start - cstart;
+		memcpy( clist[j].data + coffset, s3data[i].data, s3data[i].len);
+	}
+
+	return result;
+}
+
+/*----------------------------------------------------------------
+* mkpdrlist
+*
+* Reads a raw PDA and builds an array of pdrec_t structures.
+*
+* Arguments:
+*	pda	buffer containing raw PDA bytes
+*	pdrec	ptr to an array of pdrec_t's.  Will be filled on exit.
+*	nrec	ptr to a variable that will contain the count of PDRs
+*
+* Returns:
+*	0	- success
+*	~0	- failure (probably an errno)
+----------------------------------------------------------------*/
+int mkpdrlist( pda_t *pda)
+{
+	int	result = 0;
+	u16	*pda16 = (u16*)pda->buf;
+	int	curroff;	/* in 'words' */
+
+	pda->nrec = 0;
+	curroff = 0;
+	while ( curroff < (HFA384x_PDA_LEN_MAX / 2) &&
+		le16_to_cpu(pda16[curroff + 1]) !=
+		HFA384x_PDR_END_OF_PDA ) {
+		pda->rec[pda->nrec] = (hfa384x_pdrec_t*)&(pda16[curroff]);
+
+		if (le16_to_cpu(pda->rec[pda->nrec]->code) ==
+				HFA384x_PDR_NICID) {
+			memcpy(&nicid, &pda->rec[pda->nrec]->data.nicid,
+			       sizeof(nicid));
+			nicid.id = le16_to_cpu(nicid.id);
+			nicid.variant = le16_to_cpu(nicid.variant);
+			nicid.major = le16_to_cpu(nicid.major);
+			nicid.minor = le16_to_cpu(nicid.minor);
+		}
+		if (le16_to_cpu(pda->rec[pda->nrec]->code) ==
+				HFA384x_PDR_MFISUPRANGE) {
+			memcpy(&rfid, &pda->rec[pda->nrec]->data.mfisuprange,
+			       sizeof(rfid));
+			rfid.id = le16_to_cpu(rfid.id);
+			rfid.variant = le16_to_cpu(rfid.variant);
+			rfid.bottom = le16_to_cpu(rfid.bottom);
+			rfid.top = le16_to_cpu(rfid.top);
+		}
+		if (le16_to_cpu(pda->rec[pda->nrec]->code) ==
+				HFA384x_PDR_CFISUPRANGE) {
+			memcpy(&macid, &pda->rec[pda->nrec]->data.cfisuprange,
+			       sizeof(macid));
+			macid.id = le16_to_cpu(macid.id);
+			macid.variant = le16_to_cpu(macid.variant);
+			macid.bottom = le16_to_cpu(macid.bottom);
+			macid.top = le16_to_cpu(macid.top);
+		}
+
+		(pda->nrec)++;
+		curroff += le16_to_cpu(pda16[curroff]) + 1;
+
+	}
+	if ( curroff >= (HFA384x_PDA_LEN_MAX / 2) ) {
+		printk(KERN_ERR
+			"no end record found or invalid lengths in "
+			"PDR data, exiting. %x %d\n", curroff, pda->nrec);
+		return(1);
+	}
+	if (le16_to_cpu(pda16[curroff + 1]) == HFA384x_PDR_END_OF_PDA ) {
+		pda->rec[pda->nrec] = (hfa384x_pdrec_t*)&(pda16[curroff]);
+		(pda->nrec)++;
+	}
+	return result;
+}
+
+
+
+/*----------------------------------------------------------------
+* plugimage
+*
+* Plugs the given image using the given plug records from the given
+* PDA and filename.
+*
+* Arguments:
+*	fchunk		Array of image chunks
+*	nfchunks	Number of image chunks
+*	s3plug		Array of plug records
+*	ns3plug		Number of plug records
+*	pda		Current pda data
+*
+* Returns:
+*	0	success
+*	~0	failure
+----------------------------------------------------------------*/
+int plugimage( imgchunk_t *fchunk, unsigned int nfchunks,
+		s3plugrec_t* s3plug, unsigned int ns3plug, pda_t *pda)
+{
+	int	result = 0;
+	int	i;	/* plug index */
+	int	j;	/* index of PDR or -1 if fname plug */
+	int	c;	/* chunk index */
+	u32	pstart;
+	u32	pend;
+	u32	cstart = 0;
+	u32	cend;
+	u32	chunkoff;
+	u8	*dest;
+
+	/* for each plug record */
+	for ( i = 0; i < ns3plug; i++) {
+		pstart = s3plug[i].addr;
+		pend = 	 s3plug[i].addr + s3plug[i].len;
+		/* find the matching PDR (or filename) */
+		if ( s3plug[i].itemcode != 0xffffffffUL ) { /* not filename */
+			for ( j = 0; j < pda->nrec; j++) {
+				if ( s3plug[i].itemcode ==
+				     le16_to_cpu(pda->rec[j]->code) ) break;
+			}
+		} else {
+			j = -1;
+		}
+		if ( j >= pda->nrec && j != -1 ) { /*  if no matching PDR, fail */
+			printk(KERN_WARNING
+				"warning: Failed to find PDR for "
+				"plugrec 0x%04x.\n",
+				s3plug[i].itemcode);
+			continue; /* and move on to the next PDR */
+#if 0
+			/* MSM: They swear that unless it's the MAC address,
+			 * the serial number, or the TX calibration records,
+			 * then there's reasonable defaults in the f/w
+			 * image.  Therefore, missing PDRs in the card
+			 * should only be a warning, not fatal.
+			 * TODO: add fatals for the PDRs mentioned above.
+			 */
+			result = 1;
+			continue;
+#endif
+		}
+
+		/* Validate plug len against PDR len */
+		if ( j != -1 &&
+		     s3plug[i].len < le16_to_cpu(pda->rec[j]->len) ) {
+			printk(KERN_ERR
+				"error: Plug vs. PDR len mismatch for "
+				"plugrec 0x%04x, abort plugging.\n",
+				s3plug[i].itemcode);
+			result = 1;
+			continue;
+		}
+
+		/* Validate plug address against chunk data and identify chunk */
+		for ( c = 0; c < nfchunks; c++) {
+			cstart = fchunk[c].addr;
+			cend =	 fchunk[c].addr + fchunk[c].len;
+			if ( pstart >= cstart && pend <= cend ) break;
+		}
+		if ( c >= nfchunks ) {
+			printk(KERN_ERR
+				"error: Failed to find image chunk for "
+				"plugrec 0x%04x.\n",
+				s3plug[i].itemcode);
+			result = 1;
+			continue;
+		}
+
+		/* Plug data */
+		chunkoff = pstart - cstart;
+		dest = fchunk[c].data + chunkoff;
+		pr_debug("Plugging item 0x%04x @ 0x%06x, len=%d, "
+			      "cnum=%d coff=0x%06x\n",
+			      s3plug[i].itemcode, pstart, s3plug[i].len,
+			      c, chunkoff);
+
+		if ( j == -1 ) { /* plug the filename */
+			memset(dest, 0, s3plug[i].len);
+			strncpy(dest, PRISM2_USB_FWFILE, s3plug[i].len - 1);
+		} else { /* plug a PDR */
+			memcpy( dest, &(pda->rec[j]->data), s3plug[i].len);
+		}
+	}
+	return result;
+
+}
+
+
+/*----------------------------------------------------------------
+* read_cardpda
+*
+* Sends the command for the driver to read the pda from the card
+* named in the device variable.  Upon success, the card pda is
+* stored in the "cardpda" variables.  Note that the pda structure
+* is considered 'well formed' after this function.  That means
+* that the nrecs is valid, the rec array has been set up, and there's
+* a valid PDAEND record in the raw PDA data.
+*
+* Arguments:
+*	pda		pda structure
+*	wlandev		device
+*
+* Returns:
+*	0	- success
+*	~0	- failure (probably an errno)
+----------------------------------------------------------------*/
+int read_cardpda(pda_t *pda, wlandevice_t *wlandev)
+{
+	int				result = 0;
+	p80211msg_p2req_readpda_t	msg;
+
+	/* set up the msg */
+	msg.msgcode = DIDmsg_p2req_readpda;
+	msg.msglen = sizeof(msg);
+	strcpy(msg.devname, wlandev->name);
+	msg.pda.did = DIDmsg_p2req_readpda_pda;
+	msg.pda.len = HFA384x_PDA_LEN_MAX;
+	msg.pda.status = P80211ENUM_msgitem_status_no_value;
+	msg.resultcode.did = DIDmsg_p2req_readpda_resultcode;
+	msg.resultcode.len = sizeof(u32);
+	msg.resultcode.status = P80211ENUM_msgitem_status_no_value;
+
+	if ( prism2mgmt_readpda(wlandev, &msg) != 0 ) {
+		/* prism2mgmt_readpda prints an errno if appropriate */
+		result = -1;
+	} else if ( msg.resultcode.data == P80211ENUM_resultcode_success ) {
+		memcpy(pda->buf, msg.pda.data, HFA384x_PDA_LEN_MAX);
+		result = mkpdrlist(pda);
+	} else {
+		/* resultcode must've been something other than success */
+		result = -1;
+	}
+
+	return result;
+}
+
+
+/*----------------------------------------------------------------
+* copy_line
+*
+* Copies a line of text, up to \n, \0, or SREC_LINE_MAX, or limit of
+* From array
+*
+* Arguments:
+*	from	From addr
+*	to	To addr
+*	limit	Addr of last character in From array that can be copied
+*
+* Returns:
+*	Num characters copied
+----------------------------------------------------------------*/
+int copyline(char *from, char *to, char *limit)
+{
+	int c = 0;
+
+	while ((c < SREC_LINE_MAX - 1) && (from + c <= limit) &&
+	       (from[c] != '\n') && (from[c] != '\0')) {
+		to[c] = from[c];
+		c++;
+	}
+
+	to[c] = '\0';
+	return (c < SREC_LINE_MAX - 1) ? c + 1 : c;
+}
+
+
+/*----------------------------------------------------------------
+* read_srecfile
+*
+* Reads the given srecord file and loads the records into the
+* s3xxx arrays.  This function can be called repeatedly (once for
+* each of a set of files), if necessary.  This function performs
+* no validation of the data except for the grossest of S-record
+* line format checks.  Don't forget that these will be DOS files...
+* CR/LF at the end of each line.
+*
+* Here's the SREC format we're dealing with:
+* S[37]nnaaaaaaaaddd...dddcc
+*
+*       nn - number of bytes starting with the address field
+* aaaaaaaa - address in readable (or big endian) format
+* dd....dd - 0-245 data bytes (two chars per byte)
+*       cc - checksum
+*
+* The S7 record's (there should be only one) address value gets
+* saved in startaddr.  It's the start execution address used
+* for RAM downloads.
+*
+* The S3 records have a collection of subformats indicated by the
+* value of aaaaaaaa:
+*   0xff000000 - Plug record, data field format:
+*                xxxxxxxxaaaaaaaassssssss
+*                x - PDR code number (little endian)
+*                a - Address in load image to plug (little endian)
+*                s - Length of plug data area (little endian)
+*
+*   0xff100000 - CRC16 generation record, data field format:
+*                aaaaaaaassssssssbbbbbbbb
+*                a - Start address for CRC calculation (little endian)
+*                s - Length of data to  calculate over (little endian)
+*                b - Boolean, true=write crc, false=don't write
+*
+*   0xff200000 - Info record, data field format:
+*                ssssttttdd..dd
+*                s - Size in words (little endian)
+*                t - Info type (little endian), see #defines and
+*                    s3inforec_t for details about types.
+*                d - (s - 1) little endian words giving the contents of
+*                    the given info type.
+*
+* Arguments:
+*	rfptr	firmware image (s-record structure) in kernel memory
+*	rfsize	firmware size in kernel memory
+*
+* Returns:
+*	0	- success
+*	~0	- failure (probably an errno)
+----------------------------------------------------------------*/
+int read_srecfile(char *rfptr, int rfsize)
+{
+	int		result = 0;
+	char		buf[SREC_LINE_MAX];
+	char		tmpbuf[30];
+	s3datarec_t	tmprec;
+	int		i, c;
+	int		line = 0;
+	u16		*tmpinfo;
+	char		*endptr = rfptr + rfsize;
+
+
+	pr_debug("Reading S-record file ...\n");
+
+	while ( (c = copyline(rfptr, buf, endptr)) >= 12 ) {
+		rfptr = rfptr + c;
+		line++;
+		if ( buf[0] != 'S' ) {
+			printk(KERN_ERR "%d warning: No initial \'S\'\n", line);
+			return 1;
+		}
+		if ( buf[1] == '7' ) {	/* S7 record, start address */
+			buf[12] = '\0';
+			startaddr = simple_strtoul(buf+4, NULL, 16);
+			pr_debug("  S7 start addr, line=%d "
+				      " addr=0x%08x\n",
+				      line,
+				      startaddr);
+			continue;
+		} else if ( buf[1] == '3') {
+			/* Ok, it's an S3, parse and put it in the right array */
+			/* Record Length field (we only want datalen) */
+			memcpy(tmpbuf, buf+S3LEN_TXTOFFSET, S3LEN_TXTLEN);
+			tmpbuf[S3LEN_TXTLEN] = '\0';
+			tmprec.len = simple_strtoul( tmpbuf, NULL, 16) - 4 - 1; /* 4=addr, 1=cksum */
+			/* Address field */
+			memcpy(tmpbuf, buf+S3ADDR_TXTOFFSET, S3ADDR_TXTLEN);
+			tmpbuf[S3ADDR_TXTLEN] = '\0';
+			tmprec.addr = simple_strtoul( tmpbuf, NULL, 16);
+			/* Checksum field */
+			tmprec.checksum = simple_strtoul( buf+strlen(buf)-2, NULL, 16);
+
+			switch(  tmprec.addr )
+			{
+			case S3ADDR_PLUG:
+				memcpy(tmpbuf, buf+S3PLUG_ITEMCODE_TXTOFFSET, S3PLUG_ITEMCODE_TXTLEN);
+				tmpbuf[S3PLUG_ITEMCODE_TXTLEN] = '\0';
+				s3plug[ns3plug].itemcode = simple_strtoul(tmpbuf,NULL,16);
+				s3plug[ns3plug].itemcode = bswap_32(s3plug[ns3plug].itemcode);
+
+				memcpy(tmpbuf, buf+S3PLUG_ADDR_TXTOFFSET, S3PLUG_ADDR_TXTLEN);
+				tmpbuf[S3PLUG_ADDR_TXTLEN] = '\0';
+				s3plug[ns3plug].addr = simple_strtoul(tmpbuf,NULL,16);
+				s3plug[ns3plug].addr = bswap_32(s3plug[ns3plug].addr);
+
+				memcpy(tmpbuf, buf+S3PLUG_LEN_TXTOFFSET, S3PLUG_LEN_TXTLEN);
+				tmpbuf[S3PLUG_LEN_TXTLEN] = '\0';
+				s3plug[ns3plug].len = simple_strtoul(tmpbuf,NULL,16);
+				s3plug[ns3plug].len = bswap_32(s3plug[ns3plug].len);
+
+				pr_debug("  S3 plugrec, line=%d "
+					      "itemcode=0x%04x addr=0x%08x len=%d\n",
+					      line,
+					      s3plug[ns3plug].itemcode,
+					      s3plug[ns3plug].addr,
+					      s3plug[ns3plug].len);
+
+				ns3plug++;
+				if ( ns3plug == S3PLUG_MAX ) {
+					printk(KERN_ERR "S3 plugrec limit reached - aborting\n");
+					return 1;
+				}
+				break;
+			case S3ADDR_CRC:
+				memcpy(tmpbuf, buf+S3CRC_ADDR_TXTOFFSET, S3CRC_ADDR_TXTLEN);
+				tmpbuf[S3CRC_ADDR_TXTLEN] = '\0';
+				s3crc[ns3crc].addr = simple_strtoul(tmpbuf,NULL,16);
+				s3crc[ns3crc].addr = bswap_32(s3crc[ns3crc].addr);
+
+				memcpy(tmpbuf, buf+S3CRC_LEN_TXTOFFSET, S3CRC_LEN_TXTLEN);
+				tmpbuf[S3CRC_LEN_TXTLEN] = '\0';
+				s3crc[ns3crc].len = simple_strtoul(tmpbuf,NULL,16);
+				s3crc[ns3crc].len = bswap_32(s3crc[ns3crc].len);
+
+				memcpy(tmpbuf, buf+S3CRC_DOWRITE_TXTOFFSET, S3CRC_DOWRITE_TXTLEN);
+				tmpbuf[S3CRC_DOWRITE_TXTLEN] = '\0';
+				s3crc[ns3crc].dowrite = simple_strtoul(tmpbuf,NULL,16);
+				s3crc[ns3crc].dowrite = bswap_32(s3crc[ns3crc].dowrite);
+
+				pr_debug("  S3 crcrec, line=%d "
+					      "addr=0x%08x len=%d write=0x%08x\n",
+					      line,
+					      s3crc[ns3crc].addr,
+					      s3crc[ns3crc].len,
+					      s3crc[ns3crc].dowrite);
+				ns3crc++;
+				if ( ns3crc == S3CRC_MAX ) {
+					printk(KERN_ERR "S3 crcrec limit reached - aborting\n");
+					return 1;
+				}
+				break;
+			case S3ADDR_INFO:
+				memcpy(tmpbuf, buf+S3INFO_LEN_TXTOFFSET, S3INFO_LEN_TXTLEN);
+				tmpbuf[S3INFO_LEN_TXTLEN] = '\0';
+				s3info[ns3info].len = simple_strtoul(tmpbuf,NULL,16);
+				s3info[ns3info].len = bswap_16(s3info[ns3info].len);
+
+				memcpy(tmpbuf, buf+S3INFO_TYPE_TXTOFFSET, S3INFO_TYPE_TXTLEN);
+				tmpbuf[S3INFO_TYPE_TXTLEN] = '\0';
+				s3info[ns3info].type = simple_strtoul(tmpbuf,NULL,16);
+				s3info[ns3info].type = bswap_16(s3info[ns3info].type);
+
+				pr_debug("  S3 inforec, line=%d "
+					      "len=0x%04x type=0x%04x\n",
+					      line,
+					      s3info[ns3info].len,
+					      s3info[ns3info].type);
+				if ( ((s3info[ns3info].len - 1) * sizeof(u16)) > sizeof(s3info[ns3info].info) ) {
+					printk(KERN_ERR " S3 inforec length too long - aborting\n");
+					return 1;
+				}
+
+				tmpinfo = (u16*)&(s3info[ns3info].info.version);
+				for (i = 0; i < s3info[ns3info].len - 1; i++) {
+					memcpy( tmpbuf, buf+S3INFO_DATA_TXTOFFSET+(i*4), 4);
+					tmpbuf[4] = '\0';
+					tmpinfo[i] = simple_strtoul(tmpbuf,NULL,16);
+					tmpinfo[i] = bswap_16(tmpinfo[i]);
+				}
+				pr_debug("            info=");
+				for (i = 0; i < s3info[ns3info].len - 1; i++) {
+					pr_debug("%04x ", tmpinfo[i]);
+				}
+				pr_debug("\n");
+
+				ns3info++;
+				if ( ns3info == S3INFO_MAX ) {
+					printk(KERN_ERR "S3 inforec limit reached - aborting\n");
+					return 1;
+				}
+				break;
+			default:	/* Data record */
+				s3data[ns3data].addr = tmprec.addr;
+				s3data[ns3data].len = tmprec.len;
+				s3data[ns3data].checksum = tmprec.checksum;
+				s3data[ns3data].data = kmalloc(tmprec.len, GFP_KERNEL);
+				for ( i = 0; i < tmprec.len; i++) {
+					memcpy(tmpbuf, buf+S3DATA_TXTOFFSET+(i*2), 2);
+					tmpbuf[2] = '\0';
+					s3data[ns3data].data[i] = simple_strtoul(tmpbuf, NULL, 16);
+				}
+				ns3data++;
+				if ( ns3data == S3DATA_MAX ) {
+					printk(KERN_ERR "S3 datarec limit reached - aborting\n");
+					return 1;
+				}
+				break;
+			}
+		} else {
+			printk(KERN_WARNING "%d warning: Unknown S-record detected.\n", line);
+		}
+	}
+	return result;
+}
+
+
+/*----------------------------------------------------------------
+* s3datarec_compare
+*
+* Comparison function for sort().
+*
+* Arguments:
+*	p1	ptr to the first item
+*	p2	ptr to the second item
+* Returns:
+*	0	items are equal
+*	<0	p1 < p2
+*	>0	p1 > p2
+----------------------------------------------------------------*/
+int s3datarec_compare(const void *p1, const void *p2)
+{
+	const s3datarec_t	*s1 = p1;
+	const s3datarec_t	*s2 = p2;
+	if ( s1->addr == s2->addr ) return 0;
+	if ( s1->addr < s2->addr ) return -1;
+	return 1;
+}
+
+
+/*----------------------------------------------------------------
+* writeimage
+*
+* Takes the chunks, builds p80211 messages and sends them down
+* to the driver for writing to the card.
+*
+* Arguments:
+*	wlandev		device
+*	fchunk		Array of image chunks
+*	nfchunks	Number of image chunks
+*
+* Returns:
+*	0	success
+*	~0	failure
+----------------------------------------------------------------*/
+int writeimage(wlandevice_t *wlandev, imgchunk_t *fchunk, unsigned int nfchunks)
+{
+	int					result = 0;
+	p80211msg_p2req_ramdl_state_t		rstatemsg;
+	p80211msg_p2req_ramdl_write_t		rwritemsg;
+	p80211msg_t				*msgp;
+	u32					resultcode;
+	int					i;
+	int					j;
+	unsigned int				nwrites;
+	u32					curroff;
+	u32					currlen;
+	u32					currdaddr;
+
+	/* Initialize the messages */
+	memset(&rstatemsg, 0, sizeof(rstatemsg));
+	strcpy(rstatemsg.devname, wlandev->name);
+	rstatemsg.msgcode =		DIDmsg_p2req_ramdl_state;
+	rstatemsg.msglen =		sizeof(rstatemsg);
+	rstatemsg.enable.did =		DIDmsg_p2req_ramdl_state_enable;
+	rstatemsg.exeaddr.did =		DIDmsg_p2req_ramdl_state_exeaddr;
+	rstatemsg.resultcode.did =	DIDmsg_p2req_ramdl_state_resultcode;
+	rstatemsg.enable.status =	P80211ENUM_msgitem_status_data_ok;
+	rstatemsg.exeaddr.status =	P80211ENUM_msgitem_status_data_ok;
+	rstatemsg.resultcode.status =	P80211ENUM_msgitem_status_no_value;
+	rstatemsg.enable.len =		sizeof(u32);
+	rstatemsg.exeaddr.len =		sizeof(u32);
+	rstatemsg.resultcode.len =	sizeof(u32);
+
+	memset(&rwritemsg, 0, sizeof(rwritemsg));
+	strcpy(rwritemsg.devname, wlandev->name);
+	rwritemsg.msgcode =		DIDmsg_p2req_ramdl_write;
+	rwritemsg.msglen =		sizeof(rwritemsg);
+	rwritemsg.addr.did =		DIDmsg_p2req_ramdl_write_addr;
+	rwritemsg.len.did =		DIDmsg_p2req_ramdl_write_len;
+	rwritemsg.data.did =		DIDmsg_p2req_ramdl_write_data;
+	rwritemsg.resultcode.did =	DIDmsg_p2req_ramdl_write_resultcode;
+	rwritemsg.addr.status =		P80211ENUM_msgitem_status_data_ok;
+	rwritemsg.len.status =		P80211ENUM_msgitem_status_data_ok;
+	rwritemsg.data.status =		P80211ENUM_msgitem_status_data_ok;
+	rwritemsg.resultcode.status =	P80211ENUM_msgitem_status_no_value;
+	rwritemsg.addr.len =		sizeof(u32);
+	rwritemsg.len.len =		sizeof(u32);
+	rwritemsg.data.len =		WRITESIZE_MAX;
+	rwritemsg.resultcode.len =	sizeof(u32);
+
+	/* Send xxx_state(enable) */
+	pr_debug("Sending dl_state(enable) message.\n");
+	rstatemsg.enable.data = P80211ENUM_truth_true;
+	rstatemsg.exeaddr.data = startaddr;
+
+	msgp = (p80211msg_t*)&rstatemsg;
+	result = prism2mgmt_ramdl_state(wlandev, msgp);
+	if ( result ) {
+		printk(KERN_ERR
+			"writeimage state enable failed w/ result=%d, "
+			"aborting download\n", result);
+		return result;
+	}
+	resultcode = rstatemsg.resultcode.data;
+	if ( resultcode != P80211ENUM_resultcode_success ) {
+		printk(KERN_ERR
+			"writeimage()->xxxdl_state msg indicates failure, "
+			"w/ resultcode=%d, aborting download.\n",
+			resultcode);
+		return 1;
+	}
+
+	/* Now, loop through the data chunks and send WRITESIZE_MAX data */
+	for ( i = 0; i < nfchunks; i++) {
+		nwrites = fchunk[i].len / WRITESIZE_MAX;
+		nwrites += (fchunk[i].len % WRITESIZE_MAX) ? 1 : 0;
+		curroff = 0;
+		for ( j = 0; j < nwrites; j++) {
+			currlen =
+			  (fchunk[i].len - (WRITESIZE_MAX * j)) > WRITESIZE_MAX ?
+			  WRITESIZE_MAX :
+			  (fchunk[i].len - (WRITESIZE_MAX * j));
+			curroff = j * WRITESIZE_MAX;
+			currdaddr = fchunk[i].addr + curroff;
+			/* Setup the message */
+			rwritemsg.addr.data = currdaddr;
+			rwritemsg.len.data = currlen;
+			memcpy(rwritemsg.data.data,
+				fchunk[i].data + curroff,
+				currlen);
+
+			/* Send flashdl_write(pda) */
+			pr_debug("Sending xxxdl_write message addr=%06x len=%d.\n",
+				      currdaddr, currlen);
+
+			msgp = (p80211msg_t*)&rwritemsg;
+			result = prism2mgmt_ramdl_write(wlandev, msgp);
+
+			/* Check the results */
+			if ( result ) {
+				printk(KERN_ERR
+					"writeimage chunk write failed w/ result=%d, "
+					"aborting download\n", result);
+				return result;
+			}
+			resultcode = rstatemsg.resultcode.data;
+			if ( resultcode != P80211ENUM_resultcode_success ) {
+				printk(KERN_ERR
+					"writeimage()->xxxdl_write msg indicates failure, "
+					"w/ resultcode=%d, aborting download.\n",
+					resultcode);
+				return 1;
+			}
+
+		}
+	}
+
+	/* Send xxx_state(disable) */
+	pr_debug("Sending dl_state(disable) message.\n");
+	rstatemsg.enable.data = P80211ENUM_truth_false;
+	rstatemsg.exeaddr.data = 0;
+
+	msgp = (p80211msg_t*)&rstatemsg;
+	result = prism2mgmt_ramdl_state(wlandev, msgp);
+	if ( result ) {
+		printk(KERN_ERR
+			"writeimage state disable failed w/ result=%d, "
+			"aborting download\n", result);
+		return result;
+	}
+	resultcode = rstatemsg.resultcode.data;
+	if ( resultcode != P80211ENUM_resultcode_success ) {
+		printk(KERN_ERR
+			"writeimage()->xxxdl_state msg indicates failure, "
+			"w/ resultcode=%d, aborting download.\n",
+			resultcode);
+		return 1;
+	}
+	return result;
+}
+
+
+
+int validate_identity(void)
+{
+	int i;
+	int result = 1;
+
+	pr_debug("NIC ID: %#x v%d.%d.%d\n",
+	       nicid.id,
+	       nicid.major,
+	       nicid.minor,
+	       nicid.variant);
+	pr_debug("MFI ID: %#x v%d %d->%d\n",
+	       rfid.id,
+	       rfid.variant,
+	       rfid.bottom,
+	       rfid.top);
+	pr_debug("CFI ID: %#x v%d %d->%d\n",
+	       macid.id,
+	       macid.variant,
+	       macid.bottom,
+	       macid.top);
+	pr_debug("PRI ID: %#x v%d %d->%d\n",
+	       priid.id,
+	       priid.variant,
+	       priid.bottom,
+	       priid.top);
+
+	for (i = 0 ; i < ns3info ; i ++) {
+		switch (s3info[i].type) {
+		case 1:
+			pr_debug("Version:  ID %#x %d.%d.%d\n",
+			       s3info[i].info.version.id,
+			       s3info[i].info.version.major,
+				       s3info[i].info.version.minor,
+			       s3info[i].info.version.variant);
+			break;
+		case 2:
+			pr_debug("Compat: Role %#x Id %#x v%d %d->%d\n",
+			       s3info[i].info.compat.role,
+			       s3info[i].info.compat.id,
+			       s3info[i].info.compat.variant,
+			       s3info[i].info.compat.bottom,
+			       s3info[i].info.compat.top);
+
+			/* MAC compat range */
+			if ((s3info[i].info.compat.role == 1) &&
+			    (s3info[i].info.compat.id == 2)) {
+				if (s3info[i].info.compat.variant !=
+				    macid.variant) {
+					result = 2;
+				}
+			}
+
+			/* PRI compat range */
+			if ((s3info[i].info.compat.role == 1) &&
+			    (s3info[i].info.compat.id == 3)) {
+				if ((s3info[i].info.compat.bottom > priid.top) ||
+				    (s3info[i].info.compat.top < priid.bottom)){
+					result = 3;
+				}
+			}
+			/* SEC compat range */
+			if ((s3info[i].info.compat.role == 1) &&
+			    (s3info[i].info.compat.id == 4)) {
+
+			}
+
+			break;
+		case 3:
+				pr_debug("Seq: %#x\n", s3info[i].info.buildseq);
+
+				break;
+		case 4:
+			pr_debug("Platform:  ID %#x %d.%d.%d\n",
+			       s3info[i].info.version.id,
+			       s3info[i].info.version.major,
+			       s3info[i].info.version.minor,
+			       s3info[i].info.version.variant);
+
+			if (nicid.id != s3info[i].info.version.id)
+				continue;
+			if (nicid.major != s3info[i].info.version.major)
+				continue;
+			if (nicid.minor != s3info[i].info.version.minor)
+				continue;
+			if ((nicid.variant != s3info[i].info.version.variant) &&
+			    (nicid.id != 0x8008))
+				continue;
+
+			if (result != 2)
+				result = 0;
+			break;
+		case 0x8001:
+			pr_debug("name inforec len %d\n", s3info[i].len);
+
+			break;
+		default:
+			pr_debug("Unknown inforec type %d\n", s3info[i].type);
+		}
+	}
+	// walk through
+
+	return result;
+}
