commit 2bc51572aa6ce39cb2e21b73e5278bb7cd98762b
Author: Maya Nakamura <m.maya.nakamura@gmail.com>
Date:   Thu Oct 18 01:29:42 2018 -0700

    staging: wlan-ng: Replace long int with long
    
    Replace long int with long as int is unnecessary according to the
    checkpatch.pl warning. K&R write, 'The word int can be omitted... and
    typically is.'
    
    Signed-off-by: Maya Nakamura <m.maya.nakamura@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/p80211conv.c b/drivers/staging/wlan-ng/p80211conv.c
index 91debcf20646..0ff5fda81b05 100644
--- a/drivers/staging/wlan-ng/p80211conv.c
+++ b/drivers/staging/wlan-ng/p80211conv.c
@@ -430,7 +430,7 @@ int skb_p80211_to_ether(struct wlandevice *wlandev, u32 ethconv,
 			/* A bogus length ethfrm has been sent. */
 			/* Is someone trying an oflow attack? */
 			netdev_err(netdev, "DIXII frame too large (%ld > %d)\n",
-				   (long int)(payload_length -
+				   (long)(payload_length -
 				   sizeof(struct wlan_llc) -
 				   sizeof(struct wlan_snap)), netdev->mtu);
 			return 1;

commit 173ffd0993fd3e6ec7e0e24424350a807605e6d0
Author: Tim Collier <osdevtc@gmail.com>
Date:   Wed May 23 08:30:25 2018 +0100

    staging: wlan-ng: convert P80211SKB_RXMETA to inline function in p80211conv
    
    To avoid possible issues with repeated reference to the macro argument
    as reported by checkpatch, macro P80211SKB_RXMETA is replaced with an
    equivalent inline function. The function is named p80211skb_rxmeta to
    follow the coding style guidelines; references to the macro are
    updated to reference the new function.
    
    This change depends on the similar change for P80211SKB_FRMMETA having
    been applied.
    
    Signed-off-by: Tim Collier <osdevtc@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/p80211conv.c b/drivers/staging/wlan-ng/p80211conv.c
index 646e9c205c52..91debcf20646 100644
--- a/drivers/staging/wlan-ng/p80211conv.c
+++ b/drivers/staging/wlan-ng/p80211conv.c
@@ -497,7 +497,7 @@ int skb_p80211_to_ether(struct wlandevice *wlandev, u32 ethconv,
 	/* jkriegl: only process signal/noise if requested by iwspy */
 	if (wlandev->spy_number)
 		orinoco_spy_gather(wlandev, eth_hdr(skb)->h_source,
-				   P80211SKB_RXMETA(skb));
+				   p80211skb_rxmeta(skb));
 
 	/* Free the metadata */
 	p80211skb_rxmeta_detach(skb);
@@ -605,7 +605,7 @@ int p80211skb_rxmeta_attach(struct wlandevice *wlandev, struct sk_buff *skb)
 	struct p80211_frmmeta *frmmeta;
 
 	/* If these already have metadata, we error out! */
-	if (P80211SKB_RXMETA(skb)) {
+	if (p80211skb_rxmeta(skb)) {
 		netdev_err(wlandev->netdev,
 			   "%s: RXmeta already attached!\n", wlandev->name);
 		result = 0;

commit df6835d1f66a27f753f93b017a5a022dbdd0d372
Author: Tim Collier <osdevtc@gmail.com>
Date:   Wed May 23 08:30:24 2018 +0100

    staging: wlan-ng: convert P80211SKB_FRMMETA to inline function in p80211conv
    
    To avoid possible issues with repeated reference to the macro argument
    as reported by checkpatch, macro P80211SKB_FRMMETA is replaced with an
    equivalent inline function. The function is named p80211skb_frmmeta to
    follow the coding style guidelines; references to the macro are
    updated to reference the new function.
    
    Signed-off-by: Tim Collier <osdevtc@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/p80211conv.c b/drivers/staging/wlan-ng/p80211conv.c
index 855b424f6423..646e9c205c52 100644
--- a/drivers/staging/wlan-ng/p80211conv.c
+++ b/drivers/staging/wlan-ng/p80211conv.c
@@ -563,7 +563,7 @@ void p80211skb_rxmeta_detach(struct sk_buff *skb)
 		pr_debug("Called w/ null skb.\n");
 		return;
 	}
-	frmmeta = P80211SKB_FRMMETA(skb);
+	frmmeta = p80211skb_frmmeta(skb);
 	if (!frmmeta) {	/* no magic */
 		pr_debug("Called w/ bad frmmeta magic.\n");
 		return;
@@ -654,7 +654,7 @@ void p80211skb_free(struct wlandevice *wlandev, struct sk_buff *skb)
 {
 	struct p80211_frmmeta *meta;
 
-	meta = P80211SKB_FRMMETA(skb);
+	meta = p80211skb_frmmeta(skb);
 	if (meta && meta->rx)
 		p80211skb_rxmeta_detach(skb);
 	else

commit f7056d335d919c15dc9ae26923969673da846e37
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Nov 7 21:07:51 2017 +0100

    staging: wlan-ng: add SPDX identifiers to all wlan-ng driver files
    
    It's good to have SPDX identifiers in all files to make it easier to
    audit the kernel tree for correct licenses.
    
    Update the wlan-ng driver files with the correct SPDX license identifier
    based on the license text in the file itself.  The SPDX identifier is a
    legally binding shorthand, which can be used instead of the full boiler
    plate text.
    
    This work is based on a script and data from Thomas Gleixner, Philippe
    Ombredanne, and Kate Stewart.
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: Philippe Ombredanne <pombredanne@nexb.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/p80211conv.c b/drivers/staging/wlan-ng/p80211conv.c
index c1b6d426bcad..855b424f6423 100644
--- a/drivers/staging/wlan-ng/p80211conv.c
+++ b/drivers/staging/wlan-ng/p80211conv.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: (GPL-2.0 OR MPL-1.1)
 /* src/p80211/p80211conv.c
  *
  * Ether/802.11 conversions and packet buffer routines

commit b5956dd26f848086af7413d8d089b4ab41ab341d
Author: Lynn Lei <lynnl.yet@gmail.com>
Date:   Tue Aug 8 23:05:59 2017 +0800

    drivers/staging/wlan-ng/p80211conv.c: fixed a potential memory leak
    
    Fixed a potential memory leak inside skb_ether_to_p80211()
            When the wep_encrypt() fails  the code return 2 directly
            Which causes the p80211_wep->data dangling
    
    Add a kfree statement to reclaim that memory allocated
    
    Signed-off-by: Lynn Lei <lynnl.yet@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/p80211conv.c b/drivers/staging/wlan-ng/p80211conv.c
index fc8ad33ade9f..c1b6d426bcad 100644
--- a/drivers/staging/wlan-ng/p80211conv.c
+++ b/drivers/staging/wlan-ng/p80211conv.c
@@ -213,6 +213,7 @@ int skb_ether_to_p80211(struct wlandevice *wlandev, u32 ethconv,
 			netdev_warn(wlandev->netdev,
 				    "Host en-WEP failed, dropping frame (%d).\n",
 				    foo);
+			kfree(p80211_wep->data);
 			return 2;
 		}
 		fc |= cpu_to_le16(WLAN_SET_FC_ISWEP(1));

commit d58ff35122847a83ba55394e2ae3a1527b6febf5
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Fri Jun 16 14:29:23 2017 +0200

    networking: make skb_push & __skb_push return void pointers
    
    It seems like a historic accident that these return unsigned char *,
    and in many places that means casts are required, more often than not.
    
    Make these functions return void * and remove all the casts across
    the tree, adding a (u8 *) cast only where the unsigned char pointer
    was used directly, all done with the following spatch:
    
        @@
        expression SKB, LEN;
        typedef u8;
        identifier fn = { skb_push, __skb_push, skb_push_rcsum };
        @@
        - *(fn(SKB, LEN))
        + *(u8 *)fn(SKB, LEN)
    
        @@
        expression E, SKB, LEN;
        identifier fn = { skb_push, __skb_push, skb_push_rcsum };
        type T;
        @@
        - E = ((T *)(fn(SKB, LEN)))
        + E = fn(SKB, LEN)
    
        @@
        expression SKB, LEN;
        identifier fn = { skb_push, __skb_push, skb_push_rcsum };
        @@
        - fn(SKB, LEN)[0]
        + *(u8 *)fn(SKB, LEN)
    
    Note that the last part there converts from push(...)[0] to the
    more idiomatic *(u8 *)push(...).
    
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/staging/wlan-ng/p80211conv.c b/drivers/staging/wlan-ng/p80211conv.c
index a062e80361ef..fc8ad33ade9f 100644
--- a/drivers/staging/wlan-ng/p80211conv.c
+++ b/drivers/staging/wlan-ng/p80211conv.c
@@ -148,9 +148,7 @@ int skb_ether_to_p80211(struct wlandevice *wlandev, u32 ethconv,
 			skb_pull(skb, ETH_HLEN);
 
 			/* tack on SNAP */
-			e_snap =
-			    (struct wlan_snap *)skb_push(skb,
-				sizeof(struct wlan_snap));
+			e_snap = skb_push(skb, sizeof(struct wlan_snap));
 			e_snap->type = htons(proto);
 			if (ethconv == WLAN_ETHCONV_8021h &&
 			    p80211_stt_findproto(proto)) {
@@ -162,9 +160,7 @@ int skb_ether_to_p80211(struct wlandevice *wlandev, u32 ethconv,
 			}
 
 			/* tack on llc */
-			e_llc =
-			    (struct wlan_llc *)skb_push(skb,
-				sizeof(struct wlan_llc));
+			e_llc = skb_push(skb, sizeof(struct wlan_llc));
 			e_llc->dsap = 0xAA;	/* SNAP, see IEEE 802 */
 			e_llc->ssap = 0xAA;
 			e_llc->ctl = 0x03;
@@ -407,7 +403,7 @@ int skb_p80211_to_ether(struct wlandevice *wlandev, u32 ethconv,
 		skb_pull(skb, payload_offset);
 
 		/* create 802.3 header at beginning of skb. */
-		e_hdr = (struct wlan_ethhdr *)skb_push(skb, ETH_HLEN);
+		e_hdr = skb_push(skb, ETH_HLEN);
 		ether_addr_copy(e_hdr->daddr, daddr);
 		ether_addr_copy(e_hdr->saddr, saddr);
 		e_hdr->type = htons(payload_length);
@@ -448,7 +444,7 @@ int skb_p80211_to_ether(struct wlandevice *wlandev, u32 ethconv,
 		skb_pull(skb, sizeof(struct wlan_snap));
 
 		/* create 802.3 header at beginning of skb. */
-		e_hdr = (struct wlan_ethhdr *)skb_push(skb, ETH_HLEN);
+		e_hdr = skb_push(skb, ETH_HLEN);
 		e_hdr->type = e_snap->type;
 		ether_addr_copy(e_hdr->daddr, daddr);
 		ether_addr_copy(e_hdr->saddr, saddr);
@@ -475,7 +471,7 @@ int skb_p80211_to_ether(struct wlandevice *wlandev, u32 ethconv,
 		skb_pull(skb, payload_offset);
 
 		/* create 802.3 header at beginning of skb. */
-		e_hdr = (struct wlan_ethhdr *)skb_push(skb, ETH_HLEN);
+		e_hdr = skb_push(skb, ETH_HLEN);
 		ether_addr_copy(e_hdr->daddr, daddr);
 		ether_addr_copy(e_hdr->saddr, saddr);
 		e_hdr->type = htons(payload_length);

commit 8954ef903fa5f86a42580bcf80cb0116ab2b3c02
Author: Gargi Sharma <gs051095@gmail.com>
Date:   Sat Feb 18 11:07:41 2017 +0530

    staging: wlan-ng: remove extra parentheses
    
    Removes extra parentheses around function arguments. Issue
    detected and resolved using the following coccinelle script:
    
    @@
    expression e;
    identifier f;
    @@
    
    f(...,
    -(
    e
    -)
    ,...)
    
    Signed-off-by: Gargi Sharma <gs051095@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/p80211conv.c b/drivers/staging/wlan-ng/p80211conv.c
index 8b0905e7c9be..a062e80361ef 100644
--- a/drivers/staging/wlan-ng/p80211conv.c
+++ b/drivers/staging/wlan-ng/p80211conv.c
@@ -211,7 +211,7 @@ int skb_ether_to_p80211(struct wlandevice *wlandev, u32 ethconv,
 			return -ENOMEM;
 		foo = wep_encrypt(wlandev, skb->data, p80211_wep->data,
 				  skb->len,
-				  (wlandev->hostwep & HOSTWEP_DEFAULTKEY_MASK),
+				  wlandev->hostwep & HOSTWEP_DEFAULTKEY_MASK,
 				  p80211_wep->iv, p80211_wep->icv);
 		if (foo) {
 			netdev_warn(wlandev->netdev,

commit 606ea2bd81d0290dbea2c84c976dee3dd39c3427
Author: Alexander Alemayhu <alexander@alemayhu.com>
Date:   Sat Feb 11 11:13:47 2017 +0100

    staging: wlan-ng: reduce type warnings
    
    Fixes the following sparse output:
    
    drivers/staging/wlan-ng/p80211conv.c:132:25: warning: cast to restricted __be16
    drivers/staging/wlan-ng/p80211conv.c:132:25: warning: cast to restricted __be16
    drivers/staging/wlan-ng/p80211conv.c:132:25: warning: cast to restricted __be16
    drivers/staging/wlan-ng/p80211conv.c:132:25: warning: cast to restricted __be16
    drivers/staging/wlan-ng/p80211conv.c:154:38: warning: incorrect type in assignment (different base types)
    drivers/staging/wlan-ng/p80211conv.c:154:38:    expected unsigned short [unsigned] [usertype] type
    drivers/staging/wlan-ng/p80211conv.c:154:38:    got restricted __be16 [usertype] <noident>
    drivers/staging/wlan-ng/p80211conv.c:390:42: warning: cast to restricted __le16
    drivers/staging/wlan-ng/p80211conv.c:413:29: warning: incorrect type in assignment (different base types)
    drivers/staging/wlan-ng/p80211conv.c:413:29:    expected unsigned short [unsigned] [usertype] type
    drivers/staging/wlan-ng/p80211conv.c:413:29:    got restricted __be16 [usertype] <noident>
    drivers/staging/wlan-ng/p80211conv.c:481:29: warning: incorrect type in assignment (different base types)
    drivers/staging/wlan-ng/p80211conv.c:481:29:    expected unsigned short [unsigned] [usertype] type
    drivers/staging/wlan-ng/p80211conv.c:481:29:    got restricted __be16 [usertype] <noident>
    
    Signed-off-by: Alexander Alemayhu <alexander@alemayhu.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/p80211conv.c b/drivers/staging/wlan-ng/p80211conv.c
index 8387e6a3031a..8b0905e7c9be 100644
--- a/drivers/staging/wlan-ng/p80211conv.c
+++ b/drivers/staging/wlan-ng/p80211conv.c
@@ -387,7 +387,7 @@ int skb_p80211_to_ether(struct wlandevice *wlandev, u32 ethconv,
 		   (((memcmp(e_snap->oui, oui_rfc1042,
 		   WLAN_IEEE_OUI_LEN) == 0) &&
 		   (ethconv == WLAN_ETHCONV_8021h) &&
-		   (p80211_stt_findproto(le16_to_cpu(e_snap->type)))) ||
+		   (p80211_stt_findproto(be16_to_cpu(e_snap->type)))) ||
 		   (memcmp(e_snap->oui, oui_rfc1042, WLAN_IEEE_OUI_LEN) !=
 			0))) {
 		pr_debug("SNAP+RFC1042 len: %d\n", payload_length);

commit 0904f84a218e34823b3cfd3b8b0f5e8c5af714d3
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Mon Nov 7 18:55:19 2016 +0100

    staging: wlan-ng: remove unnecessary out of memory message in p80211conv.c
    
    This patch fix the following checkpatch script warning:
    WARNING: Possible unnecessary 'out of memory' message.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/p80211conv.c b/drivers/staging/wlan-ng/p80211conv.c
index 5080d42245bb..8387e6a3031a 100644
--- a/drivers/staging/wlan-ng/p80211conv.c
+++ b/drivers/staging/wlan-ng/p80211conv.c
@@ -618,8 +618,6 @@ int p80211skb_rxmeta_attach(struct wlandevice *wlandev, struct sk_buff *skb)
 	rxmeta = kzalloc(sizeof(*rxmeta), GFP_ATOMIC);
 
 	if (!rxmeta) {
-		netdev_err(wlandev->netdev,
-			   "%s: Failed to allocate rxmeta.\n", wlandev->name);
 		result = 1;
 		goto exit;
 	}

commit 229dbdc577cf6cf0f0589739b403aa5ef125f8e2
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Mon Oct 10 16:02:20 2016 +0200

    staging: wlan-ng: Replace data type declaration with variable of same type in p80211conv.c
    
    sizeof(*var) instead of sizeof(struct XXX) is preferred.
    Fix it in p80211conv.c file.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/p80211conv.c b/drivers/staging/wlan-ng/p80211conv.c
index 5c0e65863205..5080d42245bb 100644
--- a/drivers/staging/wlan-ng/p80211conv.c
+++ b/drivers/staging/wlan-ng/p80211conv.c
@@ -615,7 +615,7 @@ int p80211skb_rxmeta_attach(struct wlandevice *wlandev, struct sk_buff *skb)
 	}
 
 	/* Allocate the rxmeta */
-	rxmeta = kzalloc(sizeof(struct p80211_rxmeta), GFP_ATOMIC);
+	rxmeta = kzalloc(sizeof(*rxmeta), GFP_ATOMIC);
 
 	if (!rxmeta) {
 		netdev_err(wlandev->netdev,

commit b1a57426d0b5d9caa2c5edcc77b24f5d6d7addd9
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Sun Oct 9 17:10:20 2016 +0200

    staging: wlan-ng: fix block comment warnings in p80211conv.c
    
    This patch fix the following checkpatch.pl warnings in p80211conv.c:
    WARNING: Block comments should align the * on each line
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/p80211conv.c b/drivers/staging/wlan-ng/p80211conv.c
index 0247cbc29145..5c0e65863205 100644
--- a/drivers/staging/wlan-ng/p80211conv.c
+++ b/drivers/staging/wlan-ng/p80211conv.c
@@ -1,56 +1,56 @@
 /* src/p80211/p80211conv.c
-*
-* Ether/802.11 conversions and packet buffer routines
-*
-* Copyright (C) 1999 AbsoluteValue Systems, Inc.  All Rights Reserved.
-* --------------------------------------------------------------------
-*
-* linux-wlan
-*
-*   The contents of this file are subject to the Mozilla Public
-*   License Version 1.1 (the "License"); you may not use this file
-*   except in compliance with the License. You may obtain a copy of
-*   the License at http://www.mozilla.org/MPL/
-*
-*   Software distributed under the License is distributed on an "AS
-*   IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
-*   implied. See the License for the specific language governing
-*   rights and limitations under the License.
-*
-*   Alternatively, the contents of this file may be used under the
-*   terms of the GNU Public License version 2 (the "GPL"), in which
-*   case the provisions of the GPL are applicable instead of the
-*   above.  If you wish to allow the use of your version of this file
-*   only under the terms of the GPL and not to allow others to use
-*   your version of this file under the MPL, indicate your decision
-*   by deleting the provisions above and replace them with the notice
-*   and other provisions required by the GPL.  If you do not delete
-*   the provisions above, a recipient may use your version of this
-*   file under either the MPL or the GPL.
-*
-* --------------------------------------------------------------------
-*
-* Inquiries regarding the linux-wlan Open Source project can be
-* made directly to:
-*
-* AbsoluteValue Systems Inc.
-* info@linux-wlan.com
-* http://www.linux-wlan.com
-*
-* --------------------------------------------------------------------
-*
-* Portions of the development of this software were funded by
-* Intersil Corporation as part of PRISM(R) chipset product development.
-*
-* --------------------------------------------------------------------
-*
-* This file defines the functions that perform Ethernet to/from
-* 802.11 frame conversions.
-*
-* --------------------------------------------------------------------
-*
-*================================================================
-*/
+ *
+ * Ether/802.11 conversions and packet buffer routines
+ *
+ * Copyright (C) 1999 AbsoluteValue Systems, Inc.  All Rights Reserved.
+ * --------------------------------------------------------------------
+ *
+ * linux-wlan
+ *
+ *   The contents of this file are subject to the Mozilla Public
+ *   License Version 1.1 (the "License"); you may not use this file
+ *   except in compliance with the License. You may obtain a copy of
+ *   the License at http://www.mozilla.org/MPL/
+ *
+ *   Software distributed under the License is distributed on an "AS
+ *   IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ *   implied. See the License for the specific language governing
+ *   rights and limitations under the License.
+ *
+ *   Alternatively, the contents of this file may be used under the
+ *   terms of the GNU Public License version 2 (the "GPL"), in which
+ *   case the provisions of the GPL are applicable instead of the
+ *   above.  If you wish to allow the use of your version of this file
+ *   only under the terms of the GPL and not to allow others to use
+ *   your version of this file under the MPL, indicate your decision
+ *   by deleting the provisions above and replace them with the notice
+ *   and other provisions required by the GPL.  If you do not delete
+ *   the provisions above, a recipient may use your version of this
+ *   file under either the MPL or the GPL.
+ *
+ * --------------------------------------------------------------------
+ *
+ * Inquiries regarding the linux-wlan Open Source project can be
+ * made directly to:
+ *
+ * AbsoluteValue Systems Inc.
+ * info@linux-wlan.com
+ * http://www.linux-wlan.com
+ *
+ * --------------------------------------------------------------------
+ *
+ * Portions of the development of this software were funded by
+ * Intersil Corporation as part of PRISM(R) chipset product development.
+ *
+ * --------------------------------------------------------------------
+ *
+ * This file defines the functions that perform Ethernet to/from
+ * 802.11 frame conversions.
+ *
+ * --------------------------------------------------------------------
+ *
+ *================================================================
+ */
 
 #include <linux/module.h>
 #include <linux/kernel.h>
@@ -79,31 +79,31 @@ static const u8 oui_rfc1042[] = { 0x00, 0x00, 0x00 };
 static const u8 oui_8021h[] = { 0x00, 0x00, 0xf8 };
 
 /*----------------------------------------------------------------
-* p80211pb_ether_to_80211
-*
-* Uses the contents of the ether frame and the etherconv setting
-* to build the elements of the 802.11 frame.
-*
-* We don't actually set
-* up the frame header here.  That's the MAC's job.  We're only handling
-* conversion of DIXII or 802.3+LLC frames to something that works
-* with 802.11.
-*
-* Note -- 802.11 header is NOT part of the skb.  Likewise, the 802.11
-*         FCS is also not present and will need to be added elsewhere.
-*
-* Arguments:
-*	ethconv		Conversion type to perform
-*	skb		skbuff containing the ether frame
-*       p80211_hdr      802.11 header
-*
-* Returns:
-*	0 on success, non-zero otherwise
-*
-* Call context:
-*	May be called in interrupt or non-interrupt context
-*----------------------------------------------------------------
-*/
+ * p80211pb_ether_to_80211
+ *
+ * Uses the contents of the ether frame and the etherconv setting
+ * to build the elements of the 802.11 frame.
+ *
+ * We don't actually set
+ * up the frame header here.  That's the MAC's job.  We're only handling
+ * conversion of DIXII or 802.3+LLC frames to something that works
+ * with 802.11.
+ *
+ * Note -- 802.11 header is NOT part of the skb.  Likewise, the 802.11
+ *         FCS is also not present and will need to be added elsewhere.
+ *
+ * Arguments:
+ *	ethconv		Conversion type to perform
+ *	skb		skbuff containing the ether frame
+ *       p80211_hdr      802.11 header
+ *
+ * Returns:
+ *	0 on success, non-zero otherwise
+ *
+ * Call context:
+ *	May be called in interrupt or non-interrupt context
+ *----------------------------------------------------------------
+ */
 int skb_ether_to_p80211(struct wlandevice *wlandev, u32 ethconv,
 			struct sk_buff *skb, union p80211_hdr *p80211_hdr,
 			struct p80211_metawep *p80211_wep)
@@ -255,25 +255,25 @@ static void orinoco_spy_gather(struct wlandevice *wlandev, char *mac,
 }
 
 /*----------------------------------------------------------------
-* p80211pb_80211_to_ether
-*
-* Uses the contents of a received 802.11 frame and the etherconv
-* setting to build an ether frame.
-*
-* This function extracts the src and dest address from the 802.11
-* frame to use in the construction of the eth frame.
-*
-* Arguments:
-*	ethconv		Conversion type to perform
-*	skb		Packet buffer containing the 802.11 frame
-*
-* Returns:
-*	0 on success, non-zero otherwise
-*
-* Call context:
-*	May be called in interrupt or non-interrupt context
-*----------------------------------------------------------------
-*/
+ * p80211pb_80211_to_ether
+ *
+ * Uses the contents of a received 802.11 frame and the etherconv
+ * setting to build an ether frame.
+ *
+ * This function extracts the src and dest address from the 802.11
+ * frame to use in the construction of the eth frame.
+ *
+ * Arguments:
+ *	ethconv		Conversion type to perform
+ *	skb		Packet buffer containing the 802.11 frame
+ *
+ * Returns:
+ *	0 on success, non-zero otherwise
+ *
+ * Call context:
+ *	May be called in interrupt or non-interrupt context
+ *----------------------------------------------------------------
+ */
 int skb_p80211_to_ether(struct wlandevice *wlandev, u32 ethconv,
 			struct sk_buff *skb)
 {
@@ -508,22 +508,22 @@ int skb_p80211_to_ether(struct wlandevice *wlandev, u32 ethconv,
 }
 
 /*----------------------------------------------------------------
-* p80211_stt_findproto
-*
-* Searches the 802.1h Selective Translation Table for a given
-* protocol.
-*
-* Arguments:
-*	proto	protocol number (in host order) to search for.
-*
-* Returns:
-*	1 - if the table is empty or a match is found.
-*	0 - if the table is non-empty and a match is not found.
-*
-* Call context:
-*	May be called in interrupt or non-interrupt context
-*----------------------------------------------------------------
-*/
+ * p80211_stt_findproto
+ *
+ * Searches the 802.1h Selective Translation Table for a given
+ * protocol.
+ *
+ * Arguments:
+ *	proto	protocol number (in host order) to search for.
+ *
+ * Returns:
+ *	1 - if the table is empty or a match is found.
+ *	0 - if the table is non-empty and a match is not found.
+ *
+ * Call context:
+ *	May be called in interrupt or non-interrupt context
+ *----------------------------------------------------------------
+ */
 int p80211_stt_findproto(u16 proto)
 {
 	/* Always return found for now.  This is the behavior used by the */
@@ -540,21 +540,21 @@ int p80211_stt_findproto(u16 proto)
 }
 
 /*----------------------------------------------------------------
-* p80211skb_rxmeta_detach
-*
-* Disconnects the frmmeta and rxmeta from an skb.
-*
-* Arguments:
-*	wlandev		The wlandev this skb belongs to.
-*	skb		The skb we're attaching to.
-*
-* Returns:
-*	0 on success, non-zero otherwise
-*
-* Call context:
-*	May be called in interrupt or non-interrupt context
-*----------------------------------------------------------------
-*/
+ * p80211skb_rxmeta_detach
+ *
+ * Disconnects the frmmeta and rxmeta from an skb.
+ *
+ * Arguments:
+ *	wlandev		The wlandev this skb belongs to.
+ *	skb		The skb we're attaching to.
+ *
+ * Returns:
+ *	0 on success, non-zero otherwise
+ *
+ * Call context:
+ *	May be called in interrupt or non-interrupt context
+ *----------------------------------------------------------------
+ */
 void p80211skb_rxmeta_detach(struct sk_buff *skb)
 {
 	struct p80211_rxmeta *rxmeta;
@@ -584,22 +584,22 @@ void p80211skb_rxmeta_detach(struct sk_buff *skb)
 }
 
 /*----------------------------------------------------------------
-* p80211skb_rxmeta_attach
-*
-* Allocates a p80211rxmeta structure, initializes it, and attaches
-* it to an skb.
-*
-* Arguments:
-*	wlandev		The wlandev this skb belongs to.
-*	skb		The skb we're attaching to.
-*
-* Returns:
-*	0 on success, non-zero otherwise
-*
-* Call context:
-*	May be called in interrupt or non-interrupt context
-*----------------------------------------------------------------
-*/
+ * p80211skb_rxmeta_attach
+ *
+ * Allocates a p80211rxmeta structure, initializes it, and attaches
+ * it to an skb.
+ *
+ * Arguments:
+ *	wlandev		The wlandev this skb belongs to.
+ *	skb		The skb we're attaching to.
+ *
+ * Returns:
+ *	0 on success, non-zero otherwise
+ *
+ * Call context:
+ *	May be called in interrupt or non-interrupt context
+ *----------------------------------------------------------------
+ */
 int p80211skb_rxmeta_attach(struct wlandevice *wlandev, struct sk_buff *skb)
 {
 	int result = 0;
@@ -638,22 +638,22 @@ int p80211skb_rxmeta_attach(struct wlandevice *wlandev, struct sk_buff *skb)
 }
 
 /*----------------------------------------------------------------
-* p80211skb_free
-*
-* Frees an entire p80211skb by checking and freeing the meta struct
-* and then freeing the skb.
-*
-* Arguments:
-*	wlandev		The wlandev this skb belongs to.
-*	skb		The skb we're attaching to.
-*
-* Returns:
-*	0 on success, non-zero otherwise
-*
-* Call context:
-*	May be called in interrupt or non-interrupt context
-*----------------------------------------------------------------
-*/
+ * p80211skb_free
+ *
+ * Frees an entire p80211skb by checking and freeing the meta struct
+ * and then freeing the skb.
+ *
+ * Arguments:
+ *	wlandev		The wlandev this skb belongs to.
+ *	skb		The skb we're attaching to.
+ *
+ * Returns:
+ *	0 on success, non-zero otherwise
+ *
+ * Call context:
+ *	May be called in interrupt or non-interrupt context
+ *----------------------------------------------------------------
+ */
 void p80211skb_free(struct wlandevice *wlandev, struct sk_buff *skb)
 {
 	struct p80211_frmmeta *meta;

commit 19066982a7ae7ca9570d3271451ba3adc616019e
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Tue Sep 27 19:33:51 2016 +0200

    staging: wlan-ng: avoid new typedef: netdevice_t
    
    This patch fixes the following checkpatch.pl warning in p80211netdev.h:
    WARNING: do not add new typedefs
    
    It applies for typedef netdevice_t
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/p80211conv.c b/drivers/staging/wlan-ng/p80211conv.c
index efc52e90578d..0247cbc29145 100644
--- a/drivers/staging/wlan-ng/p80211conv.c
+++ b/drivers/staging/wlan-ng/p80211conv.c
@@ -277,7 +277,7 @@ static void orinoco_spy_gather(struct wlandevice *wlandev, char *mac,
 int skb_p80211_to_ether(struct wlandevice *wlandev, u32 ethconv,
 			struct sk_buff *skb)
 {
-	netdevice_t *netdev = wlandev->netdev;
+	struct net_device *netdev = wlandev->netdev;
 	u16 fc;
 	unsigned int payload_length;
 	unsigned int payload_offset;

commit c9573a8d1963ba82f163c4d113266da82c048c21
Author: sayli karnik <karniksayli1995@gmail.com>
Date:   Sun Sep 18 15:11:14 2016 +0530

    staging: wlan-ng: Remove the typedef to the 'wlandevice' structure
    
    This patch removes the typedef 'wlandevice_t' to the 'wlandevice'
    structure.
    
    Signed-off-by: sayli karnik <karniksayli1995@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/p80211conv.c b/drivers/staging/wlan-ng/p80211conv.c
index 6354036ffb42..efc52e90578d 100644
--- a/drivers/staging/wlan-ng/p80211conv.c
+++ b/drivers/staging/wlan-ng/p80211conv.c
@@ -104,7 +104,7 @@ static const u8 oui_8021h[] = { 0x00, 0x00, 0xf8 };
 *	May be called in interrupt or non-interrupt context
 *----------------------------------------------------------------
 */
-int skb_ether_to_p80211(wlandevice_t *wlandev, u32 ethconv,
+int skb_ether_to_p80211(struct wlandevice *wlandev, u32 ethconv,
 			struct sk_buff *skb, union p80211_hdr *p80211_hdr,
 			struct p80211_metawep *p80211_wep)
 {
@@ -232,7 +232,7 @@ int skb_ether_to_p80211(wlandevice_t *wlandev, u32 ethconv,
 }
 
 /* jkriegl: from orinoco, modified */
-static void orinoco_spy_gather(wlandevice_t *wlandev, char *mac,
+static void orinoco_spy_gather(struct wlandevice *wlandev, char *mac,
 			       struct p80211_rxmeta *rxmeta)
 {
 	int i;
@@ -274,7 +274,7 @@ static void orinoco_spy_gather(wlandevice_t *wlandev, char *mac,
 *	May be called in interrupt or non-interrupt context
 *----------------------------------------------------------------
 */
-int skb_p80211_to_ether(wlandevice_t *wlandev, u32 ethconv,
+int skb_p80211_to_ether(struct wlandevice *wlandev, u32 ethconv,
 			struct sk_buff *skb)
 {
 	netdevice_t *netdev = wlandev->netdev;

commit 7a4000e7128d9432ba78bc398bbedc6066825b80
Author: Claudiu Beznea <claudiu.beznea@gmail.com>
Date:   Fri Mar 25 22:54:48 2016 +0200

    Staging: wlan-ng: no need for memcpy() since its arguments are already equal
    
    This patch removes the memcpy() for two variables which were
    previously tested with memcmp(). The result of memcmp() was
    zero which means that the previously tested variables were
    already equal.
    
    Signed-off-by: Claudiu Beznea <claudiu.beznea@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/p80211conv.c b/drivers/staging/wlan-ng/p80211conv.c
index bdb50a51483b..6354036ffb42 100644
--- a/drivers/staging/wlan-ng/p80211conv.c
+++ b/drivers/staging/wlan-ng/p80211conv.c
@@ -243,7 +243,6 @@ static void orinoco_spy_gather(wlandevice_t *wlandev, char *mac,
 
 	for (i = 0; i < wlandev->spy_number; i++) {
 		if (!memcmp(wlandev->spy_address[i], mac, ETH_ALEN)) {
-			memcpy(wlandev->spy_address[i], mac, ETH_ALEN);
 			wlandev->spy_stat[i].level = rxmeta->signal;
 			wlandev->spy_stat[i].noise = rxmeta->noise;
 			wlandev->spy_stat[i].qual =

commit 78822dc3c371ba7a909de72525ee176f78ea236c
Author: Claudiu Beznea <claudiu.beznea@gmail.com>
Date:   Mon Mar 14 22:45:13 2016 +0200

    Staging: wlan-ng: defined oui_rfc1042[] and oui_8021h[] arrays as const arrays
    
    This patch defines oui_rfc1042[] and oui_8021h[] arrays from
    p80211conv.c as const arrays since these are not changed
    anywhere in code.
    
    Signed-off-by: Claudiu Beznea <claudiu.beznea@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/p80211conv.c b/drivers/staging/wlan-ng/p80211conv.c
index 0a8f3960d465..bdb50a51483b 100644
--- a/drivers/staging/wlan-ng/p80211conv.c
+++ b/drivers/staging/wlan-ng/p80211conv.c
@@ -75,8 +75,8 @@
 #include "p80211ioctl.h"
 #include "p80211req.h"
 
-static u8 oui_rfc1042[] = { 0x00, 0x00, 0x00 };
-static u8 oui_8021h[] = { 0x00, 0x00, 0xf8 };
+static const u8 oui_rfc1042[] = { 0x00, 0x00, 0x00 };
+static const u8 oui_8021h[] = { 0x00, 0x00, 0xf8 };
 
 /*----------------------------------------------------------------
 * p80211pb_ether_to_80211

commit d23054350d0fafdc4a6f8d68b18cd70ec581c95d
Author: Pranjal Bhor <bhor.pranjal@gmail.com>
Date:   Tue Jan 19 01:05:13 2016 +0530

    staging: wlan-ng: NULL comparisons made elegant
    
    Elegance added for NULL comparisons
    
    Signed-off-by: Pranjal Bhor <bhor.pranjal@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/p80211conv.c b/drivers/staging/wlan-ng/p80211conv.c
index 81f0f06eb597..0a8f3960d465 100644
--- a/drivers/staging/wlan-ng/p80211conv.c
+++ b/drivers/staging/wlan-ng/p80211conv.c
@@ -562,17 +562,17 @@ void p80211skb_rxmeta_detach(struct sk_buff *skb)
 	struct p80211_frmmeta *frmmeta;
 
 	/* Sanity checks */
-	if (skb == NULL) {	/* bad skb */
+	if (!skb) {	/* bad skb */
 		pr_debug("Called w/ null skb.\n");
 		return;
 	}
 	frmmeta = P80211SKB_FRMMETA(skb);
-	if (frmmeta == NULL) {	/* no magic */
+	if (!frmmeta) {	/* no magic */
 		pr_debug("Called w/ bad frmmeta magic.\n");
 		return;
 	}
 	rxmeta = frmmeta->rx;
-	if (rxmeta == NULL) {	/* bad meta ptr */
+	if (!rxmeta) {	/* bad meta ptr */
 		pr_debug("Called w/ bad rxmeta ptr.\n");
 		return;
 	}
@@ -608,7 +608,7 @@ int p80211skb_rxmeta_attach(struct wlandevice *wlandev, struct sk_buff *skb)
 	struct p80211_frmmeta *frmmeta;
 
 	/* If these already have metadata, we error out! */
-	if (P80211SKB_RXMETA(skb) != NULL) {
+	if (P80211SKB_RXMETA(skb)) {
 		netdev_err(wlandev->netdev,
 			   "%s: RXmeta already attached!\n", wlandev->name);
 		result = 0;
@@ -618,7 +618,7 @@ int p80211skb_rxmeta_attach(struct wlandevice *wlandev, struct sk_buff *skb)
 	/* Allocate the rxmeta */
 	rxmeta = kzalloc(sizeof(struct p80211_rxmeta), GFP_ATOMIC);
 
-	if (rxmeta == NULL) {
+	if (!rxmeta) {
 		netdev_err(wlandev->netdev,
 			   "%s: Failed to allocate rxmeta.\n", wlandev->name);
 		result = 1;

commit 64ddba5275c397e34899a1d77e2ca0ee8e169e4b
Author: Pranjal Bhor <bhor.pranjal@gmail.com>
Date:   Tue Jan 19 01:04:56 2016 +0530

    staging: wlan-ng: Open parenthesis alignment style fix
    
    Alignment of lines matched with open parenthesis
    
    Signed-off-by: Pranjal Bhor <bhor.pranjal@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/p80211conv.c b/drivers/staging/wlan-ng/p80211conv.c
index c4fd5b211cd7..81f0f06eb597 100644
--- a/drivers/staging/wlan-ng/p80211conv.c
+++ b/drivers/staging/wlan-ng/p80211conv.c
@@ -215,8 +215,8 @@ int skb_ether_to_p80211(wlandevice_t *wlandev, u32 ethconv,
 				  p80211_wep->iv, p80211_wep->icv);
 		if (foo) {
 			netdev_warn(wlandev->netdev,
-			       "Host en-WEP failed, dropping frame (%d).\n",
-			       foo);
+				    "Host en-WEP failed, dropping frame (%d).\n",
+				    foo);
 			return 2;
 		}
 		fc |= cpu_to_le16(WLAN_SET_FC_ISWEP(1));
@@ -330,10 +330,10 @@ int skb_p80211_to_ether(wlandevice_t *wlandev, u32 ethconv,
 			return 1;
 		}
 		foo = wep_decrypt(wlandev, skb->data + payload_offset + 4,
-				       payload_length - 8, -1,
-				       skb->data + payload_offset,
-				       skb->data + payload_offset +
-				       payload_length - 4);
+				  payload_length - 8, -1,
+				  skb->data + payload_offset,
+				  skb->data + payload_offset +
+				  payload_length - 4);
 		if (foo) {
 			/* de-wep failed, drop skb. */
 			pr_debug("Host de-WEP failed, dropping frame (%d).\n",
@@ -371,7 +371,7 @@ int skb_p80211_to_ether(wlandevice_t *wlandev, u32 ethconv,
 			/* A bogus length ethfrm has been encap'd. */
 			/* Is someone trying an oflow attack? */
 			netdev_err(netdev, "ENCAP frame too large (%d > %d)\n",
-			       payload_length, netdev->mtu + ETH_HLEN);
+				   payload_length, netdev->mtu + ETH_HLEN);
 			return 1;
 		}
 
@@ -400,7 +400,7 @@ int skb_p80211_to_ether(wlandevice_t *wlandev, u32 ethconv,
 			/* A bogus length ethfrm has been sent. */
 			/* Is someone trying an oflow attack? */
 			netdev_err(netdev, "SNAP frame too large (%d > %d)\n",
-			       payload_length, netdev->mtu);
+				   payload_length, netdev->mtu);
 			return 1;
 		}
 
@@ -433,9 +433,9 @@ int skb_p80211_to_ether(wlandevice_t *wlandev, u32 ethconv,
 			/* A bogus length ethfrm has been sent. */
 			/* Is someone trying an oflow attack? */
 			netdev_err(netdev, "DIXII frame too large (%ld > %d)\n",
-			       (long int)(payload_length -
-					sizeof(struct wlan_llc) -
-					sizeof(struct wlan_snap)), netdev->mtu);
+				   (long int)(payload_length -
+				   sizeof(struct wlan_llc) -
+				   sizeof(struct wlan_snap)), netdev->mtu);
 			return 1;
 		}
 
@@ -468,7 +468,7 @@ int skb_p80211_to_ether(wlandevice_t *wlandev, u32 ethconv,
 			/* A bogus length ethfrm has been sent. */
 			/* Is someone trying an oflow attack? */
 			netdev_err(netdev, "OTHER frame too large (%d > %d)\n",
-			       payload_length, netdev->mtu);
+				   payload_length, netdev->mtu);
 			return 1;
 		}
 

commit 40defde4a4025cd7aae3afcb54c0b9588d96cb8d
Author: Pranjal Bhor <bhor.pranjal@gmail.com>
Date:   Tue Jan 19 01:04:41 2016 +0530

    staging: wlan-ng: Coding style fix for casting operation
    
    Removed spaces after casting operating
    
    Signed-off-by: Pranjal Bhor <bhor.pranjal@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/p80211conv.c b/drivers/staging/wlan-ng/p80211conv.c
index 00d82e25c250..c4fd5b211cd7 100644
--- a/drivers/staging/wlan-ng/p80211conv.c
+++ b/drivers/staging/wlan-ng/p80211conv.c
@@ -149,7 +149,7 @@ int skb_ether_to_p80211(wlandevice_t *wlandev, u32 ethconv,
 
 			/* tack on SNAP */
 			e_snap =
-			    (struct wlan_snap *) skb_push(skb,
+			    (struct wlan_snap *)skb_push(skb,
 				sizeof(struct wlan_snap));
 			e_snap->type = htons(proto);
 			if (ethconv == WLAN_ETHCONV_8021h &&
@@ -163,7 +163,7 @@ int skb_ether_to_p80211(wlandevice_t *wlandev, u32 ethconv,
 
 			/* tack on llc */
 			e_llc =
-			    (struct wlan_llc *) skb_push(skb,
+			    (struct wlan_llc *)skb_push(skb,
 				sizeof(struct wlan_llc));
 			e_llc->dsap = 0xAA;	/* SNAP, see IEEE 802 */
 			e_llc->ssap = 0xAA;
@@ -294,7 +294,7 @@ int skb_p80211_to_ether(wlandevice_t *wlandev, u32 ethconv,
 	payload_length = skb->len - WLAN_HDR_A3_LEN - WLAN_CRC_LEN;
 	payload_offset = WLAN_HDR_A3_LEN;
 
-	w_hdr = (union p80211_hdr *) skb->data;
+	w_hdr = (union p80211_hdr *)skb->data;
 
 	/* setup some vars for convenience */
 	fc = le16_to_cpu(w_hdr->a3.fc);
@@ -352,11 +352,11 @@ int skb_p80211_to_ether(wlandevice_t *wlandev, u32 ethconv,
 		wlandev->rx.decrypt++;
 	}
 
-	e_hdr = (struct wlan_ethhdr *) (skb->data + payload_offset);
+	e_hdr = (struct wlan_ethhdr *)(skb->data + payload_offset);
 
-	e_llc = (struct wlan_llc *) (skb->data + payload_offset);
+	e_llc = (struct wlan_llc *)(skb->data + payload_offset);
 	e_snap =
-	    (struct wlan_snap *) (skb->data + payload_offset +
+	    (struct wlan_snap *)(skb->data + payload_offset +
 		sizeof(struct wlan_llc));
 
 	/* Test for the various encodings */
@@ -631,7 +631,7 @@ int p80211skb_rxmeta_attach(struct wlandevice *wlandev, struct sk_buff *skb)
 
 	/* Overlay a frmmeta_t onto skb->cb */
 	memset(skb->cb, 0, sizeof(struct p80211_frmmeta));
-	frmmeta = (struct p80211_frmmeta *) (skb->cb);
+	frmmeta = (struct p80211_frmmeta *)(skb->cb);
 	frmmeta->magic = P80211_FRMMETA_MAGIC;
 	frmmeta->rx = rxmeta;
 exit:

commit 3c3424d2484d1fe5856d29189424893926cf7d23
Author: Pranjal Bhor <bhor.pranjal@gmail.com>
Date:   Tue Jan 19 01:04:25 2016 +0530

    staging: wlan-ng: Removed blank lines after braces
    
    Blank lines before closing braces and after opening braces
    have been removed.
    
    Signed-off-by: Pranjal Bhor <bhor.pranjal@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/p80211conv.c b/drivers/staging/wlan-ng/p80211conv.c
index 81f36241be03..00d82e25c250 100644
--- a/drivers/staging/wlan-ng/p80211conv.c
+++ b/drivers/staging/wlan-ng/p80211conv.c
@@ -108,7 +108,6 @@ int skb_ether_to_p80211(wlandevice_t *wlandev, u32 ethconv,
 			struct sk_buff *skb, union p80211_hdr *p80211_hdr,
 			struct p80211_metawep *p80211_wep)
 {
-
 	__le16 fc;
 	u16 proto;
 	struct wlan_ethhdr e_hdr;
@@ -169,7 +168,6 @@ int skb_ether_to_p80211(wlandevice_t *wlandev, u32 ethconv,
 			e_llc->dsap = 0xAA;	/* SNAP, see IEEE 802 */
 			e_llc->ssap = 0xAA;
 			e_llc->ctl = 0x03;
-
 		}
 	}
 
@@ -244,7 +242,6 @@ static void orinoco_spy_gather(wlandevice_t *wlandev, char *mac,
 	 */
 
 	for (i = 0; i < wlandev->spy_number; i++) {
-
 		if (!memcmp(wlandev->spy_address[i], mac, ETH_ALEN)) {
 			memcpy(wlandev->spy_address[i], mac, ETH_ALEN);
 			wlandev->spy_stat[i].level = rxmeta->signal;
@@ -486,7 +483,6 @@ int skb_p80211_to_ether(wlandevice_t *wlandev, u32 ethconv,
 
 		/* chop off the 802.11 CRC */
 		skb_trim(skb, skb->len - WLAN_CRC_LEN);
-
 	}
 
 	/*

commit 2584538807926344e713548e5210bded8ed22011
Author: Pranjal Bhor <bhor.pranjal@gmail.com>
Date:   Tue Jan 19 01:04:09 2016 +0530

    staging: wlan-ng: Logical continuation fixes
    
    Logical continuation coding style issues fixed while
    condition checking
    
    Signed-off-by: Pranjal Bhor <bhor.pranjal@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/p80211conv.c b/drivers/staging/wlan-ng/p80211conv.c
index 3121e1dcf793..81f36241be03 100644
--- a/drivers/staging/wlan-ng/p80211conv.c
+++ b/drivers/staging/wlan-ng/p80211conv.c
@@ -153,8 +153,8 @@ int skb_ether_to_p80211(wlandevice_t *wlandev, u32 ethconv,
 			    (struct wlan_snap *) skb_push(skb,
 				sizeof(struct wlan_snap));
 			e_snap->type = htons(proto);
-			if (ethconv == WLAN_ETHCONV_8021h
-			    && p80211_stt_findproto(proto)) {
+			if (ethconv == WLAN_ETHCONV_8021h &&
+			    p80211_stt_findproto(proto)) {
 				memcpy(e_snap->oui, oui_8021h,
 				       WLAN_IEEE_OUI_LEN);
 			} else {
@@ -204,8 +204,8 @@ int skb_ether_to_p80211(wlandevice_t *wlandev, u32 ethconv,
 
 	p80211_wep->data = NULL;
 
-	if ((wlandev->hostwep & HOSTWEP_PRIVACYINVOKED)
-	    && (wlandev->hostwep & HOSTWEP_ENCRYPT)) {
+	if ((wlandev->hostwep & HOSTWEP_PRIVACYINVOKED) &&
+	    (wlandev->hostwep & HOSTWEP_ENCRYPT)) {
 		/* XXXX need to pick keynum other than default? */
 
 		p80211_wep->data = kmalloc(skb->len, GFP_ATOMIC);
@@ -304,12 +304,12 @@ int skb_p80211_to_ether(wlandevice_t *wlandev, u32 ethconv,
 	if ((WLAN_GET_FC_TODS(fc) == 0) && (WLAN_GET_FC_FROMDS(fc) == 0)) {
 		ether_addr_copy(daddr, w_hdr->a3.a1);
 		ether_addr_copy(saddr, w_hdr->a3.a2);
-	} else if ((WLAN_GET_FC_TODS(fc) == 0)
-			&& (WLAN_GET_FC_FROMDS(fc) == 1)) {
+	} else if ((WLAN_GET_FC_TODS(fc) == 0) &&
+		   (WLAN_GET_FC_FROMDS(fc) == 1)) {
 		ether_addr_copy(daddr, w_hdr->a3.a1);
 		ether_addr_copy(saddr, w_hdr->a3.a3);
-	} else if ((WLAN_GET_FC_TODS(fc) == 1)
-			&& (WLAN_GET_FC_FROMDS(fc) == 0)) {
+	} else if ((WLAN_GET_FC_TODS(fc) == 1) &&
+		   (WLAN_GET_FC_FROMDS(fc) == 0)) {
 		ether_addr_copy(daddr, w_hdr->a3.a3);
 		ether_addr_copy(saddr, w_hdr->a3.a2);
 	} else {
@@ -324,8 +324,9 @@ int skb_p80211_to_ether(wlandevice_t *wlandev, u32 ethconv,
 	}
 
 	/* perform de-wep if necessary.. */
-	if ((wlandev->hostwep & HOSTWEP_PRIVACYINVOKED) && WLAN_GET_FC_ISWEP(fc)
-	    && (wlandev->hostwep & HOSTWEP_DECRYPT)) {
+	if ((wlandev->hostwep & HOSTWEP_PRIVACYINVOKED) &&
+	    WLAN_GET_FC_ISWEP(fc) &&
+	    (wlandev->hostwep & HOSTWEP_DECRYPT)) {
 		if (payload_length <= 8) {
 			netdev_err(netdev,
 				   "WEP frame too short (%u).\n", skb->len);
@@ -383,15 +384,15 @@ int skb_p80211_to_ether(wlandevice_t *wlandev, u32 ethconv,
 		skb_trim(skb, skb->len - WLAN_CRC_LEN);
 
 	} else if ((payload_length >= sizeof(struct wlan_llc) +
-		sizeof(struct wlan_snap))
-		&& (e_llc->dsap == 0xaa)
-		&& (e_llc->ssap == 0xaa)
-		&& (e_llc->ctl == 0x03)
-		   &&
-		   (((memcmp(e_snap->oui, oui_rfc1042, WLAN_IEEE_OUI_LEN) == 0)
-		     && (ethconv == WLAN_ETHCONV_8021h)
-		     && (p80211_stt_findproto(le16_to_cpu(e_snap->type))))
-		    || (memcmp(e_snap->oui, oui_rfc1042, WLAN_IEEE_OUI_LEN) !=
+		sizeof(struct wlan_snap)) &&
+		(e_llc->dsap == 0xaa) &&
+		(e_llc->ssap == 0xaa) &&
+		(e_llc->ctl == 0x03) &&
+		   (((memcmp(e_snap->oui, oui_rfc1042,
+		   WLAN_IEEE_OUI_LEN) == 0) &&
+		   (ethconv == WLAN_ETHCONV_8021h) &&
+		   (p80211_stt_findproto(le16_to_cpu(e_snap->type)))) ||
+		   (memcmp(e_snap->oui, oui_rfc1042, WLAN_IEEE_OUI_LEN) !=
 			0))) {
 		pr_debug("SNAP+RFC1042 len: %d\n", payload_length);
 		/* it's a SNAP + RFC1042 frame && protocol is in STT */
@@ -419,10 +420,10 @@ int skb_p80211_to_ether(wlandevice_t *wlandev, u32 ethconv,
 		skb_trim(skb, skb->len - WLAN_CRC_LEN);
 
 	} else if ((payload_length >= sizeof(struct wlan_llc) +
-		sizeof(struct wlan_snap))
-		&& (e_llc->dsap == 0xaa)
-		&& (e_llc->ssap == 0xaa)
-		&& (e_llc->ctl == 0x03)) {
+		sizeof(struct wlan_snap)) &&
+		(e_llc->dsap == 0xaa) &&
+		(e_llc->ssap == 0xaa) &&
+		(e_llc->ctl == 0x03)) {
 		pr_debug("802.1h/RFC1042 len: %d\n", payload_length);
 		/* it's an 802.1h frame || (an RFC1042 && protocol not in STT)
 		 * build a DIXII + RFC894

commit 4a55218e0ffb65826f57121e9f0abae72f6c3e52
Author: Pranjal Bhor <bhor.pranjal@gmail.com>
Date:   Tue Jan 19 01:03:49 2016 +0530

    staging: wlan-ng: Fixed block comments coding style issue
    
    All block comment lines now begin with "*" and end with "*/"
    on a new line.
    
    Signed-off-by: Pranjal Bhor <bhor.pranjal@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/p80211conv.c b/drivers/staging/wlan-ng/p80211conv.c
index 1b02cdf9d1fa..3121e1dcf793 100644
--- a/drivers/staging/wlan-ng/p80211conv.c
+++ b/drivers/staging/wlan-ng/p80211conv.c
@@ -49,7 +49,8 @@
 *
 * --------------------------------------------------------------------
 *
-*================================================================ */
+*================================================================
+*/
 
 #include <linux/module.h>
 #include <linux/kernel.h>
@@ -101,7 +102,8 @@ static u8 oui_8021h[] = { 0x00, 0x00, 0xf8 };
 *
 * Call context:
 *	May be called in interrupt or non-interrupt context
-----------------------------------------------------------------*/
+*----------------------------------------------------------------
+*/
 int skb_ether_to_p80211(wlandevice_t *wlandev, u32 ethconv,
 			struct sk_buff *skb, union p80211_hdr *p80211_hdr,
 			struct p80211_metawep *p80211_wep)
@@ -238,7 +240,8 @@ static void orinoco_spy_gather(wlandevice_t *wlandev, char *mac,
 	int i;
 
 	/* Gather wireless spy statistics: for each packet, compare the
-	 * source address with out list, and if match, get the stats... */
+	 * source address with out list, and if match, get the stats...
+	 */
 
 	for (i = 0; i < wlandev->spy_number; i++) {
 
@@ -273,7 +276,8 @@ static void orinoco_spy_gather(wlandevice_t *wlandev, char *mac,
 *
 * Call context:
 *	May be called in interrupt or non-interrupt context
-----------------------------------------------------------------*/
+*----------------------------------------------------------------
+*/
 int skb_p80211_to_ether(wlandevice_t *wlandev, u32 ethconv,
 			struct sk_buff *skb)
 {
@@ -421,7 +425,8 @@ int skb_p80211_to_ether(wlandevice_t *wlandev, u32 ethconv,
 		&& (e_llc->ctl == 0x03)) {
 		pr_debug("802.1h/RFC1042 len: %d\n", payload_length);
 		/* it's an 802.1h frame || (an RFC1042 && protocol not in STT)
-		   build a DIXII + RFC894 */
+		 * build a DIXII + RFC894
+		 */
 
 		/* Test for an overlength frame */
 		if ((payload_length - sizeof(struct wlan_llc) -
@@ -521,14 +526,15 @@ int skb_p80211_to_ether(wlandevice_t *wlandev, u32 ethconv,
 *
 * Call context:
 *	May be called in interrupt or non-interrupt context
-----------------------------------------------------------------*/
+*----------------------------------------------------------------
+*/
 int p80211_stt_findproto(u16 proto)
 {
 	/* Always return found for now.  This is the behavior used by the */
-	/*  Zoom Win95 driver when 802.1h mode is selected */
+	/* Zoom Win95 driver when 802.1h mode is selected */
 	/* TODO: If necessary, add an actual search we'll probably
-	   need this to match the CMAC's way of doing things.
-	   Need to do some testing to confirm.
+	 * need this to match the CMAC's way of doing things.
+	 * Need to do some testing to confirm.
 	 */
 
 	if (proto == ETH_P_AARP)	/* APPLETALK */
@@ -551,7 +557,8 @@ int p80211_stt_findproto(u16 proto)
 *
 * Call context:
 *	May be called in interrupt or non-interrupt context
-----------------------------------------------------------------*/
+*----------------------------------------------------------------
+*/
 void p80211skb_rxmeta_detach(struct sk_buff *skb)
 {
 	struct p80211_rxmeta *rxmeta;
@@ -595,7 +602,8 @@ void p80211skb_rxmeta_detach(struct sk_buff *skb)
 *
 * Call context:
 *	May be called in interrupt or non-interrupt context
-----------------------------------------------------------------*/
+*----------------------------------------------------------------
+*/
 int p80211skb_rxmeta_attach(struct wlandevice *wlandev, struct sk_buff *skb)
 {
 	int result = 0;
@@ -648,7 +656,8 @@ int p80211skb_rxmeta_attach(struct wlandevice *wlandev, struct sk_buff *skb)
 *
 * Call context:
 *	May be called in interrupt or non-interrupt context
-----------------------------------------------------------------*/
+*----------------------------------------------------------------
+*/
 void p80211skb_free(struct wlandevice *wlandev, struct sk_buff *skb)
 {
 	struct p80211_frmmeta *meta;

commit 242850f48a96ce0bf48e81fa20850792f27fd3ba
Author: Anish Bhatt <anish7@gmail.com>
Date:   Fri Sep 4 14:00:30 2015 -0700

    staging/wlan-ng : Remove duplicated defines from p80211
    
    ETH_ALEN/ETH_HLEN can be  used instead of
    WLAN_ETHADDR_LEN & WLAN_ETHHDR_LEN, replace directly or
    use eth_addr* functions where applicable.
    
    Signed-off-by: Anish Bhatt <anish@chelsio.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/p80211conv.c b/drivers/staging/wlan-ng/p80211conv.c
index 49f2ef88929d..1b02cdf9d1fa 100644
--- a/drivers/staging/wlan-ng/p80211conv.c
+++ b/drivers/staging/wlan-ng/p80211conv.c
@@ -135,7 +135,7 @@ int skb_ether_to_p80211(wlandevice_t *wlandev, u32 ethconv,
 			/* it's 802.3, pass ether payload unchanged,  */
 
 			/* trim off ethernet header */
-			skb_pull(skb, WLAN_ETHHDR_LEN);
+			skb_pull(skb, ETH_HLEN);
 
 			/*   leave off any PAD octets.  */
 			skb_trim(skb, proto);
@@ -144,7 +144,7 @@ int skb_ether_to_p80211(wlandevice_t *wlandev, u32 ethconv,
 			/* it's DIXII, time for some conversion */
 
 			/* trim off ethernet header */
-			skb_pull(skb, WLAN_ETHHDR_LEN);
+			skb_pull(skb, ETH_HLEN);
 
 			/* tack on SNAP */
 			e_snap =
@@ -281,8 +281,8 @@ int skb_p80211_to_ether(wlandevice_t *wlandev, u32 ethconv,
 	u16 fc;
 	unsigned int payload_length;
 	unsigned int payload_offset;
-	u8 daddr[WLAN_ETHADDR_LEN];
-	u8 saddr[WLAN_ETHADDR_LEN];
+	u8 daddr[ETH_ALEN];
+	u8 saddr[ETH_ALEN];
 	union p80211_hdr *w_hdr;
 	struct wlan_ethhdr *e_hdr;
 	struct wlan_llc *e_llc;
@@ -298,16 +298,16 @@ int skb_p80211_to_ether(wlandevice_t *wlandev, u32 ethconv,
 	/* setup some vars for convenience */
 	fc = le16_to_cpu(w_hdr->a3.fc);
 	if ((WLAN_GET_FC_TODS(fc) == 0) && (WLAN_GET_FC_FROMDS(fc) == 0)) {
-		memcpy(daddr, w_hdr->a3.a1, WLAN_ETHADDR_LEN);
-		memcpy(saddr, w_hdr->a3.a2, WLAN_ETHADDR_LEN);
+		ether_addr_copy(daddr, w_hdr->a3.a1);
+		ether_addr_copy(saddr, w_hdr->a3.a2);
 	} else if ((WLAN_GET_FC_TODS(fc) == 0)
 			&& (WLAN_GET_FC_FROMDS(fc) == 1)) {
-		memcpy(daddr, w_hdr->a3.a1, WLAN_ETHADDR_LEN);
-		memcpy(saddr, w_hdr->a3.a3, WLAN_ETHADDR_LEN);
+		ether_addr_copy(daddr, w_hdr->a3.a1);
+		ether_addr_copy(saddr, w_hdr->a3.a3);
 	} else if ((WLAN_GET_FC_TODS(fc) == 1)
 			&& (WLAN_GET_FC_FROMDS(fc) == 0)) {
-		memcpy(daddr, w_hdr->a3.a3, WLAN_ETHADDR_LEN);
-		memcpy(saddr, w_hdr->a3.a2, WLAN_ETHADDR_LEN);
+		ether_addr_copy(daddr, w_hdr->a3.a3);
+		ether_addr_copy(saddr, w_hdr->a3.a2);
 	} else {
 		payload_offset = WLAN_HDR_A4_LEN;
 		if (payload_length < WLAN_HDR_A4_LEN - WLAN_HDR_A3_LEN) {
@@ -315,8 +315,8 @@ int skb_p80211_to_ether(wlandevice_t *wlandev, u32 ethconv,
 			return 1;
 		}
 		payload_length -= (WLAN_HDR_A4_LEN - WLAN_HDR_A3_LEN);
-		memcpy(daddr, w_hdr->a4.a3, WLAN_ETHADDR_LEN);
-		memcpy(saddr, w_hdr->a4.a4, WLAN_ETHADDR_LEN);
+		ether_addr_copy(daddr, w_hdr->a4.a3);
+		ether_addr_copy(saddr, w_hdr->a4.a4);
 	}
 
 	/* perform de-wep if necessary.. */
@@ -360,16 +360,16 @@ int skb_p80211_to_ether(wlandevice_t *wlandev, u32 ethconv,
 	/* Test for the various encodings */
 	if ((payload_length >= sizeof(struct wlan_ethhdr)) &&
 	    (e_llc->dsap != 0xaa || e_llc->ssap != 0xaa) &&
-	    ((memcmp(daddr, e_hdr->daddr, WLAN_ETHADDR_LEN) == 0) ||
-	     (memcmp(saddr, e_hdr->saddr, WLAN_ETHADDR_LEN) == 0))) {
+	    ((!ether_addr_equal_unaligned(daddr, e_hdr->daddr)) ||
+	     (!ether_addr_equal_unaligned(saddr, e_hdr->saddr)))) {
 		pr_debug("802.3 ENCAP len: %d\n", payload_length);
 		/* 802.3 Encapsulated */
 		/* Test for an overlength frame */
-		if (payload_length > (netdev->mtu + WLAN_ETHHDR_LEN)) {
+		if (payload_length > (netdev->mtu + ETH_HLEN)) {
 			/* A bogus length ethfrm has been encap'd. */
 			/* Is someone trying an oflow attack? */
 			netdev_err(netdev, "ENCAP frame too large (%d > %d)\n",
-			       payload_length, netdev->mtu + WLAN_ETHHDR_LEN);
+			       payload_length, netdev->mtu + ETH_HLEN);
 			return 1;
 		}
 
@@ -406,9 +406,9 @@ int skb_p80211_to_ether(wlandevice_t *wlandev, u32 ethconv,
 		skb_pull(skb, payload_offset);
 
 		/* create 802.3 header at beginning of skb. */
-		e_hdr = (struct wlan_ethhdr *) skb_push(skb, WLAN_ETHHDR_LEN);
-		memcpy(e_hdr->daddr, daddr, WLAN_ETHADDR_LEN);
-		memcpy(e_hdr->saddr, saddr, WLAN_ETHADDR_LEN);
+		e_hdr = (struct wlan_ethhdr *)skb_push(skb, ETH_HLEN);
+		ether_addr_copy(e_hdr->daddr, daddr);
+		ether_addr_copy(e_hdr->saddr, saddr);
 		e_hdr->type = htons(payload_length);
 
 		/* chop off the 802.11 CRC */
@@ -446,10 +446,10 @@ int skb_p80211_to_ether(wlandevice_t *wlandev, u32 ethconv,
 		skb_pull(skb, sizeof(struct wlan_snap));
 
 		/* create 802.3 header at beginning of skb. */
-		e_hdr = (struct wlan_ethhdr *) skb_push(skb, WLAN_ETHHDR_LEN);
+		e_hdr = (struct wlan_ethhdr *)skb_push(skb, ETH_HLEN);
 		e_hdr->type = e_snap->type;
-		memcpy(e_hdr->daddr, daddr, WLAN_ETHADDR_LEN);
-		memcpy(e_hdr->saddr, saddr, WLAN_ETHADDR_LEN);
+		ether_addr_copy(e_hdr->daddr, daddr);
+		ether_addr_copy(e_hdr->saddr, saddr);
 
 		/* chop off the 802.11 CRC */
 		skb_trim(skb, skb->len - WLAN_CRC_LEN);
@@ -473,9 +473,9 @@ int skb_p80211_to_ether(wlandevice_t *wlandev, u32 ethconv,
 		skb_pull(skb, payload_offset);
 
 		/* create 802.3 header at beginning of skb. */
-		e_hdr = (struct wlan_ethhdr *) skb_push(skb, WLAN_ETHHDR_LEN);
-		memcpy(e_hdr->daddr, daddr, WLAN_ETHADDR_LEN);
-		memcpy(e_hdr->saddr, saddr, WLAN_ETHADDR_LEN);
+		e_hdr = (struct wlan_ethhdr *)skb_push(skb, ETH_HLEN);
+		ether_addr_copy(e_hdr->daddr, daddr);
+		ether_addr_copy(e_hdr->saddr, saddr);
 		e_hdr->type = htons(payload_length);
 
 		/* chop off the 802.11 CRC */

commit 4c6b0ec2f1cf08419a08c189fd713a810ca9e86a
Author: Hari Prasath Gujulan Elango <hgujulan@visteon.com>
Date:   Mon Jun 15 11:48:53 2015 +0000

    staging: wlan-ng: Replace hard coded values with MACRO's
    
    This patch replaces hard coded values with global definitions for the
    Ethernet IEEE 802.3 interface defined in standard header file.
    
    Signed-off-by: Hari Prasath Gujulan Elango <hgujulan@visteon.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/p80211conv.c b/drivers/staging/wlan-ng/p80211conv.c
index c0e6ac8a28eb..49f2ef88929d 100644
--- a/drivers/staging/wlan-ng/p80211conv.c
+++ b/drivers/staging/wlan-ng/p80211conv.c
@@ -129,7 +129,7 @@ int skb_ether_to_p80211(wlandevice_t *wlandev, u32 ethconv,
 	} else {
 		/* step 1: classify ether frame, DIX or 802.3? */
 		proto = ntohs(e_hdr.type);
-		if (proto <= 1500) {
+		if (proto <= ETH_DATA_LEN) {
 			pr_debug("802.3 len: %d\n", skb->len);
 			/* codes <= 1500 reserved for 802.3 lengths */
 			/* it's 802.3, pass ether payload unchanged,  */
@@ -531,7 +531,7 @@ int p80211_stt_findproto(u16 proto)
 	   Need to do some testing to confirm.
 	 */
 
-	if (proto == 0x80f3)	/* APPLETALK */
+	if (proto == ETH_P_AARP)	/* APPLETALK */
 		return 1;
 
 	return 0;

commit 4bff39dfb75743c44d429b84b3810a955b8192b2
Author: Gujulan Elango, Hari Prasath (H.) <hgujulan@visteon.com>
Date:   Wed May 13 14:35:25 2015 +0000

    staging: wlan-ng: check return value of kmalloc
    
    check return value of kmalloc before accessing the memory pointer and
    return -ENOMEM if allocation fails.
    
    Signed-off-by: Hari Prasath Gujulan Elango <hgujulan@visteon.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/p80211conv.c b/drivers/staging/wlan-ng/p80211conv.c
index bd69e8cf200f..c0e6ac8a28eb 100644
--- a/drivers/staging/wlan-ng/p80211conv.c
+++ b/drivers/staging/wlan-ng/p80211conv.c
@@ -207,6 +207,8 @@ int skb_ether_to_p80211(wlandevice_t *wlandev, u32 ethconv,
 		/* XXXX need to pick keynum other than default? */
 
 		p80211_wep->data = kmalloc(skb->len, GFP_ATOMIC);
+		if (!p80211_wep->data)
+			return -ENOMEM;
 		foo = wep_encrypt(wlandev, skb->data, p80211_wep->data,
 				  skb->len,
 				  (wlandev->hostwep & HOSTWEP_DEFAULTKEY_MASK),

commit 1a6dfce737cc7d8f7a99c79ca7c15c64fb840534
Author: Masanari Iida <standby24x7@gmail.com>
Date:   Mon Dec 1 00:29:00 2014 +0900

    staging: wlan-ng: Fix typo in comments and printk
    
    This patch fix spelling typo in comments and print.
    
    Signed-off-by: Masanari Iida <standby24x7@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/p80211conv.c b/drivers/staging/wlan-ng/p80211conv.c
index 7eaaf9a63503..bd69e8cf200f 100644
--- a/drivers/staging/wlan-ng/p80211conv.c
+++ b/drivers/staging/wlan-ng/p80211conv.c
@@ -511,7 +511,7 @@ int skb_p80211_to_ether(wlandevice_t *wlandev, u32 ethconv,
 * protocol.
 *
 * Arguments:
-*	proto	protocl number (in host order) to search for.
+*	proto	protocol number (in host order) to search for.
 *
 * Returns:
 *	1 - if the table is empty or a match is found.

commit f474f5e5353d9a935833b69d029db4856b6bd6e9
Author: Ebru Akagunduz <ebru.akagunduz@gmail.com>
Date:   Sat Oct 25 13:16:42 2014 +0300

    staging: wlan-ng: Fix incorrect type in assignments
    
    fc variable type was u16 and it has an assignment
    from cpu_to_le16() so its type changed as __le16.
    This bug found by sparse.
    
    Signed-off-by: Ebru Akagunduz <ebru.akagunduz@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/p80211conv.c b/drivers/staging/wlan-ng/p80211conv.c
index 3b5468c64fde..7eaaf9a63503 100644
--- a/drivers/staging/wlan-ng/p80211conv.c
+++ b/drivers/staging/wlan-ng/p80211conv.c
@@ -107,7 +107,7 @@ int skb_ether_to_p80211(wlandevice_t *wlandev, u32 ethconv,
 			struct p80211_metawep *p80211_wep)
 {
 
-	u16 fc;
+	__le16 fc;
 	u16 proto;
 	struct wlan_ethhdr e_hdr;
 	struct wlan_llc *e_llc;

commit 0e1fc793c7e42308dddad103a195dd261c5bf650
Author: Modestas Stankus <stankus.modestas@gmail.com>
Date:   Thu Jul 31 22:33:35 2014 +0300

    staging: wlan-ng: coding style problem fix
    
    WARNING: break is not useful after a goto or return
    201: FILE: drivers/staging/wlan-ng/p80211conv.c:201:
    +               return 1;
    +               break;
    
    Signed-off-by: Modestas Stankus <stankus.modestas@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/p80211conv.c b/drivers/staging/wlan-ng/p80211conv.c
index 913676e1797e..3b5468c64fde 100644
--- a/drivers/staging/wlan-ng/p80211conv.c
+++ b/drivers/staging/wlan-ng/p80211conv.c
@@ -198,7 +198,6 @@ int skb_ether_to_p80211(wlandevice_t *wlandev, u32 ethconv,
 		netdev_err(wlandev->netdev,
 			   "Error: Converting eth to wlan in unknown mode.\n");
 		return 1;
-		break;
 	}
 
 	p80211_wep->data = NULL;

commit 02d9b1eb4b21b9309efdf8c8aee023a59d3f76e0
Author: Vitaly Osipov <vitaly.osipov@gmail.com>
Date:   Sun May 18 16:59:36 2014 +1000

    staging: wlan-ng: use netdev_() instead of printk()
    
    Replaced all uses of printk() in wlan-ng with netdev_err / _warn
    where a netdev exists. If a few cases where a netdev does not yet
    exist, dev_ or pr_ was used.
    
    Checkpatch complains about lines over 80 chars or split string
    constants - the messages are just too long, keeping it completely
    happy would make the code less readable.
    
    Signed-off-by: Vitaly Osipov <vitaly.osipov@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/p80211conv.c b/drivers/staging/wlan-ng/p80211conv.c
index 3df753b51e89..913676e1797e 100644
--- a/drivers/staging/wlan-ng/p80211conv.c
+++ b/drivers/staging/wlan-ng/p80211conv.c
@@ -195,8 +195,8 @@ int skb_ether_to_p80211(wlandevice_t *wlandev, u32 ethconv,
 		memcpy(p80211_hdr->a3.a3, &e_hdr.saddr, ETH_ALEN);
 		break;
 	default:
-		printk(KERN_ERR
-		       "Error: Converting eth to wlan in unknown mode.\n");
+		netdev_err(wlandev->netdev,
+			   "Error: Converting eth to wlan in unknown mode.\n");
 		return 1;
 		break;
 	}
@@ -213,7 +213,7 @@ int skb_ether_to_p80211(wlandevice_t *wlandev, u32 ethconv,
 				  (wlandev->hostwep & HOSTWEP_DEFAULTKEY_MASK),
 				  p80211_wep->iv, p80211_wep->icv);
 		if (foo) {
-			printk(KERN_WARNING
+			netdev_warn(wlandev->netdev,
 			       "Host en-WEP failed, dropping frame (%d).\n",
 			       foo);
 			return 2;
@@ -310,7 +310,7 @@ int skb_p80211_to_ether(wlandevice_t *wlandev, u32 ethconv,
 	} else {
 		payload_offset = WLAN_HDR_A4_LEN;
 		if (payload_length < WLAN_HDR_A4_LEN - WLAN_HDR_A3_LEN) {
-			printk(KERN_ERR "A4 frame too short!\n");
+			netdev_err(netdev, "A4 frame too short!\n");
 			return 1;
 		}
 		payload_length -= (WLAN_HDR_A4_LEN - WLAN_HDR_A3_LEN);
@@ -322,8 +322,8 @@ int skb_p80211_to_ether(wlandevice_t *wlandev, u32 ethconv,
 	if ((wlandev->hostwep & HOSTWEP_PRIVACYINVOKED) && WLAN_GET_FC_ISWEP(fc)
 	    && (wlandev->hostwep & HOSTWEP_DECRYPT)) {
 		if (payload_length <= 8) {
-			printk(KERN_ERR "WEP frame too short (%u).\n",
-			       skb->len);
+			netdev_err(netdev,
+				   "WEP frame too short (%u).\n", skb->len);
 			return 1;
 		}
 		foo = wep_decrypt(wlandev, skb->data + payload_offset + 4,
@@ -367,7 +367,7 @@ int skb_p80211_to_ether(wlandevice_t *wlandev, u32 ethconv,
 		if (payload_length > (netdev->mtu + WLAN_ETHHDR_LEN)) {
 			/* A bogus length ethfrm has been encap'd. */
 			/* Is someone trying an oflow attack? */
-			printk(KERN_ERR "ENCAP frame too large (%d > %d)\n",
+			netdev_err(netdev, "ENCAP frame too large (%d > %d)\n",
 			       payload_length, netdev->mtu + WLAN_ETHHDR_LEN);
 			return 1;
 		}
@@ -396,7 +396,7 @@ int skb_p80211_to_ether(wlandevice_t *wlandev, u32 ethconv,
 		if (payload_length > netdev->mtu) {
 			/* A bogus length ethfrm has been sent. */
 			/* Is someone trying an oflow attack? */
-			printk(KERN_ERR "SNAP frame too large (%d > %d)\n",
+			netdev_err(netdev, "SNAP frame too large (%d > %d)\n",
 			       payload_length, netdev->mtu);
 			return 1;
 		}
@@ -428,7 +428,7 @@ int skb_p80211_to_ether(wlandevice_t *wlandev, u32 ethconv,
 			> netdev->mtu) {
 			/* A bogus length ethfrm has been sent. */
 			/* Is someone trying an oflow attack? */
-			printk(KERN_ERR "DIXII frame too large (%ld > %d)\n",
+			netdev_err(netdev, "DIXII frame too large (%ld > %d)\n",
 			       (long int)(payload_length -
 					sizeof(struct wlan_llc) -
 					sizeof(struct wlan_snap)), netdev->mtu);
@@ -463,7 +463,7 @@ int skb_p80211_to_ether(wlandevice_t *wlandev, u32 ethconv,
 		if (payload_length > netdev->mtu) {
 			/* A bogus length ethfrm has been sent. */
 			/* Is someone trying an oflow attack? */
-			printk(KERN_ERR "OTHER frame too large (%d > %d)\n",
+			netdev_err(netdev, "OTHER frame too large (%d > %d)\n",
 			       payload_length, netdev->mtu);
 			return 1;
 		}
@@ -603,8 +603,8 @@ int p80211skb_rxmeta_attach(struct wlandevice *wlandev, struct sk_buff *skb)
 
 	/* If these already have metadata, we error out! */
 	if (P80211SKB_RXMETA(skb) != NULL) {
-		printk(KERN_ERR "%s: RXmeta already attached!\n",
-		       wlandev->name);
+		netdev_err(wlandev->netdev,
+			   "%s: RXmeta already attached!\n", wlandev->name);
 		result = 0;
 		goto exit;
 	}
@@ -613,8 +613,8 @@ int p80211skb_rxmeta_attach(struct wlandevice *wlandev, struct sk_buff *skb)
 	rxmeta = kzalloc(sizeof(struct p80211_rxmeta), GFP_ATOMIC);
 
 	if (rxmeta == NULL) {
-		printk(KERN_ERR "%s: Failed to allocate rxmeta.\n",
-		       wlandev->name);
+		netdev_err(wlandev->netdev,
+			   "%s: Failed to allocate rxmeta.\n", wlandev->name);
 		result = 1;
 		goto exit;
 	}
@@ -656,6 +656,7 @@ void p80211skb_free(struct wlandevice *wlandev, struct sk_buff *skb)
 	if (meta && meta->rx)
 		p80211skb_rxmeta_detach(skb);
 	else
-		printk(KERN_ERR "Freeing an skb (%p) w/ no frmmeta.\n", skb);
+		netdev_err(wlandev->netdev,
+			   "Freeing an skb (%p) w/ no frmmeta.\n", skb);
 	dev_kfree_skb(skb);
 }

commit 311e24fb1a654a260697793880979142fbbd185d
Author: Devendra Naga <devendra.aaru@gmail.com>
Date:   Sun Sep 9 18:40:59 2012 +0530

    staging:wlan-ng: cleanup p80211skb_free and p80211skb_rxmeta_detach
    
    these functions doesn't need return at the end of the function
    
    Signed-off-by: Devendra Naga <devendra.aaru@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wlan-ng/p80211conv.c b/drivers/staging/wlan-ng/p80211conv.c
index f53a27a2e3fe..3df753b51e89 100644
--- a/drivers/staging/wlan-ng/p80211conv.c
+++ b/drivers/staging/wlan-ng/p80211conv.c
@@ -559,17 +559,17 @@ void p80211skb_rxmeta_detach(struct sk_buff *skb)
 	/* Sanity checks */
 	if (skb == NULL) {	/* bad skb */
 		pr_debug("Called w/ null skb.\n");
-		goto exit;
+		return;
 	}
 	frmmeta = P80211SKB_FRMMETA(skb);
 	if (frmmeta == NULL) {	/* no magic */
 		pr_debug("Called w/ bad frmmeta magic.\n");
-		goto exit;
+		return;
 	}
 	rxmeta = frmmeta->rx;
 	if (rxmeta == NULL) {	/* bad meta ptr */
 		pr_debug("Called w/ bad rxmeta ptr.\n");
-		goto exit;
+		return;
 	}
 
 	/* Free rxmeta */
@@ -577,8 +577,6 @@ void p80211skb_rxmeta_detach(struct sk_buff *skb)
 
 	/* Clear skb->cb */
 	memset(skb->cb, 0, sizeof(skb->cb));
-exit:
-	return;
 }
 
 /*----------------------------------------------------------------
@@ -660,5 +658,4 @@ void p80211skb_free(struct wlandevice *wlandev, struct sk_buff *skb)
 	else
 		printk(KERN_ERR "Freeing an skb (%p) w/ no frmmeta.\n", skb);
 	dev_kfree_skb(skb);
-	return;
 }

commit e80528b78e8d33494a0784dc214e71a728162d92
Author: Adam Thompson <adam@lotpblog.com>
Date:   Sat Jan 29 02:08:50 2011 -0500

    Staging: wlan-ng: fix 2 space coding style issues
    
    This patch to p80211conv.c fixes to space coding style warnings found
    with checkpatch.pl
    
    Signed-off-by: Adam Thompson <adam@lotpblog.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/wlan-ng/p80211conv.c b/drivers/staging/wlan-ng/p80211conv.c
index 146f3651b6f2..f53a27a2e3fe 100644
--- a/drivers/staging/wlan-ng/p80211conv.c
+++ b/drivers/staging/wlan-ng/p80211conv.c
@@ -379,7 +379,7 @@ int skb_p80211_to_ether(wlandevice_t *wlandev, u32 ethconv,
 
 	} else if ((payload_length >= sizeof(struct wlan_llc) +
 		sizeof(struct wlan_snap))
-		&&(e_llc->dsap == 0xaa)
+		&& (e_llc->dsap == 0xaa)
 		&& (e_llc->ssap == 0xaa)
 		&& (e_llc->ctl == 0x03)
 		   &&
@@ -415,7 +415,7 @@ int skb_p80211_to_ether(wlandevice_t *wlandev, u32 ethconv,
 
 	} else if ((payload_length >= sizeof(struct wlan_llc) +
 		sizeof(struct wlan_snap))
-		&&(e_llc->dsap == 0xaa)
+		&& (e_llc->dsap == 0xaa)
 		&& (e_llc->ssap == 0xaa)
 		&& (e_llc->ctl == 0x03)) {
 		pr_debug("802.1h/RFC1042 len: %d\n", payload_length);

commit 4eb28f7197a2cbaf7a9be778d429a5fb9bb6172e
Author: Johan Meiring <johanmeiring@gmail.com>
Date:   Sat Nov 6 15:46:54 2010 +0200

    Staging: wlan-ng: fixed coding style issues in p80211conv.c
    
    This is a patch to the p80211conv.c file that fixes a couple of coding
    style issues found by the checkpatch.pl tool.
    
    Signed-off-by: Johan Meiring <johanmeiring@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/wlan-ng/p80211conv.c b/drivers/staging/wlan-ng/p80211conv.c
index 83879f9a0b7d..146f3651b6f2 100644
--- a/drivers/staging/wlan-ng/p80211conv.c
+++ b/drivers/staging/wlan-ng/p80211conv.c
@@ -148,7 +148,8 @@ int skb_ether_to_p80211(wlandevice_t *wlandev, u32 ethconv,
 
 			/* tack on SNAP */
 			e_snap =
-			    (struct wlan_snap *) skb_push(skb, sizeof(struct wlan_snap));
+			    (struct wlan_snap *) skb_push(skb,
+				sizeof(struct wlan_snap));
 			e_snap->type = htons(proto);
 			if (ethconv == WLAN_ETHCONV_8021h
 			    && p80211_stt_findproto(proto)) {
@@ -161,7 +162,8 @@ int skb_ether_to_p80211(wlandevice_t *wlandev, u32 ethconv,
 
 			/* tack on llc */
 			e_llc =
-			    (struct wlan_llc *) skb_push(skb, sizeof(struct wlan_llc));
+			    (struct wlan_llc *) skb_push(skb,
+				sizeof(struct wlan_llc));
 			e_llc->dsap = 0xAA;	/* SNAP, see IEEE 802 */
 			e_llc->ssap = 0xAA;
 			e_llc->ctl = 0x03;
@@ -297,10 +299,12 @@ int skb_p80211_to_ether(wlandevice_t *wlandev, u32 ethconv,
 	if ((WLAN_GET_FC_TODS(fc) == 0) && (WLAN_GET_FC_FROMDS(fc) == 0)) {
 		memcpy(daddr, w_hdr->a3.a1, WLAN_ETHADDR_LEN);
 		memcpy(saddr, w_hdr->a3.a2, WLAN_ETHADDR_LEN);
-	} else if ((WLAN_GET_FC_TODS(fc) == 0) && (WLAN_GET_FC_FROMDS(fc) == 1)) {
+	} else if ((WLAN_GET_FC_TODS(fc) == 0)
+			&& (WLAN_GET_FC_FROMDS(fc) == 1)) {
 		memcpy(daddr, w_hdr->a3.a1, WLAN_ETHADDR_LEN);
 		memcpy(saddr, w_hdr->a3.a3, WLAN_ETHADDR_LEN);
-	} else if ((WLAN_GET_FC_TODS(fc) == 1) && (WLAN_GET_FC_FROMDS(fc) == 0)) {
+	} else if ((WLAN_GET_FC_TODS(fc) == 1)
+			&& (WLAN_GET_FC_FROMDS(fc) == 0)) {
 		memcpy(daddr, w_hdr->a3.a3, WLAN_ETHADDR_LEN);
 		memcpy(saddr, w_hdr->a3.a2, WLAN_ETHADDR_LEN);
 	} else {
@@ -349,7 +353,8 @@ int skb_p80211_to_ether(wlandevice_t *wlandev, u32 ethconv,
 
 	e_llc = (struct wlan_llc *) (skb->data + payload_offset);
 	e_snap =
-	    (struct wlan_snap *) (skb->data + payload_offset + sizeof(struct wlan_llc));
+	    (struct wlan_snap *) (skb->data + payload_offset +
+		sizeof(struct wlan_llc));
 
 	/* Test for the various encodings */
 	if ((payload_length >= sizeof(struct wlan_ethhdr)) &&
@@ -372,9 +377,11 @@ int skb_p80211_to_ether(wlandevice_t *wlandev, u32 ethconv,
 		/* chop off the 802.11 CRC */
 		skb_trim(skb, skb->len - WLAN_CRC_LEN);
 
-	} else if ((payload_length >= sizeof(struct wlan_llc) + sizeof(struct wlan_snap))
-		   && (e_llc->dsap == 0xaa) && (e_llc->ssap == 0xaa)
-		   && (e_llc->ctl == 0x03)
+	} else if ((payload_length >= sizeof(struct wlan_llc) +
+		sizeof(struct wlan_snap))
+		&&(e_llc->dsap == 0xaa)
+		&& (e_llc->ssap == 0xaa)
+		&& (e_llc->ctl == 0x03)
 		   &&
 		   (((memcmp(e_snap->oui, oui_rfc1042, WLAN_IEEE_OUI_LEN) == 0)
 		     && (ethconv == WLAN_ETHCONV_8021h)
@@ -406,21 +413,25 @@ int skb_p80211_to_ether(wlandevice_t *wlandev, u32 ethconv,
 		/* chop off the 802.11 CRC */
 		skb_trim(skb, skb->len - WLAN_CRC_LEN);
 
-	} else if ((payload_length >= sizeof(struct wlan_llc) + sizeof(struct wlan_snap))
-		   && (e_llc->dsap == 0xaa) && (e_llc->ssap == 0xaa)
-		   && (e_llc->ctl == 0x03)) {
+	} else if ((payload_length >= sizeof(struct wlan_llc) +
+		sizeof(struct wlan_snap))
+		&&(e_llc->dsap == 0xaa)
+		&& (e_llc->ssap == 0xaa)
+		&& (e_llc->ctl == 0x03)) {
 		pr_debug("802.1h/RFC1042 len: %d\n", payload_length);
-		/* it's an 802.1h frame || (an RFC1042 && protocol is not in STT) */
-		/* build a DIXII + RFC894 */
+		/* it's an 802.1h frame || (an RFC1042 && protocol not in STT)
+		   build a DIXII + RFC894 */
 
 		/* Test for an overlength frame */
-		if ((payload_length - sizeof(struct wlan_llc) - sizeof(struct wlan_snap))
-		    > netdev->mtu) {
+		if ((payload_length - sizeof(struct wlan_llc) -
+			sizeof(struct wlan_snap))
+			> netdev->mtu) {
 			/* A bogus length ethfrm has been sent. */
 			/* Is someone trying an oflow attack? */
 			printk(KERN_ERR "DIXII frame too large (%ld > %d)\n",
-			       (long int)(payload_length - sizeof(struct wlan_llc) -
-					  sizeof(struct wlan_snap)), netdev->mtu);
+			       (long int)(payload_length -
+					sizeof(struct wlan_llc) -
+					sizeof(struct wlan_snap)), netdev->mtu);
 			return 1;
 		}
 

commit 51e4896adad00a066fad65649405c1c9fa108157
Author: Edgardo Hames <ehames@gmail.com>
Date:   Sat Jul 31 13:06:52 2010 -0300

    Staging: wlan-ng: fix style issues in p80211conv.h
    
    This patch removes typedefs in p80211conv.h.
    
    Signed-off-by: Edgardo Hames <ehames@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/wlan-ng/p80211conv.c b/drivers/staging/wlan-ng/p80211conv.c
index 409a7c88021b..83879f9a0b7d 100644
--- a/drivers/staging/wlan-ng/p80211conv.c
+++ b/drivers/staging/wlan-ng/p80211conv.c
@@ -104,14 +104,14 @@ static u8 oui_8021h[] = { 0x00, 0x00, 0xf8 };
 ----------------------------------------------------------------*/
 int skb_ether_to_p80211(wlandevice_t *wlandev, u32 ethconv,
 			struct sk_buff *skb, union p80211_hdr *p80211_hdr,
-			p80211_metawep_t *p80211_wep)
+			struct p80211_metawep *p80211_wep)
 {
 
 	u16 fc;
 	u16 proto;
-	wlan_ethhdr_t e_hdr;
-	wlan_llc_t *e_llc;
-	wlan_snap_t *e_snap;
+	struct wlan_ethhdr e_hdr;
+	struct wlan_llc *e_llc;
+	struct wlan_snap *e_snap;
 	int foo;
 
 	memcpy(&e_hdr, skb->data, sizeof(e_hdr));
@@ -148,7 +148,7 @@ int skb_ether_to_p80211(wlandevice_t *wlandev, u32 ethconv,
 
 			/* tack on SNAP */
 			e_snap =
-			    (wlan_snap_t *) skb_push(skb, sizeof(wlan_snap_t));
+			    (struct wlan_snap *) skb_push(skb, sizeof(struct wlan_snap));
 			e_snap->type = htons(proto);
 			if (ethconv == WLAN_ETHCONV_8021h
 			    && p80211_stt_findproto(proto)) {
@@ -161,7 +161,7 @@ int skb_ether_to_p80211(wlandevice_t *wlandev, u32 ethconv,
 
 			/* tack on llc */
 			e_llc =
-			    (wlan_llc_t *) skb_push(skb, sizeof(wlan_llc_t));
+			    (struct wlan_llc *) skb_push(skb, sizeof(struct wlan_llc));
 			e_llc->dsap = 0xAA;	/* SNAP, see IEEE 802 */
 			e_llc->ssap = 0xAA;
 			e_llc->ctl = 0x03;
@@ -230,7 +230,7 @@ int skb_ether_to_p80211(wlandevice_t *wlandev, u32 ethconv,
 
 /* jkriegl: from orinoco, modified */
 static void orinoco_spy_gather(wlandevice_t *wlandev, char *mac,
-			       p80211_rxmeta_t *rxmeta)
+			       struct p80211_rxmeta *rxmeta)
 {
 	int i;
 
@@ -281,9 +281,9 @@ int skb_p80211_to_ether(wlandevice_t *wlandev, u32 ethconv,
 	u8 daddr[WLAN_ETHADDR_LEN];
 	u8 saddr[WLAN_ETHADDR_LEN];
 	union p80211_hdr *w_hdr;
-	wlan_ethhdr_t *e_hdr;
-	wlan_llc_t *e_llc;
-	wlan_snap_t *e_snap;
+	struct wlan_ethhdr *e_hdr;
+	struct wlan_llc *e_llc;
+	struct wlan_snap *e_snap;
 
 	int foo;
 
@@ -345,14 +345,14 @@ int skb_p80211_to_ether(wlandevice_t *wlandev, u32 ethconv,
 		wlandev->rx.decrypt++;
 	}
 
-	e_hdr = (wlan_ethhdr_t *) (skb->data + payload_offset);
+	e_hdr = (struct wlan_ethhdr *) (skb->data + payload_offset);
 
-	e_llc = (wlan_llc_t *) (skb->data + payload_offset);
+	e_llc = (struct wlan_llc *) (skb->data + payload_offset);
 	e_snap =
-	    (wlan_snap_t *) (skb->data + payload_offset + sizeof(wlan_llc_t));
+	    (struct wlan_snap *) (skb->data + payload_offset + sizeof(struct wlan_llc));
 
 	/* Test for the various encodings */
-	if ((payload_length >= sizeof(wlan_ethhdr_t)) &&
+	if ((payload_length >= sizeof(struct wlan_ethhdr)) &&
 	    (e_llc->dsap != 0xaa || e_llc->ssap != 0xaa) &&
 	    ((memcmp(daddr, e_hdr->daddr, WLAN_ETHADDR_LEN) == 0) ||
 	     (memcmp(saddr, e_hdr->saddr, WLAN_ETHADDR_LEN) == 0))) {
@@ -372,7 +372,7 @@ int skb_p80211_to_ether(wlandevice_t *wlandev, u32 ethconv,
 		/* chop off the 802.11 CRC */
 		skb_trim(skb, skb->len - WLAN_CRC_LEN);
 
-	} else if ((payload_length >= sizeof(wlan_llc_t) + sizeof(wlan_snap_t))
+	} else if ((payload_length >= sizeof(struct wlan_llc) + sizeof(struct wlan_snap))
 		   && (e_llc->dsap == 0xaa) && (e_llc->ssap == 0xaa)
 		   && (e_llc->ctl == 0x03)
 		   &&
@@ -398,7 +398,7 @@ int skb_p80211_to_ether(wlandevice_t *wlandev, u32 ethconv,
 		skb_pull(skb, payload_offset);
 
 		/* create 802.3 header at beginning of skb. */
-		e_hdr = (wlan_ethhdr_t *) skb_push(skb, WLAN_ETHHDR_LEN);
+		e_hdr = (struct wlan_ethhdr *) skb_push(skb, WLAN_ETHHDR_LEN);
 		memcpy(e_hdr->daddr, daddr, WLAN_ETHADDR_LEN);
 		memcpy(e_hdr->saddr, saddr, WLAN_ETHADDR_LEN);
 		e_hdr->type = htons(payload_length);
@@ -406,7 +406,7 @@ int skb_p80211_to_ether(wlandevice_t *wlandev, u32 ethconv,
 		/* chop off the 802.11 CRC */
 		skb_trim(skb, skb->len - WLAN_CRC_LEN);
 
-	} else if ((payload_length >= sizeof(wlan_llc_t) + sizeof(wlan_snap_t))
+	} else if ((payload_length >= sizeof(struct wlan_llc) + sizeof(struct wlan_snap))
 		   && (e_llc->dsap == 0xaa) && (e_llc->ssap == 0xaa)
 		   && (e_llc->ctl == 0x03)) {
 		pr_debug("802.1h/RFC1042 len: %d\n", payload_length);
@@ -414,13 +414,13 @@ int skb_p80211_to_ether(wlandevice_t *wlandev, u32 ethconv,
 		/* build a DIXII + RFC894 */
 
 		/* Test for an overlength frame */
-		if ((payload_length - sizeof(wlan_llc_t) - sizeof(wlan_snap_t))
+		if ((payload_length - sizeof(struct wlan_llc) - sizeof(struct wlan_snap))
 		    > netdev->mtu) {
 			/* A bogus length ethfrm has been sent. */
 			/* Is someone trying an oflow attack? */
 			printk(KERN_ERR "DIXII frame too large (%ld > %d)\n",
-			       (long int)(payload_length - sizeof(wlan_llc_t) -
-					  sizeof(wlan_snap_t)), netdev->mtu);
+			       (long int)(payload_length - sizeof(struct wlan_llc) -
+					  sizeof(struct wlan_snap)), netdev->mtu);
 			return 1;
 		}
 
@@ -428,13 +428,13 @@ int skb_p80211_to_ether(wlandevice_t *wlandev, u32 ethconv,
 		skb_pull(skb, payload_offset);
 
 		/* chop llc header from skb. */
-		skb_pull(skb, sizeof(wlan_llc_t));
+		skb_pull(skb, sizeof(struct wlan_llc));
 
 		/* chop snap header from skb. */
-		skb_pull(skb, sizeof(wlan_snap_t));
+		skb_pull(skb, sizeof(struct wlan_snap));
 
 		/* create 802.3 header at beginning of skb. */
-		e_hdr = (wlan_ethhdr_t *) skb_push(skb, WLAN_ETHHDR_LEN);
+		e_hdr = (struct wlan_ethhdr *) skb_push(skb, WLAN_ETHHDR_LEN);
 		e_hdr->type = e_snap->type;
 		memcpy(e_hdr->daddr, daddr, WLAN_ETHADDR_LEN);
 		memcpy(e_hdr->saddr, saddr, WLAN_ETHADDR_LEN);
@@ -461,7 +461,7 @@ int skb_p80211_to_ether(wlandevice_t *wlandev, u32 ethconv,
 		skb_pull(skb, payload_offset);
 
 		/* create 802.3 header at beginning of skb. */
-		e_hdr = (wlan_ethhdr_t *) skb_push(skb, WLAN_ETHHDR_LEN);
+		e_hdr = (struct wlan_ethhdr *) skb_push(skb, WLAN_ETHHDR_LEN);
 		memcpy(e_hdr->daddr, daddr, WLAN_ETHADDR_LEN);
 		memcpy(e_hdr->saddr, saddr, WLAN_ETHADDR_LEN);
 		e_hdr->type = htons(payload_length);
@@ -542,8 +542,8 @@ int p80211_stt_findproto(u16 proto)
 ----------------------------------------------------------------*/
 void p80211skb_rxmeta_detach(struct sk_buff *skb)
 {
-	p80211_rxmeta_t *rxmeta;
-	p80211_frmmeta_t *frmmeta;
+	struct p80211_rxmeta *rxmeta;
+	struct p80211_frmmeta *frmmeta;
 
 	/* Sanity checks */
 	if (skb == NULL) {	/* bad skb */
@@ -589,8 +589,8 @@ void p80211skb_rxmeta_detach(struct sk_buff *skb)
 int p80211skb_rxmeta_attach(struct wlandevice *wlandev, struct sk_buff *skb)
 {
 	int result = 0;
-	p80211_rxmeta_t *rxmeta;
-	p80211_frmmeta_t *frmmeta;
+	struct p80211_rxmeta *rxmeta;
+	struct p80211_frmmeta *frmmeta;
 
 	/* If these already have metadata, we error out! */
 	if (P80211SKB_RXMETA(skb) != NULL) {
@@ -601,7 +601,7 @@ int p80211skb_rxmeta_attach(struct wlandevice *wlandev, struct sk_buff *skb)
 	}
 
 	/* Allocate the rxmeta */
-	rxmeta = kzalloc(sizeof(p80211_rxmeta_t), GFP_ATOMIC);
+	rxmeta = kzalloc(sizeof(struct p80211_rxmeta), GFP_ATOMIC);
 
 	if (rxmeta == NULL) {
 		printk(KERN_ERR "%s: Failed to allocate rxmeta.\n",
@@ -615,8 +615,8 @@ int p80211skb_rxmeta_attach(struct wlandevice *wlandev, struct sk_buff *skb)
 	rxmeta->hosttime = jiffies;
 
 	/* Overlay a frmmeta_t onto skb->cb */
-	memset(skb->cb, 0, sizeof(p80211_frmmeta_t));
-	frmmeta = (p80211_frmmeta_t *) (skb->cb);
+	memset(skb->cb, 0, sizeof(struct p80211_frmmeta));
+	frmmeta = (struct p80211_frmmeta *) (skb->cb);
 	frmmeta->magic = P80211_FRMMETA_MAGIC;
 	frmmeta->rx = rxmeta;
 exit:
@@ -641,7 +641,7 @@ int p80211skb_rxmeta_attach(struct wlandevice *wlandev, struct sk_buff *skb)
 ----------------------------------------------------------------*/
 void p80211skb_free(struct wlandevice *wlandev, struct sk_buff *skb)
 {
-	p80211_frmmeta_t *meta;
+	struct p80211_frmmeta *meta;
 
 	meta = P80211SKB_FRMMETA(skb);
 	if (meta && meta->rx)

commit 93df38e593d949de83a6447d016cc4b07d392f47
Author: Edgardo Hames <ehames@gmail.com>
Date:   Fri Jul 30 22:51:55 2010 -0300

    Staging: wlan-ng: fix style issues for p80211hdr.h
    
    Removed typedef and other style issues.
    
    Signed-off-by: Edgardo Hames <ehames@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/wlan-ng/p80211conv.c b/drivers/staging/wlan-ng/p80211conv.c
index 059e15055b74..409a7c88021b 100644
--- a/drivers/staging/wlan-ng/p80211conv.c
+++ b/drivers/staging/wlan-ng/p80211conv.c
@@ -103,7 +103,7 @@ static u8 oui_8021h[] = { 0x00, 0x00, 0xf8 };
 *	May be called in interrupt or non-interrupt context
 ----------------------------------------------------------------*/
 int skb_ether_to_p80211(wlandevice_t *wlandev, u32 ethconv,
-			struct sk_buff *skb, p80211_hdr_t *p80211_hdr,
+			struct sk_buff *skb, union p80211_hdr *p80211_hdr,
 			p80211_metawep_t *p80211_wep)
 {
 
@@ -280,7 +280,7 @@ int skb_p80211_to_ether(wlandevice_t *wlandev, u32 ethconv,
 	unsigned int payload_offset;
 	u8 daddr[WLAN_ETHADDR_LEN];
 	u8 saddr[WLAN_ETHADDR_LEN];
-	p80211_hdr_t *w_hdr;
+	union p80211_hdr *w_hdr;
 	wlan_ethhdr_t *e_hdr;
 	wlan_llc_t *e_llc;
 	wlan_snap_t *e_snap;
@@ -290,7 +290,7 @@ int skb_p80211_to_ether(wlandevice_t *wlandev, u32 ethconv,
 	payload_length = skb->len - WLAN_HDR_A3_LEN - WLAN_CRC_LEN;
 	payload_offset = WLAN_HDR_A3_LEN;
 
-	w_hdr = (p80211_hdr_t *) skb->data;
+	w_hdr = (union p80211_hdr *) skb->data;
 
 	/* setup some vars for convenience */
 	fc = le16_to_cpu(w_hdr->a3.fc);

commit 7a6cb0d5497418599d2125b670926b75e673861c
Author: Julia Lawall <julia@diku.dk>
Date:   Thu May 13 22:00:05 2010 +0200

    Staging: Use kcalloc or kzalloc
    
    Use kcalloc or kzalloc rather than the combination of kmalloc and memset.
    
    The semantic patch that makes this change is as follows:
    (http://coccinelle.lip6.fr/)
    
    // <smpl>
    @@
    expression x,y,flags;
    statement S;
    type T;
    @@
    
    x =
    -   kmalloc
    +   kcalloc
               (
    -           y * sizeof(T),
    +           y, sizeof(T),
                    flags);
     if (x == NULL) S
    -memset(x, 0, y * sizeof(T));
    
    @@
    expression x,size,flags;
    statement S;
    @@
    
    -x = kmalloc(size,flags);
    +x = kzalloc(size,flags);
     if (x == NULL) S
    -memset(x, 0, size);
    // </smpl>
    
    Signed-off-by: Julia Lawall <julia@diku.dk>

diff --git a/drivers/staging/wlan-ng/p80211conv.c b/drivers/staging/wlan-ng/p80211conv.c
index 71c3595fe830..059e15055b74 100644
--- a/drivers/staging/wlan-ng/p80211conv.c
+++ b/drivers/staging/wlan-ng/p80211conv.c
@@ -601,7 +601,7 @@ int p80211skb_rxmeta_attach(struct wlandevice *wlandev, struct sk_buff *skb)
 	}
 
 	/* Allocate the rxmeta */
-	rxmeta = kmalloc(sizeof(p80211_rxmeta_t), GFP_ATOMIC);
+	rxmeta = kzalloc(sizeof(p80211_rxmeta_t), GFP_ATOMIC);
 
 	if (rxmeta == NULL) {
 		printk(KERN_ERR "%s: Failed to allocate rxmeta.\n",
@@ -611,7 +611,6 @@ int p80211skb_rxmeta_attach(struct wlandevice *wlandev, struct sk_buff *skb)
 	}
 
 	/* Initialize the rxmeta */
-	memset(rxmeta, 0, sizeof(p80211_rxmeta_t));
 	rxmeta->wlandev = wlandev;
 	rxmeta->hosttime = jiffies;
 

commit 5813b6243cf02b89c6e6a6a8debc10477e5ce3a8
Author: Ruslan Pisarev <ruslan@rpisarev.org.ua>
Date:   Mon Mar 15 21:27:42 2010 +0200

    Staging: wlan-ng: fix spaces coding style issue in p80211conv.c
    
    This is a patch to the p80211conv.c file that fixed up a TAB and spaces
    Errors found by the checkpatch.pl tools, like
            spaces required around that '&' (ctx:VxV)
    
    Signed-off-by: Ruslan Pisarev <ruslan@rpisarev.org.ua>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/wlan-ng/p80211conv.c b/drivers/staging/wlan-ng/p80211conv.c
index a1605fbc8092..71c3595fe830 100644
--- a/drivers/staging/wlan-ng/p80211conv.c
+++ b/drivers/staging/wlan-ng/p80211conv.c
@@ -208,7 +208,7 @@ int skb_ether_to_p80211(wlandevice_t *wlandev, u32 ethconv,
 		p80211_wep->data = kmalloc(skb->len, GFP_ATOMIC);
 		foo = wep_encrypt(wlandev, skb->data, p80211_wep->data,
 				  skb->len,
-				  (wlandev->hostwep &HOSTWEP_DEFAULTKEY_MASK),
+				  (wlandev->hostwep & HOSTWEP_DEFAULTKEY_MASK),
 				  p80211_wep->iv, p80211_wep->icv);
 		if (foo) {
 			printk(KERN_WARNING

commit b02957d58a27525499ab10d272d3b44682a7ae50
Merge: 3a8954e8f22c b94c765ac31f
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Thu Mar 4 08:14:54 2010 -0800

    Staging: Merge two branches of coding style fixes together
    
    Turns out that multiple people sent pretty much the same patch
    for the same staging drivers.  Commit these in two different
    branches and merge them together to get a more complete coverage
    of the cleanup and properly credit everyone for the work that they
    did.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

commit 3f4b4e779714ae2dd55757617a8033ab338fa7f0
Author: Andrew Elwell <andrew.elwell@gmail.com>
Date:   Thu Feb 18 23:56:13 2010 +0100

    Staging: wlan-ng: More checkpatch.pl error cleanups
    
    Signed-off-by: Andrew Elwell <Andrew.Elwell@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/wlan-ng/p80211conv.c b/drivers/staging/wlan-ng/p80211conv.c
index 5952c671073f..3ba5eabdb583 100644
--- a/drivers/staging/wlan-ng/p80211conv.c
+++ b/drivers/staging/wlan-ng/p80211conv.c
@@ -207,11 +207,10 @@ int skb_ether_to_p80211(wlandevice_t *wlandev, u32 ethconv,
 
 		p80211_wep->data = kmalloc(skb->len, GFP_ATOMIC);
 
-		if ((foo = wep_encrypt(wlandev, skb->data, p80211_wep->data,
-				       skb->len,
-				       (wlandev->hostwep &
-					HOSTWEP_DEFAULTKEY_MASK),
-				       p80211_wep->iv, p80211_wep->icv))) {
+		foo = wep_encrypt(wlandev, skb->data, p80211_wep->data,
+				  skb->len, (wlandev->hostwep &HOSTWEP_DEFAULTKEY_MASK),
+				  p80211_wep->iv, p80211_wep->icv);
+		if (foo) {
 			printk(KERN_WARNING
 			       "Host en-WEP failed, dropping frame (%d).\n",
 			       foo);
@@ -323,11 +322,12 @@ int skb_p80211_to_ether(wlandevice_t *wlandev, u32 ethconv,
 			       skb->len);
 			return 1;
 		}
-		if ((foo = wep_decrypt(wlandev, skb->data + payload_offset + 4,
+		foo = wep_decrypt(wlandev, skb->data + payload_offset + 4,
 				       payload_length - 8, -1,
 				       skb->data + payload_offset,
 				       skb->data + payload_offset +
-				       payload_length - 4))) {
+				       payload_length - 4);
+		if (foo) {
 			/* de-wep failed, drop skb. */
 			pr_debug("Host de-WEP failed, dropping frame (%d).\n",
 				 foo);

commit 5dd8acc8fd6b0476a2dc49bc6de4712d22c368c0
Author: Svenne Krap <svenne@krap.dk>
Date:   Sun Feb 14 18:59:00 2010 +0100

    Staging: wlan-ng: multiple safe style cleanups
    
    Cleanups as suggested by checkpatch.pl utiltiy.
    .o's from before and after cleanup have matching SHA1s.
    
    Signed-off-by: Svenne Krap <svenne@krap.dk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/wlan-ng/p80211conv.c b/drivers/staging/wlan-ng/p80211conv.c
index 5952c671073f..99c5ec45b00d 100644
--- a/drivers/staging/wlan-ng/p80211conv.c
+++ b/drivers/staging/wlan-ng/p80211conv.c
@@ -206,12 +206,12 @@ int skb_ether_to_p80211(wlandevice_t *wlandev, u32 ethconv,
 		/* XXXX need to pick keynum other than default? */
 
 		p80211_wep->data = kmalloc(skb->len, GFP_ATOMIC);
-
-		if ((foo = wep_encrypt(wlandev, skb->data, p80211_wep->data,
-				       skb->len,
-				       (wlandev->hostwep &
-					HOSTWEP_DEFAULTKEY_MASK),
-				       p80211_wep->iv, p80211_wep->icv))) {
+		foo = wep_encrypt(wlandev, skb->data, p80211_wep->data,
+			skb->len,
+			(wlandev->hostwep &
+			HOSTWEP_DEFAULTKEY_MASK),
+			p80211_wep->iv, p80211_wep->icv);
+		if (foo) {
 			printk(KERN_WARNING
 			       "Host en-WEP failed, dropping frame (%d).\n",
 			       foo);
@@ -323,11 +323,12 @@ int skb_p80211_to_ether(wlandevice_t *wlandev, u32 ethconv,
 			       skb->len);
 			return 1;
 		}
-		if ((foo = wep_decrypt(wlandev, skb->data + payload_offset + 4,
-				       payload_length - 8, -1,
-				       skb->data + payload_offset,
-				       skb->data + payload_offset +
-				       payload_length - 4))) {
+		foo = wep_decrypt(wlandev, skb->data + payload_offset + 4,
+			payload_length - 8, -1,
+			skb->data + payload_offset,
+			skb->data + payload_offset +
+			payload_length - 4);
+		if (foo) {
 			/* de-wep failed, drop skb. */
 			pr_debug("Host de-WEP failed, dropping frame (%d).\n",
 				 foo);

commit 297f06cea635ea4552541a11e7fb7014425110c6
Author: Mithlesh Thukral <mithlesh@linsyssoft.com>
Date:   Wed Jun 10 19:36:11 2009 +0530

    staging: wlan-ng: scripts/checkpatch.pl error fixes.
    
    scripts/checkpatch.pl error fixes. This is a TODO item.
    This patch fixes most of the errors reported by checkpatch.pl in
    wlan-ng directory of staging tree.
    
    Signed-off-by: Mithlesh Thukral <mithlesh@linsyssoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/wlan-ng/p80211conv.c b/drivers/staging/wlan-ng/p80211conv.c
index 8b4f3960d9bc..5952c671073f 100644
--- a/drivers/staging/wlan-ng/p80211conv.c
+++ b/drivers/staging/wlan-ng/p80211conv.c
@@ -102,9 +102,9 @@ static u8 oui_8021h[] = { 0x00, 0x00, 0xf8 };
 * Call context:
 *	May be called in interrupt or non-interrupt context
 ----------------------------------------------------------------*/
-int skb_ether_to_p80211(wlandevice_t * wlandev, u32 ethconv,
-			struct sk_buff *skb, p80211_hdr_t * p80211_hdr,
-			p80211_metawep_t * p80211_wep)
+int skb_ether_to_p80211(wlandevice_t *wlandev, u32 ethconv,
+			struct sk_buff *skb, p80211_hdr_t *p80211_hdr,
+			p80211_metawep_t *p80211_wep)
 {
 
 	u16 fc;
@@ -230,8 +230,8 @@ int skb_ether_to_p80211(wlandevice_t * wlandev, u32 ethconv,
 }
 
 /* jkriegl: from orinoco, modified */
-static void orinoco_spy_gather(wlandevice_t * wlandev, char *mac,
-			       p80211_rxmeta_t * rxmeta)
+static void orinoco_spy_gather(wlandevice_t *wlandev, char *mac,
+			       p80211_rxmeta_t *rxmeta)
 {
 	int i;
 
@@ -272,7 +272,7 @@ static void orinoco_spy_gather(wlandevice_t * wlandev, char *mac,
 * Call context:
 *	May be called in interrupt or non-interrupt context
 ----------------------------------------------------------------*/
-int skb_p80211_to_ether(wlandevice_t * wlandev, u32 ethconv,
+int skb_p80211_to_ether(wlandevice_t *wlandev, u32 ethconv,
 			struct sk_buff *skb)
 {
 	netdevice_t *netdev = wlandev->netdev;

commit 75f49e07520d036c2a0903694fdc0bcfb5523b76
Author: Mithlesh Thukral <mithlesh@linsyssoft.com>
Date:   Mon May 25 19:06:16 2009 +0530

    Staging: wlan-ng: Lindent cleanups
    
    Lindent script cleanups in wlan-ng driver in the staging tree.
    This is a item in the TODO list.
    
    Signed-off-by: Mithlesh Thukral <mithlesh@linsyssoft.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/wlan-ng/p80211conv.c b/drivers/staging/wlan-ng/p80211conv.c
index 44266b8618c9..8b4f3960d9bc 100644
--- a/drivers/staging/wlan-ng/p80211conv.c
+++ b/drivers/staging/wlan-ng/p80211conv.c
@@ -102,9 +102,9 @@ static u8 oui_8021h[] = { 0x00, 0x00, 0xf8 };
 * Call context:
 *	May be called in interrupt or non-interrupt context
 ----------------------------------------------------------------*/
-int skb_ether_to_p80211(wlandevice_t *wlandev, u32 ethconv,
-			struct sk_buff *skb, p80211_hdr_t *p80211_hdr,
-			p80211_metawep_t *p80211_wep)
+int skb_ether_to_p80211(wlandevice_t * wlandev, u32 ethconv,
+			struct sk_buff *skb, p80211_hdr_t * p80211_hdr,
+			p80211_metawep_t * p80211_wep)
 {
 
 	u16 fc;
@@ -209,8 +209,8 @@ int skb_ether_to_p80211(wlandevice_t *wlandev, u32 ethconv,
 
 		if ((foo = wep_encrypt(wlandev, skb->data, p80211_wep->data,
 				       skb->len,
-				       (wlandev->
-					hostwep & HOSTWEP_DEFAULTKEY_MASK),
+				       (wlandev->hostwep &
+					HOSTWEP_DEFAULTKEY_MASK),
 				       p80211_wep->iv, p80211_wep->icv))) {
 			printk(KERN_WARNING
 			       "Host en-WEP failed, dropping frame (%d).\n",
@@ -230,8 +230,8 @@ int skb_ether_to_p80211(wlandevice_t *wlandev, u32 ethconv,
 }
 
 /* jkriegl: from orinoco, modified */
-static void orinoco_spy_gather(wlandevice_t *wlandev, char *mac,
-			       p80211_rxmeta_t *rxmeta)
+static void orinoco_spy_gather(wlandevice_t * wlandev, char *mac,
+			       p80211_rxmeta_t * rxmeta)
 {
 	int i;
 
@@ -272,7 +272,7 @@ static void orinoco_spy_gather(wlandevice_t *wlandev, char *mac,
 * Call context:
 *	May be called in interrupt or non-interrupt context
 ----------------------------------------------------------------*/
-int skb_p80211_to_ether(wlandevice_t *wlandev, u32 ethconv,
+int skb_p80211_to_ether(wlandevice_t * wlandev, u32 ethconv,
 			struct sk_buff *skb)
 {
 	netdevice_t *netdev = wlandev->netdev;
@@ -329,9 +329,8 @@ int skb_p80211_to_ether(wlandevice_t *wlandev, u32 ethconv,
 				       skb->data + payload_offset +
 				       payload_length - 4))) {
 			/* de-wep failed, drop skb. */
-			pr_debug(
-			       "Host de-WEP failed, dropping frame (%d).\n",
-			       foo);
+			pr_debug("Host de-WEP failed, dropping frame (%d).\n",
+				 foo);
 			wlandev->rx.decrypt_err++;
 			return 2;
 		}

commit f2b50b40d1241b443da43fa66ae53bae93df910a
Author: Karl Relton <karllinuxtest.relton@ntlworld.com>
Date:   Fri May 8 20:54:17 2009 +0100

    Staging: wlan-ng: Change KERN_DEBUG or pr_debug to match orig driver
    
    Change uses of KERN_DEBUG over to pr_debug to match original driver
    where messages are only needed during driver development.
    
    Signed-off-by: Karl Relton <karllinuxtest.relton@ntlworld.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/wlan-ng/p80211conv.c b/drivers/staging/wlan-ng/p80211conv.c
index 2abce0c34444..44266b8618c9 100644
--- a/drivers/staging/wlan-ng/p80211conv.c
+++ b/drivers/staging/wlan-ng/p80211conv.c
@@ -329,7 +329,7 @@ int skb_p80211_to_ether(wlandevice_t *wlandev, u32 ethconv,
 				       skb->data + payload_offset +
 				       payload_length - 4))) {
 			/* de-wep failed, drop skb. */
-			printk(KERN_DEBUG
+			pr_debug(
 			       "Host de-WEP failed, dropping frame (%d).\n",
 			       foo);
 			wlandev->rx.decrypt_err++;

commit 465e7417b15348909606c3edce5f018818235a54
Author: Moritz Muehlenhoff <jmm@debian.org>
Date:   Mon Feb 9 19:33:44 2009 +0100

    Staging: wlan-ng: Remove the now empty wlan_compat.h
    
    Signed-off-by: Moritz Muehlenhoff <jmm@debian.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/wlan-ng/p80211conv.c b/drivers/staging/wlan-ng/p80211conv.c
index 123cb9a2b31d..2abce0c34444 100644
--- a/drivers/staging/wlan-ng/p80211conv.c
+++ b/drivers/staging/wlan-ng/p80211conv.c
@@ -65,8 +65,6 @@
 
 #include <asm/byteorder.h>
 
-#include "wlan_compat.h"
-
 #include "p80211types.h"
 #include "p80211hdr.h"
 #include "p80211conv.h"

commit 82eaca7d9a2ba1f619bf6eebb677add20235c1aa
Author: Moritz Muehlenhoff <jmm@debian.org>
Date:   Sun Feb 8 02:20:56 2009 +0100

    Staging: wlan-ng: p80211conv.c: Coding style cleanups
    
    Signed-off-by: Moritz Muehlenhoff <jmm@debian.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/wlan-ng/p80211conv.c b/drivers/staging/wlan-ng/p80211conv.c
index 724f3de77e21..123cb9a2b31d 100644
--- a/drivers/staging/wlan-ng/p80211conv.c
+++ b/drivers/staging/wlan-ng/p80211conv.c
@@ -48,10 +48,8 @@
 * 802.11 frame conversions.
 *
 * --------------------------------------------------------------------
-*/
-/*================================================================*/
-/* System Includes */
-
+*
+*================================================================ */
 
 #include <linux/module.h>
 #include <linux/kernel.h>
@@ -69,9 +67,6 @@
 
 #include "wlan_compat.h"
 
-/*================================================================*/
-/* Project Includes */
-
 #include "p80211types.h"
 #include "p80211hdr.h"
 #include "p80211conv.h"
@@ -81,15 +76,8 @@
 #include "p80211ioctl.h"
 #include "p80211req.h"
 
-
-/*================================================================*/
-/* Local Static Definitions */
-
-static u8	oui_rfc1042[] = {0x00, 0x00, 0x00};
-static u8	oui_8021h[] = {0x00, 0x00, 0xf8};
-
-/*================================================================*/
-/* Function Definitions */
+static u8 oui_rfc1042[] = { 0x00, 0x00, 0x00 };
+static u8 oui_8021h[] = { 0x00, 0x00, 0xf8 };
 
 /*----------------------------------------------------------------
 * p80211pb_ether_to_80211
@@ -116,14 +104,16 @@ static u8	oui_8021h[] = {0x00, 0x00, 0xf8};
 * Call context:
 *	May be called in interrupt or non-interrupt context
 ----------------------------------------------------------------*/
-int skb_ether_to_p80211( wlandevice_t *wlandev, u32 ethconv, struct sk_buff *skb, p80211_hdr_t *p80211_hdr, p80211_metawep_t *p80211_wep)
+int skb_ether_to_p80211(wlandevice_t *wlandev, u32 ethconv,
+			struct sk_buff *skb, p80211_hdr_t *p80211_hdr,
+			p80211_metawep_t *p80211_wep)
 {
 
-	u16          fc;
-	u16          proto;
-	wlan_ethhdr_t   e_hdr;
-	wlan_llc_t      *e_llc;
-	wlan_snap_t     *e_snap;
+	u16 fc;
+	u16 proto;
+	wlan_ethhdr_t e_hdr;
+	wlan_llc_t *e_llc;
+	wlan_snap_t *e_snap;
 	int foo;
 
 	memcpy(&e_hdr, skb->data, sizeof(e_hdr));
@@ -133,17 +123,17 @@ int skb_ether_to_p80211( wlandevice_t *wlandev, u32 ethconv, struct sk_buff *skb
 		return 1;
 	}
 
-	if ( ethconv == WLAN_ETHCONV_ENCAP ) { /* simplest case */
-	        pr_debug("ENCAP len: %d\n", skb->len);
+	if (ethconv == WLAN_ETHCONV_ENCAP) {	/* simplest case */
+		pr_debug("ENCAP len: %d\n", skb->len);
 		/* here, we don't care what kind of ether frm. Just stick it */
 		/*  in the 80211 payload */
 		/* which is to say, leave the skb alone. */
 	} else {
 		/* step 1: classify ether frame, DIX or 802.3? */
 		proto = ntohs(e_hdr.type);
-		if ( proto <= 1500 ) {
-		        pr_debug("802.3 len: %d\n", skb->len);
-                        /* codes <= 1500 reserved for 802.3 lengths */
+		if (proto <= 1500) {
+			pr_debug("802.3 len: %d\n", skb->len);
+			/* codes <= 1500 reserved for 802.3 lengths */
 			/* it's 802.3, pass ether payload unchanged,  */
 
 			/* trim off ethernet header */
@@ -152,23 +142,28 @@ int skb_ether_to_p80211( wlandevice_t *wlandev, u32 ethconv, struct sk_buff *skb
 			/*   leave off any PAD octets.  */
 			skb_trim(skb, proto);
 		} else {
-		        pr_debug("DIXII len: %d\n", skb->len);
+			pr_debug("DIXII len: %d\n", skb->len);
 			/* it's DIXII, time for some conversion */
 
 			/* trim off ethernet header */
 			skb_pull(skb, WLAN_ETHHDR_LEN);
 
 			/* tack on SNAP */
-			e_snap = (wlan_snap_t *) skb_push(skb, sizeof(wlan_snap_t));
+			e_snap =
+			    (wlan_snap_t *) skb_push(skb, sizeof(wlan_snap_t));
 			e_snap->type = htons(proto);
-			if ( ethconv == WLAN_ETHCONV_8021h && p80211_stt_findproto(proto) ) {
-				memcpy( e_snap->oui, oui_8021h, WLAN_IEEE_OUI_LEN);
+			if (ethconv == WLAN_ETHCONV_8021h
+			    && p80211_stt_findproto(proto)) {
+				memcpy(e_snap->oui, oui_8021h,
+				       WLAN_IEEE_OUI_LEN);
 			} else {
-				memcpy( e_snap->oui, oui_rfc1042, WLAN_IEEE_OUI_LEN);
+				memcpy(e_snap->oui, oui_rfc1042,
+				       WLAN_IEEE_OUI_LEN);
 			}
 
 			/* tack on llc */
-			e_llc = (wlan_llc_t *) skb_push(skb, sizeof(wlan_llc_t));
+			e_llc =
+			    (wlan_llc_t *) skb_push(skb, sizeof(wlan_llc_t));
 			e_llc->dsap = 0xAA;	/* SNAP, see IEEE 802 */
 			e_llc->ssap = 0xAA;
 			e_llc->ctl = 0x03;
@@ -178,10 +173,10 @@ int skb_ether_to_p80211( wlandevice_t *wlandev, u32 ethconv, struct sk_buff *skb
 
 	/* Set up the 802.11 header */
 	/* It's a data frame */
-	fc = cpu_to_le16( WLAN_SET_FC_FTYPE(WLAN_FTYPE_DATA) |
-			  WLAN_SET_FC_FSTYPE(WLAN_FSTYPE_DATAONLY));
+	fc = cpu_to_le16(WLAN_SET_FC_FTYPE(WLAN_FTYPE_DATA) |
+			 WLAN_SET_FC_FSTYPE(WLAN_FSTYPE_DATAONLY));
 
-	switch ( wlandev->macmode ) {
+	switch (wlandev->macmode) {
 	case WLAN_MACMODE_IBSS_STA:
 		memcpy(p80211_hdr->a3.a1, &e_hdr.daddr, ETH_ALEN);
 		memcpy(p80211_hdr->a3.a2, wlandev->netdev->dev_addr, ETH_ALEN);
@@ -200,30 +195,34 @@ int skb_ether_to_p80211( wlandevice_t *wlandev, u32 ethconv, struct sk_buff *skb
 		memcpy(p80211_hdr->a3.a3, &e_hdr.saddr, ETH_ALEN);
 		break;
 	default:
-		printk(KERN_ERR "Error: Converting eth to wlan in unknown mode.\n");
+		printk(KERN_ERR
+		       "Error: Converting eth to wlan in unknown mode.\n");
 		return 1;
 		break;
 	}
 
 	p80211_wep->data = NULL;
 
-	if ((wlandev->hostwep & HOSTWEP_PRIVACYINVOKED) && (wlandev->hostwep & HOSTWEP_ENCRYPT)) {
-		// XXXX need to pick keynum other than default?
+	if ((wlandev->hostwep & HOSTWEP_PRIVACYINVOKED)
+	    && (wlandev->hostwep & HOSTWEP_ENCRYPT)) {
+		/* XXXX need to pick keynum other than default? */
 
 		p80211_wep->data = kmalloc(skb->len, GFP_ATOMIC);
 
 		if ((foo = wep_encrypt(wlandev, skb->data, p80211_wep->data,
 				       skb->len,
-				(wlandev->hostwep & HOSTWEP_DEFAULTKEY_MASK),
-				p80211_wep->iv, p80211_wep->icv))) {
-			printk(KERN_WARNING "Host en-WEP failed, dropping frame (%d).\n", foo);
+				       (wlandev->
+					hostwep & HOSTWEP_DEFAULTKEY_MASK),
+				       p80211_wep->iv, p80211_wep->icv))) {
+			printk(KERN_WARNING
+			       "Host en-WEP failed, dropping frame (%d).\n",
+			       foo);
 			return 2;
 		}
 		fc |= cpu_to_le16(WLAN_SET_FC_ISWEP(1));
 	}
 
-
-	//	skb->nh.raw = skb->data;
+	/*      skb->nh.raw = skb->data; */
 
 	p80211_hdr->a3.fc = fc;
 	p80211_hdr->a3.dur = 0;
@@ -236,22 +235,24 @@ int skb_ether_to_p80211( wlandevice_t *wlandev, u32 ethconv, struct sk_buff *skb
 static void orinoco_spy_gather(wlandevice_t *wlandev, char *mac,
 			       p80211_rxmeta_t *rxmeta)
 {
-        int i;
+	int i;
 
-        /* Gather wireless spy statistics: for each packet, compare the
-         * source address with out list, and if match, get the stats... */
+	/* Gather wireless spy statistics: for each packet, compare the
+	 * source address with out list, and if match, get the stats... */
 
-        for (i = 0; i < wlandev->spy_number; i++) {
+	for (i = 0; i < wlandev->spy_number; i++) {
 
-                if (!memcmp(wlandev->spy_address[i], mac, ETH_ALEN)) {
+		if (!memcmp(wlandev->spy_address[i], mac, ETH_ALEN)) {
 			memcpy(wlandev->spy_address[i], mac, ETH_ALEN);
-                        wlandev->spy_stat[i].level = rxmeta->signal;
-                        wlandev->spy_stat[i].noise = rxmeta->noise;
-                        wlandev->spy_stat[i].qual = (rxmeta->signal > rxmeta->noise) ? \
-                                                     (rxmeta->signal - rxmeta->noise) : 0;
-                        wlandev->spy_stat[i].updated = 0x7;
-                }
-        }
+			wlandev->spy_stat[i].level = rxmeta->signal;
+			wlandev->spy_stat[i].noise = rxmeta->noise;
+			wlandev->spy_stat[i].qual =
+			    (rxmeta->signal >
+			     rxmeta->noise) ? (rxmeta->signal -
+					       rxmeta->noise) : 0;
+			wlandev->spy_stat[i].updated = 0x7;
+		}
+	}
 }
 
 /*----------------------------------------------------------------
@@ -273,18 +274,19 @@ static void orinoco_spy_gather(wlandevice_t *wlandev, char *mac,
 * Call context:
 *	May be called in interrupt or non-interrupt context
 ----------------------------------------------------------------*/
-int skb_p80211_to_ether( wlandevice_t *wlandev, u32 ethconv, struct sk_buff *skb)
+int skb_p80211_to_ether(wlandevice_t *wlandev, u32 ethconv,
+			struct sk_buff *skb)
 {
-	netdevice_t     *netdev = wlandev->netdev;
-	u16          fc;
-	unsigned int            payload_length;
-	unsigned int            payload_offset;
-	u8		daddr[WLAN_ETHADDR_LEN];
-	u8		saddr[WLAN_ETHADDR_LEN];
-	p80211_hdr_t    *w_hdr;
-	wlan_ethhdr_t   *e_hdr;
-	wlan_llc_t      *e_llc;
-	wlan_snap_t     *e_snap;
+	netdevice_t *netdev = wlandev->netdev;
+	u16 fc;
+	unsigned int payload_length;
+	unsigned int payload_offset;
+	u8 daddr[WLAN_ETHADDR_LEN];
+	u8 saddr[WLAN_ETHADDR_LEN];
+	p80211_hdr_t *w_hdr;
+	wlan_ethhdr_t *e_hdr;
+	wlan_llc_t *e_llc;
+	wlan_snap_t *e_snap;
 
 	int foo;
 
@@ -293,15 +295,15 @@ int skb_p80211_to_ether( wlandevice_t *wlandev, u32 ethconv, struct sk_buff *skb
 
 	w_hdr = (p80211_hdr_t *) skb->data;
 
-        /* setup some vars for convenience */
+	/* setup some vars for convenience */
 	fc = le16_to_cpu(w_hdr->a3.fc);
-	if ( (WLAN_GET_FC_TODS(fc) == 0) && (WLAN_GET_FC_FROMDS(fc) == 0) ) {
+	if ((WLAN_GET_FC_TODS(fc) == 0) && (WLAN_GET_FC_FROMDS(fc) == 0)) {
 		memcpy(daddr, w_hdr->a3.a1, WLAN_ETHADDR_LEN);
 		memcpy(saddr, w_hdr->a3.a2, WLAN_ETHADDR_LEN);
-	} else if( (WLAN_GET_FC_TODS(fc) == 0) && (WLAN_GET_FC_FROMDS(fc) == 1) ) {
+	} else if ((WLAN_GET_FC_TODS(fc) == 0) && (WLAN_GET_FC_FROMDS(fc) == 1)) {
 		memcpy(daddr, w_hdr->a3.a1, WLAN_ETHADDR_LEN);
 		memcpy(saddr, w_hdr->a3.a3, WLAN_ETHADDR_LEN);
-	} else if( (WLAN_GET_FC_TODS(fc) == 1) && (WLAN_GET_FC_FROMDS(fc) == 0) ) {
+	} else if ((WLAN_GET_FC_TODS(fc) == 1) && (WLAN_GET_FC_FROMDS(fc) == 0)) {
 		memcpy(daddr, w_hdr->a3.a3, WLAN_ETHADDR_LEN);
 		memcpy(saddr, w_hdr->a3.a2, WLAN_ETHADDR_LEN);
 	} else {
@@ -316,18 +318,22 @@ int skb_p80211_to_ether( wlandevice_t *wlandev, u32 ethconv, struct sk_buff *skb
 	}
 
 	/* perform de-wep if necessary.. */
-	if ((wlandev->hostwep & HOSTWEP_PRIVACYINVOKED) && WLAN_GET_FC_ISWEP(fc) && (wlandev->hostwep & HOSTWEP_DECRYPT)) {
+	if ((wlandev->hostwep & HOSTWEP_PRIVACYINVOKED) && WLAN_GET_FC_ISWEP(fc)
+	    && (wlandev->hostwep & HOSTWEP_DECRYPT)) {
 		if (payload_length <= 8) {
 			printk(KERN_ERR "WEP frame too short (%u).\n",
-					skb->len);
+			       skb->len);
 			return 1;
 		}
 		if ((foo = wep_decrypt(wlandev, skb->data + payload_offset + 4,
 				       payload_length - 8, -1,
 				       skb->data + payload_offset,
-				       skb->data + payload_offset + payload_length - 4))) {
+				       skb->data + payload_offset +
+				       payload_length - 4))) {
 			/* de-wep failed, drop skb. */
-			pr_debug("Host de-WEP failed, dropping frame (%d).\n", foo);
+			printk(KERN_DEBUG
+			       "Host de-WEP failed, dropping frame (%d).\n",
+			       foo);
 			wlandev->rx.decrypt_err++;
 			return 2;
 		}
@@ -345,21 +351,22 @@ int skb_p80211_to_ether( wlandevice_t *wlandev, u32 ethconv, struct sk_buff *skb
 	e_hdr = (wlan_ethhdr_t *) (skb->data + payload_offset);
 
 	e_llc = (wlan_llc_t *) (skb->data + payload_offset);
-	e_snap = (wlan_snap_t *) (skb->data + payload_offset + sizeof(wlan_llc_t));
+	e_snap =
+	    (wlan_snap_t *) (skb->data + payload_offset + sizeof(wlan_llc_t));
 
 	/* Test for the various encodings */
-	if ( (payload_length >= sizeof(wlan_ethhdr_t)) &&
-	     ( e_llc->dsap != 0xaa || e_llc->ssap != 0xaa ) &&
-	     ((memcmp(daddr, e_hdr->daddr, WLAN_ETHADDR_LEN) == 0) ||
+	if ((payload_length >= sizeof(wlan_ethhdr_t)) &&
+	    (e_llc->dsap != 0xaa || e_llc->ssap != 0xaa) &&
+	    ((memcmp(daddr, e_hdr->daddr, WLAN_ETHADDR_LEN) == 0) ||
 	     (memcmp(saddr, e_hdr->saddr, WLAN_ETHADDR_LEN) == 0))) {
 		pr_debug("802.3 ENCAP len: %d\n", payload_length);
 		/* 802.3 Encapsulated */
 		/* Test for an overlength frame */
-		if ( payload_length > (netdev->mtu + WLAN_ETHHDR_LEN)) {
+		if (payload_length > (netdev->mtu + WLAN_ETHHDR_LEN)) {
 			/* A bogus length ethfrm has been encap'd. */
 			/* Is someone trying an oflow attack? */
 			printk(KERN_ERR "ENCAP frame too large (%d > %d)\n",
-				payload_length, netdev->mtu + WLAN_ETHHDR_LEN);
+			       payload_length, netdev->mtu + WLAN_ETHHDR_LEN);
 			return 1;
 		}
 
@@ -368,25 +375,25 @@ int skb_p80211_to_ether( wlandevice_t *wlandev, u32 ethconv, struct sk_buff *skb
 		/* chop off the 802.11 CRC */
 		skb_trim(skb, skb->len - WLAN_CRC_LEN);
 
-	} else if ((payload_length >= sizeof(wlan_llc_t) + sizeof(wlan_snap_t)) &&
-		   (e_llc->dsap == 0xaa) &&
-		   (e_llc->ssap == 0xaa) &&
-		   (e_llc->ctl == 0x03) &&
-		   (((memcmp( e_snap->oui, oui_rfc1042, WLAN_IEEE_OUI_LEN)==0) &&
-		    (ethconv == WLAN_ETHCONV_8021h) &&
-		    (p80211_stt_findproto(le16_to_cpu(e_snap->type)))) ||
-		    (memcmp( e_snap->oui, oui_rfc1042, WLAN_IEEE_OUI_LEN)!=0)))
-	{
+	} else if ((payload_length >= sizeof(wlan_llc_t) + sizeof(wlan_snap_t))
+		   && (e_llc->dsap == 0xaa) && (e_llc->ssap == 0xaa)
+		   && (e_llc->ctl == 0x03)
+		   &&
+		   (((memcmp(e_snap->oui, oui_rfc1042, WLAN_IEEE_OUI_LEN) == 0)
+		     && (ethconv == WLAN_ETHCONV_8021h)
+		     && (p80211_stt_findproto(le16_to_cpu(e_snap->type))))
+		    || (memcmp(e_snap->oui, oui_rfc1042, WLAN_IEEE_OUI_LEN) !=
+			0))) {
 		pr_debug("SNAP+RFC1042 len: %d\n", payload_length);
 		/* it's a SNAP + RFC1042 frame && protocol is in STT */
 		/* build 802.3 + RFC1042 */
 
 		/* Test for an overlength frame */
-		if ( payload_length > netdev->mtu ) {
+		if (payload_length > netdev->mtu) {
 			/* A bogus length ethfrm has been sent. */
 			/* Is someone trying an oflow attack? */
 			printk(KERN_ERR "SNAP frame too large (%d > %d)\n",
-				payload_length, netdev->mtu);
+			       payload_length, netdev->mtu);
 			return 1;
 		}
 
@@ -402,10 +409,9 @@ int skb_p80211_to_ether( wlandevice_t *wlandev, u32 ethconv, struct sk_buff *skb
 		/* chop off the 802.11 CRC */
 		skb_trim(skb, skb->len - WLAN_CRC_LEN);
 
-	}  else if ((payload_length >= sizeof(wlan_llc_t) + sizeof(wlan_snap_t)) &&
-		    (e_llc->dsap == 0xaa) &&
-		    (e_llc->ssap == 0xaa) &&
-		    (e_llc->ctl == 0x03) ) {
+	} else if ((payload_length >= sizeof(wlan_llc_t) + sizeof(wlan_snap_t))
+		   && (e_llc->dsap == 0xaa) && (e_llc->ssap == 0xaa)
+		   && (e_llc->ctl == 0x03)) {
 		pr_debug("802.1h/RFC1042 len: %d\n", payload_length);
 		/* it's an 802.1h frame || (an RFC1042 && protocol is not in STT) */
 		/* build a DIXII + RFC894 */
@@ -416,9 +422,8 @@ int skb_p80211_to_ether( wlandevice_t *wlandev, u32 ethconv, struct sk_buff *skb
 			/* A bogus length ethfrm has been sent. */
 			/* Is someone trying an oflow attack? */
 			printk(KERN_ERR "DIXII frame too large (%ld > %d)\n",
-					(long int) (payload_length - sizeof(wlan_llc_t) -
-						    sizeof(wlan_snap_t)),
-					netdev->mtu);
+			       (long int)(payload_length - sizeof(wlan_llc_t) -
+					  sizeof(wlan_snap_t)), netdev->mtu);
 			return 1;
 		}
 
@@ -447,12 +452,11 @@ int skb_p80211_to_ether( wlandevice_t *wlandev, u32 ethconv, struct sk_buff *skb
 		/* allocate space and setup hostbuf */
 
 		/* Test for an overlength frame */
-		if ( payload_length > netdev->mtu ) {
+		if (payload_length > netdev->mtu) {
 			/* A bogus length ethfrm has been sent. */
 			/* Is someone trying an oflow attack? */
 			printk(KERN_ERR "OTHER frame too large (%d > %d)\n",
-				payload_length,
-				netdev->mtu);
+			       payload_length, netdev->mtu);
 			return 1;
 		}
 
@@ -470,21 +474,22 @@ int skb_p80211_to_ether( wlandevice_t *wlandev, u32 ethconv, struct sk_buff *skb
 
 	}
 
-        /*
-         * Note that eth_type_trans() expects an skb w/ skb->data pointing
-         * at the MAC header, it then sets the following skb members:
-         * skb->mac_header,
-         * skb->data, and
-         * skb->pkt_type.
-         * It then _returns_ the value that _we're_ supposed to stuff in
-         * skb->protocol.  This is nuts.
-         */
+	/*
+	 * Note that eth_type_trans() expects an skb w/ skb->data pointing
+	 * at the MAC header, it then sets the following skb members:
+	 * skb->mac_header,
+	 * skb->data, and
+	 * skb->pkt_type.
+	 * It then _returns_ the value that _we're_ supposed to stuff in
+	 * skb->protocol.  This is nuts.
+	 */
 	skb->protocol = eth_type_trans(skb, netdev);
 
-        /* jkriegl: process signal and noise as set in hfa384x_int_rx() */
+	/* jkriegl: process signal and noise as set in hfa384x_int_rx() */
 	/* jkriegl: only process signal/noise if requested by iwspy */
-        if (wlandev->spy_number)
-                orinoco_spy_gather(wlandev, eth_hdr(skb)->h_source, P80211SKB_RXMETA(skb));
+	if (wlandev->spy_number)
+		orinoco_spy_gather(wlandev, eth_hdr(skb)->h_source,
+				   P80211SKB_RXMETA(skb));
 
 	/* Free the metadata */
 	p80211skb_rxmeta_detach(skb);
@@ -513,11 +518,11 @@ int p80211_stt_findproto(u16 proto)
 	/* Always return found for now.  This is the behavior used by the */
 	/*  Zoom Win95 driver when 802.1h mode is selected */
 	/* TODO: If necessary, add an actual search we'll probably
-		 need this to match the CMAC's way of doing things.
-		 Need to do some testing to confirm.
-	*/
+	   need this to match the CMAC's way of doing things.
+	   Need to do some testing to confirm.
+	 */
 
-	if (proto == 0x80f3)  /* APPLETALK */
+	if (proto == 0x80f3)	/* APPLETALK */
 		return 1;
 
 	return 0;
@@ -538,24 +543,23 @@ int p80211_stt_findproto(u16 proto)
 * Call context:
 *	May be called in interrupt or non-interrupt context
 ----------------------------------------------------------------*/
-void
-p80211skb_rxmeta_detach(struct sk_buff *skb)
+void p80211skb_rxmeta_detach(struct sk_buff *skb)
 {
-	p80211_rxmeta_t		*rxmeta;
-	p80211_frmmeta_t	*frmmeta;
+	p80211_rxmeta_t *rxmeta;
+	p80211_frmmeta_t *frmmeta;
 
 	/* Sanity checks */
-	if ( skb==NULL ) {			/* bad skb */
+	if (skb == NULL) {	/* bad skb */
 		pr_debug("Called w/ null skb.\n");
 		goto exit;
 	}
 	frmmeta = P80211SKB_FRMMETA(skb);
-	if ( frmmeta == NULL ) { 		/* no magic */
+	if (frmmeta == NULL) {	/* no magic */
 		pr_debug("Called w/ bad frmmeta magic.\n");
 		goto exit;
 	}
 	rxmeta = frmmeta->rx;
-	if ( rxmeta == NULL ) {			/* bad meta ptr */
+	if (rxmeta == NULL) {	/* bad meta ptr */
 		pr_debug("Called w/ bad rxmeta ptr.\n");
 		goto exit;
 	}
@@ -585,17 +589,16 @@ p80211skb_rxmeta_detach(struct sk_buff *skb)
 * Call context:
 *	May be called in interrupt or non-interrupt context
 ----------------------------------------------------------------*/
-int
-p80211skb_rxmeta_attach(struct wlandevice *wlandev, struct sk_buff *skb)
+int p80211skb_rxmeta_attach(struct wlandevice *wlandev, struct sk_buff *skb)
 {
-	int			result = 0;
-	p80211_rxmeta_t		*rxmeta;
-	p80211_frmmeta_t	*frmmeta;
+	int result = 0;
+	p80211_rxmeta_t *rxmeta;
+	p80211_frmmeta_t *frmmeta;
 
 	/* If these already have metadata, we error out! */
 	if (P80211SKB_RXMETA(skb) != NULL) {
 		printk(KERN_ERR "%s: RXmeta already attached!\n",
-				wlandev->name);
+		       wlandev->name);
 		result = 0;
 		goto exit;
 	}
@@ -603,9 +606,9 @@ p80211skb_rxmeta_attach(struct wlandevice *wlandev, struct sk_buff *skb)
 	/* Allocate the rxmeta */
 	rxmeta = kmalloc(sizeof(p80211_rxmeta_t), GFP_ATOMIC);
 
-	if ( rxmeta == NULL ) {
+	if (rxmeta == NULL) {
 		printk(KERN_ERR "%s: Failed to allocate rxmeta.\n",
-				wlandev->name);
+		       wlandev->name);
 		result = 1;
 		goto exit;
 	}
@@ -617,7 +620,7 @@ p80211skb_rxmeta_attach(struct wlandevice *wlandev, struct sk_buff *skb)
 
 	/* Overlay a frmmeta_t onto skb->cb */
 	memset(skb->cb, 0, sizeof(p80211_frmmeta_t));
-	frmmeta = (p80211_frmmeta_t*)(skb->cb);
+	frmmeta = (p80211_frmmeta_t *) (skb->cb);
 	frmmeta->magic = P80211_FRMMETA_MAGIC;
 	frmmeta->rx = rxmeta;
 exit:
@@ -640,18 +643,15 @@ p80211skb_rxmeta_attach(struct wlandevice *wlandev, struct sk_buff *skb)
 * Call context:
 *	May be called in interrupt or non-interrupt context
 ----------------------------------------------------------------*/
-void
-p80211skb_free(struct wlandevice *wlandev, struct sk_buff *skb)
+void p80211skb_free(struct wlandevice *wlandev, struct sk_buff *skb)
 {
-	p80211_frmmeta_t	*meta;
+	p80211_frmmeta_t *meta;
 
 	meta = P80211SKB_FRMMETA(skb);
-	if ( meta && meta->rx) {
+	if (meta && meta->rx)
 		p80211skb_rxmeta_detach(skb);
-	} else {
+	else
 		printk(KERN_ERR "Freeing an skb (%p) w/ no frmmeta.\n", skb);
-	}
-
 	dev_kfree_skb(skb);
 	return;
 }

commit a7cf7bae3297f16bb4a2f00310377fec06d0ecd6
Author: Moritz Muehlenhoff <jmm@debian.org>
Date:   Sun Feb 8 02:01:00 2009 +0100

    Staging: wlan-ng: Replace WLAN_LOG_DEBUG() with printk(KERN_DEBUG
    
    Signed-off-by: Moritz Muehlenhoff <jmm@debian.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/wlan-ng/p80211conv.c b/drivers/staging/wlan-ng/p80211conv.c
index b2d6ae53cab6..724f3de77e21 100644
--- a/drivers/staging/wlan-ng/p80211conv.c
+++ b/drivers/staging/wlan-ng/p80211conv.c
@@ -129,12 +129,12 @@ int skb_ether_to_p80211( wlandevice_t *wlandev, u32 ethconv, struct sk_buff *skb
 	memcpy(&e_hdr, skb->data, sizeof(e_hdr));
 
 	if (skb->len <= 0) {
-		WLAN_LOG_DEBUG(1, "zero-length skb!\n");
+		pr_debug("zero-length skb!\n");
 		return 1;
 	}
 
 	if ( ethconv == WLAN_ETHCONV_ENCAP ) { /* simplest case */
-	        WLAN_LOG_DEBUG(3, "ENCAP len: %d\n", skb->len);
+	        pr_debug("ENCAP len: %d\n", skb->len);
 		/* here, we don't care what kind of ether frm. Just stick it */
 		/*  in the 80211 payload */
 		/* which is to say, leave the skb alone. */
@@ -142,7 +142,7 @@ int skb_ether_to_p80211( wlandevice_t *wlandev, u32 ethconv, struct sk_buff *skb
 		/* step 1: classify ether frame, DIX or 802.3? */
 		proto = ntohs(e_hdr.type);
 		if ( proto <= 1500 ) {
-		        WLAN_LOG_DEBUG(3, "802.3 len: %d\n", skb->len);
+		        pr_debug("802.3 len: %d\n", skb->len);
                         /* codes <= 1500 reserved for 802.3 lengths */
 			/* it's 802.3, pass ether payload unchanged,  */
 
@@ -152,7 +152,7 @@ int skb_ether_to_p80211( wlandevice_t *wlandev, u32 ethconv, struct sk_buff *skb
 			/*   leave off any PAD octets.  */
 			skb_trim(skb, proto);
 		} else {
-		        WLAN_LOG_DEBUG(3, "DIXII len: %d\n", skb->len);
+		        pr_debug("DIXII len: %d\n", skb->len);
 			/* it's DIXII, time for some conversion */
 
 			/* trim off ethernet header */
@@ -327,7 +327,7 @@ int skb_p80211_to_ether( wlandevice_t *wlandev, u32 ethconv, struct sk_buff *skb
 				       skb->data + payload_offset,
 				       skb->data + payload_offset + payload_length - 4))) {
 			/* de-wep failed, drop skb. */
-			WLAN_LOG_DEBUG(1, "Host de-WEP failed, dropping frame (%d).\n", foo);
+			pr_debug("Host de-WEP failed, dropping frame (%d).\n", foo);
 			wlandev->rx.decrypt_err++;
 			return 2;
 		}
@@ -352,7 +352,7 @@ int skb_p80211_to_ether( wlandevice_t *wlandev, u32 ethconv, struct sk_buff *skb
 	     ( e_llc->dsap != 0xaa || e_llc->ssap != 0xaa ) &&
 	     ((memcmp(daddr, e_hdr->daddr, WLAN_ETHADDR_LEN) == 0) ||
 	     (memcmp(saddr, e_hdr->saddr, WLAN_ETHADDR_LEN) == 0))) {
-		WLAN_LOG_DEBUG(3, "802.3 ENCAP len: %d\n", payload_length);
+		pr_debug("802.3 ENCAP len: %d\n", payload_length);
 		/* 802.3 Encapsulated */
 		/* Test for an overlength frame */
 		if ( payload_length > (netdev->mtu + WLAN_ETHHDR_LEN)) {
@@ -377,7 +377,7 @@ int skb_p80211_to_ether( wlandevice_t *wlandev, u32 ethconv, struct sk_buff *skb
 		    (p80211_stt_findproto(le16_to_cpu(e_snap->type)))) ||
 		    (memcmp( e_snap->oui, oui_rfc1042, WLAN_IEEE_OUI_LEN)!=0)))
 	{
-		WLAN_LOG_DEBUG(3, "SNAP+RFC1042 len: %d\n", payload_length);
+		pr_debug("SNAP+RFC1042 len: %d\n", payload_length);
 		/* it's a SNAP + RFC1042 frame && protocol is in STT */
 		/* build 802.3 + RFC1042 */
 
@@ -406,7 +406,7 @@ int skb_p80211_to_ether( wlandevice_t *wlandev, u32 ethconv, struct sk_buff *skb
 		    (e_llc->dsap == 0xaa) &&
 		    (e_llc->ssap == 0xaa) &&
 		    (e_llc->ctl == 0x03) ) {
-		WLAN_LOG_DEBUG(3, "802.1h/RFC1042 len: %d\n", payload_length);
+		pr_debug("802.1h/RFC1042 len: %d\n", payload_length);
 		/* it's an 802.1h frame || (an RFC1042 && protocol is not in STT) */
 		/* build a DIXII + RFC894 */
 
@@ -440,7 +440,7 @@ int skb_p80211_to_ether( wlandevice_t *wlandev, u32 ethconv, struct sk_buff *skb
 		/* chop off the 802.11 CRC */
 		skb_trim(skb, skb->len - WLAN_CRC_LEN);
 	} else {
-		WLAN_LOG_DEBUG(3, "NON-ENCAP len: %d\n", payload_length);
+		pr_debug("NON-ENCAP len: %d\n", payload_length);
 		/* any NON-ENCAP */
 		/* it's a generic 80211+LLC or IPX 'Raw 802.3' */
 		/*  build an 802.3 frame */
@@ -546,17 +546,17 @@ p80211skb_rxmeta_detach(struct sk_buff *skb)
 
 	/* Sanity checks */
 	if ( skb==NULL ) {			/* bad skb */
-		WLAN_LOG_DEBUG(1, "Called w/ null skb.\n");
+		pr_debug("Called w/ null skb.\n");
 		goto exit;
 	}
 	frmmeta = P80211SKB_FRMMETA(skb);
 	if ( frmmeta == NULL ) { 		/* no magic */
-		WLAN_LOG_DEBUG(1, "Called w/ bad frmmeta magic.\n");
+		pr_debug("Called w/ bad frmmeta magic.\n");
 		goto exit;
 	}
 	rxmeta = frmmeta->rx;
 	if ( rxmeta == NULL ) {			/* bad meta ptr */
-		WLAN_LOG_DEBUG(1, "Called w/ bad rxmeta ptr.\n");
+		pr_debug("Called w/ bad rxmeta ptr.\n");
 		goto exit;
 	}
 

commit 944be922b7213fb844076051e99c2acae3c73676
Author: Moritz Muehlenhoff <jmm@debian.org>
Date:   Sun Jan 25 21:55:09 2009 +0100

    Staging: wlan-ng: Remove dead/unused code from p80211conv.c
    
    Signed-off-by: Moritz Muehlenhoff <jmm@debian.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/wlan-ng/p80211conv.c b/drivers/staging/wlan-ng/p80211conv.c
index c1b1afacadb4..b2d6ae53cab6 100644
--- a/drivers/staging/wlan-ng/p80211conv.c
+++ b/drivers/staging/wlan-ng/p80211conv.c
@@ -82,27 +82,12 @@
 #include "p80211req.h"
 
 
-/*================================================================*/
-/* Local Constants */
-
-/*================================================================*/
-/* Local Macros */
-
-
-/*================================================================*/
-/* Local Types */
-
-
 /*================================================================*/
 /* Local Static Definitions */
 
 static u8	oui_rfc1042[] = {0x00, 0x00, 0x00};
 static u8	oui_8021h[] = {0x00, 0x00, 0xf8};
 
-/*================================================================*/
-/* Local Function Declarations */
-
-
 /*================================================================*/
 /* Function Definitions */
 
@@ -225,11 +210,7 @@ int skb_ether_to_p80211( wlandevice_t *wlandev, u32 ethconv, struct sk_buff *skb
 	if ((wlandev->hostwep & HOSTWEP_PRIVACYINVOKED) && (wlandev->hostwep & HOSTWEP_ENCRYPT)) {
 		// XXXX need to pick keynum other than default?
 
-#if 1
 		p80211_wep->data = kmalloc(skb->len, GFP_ATOMIC);
-#else
-		p80211_wep->data = skb->data;
-#endif
 
 		if ((foo = wep_encrypt(wlandev, skb->data, p80211_wep->data,
 				       skb->len,

commit 9b9556ecc4bd8279aec195de84fd7d45a9883547
Author: Moritz Muehlenhoff <jmm@debian.org>
Date:   Sun Jan 25 21:55:01 2009 +0100

    Staging: wlan-ng: Replace WLAN_LOG_WARNING() with printk()
    
    Signed-off-by: Moritz Muehlenhoff <jmm@debian.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/wlan-ng/p80211conv.c b/drivers/staging/wlan-ng/p80211conv.c
index a153c4e91d5f..c1b1afacadb4 100644
--- a/drivers/staging/wlan-ng/p80211conv.c
+++ b/drivers/staging/wlan-ng/p80211conv.c
@@ -235,7 +235,7 @@ int skb_ether_to_p80211( wlandevice_t *wlandev, u32 ethconv, struct sk_buff *skb
 				       skb->len,
 				(wlandev->hostwep & HOSTWEP_DEFAULTKEY_MASK),
 				p80211_wep->iv, p80211_wep->icv))) {
-			WLAN_LOG_WARNING("Host en-WEP failed, dropping frame (%d).\n", foo);
+			printk(KERN_WARNING "Host en-WEP failed, dropping frame (%d).\n", foo);
 			return 2;
 		}
 		fc |= cpu_to_le16(WLAN_SET_FC_ISWEP(1));

commit edbd606c4671fcd439164c8d63e896044d706156
Author: Moritz Muehlenhoff <jmm@debian.org>
Date:   Sun Jan 25 21:55:00 2009 +0100

    Staging: wlan-ng: Replace WLAN_LOG_ERROR() with printk()
    
    Signed-off-by: Moritz Muehlenhoff <jmm@debian.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/wlan-ng/p80211conv.c b/drivers/staging/wlan-ng/p80211conv.c
index c3719249f013..a153c4e91d5f 100644
--- a/drivers/staging/wlan-ng/p80211conv.c
+++ b/drivers/staging/wlan-ng/p80211conv.c
@@ -215,7 +215,7 @@ int skb_ether_to_p80211( wlandevice_t *wlandev, u32 ethconv, struct sk_buff *skb
 		memcpy(p80211_hdr->a3.a3, &e_hdr.saddr, ETH_ALEN);
 		break;
 	default:
-		WLAN_LOG_ERROR("Error: Converting eth to wlan in unknown mode.\n");
+		printk(KERN_ERR "Error: Converting eth to wlan in unknown mode.\n");
 		return 1;
 		break;
 	}
@@ -326,7 +326,7 @@ int skb_p80211_to_ether( wlandevice_t *wlandev, u32 ethconv, struct sk_buff *skb
 	} else {
 		payload_offset = WLAN_HDR_A4_LEN;
 		if (payload_length < WLAN_HDR_A4_LEN - WLAN_HDR_A3_LEN) {
-			WLAN_LOG_ERROR("A4 frame too short!\n");
+			printk(KERN_ERR "A4 frame too short!\n");
 			return 1;
 		}
 		payload_length -= (WLAN_HDR_A4_LEN - WLAN_HDR_A3_LEN);
@@ -337,7 +337,7 @@ int skb_p80211_to_ether( wlandevice_t *wlandev, u32 ethconv, struct sk_buff *skb
 	/* perform de-wep if necessary.. */
 	if ((wlandev->hostwep & HOSTWEP_PRIVACYINVOKED) && WLAN_GET_FC_ISWEP(fc) && (wlandev->hostwep & HOSTWEP_DECRYPT)) {
 		if (payload_length <= 8) {
-			WLAN_LOG_ERROR("WEP frame too short (%u).\n",
+			printk(KERN_ERR "WEP frame too short (%u).\n",
 					skb->len);
 			return 1;
 		}
@@ -377,7 +377,7 @@ int skb_p80211_to_ether( wlandevice_t *wlandev, u32 ethconv, struct sk_buff *skb
 		if ( payload_length > (netdev->mtu + WLAN_ETHHDR_LEN)) {
 			/* A bogus length ethfrm has been encap'd. */
 			/* Is someone trying an oflow attack? */
-			WLAN_LOG_ERROR("ENCAP frame too large (%d > %d)\n",
+			printk(KERN_ERR "ENCAP frame too large (%d > %d)\n",
 				payload_length, netdev->mtu + WLAN_ETHHDR_LEN);
 			return 1;
 		}
@@ -404,7 +404,7 @@ int skb_p80211_to_ether( wlandevice_t *wlandev, u32 ethconv, struct sk_buff *skb
 		if ( payload_length > netdev->mtu ) {
 			/* A bogus length ethfrm has been sent. */
 			/* Is someone trying an oflow attack? */
-			WLAN_LOG_ERROR("SNAP frame too large (%d > %d)\n",
+			printk(KERN_ERR "SNAP frame too large (%d > %d)\n",
 				payload_length, netdev->mtu);
 			return 1;
 		}
@@ -434,7 +434,7 @@ int skb_p80211_to_ether( wlandevice_t *wlandev, u32 ethconv, struct sk_buff *skb
 		    > netdev->mtu) {
 			/* A bogus length ethfrm has been sent. */
 			/* Is someone trying an oflow attack? */
-			WLAN_LOG_ERROR("DIXII frame too large (%ld > %d)\n",
+			printk(KERN_ERR "DIXII frame too large (%ld > %d)\n",
 					(long int) (payload_length - sizeof(wlan_llc_t) -
 						    sizeof(wlan_snap_t)),
 					netdev->mtu);
@@ -469,7 +469,7 @@ int skb_p80211_to_ether( wlandevice_t *wlandev, u32 ethconv, struct sk_buff *skb
 		if ( payload_length > netdev->mtu ) {
 			/* A bogus length ethfrm has been sent. */
 			/* Is someone trying an oflow attack? */
-			WLAN_LOG_ERROR("OTHER frame too large (%d > %d)\n",
+			printk(KERN_ERR "OTHER frame too large (%d > %d)\n",
 				payload_length,
 				netdev->mtu);
 			return 1;
@@ -613,7 +613,7 @@ p80211skb_rxmeta_attach(struct wlandevice *wlandev, struct sk_buff *skb)
 
 	/* If these already have metadata, we error out! */
 	if (P80211SKB_RXMETA(skb) != NULL) {
-		WLAN_LOG_ERROR("%s: RXmeta already attached!\n",
+		printk(KERN_ERR "%s: RXmeta already attached!\n",
 				wlandev->name);
 		result = 0;
 		goto exit;
@@ -623,7 +623,7 @@ p80211skb_rxmeta_attach(struct wlandevice *wlandev, struct sk_buff *skb)
 	rxmeta = kmalloc(sizeof(p80211_rxmeta_t), GFP_ATOMIC);
 
 	if ( rxmeta == NULL ) {
-		WLAN_LOG_ERROR("%s: Failed to allocate rxmeta.\n",
+		printk(KERN_ERR "%s: Failed to allocate rxmeta.\n",
 				wlandev->name);
 		result = 1;
 		goto exit;
@@ -668,7 +668,7 @@ p80211skb_free(struct wlandevice *wlandev, struct sk_buff *skb)
 	if ( meta && meta->rx) {
 		p80211skb_rxmeta_detach(skb);
 	} else {
-		WLAN_LOG_ERROR("Freeing an skb (%p) w/ no frmmeta.\n", skb);
+		printk(KERN_ERR "Freeing an skb (%p) w/ no frmmeta.\n", skb);
 	}
 
 	dev_kfree_skb(skb);

commit ae26230bf93d37de73febdd1990090dcbd489b38
Author: Moritz Muehlenhoff <jmm@debian.org>
Date:   Wed Jan 21 22:00:45 2009 +0100

    Staging: wlan-ng: Use generic byteorder macros
    
    This patch removes the ieee2host16(), ieee2host32(), host2ieee16()
    and host2ieee32() macros and replaces them with the generic ones.
    
    Signed-off-by: Moritz Muehlenhoff <jmm@debian.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/wlan-ng/p80211conv.c b/drivers/staging/wlan-ng/p80211conv.c
index 53b17c3b1ed0..c3719249f013 100644
--- a/drivers/staging/wlan-ng/p80211conv.c
+++ b/drivers/staging/wlan-ng/p80211conv.c
@@ -63,6 +63,7 @@
 #include <linux/netdevice.h>
 #include <linux/etherdevice.h>
 #include <linux/if_ether.h>
+#include <linux/byteorder/generic.h>
 
 #include <asm/byteorder.h>
 
@@ -192,7 +193,7 @@ int skb_ether_to_p80211( wlandevice_t *wlandev, u32 ethconv, struct sk_buff *skb
 
 	/* Set up the 802.11 header */
 	/* It's a data frame */
-	fc = host2ieee16( WLAN_SET_FC_FTYPE(WLAN_FTYPE_DATA) |
+	fc = cpu_to_le16( WLAN_SET_FC_FTYPE(WLAN_FTYPE_DATA) |
 			  WLAN_SET_FC_FSTYPE(WLAN_FSTYPE_DATAONLY));
 
 	switch ( wlandev->macmode ) {
@@ -202,13 +203,13 @@ int skb_ether_to_p80211( wlandevice_t *wlandev, u32 ethconv, struct sk_buff *skb
 		memcpy(p80211_hdr->a3.a3, wlandev->bssid, ETH_ALEN);
 		break;
 	case WLAN_MACMODE_ESS_STA:
-		fc |= host2ieee16(WLAN_SET_FC_TODS(1));
+		fc |= cpu_to_le16(WLAN_SET_FC_TODS(1));
 		memcpy(p80211_hdr->a3.a1, wlandev->bssid, ETH_ALEN);
 		memcpy(p80211_hdr->a3.a2, wlandev->netdev->dev_addr, ETH_ALEN);
 		memcpy(p80211_hdr->a3.a3, &e_hdr.daddr, ETH_ALEN);
 		break;
 	case WLAN_MACMODE_ESS_AP:
-		fc |= host2ieee16(WLAN_SET_FC_FROMDS(1));
+		fc |= cpu_to_le16(WLAN_SET_FC_FROMDS(1));
 		memcpy(p80211_hdr->a3.a1, &e_hdr.daddr, ETH_ALEN);
 		memcpy(p80211_hdr->a3.a2, wlandev->bssid, ETH_ALEN);
 		memcpy(p80211_hdr->a3.a3, &e_hdr.saddr, ETH_ALEN);
@@ -237,7 +238,7 @@ int skb_ether_to_p80211( wlandevice_t *wlandev, u32 ethconv, struct sk_buff *skb
 			WLAN_LOG_WARNING("Host en-WEP failed, dropping frame (%d).\n", foo);
 			return 2;
 		}
-		fc |= host2ieee16(WLAN_SET_FC_ISWEP(1));
+		fc |= cpu_to_le16(WLAN_SET_FC_ISWEP(1));
 	}
 
 
@@ -312,7 +313,7 @@ int skb_p80211_to_ether( wlandevice_t *wlandev, u32 ethconv, struct sk_buff *skb
 	w_hdr = (p80211_hdr_t *) skb->data;
 
         /* setup some vars for convenience */
-	fc = ieee2host16(w_hdr->a3.fc);
+	fc = le16_to_cpu(w_hdr->a3.fc);
 	if ( (WLAN_GET_FC_TODS(fc) == 0) && (WLAN_GET_FC_FROMDS(fc) == 0) ) {
 		memcpy(daddr, w_hdr->a3.a1, WLAN_ETHADDR_LEN);
 		memcpy(saddr, w_hdr->a3.a2, WLAN_ETHADDR_LEN);
@@ -392,7 +393,7 @@ int skb_p80211_to_ether( wlandevice_t *wlandev, u32 ethconv, struct sk_buff *skb
 		   (e_llc->ctl == 0x03) &&
 		   (((memcmp( e_snap->oui, oui_rfc1042, WLAN_IEEE_OUI_LEN)==0) &&
 		    (ethconv == WLAN_ETHCONV_8021h) &&
-		    (p80211_stt_findproto(ieee2host16(e_snap->type)))) ||
+		    (p80211_stt_findproto(le16_to_cpu(e_snap->type)))) ||
 		    (memcmp( e_snap->oui, oui_rfc1042, WLAN_IEEE_OUI_LEN)!=0)))
 	{
 		WLAN_LOG_DEBUG(3, "SNAP+RFC1042 len: %d\n", payload_length);

commit 8a251b55ef34c2a03e8ddf6d17bb125b92bb4a54
Author: Moritz Muehlenhoff <jmm@debian.org>
Date:   Wed Jan 21 22:00:44 2009 +0100

    Staging: wlan-ng: Remove DBFENTER/DBFEXIT macros
    
    Remove the ugly DBFENTER/DBFEXIT macros, which are only inserted to add "<---" and
    "--->" at the function start/end at higher debug levels and which make the code
    a lot less readable.
    
    Signed-off-by: Moritz Muehlenhoff <jmm@debian.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/wlan-ng/p80211conv.c b/drivers/staging/wlan-ng/p80211conv.c
index 342715af82d7..53b17c3b1ed0 100644
--- a/drivers/staging/wlan-ng/p80211conv.c
+++ b/drivers/staging/wlan-ng/p80211conv.c
@@ -140,7 +140,6 @@ int skb_ether_to_p80211( wlandevice_t *wlandev, u32 ethconv, struct sk_buff *skb
 	wlan_snap_t     *e_snap;
 	int foo;
 
-	DBFENTER;
 	memcpy(&e_hdr, skb->data, sizeof(e_hdr));
 
 	if (skb->len <= 0) {
@@ -248,7 +247,6 @@ int skb_ether_to_p80211( wlandevice_t *wlandev, u32 ethconv, struct sk_buff *skb
 	p80211_hdr->a3.dur = 0;
 	p80211_hdr->a3.seq = 0;
 
-	DBFEXIT;
 	return 0;
 }
 
@@ -308,8 +306,6 @@ int skb_p80211_to_ether( wlandevice_t *wlandev, u32 ethconv, struct sk_buff *skb
 
 	int foo;
 
-	DBFENTER;
-
 	payload_length = skb->len - WLAN_HDR_A3_LEN - WLAN_CRC_LEN;
 	payload_offset = WLAN_HDR_A3_LEN;
 
@@ -511,7 +507,6 @@ int skb_p80211_to_ether( wlandevice_t *wlandev, u32 ethconv, struct sk_buff *skb
 	/* Free the metadata */
 	p80211skb_rxmeta_detach(skb);
 
-	DBFEXIT;
 	return 0;
 }
 
@@ -567,7 +562,6 @@ p80211skb_rxmeta_detach(struct sk_buff *skb)
 	p80211_rxmeta_t		*rxmeta;
 	p80211_frmmeta_t	*frmmeta;
 
-	DBFENTER;
 	/* Sanity checks */
 	if ( skb==NULL ) {			/* bad skb */
 		WLAN_LOG_DEBUG(1, "Called w/ null skb.\n");
@@ -590,7 +584,6 @@ p80211skb_rxmeta_detach(struct sk_buff *skb)
 	/* Clear skb->cb */
 	memset(skb->cb, 0, sizeof(skb->cb));
 exit:
-	DBFEXIT;
 	return;
 }
 
@@ -617,8 +610,6 @@ p80211skb_rxmeta_attach(struct wlandevice *wlandev, struct sk_buff *skb)
 	p80211_rxmeta_t		*rxmeta;
 	p80211_frmmeta_t	*frmmeta;
 
-	DBFENTER;
-
 	/* If these already have metadata, we error out! */
 	if (P80211SKB_RXMETA(skb) != NULL) {
 		WLAN_LOG_ERROR("%s: RXmeta already attached!\n",
@@ -648,7 +639,6 @@ p80211skb_rxmeta_attach(struct wlandevice *wlandev, struct sk_buff *skb)
 	frmmeta->magic = P80211_FRMMETA_MAGIC;
 	frmmeta->rx = rxmeta;
 exit:
-	DBFEXIT;
 	return result;
 }
 
@@ -672,7 +662,7 @@ void
 p80211skb_free(struct wlandevice *wlandev, struct sk_buff *skb)
 {
 	p80211_frmmeta_t	*meta;
-	DBFENTER;
+
 	meta = P80211SKB_FRMMETA(skb);
 	if ( meta && meta->rx) {
 		p80211skb_rxmeta_detach(skb);
@@ -681,6 +671,5 @@ p80211skb_free(struct wlandevice *wlandev, struct sk_buff *skb)
 	}
 
 	dev_kfree_skb(skb);
-	DBFEXIT;
 	return;
 }

commit 28b17a4bdf148b7591c004efd10a8850d52849ec
Author: Moritz Muehlenhoff <jmm@debian.org>
Date:   Wed Jan 21 22:00:41 2009 +0100

    Staging: wlan-ng: Remove use of WLAN_ADDR_LEN
    
    Replace the driver local WLAN_ADDR_LEN constant through the kernel-wide ETH_ALEN definiton.
    
    Signed-off-by: Moritz Muehlenhoff <jmm@debian.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/wlan-ng/p80211conv.c b/drivers/staging/wlan-ng/p80211conv.c
index dfc7b3a1e9c9..342715af82d7 100644
--- a/drivers/staging/wlan-ng/p80211conv.c
+++ b/drivers/staging/wlan-ng/p80211conv.c
@@ -198,21 +198,21 @@ int skb_ether_to_p80211( wlandevice_t *wlandev, u32 ethconv, struct sk_buff *skb
 
 	switch ( wlandev->macmode ) {
 	case WLAN_MACMODE_IBSS_STA:
-		memcpy(p80211_hdr->a3.a1, &e_hdr.daddr, WLAN_ADDR_LEN);
-		memcpy(p80211_hdr->a3.a2, wlandev->netdev->dev_addr, WLAN_ADDR_LEN);
-		memcpy(p80211_hdr->a3.a3, wlandev->bssid, WLAN_ADDR_LEN);
+		memcpy(p80211_hdr->a3.a1, &e_hdr.daddr, ETH_ALEN);
+		memcpy(p80211_hdr->a3.a2, wlandev->netdev->dev_addr, ETH_ALEN);
+		memcpy(p80211_hdr->a3.a3, wlandev->bssid, ETH_ALEN);
 		break;
 	case WLAN_MACMODE_ESS_STA:
 		fc |= host2ieee16(WLAN_SET_FC_TODS(1));
-		memcpy(p80211_hdr->a3.a1, wlandev->bssid, WLAN_ADDR_LEN);
-		memcpy(p80211_hdr->a3.a2, wlandev->netdev->dev_addr, WLAN_ADDR_LEN);
-		memcpy(p80211_hdr->a3.a3, &e_hdr.daddr, WLAN_ADDR_LEN);
+		memcpy(p80211_hdr->a3.a1, wlandev->bssid, ETH_ALEN);
+		memcpy(p80211_hdr->a3.a2, wlandev->netdev->dev_addr, ETH_ALEN);
+		memcpy(p80211_hdr->a3.a3, &e_hdr.daddr, ETH_ALEN);
 		break;
 	case WLAN_MACMODE_ESS_AP:
 		fc |= host2ieee16(WLAN_SET_FC_FROMDS(1));
-		memcpy(p80211_hdr->a3.a1, &e_hdr.daddr, WLAN_ADDR_LEN);
-		memcpy(p80211_hdr->a3.a2, wlandev->bssid, WLAN_ADDR_LEN);
-		memcpy(p80211_hdr->a3.a3, &e_hdr.saddr, WLAN_ADDR_LEN);
+		memcpy(p80211_hdr->a3.a1, &e_hdr.daddr, ETH_ALEN);
+		memcpy(p80211_hdr->a3.a2, wlandev->bssid, ETH_ALEN);
+		memcpy(p80211_hdr->a3.a3, &e_hdr.saddr, ETH_ALEN);
 		break;
 	default:
 		WLAN_LOG_ERROR("Error: Converting eth to wlan in unknown mode.\n");

commit 1f9e9ce1f99e89ee180a3994c44bdff43ebeb139
Author: Roel Kluin <roel.kluin@gmail.com>
Date:   Wed Dec 3 00:06:39 2008 +0100

    Staging: wlan-ng: skb_p80211_to_ether() - payload_length is unsigned, check before subtraction
    
    payload_length is unsigned, check before subtraction
    
    Signed-off-by: Roel Kluin <roel.kluin@gmail.com>

diff --git a/drivers/staging/wlan-ng/p80211conv.c b/drivers/staging/wlan-ng/p80211conv.c
index 993e8f480736..dfc7b3a1e9c9 100644
--- a/drivers/staging/wlan-ng/p80211conv.c
+++ b/drivers/staging/wlan-ng/p80211conv.c
@@ -328,11 +328,11 @@ int skb_p80211_to_ether( wlandevice_t *wlandev, u32 ethconv, struct sk_buff *skb
 		memcpy(saddr, w_hdr->a3.a2, WLAN_ETHADDR_LEN);
 	} else {
 		payload_offset = WLAN_HDR_A4_LEN;
-		payload_length -= ( WLAN_HDR_A4_LEN - WLAN_HDR_A3_LEN );
-		if (payload_length < 0 ) {
+		if (payload_length < WLAN_HDR_A4_LEN - WLAN_HDR_A3_LEN) {
 			WLAN_LOG_ERROR("A4 frame too short!\n");
 			return 1;
 		}
+		payload_length -= (WLAN_HDR_A4_LEN - WLAN_HDR_A3_LEN);
 		memcpy(daddr, w_hdr->a4.a3, WLAN_ETHADDR_LEN);
 		memcpy(saddr, w_hdr->a4.a4, WLAN_ETHADDR_LEN);
 	}

commit d11e5f22ac9330ebe8f6157395a1a55645064322
Author: Huang Weiyi <weiyi.huang@gmail.com>
Date:   Fri Oct 31 22:49:56 2008 +0800

    Staging: wlan-ng: remove unused #include <version.h>
    
    The file(s) below do not use LINUX_VERSION_CODE nor KERNEL_VERSION.
      drivers/staging/wlan-ng/p80211conv.c
      drivers/staging/wlan-ng/p80211req.c
      drivers/staging/wlan-ng/p80211wext.c
      drivers/staging/wlan-ng/prism2mgmt.c
    
    This patch removes the said #include <version.h>.
    
    Signed-off-by: Huang Weiyi <weiyi.huang@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/wlan-ng/p80211conv.c b/drivers/staging/wlan-ng/p80211conv.c
index 5d3d0811ebf3..993e8f480736 100644
--- a/drivers/staging/wlan-ng/p80211conv.c
+++ b/drivers/staging/wlan-ng/p80211conv.c
@@ -52,7 +52,6 @@
 /*================================================================*/
 /* System Includes */
 
-#include <linux/version.h>
 
 #include <linux/module.h>
 #include <linux/kernel.h>

commit 33ce0ca6e22e726f64ed86821da1677a00fb0e06
Author: Richard Kennedy <richard@rsk.demon.co.uk>
Date:   Mon Nov 3 11:24:54 2008 +0000

    Staging: wlan-ng: p80211conv.c copy code from wlan-ng-devel branch to not drop packets
    
    allow card to correctly receive network packets,
    without this change all incoming packets are dropped.
    code copied from the latest wlan-ng-devel tree.
    
    Signed-off-by: Richard Kennedy <richard@rsk.demon.co.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/wlan-ng/p80211conv.c b/drivers/staging/wlan-ng/p80211conv.c
index e7cc89f8e7a8..5d3d0811ebf3 100644
--- a/drivers/staging/wlan-ng/p80211conv.c
+++ b/drivers/staging/wlan-ng/p80211conv.c
@@ -377,6 +377,14 @@ int skb_p80211_to_ether( wlandevice_t *wlandev, u32 ethconv, struct sk_buff *skb
 	     (memcmp(saddr, e_hdr->saddr, WLAN_ETHADDR_LEN) == 0))) {
 		WLAN_LOG_DEBUG(3, "802.3 ENCAP len: %d\n", payload_length);
 		/* 802.3 Encapsulated */
+		/* Test for an overlength frame */
+		if ( payload_length > (netdev->mtu + WLAN_ETHHDR_LEN)) {
+			/* A bogus length ethfrm has been encap'd. */
+			/* Is someone trying an oflow attack? */
+			WLAN_LOG_ERROR("ENCAP frame too large (%d > %d)\n",
+				payload_length, netdev->mtu + WLAN_ETHHDR_LEN);
+			return 1;
+		}
 
 		/* Chop off the 802.11 header.  it's already sane. */
 		skb_pull(skb, payload_offset);
@@ -396,6 +404,15 @@ int skb_p80211_to_ether( wlandevice_t *wlandev, u32 ethconv, struct sk_buff *skb
 		/* it's a SNAP + RFC1042 frame && protocol is in STT */
 		/* build 802.3 + RFC1042 */
 
+		/* Test for an overlength frame */
+		if ( payload_length > netdev->mtu ) {
+			/* A bogus length ethfrm has been sent. */
+			/* Is someone trying an oflow attack? */
+			WLAN_LOG_ERROR("SNAP frame too large (%d > %d)\n",
+				payload_length, netdev->mtu);
+			return 1;
+		}
+
 		/* chop 802.11 header from skb. */
 		skb_pull(skb, payload_offset);
 
@@ -416,6 +433,18 @@ int skb_p80211_to_ether( wlandevice_t *wlandev, u32 ethconv, struct sk_buff *skb
 		/* it's an 802.1h frame || (an RFC1042 && protocol is not in STT) */
 		/* build a DIXII + RFC894 */
 
+		/* Test for an overlength frame */
+		if ((payload_length - sizeof(wlan_llc_t) - sizeof(wlan_snap_t))
+		    > netdev->mtu) {
+			/* A bogus length ethfrm has been sent. */
+			/* Is someone trying an oflow attack? */
+			WLAN_LOG_ERROR("DIXII frame too large (%ld > %d)\n",
+					(long int) (payload_length - sizeof(wlan_llc_t) -
+						    sizeof(wlan_snap_t)),
+					netdev->mtu);
+			return 1;
+		}
+
 		/* chop 802.11 header from skb. */
 		skb_pull(skb, payload_offset);
 
@@ -440,6 +469,16 @@ int skb_p80211_to_ether( wlandevice_t *wlandev, u32 ethconv, struct sk_buff *skb
 		/*  build an 802.3 frame */
 		/* allocate space and setup hostbuf */
 
+		/* Test for an overlength frame */
+		if ( payload_length > netdev->mtu ) {
+			/* A bogus length ethfrm has been sent. */
+			/* Is someone trying an oflow attack? */
+			WLAN_LOG_ERROR("OTHER frame too large (%d > %d)\n",
+				payload_length,
+				netdev->mtu);
+			return 1;
+		}
+
 		/* Chop off the 802.11 header. */
 		skb_pull(skb, payload_offset);
 
@@ -454,8 +493,16 @@ int skb_p80211_to_ether( wlandevice_t *wlandev, u32 ethconv, struct sk_buff *skb
 
 	}
 
+        /*
+         * Note that eth_type_trans() expects an skb w/ skb->data pointing
+         * at the MAC header, it then sets the following skb members:
+         * skb->mac_header,
+         * skb->data, and
+         * skb->pkt_type.
+         * It then _returns_ the value that _we're_ supposed to stuff in
+         * skb->protocol.  This is nuts.
+         */
 	skb->protocol = eth_type_trans(skb, netdev);
-	skb_reset_mac_header(skb);
 
         /* jkriegl: process signal and noise as set in hfa384x_int_rx() */
 	/* jkriegl: only process signal/noise if requested by iwspy */

commit e02c69b8af13938153a3e9470fadce49608170de
Author: Solomon Peachy <pizza@shaftnet.org>
Date:   Wed Oct 29 10:42:59 2008 -0400

    Staging: wlan-ng: Consolidate wlan-ng into a single module.
    
    There's no point in having a separate 'p80211' module, as nobody else is
    ever going to use it.  Push everyting into a single module, and get rid
    of all exports.
    
    Signed-off-by: Solomon Peachy <pizza@shaftnet.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/wlan-ng/p80211conv.c b/drivers/staging/wlan-ng/p80211conv.c
index 8996e52b51c2..e7cc89f8e7a8 100644
--- a/drivers/staging/wlan-ng/p80211conv.c
+++ b/drivers/staging/wlan-ng/p80211conv.c
@@ -52,9 +52,6 @@
 /*================================================================*/
 /* System Includes */
 
-#define __NO_VERSION__		/* prevent the static definition */
-
-
 #include <linux/version.h>
 
 #include <linux/module.h>

commit aaad430378dd128ee015c8ed6e77809317c496a5
Author: Solomon Peachy <pizza@shaftnet.org>
Date:   Wed Oct 29 10:42:53 2008 -0400

    Staging: wlan-ng: Use standard kernel integer (u32/s32/etc) types.
    
    wlan-ng needed to interact with userspace, and support very old kernels,
    so it used to define its own types for integers to ensure consistency.
    
    It's all rather irrelevant now.
    
    Signed-off-by: Solomon Peachy <pizza@shaftnet.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/wlan-ng/p80211conv.c b/drivers/staging/wlan-ng/p80211conv.c
index 749ea8d93207..8996e52b51c2 100644
--- a/drivers/staging/wlan-ng/p80211conv.c
+++ b/drivers/staging/wlan-ng/p80211conv.c
@@ -99,8 +99,8 @@
 /*================================================================*/
 /* Local Static Definitions */
 
-static UINT8	oui_rfc1042[] = {0x00, 0x00, 0x00};
-static UINT8	oui_8021h[] = {0x00, 0x00, 0xf8};
+static u8	oui_rfc1042[] = {0x00, 0x00, 0x00};
+static u8	oui_8021h[] = {0x00, 0x00, 0xf8};
 
 /*================================================================*/
 /* Local Function Declarations */
@@ -134,11 +134,11 @@ static UINT8	oui_8021h[] = {0x00, 0x00, 0xf8};
 * Call context:
 *	May be called in interrupt or non-interrupt context
 ----------------------------------------------------------------*/
-int skb_ether_to_p80211( wlandevice_t *wlandev, UINT32 ethconv, struct sk_buff *skb, p80211_hdr_t *p80211_hdr, p80211_metawep_t *p80211_wep)
+int skb_ether_to_p80211( wlandevice_t *wlandev, u32 ethconv, struct sk_buff *skb, p80211_hdr_t *p80211_hdr, p80211_metawep_t *p80211_wep)
 {
 
-	UINT16          fc;
-	UINT16          proto;
+	u16          fc;
+	u16          proto;
 	wlan_ethhdr_t   e_hdr;
 	wlan_llc_t      *e_llc;
 	wlan_snap_t     *e_snap;
@@ -297,14 +297,14 @@ static void orinoco_spy_gather(wlandevice_t *wlandev, char *mac,
 * Call context:
 *	May be called in interrupt or non-interrupt context
 ----------------------------------------------------------------*/
-int skb_p80211_to_ether( wlandevice_t *wlandev, UINT32 ethconv, struct sk_buff *skb)
+int skb_p80211_to_ether( wlandevice_t *wlandev, u32 ethconv, struct sk_buff *skb)
 {
 	netdevice_t     *netdev = wlandev->netdev;
-	UINT16          fc;
-	UINT            payload_length;
-	UINT            payload_offset;
-	UINT8		daddr[WLAN_ETHADDR_LEN];
-	UINT8		saddr[WLAN_ETHADDR_LEN];
+	u16          fc;
+	unsigned int            payload_length;
+	unsigned int            payload_offset;
+	u8		daddr[WLAN_ETHADDR_LEN];
+	u8		saddr[WLAN_ETHADDR_LEN];
 	p80211_hdr_t    *w_hdr;
 	wlan_ethhdr_t   *e_hdr;
 	wlan_llc_t      *e_llc;
@@ -488,7 +488,7 @@ int skb_p80211_to_ether( wlandevice_t *wlandev, UINT32 ethconv, struct sk_buff *
 * Call context:
 *	May be called in interrupt or non-interrupt context
 ----------------------------------------------------------------*/
-int p80211_stt_findproto(UINT16 proto)
+int p80211_stt_findproto(u16 proto)
 {
 	/* Always return found for now.  This is the behavior used by the */
 	/*  Zoom Win95 driver when 802.1h mode is selected */

commit ff1ae8f3c1b972ff850400abdd5f7da36270f408
Author: Solomon Peachy <pizza@shaftnet.org>
Date:   Mon Oct 27 11:14:05 2008 -0400

    Staging: wlan-ng: Eliminate local 'version.h'
    
    The kernel provides us with the proper version of this file.
    
    Signed-off-by: Solomon Peachy <pizza@shaftnet.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/wlan-ng/p80211conv.c b/drivers/staging/wlan-ng/p80211conv.c
index aaf1c9d44487..749ea8d93207 100644
--- a/drivers/staging/wlan-ng/p80211conv.c
+++ b/drivers/staging/wlan-ng/p80211conv.c
@@ -70,7 +70,6 @@
 
 #include <asm/byteorder.h>
 
-#include "version.h"
 #include "wlan_compat.h"
 
 /*================================================================*/

commit 905862c9f98676807931c9c832ee12ba0d58bc88
Author: Solomon Peachy <pizza@shaftnet.org>
Date:   Mon Oct 27 11:14:04 2008 -0400

    Staging: wlan-ng: Eliminate one more rx mtu test.
    
    It also isn't needed.
    
    Signed-off-by: Solomon Peachy <pizza@shaftnet.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/wlan-ng/p80211conv.c b/drivers/staging/wlan-ng/p80211conv.c
index d58f10f11d00..aaf1c9d44487 100644
--- a/drivers/staging/wlan-ng/p80211conv.c
+++ b/drivers/staging/wlan-ng/p80211conv.c
@@ -444,16 +444,6 @@ int skb_p80211_to_ether( wlandevice_t *wlandev, UINT32 ethconv, struct sk_buff *
 		/*  build an 802.3 frame */
 		/* allocate space and setup hostbuf */
 
-		/* Test for an overlength frame */
-		if ( payload_length > netdev->mtu ) {
-			/* A bogus length ethfrm has been sent. */
-			/* Is someone trying an oflow attack? */
-			WLAN_LOG_ERROR("OTHER frame too large (%d > %d)\n",
-				payload_length,
-				netdev->mtu);
-			return 1;
-		}
-
 		/* Chop off the 802.11 header. */
 		skb_pull(skb, payload_offset);
 

commit 9d86349e9c8059039d41f5d40ad42d77ef5acf87
Author: Solomon Peachy <pizza@shaftnet.org>
Date:   Mon Oct 27 11:14:03 2008 -0400

    Staging: wlan-ng: Get rid of the MTU tests in the rx conversion path.
    
    They are not needed.
    
    Signed-off-by: Solomon Peachy <pizza@shaftnet.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/wlan-ng/p80211conv.c b/drivers/staging/wlan-ng/p80211conv.c
index 68121b9b34fa..d58f10f11d00 100644
--- a/drivers/staging/wlan-ng/p80211conv.c
+++ b/drivers/staging/wlan-ng/p80211conv.c
@@ -381,14 +381,6 @@ int skb_p80211_to_ether( wlandevice_t *wlandev, UINT32 ethconv, struct sk_buff *
 	     (memcmp(saddr, e_hdr->saddr, WLAN_ETHADDR_LEN) == 0))) {
 		WLAN_LOG_DEBUG(3, "802.3 ENCAP len: %d\n", payload_length);
 		/* 802.3 Encapsulated */
-		/* Test for an overlength frame */
-		if ( payload_length > (netdev->mtu + WLAN_ETHHDR_LEN)) {
-			/* A bogus length ethfrm has been encap'd. */
-			/* Is someone trying an oflow attack? */
-			WLAN_LOG_ERROR("ENCAP frame too large (%d > %d)\n",
-				payload_length, netdev->mtu + WLAN_ETHHDR_LEN);
-			return 1;
-		}
 
 		/* Chop off the 802.11 header.  it's already sane. */
 		skb_pull(skb, payload_offset);
@@ -408,15 +400,6 @@ int skb_p80211_to_ether( wlandevice_t *wlandev, UINT32 ethconv, struct sk_buff *
 		/* it's a SNAP + RFC1042 frame && protocol is in STT */
 		/* build 802.3 + RFC1042 */
 
-		/* Test for an overlength frame */
-		if ( payload_length > netdev->mtu ) {
-			/* A bogus length ethfrm has been sent. */
-			/* Is someone trying an oflow attack? */
-			WLAN_LOG_ERROR("SNAP frame too large (%d > %d)\n",
-				payload_length, netdev->mtu);
-			return 1;
-		}
-
 		/* chop 802.11 header from skb. */
 		skb_pull(skb, payload_offset);
 
@@ -437,18 +420,6 @@ int skb_p80211_to_ether( wlandevice_t *wlandev, UINT32 ethconv, struct sk_buff *
 		/* it's an 802.1h frame || (an RFC1042 && protocol is not in STT) */
 		/* build a DIXII + RFC894 */
 
-		/* Test for an overlength frame */
-		if ((payload_length - sizeof(wlan_llc_t) - sizeof(wlan_snap_t))
-		    > netdev->mtu) {
-			/* A bogus length ethfrm has been sent. */
-			/* Is someone trying an oflow attack? */
-			WLAN_LOG_ERROR("DIXII frame too large (%ld > %d)\n",
-					(long int) (payload_length - sizeof(wlan_llc_t) -
-						    sizeof(wlan_snap_t)),
-					netdev->mtu);
-			return 1;
-		}
-
 		/* chop 802.11 header from skb. */
 		skb_pull(skb, payload_offset);
 

commit 00b3ed1685089ff52169a715de11106ed37df087
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Thu Oct 2 11:29:28 2008 -0700

    Staging: add wlan-ng prism2 usb driver
    
    This adds the wlan-ng prism2 USB driver to the drivers/staging tree.
    
    The code was originally written by the linux-wlan-ng team, patched by
    some Novell engineers to properly work on newer kernels, and then hacked
    into place in order to get it to build properly in a single subdirectory
    within the kernel tree by me.
    
    It supports a wide range of older USB prism2 devices, and contains a
    80211 stack to support this single driver.
    
    Cc: Christian Zoz <zoz@suse.de>
    Cc: Andreas Gruenbacher <agruen@suse.de>
    Cc: linux-wireless <linux-wireless@vger.kernel.org>
    Cc: John Linville <linville@tuxdriver.com>
    Cc: Helmut Schaa <helmut.schaa@googlemail.com>
    Cc: linux-wlan-ng <solomon@linux-wlan.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/wlan-ng/p80211conv.c b/drivers/staging/wlan-ng/p80211conv.c
new file mode 100644
index 000000000000..68121b9b34fa
--- /dev/null
+++ b/drivers/staging/wlan-ng/p80211conv.c
@@ -0,0 +1,683 @@
+/* src/p80211/p80211conv.c
+*
+* Ether/802.11 conversions and packet buffer routines
+*
+* Copyright (C) 1999 AbsoluteValue Systems, Inc.  All Rights Reserved.
+* --------------------------------------------------------------------
+*
+* linux-wlan
+*
+*   The contents of this file are subject to the Mozilla Public
+*   License Version 1.1 (the "License"); you may not use this file
+*   except in compliance with the License. You may obtain a copy of
+*   the License at http://www.mozilla.org/MPL/
+*
+*   Software distributed under the License is distributed on an "AS
+*   IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+*   implied. See the License for the specific language governing
+*   rights and limitations under the License.
+*
+*   Alternatively, the contents of this file may be used under the
+*   terms of the GNU Public License version 2 (the "GPL"), in which
+*   case the provisions of the GPL are applicable instead of the
+*   above.  If you wish to allow the use of your version of this file
+*   only under the terms of the GPL and not to allow others to use
+*   your version of this file under the MPL, indicate your decision
+*   by deleting the provisions above and replace them with the notice
+*   and other provisions required by the GPL.  If you do not delete
+*   the provisions above, a recipient may use your version of this
+*   file under either the MPL or the GPL.
+*
+* --------------------------------------------------------------------
+*
+* Inquiries regarding the linux-wlan Open Source project can be
+* made directly to:
+*
+* AbsoluteValue Systems Inc.
+* info@linux-wlan.com
+* http://www.linux-wlan.com
+*
+* --------------------------------------------------------------------
+*
+* Portions of the development of this software were funded by
+* Intersil Corporation as part of PRISM(R) chipset product development.
+*
+* --------------------------------------------------------------------
+*
+* This file defines the functions that perform Ethernet to/from
+* 802.11 frame conversions.
+*
+* --------------------------------------------------------------------
+*/
+/*================================================================*/
+/* System Includes */
+
+#define __NO_VERSION__		/* prevent the static definition */
+
+
+#include <linux/version.h>
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/types.h>
+#include <linux/skbuff.h>
+#include <linux/slab.h>
+#include <linux/wireless.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/if_ether.h>
+
+#include <asm/byteorder.h>
+
+#include "version.h"
+#include "wlan_compat.h"
+
+/*================================================================*/
+/* Project Includes */
+
+#include "p80211types.h"
+#include "p80211hdr.h"
+#include "p80211conv.h"
+#include "p80211mgmt.h"
+#include "p80211msg.h"
+#include "p80211netdev.h"
+#include "p80211ioctl.h"
+#include "p80211req.h"
+
+
+/*================================================================*/
+/* Local Constants */
+
+/*================================================================*/
+/* Local Macros */
+
+
+/*================================================================*/
+/* Local Types */
+
+
+/*================================================================*/
+/* Local Static Definitions */
+
+static UINT8	oui_rfc1042[] = {0x00, 0x00, 0x00};
+static UINT8	oui_8021h[] = {0x00, 0x00, 0xf8};
+
+/*================================================================*/
+/* Local Function Declarations */
+
+
+/*================================================================*/
+/* Function Definitions */
+
+/*----------------------------------------------------------------
+* p80211pb_ether_to_80211
+*
+* Uses the contents of the ether frame and the etherconv setting
+* to build the elements of the 802.11 frame.
+*
+* We don't actually set
+* up the frame header here.  That's the MAC's job.  We're only handling
+* conversion of DIXII or 802.3+LLC frames to something that works
+* with 802.11.
+*
+* Note -- 802.11 header is NOT part of the skb.  Likewise, the 802.11
+*         FCS is also not present and will need to be added elsewhere.
+*
+* Arguments:
+*	ethconv		Conversion type to perform
+*	skb		skbuff containing the ether frame
+*       p80211_hdr      802.11 header
+*
+* Returns:
+*	0 on success, non-zero otherwise
+*
+* Call context:
+*	May be called in interrupt or non-interrupt context
+----------------------------------------------------------------*/
+int skb_ether_to_p80211( wlandevice_t *wlandev, UINT32 ethconv, struct sk_buff *skb, p80211_hdr_t *p80211_hdr, p80211_metawep_t *p80211_wep)
+{
+
+	UINT16          fc;
+	UINT16          proto;
+	wlan_ethhdr_t   e_hdr;
+	wlan_llc_t      *e_llc;
+	wlan_snap_t     *e_snap;
+	int foo;
+
+	DBFENTER;
+	memcpy(&e_hdr, skb->data, sizeof(e_hdr));
+
+	if (skb->len <= 0) {
+		WLAN_LOG_DEBUG(1, "zero-length skb!\n");
+		return 1;
+	}
+
+	if ( ethconv == WLAN_ETHCONV_ENCAP ) { /* simplest case */
+	        WLAN_LOG_DEBUG(3, "ENCAP len: %d\n", skb->len);
+		/* here, we don't care what kind of ether frm. Just stick it */
+		/*  in the 80211 payload */
+		/* which is to say, leave the skb alone. */
+	} else {
+		/* step 1: classify ether frame, DIX or 802.3? */
+		proto = ntohs(e_hdr.type);
+		if ( proto <= 1500 ) {
+		        WLAN_LOG_DEBUG(3, "802.3 len: %d\n", skb->len);
+                        /* codes <= 1500 reserved for 802.3 lengths */
+			/* it's 802.3, pass ether payload unchanged,  */
+
+			/* trim off ethernet header */
+			skb_pull(skb, WLAN_ETHHDR_LEN);
+
+			/*   leave off any PAD octets.  */
+			skb_trim(skb, proto);
+		} else {
+		        WLAN_LOG_DEBUG(3, "DIXII len: %d\n", skb->len);
+			/* it's DIXII, time for some conversion */
+
+			/* trim off ethernet header */
+			skb_pull(skb, WLAN_ETHHDR_LEN);
+
+			/* tack on SNAP */
+			e_snap = (wlan_snap_t *) skb_push(skb, sizeof(wlan_snap_t));
+			e_snap->type = htons(proto);
+			if ( ethconv == WLAN_ETHCONV_8021h && p80211_stt_findproto(proto) ) {
+				memcpy( e_snap->oui, oui_8021h, WLAN_IEEE_OUI_LEN);
+			} else {
+				memcpy( e_snap->oui, oui_rfc1042, WLAN_IEEE_OUI_LEN);
+			}
+
+			/* tack on llc */
+			e_llc = (wlan_llc_t *) skb_push(skb, sizeof(wlan_llc_t));
+			e_llc->dsap = 0xAA;	/* SNAP, see IEEE 802 */
+			e_llc->ssap = 0xAA;
+			e_llc->ctl = 0x03;
+
+		}
+	}
+
+	/* Set up the 802.11 header */
+	/* It's a data frame */
+	fc = host2ieee16( WLAN_SET_FC_FTYPE(WLAN_FTYPE_DATA) |
+			  WLAN_SET_FC_FSTYPE(WLAN_FSTYPE_DATAONLY));
+
+	switch ( wlandev->macmode ) {
+	case WLAN_MACMODE_IBSS_STA:
+		memcpy(p80211_hdr->a3.a1, &e_hdr.daddr, WLAN_ADDR_LEN);
+		memcpy(p80211_hdr->a3.a2, wlandev->netdev->dev_addr, WLAN_ADDR_LEN);
+		memcpy(p80211_hdr->a3.a3, wlandev->bssid, WLAN_ADDR_LEN);
+		break;
+	case WLAN_MACMODE_ESS_STA:
+		fc |= host2ieee16(WLAN_SET_FC_TODS(1));
+		memcpy(p80211_hdr->a3.a1, wlandev->bssid, WLAN_ADDR_LEN);
+		memcpy(p80211_hdr->a3.a2, wlandev->netdev->dev_addr, WLAN_ADDR_LEN);
+		memcpy(p80211_hdr->a3.a3, &e_hdr.daddr, WLAN_ADDR_LEN);
+		break;
+	case WLAN_MACMODE_ESS_AP:
+		fc |= host2ieee16(WLAN_SET_FC_FROMDS(1));
+		memcpy(p80211_hdr->a3.a1, &e_hdr.daddr, WLAN_ADDR_LEN);
+		memcpy(p80211_hdr->a3.a2, wlandev->bssid, WLAN_ADDR_LEN);
+		memcpy(p80211_hdr->a3.a3, &e_hdr.saddr, WLAN_ADDR_LEN);
+		break;
+	default:
+		WLAN_LOG_ERROR("Error: Converting eth to wlan in unknown mode.\n");
+		return 1;
+		break;
+	}
+
+	p80211_wep->data = NULL;
+
+	if ((wlandev->hostwep & HOSTWEP_PRIVACYINVOKED) && (wlandev->hostwep & HOSTWEP_ENCRYPT)) {
+		// XXXX need to pick keynum other than default?
+
+#if 1
+		p80211_wep->data = kmalloc(skb->len, GFP_ATOMIC);
+#else
+		p80211_wep->data = skb->data;
+#endif
+
+		if ((foo = wep_encrypt(wlandev, skb->data, p80211_wep->data,
+				       skb->len,
+				(wlandev->hostwep & HOSTWEP_DEFAULTKEY_MASK),
+				p80211_wep->iv, p80211_wep->icv))) {
+			WLAN_LOG_WARNING("Host en-WEP failed, dropping frame (%d).\n", foo);
+			return 2;
+		}
+		fc |= host2ieee16(WLAN_SET_FC_ISWEP(1));
+	}
+
+
+	//	skb->nh.raw = skb->data;
+
+	p80211_hdr->a3.fc = fc;
+	p80211_hdr->a3.dur = 0;
+	p80211_hdr->a3.seq = 0;
+
+	DBFEXIT;
+	return 0;
+}
+
+/* jkriegl: from orinoco, modified */
+static void orinoco_spy_gather(wlandevice_t *wlandev, char *mac,
+			       p80211_rxmeta_t *rxmeta)
+{
+        int i;
+
+        /* Gather wireless spy statistics: for each packet, compare the
+         * source address with out list, and if match, get the stats... */
+
+        for (i = 0; i < wlandev->spy_number; i++) {
+
+                if (!memcmp(wlandev->spy_address[i], mac, ETH_ALEN)) {
+			memcpy(wlandev->spy_address[i], mac, ETH_ALEN);
+                        wlandev->spy_stat[i].level = rxmeta->signal;
+                        wlandev->spy_stat[i].noise = rxmeta->noise;
+                        wlandev->spy_stat[i].qual = (rxmeta->signal > rxmeta->noise) ? \
+                                                     (rxmeta->signal - rxmeta->noise) : 0;
+                        wlandev->spy_stat[i].updated = 0x7;
+                }
+        }
+}
+
+/*----------------------------------------------------------------
+* p80211pb_80211_to_ether
+*
+* Uses the contents of a received 802.11 frame and the etherconv
+* setting to build an ether frame.
+*
+* This function extracts the src and dest address from the 802.11
+* frame to use in the construction of the eth frame.
+*
+* Arguments:
+*	ethconv		Conversion type to perform
+*	skb		Packet buffer containing the 802.11 frame
+*
+* Returns:
+*	0 on success, non-zero otherwise
+*
+* Call context:
+*	May be called in interrupt or non-interrupt context
+----------------------------------------------------------------*/
+int skb_p80211_to_ether( wlandevice_t *wlandev, UINT32 ethconv, struct sk_buff *skb)
+{
+	netdevice_t     *netdev = wlandev->netdev;
+	UINT16          fc;
+	UINT            payload_length;
+	UINT            payload_offset;
+	UINT8		daddr[WLAN_ETHADDR_LEN];
+	UINT8		saddr[WLAN_ETHADDR_LEN];
+	p80211_hdr_t    *w_hdr;
+	wlan_ethhdr_t   *e_hdr;
+	wlan_llc_t      *e_llc;
+	wlan_snap_t     *e_snap;
+
+	int foo;
+
+	DBFENTER;
+
+	payload_length = skb->len - WLAN_HDR_A3_LEN - WLAN_CRC_LEN;
+	payload_offset = WLAN_HDR_A3_LEN;
+
+	w_hdr = (p80211_hdr_t *) skb->data;
+
+        /* setup some vars for convenience */
+	fc = ieee2host16(w_hdr->a3.fc);
+	if ( (WLAN_GET_FC_TODS(fc) == 0) && (WLAN_GET_FC_FROMDS(fc) == 0) ) {
+		memcpy(daddr, w_hdr->a3.a1, WLAN_ETHADDR_LEN);
+		memcpy(saddr, w_hdr->a3.a2, WLAN_ETHADDR_LEN);
+	} else if( (WLAN_GET_FC_TODS(fc) == 0) && (WLAN_GET_FC_FROMDS(fc) == 1) ) {
+		memcpy(daddr, w_hdr->a3.a1, WLAN_ETHADDR_LEN);
+		memcpy(saddr, w_hdr->a3.a3, WLAN_ETHADDR_LEN);
+	} else if( (WLAN_GET_FC_TODS(fc) == 1) && (WLAN_GET_FC_FROMDS(fc) == 0) ) {
+		memcpy(daddr, w_hdr->a3.a3, WLAN_ETHADDR_LEN);
+		memcpy(saddr, w_hdr->a3.a2, WLAN_ETHADDR_LEN);
+	} else {
+		payload_offset = WLAN_HDR_A4_LEN;
+		payload_length -= ( WLAN_HDR_A4_LEN - WLAN_HDR_A3_LEN );
+		if (payload_length < 0 ) {
+			WLAN_LOG_ERROR("A4 frame too short!\n");
+			return 1;
+		}
+		memcpy(daddr, w_hdr->a4.a3, WLAN_ETHADDR_LEN);
+		memcpy(saddr, w_hdr->a4.a4, WLAN_ETHADDR_LEN);
+	}
+
+	/* perform de-wep if necessary.. */
+	if ((wlandev->hostwep & HOSTWEP_PRIVACYINVOKED) && WLAN_GET_FC_ISWEP(fc) && (wlandev->hostwep & HOSTWEP_DECRYPT)) {
+		if (payload_length <= 8) {
+			WLAN_LOG_ERROR("WEP frame too short (%u).\n",
+					skb->len);
+			return 1;
+		}
+		if ((foo = wep_decrypt(wlandev, skb->data + payload_offset + 4,
+				       payload_length - 8, -1,
+				       skb->data + payload_offset,
+				       skb->data + payload_offset + payload_length - 4))) {
+			/* de-wep failed, drop skb. */
+			WLAN_LOG_DEBUG(1, "Host de-WEP failed, dropping frame (%d).\n", foo);
+			wlandev->rx.decrypt_err++;
+			return 2;
+		}
+
+		/* subtract the IV+ICV length off the payload */
+		payload_length -= 8;
+		/* chop off the IV */
+		skb_pull(skb, 4);
+		/* chop off the ICV. */
+		skb_trim(skb, skb->len - 4);
+
+		wlandev->rx.decrypt++;
+	}
+
+	e_hdr = (wlan_ethhdr_t *) (skb->data + payload_offset);
+
+	e_llc = (wlan_llc_t *) (skb->data + payload_offset);
+	e_snap = (wlan_snap_t *) (skb->data + payload_offset + sizeof(wlan_llc_t));
+
+	/* Test for the various encodings */
+	if ( (payload_length >= sizeof(wlan_ethhdr_t)) &&
+	     ( e_llc->dsap != 0xaa || e_llc->ssap != 0xaa ) &&
+	     ((memcmp(daddr, e_hdr->daddr, WLAN_ETHADDR_LEN) == 0) ||
+	     (memcmp(saddr, e_hdr->saddr, WLAN_ETHADDR_LEN) == 0))) {
+		WLAN_LOG_DEBUG(3, "802.3 ENCAP len: %d\n", payload_length);
+		/* 802.3 Encapsulated */
+		/* Test for an overlength frame */
+		if ( payload_length > (netdev->mtu + WLAN_ETHHDR_LEN)) {
+			/* A bogus length ethfrm has been encap'd. */
+			/* Is someone trying an oflow attack? */
+			WLAN_LOG_ERROR("ENCAP frame too large (%d > %d)\n",
+				payload_length, netdev->mtu + WLAN_ETHHDR_LEN);
+			return 1;
+		}
+
+		/* Chop off the 802.11 header.  it's already sane. */
+		skb_pull(skb, payload_offset);
+		/* chop off the 802.11 CRC */
+		skb_trim(skb, skb->len - WLAN_CRC_LEN);
+
+	} else if ((payload_length >= sizeof(wlan_llc_t) + sizeof(wlan_snap_t)) &&
+		   (e_llc->dsap == 0xaa) &&
+		   (e_llc->ssap == 0xaa) &&
+		   (e_llc->ctl == 0x03) &&
+		   (((memcmp( e_snap->oui, oui_rfc1042, WLAN_IEEE_OUI_LEN)==0) &&
+		    (ethconv == WLAN_ETHCONV_8021h) &&
+		    (p80211_stt_findproto(ieee2host16(e_snap->type)))) ||
+		    (memcmp( e_snap->oui, oui_rfc1042, WLAN_IEEE_OUI_LEN)!=0)))
+	{
+		WLAN_LOG_DEBUG(3, "SNAP+RFC1042 len: %d\n", payload_length);
+		/* it's a SNAP + RFC1042 frame && protocol is in STT */
+		/* build 802.3 + RFC1042 */
+
+		/* Test for an overlength frame */
+		if ( payload_length > netdev->mtu ) {
+			/* A bogus length ethfrm has been sent. */
+			/* Is someone trying an oflow attack? */
+			WLAN_LOG_ERROR("SNAP frame too large (%d > %d)\n",
+				payload_length, netdev->mtu);
+			return 1;
+		}
+
+		/* chop 802.11 header from skb. */
+		skb_pull(skb, payload_offset);
+
+		/* create 802.3 header at beginning of skb. */
+		e_hdr = (wlan_ethhdr_t *) skb_push(skb, WLAN_ETHHDR_LEN);
+		memcpy(e_hdr->daddr, daddr, WLAN_ETHADDR_LEN);
+		memcpy(e_hdr->saddr, saddr, WLAN_ETHADDR_LEN);
+		e_hdr->type = htons(payload_length);
+
+		/* chop off the 802.11 CRC */
+		skb_trim(skb, skb->len - WLAN_CRC_LEN);
+
+	}  else if ((payload_length >= sizeof(wlan_llc_t) + sizeof(wlan_snap_t)) &&
+		    (e_llc->dsap == 0xaa) &&
+		    (e_llc->ssap == 0xaa) &&
+		    (e_llc->ctl == 0x03) ) {
+		WLAN_LOG_DEBUG(3, "802.1h/RFC1042 len: %d\n", payload_length);
+		/* it's an 802.1h frame || (an RFC1042 && protocol is not in STT) */
+		/* build a DIXII + RFC894 */
+
+		/* Test for an overlength frame */
+		if ((payload_length - sizeof(wlan_llc_t) - sizeof(wlan_snap_t))
+		    > netdev->mtu) {
+			/* A bogus length ethfrm has been sent. */
+			/* Is someone trying an oflow attack? */
+			WLAN_LOG_ERROR("DIXII frame too large (%ld > %d)\n",
+					(long int) (payload_length - sizeof(wlan_llc_t) -
+						    sizeof(wlan_snap_t)),
+					netdev->mtu);
+			return 1;
+		}
+
+		/* chop 802.11 header from skb. */
+		skb_pull(skb, payload_offset);
+
+		/* chop llc header from skb. */
+		skb_pull(skb, sizeof(wlan_llc_t));
+
+		/* chop snap header from skb. */
+		skb_pull(skb, sizeof(wlan_snap_t));
+
+		/* create 802.3 header at beginning of skb. */
+		e_hdr = (wlan_ethhdr_t *) skb_push(skb, WLAN_ETHHDR_LEN);
+		e_hdr->type = e_snap->type;
+		memcpy(e_hdr->daddr, daddr, WLAN_ETHADDR_LEN);
+		memcpy(e_hdr->saddr, saddr, WLAN_ETHADDR_LEN);
+
+		/* chop off the 802.11 CRC */
+		skb_trim(skb, skb->len - WLAN_CRC_LEN);
+	} else {
+		WLAN_LOG_DEBUG(3, "NON-ENCAP len: %d\n", payload_length);
+		/* any NON-ENCAP */
+		/* it's a generic 80211+LLC or IPX 'Raw 802.3' */
+		/*  build an 802.3 frame */
+		/* allocate space and setup hostbuf */
+
+		/* Test for an overlength frame */
+		if ( payload_length > netdev->mtu ) {
+			/* A bogus length ethfrm has been sent. */
+			/* Is someone trying an oflow attack? */
+			WLAN_LOG_ERROR("OTHER frame too large (%d > %d)\n",
+				payload_length,
+				netdev->mtu);
+			return 1;
+		}
+
+		/* Chop off the 802.11 header. */
+		skb_pull(skb, payload_offset);
+
+		/* create 802.3 header at beginning of skb. */
+		e_hdr = (wlan_ethhdr_t *) skb_push(skb, WLAN_ETHHDR_LEN);
+		memcpy(e_hdr->daddr, daddr, WLAN_ETHADDR_LEN);
+		memcpy(e_hdr->saddr, saddr, WLAN_ETHADDR_LEN);
+		e_hdr->type = htons(payload_length);
+
+		/* chop off the 802.11 CRC */
+		skb_trim(skb, skb->len - WLAN_CRC_LEN);
+
+	}
+
+	skb->protocol = eth_type_trans(skb, netdev);
+	skb_reset_mac_header(skb);
+
+        /* jkriegl: process signal and noise as set in hfa384x_int_rx() */
+	/* jkriegl: only process signal/noise if requested by iwspy */
+        if (wlandev->spy_number)
+                orinoco_spy_gather(wlandev, eth_hdr(skb)->h_source, P80211SKB_RXMETA(skb));
+
+	/* Free the metadata */
+	p80211skb_rxmeta_detach(skb);
+
+	DBFEXIT;
+	return 0;
+}
+
+/*----------------------------------------------------------------
+* p80211_stt_findproto
+*
+* Searches the 802.1h Selective Translation Table for a given
+* protocol.
+*
+* Arguments:
+*	proto	protocl number (in host order) to search for.
+*
+* Returns:
+*	1 - if the table is empty or a match is found.
+*	0 - if the table is non-empty and a match is not found.
+*
+* Call context:
+*	May be called in interrupt or non-interrupt context
+----------------------------------------------------------------*/
+int p80211_stt_findproto(UINT16 proto)
+{
+	/* Always return found for now.  This is the behavior used by the */
+	/*  Zoom Win95 driver when 802.1h mode is selected */
+	/* TODO: If necessary, add an actual search we'll probably
+		 need this to match the CMAC's way of doing things.
+		 Need to do some testing to confirm.
+	*/
+
+	if (proto == 0x80f3)  /* APPLETALK */
+		return 1;
+
+	return 0;
+}
+
+/*----------------------------------------------------------------
+* p80211skb_rxmeta_detach
+*
+* Disconnects the frmmeta and rxmeta from an skb.
+*
+* Arguments:
+*	wlandev		The wlandev this skb belongs to.
+*	skb		The skb we're attaching to.
+*
+* Returns:
+*	0 on success, non-zero otherwise
+*
+* Call context:
+*	May be called in interrupt or non-interrupt context
+----------------------------------------------------------------*/
+void
+p80211skb_rxmeta_detach(struct sk_buff *skb)
+{
+	p80211_rxmeta_t		*rxmeta;
+	p80211_frmmeta_t	*frmmeta;
+
+	DBFENTER;
+	/* Sanity checks */
+	if ( skb==NULL ) {			/* bad skb */
+		WLAN_LOG_DEBUG(1, "Called w/ null skb.\n");
+		goto exit;
+	}
+	frmmeta = P80211SKB_FRMMETA(skb);
+	if ( frmmeta == NULL ) { 		/* no magic */
+		WLAN_LOG_DEBUG(1, "Called w/ bad frmmeta magic.\n");
+		goto exit;
+	}
+	rxmeta = frmmeta->rx;
+	if ( rxmeta == NULL ) {			/* bad meta ptr */
+		WLAN_LOG_DEBUG(1, "Called w/ bad rxmeta ptr.\n");
+		goto exit;
+	}
+
+	/* Free rxmeta */
+	kfree(rxmeta);
+
+	/* Clear skb->cb */
+	memset(skb->cb, 0, sizeof(skb->cb));
+exit:
+	DBFEXIT;
+	return;
+}
+
+/*----------------------------------------------------------------
+* p80211skb_rxmeta_attach
+*
+* Allocates a p80211rxmeta structure, initializes it, and attaches
+* it to an skb.
+*
+* Arguments:
+*	wlandev		The wlandev this skb belongs to.
+*	skb		The skb we're attaching to.
+*
+* Returns:
+*	0 on success, non-zero otherwise
+*
+* Call context:
+*	May be called in interrupt or non-interrupt context
+----------------------------------------------------------------*/
+int
+p80211skb_rxmeta_attach(struct wlandevice *wlandev, struct sk_buff *skb)
+{
+	int			result = 0;
+	p80211_rxmeta_t		*rxmeta;
+	p80211_frmmeta_t	*frmmeta;
+
+	DBFENTER;
+
+	/* If these already have metadata, we error out! */
+	if (P80211SKB_RXMETA(skb) != NULL) {
+		WLAN_LOG_ERROR("%s: RXmeta already attached!\n",
+				wlandev->name);
+		result = 0;
+		goto exit;
+	}
+
+	/* Allocate the rxmeta */
+	rxmeta = kmalloc(sizeof(p80211_rxmeta_t), GFP_ATOMIC);
+
+	if ( rxmeta == NULL ) {
+		WLAN_LOG_ERROR("%s: Failed to allocate rxmeta.\n",
+				wlandev->name);
+		result = 1;
+		goto exit;
+	}
+
+	/* Initialize the rxmeta */
+	memset(rxmeta, 0, sizeof(p80211_rxmeta_t));
+	rxmeta->wlandev = wlandev;
+	rxmeta->hosttime = jiffies;
+
+	/* Overlay a frmmeta_t onto skb->cb */
+	memset(skb->cb, 0, sizeof(p80211_frmmeta_t));
+	frmmeta = (p80211_frmmeta_t*)(skb->cb);
+	frmmeta->magic = P80211_FRMMETA_MAGIC;
+	frmmeta->rx = rxmeta;
+exit:
+	DBFEXIT;
+	return result;
+}
+
+/*----------------------------------------------------------------
+* p80211skb_free
+*
+* Frees an entire p80211skb by checking and freeing the meta struct
+* and then freeing the skb.
+*
+* Arguments:
+*	wlandev		The wlandev this skb belongs to.
+*	skb		The skb we're attaching to.
+*
+* Returns:
+*	0 on success, non-zero otherwise
+*
+* Call context:
+*	May be called in interrupt or non-interrupt context
+----------------------------------------------------------------*/
+void
+p80211skb_free(struct wlandevice *wlandev, struct sk_buff *skb)
+{
+	p80211_frmmeta_t	*meta;
+	DBFENTER;
+	meta = P80211SKB_FRMMETA(skb);
+	if ( meta && meta->rx) {
+		p80211skb_rxmeta_detach(skb);
+	} else {
+		WLAN_LOG_ERROR("Freeing an skb (%p) w/ no frmmeta.\n", skb);
+	}
+
+	dev_kfree_skb(skb);
+	DBFEXIT;
+	return;
+}
