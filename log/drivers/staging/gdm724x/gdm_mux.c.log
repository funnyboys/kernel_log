commit ed98730d9f25290b157839ccc0f925b53afa7b6a
Author: Ignacio Losiggio <iglosiggio@gmail.com>
Date:   Sun Mar 17 22:15:36 2019 -0300

    staging: gdm724x: Do not break expressions
    
    When the entire expression can be shown in the same line breaking it
    makes it more difficult to read.
    
    Signed-off-by: Ignacio Losiggio <iglosiggio@dc.uba.ar>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gdm724x/gdm_mux.c b/drivers/staging/gdm724x/gdm_mux.c
index e2a050ba6fbb..0678f344fafb 100644
--- a/drivers/staging/gdm724x/gdm_mux.c
+++ b/drivers/staging/gdm724x/gdm_mux.c
@@ -164,8 +164,7 @@ static int up_to_host(struct mux_rx *r)
 
 		total_len = ALIGN(MUX_HEADER_SIZE + payload_size, 4);
 
-		if (len - packet_size_sum <
-			total_len) {
+		if (len - packet_size_sum < total_len) {
 			pr_err("invalid payload : %d %d %04x\n",
 			       payload_size, len, packet_type);
 			break;
@@ -376,8 +375,8 @@ static int gdm_mux_send(void *priv_dev, void *data, int len, int tty_index,
 	mux_header->packet_type = __cpu_to_le16(packet_type[tty_index]);
 
 	memcpy(t->buf + MUX_HEADER_SIZE, data, len);
-	memset(t->buf + MUX_HEADER_SIZE + len, 0, total_len - MUX_HEADER_SIZE -
-	       len);
+	memset(t->buf + MUX_HEADER_SIZE + len, 0,
+	       total_len - MUX_HEADER_SIZE - len);
 
 	t->len = total_len;
 	t->callback = cb;

commit ad9bd58c2adf6c4faf5e62bf7479d2d30c183bc6
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Apr 25 15:11:18 2018 +0200

    staging: gdm724x: remove redundant license information
    
    Now that the SPDX tag is in all gdm724x files, that identifies the
    license in a specific and legally-defined manner.  So the extra GPL text
    wording can be removed as it is no longer needed at all.
    
    This is done on a quest to remove the 700+ different ways that files in
    the kernel describe the GPL license text.  And there's unneeded stuff
    like the address (sometimes incorrect) for the FSF which is never
    needed.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gdm724x/gdm_mux.c b/drivers/staging/gdm724x/gdm_mux.c
index 8b860e2f5192..e2a050ba6fbb 100644
--- a/drivers/staging/gdm724x/gdm_mux.c
+++ b/drivers/staging/gdm724x/gdm_mux.c
@@ -1,16 +1,5 @@
 // SPDX-License-Identifier: GPL-2.0
-/*
- * Copyright (c) 2012 GCT Semiconductor, Inc. All rights reserved.
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
- */
+/* Copyright (c) 2012 GCT Semiconductor, Inc. All rights reserved. */
 
 #define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
 

commit 1146ee4a9a7e5b79a95ebddfb2853017542ddb93
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Apr 25 15:11:17 2018 +0200

    staging: gdm724x: add SPDX identifiers to all files.
    
    It's good to have SPDX identifiers in all files to make it easier to
    audit the kernel tree for correct licenses.
    
    Fix up the all of the staging gdm724x files to have a proper SPDX
    identifier, based on the license text in the file itself.  The SPDX
    identifier is a legally binding shorthand, which can be used instead of
    the full boiler plate text.
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: Philippe Ombredanne <pombredanne@nexb.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gdm724x/gdm_mux.c b/drivers/staging/gdm724x/gdm_mux.c
index 63921bad519e..8b860e2f5192 100644
--- a/drivers/staging/gdm724x/gdm_mux.c
+++ b/drivers/staging/gdm724x/gdm_mux.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * Copyright (c) 2012 GCT Semiconductor, Inc. All rights reserved.
  *

commit a4b0330ec145909427d79556ac139c04517e81bb
Author: Quytelda Kahja <quytelda@tamalin.org>
Date:   Sat Feb 17 23:06:35 2018 -0800

    Staging: gdm724x: mux: Check return value of register_lte_tty_driver().
    
    Check the return value of of the register_lte_tty_driver() call in the
    module initialization function.
    
    Signed-off-by: Quytelda Kahja <quytelda@tamalin.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gdm724x/gdm_mux.c b/drivers/staging/gdm724x/gdm_mux.c
index 996b1f538aae..63921bad519e 100644
--- a/drivers/staging/gdm724x/gdm_mux.c
+++ b/drivers/staging/gdm724x/gdm_mux.c
@@ -657,7 +657,11 @@ static struct usb_driver gdm_mux_driver = {
 
 static int __init gdm_usb_mux_init(void)
 {
-	register_lte_tty_driver();
+	int ret;
+
+	ret = register_lte_tty_driver();
+	if (ret)
+		return ret;
 
 	return usb_register(&gdm_mux_driver);
 }

commit b58f45c8fc301fe83ee28cad3e64686c19e78f1c
Author: Johan Hovold <johan@kernel.org>
Date:   Wed Apr 26 12:23:04 2017 +0200

    staging: gdm724x: gdm_mux: fix use-after-free on module unload
    
    Make sure to deregister the USB driver before releasing the tty driver
    to avoid use-after-free in the USB disconnect callback where the tty
    devices are deregistered.
    
    Fixes: 61e121047645 ("staging: gdm7240: adding LTE USB driver")
    Cc: stable <stable@vger.kernel.org>     # 3.12
    Cc: Won Kang <wkang77@gmail.com>
    Signed-off-by: Johan Hovold <johan@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gdm724x/gdm_mux.c b/drivers/staging/gdm724x/gdm_mux.c
index aba32e22db0c..996b1f538aae 100644
--- a/drivers/staging/gdm724x/gdm_mux.c
+++ b/drivers/staging/gdm724x/gdm_mux.c
@@ -664,9 +664,8 @@ static int __init gdm_usb_mux_init(void)
 
 static void __exit gdm_usb_mux_exit(void)
 {
-	unregister_lte_tty_driver();
-
 	usb_deregister(&gdm_mux_driver);
+	unregister_lte_tty_driver();
 }
 
 module_init(gdm_usb_mux_init);

commit ca5af1f303d16cdf183354abffba46528b72a163
Author: simran singhal <singhalsimran0@gmail.com>
Date:   Wed Feb 22 07:31:09 2017 +0530

    staging: gdm724x: Drop useless initialisation
    
    Removed initialisation of a varible if it is immediately reassigned.
    
    Changes were made using Coccinelle.
    
    @@
    type T;
    constant C;
    expression e;
    identifier i;
    @@
    T i
    - = C
    ;
    i = e;
    
    Signed-off-by: simran singhal <singhalsimran0@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gdm724x/gdm_mux.c b/drivers/staging/gdm724x/gdm_mux.c
index 400969170d1c..aba32e22db0c 100644
--- a/drivers/staging/gdm724x/gdm_mux.c
+++ b/drivers/staging/gdm724x/gdm_mux.c
@@ -62,7 +62,7 @@ static int packet_type_to_index(u16 packetType)
 
 static struct mux_tx *alloc_mux_tx(int len)
 {
-	struct mux_tx *t = NULL;
+	struct mux_tx *t;
 
 	t = kzalloc(sizeof(*t), GFP_ATOMIC);
 	if (!t)
@@ -91,7 +91,7 @@ static void free_mux_tx(struct mux_tx *t)
 
 static struct mux_rx *alloc_mux_rx(void)
 {
-	struct mux_rx *r = NULL;
+	struct mux_rx *r;
 
 	r = kzalloc(sizeof(*r), GFP_KERNEL);
 	if (!r)

commit 47678e37927019265ab9c9a2103a0ef76b2584a6
Author: Bruno Carvalho <brunocarvalhofarias@gmail.com>
Date:   Sat May 7 22:15:53 2016 -0400

    staging/gdm724x: fix "alignment should match open parenthesis" issues
    
    Fix checkpatch issues: "CHECK: Alignment should match open parenthesis"
    
    Signed-off-by: Bruno Carvalho <brunocarvalhofarias@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gdm724x/gdm_mux.c b/drivers/staging/gdm724x/gdm_mux.c
index 6bedd668324c..400969170d1c 100644
--- a/drivers/staging/gdm724x/gdm_mux.c
+++ b/drivers/staging/gdm724x/gdm_mux.c
@@ -278,8 +278,9 @@ static void gdm_mux_rcv_complete(struct urb *urb)
 	}
 }
 
-static int gdm_mux_recv(void *priv_dev, int (*cb)(void *data, int len,
-			int tty_index, struct tty_dev *tty_dev, int complete))
+static int gdm_mux_recv(void *priv_dev,
+			int (*cb)(void *data, int len, int tty_index,
+				  struct tty_dev *tty_dev, int complete))
 {
 	struct mux_dev *mux_dev = priv_dev;
 	struct usb_device *usbdev = mux_dev->usbdev;

commit 6c6baa841662e1ab46353fee3c618d9f347ce06e
Author: Bhumika Goyal <bhumirks@gmail.com>
Date:   Fri Feb 26 15:34:32 2016 +0530

    Staging: gdm724x: Use min instead of ternary operator
    
    This patch replaces ternary operator with macro min as it shorter and
    thus increases code readability. Macro min return the minimum of the
    two compared values.
    Made a semantic patch for changes:
    
    @@
    type T;
    T x;
    T y;
    @@
    (
    - x < y ? x : y
    + min(x,y)
    |
    - x > y ? x : y
    + max(x,y)
    )
    
    Signed-off-by: Bhumika Goyal <bhumirks@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gdm724x/gdm_mux.c b/drivers/staging/gdm724x/gdm_mux.c
index 937010b3a603..6bedd668324c 100644
--- a/drivers/staging/gdm724x/gdm_mux.c
+++ b/drivers/staging/gdm724x/gdm_mux.c
@@ -433,7 +433,7 @@ static int gdm_mux_send_control(void *priv_dev, int request, int value,
 	if (ret < 0)
 		pr_err("usb_control_msg error: %d\n", ret);
 
-	return ret < 0 ? ret : 0;
+	return min(ret, 0);
 }
 
 static void release_usb(struct mux_dev *mux_dev)

commit c272dc2da14cde0bfd9495a5aafb8e3e94f35601
Author: Amitoj Kaur Chawla <amitoj1606@gmail.com>
Date:   Sat Feb 13 10:31:02 2016 +0530

    staging: gdm724x: gdm_mux: Remove create_workqueue()
    
    With concurrency managed workqueues, use of dedicated workqueues
    can be replaced by using system_wq. Drop mux_rx_wq by using system_wq.
    
    Since there is only one work item per mux_dev and different mux_devs
    do not need to be ordered, increase of concurrency level by switching
    to system_wq should not break anything.
    
    cancel_work_sync() is used to ensure that work is not pending or
    executing on any CPU.
    
    Lastly, since all devices are suspended, which shutdowns the work item
    before the driver can be unregistered, it is guaranteed that no work
    item is pending or executing by the time exit path runs.
    
    Signed-off-by: Amitoj Kaur Chawla <amitoj1606@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gdm724x/gdm_mux.c b/drivers/staging/gdm724x/gdm_mux.c
index 445f83615575..937010b3a603 100644
--- a/drivers/staging/gdm724x/gdm_mux.c
+++ b/drivers/staging/gdm724x/gdm_mux.c
@@ -26,8 +26,6 @@
 
 #include "gdm_mux.h"
 
-static struct workqueue_struct *mux_rx_wq;
-
 static u16 packet_type[TTY_MAX_COUNT] = {0xF011, 0xF010};
 
 #define USB_DEVICE_CDC_DATA(vid, pid) \
@@ -275,7 +273,7 @@ static void gdm_mux_rcv_complete(struct urb *urb)
 		r->len = r->urb->actual_length;
 		spin_lock_irqsave(&rx->to_host_lock, flags);
 		list_add_tail(&r->to_host_list, &rx->to_host_list);
-		queue_work(mux_rx_wq, &mux_dev->work_rx.work);
+		schedule_work(&mux_dev->work_rx.work);
 		spin_unlock_irqrestore(&rx->to_host_lock, flags);
 	}
 }
@@ -602,6 +600,8 @@ static int gdm_mux_suspend(struct usb_interface *intf, pm_message_t pm_msg)
 	mux_dev = tty_dev->priv_dev;
 	rx = &mux_dev->rx;
 
+	cancel_work_sync(&mux_dev->work_rx.work);
+
 	if (mux_dev->usb_state != PM_NORMAL) {
 		dev_err(intf->usb_dev, "usb suspend - invalid state\n");
 		return -1;
@@ -656,13 +656,6 @@ static struct usb_driver gdm_mux_driver = {
 
 static int __init gdm_usb_mux_init(void)
 {
-
-	mux_rx_wq = create_workqueue("mux_rx_wq");
-	if (!mux_rx_wq) {
-		pr_err("work queue create fail\n");
-		return -1;
-	}
-
 	register_lte_tty_driver();
 
 	return usb_register(&gdm_mux_driver);
@@ -672,11 +665,6 @@ static void __exit gdm_usb_mux_exit(void)
 {
 	unregister_lte_tty_driver();
 
-	if (mux_rx_wq) {
-		flush_workqueue(mux_rx_wq);
-		destroy_workqueue(mux_rx_wq);
-	}
-
 	usb_deregister(&gdm_mux_driver);
 }
 

commit a487db8b67044b98fddf5433d4a5c96a2ce06d3a
Author: Ioana Ciornei <ciorneiioana@gmail.com>
Date:   Sun Oct 18 15:51:52 2015 +0300

    staging: gdm724x: remove multiple blank lines
    
    This patch removes multiple blank lines in order to follow linux
    kernel coding style.
    
    Signed-off-by: Ioana Ciornei <ciorneiioana@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gdm724x/gdm_mux.c b/drivers/staging/gdm724x/gdm_mux.c
index 79af94f9a61d..445f83615575 100644
--- a/drivers/staging/gdm724x/gdm_mux.c
+++ b/drivers/staging/gdm724x/gdm_mux.c
@@ -48,7 +48,6 @@ static const struct usb_device_id id_table[] = {
 	{}
 };
 
-
 MODULE_DEVICE_TABLE(usb, id_table);
 
 static int packet_type_to_index(u16 packetType)
@@ -150,7 +149,6 @@ static void put_rx_struct(struct rx_cxt *rx, struct mux_rx *r)
 	spin_unlock_irqrestore(&rx->free_list_lock, flags);
 }
 
-
 static int up_to_host(struct mux_rx *r)
 {
 	struct mux_dev *mux_dev = r->mux_dev;
@@ -474,7 +472,6 @@ static void release_usb(struct mux_dev *mux_dev)
 	spin_unlock_irqrestore(&rx->to_host_lock, flags);
 }
 
-
 static int init_usb(struct mux_dev *mux_dev)
 {
 	struct mux_rx *r;
@@ -612,7 +609,6 @@ static int gdm_mux_suspend(struct usb_interface *intf, pm_message_t pm_msg)
 
 	mux_dev->usb_state = PM_SUSPEND;
 
-
 	spin_lock_irqsave(&rx->submit_list_lock, flags);
 	list_for_each_entry_safe(r, r_next, &rx->rx_submit_list,
 				 rx_submit_list) {

commit 7b7df122f894f5b731e0f06777302ec248a7d9f1
Author: Ioana Ciornei <ciorneiioana@gmail.com>
Date:   Sun Oct 18 15:51:51 2015 +0300

    staging: gdm724x: correct kzalloc/kmalloc sizeof argument
    
    This patch converts sizeof(TYPE) to sizeof(VAR) when used as
    a kzalloc/kmaloc argument.
    
    Signed-off-by: Ioana Ciornei <ciorneiioana@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gdm724x/gdm_mux.c b/drivers/staging/gdm724x/gdm_mux.c
index 47148cfcbf1f..79af94f9a61d 100644
--- a/drivers/staging/gdm724x/gdm_mux.c
+++ b/drivers/staging/gdm724x/gdm_mux.c
@@ -67,7 +67,7 @@ static struct mux_tx *alloc_mux_tx(int len)
 {
 	struct mux_tx *t = NULL;
 
-	t = kzalloc(sizeof(struct mux_tx), GFP_ATOMIC);
+	t = kzalloc(sizeof(*t), GFP_ATOMIC);
 	if (!t)
 		return NULL;
 
@@ -96,7 +96,7 @@ static struct mux_rx *alloc_mux_rx(void)
 {
 	struct mux_rx *r = NULL;
 
-	r = kzalloc(sizeof(struct mux_rx), GFP_KERNEL);
+	r = kzalloc(sizeof(*r), GFP_KERNEL);
 	if (!r)
 		return NULL;
 
@@ -526,11 +526,11 @@ static int gdm_mux_probe(struct usb_interface *intf,
 	if (bInterfaceNumber != 2)
 		return -ENODEV;
 
-	mux_dev = kzalloc(sizeof(struct mux_dev), GFP_KERNEL);
+	mux_dev = kzalloc(sizeof(*mux_dev), GFP_KERNEL);
 	if (!mux_dev)
 		return -ENOMEM;
 
-	tty_dev = kzalloc(sizeof(struct tty_dev), GFP_KERNEL);
+	tty_dev = kzalloc(sizeof(*tty_dev), GFP_KERNEL);
 	if (!tty_dev) {
 		ret = -ENOMEM;
 		goto err_free_mux;

commit ba7f55b705b94e26293971b9fbda183238cdc30c
Author: Ioana Ciornei <ciorneiioana@gmail.com>
Date:   Sun Oct 18 15:51:50 2015 +0300

    staging: gdm724x: add spaces around binary operators
    
    This patch add spaces around binary operators in order
    to follow kernel coding style.
    
    Signed-off-by: Ioana Ciornei <ciorneiioana@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gdm724x/gdm_mux.c b/drivers/staging/gdm724x/gdm_mux.c
index 0408549ca994..47148cfcbf1f 100644
--- a/drivers/staging/gdm724x/gdm_mux.c
+++ b/drivers/staging/gdm724x/gdm_mux.c
@@ -388,8 +388,8 @@ static int gdm_mux_send(void *priv_dev, void *data, int len, int tty_index,
 	mux_header->payload_size = __cpu_to_le32((u32)len);
 	mux_header->packet_type = __cpu_to_le16(packet_type[tty_index]);
 
-	memcpy(t->buf+MUX_HEADER_SIZE, data, len);
-	memset(t->buf+MUX_HEADER_SIZE+len, 0, total_len - MUX_HEADER_SIZE -
+	memcpy(t->buf + MUX_HEADER_SIZE, data, len);
+	memset(t->buf + MUX_HEADER_SIZE + len, 0, total_len - MUX_HEADER_SIZE -
 	       len);
 
 	t->len = total_len;

commit b6f6fd8a871cebc8085719c08ea489d1d98bb21e
Author: Ioana Ciornei <ciorneiioana@gmail.com>
Date:   Sun Oct 18 15:51:49 2015 +0300

    stating: gdm724x: remove explicit NULL comparison
    
    This patch converts explicit NULL comparison to its shorter
    equivalent form.
    Done with coccinelle semantic patch:
    
    @@
    expression e;
    @@
    
    - e == NULL
    + !e
    
    Signed-off-by: Ioana Ciornei <ciorneiioana@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gdm724x/gdm_mux.c b/drivers/staging/gdm724x/gdm_mux.c
index e82f3179c5db..0408549ca994 100644
--- a/drivers/staging/gdm724x/gdm_mux.c
+++ b/drivers/staging/gdm724x/gdm_mux.c
@@ -492,7 +492,7 @@ static int init_usb(struct mux_dev *mux_dev)
 
 	for (i = 0; i < MAX_ISSUE_NUM * 2; i++) {
 		r = alloc_mux_rx();
-		if (r == NULL) {
+		if (!r) {
 			ret = -ENOMEM;
 			break;
 		}
@@ -662,7 +662,7 @@ static int __init gdm_usb_mux_init(void)
 {
 
 	mux_rx_wq = create_workqueue("mux_rx_wq");
-	if (mux_rx_wq == NULL) {
+	if (!mux_rx_wq) {
 		pr_err("work queue create fail\n");
 		return -1;
 	}

commit a4785ef8102390fa7e0e8865efd44036b7337e22
Author: Ioana Ciornei <ciorneiioana@gmail.com>
Date:   Sun Oct 18 15:51:48 2015 +0300

    staging: gdm724x: properly indent to match open paranthesis
    
    Indent parameters and arguments passed to function calls to match
    open paranthesis
    
    Signed-off-by: Ioana Ciornei <ciorneiioana@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gdm724x/gdm_mux.c b/drivers/staging/gdm724x/gdm_mux.c
index 07de99cf473e..e82f3179c5db 100644
--- a/drivers/staging/gdm724x/gdm_mux.c
+++ b/drivers/staging/gdm724x/gdm_mux.c
@@ -271,7 +271,7 @@ static void gdm_mux_rcv_complete(struct urb *urb)
 	if (urb->status) {
 		if (mux_dev->usb_state == PM_NORMAL)
 			dev_err(&urb->dev->dev, "%s: urb status error %d\n",
-			       __func__, urb->status);
+				__func__, urb->status);
 		put_rx_struct(rx, r);
 	} else {
 		r->len = r->urb->actual_length;

commit 15aae23e9e5e98a93cf4d942080d17a6ef07d074
Author: Shivani Bhardwaj <shivanib134@gmail.com>
Date:   Fri Oct 16 20:56:22 2015 +0530

    Staging: gdx724x: gdm_mux: Remove explicit cast
    
    Compiler can typecast variables implicitly so, explicit type cast is not
    required and should be removed.
    Semantic patch used:
    
    @@
    type T;
    T e;
    identifier x;
    @@
    
    * T x = (T)e;
    
    Signed-off-by: Shivani Bhardwaj <shivanib134@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gdm724x/gdm_mux.c b/drivers/staging/gdm724x/gdm_mux.c
index 97b72a0b4ab7..07de99cf473e 100644
--- a/drivers/staging/gdm724x/gdm_mux.c
+++ b/drivers/staging/gdm724x/gdm_mux.c
@@ -222,7 +222,7 @@ static void do_rx(struct work_struct *work)
 	struct mux_dev *mux_dev =
 		container_of(work, struct mux_dev, work_rx.work);
 	struct mux_rx *r;
-	struct rx_cxt *rx = (struct rx_cxt *)&mux_dev->rx;
+	struct rx_cxt *rx = &mux_dev->rx;
 	unsigned long flags;
 	int ret = 0;
 

commit 2594ca30c0ae7f126fc84dc3a795f007c2b2787f
Author: Shraddha Barke <shraddha.6596@gmail.com>
Date:   Thu Oct 15 00:58:20 2015 +0530

    Staging: gdm724x: Remove unnecessary cast on void pointer
    
    void pointers do not need to be cast to other pointer types.
    
    Semantic patch:
    
    @r@
    expression x;
    void* e;
    type T;
    identifier f;
    @@
    
    (
      *((T *)e)
    |
      ((T *)x)[...]
    |
      ((T *)x)->f
    |
    - (T *)
      e
    )
    
    Signed-off-by: Shraddha Barke <shraddha.6596@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gdm724x/gdm_mux.c b/drivers/staging/gdm724x/gdm_mux.c
index 1cf24e4edf25..97b72a0b4ab7 100644
--- a/drivers/staging/gdm724x/gdm_mux.c
+++ b/drivers/staging/gdm724x/gdm_mux.c
@@ -153,7 +153,7 @@ static void put_rx_struct(struct rx_cxt *rx, struct mux_rx *r)
 
 static int up_to_host(struct mux_rx *r)
 {
-	struct mux_dev *mux_dev = (struct mux_dev *)r->mux_dev;
+	struct mux_dev *mux_dev = r->mux_dev;
 	struct mux_pkt_header *mux_header;
 	unsigned int start_flag;
 	unsigned int payload_size;
@@ -262,7 +262,7 @@ static void remove_rx_submit_list(struct mux_rx *r, struct rx_cxt *rx)
 static void gdm_mux_rcv_complete(struct urb *urb)
 {
 	struct mux_rx *r = urb->context;
-	struct mux_dev *mux_dev = (struct mux_dev *)r->mux_dev;
+	struct mux_dev *mux_dev = r->mux_dev;
 	struct rx_cxt *rx = &mux_dev->rx;
 	unsigned long flags;
 

commit 892c89d5d7ffd1bb794fe54d86c0eef18d215fab
Author: Sławomir Demeszko <s.demeszko@wireless-instruments.com>
Date:   Tue May 5 17:49:54 2015 +0200

    staging: gdm724x: Correction of variable usage after applying ALIGN()
    
    Fix regression introduced by commit <29ef8a53542a>. After it writing
    AT commands to /dev/GCT-ATM0 is unsuccessful (no echo, no response)
    and dmesg show "gdmtty: invalid payload : 1 16 f011".
    
    Before that commit value of dummy_cnt was only a padding size. After using
    ALIGN() this value is increased by its first argument. So the following
    usage of this variable needs correction.
    
    Signed-off-by: Sławomir Demeszko <s.demeszko@wireless-instruments.com>
    Cc: stable <stable@vger.kernel.org> # 3.14+
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gdm724x/gdm_mux.c b/drivers/staging/gdm724x/gdm_mux.c
index 8199b0a697bb..1cf24e4edf25 100644
--- a/drivers/staging/gdm724x/gdm_mux.c
+++ b/drivers/staging/gdm724x/gdm_mux.c
@@ -158,7 +158,7 @@ static int up_to_host(struct mux_rx *r)
 	unsigned int start_flag;
 	unsigned int payload_size;
 	unsigned short packet_type;
-	int dummy_cnt;
+	int total_len;
 	u32 packet_size_sum = r->offset;
 	int index;
 	int ret = TO_HOST_INVALID_PACKET;
@@ -176,10 +176,10 @@ static int up_to_host(struct mux_rx *r)
 			break;
 		}
 
-		dummy_cnt = ALIGN(MUX_HEADER_SIZE + payload_size, 4);
+		total_len = ALIGN(MUX_HEADER_SIZE + payload_size, 4);
 
 		if (len - packet_size_sum <
-			MUX_HEADER_SIZE + payload_size + dummy_cnt) {
+			total_len) {
 			pr_err("invalid payload : %d %d %04x\n",
 			       payload_size, len, packet_type);
 			break;
@@ -202,7 +202,7 @@ static int up_to_host(struct mux_rx *r)
 			break;
 		}
 
-		packet_size_sum += MUX_HEADER_SIZE + payload_size + dummy_cnt;
+		packet_size_sum += total_len;
 		if (len - packet_size_sum <= MUX_HEADER_SIZE + 2) {
 			ret = r->callback(NULL,
 					0,
@@ -361,7 +361,6 @@ static int gdm_mux_send(void *priv_dev, void *data, int len, int tty_index,
 	struct mux_pkt_header *mux_header;
 	struct mux_tx *t = NULL;
 	static u32 seq_num = 1;
-	int dummy_cnt;
 	int total_len;
 	int ret;
 	unsigned long flags;
@@ -374,9 +373,7 @@ static int gdm_mux_send(void *priv_dev, void *data, int len, int tty_index,
 
 	spin_lock_irqsave(&mux_dev->write_lock, flags);
 
-	dummy_cnt = ALIGN(MUX_HEADER_SIZE + len, 4);
-
-	total_len = len + MUX_HEADER_SIZE + dummy_cnt;
+	total_len = ALIGN(MUX_HEADER_SIZE + len, 4);
 
 	t = alloc_mux_tx(total_len);
 	if (!t) {
@@ -392,7 +389,8 @@ static int gdm_mux_send(void *priv_dev, void *data, int len, int tty_index,
 	mux_header->packet_type = __cpu_to_le16(packet_type[tty_index]);
 
 	memcpy(t->buf+MUX_HEADER_SIZE, data, len);
-	memset(t->buf+MUX_HEADER_SIZE+len, 0, dummy_cnt);
+	memset(t->buf+MUX_HEADER_SIZE+len, 0, total_len - MUX_HEADER_SIZE -
+	       len);
 
 	t->len = total_len;
 	t->callback = cb;

commit 3d719423da9fdaa4c126a91cac91c3a0679226df
Author: Haneen Mohammed <hamohammed.sa@gmail.com>
Date:   Wed Mar 18 13:08:59 2015 +0300

    Staging: gdm724x: replace pr_* with dev_*
    
    This patch replace pr_err/pr_info with dev_err/dev_info, when
    appropriate device structure is found.
    
    Issue found  and resolved using the following Coccinelle script.
    pr_err/dev_err was substituted with pr_info/dev_info in the later case.
    
    @r exists@
    identifier f, s, i;
    position p;
    @@
    f(...,struct s *i,...) {
    <+...
    when != i == NULL
    pr_err@p(...);
    ...+>
    }
    @rr@
    identifier r.s, s2, fld;
    @@
    
    struct s {
            ...
            struct s2 *fld;
            ...
    };
    
    @rrr@
    identifier rr.s2, fld2;
    @@
    
    struct s2 {
            ...
            struct device fld2;
            ...
    };
    @@
    identifier r.i, r.s, rr.fld, rrr.fld2;
    position r.p;
    @@
    
    -pr_err@p
    +dev_err
       (
    + &i->fld->fld2,
    ...)
    
    Signed-off-by: Haneen Mohammed <hamohammed.sa@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gdm724x/gdm_mux.c b/drivers/staging/gdm724x/gdm_mux.c
index b987ba0510b7..8199b0a697bb 100644
--- a/drivers/staging/gdm724x/gdm_mux.c
+++ b/drivers/staging/gdm724x/gdm_mux.c
@@ -270,7 +270,7 @@ static void gdm_mux_rcv_complete(struct urb *urb)
 
 	if (urb->status) {
 		if (mux_dev->usb_state == PM_NORMAL)
-			pr_err("%s: urb status error %d\n",
+			dev_err(&urb->dev->dev, "%s: urb status error %d\n",
 			       __func__, urb->status);
 		put_rx_struct(rx, r);
 	} else {
@@ -342,7 +342,7 @@ static void gdm_mux_send_complete(struct urb *urb)
 	struct mux_tx *t = urb->context;
 
 	if (urb->status == -ECONNRESET) {
-		pr_info("CONNRESET\n");
+		dev_info(&urb->dev->dev, "CONNRESET\n");
 		free_mux_tx(t);
 		return;
 	}

commit df02b50acfcec04cd50abc5f6265118d2cdacbee
Author: Haneen Mohammed <hamohammed.sa@gmail.com>
Date:   Tue Mar 17 08:34:20 2015 +0300

    Staging: gdm724x: replace pr_err with dev_err
    
    This patch replace pr_err with dev_err, when appropriate device structre
    is found.
    Issue found using the following Coccinelle script:
    
    @r exists@
    identifier f, s, i;
    position p;
    @@
    
    f(...,struct s *i,...) {
    <+...
    when != i == NULL
    pr_err@p(...);
    ...+>
    }
    
    @rr@
    identifier r.s, fld;
    @@
    
    struct s {
            ...
            struct device *fld;
            ...
    };
    
    @@
    identifier r.i, rr.fld;
    position r.p;
    @@
    -pr_err@p
    +dev_err
       (
    + i->fld,
    ...)
    
    Signed-off-by: Haneen Mohammed <hamohammed.sa@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gdm724x/gdm_mux.c b/drivers/staging/gdm724x/gdm_mux.c
index d1ab996b3305..b987ba0510b7 100644
--- a/drivers/staging/gdm724x/gdm_mux.c
+++ b/drivers/staging/gdm724x/gdm_mux.c
@@ -608,7 +608,7 @@ static int gdm_mux_suspend(struct usb_interface *intf, pm_message_t pm_msg)
 	rx = &mux_dev->rx;
 
 	if (mux_dev->usb_state != PM_NORMAL) {
-		pr_err("usb suspend - invalid state\n");
+		dev_err(intf->usb_dev, "usb suspend - invalid state\n");
 		return -1;
 	}
 
@@ -637,7 +637,7 @@ static int gdm_mux_resume(struct usb_interface *intf)
 	mux_dev = tty_dev->priv_dev;
 
 	if (mux_dev->usb_state != PM_SUSPEND) {
-		pr_err("usb resume - invalid state\n");
+		dev_err(intf->usb_dev, "usb resume - invalid state\n");
 		return -1;
 	}
 

commit 2fc6aa5d745477b995708b3edc601525367edbd4
Author: Robert Nachlinger <robert.nachlinger@gmail.com>
Date:   Thu Dec 18 17:57:06 2014 +0100

    Staging: gdm724x: fix space before comma coding style issue in gdm_mux.c
    
    This is a patch to the gdm_mux.c file that fixes a space before comma
    coding style issue found by the checkpatch.pl tool.
    
    Signed-off-by: Robert Nachlinger <robert.nachlinger@googlemail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gdm724x/gdm_mux.c b/drivers/staging/gdm724x/gdm_mux.c
index b5b063a738f8..d1ab996b3305 100644
--- a/drivers/staging/gdm724x/gdm_mux.c
+++ b/drivers/staging/gdm724x/gdm_mux.c
@@ -220,7 +220,7 @@ static int up_to_host(struct mux_rx *r)
 static void do_rx(struct work_struct *work)
 {
 	struct mux_dev *mux_dev =
-		container_of(work, struct mux_dev , work_rx.work);
+		container_of(work, struct mux_dev, work_rx.work);
 	struct mux_rx *r;
 	struct rx_cxt *rx = (struct rx_cxt *)&mux_dev->rx;
 	unsigned long flags;

commit 37d963fb80d2fd944bd0124570b2adc5b826ccef
Author: Gulsah Kose <gulsah.1004@gmail.com>
Date:   Sat Sep 20 20:43:53 2014 +0300

    staging: gdm724x: Fix missing blank line warning.
    
    Fixes "Missing a blank line after declarations" checkpatch.pl warning in
    gdm_mux.c
    
    Signed-off-by: Gulsah Kose <gulsah.1004@gmail.com>
    Reviewed-by: Josh Triplett <josh@joshtriplett.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gdm724x/gdm_mux.c b/drivers/staging/gdm724x/gdm_mux.c
index 10ce2c1805bb..b5b063a738f8 100644
--- a/drivers/staging/gdm724x/gdm_mux.c
+++ b/drivers/staging/gdm724x/gdm_mux.c
@@ -517,6 +517,7 @@ static int gdm_mux_probe(struct usb_interface *intf,
 	int ret;
 	int i;
 	struct usb_device *usbdev = interface_to_usbdev(intf);
+
 	bInterfaceNumber = intf->cur_altsetting->desc.bInterfaceNumber;
 
 	idVendor = __le16_to_cpu(usbdev->descriptor.idVendor);

commit 7b99b5efaab0f8c8c637cb68840e990fbca16878
Author: Daniel Ngu <daniel.dy.ngu@gmail.com>
Date:   Mon Mar 17 08:17:28 2014 +1300

    Staging: gdm724x: gdm_mux.c: fixed coding style
    
    Line over 80 characters
    
    Signed-off-by: Daniel Ngu <daniel.dy.ngu@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gdm724x/gdm_mux.c b/drivers/staging/gdm724x/gdm_mux.c
index 2fa3a5a6580f..10ce2c1805bb 100644
--- a/drivers/staging/gdm724x/gdm_mux.c
+++ b/drivers/staging/gdm724x/gdm_mux.c
@@ -165,7 +165,8 @@ static int up_to_host(struct mux_rx *r)
 	int len = r->len;
 
 	while (1) {
-		mux_header = (struct mux_pkt_header *)(r->buf + packet_size_sum);
+		mux_header = (struct mux_pkt_header *)(r->buf +
+						       packet_size_sum);
 		start_flag = __le32_to_cpu(mux_header->start_flag);
 		payload_size = __le32_to_cpu(mux_header->payload_size);
 		packet_type = __le16_to_cpu(mux_header->packet_type);
@@ -231,7 +232,8 @@ static void do_rx(struct work_struct *work)
 			spin_unlock_irqrestore(&rx->to_host_lock, flags);
 			break;
 		}
-		r = list_entry(rx->to_host_list.next, struct mux_rx, to_host_list);
+		r = list_entry(rx->to_host_list.next, struct mux_rx,
+			       to_host_list);
 		list_del(&r->to_host_list);
 		spin_unlock_irqrestore(&rx->to_host_lock, flags);
 
@@ -249,7 +251,8 @@ static void remove_rx_submit_list(struct mux_rx *r, struct rx_cxt *rx)
 	struct mux_rx	*r_remove, *r_remove_next;
 
 	spin_lock_irqsave(&rx->submit_list_lock, flags);
-	list_for_each_entry_safe(r_remove, r_remove_next, &rx->rx_submit_list, rx_submit_list) {
+	list_for_each_entry_safe(r_remove, r_remove_next, &rx->rx_submit_list,
+				 rx_submit_list) {
 		if (r == r_remove)
 			list_del(&r->rx_submit_list);
 	}
@@ -279,9 +282,8 @@ static void gdm_mux_rcv_complete(struct urb *urb)
 	}
 }
 
-static int gdm_mux_recv(void *priv_dev,
-			int (*cb)(void *data, int len, int tty_index, struct tty_dev *tty_dev, int complete)
-			)
+static int gdm_mux_recv(void *priv_dev, int (*cb)(void *data, int len,
+			int tty_index, struct tty_dev *tty_dev, int complete))
 {
 	struct mux_dev *mux_dev = priv_dev;
 	struct usb_device *usbdev = mux_dev->usbdev;
@@ -416,7 +418,8 @@ static int gdm_mux_send(void *priv_dev, void *data, int len, int tty_index,
 	return ret;
 }
 
-static int gdm_mux_send_control(void *priv_dev, int request, int value, void *buf, int len)
+static int gdm_mux_send_control(void *priv_dev, int request, int value,
+				void *buf, int len)
 {
 	struct mux_dev *mux_dev = priv_dev;
 	struct usb_device *usbdev = mux_dev->usbdev;
@@ -448,7 +451,8 @@ static void release_usb(struct mux_dev *mux_dev)
 	cancel_delayed_work(&mux_dev->work_rx);
 
 	spin_lock_irqsave(&rx->submit_list_lock, flags);
-	list_for_each_entry_safe(r, r_next, &rx->rx_submit_list, rx_submit_list) {
+	list_for_each_entry_safe(r, r_next, &rx->rx_submit_list,
+				 rx_submit_list) {
 		spin_unlock_irqrestore(&rx->submit_list_lock, flags);
 		usb_kill_urb(r->urb);
 		spin_lock_irqsave(&rx->submit_list_lock, flags);
@@ -503,7 +507,8 @@ static int init_usb(struct mux_dev *mux_dev)
 	return ret;
 }
 
-static int gdm_mux_probe(struct usb_interface *intf, const struct usb_device_id *id)
+static int gdm_mux_probe(struct usb_interface *intf,
+			 const struct usb_device_id *id)
 {
 	struct mux_dev *mux_dev;
 	struct tty_dev *tty_dev;
@@ -610,7 +615,8 @@ static int gdm_mux_suspend(struct usb_interface *intf, pm_message_t pm_msg)
 
 
 	spin_lock_irqsave(&rx->submit_list_lock, flags);
-	list_for_each_entry_safe(r, r_next, &rx->rx_submit_list, rx_submit_list) {
+	list_for_each_entry_safe(r, r_next, &rx->rx_submit_list,
+				 rx_submit_list) {
 		spin_unlock_irqrestore(&rx->submit_list_lock, flags);
 		usb_kill_urb(r->urb);
 		spin_lock_irqsave(&rx->submit_list_lock, flags);

commit 29ef8a53542ab4a6e0151978459d03996750d54b
Author: Rashika Kheria <rashika.kheria@gmail.com>
Date:   Fri Nov 8 18:09:44 2013 +0530

    Staging: gdm724x: Use ALIGN() macro for dummy_cnt in gdm_mux.c
    
    As suggested in TODO list, this patch uses ALIGN() macro for variable
    dummy_cnt in functions up_to_host() and gdm_mux_send() in file
    gdm_mux.c.
    The macro has already been defined in include/linux/kernel.h, hence is
    not defined again.
    
    Signed-off-by: Rashika Kheria <rashika.kheria@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gdm724x/gdm_mux.c b/drivers/staging/gdm724x/gdm_mux.c
index 62163673976c..2fa3a5a6580f 100644
--- a/drivers/staging/gdm724x/gdm_mux.c
+++ b/drivers/staging/gdm724x/gdm_mux.c
@@ -158,7 +158,6 @@ static int up_to_host(struct mux_rx *r)
 	unsigned int start_flag;
 	unsigned int payload_size;
 	unsigned short packet_type;
-	int remain;
 	int dummy_cnt;
 	u32 packet_size_sum = r->offset;
 	int index;
@@ -176,8 +175,7 @@ static int up_to_host(struct mux_rx *r)
 			break;
 		}
 
-		remain = (MUX_HEADER_SIZE + payload_size) % 4;
-		dummy_cnt = remain ? (4-remain) : 0;
+		dummy_cnt = ALIGN(MUX_HEADER_SIZE + payload_size, 4);
 
 		if (len - packet_size_sum <
 			MUX_HEADER_SIZE + payload_size + dummy_cnt) {
@@ -361,7 +359,6 @@ static int gdm_mux_send(void *priv_dev, void *data, int len, int tty_index,
 	struct mux_pkt_header *mux_header;
 	struct mux_tx *t = NULL;
 	static u32 seq_num = 1;
-	int remain;
 	int dummy_cnt;
 	int total_len;
 	int ret;
@@ -375,8 +372,7 @@ static int gdm_mux_send(void *priv_dev, void *data, int len, int tty_index,
 
 	spin_lock_irqsave(&mux_dev->write_lock, flags);
 
-	remain = (MUX_HEADER_SIZE + len) % 4;
-	dummy_cnt = remain ? (4 - remain) : 0;
+	dummy_cnt = ALIGN(MUX_HEADER_SIZE + len, 4);
 
 	total_len = len + MUX_HEADER_SIZE + dummy_cnt;
 

commit 47052577bcb941da36a991fea3dadc0d3b14c741
Author: Alexey Khoroshilov <khoroshilov@ispras.ru>
Date:   Wed Oct 9 00:50:16 2013 +0400

    staging: gdm7240: fix memory leak on failure path
    
    init_usb() may fail after some of mux_rxes already allocated.
    So we need to release them on the failure path.
    
    Found by Linux Driver Verification project (linuxtesting.org).
    
    Signed-off-by: Alexey Khoroshilov <khoroshilov@ispras.ru>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gdm724x/gdm_mux.c b/drivers/staging/gdm724x/gdm_mux.c
index 3c89eaa4e5c7..62163673976c 100644
--- a/drivers/staging/gdm724x/gdm_mux.c
+++ b/drivers/staging/gdm724x/gdm_mux.c
@@ -541,7 +541,7 @@ static int gdm_mux_probe(struct usb_interface *intf, const struct usb_device_id
 
 	ret = init_usb(mux_dev);
 	if (ret)
-		goto err_free_tty;
+		goto err_free_usb;
 
 	tty_dev->priv_dev = (void *)mux_dev;
 	tty_dev->send_func = gdm_mux_send;
@@ -565,8 +565,8 @@ static int gdm_mux_probe(struct usb_interface *intf, const struct usb_device_id
 
 err_unregister_tty:
 	unregister_lte_tty_device(tty_dev);
+err_free_usb:
 	release_usb(mux_dev);
-err_free_tty:
 	kfree(tty_dev);
 err_free_mux:
 	kfree(mux_dev);

commit a4d8c83cb55ee58cdbdc4b8a27e3855516efa484
Author: Alexey Khoroshilov <khoroshilov@ispras.ru>
Date:   Wed Oct 9 00:50:15 2013 +0400

    staging: gdm7240: alloc_mux_rx() does not need GFP_ATOMIC
    
    As far as alloc_mux_rx() is called from probe() only
    there is no need in GFP_ATOMIC here.
    
    Found by Linux Driver Verification project (linuxtesting.org).
    
    Signed-off-by: Alexey Khoroshilov <khoroshilov@ispras.ru>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gdm724x/gdm_mux.c b/drivers/staging/gdm724x/gdm_mux.c
index d63517ce2a33..3c89eaa4e5c7 100644
--- a/drivers/staging/gdm724x/gdm_mux.c
+++ b/drivers/staging/gdm724x/gdm_mux.c
@@ -96,12 +96,12 @@ static struct mux_rx *alloc_mux_rx(void)
 {
 	struct mux_rx *r = NULL;
 
-	r = kzalloc(sizeof(struct mux_rx), GFP_ATOMIC);
+	r = kzalloc(sizeof(struct mux_rx), GFP_KERNEL);
 	if (!r)
 		return NULL;
 
-	r->urb = usb_alloc_urb(0, GFP_ATOMIC);
-	r->buf = kmalloc(MUX_RX_MAX_SIZE, GFP_ATOMIC);
+	r->urb = usb_alloc_urb(0, GFP_KERNEL);
+	r->buf = kmalloc(MUX_RX_MAX_SIZE, GFP_KERNEL);
 	if (!r->urb || !r->buf) {
 		usb_free_urb(r->urb);
 		kfree(r->buf);

commit ff52b8fe2b8208432f92c59bea20a4a6128923ff
Author: Valentina Manea <valentina.manea.m@gmail.com>
Date:   Tue Oct 8 13:21:26 2013 +0300

    staging: gdm724x: Fix sparse warnings regarding static functions/variables
    
    This fixes sparse warnings for functions and variables, e.g.:
    * drivers/staging/gdm724x/gdm_mux.c:29:25: warning: symbol
    'mux_rx_wq' was not declared. Should it be static?
    
    Signed-off-by: Valentina Manea <valentina.manea.m@gmail.com>
    Reviewed-by: Zach Brown <zab@redhat.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gdm724x/gdm_mux.c b/drivers/staging/gdm724x/gdm_mux.c
index 5b1ef4000d0f..d63517ce2a33 100644
--- a/drivers/staging/gdm724x/gdm_mux.c
+++ b/drivers/staging/gdm724x/gdm_mux.c
@@ -26,7 +26,7 @@
 
 #include "gdm_mux.h"
 
-struct workqueue_struct *mux_rx_wq;
+static struct workqueue_struct *mux_rx_wq;
 
 static u16 packet_type[TTY_MAX_COUNT] = {0xF011, 0xF010};
 
@@ -51,7 +51,7 @@ static const struct usb_device_id id_table[] = {
 
 MODULE_DEVICE_TABLE(usb, id_table);
 
-int packet_type_to_index(u16 packetType)
+static int packet_type_to_index(u16 packetType)
 {
 	int i;
 

commit 234ad18249a46af8703246a3c417bb4382512d2f
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Wed Aug 21 11:31:18 2013 +0300

    staging: gdm7240: fix error handling of probe()
    
    The error handling is messy and not in kernel style.  On some paths it
    frees "mux_dev" twice.
    
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gdm724x/gdm_mux.c b/drivers/staging/gdm724x/gdm_mux.c
index 9e217ff3b15b..5b1ef4000d0f 100644
--- a/drivers/staging/gdm724x/gdm_mux.c
+++ b/drivers/staging/gdm724x/gdm_mux.c
@@ -509,11 +509,11 @@ static int init_usb(struct mux_dev *mux_dev)
 
 static int gdm_mux_probe(struct usb_interface *intf, const struct usb_device_id *id)
 {
-	struct mux_dev *mux_dev = NULL;
-	struct tty_dev *tty_dev = NULL;
+	struct mux_dev *mux_dev;
+	struct tty_dev *tty_dev;
 	u16 idVendor, idProduct;
 	int bInterfaceNumber;
-	int ret = 0;
+	int ret;
 	int i;
 	struct usb_device *usbdev = interface_to_usbdev(intf);
 	bInterfaceNumber = intf->cur_altsetting->desc.bInterfaceNumber;
@@ -523,61 +523,54 @@ static int gdm_mux_probe(struct usb_interface *intf, const struct usb_device_id
 
 	pr_info("mux vid = 0x%04x pid = 0x%04x\n", idVendor, idProduct);
 
-	if (bInterfaceNumber != 2) {
-		ret = -ENODEV;
-		goto out;
-	}
+	if (bInterfaceNumber != 2)
+		return -ENODEV;
 
 	mux_dev = kzalloc(sizeof(struct mux_dev), GFP_KERNEL);
-	if (!mux_dev) {
-		ret = -ENOMEM;
-		goto out;
-	}
+	if (!mux_dev)
+		return -ENOMEM;
 
 	tty_dev = kzalloc(sizeof(struct tty_dev), GFP_KERNEL);
 	if (!tty_dev) {
-		kfree(mux_dev);
 		ret = -ENOMEM;
-		goto out;
+		goto err_free_mux;
 	}
 
 	mux_dev->usbdev = usbdev;
 	mux_dev->control_intf = intf;
 
 	ret = init_usb(mux_dev);
-	if (ret < 0)
-		goto out;
+	if (ret)
+		goto err_free_tty;
 
 	tty_dev->priv_dev = (void *)mux_dev;
 	tty_dev->send_func = gdm_mux_send;
 	tty_dev->recv_func = gdm_mux_recv;
 	tty_dev->send_control = gdm_mux_send_control;
 
-	if (register_lte_tty_device(tty_dev, &intf->dev) < 0) {
-		unregister_lte_tty_device(tty_dev);
-		mux_dev = tty_dev->priv_dev;
+	ret = register_lte_tty_device(tty_dev, &intf->dev);
+	if (ret)
+		goto err_unregister_tty;
 
-		ret = -1;
-		goto out;
-	}
 	for (i = 0; i < TTY_MAX_COUNT; i++)
 		mux_dev->tty_dev = tty_dev;
 
-out:
-	if (ret < 0) {
-		kfree(tty_dev);
-		if (mux_dev) {
-			release_usb(mux_dev);
-			kfree(mux_dev);
-		}
-	} else {
-		mux_dev->intf = intf;
-		mux_dev->usb_state = PM_NORMAL;
-	}
+	mux_dev->intf = intf;
+	mux_dev->usb_state = PM_NORMAL;
 
 	usb_get_dev(usbdev);
 	usb_set_intfdata(intf, tty_dev);
 
+	return 0;
+
+err_unregister_tty:
+	unregister_lte_tty_device(tty_dev);
+	release_usb(mux_dev);
+err_free_tty:
+	kfree(tty_dev);
+err_free_mux:
+	kfree(mux_dev);
+
 	return ret;
 }
 

commit bf0373f1c61dd0e0356aeed4e51786e052bb4de8
Author: Won Kang <wkang77@gmail.com>
Date:   Fri Aug 16 13:13:44 2013 +0900

    staging: gdm7240: a TTY rewrite according to the latest TTY APIs
    
    Fixed mis-use of mutex for gdm_table. gdm_table is refered to only
    inside tty_install and port destrcut, and usb callbacks use internal
    reference which was saved during urb submission
    
    Signed-off-by: Won Kang <wonkang@gctsemi.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gdm724x/gdm_mux.c b/drivers/staging/gdm724x/gdm_mux.c
index b630babb57af..9e217ff3b15b 100644
--- a/drivers/staging/gdm724x/gdm_mux.c
+++ b/drivers/staging/gdm724x/gdm_mux.c
@@ -25,7 +25,6 @@
 #include <linux/usb/cdc.h>
 
 #include "gdm_mux.h"
-#include "gdm_tty.h"
 
 struct workqueue_struct *mux_rx_wq;
 
@@ -196,7 +195,7 @@ static int up_to_host(struct mux_rx *r)
 		ret = r->callback(mux_header->data,
 				payload_size,
 				index,
-				mux_dev->minor[index],
+				mux_dev->tty_dev,
 				RECV_PACKET_PROCESS_CONTINUE
 				);
 		if (ret == TO_HOST_BUFFER_REQUEST_FAIL) {
@@ -209,7 +208,7 @@ static int up_to_host(struct mux_rx *r)
 			ret = r->callback(NULL,
 					0,
 					index,
-					mux_dev->minor[index],
+					mux_dev->tty_dev,
 					RECV_PACKET_PROCESS_COMPLETE
 					);
 			break;
@@ -283,7 +282,7 @@ static void gdm_mux_rcv_complete(struct urb *urb)
 }
 
 static int gdm_mux_recv(void *priv_dev,
-			int (*cb)(void *data, int len, int tty_index, int minor, int complete)
+			int (*cb)(void *data, int len, int tty_index, struct tty_dev *tty_dev, int complete)
 			)
 {
 	struct mux_dev *mux_dev = priv_dev;
@@ -562,7 +561,7 @@ static int gdm_mux_probe(struct usb_interface *intf, const struct usb_device_id
 		goto out;
 	}
 	for (i = 0; i < TTY_MAX_COUNT; i++)
-		mux_dev->minor[i] = tty_dev->minor[i];
+		mux_dev->tty_dev = tty_dev;
 
 out:
 	if (ret < 0) {

commit b07dee7c9aa78e9b55e0b4ecdba622db55a99ffe
Author: Wei Yongjun <yongjun_wei@trendmicro.com.cn>
Date:   Fri Jul 26 10:15:55 2013 +0800

    staging: gdm724x: use GFP_ATOMIC under spin lock
    
    A spin lock is taken here so we should use GFP_ATOMIC.
    
    Signed-off-by: Wei Yongjun <yongjun_wei@trendmicro.com.cn>
    Acked-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gdm724x/gdm_mux.c b/drivers/staging/gdm724x/gdm_mux.c
index 2e619d2e7ba1..b630babb57af 100644
--- a/drivers/staging/gdm724x/gdm_mux.c
+++ b/drivers/staging/gdm724x/gdm_mux.c
@@ -409,7 +409,7 @@ static int gdm_mux_send(void *priv_dev, void *data, int len, int tty_index,
 			  gdm_mux_send_complete,
 			  t);
 
-	ret = usb_submit_urb(t->urb, GFP_KERNEL);
+	ret = usb_submit_urb(t->urb, GFP_ATOMIC);
 
 	spin_unlock_irqrestore(&mux_dev->write_lock, flags);
 

commit 3d2bf0fa5f1ecce06bbc6e7f749e4f32e90854a6
Author: Sachin Kamat <sachin.kamat@linaro.org>
Date:   Thu Jul 25 11:36:51 2013 +0530

    staging: gdm724x: Remove version.h header inclusion in gdm_mux.c
    
    version.h header inclusion is not necessary as detected by
    versioncheck.
    
    Signed-off-by: Sachin Kamat <sachin.kamat@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gdm724x/gdm_mux.c b/drivers/staging/gdm724x/gdm_mux.c
index f570bc00c990..2e619d2e7ba1 100644
--- a/drivers/staging/gdm724x/gdm_mux.c
+++ b/drivers/staging/gdm724x/gdm_mux.c
@@ -14,7 +14,6 @@
 #define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
 
 #include <linux/module.h>
-#include <linux/version.h>
 #include <linux/kernel.h>
 #include <linux/usb.h>
 #include <linux/errno.h>

commit 0ec473b5267d01762b610d57e168b0401a137f3a
Author: Joe Perches <joe@perches.com>
Date:   Wed Jul 24 14:13:03 2013 -0700

    staging: gdm724x: Update logging
    
    Make the logging prefixes match the module names
    by adding #define pr_fmt(fmt) KBUILD_MODNAME and
    converting printks to netdev_<level> when a
    struct netdevice * is available and and pr_<level>
    when not.
    
    Remove embedded prefixes.
    Add missing terminating newlines.
    Remove an unnecessary rx-dropped message.
    Remove an unnecessary temporary variable.
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gdm724x/gdm_mux.c b/drivers/staging/gdm724x/gdm_mux.c
index 2199f1bcbc84..f570bc00c990 100644
--- a/drivers/staging/gdm724x/gdm_mux.c
+++ b/drivers/staging/gdm724x/gdm_mux.c
@@ -11,6 +11,8 @@
  * GNU General Public License for more details.
  */
 
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+
 #include <linux/module.h>
 #include <linux/version.h>
 #include <linux/kernel.h>
@@ -172,8 +174,7 @@ static int up_to_host(struct mux_rx *r)
 		packet_type = __le16_to_cpu(mux_header->packet_type);
 
 		if (start_flag != START_FLAG) {
-			printk(KERN_ERR "glte: invalid START_FLAG %x\n",
-				start_flag);
+			pr_err("invalid START_FLAG %x\n", start_flag);
 			break;
 		}
 
@@ -182,16 +183,14 @@ static int up_to_host(struct mux_rx *r)
 
 		if (len - packet_size_sum <
 			MUX_HEADER_SIZE + payload_size + dummy_cnt) {
-			printk(KERN_ERR "glte: invalid payload : %d %d %04x\n",
-			       payload_size, len,
-			       packet_type
-			       );
+			pr_err("invalid payload : %d %d %04x\n",
+			       payload_size, len, packet_type);
 			break;
 		}
 
 		index = packet_type_to_index(packet_type);
 		if (index < 0) {
-			printk(KERN_ERR "glte: invalid index %d\n", index);
+			pr_err("invalid index %d\n", index);
 			break;
 		}
 
@@ -242,7 +241,7 @@ static void do_rx(struct work_struct *work)
 
 		ret = up_to_host(r);
 		if (ret == TO_HOST_BUFFER_REQUEST_FAIL)
-			printk(KERN_ERR "glte: failed to send mux data to host\n");
+			pr_err("failed to send mux data to host\n");
 		else
 			put_rx_struct(rx, r);
 	}
@@ -272,7 +271,8 @@ static void gdm_mux_rcv_complete(struct urb *urb)
 
 	if (urb->status) {
 		if (mux_dev->usb_state == PM_NORMAL)
-			printk(KERN_ERR "glte: gdm_mux_rcv_complete urb status error %d\n", urb->status);
+			pr_err("%s: urb status error %d\n",
+			       __func__, urb->status);
 		put_rx_struct(rx, r);
 	} else {
 		r->len = r->urb->actual_length;
@@ -295,13 +295,13 @@ static int gdm_mux_recv(void *priv_dev,
 	int ret;
 
 	if (!usbdev) {
-		printk(KERN_ERR "glte: device is disconnected\n");
+		pr_err("device is disconnected\n");
 		return -ENODEV;
 	}
 
 	r = get_rx_struct(rx);
 	if (!r) {
-		printk(KERN_ERR "glte: get_rx_struct fail\n");
+		pr_err("get_rx_struct fail\n");
 		return -ENOMEM;
 	}
 
@@ -331,7 +331,7 @@ static int gdm_mux_recv(void *priv_dev,
 
 		put_rx_struct(rx, r);
 
-		printk(KERN_ERR "glte: usb_submit_urb ret=%d\n", ret);
+		pr_err("usb_submit_urb ret=%d\n", ret);
 	}
 
 	usb_mark_last_busy(usbdev);
@@ -344,7 +344,7 @@ static void gdm_mux_send_complete(struct urb *urb)
 	struct mux_tx *t = urb->context;
 
 	if (urb->status == -ECONNRESET) {
-		printk(KERN_INFO "glte: CONNRESET\n");
+		pr_info("CONNRESET\n");
 		free_mux_tx(t);
 		return;
 	}
@@ -384,7 +384,7 @@ static int gdm_mux_send(void *priv_dev, void *data, int len, int tty_index,
 
 	t = alloc_mux_tx(total_len);
 	if (!t) {
-		printk(KERN_ERR "glte: alloc_mux_tx fail\n");
+		pr_err("alloc_mux_tx fail\n");
 		spin_unlock_irqrestore(&mux_dev->write_lock, flags);
 		return -ENOMEM;
 	}
@@ -415,7 +415,7 @@ static int gdm_mux_send(void *priv_dev, void *data, int len, int tty_index,
 	spin_unlock_irqrestore(&mux_dev->write_lock, flags);
 
 	if (ret)
-		printk(KERN_ERR "glte: usb_submit_urb Error : %d\n", ret);
+		pr_err("usb_submit_urb Error: %d\n", ret);
 
 	usb_mark_last_busy(usbdev);
 
@@ -440,7 +440,7 @@ static int gdm_mux_send_control(void *priv_dev, int request, int value, void *bu
 			     );
 
 	if (ret < 0)
-		printk(KERN_ERR "glte: usb_control_msg error : %d\n", ret);
+		pr_err("usb_control_msg error: %d\n", ret);
 
 	return ret < 0 ? ret : 0;
 }
@@ -523,8 +523,7 @@ static int gdm_mux_probe(struct usb_interface *intf, const struct usb_device_id
 	idVendor = __le16_to_cpu(usbdev->descriptor.idVendor);
 	idProduct = __le16_to_cpu(usbdev->descriptor.idProduct);
 
-	printk(KERN_INFO "glte: mux vid = 0x%04x pid = 0x%04x\n",
-	       idVendor, idProduct);
+	pr_info("mux vid = 0x%04x pid = 0x%04x\n", idVendor, idProduct);
 
 	if (bInterfaceNumber != 2) {
 		ret = -ENODEV;
@@ -616,7 +615,7 @@ static int gdm_mux_suspend(struct usb_interface *intf, pm_message_t pm_msg)
 	rx = &mux_dev->rx;
 
 	if (mux_dev->usb_state != PM_NORMAL) {
-		printk(KERN_ERR "glte: usb suspend - invalid state\n");
+		pr_err("usb suspend - invalid state\n");
 		return -1;
 	}
 
@@ -644,7 +643,7 @@ static int gdm_mux_resume(struct usb_interface *intf)
 	mux_dev = tty_dev->priv_dev;
 
 	if (mux_dev->usb_state != PM_SUSPEND) {
-		printk(KERN_ERR "glte: usb resume - invalid state\n");
+		pr_err("usb resume - invalid state\n");
 		return -1;
 	}
 
@@ -672,7 +671,7 @@ static int __init gdm_usb_mux_init(void)
 
 	mux_rx_wq = create_workqueue("mux_rx_wq");
 	if (mux_rx_wq == NULL) {
-		printk(KERN_ERR "glte: work queue create fail");
+		pr_err("work queue create fail\n");
 		return -1;
 	}
 

commit 61e121047645122c47714fcda684d0ee67f444af
Author: Won Kang <wkang77@gmail.com>
Date:   Thu Jul 25 03:36:17 2013 +0900

    staging: gdm7240: adding LTE USB driver
    
    GCT Semiconductor GDM7240 is 4G LTE chip.
    This driver supports GCT reference platform as a USB device.
    
    Signed-off-by: Won Kang <wonkang@gctsemi.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/gdm724x/gdm_mux.c b/drivers/staging/gdm724x/gdm_mux.c
new file mode 100644
index 000000000000..2199f1bcbc84
--- /dev/null
+++ b/drivers/staging/gdm724x/gdm_mux.c
@@ -0,0 +1,700 @@
+/*
+ * Copyright (c) 2012 GCT Semiconductor, Inc. All rights reserved.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/module.h>
+#include <linux/version.h>
+#include <linux/kernel.h>
+#include <linux/usb.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/tty.h>
+#include <linux/tty_driver.h>
+#include <linux/tty_flip.h>
+#include <linux/slab.h>
+#include <linux/usb/cdc.h>
+
+#include "gdm_mux.h"
+#include "gdm_tty.h"
+
+struct workqueue_struct *mux_rx_wq;
+
+static u16 packet_type[TTY_MAX_COUNT] = {0xF011, 0xF010};
+
+#define USB_DEVICE_CDC_DATA(vid, pid) \
+	.match_flags = \
+		USB_DEVICE_ID_MATCH_DEVICE |\
+		USB_DEVICE_ID_MATCH_INT_CLASS |\
+		USB_DEVICE_ID_MATCH_INT_SUBCLASS,\
+	.idVendor = vid,\
+	.idProduct = pid,\
+	.bInterfaceClass = USB_CLASS_COMM,\
+	.bInterfaceSubClass = USB_CDC_SUBCLASS_ACM
+
+static const struct usb_device_id id_table[] = {
+	{ USB_DEVICE_CDC_DATA(0x1076, 0x8000) }, /* GCT GDM7240 */
+	{ USB_DEVICE_CDC_DATA(0x1076, 0x8f00) }, /* GCT GDM7243 */
+	{ USB_DEVICE_CDC_DATA(0x1076, 0x9000) }, /* GCT GDM7243 */
+	{ USB_DEVICE_CDC_DATA(0x1d74, 0x2300) }, /* LGIT Phoenix */
+	{}
+};
+
+
+MODULE_DEVICE_TABLE(usb, id_table);
+
+int packet_type_to_index(u16 packetType)
+{
+	int i;
+
+	for (i = 0; i < TTY_MAX_COUNT; i++) {
+		if (packet_type[i] == packetType)
+			return i;
+	}
+
+	return -1;
+}
+
+static struct mux_tx *alloc_mux_tx(int len)
+{
+	struct mux_tx *t = NULL;
+
+	t = kzalloc(sizeof(struct mux_tx), GFP_ATOMIC);
+	if (!t)
+		return NULL;
+
+	t->urb = usb_alloc_urb(0, GFP_ATOMIC);
+	t->buf = kmalloc(MUX_TX_MAX_SIZE, GFP_ATOMIC);
+	if (!t->urb || !t->buf) {
+		usb_free_urb(t->urb);
+		kfree(t->buf);
+		kfree(t);
+		return NULL;
+	}
+
+	return t;
+}
+
+static void free_mux_tx(struct mux_tx *t)
+{
+	if (t) {
+		usb_free_urb(t->urb);
+		kfree(t->buf);
+		kfree(t);
+	}
+}
+
+static struct mux_rx *alloc_mux_rx(void)
+{
+	struct mux_rx *r = NULL;
+
+	r = kzalloc(sizeof(struct mux_rx), GFP_ATOMIC);
+	if (!r)
+		return NULL;
+
+	r->urb = usb_alloc_urb(0, GFP_ATOMIC);
+	r->buf = kmalloc(MUX_RX_MAX_SIZE, GFP_ATOMIC);
+	if (!r->urb || !r->buf) {
+		usb_free_urb(r->urb);
+		kfree(r->buf);
+		kfree(r);
+		return NULL;
+	}
+
+	return r;
+}
+
+static void free_mux_rx(struct mux_rx *r)
+{
+	if (r) {
+		usb_free_urb(r->urb);
+		kfree(r->buf);
+		kfree(r);
+	}
+}
+
+static struct mux_rx *get_rx_struct(struct rx_cxt *rx)
+{
+	struct mux_rx *r;
+	unsigned long flags;
+
+	spin_lock_irqsave(&rx->free_list_lock, flags);
+
+	if (list_empty(&rx->rx_free_list)) {
+		spin_unlock_irqrestore(&rx->free_list_lock, flags);
+		return NULL;
+	}
+
+	r = list_entry(rx->rx_free_list.prev, struct mux_rx, free_list);
+	list_del(&r->free_list);
+
+	spin_unlock_irqrestore(&rx->free_list_lock, flags);
+
+	return r;
+}
+
+static void put_rx_struct(struct rx_cxt *rx, struct mux_rx *r)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&rx->free_list_lock, flags);
+	list_add_tail(&r->free_list, &rx->rx_free_list);
+	spin_unlock_irqrestore(&rx->free_list_lock, flags);
+}
+
+
+static int up_to_host(struct mux_rx *r)
+{
+	struct mux_dev *mux_dev = (struct mux_dev *)r->mux_dev;
+	struct mux_pkt_header *mux_header;
+	unsigned int start_flag;
+	unsigned int payload_size;
+	unsigned short packet_type;
+	int remain;
+	int dummy_cnt;
+	u32 packet_size_sum = r->offset;
+	int index;
+	int ret = TO_HOST_INVALID_PACKET;
+	int len = r->len;
+
+	while (1) {
+		mux_header = (struct mux_pkt_header *)(r->buf + packet_size_sum);
+		start_flag = __le32_to_cpu(mux_header->start_flag);
+		payload_size = __le32_to_cpu(mux_header->payload_size);
+		packet_type = __le16_to_cpu(mux_header->packet_type);
+
+		if (start_flag != START_FLAG) {
+			printk(KERN_ERR "glte: invalid START_FLAG %x\n",
+				start_flag);
+			break;
+		}
+
+		remain = (MUX_HEADER_SIZE + payload_size) % 4;
+		dummy_cnt = remain ? (4-remain) : 0;
+
+		if (len - packet_size_sum <
+			MUX_HEADER_SIZE + payload_size + dummy_cnt) {
+			printk(KERN_ERR "glte: invalid payload : %d %d %04x\n",
+			       payload_size, len,
+			       packet_type
+			       );
+			break;
+		}
+
+		index = packet_type_to_index(packet_type);
+		if (index < 0) {
+			printk(KERN_ERR "glte: invalid index %d\n", index);
+			break;
+		}
+
+		ret = r->callback(mux_header->data,
+				payload_size,
+				index,
+				mux_dev->minor[index],
+				RECV_PACKET_PROCESS_CONTINUE
+				);
+		if (ret == TO_HOST_BUFFER_REQUEST_FAIL) {
+			r->offset += packet_size_sum;
+			break;
+		}
+
+		packet_size_sum += MUX_HEADER_SIZE + payload_size + dummy_cnt;
+		if (len - packet_size_sum <= MUX_HEADER_SIZE + 2) {
+			ret = r->callback(NULL,
+					0,
+					index,
+					mux_dev->minor[index],
+					RECV_PACKET_PROCESS_COMPLETE
+					);
+			break;
+		}
+	}
+
+	return ret;
+}
+
+static void do_rx(struct work_struct *work)
+{
+	struct mux_dev *mux_dev =
+		container_of(work, struct mux_dev , work_rx.work);
+	struct mux_rx *r;
+	struct rx_cxt *rx = (struct rx_cxt *)&mux_dev->rx;
+	unsigned long flags;
+	int ret = 0;
+
+	while (1) {
+		spin_lock_irqsave(&rx->to_host_lock, flags);
+		if (list_empty(&rx->to_host_list)) {
+			spin_unlock_irqrestore(&rx->to_host_lock, flags);
+			break;
+		}
+		r = list_entry(rx->to_host_list.next, struct mux_rx, to_host_list);
+		list_del(&r->to_host_list);
+		spin_unlock_irqrestore(&rx->to_host_lock, flags);
+
+		ret = up_to_host(r);
+		if (ret == TO_HOST_BUFFER_REQUEST_FAIL)
+			printk(KERN_ERR "glte: failed to send mux data to host\n");
+		else
+			put_rx_struct(rx, r);
+	}
+}
+
+static void remove_rx_submit_list(struct mux_rx *r, struct rx_cxt *rx)
+{
+	unsigned long flags;
+	struct mux_rx	*r_remove, *r_remove_next;
+
+	spin_lock_irqsave(&rx->submit_list_lock, flags);
+	list_for_each_entry_safe(r_remove, r_remove_next, &rx->rx_submit_list, rx_submit_list) {
+		if (r == r_remove)
+			list_del(&r->rx_submit_list);
+	}
+	spin_unlock_irqrestore(&rx->submit_list_lock, flags);
+}
+
+static void gdm_mux_rcv_complete(struct urb *urb)
+{
+	struct mux_rx *r = urb->context;
+	struct mux_dev *mux_dev = (struct mux_dev *)r->mux_dev;
+	struct rx_cxt *rx = &mux_dev->rx;
+	unsigned long flags;
+
+	remove_rx_submit_list(r, rx);
+
+	if (urb->status) {
+		if (mux_dev->usb_state == PM_NORMAL)
+			printk(KERN_ERR "glte: gdm_mux_rcv_complete urb status error %d\n", urb->status);
+		put_rx_struct(rx, r);
+	} else {
+		r->len = r->urb->actual_length;
+		spin_lock_irqsave(&rx->to_host_lock, flags);
+		list_add_tail(&r->to_host_list, &rx->to_host_list);
+		queue_work(mux_rx_wq, &mux_dev->work_rx.work);
+		spin_unlock_irqrestore(&rx->to_host_lock, flags);
+	}
+}
+
+static int gdm_mux_recv(void *priv_dev,
+			int (*cb)(void *data, int len, int tty_index, int minor, int complete)
+			)
+{
+	struct mux_dev *mux_dev = priv_dev;
+	struct usb_device *usbdev = mux_dev->usbdev;
+	struct mux_rx *r;
+	struct rx_cxt *rx = &mux_dev->rx;
+	unsigned long flags;
+	int ret;
+
+	if (!usbdev) {
+		printk(KERN_ERR "glte: device is disconnected\n");
+		return -ENODEV;
+	}
+
+	r = get_rx_struct(rx);
+	if (!r) {
+		printk(KERN_ERR "glte: get_rx_struct fail\n");
+		return -ENOMEM;
+	}
+
+	r->offset = 0;
+	r->mux_dev = (void *)mux_dev;
+	r->callback = cb;
+	mux_dev->rx_cb = cb;
+
+	usb_fill_bulk_urb(r->urb,
+			  usbdev,
+			  usb_rcvbulkpipe(usbdev, 0x86),
+			  r->buf,
+			  MUX_RX_MAX_SIZE,
+			  gdm_mux_rcv_complete,
+			  r);
+
+	spin_lock_irqsave(&rx->submit_list_lock, flags);
+	list_add_tail(&r->rx_submit_list, &rx->rx_submit_list);
+	spin_unlock_irqrestore(&rx->submit_list_lock, flags);
+
+	ret = usb_submit_urb(r->urb, GFP_KERNEL);
+
+	if (ret) {
+		spin_lock_irqsave(&rx->submit_list_lock, flags);
+		list_del(&r->rx_submit_list);
+		spin_unlock_irqrestore(&rx->submit_list_lock, flags);
+
+		put_rx_struct(rx, r);
+
+		printk(KERN_ERR "glte: usb_submit_urb ret=%d\n", ret);
+	}
+
+	usb_mark_last_busy(usbdev);
+
+	return ret;
+}
+
+static void gdm_mux_send_complete(struct urb *urb)
+{
+	struct mux_tx *t = urb->context;
+
+	if (urb->status == -ECONNRESET) {
+		printk(KERN_INFO "glte: CONNRESET\n");
+		free_mux_tx(t);
+		return;
+	}
+
+	if (t->callback)
+		t->callback(t->cb_data);
+
+	free_mux_tx(t);
+}
+
+static int gdm_mux_send(void *priv_dev, void *data, int len, int tty_index,
+			void (*cb)(void *data), void *cb_data)
+{
+	struct mux_dev *mux_dev = priv_dev;
+	struct usb_device *usbdev = mux_dev->usbdev;
+	struct mux_pkt_header *mux_header;
+	struct mux_tx *t = NULL;
+	static u32 seq_num = 1;
+	int remain;
+	int dummy_cnt;
+	int total_len;
+	int ret;
+	unsigned long flags;
+
+	if (mux_dev->usb_state == PM_SUSPEND) {
+		ret = usb_autopm_get_interface(mux_dev->intf);
+		if (!ret)
+			usb_autopm_put_interface(mux_dev->intf);
+	}
+
+	spin_lock_irqsave(&mux_dev->write_lock, flags);
+
+	remain = (MUX_HEADER_SIZE + len) % 4;
+	dummy_cnt = remain ? (4 - remain) : 0;
+
+	total_len = len + MUX_HEADER_SIZE + dummy_cnt;
+
+	t = alloc_mux_tx(total_len);
+	if (!t) {
+		printk(KERN_ERR "glte: alloc_mux_tx fail\n");
+		spin_unlock_irqrestore(&mux_dev->write_lock, flags);
+		return -ENOMEM;
+	}
+
+	mux_header = (struct mux_pkt_header *)t->buf;
+	mux_header->start_flag = __cpu_to_le32(START_FLAG);
+	mux_header->seq_num = __cpu_to_le32(seq_num++);
+	mux_header->payload_size = __cpu_to_le32((u32)len);
+	mux_header->packet_type = __cpu_to_le16(packet_type[tty_index]);
+
+	memcpy(t->buf+MUX_HEADER_SIZE, data, len);
+	memset(t->buf+MUX_HEADER_SIZE+len, 0, dummy_cnt);
+
+	t->len = total_len;
+	t->callback = cb;
+	t->cb_data = cb_data;
+
+	usb_fill_bulk_urb(t->urb,
+			  usbdev,
+			  usb_sndbulkpipe(usbdev, 5),
+			  t->buf,
+			  total_len,
+			  gdm_mux_send_complete,
+			  t);
+
+	ret = usb_submit_urb(t->urb, GFP_KERNEL);
+
+	spin_unlock_irqrestore(&mux_dev->write_lock, flags);
+
+	if (ret)
+		printk(KERN_ERR "glte: usb_submit_urb Error : %d\n", ret);
+
+	usb_mark_last_busy(usbdev);
+
+	return ret;
+}
+
+static int gdm_mux_send_control(void *priv_dev, int request, int value, void *buf, int len)
+{
+	struct mux_dev *mux_dev = priv_dev;
+	struct usb_device *usbdev = mux_dev->usbdev;
+	int ret;
+
+	ret = usb_control_msg(usbdev,
+			      usb_sndctrlpipe(usbdev, 0),
+			      request,
+			      USB_RT_ACM,
+			      value,
+			      2,
+			      buf,
+			      len,
+			      5000
+			     );
+
+	if (ret < 0)
+		printk(KERN_ERR "glte: usb_control_msg error : %d\n", ret);
+
+	return ret < 0 ? ret : 0;
+}
+
+static void release_usb(struct mux_dev *mux_dev)
+{
+	struct rx_cxt		*rx = &mux_dev->rx;
+	struct mux_rx		*r, *r_next;
+	unsigned long		flags;
+
+	cancel_delayed_work(&mux_dev->work_rx);
+
+	spin_lock_irqsave(&rx->submit_list_lock, flags);
+	list_for_each_entry_safe(r, r_next, &rx->rx_submit_list, rx_submit_list) {
+		spin_unlock_irqrestore(&rx->submit_list_lock, flags);
+		usb_kill_urb(r->urb);
+		spin_lock_irqsave(&rx->submit_list_lock, flags);
+	}
+	spin_unlock_irqrestore(&rx->submit_list_lock, flags);
+
+	spin_lock_irqsave(&rx->free_list_lock, flags);
+	list_for_each_entry_safe(r, r_next, &rx->rx_free_list, free_list) {
+		list_del(&r->free_list);
+		free_mux_rx(r);
+	}
+	spin_unlock_irqrestore(&rx->free_list_lock, flags);
+
+	spin_lock_irqsave(&rx->to_host_lock, flags);
+	list_for_each_entry_safe(r, r_next, &rx->to_host_list, to_host_list) {
+		if (r->mux_dev == (void *)mux_dev) {
+			list_del(&r->to_host_list);
+			free_mux_rx(r);
+		}
+	}
+	spin_unlock_irqrestore(&rx->to_host_lock, flags);
+}
+
+
+static int init_usb(struct mux_dev *mux_dev)
+{
+	struct mux_rx *r;
+	struct rx_cxt *rx = &mux_dev->rx;
+	int ret = 0;
+	int i;
+
+	spin_lock_init(&mux_dev->write_lock);
+	INIT_LIST_HEAD(&rx->to_host_list);
+	INIT_LIST_HEAD(&rx->rx_submit_list);
+	INIT_LIST_HEAD(&rx->rx_free_list);
+	spin_lock_init(&rx->to_host_lock);
+	spin_lock_init(&rx->submit_list_lock);
+	spin_lock_init(&rx->free_list_lock);
+
+	for (i = 0; i < MAX_ISSUE_NUM * 2; i++) {
+		r = alloc_mux_rx();
+		if (r == NULL) {
+			ret = -ENOMEM;
+			break;
+		}
+
+		list_add(&r->free_list, &rx->rx_free_list);
+	}
+
+	INIT_DELAYED_WORK(&mux_dev->work_rx, do_rx);
+
+	return ret;
+}
+
+static int gdm_mux_probe(struct usb_interface *intf, const struct usb_device_id *id)
+{
+	struct mux_dev *mux_dev = NULL;
+	struct tty_dev *tty_dev = NULL;
+	u16 idVendor, idProduct;
+	int bInterfaceNumber;
+	int ret = 0;
+	int i;
+	struct usb_device *usbdev = interface_to_usbdev(intf);
+	bInterfaceNumber = intf->cur_altsetting->desc.bInterfaceNumber;
+
+	idVendor = __le16_to_cpu(usbdev->descriptor.idVendor);
+	idProduct = __le16_to_cpu(usbdev->descriptor.idProduct);
+
+	printk(KERN_INFO "glte: mux vid = 0x%04x pid = 0x%04x\n",
+	       idVendor, idProduct);
+
+	if (bInterfaceNumber != 2) {
+		ret = -ENODEV;
+		goto out;
+	}
+
+	mux_dev = kzalloc(sizeof(struct mux_dev), GFP_KERNEL);
+	if (!mux_dev) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	tty_dev = kzalloc(sizeof(struct tty_dev), GFP_KERNEL);
+	if (!tty_dev) {
+		kfree(mux_dev);
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	mux_dev->usbdev = usbdev;
+	mux_dev->control_intf = intf;
+
+	ret = init_usb(mux_dev);
+	if (ret < 0)
+		goto out;
+
+	tty_dev->priv_dev = (void *)mux_dev;
+	tty_dev->send_func = gdm_mux_send;
+	tty_dev->recv_func = gdm_mux_recv;
+	tty_dev->send_control = gdm_mux_send_control;
+
+	if (register_lte_tty_device(tty_dev, &intf->dev) < 0) {
+		unregister_lte_tty_device(tty_dev);
+		mux_dev = tty_dev->priv_dev;
+
+		ret = -1;
+		goto out;
+	}
+	for (i = 0; i < TTY_MAX_COUNT; i++)
+		mux_dev->minor[i] = tty_dev->minor[i];
+
+out:
+	if (ret < 0) {
+		kfree(tty_dev);
+		if (mux_dev) {
+			release_usb(mux_dev);
+			kfree(mux_dev);
+		}
+	} else {
+		mux_dev->intf = intf;
+		mux_dev->usb_state = PM_NORMAL;
+	}
+
+	usb_get_dev(usbdev);
+	usb_set_intfdata(intf, tty_dev);
+
+	return ret;
+}
+
+static void gdm_mux_disconnect(struct usb_interface *intf)
+{
+	struct tty_dev *tty_dev;
+	struct mux_dev *mux_dev;
+	struct usb_device *usbdev = interface_to_usbdev(intf);
+
+	tty_dev = usb_get_intfdata(intf);
+
+	mux_dev = tty_dev->priv_dev;
+
+	release_usb(mux_dev);
+	unregister_lte_tty_device(tty_dev);
+
+	kfree(mux_dev);
+	kfree(tty_dev);
+
+	usb_put_dev(usbdev);
+}
+
+static int gdm_mux_suspend(struct usb_interface *intf, pm_message_t pm_msg)
+{
+	struct tty_dev *tty_dev;
+	struct mux_dev *mux_dev;
+	struct rx_cxt *rx;
+	struct mux_rx *r, *r_next;
+	unsigned long flags;
+
+	tty_dev = usb_get_intfdata(intf);
+	mux_dev = tty_dev->priv_dev;
+	rx = &mux_dev->rx;
+
+	if (mux_dev->usb_state != PM_NORMAL) {
+		printk(KERN_ERR "glte: usb suspend - invalid state\n");
+		return -1;
+	}
+
+	mux_dev->usb_state = PM_SUSPEND;
+
+
+	spin_lock_irqsave(&rx->submit_list_lock, flags);
+	list_for_each_entry_safe(r, r_next, &rx->rx_submit_list, rx_submit_list) {
+		spin_unlock_irqrestore(&rx->submit_list_lock, flags);
+		usb_kill_urb(r->urb);
+		spin_lock_irqsave(&rx->submit_list_lock, flags);
+	}
+	spin_unlock_irqrestore(&rx->submit_list_lock, flags);
+
+	return 0;
+}
+
+static int gdm_mux_resume(struct usb_interface *intf)
+{
+	struct tty_dev *tty_dev;
+	struct mux_dev *mux_dev;
+	u8 i;
+
+	tty_dev = usb_get_intfdata(intf);
+	mux_dev = tty_dev->priv_dev;
+
+	if (mux_dev->usb_state != PM_SUSPEND) {
+		printk(KERN_ERR "glte: usb resume - invalid state\n");
+		return -1;
+	}
+
+	mux_dev->usb_state = PM_NORMAL;
+
+	for (i = 0; i < MAX_ISSUE_NUM; i++)
+		gdm_mux_recv(mux_dev, mux_dev->rx_cb);
+
+	return 0;
+}
+
+static struct usb_driver gdm_mux_driver = {
+	.name = "gdm_mux",
+	.probe = gdm_mux_probe,
+	.disconnect = gdm_mux_disconnect,
+	.id_table = id_table,
+	.supports_autosuspend = 1,
+	.suspend = gdm_mux_suspend,
+	.resume = gdm_mux_resume,
+	.reset_resume = gdm_mux_resume,
+};
+
+static int __init gdm_usb_mux_init(void)
+{
+
+	mux_rx_wq = create_workqueue("mux_rx_wq");
+	if (mux_rx_wq == NULL) {
+		printk(KERN_ERR "glte: work queue create fail");
+		return -1;
+	}
+
+	register_lte_tty_driver();
+
+	return usb_register(&gdm_mux_driver);
+}
+
+static void __exit gdm_usb_mux_exit(void)
+{
+	unregister_lte_tty_driver();
+
+	if (mux_rx_wq) {
+		flush_workqueue(mux_rx_wq);
+		destroy_workqueue(mux_rx_wq);
+	}
+
+	usb_deregister(&gdm_mux_driver);
+}
+
+module_init(gdm_usb_mux_init);
+module_exit(gdm_usb_mux_exit);
+
+MODULE_DESCRIPTION("GCT LTE TTY Device Driver");
+MODULE_LICENSE("GPL");
