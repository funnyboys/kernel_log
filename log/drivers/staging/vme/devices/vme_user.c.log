commit 1832f2d8ff69138aa70d3cb3b4ea3c2058e73aea
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Tue Sep 11 21:59:08 2018 +0200

    compat_ioctl: move more drivers to compat_ptr_ioctl
    
    The .ioctl and .compat_ioctl file operations have the same prototype so
    they can both point to the same function, which works great almost all
    the time when all the commands are compatible.
    
    One exception is the s390 architecture, where a compat pointer is only
    31 bit wide, and converting it into a 64-bit pointer requires calling
    compat_ptr(). Most drivers here will never run in s390, but since we now
    have a generic helper for it, it's easy enough to use it consistently.
    
    I double-checked all these drivers to ensure that all ioctl arguments
    are used as pointers or are ignored, but are not interpreted as integer
    values.
    
    Acked-by: Jason Gunthorpe <jgg@mellanox.com>
    Acked-by: Daniel Vetter <daniel.vetter@ffwll.ch>
    Acked-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Acked-by: David Sterba <dsterba@suse.com>
    Acked-by: Darren Hart (VMware) <dvhart@infradead.org>
    Acked-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>
    Acked-by: Bjorn Andersson <bjorn.andersson@linaro.org>
    Acked-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/drivers/staging/vme/devices/vme_user.c b/drivers/staging/vme/devices/vme_user.c
index 6a33aaa1a49f..fd0ea4dbcb91 100644
--- a/drivers/staging/vme/devices/vme_user.c
+++ b/drivers/staging/vme/devices/vme_user.c
@@ -494,7 +494,7 @@ static const struct file_operations vme_user_fops = {
 	.write = vme_user_write,
 	.llseek = vme_user_llseek,
 	.unlocked_ioctl = vme_user_unlocked_ioctl,
-	.compat_ioctl = vme_user_unlocked_ioctl,
+	.compat_ioctl = compat_ptr_ioctl,
 	.mmap = vme_user_mmap,
 };
 

commit 71e9513b2571ea139bb3619e3a4e3a3e98ea9767
Author: Christophe JAILLET <christophe.jaillet@wanadoo.fr>
Date:   Tue Mar 13 22:01:13 2018 +0100

    staging: vme: vme_user: Fix some error handling paths in 'vme_user_probe()'
    
    2 gotos in error handling paths branch to the wrong label.
    Fix it.
    
    Signed-off-by: Christophe JAILLET <christophe.jaillet@wanadoo.fr>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vme/devices/vme_user.c b/drivers/staging/vme/devices/vme_user.c
index 3242dee8246f..6a33aaa1a49f 100644
--- a/drivers/staging/vme/devices/vme_user.c
+++ b/drivers/staging/vme/devices/vme_user.c
@@ -558,7 +558,7 @@ static int vme_user_probe(struct vme_dev *vdev)
 	vme_user_cdev->owner = THIS_MODULE;
 	err = cdev_add(vme_user_cdev, MKDEV(VME_MAJOR, 0), VME_DEVS);
 	if (err)
-		goto err_char;
+		goto err_class;
 
 	/* Request slave resources and allocate buffers (128kB wide) */
 	for (i = SLAVE_MINOR; i < (SLAVE_MAX + 1); i++) {
@@ -618,7 +618,7 @@ static int vme_user_probe(struct vme_dev *vdev)
 	if (IS_ERR(vme_user_sysfs_class)) {
 		dev_err(&vdev->dev, "Error creating vme_user class.\n");
 		err = PTR_ERR(vme_user_sysfs_class);
-		goto err_class;
+		goto err_master;
 	}
 
 	/* Add sysfs Entries */

commit 5d8515bc232172963a4cef007e97b08c5e4d0533
Merge: db5933225f2f 3384e01179ef
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Feb 1 09:51:57 2018 -0800

    Merge tag 'staging-4.16-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/staging
    
    Pull staging/IIO updates from Greg KH:
     "Here is the big Staging and IIO driver patches for 4.16-rc1.
    
      There is the normal amount of new IIO drivers added, like all
      releases.
    
      The networking IPX and the ncpfs filesystem are moved into the staging
      tree, as they are on their way out of the kernel due to lack of use
      anymore.
    
      The visorbus subsystem finall has started moving out of the staging
      tree to the "real" part of the kernel, and the most and fsl-mc
      codebases are almost ready to move out, that will probably happen for
      4.17-rc1 if all goes well.
    
      Other than that, there is a bunch of license header cleanups in the
      tree, along with the normal amount of coding style churn that we all
      know and love for this codebase. I also got frustrated at the
      Meltdown/Spectre mess and took it out on the dgnc tty driver, deleting
      huge chunks of it that were never even being used.
    
      Full details of everything is in the shortlog.
    
      All of these patches have been in linux-next for a while with no
      reported issues"
    
    * tag 'staging-4.16-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/staging: (627 commits)
      staging: rtlwifi: remove redundant initialization of 'cfg_cmd'
      staging: rtl8723bs: remove a couple of redundant initializations
      staging: comedi: reformat lines to 80 chars or less
      staging: lustre: separate a connection destroy from free struct kib_conn
      Staging: rtl8723bs: Use !x instead of NULL comparison
      Staging: rtl8723bs: Remove dead code
      Staging: rtl8723bs: Change names to conform to the kernel code
      staging: ccree: Fix missing blank line after declaration
      staging: rtl8188eu: remove redundant initialization of 'pwrcfgcmd'
      staging: rtlwifi: remove unused RTLHALMAC_ST and RTLPHYDM_ST
      staging: fbtft: remove unused FB_TFT_SSD1325 kconfig
      staging: comedi: dt2811: remove redundant initialization of 'ns'
      staging: wilc1000: fix alignments to match open parenthesis
      staging: wilc1000: removed unnecessary defined enums typedef
      staging: wilc1000: remove unnecessary use of parentheses
      staging: rtl8192u: remove redundant initialization of 'timeout'
      staging: sm750fb: fix CamelCase for dispSet var
      staging: lustre: lnet/selftest: fix compile error on UP build
      staging: rtl8723bs: hal_com_phycfg: Remove unneeded semicolons
      staging: rts5208: Fix "seg_no" calculation in reset_ms_card()
      ...

commit 73f8a5453d40d1cfcbbd4d5ae482f172cc7f9a75
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Thu Jan 11 11:08:33 2018 +0100

    staging: vme: vme_user.c: remove redundant license text
    
    Now that the SPDX tag is in all drivers/staging/vme/ files, that
    identifies the license in a specific and legally-defined manner.  So the
    extra GPL text wording can be removed as it is no longer needed at all.
    
    This is done on a quest to remove the 700+ different ways that files in
    the kernel describe the GPL license text.  And there's unneeded stuff
    like the address (sometimes incorrect) for the FSF which is never
    needed.
    
    No copyright headers or other non-license-description text was removed.
    
    Cc: Martyn Welch <martyn@welchs.me.uk>
    Cc: Manohar Vanga <manohar.vanga@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vme/devices/vme_user.c b/drivers/staging/vme/devices/vme_user.c
index e4be16c5f726..954bd435f679 100644
--- a/drivers/staging/vme/devices/vme_user.c
+++ b/drivers/staging/vme/devices/vme_user.c
@@ -8,12 +8,6 @@
  * Based on work by:
  *   Tom Armistead and Ajit Prem
  *     Copyright 2004 Motorola Inc.
- *
- *
- * This program is free software; you can redistribute  it and/or modify it
- * under  the terms of  the GNU General  Public License as published by the
- * Free Software Foundation;  either version 2 of the  License, or (at your
- * option) any later version.
  */
 
 #define pr_fmt(fmt) KBUILD_MODNAME ": " fmt

commit 0057cb5e8dac45089830d7712731d0b94facefe9
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Thu Jan 11 11:08:32 2018 +0100

    staging: vme: vme_user: add SPDX identifier.
    
    It's good to have SPDX identifiers in all files to make it easier to
    audit the kernel tree for correct licenses.
    
    Fix up the remaining staging vme driver to have a proper SPDX
    identifier, based on the license text in the file itself.  The SPDX
    identifier is a legally binding shorthand, which can be used instead of
    the full boiler plate text.
    
    This work is based on a script and data from Thomas Gleixner, Philippe
    Ombredanne, and Kate Stewart.
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: Philippe Ombredanne <pombredanne@nexb.com>
    Cc: Martyn Welch <martyn@welchs.me.uk>
    Cc: Manohar Vanga <manohar.vanga@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vme/devices/vme_user.c b/drivers/staging/vme/devices/vme_user.c
index 41a5b32e0d1c..e4be16c5f726 100644
--- a/drivers/staging/vme/devices/vme_user.c
+++ b/drivers/staging/vme/devices/vme_user.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0+
 /*
  * VMEbus User access driver
  *

commit 9d4c0c9f6a747a9bdec03057be4193994839ec87
Author: Philippe Loctaux <loctauxphilippe@gmail.com>
Date:   Thu Dec 28 22:51:24 2017 +0100

    Staging: vme: vme_user: fixed an alignment coding style issue
    
    Fixed a coding style issue.
    
    Signed-off-by: Philippe Loctaux <loctauxphilippe@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vme/devices/vme_user.c b/drivers/staging/vme/devices/vme_user.c
index a3d4610fbdbe..41a5b32e0d1c 100644
--- a/drivers/staging/vme/devices/vme_user.c
+++ b/drivers/staging/vme/devices/vme_user.c
@@ -573,7 +573,7 @@ static int vme_user_probe(struct vme_dev *vdev)
 		 * by all windows.
 		 */
 		image[i].resource = vme_slave_request(vme_user_bridge,
-			VME_A24, VME_SCT);
+						      VME_A24, VME_SCT);
 		if (!image[i].resource) {
 			dev_warn(&vdev->dev,
 				 "Unable to allocate slave resource\n");
@@ -582,7 +582,8 @@ static int vme_user_probe(struct vme_dev *vdev)
 		}
 		image[i].size_buf = PCI_BUF_SIZE;
 		image[i].kern_buf = vme_alloc_consistent(image[i].resource,
-			image[i].size_buf, &image[i].pci_buf);
+							 image[i].size_buf,
+							 &image[i].pci_buf);
 		if (!image[i].kern_buf) {
 			dev_warn(&vdev->dev,
 				 "Unable to allocate memory for buffer\n");
@@ -600,7 +601,8 @@ static int vme_user_probe(struct vme_dev *vdev)
 	for (i = MASTER_MINOR; i < (MASTER_MAX + 1); i++) {
 		/* XXX Need to properly request attributes */
 		image[i].resource = vme_master_request(vme_user_bridge,
-			VME_A32, VME_SCT, VME_D32);
+						       VME_A32, VME_SCT,
+						       VME_D32);
 		if (!image[i].resource) {
 			dev_warn(&vdev->dev,
 				 "Unable to allocate master resource\n");
@@ -645,7 +647,8 @@ static int vme_user_probe(struct vme_dev *vdev)
 
 		num = (type[i] == SLAVE_MINOR) ? i - (MASTER_MAX + 1) : i;
 		image[i].device = device_create(vme_user_sysfs_class, NULL,
-					MKDEV(VME_MAJOR, i), NULL, name, num);
+						MKDEV(VME_MAJOR, i), NULL,
+						name, num);
 		if (IS_ERR(image[i].device)) {
 			dev_info(&vdev->dev, "Error creating sysfs device\n");
 			err = PTR_ERR(image[i].device);

commit 14544d7690f674ce2b7aa9dc6531c244cc861d19
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Dec 29 16:12:28 2017 -0500

    vme_user: don't use __copy_..._user()
    
    Saving access_ok() is not worth the trouble; yes, the callers of ->read()
    and ->write() will have done the right checks, but it's much too long
    (and varied) call chains to rely upon.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/drivers/staging/vme/devices/vme_user.c b/drivers/staging/vme/devices/vme_user.c
index a3d4610fbdbe..4c8c6fa0a79f 100644
--- a/drivers/staging/vme/devices/vme_user.c
+++ b/drivers/staging/vme/devices/vme_user.c
@@ -134,7 +134,7 @@ static ssize_t resource_to_user(int minor, char __user *buf, size_t count,
 	if (copied < 0)
 		return (int)copied;
 
-	if (__copy_to_user(buf, image[minor].kern_buf, (unsigned long)copied))
+	if (copy_to_user(buf, image[minor].kern_buf, (unsigned long)copied))
 		return -EFAULT;
 
 	return copied;
@@ -146,7 +146,7 @@ static ssize_t resource_from_user(unsigned int minor, const char __user *buf,
 	if (count > image[minor].size_buf)
 		count = image[minor].size_buf;
 
-	if (__copy_from_user(image[minor].kern_buf, buf, (unsigned long)count))
+	if (copy_from_user(image[minor].kern_buf, buf, (unsigned long)count))
 		return -EFAULT;
 
 	return vme_master_write(image[minor].resource, image[minor].kern_buf,
@@ -159,7 +159,7 @@ static ssize_t buffer_to_user(unsigned int minor, char __user *buf,
 	void *image_ptr;
 
 	image_ptr = image[minor].kern_buf + *ppos;
-	if (__copy_to_user(buf, image_ptr, (unsigned long)count))
+	if (copy_to_user(buf, image_ptr, (unsigned long)count))
 		return -EFAULT;
 
 	return count;
@@ -171,7 +171,7 @@ static ssize_t buffer_from_user(unsigned int minor, const char __user *buf,
 	void *image_ptr;
 
 	image_ptr = image[minor].kern_buf + *ppos;
-	if (__copy_from_user(image_ptr, buf, (unsigned long)count))
+	if (copy_from_user(image_ptr, buf, (unsigned long)count))
 		return -EFAULT;
 
 	return count;

commit d3cfd5b9c8dc2bd6dff08acb074973a09ba30751
Author: Elena Reshetova <elena.reshetova@intel.com>
Date:   Mon Mar 6 16:21:10 2017 +0200

    drivers: convert vme_user_vma_priv.refcnt from atomic_t to refcount_t
    
    refcount_t type and corresponding API should be
    used instead of atomic_t when the variable is used as
    a reference counter. This allows to avoid accidental
    refcounter overflows that might lead to use-after-free
    situations.
    
    Signed-off-by: Elena Reshetova <elena.reshetova@intel.com>
    Signed-off-by: Hans Liljestrand <ishkamiel@gmail.com>
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: David Windsor <dwindsor@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vme/devices/vme_user.c b/drivers/staging/vme/devices/vme_user.c
index 69e9a7705afb..a3d4610fbdbe 100644
--- a/drivers/staging/vme/devices/vme_user.c
+++ b/drivers/staging/vme/devices/vme_user.c
@@ -17,7 +17,7 @@
 
 #define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
 
-#include <linux/atomic.h>
+#include <linux/refcount.h>
 #include <linux/cdev.h>
 #include <linux/delay.h>
 #include <linux/device.h>
@@ -118,7 +118,7 @@ static const int type[VME_DEVS] = {	MASTER_MINOR,	MASTER_MINOR,
 
 struct vme_user_vma_priv {
 	unsigned int minor;
-	atomic_t refcnt;
+	refcount_t refcnt;
 };
 
 static ssize_t resource_to_user(int minor, char __user *buf, size_t count,
@@ -430,7 +430,7 @@ static void vme_user_vm_open(struct vm_area_struct *vma)
 {
 	struct vme_user_vma_priv *vma_priv = vma->vm_private_data;
 
-	atomic_inc(&vma_priv->refcnt);
+	refcount_inc(&vma_priv->refcnt);
 }
 
 static void vme_user_vm_close(struct vm_area_struct *vma)
@@ -438,7 +438,7 @@ static void vme_user_vm_close(struct vm_area_struct *vma)
 	struct vme_user_vma_priv *vma_priv = vma->vm_private_data;
 	unsigned int minor = vma_priv->minor;
 
-	if (!atomic_dec_and_test(&vma_priv->refcnt))
+	if (!refcount_dec_and_test(&vma_priv->refcnt))
 		return;
 
 	mutex_lock(&image[minor].mutex);
@@ -473,7 +473,7 @@ static int vme_user_master_mmap(unsigned int minor, struct vm_area_struct *vma)
 	}
 
 	vma_priv->minor = minor;
-	atomic_set(&vma_priv->refcnt, 1);
+	refcount_set(&vma_priv->refcnt, 1);
 	vma->vm_ops = &vme_user_vm_ops;
 	vma->vm_private_data = vma_priv;
 

commit 00e293b9efe4d595064b883f1e5a30fa72974662
Author: Philip Thiemann <philip.thiemann@fau.de>
Date:   Thu Jan 12 14:00:26 2017 +0100

    staging: vme: vme_user.c: fix warning 'line over 80 characters'
    
    Removed checkpatch.pl warning 'line over 80 characters' by inserting a
    linebreak in the comment line 50.
    
    Signed-off-by: Philip Thiemann <philip.thiemann@fau.de>
    Signed-off-by: Fabian Arnold <fabian.arnold@fau.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vme/devices/vme_user.c b/drivers/staging/vme/devices/vme_user.c
index 87aa5174df22..69e9a7705afb 100644
--- a/drivers/staging/vme/devices/vme_user.c
+++ b/drivers/staging/vme/devices/vme_user.c
@@ -47,7 +47,8 @@ static const char driver_name[] = "vme_user";
 static int bus[VME_USER_BUS_MAX];
 static unsigned int bus_num;
 
-/* Currently Documentation/admin-guide/devices.rst defines the following for VME:
+/* Currently Documentation/admin-guide/devices.rst defines the
+ * following for VME:
  *
  * 221 char	VME bus
  *		  0 = /dev/bus/vme/m0		First master image

commit 72cca7baf4fba777b8ab770b902cf2e08941773f
Merge: 5266e70335da 3e0f9b2ca8e4
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Dec 13 11:35:00 2016 -0800

    Merge tag 'staging-4.10-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/staging
    
    Pull staging/IIO updates from Greg KH:
     "Here's the "big" staging/iio pull request for 4.10-rc1.
    
      Not as big as 4.9 was, but still just over a thousand changes. We
      almost broke even of lines added vs. removed, as the slicoss driver
      was removed (got a "clean" driver for the same hardware through the
      netdev tree), and some iio drivers were also dropped, but I think we
      ended up adding a few thousand lines to the source tree in the end.
      Other than that it's a lot of minor fixes all over the place, nothing
      major stands out at all.
    
      All of these have been in linux-next for a while. There will be a
      merge conflict with Al's vfs tree in the lustre code, but the
      resolution for that should be pretty simple, that too has been in
      linux-next"
    
    * tag 'staging-4.10-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/staging: (1002 commits)
      staging: comedi: comedidev.h: Document usage of 'detach' handler
      staging: fsl-mc: remove unnecessary info prints from bus driver
      staging: fsl-mc: add sysfs ABI doc
      staging/lustre/o2iblnd: Fix misspelled attemps->attempts
      staging/lustre/o2iblnd: Fix misspelling intialized->intialized
      staging/lustre: Convert all bare unsigned to unsigned int
      staging/lustre/socklnd: Fix whitespace problem
      staging/lustre/o2iblnd: Add missing space
      staging/lustre/lnetselftest: Fix potential integer overflow
      staging: greybus: audio_module: remove redundant OOM message
      staging: dgnc: Fix lines longer than 80 characters
      staging: dgnc: fix blank line after '{' warnings.
      staging/android: remove Sync Framework tasks from TODO
      staging/lustre/osc: Revert erroneous list_for_each_entry_safe use
      staging: slicoss: remove the staging driver
      staging: lustre: libcfs: remove lnet upcall code
      staging: lustre: remove set but unused variables
      staging: lustre: osc: set lock data for readahead lock
      staging: lustre: import: don't reconnect during connect interpret
      staging: lustre: clio: remove mtime check in vvp_io_fault_start()
      ...

commit 1fede020317e688a524722a0cfbf864c23889715
Author: Walt Feasel <waltfeasel@gmail.com>
Date:   Fri Nov 18 12:14:07 2016 -0500

    staging: vme: vme_user.c Spelling corrections
    
    Make spelling corrections for 'correctly' and
    'unregister'
    
    Signed-off-by: Walt Feasel <waltfeasel@gmail.com>
    Acked-by: Martyn Welch <martyn at welchs.e.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vme/devices/vme_user.c b/drivers/staging/vme/devices/vme_user.c
index 5dd430f8f921..2753fb21c596 100644
--- a/drivers/staging/vme/devices/vme_user.c
+++ b/drivers/staging/vme/devices/vme_user.c
@@ -661,7 +661,7 @@ static int vme_user_probe(struct vme_dev *vdev)
 	}
 	class_destroy(vme_user_sysfs_class);
 
-	/* Ensure counter set correcty to unalloc all master windows */
+	/* Ensure counter set correctly to unalloc all master windows */
 	i = MASTER_MAX + 1;
 err_master:
 	while (i > MASTER_MINOR) {
@@ -671,7 +671,7 @@ static int vme_user_probe(struct vme_dev *vdev)
 	}
 
 	/*
-	 * Ensure counter set correcty to unalloc all slave windows and buffers
+	 * Ensure counter set correctly to unalloc all slave windows and buffers
 	 */
 	i = SLAVE_MAX + 1;
 err_slave:
@@ -716,7 +716,7 @@ static int vme_user_remove(struct vme_dev *dev)
 	/* Unregister device driver */
 	cdev_del(vme_user_cdev);
 
-	/* Unregiser the major and minor device numbers */
+	/* Unregister the major and minor device numbers */
 	unregister_chrdev_region(MKDEV(VME_MAJOR, 0), VME_DEVS);
 
 	return 0;

commit 8c27ceff3604b249a9efafbd1bd8b141b79e619d
Author: Mauro Carvalho Chehab <mchehab@s-opensource.com>
Date:   Tue Oct 18 10:12:27 2016 -0200

    docs: fix locations of several documents that got moved
    
    The previous patch renamed several files that are cross-referenced
    along the Kernel documentation. Adjust the links to point to
    the right places.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/staging/vme/devices/vme_user.c b/drivers/staging/vme/devices/vme_user.c
index 5dd430f8f921..d84dffb894f4 100644
--- a/drivers/staging/vme/devices/vme_user.c
+++ b/drivers/staging/vme/devices/vme_user.c
@@ -47,7 +47,7 @@ static const char driver_name[] = "vme_user";
 static int bus[VME_USER_BUS_MAX];
 static unsigned int bus_num;
 
-/* Currently Documentation/devices.txt defines the following for VME:
+/* Currently Documentation/admin-guide/devices.rst defines the following for VME:
  *
  * 221 char	VME bus
  *		  0 = /dev/bus/vme/m0		First master image

commit 65f5c3ea622dfca230e96e5098603f1df9e0a902
Author: Ryan Swan <ryan@ryanswan.com>
Date:   Mon Sep 12 09:58:20 2016 -0400

    staging: vme/devices: vme_user.c: fix: converted decimal permissions to octal
    
    Ran checkpatch.pl -f vme_user.c
    Fixed: ERROR: Use 4 digit octal (0777) not decimal permissions
    
    Signed-off-by: Ryan Swan <ryan@ryanswan.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vme/devices/vme_user.c b/drivers/staging/vme/devices/vme_user.c
index b95883bc68fe..5dd430f8f921 100644
--- a/drivers/staging/vme/devices/vme_user.c
+++ b/drivers/staging/vme/devices/vme_user.c
@@ -773,7 +773,7 @@ static void __exit vme_user_exit(void)
 }
 
 MODULE_PARM_DESC(bus, "Enumeration of VMEbus to which the driver is connected");
-module_param_array(bus, int, &bus_num, 0);
+module_param_array(bus, int, &bus_num, 0000);
 
 MODULE_DESCRIPTION("VME User Space Access Driver");
 MODULE_AUTHOR("Martyn Welch <martyn.welch@ge.com");

commit 59a04f11350bcf5653aee760fb3d5e06a651b640
Author: Egor Uleyskiy <egor.ulieiskii@gmail.com>
Date:   Sun Nov 22 11:27:56 2015 +0200

    drivers: staging: vme: Fixed checking NULL and 0 code style
    
    Signed-off-by: Egor Uleyskiy <egor.ulieiskii@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vme/devices/vme_user.c b/drivers/staging/vme/devices/vme_user.c
index a05a065686de..b95883bc68fe 100644
--- a/drivers/staging/vme/devices/vme_user.c
+++ b/drivers/staging/vme/devices/vme_user.c
@@ -309,7 +309,7 @@ static int vme_user_ioctl(struct inode *inode, struct file *file,
 		case VME_IRQ_GEN:
 			copied = copy_from_user(&irq_req, argp,
 						sizeof(irq_req));
-			if (copied != 0) {
+			if (copied) {
 				pr_warn("Partial copy from userspace\n");
 				return -EFAULT;
 			}
@@ -335,7 +335,7 @@ static int vme_user_ioctl(struct inode *inode, struct file *file,
 
 			copied = copy_to_user(argp, &master,
 					      sizeof(master));
-			if (copied != 0) {
+			if (copied) {
 				pr_warn("Partial copy to userspace\n");
 				return -EFAULT;
 			}
@@ -350,7 +350,7 @@ static int vme_user_ioctl(struct inode *inode, struct file *file,
 			}
 
 			copied = copy_from_user(&master, argp, sizeof(master));
-			if (copied != 0) {
+			if (copied) {
 				pr_warn("Partial copy from userspace\n");
 				return -EFAULT;
 			}
@@ -380,7 +380,7 @@ static int vme_user_ioctl(struct inode *inode, struct file *file,
 
 			copied = copy_to_user(argp, &slave,
 					      sizeof(slave));
-			if (copied != 0) {
+			if (copied) {
 				pr_warn("Partial copy to userspace\n");
 				return -EFAULT;
 			}
@@ -390,7 +390,7 @@ static int vme_user_ioctl(struct inode *inode, struct file *file,
 		case VME_SET_SLAVE:
 
 			copied = copy_from_user(&slave, argp, sizeof(slave));
-			if (copied != 0) {
+			if (copied) {
 				pr_warn("Partial copy from userspace\n");
 				return -EFAULT;
 			}
@@ -757,7 +757,7 @@ static int __init vme_user_init(void)
 	 * we just change the code in vme_user_match().
 	 */
 	retval = vme_register_driver(&vme_user_driver, VME_MAX_SLOTS);
-	if (retval != 0)
+	if (retval)
 		goto err_reg;
 
 	return retval;

commit 93a28666a9fadc56fa700e496bb549faf490f3a4
Author: Egor Uleyskiy <egor.ulieiskii@gmail.com>
Date:   Sun Nov 22 11:27:54 2015 +0200

    drivers: staging: vme: Fixed the using of sizeof
    
    Constructions that looks like
        card = kzalloc(sizeof(struct pio2_card), GFP_KERNEL);
      are changed to
        card = kzalloc(sizeof(*card), GFP_KERNEL);
    
    Signed-off-by: Egor Uleyskiy <egor.ulieiskii@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vme/devices/vme_user.c b/drivers/staging/vme/devices/vme_user.c
index 8e61a3b3e7e4..a05a065686de 100644
--- a/drivers/staging/vme/devices/vme_user.c
+++ b/drivers/staging/vme/devices/vme_user.c
@@ -308,7 +308,7 @@ static int vme_user_ioctl(struct inode *inode, struct file *file,
 		switch (cmd) {
 		case VME_IRQ_GEN:
 			copied = copy_from_user(&irq_req, argp,
-						sizeof(struct vme_irq_id));
+						sizeof(irq_req));
 			if (copied != 0) {
 				pr_warn("Partial copy from userspace\n");
 				return -EFAULT;
@@ -322,7 +322,7 @@ static int vme_user_ioctl(struct inode *inode, struct file *file,
 	case MASTER_MINOR:
 		switch (cmd) {
 		case VME_GET_MASTER:
-			memset(&master, 0, sizeof(struct vme_master));
+			memset(&master, 0, sizeof(master));
 
 			/* XXX	We do not want to push aspace, cycle and width
 			 *	to userspace as they are
@@ -334,7 +334,7 @@ static int vme_user_ioctl(struct inode *inode, struct file *file,
 						&master.cycle, &master.dwidth);
 
 			copied = copy_to_user(argp, &master,
-					      sizeof(struct vme_master));
+					      sizeof(master));
 			if (copied != 0) {
 				pr_warn("Partial copy to userspace\n");
 				return -EFAULT;
@@ -368,7 +368,7 @@ static int vme_user_ioctl(struct inode *inode, struct file *file,
 	case SLAVE_MINOR:
 		switch (cmd) {
 		case VME_GET_SLAVE:
-			memset(&slave, 0, sizeof(struct vme_slave));
+			memset(&slave, 0, sizeof(slave));
 
 			/* XXX	We do not want to push aspace, cycle and width
 			 *	to userspace as they are
@@ -379,7 +379,7 @@ static int vme_user_ioctl(struct inode *inode, struct file *file,
 					       &slave.aspace, &slave.cycle);
 
 			copied = copy_to_user(argp, &slave,
-					      sizeof(struct vme_slave));
+					      sizeof(slave));
 			if (copied != 0) {
 				pr_warn("Partial copy to userspace\n");
 				return -EFAULT;

commit 44ae5443ef9fac059a2892cbb3f7e4d95f7f8d12
Author: Navy Cheng <navych@126.com>
Date:   Thu Aug 6 09:47:57 2015 +0800

    Staging: vme: remove an unnecessary and wrong warning message
    
    The wrong warning message in vme_user_probe() will mislead developers and
    users. As the error message which prompt cdev_add() error already exists,
    just remove the unnecessary and wrong message.
    
    Signed-off-by: Navy Cheng <navych@126.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vme/devices/vme_user.c b/drivers/staging/vme/devices/vme_user.c
index b3e3c2d546a1..8e61a3b3e7e4 100644
--- a/drivers/staging/vme/devices/vme_user.c
+++ b/drivers/staging/vme/devices/vme_user.c
@@ -561,10 +561,8 @@ static int vme_user_probe(struct vme_dev *vdev)
 	vme_user_cdev->ops = &vme_user_fops;
 	vme_user_cdev->owner = THIS_MODULE;
 	err = cdev_add(vme_user_cdev, MKDEV(VME_MAJOR, 0), VME_DEVS);
-	if (err) {
-		dev_warn(&vdev->dev, "cdev_all failed\n");
+	if (err)
 		goto err_char;
-	}
 
 	/* Request slave resources and allocate buffers (128kB wide) */
 	for (i = SLAVE_MINOR; i < (SLAVE_MAX + 1); i++) {

commit 32491f561bffddfc5c3dee87e439f2ec64a6cf80
Author: Dmitry Kalinkin <dmitry.kalinkin@gmail.com>
Date:   Fri Jun 26 23:39:44 2015 +0300

    staging: vme_user: remove okcount variable
    
    Signed-off-by: Dmitry Kalinkin <dmitry.kalinkin@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vme/devices/vme_user.c b/drivers/staging/vme/devices/vme_user.c
index 7ca943cf1b92..b3e3c2d546a1 100644
--- a/drivers/staging/vme/devices/vme_user.c
+++ b/drivers/staging/vme/devices/vme_user.c
@@ -182,7 +182,6 @@ static ssize_t vme_user_read(struct file *file, char __user *buf, size_t count,
 	unsigned int minor = MINOR(file_inode(file)->i_rdev);
 	ssize_t retval;
 	size_t image_size;
-	size_t okcount;
 
 	if (minor == CONTROL_MINOR)
 		return 0;
@@ -200,16 +199,14 @@ static ssize_t vme_user_read(struct file *file, char __user *buf, size_t count,
 
 	/* Ensure not reading past end of the image */
 	if (*ppos + count > image_size)
-		okcount = image_size - *ppos;
-	else
-		okcount = count;
+		count = image_size - *ppos;
 
 	switch (type[minor]) {
 	case MASTER_MINOR:
-		retval = resource_to_user(minor, buf, okcount, ppos);
+		retval = resource_to_user(minor, buf, count, ppos);
 		break;
 	case SLAVE_MINOR:
-		retval = buffer_to_user(minor, buf, okcount, ppos);
+		retval = buffer_to_user(minor, buf, count, ppos);
 		break;
 	default:
 		retval = -EINVAL;
@@ -228,7 +225,6 @@ static ssize_t vme_user_write(struct file *file, const char __user *buf,
 	unsigned int minor = MINOR(file_inode(file)->i_rdev);
 	ssize_t retval;
 	size_t image_size;
-	size_t okcount;
 
 	if (minor == CONTROL_MINOR)
 		return 0;
@@ -245,16 +241,14 @@ static ssize_t vme_user_write(struct file *file, const char __user *buf,
 
 	/* Ensure not reading past end of the image */
 	if (*ppos + count > image_size)
-		okcount = image_size - *ppos;
-	else
-		okcount = count;
+		count = image_size - *ppos;
 
 	switch (type[minor]) {
 	case MASTER_MINOR:
-		retval = resource_from_user(minor, buf, okcount, ppos);
+		retval = resource_from_user(minor, buf, count, ppos);
 		break;
 	case SLAVE_MINOR:
-		retval = buffer_from_user(minor, buf, okcount, ppos);
+		retval = buffer_from_user(minor, buf, count, ppos);
 		break;
 	default:
 		retval = -EINVAL;

commit 18f8bee2066a55b7fee478cac0a91d073d3d24a9
Author: Dmitry Kalinkin <dmitry.kalinkin@gmail.com>
Date:   Fri Jun 26 23:39:43 2015 +0300

    staging: vme_user: remove distracting comment
    
    Signed-off-by: Dmitry Kalinkin <dmitry.kalinkin@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vme/devices/vme_user.c b/drivers/staging/vme/devices/vme_user.c
index 947a38eb9160..7ca943cf1b92 100644
--- a/drivers/staging/vme/devices/vme_user.c
+++ b/drivers/staging/vme/devices/vme_user.c
@@ -128,7 +128,6 @@ static ssize_t resource_to_user(int minor, char __user *buf, size_t count,
 	if (count > image[minor].size_buf)
 		count = image[minor].size_buf;
 
-	/* We copy to kernel buffer */
 	copied = vme_master_read(image[minor].resource, image[minor].kern_buf,
 				 count, *ppos);
 	if (copied < 0)

commit 457ab28619abd1a87eefbb2615bb54ede51e339f
Author: Dmitry Kalinkin <dmitry.kalinkin@gmail.com>
Date:   Fri Jun 26 23:39:42 2015 +0300

    staging: vme_user: remove unused variable
    
    Signed-off-by: Dmitry Kalinkin <dmitry.kalinkin@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vme/devices/vme_user.c b/drivers/staging/vme/devices/vme_user.c
index ef876a44e0cf..947a38eb9160 100644
--- a/drivers/staging/vme/devices/vme_user.c
+++ b/drivers/staging/vme/devices/vme_user.c
@@ -143,18 +143,14 @@ static ssize_t resource_to_user(int minor, char __user *buf, size_t count,
 static ssize_t resource_from_user(unsigned int minor, const char __user *buf,
 				  size_t count, loff_t *ppos)
 {
-	ssize_t copied = 0;
-
 	if (count > image[minor].size_buf)
 		count = image[minor].size_buf;
 
 	if (__copy_from_user(image[minor].kern_buf, buf, (unsigned long)count))
 		return -EFAULT;
 
-	copied = vme_master_write(image[minor].resource, image[minor].kern_buf,
-				  count, *ppos);
-
-	return copied;
+	return vme_master_write(image[minor].resource, image[minor].kern_buf,
+				count, *ppos);
 }
 
 static ssize_t buffer_to_user(unsigned int minor, char __user *buf,

commit 7c78e0cdd0baaea087f342330ec1cc44cf4312e8
Author: Dmitry Kalinkin <dmitry.kalinkin@gmail.com>
Date:   Fri Jun 26 23:39:41 2015 +0300

    staging: vme_user: switch to returning -EFAULT on __copy_*_user errors
    
    Signed-off-by: Dmitry Kalinkin <dmitry.kalinkin@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vme/devices/vme_user.c b/drivers/staging/vme/devices/vme_user.c
index a2345db91e85..ef876a44e0cf 100644
--- a/drivers/staging/vme/devices/vme_user.c
+++ b/drivers/staging/vme/devices/vme_user.c
@@ -123,7 +123,6 @@ struct vme_user_vma_priv {
 static ssize_t resource_to_user(int minor, char __user *buf, size_t count,
 				loff_t *ppos)
 {
-	ssize_t retval;
 	ssize_t copied = 0;
 
 	if (count > image[minor].size_buf)
@@ -135,13 +134,8 @@ static ssize_t resource_to_user(int minor, char __user *buf, size_t count,
 	if (copied < 0)
 		return (int)copied;
 
-	retval = __copy_to_user(buf, image[minor].kern_buf,
-				(unsigned long)copied);
-	if (retval != 0) {
-		copied = (copied - retval);
-		pr_info("User copy failed\n");
-		return -EINVAL;
-	}
+	if (__copy_to_user(buf, image[minor].kern_buf, (unsigned long)copied))
+		return -EFAULT;
 
 	return copied;
 }
@@ -149,21 +143,16 @@ static ssize_t resource_to_user(int minor, char __user *buf, size_t count,
 static ssize_t resource_from_user(unsigned int minor, const char __user *buf,
 				  size_t count, loff_t *ppos)
 {
-	ssize_t retval;
 	ssize_t copied = 0;
 
 	if (count > image[minor].size_buf)
 		count = image[minor].size_buf;
 
-	retval = __copy_from_user(image[minor].kern_buf, buf,
-				  (unsigned long)count);
-	if (retval != 0)
-		copied = (copied - retval);
-	else
-		copied = count;
+	if (__copy_from_user(image[minor].kern_buf, buf, (unsigned long)count))
+		return -EFAULT;
 
 	copied = vme_master_write(image[minor].resource, image[minor].kern_buf,
-				  copied, *ppos);
+				  count, *ppos);
 
 	return copied;
 }
@@ -172,38 +161,24 @@ static ssize_t buffer_to_user(unsigned int minor, char __user *buf,
 			      size_t count, loff_t *ppos)
 {
 	void *image_ptr;
-	ssize_t retval;
 
 	image_ptr = image[minor].kern_buf + *ppos;
+	if (__copy_to_user(buf, image_ptr, (unsigned long)count))
+		return -EFAULT;
 
-	retval = __copy_to_user(buf, image_ptr, (unsigned long)count);
-	if (retval != 0) {
-		retval = (count - retval);
-		pr_warn("Partial copy to userspace\n");
-	} else
-		retval = count;
-
-	/* Return number of bytes successfully read */
-	return retval;
+	return count;
 }
 
 static ssize_t buffer_from_user(unsigned int minor, const char __user *buf,
 				size_t count, loff_t *ppos)
 {
 	void *image_ptr;
-	size_t retval;
 
 	image_ptr = image[minor].kern_buf + *ppos;
+	if (__copy_from_user(image_ptr, buf, (unsigned long)count))
+		return -EFAULT;
 
-	retval = __copy_from_user(image_ptr, buf, (unsigned long)count);
-	if (retval != 0) {
-		retval = (count - retval);
-		pr_warn("Partial copy to userspace\n");
-	} else
-		retval = count;
-
-	/* Return number of bytes successfully read */
-	return retval;
+	return count;
 }
 
 static ssize_t vme_user_read(struct file *file, char __user *buf, size_t count,

commit 8e4d138cc083bb960271e79832982e982c35d219
Author: Dmitry Kalinkin <dmitry.kalinkin@gmail.com>
Date:   Fri Jun 26 23:39:40 2015 +0300

    staging: vme_user: allow large read()/write()
    
    This changes large master transfers to do shorter read/write rather than
    return -EINVAL. User space will now be able to optimistically request a
    large transfer and get at least some data.
    
    This also removes comments suggesting on how to implement large
    transfers. Current vme_master_* read and write implementations use CPU
    copies that don't produce burst PCI accesses and subsequently no block
    transfer on VME bus. In the end overall performance is quiet low and it
    can't be fixed by doing direct copy to user space. Much easier solution
    would be to just reuse kernel buffer.
    
    Signed-off-by: Dmitry Kalinkin <dmitry.kalinkin@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vme/devices/vme_user.c b/drivers/staging/vme/devices/vme_user.c
index 3467cde5ac6c..a2345db91e85 100644
--- a/drivers/staging/vme/devices/vme_user.c
+++ b/drivers/staging/vme/devices/vme_user.c
@@ -120,75 +120,50 @@ struct vme_user_vma_priv {
 	atomic_t refcnt;
 };
 
-/*
- * We are going ot alloc a page during init per window for small transfers.
- * Small transfers will go VME -> buffer -> user space. Larger (more than a
- * page) transfers will lock the user space buffer into memory and then
- * transfer the data directly into the user space buffers.
- */
 static ssize_t resource_to_user(int minor, char __user *buf, size_t count,
 				loff_t *ppos)
 {
 	ssize_t retval;
 	ssize_t copied = 0;
 
-	if (count <= image[minor].size_buf) {
-		/* We copy to kernel buffer */
-		copied = vme_master_read(image[minor].resource,
-			image[minor].kern_buf, count, *ppos);
-		if (copied < 0)
-			return (int)copied;
-
-		retval = __copy_to_user(buf, image[minor].kern_buf,
-			(unsigned long)copied);
-		if (retval != 0) {
-			copied = (copied - retval);
-			pr_info("User copy failed\n");
-			return -EINVAL;
-		}
+	if (count > image[minor].size_buf)
+		count = image[minor].size_buf;
 
-	} else {
-		/* XXX Need to write this */
-		pr_info("Currently don't support large transfers\n");
-		/* Map in pages from userspace */
+	/* We copy to kernel buffer */
+	copied = vme_master_read(image[minor].resource, image[minor].kern_buf,
+				 count, *ppos);
+	if (copied < 0)
+		return (int)copied;
 
-		/* Call vme_master_read to do the transfer */
+	retval = __copy_to_user(buf, image[minor].kern_buf,
+				(unsigned long)copied);
+	if (retval != 0) {
+		copied = (copied - retval);
+		pr_info("User copy failed\n");
 		return -EINVAL;
 	}
 
 	return copied;
 }
 
-/*
- * We are going to alloc a page during init per window for small transfers.
- * Small transfers will go user space -> buffer -> VME. Larger (more than a
- * page) transfers will lock the user space buffer into memory and then
- * transfer the data directly from the user space buffers out to VME.
- */
 static ssize_t resource_from_user(unsigned int minor, const char __user *buf,
 				  size_t count, loff_t *ppos)
 {
 	ssize_t retval;
 	ssize_t copied = 0;
 
-	if (count <= image[minor].size_buf) {
-		retval = __copy_from_user(image[minor].kern_buf, buf,
-			(unsigned long)count);
-		if (retval != 0)
-			copied = (copied - retval);
-		else
-			copied = count;
-
-		copied = vme_master_write(image[minor].resource,
-			image[minor].kern_buf, copied, *ppos);
-	} else {
-		/* XXX Need to write this */
-		pr_info("Currently don't support large transfers\n");
-		/* Map in pages from userspace */
-
-		/* Call vme_master_write to do the transfer */
-		return -EINVAL;
-	}
+	if (count > image[minor].size_buf)
+		count = image[minor].size_buf;
+
+	retval = __copy_from_user(image[minor].kern_buf, buf,
+				  (unsigned long)count);
+	if (retval != 0)
+		copied = (copied - retval);
+	else
+		copied = count;
+
+	copied = vme_master_write(image[minor].resource, image[minor].kern_buf,
+				  copied, *ppos);
 
 	return copied;
 }

commit 1f0622de0d1fb7de187c7cf729971d56def7814e
Author: Dmitry Kalinkin <dmitry.kalinkin@gmail.com>
Date:   Fri Jun 26 23:39:39 2015 +0300

    staging: vme_user: fix kmalloc style
    
    Signed-off-by: Dmitry Kalinkin <dmitry.kalinkin@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vme/devices/vme_user.c b/drivers/staging/vme/devices/vme_user.c
index 2ff15f081776..3467cde5ac6c 100644
--- a/drivers/staging/vme/devices/vme_user.c
+++ b/drivers/staging/vme/devices/vme_user.c
@@ -526,7 +526,7 @@ static int vme_user_master_mmap(unsigned int minor, struct vm_area_struct *vma)
 		return err;
 	}
 
-	vma_priv = kmalloc(sizeof(struct vme_user_vma_priv), GFP_KERNEL);
+	vma_priv = kmalloc(sizeof(*vma_priv), GFP_KERNEL);
 	if (!vma_priv) {
 		mutex_unlock(&image[minor].mutex);
 		return -ENOMEM;

commit f99b71be37dd88e7b2f4a7c227da6c4f71cd8fa4
Author: Dmitry Kalinkin <dmitry.kalinkin@gmail.com>
Date:   Fri Jun 26 23:39:38 2015 +0300

    staging: vme_user: fix NULL comparison style
    
    Signed-off-by: Dmitry Kalinkin <dmitry.kalinkin@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vme/devices/vme_user.c b/drivers/staging/vme/devices/vme_user.c
index 494655ad1264..2ff15f081776 100644
--- a/drivers/staging/vme/devices/vme_user.c
+++ b/drivers/staging/vme/devices/vme_user.c
@@ -527,7 +527,7 @@ static int vme_user_master_mmap(unsigned int minor, struct vm_area_struct *vma)
 	}
 
 	vma_priv = kmalloc(sizeof(struct vme_user_vma_priv), GFP_KERNEL);
-	if (vma_priv == NULL) {
+	if (!vma_priv) {
 		mutex_unlock(&image[minor].mutex);
 		return -ENOMEM;
 	}
@@ -588,7 +588,7 @@ static int vme_user_probe(struct vme_dev *vdev)
 	char *name;
 
 	/* Save pointer to the bridge device */
-	if (vme_user_bridge != NULL) {
+	if (vme_user_bridge) {
 		dev_err(&vdev->dev, "Driver can only be loaded for 1 device\n");
 		err = -EINVAL;
 		goto err_dev;
@@ -636,7 +636,7 @@ static int vme_user_probe(struct vme_dev *vdev)
 		 */
 		image[i].resource = vme_slave_request(vme_user_bridge,
 			VME_A24, VME_SCT);
-		if (image[i].resource == NULL) {
+		if (!image[i].resource) {
 			dev_warn(&vdev->dev,
 				 "Unable to allocate slave resource\n");
 			err = -ENOMEM;
@@ -645,7 +645,7 @@ static int vme_user_probe(struct vme_dev *vdev)
 		image[i].size_buf = PCI_BUF_SIZE;
 		image[i].kern_buf = vme_alloc_consistent(image[i].resource,
 			image[i].size_buf, &image[i].pci_buf);
-		if (image[i].kern_buf == NULL) {
+		if (!image[i].kern_buf) {
 			dev_warn(&vdev->dev,
 				 "Unable to allocate memory for buffer\n");
 			image[i].pci_buf = 0;
@@ -663,7 +663,7 @@ static int vme_user_probe(struct vme_dev *vdev)
 		/* XXX Need to properly request attributes */
 		image[i].resource = vme_master_request(vme_user_bridge,
 			VME_A32, VME_SCT, VME_D32);
-		if (image[i].resource == NULL) {
+		if (!image[i].resource) {
 			dev_warn(&vdev->dev,
 				 "Unable to allocate master resource\n");
 			err = -ENOMEM;
@@ -671,7 +671,7 @@ static int vme_user_probe(struct vme_dev *vdev)
 		}
 		image[i].size_buf = PCI_BUF_SIZE;
 		image[i].kern_buf = kmalloc(image[i].size_buf, GFP_KERNEL);
-		if (image[i].kern_buf == NULL) {
+		if (!image[i].kern_buf) {
 			err = -ENOMEM;
 			vme_master_free(image[i].resource);
 			goto err_master;

commit cd974d35ab784d98085ed1b317a9978c026d86f7
Author: Dmitry Kalinkin <dmitry.kalinkin@gmail.com>
Date:   Fri Jun 26 23:39:37 2015 +0300

    staging: vme_user: fix blank lines
    
    Signed-off-by: Dmitry Kalinkin <dmitry.kalinkin@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vme/devices/vme_user.c b/drivers/staging/vme/devices/vme_user.c
index ccf96029ca22..494655ad1264 100644
--- a/drivers/staging/vme/devices/vme_user.c
+++ b/drivers/staging/vme/devices/vme_user.c
@@ -101,13 +101,13 @@ struct image_desc {
 	struct vme_resource *resource;	/* VME resource */
 	int mmap_count;		/* Number of current mmap's */
 };
+
 static struct image_desc image[VME_DEVS];
 
 static struct cdev *vme_user_cdev;		/* Character device */
 static struct class *vme_user_sysfs_class;	/* Sysfs class */
 static struct vme_dev *vme_user_bridge;		/* Pointer to user device */
 
-
 static const int type[VME_DEVS] = {	MASTER_MINOR,	MASTER_MINOR,
 					MASTER_MINOR,	MASTER_MINOR,
 					SLAVE_MINOR,	SLAVE_MINOR,
@@ -120,7 +120,6 @@ struct vme_user_vma_priv {
 	atomic_t refcnt;
 };
 
-
 /*
  * We are going ot alloc a page during init per window for small transfers.
  * Small transfers will go VME -> buffer -> user space. Larger (more than a
@@ -836,7 +835,6 @@ static void __exit vme_user_exit(void)
 	vme_unregister_driver(&vme_user_driver);
 }
 
-
 MODULE_PARM_DESC(bus, "Enumeration of VMEbus to which the driver is connected");
 module_param_array(bus, int, &bus_num, 0);
 

commit 86eadace5d021f50558936ea75234f3262d16bc2
Author: Dmitry Kalinkin <dmitry.kalinkin@gmail.com>
Date:   Fri Jun 26 23:39:36 2015 +0300

    staging: vme_user: fix code alignment
    
    Signed-off-by: Dmitry Kalinkin <dmitry.kalinkin@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vme/devices/vme_user.c b/drivers/staging/vme/devices/vme_user.c
index 9cca97af3044..ccf96029ca22 100644
--- a/drivers/staging/vme/devices/vme_user.c
+++ b/drivers/staging/vme/devices/vme_user.c
@@ -128,7 +128,7 @@ struct vme_user_vma_priv {
  * transfer the data directly into the user space buffers.
  */
 static ssize_t resource_to_user(int minor, char __user *buf, size_t count,
-	loff_t *ppos)
+				loff_t *ppos)
 {
 	ssize_t retval;
 	ssize_t copied = 0;
@@ -167,7 +167,7 @@ static ssize_t resource_to_user(int minor, char __user *buf, size_t count,
  * transfer the data directly from the user space buffers out to VME.
  */
 static ssize_t resource_from_user(unsigned int minor, const char __user *buf,
-	size_t count, loff_t *ppos)
+				  size_t count, loff_t *ppos)
 {
 	ssize_t retval;
 	ssize_t copied = 0;
@@ -195,7 +195,7 @@ static ssize_t resource_from_user(unsigned int minor, const char __user *buf,
 }
 
 static ssize_t buffer_to_user(unsigned int minor, char __user *buf,
-	size_t count, loff_t *ppos)
+			      size_t count, loff_t *ppos)
 {
 	void *image_ptr;
 	ssize_t retval;
@@ -214,7 +214,7 @@ static ssize_t buffer_to_user(unsigned int minor, char __user *buf,
 }
 
 static ssize_t buffer_from_user(unsigned int minor, const char __user *buf,
-	size_t count, loff_t *ppos)
+				size_t count, loff_t *ppos)
 {
 	void *image_ptr;
 	size_t retval;
@@ -233,7 +233,7 @@ static ssize_t buffer_from_user(unsigned int minor, const char __user *buf,
 }
 
 static ssize_t vme_user_read(struct file *file, char __user *buf, size_t count,
-			loff_t *ppos)
+			     loff_t *ppos)
 {
 	unsigned int minor = MINOR(file_inode(file)->i_rdev);
 	ssize_t retval;
@@ -279,7 +279,7 @@ static ssize_t vme_user_read(struct file *file, char __user *buf, size_t count,
 }
 
 static ssize_t vme_user_write(struct file *file, const char __user *buf,
-			size_t count, loff_t *ppos)
+			      size_t count, loff_t *ppos)
 {
 	unsigned int minor = MINOR(file_inode(file)->i_rdev);
 	ssize_t retval;
@@ -354,7 +354,7 @@ static loff_t vme_user_llseek(struct file *file, loff_t off, int whence)
  * already been defined.
  */
 static int vme_user_ioctl(struct inode *inode, struct file *file,
-	unsigned int cmd, unsigned long arg)
+			  unsigned int cmd, unsigned long arg)
 {
 	struct vme_master master;
 	struct vme_slave slave;
@@ -390,12 +390,13 @@ static int vme_user_ioctl(struct inode *inode, struct file *file,
 			 *	to userspace as they are
 			 */
 			retval = vme_master_get(image[minor].resource,
-				&master.enable, &master.vme_addr,
-				&master.size, &master.aspace,
-				&master.cycle, &master.dwidth);
+						&master.enable,
+						&master.vme_addr,
+						&master.size, &master.aspace,
+						&master.cycle, &master.dwidth);
 
 			copied = copy_to_user(argp, &master,
-				sizeof(struct vme_master));
+					      sizeof(struct vme_master));
 			if (copied != 0) {
 				pr_warn("Partial copy to userspace\n");
 				return -EFAULT;
@@ -435,12 +436,12 @@ static int vme_user_ioctl(struct inode *inode, struct file *file,
 			 *	to userspace as they are
 			 */
 			retval = vme_slave_get(image[minor].resource,
-				&slave.enable, &slave.vme_addr,
-				&slave.size, &pci_addr, &slave.aspace,
-				&slave.cycle);
+					       &slave.enable, &slave.vme_addr,
+					       &slave.size, &pci_addr,
+					       &slave.aspace, &slave.cycle);
 
 			copied = copy_to_user(argp, &slave,
-				sizeof(struct vme_slave));
+					      sizeof(struct vme_slave));
 			if (copied != 0) {
 				pr_warn("Partial copy to userspace\n");
 				return -EFAULT;
@@ -606,7 +607,7 @@ static int vme_user_probe(struct vme_dev *vdev)
 
 	/* Assign major and minor numbers for the driver */
 	err = register_chrdev_region(MKDEV(VME_MAJOR, 0), VME_DEVS,
-		driver_name);
+				     driver_name);
 	if (err) {
 		dev_warn(&vdev->dev, "Error getting Major Number %d for driver.\n",
 			 VME_MAJOR);

commit 625a9e012dc637fdc4ceadaac74f18155b0406f6
Author: Dmitry Kalinkin <dmitry.kalinkin@gmail.com>
Date:   Sat Jun 13 16:34:03 2015 +0300

    staging: vme_user: remove buf_unalloc helper
    
    buf_unalloc is essentially a vme_free_consistent:
    1) image[i].kern_buf is never NULL in buf_alloc call
    2) kern_buf, pci_buf and size_buf get zeroed in vme_user_probe anyway
    
    Signed-off-by: Dmitry Kalinkin <dmitry.kalinkin@gmail.com>
    Cc: Igor Alekseev <igor.alekseev@itep.ru>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vme/devices/vme_user.c b/drivers/staging/vme/devices/vme_user.c
index a72f7a9c8d09..9cca97af3044 100644
--- a/drivers/staging/vme/devices/vme_user.c
+++ b/drivers/staging/vme/devices/vme_user.c
@@ -563,31 +563,6 @@ static const struct file_operations vme_user_fops = {
 	.mmap = vme_user_mmap,
 };
 
-/*
- * Unallocate a previously allocated buffer
- */
-static void buf_unalloc(int num)
-{
-	if (image[num].kern_buf) {
-#ifdef VME_DEBUG
-		pr_debug("UniverseII:Releasing buffer at %p\n",
-			 image[num].pci_buf);
-#endif
-
-		vme_free_consistent(image[num].resource, image[num].size_buf,
-			image[num].kern_buf, image[num].pci_buf);
-
-		image[num].kern_buf = NULL;
-		image[num].pci_buf = 0;
-		image[num].size_buf = 0;
-
-#ifdef VME_DEBUG
-	} else {
-		pr_debug("UniverseII: Buffer not allocated\n");
-#endif
-	}
-}
-
 static int vme_user_match(struct vme_dev *vdev)
 {
 	int i;
@@ -765,7 +740,8 @@ static int vme_user_probe(struct vme_dev *vdev)
 err_slave:
 	while (i > SLAVE_MINOR) {
 		i--;
-		buf_unalloc(i);
+		vme_free_consistent(image[i].resource, image[i].size_buf,
+				    image[i].kern_buf, image[i].pci_buf);
 		vme_slave_free(image[i].resource);
 	}
 err_class:
@@ -795,7 +771,8 @@ static int vme_user_remove(struct vme_dev *dev)
 
 	for (i = SLAVE_MINOR; i < (SLAVE_MAX + 1); i++) {
 		vme_slave_set(image[i].resource, 0, 0, 0, 0, VME_A32, 0);
-		buf_unalloc(i);
+		vme_free_consistent(image[i].resource, image[i].size_buf,
+				    image[i].kern_buf, image[i].pci_buf);
 		vme_slave_free(image[i].resource);
 	}
 

commit 0b029cb2f57a1499683d6b636fb967e5736ed554
Author: Dmitry Kalinkin <dmitry.kalinkin@gmail.com>
Date:   Sat Jun 13 16:34:02 2015 +0300

    staging: vme_user: remove open/release
    
    Checking for image[minor].resource != NULL is not needed since all
    resources are allocated before device is created.
    
    image[minor].users accounting is deleted because it's not being used.
    
    Signed-off-by: Dmitry Kalinkin <dmitry.kalinkin@gmail.com>
    Cc: Igor Alekseev <igor.alekseev@itep.ru>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vme/devices/vme_user.c b/drivers/staging/vme/devices/vme_user.c
index 8e46d606d42a..a72f7a9c8d09 100644
--- a/drivers/staging/vme/devices/vme_user.c
+++ b/drivers/staging/vme/devices/vme_user.c
@@ -99,7 +99,6 @@ struct image_desc {
 	struct mutex mutex;	/* Mutex for locking image */
 	struct device *device;	/* Sysfs device */
 	struct vme_resource *resource;	/* VME resource */
-	int users;		/* Number of current users */
 	int mmap_count;		/* Number of current mmap's */
 };
 static struct image_desc image[VME_DEVS];
@@ -122,46 +121,6 @@ struct vme_user_vma_priv {
 };
 
 
-static int vme_user_open(struct inode *inode, struct file *file)
-{
-	int err;
-	unsigned int minor = MINOR(inode->i_rdev);
-
-	mutex_lock(&image[minor].mutex);
-	/* Allow device to be opened if a resource is needed and allocated. */
-	if (minor < CONTROL_MINOR && image[minor].resource == NULL) {
-		pr_err("No resources allocated for device\n");
-		err = -EINVAL;
-		goto err_res;
-	}
-
-	/* Increment user count */
-	image[minor].users++;
-
-	mutex_unlock(&image[minor].mutex);
-
-	return 0;
-
-err_res:
-	mutex_unlock(&image[minor].mutex);
-
-	return err;
-}
-
-static int vme_user_release(struct inode *inode, struct file *file)
-{
-	unsigned int minor = MINOR(inode->i_rdev);
-
-	mutex_lock(&image[minor].mutex);
-
-	/* Decrement user count */
-	image[minor].users--;
-
-	mutex_unlock(&image[minor].mutex);
-
-	return 0;
-}
-
 /*
  * We are going ot alloc a page during init per window for small transfers.
  * Small transfers will go VME -> buffer -> user space. Larger (more than a
@@ -596,8 +555,6 @@ static int vme_user_mmap(struct file *file, struct vm_area_struct *vma)
 }
 
 static const struct file_operations vme_user_fops = {
-	.open = vme_user_open,
-	.release = vme_user_release,
 	.read = vme_user_read,
 	.write = vme_user_write,
 	.llseek = vme_user_llseek,
@@ -670,7 +627,6 @@ static int vme_user_probe(struct vme_dev *vdev)
 		mutex_init(&image[i].mutex);
 		image[i].device = NULL;
 		image[i].resource = NULL;
-		image[i].users = 0;
 	}
 
 	/* Assign major and minor numbers for the driver */

commit e4aea6aa03267b496c21abefe170bb0d77192882
Author: Dmitry Kalinkin <dmitry.kalinkin@gmail.com>
Date:   Sat Jun 13 16:34:01 2015 +0300

    staging: vme_user: remove forward declarations
    
    Reorder code so that forward declarations are not needed.
    
    Signed-off-by: Dmitry Kalinkin <dmitry.kalinkin@gmail.com>
    Cc: Igor Alekseev <igor.alekseev@itep.ru>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vme/devices/vme_user.c b/drivers/staging/vme/devices/vme_user.c
index 449b8cd1dcb0..8e46d606d42a 100644
--- a/drivers/staging/vme/devices/vme_user.c
+++ b/drivers/staging/vme/devices/vme_user.c
@@ -116,44 +116,11 @@ static const int type[VME_DEVS] = {	MASTER_MINOR,	MASTER_MINOR,
 					CONTROL_MINOR
 				};
 
-
-static int vme_user_open(struct inode *, struct file *);
-static int vme_user_release(struct inode *, struct file *);
-static ssize_t vme_user_read(struct file *, char __user *, size_t, loff_t *);
-static ssize_t vme_user_write(struct file *, const char __user *, size_t,
-	loff_t *);
-static loff_t vme_user_llseek(struct file *, loff_t, int);
-static long vme_user_unlocked_ioctl(struct file *, unsigned int, unsigned long);
-static int vme_user_mmap(struct file *file, struct vm_area_struct *vma);
-
-static void vme_user_vm_open(struct vm_area_struct *vma);
-static void vme_user_vm_close(struct vm_area_struct *vma);
-
-static int vme_user_match(struct vme_dev *);
-static int vme_user_probe(struct vme_dev *);
-static int vme_user_remove(struct vme_dev *);
-
-static const struct file_operations vme_user_fops = {
-	.open = vme_user_open,
-	.release = vme_user_release,
-	.read = vme_user_read,
-	.write = vme_user_write,
-	.llseek = vme_user_llseek,
-	.unlocked_ioctl = vme_user_unlocked_ioctl,
-	.compat_ioctl = vme_user_unlocked_ioctl,
-	.mmap = vme_user_mmap,
-};
-
 struct vme_user_vma_priv {
 	unsigned int minor;
 	atomic_t refcnt;
 };
 
-static const struct vm_operations_struct vme_user_vm_ops = {
-	.open = vme_user_vm_open,
-	.close = vme_user_vm_close,
-};
-
 
 static int vme_user_open(struct inode *inode, struct file *file)
 {
@@ -582,6 +549,11 @@ static void vme_user_vm_close(struct vm_area_struct *vma)
 	kfree(vma_priv);
 }
 
+static const struct vm_operations_struct vme_user_vm_ops = {
+	.open = vme_user_vm_open,
+	.close = vme_user_vm_close,
+};
+
 static int vme_user_master_mmap(unsigned int minor, struct vm_area_struct *vma)
 {
 	int err;
@@ -623,6 +595,16 @@ static int vme_user_mmap(struct file *file, struct vm_area_struct *vma)
 	return -ENODEV;
 }
 
+static const struct file_operations vme_user_fops = {
+	.open = vme_user_open,
+	.release = vme_user_release,
+	.read = vme_user_read,
+	.write = vme_user_write,
+	.llseek = vme_user_llseek,
+	.unlocked_ioctl = vme_user_unlocked_ioctl,
+	.compat_ioctl = vme_user_unlocked_ioctl,
+	.mmap = vme_user_mmap,
+};
 
 /*
  * Unallocate a previously allocated buffer
@@ -649,52 +631,6 @@ static void buf_unalloc(int num)
 	}
 }
 
-static struct vme_driver vme_user_driver = {
-	.name = driver_name,
-	.match = vme_user_match,
-	.probe = vme_user_probe,
-	.remove = vme_user_remove,
-};
-
-
-static int __init vme_user_init(void)
-{
-	int retval = 0;
-
-	pr_info("VME User Space Access Driver\n");
-
-	if (bus_num == 0) {
-		pr_err("No cards, skipping registration\n");
-		retval = -ENODEV;
-		goto err_nocard;
-	}
-
-	/* Let's start by supporting one bus, we can support more than one
-	 * in future revisions if that ever becomes necessary.
-	 */
-	if (bus_num > VME_USER_BUS_MAX) {
-		pr_err("Driver only able to handle %d buses\n",
-		       VME_USER_BUS_MAX);
-		bus_num = VME_USER_BUS_MAX;
-	}
-
-	/*
-	 * Here we just register the maximum number of devices we can and
-	 * leave vme_user_match() to allow only 1 to go through to probe().
-	 * This way, if we later want to allow multiple user access devices,
-	 * we just change the code in vme_user_match().
-	 */
-	retval = vme_register_driver(&vme_user_driver, VME_MAX_SLOTS);
-	if (retval != 0)
-		goto err_reg;
-
-	return retval;
-
-err_reg:
-err_nocard:
-	return retval;
-}
-
 static int vme_user_match(struct vme_dev *vdev)
 {
 	int i;
@@ -916,6 +852,51 @@ static int vme_user_remove(struct vme_dev *dev)
 	return 0;
 }
 
+static struct vme_driver vme_user_driver = {
+	.name = driver_name,
+	.match = vme_user_match,
+	.probe = vme_user_probe,
+	.remove = vme_user_remove,
+};
+
+static int __init vme_user_init(void)
+{
+	int retval = 0;
+
+	pr_info("VME User Space Access Driver\n");
+
+	if (bus_num == 0) {
+		pr_err("No cards, skipping registration\n");
+		retval = -ENODEV;
+		goto err_nocard;
+	}
+
+	/* Let's start by supporting one bus, we can support more than one
+	 * in future revisions if that ever becomes necessary.
+	 */
+	if (bus_num > VME_USER_BUS_MAX) {
+		pr_err("Driver only able to handle %d buses\n",
+		       VME_USER_BUS_MAX);
+		bus_num = VME_USER_BUS_MAX;
+	}
+
+	/*
+	 * Here we just register the maximum number of devices we can and
+	 * leave vme_user_match() to allow only 1 to go through to probe().
+	 * This way, if we later want to allow multiple user access devices,
+	 * we just change the code in vme_user_match().
+	 */
+	retval = vme_register_driver(&vme_user_driver, VME_MAX_SLOTS);
+	if (retval != 0)
+		goto err_reg;
+
+	return retval;
+
+err_reg:
+err_nocard:
+	return retval;
+}
+
 static void __exit vme_user_exit(void)
 {
 	vme_unregister_driver(&vme_user_driver);

commit d884dd8c88e04958d809471781290b64f3d1a87a
Author: Dmitry Kalinkin <dmitry.kalinkin@gmail.com>
Date:   Thu May 28 15:07:08 2015 +0300

    staging: vme_user: remove unused counters
    
    Signed-off-by: Dmitry Kalinkin <dmitry.kalinkin@gmail.com>
    Cc: Igor Alekseev <igor.alekseev@itep.ru>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vme/devices/vme_user.c b/drivers/staging/vme/devices/vme_user.c
index da828f48b2ef..449b8cd1dcb0 100644
--- a/drivers/staging/vme/devices/vme_user.c
+++ b/drivers/staging/vme/devices/vme_user.c
@@ -104,18 +104,6 @@ struct image_desc {
 };
 static struct image_desc image[VME_DEVS];
 
-struct driver_stats {
-	unsigned long reads;
-	unsigned long writes;
-	unsigned long ioctls;
-	unsigned long irqs;
-	unsigned long berrs;
-	unsigned long dmaerrors;
-	unsigned long timeouts;
-	unsigned long external;
-};
-static struct driver_stats statistics;
-
 static struct cdev *vme_user_cdev;		/* Character device */
 static struct class *vme_user_sysfs_class;	/* Sysfs class */
 static struct vme_dev *vme_user_bridge;		/* Pointer to user device */
@@ -167,20 +155,6 @@ static const struct vm_operations_struct vme_user_vm_ops = {
 };
 
 
-/*
- * Reset all the statistic counters
- */
-static void reset_counters(void)
-{
-	statistics.reads = 0;
-	statistics.writes = 0;
-	statistics.ioctls = 0;
-	statistics.irqs = 0;
-	statistics.berrs = 0;
-	statistics.dmaerrors = 0;
-	statistics.timeouts = 0;
-}
-
 static int vme_user_open(struct inode *inode, struct file *file)
 {
 	int err;
@@ -465,8 +439,6 @@ static int vme_user_ioctl(struct inode *inode, struct file *file,
 	dma_addr_t pci_addr;
 	void __user *argp = (void __user *)arg;
 
-	statistics.ioctls++;
-
 	switch (type[minor]) {
 	case CONTROL_MINOR:
 		switch (cmd) {
@@ -765,9 +737,6 @@ static int vme_user_probe(struct vme_dev *vdev)
 		image[i].users = 0;
 	}
 
-	/* Initialise statistics counters */
-	reset_counters();
-
 	/* Assign major and minor numbers for the driver */
 	err = register_chrdev_region(MKDEV(VME_MAJOR, 0), VME_DEVS,
 		driver_name);

commit 615c40dd9f884add78cc3048167b59856d241fa3
Author: Dmitry Kalinkin <dmitry.kalinkin@gmail.com>
Date:   Thu May 28 15:07:02 2015 +0300

    staging: vme_user: refactor llseek to switch(){}
    
    This makes vme_user_llseek ignore all minors that don't have llseek
    implementation.
    
    Signed-off-by: Dmitry Kalinkin <dmitry.kalinkin@gmail.com>
    Cc: Igor Alekseev <igor.alekseev@itep.ru>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vme/devices/vme_user.c b/drivers/staging/vme/devices/vme_user.c
index 19ba749bb122..da828f48b2ef 100644
--- a/drivers/staging/vme/devices/vme_user.c
+++ b/drivers/staging/vme/devices/vme_user.c
@@ -430,15 +430,17 @@ static loff_t vme_user_llseek(struct file *file, loff_t off, int whence)
 	size_t image_size;
 	loff_t res;
 
-	if (minor == CONTROL_MINOR)
-		return -EINVAL;
-
-	mutex_lock(&image[minor].mutex);
-	image_size = vme_get_size(image[minor].resource);
-	res = fixed_size_llseek(file, off, whence, image_size);
-	mutex_unlock(&image[minor].mutex);
+	switch (type[minor]) {
+	case MASTER_MINOR:
+	case SLAVE_MINOR:
+		mutex_lock(&image[minor].mutex);
+		image_size = vme_get_size(image[minor].resource);
+		res = fixed_size_llseek(file, off, whence, image_size);
+		mutex_unlock(&image[minor].mutex);
+		return res;
+	}
 
-	return res;
+	return -EINVAL;
 }
 
 /*

commit c74a804f115bdedcac72ea52ca33f46cfae3b74f
Author: Dmitry Kalinkin <dmitry.kalinkin@gmail.com>
Date:   Thu Feb 26 18:53:10 2015 +0300

    staging: vme: mmap() support for vme_user
    
    We also make sure that user won't be able to reconfigure the window while it is
    mmap'ed.
    
    Signed-off-by: Dmitry Kalinkin <dmitry.kalinkin@gmail.com>
    Cc: Martyn Welch <martyn.welch@ge.com>
    Cc: Igor Alekseev <igor.alekseev@itep.ru>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vme/devices/vme_user.c b/drivers/staging/vme/devices/vme_user.c
index 87318386034b..19ba749bb122 100644
--- a/drivers/staging/vme/devices/vme_user.c
+++ b/drivers/staging/vme/devices/vme_user.c
@@ -17,6 +17,7 @@
 
 #define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
 
+#include <linux/atomic.h>
 #include <linux/cdev.h>
 #include <linux/delay.h>
 #include <linux/device.h>
@@ -99,6 +100,7 @@ struct image_desc {
 	struct device *device;	/* Sysfs device */
 	struct vme_resource *resource;	/* VME resource */
 	int users;		/* Number of current users */
+	int mmap_count;		/* Number of current mmap's */
 };
 static struct image_desc image[VME_DEVS];
 
@@ -134,6 +136,10 @@ static ssize_t vme_user_write(struct file *, const char __user *, size_t,
 	loff_t *);
 static loff_t vme_user_llseek(struct file *, loff_t, int);
 static long vme_user_unlocked_ioctl(struct file *, unsigned int, unsigned long);
+static int vme_user_mmap(struct file *file, struct vm_area_struct *vma);
+
+static void vme_user_vm_open(struct vm_area_struct *vma);
+static void vme_user_vm_close(struct vm_area_struct *vma);
 
 static int vme_user_match(struct vme_dev *);
 static int vme_user_probe(struct vme_dev *);
@@ -147,6 +153,17 @@ static const struct file_operations vme_user_fops = {
 	.llseek = vme_user_llseek,
 	.unlocked_ioctl = vme_user_unlocked_ioctl,
 	.compat_ioctl = vme_user_unlocked_ioctl,
+	.mmap = vme_user_mmap,
+};
+
+struct vme_user_vma_priv {
+	unsigned int minor;
+	atomic_t refcnt;
+};
+
+static const struct vm_operations_struct vme_user_vm_ops = {
+	.open = vme_user_vm_open,
+	.close = vme_user_vm_close,
 };
 
 
@@ -488,6 +505,11 @@ static int vme_user_ioctl(struct inode *inode, struct file *file,
 
 		case VME_SET_MASTER:
 
+			if (image[minor].mmap_count != 0) {
+				pr_warn("Can't adjust mapped window\n");
+				return -EPERM;
+			}
+
 			copied = copy_from_user(&master, argp, sizeof(master));
 			if (copied != 0) {
 				pr_warn("Partial copy from userspace\n");
@@ -564,6 +586,69 @@ vme_user_unlocked_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 	return ret;
 }
 
+static void vme_user_vm_open(struct vm_area_struct *vma)
+{
+	struct vme_user_vma_priv *vma_priv = vma->vm_private_data;
+
+	atomic_inc(&vma_priv->refcnt);
+}
+
+static void vme_user_vm_close(struct vm_area_struct *vma)
+{
+	struct vme_user_vma_priv *vma_priv = vma->vm_private_data;
+	unsigned int minor = vma_priv->minor;
+
+	if (!atomic_dec_and_test(&vma_priv->refcnt))
+		return;
+
+	mutex_lock(&image[minor].mutex);
+	image[minor].mmap_count--;
+	mutex_unlock(&image[minor].mutex);
+
+	kfree(vma_priv);
+}
+
+static int vme_user_master_mmap(unsigned int minor, struct vm_area_struct *vma)
+{
+	int err;
+	struct vme_user_vma_priv *vma_priv;
+
+	mutex_lock(&image[minor].mutex);
+
+	err = vme_master_mmap(image[minor].resource, vma);
+	if (err) {
+		mutex_unlock(&image[minor].mutex);
+		return err;
+	}
+
+	vma_priv = kmalloc(sizeof(struct vme_user_vma_priv), GFP_KERNEL);
+	if (vma_priv == NULL) {
+		mutex_unlock(&image[minor].mutex);
+		return -ENOMEM;
+	}
+
+	vma_priv->minor = minor;
+	atomic_set(&vma_priv->refcnt, 1);
+	vma->vm_ops = &vme_user_vm_ops;
+	vma->vm_private_data = vma_priv;
+
+	image[minor].mmap_count++;
+
+	mutex_unlock(&image[minor].mutex);
+
+	return 0;
+}
+
+static int vme_user_mmap(struct file *file, struct vm_area_struct *vma)
+{
+	unsigned int minor = MINOR(file_inode(file)->i_rdev);
+
+	if (type[minor] == MASTER_MINOR)
+		return vme_user_master_mmap(minor, vma);
+
+	return -ENODEV;
+}
+
 
 /*
  * Unallocate a previously allocated buffer

commit 0cd189a42da07c89c809debc1f6a75f5ec0f5c43
Author: Dmitry Kalinkin <dmitry.kalinkin@gmail.com>
Date:   Thu Feb 26 18:53:09 2015 +0300

    staging: vme: use image mutex for ioctl()
    
    This implements more granular locking in vme_user_ioctl() by using separate
    locks for each devfs device.
    
    This also provides a synchronization between vme_user_read(), vme_user_write()
    and vme_user_ioctl().
    
    Signed-off-by: Dmitry Kalinkin <dmitry.kalinkin@gmail.com>
    Cc: Martyn Welch <martyn.welch@ge.com>
    Cc: Igor Alekseev <igor.alekseev@itep.ru>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vme/devices/vme_user.c b/drivers/staging/vme/devices/vme_user.c
index 8b1f53331433..87318386034b 100644
--- a/drivers/staging/vme/devices/vme_user.c
+++ b/drivers/staging/vme/devices/vme_user.c
@@ -41,7 +41,6 @@
 
 #include "vme_user.h"
 
-static DEFINE_MUTEX(vme_user_mutex);
 static const char driver_name[] = "vme_user";
 
 static int bus[VME_USER_BUS_MAX];
@@ -555,10 +554,12 @@ static long
 vme_user_unlocked_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 {
 	int ret;
+	struct inode *inode = file_inode(file);
+	unsigned int minor = MINOR(inode->i_rdev);
 
-	mutex_lock(&vme_user_mutex);
-	ret = vme_user_ioctl(file_inode(file), file, cmd, arg);
-	mutex_unlock(&vme_user_mutex);
+	mutex_lock(&image[minor].mutex);
+	ret = vme_user_ioctl(inode, file, cmd, arg);
+	mutex_unlock(&image[minor].mutex);
 
 	return ret;
 }

commit 77c688ac87183537ed0fb84ec2cb8fa8ec97c458
Merge: 5e40d331bd72 a457606a6f81
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Oct 13 11:28:42 2014 +0200

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull vfs updates from Al Viro:
     "The big thing in this pile is Eric's unmount-on-rmdir series; we
      finally have everything we need for that.  The final piece of prereqs
      is delayed mntput() - now filesystem shutdown always happens on
      shallow stack.
    
      Other than that, we have several new primitives for iov_iter (Matt
      Wilcox, culled from his XIP-related series) pushing the conversion to
      ->read_iter()/ ->write_iter() a bit more, a bunch of fs/dcache.c
      cleanups and fixes (including the external name refcounting, which
      gives consistent behaviour of d_move() wrt procfs symlinks for long
      and short names alike) and assorted cleanups and fixes all over the
      place.
    
      This is just the first pile; there's a lot of stuff from various
      people that ought to go in this window.  Starting with
      unionmount/overlayfs mess...  ;-/"
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs: (60 commits)
      fs/file_table.c: Update alloc_file() comment
      vfs: Deduplicate code shared by xattr system calls operating on paths
      reiserfs: remove pointless forward declaration of struct nameidata
      don't need that forward declaration of struct nameidata in dcache.h anymore
      take dname_external() into fs/dcache.c
      let path_init() failures treated the same way as subsequent link_path_walk()
      fix misuses of f_count() in ppp and netlink
      ncpfs: use list_for_each_entry() for d_subdirs walk
      vfs: move getname() from callers to do_mount()
      gfs2_atomic_open(): skip lookups on hashed dentry
      [infiniband] remove pointless assignments
      gadgetfs: saner API for gadgetfs_create_file()
      f_fs: saner API for ffs_sb_create_file()
      jfs: don't hash direct inode
      [s390] remove pointless assignment of ->f_op in vmlogrdr ->open()
      ecryptfs: ->f_op is never NULL
      android: ->f_op is never NULL
      nouveau: __iomem misannotations
      missing annotation in fs/file.c
      fs: namespace: suppress 'may be used uninitialized' warnings
      ...

commit 594822918de20bf3a50afbc4de65b6f2971a92db
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Tue Aug 19 11:28:35 2014 -0400

    vme: don't open-code fixed_size_llseek()
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/drivers/staging/vme/devices/vme_user.c b/drivers/staging/vme/devices/vme_user.c
index 920e50addd3e..cdd2ff7999e9 100644
--- a/drivers/staging/vme/devices/vme_user.c
+++ b/drivers/staging/vme/devices/vme_user.c
@@ -410,41 +410,19 @@ static ssize_t vme_user_write(struct file *file, const char __user *buf,
 
 static loff_t vme_user_llseek(struct file *file, loff_t off, int whence)
 {
-	loff_t absolute = -1;
 	unsigned int minor = MINOR(file_inode(file)->i_rdev);
 	size_t image_size;
+	loff_t res;
 
 	if (minor == CONTROL_MINOR)
 		return -EINVAL;
 
 	mutex_lock(&image[minor].mutex);
 	image_size = vme_get_size(image[minor].resource);
-
-	switch (whence) {
-	case SEEK_SET:
-		absolute = off;
-		break;
-	case SEEK_CUR:
-		absolute = file->f_pos + off;
-		break;
-	case SEEK_END:
-		absolute = image_size + off;
-		break;
-	default:
-		mutex_unlock(&image[minor].mutex);
-		return -EINVAL;
-	}
-
-	if ((absolute < 0) || (absolute >= image_size)) {
-		mutex_unlock(&image[minor].mutex);
-		return -EINVAL;
-	}
-
-	file->f_pos = absolute;
-
+	res = fixed_size_llseek(file, off, whence, image_size);
 	mutex_unlock(&image[minor].mutex);
 
-	return absolute;
+	return res;
 }
 
 /*

commit fc489a528728dcce38df10a74cc1539522b670e7
Author: Mahati Chamarthy <mahati.chamarthy@gmail.com>
Date:   Mon Sep 22 23:04:13 2014 +0530

    Staging: vme: devices: Merges two lines of code and removes unused variable
    
    This patch merges an assignment with an immediately following return of
    the assigned variable.  The following Coccinelle semantic patch was used
    to make this transformation:
    
    @@
    expression ret;
    identifier f;
    @@
    
    -ret =
    +return
         f(...);
    -return ret;
    
    Signed-off-by: Mahati Chamarthy <mahati.chamarthy@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vme/devices/vme_user.c b/drivers/staging/vme/devices/vme_user.c
index 920e50addd3e..73cec14cbf56 100644
--- a/drivers/staging/vme/devices/vme_user.c
+++ b/drivers/staging/vme/devices/vme_user.c
@@ -482,11 +482,9 @@ static int vme_user_ioctl(struct inode *inode, struct file *file,
 				return -EFAULT;
 			}
 
-			retval = vme_irq_generate(vme_user_bridge,
+			return vme_irq_generate(vme_user_bridge,
 						  irq_req.level,
 						  irq_req.statid);
-
-			return retval;
 		}
 		break;
 	case MASTER_MINOR:

commit e20487e52be0cd26aefe3681362b4d3c4c3deb5a
Author: Tom Jorquera <tom.jorquera@gmail.com>
Date:   Wed Jul 23 18:17:58 2014 +0200

    staging: vme: removed useless breaks in vme_user.c
    
    vme_user.c contained unnecessary breaks after gotos, which increased
    code size and caused code style warning. This is now fixed.
    
    Signed-off-by: Tom Jorquera <tom.jorquera@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vme/devices/vme_user.c b/drivers/staging/vme/devices/vme_user.c
index 2d8497277aae..920e50addd3e 100644
--- a/drivers/staging/vme/devices/vme_user.c
+++ b/drivers/staging/vme/devices/vme_user.c
@@ -433,7 +433,6 @@ static loff_t vme_user_llseek(struct file *file, loff_t off, int whence)
 	default:
 		mutex_unlock(&image[minor].mutex);
 		return -EINVAL;
-		break;
 	}
 
 	if ((absolute < 0) || (absolute >= image_size)) {
@@ -511,7 +510,6 @@ static int vme_user_ioctl(struct inode *inode, struct file *file,
 			}
 
 			return retval;
-			break;
 
 		case VME_SET_MASTER:
 
@@ -552,7 +550,6 @@ static int vme_user_ioctl(struct inode *inode, struct file *file,
 			}
 
 			return retval;
-			break;
 
 		case VME_SET_SLAVE:
 
@@ -806,7 +803,6 @@ static int vme_user_probe(struct vme_dev *vdev)
 		default:
 			err = -EINVAL;
 			goto err_sysfs;
-			break;
 		}
 
 		num = (type[i] == SLAVE_MINOR) ? i - (MASTER_MAX + 1) : i;

commit 3eb9992caff10b62cf0ed0bcb1667a58b13188fa
Merge: e347fa5f4271 a798c10faf62
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Apr 22 10:08:40 2014 -0700

    Merge 3.15-rc2 into staging-next
    
    This resolves a bunch of merge errors with other fixes that are already
    in Linus's tree.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit f1552cbdc7d3cb42f3c9e88b2ad6cd5bfe90881a
Author: Bojan Prtvar <prtvar.b@gmail.com>
Date:   Thu Apr 3 18:56:10 2014 +0200

    staging: vme: Simplfy string usage in vme_user_probe()
    
    We can avoid usage of sprintf() and magic-sized array with simple pointer assignment.
    
    Signed-off-by: Bojan Prtvar <prtvar.b@gmail.com>
    Reviewed-by: wharms <wharms@bfs.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vme/devices/vme_user.c b/drivers/staging/vme/devices/vme_user.c
index 481192a2f4e2..5fa7f831dabd 100644
--- a/drivers/staging/vme/devices/vme_user.c
+++ b/drivers/staging/vme/devices/vme_user.c
@@ -684,7 +684,7 @@ static int vme_user_match(struct vme_dev *vdev)
 static int vme_user_probe(struct vme_dev *vdev)
 {
 	int i, err;
-	char name[12];
+	char *name;
 
 	/* Save pointer to the bridge device */
 	if (vme_user_bridge != NULL) {
@@ -794,13 +794,13 @@ static int vme_user_probe(struct vme_dev *vdev)
 
 		switch (type[i]) {
 		case MASTER_MINOR:
-			sprintf(name, "bus/vme/m%%d");
+			name = "bus/vme/m%d";
 			break;
 		case CONTROL_MINOR:
-			sprintf(name, "bus/vme/ctl");
+			name = "bus/vme/ctl";
 			break;
 		case SLAVE_MINOR:
-			sprintf(name, "bus/vme/s%%d");
+			name = "bus/vme/s%d";
 			break;
 		default:
 			err = -EINVAL;

commit 938acb99ce6c8883075c4c6e64409dd765bdb9e9
Author: Bojan Prtvar <prtvar.b@gmail.com>
Date:   Thu Apr 3 00:24:10 2014 +0200

    staging: vme: Fix a small coding style issue in vme_user.c
    
    The checkpatch.pl complains about missing blank line after declaration.
    This patch silence the warning.
    
    Signed-off-by: Bojan Prtvar <prtvar.b@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vme/devices/vme_user.c b/drivers/staging/vme/devices/vme_user.c
index 792792715673..481192a2f4e2 100644
--- a/drivers/staging/vme/devices/vme_user.c
+++ b/drivers/staging/vme/devices/vme_user.c
@@ -791,6 +791,7 @@ static int vme_user_probe(struct vme_dev *vdev)
 	/* Add sysfs Entries */
 	for (i = 0; i < VME_DEVS; i++) {
 		int num;
+
 		switch (type[i]) {
 		case MASTER_MINOR:
 			sprintf(name, "bus/vme/m%%d");

commit 1a52489318c16aaff71059b3892a1a2f3bb8ecec
Author: Daeseok Youn <daeseok.youn@gmail.com>
Date:   Wed Mar 26 12:01:48 2014 +0900

    staging: vme: fix memory leak in vme_user_probe()
    
    If vme_master_request() returns NULL when it failed,
    it need to free buffers for master.
    
    And also removes unreachable code in vme_user_probe().
    
    Signed-off-by: Daeseok Youn <daeseok.youn@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vme/devices/vme_user.c b/drivers/staging/vme/devices/vme_user.c
index 792792715673..ffb4eeefdddb 100644
--- a/drivers/staging/vme/devices/vme_user.c
+++ b/drivers/staging/vme/devices/vme_user.c
@@ -776,7 +776,8 @@ static int vme_user_probe(struct vme_dev *vdev)
 		image[i].kern_buf = kmalloc(image[i].size_buf, GFP_KERNEL);
 		if (image[i].kern_buf == NULL) {
 			err = -ENOMEM;
-			goto err_master_buf;
+			vme_master_free(image[i].resource);
+			goto err_master;
 		}
 	}
 
@@ -819,8 +820,6 @@ static int vme_user_probe(struct vme_dev *vdev)
 
 	return 0;
 
-	/* Ensure counter set correcty to destroy all sysfs devices */
-	i = VME_DEVS;
 err_sysfs:
 	while (i > 0) {
 		i--;
@@ -830,12 +829,10 @@ static int vme_user_probe(struct vme_dev *vdev)
 
 	/* Ensure counter set correcty to unalloc all master windows */
 	i = MASTER_MAX + 1;
-err_master_buf:
-	for (i = MASTER_MINOR; i < (MASTER_MAX + 1); i++)
-		kfree(image[i].kern_buf);
 err_master:
 	while (i > MASTER_MINOR) {
 		i--;
+		kfree(image[i].kern_buf);
 		vme_master_free(image[i].resource);
 	}
 

commit 89b1cc2dcb08cdfd7cf04593c135a399c1492c42
Author: Aaron Sierra <asierra@xes-inc.com>
Date:   Wed Dec 18 10:11:09 2013 -0600

    vme_user: Enable compat_ioctl for mixed environment
    
    Now that the VME userspace API structures compile to a consistent size
    in mixed environments (32-bit userspace and 64-bit kernel), enable the
    .compat_ioctl to allow ioctls to execute in this environment.
    
    Signed-off-by: Aaron Sierra <asierra@xes-inc.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vme/devices/vme_user.c b/drivers/staging/vme/devices/vme_user.c
index bc4f8623c8cc..792792715673 100644
--- a/drivers/staging/vme/devices/vme_user.c
+++ b/drivers/staging/vme/devices/vme_user.c
@@ -147,6 +147,7 @@ static const struct file_operations vme_user_fops = {
 	.write = vme_user_write,
 	.llseek = vme_user_llseek,
 	.unlocked_ioctl = vme_user_unlocked_ioctl,
+	.compat_ioctl = vme_user_unlocked_ioctl,
 };
 
 

commit d7729f0fc40296f91b483dfb929e71b27cf75345
Author: Martyn Welch <martyn.welch@ge.com>
Date:   Fri Nov 8 11:58:35 2013 +0000

    VME: Rename vme_slot_get to avoid confusion with reference counting
    
    Traditionally the "get" functions increment the reference count of the
    object that is returned, which does not happen with vme_slot_get. The
    function vme_slot_get returns the physical VME slot associated with a
    particular struct vme_dev. Rename vme_slot_num to avoid any confusion.
    
    Signed-off-by: Martyn Welch <martyn.welch@ge.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vme/devices/vme_user.c b/drivers/staging/vme/devices/vme_user.c
index caee906f9b38..bc4f8623c8cc 100644
--- a/drivers/staging/vme/devices/vme_user.c
+++ b/drivers/staging/vme/devices/vme_user.c
@@ -666,7 +666,7 @@ static int vme_user_match(struct vme_dev *vdev)
 	int i;
 
 	int cur_bus = vme_bus_num(vdev);
-	int cur_slot = vme_slot_get(vdev);
+	int cur_slot = vme_slot_num(vdev);
 
 	for (i = 0; i < bus_num; i++)
 		if ((cur_bus == bus[i]) && (cur_slot == vdev->num))

commit 978f47d64365fa1659178e54c5106154c315b595
Author: Martyn Welch <martyn.welch@ge.com>
Date:   Fri Nov 8 11:58:34 2013 +0000

    VME: Provide access to VME bus enumeration and fix vme_user match function
    
    The match function for vme_user is completely wrong. It will blindly bind
    against the first VME slot on each bus (at this point that would be just the
    first bus as the driver can only handle one bus).
    
    The original intention (before some major subsystem changes) was that the
    driver bind against the slot to which the bridge was attached in the VME
    system and to the bus(es) provided via the "bus" module parameter.
    
    To do this cleanly (i.e. without poking arround in the subsystems internal
    stuctures) a functionality has been added to provide access to the bus
    enumeration.
    
    Signed-off-by: Martyn Welch <martyn.welch@ge.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vme/devices/vme_user.c b/drivers/staging/vme/devices/vme_user.c
index daec15565a43..caee906f9b38 100644
--- a/drivers/staging/vme/devices/vme_user.c
+++ b/drivers/staging/vme/devices/vme_user.c
@@ -663,9 +663,16 @@ static int __init vme_user_init(void)
 
 static int vme_user_match(struct vme_dev *vdev)
 {
-	if (vdev->num >= VME_USER_BUS_MAX)
-		return 0;
-	return 1;
+	int i;
+
+	int cur_bus = vme_bus_num(vdev);
+	int cur_slot = vme_slot_get(vdev);
+
+	for (i = 0; i < bus_num; i++)
+		if ((cur_bus == bus[i]) && (cur_slot == vdev->num))
+			return 1;
+
+	return 0;
 }
 
 /*

commit 465ff28db720d99d885ee9cd70af487745ea4a5a
Author: Wei Yongjun <yongjun_wei@trendmicro.com.cn>
Date:   Mon May 13 14:05:38 2013 +0800

    staging: vme: fix error return code in vme_user_probe()
    
    Fix to return -ENOMEM in the resource alloc error handling
    case instead of 0, as done elsewhere in this function.
    
    Signed-off-by: Wei Yongjun <yongjun_wei@trendmicro.com.cn>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vme/devices/vme_user.c b/drivers/staging/vme/devices/vme_user.c
index cf2148e8e5c4..daec15565a43 100644
--- a/drivers/staging/vme/devices/vme_user.c
+++ b/drivers/staging/vme/devices/vme_user.c
@@ -734,6 +734,7 @@ static int vme_user_probe(struct vme_dev *vdev)
 		if (image[i].resource == NULL) {
 			dev_warn(&vdev->dev,
 				 "Unable to allocate slave resource\n");
+			err = -ENOMEM;
 			goto err_slave;
 		}
 		image[i].size_buf = PCI_BUF_SIZE;
@@ -760,6 +761,7 @@ static int vme_user_probe(struct vme_dev *vdev)
 		if (image[i].resource == NULL) {
 			dev_warn(&vdev->dev,
 				 "Unable to allocate master resource\n");
+			err = -ENOMEM;
 			goto err_master;
 		}
 		image[i].size_buf = PCI_BUF_SIZE;

commit f827c165b0e6ba1898317ae9ebae87855d386a2c
Author: Lisa Nguyen <lisa@xenapiadmin.com>
Date:   Mon May 6 13:04:30 2013 -0700

    vme/devices: Fixed camel-case variable names
    
    Fixed camel-case variable names in vme_user.c and vme_user.h.
    
    Signed-off-by: Lisa Nguyen <lisa@xenapiadmin.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vme/devices/vme_user.c b/drivers/staging/vme/devices/vme_user.c
index da7f75984979..cf2148e8e5c4 100644
--- a/drivers/staging/vme/devices/vme_user.c
+++ b/drivers/staging/vme/devices/vme_user.c
@@ -109,7 +109,7 @@ struct driver_stats {
 	unsigned long ioctls;
 	unsigned long irqs;
 	unsigned long berrs;
-	unsigned long dmaErrors;
+	unsigned long dmaerrors;
 	unsigned long timeouts;
 	unsigned long external;
 };
@@ -160,7 +160,7 @@ static void reset_counters(void)
 	statistics.ioctls = 0;
 	statistics.irqs = 0;
 	statistics.berrs = 0;
-	statistics.dmaErrors = 0;
+	statistics.dmaerrors = 0;
 	statistics.timeouts = 0;
 }
 

commit d4113a69bc9ca518f492b2ad7d2d586cd2ca5803
Author: Kumar Amit Mehta <gmate.amit@gmail.com>
Date:   Sun Mar 24 22:37:48 2013 -0700

    staging: vme: fix for a potential NULL pointer dereference
    
    Audit the return value of cdev_alloc and hence fixes a potential NULL pointer
    dereferencing.
    
    Signed-off-by: Kumar Amit Mehta <gmate.amit@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vme/devices/vme_user.c b/drivers/staging/vme/devices/vme_user.c
index d074b1ecb41a..da7f75984979 100644
--- a/drivers/staging/vme/devices/vme_user.c
+++ b/drivers/staging/vme/devices/vme_user.c
@@ -710,6 +710,10 @@ static int vme_user_probe(struct vme_dev *vdev)
 
 	/* Register the driver as a char device */
 	vme_user_cdev = cdev_alloc();
+	if (!vme_user_cdev) {
+		err = -ENOMEM;
+		goto err_char;
+	}
 	vme_user_cdev->ops = &vme_user_fops;
 	vme_user_cdev->owner = THIS_MODULE;
 	err = cdev_add(vme_user_cdev, MKDEV(VME_MAJOR, 0), VME_DEVS);

commit d895cb1af15c04c522a25c79cc429076987c089b
Merge: 9626357371b5 d3d009cb965e
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Feb 26 20:16:07 2013 -0800

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull vfs pile (part one) from Al Viro:
     "Assorted stuff - cleaning namei.c up a bit, fixing ->d_name/->d_parent
      locking violations, etc.
    
      The most visible changes here are death of FS_REVAL_DOT (replaced with
      "has ->d_weak_revalidate()") and a new helper getting from struct file
      to inode.  Some bits of preparation to xattr method interface changes.
    
      Misc patches by various people sent this cycle *and* ocfs2 fixes from
      several cycles ago that should've been upstream right then.
    
      PS: the next vfs pile will be xattr stuff."
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs: (46 commits)
      saner proc_get_inode() calling conventions
      proc: avoid extra pde_put() in proc_fill_super()
      fs: change return values from -EACCES to -EPERM
      fs/exec.c: make bprm_mm_init() static
      ocfs2/dlm: use GFP_ATOMIC inside a spin_lock
      ocfs2: fix possible use-after-free with AIO
      ocfs2: Fix oops in ocfs2_fast_symlink_readpage() code path
      get_empty_filp()/alloc_file() leave both ->f_pos and ->f_version zero
      target: writev() on single-element vector is pointless
      export kernel_write(), convert open-coded instances
      fs: encode_fh: return FILEID_INVALID if invalid fid_type
      kill f_vfsmnt
      vfs: kill FS_REVAL_DOT by adding a d_weak_revalidate dentry op
      nfsd: handle vfs_getattr errors in acl protocol
      switch vfs_getattr() to struct path
      default SET_PERSONALITY() in linux/elf.h
      ceph: prepopulate inodes only when request is aborted
      d_hash_and_lookup(): export, switch open-coded instances
      9p: switch v9fs_set_create_acl() to inode+fid, do it before d_instantiate()
      9p: split dropping the acls from v9fs_set_create_acl()
      ...

commit 496ad9aa8ef448058e36ca7a787c61f2e63f0f54
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Wed Jan 23 17:07:38 2013 -0500

    new helper: file_inode(file)
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/drivers/staging/vme/devices/vme_user.c b/drivers/staging/vme/devices/vme_user.c
index 4ef852c4c4e1..869ce93ee204 100644
--- a/drivers/staging/vme/devices/vme_user.c
+++ b/drivers/staging/vme/devices/vme_user.c
@@ -318,7 +318,7 @@ static ssize_t buffer_from_user(unsigned int minor, const char __user *buf,
 static ssize_t vme_user_read(struct file *file, char __user *buf, size_t count,
 			loff_t *ppos)
 {
-	unsigned int minor = MINOR(file->f_dentry->d_inode->i_rdev);
+	unsigned int minor = MINOR(file_inode(file)->i_rdev);
 	ssize_t retval;
 	size_t image_size;
 	size_t okcount;
@@ -364,7 +364,7 @@ static ssize_t vme_user_read(struct file *file, char __user *buf, size_t count,
 static ssize_t vme_user_write(struct file *file, const char __user *buf,
 			size_t count, loff_t *ppos)
 {
-	unsigned int minor = MINOR(file->f_dentry->d_inode->i_rdev);
+	unsigned int minor = MINOR(file_inode(file)->i_rdev);
 	ssize_t retval;
 	size_t image_size;
 	size_t okcount;
@@ -410,7 +410,7 @@ static ssize_t vme_user_write(struct file *file, const char __user *buf,
 static loff_t vme_user_llseek(struct file *file, loff_t off, int whence)
 {
 	loff_t absolute = -1;
-	unsigned int minor = MINOR(file->f_dentry->d_inode->i_rdev);
+	unsigned int minor = MINOR(file_inode(file)->i_rdev);
 	size_t image_size;
 
 	if (minor == CONTROL_MINOR)
@@ -583,7 +583,7 @@ vme_user_unlocked_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 	int ret;
 
 	mutex_lock(&vme_user_mutex);
-	ret = vme_user_ioctl(file->f_path.dentry->d_inode, file, cmd, arg);
+	ret = vme_user_ioctl(file_inode(file), file, cmd, arg);
 	mutex_unlock(&vme_user_mutex);
 
 	return ret;

commit 78110bb8dc4a7ff331bfa3cfe7d4e287cfb3f22b
Author: Joe Perches <joe@perches.com>
Date:   Mon Feb 11 09:41:29 2013 -0800

    staging: Remove unnecessary OOM messages
    
    alloc failures already get standardized OOM
    messages and a dump_stack.
    
    For the affected mallocs around these OOM messages:
    
    Converted kzallocs with multiplies to kcalloc.
    Converted kmallocs with multiplies to kmalloc_array.
    Converted a kmalloc/strlen/strncpy to kstrdup.
    Moved a spin_lock below a removed OOM message and
    removed a now unnecessary spin_unlock.
    Neatened alignment and whitespace.
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vme/devices/vme_user.c b/drivers/staging/vme/devices/vme_user.c
index 4ef852c4c4e1..57474cff51f0 100644
--- a/drivers/staging/vme/devices/vme_user.c
+++ b/drivers/staging/vme/devices/vme_user.c
@@ -761,8 +761,6 @@ static int vme_user_probe(struct vme_dev *vdev)
 		image[i].size_buf = PCI_BUF_SIZE;
 		image[i].kern_buf = kmalloc(image[i].size_buf, GFP_KERNEL);
 		if (image[i].kern_buf == NULL) {
-			dev_warn(&vdev->dev,
-				 "Unable to allocate memory for master window buffers\n");
 			err = -ENOMEM;
 			goto err_master_buf;
 		}

commit f21a8247641329c40ab17b2d70c492c060bb3573
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Nov 19 13:26:52 2012 -0500

    staging: vme: remove use of __devexit
    
    CONFIG_HOTPLUG is going away as an option so __devexit is no
    longer needed.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Cc: Martyn Welch <martyn.welch@ge.com>
    Cc: Manohar Vanga <manohar.vanga@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vme/devices/vme_user.c b/drivers/staging/vme/devices/vme_user.c
index e36211056272..4ef852c4c4e1 100644
--- a/drivers/staging/vme/devices/vme_user.c
+++ b/drivers/staging/vme/devices/vme_user.c
@@ -138,7 +138,7 @@ static long vme_user_unlocked_ioctl(struct file *, unsigned int, unsigned long);
 
 static int vme_user_match(struct vme_dev *);
 static int vme_user_probe(struct vme_dev *);
-static int __devexit vme_user_remove(struct vme_dev *);
+static int vme_user_remove(struct vme_dev *);
 
 static const struct file_operations vme_user_fops = {
 	.open = vme_user_open,
@@ -846,7 +846,7 @@ static int vme_user_probe(struct vme_dev *vdev)
 	return err;
 }
 
-static int __devexit vme_user_remove(struct vme_dev *dev)
+static int vme_user_remove(struct vme_dev *dev)
 {
 	int i;
 

commit d7e530d26ba3dc59753e0d0b04fecdbb1f394c38
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Nov 19 13:21:56 2012 -0500

    staging: vme: remove use of __devinit
    
    CONFIG_HOTPLUG is going away as an option so __devinit is no longer
    needed.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Cc: Martyn Welch <martyn.welch@ge.com>
    Cc: Manohar Vanga <manohar.vanga@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vme/devices/vme_user.c b/drivers/staging/vme/devices/vme_user.c
index 8209c2d3c151..e36211056272 100644
--- a/drivers/staging/vme/devices/vme_user.c
+++ b/drivers/staging/vme/devices/vme_user.c
@@ -137,7 +137,7 @@ static loff_t vme_user_llseek(struct file *, loff_t, int);
 static long vme_user_unlocked_ioctl(struct file *, unsigned int, unsigned long);
 
 static int vme_user_match(struct vme_dev *);
-static int __devinit vme_user_probe(struct vme_dev *);
+static int vme_user_probe(struct vme_dev *);
 static int __devexit vme_user_remove(struct vme_dev *);
 
 static const struct file_operations vme_user_fops = {
@@ -673,7 +673,7 @@ static int vme_user_match(struct vme_dev *vdev)
  * as practical. We will therefore reserve the buffers and request the images
  * here so that we don't have to do it later.
  */
-static int __devinit vme_user_probe(struct vme_dev *vdev)
+static int vme_user_probe(struct vme_dev *vdev)
 {
 	int i, err;
 	char name[12];

commit 38930755b86082b8d44da038d0ec0b912a708679
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Nov 19 13:21:03 2012 -0500

    staging: vme: remove use of __devexit_p
    
    CONFIG_HOTPLUG is going away as an option so __devexit_p is no longer
    needed.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Cc: Martyn Welch <martyn.welch@ge.com>
    Cc: Manohar Vanga <manohar.vanga@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vme/devices/vme_user.c b/drivers/staging/vme/devices/vme_user.c
index e3731eb2bab1..8209c2d3c151 100644
--- a/drivers/staging/vme/devices/vme_user.c
+++ b/drivers/staging/vme/devices/vme_user.c
@@ -619,7 +619,7 @@ static struct vme_driver vme_user_driver = {
 	.name = driver_name,
 	.match = vme_user_match,
 	.probe = vme_user_probe,
-	.remove = __devexit_p(vme_user_remove),
+	.remove = vme_user_remove,
 };
 
 

commit 0093e5f8b3959aec933ff3d3334fc880d7600b22
Author: YAMANE Toshiaki <yamanetoshi@gmail.com>
Date:   Fri Nov 9 12:23:14 2012 +0900

    staging/vme: Use dev_ or pr_ printks in devices/vme_user.c
    
    fixed below checkpatch warnings.
    - WARNING: Prefer netdev_err(netdev, ... then dev_err(dev, ... then pr_err(...  to printk(KERN_ERR ...
    - WARNING: Prefer netdev_info(netdev, ... then dev_info(dev, ... then pr_info(...  to printk(KERN_INFO ...
    - WARNING: Prefer netdev_dbg(netdev, ... then dev_dbg(dev, ... then pr_debug(...  to printk(KERN_DEBUG ...
    - WARNING: Prefer netdev_warn(netdev, ... then dev_warn(dev, ... then pr_warn(...  to printk(KERN_WARNING ...
    
    and add pr_fmt.
    
    Signed-off-by: YAMANE Toshiaki <yamanetoshi@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vme/devices/vme_user.c b/drivers/staging/vme/devices/vme_user.c
index c3f94f311ca7..e3731eb2bab1 100644
--- a/drivers/staging/vme/devices/vme_user.c
+++ b/drivers/staging/vme/devices/vme_user.c
@@ -15,6 +15,8 @@
  * option) any later version.
  */
 
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+
 #include <linux/cdev.h>
 #include <linux/delay.h>
 #include <linux/device.h>
@@ -170,7 +172,7 @@ static int vme_user_open(struct inode *inode, struct file *file)
 	mutex_lock(&image[minor].mutex);
 	/* Allow device to be opened if a resource is needed and allocated. */
 	if (minor < CONTROL_MINOR && image[minor].resource == NULL) {
-		printk(KERN_ERR "No resources allocated for device\n");
+		pr_err("No resources allocated for device\n");
 		err = -EINVAL;
 		goto err_res;
 	}
@@ -225,13 +227,13 @@ static ssize_t resource_to_user(int minor, char __user *buf, size_t count,
 			(unsigned long)copied);
 		if (retval != 0) {
 			copied = (copied - retval);
-			printk(KERN_INFO "User copy failed\n");
+			pr_info("User copy failed\n");
 			return -EINVAL;
 		}
 
 	} else {
 		/* XXX Need to write this */
-		printk(KERN_INFO "Currently don't support large transfers\n");
+		pr_info("Currently don't support large transfers\n");
 		/* Map in pages from userspace */
 
 		/* Call vme_master_read to do the transfer */
@@ -265,7 +267,7 @@ static ssize_t resource_from_user(unsigned int minor, const char __user *buf,
 			image[minor].kern_buf, copied, *ppos);
 	} else {
 		/* XXX Need to write this */
-		printk(KERN_INFO "Currently don't support large transfers\n");
+		pr_info("Currently don't support large transfers\n");
 		/* Map in pages from userspace */
 
 		/* Call vme_master_write to do the transfer */
@@ -286,7 +288,7 @@ static ssize_t buffer_to_user(unsigned int minor, char __user *buf,
 	retval = __copy_to_user(buf, image_ptr, (unsigned long)count);
 	if (retval != 0) {
 		retval = (count - retval);
-		printk(KERN_WARNING "Partial copy to userspace\n");
+		pr_warn("Partial copy to userspace\n");
 	} else
 		retval = count;
 
@@ -305,7 +307,7 @@ static ssize_t buffer_from_user(unsigned int minor, const char __user *buf,
 	retval = __copy_from_user(image_ptr, buf, (unsigned long)count);
 	if (retval != 0) {
 		retval = (count - retval);
-		printk(KERN_WARNING "Partial copy to userspace\n");
+		pr_warn("Partial copy to userspace\n");
 	} else
 		retval = count;
 
@@ -476,7 +478,7 @@ static int vme_user_ioctl(struct inode *inode, struct file *file,
 			copied = copy_from_user(&irq_req, argp,
 						sizeof(struct vme_irq_id));
 			if (copied != 0) {
-				printk(KERN_WARNING "Partial copy from userspace\n");
+				pr_warn("Partial copy from userspace\n");
 				return -EFAULT;
 			}
 
@@ -503,8 +505,7 @@ static int vme_user_ioctl(struct inode *inode, struct file *file,
 			copied = copy_to_user(argp, &master,
 				sizeof(struct vme_master));
 			if (copied != 0) {
-				printk(KERN_WARNING "Partial copy to "
-					"userspace\n");
+				pr_warn("Partial copy to userspace\n");
 				return -EFAULT;
 			}
 
@@ -515,8 +516,7 @@ static int vme_user_ioctl(struct inode *inode, struct file *file,
 
 			copied = copy_from_user(&master, argp, sizeof(master));
 			if (copied != 0) {
-				printk(KERN_WARNING "Partial copy from "
-					"userspace\n");
+				pr_warn("Partial copy from userspace\n");
 				return -EFAULT;
 			}
 
@@ -546,8 +546,7 @@ static int vme_user_ioctl(struct inode *inode, struct file *file,
 			copied = copy_to_user(argp, &slave,
 				sizeof(struct vme_slave));
 			if (copied != 0) {
-				printk(KERN_WARNING "Partial copy to "
-					"userspace\n");
+				pr_warn("Partial copy to userspace\n");
 				return -EFAULT;
 			}
 
@@ -558,8 +557,7 @@ static int vme_user_ioctl(struct inode *inode, struct file *file,
 
 			copied = copy_from_user(&slave, argp, sizeof(slave));
 			if (copied != 0) {
-				printk(KERN_WARNING "Partial copy from "
-					"userspace\n");
+				pr_warn("Partial copy from userspace\n");
 				return -EFAULT;
 			}
 
@@ -599,8 +597,8 @@ static void buf_unalloc(int num)
 {
 	if (image[num].kern_buf) {
 #ifdef VME_DEBUG
-		printk(KERN_DEBUG "UniverseII:Releasing buffer at %p\n",
-			image[num].pci_buf);
+		pr_debug("UniverseII:Releasing buffer at %p\n",
+			 image[num].pci_buf);
 #endif
 
 		vme_free_consistent(image[num].resource, image[num].size_buf,
@@ -612,7 +610,7 @@ static void buf_unalloc(int num)
 
 #ifdef VME_DEBUG
 	} else {
-		printk(KERN_DEBUG "UniverseII: Buffer not allocated\n");
+		pr_debug("UniverseII: Buffer not allocated\n");
 #endif
 	}
 }
@@ -629,11 +627,10 @@ static int __init vme_user_init(void)
 {
 	int retval = 0;
 
-	printk(KERN_INFO "VME User Space Access Driver\n");
+	pr_info("VME User Space Access Driver\n");
 
 	if (bus_num == 0) {
-		printk(KERN_ERR "%s: No cards, skipping registration\n",
-			driver_name);
+		pr_err("No cards, skipping registration\n");
 		retval = -ENODEV;
 		goto err_nocard;
 	}
@@ -642,8 +639,8 @@ static int __init vme_user_init(void)
 	 * in future revisions if that ever becomes necessary.
 	 */
 	if (bus_num > VME_USER_BUS_MAX) {
-		printk(KERN_ERR "%s: Driver only able to handle %d buses\n",
-			driver_name, VME_USER_BUS_MAX);
+		pr_err("Driver only able to handle %d buses\n",
+		       VME_USER_BUS_MAX);
 		bus_num = VME_USER_BUS_MAX;
 	}
 
@@ -683,8 +680,7 @@ static int __devinit vme_user_probe(struct vme_dev *vdev)
 
 	/* Save pointer to the bridge device */
 	if (vme_user_bridge != NULL) {
-		printk(KERN_ERR "%s: Driver can only be loaded for 1 device\n",
-			driver_name);
+		dev_err(&vdev->dev, "Driver can only be loaded for 1 device\n");
 		err = -EINVAL;
 		goto err_dev;
 	}
@@ -707,8 +703,8 @@ static int __devinit vme_user_probe(struct vme_dev *vdev)
 	err = register_chrdev_region(MKDEV(VME_MAJOR, 0), VME_DEVS,
 		driver_name);
 	if (err) {
-		printk(KERN_WARNING "%s: Error getting Major Number %d for "
-		"driver.\n", driver_name, VME_MAJOR);
+		dev_warn(&vdev->dev, "Error getting Major Number %d for driver.\n",
+			 VME_MAJOR);
 		goto err_region;
 	}
 
@@ -718,7 +714,7 @@ static int __devinit vme_user_probe(struct vme_dev *vdev)
 	vme_user_cdev->owner = THIS_MODULE;
 	err = cdev_add(vme_user_cdev, MKDEV(VME_MAJOR, 0), VME_DEVS);
 	if (err) {
-		printk(KERN_WARNING "%s: cdev_all failed\n", driver_name);
+		dev_warn(&vdev->dev, "cdev_all failed\n");
 		goto err_char;
 	}
 
@@ -732,16 +728,16 @@ static int __devinit vme_user_probe(struct vme_dev *vdev)
 		image[i].resource = vme_slave_request(vme_user_bridge,
 			VME_A24, VME_SCT);
 		if (image[i].resource == NULL) {
-			printk(KERN_WARNING "Unable to allocate slave "
-				"resource\n");
+			dev_warn(&vdev->dev,
+				 "Unable to allocate slave resource\n");
 			goto err_slave;
 		}
 		image[i].size_buf = PCI_BUF_SIZE;
 		image[i].kern_buf = vme_alloc_consistent(image[i].resource,
 			image[i].size_buf, &image[i].pci_buf);
 		if (image[i].kern_buf == NULL) {
-			printk(KERN_WARNING "Unable to allocate memory for "
-				"buffer\n");
+			dev_warn(&vdev->dev,
+				 "Unable to allocate memory for buffer\n");
 			image[i].pci_buf = 0;
 			vme_slave_free(image[i].resource);
 			err = -ENOMEM;
@@ -758,15 +754,15 @@ static int __devinit vme_user_probe(struct vme_dev *vdev)
 		image[i].resource = vme_master_request(vme_user_bridge,
 			VME_A32, VME_SCT, VME_D32);
 		if (image[i].resource == NULL) {
-			printk(KERN_WARNING "Unable to allocate master "
-				"resource\n");
+			dev_warn(&vdev->dev,
+				 "Unable to allocate master resource\n");
 			goto err_master;
 		}
 		image[i].size_buf = PCI_BUF_SIZE;
 		image[i].kern_buf = kmalloc(image[i].size_buf, GFP_KERNEL);
 		if (image[i].kern_buf == NULL) {
-			printk(KERN_WARNING "Unable to allocate memory for "
-				"master window buffers\n");
+			dev_warn(&vdev->dev,
+				 "Unable to allocate memory for master window buffers\n");
 			err = -ENOMEM;
 			goto err_master_buf;
 		}
@@ -775,7 +771,7 @@ static int __devinit vme_user_probe(struct vme_dev *vdev)
 	/* Create sysfs entries - on udev systems this creates the dev files */
 	vme_user_sysfs_class = class_create(THIS_MODULE, driver_name);
 	if (IS_ERR(vme_user_sysfs_class)) {
-		printk(KERN_ERR "Error creating vme_user class.\n");
+		dev_err(&vdev->dev, "Error creating vme_user class.\n");
 		err = PTR_ERR(vme_user_sysfs_class);
 		goto err_class;
 	}
@@ -803,8 +799,7 @@ static int __devinit vme_user_probe(struct vme_dev *vdev)
 		image[i].device = device_create(vme_user_sysfs_class, NULL,
 					MKDEV(VME_MAJOR, i), NULL, name, num);
 		if (IS_ERR(image[i].device)) {
-			printk(KERN_INFO "%s: Error creating sysfs device\n",
-				driver_name);
+			dev_info(&vdev->dev, "Error creating sysfs device\n");
 			err = PTR_ERR(image[i].device);
 			goto err_sysfs;
 		}

commit 538a697ac8ca86b4507aaf81cfed5359aa11d606
Author: Toshiaki Yamane <yamanetoshi@gmail.com>
Date:   Tue Aug 21 20:12:33 2012 +0900

    Staging: vme: Fix a white space issue
    
    The below checkpatch error was fixed.
    
    -ERROR: trailing whitespace
    
    Signed-off-by: Toshiaki Yamane <yamanetoshi@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vme/devices/vme_user.c b/drivers/staging/vme/devices/vme_user.c
index 0170788fcdee..c3f94f311ca7 100644
--- a/drivers/staging/vme/devices/vme_user.c
+++ b/drivers/staging/vme/devices/vme_user.c
@@ -396,7 +396,7 @@ static ssize_t vme_user_write(struct file *file, const char __user *buf,
 	default:
 		retval = -EINVAL;
 	}
-	
+
 	mutex_unlock(&image[minor].mutex);
 
 	if (retval > 0)

commit 95605332997211f377af55d05209c3ef2b86bed1
Author: Justin P. Mattock <justinmattock@gmail.com>
Date:   Mon Aug 13 10:28:22 2012 -0700

    staging "vme" Fix typos.
    
    Signed-off-by: Justin P. Mattock <justinmattock@gmail.com>
    Acked-by: Martyn Welch <martyn.welch@ge.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vme/devices/vme_user.c b/drivers/staging/vme/devices/vme_user.c
index e25645e226e3..0170788fcdee 100644
--- a/drivers/staging/vme/devices/vme_user.c
+++ b/drivers/staging/vme/devices/vme_user.c
@@ -64,13 +64,13 @@ static unsigned int bus_num;
  *
  * However the VME driver at http://www.vmelinux.org/ is rather old and doesn't
  * even support the tsi148 chipset (which has 8 master and 8 slave windows).
- * We'll run with this or now as far as possible, however it probably makes
+ * We'll run with this for now as far as possible, however it probably makes
  * sense to get rid of the old mappings and just do everything dynamically.
  *
  * So for now, we'll restrict the driver to providing 4 masters and 4 slaves as
  * defined above and try to support at least some of the interface from
- * http://www.vmelinux.org/ as an alternative drive can be written providing a
- * saner interface later.
+ * http://www.vmelinux.org/ as an alternative the driver can be written
+ * providing a saner interface later.
  *
  * The vmelinux.org driver never supported slave images, the devices reserved
  * for slaves were repurposed to support all 8 master images on the UniverseII!
@@ -242,7 +242,7 @@ static ssize_t resource_to_user(int minor, char __user *buf, size_t count,
 }
 
 /*
- * We are going ot alloc a page during init per window for small transfers.
+ * We are going to alloc a page during init per window for small transfers.
  * Small transfers will go user space -> buffer -> VME. Larger (more than a
  * page) transfers will lock the user space buffer into memory and then
  * transfer the data directly from the user space buffers out to VME.

commit be408d7807ea2de36471ceb35cd4bd503118beaf
Author: Duan Jiong <djduanjiong@gmail.com>
Date:   Wed Jul 18 22:25:39 2012 +0800

    vme_user.c: remove duplicated include
    
    Signed-off-by: Duan Jiong <djduanjiong@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vme/devices/vme_user.c b/drivers/staging/vme/devices/vme_user.c
index 0c2479e41938..e25645e226e3 100644
--- a/drivers/staging/vme/devices/vme_user.c
+++ b/drivers/staging/vme/devices/vme_user.c
@@ -31,7 +31,6 @@
 #include <linux/slab.h>
 #include <linux/spinlock.h>
 #include <linux/syscalls.h>
-#include <linux/mutex.h>
 #include <linux/types.h>
 
 #include <linux/io.h>

commit a7f3943cd055f73e82e1b57468286f3d7cf9fb27
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Fri Jul 6 11:21:49 2012 +0300

    Staging: vme: silence a Sparse warning
    
    Sparse complains that "arg" is not a __user pointer.  The "argp" and
    "arg" variables are equivalent but argp is declared as a __user pointer.
    
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Acked-By: Martyn Welch <martyn.welch@ge.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vme/devices/vme_user.c b/drivers/staging/vme/devices/vme_user.c
index e24a6f95db12..0c2479e41938 100644
--- a/drivers/staging/vme/devices/vme_user.c
+++ b/drivers/staging/vme/devices/vme_user.c
@@ -474,7 +474,7 @@ static int vme_user_ioctl(struct inode *inode, struct file *file,
 	case CONTROL_MINOR:
 		switch (cmd) {
 		case VME_IRQ_GEN:
-			copied = copy_from_user(&irq_req, (char *)arg,
+			copied = copy_from_user(&irq_req, argp,
 						sizeof(struct vme_irq_id));
 			if (copied != 0) {
 				printk(KERN_WARNING "Partial copy from userspace\n");

commit db3b9e990e75573402cda22faf933760f076c033
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Thu Apr 26 12:34:58 2012 -0700

    Staging: VME: move VME drivers out of staging
    
    This moves the VME core, VME board drivers, and VME bridge drivers out
    of the drivers/staging/vme/ area to drivers/vme/.
    
    The VME device drivers have not moved out yet due to some API questions
    they are still working through, that should happen soon, hopefully.
    
    Cc: Martyn Welch <martyn.welch@ge.com>
    Cc: Manohar Vanga <manohar.vanga@cern.ch>
    Cc: Vincent Bossier <vincent.bossier@gmail.com>
    Cc: "Emilio G. Cota" <cota@braap.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vme/devices/vme_user.c b/drivers/staging/vme/devices/vme_user.c
index 10269d59942f..e24a6f95db12 100644
--- a/drivers/staging/vme/devices/vme_user.c
+++ b/drivers/staging/vme/devices/vme_user.c
@@ -36,8 +36,8 @@
 
 #include <linux/io.h>
 #include <linux/uaccess.h>
+#include <linux/vme.h>
 
-#include "../vme.h"
 #include "vme_user.h"
 
 static DEFINE_MUTEX(vme_user_mutex);

commit ecb3b80ff968f1fffdbda9eb9aa8116db86ce220
Author: Santosh Nayak <santoshprasadnayak@gmail.com>
Date:   Tue Apr 3 16:42:51 2012 +0530

    Staging: vme: Replace semaphore by mutex.
    
    Replace binary semaphore by mutex for code cleanup.
    Mutex also gives better performance than semaphore.
    
    Add 'mutex_destroy()' in 'vme_user_remove()' routine.
    
    Signed-off-by: Santosh Nayak <santoshprasadnayak@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/vme/devices/vme_user.c b/drivers/staging/vme/devices/vme_user.c
index 7dcd1622b5f5..10269d59942f 100644
--- a/drivers/staging/vme/devices/vme_user.c
+++ b/drivers/staging/vme/devices/vme_user.c
@@ -27,7 +27,7 @@
 #include <linux/module.h>
 #include <linux/pagemap.h>
 #include <linux/pci.h>
-#include <linux/semaphore.h>
+#include <linux/mutex.h>
 #include <linux/slab.h>
 #include <linux/spinlock.h>
 #include <linux/syscalls.h>
@@ -95,7 +95,7 @@ struct image_desc {
 	void *kern_buf;	/* Buffer address in kernel space */
 	dma_addr_t pci_buf;	/* Buffer address in PCI address space */
 	unsigned long long size_buf;	/* Buffer size */
-	struct semaphore sem;	/* Semaphore for locking image */
+	struct mutex mutex;	/* Mutex for locking image */
 	struct device *device;	/* Sysfs device */
 	struct vme_resource *resource;	/* VME resource */
 	int users;		/* Number of current users */
@@ -168,7 +168,7 @@ static int vme_user_open(struct inode *inode, struct file *file)
 	int err;
 	unsigned int minor = MINOR(inode->i_rdev);
 
-	down(&image[minor].sem);
+	mutex_lock(&image[minor].mutex);
 	/* Allow device to be opened if a resource is needed and allocated. */
 	if (minor < CONTROL_MINOR && image[minor].resource == NULL) {
 		printk(KERN_ERR "No resources allocated for device\n");
@@ -179,12 +179,12 @@ static int vme_user_open(struct inode *inode, struct file *file)
 	/* Increment user count */
 	image[minor].users++;
 
-	up(&image[minor].sem);
+	mutex_unlock(&image[minor].mutex);
 
 	return 0;
 
 err_res:
-	up(&image[minor].sem);
+	mutex_unlock(&image[minor].mutex);
 
 	return err;
 }
@@ -193,12 +193,12 @@ static int vme_user_release(struct inode *inode, struct file *file)
 {
 	unsigned int minor = MINOR(inode->i_rdev);
 
-	down(&image[minor].sem);
+	mutex_lock(&image[minor].mutex);
 
 	/* Decrement user count */
 	image[minor].users--;
 
-	up(&image[minor].sem);
+	mutex_unlock(&image[minor].mutex);
 
 	return 0;
 }
@@ -325,14 +325,14 @@ static ssize_t vme_user_read(struct file *file, char __user *buf, size_t count,
 	if (minor == CONTROL_MINOR)
 		return 0;
 
-	down(&image[minor].sem);
+	mutex_lock(&image[minor].mutex);
 
 	/* XXX Do we *really* want this helper - we can use vme_*_get ? */
 	image_size = vme_get_size(image[minor].resource);
 
 	/* Ensure we are starting at a valid location */
 	if ((*ppos < 0) || (*ppos > (image_size - 1))) {
-		up(&image[minor].sem);
+		mutex_unlock(&image[minor].mutex);
 		return 0;
 	}
 
@@ -353,8 +353,7 @@ static ssize_t vme_user_read(struct file *file, char __user *buf, size_t count,
 		retval = -EINVAL;
 	}
 
-	up(&image[minor].sem);
-
+	mutex_unlock(&image[minor].mutex);
 	if (retval > 0)
 		*ppos += retval;
 
@@ -372,13 +371,13 @@ static ssize_t vme_user_write(struct file *file, const char __user *buf,
 	if (minor == CONTROL_MINOR)
 		return 0;
 
-	down(&image[minor].sem);
+	mutex_lock(&image[minor].mutex);
 
 	image_size = vme_get_size(image[minor].resource);
 
 	/* Ensure we are starting at a valid location */
 	if ((*ppos < 0) || (*ppos > (image_size - 1))) {
-		up(&image[minor].sem);
+		mutex_unlock(&image[minor].mutex);
 		return 0;
 	}
 
@@ -398,8 +397,8 @@ static ssize_t vme_user_write(struct file *file, const char __user *buf,
 	default:
 		retval = -EINVAL;
 	}
-
-	up(&image[minor].sem);
+	
+	mutex_unlock(&image[minor].mutex);
 
 	if (retval > 0)
 		*ppos += retval;
@@ -416,7 +415,7 @@ static loff_t vme_user_llseek(struct file *file, loff_t off, int whence)
 	if (minor == CONTROL_MINOR)
 		return -EINVAL;
 
-	down(&image[minor].sem);
+	mutex_lock(&image[minor].mutex);
 	image_size = vme_get_size(image[minor].resource);
 
 	switch (whence) {
@@ -430,19 +429,19 @@ static loff_t vme_user_llseek(struct file *file, loff_t off, int whence)
 		absolute = image_size + off;
 		break;
 	default:
-		up(&image[minor].sem);
+		mutex_unlock(&image[minor].mutex);
 		return -EINVAL;
 		break;
 	}
 
 	if ((absolute < 0) || (absolute >= image_size)) {
-		up(&image[minor].sem);
+		mutex_unlock(&image[minor].mutex);
 		return -EINVAL;
 	}
 
 	file->f_pos = absolute;
 
-	up(&image[minor].sem);
+	mutex_unlock(&image[minor].mutex);
 
 	return absolute;
 }
@@ -696,7 +695,7 @@ static int __devinit vme_user_probe(struct vme_dev *vdev)
 	for (i = 0; i < VME_DEVS; i++) {
 		image[i].kern_buf = NULL;
 		image[i].pci_buf = 0;
-		sema_init(&image[i].sem, 1);
+		mutex_init(&image[i].mutex);
 		image[i].device = NULL;
 		image[i].resource = NULL;
 		image[i].users = 0;
@@ -858,8 +857,10 @@ static int __devexit vme_user_remove(struct vme_dev *dev)
 	int i;
 
 	/* Remove sysfs Entries */
-	for (i = 0; i < VME_DEVS; i++)
+	for (i = 0; i < VME_DEVS; i++) {
+		mutex_destroy(&image[i].mutex);
 		device_destroy(vme_user_sysfs_class, MKDEV(VME_MAJOR, i));
+	}
 	class_destroy(vme_user_sysfs_class);
 
 	for (i = MASTER_MINOR; i < (MASTER_MAX + 1); i++) {

commit 0a4b6b0279d903df2d62aaf92edf360fb5312532
Author: Manohar Vanga <manohar.vanga@cern.ch>
Date:   Mon Sep 26 11:27:18 2011 +0200

    staging: vme_user: rename USER_BUS_MAX to VME_USER_BUS_MAX
    
    Signed-off-by: Manohar Vanga <manohar.vanga@cern.ch>
    Cc: Martyn Welch <martyn.welch@ge.com>
    Reviewed-by: Emilio G. Cota <cota@braap.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/vme/devices/vme_user.c b/drivers/staging/vme/devices/vme_user.c
index 9518dda13ea6..7dcd1622b5f5 100644
--- a/drivers/staging/vme/devices/vme_user.c
+++ b/drivers/staging/vme/devices/vme_user.c
@@ -43,7 +43,7 @@
 static DEFINE_MUTEX(vme_user_mutex);
 static const char driver_name[] = "vme_user";
 
-static int bus[USER_BUS_MAX];
+static int bus[VME_USER_BUS_MAX];
 static unsigned int bus_num;
 
 /* Currently Documentation/devices.txt defines the following for VME:
@@ -643,10 +643,10 @@ static int __init vme_user_init(void)
 	/* Let's start by supporting one bus, we can support more than one
 	 * in future revisions if that ever becomes necessary.
 	 */
-	if (bus_num > USER_BUS_MAX) {
+	if (bus_num > VME_USER_BUS_MAX) {
 		printk(KERN_ERR "%s: Driver only able to handle %d buses\n",
-			driver_name, USER_BUS_MAX);
-		bus_num = USER_BUS_MAX;
+			driver_name, VME_USER_BUS_MAX);
+		bus_num = VME_USER_BUS_MAX;
 	}
 
 	/*
@@ -668,7 +668,7 @@ static int __init vme_user_init(void)
 
 static int vme_user_match(struct vme_dev *vdev)
 {
-	if (vdev->num >= USER_BUS_MAX)
+	if (vdev->num >= VME_USER_BUS_MAX)
 		return 0;
 	return 1;
 }

commit a916a391d3e19593a104a8c3c4779a3084f1ca5b
Author: Manohar Vanga <manohar.vanga@cern.ch>
Date:   Mon Sep 26 11:27:17 2011 +0200

    staging: vme: get rid of struct vme_device_id and slots
    
    Previously, the device-driver matching mechanism depended on the
    vme_device_id structure due to the need for a bind table per driver.
    This method of matching is no longer used so this patch merges the
    fields of struct vme_device_id into struct vme_dev. Since this also
    renders the slot field meaningless, it has also been removed in this
    patch.
    
    Signed-off-by: Manohar Vanga <manohar.vanga@cern.ch>
    Cc: Martyn Welch <martyn.welch@ge.com>
    Reviewed-by: Emilio G. Cota <cota@braap.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/vme/devices/vme_user.c b/drivers/staging/vme/devices/vme_user.c
index c658ce9bd612..9518dda13ea6 100644
--- a/drivers/staging/vme/devices/vme_user.c
+++ b/drivers/staging/vme/devices/vme_user.c
@@ -668,7 +668,7 @@ static int __init vme_user_init(void)
 
 static int vme_user_match(struct vme_dev *vdev)
 {
-	if (vdev->id.num >= USER_BUS_MAX)
+	if (vdev->num >= USER_BUS_MAX)
 		return 0;
 	return 1;
 }

commit 5d6abf379d73efe390488e8edba972af4e93cb1c
Author: Manohar Vanga <manohar.vanga@cern.ch>
Date:   Mon Sep 26 11:27:16 2011 +0200

    staging: vme: make match() driver specific to improve non-VME64x support
    
    For jumper based boards (non VME64x), there is no mechanism
    for detecting the card that is plugged into a specific slot. This
    leads to issues in non-autodiscovery crates/cards when a card is
    plugged into a slot that is "claimed" by a different driver. In
    reality, there is no problem, but the driver rejects such a
    configuration due to its dependence on the concept of slots.
    
    This patch makes the concept of slots less critical and pushes the
    driver match() to individual drivers (similar to what happens in the
    ISA bus in driver/base/isa.c). This allows drivers to register the
    number of devices that they expect without any restrictions. Devices
    in this new model are now formatted as $driver_name-$bus_id.$device_id
    (as compared to the earlier vme-$bus_id.$slot_number).
    
    This model also makes the device model more logical as devices
    are only registered when they actually exist whereas earlier,
    a set of devices were being created automatically regardless of
    them actually being there.
    
    Another change introduced in this patch is that devices are now created
    within the VME driver structure rather than in the VME bridge structure.
    This way, things don't go haywire if the bridge driver is removed while
    a driver is using it.
    
    Signed-off-by: Manohar Vanga <manohar.vanga@cern.ch>
    Cc: Martyn Welch <martyn.welch@ge.com>
    Reviewed-by: Emilio G. Cota <cota@braap.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/vme/devices/vme_user.c b/drivers/staging/vme/devices/vme_user.c
index bb33dc2ece4e..c658ce9bd612 100644
--- a/drivers/staging/vme/devices/vme_user.c
+++ b/drivers/staging/vme/devices/vme_user.c
@@ -135,6 +135,7 @@ static ssize_t vme_user_write(struct file *, const char __user *, size_t,
 static loff_t vme_user_llseek(struct file *, loff_t, int);
 static long vme_user_unlocked_ioctl(struct file *, unsigned int, unsigned long);
 
+static int vme_user_match(struct vme_dev *);
 static int __devinit vme_user_probe(struct vme_dev *);
 static int __devexit vme_user_remove(struct vme_dev *);
 
@@ -620,6 +621,7 @@ static void buf_unalloc(int num)
 
 static struct vme_driver vme_user_driver = {
 	.name = driver_name,
+	.match = vme_user_match,
 	.probe = vme_user_probe,
 	.remove = __devexit_p(vme_user_remove),
 };
@@ -628,8 +630,6 @@ static struct vme_driver vme_user_driver = {
 static int __init vme_user_init(void)
 {
 	int retval = 0;
-	int i;
-	struct vme_device_id *ids;
 
 	printk(KERN_INFO "VME User Space Access Driver\n");
 
@@ -649,41 +649,30 @@ static int __init vme_user_init(void)
 		bus_num = USER_BUS_MAX;
 	}
 
-
-	/* Dynamically create the bind table based on module parameters */
-	ids = kzalloc(sizeof(struct vme_device_id) * (bus_num + 1), GFP_KERNEL);
-	if (ids == NULL) {
-		printk(KERN_ERR "%s: Unable to allocate ID table\n",
-			driver_name);
-		retval = -ENOMEM;
-		goto err_id;
-	}
-
-	for (i = 0; i < bus_num; i++) {
-		ids[i].bus = bus[i];
-		/*
-		 * We register the driver against the slot occupied by *this*
-		 * card, since it's really a low level way of controlling
-		 * the VME bridge
-		 */
-		ids[i].slot = VME_SLOT_CURRENT;
-	}
-
-	vme_user_driver.bind_table = ids;
-
-	retval = vme_register_driver(&vme_user_driver);
+	/*
+	 * Here we just register the maximum number of devices we can and
+	 * leave vme_user_match() to allow only 1 to go through to probe().
+	 * This way, if we later want to allow multiple user access devices,
+	 * we just change the code in vme_user_match().
+	 */
+	retval = vme_register_driver(&vme_user_driver, VME_MAX_SLOTS);
 	if (retval != 0)
 		goto err_reg;
 
 	return retval;
 
 err_reg:
-	kfree(ids);
-err_id:
 err_nocard:
 	return retval;
 }
 
+static int vme_user_match(struct vme_dev *vdev)
+{
+	if (vdev->id.num >= USER_BUS_MAX)
+		return 0;
+	return 1;
+}
+
 /*
  * In this simple access driver, the old behaviour is being preserved as much
  * as practical. We will therefore reserve the buffers and request the images
@@ -896,8 +885,6 @@ static int __devexit vme_user_remove(struct vme_dev *dev)
 static void __exit vme_user_exit(void)
 {
 	vme_unregister_driver(&vme_user_driver);
-
-	kfree(vme_user_driver.bind_table);
 }
 
 

commit 8f966dc444b11adff6011a1d1fce424abdd876d8
Author: Manohar Vanga <manohar.vanga@cern.ch>
Date:   Mon Sep 26 11:27:15 2011 +0200

    staging: vme: add struct vme_dev for VME devices
    
    Instead of using a vanilla 'struct device' for VME devices, add new
    'struct vme_dev'. Modifications have been made to the VME framework
    API as well as all in-tree VME drivers.
    
    The new vme_dev structure has the following advantages from the
    current model used by the driver:
    
        * Driver functions (probe, remove) now receive a VME device
          instead of a pointer to the bridge device (cleaner design)
        * It's easier to differenciate API calls as bridge-based or
          device-based (ie. cleaner interface).
    
    Signed-off-by: Manohar Vanga <manohar.vanga@cern.ch>
    Cc: Martyn Welch <martyn.welch@ge.com>
    Reviewed-by: Emilio G. Cota <cota@braap.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/vme/devices/vme_user.c b/drivers/staging/vme/devices/vme_user.c
index 3cbeb2ada418..bb33dc2ece4e 100644
--- a/drivers/staging/vme/devices/vme_user.c
+++ b/drivers/staging/vme/devices/vme_user.c
@@ -116,7 +116,7 @@ static struct driver_stats statistics;
 
 static struct cdev *vme_user_cdev;		/* Character device */
 static struct class *vme_user_sysfs_class;	/* Sysfs class */
-static struct device *vme_user_bridge;		/* Pointer to bridge device */
+static struct vme_dev *vme_user_bridge;		/* Pointer to user device */
 
 
 static const int type[VME_DEVS] = {	MASTER_MINOR,	MASTER_MINOR,
@@ -135,8 +135,8 @@ static ssize_t vme_user_write(struct file *, const char __user *, size_t,
 static loff_t vme_user_llseek(struct file *, loff_t, int);
 static long vme_user_unlocked_ioctl(struct file *, unsigned int, unsigned long);
 
-static int __devinit vme_user_probe(struct device *, int, int);
-static int __devexit vme_user_remove(struct device *, int, int);
+static int __devinit vme_user_probe(struct vme_dev *);
+static int __devexit vme_user_remove(struct vme_dev *);
 
 static const struct file_operations vme_user_fops = {
 	.open = vme_user_open,
@@ -689,8 +689,7 @@ static int __init vme_user_init(void)
  * as practical. We will therefore reserve the buffers and request the images
  * here so that we don't have to do it later.
  */
-static int __devinit vme_user_probe(struct device *dev, int cur_bus,
-	int cur_slot)
+static int __devinit vme_user_probe(struct vme_dev *vdev)
 {
 	int i, err;
 	char name[12];
@@ -702,7 +701,7 @@ static int __devinit vme_user_probe(struct device *dev, int cur_bus,
 		err = -EINVAL;
 		goto err_dev;
 	}
-	vme_user_bridge = dev;
+	vme_user_bridge = vdev;
 
 	/* Initialise descriptors */
 	for (i = 0; i < VME_DEVS; i++) {
@@ -865,8 +864,7 @@ static int __devinit vme_user_probe(struct device *dev, int cur_bus,
 	return err;
 }
 
-static int __devexit vme_user_remove(struct device *dev, int cur_bus,
-	int cur_slot)
+static int __devexit vme_user_remove(struct vme_dev *dev)
 {
 	int i;
 

commit 34a678110ac5d2f1b694c8b9df5cccb1a2607721
Author: Manohar Vanga <manohar.vanga@cern.ch>
Date:   Mon Aug 1 12:20:46 2011 +0200

    staging: vme_user: change kmalloc+memset to kzalloc
    
    Signed-off-by: Manohar Vanga <manohar.vanga@cern.ch>
    Acked-by: Martyn Welch <martyn.welch@ge.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/vme/devices/vme_user.c b/drivers/staging/vme/devices/vme_user.c
index 91d2cc7bb4c3..3cbeb2ada418 100644
--- a/drivers/staging/vme/devices/vme_user.c
+++ b/drivers/staging/vme/devices/vme_user.c
@@ -651,7 +651,7 @@ static int __init vme_user_init(void)
 
 
 	/* Dynamically create the bind table based on module parameters */
-	ids = kmalloc(sizeof(struct vme_device_id) * (bus_num + 1), GFP_KERNEL);
+	ids = kzalloc(sizeof(struct vme_device_id) * (bus_num + 1), GFP_KERNEL);
 	if (ids == NULL) {
 		printk(KERN_ERR "%s: Unable to allocate ID table\n",
 			driver_name);
@@ -659,8 +659,6 @@ static int __init vme_user_init(void)
 		goto err_id;
 	}
 
-	memset(ids, 0, (sizeof(struct vme_device_id) * (bus_num + 1)));
-
 	for (i = 0; i < bus_num; i++) {
 		ids[i].bus = bus[i];
 		/*

commit dca22184262de0171bafdf613a8d3992a818b70f
Author: Vincent Bossier <vincent.bossier@gmail.com>
Date:   Thu Jun 9 15:49:30 2011 +0200

    Staging: VME: Introduce IOCTL to generate VME interrupts.
    
    The vme_irq_set is oblviously not needed (a remnant from old tests) and the
    IOCTL exchange types have been updated following Greg's comments.
    
    Allow the IOCTL call to generate VME interrupts when called on the vme/ctl
    device with the right arguments.
    
    Signed-off-by: Vincent Bossier <vincent.bossier@gmail.com>
    Acked-by: Martyn Welch <martyn.welch@ge.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/vme/devices/vme_user.c b/drivers/staging/vme/devices/vme_user.c
index db128790e578..91d2cc7bb4c3 100644
--- a/drivers/staging/vme/devices/vme_user.c
+++ b/drivers/staging/vme/devices/vme_user.c
@@ -461,6 +461,7 @@ static int vme_user_ioctl(struct inode *inode, struct file *file,
 {
 	struct vme_master master;
 	struct vme_slave slave;
+	struct vme_irq_id irq_req;
 	unsigned long copied;
 	unsigned int minor = MINOR(inode->i_rdev);
 	int retval;
@@ -471,6 +472,21 @@ static int vme_user_ioctl(struct inode *inode, struct file *file,
 
 	switch (type[minor]) {
 	case CONTROL_MINOR:
+		switch (cmd) {
+		case VME_IRQ_GEN:
+			copied = copy_from_user(&irq_req, (char *)arg,
+						sizeof(struct vme_irq_id));
+			if (copied != 0) {
+				printk(KERN_WARNING "Partial copy from userspace\n");
+				return -EFAULT;
+			}
+
+			retval = vme_irq_generate(vme_user_bridge,
+						  irq_req.level,
+						  irq_req.statid);
+
+			return retval;
+		}
 		break;
 	case MASTER_MINOR:
 		switch (cmd) {

commit 05614fbfc1f3dedc337ac67e83b6ad130ba9fc9f
Author: Vincent Bossier <vincent.bossier@gmail.com>
Date:   Thu Jun 9 09:20:31 2011 +0100

    Staging: VME: Make vme/ctl device available for IOCTL operations only.
    
    Resurrect the vme/ctl device by allowing to open it even if it has no resources
    and make related read/write/llseek operations dummy.
    
    Signed-off-by: Vincent Bossier <vincent.bossier@gmail.com>
    Acked-by: Martyn Welch <martyn.welch@ge.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/vme/devices/vme_user.c b/drivers/staging/vme/devices/vme_user.c
index 633a64259f1a..db128790e578 100644
--- a/drivers/staging/vme/devices/vme_user.c
+++ b/drivers/staging/vme/devices/vme_user.c
@@ -168,8 +168,8 @@ static int vme_user_open(struct inode *inode, struct file *file)
 	unsigned int minor = MINOR(inode->i_rdev);
 
 	down(&image[minor].sem);
-	/* Only allow device to be opened if a resource is allocated */
-	if (image[minor].resource == NULL) {
+	/* Allow device to be opened if a resource is needed and allocated. */
+	if (minor < CONTROL_MINOR && image[minor].resource == NULL) {
 		printk(KERN_ERR "No resources allocated for device\n");
 		err = -EINVAL;
 		goto err_res;
@@ -321,6 +321,9 @@ static ssize_t vme_user_read(struct file *file, char __user *buf, size_t count,
 	size_t image_size;
 	size_t okcount;
 
+	if (minor == CONTROL_MINOR)
+		return 0;
+
 	down(&image[minor].sem);
 
 	/* XXX Do we *really* want this helper - we can use vme_*_get ? */
@@ -365,6 +368,9 @@ static ssize_t vme_user_write(struct file *file, const char __user *buf,
 	size_t image_size;
 	size_t okcount;
 
+	if (minor == CONTROL_MINOR)
+		return 0;
+
 	down(&image[minor].sem);
 
 	image_size = vme_get_size(image[minor].resource);
@@ -406,6 +412,9 @@ static loff_t vme_user_llseek(struct file *file, loff_t off, int whence)
 	unsigned int minor = MINOR(file->f_dentry->d_inode->i_rdev);
 	size_t image_size;
 
+	if (minor == CONTROL_MINOR)
+		return -EINVAL;
+
 	down(&image[minor].sem);
 	image_size = vme_get_size(image[minor].resource);
 

commit 584721cab2bdd26f63bfeca60c83f5e6b8eee7d0
Author: Vincent Bossier <vincent.bossier@gmail.com>
Date:   Fri Jun 3 10:07:39 2011 +0100

    Staging VME: Fix remaining checkpatch.pl errors.
    
    This patch solves all the existing issues reported by checkpatch.pl in the VME
    sub-system.
    
    Signed-off-by: Vincent Bossier <vincent.bossier@gmail.com>
    Acked-by: Martyn Welch <martyn.welch@ge.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/vme/devices/vme_user.c b/drivers/staging/vme/devices/vme_user.c
index a571173249cf..633a64259f1a 100644
--- a/drivers/staging/vme/devices/vme_user.c
+++ b/drivers/staging/vme/devices/vme_user.c
@@ -41,7 +41,7 @@
 #include "vme_user.h"
 
 static DEFINE_MUTEX(vme_user_mutex);
-static char driver_name[] = "vme_user";
+static const char driver_name[] = "vme_user";
 
 static int bus[USER_BUS_MAX];
 static unsigned int bus_num;
@@ -91,7 +91,7 @@ static unsigned int bus_num;
 /*
  * Structure to handle image related parameters.
  */
-typedef struct {
+struct image_desc {
 	void *kern_buf;	/* Buffer address in kernel space */
 	dma_addr_t pci_buf;	/* Buffer address in PCI address space */
 	unsigned long long size_buf;	/* Buffer size */
@@ -99,10 +99,10 @@ typedef struct {
 	struct device *device;	/* Sysfs device */
 	struct vme_resource *resource;	/* VME resource */
 	int users;		/* Number of current users */
-} image_desc_t;
-static image_desc_t image[VME_DEVS];
+};
+static struct image_desc image[VME_DEVS];
 
-typedef struct {
+struct driver_stats {
 	unsigned long reads;
 	unsigned long writes;
 	unsigned long ioctls;
@@ -111,8 +111,8 @@ typedef struct {
 	unsigned long dmaErrors;
 	unsigned long timeouts;
 	unsigned long external;
-} driver_stats_t;
-static driver_stats_t statistics;
+};
+static struct driver_stats statistics;
 
 static struct cdev *vme_user_cdev;		/* Character device */
 static struct class *vme_user_sysfs_class;	/* Sysfs class */
@@ -138,7 +138,7 @@ static long vme_user_unlocked_ioctl(struct file *, unsigned int, unsigned long);
 static int __devinit vme_user_probe(struct device *, int, int);
 static int __devexit vme_user_remove(struct device *, int, int);
 
-static struct file_operations vme_user_fops = {
+static const struct file_operations vme_user_fops = {
 	.open = vme_user_open,
 	.release = vme_user_release,
 	.read = vme_user_read,
@@ -773,6 +773,7 @@ static int __devinit vme_user_probe(struct device *dev, int cur_bus,
 
 	/* Add sysfs Entries */
 	for (i = 0; i < VME_DEVS; i++) {
+		int num;
 		switch (type[i]) {
 		case MASTER_MINOR:
 			sprintf(name, "bus/vme/m%%d");
@@ -789,10 +790,9 @@ static int __devinit vme_user_probe(struct device *dev, int cur_bus,
 			break;
 		}
 
-		image[i].device =
-			device_create(vme_user_sysfs_class, NULL,
-				MKDEV(VME_MAJOR, i), NULL, name,
-				(type[i] == SLAVE_MINOR) ? i - (MASTER_MAX + 1) : i);
+		num = (type[i] == SLAVE_MINOR) ? i - (MASTER_MAX + 1) : i;
+		image[i].device = device_create(vme_user_sysfs_class, NULL,
+					MKDEV(VME_MAJOR, i), NULL, name, num);
 		if (IS_ERR(image[i].device)) {
 			printk(KERN_INFO "%s: Error creating sysfs device\n",
 				driver_name);

commit b62c99b17c2c513eaf6b77a76907a13a1beb86d3
Author: Emilio G. Cota <cota@braap.org>
Date:   Fri Dec 3 14:20:51 2010 +0000

    staging/vme_user: add missing calls to vme_master_free calls in .remove
    
    Signed-off-by: Emilio G. Cota <cota@braap.org>
    Acked-by: Martyn Welch <martyn.welch@ge.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/vme/devices/vme_user.c b/drivers/staging/vme/devices/vme_user.c
index db445ed164c6..a571173249cf 100644
--- a/drivers/staging/vme/devices/vme_user.c
+++ b/drivers/staging/vme/devices/vme_user.c
@@ -852,8 +852,10 @@ static int __devexit vme_user_remove(struct device *dev, int cur_bus,
 		device_destroy(vme_user_sysfs_class, MKDEV(VME_MAJOR, i));
 	class_destroy(vme_user_sysfs_class);
 
-	for (i = MASTER_MINOR; i < (MASTER_MAX + 1); i++)
+	for (i = MASTER_MINOR; i < (MASTER_MAX + 1); i++) {
 		kfree(image[i].kern_buf);
+		vme_master_free(image[i].resource);
+	}
 
 	for (i = SLAVE_MINOR; i < (SLAVE_MAX + 1); i++) {
 		vme_slave_set(image[i].resource, 0, 0, 0, 0, VME_A32, 0);

commit 4740a0846069f6d4cbba9e328a9d92e6dd76110d
Author: Emilio G. Cota <cota@braap.org>
Date:   Fri Dec 3 13:44:15 2010 +0000

    staging/vme/vme_user: use __dev{init, exit} for .probe and .remove
    
    Signed-off-by: Emilio G. Cota <cota@braap.org>
    [martyn.welch@ge.com: Fixed checkpatch line length warnings]
    Signed-off-by: Martyn Welch <martyn.welch@ge.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/vme/devices/vme_user.c b/drivers/staging/vme/devices/vme_user.c
index dc7175bdfcf9..db445ed164c6 100644
--- a/drivers/staging/vme/devices/vme_user.c
+++ b/drivers/staging/vme/devices/vme_user.c
@@ -135,8 +135,8 @@ static ssize_t vme_user_write(struct file *, const char __user *, size_t,
 static loff_t vme_user_llseek(struct file *, loff_t, int);
 static long vme_user_unlocked_ioctl(struct file *, unsigned int, unsigned long);
 
-static int __init vme_user_probe(struct device *, int, int);
-static int __exit vme_user_remove(struct device *, int, int);
+static int __devinit vme_user_probe(struct device *, int, int);
+static int __devexit vme_user_remove(struct device *, int, int);
 
 static struct file_operations vme_user_fops = {
 	.open = vme_user_open,
@@ -596,7 +596,7 @@ static void buf_unalloc(int num)
 static struct vme_driver vme_user_driver = {
 	.name = driver_name,
 	.probe = vme_user_probe,
-	.remove = vme_user_remove,
+	.remove = __devexit_p(vme_user_remove),
 };
 
 
@@ -666,7 +666,8 @@ static int __init vme_user_init(void)
  * as practical. We will therefore reserve the buffers and request the images
  * here so that we don't have to do it later.
  */
-static int __init vme_user_probe(struct device *dev, int cur_bus, int cur_slot)
+static int __devinit vme_user_probe(struct device *dev, int cur_bus,
+	int cur_slot)
 {
 	int i, err;
 	char name[12];
@@ -841,7 +842,8 @@ static int __init vme_user_probe(struct device *dev, int cur_bus, int cur_slot)
 	return err;
 }
 
-static int __exit vme_user_remove(struct device *dev, int cur_bus, int cur_slot)
+static int __devexit vme_user_remove(struct device *dev, int cur_bus,
+	int cur_slot)
 {
 	int i;
 

commit 1daa38d379932bde0d2036c2e10ced3e8842b74f
Author: Emilio G. Cota <cota@braap.org>
Date:   Fri Dec 3 09:05:08 2010 +0000

    staging/vme_user: fix usage of the slave resources after they've been freed
    
    buf_unalloc() frees the memory buffers allocated with vme_alloc_consistent.
    The associated VME resource is needed in both vme_alloc_consistent and
    vme_free_consistent; however the slave VME resources are being freed before
    the calls to vme_free_consistent are made, which means the buffers
    are never returned.
    
    Fix this by freeing the VME resources only after the consistent buffers have
    been returned.
    
    Signed-off-by: Emilio G. Cota <cota@braap.org>
    Acked-by: Martyn Welch <martyn.welch@ge.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/vme/devices/vme_user.c b/drivers/staging/vme/devices/vme_user.c
index 36381489b797..dc7175bdfcf9 100644
--- a/drivers/staging/vme/devices/vme_user.c
+++ b/drivers/staging/vme/devices/vme_user.c
@@ -829,8 +829,8 @@ static int __init vme_user_probe(struct device *dev, int cur_bus, int cur_slot)
 err_slave:
 	while (i > SLAVE_MINOR) {
 		i--;
-		vme_slave_free(image[i].resource);
 		buf_unalloc(i);
+		vme_slave_free(image[i].resource);
 	}
 err_class:
 	cdev_del(vme_user_cdev);
@@ -855,8 +855,8 @@ static int __exit vme_user_remove(struct device *dev, int cur_bus, int cur_slot)
 
 	for (i = SLAVE_MINOR; i < (SLAVE_MAX + 1); i++) {
 		vme_slave_set(image[i].resource, 0, 0, 0, 0, VME_A32, 0);
-		vme_slave_free(image[i].resource);
 		buf_unalloc(i);
+		vme_slave_free(image[i].resource);
 	}
 
 	/* Unregister device driver */

commit 1a85f2073d99080ea70962f767edca479c768b6e
Author: Emilio G. Cota <cota@braap.org>
Date:   Fri Nov 12 11:15:34 2010 +0000

    staging: vme_user: mark user-space buffers with __user
    
    Signed-off-by: Emilio G. Cota <cota@braap.org>
    [martyn.welch@ge.com: modified to remove checkpatch warnings]
    Signed-off-by: Martyn Welch <martyn.welch@ge.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/vme/devices/vme_user.c b/drivers/staging/vme/devices/vme_user.c
index 5d3a39bcd2a8..36381489b797 100644
--- a/drivers/staging/vme/devices/vme_user.c
+++ b/drivers/staging/vme/devices/vme_user.c
@@ -129,8 +129,9 @@ static const int type[VME_DEVS] = {	MASTER_MINOR,	MASTER_MINOR,
 
 static int vme_user_open(struct inode *, struct file *);
 static int vme_user_release(struct inode *, struct file *);
-static ssize_t vme_user_read(struct file *, char *, size_t, loff_t *);
-static ssize_t vme_user_write(struct file *, const char *, size_t, loff_t *);
+static ssize_t vme_user_read(struct file *, char __user *, size_t, loff_t *);
+static ssize_t vme_user_write(struct file *, const char __user *, size_t,
+	loff_t *);
 static loff_t vme_user_llseek(struct file *, loff_t, int);
 static long vme_user_unlocked_ioctl(struct file *, unsigned int, unsigned long);
 
@@ -246,7 +247,7 @@ static ssize_t resource_to_user(int minor, char __user *buf, size_t count,
  * page) transfers will lock the user space buffer into memory and then
  * transfer the data directly from the user space buffers out to VME.
  */
-static ssize_t resource_from_user(unsigned int minor, const char *buf,
+static ssize_t resource_from_user(unsigned int minor, const char __user *buf,
 	size_t count, loff_t *ppos)
 {
 	ssize_t retval;
@@ -293,7 +294,7 @@ static ssize_t buffer_to_user(unsigned int minor, char __user *buf,
 	return retval;
 }
 
-static ssize_t buffer_from_user(unsigned int minor, const char *buf,
+static ssize_t buffer_from_user(unsigned int minor, const char __user *buf,
 	size_t count, loff_t *ppos)
 {
 	void *image_ptr;
@@ -312,7 +313,7 @@ static ssize_t buffer_from_user(unsigned int minor, const char *buf,
 	return retval;
 }
 
-static ssize_t vme_user_read(struct file *file, char *buf, size_t count,
+static ssize_t vme_user_read(struct file *file, char __user *buf, size_t count,
 			loff_t *ppos)
 {
 	unsigned int minor = MINOR(file->f_dentry->d_inode->i_rdev);
@@ -356,8 +357,8 @@ static ssize_t vme_user_read(struct file *file, char *buf, size_t count,
 	return retval;
 }
 
-static ssize_t vme_user_write(struct file *file, const char *buf, size_t count,
-			 loff_t *ppos)
+static ssize_t vme_user_write(struct file *file, const char __user *buf,
+			size_t count, loff_t *ppos)
 {
 	unsigned int minor = MINOR(file->f_dentry->d_inode->i_rdev);
 	ssize_t retval;
@@ -455,6 +456,7 @@ static int vme_user_ioctl(struct inode *inode, struct file *file,
 	unsigned int minor = MINOR(inode->i_rdev);
 	int retval;
 	dma_addr_t pci_addr;
+	void __user *argp = (void __user *)arg;
 
 	statistics.ioctls++;
 
@@ -474,7 +476,7 @@ static int vme_user_ioctl(struct inode *inode, struct file *file,
 				&master.size, &master.aspace,
 				&master.cycle, &master.dwidth);
 
-			copied = copy_to_user((char *)arg, &master,
+			copied = copy_to_user(argp, &master,
 				sizeof(struct vme_master));
 			if (copied != 0) {
 				printk(KERN_WARNING "Partial copy to "
@@ -487,8 +489,7 @@ static int vme_user_ioctl(struct inode *inode, struct file *file,
 
 		case VME_SET_MASTER:
 
-			copied = copy_from_user(&master, (char *)arg,
-				sizeof(master));
+			copied = copy_from_user(&master, argp, sizeof(master));
 			if (copied != 0) {
 				printk(KERN_WARNING "Partial copy from "
 					"userspace\n");
@@ -518,7 +519,7 @@ static int vme_user_ioctl(struct inode *inode, struct file *file,
 				&slave.size, &pci_addr, &slave.aspace,
 				&slave.cycle);
 
-			copied = copy_to_user((char *)arg, &slave,
+			copied = copy_to_user(argp, &slave,
 				sizeof(struct vme_slave));
 			if (copied != 0) {
 				printk(KERN_WARNING "Partial copy to "
@@ -531,8 +532,7 @@ static int vme_user_ioctl(struct inode *inode, struct file *file,
 
 		case VME_SET_SLAVE:
 
-			copied = copy_from_user(&slave, (char *)arg,
-				sizeof(slave));
+			copied = copy_from_user(&slave, argp, sizeof(slave));
 			if (copied != 0) {
 				printk(KERN_WARNING "Partial copy from "
 					"userspace\n");

commit 0a81a0f768e5bb0c32db6e44440c5b7c1b4658e7
Author: Emilio G. Cota <cota@braap.org>
Date:   Fri Nov 12 11:15:27 2010 +0000

    staging: vme_user: remove __iomem marking from kern_buf and derivates
    
    kern_buf is not iomem; it comes from kmalloc and is directly
    dereferenced.
    
    Signed-off-by: Emilio G. Cota <cota@braap.org>
    Acked-by: Martyn Welch <martyn.welch@ge.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/vme/devices/vme_user.c b/drivers/staging/vme/devices/vme_user.c
index 7c61adc8eb79..5d3a39bcd2a8 100644
--- a/drivers/staging/vme/devices/vme_user.c
+++ b/drivers/staging/vme/devices/vme_user.c
@@ -92,7 +92,7 @@ static unsigned int bus_num;
  * Structure to handle image related parameters.
  */
 typedef struct {
-	void __iomem *kern_buf;	/* Buffer address in kernel space */
+	void *kern_buf;	/* Buffer address in kernel space */
 	dma_addr_t pci_buf;	/* Buffer address in PCI address space */
 	unsigned long long size_buf;	/* Buffer size */
 	struct semaphore sem;	/* Semaphore for locking image */
@@ -277,7 +277,7 @@ static ssize_t resource_from_user(unsigned int minor, const char *buf,
 static ssize_t buffer_to_user(unsigned int minor, char __user *buf,
 	size_t count, loff_t *ppos)
 {
-	void __iomem *image_ptr;
+	void *image_ptr;
 	ssize_t retval;
 
 	image_ptr = image[minor].kern_buf + *ppos;
@@ -296,7 +296,7 @@ static ssize_t buffer_to_user(unsigned int minor, char __user *buf,
 static ssize_t buffer_from_user(unsigned int minor, const char *buf,
 	size_t count, loff_t *ppos)
 {
-	void __iomem *image_ptr;
+	void *image_ptr;
 	size_t retval;
 
 	image_ptr = image[minor].kern_buf + *ppos;

commit c949231838006d7de4ad38be38d9e112826862da
Author: Emilio G. Cota <cota@braap.org>
Date:   Fri Nov 12 11:15:21 2010 +0000

    staging: vme_user: use an unsigned int for counting the number of kparams
    
    unsigned int is what struct kparam_array internally uses.
    
    Signed-off-by: Emilio G. Cota <cota@braap.org>
    Acked-by: Martyn Welch <martyn.welch@ge.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/vme/devices/vme_user.c b/drivers/staging/vme/devices/vme_user.c
index f7fa02d0d87b..7c61adc8eb79 100644
--- a/drivers/staging/vme/devices/vme_user.c
+++ b/drivers/staging/vme/devices/vme_user.c
@@ -44,7 +44,7 @@ static DEFINE_MUTEX(vme_user_mutex);
 static char driver_name[] = "vme_user";
 
 static int bus[USER_BUS_MAX];
-static int bus_num;
+static unsigned int bus_num;
 
 /* Currently Documentation/devices.txt defines the following for VME:
  *

commit b9cc293486e27f4d29a9813da6ebcb8574071dfa
Author: Emilio G. Cota <cota@braap.org>
Date:   Fri Nov 12 11:15:14 2010 +0000

    staging: vme_user: declare private variables as static
    
    Signed-off-by: Emilio G. Cota <cota@braap.org>
    [martyn.welch@ge.com: modified to remove checkpatch warnings]
    Signed-off-by: Martyn Welch <martyn.welch@ge.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/vme/devices/vme_user.c b/drivers/staging/vme/devices/vme_user.c
index bdc4e1ecfaf3..f7fa02d0d87b 100644
--- a/drivers/staging/vme/devices/vme_user.c
+++ b/drivers/staging/vme/devices/vme_user.c
@@ -114,9 +114,9 @@ typedef struct {
 } driver_stats_t;
 static driver_stats_t statistics;
 
-struct cdev *vme_user_cdev;		/* Character device */
-struct class *vme_user_sysfs_class;	/* Sysfs class */
-struct device *vme_user_bridge;		/* Pointer to the bridge device */
+static struct cdev *vme_user_cdev;		/* Character device */
+static struct class *vme_user_sysfs_class;	/* Sysfs class */
+static struct device *vme_user_bridge;		/* Pointer to bridge device */
 
 
 static const int type[VME_DEVS] = {	MASTER_MINOR,	MASTER_MINOR,

commit c0779fd01df76b3097cc77e3a404e8bb067e5628
Author: Emilio G. Cota <cota@braap.org>
Date:   Fri Nov 12 11:14:20 2010 +0000

    staging: vme_user: remove unreachable line
    
    Signed-off-by: Emilio G. Cota <cota@braap.org>
    Acked-by: Martyn Welch <martyn.welch@ge.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/vme/devices/vme_user.c b/drivers/staging/vme/devices/vme_user.c
index a6f61162af3f..bdc4e1ecfaf3 100644
--- a/drivers/staging/vme/devices/vme_user.c
+++ b/drivers/staging/vme/devices/vme_user.c
@@ -654,7 +654,6 @@ static int __init vme_user_init(void)
 
 	return retval;
 
-	vme_unregister_driver(&vme_user_driver);
 err_reg:
 	kfree(ids);
 err_id:

commit 55db50205adaf14db1bda07d0931b647b794de2f
Author: Emilio G. Cota <cota@braap.org>
Date:   Fri Nov 12 11:14:14 2010 +0000

    staging: vme_user: return the appropriate error code when module_init fails
    
    When init_module fails, 0 is returned anyway; the module is then installed
    and oopses when we try to remove it:
    
    [ 3236.368009] WARNING: at drivers/base/driver.c:262 driver_unregister+0x36/0x6f()
    [ 3236.368012] Hardware name:
    [ 3236.368014] Unexpected driver unregister!
    [ 3236.368016] Modules linked in: vme_user(-) vme_tsi148 vme e1000e iTCO_wdt iTCO_vendor_support [last unloaded: vme]
    [ 3236.368027] Pid: 16162, comm: rmmod Not tainted 2.6.35 #2
    [ 3236.368029] Call Trace:
    [ 3236.368037]  [<ffffffff81036ea3>] warn_slowpath_common+0x80/0x98
    [ 3236.368044]  [<ffffffff81060a65>] ? __try_stop_module+0x0/0x58
    [ 3236.368049]  [<ffffffff81036f4f>] warn_slowpath_fmt+0x41/0x43
    [ 3236.368054]  [<ffffffff81060a65>] ? __try_stop_module+0x0/0x58
    [ 3236.368059]  [<ffffffff811e8f78>] driver_unregister+0x36/0x6f
    [ 3236.368066]  [<ffffffffa004aa44>] vme_unregister_driver+0xd/0xf [vme]
    [ 3236.368072]  [<ffffffffa00616c8>] vme_user_exit+0x10/0x1e [vme_user]
    [ 3236.368076]  [<ffffffff810612c1>] sys_delete_module+0x1ba/0x226
    [ 3236.368082]  [<ffffffff812d6e14>] ? do_page_fault+0x25d/0x28a
    [ 3236.368088]  [<ffffffff8100202b>] system_call_fastpath+0x16/0x1b
    [ 3236.368092] ---[ end trace cab6d88ebc44c1de ]---
    
    The appended fixes it by returning the appropriate error code in module_init
    whenever something goes wrong, thus cancelling the insertion of the module.
    
    Signed-off-by: Emilio G. Cota <cota@braap.org>
    Acked-by: Martyn Welch <martyn.welch@ge.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/vme/devices/vme_user.c b/drivers/staging/vme/devices/vme_user.c
index cbe2e11d9af7..a6f61162af3f 100644
--- a/drivers/staging/vme/devices/vme_user.c
+++ b/drivers/staging/vme/devices/vme_user.c
@@ -611,6 +611,7 @@ static int __init vme_user_init(void)
 	if (bus_num == 0) {
 		printk(KERN_ERR "%s: No cards, skipping registration\n",
 			driver_name);
+		retval = -ENODEV;
 		goto err_nocard;
 	}
 
@@ -629,6 +630,7 @@ static int __init vme_user_init(void)
 	if (ids == NULL) {
 		printk(KERN_ERR "%s: Unable to allocate ID table\n",
 			driver_name);
+		retval = -ENOMEM;
 		goto err_id;
 	}
 

commit 886953e9b70bcb6913716b49bdf21b69450a7cd6
Author: Emilio G. Cota <cota@braap.org>
Date:   Fri Nov 12 11:14:07 2010 +0000

    staging: vme: style: convert '&(foo)' to '&foo'
    
    done with
    find . -name '*.c' | xargs perl -p -i -e 's/&\(([^()]+)\)/&$1/g'
    
    Signed-off-by: Emilio G. Cota <cota@braap.org>
    Acked-by: Martyn Welch <martyn.welch@ge.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/vme/devices/vme_user.c b/drivers/staging/vme/devices/vme_user.c
index 71bbc526626c..cbe2e11d9af7 100644
--- a/drivers/staging/vme/devices/vme_user.c
+++ b/drivers/staging/vme/devices/vme_user.c
@@ -470,9 +470,9 @@ static int vme_user_ioctl(struct inode *inode, struct file *file,
 			 *	to userspace as they are
 			 */
 			retval = vme_master_get(image[minor].resource,
-				&(master.enable), &(master.vme_addr),
-				&(master.size), &(master.aspace),
-				&(master.cycle), &(master.dwidth));
+				&master.enable, &master.vme_addr,
+				&master.size, &master.aspace,
+				&master.cycle, &master.dwidth);
 
 			copied = copy_to_user((char *)arg, &master,
 				sizeof(struct vme_master));
@@ -514,9 +514,9 @@ static int vme_user_ioctl(struct inode *inode, struct file *file,
 			 *	to userspace as they are
 			 */
 			retval = vme_slave_get(image[minor].resource,
-				&(slave.enable), &(slave.vme_addr),
-				&(slave.size), &pci_addr, &(slave.aspace),
-				&(slave.cycle));
+				&slave.enable, &slave.vme_addr,
+				&slave.size, &pci_addr, &slave.aspace,
+				&slave.cycle);
 
 			copied = copy_to_user((char *)arg, &slave,
 				sizeof(struct vme_slave));
@@ -683,7 +683,7 @@ static int __init vme_user_probe(struct device *dev, int cur_bus, int cur_slot)
 	for (i = 0; i < VME_DEVS; i++) {
 		image[i].kern_buf = NULL;
 		image[i].pci_buf = 0;
-		sema_init(&(image[i].sem), 1);
+		sema_init(&image[i].sem, 1);
 		image[i].device = NULL;
 		image[i].resource = NULL;
 		image[i].users = 0;
@@ -727,7 +727,7 @@ static int __init vme_user_probe(struct device *dev, int cur_bus, int cur_slot)
 		}
 		image[i].size_buf = PCI_BUF_SIZE;
 		image[i].kern_buf = vme_alloc_consistent(image[i].resource,
-			image[i].size_buf, &(image[i].pci_buf));
+			image[i].size_buf, &image[i].pci_buf);
 		if (image[i].kern_buf == NULL) {
 			printk(KERN_WARNING "Unable to allocate memory for "
 				"buffer\n");

commit 0f0800f17a60816141f138a422477dc936262c42
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Sep 7 14:33:47 2010 +0000

    staging: Bulk convert the semaphore mess
    
    init_MUTEX(_LOCKED) and DECLARE_MUTEX are going away. Bulk convert
    staging users.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/vme/devices/vme_user.c b/drivers/staging/vme/devices/vme_user.c
index 8f77bd24630c..71bbc526626c 100644
--- a/drivers/staging/vme/devices/vme_user.c
+++ b/drivers/staging/vme/devices/vme_user.c
@@ -683,7 +683,7 @@ static int __init vme_user_probe(struct device *dev, int cur_bus, int cur_slot)
 	for (i = 0; i < VME_DEVS; i++) {
 		image[i].kern_buf = NULL;
 		image[i].pci_buf = 0;
-		init_MUTEX(&(image[i].sem));
+		sema_init(&(image[i].sem), 1);
 		image[i].device = NULL;
 		image[i].resource = NULL;
 		image[i].users = 0;

commit 8e2394a981b9258db47f8e223a550d46c6d40cc8
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Sun Jul 11 23:18:52 2010 +0200

    Staging: autoconvert trivial BKL users to private mutex
    
    All these files use the big kernel lock in a trivial
    way to serialize their private file operations,
    typically resulting from an earlier semi-automatic
    pushdown from VFS.
    
    None of these drivers appears to want to lock against
    other code, and they all use the BKL as the top-level
    lock in their file operations, meaning that there
    is no lock-order inversion problem.
    
    Consequently, we can remove the BKL completely,
    replacing it with a per-file mutex in every case.
    Using a scripted approach means we can avoid
    typos.
    
    file=$1
    name=$2
    if grep -q lock_kernel ${file} ; then
        if grep -q 'include.*linux.mutex.h' ${file} ; then
                sed -i '/include.*<linux\/smp_lock.h>/d' ${file}
        else
                sed -i 's/include.*<linux\/smp_lock.h>.*$/include <linux\/mutex.h>/g' ${file}
        fi
        sed -i ${file} \
            -e "/^#include.*linux.mutex.h/,$ {
                    1,/^\(static\|int\|long\)/ {
                         /^\(static\|int\|long\)/istatic DEFINE_MUTEX(${name}_mutex);
    
    } }"  \
        -e "s/\(un\)*lock_kernel\>[ ]*()/mutex_\1lock(\&${name}_mutex)/g" \
        -e '/[      ]*cycle_kernel_lock();/d'
    else
        sed -i -e '/include.*\<smp_lock.h\>/d' ${file}  \
                    -e '/cycle_kernel_lock()/d'
    fi
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/vme/devices/vme_user.c b/drivers/staging/vme/devices/vme_user.c
index 326991c7d47b..8f77bd24630c 100644
--- a/drivers/staging/vme/devices/vme_user.c
+++ b/drivers/staging/vme/devices/vme_user.c
@@ -31,7 +31,7 @@
 #include <linux/slab.h>
 #include <linux/spinlock.h>
 #include <linux/syscalls.h>
-#include <linux/smp_lock.h>
+#include <linux/mutex.h>
 #include <linux/types.h>
 
 #include <linux/io.h>
@@ -40,6 +40,7 @@
 #include "../vme.h"
 #include "vme_user.h"
 
+static DEFINE_MUTEX(vme_user_mutex);
 static char driver_name[] = "vme_user";
 
 static int bus[USER_BUS_MAX];
@@ -559,9 +560,9 @@ vme_user_unlocked_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 {
 	int ret;
 
-	lock_kernel();
+	mutex_lock(&vme_user_mutex);
 	ret = vme_user_ioctl(file->f_path.dentry->d_inode, file, cmd, arg);
-	unlock_kernel();
+	mutex_unlock(&vme_user_mutex);
 
 	return ret;
 }

commit 45f9f018967c3fc112a03a99a8fdfad3621407a7
Author: Nanakos Chrysostomos <nanakos@wired-net.gr>
Date:   Fri May 28 10:54:45 2010 +0000

    Staging: vme: devices: vme_user.c: Fix checkpatch.pl issues.
    
    Fix resolves checkpatch.pl issues for vme_user.c file.
    
    Signed-off-by: Nanakos Chrysostomos <nanakos@wired-net.gr>
    Signed-off-by: Martyn Welch <martyn.welch@ge.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/vme/devices/vme_user.c b/drivers/staging/vme/devices/vme_user.c
index bc16fc070fd3..326991c7d47b 100644
--- a/drivers/staging/vme/devices/vme_user.c
+++ b/drivers/staging/vme/devices/vme_user.c
@@ -34,8 +34,8 @@
 #include <linux/smp_lock.h>
 #include <linux/types.h>
 
-#include <asm/io.h>
-#include <asm/uaccess.h>
+#include <linux/io.h>
+#include <linux/uaccess.h>
 
 #include "../vme.h"
 #include "vme_user.h"
@@ -48,19 +48,19 @@ static int bus_num;
 /* Currently Documentation/devices.txt defines the following for VME:
  *
  * 221 char	VME bus
- * 		  0 = /dev/bus/vme/m0		First master image
- * 		  1 = /dev/bus/vme/m1		Second master image
- * 		  2 = /dev/bus/vme/m2		Third master image
- * 		  3 = /dev/bus/vme/m3		Fourth master image
- * 		  4 = /dev/bus/vme/s0		First slave image
- * 		  5 = /dev/bus/vme/s1		Second slave image
- * 		  6 = /dev/bus/vme/s2		Third slave image
- * 		  7 = /dev/bus/vme/s3		Fourth slave image
- * 		  8 = /dev/bus/vme/ctl		Control
+ *		  0 = /dev/bus/vme/m0		First master image
+ *		  1 = /dev/bus/vme/m1		Second master image
+ *		  2 = /dev/bus/vme/m2		Third master image
+ *		  3 = /dev/bus/vme/m3		Fourth master image
+ *		  4 = /dev/bus/vme/s0		First slave image
+ *		  5 = /dev/bus/vme/s1		Second slave image
+ *		  6 = /dev/bus/vme/s2		Third slave image
+ *		  7 = /dev/bus/vme/s3		Fourth slave image
+ *		  8 = /dev/bus/vme/ctl		Control
  *
- * 		It is expected that all VME bus drivers will use the
- * 		same interface.  For interface documentation see
- * 		http://www.vmelinux.org/.
+ *		It is expected that all VME bus drivers will use the
+ *		same interface.  For interface documentation see
+ *		http://www.vmelinux.org/.
  *
  * However the VME driver at http://www.vmelinux.org/ is rather old and doesn't
  * even support the tsi148 chipset (which has 8 master and 8 slave windows).
@@ -137,12 +137,12 @@ static int __init vme_user_probe(struct device *, int, int);
 static int __exit vme_user_remove(struct device *, int, int);
 
 static struct file_operations vme_user_fops = {
-        .open = vme_user_open,
-        .release = vme_user_release,
-        .read = vme_user_read,
-        .write = vme_user_write,
-        .llseek = vme_user_llseek,
-        .unlocked_ioctl = vme_user_unlocked_ioctl,
+	.open = vme_user_open,
+	.release = vme_user_release,
+	.read = vme_user_read,
+	.write = vme_user_write,
+	.llseek = vme_user_llseek,
+	.unlocked_ioctl = vme_user_unlocked_ioctl,
 };
 
 
@@ -151,13 +151,13 @@ static struct file_operations vme_user_fops = {
  */
 static void reset_counters(void)
 {
-        statistics.reads = 0;
-        statistics.writes = 0;
-        statistics.ioctls = 0;
-        statistics.irqs = 0;
-        statistics.berrs = 0;
-        statistics.dmaErrors = 0;
-        statistics.timeouts = 0;
+	statistics.reads = 0;
+	statistics.writes = 0;
+	statistics.ioctls = 0;
+	statistics.irqs = 0;
+	statistics.berrs = 0;
+	statistics.dmaErrors = 0;
+	statistics.timeouts = 0;
 }
 
 static int vme_user_open(struct inode *inode, struct file *file)
@@ -216,21 +216,20 @@ static ssize_t resource_to_user(int minor, char __user *buf, size_t count,
 		/* We copy to kernel buffer */
 		copied = vme_master_read(image[minor].resource,
 			image[minor].kern_buf, count, *ppos);
-		if (copied < 0) {
+		if (copied < 0)
 			return (int)copied;
-		}
 
 		retval = __copy_to_user(buf, image[minor].kern_buf,
 			(unsigned long)copied);
 		if (retval != 0) {
 			copied = (copied - retval);
-			printk("User copy failed\n");
+			printk(KERN_INFO "User copy failed\n");
 			return -EINVAL;
 		}
 
 	} else {
 		/* XXX Need to write this */
-		printk("Currently don't support large transfers\n");
+		printk(KERN_INFO "Currently don't support large transfers\n");
 		/* Map in pages from userspace */
 
 		/* Call vme_master_read to do the transfer */
@@ -264,7 +263,7 @@ static ssize_t resource_from_user(unsigned int minor, const char *buf,
 			image[minor].kern_buf, copied, *ppos);
 	} else {
 		/* XXX Need to write this */
-		printk("Currently don't support large transfers\n");
+		printk(KERN_INFO "Currently don't support large transfers\n");
 		/* Map in pages from userspace */
 
 		/* Call vme_master_write to do the transfer */
@@ -313,7 +312,7 @@ static ssize_t buffer_from_user(unsigned int minor, const char *buf,
 }
 
 static ssize_t vme_user_read(struct file *file, char *buf, size_t count,
-			loff_t * ppos)
+			loff_t *ppos)
 {
 	unsigned int minor = MINOR(file->f_dentry->d_inode->i_rdev);
 	ssize_t retval;
@@ -337,7 +336,7 @@ static ssize_t vme_user_read(struct file *file, char *buf, size_t count,
 	else
 		okcount = count;
 
-	switch (type[minor]){
+	switch (type[minor]) {
 	case MASTER_MINOR:
 		retval = resource_to_user(minor, buf, okcount, ppos);
 		break;
@@ -380,7 +379,7 @@ static ssize_t vme_user_write(struct file *file, const char *buf, size_t count,
 	else
 		okcount = count;
 
-	switch (type[minor]){
+	switch (type[minor]) {
 	case MASTER_MINOR:
 		retval = resource_from_user(minor, buf, okcount, ppos);
 		break;
@@ -571,7 +570,7 @@ vme_user_unlocked_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 /*
  * Unallocate a previously allocated buffer
  */
-static void buf_unalloc (int num)
+static void buf_unalloc(int num)
 {
 	if (image[num].kern_buf) {
 #ifdef VME_DEBUG
@@ -594,8 +593,8 @@ static void buf_unalloc (int num)
 }
 
 static struct vme_driver vme_user_driver = {
-        .name = driver_name,
-        .probe = vme_user_probe,
+	.name = driver_name,
+	.probe = vme_user_probe,
 	.remove = vme_user_remove,
 };
 
@@ -770,16 +769,16 @@ static int __init vme_user_probe(struct device *dev, int cur_bus, int cur_slot)
 	}
 
 	/* Add sysfs Entries */
-	for (i=0; i<VME_DEVS; i++) {
+	for (i = 0; i < VME_DEVS; i++) {
 		switch (type[i]) {
 		case MASTER_MINOR:
-			sprintf(name,"bus/vme/m%%d");
+			sprintf(name, "bus/vme/m%%d");
 			break;
 		case CONTROL_MINOR:
-			sprintf(name,"bus/vme/ctl");
+			sprintf(name, "bus/vme/ctl");
 			break;
 		case SLAVE_MINOR:
-			sprintf(name,"bus/vme/s%%d");
+			sprintf(name, "bus/vme/s%%d");
 			break;
 		default:
 			err = -EINVAL;
@@ -790,9 +789,9 @@ static int __init vme_user_probe(struct device *dev, int cur_bus, int cur_slot)
 		image[i].device =
 			device_create(vme_user_sysfs_class, NULL,
 				MKDEV(VME_MAJOR, i), NULL, name,
-				(type[i] == SLAVE_MINOR)? i - (MASTER_MAX + 1) : i);
+				(type[i] == SLAVE_MINOR) ? i - (MASTER_MAX + 1) : i);
 		if (IS_ERR(image[i].device)) {
-			printk("%s: Error creating sysfs device\n",
+			printk(KERN_INFO "%s: Error creating sysfs device\n",
 				driver_name);
 			err = PTR_ERR(image[i].device);
 			goto err_sysfs;
@@ -804,7 +803,7 @@ static int __init vme_user_probe(struct device *dev, int cur_bus, int cur_slot)
 	/* Ensure counter set correcty to destroy all sysfs devices */
 	i = VME_DEVS;
 err_sysfs:
-	while (i > 0){
+	while (i > 0) {
 		i--;
 		device_destroy(vme_user_sysfs_class, MKDEV(VME_MAJOR, i));
 	}
@@ -845,9 +844,8 @@ static int __exit vme_user_remove(struct device *dev, int cur_bus, int cur_slot)
 	int i;
 
 	/* Remove sysfs Entries */
-	for(i=0; i<VME_DEVS; i++) {
+	for (i = 0; i < VME_DEVS; i++)
 		device_destroy(vme_user_sysfs_class, MKDEV(VME_MAJOR, i));
-	}
 	class_destroy(vme_user_sysfs_class);
 
 	for (i = MASTER_MINOR; i < (MASTER_MAX + 1); i++)

commit b1f2ac07636aadee5cb077fc7e830908b00fcaae
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Tue Apr 27 20:15:07 2010 +0200

    Staging: push down BKL into ioctl functions
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/vme/devices/vme_user.c b/drivers/staging/vme/devices/vme_user.c
index 1ab9a985dfb9..bc16fc070fd3 100644
--- a/drivers/staging/vme/devices/vme_user.c
+++ b/drivers/staging/vme/devices/vme_user.c
@@ -31,6 +31,7 @@
 #include <linux/slab.h>
 #include <linux/spinlock.h>
 #include <linux/syscalls.h>
+#include <linux/smp_lock.h>
 #include <linux/types.h>
 
 #include <asm/io.h>
@@ -130,8 +131,7 @@ static int vme_user_release(struct inode *, struct file *);
 static ssize_t vme_user_read(struct file *, char *, size_t, loff_t *);
 static ssize_t vme_user_write(struct file *, const char *, size_t, loff_t *);
 static loff_t vme_user_llseek(struct file *, loff_t, int);
-static int vme_user_ioctl(struct inode *, struct file *, unsigned int,
-	unsigned long);
+static long vme_user_unlocked_ioctl(struct file *, unsigned int, unsigned long);
 
 static int __init vme_user_probe(struct device *, int, int);
 static int __exit vme_user_remove(struct device *, int, int);
@@ -142,7 +142,7 @@ static struct file_operations vme_user_fops = {
         .read = vme_user_read,
         .write = vme_user_write,
         .llseek = vme_user_llseek,
-        .ioctl = vme_user_ioctl,
+        .unlocked_ioctl = vme_user_unlocked_ioctl,
 };
 
 
@@ -555,6 +555,18 @@ static int vme_user_ioctl(struct inode *inode, struct file *file,
 	return -EINVAL;
 }
 
+static long
+vme_user_unlocked_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
+{
+	int ret;
+
+	lock_kernel();
+	ret = vme_user_ioctl(file->f_path.dentry->d_inode, file, cmd, arg);
+	unlock_kernel();
+
+	return ret;
+}
+
 
 /*
  * Unallocate a previously allocated buffer

commit 5a0e3ad6af8660be21ca98a971cd00f331318c05
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Mar 24 17:04:11 2010 +0900

    include cleanup: Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h
    
    percpu.h is included by sched.h and module.h and thus ends up being
    included when building most .c files.  percpu.h includes slab.h which
    in turn includes gfp.h making everything defined by the two files
    universally available and complicating inclusion dependencies.
    
    percpu.h -> slab.h dependency is about to be removed.  Prepare for
    this change by updating users of gfp and slab facilities include those
    headers directly instead of assuming availability.  As this conversion
    needs to touch large number of source files, the following script is
    used as the basis of conversion.
    
      http://userweb.kernel.org/~tj/misc/slabh-sweep.py
    
    The script does the followings.
    
    * Scan files for gfp and slab usages and update includes such that
      only the necessary includes are there.  ie. if only gfp is used,
      gfp.h, if slab is used, slab.h.
    
    * When the script inserts a new include, it looks at the include
      blocks and try to put the new include such that its order conforms
      to its surrounding.  It's put in the include block which contains
      core kernel includes, in the same order that the rest are ordered -
      alphabetical, Christmas tree, rev-Xmas-tree or at the end if there
      doesn't seem to be any matching order.
    
    * If the script can't find a place to put a new include (mostly
      because the file doesn't have fitting include block), it prints out
      an error message indicating which .h file needs to be added to the
      file.
    
    The conversion was done in the following steps.
    
    1. The initial automatic conversion of all .c files updated slightly
       over 4000 files, deleting around 700 includes and adding ~480 gfp.h
       and ~3000 slab.h inclusions.  The script emitted errors for ~400
       files.
    
    2. Each error was manually checked.  Some didn't need the inclusion,
       some needed manual addition while adding it to implementation .h or
       embedding .c file was more appropriate for others.  This step added
       inclusions to around 150 files.
    
    3. The script was run again and the output was compared to the edits
       from #2 to make sure no file was left behind.
    
    4. Several build tests were done and a couple of problems were fixed.
       e.g. lib/decompress_*.c used malloc/free() wrappers around slab
       APIs requiring slab.h to be added manually.
    
    5. The script was run on all .h files but without automatically
       editing them as sprinkling gfp.h and slab.h inclusions around .h
       files could easily lead to inclusion dependency hell.  Most gfp.h
       inclusion directives were ignored as stuff from gfp.h was usually
       wildly available and often used in preprocessor macros.  Each
       slab.h inclusion directive was examined and added manually as
       necessary.
    
    6. percpu.h was updated not to include slab.h.
    
    7. Build test were done on the following configurations and failures
       were fixed.  CONFIG_GCOV_KERNEL was turned off for all tests (as my
       distributed build env didn't work with gcov compiles) and a few
       more options had to be turned off depending on archs to make things
       build (like ipr on powerpc/64 which failed due to missing writeq).
    
       * x86 and x86_64 UP and SMP allmodconfig and a custom test config.
       * powerpc and powerpc64 SMP allmodconfig
       * sparc and sparc64 SMP allmodconfig
       * ia64 SMP allmodconfig
       * s390 SMP allmodconfig
       * alpha SMP allmodconfig
       * um on x86_64 SMP allmodconfig
    
    8. percpu.h modifications were reverted so that it could be applied as
       a separate patch and serve as bisection point.
    
    Given the fact that I had only a couple of failures from tests on step
    6, I'm fairly confident about the coverage of this conversion patch.
    If there is a breakage, it's likely to be something in one of the arch
    headers which should be easily discoverable easily on most builds of
    the specific arch.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Guess-its-ok-by: Christoph Lameter <cl@linux-foundation.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Lee Schermerhorn <Lee.Schermerhorn@hp.com>

diff --git a/drivers/staging/vme/devices/vme_user.c b/drivers/staging/vme/devices/vme_user.c
index c60c80fb241d..1ab9a985dfb9 100644
--- a/drivers/staging/vme/devices/vme_user.c
+++ b/drivers/staging/vme/devices/vme_user.c
@@ -28,6 +28,7 @@
 #include <linux/pagemap.h>
 #include <linux/pci.h>
 #include <linux/semaphore.h>
+#include <linux/slab.h>
 #include <linux/spinlock.h>
 #include <linux/syscalls.h>
 #include <linux/types.h>

commit 33e920d9ebaddbc9cf51cf6e1de7baa8d7b8d6dd
Author: Arthur Benilov <arthur.benilov@iba-group.com>
Date:   Tue Feb 16 15:41:21 2010 +0100

    Staging: vme: Allocate memory buffers for master windows
    
    For VME device I/O operations on master windows the user driver tends
    to use kern_buf buffer array which is not allocated. This causes an error
    when reading from master window device files.
    
    Signed-off-by: Arthur Benilov <arthur.benilov@iba-group.com>
    Signed-off-by: Vincent Bossier <vincent.bossier@iba-group.com>
    Acked-by: Martyn Welch <martyn.welch@ge.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/vme/devices/vme_user.c b/drivers/staging/vme/devices/vme_user.c
index 0d404f1a27f4..c60c80fb241d 100644
--- a/drivers/staging/vme/devices/vme_user.c
+++ b/drivers/staging/vme/devices/vme_user.c
@@ -738,6 +738,14 @@ static int __init vme_user_probe(struct device *dev, int cur_bus, int cur_slot)
 				"resource\n");
 			goto err_master;
 		}
+		image[i].size_buf = PCI_BUF_SIZE;
+		image[i].kern_buf = kmalloc(image[i].size_buf, GFP_KERNEL);
+		if (image[i].kern_buf == NULL) {
+			printk(KERN_WARNING "Unable to allocate memory for "
+				"master window buffers\n");
+			err = -ENOMEM;
+			goto err_master_buf;
+		}
 	}
 
 	/* Create sysfs entries - on udev systems this creates the dev files */
@@ -791,6 +799,9 @@ static int __init vme_user_probe(struct device *dev, int cur_bus, int cur_slot)
 
 	/* Ensure counter set correcty to unalloc all master windows */
 	i = MASTER_MAX + 1;
+err_master_buf:
+	for (i = MASTER_MINOR; i < (MASTER_MAX + 1); i++)
+		kfree(image[i].kern_buf);
 err_master:
 	while (i > MASTER_MINOR) {
 		i--;
@@ -826,6 +837,9 @@ static int __exit vme_user_remove(struct device *dev, int cur_bus, int cur_slot)
 	}
 	class_destroy(vme_user_sysfs_class);
 
+	for (i = MASTER_MINOR; i < (MASTER_MAX + 1); i++)
+		kfree(image[i].kern_buf);
+
 	for (i = SLAVE_MINOR; i < (SLAVE_MAX + 1); i++) {
 		vme_slave_set(image[i].resource, 0, 0, 0, 0, VME_A32, 0);
 		vme_slave_free(image[i].resource);

commit 5188d74cc4597a63a0907b8996ca0a2d36f1b970
Author: Arthur Benilov <arthur.benilov@iba-group.com>
Date:   Tue Feb 16 15:40:58 2010 +0100

    Staging: vme: Use A24 when requesting slave resource
    
    When requesting slave resources A16 addressing mode flag is used to find
    available windows. Since the ca91cx42 bridge only supports two A16 slave windows
    but four are requested, the driver fails to initialize. The flag has been
    changed to A24, which is supported by all slave windows.
    
    Signed-off-by: Arthur Benilov <arthur.benilov@iba-group.com>
    Signed-off-by: Vincent Bossier <vincent.bossier@iba-group.com>
    Acked-by: Martyn Welch <martyn.welch@ge.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/vme/devices/vme_user.c b/drivers/staging/vme/devices/vme_user.c
index ddecbe5105b9..0d404f1a27f4 100644
--- a/drivers/staging/vme/devices/vme_user.c
+++ b/drivers/staging/vme/devices/vme_user.c
@@ -701,8 +701,12 @@ static int __init vme_user_probe(struct device *dev, int cur_bus, int cur_slot)
 	/* Request slave resources and allocate buffers (128kB wide) */
 	for (i = SLAVE_MINOR; i < (SLAVE_MAX + 1); i++) {
 		/* XXX Need to properly request attributes */
+		/* For ca91cx42 bridge there are only two slave windows
+		 * supporting A16 addressing, so we request A24 supported
+		 * by all windows.
+		 */
 		image[i].resource = vme_slave_request(vme_user_bridge,
-			VME_A16, VME_SCT);
+			VME_A24, VME_SCT);
 		if (image[i].resource == NULL) {
 			printk(KERN_WARNING "Unable to allocate slave "
 				"resource\n");

commit 877de4b4866f1cc0a25a4d67d3927304556f5d1f
Author: Arthur Benilov <arthur.benilov@iba-group.com>
Date:   Tue Feb 16 15:40:30 2010 +0100

    Staging: vme: llseek support in user driver
    
    Provide vme_user_llseek() implementation.
    
    Signed-off-by: Arthur Benilov <arthur.benilov@iba-group.com>
    Signed-off-by: Vincent Bossier <vincent.bossier@iba-group.com>
    Acked-by: Martyn Welch <martyn.welch@ge.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/vme/devices/vme_user.c b/drivers/staging/vme/devices/vme_user.c
index 48d46cadb13f..ddecbe5105b9 100644
--- a/drivers/staging/vme/devices/vme_user.c
+++ b/drivers/staging/vme/devices/vme_user.c
@@ -400,8 +400,39 @@ static ssize_t vme_user_write(struct file *file, const char *buf, size_t count,
 
 static loff_t vme_user_llseek(struct file *file, loff_t off, int whence)
 {
-	printk(KERN_ERR "Llseek currently incomplete\n");
-	return -EINVAL;
+	loff_t absolute = -1;
+	unsigned int minor = MINOR(file->f_dentry->d_inode->i_rdev);
+	size_t image_size;
+
+	down(&image[minor].sem);
+	image_size = vme_get_size(image[minor].resource);
+
+	switch (whence) {
+	case SEEK_SET:
+		absolute = off;
+		break;
+	case SEEK_CUR:
+		absolute = file->f_pos + off;
+		break;
+	case SEEK_END:
+		absolute = image_size + off;
+		break;
+	default:
+		up(&image[minor].sem);
+		return -EINVAL;
+		break;
+	}
+
+	if ((absolute < 0) || (absolute >= image_size)) {
+		up(&image[minor].sem);
+		return -EINVAL;
+	}
+
+	file->f_pos = absolute;
+
+	up(&image[minor].sem);
+
+	return absolute;
 }
 
 /*

commit 66bd8db52ab48e7189e02d4bf1f23109cc1ede70
Author: Martyn Welch <martyn.welch@ge.com>
Date:   Thu Feb 18 15:12:52 2010 +0000

    Staging: vme: Renaming following split of GE Fanuc joint venture
    
    This patch corrects author email addresses and Copyright notices as a
    result of the split up of the GE Fanuc joint venture.
    
    Signed-off-by: Martyn Welch <martyn.welch@gefanuc.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/vme/devices/vme_user.c b/drivers/staging/vme/devices/vme_user.c
index 2159540d9383..48d46cadb13f 100644
--- a/drivers/staging/vme/devices/vme_user.c
+++ b/drivers/staging/vme/devices/vme_user.c
@@ -1,8 +1,8 @@
 /*
  * VMEbus User access driver
  *
- * Author: Martyn Welch <martyn.welch@gefanuc.com>
- * Copyright 2008 GE Fanuc Intelligent Platforms Embedded Systems, Inc.
+ * Author: Martyn Welch <martyn.welch@ge.com>
+ * Copyright 2008 GE Intelligent Platforms Embedded Systems, Inc.
  *
  * Based on work by:
  *   Tom Armistead and Ajit Prem
@@ -818,7 +818,7 @@ MODULE_PARM_DESC(bus, "Enumeration of VMEbus to which the driver is connected");
 module_param_array(bus, int, &bus_num, 0);
 
 MODULE_DESCRIPTION("VME User Space Access Driver");
-MODULE_AUTHOR("Martyn Welch <martyn.welch@gefanuc.com");
+MODULE_AUTHOR("Martyn Welch <martyn.welch@ge.com");
 MODULE_LICENSE("GPL");
 
 module_init(vme_user_init);

commit 51616e21066d040988a33effa82d4ef37fd60959
Author: Martyn Welch <martyn.welch@gefanuc.com>
Date:   Tue Dec 15 08:42:43 2009 +0000

    Staging: vme: Correct vme_user error message typo
    
    Correction of erroneous error message in vme_user.c.
    
    Signed-off-by: Martyn Welch <martyn.welch@gefanuc.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/vme/devices/vme_user.c b/drivers/staging/vme/devices/vme_user.c
index e228942ee081..2159540d9383 100644
--- a/drivers/staging/vme/devices/vme_user.c
+++ b/drivers/staging/vme/devices/vme_user.c
@@ -574,8 +574,8 @@ static int __init vme_user_init(void)
 	 * in future revisions if that ever becomes necessary.
 	 */
 	if (bus_num > USER_BUS_MAX) {
-		printk(KERN_ERR "%s: Driver only able to handle %d PIO2 "
-			"Cards\n", driver_name, USER_BUS_MAX);
+		printk(KERN_ERR "%s: Driver only able to handle %d buses\n",
+			driver_name, USER_BUS_MAX);
 		bus_num = USER_BUS_MAX;
 	}
 

commit beb9ccc635433065a099b75dc8b22caf0844014a
Author: Martyn Welch <martyn.welch@gefanuc.com>
Date:   Thu Oct 29 16:34:48 2009 +0000

    staging: vme: correct array overflow
    
    Eric Sesterhenn noticed that vme_user is overflowing an array used by
    sprintf. Use a bigger array.
    
    CC: Eric Sesterhenn <eric.sesterhenn@lsexperts.de>
    Signed-off-by: Martyn Welch <martyn.welch@gefanuc.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/vme/devices/vme_user.c b/drivers/staging/vme/devices/vme_user.c
index dc9be4778fe5..e228942ee081 100644
--- a/drivers/staging/vme/devices/vme_user.c
+++ b/drivers/staging/vme/devices/vme_user.c
@@ -624,7 +624,7 @@ static int __init vme_user_init(void)
 static int __init vme_user_probe(struct device *dev, int cur_bus, int cur_slot)
 {
 	int i, err;
-	char name[8];
+	char name[12];
 
 	/* Save pointer to the bridge device */
 	if (vme_user_bridge != NULL) {

commit 6884bb09244498bfa67a99737f33b638d8eae450
Author: Huang Weiyi <weiyi.huang@gmail.com>
Date:   Thu Sep 17 21:25:49 2009 +0800

    Staging: vme: remove unused #include <linux/version.h>
    
    Remove unused #include <linux/version.h>('s) in
      drivers/staging/vme/bridges/vme_ca91cx42.c
      drivers/staging/vme/bridges/vme_tsi148.c
      drivers/staging/vme/devices/vme_user.c
      drivers/staging/vme/vme.c
    
    Signed-off-by: Huang Weiyi <weiyi.huang@gmail.com>
    Acked-by: Martyn Welch <martyn.welch@gefanuc.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/vme/devices/vme_user.c b/drivers/staging/vme/devices/vme_user.c
index 78912883d153..dc9be4778fe5 100644
--- a/drivers/staging/vme/devices/vme_user.c
+++ b/drivers/staging/vme/devices/vme_user.c
@@ -31,7 +31,6 @@
 #include <linux/spinlock.h>
 #include <linux/syscalls.h>
 #include <linux/types.h>
-#include <linux/version.h>
 
 #include <asm/io.h>
 #include <asm/uaccess.h>

commit 238add523bf9c89db1a191599fff2770af55e0fd
Author: Martyn Welch <martyn.welch@gefanuc.com>
Date:   Tue Aug 11 14:37:15 2009 +0100

    Staging: Update VME vme_user module
    
    * Add ifdef wrapper to vme_user.h
     * Correct Initialisation routine
     * Add remove routine to correct probe routine
     * Remove old test routines
    
    Signed-off-by: Martyn Welch <martyn.welch@gefanuc.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/vme/devices/vme_user.c b/drivers/staging/vme/devices/vme_user.c
index 10294ab1c404..78912883d153 100644
--- a/drivers/staging/vme/devices/vme_user.c
+++ b/drivers/staging/vme/devices/vme_user.c
@@ -39,6 +39,11 @@
 #include "../vme.h"
 #include "vme_user.h"
 
+static char driver_name[] = "vme_user";
+
+static int bus[USER_BUS_MAX];
+static int bus_num;
+
 /* Currently Documentation/devices.txt defines the following for VME:
  *
  * 221 char	VME bus
@@ -65,6 +70,10 @@
  * defined above and try to support at least some of the interface from
  * http://www.vmelinux.org/ as an alternative drive can be written providing a
  * saner interface later.
+ *
+ * The vmelinux.org driver never supported slave images, the devices reserved
+ * for slaves were repurposed to support all 8 master images on the UniverseII!
+ * We shall support 4 masters and 4 slaves with this driver.
  */
 #define VME_MAJOR	221	/* VME Major Device Number */
 #define VME_DEVS	9	/* Number of dev entries */
@@ -107,7 +116,6 @@ struct cdev *vme_user_cdev;		/* Character device */
 struct class *vme_user_sysfs_class;	/* Sysfs class */
 struct device *vme_user_bridge;		/* Pointer to the bridge device */
 
-static char driver_name[] = "vme_user";
 
 static const int type[VME_DEVS] = {	MASTER_MINOR,	MASTER_MINOR,
 					MASTER_MINOR,	MASTER_MINOR,
@@ -125,7 +133,8 @@ static loff_t vme_user_llseek(struct file *, loff_t, int);
 static int vme_user_ioctl(struct inode *, struct file *, unsigned int,
 	unsigned long);
 
-static int __init vme_user_probe(struct device *dev);
+static int __init vme_user_probe(struct device *, int, int);
+static int __exit vme_user_remove(struct device *, int, int);
 
 static struct file_operations vme_user_fops = {
         .open = vme_user_open,
@@ -151,61 +160,6 @@ static void reset_counters(void)
         statistics.timeouts = 0;
 }
 
-void lmcall(int monitor)
-{
-	printk("Caught Location Monitor %d access\n", monitor);
-}
-
-static void tests(void)
-{
-	struct vme_resource *dma_res;
-	struct vme_dma_list *dma_list;
-	struct vme_dma_attr *pattern_attr, *vme_attr;
-
-	int retval;
-	unsigned int data;
-
-	printk("Running VME DMA test\n");
-	dma_res = vme_request_dma(vme_user_bridge);
-	dma_list = vme_new_dma_list(dma_res);
-	pattern_attr = vme_dma_pattern_attribute(0x0,
-		VME_DMA_PATTERN_WORD |
-			VME_DMA_PATTERN_INCREMENT);
-	vme_attr = vme_dma_vme_attribute(0x10000, VME_A32,
-		VME_SCT, VME_D32);
-	retval = vme_dma_list_add(dma_list, pattern_attr,
-		vme_attr, 0x10000);
-#if 0
-	vme_dma_free_attribute(vme_attr);
-	vme_attr = vme_dma_vme_attribute(0x20000, VME_A32,
-		VME_SCT, VME_D32);
-	retval = vme_dma_list_add(dma_list, pattern_attr,
-		vme_attr, 0x10000);
-#endif
-	retval = vme_dma_list_exec(dma_list);
-	vme_dma_free_attribute(pattern_attr);
-	vme_dma_free_attribute(vme_attr);
-	vme_dma_list_free(dma_list);
-#if 0
-	printk("Generating a VME interrupt\n");
-	vme_generate_irq(dma_res, 0x3, 0xaa);
-	printk("Interrupt returned\n");
-#endif
-	vme_dma_free(dma_res);
-
-	/* Attempt RMW */
-	data = vme_master_rmw(image[0].resource, 0x80000000, 0x00000000,
-		0x80000000, 0);
-	printk("RMW returned 0x%8.8x\n", data);
-
-
-	/* Location Monitor */
-	printk("vme_lm_set:%d\n", vme_lm_set(vme_user_bridge, 0x60000, VME_A32, VME_SCT | VME_USER | VME_DATA));
-	printk("vme_lm_attach:%d\n", vme_lm_attach(vme_user_bridge, 0, lmcall));
-
-	printk("Board in VME slot:%d\n", vme_slot_get(vme_user_bridge));
-}
-
 static int vme_user_open(struct inode *inode, struct file *file)
 {
 	int err;
@@ -451,57 +405,118 @@ static loff_t vme_user_llseek(struct file *file, loff_t off, int whence)
 	return -EINVAL;
 }
 
+/*
+ * The ioctls provided by the old VME access method (the one at vmelinux.org)
+ * are most certainly wrong as the effectively push the registers layout
+ * through to user space. Given that the VME core can handle multiple bridges,
+ * with different register layouts this is most certainly not the way to go.
+ *
+ * We aren't using the structures defined in the Motorola driver either - these
+ * are also quite low level, however we should use the definitions that have
+ * already been defined.
+ */
 static int vme_user_ioctl(struct inode *inode, struct file *file,
 	unsigned int cmd, unsigned long arg)
 {
+	struct vme_master master;
+	struct vme_slave slave;
+	unsigned long copied;
 	unsigned int minor = MINOR(inode->i_rdev);
-#if 0
-	int ret_val;
-#endif
-	unsigned long copyRet;
-	vme_slave_t slave;
+	int retval;
+	dma_addr_t pci_addr;
 
 	statistics.ioctls++;
+
 	switch (type[minor]) {
 	case CONTROL_MINOR:
 		break;
 	case MASTER_MINOR:
-		break;
-	case SLAVE_MINOR:
 		switch (cmd) {
-		case VME_SET_SLAVE:
+		case VME_GET_MASTER:
+			memset(&master, 0, sizeof(struct vme_master));
+
+			/* XXX	We do not want to push aspace, cycle and width
+			 *	to userspace as they are
+			 */
+			retval = vme_master_get(image[minor].resource,
+				&(master.enable), &(master.vme_addr),
+				&(master.size), &(master.aspace),
+				&(master.cycle), &(master.dwidth));
+
+			copied = copy_to_user((char *)arg, &master,
+				sizeof(struct vme_master));
+			if (copied != 0) {
+				printk(KERN_WARNING "Partial copy to "
+					"userspace\n");
+				return -EFAULT;
+			}
 
-			copyRet = copy_from_user(&slave, (char *)arg,
-				sizeof(slave));
-			if (copyRet != 0) {
+			return retval;
+			break;
+
+		case VME_SET_MASTER:
+
+			copied = copy_from_user(&master, (char *)arg,
+				sizeof(master));
+			if (copied != 0) {
 				printk(KERN_WARNING "Partial copy from "
 					"userspace\n");
 				return -EFAULT;
 			}
 
-			return vme_slave_set(image[minor].resource,
-				slave.enable, slave.vme_addr, slave.size,
-				image[minor].pci_buf, slave.aspace,
-				slave.cycle);
+			/* XXX	We do not want to push aspace, cycle and width
+			 *	to userspace as they are
+			 */
+			return vme_master_set(image[minor].resource,
+				master.enable, master.vme_addr, master.size,
+				master.aspace, master.cycle, master.dwidth);
 
 			break;
-#if 0
+		}
+		break;
+	case SLAVE_MINOR:
+		switch (cmd) {
 		case VME_GET_SLAVE:
-			vme_slave_t slave;
+			memset(&slave, 0, sizeof(struct vme_slave));
+
+			/* XXX	We do not want to push aspace, cycle and width
+			 *	to userspace as they are
+			 */
+			retval = vme_slave_get(image[minor].resource,
+				&(slave.enable), &(slave.vme_addr),
+				&(slave.size), &pci_addr, &(slave.aspace),
+				&(slave.cycle));
+
+			copied = copy_to_user((char *)arg, &slave,
+				sizeof(struct vme_slave));
+			if (copied != 0) {
+				printk(KERN_WARNING "Partial copy to "
+					"userspace\n");
+				return -EFAULT;
+			}
+
+			return retval;
+			break;
 
-			ret_val = vme_slave_get(minor, &iRegs);
+		case VME_SET_SLAVE:
 
-			copyRet = copy_to_user((char *)arg, &slave,
+			copied = copy_from_user(&slave, (char *)arg,
 				sizeof(slave));
-			if (copyRet != 0) {
-				printk(KERN_WARNING "Partial copy to "
+			if (copied != 0) {
+				printk(KERN_WARNING "Partial copy from "
 					"userspace\n");
 				return -EFAULT;
 			}
 
-			return ret_val;
+			/* XXX	We do not want to push aspace, cycle and width
+			 *	to userspace as they are
+			 */
+			return vme_slave_set(image[minor].resource,
+				slave.enable, slave.vme_addr, slave.size,
+				image[minor].pci_buf, slave.aspace,
+				slave.cycle);
+
 			break;
-#endif
 		}
 		break;
 	}
@@ -538,36 +553,87 @@ static void buf_unalloc (int num)
 static struct vme_driver vme_user_driver = {
         .name = driver_name,
         .probe = vme_user_probe,
+	.remove = vme_user_remove,
 };
 
 
-/*
- * In this simple access driver, the old behaviour is being preserved as much
- * as practical. We will therefore reserve the buffers and request the images
- * here so that we don't have to do it later.
- */
-static int __init vme_bridge_init(void)
+static int __init vme_user_init(void)
 {
-	int retval;
+	int retval = 0;
+	int i;
+	struct vme_device_id *ids;
+
 	printk(KERN_INFO "VME User Space Access Driver\n");
-	printk("vme_user_driver:%p\n", &vme_user_driver);
+
+	if (bus_num == 0) {
+		printk(KERN_ERR "%s: No cards, skipping registration\n",
+			driver_name);
+		goto err_nocard;
+	}
+
+	/* Let's start by supporting one bus, we can support more than one
+	 * in future revisions if that ever becomes necessary.
+	 */
+	if (bus_num > USER_BUS_MAX) {
+		printk(KERN_ERR "%s: Driver only able to handle %d PIO2 "
+			"Cards\n", driver_name, USER_BUS_MAX);
+		bus_num = USER_BUS_MAX;
+	}
+
+
+	/* Dynamically create the bind table based on module parameters */
+	ids = kmalloc(sizeof(struct vme_device_id) * (bus_num + 1), GFP_KERNEL);
+	if (ids == NULL) {
+		printk(KERN_ERR "%s: Unable to allocate ID table\n",
+			driver_name);
+		goto err_id;
+	}
+
+	memset(ids, 0, (sizeof(struct vme_device_id) * (bus_num + 1)));
+
+	for (i = 0; i < bus_num; i++) {
+		ids[i].bus = bus[i];
+		/*
+		 * We register the driver against the slot occupied by *this*
+		 * card, since it's really a low level way of controlling
+		 * the VME bridge
+		 */
+		ids[i].slot = VME_SLOT_CURRENT;
+	}
+
+	vme_user_driver.bind_table = ids;
+
 	retval = vme_register_driver(&vme_user_driver);
-	printk("vme_register_driver returned %d\n", retval);
+	if (retval != 0)
+		goto err_reg;
+
+	return retval;
+
+	vme_unregister_driver(&vme_user_driver);
+err_reg:
+	kfree(ids);
+err_id:
+err_nocard:
 	return retval;
 }
 
 /*
- * This structure gets passed a device, this should be the device created at
- * registration.
+ * In this simple access driver, the old behaviour is being preserved as much
+ * as practical. We will therefore reserve the buffers and request the images
+ * here so that we don't have to do it later.
  */
-static int __init vme_user_probe(struct device *dev)
+static int __init vme_user_probe(struct device *dev, int cur_bus, int cur_slot)
 {
 	int i, err;
 	char name[8];
 
-	printk("Running vme_user_probe()\n");
-
-	/* Pointer to the bridge device */
+	/* Save pointer to the bridge device */
+	if (vme_user_bridge != NULL) {
+		printk(KERN_ERR "%s: Driver can only be loaded for 1 device\n",
+			driver_name);
+		err = -EINVAL;
+		goto err_dev;
+	}
 	vme_user_bridge = dev;
 
 	/* Initialise descriptors */
@@ -610,7 +676,7 @@ static int __init vme_user_probe(struct device *dev)
 		if (image[i].resource == NULL) {
 			printk(KERN_WARNING "Unable to allocate slave "
 				"resource\n");
-			goto err_buf;
+			goto err_slave;
 		}
 		image[i].size_buf = PCI_BUF_SIZE;
 		image[i].kern_buf = vme_alloc_consistent(image[i].resource,
@@ -621,7 +687,7 @@ static int __init vme_user_probe(struct device *dev)
 			image[i].pci_buf = 0;
 			vme_slave_free(image[i].resource);
 			err = -ENOMEM;
-			goto err_buf;
+			goto err_slave;
 		}
 	}
 
@@ -636,38 +702,7 @@ static int __init vme_user_probe(struct device *dev)
 		if (image[i].resource == NULL) {
 			printk(KERN_WARNING "Unable to allocate master "
 				"resource\n");
-			goto err_buf;
-		}
-		image[i].size_buf = PAGE_SIZE;
-		image[i].kern_buf = vme_alloc_consistent(image[i].resource,
-			image[i].size_buf, &(image[i].pci_buf));
-		if (image[i].kern_buf == NULL) {
-			printk(KERN_WARNING "Unable to allocate memory for "
-				"buffer\n");
-			image[i].pci_buf = 0;
-			vme_master_free(image[i].resource);
-			err = -ENOMEM;
-			goto err_buf;
-		}
-	}
-
-	/* Setup some debug windows */
-	for (i = SLAVE_MINOR; i < (SLAVE_MAX + 1); i++) {
-		err = vme_slave_set(image[i].resource, 1, 0x4000*(i-4),
-			0x4000, image[i].pci_buf, VME_A16,
-			VME_SCT | VME_SUPER | VME_USER | VME_PROG | VME_DATA);
-		if (err != 0) {
-			printk(KERN_WARNING "Failed to configure window\n");
-			goto err_buf;
-		}
-	}
-	for (i = MASTER_MINOR; i < (MASTER_MAX + 1); i++) {
-		err = vme_master_set(image[i].resource, 1,
-			(0x10000 + (0x10000*i)), 0x10000,
-			VME_A32, VME_SCT | VME_USER | VME_DATA, VME_D32);
-		if (err != 0) {
-			printk(KERN_WARNING "Failed to configure window\n");
-			goto err_buf;
+			goto err_master;
 		}
 	}
 
@@ -709,11 +744,6 @@ static int __init vme_user_probe(struct device *dev)
 		}
 	}
 
-	/* XXX Run tests */
-	/*
-	tests();
-	*/
-
 	return 0;
 
 	/* Ensure counter set correcty to destroy all sysfs devices */
@@ -725,12 +755,21 @@ static int __init vme_user_probe(struct device *dev)
 	}
 	class_destroy(vme_user_sysfs_class);
 
-	/* Ensure counter set correcty to unalloc all slave buffers */
+	/* Ensure counter set correcty to unalloc all master windows */
+	i = MASTER_MAX + 1;
+err_master:
+	while (i > MASTER_MINOR) {
+		i--;
+		vme_master_free(image[i].resource);
+	}
+
+	/*
+	 * Ensure counter set correcty to unalloc all slave windows and buffers
+	 */
 	i = SLAVE_MAX + 1;
-err_buf:
-	while (i > SLAVE_MINOR){
+err_slave:
+	while (i > SLAVE_MINOR) {
 		i--;
-		vme_slave_set(image[i].resource, 0, 0, 0, 0, VME_A32, 0);
 		vme_slave_free(image[i].resource);
 		buf_unalloc(i);
 	}
@@ -739,10 +778,11 @@ static int __init vme_user_probe(struct device *dev)
 err_char:
 	unregister_chrdev_region(MKDEV(VME_MAJOR, 0), VME_DEVS);
 err_region:
+err_dev:
 	return err;
 }
 
-static void __exit vme_bridge_exit(void)
+static int __exit vme_user_remove(struct device *dev, int cur_bus, int cur_slot)
 {
 	int i;
 
@@ -753,6 +793,8 @@ static void __exit vme_bridge_exit(void)
 	class_destroy(vme_user_sysfs_class);
 
 	for (i = SLAVE_MINOR; i < (SLAVE_MAX + 1); i++) {
+		vme_slave_set(image[i].resource, 0, 0, 0, 0, VME_A32, 0);
+		vme_slave_free(image[i].resource);
 		buf_unalloc(i);
 	}
 
@@ -761,11 +803,24 @@ static void __exit vme_bridge_exit(void)
 
 	/* Unregiser the major and minor device numbers */
 	unregister_chrdev_region(MKDEV(VME_MAJOR, 0), VME_DEVS);
+
+	return 0;
 }
 
+static void __exit vme_user_exit(void)
+{
+	vme_unregister_driver(&vme_user_driver);
+
+	kfree(vme_user_driver.bind_table);
+}
+
+
+MODULE_PARM_DESC(bus, "Enumeration of VMEbus to which the driver is connected");
+module_param_array(bus, int, &bus_num, 0);
+
 MODULE_DESCRIPTION("VME User Space Access Driver");
 MODULE_AUTHOR("Martyn Welch <martyn.welch@gefanuc.com");
 MODULE_LICENSE("GPL");
 
-module_init(vme_bridge_init);
-module_exit(vme_bridge_exit);
+module_init(vme_user_init);
+module_exit(vme_user_exit);

commit f00a86d98a1ec3e99d352cda926fab767ba43b1f
Author: Martyn Welch <martyn.welch@gefanuc.com>
Date:   Fri Jul 31 09:28:17 2009 +0100

    Staging: vme: add VME userspace driver
    
    Adds a VME userspace access driver
    
    Signed-off-by: Martyn Welch <martyn.welch@gefanuc.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/vme/devices/vme_user.c b/drivers/staging/vme/devices/vme_user.c
new file mode 100644
index 000000000000..10294ab1c404
--- /dev/null
+++ b/drivers/staging/vme/devices/vme_user.c
@@ -0,0 +1,771 @@
+/*
+ * VMEbus User access driver
+ *
+ * Author: Martyn Welch <martyn.welch@gefanuc.com>
+ * Copyright 2008 GE Fanuc Intelligent Platforms Embedded Systems, Inc.
+ *
+ * Based on work by:
+ *   Tom Armistead and Ajit Prem
+ *     Copyright 2004 Motorola Inc.
+ *
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#include <linux/cdev.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/dma-mapping.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/ioctl.h>
+#include <linux/kernel.h>
+#include <linux/mm.h>
+#include <linux/module.h>
+#include <linux/pagemap.h>
+#include <linux/pci.h>
+#include <linux/semaphore.h>
+#include <linux/spinlock.h>
+#include <linux/syscalls.h>
+#include <linux/types.h>
+#include <linux/version.h>
+
+#include <asm/io.h>
+#include <asm/uaccess.h>
+
+#include "../vme.h"
+#include "vme_user.h"
+
+/* Currently Documentation/devices.txt defines the following for VME:
+ *
+ * 221 char	VME bus
+ * 		  0 = /dev/bus/vme/m0		First master image
+ * 		  1 = /dev/bus/vme/m1		Second master image
+ * 		  2 = /dev/bus/vme/m2		Third master image
+ * 		  3 = /dev/bus/vme/m3		Fourth master image
+ * 		  4 = /dev/bus/vme/s0		First slave image
+ * 		  5 = /dev/bus/vme/s1		Second slave image
+ * 		  6 = /dev/bus/vme/s2		Third slave image
+ * 		  7 = /dev/bus/vme/s3		Fourth slave image
+ * 		  8 = /dev/bus/vme/ctl		Control
+ *
+ * 		It is expected that all VME bus drivers will use the
+ * 		same interface.  For interface documentation see
+ * 		http://www.vmelinux.org/.
+ *
+ * However the VME driver at http://www.vmelinux.org/ is rather old and doesn't
+ * even support the tsi148 chipset (which has 8 master and 8 slave windows).
+ * We'll run with this or now as far as possible, however it probably makes
+ * sense to get rid of the old mappings and just do everything dynamically.
+ *
+ * So for now, we'll restrict the driver to providing 4 masters and 4 slaves as
+ * defined above and try to support at least some of the interface from
+ * http://www.vmelinux.org/ as an alternative drive can be written providing a
+ * saner interface later.
+ */
+#define VME_MAJOR	221	/* VME Major Device Number */
+#define VME_DEVS	9	/* Number of dev entries */
+
+#define MASTER_MINOR	0
+#define MASTER_MAX	3
+#define SLAVE_MINOR	4
+#define SLAVE_MAX	7
+#define CONTROL_MINOR	8
+
+#define PCI_BUF_SIZE  0x20000	/* Size of one slave image buffer */
+
+/*
+ * Structure to handle image related parameters.
+ */
+typedef struct {
+	void __iomem *kern_buf;	/* Buffer address in kernel space */
+	dma_addr_t pci_buf;	/* Buffer address in PCI address space */
+	unsigned long long size_buf;	/* Buffer size */
+	struct semaphore sem;	/* Semaphore for locking image */
+	struct device *device;	/* Sysfs device */
+	struct vme_resource *resource;	/* VME resource */
+	int users;		/* Number of current users */
+} image_desc_t;
+static image_desc_t image[VME_DEVS];
+
+typedef struct {
+	unsigned long reads;
+	unsigned long writes;
+	unsigned long ioctls;
+	unsigned long irqs;
+	unsigned long berrs;
+	unsigned long dmaErrors;
+	unsigned long timeouts;
+	unsigned long external;
+} driver_stats_t;
+static driver_stats_t statistics;
+
+struct cdev *vme_user_cdev;		/* Character device */
+struct class *vme_user_sysfs_class;	/* Sysfs class */
+struct device *vme_user_bridge;		/* Pointer to the bridge device */
+
+static char driver_name[] = "vme_user";
+
+static const int type[VME_DEVS] = {	MASTER_MINOR,	MASTER_MINOR,
+					MASTER_MINOR,	MASTER_MINOR,
+					SLAVE_MINOR,	SLAVE_MINOR,
+					SLAVE_MINOR,	SLAVE_MINOR,
+					CONTROL_MINOR
+				};
+
+
+static int vme_user_open(struct inode *, struct file *);
+static int vme_user_release(struct inode *, struct file *);
+static ssize_t vme_user_read(struct file *, char *, size_t, loff_t *);
+static ssize_t vme_user_write(struct file *, const char *, size_t, loff_t *);
+static loff_t vme_user_llseek(struct file *, loff_t, int);
+static int vme_user_ioctl(struct inode *, struct file *, unsigned int,
+	unsigned long);
+
+static int __init vme_user_probe(struct device *dev);
+
+static struct file_operations vme_user_fops = {
+        .open = vme_user_open,
+        .release = vme_user_release,
+        .read = vme_user_read,
+        .write = vme_user_write,
+        .llseek = vme_user_llseek,
+        .ioctl = vme_user_ioctl,
+};
+
+
+/*
+ * Reset all the statistic counters
+ */
+static void reset_counters(void)
+{
+        statistics.reads = 0;
+        statistics.writes = 0;
+        statistics.ioctls = 0;
+        statistics.irqs = 0;
+        statistics.berrs = 0;
+        statistics.dmaErrors = 0;
+        statistics.timeouts = 0;
+}
+
+void lmcall(int monitor)
+{
+	printk("Caught Location Monitor %d access\n", monitor);
+}
+
+static void tests(void)
+{
+	struct vme_resource *dma_res;
+	struct vme_dma_list *dma_list;
+	struct vme_dma_attr *pattern_attr, *vme_attr;
+
+	int retval;
+	unsigned int data;
+
+	printk("Running VME DMA test\n");
+	dma_res = vme_request_dma(vme_user_bridge);
+	dma_list = vme_new_dma_list(dma_res);
+	pattern_attr = vme_dma_pattern_attribute(0x0,
+		VME_DMA_PATTERN_WORD |
+			VME_DMA_PATTERN_INCREMENT);
+	vme_attr = vme_dma_vme_attribute(0x10000, VME_A32,
+		VME_SCT, VME_D32);
+	retval = vme_dma_list_add(dma_list, pattern_attr,
+		vme_attr, 0x10000);
+#if 0
+	vme_dma_free_attribute(vme_attr);
+	vme_attr = vme_dma_vme_attribute(0x20000, VME_A32,
+		VME_SCT, VME_D32);
+	retval = vme_dma_list_add(dma_list, pattern_attr,
+		vme_attr, 0x10000);
+#endif
+	retval = vme_dma_list_exec(dma_list);
+	vme_dma_free_attribute(pattern_attr);
+	vme_dma_free_attribute(vme_attr);
+	vme_dma_list_free(dma_list);
+#if 0
+	printk("Generating a VME interrupt\n");
+	vme_generate_irq(dma_res, 0x3, 0xaa);
+	printk("Interrupt returned\n");
+#endif
+	vme_dma_free(dma_res);
+
+	/* Attempt RMW */
+	data = vme_master_rmw(image[0].resource, 0x80000000, 0x00000000,
+		0x80000000, 0);
+	printk("RMW returned 0x%8.8x\n", data);
+
+
+	/* Location Monitor */
+	printk("vme_lm_set:%d\n", vme_lm_set(vme_user_bridge, 0x60000, VME_A32, VME_SCT | VME_USER | VME_DATA));
+	printk("vme_lm_attach:%d\n", vme_lm_attach(vme_user_bridge, 0, lmcall));
+
+	printk("Board in VME slot:%d\n", vme_slot_get(vme_user_bridge));
+}
+
+static int vme_user_open(struct inode *inode, struct file *file)
+{
+	int err;
+	unsigned int minor = MINOR(inode->i_rdev);
+
+	down(&image[minor].sem);
+	/* Only allow device to be opened if a resource is allocated */
+	if (image[minor].resource == NULL) {
+		printk(KERN_ERR "No resources allocated for device\n");
+		err = -EINVAL;
+		goto err_res;
+	}
+
+	/* Increment user count */
+	image[minor].users++;
+
+	up(&image[minor].sem);
+
+	return 0;
+
+err_res:
+	up(&image[minor].sem);
+
+	return err;
+}
+
+static int vme_user_release(struct inode *inode, struct file *file)
+{
+	unsigned int minor = MINOR(inode->i_rdev);
+
+	down(&image[minor].sem);
+
+	/* Decrement user count */
+	image[minor].users--;
+
+	up(&image[minor].sem);
+
+	return 0;
+}
+
+/*
+ * We are going ot alloc a page during init per window for small transfers.
+ * Small transfers will go VME -> buffer -> user space. Larger (more than a
+ * page) transfers will lock the user space buffer into memory and then
+ * transfer the data directly into the user space buffers.
+ */
+static ssize_t resource_to_user(int minor, char __user *buf, size_t count,
+	loff_t *ppos)
+{
+	ssize_t retval;
+	ssize_t copied = 0;
+
+	if (count <= image[minor].size_buf) {
+		/* We copy to kernel buffer */
+		copied = vme_master_read(image[minor].resource,
+			image[minor].kern_buf, count, *ppos);
+		if (copied < 0) {
+			return (int)copied;
+		}
+
+		retval = __copy_to_user(buf, image[minor].kern_buf,
+			(unsigned long)copied);
+		if (retval != 0) {
+			copied = (copied - retval);
+			printk("User copy failed\n");
+			return -EINVAL;
+		}
+
+	} else {
+		/* XXX Need to write this */
+		printk("Currently don't support large transfers\n");
+		/* Map in pages from userspace */
+
+		/* Call vme_master_read to do the transfer */
+		return -EINVAL;
+	}
+
+	return copied;
+}
+
+/*
+ * We are going ot alloc a page during init per window for small transfers.
+ * Small transfers will go user space -> buffer -> VME. Larger (more than a
+ * page) transfers will lock the user space buffer into memory and then
+ * transfer the data directly from the user space buffers out to VME.
+ */
+static ssize_t resource_from_user(unsigned int minor, const char *buf,
+	size_t count, loff_t *ppos)
+{
+	ssize_t retval;
+	ssize_t copied = 0;
+
+	if (count <= image[minor].size_buf) {
+		retval = __copy_from_user(image[minor].kern_buf, buf,
+			(unsigned long)count);
+		if (retval != 0)
+			copied = (copied - retval);
+		else
+			copied = count;
+
+		copied = vme_master_write(image[minor].resource,
+			image[minor].kern_buf, copied, *ppos);
+	} else {
+		/* XXX Need to write this */
+		printk("Currently don't support large transfers\n");
+		/* Map in pages from userspace */
+
+		/* Call vme_master_write to do the transfer */
+		return -EINVAL;
+	}
+
+	return copied;
+}
+
+static ssize_t buffer_to_user(unsigned int minor, char __user *buf,
+	size_t count, loff_t *ppos)
+{
+	void __iomem *image_ptr;
+	ssize_t retval;
+
+	image_ptr = image[minor].kern_buf + *ppos;
+
+	retval = __copy_to_user(buf, image_ptr, (unsigned long)count);
+	if (retval != 0) {
+		retval = (count - retval);
+		printk(KERN_WARNING "Partial copy to userspace\n");
+	} else
+		retval = count;
+
+	/* Return number of bytes successfully read */
+	return retval;
+}
+
+static ssize_t buffer_from_user(unsigned int minor, const char *buf,
+	size_t count, loff_t *ppos)
+{
+	void __iomem *image_ptr;
+	size_t retval;
+
+	image_ptr = image[minor].kern_buf + *ppos;
+
+	retval = __copy_from_user(image_ptr, buf, (unsigned long)count);
+	if (retval != 0) {
+		retval = (count - retval);
+		printk(KERN_WARNING "Partial copy to userspace\n");
+	} else
+		retval = count;
+
+	/* Return number of bytes successfully read */
+	return retval;
+}
+
+static ssize_t vme_user_read(struct file *file, char *buf, size_t count,
+			loff_t * ppos)
+{
+	unsigned int minor = MINOR(file->f_dentry->d_inode->i_rdev);
+	ssize_t retval;
+	size_t image_size;
+	size_t okcount;
+
+	down(&image[minor].sem);
+
+	/* XXX Do we *really* want this helper - we can use vme_*_get ? */
+	image_size = vme_get_size(image[minor].resource);
+
+	/* Ensure we are starting at a valid location */
+	if ((*ppos < 0) || (*ppos > (image_size - 1))) {
+		up(&image[minor].sem);
+		return 0;
+	}
+
+	/* Ensure not reading past end of the image */
+	if (*ppos + count > image_size)
+		okcount = image_size - *ppos;
+	else
+		okcount = count;
+
+	switch (type[minor]){
+	case MASTER_MINOR:
+		retval = resource_to_user(minor, buf, okcount, ppos);
+		break;
+	case SLAVE_MINOR:
+		retval = buffer_to_user(minor, buf, okcount, ppos);
+		break;
+	default:
+		retval = -EINVAL;
+	}
+
+	up(&image[minor].sem);
+
+	if (retval > 0)
+		*ppos += retval;
+
+	return retval;
+}
+
+static ssize_t vme_user_write(struct file *file, const char *buf, size_t count,
+			 loff_t *ppos)
+{
+	unsigned int minor = MINOR(file->f_dentry->d_inode->i_rdev);
+	ssize_t retval;
+	size_t image_size;
+	size_t okcount;
+
+	down(&image[minor].sem);
+
+	image_size = vme_get_size(image[minor].resource);
+
+	/* Ensure we are starting at a valid location */
+	if ((*ppos < 0) || (*ppos > (image_size - 1))) {
+		up(&image[minor].sem);
+		return 0;
+	}
+
+	/* Ensure not reading past end of the image */
+	if (*ppos + count > image_size)
+		okcount = image_size - *ppos;
+	else
+		okcount = count;
+
+	switch (type[minor]){
+	case MASTER_MINOR:
+		retval = resource_from_user(minor, buf, okcount, ppos);
+		break;
+	case SLAVE_MINOR:
+		retval = buffer_from_user(minor, buf, okcount, ppos);
+		break;
+	default:
+		retval = -EINVAL;
+	}
+
+	up(&image[minor].sem);
+
+	if (retval > 0)
+		*ppos += retval;
+
+	return retval;
+}
+
+static loff_t vme_user_llseek(struct file *file, loff_t off, int whence)
+{
+	printk(KERN_ERR "Llseek currently incomplete\n");
+	return -EINVAL;
+}
+
+static int vme_user_ioctl(struct inode *inode, struct file *file,
+	unsigned int cmd, unsigned long arg)
+{
+	unsigned int minor = MINOR(inode->i_rdev);
+#if 0
+	int ret_val;
+#endif
+	unsigned long copyRet;
+	vme_slave_t slave;
+
+	statistics.ioctls++;
+	switch (type[minor]) {
+	case CONTROL_MINOR:
+		break;
+	case MASTER_MINOR:
+		break;
+	case SLAVE_MINOR:
+		switch (cmd) {
+		case VME_SET_SLAVE:
+
+			copyRet = copy_from_user(&slave, (char *)arg,
+				sizeof(slave));
+			if (copyRet != 0) {
+				printk(KERN_WARNING "Partial copy from "
+					"userspace\n");
+				return -EFAULT;
+			}
+
+			return vme_slave_set(image[minor].resource,
+				slave.enable, slave.vme_addr, slave.size,
+				image[minor].pci_buf, slave.aspace,
+				slave.cycle);
+
+			break;
+#if 0
+		case VME_GET_SLAVE:
+			vme_slave_t slave;
+
+			ret_val = vme_slave_get(minor, &iRegs);
+
+			copyRet = copy_to_user((char *)arg, &slave,
+				sizeof(slave));
+			if (copyRet != 0) {
+				printk(KERN_WARNING "Partial copy to "
+					"userspace\n");
+				return -EFAULT;
+			}
+
+			return ret_val;
+			break;
+#endif
+		}
+		break;
+	}
+
+	return -EINVAL;
+}
+
+
+/*
+ * Unallocate a previously allocated buffer
+ */
+static void buf_unalloc (int num)
+{
+	if (image[num].kern_buf) {
+#ifdef VME_DEBUG
+		printk(KERN_DEBUG "UniverseII:Releasing buffer at %p\n",
+			image[num].pci_buf);
+#endif
+
+		vme_free_consistent(image[num].resource, image[num].size_buf,
+			image[num].kern_buf, image[num].pci_buf);
+
+		image[num].kern_buf = NULL;
+		image[num].pci_buf = 0;
+		image[num].size_buf = 0;
+
+#ifdef VME_DEBUG
+	} else {
+		printk(KERN_DEBUG "UniverseII: Buffer not allocated\n");
+#endif
+	}
+}
+
+static struct vme_driver vme_user_driver = {
+        .name = driver_name,
+        .probe = vme_user_probe,
+};
+
+
+/*
+ * In this simple access driver, the old behaviour is being preserved as much
+ * as practical. We will therefore reserve the buffers and request the images
+ * here so that we don't have to do it later.
+ */
+static int __init vme_bridge_init(void)
+{
+	int retval;
+	printk(KERN_INFO "VME User Space Access Driver\n");
+	printk("vme_user_driver:%p\n", &vme_user_driver);
+	retval = vme_register_driver(&vme_user_driver);
+	printk("vme_register_driver returned %d\n", retval);
+	return retval;
+}
+
+/*
+ * This structure gets passed a device, this should be the device created at
+ * registration.
+ */
+static int __init vme_user_probe(struct device *dev)
+{
+	int i, err;
+	char name[8];
+
+	printk("Running vme_user_probe()\n");
+
+	/* Pointer to the bridge device */
+	vme_user_bridge = dev;
+
+	/* Initialise descriptors */
+	for (i = 0; i < VME_DEVS; i++) {
+		image[i].kern_buf = NULL;
+		image[i].pci_buf = 0;
+		init_MUTEX(&(image[i].sem));
+		image[i].device = NULL;
+		image[i].resource = NULL;
+		image[i].users = 0;
+	}
+
+	/* Initialise statistics counters */
+	reset_counters();
+
+	/* Assign major and minor numbers for the driver */
+	err = register_chrdev_region(MKDEV(VME_MAJOR, 0), VME_DEVS,
+		driver_name);
+	if (err) {
+		printk(KERN_WARNING "%s: Error getting Major Number %d for "
+		"driver.\n", driver_name, VME_MAJOR);
+		goto err_region;
+	}
+
+	/* Register the driver as a char device */
+	vme_user_cdev = cdev_alloc();
+	vme_user_cdev->ops = &vme_user_fops;
+	vme_user_cdev->owner = THIS_MODULE;
+	err = cdev_add(vme_user_cdev, MKDEV(VME_MAJOR, 0), VME_DEVS);
+	if (err) {
+		printk(KERN_WARNING "%s: cdev_all failed\n", driver_name);
+		goto err_char;
+	}
+
+	/* Request slave resources and allocate buffers (128kB wide) */
+	for (i = SLAVE_MINOR; i < (SLAVE_MAX + 1); i++) {
+		/* XXX Need to properly request attributes */
+		image[i].resource = vme_slave_request(vme_user_bridge,
+			VME_A16, VME_SCT);
+		if (image[i].resource == NULL) {
+			printk(KERN_WARNING "Unable to allocate slave "
+				"resource\n");
+			goto err_buf;
+		}
+		image[i].size_buf = PCI_BUF_SIZE;
+		image[i].kern_buf = vme_alloc_consistent(image[i].resource,
+			image[i].size_buf, &(image[i].pci_buf));
+		if (image[i].kern_buf == NULL) {
+			printk(KERN_WARNING "Unable to allocate memory for "
+				"buffer\n");
+			image[i].pci_buf = 0;
+			vme_slave_free(image[i].resource);
+			err = -ENOMEM;
+			goto err_buf;
+		}
+	}
+
+	/*
+	 * Request master resources allocate page sized buffers for small
+	 * reads and writes
+	 */
+	for (i = MASTER_MINOR; i < (MASTER_MAX + 1); i++) {
+		/* XXX Need to properly request attributes */
+		image[i].resource = vme_master_request(vme_user_bridge,
+			VME_A32, VME_SCT, VME_D32);
+		if (image[i].resource == NULL) {
+			printk(KERN_WARNING "Unable to allocate master "
+				"resource\n");
+			goto err_buf;
+		}
+		image[i].size_buf = PAGE_SIZE;
+		image[i].kern_buf = vme_alloc_consistent(image[i].resource,
+			image[i].size_buf, &(image[i].pci_buf));
+		if (image[i].kern_buf == NULL) {
+			printk(KERN_WARNING "Unable to allocate memory for "
+				"buffer\n");
+			image[i].pci_buf = 0;
+			vme_master_free(image[i].resource);
+			err = -ENOMEM;
+			goto err_buf;
+		}
+	}
+
+	/* Setup some debug windows */
+	for (i = SLAVE_MINOR; i < (SLAVE_MAX + 1); i++) {
+		err = vme_slave_set(image[i].resource, 1, 0x4000*(i-4),
+			0x4000, image[i].pci_buf, VME_A16,
+			VME_SCT | VME_SUPER | VME_USER | VME_PROG | VME_DATA);
+		if (err != 0) {
+			printk(KERN_WARNING "Failed to configure window\n");
+			goto err_buf;
+		}
+	}
+	for (i = MASTER_MINOR; i < (MASTER_MAX + 1); i++) {
+		err = vme_master_set(image[i].resource, 1,
+			(0x10000 + (0x10000*i)), 0x10000,
+			VME_A32, VME_SCT | VME_USER | VME_DATA, VME_D32);
+		if (err != 0) {
+			printk(KERN_WARNING "Failed to configure window\n");
+			goto err_buf;
+		}
+	}
+
+	/* Create sysfs entries - on udev systems this creates the dev files */
+	vme_user_sysfs_class = class_create(THIS_MODULE, driver_name);
+	if (IS_ERR(vme_user_sysfs_class)) {
+		printk(KERN_ERR "Error creating vme_user class.\n");
+		err = PTR_ERR(vme_user_sysfs_class);
+		goto err_class;
+	}
+
+	/* Add sysfs Entries */
+	for (i=0; i<VME_DEVS; i++) {
+		switch (type[i]) {
+		case MASTER_MINOR:
+			sprintf(name,"bus/vme/m%%d");
+			break;
+		case CONTROL_MINOR:
+			sprintf(name,"bus/vme/ctl");
+			break;
+		case SLAVE_MINOR:
+			sprintf(name,"bus/vme/s%%d");
+			break;
+		default:
+			err = -EINVAL;
+			goto err_sysfs;
+			break;
+		}
+
+		image[i].device =
+			device_create(vme_user_sysfs_class, NULL,
+				MKDEV(VME_MAJOR, i), NULL, name,
+				(type[i] == SLAVE_MINOR)? i - (MASTER_MAX + 1) : i);
+		if (IS_ERR(image[i].device)) {
+			printk("%s: Error creating sysfs device\n",
+				driver_name);
+			err = PTR_ERR(image[i].device);
+			goto err_sysfs;
+		}
+	}
+
+	/* XXX Run tests */
+	/*
+	tests();
+	*/
+
+	return 0;
+
+	/* Ensure counter set correcty to destroy all sysfs devices */
+	i = VME_DEVS;
+err_sysfs:
+	while (i > 0){
+		i--;
+		device_destroy(vme_user_sysfs_class, MKDEV(VME_MAJOR, i));
+	}
+	class_destroy(vme_user_sysfs_class);
+
+	/* Ensure counter set correcty to unalloc all slave buffers */
+	i = SLAVE_MAX + 1;
+err_buf:
+	while (i > SLAVE_MINOR){
+		i--;
+		vme_slave_set(image[i].resource, 0, 0, 0, 0, VME_A32, 0);
+		vme_slave_free(image[i].resource);
+		buf_unalloc(i);
+	}
+err_class:
+	cdev_del(vme_user_cdev);
+err_char:
+	unregister_chrdev_region(MKDEV(VME_MAJOR, 0), VME_DEVS);
+err_region:
+	return err;
+}
+
+static void __exit vme_bridge_exit(void)
+{
+	int i;
+
+	/* Remove sysfs Entries */
+	for(i=0; i<VME_DEVS; i++) {
+		device_destroy(vme_user_sysfs_class, MKDEV(VME_MAJOR, i));
+	}
+	class_destroy(vme_user_sysfs_class);
+
+	for (i = SLAVE_MINOR; i < (SLAVE_MAX + 1); i++) {
+		buf_unalloc(i);
+	}
+
+	/* Unregister device driver */
+	cdev_del(vme_user_cdev);
+
+	/* Unregiser the major and minor device numbers */
+	unregister_chrdev_region(MKDEV(VME_MAJOR, 0), VME_DEVS);
+}
+
+MODULE_DESCRIPTION("VME User Space Access Driver");
+MODULE_AUTHOR("Martyn Welch <martyn.welch@gefanuc.com");
+MODULE_LICENSE("GPL");
+
+module_init(vme_bridge_init);
+module_exit(vme_bridge_exit);
