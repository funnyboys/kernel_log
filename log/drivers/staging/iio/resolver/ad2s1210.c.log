commit 5e4f99a6b788047b0b8a7496c2e0c8f372f6edf2
Author: Dragos Bogdan <dragos.bogdan@analog.com>
Date:   Wed Apr 29 10:21:29 2020 +0300

    staging: iio: ad2s1210: Fix SPI reading
    
    If the serial interface is used, the 8-bit address should be latched using
    the rising edge of the WR/FSYNC signal.
    
    This basically means that a CS change is required between the first byte
    sent, and the second one.
    This change splits the single-transfer transfer of 2 bytes into 2 transfers
    with a single byte, and CS change in-between.
    
    Note fixes tag is not accurate, but reflects a point beyond which there
    are too many refactors to make backporting straight forward.
    
    Fixes: b19e9ad5e2cb ("staging:iio:resolver:ad2s1210 general driver cleanup.")
    Signed-off-by: Dragos Bogdan <dragos.bogdan@analog.com>
    Signed-off-by: Alexandru Ardelean <alexandru.ardelean@analog.com>
    Cc: <Stable@vger.kernel.org>
    Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>

diff --git a/drivers/staging/iio/resolver/ad2s1210.c b/drivers/staging/iio/resolver/ad2s1210.c
index 4b25a3a314ed..ed404355ea4c 100644
--- a/drivers/staging/iio/resolver/ad2s1210.c
+++ b/drivers/staging/iio/resolver/ad2s1210.c
@@ -130,17 +130,24 @@ static int ad2s1210_config_write(struct ad2s1210_state *st, u8 data)
 static int ad2s1210_config_read(struct ad2s1210_state *st,
 				unsigned char address)
 {
-	struct spi_transfer xfer = {
-		.len = 2,
-		.rx_buf = st->rx,
-		.tx_buf = st->tx,
+	struct spi_transfer xfers[] = {
+		{
+			.len = 1,
+			.rx_buf = &st->rx[0],
+			.tx_buf = &st->tx[0],
+			.cs_change = 1,
+		}, {
+			.len = 1,
+			.rx_buf = &st->rx[1],
+			.tx_buf = &st->tx[1],
+		},
 	};
 	int ret = 0;
 
 	ad2s1210_set_mode(MOD_CONFIG, st);
 	st->tx[0] = address | AD2S1210_MSB_IS_HIGH;
 	st->tx[1] = AD2S1210_REG_FAULT;
-	ret = spi_sync_transfer(st->sdev, &xfer, 1);
+	ret = spi_sync_transfer(st->sdev, xfers, 2);
 	if (ret < 0)
 		return ret;
 

commit 857ba268f918dec28470c2074e7c69ccad52547e
Author: Chuhong Yuan <hslester96@gmail.com>
Date:   Fri Jul 26 19:07:42 2019 +0800

    staging: iio: ad2s1210: Use device-managed API
    
    Use device-managed API to simplify the code.
    The remove function is redundant now and can
    be deleted.
    
    Signed-off-by: Chuhong Yuan <hslester96@gmail.com>
    Reviewed-by: Alexandru Ardelean <alexandru.ardelean@analog.com>
    Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>

diff --git a/drivers/staging/iio/resolver/ad2s1210.c b/drivers/staging/iio/resolver/ad2s1210.c
index 0c1bd108c386..4b25a3a314ed 100644
--- a/drivers/staging/iio/resolver/ad2s1210.c
+++ b/drivers/staging/iio/resolver/ad2s1210.c
@@ -671,7 +671,7 @@ static int ad2s1210_probe(struct spi_device *spi)
 	indio_dev->num_channels = ARRAY_SIZE(ad2s1210_channels);
 	indio_dev->name = spi_get_device_id(spi)->name;
 
-	ret = iio_device_register(indio_dev);
+	ret = devm_iio_device_register(&spi->dev, indio_dev);
 	if (ret)
 		return ret;
 
@@ -683,15 +683,6 @@ static int ad2s1210_probe(struct spi_device *spi)
 	return 0;
 }
 
-static int ad2s1210_remove(struct spi_device *spi)
-{
-	struct iio_dev *indio_dev = spi_get_drvdata(spi);
-
-	iio_device_unregister(indio_dev);
-
-	return 0;
-}
-
 static const struct of_device_id ad2s1210_of_match[] = {
 	{ .compatible = "adi,ad2s1210", },
 	{ }
@@ -710,7 +701,6 @@ static struct spi_driver ad2s1210_driver = {
 		.of_match_table = of_match_ptr(ad2s1210_of_match),
 	},
 	.probe = ad2s1210_probe,
-	.remove = ad2s1210_remove,
 	.id_table = ad2s1210_id,
 };
 module_spi_driver(ad2s1210_driver);

commit cf344bd67e569b02a6d323a43405ad425396d6ea
Author: Alexandru Ardelean <alexandru.ardelean@analog.com>
Date:   Thu Jun 6 13:34:09 2019 +0300

    staging: iio: ad2s1210: Remove platform data NULL check in probe
    
    The driver only needs to access GPIOs via GPIOLIB. And SPI can be
    configured via device-tree or ACPI.
    
    The platform data is a remnant from another time, and should not cause the
    driver to error out during probing if it is NULL.
    Also, it's not used.
    
    Signed-off-by: Alexandru Ardelean <alexandru.ardelean@analog.com>
    Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>

diff --git a/drivers/staging/iio/resolver/ad2s1210.c b/drivers/staging/iio/resolver/ad2s1210.c
index b6be0bc202f5..0c1bd108c386 100644
--- a/drivers/staging/iio/resolver/ad2s1210.c
+++ b/drivers/staging/iio/resolver/ad2s1210.c
@@ -647,9 +647,6 @@ static int ad2s1210_probe(struct spi_device *spi)
 	struct ad2s1210_state *st;
 	int ret;
 
-	if (!spi->dev.platform_data)
-		return -EINVAL;
-
 	indio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*st));
 	if (!indio_dev)
 		return -ENOMEM;

commit 2506abea7f40ea9d7633828941f25d5c2dab4925
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Apr 2 12:31:55 2019 +0200

    staging: iio: add proper SPDX identifiers to remaining driver files
    
    There are a number of IIO staging drivers that do not have a proper SPDX
    identifier on it.  So fix that up and at the same time, remove the "free
    form" license text, as that's pretty much impossible for any tool to
    parse.
    
    Cc: Lars-Peter Clausen <lars@metafoo.de>
    Cc: Michael Hennerich <Michael.Hennerich@analog.com>
    Cc: Jonathan Cameron <jic23@kernel.org>
    Cc: Hartmut Knaack <knaack.h@gmx.de>
    Cc: Peter Meerwald-Stadler <pmeerw@pmeerw.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/iio/resolver/ad2s1210.c b/drivers/staging/iio/resolver/ad2s1210.c
index cec9d995b3df..b6be0bc202f5 100644
--- a/drivers/staging/iio/resolver/ad2s1210.c
+++ b/drivers/staging/iio/resolver/ad2s1210.c
@@ -1,12 +1,8 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * ad2s1210.c support for the ADI Resolver to Digital Converters: AD2S1210
  *
  * Copyright (c) 2010-2010 Analog Devices Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
  */
 #include <linux/types.h>
 #include <linux/mutex.h>

commit 382c7fce7005b55f0583cf5905758d2b8def803a
Author: Nishad Kamdar <nishadkamdar@gmail.com>
Date:   Wed Oct 31 21:30:36 2018 +0530

    staging: iio: ad2s1210: Add device tree table.
    
    Add device tree table for matching vendor ID.
    
    Note that as the driver is still heavily in flux and there are some
    non obvious aspects to a comprehensive binding, that binding will
    be submitted at a later date (before leaving staging!)
    
    Signed-off-by: Nishad Kamdar <nishadkamdar@gmail.com>
    Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>

diff --git a/drivers/staging/iio/resolver/ad2s1210.c b/drivers/staging/iio/resolver/ad2s1210.c
index 235944189ab0..cec9d995b3df 100644
--- a/drivers/staging/iio/resolver/ad2s1210.c
+++ b/drivers/staging/iio/resolver/ad2s1210.c
@@ -699,6 +699,12 @@ static int ad2s1210_remove(struct spi_device *spi)
 	return 0;
 }
 
+static const struct of_device_id ad2s1210_of_match[] = {
+	{ .compatible = "adi,ad2s1210", },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, ad2s1210_of_match);
+
 static const struct spi_device_id ad2s1210_id[] = {
 	{ "ad2s1210" },
 	{}
@@ -708,6 +714,7 @@ MODULE_DEVICE_TABLE(spi, ad2s1210_id);
 static struct spi_driver ad2s1210_driver = {
 	.driver = {
 		.name = DRV_NAME,
+		.of_match_table = of_match_ptr(ad2s1210_of_match),
 	},
 	.probe = ad2s1210_probe,
 	.remove = ad2s1210_remove,

commit 66dd9e3d5e038f46f2cbecc76a1e970b614dc824
Author: Nishad Kamdar <nishadkamdar@gmail.com>
Date:   Wed Oct 31 21:29:53 2018 +0530

    staging: iio: ad2s1210: Drop the gpioin flag.
    
    Drop gpioin flag which decides how the GPIOs
    are controlled as the GPIOs must be outputs
    for the host as per the datasheet.
    
    Removes need for platform data so that is dropped as well.
    
    Signed-off-by: Nishad Kamdar <nishadkamdar@gmail.com>
    Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>

diff --git a/drivers/staging/iio/resolver/ad2s1210.c b/drivers/staging/iio/resolver/ad2s1210.c
index e2623984b200..235944189ab0 100644
--- a/drivers/staging/iio/resolver/ad2s1210.c
+++ b/drivers/staging/iio/resolver/ad2s1210.c
@@ -20,7 +20,6 @@
 
 #include <linux/iio/iio.h>
 #include <linux/iio/sysfs.h>
-#include "ad2s1210.h"
 
 #define DRV_NAME "ad2s1210"
 
@@ -80,15 +79,7 @@ struct ad2s1210_gpio {
 	unsigned long flags;
 };
 
-static const struct ad2s1210_gpio gpios_in[] = {
-	[AD2S1210_SAMPLE] = { .name = "adi,sample", .flags = GPIOD_IN },
-	[AD2S1210_A0] = { .name = "adi,a0", .flags = GPIOD_IN },
-	[AD2S1210_A1] = { .name = "adi,a1", .flags = GPIOD_IN },
-	[AD2S1210_RES0] = { .name = "adi,res0", .flags = GPIOD_IN },
-	[AD2S1210_RES1] = { .name = "adi,res1", .flags = GPIOD_IN },
-};
-
-static const struct ad2s1210_gpio gpios_out[] = {
+static const struct ad2s1210_gpio gpios[] = {
 	[AD2S1210_SAMPLE] = { .name = "adi,sample", .flags = GPIOD_OUT_LOW },
 	[AD2S1210_A0] = { .name = "adi,a0", .flags = GPIOD_OUT_LOW },
 	[AD2S1210_A1] = { .name = "adi,a1", .flags = GPIOD_OUT_LOW },
@@ -99,7 +90,6 @@ static const struct ad2s1210_gpio gpios_out[] = {
 static const unsigned int ad2s1210_resolution_value[] = { 10, 12, 14, 16 };
 
 struct ad2s1210_state {
-	const struct ad2s1210_platform_data *pdata;
 	struct mutex lock;
 	struct spi_device *sdev;
 	struct gpio_desc *gpios[5];
@@ -180,14 +170,6 @@ int ad2s1210_update_frequency_control_word(struct ad2s1210_state *st)
 	return ad2s1210_config_write(st, fcw);
 }
 
-static unsigned char ad2s1210_read_resolution_pin(struct ad2s1210_state *st)
-{
-	int resolution = (gpiod_get_value(st->gpios[AD2S1210_RES0]) << 1) |
-			  gpiod_get_value(st->gpios[AD2S1210_RES1]);
-
-	return ad2s1210_resolution_value[resolution];
-}
-
 static const int ad2s1210_res_pins[4][2] = {
 	{ 0, 0 }, {0, 1}, {1, 0}, {1, 1}
 };
@@ -333,13 +315,7 @@ static ssize_t ad2s1210_store_control(struct device *dev,
 	}
 	st->resolution =
 		ad2s1210_resolution_value[data & AD2S1210_SET_RESOLUTION];
-	if (st->pdata->gpioin) {
-		data = ad2s1210_read_resolution_pin(st);
-		if (data != st->resolution)
-			dev_warn(dev, "ad2s1210: resolution settings not match\n");
-	} else {
-		ad2s1210_set_resolution_pin(st);
-	}
+	ad2s1210_set_resolution_pin(st);
 	ret = len;
 	st->hysteresis = !!(data & AD2S1210_ENABLE_HYSTERESIS);
 
@@ -395,13 +371,7 @@ static ssize_t ad2s1210_store_resolution(struct device *dev,
 	}
 	st->resolution =
 		ad2s1210_resolution_value[data & AD2S1210_SET_RESOLUTION];
-	if (st->pdata->gpioin) {
-		data = ad2s1210_read_resolution_pin(st);
-		if (data != st->resolution)
-			dev_warn(dev, "ad2s1210: resolution settings not match\n");
-	} else {
-		ad2s1210_set_resolution_pin(st);
-	}
+	ad2s1210_set_resolution_pin(st);
 	ret = len;
 error_ret:
 	mutex_unlock(&st->lock);
@@ -622,10 +592,7 @@ static int ad2s1210_initial(struct ad2s1210_state *st)
 	int ret;
 
 	mutex_lock(&st->lock);
-	if (st->pdata->gpioin)
-		st->resolution = ad2s1210_read_resolution_pin(st);
-	else
-		ad2s1210_set_resolution_pin(st);
+	ad2s1210_set_resolution_pin(st);
 
 	ret = ad2s1210_config_write(st, AD2S1210_REG_CONTROL);
 	if (ret < 0)
@@ -660,19 +627,17 @@ static const struct iio_info ad2s1210_info = {
 
 static int ad2s1210_setup_gpios(struct ad2s1210_state *st)
 {
-	const struct ad2s1210_gpio *pin = st->pdata->gpioin ?
-		&gpios_in[0] : &gpios_out[0];
 	struct spi_device *spi = st->sdev;
 	int i, ret;
 
-	for (i = 0; i < ARRAY_SIZE(gpios_in); i++) {
-		st->gpios[i] = devm_gpiod_get(&spi->dev, pin[i].name,
-					      pin[i].flags);
+	for (i = 0; i < ARRAY_SIZE(gpios); i++) {
+		st->gpios[i] = devm_gpiod_get(&spi->dev, gpios[i].name,
+					      gpios[i].flags);
 		if (IS_ERR(st->gpios[i])) {
 			ret = PTR_ERR(st->gpios[i]);
 			dev_err(&spi->dev,
 				"ad2s1210: failed to request %s GPIO: %d\n",
-				pin[i].name, ret);
+				gpios[i].name, ret);
 			return ret;
 		}
 	}
@@ -693,7 +658,6 @@ static int ad2s1210_probe(struct spi_device *spi)
 	if (!indio_dev)
 		return -ENOMEM;
 	st = iio_priv(indio_dev);
-	st->pdata = spi->dev.platform_data;
 	ret = ad2s1210_setup_gpios(st);
 	if (ret < 0)
 		return ret;

commit f356dc6ec26b3990070ca16ec12a4239e9128bd8
Author: Nishad Kamdar <nishadkamdar@gmail.com>
Date:   Wed Oct 31 21:28:52 2018 +0530

    staging: iio: ad2s1210: Switch to the gpio descriptor interface
    
    Use the gpiod interface instead of the deprecated old non-descriptor
    interface.
    
    Signed-off-by: Nishad Kamdar <nishadkamdar@gmail.com>
    Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>

diff --git a/drivers/staging/iio/resolver/ad2s1210.c b/drivers/staging/iio/resolver/ad2s1210.c
index d4b1c2c010f2..e2623984b200 100644
--- a/drivers/staging/iio/resolver/ad2s1210.c
+++ b/drivers/staging/iio/resolver/ad2s1210.c
@@ -15,7 +15,7 @@
 #include <linux/slab.h>
 #include <linux/sysfs.h>
 #include <linux/delay.h>
-#include <linux/gpio.h>
+#include <linux/gpio/consumer.h>
 #include <linux/module.h>
 
 #include <linux/iio/iio.h>
@@ -67,12 +67,42 @@ enum ad2s1210_mode {
 	MOD_RESERVED,
 };
 
+enum ad2s1210_gpios {
+	AD2S1210_SAMPLE,
+	AD2S1210_A0,
+	AD2S1210_A1,
+	AD2S1210_RES0,
+	AD2S1210_RES1,
+};
+
+struct ad2s1210_gpio {
+	const char *name;
+	unsigned long flags;
+};
+
+static const struct ad2s1210_gpio gpios_in[] = {
+	[AD2S1210_SAMPLE] = { .name = "adi,sample", .flags = GPIOD_IN },
+	[AD2S1210_A0] = { .name = "adi,a0", .flags = GPIOD_IN },
+	[AD2S1210_A1] = { .name = "adi,a1", .flags = GPIOD_IN },
+	[AD2S1210_RES0] = { .name = "adi,res0", .flags = GPIOD_IN },
+	[AD2S1210_RES1] = { .name = "adi,res1", .flags = GPIOD_IN },
+};
+
+static const struct ad2s1210_gpio gpios_out[] = {
+	[AD2S1210_SAMPLE] = { .name = "adi,sample", .flags = GPIOD_OUT_LOW },
+	[AD2S1210_A0] = { .name = "adi,a0", .flags = GPIOD_OUT_LOW },
+	[AD2S1210_A1] = { .name = "adi,a1", .flags = GPIOD_OUT_LOW },
+	[AD2S1210_RES0] = { .name = "adi,res0", .flags = GPIOD_OUT_LOW },
+	[AD2S1210_RES1] = { .name = "adi,res1", .flags = GPIOD_OUT_LOW },
+};
+
 static const unsigned int ad2s1210_resolution_value[] = { 10, 12, 14, 16 };
 
 struct ad2s1210_state {
 	const struct ad2s1210_platform_data *pdata;
 	struct mutex lock;
 	struct spi_device *sdev;
+	struct gpio_desc *gpios[5];
 	unsigned int fclkin;
 	unsigned int fexcit;
 	bool hysteresis;
@@ -91,8 +121,8 @@ static const int ad2s1210_mode_vals[4][2] = {
 static inline void ad2s1210_set_mode(enum ad2s1210_mode mode,
 				     struct ad2s1210_state *st)
 {
-	gpio_set_value(st->pdata->a[0], ad2s1210_mode_vals[mode][0]);
-	gpio_set_value(st->pdata->a[1], ad2s1210_mode_vals[mode][1]);
+	gpiod_set_value(st->gpios[AD2S1210_A0], ad2s1210_mode_vals[mode][0]);
+	gpiod_set_value(st->gpios[AD2S1210_A1], ad2s1210_mode_vals[mode][1]);
 	st->mode = mode;
 }
 
@@ -152,8 +182,8 @@ int ad2s1210_update_frequency_control_word(struct ad2s1210_state *st)
 
 static unsigned char ad2s1210_read_resolution_pin(struct ad2s1210_state *st)
 {
-	int resolution = (gpio_get_value(st->pdata->res[0]) << 1) |
-			  gpio_get_value(st->pdata->res[1]);
+	int resolution = (gpiod_get_value(st->gpios[AD2S1210_RES0]) << 1) |
+			  gpiod_get_value(st->gpios[AD2S1210_RES1]);
 
 	return ad2s1210_resolution_value[resolution];
 }
@@ -164,10 +194,10 @@ static const int ad2s1210_res_pins[4][2] = {
 
 static inline void ad2s1210_set_resolution_pin(struct ad2s1210_state *st)
 {
-	gpio_set_value(st->pdata->res[0],
-		       ad2s1210_res_pins[(st->resolution - 10) / 2][0]);
-	gpio_set_value(st->pdata->res[1],
-		       ad2s1210_res_pins[(st->resolution - 10) / 2][1]);
+	gpiod_set_value(st->gpios[AD2S1210_RES0],
+			ad2s1210_res_pins[(st->resolution - 10) / 2][0]);
+	gpiod_set_value(st->gpios[AD2S1210_RES1],
+			ad2s1210_res_pins[(st->resolution - 10) / 2][1]);
 }
 
 static inline int ad2s1210_soft_reset(struct ad2s1210_state *st)
@@ -401,15 +431,15 @@ static ssize_t ad2s1210_clear_fault(struct device *dev,
 	int ret;
 
 	mutex_lock(&st->lock);
-	gpio_set_value(st->pdata->sample, 0);
+	gpiod_set_value(st->gpios[AD2S1210_SAMPLE], 0);
 	/* delay (2 * tck + 20) nano seconds */
 	udelay(1);
-	gpio_set_value(st->pdata->sample, 1);
+	gpiod_set_value(st->gpios[AD2S1210_SAMPLE], 1);
 	ret = ad2s1210_config_read(st, AD2S1210_REG_FAULT);
 	if (ret < 0)
 		goto error_ret;
-	gpio_set_value(st->pdata->sample, 0);
-	gpio_set_value(st->pdata->sample, 1);
+	gpiod_set_value(st->gpios[AD2S1210_SAMPLE], 0);
+	gpiod_set_value(st->gpios[AD2S1210_SAMPLE], 1);
 error_ret:
 	mutex_unlock(&st->lock);
 
@@ -466,7 +496,7 @@ static int ad2s1210_read_raw(struct iio_dev *indio_dev,
 	s16 vel;
 
 	mutex_lock(&st->lock);
-	gpio_set_value(st->pdata->sample, 0);
+	gpiod_set_value(st->gpios[AD2S1210_SAMPLE], 0);
 	/* delay (6 * tck + 20) nano seconds */
 	udelay(1);
 
@@ -512,7 +542,7 @@ static int ad2s1210_read_raw(struct iio_dev *indio_dev,
 	}
 
 error_ret:
-	gpio_set_value(st->pdata->sample, 1);
+	gpiod_set_value(st->gpios[AD2S1210_SAMPLE], 1);
 	/* delay (2 * tck + 20) nano seconds */
 	udelay(1);
 	mutex_unlock(&st->lock);
@@ -630,30 +660,24 @@ static const struct iio_info ad2s1210_info = {
 
 static int ad2s1210_setup_gpios(struct ad2s1210_state *st)
 {
-	unsigned long flags = st->pdata->gpioin ? GPIOF_DIR_IN : GPIOF_DIR_OUT;
-	struct gpio ad2s1210_gpios[] = {
-		{ st->pdata->sample, GPIOF_DIR_IN, "sample" },
-		{ st->pdata->a[0], flags, "a0" },
-		{ st->pdata->a[1], flags, "a1" },
-		{ st->pdata->res[0], flags, "res0" },
-		{ st->pdata->res[0], flags, "res1" },
-	};
-
-	return gpio_request_array(ad2s1210_gpios, ARRAY_SIZE(ad2s1210_gpios));
-}
-
-static void ad2s1210_free_gpios(struct ad2s1210_state *st)
-{
-	unsigned long flags = st->pdata->gpioin ? GPIOF_DIR_IN : GPIOF_DIR_OUT;
-	struct gpio ad2s1210_gpios[] = {
-		{ st->pdata->sample, GPIOF_DIR_IN, "sample" },
-		{ st->pdata->a[0], flags, "a0" },
-		{ st->pdata->a[1], flags, "a1" },
-		{ st->pdata->res[0], flags, "res0" },
-		{ st->pdata->res[0], flags, "res1" },
-	};
+	const struct ad2s1210_gpio *pin = st->pdata->gpioin ?
+		&gpios_in[0] : &gpios_out[0];
+	struct spi_device *spi = st->sdev;
+	int i, ret;
+
+	for (i = 0; i < ARRAY_SIZE(gpios_in); i++) {
+		st->gpios[i] = devm_gpiod_get(&spi->dev, pin[i].name,
+					      pin[i].flags);
+		if (IS_ERR(st->gpios[i])) {
+			ret = PTR_ERR(st->gpios[i]);
+			dev_err(&spi->dev,
+				"ad2s1210: failed to request %s GPIO: %d\n",
+				pin[i].name, ret);
+			return ret;
+		}
+	}
 
-	gpio_free_array(ad2s1210_gpios, ARRAY_SIZE(ad2s1210_gpios));
+	return 0;
 }
 
 static int ad2s1210_probe(struct spi_device *spi)
@@ -692,7 +716,7 @@ static int ad2s1210_probe(struct spi_device *spi)
 
 	ret = iio_device_register(indio_dev);
 	if (ret)
-		goto error_free_gpios;
+		return ret;
 
 	st->fclkin = spi->max_speed_hz;
 	spi->mode = SPI_MODE_3;
@@ -700,10 +724,6 @@ static int ad2s1210_probe(struct spi_device *spi)
 	ad2s1210_initial(st);
 
 	return 0;
-
-error_free_gpios:
-	ad2s1210_free_gpios(st);
-	return ret;
 }
 
 static int ad2s1210_remove(struct spi_device *spi)
@@ -711,7 +731,6 @@ static int ad2s1210_remove(struct spi_device *spi)
 	struct iio_dev *indio_dev = spi_get_drvdata(spi);
 
 	iio_device_unregister(indio_dev);
-	ad2s1210_free_gpios(iio_priv(indio_dev));
 
 	return 0;
 }

commit 5c93f3ce98b6e5ceda6b2e9c80b071e556fac6f4
Author: Matheus Tavares <matheus.bernardino@usp.br>
Date:   Mon Oct 8 00:29:38 2018 -0300

    staging: iio: ad2s1210: fix 'assignment operator' style checks
    
    This patch fixes all "Assignment operator '=' should be on the previous
    line" checks found in ad2s1210.c with checkpatch.pl.
    
    Signed-off-by: Matheus Tavares <matheus.bernardino@usp.br>
    Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>

diff --git a/drivers/staging/iio/resolver/ad2s1210.c b/drivers/staging/iio/resolver/ad2s1210.c
index ac13b99bd9cb..d4b1c2c010f2 100644
--- a/drivers/staging/iio/resolver/ad2s1210.c
+++ b/drivers/staging/iio/resolver/ad2s1210.c
@@ -301,8 +301,8 @@ static ssize_t ad2s1210_store_control(struct device *dev,
 			"ad2s1210: write control register fail\n");
 		goto error_ret;
 	}
-	st->resolution
-		= ad2s1210_resolution_value[data & AD2S1210_SET_RESOLUTION];
+	st->resolution =
+		ad2s1210_resolution_value[data & AD2S1210_SET_RESOLUTION];
 	if (st->pdata->gpioin) {
 		data = ad2s1210_read_resolution_pin(st);
 		if (data != st->resolution)
@@ -363,8 +363,8 @@ static ssize_t ad2s1210_store_resolution(struct device *dev,
 		dev_err(dev, "ad2s1210: setting resolution fail\n");
 		goto error_ret;
 	}
-	st->resolution
-		= ad2s1210_resolution_value[data & AD2S1210_SET_RESOLUTION];
+	st->resolution =
+		ad2s1210_resolution_value[data & AD2S1210_SET_RESOLUTION];
 	if (st->pdata->gpioin) {
 		data = ad2s1210_read_resolution_pin(st);
 		if (data != st->resolution)

commit 9aa5134ac486b48c4c8ac14571e6034131f040f8
Author: Rodrigo Siqueira <rodrigosiqueiramelo@gmail.com>
Date:   Fri Mar 9 20:46:25 2018 -0300

    staging:iio:ad2s1210: Remove old_data from ad2s1210_state
    
    The variable old_data is a bool type, which only receives the value
    'true' in the function ad2s1210_config_write and ad2s1210_config_read.
    There is no other use for this variable. This patch removes old_data
    from the ad2s1210_state and from all the function that use it.
    
    Signed-off-by: Rodrigo Siqueira <rodrigosiqueiramelo@gmail.com>
    Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>

diff --git a/drivers/staging/iio/resolver/ad2s1210.c b/drivers/staging/iio/resolver/ad2s1210.c
index 79cb56670fc2..ac13b99bd9cb 100644
--- a/drivers/staging/iio/resolver/ad2s1210.c
+++ b/drivers/staging/iio/resolver/ad2s1210.c
@@ -76,7 +76,6 @@ struct ad2s1210_state {
 	unsigned int fclkin;
 	unsigned int fexcit;
 	bool hysteresis;
-	bool old_data;
 	u8 resolution;
 	enum ad2s1210_mode mode;
 	u8 rx[2] ____cacheline_aligned;
@@ -107,7 +106,6 @@ static int ad2s1210_config_write(struct ad2s1210_state *st, u8 data)
 	ret = spi_write(st->sdev, st->tx, 1);
 	if (ret < 0)
 		return ret;
-	st->old_data = true;
 
 	return 0;
 }
@@ -129,7 +127,6 @@ static int ad2s1210_config_read(struct ad2s1210_state *st,
 	ret = spi_sync_transfer(st->sdev, &xfer, 1);
 	if (ret < 0)
 		return ret;
-	st->old_data = true;
 
 	return st->rx[1];
 }

commit a8cf0d829af69e64aa1cbf9bc8816389c5cce5e9
Author: Rodrigo Siqueira <rodrigosiqueiramelo@gmail.com>
Date:   Fri Mar 9 20:46:05 2018 -0300

    staging:iio:ad2s1210: Remove unused #define directive
    
    This patch removes some #define directives not used in the code.
    
    Signed-off-by: Rodrigo Siqueira <rodrigosiqueiramelo@gmail.com>
    Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>

diff --git a/drivers/staging/iio/resolver/ad2s1210.c b/drivers/staging/iio/resolver/ad2s1210.c
index 0cdcd71e285b..79cb56670fc2 100644
--- a/drivers/staging/iio/resolver/ad2s1210.c
+++ b/drivers/staging/iio/resolver/ad2s1210.c
@@ -35,8 +35,6 @@
 #define AD2S1210_SET_RES1		0x02
 #define AD2S1210_SET_RES0		0x01
 
-#define AD2S1210_SET_ENRESOLUTION	(AD2S1210_SET_ENRES1 |	\
-					 AD2S1210_SET_ENRES0)
 #define AD2S1210_SET_RESOLUTION		(AD2S1210_SET_RES1 | AD2S1210_SET_RES0)
 
 #define AD2S1210_REG_POSITION		0x80
@@ -53,10 +51,6 @@
 #define AD2S1210_REG_SOFT_RESET		0xF0
 #define AD2S1210_REG_FAULT		0xFF
 
-/* pin SAMPLE, A0, A1, RES0, RES1, is controlled by driver */
-#define AD2S1210_SAA		3
-#define AD2S1210_PN		(AD2S1210_SAA + AD2S1210_RES)
-
 #define AD2S1210_MIN_CLKIN	6144000
 #define AD2S1210_MAX_CLKIN	10240000
 #define AD2S1210_MIN_EXCIT	2000
@@ -64,10 +58,6 @@
 #define AD2S1210_MIN_FCW	0x4
 #define AD2S1210_MAX_FCW	0x50
 
-/* default input clock on serial interface */
-#define AD2S1210_DEF_CLKIN	8192000
-/* clock period in nano second */
-#define AD2S1210_DEF_TCK	(1000000000 / AD2S1210_DEF_CLKIN)
 #define AD2S1210_DEF_EXCIT	10000
 
 enum ad2s1210_mode {

commit 23c537ae0e2f109165ef231edc25155a64427cc1
Author: Rodrigo Siqueira <rodrigosiqueiramelo@gmail.com>
Date:   Fri Mar 9 20:45:50 2018 -0300

    staging:iio:ad2s1210: Remove end of line with '['
    
    This patch fixes the checkpatch.pl check:
    
    iio/resolver/ad2s1210.c:202: CHECK: Lines should not end with a '['
    
    Signed-off-by: Rodrigo Siqueira <rodrigosiqueiramelo@gmail.com>
    Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>

diff --git a/drivers/staging/iio/resolver/ad2s1210.c b/drivers/staging/iio/resolver/ad2s1210.c
index f8baab061eba..0cdcd71e285b 100644
--- a/drivers/staging/iio/resolver/ad2s1210.c
+++ b/drivers/staging/iio/resolver/ad2s1210.c
@@ -165,9 +165,10 @@ int ad2s1210_update_frequency_control_word(struct ad2s1210_state *st)
 
 static unsigned char ad2s1210_read_resolution_pin(struct ad2s1210_state *st)
 {
-	return ad2s1210_resolution_value[
-		(gpio_get_value(st->pdata->res[0]) << 1) |
-		gpio_get_value(st->pdata->res[1])];
+	int resolution = (gpio_get_value(st->pdata->res[0]) << 1) |
+			  gpio_get_value(st->pdata->res[1]);
+
+	return ad2s1210_resolution_value[resolution];
 }
 
 static const int ad2s1210_res_pins[4][2] = {

commit 3762f8a0f3687d109b22e5a64f4a782e029de59d
Author: Jonathan Cameron <jic23@kernel.org>
Date:   Sun Jul 23 17:26:16 2017 +0100

    iio:resolver: drop assignment of iio_info.driver_module
    
    The equivalent is now done via macro magic when
    the relevant register call is made.  The actual structure
    elements will shortly go away.
    
    Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>
    Reviewed-by: Lars-Peter Clausen <lars@metafoo.de>

diff --git a/drivers/staging/iio/resolver/ad2s1210.c b/drivers/staging/iio/resolver/ad2s1210.c
index 3e00df74b18c..f8baab061eba 100644
--- a/drivers/staging/iio/resolver/ad2s1210.c
+++ b/drivers/staging/iio/resolver/ad2s1210.c
@@ -638,7 +638,6 @@ static int ad2s1210_initial(struct ad2s1210_state *st)
 static const struct iio_info ad2s1210_info = {
 	.read_raw = ad2s1210_read_raw,
 	.attrs = &ad2s1210_attribute_group,
-	.driver_module = THIS_MODULE,
 };
 
 static int ad2s1210_setup_gpios(struct ad2s1210_state *st)

commit 105967ad68d2eb1a041bc041f9cf96af2a653b65
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Fri Jul 14 11:31:03 2017 +0200

    staging:iio:resolver:ad2s1210 fix negative IIO_ANGL_VEL read
    
    gcc-7 points out an older regression:
    
    drivers/staging/iio/resolver/ad2s1210.c: In function 'ad2s1210_read_raw':
    drivers/staging/iio/resolver/ad2s1210.c:515:42: error: '<<' in boolean context, did you mean '<' ? [-Werror=int-in-bool-context]
    
    The original code had 'unsigned short' here, but incorrectly got
    converted to 'bool'. This reverts the regression and uses a normal
    type instead.
    
    Fixes: 29148543c521 ("staging:iio:resolver:ad2s1210 minimal chan spec conversion.")
    Cc: stable@vger.kernel.org
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>

diff --git a/drivers/staging/iio/resolver/ad2s1210.c b/drivers/staging/iio/resolver/ad2s1210.c
index a6a8393d6664..3e00df74b18c 100644
--- a/drivers/staging/iio/resolver/ad2s1210.c
+++ b/drivers/staging/iio/resolver/ad2s1210.c
@@ -472,7 +472,7 @@ static int ad2s1210_read_raw(struct iio_dev *indio_dev,
 			     long m)
 {
 	struct ad2s1210_state *st = iio_priv(indio_dev);
-	bool negative;
+	u16 negative;
 	int ret = 0;
 	u16 pos;
 	s16 vel;

commit 2b7cb7bed6e209a1b1560fe288087f84614cc793
Author: Miguel Robles <miguel.robles@farole.net>
Date:   Thu Mar 16 15:28:29 2017 +0100

    Staging: iio: resolver: ad2s1210: Fix warning, statements should start on a tabstop
    
    Fix checkpatch warning:
    Statements should start on a tabstop.
    
    Signed-off-by: Miguel Robles <miguel.robles@farole.net>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/staging/iio/resolver/ad2s1210.c b/drivers/staging/iio/resolver/ad2s1210.c
index 90b57c03609c..a6a8393d6664 100644
--- a/drivers/staging/iio/resolver/ad2s1210.c
+++ b/drivers/staging/iio/resolver/ad2s1210.c
@@ -490,8 +490,8 @@ static int ad2s1210_read_raw(struct iio_dev *indio_dev,
 		ad2s1210_set_mode(MOD_VEL, st);
 		break;
 	default:
-	       ret = -EINVAL;
-	       break;
+		ret = -EINVAL;
+		break;
 	}
 	if (ret < 0)
 		goto error_ret;

commit 6144f61af6e304044918a3d7a9a2ada2a5c874a7
Author: Derek Robson <robsonde@gmail.com>
Date:   Sat Feb 4 14:45:41 2017 +1300

    Staging: iio: resolver: ad2s1210.c - style fix
    
    Changed symbolic permissions to octal permissions.
    Found using checkpatch
    
    Signed-off-by: Derek Robson <robsonde@gmail.com>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/staging/iio/resolver/ad2s1210.c b/drivers/staging/iio/resolver/ad2s1210.c
index 6b992634f009..90b57c03609c 100644
--- a/drivers/staging/iio/resolver/ad2s1210.c
+++ b/drivers/staging/iio/resolver/ad2s1210.c
@@ -531,36 +531,36 @@ static int ad2s1210_read_raw(struct iio_dev *indio_dev,
 	return ret;
 }
 
-static IIO_DEVICE_ATTR(fclkin, S_IRUGO | S_IWUSR,
+static IIO_DEVICE_ATTR(fclkin, 0644,
 		       ad2s1210_show_fclkin, ad2s1210_store_fclkin, 0);
-static IIO_DEVICE_ATTR(fexcit, S_IRUGO | S_IWUSR,
+static IIO_DEVICE_ATTR(fexcit, 0644,
 		       ad2s1210_show_fexcit,	ad2s1210_store_fexcit, 0);
-static IIO_DEVICE_ATTR(control, S_IRUGO | S_IWUSR,
+static IIO_DEVICE_ATTR(control, 0644,
 		       ad2s1210_show_control, ad2s1210_store_control, 0);
-static IIO_DEVICE_ATTR(bits, S_IRUGO | S_IWUSR,
+static IIO_DEVICE_ATTR(bits, 0644,
 		       ad2s1210_show_resolution, ad2s1210_store_resolution, 0);
-static IIO_DEVICE_ATTR(fault, S_IRUGO | S_IWUSR,
+static IIO_DEVICE_ATTR(fault, 0644,
 		       ad2s1210_show_fault, ad2s1210_clear_fault, 0);
 
-static IIO_DEVICE_ATTR(los_thrd, S_IRUGO | S_IWUSR,
+static IIO_DEVICE_ATTR(los_thrd, 0644,
 		       ad2s1210_show_reg, ad2s1210_store_reg,
 		       AD2S1210_REG_LOS_THRD);
-static IIO_DEVICE_ATTR(dos_ovr_thrd, S_IRUGO | S_IWUSR,
+static IIO_DEVICE_ATTR(dos_ovr_thrd, 0644,
 		       ad2s1210_show_reg, ad2s1210_store_reg,
 		       AD2S1210_REG_DOS_OVR_THRD);
-static IIO_DEVICE_ATTR(dos_mis_thrd, S_IRUGO | S_IWUSR,
+static IIO_DEVICE_ATTR(dos_mis_thrd, 0644,
 		       ad2s1210_show_reg, ad2s1210_store_reg,
 		       AD2S1210_REG_DOS_MIS_THRD);
-static IIO_DEVICE_ATTR(dos_rst_max_thrd, S_IRUGO | S_IWUSR,
+static IIO_DEVICE_ATTR(dos_rst_max_thrd, 0644,
 		       ad2s1210_show_reg, ad2s1210_store_reg,
 		       AD2S1210_REG_DOS_RST_MAX_THRD);
-static IIO_DEVICE_ATTR(dos_rst_min_thrd, S_IRUGO | S_IWUSR,
+static IIO_DEVICE_ATTR(dos_rst_min_thrd, 0644,
 		       ad2s1210_show_reg, ad2s1210_store_reg,
 		       AD2S1210_REG_DOS_RST_MIN_THRD);
-static IIO_DEVICE_ATTR(lot_high_thrd, S_IRUGO | S_IWUSR,
+static IIO_DEVICE_ATTR(lot_high_thrd, 0644,
 		       ad2s1210_show_reg, ad2s1210_store_reg,
 		       AD2S1210_REG_LOT_HIGH_THRD);
-static IIO_DEVICE_ATTR(lot_low_thrd, S_IRUGO | S_IWUSR,
+static IIO_DEVICE_ATTR(lot_low_thrd, 0644,
 		       ad2s1210_show_reg, ad2s1210_store_reg,
 		       AD2S1210_REG_LOT_LOW_THRD);
 

commit b5b6e7beb0a0e6fb553af1a18b52f6d835b40951
Author: Eva Rachel Retuya <eraretuya@gmail.com>
Date:   Thu Feb 18 18:59:39 2016 +0800

    staging: iio: resolver: fix comparison to NULL
    
    Remove comparison of spi->dev.platform_data to NULL by replacing it with
    '!spi->dev.platform_data' as checkpatch suggested:
    
    CHECK: Comparison to NULL could be written "!spi->dev.platform_data"
    
    Signed-off-by: Eva Rachel Retuya <eraretuya@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/iio/resolver/ad2s1210.c b/drivers/staging/iio/resolver/ad2s1210.c
index 477df95af859..6b992634f009 100644
--- a/drivers/staging/iio/resolver/ad2s1210.c
+++ b/drivers/staging/iio/resolver/ad2s1210.c
@@ -675,7 +675,7 @@ static int ad2s1210_probe(struct spi_device *spi)
 	struct ad2s1210_state *st;
 	int ret;
 
-	if (spi->dev.platform_data == NULL)
+	if (!spi->dev.platform_data)
 		return -EINVAL;
 
 	indio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*st));

commit c7e426d1c521922689cb00e4665674c128de8e37
Author: Eva Rachel Retuya <eraretuya@gmail.com>
Date:   Thu Feb 18 18:59:38 2016 +0800

    staging: iio: resolver: remove unnecessary blank line
    
    Delete the excess newline. Issue found by checkpatch.
    
    CHECK: Please don't use multiple blank lines
    
    Signed-off-by: Eva Rachel Retuya <eraretuya@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/iio/resolver/ad2s1210.c b/drivers/staging/iio/resolver/ad2s1210.c
index 03395d438b5a..477df95af859 100644
--- a/drivers/staging/iio/resolver/ad2s1210.c
+++ b/drivers/staging/iio/resolver/ad2s1210.c
@@ -564,7 +564,6 @@ static IIO_DEVICE_ATTR(lot_low_thrd, S_IRUGO | S_IWUSR,
 		       ad2s1210_show_reg, ad2s1210_store_reg,
 		       AD2S1210_REG_LOT_LOW_THRD);
 
-
 static const struct iio_chan_spec ad2s1210_channels[] = {
 	{
 		.type = IIO_ANGL,

commit c3f63dd6fee6f0dbf96a1f8fa76e9cfee54f1463
Author: Eva Rachel Retuya <eraretuya@gmail.com>
Date:   Thu Feb 18 18:59:37 2016 +0800

    staging: iio: resolver: delete space after a cast
    
    Delete unwanted whitespace after casting. Issue pointed out by
    checkpatch.
    
    Signed-off-by: Eva Rachel Retuya <eraretuya@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/iio/resolver/ad2s1210.c b/drivers/staging/iio/resolver/ad2s1210.c
index 563a01c29e73..03395d438b5a 100644
--- a/drivers/staging/iio/resolver/ad2s1210.c
+++ b/drivers/staging/iio/resolver/ad2s1210.c
@@ -501,7 +501,7 @@ static int ad2s1210_read_raw(struct iio_dev *indio_dev,
 
 	switch (chan->type) {
 	case IIO_ANGL:
-		pos = be16_to_cpup((__be16 *) st->rx);
+		pos = be16_to_cpup((__be16 *)st->rx);
 		if (st->hysteresis)
 			pos >>= 16 - st->resolution;
 		*val = pos;
@@ -509,7 +509,7 @@ static int ad2s1210_read_raw(struct iio_dev *indio_dev,
 		break;
 	case IIO_ANGL_VEL:
 		negative = st->rx[0] & 0x80;
-		vel = be16_to_cpup((__be16 *) st->rx);
+		vel = be16_to_cpup((__be16 *)st->rx);
 		vel >>= 16 - st->resolution;
 		if (vel & 0x8000) {
 			negative = (0xffff >> st->resolution) << st->resolution;

commit 84681c7c85b75eba8b3b6c668c8e61b9e265d8f9
Author: Eva Rachel Retuya <eraretuya@gmail.com>
Date:   Thu Feb 18 18:59:36 2016 +0800

    staging: iio: resolver: add missing braces on if-else statements
    
    Add braces around the else clause to adhere to kernel coding style. This
    clears the following checkpatch issue:
    
    CHECK: braces {} should be used on all arms of this statement
    
    Signed-off-by: Eva Rachel Retuya <eraretuya@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/iio/resolver/ad2s1210.c b/drivers/staging/iio/resolver/ad2s1210.c
index 4cf5e4144448..563a01c29e73 100644
--- a/drivers/staging/iio/resolver/ad2s1210.c
+++ b/drivers/staging/iio/resolver/ad2s1210.c
@@ -319,9 +319,9 @@ static ssize_t ad2s1210_store_control(struct device *dev,
 		data = ad2s1210_read_resolution_pin(st);
 		if (data != st->resolution)
 			dev_warn(dev, "ad2s1210: resolution settings not match\n");
-	} else
+	} else {
 		ad2s1210_set_resolution_pin(st);
-
+	}
 	ret = len;
 	st->hysteresis = !!(data & AD2S1210_ENABLE_HYSTERESIS);
 
@@ -381,8 +381,9 @@ static ssize_t ad2s1210_store_resolution(struct device *dev,
 		data = ad2s1210_read_resolution_pin(st);
 		if (data != st->resolution)
 			dev_warn(dev, "ad2s1210: resolution settings not match\n");
-	} else
+	} else {
 		ad2s1210_set_resolution_pin(st);
+	}
 	ret = len;
 error_ret:
 	mutex_unlock(&st->lock);

commit 8d80ccbb1e6ae8c9c9380a2ec9506b47bea35ca9
Author: Eva Rachel Retuya <eraretuya@gmail.com>
Date:   Thu Feb 18 18:59:35 2016 +0800

    staging: iio: resolver: use blank line after array declaration
    
    Add a blank line after array declaration. This clears the checkpatch
    check:
    
    CHECK: Please use a blank line after function/struct/union/enum
    declarations
    
    Signed-off-by: Eva Rachel Retuya <eraretuya@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/iio/resolver/ad2s1210.c b/drivers/staging/iio/resolver/ad2s1210.c
index f2a3463ad8c1..4cf5e4144448 100644
--- a/drivers/staging/iio/resolver/ad2s1210.c
+++ b/drivers/staging/iio/resolver/ad2s1210.c
@@ -98,6 +98,7 @@ static const int ad2s1210_mode_vals[4][2] = {
 	[MOD_VEL] = { 0, 1 },
 	[MOD_CONFIG] = { 1, 0 },
 };
+
 static inline void ad2s1210_set_mode(enum ad2s1210_mode mode,
 				     struct ad2s1210_state *st)
 {

commit cdd6dee0f176b7ea4905940de07a9fef67623bfa
Author: Eva Rachel Retuya <eraretuya@gmail.com>
Date:   Thu Feb 18 18:59:34 2016 +0800

    staging: iio: resolver: add spaces around operators
    
    Add spaces around operators to improve readability and to address the
    checkpatch issue:
    
    CHECK: spaces preferred around that '/' (ctx:VxV)
    
    Signed-off-by: Eva Rachel Retuya <eraretuya@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/iio/resolver/ad2s1210.c b/drivers/staging/iio/resolver/ad2s1210.c
index f11832c52aa0..f2a3463ad8c1 100644
--- a/drivers/staging/iio/resolver/ad2s1210.c
+++ b/drivers/staging/iio/resolver/ad2s1210.c
@@ -67,7 +67,7 @@
 /* default input clock on serial interface */
 #define AD2S1210_DEF_CLKIN	8192000
 /* clock period in nano second */
-#define AD2S1210_DEF_TCK	(1000000000/AD2S1210_DEF_CLKIN)
+#define AD2S1210_DEF_TCK	(1000000000 / AD2S1210_DEF_CLKIN)
 #define AD2S1210_DEF_EXCIT	10000
 
 enum ad2s1210_mode {
@@ -176,9 +176,9 @@ static const int ad2s1210_res_pins[4][2] = {
 static inline void ad2s1210_set_resolution_pin(struct ad2s1210_state *st)
 {
 	gpio_set_value(st->pdata->res[0],
-		       ad2s1210_res_pins[(st->resolution - 10)/2][0]);
+		       ad2s1210_res_pins[(st->resolution - 10) / 2][0]);
 	gpio_set_value(st->pdata->res[1],
-		       ad2s1210_res_pins[(st->resolution - 10)/2][1]);
+		       ad2s1210_res_pins[(st->resolution - 10) / 2][1]);
 }
 
 static inline int ad2s1210_soft_reset(struct ad2s1210_state *st)

commit ae6394aaf12e41d6117688db598d0b095efcf7a2
Author: Eva Rachel Retuya <eraretuya@gmail.com>
Date:   Thu Feb 18 18:59:33 2016 +0800

    staging: iio: resolver: align to match open parenthesis
    
    Use a combination of tabs and spaces to align parameters to its
    corresponding open parenthesis. Checkpatch found this issue.
    
    Signed-off-by: Eva Rachel Retuya <eraretuya@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/iio/resolver/ad2s1210.c b/drivers/staging/iio/resolver/ad2s1210.c
index d97aa2827412..f11832c52aa0 100644
--- a/drivers/staging/iio/resolver/ad2s1210.c
+++ b/drivers/staging/iio/resolver/ad2s1210.c
@@ -123,7 +123,7 @@ static int ad2s1210_config_write(struct ad2s1210_state *st, u8 data)
 
 /* read value from one of the registers */
 static int ad2s1210_config_read(struct ad2s1210_state *st,
-		       unsigned char address)
+				unsigned char address)
 {
 	struct spi_transfer xfer = {
 		.len = 2,
@@ -282,8 +282,8 @@ static ssize_t ad2s1210_show_control(struct device *dev,
 }
 
 static ssize_t ad2s1210_store_control(struct device *dev,
-			struct device_attribute *attr,
-			const char *buf, size_t len)
+				      struct device_attribute *attr,
+				      const char *buf, size_t len)
 {
 	struct ad2s1210_state *st = iio_priv(dev_to_iio_dev(dev));
 	unsigned char udata;
@@ -330,7 +330,8 @@ static ssize_t ad2s1210_store_control(struct device *dev,
 }
 
 static ssize_t ad2s1210_show_resolution(struct device *dev,
-			struct device_attribute *attr, char *buf)
+					struct device_attribute *attr,
+					char *buf)
 {
 	struct ad2s1210_state *st = iio_priv(dev_to_iio_dev(dev));
 
@@ -338,8 +339,8 @@ static ssize_t ad2s1210_show_resolution(struct device *dev,
 }
 
 static ssize_t ad2s1210_store_resolution(struct device *dev,
-			struct device_attribute *attr,
-			const char *buf, size_t len)
+					 struct device_attribute *attr,
+					 const char *buf, size_t len)
 {
 	struct ad2s1210_state *st = iio_priv(dev_to_iio_dev(dev));
 	unsigned char data;
@@ -389,7 +390,7 @@ static ssize_t ad2s1210_store_resolution(struct device *dev,
 
 /* read the fault register since last sample */
 static ssize_t ad2s1210_show_fault(struct device *dev,
-			struct device_attribute *attr, char *buf)
+				   struct device_attribute *attr, char *buf)
 {
 	struct ad2s1210_state *st = iio_priv(dev_to_iio_dev(dev));
 	int ret;
@@ -441,7 +442,8 @@ static ssize_t ad2s1210_show_reg(struct device *dev,
 }
 
 static ssize_t ad2s1210_store_reg(struct device *dev,
-		struct device_attribute *attr, const char *buf, size_t len)
+				  struct device_attribute *attr,
+				  const char *buf, size_t len)
 {
 	struct ad2s1210_state *st = iio_priv(dev_to_iio_dev(dev));
 	unsigned char data;

commit 75f5db39ff14ed95056f2cca3ad98c3cae97170c
Merge: 52787e91bf53 c70efb851531
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Nov 5 13:15:12 2015 -0800

    Merge tag 'spi-v4.4' of git://git.kernel.org/pub/scm/linux/kernel/git/broonie/spi
    
    Pull spi updates from Mark Brown:
     "Quite a lot of activity in SPI this cycle, almost all of it in drivers
      with a few minor improvements and tweaks in the core.
    
       - Updates to pxa2xx to support Intel Broxton and multiple chip selects.
       - Support for big endian in the bcm63xx driver.
       - Multiple slave support for the mt8173
       - New driver for the auxiliary SPI controller in bcm2835 SoCs.
       - Support for Layerscale SoCs in the Freescale DSPI driver"
    
    * tag 'spi-v4.4' of git://git.kernel.org/pub/scm/linux/kernel/git/broonie/spi: (87 commits)
      spi: pxa2xx: Rework self-initiated platform data creation for non-ACPI
      spi: pxa2xx: Add support for Intel Broxton
      spi: pxa2xx: Detect number of enabled Intel LPSS SPI chip select signals
      spi: pxa2xx: Add output control for multiple Intel LPSS chip selects
      spi: pxa2xx: Use LPSS prefix for defines that are Intel LPSS specific
      spi: Add DSPI support for layerscape family
      spi: ti-qspi: improve ->remove() callback
      spi/spi-xilinx: Fix race condition on last word read
      spi: Drop owner assignment from spi_drivers
      spi: Add THIS_MODULE to spi_driver in SPI core
      spi: Setup the master controller driver before setting the chipselect
      spi: dw: replace magic constant by DW_SPI_DR
      spi: mediatek: mt8173 spi multiple devices support
      spi: mediatek: handle controller_data in mtk_spi_setup
      spi: mediatek: remove mtk_spi_config
      spi: mediatek: Update document devicetree bindings to support multiple devices
      spi: fix kernel-doc warnings about missing return desc in spi.c
      spi: fix kernel-doc warnings about missing return desc in spi.h
      spi: pxa2xx: Align a few defines
      spi: pxa2xx: Save other reg_cs_ctrl bits when configuring chip select
      ...

commit 3821a065f5672c430a088ae68b4da2a2d2b34106
Author: Andrew F. Davis <afd@ti.com>
Date:   Fri Oct 23 08:59:11 2015 -0500

    spi: Drop owner assignment from spi_drivers
    
    An spi_driver does not need to set an owner, it will be populated by the
    driver core.
    
    Signed-off-by: Andrew F. Davis <afd@ti.com>
    Acked-by: Jonathan Cameron <jic23@kernel.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/staging/iio/resolver/ad2s1210.c b/drivers/staging/iio/resolver/ad2s1210.c
index 7bc3e4a73834..95f5426a14d9 100644
--- a/drivers/staging/iio/resolver/ad2s1210.c
+++ b/drivers/staging/iio/resolver/ad2s1210.c
@@ -735,7 +735,6 @@ MODULE_DEVICE_TABLE(spi, ad2s1210_id);
 static struct spi_driver ad2s1210_driver = {
 	.driver = {
 		.name = DRV_NAME,
-		.owner = THIS_MODULE,
 	},
 	.probe = ad2s1210_probe,
 	.remove = ad2s1210_remove,

commit 3a1d9489e92a4dd93f6f070aa7e9062beed94c69
Author: Shraddha Barke <shraddha.6596@gmail.com>
Date:   Tue Oct 13 21:07:48 2015 +0530

    Staging: iio: Remove exceptional & on function name
    
    In this file, function names are otherwise used as pointers without &.
    
    A simplified version of the Coccinelle semantic patch that makes this
    change is as follows:
    
    // <smpl>
    @r@
    identifier f;
    @@
    
    f(...) { ... }
    @@
    identifier r.f;
    @@
    
    - &f
    + f
    // </smpl>
    
    Signed-off-by: Shraddha Barke <shraddha.6596@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/iio/resolver/ad2s1210.c b/drivers/staging/iio/resolver/ad2s1210.c
index 7bc3e4a73834..3bd65f5c9cf5 100644
--- a/drivers/staging/iio/resolver/ad2s1210.c
+++ b/drivers/staging/iio/resolver/ad2s1210.c
@@ -633,7 +633,7 @@ static int ad2s1210_initial(struct ad2s1210_state *st)
 }
 
 static const struct iio_info ad2s1210_info = {
-	.read_raw = &ad2s1210_read_raw,
+	.read_raw = ad2s1210_read_raw,
 	.attrs = &ad2s1210_attribute_group,
 	.driver_module = THIS_MODULE,
 };

commit dc5f2c5f6aa159ebf4b29b169aa1f71cf98d3d6a
Merge: c754ff966d54 c0644160a8b5
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Mar 24 22:53:52 2015 +0100

    Merge tag 'iio-for-4.1a' of git://git.kernel.org/pub/scm/linux/kernel/git/jic23/iio into staging-next
    
    Jonathan writes:
    
    First set of new drivers, cleanups and functionality for IIO in the 4.1 cycle.
    
    New drivers
    * CM3323 color sensor.
    * MS5611 pressure and temperature sensor.
    
    New functionality
    * mup6050 - create mux clients for devices described via ACPI. The reasoning
         and approach taken in this patch are complex.  Basically there is no
         otherway of finding out what is there than by some esoteric look ups in
         the ACPI data.
    * cm3232 - PM support
    * itg3200 - suspend/resume support
    * mcp320x - add more ADCs to the kconfig to reflect what the driver supports
         (this patch and the bindings got left behind when the support was added
          a while back).
    
    Docs / utils
    * ti-adc128s052 - DT bindings.
    * mcp3422 - DT bindings.
    * mcp320x - DT bindings
    * ABI docs for event threshold scale attributes, in_magn_offset, proximity
      scan_element and thresh falling/rising values for accelerometers.  All
      elements long in use that have slipped by being explicitly documented.
    * Tidy up the tools previously in drivers/staging/iio/Documentation and move
      them out to /tools/iio. Yet another move that should have happened long ago.
      This time Roberta Dobrescu did the leg work.  Thanks!
    
    Core Cleanups
    * Export userspace IIO headers.  We should have done the appropriate header
      splitting a long time ago. Thanks to Daniel for sorting this out.
    
    * Refactor the registring of attributes for buffers to move all non-custom
      ones to a vector allowing easier additions to the current set in the future.
    
    Driver Cleanups
    * gpiod related cleanups.  Make use of the additional parameter to specify
            initial direciton to avoid extra code.
    * bmc150 - Various refactorings to reduce code repitition and prepare for
               hardware buffer support.  Some of these cleanups are good even
               without the new functionality.
    * kmx61 - direct use of index to an array avoiding a structure element which
              was always the index to an element in an array of that structure.
    * vf610 - avoid incorrect type for return from wait_for_completion_timeout.
    * gp2ap020a00f - use put_unaligned_le32 for slight code simplification.
    * ade7754 - improve error handling including suppressing some build warnings.
    * ade7759 - improve error handling including suppressing some build warnings.
    * hmc5843 - Long line and indentation fixes. Also some constifying of various
          constant data.
    * ade7854 - 80+ character line splitting.
    * ad2s1210 - fix wrong printf format string.
    * mxs-lradc - fix wrong printf format string.
    * ade7954-i2c - code alignment fixes and other trivial but worthwhile bits.
    * periodic rtc trigger - make the frequency type an unsigned int as it
      is always treated as such.
    * jsa1212 - constify struct regmap_config as it is constant.
    * ad7793 - typo in the MODULE_DESCRIPTION
    * mma9551 - check gpiod_to_irq errors.  Note that this doesn't actually cause
        any trouble but is worth tidying up as obviously incorrect.
    * mlx90614 - refactor the register symbols to make it clear which reads are to
        RAM not PROM.

commit 8ac7f9b37ebc6ae294a6ebbf8cd14d2bf3edc7b4
Author: Haneen Mohammed <hamohammed.sa@gmail.com>
Date:   Wed Mar 18 13:12:07 2015 +0300

    Staging: iio: replace pr_* with dev_*
    
    dev_* is prefered over pr_* when appropriate device stuct is present.
    This patch replace pr_err and pr_warn with its dev_ counterpart.
    
    Signed-off-by: Haneen Mohammed <hamohammed.sa@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/iio/resolver/ad2s1210.c b/drivers/staging/iio/resolver/ad2s1210.c
index 1d8c5c0bdc88..5b1daeacac7a 100644
--- a/drivers/staging/iio/resolver/ad2s1210.c
+++ b/drivers/staging/iio/resolver/ad2s1210.c
@@ -151,7 +151,7 @@ int ad2s1210_update_frequency_control_word(struct ad2s1210_state *st)
 
 	fcw = (unsigned char)(st->fexcit * (1 << 15) / st->fclkin);
 	if (fcw < AD2S1210_MIN_FCW || fcw > AD2S1210_MAX_FCW) {
-		pr_err("ad2s1210: FCW out of range\n");
+		dev_err(&st->sdev->dev, "ad2s1210: FCW out of range\n");
 		return -ERANGE;
 	}
 
@@ -317,7 +317,7 @@ static ssize_t ad2s1210_store_control(struct device *dev,
 	if (st->pdata->gpioin) {
 		data = ad2s1210_read_resolution_pin(st);
 		if (data != st->resolution)
-			pr_warn("ad2s1210: resolution settings not match\n");
+			dev_warn(dev, "ad2s1210: resolution settings not match\n");
 	} else
 		ad2s1210_set_resolution_pin(st);
 
@@ -378,7 +378,7 @@ static ssize_t ad2s1210_store_resolution(struct device *dev,
 	if (st->pdata->gpioin) {
 		data = ad2s1210_read_resolution_pin(st);
 		if (data != st->resolution)
-			pr_warn("ad2s1210: resolution settings not match\n");
+			dev_warn(dev, "ad2s1210: resolution settings not match\n");
 	} else
 		ad2s1210_set_resolution_pin(st);
 	ret = len;

commit 92371df8a9b70735b63075bb1f8a7480488d748e
Author: Haneen Mohammed <hamohammed.sa@gmail.com>
Date:   Tue Mar 17 08:35:41 2015 +0300

    Staging: iio: replace pr_err with dev_err
    
    This patch replace pr_err with dev_err, when appropriate device structre
    is found.
    Issue found using the following Coccinelle script:
    
    @r exists@
    identifier f, s, i;
    position p;
    @@
    
    f(...,struct s *i,...) {
    <+...
    when != i == NULL
    pr_err@p(...);
    ...+>
    }
    
    @rr@
    identifier r.s, fld;
    @@
    
    struct s {
            ...
            struct device *fld;
            ...
    };
    
    @@
    identifier r.i, rr.fld;
    position r.p;
    @@
    -pr_err@p
    +dev_err
       (
    + i->fld,
    ...)
    
    Signed-off-by: Haneen Mohammed <hamohammed.sa@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/iio/resolver/ad2s1210.c b/drivers/staging/iio/resolver/ad2s1210.c
index b4c14ba5fdee..1d8c5c0bdc88 100644
--- a/drivers/staging/iio/resolver/ad2s1210.c
+++ b/drivers/staging/iio/resolver/ad2s1210.c
@@ -214,7 +214,7 @@ static ssize_t ad2s1210_store_fclkin(struct device *dev,
 	if (ret)
 		return ret;
 	if (fclkin < AD2S1210_MIN_CLKIN || fclkin > AD2S1210_MAX_CLKIN) {
-		pr_err("ad2s1210: fclkin out of range\n");
+		dev_err(dev, "ad2s1210: fclkin out of range\n");
 		return -EINVAL;
 	}
 
@@ -252,7 +252,8 @@ static ssize_t ad2s1210_store_fexcit(struct device *dev,
 	if (ret < 0)
 		return ret;
 	if (fexcit < AD2S1210_MIN_EXCIT || fexcit > AD2S1210_MAX_EXCIT) {
-		pr_err("ad2s1210: excitation frequency out of range\n");
+		dev_err(dev,
+			"ad2s1210: excitation frequency out of range\n");
 		return -EINVAL;
 	}
 	mutex_lock(&st->lock);
@@ -307,7 +308,8 @@ static ssize_t ad2s1210_store_control(struct device *dev,
 		goto error_ret;
 	if (ret & AD2S1210_MSB_IS_HIGH) {
 		ret = -EIO;
-		pr_err("ad2s1210: write control register fail\n");
+		dev_err(dev,
+			"ad2s1210: write control register fail\n");
 		goto error_ret;
 	}
 	st->resolution
@@ -346,7 +348,7 @@ static ssize_t ad2s1210_store_resolution(struct device *dev,
 
 	ret = kstrtou8(buf, 10, &udata);
 	if (ret || udata < 10 || udata > 16) {
-		pr_err("ad2s1210: resolution out of range\n");
+		dev_err(dev, "ad2s1210: resolution out of range\n");
 		return -EINVAL;
 	}
 	mutex_lock(&st->lock);
@@ -368,7 +370,7 @@ static ssize_t ad2s1210_store_resolution(struct device *dev,
 	data = ret;
 	if (data & AD2S1210_MSB_IS_HIGH) {
 		ret = -EIO;
-		pr_err("ad2s1210: setting resolution fail\n");
+		dev_err(dev, "ad2s1210: setting resolution fail\n");
 		goto error_ret;
 	}
 	st->resolution

commit 31a3dda6489dd68552e1e6af56abcf65405d6b5c
Author: Rickard Strandqvist <rickard_strandqvist@spectrumdigital.se>
Date:   Tue Jan 27 23:22:34 2015 +0100

    staging: iio: resolver: ad2s1210: Change type in printf format string
    
    Wrong type in printf format string, requires 'int'
    but the argument type is 'unsigned int'
    
    This was found using a static code analysis program called cppcheck
    
    Signed-off-by: Rickard Strandqvist <rickard_strandqvist@spectrumdigital.se>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/staging/iio/resolver/ad2s1210.c b/drivers/staging/iio/resolver/ad2s1210.c
index b4c14ba5fdee..a8ecf87ef4a9 100644
--- a/drivers/staging/iio/resolver/ad2s1210.c
+++ b/drivers/staging/iio/resolver/ad2s1210.c
@@ -198,7 +198,7 @@ static ssize_t ad2s1210_show_fclkin(struct device *dev,
 {
 	struct ad2s1210_state *st = iio_priv(dev_to_iio_dev(dev));
 
-	return sprintf(buf, "%d\n", st->fclkin);
+	return sprintf(buf, "%u\n", st->fclkin);
 }
 
 static ssize_t ad2s1210_store_fclkin(struct device *dev,
@@ -237,7 +237,7 @@ static ssize_t ad2s1210_show_fexcit(struct device *dev,
 {
 	struct ad2s1210_state *st = iio_priv(dev_to_iio_dev(dev));
 
-	return sprintf(buf, "%d\n", st->fexcit);
+	return sprintf(buf, "%u\n", st->fexcit);
 }
 
 static ssize_t ad2s1210_store_fexcit(struct device *dev,

commit 8a689c114796d8a3801c2bf3e25d3e21d6816036
Author: Aybuke Ozdemir <aybuke.147@gmail.com>
Date:   Fri Sep 19 18:48:05 2014 +0300

    Staging: iio: resolver: Missing a blank line after declarations
    
    This patch fixes these warning messages found by checkpatch.pl:
    WARNING : Missing a blank line after declarations
    
    Signed-off-by: Aybuke Ozdemir <aybuke.147@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/iio/resolver/ad2s1210.c b/drivers/staging/iio/resolver/ad2s1210.c
index 1360099fdaea..b4c14ba5fdee 100644
--- a/drivers/staging/iio/resolver/ad2s1210.c
+++ b/drivers/staging/iio/resolver/ad2s1210.c
@@ -197,6 +197,7 @@ static ssize_t ad2s1210_show_fclkin(struct device *dev,
 				    char *buf)
 {
 	struct ad2s1210_state *st = iio_priv(dev_to_iio_dev(dev));
+
 	return sprintf(buf, "%d\n", st->fclkin);
 }
 
@@ -235,6 +236,7 @@ static ssize_t ad2s1210_show_fexcit(struct device *dev,
 				    char *buf)
 {
 	struct ad2s1210_state *st = iio_priv(dev_to_iio_dev(dev));
+
 	return sprintf(buf, "%d\n", st->fexcit);
 }
 
@@ -271,6 +273,7 @@ static ssize_t ad2s1210_show_control(struct device *dev,
 {
 	struct ad2s1210_state *st = iio_priv(dev_to_iio_dev(dev));
 	int ret;
+
 	mutex_lock(&st->lock);
 	ret = ad2s1210_config_read(st, AD2S1210_REG_CONTROL);
 	mutex_unlock(&st->lock);
@@ -328,6 +331,7 @@ static ssize_t ad2s1210_show_resolution(struct device *dev,
 			struct device_attribute *attr, char *buf)
 {
 	struct ad2s1210_state *st = iio_priv(dev_to_iio_dev(dev));
+
 	return sprintf(buf, "%d\n", st->resolution);
 }
 

commit 7557138a943bf460e56972b8b9f45d535a473a3c
Author: Teodora Baluta <teodora.baluta@intel.com>
Date:   Mon Jul 28 12:18:00 2014 +0100

    staging: iio: adis16240: fix sparse warnings regarding incorrect argument type
    
    Silence the following sparse warnings by changing cast from u16 to
    __be16:
    
      CHECK   drivers/staging/iio/accel/adis16240_core.c
    drivers/staging/iio/accel/adis16240_core.c:128:51: warning: incorrect
    type in argument 3 (different signedness)
    drivers/staging/iio/accel/adis16240_core.c:128:51:    expected unsigned
    short [usertype] *val
    drivers/staging/iio/accel/adis16240_core.c:128:51:    got signed short
    *<noident>
    drivers/staging/iio/accel/adis16240_core.c:142:51: warning: incorrect
    type in argument 3 (different signedness)
    drivers/staging/iio/accel/adis16240_core.c:142:51:    expected unsigned
    short [usertype] *val
    drivers/staging/iio/accel/adis16240_core.c:142:51:    got signed short
    *<noident>
    
    Signed-off-by: Teodora Baluta <teodora.baluta@intel.com>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/staging/iio/resolver/ad2s1210.c b/drivers/staging/iio/resolver/ad2s1210.c
index 7fbaba41c872..1360099fdaea 100644
--- a/drivers/staging/iio/resolver/ad2s1210.c
+++ b/drivers/staging/iio/resolver/ad2s1210.c
@@ -491,7 +491,7 @@ static int ad2s1210_read_raw(struct iio_dev *indio_dev,
 
 	switch (chan->type) {
 	case IIO_ANGL:
-		pos = be16_to_cpup((u16 *)st->rx);
+		pos = be16_to_cpup((__be16 *) st->rx);
 		if (st->hysteresis)
 			pos >>= 16 - st->resolution;
 		*val = pos;
@@ -499,7 +499,7 @@ static int ad2s1210_read_raw(struct iio_dev *indio_dev,
 		break;
 	case IIO_ANGL_VEL:
 		negative = st->rx[0] & 0x80;
-		vel = be16_to_cpup((s16 *)st->rx);
+		vel = be16_to_cpup((__be16 *) st->rx);
 		vel >>= 16 - st->resolution;
 		if (vel & 0x8000) {
 			negative = (0xffff >> st->resolution) << st->resolution;

commit 21d9fbcc4f44c21c2076cb6f5000c71c0d0d46fc
Author: Monam Agarwal <monamagarwal123@gmail.com>
Date:   Mon Mar 3 22:09:58 2014 +0530

    Staging: iio/resolver: Fix prefer pr_warn over pr_warning in ad2s1210.c
    
    This patch fixes following checkpatch.pl warning
    WARNING: Prefer pr_warn(... to pr_warning(...
    
    Signed-off-by: Monam Agarwal <monamagarwal123@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/iio/resolver/ad2s1210.c b/drivers/staging/iio/resolver/ad2s1210.c
index 6966d5f76648..7fbaba41c872 100644
--- a/drivers/staging/iio/resolver/ad2s1210.c
+++ b/drivers/staging/iio/resolver/ad2s1210.c
@@ -312,7 +312,7 @@ static ssize_t ad2s1210_store_control(struct device *dev,
 	if (st->pdata->gpioin) {
 		data = ad2s1210_read_resolution_pin(st);
 		if (data != st->resolution)
-			pr_warning("ad2s1210: resolution settings not match\n");
+			pr_warn("ad2s1210: resolution settings not match\n");
 	} else
 		ad2s1210_set_resolution_pin(st);
 
@@ -372,7 +372,7 @@ static ssize_t ad2s1210_store_resolution(struct device *dev,
 	if (st->pdata->gpioin) {
 		data = ad2s1210_read_resolution_pin(st);
 		if (data != st->resolution)
-			pr_warning("ad2s1210: resolution settings not match\n");
+			pr_warn("ad2s1210: resolution settings not match\n");
 	} else
 		ad2s1210_set_resolution_pin(st);
 	ret = len;

commit 50711572c6949f3e5f53f47f7adf2d7c1d5011d9
Author: Sachin Kamat <sachin.kamat@linaro.org>
Date:   Wed Sep 11 10:55:00 2013 +0100

    staging: iio: ad2s1210: Use devm_iio_device_alloc
    
    devm_iio_device_alloc makes code simpler.
    
    Signed-off-by: Sachin Kamat <sachin.kamat@linaro.org>
    Cc: Graff Yang <graff.yang@gmail.com>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/staging/iio/resolver/ad2s1210.c b/drivers/staging/iio/resolver/ad2s1210.c
index 2b0c8e50654d..6966d5f76648 100644
--- a/drivers/staging/iio/resolver/ad2s1210.c
+++ b/drivers/staging/iio/resolver/ad2s1210.c
@@ -669,16 +669,14 @@ static int ad2s1210_probe(struct spi_device *spi)
 	if (spi->dev.platform_data == NULL)
 		return -EINVAL;
 
-	indio_dev = iio_device_alloc(sizeof(*st));
-	if (indio_dev == NULL) {
-		ret = -ENOMEM;
-		goto error_ret;
-	}
+	indio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*st));
+	if (!indio_dev)
+		return -ENOMEM;
 	st = iio_priv(indio_dev);
 	st->pdata = spi->dev.platform_data;
 	ret = ad2s1210_setup_gpios(st);
 	if (ret < 0)
-		goto error_free_dev;
+		return ret;
 
 	spi_set_drvdata(spi, indio_dev);
 
@@ -709,9 +707,6 @@ static int ad2s1210_probe(struct spi_device *spi)
 
 error_free_gpios:
 	ad2s1210_free_gpios(st);
-error_free_dev:
-	iio_device_free(indio_dev);
-error_ret:
 	return ret;
 }
 
@@ -721,7 +716,6 @@ static int ad2s1210_remove(struct spi_device *spi)
 
 	iio_device_unregister(indio_dev);
 	ad2s1210_free_gpios(iio_priv(indio_dev));
-	iio_device_free(indio_dev);
 
 	return 0;
 }

commit e5e26dd5bb740c34c975e2ae059126ba3486a1ce
Author: Jingoo Han <jg1.han@samsung.com>
Date:   Tue Aug 20 03:31:00 2013 +0100

    staging: iio: replace strict_strto*() with kstrto*()
    
    The usage of strict_strto*() is not preferred, because
    strict_strto*() is obsolete. Thus, kstrto*() should be
    used.
    
    Previously, there were only strict_strtol(), strict_strtoul(),
    strict_strtoull(), and strict_strtoll(). Thus, when converting
    to the variables, only long, unsigned long, unsigned long long,
    and long long can be used.
    
    However, kstrto*() provides various functions handling all types
    of variables. Therefore, the types of variables can be changed
    properly.
    
    Signed-off-by: Jingoo Han <jg1.han@samsung.com>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/staging/iio/resolver/ad2s1210.c b/drivers/staging/iio/resolver/ad2s1210.c
index dcdadbbcf7e8..2b0c8e50654d 100644
--- a/drivers/staging/iio/resolver/ad2s1210.c
+++ b/drivers/staging/iio/resolver/ad2s1210.c
@@ -206,10 +206,10 @@ static ssize_t ad2s1210_store_fclkin(struct device *dev,
 				     size_t len)
 {
 	struct ad2s1210_state *st = iio_priv(dev_to_iio_dev(dev));
-	unsigned long fclkin;
+	unsigned int fclkin;
 	int ret;
 
-	ret = strict_strtoul(buf, 10, &fclkin);
+	ret = kstrtouint(buf, 10, &fclkin);
 	if (ret)
 		return ret;
 	if (fclkin < AD2S1210_MIN_CLKIN || fclkin > AD2S1210_MAX_CLKIN) {
@@ -243,10 +243,10 @@ static ssize_t ad2s1210_store_fexcit(struct device *dev,
 				     const char *buf, size_t len)
 {
 	struct ad2s1210_state *st = iio_priv(dev_to_iio_dev(dev));
-	unsigned long fexcit;
+	unsigned int fexcit;
 	int ret;
 
-	ret = strict_strtoul(buf, 10, &fexcit);
+	ret = kstrtouint(buf, 10, &fexcit);
 	if (ret < 0)
 		return ret;
 	if (fexcit < AD2S1210_MIN_EXCIT || fexcit > AD2S1210_MAX_EXCIT) {
@@ -282,11 +282,11 @@ static ssize_t ad2s1210_store_control(struct device *dev,
 			const char *buf, size_t len)
 {
 	struct ad2s1210_state *st = iio_priv(dev_to_iio_dev(dev));
-	unsigned long udata;
+	unsigned char udata;
 	unsigned char data;
 	int ret;
 
-	ret = strict_strtoul(buf, 16, &udata);
+	ret = kstrtou8(buf, 16, &udata);
 	if (ret)
 		return -EINVAL;
 
@@ -337,10 +337,10 @@ static ssize_t ad2s1210_store_resolution(struct device *dev,
 {
 	struct ad2s1210_state *st = iio_priv(dev_to_iio_dev(dev));
 	unsigned char data;
-	unsigned long udata;
+	unsigned char udata;
 	int ret;
 
-	ret = strict_strtoul(buf, 10, &udata);
+	ret = kstrtou8(buf, 10, &udata);
 	if (ret || udata < 10 || udata > 16) {
 		pr_err("ad2s1210: resolution out of range\n");
 		return -EINVAL;
@@ -438,11 +438,11 @@ static ssize_t ad2s1210_store_reg(struct device *dev,
 		struct device_attribute *attr, const char *buf, size_t len)
 {
 	struct ad2s1210_state *st = iio_priv(dev_to_iio_dev(dev));
-	unsigned long data;
+	unsigned char data;
 	int ret;
 	struct iio_dev_attr *iattr = to_iio_dev_attr(attr);
 
-	ret = strict_strtoul(buf, 10, &data);
+	ret = kstrtou8(buf, 10, &data);
 	if (ret)
 		return -EINVAL;
 	mutex_lock(&st->lock);

commit be8309d69991956def20c86c3902ca46f9490e7b
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Tue Jul 16 16:08:00 2013 +0100

    staging:iio:ad2s1210: Don't expose the chip reset to userspace
    
    There is no reason why userspace should want to trigger a manual reset of the
    device, so remove this functionality.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/staging/iio/resolver/ad2s1210.c b/drivers/staging/iio/resolver/ad2s1210.c
index 0d3356d4b7d2..dcdadbbcf7e8 100644
--- a/drivers/staging/iio/resolver/ad2s1210.c
+++ b/drivers/staging/iio/resolver/ad2s1210.c
@@ -192,21 +192,6 @@ static inline int ad2s1210_soft_reset(struct ad2s1210_state *st)
 	return ad2s1210_config_write(st, 0x0);
 }
 
-static ssize_t ad2s1210_store_softreset(struct device *dev,
-					struct device_attribute *attr,
-					const char *buf,
-					size_t len)
-{
-	struct ad2s1210_state *st = iio_priv(dev_to_iio_dev(dev));
-	int ret;
-
-	mutex_lock(&st->lock);
-	ret = ad2s1210_soft_reset(st);
-	mutex_unlock(&st->lock);
-
-	return ret < 0 ? ret : len;
-}
-
 static ssize_t ad2s1210_show_fclkin(struct device *dev,
 				    struct device_attribute *attr,
 				    char *buf)
@@ -536,8 +521,6 @@ static int ad2s1210_read_raw(struct iio_dev *indio_dev,
 	return ret;
 }
 
-static IIO_DEVICE_ATTR(reset, S_IWUSR,
-		       NULL, ad2s1210_store_softreset, 0);
 static IIO_DEVICE_ATTR(fclkin, S_IRUGO | S_IWUSR,
 		       ad2s1210_show_fclkin, ad2s1210_store_fclkin, 0);
 static IIO_DEVICE_ATTR(fexcit, S_IRUGO | S_IWUSR,
@@ -587,7 +570,6 @@ static const struct iio_chan_spec ad2s1210_channels[] = {
 };
 
 static struct attribute *ad2s1210_attributes[] = {
-	&iio_dev_attr_reset.dev_attr.attr,
 	&iio_dev_attr_fclkin.dev_attr.attr,
 	&iio_dev_attr_fexcit.dev_attr.attr,
 	&iio_dev_attr_control.dev_attr.attr,

commit 07d0f65491dec4733bcf0ba430cee7403f5174cb
Author: Jonathan Cameron <jic23@kernel.org>
Date:   Wed Feb 27 19:41:30 2013 +0000

    staging:iio:resolver:ad2s1210 move to info_mask_(shared_by_type/separate)
    
    The original info_mask is going away in favour of the broken out versions.
    
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>
    Acked-by: Michael Hennerich <michael.hennerich@analog.com>

diff --git a/drivers/staging/iio/resolver/ad2s1210.c b/drivers/staging/iio/resolver/ad2s1210.c
index 53110b6a3c74..0d3356d4b7d2 100644
--- a/drivers/staging/iio/resolver/ad2s1210.c
+++ b/drivers/staging/iio/resolver/ad2s1210.c
@@ -577,12 +577,12 @@ static const struct iio_chan_spec ad2s1210_channels[] = {
 		.type = IIO_ANGL,
 		.indexed = 1,
 		.channel = 0,
-		.info_mask = IIO_CHAN_INFO_RAW_SEPARATE_BIT,
+		.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),
 	}, {
 		.type = IIO_ANGL_VEL,
 		.indexed = 1,
 		.channel = 0,
-		.info_mask = IIO_CHAN_INFO_RAW_SEPARATE_BIT,
+		.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),
 	}
 };
 

commit ad6c46b0c712e0d8fd8a80ee372b30f14a781888
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Wed Jan 9 17:31:00 2013 +0000

    staging:iio: Use spi_sync_transfer()
    
    Use the new spi_sync_transfer() helper function instead of open-coding it.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/staging/iio/resolver/ad2s1210.c b/drivers/staging/iio/resolver/ad2s1210.c
index ed07a348eb55..53110b6a3c74 100644
--- a/drivers/staging/iio/resolver/ad2s1210.c
+++ b/drivers/staging/iio/resolver/ad2s1210.c
@@ -130,15 +130,12 @@ static int ad2s1210_config_read(struct ad2s1210_state *st,
 		.rx_buf = st->rx,
 		.tx_buf = st->tx,
 	};
-	struct spi_message msg;
 	int ret = 0;
 
 	ad2s1210_set_mode(MOD_CONFIG, st);
-	spi_message_init(&msg);
-	spi_message_add_tail(&xfer, &msg);
 	st->tx[0] = address | AD2S1210_MSB_IS_HIGH;
 	st->tx[1] = AD2S1210_REG_FAULT;
-	ret = spi_sync(st->sdev, &msg);
+	ret = spi_sync_transfer(st->sdev, &xfer, 1);
 	if (ret < 0)
 		return ret;
 	st->old_data = true;

commit e543acf07db78cfc135e45c4ce0ed26ccf774c37
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Nov 19 13:21:38 2012 -0500

    staging: iio: remove use of __devexit_p
    
    CONFIG_HOTPLUG is going away as an option so __devexit_p is no longer
    needed.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Cc: Jonathan Cameron <jic23@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/iio/resolver/ad2s1210.c b/drivers/staging/iio/resolver/ad2s1210.c
index d57c62945e78..ed07a348eb55 100644
--- a/drivers/staging/iio/resolver/ad2s1210.c
+++ b/drivers/staging/iio/resolver/ad2s1210.c
@@ -759,7 +759,7 @@ static struct spi_driver ad2s1210_driver = {
 		.owner = THIS_MODULE,
 	},
 	.probe = ad2s1210_probe,
-	.remove = __devexit_p(ad2s1210_remove),
+	.remove = ad2s1210_remove,
 	.id_table = ad2s1210_id,
 };
 module_spi_driver(ad2s1210_driver);

commit 447d4f29ee3fa62f13c65688bb7b74d5a9a0d767
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Nov 19 13:26:37 2012 -0500

    staging: iio: remove use of __devexit
    
    CONFIG_HOTPLUG is going away as an option so __devexit is no
    longer needed.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Cc: Jonathan Cameron <jic23@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/iio/resolver/ad2s1210.c b/drivers/staging/iio/resolver/ad2s1210.c
index 98c653c82c3a..d57c62945e78 100644
--- a/drivers/staging/iio/resolver/ad2s1210.c
+++ b/drivers/staging/iio/resolver/ad2s1210.c
@@ -736,7 +736,7 @@ static int ad2s1210_probe(struct spi_device *spi)
 	return ret;
 }
 
-static int __devexit ad2s1210_remove(struct spi_device *spi)
+static int ad2s1210_remove(struct spi_device *spi)
 {
 	struct iio_dev *indio_dev = spi_get_drvdata(spi);
 

commit 4ae1c61ff2ba4fea4e4c1a045cb1f34520608789
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Nov 19 13:21:57 2012 -0500

    staging: iio: remove use of __devinit
    
    CONFIG_HOTPLUG is going away as an option so __devinit is no longer
    needed.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Cc: Jonathan Cameron <jic23@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/iio/resolver/ad2s1210.c b/drivers/staging/iio/resolver/ad2s1210.c
index 4ba4d05ed423..98c653c82c3a 100644
--- a/drivers/staging/iio/resolver/ad2s1210.c
+++ b/drivers/staging/iio/resolver/ad2s1210.c
@@ -610,7 +610,7 @@ static const struct attribute_group ad2s1210_attribute_group = {
 	.attrs = ad2s1210_attributes,
 };
 
-static int __devinit ad2s1210_initial(struct ad2s1210_state *st)
+static int ad2s1210_initial(struct ad2s1210_state *st)
 {
 	unsigned char data;
 	int ret;
@@ -681,7 +681,7 @@ static void ad2s1210_free_gpios(struct ad2s1210_state *st)
 	gpio_free_array(ad2s1210_gpios, ARRAY_SIZE(ad2s1210_gpios));
 }
 
-static int __devinit ad2s1210_probe(struct spi_device *spi)
+static int ad2s1210_probe(struct spi_device *spi)
 {
 	struct iio_dev *indio_dev;
 	struct ad2s1210_state *st;

commit f4e4b9558bc696cc89de460e754d3fecb50b13cb
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Thu Aug 9 08:51:00 2012 +0100

    staging:iio: Constify static iio_chan_spec arrays
    
    The per driver iio_chan_spec arrays are usually shared between multiple device
    instances. So a single device instance may not modify the iio_chan_spec array
    since this would also affect the other device instances. To make this restriction
    explicit mark the per driver iio_chan_spec arrays as const.
    
    Conversion was done automatically using the following coccinelle semantic patch:
    
    // <smpl>
    @disable optional_qualifier@
    identifier channels;
    @@
    static
    +const
    struct iio_chan_spec channels[] = ...;
    // </smpl>
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/staging/iio/resolver/ad2s1210.c b/drivers/staging/iio/resolver/ad2s1210.c
index f313859476c1..4ba4d05ed423 100644
--- a/drivers/staging/iio/resolver/ad2s1210.c
+++ b/drivers/staging/iio/resolver/ad2s1210.c
@@ -575,7 +575,7 @@ static IIO_DEVICE_ATTR(lot_low_thrd, S_IRUGO | S_IWUSR,
 		       AD2S1210_REG_LOT_LOW_THRD);
 
 
-static struct iio_chan_spec ad2s1210_channels[] = {
+static const struct iio_chan_spec ad2s1210_channels[] = {
 	{
 		.type = IIO_ANGL,
 		.indexed = 1,

commit a651cf9b5f0065d803b2f72ecab0a39861e8b03d
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Sat May 12 15:39:53 2012 +0200

    staging:iio:resolver: Use dev_to_iio_dev()
    
    Replace open-coded instances of getting a iio_dev struct from a device struct
    with dev_to_iio_dev().
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Acked-by: Jonathan Cameron <jic23@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/iio/resolver/ad2s1210.c b/drivers/staging/iio/resolver/ad2s1210.c
index a236ddbee372..f313859476c1 100644
--- a/drivers/staging/iio/resolver/ad2s1210.c
+++ b/drivers/staging/iio/resolver/ad2s1210.c
@@ -200,7 +200,7 @@ static ssize_t ad2s1210_store_softreset(struct device *dev,
 					const char *buf,
 					size_t len)
 {
-	struct ad2s1210_state *st = iio_priv(dev_get_drvdata(dev));
+	struct ad2s1210_state *st = iio_priv(dev_to_iio_dev(dev));
 	int ret;
 
 	mutex_lock(&st->lock);
@@ -214,7 +214,7 @@ static ssize_t ad2s1210_show_fclkin(struct device *dev,
 				    struct device_attribute *attr,
 				    char *buf)
 {
-	struct ad2s1210_state *st = iio_priv(dev_get_drvdata(dev));
+	struct ad2s1210_state *st = iio_priv(dev_to_iio_dev(dev));
 	return sprintf(buf, "%d\n", st->fclkin);
 }
 
@@ -223,7 +223,7 @@ static ssize_t ad2s1210_store_fclkin(struct device *dev,
 				     const char *buf,
 				     size_t len)
 {
-	struct ad2s1210_state *st = iio_priv(dev_get_drvdata(dev));
+	struct ad2s1210_state *st = iio_priv(dev_to_iio_dev(dev));
 	unsigned long fclkin;
 	int ret;
 
@@ -252,7 +252,7 @@ static ssize_t ad2s1210_show_fexcit(struct device *dev,
 				    struct device_attribute *attr,
 				    char *buf)
 {
-	struct ad2s1210_state *st = iio_priv(dev_get_drvdata(dev));
+	struct ad2s1210_state *st = iio_priv(dev_to_iio_dev(dev));
 	return sprintf(buf, "%d\n", st->fexcit);
 }
 
@@ -260,7 +260,7 @@ static ssize_t ad2s1210_store_fexcit(struct device *dev,
 				     struct device_attribute *attr,
 				     const char *buf, size_t len)
 {
-	struct ad2s1210_state *st = iio_priv(dev_get_drvdata(dev));
+	struct ad2s1210_state *st = iio_priv(dev_to_iio_dev(dev));
 	unsigned long fexcit;
 	int ret;
 
@@ -287,7 +287,7 @@ static ssize_t ad2s1210_show_control(struct device *dev,
 				     struct device_attribute *attr,
 				     char *buf)
 {
-	struct ad2s1210_state *st = iio_priv(dev_get_drvdata(dev));
+	struct ad2s1210_state *st = iio_priv(dev_to_iio_dev(dev));
 	int ret;
 	mutex_lock(&st->lock);
 	ret = ad2s1210_config_read(st, AD2S1210_REG_CONTROL);
@@ -299,7 +299,7 @@ static ssize_t ad2s1210_store_control(struct device *dev,
 			struct device_attribute *attr,
 			const char *buf, size_t len)
 {
-	struct ad2s1210_state *st = iio_priv(dev_get_drvdata(dev));
+	struct ad2s1210_state *st = iio_priv(dev_to_iio_dev(dev));
 	unsigned long udata;
 	unsigned char data;
 	int ret;
@@ -345,7 +345,7 @@ static ssize_t ad2s1210_store_control(struct device *dev,
 static ssize_t ad2s1210_show_resolution(struct device *dev,
 			struct device_attribute *attr, char *buf)
 {
-	struct ad2s1210_state *st = iio_priv(dev_get_drvdata(dev));
+	struct ad2s1210_state *st = iio_priv(dev_to_iio_dev(dev));
 	return sprintf(buf, "%d\n", st->resolution);
 }
 
@@ -353,7 +353,7 @@ static ssize_t ad2s1210_store_resolution(struct device *dev,
 			struct device_attribute *attr,
 			const char *buf, size_t len)
 {
-	struct ad2s1210_state *st = iio_priv(dev_get_drvdata(dev));
+	struct ad2s1210_state *st = iio_priv(dev_to_iio_dev(dev));
 	unsigned char data;
 	unsigned long udata;
 	int ret;
@@ -403,7 +403,7 @@ static ssize_t ad2s1210_store_resolution(struct device *dev,
 static ssize_t ad2s1210_show_fault(struct device *dev,
 			struct device_attribute *attr, char *buf)
 {
-	struct ad2s1210_state *st = iio_priv(dev_get_drvdata(dev));
+	struct ad2s1210_state *st = iio_priv(dev_to_iio_dev(dev));
 	int ret;
 
 	mutex_lock(&st->lock);
@@ -418,7 +418,7 @@ static ssize_t ad2s1210_clear_fault(struct device *dev,
 				    const char *buf,
 				    size_t len)
 {
-	struct ad2s1210_state *st = iio_priv(dev_get_drvdata(dev));
+	struct ad2s1210_state *st = iio_priv(dev_to_iio_dev(dev));
 	int ret;
 
 	mutex_lock(&st->lock);
@@ -441,7 +441,7 @@ static ssize_t ad2s1210_show_reg(struct device *dev,
 				 struct device_attribute *attr,
 				 char *buf)
 {
-	struct ad2s1210_state *st = iio_priv(dev_get_drvdata(dev));
+	struct ad2s1210_state *st = iio_priv(dev_to_iio_dev(dev));
 	struct iio_dev_attr *iattr = to_iio_dev_attr(attr);
 	int ret;
 
@@ -455,7 +455,7 @@ static ssize_t ad2s1210_show_reg(struct device *dev,
 static ssize_t ad2s1210_store_reg(struct device *dev,
 		struct device_attribute *attr, const char *buf, size_t len)
 {
-	struct ad2s1210_state *st = iio_priv(dev_get_drvdata(dev));
+	struct ad2s1210_state *st = iio_priv(dev_to_iio_dev(dev));
 	unsigned long data;
 	int ret;
 	struct iio_dev_attr *iattr = to_iio_dev_attr(attr);

commit 7cbb753701d11f3c71e8543e1ae0fc0772edac06
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Thu Apr 26 13:35:01 2012 +0200

    staging:iio: Streamline API function naming
    
    Currently we use two different naming schemes in the IIO API, iio_verb_object
    and iio_object_verb. E.g iio_device_register and iio_allocate_device. This
    patches renames instances of the later to the former. The patch also renames allocate to
    alloc as this seems to be the preferred form throughout the kernel.
    
    In particular the following renames are performed by the patch:
            iio_put_device -> iio_device_put
            iio_allocate_device -> iio_device_alloc
            iio_free_device -> iio_device_free
            iio_get_trigger -> iio_trigger_get
            iio_put_trigger -> iio_trigger_put
            iio_allocate_trigger -> iio_trigger_alloc
            iio_free_trigger -> iio_trigger_free
    
    The conversion was done with the following coccinelle patch with manual fixes to
    comments and documentation.
    
    <smpl>
    @@
    @@
    -iio_put_device
    +iio_device_put
    @@
    @@
    -iio_allocate_device
    +iio_device_alloc
    @@
    @@
    -iio_free_device
    +iio_device_free
    @@
    @@
    -iio_get_trigger
    +iio_trigger_get
    @@
    @@
    -iio_put_trigger
    +iio_trigger_put
    @@
    @@
    -iio_allocate_trigger
    +iio_trigger_alloc
    @@
    @@
    -iio_free_trigger
    +iio_trigger_free
    </smpl>
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Acked-by: Jonathan Cameron <jic23@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/iio/resolver/ad2s1210.c b/drivers/staging/iio/resolver/ad2s1210.c
index 4d580e238eb8..a236ddbee372 100644
--- a/drivers/staging/iio/resolver/ad2s1210.c
+++ b/drivers/staging/iio/resolver/ad2s1210.c
@@ -690,7 +690,7 @@ static int __devinit ad2s1210_probe(struct spi_device *spi)
 	if (spi->dev.platform_data == NULL)
 		return -EINVAL;
 
-	indio_dev = iio_allocate_device(sizeof(*st));
+	indio_dev = iio_device_alloc(sizeof(*st));
 	if (indio_dev == NULL) {
 		ret = -ENOMEM;
 		goto error_ret;
@@ -731,7 +731,7 @@ static int __devinit ad2s1210_probe(struct spi_device *spi)
 error_free_gpios:
 	ad2s1210_free_gpios(st);
 error_free_dev:
-	iio_free_device(indio_dev);
+	iio_device_free(indio_dev);
 error_ret:
 	return ret;
 }
@@ -742,7 +742,7 @@ static int __devexit ad2s1210_remove(struct spi_device *spi)
 
 	iio_device_unregister(indio_dev);
 	ad2s1210_free_gpios(iio_priv(indio_dev));
-	iio_free_device(indio_dev);
+	iio_device_free(indio_dev);
 
 	return 0;
 }

commit 06458e277eac2b8761b0a04d3c808d57be281a2e
Author: Jonathan Cameron <jic23@kernel.org>
Date:   Wed Apr 25 15:54:58 2012 +0100

    IIO: Move core headers to include/linux/iio
    
    Step 1 in moving the IIO core out of staging.
    
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/iio/resolver/ad2s1210.c b/drivers/staging/iio/resolver/ad2s1210.c
index c6ced163105d..4d580e238eb8 100644
--- a/drivers/staging/iio/resolver/ad2s1210.c
+++ b/drivers/staging/iio/resolver/ad2s1210.c
@@ -18,8 +18,8 @@
 #include <linux/gpio.h>
 #include <linux/module.h>
 
-#include "../iio.h"
-#include "../sysfs.h"
+#include <linux/iio/iio.h>
+#include <linux/iio/sysfs.h>
 #include "ad2s1210.h"
 
 #define DRV_NAME "ad2s1210"

commit 6246577071ac4b29579203e7c22a7f383cf4f9e8
Author: Jonathan Cameron <jic23@kernel.org>
Date:   Sun Apr 15 17:41:24 2012 +0100

    staging:iio:resolver Add IIO_CHAN_INFO_RAW entries to all drivers.
    
    Precursor to making value read / write attribute optional.
    No processed values in resolvers at the moment.
    
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>
    Acked-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/iio/resolver/ad2s1210.c b/drivers/staging/iio/resolver/ad2s1210.c
index c439fcf72be7..c6ced163105d 100644
--- a/drivers/staging/iio/resolver/ad2s1210.c
+++ b/drivers/staging/iio/resolver/ad2s1210.c
@@ -580,10 +580,12 @@ static struct iio_chan_spec ad2s1210_channels[] = {
 		.type = IIO_ANGL,
 		.indexed = 1,
 		.channel = 0,
+		.info_mask = IIO_CHAN_INFO_RAW_SEPARATE_BIT,
 	}, {
 		.type = IIO_ANGL_VEL,
 		.indexed = 1,
 		.channel = 0,
+		.info_mask = IIO_CHAN_INFO_RAW_SEPARATE_BIT,
 	}
 };
 

commit 12e55508921865aefdd80fd17afe70c191afbd1b
Merge: 55b81e6f2795 4d447c9a6ebc
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Jan 9 12:18:17 2012 -0800

    Merge branch 'staging-next' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/staging
    
    * 'staging-next' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/staging: (466 commits)
      net/hyperv: Add support for jumbo frame up to 64KB
      net/hyperv: Add NETVSP protocol version negotiation
      net/hyperv: Remove unnecessary kmap_atomic in netvsc driver
      staging/rtl8192e: Register against lib80211
      staging/rtl8192e: Convert to lib80211_crypt_info
      staging/rtl8192e: Convert to lib80211_crypt_data and lib80211_crypt_ops
      staging/rtl8192e: Add lib80211.h to rtllib.h
      staging/mei: add watchdog device registration wrappers
      drm/omap: GEM, deal with cache
      staging: vt6656: int.c, int.h: Change return of function to void
      staging: usbip: removed unused definitions from header
      staging: usbip: removed dead code from receive function
      staging:iio: Drop {mark,unmark}_in_use callbacks
      staging:iio: Drop buffer mark_param_change callback
      staging:iio: Drop the unused buffer enable() and is_enabled() callbacks
      staging:iio: Drop buffer busy flag
      staging:iio: Make sure a device is only opened once at a time
      staging:iio: Disallow modifying buffer size when buffer is enabled
      staging:iio: Disallow changing scan elements in all buffered modes
      staging:iio: Use iio_buffer_enabled instead of open coding it
      ...
    
    Fix up conflict in drivers/staging/iio/adc/ad799x_core.c (removal of
    module_init due to using module_i2c_driver() helper, next to removal of
    MODULE_ALIAS due to using MODULE_DEVICE_TABLE instead).

commit 55e4390cb04e8b0fbae8983c3494c9e24132db1b
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Wed Nov 16 08:53:31 2011 +0100

    staging:iio: Add missing MODULE_DEVICE_TABLE and MODULE_ALIAS
    
    Quite a few iio drivers provide no MODULE_DEVICE_TABLE or MODULE_ALIAS or only
    provide a MODULE_ALIAS while they have support for multiple device ids. This
    prevents auto module loading from working correctly.
    
    This patch fixes it by adding the missing MODULE_DEVICE_TABLEs and
    MODULE_ALIAS'.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Acked-by: Jonathan Cameron <jic23@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/iio/resolver/ad2s1210.c b/drivers/staging/iio/resolver/ad2s1210.c
index 6401a6273625..8996c98f832a 100644
--- a/drivers/staging/iio/resolver/ad2s1210.c
+++ b/drivers/staging/iio/resolver/ad2s1210.c
@@ -749,6 +749,7 @@ static const struct spi_device_id ad2s1210_id[] = {
 	{ "ad2s1210" },
 	{}
 };
+MODULE_DEVICE_TABLE(spi, ad2s1210_id);
 
 static struct spi_driver ad2s1210_driver = {
 	.driver = {

commit ae6ae6fec3f7d6919e0146996df37b665c75f662
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Wed Nov 16 10:13:39 2011 +0100

    staging:iio: Use module_spi_driver to register SPI driver
    
    Use the newly introduced module_spi_driver macro for registering SPI drivers.
    This allows us to remove a few lines of boilerplate code.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Acked-by: Grant Likely <grant.likely@secretlab.ca>
    Acked-by: Jonathan Cameron <jic23@kernel.org>
    Acked-by: Wolfram Sang <w.sang@pengutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/iio/resolver/ad2s1210.c b/drivers/staging/iio/resolver/ad2s1210.c
index 6401a6273625..ff1b3316d016 100644
--- a/drivers/staging/iio/resolver/ad2s1210.c
+++ b/drivers/staging/iio/resolver/ad2s1210.c
@@ -759,18 +759,7 @@ static struct spi_driver ad2s1210_driver = {
 	.remove = __devexit_p(ad2s1210_remove),
 	.id_table = ad2s1210_id,
 };
-
-static __init int ad2s1210_spi_init(void)
-{
-	return spi_register_driver(&ad2s1210_driver);
-}
-module_init(ad2s1210_spi_init);
-
-static __exit void ad2s1210_spi_exit(void)
-{
-	spi_unregister_driver(&ad2s1210_driver);
-}
-module_exit(ad2s1210_spi_exit);
+module_spi_driver(ad2s1210_driver);
 
 MODULE_AUTHOR("Graff Yang <graff.yang@gmail.com>");
 MODULE_DESCRIPTION("Analog Devices AD2S1210 Resolver to Digital SPI driver");

commit d2fffd6c2fd60fe9ab63ef30758d9d43a5057549
Author: Jonathan Cameron <jic23@cam.ac.uk>
Date:   Fri Oct 14 14:46:58 2011 +0100

    staging:iio: fix removal path to allow correct freeing.
    
    Fix a dumb lack of consideration of the effect of combining
    the iio_device_unregister and iio_free_device calls into
    one.  There is no valid place to free some of the sysfs
    array elements.
    
    Signed-off-by: Jonathan Cameron <jic23@cam.ac.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/iio/resolver/ad2s1210.c b/drivers/staging/iio/resolver/ad2s1210.c
index 8a6fcb669775..6401a6273625 100644
--- a/drivers/staging/iio/resolver/ad2s1210.c
+++ b/drivers/staging/iio/resolver/ad2s1210.c
@@ -737,10 +737,10 @@ static int __devinit ad2s1210_probe(struct spi_device *spi)
 static int __devexit ad2s1210_remove(struct spi_device *spi)
 {
 	struct iio_dev *indio_dev = spi_get_drvdata(spi);
-	struct ad2s1210_state *st = iio_priv(indio_dev);
 
-	ad2s1210_free_gpios(st);
 	iio_device_unregister(indio_dev);
+	ad2s1210_free_gpios(iio_priv(indio_dev));
+	iio_free_device(indio_dev);
 
 	return 0;
 }

commit 93decf3661bf1c7c05bbc217d4e69222b557512a
Author: Jonathan Cameron <jic23@cam.ac.uk>
Date:   Wed Oct 5 15:28:06 2011 +0100

    staging:iio:resolver:ad2s1210 cleanup gpio handling.
    
    Basically make use of the gpio array functions.
    Technically the free doesn't need as much info
    as given here, but this keeps it clean and easy
    to follow.
    
    Signed-off-by: Jonathan Cameron <jic23@cam.ac.uk>
    Acked-by: Michael Hennerich <michael.hennerich@analog.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/iio/resolver/ad2s1210.c b/drivers/staging/iio/resolver/ad2s1210.c
index 4f248de156e8..8a6fcb669775 100644
--- a/drivers/staging/iio/resolver/ad2s1210.c
+++ b/drivers/staging/iio/resolver/ad2s1210.c
@@ -653,45 +653,30 @@ static const struct iio_info ad2s1210_info = {
 
 static int ad2s1210_setup_gpios(struct ad2s1210_state *st)
 {
-	int ret;
 	unsigned long flags = st->pdata->gpioin ? GPIOF_DIR_IN : GPIOF_DIR_OUT;
+	struct gpio ad2s1210_gpios[] = {
+		{ st->pdata->sample, GPIOF_DIR_IN, "sample" },
+		{ st->pdata->a[0], flags, "a0" },
+		{ st->pdata->a[1], flags, "a1" },
+		{ st->pdata->res[0], flags, "res0" },
+		{ st->pdata->res[0], flags, "res1" },
+	};
 
-	ret = gpio_request_one(st->pdata->sample, GPIOF_DIR_IN, "sample");
-	if (ret < 0)
-		goto error_ret;
-	ret = gpio_request_one(st->pdata->a[0], flags, "a0");
-	if (ret < 0)
-		goto error_free_sample;
-	ret = gpio_request_one(st->pdata->a[1], flags, "a1");
-	if (ret < 0)
-		goto error_free_a0;
-	ret = gpio_request_one(st->pdata->res[1], flags, "res0");
-	if (ret < 0)
-		goto error_free_a1;
-	ret = gpio_request_one(st->pdata->res[1], flags, "res1");
-	if (ret < 0)
-		goto error_free_res0;
-
-	return 0;
-error_free_res0:
-	gpio_free(st->pdata->res[0]);
-error_free_a1:
-	gpio_free(st->pdata->a[1]);
-error_free_a0:
-	gpio_free(st->pdata->a[0]);
-error_free_sample:
-	gpio_free(st->pdata->sample);
-error_ret:
-	return ret;
+	return gpio_request_array(ad2s1210_gpios, ARRAY_SIZE(ad2s1210_gpios));
 }
 
 static void ad2s1210_free_gpios(struct ad2s1210_state *st)
 {
-	gpio_free(st->pdata->res[1]);
-	gpio_free(st->pdata->res[0]);
-	gpio_free(st->pdata->a[1]);
-	gpio_free(st->pdata->a[0]);
-	gpio_free(st->pdata->sample);
+	unsigned long flags = st->pdata->gpioin ? GPIOF_DIR_IN : GPIOF_DIR_OUT;
+	struct gpio ad2s1210_gpios[] = {
+		{ st->pdata->sample, GPIOF_DIR_IN, "sample" },
+		{ st->pdata->a[0], flags, "a0" },
+		{ st->pdata->a[1], flags, "a1" },
+		{ st->pdata->res[0], flags, "res0" },
+		{ st->pdata->res[0], flags, "res1" },
+	};
+
+	gpio_free_array(ad2s1210_gpios, ARRAY_SIZE(ad2s1210_gpios));
 }
 
 static int __devinit ad2s1210_probe(struct spi_device *spi)

commit f97beb535b14b07e89744c58d40d51646dceca75
Author: Jonathan Cameron <jic23@cam.ac.uk>
Date:   Wed Oct 5 15:28:05 2011 +0100

    staging:iio:resolver:ad2s1210 drop raw config register access
    
    This should never have been exposed to userspace
    
    Signed-off-by: Jonathan Cameron <jic23@cam.ac.uk>
    Acked-by: Michael Hennerich <michael.hennerich@analog.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/iio/resolver/ad2s1210.c b/drivers/staging/iio/resolver/ad2s1210.c
index 697db80df9c1..4f248de156e8 100644
--- a/drivers/staging/iio/resolver/ad2s1210.c
+++ b/drivers/staging/iio/resolver/ad2s1210.c
@@ -195,47 +195,6 @@ static inline int ad2s1210_soft_reset(struct ad2s1210_state *st)
 	return ad2s1210_config_write(st, 0x0);
 }
 
-
-/* return the OLD DATA since last spi bus write */
-static ssize_t ad2s1210_show_raw(struct device *dev,
-				 struct device_attribute *attr,
-				 char *buf)
-{
-	struct ad2s1210_state *st = iio_priv(dev_get_drvdata(dev));
-	int ret = 0;
-
-	mutex_lock(&st->lock);
-	if (st->old_data) {
-		ret = sprintf(buf, "0x%x\n", st->rx[0]);
-		st->old_data = false;
-	}
-	mutex_unlock(&st->lock);
-
-	return ret;
-}
-
-static ssize_t ad2s1210_store_raw(struct device *dev,
-				  struct device_attribute *attr,
-				  const char *buf,
-				  size_t len)
-{
-	struct ad2s1210_state *st = iio_priv(dev_get_drvdata(dev));
-	unsigned long udata;
-	unsigned char data;
-	int ret;
-
-	ret = strict_strtoul(buf, 16, &udata);
-	if (ret)
-		return -EINVAL;
-
-	data = udata & 0xff;
-	mutex_lock(&st->lock);
-	ret = ad2s1210_config_write(st, data);
-	mutex_unlock(&st->lock);
-
-	return ret < 0 ? ret : len;
-}
-
 static ssize_t ad2s1210_store_softreset(struct device *dev,
 					struct device_attribute *attr,
 					const char *buf,
@@ -580,8 +539,6 @@ static int ad2s1210_read_raw(struct iio_dev *indio_dev,
 	return ret;
 }
 
-static IIO_DEVICE_ATTR(raw_io, S_IRUGO | S_IWUSR,
-		       ad2s1210_show_raw, ad2s1210_store_raw, 0);
 static IIO_DEVICE_ATTR(reset, S_IWUSR,
 		       NULL, ad2s1210_store_softreset, 0);
 static IIO_DEVICE_ATTR(fclkin, S_IRUGO | S_IWUSR,
@@ -631,7 +588,6 @@ static struct iio_chan_spec ad2s1210_channels[] = {
 };
 
 static struct attribute *ad2s1210_attributes[] = {
-	&iio_dev_attr_raw_io.dev_attr.attr,
 	&iio_dev_attr_reset.dev_attr.attr,
 	&iio_dev_attr_fclkin.dev_attr.attr,
 	&iio_dev_attr_fexcit.dev_attr.attr,

commit 29148543c52146bbbb3f918c5312f6fb7eef21af
Author: Jonathan Cameron <jic23@cam.ac.uk>
Date:   Wed Oct 5 15:28:04 2011 +0100

    staging:iio:resolver:ad2s1210 minimal chan spec conversion.
    
    Just convert the raw reads in this patch.
    
    Signed-off-by: Jonathan Cameron <jic23@cam.ac.uk>
    Acked-by: Michael Hennerich <michael.hennerich@analog.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/iio/resolver/ad2s1210.c b/drivers/staging/iio/resolver/ad2s1210.c
index 9a88563a7fe1..697db80df9c1 100644
--- a/drivers/staging/iio/resolver/ad2s1210.c
+++ b/drivers/staging/iio/resolver/ad2s1210.c
@@ -514,71 +514,70 @@ static ssize_t ad2s1210_store_reg(struct device *dev,
 	return ret < 0 ? ret : len;
 }
 
-static ssize_t ad2s1210_show_pos(struct device *dev,
-				 struct device_attribute *attr,
-				 char *buf)
+static int ad2s1210_read_raw(struct iio_dev *indio_dev,
+			     struct iio_chan_spec const *chan,
+			     int *val,
+			     int *val2,
+			     long m)
 {
+	struct ad2s1210_state *st = iio_priv(indio_dev);
+	bool negative;
 	int ret = 0;
-	ssize_t len = 0;
 	u16 pos;
-	struct ad2s1210_state *st = iio_priv(dev_get_drvdata(dev));
-
-	mutex_lock(&st->lock);
-	gpio_set_value(st->pdata->sample, 0);
-	/* delay (6 * tck + 20) nano seconds */
-	udelay(1);
-
-	ad2s1210_set_mode(MOD_POS, st);
-	ret = spi_read(st->sdev, st->rx, 2);
-	if (ret)
-		goto error_ret;
-	pos = be16_to_cpup((u16 *)st->rx);
-	if (st->hysteresis)
-		pos >>= 16 - st->resolution;
-	len = sprintf(buf, "%d\n", pos);
-error_ret:
-	gpio_set_value(st->pdata->sample, 1);
-	/* delay (2 * tck + 20) nano seconds */
-	udelay(1);
-	mutex_unlock(&st->lock);
-
-	return ret < 0 ? ret : len;
-}
-
-static ssize_t ad2s1210_show_vel(struct device *dev,
-				 struct device_attribute *attr,
-				 char *buf)
-{
-	unsigned short negative;
-	int ret = 0;
-	ssize_t len = 0;
 	s16 vel;
-	struct ad2s1210_state *st = iio_priv(dev_get_drvdata(dev));
 
 	mutex_lock(&st->lock);
 	gpio_set_value(st->pdata->sample, 0);
 	/* delay (6 * tck + 20) nano seconds */
 	udelay(1);
 
-	ad2s1210_set_mode(MOD_VEL, st);
+	switch (chan->type) {
+	case IIO_ANGL:
+		ad2s1210_set_mode(MOD_POS, st);
+		break;
+	case IIO_ANGL_VEL:
+		ad2s1210_set_mode(MOD_VEL, st);
+		break;
+	default:
+	       ret = -EINVAL;
+	       break;
+	}
+	if (ret < 0)
+		goto error_ret;
 	ret = spi_read(st->sdev, st->rx, 2);
-	if (ret)
+	if (ret < 0)
 		goto error_ret;
-	negative = st->rx[0] & 0x80;
-	vel = be16_to_cpup((s16 *)st->rx);
-	vel >>= 16 - st->resolution;
-	if (vel & 0x8000) {
-		negative = (0xffff >> st->resolution) << st->resolution;
-		vel |= negative;
+
+	switch (chan->type) {
+	case IIO_ANGL:
+		pos = be16_to_cpup((u16 *)st->rx);
+		if (st->hysteresis)
+			pos >>= 16 - st->resolution;
+		*val = pos;
+		ret = IIO_VAL_INT;
+		break;
+	case IIO_ANGL_VEL:
+		negative = st->rx[0] & 0x80;
+		vel = be16_to_cpup((s16 *)st->rx);
+		vel >>= 16 - st->resolution;
+		if (vel & 0x8000) {
+			negative = (0xffff >> st->resolution) << st->resolution;
+			vel |= negative;
+		}
+		*val = vel;
+		ret = IIO_VAL_INT;
+		break;
+	default:
+		mutex_unlock(&st->lock);
+		return -EINVAL;
 	}
-	len = sprintf(buf, "%d\n", vel);
+
 error_ret:
 	gpio_set_value(st->pdata->sample, 1);
 	/* delay (2 * tck + 20) nano seconds */
 	udelay(1);
 	mutex_unlock(&st->lock);
-
-	return ret < 0 ? ret : len;
+	return ret;
 }
 
 static IIO_DEVICE_ATTR(raw_io, S_IRUGO | S_IWUSR,
@@ -595,8 +594,7 @@ static IIO_DEVICE_ATTR(bits, S_IRUGO | S_IWUSR,
 		       ad2s1210_show_resolution, ad2s1210_store_resolution, 0);
 static IIO_DEVICE_ATTR(fault, S_IRUGO | S_IWUSR,
 		       ad2s1210_show_fault, ad2s1210_clear_fault, 0);
-static IIO_DEVICE_ATTR(pos, S_IRUGO, ad2s1210_show_pos, NULL, 0);
-static IIO_DEVICE_ATTR(vel, S_IRUGO,  ad2s1210_show_vel, NULL, 0);
+
 static IIO_DEVICE_ATTR(los_thrd, S_IRUGO | S_IWUSR,
 		       ad2s1210_show_reg, ad2s1210_store_reg,
 		       AD2S1210_REG_LOS_THRD);
@@ -619,6 +617,19 @@ static IIO_DEVICE_ATTR(lot_low_thrd, S_IRUGO | S_IWUSR,
 		       ad2s1210_show_reg, ad2s1210_store_reg,
 		       AD2S1210_REG_LOT_LOW_THRD);
 
+
+static struct iio_chan_spec ad2s1210_channels[] = {
+	{
+		.type = IIO_ANGL,
+		.indexed = 1,
+		.channel = 0,
+	}, {
+		.type = IIO_ANGL_VEL,
+		.indexed = 1,
+		.channel = 0,
+	}
+};
+
 static struct attribute *ad2s1210_attributes[] = {
 	&iio_dev_attr_raw_io.dev_attr.attr,
 	&iio_dev_attr_reset.dev_attr.attr,
@@ -627,8 +638,6 @@ static struct attribute *ad2s1210_attributes[] = {
 	&iio_dev_attr_control.dev_attr.attr,
 	&iio_dev_attr_bits.dev_attr.attr,
 	&iio_dev_attr_fault.dev_attr.attr,
-	&iio_dev_attr_pos.dev_attr.attr,
-	&iio_dev_attr_vel.dev_attr.attr,
 	&iio_dev_attr_los_thrd.dev_attr.attr,
 	&iio_dev_attr_dos_ovr_thrd.dev_attr.attr,
 	&iio_dev_attr_dos_mis_thrd.dev_attr.attr,
@@ -681,6 +690,7 @@ static int __devinit ad2s1210_initial(struct ad2s1210_state *st)
 }
 
 static const struct iio_info ad2s1210_info = {
+	.read_raw = &ad2s1210_read_raw,
 	.attrs = &ad2s1210_attribute_group,
 	.driver_module = THIS_MODULE,
 };
@@ -760,6 +770,8 @@ static int __devinit ad2s1210_probe(struct spi_device *spi)
 	indio_dev->dev.parent = &spi->dev;
 	indio_dev->info = &ad2s1210_info;
 	indio_dev->modes = INDIO_DIRECT_MODE;
+	indio_dev->channels = ad2s1210_channels;
+	indio_dev->num_channels = ARRAY_SIZE(ad2s1210_channels);
 	indio_dev->name = spi_get_device_id(spi)->name;
 
 	ret = iio_device_register(indio_dev);

commit bf52f0591f85eaa339a4707a4636bb62cba7ffff
Author: Jonathan Cameron <jic23@cam.ac.uk>
Date:   Wed Oct 5 15:28:03 2011 +0100

    staging:iio:resolver:ad2s1210 ensure iio_dev->name is set
    
    This is needed to ensure the required name attribute is
    created. Using an id table is the route most consistent
    with other drivers.
    
    Signed-off-by: Jonathan Cameron <jic23@cam.ac.uk>
    Acked-by: Michael Hennerich <michael.hennerich@analog.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/iio/resolver/ad2s1210.c b/drivers/staging/iio/resolver/ad2s1210.c
index 5c9c409ec7cb..9a88563a7fe1 100644
--- a/drivers/staging/iio/resolver/ad2s1210.c
+++ b/drivers/staging/iio/resolver/ad2s1210.c
@@ -760,6 +760,7 @@ static int __devinit ad2s1210_probe(struct spi_device *spi)
 	indio_dev->dev.parent = &spi->dev;
 	indio_dev->info = &ad2s1210_info;
 	indio_dev->modes = INDIO_DIRECT_MODE;
+	indio_dev->name = spi_get_device_id(spi)->name;
 
 	ret = iio_device_register(indio_dev);
 	if (ret)
@@ -791,6 +792,11 @@ static int __devexit ad2s1210_remove(struct spi_device *spi)
 	return 0;
 }
 
+static const struct spi_device_id ad2s1210_id[] = {
+	{ "ad2s1210" },
+	{}
+};
+
 static struct spi_driver ad2s1210_driver = {
 	.driver = {
 		.name = DRV_NAME,
@@ -798,6 +804,7 @@ static struct spi_driver ad2s1210_driver = {
 	},
 	.probe = ad2s1210_probe,
 	.remove = __devexit_p(ad2s1210_remove),
+	.id_table = ad2s1210_id,
 };
 
 static __init int ad2s1210_spi_init(void)

commit 26d25ae3f0d8ffe350aacc75b71198d6b35bd1f4
Author: Jonathan Cameron <jic23@cam.ac.uk>
Date:   Fri Sep 2 17:14:40 2011 +0100

    staging:iio: rework of attribute registration.
    
    This set also includes quite a number of bug fixes of particularly
    remove functions.
    
    Necessary due to issue pointed out in Bart Van Assche's patch:
    docs/driver-model: Document device.groups
    
    V2: Rebase due to patch reordering.
    V3: Pull various error fixes and cleanups out into their own patches.
    
    Signed-off-by: Jonathan Cameron <jic23@cam.ac.uk>
    Acked-by: Michael Hennerich <Michael.Hennerich@analog.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/iio/resolver/ad2s1210.c b/drivers/staging/iio/resolver/ad2s1210.c
index 5e83227da4bc..5c9c409ec7cb 100644
--- a/drivers/staging/iio/resolver/ad2s1210.c
+++ b/drivers/staging/iio/resolver/ad2s1210.c
@@ -784,6 +784,7 @@ static int __devexit ad2s1210_remove(struct spi_device *spi)
 {
 	struct iio_dev *indio_dev = spi_get_drvdata(spi);
 	struct ad2s1210_state *st = iio_priv(indio_dev);
+
 	ad2s1210_free_gpios(st);
 	iio_device_unregister(indio_dev);
 

commit 3e39440789adef103422ce201538b4da8745fe8e
Author: Jonathan Cameron <jic23@cam.ac.uk>
Date:   Tue Aug 30 12:41:18 2011 +0100

    staging:iio:fix using iio_priv or iio_dev after iio_unregister_device
    
    This includes calling iio_free_device as that should only be called
    before the device has been registered.
    
    Also one case of iio_free_device being called on a registered device.
    
    This has been pulled out of the reworking attributes patch.
    
    Signed-off-by: Jonathan Cameron <jic23@cam.ac.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/iio/resolver/ad2s1210.c b/drivers/staging/iio/resolver/ad2s1210.c
index f8459e8e8552..5e83227da4bc 100644
--- a/drivers/staging/iio/resolver/ad2s1210.c
+++ b/drivers/staging/iio/resolver/ad2s1210.c
@@ -784,8 +784,8 @@ static int __devexit ad2s1210_remove(struct spi_device *spi)
 {
 	struct iio_dev *indio_dev = spi_get_drvdata(spi);
 	struct ad2s1210_state *st = iio_priv(indio_dev);
-	iio_device_unregister(indio_dev);
 	ad2s1210_free_gpios(st);
+	iio_device_unregister(indio_dev);
 
 	return 0;
 }

commit 99c978529a40132a6f7a5f136b4362b56fc88d8c
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Sun Jul 3 15:49:50 2011 -0400

    staging: Add module.h to drivers/staging users
    
    Lots of people expect module.h to just "be there" without
    any #include effort.  But we are crushing that.  So fix those
    files in staging relying on implicit module.h presence.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/iio/resolver/ad2s1210.c b/drivers/staging/iio/resolver/ad2s1210.c
index 53cb031b04dc..f8459e8e8552 100644
--- a/drivers/staging/iio/resolver/ad2s1210.c
+++ b/drivers/staging/iio/resolver/ad2s1210.c
@@ -16,6 +16,7 @@
 #include <linux/sysfs.h>
 #include <linux/delay.h>
 #include <linux/gpio.h>
+#include <linux/module.h>
 
 #include "../iio.h"
 #include "../sysfs.h"

commit 705099a763000872ae1a7ffda6b0433d56b55a6c
Author: Jonathan Cameron <jic23@cam.ac.uk>
Date:   Fri Aug 12 16:55:37 2011 +0100

    staging:iio:various Stop drivers putting sysfs attributes in a directory named after the device.
    
    No idea how this particularly 'quirk' got in there in the first
    place.
    
    Signed-off-by: Jonathan Cameron <jic23@cam.ac.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/iio/resolver/ad2s1210.c b/drivers/staging/iio/resolver/ad2s1210.c
index ecaf7bb790fe..53cb031b04dc 100644
--- a/drivers/staging/iio/resolver/ad2s1210.c
+++ b/drivers/staging/iio/resolver/ad2s1210.c
@@ -639,7 +639,6 @@ static struct attribute *ad2s1210_attributes[] = {
 };
 
 static const struct attribute_group ad2s1210_attribute_group = {
-	.name = DRV_NAME,
 	.attrs = ad2s1210_attributes,
 };
 

commit b19e9ad5e2cb9145c81690cec7c826b156d5b3c1
Author: Jonathan Cameron <jic23@cam.ac.uk>
Date:   Mon Jun 27 13:07:51 2011 +0100

    staging:iio:resolver:ad2s1210 general driver cleanup.
    
    Note I haven't made any changes to the userspace interface as yet.
    This is all about cleaning up what was actually there (handling
    all errors etc).
    
    Signed-off-by: Jonathan Cameron <jic23@cam.ac.uk>
    Acked-by: Michael Hennerich <michael.hennerich@analog.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/iio/resolver/ad2s1210.c b/drivers/staging/iio/resolver/ad2s1210.c
index 09f4fcfda73a..ecaf7bb790fe 100644
--- a/drivers/staging/iio/resolver/ad2s1210.c
+++ b/drivers/staging/iio/resolver/ad2s1210.c
@@ -19,44 +19,41 @@
 
 #include "../iio.h"
 #include "../sysfs.h"
+#include "ad2s1210.h"
 
 #define DRV_NAME "ad2s1210"
 
-#define DEF_CONTROL		0x7E
-
-#define MSB_IS_HIGH		0x80
-#define MSB_IS_LOW		0x7F
-#define PHASE_LOCK_RANGE_44	0x20
-#define ENABLE_HYSTERESIS	0x10
-#define SET_ENRES1		0x08
-#define SET_ENRES0		0x04
-#define SET_RES1		0x02
-#define SET_RES0		0x01
-
-#define SET_ENRESOLUTION	(SET_ENRES1 | SET_ENRES0)
-#define SET_RESOLUTION		(SET_RES1 | SET_RES0)
-
-#define REG_POSITION		0x80
-#define REG_VELOCITY		0x82
-#define REG_LOS_THRD		0x88
-#define REG_DOS_OVR_THRD	0x89
-#define REG_DOS_MIS_THRD	0x8A
-#define REG_DOS_RST_MAX_THRD	0x8B
-#define REG_DOS_RST_MIN_THRD	0x8C
-#define REG_LOT_HIGH_THRD	0x8D
-#define REG_LOT_LOW_THRD	0x8E
-#define REG_EXCIT_FREQ		0x91
-#define REG_CONTROL		0x92
-#define REG_SOFT_RESET		0xF0
-#define REG_FAULT		0xFF
+#define AD2S1210_DEF_CONTROL		0x7E
+
+#define AD2S1210_MSB_IS_HIGH		0x80
+#define AD2S1210_MSB_IS_LOW		0x7F
+#define AD2S1210_PHASE_LOCK_RANGE_44	0x20
+#define AD2S1210_ENABLE_HYSTERESIS	0x10
+#define AD2S1210_SET_ENRES1		0x08
+#define AD2S1210_SET_ENRES0		0x04
+#define AD2S1210_SET_RES1		0x02
+#define AD2S1210_SET_RES0		0x01
+
+#define AD2S1210_SET_ENRESOLUTION	(AD2S1210_SET_ENRES1 |	\
+					 AD2S1210_SET_ENRES0)
+#define AD2S1210_SET_RESOLUTION		(AD2S1210_SET_RES1 | AD2S1210_SET_RES0)
+
+#define AD2S1210_REG_POSITION		0x80
+#define AD2S1210_REG_VELOCITY		0x82
+#define AD2S1210_REG_LOS_THRD		0x88
+#define AD2S1210_REG_DOS_OVR_THRD	0x89
+#define AD2S1210_REG_DOS_MIS_THRD	0x8A
+#define AD2S1210_REG_DOS_RST_MAX_THRD	0x8B
+#define AD2S1210_REG_DOS_RST_MIN_THRD	0x8C
+#define AD2S1210_REG_LOT_HIGH_THRD	0x8D
+#define AD2S1210_REG_LOT_LOW_THRD	0x8E
+#define AD2S1210_REG_EXCIT_FREQ		0x91
+#define AD2S1210_REG_CONTROL		0x92
+#define AD2S1210_REG_SOFT_RESET		0xF0
+#define AD2S1210_REG_FAULT		0xFF
 
 /* pin SAMPLE, A0, A1, RES0, RES1, is controlled by driver */
 #define AD2S1210_SAA		3
-#if defined(CONFIG_AD2S1210_GPIO_INPUT) || defined(CONFIG_AD2S1210_GPIO_OUTPUT)
-# define AD2S1210_RES		2
-#else
-# define AD2S1210_RES		0
-#endif
 #define AD2S1210_PN		(AD2S1210_SAA + AD2S1210_RES)
 
 #define AD2S1210_MIN_CLKIN	6144000
@@ -75,190 +72,153 @@
 enum ad2s1210_mode {
 	MOD_POS = 0,
 	MOD_VEL,
-	MOD_RESERVED,
 	MOD_CONFIG,
+	MOD_RESERVED,
 };
 
-enum ad2s1210_res {
-	RES_10 = 10,
-	RES_12 = 12,
-	RES_14 = 14,
-	RES_16 = 16,
-};
-
-static unsigned int resolution_value[] = {
-		RES_10, RES_12, RES_14, RES_16};
+static const unsigned int ad2s1210_resolution_value[] = { 10, 12, 14, 16 };
 
 struct ad2s1210_state {
+	const struct ad2s1210_platform_data *pdata;
 	struct mutex lock;
-	struct iio_dev *idev;
 	struct spi_device *sdev;
-	struct spi_transfer xfer;
-	unsigned int hysteresis;
-	unsigned int old_data;
-	enum ad2s1210_mode mode;
-	enum ad2s1210_res resolution;
 	unsigned int fclkin;
 	unsigned int fexcit;
-	unsigned short sample;
-	unsigned short a0;
-	unsigned short a1;
-	unsigned short res0;
-	unsigned short res1;
-	u8 rx[3];
-	u8 tx[3];
+	bool hysteresis;
+	bool old_data;
+	u8 resolution;
+	enum ad2s1210_mode mode;
+	u8 rx[2] ____cacheline_aligned;
+	u8 tx[2] ____cacheline_aligned;
 };
 
-static inline void start_sample(struct ad2s1210_state *st)
-{
-	gpio_set_value(st->sample, 0);
-}
-
-static inline void stop_sample(struct ad2s1210_state *st)
-{
-	gpio_set_value(st->sample, 1);
-}
-
-static inline void set_mode(enum ad2s1210_mode mode, struct ad2s1210_state *st)
+static const int ad2s1210_mode_vals[4][2] = {
+	[MOD_POS] = { 0, 0 },
+	[MOD_VEL] = { 0, 1 },
+	[MOD_CONFIG] = { 1, 0 },
+};
+static inline void ad2s1210_set_mode(enum ad2s1210_mode mode,
+				     struct ad2s1210_state *st)
 {
-	switch (mode) {
-	case MOD_POS:
-		gpio_set_value(st->a0, 0);
-		gpio_set_value(st->a1, 0);
-		break;
-	case MOD_VEL:
-		gpio_set_value(st->a0, 0);
-		gpio_set_value(st->a1, 1);
-		break;
-	case MOD_CONFIG:
-		gpio_set_value(st->a0, 1);
-		gpio_set_value(st->a1, 1);
-		break;
-	default:
-		/* set to reserved mode */
-		gpio_set_value(st->a0, 1);
-		gpio_set_value(st->a1, 0);
-	}
+	gpio_set_value(st->pdata->a[0], ad2s1210_mode_vals[mode][0]);
+	gpio_set_value(st->pdata->a[1], ad2s1210_mode_vals[mode][1]);
 	st->mode = mode;
 }
 
 /* write 1 bytes (address or data) to the chip */
-static int config_write(struct ad2s1210_state *st,
-					unsigned char data)
+static int ad2s1210_config_write(struct ad2s1210_state *st, u8 data)
 {
-	struct spi_message msg;
-	int ret = 0;
-
-	st->xfer.len = 1;
-	set_mode(MOD_CONFIG, st);
+	int ret;
 
-	spi_message_init(&msg);
-	spi_message_add_tail(&st->xfer, &msg);
+	ad2s1210_set_mode(MOD_CONFIG, st);
 	st->tx[0] = data;
-	ret = spi_sync(st->sdev, &msg);
-	if (ret)
+	ret = spi_write(st->sdev, st->tx, 1);
+	if (ret < 0)
 		return ret;
-	st->old_data = 1;
-	return ret;
+	st->old_data = true;
+
+	return 0;
 }
 
 /* read value from one of the registers */
-static int config_read(struct ad2s1210_state *st,
-				unsigned char address,
-					unsigned char *data)
-{
+static int ad2s1210_config_read(struct ad2s1210_state *st,
+		       unsigned char address)
+{
+	struct spi_transfer xfer = {
+		.len = 2,
+		.rx_buf = st->rx,
+		.tx_buf = st->tx,
+	};
 	struct spi_message msg;
 	int ret = 0;
 
-	st->xfer.len = 2;
-	set_mode(MOD_CONFIG, st);
-
+	ad2s1210_set_mode(MOD_CONFIG, st);
 	spi_message_init(&msg);
-	spi_message_add_tail(&st->xfer, &msg);
-	st->tx[0] = address | MSB_IS_HIGH;
-	st->tx[1] = REG_FAULT;
+	spi_message_add_tail(&xfer, &msg);
+	st->tx[0] = address | AD2S1210_MSB_IS_HIGH;
+	st->tx[1] = AD2S1210_REG_FAULT;
 	ret = spi_sync(st->sdev, &msg);
-	if (ret)
+	if (ret < 0)
 		return ret;
-	*data = st->rx[1];
-	st->old_data = 1;
-	return ret;
+	st->old_data = true;
+
+	return st->rx[1];
 }
 
-static inline void update_frequency_control_word(struct ad2s1210_state *st)
+static inline
+int ad2s1210_update_frequency_control_word(struct ad2s1210_state *st)
 {
+	int ret;
 	unsigned char fcw;
+
 	fcw = (unsigned char)(st->fexcit * (1 << 15) / st->fclkin);
-	if (fcw >= AD2S1210_MIN_FCW && fcw <= AD2S1210_MAX_FCW) {
-		config_write(st, REG_EXCIT_FREQ);
-		config_write(st, fcw);
-	} else
+	if (fcw < AD2S1210_MIN_FCW || fcw > AD2S1210_MAX_FCW) {
 		pr_err("ad2s1210: FCW out of range\n");
+		return -ERANGE;
+	}
+
+	ret = ad2s1210_config_write(st, AD2S1210_REG_EXCIT_FREQ);
+	if (ret < 0)
+		return ret;
+
+	return ad2s1210_config_write(st, fcw);
 }
 
-#if defined(CONFIG_AD2S1210_GPIO_INPUT)
-static inline unsigned char read_resolution_pin(struct ad2s1210_state *st)
+static unsigned char ad2s1210_read_resolution_pin(struct ad2s1210_state *st)
 {
-	unsigned int data;
-	data = (gpio_get_value(st->res0) << 1)  |
-			gpio_get_value(st->res1);
-	return resolution_value[data];
+	return ad2s1210_resolution_value[
+		(gpio_get_value(st->pdata->res[0]) << 1) |
+		gpio_get_value(st->pdata->res[1])];
 }
-#elif defined(CONFIG_AD2S1210_GPIO_OUTPUT)
-static inline void set_resolution_pin(struct ad2s1210_state *st)
+
+static const int ad2s1210_res_pins[4][2] = {
+	{ 0, 0 }, {0, 1}, {1, 0}, {1, 1}
+};
+
+static inline void ad2s1210_set_resolution_pin(struct ad2s1210_state *st)
 {
-	switch (st->resolution) {
-	case RES_10:
-		gpio_set_value(st->res0, 0);
-		gpio_set_value(st->res1, 0);
-		break;
-	case RES_12:
-		gpio_set_value(st->res0, 0);
-		gpio_set_value(st->res1, 1);
-		break;
-	case RES_14:
-		gpio_set_value(st->res0, 1);
-		gpio_set_value(st->res1, 0);
-		break;
-	case RES_16:
-		gpio_set_value(st->res0, 1);
-		gpio_set_value(st->res1, 1);
-		break;
-	}
+	gpio_set_value(st->pdata->res[0],
+		       ad2s1210_res_pins[(st->resolution - 10)/2][0]);
+	gpio_set_value(st->pdata->res[1],
+		       ad2s1210_res_pins[(st->resolution - 10)/2][1]);
 }
-#endif
 
-static inline void soft_reset(struct ad2s1210_state *st)
+static inline int ad2s1210_soft_reset(struct ad2s1210_state *st)
 {
-	config_write(st, REG_SOFT_RESET);
-	config_write(st, 0x0);
+	int ret;
+
+	ret = ad2s1210_config_write(st, AD2S1210_REG_SOFT_RESET);
+	if (ret < 0)
+		return ret;
+
+	return ad2s1210_config_write(st, 0x0);
 }
 
 
 /* return the OLD DATA since last spi bus write */
 static ssize_t ad2s1210_show_raw(struct device *dev,
-			struct device_attribute *attr, char *buf)
+				 struct device_attribute *attr,
+				 char *buf)
 {
-	struct iio_dev *idev = dev_get_drvdata(dev);
-	struct ad2s1210_state *st = idev->dev_data;
-	int ret;
+	struct ad2s1210_state *st = iio_priv(dev_get_drvdata(dev));
+	int ret = 0;
 
 	mutex_lock(&st->lock);
 	if (st->old_data) {
 		ret = sprintf(buf, "0x%x\n", st->rx[0]);
-		st->old_data = 0;
-	} else
-		ret = 0;
+		st->old_data = false;
+	}
 	mutex_unlock(&st->lock);
+
 	return ret;
 }
 
 static ssize_t ad2s1210_store_raw(struct device *dev,
-		struct device_attribute *attr,
-		const char *buf, size_t len)
+				  struct device_attribute *attr,
+				  const char *buf,
+				  size_t len)
 {
-	struct iio_dev *idev = dev_get_drvdata(dev);
-	struct ad2s1210_state *st = idev->dev_data;
+	struct ad2s1210_state *st = iio_priv(dev_get_drvdata(dev));
 	unsigned long udata;
 	unsigned char data;
 	int ret;
@@ -266,139 +226,157 @@ static ssize_t ad2s1210_store_raw(struct device *dev,
 	ret = strict_strtoul(buf, 16, &udata);
 	if (ret)
 		return -EINVAL;
+
 	data = udata & 0xff;
 	mutex_lock(&st->lock);
-	config_write(st, data);
+	ret = ad2s1210_config_write(st, data);
 	mutex_unlock(&st->lock);
-	return 1;
+
+	return ret < 0 ? ret : len;
 }
 
 static ssize_t ad2s1210_store_softreset(struct device *dev,
-			struct device_attribute *attr,
-			const char *buf, size_t len)
+					struct device_attribute *attr,
+					const char *buf,
+					size_t len)
 {
-	struct iio_dev *idev = dev_get_drvdata(dev);
-	struct ad2s1210_state *st = idev->dev_data;
+	struct ad2s1210_state *st = iio_priv(dev_get_drvdata(dev));
+	int ret;
+
 	mutex_lock(&st->lock);
-	soft_reset(st);
+	ret = ad2s1210_soft_reset(st);
 	mutex_unlock(&st->lock);
-	return len;
+
+	return ret < 0 ? ret : len;
 }
 
 static ssize_t ad2s1210_show_fclkin(struct device *dev,
-			struct device_attribute *attr, char *buf)
+				    struct device_attribute *attr,
+				    char *buf)
 {
-	struct iio_dev *idev = dev_get_drvdata(dev);
-	struct ad2s1210_state *st = idev->dev_data;
+	struct ad2s1210_state *st = iio_priv(dev_get_drvdata(dev));
 	return sprintf(buf, "%d\n", st->fclkin);
 }
 
 static ssize_t ad2s1210_store_fclkin(struct device *dev,
-			struct device_attribute *attr,
-			const char *buf, size_t len)
+				     struct device_attribute *attr,
+				     const char *buf,
+				     size_t len)
 {
-	struct iio_dev *idev = dev_get_drvdata(dev);
-	struct ad2s1210_state *st = idev->dev_data;
+	struct ad2s1210_state *st = iio_priv(dev_get_drvdata(dev));
 	unsigned long fclkin;
 	int ret;
 
 	ret = strict_strtoul(buf, 10, &fclkin);
-	if (!ret && fclkin >= AD2S1210_MIN_CLKIN &&
-				fclkin <= AD2S1210_MAX_CLKIN) {
-		mutex_lock(&st->lock);
-		st->fclkin = fclkin;
-	} else {
+	if (ret)
+		return ret;
+	if (fclkin < AD2S1210_MIN_CLKIN || fclkin > AD2S1210_MAX_CLKIN) {
 		pr_err("ad2s1210: fclkin out of range\n");
 		return -EINVAL;
 	}
-	update_frequency_control_word(st);
-	soft_reset(st);
+
+	mutex_lock(&st->lock);
+	st->fclkin = fclkin;
+
+	ret = ad2s1210_update_frequency_control_word(st);
+	if (ret < 0)
+		goto error_ret;
+	ret = ad2s1210_soft_reset(st);
+error_ret:
 	mutex_unlock(&st->lock);
-	return len;
+
+	return ret < 0 ? ret : len;
 }
 
 static ssize_t ad2s1210_show_fexcit(struct device *dev,
-			struct device_attribute *attr, char *buf)
+				    struct device_attribute *attr,
+				    char *buf)
 {
-	struct iio_dev *idev = dev_get_drvdata(dev);
-	struct ad2s1210_state *st = idev->dev_data;
+	struct ad2s1210_state *st = iio_priv(dev_get_drvdata(dev));
 	return sprintf(buf, "%d\n", st->fexcit);
 }
 
 static ssize_t ad2s1210_store_fexcit(struct device *dev,
-			struct device_attribute *attr,
-			const char *buf, size_t len)
+				     struct device_attribute *attr,
+				     const char *buf, size_t len)
 {
-	struct iio_dev *idev = dev_get_drvdata(dev);
-	struct ad2s1210_state *st = idev->dev_data;
+	struct ad2s1210_state *st = iio_priv(dev_get_drvdata(dev));
 	unsigned long fexcit;
 	int ret;
 
 	ret = strict_strtoul(buf, 10, &fexcit);
-	if (!ret && fexcit >= AD2S1210_MIN_EXCIT &&
-				fexcit <= AD2S1210_MAX_EXCIT) {
-		mutex_lock(&st->lock);
-		st->fexcit = fexcit;
-	} else {
+	if (ret < 0)
+		return ret;
+	if (fexcit < AD2S1210_MIN_EXCIT || fexcit > AD2S1210_MAX_EXCIT) {
 		pr_err("ad2s1210: excitation frequency out of range\n");
 		return -EINVAL;
 	}
-	update_frequency_control_word(st);
-	soft_reset(st);
+	mutex_lock(&st->lock);
+	st->fexcit = fexcit;
+	ret = ad2s1210_update_frequency_control_word(st);
+	if (ret < 0)
+		goto error_ret;
+	ret = ad2s1210_soft_reset(st);
+error_ret:
 	mutex_unlock(&st->lock);
-	return len;
+
+	return ret < 0 ? ret : len;
 }
 
 static ssize_t ad2s1210_show_control(struct device *dev,
-			struct device_attribute *attr, char *buf)
+				     struct device_attribute *attr,
+				     char *buf)
 {
-	struct iio_dev *idev = dev_get_drvdata(dev);
-	struct ad2s1210_state *st = idev->dev_data;
-	unsigned char data;
+	struct ad2s1210_state *st = iio_priv(dev_get_drvdata(dev));
+	int ret;
 	mutex_lock(&st->lock);
-	config_read(st, REG_CONTROL, &data);
+	ret = ad2s1210_config_read(st, AD2S1210_REG_CONTROL);
 	mutex_unlock(&st->lock);
-	return sprintf(buf, "0x%x\n", data);
+	return ret < 0 ? ret : sprintf(buf, "0x%x\n", ret);
 }
 
 static ssize_t ad2s1210_store_control(struct device *dev,
 			struct device_attribute *attr,
 			const char *buf, size_t len)
 {
-	struct iio_dev *idev = dev_get_drvdata(dev);
-	struct ad2s1210_state *st = idev->dev_data;
+	struct ad2s1210_state *st = iio_priv(dev_get_drvdata(dev));
 	unsigned long udata;
 	unsigned char data;
 	int ret;
 
 	ret = strict_strtoul(buf, 16, &udata);
-	if (ret) {
-		ret = -EINVAL;
-		goto error_ret;
-	}
+	if (ret)
+		return -EINVAL;
+
 	mutex_lock(&st->lock);
-	config_write(st, REG_CONTROL);
-	data = udata & MSB_IS_LOW;
-	config_write(st, data);
-	config_read(st, REG_CONTROL, &data);
-	if (data & MSB_IS_HIGH) {
+	ret = ad2s1210_config_write(st, AD2S1210_REG_CONTROL);
+	if (ret < 0)
+		goto error_ret;
+	data = udata & AD2S1210_MSB_IS_LOW;
+	ret = ad2s1210_config_write(st, data);
+	if (ret < 0)
+		goto error_ret;
+
+	ret = ad2s1210_config_read(st, AD2S1210_REG_CONTROL);
+	if (ret < 0)
+		goto error_ret;
+	if (ret & AD2S1210_MSB_IS_HIGH) {
 		ret = -EIO;
 		pr_err("ad2s1210: write control register fail\n");
 		goto error_ret;
 	}
-	st->resolution = resolution_value[data & SET_RESOLUTION];
-#if defined(CONFIG_AD2S1210_GPIO_INPUT)
-	data = read_resolution_pin(st);
-	if (data != st->resolution)
-		pr_warning("ad2s1210: resolution settings not match\n");
-#elif defined(CONFIG_AD2S1210_GPIO_OUTPUT)
-	set_resolution_pin(st);
-#endif
+	st->resolution
+		= ad2s1210_resolution_value[data & AD2S1210_SET_RESOLUTION];
+	if (st->pdata->gpioin) {
+		data = ad2s1210_read_resolution_pin(st);
+		if (data != st->resolution)
+			pr_warning("ad2s1210: resolution settings not match\n");
+	} else
+		ad2s1210_set_resolution_pin(st);
+
 	ret = len;
-	if (data & ENABLE_HYSTERESIS)
-		st->hysteresis = 1;
-	else
-		st->hysteresis = 0;
+	st->hysteresis = !!(data & AD2S1210_ENABLE_HYSTERESIS);
+
 error_ret:
 	mutex_unlock(&st->lock);
 	return ret;
@@ -407,8 +385,7 @@ static ssize_t ad2s1210_store_control(struct device *dev,
 static ssize_t ad2s1210_show_resolution(struct device *dev,
 			struct device_attribute *attr, char *buf)
 {
-	struct iio_dev *idev = dev_get_drvdata(dev);
-	struct ad2s1210_state *st = idev->dev_data;
+	struct ad2s1210_state *st = iio_priv(dev_get_drvdata(dev));
 	return sprintf(buf, "%d\n", st->resolution);
 }
 
@@ -416,103 +393,109 @@ static ssize_t ad2s1210_store_resolution(struct device *dev,
 			struct device_attribute *attr,
 			const char *buf, size_t len)
 {
-	struct iio_dev *idev = dev_get_drvdata(dev);
-	struct ad2s1210_state *st = idev->dev_data;
+	struct ad2s1210_state *st = iio_priv(dev_get_drvdata(dev));
 	unsigned char data;
 	unsigned long udata;
 	int ret;
 
 	ret = strict_strtoul(buf, 10, &udata);
-	if (ret || udata < RES_10 || udata > RES_16) {
+	if (ret || udata < 10 || udata > 16) {
 		pr_err("ad2s1210: resolution out of range\n");
 		return -EINVAL;
 	}
 	mutex_lock(&st->lock);
-	config_read(st, REG_CONTROL, &data);
-	data &= ~SET_RESOLUTION;
-	data |= (udata - RES_10) >> 1;
-	config_write(st, REG_CONTROL);
-	config_write(st, data & MSB_IS_LOW);
-	config_read(st, REG_CONTROL, &data);
-	if (data & MSB_IS_HIGH) {
+	ret = ad2s1210_config_read(st, AD2S1210_REG_CONTROL);
+	if (ret < 0)
+		goto error_ret;
+	data = ret;
+	data &= ~AD2S1210_SET_RESOLUTION;
+	data |= (udata - 10) >> 1;
+	ret = ad2s1210_config_write(st, AD2S1210_REG_CONTROL);
+	if (ret < 0)
+		goto error_ret;
+	ret = ad2s1210_config_write(st, data & AD2S1210_MSB_IS_LOW);
+	if (ret < 0)
+		goto error_ret;
+	ret = ad2s1210_config_read(st, AD2S1210_REG_CONTROL);
+	if (ret < 0)
+		goto error_ret;
+	data = ret;
+	if (data & AD2S1210_MSB_IS_HIGH) {
 		ret = -EIO;
 		pr_err("ad2s1210: setting resolution fail\n");
 		goto error_ret;
 	}
-	st->resolution = resolution_value[data & SET_RESOLUTION];
-#if defined(CONFIG_AD2S1210_GPIO_INPUT)
-	data = read_resolution_pin(st);
-	if (data != st->resolution)
-		pr_warning("ad2s1210: resolution settings not match\n");
-#elif defined(CONFIG_AD2S1210_GPIO_OUTPUT)
-	set_resolution_pin(st);
-#endif
+	st->resolution
+		= ad2s1210_resolution_value[data & AD2S1210_SET_RESOLUTION];
+	if (st->pdata->gpioin) {
+		data = ad2s1210_read_resolution_pin(st);
+		if (data != st->resolution)
+			pr_warning("ad2s1210: resolution settings not match\n");
+	} else
+		ad2s1210_set_resolution_pin(st);
 	ret = len;
 error_ret:
 	mutex_unlock(&st->lock);
 	return ret;
 }
+
 /* read the fault register since last sample */
 static ssize_t ad2s1210_show_fault(struct device *dev,
 			struct device_attribute *attr, char *buf)
 {
-	int ret = 0;
-	ssize_t len = 0;
-	unsigned char data;
-	struct iio_dev *idev = dev_get_drvdata(dev);
-	struct ad2s1210_state *st = idev->dev_data;
+	struct ad2s1210_state *st = iio_priv(dev_get_drvdata(dev));
+	int ret;
 
 	mutex_lock(&st->lock);
-	ret = config_read(st, REG_FAULT, &data);
-
-	if (ret)
-		goto error_ret;
-	len = sprintf(buf, "0x%x\n", data);
-error_ret:
+	ret = ad2s1210_config_read(st, AD2S1210_REG_FAULT);
 	mutex_unlock(&st->lock);
-	return ret ? ret : len;
+
+	return ret ? ret : sprintf(buf, "0x%x\n", ret);
 }
 
 static ssize_t ad2s1210_clear_fault(struct device *dev,
-			struct device_attribute *attr,
-			const char *buf, size_t len)
+				    struct device_attribute *attr,
+				    const char *buf,
+				    size_t len)
 {
-	struct iio_dev *idev = dev_get_drvdata(dev);
-	struct ad2s1210_state *st = idev->dev_data;
-	unsigned char data;
+	struct ad2s1210_state *st = iio_priv(dev_get_drvdata(dev));
+	int ret;
 
 	mutex_lock(&st->lock);
-	start_sample(st);
+	gpio_set_value(st->pdata->sample, 0);
 	/* delay (2 * tck + 20) nano seconds */
 	udelay(1);
-	stop_sample(st);
-	config_read(st, REG_FAULT, &data);
-	start_sample(st);
-	stop_sample(st);
+	gpio_set_value(st->pdata->sample, 1);
+	ret = ad2s1210_config_read(st, AD2S1210_REG_FAULT);
+	if (ret < 0)
+		goto error_ret;
+	gpio_set_value(st->pdata->sample, 0);
+	gpio_set_value(st->pdata->sample, 1);
+error_ret:
 	mutex_unlock(&st->lock);
 
-	return 0;
+	return ret < 0 ? ret : len;
 }
 
 static ssize_t ad2s1210_show_reg(struct device *dev,
-			struct device_attribute *attr, char *buf)
+				 struct device_attribute *attr,
+				 char *buf)
 {
-	struct iio_dev *idev = dev_get_drvdata(dev);
-	struct ad2s1210_state *st = idev->dev_data;
-	unsigned char data;
+	struct ad2s1210_state *st = iio_priv(dev_get_drvdata(dev));
 	struct iio_dev_attr *iattr = to_iio_dev_attr(attr);
+	int ret;
 
 	mutex_lock(&st->lock);
-	config_read(st, iattr->address, &data);
+	ret = ad2s1210_config_read(st, iattr->address);
 	mutex_unlock(&st->lock);
-	return sprintf(buf, "%d\n", data);
+
+	return ret < 0 ? ret : sprintf(buf, "%d\n", ret);
 }
 
 static ssize_t ad2s1210_store_reg(struct device *dev,
 		struct device_attribute *attr, const char *buf, size_t len)
 {
-	struct iio_dev *idev = dev_get_drvdata(dev);
-	struct ad2s1210_state *st = idev->dev_data;
+	struct ad2s1210_state *st = iio_priv(dev_get_drvdata(dev));
 	unsigned long data;
 	int ret;
 	struct iio_dev_attr *iattr = to_iio_dev_attr(attr);
@@ -521,183 +504,121 @@ static ssize_t ad2s1210_store_reg(struct device *dev,
 	if (ret)
 		return -EINVAL;
 	mutex_lock(&st->lock);
-	config_write(st, iattr->address);
-	config_write(st, data & MSB_IS_LOW);
+	ret = ad2s1210_config_write(st, iattr->address);
+	if (ret < 0)
+		goto error_ret;
+	ret = ad2s1210_config_write(st, data & AD2S1210_MSB_IS_LOW);
+error_ret:
 	mutex_unlock(&st->lock);
-	return len;
+	return ret < 0 ? ret : len;
 }
 
 static ssize_t ad2s1210_show_pos(struct device *dev,
-			struct device_attribute *attr, char *buf)
+				 struct device_attribute *attr,
+				 char *buf)
 {
-	struct spi_message msg;
 	int ret = 0;
 	ssize_t len = 0;
 	u16 pos;
-	struct iio_dev *idev = dev_get_drvdata(dev);
-	struct ad2s1210_state *st = idev->dev_data;
+	struct ad2s1210_state *st = iio_priv(dev_get_drvdata(dev));
 
-	st->xfer.len = 2;
 	mutex_lock(&st->lock);
-	start_sample(st);
+	gpio_set_value(st->pdata->sample, 0);
 	/* delay (6 * tck + 20) nano seconds */
 	udelay(1);
 
-	set_mode(MOD_POS, st);
-
-	spi_message_init(&msg);
-	spi_message_add_tail(&st->xfer, &msg);
-	ret = spi_sync(st->sdev, &msg);
+	ad2s1210_set_mode(MOD_POS, st);
+	ret = spi_read(st->sdev, st->rx, 2);
 	if (ret)
 		goto error_ret;
-	pos = ((((u16)(st->rx[0])) << 8) | (st->rx[1]));
+	pos = be16_to_cpup((u16 *)st->rx);
 	if (st->hysteresis)
 		pos >>= 16 - st->resolution;
 	len = sprintf(buf, "%d\n", pos);
 error_ret:
-	stop_sample(st);
+	gpio_set_value(st->pdata->sample, 1);
 	/* delay (2 * tck + 20) nano seconds */
 	udelay(1);
 	mutex_unlock(&st->lock);
 
-	return ret ? ret : len;
+	return ret < 0 ? ret : len;
 }
 
 static ssize_t ad2s1210_show_vel(struct device *dev,
-			struct device_attribute *attr, char *buf)
+				 struct device_attribute *attr,
+				 char *buf)
 {
-	struct spi_message msg;
 	unsigned short negative;
 	int ret = 0;
 	ssize_t len = 0;
 	s16 vel;
-	struct iio_dev *idev = dev_get_drvdata(dev);
-	struct ad2s1210_state *st = idev->dev_data;
+	struct ad2s1210_state *st = iio_priv(dev_get_drvdata(dev));
 
-	st->xfer.len = 2;
 	mutex_lock(&st->lock);
-	start_sample(st);
+	gpio_set_value(st->pdata->sample, 0);
 	/* delay (6 * tck + 20) nano seconds */
 	udelay(1);
 
-	set_mode(MOD_VEL, st);
-
-	spi_message_init(&msg);
-	spi_message_add_tail(&st->xfer, &msg);
-	ret = spi_sync(st->sdev, &msg);
+	ad2s1210_set_mode(MOD_VEL, st);
+	ret = spi_read(st->sdev, st->rx, 2);
 	if (ret)
 		goto error_ret;
 	negative = st->rx[0] & 0x80;
-	vel = ((((s16)(st->rx[0])) << 8) | (st->rx[1]));
+	vel = be16_to_cpup((s16 *)st->rx);
 	vel >>= 16 - st->resolution;
-	if (negative) {
+	if (vel & 0x8000) {
 		negative = (0xffff >> st->resolution) << st->resolution;
 		vel |= negative;
 	}
 	len = sprintf(buf, "%d\n", vel);
 error_ret:
-	stop_sample(st);
+	gpio_set_value(st->pdata->sample, 1);
 	/* delay (2 * tck + 20) nano seconds */
 	udelay(1);
 	mutex_unlock(&st->lock);
 
-	return ret ? ret : len;
+	return ret < 0 ? ret : len;
 }
 
-static ssize_t ad2s1210_show_pos_vel(struct device *dev,
-			struct device_attribute *attr, char *buf)
-{
-	struct spi_message msg;
-	unsigned short negative;
-	int ret = 0;
-	ssize_t len = 0;
-	u16 pos;
-	s16 vel;
-	struct iio_dev *idev = dev_get_drvdata(dev);
-	struct ad2s1210_state *st = idev->dev_data;
-
-	st->xfer.len = 2;
-	mutex_lock(&st->lock);
-	start_sample(st);
-	/* delay (6 * tck + 20) nano seconds */
-	udelay(1);
-
-	set_mode(MOD_POS, st);
-
-	spi_message_init(&msg);
-	spi_message_add_tail(&st->xfer, &msg);
-	ret = spi_sync(st->sdev, &msg);
-	if (ret)
-		goto error_ret;
-	pos = ((((u16)(st->rx[0])) << 8) | (st->rx[1]));
-	if (st->hysteresis)
-		pos >>= 16 - st->resolution;
-	len = sprintf(buf, "%d ", pos);
-
-	st->xfer.len = 2;
-	set_mode(MOD_VEL, st);
-	spi_message_init(&msg);
-	spi_message_add_tail(&st->xfer, &msg);
-	ret = spi_sync(st->sdev, &msg);
-	if (ret)
-		goto error_ret;
-	negative = st->rx[0] & 0x80;
-	vel = ((((s16)(st->rx[0])) << 8) | (st->rx[1]));
-	vel >>= 16 - st->resolution;
-	if (negative) {
-		negative = (0xffff >> st->resolution) << st->resolution;
-		vel |= negative;
-	}
-	len += sprintf(buf + len, "%d\n", vel);
-error_ret:
-	stop_sample(st);
-	/* delay (2 * tck + 20) nano seconds */
-	udelay(1);
-	mutex_unlock(&st->lock);
-
-	return ret ? ret : len;
-}
-
-static IIO_CONST_ATTR(description,
-	"Variable Resolution, 10-Bit to 16Bit R/D\n\
-Converter with Reference Oscillator");
 static IIO_DEVICE_ATTR(raw_io, S_IRUGO | S_IWUSR,
-		ad2s1210_show_raw, ad2s1210_store_raw, 0);
+		       ad2s1210_show_raw, ad2s1210_store_raw, 0);
 static IIO_DEVICE_ATTR(reset, S_IWUSR,
-		NULL, ad2s1210_store_softreset, 0);
+		       NULL, ad2s1210_store_softreset, 0);
 static IIO_DEVICE_ATTR(fclkin, S_IRUGO | S_IWUSR,
-		ad2s1210_show_fclkin, ad2s1210_store_fclkin, 0);
+		       ad2s1210_show_fclkin, ad2s1210_store_fclkin, 0);
 static IIO_DEVICE_ATTR(fexcit, S_IRUGO | S_IWUSR,
-		ad2s1210_show_fexcit,	ad2s1210_store_fexcit, 0);
+		       ad2s1210_show_fexcit,	ad2s1210_store_fexcit, 0);
 static IIO_DEVICE_ATTR(control, S_IRUGO | S_IWUSR,
-		ad2s1210_show_control, ad2s1210_store_control, 0);
+		       ad2s1210_show_control, ad2s1210_store_control, 0);
 static IIO_DEVICE_ATTR(bits, S_IRUGO | S_IWUSR,
-		ad2s1210_show_resolution, ad2s1210_store_resolution, 0);
+		       ad2s1210_show_resolution, ad2s1210_store_resolution, 0);
 static IIO_DEVICE_ATTR(fault, S_IRUGO | S_IWUSR,
-		ad2s1210_show_fault, ad2s1210_clear_fault, 0);
-static IIO_DEVICE_ATTR(pos, S_IRUGO,
-		ad2s1210_show_pos, NULL, 0);
-static IIO_DEVICE_ATTR(vel, S_IRUGO,
-		ad2s1210_show_vel, NULL, 0);
-static IIO_DEVICE_ATTR(pos_vel, S_IRUGO,
-		ad2s1210_show_pos_vel, NULL, 0);
+		       ad2s1210_show_fault, ad2s1210_clear_fault, 0);
+static IIO_DEVICE_ATTR(pos, S_IRUGO, ad2s1210_show_pos, NULL, 0);
+static IIO_DEVICE_ATTR(vel, S_IRUGO,  ad2s1210_show_vel, NULL, 0);
 static IIO_DEVICE_ATTR(los_thrd, S_IRUGO | S_IWUSR,
-		ad2s1210_show_reg, ad2s1210_store_reg, REG_LOS_THRD);
+		       ad2s1210_show_reg, ad2s1210_store_reg,
+		       AD2S1210_REG_LOS_THRD);
 static IIO_DEVICE_ATTR(dos_ovr_thrd, S_IRUGO | S_IWUSR,
-		ad2s1210_show_reg, ad2s1210_store_reg, REG_DOS_OVR_THRD);
+		       ad2s1210_show_reg, ad2s1210_store_reg,
+		       AD2S1210_REG_DOS_OVR_THRD);
 static IIO_DEVICE_ATTR(dos_mis_thrd, S_IRUGO | S_IWUSR,
-		ad2s1210_show_reg, ad2s1210_store_reg, REG_DOS_MIS_THRD);
+		       ad2s1210_show_reg, ad2s1210_store_reg,
+		       AD2S1210_REG_DOS_MIS_THRD);
 static IIO_DEVICE_ATTR(dos_rst_max_thrd, S_IRUGO | S_IWUSR,
-		ad2s1210_show_reg, ad2s1210_store_reg, REG_DOS_RST_MAX_THRD);
+		       ad2s1210_show_reg, ad2s1210_store_reg,
+		       AD2S1210_REG_DOS_RST_MAX_THRD);
 static IIO_DEVICE_ATTR(dos_rst_min_thrd, S_IRUGO | S_IWUSR,
-		ad2s1210_show_reg, ad2s1210_store_reg, REG_DOS_RST_MIN_THRD);
+		       ad2s1210_show_reg, ad2s1210_store_reg,
+		       AD2S1210_REG_DOS_RST_MIN_THRD);
 static IIO_DEVICE_ATTR(lot_high_thrd, S_IRUGO | S_IWUSR,
-		ad2s1210_show_reg, ad2s1210_store_reg, REG_LOT_HIGH_THRD);
+		       ad2s1210_show_reg, ad2s1210_store_reg,
+		       AD2S1210_REG_LOT_HIGH_THRD);
 static IIO_DEVICE_ATTR(lot_low_thrd, S_IRUGO | S_IWUSR,
-		ad2s1210_show_reg, ad2s1210_store_reg, REG_LOT_LOW_THRD);
+		       ad2s1210_show_reg, ad2s1210_store_reg,
+		       AD2S1210_REG_LOT_LOW_THRD);
 
 static struct attribute *ad2s1210_attributes[] = {
-	&iio_const_attr_description.dev_attr.attr,
 	&iio_dev_attr_raw_io.dev_attr.attr,
 	&iio_dev_attr_reset.dev_attr.attr,
 	&iio_dev_attr_fclkin.dev_attr.attr,
@@ -707,7 +628,6 @@ static struct attribute *ad2s1210_attributes[] = {
 	&iio_dev_attr_fault.dev_attr.attr,
 	&iio_dev_attr_pos.dev_attr.attr,
 	&iio_dev_attr_vel.dev_attr.attr,
-	&iio_dev_attr_pos_vel.dev_attr.attr,
 	&iio_dev_attr_los_thrd.dev_attr.attr,
 	&iio_dev_attr_dos_ovr_thrd.dev_attr.attr,
 	&iio_dev_attr_dos_mis_thrd.dev_attr.attr,
@@ -729,27 +649,32 @@ static int __devinit ad2s1210_initial(struct ad2s1210_state *st)
 	int ret;
 
 	mutex_lock(&st->lock);
-#if defined(CONFIG_AD2S1210_GPIO_INPUT)
-	st->resolution = read_resolution_pin(st);
-#elif defined(CONFIG_AD2S1210_GPIO_OUTPUT)
-	set_resolution_pin(st);
-#endif
-
-	config_write(st, REG_CONTROL);
-	data = DEF_CONTROL & ~(SET_RESOLUTION);
-	data |= (st->resolution - RES_10) >> 1;
-	config_write(st, data);
-	ret = config_read(st, REG_CONTROL, &data);
-	if (ret)
+	if (st->pdata->gpioin)
+		st->resolution = ad2s1210_read_resolution_pin(st);
+	else
+		ad2s1210_set_resolution_pin(st);
+
+	ret = ad2s1210_config_write(st, AD2S1210_REG_CONTROL);
+	if (ret < 0)
+		goto error_ret;
+	data = AD2S1210_DEF_CONTROL & ~(AD2S1210_SET_RESOLUTION);
+	data |= (st->resolution - 10) >> 1;
+	ret = ad2s1210_config_write(st, data);
+	if (ret < 0)
+		goto error_ret;
+	ret = ad2s1210_config_read(st, AD2S1210_REG_CONTROL);
+	if (ret < 0)
 		goto error_ret;
 
-	if (data & MSB_IS_HIGH) {
+	if (ret & AD2S1210_MSB_IS_HIGH) {
 		ret = -EIO;
 		goto error_ret;
 	}
 
-	update_frequency_control_word(st);
-	soft_reset(st);
+	ret = ad2s1210_update_frequency_control_word(st);
+	if (ret < 0)
+		goto error_ret;
+	ret = ad2s1210_soft_reset(st);
 error_ret:
 	mutex_unlock(&st->lock);
 	return ret;
@@ -760,90 +685,107 @@ static const struct iio_info ad2s1210_info = {
 	.driver_module = THIS_MODULE,
 };
 
+static int ad2s1210_setup_gpios(struct ad2s1210_state *st)
+{
+	int ret;
+	unsigned long flags = st->pdata->gpioin ? GPIOF_DIR_IN : GPIOF_DIR_OUT;
+
+	ret = gpio_request_one(st->pdata->sample, GPIOF_DIR_IN, "sample");
+	if (ret < 0)
+		goto error_ret;
+	ret = gpio_request_one(st->pdata->a[0], flags, "a0");
+	if (ret < 0)
+		goto error_free_sample;
+	ret = gpio_request_one(st->pdata->a[1], flags, "a1");
+	if (ret < 0)
+		goto error_free_a0;
+	ret = gpio_request_one(st->pdata->res[1], flags, "res0");
+	if (ret < 0)
+		goto error_free_a1;
+	ret = gpio_request_one(st->pdata->res[1], flags, "res1");
+	if (ret < 0)
+		goto error_free_res0;
+
+	return 0;
+error_free_res0:
+	gpio_free(st->pdata->res[0]);
+error_free_a1:
+	gpio_free(st->pdata->a[1]);
+error_free_a0:
+	gpio_free(st->pdata->a[0]);
+error_free_sample:
+	gpio_free(st->pdata->sample);
+error_ret:
+	return ret;
+}
+
+static void ad2s1210_free_gpios(struct ad2s1210_state *st)
+{
+	gpio_free(st->pdata->res[1]);
+	gpio_free(st->pdata->res[0]);
+	gpio_free(st->pdata->a[1]);
+	gpio_free(st->pdata->a[0]);
+	gpio_free(st->pdata->sample);
+}
+
 static int __devinit ad2s1210_probe(struct spi_device *spi)
 {
+	struct iio_dev *indio_dev;
 	struct ad2s1210_state *st;
-	int pn, ret = 0;
-	unsigned short *pins = spi->dev.platform_data;
-
-	for (pn = 0; pn < AD2S1210_PN; pn++) {
-		if (gpio_request(pins[pn], DRV_NAME)) {
-			pr_err("%s: request gpio pin %d failed\n",
-						DRV_NAME, pins[pn]);
-			goto error_ret;
-		}
-		if (pn < AD2S1210_SAA)
-			gpio_direction_output(pins[pn], 1);
-		else {
-#if defined(CONFIG_AD2S1210_GPIO_INPUT)
-			gpio_direction_input(pins[pn]);
-#elif defined(CONFIG_AD2S1210_GPIO_OUTPUT)
-			gpio_direction_output(pins[pn], 1);
-#endif
-		}
-	}
+	int ret;
+
+	if (spi->dev.platform_data == NULL)
+		return -EINVAL;
 
-	st = kzalloc(sizeof(*st), GFP_KERNEL);
-	if (st == NULL) {
+	indio_dev = iio_allocate_device(sizeof(*st));
+	if (indio_dev == NULL) {
 		ret = -ENOMEM;
 		goto error_ret;
 	}
-	spi_set_drvdata(spi, st);
+	st = iio_priv(indio_dev);
+	st->pdata = spi->dev.platform_data;
+	ret = ad2s1210_setup_gpios(st);
+	if (ret < 0)
+		goto error_free_dev;
+
+	spi_set_drvdata(spi, indio_dev);
 
 	mutex_init(&st->lock);
 	st->sdev = spi;
-	st->xfer.tx_buf = st->tx;
-	st->xfer.rx_buf = st->rx;
-	st->hysteresis = 1;
+	st->hysteresis = true;
 	st->mode = MOD_CONFIG;
-	st->resolution = RES_12;
-	st->fclkin = AD2S1210_DEF_CLKIN;
+	st->resolution = 12;
 	st->fexcit = AD2S1210_DEF_EXCIT;
-	st->sample = pins[0];
-	st->a0 = pins[1];
-	st->a1 = pins[2];
-	st->res0 = pins[3];
-	st->res1 = pins[4];
-
-	st->idev = iio_allocate_device(0);
-	if (st->idev == NULL) {
-		ret = -ENOMEM;
-		goto error_free_st;
-	}
-	st->idev->dev.parent = &spi->dev;
 
-	st->idev->info = &ad2s1210_info;
-	st->idev->dev_data = (void *)(st);
-	st->idev->modes = INDIO_DIRECT_MODE;
+	indio_dev->dev.parent = &spi->dev;
+	indio_dev->info = &ad2s1210_info;
+	indio_dev->modes = INDIO_DIRECT_MODE;
 
-	ret = iio_device_register(st->idev);
+	ret = iio_device_register(indio_dev);
 	if (ret)
-		goto error_free_dev;
+		goto error_free_gpios;
 
-	if (spi->max_speed_hz != AD2S1210_DEF_CLKIN)
-		st->fclkin = spi->max_speed_hz;
+	st->fclkin = spi->max_speed_hz;
 	spi->mode = SPI_MODE_3;
 	spi_setup(spi);
-
 	ad2s1210_initial(st);
+
 	return 0;
 
+error_free_gpios:
+	ad2s1210_free_gpios(st);
 error_free_dev:
-	iio_free_device(st->idev);
-error_free_st:
-	kfree(st);
+	iio_free_device(indio_dev);
 error_ret:
-	for (--pn; pn >= 0; pn--)
-		gpio_free(pins[pn]);
 	return ret;
 }
 
 static int __devexit ad2s1210_remove(struct spi_device *spi)
 {
-	struct ad2s1210_state *st = spi_get_drvdata(spi);
-
-	iio_device_unregister(st->idev);
-	kfree(st);
+	struct iio_dev *indio_dev = spi_get_drvdata(spi);
+	struct ad2s1210_state *st = iio_priv(indio_dev);
+	iio_device_unregister(indio_dev);
+	ad2s1210_free_gpios(st);
 
 	return 0;
 }

commit 6fe8135fccd66aedcc55ded70824342587fd2499
Author: Jonathan Cameron <jic23@cam.ac.uk>
Date:   Wed May 18 14:42:37 2011 +0100

    staging:iio: implement an iio_info structure to take some of the constant elements out of iio_dev.
    
    This was suggested by Arnd Bergmann,  Other elements may well
    move in here in future, but it definitely makes sense for these.
    
    Signed-off-by: Jonathan Cameron <jic23@cam.ac.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/iio/resolver/ad2s1210.c b/drivers/staging/iio/resolver/ad2s1210.c
index dc7cae80cf3a..09f4fcfda73a 100644
--- a/drivers/staging/iio/resolver/ad2s1210.c
+++ b/drivers/staging/iio/resolver/ad2s1210.c
@@ -755,6 +755,11 @@ static int __devinit ad2s1210_initial(struct ad2s1210_state *st)
 	return ret;
 }
 
+static const struct iio_info ad2s1210_info = {
+	.attrs = &ad2s1210_attribute_group,
+	.driver_module = THIS_MODULE,
+};
+
 static int __devinit ad2s1210_probe(struct spi_device *spi)
 {
 	struct ad2s1210_state *st;
@@ -806,12 +811,9 @@ static int __devinit ad2s1210_probe(struct spi_device *spi)
 		goto error_free_st;
 	}
 	st->idev->dev.parent = &spi->dev;
-	st->idev->num_interrupt_lines = 0;
-	st->idev->event_attrs = NULL;
 
-	st->idev->attrs = &ad2s1210_attribute_group;
+	st->idev->info = &ad2s1210_info;
 	st->idev->dev_data = (void *)(st);
-	st->idev->driver_module = THIS_MODULE;
 	st->idev->modes = INDIO_DIRECT_MODE;
 
 	ret = iio_device_register(st->idev);

commit 6f7c8ee585e9db54cb29af1bdb93f29837824933
Author: Jonathan Cameron <jic23@cam.ac.uk>
Date:   Fri Apr 15 18:55:56 2011 +0100

    staging:iio: Add ability to allocate private data space to iio_allocate_device
    
    Suggested by Arnd Bergmann.  Note this will break ALL drivers that
    are out of mainline.  The fix is trivial change of
    iio_allocate_device() -> iio_allocate_device(0)
    Sorry if this causes issues for any one!
    
    V2: Include new drivers in the update
    
    Signed-off-by: Jonathan Cameron <jic23@cam.ac.uk>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/iio/resolver/ad2s1210.c b/drivers/staging/iio/resolver/ad2s1210.c
index c12f64cc40df..dc7cae80cf3a 100644
--- a/drivers/staging/iio/resolver/ad2s1210.c
+++ b/drivers/staging/iio/resolver/ad2s1210.c
@@ -800,7 +800,7 @@ static int __devinit ad2s1210_probe(struct spi_device *spi)
 	st->res0 = pins[3];
 	st->res1 = pins[4];
 
-	st->idev = iio_allocate_device();
+	st->idev = iio_allocate_device(0);
 	if (st->idev == NULL) {
 		ret = -ENOMEM;
 		goto error_free_st;

commit 983bbfd091be5b3e1a729f31cce29431fbff2d27
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Fri Dec 10 10:56:18 2010 -0800

    Staging: iio: fix up world writable sysfs files.
    
    You should not be able to write to sysfs files from any user.
    
    Cc: Graf Yang <graf.yang@analog.com>
    Cc: Michael Hennerich <michael.hennerich@analog.com>
    Cc: Jonathan Cameron <jic23@cam.ac.uk>
    Cc: Mike Frysinger <vapier@gentoo.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/iio/resolver/ad2s1210.c b/drivers/staging/iio/resolver/ad2s1210.c
index 34fb21aa8b07..c12f64cc40df 100644
--- a/drivers/staging/iio/resolver/ad2s1210.c
+++ b/drivers/staging/iio/resolver/ad2s1210.c
@@ -661,19 +661,19 @@ static ssize_t ad2s1210_show_pos_vel(struct device *dev,
 static IIO_CONST_ATTR(description,
 	"Variable Resolution, 10-Bit to 16Bit R/D\n\
 Converter with Reference Oscillator");
-static IIO_DEVICE_ATTR(raw_io, S_IRUGO | S_IWUGO,
+static IIO_DEVICE_ATTR(raw_io, S_IRUGO | S_IWUSR,
 		ad2s1210_show_raw, ad2s1210_store_raw, 0);
-static IIO_DEVICE_ATTR(reset, S_IWUGO,
+static IIO_DEVICE_ATTR(reset, S_IWUSR,
 		NULL, ad2s1210_store_softreset, 0);
-static IIO_DEVICE_ATTR(fclkin, S_IRUGO | S_IWUGO,
+static IIO_DEVICE_ATTR(fclkin, S_IRUGO | S_IWUSR,
 		ad2s1210_show_fclkin, ad2s1210_store_fclkin, 0);
-static IIO_DEVICE_ATTR(fexcit, S_IRUGO | S_IWUGO,
+static IIO_DEVICE_ATTR(fexcit, S_IRUGO | S_IWUSR,
 		ad2s1210_show_fexcit,	ad2s1210_store_fexcit, 0);
-static IIO_DEVICE_ATTR(control, S_IRUGO | S_IWUGO,
+static IIO_DEVICE_ATTR(control, S_IRUGO | S_IWUSR,
 		ad2s1210_show_control, ad2s1210_store_control, 0);
-static IIO_DEVICE_ATTR(bits, S_IRUGO | S_IWUGO,
+static IIO_DEVICE_ATTR(bits, S_IRUGO | S_IWUSR,
 		ad2s1210_show_resolution, ad2s1210_store_resolution, 0);
-static IIO_DEVICE_ATTR(fault, S_IRUGO | S_IWUGO,
+static IIO_DEVICE_ATTR(fault, S_IRUGO | S_IWUSR,
 		ad2s1210_show_fault, ad2s1210_clear_fault, 0);
 static IIO_DEVICE_ATTR(pos, S_IRUGO,
 		ad2s1210_show_pos, NULL, 0);
@@ -681,19 +681,19 @@ static IIO_DEVICE_ATTR(vel, S_IRUGO,
 		ad2s1210_show_vel, NULL, 0);
 static IIO_DEVICE_ATTR(pos_vel, S_IRUGO,
 		ad2s1210_show_pos_vel, NULL, 0);
-static IIO_DEVICE_ATTR(los_thrd, S_IRUGO | S_IWUGO,
+static IIO_DEVICE_ATTR(los_thrd, S_IRUGO | S_IWUSR,
 		ad2s1210_show_reg, ad2s1210_store_reg, REG_LOS_THRD);
-static IIO_DEVICE_ATTR(dos_ovr_thrd, S_IRUGO | S_IWUGO,
+static IIO_DEVICE_ATTR(dos_ovr_thrd, S_IRUGO | S_IWUSR,
 		ad2s1210_show_reg, ad2s1210_store_reg, REG_DOS_OVR_THRD);
-static IIO_DEVICE_ATTR(dos_mis_thrd, S_IRUGO | S_IWUGO,
+static IIO_DEVICE_ATTR(dos_mis_thrd, S_IRUGO | S_IWUSR,
 		ad2s1210_show_reg, ad2s1210_store_reg, REG_DOS_MIS_THRD);
-static IIO_DEVICE_ATTR(dos_rst_max_thrd, S_IRUGO | S_IWUGO,
+static IIO_DEVICE_ATTR(dos_rst_max_thrd, S_IRUGO | S_IWUSR,
 		ad2s1210_show_reg, ad2s1210_store_reg, REG_DOS_RST_MAX_THRD);
-static IIO_DEVICE_ATTR(dos_rst_min_thrd, S_IRUGO | S_IWUGO,
+static IIO_DEVICE_ATTR(dos_rst_min_thrd, S_IRUGO | S_IWUSR,
 		ad2s1210_show_reg, ad2s1210_store_reg, REG_DOS_RST_MIN_THRD);
-static IIO_DEVICE_ATTR(lot_high_thrd, S_IRUGO | S_IWUGO,
+static IIO_DEVICE_ATTR(lot_high_thrd, S_IRUGO | S_IWUSR,
 		ad2s1210_show_reg, ad2s1210_store_reg, REG_LOT_HIGH_THRD);
-static IIO_DEVICE_ATTR(lot_low_thrd, S_IRUGO | S_IWUGO,
+static IIO_DEVICE_ATTR(lot_low_thrd, S_IRUGO | S_IWUSR,
 		ad2s1210_show_reg, ad2s1210_store_reg, REG_LOT_LOW_THRD);
 
 static struct attribute *ad2s1210_attributes[] = {

commit 817e5c65c511d4a83686333ae75507deb4b55d5e
Author: Graf Yang <graf.yang@analog.com>
Date:   Wed Oct 27 21:44:21 2010 -0400

    staging: iio: resolver: new driver for AD2S1210 devices
    
    Signed-off-by: Graf Yang <graf.yang@analog.com>
    Signed-off-by: Michael Hennerich <michael.hennerich@analog.com>
    Acked-by: Jonathan Cameron <jic23@cam.ac.uk>
    Signed-off-by: Mike Frysinger <vapier@gentoo.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/iio/resolver/ad2s1210.c b/drivers/staging/iio/resolver/ad2s1210.c
new file mode 100644
index 000000000000..34fb21aa8b07
--- /dev/null
+++ b/drivers/staging/iio/resolver/ad2s1210.c
@@ -0,0 +1,872 @@
+/*
+ * ad2s1210.c support for the ADI Resolver to Digital Converters: AD2S1210
+ *
+ * Copyright (c) 2010-2010 Analog Devices Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+#include <linux/types.h>
+#include <linux/mutex.h>
+#include <linux/device.h>
+#include <linux/spi/spi.h>
+#include <linux/slab.h>
+#include <linux/sysfs.h>
+#include <linux/delay.h>
+#include <linux/gpio.h>
+
+#include "../iio.h"
+#include "../sysfs.h"
+
+#define DRV_NAME "ad2s1210"
+
+#define DEF_CONTROL		0x7E
+
+#define MSB_IS_HIGH		0x80
+#define MSB_IS_LOW		0x7F
+#define PHASE_LOCK_RANGE_44	0x20
+#define ENABLE_HYSTERESIS	0x10
+#define SET_ENRES1		0x08
+#define SET_ENRES0		0x04
+#define SET_RES1		0x02
+#define SET_RES0		0x01
+
+#define SET_ENRESOLUTION	(SET_ENRES1 | SET_ENRES0)
+#define SET_RESOLUTION		(SET_RES1 | SET_RES0)
+
+#define REG_POSITION		0x80
+#define REG_VELOCITY		0x82
+#define REG_LOS_THRD		0x88
+#define REG_DOS_OVR_THRD	0x89
+#define REG_DOS_MIS_THRD	0x8A
+#define REG_DOS_RST_MAX_THRD	0x8B
+#define REG_DOS_RST_MIN_THRD	0x8C
+#define REG_LOT_HIGH_THRD	0x8D
+#define REG_LOT_LOW_THRD	0x8E
+#define REG_EXCIT_FREQ		0x91
+#define REG_CONTROL		0x92
+#define REG_SOFT_RESET		0xF0
+#define REG_FAULT		0xFF
+
+/* pin SAMPLE, A0, A1, RES0, RES1, is controlled by driver */
+#define AD2S1210_SAA		3
+#if defined(CONFIG_AD2S1210_GPIO_INPUT) || defined(CONFIG_AD2S1210_GPIO_OUTPUT)
+# define AD2S1210_RES		2
+#else
+# define AD2S1210_RES		0
+#endif
+#define AD2S1210_PN		(AD2S1210_SAA + AD2S1210_RES)
+
+#define AD2S1210_MIN_CLKIN	6144000
+#define AD2S1210_MAX_CLKIN	10240000
+#define AD2S1210_MIN_EXCIT	2000
+#define AD2S1210_MAX_EXCIT	20000
+#define AD2S1210_MIN_FCW	0x4
+#define AD2S1210_MAX_FCW	0x50
+
+/* default input clock on serial interface */
+#define AD2S1210_DEF_CLKIN	8192000
+/* clock period in nano second */
+#define AD2S1210_DEF_TCK	(1000000000/AD2S1210_DEF_CLKIN)
+#define AD2S1210_DEF_EXCIT	10000
+
+enum ad2s1210_mode {
+	MOD_POS = 0,
+	MOD_VEL,
+	MOD_RESERVED,
+	MOD_CONFIG,
+};
+
+enum ad2s1210_res {
+	RES_10 = 10,
+	RES_12 = 12,
+	RES_14 = 14,
+	RES_16 = 16,
+};
+
+static unsigned int resolution_value[] = {
+		RES_10, RES_12, RES_14, RES_16};
+
+struct ad2s1210_state {
+	struct mutex lock;
+	struct iio_dev *idev;
+	struct spi_device *sdev;
+	struct spi_transfer xfer;
+	unsigned int hysteresis;
+	unsigned int old_data;
+	enum ad2s1210_mode mode;
+	enum ad2s1210_res resolution;
+	unsigned int fclkin;
+	unsigned int fexcit;
+	unsigned short sample;
+	unsigned short a0;
+	unsigned short a1;
+	unsigned short res0;
+	unsigned short res1;
+	u8 rx[3];
+	u8 tx[3];
+};
+
+static inline void start_sample(struct ad2s1210_state *st)
+{
+	gpio_set_value(st->sample, 0);
+}
+
+static inline void stop_sample(struct ad2s1210_state *st)
+{
+	gpio_set_value(st->sample, 1);
+}
+
+static inline void set_mode(enum ad2s1210_mode mode, struct ad2s1210_state *st)
+{
+	switch (mode) {
+	case MOD_POS:
+		gpio_set_value(st->a0, 0);
+		gpio_set_value(st->a1, 0);
+		break;
+	case MOD_VEL:
+		gpio_set_value(st->a0, 0);
+		gpio_set_value(st->a1, 1);
+		break;
+	case MOD_CONFIG:
+		gpio_set_value(st->a0, 1);
+		gpio_set_value(st->a1, 1);
+		break;
+	default:
+		/* set to reserved mode */
+		gpio_set_value(st->a0, 1);
+		gpio_set_value(st->a1, 0);
+	}
+	st->mode = mode;
+}
+
+/* write 1 bytes (address or data) to the chip */
+static int config_write(struct ad2s1210_state *st,
+					unsigned char data)
+{
+	struct spi_message msg;
+	int ret = 0;
+
+	st->xfer.len = 1;
+	set_mode(MOD_CONFIG, st);
+
+	spi_message_init(&msg);
+	spi_message_add_tail(&st->xfer, &msg);
+	st->tx[0] = data;
+	ret = spi_sync(st->sdev, &msg);
+	if (ret)
+		return ret;
+	st->old_data = 1;
+	return ret;
+}
+
+/* read value from one of the registers */
+static int config_read(struct ad2s1210_state *st,
+				unsigned char address,
+					unsigned char *data)
+{
+	struct spi_message msg;
+	int ret = 0;
+
+	st->xfer.len = 2;
+	set_mode(MOD_CONFIG, st);
+
+	spi_message_init(&msg);
+	spi_message_add_tail(&st->xfer, &msg);
+	st->tx[0] = address | MSB_IS_HIGH;
+	st->tx[1] = REG_FAULT;
+	ret = spi_sync(st->sdev, &msg);
+	if (ret)
+		return ret;
+	*data = st->rx[1];
+	st->old_data = 1;
+	return ret;
+}
+
+static inline void update_frequency_control_word(struct ad2s1210_state *st)
+{
+	unsigned char fcw;
+	fcw = (unsigned char)(st->fexcit * (1 << 15) / st->fclkin);
+	if (fcw >= AD2S1210_MIN_FCW && fcw <= AD2S1210_MAX_FCW) {
+		config_write(st, REG_EXCIT_FREQ);
+		config_write(st, fcw);
+	} else
+		pr_err("ad2s1210: FCW out of range\n");
+}
+
+#if defined(CONFIG_AD2S1210_GPIO_INPUT)
+static inline unsigned char read_resolution_pin(struct ad2s1210_state *st)
+{
+	unsigned int data;
+	data = (gpio_get_value(st->res0) << 1)  |
+			gpio_get_value(st->res1);
+	return resolution_value[data];
+}
+#elif defined(CONFIG_AD2S1210_GPIO_OUTPUT)
+static inline void set_resolution_pin(struct ad2s1210_state *st)
+{
+	switch (st->resolution) {
+	case RES_10:
+		gpio_set_value(st->res0, 0);
+		gpio_set_value(st->res1, 0);
+		break;
+	case RES_12:
+		gpio_set_value(st->res0, 0);
+		gpio_set_value(st->res1, 1);
+		break;
+	case RES_14:
+		gpio_set_value(st->res0, 1);
+		gpio_set_value(st->res1, 0);
+		break;
+	case RES_16:
+		gpio_set_value(st->res0, 1);
+		gpio_set_value(st->res1, 1);
+		break;
+	}
+}
+#endif
+
+static inline void soft_reset(struct ad2s1210_state *st)
+{
+	config_write(st, REG_SOFT_RESET);
+	config_write(st, 0x0);
+}
+
+
+/* return the OLD DATA since last spi bus write */
+static ssize_t ad2s1210_show_raw(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	struct iio_dev *idev = dev_get_drvdata(dev);
+	struct ad2s1210_state *st = idev->dev_data;
+	int ret;
+
+	mutex_lock(&st->lock);
+	if (st->old_data) {
+		ret = sprintf(buf, "0x%x\n", st->rx[0]);
+		st->old_data = 0;
+	} else
+		ret = 0;
+	mutex_unlock(&st->lock);
+	return ret;
+}
+
+static ssize_t ad2s1210_store_raw(struct device *dev,
+		struct device_attribute *attr,
+		const char *buf, size_t len)
+{
+	struct iio_dev *idev = dev_get_drvdata(dev);
+	struct ad2s1210_state *st = idev->dev_data;
+	unsigned long udata;
+	unsigned char data;
+	int ret;
+
+	ret = strict_strtoul(buf, 16, &udata);
+	if (ret)
+		return -EINVAL;
+	data = udata & 0xff;
+	mutex_lock(&st->lock);
+	config_write(st, data);
+	mutex_unlock(&st->lock);
+	return 1;
+}
+
+static ssize_t ad2s1210_store_softreset(struct device *dev,
+			struct device_attribute *attr,
+			const char *buf, size_t len)
+{
+	struct iio_dev *idev = dev_get_drvdata(dev);
+	struct ad2s1210_state *st = idev->dev_data;
+	mutex_lock(&st->lock);
+	soft_reset(st);
+	mutex_unlock(&st->lock);
+	return len;
+}
+
+static ssize_t ad2s1210_show_fclkin(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	struct iio_dev *idev = dev_get_drvdata(dev);
+	struct ad2s1210_state *st = idev->dev_data;
+	return sprintf(buf, "%d\n", st->fclkin);
+}
+
+static ssize_t ad2s1210_store_fclkin(struct device *dev,
+			struct device_attribute *attr,
+			const char *buf, size_t len)
+{
+	struct iio_dev *idev = dev_get_drvdata(dev);
+	struct ad2s1210_state *st = idev->dev_data;
+	unsigned long fclkin;
+	int ret;
+
+	ret = strict_strtoul(buf, 10, &fclkin);
+	if (!ret && fclkin >= AD2S1210_MIN_CLKIN &&
+				fclkin <= AD2S1210_MAX_CLKIN) {
+		mutex_lock(&st->lock);
+		st->fclkin = fclkin;
+	} else {
+		pr_err("ad2s1210: fclkin out of range\n");
+		return -EINVAL;
+	}
+	update_frequency_control_word(st);
+	soft_reset(st);
+	mutex_unlock(&st->lock);
+	return len;
+}
+
+static ssize_t ad2s1210_show_fexcit(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	struct iio_dev *idev = dev_get_drvdata(dev);
+	struct ad2s1210_state *st = idev->dev_data;
+	return sprintf(buf, "%d\n", st->fexcit);
+}
+
+static ssize_t ad2s1210_store_fexcit(struct device *dev,
+			struct device_attribute *attr,
+			const char *buf, size_t len)
+{
+	struct iio_dev *idev = dev_get_drvdata(dev);
+	struct ad2s1210_state *st = idev->dev_data;
+	unsigned long fexcit;
+	int ret;
+
+	ret = strict_strtoul(buf, 10, &fexcit);
+	if (!ret && fexcit >= AD2S1210_MIN_EXCIT &&
+				fexcit <= AD2S1210_MAX_EXCIT) {
+		mutex_lock(&st->lock);
+		st->fexcit = fexcit;
+	} else {
+		pr_err("ad2s1210: excitation frequency out of range\n");
+		return -EINVAL;
+	}
+	update_frequency_control_word(st);
+	soft_reset(st);
+	mutex_unlock(&st->lock);
+	return len;
+}
+
+static ssize_t ad2s1210_show_control(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	struct iio_dev *idev = dev_get_drvdata(dev);
+	struct ad2s1210_state *st = idev->dev_data;
+	unsigned char data;
+	mutex_lock(&st->lock);
+	config_read(st, REG_CONTROL, &data);
+	mutex_unlock(&st->lock);
+	return sprintf(buf, "0x%x\n", data);
+}
+
+static ssize_t ad2s1210_store_control(struct device *dev,
+			struct device_attribute *attr,
+			const char *buf, size_t len)
+{
+	struct iio_dev *idev = dev_get_drvdata(dev);
+	struct ad2s1210_state *st = idev->dev_data;
+	unsigned long udata;
+	unsigned char data;
+	int ret;
+
+	ret = strict_strtoul(buf, 16, &udata);
+	if (ret) {
+		ret = -EINVAL;
+		goto error_ret;
+	}
+	mutex_lock(&st->lock);
+	config_write(st, REG_CONTROL);
+	data = udata & MSB_IS_LOW;
+	config_write(st, data);
+	config_read(st, REG_CONTROL, &data);
+	if (data & MSB_IS_HIGH) {
+		ret = -EIO;
+		pr_err("ad2s1210: write control register fail\n");
+		goto error_ret;
+	}
+	st->resolution = resolution_value[data & SET_RESOLUTION];
+#if defined(CONFIG_AD2S1210_GPIO_INPUT)
+	data = read_resolution_pin(st);
+	if (data != st->resolution)
+		pr_warning("ad2s1210: resolution settings not match\n");
+#elif defined(CONFIG_AD2S1210_GPIO_OUTPUT)
+	set_resolution_pin(st);
+#endif
+	ret = len;
+	if (data & ENABLE_HYSTERESIS)
+		st->hysteresis = 1;
+	else
+		st->hysteresis = 0;
+error_ret:
+	mutex_unlock(&st->lock);
+	return ret;
+}
+
+static ssize_t ad2s1210_show_resolution(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	struct iio_dev *idev = dev_get_drvdata(dev);
+	struct ad2s1210_state *st = idev->dev_data;
+	return sprintf(buf, "%d\n", st->resolution);
+}
+
+static ssize_t ad2s1210_store_resolution(struct device *dev,
+			struct device_attribute *attr,
+			const char *buf, size_t len)
+{
+	struct iio_dev *idev = dev_get_drvdata(dev);
+	struct ad2s1210_state *st = idev->dev_data;
+	unsigned char data;
+	unsigned long udata;
+	int ret;
+
+	ret = strict_strtoul(buf, 10, &udata);
+	if (ret || udata < RES_10 || udata > RES_16) {
+		pr_err("ad2s1210: resolution out of range\n");
+		return -EINVAL;
+	}
+	mutex_lock(&st->lock);
+	config_read(st, REG_CONTROL, &data);
+	data &= ~SET_RESOLUTION;
+	data |= (udata - RES_10) >> 1;
+	config_write(st, REG_CONTROL);
+	config_write(st, data & MSB_IS_LOW);
+	config_read(st, REG_CONTROL, &data);
+	if (data & MSB_IS_HIGH) {
+		ret = -EIO;
+		pr_err("ad2s1210: setting resolution fail\n");
+		goto error_ret;
+	}
+	st->resolution = resolution_value[data & SET_RESOLUTION];
+#if defined(CONFIG_AD2S1210_GPIO_INPUT)
+	data = read_resolution_pin(st);
+	if (data != st->resolution)
+		pr_warning("ad2s1210: resolution settings not match\n");
+#elif defined(CONFIG_AD2S1210_GPIO_OUTPUT)
+	set_resolution_pin(st);
+#endif
+	ret = len;
+error_ret:
+	mutex_unlock(&st->lock);
+	return ret;
+}
+/* read the fault register since last sample */
+static ssize_t ad2s1210_show_fault(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	int ret = 0;
+	ssize_t len = 0;
+	unsigned char data;
+	struct iio_dev *idev = dev_get_drvdata(dev);
+	struct ad2s1210_state *st = idev->dev_data;
+
+	mutex_lock(&st->lock);
+	ret = config_read(st, REG_FAULT, &data);
+
+	if (ret)
+		goto error_ret;
+	len = sprintf(buf, "0x%x\n", data);
+error_ret:
+	mutex_unlock(&st->lock);
+	return ret ? ret : len;
+}
+
+static ssize_t ad2s1210_clear_fault(struct device *dev,
+			struct device_attribute *attr,
+			const char *buf, size_t len)
+{
+	struct iio_dev *idev = dev_get_drvdata(dev);
+	struct ad2s1210_state *st = idev->dev_data;
+	unsigned char data;
+
+	mutex_lock(&st->lock);
+	start_sample(st);
+	/* delay (2 * tck + 20) nano seconds */
+	udelay(1);
+	stop_sample(st);
+	config_read(st, REG_FAULT, &data);
+	start_sample(st);
+	stop_sample(st);
+	mutex_unlock(&st->lock);
+
+	return 0;
+}
+
+static ssize_t ad2s1210_show_reg(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	struct iio_dev *idev = dev_get_drvdata(dev);
+	struct ad2s1210_state *st = idev->dev_data;
+	unsigned char data;
+	struct iio_dev_attr *iattr = to_iio_dev_attr(attr);
+
+	mutex_lock(&st->lock);
+	config_read(st, iattr->address, &data);
+	mutex_unlock(&st->lock);
+	return sprintf(buf, "%d\n", data);
+}
+
+static ssize_t ad2s1210_store_reg(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t len)
+{
+	struct iio_dev *idev = dev_get_drvdata(dev);
+	struct ad2s1210_state *st = idev->dev_data;
+	unsigned long data;
+	int ret;
+	struct iio_dev_attr *iattr = to_iio_dev_attr(attr);
+
+	ret = strict_strtoul(buf, 10, &data);
+	if (ret)
+		return -EINVAL;
+	mutex_lock(&st->lock);
+	config_write(st, iattr->address);
+	config_write(st, data & MSB_IS_LOW);
+	mutex_unlock(&st->lock);
+	return len;
+}
+
+static ssize_t ad2s1210_show_pos(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	struct spi_message msg;
+	int ret = 0;
+	ssize_t len = 0;
+	u16 pos;
+	struct iio_dev *idev = dev_get_drvdata(dev);
+	struct ad2s1210_state *st = idev->dev_data;
+
+	st->xfer.len = 2;
+	mutex_lock(&st->lock);
+	start_sample(st);
+	/* delay (6 * tck + 20) nano seconds */
+	udelay(1);
+
+	set_mode(MOD_POS, st);
+
+	spi_message_init(&msg);
+	spi_message_add_tail(&st->xfer, &msg);
+	ret = spi_sync(st->sdev, &msg);
+	if (ret)
+		goto error_ret;
+	pos = ((((u16)(st->rx[0])) << 8) | (st->rx[1]));
+	if (st->hysteresis)
+		pos >>= 16 - st->resolution;
+	len = sprintf(buf, "%d\n", pos);
+error_ret:
+	stop_sample(st);
+	/* delay (2 * tck + 20) nano seconds */
+	udelay(1);
+	mutex_unlock(&st->lock);
+
+	return ret ? ret : len;
+}
+
+static ssize_t ad2s1210_show_vel(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	struct spi_message msg;
+	unsigned short negative;
+	int ret = 0;
+	ssize_t len = 0;
+	s16 vel;
+	struct iio_dev *idev = dev_get_drvdata(dev);
+	struct ad2s1210_state *st = idev->dev_data;
+
+	st->xfer.len = 2;
+	mutex_lock(&st->lock);
+	start_sample(st);
+	/* delay (6 * tck + 20) nano seconds */
+	udelay(1);
+
+	set_mode(MOD_VEL, st);
+
+	spi_message_init(&msg);
+	spi_message_add_tail(&st->xfer, &msg);
+	ret = spi_sync(st->sdev, &msg);
+	if (ret)
+		goto error_ret;
+	negative = st->rx[0] & 0x80;
+	vel = ((((s16)(st->rx[0])) << 8) | (st->rx[1]));
+	vel >>= 16 - st->resolution;
+	if (negative) {
+		negative = (0xffff >> st->resolution) << st->resolution;
+		vel |= negative;
+	}
+	len = sprintf(buf, "%d\n", vel);
+error_ret:
+	stop_sample(st);
+	/* delay (2 * tck + 20) nano seconds */
+	udelay(1);
+	mutex_unlock(&st->lock);
+
+	return ret ? ret : len;
+}
+
+static ssize_t ad2s1210_show_pos_vel(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	struct spi_message msg;
+	unsigned short negative;
+	int ret = 0;
+	ssize_t len = 0;
+	u16 pos;
+	s16 vel;
+	struct iio_dev *idev = dev_get_drvdata(dev);
+	struct ad2s1210_state *st = idev->dev_data;
+
+	st->xfer.len = 2;
+	mutex_lock(&st->lock);
+	start_sample(st);
+	/* delay (6 * tck + 20) nano seconds */
+	udelay(1);
+
+	set_mode(MOD_POS, st);
+
+	spi_message_init(&msg);
+	spi_message_add_tail(&st->xfer, &msg);
+	ret = spi_sync(st->sdev, &msg);
+	if (ret)
+		goto error_ret;
+	pos = ((((u16)(st->rx[0])) << 8) | (st->rx[1]));
+	if (st->hysteresis)
+		pos >>= 16 - st->resolution;
+	len = sprintf(buf, "%d ", pos);
+
+	st->xfer.len = 2;
+	set_mode(MOD_VEL, st);
+	spi_message_init(&msg);
+	spi_message_add_tail(&st->xfer, &msg);
+	ret = spi_sync(st->sdev, &msg);
+	if (ret)
+		goto error_ret;
+	negative = st->rx[0] & 0x80;
+	vel = ((((s16)(st->rx[0])) << 8) | (st->rx[1]));
+	vel >>= 16 - st->resolution;
+	if (negative) {
+		negative = (0xffff >> st->resolution) << st->resolution;
+		vel |= negative;
+	}
+	len += sprintf(buf + len, "%d\n", vel);
+error_ret:
+	stop_sample(st);
+	/* delay (2 * tck + 20) nano seconds */
+	udelay(1);
+	mutex_unlock(&st->lock);
+
+	return ret ? ret : len;
+}
+
+static IIO_CONST_ATTR(description,
+	"Variable Resolution, 10-Bit to 16Bit R/D\n\
+Converter with Reference Oscillator");
+static IIO_DEVICE_ATTR(raw_io, S_IRUGO | S_IWUGO,
+		ad2s1210_show_raw, ad2s1210_store_raw, 0);
+static IIO_DEVICE_ATTR(reset, S_IWUGO,
+		NULL, ad2s1210_store_softreset, 0);
+static IIO_DEVICE_ATTR(fclkin, S_IRUGO | S_IWUGO,
+		ad2s1210_show_fclkin, ad2s1210_store_fclkin, 0);
+static IIO_DEVICE_ATTR(fexcit, S_IRUGO | S_IWUGO,
+		ad2s1210_show_fexcit,	ad2s1210_store_fexcit, 0);
+static IIO_DEVICE_ATTR(control, S_IRUGO | S_IWUGO,
+		ad2s1210_show_control, ad2s1210_store_control, 0);
+static IIO_DEVICE_ATTR(bits, S_IRUGO | S_IWUGO,
+		ad2s1210_show_resolution, ad2s1210_store_resolution, 0);
+static IIO_DEVICE_ATTR(fault, S_IRUGO | S_IWUGO,
+		ad2s1210_show_fault, ad2s1210_clear_fault, 0);
+static IIO_DEVICE_ATTR(pos, S_IRUGO,
+		ad2s1210_show_pos, NULL, 0);
+static IIO_DEVICE_ATTR(vel, S_IRUGO,
+		ad2s1210_show_vel, NULL, 0);
+static IIO_DEVICE_ATTR(pos_vel, S_IRUGO,
+		ad2s1210_show_pos_vel, NULL, 0);
+static IIO_DEVICE_ATTR(los_thrd, S_IRUGO | S_IWUGO,
+		ad2s1210_show_reg, ad2s1210_store_reg, REG_LOS_THRD);
+static IIO_DEVICE_ATTR(dos_ovr_thrd, S_IRUGO | S_IWUGO,
+		ad2s1210_show_reg, ad2s1210_store_reg, REG_DOS_OVR_THRD);
+static IIO_DEVICE_ATTR(dos_mis_thrd, S_IRUGO | S_IWUGO,
+		ad2s1210_show_reg, ad2s1210_store_reg, REG_DOS_MIS_THRD);
+static IIO_DEVICE_ATTR(dos_rst_max_thrd, S_IRUGO | S_IWUGO,
+		ad2s1210_show_reg, ad2s1210_store_reg, REG_DOS_RST_MAX_THRD);
+static IIO_DEVICE_ATTR(dos_rst_min_thrd, S_IRUGO | S_IWUGO,
+		ad2s1210_show_reg, ad2s1210_store_reg, REG_DOS_RST_MIN_THRD);
+static IIO_DEVICE_ATTR(lot_high_thrd, S_IRUGO | S_IWUGO,
+		ad2s1210_show_reg, ad2s1210_store_reg, REG_LOT_HIGH_THRD);
+static IIO_DEVICE_ATTR(lot_low_thrd, S_IRUGO | S_IWUGO,
+		ad2s1210_show_reg, ad2s1210_store_reg, REG_LOT_LOW_THRD);
+
+static struct attribute *ad2s1210_attributes[] = {
+	&iio_const_attr_description.dev_attr.attr,
+	&iio_dev_attr_raw_io.dev_attr.attr,
+	&iio_dev_attr_reset.dev_attr.attr,
+	&iio_dev_attr_fclkin.dev_attr.attr,
+	&iio_dev_attr_fexcit.dev_attr.attr,
+	&iio_dev_attr_control.dev_attr.attr,
+	&iio_dev_attr_bits.dev_attr.attr,
+	&iio_dev_attr_fault.dev_attr.attr,
+	&iio_dev_attr_pos.dev_attr.attr,
+	&iio_dev_attr_vel.dev_attr.attr,
+	&iio_dev_attr_pos_vel.dev_attr.attr,
+	&iio_dev_attr_los_thrd.dev_attr.attr,
+	&iio_dev_attr_dos_ovr_thrd.dev_attr.attr,
+	&iio_dev_attr_dos_mis_thrd.dev_attr.attr,
+	&iio_dev_attr_dos_rst_max_thrd.dev_attr.attr,
+	&iio_dev_attr_dos_rst_min_thrd.dev_attr.attr,
+	&iio_dev_attr_lot_high_thrd.dev_attr.attr,
+	&iio_dev_attr_lot_low_thrd.dev_attr.attr,
+	NULL,
+};
+
+static const struct attribute_group ad2s1210_attribute_group = {
+	.name = DRV_NAME,
+	.attrs = ad2s1210_attributes,
+};
+
+static int __devinit ad2s1210_initial(struct ad2s1210_state *st)
+{
+	unsigned char data;
+	int ret;
+
+	mutex_lock(&st->lock);
+#if defined(CONFIG_AD2S1210_GPIO_INPUT)
+	st->resolution = read_resolution_pin(st);
+#elif defined(CONFIG_AD2S1210_GPIO_OUTPUT)
+	set_resolution_pin(st);
+#endif
+
+	config_write(st, REG_CONTROL);
+	data = DEF_CONTROL & ~(SET_RESOLUTION);
+	data |= (st->resolution - RES_10) >> 1;
+	config_write(st, data);
+	ret = config_read(st, REG_CONTROL, &data);
+	if (ret)
+		goto error_ret;
+
+	if (data & MSB_IS_HIGH) {
+		ret = -EIO;
+		goto error_ret;
+	}
+
+	update_frequency_control_word(st);
+	soft_reset(st);
+error_ret:
+	mutex_unlock(&st->lock);
+	return ret;
+}
+
+static int __devinit ad2s1210_probe(struct spi_device *spi)
+{
+	struct ad2s1210_state *st;
+	int pn, ret = 0;
+	unsigned short *pins = spi->dev.platform_data;
+
+	for (pn = 0; pn < AD2S1210_PN; pn++) {
+		if (gpio_request(pins[pn], DRV_NAME)) {
+			pr_err("%s: request gpio pin %d failed\n",
+						DRV_NAME, pins[pn]);
+			goto error_ret;
+		}
+		if (pn < AD2S1210_SAA)
+			gpio_direction_output(pins[pn], 1);
+		else {
+#if defined(CONFIG_AD2S1210_GPIO_INPUT)
+			gpio_direction_input(pins[pn]);
+#elif defined(CONFIG_AD2S1210_GPIO_OUTPUT)
+			gpio_direction_output(pins[pn], 1);
+#endif
+		}
+	}
+
+	st = kzalloc(sizeof(*st), GFP_KERNEL);
+	if (st == NULL) {
+		ret = -ENOMEM;
+		goto error_ret;
+	}
+	spi_set_drvdata(spi, st);
+
+	mutex_init(&st->lock);
+	st->sdev = spi;
+	st->xfer.tx_buf = st->tx;
+	st->xfer.rx_buf = st->rx;
+	st->hysteresis = 1;
+	st->mode = MOD_CONFIG;
+	st->resolution = RES_12;
+	st->fclkin = AD2S1210_DEF_CLKIN;
+	st->fexcit = AD2S1210_DEF_EXCIT;
+	st->sample = pins[0];
+	st->a0 = pins[1];
+	st->a1 = pins[2];
+	st->res0 = pins[3];
+	st->res1 = pins[4];
+
+	st->idev = iio_allocate_device();
+	if (st->idev == NULL) {
+		ret = -ENOMEM;
+		goto error_free_st;
+	}
+	st->idev->dev.parent = &spi->dev;
+	st->idev->num_interrupt_lines = 0;
+	st->idev->event_attrs = NULL;
+
+	st->idev->attrs = &ad2s1210_attribute_group;
+	st->idev->dev_data = (void *)(st);
+	st->idev->driver_module = THIS_MODULE;
+	st->idev->modes = INDIO_DIRECT_MODE;
+
+	ret = iio_device_register(st->idev);
+	if (ret)
+		goto error_free_dev;
+
+	if (spi->max_speed_hz != AD2S1210_DEF_CLKIN)
+		st->fclkin = spi->max_speed_hz;
+	spi->mode = SPI_MODE_3;
+	spi_setup(spi);
+
+	ad2s1210_initial(st);
+	return 0;
+
+error_free_dev:
+	iio_free_device(st->idev);
+error_free_st:
+	kfree(st);
+error_ret:
+	for (--pn; pn >= 0; pn--)
+		gpio_free(pins[pn]);
+	return ret;
+}
+
+static int __devexit ad2s1210_remove(struct spi_device *spi)
+{
+	struct ad2s1210_state *st = spi_get_drvdata(spi);
+
+	iio_device_unregister(st->idev);
+	kfree(st);
+
+	return 0;
+}
+
+static struct spi_driver ad2s1210_driver = {
+	.driver = {
+		.name = DRV_NAME,
+		.owner = THIS_MODULE,
+	},
+	.probe = ad2s1210_probe,
+	.remove = __devexit_p(ad2s1210_remove),
+};
+
+static __init int ad2s1210_spi_init(void)
+{
+	return spi_register_driver(&ad2s1210_driver);
+}
+module_init(ad2s1210_spi_init);
+
+static __exit void ad2s1210_spi_exit(void)
+{
+	spi_unregister_driver(&ad2s1210_driver);
+}
+module_exit(ad2s1210_spi_exit);
+
+MODULE_AUTHOR("Graff Yang <graff.yang@gmail.com>");
+MODULE_DESCRIPTION("Analog Devices AD2S1210 Resolver to Digital SPI driver");
+MODULE_LICENSE("GPL v2");
