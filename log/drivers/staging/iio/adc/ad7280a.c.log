commit 4ce28818941fa0058c345310c9768b09d6ae06d8
Author: Deepak R Varma <mh12gx2825@gmail.com>
Date:   Mon Mar 23 01:27:26 2020 +0530

    staging: iio: adc: ad7280a: Add comments to clarify stringified arguments
    
    Checkpatch would flash a check message around a stringified macro
    argument containing a '-' character. Add comment to indicate the
    argument is legitimate and doesn't need fixing.
    
    Signed-off-by: Deepak R Varma <mh12gx2825@gmail.com>
    Suggested-by: Lars-Peter Clausen <lars@metafoo.de>
    Link: https://lore.kernel.org/r/469bf8db1c228913e72841367182fba2168fe795.1584904896.git.mh12gx2825@gmail.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/iio/adc/ad7280a.c b/drivers/staging/iio/adc/ad7280a.c
index 19a5f244dcae..bef6bd1295ea 100644
--- a/drivers/staging/iio/adc/ad7280a.c
+++ b/drivers/staging/iio/adc/ad7280a.c
@@ -824,6 +824,10 @@ static irqreturn_t ad7280_event_handler(int irq, void *private)
 	return IRQ_HANDLED;
 }
 
+/* Note: No need to fix checkpatch warning that reads:
+ *	CHECK: spaces preferred around that '-' (ctx:VxV)
+ * The function argument is stringified and doesn't need a fix
+ */
 static IIO_DEVICE_ATTR_NAMED(in_thresh_low_value,
 			     in_voltage-voltage_thresh_low_value,
 			     0644,

commit 932f98922f6fca9f8c45274346b49058dd50d51a
Merge: 44b8ef17c435 df1d80aee963
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Thu Apr 4 22:25:29 2019 +0200

    Merge tag 'iio-for-5.2a-2' of git://git.kernel.org/pub/scm/linux/kernel/git/jic23/iio into staging-next
    
    Jonathan writes:
    
    First set of new device support, features and fixes for IIO in the 5.2 cycle
    
    Staging graduations
    * ad7780
      - Move this ADC driver out of staging.  Included adding some new features
        along the way (see below). Also added DT bindings.
    
    New device support
    * adis16480
      - Support the ADIS16495 and ADIS16497 IMU devices making
        heavy use of refactoring of various aspects of the driver in precursor
        patches.
    * lsm6dsx
      - Support for the ASM330LHH 6-axis (accelerometer + gyro) sensor.
      - Support for the LSM6DS0X
    * matbotix mb1232
      - New driver for this ultrasound ranging device family. Including bindings.
      - Supports mb1202, mb1212, mb1222, mb1232, mb1242, mb7040 and mb7137.
    * max31856
      - New driver for this thermocouple temperature sensor.
    * meson saradc
      - Support the Meson-G12A (ID addition only).
    * stmpe-adc
      - New driver supporting generic ADC alongside touchscreen support which
        previously existed. Includes DT bindings.
    * vcnl4000
      - Support for the vcln4040 proximity and light sensor, including adding
        DT bindings for this and parts previously supported.
    
    Features
    * core
      - Allow reading of mount matrices from ACPI in addition to DT.
      - Common binding for theromcouple types.
    * ad5933
      - Add ABI docs as there are a few 'unsual' elements about this
        device - perhaps because it's our only impedance analyser.
    * ad7780
      - Add gain and filter gpio support + readback of current gain and filter.
    * adis16480
      - Allow selection fo the dataready pin to be used.
      - Device tree ID table and binding documentation.
      - Support external clock modes, including new bindings.
    * bma180
      - Mount matrix support.
    * bmc150
      - Mount matrix support.
    * bmg160
      - Mount matrix support.
      - DT id table and bindings doc.
    * bmp280
      - Put calibration data into the entropy pool.
    * hmc5843
      - Mount matrix support.
    * itg3200
      - Mount matrix support.
    * kxcjk1013
      - Device tree id table, and binding docs.
    * lpc32xx
      - Add scale when regulator specified including DT docs for regulator.
    * pms7003
      - Add device IDs for all supported parts to driver and binding.
    * stm32-dfsdm
      - Enable hw consumer support, scan mode control and a complex set of
        triggered buffer modes.
      - Power management.
    * stm32-lptimer-counter
      - power management.
      - Document the pinctrl sleep state binding.
    * ti-ads7950
      - GPIO pin support.
    
    Cleanups, minor fixes
    * core
      - Use bitmap_zalloc to make it explicit that is what we are doing.
      - Tidy up all the Kconfig files (which had slowly gotten messy)
      - Fix a forwards definition missing issue in iio/driver.h
    * ad sigma delta core
      - Improve handling of SPI bus locking vs CS assertion.  This has been
        wrong a long time so not rushing this in.
    * ad5064
      - Mlock to local lock.
    * ad5933 (staging cleanup)
      - Multiline comment fixes.
      - Include ordering.
      - SPDX.
      - Tidy up Kconfig help which was a bit missleading.
      - Change some non standard attributes to ABI defined ones.
    * ad7124
      - White space fix.
    * ad7192
      - White space.
      - Use DT clock binding.
      - Improve error reporting.
      - Platform data to DT conversion.
      - Use read_avail callback, mostly to avoid the endless series of
        patches from new contributors trying to falsely put spaces around
        the negative sign.
    * ad7280a
      - Add brackets to macros to avoid potential precedence isseus.
      - Add temp vars for event codes to reduce indent and improved readability.
      - Clean out som CamelCase notation.
      - White space.
    * ad7606
      - Fix broken file naming in MAINTAINERS.
    * ad7780
      - Missing switch defaults to supress warnings and harden the code slightly.
      - Set pattern masks more directly.
      - Add ID values and masks for all supported chips.
      - SPDX + add Renato as a copyright holder as he has done a lot of work on
        this driver.
      - Add brackets to macros to avoid potential precedence issues.
    * ad7923
      - White space fixes.
      - Use BIT macro to improve readability.
      - Add brackets to macros to avoid potential precedence issues.
      - Tidy up a null comparisom.
    * ad9523
      - Fix a typo in naming of variables.
    * adis16400
      - Combine trigger file into main code as no advantage in separate files.
        Rename core file to just adis16400.
      - Squash the header into the c file now there is only one file.
      - Generalize burst mode to support new variants.
    * ak8975
      - Local variable to improve readability around mount matrix support.
    * as3935
      - Avoid potential race by ensuring remove does exact opposite of
        probe rather than a slightly different order.
    * cross_ec
      - Drop some unnecessary includes.
      - Fix some warning and the slightly 'unusual' code.
      - Add some docs for non obvious function.
      - SPDX
    * hmc5843
      - Potential unhandled error case.
    * iio trigger core
      - Print an error if there is no available irq due to max consumers per
        trigger being set to low.
    * iio loop trigger
      - Drop an unlikely on IS_ERR as IS_ERR already has the annotation.
    * ingenic-adc
      - Drop a redundant dev_err call as devm_ioremap_resource reports the same
        internally.
    * lmp91000
      - Drop some unncessary parentheses and white space tidy up.
      - Invert and if statement to improve readability.
      - Fix a wrong error message.
    * lpc32xx
      - Header sorting + drop some unused ones.
    * mma8542
      - Mark a switch fallthrough.
    * mpu6050
      - Add a local variable to improve code readability around mount matrix
        support.
    * mxs-lradc-adc
      - Handle devm_iio_trigger_alloc failure.
    * sps30
      - Fix up a kernel version in the ABI docs.
    * srf04
      - DT binding doc converted to yaml.
    * ssp_sensors
      - Supress a clang build warning due to lack of visibility of conditional
        within a iio_push_to_buffers_with_timestamp.  (reasonable false warning!)
    * st_accel
      - Drop pointless less than 0 comparisom of unsigned int.
    * stm32-dfsdm
      - Improve accuracy of spi_master_frequency calculation.
      - Improve calculation fo sampling frequency.
      - Rework various internals to simplify adding triggered buffer support.
      - Claim direct mode to avoid racing around read_raw and being in buffered
        mode.
    * stmpe
      - Fix a clang false positive warning.
    * ti-ads7950
      - Use local lock rather than using the core mlock when not locking around
        the device mode.
    * vcnl4000
      - Use word writes instead of byte writes.  It seems byte writes are fine
        for some parts (undocument) but not others that the driver will shortly
        support.
    
    Other
    * mailmap
      - Add email address change for Sean Nyekjaer.  Update in relevant drivers
    
    * tag 'iio-for-5.2a-2' of git://git.kernel.org/pub/scm/linux/kernel/git/jic23/iio: (129 commits)
      iio: ad_sigma_delta: Properly handle SPI bus locking vs CS assertion
      iio: adc: stm32-dfsdm: add PM support
      iio: adc: stm32-dfsdm: improve sampling frequency accuracy
      staging: iio: adc: ad7280a: Tab alignment
      MAINTAINERS: Fix the link to ad7606 dt-bindings
      iio:temperature: Add MAX31856 thermocouple support
      iio:temperature:max31856:Add device tree bind info
      dt-bindings: iio/temperature: Add thermocouple types (and doc)
      devantech-srf04.yaml: transform DT binding to YAML
      iio: frequency: ad9523: Fix typo in ad9523_platform_data
      iio: Make possible to include driver.h first
      dt-bindings: iio: add Bosch BMG160 gyroscope sensor
      iio: gyro: bmg160: add device tree compatibility table
      staging: iio: adc: ad7192: Use read_avail for available attributes
      dt-bindings: iio: light: add vcnl4040 devicetree bindings
      iio: light: vcnl4000 add support for the VCNL4040 proximity and light sensor
      dt-bindings: iio: light: add vcnl4000 devicetree bindings
      iio: light: vcnl4000 add devicetree hooks
      iio: light: vcnl4000 use word writes instead of byte writes
      iio: adc: stm32-dfsdm: claim direct mode for raw read and settings
      ...

commit 65500c53aa6d0a6c4e40fcc7788332af9720ad14
Author: Cristian Sicilia <sicilia.cristian@gmail.com>
Date:   Sun Mar 24 18:23:09 2019 +0100

    staging: iio: adc: ad7280a: Tab alignment
    
    Aligned some parameters.
    
    Signed-off-by: Cristian Sicilia <sicilia.cristian@gmail.com>
    Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>

diff --git a/drivers/staging/iio/adc/ad7280a.c b/drivers/staging/iio/adc/ad7280a.c
index c81a8c9382d5..229dcad537b2 100644
--- a/drivers/staging/iio/adc/ad7280a.c
+++ b/drivers/staging/iio/adc/ad7280a.c
@@ -826,30 +826,30 @@ static irqreturn_t ad7280_event_handler(int irq, void *private)
 }
 
 static IIO_DEVICE_ATTR_NAMED(in_thresh_low_value,
-		in_voltage-voltage_thresh_low_value,
-		0644,
-		ad7280_read_channel_config,
-		ad7280_write_channel_config,
-		AD7280A_CELL_UNDERVOLTAGE);
+			     in_voltage-voltage_thresh_low_value,
+			     0644,
+			     ad7280_read_channel_config,
+			     ad7280_write_channel_config,
+			     AD7280A_CELL_UNDERVOLTAGE);
 
 static IIO_DEVICE_ATTR_NAMED(in_thresh_high_value,
-		in_voltage-voltage_thresh_high_value,
-		0644,
-		ad7280_read_channel_config,
-		ad7280_write_channel_config,
-		AD7280A_CELL_OVERVOLTAGE);
+			     in_voltage-voltage_thresh_high_value,
+			     0644,
+			     ad7280_read_channel_config,
+			     ad7280_write_channel_config,
+			     AD7280A_CELL_OVERVOLTAGE);
 
 static IIO_DEVICE_ATTR(in_temp_thresh_low_value,
-		0644,
-		ad7280_read_channel_config,
-		ad7280_write_channel_config,
-		AD7280A_AUX_ADC_UNDERVOLTAGE);
+		       0644,
+		       ad7280_read_channel_config,
+		       ad7280_write_channel_config,
+		       AD7280A_AUX_ADC_UNDERVOLTAGE);
 
 static IIO_DEVICE_ATTR(in_temp_thresh_high_value,
-		0644,
-		ad7280_read_channel_config,
-		ad7280_write_channel_config,
-		AD7280A_AUX_ADC_OVERVOLTAGE);
+		       0644,
+		       ad7280_read_channel_config,
+		       ad7280_write_channel_config,
+		       AD7280A_AUX_ADC_OVERVOLTAGE);
 
 static struct attribute *ad7280_event_attributes[] = {
 	&iio_dev_attr_in_thresh_low_value.dev_attr.attr,

commit 9bf1468e9d62c144b91ca9684b91dfc84c3f2a4b
Author: Cristian Sicilia <sicilia.cristian@gmail.com>
Date:   Sat Mar 23 20:21:49 2019 +0100

    staging: iio: adc: ad7280a: Remove CamelCase notation
    
    Fix CamelCase naming.
    
    Signed-off-by: Cristian Sicilia <sicilia.cristian@gmail.com>
    Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>

diff --git a/drivers/staging/iio/adc/ad7280a.c b/drivers/staging/iio/adc/ad7280a.c
index bbd239b29667..c81a8c9382d5 100644
--- a/drivers/staging/iio/adc/ad7280a.c
+++ b/drivers/staging/iio/adc/ad7280a.c
@@ -917,8 +917,8 @@ static int ad7280_probe(struct spi_device *spi)
 	const struct ad7280_platform_data *pdata = dev_get_platdata(&spi->dev);
 	struct ad7280_state *st;
 	int ret;
-	const unsigned short tACQ_ns[4] = {465, 1010, 1460, 1890};
-	const unsigned short nAVG[4] = {1, 2, 4, 8};
+	const unsigned short t_acq_ns[4] = {465, 1010, 1460, 1890};
+	const unsigned short n_avg[4] = {1, 2, 4, 8};
 	struct iio_dev *indio_dev;
 
 	indio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*st));
@@ -966,10 +966,9 @@ static int ad7280_probe(struct spi_device *spi)
 	 */
 
 	st->readback_delay_us =
-		((tACQ_ns[pdata->acquisition_time & 0x3] + 695) *
-		(AD7280A_NUM_CH * nAVG[pdata->conversion_averaging & 0x3]))
-		- tACQ_ns[pdata->acquisition_time & 0x3] +
-		st->slave_num * 250;
+		((t_acq_ns[pdata->acquisition_time & 0x3] + 695) *
+		 (AD7280A_NUM_CH * n_avg[pdata->conversion_averaging & 0x3])) -
+		t_acq_ns[pdata->acquisition_time & 0x3] + st->slave_num * 250;
 
 	/* Convert to usecs */
 	st->readback_delay_us = DIV_ROUND_UP(st->readback_delay_us, 1000);

commit 6c249591eef2d318af7a11ee688573d635e616ca
Author: Cristian Sicilia <sicilia.cristian@gmail.com>
Date:   Sat Mar 23 20:21:45 2019 +0100

    staging: iio: adc: ad7280a: Adding temp var to improve readability
    
    Creating a temporary variable to improve readability
    
    Signed-off-by: Cristian Sicilia <sicilia.cristian@gmail.com>
    Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>

diff --git a/drivers/staging/iio/adc/ad7280a.c b/drivers/staging/iio/adc/ad7280a.c
index 4199a4fbcf18..bbd239b29667 100644
--- a/drivers/staging/iio/adc/ad7280a.c
+++ b/drivers/staging/iio/adc/ad7280a.c
@@ -784,43 +784,38 @@ static irqreturn_t ad7280_event_handler(int irq, void *private)
 	for (i = 0; i < st->scan_cnt; i++) {
 		if (((channels[i] >> 23) & 0xF) <= AD7280A_CELL_VOLTAGE_6) {
 			if (((channels[i] >> 11) & 0xFFF) >=
-				st->cell_threshhigh)
-				iio_push_event(indio_dev,
-					       IIO_EVENT_CODE(IIO_VOLTAGE,
-							1,
-							0,
-							IIO_EV_DIR_RISING,
-							IIO_EV_TYPE_THRESH,
-							0, 0, 0),
+			    st->cell_threshhigh) {
+				u64 tmp = IIO_EVENT_CODE(IIO_VOLTAGE, 1, 0,
+							 IIO_EV_DIR_RISING,
+							 IIO_EV_TYPE_THRESH,
+							 0, 0, 0);
+				iio_push_event(indio_dev, tmp,
 					       iio_get_time_ns(indio_dev));
-			else if (((channels[i] >> 11) & 0xFFF) <=
-				st->cell_threshlow)
-				iio_push_event(indio_dev,
-					       IIO_EVENT_CODE(IIO_VOLTAGE,
-							1,
-							0,
-							IIO_EV_DIR_FALLING,
-							IIO_EV_TYPE_THRESH,
-							0, 0, 0),
+			} else if (((channels[i] >> 11) & 0xFFF) <=
+				   st->cell_threshlow) {
+				u64 tmp = IIO_EVENT_CODE(IIO_VOLTAGE, 1, 0,
+							 IIO_EV_DIR_FALLING,
+							 IIO_EV_TYPE_THRESH,
+							 0, 0, 0);
+				iio_push_event(indio_dev, tmp,
 					       iio_get_time_ns(indio_dev));
+			}
 		} else {
-			if (((channels[i] >> 11) & 0xFFF) >= st->aux_threshhigh)
-				iio_push_event(indio_dev,
-					       IIO_UNMOD_EVENT_CODE(
-							IIO_TEMP,
-							0,
+			if (((channels[i] >> 11) & 0xFFF) >=
+			    st->aux_threshhigh) {
+				u64 tmp = IIO_UNMOD_EVENT_CODE(IIO_TEMP, 0,
 							IIO_EV_TYPE_THRESH,
-							IIO_EV_DIR_RISING),
+							IIO_EV_DIR_RISING);
+				iio_push_event(indio_dev, tmp,
 					       iio_get_time_ns(indio_dev));
-			else if (((channels[i] >> 11) & 0xFFF) <=
-				st->aux_threshlow)
-				iio_push_event(indio_dev,
-					       IIO_UNMOD_EVENT_CODE(
-							IIO_TEMP,
-							0,
+			} else if (((channels[i] >> 11) & 0xFFF) <=
+				st->aux_threshlow) {
+				u64 tmp = IIO_UNMOD_EVENT_CODE(IIO_TEMP, 0,
 							IIO_EV_TYPE_THRESH,
-							IIO_EV_DIR_FALLING),
+							IIO_EV_DIR_FALLING);
+				iio_push_event(indio_dev, tmp,
 					       iio_get_time_ns(indio_dev));
+			}
 		}
 	}
 

commit d04411c2a67892360a018c38168e4d17fa1896cf
Author: Cristian Sicilia <sicilia.cristian@gmail.com>
Date:   Sat Mar 23 20:21:42 2019 +0100

    staging: iio: adc: ad7280a: Avoid precedence issues in macro
    
    Enclosing parameter with parenthesis due to avoid
    possible precedence issue.
    
    Signed-off-by: Cristian Sicilia <sicilia.cristian@gmail.com>
    Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>

diff --git a/drivers/staging/iio/adc/ad7280a.c b/drivers/staging/iio/adc/ad7280a.c
index d9df12665176..4199a4fbcf18 100644
--- a/drivers/staging/iio/adc/ad7280a.c
+++ b/drivers/staging/iio/adc/ad7280a.c
@@ -97,9 +97,10 @@
 #define AD7280A_NUM_CH			(AD7280A_AUX_ADC_6 - \
 					AD7280A_CELL_VOLTAGE_1 + 1)
 
-#define AD7280A_CALC_VOLTAGE_CHAN_NUM(d, c) ((d * AD7280A_CELLS_PER_DEV) + c)
-#define AD7280A_CALC_TEMP_CHAN_NUM(d, c)    ((d * AD7280A_CELLS_PER_DEV) + \
-					     c - AD7280A_CELLS_PER_DEV)
+#define AD7280A_CALC_VOLTAGE_CHAN_NUM(d, c) (((d) * AD7280A_CELLS_PER_DEV) + \
+					     (c))
+#define AD7280A_CALC_TEMP_CHAN_NUM(d, c)    (((d) * AD7280A_CELLS_PER_DEV) + \
+					     (c) - AD7280A_CELLS_PER_DEV)
 
 #define AD7280A_DEVADDR_MASTER		0
 #define AD7280A_DEVADDR_ALL		0x1F

commit 2506abea7f40ea9d7633828941f25d5c2dab4925
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Apr 2 12:31:55 2019 +0200

    staging: iio: add proper SPDX identifiers to remaining driver files
    
    There are a number of IIO staging drivers that do not have a proper SPDX
    identifier on it.  So fix that up and at the same time, remove the "free
    form" license text, as that's pretty much impossible for any tool to
    parse.
    
    Cc: Lars-Peter Clausen <lars@metafoo.de>
    Cc: Michael Hennerich <Michael.Hennerich@analog.com>
    Cc: Jonathan Cameron <jic23@kernel.org>
    Cc: Hartmut Knaack <knaack.h@gmx.de>
    Cc: Peter Meerwald-Stadler <pmeerw@pmeerw.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/iio/adc/ad7280a.c b/drivers/staging/iio/adc/ad7280a.c
index d9df12665176..47cfe920b2ae 100644
--- a/drivers/staging/iio/adc/ad7280a.c
+++ b/drivers/staging/iio/adc/ad7280a.c
@@ -1,9 +1,8 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * AD7280A Lithium Ion Battery Monitoring System
  *
  * Copyright 2011 Analog Devices Inc.
- *
- * Licensed under the GPL-2.
  */
 
 #include <linux/crc8.h>

commit 4b6374577fe751f60ffc24c7b95ce803a22b2476
Author: Slawomir Stepien <sst@poczta.fm>
Date:   Wed Dec 12 18:02:28 2018 +0100

    staging: iio: adc: ad7280a: split ad7280_attr_init() to more functions
    
    The ad7280_attr_init function has been split into more specific
    functions to increase the code readability.
    
    Signed-off-by: Slawomir Stepien <sst@poczta.fm>
    Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>

diff --git a/drivers/staging/iio/adc/ad7280a.c b/drivers/staging/iio/adc/ad7280a.c
index 8439a4e23228..d9df12665176 100644
--- a/drivers/staging/iio/adc/ad7280a.c
+++ b/drivers/staging/iio/adc/ad7280a.c
@@ -596,11 +596,75 @@ static int ad7280_channel_init(struct ad7280_state *st)
 	return cnt + 1;
 }
 
-static int ad7280_attr_init(struct ad7280_state *st)
+static int ad7280_balance_switch_attr_init(struct iio_dev_attr *attr,
+					   struct device *dev, int addr, int i)
+{
+	attr->address = addr;
+	attr->dev_attr.attr.mode = 0644;
+	attr->dev_attr.show = ad7280_show_balance_sw;
+	attr->dev_attr.store = ad7280_store_balance_sw;
+	attr->dev_attr.attr.name = devm_kasprintf(dev, GFP_KERNEL,
+						  "in%d-in%d_balance_switch_en",
+						  i, i + 1);
+	if (!attr->dev_attr.attr.name)
+		return -ENOMEM;
+
+	return 0;
+}
+
+static int ad7280_balance_timer_attr_init(struct iio_dev_attr *attr,
+					  struct device *dev, int addr, int i)
+{
+	attr->address = addr;
+	attr->dev_attr.attr.mode = 0644;
+	attr->dev_attr.show = ad7280_show_balance_timer;
+	attr->dev_attr.store = ad7280_store_balance_timer;
+	attr->dev_attr.attr.name = devm_kasprintf(dev, GFP_KERNEL,
+						  "in%d-in%d_balance_timer",
+						  i, i + 1);
+	if (!attr->dev_attr.attr.name)
+		return -ENOMEM;
+
+	return 0;
+}
+
+static int ad7280_init_dev_attrs(struct ad7280_state *st, int dev, int *cnt)
 {
-	int dev, ch, cnt;
-	unsigned int index;
+	int addr, ch, i, ret;
 	struct iio_dev_attr *iio_attr;
+	struct device *sdev = &st->spi->dev;
+
+	for (ch = AD7280A_CELL_VOLTAGE_1; ch <= AD7280A_CELL_VOLTAGE_6; ch++) {
+		iio_attr = &st->iio_attr[*cnt];
+		addr = ad7280a_devaddr(dev) << 8 | ch;
+		i = dev * AD7280A_CELLS_PER_DEV + ch;
+
+		ret = ad7280_balance_switch_attr_init(iio_attr, sdev, addr, i);
+		if (ret < 0)
+			return ret;
+
+		ad7280_attributes[*cnt] = &iio_attr->dev_attr.attr;
+
+		(*cnt)++;
+		iio_attr = &st->iio_attr[*cnt];
+		addr = ad7280a_devaddr(dev) << 8 | (AD7280A_CB1_TIMER + ch);
+
+		ret = ad7280_balance_timer_attr_init(iio_attr, sdev, addr, i);
+		if (ret < 0)
+			return ret;
+
+		ad7280_attributes[*cnt] = &iio_attr->dev_attr.attr;
+		(*cnt)++;
+	}
+
+	ad7280_attributes[*cnt] = NULL;
+
+	return 0;
+}
+
+static int ad7280_attr_init(struct ad7280_state *st)
+{
+	int dev, cnt = 0, ret;
 
 	st->iio_attr = devm_kcalloc(&st->spi->dev, 2, sizeof(*st->iio_attr) *
 				    (st->slave_num + 1) * AD7280A_CELLS_PER_DEV,
@@ -608,41 +672,11 @@ static int ad7280_attr_init(struct ad7280_state *st)
 	if (!st->iio_attr)
 		return -ENOMEM;
 
-	for (dev = 0, cnt = 0; dev <= st->slave_num; dev++)
-		for (ch = AD7280A_CELL_VOLTAGE_1; ch <= AD7280A_CELL_VOLTAGE_6;
-			ch++, cnt++) {
-			iio_attr = &st->iio_attr[cnt];
-			index = dev * AD7280A_CELLS_PER_DEV + ch;
-			iio_attr->address = ad7280a_devaddr(dev) << 8 | ch;
-			iio_attr->dev_attr.attr.mode = 0644;
-			iio_attr->dev_attr.show = ad7280_show_balance_sw;
-			iio_attr->dev_attr.store = ad7280_store_balance_sw;
-			iio_attr->dev_attr.attr.name =
-				devm_kasprintf(&st->spi->dev, GFP_KERNEL,
-					       "in%d-in%d_balance_switch_en",
-					       index, index + 1);
-			if (!iio_attr->dev_attr.attr.name)
-				return -ENOMEM;
-
-			ad7280_attributes[cnt] = &iio_attr->dev_attr.attr;
-			cnt++;
-			iio_attr = &st->iio_attr[cnt];
-			iio_attr->address = ad7280a_devaddr(dev) << 8 |
-				(AD7280A_CB1_TIMER + ch);
-			iio_attr->dev_attr.attr.mode = 0644;
-			iio_attr->dev_attr.show = ad7280_show_balance_timer;
-			iio_attr->dev_attr.store = ad7280_store_balance_timer;
-			iio_attr->dev_attr.attr.name =
-				devm_kasprintf(&st->spi->dev, GFP_KERNEL,
-					       "in%d-in%d_balance_timer",
-					       index, index + 1);
-			if (!iio_attr->dev_attr.attr.name)
-				return -ENOMEM;
-
-			ad7280_attributes[cnt] = &iio_attr->dev_attr.attr;
-		}
-
-	ad7280_attributes[cnt] = NULL;
+	for (dev = 0; dev <= st->slave_num; dev++) {
+		ret = ad7280_init_dev_attrs(st, dev, &cnt);
+		if (ret < 0)
+			return ret;
+	}
 
 	return 0;
 }

commit 243c5c9d7b6250ce5e03cd88e48a40f961251b4e
Author: Slawomir Stepien <sst@poczta.fm>
Date:   Wed Dec 12 18:02:27 2018 +0100

    staging: iio: adc: ad7280a: split ad7280_channel_init() to more functions
    
    The ad7280_channel_init function has been split into more specific
    functions to increase the code readability.
    
    The setting of channel's scan_type.shift to 0, has been removed, since
    it is the default value.
    
    Signed-off-by: Slawomir Stepien <sst@poczta.fm>
    Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>

diff --git a/drivers/staging/iio/adc/ad7280a.c b/drivers/staging/iio/adc/ad7280a.c
index 14f6a3ced060..8439a4e23228 100644
--- a/drivers/staging/iio/adc/ad7280a.c
+++ b/drivers/staging/iio/adc/ad7280a.c
@@ -97,6 +97,10 @@
 #define AD7280A_NUM_CH			(AD7280A_AUX_ADC_6 - \
 					AD7280A_CELL_VOLTAGE_1 + 1)
 
+#define AD7280A_CALC_VOLTAGE_CHAN_NUM(d, c) ((d * AD7280A_CELLS_PER_DEV) + c)
+#define AD7280A_CALC_TEMP_CHAN_NUM(d, c)    ((d * AD7280A_CELLS_PER_DEV) + \
+					     c - AD7280A_CELLS_PER_DEV)
+
 #define AD7280A_DEVADDR_MASTER		0
 #define AD7280A_DEVADDR_ALL		0x1F
 /* 5-bit device address is sent LSB first */
@@ -496,63 +500,98 @@ static const struct attribute_group ad7280_attrs_group = {
 	.attrs = ad7280_attributes,
 };
 
+static void ad7280_voltage_channel_init(struct iio_chan_spec *chan, int i)
+{
+	chan->type = IIO_VOLTAGE;
+	chan->differential = 1;
+	chan->channel = i;
+	chan->channel2 = chan->channel + 1;
+}
+
+static void ad7280_temp_channel_init(struct iio_chan_spec *chan, int i)
+{
+	chan->type = IIO_TEMP;
+	chan->channel = i;
+}
+
+static void ad7280_common_fields_init(struct iio_chan_spec *chan, int addr,
+				      int cnt)
+{
+	chan->indexed = 1;
+	chan->info_mask_separate = BIT(IIO_CHAN_INFO_RAW);
+	chan->info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE);
+	chan->address = addr;
+	chan->scan_index = cnt;
+	chan->scan_type.sign = 'u';
+	chan->scan_type.realbits = 12;
+	chan->scan_type.storagebits = 32;
+}
+
+static void ad7280_total_voltage_channel_init(struct iio_chan_spec *chan,
+					      int cnt, int dev)
+{
+	chan->type = IIO_VOLTAGE;
+	chan->differential = 1;
+	chan->channel = 0;
+	chan->channel2 = dev * AD7280A_CELLS_PER_DEV;
+	chan->address = AD7280A_ALL_CELLS;
+	chan->indexed = 1;
+	chan->info_mask_separate = BIT(IIO_CHAN_INFO_RAW);
+	chan->info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE);
+	chan->scan_index = cnt;
+	chan->scan_type.sign = 'u';
+	chan->scan_type.realbits = 32;
+	chan->scan_type.storagebits = 32;
+}
+
+static void ad7280_timestamp_channel_init(struct iio_chan_spec *chan, int cnt)
+{
+	chan->type = IIO_TIMESTAMP;
+	chan->channel = -1;
+	chan->scan_index = cnt;
+	chan->scan_type.sign = 's';
+	chan->scan_type.realbits = 64;
+	chan->scan_type.storagebits = 64;
+}
+
+static void ad7280_init_dev_channels(struct ad7280_state *st, int dev, int *cnt)
+{
+	int addr, ch, i;
+	struct iio_chan_spec *chan;
+
+	for (ch = AD7280A_CELL_VOLTAGE_1; ch <= AD7280A_AUX_ADC_6; ch++) {
+		chan = &st->channels[*cnt];
+
+		if (ch < AD7280A_AUX_ADC_1) {
+			i = AD7280A_CALC_VOLTAGE_CHAN_NUM(dev, ch);
+			ad7280_voltage_channel_init(chan, i);
+		} else {
+			i = AD7280A_CALC_TEMP_CHAN_NUM(dev, ch);
+			ad7280_temp_channel_init(chan, i);
+		}
+
+		addr = ad7280a_devaddr(dev) << 8 | ch;
+		ad7280_common_fields_init(chan, addr, *cnt);
+
+		(*cnt)++;
+	}
+}
+
 static int ad7280_channel_init(struct ad7280_state *st)
 {
-	int dev, ch, cnt;
+	int dev, cnt = 0;
 
 	st->channels = devm_kcalloc(&st->spi->dev, (st->slave_num + 1) * 12 + 2,
 				    sizeof(*st->channels), GFP_KERNEL);
 	if (!st->channels)
 		return -ENOMEM;
 
-	for (dev = 0, cnt = 0; dev <= st->slave_num; dev++)
-		for (ch = AD7280A_CELL_VOLTAGE_1; ch <= AD7280A_AUX_ADC_6;
-			ch++, cnt++) {
-			if (ch < AD7280A_AUX_ADC_1) {
-				st->channels[cnt].type = IIO_VOLTAGE;
-				st->channels[cnt].differential = 1;
-				st->channels[cnt].channel = (dev * 6) + ch;
-				st->channels[cnt].channel2 =
-					st->channels[cnt].channel + 1;
-			} else {
-				st->channels[cnt].type = IIO_TEMP;
-				st->channels[cnt].channel = (dev * 6) + ch - 6;
-			}
-			st->channels[cnt].indexed = 1;
-			st->channels[cnt].info_mask_separate =
-				BIT(IIO_CHAN_INFO_RAW);
-			st->channels[cnt].info_mask_shared_by_type =
-				BIT(IIO_CHAN_INFO_SCALE);
-			st->channels[cnt].address =
-				ad7280a_devaddr(dev) << 8 | ch;
-			st->channels[cnt].scan_index = cnt;
-			st->channels[cnt].scan_type.sign = 'u';
-			st->channels[cnt].scan_type.realbits = 12;
-			st->channels[cnt].scan_type.storagebits = 32;
-			st->channels[cnt].scan_type.shift = 0;
-		}
+	for (dev = 0; dev <= st->slave_num; dev++)
+		ad7280_init_dev_channels(st, dev, &cnt);
 
-	st->channels[cnt].type = IIO_VOLTAGE;
-	st->channels[cnt].differential = 1;
-	st->channels[cnt].channel = 0;
-	st->channels[cnt].channel2 = dev * 6;
-	st->channels[cnt].address = AD7280A_ALL_CELLS;
-	st->channels[cnt].indexed = 1;
-	st->channels[cnt].info_mask_separate = BIT(IIO_CHAN_INFO_RAW);
-	st->channels[cnt].info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE);
-	st->channels[cnt].scan_index = cnt;
-	st->channels[cnt].scan_type.sign = 'u';
-	st->channels[cnt].scan_type.realbits = 32;
-	st->channels[cnt].scan_type.storagebits = 32;
-	st->channels[cnt].scan_type.shift = 0;
+	ad7280_total_voltage_channel_init(&st->channels[cnt], cnt, dev);
 	cnt++;
-	st->channels[cnt].type = IIO_TIMESTAMP;
-	st->channels[cnt].channel = -1;
-	st->channels[cnt].scan_index = cnt;
-	st->channels[cnt].scan_type.sign = 's';
-	st->channels[cnt].scan_type.realbits = 64;
-	st->channels[cnt].scan_type.storagebits = 64;
-	st->channels[cnt].scan_type.shift = 0;
+	ad7280_timestamp_channel_init(&st->channels[cnt], cnt);
 
 	return cnt + 1;
 }

commit 794e20ee038ea368f3f099d196792b024fb3170c
Author: Slawomir Stepien <sst@poczta.fm>
Date:   Sun Dec 2 12:42:35 2018 +0100

    staging: iio: adc: ad7280a: fix overwrite of the returned value
    
    The ret returned from ad7280_chain_setup() is needed to initialize the
    slave_num. Don't overwrite it with call to devm_add_action_or_reset().
    
    Fixes: cc9c58ef6e06 ("staging: iio: adc: ad7280a: use devm_* APIs")
    Signed-off-by: Slawomir Stepien <sst@poczta.fm>
    Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>

diff --git a/drivers/staging/iio/adc/ad7280a.c b/drivers/staging/iio/adc/ad7280a.c
index 7a0ba26f9fd9..14f6a3ced060 100644
--- a/drivers/staging/iio/adc/ad7280a.c
+++ b/drivers/staging/iio/adc/ad7280a.c
@@ -879,15 +879,15 @@ static int ad7280_probe(struct spi_device *spi)
 	if (ret < 0)
 		return ret;
 
-	ret = devm_add_action_or_reset(&spi->dev, ad7280_sw_power_down, st);
-	if (ret)
-		return ret;
-
 	st->slave_num = ret;
 	st->scan_cnt = (st->slave_num + 1) * AD7280A_NUM_CH;
 	st->cell_threshhigh = 0xFF;
 	st->aux_threshhigh = 0xFF;
 
+	ret = devm_add_action_or_reset(&spi->dev, ad7280_sw_power_down, st);
+	if (ret)
+		return ret;
+
 	/*
 	 * Total Conversion Time = ((tACQ + tCONV) *
 	 *			   (Number of Conversions per Part)) âˆ’

commit 53e8785c248df097364b75e550d06bbc58db8af8
Author: Nicholas Mc Guire <hofrat@osadl.org>
Date:   Tue Nov 27 18:05:04 2018 +0100

    staging: iio: adc: ad7280a: check for devm_kasprint() failure
    
    devm_kasprintf() may return NULL on failure of internal allocation thus
    the assignments to  attr.name  are not safe if not checked. On error
    ad7280_attr_init() returns a negative return so -ENOMEM should be
    OK here (passed on as return value of the probe function). To make the
    error case more readable a temporary  iio_attr  is introduced and the code
    refactored.
    
    Signed-off-by: Nicholas Mc Guire <hofrat@osadl.org>
    Fixes: 2051f25d2a26 ("iio: adc: New driver for AD7280A Lithium Ion Battery Monitoring System2")
    Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>

diff --git a/drivers/staging/iio/adc/ad7280a.c b/drivers/staging/iio/adc/ad7280a.c
index 0bb9ab174f2a..7a0ba26f9fd9 100644
--- a/drivers/staging/iio/adc/ad7280a.c
+++ b/drivers/staging/iio/adc/ad7280a.c
@@ -561,6 +561,7 @@ static int ad7280_attr_init(struct ad7280_state *st)
 {
 	int dev, ch, cnt;
 	unsigned int index;
+	struct iio_dev_attr *iio_attr;
 
 	st->iio_attr = devm_kcalloc(&st->spi->dev, 2, sizeof(*st->iio_attr) *
 				    (st->slave_num + 1) * AD7280A_CELLS_PER_DEV,
@@ -571,37 +572,35 @@ static int ad7280_attr_init(struct ad7280_state *st)
 	for (dev = 0, cnt = 0; dev <= st->slave_num; dev++)
 		for (ch = AD7280A_CELL_VOLTAGE_1; ch <= AD7280A_CELL_VOLTAGE_6;
 			ch++, cnt++) {
+			iio_attr = &st->iio_attr[cnt];
 			index = dev * AD7280A_CELLS_PER_DEV + ch;
-			st->iio_attr[cnt].address =
-				ad7280a_devaddr(dev) << 8 | ch;
-			st->iio_attr[cnt].dev_attr.attr.mode =
-				0644;
-			st->iio_attr[cnt].dev_attr.show =
-				ad7280_show_balance_sw;
-			st->iio_attr[cnt].dev_attr.store =
-				ad7280_store_balance_sw;
-			st->iio_attr[cnt].dev_attr.attr.name =
+			iio_attr->address = ad7280a_devaddr(dev) << 8 | ch;
+			iio_attr->dev_attr.attr.mode = 0644;
+			iio_attr->dev_attr.show = ad7280_show_balance_sw;
+			iio_attr->dev_attr.store = ad7280_store_balance_sw;
+			iio_attr->dev_attr.attr.name =
 				devm_kasprintf(&st->spi->dev, GFP_KERNEL,
 					       "in%d-in%d_balance_switch_en",
 					       index, index + 1);
-			ad7280_attributes[cnt] =
-				&st->iio_attr[cnt].dev_attr.attr;
+			if (!iio_attr->dev_attr.attr.name)
+				return -ENOMEM;
+
+			ad7280_attributes[cnt] = &iio_attr->dev_attr.attr;
 			cnt++;
-			st->iio_attr[cnt].address =
-				ad7280a_devaddr(dev) << 8 |
+			iio_attr = &st->iio_attr[cnt];
+			iio_attr->address = ad7280a_devaddr(dev) << 8 |
 				(AD7280A_CB1_TIMER + ch);
-			st->iio_attr[cnt].dev_attr.attr.mode =
-				0644;
-			st->iio_attr[cnt].dev_attr.show =
-				ad7280_show_balance_timer;
-			st->iio_attr[cnt].dev_attr.store =
-				ad7280_store_balance_timer;
-			st->iio_attr[cnt].dev_attr.attr.name =
+			iio_attr->dev_attr.attr.mode = 0644;
+			iio_attr->dev_attr.show = ad7280_show_balance_timer;
+			iio_attr->dev_attr.store = ad7280_store_balance_timer;
+			iio_attr->dev_attr.attr.name =
 				devm_kasprintf(&st->spi->dev, GFP_KERNEL,
 					       "in%d-in%d_balance_timer",
 					       index, index + 1);
-			ad7280_attributes[cnt] =
-				&st->iio_attr[cnt].dev_attr.attr;
+			if (!iio_attr->dev_attr.attr.name)
+				return -ENOMEM;
+
+			ad7280_attributes[cnt] = &iio_attr->dev_attr.attr;
 		}
 
 	ad7280_attributes[cnt] = NULL;

commit cc9c58ef6e0623f92edc2988c8a8ebfb63b40cea
Author: Slawomir Stepien <sst@poczta.fm>
Date:   Sun Nov 11 16:59:11 2018 +0100

    staging: iio: adc: ad7280a: use devm_* APIs
    
    devm_* APIs are device managed and make code simpler.
    
    Signed-off-by: Slawomir Stepien <sst@poczta.fm>
    Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>

diff --git a/drivers/staging/iio/adc/ad7280a.c b/drivers/staging/iio/adc/ad7280a.c
index 5de701eda08e..0bb9ab174f2a 100644
--- a/drivers/staging/iio/adc/ad7280a.c
+++ b/drivers/staging/iio/adc/ad7280a.c
@@ -330,6 +330,14 @@ static int ad7280_read_all_channels(struct ad7280_state *st, unsigned int cnt,
 	return sum;
 }
 
+static void ad7280_sw_power_down(void *data)
+{
+	struct ad7280_state *st = data;
+
+	ad7280_write(st, AD7280A_DEVADDR_MASTER, AD7280A_CONTROL_HB, 1,
+		     AD7280A_CTRL_HB_PWRDN_SW | st->ctrl_hb);
+}
+
 static int ad7280_chain_setup(struct ad7280_state *st)
 {
 	unsigned int val, n;
@@ -492,8 +500,8 @@ static int ad7280_channel_init(struct ad7280_state *st)
 {
 	int dev, ch, cnt;
 
-	st->channels = kcalloc((st->slave_num + 1) * 12 + 2,
-			       sizeof(*st->channels), GFP_KERNEL);
+	st->channels = devm_kcalloc(&st->spi->dev, (st->slave_num + 1) * 12 + 2,
+				    sizeof(*st->channels), GFP_KERNEL);
 	if (!st->channels)
 		return -ENOMEM;
 
@@ -552,16 +560,18 @@ static int ad7280_channel_init(struct ad7280_state *st)
 static int ad7280_attr_init(struct ad7280_state *st)
 {
 	int dev, ch, cnt;
+	unsigned int index;
 
-	st->iio_attr = kcalloc(2, sizeof(*st->iio_attr) *
-			       (st->slave_num + 1) * AD7280A_CELLS_PER_DEV,
-			       GFP_KERNEL);
+	st->iio_attr = devm_kcalloc(&st->spi->dev, 2, sizeof(*st->iio_attr) *
+				    (st->slave_num + 1) * AD7280A_CELLS_PER_DEV,
+				    GFP_KERNEL);
 	if (!st->iio_attr)
 		return -ENOMEM;
 
 	for (dev = 0, cnt = 0; dev <= st->slave_num; dev++)
 		for (ch = AD7280A_CELL_VOLTAGE_1; ch <= AD7280A_CELL_VOLTAGE_6;
 			ch++, cnt++) {
+			index = dev * AD7280A_CELLS_PER_DEV + ch;
 			st->iio_attr[cnt].address =
 				ad7280a_devaddr(dev) << 8 | ch;
 			st->iio_attr[cnt].dev_attr.attr.mode =
@@ -571,10 +581,9 @@ static int ad7280_attr_init(struct ad7280_state *st)
 			st->iio_attr[cnt].dev_attr.store =
 				ad7280_store_balance_sw;
 			st->iio_attr[cnt].dev_attr.attr.name =
-				kasprintf(GFP_KERNEL,
-					  "in%d-in%d_balance_switch_en",
-					  dev * AD7280A_CELLS_PER_DEV + ch,
-					  dev * AD7280A_CELLS_PER_DEV + ch + 1);
+				devm_kasprintf(&st->spi->dev, GFP_KERNEL,
+					       "in%d-in%d_balance_switch_en",
+					       index, index + 1);
 			ad7280_attributes[cnt] =
 				&st->iio_attr[cnt].dev_attr.attr;
 			cnt++;
@@ -588,10 +597,9 @@ static int ad7280_attr_init(struct ad7280_state *st)
 			st->iio_attr[cnt].dev_attr.store =
 				ad7280_store_balance_timer;
 			st->iio_attr[cnt].dev_attr.attr.name =
-				kasprintf(GFP_KERNEL,
-					  "in%d-in%d_balance_timer",
-					  dev * AD7280A_CELLS_PER_DEV + ch,
-					  dev * AD7280A_CELLS_PER_DEV + ch + 1);
+				devm_kasprintf(&st->spi->dev, GFP_KERNEL,
+					       "in%d-in%d_balance_timer",
+					       index, index + 1);
 			ad7280_attributes[cnt] =
 				&st->iio_attr[cnt].dev_attr.attr;
 		}
@@ -872,6 +880,10 @@ static int ad7280_probe(struct spi_device *spi)
 	if (ret < 0)
 		return ret;
 
+	ret = devm_add_action_or_reset(&spi->dev, ad7280_sw_power_down, st);
+	if (ret)
+		return ret;
+
 	st->slave_num = ret;
 	st->scan_cnt = (st->slave_num + 1) * AD7280A_NUM_CH;
 	st->cell_threshhigh = 0xFF;
@@ -901,7 +913,7 @@ static int ad7280_probe(struct spi_device *spi)
 
 	ret = ad7280_channel_init(st);
 	if (ret < 0)
-		goto error_power_down;
+		return ret;
 
 	indio_dev->num_channels = ret;
 	indio_dev->channels = st->channels;
@@ -909,68 +921,37 @@ static int ad7280_probe(struct spi_device *spi)
 
 	ret = ad7280_attr_init(st);
 	if (ret < 0)
-		goto error_free_channels;
+		return ret;
 
-	ret = iio_device_register(indio_dev);
+	ret = devm_iio_device_register(&spi->dev, indio_dev);
 	if (ret)
-		goto error_free_attr;
+		return ret;
 
 	if (spi->irq > 0) {
 		ret = ad7280_write(st, AD7280A_DEVADDR_MASTER,
 				   AD7280A_ALERT, 1,
 				   AD7280A_ALERT_RELAY_SIG_CHAIN_DOWN);
 		if (ret)
-			goto error_unregister;
+			return ret;
 
 		ret = ad7280_write(st, ad7280a_devaddr(st->slave_num),
 				   AD7280A_ALERT, 0,
 				   AD7280A_ALERT_GEN_STATIC_HIGH |
 				   (pdata->chain_last_alert_ignore & 0xF));
 		if (ret)
-			goto error_unregister;
-
-		ret = request_threaded_irq(spi->irq,
-					   NULL,
-					   ad7280_event_handler,
-					   IRQF_TRIGGER_FALLING |
-					   IRQF_ONESHOT,
-					   indio_dev->name,
-					   indio_dev);
+			return ret;
+
+		ret = devm_request_threaded_irq(&spi->dev, spi->irq,
+						NULL,
+						ad7280_event_handler,
+						IRQF_TRIGGER_FALLING |
+						IRQF_ONESHOT,
+						indio_dev->name,
+						indio_dev);
 		if (ret)
-			goto error_unregister;
+			return ret;
 	}
 
-	return 0;
-error_unregister:
-	iio_device_unregister(indio_dev);
-
-error_free_attr:
-	kfree(st->iio_attr);
-
-error_free_channels:
-	kfree(st->channels);
-
-error_power_down:
-	ad7280_write(st, AD7280A_DEVADDR_MASTER, AD7280A_CONTROL_HB, 1,
-		     AD7280A_CTRL_HB_PWRDN_SW | st->ctrl_hb);
-	return ret;
-}
-
-static int ad7280_remove(struct spi_device *spi)
-{
-	struct iio_dev *indio_dev = spi_get_drvdata(spi);
-	struct ad7280_state *st = iio_priv(indio_dev);
-
-	if (spi->irq > 0)
-		free_irq(spi->irq, indio_dev);
-	iio_device_unregister(indio_dev);
-
-	ad7280_write(st, AD7280A_DEVADDR_MASTER, AD7280A_CONTROL_HB, 1,
-		     AD7280A_CTRL_HB_PWRDN_SW | st->ctrl_hb);
-
-	kfree(st->channels);
-	kfree(st->iio_attr);
-
 	return 0;
 }
 
@@ -985,7 +966,6 @@ static struct spi_driver ad7280_driver = {
 		.name	= "ad7280",
 	},
 	.probe		= ad7280_probe,
-	.remove		= ad7280_remove,
 	.id_table	= ad7280_id,
 };
 module_spi_driver(ad7280_driver);

commit 9829f9e5415c17824f23aa6e1573829256c8c298
Author: Slawomir Stepien <sst@poczta.fm>
Date:   Sun Nov 11 16:59:10 2018 +0100

    staging: iio: adc: ad7280a: power down the device on error in probe
    
    Power down the device if anything goes wrong after the SPI has been
    setup correctly in the probe function.
    
    Existing code that toggles the AD7280A_CTRL_LB_SWRST bit inside
    ad7280_chain_setup function is responsible for powering up the device.
    
    Signed-off-by: Slawomir Stepien <sst@poczta.fm>
    Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>

diff --git a/drivers/staging/iio/adc/ad7280a.c b/drivers/staging/iio/adc/ad7280a.c
index 89c2c2deca64..5de701eda08e 100644
--- a/drivers/staging/iio/adc/ad7280a.c
+++ b/drivers/staging/iio/adc/ad7280a.c
@@ -350,29 +350,38 @@ static int ad7280_chain_setup(struct ad7280_state *st)
 			   AD7280A_CTRL_LB_MUST_SET |
 			   st->ctrl_lb);
 	if (ret)
-		return ret;
+		goto error_power_down;
 
 	ret = ad7280_write(st, AD7280A_DEVADDR_MASTER, AD7280A_READ, 1,
 			   AD7280A_CONTROL_LB << 2);
 	if (ret)
-		return ret;
+		goto error_power_down;
 
 	for (n = 0; n <= AD7280A_MAX_CHAIN; n++) {
 		ret = __ad7280_read32(st, &val);
 		if (ret)
-			return ret;
+			goto error_power_down;
 
 		if (val == 0)
 			return n - 1;
 
-		if (ad7280_check_crc(st, val))
-			return -EIO;
+		if (ad7280_check_crc(st, val)) {
+			ret = -EIO;
+			goto error_power_down;
+		}
 
-		if (n != ad7280a_devaddr(val >> 27))
-			return -EIO;
+		if (n != ad7280a_devaddr(val >> 27)) {
+			ret = -EIO;
+			goto error_power_down;
+		}
 	}
+	ret = -EFAULT;
 
-	return -EFAULT;
+error_power_down:
+	ad7280_write(st, AD7280A_DEVADDR_MASTER, AD7280A_CONTROL_HB, 1,
+		     AD7280A_CTRL_HB_PWRDN_SW | st->ctrl_hb);
+
+	return ret;
 }
 
 static ssize_t ad7280_show_balance_sw(struct device *dev,
@@ -892,7 +901,7 @@ static int ad7280_probe(struct spi_device *spi)
 
 	ret = ad7280_channel_init(st);
 	if (ret < 0)
-		return ret;
+		goto error_power_down;
 
 	indio_dev->num_channels = ret;
 	indio_dev->channels = st->channels;
@@ -941,6 +950,9 @@ static int ad7280_probe(struct spi_device *spi)
 error_free_channels:
 	kfree(st->channels);
 
+error_power_down:
+	ad7280_write(st, AD7280A_DEVADDR_MASTER, AD7280A_CONTROL_HB, 1,
+		     AD7280A_CTRL_HB_PWRDN_SW | st->ctrl_hb);
 	return ret;
 }
 

commit fdee2ca14bcaecbd5738c679f91acbab74b349aa
Author: Slawomir Stepien <sst@poczta.fm>
Date:   Fri Oct 26 18:53:10 2018 +0200

    staging: iio: adc: ad7280a: don't cast type inside switch expression
    
    The type promotion will kick in, so the comparison will work.
    
    Signed-off-by: Slawomir Stepien <sst@poczta.fm>
    Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>

diff --git a/drivers/staging/iio/adc/ad7280a.c b/drivers/staging/iio/adc/ad7280a.c
index 7161998c8a0e..89c2c2deca64 100644
--- a/drivers/staging/iio/adc/ad7280a.c
+++ b/drivers/staging/iio/adc/ad7280a.c
@@ -601,7 +601,7 @@ static ssize_t ad7280_read_channel_config(struct device *dev,
 	struct iio_dev_attr *this_attr = to_iio_dev_attr(attr);
 	unsigned int val;
 
-	switch ((u32)this_attr->address) {
+	switch (this_attr->address) {
 	case AD7280A_CELL_OVERVOLTAGE:
 		val = 1000 + (st->cell_threshhigh * 1568) / 100;
 		break;
@@ -637,7 +637,7 @@ static ssize_t ad7280_write_channel_config(struct device *dev,
 	if (ret)
 		return ret;
 
-	switch ((u32)this_attr->address) {
+	switch (this_attr->address) {
 	case AD7280A_CELL_OVERVOLTAGE:
 	case AD7280A_CELL_UNDERVOLTAGE:
 		val = ((val - 1000) * 100) / 1568; /* LSB 15.68mV */
@@ -653,7 +653,7 @@ static ssize_t ad7280_write_channel_config(struct device *dev,
 	val = clamp(val, 0L, 0xFFL);
 
 	mutex_lock(&st->lock);
-	switch ((u32)this_attr->address) {
+	switch (this_attr->address) {
 	case AD7280A_CELL_OVERVOLTAGE:
 		st->cell_threshhigh = val;
 		break;

commit 4cd62a5425115ad14b54f2c7dece597c0c57d701
Author: Slawomir Stepien <sst@poczta.fm>
Date:   Thu Oct 18 20:59:33 2018 +0200

    staging: iio: adc: ad7280a: use crc8.h API to build crc table
    
    The custom build function ad7280_crc8_build_table is not needed. The
    crc8_populate_msb function from linux/crc8.h will build the same crc
    table.
    
    Signed-off-by: Slawomir Stepien <sst@poczta.fm>
    Acked-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>

diff --git a/drivers/staging/iio/adc/ad7280a.c b/drivers/staging/iio/adc/ad7280a.c
index cbeb52485a31..7161998c8a0e 100644
--- a/drivers/staging/iio/adc/ad7280a.c
+++ b/drivers/staging/iio/adc/ad7280a.c
@@ -6,6 +6,7 @@
  * Licensed under the GPL-2.
  */
 
+#include <linux/crc8.h>
 #include <linux/device.h>
 #include <linux/kernel.h>
 #include <linux/slab.h>
@@ -121,8 +122,6 @@ static unsigned int ad7280a_devaddr(unsigned int addr)
  * P(x) = x^8 + x^5 + x^3 + x^2 + x^1 + x^0 = 0b100101111 => 0x2F
  */
 #define POLYNOM		0x2F
-#define POLYNOM_ORDER	8
-#define HIGHBIT		(1 << (POLYNOM_ORDER - 1))
 
 struct ad7280_state {
 	struct spi_device		*spi;
@@ -131,7 +130,7 @@ struct ad7280_state {
 	int				slave_num;
 	int				scan_cnt;
 	int				readback_delay_us;
-	unsigned char			crc_tab[256];
+	unsigned char			crc_tab[CRC8_TABLE_SIZE];
 	unsigned char			ctrl_hb;
 	unsigned char			ctrl_lb;
 	unsigned char			cell_threshhigh;
@@ -144,23 +143,6 @@ struct ad7280_state {
 	__be32				buf[2] ____cacheline_aligned;
 };
 
-static void ad7280_crc8_build_table(unsigned char *crc_tab)
-{
-	unsigned char bit, crc;
-	int cnt, i;
-
-	for (cnt = 0; cnt < 256; cnt++) {
-		crc = cnt;
-		for (i = 0; i < 8; i++) {
-			bit = crc & HIGHBIT;
-			crc <<= 1;
-			if (bit)
-				crc ^= POLYNOM;
-		}
-		crc_tab[cnt] = crc;
-	}
-}
-
 static unsigned char ad7280_calc_crc8(unsigned char *crc_tab, unsigned int val)
 {
 	unsigned char crc;
@@ -866,7 +848,7 @@ static int ad7280_probe(struct spi_device *spi)
 	if (!pdata)
 		pdata = &ad7793_default_pdata;
 
-	ad7280_crc8_build_table(st->crc_tab);
+	crc8_populate_msb(st->crc_tab, POLYNOM);
 
 	st->spi->max_speed_hz = AD7280A_MAX_SPI_CLK_HZ;
 	st->spi->mode = SPI_MODE_1;

commit 0559ef7fde67bc6c83c6eb6329dbd6649528263e
Author: Slawomir Stepien <sst@poczta.fm>
Date:   Sat Oct 20 23:04:11 2018 +0200

    staging: iio: adc: ad7280a: handle error from __ad7280_read32()
    
    Inside __ad7280_read32(), the spi_sync_transfer() can fail with negative
    error code. This change will ensure that this error is being passed up
    in the call stack, so it can be handled.
    
    Signed-off-by: Slawomir Stepien <sst@poczta.fm>
    Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>

diff --git a/drivers/staging/iio/adc/ad7280a.c b/drivers/staging/iio/adc/ad7280a.c
index 58420dcb406d..cbeb52485a31 100644
--- a/drivers/staging/iio/adc/ad7280a.c
+++ b/drivers/staging/iio/adc/ad7280a.c
@@ -256,7 +256,9 @@ static int ad7280_read(struct ad7280_state *st, unsigned int devaddr,
 	if (ret)
 		return ret;
 
-	__ad7280_read32(st, &tmp);
+	ret = __ad7280_read32(st, &tmp);
+	if (ret)
+		return ret;
 
 	if (ad7280_check_crc(st, tmp))
 		return -EIO;
@@ -294,7 +296,9 @@ static int ad7280_read_channel(struct ad7280_state *st, unsigned int devaddr,
 
 	ad7280_delay(st);
 
-	__ad7280_read32(st, &tmp);
+	ret = __ad7280_read32(st, &tmp);
+	if (ret)
+		return ret;
 
 	if (ad7280_check_crc(st, tmp))
 		return -EIO;
@@ -327,7 +331,9 @@ static int ad7280_read_all_channels(struct ad7280_state *st, unsigned int cnt,
 	ad7280_delay(st);
 
 	for (i = 0; i < cnt; i++) {
-		__ad7280_read32(st, &tmp);
+		ret = __ad7280_read32(st, &tmp);
+		if (ret)
+			return ret;
 
 		if (ad7280_check_crc(st, tmp))
 			return -EIO;
@@ -370,7 +376,10 @@ static int ad7280_chain_setup(struct ad7280_state *st)
 		return ret;
 
 	for (n = 0; n <= AD7280A_MAX_CHAIN; n++) {
-		__ad7280_read32(st, &val);
+		ret = __ad7280_read32(st, &val);
+		if (ret)
+			return ret;
+
 		if (val == 0)
 			return n - 1;
 

commit 9920ed25eccc9b494926be5372ba745db83481ab
Author: Michael Hennerich <michael.hennerich@analog.com>
Date:   Tue Aug 14 13:23:17 2018 +0200

    drivers: iio: Update MODULE AUTHOR email address
    
    no functional changes
    
    Signed-off-by: Michael Hennerich <michael.hennerich@analog.com>
    Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>

diff --git a/drivers/staging/iio/adc/ad7280a.c b/drivers/staging/iio/adc/ad7280a.c
index b736275c10f5..58420dcb406d 100644
--- a/drivers/staging/iio/adc/ad7280a.c
+++ b/drivers/staging/iio/adc/ad7280a.c
@@ -987,6 +987,6 @@ static struct spi_driver ad7280_driver = {
 };
 module_spi_driver(ad7280_driver);
 
-MODULE_AUTHOR("Michael Hennerich <hennerich@blackfin.uclinux.org>");
+MODULE_AUTHOR("Michael Hennerich <michael.hennerich@analog.com>");
 MODULE_DESCRIPTION("Analog Devices AD7280A");
 MODULE_LICENSE("GPL v2");

commit ae6cc213822effebb88ee9d2cdd968593b40b80b
Author: Jonathan Cameron <jic23@kernel.org>
Date:   Sun Jul 23 17:26:10 2017 +0100

    staging:iio:adc: drop assign iio_info.driver_module
    
    The equivalent of this is now done via macro magic when
    the relevant register call is made.  The actual structure
    element will shortly go away.
    
    Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>
    Reviewed-by: Lars-Peter Clausen <lars@metafoo.de>

diff --git a/drivers/staging/iio/adc/ad7280a.c b/drivers/staging/iio/adc/ad7280a.c
index f85dde9805e0..b736275c10f5 100644
--- a/drivers/staging/iio/adc/ad7280a.c
+++ b/drivers/staging/iio/adc/ad7280a.c
@@ -828,7 +828,6 @@ static const struct iio_info ad7280_info = {
 	.read_raw = ad7280_read_raw,
 	.event_attrs = &ad7280_event_attrs_group,
 	.attrs = &ad7280_attrs_group,
-	.driver_module = THIS_MODULE,
 };
 
 static const struct ad7280_platform_data ad7793_default_pdata = {

commit 065a7c0b1fec9df9b22cf228b777fc3d2f4e6ba9
Author: Jaya Durga <rjdurga@gmail.com>
Date:   Wed Jul 19 17:55:57 2017 +0530

    Staging: iio: adc: ad7280a.c: Fixed Macro argument reuse
    
    CHECK: Macro argument reuse 'addr' - possible side-effects?
    
    convert AD7280A_DEVADDR to ad7280a_devaddr static function
    to fix checkpath check
    
    v3: small style changes
    
    Signed-off-by: Jaya Durga <rjdurga@gmail.com>
    Signed-off-by: Jonathan Cameron <Jonathan.Cameron@huawei.com>

diff --git a/drivers/staging/iio/adc/ad7280a.c b/drivers/staging/iio/adc/ad7280a.c
index d5ab83f0236d..f85dde9805e0 100644
--- a/drivers/staging/iio/adc/ad7280a.c
+++ b/drivers/staging/iio/adc/ad7280a.c
@@ -99,9 +99,14 @@
 #define AD7280A_DEVADDR_MASTER		0
 #define AD7280A_DEVADDR_ALL		0x1F
 /* 5-bit device address is sent LSB first */
-#define AD7280A_DEVADDR(addr)	(((addr & 0x1) << 4) | ((addr & 0x2) << 3) | \
-				(addr & 0x4) | ((addr & 0x8) >> 3) | \
-				((addr & 0x10) >> 4))
+static unsigned int ad7280a_devaddr(unsigned int addr)
+{
+	return ((addr & 0x1) << 4) |
+	       ((addr & 0x2) << 3) |
+	       (addr & 0x4) |
+	       ((addr & 0x8) >> 3) |
+	       ((addr & 0x10) >> 4);
+}
 
 /* During a read a valid write is mandatory.
  * So writing to the highest available address (Address 0x1F)
@@ -372,7 +377,7 @@ static int ad7280_chain_setup(struct ad7280_state *st)
 		if (ad7280_check_crc(st, val))
 			return -EIO;
 
-		if (n != AD7280A_DEVADDR(val >> 27))
+		if (n != ad7280a_devaddr(val >> 27))
 			return -EIO;
 	}
 
@@ -511,7 +516,7 @@ static int ad7280_channel_init(struct ad7280_state *st)
 			st->channels[cnt].info_mask_shared_by_type =
 				BIT(IIO_CHAN_INFO_SCALE);
 			st->channels[cnt].address =
-				AD7280A_DEVADDR(dev) << 8 | ch;
+				ad7280a_devaddr(dev) << 8 | ch;
 			st->channels[cnt].scan_index = cnt;
 			st->channels[cnt].scan_type.sign = 'u';
 			st->channels[cnt].scan_type.realbits = 12;
@@ -558,7 +563,7 @@ static int ad7280_attr_init(struct ad7280_state *st)
 		for (ch = AD7280A_CELL_VOLTAGE_1; ch <= AD7280A_CELL_VOLTAGE_6;
 			ch++, cnt++) {
 			st->iio_attr[cnt].address =
-				AD7280A_DEVADDR(dev) << 8 | ch;
+				ad7280a_devaddr(dev) << 8 | ch;
 			st->iio_attr[cnt].dev_attr.attr.mode =
 				0644;
 			st->iio_attr[cnt].dev_attr.show =
@@ -574,7 +579,7 @@ static int ad7280_attr_init(struct ad7280_state *st)
 				&st->iio_attr[cnt].dev_attr.attr;
 			cnt++;
 			st->iio_attr[cnt].address =
-				AD7280A_DEVADDR(dev) << 8 |
+				ad7280a_devaddr(dev) << 8 |
 				(AD7280A_CB1_TIMER + ch);
 			st->iio_attr[cnt].dev_attr.attr.mode =
 				0644;
@@ -918,7 +923,7 @@ static int ad7280_probe(struct spi_device *spi)
 		if (ret)
 			goto error_unregister;
 
-		ret = ad7280_write(st, AD7280A_DEVADDR(st->slave_num),
+		ret = ad7280_write(st, ad7280a_devaddr(st->slave_num),
 				   AD7280A_ALERT, 0,
 				   AD7280A_ALERT_GEN_STATIC_HIGH |
 				   (pdata->chain_last_alert_ignore & 0xF));

commit 40dffd9974b369be886d5fec7407087d7d9edfa8
Author: Olivier Leveque <o_leveque@orange.fr>
Date:   Thu Mar 23 14:18:09 2017 +0100

    staging: iio: adc: ad7280a: fix permission coding style issue
    
    Symbolic permissions 'S_IWUSR | S_IRUGO' are not preferred. Consider using
    octal permissions '0644'. Found running checkpatch.
    
    Signed-off-by: Olivier Leveque <o_leveque@orange.fr>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/staging/iio/adc/ad7280a.c b/drivers/staging/iio/adc/ad7280a.c
index 6a85e284c8a4..d5ab83f0236d 100644
--- a/drivers/staging/iio/adc/ad7280a.c
+++ b/drivers/staging/iio/adc/ad7280a.c
@@ -560,7 +560,7 @@ static int ad7280_attr_init(struct ad7280_state *st)
 			st->iio_attr[cnt].address =
 				AD7280A_DEVADDR(dev) << 8 | ch;
 			st->iio_attr[cnt].dev_attr.attr.mode =
-				S_IWUSR | S_IRUGO;
+				0644;
 			st->iio_attr[cnt].dev_attr.show =
 				ad7280_show_balance_sw;
 			st->iio_attr[cnt].dev_attr.store =
@@ -577,7 +577,7 @@ static int ad7280_attr_init(struct ad7280_state *st)
 				AD7280A_DEVADDR(dev) << 8 |
 				(AD7280A_CB1_TIMER + ch);
 			st->iio_attr[cnt].dev_attr.attr.mode =
-				S_IWUSR | S_IRUGO;
+				0644;
 			st->iio_attr[cnt].dev_attr.show =
 				ad7280_show_balance_timer;
 			st->iio_attr[cnt].dev_attr.store =
@@ -746,26 +746,26 @@ static irqreturn_t ad7280_event_handler(int irq, void *private)
 
 static IIO_DEVICE_ATTR_NAMED(in_thresh_low_value,
 		in_voltage-voltage_thresh_low_value,
-		S_IRUGO | S_IWUSR,
+		0644,
 		ad7280_read_channel_config,
 		ad7280_write_channel_config,
 		AD7280A_CELL_UNDERVOLTAGE);
 
 static IIO_DEVICE_ATTR_NAMED(in_thresh_high_value,
 		in_voltage-voltage_thresh_high_value,
-		S_IRUGO | S_IWUSR,
+		0644,
 		ad7280_read_channel_config,
 		ad7280_write_channel_config,
 		AD7280A_CELL_OVERVOLTAGE);
 
 static IIO_DEVICE_ATTR(in_temp_thresh_low_value,
-		S_IRUGO | S_IWUSR,
+		0644,
 		ad7280_read_channel_config,
 		ad7280_write_channel_config,
 		AD7280A_AUX_ADC_UNDERVOLTAGE);
 
 static IIO_DEVICE_ATTR(in_temp_thresh_high_value,
-		S_IRUGO | S_IWUSR,
+		0644,
 		ad7280_read_channel_config,
 		ad7280_write_channel_config,
 		AD7280A_AUX_ADC_OVERVOLTAGE);

commit dba968c4fea0f9368e709966666d6e35dfe05e62
Author: Gargi Sharma <gs051095@gmail.com>
Date:   Fri Mar 17 13:29:30 2017 +0530

    staging: iio: ad7280: Replace mlock with driver private lock
    
    The IIO subsystem is redefining iio_dev->mlock to be used by
    the IIO core only for protecting device operating mode changes.
    ie. Changes between INDIO_DIRECT_MODE, INDIO_BUFFER_* modes.
    
    In this driver, mlock was being used to protect hardware state
    changes.  Replace it with a lock in the devices global data.
    
    Signed-off-by: Gargi Sharma <gs051095@gmail.com>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/staging/iio/adc/ad7280a.c b/drivers/staging/iio/adc/ad7280a.c
index ee679ac0368f..6a85e284c8a4 100644
--- a/drivers/staging/iio/adc/ad7280a.c
+++ b/drivers/staging/iio/adc/ad7280a.c
@@ -134,6 +134,7 @@ struct ad7280_state {
 	unsigned char			aux_threshhigh;
 	unsigned char			aux_threshlow;
 	unsigned char			cb_mask[AD7280A_MAX_CHAIN];
+	struct mutex			lock; /* protect sensor state */
 
 	__be32				buf[2] ____cacheline_aligned;
 };
@@ -410,7 +411,7 @@ static ssize_t ad7280_store_balance_sw(struct device *dev,
 	devaddr = this_attr->address >> 8;
 	ch = this_attr->address & 0xFF;
 
-	mutex_lock(&indio_dev->mlock);
+	mutex_lock(&st->lock);
 	if (readin)
 		st->cb_mask[devaddr] |= 1 << (ch + 2);
 	else
@@ -418,7 +419,7 @@ static ssize_t ad7280_store_balance_sw(struct device *dev,
 
 	ret = ad7280_write(st, devaddr, AD7280A_CELL_BALANCE,
 			   0, st->cb_mask[devaddr]);
-	mutex_unlock(&indio_dev->mlock);
+	mutex_unlock(&st->lock);
 
 	return ret ? ret : len;
 }
@@ -433,10 +434,10 @@ static ssize_t ad7280_show_balance_timer(struct device *dev,
 	int ret;
 	unsigned int msecs;
 
-	mutex_lock(&indio_dev->mlock);
+	mutex_lock(&st->lock);
 	ret = ad7280_read(st, this_attr->address >> 8,
 			  this_attr->address & 0xFF);
-	mutex_unlock(&indio_dev->mlock);
+	mutex_unlock(&st->lock);
 
 	if (ret < 0)
 		return ret;
@@ -466,11 +467,11 @@ static ssize_t ad7280_store_balance_timer(struct device *dev,
 	if (val > 31)
 		return -EINVAL;
 
-	mutex_lock(&indio_dev->mlock);
+	mutex_lock(&st->lock);
 	ret = ad7280_write(st, this_attr->address >> 8,
 			   this_attr->address & 0xFF,
 			   0, (val & 0x1F) << 3);
-	mutex_unlock(&indio_dev->mlock);
+	mutex_unlock(&st->lock);
 
 	return ret ? ret : len;
 }
@@ -655,7 +656,7 @@ static ssize_t ad7280_write_channel_config(struct device *dev,
 
 	val = clamp(val, 0L, 0xFFL);
 
-	mutex_lock(&indio_dev->mlock);
+	mutex_lock(&st->lock);
 	switch ((u32)this_attr->address) {
 	case AD7280A_CELL_OVERVOLTAGE:
 		st->cell_threshhigh = val;
@@ -674,7 +675,7 @@ static ssize_t ad7280_write_channel_config(struct device *dev,
 	ret = ad7280_write(st, AD7280A_DEVADDR_MASTER,
 			   this_attr->address, 1, val);
 
-	mutex_unlock(&indio_dev->mlock);
+	mutex_unlock(&st->lock);
 
 	return ret ? ret : len;
 }
@@ -792,13 +793,13 @@ static int ad7280_read_raw(struct iio_dev *indio_dev,
 
 	switch (m) {
 	case IIO_CHAN_INFO_RAW:
-		mutex_lock(&indio_dev->mlock);
+		mutex_lock(&st->lock);
 		if (chan->address == AD7280A_ALL_CELLS)
 			ret = ad7280_read_all_channels(st, st->scan_cnt, NULL);
 		else
 			ret = ad7280_read_channel(st, chan->address >> 8,
 						  chan->address & 0xFF);
-		mutex_unlock(&indio_dev->mlock);
+		mutex_unlock(&st->lock);
 
 		if (ret < 0)
 			return ret;
@@ -847,6 +848,7 @@ static int ad7280_probe(struct spi_device *spi)
 	st = iio_priv(indio_dev);
 	spi_set_drvdata(spi, indio_dev);
 	st->spi = spi;
+	mutex_init(&st->lock);
 
 	if (!pdata)
 		pdata = &ad7793_default_pdata;

commit e0e1bec8550114b0571f3867bb355f79b464b1d4
Author: Bhumika Goyal <bhumirks@gmail.com>
Date:   Sun Oct 2 00:45:12 2016 +0530

    Staging: iio: ad7280a: constify attribute_group structures
    
    Check for attribute_group structures that are only stored in the
    event_attrs filed of iio_info structure. As the event_attrs field
    of iio_info structures is constant, so these attribute_group
    structures can also be declared constant.
    Done using coccinelle:
    
    @r1 disable optional_qualifier @
    identifier i;
    position p;
    @@
    static struct attribute_group i@p = {...};
    
    @ok1@
    identifier r1.i;
    position p;
    struct iio_info x;
    @@
    x.event_attrs=&i@p;
    
    @bad@
    position p!={r1.p,ok1.p};
    identifier r1.i;
    @@
    i@p
    
    @depends on !bad disable optional_qualifier@
    identifier r1.i;
    @@
    static
    +const
    struct attribute_group i={...};
    
    @depends on !bad disable optional_qualifier@
    identifier r1.i;
    @@
    +const
    struct attribute_group i;
    
    File size before:
       text    data     bss     dec     hex filename
       6271     672     776    7719    1e27
    drivers/staging/iio/adc/ad7280a.o
    
    File size after:
       text    data     bss     dec     hex filename
       6335     608     776    7719    1e27
    drivers/staging/iio/adc/ad7280a.o
    
    Signed-off-by: Bhumika Goyal <bhumirks@gmail.com>
    Acked-by: Julia Lawall <julia.lawall@lip6.fr>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/staging/iio/adc/ad7280a.c b/drivers/staging/iio/adc/ad7280a.c
index b460dda7eb65..ee679ac0368f 100644
--- a/drivers/staging/iio/adc/ad7280a.c
+++ b/drivers/staging/iio/adc/ad7280a.c
@@ -777,7 +777,7 @@ static struct attribute *ad7280_event_attributes[] = {
 	NULL,
 };
 
-static struct attribute_group ad7280_event_attrs_group = {
+static const struct attribute_group ad7280_event_attrs_group = {
 	.attrs = ad7280_event_attributes,
 };
 

commit d306ddbad1b21287eb4a779dbc1d1e782f2fb1e1
Author: Bhumika Goyal <bhumirks@gmail.com>
Date:   Mon Sep 26 10:31:38 2016 +0530

    Staging:iio:adc:ad7280a: constify attribute_group structures
    
    Check for attribute_group structures that are only stored in the
    attrs filed of iio_info structure. As the attrs field of iio_info
    structures is constant, so these attribute_group structures can also be
    declared constant.
    Done using coccinelle:
    
    @r1 disable optional_qualifier @
    identifier i;
    position p;
    @@
    static struct attribute_group i@p = {...};
    
    @ok1@
    identifier r1.i;
    position p;
    struct iio_info x;
    @@
    x.attrs=&i@p;
    
    @bad@
    position p!={r1.p,ok1.p};
    identifier r1.i;
    @@
    i@p
    
    @depends on !bad disable optional_qualifier@
    identifier r1.i;
    @@
    static
    +const
    struct attribute_group i={...};
    
    @depends on !bad disable optional_qualifier@
    identifier r1.i;
    @@
    +const
    struct attribute_group i;
    
    File size before: drivers/staging/iio/adc/ad7280a.o
       text    data     bss     dec     hex filename
       6487     584     776    7847    1ea7
    drivers/staging/iio/adc/ad7280a.o
    
    File size after: drivers/staging/iio/adc/ad7280a.o
       text    data     bss     dec     hex filename
       6551     544     776    7871    1ebf
    drivers/staging/iio/adc/ad7280a.o
    
    Signed-off-by: Bhumika Goyal <bhumirks@gmail.com>
    Acked-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/staging/iio/adc/ad7280a.c b/drivers/staging/iio/adc/ad7280a.c
index 2177f1dd2b5d..b460dda7eb65 100644
--- a/drivers/staging/iio/adc/ad7280a.c
+++ b/drivers/staging/iio/adc/ad7280a.c
@@ -478,7 +478,7 @@ static ssize_t ad7280_store_balance_timer(struct device *dev,
 static struct attribute *ad7280_attributes[AD7280A_MAX_CHAIN *
 					   AD7280A_CELLS_PER_DEV * 2 + 1];
 
-static struct attribute_group ad7280_attrs_group = {
+static const struct attribute_group ad7280_attrs_group = {
 	.attrs = ad7280_attributes,
 };
 

commit bc2b7dab629a51e8beb5fda4222c62a23b729f26
Author: Gregor Boirie <gregor.boirie@parrot.com>
Date:   Wed Mar 9 19:05:49 2016 +0100

    iio:core: timestamping clock selection support
    
    Adds a new per-device sysfs attribute "current_timestamp_clock" to allow
    userspace to select a particular POSIX clock for buffered samples and
    events timestamping.
    
    Following clocks, as listed in clock_gettime(2), are supported:
    CLOCK_REALTIME, CLOCK_MONOTONIC, CLOCK_MONOTONIC_RAW,
    CLOCK_REALTIME_COARSE, CLOCK_MONOTONIC_COARSE, CLOCK_BOOTTIME and
    CLOCK_TAI.
    
    Signed-off-by: Gregor Boirie <gregor.boirie@parrot.com>
    Acked-by: Sanchayan Maity <maitysanchayan@gmail.com>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/staging/iio/adc/ad7280a.c b/drivers/staging/iio/adc/ad7280a.c
index a06b46cb81ca..2177f1dd2b5d 100644
--- a/drivers/staging/iio/adc/ad7280a.c
+++ b/drivers/staging/iio/adc/ad7280a.c
@@ -705,7 +705,7 @@ static irqreturn_t ad7280_event_handler(int irq, void *private)
 							IIO_EV_DIR_RISING,
 							IIO_EV_TYPE_THRESH,
 							0, 0, 0),
-					       iio_get_time_ns());
+					       iio_get_time_ns(indio_dev));
 			else if (((channels[i] >> 11) & 0xFFF) <=
 				st->cell_threshlow)
 				iio_push_event(indio_dev,
@@ -715,7 +715,7 @@ static irqreturn_t ad7280_event_handler(int irq, void *private)
 							IIO_EV_DIR_FALLING,
 							IIO_EV_TYPE_THRESH,
 							0, 0, 0),
-					       iio_get_time_ns());
+					       iio_get_time_ns(indio_dev));
 		} else {
 			if (((channels[i] >> 11) & 0xFFF) >= st->aux_threshhigh)
 				iio_push_event(indio_dev,
@@ -724,7 +724,7 @@ static irqreturn_t ad7280_event_handler(int irq, void *private)
 							0,
 							IIO_EV_TYPE_THRESH,
 							IIO_EV_DIR_RISING),
-					       iio_get_time_ns());
+					       iio_get_time_ns(indio_dev));
 			else if (((channels[i] >> 11) & 0xFFF) <=
 				st->aux_threshlow)
 				iio_push_event(indio_dev,
@@ -733,7 +733,7 @@ static irqreturn_t ad7280_event_handler(int irq, void *private)
 							0,
 							IIO_EV_TYPE_THRESH,
 							IIO_EV_DIR_FALLING),
-					       iio_get_time_ns());
+					       iio_get_time_ns(indio_dev));
 		}
 	}
 

commit 51fadb985786929af9377245042b412302d2c9a2
Author: Alison Schofield <amsfield22@gmail.com>
Date:   Sat Mar 26 12:50:24 2016 -0700

    staging: iio: convert bare unsigned usage to unsigned int
    
    Use kernel preferred unsigned int declaration style.
    
    Patch created using:
    git ls-files drivers/staging/iio | \
    xargs ./scripts/checkpatch.pl -f --fix-inplace --types=unspecified_int
    
    Hand edits restored columns in structure definitions.
    
    Signed-off-by: Alison Schofield <amsfield22@gmail.com>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/staging/iio/adc/ad7280a.c b/drivers/staging/iio/adc/ad7280a.c
index 62e5ecacf634..a06b46cb81ca 100644
--- a/drivers/staging/iio/adc/ad7280a.c
+++ b/drivers/staging/iio/adc/ad7280a.c
@@ -155,7 +155,7 @@ static void ad7280_crc8_build_table(unsigned char *crc_tab)
 	}
 }
 
-static unsigned char ad7280_calc_crc8(unsigned char *crc_tab, unsigned val)
+static unsigned char ad7280_calc_crc8(unsigned char *crc_tab, unsigned int val)
 {
 	unsigned char crc;
 
@@ -165,7 +165,7 @@ static unsigned char ad7280_calc_crc8(unsigned char *crc_tab, unsigned val)
 	return  crc ^ (val & 0xFF);
 }
 
-static int ad7280_check_crc(struct ad7280_state *st, unsigned val)
+static int ad7280_check_crc(struct ad7280_state *st, unsigned int val)
 {
 	unsigned char crc = ad7280_calc_crc8(st->crc_tab, val >> 10);
 
@@ -191,7 +191,7 @@ static void ad7280_delay(struct ad7280_state *st)
 		usleep_range(250, 500);
 }
 
-static int __ad7280_read32(struct ad7280_state *st, unsigned *val)
+static int __ad7280_read32(struct ad7280_state *st, unsigned int *val)
 {
 	int ret;
 	struct spi_transfer t = {
@@ -211,10 +211,10 @@ static int __ad7280_read32(struct ad7280_state *st, unsigned *val)
 	return 0;
 }
 
-static int ad7280_write(struct ad7280_state *st, unsigned devaddr,
-			unsigned addr, bool all, unsigned val)
+static int ad7280_write(struct ad7280_state *st, unsigned int devaddr,
+			unsigned int addr, bool all, unsigned int val)
 {
-	unsigned reg = devaddr << 27 | addr << 21 |
+	unsigned int reg = devaddr << 27 | addr << 21 |
 			(val & 0xFF) << 13 | all << 12;
 
 	reg |= ad7280_calc_crc8(st->crc_tab, reg >> 11) << 3 | 0x2;
@@ -223,11 +223,11 @@ static int ad7280_write(struct ad7280_state *st, unsigned devaddr,
 	return spi_write(st->spi, &st->buf[0], 4);
 }
 
-static int ad7280_read(struct ad7280_state *st, unsigned devaddr,
-		       unsigned addr)
+static int ad7280_read(struct ad7280_state *st, unsigned int devaddr,
+		       unsigned int addr)
 {
 	int ret;
-	unsigned tmp;
+	unsigned int tmp;
 
 	/* turns off the read operation on all parts */
 	ret = ad7280_write(st, AD7280A_DEVADDR_MASTER, AD7280A_CONTROL_HB, 1,
@@ -261,11 +261,11 @@ static int ad7280_read(struct ad7280_state *st, unsigned devaddr,
 	return (tmp >> 13) & 0xFF;
 }
 
-static int ad7280_read_channel(struct ad7280_state *st, unsigned devaddr,
-			       unsigned addr)
+static int ad7280_read_channel(struct ad7280_state *st, unsigned int devaddr,
+			       unsigned int addr)
 {
 	int ret;
-	unsigned tmp;
+	unsigned int tmp;
 
 	ret = ad7280_write(st, devaddr, AD7280A_READ, 0, addr << 2);
 	if (ret)
@@ -299,11 +299,11 @@ static int ad7280_read_channel(struct ad7280_state *st, unsigned devaddr,
 	return (tmp >> 11) & 0xFFF;
 }
 
-static int ad7280_read_all_channels(struct ad7280_state *st, unsigned cnt,
-				    unsigned *array)
+static int ad7280_read_all_channels(struct ad7280_state *st, unsigned int cnt,
+				    unsigned int *array)
 {
 	int i, ret;
-	unsigned tmp, sum = 0;
+	unsigned int tmp, sum = 0;
 
 	ret = ad7280_write(st, AD7280A_DEVADDR_MASTER, AD7280A_READ, 1,
 			   AD7280A_CELL_VOLTAGE_1 << 2);
@@ -338,7 +338,7 @@ static int ad7280_read_all_channels(struct ad7280_state *st, unsigned cnt,
 
 static int ad7280_chain_setup(struct ad7280_state *st)
 {
-	unsigned val, n;
+	unsigned int val, n;
 	int ret;
 
 	ret = ad7280_write(st, AD7280A_DEVADDR_MASTER, AD7280A_CONTROL_LB, 1,
@@ -401,7 +401,7 @@ static ssize_t ad7280_store_balance_sw(struct device *dev,
 	struct iio_dev_attr *this_attr = to_iio_dev_attr(attr);
 	bool readin;
 	int ret;
-	unsigned devaddr, ch;
+	unsigned int devaddr, ch;
 
 	ret = strtobool(buf, &readin);
 	if (ret)
@@ -431,7 +431,7 @@ static ssize_t ad7280_show_balance_timer(struct device *dev,
 	struct ad7280_state *st = iio_priv(indio_dev);
 	struct iio_dev_attr *this_attr = to_iio_dev_attr(attr);
 	int ret;
-	unsigned msecs;
+	unsigned int msecs;
 
 	mutex_lock(&indio_dev->mlock);
 	ret = ad7280_read(st, this_attr->address >> 8,
@@ -602,7 +602,7 @@ static ssize_t ad7280_read_channel_config(struct device *dev,
 	struct iio_dev *indio_dev = dev_to_iio_dev(dev);
 	struct ad7280_state *st = iio_priv(indio_dev);
 	struct iio_dev_attr *this_attr = to_iio_dev_attr(attr);
-	unsigned val;
+	unsigned int val;
 
 	switch ((u32)this_attr->address) {
 	case AD7280A_CELL_OVERVOLTAGE:
@@ -683,7 +683,7 @@ static irqreturn_t ad7280_event_handler(int irq, void *private)
 {
 	struct iio_dev *indio_dev = private;
 	struct ad7280_state *st = iio_priv(indio_dev);
-	unsigned *channels;
+	unsigned int *channels;
 	int i, ret;
 
 	channels = kcalloc(st->scan_cnt, sizeof(*channels), GFP_KERNEL);

commit 8c79c49c803da7e1bd21da0374cf02083becae04
Author: Janani Ravichandran <janani.rvchndrn@gmail.com>
Date:   Tue Feb 9 13:40:28 2016 -0500

    staging: iio: Remove parantheses around right hand side of assignment
    
    Remove parantheses on the right hand side of assignments as they are not
    needed. Coccinelle patch used:
    @@
    expression a, b, c, d;
    @@
    
    (
      a = (c == d)
    |
      a =
    - (
      b
    - )
    )
    
    Signed-off-by: Janani Ravichandran <janani.rvchndrn@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/iio/adc/ad7280a.c b/drivers/staging/iio/adc/ad7280a.c
index f45ebedb7a05..62e5ecacf634 100644
--- a/drivers/staging/iio/adc/ad7280a.c
+++ b/drivers/staging/iio/adc/ad7280a.c
@@ -214,8 +214,8 @@ static int __ad7280_read32(struct ad7280_state *st, unsigned *val)
 static int ad7280_write(struct ad7280_state *st, unsigned devaddr,
 			unsigned addr, bool all, unsigned val)
 {
-	unsigned reg = (devaddr << 27 | addr << 21 |
-			(val & 0xFF) << 13 | all << 12);
+	unsigned reg = devaddr << 27 | addr << 21 |
+			(val & 0xFF) << 13 | all << 12;
 
 	reg |= ad7280_calc_crc8(st->crc_tab, reg >> 11) << 3 | 0x2;
 	st->buf[0] = cpu_to_be32(reg);

commit 22b19ab3e2d6da666be816e649af67bf721b8561
Author: Nizam Haider <nizamhaider786@gmail.com>
Date:   Mon Nov 23 23:03:07 2015 +0530

    Staging: iio: adc: use dev_get_platdata()
    
    Use the wrapper function for retrieving the platform data instead of
    accessing dev->platform_data directly.
    
    Signed-off-by: Nizam Haider <nijamh@cdac.in>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/staging/iio/adc/ad7280a.c b/drivers/staging/iio/adc/ad7280a.c
index 35acb1a4669b..f45ebedb7a05 100644
--- a/drivers/staging/iio/adc/ad7280a.c
+++ b/drivers/staging/iio/adc/ad7280a.c
@@ -833,7 +833,7 @@ static const struct ad7280_platform_data ad7793_default_pdata = {
 
 static int ad7280_probe(struct spi_device *spi)
 {
-	const struct ad7280_platform_data *pdata = spi->dev.platform_data;
+	const struct ad7280_platform_data *pdata = dev_get_platdata(&spi->dev);
 	struct ad7280_state *st;
 	int ret;
 	const unsigned short tACQ_ns[4] = {465, 1010, 1460, 1890};

commit 75f5db39ff14ed95056f2cca3ad98c3cae97170c
Merge: 52787e91bf53 c70efb851531
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Nov 5 13:15:12 2015 -0800

    Merge tag 'spi-v4.4' of git://git.kernel.org/pub/scm/linux/kernel/git/broonie/spi
    
    Pull spi updates from Mark Brown:
     "Quite a lot of activity in SPI this cycle, almost all of it in drivers
      with a few minor improvements and tweaks in the core.
    
       - Updates to pxa2xx to support Intel Broxton and multiple chip selects.
       - Support for big endian in the bcm63xx driver.
       - Multiple slave support for the mt8173
       - New driver for the auxiliary SPI controller in bcm2835 SoCs.
       - Support for Layerscale SoCs in the Freescale DSPI driver"
    
    * tag 'spi-v4.4' of git://git.kernel.org/pub/scm/linux/kernel/git/broonie/spi: (87 commits)
      spi: pxa2xx: Rework self-initiated platform data creation for non-ACPI
      spi: pxa2xx: Add support for Intel Broxton
      spi: pxa2xx: Detect number of enabled Intel LPSS SPI chip select signals
      spi: pxa2xx: Add output control for multiple Intel LPSS chip selects
      spi: pxa2xx: Use LPSS prefix for defines that are Intel LPSS specific
      spi: Add DSPI support for layerscape family
      spi: ti-qspi: improve ->remove() callback
      spi/spi-xilinx: Fix race condition on last word read
      spi: Drop owner assignment from spi_drivers
      spi: Add THIS_MODULE to spi_driver in SPI core
      spi: Setup the master controller driver before setting the chipselect
      spi: dw: replace magic constant by DW_SPI_DR
      spi: mediatek: mt8173 spi multiple devices support
      spi: mediatek: handle controller_data in mtk_spi_setup
      spi: mediatek: remove mtk_spi_config
      spi: mediatek: Update document devicetree bindings to support multiple devices
      spi: fix kernel-doc warnings about missing return desc in spi.c
      spi: fix kernel-doc warnings about missing return desc in spi.h
      spi: pxa2xx: Align a few defines
      spi: pxa2xx: Save other reg_cs_ctrl bits when configuring chip select
      ...

commit 3821a065f5672c430a088ae68b4da2a2d2b34106
Author: Andrew F. Davis <afd@ti.com>
Date:   Fri Oct 23 08:59:11 2015 -0500

    spi: Drop owner assignment from spi_drivers
    
    An spi_driver does not need to set an owner, it will be populated by the
    driver core.
    
    Signed-off-by: Andrew F. Davis <afd@ti.com>
    Acked-by: Jonathan Cameron <jic23@kernel.org>
    Signed-off-by: Mark Brown <broonie@kernel.org>

diff --git a/drivers/staging/iio/adc/ad7280a.c b/drivers/staging/iio/adc/ad7280a.c
index d98e229c46bf..8a7c8737adc4 100644
--- a/drivers/staging/iio/adc/ad7280a.c
+++ b/drivers/staging/iio/adc/ad7280a.c
@@ -972,7 +972,6 @@ MODULE_DEVICE_TABLE(spi, ad7280_id);
 static struct spi_driver ad7280_driver = {
 	.driver = {
 		.name	= "ad7280",
-		.owner	= THIS_MODULE,
 	},
 	.probe		= ad7280_probe,
 	.remove		= ad7280_remove,

commit 5f7e280f5ae61450a7aecd9feefe3f032b6a5abf
Author: Ioana Ciornei <ciorneiioana@gmail.com>
Date:   Wed Oct 14 21:14:19 2015 +0300

    staging: iio: adc: remove the use of CamelCase
    
    Remove the use of CamelCase to follow the kernel naming conventions
    
    Signed-off-by: Ioana Ciornei <ciorneiioana@gmail.com>
    Reviewed-by: Daniel Baluta <daniel.baluta@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/iio/adc/ad7280a.c b/drivers/staging/iio/adc/ad7280a.c
index d37e8a436986..45df714cc83a 100644
--- a/drivers/staging/iio/adc/ad7280a.c
+++ b/drivers/staging/iio/adc/ad7280a.c
@@ -89,7 +89,7 @@
 
 #define AD7280A_ALL_CELLS				(0xAD << 16)
 
-#define AD7280A_MAX_SPI_CLK_Hz		700000 /* < 1MHz */
+#define AD7280A_MAX_SPI_CLK_HZ		700000 /* < 1MHz */
 #define AD7280A_MAX_CHAIN		8
 #define AD7280A_CELLS_PER_DEV		6
 #define AD7280A_BITS			12
@@ -853,7 +853,7 @@ static int ad7280_probe(struct spi_device *spi)
 
 	ad7280_crc8_build_table(st->crc_tab);
 
-	st->spi->max_speed_hz = AD7280A_MAX_SPI_CLK_Hz;
+	st->spi->max_speed_hz = AD7280A_MAX_SPI_CLK_HZ;
 	st->spi->mode = SPI_MODE_1;
 	spi_setup(st->spi);
 

commit 253ed6848f07b910be5a9bbe1a741c6bc679cb54
Author: Ioana Ciornei <ciorneiioana@gmail.com>
Date:   Wed Oct 14 21:14:18 2015 +0300

    staging: iio: adc: remove multiple blank lines
    
    Remove multiple blank lines since there is no practical reason
    to have it
    
    Signed-off-by: Ioana Ciornei <ciorneiioana@gmail.com>
    Reviewed-by: Daniel Baluta <daniel.baluta@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/iio/adc/ad7280a.c b/drivers/staging/iio/adc/ad7280a.c
index 273703399282..d37e8a436986 100644
--- a/drivers/staging/iio/adc/ad7280a.c
+++ b/drivers/staging/iio/adc/ad7280a.c
@@ -769,7 +769,6 @@ static IIO_DEVICE_ATTR(in_temp_thresh_high_value,
 		ad7280_write_channel_config,
 		AD7280A_AUX_ADC_OVERVOLTAGE);
 
-
 static struct attribute *ad7280_event_attributes[] = {
 	&iio_dev_attr_in_thresh_low_value.dev_attr.attr,
 	&iio_dev_attr_in_thresh_high_value.dev_attr.attr,

commit c30685c67cc21490fc6842cbbc68404be90f6859
Author: Ioana Ciornei <ciorneiioana@gmail.com>
Date:   Wed Oct 14 21:14:15 2015 +0300

    staging: iio: adc: remove space after cast
    
    Remove the space after an explicit cast because there is no
    point in having it
    
    Signed-off-by: Ioana Ciornei <ciorneiioana@gmail.com>
    Reviewed-by: Daniel Baluta <daniel.baluta@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/iio/adc/ad7280a.c b/drivers/staging/iio/adc/ad7280a.c
index 01156c7ceefb..273703399282 100644
--- a/drivers/staging/iio/adc/ad7280a.c
+++ b/drivers/staging/iio/adc/ad7280a.c
@@ -604,7 +604,7 @@ static ssize_t ad7280_read_channel_config(struct device *dev,
 	struct iio_dev_attr *this_attr = to_iio_dev_attr(attr);
 	unsigned val;
 
-	switch ((u32) this_attr->address) {
+	switch ((u32)this_attr->address) {
 	case AD7280A_CELL_OVERVOLTAGE:
 		val = 1000 + (st->cell_threshhigh * 1568) / 100;
 		break;
@@ -640,7 +640,7 @@ static ssize_t ad7280_write_channel_config(struct device *dev,
 	if (ret)
 		return ret;
 
-	switch ((u32) this_attr->address) {
+	switch ((u32)this_attr->address) {
 	case AD7280A_CELL_OVERVOLTAGE:
 	case AD7280A_CELL_UNDERVOLTAGE:
 		val = ((val - 1000) * 100) / 1568; /* LSB 15.68mV */
@@ -656,7 +656,7 @@ static ssize_t ad7280_write_channel_config(struct device *dev,
 	val = clamp(val, 0L, 0xFFL);
 
 	mutex_lock(&indio_dev->mlock);
-	switch ((u32) this_attr->address) {
+	switch ((u32)this_attr->address) {
 	case AD7280A_CELL_OVERVOLTAGE:
 		st->cell_threshhigh = val;
 		break;

commit 603f102f7887e742ae85939dad80e868c2e64885
Author: Ioana Ciornei <ciorneiioana@gmail.com>
Date:   Wed Oct 14 21:14:14 2015 +0300

    staging: iio: adc: remove explicit comparison to NULL
    
    Use !condition instead off condition == NULL when comparing with NULL
    
    Signed-off-by: Ioana Ciornei <ciorneiioana@gmail.com>
    Reviewed-by: Daniel Baluta <daniel.baluta@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/iio/adc/ad7280a.c b/drivers/staging/iio/adc/ad7280a.c
index 6db764e68c97..01156c7ceefb 100644
--- a/drivers/staging/iio/adc/ad7280a.c
+++ b/drivers/staging/iio/adc/ad7280a.c
@@ -488,7 +488,7 @@ static int ad7280_channel_init(struct ad7280_state *st)
 
 	st->channels = kcalloc((st->slave_num + 1) * 12 + 2,
 			       sizeof(*st->channels), GFP_KERNEL);
-	if (st->channels == NULL)
+	if (!st->channels)
 		return -ENOMEM;
 
 	for (dev = 0, cnt = 0; dev <= st->slave_num; dev++)
@@ -550,7 +550,7 @@ static int ad7280_attr_init(struct ad7280_state *st)
 	st->iio_attr = kcalloc(2, sizeof(*st->iio_attr) *
 			       (st->slave_num + 1) * AD7280A_CELLS_PER_DEV,
 			       GFP_KERNEL);
-	if (st->iio_attr == NULL)
+	if (!st->iio_attr)
 		return -ENOMEM;
 
 	for (dev = 0, cnt = 0; dev <= st->slave_num; dev++)
@@ -687,7 +687,7 @@ static irqreturn_t ad7280_event_handler(int irq, void *private)
 	int i, ret;
 
 	channels = kcalloc(st->scan_cnt, sizeof(*channels), GFP_KERNEL);
-	if (channels == NULL)
+	if (!channels)
 		return IRQ_HANDLED;
 
 	ret = ad7280_read_all_channels(st, st->scan_cnt, channels);
@@ -842,7 +842,7 @@ static int ad7280_probe(struct spi_device *spi)
 	struct iio_dev *indio_dev;
 
 	indio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*st));
-	if (indio_dev == NULL)
+	if (!indio_dev)
 		return -ENOMEM;
 
 	st = iio_priv(indio_dev);

commit e8ef49f09b26a4c11ad846ef1afa2a726a8c6800
Author: Ioana Ciornei <ciorneiioana@gmail.com>
Date:   Wed Oct 14 21:14:13 2015 +0300

    staging: iio: adc: properly indent to match open paranthesis
    
    Indent parameters and arguments passed to function calls to match
    open paranthesis
    
    Signed-off-by: Ioana Ciornei <ciorneiioana@gmail.com>
    Reviewed-by: Daniel Baluta <daniel.baluta@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/iio/adc/ad7280a.c b/drivers/staging/iio/adc/ad7280a.c
index edbfba1c503c..6db764e68c97 100644
--- a/drivers/staging/iio/adc/ad7280a.c
+++ b/drivers/staging/iio/adc/ad7280a.c
@@ -224,24 +224,24 @@ static int ad7280_write(struct ad7280_state *st, unsigned devaddr,
 }
 
 static int ad7280_read(struct ad7280_state *st, unsigned devaddr,
-			unsigned addr)
+		       unsigned addr)
 {
 	int ret;
 	unsigned tmp;
 
 	/* turns off the read operation on all parts */
 	ret = ad7280_write(st, AD7280A_DEVADDR_MASTER, AD7280A_CONTROL_HB, 1,
-			AD7280A_CTRL_HB_CONV_INPUT_ALL |
-			AD7280A_CTRL_HB_CONV_RES_READ_NO |
-			st->ctrl_hb);
+			   AD7280A_CTRL_HB_CONV_INPUT_ALL |
+			   AD7280A_CTRL_HB_CONV_RES_READ_NO |
+			   st->ctrl_hb);
 	if (ret)
 		return ret;
 
 	/* turns on the read operation on the addressed part */
 	ret = ad7280_write(st, devaddr, AD7280A_CONTROL_HB, 0,
-			AD7280A_CTRL_HB_CONV_INPUT_ALL |
-			AD7280A_CTRL_HB_CONV_RES_READ_ALL |
-			st->ctrl_hb);
+			   AD7280A_CTRL_HB_CONV_INPUT_ALL |
+			   AD7280A_CTRL_HB_CONV_RES_READ_ALL |
+			   st->ctrl_hb);
 	if (ret)
 		return ret;
 
@@ -272,17 +272,17 @@ static int ad7280_read_channel(struct ad7280_state *st, unsigned devaddr,
 		return ret;
 
 	ret = ad7280_write(st, AD7280A_DEVADDR_MASTER, AD7280A_CONTROL_HB, 1,
-			AD7280A_CTRL_HB_CONV_INPUT_ALL |
-			AD7280A_CTRL_HB_CONV_RES_READ_NO |
-			st->ctrl_hb);
+			   AD7280A_CTRL_HB_CONV_INPUT_ALL |
+			   AD7280A_CTRL_HB_CONV_RES_READ_NO |
+			   st->ctrl_hb);
 	if (ret)
 		return ret;
 
 	ret = ad7280_write(st, devaddr, AD7280A_CONTROL_HB, 0,
-			AD7280A_CTRL_HB_CONV_INPUT_ALL |
-			AD7280A_CTRL_HB_CONV_RES_READ_ALL |
-			AD7280A_CTRL_HB_CONV_START_CS |
-			st->ctrl_hb);
+			   AD7280A_CTRL_HB_CONV_INPUT_ALL |
+			   AD7280A_CTRL_HB_CONV_RES_READ_ALL |
+			   AD7280A_CTRL_HB_CONV_START_CS |
+			   st->ctrl_hb);
 	if (ret)
 		return ret;
 
@@ -300,7 +300,7 @@ static int ad7280_read_channel(struct ad7280_state *st, unsigned devaddr,
 }
 
 static int ad7280_read_all_channels(struct ad7280_state *st, unsigned cnt,
-			     unsigned *array)
+				    unsigned *array)
 {
 	int i, ret;
 	unsigned tmp, sum = 0;
@@ -311,10 +311,10 @@ static int ad7280_read_all_channels(struct ad7280_state *st, unsigned cnt,
 		return ret;
 
 	ret = ad7280_write(st, AD7280A_DEVADDR_MASTER, AD7280A_CONTROL_HB, 1,
-			AD7280A_CTRL_HB_CONV_INPUT_ALL |
-			AD7280A_CTRL_HB_CONV_RES_READ_ALL |
-			AD7280A_CTRL_HB_CONV_START_CS |
-			st->ctrl_hb);
+			   AD7280A_CTRL_HB_CONV_INPUT_ALL |
+			   AD7280A_CTRL_HB_CONV_RES_READ_ALL |
+			   AD7280A_CTRL_HB_CONV_START_CS |
+			   st->ctrl_hb);
 	if (ret)
 		return ret;
 
@@ -342,24 +342,24 @@ static int ad7280_chain_setup(struct ad7280_state *st)
 	int ret;
 
 	ret = ad7280_write(st, AD7280A_DEVADDR_MASTER, AD7280A_CONTROL_LB, 1,
-			AD7280A_CTRL_LB_DAISY_CHAIN_RB_EN |
-			AD7280A_CTRL_LB_LOCK_DEV_ADDR |
-			AD7280A_CTRL_LB_MUST_SET |
-			AD7280A_CTRL_LB_SWRST |
-			st->ctrl_lb);
+			   AD7280A_CTRL_LB_DAISY_CHAIN_RB_EN |
+			   AD7280A_CTRL_LB_LOCK_DEV_ADDR |
+			   AD7280A_CTRL_LB_MUST_SET |
+			   AD7280A_CTRL_LB_SWRST |
+			   st->ctrl_lb);
 	if (ret)
 		return ret;
 
 	ret = ad7280_write(st, AD7280A_DEVADDR_MASTER, AD7280A_CONTROL_LB, 1,
-			AD7280A_CTRL_LB_DAISY_CHAIN_RB_EN |
-			AD7280A_CTRL_LB_LOCK_DEV_ADDR |
-			AD7280A_CTRL_LB_MUST_SET |
-			st->ctrl_lb);
+			   AD7280A_CTRL_LB_DAISY_CHAIN_RB_EN |
+			   AD7280A_CTRL_LB_LOCK_DEV_ADDR |
+			   AD7280A_CTRL_LB_MUST_SET |
+			   st->ctrl_lb);
 	if (ret)
 		return ret;
 
 	ret = ad7280_write(st, AD7280A_DEVADDR_MASTER, AD7280A_READ, 1,
-			AD7280A_CONTROL_LB << 2);
+			   AD7280A_CONTROL_LB << 2);
 	if (ret)
 		return ret;
 
@@ -379,8 +379,8 @@ static int ad7280_chain_setup(struct ad7280_state *st)
 }
 
 static ssize_t ad7280_show_balance_sw(struct device *dev,
-					struct device_attribute *attr,
-					char *buf)
+				      struct device_attribute *attr,
+				      char *buf)
 {
 	struct iio_dev *indio_dev = dev_to_iio_dev(dev);
 	struct ad7280_state *st = iio_priv(indio_dev);
@@ -392,9 +392,9 @@ static ssize_t ad7280_show_balance_sw(struct device *dev,
 }
 
 static ssize_t ad7280_store_balance_sw(struct device *dev,
-					 struct device_attribute *attr,
-					 const char *buf,
-					 size_t len)
+				       struct device_attribute *attr,
+				       const char *buf,
+				       size_t len)
 {
 	struct iio_dev *indio_dev = dev_to_iio_dev(dev);
 	struct ad7280_state *st = iio_priv(indio_dev);
@@ -424,8 +424,8 @@ static ssize_t ad7280_store_balance_sw(struct device *dev,
 }
 
 static ssize_t ad7280_show_balance_timer(struct device *dev,
-					struct device_attribute *attr,
-					char *buf)
+					 struct device_attribute *attr,
+					 char *buf)
 {
 	struct iio_dev *indio_dev = dev_to_iio_dev(dev);
 	struct ad7280_state *st = iio_priv(indio_dev);
@@ -435,7 +435,7 @@ static ssize_t ad7280_show_balance_timer(struct device *dev,
 
 	mutex_lock(&indio_dev->mlock);
 	ret = ad7280_read(st, this_attr->address >> 8,
-			this_attr->address & 0xFF);
+			  this_attr->address & 0xFF);
 	mutex_unlock(&indio_dev->mlock);
 
 	if (ret < 0)
@@ -447,9 +447,9 @@ static ssize_t ad7280_show_balance_timer(struct device *dev,
 }
 
 static ssize_t ad7280_store_balance_timer(struct device *dev,
-					 struct device_attribute *attr,
-					 const char *buf,
-					 size_t len)
+					  struct device_attribute *attr,
+					  const char *buf,
+					  size_t len)
 {
 	struct iio_dev *indio_dev = dev_to_iio_dev(dev);
 	struct ad7280_state *st = iio_priv(indio_dev);
@@ -492,8 +492,8 @@ static int ad7280_channel_init(struct ad7280_state *st)
 		return -ENOMEM;
 
 	for (dev = 0, cnt = 0; dev <= st->slave_num; dev++)
-		for (ch = AD7280A_CELL_VOLTAGE_1; ch <= AD7280A_AUX_ADC_6; ch++,
-			cnt++) {
+		for (ch = AD7280A_CELL_VOLTAGE_1; ch <= AD7280A_AUX_ADC_6;
+			ch++, cnt++) {
 			if (ch < AD7280A_AUX_ADC_1) {
 				st->channels[cnt].type = IIO_VOLTAGE;
 				st->channels[cnt].differential = 1;
@@ -566,9 +566,9 @@ static int ad7280_attr_init(struct ad7280_state *st)
 				ad7280_store_balance_sw;
 			st->iio_attr[cnt].dev_attr.attr.name =
 				kasprintf(GFP_KERNEL,
-					"in%d-in%d_balance_switch_en",
-					(dev * AD7280A_CELLS_PER_DEV) + ch,
-					(dev * AD7280A_CELLS_PER_DEV) + ch + 1);
+					  "in%d-in%d_balance_switch_en",
+					  dev * AD7280A_CELLS_PER_DEV + ch,
+					  dev * AD7280A_CELLS_PER_DEV + ch + 1);
 			ad7280_attributes[cnt] =
 				&st->iio_attr[cnt].dev_attr.attr;
 			cnt++;
@@ -582,9 +582,10 @@ static int ad7280_attr_init(struct ad7280_state *st)
 			st->iio_attr[cnt].dev_attr.store =
 				ad7280_store_balance_timer;
 			st->iio_attr[cnt].dev_attr.attr.name =
-				kasprintf(GFP_KERNEL, "in%d-in%d_balance_timer",
-					(dev * AD7280A_CELLS_PER_DEV) + ch,
-					(dev * AD7280A_CELLS_PER_DEV) + ch + 1);
+				kasprintf(GFP_KERNEL,
+					  "in%d-in%d_balance_timer",
+					  dev * AD7280A_CELLS_PER_DEV + ch,
+					  dev * AD7280A_CELLS_PER_DEV + ch + 1);
 			ad7280_attributes[cnt] =
 				&st->iio_attr[cnt].dev_attr.attr;
 		}
@@ -595,8 +596,8 @@ static int ad7280_attr_init(struct ad7280_state *st)
 }
 
 static ssize_t ad7280_read_channel_config(struct device *dev,
-					struct device_attribute *attr,
-					char *buf)
+					  struct device_attribute *attr,
+					  char *buf)
 {
 	struct iio_dev *indio_dev = dev_to_iio_dev(dev);
 	struct ad7280_state *st = iio_priv(indio_dev);
@@ -624,9 +625,9 @@ static ssize_t ad7280_read_channel_config(struct device *dev,
 }
 
 static ssize_t ad7280_write_channel_config(struct device *dev,
-					 struct device_attribute *attr,
-					 const char *buf,
-					 size_t len)
+					   struct device_attribute *attr,
+					   const char *buf,
+					   size_t len)
 {
 	struct iio_dev *indio_dev = dev_to_iio_dev(dev);
 	struct ad7280_state *st = iio_priv(indio_dev);
@@ -698,39 +699,41 @@ static irqreturn_t ad7280_event_handler(int irq, void *private)
 			if (((channels[i] >> 11) & 0xFFF) >=
 				st->cell_threshhigh)
 				iio_push_event(indio_dev,
-					IIO_EVENT_CODE(IIO_VOLTAGE,
-						       1,
-						       0,
-						       IIO_EV_DIR_RISING,
-						       IIO_EV_TYPE_THRESH,
-						       0, 0, 0),
-					iio_get_time_ns());
+					       IIO_EVENT_CODE(IIO_VOLTAGE,
+							1,
+							0,
+							IIO_EV_DIR_RISING,
+							IIO_EV_TYPE_THRESH,
+							0, 0, 0),
+					       iio_get_time_ns());
 			else if (((channels[i] >> 11) & 0xFFF) <=
 				st->cell_threshlow)
 				iio_push_event(indio_dev,
-					IIO_EVENT_CODE(IIO_VOLTAGE,
-						       1,
-						       0,
-						       IIO_EV_DIR_FALLING,
-						       IIO_EV_TYPE_THRESH,
-						       0, 0, 0),
-					iio_get_time_ns());
+					       IIO_EVENT_CODE(IIO_VOLTAGE,
+							1,
+							0,
+							IIO_EV_DIR_FALLING,
+							IIO_EV_TYPE_THRESH,
+							0, 0, 0),
+					       iio_get_time_ns());
 		} else {
 			if (((channels[i] >> 11) & 0xFFF) >= st->aux_threshhigh)
 				iio_push_event(indio_dev,
-					IIO_UNMOD_EVENT_CODE(IIO_TEMP,
-					0,
-					IIO_EV_TYPE_THRESH,
-					IIO_EV_DIR_RISING),
-					iio_get_time_ns());
+					       IIO_UNMOD_EVENT_CODE(
+							IIO_TEMP,
+							0,
+							IIO_EV_TYPE_THRESH,
+							IIO_EV_DIR_RISING),
+					       iio_get_time_ns());
 			else if (((channels[i] >> 11) & 0xFFF) <=
 				st->aux_threshlow)
 				iio_push_event(indio_dev,
-					IIO_UNMOD_EVENT_CODE(IIO_TEMP,
-					0,
-					IIO_EV_TYPE_THRESH,
-					IIO_EV_DIR_FALLING),
-					iio_get_time_ns());
+					       IIO_UNMOD_EVENT_CODE(
+							IIO_TEMP,
+							0,
+							IIO_EV_TYPE_THRESH,
+							IIO_EV_DIR_FALLING),
+					       iio_get_time_ns());
 		}
 	}
 
@@ -955,7 +958,7 @@ static int ad7280_remove(struct spi_device *spi)
 	iio_device_unregister(indio_dev);
 
 	ad7280_write(st, AD7280A_DEVADDR_MASTER, AD7280A_CONTROL_HB, 1,
-			AD7280A_CTRL_HB_PWRDN_SW | st->ctrl_hb);
+		     AD7280A_CTRL_HB_PWRDN_SW | st->ctrl_hb);
 
 	kfree(st->channels);
 	kfree(st->iio_attr);

commit 3a1d9489e92a4dd93f6f070aa7e9062beed94c69
Author: Shraddha Barke <shraddha.6596@gmail.com>
Date:   Tue Oct 13 21:07:48 2015 +0530

    Staging: iio: Remove exceptional & on function name
    
    In this file, function names are otherwise used as pointers without &.
    
    A simplified version of the Coccinelle semantic patch that makes this
    change is as follows:
    
    // <smpl>
    @r@
    identifier f;
    @@
    
    f(...) { ... }
    @@
    identifier r.f;
    @@
    
    - &f
    + f
    // </smpl>
    
    Signed-off-by: Shraddha Barke <shraddha.6596@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/iio/adc/ad7280a.c b/drivers/staging/iio/adc/ad7280a.c
index d98e229c46bf..edbfba1c503c 100644
--- a/drivers/staging/iio/adc/ad7280a.c
+++ b/drivers/staging/iio/adc/ad7280a.c
@@ -817,7 +817,7 @@ static int ad7280_read_raw(struct iio_dev *indio_dev,
 }
 
 static const struct iio_info ad7280_info = {
-	.read_raw = &ad7280_read_raw,
+	.read_raw = ad7280_read_raw,
 	.event_attrs = &ad7280_event_attrs_group,
 	.attrs = &ad7280_attrs_group,
 	.driver_module = THIS_MODULE,

commit 418880f5708dec9fdb2eaa7a61175fa1d8ab4110
Author: Haneen Mohammed <hamohammed.sa@gmail.com>
Date:   Thu Mar 26 02:23:29 2015 +0300

    Staging: iio: use the BIT macro in adc
    
    This patch replaces bit shifting on:
    0,1,2, and 3 with the BIT(x) macro.
    Issue addressed by checkpatcg.pl.
    This was done with the help of Coccinelle:
    
    @r1@
    identifier x;
    constant int g;
    @@
    
    (
    0<<\(x\|g\)
    |
    1<<\(x\|g\)
    |
    2<<\(x\|g\)
    |
    3<<\(x\|g\)
    )
    
    @script:python b@
    g2 <<r1.g;
    y;
    @@
    coccinelle.y = int(g2) + 1
    
    @c@
    constant int r1.g;
    identifier b.y;
    @@
    (
    -(1 << g)
    +BIT(g)
    |
    -(0 << g)
    + 0
    |
    -(2 << g)
    +BIT(y)
    |
    -(3 << g)
    +(BIT(y)| BIT(g))
    )
    
    Signed-off-by: Haneen Mohammed <hamohammed.sa@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/iio/adc/ad7280a.c b/drivers/staging/iio/adc/ad7280a.c
index e7d45ee2fac6..d98e229c46bf 100644
--- a/drivers/staging/iio/adc/ad7280a.c
+++ b/drivers/staging/iio/adc/ad7280a.c
@@ -55,37 +55,37 @@
 #define AD7280A_CNVST_CONTROL		0x1D /* D7 to D0, Read/write */
 
 /* Bits and Masks */
-#define AD7280A_CTRL_HB_CONV_INPUT_ALL			(0 << 6)
-#define AD7280A_CTRL_HB_CONV_INPUT_6CELL_AUX1_3_4	(1 << 6)
-#define AD7280A_CTRL_HB_CONV_INPUT_6CELL		(2 << 6)
-#define AD7280A_CTRL_HB_CONV_INPUT_SELF_TEST		(3 << 6)
-#define AD7280A_CTRL_HB_CONV_RES_READ_ALL		(0 << 4)
-#define AD7280A_CTRL_HB_CONV_RES_READ_6CELL_AUX1_3_4	(1 << 4)
-#define AD7280A_CTRL_HB_CONV_RES_READ_6CELL		(2 << 4)
-#define AD7280A_CTRL_HB_CONV_RES_READ_NO		(3 << 4)
-#define AD7280A_CTRL_HB_CONV_START_CNVST		(0 << 3)
-#define AD7280A_CTRL_HB_CONV_START_CS			(1 << 3)
-#define AD7280A_CTRL_HB_CONV_AVG_DIS			(0 << 1)
-#define AD7280A_CTRL_HB_CONV_AVG_2			(1 << 1)
-#define AD7280A_CTRL_HB_CONV_AVG_4			(2 << 1)
-#define AD7280A_CTRL_HB_CONV_AVG_8			(3 << 1)
+#define AD7280A_CTRL_HB_CONV_INPUT_ALL			0
+#define AD7280A_CTRL_HB_CONV_INPUT_6CELL_AUX1_3_4	BIT(6)
+#define AD7280A_CTRL_HB_CONV_INPUT_6CELL		BIT(7)
+#define AD7280A_CTRL_HB_CONV_INPUT_SELF_TEST		(BIT(7) | BIT(6))
+#define AD7280A_CTRL_HB_CONV_RES_READ_ALL		0
+#define AD7280A_CTRL_HB_CONV_RES_READ_6CELL_AUX1_3_4	BIT(4)
+#define AD7280A_CTRL_HB_CONV_RES_READ_6CELL		BIT(5)
+#define AD7280A_CTRL_HB_CONV_RES_READ_NO		(BIT(5) | BIT(4))
+#define AD7280A_CTRL_HB_CONV_START_CNVST		0
+#define AD7280A_CTRL_HB_CONV_START_CS			BIT(3)
+#define AD7280A_CTRL_HB_CONV_AVG_DIS			0
+#define AD7280A_CTRL_HB_CONV_AVG_2			BIT(1)
+#define AD7280A_CTRL_HB_CONV_AVG_4			BIT(2)
+#define AD7280A_CTRL_HB_CONV_AVG_8			(BIT(2) | BIT(1))
 #define AD7280A_CTRL_HB_CONV_AVG(x)			((x) << 1)
-#define AD7280A_CTRL_HB_PWRDN_SW			(1 << 0)
+#define AD7280A_CTRL_HB_PWRDN_SW			BIT(0)
 
-#define AD7280A_CTRL_LB_SWRST				(1 << 7)
-#define AD7280A_CTRL_LB_ACQ_TIME_400ns			(0 << 5)
-#define AD7280A_CTRL_LB_ACQ_TIME_800ns			(1 << 5)
-#define AD7280A_CTRL_LB_ACQ_TIME_1200ns			(2 << 5)
-#define AD7280A_CTRL_LB_ACQ_TIME_1600ns			(3 << 5)
+#define AD7280A_CTRL_LB_SWRST				BIT(7)
+#define AD7280A_CTRL_LB_ACQ_TIME_400ns			0
+#define AD7280A_CTRL_LB_ACQ_TIME_800ns			BIT(5)
+#define AD7280A_CTRL_LB_ACQ_TIME_1200ns			BIT(6)
+#define AD7280A_CTRL_LB_ACQ_TIME_1600ns			(BIT(6) | BIT(5))
 #define AD7280A_CTRL_LB_ACQ_TIME(x)			((x) << 5)
-#define AD7280A_CTRL_LB_MUST_SET			(1 << 4)
-#define AD7280A_CTRL_LB_THERMISTOR_EN			(1 << 3)
-#define AD7280A_CTRL_LB_LOCK_DEV_ADDR			(1 << 2)
-#define AD7280A_CTRL_LB_INC_DEV_ADDR			(1 << 1)
-#define AD7280A_CTRL_LB_DAISY_CHAIN_RB_EN		(1 << 0)
-
-#define AD7280A_ALERT_GEN_STATIC_HIGH			(1 << 6)
-#define AD7280A_ALERT_RELAY_SIG_CHAIN_DOWN		(3 << 6)
+#define AD7280A_CTRL_LB_MUST_SET			BIT(4)
+#define AD7280A_CTRL_LB_THERMISTOR_EN			BIT(3)
+#define AD7280A_CTRL_LB_LOCK_DEV_ADDR			BIT(2)
+#define AD7280A_CTRL_LB_INC_DEV_ADDR			BIT(1)
+#define AD7280A_CTRL_LB_DAISY_CHAIN_RB_EN		BIT(0)
+
+#define AD7280A_ALERT_GEN_STATIC_HIGH			BIT(6)
+#define AD7280A_ALERT_RELAY_SIG_CHAIN_DOWN		(BIT(7) | BIT(6))
 
 #define AD7280A_ALL_CELLS				(0xAD << 16)
 

commit 7e026b647b27d3dc170bd335d5e9c4a6f45323ff
Author: Navya Sri Nizamkari <navyasri.tech@gmail.com>
Date:   Tue Mar 10 17:32:50 2015 +0530

    staging: iio: Use kcalloc instead of kzalloc.
    
    This patch uses kcalloc instead of kzalloc function.
    A coccinelle script was used to make this change.
    
    Signed-off-by: Navya Sri Nizamkari <navyasri.tech@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/iio/adc/ad7280a.c b/drivers/staging/iio/adc/ad7280a.c
index 4d4870787eed..e7d45ee2fac6 100644
--- a/drivers/staging/iio/adc/ad7280a.c
+++ b/drivers/staging/iio/adc/ad7280a.c
@@ -547,8 +547,9 @@ static int ad7280_attr_init(struct ad7280_state *st)
 {
 	int dev, ch, cnt;
 
-	st->iio_attr = kzalloc(sizeof(*st->iio_attr) * (st->slave_num + 1) *
-				AD7280A_CELLS_PER_DEV * 2, GFP_KERNEL);
+	st->iio_attr = kcalloc(2, sizeof(*st->iio_attr) *
+			       (st->slave_num + 1) * AD7280A_CELLS_PER_DEV,
+			       GFP_KERNEL);
 	if (st->iio_attr == NULL)
 		return -ENOMEM;
 

commit e3fe42b149c4c8ee13ade4112ed38e6d9a85c7b7
Author: Vaishali Thakkar <vthakkar1994@gmail.com>
Date:   Fri Oct 3 09:16:53 2014 +0530

    Staging: iio: adc: Refine delay computation
    
    As per comment in function ad7280_delay, conversion delay may take up
    to 250us. We cannot rely on msleep for this because it may sleep longer
    than intended time for values less than 20ms, so use usleep_range instead.
    
    Problem detected using checkpatch.pl.
    
    Signed-off-by: Vaishali Thakkar <vthakkar1994@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/iio/adc/ad7280a.c b/drivers/staging/iio/adc/ad7280a.c
index d215edf66af2..4d4870787eed 100644
--- a/drivers/staging/iio/adc/ad7280a.c
+++ b/drivers/staging/iio/adc/ad7280a.c
@@ -188,7 +188,7 @@ static void ad7280_delay(struct ad7280_state *st)
 	if (st->readback_delay_us < 50)
 		udelay(st->readback_delay_us);
 	else
-		msleep(1);
+		usleep_range(250, 500);
 }
 
 static int __ad7280_read32(struct ad7280_state *st, unsigned *val)

commit fd8122d12858132aa9684f2b979107a1f4bba139
Author: Masanari Iida <standby24x7@gmail.com>
Date:   Mon Apr 28 17:00:00 2014 +0100

    staging: iio: Fix format string mismatch in ad7280a.c
    
    Fix two format string mismatch in ad7280a.c
    
    Signed-off-by: Masanari Iida <standby24x7@gmail.com>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/staging/iio/adc/ad7280a.c b/drivers/staging/iio/adc/ad7280a.c
index 1ac11f64827c..d215edf66af2 100644
--- a/drivers/staging/iio/adc/ad7280a.c
+++ b/drivers/staging/iio/adc/ad7280a.c
@@ -443,7 +443,7 @@ static ssize_t ad7280_show_balance_timer(struct device *dev,
 
 	msecs = (ret >> 3) * 71500;
 
-	return sprintf(buf, "%d\n", msecs);
+	return sprintf(buf, "%u\n", msecs);
 }
 
 static ssize_t ad7280_store_balance_timer(struct device *dev,
@@ -619,7 +619,7 @@ static ssize_t ad7280_read_channel_config(struct device *dev,
 		return -EINVAL;
 	}
 
-	return sprintf(buf, "%d\n", val);
+	return sprintf(buf, "%u\n", val);
 }
 
 static ssize_t ad7280_write_channel_config(struct device *dev,

commit 93dbad639d93300977ed76acc0db20771cca98f7
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Mon Nov 25 12:42:00 2013 +0000

    staging:iio:ad7280a: Do not store transfer buffer on the stack
    
    Some I2C controllers may not be able to handle transfer buffers that are placed
    on the stack.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/staging/iio/adc/ad7280a.c b/drivers/staging/iio/adc/ad7280a.c
index 89ee65bdc279..1ac11f64827c 100644
--- a/drivers/staging/iio/adc/ad7280a.c
+++ b/drivers/staging/iio/adc/ad7280a.c
@@ -134,6 +134,8 @@ struct ad7280_state {
 	unsigned char			aux_threshhigh;
 	unsigned char			aux_threshlow;
 	unsigned char			cb_mask[AD7280A_MAX_CHAIN];
+
+	__be32				buf[2] ____cacheline_aligned;
 };
 
 static void ad7280_crc8_build_table(unsigned char *crc_tab)
@@ -189,22 +191,22 @@ static void ad7280_delay(struct ad7280_state *st)
 		msleep(1);
 }
 
-static int __ad7280_read32(struct spi_device *spi, unsigned *val)
+static int __ad7280_read32(struct ad7280_state *st, unsigned *val)
 {
-	__be32 rx_buf, tx_buf = cpu_to_be32(AD7280A_READ_TXVAL);
 	int ret;
-
 	struct spi_transfer t = {
-		.tx_buf	= &tx_buf,
-		.rx_buf = &rx_buf,
+		.tx_buf	= &st->buf[0],
+		.rx_buf = &st->buf[1],
 		.len = 4,
 	};
 
-	ret = spi_sync_transfer(spi, &t, 1);
+	st->buf[0] = cpu_to_be32(AD7280A_READ_TXVAL);
+
+	ret = spi_sync_transfer(st->spi, &t, 1);
 	if (ret)
 		return ret;
 
-	*val = be32_to_cpu(rx_buf);
+	*val = be32_to_cpu(st->buf[1]);
 
 	return 0;
 }
@@ -214,12 +216,11 @@ static int ad7280_write(struct ad7280_state *st, unsigned devaddr,
 {
 	unsigned reg = (devaddr << 27 | addr << 21 |
 			(val & 0xFF) << 13 | all << 12);
-	__be32 tx_buf;
 
 	reg |= ad7280_calc_crc8(st->crc_tab, reg >> 11) << 3 | 0x2;
-	tx_buf = cpu_to_be32(reg);
+	st->buf[0] = cpu_to_be32(reg);
 
-	return spi_write(st->spi, &tx_buf, 4);
+	return spi_write(st->spi, &st->buf[0], 4);
 }
 
 static int ad7280_read(struct ad7280_state *st, unsigned devaddr,
@@ -249,7 +250,7 @@ static int ad7280_read(struct ad7280_state *st, unsigned devaddr,
 	if (ret)
 		return ret;
 
-	__ad7280_read32(st->spi, &tmp);
+	__ad7280_read32(st, &tmp);
 
 	if (ad7280_check_crc(st, tmp))
 		return -EIO;
@@ -287,7 +288,7 @@ static int ad7280_read_channel(struct ad7280_state *st, unsigned devaddr,
 
 	ad7280_delay(st);
 
-	__ad7280_read32(st->spi, &tmp);
+	__ad7280_read32(st, &tmp);
 
 	if (ad7280_check_crc(st, tmp))
 		return -EIO;
@@ -320,7 +321,7 @@ static int ad7280_read_all_channels(struct ad7280_state *st, unsigned cnt,
 	ad7280_delay(st);
 
 	for (i = 0; i < cnt; i++) {
-		__ad7280_read32(st->spi, &tmp);
+		__ad7280_read32(st, &tmp);
 
 		if (ad7280_check_crc(st, tmp))
 			return -EIO;
@@ -363,7 +364,7 @@ static int ad7280_chain_setup(struct ad7280_state *st)
 		return ret;
 
 	for (n = 0; n <= AD7280A_MAX_CHAIN; n++) {
-		__ad7280_read32(st->spi, &val);
+		__ad7280_read32(st, &val);
 		if (val == 0)
 			return n - 1;
 

commit b39c47d1930191120d290e664740ba7ae04d0134
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Mon Nov 25 12:42:00 2013 +0000

    staging:iio:ad7280a: Mark transfer buffer as __be32
    
    Fixes the following warnings from sparse:
            drivers/staging/iio/adc/ad7280a.c:194:35: warning: incorrect type in initializer (different base types)
            drivers/staging/iio/adc/ad7280a.c:194:35:    expected unsigned int [unsigned] tx_buf
            drivers/staging/iio/adc/ad7280a.c:194:35:    got restricted __be32 [usertype] <noident>
            drivers/staging/iio/adc/ad7280a.c:207:16: warning: cast to restricted __be32
            drivers/staging/iio/adc/ad7280a.c:207:16: warning: cast to restricted __be32
            drivers/staging/iio/adc/ad7280a.c:207:16: warning: cast to restricted __be32
            drivers/staging/iio/adc/ad7280a.c:207:16: warning: cast to restricted __be32
            drivers/staging/iio/adc/ad7280a.c:207:16: warning: cast to restricted __be32
            drivers/staging/iio/adc/ad7280a.c:207:16: warning: cast to restricted __be32
            drivers/staging/iio/adc/ad7280a.c:219:13: warning: incorrect type in assignment (different base types)
            drivers/staging/iio/adc/ad7280a.c:219:13:    expected unsigned int [unsigned] [assigned] reg
            drivers/staging/iio/adc/ad7280a.c:219:13:    got restricted __be32 [usertype] <noident>
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/staging/iio/adc/ad7280a.c b/drivers/staging/iio/adc/ad7280a.c
index 8209fa542a8a..89ee65bdc279 100644
--- a/drivers/staging/iio/adc/ad7280a.c
+++ b/drivers/staging/iio/adc/ad7280a.c
@@ -191,7 +191,7 @@ static void ad7280_delay(struct ad7280_state *st)
 
 static int __ad7280_read32(struct spi_device *spi, unsigned *val)
 {
-	unsigned rx_buf, tx_buf = cpu_to_be32(AD7280A_READ_TXVAL);
+	__be32 rx_buf, tx_buf = cpu_to_be32(AD7280A_READ_TXVAL);
 	int ret;
 
 	struct spi_transfer t = {
@@ -214,11 +214,12 @@ static int ad7280_write(struct ad7280_state *st, unsigned devaddr,
 {
 	unsigned reg = (devaddr << 27 | addr << 21 |
 			(val & 0xFF) << 13 | all << 12);
+	__be32 tx_buf;
 
 	reg |= ad7280_calc_crc8(st->crc_tab, reg >> 11) << 3 | 0x2;
-	reg = cpu_to_be32(reg);
+	tx_buf = cpu_to_be32(reg);
 
-	return spi_write(st->spi, &reg, 4);
+	return spi_write(st->spi, &tx_buf, 4);
 }
 
 static int ad7280_read(struct ad7280_state *st, unsigned devaddr,

commit d6570b33a1c0620774fe693030ef9e0317dafd84
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Sat Sep 28 10:31:00 2013 +0100

    staging:iio:ad7280a: Report scale as fractional value
    
    Move the complexity of calculating the fixed point scale to the core.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/staging/iio/adc/ad7280a.c b/drivers/staging/iio/adc/ad7280a.c
index e7191e44a970..8209fa542a8a 100644
--- a/drivers/staging/iio/adc/ad7280a.c
+++ b/drivers/staging/iio/adc/ad7280a.c
@@ -783,7 +783,6 @@ static int ad7280_read_raw(struct iio_dev *indio_dev,
 			   long m)
 {
 	struct ad7280_state *st = iio_priv(indio_dev);
-	unsigned int scale_uv;
 	int ret;
 
 	switch (m) {
@@ -804,13 +803,12 @@ static int ad7280_read_raw(struct iio_dev *indio_dev,
 		return IIO_VAL_INT;
 	case IIO_CHAN_INFO_SCALE:
 		if ((chan->address & 0xFF) <= AD7280A_CELL_VOLTAGE_6)
-			scale_uv = (4000 * 1000) >> AD7280A_BITS;
+			*val = 4000;
 		else
-			scale_uv = (5000 * 1000) >> AD7280A_BITS;
+			*val = 5000;
 
-		*val =  scale_uv / 1000;
-		*val2 = (scale_uv % 1000) * 1000;
-		return IIO_VAL_INT_PLUS_MICRO;
+		*val2 = AD7280A_BITS;
+		return IIO_VAL_FRACTIONAL_LOG2;
 	}
 	return -EINVAL;
 }

commit 0a2f0265b6dabab8342ac3374bcb47340d654e08
Author: Sachin Kamat <sachin.kamat@linaro.org>
Date:   Sat Aug 31 18:12:00 2013 +0100

    staging: iio: ad7280a: Use devm_iio_device_alloc
    
    devm_iio_device_alloc makes code simpler.
    
    Signed-off-by: Sachin Kamat <sachin.kamat@linaro.org>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/staging/iio/adc/ad7280a.c b/drivers/staging/iio/adc/ad7280a.c
index c19618bc37c4..e7191e44a970 100644
--- a/drivers/staging/iio/adc/ad7280a.c
+++ b/drivers/staging/iio/adc/ad7280a.c
@@ -835,8 +835,9 @@ static int ad7280_probe(struct spi_device *spi)
 	int ret;
 	const unsigned short tACQ_ns[4] = {465, 1010, 1460, 1890};
 	const unsigned short nAVG[4] = {1, 2, 4, 8};
-	struct iio_dev *indio_dev = iio_device_alloc(sizeof(*st));
+	struct iio_dev *indio_dev;
 
+	indio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*st));
 	if (indio_dev == NULL)
 		return -ENOMEM;
 
@@ -860,7 +861,7 @@ static int ad7280_probe(struct spi_device *spi)
 
 	ret = ad7280_chain_setup(st);
 	if (ret < 0)
-		goto error_free_device;
+		return ret;
 
 	st->slave_num = ret;
 	st->scan_cnt = (st->slave_num + 1) * AD7280A_NUM_CH;
@@ -891,7 +892,7 @@ static int ad7280_probe(struct spi_device *spi)
 
 	ret = ad7280_channel_init(st);
 	if (ret < 0)
-		goto error_free_device;
+		return ret;
 
 	indio_dev->num_channels = ret;
 	indio_dev->channels = st->channels;
@@ -940,9 +941,6 @@ static int ad7280_probe(struct spi_device *spi)
 error_free_channels:
 	kfree(st->channels);
 
-error_free_device:
-	iio_device_free(indio_dev);
-
 	return ret;
 }
 
@@ -960,7 +958,6 @@ static int ad7280_remove(struct spi_device *spi)
 
 	kfree(st->channels);
 	kfree(st->iio_attr);
-	iio_device_free(indio_dev);
 
 	return 0;
 }

commit f86f83622fe2c45d75f83a7db8d170da55b5b476
Author: Aida Mynzhasova <ai.c.c0der@gmail.com>
Date:   Tue May 7 00:04:41 2013 +0400

    staging:iio:adc: Use kstrtol()/kstrtoul()
    
    Replace deprecated strict_strtol()/strict_strtoul() with
    kstrtol()/kstrtoul(). Add missing checks for conversion return codes.
    
    Signed-off-by: Aida Mynzhasova <ai.c.c0der@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/iio/adc/ad7280a.c b/drivers/staging/iio/adc/ad7280a.c
index 2fd6ee3c1902..c19618bc37c4 100644
--- a/drivers/staging/iio/adc/ad7280a.c
+++ b/drivers/staging/iio/adc/ad7280a.c
@@ -632,7 +632,7 @@ static ssize_t ad7280_write_channel_config(struct device *dev,
 	long val;
 	int ret;
 
-	ret = strict_strtol(buf, 10, &val);
+	ret = kstrtol(buf, 10, &val);
 	if (ret)
 		return ret;
 

commit 4ff30e0a0c63670e1af7635dc0659bc74c2ffe13
Author: Jonathan Cameron <jic23@kernel.org>
Date:   Wed Feb 27 19:37:07 2013 +0000

    staging:iio:adc:ad7280a move to info_mask_(shared_by_type/separate)
    
    The original info_mask is going away in favour of the broken out versions.
    
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>
    Acked-by: Lars-Peter Clausen <lars@metafoo.de>

diff --git a/drivers/staging/iio/adc/ad7280a.c b/drivers/staging/iio/adc/ad7280a.c
index 1f190c1b12a6..2fd6ee3c1902 100644
--- a/drivers/staging/iio/adc/ad7280a.c
+++ b/drivers/staging/iio/adc/ad7280a.c
@@ -503,9 +503,10 @@ static int ad7280_channel_init(struct ad7280_state *st)
 				st->channels[cnt].channel = (dev * 6) + ch - 6;
 			}
 			st->channels[cnt].indexed = 1;
-			st->channels[cnt].info_mask =
-				IIO_CHAN_INFO_RAW_SEPARATE_BIT |
-				IIO_CHAN_INFO_SCALE_SHARED_BIT;
+			st->channels[cnt].info_mask_separate =
+				BIT(IIO_CHAN_INFO_RAW);
+			st->channels[cnt].info_mask_shared_by_type =
+				BIT(IIO_CHAN_INFO_SCALE);
 			st->channels[cnt].address =
 				AD7280A_DEVADDR(dev) << 8 | ch;
 			st->channels[cnt].scan_index = cnt;
@@ -521,9 +522,8 @@ static int ad7280_channel_init(struct ad7280_state *st)
 	st->channels[cnt].channel2 = dev * 6;
 	st->channels[cnt].address = AD7280A_ALL_CELLS;
 	st->channels[cnt].indexed = 1;
-	st->channels[cnt].info_mask =
-		IIO_CHAN_INFO_RAW_SEPARATE_BIT |
-		IIO_CHAN_INFO_SCALE_SHARED_BIT;
+	st->channels[cnt].info_mask_separate = BIT(IIO_CHAN_INFO_RAW);
+	st->channels[cnt].info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE);
 	st->channels[cnt].scan_index = cnt;
 	st->channels[cnt].scan_type.sign = 'u';
 	st->channels[cnt].scan_type.realbits = 32;

commit ad6c46b0c712e0d8fd8a80ee372b30f14a781888
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Wed Jan 9 17:31:00 2013 +0000

    staging:iio: Use spi_sync_transfer()
    
    Use the new spi_sync_transfer() helper function instead of open-coding it.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/staging/iio/adc/ad7280a.c b/drivers/staging/iio/adc/ad7280a.c
index fa81a491e790..1f190c1b12a6 100644
--- a/drivers/staging/iio/adc/ad7280a.c
+++ b/drivers/staging/iio/adc/ad7280a.c
@@ -199,12 +199,8 @@ static int __ad7280_read32(struct spi_device *spi, unsigned *val)
 		.rx_buf = &rx_buf,
 		.len = 4,
 	};
-	struct spi_message m;
 
-	spi_message_init(&m);
-	spi_message_add_tail(&t, &m);
-
-	ret = spi_sync(spi, &m);
+	ret = spi_sync_transfer(spi, &t, 1);
 	if (ret)
 		return ret;
 

commit e543acf07db78cfc135e45c4ce0ed26ccf774c37
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Nov 19 13:21:38 2012 -0500

    staging: iio: remove use of __devexit_p
    
    CONFIG_HOTPLUG is going away as an option so __devexit_p is no longer
    needed.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Cc: Jonathan Cameron <jic23@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/iio/adc/ad7280a.c b/drivers/staging/iio/adc/ad7280a.c
index 9b1a095e79c0..fa81a491e790 100644
--- a/drivers/staging/iio/adc/ad7280a.c
+++ b/drivers/staging/iio/adc/ad7280a.c
@@ -981,7 +981,7 @@ static struct spi_driver ad7280_driver = {
 		.owner	= THIS_MODULE,
 	},
 	.probe		= ad7280_probe,
-	.remove		= __devexit_p(ad7280_remove),
+	.remove		= ad7280_remove,
 	.id_table	= ad7280_id,
 };
 module_spi_driver(ad7280_driver);

commit 447d4f29ee3fa62f13c65688bb7b74d5a9a0d767
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Nov 19 13:26:37 2012 -0500

    staging: iio: remove use of __devexit
    
    CONFIG_HOTPLUG is going away as an option so __devexit is no
    longer needed.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Cc: Jonathan Cameron <jic23@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/iio/adc/ad7280a.c b/drivers/staging/iio/adc/ad7280a.c
index 6e9984373efa..9b1a095e79c0 100644
--- a/drivers/staging/iio/adc/ad7280a.c
+++ b/drivers/staging/iio/adc/ad7280a.c
@@ -950,7 +950,7 @@ static int ad7280_probe(struct spi_device *spi)
 	return ret;
 }
 
-static int __devexit ad7280_remove(struct spi_device *spi)
+static int ad7280_remove(struct spi_device *spi)
 {
 	struct iio_dev *indio_dev = spi_get_drvdata(spi);
 	struct ad7280_state *st = iio_priv(indio_dev);

commit 4ae1c61ff2ba4fea4e4c1a045cb1f34520608789
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Mon Nov 19 13:21:57 2012 -0500

    staging: iio: remove use of __devinit
    
    CONFIG_HOTPLUG is going away as an option so __devinit is no longer
    needed.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Cc: Jonathan Cameron <jic23@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/iio/adc/ad7280a.c b/drivers/staging/iio/adc/ad7280a.c
index e7cb3b2fe67f..6e9984373efa 100644
--- a/drivers/staging/iio/adc/ad7280a.c
+++ b/drivers/staging/iio/adc/ad7280a.c
@@ -832,7 +832,7 @@ static const struct ad7280_platform_data ad7793_default_pdata = {
 	.thermistor_term_en = true,
 };
 
-static int __devinit ad7280_probe(struct spi_device *spi)
+static int ad7280_probe(struct spi_device *spi)
 {
 	const struct ad7280_platform_data *pdata = spi->dev.platform_data;
 	struct ad7280_state *st;

commit fad109452e0562e896ee0ede27552931c761b0ad
Author: Kumar Amit Mehta <gmate.amit@gmail.com>
Date:   Fri Nov 2 07:28:00 2012 +0000

    staging: iio: adc: ad7280a.c: fixed macro coding style
    
    remove unnecessary semicolon from the macro definition
    
    Signed-off-by: Kumar Amit Mehta <gmate.amit@gmail.com>
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>

diff --git a/drivers/staging/iio/adc/ad7280a.c b/drivers/staging/iio/adc/ad7280a.c
index cfc39a703126..e7cb3b2fe67f 100644
--- a/drivers/staging/iio/adc/ad7280a.c
+++ b/drivers/staging/iio/adc/ad7280a.c
@@ -117,7 +117,7 @@
  */
 #define POLYNOM		0x2F
 #define POLYNOM_ORDER	8
-#define HIGHBIT		1 << (POLYNOM_ORDER - 1);
+#define HIGHBIT		(1 << (POLYNOM_ORDER - 1))
 
 struct ad7280_state {
 	struct spi_device		*spi;

commit 62c5183971428a559b687fcb15f548df28dbe8dc
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Sat May 12 15:39:42 2012 +0200

    staging:iio:adc: Use dev_to_iio_dev()
    
    Replace open-coded instances of getting a iio_dev struct from a device struct
    with dev_to_iio_dev().
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Acked-by: Jonathan Cameron <jic23@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/iio/adc/ad7280a.c b/drivers/staging/iio/adc/ad7280a.c
index 9c3b66f37395..cfc39a703126 100644
--- a/drivers/staging/iio/adc/ad7280a.c
+++ b/drivers/staging/iio/adc/ad7280a.c
@@ -384,7 +384,7 @@ static ssize_t ad7280_show_balance_sw(struct device *dev,
 					struct device_attribute *attr,
 					char *buf)
 {
-	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct iio_dev *indio_dev = dev_to_iio_dev(dev);
 	struct ad7280_state *st = iio_priv(indio_dev);
 	struct iio_dev_attr *this_attr = to_iio_dev_attr(attr);
 
@@ -398,7 +398,7 @@ static ssize_t ad7280_store_balance_sw(struct device *dev,
 					 const char *buf,
 					 size_t len)
 {
-	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct iio_dev *indio_dev = dev_to_iio_dev(dev);
 	struct ad7280_state *st = iio_priv(indio_dev);
 	struct iio_dev_attr *this_attr = to_iio_dev_attr(attr);
 	bool readin;
@@ -429,7 +429,7 @@ static ssize_t ad7280_show_balance_timer(struct device *dev,
 					struct device_attribute *attr,
 					char *buf)
 {
-	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct iio_dev *indio_dev = dev_to_iio_dev(dev);
 	struct ad7280_state *st = iio_priv(indio_dev);
 	struct iio_dev_attr *this_attr = to_iio_dev_attr(attr);
 	int ret;
@@ -453,7 +453,7 @@ static ssize_t ad7280_store_balance_timer(struct device *dev,
 					 const char *buf,
 					 size_t len)
 {
-	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct iio_dev *indio_dev = dev_to_iio_dev(dev);
 	struct ad7280_state *st = iio_priv(indio_dev);
 	struct iio_dev_attr *this_attr = to_iio_dev_attr(attr);
 	unsigned long val;
@@ -599,7 +599,7 @@ static ssize_t ad7280_read_channel_config(struct device *dev,
 					struct device_attribute *attr,
 					char *buf)
 {
-	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct iio_dev *indio_dev = dev_to_iio_dev(dev);
 	struct ad7280_state *st = iio_priv(indio_dev);
 	struct iio_dev_attr *this_attr = to_iio_dev_attr(attr);
 	unsigned val;
@@ -629,7 +629,7 @@ static ssize_t ad7280_write_channel_config(struct device *dev,
 					 const char *buf,
 					 size_t len)
 {
-	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct iio_dev *indio_dev = dev_to_iio_dev(dev);
 	struct ad7280_state *st = iio_priv(indio_dev);
 	struct iio_dev_attr *this_attr = to_iio_dev_attr(attr);
 

commit 7cbb753701d11f3c71e8543e1ae0fc0772edac06
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Thu Apr 26 13:35:01 2012 +0200

    staging:iio: Streamline API function naming
    
    Currently we use two different naming schemes in the IIO API, iio_verb_object
    and iio_object_verb. E.g iio_device_register and iio_allocate_device. This
    patches renames instances of the later to the former. The patch also renames allocate to
    alloc as this seems to be the preferred form throughout the kernel.
    
    In particular the following renames are performed by the patch:
            iio_put_device -> iio_device_put
            iio_allocate_device -> iio_device_alloc
            iio_free_device -> iio_device_free
            iio_get_trigger -> iio_trigger_get
            iio_put_trigger -> iio_trigger_put
            iio_allocate_trigger -> iio_trigger_alloc
            iio_free_trigger -> iio_trigger_free
    
    The conversion was done with the following coccinelle patch with manual fixes to
    comments and documentation.
    
    <smpl>
    @@
    @@
    -iio_put_device
    +iio_device_put
    @@
    @@
    -iio_allocate_device
    +iio_device_alloc
    @@
    @@
    -iio_free_device
    +iio_device_free
    @@
    @@
    -iio_get_trigger
    +iio_trigger_get
    @@
    @@
    -iio_put_trigger
    +iio_trigger_put
    @@
    @@
    -iio_allocate_trigger
    +iio_trigger_alloc
    @@
    @@
    -iio_free_trigger
    +iio_trigger_free
    </smpl>
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Acked-by: Jonathan Cameron <jic23@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/iio/adc/ad7280a.c b/drivers/staging/iio/adc/ad7280a.c
index d72780f91031..9c3b66f37395 100644
--- a/drivers/staging/iio/adc/ad7280a.c
+++ b/drivers/staging/iio/adc/ad7280a.c
@@ -839,7 +839,7 @@ static int __devinit ad7280_probe(struct spi_device *spi)
 	int ret;
 	const unsigned short tACQ_ns[4] = {465, 1010, 1460, 1890};
 	const unsigned short nAVG[4] = {1, 2, 4, 8};
-	struct iio_dev *indio_dev = iio_allocate_device(sizeof(*st));
+	struct iio_dev *indio_dev = iio_device_alloc(sizeof(*st));
 
 	if (indio_dev == NULL)
 		return -ENOMEM;
@@ -945,7 +945,7 @@ static int __devinit ad7280_probe(struct spi_device *spi)
 	kfree(st->channels);
 
 error_free_device:
-	iio_free_device(indio_dev);
+	iio_device_free(indio_dev);
 
 	return ret;
 }
@@ -964,7 +964,7 @@ static int __devexit ad7280_remove(struct spi_device *spi)
 
 	kfree(st->channels);
 	kfree(st->iio_attr);
-	iio_free_device(indio_dev);
+	iio_device_free(indio_dev);
 
 	return 0;
 }

commit 06458e277eac2b8761b0a04d3c808d57be281a2e
Author: Jonathan Cameron <jic23@kernel.org>
Date:   Wed Apr 25 15:54:58 2012 +0100

    IIO: Move core headers to include/linux/iio
    
    Step 1 in moving the IIO core out of staging.
    
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/iio/adc/ad7280a.c b/drivers/staging/iio/adc/ad7280a.c
index f0c0c72a1b07..d72780f91031 100644
--- a/drivers/staging/iio/adc/ad7280a.c
+++ b/drivers/staging/iio/adc/ad7280a.c
@@ -16,9 +16,9 @@
 #include <linux/interrupt.h>
 #include <linux/module.h>
 
-#include "../iio.h"
-#include "../sysfs.h"
-#include "../events.h"
+#include <linux/iio/iio.h>
+#include <linux/iio/sysfs.h>
+#include <linux/iio/events.h>
 
 #include "ad7280a.h"
 

commit b11f98ff8c35d62523b2bfad07df3d756113aae3
Author: Jonathan Cameron <jic23@kernel.org>
Date:   Sun Apr 15 17:41:18 2012 +0100

    staging:iio:adc Add IIO_CHAN_INFO_RAW entries to all drivers.
    
    Precursor to making value read / write attribute optional.
    No processed values for adc's.
    
    Updated to include the spear adc driver (hence introducing a
    dependency on the patch that adds that driver).
    
    Signed-off-by: Jonathan Cameron <jic23@kernel.org>
    Acked-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/iio/adc/ad7280a.c b/drivers/staging/iio/adc/ad7280a.c
index 7dbd6812c240..f0c0c72a1b07 100644
--- a/drivers/staging/iio/adc/ad7280a.c
+++ b/drivers/staging/iio/adc/ad7280a.c
@@ -508,6 +508,7 @@ static int ad7280_channel_init(struct ad7280_state *st)
 			}
 			st->channels[cnt].indexed = 1;
 			st->channels[cnt].info_mask =
+				IIO_CHAN_INFO_RAW_SEPARATE_BIT |
 				IIO_CHAN_INFO_SCALE_SHARED_BIT;
 			st->channels[cnt].address =
 				AD7280A_DEVADDR(dev) << 8 | ch;
@@ -524,7 +525,9 @@ static int ad7280_channel_init(struct ad7280_state *st)
 	st->channels[cnt].channel2 = dev * 6;
 	st->channels[cnt].address = AD7280A_ALL_CELLS;
 	st->channels[cnt].indexed = 1;
-	st->channels[cnt].info_mask = IIO_CHAN_INFO_SCALE_SHARED_BIT;
+	st->channels[cnt].info_mask =
+		IIO_CHAN_INFO_RAW_SEPARATE_BIT |
+		IIO_CHAN_INFO_SCALE_SHARED_BIT;
 	st->channels[cnt].scan_index = cnt;
 	st->channels[cnt].scan_type.sign = 'u';
 	st->channels[cnt].scan_type.realbits = 32;
@@ -788,7 +791,7 @@ static int ad7280_read_raw(struct iio_dev *indio_dev,
 	int ret;
 
 	switch (m) {
-	case 0:
+	case IIO_CHAN_INFO_RAW:
 		mutex_lock(&indio_dev->mlock);
 		if (chan->address == AD7280A_ALL_CELLS)
 			ret = ad7280_read_all_channels(st, st->scan_cnt, NULL);

commit 12e55508921865aefdd80fd17afe70c191afbd1b
Merge: 55b81e6f2795 4d447c9a6ebc
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Jan 9 12:18:17 2012 -0800

    Merge branch 'staging-next' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/staging
    
    * 'staging-next' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/staging: (466 commits)
      net/hyperv: Add support for jumbo frame up to 64KB
      net/hyperv: Add NETVSP protocol version negotiation
      net/hyperv: Remove unnecessary kmap_atomic in netvsc driver
      staging/rtl8192e: Register against lib80211
      staging/rtl8192e: Convert to lib80211_crypt_info
      staging/rtl8192e: Convert to lib80211_crypt_data and lib80211_crypt_ops
      staging/rtl8192e: Add lib80211.h to rtllib.h
      staging/mei: add watchdog device registration wrappers
      drm/omap: GEM, deal with cache
      staging: vt6656: int.c, int.h: Change return of function to void
      staging: usbip: removed unused definitions from header
      staging: usbip: removed dead code from receive function
      staging:iio: Drop {mark,unmark}_in_use callbacks
      staging:iio: Drop buffer mark_param_change callback
      staging:iio: Drop the unused buffer enable() and is_enabled() callbacks
      staging:iio: Drop buffer busy flag
      staging:iio: Make sure a device is only opened once at a time
      staging:iio: Disallow modifying buffer size when buffer is enabled
      staging:iio: Disallow changing scan elements in all buffered modes
      staging:iio: Use iio_buffer_enabled instead of open coding it
      ...
    
    Fix up conflict in drivers/staging/iio/adc/ad799x_core.c (removal of
    module_init due to using module_i2c_driver() helper, next to removal of
    MODULE_ALIAS due to using MODULE_DEVICE_TABLE instead).

commit 94386ab0b4c5a4e15afae8542cb01caa2ff37594
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Mon Dec 5 16:53:05 2011 +0100

    staging:iio: Remove redundant spi driver bus initialization
    
    In ancient times it was necessary to manually initialize the bus field of an
    spi_driver to spi_bus_type. These days this is done in spi_register_driver() so
    we can drop the manual assignment.
    
    The patch was generated using the following coccinelle semantic patch:
    // <smpl>
    @@
    identifier _driver;
    @@
     struct spi_driver _driver = {
            .driver = {
    -               .bus = &spi_bus_type,
            },
     };
    // </smpl>
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Acked-by: Jonathan Cameron <jic23@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/iio/adc/ad7280a.c b/drivers/staging/iio/adc/ad7280a.c
index 3fac9b1fc66c..941db3a55502 100644
--- a/drivers/staging/iio/adc/ad7280a.c
+++ b/drivers/staging/iio/adc/ad7280a.c
@@ -975,7 +975,6 @@ MODULE_DEVICE_TABLE(spi, ad7280_id);
 static struct spi_driver ad7280_driver = {
 	.driver = {
 		.name	= "ad7280",
-		.bus	= &spi_bus_type,
 		.owner	= THIS_MODULE,
 	},
 	.probe		= ad7280_probe,

commit 6d3ff1cc99eb869af040e34c0bbe3035cc5c203b
Author: Andreas Ruprecht <rupran@einserver.de>
Date:   Tue Nov 29 11:43:28 2011 +0100

    Staging: iio/adc: strict_strtoul was used with a long type variable
    
    The function ad7280_store_balance_timer() parses data from a char*
    buffer into a long variable, but uses the the function strict_strtoul
    which expects a pointer to an unsigned long variable as its third
    parameter.
    
    As Dan Carpenter mentioned, the values are capped a few lines later,
    but a check if val is negative is missing.
    Now this function will return -ERANGE if there is a representation of
    a negative number in buf.
    
    Additionally the checkpatch.pl considers strict_strtoul as obsolete.
    I replaced its call with the suggested kstrtoul.
    
    Signed-off-by: Andreas Ruprecht <rupran@einserver.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/iio/adc/ad7280a.c b/drivers/staging/iio/adc/ad7280a.c
index f70bff247857..3fac9b1fc66c 100644
--- a/drivers/staging/iio/adc/ad7280a.c
+++ b/drivers/staging/iio/adc/ad7280a.c
@@ -456,10 +456,10 @@ static ssize_t ad7280_store_balance_timer(struct device *dev,
 	struct iio_dev *indio_dev = dev_get_drvdata(dev);
 	struct ad7280_state *st = iio_priv(indio_dev);
 	struct iio_dev_attr *this_attr = to_iio_dev_attr(attr);
-	long val;
+	unsigned long val;
 	int ret;
 
-	ret = strict_strtoul(buf, 10, &val);
+	ret = kstrtoul(buf, 10, &val);
 	if (ret)
 		return ret;
 

commit d83fb184945cd2daaafd33a702bba9cb7ed502bf
Author: Thomas Meyer <thomas@m3y3r.de>
Date:   Tue Nov 29 22:08:00 2011 +0100

    staging: iio: Use kcalloc instead of kzalloc to allocate array
    
    The advantage of kcalloc is, that will prevent integer overflows which could
    result from the multiplication of number of elements and size and it is also
    a bit nicer to read.
    
    The semantic patch that makes this change is available
    in https://lkml.org/lkml/2011/11/25/107
    
    Signed-off-by: Thomas Meyer <thomas@m3y3r.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/iio/adc/ad7280a.c b/drivers/staging/iio/adc/ad7280a.c
index 1af4194bbd83..f70bff247857 100644
--- a/drivers/staging/iio/adc/ad7280a.c
+++ b/drivers/staging/iio/adc/ad7280a.c
@@ -488,8 +488,8 @@ static int ad7280_channel_init(struct ad7280_state *st)
 {
 	int dev, ch, cnt;
 
-	st->channels = kzalloc(sizeof(*st->channels) *
-				((st->slave_num + 1) * 12 + 2), GFP_KERNEL);
+	st->channels = kcalloc((st->slave_num + 1) * 12 + 2,
+			       sizeof(*st->channels), GFP_KERNEL);
 	if (st->channels == NULL)
 		return -ENOMEM;
 
@@ -683,7 +683,7 @@ static irqreturn_t ad7280_event_handler(int irq, void *private)
 	unsigned *channels;
 	int i, ret;
 
-	channels = kzalloc(sizeof(*channels) * st->scan_cnt, GFP_KERNEL);
+	channels = kcalloc(st->scan_cnt, sizeof(*channels), GFP_KERNEL);
 	if (channels == NULL)
 		return IRQ_HANDLED;
 

commit 55e4390cb04e8b0fbae8983c3494c9e24132db1b
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Wed Nov 16 08:53:31 2011 +0100

    staging:iio: Add missing MODULE_DEVICE_TABLE and MODULE_ALIAS
    
    Quite a few iio drivers provide no MODULE_DEVICE_TABLE or MODULE_ALIAS or only
    provide a MODULE_ALIAS while they have support for multiple device ids. This
    prevents auto module loading from working correctly.
    
    This patch fixes it by adding the missing MODULE_DEVICE_TABLEs and
    MODULE_ALIAS'.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Acked-by: Jonathan Cameron <jic23@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/iio/adc/ad7280a.c b/drivers/staging/iio/adc/ad7280a.c
index cd3397f95f80..1af4194bbd83 100644
--- a/drivers/staging/iio/adc/ad7280a.c
+++ b/drivers/staging/iio/adc/ad7280a.c
@@ -970,6 +970,7 @@ static const struct spi_device_id ad7280_id[] = {
 	{"ad7280a", 0},
 	{}
 };
+MODULE_DEVICE_TABLE(spi, ad7280_id);
 
 static struct spi_driver ad7280_driver = {
 	.driver = {

commit c8a9f8056f40f6201b84fdddb49a1c62630902c5
Author: Jonathan Cameron <jic23@cam.ac.uk>
Date:   Wed Oct 26 17:41:36 2011 +0100

    staging:iio:treewide only use shared to decide on interfaces
    
    Internally the fact that say scale is shared across channels is
    actually of remarkably little interest.  Hence lets not store it.
    Numerous devices have weird combinations of channels sharing
    scale anyway so it is not as though this was really telling
    us much. Note however that we do still use the shared sysfs
    attrs thus massively reducing the number of attrs in complex
    drivers.
    
    Side effect is that certain drivers that were abusing this
    (mostly my work) needed to do a few more checks on what the
    channel they are being queried on actually is.
    
    This is also helpful for in kernel interfaces where we
    just want to query the scale and don't care whether it
    is shared with other channels or not.
    
    Signed-off-by: Jonathan Cameron <jic23@cam.ac.uk>
    Acked-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/iio/adc/ad7280a.c b/drivers/staging/iio/adc/ad7280a.c
index 7fb60c5a80e5..cd3397f95f80 100644
--- a/drivers/staging/iio/adc/ad7280a.c
+++ b/drivers/staging/iio/adc/ad7280a.c
@@ -508,7 +508,7 @@ static int ad7280_channel_init(struct ad7280_state *st)
 			}
 			st->channels[cnt].indexed = 1;
 			st->channels[cnt].info_mask =
-				(1 << IIO_CHAN_INFO_SCALE_SHARED);
+				IIO_CHAN_INFO_SCALE_SHARED_BIT;
 			st->channels[cnt].address =
 				AD7280A_DEVADDR(dev) << 8 | ch;
 			st->channels[cnt].scan_index = cnt;
@@ -524,7 +524,7 @@ static int ad7280_channel_init(struct ad7280_state *st)
 	st->channels[cnt].channel2 = dev * 6;
 	st->channels[cnt].address = AD7280A_ALL_CELLS;
 	st->channels[cnt].indexed = 1;
-	st->channels[cnt].info_mask = (1 << IIO_CHAN_INFO_SCALE_SHARED);
+	st->channels[cnt].info_mask = IIO_CHAN_INFO_SCALE_SHARED_BIT;
 	st->channels[cnt].scan_index = cnt;
 	st->channels[cnt].scan_type.sign = 'u';
 	st->channels[cnt].scan_type.realbits = 32;
@@ -803,7 +803,7 @@ static int ad7280_read_raw(struct iio_dev *indio_dev,
 		*val = ret;
 
 		return IIO_VAL_INT;
-	case IIO_CHAN_INFO_SCALE_SHARED:
+	case IIO_CHAN_INFO_SCALE:
 		if ((chan->address & 0xFF) <= AD7280A_CELL_VOLTAGE_6)
 			scale_uv = (4000 * 1000) >> AD7280A_BITS;
 		else

commit 924f8a21dd13223cc1493a916c6769cf73e0d45e
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Wed Oct 26 17:41:35 2011 +0100

    staging:iio: Do not use bitmasks for channel info addresses
    
    Currently the iio framework uses bitmasks for the address field of channel info
    attributes. This is for historical reasons and no longer required since it will
    only ever query a single info attribute at once. This patch changes the code to
    use the non-shifted iio_chan_info_enum values for the info attribute address.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Signed-off-by: Jonathan Cameron <jic23@cam.ac.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/iio/adc/ad7280a.c b/drivers/staging/iio/adc/ad7280a.c
index 8f4fac1ce7ae..7fb60c5a80e5 100644
--- a/drivers/staging/iio/adc/ad7280a.c
+++ b/drivers/staging/iio/adc/ad7280a.c
@@ -803,7 +803,7 @@ static int ad7280_read_raw(struct iio_dev *indio_dev,
 		*val = ret;
 
 		return IIO_VAL_INT;
-	case (1 << IIO_CHAN_INFO_SCALE_SHARED):
+	case IIO_CHAN_INFO_SCALE_SHARED:
 		if ((chan->address & 0xFF) <= AD7280A_CELL_VOLTAGE_6)
 			scale_uv = (4000 * 1000) >> AD7280A_BITS;
 		else

commit af5046af1c812839f085030f358a01814666fc80
Author: Jonathan Cameron <jic23@cam.ac.uk>
Date:   Wed Oct 26 17:41:32 2011 +0100

    staging:iio: header reorganization
    
    Issue brought up by Lars-Peter Clausen. This is a varient of what
    he suggested.
    
    io/iio.h for driver stuff (has to include types.h)
            Sub files for the bits drivers may or may not use
            iio/sysfs.h
            iio/buffer.h (contents of current buffer_generic.h)
            (obviously anything offering events will need events.h as well)
    iio/types.h for the enums that matter to both
            iio_chan_type, iio_modifier
    iio/events.h for the event code stuff
            IIO_EVENT_CODE and friends.  + everything in chrdev.h  So this
            is the stuff that userspace cares about.
            Also include iio_event_type, iio_event_direction
    
    Thus iio drivers include iio.h + as required
    events.h
    sysfs.h
    buffer.h
    
    in kernel users (once that interface is merged) will need inkern.h
    which will pull in types.h
    
    Userspace will need just events.h (which pulls in types.h) to get
    everything they need to know about.  Buffer userspace access doesn't
    currently need any core defines. All information about the data
    format is passed through sysfs.
    
    Signed-off-by: Jonathan Cameron <jic23@cam.ac.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/iio/adc/ad7280a.c b/drivers/staging/iio/adc/ad7280a.c
index f45b66bf6105..8f4fac1ce7ae 100644
--- a/drivers/staging/iio/adc/ad7280a.c
+++ b/drivers/staging/iio/adc/ad7280a.c
@@ -18,6 +18,7 @@
 
 #include "../iio.h"
 #include "../sysfs.h"
+#include "../events.h"
 
 #include "ad7280a.h"
 

commit 703a9ce45abf0ae0221161fbb11952dc528db0b0
Author: Michael Hennerich <michael.hennerich@analog.com>
Date:   Wed Oct 26 13:38:18 2011 +0200

    iio: adc: ad7280a: Fix memory leak
    
    Free channels in case read fails with error.
    
    Signed-off-by: Michael Hennerich <michael.hennerich@analog.com>
    Acked-by: Jonathan Cameron <jic23@cam.ac.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/iio/adc/ad7280a.c b/drivers/staging/iio/adc/ad7280a.c
index 0c212e050a8d..f45b66bf6105 100644
--- a/drivers/staging/iio/adc/ad7280a.c
+++ b/drivers/staging/iio/adc/ad7280a.c
@@ -688,7 +688,7 @@ static irqreturn_t ad7280_event_handler(int irq, void *private)
 
 	ret = ad7280_read_all_channels(st, st->scan_cnt, channels);
 	if (ret < 0)
-		return IRQ_HANDLED;
+		goto out;
 
 	for (i = 0; i < st->scan_cnt; i++) {
 		if (((channels[i] >> 23) & 0xF) <= AD7280A_CELL_VOLTAGE_6) {
@@ -731,6 +731,7 @@ static irqreturn_t ad7280_event_handler(int irq, void *private)
 		}
 	}
 
+out:
 	kfree(channels);
 
 	return IRQ_HANDLED;

commit e15fbc91a4304a977ed99c3eb21bab7015e86c11
Author: Michael Hennerich <michael.hennerich@analog.com>
Date:   Tue Oct 25 10:51:04 2011 +0200

    iio: introduce type casts to avoid __ucmpdi2 calls
    
    This patch type casts the switch control variable to 32 bits in order to
    prevent a call __ucmpdi2 generated by some versions of gcc.
    
    This fixes an undefined reference to `__ucmpdi2' when compiled for arch/blackfin
    
    Signed-off-by: Michael Hennerich <michael.hennerich@analog.com>
    Acked-by: Jonathan Cameron <jic23@cam.ac.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/iio/adc/ad7280a.c b/drivers/staging/iio/adc/ad7280a.c
index 372d059042f9..0c212e050a8d 100644
--- a/drivers/staging/iio/adc/ad7280a.c
+++ b/drivers/staging/iio/adc/ad7280a.c
@@ -600,7 +600,7 @@ static ssize_t ad7280_read_channel_config(struct device *dev,
 	struct iio_dev_attr *this_attr = to_iio_dev_attr(attr);
 	unsigned val;
 
-	switch (this_attr->address) {
+	switch ((u32) this_attr->address) {
 	case AD7280A_CELL_OVERVOLTAGE:
 		val = 1000 + (st->cell_threshhigh * 1568) / 100;
 		break;
@@ -636,7 +636,7 @@ static ssize_t ad7280_write_channel_config(struct device *dev,
 	if (ret)
 		return ret;
 
-	switch (this_attr->address) {
+	switch ((u32) this_attr->address) {
 	case AD7280A_CELL_OVERVOLTAGE:
 	case AD7280A_CELL_UNDERVOLTAGE:
 		val = ((val - 1000) * 100) / 1568; /* LSB 15.68mV */
@@ -652,7 +652,7 @@ static ssize_t ad7280_write_channel_config(struct device *dev,
 	val = clamp(val, 0L, 0xFFL);
 
 	mutex_lock(&indio_dev->mlock);
-	switch (this_attr->address) {
+	switch ((u32) this_attr->address) {
 	case AD7280A_CELL_OVERVOLTAGE:
 		st->cell_threshhigh = val;
 		break;

commit ae6ae6fec3f7d6919e0146996df37b665c75f662
Author: Lars-Peter Clausen <lars@metafoo.de>
Date:   Wed Nov 16 10:13:39 2011 +0100

    staging:iio: Use module_spi_driver to register SPI driver
    
    Use the newly introduced module_spi_driver macro for registering SPI drivers.
    This allows us to remove a few lines of boilerplate code.
    
    Signed-off-by: Lars-Peter Clausen <lars@metafoo.de>
    Acked-by: Grant Likely <grant.likely@secretlab.ca>
    Acked-by: Jonathan Cameron <jic23@kernel.org>
    Acked-by: Wolfram Sang <w.sang@pengutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/iio/adc/ad7280a.c b/drivers/staging/iio/adc/ad7280a.c
index 372d059042f9..dbaeae81e873 100644
--- a/drivers/staging/iio/adc/ad7280a.c
+++ b/drivers/staging/iio/adc/ad7280a.c
@@ -979,18 +979,7 @@ static struct spi_driver ad7280_driver = {
 	.remove		= __devexit_p(ad7280_remove),
 	.id_table	= ad7280_id,
 };
-
-static int __init ad7280_init(void)
-{
-	return spi_register_driver(&ad7280_driver);
-}
-module_init(ad7280_init);
-
-static void __exit ad7280_exit(void)
-{
-	spi_unregister_driver(&ad7280_driver);
-}
-module_exit(ad7280_exit);
+module_spi_driver(ad7280_driver);
 
 MODULE_AUTHOR("Michael Hennerich <hennerich@blackfin.uclinux.org>");
 MODULE_DESCRIPTION("Analog Devices AD7280A");

commit d2fffd6c2fd60fe9ab63ef30758d9d43a5057549
Author: Jonathan Cameron <jic23@cam.ac.uk>
Date:   Fri Oct 14 14:46:58 2011 +0100

    staging:iio: fix removal path to allow correct freeing.
    
    Fix a dumb lack of consideration of the effect of combining
    the iio_device_unregister and iio_free_device calls into
    one.  There is no valid place to free some of the sysfs
    array elements.
    
    Signed-off-by: Jonathan Cameron <jic23@cam.ac.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/iio/adc/ad7280a.c b/drivers/staging/iio/adc/ad7280a.c
index 386834a9b69d..372d059042f9 100644
--- a/drivers/staging/iio/adc/ad7280a.c
+++ b/drivers/staging/iio/adc/ad7280a.c
@@ -831,7 +831,7 @@ static int __devinit ad7280_probe(struct spi_device *spi)
 {
 	const struct ad7280_platform_data *pdata = spi->dev.platform_data;
 	struct ad7280_state *st;
-	int ret, regdone = 0;
+	int ret;
 	const unsigned short tACQ_ns[4] = {465, 1010, 1460, 1890};
 	const unsigned short nAVG[4] = {1, 2, 4, 8};
 	struct iio_dev *indio_dev = iio_allocate_device(sizeof(*st));
@@ -903,21 +903,20 @@ static int __devinit ad7280_probe(struct spi_device *spi)
 	ret = iio_device_register(indio_dev);
 	if (ret)
 		goto error_free_attr;
-	regdone = 1;
 
 	if (spi->irq > 0) {
 		ret = ad7280_write(st, AD7280A_DEVADDR_MASTER,
 				   AD7280A_ALERT, 1,
 				   AD7280A_ALERT_RELAY_SIG_CHAIN_DOWN);
 		if (ret)
-			goto error_free_attr;
+			goto error_unregister;
 
 		ret = ad7280_write(st, AD7280A_DEVADDR(st->slave_num),
 				   AD7280A_ALERT, 0,
 				   AD7280A_ALERT_GEN_STATIC_HIGH |
 				   (pdata->chain_last_alert_ignore & 0xF));
 		if (ret)
-			goto error_free_attr;
+			goto error_unregister;
 
 		ret = request_threaded_irq(spi->irq,
 					   NULL,
@@ -927,10 +926,12 @@ static int __devinit ad7280_probe(struct spi_device *spi)
 					   indio_dev->name,
 					   indio_dev);
 		if (ret)
-			goto error_free_attr;
+			goto error_unregister;
 	}
 
 	return 0;
+error_unregister:
+	iio_device_unregister(indio_dev);
 
 error_free_attr:
 	kfree(st->iio_attr);
@@ -939,10 +940,7 @@ static int __devinit ad7280_probe(struct spi_device *spi)
 	kfree(st->channels);
 
 error_free_device:
-	if (regdone)
-		iio_device_unregister(indio_dev);
-	else
-		iio_free_device(indio_dev);
+	iio_free_device(indio_dev);
 
 	return ret;
 }
@@ -954,13 +952,14 @@ static int __devexit ad7280_remove(struct spi_device *spi)
 
 	if (spi->irq > 0)
 		free_irq(spi->irq, indio_dev);
+	iio_device_unregister(indio_dev);
 
 	ad7280_write(st, AD7280A_DEVADDR_MASTER, AD7280A_CONTROL_HB, 1,
 			AD7280A_CTRL_HB_PWRDN_SW | st->ctrl_hb);
 
 	kfree(st->channels);
 	kfree(st->iio_attr);
-	iio_device_unregister(indio_dev);
+	iio_free_device(indio_dev);
 
 	return 0;
 }

commit 84f79ecb0c1f39393b96e1401d4e8a1d498f3613
Author: Jonathan Cameron <jic23@cam.ac.uk>
Date:   Thu Oct 6 17:14:37 2011 +0100

    staging:iio:adc:naming: dev_info to indio_dev for consistency
    
    We had a random missmatch of these two.  Lets pick the most common
    and get rid of the other.
    
    Signed-off-by: Jonathan Cameron <jic23@cam.ac.uk>
    Acked-by: Michael Hennerich <michael.hennerich@analog.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/iio/adc/ad7280a.c b/drivers/staging/iio/adc/ad7280a.c
index 59581feecd44..386834a9b69d 100644
--- a/drivers/staging/iio/adc/ad7280a.c
+++ b/drivers/staging/iio/adc/ad7280a.c
@@ -383,8 +383,8 @@ static ssize_t ad7280_show_balance_sw(struct device *dev,
 					struct device_attribute *attr,
 					char *buf)
 {
-	struct iio_dev *dev_info = dev_get_drvdata(dev);
-	struct ad7280_state *st = iio_priv(dev_info);
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct ad7280_state *st = iio_priv(indio_dev);
 	struct iio_dev_attr *this_attr = to_iio_dev_attr(attr);
 
 	return sprintf(buf, "%d\n",
@@ -397,8 +397,8 @@ static ssize_t ad7280_store_balance_sw(struct device *dev,
 					 const char *buf,
 					 size_t len)
 {
-	struct iio_dev *dev_info = dev_get_drvdata(dev);
-	struct ad7280_state *st = iio_priv(dev_info);
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct ad7280_state *st = iio_priv(indio_dev);
 	struct iio_dev_attr *this_attr = to_iio_dev_attr(attr);
 	bool readin;
 	int ret;
@@ -411,7 +411,7 @@ static ssize_t ad7280_store_balance_sw(struct device *dev,
 	devaddr = this_attr->address >> 8;
 	ch = this_attr->address & 0xFF;
 
-	mutex_lock(&dev_info->mlock);
+	mutex_lock(&indio_dev->mlock);
 	if (readin)
 		st->cb_mask[devaddr] |= 1 << (ch + 2);
 	else
@@ -419,7 +419,7 @@ static ssize_t ad7280_store_balance_sw(struct device *dev,
 
 	ret = ad7280_write(st, devaddr, AD7280A_CELL_BALANCE,
 			   0, st->cb_mask[devaddr]);
-	mutex_unlock(&dev_info->mlock);
+	mutex_unlock(&indio_dev->mlock);
 
 	return ret ? ret : len;
 }
@@ -428,16 +428,16 @@ static ssize_t ad7280_show_balance_timer(struct device *dev,
 					struct device_attribute *attr,
 					char *buf)
 {
-	struct iio_dev *dev_info = dev_get_drvdata(dev);
-	struct ad7280_state *st = iio_priv(dev_info);
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct ad7280_state *st = iio_priv(indio_dev);
 	struct iio_dev_attr *this_attr = to_iio_dev_attr(attr);
 	int ret;
 	unsigned msecs;
 
-	mutex_lock(&dev_info->mlock);
+	mutex_lock(&indio_dev->mlock);
 	ret = ad7280_read(st, this_attr->address >> 8,
 			this_attr->address & 0xFF);
-	mutex_unlock(&dev_info->mlock);
+	mutex_unlock(&indio_dev->mlock);
 
 	if (ret < 0)
 		return ret;
@@ -452,8 +452,8 @@ static ssize_t ad7280_store_balance_timer(struct device *dev,
 					 const char *buf,
 					 size_t len)
 {
-	struct iio_dev *dev_info = dev_get_drvdata(dev);
-	struct ad7280_state *st = iio_priv(dev_info);
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct ad7280_state *st = iio_priv(indio_dev);
 	struct iio_dev_attr *this_attr = to_iio_dev_attr(attr);
 	long val;
 	int ret;
@@ -467,11 +467,11 @@ static ssize_t ad7280_store_balance_timer(struct device *dev,
 	if (val > 31)
 		return -EINVAL;
 
-	mutex_lock(&dev_info->mlock);
+	mutex_lock(&indio_dev->mlock);
 	ret = ad7280_write(st, this_attr->address >> 8,
 			   this_attr->address & 0xFF,
 			   0, (val & 0x1F) << 3);
-	mutex_unlock(&dev_info->mlock);
+	mutex_unlock(&indio_dev->mlock);
 
 	return ret ? ret : len;
 }
@@ -595,8 +595,8 @@ static ssize_t ad7280_read_channel_config(struct device *dev,
 					struct device_attribute *attr,
 					char *buf)
 {
-	struct iio_dev *dev_info = dev_get_drvdata(dev);
-	struct ad7280_state *st = iio_priv(dev_info);
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct ad7280_state *st = iio_priv(indio_dev);
 	struct iio_dev_attr *this_attr = to_iio_dev_attr(attr);
 	unsigned val;
 
@@ -625,8 +625,8 @@ static ssize_t ad7280_write_channel_config(struct device *dev,
 					 const char *buf,
 					 size_t len)
 {
-	struct iio_dev *dev_info = dev_get_drvdata(dev);
-	struct ad7280_state *st = iio_priv(dev_info);
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct ad7280_state *st = iio_priv(indio_dev);
 	struct iio_dev_attr *this_attr = to_iio_dev_attr(attr);
 
 	long val;
@@ -651,7 +651,7 @@ static ssize_t ad7280_write_channel_config(struct device *dev,
 
 	val = clamp(val, 0L, 0xFFL);
 
-	mutex_lock(&dev_info->mlock);
+	mutex_lock(&indio_dev->mlock);
 	switch (this_attr->address) {
 	case AD7280A_CELL_OVERVOLTAGE:
 		st->cell_threshhigh = val;
@@ -670,15 +670,15 @@ static ssize_t ad7280_write_channel_config(struct device *dev,
 	ret = ad7280_write(st, AD7280A_DEVADDR_MASTER,
 			   this_attr->address, 1, val);
 
-	mutex_unlock(&dev_info->mlock);
+	mutex_unlock(&indio_dev->mlock);
 
 	return ret ? ret : len;
 }
 
 static irqreturn_t ad7280_event_handler(int irq, void *private)
 {
-	struct iio_dev *dev_info = private;
-	struct ad7280_state *st = iio_priv(dev_info);
+	struct iio_dev *indio_dev = private;
+	struct ad7280_state *st = iio_priv(indio_dev);
 	unsigned *channels;
 	int i, ret;
 
@@ -694,7 +694,7 @@ static irqreturn_t ad7280_event_handler(int irq, void *private)
 		if (((channels[i] >> 23) & 0xF) <= AD7280A_CELL_VOLTAGE_6) {
 			if (((channels[i] >> 11) & 0xFFF) >=
 				st->cell_threshhigh)
-				iio_push_event(dev_info,
+				iio_push_event(indio_dev,
 					IIO_EVENT_CODE(IIO_VOLTAGE,
 						       1,
 						       0,
@@ -704,7 +704,7 @@ static irqreturn_t ad7280_event_handler(int irq, void *private)
 					iio_get_time_ns());
 			else if (((channels[i] >> 11) & 0xFFF) <=
 				st->cell_threshlow)
-				iio_push_event(dev_info,
+				iio_push_event(indio_dev,
 					IIO_EVENT_CODE(IIO_VOLTAGE,
 						       1,
 						       0,
@@ -714,7 +714,7 @@ static irqreturn_t ad7280_event_handler(int irq, void *private)
 					iio_get_time_ns());
 		} else {
 			if (((channels[i] >> 11) & 0xFFF) >= st->aux_threshhigh)
-				iio_push_event(dev_info,
+				iio_push_event(indio_dev,
 					IIO_UNMOD_EVENT_CODE(IIO_TEMP,
 					0,
 					IIO_EV_TYPE_THRESH,
@@ -722,7 +722,7 @@ static irqreturn_t ad7280_event_handler(int irq, void *private)
 					iio_get_time_ns());
 			else if (((channels[i] >> 11) & 0xFFF) <=
 				st->aux_threshlow)
-				iio_push_event(dev_info,
+				iio_push_event(indio_dev,
 					IIO_UNMOD_EVENT_CODE(IIO_TEMP,
 					0,
 					IIO_EV_TYPE_THRESH,
@@ -775,25 +775,25 @@ static struct attribute_group ad7280_event_attrs_group = {
 	.attrs = ad7280_event_attributes,
 };
 
-static int ad7280_read_raw(struct iio_dev *dev_info,
+static int ad7280_read_raw(struct iio_dev *indio_dev,
 			   struct iio_chan_spec const *chan,
 			   int *val,
 			   int *val2,
 			   long m)
 {
-	struct ad7280_state *st = iio_priv(dev_info);
+	struct ad7280_state *st = iio_priv(indio_dev);
 	unsigned int scale_uv;
 	int ret;
 
 	switch (m) {
 	case 0:
-		mutex_lock(&dev_info->mlock);
+		mutex_lock(&indio_dev->mlock);
 		if (chan->address == AD7280A_ALL_CELLS)
 			ret = ad7280_read_all_channels(st, st->scan_cnt, NULL);
 		else
 			ret = ad7280_read_channel(st, chan->address >> 8,
 						  chan->address & 0xFF);
-		mutex_unlock(&dev_info->mlock);
+		mutex_unlock(&indio_dev->mlock);
 
 		if (ret < 0)
 			return ret;

commit 748b636c4020286f84362f4a3cfa65a96d5387a5
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Fri Sep 30 18:06:58 2011 -0400

    staging: add module.h to various iio drivers
    
    Since they are assuming it is there implicitly and will fail otherwise
    with things like:
    
    drivers/staging/iio/impedance-analyzer/ad5933.c:816: warning: type
     defaults to â€˜intâ€™ in declaration of â€˜MODULE_AUTHORâ€™
    
    drivers/staging/iio/adc/ad7280a.c:990: warning: type defaults to â€˜intâ€™
     in declaration of â€˜MODULE_AUTHORâ€™
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/iio/adc/ad7280a.c b/drivers/staging/iio/adc/ad7280a.c
index 4c67cfea6ed4..59581feecd44 100644
--- a/drivers/staging/iio/adc/ad7280a.c
+++ b/drivers/staging/iio/adc/ad7280a.c
@@ -14,6 +14,7 @@
 #include <linux/err.h>
 #include <linux/delay.h>
 #include <linux/interrupt.h>
+#include <linux/module.h>
 
 #include "../iio.h"
 #include "../sysfs.h"

commit 322c95636739420631e51f3d3f24132dc220762a
Author: Jonathan Cameron <jic23@cam.ac.uk>
Date:   Wed Sep 14 13:01:23 2011 +0100

    staging:iio:tree wide. abi fixup for in_ out_ prefix introduction.
    
    This patch set should bring all the attributes created outside
    of chan_spec registration inline with the new abi.
    
    Signed-off-by: Jonathan Cameron <jic23@cam.ac.uk>
    Acked-by: Michael Hennerich <michael.hennerich@analog.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/iio/adc/ad7280a.c b/drivers/staging/iio/adc/ad7280a.c
index 2d8d650dc274..4c67cfea6ed4 100644
--- a/drivers/staging/iio/adc/ad7280a.c
+++ b/drivers/staging/iio/adc/ad7280a.c
@@ -736,26 +736,26 @@ static irqreturn_t ad7280_event_handler(int irq, void *private)
 }
 
 static IIO_DEVICE_ATTR_NAMED(in_thresh_low_value,
-		in-in_thresh_low_value,
+		in_voltage-voltage_thresh_low_value,
 		S_IRUGO | S_IWUSR,
 		ad7280_read_channel_config,
 		ad7280_write_channel_config,
 		AD7280A_CELL_UNDERVOLTAGE);
 
 static IIO_DEVICE_ATTR_NAMED(in_thresh_high_value,
-		in-in_thresh_high_value,
+		in_voltage-voltage_thresh_high_value,
 		S_IRUGO | S_IWUSR,
 		ad7280_read_channel_config,
 		ad7280_write_channel_config,
 		AD7280A_CELL_OVERVOLTAGE);
 
-static IIO_DEVICE_ATTR(temp_thresh_low_value,
+static IIO_DEVICE_ATTR(in_temp_thresh_low_value,
 		S_IRUGO | S_IWUSR,
 		ad7280_read_channel_config,
 		ad7280_write_channel_config,
 		AD7280A_AUX_ADC_UNDERVOLTAGE);
 
-static IIO_DEVICE_ATTR(temp_thresh_high_value,
+static IIO_DEVICE_ATTR(in_temp_thresh_high_value,
 		S_IRUGO | S_IWUSR,
 		ad7280_read_channel_config,
 		ad7280_write_channel_config,
@@ -765,8 +765,8 @@ static IIO_DEVICE_ATTR(temp_thresh_high_value,
 static struct attribute *ad7280_event_attributes[] = {
 	&iio_dev_attr_in_thresh_low_value.dev_attr.attr,
 	&iio_dev_attr_in_thresh_high_value.dev_attr.attr,
-	&iio_dev_attr_temp_thresh_low_value.dev_attr.attr,
-	&iio_dev_attr_temp_thresh_high_value.dev_attr.attr,
+	&iio_dev_attr_in_temp_thresh_low_value.dev_attr.attr,
+	&iio_dev_attr_in_temp_thresh_high_value.dev_attr.attr,
 	NULL,
 };
 

commit ade7ef7ba3bf888b90269f8ca864841b2cd9803f
Author: Jonathan Cameron <jic23@cam.ac.uk>
Date:   Fri Sep 2 17:14:45 2011 +0100

    staging:iio: Differential channel handling - use explicit flag rather than types.
    
    Straight forward change in the core, but required some drivers to not use
    the IIO_CHAN macro as that doesn't allow setting this bit (and is
    going away anyway). Hence the churn.
    
    Tested on max1363 with a couple of supported parts.
    
    V2: differential bit in code got 7 bits and direction 1. Reversed that.
    Issue spotted by Michael - thanks!
    
    Signed-off-by: Jonathan Cameron <jic23@cam.ac.uk>
    Acked-by: Michael Hennerich <Michael.Hennerich@analog.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/iio/adc/ad7280a.c b/drivers/staging/iio/adc/ad7280a.c
index bdc325dcb5b6..2d8d650dc274 100644
--- a/drivers/staging/iio/adc/ad7280a.c
+++ b/drivers/staging/iio/adc/ad7280a.c
@@ -495,7 +495,8 @@ static int ad7280_channel_init(struct ad7280_state *st)
 		for (ch = AD7280A_CELL_VOLTAGE_1; ch <= AD7280A_AUX_ADC_6; ch++,
 			cnt++) {
 			if (ch < AD7280A_AUX_ADC_1) {
-				st->channels[cnt].type = IIO_IN_DIFF;
+				st->channels[cnt].type = IIO_VOLTAGE;
+				st->channels[cnt].differential = 1;
 				st->channels[cnt].channel = (dev * 6) + ch;
 				st->channels[cnt].channel2 =
 					st->channels[cnt].channel + 1;
@@ -515,7 +516,8 @@ static int ad7280_channel_init(struct ad7280_state *st)
 			st->channels[cnt].scan_type.shift = 0;
 		}
 
-	st->channels[cnt].type = IIO_IN_DIFF;
+	st->channels[cnt].type = IIO_VOLTAGE;
+	st->channels[cnt].differential = 1;
 	st->channels[cnt].channel = 0;
 	st->channels[cnt].channel2 = dev * 6;
 	st->channels[cnt].address = AD7280A_ALL_CELLS;
@@ -692,18 +694,22 @@ static irqreturn_t ad7280_event_handler(int irq, void *private)
 			if (((channels[i] >> 11) & 0xFFF) >=
 				st->cell_threshhigh)
 				iio_push_event(dev_info,
-					IIO_UNMOD_EVENT_CODE(IIO_IN_DIFF,
-					0,
-					IIO_EV_TYPE_THRESH,
-					IIO_EV_DIR_RISING),
+					IIO_EVENT_CODE(IIO_VOLTAGE,
+						       1,
+						       0,
+						       IIO_EV_DIR_RISING,
+						       IIO_EV_TYPE_THRESH,
+						       0, 0, 0),
 					iio_get_time_ns());
 			else if (((channels[i] >> 11) & 0xFFF) <=
 				st->cell_threshlow)
 				iio_push_event(dev_info,
-					IIO_UNMOD_EVENT_CODE(IIO_IN_DIFF,
-					0,
-					IIO_EV_TYPE_THRESH,
-					IIO_EV_DIR_FALLING),
+					IIO_EVENT_CODE(IIO_VOLTAGE,
+						       1,
+						       0,
+						       IIO_EV_DIR_FALLING,
+						       IIO_EV_TYPE_THRESH,
+						       0, 0, 0),
 					iio_get_time_ns());
 		} else {
 			if (((channels[i] >> 11) & 0xFFF) >= st->aux_threshhigh)

commit 5aa9618896e0ba49b444731f9fafa7f7c18a13ab
Author: Jonathan Cameron <jic23@cam.ac.uk>
Date:   Tue Aug 30 12:41:06 2011 +0100

    staging:iio: remove broken support for multiple event interfaces.
    
    We don't have a use case for these.  Two drivers appeared to use them
    but both report all events on the first.
    
    V2: Remove now irrelevant comment.
    V3: Include fixup for adc/ad7280a.c
    
    Signed-off-by: Jonathan Cameron <jic23@cam.ac.uk>
    Acked-by: Michael Hennerich <michael.hennerich@analog.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/iio/adc/ad7280a.c b/drivers/staging/iio/adc/ad7280a.c
index ab6cf9cb5a7f..bdc325dcb5b6 100644
--- a/drivers/staging/iio/adc/ad7280a.c
+++ b/drivers/staging/iio/adc/ad7280a.c
@@ -691,7 +691,7 @@ static irqreturn_t ad7280_event_handler(int irq, void *private)
 		if (((channels[i] >> 23) & 0xF) <= AD7280A_CELL_VOLTAGE_6) {
 			if (((channels[i] >> 11) & 0xFFF) >=
 				st->cell_threshhigh)
-				iio_push_event(dev_info, 0,
+				iio_push_event(dev_info,
 					IIO_UNMOD_EVENT_CODE(IIO_IN_DIFF,
 					0,
 					IIO_EV_TYPE_THRESH,
@@ -699,7 +699,7 @@ static irqreturn_t ad7280_event_handler(int irq, void *private)
 					iio_get_time_ns());
 			else if (((channels[i] >> 11) & 0xFFF) <=
 				st->cell_threshlow)
-				iio_push_event(dev_info, 0,
+				iio_push_event(dev_info,
 					IIO_UNMOD_EVENT_CODE(IIO_IN_DIFF,
 					0,
 					IIO_EV_TYPE_THRESH,
@@ -707,7 +707,7 @@ static irqreturn_t ad7280_event_handler(int irq, void *private)
 					iio_get_time_ns());
 		} else {
 			if (((channels[i] >> 11) & 0xFFF) >= st->aux_threshhigh)
-				iio_push_event(dev_info, 0,
+				iio_push_event(dev_info,
 					IIO_UNMOD_EVENT_CODE(IIO_TEMP,
 					0,
 					IIO_EV_TYPE_THRESH,
@@ -715,7 +715,7 @@ static irqreturn_t ad7280_event_handler(int irq, void *private)
 					iio_get_time_ns());
 			else if (((channels[i] >> 11) & 0xFFF) <=
 				st->aux_threshlow)
-				iio_push_event(dev_info, 0,
+				iio_push_event(dev_info,
 					IIO_UNMOD_EVENT_CODE(IIO_TEMP,
 					0,
 					IIO_EV_TYPE_THRESH,
@@ -809,7 +809,6 @@ static int ad7280_read_raw(struct iio_dev *dev_info,
 
 static const struct iio_info ad7280_info = {
 	.read_raw = &ad7280_read_raw,
-	.num_interrupt_lines = 1,
 	.event_attrs = &ad7280_event_attrs_group,
 	.attrs = &ad7280_attrs_group,
 	.driver_module = THIS_MODULE,

commit 2051f25d2a26573918b59d69847f5bf77635023e
Author: Michael Hennerich <michael.hennerich@analog.com>
Date:   Wed Jul 20 15:03:09 2011 +0200

    iio: adc: New driver for AD7280A Lithium Ion Battery Monitoring System
    
    The AD7280A monitoring system contains all the functions required for
    general purpose monitoring and maintenance of stacked
    lithium ion batteries as used in hybrid electric vehicles,
    battery backup applications, etc.
    
    Changes since V1:
    
    Make cell channels all type IIO_IN_DIFF, update documentation accordingly.
    Remove unused and redundant defines.
    Use SI units where applicable.
    Remove unnecessary wrapper function.
    Remove redundant initialization.
    Add comments where requested.
    Revise event handler.
    Use const where applicable.
    
    Changes since V2:
    
    Remove redundant adc.h include file, scheduled for removal.
    
    Signed-off-by: Michael Hennerich <michael.hennerich@analog.com>
    Acked-by: Jonathan Cameron <jic23@cam.ac.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/iio/adc/ad7280a.c b/drivers/staging/iio/adc/ad7280a.c
new file mode 100644
index 000000000000..ab6cf9cb5a7f
--- /dev/null
+++ b/drivers/staging/iio/adc/ad7280a.c
@@ -0,0 +1,992 @@
+/*
+ * AD7280A Lithium Ion Battery Monitoring System
+ *
+ * Copyright 2011 Analog Devices Inc.
+ *
+ * Licensed under the GPL-2.
+ */
+
+#include <linux/device.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/sysfs.h>
+#include <linux/spi/spi.h>
+#include <linux/err.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+
+#include "../iio.h"
+#include "../sysfs.h"
+
+#include "ad7280a.h"
+
+/* Registers */
+#define AD7280A_CELL_VOLTAGE_1		0x0  /* D11 to D0, Read only */
+#define AD7280A_CELL_VOLTAGE_2		0x1  /* D11 to D0, Read only */
+#define AD7280A_CELL_VOLTAGE_3		0x2  /* D11 to D0, Read only */
+#define AD7280A_CELL_VOLTAGE_4		0x3  /* D11 to D0, Read only */
+#define AD7280A_CELL_VOLTAGE_5		0x4  /* D11 to D0, Read only */
+#define AD7280A_CELL_VOLTAGE_6		0x5  /* D11 to D0, Read only */
+#define AD7280A_AUX_ADC_1		0x6  /* D11 to D0, Read only */
+#define AD7280A_AUX_ADC_2		0x7  /* D11 to D0, Read only */
+#define AD7280A_AUX_ADC_3		0x8  /* D11 to D0, Read only */
+#define AD7280A_AUX_ADC_4		0x9  /* D11 to D0, Read only */
+#define AD7280A_AUX_ADC_5		0xA  /* D11 to D0, Read only */
+#define AD7280A_AUX_ADC_6		0xB  /* D11 to D0, Read only */
+#define AD7280A_SELF_TEST		0xC  /* D11 to D0, Read only */
+#define AD7280A_CONTROL_HB		0xD  /* D15 to D8, Read/write */
+#define AD7280A_CONTROL_LB		0xE  /* D7 to D0, Read/write */
+#define AD7280A_CELL_OVERVOLTAGE	0xF  /* D7 to D0, Read/write */
+#define AD7280A_CELL_UNDERVOLTAGE	0x10 /* D7 to D0, Read/write */
+#define AD7280A_AUX_ADC_OVERVOLTAGE	0x11 /* D7 to D0, Read/write */
+#define AD7280A_AUX_ADC_UNDERVOLTAGE	0x12 /* D7 to D0, Read/write */
+#define AD7280A_ALERT			0x13 /* D7 to D0, Read/write */
+#define AD7280A_CELL_BALANCE		0x14 /* D7 to D0, Read/write */
+#define AD7280A_CB1_TIMER		0x15 /* D7 to D0, Read/write */
+#define AD7280A_CB2_TIMER		0x16 /* D7 to D0, Read/write */
+#define AD7280A_CB3_TIMER		0x17 /* D7 to D0, Read/write */
+#define AD7280A_CB4_TIMER		0x18 /* D7 to D0, Read/write */
+#define AD7280A_CB5_TIMER		0x19 /* D7 to D0, Read/write */
+#define AD7280A_CB6_TIMER		0x1A /* D7 to D0, Read/write */
+#define AD7280A_PD_TIMER		0x1B /* D7 to D0, Read/write */
+#define AD7280A_READ			0x1C /* D7 to D0, Read/write */
+#define AD7280A_CNVST_CONTROL		0x1D /* D7 to D0, Read/write */
+
+/* Bits and Masks */
+#define AD7280A_CTRL_HB_CONV_INPUT_ALL			(0 << 6)
+#define AD7280A_CTRL_HB_CONV_INPUT_6CELL_AUX1_3_4	(1 << 6)
+#define AD7280A_CTRL_HB_CONV_INPUT_6CELL		(2 << 6)
+#define AD7280A_CTRL_HB_CONV_INPUT_SELF_TEST		(3 << 6)
+#define AD7280A_CTRL_HB_CONV_RES_READ_ALL		(0 << 4)
+#define AD7280A_CTRL_HB_CONV_RES_READ_6CELL_AUX1_3_4	(1 << 4)
+#define AD7280A_CTRL_HB_CONV_RES_READ_6CELL		(2 << 4)
+#define AD7280A_CTRL_HB_CONV_RES_READ_NO		(3 << 4)
+#define AD7280A_CTRL_HB_CONV_START_CNVST		(0 << 3)
+#define AD7280A_CTRL_HB_CONV_START_CS			(1 << 3)
+#define AD7280A_CTRL_HB_CONV_AVG_DIS			(0 << 1)
+#define AD7280A_CTRL_HB_CONV_AVG_2			(1 << 1)
+#define AD7280A_CTRL_HB_CONV_AVG_4			(2 << 1)
+#define AD7280A_CTRL_HB_CONV_AVG_8			(3 << 1)
+#define AD7280A_CTRL_HB_CONV_AVG(x)			((x) << 1)
+#define AD7280A_CTRL_HB_PWRDN_SW			(1 << 0)
+
+#define AD7280A_CTRL_LB_SWRST				(1 << 7)
+#define AD7280A_CTRL_LB_ACQ_TIME_400ns			(0 << 5)
+#define AD7280A_CTRL_LB_ACQ_TIME_800ns			(1 << 5)
+#define AD7280A_CTRL_LB_ACQ_TIME_1200ns			(2 << 5)
+#define AD7280A_CTRL_LB_ACQ_TIME_1600ns			(3 << 5)
+#define AD7280A_CTRL_LB_ACQ_TIME(x)			((x) << 5)
+#define AD7280A_CTRL_LB_MUST_SET			(1 << 4)
+#define AD7280A_CTRL_LB_THERMISTOR_EN			(1 << 3)
+#define AD7280A_CTRL_LB_LOCK_DEV_ADDR			(1 << 2)
+#define AD7280A_CTRL_LB_INC_DEV_ADDR			(1 << 1)
+#define AD7280A_CTRL_LB_DAISY_CHAIN_RB_EN		(1 << 0)
+
+#define AD7280A_ALERT_GEN_STATIC_HIGH			(1 << 6)
+#define AD7280A_ALERT_RELAY_SIG_CHAIN_DOWN		(3 << 6)
+
+#define AD7280A_ALL_CELLS				(0xAD << 16)
+
+#define AD7280A_MAX_SPI_CLK_Hz		700000 /* < 1MHz */
+#define AD7280A_MAX_CHAIN		8
+#define AD7280A_CELLS_PER_DEV		6
+#define AD7280A_BITS			12
+#define AD7280A_NUM_CH			(AD7280A_AUX_ADC_6 - \
+					AD7280A_CELL_VOLTAGE_1 + 1)
+
+#define AD7280A_DEVADDR_MASTER		0
+#define AD7280A_DEVADDR_ALL		0x1F
+/* 5-bit device address is sent LSB first */
+#define AD7280A_DEVADDR(addr)	(((addr & 0x1) << 4) | ((addr & 0x2) << 3) | \
+				(addr & 0x4) | ((addr & 0x8) >> 3) | \
+				((addr & 0x10) >> 4))
+
+/* During a read a valid write is mandatory.
+ * So writing to the highest available address (Address 0x1F)
+ * and setting the address all parts bit to 0 is recommended
+ * So the TXVAL is AD7280A_DEVADDR_ALL + CRC
+ */
+#define AD7280A_READ_TXVAL	0xF800030A
+
+/*
+ * AD7280 CRC
+ *
+ * P(x) = x^8 + x^5 + x^3 + x^2 + x^1 + x^0 = 0b100101111 => 0x2F
+ */
+#define POLYNOM		0x2F
+#define POLYNOM_ORDER	8
+#define HIGHBIT		1 << (POLYNOM_ORDER - 1);
+
+struct ad7280_state {
+	struct spi_device		*spi;
+	struct iio_chan_spec		*channels;
+	struct iio_dev_attr		*iio_attr;
+	int				slave_num;
+	int				scan_cnt;
+	int				readback_delay_us;
+	unsigned char			crc_tab[256];
+	unsigned char			ctrl_hb;
+	unsigned char			ctrl_lb;
+	unsigned char			cell_threshhigh;
+	unsigned char			cell_threshlow;
+	unsigned char			aux_threshhigh;
+	unsigned char			aux_threshlow;
+	unsigned char			cb_mask[AD7280A_MAX_CHAIN];
+};
+
+static void ad7280_crc8_build_table(unsigned char *crc_tab)
+{
+	unsigned char bit, crc;
+	int cnt, i;
+
+	for (cnt = 0; cnt < 256; cnt++) {
+		crc = cnt;
+		for (i = 0; i < 8; i++) {
+			bit = crc & HIGHBIT;
+			crc <<= 1;
+			if (bit)
+				crc ^= POLYNOM;
+		}
+		crc_tab[cnt] = crc;
+	}
+}
+
+static unsigned char ad7280_calc_crc8(unsigned char *crc_tab, unsigned val)
+{
+	unsigned char crc;
+
+	crc = crc_tab[val >> 16 & 0xFF];
+	crc = crc_tab[crc ^ (val >> 8 & 0xFF)];
+
+	return  crc ^ (val & 0xFF);
+}
+
+static int ad7280_check_crc(struct ad7280_state *st, unsigned val)
+{
+	unsigned char crc = ad7280_calc_crc8(st->crc_tab, val >> 10);
+
+	if (crc != ((val >> 2) & 0xFF))
+		return -EIO;
+
+	return 0;
+}
+
+/* After initiating a conversion sequence we need to wait until the
+ * conversion is done. The delay is typically in the range of 15..30 us
+ * however depending an the number of devices in the daisy chain and the
+ * number of averages taken, conversion delays and acquisition time options
+ * it may take up to 250us, in this case we better sleep instead of busy
+ * wait.
+ */
+
+static void ad7280_delay(struct ad7280_state *st)
+{
+	if (st->readback_delay_us < 50)
+		udelay(st->readback_delay_us);
+	else
+		msleep(1);
+}
+
+static int __ad7280_read32(struct spi_device *spi, unsigned *val)
+{
+	unsigned rx_buf, tx_buf = cpu_to_be32(AD7280A_READ_TXVAL);
+	int ret;
+
+	struct spi_transfer t = {
+		.tx_buf	= &tx_buf,
+		.rx_buf = &rx_buf,
+		.len = 4,
+	};
+	struct spi_message m;
+
+	spi_message_init(&m);
+	spi_message_add_tail(&t, &m);
+
+	ret = spi_sync(spi, &m);
+	if (ret)
+		return ret;
+
+	*val = be32_to_cpu(rx_buf);
+
+	return 0;
+}
+
+static int ad7280_write(struct ad7280_state *st, unsigned devaddr,
+			unsigned addr, bool all, unsigned val)
+{
+	unsigned reg = (devaddr << 27 | addr << 21 |
+			(val & 0xFF) << 13 | all << 12);
+
+	reg |= ad7280_calc_crc8(st->crc_tab, reg >> 11) << 3 | 0x2;
+	reg = cpu_to_be32(reg);
+
+	return spi_write(st->spi, &reg, 4);
+}
+
+static int ad7280_read(struct ad7280_state *st, unsigned devaddr,
+			unsigned addr)
+{
+	int ret;
+	unsigned tmp;
+
+	/* turns off the read operation on all parts */
+	ret = ad7280_write(st, AD7280A_DEVADDR_MASTER, AD7280A_CONTROL_HB, 1,
+			AD7280A_CTRL_HB_CONV_INPUT_ALL |
+			AD7280A_CTRL_HB_CONV_RES_READ_NO |
+			st->ctrl_hb);
+	if (ret)
+		return ret;
+
+	/* turns on the read operation on the addressed part */
+	ret = ad7280_write(st, devaddr, AD7280A_CONTROL_HB, 0,
+			AD7280A_CTRL_HB_CONV_INPUT_ALL |
+			AD7280A_CTRL_HB_CONV_RES_READ_ALL |
+			st->ctrl_hb);
+	if (ret)
+		return ret;
+
+	/* Set register address on the part to be read from */
+	ret = ad7280_write(st, devaddr, AD7280A_READ, 0, addr << 2);
+	if (ret)
+		return ret;
+
+	__ad7280_read32(st->spi, &tmp);
+
+	if (ad7280_check_crc(st, tmp))
+		return -EIO;
+
+	if (((tmp >> 27) != devaddr) || (((tmp >> 21) & 0x3F) != addr))
+		return -EFAULT;
+
+	return (tmp >> 13) & 0xFF;
+}
+
+static int ad7280_read_channel(struct ad7280_state *st, unsigned devaddr,
+			       unsigned addr)
+{
+	int ret;
+	unsigned tmp;
+
+	ret = ad7280_write(st, devaddr, AD7280A_READ, 0, addr << 2);
+	if (ret)
+		return ret;
+
+	ret = ad7280_write(st, AD7280A_DEVADDR_MASTER, AD7280A_CONTROL_HB, 1,
+			AD7280A_CTRL_HB_CONV_INPUT_ALL |
+			AD7280A_CTRL_HB_CONV_RES_READ_NO |
+			st->ctrl_hb);
+	if (ret)
+		return ret;
+
+	ret = ad7280_write(st, devaddr, AD7280A_CONTROL_HB, 0,
+			AD7280A_CTRL_HB_CONV_INPUT_ALL |
+			AD7280A_CTRL_HB_CONV_RES_READ_ALL |
+			AD7280A_CTRL_HB_CONV_START_CS |
+			st->ctrl_hb);
+	if (ret)
+		return ret;
+
+	ad7280_delay(st);
+
+	__ad7280_read32(st->spi, &tmp);
+
+	if (ad7280_check_crc(st, tmp))
+		return -EIO;
+
+	if (((tmp >> 27) != devaddr) || (((tmp >> 23) & 0xF) != addr))
+		return -EFAULT;
+
+	return (tmp >> 11) & 0xFFF;
+}
+
+static int ad7280_read_all_channels(struct ad7280_state *st, unsigned cnt,
+			     unsigned *array)
+{
+	int i, ret;
+	unsigned tmp, sum = 0;
+
+	ret = ad7280_write(st, AD7280A_DEVADDR_MASTER, AD7280A_READ, 1,
+			   AD7280A_CELL_VOLTAGE_1 << 2);
+	if (ret)
+		return ret;
+
+	ret = ad7280_write(st, AD7280A_DEVADDR_MASTER, AD7280A_CONTROL_HB, 1,
+			AD7280A_CTRL_HB_CONV_INPUT_ALL |
+			AD7280A_CTRL_HB_CONV_RES_READ_ALL |
+			AD7280A_CTRL_HB_CONV_START_CS |
+			st->ctrl_hb);
+	if (ret)
+		return ret;
+
+	ad7280_delay(st);
+
+	for (i = 0; i < cnt; i++) {
+		__ad7280_read32(st->spi, &tmp);
+
+		if (ad7280_check_crc(st, tmp))
+			return -EIO;
+
+		if (array)
+			array[i] = tmp;
+		/* only sum cell voltages */
+		if (((tmp >> 23) & 0xF) <= AD7280A_CELL_VOLTAGE_6)
+			sum += ((tmp >> 11) & 0xFFF);
+	}
+
+	return sum;
+}
+
+static int ad7280_chain_setup(struct ad7280_state *st)
+{
+	unsigned val, n;
+	int ret;
+
+	ret = ad7280_write(st, AD7280A_DEVADDR_MASTER, AD7280A_CONTROL_LB, 1,
+			AD7280A_CTRL_LB_DAISY_CHAIN_RB_EN |
+			AD7280A_CTRL_LB_LOCK_DEV_ADDR |
+			AD7280A_CTRL_LB_MUST_SET |
+			AD7280A_CTRL_LB_SWRST |
+			st->ctrl_lb);
+	if (ret)
+		return ret;
+
+	ret = ad7280_write(st, AD7280A_DEVADDR_MASTER, AD7280A_CONTROL_LB, 1,
+			AD7280A_CTRL_LB_DAISY_CHAIN_RB_EN |
+			AD7280A_CTRL_LB_LOCK_DEV_ADDR |
+			AD7280A_CTRL_LB_MUST_SET |
+			st->ctrl_lb);
+	if (ret)
+		return ret;
+
+	ret = ad7280_write(st, AD7280A_DEVADDR_MASTER, AD7280A_READ, 1,
+			AD7280A_CONTROL_LB << 2);
+	if (ret)
+		return ret;
+
+	for (n = 0; n <= AD7280A_MAX_CHAIN; n++) {
+		__ad7280_read32(st->spi, &val);
+		if (val == 0)
+			return n - 1;
+
+		if (ad7280_check_crc(st, val))
+			return -EIO;
+
+		if (n != AD7280A_DEVADDR(val >> 27))
+			return -EIO;
+	}
+
+	return -EFAULT;
+}
+
+static ssize_t ad7280_show_balance_sw(struct device *dev,
+					struct device_attribute *attr,
+					char *buf)
+{
+	struct iio_dev *dev_info = dev_get_drvdata(dev);
+	struct ad7280_state *st = iio_priv(dev_info);
+	struct iio_dev_attr *this_attr = to_iio_dev_attr(attr);
+
+	return sprintf(buf, "%d\n",
+		       !!(st->cb_mask[this_attr->address >> 8] &
+		       (1 << ((this_attr->address & 0xFF) + 2))));
+}
+
+static ssize_t ad7280_store_balance_sw(struct device *dev,
+					 struct device_attribute *attr,
+					 const char *buf,
+					 size_t len)
+{
+	struct iio_dev *dev_info = dev_get_drvdata(dev);
+	struct ad7280_state *st = iio_priv(dev_info);
+	struct iio_dev_attr *this_attr = to_iio_dev_attr(attr);
+	bool readin;
+	int ret;
+	unsigned devaddr, ch;
+
+	ret = strtobool(buf, &readin);
+	if (ret)
+		return ret;
+
+	devaddr = this_attr->address >> 8;
+	ch = this_attr->address & 0xFF;
+
+	mutex_lock(&dev_info->mlock);
+	if (readin)
+		st->cb_mask[devaddr] |= 1 << (ch + 2);
+	else
+		st->cb_mask[devaddr] &= ~(1 << (ch + 2));
+
+	ret = ad7280_write(st, devaddr, AD7280A_CELL_BALANCE,
+			   0, st->cb_mask[devaddr]);
+	mutex_unlock(&dev_info->mlock);
+
+	return ret ? ret : len;
+}
+
+static ssize_t ad7280_show_balance_timer(struct device *dev,
+					struct device_attribute *attr,
+					char *buf)
+{
+	struct iio_dev *dev_info = dev_get_drvdata(dev);
+	struct ad7280_state *st = iio_priv(dev_info);
+	struct iio_dev_attr *this_attr = to_iio_dev_attr(attr);
+	int ret;
+	unsigned msecs;
+
+	mutex_lock(&dev_info->mlock);
+	ret = ad7280_read(st, this_attr->address >> 8,
+			this_attr->address & 0xFF);
+	mutex_unlock(&dev_info->mlock);
+
+	if (ret < 0)
+		return ret;
+
+	msecs = (ret >> 3) * 71500;
+
+	return sprintf(buf, "%d\n", msecs);
+}
+
+static ssize_t ad7280_store_balance_timer(struct device *dev,
+					 struct device_attribute *attr,
+					 const char *buf,
+					 size_t len)
+{
+	struct iio_dev *dev_info = dev_get_drvdata(dev);
+	struct ad7280_state *st = iio_priv(dev_info);
+	struct iio_dev_attr *this_attr = to_iio_dev_attr(attr);
+	long val;
+	int ret;
+
+	ret = strict_strtoul(buf, 10, &val);
+	if (ret)
+		return ret;
+
+	val /= 71500;
+
+	if (val > 31)
+		return -EINVAL;
+
+	mutex_lock(&dev_info->mlock);
+	ret = ad7280_write(st, this_attr->address >> 8,
+			   this_attr->address & 0xFF,
+			   0, (val & 0x1F) << 3);
+	mutex_unlock(&dev_info->mlock);
+
+	return ret ? ret : len;
+}
+
+static struct attribute *ad7280_attributes[AD7280A_MAX_CHAIN *
+					   AD7280A_CELLS_PER_DEV * 2 + 1];
+
+static struct attribute_group ad7280_attrs_group = {
+	.attrs = ad7280_attributes,
+};
+
+static int ad7280_channel_init(struct ad7280_state *st)
+{
+	int dev, ch, cnt;
+
+	st->channels = kzalloc(sizeof(*st->channels) *
+				((st->slave_num + 1) * 12 + 2), GFP_KERNEL);
+	if (st->channels == NULL)
+		return -ENOMEM;
+
+	for (dev = 0, cnt = 0; dev <= st->slave_num; dev++)
+		for (ch = AD7280A_CELL_VOLTAGE_1; ch <= AD7280A_AUX_ADC_6; ch++,
+			cnt++) {
+			if (ch < AD7280A_AUX_ADC_1) {
+				st->channels[cnt].type = IIO_IN_DIFF;
+				st->channels[cnt].channel = (dev * 6) + ch;
+				st->channels[cnt].channel2 =
+					st->channels[cnt].channel + 1;
+			} else {
+				st->channels[cnt].type = IIO_TEMP;
+				st->channels[cnt].channel = (dev * 6) + ch - 6;
+			}
+			st->channels[cnt].indexed = 1;
+			st->channels[cnt].info_mask =
+				(1 << IIO_CHAN_INFO_SCALE_SHARED);
+			st->channels[cnt].address =
+				AD7280A_DEVADDR(dev) << 8 | ch;
+			st->channels[cnt].scan_index = cnt;
+			st->channels[cnt].scan_type.sign = 'u';
+			st->channels[cnt].scan_type.realbits = 12;
+			st->channels[cnt].scan_type.storagebits = 32;
+			st->channels[cnt].scan_type.shift = 0;
+		}
+
+	st->channels[cnt].type = IIO_IN_DIFF;
+	st->channels[cnt].channel = 0;
+	st->channels[cnt].channel2 = dev * 6;
+	st->channels[cnt].address = AD7280A_ALL_CELLS;
+	st->channels[cnt].indexed = 1;
+	st->channels[cnt].info_mask = (1 << IIO_CHAN_INFO_SCALE_SHARED);
+	st->channels[cnt].scan_index = cnt;
+	st->channels[cnt].scan_type.sign = 'u';
+	st->channels[cnt].scan_type.realbits = 32;
+	st->channels[cnt].scan_type.storagebits = 32;
+	st->channels[cnt].scan_type.shift = 0;
+	cnt++;
+	st->channels[cnt].type = IIO_TIMESTAMP;
+	st->channels[cnt].channel = -1;
+	st->channels[cnt].scan_index = cnt;
+	st->channels[cnt].scan_type.sign = 's';
+	st->channels[cnt].scan_type.realbits = 64;
+	st->channels[cnt].scan_type.storagebits = 64;
+	st->channels[cnt].scan_type.shift = 0;
+
+	return cnt + 1;
+}
+
+static int ad7280_attr_init(struct ad7280_state *st)
+{
+	int dev, ch, cnt;
+
+	st->iio_attr = kzalloc(sizeof(*st->iio_attr) * (st->slave_num + 1) *
+				AD7280A_CELLS_PER_DEV * 2, GFP_KERNEL);
+	if (st->iio_attr == NULL)
+		return -ENOMEM;
+
+	for (dev = 0, cnt = 0; dev <= st->slave_num; dev++)
+		for (ch = AD7280A_CELL_VOLTAGE_1; ch <= AD7280A_CELL_VOLTAGE_6;
+			ch++, cnt++) {
+			st->iio_attr[cnt].address =
+				AD7280A_DEVADDR(dev) << 8 | ch;
+			st->iio_attr[cnt].dev_attr.attr.mode =
+				S_IWUSR | S_IRUGO;
+			st->iio_attr[cnt].dev_attr.show =
+				ad7280_show_balance_sw;
+			st->iio_attr[cnt].dev_attr.store =
+				ad7280_store_balance_sw;
+			st->iio_attr[cnt].dev_attr.attr.name =
+				kasprintf(GFP_KERNEL,
+					"in%d-in%d_balance_switch_en",
+					(dev * AD7280A_CELLS_PER_DEV) + ch,
+					(dev * AD7280A_CELLS_PER_DEV) + ch + 1);
+			ad7280_attributes[cnt] =
+				&st->iio_attr[cnt].dev_attr.attr;
+			cnt++;
+			st->iio_attr[cnt].address =
+				AD7280A_DEVADDR(dev) << 8 |
+				(AD7280A_CB1_TIMER + ch);
+			st->iio_attr[cnt].dev_attr.attr.mode =
+				S_IWUSR | S_IRUGO;
+			st->iio_attr[cnt].dev_attr.show =
+				ad7280_show_balance_timer;
+			st->iio_attr[cnt].dev_attr.store =
+				ad7280_store_balance_timer;
+			st->iio_attr[cnt].dev_attr.attr.name =
+				kasprintf(GFP_KERNEL, "in%d-in%d_balance_timer",
+					(dev * AD7280A_CELLS_PER_DEV) + ch,
+					(dev * AD7280A_CELLS_PER_DEV) + ch + 1);
+			ad7280_attributes[cnt] =
+				&st->iio_attr[cnt].dev_attr.attr;
+		}
+
+	ad7280_attributes[cnt] = NULL;
+
+	return 0;
+}
+
+static ssize_t ad7280_read_channel_config(struct device *dev,
+					struct device_attribute *attr,
+					char *buf)
+{
+	struct iio_dev *dev_info = dev_get_drvdata(dev);
+	struct ad7280_state *st = iio_priv(dev_info);
+	struct iio_dev_attr *this_attr = to_iio_dev_attr(attr);
+	unsigned val;
+
+	switch (this_attr->address) {
+	case AD7280A_CELL_OVERVOLTAGE:
+		val = 1000 + (st->cell_threshhigh * 1568) / 100;
+		break;
+	case AD7280A_CELL_UNDERVOLTAGE:
+		val = 1000 + (st->cell_threshlow * 1568) / 100;
+		break;
+	case AD7280A_AUX_ADC_OVERVOLTAGE:
+		val = (st->aux_threshhigh * 196) / 10;
+		break;
+	case AD7280A_AUX_ADC_UNDERVOLTAGE:
+		val = (st->aux_threshlow * 196) / 10;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return sprintf(buf, "%d\n", val);
+}
+
+static ssize_t ad7280_write_channel_config(struct device *dev,
+					 struct device_attribute *attr,
+					 const char *buf,
+					 size_t len)
+{
+	struct iio_dev *dev_info = dev_get_drvdata(dev);
+	struct ad7280_state *st = iio_priv(dev_info);
+	struct iio_dev_attr *this_attr = to_iio_dev_attr(attr);
+
+	long val;
+	int ret;
+
+	ret = strict_strtol(buf, 10, &val);
+	if (ret)
+		return ret;
+
+	switch (this_attr->address) {
+	case AD7280A_CELL_OVERVOLTAGE:
+	case AD7280A_CELL_UNDERVOLTAGE:
+		val = ((val - 1000) * 100) / 1568; /* LSB 15.68mV */
+		break;
+	case AD7280A_AUX_ADC_OVERVOLTAGE:
+	case AD7280A_AUX_ADC_UNDERVOLTAGE:
+		val = (val * 10) / 196; /* LSB 19.6mV */
+		break;
+	default:
+		return -EFAULT;
+	}
+
+	val = clamp(val, 0L, 0xFFL);
+
+	mutex_lock(&dev_info->mlock);
+	switch (this_attr->address) {
+	case AD7280A_CELL_OVERVOLTAGE:
+		st->cell_threshhigh = val;
+		break;
+	case AD7280A_CELL_UNDERVOLTAGE:
+		st->cell_threshlow = val;
+		break;
+	case AD7280A_AUX_ADC_OVERVOLTAGE:
+		st->aux_threshhigh = val;
+		break;
+	case AD7280A_AUX_ADC_UNDERVOLTAGE:
+		st->aux_threshlow = val;
+		break;
+	}
+
+	ret = ad7280_write(st, AD7280A_DEVADDR_MASTER,
+			   this_attr->address, 1, val);
+
+	mutex_unlock(&dev_info->mlock);
+
+	return ret ? ret : len;
+}
+
+static irqreturn_t ad7280_event_handler(int irq, void *private)
+{
+	struct iio_dev *dev_info = private;
+	struct ad7280_state *st = iio_priv(dev_info);
+	unsigned *channels;
+	int i, ret;
+
+	channels = kzalloc(sizeof(*channels) * st->scan_cnt, GFP_KERNEL);
+	if (channels == NULL)
+		return IRQ_HANDLED;
+
+	ret = ad7280_read_all_channels(st, st->scan_cnt, channels);
+	if (ret < 0)
+		return IRQ_HANDLED;
+
+	for (i = 0; i < st->scan_cnt; i++) {
+		if (((channels[i] >> 23) & 0xF) <= AD7280A_CELL_VOLTAGE_6) {
+			if (((channels[i] >> 11) & 0xFFF) >=
+				st->cell_threshhigh)
+				iio_push_event(dev_info, 0,
+					IIO_UNMOD_EVENT_CODE(IIO_IN_DIFF,
+					0,
+					IIO_EV_TYPE_THRESH,
+					IIO_EV_DIR_RISING),
+					iio_get_time_ns());
+			else if (((channels[i] >> 11) & 0xFFF) <=
+				st->cell_threshlow)
+				iio_push_event(dev_info, 0,
+					IIO_UNMOD_EVENT_CODE(IIO_IN_DIFF,
+					0,
+					IIO_EV_TYPE_THRESH,
+					IIO_EV_DIR_FALLING),
+					iio_get_time_ns());
+		} else {
+			if (((channels[i] >> 11) & 0xFFF) >= st->aux_threshhigh)
+				iio_push_event(dev_info, 0,
+					IIO_UNMOD_EVENT_CODE(IIO_TEMP,
+					0,
+					IIO_EV_TYPE_THRESH,
+					IIO_EV_DIR_RISING),
+					iio_get_time_ns());
+			else if (((channels[i] >> 11) & 0xFFF) <=
+				st->aux_threshlow)
+				iio_push_event(dev_info, 0,
+					IIO_UNMOD_EVENT_CODE(IIO_TEMP,
+					0,
+					IIO_EV_TYPE_THRESH,
+					IIO_EV_DIR_FALLING),
+					iio_get_time_ns());
+		}
+	}
+
+	kfree(channels);
+
+	return IRQ_HANDLED;
+}
+
+static IIO_DEVICE_ATTR_NAMED(in_thresh_low_value,
+		in-in_thresh_low_value,
+		S_IRUGO | S_IWUSR,
+		ad7280_read_channel_config,
+		ad7280_write_channel_config,
+		AD7280A_CELL_UNDERVOLTAGE);
+
+static IIO_DEVICE_ATTR_NAMED(in_thresh_high_value,
+		in-in_thresh_high_value,
+		S_IRUGO | S_IWUSR,
+		ad7280_read_channel_config,
+		ad7280_write_channel_config,
+		AD7280A_CELL_OVERVOLTAGE);
+
+static IIO_DEVICE_ATTR(temp_thresh_low_value,
+		S_IRUGO | S_IWUSR,
+		ad7280_read_channel_config,
+		ad7280_write_channel_config,
+		AD7280A_AUX_ADC_UNDERVOLTAGE);
+
+static IIO_DEVICE_ATTR(temp_thresh_high_value,
+		S_IRUGO | S_IWUSR,
+		ad7280_read_channel_config,
+		ad7280_write_channel_config,
+		AD7280A_AUX_ADC_OVERVOLTAGE);
+
+
+static struct attribute *ad7280_event_attributes[] = {
+	&iio_dev_attr_in_thresh_low_value.dev_attr.attr,
+	&iio_dev_attr_in_thresh_high_value.dev_attr.attr,
+	&iio_dev_attr_temp_thresh_low_value.dev_attr.attr,
+	&iio_dev_attr_temp_thresh_high_value.dev_attr.attr,
+	NULL,
+};
+
+static struct attribute_group ad7280_event_attrs_group = {
+	.attrs = ad7280_event_attributes,
+};
+
+static int ad7280_read_raw(struct iio_dev *dev_info,
+			   struct iio_chan_spec const *chan,
+			   int *val,
+			   int *val2,
+			   long m)
+{
+	struct ad7280_state *st = iio_priv(dev_info);
+	unsigned int scale_uv;
+	int ret;
+
+	switch (m) {
+	case 0:
+		mutex_lock(&dev_info->mlock);
+		if (chan->address == AD7280A_ALL_CELLS)
+			ret = ad7280_read_all_channels(st, st->scan_cnt, NULL);
+		else
+			ret = ad7280_read_channel(st, chan->address >> 8,
+						  chan->address & 0xFF);
+		mutex_unlock(&dev_info->mlock);
+
+		if (ret < 0)
+			return ret;
+
+		*val = ret;
+
+		return IIO_VAL_INT;
+	case (1 << IIO_CHAN_INFO_SCALE_SHARED):
+		if ((chan->address & 0xFF) <= AD7280A_CELL_VOLTAGE_6)
+			scale_uv = (4000 * 1000) >> AD7280A_BITS;
+		else
+			scale_uv = (5000 * 1000) >> AD7280A_BITS;
+
+		*val =  scale_uv / 1000;
+		*val2 = (scale_uv % 1000) * 1000;
+		return IIO_VAL_INT_PLUS_MICRO;
+	}
+	return -EINVAL;
+}
+
+static const struct iio_info ad7280_info = {
+	.read_raw = &ad7280_read_raw,
+	.num_interrupt_lines = 1,
+	.event_attrs = &ad7280_event_attrs_group,
+	.attrs = &ad7280_attrs_group,
+	.driver_module = THIS_MODULE,
+};
+
+static const struct ad7280_platform_data ad7793_default_pdata = {
+	.acquisition_time = AD7280A_ACQ_TIME_400ns,
+	.conversion_averaging = AD7280A_CONV_AVG_DIS,
+	.thermistor_term_en = true,
+};
+
+static int __devinit ad7280_probe(struct spi_device *spi)
+{
+	const struct ad7280_platform_data *pdata = spi->dev.platform_data;
+	struct ad7280_state *st;
+	int ret, regdone = 0;
+	const unsigned short tACQ_ns[4] = {465, 1010, 1460, 1890};
+	const unsigned short nAVG[4] = {1, 2, 4, 8};
+	struct iio_dev *indio_dev = iio_allocate_device(sizeof(*st));
+
+	if (indio_dev == NULL)
+		return -ENOMEM;
+
+	st = iio_priv(indio_dev);
+	spi_set_drvdata(spi, indio_dev);
+	st->spi = spi;
+
+	if (!pdata)
+		pdata = &ad7793_default_pdata;
+
+	ad7280_crc8_build_table(st->crc_tab);
+
+	st->spi->max_speed_hz = AD7280A_MAX_SPI_CLK_Hz;
+	st->spi->mode = SPI_MODE_1;
+	spi_setup(st->spi);
+
+	st->ctrl_lb = AD7280A_CTRL_LB_ACQ_TIME(pdata->acquisition_time & 0x3);
+	st->ctrl_hb = AD7280A_CTRL_HB_CONV_AVG(pdata->conversion_averaging
+			& 0x3) | (pdata->thermistor_term_en ?
+			AD7280A_CTRL_LB_THERMISTOR_EN : 0);
+
+	ret = ad7280_chain_setup(st);
+	if (ret < 0)
+		goto error_free_device;
+
+	st->slave_num = ret;
+	st->scan_cnt = (st->slave_num + 1) * AD7280A_NUM_CH;
+	st->cell_threshhigh = 0xFF;
+	st->aux_threshhigh = 0xFF;
+
+	/*
+	 * Total Conversion Time = ((tACQ + tCONV) *
+	 *			   (Number of Conversions per Part)) âˆ’
+	 *			   tACQ + ((N - 1) * tDELAY)
+	 *
+	 * Readback Delay = Total Conversion Time + tWAIT
+	 */
+
+	st->readback_delay_us =
+		((tACQ_ns[pdata->acquisition_time & 0x3] + 695) *
+		(AD7280A_NUM_CH * nAVG[pdata->conversion_averaging & 0x3]))
+		- tACQ_ns[pdata->acquisition_time & 0x3] +
+		st->slave_num * 250;
+
+	/* Convert to usecs */
+	st->readback_delay_us = DIV_ROUND_UP(st->readback_delay_us, 1000);
+	st->readback_delay_us += 5; /* Add tWAIT */
+
+	indio_dev->name = spi_get_device_id(spi)->name;
+	indio_dev->dev.parent = &spi->dev;
+	indio_dev->modes = INDIO_DIRECT_MODE;
+
+	ret = ad7280_channel_init(st);
+	if (ret < 0)
+		goto error_free_device;
+
+	indio_dev->num_channels = ret;
+	indio_dev->channels = st->channels;
+	indio_dev->info = &ad7280_info;
+
+	ret = ad7280_attr_init(st);
+	if (ret < 0)
+		goto error_free_channels;
+
+	ret = iio_device_register(indio_dev);
+	if (ret)
+		goto error_free_attr;
+	regdone = 1;
+
+	if (spi->irq > 0) {
+		ret = ad7280_write(st, AD7280A_DEVADDR_MASTER,
+				   AD7280A_ALERT, 1,
+				   AD7280A_ALERT_RELAY_SIG_CHAIN_DOWN);
+		if (ret)
+			goto error_free_attr;
+
+		ret = ad7280_write(st, AD7280A_DEVADDR(st->slave_num),
+				   AD7280A_ALERT, 0,
+				   AD7280A_ALERT_GEN_STATIC_HIGH |
+				   (pdata->chain_last_alert_ignore & 0xF));
+		if (ret)
+			goto error_free_attr;
+
+		ret = request_threaded_irq(spi->irq,
+					   NULL,
+					   ad7280_event_handler,
+					   IRQF_TRIGGER_FALLING |
+					   IRQF_ONESHOT,
+					   indio_dev->name,
+					   indio_dev);
+		if (ret)
+			goto error_free_attr;
+	}
+
+	return 0;
+
+error_free_attr:
+	kfree(st->iio_attr);
+
+error_free_channels:
+	kfree(st->channels);
+
+error_free_device:
+	if (regdone)
+		iio_device_unregister(indio_dev);
+	else
+		iio_free_device(indio_dev);
+
+	return ret;
+}
+
+static int __devexit ad7280_remove(struct spi_device *spi)
+{
+	struct iio_dev *indio_dev = spi_get_drvdata(spi);
+	struct ad7280_state *st = iio_priv(indio_dev);
+
+	if (spi->irq > 0)
+		free_irq(spi->irq, indio_dev);
+
+	ad7280_write(st, AD7280A_DEVADDR_MASTER, AD7280A_CONTROL_HB, 1,
+			AD7280A_CTRL_HB_PWRDN_SW | st->ctrl_hb);
+
+	kfree(st->channels);
+	kfree(st->iio_attr);
+	iio_device_unregister(indio_dev);
+
+	return 0;
+}
+
+static const struct spi_device_id ad7280_id[] = {
+	{"ad7280a", 0},
+	{}
+};
+
+static struct spi_driver ad7280_driver = {
+	.driver = {
+		.name	= "ad7280",
+		.bus	= &spi_bus_type,
+		.owner	= THIS_MODULE,
+	},
+	.probe		= ad7280_probe,
+	.remove		= __devexit_p(ad7280_remove),
+	.id_table	= ad7280_id,
+};
+
+static int __init ad7280_init(void)
+{
+	return spi_register_driver(&ad7280_driver);
+}
+module_init(ad7280_init);
+
+static void __exit ad7280_exit(void)
+{
+	spi_unregister_driver(&ad7280_driver);
+}
+module_exit(ad7280_exit);
+
+MODULE_AUTHOR("Michael Hennerich <hennerich@blackfin.uclinux.org>");
+MODULE_DESCRIPTION("Analog Devices AD7280A");
+MODULE_LICENSE("GPL v2");
