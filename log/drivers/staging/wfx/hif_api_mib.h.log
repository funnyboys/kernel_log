commit d4620087d2ebc36077b0cd9d49773dcc29089fab
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Mon Apr 20 18:03:01 2020 +0200

    staging: wfx: dual CTS is never necessary
    
    Dual CTS is only necessary when sending/receiving STBC data. However,
    the chip does not support STBC, so it is never necessary to enable
    double CTS.
    
    We can simplify the code.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200420160311.57323-7-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/hif_api_mib.h b/drivers/staging/wfx/hif_api_mib.h
index 9f30cf503ad5..6f1434795fa8 100644
--- a/drivers/staging/wfx/hif_api_mib.h
+++ b/drivers/staging/wfx/hif_api_mib.h
@@ -379,12 +379,6 @@ struct hif_mib_protected_mgmt_policy {
 	u8     reserved2[3];
 } __packed;
 
-struct hif_mib_set_ht_protection {
-	u8     dual_cts_prot:1;
-	u8     reserved1:7;
-	u8     reserved2[3];
-} __packed;
-
 struct hif_mib_keep_alive_period {
 	__le16 keep_alive_period;
 	u8     reserved[2];

commit be4692e5e04a063119de9a74471504ab7ec39d1a
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Mon Apr 6 13:17:56 2020 +0200

    staging: wfx: send just necessary bytes
    
    Size of hif_mib_template_frame must be sufficient to contains bytes
    declared by frame_length and cannot exceed 700bytes.
    
    Change the API to reflect that.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200406111756.154086-12-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/hif_api_mib.h b/drivers/staging/wfx/hif_api_mib.h
index 0490157b4f3b..9f30cf503ad5 100644
--- a/drivers/staging/wfx/hif_api_mib.h
+++ b/drivers/staging/wfx/hif_api_mib.h
@@ -270,12 +270,14 @@ enum hif_tmplt {
 	HIF_TMPLT_NA     = 0x7
 };
 
+#define HIF_API_MAX_TEMPLATE_FRAME_SIZE 700
+
 struct hif_mib_template_frame {
 	u8     frame_type;
 	u8     init_rate:7;
 	u8     mode:1;
 	__le16 frame_length;
-	u8     frame[700];
+	u8     frame[];
 } __packed;
 
 struct hif_mib_beacon_wake_up_period {

commit fac592d084abfc8e1c71536a0563fde852007a81
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Mon Apr 6 13:17:52 2020 +0200

    staging: wfx: align members declarations in hif API
    
    Hardware API headers were not uniformly aligned.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200406111756.154086-8-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/hif_api_mib.h b/drivers/staging/wfx/hif_api_mib.h
index cd1c3fd37d1d..0490157b4f3b 100644
--- a/drivers/staging/wfx/hif_api_mib.h
+++ b/drivers/staging/wfx/hif_api_mib.h
@@ -10,88 +10,88 @@
 
 #include "hif_api_general.h"
 
-#define HIF_API_IPV4_ADDRESS_SIZE                       4
-#define HIF_API_IPV6_ADDRESS_SIZE                       16
+#define HIF_API_IPV4_ADDRESS_SIZE 4
+#define HIF_API_IPV6_ADDRESS_SIZE 16
 
 enum hif_mib_ids {
-	HIF_MIB_ID_GL_OPERATIONAL_POWER_MODE       = 0x2000,
-	HIF_MIB_ID_GL_BLOCK_ACK_INFO               = 0x2001,
-	HIF_MIB_ID_GL_SET_MULTI_MSG                = 0x2002,
-	HIF_MIB_ID_CCA_CONFIG                      = 0x2003,
-	HIF_MIB_ID_ETHERTYPE_DATAFRAME_CONDITION   = 0x2010,
-	HIF_MIB_ID_PORT_DATAFRAME_CONDITION        = 0x2011,
-	HIF_MIB_ID_MAGIC_DATAFRAME_CONDITION       = 0x2012,
-	HIF_MIB_ID_MAC_ADDR_DATAFRAME_CONDITION    = 0x2013,
-	HIF_MIB_ID_IPV4_ADDR_DATAFRAME_CONDITION   = 0x2014,
-	HIF_MIB_ID_IPV6_ADDR_DATAFRAME_CONDITION   = 0x2015,
-	HIF_MIB_ID_UC_MC_BC_DATAFRAME_CONDITION    = 0x2016,
-	HIF_MIB_ID_CONFIG_DATA_FILTER              = 0x2017,
-	HIF_MIB_ID_SET_DATA_FILTERING              = 0x2018,
-	HIF_MIB_ID_ARP_IP_ADDRESSES_TABLE          = 0x2019,
-	HIF_MIB_ID_NS_IP_ADDRESSES_TABLE           = 0x201A,
-	HIF_MIB_ID_RX_FILTER                       = 0x201B,
-	HIF_MIB_ID_BEACON_FILTER_TABLE             = 0x201C,
-	HIF_MIB_ID_BEACON_FILTER_ENABLE            = 0x201D,
-	HIF_MIB_ID_GRP_SEQ_COUNTER                 = 0x2030,
-	HIF_MIB_ID_TSF_COUNTER                     = 0x2031,
-	HIF_MIB_ID_STATISTICS_TABLE                = 0x2032,
-	HIF_MIB_ID_COUNTERS_TABLE                  = 0x2033,
-	HIF_MIB_ID_MAX_TX_POWER_LEVEL              = 0x2034,
-	HIF_MIB_ID_EXTENDED_COUNTERS_TABLE         = 0x2035,
-	HIF_MIB_ID_DOT11_MAC_ADDRESS               = 0x2040,
+	HIF_MIB_ID_GL_OPERATIONAL_POWER_MODE        = 0x2000,
+	HIF_MIB_ID_GL_BLOCK_ACK_INFO                = 0x2001,
+	HIF_MIB_ID_GL_SET_MULTI_MSG                 = 0x2002,
+	HIF_MIB_ID_CCA_CONFIG                       = 0x2003,
+	HIF_MIB_ID_ETHERTYPE_DATAFRAME_CONDITION    = 0x2010,
+	HIF_MIB_ID_PORT_DATAFRAME_CONDITION         = 0x2011,
+	HIF_MIB_ID_MAGIC_DATAFRAME_CONDITION        = 0x2012,
+	HIF_MIB_ID_MAC_ADDR_DATAFRAME_CONDITION     = 0x2013,
+	HIF_MIB_ID_IPV4_ADDR_DATAFRAME_CONDITION    = 0x2014,
+	HIF_MIB_ID_IPV6_ADDR_DATAFRAME_CONDITION    = 0x2015,
+	HIF_MIB_ID_UC_MC_BC_DATAFRAME_CONDITION     = 0x2016,
+	HIF_MIB_ID_CONFIG_DATA_FILTER               = 0x2017,
+	HIF_MIB_ID_SET_DATA_FILTERING               = 0x2018,
+	HIF_MIB_ID_ARP_IP_ADDRESSES_TABLE           = 0x2019,
+	HIF_MIB_ID_NS_IP_ADDRESSES_TABLE            = 0x201A,
+	HIF_MIB_ID_RX_FILTER                        = 0x201B,
+	HIF_MIB_ID_BEACON_FILTER_TABLE              = 0x201C,
+	HIF_MIB_ID_BEACON_FILTER_ENABLE             = 0x201D,
+	HIF_MIB_ID_GRP_SEQ_COUNTER                  = 0x2030,
+	HIF_MIB_ID_TSF_COUNTER                      = 0x2031,
+	HIF_MIB_ID_STATISTICS_TABLE                 = 0x2032,
+	HIF_MIB_ID_COUNTERS_TABLE                   = 0x2033,
+	HIF_MIB_ID_MAX_TX_POWER_LEVEL               = 0x2034,
+	HIF_MIB_ID_EXTENDED_COUNTERS_TABLE          = 0x2035,
+	HIF_MIB_ID_DOT11_MAC_ADDRESS                = 0x2040,
 	HIF_MIB_ID_DOT11_MAX_TRANSMIT_MSDU_LIFETIME = 0x2041,
-	HIF_MIB_ID_DOT11_MAX_RECEIVE_LIFETIME      = 0x2042,
-	HIF_MIB_ID_DOT11_WEP_DEFAULT_KEY_ID        = 0x2043,
-	HIF_MIB_ID_DOT11_RTS_THRESHOLD             = 0x2044,
-	HIF_MIB_ID_SLOT_TIME                       = 0x2045,
-	HIF_MIB_ID_CURRENT_TX_POWER_LEVEL          = 0x2046,
-	HIF_MIB_ID_NON_ERP_PROTECTION              = 0x2047,
-	HIF_MIB_ID_TEMPLATE_FRAME                  = 0x2048,
-	HIF_MIB_ID_BEACON_WAKEUP_PERIOD            = 0x2049,
-	HIF_MIB_ID_RCPI_RSSI_THRESHOLD             = 0x204A,
-	HIF_MIB_ID_BLOCK_ACK_POLICY                = 0x204B,
-	HIF_MIB_ID_OVERRIDE_INTERNAL_TX_RATE       = 0x204C,
-	HIF_MIB_ID_SET_ASSOCIATION_MODE            = 0x204D,
-	HIF_MIB_ID_SET_UAPSD_INFORMATION           = 0x204E,
-	HIF_MIB_ID_SET_TX_RATE_RETRY_POLICY        = 0x204F,
-	HIF_MIB_ID_PROTECTED_MGMT_POLICY           = 0x2050,
-	HIF_MIB_ID_SET_HT_PROTECTION               = 0x2051,
-	HIF_MIB_ID_KEEP_ALIVE_PERIOD               = 0x2052,
-	HIF_MIB_ID_ARP_KEEP_ALIVE_PERIOD           = 0x2053,
-	HIF_MIB_ID_INACTIVITY_TIMER                = 0x2054,
-	HIF_MIB_ID_INTERFACE_PROTECTION            = 0x2055,
-	HIF_MIB_ID_BEACON_STATS                    = 0x2056,
+	HIF_MIB_ID_DOT11_MAX_RECEIVE_LIFETIME       = 0x2042,
+	HIF_MIB_ID_DOT11_WEP_DEFAULT_KEY_ID         = 0x2043,
+	HIF_MIB_ID_DOT11_RTS_THRESHOLD              = 0x2044,
+	HIF_MIB_ID_SLOT_TIME                        = 0x2045,
+	HIF_MIB_ID_CURRENT_TX_POWER_LEVEL           = 0x2046,
+	HIF_MIB_ID_NON_ERP_PROTECTION               = 0x2047,
+	HIF_MIB_ID_TEMPLATE_FRAME                   = 0x2048,
+	HIF_MIB_ID_BEACON_WAKEUP_PERIOD             = 0x2049,
+	HIF_MIB_ID_RCPI_RSSI_THRESHOLD              = 0x204A,
+	HIF_MIB_ID_BLOCK_ACK_POLICY                 = 0x204B,
+	HIF_MIB_ID_OVERRIDE_INTERNAL_TX_RATE        = 0x204C,
+	HIF_MIB_ID_SET_ASSOCIATION_MODE             = 0x204D,
+	HIF_MIB_ID_SET_UAPSD_INFORMATION            = 0x204E,
+	HIF_MIB_ID_SET_TX_RATE_RETRY_POLICY         = 0x204F,
+	HIF_MIB_ID_PROTECTED_MGMT_POLICY            = 0x2050,
+	HIF_MIB_ID_SET_HT_PROTECTION                = 0x2051,
+	HIF_MIB_ID_KEEP_ALIVE_PERIOD                = 0x2052,
+	HIF_MIB_ID_ARP_KEEP_ALIVE_PERIOD            = 0x2053,
+	HIF_MIB_ID_INACTIVITY_TIMER                 = 0x2054,
+	HIF_MIB_ID_INTERFACE_PROTECTION             = 0x2055,
+	HIF_MIB_ID_BEACON_STATS                     = 0x2056,
 };
 
 enum hif_op_power_mode {
-	HIF_OP_POWER_MODE_ACTIVE                   = 0x0,
-	HIF_OP_POWER_MODE_DOZE                     = 0x1,
-	HIF_OP_POWER_MODE_QUIESCENT                = 0x2
+	HIF_OP_POWER_MODE_ACTIVE    = 0x0,
+	HIF_OP_POWER_MODE_DOZE      = 0x1,
+	HIF_OP_POWER_MODE_QUIESCENT = 0x2
 };
 
 struct hif_mib_gl_operational_power_mode {
-	u8    power_mode:4;
-	u8    reserved1:3;
-	u8    wup_ind_activation:1;
-	u8    reserved2[3];
+	u8     power_mode:4;
+	u8     reserved1:3;
+	u8     wup_ind_activation:1;
+	u8     reserved2[3];
 } __packed;
 
 struct hif_mib_gl_set_multi_msg {
-	u8    enable_multi_tx_conf:1;
-	u8    reserved1:7;
-	u8    reserved2[3];
+	u8     enable_multi_tx_conf:1;
+	u8     reserved1:7;
+	u8     reserved2[3];
 } __packed;
 
 enum hif_mac_addr_type {
-	HIF_MAC_ADDR_A1                            = 0x0,
-	HIF_MAC_ADDR_A2                            = 0x1,
-	HIF_MAC_ADDR_A3                            = 0x2
+	HIF_MAC_ADDR_A1 = 0x0,
+	HIF_MAC_ADDR_A2 = 0x1,
+	HIF_MAC_ADDR_A3 = 0x2
 };
 
 struct hif_mib_mac_addr_data_frame_condition {
-	u8    condition_idx;
-	u8    address_type;
-	u8    mac_address[ETH_ALEN];
+	u8     condition_idx;
+	u8     address_type;
+	u8     mac_address[ETH_ALEN];
 } __packed;
 
 #define HIF_FILTER_UNICAST   0x1
@@ -99,65 +99,65 @@ struct hif_mib_mac_addr_data_frame_condition {
 #define HIF_FILTER_BROADCAST 0x4
 
 struct hif_mib_uc_mc_bc_data_frame_condition {
-	u8    condition_idx;
-	u8    allowed_frames;
-	u8    reserved[2];
+	u8     condition_idx;
+	u8     allowed_frames;
+	u8     reserved[2];
 } __packed;
 
 struct hif_mib_config_data_filter {
-	u8    filter_idx;
-	u8    enable;
-	u8    reserved1[2];
-	u8    eth_type_cond;
-	u8    port_cond;
-	u8    magic_cond;
-	u8    mac_cond;
-	u8    ipv4_cond;
-	u8    ipv6_cond;
-	u8    uc_mc_bc_cond;
-	u8    reserved2;
+	u8     filter_idx;
+	u8     enable;
+	u8     reserved1[2];
+	u8     eth_type_cond;
+	u8     port_cond;
+	u8     magic_cond;
+	u8     mac_cond;
+	u8     ipv4_cond;
+	u8     ipv6_cond;
+	u8     uc_mc_bc_cond;
+	u8     reserved2;
 } __packed;
 
 struct hif_mib_set_data_filtering {
-	u8    invert_matching:1;
-	u8    reserved1:7;
-	u8    enable:1;
-	u8    reserved2:7;
-	u8    reserved3[2];
+	u8     invert_matching:1;
+	u8     reserved1:7;
+	u8     enable:1;
+	u8     reserved2:7;
+	u8     reserved3[2];
 } __packed;
 
 enum hif_arp_ns_frame_treatment {
-	HIF_ARP_NS_FILTERING_DISABLE                  = 0x0,
-	HIF_ARP_NS_FILTERING_ENABLE                   = 0x1,
-	HIF_ARP_NS_REPLY_ENABLE                       = 0x2
+	HIF_ARP_NS_FILTERING_DISABLE = 0x0,
+	HIF_ARP_NS_FILTERING_ENABLE  = 0x1,
+	HIF_ARP_NS_REPLY_ENABLE      = 0x2
 };
 
 struct hif_mib_arp_ip_addr_table {
-	u8    condition_idx;
-	u8    arp_enable;
-	u8    reserved[2];
-	u8    ipv4_address[HIF_API_IPV4_ADDRESS_SIZE];
+	u8     condition_idx;
+	u8     arp_enable;
+	u8     reserved[2];
+	u8     ipv4_address[HIF_API_IPV4_ADDRESS_SIZE];
 } __packed;
 
 struct hif_mib_rx_filter {
-	u8    reserved1:1;
-	u8    bssid_filter:1;
-	u8    reserved2:1;
-	u8    fwd_probe_req:1;
-	u8    keep_alive_filter:1;
-	u8    reserved3:3;
-	u8    reserved4[3];
+	u8     reserved1:1;
+	u8     bssid_filter:1;
+	u8     reserved2:1;
+	u8     fwd_probe_req:1;
+	u8     keep_alive_filter:1;
+	u8     reserved3:3;
+	u8     reserved4[3];
 } __packed;
 
 struct hif_ie_table_entry {
-	u8    ie_id;
-	u8    has_changed:1;
-	u8    no_longer:1;
-	u8    has_appeared:1;
-	u8    reserved:1;
-	u8    num_match_data:4;
-	u8    oui[3];
-	u8    match_data[3];
+	u8     ie_id;
+	u8     has_changed:1;
+	u8     no_longer:1;
+	u8     has_appeared:1;
+	u8     reserved:1;
+	u8     num_match_data:4;
+	u8     oui[3];
+	u8     match_data[3];
 } __packed;
 
 struct hif_mib_bcn_filter_table {
@@ -166,9 +166,9 @@ struct hif_mib_bcn_filter_table {
 } __packed;
 
 enum hif_beacon_filter {
-	HIF_BEACON_FILTER_DISABLE                  = 0x0,
-	HIF_BEACON_FILTER_ENABLE                   = 0x1,
-	HIF_BEACON_FILTER_AUTO_ERP                 = 0x2
+	HIF_BEACON_FILTER_DISABLE  = 0x0,
+	HIF_BEACON_FILTER_ENABLE   = 0x1,
+	HIF_BEACON_FILTER_AUTO_ERP = 0x2
 };
 
 struct hif_mib_bcn_filter_enable {
@@ -232,13 +232,13 @@ struct hif_mib_count_table {
 } __packed;
 
 struct hif_mib_mac_address {
-	u8    mac_addr[ETH_ALEN];
+	u8     mac_addr[ETH_ALEN];
 	__le16 reserved;
 } __packed;
 
 struct hif_mib_wep_default_key_id {
-	u8    wep_default_key_id;
-	u8    reserved[3];
+	u8     wep_default_key_id;
+	u8     reserved[3];
 } __packed;
 
 struct hif_mib_dot11_rts_threshold {
@@ -254,138 +254,138 @@ struct hif_mib_current_tx_power_level {
 } __packed;
 
 struct hif_mib_non_erp_protection {
-	u8   use_cts_to_self:1;
-	u8   reserved1:7;
-	u8   reserved2[3];
+	u8     use_cts_to_self:1;
+	u8     reserved1:7;
+	u8     reserved2[3];
 } __packed;
 
 enum hif_tmplt {
-	HIF_TMPLT_PRBREQ                           = 0x0,
-	HIF_TMPLT_BCN                              = 0x1,
-	HIF_TMPLT_NULL                             = 0x2,
-	HIF_TMPLT_QOSNUL                           = 0x3,
-	HIF_TMPLT_PSPOLL                           = 0x4,
-	HIF_TMPLT_PRBRES                           = 0x5,
-	HIF_TMPLT_ARP                              = 0x6,
-	HIF_TMPLT_NA                               = 0x7
+	HIF_TMPLT_PRBREQ = 0x0,
+	HIF_TMPLT_BCN    = 0x1,
+	HIF_TMPLT_NULL   = 0x2,
+	HIF_TMPLT_QOSNUL = 0x3,
+	HIF_TMPLT_PSPOLL = 0x4,
+	HIF_TMPLT_PRBRES = 0x5,
+	HIF_TMPLT_ARP    = 0x6,
+	HIF_TMPLT_NA     = 0x7
 };
 
 struct hif_mib_template_frame {
-	u8    frame_type;
-	u8    init_rate:7;
-	u8    mode:1;
+	u8     frame_type;
+	u8     init_rate:7;
+	u8     mode:1;
 	__le16 frame_length;
-	u8    frame[700];
+	u8     frame[700];
 } __packed;
 
 struct hif_mib_beacon_wake_up_period {
-	u8    wakeup_period_min;
-	u8    receive_dtim:1;
-	u8    reserved1:7;
-	u8    wakeup_period_max;
-	u8    reserved2;
+	u8     wakeup_period_min;
+	u8     receive_dtim:1;
+	u8     reserved1:7;
+	u8     wakeup_period_max;
+	u8     reserved2;
 } __packed;
 
 struct hif_mib_rcpi_rssi_threshold {
-	u8    detection:1;
-	u8    rcpi_rssi:1;
-	u8    upperthresh:1;
-	u8    lowerthresh:1;
-	u8    reserved:4;
-	u8    lower_threshold;
-	u8    upper_threshold;
-	u8    rolling_average_count;
+	u8     detection:1;
+	u8     rcpi_rssi:1;
+	u8     upperthresh:1;
+	u8     lowerthresh:1;
+	u8     reserved:4;
+	u8     lower_threshold;
+	u8     upper_threshold;
+	u8     rolling_average_count;
 } __packed;
 
 #define DEFAULT_BA_MAX_RX_BUFFER_SIZE 16
 
 struct hif_mib_block_ack_policy {
-	u8    block_ack_tx_tid_policy;
-	u8    reserved1;
-	u8    block_ack_rx_tid_policy;
-	u8    block_ack_rx_max_buffer_size;
+	u8     block_ack_tx_tid_policy;
+	u8     reserved1;
+	u8     block_ack_rx_tid_policy;
+	u8     block_ack_rx_max_buffer_size;
 } __packed;
 
 enum hif_mpdu_start_spacing {
-	HIF_MPDU_START_SPACING_NO_RESTRIC          = 0x0,
-	HIF_MPDU_START_SPACING_QUARTER             = 0x1,
-	HIF_MPDU_START_SPACING_HALF                = 0x2,
-	HIF_MPDU_START_SPACING_ONE                 = 0x3,
-	HIF_MPDU_START_SPACING_TWO                 = 0x4,
-	HIF_MPDU_START_SPACING_FOUR                = 0x5,
-	HIF_MPDU_START_SPACING_EIGHT               = 0x6,
-	HIF_MPDU_START_SPACING_SIXTEEN             = 0x7
+	HIF_MPDU_START_SPACING_NO_RESTRIC = 0x0,
+	HIF_MPDU_START_SPACING_QUARTER    = 0x1,
+	HIF_MPDU_START_SPACING_HALF       = 0x2,
+	HIF_MPDU_START_SPACING_ONE        = 0x3,
+	HIF_MPDU_START_SPACING_TWO        = 0x4,
+	HIF_MPDU_START_SPACING_FOUR       = 0x5,
+	HIF_MPDU_START_SPACING_EIGHT      = 0x6,
+	HIF_MPDU_START_SPACING_SIXTEEN    = 0x7
 };
 
 struct hif_mib_set_association_mode {
-	u8    preambtype_use:1;
-	u8    mode:1;
-	u8    rateset:1;
-	u8    spacing:1;
-	u8    reserved1:4;
-	u8    short_preamble:1;
-	u8    reserved2:7;
-	u8    greenfield:1;
-	u8    reserved3:7;
-	u8    mpdu_start_spacing;
+	u8     preambtype_use:1;
+	u8     mode:1;
+	u8     rateset:1;
+	u8     spacing:1;
+	u8     reserved1:4;
+	u8     short_preamble:1;
+	u8     reserved2:7;
+	u8     greenfield:1;
+	u8     reserved3:7;
+	u8     mpdu_start_spacing;
 	__le32 basic_rate_set;
 } __packed;
 
 struct hif_mib_set_uapsd_information {
-	u8    trig_bckgrnd:1;
-	u8    trig_be:1;
-	u8    trig_video:1;
-	u8    trig_voice:1;
-	u8    reserved1:4;
-	u8    deliv_bckgrnd:1;
-	u8    deliv_be:1;
-	u8    deliv_video:1;
-	u8    deliv_voice:1;
-	u8    reserved2:4;
+	u8     trig_bckgrnd:1;
+	u8     trig_be:1;
+	u8     trig_video:1;
+	u8     trig_voice:1;
+	u8     reserved1:4;
+	u8     deliv_bckgrnd:1;
+	u8     deliv_be:1;
+	u8     deliv_video:1;
+	u8     deliv_voice:1;
+	u8     reserved2:4;
 	__le16 min_auto_trigger_interval;
 	__le16 max_auto_trigger_interval;
 	__le16 auto_trigger_step;
 } __packed;
 
 struct hif_mib_tx_rate_retry_policy {
-	u8    policy_index;
-	u8    short_retry_count;
-	u8    long_retry_count;
-	u8    first_rate_sel:2;
-	u8    terminate:1;
-	u8    count_init:1;
-	u8    reserved1:4;
-	u8    rate_recovery_count;
-	u8    reserved2[3];
-	u8    rates[12];
+	u8     policy_index;
+	u8     short_retry_count;
+	u8     long_retry_count;
+	u8     first_rate_sel:2;
+	u8     terminate:1;
+	u8     count_init:1;
+	u8     reserved1:4;
+	u8     rate_recovery_count;
+	u8     reserved2[3];
+	u8     rates[12];
 } __packed;
 
-#define HIF_TX_RETRY_POLICY_MAX        15
-#define HIF_TX_RETRY_POLICY_INVALID    HIF_TX_RETRY_POLICY_MAX
+#define HIF_TX_RETRY_POLICY_MAX     15
+#define HIF_TX_RETRY_POLICY_INVALID HIF_TX_RETRY_POLICY_MAX
 
 struct hif_mib_set_tx_rate_retry_policy {
-	u8    num_tx_rate_policies;
-	u8    reserved[3];
+	u8     num_tx_rate_policies;
+	u8     reserved[3];
 	struct hif_mib_tx_rate_retry_policy tx_rate_retry_policy[];
 } __packed;
 
 struct hif_mib_protected_mgmt_policy {
-	u8   pmf_enable:1;
-	u8   unpmf_allowed:1;
-	u8   host_enc_auth_frames:1;
-	u8   reserved1:5;
-	u8   reserved2[3];
+	u8     pmf_enable:1;
+	u8     unpmf_allowed:1;
+	u8     host_enc_auth_frames:1;
+	u8     reserved1:5;
+	u8     reserved2[3];
 } __packed;
 
 struct hif_mib_set_ht_protection {
-	u8   dual_cts_prot:1;
-	u8   reserved1:7;
-	u8   reserved2[3];
+	u8     dual_cts_prot:1;
+	u8     reserved1:7;
+	u8     reserved2[3];
 } __packed;
 
 struct hif_mib_keep_alive_period {
 	__le16 keep_alive_period;
-	u8    reserved[2];
+	u8     reserved[2];
 } __packed;
 
 #endif

commit 31db18cccc277e63f0e6489587381d52f034194b
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Mon Apr 6 13:17:51 2020 +0200

    staging: wfx: fix endianness of hif API
    
    The chip expects little endian in all structs it sends/receives. This
    patch fixes the hif API to reflect this fact. Sparse should now report
    meaningful errors.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200406111756.154086-7-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/hif_api_mib.h b/drivers/staging/wfx/hif_api_mib.h
index e6d05789720c..cd1c3fd37d1d 100644
--- a/drivers/staging/wfx/hif_api_mib.h
+++ b/drivers/staging/wfx/hif_api_mib.h
@@ -161,7 +161,7 @@ struct hif_ie_table_entry {
 } __packed;
 
 struct hif_mib_bcn_filter_table {
-	u32   num_of_info_elmts;
+	__le32 num_of_info_elmts;
 	struct hif_ie_table_entry ie_table[];
 } __packed;
 
@@ -172,68 +172,68 @@ enum hif_beacon_filter {
 };
 
 struct hif_mib_bcn_filter_enable {
-	u32   enable;
-	u32   bcn_count;
+	__le32 enable;
+	__le32 bcn_count;
 } __packed;
 
 struct hif_mib_extended_count_table {
-	u32   count_plcp_errors;
-	u32   count_fcs_errors;
-	u32   count_tx_packets;
-	u32   count_rx_packets;
-	u32   count_rx_packet_errors;
-	u32   count_rx_decryption_failures;
-	u32   count_rx_mic_failures;
-	u32   count_rx_no_key_failures;
-	u32   count_tx_multicast_frames;
-	u32   count_tx_frames_success;
-	u32   count_tx_frame_failures;
-	u32   count_tx_frames_retried;
-	u32   count_tx_frames_multi_retried;
-	u32   count_rx_frame_duplicates;
-	u32   count_rts_success;
-	u32   count_rts_failures;
-	u32   count_ack_failures;
-	u32   count_rx_multicast_frames;
-	u32   count_rx_frames_success;
-	u32   count_rx_cmacicv_errors;
-	u32   count_rx_cmac_replays;
-	u32   count_rx_mgmt_ccmp_replays;
-	u32   count_rx_bipmic_errors;
-	u32   count_rx_beacon;
-	u32   count_miss_beacon;
-	u32   reserved[15];
+	__le32 count_plcp_errors;
+	__le32 count_fcs_errors;
+	__le32 count_tx_packets;
+	__le32 count_rx_packets;
+	__le32 count_rx_packet_errors;
+	__le32 count_rx_decryption_failures;
+	__le32 count_rx_mic_failures;
+	__le32 count_rx_no_key_failures;
+	__le32 count_tx_multicast_frames;
+	__le32 count_tx_frames_success;
+	__le32 count_tx_frame_failures;
+	__le32 count_tx_frames_retried;
+	__le32 count_tx_frames_multi_retried;
+	__le32 count_rx_frame_duplicates;
+	__le32 count_rts_success;
+	__le32 count_rts_failures;
+	__le32 count_ack_failures;
+	__le32 count_rx_multicast_frames;
+	__le32 count_rx_frames_success;
+	__le32 count_rx_cmacicv_errors;
+	__le32 count_rx_cmac_replays;
+	__le32 count_rx_mgmt_ccmp_replays;
+	__le32 count_rx_bipmic_errors;
+	__le32 count_rx_beacon;
+	__le32 count_miss_beacon;
+	__le32 reserved[15];
 } __packed;
 
 struct hif_mib_count_table {
-	u32   count_plcp_errors;
-	u32   count_fcs_errors;
-	u32   count_tx_packets;
-	u32   count_rx_packets;
-	u32   count_rx_packet_errors;
-	u32   count_rx_decryption_failures;
-	u32   count_rx_mic_failures;
-	u32   count_rx_no_key_failures;
-	u32   count_tx_multicast_frames;
-	u32   count_tx_frames_success;
-	u32   count_tx_frame_failures;
-	u32   count_tx_frames_retried;
-	u32   count_tx_frames_multi_retried;
-	u32   count_rx_frame_duplicates;
-	u32   count_rts_success;
-	u32   count_rts_failures;
-	u32   count_ack_failures;
-	u32   count_rx_multicast_frames;
-	u32   count_rx_frames_success;
-	u32   count_rx_cmacicv_errors;
-	u32   count_rx_cmac_replays;
-	u32   count_rx_mgmt_ccmp_replays;
-	u32   count_rx_bipmic_errors;
+	__le32 count_plcp_errors;
+	__le32 count_fcs_errors;
+	__le32 count_tx_packets;
+	__le32 count_rx_packets;
+	__le32 count_rx_packet_errors;
+	__le32 count_rx_decryption_failures;
+	__le32 count_rx_mic_failures;
+	__le32 count_rx_no_key_failures;
+	__le32 count_tx_multicast_frames;
+	__le32 count_tx_frames_success;
+	__le32 count_tx_frame_failures;
+	__le32 count_tx_frames_retried;
+	__le32 count_tx_frames_multi_retried;
+	__le32 count_rx_frame_duplicates;
+	__le32 count_rts_success;
+	__le32 count_rts_failures;
+	__le32 count_ack_failures;
+	__le32 count_rx_multicast_frames;
+	__le32 count_rx_frames_success;
+	__le32 count_rx_cmacicv_errors;
+	__le32 count_rx_cmac_replays;
+	__le32 count_rx_mgmt_ccmp_replays;
+	__le32 count_rx_bipmic_errors;
 } __packed;
 
 struct hif_mib_mac_address {
 	u8    mac_addr[ETH_ALEN];
-	u16   reserved;
+	__le16 reserved;
 } __packed;
 
 struct hif_mib_wep_default_key_id {
@@ -242,15 +242,15 @@ struct hif_mib_wep_default_key_id {
 } __packed;
 
 struct hif_mib_dot11_rts_threshold {
-	u32   threshold;
+	__le32 threshold;
 } __packed;
 
 struct hif_mib_slot_time {
-	u32   slot_time;
+	__le32 slot_time;
 } __packed;
 
 struct hif_mib_current_tx_power_level {
-	s32   power_level;
+	__le32 power_level; // signed value
 } __packed;
 
 struct hif_mib_non_erp_protection {
@@ -274,7 +274,7 @@ struct hif_mib_template_frame {
 	u8    frame_type;
 	u8    init_rate:7;
 	u8    mode:1;
-	u16   frame_length;
+	__le16 frame_length;
 	u8    frame[700];
 } __packed;
 
@@ -328,7 +328,7 @@ struct hif_mib_set_association_mode {
 	u8    greenfield:1;
 	u8    reserved3:7;
 	u8    mpdu_start_spacing;
-	u32   basic_rate_set;
+	__le32 basic_rate_set;
 } __packed;
 
 struct hif_mib_set_uapsd_information {
@@ -342,9 +342,9 @@ struct hif_mib_set_uapsd_information {
 	u8    deliv_video:1;
 	u8    deliv_voice:1;
 	u8    reserved2:4;
-	u16   min_auto_trigger_interval;
-	u16   max_auto_trigger_interval;
-	u16   auto_trigger_step;
+	__le16 min_auto_trigger_interval;
+	__le16 max_auto_trigger_interval;
+	__le16 auto_trigger_step;
 } __packed;
 
 struct hif_mib_tx_rate_retry_policy {
@@ -384,7 +384,7 @@ struct hif_mib_set_ht_protection {
 } __packed;
 
 struct hif_mib_keep_alive_period {
-	u16   keep_alive_period;
+	__le16 keep_alive_period;
 	u8    reserved[2];
 } __packed;
 

commit a3d968288640277819af01f23f593af1c279a2b8
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Mon Apr 6 13:17:50 2020 +0200

    staging: wfx: remove useless defines
    
    Several values defined in hif API are only here to define length of some
    arrays. In most cases, they do not provide any extra information about
    the size of the array (ie. "API_FIRMWARE_LABEL_SIZE" is only used to
    define the size of member "firmware_label").
    
    Remove these useless definitions.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200406111756.154086-6-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/hif_api_mib.h b/drivers/staging/wfx/hif_api_mib.h
index 732f82d10a19..e6d05789720c 100644
--- a/drivers/staging/wfx/hif_api_mib.h
+++ b/drivers/staging/wfx/hif_api_mib.h
@@ -149,9 +149,6 @@ struct hif_mib_rx_filter {
 	u8    reserved4[3];
 } __packed;
 
-#define HIF_API_OUI_SIZE                                3
-#define HIF_API_MATCH_DATA_SIZE                         3
-
 struct hif_ie_table_entry {
 	u8    ie_id;
 	u8    has_changed:1;
@@ -159,8 +156,8 @@ struct hif_ie_table_entry {
 	u8    has_appeared:1;
 	u8    reserved:1;
 	u8    num_match_data:4;
-	u8    oui[HIF_API_OUI_SIZE];
-	u8    match_data[HIF_API_MATCH_DATA_SIZE];
+	u8    oui[3];
+	u8    match_data[3];
 } __packed;
 
 struct hif_mib_bcn_filter_table {
@@ -273,14 +270,12 @@ enum hif_tmplt {
 	HIF_TMPLT_NA                               = 0x7
 };
 
-#define HIF_API_MAX_TEMPLATE_FRAME_SIZE                              700
-
 struct hif_mib_template_frame {
 	u8    frame_type;
 	u8    init_rate:7;
 	u8    mode:1;
 	u16   frame_length;
-	u8    frame[HIF_API_MAX_TEMPLATE_FRAME_SIZE];
+	u8    frame[700];
 } __packed;
 
 struct hif_mib_beacon_wake_up_period {

commit 29d69a59c4c6de92a9f0b4b5dbb2e7842168b87f
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Mon Apr 6 13:17:49 2020 +0200

    staging: wfx: remove unused definitions from the hif API
    
    Until now, hif API was directly imported from firmware sources.
    However, it does not make sense to keep ton of unused structures in
    the driver. Moreover, the hif API is now stable enough to be keep in
    sync by importing delta from firmware.
    
    So, drop unused definitions from the hif API.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200406111756.154086-5-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/hif_api_mib.h b/drivers/staging/wfx/hif_api_mib.h
index 36c9152785c4..732f82d10a19 100644
--- a/drivers/staging/wfx/hif_api_mib.h
+++ b/drivers/staging/wfx/hif_api_mib.h
@@ -63,8 +63,6 @@ enum hif_mib_ids {
 	HIF_MIB_ID_BEACON_STATS                    = 0x2056,
 };
 
-#define HIF_OP_POWER_MODE_MASK                     0xf
-
 enum hif_op_power_mode {
 	HIF_OP_POWER_MODE_ACTIVE                   = 0x0,
 	HIF_OP_POWER_MODE_DOZE                     = 0x1,
@@ -78,78 +76,12 @@ struct hif_mib_gl_operational_power_mode {
 	u8    reserved2[3];
 } __packed;
 
-struct hif_mib_gl_block_ack_info {
-	u8    rx_buffer_size;
-	u8    rx_max_num_agreements;
-	u8    tx_buffer_size;
-	u8    tx_max_num_agreements;
-} __packed;
-
 struct hif_mib_gl_set_multi_msg {
 	u8    enable_multi_tx_conf:1;
 	u8    reserved1:7;
 	u8    reserved2[3];
 } __packed;
 
-enum hif_cca_thr_mode {
-	HIF_CCA_THR_MODE_RELATIVE = 0x0,
-	HIF_CCA_THR_MODE_ABSOLUTE = 0x1
-};
-
-struct hif_mib_gl_cca_config {
-	u8  cca_thr_mode;
-	u8  reserved[3];
-} __packed;
-
-#define MAX_NUMBER_DATA_FILTERS             0xA
-
-#define MAX_NUMBER_IPV4_ADDR_CONDITIONS     0x4
-#define MAX_NUMBER_IPV6_ADDR_CONDITIONS     0x4
-#define MAX_NUMBER_MAC_ADDR_CONDITIONS      0x4
-#define MAX_NUMBER_UC_MC_BC_CONDITIONS      0x4
-#define MAX_NUMBER_ETHER_TYPE_CONDITIONS    0x4
-#define MAX_NUMBER_PORT_CONDITIONS          0x4
-#define MAX_NUMBER_MAGIC_CONDITIONS         0x4
-#define MAX_NUMBER_ARP_CONDITIONS           0x2
-#define MAX_NUMBER_NS_CONDITIONS            0x2
-
-struct hif_mib_ethertype_data_frame_condition {
-	u8    condition_idx;
-	u8    reserved;
-	u16   ether_type;
-} __packed;
-
-enum hif_udp_tcp_protocol {
-	HIF_PROTOCOL_UDP                       = 0x0,
-	HIF_PROTOCOL_TCP                       = 0x1,
-	HIF_PROTOCOL_BOTH_UDP_TCP              = 0x2
-};
-
-enum hif_which_port {
-	HIF_PORT_DST                           = 0x0,
-	HIF_PORT_SRC                           = 0x1,
-	HIF_PORT_SRC_OR_DST                    = 0x2
-};
-
-struct hif_mib_ports_data_frame_condition {
-	u8    condition_idx;
-	u8    protocol;
-	u8    which_port;
-	u8    reserved1;
-	u16   port_number;
-	u8    reserved2[2];
-} __packed;
-
-#define HIF_API_MAGIC_PATTERN_SIZE                 32
-
-struct hif_mib_magic_data_frame_condition {
-	u8    condition_idx;
-	u8    offset;
-	u8    magic_pattern_length;
-	u8    reserved;
-	u8    magic_pattern[HIF_API_MAGIC_PATTERN_SIZE];
-} __packed;
-
 enum hif_mac_addr_type {
 	HIF_MAC_ADDR_A1                            = 0x0,
 	HIF_MAC_ADDR_A2                            = 0x1,
@@ -162,25 +94,6 @@ struct hif_mib_mac_addr_data_frame_condition {
 	u8    mac_address[ETH_ALEN];
 } __packed;
 
-enum hif_ip_addr_mode {
-	HIF_IP_ADDR_SRC                            = 0x0,
-	HIF_IP_ADDR_DST                            = 0x1
-};
-
-struct hif_mib_ipv4_addr_data_frame_condition {
-	u8    condition_idx;
-	u8    address_mode;
-	u8    reserved[2];
-	u8    i_pv4_address[HIF_API_IPV4_ADDRESS_SIZE];
-} __packed;
-
-struct hif_mib_ipv6_addr_data_frame_condition {
-	u8    condition_idx;
-	u8    address_mode;
-	u8    reserved[2];
-	u8    i_pv6_address[HIF_API_IPV6_ADDRESS_SIZE];
-} __packed;
-
 #define HIF_FILTER_UNICAST   0x1
 #define HIF_FILTER_MULTICAST 0x2
 #define HIF_FILTER_BROADCAST 0x4
@@ -226,13 +139,6 @@ struct hif_mib_arp_ip_addr_table {
 	u8    ipv4_address[HIF_API_IPV4_ADDRESS_SIZE];
 } __packed;
 
-struct hif_mib_ns_ip_addr_table {
-	u8    condition_idx;
-	u8    ns_enable;
-	u8    reserved[2];
-	u8    ipv6_address[HIF_API_IPV6_ADDRESS_SIZE];
-} __packed;
-
 struct hif_mib_rx_filter {
 	u8    reserved1:1;
 	u8    bssid_filter:1;
@@ -273,23 +179,6 @@ struct hif_mib_bcn_filter_enable {
 	u32   bcn_count;
 } __packed;
 
-struct hif_mib_group_seq_counter {
-	u32   bits4716;
-	u16   bits1500;
-	u16   reserved;
-} __packed;
-
-struct hif_mib_tsf_counter {
-	u32   tsf_counterlo;
-	u32   tsf_counterhi;
-} __packed;
-
-struct hif_mib_stats_table {
-	s16    latest_snr;
-	u8    latest_rcpi;
-	s8     latest_rssi;
-} __packed;
-
 struct hif_mib_extended_count_table {
 	u32   count_plcp_errors;
 	u32   count_fcs_errors;
@@ -345,29 +234,11 @@ struct hif_mib_count_table {
 	u32   count_rx_bipmic_errors;
 } __packed;
 
-struct hif_mib_max_tx_power_level {
-	s32       max_tx_power_level_rf_port1;
-	s32       max_tx_power_level_rf_port2;
-} __packed;
-
-struct hif_mib_beacon_stats {
-	s32     latest_tbtt_diff;
-	u32    reserved[4];
-} __packed;
-
 struct hif_mib_mac_address {
 	u8    mac_addr[ETH_ALEN];
 	u16   reserved;
 } __packed;
 
-struct hif_mib_dot11_max_transmit_msdu_lifetime {
-	u32   max_life_time;
-} __packed;
-
-struct hif_mib_dot11_max_receive_lifetime {
-	u32   max_life_time;
-} __packed;
-
 struct hif_mib_wep_default_key_id {
 	u8    wep_default_key_id;
 	u8    reserved[3];
@@ -440,12 +311,6 @@ struct hif_mib_block_ack_policy {
 	u8    block_ack_rx_max_buffer_size;
 } __packed;
 
-struct hif_mib_override_int_rate {
-	u8    internal_tx_rate;
-	u8    non_erp_internal_tx_rate;
-	u8    reserved[2];
-} __packed;
-
 enum hif_mpdu_start_spacing {
 	HIF_MPDU_START_SPACING_NO_RESTRIC          = 0x0,
 	HIF_MPDU_START_SPACING_QUARTER             = 0x1,
@@ -528,24 +393,4 @@ struct hif_mib_keep_alive_period {
 	u8    reserved[2];
 } __packed;
 
-struct hif_mib_arp_keep_alive_period {
-	u16   arp_keep_alive_period;
-	u8    encr_type;
-	u8    reserved;
-	u8    sender_ipv4_address[HIF_API_IPV4_ADDRESS_SIZE];
-	u8    target_ipv4_address[HIF_API_IPV4_ADDRESS_SIZE];
-} __packed;
-
-struct hif_mib_inactivity_timer {
-	u8    min_active_time;
-	u8    max_active_time;
-	u16   reserved;
-} __packed;
-
-struct hif_mib_interface_protection {
-	u8   use_cts_prot:1;
-	u8   reserved1:7;
-	u8   reserved2[3];
-} __packed;
-
 #endif

commit a4aac6b8890fef31c94cc658d4b56591d20cf5f2
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Mon Apr 6 13:17:48 2020 +0200

    staging: wfx: relocate TX_RETRY_POLICY_MAX and TX_RETRY_POLICY_INVALID to hif API
    
    The definitions TX_RETRY_POLICY_MAX and TX_RETRY_POLICY_INVALID are
    imposed by the hardware. Therefore, they should be located in the
    hardware interface API.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200406111756.154086-4-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/hif_api_mib.h b/drivers/staging/wfx/hif_api_mib.h
index 0c67cd4c1593..36c9152785c4 100644
--- a/drivers/staging/wfx/hif_api_mib.h
+++ b/drivers/staging/wfx/hif_api_mib.h
@@ -500,7 +500,8 @@ struct hif_mib_tx_rate_retry_policy {
 	u8    rates[12];
 } __packed;
 
-#define HIF_MIB_NUM_TX_RATE_RETRY_POLICIES    15
+#define HIF_TX_RETRY_POLICY_MAX        15
+#define HIF_TX_RETRY_POLICY_INVALID    HIF_TX_RETRY_POLICY_MAX
 
 struct hif_mib_set_tx_rate_retry_policy {
 	u8    num_tx_rate_policies;

commit 3f5264e75c7bd332f38c8bc0f903771336fba44d
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Wed Jan 15 13:54:51 2020 +0000

    staging: wfx: simplify hif_mib_set_data_filtering
    
    The field "default_filter" was not obvious.
    
    In add, explicitly declare that fields default_filter and enable are
    booleans.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200115135338.14374-34-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/hif_api_mib.h b/drivers/staging/wfx/hif_api_mib.h
index e0ef0337e01c..0c67cd4c1593 100644
--- a/drivers/staging/wfx/hif_api_mib.h
+++ b/drivers/staging/wfx/hif_api_mib.h
@@ -206,9 +206,11 @@ struct hif_mib_config_data_filter {
 } __packed;
 
 struct hif_mib_set_data_filtering {
-	u8    default_filter;
-	u8    enable;
-	u8    reserved[2];
+	u8    invert_matching:1;
+	u8    reserved1:7;
+	u8    enable:1;
+	u8    reserved2:7;
+	u8    reserved3[2];
 } __packed;
 
 enum hif_arp_ns_frame_treatment {

commit f5864a1076d1a5f3c7d297ab79bfabaa69af3e41
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Wed Jan 15 13:54:49 2020 +0000

    staging: wfx: simplify hif_mib_uc_mc_bc_data_frame_condition
    
    The current API defines bitfields. It is not very convenient. Prefer to
    use bitmasks.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200115135338.14374-33-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/hif_api_mib.h b/drivers/staging/wfx/hif_api_mib.h
index 1603b3074bf7..e0ef0337e01c 100644
--- a/drivers/staging/wfx/hif_api_mib.h
+++ b/drivers/staging/wfx/hif_api_mib.h
@@ -181,19 +181,13 @@ struct hif_mib_ipv6_addr_data_frame_condition {
 	u8    i_pv6_address[HIF_API_IPV6_ADDRESS_SIZE];
 } __packed;
 
-union hif_addr_type {
-	u8 value;
-	struct {
-		u8    type_unicast:1;
-		u8    type_multicast:1;
-		u8    type_broadcast:1;
-		u8    reserved:5;
-	} bits;
-};
+#define HIF_FILTER_UNICAST   0x1
+#define HIF_FILTER_MULTICAST 0x2
+#define HIF_FILTER_BROADCAST 0x4
 
 struct hif_mib_uc_mc_bc_data_frame_condition {
 	u8    condition_idx;
-	union hif_addr_type param;
+	u8    allowed_frames;
 	u8    reserved[2];
 } __packed;
 

commit 07c11c18ebb50c4f4b3fb5a40cbce212352b35bf
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Tue Dec 17 16:15:07 2019 +0000

    staging: wfx: better naming for hif_mib_set_association_mode->greenfield
    
    Current name "mixed_or_greenfield_type" does not allow to know if
    "true" means "mixed" of "greenfield". It is possible to use a better
    name and drop "enum hif_tx_mode".
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20191217161318.31402-29-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/hif_api_mib.h b/drivers/staging/wfx/hif_api_mib.h
index 34e4310ad71f..1603b3074bf7 100644
--- a/drivers/staging/wfx/hif_api_mib.h
+++ b/drivers/staging/wfx/hif_api_mib.h
@@ -395,11 +395,6 @@ struct hif_mib_non_erp_protection {
 	u8   reserved2[3];
 } __packed;
 
-enum hif_tx_mode {
-	HIF_TX_MODE_MIXED                        = 0x0,
-	HIF_TX_MODE_GREENFIELD                   = 0x1
-};
-
 enum hif_tmplt {
 	HIF_TMPLT_PRBREQ                           = 0x0,
 	HIF_TMPLT_BCN                              = 0x1,
@@ -474,7 +469,8 @@ struct hif_mib_set_association_mode {
 	u8    reserved1:4;
 	u8    short_preamble:1;
 	u8    reserved2:7;
-	u8    mixed_or_greenfield_type;
+	u8    greenfield:1;
+	u8    reserved3:7;
 	u8    mpdu_start_spacing;
 	u32   basic_rate_set;
 } __packed;

commit ad636ec4f01a06a59433d126c5754127b3157197
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Tue Dec 17 16:15:05 2019 +0000

    staging: wfx: better naming for hif_req_join->short_preamble
    
    HIF_PREAMBLE_SHORT_LONG12 is never used. So it is possible to change
    "preamble_type" into a boolean and drop "enum hif_preamble".
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20191217161318.31402-28-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/hif_api_mib.h b/drivers/staging/wfx/hif_api_mib.h
index 94b789ceb4ff..34e4310ad71f 100644
--- a/drivers/staging/wfx/hif_api_mib.h
+++ b/drivers/staging/wfx/hif_api_mib.h
@@ -471,8 +471,9 @@ struct hif_mib_set_association_mode {
 	u8    mode:1;
 	u8    rateset:1;
 	u8    spacing:1;
-	u8    reserved:4;
-	u8    preamble_type;
+	u8    reserved1:4;
+	u8    short_preamble:1;
+	u8    reserved2:7;
 	u8    mixed_or_greenfield_type;
 	u8    mpdu_start_spacing;
 	u32   basic_rate_set;

commit 5cd382b2693358be99b9ae1c524854f5715b5dc2
Author: Jules Irenge <jbi.octave@gmail.com>
Date:   Mon Nov 11 13:30:53 2019 +0000

    staging: wfx: replace uintXX_t to uXX and intXX_t to sXX
    
    Replace uint8_t to u8, uint16_t to u16, uint32_t to u32
    int8_t to s8,int16_t to s16 and int32_t to s32
    As per recommendation of checkpatch tool.
    
    Signed-off-by: Jules Irenge <jbi.octave@gmail.com>
    Link: https://lore.kernel.org/r/20191111133055.214410-1-jbi.octave@gmail.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/hif_api_mib.h b/drivers/staging/wfx/hif_api_mib.h
index af657555f894..94b789ceb4ff 100644
--- a/drivers/staging/wfx/hif_api_mib.h
+++ b/drivers/staging/wfx/hif_api_mib.h
@@ -72,23 +72,23 @@ enum hif_op_power_mode {
 };
 
 struct hif_mib_gl_operational_power_mode {
-	uint8_t    power_mode:4;
-	uint8_t    reserved1:3;
-	uint8_t    wup_ind_activation:1;
-	uint8_t    reserved2[3];
+	u8    power_mode:4;
+	u8    reserved1:3;
+	u8    wup_ind_activation:1;
+	u8    reserved2[3];
 } __packed;
 
 struct hif_mib_gl_block_ack_info {
-	uint8_t    rx_buffer_size;
-	uint8_t    rx_max_num_agreements;
-	uint8_t    tx_buffer_size;
-	uint8_t    tx_max_num_agreements;
+	u8    rx_buffer_size;
+	u8    rx_max_num_agreements;
+	u8    tx_buffer_size;
+	u8    tx_max_num_agreements;
 } __packed;
 
 struct hif_mib_gl_set_multi_msg {
-	uint8_t    enable_multi_tx_conf:1;
-	uint8_t    reserved1:7;
-	uint8_t    reserved2[3];
+	u8    enable_multi_tx_conf:1;
+	u8    reserved1:7;
+	u8    reserved2[3];
 } __packed;
 
 enum hif_cca_thr_mode {
@@ -97,8 +97,8 @@ enum hif_cca_thr_mode {
 };
 
 struct hif_mib_gl_cca_config {
-	uint8_t  cca_thr_mode;
-	uint8_t  reserved[3];
+	u8  cca_thr_mode;
+	u8  reserved[3];
 } __packed;
 
 #define MAX_NUMBER_DATA_FILTERS             0xA
@@ -114,9 +114,9 @@ struct hif_mib_gl_cca_config {
 #define MAX_NUMBER_NS_CONDITIONS            0x2
 
 struct hif_mib_ethertype_data_frame_condition {
-	uint8_t    condition_idx;
-	uint8_t    reserved;
-	uint16_t   ether_type;
+	u8    condition_idx;
+	u8    reserved;
+	u16   ether_type;
 } __packed;
 
 enum hif_udp_tcp_protocol {
@@ -132,22 +132,22 @@ enum hif_which_port {
 };
 
 struct hif_mib_ports_data_frame_condition {
-	uint8_t    condition_idx;
-	uint8_t    protocol;
-	uint8_t    which_port;
-	uint8_t    reserved1;
-	uint16_t   port_number;
-	uint8_t    reserved2[2];
+	u8    condition_idx;
+	u8    protocol;
+	u8    which_port;
+	u8    reserved1;
+	u16   port_number;
+	u8    reserved2[2];
 } __packed;
 
 #define HIF_API_MAGIC_PATTERN_SIZE                 32
 
 struct hif_mib_magic_data_frame_condition {
-	uint8_t    condition_idx;
-	uint8_t    offset;
-	uint8_t    magic_pattern_length;
-	uint8_t    reserved;
-	uint8_t    magic_pattern[HIF_API_MAGIC_PATTERN_SIZE];
+	u8    condition_idx;
+	u8    offset;
+	u8    magic_pattern_length;
+	u8    reserved;
+	u8    magic_pattern[HIF_API_MAGIC_PATTERN_SIZE];
 } __packed;
 
 enum hif_mac_addr_type {
@@ -157,9 +157,9 @@ enum hif_mac_addr_type {
 };
 
 struct hif_mib_mac_addr_data_frame_condition {
-	uint8_t    condition_idx;
-	uint8_t    address_type;
-	uint8_t    mac_address[ETH_ALEN];
+	u8    condition_idx;
+	u8    address_type;
+	u8    mac_address[ETH_ALEN];
 } __packed;
 
 enum hif_ip_addr_mode {
@@ -168,53 +168,53 @@ enum hif_ip_addr_mode {
 };
 
 struct hif_mib_ipv4_addr_data_frame_condition {
-	uint8_t    condition_idx;
-	uint8_t    address_mode;
-	uint8_t    reserved[2];
-	uint8_t    i_pv4_address[HIF_API_IPV4_ADDRESS_SIZE];
+	u8    condition_idx;
+	u8    address_mode;
+	u8    reserved[2];
+	u8    i_pv4_address[HIF_API_IPV4_ADDRESS_SIZE];
 } __packed;
 
 struct hif_mib_ipv6_addr_data_frame_condition {
-	uint8_t    condition_idx;
-	uint8_t    address_mode;
-	uint8_t    reserved[2];
-	uint8_t    i_pv6_address[HIF_API_IPV6_ADDRESS_SIZE];
+	u8    condition_idx;
+	u8    address_mode;
+	u8    reserved[2];
+	u8    i_pv6_address[HIF_API_IPV6_ADDRESS_SIZE];
 } __packed;
 
 union hif_addr_type {
-	uint8_t value;
+	u8 value;
 	struct {
-		uint8_t    type_unicast:1;
-		uint8_t    type_multicast:1;
-		uint8_t    type_broadcast:1;
-		uint8_t    reserved:5;
+		u8    type_unicast:1;
+		u8    type_multicast:1;
+		u8    type_broadcast:1;
+		u8    reserved:5;
 	} bits;
 };
 
 struct hif_mib_uc_mc_bc_data_frame_condition {
-	uint8_t    condition_idx;
+	u8    condition_idx;
 	union hif_addr_type param;
-	uint8_t    reserved[2];
+	u8    reserved[2];
 } __packed;
 
 struct hif_mib_config_data_filter {
-	uint8_t    filter_idx;
-	uint8_t    enable;
-	uint8_t    reserved1[2];
-	uint8_t    eth_type_cond;
-	uint8_t    port_cond;
-	uint8_t    magic_cond;
-	uint8_t    mac_cond;
-	uint8_t    ipv4_cond;
-	uint8_t    ipv6_cond;
-	uint8_t    uc_mc_bc_cond;
-	uint8_t    reserved2;
+	u8    filter_idx;
+	u8    enable;
+	u8    reserved1[2];
+	u8    eth_type_cond;
+	u8    port_cond;
+	u8    magic_cond;
+	u8    mac_cond;
+	u8    ipv4_cond;
+	u8    ipv6_cond;
+	u8    uc_mc_bc_cond;
+	u8    reserved2;
 } __packed;
 
 struct hif_mib_set_data_filtering {
-	uint8_t    default_filter;
-	uint8_t    enable;
-	uint8_t    reserved[2];
+	u8    default_filter;
+	u8    enable;
+	u8    reserved[2];
 } __packed;
 
 enum hif_arp_ns_frame_treatment {
@@ -224,45 +224,45 @@ enum hif_arp_ns_frame_treatment {
 };
 
 struct hif_mib_arp_ip_addr_table {
-	uint8_t    condition_idx;
-	uint8_t    arp_enable;
-	uint8_t    reserved[2];
-	uint8_t    ipv4_address[HIF_API_IPV4_ADDRESS_SIZE];
+	u8    condition_idx;
+	u8    arp_enable;
+	u8    reserved[2];
+	u8    ipv4_address[HIF_API_IPV4_ADDRESS_SIZE];
 } __packed;
 
 struct hif_mib_ns_ip_addr_table {
-	uint8_t    condition_idx;
-	uint8_t    ns_enable;
-	uint8_t    reserved[2];
-	uint8_t    ipv6_address[HIF_API_IPV6_ADDRESS_SIZE];
+	u8    condition_idx;
+	u8    ns_enable;
+	u8    reserved[2];
+	u8    ipv6_address[HIF_API_IPV6_ADDRESS_SIZE];
 } __packed;
 
 struct hif_mib_rx_filter {
-	uint8_t    reserved1:1;
-	uint8_t    bssid_filter:1;
-	uint8_t    reserved2:1;
-	uint8_t    fwd_probe_req:1;
-	uint8_t    keep_alive_filter:1;
-	uint8_t    reserved3:3;
-	uint8_t    reserved4[3];
+	u8    reserved1:1;
+	u8    bssid_filter:1;
+	u8    reserved2:1;
+	u8    fwd_probe_req:1;
+	u8    keep_alive_filter:1;
+	u8    reserved3:3;
+	u8    reserved4[3];
 } __packed;
 
 #define HIF_API_OUI_SIZE                                3
 #define HIF_API_MATCH_DATA_SIZE                         3
 
 struct hif_ie_table_entry {
-	uint8_t    ie_id;
-	uint8_t    has_changed:1;
-	uint8_t    no_longer:1;
-	uint8_t    has_appeared:1;
-	uint8_t    reserved:1;
-	uint8_t    num_match_data:4;
-	uint8_t    oui[HIF_API_OUI_SIZE];
-	uint8_t    match_data[HIF_API_MATCH_DATA_SIZE];
+	u8    ie_id;
+	u8    has_changed:1;
+	u8    no_longer:1;
+	u8    has_appeared:1;
+	u8    reserved:1;
+	u8    num_match_data:4;
+	u8    oui[HIF_API_OUI_SIZE];
+	u8    match_data[HIF_API_MATCH_DATA_SIZE];
 } __packed;
 
 struct hif_mib_bcn_filter_table {
-	uint32_t   num_of_info_elmts;
+	u32   num_of_info_elmts;
 	struct hif_ie_table_entry ie_table[];
 } __packed;
 
@@ -273,126 +273,126 @@ enum hif_beacon_filter {
 };
 
 struct hif_mib_bcn_filter_enable {
-	uint32_t   enable;
-	uint32_t   bcn_count;
+	u32   enable;
+	u32   bcn_count;
 } __packed;
 
 struct hif_mib_group_seq_counter {
-	uint32_t   bits4716;
-	uint16_t   bits1500;
-	uint16_t   reserved;
+	u32   bits4716;
+	u16   bits1500;
+	u16   reserved;
 } __packed;
 
 struct hif_mib_tsf_counter {
-	uint32_t   tsf_counterlo;
-	uint32_t   tsf_counterhi;
+	u32   tsf_counterlo;
+	u32   tsf_counterhi;
 } __packed;
 
 struct hif_mib_stats_table {
-	int16_t    latest_snr;
-	uint8_t    latest_rcpi;
-	int8_t     latest_rssi;
+	s16    latest_snr;
+	u8    latest_rcpi;
+	s8     latest_rssi;
 } __packed;
 
 struct hif_mib_extended_count_table {
-	uint32_t   count_plcp_errors;
-	uint32_t   count_fcs_errors;
-	uint32_t   count_tx_packets;
-	uint32_t   count_rx_packets;
-	uint32_t   count_rx_packet_errors;
-	uint32_t   count_rx_decryption_failures;
-	uint32_t   count_rx_mic_failures;
-	uint32_t   count_rx_no_key_failures;
-	uint32_t   count_tx_multicast_frames;
-	uint32_t   count_tx_frames_success;
-	uint32_t   count_tx_frame_failures;
-	uint32_t   count_tx_frames_retried;
-	uint32_t   count_tx_frames_multi_retried;
-	uint32_t   count_rx_frame_duplicates;
-	uint32_t   count_rts_success;
-	uint32_t   count_rts_failures;
-	uint32_t   count_ack_failures;
-	uint32_t   count_rx_multicast_frames;
-	uint32_t   count_rx_frames_success;
-	uint32_t   count_rx_cmacicv_errors;
-	uint32_t   count_rx_cmac_replays;
-	uint32_t   count_rx_mgmt_ccmp_replays;
-	uint32_t   count_rx_bipmic_errors;
-	uint32_t   count_rx_beacon;
-	uint32_t   count_miss_beacon;
-	uint32_t   reserved[15];
+	u32   count_plcp_errors;
+	u32   count_fcs_errors;
+	u32   count_tx_packets;
+	u32   count_rx_packets;
+	u32   count_rx_packet_errors;
+	u32   count_rx_decryption_failures;
+	u32   count_rx_mic_failures;
+	u32   count_rx_no_key_failures;
+	u32   count_tx_multicast_frames;
+	u32   count_tx_frames_success;
+	u32   count_tx_frame_failures;
+	u32   count_tx_frames_retried;
+	u32   count_tx_frames_multi_retried;
+	u32   count_rx_frame_duplicates;
+	u32   count_rts_success;
+	u32   count_rts_failures;
+	u32   count_ack_failures;
+	u32   count_rx_multicast_frames;
+	u32   count_rx_frames_success;
+	u32   count_rx_cmacicv_errors;
+	u32   count_rx_cmac_replays;
+	u32   count_rx_mgmt_ccmp_replays;
+	u32   count_rx_bipmic_errors;
+	u32   count_rx_beacon;
+	u32   count_miss_beacon;
+	u32   reserved[15];
 } __packed;
 
 struct hif_mib_count_table {
-	uint32_t   count_plcp_errors;
-	uint32_t   count_fcs_errors;
-	uint32_t   count_tx_packets;
-	uint32_t   count_rx_packets;
-	uint32_t   count_rx_packet_errors;
-	uint32_t   count_rx_decryption_failures;
-	uint32_t   count_rx_mic_failures;
-	uint32_t   count_rx_no_key_failures;
-	uint32_t   count_tx_multicast_frames;
-	uint32_t   count_tx_frames_success;
-	uint32_t   count_tx_frame_failures;
-	uint32_t   count_tx_frames_retried;
-	uint32_t   count_tx_frames_multi_retried;
-	uint32_t   count_rx_frame_duplicates;
-	uint32_t   count_rts_success;
-	uint32_t   count_rts_failures;
-	uint32_t   count_ack_failures;
-	uint32_t   count_rx_multicast_frames;
-	uint32_t   count_rx_frames_success;
-	uint32_t   count_rx_cmacicv_errors;
-	uint32_t   count_rx_cmac_replays;
-	uint32_t   count_rx_mgmt_ccmp_replays;
-	uint32_t   count_rx_bipmic_errors;
+	u32   count_plcp_errors;
+	u32   count_fcs_errors;
+	u32   count_tx_packets;
+	u32   count_rx_packets;
+	u32   count_rx_packet_errors;
+	u32   count_rx_decryption_failures;
+	u32   count_rx_mic_failures;
+	u32   count_rx_no_key_failures;
+	u32   count_tx_multicast_frames;
+	u32   count_tx_frames_success;
+	u32   count_tx_frame_failures;
+	u32   count_tx_frames_retried;
+	u32   count_tx_frames_multi_retried;
+	u32   count_rx_frame_duplicates;
+	u32   count_rts_success;
+	u32   count_rts_failures;
+	u32   count_ack_failures;
+	u32   count_rx_multicast_frames;
+	u32   count_rx_frames_success;
+	u32   count_rx_cmacicv_errors;
+	u32   count_rx_cmac_replays;
+	u32   count_rx_mgmt_ccmp_replays;
+	u32   count_rx_bipmic_errors;
 } __packed;
 
 struct hif_mib_max_tx_power_level {
-	int32_t       max_tx_power_level_rf_port1;
-	int32_t       max_tx_power_level_rf_port2;
+	s32       max_tx_power_level_rf_port1;
+	s32       max_tx_power_level_rf_port2;
 } __packed;
 
 struct hif_mib_beacon_stats {
-	int32_t     latest_tbtt_diff;
-	uint32_t    reserved[4];
+	s32     latest_tbtt_diff;
+	u32    reserved[4];
 } __packed;
 
 struct hif_mib_mac_address {
-	uint8_t    mac_addr[ETH_ALEN];
-	uint16_t   reserved;
+	u8    mac_addr[ETH_ALEN];
+	u16   reserved;
 } __packed;
 
 struct hif_mib_dot11_max_transmit_msdu_lifetime {
-	uint32_t   max_life_time;
+	u32   max_life_time;
 } __packed;
 
 struct hif_mib_dot11_max_receive_lifetime {
-	uint32_t   max_life_time;
+	u32   max_life_time;
 } __packed;
 
 struct hif_mib_wep_default_key_id {
-	uint8_t    wep_default_key_id;
-	uint8_t    reserved[3];
+	u8    wep_default_key_id;
+	u8    reserved[3];
 } __packed;
 
 struct hif_mib_dot11_rts_threshold {
-	uint32_t   threshold;
+	u32   threshold;
 } __packed;
 
 struct hif_mib_slot_time {
-	uint32_t   slot_time;
+	u32   slot_time;
 } __packed;
 
 struct hif_mib_current_tx_power_level {
-	int32_t   power_level;
+	s32   power_level;
 } __packed;
 
 struct hif_mib_non_erp_protection {
-	uint8_t   use_cts_to_self:1;
-	uint8_t   reserved1:7;
-	uint8_t   reserved2[3];
+	u8   use_cts_to_self:1;
+	u8   reserved1:7;
+	u8   reserved2[3];
 } __packed;
 
 enum hif_tx_mode {
@@ -414,45 +414,45 @@ enum hif_tmplt {
 #define HIF_API_MAX_TEMPLATE_FRAME_SIZE                              700
 
 struct hif_mib_template_frame {
-	uint8_t    frame_type;
-	uint8_t    init_rate:7;
-	uint8_t    mode:1;
-	uint16_t   frame_length;
-	uint8_t    frame[HIF_API_MAX_TEMPLATE_FRAME_SIZE];
+	u8    frame_type;
+	u8    init_rate:7;
+	u8    mode:1;
+	u16   frame_length;
+	u8    frame[HIF_API_MAX_TEMPLATE_FRAME_SIZE];
 } __packed;
 
 struct hif_mib_beacon_wake_up_period {
-	uint8_t    wakeup_period_min;
-	uint8_t    receive_dtim:1;
-	uint8_t    reserved1:7;
-	uint8_t    wakeup_period_max;
-	uint8_t    reserved2;
+	u8    wakeup_period_min;
+	u8    receive_dtim:1;
+	u8    reserved1:7;
+	u8    wakeup_period_max;
+	u8    reserved2;
 } __packed;
 
 struct hif_mib_rcpi_rssi_threshold {
-	uint8_t    detection:1;
-	uint8_t    rcpi_rssi:1;
-	uint8_t    upperthresh:1;
-	uint8_t    lowerthresh:1;
-	uint8_t    reserved:4;
-	uint8_t    lower_threshold;
-	uint8_t    upper_threshold;
-	uint8_t    rolling_average_count;
+	u8    detection:1;
+	u8    rcpi_rssi:1;
+	u8    upperthresh:1;
+	u8    lowerthresh:1;
+	u8    reserved:4;
+	u8    lower_threshold;
+	u8    upper_threshold;
+	u8    rolling_average_count;
 } __packed;
 
 #define DEFAULT_BA_MAX_RX_BUFFER_SIZE 16
 
 struct hif_mib_block_ack_policy {
-	uint8_t    block_ack_tx_tid_policy;
-	uint8_t    reserved1;
-	uint8_t    block_ack_rx_tid_policy;
-	uint8_t    block_ack_rx_max_buffer_size;
+	u8    block_ack_tx_tid_policy;
+	u8    reserved1;
+	u8    block_ack_rx_tid_policy;
+	u8    block_ack_rx_max_buffer_size;
 } __packed;
 
 struct hif_mib_override_int_rate {
-	uint8_t    internal_tx_rate;
-	uint8_t    non_erp_internal_tx_rate;
-	uint8_t    reserved[2];
+	u8    internal_tx_rate;
+	u8    non_erp_internal_tx_rate;
+	u8    reserved[2];
 } __packed;
 
 enum hif_mpdu_start_spacing {
@@ -467,92 +467,91 @@ enum hif_mpdu_start_spacing {
 };
 
 struct hif_mib_set_association_mode {
-	uint8_t    preambtype_use:1;
-	uint8_t    mode:1;
-	uint8_t    rateset:1;
-	uint8_t    spacing:1;
-	uint8_t    reserved:4;
-	uint8_t    preamble_type;
-	uint8_t    mixed_or_greenfield_type;
-	uint8_t    mpdu_start_spacing;
-	uint32_t   basic_rate_set;
+	u8    preambtype_use:1;
+	u8    mode:1;
+	u8    rateset:1;
+	u8    spacing:1;
+	u8    reserved:4;
+	u8    preamble_type;
+	u8    mixed_or_greenfield_type;
+	u8    mpdu_start_spacing;
+	u32   basic_rate_set;
 } __packed;
 
 struct hif_mib_set_uapsd_information {
-	uint8_t    trig_bckgrnd:1;
-	uint8_t    trig_be:1;
-	uint8_t    trig_video:1;
-	uint8_t    trig_voice:1;
-	uint8_t    reserved1:4;
-	uint8_t    deliv_bckgrnd:1;
-	uint8_t    deliv_be:1;
-	uint8_t    deliv_video:1;
-	uint8_t    deliv_voice:1;
-	uint8_t    reserved2:4;
-	uint16_t   min_auto_trigger_interval;
-	uint16_t   max_auto_trigger_interval;
-	uint16_t   auto_trigger_step;
+	u8    trig_bckgrnd:1;
+	u8    trig_be:1;
+	u8    trig_video:1;
+	u8    trig_voice:1;
+	u8    reserved1:4;
+	u8    deliv_bckgrnd:1;
+	u8    deliv_be:1;
+	u8    deliv_video:1;
+	u8    deliv_voice:1;
+	u8    reserved2:4;
+	u16   min_auto_trigger_interval;
+	u16   max_auto_trigger_interval;
+	u16   auto_trigger_step;
 } __packed;
 
 struct hif_mib_tx_rate_retry_policy {
-	uint8_t    policy_index;
-	uint8_t    short_retry_count;
-	uint8_t    long_retry_count;
-	uint8_t    first_rate_sel:2;
-	uint8_t    terminate:1;
-	uint8_t    count_init:1;
-	uint8_t    reserved1:4;
-	uint8_t    rate_recovery_count;
-	uint8_t    reserved2[3];
-	uint8_t    rates[12];
+	u8    policy_index;
+	u8    short_retry_count;
+	u8    long_retry_count;
+	u8    first_rate_sel:2;
+	u8    terminate:1;
+	u8    count_init:1;
+	u8    reserved1:4;
+	u8    rate_recovery_count;
+	u8    reserved2[3];
+	u8    rates[12];
 } __packed;
 
 #define HIF_MIB_NUM_TX_RATE_RETRY_POLICIES    15
 
 struct hif_mib_set_tx_rate_retry_policy {
-	uint8_t    num_tx_rate_policies;
-	uint8_t    reserved[3];
+	u8    num_tx_rate_policies;
+	u8    reserved[3];
 	struct hif_mib_tx_rate_retry_policy tx_rate_retry_policy[];
 } __packed;
 
 struct hif_mib_protected_mgmt_policy {
-	uint8_t   pmf_enable:1;
-	uint8_t   unpmf_allowed:1;
-	uint8_t   host_enc_auth_frames:1;
-	uint8_t   reserved1:5;
-	uint8_t   reserved2[3];
+	u8   pmf_enable:1;
+	u8   unpmf_allowed:1;
+	u8   host_enc_auth_frames:1;
+	u8   reserved1:5;
+	u8   reserved2[3];
 } __packed;
 
 struct hif_mib_set_ht_protection {
-	uint8_t   dual_cts_prot:1;
-	uint8_t   reserved1:7;
-	uint8_t   reserved2[3];
+	u8   dual_cts_prot:1;
+	u8   reserved1:7;
+	u8   reserved2[3];
 } __packed;
 
 struct hif_mib_keep_alive_period {
-	uint16_t   keep_alive_period;
-	uint8_t    reserved[2];
+	u16   keep_alive_period;
+	u8    reserved[2];
 } __packed;
 
 struct hif_mib_arp_keep_alive_period {
-	uint16_t   arp_keep_alive_period;
-	uint8_t    encr_type;
-	uint8_t    reserved;
-	uint8_t    sender_ipv4_address[HIF_API_IPV4_ADDRESS_SIZE];
-	uint8_t    target_ipv4_address[HIF_API_IPV4_ADDRESS_SIZE];
+	u16   arp_keep_alive_period;
+	u8    encr_type;
+	u8    reserved;
+	u8    sender_ipv4_address[HIF_API_IPV4_ADDRESS_SIZE];
+	u8    target_ipv4_address[HIF_API_IPV4_ADDRESS_SIZE];
 } __packed;
 
 struct hif_mib_inactivity_timer {
-	uint8_t    min_active_time;
-	uint8_t    max_active_time;
-	uint16_t   reserved;
+	u8    min_active_time;
+	u8    max_active_time;
+	u16   reserved;
 } __packed;
 
 struct hif_mib_interface_protection {
-	uint8_t   use_cts_prot:1;
-	uint8_t   reserved1:7;
-	uint8_t   reserved2[3];
+	u8   use_cts_prot:1;
+	u8   reserved1:7;
+	u8   reserved2[3];
 } __packed;
 
-
 #endif

commit c22a3a9c0a87d2064cbe744b1b393569d0621474
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Thu Oct 17 09:40:07 2019 +0000

    staging: wfx: fix number of available tx_policies
    
    Original API declares 16 tx_policies. But in fact, the 16th is used
    internally by the firmware. So, only 15 tx_policies are available for
    driver.
    
    Reported-by: Alban Jeantheau <alban.jeantheau@silabs.com>
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20191017093954.657-6-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/hif_api_mib.h b/drivers/staging/wfx/hif_api_mib.h
index 3c56ef2978a2..af657555f894 100644
--- a/drivers/staging/wfx/hif_api_mib.h
+++ b/drivers/staging/wfx/hif_api_mib.h
@@ -507,7 +507,7 @@ struct hif_mib_tx_rate_retry_policy {
 	uint8_t    rates[12];
 } __packed;
 
-#define HIF_MIB_NUM_TX_RATE_RETRY_POLICIES    16
+#define HIF_MIB_NUM_TX_RATE_RETRY_POLICIES    15
 
 struct hif_mib_set_tx_rate_retry_policy {
 	uint8_t    num_tx_rate_policies;

commit e4ee3cb3efc67893ad7d8e27176e5cfee6f3c7dc
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Thu Sep 19 14:25:39 2019 +0000

    staging: wfx: import HIF API headers
    
    These files are shared with firmware sources. Only a subset of these
    definitions are used by driver but, for now, it is easier to import all.
    
    API defines 3 kinds of messages:
       - Requests (req) are sent from host to chip
       - Confirmations (cnf) are sent by chip and are always in reply to a
         request
       - Indications (ind) are spontaneous message from chip to host
    
    One request normally generate one confirmation. There are a few
    exceptions to this rule:
       - "shutdown" request is not acknowledged
       - multiple tx request can be acknowledged a unique "multi-tx"
         confirmation
    
    In add, API defines MIB. They are sub-structures for write_mib and
    read_mib API.
    
    Note that all numbers in API have to be little endian when sent/received
    from/to chip (I didn't declared them with __le32 because driver also use
    them internally).
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20190919142527.31797-7-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/hif_api_mib.h b/drivers/staging/wfx/hif_api_mib.h
new file mode 100644
index 000000000000..3c56ef2978a2
--- /dev/null
+++ b/drivers/staging/wfx/hif_api_mib.h
@@ -0,0 +1,558 @@
+/* SPDX-License-Identifier: Apache-2.0 */
+/*
+ * WFx hardware interface definitions
+ *
+ * Copyright (c) 2018-2019, Silicon Laboratories Inc.
+ */
+
+#ifndef WFX_HIF_API_MIB_H
+#define WFX_HIF_API_MIB_H
+
+#include "hif_api_general.h"
+
+#define HIF_API_IPV4_ADDRESS_SIZE                       4
+#define HIF_API_IPV6_ADDRESS_SIZE                       16
+
+enum hif_mib_ids {
+	HIF_MIB_ID_GL_OPERATIONAL_POWER_MODE       = 0x2000,
+	HIF_MIB_ID_GL_BLOCK_ACK_INFO               = 0x2001,
+	HIF_MIB_ID_GL_SET_MULTI_MSG                = 0x2002,
+	HIF_MIB_ID_CCA_CONFIG                      = 0x2003,
+	HIF_MIB_ID_ETHERTYPE_DATAFRAME_CONDITION   = 0x2010,
+	HIF_MIB_ID_PORT_DATAFRAME_CONDITION        = 0x2011,
+	HIF_MIB_ID_MAGIC_DATAFRAME_CONDITION       = 0x2012,
+	HIF_MIB_ID_MAC_ADDR_DATAFRAME_CONDITION    = 0x2013,
+	HIF_MIB_ID_IPV4_ADDR_DATAFRAME_CONDITION   = 0x2014,
+	HIF_MIB_ID_IPV6_ADDR_DATAFRAME_CONDITION   = 0x2015,
+	HIF_MIB_ID_UC_MC_BC_DATAFRAME_CONDITION    = 0x2016,
+	HIF_MIB_ID_CONFIG_DATA_FILTER              = 0x2017,
+	HIF_MIB_ID_SET_DATA_FILTERING              = 0x2018,
+	HIF_MIB_ID_ARP_IP_ADDRESSES_TABLE          = 0x2019,
+	HIF_MIB_ID_NS_IP_ADDRESSES_TABLE           = 0x201A,
+	HIF_MIB_ID_RX_FILTER                       = 0x201B,
+	HIF_MIB_ID_BEACON_FILTER_TABLE             = 0x201C,
+	HIF_MIB_ID_BEACON_FILTER_ENABLE            = 0x201D,
+	HIF_MIB_ID_GRP_SEQ_COUNTER                 = 0x2030,
+	HIF_MIB_ID_TSF_COUNTER                     = 0x2031,
+	HIF_MIB_ID_STATISTICS_TABLE                = 0x2032,
+	HIF_MIB_ID_COUNTERS_TABLE                  = 0x2033,
+	HIF_MIB_ID_MAX_TX_POWER_LEVEL              = 0x2034,
+	HIF_MIB_ID_EXTENDED_COUNTERS_TABLE         = 0x2035,
+	HIF_MIB_ID_DOT11_MAC_ADDRESS               = 0x2040,
+	HIF_MIB_ID_DOT11_MAX_TRANSMIT_MSDU_LIFETIME = 0x2041,
+	HIF_MIB_ID_DOT11_MAX_RECEIVE_LIFETIME      = 0x2042,
+	HIF_MIB_ID_DOT11_WEP_DEFAULT_KEY_ID        = 0x2043,
+	HIF_MIB_ID_DOT11_RTS_THRESHOLD             = 0x2044,
+	HIF_MIB_ID_SLOT_TIME                       = 0x2045,
+	HIF_MIB_ID_CURRENT_TX_POWER_LEVEL          = 0x2046,
+	HIF_MIB_ID_NON_ERP_PROTECTION              = 0x2047,
+	HIF_MIB_ID_TEMPLATE_FRAME                  = 0x2048,
+	HIF_MIB_ID_BEACON_WAKEUP_PERIOD            = 0x2049,
+	HIF_MIB_ID_RCPI_RSSI_THRESHOLD             = 0x204A,
+	HIF_MIB_ID_BLOCK_ACK_POLICY                = 0x204B,
+	HIF_MIB_ID_OVERRIDE_INTERNAL_TX_RATE       = 0x204C,
+	HIF_MIB_ID_SET_ASSOCIATION_MODE            = 0x204D,
+	HIF_MIB_ID_SET_UAPSD_INFORMATION           = 0x204E,
+	HIF_MIB_ID_SET_TX_RATE_RETRY_POLICY        = 0x204F,
+	HIF_MIB_ID_PROTECTED_MGMT_POLICY           = 0x2050,
+	HIF_MIB_ID_SET_HT_PROTECTION               = 0x2051,
+	HIF_MIB_ID_KEEP_ALIVE_PERIOD               = 0x2052,
+	HIF_MIB_ID_ARP_KEEP_ALIVE_PERIOD           = 0x2053,
+	HIF_MIB_ID_INACTIVITY_TIMER                = 0x2054,
+	HIF_MIB_ID_INTERFACE_PROTECTION            = 0x2055,
+	HIF_MIB_ID_BEACON_STATS                    = 0x2056,
+};
+
+#define HIF_OP_POWER_MODE_MASK                     0xf
+
+enum hif_op_power_mode {
+	HIF_OP_POWER_MODE_ACTIVE                   = 0x0,
+	HIF_OP_POWER_MODE_DOZE                     = 0x1,
+	HIF_OP_POWER_MODE_QUIESCENT                = 0x2
+};
+
+struct hif_mib_gl_operational_power_mode {
+	uint8_t    power_mode:4;
+	uint8_t    reserved1:3;
+	uint8_t    wup_ind_activation:1;
+	uint8_t    reserved2[3];
+} __packed;
+
+struct hif_mib_gl_block_ack_info {
+	uint8_t    rx_buffer_size;
+	uint8_t    rx_max_num_agreements;
+	uint8_t    tx_buffer_size;
+	uint8_t    tx_max_num_agreements;
+} __packed;
+
+struct hif_mib_gl_set_multi_msg {
+	uint8_t    enable_multi_tx_conf:1;
+	uint8_t    reserved1:7;
+	uint8_t    reserved2[3];
+} __packed;
+
+enum hif_cca_thr_mode {
+	HIF_CCA_THR_MODE_RELATIVE = 0x0,
+	HIF_CCA_THR_MODE_ABSOLUTE = 0x1
+};
+
+struct hif_mib_gl_cca_config {
+	uint8_t  cca_thr_mode;
+	uint8_t  reserved[3];
+} __packed;
+
+#define MAX_NUMBER_DATA_FILTERS             0xA
+
+#define MAX_NUMBER_IPV4_ADDR_CONDITIONS     0x4
+#define MAX_NUMBER_IPV6_ADDR_CONDITIONS     0x4
+#define MAX_NUMBER_MAC_ADDR_CONDITIONS      0x4
+#define MAX_NUMBER_UC_MC_BC_CONDITIONS      0x4
+#define MAX_NUMBER_ETHER_TYPE_CONDITIONS    0x4
+#define MAX_NUMBER_PORT_CONDITIONS          0x4
+#define MAX_NUMBER_MAGIC_CONDITIONS         0x4
+#define MAX_NUMBER_ARP_CONDITIONS           0x2
+#define MAX_NUMBER_NS_CONDITIONS            0x2
+
+struct hif_mib_ethertype_data_frame_condition {
+	uint8_t    condition_idx;
+	uint8_t    reserved;
+	uint16_t   ether_type;
+} __packed;
+
+enum hif_udp_tcp_protocol {
+	HIF_PROTOCOL_UDP                       = 0x0,
+	HIF_PROTOCOL_TCP                       = 0x1,
+	HIF_PROTOCOL_BOTH_UDP_TCP              = 0x2
+};
+
+enum hif_which_port {
+	HIF_PORT_DST                           = 0x0,
+	HIF_PORT_SRC                           = 0x1,
+	HIF_PORT_SRC_OR_DST                    = 0x2
+};
+
+struct hif_mib_ports_data_frame_condition {
+	uint8_t    condition_idx;
+	uint8_t    protocol;
+	uint8_t    which_port;
+	uint8_t    reserved1;
+	uint16_t   port_number;
+	uint8_t    reserved2[2];
+} __packed;
+
+#define HIF_API_MAGIC_PATTERN_SIZE                 32
+
+struct hif_mib_magic_data_frame_condition {
+	uint8_t    condition_idx;
+	uint8_t    offset;
+	uint8_t    magic_pattern_length;
+	uint8_t    reserved;
+	uint8_t    magic_pattern[HIF_API_MAGIC_PATTERN_SIZE];
+} __packed;
+
+enum hif_mac_addr_type {
+	HIF_MAC_ADDR_A1                            = 0x0,
+	HIF_MAC_ADDR_A2                            = 0x1,
+	HIF_MAC_ADDR_A3                            = 0x2
+};
+
+struct hif_mib_mac_addr_data_frame_condition {
+	uint8_t    condition_idx;
+	uint8_t    address_type;
+	uint8_t    mac_address[ETH_ALEN];
+} __packed;
+
+enum hif_ip_addr_mode {
+	HIF_IP_ADDR_SRC                            = 0x0,
+	HIF_IP_ADDR_DST                            = 0x1
+};
+
+struct hif_mib_ipv4_addr_data_frame_condition {
+	uint8_t    condition_idx;
+	uint8_t    address_mode;
+	uint8_t    reserved[2];
+	uint8_t    i_pv4_address[HIF_API_IPV4_ADDRESS_SIZE];
+} __packed;
+
+struct hif_mib_ipv6_addr_data_frame_condition {
+	uint8_t    condition_idx;
+	uint8_t    address_mode;
+	uint8_t    reserved[2];
+	uint8_t    i_pv6_address[HIF_API_IPV6_ADDRESS_SIZE];
+} __packed;
+
+union hif_addr_type {
+	uint8_t value;
+	struct {
+		uint8_t    type_unicast:1;
+		uint8_t    type_multicast:1;
+		uint8_t    type_broadcast:1;
+		uint8_t    reserved:5;
+	} bits;
+};
+
+struct hif_mib_uc_mc_bc_data_frame_condition {
+	uint8_t    condition_idx;
+	union hif_addr_type param;
+	uint8_t    reserved[2];
+} __packed;
+
+struct hif_mib_config_data_filter {
+	uint8_t    filter_idx;
+	uint8_t    enable;
+	uint8_t    reserved1[2];
+	uint8_t    eth_type_cond;
+	uint8_t    port_cond;
+	uint8_t    magic_cond;
+	uint8_t    mac_cond;
+	uint8_t    ipv4_cond;
+	uint8_t    ipv6_cond;
+	uint8_t    uc_mc_bc_cond;
+	uint8_t    reserved2;
+} __packed;
+
+struct hif_mib_set_data_filtering {
+	uint8_t    default_filter;
+	uint8_t    enable;
+	uint8_t    reserved[2];
+} __packed;
+
+enum hif_arp_ns_frame_treatment {
+	HIF_ARP_NS_FILTERING_DISABLE                  = 0x0,
+	HIF_ARP_NS_FILTERING_ENABLE                   = 0x1,
+	HIF_ARP_NS_REPLY_ENABLE                       = 0x2
+};
+
+struct hif_mib_arp_ip_addr_table {
+	uint8_t    condition_idx;
+	uint8_t    arp_enable;
+	uint8_t    reserved[2];
+	uint8_t    ipv4_address[HIF_API_IPV4_ADDRESS_SIZE];
+} __packed;
+
+struct hif_mib_ns_ip_addr_table {
+	uint8_t    condition_idx;
+	uint8_t    ns_enable;
+	uint8_t    reserved[2];
+	uint8_t    ipv6_address[HIF_API_IPV6_ADDRESS_SIZE];
+} __packed;
+
+struct hif_mib_rx_filter {
+	uint8_t    reserved1:1;
+	uint8_t    bssid_filter:1;
+	uint8_t    reserved2:1;
+	uint8_t    fwd_probe_req:1;
+	uint8_t    keep_alive_filter:1;
+	uint8_t    reserved3:3;
+	uint8_t    reserved4[3];
+} __packed;
+
+#define HIF_API_OUI_SIZE                                3
+#define HIF_API_MATCH_DATA_SIZE                         3
+
+struct hif_ie_table_entry {
+	uint8_t    ie_id;
+	uint8_t    has_changed:1;
+	uint8_t    no_longer:1;
+	uint8_t    has_appeared:1;
+	uint8_t    reserved:1;
+	uint8_t    num_match_data:4;
+	uint8_t    oui[HIF_API_OUI_SIZE];
+	uint8_t    match_data[HIF_API_MATCH_DATA_SIZE];
+} __packed;
+
+struct hif_mib_bcn_filter_table {
+	uint32_t   num_of_info_elmts;
+	struct hif_ie_table_entry ie_table[];
+} __packed;
+
+enum hif_beacon_filter {
+	HIF_BEACON_FILTER_DISABLE                  = 0x0,
+	HIF_BEACON_FILTER_ENABLE                   = 0x1,
+	HIF_BEACON_FILTER_AUTO_ERP                 = 0x2
+};
+
+struct hif_mib_bcn_filter_enable {
+	uint32_t   enable;
+	uint32_t   bcn_count;
+} __packed;
+
+struct hif_mib_group_seq_counter {
+	uint32_t   bits4716;
+	uint16_t   bits1500;
+	uint16_t   reserved;
+} __packed;
+
+struct hif_mib_tsf_counter {
+	uint32_t   tsf_counterlo;
+	uint32_t   tsf_counterhi;
+} __packed;
+
+struct hif_mib_stats_table {
+	int16_t    latest_snr;
+	uint8_t    latest_rcpi;
+	int8_t     latest_rssi;
+} __packed;
+
+struct hif_mib_extended_count_table {
+	uint32_t   count_plcp_errors;
+	uint32_t   count_fcs_errors;
+	uint32_t   count_tx_packets;
+	uint32_t   count_rx_packets;
+	uint32_t   count_rx_packet_errors;
+	uint32_t   count_rx_decryption_failures;
+	uint32_t   count_rx_mic_failures;
+	uint32_t   count_rx_no_key_failures;
+	uint32_t   count_tx_multicast_frames;
+	uint32_t   count_tx_frames_success;
+	uint32_t   count_tx_frame_failures;
+	uint32_t   count_tx_frames_retried;
+	uint32_t   count_tx_frames_multi_retried;
+	uint32_t   count_rx_frame_duplicates;
+	uint32_t   count_rts_success;
+	uint32_t   count_rts_failures;
+	uint32_t   count_ack_failures;
+	uint32_t   count_rx_multicast_frames;
+	uint32_t   count_rx_frames_success;
+	uint32_t   count_rx_cmacicv_errors;
+	uint32_t   count_rx_cmac_replays;
+	uint32_t   count_rx_mgmt_ccmp_replays;
+	uint32_t   count_rx_bipmic_errors;
+	uint32_t   count_rx_beacon;
+	uint32_t   count_miss_beacon;
+	uint32_t   reserved[15];
+} __packed;
+
+struct hif_mib_count_table {
+	uint32_t   count_plcp_errors;
+	uint32_t   count_fcs_errors;
+	uint32_t   count_tx_packets;
+	uint32_t   count_rx_packets;
+	uint32_t   count_rx_packet_errors;
+	uint32_t   count_rx_decryption_failures;
+	uint32_t   count_rx_mic_failures;
+	uint32_t   count_rx_no_key_failures;
+	uint32_t   count_tx_multicast_frames;
+	uint32_t   count_tx_frames_success;
+	uint32_t   count_tx_frame_failures;
+	uint32_t   count_tx_frames_retried;
+	uint32_t   count_tx_frames_multi_retried;
+	uint32_t   count_rx_frame_duplicates;
+	uint32_t   count_rts_success;
+	uint32_t   count_rts_failures;
+	uint32_t   count_ack_failures;
+	uint32_t   count_rx_multicast_frames;
+	uint32_t   count_rx_frames_success;
+	uint32_t   count_rx_cmacicv_errors;
+	uint32_t   count_rx_cmac_replays;
+	uint32_t   count_rx_mgmt_ccmp_replays;
+	uint32_t   count_rx_bipmic_errors;
+} __packed;
+
+struct hif_mib_max_tx_power_level {
+	int32_t       max_tx_power_level_rf_port1;
+	int32_t       max_tx_power_level_rf_port2;
+} __packed;
+
+struct hif_mib_beacon_stats {
+	int32_t     latest_tbtt_diff;
+	uint32_t    reserved[4];
+} __packed;
+
+struct hif_mib_mac_address {
+	uint8_t    mac_addr[ETH_ALEN];
+	uint16_t   reserved;
+} __packed;
+
+struct hif_mib_dot11_max_transmit_msdu_lifetime {
+	uint32_t   max_life_time;
+} __packed;
+
+struct hif_mib_dot11_max_receive_lifetime {
+	uint32_t   max_life_time;
+} __packed;
+
+struct hif_mib_wep_default_key_id {
+	uint8_t    wep_default_key_id;
+	uint8_t    reserved[3];
+} __packed;
+
+struct hif_mib_dot11_rts_threshold {
+	uint32_t   threshold;
+} __packed;
+
+struct hif_mib_slot_time {
+	uint32_t   slot_time;
+} __packed;
+
+struct hif_mib_current_tx_power_level {
+	int32_t   power_level;
+} __packed;
+
+struct hif_mib_non_erp_protection {
+	uint8_t   use_cts_to_self:1;
+	uint8_t   reserved1:7;
+	uint8_t   reserved2[3];
+} __packed;
+
+enum hif_tx_mode {
+	HIF_TX_MODE_MIXED                        = 0x0,
+	HIF_TX_MODE_GREENFIELD                   = 0x1
+};
+
+enum hif_tmplt {
+	HIF_TMPLT_PRBREQ                           = 0x0,
+	HIF_TMPLT_BCN                              = 0x1,
+	HIF_TMPLT_NULL                             = 0x2,
+	HIF_TMPLT_QOSNUL                           = 0x3,
+	HIF_TMPLT_PSPOLL                           = 0x4,
+	HIF_TMPLT_PRBRES                           = 0x5,
+	HIF_TMPLT_ARP                              = 0x6,
+	HIF_TMPLT_NA                               = 0x7
+};
+
+#define HIF_API_MAX_TEMPLATE_FRAME_SIZE                              700
+
+struct hif_mib_template_frame {
+	uint8_t    frame_type;
+	uint8_t    init_rate:7;
+	uint8_t    mode:1;
+	uint16_t   frame_length;
+	uint8_t    frame[HIF_API_MAX_TEMPLATE_FRAME_SIZE];
+} __packed;
+
+struct hif_mib_beacon_wake_up_period {
+	uint8_t    wakeup_period_min;
+	uint8_t    receive_dtim:1;
+	uint8_t    reserved1:7;
+	uint8_t    wakeup_period_max;
+	uint8_t    reserved2;
+} __packed;
+
+struct hif_mib_rcpi_rssi_threshold {
+	uint8_t    detection:1;
+	uint8_t    rcpi_rssi:1;
+	uint8_t    upperthresh:1;
+	uint8_t    lowerthresh:1;
+	uint8_t    reserved:4;
+	uint8_t    lower_threshold;
+	uint8_t    upper_threshold;
+	uint8_t    rolling_average_count;
+} __packed;
+
+#define DEFAULT_BA_MAX_RX_BUFFER_SIZE 16
+
+struct hif_mib_block_ack_policy {
+	uint8_t    block_ack_tx_tid_policy;
+	uint8_t    reserved1;
+	uint8_t    block_ack_rx_tid_policy;
+	uint8_t    block_ack_rx_max_buffer_size;
+} __packed;
+
+struct hif_mib_override_int_rate {
+	uint8_t    internal_tx_rate;
+	uint8_t    non_erp_internal_tx_rate;
+	uint8_t    reserved[2];
+} __packed;
+
+enum hif_mpdu_start_spacing {
+	HIF_MPDU_START_SPACING_NO_RESTRIC          = 0x0,
+	HIF_MPDU_START_SPACING_QUARTER             = 0x1,
+	HIF_MPDU_START_SPACING_HALF                = 0x2,
+	HIF_MPDU_START_SPACING_ONE                 = 0x3,
+	HIF_MPDU_START_SPACING_TWO                 = 0x4,
+	HIF_MPDU_START_SPACING_FOUR                = 0x5,
+	HIF_MPDU_START_SPACING_EIGHT               = 0x6,
+	HIF_MPDU_START_SPACING_SIXTEEN             = 0x7
+};
+
+struct hif_mib_set_association_mode {
+	uint8_t    preambtype_use:1;
+	uint8_t    mode:1;
+	uint8_t    rateset:1;
+	uint8_t    spacing:1;
+	uint8_t    reserved:4;
+	uint8_t    preamble_type;
+	uint8_t    mixed_or_greenfield_type;
+	uint8_t    mpdu_start_spacing;
+	uint32_t   basic_rate_set;
+} __packed;
+
+struct hif_mib_set_uapsd_information {
+	uint8_t    trig_bckgrnd:1;
+	uint8_t    trig_be:1;
+	uint8_t    trig_video:1;
+	uint8_t    trig_voice:1;
+	uint8_t    reserved1:4;
+	uint8_t    deliv_bckgrnd:1;
+	uint8_t    deliv_be:1;
+	uint8_t    deliv_video:1;
+	uint8_t    deliv_voice:1;
+	uint8_t    reserved2:4;
+	uint16_t   min_auto_trigger_interval;
+	uint16_t   max_auto_trigger_interval;
+	uint16_t   auto_trigger_step;
+} __packed;
+
+struct hif_mib_tx_rate_retry_policy {
+	uint8_t    policy_index;
+	uint8_t    short_retry_count;
+	uint8_t    long_retry_count;
+	uint8_t    first_rate_sel:2;
+	uint8_t    terminate:1;
+	uint8_t    count_init:1;
+	uint8_t    reserved1:4;
+	uint8_t    rate_recovery_count;
+	uint8_t    reserved2[3];
+	uint8_t    rates[12];
+} __packed;
+
+#define HIF_MIB_NUM_TX_RATE_RETRY_POLICIES    16
+
+struct hif_mib_set_tx_rate_retry_policy {
+	uint8_t    num_tx_rate_policies;
+	uint8_t    reserved[3];
+	struct hif_mib_tx_rate_retry_policy tx_rate_retry_policy[];
+} __packed;
+
+struct hif_mib_protected_mgmt_policy {
+	uint8_t   pmf_enable:1;
+	uint8_t   unpmf_allowed:1;
+	uint8_t   host_enc_auth_frames:1;
+	uint8_t   reserved1:5;
+	uint8_t   reserved2[3];
+} __packed;
+
+struct hif_mib_set_ht_protection {
+	uint8_t   dual_cts_prot:1;
+	uint8_t   reserved1:7;
+	uint8_t   reserved2[3];
+} __packed;
+
+struct hif_mib_keep_alive_period {
+	uint16_t   keep_alive_period;
+	uint8_t    reserved[2];
+} __packed;
+
+struct hif_mib_arp_keep_alive_period {
+	uint16_t   arp_keep_alive_period;
+	uint8_t    encr_type;
+	uint8_t    reserved;
+	uint8_t    sender_ipv4_address[HIF_API_IPV4_ADDRESS_SIZE];
+	uint8_t    target_ipv4_address[HIF_API_IPV4_ADDRESS_SIZE];
+} __packed;
+
+struct hif_mib_inactivity_timer {
+	uint8_t    min_active_time;
+	uint8_t    max_active_time;
+	uint16_t   reserved;
+} __packed;
+
+struct hif_mib_interface_protection {
+	uint8_t   use_cts_prot:1;
+	uint8_t   reserved1:7;
+	uint8_t   reserved2[3];
+} __packed;
+
+
+#endif
