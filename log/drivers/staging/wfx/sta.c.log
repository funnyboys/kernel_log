commit 398999dabc8cfc51c7274639cb87e2a316138859
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Tue May 26 19:18:17 2020 +0200

    staging: wfx: split wfx_get_ps_timeout() from wfx_update_pm()
    
    In the next commit, we will have to compute the PS timeout without
    changing the power save status of the device. This patch introduces
    wfx_get_ps_timeout() for that job and make wfx_update_pm() relies on it.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200526171821.934581-7-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index d0ab0b8dc404..12e8a5b638f1 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -200,36 +200,49 @@ void wfx_configure_filter(struct ieee80211_hw *hw, unsigned int changed_flags,
 	mutex_unlock(&wdev->conf_mutex);
 }
 
-static int wfx_update_pm(struct wfx_vif *wvif)
+int wfx_get_ps_timeout(struct wfx_vif *wvif, bool *enable_ps)
 {
-	struct ieee80211_conf *conf = &wvif->wdev->hw->conf;
-	bool ps = wvif->vif->bss_conf.ps;
-	int ps_timeout = conf->dynamic_ps_timeout;
 	struct ieee80211_channel *chan0 = NULL, *chan1 = NULL;
+	struct ieee80211_conf *conf = &wvif->wdev->hw->conf;
 
-	WARN_ON(conf->dynamic_ps_timeout < 0);
-	if (!wvif->vif->bss_conf.assoc)
-		return 0;
-	if (!ps)
-		ps_timeout = 0;
-	if (wvif->uapsd_mask)
-		ps_timeout = 0;
-
-	// Kernel disable powersave when an AP is in use. In contrary, it is
-	// absolutely necessary to enable legacy powersave for WF200 if channels
-	// are differents.
+	WARN(!wvif->vif->bss_conf.assoc && enable_ps,
+	     "enable_ps is reliable only if associated");
 	if (wdev_to_wvif(wvif->wdev, 0))
 		chan0 = wdev_to_wvif(wvif->wdev, 0)->vif->bss_conf.chandef.chan;
 	if (wdev_to_wvif(wvif->wdev, 1))
 		chan1 = wdev_to_wvif(wvif->wdev, 1)->vif->bss_conf.chandef.chan;
 	if (chan0 && chan1 && chan0->hw_value != chan1->hw_value &&
 	    wvif->vif->type != NL80211_IFTYPE_AP) {
-		ps = true;
+		// It is necessary to enable powersave if channels
+		// are differents.
+		if (enable_ps)
+			*enable_ps = true;
 		if (wvif->bss_not_support_ps_poll)
-			ps_timeout = 30;
+			return 30;
 		else
-			ps_timeout = 0;
+			return 0;
 	}
+	if (enable_ps)
+		*enable_ps = wvif->vif->bss_conf.ps;
+	if (wvif->vif->bss_conf.assoc && wvif->vif->bss_conf.ps)
+		return conf->dynamic_ps_timeout;
+	else
+		return -1;
+}
+
+int wfx_update_pm(struct wfx_vif *wvif)
+{
+	int ps_timeout;
+	bool ps;
+
+	if (!wvif->vif->bss_conf.assoc)
+		return 0;
+	ps_timeout = wfx_get_ps_timeout(wvif, &ps);
+	if (!ps)
+		ps_timeout = 0;
+	WARN_ON(ps_timeout < 0);
+	if (wvif->uapsd_mask)
+		ps_timeout = 0;
 
 	if (!wait_for_completion_timeout(&wvif->set_pm_mode_complete,
 					 TU_TO_JIFFIES(512)))

commit 9a9cd090e996f80ec9edbd8ea58192f25e21ec74
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Tue May 26 19:18:16 2020 +0200

    staging: wfx: retrieve the PS status from the vif
    
    The Power Save status is stored for each virtual interface and for the
    whole device. The WF200 is able to handle power saving per interface, so
    use the value stored in vif.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200526171821.934581-6-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index 6015cd2c4d8a..d0ab0b8dc404 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -203,7 +203,7 @@ void wfx_configure_filter(struct ieee80211_hw *hw, unsigned int changed_flags,
 static int wfx_update_pm(struct wfx_vif *wvif)
 {
 	struct ieee80211_conf *conf = &wvif->wdev->hw->conf;
-	bool ps = conf->flags & IEEE80211_CONF_PS;
+	bool ps = wvif->vif->bss_conf.ps;
 	int ps_timeout = conf->dynamic_ps_timeout;
 	struct ieee80211_channel *chan0 = NULL, *chan1 = NULL;
 

commit c336c022503d1be719ca06f2526c211709e3d2d3
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Fri May 15 10:33:25 2020 +0200

    staging: wfx: remove false positive warning
    
    When a station is removed, the driver check that all the Tx frames were
    correctly sent. However, the station can be removed before all the Tx
    frames were acknowledged and a false positive warning can be emitted.
    
    The previous commit has added a trace when driver received an
    acknowledge for a non-existent station. It appear that these events
    are perfectly correlated and there is no leak.
    
    Now, the subject is perfectly understood. Remove the warning. Just keep
    a debug trace in case we have any doubt in the future.
    
    In the past, the subject has already been discussed here:
       https://lore.kernel.org/driverdev-devel/6287924.ghGFUMk3OD@pc-42/
    
    Fixes: 4bbc6a3e7ad0 ("staging: wfx: make warning about pending frame less scary")
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200515083325.378539-20-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index f448957c1a92..6015cd2c4d8a 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -441,8 +441,10 @@ int wfx_sta_remove(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 
 	for (i = 0; i < ARRAY_SIZE(sta_priv->buffered); i++)
 		if (sta_priv->buffered[i])
-			dev_warn(wvif->wdev->dev, "release station while %d pending frame on queue %d",
-				 sta_priv->buffered[i], i);
+			// Not an error if paired with trace in
+			// wfx_tx_update_sta()
+			dev_dbg(wvif->wdev->dev, "release station while %d pending frame on queue %d",
+				sta_priv->buffered[i], i);
 	// See note in wfx_sta_add()
 	if (!sta_priv->link_id)
 		return 0;

commit a1ae4d07fd94da1b3f7597f1594af2e35f1065cc
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Fri May 15 10:33:22 2020 +0200

    staging: wfx: fix error reporting in wfx_start_ap()
    
    If AP did not start, the error was not reported to mac80211.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200515083325.378539-17-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index 57304ed42e79..f448957c1a92 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -476,14 +476,17 @@ int wfx_start_ap(struct ieee80211_hw *hw, struct ieee80211_vif *vif)
 {
 	struct wfx_vif *wvif = (struct wfx_vif *)vif->drv_priv;
 	struct wfx_dev *wdev = wvif->wdev;
+	int ret;
 
 	wvif =  NULL;
 	while ((wvif = wvif_iterate(wdev, wvif)) != NULL)
 		wfx_update_pm(wvif);
 	wvif = (struct wfx_vif *)vif->drv_priv;
 	wfx_upload_ap_templates(wvif);
-	hif_start(wvif, &vif->bss_conf, wvif->channel);
-	return 0;
+	ret = hif_start(wvif, &vif->bss_conf, wvif->channel);
+	if (ret > 0)
+		return -EIO;
+	return ret;
 }
 
 void wfx_stop_ap(struct ieee80211_hw *hw, struct ieee80211_vif *vif)

commit ac0e50a5a3cb6b6c41c4e568144f780a89bd0d54
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Fri May 15 10:33:21 2020 +0200

    staging: wfx: drop unnecessary filter configuration when disabling filter
    
    Currently, when mac80211 want to disable beacon filtering, the driver
    reset the filter table and disable the beacon filtering. Only the latter
    action is required.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200515083325.378539-16-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index 0cb7315bb050..57304ed42e79 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -84,7 +84,6 @@ static void wfx_filter_beacon(struct wfx_vif *wvif, bool filter_beacon)
 	};
 
 	if (!filter_beacon) {
-		hif_set_beacon_filter_table(wvif, 0, NULL);
 		hif_beacon_filter_control(wvif, 0, 1);
 	} else {
 		hif_set_beacon_filter_table(wvif, 3, filter_ies);

commit f75818c251cb31c47e751ce15f97758a92132df7
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Fri May 15 10:33:20 2020 +0200

    staging: wfx: fix PS parameters when multiple vif are in use
    
    When multiple vif are in use (= one access point and one station), and
    when the channels are different, it is necessary to enable power save on
    station.
    
    The firmware check that steps are done in the correct order:
      - AP can't start if PS is not enable on the station
      - PS can't set on the station before the association has finished
        (= before the call set_bss_params)
    
    Obviously, in add, when one of the interface disappears, it is necessary to
    restore the power save status.
    
    wfx_update_pm() is able to set the correct PS configuration. But it has
    to be called at the right time:
       1. before hif_start(), but after the channel configuration is known
       2. after hif_set_bss_params()
       3. after hif_reset()
    
    Therefore, the call to wfx_update_pm() from wfx_add_interface() is too
    early to address 1.
    
    The call after hif_set_bss_params() already exists.
    
    For the symmetry, the call from wfx_remove_interface() (that handle 3.)
    is also relocated.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200515083325.378539-15-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index 6e9f38d051ab..0cb7315bb050 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -347,15 +347,20 @@ static void wfx_set_mfp(struct wfx_vif *wvif,
 
 void wfx_reset(struct wfx_vif *wvif)
 {
-	wfx_tx_lock_flush(wvif->wdev);
+	struct wfx_dev *wdev = wvif->wdev;
+
+	wfx_tx_lock_flush(wdev);
 	hif_reset(wvif, false);
 	wfx_tx_policy_init(wvif);
-	if (wvif_count(wvif->wdev) <= 1)
+	if (wvif_count(wdev) <= 1)
 		hif_set_block_ack_policy(wvif, 0xFF, 0xFF);
-	wfx_tx_unlock(wvif->wdev);
+	wfx_tx_unlock(wdev);
 	wvif->join_in_progress = false;
 	wvif->bss_not_support_ps_poll = false;
 	cancel_delayed_work_sync(&wvif->beacon_loss_work);
+	wvif =  NULL;
+	while ((wvif = wvif_iterate(wdev, wvif)) != NULL)
+		wfx_update_pm(wvif);
 }
 
 static void wfx_do_join(struct wfx_vif *wvif)
@@ -471,7 +476,12 @@ static int wfx_upload_ap_templates(struct wfx_vif *wvif)
 int wfx_start_ap(struct ieee80211_hw *hw, struct ieee80211_vif *vif)
 {
 	struct wfx_vif *wvif = (struct wfx_vif *)vif->drv_priv;
+	struct wfx_dev *wdev = wvif->wdev;
 
+	wvif =  NULL;
+	while ((wvif = wvif_iterate(wdev, wvif)) != NULL)
+		wfx_update_pm(wvif);
+	wvif = (struct wfx_vif *)vif->drv_priv;
 	wfx_upload_ap_templates(wvif);
 	hif_start(wvif, &vif->bss_conf, wvif->channel);
 	return 0;
@@ -786,8 +796,6 @@ int wfx_add_interface(struct ieee80211_hw *hw, struct ieee80211_vif *vif)
 			hif_set_block_ack_policy(wvif, 0xFF, 0xFF);
 		else
 			hif_set_block_ack_policy(wvif, 0x00, 0x00);
-		// Combo force powersave mode. We can re-enable it now
-		ret = wfx_update_pm(wvif);
 	}
 	return ret;
 }
@@ -818,8 +826,6 @@ void wfx_remove_interface(struct ieee80211_hw *hw, struct ieee80211_vif *vif)
 			hif_set_block_ack_policy(wvif, 0xFF, 0xFF);
 		else
 			hif_set_block_ack_policy(wvif, 0x00, 0x00);
-		// Combo force powersave mode. We can re-enable it now
-		wfx_update_pm(wvif);
 	}
 }
 

commit f214b7b6e7c959b4306df8e5c687887c547e38b6
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Fri May 15 10:33:19 2020 +0200

    staging: wfx: fix potential dead lock between join and scan
    
    The device disallows to start a scan request between hif_join() and
    hif_set_bss_params(). The driver is not protected against that. The
    worst case happens when association is aborted and hif_set_bss_params()
    never happens.
    
    mac80211 would never ask for scan during the association process. So,
    this patch just aborts the association in progress when scan is
    requested.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200515083325.378539-14-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index 7d9f680ca53a..6e9f38d051ab 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -353,6 +353,7 @@ void wfx_reset(struct wfx_vif *wvif)
 	if (wvif_count(wvif->wdev) <= 1)
 		hif_set_block_ack_policy(wvif, 0xFF, 0xFF);
 	wfx_tx_unlock(wvif->wdev);
+	wvif->join_in_progress = false;
 	wvif->bss_not_support_ps_poll = false;
 	cancel_delayed_work_sync(&wvif->beacon_loss_work);
 }
@@ -390,6 +391,7 @@ static void wfx_do_join(struct wfx_vif *wvif)
 	wfx_set_mfp(wvif, bss);
 	cfg80211_put_bss(wvif->wdev->hw->wiphy, bss);
 
+	wvif->join_in_progress = true;
 	ret = hif_join(wvif, conf, wvif->channel, ssid, ssidlen);
 	if (ret) {
 		ieee80211_connection_loss(wvif->vif);
@@ -485,6 +487,7 @@ void wfx_stop_ap(struct ieee80211_hw *hw, struct ieee80211_vif *vif)
 static void wfx_join_finalize(struct wfx_vif *wvif,
 			      struct ieee80211_bss_conf *info)
 {
+	wvif->join_in_progress = false;
 	hif_set_association_mode(wvif, info);
 	hif_keep_alive_period(wvif, 0);
 	// beacon_loss_count is defined to 7 in net/mac80211/mlme.c. Let's use

commit b3a71adf4d580b6382944e2c2ead392ba65e5243
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Fri May 15 10:33:18 2020 +0200

    staging: wfx: merge wfx_stop_ap() with wfx_reset()
    
    wfx_stop_ap() and wfx_reset() do the same thing. Merge them.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200515083325.378539-13-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index e077f42b62dc..7d9f680ca53a 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -479,11 +479,7 @@ void wfx_stop_ap(struct ieee80211_hw *hw, struct ieee80211_vif *vif)
 {
 	struct wfx_vif *wvif = (struct wfx_vif *)vif->drv_priv;
 
-	hif_reset(wvif, false);
-	wfx_tx_policy_init(wvif);
-	if (wvif_count(wvif->wdev) <= 1)
-		hif_set_block_ack_policy(wvif, 0xFF, 0xFF);
-	wvif->bss_not_support_ps_poll = false;
+	wfx_reset(wvif);
 }
 
 static void wfx_join_finalize(struct wfx_vif *wvif,

commit 5a48a4a3efb45fb18970c05e3a6b6bf5d72dbb7a
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Fri May 15 10:33:17 2020 +0200

    staging: wfx: rename wfx_do_unjoin() into wfx_reset()
    
    In fact, wfx_do_unjoin() resets the interface. This mechanism can be
    used in more cases than just disassociating from a BSS. So, rename it to
    reflect that fact.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200515083325.378539-12-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index 1a876a0faaf5..e077f42b62dc 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -315,20 +315,6 @@ void wfx_set_default_unicast_key(struct ieee80211_hw *hw,
 	hif_wep_default_key_id(wvif, idx);
 }
 
-// Call it with wdev->conf_mutex locked
-static void wfx_do_unjoin(struct wfx_vif *wvif)
-{
-	/* Unjoin is a reset. */
-	wfx_tx_lock_flush(wvif->wdev);
-	hif_reset(wvif, false);
-	wfx_tx_policy_init(wvif);
-	if (wvif_count(wvif->wdev) <= 1)
-		hif_set_block_ack_policy(wvif, 0xFF, 0xFF);
-	wfx_tx_unlock(wvif->wdev);
-	wvif->bss_not_support_ps_poll = false;
-	cancel_delayed_work_sync(&wvif->beacon_loss_work);
-}
-
 static void wfx_set_mfp(struct wfx_vif *wvif,
 			struct cfg80211_bss *bss)
 {
@@ -359,6 +345,18 @@ static void wfx_set_mfp(struct wfx_vif *wvif,
 	hif_set_mfp(wvif, mfpc, mfpr);
 }
 
+void wfx_reset(struct wfx_vif *wvif)
+{
+	wfx_tx_lock_flush(wvif->wdev);
+	hif_reset(wvif, false);
+	wfx_tx_policy_init(wvif);
+	if (wvif_count(wvif->wdev) <= 1)
+		hif_set_block_ack_policy(wvif, 0xFF, 0xFF);
+	wfx_tx_unlock(wvif->wdev);
+	wvif->bss_not_support_ps_poll = false;
+	cancel_delayed_work_sync(&wvif->beacon_loss_work);
+}
+
 static void wfx_do_join(struct wfx_vif *wvif)
 {
 	int ret;
@@ -395,7 +393,7 @@ static void wfx_do_join(struct wfx_vif *wvif)
 	ret = hif_join(wvif, conf, wvif->channel, ssid, ssidlen);
 	if (ret) {
 		ieee80211_connection_loss(wvif->vif);
-		wfx_do_unjoin(wvif);
+		wfx_reset(wvif);
 	} else {
 		/* Due to beacon filtering it is possible that the
 		 * AP's beacon is not known for the mac80211 stack.
@@ -513,7 +511,7 @@ void wfx_leave_ibss(struct ieee80211_hw *hw, struct ieee80211_vif *vif)
 {
 	struct wfx_vif *wvif = (struct wfx_vif *)vif->drv_priv;
 
-	wfx_do_unjoin(wvif);
+	wfx_reset(wvif);
 }
 
 static void wfx_enable_beacon(struct wfx_vif *wvif, bool enable)
@@ -580,7 +578,7 @@ void wfx_bss_info_changed(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 		if (info->assoc || info->ibss_joined)
 			wfx_join_finalize(wvif, info);
 		else if (!info->assoc && vif->type == NL80211_IFTYPE_STATION)
-			wfx_do_unjoin(wvif);
+			wfx_reset(wvif);
 		else
 			dev_warn(wdev->dev, "%s: misunderstood change: ASSOC\n",
 				 __func__);

commit cae9b69522b22e6e7a884451ba729b229ff0a03a
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Tue May 5 14:37:56 2020 +0200

    staging: wfx: remove spaces after cast operator
    
    The kernel coding style expects no space after cast operator. This patch
    make the wfx driver compliant with this rule.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200505123757.39506-15-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index 999e0f0e19af..1a876a0faaf5 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -251,7 +251,7 @@ int wfx_conf_tx(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 		   u16 queue, const struct ieee80211_tx_queue_params *params)
 {
 	struct wfx_dev *wdev = hw->priv;
-	struct wfx_vif *wvif = (struct wfx_vif *) vif->drv_priv;
+	struct wfx_vif *wvif = (struct wfx_vif *)vif->drv_priv;
 	int old_uapsd = wvif->uapsd_mask;
 
 	WARN_ON(queue >= hw->queues);
@@ -345,8 +345,7 @@ static void wfx_set_mfp(struct wfx_vif *wvif,
 
 	rcu_read_lock();
 	if (bss)
-		ptr = (const u16 *) ieee80211_bss_get_ie(bss,
-							      WLAN_EID_RSN);
+		ptr = (const u16 *)ieee80211_bss_get_ie(bss, WLAN_EID_RSN);
 
 	if (ptr) {
 		ptr += pairwise_cipher_suite_count_offset;
@@ -411,8 +410,8 @@ static void wfx_do_join(struct wfx_vif *wvif)
 int wfx_sta_add(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 		struct ieee80211_sta *sta)
 {
-	struct wfx_vif *wvif = (struct wfx_vif *) vif->drv_priv;
-	struct wfx_sta_priv *sta_priv = (struct wfx_sta_priv *) &sta->drv_priv;
+	struct wfx_vif *wvif = (struct wfx_vif *)vif->drv_priv;
+	struct wfx_sta_priv *sta_priv = (struct wfx_sta_priv *)&sta->drv_priv;
 
 	spin_lock_init(&sta_priv->lock);
 	sta_priv->vif_id = wvif->id;
@@ -432,8 +431,8 @@ int wfx_sta_add(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 int wfx_sta_remove(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 		   struct ieee80211_sta *sta)
 {
-	struct wfx_vif *wvif = (struct wfx_vif *) vif->drv_priv;
-	struct wfx_sta_priv *sta_priv = (struct wfx_sta_priv *) &sta->drv_priv;
+	struct wfx_vif *wvif = (struct wfx_vif *)vif->drv_priv;
+	struct wfx_sta_priv *sta_priv = (struct wfx_sta_priv *)&sta->drv_priv;
 	int i;
 
 	for (i = 0; i < ARRAY_SIZE(sta_priv->buffered); i++)
@@ -534,7 +533,7 @@ void wfx_bss_info_changed(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 			  struct ieee80211_bss_conf *info, u32 changed)
 {
 	struct wfx_dev *wdev = hw->priv;
-	struct wfx_vif *wvif = (struct wfx_vif *) vif->drv_priv;
+	struct wfx_vif *wvif = (struct wfx_vif *)vif->drv_priv;
 	int i;
 
 	mutex_lock(&wdev->conf_mutex);
@@ -703,7 +702,7 @@ void wfx_change_chanctx(struct ieee80211_hw *hw,
 int wfx_assign_vif_chanctx(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 			   struct ieee80211_chanctx_conf *conf)
 {
-	struct wfx_vif *wvif = (struct wfx_vif *) vif->drv_priv;
+	struct wfx_vif *wvif = (struct wfx_vif *)vif->drv_priv;
 	struct ieee80211_channel *ch = conf->def.chan;
 
 	WARN(wvif->channel, "channel overwrite");
@@ -716,7 +715,7 @@ void wfx_unassign_vif_chanctx(struct ieee80211_hw *hw,
 			      struct ieee80211_vif *vif,
 			      struct ieee80211_chanctx_conf *conf)
 {
-	struct wfx_vif *wvif = (struct wfx_vif *) vif->drv_priv;
+	struct wfx_vif *wvif = (struct wfx_vif *)vif->drv_priv;
 	struct ieee80211_channel *ch = conf->def.chan;
 
 	WARN(wvif->channel != ch, "channel mismatch");
@@ -732,7 +731,7 @@ int wfx_add_interface(struct ieee80211_hw *hw, struct ieee80211_vif *vif)
 {
 	int i, ret = 0;
 	struct wfx_dev *wdev = hw->priv;
-	struct wfx_vif *wvif = (struct wfx_vif *) vif->drv_priv;
+	struct wfx_vif *wvif = (struct wfx_vif *)vif->drv_priv;
 
 	vif->driver_flags |= IEEE80211_VIF_BEACON_FILTER |
 			     IEEE80211_VIF_SUPPORTS_UAPSD |
@@ -799,7 +798,7 @@ int wfx_add_interface(struct ieee80211_hw *hw, struct ieee80211_vif *vif)
 void wfx_remove_interface(struct ieee80211_hw *hw, struct ieee80211_vif *vif)
 {
 	struct wfx_dev *wdev = hw->priv;
-	struct wfx_vif *wvif = (struct wfx_vif *) vif->drv_priv;
+	struct wfx_vif *wvif = (struct wfx_vif *)vif->drv_priv;
 
 	wait_for_completion_timeout(&wvif->set_pm_mode_complete, msecs_to_jiffies(300));
 

commit b356aed9ec0c218a86902c02cb4031a6c8f89e1e
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Tue May 5 14:37:55 2020 +0200

    staging: wfx: fix alignements of function prototypes
    
    Some function prototypes were not correctly aligned and/or exceed 80
    columns.
    
    In some other cases, the prototypes were written on more lines than
    necessary.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200505123757.39506-14-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index 3ad0b67a7dca..999e0f0e19af 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -139,10 +139,8 @@ u64 wfx_prepare_multicast(struct ieee80211_hw *hw,
 	return 0;
 }
 
-void wfx_configure_filter(struct ieee80211_hw *hw,
-			     unsigned int changed_flags,
-			     unsigned int *total_flags,
-			     u64 unused)
+void wfx_configure_filter(struct ieee80211_hw *hw, unsigned int changed_flags,
+			  unsigned int *total_flags, u64 unused)
 {
 	struct wfx_vif *wvif = NULL;
 	struct wfx_dev *wdev = hw->priv;
@@ -532,10 +530,8 @@ static void wfx_enable_beacon(struct wfx_vif *wvif, bool enable)
 	hif_beacon_transmit(wvif, enable);
 }
 
-void wfx_bss_info_changed(struct ieee80211_hw *hw,
-			     struct ieee80211_vif *vif,
-			     struct ieee80211_bss_conf *info,
-			     u32 changed)
+void wfx_bss_info_changed(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
+			  struct ieee80211_bss_conf *info, u32 changed)
 {
 	struct wfx_dev *wdev = hw->priv;
 	struct wfx_vif *wvif = (struct wfx_vif *) vif->drv_priv;
@@ -800,8 +796,7 @@ int wfx_add_interface(struct ieee80211_hw *hw, struct ieee80211_vif *vif)
 	return ret;
 }
 
-void wfx_remove_interface(struct ieee80211_hw *hw,
-			  struct ieee80211_vif *vif)
+void wfx_remove_interface(struct ieee80211_hw *hw, struct ieee80211_vif *vif)
 {
 	struct wfx_dev *wdev = hw->priv;
 	struct wfx_vif *wvif = (struct wfx_vif *) vif->drv_priv;

commit bcd8795ad2b6909fb2736fe6efea6052b154bac2
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Tue May 5 14:37:52 2020 +0200

    staging: wfx: fix missing 'static' keyword
    
    Sparse tool noticed that wfx_enable_beacon() is never used outside of
    sta.c. Therefore, it can be declared static.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200505123757.39506-11-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index 74ec0b604085..3ad0b67a7dca 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -519,7 +519,7 @@ void wfx_leave_ibss(struct ieee80211_hw *hw, struct ieee80211_vif *vif)
 	wfx_do_unjoin(wvif);
 }
 
-void wfx_enable_beacon(struct wfx_vif *wvif, bool enable)
+static void wfx_enable_beacon(struct wfx_vif *wvif, bool enable)
 {
 	// Driver has Content After DTIM Beacon in queue. Driver is waiting for
 	// a signal from the firmware. Since we are going to stop to send

commit 6ae0878b4800c7042d35c0fb4c6baabb62621ecc
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Mon Apr 27 15:40:25 2020 +0200

    staging: wfx: fix double init of tx_policy_upload_work
    
    The work_struct tx_policy_upload_work was initialized twice.
    
    Fixes: 99879121bfbb ("staging: wfx: fix the cache of rate policies on interface reset")
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200427134031.323403-12-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index 67eb4a6e176b..74ec0b604085 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -782,7 +782,6 @@ int wfx_add_interface(struct ieee80211_hw *hw, struct ieee80211_vif *vif)
 	init_completion(&wvif->scan_complete);
 	INIT_WORK(&wvif->scan_work, wfx_hw_scan_work);
 
-	INIT_WORK(&wvif->tx_policy_upload_work, wfx_tx_policy_upload_work);
 	mutex_unlock(&wdev->conf_mutex);
 
 	hif_set_macaddr(wvif, vif->addr);

commit 1d52d29983e5daa18c441feed94259aaf03c582c
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Mon Apr 27 15:40:20 2020 +0200

    staging: wfx: add support for 'device too hot' indication
    
    Device is able to detect a high temperature. In this case, the traffic
    is not allowed to be sent until the temperature decrease.
    
    This patch detects the warnings raised by the device and stop the
    traffic accordingly. It also add a delayed task as safeguard in case the
    chip would never send the indication that the temperature decrease.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200427134031.323403-7-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index 5132c19e0367..67eb4a6e176b 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -38,6 +38,29 @@ u32 wfx_rate_mask_to_hw(struct wfx_dev *wdev, u32 rates)
 	return ret;
 }
 
+void wfx_cooling_timeout_work(struct work_struct *work)
+{
+	struct wfx_dev *wdev = container_of(to_delayed_work(work),
+					    struct wfx_dev,
+					    cooling_timeout_work);
+
+	wdev->chip_frozen = true;
+	wfx_tx_unlock(wdev);
+}
+
+void wfx_suspend_hot_dev(struct wfx_dev *wdev, enum sta_notify_cmd cmd)
+{
+	if (cmd == STA_NOTIFY_AWAKE) {
+		// Device recover normal temperature
+		if (cancel_delayed_work(&wdev->cooling_timeout_work))
+			wfx_tx_unlock(wdev);
+	} else {
+		// Device is too hot
+		schedule_delayed_work(&wdev->cooling_timeout_work, 10 * HZ);
+		wfx_tx_lock(wdev);
+	}
+}
+
 static void wfx_filter_beacon(struct wfx_vif *wvif, bool filter_beacon)
 {
 	const struct hif_ie_table_entry filter_ies[] = {

commit 8e47df5fc4abd31522b92eddf59c2863e3c5abde
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Mon Apr 27 15:40:19 2020 +0200

    staging: wfx: fix CAB sent at the wrong time
    
    wfx_suspend_resume_mc() is called when the device is about to sent a
    DTIM. This is the right moment to enqueue Content After DTIM Beacon
    (CAB).
    
    However, wfx_suspend_resume_mc() is also called when the DTIM period
    ends. Until now, this event did also trig CAB.
    
    Note this issue did not have too much impact since when a CAB is sent
    outside of DTIM window, an error is reported by the firmware and
    mac80211 retries to send the data.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200427134031.323403-6-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index 77d5ff17a59a..5132c19e0367 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -641,6 +641,8 @@ int wfx_set_tim(struct ieee80211_hw *hw, struct ieee80211_sta *sta, bool set)
 
 void wfx_suspend_resume_mc(struct wfx_vif *wvif, enum sta_notify_cmd notify_cmd)
 {
+	if (notify_cmd != STA_NOTIFY_AWAKE)
+		return;
 	WARN(!wfx_tx_queues_has_cab(wvif), "incorrect sequence");
 	WARN(wvif->after_dtim_tx_allowed, "incorrect sequence");
 	wvif->after_dtim_tx_allowed = true;

commit dd5eba1bb5b4f944a8fa4031645cbb2f854fdc92
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Mon Apr 27 15:40:18 2020 +0200

    staging: wfx: fix support for AP that do not support PS-Poll
    
    When multiple virtual interfaces (on different channels) are in use, the
    device ask to activate Power Save on station interfaces. The device
    developers recommends to use legacy PS-Poll in this case since it is the
    mode that disturb the less the other interface. However, some AP start
    to not answer anymore to PS-Poll. The device is able to detect this case
    and return a special warning in this case.
    
    So, this commit catch the warning and force usage of FastPS in this
    case.
    
    In order to confuse the less possible the other interface a small FastPS
    period is used (30ms).
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200427134031.323403-5-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index 2262e1de37f6..77d5ff17a59a 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -205,7 +205,10 @@ static int wfx_update_pm(struct wfx_vif *wvif)
 	if (chan0 && chan1 && chan0->hw_value != chan1->hw_value &&
 	    wvif->vif->type != NL80211_IFTYPE_AP) {
 		ps = true;
-		ps_timeout = 0;
+		if (wvif->bss_not_support_ps_poll)
+			ps_timeout = 30;
+		else
+			ps_timeout = 0;
 	}
 
 	if (!wait_for_completion_timeout(&wvif->set_pm_mode_complete,
@@ -215,6 +218,14 @@ static int wfx_update_pm(struct wfx_vif *wvif)
 	return hif_set_pm(wvif, ps, ps_timeout);
 }
 
+static void wfx_update_pm_work(struct work_struct *work)
+{
+	struct wfx_vif *wvif = container_of(work, struct wfx_vif,
+					    update_pm_work);
+
+	wfx_update_pm(wvif);
+}
+
 int wfx_conf_tx(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 		   u16 queue, const struct ieee80211_tx_queue_params *params)
 {
@@ -293,6 +304,7 @@ static void wfx_do_unjoin(struct wfx_vif *wvif)
 	if (wvif_count(wvif->wdev) <= 1)
 		hif_set_block_ack_policy(wvif, 0xFF, 0xFF);
 	wfx_tx_unlock(wvif->wdev);
+	wvif->bss_not_support_ps_poll = false;
 	cancel_delayed_work_sync(&wvif->beacon_loss_work);
 }
 
@@ -453,6 +465,7 @@ void wfx_stop_ap(struct ieee80211_hw *hw, struct ieee80211_vif *vif)
 	wfx_tx_policy_init(wvif);
 	if (wvif_count(wvif->wdev) <= 1)
 		hif_set_block_ack_policy(wvif, 0xFF, 0xFF);
+	wvif->bss_not_support_ps_poll = false;
 }
 
 static void wfx_join_finalize(struct wfx_vif *wvif,
@@ -737,6 +750,7 @@ int wfx_add_interface(struct ieee80211_hw *hw, struct ieee80211_vif *vif)
 
 	init_completion(&wvif->set_pm_mode_complete);
 	complete(&wvif->set_pm_mode_complete);
+	INIT_WORK(&wvif->update_pm_work, wfx_update_pm_work);
 	INIT_WORK(&wvif->tx_policy_upload_work, wfx_tx_policy_upload_work);
 
 	mutex_init(&wvif->scan_lock);

commit 7508f5d90d622d02af6a13a0a4c4064c475dd6e9
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Mon Apr 27 15:40:15 2020 +0200

    staging: wfx: fix (future) TDLS support
    
    The device does not expect that the AP to have a link-id. However, TDLS
    peers should have a a link-id.
    
    The driver does not yet declare itself as supporting TDLS.
    Notwithstanding, fix the code in anticipation of the support of TDLS.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200427134031.323403-2-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index f3e106f7eeac..2262e1de37f6 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -384,9 +384,8 @@ int wfx_sta_add(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 	spin_lock_init(&sta_priv->lock);
 	sta_priv->vif_id = wvif->id;
 
-	// FIXME: in station mode, the current API interprets new link-id as a
-	// tdls peer.
-	if (vif->type == NL80211_IFTYPE_STATION)
+	// In station mode, the firmware interprets new link-id as a TDLS peer.
+	if (vif->type == NL80211_IFTYPE_STATION && !sta->tdls)
 		return 0;
 	sta_priv->link_id = ffz(wvif->link_id_map);
 	wvif->link_id_map |= BIT(sta_priv->link_id);
@@ -408,8 +407,8 @@ int wfx_sta_remove(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 		if (sta_priv->buffered[i])
 			dev_warn(wvif->wdev->dev, "release station while %d pending frame on queue %d",
 				 sta_priv->buffered[i], i);
-	// FIXME: see note in wfx_sta_add()
-	if (vif->type == NL80211_IFTYPE_STATION)
+	// See note in wfx_sta_add()
+	if (!sta_priv->link_id)
 		return 0;
 	// FIXME add a mutex?
 	hif_map_link(wvif, sta->addr, 1, sta_priv->link_id);

commit 87f86cddda65cab8a7e3df8a00e16abeccaa0730
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Fri Apr 24 13:42:35 2020 +0300

    staging: wfx: check ssidlen and prevent an array overflow
    
    We need to cap "ssidlen" to prevent a memcpy() overflow.
    
    Fixes: 40115bbc40e2 ("staging: wfx: implement the rest of mac80211 API")
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Reviewed-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200424104235.GA416402@mwanda
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index 5d5c8951f50b..f3e106f7eeac 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -351,7 +351,9 @@ static void wfx_do_join(struct wfx_vif *wvif)
 		ssidie = ieee80211_bss_get_ie(bss, WLAN_EID_SSID);
 	if (ssidie) {
 		ssidlen = ssidie[1];
-		memcpy(ssid, &ssidie[2], ssidie[1]);
+		if (ssidlen > IEEE80211_MAX_SSID_LEN)
+			ssidlen = IEEE80211_MAX_SSID_LEN;
+		memcpy(ssid, &ssidie[2], ssidlen);
 	}
 	rcu_read_unlock();
 

commit 6ac29cc5af297098b7066e0eb3b6b9732a532f59
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Mon Apr 20 18:03:11 2020 +0200

    staging: wfx: drop unused attribute 'join_complete_status'
    
    The field join_complete_status is never read. Drop it.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200420160311.57323-17-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index 1e43e3b65953..5d5c8951f50b 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -361,10 +361,8 @@ static void wfx_do_join(struct wfx_vif *wvif)
 	ret = hif_join(wvif, conf, wvif->channel, ssid, ssidlen);
 	if (ret) {
 		ieee80211_connection_loss(wvif->vif);
-		wvif->join_complete_status = -1;
 		wfx_do_unjoin(wvif);
 	} else {
-		wvif->join_complete_status = 0;
 		/* Due to beacon filtering it is possible that the
 		 * AP's beacon is not known for the mac80211 stack.
 		 * Disable filtering temporary to make sure the stack

commit 4b815a9da5e24a86264cedad15ee6c2d94716c8f
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Mon Apr 20 18:03:10 2020 +0200

    staging: wfx: drop unused enum wfx_state
    
    In former code, the field wvif->state was more or less redundant with
    vif->type. With the lasts change it has become unused. It is now time to
    drop it.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200420160311.57323-16-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index 1732f3d0a1e5..1e43e3b65953 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -286,8 +286,6 @@ void wfx_set_default_unicast_key(struct ieee80211_hw *hw,
 // Call it with wdev->conf_mutex locked
 static void wfx_do_unjoin(struct wfx_vif *wvif)
 {
-	wvif->state = WFX_STATE_PASSIVE;
-
 	/* Unjoin is a reset. */
 	wfx_tx_lock_flush(wvif->wdev);
 	hif_reset(wvif, false);
@@ -367,11 +365,6 @@ static void wfx_do_join(struct wfx_vif *wvif)
 		wfx_do_unjoin(wvif);
 	} else {
 		wvif->join_complete_status = 0;
-		if (wvif->vif->type == NL80211_IFTYPE_ADHOC)
-			wvif->state = WFX_STATE_IBSS;
-		else
-			wvif->state = WFX_STATE_PRE_STA;
-
 		/* Due to beacon filtering it is possible that the
 		 * AP's beacon is not known for the mac80211 stack.
 		 * Disable filtering temporary to make sure the stack
@@ -448,7 +441,6 @@ int wfx_start_ap(struct ieee80211_hw *hw, struct ieee80211_vif *vif)
 {
 	struct wfx_vif *wvif = (struct wfx_vif *)vif->drv_priv;
 
-	wvif->state = WFX_STATE_AP;
 	wfx_upload_ap_templates(wvif);
 	hif_start(wvif, &vif->bss_conf, wvif->channel);
 	return 0;
@@ -462,7 +454,6 @@ void wfx_stop_ap(struct ieee80211_hw *hw, struct ieee80211_vif *vif)
 	wfx_tx_policy_init(wvif);
 	if (wvif_count(wvif->wdev) <= 1)
 		hif_set_block_ack_policy(wvif, 0xFF, 0xFF);
-	wvif->state = WFX_STATE_PASSIVE;
 }
 
 static void wfx_join_finalize(struct wfx_vif *wvif,
@@ -475,9 +466,6 @@ static void wfx_join_finalize(struct wfx_vif *wvif,
 	hif_set_bss_params(wvif, info->aid, 7);
 	hif_set_beacon_wakeup_period(wvif, 1, 1);
 	wfx_update_pm(wvif);
-
-	if (!info->ibss_joined)
-		wvif->state = WFX_STATE_STA;
 }
 
 int wfx_join_ibss(struct ieee80211_hw *hw, struct ieee80211_vif *vif)
@@ -787,7 +775,6 @@ void wfx_remove_interface(struct ieee80211_hw *hw,
 	WARN(wvif->link_id_map != 1, "corrupted state");
 
 	hif_reset(wvif, false);
-	wvif->state = WFX_STATE_PASSIVE;
 	hif_set_macaddr(wvif, NULL);
 	wfx_tx_policy_init(wvif);
 

commit cf24a82bd265d5ffff92faeda030eba7af2b2a59
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Mon Apr 20 18:03:09 2020 +0200

    staging: wfx: simplify wfx_remove_interface()
    
    In wfx_remove_interface(), the current code differentiate AP and Station
    cases. However, it is not necessary. In all cases, the only important
    thing is the call to hif_reset(). We can use the same code to support
    all cases.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200420160311.57323-15-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index bc891b6e4392..1732f3d0a1e5 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -785,24 +785,11 @@ void wfx_remove_interface(struct ieee80211_hw *hw,
 
 	mutex_lock(&wdev->conf_mutex);
 	WARN(wvif->link_id_map != 1, "corrupted state");
-	switch (wvif->state) {
-	case WFX_STATE_PRE_STA:
-	case WFX_STATE_STA:
-	case WFX_STATE_IBSS:
-		wfx_do_unjoin(wvif);
-		break;
-	case WFX_STATE_AP:
-		/* reset.link_id = 0; */
-		hif_reset(wvif, false);
-		break;
-	default:
-		break;
-	}
 
+	hif_reset(wvif, false);
 	wvif->state = WFX_STATE_PASSIVE;
-
-	/* FIXME: In add to reset MAC address, try to reset interface */
 	hif_set_macaddr(wvif, NULL);
+	wfx_tx_policy_init(wvif);
 
 	cancel_delayed_work_sync(&wvif->beacon_loss_work);
 	wdev->vif[wvif->id] = NULL;

commit 06efad5808aa0db3528eca4b8faee4013ffd787b
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Mon Apr 20 18:03:08 2020 +0200

    staging: wfx: drop useless checks in wfx_do_unjoin()
    
    The callers of wfx_do_unjoin() already take care of vif state.
    Therefore, it is not necessary to take care of the status of the
    interface.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200420160311.57323-14-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index 56cb6fff4a06..bc891b6e4392 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -286,12 +286,6 @@ void wfx_set_default_unicast_key(struct ieee80211_hw *hw,
 // Call it with wdev->conf_mutex locked
 static void wfx_do_unjoin(struct wfx_vif *wvif)
 {
-	if (!wvif->state)
-		return;
-
-	if (wvif->state == WFX_STATE_AP)
-		return;
-
 	wvif->state = WFX_STATE_PASSIVE;
 
 	/* Unjoin is a reset. */

commit 9da38fd5a90655c308e59398d169f4d3efd16377
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Mon Apr 20 18:03:06 2020 +0200

    staging: wfx: keys are kept during whole firmware life
    
    Keys sent to the firmware are never reset. So, it is not necessary to
    re-upload them after hif_reset(). Thus, it is no more necessary to keep
    a copy of the keys in struct wfx_dev.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200420160311.57323-12-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index 876952f39fc9..56cb6fff4a06 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -378,9 +378,6 @@ static void wfx_do_join(struct wfx_vif *wvif)
 		else
 			wvif->state = WFX_STATE_PRE_STA;
 
-		/* Upload keys */
-		wfx_upload_keys(wvif);
-
 		/* Due to beacon filtering it is possible that the
 		 * AP's beacon is not known for the mac80211 stack.
 		 * Disable filtering temporary to make sure the stack
@@ -457,7 +454,6 @@ int wfx_start_ap(struct ieee80211_hw *hw, struct ieee80211_vif *vif)
 {
 	struct wfx_vif *wvif = (struct wfx_vif *)vif->drv_priv;
 
-	wfx_upload_keys(wvif);
 	wvif->state = WFX_STATE_AP;
 	wfx_upload_ap_templates(wvif);
 	hif_start(wvif, &vif->bss_conf, wvif->channel);

commit 7a44644c9379eb1bbb03ce8054a0b0179f470146
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Mon Apr 20 18:03:05 2020 +0200

    staging: wfx: introduce wfx_set_default_unicast_key()
    
    Currently code handle WEP keys manually. It is far easier to use
    the set_default_unicast_key() callback provided by mac80211.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200420160311.57323-11-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index 1cc437f0bc81..876952f39fc9 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -275,6 +275,14 @@ static void wfx_beacon_loss_work(struct work_struct *work)
 			      msecs_to_jiffies(bss_conf->beacon_int));
 }
 
+void wfx_set_default_unicast_key(struct ieee80211_hw *hw,
+				 struct ieee80211_vif *vif, int idx)
+{
+	struct wfx_vif *wvif = (struct wfx_vif *)vif->drv_priv;
+
+	hif_wep_default_key_id(wvif, idx);
+}
+
 // Call it with wdev->conf_mutex locked
 static void wfx_do_unjoin(struct wfx_vif *wvif)
 {
@@ -560,13 +568,6 @@ void wfx_bss_info_changed(struct ieee80211_hw *hw,
 		wfx_filter_beacon(wvif, true);
 	}
 
-	/* assoc/disassoc, or maybe AID changed */
-	if (changed & BSS_CHANGED_ASSOC) {
-		wfx_tx_lock_flush(wdev);
-		wvif->wep_default_key_id = -1;
-		wfx_tx_unlock(wdev);
-	}
-
 	if (changed & BSS_CHANGED_ASSOC) {
 		if (info->assoc || info->ibss_joined)
 			wfx_join_finalize(wvif, info);
@@ -757,9 +758,6 @@ int wfx_add_interface(struct ieee80211_hw *hw, struct ieee80211_vif *vif)
 	INIT_WORK(&wvif->update_tim_work, wfx_update_tim_work);
 	INIT_DELAYED_WORK(&wvif->beacon_loss_work, wfx_beacon_loss_work);
 
-	wvif->wep_default_key_id = -1;
-	INIT_WORK(&wvif->wep_key_work, wfx_wep_key_work);
-
 	init_completion(&wvif->set_pm_mode_complete);
 	complete(&wvif->set_pm_mode_complete);
 	INIT_WORK(&wvif->tx_policy_upload_work, wfx_tx_policy_upload_work);

commit 7b0360e56f10e4bec46124ba7b0eaf8ec9837992
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Mon Apr 20 18:03:03 2020 +0200

    staging: wfx: simplify hif_set_bss_params()
    
    The structure hif_req_set_bss_params come from hardware API. It is not
    intended to be manipulated in upper layers of the driver.
    
    In add, current code for hif_req_set_bss_params() is too dumb. It should
    pack data with hardware representation instead of leaving all work to
    the caller.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200420160311.57323-9-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index 6cdb40a05991..1cc437f0bc81 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -470,16 +470,11 @@ void wfx_stop_ap(struct ieee80211_hw *hw, struct ieee80211_vif *vif)
 static void wfx_join_finalize(struct wfx_vif *wvif,
 			      struct ieee80211_bss_conf *info)
 {
-	struct hif_req_set_bss_params bss_params = {
-		// beacon_loss_count is defined to 7 in net/mac80211/mlme.c.
-		// Let's use the same value.
-		.beacon_lost_count = 7,
-		.aid = info->aid,
-	};
-
 	hif_set_association_mode(wvif, info);
 	hif_keep_alive_period(wvif, 0);
-	hif_set_bss_params(wvif, &bss_params);
+	// beacon_loss_count is defined to 7 in net/mac80211/mlme.c. Let's use
+	// the same value.
+	hif_set_bss_params(wvif, info->aid, 7);
 	hif_set_beacon_wakeup_period(wvif, 1, 1);
 	wfx_update_pm(wvif);
 

commit 2e885b18b1d96383814366cfe681b2f2db2833c0
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Mon Apr 20 18:03:02 2020 +0200

    staging: wfx: field operational_rate_set is ignored by firmware
    
    The field bss_params.operational_rate_set is ignore by the firmware. It
    is not necessary to send it. This change greatly simplify
    wfx_join_finalize(). It is no more necessary to get sta and it allow to
    save a RCU.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200420160311.57323-8-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index 2a9c7f28d934..6cdb40a05991 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -470,22 +470,12 @@ void wfx_stop_ap(struct ieee80211_hw *hw, struct ieee80211_vif *vif)
 static void wfx_join_finalize(struct wfx_vif *wvif,
 			      struct ieee80211_bss_conf *info)
 {
-	struct ieee80211_sta *sta = NULL;
-	struct hif_req_set_bss_params bss_params = { };
-
-	rcu_read_lock(); // protect sta
-	if (info->bssid && !info->ibss_joined)
-		sta = ieee80211_find_sta(wvif->vif, info->bssid);
-	if (sta)
-		bss_params.operational_rate_set =
-			wfx_rate_mask_to_hw(wvif->wdev, sta->supp_rates[wvif->channel->band]);
-	else
-		bss_params.operational_rate_set = -1;
-	rcu_read_unlock();
-	// beacon_loss_count is defined to 7 in net/mac80211/mlme.c. Let's use
-	// the same value.
-	bss_params.beacon_lost_count = 7;
-	bss_params.aid = info->aid;
+	struct hif_req_set_bss_params bss_params = {
+		// beacon_loss_count is defined to 7 in net/mac80211/mlme.c.
+		// Let's use the same value.
+		.beacon_lost_count = 7,
+		.aid = info->aid,
+	};
 
 	hif_set_association_mode(wvif, info);
 	hif_keep_alive_period(wvif, 0);

commit d4620087d2ebc36077b0cd9d49773dcc29089fab
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Mon Apr 20 18:03:01 2020 +0200

    staging: wfx: dual CTS is never necessary
    
    Dual CTS is only necessary when sending/receiving STBC data. However,
    the chip does not support STBC, so it is never necessary to enable
    double CTS.
    
    We can simplify the code.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200420160311.57323-7-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index a0c7737903b9..2a9c7f28d934 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -482,12 +482,6 @@ static void wfx_join_finalize(struct wfx_vif *wvif,
 	else
 		bss_params.operational_rate_set = -1;
 	rcu_read_unlock();
-	if (sta &&
-	    info->ht_operation_mode & IEEE80211_HT_OP_MODE_NON_GF_STA_PRSNT)
-		hif_dual_cts_protection(wvif, true);
-	else
-		hif_dual_cts_protection(wvif, false);
-
 	// beacon_loss_count is defined to 7 in net/mac80211/mlme.c. Let's use
 	// the same value.
 	bss_params.beacon_lost_count = 7;

commit 537000acc32363fb03cd638881bc0b0fa319ab5f
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Mon Apr 20 18:03:00 2020 +0200

    staging: wfx: also fix network parameters for IBSS networks
    
    Current code skip some configuration during joining an IBSS network.
    Indeed, it seems that this configuration is not used in IBSS. However,
    it would be harmless to set them. In add, we would prefer to keep
    association processes for ad-hoc and managed networks the closest as
    possible. It also ensures the values of internal parameters of the
    firmware.
    
    Therefore, apply them unconditionally.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200420160311.57323-6-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index a0c841658a0b..a0c7737903b9 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -494,14 +494,13 @@ static void wfx_join_finalize(struct wfx_vif *wvif,
 	bss_params.aid = info->aid;
 
 	hif_set_association_mode(wvif, info);
+	hif_keep_alive_period(wvif, 0);
+	hif_set_bss_params(wvif, &bss_params);
+	hif_set_beacon_wakeup_period(wvif, 1, 1);
+	wfx_update_pm(wvif);
 
-	if (!info->ibss_joined) {
+	if (!info->ibss_joined)
 		wvif->state = WFX_STATE_STA;
-		hif_keep_alive_period(wvif, 0);
-		hif_set_bss_params(wvif, &bss_params);
-		hif_set_beacon_wakeup_period(wvif, 1, 1);
-		wfx_update_pm(wvif);
-	}
 }
 
 int wfx_join_ibss(struct ieee80211_hw *hw, struct ieee80211_vif *vif)

commit 988cf07bb9a0f3c296e38124ab7e7f5d2f2d28a4
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Mon Apr 20 18:02:59 2020 +0200

    staging: wfx: handle firmware events synchronously
    
    Currently, events from firmware are handled in a work queue with a
    complex event queue mechanism. It is probably overkill since there is
    only two events to handle: bss_loss and CQM events. Handling these
    events synchronously is sufficient.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200420160311.57323-5-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index 2253ec2bdbf3..a0c841658a0b 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -38,27 +38,6 @@ u32 wfx_rate_mask_to_hw(struct wfx_dev *wdev, u32 rates)
 	return ret;
 }
 
-static void __wfx_free_event_queue(struct list_head *list)
-{
-	struct wfx_hif_event *event, *tmp;
-
-	list_for_each_entry_safe(event, tmp, list, link) {
-		list_del(&event->link);
-		kfree(event);
-	}
-}
-
-static void wfx_free_event_queue(struct wfx_vif *wvif)
-{
-	LIST_HEAD(list);
-
-	spin_lock(&wvif->event_queue_lock);
-	list_splice_init(&wvif->event_queue, &list);
-	spin_unlock(&wvif->event_queue_lock);
-
-	__wfx_free_event_queue(&list);
-}
-
 static void wfx_filter_beacon(struct wfx_vif *wvif, bool filter_beacon)
 {
 	const struct hif_ie_table_entry filter_ies[] = {
@@ -269,7 +248,7 @@ int wfx_set_rts_threshold(struct ieee80211_hw *hw, u32 value)
 
 /* WSM callbacks */
 
-static void wfx_event_report_rssi(struct wfx_vif *wvif, u8 raw_rcpi_rssi)
+void wfx_event_report_rssi(struct wfx_vif *wvif, u8 raw_rcpi_rssi)
 {
 	/* RSSI: signed Q8.0, RCPI: unsigned Q7.1
 	 * RSSI = RCPI / 2 - 110
@@ -296,44 +275,6 @@ static void wfx_beacon_loss_work(struct work_struct *work)
 			      msecs_to_jiffies(bss_conf->beacon_int));
 }
 
-static void wfx_event_handler_work(struct work_struct *work)
-{
-	struct wfx_vif *wvif =
-		container_of(work, struct wfx_vif, event_handler_work);
-	struct wfx_hif_event *event;
-
-	LIST_HEAD(list);
-
-	spin_lock(&wvif->event_queue_lock);
-	list_splice_init(&wvif->event_queue, &list);
-	spin_unlock(&wvif->event_queue_lock);
-
-	list_for_each_entry(event, &list, link) {
-		switch (event->evt.event_id) {
-		case HIF_EVENT_IND_BSSLOST:
-			schedule_delayed_work(&wvif->beacon_loss_work, 0);
-			break;
-		case HIF_EVENT_IND_BSSREGAINED:
-			cancel_delayed_work(&wvif->beacon_loss_work);
-			break;
-		case HIF_EVENT_IND_RCPI_RSSI:
-			wfx_event_report_rssi(wvif,
-					      event->evt.event_data.rcpi_rssi);
-			break;
-		case HIF_EVENT_IND_PS_MODE_ERROR:
-			dev_warn(wvif->wdev->dev,
-				 "error while processing power save request\n");
-			break;
-		default:
-			dev_warn(wvif->wdev->dev,
-				 "unhandled event indication: %.2x\n",
-				 event->evt.event_id);
-			break;
-		}
-	}
-	__wfx_free_event_queue(&list);
-}
-
 // Call it with wdev->conf_mutex locked
 static void wfx_do_unjoin(struct wfx_vif *wvif)
 {
@@ -351,9 +292,6 @@ static void wfx_do_unjoin(struct wfx_vif *wvif)
 	wfx_tx_policy_init(wvif);
 	if (wvif_count(wvif->wdev) <= 1)
 		hif_set_block_ack_policy(wvif, 0xFF, 0xFF);
-	wfx_free_event_queue(wvif);
-	cancel_work_sync(&wvif->event_handler_work);
-
 	wfx_tx_unlock(wvif->wdev);
 	cancel_delayed_work_sync(&wvif->beacon_loss_work);
 }
@@ -844,10 +782,6 @@ int wfx_add_interface(struct ieee80211_hw *hw, struct ieee80211_vif *vif)
 	wvif->wep_default_key_id = -1;
 	INIT_WORK(&wvif->wep_key_work, wfx_wep_key_work);
 
-	spin_lock_init(&wvif->event_queue_lock);
-	INIT_LIST_HEAD(&wvif->event_queue);
-	INIT_WORK(&wvif->event_handler_work, wfx_event_handler_work);
-
 	init_completion(&wvif->set_pm_mode_complete);
 	complete(&wvif->set_pm_mode_complete);
 	INIT_WORK(&wvif->tx_policy_upload_work, wfx_tx_policy_upload_work);
@@ -904,9 +838,7 @@ void wfx_remove_interface(struct ieee80211_hw *hw,
 	/* FIXME: In add to reset MAC address, try to reset interface */
 	hif_set_macaddr(wvif, NULL);
 
-	wfx_free_event_queue(wvif);
 	cancel_delayed_work_sync(&wvif->beacon_loss_work);
-
 	wdev->vif[wvif->id] = NULL;
 	wvif->vif = NULL;
 

commit 5c442b6a39e112539144abbfd5e75fe486c3dfab
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Mon Apr 20 18:02:58 2020 +0200

    staging: wfx: drop useless attribute 'bss_params'
    
    Since wfx_bss_params_work() does not exist anymore, there is no more
    reason to keep a copy of bss_params in struct wfx_dev. A local instance
    in wfx_join_finalize() is sufficient.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200420160311.57323-4-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index ca84724e531c..2253ec2bdbf3 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -354,7 +354,6 @@ static void wfx_do_unjoin(struct wfx_vif *wvif)
 	wfx_free_event_queue(wvif);
 	cancel_work_sync(&wvif->event_handler_work);
 
-	memset(&wvif->bss_params, 0, sizeof(wvif->bss_params));
 	wfx_tx_unlock(wvif->wdev);
 	cancel_delayed_work_sync(&wvif->beacon_loss_work);
 }
@@ -534,15 +533,16 @@ static void wfx_join_finalize(struct wfx_vif *wvif,
 			      struct ieee80211_bss_conf *info)
 {
 	struct ieee80211_sta *sta = NULL;
+	struct hif_req_set_bss_params bss_params = { };
 
 	rcu_read_lock(); // protect sta
 	if (info->bssid && !info->ibss_joined)
 		sta = ieee80211_find_sta(wvif->vif, info->bssid);
 	if (sta)
-		wvif->bss_params.operational_rate_set =
+		bss_params.operational_rate_set =
 			wfx_rate_mask_to_hw(wvif->wdev, sta->supp_rates[wvif->channel->band]);
 	else
-		wvif->bss_params.operational_rate_set = -1;
+		bss_params.operational_rate_set = -1;
 	rcu_read_unlock();
 	if (sta &&
 	    info->ht_operation_mode & IEEE80211_HT_OP_MODE_NON_GF_STA_PRSNT)
@@ -552,15 +552,15 @@ static void wfx_join_finalize(struct wfx_vif *wvif,
 
 	// beacon_loss_count is defined to 7 in net/mac80211/mlme.c. Let's use
 	// the same value.
-	wvif->bss_params.beacon_lost_count = 7;
-	wvif->bss_params.aid = info->aid;
+	bss_params.beacon_lost_count = 7;
+	bss_params.aid = info->aid;
 
 	hif_set_association_mode(wvif, info);
 
 	if (!info->ibss_joined) {
 		wvif->state = WFX_STATE_STA;
 		hif_keep_alive_period(wvif, 0);
-		hif_set_bss_params(wvif, &wvif->bss_params);
+		hif_set_bss_params(wvif, &bss_params);
 		hif_set_beacon_wakeup_period(wvif, 1, 1);
 		wfx_update_pm(wvif);
 	}
@@ -841,8 +841,6 @@ int wfx_add_interface(struct ieee80211_hw *hw, struct ieee80211_vif *vif)
 	INIT_WORK(&wvif->update_tim_work, wfx_update_tim_work);
 	INIT_DELAYED_WORK(&wvif->beacon_loss_work, wfx_beacon_loss_work);
 
-	memset(&wvif->bss_params, 0, sizeof(wvif->bss_params));
-
 	wvif->wep_default_key_id = -1;
 	INIT_WORK(&wvif->wep_key_work, wfx_wep_key_work);
 

commit 5a0af69888488d2b873f55bcba4cd17b162e4bea
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Mon Apr 20 18:02:57 2020 +0200

    staging: wfx: use ieee80211_beacon_loss() provided by mac80211
    
    The firmware is able to filter beacons and send a notification if one or
    multiple beacons are not received. Note that it send this notification
    only once. Only if it receive beacons gain, it send a new notification.
    
    Currently, the driver handle the connection loss itself (see
    wfx_cqm_bssloss_sm()). It send null frames and watch the answers.
    
    This patch fixes all this mess:
      - settle firmware to send a notification on the first beacon loss
      - call ieee80211_beacon_loss() and let mac80211 handle all the process
      - since we do have notification for each beacon loss, add a period
        task that call ieee80211_beacon_loss() until we receive "REGAIN"
        notification.
    
    Thus, we can drop the ugly wfx_cqm_bssloss_sm() and
    wfx_bss_params_work().
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200420160311.57323-3-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index c0c3eb945967..ca84724e531c 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -59,60 +59,6 @@ static void wfx_free_event_queue(struct wfx_vif *wvif)
 	__wfx_free_event_queue(&list);
 }
 
-void wfx_cqm_bssloss_sm(struct wfx_vif *wvif, int init, int good, int bad)
-{
-	int tx = 0;
-
-	mutex_lock(&wvif->bss_loss_lock);
-	cancel_work_sync(&wvif->bss_params_work);
-
-	if (init) {
-		schedule_delayed_work(&wvif->bss_loss_work, HZ);
-		wvif->bss_loss_state = 0;
-
-		if (!atomic_read(&wvif->wdev->tx_lock))
-			tx = 1;
-	} else if (good) {
-		cancel_delayed_work_sync(&wvif->bss_loss_work);
-		wvif->bss_loss_state = 0;
-		schedule_work(&wvif->bss_params_work);
-	} else if (bad) {
-		/* FIXME Should we just keep going until we time out? */
-		if (wvif->bss_loss_state < 3)
-			tx = 1;
-	} else {
-		cancel_delayed_work_sync(&wvif->bss_loss_work);
-		wvif->bss_loss_state = 0;
-	}
-
-	/* Spit out a NULL packet to our AP if necessary */
-	// FIXME: call ieee80211_beacon_loss/ieee80211_connection_loss instead
-	if (tx) {
-		struct sk_buff *skb;
-		struct ieee80211_hdr *hdr;
-		struct ieee80211_tx_control control = { };
-
-		wvif->bss_loss_state++;
-
-		skb = ieee80211_nullfunc_get(wvif->wdev->hw, wvif->vif, false);
-		if (!skb)
-			goto end;
-		hdr = (struct ieee80211_hdr *)skb->data;
-		memset(IEEE80211_SKB_CB(skb), 0,
-		       sizeof(*IEEE80211_SKB_CB(skb)));
-		IEEE80211_SKB_CB(skb)->control.vif = wvif->vif;
-		IEEE80211_SKB_CB(skb)->driver_rates[0].idx = 0;
-		IEEE80211_SKB_CB(skb)->driver_rates[0].count = 1;
-		IEEE80211_SKB_CB(skb)->driver_rates[1].idx = -1;
-		rcu_read_lock(); // protect control.sta
-		control.sta = ieee80211_find_sta(wvif->vif, hdr->addr1);
-		wfx_tx(wvif->wdev->hw, &control, skb);
-		rcu_read_unlock();
-	}
-end:
-	mutex_unlock(&wvif->bss_loss_lock);
-}
-
 static void wfx_filter_beacon(struct wfx_vif *wvif, bool filter_beacon)
 {
 	const struct hif_ie_table_entry filter_ies[] = {
@@ -339,6 +285,17 @@ static void wfx_event_report_rssi(struct wfx_vif *wvif, u8 raw_rcpi_rssi)
 	ieee80211_cqm_rssi_notify(wvif->vif, cqm_evt, rcpi_rssi, GFP_KERNEL);
 }
 
+static void wfx_beacon_loss_work(struct work_struct *work)
+{
+	struct wfx_vif *wvif = container_of(to_delayed_work(work),
+					    struct wfx_vif, beacon_loss_work);
+	struct ieee80211_bss_conf *bss_conf = &wvif->vif->bss_conf;
+
+	ieee80211_beacon_loss(wvif->vif);
+	schedule_delayed_work(to_delayed_work(work),
+			      msecs_to_jiffies(bss_conf->beacon_int));
+}
+
 static void wfx_event_handler_work(struct work_struct *work)
 {
 	struct wfx_vif *wvif =
@@ -354,12 +311,10 @@ static void wfx_event_handler_work(struct work_struct *work)
 	list_for_each_entry(event, &list, link) {
 		switch (event->evt.event_id) {
 		case HIF_EVENT_IND_BSSLOST:
-			mutex_lock(&wvif->scan_lock);
-			wfx_cqm_bssloss_sm(wvif, 1, 0, 0);
-			mutex_unlock(&wvif->scan_lock);
+			schedule_delayed_work(&wvif->beacon_loss_work, 0);
 			break;
 		case HIF_EVENT_IND_BSSREGAINED:
-			wfx_cqm_bssloss_sm(wvif, 0, 0, 0);
+			cancel_delayed_work(&wvif->beacon_loss_work);
 			break;
 		case HIF_EVENT_IND_RCPI_RSSI:
 			wfx_event_report_rssi(wvif,
@@ -379,26 +334,6 @@ static void wfx_event_handler_work(struct work_struct *work)
 	__wfx_free_event_queue(&list);
 }
 
-static void wfx_bss_loss_work(struct work_struct *work)
-{
-	struct wfx_vif *wvif = container_of(work, struct wfx_vif,
-					    bss_loss_work.work);
-
-	ieee80211_connection_loss(wvif->vif);
-}
-
-static void wfx_bss_params_work(struct work_struct *work)
-{
-	struct wfx_vif *wvif = container_of(work, struct wfx_vif,
-					    bss_params_work);
-
-	mutex_lock(&wvif->wdev->conf_mutex);
-	wvif->bss_params.bss_flags.lost_count_only = 1;
-	hif_set_bss_params(wvif, &wvif->bss_params);
-	wvif->bss_params.bss_flags.lost_count_only = 0;
-	mutex_unlock(&wvif->wdev->conf_mutex);
-}
-
 // Call it with wdev->conf_mutex locked
 static void wfx_do_unjoin(struct wfx_vif *wvif)
 {
@@ -418,10 +353,10 @@ static void wfx_do_unjoin(struct wfx_vif *wvif)
 		hif_set_block_ack_policy(wvif, 0xFF, 0xFF);
 	wfx_free_event_queue(wvif);
 	cancel_work_sync(&wvif->event_handler_work);
-	wfx_cqm_bssloss_sm(wvif, 0, 0, 0);
 
 	memset(&wvif->bss_params, 0, sizeof(wvif->bss_params));
 	wfx_tx_unlock(wvif->wdev);
+	cancel_delayed_work_sync(&wvif->beacon_loss_work);
 }
 
 static void wfx_set_mfp(struct wfx_vif *wvif,
@@ -615,9 +550,9 @@ static void wfx_join_finalize(struct wfx_vif *wvif,
 	else
 		hif_dual_cts_protection(wvif, false);
 
-	wfx_cqm_bssloss_sm(wvif, 0, 0, 0);
-
-	wvif->bss_params.beacon_lost_count = 20;
+	// beacon_loss_count is defined to 7 in net/mac80211/mlme.c. Let's use
+	// the same value.
+	wvif->bss_params.beacon_lost_count = 7;
 	wvif->bss_params.aid = info->aid;
 
 	hif_set_association_mode(wvif, info);
@@ -904,12 +839,10 @@ int wfx_add_interface(struct ieee80211_hw *hw, struct ieee80211_vif *vif)
 
 	wvif->link_id_map = 1; // link-id 0 is reserved for multicast
 	INIT_WORK(&wvif->update_tim_work, wfx_update_tim_work);
+	INIT_DELAYED_WORK(&wvif->beacon_loss_work, wfx_beacon_loss_work);
 
 	memset(&wvif->bss_params, 0, sizeof(wvif->bss_params));
 
-	mutex_init(&wvif->bss_loss_lock);
-	INIT_DELAYED_WORK(&wvif->bss_loss_work, wfx_bss_loss_work);
-
 	wvif->wep_default_key_id = -1;
 	INIT_WORK(&wvif->wep_key_work, wfx_wep_key_work);
 
@@ -919,7 +852,6 @@ int wfx_add_interface(struct ieee80211_hw *hw, struct ieee80211_vif *vif)
 
 	init_completion(&wvif->set_pm_mode_complete);
 	complete(&wvif->set_pm_mode_complete);
-	INIT_WORK(&wvif->bss_params_work, wfx_bss_params_work);
 	INIT_WORK(&wvif->tx_policy_upload_work, wfx_tx_policy_upload_work);
 
 	mutex_init(&wvif->scan_lock);
@@ -974,8 +906,8 @@ void wfx_remove_interface(struct ieee80211_hw *hw,
 	/* FIXME: In add to reset MAC address, try to reset interface */
 	hif_set_macaddr(wvif, NULL);
 
-	wfx_cqm_bssloss_sm(wvif, 0, 0, 0);
 	wfx_free_event_queue(wvif);
+	cancel_delayed_work_sync(&wvif->beacon_loss_work);
 
 	wdev->vif[wvif->id] = NULL;
 	wvif->vif = NULL;

commit 13fe5a59b3c79e03cea3f7232a05e79bc5aad70a
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Mon Apr 20 18:02:56 2020 +0200

    staging: wfx: simplify the check if the the device is associated
    
    Firmware dislikes the driver enables PS when it is not yet associated.
    The current check for that condition is more complex than necessary.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200420160311.57323-2-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index c73dbb3a0de8..c0c3eb945967 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -263,7 +263,7 @@ static int wfx_update_pm(struct wfx_vif *wvif)
 	struct ieee80211_channel *chan0 = NULL, *chan1 = NULL;
 
 	WARN_ON(conf->dynamic_ps_timeout < 0);
-	if (wvif->state != WFX_STATE_STA || !wvif->bss_params.aid)
+	if (!wvif->vif->bss_conf.assoc)
 		return 0;
 	if (!ps)
 		ps_timeout = 0;

commit c801351a9d4587aab131d018330d4b35a0b3cdcf
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Wed Apr 15 18:11:46 2020 +0200

    staging: wfx: drop useless attribute 'filter_mcast'
    
    Currently, wfx_update_filtering() apply the value of wvif->filter_mcast
    to the hardware. But an attentive reader will note that
    wfx_update_filtering() is always called after set wvif->filter_mcast.
    Thus, it not necessary to store filter_mcast in the struct wfx_vif. We
    can just pass it as parameter.
    
    Also rename wfx_update_filtering() in wfx_filter_mcast() to reflect this
    change.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200415161147.69738-20-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index 69a5823af284..c73dbb3a0de8 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -144,7 +144,7 @@ static void wfx_filter_beacon(struct wfx_vif *wvif, bool filter_beacon)
 	}
 }
 
-void wfx_update_filtering(struct wfx_vif *wvif)
+static void wfx_filter_mcast(struct wfx_vif *wvif, bool filter_mcast)
 {
 	int i;
 
@@ -152,7 +152,7 @@ void wfx_update_filtering(struct wfx_vif *wvif)
 	hif_set_data_filtering(wvif, false, true);
 	return;
 
-	if (!wvif->filter_mcast) {
+	if (!filter_mcast) {
 		hif_set_data_filtering(wvif, false, true);
 		return;
 	}
@@ -198,7 +198,7 @@ void wfx_configure_filter(struct ieee80211_hw *hw,
 {
 	struct wfx_vif *wvif = NULL;
 	struct wfx_dev *wdev = hw->priv;
-	bool filter_bssid, filter_prbreq, filter_beacon;
+	bool filter_bssid, filter_prbreq, filter_beacon, filter_mcast;
 
 	// Notes:
 	//   - Probe responses (FIF_BCN_PRBRESP_PROMISC) are never filtered
@@ -223,14 +223,14 @@ void wfx_configure_filter(struct ieee80211_hw *hw,
 		wfx_filter_beacon(wvif, filter_beacon);
 
 		if (*total_flags & FIF_ALLMULTI) {
-			wvif->filter_mcast = false;
+			filter_mcast = false;
 		} else if (!wvif->filter_mcast_count) {
 			dev_dbg(wdev->dev, "disabling unconfigured multicast filter");
-			wvif->filter_mcast = false;
+			filter_mcast = false;
 		} else {
-			wvif->filter_mcast = true;
+			filter_mcast = true;
 		}
-		wfx_update_filtering(wvif);
+		wfx_filter_mcast(wvif, filter_mcast);
 
 		if (*total_flags & FIF_OTHER_BSS)
 			filter_bssid = false;

commit b15973f30852dee46d80ccd2363ece80b2c0317d
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Wed Apr 15 18:11:45 2020 +0200

    staging: wfx: drop useless filter update when starting AP
    
    mac80211 explicitly call wfx_configure_filters() before/after starting
    AP. Thus, it is not necessary to call wfx_update_filtering() from
    wfx_start_ap().
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200415161147.69738-19-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index 1ccd40a3322f..69a5823af284 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -579,7 +579,6 @@ int wfx_start_ap(struct ieee80211_hw *hw, struct ieee80211_vif *vif)
 
 	wfx_upload_keys(wvif);
 	wvif->state = WFX_STATE_AP;
-	wfx_update_filtering(wvif);
 	wfx_upload_ap_templates(wvif);
 	hif_start(wvif, &vif->bss_conf, wvif->channel);
 	return 0;

commit 2c69b2da37824307b4c73cbf7ad98ae82a6a52fe
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Wed Apr 15 18:11:44 2020 +0200

    staging: wfx: split out wfx_filter_beacon()
    
    Currently, wfx_update_filtering() is sometime called only to apply the
    value of wvif->filter_beacon to the hardware. It is nicer to have a
    specific function for beacon filtering.
    
    In add, an attentive reader would note that wfx_update_filtering() is
    always called after change of wvif->filter_beacon. Thus, it not
    necessary to store filter_beacon in the struct wfx_vif. We can just pass
    it as parameter.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200415161147.69738-18-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index a9261ef4b4c5..1ccd40a3322f 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -113,9 +113,8 @@ void wfx_cqm_bssloss_sm(struct wfx_vif *wvif, int init, int good, int bad)
 	mutex_unlock(&wvif->bss_loss_lock);
 }
 
-void wfx_update_filtering(struct wfx_vif *wvif)
+static void wfx_filter_beacon(struct wfx_vif *wvif, bool filter_beacon)
 {
-	int i;
 	const struct hif_ie_table_entry filter_ies[] = {
 		{
 			.ie_id        = WLAN_EID_VENDOR_SPECIFIC,
@@ -136,13 +135,18 @@ void wfx_update_filtering(struct wfx_vif *wvif)
 		}
 	};
 
-	if (!wvif->filter_beacon) {
+	if (!filter_beacon) {
 		hif_set_beacon_filter_table(wvif, 0, NULL);
 		hif_beacon_filter_control(wvif, 0, 1);
 	} else {
 		hif_set_beacon_filter_table(wvif, 3, filter_ies);
 		hif_beacon_filter_control(wvif, HIF_BEACON_FILTER_ENABLE, 0);
 	}
+}
+
+void wfx_update_filtering(struct wfx_vif *wvif)
+{
+	int i;
 
 	// Temporary workaround for filters
 	hif_set_data_filtering(wvif, false, true);
@@ -194,7 +198,7 @@ void wfx_configure_filter(struct ieee80211_hw *hw,
 {
 	struct wfx_vif *wvif = NULL;
 	struct wfx_dev *wdev = hw->priv;
-	bool filter_bssid, filter_prbreq;
+	bool filter_bssid, filter_prbreq, filter_beacon;
 
 	// Notes:
 	//   - Probe responses (FIF_BCN_PRBRESP_PROMISC) are never filtered
@@ -213,9 +217,10 @@ void wfx_configure_filter(struct ieee80211_hw *hw,
 		// Note: FIF_BCN_PRBRESP_PROMISC covers probe response and
 		// beacons from other BSS
 		if (*total_flags & FIF_BCN_PRBRESP_PROMISC)
-			wvif->filter_beacon = false;
+			filter_beacon = false;
 		else
-			wvif->filter_beacon = true;
+			filter_beacon = true;
+		wfx_filter_beacon(wvif, filter_beacon);
 
 		if (*total_flags & FIF_ALLMULTI) {
 			wvif->filter_mcast = false;
@@ -501,8 +506,7 @@ static void wfx_do_join(struct wfx_vif *wvif)
 		 * Disable filtering temporary to make sure the stack
 		 * receives at least one
 		 */
-		wvif->filter_beacon = false;
-		wfx_update_filtering(wvif);
+		wfx_filter_beacon(wvif, false);
 	}
 	wfx_tx_unlock(wvif->wdev);
 }
@@ -703,8 +707,7 @@ void wfx_bss_info_changed(struct ieee80211_hw *hw,
 					     info->dtim_period);
 		// We temporary forwarded beacon for join process. It is now no
 		// more necessary.
-		wvif->filter_beacon = true;
-		wfx_update_filtering(wvif);
+		wfx_filter_beacon(wvif, true);
 	}
 
 	/* assoc/disassoc, or maybe AID changed */

commit a558395d4ce328d39772ffd88422aaad5d572449
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Wed Apr 15 18:11:43 2020 +0200

    staging: wfx: drop useless attributes 'filter_prbreq' and 'filter_bssid'
    
    It is now useless to store filter_prbreq and filter_bssid in struct
    wfx_vif. We can just pass them as parameters to hif_set_rx_filter().
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200415161147.69738-17-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index c7505b5d0947..a9261ef4b4c5 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -194,6 +194,7 @@ void wfx_configure_filter(struct ieee80211_hw *hw,
 {
 	struct wfx_vif *wvif = NULL;
 	struct wfx_dev *wdev = hw->priv;
+	bool filter_bssid, filter_prbreq;
 
 	// Notes:
 	//   - Probe responses (FIF_BCN_PRBRESP_PROMISC) are never filtered
@@ -227,9 +228,9 @@ void wfx_configure_filter(struct ieee80211_hw *hw,
 		wfx_update_filtering(wvif);
 
 		if (*total_flags & FIF_OTHER_BSS)
-			wvif->filter_bssid = false;
+			filter_bssid = false;
 		else
-			wvif->filter_bssid = true;
+			filter_bssid = true;
 
 		// In AP mode, chip can reply to probe request itself
 		if (*total_flags & FIF_PROBE_REQ &&
@@ -239,11 +240,10 @@ void wfx_configure_filter(struct ieee80211_hw *hw,
 		}
 
 		if (*total_flags & FIF_PROBE_REQ)
-			wvif->filter_prbreq = false;
+			filter_prbreq = false;
 		else
-			wvif->filter_prbreq = true;
-		hif_set_rx_filter(wvif, wvif->filter_bssid,
-				  wvif->filter_prbreq);
+			filter_prbreq = true;
+		hif_set_rx_filter(wvif, filter_bssid, filter_prbreq);
 
 		mutex_unlock(&wvif->scan_lock);
 	}

commit f41224bd47fe2f6a36bf2ba579ed5f677e288ffa
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Wed Apr 15 18:11:42 2020 +0200

    staging: wfx: drop useless call to hif_set_rx_filter()
    
    hif_set_rx_filter() apply changes on filter_prbreq and filter_bssid to
    the hardware. Each time filter_prbreq and filter_bssid are changed,
    hif_set_rx_filter() is called.
    
    Currently, on extra call to hif_set_rx_filter() is made from
    wfx_update_filtering(). This call is useless. Drop it.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200415161147.69738-16-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index 70342bdd9d96..c7505b5d0947 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -136,7 +136,6 @@ void wfx_update_filtering(struct wfx_vif *wvif)
 		}
 	};
 
-	hif_set_rx_filter(wvif, wvif->filter_bssid, wvif->filter_prbreq);
 	if (!wvif->filter_beacon) {
 		hif_set_beacon_filter_table(wvif, 0, NULL);
 		hif_beacon_filter_control(wvif, 0, 1);

commit 981132aa039d90456abf2bed7a2f6472c9dc3f98
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Wed Apr 15 18:11:41 2020 +0200

    staging: wfx: drop struct wfx_grp_addr_table
    
    The struct wfx_grp_addr_table is only instantiated on one place. There
    is no justifiation for this struct. Moreover, it is not consistent with
    other fields related to filtering (filter_bssid, etc...).
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200415161147.69738-15-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index 3a105d485237..70342bdd9d96 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -149,17 +149,16 @@ void wfx_update_filtering(struct wfx_vif *wvif)
 	hif_set_data_filtering(wvif, false, true);
 	return;
 
-	if (!wvif->mcast_filter.enable) {
+	if (!wvif->filter_mcast) {
 		hif_set_data_filtering(wvif, false, true);
 		return;
 	}
-	for (i = 0; i < wvif->mcast_filter.num_addresses; i++)
-		hif_set_mac_addr_condition(wvif, i,
-					   wvif->mcast_filter.address_list[i]);
+	for (i = 0; i < wvif->filter_mcast_count; i++)
+		hif_set_mac_addr_condition(wvif, i, wvif->filter_mcast_addr[i]);
 	hif_set_uc_mc_bc_condition(wvif, 0,
 				   HIF_FILTER_UNICAST | HIF_FILTER_BROADCAST);
 	hif_set_config_data_filter(wvif, true, 0, BIT(1),
-				   BIT(wvif->mcast_filter.num_addresses) - 1);
+				   BIT(wvif->filter_mcast_count) - 1);
 	hif_set_data_filtering(wvif, true, true);
 }
 
@@ -173,18 +172,17 @@ u64 wfx_prepare_multicast(struct ieee80211_hw *hw,
 	int count = netdev_hw_addr_list_count(mc_list);
 
 	while ((wvif = wvif_iterate(wdev, wvif)) != NULL) {
-		memset(&wvif->mcast_filter, 0x00, sizeof(wvif->mcast_filter));
-		if (!count ||
-		    count > ARRAY_SIZE(wvif->mcast_filter.address_list))
+		if (count > ARRAY_SIZE(wvif->filter_mcast_addr)) {
+			wvif->filter_mcast_count = 0;
 			continue;
+		}
+		wvif->filter_mcast_count = count;
 
 		i = 0;
 		netdev_hw_addr_list_for_each(ha, mc_list) {
-			ether_addr_copy(wvif->mcast_filter.address_list[i],
-					ha->addr);
+			ether_addr_copy(wvif->filter_mcast_addr[i], ha->addr);
 			i++;
 		}
-		wvif->mcast_filter.num_addresses = count;
 	}
 
 	return 0;
@@ -220,12 +218,12 @@ void wfx_configure_filter(struct ieee80211_hw *hw,
 			wvif->filter_beacon = true;
 
 		if (*total_flags & FIF_ALLMULTI) {
-			wvif->mcast_filter.enable = false;
-		} else if (!wvif->mcast_filter.num_addresses) {
+			wvif->filter_mcast = false;
+		} else if (!wvif->filter_mcast_count) {
 			dev_dbg(wdev->dev, "disabling unconfigured multicast filter");
-			wvif->mcast_filter.enable = false;
+			wvif->filter_mcast = false;
 		} else {
-			wvif->mcast_filter.enable = true;
+			wvif->filter_mcast = true;
 		}
 		wfx_update_filtering(wvif);
 

commit 6273691fbd50534982e864ccce482f8da6f2afac
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Wed Apr 15 18:11:40 2020 +0200

    staging: wfx: align semantic of probe request filter with other filters
    
    Filters provided by HIF API are sometime inclusive, sometime exclusive.
    
    This patch align the behavior and name of the probe request filter with
    the other filters.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200415161147.69738-14-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index 963cac83b6a8..3a105d485237 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -136,7 +136,7 @@ void wfx_update_filtering(struct wfx_vif *wvif)
 		}
 	};
 
-	hif_set_rx_filter(wvif, wvif->filter_bssid, wvif->fwd_probe_req);
+	hif_set_rx_filter(wvif, wvif->filter_bssid, wvif->filter_prbreq);
 	if (!wvif->filter_beacon) {
 		hif_set_beacon_filter_table(wvif, 0, NULL);
 		hif_beacon_filter_control(wvif, 0, 1);
@@ -242,11 +242,11 @@ void wfx_configure_filter(struct ieee80211_hw *hw,
 		}
 
 		if (*total_flags & FIF_PROBE_REQ)
-			wvif->fwd_probe_req = true;
+			wvif->filter_prbreq = false;
 		else
-			wvif->fwd_probe_req = false;
+			wvif->filter_prbreq = true;
 		hif_set_rx_filter(wvif, wvif->filter_bssid,
-				  wvif->fwd_probe_req);
+				  wvif->filter_prbreq);
 
 		mutex_unlock(&wvif->scan_lock);
 	}

commit b07357e02749b0858adf0314ff67abf5d523f03a
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Wed Apr 15 18:11:39 2020 +0200

    staging: wfx: align semantic of beacon filter with other filters
    
    Filters provided by HIF API are sometime inclusive, sometime exclusive.
    
    This patch align the behavior and name of the beacon filter with the
    other filters. Also avoid double negation: "disable filter"
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200415161147.69738-13-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index 8d2365a2e35b..963cac83b6a8 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -137,7 +137,7 @@ void wfx_update_filtering(struct wfx_vif *wvif)
 	};
 
 	hif_set_rx_filter(wvif, wvif->filter_bssid, wvif->fwd_probe_req);
-	if (wvif->disable_beacon_filter) {
+	if (!wvif->filter_beacon) {
 		hif_set_beacon_filter_table(wvif, 0, NULL);
 		hif_beacon_filter_control(wvif, 0, 1);
 	} else {
@@ -215,9 +215,9 @@ void wfx_configure_filter(struct ieee80211_hw *hw,
 		// Note: FIF_BCN_PRBRESP_PROMISC covers probe response and
 		// beacons from other BSS
 		if (*total_flags & FIF_BCN_PRBRESP_PROMISC)
-			wvif->disable_beacon_filter = true;
+			wvif->filter_beacon = false;
 		else
-			wvif->disable_beacon_filter = false;
+			wvif->filter_beacon = true;
 
 		if (*total_flags & FIF_ALLMULTI) {
 			wvif->mcast_filter.enable = false;
@@ -504,7 +504,7 @@ static void wfx_do_join(struct wfx_vif *wvif)
 		 * Disable filtering temporary to make sure the stack
 		 * receives at least one
 		 */
-		wvif->disable_beacon_filter = true;
+		wvif->filter_beacon = false;
 		wfx_update_filtering(wvif);
 	}
 	wfx_tx_unlock(wvif->wdev);
@@ -706,7 +706,7 @@ void wfx_bss_info_changed(struct ieee80211_hw *hw,
 					     info->dtim_period);
 		// We temporary forwarded beacon for join process. It is now no
 		// more necessary.
-		wvif->disable_beacon_filter = false;
+		wvif->filter_beacon = true;
 		wfx_update_filtering(wvif);
 	}
 

commit 824f830fc0943e91bbce44799e76dc50e1fbdad2
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Wed Apr 15 18:11:38 2020 +0200

    staging: wfx: drop useless wfx_fwd_probe_req()
    
    wfx_fwd_probe_req() is a function of two lines called from only one
    place. In order to uniformize all filtering functions, drop
    wfx_fwd_probe_req().
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200415161147.69738-12-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index b785b1b7d583..8d2365a2e35b 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -113,13 +113,6 @@ void wfx_cqm_bssloss_sm(struct wfx_vif *wvif, int init, int good, int bad)
 	mutex_unlock(&wvif->bss_loss_lock);
 }
 
-int wfx_fwd_probe_req(struct wfx_vif *wvif, bool enable)
-{
-	wvif->fwd_probe_req = enable;
-	return hif_set_rx_filter(wvif, wvif->filter_bssid,
-				 wvif->fwd_probe_req);
-}
-
 void wfx_update_filtering(struct wfx_vif *wvif)
 {
 	int i;
@@ -249,9 +242,12 @@ void wfx_configure_filter(struct ieee80211_hw *hw,
 		}
 
 		if (*total_flags & FIF_PROBE_REQ)
-			wfx_fwd_probe_req(wvif, true);
+			wvif->fwd_probe_req = true;
 		else
-			wfx_fwd_probe_req(wvif, false);
+			wvif->fwd_probe_req = false;
+		hif_set_rx_filter(wvif, wvif->filter_bssid,
+				  wvif->fwd_probe_req);
+
 		mutex_unlock(&wvif->scan_lock);
 	}
 	mutex_unlock(&wdev->conf_mutex);

commit ed4a707d2643de1afb938095558e3e61f6c3badd
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Wed Apr 15 18:11:37 2020 +0200

    staging: wfx: ensure that probe requests are filtered when AP
    
    Device is able to automatically reply to probe request (therefore, the
    probe requests are not forwarded to host). This feature is enabled by
    wfx_start_ap(). However, further calls to wfx_configure_filter() can
    disable it.
    
    So, relocate the handling of probe request filtering in
    wfx_configure_filter().
    
    Note that wfx_configure_filter() is always called by mac80211 when an AP
    start.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200415161147.69738-11-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index 0b2ef2d3023b..b785b1b7d583 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -241,6 +241,13 @@ void wfx_configure_filter(struct ieee80211_hw *hw,
 		else
 			wvif->filter_bssid = true;
 
+		// In AP mode, chip can reply to probe request itself
+		if (*total_flags & FIF_PROBE_REQ &&
+		    wvif->vif->type == NL80211_IFTYPE_AP) {
+			dev_dbg(wdev->dev, "do not forward probe request in AP mode\n");
+			*total_flags &= ~FIF_PROBE_REQ;
+		}
+
 		if (*total_flags & FIF_PROBE_REQ)
 			wfx_fwd_probe_req(wvif, true);
 		else
@@ -577,7 +584,6 @@ int wfx_start_ap(struct ieee80211_hw *hw, struct ieee80211_vif *vif)
 	wvif->state = WFX_STATE_AP;
 	wfx_update_filtering(wvif);
 	wfx_upload_ap_templates(wvif);
-	wfx_fwd_probe_req(wvif, false);
 	hif_start(wvif, &vif->bss_conf, wvif->channel);
 	return 0;
 }

commit 349e540a3d09ccd8ee1367bed09958899bfd9ff1
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Wed Apr 15 18:11:35 2020 +0200

    staging: wfx: do not use built-in AUTO_ERP feature
    
    Firmware is able to detect detect changes about ERP protection in
    beacons and automatically enable/disable ERP protection. However, it not
    bring performance improvements and we are more confident in the ERP
    handling of mac80211. So, the patch disable this feature.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200415161147.69738-9-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index 7c8ebd76114e..0b2ef2d3023b 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -147,10 +147,6 @@ void wfx_update_filtering(struct wfx_vif *wvif)
 	if (wvif->disable_beacon_filter) {
 		hif_set_beacon_filter_table(wvif, 0, NULL);
 		hif_beacon_filter_control(wvif, 0, 1);
-	} else if (wvif->vif->type != NL80211_IFTYPE_STATION) {
-		hif_set_beacon_filter_table(wvif, 2, filter_ies);
-		hif_beacon_filter_control(wvif, HIF_BEACON_FILTER_ENABLE |
-						HIF_BEACON_FILTER_AUTO_ERP, 0);
 	} else {
 		hif_set_beacon_filter_table(wvif, 3, filter_ies);
 		hif_beacon_filter_control(wvif, HIF_BEACON_FILTER_ENABLE, 0);

commit eb52d63a6dbded02375fa094dacec9c4503b8b72
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Wed Apr 15 18:11:34 2020 +0200

    staging: wfx: disabling beacon filtering after hif_reset() is useless
    
    After hif_reset(), device stop to receive any RF data. So, it is
    useless to disable beacon filtering. In add, if necessary, mac80211 will
    call wfx_configure_filter().
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200415161147.69738-8-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index c8a23146cae0..7c8ebd76114e 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -419,8 +419,6 @@ static void wfx_do_unjoin(struct wfx_vif *wvif)
 	cancel_work_sync(&wvif->event_handler_work);
 	wfx_cqm_bssloss_sm(wvif, 0, 0, 0);
 
-	wvif->disable_beacon_filter = false;
-	wfx_update_filtering(wvif);
 	memset(&wvif->bss_params, 0, sizeof(wvif->bss_params));
 	wfx_tx_unlock(wvif->wdev);
 }

commit 1ab6bf4c56bb5f3ecea4453d40a7f4e882a7fbb7
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Wed Apr 15 18:11:33 2020 +0200

    staging: wfx: do not wait for a dtim before associate
    
    The only reason we ask to mac80211 to wait for a dtim before to
    associate is to get an accurate DTIM value. However, we can temporary
    set the dtim period to 1. Then we can waiting for
    BSS_CHANGED_BEACON_INFO for the real value. Thus, the association
    process is faster.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200415161147.69738-7-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index 7255899b4a5a..c8a23146cae0 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -630,8 +630,7 @@ static void wfx_join_finalize(struct wfx_vif *wvif,
 		wvif->state = WFX_STATE_STA;
 		hif_keep_alive_period(wvif, 0);
 		hif_set_bss_params(wvif, &wvif->bss_params);
-		hif_set_beacon_wakeup_period(wvif, info->dtim_period,
-					     info->dtim_period);
+		hif_set_beacon_wakeup_period(wvif, 1, 1);
 		wfx_update_pm(wvif);
 	}
 }

commit b3919d9bbcde6c27f2072dd4242c54e076bb17b7
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Wed Apr 15 18:11:32 2020 +0200

    staging: wfx: wfx_update_filtering_work() is no more used
    
    Since we had simplified the join process, update_filtering_work is no
    more used. Drop it.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200415161147.69738-6-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index b01467f7606a..7255899b4a5a 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -174,14 +174,6 @@ void wfx_update_filtering(struct wfx_vif *wvif)
 	hif_set_data_filtering(wvif, true, true);
 }
 
-static void wfx_update_filtering_work(struct work_struct *work)
-{
-	struct wfx_vif *wvif = container_of(work, struct wfx_vif,
-					    update_filtering_work);
-
-	wfx_update_filtering(wvif);
-}
-
 u64 wfx_prepare_multicast(struct ieee80211_hw *hw,
 			  struct netdev_hw_addr_list *mc_list)
 {
@@ -415,7 +407,6 @@ static void wfx_do_unjoin(struct wfx_vif *wvif)
 	if (wvif->state == WFX_STATE_AP)
 		return;
 
-	cancel_work_sync(&wvif->update_filtering_work);
 	wvif->state = WFX_STATE_PASSIVE;
 
 	/* Unjoin is a reset. */
@@ -934,7 +925,6 @@ int wfx_add_interface(struct ieee80211_hw *hw, struct ieee80211_vif *vif)
 
 	init_completion(&wvif->set_pm_mode_complete);
 	complete(&wvif->set_pm_mode_complete);
-	INIT_WORK(&wvif->update_filtering_work, wfx_update_filtering_work);
 	INIT_WORK(&wvif->bss_params_work, wfx_bss_params_work);
 	INIT_WORK(&wvif->tx_policy_upload_work, wfx_tx_policy_upload_work);
 

commit e269060e79ed834c5519a037facc5944ea52f739
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Wed Apr 15 18:11:31 2020 +0200

    staging: wfx: simplify handling of beacon filter during join process
    
    When the device joins an AP, beacon are forwarded to the host. Once has
    retrieved all necessary parameters, we can start to filter the beacon
    (and only beacon with changed/new data will be forwarded).
    
    Currently, the driver detect beacons in data Rx process. It is far more
    easier to just wait for the BSS_CHANGED_BEACON_INFO event.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200415161147.69738-5-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index ec949ce0b256..b01467f7606a 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -712,9 +712,17 @@ void wfx_bss_info_changed(struct ieee80211_hw *hw,
 	if (changed & BSS_CHANGED_BEACON_ENABLED)
 		wfx_enable_beacon(wvif, info->enable_beacon);
 
-	if (changed & BSS_CHANGED_BEACON_INFO)
+	if (changed & BSS_CHANGED_BEACON_INFO) {
+		if (vif->type != NL80211_IFTYPE_STATION)
+			dev_warn(wdev->dev, "%s: misunderstood change: BEACON_INFO\n",
+				 __func__);
 		hif_set_beacon_wakeup_period(wvif, info->dtim_period,
 					     info->dtim_period);
+		// We temporary forwarded beacon for join process. It is now no
+		// more necessary.
+		wvif->disable_beacon_filter = false;
+		wfx_update_filtering(wvif);
+	}
 
 	/* assoc/disassoc, or maybe AID changed */
 	if (changed & BSS_CHANGED_ASSOC) {

commit b460713a5a2927998729fd22d9c649bcc9f1a9de
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Wed Apr 15 18:11:30 2020 +0200

    staging: wfx: rework wfx_configure_filter()
    
    wfx_configure_filter() lacks of coherency. In add, some corner cases
    seems to not been handled properly. Rework the whole function().
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200415161147.69738-4-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index 14e2f106b042..ec949ce0b256 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -203,7 +203,6 @@ u64 wfx_prepare_multicast(struct ieee80211_hw *hw,
 					ha->addr);
 			i++;
 		}
-		wvif->mcast_filter.enable = true;
 		wvif->mcast_filter.num_addresses = count;
 	}
 
@@ -218,16 +217,46 @@ void wfx_configure_filter(struct ieee80211_hw *hw,
 	struct wfx_vif *wvif = NULL;
 	struct wfx_dev *wdev = hw->priv;
 
-	*total_flags &= FIF_OTHER_BSS | FIF_FCSFAIL | FIF_PROBE_REQ;
+	// Notes:
+	//   - Probe responses (FIF_BCN_PRBRESP_PROMISC) are never filtered
+	//   - PS-Poll (FIF_PSPOLL) are never filtered
+	//   - RTS, CTS and Ack (FIF_CONTROL) are always filtered
+	//   - Broken frames (FIF_FCSFAIL and FIF_PLCPFAIL) are always filtered
+	//   - Firmware does (yet) allow to forward unicast traffic sent to
+	//     other stations (aka. promiscuous mode)
+	*total_flags &= FIF_BCN_PRBRESP_PROMISC | FIF_ALLMULTI | FIF_OTHER_BSS |
+			FIF_PROBE_REQ | FIF_PSPOLL;
 
 	mutex_lock(&wdev->conf_mutex);
 	while ((wvif = wvif_iterate(wdev, wvif)) != NULL) {
 		mutex_lock(&wvif->scan_lock);
-		wvif->filter_bssid = (*total_flags &
-				      (FIF_OTHER_BSS | FIF_PROBE_REQ)) ? 0 : 1;
-		wvif->disable_beacon_filter = !(*total_flags & FIF_PROBE_REQ);
-		wfx_fwd_probe_req(wvif, true);
+
+		// Note: FIF_BCN_PRBRESP_PROMISC covers probe response and
+		// beacons from other BSS
+		if (*total_flags & FIF_BCN_PRBRESP_PROMISC)
+			wvif->disable_beacon_filter = true;
+		else
+			wvif->disable_beacon_filter = false;
+
+		if (*total_flags & FIF_ALLMULTI) {
+			wvif->mcast_filter.enable = false;
+		} else if (!wvif->mcast_filter.num_addresses) {
+			dev_dbg(wdev->dev, "disabling unconfigured multicast filter");
+			wvif->mcast_filter.enable = false;
+		} else {
+			wvif->mcast_filter.enable = true;
+		}
 		wfx_update_filtering(wvif);
+
+		if (*total_flags & FIF_OTHER_BSS)
+			wvif->filter_bssid = false;
+		else
+			wvif->filter_bssid = true;
+
+		if (*total_flags & FIF_PROBE_REQ)
+			wfx_fwd_probe_req(wvif, true);
+		else
+			wfx_fwd_probe_req(wvif, false);
 		mutex_unlock(&wvif->scan_lock);
 	}
 	mutex_unlock(&wdev->conf_mutex);

commit e86bc725ba5f96ec687f30c924c9d82eea095968
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Wed Apr 15 18:11:29 2020 +0200

    staging: wfx: simplify wfx_update_filtering()
    
    Inline wfx_set_mcast_filter() into wfx_update_filtering() and remove
    useless intermediate variables.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200415161147.69738-3-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index cb9d14471745..14e2f106b042 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -120,34 +120,9 @@ int wfx_fwd_probe_req(struct wfx_vif *wvif, bool enable)
 				 wvif->fwd_probe_req);
 }
 
-static int wfx_set_mcast_filter(struct wfx_vif *wvif,
-				    struct wfx_grp_addr_table *fp)
-{
-	int i;
-
-	// Temporary workaround for filters
-	return hif_set_data_filtering(wvif, false, true);
-
-	if (!fp->enable)
-		return hif_set_data_filtering(wvif, false, true);
-
-	for (i = 0; i < fp->num_addresses; i++)
-		hif_set_mac_addr_condition(wvif, i, fp->address_list[i]);
-	hif_set_uc_mc_bc_condition(wvif, 0,
-				   HIF_FILTER_UNICAST | HIF_FILTER_BROADCAST);
-	hif_set_config_data_filter(wvif, true, 0, BIT(1),
-				   BIT(fp->num_addresses) - 1);
-	hif_set_data_filtering(wvif, true, true);
-
-	return 0;
-}
-
 void wfx_update_filtering(struct wfx_vif *wvif)
 {
-	int ret;
-	int bf_enable;
-	int bf_count;
-	int n_filter_ies;
+	int i;
 	const struct hif_ie_table_entry filter_ies[] = {
 		{
 			.ie_id        = WLAN_EID_VENDOR_SPECIFIC,
@@ -168,29 +143,35 @@ void wfx_update_filtering(struct wfx_vif *wvif)
 		}
 	};
 
+	hif_set_rx_filter(wvif, wvif->filter_bssid, wvif->fwd_probe_req);
 	if (wvif->disable_beacon_filter) {
-		bf_enable = 0;
-		bf_count = 1;
-		n_filter_ies = 0;
+		hif_set_beacon_filter_table(wvif, 0, NULL);
+		hif_beacon_filter_control(wvif, 0, 1);
 	} else if (wvif->vif->type != NL80211_IFTYPE_STATION) {
-		bf_enable = HIF_BEACON_FILTER_ENABLE | HIF_BEACON_FILTER_AUTO_ERP;
-		bf_count = 0;
-		n_filter_ies = 2;
+		hif_set_beacon_filter_table(wvif, 2, filter_ies);
+		hif_beacon_filter_control(wvif, HIF_BEACON_FILTER_ENABLE |
+						HIF_BEACON_FILTER_AUTO_ERP, 0);
 	} else {
-		bf_enable = HIF_BEACON_FILTER_ENABLE;
-		bf_count = 0;
-		n_filter_ies = 3;
+		hif_set_beacon_filter_table(wvif, 3, filter_ies);
+		hif_beacon_filter_control(wvif, HIF_BEACON_FILTER_ENABLE, 0);
 	}
 
-	ret = hif_set_rx_filter(wvif, wvif->filter_bssid, wvif->fwd_probe_req);
-	if (!ret)
-		ret = hif_set_beacon_filter_table(wvif, n_filter_ies, filter_ies);
-	if (!ret)
-		ret = hif_beacon_filter_control(wvif, bf_enable, bf_count);
-	if (!ret)
-		ret = wfx_set_mcast_filter(wvif, &wvif->mcast_filter);
-	if (ret)
-		dev_err(wvif->wdev->dev, "update filtering failed: %d\n", ret);
+	// Temporary workaround for filters
+	hif_set_data_filtering(wvif, false, true);
+	return;
+
+	if (!wvif->mcast_filter.enable) {
+		hif_set_data_filtering(wvif, false, true);
+		return;
+	}
+	for (i = 0; i < wvif->mcast_filter.num_addresses; i++)
+		hif_set_mac_addr_condition(wvif, i,
+					   wvif->mcast_filter.address_list[i]);
+	hif_set_uc_mc_bc_condition(wvif, 0,
+				   HIF_FILTER_UNICAST | HIF_FILTER_BROADCAST);
+	hif_set_config_data_filter(wvif, true, 0, BIT(1),
+				   BIT(wvif->mcast_filter.num_addresses) - 1);
+	hif_set_data_filtering(wvif, true, true);
 }
 
 static void wfx_update_filtering_work(struct work_struct *work)

commit 427fd02e168179f87ed3fd3f022d08a78cc51e3b
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Wed Apr 15 18:11:28 2020 +0200

    staging: wfx: update filtering even if not connected
    
    Currently, filtering are not update if the device is not connected.
    There is no obvious rationale for that. Updating filtering while it is
    not necessary is harmless. On the other hand, it is difficult to ensure
    that the filtering rule has been correctly sent to the firmware.
    
    Just drop this useless condition.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200415161147.69738-2-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index f1df7717d5f4..cb9d14471745 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -168,9 +168,6 @@ void wfx_update_filtering(struct wfx_vif *wvif)
 		}
 	};
 
-	if (wvif->state == WFX_STATE_PASSIVE)
-		return;
-
 	if (wvif->disable_beacon_filter) {
 		bf_enable = 0;
 		bf_count = 1;

commit a53f548597805dfa3b5bcc7036cd81cd212381e7
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Fri Apr 10 15:32:39 2020 +0200

    staging: wfx: drop useless update of macaddr
    
    Mac address is set in wfx_add_interface() and removed in
    wfx_remove_interface().
    
    Currently, there is also an additional update of mac address in
    wfx_do_unjoin(). It has no rationale. Mac address is already present
    and nothing has changed it. Therefore, we can drop it.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200410133239.438347-20-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index 53ab9648184a..f1df7717d5f4 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -415,7 +415,6 @@ static void wfx_do_unjoin(struct wfx_vif *wvif)
 	wfx_tx_lock_flush(wvif->wdev);
 	hif_reset(wvif, false);
 	wfx_tx_policy_init(wvif);
-	hif_set_macaddr(wvif, wvif->vif->addr);
 	if (wvif_count(wvif->wdev) <= 1)
 		hif_set_block_ack_policy(wvif, 0xFF, 0xFF);
 	wfx_free_event_queue(wvif);

commit 790241e92847c93f1bd7772299e6c58fb8f185e8
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Fri Apr 10 15:32:38 2020 +0200

    staging: wfx: drop unused attribute 'beacon_int'
    
    The field beacon_int is never read. Drop it.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200410133239.438347-19-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index 91b4ce945598..53ab9648184a 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -478,10 +478,6 @@ static void wfx_do_join(struct wfx_vif *wvif)
 		return;
 	}
 
-	/* Sanity check beacon interval */
-	if (!wvif->beacon_int)
-		wvif->beacon_int = 1;
-
 	rcu_read_lock(); // protect ssidie
 	if (bss)
 		ssidie = ieee80211_bss_get_ie(bss, WLAN_EID_SSID);
@@ -611,7 +607,6 @@ static void wfx_join_finalize(struct wfx_vif *wvif,
 {
 	struct ieee80211_sta *sta = NULL;
 
-	wvif->beacon_int = info->beacon_int;
 	rcu_read_lock(); // protect sta
 	if (info->bssid && !info->ibss_joined)
 		sta = ieee80211_find_sta(wvif->vif, info->bssid);

commit ac243a1b6ff03c1874bddb9fcbc74694da497783
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Fri Apr 10 15:32:36 2020 +0200

    staging: wfx: re-enable BA after reset
    
    Firmware does not support Block Acks when multiple vif are running.
    Thus, wfx_add_interface() and wfx_remove_interface() enable and disable
    Block Acks as necessary.
    
    Block Ack policy is also reset after hif_reset(). Driver have to
    re-enable it after each call to hif_reset().
    
    This patch reflects this behavior.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200410133239.438347-17-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index 21eceafc9a95..91b4ce945598 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -416,13 +416,12 @@ static void wfx_do_unjoin(struct wfx_vif *wvif)
 	hif_reset(wvif, false);
 	wfx_tx_policy_init(wvif);
 	hif_set_macaddr(wvif, wvif->vif->addr);
+	if (wvif_count(wvif->wdev) <= 1)
+		hif_set_block_ack_policy(wvif, 0xFF, 0xFF);
 	wfx_free_event_queue(wvif);
 	cancel_work_sync(&wvif->event_handler_work);
 	wfx_cqm_bssloss_sm(wvif, 0, 0, 0);
 
-	/* Disable Block ACKs */
-	hif_set_block_ack_policy(wvif, 0, 0);
-
 	wvif->disable_beacon_filter = false;
 	wfx_update_filtering(wvif);
 	memset(&wvif->bss_params, 0, sizeof(wvif->bss_params));
@@ -492,9 +491,6 @@ static void wfx_do_join(struct wfx_vif *wvif)
 	}
 	rcu_read_unlock();
 
-	if (wvif_count(wvif->wdev) <= 1)
-		hif_set_block_ack_policy(wvif, 0xFF, 0xFF);
-
 	wfx_set_mfp(wvif, bss);
 	cfg80211_put_bss(wvif->wdev->hw->wiphy, bss);
 
@@ -591,8 +587,6 @@ int wfx_start_ap(struct ieee80211_hw *hw, struct ieee80211_vif *vif)
 	struct wfx_vif *wvif = (struct wfx_vif *)vif->drv_priv;
 
 	wfx_upload_keys(wvif);
-	if (wvif_count(wvif->wdev) <= 1)
-		hif_set_block_ack_policy(wvif, 0xFF, 0xFF);
 	wvif->state = WFX_STATE_AP;
 	wfx_update_filtering(wvif);
 	wfx_upload_ap_templates(wvif);
@@ -607,6 +601,8 @@ void wfx_stop_ap(struct ieee80211_hw *hw, struct ieee80211_vif *vif)
 
 	hif_reset(wvif, false);
 	wfx_tx_policy_init(wvif);
+	if (wvif_count(wvif->wdev) <= 1)
+		hif_set_block_ack_policy(wvif, 0xFF, 0xFF);
 	wvif->state = WFX_STATE_PASSIVE;
 }
 

commit e836ad4e2da4c4472bb08c15fcd60493d5a09d64
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Fri Apr 10 15:32:35 2020 +0200

    staging: wfx: introduce wfx_join_ibss() and wfx_leave_ibss()
    
    Currently, IBSS networks are started by the mean of
    wfx_bss_info_changed(). It easier to use use callbacks provided by
    mac80211.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200410133239.438347-16-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index 8aa373f5deae..21eceafc9a95 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -648,6 +648,22 @@ static void wfx_join_finalize(struct wfx_vif *wvif,
 	}
 }
 
+int wfx_join_ibss(struct ieee80211_hw *hw, struct ieee80211_vif *vif)
+{
+	struct wfx_vif *wvif = (struct wfx_vif *)vif->drv_priv;
+
+	wfx_upload_ap_templates(wvif);
+	wfx_do_join(wvif);
+	return 0;
+}
+
+void wfx_leave_ibss(struct ieee80211_hw *hw, struct ieee80211_vif *vif)
+{
+	struct wfx_vif *wvif = (struct wfx_vif *)vif->drv_priv;
+
+	wfx_do_unjoin(wvif);
+}
+
 void wfx_enable_beacon(struct wfx_vif *wvif, bool enable)
 {
 	// Driver has Content After DTIM Beacon in queue. Driver is waiting for
@@ -688,8 +704,7 @@ void wfx_bss_info_changed(struct ieee80211_hw *hw,
 	if (changed & BSS_CHANGED_BASIC_RATES ||
 	    changed & BSS_CHANGED_BEACON_INT ||
 	    changed & BSS_CHANGED_BSSID) {
-		if (vif->type == NL80211_IFTYPE_STATION ||
-		    vif->type == NL80211_IFTYPE_ADHOC)
+		if (vif->type == NL80211_IFTYPE_STATION)
 			wfx_do_join(wvif);
 	}
 

commit 17c8cc79ef72a5791a7c5223d9f5905cdaa69f30
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Fri Apr 10 15:32:34 2020 +0200

    staging: wfx: allow to join IBSS networks
    
    Current code does not permit to join an already existing IBSS network.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200410133239.438347-15-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index 75f1c515751b..8aa373f5deae 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -484,7 +484,7 @@ static void wfx_do_join(struct wfx_vif *wvif)
 		wvif->beacon_int = 1;
 
 	rcu_read_lock(); // protect ssidie
-	if (!conf->ibss_joined)
+	if (bss)
 		ssidie = ieee80211_bss_get_ie(bss, WLAN_EID_SSID);
 	if (ssidie) {
 		ssidlen = ssidie[1];

commit 7b063f3bfbcd76b50b894ba16ed38a065ca33e07
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Fri Apr 10 15:32:33 2020 +0200

    staging: wfx: avoid duplicate updating of beacon template
    
    When ERP changes, mac80211 call wfx_bss_info_changed() with
    BSS_CHANGED_ERP_* and with BSS_CHANGED_BEACON.
    
    The driver already update beacon template because of
    BSS_CHANGED_BEACON. It is not necessary to also update beacon template
    because of BSS_CHANGED_ERP_*.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200410133239.438347-14-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index 11d62de531e7..75f1c515751b 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -725,18 +725,8 @@ void wfx_bss_info_changed(struct ieee80211_hw *hw,
 		hif_keep_alive_period(wvif, info->max_idle_period *
 					    USEC_PER_TU / USEC_PER_MSEC);
 
-	if (changed & BSS_CHANGED_ERP_CTS_PROT ||
-	    changed & BSS_CHANGED_ERP_PREAMBLE) {
-		u8 erp_ie[3] = { WLAN_EID_ERP_INFO, 1, 0 };
-
+	if (changed & BSS_CHANGED_ERP_CTS_PROT)
 		hif_erp_use_protection(wvif, info->use_cts_prot);
-		if (info->use_cts_prot)
-			erp_ie[2] |= WLAN_ERP_USE_PROTECTION;
-		if (info->use_short_preamble)
-			erp_ie[2] |= WLAN_ERP_BARKER_PREAMBLE;
-		if (wvif->vif->type != NL80211_IFTYPE_STATION)
-			hif_update_ie_beacon(wvif, erp_ie, sizeof(erp_ie));
-	}
 
 	if (changed & BSS_CHANGED_ERP_SLOT)
 		hif_slot_time(wvif, info->use_short_slot ? 9 : 20);

commit 974dfbf8fe411dff2e77d15ed8ec54777d13452c
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Fri Apr 10 15:32:32 2020 +0200

    staging: wfx: remove unnecessary conditions in wfx_bss_info_changed()
    
    wfx_bss_info_changed() update ERP and CQM related stuff. Thus, it check
    the flags BSS_CHANGED_ERP_* and BSS_CHANGED_CQM.
    
    It also update ERP and CQM on join and leave by checking the flag
    BSS_CHANGED_ASSOC. This check is useless. Mac80211 already do that job
    and set necessary flags as expected.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200410133239.438347-13-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index 3512e59f0968..11d62de531e7 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -725,8 +725,7 @@ void wfx_bss_info_changed(struct ieee80211_hw *hw,
 		hif_keep_alive_period(wvif, info->max_idle_period *
 					    USEC_PER_TU / USEC_PER_MSEC);
 
-	if (changed & BSS_CHANGED_ASSOC ||
-	    changed & BSS_CHANGED_ERP_CTS_PROT ||
+	if (changed & BSS_CHANGED_ERP_CTS_PROT ||
 	    changed & BSS_CHANGED_ERP_PREAMBLE) {
 		u8 erp_ie[3] = { WLAN_EID_ERP_INFO, 1, 0 };
 
@@ -739,10 +738,10 @@ void wfx_bss_info_changed(struct ieee80211_hw *hw,
 			hif_update_ie_beacon(wvif, erp_ie, sizeof(erp_ie));
 	}
 
-	if (changed & BSS_CHANGED_ASSOC || changed & BSS_CHANGED_ERP_SLOT)
+	if (changed & BSS_CHANGED_ERP_SLOT)
 		hif_slot_time(wvif, info->use_short_slot ? 9 : 20);
 
-	if (changed & BSS_CHANGED_ASSOC || changed & BSS_CHANGED_CQM)
+	if (changed & BSS_CHANGED_CQM)
 		hif_set_rcpi_rssi_threshold(wvif, info->cqm_rssi_thold,
 					    info->cqm_rssi_hyst);
 

commit 23d57c152cef193c96598bb449f3f7e83c4aae2e
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Fri Apr 10 15:32:31 2020 +0200

    staging: wfx: request to send beacons in IBSS mode
    
    Currently, firmware take in charge of start/stop sending beacons while
    in IBSS mode. However, this behavior may change in the further releases.
    
    Currently, asking to firmware to send beacon while in IBSS mode return
    an error but is harmless.
    
    Therefore, send this request unconditionally.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200410133239.438347-12-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index 7af7bfa4ac99..3512e59f0968 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -697,8 +697,7 @@ void wfx_bss_info_changed(struct ieee80211_hw *hw,
 	    changed & BSS_CHANGED_BEACON)
 		wfx_upload_ap_templates(wvif);
 
-	if (changed & BSS_CHANGED_BEACON_ENABLED &&
-	    wvif->state != WFX_STATE_IBSS)
+	if (changed & BSS_CHANGED_BEACON_ENABLED)
 		wfx_enable_beacon(wvif, info->enable_beacon);
 
 	if (changed & BSS_CHANGED_BEACON_INFO)

commit 9f9a18e40e0849b72857b7ed47b3d3bb70d93052
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Fri Apr 10 15:32:30 2020 +0200

    staging: wfx: drop unnecessary condition checks in wfx_upload_ap_templates()
    
    In former code, wfx_upload_ap_templates() was called in more cases
    than necessary. Therefore, it tried to not update the frame templates
    if it was not necessary.
    
    Now, wfx_upload_ap_templates() is called only if mac80211 asked to
    update the templates. In add, it does not hurt to upload template if
    they are not used. So, remove unnecessary conditions at beginning of
    wfx_upload_ap_templates()
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200410133239.438347-11-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index b0557dab91fd..7af7bfa4ac99 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -570,11 +570,6 @@ static int wfx_upload_ap_templates(struct wfx_vif *wvif)
 {
 	struct sk_buff *skb;
 
-	if (wvif->vif->type == NL80211_IFTYPE_STATION ||
-	    wvif->vif->type == NL80211_IFTYPE_MONITOR ||
-	    wvif->vif->type == NL80211_IFTYPE_UNSPECIFIED)
-		return 0;
-
 	skb = ieee80211_beacon_get(wvif->wdev->hw, wvif->vif);
 	if (!skb)
 		return -ENOMEM;

commit 54a9d85cab0892b5d3e5a5bba08a7f6973717025
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Fri Apr 10 15:32:29 2020 +0200

    staging: wfx: disabling keep alive during unjoin is useless
    
    After a call to hif_reset(), the parameters associated with BSS are
    reset. So, it useless to explicitly reset the keep alive period.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200410133239.438347-10-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index 67e16c435848..b0557dab91fd 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -413,7 +413,6 @@ static void wfx_do_unjoin(struct wfx_vif *wvif)
 
 	/* Unjoin is a reset. */
 	wfx_tx_lock_flush(wvif->wdev);
-	hif_keep_alive_period(wvif, 0);
 	hif_reset(wvif, false);
 	wfx_tx_policy_init(wvif);
 	hif_set_macaddr(wvif, wvif->vif->addr);

commit eeab4787d95b05a338e2a7ce125dc660c5fb232f
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Fri Apr 10 15:32:28 2020 +0200

    staging: wfx: fix support for BSS_CHANGED_KEEP_ALIVE
    
    Chip firmware is able to send periodic null frames to keep the
    association with the AP.
    
    The driver arbitrary set this period to 30sec. We prefer to rely on
    BSS_CHANGED_KEEP_ALIVE that provide a true value.
    
    Note that if BSS_CHANGED_KEEP_ALIVE is not received, we just disable
    keep_alive feature. It is not very disturbing since AP will probably
    ping the station before to disconnect it.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200410133239.438347-9-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index 7693ce22f300..67e16c435848 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -646,7 +646,7 @@ static void wfx_join_finalize(struct wfx_vif *wvif,
 
 	if (!info->ibss_joined) {
 		wvif->state = WFX_STATE_STA;
-		hif_keep_alive_period(wvif, 30 /* sec */);
+		hif_keep_alive_period(wvif, 0);
 		hif_set_bss_params(wvif, &wvif->bss_params);
 		hif_set_beacon_wakeup_period(wvif, info->dtim_period,
 					     info->dtim_period);
@@ -728,6 +728,10 @@ void wfx_bss_info_changed(struct ieee80211_hw *hw,
 				 __func__);
 	}
 
+	if (changed & BSS_CHANGED_KEEP_ALIVE)
+		hif_keep_alive_period(wvif, info->max_idle_period *
+					    USEC_PER_TU / USEC_PER_MSEC);
+
 	if (changed & BSS_CHANGED_ASSOC ||
 	    changed & BSS_CHANGED_ERP_CTS_PROT ||
 	    changed & BSS_CHANGED_ERP_PREAMBLE) {

commit eb63e2fddb51370fcb2ba77ce5e9d49515acc295
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Fri Apr 10 15:32:27 2020 +0200

    staging: wfx: remove useless call to wfx_tx_flush()
    
    wfx_do_join() calls wfx_tx_lock_flush() ate beginning of the function.
    Therefore, the subsequent call to wfx_tx_flush() is useless.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200410133239.438347-8-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index acbbc3a44733..7693ce22f300 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -493,8 +493,6 @@ static void wfx_do_join(struct wfx_vif *wvif)
 	}
 	rcu_read_unlock();
 
-	wfx_tx_flush(wvif->wdev);
-
 	if (wvif_count(wvif->wdev) <= 1)
 		hif_set_block_ack_policy(wvif, 0xFF, 0xFF);
 

commit 9abb6b26f62e392ba3761256e9e020a45c5629e3
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Fri Apr 10 15:32:26 2020 +0200

    staging: wfx: change the way the station associate to an AP
    
    Chipset need two steps to associate with an AP:
       1. it start receiving beacon from the AP (done with wfx_do_join())
       2. it sent the association request (done with wfx_join_finalize())
    
    The join request (see hif_join()) contains basic rates, beacon interval
    and bssid to connect, so we trig on these events for the first step.
    
    The second step is obviously associated to the event BSS_CHANGED_ASSOC.
    
    Note that conf_mutex is now easier to manage. It is held by
    wfx_bss_info_changed() and inner functions does not need to lock it.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200410133239.438347-7-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index 1e7ff2ba33d8..acbbc3a44733 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -471,16 +471,11 @@ static void wfx_do_join(struct wfx_vif *wvif)
 	int ssidlen = 0;
 
 	wfx_tx_lock_flush(wvif->wdev);
-	mutex_lock(&wvif->wdev->conf_mutex);
-
-	if (wvif->state)
-		wfx_do_unjoin(wvif);
 
 	bss = cfg80211_get_bss(wvif->wdev->hw->wiphy, wvif->channel,
 			       conf->bssid, NULL, 0,
 			       IEEE80211_BSS_TYPE_ANY, IEEE80211_PRIVACY_ANY);
 	if (!bss && !conf->ibss_joined) {
-		mutex_unlock(&wvif->wdev->conf_mutex);
 		wfx_tx_unlock(wvif->wdev);
 		return;
 	}
@@ -530,7 +525,6 @@ static void wfx_do_join(struct wfx_vif *wvif)
 		wfx_update_filtering(wvif);
 	}
 	wfx_tx_unlock(wvif->wdev);
-	mutex_unlock(&wvif->wdev->conf_mutex);
 }
 
 int wfx_sta_add(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
@@ -653,6 +647,7 @@ static void wfx_join_finalize(struct wfx_vif *wvif,
 	hif_set_association_mode(wvif, info);
 
 	if (!info->ibss_joined) {
+		wvif->state = WFX_STATE_STA;
 		hif_keep_alive_period(wvif, 30 /* sec */);
 		hif_set_bss_params(wvif, &wvif->bss_params);
 		hif_set_beacon_wakeup_period(wvif, info->dtim_period,
@@ -681,7 +676,6 @@ void wfx_bss_info_changed(struct ieee80211_hw *hw,
 {
 	struct wfx_dev *wdev = hw->priv;
 	struct wfx_vif *wvif = (struct wfx_vif *) vif->drv_priv;
-	bool do_join = false;
 	int i;
 
 	mutex_lock(&wdev->conf_mutex);
@@ -699,6 +693,14 @@ void wfx_bss_info_changed(struct ieee80211_hw *hw,
 		}
 	}
 
+	if (changed & BSS_CHANGED_BASIC_RATES ||
+	    changed & BSS_CHANGED_BEACON_INT ||
+	    changed & BSS_CHANGED_BSSID) {
+		if (vif->type == NL80211_IFTYPE_STATION ||
+		    vif->type == NL80211_IFTYPE_ADHOC)
+			wfx_do_join(wvif);
+	}
+
 	if (changed & BSS_CHANGED_AP_PROBE_RESP ||
 	    changed & BSS_CHANGED_BEACON)
 		wfx_upload_ap_templates(wvif);
@@ -718,41 +720,14 @@ void wfx_bss_info_changed(struct ieee80211_hw *hw,
 		wfx_tx_unlock(wdev);
 	}
 
-	if (changed & BSS_CHANGED_ASSOC && !info->assoc &&
-	    (wvif->state == WFX_STATE_STA || wvif->state == WFX_STATE_IBSS)) {
-		wfx_do_unjoin(wvif);
-	} else {
-		if (changed & BSS_CHANGED_BEACON_INT) {
-			if (info->ibss_joined)
-				do_join = true;
-		}
-
-		if (changed & BSS_CHANGED_BSSID)
-			do_join = true;
-
-		if (changed & BSS_CHANGED_ASSOC ||
-		    changed & BSS_CHANGED_BSSID ||
-		    changed & BSS_CHANGED_IBSS ||
-		    changed & BSS_CHANGED_BASIC_RATES ||
-		    changed & BSS_CHANGED_HT) {
-			if (info->assoc) {
-				if (wvif->state < WFX_STATE_PRE_STA) {
-					ieee80211_connection_loss(vif);
-					mutex_unlock(&wdev->conf_mutex);
-					return;
-				} else if (wvif->state == WFX_STATE_PRE_STA) {
-					wvif->state = WFX_STATE_STA;
-				}
-			} else {
-				do_join = true;
-			}
-
-			if (info->assoc || info->ibss_joined)
-				wfx_join_finalize(wvif, info);
-			else
-				memset(&wvif->bss_params, 0,
-				       sizeof(wvif->bss_params));
-		}
+	if (changed & BSS_CHANGED_ASSOC) {
+		if (info->assoc || info->ibss_joined)
+			wfx_join_finalize(wvif, info);
+		else if (!info->assoc && vif->type == NL80211_IFTYPE_STATION)
+			wfx_do_unjoin(wvif);
+		else
+			dev_warn(wdev->dev, "%s: misunderstood change: ASSOC\n",
+				 __func__);
 	}
 
 	if (changed & BSS_CHANGED_ASSOC ||
@@ -783,9 +758,6 @@ void wfx_bss_info_changed(struct ieee80211_hw *hw,
 		wfx_update_pm(wvif);
 
 	mutex_unlock(&wdev->conf_mutex);
-
-	if (do_join)
-		wfx_do_join(wvif);
 }
 
 static int wfx_update_tim(struct wfx_vif *wvif)

commit 3393eebd9ddbe952628b297374befd10d73e2741
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Fri Apr 10 15:32:25 2020 +0200

    staging: wfx: set all parameters before starting AP
    
    Current code start AP and then configure the different parameters. Since
    all the configuration is sent quickly after AP started, it works.
    However, it is not very nice. In add, last firmware releases start to
    disallow incorrect settings.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200410133239.438347-6-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index 92bf317b57bb..1e7ff2ba33d8 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -604,7 +604,6 @@ int wfx_start_ap(struct ieee80211_hw *hw, struct ieee80211_vif *vif)
 {
 	struct wfx_vif *wvif = (struct wfx_vif *)vif->drv_priv;
 
-	hif_start(wvif, &vif->bss_conf, wvif->channel);
 	wfx_upload_keys(wvif);
 	if (wvif_count(wvif->wdev) <= 1)
 		hif_set_block_ack_policy(wvif, 0xFF, 0xFF);
@@ -612,6 +611,7 @@ int wfx_start_ap(struct ieee80211_hw *hw, struct ieee80211_vif *vif)
 	wfx_update_filtering(wvif);
 	wfx_upload_ap_templates(wvif);
 	wfx_fwd_probe_req(wvif, false);
+	hif_start(wvif, &vif->bss_conf, wvif->channel);
 	return 0;
 }
 

commit cba1d8976db0032171bc36decd67df168e58bf3a
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Fri Apr 10 15:32:24 2020 +0200

    staging: wfx: implement start_ap/stop_ap
    
    Currently, wfx_bss_info_changed() check interface status changes and
    guess when the pattern match with an AP start and AP stop (through
    wfx_update_beaconing()). It is far easier to rely on start_ap and
    stop_ap callbacks provided by mac80211.
    
    wfx_bss_info_changed() keeps only the responsibility of updating the
    frame templates.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200410133239.438347-5-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index 36e55e32da2b..92bf317b57bb 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -575,40 +575,6 @@ int wfx_sta_remove(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 	return 0;
 }
 
-static int wfx_start_ap(struct wfx_vif *wvif)
-{
-	int ret;
-
-	wvif->beacon_int = wvif->vif->bss_conf.beacon_int;
-	ret = hif_start(wvif, &wvif->vif->bss_conf, wvif->channel);
-	if (ret)
-		return ret;
-	ret = wfx_upload_keys(wvif);
-	if (ret)
-		return ret;
-	if (wvif_count(wvif->wdev) <= 1)
-		hif_set_block_ack_policy(wvif, 0xFF, 0xFF);
-	wvif->state = WFX_STATE_AP;
-	wfx_update_filtering(wvif);
-	return 0;
-}
-
-static int wfx_update_beaconing(struct wfx_vif *wvif)
-{
-	if (wvif->vif->type != NL80211_IFTYPE_AP)
-		return 0;
-	if (wvif->state == WFX_STATE_AP &&
-	    wvif->beacon_int == wvif->vif->bss_conf.beacon_int)
-		return 0;
-	wfx_tx_lock_flush(wvif->wdev);
-	hif_reset(wvif, false);
-	wfx_tx_policy_init(wvif);
-	wvif->state = WFX_STATE_PASSIVE;
-	wfx_start_ap(wvif);
-	wfx_tx_unlock(wvif->wdev);
-	return 0;
-}
-
 static int wfx_upload_ap_templates(struct wfx_vif *wvif)
 {
 	struct sk_buff *skb;
@@ -634,6 +600,30 @@ static int wfx_upload_ap_templates(struct wfx_vif *wvif)
 	return 0;
 }
 
+int wfx_start_ap(struct ieee80211_hw *hw, struct ieee80211_vif *vif)
+{
+	struct wfx_vif *wvif = (struct wfx_vif *)vif->drv_priv;
+
+	hif_start(wvif, &vif->bss_conf, wvif->channel);
+	wfx_upload_keys(wvif);
+	if (wvif_count(wvif->wdev) <= 1)
+		hif_set_block_ack_policy(wvif, 0xFF, 0xFF);
+	wvif->state = WFX_STATE_AP;
+	wfx_update_filtering(wvif);
+	wfx_upload_ap_templates(wvif);
+	wfx_fwd_probe_req(wvif, false);
+	return 0;
+}
+
+void wfx_stop_ap(struct ieee80211_hw *hw, struct ieee80211_vif *vif)
+{
+	struct wfx_vif *wvif = (struct wfx_vif *)vif->drv_priv;
+
+	hif_reset(wvif, false);
+	wfx_tx_policy_init(wvif);
+	wvif->state = WFX_STATE_PASSIVE;
+}
+
 static void wfx_join_finalize(struct wfx_vif *wvif,
 			      struct ieee80211_bss_conf *info)
 {
@@ -709,16 +699,9 @@ void wfx_bss_info_changed(struct ieee80211_hw *hw,
 		}
 	}
 
-	if (changed & BSS_CHANGED_BEACON ||
-	    changed & BSS_CHANGED_AP_PROBE_RESP ||
-	    changed & BSS_CHANGED_BSSID ||
-	    changed & BSS_CHANGED_SSID ||
-	    changed & BSS_CHANGED_IBSS) {
-		wvif->beacon_int = info->beacon_int;
-		wfx_update_beaconing(wvif);
+	if (changed & BSS_CHANGED_AP_PROBE_RESP ||
+	    changed & BSS_CHANGED_BEACON)
 		wfx_upload_ap_templates(wvif);
-		wfx_fwd_probe_req(wvif, false);
-	}
 
 	if (changed & BSS_CHANGED_BEACON_ENABLED &&
 	    wvif->state != WFX_STATE_IBSS)
@@ -742,8 +725,6 @@ void wfx_bss_info_changed(struct ieee80211_hw *hw,
 		if (changed & BSS_CHANGED_BEACON_INT) {
 			if (info->ibss_joined)
 				do_join = true;
-			else if (wvif->state == WFX_STATE_AP)
-				wfx_update_beaconing(wvif);
 		}
 
 		if (changed & BSS_CHANGED_BSSID)

commit 836a8fc3f5073b204135a088908b15d868030c4c
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Fri Apr 10 15:32:23 2020 +0200

    staging: wfx: call wfx_do_unjoin() synchronously
    
    Currently, wfx_do_unjoin() are called by the mean of work queues.
    However, the contexts from where they are called are not atomic. So
    there is no reason to not call it synchronously.
    
    This change will simplify the code. Notice two main changes:
       - There no more reason to lock tx queue before to run
         wfx_do_unjoin(). We can lock the tx queue directly from
         wfx_do_unjoin().
       - Most of the time, wfx_do_unjoin_work() was called with conf_mutex
         held. This patch remove lock of conf_mutex in wfx_do_unjoin_work()
         and ensure that conf_mutex is always held whatever the context.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200410133239.438347-4-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index c65d464a7a9b..36e55e32da2b 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -354,14 +354,12 @@ static void wfx_event_handler_work(struct work_struct *work)
 	list_for_each_entry(event, &list, link) {
 		switch (event->evt.event_id) {
 		case HIF_EVENT_IND_BSSLOST:
-			cancel_work_sync(&wvif->unjoin_work);
 			mutex_lock(&wvif->scan_lock);
 			wfx_cqm_bssloss_sm(wvif, 1, 0, 0);
 			mutex_unlock(&wvif->scan_lock);
 			break;
 		case HIF_EVENT_IND_BSSREGAINED:
 			wfx_cqm_bssloss_sm(wvif, 0, 0, 0);
-			cancel_work_sync(&wvif->unjoin_work);
 			break;
 		case HIF_EVENT_IND_RCPI_RSSI:
 			wfx_event_report_rssi(wvif,
@@ -401,21 +399,20 @@ static void wfx_bss_params_work(struct work_struct *work)
 	mutex_unlock(&wvif->wdev->conf_mutex);
 }
 
+// Call it with wdev->conf_mutex locked
 static void wfx_do_unjoin(struct wfx_vif *wvif)
 {
-	mutex_lock(&wvif->wdev->conf_mutex);
-
 	if (!wvif->state)
-		goto done;
+		return;
 
 	if (wvif->state == WFX_STATE_AP)
-		goto done;
+		return;
 
 	cancel_work_sync(&wvif->update_filtering_work);
 	wvif->state = WFX_STATE_PASSIVE;
 
 	/* Unjoin is a reset. */
-	wfx_tx_flush(wvif->wdev);
+	wfx_tx_lock_flush(wvif->wdev);
 	hif_keep_alive_period(wvif, 0);
 	hif_reset(wvif, false);
 	wfx_tx_policy_init(wvif);
@@ -430,9 +427,7 @@ static void wfx_do_unjoin(struct wfx_vif *wvif)
 	wvif->disable_beacon_filter = false;
 	wfx_update_filtering(wvif);
 	memset(&wvif->bss_params, 0, sizeof(wvif->bss_params));
-
-done:
-	mutex_unlock(&wvif->wdev->conf_mutex);
+	wfx_tx_unlock(wvif->wdev);
 }
 
 static void wfx_set_mfp(struct wfx_vif *wvif,
@@ -476,6 +471,7 @@ static void wfx_do_join(struct wfx_vif *wvif)
 	int ssidlen = 0;
 
 	wfx_tx_lock_flush(wvif->wdev);
+	mutex_lock(&wvif->wdev->conf_mutex);
 
 	if (wvif->state)
 		wfx_do_unjoin(wvif);
@@ -484,12 +480,11 @@ static void wfx_do_join(struct wfx_vif *wvif)
 			       conf->bssid, NULL, 0,
 			       IEEE80211_BSS_TYPE_ANY, IEEE80211_PRIVACY_ANY);
 	if (!bss && !conf->ibss_joined) {
+		mutex_unlock(&wvif->wdev->conf_mutex);
 		wfx_tx_unlock(wvif->wdev);
 		return;
 	}
 
-	mutex_lock(&wvif->wdev->conf_mutex);
-
 	/* Sanity check beacon interval */
 	if (!wvif->beacon_int)
 		wvif->beacon_int = 1;
@@ -515,16 +510,13 @@ static void wfx_do_join(struct wfx_vif *wvif)
 	if (ret) {
 		ieee80211_connection_loss(wvif->vif);
 		wvif->join_complete_status = -1;
-		/* Tx lock still held, unjoin will clear it. */
-		if (!schedule_work(&wvif->unjoin_work))
-			wfx_tx_unlock(wvif->wdev);
+		wfx_do_unjoin(wvif);
 	} else {
 		wvif->join_complete_status = 0;
 		if (wvif->vif->type == NL80211_IFTYPE_ADHOC)
 			wvif->state = WFX_STATE_IBSS;
 		else
 			wvif->state = WFX_STATE_PRE_STA;
-		wfx_tx_unlock(wvif->wdev);
 
 		/* Upload keys */
 		wfx_upload_keys(wvif);
@@ -535,18 +527,10 @@ static void wfx_do_join(struct wfx_vif *wvif)
 		 * receives at least one
 		 */
 		wvif->disable_beacon_filter = true;
+		wfx_update_filtering(wvif);
 	}
-	wfx_update_filtering(wvif);
-
-	mutex_unlock(&wvif->wdev->conf_mutex);
-}
-
-static void wfx_unjoin_work(struct work_struct *work)
-{
-	struct wfx_vif *wvif = container_of(work, struct wfx_vif, unjoin_work);
-
-	wfx_do_unjoin(wvif);
 	wfx_tx_unlock(wvif->wdev);
+	mutex_unlock(&wvif->wdev->conf_mutex);
 }
 
 int wfx_sta_add(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
@@ -672,7 +656,6 @@ static void wfx_join_finalize(struct wfx_vif *wvif,
 		hif_dual_cts_protection(wvif, false);
 
 	wfx_cqm_bssloss_sm(wvif, 0, 0, 0);
-	cancel_work_sync(&wvif->unjoin_work);
 
 	wvif->bss_params.beacon_lost_count = 20;
 	wvif->bss_params.aid = info->aid;
@@ -754,10 +737,7 @@ void wfx_bss_info_changed(struct ieee80211_hw *hw,
 
 	if (changed & BSS_CHANGED_ASSOC && !info->assoc &&
 	    (wvif->state == WFX_STATE_STA || wvif->state == WFX_STATE_IBSS)) {
-		/* Shedule unjoin work */
-		wfx_tx_lock(wdev);
-		if (!schedule_work(&wvif->unjoin_work))
-			wfx_tx_unlock(wdev);
+		wfx_do_unjoin(wvif);
 	} else {
 		if (changed & BSS_CHANGED_BEACON_INT) {
 			if (info->ibss_joined)
@@ -999,7 +979,6 @@ int wfx_add_interface(struct ieee80211_hw *hw, struct ieee80211_vif *vif)
 	complete(&wvif->set_pm_mode_complete);
 	INIT_WORK(&wvif->update_filtering_work, wfx_update_filtering_work);
 	INIT_WORK(&wvif->bss_params_work, wfx_bss_params_work);
-	INIT_WORK(&wvif->unjoin_work, wfx_unjoin_work);
 	INIT_WORK(&wvif->tx_policy_upload_work, wfx_tx_policy_upload_work);
 
 	mutex_init(&wvif->scan_lock);
@@ -1039,9 +1018,7 @@ void wfx_remove_interface(struct ieee80211_hw *hw,
 	case WFX_STATE_PRE_STA:
 	case WFX_STATE_STA:
 	case WFX_STATE_IBSS:
-		wfx_tx_lock_flush(wdev);
-		if (!schedule_work(&wvif->unjoin_work))
-			wfx_tx_unlock(wdev);
+		wfx_do_unjoin(wvif);
 		break;
 	case WFX_STATE_AP:
 		/* reset.link_id = 0; */
@@ -1057,7 +1034,6 @@ void wfx_remove_interface(struct ieee80211_hw *hw,
 	hif_set_macaddr(wvif, NULL);
 
 	wfx_cqm_bssloss_sm(wvif, 0, 0, 0);
-	cancel_work_sync(&wvif->unjoin_work);
 	wfx_free_event_queue(wvif);
 
 	wdev->vif[wvif->id] = NULL;

commit b4d74f7ad1cdfb0099a4c844d3692ccd94b144aa
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Fri Apr 10 15:32:22 2020 +0200

    staging: wfx: reduce hold duration of cfg80211_bss
    
    Pointer to cfg80211_bss is held during all duration of wfx_do_join. But,
    it is not necessary, We can release it far earlier.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200410133239.438347-3-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index 380e5319472a..c65d464a7a9b 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -509,6 +509,7 @@ static void wfx_do_join(struct wfx_vif *wvif)
 		hif_set_block_ack_policy(wvif, 0xFF, 0xFF);
 
 	wfx_set_mfp(wvif, bss);
+	cfg80211_put_bss(wvif->wdev->hw->wiphy, bss);
 
 	ret = hif_join(wvif, conf, wvif->channel, ssid, ssidlen);
 	if (ret) {
@@ -538,8 +539,6 @@ static void wfx_do_join(struct wfx_vif *wvif)
 	wfx_update_filtering(wvif);
 
 	mutex_unlock(&wvif->wdev->conf_mutex);
-	if (bss)
-		cfg80211_put_bss(wvif->wdev->hw->wiphy, bss);
 }
 
 static void wfx_unjoin_work(struct work_struct *work)

commit 0f66c31eb6c457a8013c7093fd3204e7d8808115
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Fri Apr 10 15:32:21 2020 +0200

    staging: wfx: fix race between configure_filter and remove_interface
    
    wfx_remove_interface() and wfx_configure_filter() can be run
    concurrently. Therefore, this patch protect access to the list of
    interfaces from wfx_configure_filter().
    
    Notice that wfx_configure_filter() now lock "conf_lock" and "scan_lock".
    Beside that, wfx_hw_scan_work() also access to the same locks. So we
    have to lock them in same order to avoid any deadlock.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200410133239.438347-2-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index 4d5dbfc24f52..380e5319472a 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -242,6 +242,7 @@ void wfx_configure_filter(struct ieee80211_hw *hw,
 
 	*total_flags &= FIF_OTHER_BSS | FIF_FCSFAIL | FIF_PROBE_REQ;
 
+	mutex_lock(&wdev->conf_mutex);
 	while ((wvif = wvif_iterate(wdev, wvif)) != NULL) {
 		mutex_lock(&wvif->scan_lock);
 		wvif->filter_bssid = (*total_flags &
@@ -251,6 +252,7 @@ void wfx_configure_filter(struct ieee80211_hw *hw,
 		wfx_update_filtering(wvif);
 		mutex_unlock(&wvif->scan_lock);
 	}
+	mutex_unlock(&wdev->conf_mutex);
 }
 
 static int wfx_update_pm(struct wfx_vif *wvif)

commit 9a46a0a93b7b885888c59c98ea0d6d3ff5a8081e
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Mon Apr 6 13:17:55 2020 +0200

    staging: wfx: make hif_ie_table_entry const
    
    In wfx_update_filtering(), filter_ies is never modified. So, make it
    constant.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200406111756.154086-11-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index c250b117a138..4d5dbfc24f52 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -148,7 +148,7 @@ void wfx_update_filtering(struct wfx_vif *wvif)
 	int bf_enable;
 	int bf_count;
 	int n_filter_ies;
-	struct hif_ie_table_entry filter_ies[] = {
+	const struct hif_ie_table_entry filter_ies[] = {
 		{
 			.ie_id        = WLAN_EID_VENDOR_SPECIFIC,
 			.has_changed  = 1,

commit 9671f1338b67c93183a6051789acadd10c5942bb
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Mon Apr 6 13:17:53 2020 +0200

    staging: wfx: place hif_tx_mib functions into a .c file
    
    Until now, all functions from hif_tx_mib.h are declared "static inline".
    However, they are not time critical. So, it does not make so much sense.
    
    We prefer to place them in a .c file as for other hif functions.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200406111756.154086-9-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index 64cf58122661..c250b117a138 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -5,6 +5,7 @@
  * Copyright (c) 2017-2019, Silicon Laboratories, Inc.
  * Copyright (c) 2010, ST-Ericsson
  */
+#include <linux/etherdevice.h>
 #include <net/mac80211.h>
 
 #include "sta.h"

commit d7dcf8a54ea51463ece2c7c5893d7941a53edae0
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Mon Apr 6 13:17:47 2020 +0200

    staging: wfx: relocate LINK_ID_NO_ASSOC and MAX_STA_IN_AP_MODE to hif API
    
    The definitions LINK_ID_NO_ASSOC and MAX_STA_IN_AP_MODE are imposed by
    the hardware. Therefore, they should be located in the hardware
    interface API.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200406111756.154086-3-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index 2e8d3f571c3e..64cf58122661 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -563,7 +563,7 @@ int wfx_sta_add(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 	sta_priv->link_id = ffz(wvif->link_id_map);
 	wvif->link_id_map |= BIT(sta_priv->link_id);
 	WARN_ON(!sta_priv->link_id);
-	WARN_ON(sta_priv->link_id >= WFX_MAX_STA_IN_AP_MODE);
+	WARN_ON(sta_priv->link_id >= HIF_LINK_ID_MAX);
 	hif_map_link(wvif, sta->addr, 0, sta_priv->link_id);
 
 	return 0;

commit 4fb6036a1b743ad551c867e6847d2f09512467bb
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Wed Apr 1 13:04:04 2020 +0200

    staging: wfx: fix case where AP stop with CAB traffic pending
    
    When driver has Content After DTIM Beacon (CAB) in queue, it wait for an
    indication from the firmware. However, when we stop to send beacons,
    this indication may never happen.
    
    Solve this issue by simply simulate this indication. Firmware will send
    data that probably nobody will heard.
    
    Reviewed-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200401110405.80282-32-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index b1ee02d2f515..2e8d3f571c3e 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -686,6 +686,19 @@ static void wfx_join_finalize(struct wfx_vif *wvif,
 	}
 }
 
+void wfx_enable_beacon(struct wfx_vif *wvif, bool enable)
+{
+	// Driver has Content After DTIM Beacon in queue. Driver is waiting for
+	// a signal from the firmware. Since we are going to stop to send
+	// beacons, this signal will never happens. See also
+	// wfx_suspend_resume_mc()
+	if (!enable && wfx_tx_queues_has_cab(wvif)) {
+		wvif->after_dtim_tx_allowed = true;
+		wfx_bh_request_tx(wvif->wdev);
+	}
+	hif_beacon_transmit(wvif, enable);
+}
+
 void wfx_bss_info_changed(struct ieee80211_hw *hw,
 			     struct ieee80211_vif *vif,
 			     struct ieee80211_bss_conf *info,
@@ -724,7 +737,7 @@ void wfx_bss_info_changed(struct ieee80211_hw *hw,
 
 	if (changed & BSS_CHANGED_BEACON_ENABLED &&
 	    wvif->state != WFX_STATE_IBSS)
-		hif_beacon_transmit(wvif, info->enable_beacon);
+		wfx_enable_beacon(wvif, info->enable_beacon);
 
 	if (changed & BSS_CHANGED_BEACON_INFO)
 		hif_set_beacon_wakeup_period(wvif, info->dtim_period,

commit 4c6b3837c6dc0d9e5f9ec910da2e36349beea733
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Wed Apr 1 13:04:01 2020 +0200

    staging: wfx: repair wfx_flush()
    
    Until now, wfx_flush() flushed queue for while device instead of only
    the queue of the intended vif. It sometime failed with a timeout, but
    this error was not reported.
    
    Moreover, if the device was frozen, wfx_flush didn't do anything and it
    results a potential warning (and maybe a resource leak) when the frozen
    device was unregistered.
    
    We can also notice that wfx_tx_queues_wait_empty_vif() did only exist to
    work around the broken feature of wfx_flush().
    
    This patch repair wfx_flush() and therefore drop
    wfx_tx_queues_wait_empty_vif().
    
    Reviewed-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200401110405.80282-29-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index 340e09bb639d..b1ee02d2f515 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -318,29 +318,6 @@ int wfx_set_rts_threshold(struct ieee80211_hw *hw, u32 value)
 	return 0;
 }
 
-static int __wfx_flush(struct wfx_dev *wdev, bool drop)
-{
-	for (;;) {
-		if (drop)
-			wfx_tx_queues_clear(wdev);
-		if (wait_event_timeout(wdev->tx_dequeue,
-				       wfx_tx_queues_empty(wdev),
-				       2 * HZ) <= 0)
-			return -ETIMEDOUT;
-		wfx_tx_flush(wdev);
-		if (wfx_tx_queues_empty(wdev))
-			return 0;
-		dev_warn(wdev->dev, "frames queued while flushing tx queues");
-	}
-}
-
-void wfx_flush(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
-		  u32 queues, bool drop)
-{
-	// FIXME: only flush requested vif and queues
-	__wfx_flush(hw->priv, drop);
-}
-
 /* WSM callbacks */
 
 static void wfx_event_report_rssi(struct wfx_vif *wvif, u8 raw_rcpi_rssi)
@@ -843,10 +820,8 @@ static int wfx_update_tim(struct wfx_vif *wvif)
 
 	skb = ieee80211_beacon_get_tim(wvif->wdev->hw, wvif->vif,
 				       &tim_offset, &tim_length);
-	if (!skb) {
-		__wfx_flush(wvif->wdev, true);
+	if (!skb)
 		return -ENOENT;
-	}
 	tim_ptr = skb->data + tim_offset;
 
 	if (tim_offset && tim_length >= 6) {
@@ -1062,8 +1037,6 @@ void wfx_remove_interface(struct ieee80211_hw *hw,
 	}
 
 	wvif->state = WFX_STATE_PASSIVE;
-	wfx_tx_queues_wait_empty_vif(wvif);
-	wfx_tx_unlock(wdev);
 
 	/* FIXME: In add to reset MAC address, try to reset interface */
 	hif_set_macaddr(wvif, NULL);
@@ -1097,10 +1070,5 @@ void wfx_stop(struct ieee80211_hw *hw)
 {
 	struct wfx_dev *wdev = hw->priv;
 
-	wfx_tx_lock_flush(wdev);
-	mutex_lock(&wdev->conf_mutex);
-	wfx_tx_queues_clear(wdev);
-	mutex_unlock(&wdev->conf_mutex);
-	wfx_tx_unlock(wdev);
-	WARN(atomic_read(&wdev->tx_lock), "tx_lock is locked");
+	wfx_tx_queues_check_empty(wdev);
 }

commit d32cedbec0a64e24548986a0159ab86cfe6a4097
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Wed Apr 1 13:03:57 2020 +0200

    staging: wfx: drop struct wfx_queue_stats
    
    There is no reason to keep the intermediate struct wfx_queue_stats.
    Relocate its members to struct wfx_dev.
    
    Reviewed-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200401110405.80282-25-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index 15f00ea84068..340e09bb639d 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -323,7 +323,7 @@ static int __wfx_flush(struct wfx_dev *wdev, bool drop)
 	for (;;) {
 		if (drop)
 			wfx_tx_queues_clear(wdev);
-		if (wait_event_timeout(wdev->tx_queue_stats.wait_link_id_empty,
+		if (wait_event_timeout(wdev->tx_dequeue,
 				       wfx_tx_queues_empty(wdev),
 				       2 * HZ) <= 0)
 			return -ETIMEDOUT;

commit 41c5dfcdbc75e7ee75ec376e93742882ac92afca
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Wed Apr 1 13:03:56 2020 +0200

    staging: wfx: drop now useless field edca_params
    
    Since we do not rely in QoS parameters to choose which frame to send, it
    is no more necessary to keep a copy of EDCA parameters.
    
    Reviewed-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200401110405.80282-24-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index e1d7a0670c9d..15f00ea84068 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -298,7 +298,6 @@ int wfx_conf_tx(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 
 	mutex_lock(&wdev->conf_mutex);
 	assign_bit(queue, &wvif->uapsd_mask, params->uapsd);
-	memcpy(&wvif->edca_params[queue], params, sizeof(*params));
 	hif_set_edca_queue_params(wvif, queue, params);
 	if (wvif->vif->type == NL80211_IFTYPE_STATION &&
 	    old_uapsd != wvif->uapsd_mask) {

commit b6ef154973384439c663f8c5fde0eafa51e54309
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Wed Apr 1 13:03:53 2020 +0200

    staging: wfx: replace wfx_tx_queues_get_after_dtim() by wfx_tx_queues_has_cab()
    
    It is not necessary to return a skb. Just getting the information if
    there is traffic to be sent after DTIM is sufficient.
    
    In add, the acronym "cab" (Content After (DTIM) Beacon) is used in
    mac80211 to designate this kind of traffic.
    
    So, make wfx_tx_queues_get_after_dtim() return a boolean and rename
    accordingly.
    
    Reviewed-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200401110405.80282-21-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index 5c5b52dc7bdd..e1d7a0670c9d 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -857,7 +857,7 @@ static int wfx_update_tim(struct wfx_vif *wvif)
 		tim_ptr[2] = 0;
 
 		/* Set/reset aid0 bit */
-		if (wfx_tx_queues_get_after_dtim(wvif))
+		if (wfx_tx_queues_has_cab(wvif))
 			tim_ptr[4] |= 1;
 		else
 			tim_ptr[4] &= ~1;
@@ -888,7 +888,7 @@ int wfx_set_tim(struct ieee80211_hw *hw, struct ieee80211_sta *sta, bool set)
 
 void wfx_suspend_resume_mc(struct wfx_vif *wvif, enum sta_notify_cmd notify_cmd)
 {
-	WARN(!wfx_tx_queues_get_after_dtim(wvif), "incorrect sequence");
+	WARN(!wfx_tx_queues_has_cab(wvif), "incorrect sequence");
 	WARN(wvif->after_dtim_tx_allowed, "incorrect sequence");
 	wvif->after_dtim_tx_allowed = true;
 	wfx_bh_request_tx(wvif->wdev);

commit 062a6c410258ca2e66f377e54ee229c937504e22
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Wed Apr 1 13:03:45 2020 +0200

    staging: wfx: drop useless sta_asleep_mask
    
    Currently, the driver tracks power save state of the stations with the
    variable sta_asleep_mask. Then, it takes care to not sent data to asleep
    stations.
    
    However, this work is already done by mac80211. Normally, there are no
    frames for asleep stations in our queues. So, driver do not have to
    filter frames in its queues (apart the frames marked "AFTER_DTIM").
    
    Notice that there is a risk of race between state of the station and
    data send to the firmware. However, this risk is limited since the
    number of frame in queues are small. In add, this race also exists with
    the current code. Anyway, the firmware is able to detect the problem and
    driver will receive a 'REQUEUE' status (translated in
    TX_STAT_TX_FILTERED for mac80211).
    
    Reviewed-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200401110405.80282-13-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index be493b5f2b5d..5c5b52dc7bdd 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -590,11 +590,6 @@ int wfx_sta_add(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 	WARN_ON(sta_priv->link_id >= WFX_MAX_STA_IN_AP_MODE);
 	hif_map_link(wvif, sta->addr, 0, sta_priv->link_id);
 
-	spin_lock_bh(&wvif->ps_state_lock);
-	if ((sta->uapsd_queues & IEEE80211_WMM_IE_STA_QOSINFO_AC_MASK) ==
-					IEEE80211_WMM_IE_STA_QOSINFO_AC_MASK)
-		wvif->sta_asleep_mask |= BIT(sta_priv->link_id);
-	spin_unlock_bh(&wvif->ps_state_lock);
 	return 0;
 }
 
@@ -841,28 +836,6 @@ void wfx_bss_info_changed(struct ieee80211_hw *hw,
 		wfx_do_join(wvif);
 }
 
-static void wfx_ps_notify_sta(struct wfx_vif *wvif,
-			      enum sta_notify_cmd notify_cmd, int link_id)
-{
-	spin_lock_bh(&wvif->ps_state_lock);
-	if (notify_cmd == STA_NOTIFY_SLEEP)
-		wvif->sta_asleep_mask |= BIT(link_id);
-	else // notify_cmd == STA_NOTIFY_AWAKE
-		wvif->sta_asleep_mask &= ~BIT(link_id);
-	spin_unlock_bh(&wvif->ps_state_lock);
-	if (notify_cmd == STA_NOTIFY_AWAKE)
-		wfx_bh_request_tx(wvif->wdev);
-}
-
-void wfx_sta_notify(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
-		    enum sta_notify_cmd notify_cmd, struct ieee80211_sta *sta)
-{
-	struct wfx_vif *wvif = (struct wfx_vif *) vif->drv_priv;
-	struct wfx_sta_priv *sta_priv = (struct wfx_sta_priv *) &sta->drv_priv;
-
-	wfx_ps_notify_sta(wvif, notify_cmd, sta_priv->link_id);
-}
-
 static int wfx_update_tim(struct wfx_vif *wvif)
 {
 	struct sk_buff *skb;
@@ -1019,7 +992,6 @@ int wfx_add_interface(struct ieee80211_hw *hw, struct ieee80211_vif *vif)
 	wvif->wdev = wdev;
 
 	wvif->link_id_map = 1; // link-id 0 is reserved for multicast
-	spin_lock_init(&wvif->ps_state_lock);
 	INIT_WORK(&wvif->update_tim_work, wfx_update_tim_work);
 
 	memset(&wvif->bss_params, 0, sizeof(wvif->bss_params));
@@ -1083,7 +1055,6 @@ void wfx_remove_interface(struct ieee80211_hw *hw,
 			wfx_tx_unlock(wdev);
 		break;
 	case WFX_STATE_AP:
-		wvif->sta_asleep_mask = 0;
 		/* reset.link_id = 0; */
 		hif_reset(wvif, false);
 		break;

commit f42483f9efefd9ea0ea4eb054cd1e1923626e414
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Wed Apr 1 13:03:42 2020 +0200

    staging: wfx: simplify wfx_tx_queues_empty()
    
    Thanks to skb_queue_empty_lockless(), it is not necessary to acquire the
    spin_lock before to check if the queue is empty.
    
    Reviewed-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200401110405.80282-10-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index a275330f5518..be493b5f2b5d 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -325,11 +325,11 @@ static int __wfx_flush(struct wfx_dev *wdev, bool drop)
 		if (drop)
 			wfx_tx_queues_clear(wdev);
 		if (wait_event_timeout(wdev->tx_queue_stats.wait_link_id_empty,
-				       wfx_tx_queues_is_empty(wdev),
+				       wfx_tx_queues_empty(wdev),
 				       2 * HZ) <= 0)
 			return -ETIMEDOUT;
 		wfx_tx_flush(wdev);
-		if (wfx_tx_queues_is_empty(wdev))
+		if (wfx_tx_queues_empty(wdev))
 			return 0;
 		dev_warn(wdev->dev, "frames queued while flushing tx queues");
 	}

commit 57c5222004d39e8d914d7b6190593f31e3554892
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Wed Apr 1 13:03:37 2020 +0200

    staging: wfx: remove "burst" mechanism
    
    In the old days, the driver tried to reorder frames in order to send
    frames from the same queue grouped to the firmware. However, the
    firmware is able to do the job internally for a long time. There is no
    reasons to keep this mechanism.
    
    Reviewed-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200401110405.80282-5-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index 9d430346a58b..a275330f5518 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -531,7 +531,6 @@ static void wfx_do_join(struct wfx_vif *wvif)
 
 	wfx_set_mfp(wvif, bss);
 
-	wvif->wdev->tx_burst_idx = -1;
 	ret = hif_join(wvif, conf, wvif->channel, ssid, ssidlen);
 	if (ret) {
 		ieee80211_connection_loss(wvif->vif);
@@ -624,7 +623,6 @@ static int wfx_start_ap(struct wfx_vif *wvif)
 	int ret;
 
 	wvif->beacon_int = wvif->vif->bss_conf.beacon_int;
-	wvif->wdev->tx_burst_idx = -1;
 	ret = hif_start(wvif, &wvif->vif->bss_conf, wvif->channel);
 	if (ret)
 		return ret;

commit 6203da9803017701da5782998157d9826215059d
Merge: 3017e587e368 16fbf79b0f83
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon Mar 23 08:01:20 2020 +0100

    Merge 5.6-rc7 into staging-next
    
    We need the staging/iio fixes in here as well
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 76498b49f5bedbd5d184cceec05dde72749f9915
Author: Lourdes Pedrajas <lu@pplo.net>
Date:   Sun Mar 15 05:49:22 2020 +0100

    staging: wfx: remove unneeded spaces
    
    Remove spaces after type casting operators in order to comply codding
    standards.
    Issue found with checkpatch.
    
    Signed-off-by: Lourdes Pedrajas <lu@pplo.net>
    Link: https://lore.kernel.org/r/20200315044922.14249-1-lu@pplo.net
    Reviewed-by: Stefano Brivio <sbrivio@redhat.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index a60ac03fa73d..07a9991929fd 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -903,7 +903,7 @@ static void wfx_update_tim_work(struct work_struct *work)
 int wfx_set_tim(struct ieee80211_hw *hw, struct ieee80211_sta *sta, bool set)
 {
 	struct wfx_dev *wdev = hw->priv;
-	struct wfx_sta_priv *sta_dev = (struct wfx_sta_priv *) &sta->drv_priv;
+	struct wfx_sta_priv *sta_dev = (struct wfx_sta_priv *)&sta->drv_priv;
 	struct wfx_vif *wvif = wdev_to_wvif(wdev, sta_dev->vif_id);
 
 	schedule_work(&wvif->update_tim_work);

commit ac42c12dd752d315a7027dcb50421dbbd1af53bd
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Tue Mar 10 11:13:56 2020 +0100

    staging: wfx: fix RCU usage between hif_join() and ieee80211_bss_get_ie()
    
    Access to result of ieee80211_bss_get_ie() is protected by RCU. In other
    hand, function hif_join() can sleep and cannot be called with RCU
    locked.
    
    Provide a copy of "ssidie" to hif_join() to solve this behavior.
    
    Fixes: 9ced9b593741 ("staging: wfx: simplify hif_join()")
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200310101356.182818-6-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index ed16475c207c..af4f4bbd0572 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -491,9 +491,11 @@ static void wfx_set_mfp(struct wfx_vif *wvif,
 static void wfx_do_join(struct wfx_vif *wvif)
 {
 	int ret;
-	const u8 *ssidie;
 	struct ieee80211_bss_conf *conf = &wvif->vif->bss_conf;
 	struct cfg80211_bss *bss = NULL;
+	u8 ssid[IEEE80211_MAX_SSID_LEN];
+	const u8 *ssidie = NULL;
+	int ssidlen = 0;
 
 	wfx_tx_lock_flush(wvif->wdev);
 
@@ -514,11 +516,14 @@ static void wfx_do_join(struct wfx_vif *wvif)
 	if (!wvif->beacon_int)
 		wvif->beacon_int = 1;
 
-	rcu_read_lock();
+	rcu_read_lock(); // protect ssidie
 	if (!conf->ibss_joined)
 		ssidie = ieee80211_bss_get_ie(bss, WLAN_EID_SSID);
-	else
-		ssidie = NULL;
+	if (ssidie) {
+		ssidlen = ssidie[1];
+		memcpy(ssid, &ssidie[2], ssidie[1]);
+	}
+	rcu_read_unlock();
 
 	wfx_tx_flush(wvif->wdev);
 
@@ -527,10 +532,8 @@ static void wfx_do_join(struct wfx_vif *wvif)
 
 	wfx_set_mfp(wvif, bss);
 
-	/* Perform actual join */
 	wvif->wdev->tx_burst_idx = -1;
-	ret = hif_join(wvif, conf, wvif->channel, ssidie);
-	rcu_read_unlock();
+	ret = hif_join(wvif, conf, wvif->channel, ssid, ssidlen);
 	if (ret) {
 		ieee80211_connection_loss(wvif->vif);
 		wvif->join_complete_status = -1;

commit 046cc2effd1312a23b9e3d8363be7c68f6e91f3c
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Tue Mar 10 11:13:55 2020 +0100

    staging: wfx: fix RCU usage in wfx_join_finalize()
    
    Access to sta->ht_cap is protected by RCU. However,
    hif_set_association_mode() may sleep, so it can't be called in RCU.
    
    This patch fix this behavior by handling sta and its RCU directly from
    function hif_set_association_mode().
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Fixes: d00149011066 ("staging: wfx: fix RCU usage")
    Link: https://lore.kernel.org/r/20200310101356.182818-5-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index 010e13bcd33e..ed16475c207c 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -691,6 +691,7 @@ static void wfx_join_finalize(struct wfx_vif *wvif,
 			wfx_rate_mask_to_hw(wvif->wdev, sta->supp_rates[wvif->channel->band]);
 	else
 		wvif->bss_params.operational_rate_set = -1;
+	rcu_read_unlock();
 	if (sta &&
 	    info->ht_operation_mode & IEEE80211_HT_OP_MODE_NON_GF_STA_PRSNT)
 		hif_dual_cts_protection(wvif, true);
@@ -703,8 +704,7 @@ static void wfx_join_finalize(struct wfx_vif *wvif,
 	wvif->bss_params.beacon_lost_count = 20;
 	wvif->bss_params.aid = info->aid;
 
-	hif_set_association_mode(wvif, info, sta ? &sta->ht_cap : NULL);
-	rcu_read_unlock();
+	hif_set_association_mode(wvif, info);
 
 	if (!info->ibss_joined) {
 		hif_keep_alive_period(wvif, 30 /* sec */);

commit 4bbc6a3e7ad0d0f31ae3ba9858dbca45eb7a848e
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Tue Mar 10 11:13:54 2020 +0100

    staging: wfx: make warning about pending frame less scary
    
    Removing station while some traffic is in progress may happen.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200310101356.182818-4-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index 03d0f224ffdb..010e13bcd33e 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -605,7 +605,9 @@ int wfx_sta_remove(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 	int i;
 
 	for (i = 0; i < ARRAY_SIZE(sta_priv->buffered); i++)
-		WARN(sta_priv->buffered[i], "release station while Tx is in progress");
+		if (sta_priv->buffered[i])
+			dev_warn(wvif->wdev->dev, "release station while %d pending frame on queue %d",
+				 sta_priv->buffered[i], i);
 	// FIXME: see note in wfx_sta_add()
 	if (vif->type == NL80211_IFTYPE_STATION)
 		return 0;

commit 02a33f8e06f3be399aa547653715bf0e02b59e82
Author: Kaaira Gupta <kgupta@es.iitr.ac.in>
Date:   Tue Mar 10 19:55:08 2020 +0530

    staging: wfx: remove variable declaration
    
    int ret is uneccessarily declared and 0 assigned to it. Return o
    directly instead.
    
    Signed-off-by: Kaaira Gupta <kgupta@es.iitr.ac.in>
    Link: https://lore.kernel.org/r/20200310142509.25632-6-kgupta@es.iitr.ac.in
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index 03d0f224ffdb..a60ac03fa73d 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -293,7 +293,6 @@ int wfx_conf_tx(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 	struct wfx_dev *wdev = hw->priv;
 	struct wfx_vif *wvif = (struct wfx_vif *) vif->drv_priv;
 	int old_uapsd = wvif->uapsd_mask;
-	int ret = 0;
 
 	WARN_ON(queue >= hw->queues);
 
@@ -307,7 +306,7 @@ int wfx_conf_tx(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 		wfx_update_pm(wvif);
 	}
 	mutex_unlock(&wdev->conf_mutex);
-	return ret;
+	return 0;
 }
 
 int wfx_set_rts_threshold(struct ieee80211_hw *hw, u32 value)

commit ded6ca11af6bb0394a3c684b4c2e39c928ca4738
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Wed Jan 15 13:55:27 2020 +0000

    staging: wfx: simplify wfx_ps_notify_sta()
    
    wfx_ps_notify_sta() is too complex compared to the task it do.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200115135338.14374-59-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index a9b58e4a9fa3..03d0f224ffdb 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -842,26 +842,14 @@ void wfx_bss_info_changed(struct ieee80211_hw *hw,
 static void wfx_ps_notify_sta(struct wfx_vif *wvif,
 			      enum sta_notify_cmd notify_cmd, int link_id)
 {
-	u32 bit, prev;
-
 	spin_lock_bh(&wvif->ps_state_lock);
-	bit = BIT(link_id);
-	prev = wvif->sta_asleep_mask & bit;
-
-	switch (notify_cmd) {
-	case STA_NOTIFY_SLEEP:
-		if (!prev) {
-			wvif->sta_asleep_mask |= bit;
-		}
-		break;
-	case STA_NOTIFY_AWAKE:
-		if (prev) {
-			wvif->sta_asleep_mask &= ~bit;
-			wfx_bh_request_tx(wvif->wdev);
-		}
-		break;
-	}
+	if (notify_cmd == STA_NOTIFY_SLEEP)
+		wvif->sta_asleep_mask |= BIT(link_id);
+	else // notify_cmd == STA_NOTIFY_AWAKE
+		wvif->sta_asleep_mask &= ~BIT(link_id);
 	spin_unlock_bh(&wvif->ps_state_lock);
+	if (notify_cmd == STA_NOTIFY_AWAKE)
+		wfx_bh_request_tx(wvif->wdev);
 }
 
 void wfx_sta_notify(struct ieee80211_hw *hw, struct ieee80211_vif *vif,

commit a3c529a835890b0eecd324d9f0c37c67345f84e2
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Wed Jan 15 13:55:25 2020 +0000

    staging: wfx: simplify handling of IEEE80211_TX_CTL_SEND_AFTER_DTIM
    
    When mac80211 ask for a frame to be sent after a DTIM, driver should:
      1. Update TIM with multicast bit set (using update_ie). This function
         can be called whenever.
      2. Keep buffered all frames marked "after dtim"
      3. When it receive a suspend_resume indication (see
         wfx_suspend_resume_mc()), send all the buffered frames. This
         indication is sent by the firmware 4ms before the dtim.
      4. If one of the frames returns status "REQUEUE", it means that the
         DTIM period was ended before to be able to send the frame.
      5. When all the buffered frames were sent or if DTIM period was ended,
         driver should update the TIM with multicast bit reset.
    
    All the mess with the asynchronous works can be dropped.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200115135338.14374-58-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index bdc15554958c..a9b58e4a9fa3 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -851,16 +851,12 @@ static void wfx_ps_notify_sta(struct wfx_vif *wvif,
 	switch (notify_cmd) {
 	case STA_NOTIFY_SLEEP:
 		if (!prev) {
-			if (wvif->mcast_buffered && !wvif->sta_asleep_mask)
-				schedule_work(&wvif->mcast_start_work);
 			wvif->sta_asleep_mask |= bit;
 		}
 		break;
 	case STA_NOTIFY_AWAKE:
 		if (prev) {
 			wvif->sta_asleep_mask &= ~bit;
-			if (!wvif->sta_asleep_mask)
-				schedule_work(&wvif->mcast_stop_work);
 			wfx_bh_request_tx(wvif->wdev);
 		}
 		break;
@@ -898,7 +894,7 @@ static int wfx_update_tim(struct wfx_vif *wvif)
 		tim_ptr[2] = 0;
 
 		/* Set/reset aid0 bit */
-		if (wvif->aid0_bit_set)
+		if (wfx_tx_queues_get_after_dtim(wvif))
 			tim_ptr[4] |= 1;
 		else
 			tim_ptr[4] &= ~1;
@@ -927,47 +923,12 @@ int wfx_set_tim(struct ieee80211_hw *hw, struct ieee80211_sta *sta, bool set)
 	return 0;
 }
 
-static void wfx_mcast_start_work(struct work_struct *work)
-{
-	struct wfx_vif *wvif =
-		container_of(work, struct wfx_vif, mcast_start_work);
-	struct ieee80211_bss_conf *conf = &wvif->vif->bss_conf;
-	long tmo = conf->dtim_period * TU_TO_JIFFIES(wvif->beacon_int + 20);
-
-	cancel_work_sync(&wvif->mcast_stop_work);
-	if (!wvif->aid0_bit_set) {
-		wfx_tx_lock_flush(wvif->wdev);
-		wvif->aid0_bit_set = true;
-		wfx_update_tim(wvif);
-		mod_timer(&wvif->mcast_timeout, jiffies + tmo);
-		wfx_tx_unlock(wvif->wdev);
-	}
-}
-
-static void wfx_mcast_stop_work(struct work_struct *work)
-{
-	struct wfx_vif *wvif = container_of(work, struct wfx_vif,
-					    mcast_stop_work);
-
-	if (wvif->aid0_bit_set) {
-		del_timer_sync(&wvif->mcast_timeout);
-		wfx_tx_lock_flush(wvif->wdev);
-		wvif->aid0_bit_set = false;
-		wfx_update_tim(wvif);
-		wfx_tx_unlock(wvif->wdev);
-	}
-}
-
-static void wfx_mcast_timeout(struct timer_list *t)
+void wfx_suspend_resume_mc(struct wfx_vif *wvif, enum sta_notify_cmd notify_cmd)
 {
-	struct wfx_vif *wvif = from_timer(wvif, t, mcast_timeout);
-
-	dev_warn(wvif->wdev->dev, "multicast delivery timeout\n");
-	spin_lock_bh(&wvif->ps_state_lock);
-	wvif->mcast_tx = wvif->aid0_bit_set && wvif->mcast_buffered;
-	if (wvif->mcast_tx)
-		wfx_bh_request_tx(wvif->wdev);
-	spin_unlock_bh(&wvif->ps_state_lock);
+	WARN(!wfx_tx_queues_get_after_dtim(wvif), "incorrect sequence");
+	WARN(wvif->after_dtim_tx_allowed, "incorrect sequence");
+	wvif->after_dtim_tx_allowed = true;
+	wfx_bh_request_tx(wvif->wdev);
 }
 
 int wfx_ampdu_action(struct ieee80211_hw *hw,
@@ -985,25 +946,6 @@ int wfx_ampdu_action(struct ieee80211_hw *hw,
 	return -ENOTSUPP;
 }
 
-void wfx_suspend_resume_mc(struct wfx_vif *wvif, enum sta_notify_cmd notify_cmd)
-{
-	bool cancel_tmo = false;
-
-	spin_lock_bh(&wvif->ps_state_lock);
-	if (notify_cmd == STA_NOTIFY_SLEEP)
-		wvif->mcast_tx = false;
-	else
-		wvif->mcast_tx = wvif->aid0_bit_set &&
-				 wvif->mcast_buffered;
-	if (wvif->mcast_tx) {
-		cancel_tmo = true;
-		wfx_bh_request_tx(wvif->wdev);
-	}
-	spin_unlock_bh(&wvif->ps_state_lock);
-	if (cancel_tmo)
-		del_timer_sync(&wvif->mcast_timeout);
-}
-
 int wfx_add_chanctx(struct ieee80211_hw *hw,
 		    struct ieee80211_chanctx_conf *conf)
 {
@@ -1090,10 +1032,6 @@ int wfx_add_interface(struct ieee80211_hw *hw, struct ieee80211_vif *vif)
 	spin_lock_init(&wvif->ps_state_lock);
 	INIT_WORK(&wvif->update_tim_work, wfx_update_tim_work);
 
-	INIT_WORK(&wvif->mcast_start_work, wfx_mcast_start_work);
-	INIT_WORK(&wvif->mcast_stop_work, wfx_mcast_stop_work);
-	timer_setup(&wvif->mcast_timeout, wfx_mcast_timeout, 0);
-
 	memset(&wvif->bss_params, 0, sizeof(wvif->bss_params));
 
 	mutex_init(&wvif->bss_loss_lock);
@@ -1156,9 +1094,6 @@ void wfx_remove_interface(struct ieee80211_hw *hw,
 		break;
 	case WFX_STATE_AP:
 		wvif->sta_asleep_mask = 0;
-		wvif->mcast_tx = false;
-		wvif->aid0_bit_set = false;
-		wvif->mcast_buffered = false;
 		/* reset.link_id = 0; */
 		hif_reset(wvif, false);
 		break;
@@ -1175,7 +1110,6 @@ void wfx_remove_interface(struct ieee80211_hw *hw,
 
 	wfx_cqm_bssloss_sm(wvif, 0, 0, 0);
 	cancel_work_sync(&wvif->unjoin_work);
-	del_timer_sync(&wvif->mcast_timeout);
 	wfx_free_event_queue(wvif);
 
 	wdev->vif[wvif->id] = NULL;

commit 22c03264e5a914966c93baa367d63eb77f60ebaf
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Wed Jan 15 13:55:24 2020 +0000

    staging: wfx: simplify wfx_suspend_resume_mc()
    
    Indeed, it is not necessary to pass whole hif_ind_suspend_resume_tx to
    wfx_suspend_resume_mc().
    
    In add, the structure hif_ind_suspend_resume_tx come from hardware API.
    It is not intended to be manipulated in upper layers of the driver.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200115135338.14374-57-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index 7c9e93f52993..bdc15554958c 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -985,18 +985,12 @@ int wfx_ampdu_action(struct ieee80211_hw *hw,
 	return -ENOTSUPP;
 }
 
-void wfx_suspend_resume(struct wfx_vif *wvif,
-			const struct hif_ind_suspend_resume_tx *arg)
+void wfx_suspend_resume_mc(struct wfx_vif *wvif, enum sta_notify_cmd notify_cmd)
 {
 	bool cancel_tmo = false;
 
-	if (!arg->suspend_resume_flags.bc_mc_only) {
-		dev_warn(wvif->wdev->dev, "unsupported suspend/resume notification\n");
-		return;
-	}
-
 	spin_lock_bh(&wvif->ps_state_lock);
-	if (!arg->suspend_resume_flags.resume)
+	if (notify_cmd == STA_NOTIFY_SLEEP)
 		wvif->mcast_tx = false;
 	else
 		wvif->mcast_tx = wvif->aid0_bit_set &&

commit b5d4d98ec807a248e41ed7e8a3a649b8d88a745c
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Wed Jan 15 13:55:22 2020 +0000

    staging: wfx: firmware never return PS status for stations
    
    At the beginning, firmware could send suspend_resume indication to
    notify that a station wake up or sleep down. However, mac80211 already
    handles power save status of stations and this behavior has been removed
    from the firmware. So now, when suspend_resume indication is received,
    it is always to notify that a DTIM is about to be sent.
    
    So, it is possible to simply wfx_suspend_resume().
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200115135338.14374-56-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index 9f4c566517a1..7c9e93f52993 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -985,38 +985,29 @@ int wfx_ampdu_action(struct ieee80211_hw *hw,
 	return -ENOTSUPP;
 }
 
-static void wfx_dtim_notify(struct wfx_vif *wvif)
-{
-	spin_lock_bh(&wvif->ps_state_lock);
-	wvif->sta_asleep_mask = 0;
-	wfx_bh_request_tx(wvif->wdev);
-	spin_unlock_bh(&wvif->ps_state_lock);
-}
-
 void wfx_suspend_resume(struct wfx_vif *wvif,
 			const struct hif_ind_suspend_resume_tx *arg)
 {
-	if (arg->suspend_resume_flags.bc_mc_only) {
-		bool cancel_tmo = false;
+	bool cancel_tmo = false;
 
-		spin_lock_bh(&wvif->ps_state_lock);
-		if (!arg->suspend_resume_flags.resume)
-			wvif->mcast_tx = false;
-		else
-			wvif->mcast_tx = wvif->aid0_bit_set &&
-					 wvif->mcast_buffered;
-		if (wvif->mcast_tx) {
-			cancel_tmo = true;
-			wfx_bh_request_tx(wvif->wdev);
-		}
-		spin_unlock_bh(&wvif->ps_state_lock);
-		if (cancel_tmo)
-			del_timer_sync(&wvif->mcast_timeout);
-	} else if (arg->suspend_resume_flags.resume) {
-		wfx_dtim_notify(wvif);
-	} else {
+	if (!arg->suspend_resume_flags.bc_mc_only) {
 		dev_warn(wvif->wdev->dev, "unsupported suspend/resume notification\n");
+		return;
 	}
+
+	spin_lock_bh(&wvif->ps_state_lock);
+	if (!arg->suspend_resume_flags.resume)
+		wvif->mcast_tx = false;
+	else
+		wvif->mcast_tx = wvif->aid0_bit_set &&
+				 wvif->mcast_buffered;
+	if (wvif->mcast_tx) {
+		cancel_tmo = true;
+		wfx_bh_request_tx(wvif->wdev);
+	}
+	spin_unlock_bh(&wvif->ps_state_lock);
+	if (cancel_tmo)
+		del_timer_sync(&wvif->mcast_timeout);
 }
 
 int wfx_add_chanctx(struct ieee80211_hw *hw,

commit 6537adc3e3076e9dc522d827ec412812f633ec7e
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Wed Jan 15 13:55:21 2020 +0000

    staging: wfx: sta and dtim
    
    wfx_ps_notify() is called for any changes in the TIM. However,
    association ID 0 is a very special case that should be handled
    independently.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200115135338.14374-55-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index c249a2953bb0..9f4c566517a1 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -839,21 +839,13 @@ void wfx_bss_info_changed(struct ieee80211_hw *hw,
 		wfx_do_join(wvif);
 }
 
-static void wfx_ps_notify(struct wfx_vif *wvif, enum sta_notify_cmd notify_cmd,
-			  int link_id)
+static void wfx_ps_notify_sta(struct wfx_vif *wvif,
+			      enum sta_notify_cmd notify_cmd, int link_id)
 {
 	u32 bit, prev;
 
 	spin_lock_bh(&wvif->ps_state_lock);
-	/* Zero link id means "for all link IDs" */
-	if (link_id) {
-		bit = BIT(link_id);
-	} else if (notify_cmd != STA_NOTIFY_AWAKE) {
-		dev_warn(wvif->wdev->dev, "unsupported notify command\n");
-		bit = 0;
-	} else {
-		bit = wvif->link_id_map & ~1;
-	}
+	bit = BIT(link_id);
 	prev = wvif->sta_asleep_mask & bit;
 
 	switch (notify_cmd) {
@@ -867,7 +859,7 @@ static void wfx_ps_notify(struct wfx_vif *wvif, enum sta_notify_cmd notify_cmd,
 	case STA_NOTIFY_AWAKE:
 		if (prev) {
 			wvif->sta_asleep_mask &= ~bit;
-			if (link_id && !wvif->sta_asleep_mask)
+			if (!wvif->sta_asleep_mask)
 				schedule_work(&wvif->mcast_stop_work);
 			wfx_bh_request_tx(wvif->wdev);
 		}
@@ -882,7 +874,7 @@ void wfx_sta_notify(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 	struct wfx_vif *wvif = (struct wfx_vif *) vif->drv_priv;
 	struct wfx_sta_priv *sta_priv = (struct wfx_sta_priv *) &sta->drv_priv;
 
-	wfx_ps_notify(wvif, notify_cmd, sta_priv->link_id);
+	wfx_ps_notify_sta(wvif, notify_cmd, sta_priv->link_id);
 }
 
 static int wfx_update_tim(struct wfx_vif *wvif)
@@ -993,6 +985,14 @@ int wfx_ampdu_action(struct ieee80211_hw *hw,
 	return -ENOTSUPP;
 }
 
+static void wfx_dtim_notify(struct wfx_vif *wvif)
+{
+	spin_lock_bh(&wvif->ps_state_lock);
+	wvif->sta_asleep_mask = 0;
+	wfx_bh_request_tx(wvif->wdev);
+	spin_unlock_bh(&wvif->ps_state_lock);
+}
+
 void wfx_suspend_resume(struct wfx_vif *wvif,
 			const struct hif_ind_suspend_resume_tx *arg)
 {
@@ -1013,12 +1013,9 @@ void wfx_suspend_resume(struct wfx_vif *wvif,
 		if (cancel_tmo)
 			del_timer_sync(&wvif->mcast_timeout);
 	} else if (arg->suspend_resume_flags.resume) {
-		// FIXME: should change each station status independently
-		wfx_ps_notify(wvif, STA_NOTIFY_AWAKE, 0);
-		wfx_bh_request_tx(wvif->wdev);
+		wfx_dtim_notify(wvif);
 	} else {
-		// FIXME: should change each station status independently
-		wfx_ps_notify(wvif, STA_NOTIFY_SLEEP, 0);
+		dev_warn(wvif->wdev->dev, "unsupported suspend/resume notification\n");
 	}
 }
 

commit 2e57865e79cfe82afcefff553300bb0eea07c1c2
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Wed Jan 15 13:55:19 2020 +0000

    staging: wfx: pspoll_mask make no sense
    
    pspoll_mask is here to send data buffered in driver. But since station
    is marked buffered, TIM for this station is 1 and mac80211 will call
    sta_notify when a ps-poll is received. So pspoll_mask is useless and
    sta_alseep_mask is sufficient.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200115135338.14374-54-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index aa1a68b61ac5..c249a2953bb0 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -867,7 +867,6 @@ static void wfx_ps_notify(struct wfx_vif *wvif, enum sta_notify_cmd notify_cmd,
 	case STA_NOTIFY_AWAKE:
 		if (prev) {
 			wvif->sta_asleep_mask &= ~bit;
-			wvif->pspoll_mask &= ~bit;
 			if (link_id && !wvif->sta_asleep_mask)
 				schedule_work(&wvif->mcast_stop_work);
 			wfx_bh_request_tx(wvif->wdev);
@@ -1178,7 +1177,6 @@ void wfx_remove_interface(struct ieee80211_hw *hw,
 		wvif->mcast_tx = false;
 		wvif->aid0_bit_set = false;
 		wvif->mcast_buffered = false;
-		wvif->pspoll_mask = 0;
 		/* reset.link_id = 0; */
 		hif_reset(wvif, false);
 		break;

commit df3519a328aafbde521e6011ebb254853a98cfa5
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Wed Jan 15 13:55:18 2020 +0000

    staging: wfx: replace wfx_tx_get_tid() with ieee80211_get_tid()
    
    wfx_tx_get_tid() was used as a wrapper around ieee80211_get_tid(). It
    did sometime return WFX_MAX_TID to ask to upper layers to not include
    the frame in "buffered" counter. The objective of this behavior is not
    clear, but tests has shown that wfx_tx_get_tid() can be replaced by
    ieee80211_get_tid() without any regressions.
    
    BTW, it is not necessary to save the tid in tx_rpiv since it can be
    retrieved from the 802.11 header.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200115135338.14374-53-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index 33955278d9d3..aa1a68b61ac5 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -604,7 +604,7 @@ int wfx_sta_remove(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 	struct wfx_sta_priv *sta_priv = (struct wfx_sta_priv *) &sta->drv_priv;
 	int i;
 
-	for (i = 0; i < WFX_MAX_TID; i++)
+	for (i = 0; i < ARRAY_SIZE(sta_priv->buffered); i++)
 		WARN(sta_priv->buffered[i], "release station while Tx is in progress");
 	// FIXME: see note in wfx_sta_add()
 	if (vif->type == NL80211_IFTYPE_STATION)

commit 98511a91b126901e1392e1a6cf51ef94dc094f89
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Wed Jan 15 13:55:16 2020 +0000

    staging: wfx: check that no tx is pending before release sta
    
    Just for sanity.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200115135338.14374-52-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index 75c1e2aecc23..33955278d9d3 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -602,7 +602,10 @@ int wfx_sta_remove(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 {
 	struct wfx_vif *wvif = (struct wfx_vif *) vif->drv_priv;
 	struct wfx_sta_priv *sta_priv = (struct wfx_sta_priv *) &sta->drv_priv;
+	int i;
 
+	for (i = 0; i < WFX_MAX_TID; i++)
+		WARN(sta_priv->buffered[i], "release station while Tx is in progress");
 	// FIXME: see note in wfx_sta_add()
 	if (vif->type == NL80211_IFTYPE_STATION)
 		return 0;

commit d6aeba575f277104a95125584981d37c8f7cf762
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Wed Jan 15 13:55:15 2020 +0000

    staging: wfx: simplify the link-id allocation
    
    The "link-id" is a slot number provided to the chip. A link-id is
    allocated to every station associated with the chip (mainly when the
    chip is in AP mode). It is more or less the same thing than the
    association ID, but it is limited to 14 values.
    
    Firmware uses the link-id to track the power save status of the
    stations.
    
    The current code try to associate a link-id as soon as data are
    exchanged with station. It is far easier to rely on sta_add() and
    sta_remove().
    
    Until now the value WFX_LINK_ID_NO_ASSOC, was only used when no more
    link-id was available. Now, we also use this value for
    not-yet-associated stations (that was its primary behavior).
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200115135338.14374-51-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index b7d21540d9a2..75c1e2aecc23 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -573,28 +573,26 @@ static void wfx_unjoin_work(struct work_struct *work)
 int wfx_sta_add(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 		struct ieee80211_sta *sta)
 {
-	struct wfx_dev *wdev = hw->priv;
 	struct wfx_vif *wvif = (struct wfx_vif *) vif->drv_priv;
 	struct wfx_sta_priv *sta_priv = (struct wfx_sta_priv *) &sta->drv_priv;
-	struct wfx_link_entry *entry;
 
 	spin_lock_init(&sta_priv->lock);
-	if (wvif->vif->type != NL80211_IFTYPE_AP)
-		return 0;
-
 	sta_priv->vif_id = wvif->id;
-	sta_priv->link_id = wfx_find_link_id(wvif, sta->addr);
-	if (!sta_priv->link_id) {
-		dev_warn(wdev->dev, "mo more link-id available\n");
-		return -ENOENT;
-	}
 
-	entry = &wvif->link_id_db[sta_priv->link_id - 1];
+	// FIXME: in station mode, the current API interprets new link-id as a
+	// tdls peer.
+	if (vif->type == NL80211_IFTYPE_STATION)
+		return 0;
+	sta_priv->link_id = ffz(wvif->link_id_map);
+	wvif->link_id_map |= BIT(sta_priv->link_id);
+	WARN_ON(!sta_priv->link_id);
+	WARN_ON(sta_priv->link_id >= WFX_MAX_STA_IN_AP_MODE);
+	hif_map_link(wvif, sta->addr, 0, sta_priv->link_id);
+
 	spin_lock_bh(&wvif->ps_state_lock);
 	if ((sta->uapsd_queues & IEEE80211_WMM_IE_STA_QOSINFO_AC_MASK) ==
 					IEEE80211_WMM_IE_STA_QOSINFO_AC_MASK)
 		wvif->sta_asleep_mask |= BIT(sta_priv->link_id);
-	entry->status = WFX_LINK_HARD;
 	spin_unlock_bh(&wvif->ps_state_lock);
 	return 0;
 }
@@ -602,23 +600,15 @@ int wfx_sta_add(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 int wfx_sta_remove(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 		   struct ieee80211_sta *sta)
 {
-	struct wfx_dev *wdev = hw->priv;
 	struct wfx_vif *wvif = (struct wfx_vif *) vif->drv_priv;
 	struct wfx_sta_priv *sta_priv = (struct wfx_sta_priv *) &sta->drv_priv;
-	struct wfx_link_entry *entry;
 
-	if (wvif->vif->type != NL80211_IFTYPE_AP || !sta_priv->link_id)
+	// FIXME: see note in wfx_sta_add()
+	if (vif->type == NL80211_IFTYPE_STATION)
 		return 0;
-
-	entry = &wvif->link_id_db[sta_priv->link_id - 1];
-	spin_lock_bh(&wvif->ps_state_lock);
-	entry->status = WFX_LINK_RESERVE;
-	entry->timestamp = jiffies;
-	wfx_tx_lock(wdev);
-	if (!schedule_work(&wvif->link_id_work))
-		wfx_tx_unlock(wdev);
-	spin_unlock_bh(&wvif->ps_state_lock);
-	flush_work(&wvif->link_id_work);
+	// FIXME add a mutex?
+	hif_map_link(wvif, sta->addr, 1, sta_priv->link_id);
+	wvif->link_id_map &= ~BIT(sta_priv->link_id);
 	return 0;
 }
 
@@ -627,8 +617,6 @@ static int wfx_start_ap(struct wfx_vif *wvif)
 	int ret;
 
 	wvif->beacon_int = wvif->vif->bss_conf.beacon_int;
-	memset(&wvif->link_id_db, 0, sizeof(wvif->link_id_db));
-
 	wvif->wdev->tx_burst_idx = -1;
 	ret = hif_start(wvif, &wvif->vif->bss_conf, wvif->channel);
 	if (ret)
@@ -861,7 +849,7 @@ static void wfx_ps_notify(struct wfx_vif *wvif, enum sta_notify_cmd notify_cmd,
 		dev_warn(wvif->wdev->dev, "unsupported notify command\n");
 		bit = 0;
 	} else {
-		bit = wvif->link_id_map;
+		bit = wvif->link_id_map & ~1;
 	}
 	prev = wvif->sta_asleep_mask & bit;
 
@@ -1114,9 +1102,7 @@ int wfx_add_interface(struct ieee80211_hw *hw, struct ieee80211_vif *vif)
 	wvif->vif = vif;
 	wvif->wdev = wdev;
 
-	INIT_WORK(&wvif->link_id_work, wfx_link_id_work);
-	INIT_DELAYED_WORK(&wvif->link_id_gc_work, wfx_link_id_gc_work);
-
+	wvif->link_id_map = 1; // link-id 0 is reserved for multicast
 	spin_lock_init(&wvif->ps_state_lock);
 	INIT_WORK(&wvif->update_tim_work, wfx_update_tim_work);
 
@@ -1171,11 +1157,11 @@ void wfx_remove_interface(struct ieee80211_hw *hw,
 {
 	struct wfx_dev *wdev = hw->priv;
 	struct wfx_vif *wvif = (struct wfx_vif *) vif->drv_priv;
-	int i;
 
 	wait_for_completion_timeout(&wvif->set_pm_mode_complete, msecs_to_jiffies(300));
 
 	mutex_lock(&wdev->conf_mutex);
+	WARN(wvif->link_id_map != 1, "corrupted state");
 	switch (wvif->state) {
 	case WFX_STATE_PRE_STA:
 	case WFX_STATE_STA:
@@ -1185,13 +1171,6 @@ void wfx_remove_interface(struct ieee80211_hw *hw,
 			wfx_tx_unlock(wdev);
 		break;
 	case WFX_STATE_AP:
-		for (i = 0; wvif->link_id_map; ++i) {
-			if (wvif->link_id_map & BIT(i)) {
-				wfx_unmap_link(wvif, i);
-				wvif->link_id_map &= ~BIT(i);
-			}
-		}
-		memset(wvif->link_id_db, 0, sizeof(wvif->link_id_db));
 		wvif->sta_asleep_mask = 0;
 		wvif->mcast_tx = false;
 		wvif->aid0_bit_set = false;
@@ -1213,7 +1192,6 @@ void wfx_remove_interface(struct ieee80211_hw *hw,
 
 	wfx_cqm_bssloss_sm(wvif, 0, 0, 0);
 	cancel_work_sync(&wvif->unjoin_work);
-	cancel_delayed_work_sync(&wvif->link_id_gc_work);
 	del_timer_sync(&wvif->mcast_timeout);
 	wfx_free_event_queue(wvif);
 

commit 36cbb5d2a7db063879fc92e8496db9c0b7f84d7d
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Wed Jan 15 13:55:13 2020 +0000

    staging: wfx: simplify wfx_set_tim_impl()
    
    Argument provided to wfx_set_tim_impl() is always wvif->aid0_bit_set and
    there is no reason to provide another argument.
    
    Also rename wfx_set_tim_impl() into wfx_update_tim() to reflect the new
    behavior.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200115135338.14374-50-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index cc72877a090f..b7d21540d9a2 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -895,7 +895,7 @@ void wfx_sta_notify(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 	wfx_ps_notify(wvif, notify_cmd, sta_priv->link_id);
 }
 
-static int wfx_set_tim_impl(struct wfx_vif *wvif, bool aid0_bit_set)
+static int wfx_update_tim(struct wfx_vif *wvif)
 {
 	struct sk_buff *skb;
 	u16 tim_offset, tim_length;
@@ -916,7 +916,7 @@ static int wfx_set_tim_impl(struct wfx_vif *wvif, bool aid0_bit_set)
 		tim_ptr[2] = 0;
 
 		/* Set/reset aid0 bit */
-		if (aid0_bit_set)
+		if (wvif->aid0_bit_set)
 			tim_ptr[4] |= 1;
 		else
 			tim_ptr[4] &= ~1;
@@ -928,11 +928,11 @@ static int wfx_set_tim_impl(struct wfx_vif *wvif, bool aid0_bit_set)
 	return 0;
 }
 
-static void wfx_set_tim_work(struct work_struct *work)
+static void wfx_update_tim_work(struct work_struct *work)
 {
-	struct wfx_vif *wvif = container_of(work, struct wfx_vif, set_tim_work);
+	struct wfx_vif *wvif = container_of(work, struct wfx_vif, update_tim_work);
 
-	wfx_set_tim_impl(wvif, wvif->aid0_bit_set);
+	wfx_update_tim(wvif);
 }
 
 int wfx_set_tim(struct ieee80211_hw *hw, struct ieee80211_sta *sta, bool set)
@@ -941,7 +941,7 @@ int wfx_set_tim(struct ieee80211_hw *hw, struct ieee80211_sta *sta, bool set)
 	struct wfx_sta_priv *sta_dev = (struct wfx_sta_priv *) &sta->drv_priv;
 	struct wfx_vif *wvif = wdev_to_wvif(wdev, sta_dev->vif_id);
 
-	schedule_work(&wvif->set_tim_work);
+	schedule_work(&wvif->update_tim_work);
 	return 0;
 }
 
@@ -955,8 +955,8 @@ static void wfx_mcast_start_work(struct work_struct *work)
 	cancel_work_sync(&wvif->mcast_stop_work);
 	if (!wvif->aid0_bit_set) {
 		wfx_tx_lock_flush(wvif->wdev);
-		wfx_set_tim_impl(wvif, true);
 		wvif->aid0_bit_set = true;
+		wfx_update_tim(wvif);
 		mod_timer(&wvif->mcast_timeout, jiffies + tmo);
 		wfx_tx_unlock(wvif->wdev);
 	}
@@ -971,7 +971,7 @@ static void wfx_mcast_stop_work(struct work_struct *work)
 		del_timer_sync(&wvif->mcast_timeout);
 		wfx_tx_lock_flush(wvif->wdev);
 		wvif->aid0_bit_set = false;
-		wfx_set_tim_impl(wvif, false);
+		wfx_update_tim(wvif);
 		wfx_tx_unlock(wvif->wdev);
 	}
 }
@@ -1118,7 +1118,7 @@ int wfx_add_interface(struct ieee80211_hw *hw, struct ieee80211_vif *vif)
 	INIT_DELAYED_WORK(&wvif->link_id_gc_work, wfx_link_id_gc_work);
 
 	spin_lock_init(&wvif->ps_state_lock);
-	INIT_WORK(&wvif->set_tim_work, wfx_set_tim_work);
+	INIT_WORK(&wvif->update_tim_work, wfx_update_tim_work);
 
 	INIT_WORK(&wvif->mcast_start_work, wfx_mcast_start_work);
 	INIT_WORK(&wvif->mcast_stop_work, wfx_mcast_stop_work);

commit d00149011066bde86cd56c64b77616c40a4f83af
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Wed Jan 15 13:55:12 2020 +0000

    staging: wfx: fix RCU usage
    
    Indeed, sta was used after call to rcu_unlock()
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200115135338.14374-49-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index 1c10ebd11944..cc72877a090f 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -690,10 +690,9 @@ static void wfx_join_finalize(struct wfx_vif *wvif,
 	struct ieee80211_sta *sta = NULL;
 
 	wvif->beacon_int = info->beacon_int;
-	rcu_read_lock();
+	rcu_read_lock(); // protect sta
 	if (info->bssid && !info->ibss_joined)
 		sta = ieee80211_find_sta(wvif->vif, info->bssid);
-	rcu_read_unlock();
 	if (sta)
 		wvif->bss_params.operational_rate_set =
 			wfx_rate_mask_to_hw(wvif->wdev, sta->supp_rates[wvif->channel->band]);
@@ -712,6 +711,7 @@ static void wfx_join_finalize(struct wfx_vif *wvif,
 	wvif->bss_params.aid = info->aid;
 
 	hif_set_association_mode(wvif, info, sta ? &sta->ht_cap : NULL);
+	rcu_read_unlock();
 
 	if (!info->ibss_joined) {
 		hif_keep_alive_period(wvif, 30 /* sec */);

commit 76b5c2ce468fc7fa5f4daf727bbefa6f8a2d7a02
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Wed Jan 15 13:55:10 2020 +0000

    staging: wfx: fix bss_loss
    
    wfx_tx_confirm_cb()  retrieves the station associated with a frame using
    the MAC address from the 802.11 header. In the other side wfx_tx()
    retrieves the station using sta field from the ieee80211_tx_control
    argument.
    
    In wfx_cqm_bssloss_sm(), wfx_tx() was called directly without valid sta
    field, but with a valid MAC address in 802.11 header. So there the
    processing of this packet was unbalanced and may produce weird bugs.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200115135338.14374-48-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index aebce96dcd4a..1c10ebd11944 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -88,19 +88,25 @@ void wfx_cqm_bssloss_sm(struct wfx_vif *wvif, int init, int good, int bad)
 	// FIXME: call ieee80211_beacon_loss/ieee80211_connection_loss instead
 	if (tx) {
 		struct sk_buff *skb;
+		struct ieee80211_hdr *hdr;
+		struct ieee80211_tx_control control = { };
 
 		wvif->bss_loss_state++;
 
 		skb = ieee80211_nullfunc_get(wvif->wdev->hw, wvif->vif, false);
 		if (!skb)
 			goto end;
+		hdr = (struct ieee80211_hdr *)skb->data;
 		memset(IEEE80211_SKB_CB(skb), 0,
 		       sizeof(*IEEE80211_SKB_CB(skb)));
 		IEEE80211_SKB_CB(skb)->control.vif = wvif->vif;
 		IEEE80211_SKB_CB(skb)->driver_rates[0].idx = 0;
 		IEEE80211_SKB_CB(skb)->driver_rates[0].count = 1;
 		IEEE80211_SKB_CB(skb)->driver_rates[1].idx = -1;
-		wfx_tx(wvif->wdev->hw, NULL, skb);
+		rcu_read_lock(); // protect control.sta
+		control.sta = ieee80211_find_sta(wvif->vif, hdr->addr1);
+		wfx_tx(wvif->wdev->hw, &control, skb);
+		rcu_read_unlock();
 	}
 end:
 	mutex_unlock(&wvif->bss_loss_lock);

commit 7d2d2bfdeb82c383f5cd8b93b1c234249c1a588c
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Wed Jan 15 13:55:09 2020 +0000

    staging: wfx: relocate "buffered" information to sta_priv
    
    It simplify the code if field buffered is hosted in the struct sta_priv
    instead of in the struct wfx_link_entry. More globally, struct
    wfx_link_entry has no real reasons to exist and should be dropped soon.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200115135338.14374-47-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index 4a44d72f0db1..aebce96dcd4a 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -572,6 +572,7 @@ int wfx_sta_add(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 	struct wfx_sta_priv *sta_priv = (struct wfx_sta_priv *) &sta->drv_priv;
 	struct wfx_link_entry *entry;
 
+	spin_lock_init(&sta_priv->lock);
 	if (wvif->vif->type != NL80211_IFTYPE_AP)
 		return 0;
 

commit 79d5fecc9be29b3159d9d6204082080922e8419f
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Wed Jan 15 13:55:08 2020 +0000

    staging: wfx: remove handling of "early_data"
    
    It seems that purpose of "early_data" was to prevent sending data to
    mac80211 before station was completely associated. It is a useless
    precaution.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200115135338.14374-46-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index 6a43decd5ae6..4a44d72f0db1 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -571,7 +571,6 @@ int wfx_sta_add(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 	struct wfx_vif *wvif = (struct wfx_vif *) vif->drv_priv;
 	struct wfx_sta_priv *sta_priv = (struct wfx_sta_priv *) &sta->drv_priv;
 	struct wfx_link_entry *entry;
-	struct sk_buff *skb;
 
 	if (wvif->vif->type != NL80211_IFTYPE_AP)
 		return 0;
@@ -589,8 +588,6 @@ int wfx_sta_add(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 					IEEE80211_WMM_IE_STA_QOSINFO_AC_MASK)
 		wvif->sta_asleep_mask |= BIT(sta_priv->link_id);
 	entry->status = WFX_LINK_HARD;
-	while ((skb = skb_dequeue(&entry->rx_queue)))
-		ieee80211_rx_irqsafe(wdev->hw, skb);
 	spin_unlock_bh(&wvif->ps_state_lock);
 	return 0;
 }

commit 9b90910f5bf4d6c76bbd55fcda5baa0ff015060b
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Wed Jan 15 13:55:03 2020 +0000

    staging: wfx: do not update uapsd if not necessary
    
    wfx_conf_tx() is called for each queue. On every call, the function
    updates UAPSD mask and PM mode for all queues. It is a pity since the
    UAPSD configuration very rarely changes and it makes exchanges between
    the host and the chip more difficult to track.
    
    This patch avoid to update UAPSD and Power Mode in most usual cases.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200115135338.14374-43-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index bf285389c303..6a43decd5ae6 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -286,6 +286,7 @@ int wfx_conf_tx(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 {
 	struct wfx_dev *wdev = hw->priv;
 	struct wfx_vif *wvif = (struct wfx_vif *) vif->drv_priv;
+	int old_uapsd = wvif->uapsd_mask;
 	int ret = 0;
 
 	WARN_ON(queue >= hw->queues);
@@ -294,7 +295,8 @@ int wfx_conf_tx(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 	assign_bit(queue, &wvif->uapsd_mask, params->uapsd);
 	memcpy(&wvif->edca_params[queue], params, sizeof(*params));
 	hif_set_edca_queue_params(wvif, queue, params);
-	if (wvif->vif->type == NL80211_IFTYPE_STATION) {
+	if (wvif->vif->type == NL80211_IFTYPE_STATION &&
+	    old_uapsd != wvif->uapsd_mask) {
 		hif_set_uapsd_info(wvif, wvif->uapsd_mask);
 		wfx_update_pm(wvif);
 	}

commit f98138a16f854889ef8f583c704d46d5b46161ab
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Wed Jan 15 13:55:02 2020 +0000

    staging: wfx: with multiple vifs, force PS only if channels differs
    
    When multiple vif are in use (the only supported configuration is one
    station and one AP), the driver force power save flag on station.
    This behavior allows the station to leave the station channel and make
    its business on AP channel.
    
    However, this has a big impact on station performances (especially since
    only legacy PS is supported).
    
    When both vifs use the same channel, it is not necessary to keep this
    restriction. This greatly improve station performances.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200115135338.14374-42-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index 94683a1440c8..bf285389c303 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -251,6 +251,7 @@ static int wfx_update_pm(struct wfx_vif *wvif)
 	struct ieee80211_conf *conf = &wvif->wdev->hw->conf;
 	bool ps = conf->flags & IEEE80211_CONF_PS;
 	int ps_timeout = conf->dynamic_ps_timeout;
+	struct ieee80211_channel *chan0 = NULL, *chan1 = NULL;
 
 	WARN_ON(conf->dynamic_ps_timeout < 0);
 	if (wvif->state != WFX_STATE_STA || !wvif->bss_params.aid)
@@ -260,10 +261,15 @@ static int wfx_update_pm(struct wfx_vif *wvif)
 	if (wvif->uapsd_mask)
 		ps_timeout = 0;
 
-	// Kernel disable PowerSave when multiple vifs are in use. In contrary,
-	// it is absolutly necessary to enable PowerSave for WF200
-	// FIXME: only if channel vif0 != channel vif1
-	if (wvif_count(wvif->wdev) > 1) {
+	// Kernel disable powersave when an AP is in use. In contrary, it is
+	// absolutely necessary to enable legacy powersave for WF200 if channels
+	// are differents.
+	if (wdev_to_wvif(wvif->wdev, 0))
+		chan0 = wdev_to_wvif(wvif->wdev, 0)->vif->bss_conf.chandef.chan;
+	if (wdev_to_wvif(wvif->wdev, 1))
+		chan1 = wdev_to_wvif(wvif->wdev, 1)->vif->bss_conf.chandef.chan;
+	if (chan0 && chan1 && chan0->hw_value != chan1->hw_value &&
+	    wvif->vif->type != NL80211_IFTYPE_AP) {
 		ps = true;
 		ps_timeout = 0;
 	}

commit 8d97a12fa4d25f72394201ec840d9231b76b101f
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Wed Jan 15 13:55:01 2020 +0000

    staging: wfx: update power-save per interface
    
    mac80211 and the device are both able to control power-save per vif.
    But, the current code retrieve power-save from wfx_config(). So, it does
    not allow to setup power-save independently for each vif. Driver just
    has to rely on wfx_bss_info_changed() instead of wfx_config().
    
    wfx_config() has nothing to do anymore, but we keep it since it is
    mandatory for mac80211.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200115135338.14374-41-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index 0c3150a94c7c..94683a1440c8 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -826,6 +826,10 @@ void wfx_bss_info_changed(struct ieee80211_hw *hw,
 
 	if (changed & BSS_CHANGED_TXPOWER)
 		hif_set_output_power(wvif, info->txpower);
+
+	if (changed & BSS_CHANGED_PS)
+		wfx_update_pm(wvif);
+
 	mutex_unlock(&wdev->conf_mutex);
 
 	if (do_join)
@@ -1058,18 +1062,7 @@ void wfx_unassign_vif_chanctx(struct ieee80211_hw *hw,
 
 int wfx_config(struct ieee80211_hw *hw, u32 changed)
 {
-	int ret = 0;
-	struct wfx_dev *wdev = hw->priv;
-	struct wfx_vif *wvif;
-
-	if (changed & IEEE80211_CONF_CHANGE_PS) {
-		mutex_lock(&wdev->conf_mutex);
-		wvif = NULL;
-		while ((wvif = wvif_iterate(wdev, wvif)) != NULL)
-			ret = wfx_update_pm(wvif);
-		mutex_unlock(&wdev->conf_mutex);
-	}
-	return ret;
+	return 0;
 }
 
 int wfx_add_interface(struct ieee80211_hw *hw, struct ieee80211_vif *vif)

commit fd5d78bdf7527bb4c8739dc7d56b5b9a669d592b
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Wed Jan 15 13:54:58 2020 +0000

    staging: wfx: simplify wfx_update_filtering()
    
    wfx_update_filtering() has no reason to instantiate a struct
    hif_mib_bcn_filter_enable. Drop it and simplify the code.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200115135338.14374-39-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index a934f66f3a4c..0c3150a94c7c 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -138,10 +138,9 @@ static int wfx_set_mcast_filter(struct wfx_vif *wvif,
 void wfx_update_filtering(struct wfx_vif *wvif)
 {
 	int ret;
-	bool is_sta = wvif->vif && NL80211_IFTYPE_STATION == wvif->vif->type;
-	bool filter_bssid = wvif->filter_bssid;
-	bool fwd_probe_req = wvif->fwd_probe_req;
-	struct hif_mib_bcn_filter_enable bf_ctrl;
+	int bf_enable;
+	int bf_count;
+	int n_filter_ies;
 	struct hif_ie_table_entry filter_ies[] = {
 		{
 			.ie_id        = WLAN_EID_VENDOR_SPECIFIC,
@@ -161,33 +160,29 @@ void wfx_update_filtering(struct wfx_vif *wvif)
 			.has_appeared = 1,
 		}
 	};
-	int n_filter_ies;
 
 	if (wvif->state == WFX_STATE_PASSIVE)
 		return;
 
 	if (wvif->disable_beacon_filter) {
-		bf_ctrl.enable = 0;
-		bf_ctrl.bcn_count = 1;
+		bf_enable = 0;
+		bf_count = 1;
 		n_filter_ies = 0;
-	} else if (!is_sta) {
-		bf_ctrl.enable = HIF_BEACON_FILTER_ENABLE |
-				 HIF_BEACON_FILTER_AUTO_ERP;
-		bf_ctrl.bcn_count = 0;
+	} else if (wvif->vif->type != NL80211_IFTYPE_STATION) {
+		bf_enable = HIF_BEACON_FILTER_ENABLE | HIF_BEACON_FILTER_AUTO_ERP;
+		bf_count = 0;
 		n_filter_ies = 2;
 	} else {
-		bf_ctrl.enable = HIF_BEACON_FILTER_ENABLE;
-		bf_ctrl.bcn_count = 0;
+		bf_enable = HIF_BEACON_FILTER_ENABLE;
+		bf_count = 0;
 		n_filter_ies = 3;
 	}
 
-	ret = hif_set_rx_filter(wvif, filter_bssid, fwd_probe_req);
+	ret = hif_set_rx_filter(wvif, wvif->filter_bssid, wvif->fwd_probe_req);
 	if (!ret)
-		ret = hif_set_beacon_filter_table(wvif, n_filter_ies,
-						  filter_ies);
+		ret = hif_set_beacon_filter_table(wvif, n_filter_ies, filter_ies);
 	if (!ret)
-		ret = hif_beacon_filter_control(wvif, bf_ctrl.enable,
-						bf_ctrl.bcn_count);
+		ret = hif_beacon_filter_control(wvif, bf_enable, bf_count);
 	if (!ret)
 		ret = wfx_set_mcast_filter(wvif, &wvif->mcast_filter);
 	if (ret)

commit 0b58486e153c12845b1f55e0ac458a2cd777ffb5
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Wed Jan 15 13:54:56 2020 +0000

    staging: wfx: simplify wfx_set_mcast_filter()
    
    HIF functions return only serious errors (OOM or device freeze). The
    current handling of errors in wfx_set_mcast_filter() does not bring
    anything. Finally it may disturb the developer more than it helps.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200115135338.14374-38-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index e71b99aa1f63..a934f66f3a4c 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -116,7 +116,7 @@ int wfx_fwd_probe_req(struct wfx_vif *wvif, bool enable)
 static int wfx_set_mcast_filter(struct wfx_vif *wvif,
 				    struct wfx_grp_addr_table *fp)
 {
-	int i, ret;
+	int i;
 
 	// Temporary workaround for filters
 	return hif_set_data_filtering(wvif, false, true);
@@ -124,25 +124,15 @@ static int wfx_set_mcast_filter(struct wfx_vif *wvif,
 	if (!fp->enable)
 		return hif_set_data_filtering(wvif, false, true);
 
-	for (i = 0; i < fp->num_addresses; i++) {
-		ret = hif_set_mac_addr_condition(wvif, i, fp->address_list[i]);
-		if (ret)
-			return ret;
-	}
-
-	ret = hif_set_uc_mc_bc_condition(wvif, 0, HIF_FILTER_UNICAST |
-						  HIF_FILTER_BROADCAST);
-	if (ret)
-		return ret;
+	for (i = 0; i < fp->num_addresses; i++)
+		hif_set_mac_addr_condition(wvif, i, fp->address_list[i]);
+	hif_set_uc_mc_bc_condition(wvif, 0,
+				   HIF_FILTER_UNICAST | HIF_FILTER_BROADCAST);
+	hif_set_config_data_filter(wvif, true, 0, BIT(1),
+				   BIT(fp->num_addresses) - 1);
+	hif_set_data_filtering(wvif, true, true);
 
-	ret = hif_set_config_data_filter(wvif, true, 0, BIT(1),
-					 BIT(fp->num_addresses) - 1);
-	if (ret)
-		return ret;
-
-	ret = hif_set_data_filtering(wvif, true, true);
-
-	return ret;
+	return 0;
 }
 
 void wfx_update_filtering(struct wfx_vif *wvif)

commit db94907110eae5977015e3f12e71d3c07f0f3dcc
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Wed Jan 15 13:54:55 2020 +0000

    staging: wfx: simplify hif_set_config_data_filter()
    
    The structure hif_mib_config_data_filter come from hardware
    API. It is not intended to be manipulated in upper layers of the driver.
    
    In add, current code for hif_set_config_data_filter() is too dumb. It
    should pack data with hardware representation instead of leaving all
    work to the caller.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200115135338.14374-37-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index b74e0ce41069..e71b99aa1f63 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -117,7 +117,6 @@ static int wfx_set_mcast_filter(struct wfx_vif *wvif,
 				    struct wfx_grp_addr_table *fp)
 {
 	int i, ret;
-	struct hif_mib_config_data_filter config = { };
 
 	// Temporary workaround for filters
 	return hif_set_data_filtering(wvif, false, true);
@@ -129,7 +128,6 @@ static int wfx_set_mcast_filter(struct wfx_vif *wvif,
 		ret = hif_set_mac_addr_condition(wvif, i, fp->address_list[i]);
 		if (ret)
 			return ret;
-		config.mac_cond |= 1 << i;
 	}
 
 	ret = hif_set_uc_mc_bc_condition(wvif, 0, HIF_FILTER_UNICAST |
@@ -137,10 +135,8 @@ static int wfx_set_mcast_filter(struct wfx_vif *wvif,
 	if (ret)
 		return ret;
 
-	config.uc_mc_bc_cond = 1;
-	config.filter_idx = 0; // TODO #define MULTICAST_FILTERING 0
-	config.enable = 1;
-	ret = hif_set_config_data_filter(wvif, &config);
+	ret = hif_set_config_data_filter(wvif, true, 0, BIT(1),
+					 BIT(fp->num_addresses) - 1);
 	if (ret)
 		return ret;
 

commit a077126a20a49117903596ceccf0f21ed16b5841
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Wed Jan 15 13:54:54 2020 +0000

    staging: wfx: simplify hif_set_mac_addr_condition()
    
    The structure hif_mib_mac_addr_data_frame_condition come from hardware
    API. It is not intended to be manipulated in upper layers of the driver.
    
    In add, current code for hif_set_mac_addr_condition() is too dumb. It
    should pack data with hardware representation instead of leaving all
    work to the caller.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200115135338.14374-36-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index 588094486a7a..b74e0ce41069 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -118,7 +118,6 @@ static int wfx_set_mcast_filter(struct wfx_vif *wvif,
 {
 	int i, ret;
 	struct hif_mib_config_data_filter config = { };
-	struct hif_mib_mac_addr_data_frame_condition filter_addr_val = { };
 
 	// Temporary workaround for filters
 	return hif_set_data_filtering(wvif, false, true);
@@ -126,14 +125,8 @@ static int wfx_set_mcast_filter(struct wfx_vif *wvif,
 	if (!fp->enable)
 		return hif_set_data_filtering(wvif, false, true);
 
-	// A1 Address match on list
 	for (i = 0; i < fp->num_addresses; i++) {
-		filter_addr_val.condition_idx = i;
-		filter_addr_val.address_type = HIF_MAC_ADDR_A1;
-		ether_addr_copy(filter_addr_val.mac_address,
-				fp->address_list[i]);
-		ret = hif_set_mac_addr_condition(wvif,
-						 &filter_addr_val);
+		ret = hif_set_mac_addr_condition(wvif, i, fp->address_list[i]);
 		if (ret)
 			return ret;
 		config.mac_cond |= 1 << i;

commit c47b70e2c5918fab8d100915b68ada8828563a62
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Wed Jan 15 13:54:52 2020 +0000

    staging: wfx: simplify hif_set_data_filtering()
    
    The structure hif_mib_set_data_filtering come from hardware API. It is
    not intended to be manipulated in upper layers of the driver.
    
    In add, current code for hif_set_data_filtering() is too dumb. It should
    pack data with hardware representation instead of leaving all work to
    the caller.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200115135338.14374-35-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index 27248ea62aea..588094486a7a 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -118,16 +118,13 @@ static int wfx_set_mcast_filter(struct wfx_vif *wvif,
 {
 	int i, ret;
 	struct hif_mib_config_data_filter config = { };
-	struct hif_mib_set_data_filtering filter_data = { };
 	struct hif_mib_mac_addr_data_frame_condition filter_addr_val = { };
 
 	// Temporary workaround for filters
-	return hif_set_data_filtering(wvif, &filter_data);
+	return hif_set_data_filtering(wvif, false, true);
 
-	if (!fp->enable) {
-		filter_data.enable = 0;
-		return hif_set_data_filtering(wvif, &filter_data);
-	}
+	if (!fp->enable)
+		return hif_set_data_filtering(wvif, false, true);
 
 	// A1 Address match on list
 	for (i = 0; i < fp->num_addresses; i++) {
@@ -154,9 +151,7 @@ static int wfx_set_mcast_filter(struct wfx_vif *wvif,
 	if (ret)
 		return ret;
 
-	filter_data.enable = 1;
-	filter_data.invert_matching = 1; // discard all but matching frames
-	ret = hif_set_data_filtering(wvif, &filter_data);
+	ret = hif_set_data_filtering(wvif, true, true);
 
 	return ret;
 }

commit 3f5264e75c7bd332f38c8bc0f903771336fba44d
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Wed Jan 15 13:54:51 2020 +0000

    staging: wfx: simplify hif_mib_set_data_filtering
    
    The field "default_filter" was not obvious.
    
    In add, explicitly declare that fields default_filter and enable are
    booleans.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200115135338.14374-34-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index 1c1b5a6c2474..27248ea62aea 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -154,9 +154,8 @@ static int wfx_set_mcast_filter(struct wfx_vif *wvif,
 	if (ret)
 		return ret;
 
-	// discard all data frames except match filter
 	filter_data.enable = 1;
-	filter_data.default_filter = 1; // discard all
+	filter_data.invert_matching = 1; // discard all but matching frames
 	ret = hif_set_data_filtering(wvif, &filter_data);
 
 	return ret;

commit f5864a1076d1a5f3c7d297ab79bfabaa69af3e41
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Wed Jan 15 13:54:49 2020 +0000

    staging: wfx: simplify hif_mib_uc_mc_bc_data_frame_condition
    
    The current API defines bitfields. It is not very convenient. Prefer to
    use bitmasks.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200115135338.14374-33-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index 79285927c7bf..1c1b5a6c2474 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -142,8 +142,8 @@ static int wfx_set_mcast_filter(struct wfx_vif *wvif,
 		config.mac_cond |= 1 << i;
 	}
 
-	// Accept unicast and broadcast
-	ret = hif_set_uc_mc_bc_condition(wvif, 0, true, false, true);
+	ret = hif_set_uc_mc_bc_condition(wvif, 0, HIF_FILTER_UNICAST |
+						  HIF_FILTER_BROADCAST);
 	if (ret)
 		return ret;
 

commit 46f044b965e62f07a9c1411328487bf8346dbc79
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Wed Jan 15 13:54:48 2020 +0000

    staging: wfx: simplify hif_set_uc_mc_bc_condition()
    
    The structure hif_mib_uc_mc_bc_data_frame_condition come from hardware
    API. It is not intended to be manipulated in upper layers of the driver.
    
    In add, current code for hif_set_uc_mc_bc_condition() is too dumb. It
    should pack data with hardware representation instead of leaving all
    work to the caller.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200115135338.14374-32-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index 9030681858bb..79285927c7bf 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -120,7 +120,6 @@ static int wfx_set_mcast_filter(struct wfx_vif *wvif,
 	struct hif_mib_config_data_filter config = { };
 	struct hif_mib_set_data_filtering filter_data = { };
 	struct hif_mib_mac_addr_data_frame_condition filter_addr_val = { };
-	struct hif_mib_uc_mc_bc_data_frame_condition filter_addr_type = { };
 
 	// Temporary workaround for filters
 	return hif_set_data_filtering(wvif, &filter_data);
@@ -144,10 +143,7 @@ static int wfx_set_mcast_filter(struct wfx_vif *wvif,
 	}
 
 	// Accept unicast and broadcast
-	filter_addr_type.condition_idx = 0;
-	filter_addr_type.param.bits.type_unicast = 1;
-	filter_addr_type.param.bits.type_broadcast = 1;
-	ret = hif_set_uc_mc_bc_condition(wvif, &filter_addr_type);
+	ret = hif_set_uc_mc_bc_condition(wvif, 0, true, false, true);
 	if (ret)
 		return ret;
 

commit a8ec12d419af85c8225222ae19b26ea9c8fd6980
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Wed Jan 15 13:54:46 2020 +0000

    staging: wfx: simplify hif_set_association_mode()
    
    The structure hif_mib_set_association_mode come from hardware API. It is
    not intended to be manipulated in upper layers of the driver.
    
    In add, current code for hif_set_association_mode() is too dumb. It
    should pack data with hardware representation instead of leaving all
    work to the caller.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200115135338.14374-31-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index 30c62e3b3716..9030681858bb 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -712,7 +712,6 @@ static void wfx_join_finalize(struct wfx_vif *wvif,
 			      struct ieee80211_bss_conf *info)
 {
 	struct ieee80211_sta *sta = NULL;
-	struct hif_mib_set_association_mode association_mode = { };
 
 	wvif->beacon_int = info->beacon_int;
 	rcu_read_lock();
@@ -730,26 +729,13 @@ static void wfx_join_finalize(struct wfx_vif *wvif,
 	else
 		hif_dual_cts_protection(wvif, false);
 
-	association_mode.preambtype_use = 1;
-	association_mode.mode = 1;
-	association_mode.rateset = 1;
-	association_mode.spacing = 1;
-	association_mode.short_preamble = info->use_short_preamble;
-	association_mode.basic_rate_set = cpu_to_le32(wfx_rate_mask_to_hw(wvif->wdev, info->basic_rates));
-	if (sta && sta->ht_cap.ht_supported &&
-	    !(info->ht_operation_mode & IEEE80211_HT_OP_MODE_NON_GF_STA_PRSNT))
-		association_mode.greenfield =
-			!!(sta->ht_cap.cap & IEEE80211_HT_CAP_GRN_FLD);
-	if (sta && sta->ht_cap.ht_supported)
-		association_mode.mpdu_start_spacing = sta->ht_cap.ampdu_density;
-
 	wfx_cqm_bssloss_sm(wvif, 0, 0, 0);
 	cancel_work_sync(&wvif->unjoin_work);
 
 	wvif->bss_params.beacon_lost_count = 20;
 	wvif->bss_params.aid = info->aid;
 
-	hif_set_association_mode(wvif, &association_mode);
+	hif_set_association_mode(wvif, info, sta ? &sta->ht_cap : NULL);
 
 	if (!info->ibss_joined) {
 		hif_keep_alive_period(wvif, 30 /* sec */);

commit 9ced9b593741d0472dd1168ca87ca7186e3257f4
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Wed Jan 15 13:54:44 2020 +0000

    staging: wfx: simplify hif_join()
    
    The structure hif_req_join come from hardware API. It is not intended
    to be manipulated in upper layers of the driver.
    
    In add, current code for hif_join() is too dumb. It should pack data
    with hardware representation instead of leaving all work to the caller.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200115135338.14374-30-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index 395a282346b1..30c62e3b3716 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -512,32 +512,19 @@ static void wfx_set_mfp(struct wfx_vif *wvif,
 
 static void wfx_do_join(struct wfx_vif *wvif)
 {
-	const u8 *bssid;
+	int ret;
+	const u8 *ssidie;
 	struct ieee80211_bss_conf *conf = &wvif->vif->bss_conf;
 	struct cfg80211_bss *bss = NULL;
-	struct hif_req_join join = {
-		.infrastructure_bss_mode = !conf->ibss_joined,
-		.short_preamble = conf->use_short_preamble,
-		.probe_for_join = 1,
-		.atim_window = 0,
-		.basic_rate_set = wfx_rate_mask_to_hw(wvif->wdev,
-						      conf->basic_rates),
-	};
 
 	wfx_tx_lock_flush(wvif->wdev);
 
-	if (wvif->channel->flags & IEEE80211_CHAN_NO_IR)
-		join.probe_for_join = 0;
-
 	if (wvif->state)
 		wfx_do_unjoin(wvif);
 
-	bssid = wvif->vif->bss_conf.bssid;
-
 	bss = cfg80211_get_bss(wvif->wdev->hw->wiphy, wvif->channel,
-			       bssid, NULL, 0,
+			       conf->bssid, NULL, 0,
 			       IEEE80211_BSS_TYPE_ANY, IEEE80211_PRIVACY_ANY);
-
 	if (!bss && !conf->ibss_joined) {
 		wfx_tx_unlock(wvif->wdev);
 		return;
@@ -545,29 +532,15 @@ static void wfx_do_join(struct wfx_vif *wvif)
 
 	mutex_lock(&wvif->wdev->conf_mutex);
 
-	/* Sanity check basic rates */
-	if (!join.basic_rate_set)
-		join.basic_rate_set = 7;
-
 	/* Sanity check beacon interval */
 	if (!wvif->beacon_int)
 		wvif->beacon_int = 1;
 
-	join.beacon_interval = wvif->beacon_int;
-	join.channel_number = wvif->channel->hw_value;
-	memcpy(join.bssid, bssid, sizeof(join.bssid));
-
-	if (!conf->ibss_joined) {
-		const u8 *ssidie;
-
-		rcu_read_lock();
+	rcu_read_lock();
+	if (!conf->ibss_joined)
 		ssidie = ieee80211_bss_get_ie(bss, WLAN_EID_SSID);
-		if (ssidie) {
-			join.ssid_length = ssidie[1];
-			memcpy(join.ssid, &ssidie[2], join.ssid_length);
-		}
-		rcu_read_unlock();
-	}
+	else
+		ssidie = NULL;
 
 	wfx_tx_flush(wvif->wdev);
 
@@ -578,7 +551,9 @@ static void wfx_do_join(struct wfx_vif *wvif)
 
 	/* Perform actual join */
 	wvif->wdev->tx_burst_idx = -1;
-	if (hif_join(wvif, &join)) {
+	ret = hif_join(wvif, conf, wvif->channel, ssidie);
+	rcu_read_unlock();
+	if (ret) {
 		ieee80211_connection_loss(wvif->vif);
 		wvif->join_complete_status = -1;
 		/* Tx lock still held, unjoin will clear it. */

commit a09343fc354d45973614e1120f15b5e03db8f972
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Wed Jan 15 13:54:43 2020 +0000

    staging: wfx: simplify hif_update_ie()
    
    hif_update_ie() is only called to change the beacon template. So,
    specialize this function and simplify the way to call it.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200115135338.14374-29-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index e02ebc39ed41..395a282346b1 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -881,9 +881,6 @@ void wfx_bss_info_changed(struct ieee80211_hw *hw,
 	if (changed & BSS_CHANGED_ASSOC ||
 	    changed & BSS_CHANGED_ERP_CTS_PROT ||
 	    changed & BSS_CHANGED_ERP_PREAMBLE) {
-		struct hif_ie_flags target_frame = {
-			.beacon = 1,
-		};
 		u8 erp_ie[3] = { WLAN_EID_ERP_INFO, 1, 0 };
 
 		hif_erp_use_protection(wvif, info->use_cts_prot);
@@ -892,7 +889,7 @@ void wfx_bss_info_changed(struct ieee80211_hw *hw,
 		if (info->use_short_preamble)
 			erp_ie[2] |= WLAN_ERP_BARKER_PREAMBLE;
 		if (wvif->vif->type != NL80211_IFTYPE_STATION)
-			hif_update_ie(wvif, &target_frame, erp_ie, sizeof(erp_ie));
+			hif_update_ie_beacon(wvif, erp_ie, sizeof(erp_ie));
 	}
 
 	if (changed & BSS_CHANGED_ASSOC || changed & BSS_CHANGED_ERP_SLOT)
@@ -960,9 +957,6 @@ void wfx_sta_notify(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 static int wfx_set_tim_impl(struct wfx_vif *wvif, bool aid0_bit_set)
 {
 	struct sk_buff *skb;
-	struct hif_ie_flags target_frame = {
-		.beacon = 1,
-	};
 	u16 tim_offset, tim_length;
 	u8 *tim_ptr;
 
@@ -987,7 +981,7 @@ static int wfx_set_tim_impl(struct wfx_vif *wvif, bool aid0_bit_set)
 			tim_ptr[4] &= ~1;
 	}
 
-	hif_update_ie(wvif, &target_frame, tim_ptr, tim_length);
+	hif_update_ie_beacon(wvif, tim_ptr, tim_length);
 	dev_kfree_skb(skb);
 
 	return 0;

commit deb7734ea984ec6909f4dc86b4707f91301c9ddc
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Wed Jan 15 13:54:40 2020 +0000

    staging: wfx: drop wfx_set_cts_work()
    
    wfx_bss_info_changed() is not called from atomic contexts. So, it is not
    necessary to raise an asynchronous work to change ERP. Thus
    wfx_set_cts_work() become useless.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200115135338.14374-27-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index 7abe272ddc0d..e02ebc39ed41 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -671,24 +671,6 @@ int wfx_sta_remove(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 	return 0;
 }
 
-static void wfx_set_cts_work(struct work_struct *work)
-{
-	struct wfx_vif *wvif = container_of(work, struct wfx_vif, set_cts_work);
-	u8 erp_ie[3] = { WLAN_EID_ERP_INFO, 1, 0 };
-	struct hif_ie_flags target_frame = {
-		.beacon = 1,
-	};
-
-	mutex_lock(&wvif->wdev->conf_mutex);
-	erp_ie[2] = wvif->erp_info;
-	mutex_unlock(&wvif->wdev->conf_mutex);
-
-	hif_erp_use_protection(wvif, erp_ie[2] & WLAN_ERP_USE_PROTECTION);
-
-	if (wvif->vif->type != NL80211_IFTYPE_STATION)
-		hif_update_ie(wvif, &target_frame, erp_ie, sizeof(erp_ie));
-}
-
 static int wfx_start_ap(struct wfx_vif *wvif)
 {
 	int ret;
@@ -896,24 +878,21 @@ void wfx_bss_info_changed(struct ieee80211_hw *hw,
 		}
 	}
 
-	/* ERP Protection */
 	if (changed & BSS_CHANGED_ASSOC ||
 	    changed & BSS_CHANGED_ERP_CTS_PROT ||
 	    changed & BSS_CHANGED_ERP_PREAMBLE) {
-		u32 prev_erp_info = wvif->erp_info;
+		struct hif_ie_flags target_frame = {
+			.beacon = 1,
+		};
+		u8 erp_ie[3] = { WLAN_EID_ERP_INFO, 1, 0 };
 
+		hif_erp_use_protection(wvif, info->use_cts_prot);
 		if (info->use_cts_prot)
-			wvif->erp_info |= WLAN_ERP_USE_PROTECTION;
-		else if (!(prev_erp_info & WLAN_ERP_NON_ERP_PRESENT))
-			wvif->erp_info &= ~WLAN_ERP_USE_PROTECTION;
-
+			erp_ie[2] |= WLAN_ERP_USE_PROTECTION;
 		if (info->use_short_preamble)
-			wvif->erp_info |= WLAN_ERP_BARKER_PREAMBLE;
-		else
-			wvif->erp_info &= ~WLAN_ERP_BARKER_PREAMBLE;
-
-		if (prev_erp_info != wvif->erp_info)
-			schedule_work(&wvif->set_cts_work);
+			erp_ie[2] |= WLAN_ERP_BARKER_PREAMBLE;
+		if (wvif->vif->type != NL80211_IFTYPE_STATION)
+			hif_update_ie(wvif, &target_frame, erp_ie, sizeof(erp_ie));
 	}
 
 	if (changed & BSS_CHANGED_ASSOC || changed & BSS_CHANGED_ERP_SLOT)
@@ -1237,7 +1216,6 @@ int wfx_add_interface(struct ieee80211_hw *hw, struct ieee80211_vif *vif)
 	complete(&wvif->set_pm_mode_complete);
 	INIT_WORK(&wvif->update_filtering_work, wfx_update_filtering_work);
 	INIT_WORK(&wvif->bss_params_work, wfx_bss_params_work);
-	INIT_WORK(&wvif->set_cts_work, wfx_set_cts_work);
 	INIT_WORK(&wvif->unjoin_work, wfx_unjoin_work);
 	INIT_WORK(&wvif->tx_policy_upload_work, wfx_tx_policy_upload_work);
 

commit 963aff5728a0295fe90146289c2a9251024575a4
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Wed Jan 15 13:54:38 2020 +0000

    staging: wfx: drop wvif->setbssparams_done
    
    setbssparams_done was here to ensure that the firmware does not enable
    powersave before to get the first beacon. However, mac80211 already
    ensures it gets a beacon before to associate to the BSS. And even, if
    it won't, the firmware wake up at least on every DTIM, which is
    sufficient to finalize the association.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200115135338.14374-26-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index 021daa9f7a33..7abe272ddc0d 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -326,8 +326,7 @@ int wfx_conf_tx(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 	hif_set_edca_queue_params(wvif, queue, params);
 	if (wvif->vif->type == NL80211_IFTYPE_STATION) {
 		hif_set_uapsd_info(wvif, wvif->uapsd_mask);
-		if (wvif->setbssparams_done && wvif->state == WFX_STATE_STA)
-			ret = wfx_update_pm(wvif);
+		wfx_update_pm(wvif);
 	}
 	mutex_unlock(&wdev->conf_mutex);
 	return ret;
@@ -475,7 +474,6 @@ static void wfx_do_unjoin(struct wfx_vif *wvif)
 	wvif->disable_beacon_filter = false;
 	wfx_update_filtering(wvif);
 	memset(&wvif->bss_params, 0, sizeof(wvif->bss_params));
-	wvif->setbssparams_done = false;
 
 done:
 	mutex_unlock(&wvif->wdev->conf_mutex);
@@ -799,7 +797,6 @@ static void wfx_join_finalize(struct wfx_vif *wvif,
 	if (!info->ibss_joined) {
 		hif_keep_alive_period(wvif, 30 /* sec */);
 		hif_set_bss_params(wvif, &wvif->bss_params);
-		wvif->setbssparams_done = true;
 		hif_set_beacon_wakeup_period(wvif, info->dtim_period,
 					     info->dtim_period);
 		wfx_update_pm(wvif);
@@ -1224,7 +1221,8 @@ int wfx_add_interface(struct ieee80211_hw *hw, struct ieee80211_vif *vif)
 	INIT_WORK(&wvif->mcast_stop_work, wfx_mcast_stop_work);
 	timer_setup(&wvif->mcast_timeout, wfx_mcast_timeout, 0);
 
-	wvif->setbssparams_done = false;
+	memset(&wvif->bss_params, 0, sizeof(wvif->bss_params));
+
 	mutex_init(&wvif->bss_loss_lock);
 	INIT_DELAYED_WORK(&wvif->bss_loss_work, wfx_bss_loss_work);
 

commit ba366b9268263f7f86cf8e53e00bda84e238d29b
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Wed Jan 15 13:54:37 2020 +0000

    staging: wfx: drop wvif->cqm_rssi_thold
    
    Current code keeps a copy of bss_conf->cqm_rssi_thold in wfx_vif. There
    is no sane reason for that.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200115135338.14374-25-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index dede6323bb17..021daa9f7a33 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -377,7 +377,7 @@ static void wfx_event_report_rssi(struct wfx_vif *wvif, u8 raw_rcpi_rssi)
 	int cqm_evt;
 
 	rcpi_rssi = raw_rcpi_rssi / 2 - 110;
-	if (rcpi_rssi <= wvif->cqm_rssi_thold)
+	if (rcpi_rssi <= wvif->vif->bss_conf.cqm_rssi_thold)
 		cqm_evt = NL80211_CQM_RSSI_THRESHOLD_EVENT_LOW;
 	else
 		cqm_evt = NL80211_CQM_RSSI_THRESHOLD_EVENT_HIGH;
@@ -922,11 +922,9 @@ void wfx_bss_info_changed(struct ieee80211_hw *hw,
 	if (changed & BSS_CHANGED_ASSOC || changed & BSS_CHANGED_ERP_SLOT)
 		hif_slot_time(wvif, info->use_short_slot ? 9 : 20);
 
-	if (changed & BSS_CHANGED_ASSOC || changed & BSS_CHANGED_CQM) {
-		wvif->cqm_rssi_thold = info->cqm_rssi_thold;
+	if (changed & BSS_CHANGED_ASSOC || changed & BSS_CHANGED_CQM)
 		hif_set_rcpi_rssi_threshold(wvif, info->cqm_rssi_thold,
 					    info->cqm_rssi_hyst);
-	}
 
 	if (changed & BSS_CHANGED_TXPOWER)
 		hif_set_output_power(wvif, info->txpower);

commit 9d443ffc588bbee103eddecd6b1994cf7d0b0ee8
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Wed Jan 15 13:54:35 2020 +0000

    staging: wfx: drop wvif->enable_beacon
    
    It seems that current code try to save calls to hif_beacon_transmit() by
    keeping a copy of the previous value of bss_conf->enable_beacon.
    However, hif_beacon_transmit() does not cost so much and mac80211
    already take care to not send useless events.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200115135338.14374-24-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index 376451433e9e..dede6323bb17 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -843,12 +843,8 @@ void wfx_bss_info_changed(struct ieee80211_hw *hw,
 	}
 
 	if (changed & BSS_CHANGED_BEACON_ENABLED &&
-	    wvif->state != WFX_STATE_IBSS) {
-		if (wvif->enable_beacon != info->enable_beacon) {
-			hif_beacon_transmit(wvif, info->enable_beacon);
-			wvif->enable_beacon = info->enable_beacon;
-		}
-	}
+	    wvif->state != WFX_STATE_IBSS)
+		hif_beacon_transmit(wvif, info->enable_beacon);
 
 	if (changed & BSS_CHANGED_BEACON_INFO)
 		hif_set_beacon_wakeup_period(wvif, info->dtim_period,
@@ -1299,7 +1295,6 @@ void wfx_remove_interface(struct ieee80211_hw *hw,
 		}
 		memset(wvif->link_id_db, 0, sizeof(wvif->link_id_db));
 		wvif->sta_asleep_mask = 0;
-		wvif->enable_beacon = false;
 		wvif->mcast_tx = false;
 		wvif->aid0_bit_set = false;
 		wvif->mcast_buffered = false;

commit 249802e8e226b869ad065bc56811410f83cbfcd6
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Wed Jan 15 13:54:34 2020 +0000

    staging: wfx: drop wvif->dtim_period
    
    It is not necessary to keep a copy of dtim_period in wfx_vif. Prefer to
    just rely on bss_conf->dtim_period.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200115135338.14374-23-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index 1af99b7930f4..376451433e9e 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -464,7 +464,6 @@ static void wfx_do_unjoin(struct wfx_vif *wvif)
 	hif_keep_alive_period(wvif, 0);
 	hif_reset(wvif, false);
 	wfx_tx_policy_init(wvif);
-	wvif->dtim_period = 0;
 	hif_set_macaddr(wvif, wvif->vif->addr);
 	wfx_free_event_queue(wvif);
 	cancel_work_sync(&wvif->event_handler_work);
@@ -557,10 +556,6 @@ static void wfx_do_join(struct wfx_vif *wvif)
 		wvif->beacon_int = 1;
 
 	join.beacon_interval = wvif->beacon_int;
-
-	// DTIM period will be set on first Beacon
-	wvif->dtim_period = 0;
-
 	join.channel_number = wvif->channel->hw_value;
 	memcpy(join.bssid, bssid, sizeof(join.bssid));
 
@@ -701,8 +696,6 @@ static int wfx_start_ap(struct wfx_vif *wvif)
 	int ret;
 
 	wvif->beacon_int = wvif->vif->bss_conf.beacon_int;
-	wvif->dtim_period = wvif->vif->bss_conf.dtim_period;
-
 	memset(&wvif->link_id_db, 0, sizeof(wvif->link_id_db));
 
 	wvif->wdev->tx_burst_idx = -1;
@@ -766,10 +759,7 @@ static void wfx_join_finalize(struct wfx_vif *wvif,
 	struct ieee80211_sta *sta = NULL;
 	struct hif_mib_set_association_mode association_mode = { };
 
-	if (info->dtim_period)
-		wvif->dtim_period = info->dtim_period;
 	wvif->beacon_int = info->beacon_int;
-
 	rcu_read_lock();
 	if (info->bssid && !info->ibss_joined)
 		sta = ieee80211_find_sta(wvif->vif, info->bssid);
@@ -804,9 +794,6 @@ static void wfx_join_finalize(struct wfx_vif *wvif,
 	wvif->bss_params.beacon_lost_count = 20;
 	wvif->bss_params.aid = info->aid;
 
-	if (wvif->dtim_period < 1)
-		wvif->dtim_period = 1;
-
 	hif_set_association_mode(wvif, &association_mode);
 
 	if (!info->ibss_joined) {
@@ -1055,9 +1042,10 @@ int wfx_set_tim(struct ieee80211_hw *hw, struct ieee80211_sta *sta, bool set)
 
 static void wfx_mcast_start_work(struct work_struct *work)
 {
-	struct wfx_vif *wvif = container_of(work, struct wfx_vif,
-					    mcast_start_work);
-	long tmo = wvif->dtim_period * TU_TO_JIFFIES(wvif->beacon_int + 20);
+	struct wfx_vif *wvif =
+		container_of(work, struct wfx_vif, mcast_start_work);
+	struct ieee80211_bss_conf *conf = &wvif->vif->bss_conf;
+	long tmo = conf->dtim_period * TU_TO_JIFFIES(wvif->beacon_int + 20);
 
 	cancel_work_sync(&wvif->mcast_stop_work);
 	if (!wvif->aid0_bit_set) {

commit b0674e0675520beeca7a52ae7e610d751996e8ed
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Wed Jan 15 13:54:32 2020 +0000

    staging: wfx: simplify update of DTIM period
    
    Current code parse the TIM and retrieve the DTIM period. It is far
    easier to rely on bss_info_changed() for this job.
    
    It is no more necessary to run task asynchronously. So
    set_beacon_wakeup_period_work is now useless.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200115135338.14374-22-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index ae01f7be0ddb..1af99b7930f4 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -446,15 +446,6 @@ static void wfx_bss_params_work(struct work_struct *work)
 	mutex_unlock(&wvif->wdev->conf_mutex);
 }
 
-static void wfx_set_beacon_wakeup_period_work(struct work_struct *work)
-{
-	struct wfx_vif *wvif = container_of(work, struct wfx_vif,
-					    set_beacon_wakeup_period_work);
-
-	hif_set_beacon_wakeup_period(wvif, wvif->dtim_period,
-				     wvif->dtim_period);
-}
-
 static void wfx_do_unjoin(struct wfx_vif *wvif)
 {
 	mutex_lock(&wvif->wdev->conf_mutex);
@@ -466,7 +457,6 @@ static void wfx_do_unjoin(struct wfx_vif *wvif)
 		goto done;
 
 	cancel_work_sync(&wvif->update_filtering_work);
-	cancel_work_sync(&wvif->set_beacon_wakeup_period_work);
 	wvif->state = WFX_STATE_PASSIVE;
 
 	/* Unjoin is a reset. */
@@ -823,7 +813,8 @@ static void wfx_join_finalize(struct wfx_vif *wvif,
 		hif_keep_alive_period(wvif, 30 /* sec */);
 		hif_set_bss_params(wvif, &wvif->bss_params);
 		wvif->setbssparams_done = true;
-		wfx_set_beacon_wakeup_period_work(&wvif->set_beacon_wakeup_period_work);
+		hif_set_beacon_wakeup_period(wvif, info->dtim_period,
+					     info->dtim_period);
 		wfx_update_pm(wvif);
 	}
 }
@@ -872,6 +863,10 @@ void wfx_bss_info_changed(struct ieee80211_hw *hw,
 		}
 	}
 
+	if (changed & BSS_CHANGED_BEACON_INFO)
+		hif_set_beacon_wakeup_period(wvif, info->dtim_period,
+					     info->dtim_period);
+
 	/* assoc/disassoc, or maybe AID changed */
 	if (changed & BSS_CHANGED_ASSOC) {
 		wfx_tx_lock_flush(wdev);
@@ -1260,8 +1255,6 @@ int wfx_add_interface(struct ieee80211_hw *hw, struct ieee80211_vif *vif)
 
 	init_completion(&wvif->set_pm_mode_complete);
 	complete(&wvif->set_pm_mode_complete);
-	INIT_WORK(&wvif->set_beacon_wakeup_period_work,
-		  wfx_set_beacon_wakeup_period_work);
 	INIT_WORK(&wvif->update_filtering_work, wfx_update_filtering_work);
 	INIT_WORK(&wvif->bss_params_work, wfx_bss_params_work);
 	INIT_WORK(&wvif->set_cts_work, wfx_set_cts_work);

commit 50a4fb47e9ac5853e7143367b2877e348ca86ced
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Wed Jan 15 13:54:30 2020 +0000

    staging: wfx: simplify wfx_flush()
    
    Current code of wfx_flush() force to drop packets in some contexts.
    However, there is no obvious reasons to do that. It looks like a
    workaround for a bug with the old implementation of __wfx_flush().
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200115135338.14374-21-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index 3d665eef8ba7..ae01f7be0ddb 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -362,17 +362,7 @@ static int __wfx_flush(struct wfx_dev *wdev, bool drop)
 void wfx_flush(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 		  u32 queues, bool drop)
 {
-	struct wfx_vif *wvif;
-
-	if (vif) {
-		wvif = (struct wfx_vif *) vif->drv_priv;
-		if (wvif->vif->type == NL80211_IFTYPE_MONITOR)
-			drop = true;
-		if (wvif->vif->type == NL80211_IFTYPE_AP &&
-		    !wvif->enable_beacon)
-			drop = true;
-	}
-	// FIXME: only flush requested vif
+	// FIXME: only flush requested vif and queues
 	__wfx_flush(hw->priv, drop);
 }
 

commit 044df863c98d4d4be6306f3251a9397f22418946
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Wed Jan 15 13:54:29 2020 +0000

    staging: wfx: fix __wfx_flush() when drop == false
    
    wfx_tx_queues_clear() only clear not yet sent requests. So, it always
    necessary to wait for tx_queue_stats.wait_link_id_empty whatever the
    value of "drop" argument.
    
    In add, it is not necessary to return with tx queue locked since all
    calls to __wfx_flush() unlock the tx queue just after the call to
    __wfx_tx_flush().
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200115135338.14374-20-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index 0c73691ab736..3d665eef8ba7 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -343,42 +343,25 @@ int wfx_set_rts_threshold(struct ieee80211_hw *hw, u32 value)
 	return 0;
 }
 
-/* If successful, LOCKS the TX queue! */
 static int __wfx_flush(struct wfx_dev *wdev, bool drop)
 {
-	int ret;
-
 	for (;;) {
-		if (drop) {
+		if (drop)
 			wfx_tx_queues_clear(wdev);
-		} else {
-			ret = wait_event_timeout(
-				wdev->tx_queue_stats.wait_link_id_empty,
-				wfx_tx_queues_is_empty(wdev),
-				2 * HZ);
-		}
-
-		if (!drop && ret <= 0) {
-			ret = -ETIMEDOUT;
-			break;
-		}
-		ret = 0;
-
-		wfx_tx_lock_flush(wdev);
-		if (!wfx_tx_queues_is_empty(wdev)) {
-			/* Highly unlikely: WSM requeued frames. */
-			wfx_tx_unlock(wdev);
-			continue;
-		}
-		break;
+		if (wait_event_timeout(wdev->tx_queue_stats.wait_link_id_empty,
+				       wfx_tx_queues_is_empty(wdev),
+				       2 * HZ) <= 0)
+			return -ETIMEDOUT;
+		wfx_tx_flush(wdev);
+		if (wfx_tx_queues_is_empty(wdev))
+			return 0;
+		dev_warn(wdev->dev, "frames queued while flushing tx queues");
 	}
-	return ret;
 }
 
 void wfx_flush(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 		  u32 queues, bool drop)
 {
-	struct wfx_dev *wdev = hw->priv;
 	struct wfx_vif *wvif;
 
 	if (vif) {
@@ -389,10 +372,8 @@ void wfx_flush(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 		    !wvif->enable_beacon)
 			drop = true;
 	}
-
 	// FIXME: only flush requested vif
-	if (!__wfx_flush(wdev, drop))
-		wfx_tx_unlock(wdev);
+	__wfx_flush(hw->priv, drop);
 }
 
 /* WSM callbacks */
@@ -1046,8 +1027,7 @@ static int wfx_set_tim_impl(struct wfx_vif *wvif, bool aid0_bit_set)
 	skb = ieee80211_beacon_get_tim(wvif->wdev->hw, wvif->vif,
 				       &tim_offset, &tim_length);
 	if (!skb) {
-		if (!__wfx_flush(wvif->wdev, true))
-			wfx_tx_unlock(wvif->wdev);
+		__wfx_flush(wvif->wdev, true);
 		return -ENOENT;
 	}
 	tim_ptr = skb->data + tim_offset;

commit 0b2b0595cec64f89814cd1e5fbcbc36e7540443d
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Wed Jan 15 13:54:27 2020 +0000

    staging: wfx: simplify wfx_update_beaconing()
    
    Remove most of indentation of wfx_update_beaconing() by reworking the
    error handling.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200115135338.14374-19-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index 1181203489f0..0c73691ab736 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -760,23 +760,17 @@ static int wfx_start_ap(struct wfx_vif *wvif)
 
 static int wfx_update_beaconing(struct wfx_vif *wvif)
 {
-	struct ieee80211_bss_conf *conf = &wvif->vif->bss_conf;
-
-	if (wvif->vif->type == NL80211_IFTYPE_AP) {
-		/* TODO: check if changed channel, band */
-		if (wvif->state != WFX_STATE_AP ||
-		    wvif->beacon_int != conf->beacon_int) {
-			wfx_tx_lock_flush(wvif->wdev);
-			if (wvif->state != WFX_STATE_PASSIVE) {
-				hif_reset(wvif, false);
-				wfx_tx_policy_init(wvif);
-			}
-			wvif->state = WFX_STATE_PASSIVE;
-			wfx_start_ap(wvif);
-			wfx_tx_unlock(wvif->wdev);
-		} else {
-		}
-	}
+	if (wvif->vif->type != NL80211_IFTYPE_AP)
+		return 0;
+	if (wvif->state == WFX_STATE_AP &&
+	    wvif->beacon_int == wvif->vif->bss_conf.beacon_int)
+		return 0;
+	wfx_tx_lock_flush(wvif->wdev);
+	hif_reset(wvif, false);
+	wfx_tx_policy_init(wvif);
+	wvif->state = WFX_STATE_PASSIVE;
+	wfx_start_ap(wvif);
+	wfx_tx_unlock(wvif->wdev);
 	return 0;
 }
 

commit 305f710995f72a752154c22cf1f5814e661be376
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Wed Jan 15 13:54:26 2020 +0000

    staging: wfx: simplify wfx_upload_ap_templates()
    
    This function built probe response from data retrieved in beacon. Yet,
    this job can be done with ieee80211_proberesp_get(). So, we can simplify
    that code (and fix bugs like inclusion of TIM in probe responses).
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200115135338.14374-18-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index fdde7ab92302..1181203489f0 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -783,7 +783,6 @@ static int wfx_update_beaconing(struct wfx_vif *wvif)
 static int wfx_upload_ap_templates(struct wfx_vif *wvif)
 {
 	struct sk_buff *skb;
-	struct ieee80211_mgmt *mgmt;
 
 	if (wvif->vif->type == NL80211_IFTYPE_STATION ||
 	    wvif->vif->type == NL80211_IFTYPE_MONITOR ||
@@ -795,14 +794,11 @@ static int wfx_upload_ap_templates(struct wfx_vif *wvif)
 		return -ENOMEM;
 	hif_set_template_frame(wvif, skb, HIF_TMPLT_BCN,
 			       API_RATE_INDEX_B_1MBPS);
+	dev_kfree_skb(skb);
 
-	/* TODO: Distill probe resp; remove TIM and any other beacon-specific
-	 * IEs
-	 */
-	mgmt = (void *)skb->data;
-	mgmt->frame_control =
-		cpu_to_le16(IEEE80211_FTYPE_MGMT | IEEE80211_STYPE_PROBE_RESP);
-
+	skb = ieee80211_proberesp_get(wvif->wdev->hw, wvif->vif);
+	if (!skb)
+		return -ENOMEM;
 	hif_set_template_frame(wvif, skb, HIF_TMPLT_PRBRES,
 			       API_RATE_INDEX_B_1MBPS);
 	dev_kfree_skb(skb);

commit d8a92d918612fca365d5b3ed75fc9e41090366ed
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Wed Jan 15 13:54:24 2020 +0000

    staging: wfx: rename wfx_upload_beacon()
    
    In fact, wfx_upload_beacon() uploads beacon and probe response. So,
    rename it in wfx_upload_ap_templates().
    
    The call to wfx_fwd_probe_req() has nothing to do with template
    uploading, so relocate it.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200115135338.14374-17-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index 451d0108a1b0..fdde7ab92302 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -780,7 +780,7 @@ static int wfx_update_beaconing(struct wfx_vif *wvif)
 	return 0;
 }
 
-static int wfx_upload_beacon(struct wfx_vif *wvif)
+static int wfx_upload_ap_templates(struct wfx_vif *wvif)
 {
 	struct sk_buff *skb;
 	struct ieee80211_mgmt *mgmt;
@@ -805,7 +805,6 @@ static int wfx_upload_beacon(struct wfx_vif *wvif)
 
 	hif_set_template_frame(wvif, skb, HIF_TMPLT_PRBRES,
 			       API_RATE_INDEX_B_1MBPS);
-	wfx_fwd_probe_req(wvif, false);
 	dev_kfree_skb(skb);
 	return 0;
 }
@@ -900,7 +899,8 @@ void wfx_bss_info_changed(struct ieee80211_hw *hw,
 	    changed & BSS_CHANGED_IBSS) {
 		wvif->beacon_int = info->beacon_int;
 		wfx_update_beaconing(wvif);
-		wfx_upload_beacon(wvif);
+		wfx_upload_ap_templates(wvif);
+		wfx_fwd_probe_req(wvif, false);
 	}
 
 	if (changed & BSS_CHANGED_BEACON_ENABLED &&

commit 9bf7ad8c93cede3f58d0bfd4b869790401ca6d73
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Wed Jan 15 13:54:23 2020 +0000

    staging: wfx: simplify wfx_config()
    
    Now that wfx_config() only handles IEEE80211_CONF_CHANGE_PS, it can be
    simplified.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200115135338.14374-16-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index a0f19d33e972..451d0108a1b0 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -1230,22 +1230,13 @@ int wfx_config(struct ieee80211_hw *hw, u32 changed)
 	struct wfx_dev *wdev = hw->priv;
 	struct wfx_vif *wvif;
 
-	// FIXME: Interface id should not been hardcoded
-	wvif = wdev_to_wvif(wdev, 0);
-	if (!wvif) {
-		WARN(1, "interface 0 does not exist anymore");
-		return 0;
-	}
-
-	mutex_lock(&wdev->conf_mutex);
 	if (changed & IEEE80211_CONF_CHANGE_PS) {
+		mutex_lock(&wdev->conf_mutex);
 		wvif = NULL;
 		while ((wvif = wvif_iterate(wdev, wvif)) != NULL)
 			ret = wfx_update_pm(wvif);
-		wvif = wdev_to_wvif(wdev, 0);
+		mutex_unlock(&wdev->conf_mutex);
 	}
-
-	mutex_unlock(&wdev->conf_mutex);
 	return ret;
 }
 

commit f050f3dac6686903f001862cc7b67bd2dcaeaea1
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Wed Jan 15 13:54:21 2020 +0000

    staging: wfx: drop wdev->output_power
    
    mac80211 and the device are both able to control tx power per vif. But,
    the current code retrieve tx power from wfx_config(). So, it does not
    allow to setup the tx power independently for each vif. Driver just has
    to rely on bss_conf->txpower to get the correct information.
    
    In add, it is no more necessary to protect access to wdev->output_power
    with scan_lock.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200115135338.14374-15-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index dd2d0422c9ca..a0f19d33e972 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -503,7 +503,6 @@ static void wfx_do_unjoin(struct wfx_vif *wvif)
 	hif_keep_alive_period(wvif, 0);
 	hif_reset(wvif, false);
 	wfx_tx_policy_init(wvif);
-	hif_set_output_power(wvif, wvif->wdev->output_power);
 	wvif->dtim_period = 0;
 	hif_set_macaddr(wvif, wvif->vif->addr);
 	wfx_free_event_queue(wvif);
@@ -990,11 +989,8 @@ void wfx_bss_info_changed(struct ieee80211_hw *hw,
 					    info->cqm_rssi_hyst);
 	}
 
-	if (changed & BSS_CHANGED_TXPOWER &&
-	    info->txpower != wdev->output_power) {
-		wdev->output_power = info->txpower;
-		hif_set_output_power(wvif, wdev->output_power);
-	}
+	if (changed & BSS_CHANGED_TXPOWER)
+		hif_set_output_power(wvif, info->txpower);
 	mutex_unlock(&wdev->conf_mutex);
 
 	if (do_join)
@@ -1232,7 +1228,6 @@ int wfx_config(struct ieee80211_hw *hw, u32 changed)
 {
 	int ret = 0;
 	struct wfx_dev *wdev = hw->priv;
-	struct ieee80211_conf *conf = &hw->conf;
 	struct wfx_vif *wvif;
 
 	// FIXME: Interface id should not been hardcoded
@@ -1242,13 +1237,7 @@ int wfx_config(struct ieee80211_hw *hw, u32 changed)
 		return 0;
 	}
 
-	mutex_lock(&wvif->scan_lock);
 	mutex_lock(&wdev->conf_mutex);
-	if (changed & IEEE80211_CONF_CHANGE_POWER) {
-		wdev->output_power = conf->power_level;
-		hif_set_output_power(wvif, wdev->output_power);
-	}
-
 	if (changed & IEEE80211_CONF_CHANGE_PS) {
 		wvif = NULL;
 		while ((wvif = wvif_iterate(wdev, wvif)) != NULL)
@@ -1257,7 +1246,6 @@ int wfx_config(struct ieee80211_hw *hw, u32 changed)
 	}
 
 	mutex_unlock(&wdev->conf_mutex);
-	mutex_unlock(&wvif->scan_lock);
 	return ret;
 }
 

commit 811ed3e2aba3ca6d99b13704a406e518efa832d1
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Wed Jan 15 13:54:20 2020 +0000

    staging: wfx: drop struct wfx_ht_info
    
    This struct is no more used.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200115135338.14374-14-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index fcd9fe66e417..dd2d0422c9ca 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -517,7 +517,6 @@ static void wfx_do_unjoin(struct wfx_vif *wvif)
 	wfx_update_filtering(wvif);
 	memset(&wvif->bss_params, 0, sizeof(wvif->bss_params));
 	wvif->setbssparams_done = false;
-	memset(&wvif->ht_info, 0, sizeof(wvif->ht_info));
 
 done:
 	mutex_unlock(&wvif->wdev->conf_mutex);
@@ -812,11 +811,6 @@ static int wfx_upload_beacon(struct wfx_vif *wvif)
 	return 0;
 }
 
-static int wfx_is_ht(const struct wfx_ht_info *ht_info)
-{
-	return ht_info->channel_type != NL80211_CHAN_NO_HT;
-}
-
 static void wfx_join_finalize(struct wfx_vif *wvif,
 			      struct ieee80211_bss_conf *info)
 {
@@ -830,17 +824,12 @@ static void wfx_join_finalize(struct wfx_vif *wvif,
 	rcu_read_lock();
 	if (info->bssid && !info->ibss_joined)
 		sta = ieee80211_find_sta(wvif->vif, info->bssid);
-	if (sta) {
-		wvif->ht_info.ht_cap = sta->ht_cap;
+	rcu_read_unlock();
+	if (sta)
 		wvif->bss_params.operational_rate_set =
 			wfx_rate_mask_to_hw(wvif->wdev, sta->supp_rates[wvif->channel->band]);
-		wvif->ht_info.operation_mode = info->ht_operation_mode;
-	} else {
-		memset(&wvif->ht_info, 0, sizeof(wvif->ht_info));
+	else
 		wvif->bss_params.operational_rate_set = -1;
-	}
-	rcu_read_unlock();
-
 	if (sta &&
 	    info->ht_operation_mode & IEEE80211_HT_OP_MODE_NON_GF_STA_PRSNT)
 		hif_dual_cts_protection(wvif, true);
@@ -1224,7 +1213,6 @@ int wfx_assign_vif_chanctx(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 
 	WARN(wvif->channel, "channel overwrite");
 	wvif->channel = ch;
-	wvif->ht_info.channel_type = cfg80211_get_chandef_type(&conf->def);
 
 	return 0;
 }

commit 08dced7f7fe921a3880fd799583a5a85c348b85d
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Wed Jan 15 13:54:19 2020 +0000

    staging: wfx: retrieve greenfield mode from sta->ht_cap and bss_conf
    
    wvif->ht_info contains useless copies of sta->ht_cap and
    bss_conf->ht_operation_mode. Prefer to retrieve information from the
    original structs instead of rely on wvif->ht_info.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200115135338.14374-13-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index f13a5b41735c..fcd9fe66e417 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -817,14 +817,6 @@ static int wfx_is_ht(const struct wfx_ht_info *ht_info)
 	return ht_info->channel_type != NL80211_CHAN_NO_HT;
 }
 
-static int wfx_ht_greenfield(const struct wfx_ht_info *ht_info)
-{
-	return wfx_is_ht(ht_info) &&
-		(ht_info->ht_cap.cap & IEEE80211_HT_CAP_GRN_FLD) &&
-		!(ht_info->operation_mode &
-		  IEEE80211_HT_OP_MODE_NON_GF_STA_PRSNT);
-}
-
 static void wfx_join_finalize(struct wfx_vif *wvif,
 			      struct ieee80211_bss_conf *info)
 {
@@ -849,9 +841,8 @@ static void wfx_join_finalize(struct wfx_vif *wvif,
 	}
 	rcu_read_unlock();
 
-	/* Non Greenfield stations present */
-	if (wvif->ht_info.operation_mode &
-	    IEEE80211_HT_OP_MODE_NON_GF_STA_PRSNT)
+	if (sta &&
+	    info->ht_operation_mode & IEEE80211_HT_OP_MODE_NON_GF_STA_PRSNT)
 		hif_dual_cts_protection(wvif, true);
 	else
 		hif_dual_cts_protection(wvif, false);
@@ -862,7 +853,10 @@ static void wfx_join_finalize(struct wfx_vif *wvif,
 	association_mode.spacing = 1;
 	association_mode.short_preamble = info->use_short_preamble;
 	association_mode.basic_rate_set = cpu_to_le32(wfx_rate_mask_to_hw(wvif->wdev, info->basic_rates));
-	association_mode.greenfield = wfx_ht_greenfield(&wvif->ht_info);
+	if (sta && sta->ht_cap.ht_supported &&
+	    !(info->ht_operation_mode & IEEE80211_HT_OP_MODE_NON_GF_STA_PRSNT))
+		association_mode.greenfield =
+			!!(sta->ht_cap.cap & IEEE80211_HT_CAP_GRN_FLD);
 	if (sta && sta->ht_cap.ht_supported)
 		association_mode.mpdu_start_spacing = sta->ht_cap.ampdu_density;
 

commit c08ffbf7c02bddedda9e2945a9934e2651436706
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Wed Jan 15 13:54:17 2020 +0000

    staging: wfx: retrieve ampdu_density from sta->ht_cap
    
    wvif->ht_info.ht_cap is a useless copy of sta->ht_cap. It makes no sense
    to rely on it.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200115135338.14374-12-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index 660a75024f4b..f13a5b41735c 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -825,13 +825,6 @@ static int wfx_ht_greenfield(const struct wfx_ht_info *ht_info)
 		  IEEE80211_HT_OP_MODE_NON_GF_STA_PRSNT);
 }
 
-static int wfx_ht_ampdu_density(const struct wfx_ht_info *ht_info)
-{
-	if (!wfx_is_ht(ht_info))
-		return 0;
-	return ht_info->ht_cap.ampdu_density;
-}
-
 static void wfx_join_finalize(struct wfx_vif *wvif,
 			      struct ieee80211_bss_conf *info)
 {
@@ -870,7 +863,8 @@ static void wfx_join_finalize(struct wfx_vif *wvif,
 	association_mode.short_preamble = info->use_short_preamble;
 	association_mode.basic_rate_set = cpu_to_le32(wfx_rate_mask_to_hw(wvif->wdev, info->basic_rates));
 	association_mode.greenfield = wfx_ht_greenfield(&wvif->ht_info);
-	association_mode.mpdu_start_spacing = wfx_ht_ampdu_density(&wvif->ht_info);
+	if (sta && sta->ht_cap.ht_supported)
+		association_mode.mpdu_start_spacing = sta->ht_cap.ampdu_density;
 
 	wfx_cqm_bssloss_sm(wvif, 0, 0, 0);
 	cancel_work_sync(&wvif->unjoin_work);

commit 09779276f1baea08985e08587319c8fed806b020
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Wed Jan 15 13:54:14 2020 +0000

    staging: wfx: simplify hif_start() usage
    
    The structure hif_req_start come from hardware API. It is not intended
    to be manipulated in upper layers of the driver.
    
    In add, current code for hif_start() is too dumb. It should pack data
    with hardware representation instead of leaving all work to the caller.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200115135338.14374-10-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index 8c55089b1ea4..660a75024f4b 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -740,38 +740,24 @@ static void wfx_set_cts_work(struct work_struct *work)
 static int wfx_start_ap(struct wfx_vif *wvif)
 {
 	int ret;
-	struct ieee80211_bss_conf *conf = &wvif->vif->bss_conf;
-	struct hif_req_start start = {
-		.channel_number = wvif->channel->hw_value,
-		.beacon_interval = conf->beacon_int,
-		.dtim_period = conf->dtim_period,
-		.short_preamble = conf->use_short_preamble,
-		.basic_rate_set = wfx_rate_mask_to_hw(wvif->wdev,
-						      conf->basic_rates),
-	};
 
-	memset(start.ssid, 0, sizeof(start.ssid));
-	if (!conf->hidden_ssid) {
-		start.ssid_length = conf->ssid_len;
-		memcpy(start.ssid, conf->ssid, start.ssid_length);
-	}
-
-	wvif->beacon_int = conf->beacon_int;
-	wvif->dtim_period = conf->dtim_period;
+	wvif->beacon_int = wvif->vif->bss_conf.beacon_int;
+	wvif->dtim_period = wvif->vif->bss_conf.dtim_period;
 
 	memset(&wvif->link_id_db, 0, sizeof(wvif->link_id_db));
 
 	wvif->wdev->tx_burst_idx = -1;
-	ret = hif_start(wvif, &start);
-	if (!ret)
-		ret = wfx_upload_keys(wvif);
-	if (!ret) {
-		if (wvif_count(wvif->wdev) <= 1)
-			hif_set_block_ack_policy(wvif, 0xFF, 0xFF);
-		wvif->state = WFX_STATE_AP;
-		wfx_update_filtering(wvif);
-	}
-	return ret;
+	ret = hif_start(wvif, &wvif->vif->bss_conf, wvif->channel);
+	if (ret)
+		return ret;
+	ret = wfx_upload_keys(wvif);
+	if (ret)
+		return ret;
+	if (wvif_count(wvif->wdev) <= 1)
+		hif_set_block_ack_policy(wvif, 0xFF, 0xFF);
+	wvif->state = WFX_STATE_AP;
+	wfx_update_filtering(wvif);
+	return 0;
 }
 
 static int wfx_update_beaconing(struct wfx_vif *wvif)

commit e52e68eee7d0a6731d2f8d9234ba3ab226f392dd
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Wed Jan 15 13:54:13 2020 +0000

    staging: wfx: simplify hif_set_arp_ipv4_filter() usage
    
    The structure hif_mib_arp_ip_addr_table come from hardware API. It is
    not intended to be manipulated in upper layers of the driver.
    
    In add, current code for hif_set_arp_ipv4_filter() is too dumb. It
    should pack data using the hardware representation instead of leaving
    all work to the caller.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200115135338.14374-9-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index 339acbce96fb..8c55089b1ea4 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -915,30 +915,19 @@ void wfx_bss_info_changed(struct ieee80211_hw *hw,
 	struct wfx_vif *wvif = (struct wfx_vif *) vif->drv_priv;
 	bool do_join = false;
 	int i;
-	int nb_arp_addr;
 
 	mutex_lock(&wdev->conf_mutex);
 
 	/* TODO: BSS_CHANGED_QOS */
 	if (changed & BSS_CHANGED_ARP_FILTER) {
-		struct hif_mib_arp_ip_addr_table filter = { };
-
-		nb_arp_addr = info->arp_addr_cnt;
-		if (nb_arp_addr <= 0 || nb_arp_addr > HIF_MAX_ARP_IP_ADDRTABLE_ENTRIES)
-			nb_arp_addr = 0;
-
 		for (i = 0; i < HIF_MAX_ARP_IP_ADDRTABLE_ENTRIES; i++) {
-			filter.condition_idx = i;
-			if (i < nb_arp_addr) {
-				// Caution: type of arp_addr_list[i] is __be32
-				memcpy(filter.ipv4_address,
-				       &info->arp_addr_list[i],
-				       sizeof(filter.ipv4_address));
-				filter.arp_enable = HIF_ARP_NS_FILTERING_ENABLE;
-			} else {
-				filter.arp_enable = HIF_ARP_NS_FILTERING_DISABLE;
-			}
-			hif_set_arp_ipv4_filter(wvif, &filter);
+			__be32 *arp_addr = &info->arp_addr_list[i];
+
+			if (info->arp_addr_cnt > HIF_MAX_ARP_IP_ADDRTABLE_ENTRIES)
+				arp_addr = NULL;
+			if (i >= info->arp_addr_cnt)
+				arp_addr = NULL;
+			hif_set_arp_ipv4_filter(wvif, i, arp_addr);
 		}
 	}
 

commit 9ed8b0d0f27cf7ba183d8e8e7c5cc47afb7a00ae
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Wed Jan 15 13:54:12 2020 +0000

    staging: wfx: simplify hif_set_rcpi_rssi_threshold() usage
    
    The structure hif_mib_rcpi_rssi_threshold come from hardware API. It is
    not intended to be manipulated in upper layers of the driver.
    
    In add, current code for hif_set_rcpi_rssi_threshold() is dumb. It
    should pack data using the hardware representation instead of leaving
    all work to the caller.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200115135338.14374-8-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index 11e33a6d5bb5..339acbce96fb 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -1033,31 +1033,9 @@ void wfx_bss_info_changed(struct ieee80211_hw *hw,
 		hif_slot_time(wvif, info->use_short_slot ? 9 : 20);
 
 	if (changed & BSS_CHANGED_ASSOC || changed & BSS_CHANGED_CQM) {
-		struct hif_mib_rcpi_rssi_threshold th = {
-			.rolling_average_count = 8,
-			.detection = 1,
-		};
-
 		wvif->cqm_rssi_thold = info->cqm_rssi_thold;
-
-		if (!info->cqm_rssi_thold && !info->cqm_rssi_hyst) {
-			th.upperthresh = 1;
-			th.lowerthresh = 1;
-		} else {
-			/* FIXME It's not a correct way of setting threshold.
-			 * Upper and lower must be set equal here and adjusted
-			 * in callback. However current implementation is much
-			 * more reliable and stable.
-			 */
-			/* RSSI: signed Q8.0, RCPI: unsigned Q7.1
-			 * RSSI = RCPI / 2 - 110
-			 */
-			th.upper_threshold = info->cqm_rssi_thold + info->cqm_rssi_hyst;
-			th.upper_threshold = (th.upper_threshold + 110) * 2;
-			th.lower_threshold = info->cqm_rssi_thold;
-			th.lower_threshold = (th.lower_threshold + 110) * 2;
-		}
-		hif_set_rcpi_rssi_threshold(wvif, &th);
+		hif_set_rcpi_rssi_threshold(wvif, info->cqm_rssi_thold,
+					    info->cqm_rssi_hyst);
 	}
 
 	if (changed & BSS_CHANGED_TXPOWER &&

commit 5fd64673cf6e2ca08447a77de3d2fe7e73d54915
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Wed Jan 15 13:54:10 2020 +0000

    staging: wfx: simplify hif_set_output_power() usage
    
    Hardware API use 10th of dBm for output power unit. Upper layers should
    use same units than mac80211 and the conversion should be done by low
    level layer of the driver (hif_set_output_power())
    
    In add, current code of hif_set_output_power() use a __le32 while the
    device API specify a specific structure for this.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200115135338.14374-7-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index 8f53a78d7215..11e33a6d5bb5 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -503,7 +503,7 @@ static void wfx_do_unjoin(struct wfx_vif *wvif)
 	hif_keep_alive_period(wvif, 0);
 	hif_reset(wvif, false);
 	wfx_tx_policy_init(wvif);
-	hif_set_output_power(wvif, wvif->wdev->output_power * 10);
+	hif_set_output_power(wvif, wvif->wdev->output_power);
 	wvif->dtim_period = 0;
 	hif_set_macaddr(wvif, wvif->vif->addr);
 	wfx_free_event_queue(wvif);
@@ -1063,7 +1063,7 @@ void wfx_bss_info_changed(struct ieee80211_hw *hw,
 	if (changed & BSS_CHANGED_TXPOWER &&
 	    info->txpower != wdev->output_power) {
 		wdev->output_power = info->txpower;
-		hif_set_output_power(wvif, wdev->output_power * 10);
+		hif_set_output_power(wvif, wdev->output_power);
 	}
 	mutex_unlock(&wdev->conf_mutex);
 
@@ -1317,7 +1317,7 @@ int wfx_config(struct ieee80211_hw *hw, u32 changed)
 	mutex_lock(&wdev->conf_mutex);
 	if (changed & IEEE80211_CONF_CHANGE_POWER) {
 		wdev->output_power = conf->power_level;
-		hif_set_output_power(wvif, wdev->output_power * 10);
+		hif_set_output_power(wvif, wdev->output_power);
 	}
 
 	if (changed & IEEE80211_CONF_CHANGE_PS) {

commit c360f1ccdcf9532a8d8cee0f0976b28b6cb4e35b
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Wed Jan 15 13:54:09 2020 +0000

    staging: wfx: simplify hif_set_tx_rate_retry_policy() usage
    
    The structure hif_mib_set_tx_rate_retry_policy come from hardware
    API. It is not intended to be manipulated in upper layers of the driver.
    
    So, this patch relocate handling of this structure to
    hif_set_tx_rate_retry_policy() (the low level function).
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200115135338.14374-6-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index 9011b5d78706..8f53a78d7215 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -19,7 +19,7 @@
 
 #define HIF_MAX_ARP_IP_ADDRTABLE_ENTRIES 2
 
-static u32 wfx_rate_mask_to_hw(struct wfx_dev *wdev, u32 rates)
+u32 wfx_rate_mask_to_hw(struct wfx_dev *wdev, u32 rates)
 {
 	int i;
 	u32 ret = 0;

commit 0469fc6a1a8715b5c09117a26700da0d67061fb5
Author: Colin Ian King <colin.king@canonical.com>
Date:   Sat Dec 21 00:15:43 2019 +0000

    staging: wfx: check for memory allocation failures from wfx_alloc_hif
    
    Currently calls to wfx_alloc_hif are not checking for a null return
    when a memory allocation fails and this leads to null pointer
    dereferencing issues.  Fix this by adding null pointer checks and
    returning passing down -ENOMEM errors where necessary. The error
    checking in the current driver is a bit sparse, so this may need
    some extra attention later if required.
    
    Fixes: f95a29d40782 ("staging: wfx: add HIF commands helpers")
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Link: https://lore.kernel.org/r/20191221001543.15255-1-colin.king@canonical.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index 9a61478d98f8..9011b5d78706 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -316,6 +316,7 @@ int wfx_conf_tx(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 {
 	struct wfx_dev *wdev = hw->priv;
 	struct wfx_vif *wvif = (struct wfx_vif *) vif->drv_priv;
+	int ret = 0;
 
 	WARN_ON(queue >= hw->queues);
 
@@ -326,10 +327,10 @@ int wfx_conf_tx(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 	if (wvif->vif->type == NL80211_IFTYPE_STATION) {
 		hif_set_uapsd_info(wvif, wvif->uapsd_mask);
 		if (wvif->setbssparams_done && wvif->state == WFX_STATE_STA)
-			wfx_update_pm(wvif);
+			ret = wfx_update_pm(wvif);
 	}
 	mutex_unlock(&wdev->conf_mutex);
-	return 0;
+	return ret;
 }
 
 int wfx_set_rts_threshold(struct ieee80211_hw *hw, u32 value)
@@ -1322,7 +1323,7 @@ int wfx_config(struct ieee80211_hw *hw, u32 changed)
 	if (changed & IEEE80211_CONF_CHANGE_PS) {
 		wvif = NULL;
 		while ((wvif = wvif_iterate(wdev, wvif)) != NULL)
-			wfx_update_pm(wvif);
+			ret = wfx_update_pm(wvif);
 		wvif = wdev_to_wvif(wdev, 0);
 	}
 
@@ -1333,7 +1334,7 @@ int wfx_config(struct ieee80211_hw *hw, u32 changed)
 
 int wfx_add_interface(struct ieee80211_hw *hw, struct ieee80211_vif *vif)
 {
-	int i;
+	int i, ret = 0;
 	struct wfx_dev *wdev = hw->priv;
 	struct wfx_vif *wvif = (struct wfx_vif *) vif->drv_priv;
 
@@ -1417,9 +1418,9 @@ int wfx_add_interface(struct ieee80211_hw *hw, struct ieee80211_vif *vif)
 		else
 			hif_set_block_ack_policy(wvif, 0x00, 0x00);
 		// Combo force powersave mode. We can re-enable it now
-		wfx_update_pm(wvif);
+		ret = wfx_update_pm(wvif);
 	}
-	return 0;
+	return ret;
 }
 
 void wfx_remove_interface(struct ieee80211_hw *hw,

commit 398d999f96bf8e02573b0c7e32896c7812393bc0
Merge: a5a985542066 46cf053efec6
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon Dec 23 07:00:09 2019 -0500

    Merge 5.5-rc3 into staging-next
    
    We need the staging fixes in here as well.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 3dc67854dfa95f7d3f132988536ace282828378a
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Tue Dec 17 16:15:39 2019 +0000

    staging: wfx: delayed_link_loss cannot happen
    
    Original code allows to detect an BSS loss during a scan and delaying
    the handling of BSS loss. However, there it is no real problem to just
    make these two events mutually exclusive (there is just a performance
    penalty).
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20191217161318.31402-54-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index 7ae763e96455..3296bc3521d5 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -63,7 +63,6 @@ void wfx_cqm_bssloss_sm(struct wfx_vif *wvif, int init, int good, int bad)
 	int tx = 0;
 
 	mutex_lock(&wvif->bss_loss_lock);
-	wvif->delayed_link_loss = 0;
 	cancel_work_sync(&wvif->bss_params_work);
 
 	if (init) {
@@ -429,18 +428,9 @@ static void wfx_event_handler_work(struct work_struct *work)
 		switch (event->evt.event_id) {
 		case HIF_EVENT_IND_BSSLOST:
 			cancel_work_sync(&wvif->unjoin_work);
-			if (mutex_trylock(&wvif->scan_lock)) {
-				wfx_cqm_bssloss_sm(wvif, 1, 0, 0);
-				mutex_unlock(&wvif->scan_lock);
-			} else {
-				/* Scan is in progress. Delay reporting.
-				 * Scan complete will trigger bss_loss_work
-				 */
-				wvif->delayed_link_loss = 1;
-				/* Also start a watchdog. */
-				schedule_delayed_work(&wvif->bss_loss_work,
-						      5 * HZ);
-			}
+			mutex_lock(&wvif->scan_lock);
+			wfx_cqm_bssloss_sm(wvif, 1, 0, 0);
+			mutex_unlock(&wvif->scan_lock);
 			break;
 		case HIF_EVENT_IND_BSSREGAINED:
 			wfx_cqm_bssloss_sm(wvif, 0, 0, 0);
@@ -497,8 +487,6 @@ static void wfx_do_unjoin(struct wfx_vif *wvif)
 {
 	mutex_lock(&wvif->wdev->conf_mutex);
 
-	wvif->delayed_link_loss = false;
-
 	if (!wvif->state)
 		goto done;
 

commit 9699c88a4427d592655977a8cbeae46864df7700
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Tue Dec 17 16:15:38 2019 +0000

    staging: wfx: delayed_unjoin cannot happen
    
    Original code allows to detect an unjoin request during a scan and
    delaying the unjoin request. However, it is far easier to just block the
    unjoin request until the end of the scan request.
    
    In fact, it is already the case since scan and unjoin are protected by
    conf_mutex. So, currently, the handling of delayed_unjoin is just dead
    code.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20191217161318.31402-53-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index 4354bb8081c5..7ae763e96455 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -66,10 +66,6 @@ void wfx_cqm_bssloss_sm(struct wfx_vif *wvif, int init, int good, int bad)
 	wvif->delayed_link_loss = 0;
 	cancel_work_sync(&wvif->bss_params_work);
 
-	/* If we have a pending unjoin */
-	if (wvif->delayed_unjoin)
-		goto end;
-
 	if (init) {
 		schedule_delayed_work(&wvif->bss_loss_work, HZ);
 		wvif->bss_loss_state = 0;
@@ -501,16 +497,6 @@ static void wfx_do_unjoin(struct wfx_vif *wvif)
 {
 	mutex_lock(&wvif->wdev->conf_mutex);
 
-	if (!mutex_trylock(&wvif->scan_lock)) {
-		if (wvif->delayed_unjoin)
-			dev_dbg(wvif->wdev->dev,
-				"delayed unjoin is already scheduled\n");
-		else
-			wvif->delayed_unjoin = true;
-		goto done;
-	}
-	mutex_unlock(&wvif->scan_lock);
-
 	wvif->delayed_link_loss = false;
 
 	if (!wvif->state)

commit 3827e33d371ed2f4024fd42a4409e1b7af8e0938
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Tue Dec 17 16:15:37 2019 +0000

    staging: wfx: workaround bug with "iw scan"
    
    mac80211 specification does not forbid hw_scan() to call
    ieee80211_scan_completed(). However, from userspace point of view, not
    all applications support this behavior. In particular, the code of iw
    contains a big fat warning:
    
       /*
        * This code has a bug, which requires creating a separate
        * nl80211 socket to fix:
        * It is possible for a NL80211_CMD_NEW_SCAN_RESULTS or
        * NL80211_CMD_SCAN_ABORTED message to be sent by the kernel
        * before (!) we listen to it, because we only start listening
        * after we send our scan request.
        [...]
        * Alas, the kernel doesn't do that (yet).
        */
    
    So, we have to avoid to call ieee80211_scan_completed() from hw_scan()
    (it's a kind of unwritten rule).
    
    This patch relocates the hw_scan() process to a work_struct to fix the
    problem.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20191217161318.31402-52-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index 16f5db873275..4354bb8081c5 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -1427,6 +1427,7 @@ int wfx_add_interface(struct ieee80211_hw *hw, struct ieee80211_vif *vif)
 
 	mutex_init(&wvif->scan_lock);
 	init_completion(&wvif->scan_complete);
+	INIT_WORK(&wvif->scan_work, wfx_hw_scan_work);
 
 	mutex_unlock(&wdev->conf_mutex);
 

commit d1c015b4ef6f2ab74b19c216cfff07742b7665cf
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Tue Dec 17 16:15:35 2019 +0000

    staging: wfx: rewrite wfx_hw_scan()
    
    Scan requests from mac80211 must be splitted in a few hardware requests
    (it is necessary to split channels with active scan and channels with
    passive scan). Current code schedules a work_struct for each hardware
    request and one delayed_work to handle scan timeout.
    
    It is far simpler to run send all the hardware requests synchronously
    and replace delayed_work with a simple wait_for_completion_timeout().
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20191217161318.31402-51-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index ba3e81fd477b..16f5db873275 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -277,13 +277,13 @@ void wfx_configure_filter(struct ieee80211_hw *hw,
 	*total_flags &= FIF_OTHER_BSS | FIF_FCSFAIL | FIF_PROBE_REQ;
 
 	while ((wvif = wvif_iterate(wdev, wvif)) != NULL) {
-		down(&wvif->scan.lock);
+		mutex_lock(&wvif->scan_lock);
 		wvif->filter_bssid = (*total_flags &
 				      (FIF_OTHER_BSS | FIF_PROBE_REQ)) ? 0 : 1;
 		wvif->disable_beacon_filter = !(*total_flags & FIF_PROBE_REQ);
 		wfx_fwd_probe_req(wvif, true);
 		wfx_update_filtering(wvif);
-		up(&wvif->scan.lock);
+		mutex_unlock(&wvif->scan_lock);
 	}
 }
 
@@ -433,9 +433,9 @@ static void wfx_event_handler_work(struct work_struct *work)
 		switch (event->evt.event_id) {
 		case HIF_EVENT_IND_BSSLOST:
 			cancel_work_sync(&wvif->unjoin_work);
-			if (!down_trylock(&wvif->scan.lock)) {
+			if (mutex_trylock(&wvif->scan_lock)) {
 				wfx_cqm_bssloss_sm(wvif, 1, 0, 0);
-				up(&wvif->scan.lock);
+				mutex_unlock(&wvif->scan_lock);
 			} else {
 				/* Scan is in progress. Delay reporting.
 				 * Scan complete will trigger bss_loss_work
@@ -501,7 +501,7 @@ static void wfx_do_unjoin(struct wfx_vif *wvif)
 {
 	mutex_lock(&wvif->wdev->conf_mutex);
 
-	if (atomic_read(&wvif->scan.in_progress)) {
+	if (!mutex_trylock(&wvif->scan_lock)) {
 		if (wvif->delayed_unjoin)
 			dev_dbg(wvif->wdev->dev,
 				"delayed unjoin is already scheduled\n");
@@ -509,6 +509,7 @@ static void wfx_do_unjoin(struct wfx_vif *wvif)
 			wvif->delayed_unjoin = true;
 		goto done;
 	}
+	mutex_unlock(&wvif->scan_lock);
 
 	wvif->delayed_link_loss = false;
 
@@ -613,14 +614,6 @@ static void wfx_do_join(struct wfx_vif *wvif)
 
 	mutex_lock(&wvif->wdev->conf_mutex);
 
-	/* Under the conf lock: check scan status and
-	 * bail out if it is in progress.
-	 */
-	if (atomic_read(&wvif->scan.in_progress)) {
-		wfx_tx_unlock(wvif->wdev);
-		goto done_put;
-	}
-
 	/* Sanity check basic rates */
 	if (!join.basic_rate_set)
 		join.basic_rate_set = 7;
@@ -684,7 +677,6 @@ static void wfx_do_join(struct wfx_vif *wvif)
 	}
 	wfx_update_filtering(wvif);
 
-done_put:
 	mutex_unlock(&wvif->wdev->conf_mutex);
 	if (bss)
 		cfg80211_put_bss(wvif->wdev->hw->wiphy, bss);
@@ -1346,7 +1338,7 @@ int wfx_config(struct ieee80211_hw *hw, u32 changed)
 		return 0;
 	}
 
-	down(&wvif->scan.lock);
+	mutex_lock(&wvif->scan_lock);
 	mutex_lock(&wdev->conf_mutex);
 	if (changed & IEEE80211_CONF_CHANGE_POWER) {
 		wdev->output_power = conf->power_level;
@@ -1361,7 +1353,7 @@ int wfx_config(struct ieee80211_hw *hw, u32 changed)
 	}
 
 	mutex_unlock(&wdev->conf_mutex);
-	up(&wvif->scan.lock);
+	mutex_unlock(&wvif->scan_lock);
 	return ret;
 }
 
@@ -1419,10 +1411,6 @@ int wfx_add_interface(struct ieee80211_hw *hw, struct ieee80211_vif *vif)
 	wvif->wep_default_key_id = -1;
 	INIT_WORK(&wvif->wep_key_work, wfx_wep_key_work);
 
-	sema_init(&wvif->scan.lock, 1);
-	INIT_WORK(&wvif->scan.work, wfx_scan_work);
-	INIT_DELAYED_WORK(&wvif->scan.timeout, wfx_scan_timeout);
-
 	spin_lock_init(&wvif->event_queue_lock);
 	INIT_LIST_HEAD(&wvif->event_queue);
 	INIT_WORK(&wvif->event_handler_work, wfx_event_handler_work);
@@ -1435,8 +1423,11 @@ int wfx_add_interface(struct ieee80211_hw *hw, struct ieee80211_vif *vif)
 	INIT_WORK(&wvif->bss_params_work, wfx_bss_params_work);
 	INIT_WORK(&wvif->set_cts_work, wfx_set_cts_work);
 	INIT_WORK(&wvif->unjoin_work, wfx_unjoin_work);
-
 	INIT_WORK(&wvif->tx_policy_upload_work, wfx_tx_policy_upload_work);
+
+	mutex_init(&wvif->scan_lock);
+	init_completion(&wvif->scan_complete);
+
 	mutex_unlock(&wdev->conf_mutex);
 
 	hif_set_macaddr(wvif, vif->addr);
@@ -1462,10 +1453,6 @@ void wfx_remove_interface(struct ieee80211_hw *hw,
 	struct wfx_vif *wvif = (struct wfx_vif *) vif->drv_priv;
 	int i;
 
-	// If scan is in progress, stop it
-	while (down_trylock(&wvif->scan.lock))
-		schedule();
-	up(&wvif->scan.lock);
 	wait_for_completion_timeout(&wvif->set_pm_mode_complete, msecs_to_jiffies(300));
 
 	mutex_lock(&wdev->conf_mutex);
@@ -1505,8 +1492,6 @@ void wfx_remove_interface(struct ieee80211_hw *hw,
 	/* FIXME: In add to reset MAC address, try to reset interface */
 	hif_set_macaddr(wvif, NULL);
 
-	cancel_delayed_work_sync(&wvif->scan.timeout);
-
 	wfx_cqm_bssloss_sm(wvif, 0, 0, 0);
 	cancel_work_sync(&wvif->unjoin_work);
 	cancel_delayed_work_sync(&wvif->link_id_gc_work);

commit 094ecec9be6096960cb4ae6a6256759bbba7aa0a
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Tue Dec 17 16:15:34 2019 +0000

    staging: wfx: simplify hif_set_template_frame() usage
    
    The structure hif_mib_template_frame come from hardware API. It is not
    intended to be manipulated in upper layers of the driver.
    
    In add, the current code for hif_set_template_frame() is dumb. All the
    difficult task is left to the caller. So, there is code to factorize
    here.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20191217161318.31402-50-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index 19ca13543a25..ba3e81fd477b 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -831,32 +831,20 @@ static int wfx_update_beaconing(struct wfx_vif *wvif)
 
 static int wfx_upload_beacon(struct wfx_vif *wvif)
 {
-	int ret = 0;
-	struct sk_buff *skb = NULL;
+	struct sk_buff *skb;
 	struct ieee80211_mgmt *mgmt;
-	struct hif_mib_template_frame *p;
 
 	if (wvif->vif->type == NL80211_IFTYPE_STATION ||
 	    wvif->vif->type == NL80211_IFTYPE_MONITOR ||
 	    wvif->vif->type == NL80211_IFTYPE_UNSPECIFIED)
-		goto done;
+		return 0;
 
 	skb = ieee80211_beacon_get(wvif->wdev->hw, wvif->vif);
-
 	if (!skb)
 		return -ENOMEM;
+	hif_set_template_frame(wvif, skb, HIF_TMPLT_BCN,
+			       API_RATE_INDEX_B_1MBPS);
 
-	p = (struct hif_mib_template_frame *) skb_push(skb, 4);
-	p->frame_type = HIF_TMPLT_BCN;
-	p->init_rate = API_RATE_INDEX_B_1MBPS; /* 1Mbps DSSS */
-	p->frame_length = cpu_to_le16(skb->len - 4);
-
-	ret = hif_set_template_frame(wvif, p);
-
-	skb_pull(skb, 4);
-
-	if (ret)
-		goto done;
 	/* TODO: Distill probe resp; remove TIM and any other beacon-specific
 	 * IEs
 	 */
@@ -864,14 +852,11 @@ static int wfx_upload_beacon(struct wfx_vif *wvif)
 	mgmt->frame_control =
 		cpu_to_le16(IEEE80211_FTYPE_MGMT | IEEE80211_STYPE_PROBE_RESP);
 
-	p->frame_type = HIF_TMPLT_PRBRES;
-
-	ret = hif_set_template_frame(wvif, p);
+	hif_set_template_frame(wvif, skb, HIF_TMPLT_PRBRES,
+			       API_RATE_INDEX_B_1MBPS);
 	wfx_fwd_probe_req(wvif, false);
-
-done:
 	dev_kfree_skb(skb);
-	return ret;
+	return 0;
 }
 
 static int wfx_is_ht(const struct wfx_ht_info *ht_info)

commit 871341db220ab0b63153daf295946137f73e727a
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Tue Dec 17 16:15:27 2019 +0000

    staging: wfx: simplify hif_set_edca_queue_params() usage
    
    The struct hif_req_edca_queue_params comes from hardware API. It is not
    intended to be manipulated in upper layers of the driver.
    
    So, this patch:
      1. relocate the handling of this struct in hif_set_edca_queue_params()
         (the low level function)
      2. replace it in wfx_vif by the mac80211 equivalent: struct
         ieee80211_tx_queue_params
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20191217161318.31402-44-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index 3504b6b3515e..19ca13543a25 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -17,7 +17,6 @@
 #include "hif_tx.h"
 #include "hif_tx_mib.h"
 
-#define TXOP_UNIT 32
 #define HIF_MAX_ARP_IP_ADDRTABLE_ENTRIES 2
 
 static u32 wfx_rate_mask_to_hw(struct wfx_dev *wdev, u32 rates)
@@ -322,26 +321,13 @@ int wfx_conf_tx(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 {
 	struct wfx_dev *wdev = hw->priv;
 	struct wfx_vif *wvif = (struct wfx_vif *) vif->drv_priv;
-	struct hif_req_edca_queue_params *edca;
 
 	WARN_ON(queue >= hw->queues);
 
 	mutex_lock(&wdev->conf_mutex);
 	assign_bit(queue, &wvif->uapsd_mask, params->uapsd);
-	edca = &wvif->edca_params[queue];
-	edca->aifsn = params->aifs;
-	edca->cw_min = params->cw_min;
-	edca->cw_max = params->cw_max;
-	edca->tx_op_limit = params->txop * TXOP_UNIT;
-	edca->allowed_medium_time = 0;
-	edca->queue_id = 3 - queue;
-	// API 2.0 has changed queue IDs values
-	if (wfx_api_older_than(wdev, 2, 0) && queue == IEEE80211_AC_BE)
-		edca->queue_id = HIF_QUEUE_ID_BACKGROUND;
-	if (wfx_api_older_than(wdev, 2, 0) && queue == IEEE80211_AC_BK)
-		edca->queue_id = HIF_QUEUE_ID_BESTEFFORT;
-	hif_set_edca_queue_params(wvif, edca);
-
+	memcpy(&wvif->edca_params[queue], params, sizeof(*params));
+	hif_set_edca_queue_params(wvif, queue, params);
 	if (wvif->vif->type == NL80211_IFTYPE_STATION) {
 		hif_set_uapsd_info(wvif, wvif->uapsd_mask);
 		if (wvif->setbssparams_done && wvif->state == WFX_STATE_STA)

commit 654e369365fda7ed565646ccc5ac6d4f1d4dd6bb
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Tue Dec 17 16:15:25 2019 +0000

    staging: wfx: remove unnecessary EDCA initialisation
    
    mac80211 already call wfx_conf_tx() on every VIF instanciation. So, the
    driver does not need to do it.
    
    Note that current code did dirty things with wvif->edca_params. This
    struct was initialized, but only 'queue_id' was really used. The other
    members are only used to store temporary values.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20191217161318.31402-43-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index d52f618062a6..3504b6b3515e 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -334,6 +334,12 @@ int wfx_conf_tx(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 	edca->cw_max = params->cw_max;
 	edca->tx_op_limit = params->txop * TXOP_UNIT;
 	edca->allowed_medium_time = 0;
+	edca->queue_id = 3 - queue;
+	// API 2.0 has changed queue IDs values
+	if (wfx_api_older_than(wdev, 2, 0) && queue == IEEE80211_AC_BE)
+		edca->queue_id = HIF_QUEUE_ID_BACKGROUND;
+	if (wfx_api_older_than(wdev, 2, 0) && queue == IEEE80211_AC_BK)
+		edca->queue_id = HIF_QUEUE_ID_BESTEFFORT;
 	hif_set_edca_queue_params(wvif, edca);
 
 	if (wvif->vif->type == NL80211_IFTYPE_STATION) {
@@ -1393,44 +1399,6 @@ int wfx_add_interface(struct ieee80211_hw *hw, struct ieee80211_vif *vif)
 	int i;
 	struct wfx_dev *wdev = hw->priv;
 	struct wfx_vif *wvif = (struct wfx_vif *) vif->drv_priv;
-	// FIXME: parameters are set by kernel juste after interface_add.
-	// Keep struct hif_req_edca_queue_params blank?
-	struct hif_req_edca_queue_params default_edca_params[] = {
-		[IEEE80211_AC_VO] = {
-			.queue_id = HIF_QUEUE_ID_VOICE,
-			.aifsn = 2,
-			.cw_min = 3,
-			.cw_max = 7,
-			.tx_op_limit = TXOP_UNIT * 47,
-		},
-		[IEEE80211_AC_VI] = {
-			.queue_id = HIF_QUEUE_ID_VIDEO,
-			.aifsn = 2,
-			.cw_min = 7,
-			.cw_max = 15,
-			.tx_op_limit = TXOP_UNIT * 94,
-		},
-		[IEEE80211_AC_BE] = {
-			.queue_id = HIF_QUEUE_ID_BESTEFFORT,
-			.aifsn = 3,
-			.cw_min = 15,
-			.cw_max = 1023,
-			.tx_op_limit = TXOP_UNIT * 0,
-		},
-		[IEEE80211_AC_BK] = {
-			.queue_id = HIF_QUEUE_ID_BACKGROUND,
-			.aifsn = 7,
-			.cw_min = 15,
-			.cw_max = 1023,
-			.tx_op_limit = TXOP_UNIT * 0,
-		},
-	};
-
-	BUILD_BUG_ON(ARRAY_SIZE(default_edca_params) != ARRAY_SIZE(wvif->edca_params));
-	if (wfx_api_older_than(wdev, 2, 0)) {
-		default_edca_params[IEEE80211_AC_BE].queue_id = HIF_QUEUE_ID_BACKGROUND;
-		default_edca_params[IEEE80211_AC_BK].queue_id = HIF_QUEUE_ID_BESTEFFORT;
-	}
 
 	vif->driver_flags |= IEEE80211_VIF_BEACON_FILTER |
 			     IEEE80211_VIF_SUPPORTS_UAPSD |
@@ -1501,13 +1469,6 @@ int wfx_add_interface(struct ieee80211_hw *hw, struct ieee80211_vif *vif)
 	mutex_unlock(&wdev->conf_mutex);
 
 	hif_set_macaddr(wvif, vif->addr);
-	for (i = 0; i < IEEE80211_NUM_ACS; i++) {
-		memcpy(&wvif->edca_params[i], &default_edca_params[i],
-		       sizeof(default_edca_params[i]));
-		hif_set_edca_queue_params(wvif, &wvif->edca_params[i]);
-	}
-	wvif->uapsd_mask = 0;
-	hif_set_uapsd_info(wvif, wvif->uapsd_mask);
 
 	wfx_tx_policy_init(wvif);
 	wvif = NULL;

commit 7e2b32f54f61cc5ebc9c18d605ee84cef53eb60d
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Tue Dec 17 16:15:24 2019 +0000

    staging: wfx: drop struct wfx_edca_params
    
    Intermediate structure wfx_edca_params does not help. This patch
    relocates its members directly in struct wfx_vif.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20191217161318.31402-42-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index b4007afcd0c6..d52f618062a6 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -299,7 +299,7 @@ static int wfx_update_pm(struct wfx_vif *wvif)
 		return 0;
 	if (!ps)
 		ps_timeout = 0;
-	if (wvif->edca.uapsd_mask)
+	if (wvif->uapsd_mask)
 		ps_timeout = 0;
 
 	// Kernel disable PowerSave when multiple vifs are in use. In contrary,
@@ -327,8 +327,8 @@ int wfx_conf_tx(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 	WARN_ON(queue >= hw->queues);
 
 	mutex_lock(&wdev->conf_mutex);
-	assign_bit(queue, &wvif->edca.uapsd_mask, params->uapsd);
-	edca = &wvif->edca.params[queue];
+	assign_bit(queue, &wvif->uapsd_mask, params->uapsd);
+	edca = &wvif->edca_params[queue];
 	edca->aifsn = params->aifs;
 	edca->cw_min = params->cw_min;
 	edca->cw_max = params->cw_max;
@@ -337,7 +337,7 @@ int wfx_conf_tx(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 	hif_set_edca_queue_params(wvif, edca);
 
 	if (wvif->vif->type == NL80211_IFTYPE_STATION) {
-		hif_set_uapsd_info(wvif, wvif->edca.uapsd_mask);
+		hif_set_uapsd_info(wvif, wvif->uapsd_mask);
 		if (wvif->setbssparams_done && wvif->state == WFX_STATE_STA)
 			wfx_update_pm(wvif);
 	}
@@ -1426,7 +1426,7 @@ int wfx_add_interface(struct ieee80211_hw *hw, struct ieee80211_vif *vif)
 		},
 	};
 
-	BUILD_BUG_ON(ARRAY_SIZE(default_edca_params) != ARRAY_SIZE(wvif->edca.params));
+	BUILD_BUG_ON(ARRAY_SIZE(default_edca_params) != ARRAY_SIZE(wvif->edca_params));
 	if (wfx_api_older_than(wdev, 2, 0)) {
 		default_edca_params[IEEE80211_AC_BE].queue_id = HIF_QUEUE_ID_BACKGROUND;
 		default_edca_params[IEEE80211_AC_BK].queue_id = HIF_QUEUE_ID_BESTEFFORT;
@@ -1502,12 +1502,12 @@ int wfx_add_interface(struct ieee80211_hw *hw, struct ieee80211_vif *vif)
 
 	hif_set_macaddr(wvif, vif->addr);
 	for (i = 0; i < IEEE80211_NUM_ACS; i++) {
-		memcpy(&wvif->edca.params[i], &default_edca_params[i],
+		memcpy(&wvif->edca_params[i], &default_edca_params[i],
 		       sizeof(default_edca_params[i]));
-		hif_set_edca_queue_params(wvif, &wvif->edca.params[i]);
+		hif_set_edca_queue_params(wvif, &wvif->edca_params[i]);
 	}
-	wvif->edca.uapsd_mask = 0;
-	hif_set_uapsd_info(wvif, wvif->edca.uapsd_mask);
+	wvif->uapsd_mask = 0;
+	hif_set_uapsd_info(wvif, wvif->uapsd_mask);
 
 	wfx_tx_policy_init(wvif);
 	wvif = NULL;

commit adc90758f4d508fa6a462fbc3f67821387a3e2a8
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Tue Dec 17 16:15:23 2019 +0000

    staging: wfx: simplify hif_set_pm() usage
    
    The struct hif_req_set_pm_mode comes from hardware API. It is not
    intended to be manipulated in upper layers of the driver. So, this patch
    relocate the handling of this struct to hif_set_pm() (the low level
    function).
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20191217161318.31402-41-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index 9eca35d91ad3..b4007afcd0c6 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -291,37 +291,30 @@ void wfx_configure_filter(struct ieee80211_hw *hw,
 static int wfx_update_pm(struct wfx_vif *wvif)
 {
 	struct ieee80211_conf *conf = &wvif->wdev->hw->conf;
-	struct hif_req_set_pm_mode pm;
+	bool ps = conf->flags & IEEE80211_CONF_PS;
+	int ps_timeout = conf->dynamic_ps_timeout;
 
+	WARN_ON(conf->dynamic_ps_timeout < 0);
 	if (wvif->state != WFX_STATE_STA || !wvif->bss_params.aid)
 		return 0;
-
-	memset(&pm, 0, sizeof(pm));
-	if (conf->flags & IEEE80211_CONF_PS) {
-		pm.pm_mode.enter_psm = 1;
-		// Firmware does not support more than 128ms
-		pm.fast_psm_idle_period =
-			min(conf->dynamic_ps_timeout * 2, 255);
-		if (pm.fast_psm_idle_period)
-			pm.pm_mode.fast_psm = 1;
-	}
-
+	if (!ps)
+		ps_timeout = 0;
 	if (wvif->edca.uapsd_mask)
-		pm.pm_mode.fast_psm = 0;
+		ps_timeout = 0;
 
 	// Kernel disable PowerSave when multiple vifs are in use. In contrary,
 	// it is absolutly necessary to enable PowerSave for WF200
 	// FIXME: only if channel vif0 != channel vif1
 	if (wvif_count(wvif->wdev) > 1) {
-		pm.pm_mode.enter_psm = 1;
-		pm.pm_mode.fast_psm = 0;
+		ps = true;
+		ps_timeout = 0;
 	}
 
 	if (!wait_for_completion_timeout(&wvif->set_pm_mode_complete,
 					 TU_TO_JIFFIES(512)))
 		dev_warn(wvif->wdev->dev,
 			 "timeout while waiting of set_pm_mode_complete\n");
-	return hif_set_pm(wvif, &pm);
+	return hif_set_pm(wvif, ps, ps_timeout);
 }
 
 int wfx_conf_tx(struct ieee80211_hw *hw, struct ieee80211_vif *vif,

commit d74d60c3a1784b6333cdfbf919316d353c934352
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Tue Dec 17 16:15:21 2019 +0000

    staging: wfx: simplify hif_set_uapsd_info() usage
    
    It is useless to keep uapsd_info in struct wfx_vif. This structure can
    be rebuilt just before to be sent.
    
    In add, the struct hif_mib_set_uapsd_information comes from hardware
    API. It is not intended to be manipulated in upper layers of the driver.
    So, this patch relocates the handling of this struct to
    hif_set_uapsd_info() (the low level function).
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20191217161318.31402-40-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index e59560f499ea..9eca35d91ad3 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -112,44 +112,6 @@ void wfx_cqm_bssloss_sm(struct wfx_vif *wvif, int init, int good, int bad)
 	mutex_unlock(&wvif->bss_loss_lock);
 }
 
-static int wfx_set_uapsd_param(struct wfx_vif *wvif,
-			   const struct wfx_edca_params *arg)
-{
-	/* Here's the mapping AC [queue, bit]
-	 *  VO [0,3], VI [1, 2], BE [2, 1], BK [3, 0]
-	 */
-
-	if (arg->uapsd_mask & BIT(IEEE80211_AC_VO))
-		wvif->uapsd_info.trig_voice = 1;
-	else
-		wvif->uapsd_info.trig_voice = 0;
-
-	if (arg->uapsd_mask & BIT(IEEE80211_AC_VI))
-		wvif->uapsd_info.trig_video = 1;
-	else
-		wvif->uapsd_info.trig_video = 0;
-
-	if (arg->uapsd_mask & BIT(IEEE80211_AC_BE))
-		wvif->uapsd_info.trig_be = 1;
-	else
-		wvif->uapsd_info.trig_be = 0;
-
-	if (arg->uapsd_mask & BIT(IEEE80211_AC_BK))
-		wvif->uapsd_info.trig_bckgrnd = 1;
-	else
-		wvif->uapsd_info.trig_bckgrnd = 0;
-
-	/* Currently pseudo U-APSD operation is not supported, so setting
-	 * MinAutoTriggerInterval, MaxAutoTriggerInterval and
-	 * AutoTriggerStep to 0
-	 */
-	wvif->uapsd_info.min_auto_trigger_interval = 0;
-	wvif->uapsd_info.max_auto_trigger_interval = 0;
-	wvif->uapsd_info.auto_trigger_step = 0;
-
-	return hif_set_uapsd_info(wvif, &wvif->uapsd_info);
-}
-
 int wfx_fwd_probe_req(struct wfx_vif *wvif, bool enable)
 {
 	wvif->fwd_probe_req = enable;
@@ -382,7 +344,7 @@ int wfx_conf_tx(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 	hif_set_edca_queue_params(wvif, edca);
 
 	if (wvif->vif->type == NL80211_IFTYPE_STATION) {
-		wfx_set_uapsd_param(wvif, &wvif->edca);
+		hif_set_uapsd_info(wvif, wvif->edca.uapsd_mask);
 		if (wvif->setbssparams_done && wvif->state == WFX_STATE_STA)
 			wfx_update_pm(wvif);
 	}
@@ -1552,7 +1514,7 @@ int wfx_add_interface(struct ieee80211_hw *hw, struct ieee80211_vif *vif)
 		hif_set_edca_queue_params(wvif, &wvif->edca.params[i]);
 	}
 	wvif->edca.uapsd_mask = 0;
-	wfx_set_uapsd_param(wvif, &wvif->edca);
+	hif_set_uapsd_info(wvif, wvif->edca.uapsd_mask);
 
 	wfx_tx_policy_init(wvif);
 	wvif = NULL;

commit 010149e6fbccc48d726afb8e68cdc30c8b703c78
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Tue Dec 17 16:15:20 2019 +0000

    staging: wfx: prefer a bitmask instead of an array of boolean
    
    It is easier to manipulate a int than an array of booleans.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20191217161318.31402-39-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index 045d3916ada8..e59560f499ea 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -119,22 +119,22 @@ static int wfx_set_uapsd_param(struct wfx_vif *wvif,
 	 *  VO [0,3], VI [1, 2], BE [2, 1], BK [3, 0]
 	 */
 
-	if (arg->uapsd_enable[IEEE80211_AC_VO])
+	if (arg->uapsd_mask & BIT(IEEE80211_AC_VO))
 		wvif->uapsd_info.trig_voice = 1;
 	else
 		wvif->uapsd_info.trig_voice = 0;
 
-	if (arg->uapsd_enable[IEEE80211_AC_VI])
+	if (arg->uapsd_mask & BIT(IEEE80211_AC_VI))
 		wvif->uapsd_info.trig_video = 1;
 	else
 		wvif->uapsd_info.trig_video = 0;
 
-	if (arg->uapsd_enable[IEEE80211_AC_BE])
+	if (arg->uapsd_mask & BIT(IEEE80211_AC_BE))
 		wvif->uapsd_info.trig_be = 1;
 	else
 		wvif->uapsd_info.trig_be = 0;
 
-	if (arg->uapsd_enable[IEEE80211_AC_BK])
+	if (arg->uapsd_mask & BIT(IEEE80211_AC_BK))
 		wvif->uapsd_info.trig_bckgrnd = 1;
 	else
 		wvif->uapsd_info.trig_bckgrnd = 0;
@@ -330,7 +330,6 @@ static int wfx_update_pm(struct wfx_vif *wvif)
 {
 	struct ieee80211_conf *conf = &wvif->wdev->hw->conf;
 	struct hif_req_set_pm_mode pm;
-	u16 uapsd_flags;
 
 	if (wvif->state != WFX_STATE_STA || !wvif->bss_params.aid)
 		return 0;
@@ -345,9 +344,7 @@ static int wfx_update_pm(struct wfx_vif *wvif)
 			pm.pm_mode.fast_psm = 1;
 	}
 
-	memcpy(&uapsd_flags, &wvif->uapsd_info, sizeof(uapsd_flags));
-
-	if (uapsd_flags != 0)
+	if (wvif->edca.uapsd_mask)
 		pm.pm_mode.fast_psm = 0;
 
 	// Kernel disable PowerSave when multiple vifs are in use. In contrary,
@@ -375,7 +372,7 @@ int wfx_conf_tx(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 	WARN_ON(queue >= hw->queues);
 
 	mutex_lock(&wdev->conf_mutex);
-	wvif->edca.uapsd_enable[queue] = params->uapsd;
+	assign_bit(queue, &wvif->edca.uapsd_mask, params->uapsd);
 	edca = &wvif->edca.params[queue];
 	edca->aifsn = params->aifs;
 	edca->cw_min = params->cw_min;
@@ -1552,9 +1549,9 @@ int wfx_add_interface(struct ieee80211_hw *hw, struct ieee80211_vif *vif)
 	for (i = 0; i < IEEE80211_NUM_ACS; i++) {
 		memcpy(&wvif->edca.params[i], &default_edca_params[i],
 		       sizeof(default_edca_params[i]));
-		wvif->edca.uapsd_enable[i] = false;
 		hif_set_edca_queue_params(wvif, &wvif->edca.params[i]);
 	}
+	wvif->edca.uapsd_mask = 0;
 	wfx_set_uapsd_param(wvif, &wvif->edca);
 
 	wfx_tx_policy_init(wvif);

commit c91ba8c8514307c3c60dc2b1015d379b1d01c809
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Tue Dec 17 16:15:19 2019 +0000

    staging: wfx: simplify wfx_conf_tx()
    
    Error management of wfx_conf_tx() can be simplified.
    
    In add, the hardware command "hif_set_edca_queue_params" never returns
    any error.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20191217161318.31402-38-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index 42b0d01d85cc..045d3916ada8 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -370,39 +370,27 @@ int wfx_conf_tx(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 {
 	struct wfx_dev *wdev = hw->priv;
 	struct wfx_vif *wvif = (struct wfx_vif *) vif->drv_priv;
-	int ret = 0;
 	struct hif_req_edca_queue_params *edca;
 
-	mutex_lock(&wdev->conf_mutex);
-
-	if (queue < hw->queues) {
-		edca = &wvif->edca.params[queue];
-
-		wvif->edca.uapsd_enable[queue] = params->uapsd;
-		edca->aifsn = params->aifs;
-		edca->cw_min = params->cw_min;
-		edca->cw_max = params->cw_max;
-		edca->tx_op_limit = params->txop * TXOP_UNIT;
-		edca->allowed_medium_time = 0;
-		ret = hif_set_edca_queue_params(wvif, edca);
-		if (ret) {
-			ret = -EINVAL;
-			goto out;
-		}
+	WARN_ON(queue >= hw->queues);
 
-		if (wvif->vif->type == NL80211_IFTYPE_STATION) {
-			ret = wfx_set_uapsd_param(wvif, &wvif->edca);
-			if (!ret && wvif->setbssparams_done &&
-			    wvif->state == WFX_STATE_STA)
-				ret = wfx_update_pm(wvif);
-		}
-	} else {
-		ret = -EINVAL;
+	mutex_lock(&wdev->conf_mutex);
+	wvif->edca.uapsd_enable[queue] = params->uapsd;
+	edca = &wvif->edca.params[queue];
+	edca->aifsn = params->aifs;
+	edca->cw_min = params->cw_min;
+	edca->cw_max = params->cw_max;
+	edca->tx_op_limit = params->txop * TXOP_UNIT;
+	edca->allowed_medium_time = 0;
+	hif_set_edca_queue_params(wvif, edca);
+
+	if (wvif->vif->type == NL80211_IFTYPE_STATION) {
+		wfx_set_uapsd_param(wvif, &wvif->edca);
+		if (wvif->setbssparams_done && wvif->state == WFX_STATE_STA)
+			wfx_update_pm(wvif);
 	}
-
-out:
 	mutex_unlock(&wdev->conf_mutex);
-	return ret;
+	return 0;
 }
 
 int wfx_set_rts_threshold(struct ieee80211_hw *hw, u32 value)

commit 8a274dfb59209d0e0bd96f3a7917aceba39b0ca4
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Tue Dec 17 16:15:17 2019 +0000

    staging: wfx: fix pm_mode timeout
    
    Maximum request time (how long a request wait for the medium) is set in
    firmware to 512TU
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20191217161318.31402-37-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index dcb4693ec980..42b0d01d85cc 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -359,7 +359,7 @@ static int wfx_update_pm(struct wfx_vif *wvif)
 	}
 
 	if (!wait_for_completion_timeout(&wvif->set_pm_mode_complete,
-					 msecs_to_jiffies(300)))
+					 TU_TO_JIFFIES(512)))
 		dev_warn(wvif->wdev->dev,
 			 "timeout while waiting of set_pm_mode_complete\n");
 	return hif_set_pm(wvif, &pm);

commit 3f97c37063bca3948cbb8a2275f34dba7e86d025
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Tue Dec 17 16:15:16 2019 +0000

    staging: wfx: do not try to save call to hif_set_pm()
    
    Current code try to not exchange data with device if it is not
    necessary. However, it seems that the additional code does not provide
    any gain. So, we prefer to keep a simpler code.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20191217161318.31402-36-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index c57135f77572..dcb4693ec980 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -371,14 +371,11 @@ int wfx_conf_tx(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 	struct wfx_dev *wdev = hw->priv;
 	struct wfx_vif *wvif = (struct wfx_vif *) vif->drv_priv;
 	int ret = 0;
-	/* To prevent re-applying PM request OID again and again*/
-	u16 old_uapsd_flags, new_uapsd_flags;
 	struct hif_req_edca_queue_params *edca;
 
 	mutex_lock(&wdev->conf_mutex);
 
 	if (queue < hw->queues) {
-		old_uapsd_flags = *((u16 *) &wvif->uapsd_info);
 		edca = &wvif->edca.params[queue];
 
 		wvif->edca.uapsd_enable[queue] = params->uapsd;
@@ -395,10 +392,8 @@ int wfx_conf_tx(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 
 		if (wvif->vif->type == NL80211_IFTYPE_STATION) {
 			ret = wfx_set_uapsd_param(wvif, &wvif->edca);
-			new_uapsd_flags = *((u16 *) &wvif->uapsd_info);
 			if (!ret && wvif->setbssparams_done &&
-			    wvif->state == WFX_STATE_STA &&
-			    old_uapsd_flags != new_uapsd_flags)
+			    wvif->state == WFX_STATE_STA)
 				ret = wfx_update_pm(wvif);
 		}
 	} else {

commit 50ad848cc6d6c6290a38b62ea60abefb903396d3
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Tue Dec 17 16:15:15 2019 +0000

    staging: wfx: drop unnecessary wvif->powersave_mode
    
    Power save status is already available in bss_conf. So there is no
    reason to keep information duplicated in wvif->powersave_mode.
    
    In add, type of wvif->powersave_mode is low level struct made to
    communicate with device. We would like to limit usage of this kind of
    struct in upper layers of the driver.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20191217161318.31402-35-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index 91fa4d8aa37d..c57135f77572 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -328,12 +328,23 @@ void wfx_configure_filter(struct ieee80211_hw *hw,
 
 static int wfx_update_pm(struct wfx_vif *wvif)
 {
-	struct hif_req_set_pm_mode pm = wvif->powersave_mode;
+	struct ieee80211_conf *conf = &wvif->wdev->hw->conf;
+	struct hif_req_set_pm_mode pm;
 	u16 uapsd_flags;
 
 	if (wvif->state != WFX_STATE_STA || !wvif->bss_params.aid)
 		return 0;
 
+	memset(&pm, 0, sizeof(pm));
+	if (conf->flags & IEEE80211_CONF_PS) {
+		pm.pm_mode.enter_psm = 1;
+		// Firmware does not support more than 128ms
+		pm.fast_psm_idle_period =
+			min(conf->dynamic_ps_timeout * 2, 255);
+		if (pm.fast_psm_idle_period)
+			pm.pm_mode.fast_psm = 1;
+	}
+
 	memcpy(&uapsd_flags, &wvif->uapsd_info, sizeof(uapsd_flags));
 
 	if (uapsd_flags != 0)
@@ -1432,24 +1443,8 @@ int wfx_config(struct ieee80211_hw *hw, u32 changed)
 
 	if (changed & IEEE80211_CONF_CHANGE_PS) {
 		wvif = NULL;
-		while ((wvif = wvif_iterate(wdev, wvif)) != NULL) {
-			memset(&wvif->powersave_mode, 0,
-			       sizeof(wvif->powersave_mode));
-			if (conf->flags & IEEE80211_CONF_PS) {
-				wvif->powersave_mode.pm_mode.enter_psm = 1;
-				if (conf->dynamic_ps_timeout > 0) {
-					wvif->powersave_mode.pm_mode.fast_psm = 1;
-					/*
-					 * Firmware does not support more than
-					 * 128ms
-					 */
-					wvif->powersave_mode.fast_psm_idle_period =
-						min(conf->dynamic_ps_timeout *
-						    2, 255);
-				}
-			}
+		while ((wvif = wvif_iterate(wdev, wvif)) != NULL)
 			wfx_update_pm(wvif);
-		}
 		wvif = wdev_to_wvif(wdev, 0);
 	}
 

commit ad41f7196bd3eafa2e879ec7f3d387a49666f677
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Tue Dec 17 16:15:13 2019 +0000

    staging: wfx: remove redundant test while calling wfx_update_pm()
    
    Condition about wvif->state and wvif->bss_params.aid is already checked
    at beginning of wfx_update_pm().
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20191217161318.31402-34-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index ee1b15950389..91fa4d8aa37d 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -1448,8 +1448,7 @@ int wfx_config(struct ieee80211_hw *hw, u32 changed)
 						    2, 255);
 				}
 			}
-			if (wvif->state == WFX_STATE_STA && wvif->bss_params.aid)
-				wfx_update_pm(wvif);
+			wfx_update_pm(wvif);
 		}
 		wvif = wdev_to_wvif(wdev, 0);
 	}

commit 8dd5bb6631949f78c8aff1747f496265a97b1375
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Tue Dec 17 16:15:12 2019 +0000

    staging: wfx: drop useless argument from wfx_set_pm()
    
    Argument to wfx_set_pm() is always wvif->powersave_mode. So, we can
    simplify it.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20191217161318.31402-33-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index eb087b9c8097..ee1b15950389 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -326,12 +326,10 @@ void wfx_configure_filter(struct ieee80211_hw *hw,
 	}
 }
 
-static int wfx_set_pm(struct wfx_vif *wvif,
-		      const struct hif_req_set_pm_mode *arg)
+static int wfx_update_pm(struct wfx_vif *wvif)
 {
-	struct hif_req_set_pm_mode pm = *arg;
+	struct hif_req_set_pm_mode pm = wvif->powersave_mode;
 	u16 uapsd_flags;
-	int ret;
 
 	if (wvif->state != WFX_STATE_STA || !wvif->bss_params.aid)
 		return 0;
@@ -390,7 +388,7 @@ int wfx_conf_tx(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 			if (!ret && wvif->setbssparams_done &&
 			    wvif->state == WFX_STATE_STA &&
 			    old_uapsd_flags != new_uapsd_flags)
-				ret = wfx_set_pm(wvif, &wvif->powersave_mode);
+				ret = wfx_update_pm(wvif);
 		}
 	} else {
 		ret = -EINVAL;
@@ -1014,7 +1012,7 @@ static void wfx_join_finalize(struct wfx_vif *wvif,
 		hif_set_bss_params(wvif, &wvif->bss_params);
 		wvif->setbssparams_done = true;
 		wfx_set_beacon_wakeup_period_work(&wvif->set_beacon_wakeup_period_work);
-		wfx_set_pm(wvif, &wvif->powersave_mode);
+		wfx_update_pm(wvif);
 	}
 }
 
@@ -1451,7 +1449,7 @@ int wfx_config(struct ieee80211_hw *hw, u32 changed)
 				}
 			}
 			if (wvif->state == WFX_STATE_STA && wvif->bss_params.aid)
-				wfx_set_pm(wvif, &wvif->powersave_mode);
+				wfx_update_pm(wvif);
 		}
 		wvif = wdev_to_wvif(wdev, 0);
 	}
@@ -1591,7 +1589,7 @@ int wfx_add_interface(struct ieee80211_hw *hw, struct ieee80211_vif *vif)
 		else
 			hif_set_block_ack_policy(wvif, 0x00, 0x00);
 		// Combo force powersave mode. We can re-enable it now
-		wfx_set_pm(wvif, &wvif->powersave_mode);
+		wfx_update_pm(wvif);
 	}
 	return 0;
 }
@@ -1666,7 +1664,7 @@ void wfx_remove_interface(struct ieee80211_hw *hw,
 		else
 			hif_set_block_ack_policy(wvif, 0x00, 0x00);
 		// Combo force powersave mode. We can re-enable it now
-		wfx_set_pm(wvif, &wvif->powersave_mode);
+		wfx_update_pm(wvif);
 	}
 }
 

commit 97e587bd08939f8b0e315bd1be4beccaf296179d
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Tue Dec 17 16:15:11 2019 +0000

    staging: wfx: declare wfx_set_pm() static
    
    wfx_set_pm() is now only used by sta.c. It can be declared static.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20191217161318.31402-32-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index fb45aa66fc56..eb087b9c8097 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -326,6 +326,36 @@ void wfx_configure_filter(struct ieee80211_hw *hw,
 	}
 }
 
+static int wfx_set_pm(struct wfx_vif *wvif,
+		      const struct hif_req_set_pm_mode *arg)
+{
+	struct hif_req_set_pm_mode pm = *arg;
+	u16 uapsd_flags;
+	int ret;
+
+	if (wvif->state != WFX_STATE_STA || !wvif->bss_params.aid)
+		return 0;
+
+	memcpy(&uapsd_flags, &wvif->uapsd_info, sizeof(uapsd_flags));
+
+	if (uapsd_flags != 0)
+		pm.pm_mode.fast_psm = 0;
+
+	// Kernel disable PowerSave when multiple vifs are in use. In contrary,
+	// it is absolutly necessary to enable PowerSave for WF200
+	// FIXME: only if channel vif0 != channel vif1
+	if (wvif_count(wvif->wdev) > 1) {
+		pm.pm_mode.enter_psm = 1;
+		pm.pm_mode.fast_psm = 0;
+	}
+
+	if (!wait_for_completion_timeout(&wvif->set_pm_mode_complete,
+					 msecs_to_jiffies(300)))
+		dev_warn(wvif->wdev->dev,
+			 "timeout while waiting of set_pm_mode_complete\n");
+	return hif_set_pm(wvif, &pm);
+}
+
 int wfx_conf_tx(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 		   u16 queue, const struct ieee80211_tx_queue_params *params)
 {
@@ -371,33 +401,6 @@ int wfx_conf_tx(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 	return ret;
 }
 
-int wfx_set_pm(struct wfx_vif *wvif, const struct hif_req_set_pm_mode *arg)
-{
-	struct hif_req_set_pm_mode pm = *arg;
-	u16 uapsd_flags;
-
-	if (wvif->state != WFX_STATE_STA || !wvif->bss_params.aid)
-		return 0;
-
-	memcpy(&uapsd_flags, &wvif->uapsd_info, sizeof(uapsd_flags));
-
-	if (uapsd_flags != 0)
-		pm.pm_mode.fast_psm = 0;
-
-	// Kernel disable PowerSave when multiple vifs are in use. In contrary,
-	// it is absolutly necessary to enable PowerSave for WF200
-	if (wvif_count(wvif->wdev) > 1) {
-		pm.pm_mode.enter_psm = 1;
-		pm.pm_mode.fast_psm = 0;
-	}
-
-	if (!wait_for_completion_timeout(&wvif->set_pm_mode_complete,
-					 msecs_to_jiffies(300)))
-		dev_warn(wvif->wdev->dev,
-			 "timeout while waiting of set_pm_mode_complete\n");
-	return hif_set_pm(wvif, &pm);
-}
-
 int wfx_set_rts_threshold(struct ieee80211_hw *hw, u32 value)
 {
 	struct wfx_dev *wdev = hw->priv;

commit 155665d87e08814d6e47277be2e706534497c638
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Tue Dec 17 16:15:09 2019 +0000

    staging: wfx: firmware already handle powersave mode during scan
    
    When user try to launch scan while connected, it is necessary to notify
    the AP that we cannot receive data (using power save mode).
    
    Firmware already handles this automatically so the code in the driver is
    redundant and can be dropped.
    
    By edge effect, hack of scan status in wfx_set_pm() is now useless.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20191217161318.31402-31-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index 62e65493a4fe..fb45aa66fc56 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -375,7 +375,6 @@ int wfx_set_pm(struct wfx_vif *wvif, const struct hif_req_set_pm_mode *arg)
 {
 	struct hif_req_set_pm_mode pm = *arg;
 	u16 uapsd_flags;
-	int ret;
 
 	if (wvif->state != WFX_STATE_STA || !wvif->bss_params.aid)
 		return 0;
@@ -396,11 +395,7 @@ int wfx_set_pm(struct wfx_vif *wvif, const struct hif_req_set_pm_mode *arg)
 					 msecs_to_jiffies(300)))
 		dev_warn(wvif->wdev->dev,
 			 "timeout while waiting of set_pm_mode_complete\n");
-	ret = hif_set_pm(wvif, &pm);
-	// FIXME: why ?
-	if (-ETIMEDOUT == wvif->scan.status)
-		wvif->scan.status = 1;
-	return ret;
+	return hif_set_pm(wvif, &pm);
 }
 
 int wfx_set_rts_threshold(struct ieee80211_hw *hw, u32 value)

commit 536607c0c793540ee53b2242d4f676e0898f9e93
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Tue Dec 17 16:15:08 2019 +0000

    staging: wfx: simplify handling of tx_lock in wfx_do_join()
    
    In the old days, wfx_do_join() could be called from different contexts.
    Now that wfx_do_join() is called only from one place, it is cleaner to
    keep lock and unlock of data inside the function.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20191217161318.31402-30-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index 939c64f108ed..62e65493a4fe 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -644,7 +644,6 @@ static void wfx_set_mfp(struct wfx_vif *wvif,
 	hif_set_mfp(wvif, mfpc, mfpr);
 }
 
-/* MUST be called with tx_lock held!  It will be unlocked for us. */
 static void wfx_do_join(struct wfx_vif *wvif)
 {
 	const u8 *bssid;
@@ -659,6 +658,8 @@ static void wfx_do_join(struct wfx_vif *wvif)
 						      conf->basic_rates),
 	};
 
+	wfx_tx_lock_flush(wvif->wdev);
+
 	if (wvif->channel->flags & IEEE80211_CHAN_NO_IR)
 		join.probe_for_join = 0;
 
@@ -1180,10 +1181,8 @@ void wfx_bss_info_changed(struct ieee80211_hw *hw,
 	}
 	mutex_unlock(&wdev->conf_mutex);
 
-	if (do_join) {
-		wfx_tx_lock_flush(wdev);
-		wfx_do_join(wvif); /* Will unlock it for us */
-	}
+	if (do_join)
+		wfx_do_join(wvif);
 }
 
 static void wfx_ps_notify(struct wfx_vif *wvif, enum sta_notify_cmd notify_cmd,

commit 07c11c18ebb50c4f4b3fb5a40cbce212352b35bf
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Tue Dec 17 16:15:07 2019 +0000

    staging: wfx: better naming for hif_mib_set_association_mode->greenfield
    
    Current name "mixed_or_greenfield_type" does not allow to know if
    "true" means "mixed" of "greenfield". It is possible to use a better
    name and drop "enum hif_tx_mode".
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20191217161318.31402-29-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index e5c933678c47..939c64f108ed 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -996,7 +996,7 @@ static void wfx_join_finalize(struct wfx_vif *wvif,
 	association_mode.spacing = 1;
 	association_mode.short_preamble = info->use_short_preamble;
 	association_mode.basic_rate_set = cpu_to_le32(wfx_rate_mask_to_hw(wvif->wdev, info->basic_rates));
-	association_mode.mixed_or_greenfield_type = wfx_ht_greenfield(&wvif->ht_info);
+	association_mode.greenfield = wfx_ht_greenfield(&wvif->ht_info);
 	association_mode.mpdu_start_spacing = wfx_ht_ampdu_density(&wvif->ht_info);
 
 	wfx_cqm_bssloss_sm(wvif, 0, 0, 0);

commit ad636ec4f01a06a59433d126c5754127b3157197
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Tue Dec 17 16:15:05 2019 +0000

    staging: wfx: better naming for hif_req_join->short_preamble
    
    HIF_PREAMBLE_SHORT_LONG12 is never used. So it is possible to change
    "preamble_type" into a boolean and drop "enum hif_preamble".
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20191217161318.31402-28-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index 23ec7a4a926b..e5c933678c47 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -652,7 +652,7 @@ static void wfx_do_join(struct wfx_vif *wvif)
 	struct cfg80211_bss *bss = NULL;
 	struct hif_req_join join = {
 		.infrastructure_bss_mode = !conf->ibss_joined,
-		.preamble_type = conf->use_short_preamble ? HIF_PREAMBLE_SHORT : HIF_PREAMBLE_LONG,
+		.short_preamble = conf->use_short_preamble,
 		.probe_for_join = 1,
 		.atim_window = 0,
 		.basic_rate_set = wfx_rate_mask_to_hw(wvif->wdev,
@@ -843,7 +843,7 @@ static int wfx_start_ap(struct wfx_vif *wvif)
 		.channel_number = wvif->channel->hw_value,
 		.beacon_interval = conf->beacon_int,
 		.dtim_period = conf->dtim_period,
-		.preamble_type = conf->use_short_preamble ? HIF_PREAMBLE_SHORT : HIF_PREAMBLE_LONG,
+		.short_preamble = conf->use_short_preamble,
 		.basic_rate_set = wfx_rate_mask_to_hw(wvif->wdev,
 						      conf->basic_rates),
 	};
@@ -994,7 +994,7 @@ static void wfx_join_finalize(struct wfx_vif *wvif,
 	association_mode.mode = 1;
 	association_mode.rateset = 1;
 	association_mode.spacing = 1;
-	association_mode.preamble_type = info->use_short_preamble ? HIF_PREAMBLE_SHORT : HIF_PREAMBLE_LONG;
+	association_mode.short_preamble = info->use_short_preamble;
 	association_mode.basic_rate_set = cpu_to_le32(wfx_rate_mask_to_hw(wvif->wdev, info->basic_rates));
 	association_mode.mixed_or_greenfield_type = wfx_ht_greenfield(&wvif->ht_info);
 	association_mode.mpdu_start_spacing = wfx_ht_ampdu_density(&wvif->ht_info);

commit c2232d94ac67dc0a76656e8e15ae38a21d326eed
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Tue Dec 17 16:15:04 2019 +0000

    staging: wfx: improve API of hif_req_join->infrastructure_bss_mode
    
    In fact "mode" is a boolean that indicates if IBSS mode is used. This
    patch fixes the name and uses a more adapted memory representation.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20191217161318.31402-27-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index b4bb5b653e64..23ec7a4a926b 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -651,7 +651,7 @@ static void wfx_do_join(struct wfx_vif *wvif)
 	struct ieee80211_bss_conf *conf = &wvif->vif->bss_conf;
 	struct cfg80211_bss *bss = NULL;
 	struct hif_req_join join = {
-		.mode = conf->ibss_joined ? HIF_MODE_IBSS : HIF_MODE_BSS,
+		.infrastructure_bss_mode = !conf->ibss_joined,
 		.preamble_type = conf->use_short_preamble ? HIF_PREAMBLE_SHORT : HIF_PREAMBLE_LONG,
 		.probe_for_join = 1,
 		.atim_window = 0,

commit 36f7e3acaac6be7da831b9a0c31022954f79216d
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Tue Dec 17 16:14:59 2019 +0000

    staging: wfx: ensure that received hif messages are never modified
    
    There are no real reason to modify the data received from device. So,
    let's mark the arguments constant.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20191217161318.31402-23-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index 7f4eaa8e6d84..b4bb5b653e64 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -1345,7 +1345,7 @@ int wfx_ampdu_action(struct ieee80211_hw *hw,
 }
 
 void wfx_suspend_resume(struct wfx_vif *wvif,
-			struct hif_ind_suspend_resume_tx *arg)
+			const struct hif_ind_suspend_resume_tx *arg)
 {
 	if (arg->suspend_resume_flags.bc_mc_only) {
 		bool cancel_tmo = false;

commit eddd8585fb46db6fa701efc963a93477591cd736
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Tue Dec 17 16:14:56 2019 +0000

    staging: wfx: make conditions easier to read
    
    We prefer series of simple boolean conditions than computing bitmasks.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20191217161318.31402-21-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index 471dd15b227f..7f4eaa8e6d84 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -1055,9 +1055,11 @@ void wfx_bss_info_changed(struct ieee80211_hw *hw,
 		}
 	}
 
-	if (changed &
-	    (BSS_CHANGED_BEACON | BSS_CHANGED_AP_PROBE_RESP |
-	     BSS_CHANGED_BSSID | BSS_CHANGED_SSID | BSS_CHANGED_IBSS)) {
+	if (changed & BSS_CHANGED_BEACON ||
+	    changed & BSS_CHANGED_AP_PROBE_RESP ||
+	    changed & BSS_CHANGED_BSSID ||
+	    changed & BSS_CHANGED_SSID ||
+	    changed & BSS_CHANGED_IBSS) {
 		wvif->beacon_int = info->beacon_int;
 		wfx_update_beaconing(wvif);
 		wfx_upload_beacon(wvif);
@@ -1095,10 +1097,11 @@ void wfx_bss_info_changed(struct ieee80211_hw *hw,
 		if (changed & BSS_CHANGED_BSSID)
 			do_join = true;
 
-		if (changed &
-		    (BSS_CHANGED_ASSOC | BSS_CHANGED_BSSID |
-		     BSS_CHANGED_IBSS | BSS_CHANGED_BASIC_RATES |
-		     BSS_CHANGED_HT)) {
+		if (changed & BSS_CHANGED_ASSOC ||
+		    changed & BSS_CHANGED_BSSID ||
+		    changed & BSS_CHANGED_IBSS ||
+		    changed & BSS_CHANGED_BASIC_RATES ||
+		    changed & BSS_CHANGED_HT) {
 			if (info->assoc) {
 				if (wvif->state < WFX_STATE_PRE_STA) {
 					ieee80211_connection_loss(vif);
@@ -1120,9 +1123,9 @@ void wfx_bss_info_changed(struct ieee80211_hw *hw,
 	}
 
 	/* ERP Protection */
-	if (changed & (BSS_CHANGED_ASSOC |
-		       BSS_CHANGED_ERP_CTS_PROT |
-		       BSS_CHANGED_ERP_PREAMBLE)) {
+	if (changed & BSS_CHANGED_ASSOC ||
+	    changed & BSS_CHANGED_ERP_CTS_PROT ||
+	    changed & BSS_CHANGED_ERP_PREAMBLE) {
 		u32 prev_erp_info = wvif->erp_info;
 
 		if (info->use_cts_prot)
@@ -1139,10 +1142,10 @@ void wfx_bss_info_changed(struct ieee80211_hw *hw,
 			schedule_work(&wvif->set_cts_work);
 	}
 
-	if (changed & (BSS_CHANGED_ASSOC | BSS_CHANGED_ERP_SLOT))
+	if (changed & BSS_CHANGED_ASSOC || changed & BSS_CHANGED_ERP_SLOT)
 		hif_slot_time(wvif, info->use_short_slot ? 9 : 20);
 
-	if (changed & (BSS_CHANGED_ASSOC | BSS_CHANGED_CQM)) {
+	if (changed & BSS_CHANGED_ASSOC || changed & BSS_CHANGED_CQM) {
 		struct hif_mib_rcpi_rssi_threshold th = {
 			.rolling_average_count = 8,
 			.detection = 1,

commit b0ac999ebe37c931e76fbdffffd7a5b77b2d788e
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Tue Dec 17 16:14:27 2019 +0000

    staging: wfx: fix the cache of rate policies on interface reset
    
    Device and driver maintain a cache of rate policies (aka.
    tx_retry_policy in hardware API).
    
    When hif_reset() is sent to hardware, device resets its cache of rate
    policies. In order to keep driver in sync, it is necessary to do the
    same on driver.
    
    Note, when driver tries to use a rate policy that has not been defined
    on device, data is sent at 1Mbps. So, this patch should fix abnormal
    throughput observed sometime after a reset of the interface.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20191217161318.31402-2-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index 29848a202ab4..471dd15b227f 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -592,6 +592,7 @@ static void wfx_do_unjoin(struct wfx_vif *wvif)
 	wfx_tx_flush(wvif->wdev);
 	hif_keep_alive_period(wvif, 0);
 	hif_reset(wvif, false);
+	wfx_tx_policy_init(wvif);
 	hif_set_output_power(wvif, wvif->wdev->output_power * 10);
 	wvif->dtim_period = 0;
 	hif_set_macaddr(wvif, wvif->vif->addr);
@@ -880,8 +881,10 @@ static int wfx_update_beaconing(struct wfx_vif *wvif)
 		if (wvif->state != WFX_STATE_AP ||
 		    wvif->beacon_int != conf->beacon_int) {
 			wfx_tx_lock_flush(wvif->wdev);
-			if (wvif->state != WFX_STATE_PASSIVE)
+			if (wvif->state != WFX_STATE_PASSIVE) {
 				hif_reset(wvif, false);
+				wfx_tx_policy_init(wvif);
+			}
 			wvif->state = WFX_STATE_PASSIVE;
 			wfx_start_ap(wvif);
 			wfx_tx_unlock(wvif->wdev);
@@ -1567,6 +1570,7 @@ int wfx_add_interface(struct ieee80211_hw *hw, struct ieee80211_vif *vif)
 	INIT_WORK(&wvif->set_cts_work, wfx_set_cts_work);
 	INIT_WORK(&wvif->unjoin_work, wfx_unjoin_work);
 
+	INIT_WORK(&wvif->tx_policy_upload_work, wfx_tx_policy_upload_work);
 	mutex_unlock(&wdev->conf_mutex);
 
 	hif_set_macaddr(wvif, vif->addr);

commit 99879121bfbb6a815e4699aabd00ae317ca1d215
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Tue Dec 17 16:14:27 2019 +0000

    staging: wfx: fix the cache of rate policies on interface reset
    
    Device and driver maintain a cache of rate policies (aka.
    tx_retry_policy in hardware API).
    
    When hif_reset() is sent to hardware, device resets its cache of rate
    policies. In order to keep driver in sync, it is necessary to do the
    same on driver.
    
    Note, when driver tries to use a rate policy that has not been defined
    on device, data is sent at 1Mbps. So, this patch should fix abnormal
    throughput observed sometime after a reset of the interface.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20191217161318.31402-2-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index 29848a202ab4..471dd15b227f 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -592,6 +592,7 @@ static void wfx_do_unjoin(struct wfx_vif *wvif)
 	wfx_tx_flush(wvif->wdev);
 	hif_keep_alive_period(wvif, 0);
 	hif_reset(wvif, false);
+	wfx_tx_policy_init(wvif);
 	hif_set_output_power(wvif, wvif->wdev->output_power * 10);
 	wvif->dtim_period = 0;
 	hif_set_macaddr(wvif, wvif->vif->addr);
@@ -880,8 +881,10 @@ static int wfx_update_beaconing(struct wfx_vif *wvif)
 		if (wvif->state != WFX_STATE_AP ||
 		    wvif->beacon_int != conf->beacon_int) {
 			wfx_tx_lock_flush(wvif->wdev);
-			if (wvif->state != WFX_STATE_PASSIVE)
+			if (wvif->state != WFX_STATE_PASSIVE) {
 				hif_reset(wvif, false);
+				wfx_tx_policy_init(wvif);
+			}
 			wvif->state = WFX_STATE_PASSIVE;
 			wfx_start_ap(wvif);
 			wfx_tx_unlock(wvif->wdev);
@@ -1567,6 +1570,7 @@ int wfx_add_interface(struct ieee80211_hw *hw, struct ieee80211_vif *vif)
 	INIT_WORK(&wvif->set_cts_work, wfx_set_cts_work);
 	INIT_WORK(&wvif->unjoin_work, wfx_unjoin_work);
 
+	INIT_WORK(&wvif->tx_policy_upload_work, wfx_tx_policy_upload_work);
 	mutex_unlock(&wdev->conf_mutex);
 
 	hif_set_macaddr(wvif, vif->addr);

commit 8c7128c4cf4e0e6eb67bd65b4dbe619c3d297bb6
Author: Jules Irenge <jbi.octave@gmail.com>
Date:   Wed Nov 13 11:00:52 2019 +0000

    staging: align to fix warnings of line over 80 characters
    
    Align to fix multiple warnings of line over 80 characters.
    Issue detected by checkpatch tool.
    
    Signed-off-by: Jules Irenge <jbi.octave@gmail.com>
    Link: https://lore.kernel.org/r/20191113110052.14855-1-jbi.octave@gmail.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index 1cdfa88ffee7..29848a202ab4 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -100,7 +100,8 @@ void wfx_cqm_bssloss_sm(struct wfx_vif *wvif, int init, int good, int bad)
 		skb = ieee80211_nullfunc_get(wvif->wdev->hw, wvif->vif, false);
 		if (!skb)
 			goto end;
-		memset(IEEE80211_SKB_CB(skb), 0, sizeof(*IEEE80211_SKB_CB(skb)));
+		memset(IEEE80211_SKB_CB(skb), 0,
+		       sizeof(*IEEE80211_SKB_CB(skb)));
 		IEEE80211_SKB_CB(skb)->control.vif = wvif->vif;
 		IEEE80211_SKB_CB(skb)->driver_rates[0].idx = 0;
 		IEEE80211_SKB_CB(skb)->driver_rates[0].count = 1;
@@ -177,8 +178,10 @@ static int wfx_set_mcast_filter(struct wfx_vif *wvif,
 	for (i = 0; i < fp->num_addresses; i++) {
 		filter_addr_val.condition_idx = i;
 		filter_addr_val.address_type = HIF_MAC_ADDR_A1;
-		ether_addr_copy(filter_addr_val.mac_address, fp->address_list[i]);
-		ret = hif_set_mac_addr_condition(wvif, &filter_addr_val);
+		ether_addr_copy(filter_addr_val.mac_address,
+				fp->address_list[i]);
+		ret = hif_set_mac_addr_condition(wvif,
+						 &filter_addr_val);
 		if (ret)
 			return ret;
 		config.mac_cond |= 1 << i;
@@ -243,7 +246,8 @@ void wfx_update_filtering(struct wfx_vif *wvif)
 		bf_ctrl.bcn_count = 1;
 		n_filter_ies = 0;
 	} else if (!is_sta) {
-		bf_ctrl.enable = HIF_BEACON_FILTER_ENABLE | HIF_BEACON_FILTER_AUTO_ERP;
+		bf_ctrl.enable = HIF_BEACON_FILTER_ENABLE |
+				 HIF_BEACON_FILTER_AUTO_ERP;
 		bf_ctrl.bcn_count = 0;
 		n_filter_ies = 2;
 	} else {
@@ -254,9 +258,11 @@ void wfx_update_filtering(struct wfx_vif *wvif)
 
 	ret = hif_set_rx_filter(wvif, filter_bssid, fwd_probe_req);
 	if (!ret)
-		ret = hif_set_beacon_filter_table(wvif, n_filter_ies, filter_ies);
+		ret = hif_set_beacon_filter_table(wvif, n_filter_ies,
+						  filter_ies);
 	if (!ret)
-		ret = hif_beacon_filter_control(wvif, bf_ctrl.enable, bf_ctrl.bcn_count);
+		ret = hif_beacon_filter_control(wvif, bf_ctrl.enable,
+						bf_ctrl.bcn_count);
 	if (!ret)
 		ret = wfx_set_mcast_filter(wvif, &wvif->mcast_filter);
 	if (ret)
@@ -265,12 +271,14 @@ void wfx_update_filtering(struct wfx_vif *wvif)
 
 static void wfx_update_filtering_work(struct work_struct *work)
 {
-	struct wfx_vif *wvif = container_of(work, struct wfx_vif, update_filtering_work);
+	struct wfx_vif *wvif = container_of(work, struct wfx_vif,
+					    update_filtering_work);
 
 	wfx_update_filtering(wvif);
 }
 
-u64 wfx_prepare_multicast(struct ieee80211_hw *hw, struct netdev_hw_addr_list *mc_list)
+u64 wfx_prepare_multicast(struct ieee80211_hw *hw,
+			  struct netdev_hw_addr_list *mc_list)
 {
 	int i;
 	struct netdev_hw_addr *ha;
@@ -280,12 +288,14 @@ u64 wfx_prepare_multicast(struct ieee80211_hw *hw, struct netdev_hw_addr_list *m
 
 	while ((wvif = wvif_iterate(wdev, wvif)) != NULL) {
 		memset(&wvif->mcast_filter, 0x00, sizeof(wvif->mcast_filter));
-		if (!count || count > ARRAY_SIZE(wvif->mcast_filter.address_list))
+		if (!count ||
+		    count > ARRAY_SIZE(wvif->mcast_filter.address_list))
 			continue;
 
 		i = 0;
 		netdev_hw_addr_list_for_each(ha, mc_list) {
-			ether_addr_copy(wvif->mcast_filter.address_list[i], ha->addr);
+			ether_addr_copy(wvif->mcast_filter.address_list[i],
+					ha->addr);
 			i++;
 		}
 		wvif->mcast_filter.enable = true;
@@ -307,7 +317,8 @@ void wfx_configure_filter(struct ieee80211_hw *hw,
 
 	while ((wvif = wvif_iterate(wdev, wvif)) != NULL) {
 		down(&wvif->scan.lock);
-		wvif->filter_bssid = (*total_flags & (FIF_OTHER_BSS | FIF_PROBE_REQ)) ? 0 : 1;
+		wvif->filter_bssid = (*total_flags &
+				      (FIF_OTHER_BSS | FIF_PROBE_REQ)) ? 0 : 1;
 		wvif->disable_beacon_filter = !(*total_flags & FIF_PROBE_REQ);
 		wfx_fwd_probe_req(wvif, true);
 		wfx_update_filtering(wvif);
@@ -381,8 +392,10 @@ int wfx_set_pm(struct wfx_vif *wvif, const struct hif_req_set_pm_mode *arg)
 		pm.pm_mode.fast_psm = 0;
 	}
 
-	if (!wait_for_completion_timeout(&wvif->set_pm_mode_complete, msecs_to_jiffies(300)))
-		dev_warn(wvif->wdev->dev, "timeout while waiting of set_pm_mode_complete\n");
+	if (!wait_for_completion_timeout(&wvif->set_pm_mode_complete,
+					 msecs_to_jiffies(300)))
+		dev_warn(wvif->wdev->dev,
+			 "timeout while waiting of set_pm_mode_complete\n");
 	ret = hif_set_pm(wvif, &pm);
 	// FIXME: why ?
 	if (-ETIMEDOUT == wvif->scan.status)
@@ -442,7 +455,8 @@ void wfx_flush(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 		wvif = (struct wfx_vif *) vif->drv_priv;
 		if (wvif->vif->type == NL80211_IFTYPE_MONITOR)
 			drop = true;
-		if (wvif->vif->type == NL80211_IFTYPE_AP && !wvif->enable_beacon)
+		if (wvif->vif->type == NL80211_IFTYPE_AP &&
+		    !wvif->enable_beacon)
 			drop = true;
 	}
 
@@ -494,7 +508,8 @@ static void wfx_event_handler_work(struct work_struct *work)
 				 */
 				wvif->delayed_link_loss = 1;
 				/* Also start a watchdog. */
-				schedule_delayed_work(&wvif->bss_loss_work, 5 * HZ);
+				schedule_delayed_work(&wvif->bss_loss_work,
+						      5 * HZ);
 			}
 			break;
 		case HIF_EVENT_IND_BSSREGAINED:
@@ -502,13 +517,17 @@ static void wfx_event_handler_work(struct work_struct *work)
 			cancel_work_sync(&wvif->unjoin_work);
 			break;
 		case HIF_EVENT_IND_RCPI_RSSI:
-			wfx_event_report_rssi(wvif, event->evt.event_data.rcpi_rssi);
+			wfx_event_report_rssi(wvif,
+					      event->evt.event_data.rcpi_rssi);
 			break;
 		case HIF_EVENT_IND_PS_MODE_ERROR:
-			dev_warn(wvif->wdev->dev, "error while processing power save request\n");
+			dev_warn(wvif->wdev->dev,
+				 "error while processing power save request\n");
 			break;
 		default:
-			dev_warn(wvif->wdev->dev, "unhandled event indication: %.2x\n", event->evt.event_id);
+			dev_warn(wvif->wdev->dev,
+				 "unhandled event indication: %.2x\n",
+				 event->evt.event_id);
 			break;
 		}
 	}
@@ -517,14 +536,16 @@ static void wfx_event_handler_work(struct work_struct *work)
 
 static void wfx_bss_loss_work(struct work_struct *work)
 {
-	struct wfx_vif *wvif = container_of(work, struct wfx_vif, bss_loss_work.work);
+	struct wfx_vif *wvif = container_of(work, struct wfx_vif,
+					    bss_loss_work.work);
 
 	ieee80211_connection_loss(wvif->vif);
 }
 
 static void wfx_bss_params_work(struct work_struct *work)
 {
-	struct wfx_vif *wvif = container_of(work, struct wfx_vif, bss_params_work);
+	struct wfx_vif *wvif = container_of(work, struct wfx_vif,
+					    bss_params_work);
 
 	mutex_lock(&wvif->wdev->conf_mutex);
 	wvif->bss_params.bss_flags.lost_count_only = 1;
@@ -535,9 +556,11 @@ static void wfx_bss_params_work(struct work_struct *work)
 
 static void wfx_set_beacon_wakeup_period_work(struct work_struct *work)
 {
-	struct wfx_vif *wvif = container_of(work, struct wfx_vif, set_beacon_wakeup_period_work);
+	struct wfx_vif *wvif = container_of(work, struct wfx_vif,
+					    set_beacon_wakeup_period_work);
 
-	hif_set_beacon_wakeup_period(wvif, wvif->dtim_period, wvif->dtim_period);
+	hif_set_beacon_wakeup_period(wvif, wvif->dtim_period,
+				     wvif->dtim_period);
 }
 
 static void wfx_do_unjoin(struct wfx_vif *wvif)
@@ -546,7 +569,8 @@ static void wfx_do_unjoin(struct wfx_vif *wvif)
 
 	if (atomic_read(&wvif->scan.in_progress)) {
 		if (wvif->delayed_unjoin)
-			dev_dbg(wvif->wdev->dev, "delayed unjoin is already scheduled\n");
+			dev_dbg(wvif->wdev->dev,
+				"delayed unjoin is already scheduled\n");
 		else
 			wvif->delayed_unjoin = true;
 		goto done;
@@ -588,7 +612,8 @@ static void wfx_do_unjoin(struct wfx_vif *wvif)
 	mutex_unlock(&wvif->wdev->conf_mutex);
 }
 
-static void wfx_set_mfp(struct wfx_vif *wvif, struct cfg80211_bss *bss)
+static void wfx_set_mfp(struct wfx_vif *wvif,
+			struct cfg80211_bss *bss)
 {
 	const int pairwise_cipher_suite_count_offset = 8 / sizeof(u16);
 	const int pairwise_cipher_suite_size = 4 / sizeof(u16);
@@ -629,7 +654,8 @@ static void wfx_do_join(struct wfx_vif *wvif)
 		.preamble_type = conf->use_short_preamble ? HIF_PREAMBLE_SHORT : HIF_PREAMBLE_LONG,
 		.probe_for_join = 1,
 		.atim_window = 0,
-		.basic_rate_set = wfx_rate_mask_to_hw(wvif->wdev, conf->basic_rates),
+		.basic_rate_set = wfx_rate_mask_to_hw(wvif->wdev,
+						      conf->basic_rates),
 	};
 
 	if (wvif->channel->flags & IEEE80211_CHAN_NO_IR)
@@ -640,7 +666,8 @@ static void wfx_do_join(struct wfx_vif *wvif)
 
 	bssid = wvif->vif->bss_conf.bssid;
 
-	bss = cfg80211_get_bss(wvif->wdev->hw->wiphy, wvif->channel, bssid, NULL, 0,
+	bss = cfg80211_get_bss(wvif->wdev->hw->wiphy, wvif->channel,
+			       bssid, NULL, 0,
 			       IEEE80211_BSS_TYPE_ANY, IEEE80211_PRIVACY_ANY);
 
 	if (!bss && !conf->ibss_joined) {
@@ -816,7 +843,8 @@ static int wfx_start_ap(struct wfx_vif *wvif)
 		.beacon_interval = conf->beacon_int,
 		.dtim_period = conf->dtim_period,
 		.preamble_type = conf->use_short_preamble ? HIF_PREAMBLE_SHORT : HIF_PREAMBLE_LONG,
-		.basic_rate_set = wfx_rate_mask_to_hw(wvif->wdev, conf->basic_rates),
+		.basic_rate_set = wfx_rate_mask_to_hw(wvif->wdev,
+						      conf->basic_rates),
 	};
 
 	memset(start.ssid, 0, sizeof(start.ssid));
@@ -928,7 +956,8 @@ static int wfx_ht_ampdu_density(const struct wfx_ht_info *ht_info)
 	return ht_info->ht_cap.ampdu_density;
 }
 
-static void wfx_join_finalize(struct wfx_vif *wvif, struct ieee80211_bss_conf *info)
+static void wfx_join_finalize(struct wfx_vif *wvif,
+			      struct ieee80211_bss_conf *info)
 {
 	struct ieee80211_sta *sta = NULL;
 	struct hif_mib_set_association_mode association_mode = { };
@@ -952,7 +981,8 @@ static void wfx_join_finalize(struct wfx_vif *wvif, struct ieee80211_bss_conf *i
 	rcu_read_unlock();
 
 	/* Non Greenfield stations present */
-	if (wvif->ht_info.operation_mode & IEEE80211_HT_OP_MODE_NON_GF_STA_PRSNT)
+	if (wvif->ht_info.operation_mode &
+	    IEEE80211_HT_OP_MODE_NON_GF_STA_PRSNT)
 		hif_dual_cts_protection(wvif, true);
 	else
 		hif_dual_cts_protection(wvif, false);
@@ -1011,7 +1041,9 @@ void wfx_bss_info_changed(struct ieee80211_hw *hw,
 			filter.condition_idx = i;
 			if (i < nb_arp_addr) {
 				// Caution: type of arp_addr_list[i] is __be32
-				memcpy(filter.ipv4_address, &info->arp_addr_list[i], sizeof(filter.ipv4_address));
+				memcpy(filter.ipv4_address,
+				       &info->arp_addr_list[i],
+				       sizeof(filter.ipv4_address));
 				filter.arp_enable = HIF_ARP_NS_FILTERING_ENABLE;
 			} else {
 				filter.arp_enable = HIF_ARP_NS_FILTERING_DISABLE;
@@ -1028,7 +1060,8 @@ void wfx_bss_info_changed(struct ieee80211_hw *hw,
 		wfx_upload_beacon(wvif);
 	}
 
-	if (changed & BSS_CHANGED_BEACON_ENABLED && wvif->state != WFX_STATE_IBSS) {
+	if (changed & BSS_CHANGED_BEACON_ENABLED &&
+	    wvif->state != WFX_STATE_IBSS) {
 		if (wvif->enable_beacon != info->enable_beacon) {
 			hif_beacon_transmit(wvif, info->enable_beacon);
 			wvif->enable_beacon = info->enable_beacon;
@@ -1061,7 +1094,8 @@ void wfx_bss_info_changed(struct ieee80211_hw *hw,
 
 		if (changed &
 		    (BSS_CHANGED_ASSOC | BSS_CHANGED_BSSID |
-		     BSS_CHANGED_IBSS | BSS_CHANGED_BASIC_RATES | BSS_CHANGED_HT)) {
+		     BSS_CHANGED_IBSS | BSS_CHANGED_BASIC_RATES |
+		     BSS_CHANGED_HT)) {
 			if (info->assoc) {
 				if (wvif->state < WFX_STATE_PRE_STA) {
 					ieee80211_connection_loss(vif);
@@ -1077,7 +1111,8 @@ void wfx_bss_info_changed(struct ieee80211_hw *hw,
 			if (info->assoc || info->ibss_joined)
 				wfx_join_finalize(wvif, info);
 			else
-				memset(&wvif->bss_params, 0, sizeof(wvif->bss_params));
+				memset(&wvif->bss_params, 0,
+				       sizeof(wvif->bss_params));
 		}
 	}
 
@@ -1132,7 +1167,8 @@ void wfx_bss_info_changed(struct ieee80211_hw *hw,
 		hif_set_rcpi_rssi_threshold(wvif, &th);
 	}
 
-	if (changed & BSS_CHANGED_TXPOWER && info->txpower != wdev->output_power) {
+	if (changed & BSS_CHANGED_TXPOWER &&
+	    info->txpower != wdev->output_power) {
 		wdev->output_power = info->txpower;
 		hif_set_output_power(wvif, wdev->output_power * 10);
 	}
@@ -1247,7 +1283,8 @@ int wfx_set_tim(struct ieee80211_hw *hw, struct ieee80211_sta *sta, bool set)
 
 static void wfx_mcast_start_work(struct work_struct *work)
 {
-	struct wfx_vif *wvif = container_of(work, struct wfx_vif, mcast_start_work);
+	struct wfx_vif *wvif = container_of(work, struct wfx_vif,
+					    mcast_start_work);
 	long tmo = wvif->dtim_period * TU_TO_JIFFIES(wvif->beacon_int + 20);
 
 	cancel_work_sync(&wvif->mcast_stop_work);
@@ -1262,7 +1299,8 @@ static void wfx_mcast_start_work(struct work_struct *work)
 
 static void wfx_mcast_stop_work(struct work_struct *work)
 {
-	struct wfx_vif *wvif = container_of(work, struct wfx_vif, mcast_stop_work);
+	struct wfx_vif *wvif = container_of(work, struct wfx_vif,
+					    mcast_stop_work);
 
 	if (wvif->aid0_bit_set) {
 		del_timer_sync(&wvif->mcast_timeout);
@@ -1310,7 +1348,8 @@ void wfx_suspend_resume(struct wfx_vif *wvif,
 		if (!arg->suspend_resume_flags.resume)
 			wvif->mcast_tx = false;
 		else
-			wvif->mcast_tx = wvif->aid0_bit_set && wvif->mcast_buffered;
+			wvif->mcast_tx = wvif->aid0_bit_set &&
+					 wvif->mcast_buffered;
 		if (wvif->mcast_tx) {
 			cancel_tmo = true;
 			wfx_bh_request_tx(wvif->wdev);
@@ -1358,7 +1397,8 @@ int wfx_assign_vif_chanctx(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 	return 0;
 }
 
-void wfx_unassign_vif_chanctx(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
+void wfx_unassign_vif_chanctx(struct ieee80211_hw *hw,
+			      struct ieee80211_vif *vif,
 			      struct ieee80211_chanctx_conf *conf)
 {
 	struct wfx_vif *wvif = (struct wfx_vif *) vif->drv_priv;
@@ -1392,14 +1432,19 @@ int wfx_config(struct ieee80211_hw *hw, u32 changed)
 	if (changed & IEEE80211_CONF_CHANGE_PS) {
 		wvif = NULL;
 		while ((wvif = wvif_iterate(wdev, wvif)) != NULL) {
-			memset(&wvif->powersave_mode, 0, sizeof(wvif->powersave_mode));
+			memset(&wvif->powersave_mode, 0,
+			       sizeof(wvif->powersave_mode));
 			if (conf->flags & IEEE80211_CONF_PS) {
 				wvif->powersave_mode.pm_mode.enter_psm = 1;
 				if (conf->dynamic_ps_timeout > 0) {
 					wvif->powersave_mode.pm_mode.fast_psm = 1;
-					// Firmware does not support more than 128ms
+					/*
+					 * Firmware does not support more than
+					 * 128ms
+					 */
 					wvif->powersave_mode.fast_psm_idle_period =
-						min(conf->dynamic_ps_timeout * 2, 255);
+						min(conf->dynamic_ps_timeout *
+						    2, 255);
 				}
 			}
 			if (wvif->state == WFX_STATE_STA && wvif->bss_params.aid)
@@ -1515,7 +1560,8 @@ int wfx_add_interface(struct ieee80211_hw *hw, struct ieee80211_vif *vif)
 
 	init_completion(&wvif->set_pm_mode_complete);
 	complete(&wvif->set_pm_mode_complete);
-	INIT_WORK(&wvif->set_beacon_wakeup_period_work, wfx_set_beacon_wakeup_period_work);
+	INIT_WORK(&wvif->set_beacon_wakeup_period_work,
+		  wfx_set_beacon_wakeup_period_work);
 	INIT_WORK(&wvif->update_filtering_work, wfx_update_filtering_work);
 	INIT_WORK(&wvif->bss_params_work, wfx_bss_params_work);
 	INIT_WORK(&wvif->set_cts_work, wfx_set_cts_work);
@@ -1525,7 +1571,8 @@ int wfx_add_interface(struct ieee80211_hw *hw, struct ieee80211_vif *vif)
 
 	hif_set_macaddr(wvif, vif->addr);
 	for (i = 0; i < IEEE80211_NUM_ACS; i++) {
-		memcpy(&wvif->edca.params[i], &default_edca_params[i], sizeof(default_edca_params[i]));
+		memcpy(&wvif->edca.params[i], &default_edca_params[i],
+		       sizeof(default_edca_params[i]));
 		wvif->edca.uapsd_enable[i] = false;
 		hif_set_edca_queue_params(wvif, &wvif->edca.params[i]);
 	}

commit 5cd382b2693358be99b9ae1c524854f5715b5dc2
Author: Jules Irenge <jbi.octave@gmail.com>
Date:   Mon Nov 11 13:30:53 2019 +0000

    staging: wfx: replace uintXX_t to uXX and intXX_t to sXX
    
    Replace uint8_t to u8, uint16_t to u16, uint32_t to u32
    int8_t to s8,int16_t to s16 and int32_t to s32
    As per recommendation of checkpatch tool.
    
    Signed-off-by: Jules Irenge <jbi.octave@gmail.com>
    Link: https://lore.kernel.org/r/20191111133055.214410-1-jbi.octave@gmail.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index 2ab5ba9742ad..1cdfa88ffee7 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -453,7 +453,7 @@ void wfx_flush(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 
 /* WSM callbacks */
 
-static void wfx_event_report_rssi(struct wfx_vif *wvif, uint8_t raw_rcpi_rssi)
+static void wfx_event_report_rssi(struct wfx_vif *wvif, u8 raw_rcpi_rssi)
 {
 	/* RSSI: signed Q8.0, RCPI: unsigned Q7.1
 	 * RSSI = RCPI / 2 - 110
@@ -590,10 +590,10 @@ static void wfx_do_unjoin(struct wfx_vif *wvif)
 
 static void wfx_set_mfp(struct wfx_vif *wvif, struct cfg80211_bss *bss)
 {
-	const int pairwise_cipher_suite_count_offset = 8 / sizeof(uint16_t);
-	const int pairwise_cipher_suite_size = 4 / sizeof(uint16_t);
-	const int akm_suite_size = 4 / sizeof(uint16_t);
-	const uint16_t *ptr = NULL;
+	const int pairwise_cipher_suite_count_offset = 8 / sizeof(u16);
+	const int pairwise_cipher_suite_size = 4 / sizeof(u16);
+	const int akm_suite_size = 4 / sizeof(u16);
+	const u16 *ptr = NULL;
 	bool mfpc = false;
 	bool mfpr = false;
 
@@ -603,7 +603,8 @@ static void wfx_set_mfp(struct wfx_vif *wvif, struct cfg80211_bss *bss)
 
 	rcu_read_lock();
 	if (bss)
-		ptr = (const uint16_t *) ieee80211_bss_get_ie(bss, WLAN_EID_RSN);
+		ptr = (const u16 *) ieee80211_bss_get_ie(bss,
+							      WLAN_EID_RSN);
 
 	if (ptr) {
 		ptr += pairwise_cipher_suite_count_offset;

commit 78ce93f3e80bf8dff320a6d084c9933e81aa4a3f
Author: Nachammai Karuppiah <nachukannan@gmail.com>
Date:   Tue Nov 5 01:21:31 2019 -0800

    staging: wfx: Remove local variable used only in return statement.
    
    Remove unnecessary local variable that is used in return statement and
    return the expression directly. Issue found using coccinelle.
    
    Signed-off-by: Nachammai Karuppiah <nachukannan@gmail.com>
    Link: https://lore.kernel.org/r/1572945691-109992-1-git-send-email-nachukannan@gmail.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index 70a00b84ac5f..2ab5ba9742ad 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -114,8 +114,6 @@ void wfx_cqm_bssloss_sm(struct wfx_vif *wvif, int init, int good, int bad)
 static int wfx_set_uapsd_param(struct wfx_vif *wvif,
 			   const struct wfx_edca_params *arg)
 {
-	int ret;
-
 	/* Here's the mapping AC [queue, bit]
 	 *  VO [0,3], VI [1, 2], BE [2, 1], BK [3, 0]
 	 */
@@ -148,8 +146,7 @@ static int wfx_set_uapsd_param(struct wfx_vif *wvif,
 	wvif->uapsd_info.max_auto_trigger_interval = 0;
 	wvif->uapsd_info.auto_trigger_step = 0;
 
-	ret = hif_set_uapsd_info(wvif, &wvif->uapsd_info);
-	return ret;
+	return hif_set_uapsd_info(wvif, &wvif->uapsd_info);
 }
 
 int wfx_fwd_probe_req(struct wfx_vif *wvif, bool enable)

commit 168c7d76425d053ca6a311e450ac3627cffff5a7
Author: Jules Irenge <jbi.octave@gmail.com>
Date:   Tue Nov 5 01:03:52 2019 +0000

    staging: wfx: replace 1 by true
    
    Replace 1 by true when it is stored in a boolean variable.
    Recommended by coccinelle tool.
    
    Signed-off-by: Jules Irenge <jbi.octave@gmail.com>
    Link: https://lore.kernel.org/r/20191105010352.222479-3-jbi.octave@gmail.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index 93f3739b5f3a..70a00b84ac5f 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -291,7 +291,7 @@ u64 wfx_prepare_multicast(struct ieee80211_hw *hw, struct netdev_hw_addr_list *m
 			ether_addr_copy(wvif->mcast_filter.address_list[i], ha->addr);
 			i++;
 		}
-		wvif->mcast_filter.enable = 1;
+		wvif->mcast_filter.enable = true;
 		wvif->mcast_filter.num_addresses = count;
 	}
 

commit 1878c5b91430d38a0beefd0dc5cb6035913ebc7f
Author: Christophe JAILLET <christophe.jaillet@wanadoo.fr>
Date:   Sat Nov 2 16:59:45 2019 +0100

    staging: wfx: Fix a memory leak in 'wfx_upload_beacon'
    
    The current code is a no-op, because all it can do is 'dev_kfree_skb(NULL)'
    Remove the test before 'dev_kfree_skb()'
    
    Signed-off-by: Christophe JAILLET <christophe.jaillet@wanadoo.fr>
    Link: https://lore.kernel.org/r/20191102155945.20205-1-christophe.jaillet@wanadoo.fr
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index 688586e823c0..93f3739b5f3a 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -906,8 +906,7 @@ static int wfx_upload_beacon(struct wfx_vif *wvif)
 	wfx_fwd_probe_req(wvif, false);
 
 done:
-	if (!skb)
-		dev_kfree_skb(skb);
+	dev_kfree_skb(skb);
 	return ret;
 }
 

commit 8fd1fe824f20692a09279fabe952cf65bedffeee
Author: zhengbin <zhengbin13@huawei.com>
Date:   Wed Oct 9 21:50:30 2019 +0800

    staging: wfx: Make some functions static in sta.c
    
    Fix sparse warnings:
    
    drivers/staging/wfx/sta.c:269:6: warning: symbol 'wfx_update_filtering_work' was not declared. Should it be static?
    drivers/staging/wfx/sta.c:475:6: warning: symbol 'wfx_event_handler_work' was not declared. Should it be static?
    drivers/staging/wfx/sta.c:521:6: warning: symbol 'wfx_bss_loss_work' was not declared. Should it be static?
    drivers/staging/wfx/sta.c:528:6: warning: symbol 'wfx_bss_params_work' was not declared. Should it be static?
    drivers/staging/wfx/sta.c:539:6: warning: symbol 'wfx_set_beacon_wakeup_period_work' was not declared. Should it be static?
    drivers/staging/wfx/sta.c:732:6: warning: symbol 'wfx_unjoin_work' was not declared. Should it be static?
    drivers/staging/wfx/sta.c:794:6: warning: symbol 'wfx_set_cts_work' was not declared. Should it be static?
    drivers/staging/wfx/sta.c:1234:6: warning: symbol 'wfx_set_tim_work' was not declared. Should it be static?
    
    Reported-by: Hulk Robot <hulkci@huawei.com>
    Signed-off-by: zhengbin <zhengbin13@huawei.com>
    Reviewed-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/1570629030-29888-4-git-send-email-zhengbin13@huawei.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index 3c715cc88ab2..688586e823c0 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -266,7 +266,7 @@ void wfx_update_filtering(struct wfx_vif *wvif)
 		dev_err(wvif->wdev->dev, "update filtering failed: %d\n", ret);
 }
 
-void wfx_update_filtering_work(struct work_struct *work)
+static void wfx_update_filtering_work(struct work_struct *work)
 {
 	struct wfx_vif *wvif = container_of(work, struct wfx_vif, update_filtering_work);
 
@@ -472,7 +472,7 @@ static void wfx_event_report_rssi(struct wfx_vif *wvif, uint8_t raw_rcpi_rssi)
 	ieee80211_cqm_rssi_notify(wvif->vif, cqm_evt, rcpi_rssi, GFP_KERNEL);
 }
 
-void wfx_event_handler_work(struct work_struct *work)
+static void wfx_event_handler_work(struct work_struct *work)
 {
 	struct wfx_vif *wvif =
 		container_of(work, struct wfx_vif, event_handler_work);
@@ -518,14 +518,14 @@ void wfx_event_handler_work(struct work_struct *work)
 	__wfx_free_event_queue(&list);
 }
 
-void wfx_bss_loss_work(struct work_struct *work)
+static void wfx_bss_loss_work(struct work_struct *work)
 {
 	struct wfx_vif *wvif = container_of(work, struct wfx_vif, bss_loss_work.work);
 
 	ieee80211_connection_loss(wvif->vif);
 }
 
-void wfx_bss_params_work(struct work_struct *work)
+static void wfx_bss_params_work(struct work_struct *work)
 {
 	struct wfx_vif *wvif = container_of(work, struct wfx_vif, bss_params_work);
 
@@ -536,7 +536,7 @@ void wfx_bss_params_work(struct work_struct *work)
 	mutex_unlock(&wvif->wdev->conf_mutex);
 }
 
-void wfx_set_beacon_wakeup_period_work(struct work_struct *work)
+static void wfx_set_beacon_wakeup_period_work(struct work_struct *work)
 {
 	struct wfx_vif *wvif = container_of(work, struct wfx_vif, set_beacon_wakeup_period_work);
 
@@ -729,7 +729,7 @@ static void wfx_do_join(struct wfx_vif *wvif)
 		cfg80211_put_bss(wvif->wdev->hw->wiphy, bss);
 }
 
-void wfx_unjoin_work(struct work_struct *work)
+static void wfx_unjoin_work(struct work_struct *work)
 {
 	struct wfx_vif *wvif = container_of(work, struct wfx_vif, unjoin_work);
 
@@ -791,7 +791,7 @@ int wfx_sta_remove(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 	return 0;
 }
 
-void wfx_set_cts_work(struct work_struct *work)
+static void wfx_set_cts_work(struct work_struct *work)
 {
 	struct wfx_vif *wvif = container_of(work, struct wfx_vif, set_cts_work);
 	u8 erp_ie[3] = { WLAN_EID_ERP_INFO, 1, 0 };
@@ -1231,7 +1231,7 @@ static int wfx_set_tim_impl(struct wfx_vif *wvif, bool aid0_bit_set)
 	return 0;
 }
 
-void wfx_set_tim_work(struct work_struct *work)
+static void wfx_set_tim_work(struct work_struct *work)
 {
 	struct wfx_vif *wvif = container_of(work, struct wfx_vif, set_tim_work);
 

commit fcd6c0f9a12369ae6d500d747e668ed98ef5edd6
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Tue Oct 8 09:43:01 2019 +0000

    staging: wfx: avoid namespace contamination
    
    tx_policy_init() was already defined in driver cw1200. So, compilation
    failed when wfx and cw1200 were both built-in.
    
    In order to keep a coherent naming scheme, this patch prefixes all
    "tx_policy_*" functions with "wfx_".
    
    Fixes: 9bca45f3d692 ("staging: wfx: allow to send 802.11 frames")
    Reported-by: kbuild test robot <lkp@intel.com>
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20191008094232.10014-8-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index 733b93a8f830..3c715cc88ab2 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -1534,7 +1534,7 @@ int wfx_add_interface(struct ieee80211_hw *hw, struct ieee80211_vif *vif)
 	}
 	wfx_set_uapsd_param(wvif, &wvif->edca);
 
-	tx_policy_init(wvif);
+	wfx_tx_policy_init(wvif);
 	wvif = NULL;
 	while ((wvif = wvif_iterate(wdev, wvif)) != NULL) {
 		// Combo mode does not support Block Acks. We can re-enable them

commit b5be2aa3b3ac153f056f93406c520dc74a1cebbe
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Tue Oct 8 09:43:01 2019 +0000

    staging: wfx: drop calls to BUG_ON()
    
    Most of calls to BUG_ON() could replaced by WARN().
    
    By the way, this patch also try to favor WARN() (that include a comment
    about the problem) instead of WARN_ON().
    
    Reported-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20191008094232.10014-7-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index 12198b8f3685..733b93a8f830 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -1454,6 +1454,7 @@ int wfx_add_interface(struct ieee80211_hw *hw, struct ieee80211_vif *vif)
 		},
 	};
 
+	BUILD_BUG_ON(ARRAY_SIZE(default_edca_params) != ARRAY_SIZE(wvif->edca.params));
 	if (wfx_api_older_than(wdev, 2, 0)) {
 		default_edca_params[IEEE80211_AC_BE].queue_id = HIF_QUEUE_ID_BACKGROUND;
 		default_edca_params[IEEE80211_AC_BK].queue_id = HIF_QUEUE_ID_BESTEFFORT;
@@ -1526,7 +1527,6 @@ int wfx_add_interface(struct ieee80211_hw *hw, struct ieee80211_vif *vif)
 	mutex_unlock(&wdev->conf_mutex);
 
 	hif_set_macaddr(wvif, vif->addr);
-	BUG_ON(ARRAY_SIZE(default_edca_params) != ARRAY_SIZE(wvif->edca.params));
 	for (i = 0; i < IEEE80211_NUM_ACS; i++) {
 		memcpy(&wvif->edca.params[i], &default_edca_params[i], sizeof(default_edca_params[i]));
 		wvif->edca.uapsd_enable[i] = false;

commit c54f9f0e8c81192b17e2ae2eb7af6a037fd250a5
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Tue Oct 8 09:42:58 2019 +0000

    staging: wfx: simplify memory allocation in wfx_update_filtering()
    
    Original code did not handle case where kmalloc failed. By the way, it
    is more convenient to allocate and build HIF message in
    hif_set_beacon_filter_table() instead of to ask to caller function to
    build it.
    
    Fixes: 40115bbc40e2 ("staging: wfx: implement the rest of mac80211 API")
    Reported-by: kbuild test robot <lkp@intel.com>
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20191008094232.10014-2-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index 2855d14a709c..12198b8f3685 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -217,14 +217,13 @@ void wfx_update_filtering(struct wfx_vif *wvif)
 	bool filter_bssid = wvif->filter_bssid;
 	bool fwd_probe_req = wvif->fwd_probe_req;
 	struct hif_mib_bcn_filter_enable bf_ctrl;
-	struct hif_mib_bcn_filter_table *bf_tbl;
-	struct hif_ie_table_entry ie_tbl[] = {
+	struct hif_ie_table_entry filter_ies[] = {
 		{
 			.ie_id        = WLAN_EID_VENDOR_SPECIFIC,
 			.has_changed  = 1,
 			.no_longer    = 1,
 			.has_appeared = 1,
-			.oui         = { 0x50, 0x6F, 0x9A},
+			.oui          = { 0x50, 0x6F, 0x9A },
 		}, {
 			.ie_id        = WLAN_EID_HT_OPERATION,
 			.has_changed  = 1,
@@ -237,36 +236,34 @@ void wfx_update_filtering(struct wfx_vif *wvif)
 			.has_appeared = 1,
 		}
 	};
+	int n_filter_ies;
 
 	if (wvif->state == WFX_STATE_PASSIVE)
 		return;
 
-	bf_tbl = kmalloc(sizeof(struct hif_mib_bcn_filter_table) + sizeof(ie_tbl), GFP_KERNEL);
-	memcpy(bf_tbl->ie_table, ie_tbl, sizeof(ie_tbl));
 	if (wvif->disable_beacon_filter) {
 		bf_ctrl.enable = 0;
 		bf_ctrl.bcn_count = 1;
-		bf_tbl->num_of_info_elmts = 0;
+		n_filter_ies = 0;
 	} else if (!is_sta) {
 		bf_ctrl.enable = HIF_BEACON_FILTER_ENABLE | HIF_BEACON_FILTER_AUTO_ERP;
 		bf_ctrl.bcn_count = 0;
-		bf_tbl->num_of_info_elmts = 2;
+		n_filter_ies = 2;
 	} else {
 		bf_ctrl.enable = HIF_BEACON_FILTER_ENABLE;
 		bf_ctrl.bcn_count = 0;
-		bf_tbl->num_of_info_elmts = 3;
+		n_filter_ies = 3;
 	}
 
 	ret = hif_set_rx_filter(wvif, filter_bssid, fwd_probe_req);
 	if (!ret)
-		ret = hif_set_beacon_filter_table(wvif, bf_tbl);
+		ret = hif_set_beacon_filter_table(wvif, n_filter_ies, filter_ies);
 	if (!ret)
 		ret = hif_beacon_filter_control(wvif, bf_ctrl.enable, bf_ctrl.bcn_count);
 	if (!ret)
 		ret = wfx_set_mcast_filter(wvif, &wvif->mcast_filter);
 	if (ret)
 		dev_err(wvif->wdev->dev, "update filtering failed: %d\n", ret);
-	kfree(bf_tbl);
 }
 
 void wfx_update_filtering_work(struct work_struct *work)

commit 40115bbc40e2fd2de0e01ef2a28e0d09a1b5d0d1
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Thu Sep 19 14:25:48 2019 +0000

    staging: wfx: implement the rest of mac80211 API
    
    Finish to fill struct ieee80211_ops with necessary callbacks. Driver is
    now ready to be registered to mac80211.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20190919142527.31797-21-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index 2e709b8a3bf4..2855d14a709c 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -9,11 +9,148 @@
 
 #include "sta.h"
 #include "wfx.h"
+#include "fwio.h"
+#include "bh.h"
 #include "key.h"
 #include "scan.h"
+#include "debug.h"
+#include "hif_tx.h"
 #include "hif_tx_mib.h"
 
 #define TXOP_UNIT 32
+#define HIF_MAX_ARP_IP_ADDRTABLE_ENTRIES 2
+
+static u32 wfx_rate_mask_to_hw(struct wfx_dev *wdev, u32 rates)
+{
+	int i;
+	u32 ret = 0;
+	// WFx only support 2GHz
+	struct ieee80211_supported_band *sband = wdev->hw->wiphy->bands[NL80211_BAND_2GHZ];
+
+	for (i = 0; i < sband->n_bitrates; i++) {
+		if (rates & BIT(i)) {
+			if (i >= sband->n_bitrates)
+				dev_warn(wdev->dev, "unsupported basic rate\n");
+			else
+				ret |= BIT(sband->bitrates[i].hw_value);
+		}
+	}
+	return ret;
+}
+
+static void __wfx_free_event_queue(struct list_head *list)
+{
+	struct wfx_hif_event *event, *tmp;
+
+	list_for_each_entry_safe(event, tmp, list, link) {
+		list_del(&event->link);
+		kfree(event);
+	}
+}
+
+static void wfx_free_event_queue(struct wfx_vif *wvif)
+{
+	LIST_HEAD(list);
+
+	spin_lock(&wvif->event_queue_lock);
+	list_splice_init(&wvif->event_queue, &list);
+	spin_unlock(&wvif->event_queue_lock);
+
+	__wfx_free_event_queue(&list);
+}
+
+void wfx_cqm_bssloss_sm(struct wfx_vif *wvif, int init, int good, int bad)
+{
+	int tx = 0;
+
+	mutex_lock(&wvif->bss_loss_lock);
+	wvif->delayed_link_loss = 0;
+	cancel_work_sync(&wvif->bss_params_work);
+
+	/* If we have a pending unjoin */
+	if (wvif->delayed_unjoin)
+		goto end;
+
+	if (init) {
+		schedule_delayed_work(&wvif->bss_loss_work, HZ);
+		wvif->bss_loss_state = 0;
+
+		if (!atomic_read(&wvif->wdev->tx_lock))
+			tx = 1;
+	} else if (good) {
+		cancel_delayed_work_sync(&wvif->bss_loss_work);
+		wvif->bss_loss_state = 0;
+		schedule_work(&wvif->bss_params_work);
+	} else if (bad) {
+		/* FIXME Should we just keep going until we time out? */
+		if (wvif->bss_loss_state < 3)
+			tx = 1;
+	} else {
+		cancel_delayed_work_sync(&wvif->bss_loss_work);
+		wvif->bss_loss_state = 0;
+	}
+
+	/* Spit out a NULL packet to our AP if necessary */
+	// FIXME: call ieee80211_beacon_loss/ieee80211_connection_loss instead
+	if (tx) {
+		struct sk_buff *skb;
+
+		wvif->bss_loss_state++;
+
+		skb = ieee80211_nullfunc_get(wvif->wdev->hw, wvif->vif, false);
+		if (!skb)
+			goto end;
+		memset(IEEE80211_SKB_CB(skb), 0, sizeof(*IEEE80211_SKB_CB(skb)));
+		IEEE80211_SKB_CB(skb)->control.vif = wvif->vif;
+		IEEE80211_SKB_CB(skb)->driver_rates[0].idx = 0;
+		IEEE80211_SKB_CB(skb)->driver_rates[0].count = 1;
+		IEEE80211_SKB_CB(skb)->driver_rates[1].idx = -1;
+		wfx_tx(wvif->wdev->hw, NULL, skb);
+	}
+end:
+	mutex_unlock(&wvif->bss_loss_lock);
+}
+
+static int wfx_set_uapsd_param(struct wfx_vif *wvif,
+			   const struct wfx_edca_params *arg)
+{
+	int ret;
+
+	/* Here's the mapping AC [queue, bit]
+	 *  VO [0,3], VI [1, 2], BE [2, 1], BK [3, 0]
+	 */
+
+	if (arg->uapsd_enable[IEEE80211_AC_VO])
+		wvif->uapsd_info.trig_voice = 1;
+	else
+		wvif->uapsd_info.trig_voice = 0;
+
+	if (arg->uapsd_enable[IEEE80211_AC_VI])
+		wvif->uapsd_info.trig_video = 1;
+	else
+		wvif->uapsd_info.trig_video = 0;
+
+	if (arg->uapsd_enable[IEEE80211_AC_BE])
+		wvif->uapsd_info.trig_be = 1;
+	else
+		wvif->uapsd_info.trig_be = 0;
+
+	if (arg->uapsd_enable[IEEE80211_AC_BK])
+		wvif->uapsd_info.trig_bckgrnd = 1;
+	else
+		wvif->uapsd_info.trig_bckgrnd = 0;
+
+	/* Currently pseudo U-APSD operation is not supported, so setting
+	 * MinAutoTriggerInterval, MaxAutoTriggerInterval and
+	 * AutoTriggerStep to 0
+	 */
+	wvif->uapsd_info.min_auto_trigger_interval = 0;
+	wvif->uapsd_info.max_auto_trigger_interval = 0;
+	wvif->uapsd_info.auto_trigger_step = 0;
+
+	ret = hif_set_uapsd_info(wvif, &wvif->uapsd_info);
+	return ret;
+}
 
 int wfx_fwd_probe_req(struct wfx_vif *wvif, bool enable)
 {
@@ -22,6 +159,1044 @@ int wfx_fwd_probe_req(struct wfx_vif *wvif, bool enable)
 				 wvif->fwd_probe_req);
 }
 
+static int wfx_set_mcast_filter(struct wfx_vif *wvif,
+				    struct wfx_grp_addr_table *fp)
+{
+	int i, ret;
+	struct hif_mib_config_data_filter config = { };
+	struct hif_mib_set_data_filtering filter_data = { };
+	struct hif_mib_mac_addr_data_frame_condition filter_addr_val = { };
+	struct hif_mib_uc_mc_bc_data_frame_condition filter_addr_type = { };
+
+	// Temporary workaround for filters
+	return hif_set_data_filtering(wvif, &filter_data);
+
+	if (!fp->enable) {
+		filter_data.enable = 0;
+		return hif_set_data_filtering(wvif, &filter_data);
+	}
+
+	// A1 Address match on list
+	for (i = 0; i < fp->num_addresses; i++) {
+		filter_addr_val.condition_idx = i;
+		filter_addr_val.address_type = HIF_MAC_ADDR_A1;
+		ether_addr_copy(filter_addr_val.mac_address, fp->address_list[i]);
+		ret = hif_set_mac_addr_condition(wvif, &filter_addr_val);
+		if (ret)
+			return ret;
+		config.mac_cond |= 1 << i;
+	}
+
+	// Accept unicast and broadcast
+	filter_addr_type.condition_idx = 0;
+	filter_addr_type.param.bits.type_unicast = 1;
+	filter_addr_type.param.bits.type_broadcast = 1;
+	ret = hif_set_uc_mc_bc_condition(wvif, &filter_addr_type);
+	if (ret)
+		return ret;
+
+	config.uc_mc_bc_cond = 1;
+	config.filter_idx = 0; // TODO #define MULTICAST_FILTERING 0
+	config.enable = 1;
+	ret = hif_set_config_data_filter(wvif, &config);
+	if (ret)
+		return ret;
+
+	// discard all data frames except match filter
+	filter_data.enable = 1;
+	filter_data.default_filter = 1; // discard all
+	ret = hif_set_data_filtering(wvif, &filter_data);
+
+	return ret;
+}
+
+void wfx_update_filtering(struct wfx_vif *wvif)
+{
+	int ret;
+	bool is_sta = wvif->vif && NL80211_IFTYPE_STATION == wvif->vif->type;
+	bool filter_bssid = wvif->filter_bssid;
+	bool fwd_probe_req = wvif->fwd_probe_req;
+	struct hif_mib_bcn_filter_enable bf_ctrl;
+	struct hif_mib_bcn_filter_table *bf_tbl;
+	struct hif_ie_table_entry ie_tbl[] = {
+		{
+			.ie_id        = WLAN_EID_VENDOR_SPECIFIC,
+			.has_changed  = 1,
+			.no_longer    = 1,
+			.has_appeared = 1,
+			.oui         = { 0x50, 0x6F, 0x9A},
+		}, {
+			.ie_id        = WLAN_EID_HT_OPERATION,
+			.has_changed  = 1,
+			.no_longer    = 1,
+			.has_appeared = 1,
+		}, {
+			.ie_id        = WLAN_EID_ERP_INFO,
+			.has_changed  = 1,
+			.no_longer    = 1,
+			.has_appeared = 1,
+		}
+	};
+
+	if (wvif->state == WFX_STATE_PASSIVE)
+		return;
+
+	bf_tbl = kmalloc(sizeof(struct hif_mib_bcn_filter_table) + sizeof(ie_tbl), GFP_KERNEL);
+	memcpy(bf_tbl->ie_table, ie_tbl, sizeof(ie_tbl));
+	if (wvif->disable_beacon_filter) {
+		bf_ctrl.enable = 0;
+		bf_ctrl.bcn_count = 1;
+		bf_tbl->num_of_info_elmts = 0;
+	} else if (!is_sta) {
+		bf_ctrl.enable = HIF_BEACON_FILTER_ENABLE | HIF_BEACON_FILTER_AUTO_ERP;
+		bf_ctrl.bcn_count = 0;
+		bf_tbl->num_of_info_elmts = 2;
+	} else {
+		bf_ctrl.enable = HIF_BEACON_FILTER_ENABLE;
+		bf_ctrl.bcn_count = 0;
+		bf_tbl->num_of_info_elmts = 3;
+	}
+
+	ret = hif_set_rx_filter(wvif, filter_bssid, fwd_probe_req);
+	if (!ret)
+		ret = hif_set_beacon_filter_table(wvif, bf_tbl);
+	if (!ret)
+		ret = hif_beacon_filter_control(wvif, bf_ctrl.enable, bf_ctrl.bcn_count);
+	if (!ret)
+		ret = wfx_set_mcast_filter(wvif, &wvif->mcast_filter);
+	if (ret)
+		dev_err(wvif->wdev->dev, "update filtering failed: %d\n", ret);
+	kfree(bf_tbl);
+}
+
+void wfx_update_filtering_work(struct work_struct *work)
+{
+	struct wfx_vif *wvif = container_of(work, struct wfx_vif, update_filtering_work);
+
+	wfx_update_filtering(wvif);
+}
+
+u64 wfx_prepare_multicast(struct ieee80211_hw *hw, struct netdev_hw_addr_list *mc_list)
+{
+	int i;
+	struct netdev_hw_addr *ha;
+	struct wfx_vif *wvif = NULL;
+	struct wfx_dev *wdev = hw->priv;
+	int count = netdev_hw_addr_list_count(mc_list);
+
+	while ((wvif = wvif_iterate(wdev, wvif)) != NULL) {
+		memset(&wvif->mcast_filter, 0x00, sizeof(wvif->mcast_filter));
+		if (!count || count > ARRAY_SIZE(wvif->mcast_filter.address_list))
+			continue;
+
+		i = 0;
+		netdev_hw_addr_list_for_each(ha, mc_list) {
+			ether_addr_copy(wvif->mcast_filter.address_list[i], ha->addr);
+			i++;
+		}
+		wvif->mcast_filter.enable = 1;
+		wvif->mcast_filter.num_addresses = count;
+	}
+
+	return 0;
+}
+
+void wfx_configure_filter(struct ieee80211_hw *hw,
+			     unsigned int changed_flags,
+			     unsigned int *total_flags,
+			     u64 unused)
+{
+	struct wfx_vif *wvif = NULL;
+	struct wfx_dev *wdev = hw->priv;
+
+	*total_flags &= FIF_OTHER_BSS | FIF_FCSFAIL | FIF_PROBE_REQ;
+
+	while ((wvif = wvif_iterate(wdev, wvif)) != NULL) {
+		down(&wvif->scan.lock);
+		wvif->filter_bssid = (*total_flags & (FIF_OTHER_BSS | FIF_PROBE_REQ)) ? 0 : 1;
+		wvif->disable_beacon_filter = !(*total_flags & FIF_PROBE_REQ);
+		wfx_fwd_probe_req(wvif, true);
+		wfx_update_filtering(wvif);
+		up(&wvif->scan.lock);
+	}
+}
+
+int wfx_conf_tx(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
+		   u16 queue, const struct ieee80211_tx_queue_params *params)
+{
+	struct wfx_dev *wdev = hw->priv;
+	struct wfx_vif *wvif = (struct wfx_vif *) vif->drv_priv;
+	int ret = 0;
+	/* To prevent re-applying PM request OID again and again*/
+	u16 old_uapsd_flags, new_uapsd_flags;
+	struct hif_req_edca_queue_params *edca;
+
+	mutex_lock(&wdev->conf_mutex);
+
+	if (queue < hw->queues) {
+		old_uapsd_flags = *((u16 *) &wvif->uapsd_info);
+		edca = &wvif->edca.params[queue];
+
+		wvif->edca.uapsd_enable[queue] = params->uapsd;
+		edca->aifsn = params->aifs;
+		edca->cw_min = params->cw_min;
+		edca->cw_max = params->cw_max;
+		edca->tx_op_limit = params->txop * TXOP_UNIT;
+		edca->allowed_medium_time = 0;
+		ret = hif_set_edca_queue_params(wvif, edca);
+		if (ret) {
+			ret = -EINVAL;
+			goto out;
+		}
+
+		if (wvif->vif->type == NL80211_IFTYPE_STATION) {
+			ret = wfx_set_uapsd_param(wvif, &wvif->edca);
+			new_uapsd_flags = *((u16 *) &wvif->uapsd_info);
+			if (!ret && wvif->setbssparams_done &&
+			    wvif->state == WFX_STATE_STA &&
+			    old_uapsd_flags != new_uapsd_flags)
+				ret = wfx_set_pm(wvif, &wvif->powersave_mode);
+		}
+	} else {
+		ret = -EINVAL;
+	}
+
+out:
+	mutex_unlock(&wdev->conf_mutex);
+	return ret;
+}
+
+int wfx_set_pm(struct wfx_vif *wvif, const struct hif_req_set_pm_mode *arg)
+{
+	struct hif_req_set_pm_mode pm = *arg;
+	u16 uapsd_flags;
+	int ret;
+
+	if (wvif->state != WFX_STATE_STA || !wvif->bss_params.aid)
+		return 0;
+
+	memcpy(&uapsd_flags, &wvif->uapsd_info, sizeof(uapsd_flags));
+
+	if (uapsd_flags != 0)
+		pm.pm_mode.fast_psm = 0;
+
+	// Kernel disable PowerSave when multiple vifs are in use. In contrary,
+	// it is absolutly necessary to enable PowerSave for WF200
+	if (wvif_count(wvif->wdev) > 1) {
+		pm.pm_mode.enter_psm = 1;
+		pm.pm_mode.fast_psm = 0;
+	}
+
+	if (!wait_for_completion_timeout(&wvif->set_pm_mode_complete, msecs_to_jiffies(300)))
+		dev_warn(wvif->wdev->dev, "timeout while waiting of set_pm_mode_complete\n");
+	ret = hif_set_pm(wvif, &pm);
+	// FIXME: why ?
+	if (-ETIMEDOUT == wvif->scan.status)
+		wvif->scan.status = 1;
+	return ret;
+}
+
+int wfx_set_rts_threshold(struct ieee80211_hw *hw, u32 value)
+{
+	struct wfx_dev *wdev = hw->priv;
+	struct wfx_vif *wvif = NULL;
+
+	while ((wvif = wvif_iterate(wdev, wvif)) != NULL)
+		hif_rts_threshold(wvif, value);
+	return 0;
+}
+
+/* If successful, LOCKS the TX queue! */
+static int __wfx_flush(struct wfx_dev *wdev, bool drop)
+{
+	int ret;
+
+	for (;;) {
+		if (drop) {
+			wfx_tx_queues_clear(wdev);
+		} else {
+			ret = wait_event_timeout(
+				wdev->tx_queue_stats.wait_link_id_empty,
+				wfx_tx_queues_is_empty(wdev),
+				2 * HZ);
+		}
+
+		if (!drop && ret <= 0) {
+			ret = -ETIMEDOUT;
+			break;
+		}
+		ret = 0;
+
+		wfx_tx_lock_flush(wdev);
+		if (!wfx_tx_queues_is_empty(wdev)) {
+			/* Highly unlikely: WSM requeued frames. */
+			wfx_tx_unlock(wdev);
+			continue;
+		}
+		break;
+	}
+	return ret;
+}
+
+void wfx_flush(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
+		  u32 queues, bool drop)
+{
+	struct wfx_dev *wdev = hw->priv;
+	struct wfx_vif *wvif;
+
+	if (vif) {
+		wvif = (struct wfx_vif *) vif->drv_priv;
+		if (wvif->vif->type == NL80211_IFTYPE_MONITOR)
+			drop = true;
+		if (wvif->vif->type == NL80211_IFTYPE_AP && !wvif->enable_beacon)
+			drop = true;
+	}
+
+	// FIXME: only flush requested vif
+	if (!__wfx_flush(wdev, drop))
+		wfx_tx_unlock(wdev);
+}
+
+/* WSM callbacks */
+
+static void wfx_event_report_rssi(struct wfx_vif *wvif, uint8_t raw_rcpi_rssi)
+{
+	/* RSSI: signed Q8.0, RCPI: unsigned Q7.1
+	 * RSSI = RCPI / 2 - 110
+	 */
+	int rcpi_rssi;
+	int cqm_evt;
+
+	rcpi_rssi = raw_rcpi_rssi / 2 - 110;
+	if (rcpi_rssi <= wvif->cqm_rssi_thold)
+		cqm_evt = NL80211_CQM_RSSI_THRESHOLD_EVENT_LOW;
+	else
+		cqm_evt = NL80211_CQM_RSSI_THRESHOLD_EVENT_HIGH;
+	ieee80211_cqm_rssi_notify(wvif->vif, cqm_evt, rcpi_rssi, GFP_KERNEL);
+}
+
+void wfx_event_handler_work(struct work_struct *work)
+{
+	struct wfx_vif *wvif =
+		container_of(work, struct wfx_vif, event_handler_work);
+	struct wfx_hif_event *event;
+
+	LIST_HEAD(list);
+
+	spin_lock(&wvif->event_queue_lock);
+	list_splice_init(&wvif->event_queue, &list);
+	spin_unlock(&wvif->event_queue_lock);
+
+	list_for_each_entry(event, &list, link) {
+		switch (event->evt.event_id) {
+		case HIF_EVENT_IND_BSSLOST:
+			cancel_work_sync(&wvif->unjoin_work);
+			if (!down_trylock(&wvif->scan.lock)) {
+				wfx_cqm_bssloss_sm(wvif, 1, 0, 0);
+				up(&wvif->scan.lock);
+			} else {
+				/* Scan is in progress. Delay reporting.
+				 * Scan complete will trigger bss_loss_work
+				 */
+				wvif->delayed_link_loss = 1;
+				/* Also start a watchdog. */
+				schedule_delayed_work(&wvif->bss_loss_work, 5 * HZ);
+			}
+			break;
+		case HIF_EVENT_IND_BSSREGAINED:
+			wfx_cqm_bssloss_sm(wvif, 0, 0, 0);
+			cancel_work_sync(&wvif->unjoin_work);
+			break;
+		case HIF_EVENT_IND_RCPI_RSSI:
+			wfx_event_report_rssi(wvif, event->evt.event_data.rcpi_rssi);
+			break;
+		case HIF_EVENT_IND_PS_MODE_ERROR:
+			dev_warn(wvif->wdev->dev, "error while processing power save request\n");
+			break;
+		default:
+			dev_warn(wvif->wdev->dev, "unhandled event indication: %.2x\n", event->evt.event_id);
+			break;
+		}
+	}
+	__wfx_free_event_queue(&list);
+}
+
+void wfx_bss_loss_work(struct work_struct *work)
+{
+	struct wfx_vif *wvif = container_of(work, struct wfx_vif, bss_loss_work.work);
+
+	ieee80211_connection_loss(wvif->vif);
+}
+
+void wfx_bss_params_work(struct work_struct *work)
+{
+	struct wfx_vif *wvif = container_of(work, struct wfx_vif, bss_params_work);
+
+	mutex_lock(&wvif->wdev->conf_mutex);
+	wvif->bss_params.bss_flags.lost_count_only = 1;
+	hif_set_bss_params(wvif, &wvif->bss_params);
+	wvif->bss_params.bss_flags.lost_count_only = 0;
+	mutex_unlock(&wvif->wdev->conf_mutex);
+}
+
+void wfx_set_beacon_wakeup_period_work(struct work_struct *work)
+{
+	struct wfx_vif *wvif = container_of(work, struct wfx_vif, set_beacon_wakeup_period_work);
+
+	hif_set_beacon_wakeup_period(wvif, wvif->dtim_period, wvif->dtim_period);
+}
+
+static void wfx_do_unjoin(struct wfx_vif *wvif)
+{
+	mutex_lock(&wvif->wdev->conf_mutex);
+
+	if (atomic_read(&wvif->scan.in_progress)) {
+		if (wvif->delayed_unjoin)
+			dev_dbg(wvif->wdev->dev, "delayed unjoin is already scheduled\n");
+		else
+			wvif->delayed_unjoin = true;
+		goto done;
+	}
+
+	wvif->delayed_link_loss = false;
+
+	if (!wvif->state)
+		goto done;
+
+	if (wvif->state == WFX_STATE_AP)
+		goto done;
+
+	cancel_work_sync(&wvif->update_filtering_work);
+	cancel_work_sync(&wvif->set_beacon_wakeup_period_work);
+	wvif->state = WFX_STATE_PASSIVE;
+
+	/* Unjoin is a reset. */
+	wfx_tx_flush(wvif->wdev);
+	hif_keep_alive_period(wvif, 0);
+	hif_reset(wvif, false);
+	hif_set_output_power(wvif, wvif->wdev->output_power * 10);
+	wvif->dtim_period = 0;
+	hif_set_macaddr(wvif, wvif->vif->addr);
+	wfx_free_event_queue(wvif);
+	cancel_work_sync(&wvif->event_handler_work);
+	wfx_cqm_bssloss_sm(wvif, 0, 0, 0);
+
+	/* Disable Block ACKs */
+	hif_set_block_ack_policy(wvif, 0, 0);
+
+	wvif->disable_beacon_filter = false;
+	wfx_update_filtering(wvif);
+	memset(&wvif->bss_params, 0, sizeof(wvif->bss_params));
+	wvif->setbssparams_done = false;
+	memset(&wvif->ht_info, 0, sizeof(wvif->ht_info));
+
+done:
+	mutex_unlock(&wvif->wdev->conf_mutex);
+}
+
+static void wfx_set_mfp(struct wfx_vif *wvif, struct cfg80211_bss *bss)
+{
+	const int pairwise_cipher_suite_count_offset = 8 / sizeof(uint16_t);
+	const int pairwise_cipher_suite_size = 4 / sizeof(uint16_t);
+	const int akm_suite_size = 4 / sizeof(uint16_t);
+	const uint16_t *ptr = NULL;
+	bool mfpc = false;
+	bool mfpr = false;
+
+	/* 802.11w protected mgmt frames */
+
+	/* retrieve MFPC and MFPR flags from beacon or PBRSP */
+
+	rcu_read_lock();
+	if (bss)
+		ptr = (const uint16_t *) ieee80211_bss_get_ie(bss, WLAN_EID_RSN);
+
+	if (ptr) {
+		ptr += pairwise_cipher_suite_count_offset;
+		ptr += 1 + pairwise_cipher_suite_size * *ptr;
+		ptr += 1 + akm_suite_size * *ptr;
+		mfpr = *ptr & BIT(6);
+		mfpc = *ptr & BIT(7);
+	}
+	rcu_read_unlock();
+
+	hif_set_mfp(wvif, mfpc, mfpr);
+}
+
+/* MUST be called with tx_lock held!  It will be unlocked for us. */
+static void wfx_do_join(struct wfx_vif *wvif)
+{
+	const u8 *bssid;
+	struct ieee80211_bss_conf *conf = &wvif->vif->bss_conf;
+	struct cfg80211_bss *bss = NULL;
+	struct hif_req_join join = {
+		.mode = conf->ibss_joined ? HIF_MODE_IBSS : HIF_MODE_BSS,
+		.preamble_type = conf->use_short_preamble ? HIF_PREAMBLE_SHORT : HIF_PREAMBLE_LONG,
+		.probe_for_join = 1,
+		.atim_window = 0,
+		.basic_rate_set = wfx_rate_mask_to_hw(wvif->wdev, conf->basic_rates),
+	};
+
+	if (wvif->channel->flags & IEEE80211_CHAN_NO_IR)
+		join.probe_for_join = 0;
+
+	if (wvif->state)
+		wfx_do_unjoin(wvif);
+
+	bssid = wvif->vif->bss_conf.bssid;
+
+	bss = cfg80211_get_bss(wvif->wdev->hw->wiphy, wvif->channel, bssid, NULL, 0,
+			       IEEE80211_BSS_TYPE_ANY, IEEE80211_PRIVACY_ANY);
+
+	if (!bss && !conf->ibss_joined) {
+		wfx_tx_unlock(wvif->wdev);
+		return;
+	}
+
+	mutex_lock(&wvif->wdev->conf_mutex);
+
+	/* Under the conf lock: check scan status and
+	 * bail out if it is in progress.
+	 */
+	if (atomic_read(&wvif->scan.in_progress)) {
+		wfx_tx_unlock(wvif->wdev);
+		goto done_put;
+	}
+
+	/* Sanity check basic rates */
+	if (!join.basic_rate_set)
+		join.basic_rate_set = 7;
+
+	/* Sanity check beacon interval */
+	if (!wvif->beacon_int)
+		wvif->beacon_int = 1;
+
+	join.beacon_interval = wvif->beacon_int;
+
+	// DTIM period will be set on first Beacon
+	wvif->dtim_period = 0;
+
+	join.channel_number = wvif->channel->hw_value;
+	memcpy(join.bssid, bssid, sizeof(join.bssid));
+
+	if (!conf->ibss_joined) {
+		const u8 *ssidie;
+
+		rcu_read_lock();
+		ssidie = ieee80211_bss_get_ie(bss, WLAN_EID_SSID);
+		if (ssidie) {
+			join.ssid_length = ssidie[1];
+			memcpy(join.ssid, &ssidie[2], join.ssid_length);
+		}
+		rcu_read_unlock();
+	}
+
+	wfx_tx_flush(wvif->wdev);
+
+	if (wvif_count(wvif->wdev) <= 1)
+		hif_set_block_ack_policy(wvif, 0xFF, 0xFF);
+
+	wfx_set_mfp(wvif, bss);
+
+	/* Perform actual join */
+	wvif->wdev->tx_burst_idx = -1;
+	if (hif_join(wvif, &join)) {
+		ieee80211_connection_loss(wvif->vif);
+		wvif->join_complete_status = -1;
+		/* Tx lock still held, unjoin will clear it. */
+		if (!schedule_work(&wvif->unjoin_work))
+			wfx_tx_unlock(wvif->wdev);
+	} else {
+		wvif->join_complete_status = 0;
+		if (wvif->vif->type == NL80211_IFTYPE_ADHOC)
+			wvif->state = WFX_STATE_IBSS;
+		else
+			wvif->state = WFX_STATE_PRE_STA;
+		wfx_tx_unlock(wvif->wdev);
+
+		/* Upload keys */
+		wfx_upload_keys(wvif);
+
+		/* Due to beacon filtering it is possible that the
+		 * AP's beacon is not known for the mac80211 stack.
+		 * Disable filtering temporary to make sure the stack
+		 * receives at least one
+		 */
+		wvif->disable_beacon_filter = true;
+	}
+	wfx_update_filtering(wvif);
+
+done_put:
+	mutex_unlock(&wvif->wdev->conf_mutex);
+	if (bss)
+		cfg80211_put_bss(wvif->wdev->hw->wiphy, bss);
+}
+
+void wfx_unjoin_work(struct work_struct *work)
+{
+	struct wfx_vif *wvif = container_of(work, struct wfx_vif, unjoin_work);
+
+	wfx_do_unjoin(wvif);
+	wfx_tx_unlock(wvif->wdev);
+}
+
+int wfx_sta_add(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
+		struct ieee80211_sta *sta)
+{
+	struct wfx_dev *wdev = hw->priv;
+	struct wfx_vif *wvif = (struct wfx_vif *) vif->drv_priv;
+	struct wfx_sta_priv *sta_priv = (struct wfx_sta_priv *) &sta->drv_priv;
+	struct wfx_link_entry *entry;
+	struct sk_buff *skb;
+
+	if (wvif->vif->type != NL80211_IFTYPE_AP)
+		return 0;
+
+	sta_priv->vif_id = wvif->id;
+	sta_priv->link_id = wfx_find_link_id(wvif, sta->addr);
+	if (!sta_priv->link_id) {
+		dev_warn(wdev->dev, "mo more link-id available\n");
+		return -ENOENT;
+	}
+
+	entry = &wvif->link_id_db[sta_priv->link_id - 1];
+	spin_lock_bh(&wvif->ps_state_lock);
+	if ((sta->uapsd_queues & IEEE80211_WMM_IE_STA_QOSINFO_AC_MASK) ==
+					IEEE80211_WMM_IE_STA_QOSINFO_AC_MASK)
+		wvif->sta_asleep_mask |= BIT(sta_priv->link_id);
+	entry->status = WFX_LINK_HARD;
+	while ((skb = skb_dequeue(&entry->rx_queue)))
+		ieee80211_rx_irqsafe(wdev->hw, skb);
+	spin_unlock_bh(&wvif->ps_state_lock);
+	return 0;
+}
+
+int wfx_sta_remove(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
+		   struct ieee80211_sta *sta)
+{
+	struct wfx_dev *wdev = hw->priv;
+	struct wfx_vif *wvif = (struct wfx_vif *) vif->drv_priv;
+	struct wfx_sta_priv *sta_priv = (struct wfx_sta_priv *) &sta->drv_priv;
+	struct wfx_link_entry *entry;
+
+	if (wvif->vif->type != NL80211_IFTYPE_AP || !sta_priv->link_id)
+		return 0;
+
+	entry = &wvif->link_id_db[sta_priv->link_id - 1];
+	spin_lock_bh(&wvif->ps_state_lock);
+	entry->status = WFX_LINK_RESERVE;
+	entry->timestamp = jiffies;
+	wfx_tx_lock(wdev);
+	if (!schedule_work(&wvif->link_id_work))
+		wfx_tx_unlock(wdev);
+	spin_unlock_bh(&wvif->ps_state_lock);
+	flush_work(&wvif->link_id_work);
+	return 0;
+}
+
+void wfx_set_cts_work(struct work_struct *work)
+{
+	struct wfx_vif *wvif = container_of(work, struct wfx_vif, set_cts_work);
+	u8 erp_ie[3] = { WLAN_EID_ERP_INFO, 1, 0 };
+	struct hif_ie_flags target_frame = {
+		.beacon = 1,
+	};
+
+	mutex_lock(&wvif->wdev->conf_mutex);
+	erp_ie[2] = wvif->erp_info;
+	mutex_unlock(&wvif->wdev->conf_mutex);
+
+	hif_erp_use_protection(wvif, erp_ie[2] & WLAN_ERP_USE_PROTECTION);
+
+	if (wvif->vif->type != NL80211_IFTYPE_STATION)
+		hif_update_ie(wvif, &target_frame, erp_ie, sizeof(erp_ie));
+}
+
+static int wfx_start_ap(struct wfx_vif *wvif)
+{
+	int ret;
+	struct ieee80211_bss_conf *conf = &wvif->vif->bss_conf;
+	struct hif_req_start start = {
+		.channel_number = wvif->channel->hw_value,
+		.beacon_interval = conf->beacon_int,
+		.dtim_period = conf->dtim_period,
+		.preamble_type = conf->use_short_preamble ? HIF_PREAMBLE_SHORT : HIF_PREAMBLE_LONG,
+		.basic_rate_set = wfx_rate_mask_to_hw(wvif->wdev, conf->basic_rates),
+	};
+
+	memset(start.ssid, 0, sizeof(start.ssid));
+	if (!conf->hidden_ssid) {
+		start.ssid_length = conf->ssid_len;
+		memcpy(start.ssid, conf->ssid, start.ssid_length);
+	}
+
+	wvif->beacon_int = conf->beacon_int;
+	wvif->dtim_period = conf->dtim_period;
+
+	memset(&wvif->link_id_db, 0, sizeof(wvif->link_id_db));
+
+	wvif->wdev->tx_burst_idx = -1;
+	ret = hif_start(wvif, &start);
+	if (!ret)
+		ret = wfx_upload_keys(wvif);
+	if (!ret) {
+		if (wvif_count(wvif->wdev) <= 1)
+			hif_set_block_ack_policy(wvif, 0xFF, 0xFF);
+		wvif->state = WFX_STATE_AP;
+		wfx_update_filtering(wvif);
+	}
+	return ret;
+}
+
+static int wfx_update_beaconing(struct wfx_vif *wvif)
+{
+	struct ieee80211_bss_conf *conf = &wvif->vif->bss_conf;
+
+	if (wvif->vif->type == NL80211_IFTYPE_AP) {
+		/* TODO: check if changed channel, band */
+		if (wvif->state != WFX_STATE_AP ||
+		    wvif->beacon_int != conf->beacon_int) {
+			wfx_tx_lock_flush(wvif->wdev);
+			if (wvif->state != WFX_STATE_PASSIVE)
+				hif_reset(wvif, false);
+			wvif->state = WFX_STATE_PASSIVE;
+			wfx_start_ap(wvif);
+			wfx_tx_unlock(wvif->wdev);
+		} else {
+		}
+	}
+	return 0;
+}
+
+static int wfx_upload_beacon(struct wfx_vif *wvif)
+{
+	int ret = 0;
+	struct sk_buff *skb = NULL;
+	struct ieee80211_mgmt *mgmt;
+	struct hif_mib_template_frame *p;
+
+	if (wvif->vif->type == NL80211_IFTYPE_STATION ||
+	    wvif->vif->type == NL80211_IFTYPE_MONITOR ||
+	    wvif->vif->type == NL80211_IFTYPE_UNSPECIFIED)
+		goto done;
+
+	skb = ieee80211_beacon_get(wvif->wdev->hw, wvif->vif);
+
+	if (!skb)
+		return -ENOMEM;
+
+	p = (struct hif_mib_template_frame *) skb_push(skb, 4);
+	p->frame_type = HIF_TMPLT_BCN;
+	p->init_rate = API_RATE_INDEX_B_1MBPS; /* 1Mbps DSSS */
+	p->frame_length = cpu_to_le16(skb->len - 4);
+
+	ret = hif_set_template_frame(wvif, p);
+
+	skb_pull(skb, 4);
+
+	if (ret)
+		goto done;
+	/* TODO: Distill probe resp; remove TIM and any other beacon-specific
+	 * IEs
+	 */
+	mgmt = (void *)skb->data;
+	mgmt->frame_control =
+		cpu_to_le16(IEEE80211_FTYPE_MGMT | IEEE80211_STYPE_PROBE_RESP);
+
+	p->frame_type = HIF_TMPLT_PRBRES;
+
+	ret = hif_set_template_frame(wvif, p);
+	wfx_fwd_probe_req(wvif, false);
+
+done:
+	if (!skb)
+		dev_kfree_skb(skb);
+	return ret;
+}
+
+static int wfx_is_ht(const struct wfx_ht_info *ht_info)
+{
+	return ht_info->channel_type != NL80211_CHAN_NO_HT;
+}
+
+static int wfx_ht_greenfield(const struct wfx_ht_info *ht_info)
+{
+	return wfx_is_ht(ht_info) &&
+		(ht_info->ht_cap.cap & IEEE80211_HT_CAP_GRN_FLD) &&
+		!(ht_info->operation_mode &
+		  IEEE80211_HT_OP_MODE_NON_GF_STA_PRSNT);
+}
+
+static int wfx_ht_ampdu_density(const struct wfx_ht_info *ht_info)
+{
+	if (!wfx_is_ht(ht_info))
+		return 0;
+	return ht_info->ht_cap.ampdu_density;
+}
+
+static void wfx_join_finalize(struct wfx_vif *wvif, struct ieee80211_bss_conf *info)
+{
+	struct ieee80211_sta *sta = NULL;
+	struct hif_mib_set_association_mode association_mode = { };
+
+	if (info->dtim_period)
+		wvif->dtim_period = info->dtim_period;
+	wvif->beacon_int = info->beacon_int;
+
+	rcu_read_lock();
+	if (info->bssid && !info->ibss_joined)
+		sta = ieee80211_find_sta(wvif->vif, info->bssid);
+	if (sta) {
+		wvif->ht_info.ht_cap = sta->ht_cap;
+		wvif->bss_params.operational_rate_set =
+			wfx_rate_mask_to_hw(wvif->wdev, sta->supp_rates[wvif->channel->band]);
+		wvif->ht_info.operation_mode = info->ht_operation_mode;
+	} else {
+		memset(&wvif->ht_info, 0, sizeof(wvif->ht_info));
+		wvif->bss_params.operational_rate_set = -1;
+	}
+	rcu_read_unlock();
+
+	/* Non Greenfield stations present */
+	if (wvif->ht_info.operation_mode & IEEE80211_HT_OP_MODE_NON_GF_STA_PRSNT)
+		hif_dual_cts_protection(wvif, true);
+	else
+		hif_dual_cts_protection(wvif, false);
+
+	association_mode.preambtype_use = 1;
+	association_mode.mode = 1;
+	association_mode.rateset = 1;
+	association_mode.spacing = 1;
+	association_mode.preamble_type = info->use_short_preamble ? HIF_PREAMBLE_SHORT : HIF_PREAMBLE_LONG;
+	association_mode.basic_rate_set = cpu_to_le32(wfx_rate_mask_to_hw(wvif->wdev, info->basic_rates));
+	association_mode.mixed_or_greenfield_type = wfx_ht_greenfield(&wvif->ht_info);
+	association_mode.mpdu_start_spacing = wfx_ht_ampdu_density(&wvif->ht_info);
+
+	wfx_cqm_bssloss_sm(wvif, 0, 0, 0);
+	cancel_work_sync(&wvif->unjoin_work);
+
+	wvif->bss_params.beacon_lost_count = 20;
+	wvif->bss_params.aid = info->aid;
+
+	if (wvif->dtim_period < 1)
+		wvif->dtim_period = 1;
+
+	hif_set_association_mode(wvif, &association_mode);
+
+	if (!info->ibss_joined) {
+		hif_keep_alive_period(wvif, 30 /* sec */);
+		hif_set_bss_params(wvif, &wvif->bss_params);
+		wvif->setbssparams_done = true;
+		wfx_set_beacon_wakeup_period_work(&wvif->set_beacon_wakeup_period_work);
+		wfx_set_pm(wvif, &wvif->powersave_mode);
+	}
+}
+
+void wfx_bss_info_changed(struct ieee80211_hw *hw,
+			     struct ieee80211_vif *vif,
+			     struct ieee80211_bss_conf *info,
+			     u32 changed)
+{
+	struct wfx_dev *wdev = hw->priv;
+	struct wfx_vif *wvif = (struct wfx_vif *) vif->drv_priv;
+	bool do_join = false;
+	int i;
+	int nb_arp_addr;
+
+	mutex_lock(&wdev->conf_mutex);
+
+	/* TODO: BSS_CHANGED_QOS */
+	if (changed & BSS_CHANGED_ARP_FILTER) {
+		struct hif_mib_arp_ip_addr_table filter = { };
+
+		nb_arp_addr = info->arp_addr_cnt;
+		if (nb_arp_addr <= 0 || nb_arp_addr > HIF_MAX_ARP_IP_ADDRTABLE_ENTRIES)
+			nb_arp_addr = 0;
+
+		for (i = 0; i < HIF_MAX_ARP_IP_ADDRTABLE_ENTRIES; i++) {
+			filter.condition_idx = i;
+			if (i < nb_arp_addr) {
+				// Caution: type of arp_addr_list[i] is __be32
+				memcpy(filter.ipv4_address, &info->arp_addr_list[i], sizeof(filter.ipv4_address));
+				filter.arp_enable = HIF_ARP_NS_FILTERING_ENABLE;
+			} else {
+				filter.arp_enable = HIF_ARP_NS_FILTERING_DISABLE;
+			}
+			hif_set_arp_ipv4_filter(wvif, &filter);
+		}
+	}
+
+	if (changed &
+	    (BSS_CHANGED_BEACON | BSS_CHANGED_AP_PROBE_RESP |
+	     BSS_CHANGED_BSSID | BSS_CHANGED_SSID | BSS_CHANGED_IBSS)) {
+		wvif->beacon_int = info->beacon_int;
+		wfx_update_beaconing(wvif);
+		wfx_upload_beacon(wvif);
+	}
+
+	if (changed & BSS_CHANGED_BEACON_ENABLED && wvif->state != WFX_STATE_IBSS) {
+		if (wvif->enable_beacon != info->enable_beacon) {
+			hif_beacon_transmit(wvif, info->enable_beacon);
+			wvif->enable_beacon = info->enable_beacon;
+		}
+	}
+
+	/* assoc/disassoc, or maybe AID changed */
+	if (changed & BSS_CHANGED_ASSOC) {
+		wfx_tx_lock_flush(wdev);
+		wvif->wep_default_key_id = -1;
+		wfx_tx_unlock(wdev);
+	}
+
+	if (changed & BSS_CHANGED_ASSOC && !info->assoc &&
+	    (wvif->state == WFX_STATE_STA || wvif->state == WFX_STATE_IBSS)) {
+		/* Shedule unjoin work */
+		wfx_tx_lock(wdev);
+		if (!schedule_work(&wvif->unjoin_work))
+			wfx_tx_unlock(wdev);
+	} else {
+		if (changed & BSS_CHANGED_BEACON_INT) {
+			if (info->ibss_joined)
+				do_join = true;
+			else if (wvif->state == WFX_STATE_AP)
+				wfx_update_beaconing(wvif);
+		}
+
+		if (changed & BSS_CHANGED_BSSID)
+			do_join = true;
+
+		if (changed &
+		    (BSS_CHANGED_ASSOC | BSS_CHANGED_BSSID |
+		     BSS_CHANGED_IBSS | BSS_CHANGED_BASIC_RATES | BSS_CHANGED_HT)) {
+			if (info->assoc) {
+				if (wvif->state < WFX_STATE_PRE_STA) {
+					ieee80211_connection_loss(vif);
+					mutex_unlock(&wdev->conf_mutex);
+					return;
+				} else if (wvif->state == WFX_STATE_PRE_STA) {
+					wvif->state = WFX_STATE_STA;
+				}
+			} else {
+				do_join = true;
+			}
+
+			if (info->assoc || info->ibss_joined)
+				wfx_join_finalize(wvif, info);
+			else
+				memset(&wvif->bss_params, 0, sizeof(wvif->bss_params));
+		}
+	}
+
+	/* ERP Protection */
+	if (changed & (BSS_CHANGED_ASSOC |
+		       BSS_CHANGED_ERP_CTS_PROT |
+		       BSS_CHANGED_ERP_PREAMBLE)) {
+		u32 prev_erp_info = wvif->erp_info;
+
+		if (info->use_cts_prot)
+			wvif->erp_info |= WLAN_ERP_USE_PROTECTION;
+		else if (!(prev_erp_info & WLAN_ERP_NON_ERP_PRESENT))
+			wvif->erp_info &= ~WLAN_ERP_USE_PROTECTION;
+
+		if (info->use_short_preamble)
+			wvif->erp_info |= WLAN_ERP_BARKER_PREAMBLE;
+		else
+			wvif->erp_info &= ~WLAN_ERP_BARKER_PREAMBLE;
+
+		if (prev_erp_info != wvif->erp_info)
+			schedule_work(&wvif->set_cts_work);
+	}
+
+	if (changed & (BSS_CHANGED_ASSOC | BSS_CHANGED_ERP_SLOT))
+		hif_slot_time(wvif, info->use_short_slot ? 9 : 20);
+
+	if (changed & (BSS_CHANGED_ASSOC | BSS_CHANGED_CQM)) {
+		struct hif_mib_rcpi_rssi_threshold th = {
+			.rolling_average_count = 8,
+			.detection = 1,
+		};
+
+		wvif->cqm_rssi_thold = info->cqm_rssi_thold;
+
+		if (!info->cqm_rssi_thold && !info->cqm_rssi_hyst) {
+			th.upperthresh = 1;
+			th.lowerthresh = 1;
+		} else {
+			/* FIXME It's not a correct way of setting threshold.
+			 * Upper and lower must be set equal here and adjusted
+			 * in callback. However current implementation is much
+			 * more reliable and stable.
+			 */
+			/* RSSI: signed Q8.0, RCPI: unsigned Q7.1
+			 * RSSI = RCPI / 2 - 110
+			 */
+			th.upper_threshold = info->cqm_rssi_thold + info->cqm_rssi_hyst;
+			th.upper_threshold = (th.upper_threshold + 110) * 2;
+			th.lower_threshold = info->cqm_rssi_thold;
+			th.lower_threshold = (th.lower_threshold + 110) * 2;
+		}
+		hif_set_rcpi_rssi_threshold(wvif, &th);
+	}
+
+	if (changed & BSS_CHANGED_TXPOWER && info->txpower != wdev->output_power) {
+		wdev->output_power = info->txpower;
+		hif_set_output_power(wvif, wdev->output_power * 10);
+	}
+	mutex_unlock(&wdev->conf_mutex);
+
+	if (do_join) {
+		wfx_tx_lock_flush(wdev);
+		wfx_do_join(wvif); /* Will unlock it for us */
+	}
+}
+
+static void wfx_ps_notify(struct wfx_vif *wvif, enum sta_notify_cmd notify_cmd,
+			  int link_id)
+{
+	u32 bit, prev;
+
+	spin_lock_bh(&wvif->ps_state_lock);
+	/* Zero link id means "for all link IDs" */
+	if (link_id) {
+		bit = BIT(link_id);
+	} else if (notify_cmd != STA_NOTIFY_AWAKE) {
+		dev_warn(wvif->wdev->dev, "unsupported notify command\n");
+		bit = 0;
+	} else {
+		bit = wvif->link_id_map;
+	}
+	prev = wvif->sta_asleep_mask & bit;
+
+	switch (notify_cmd) {
+	case STA_NOTIFY_SLEEP:
+		if (!prev) {
+			if (wvif->mcast_buffered && !wvif->sta_asleep_mask)
+				schedule_work(&wvif->mcast_start_work);
+			wvif->sta_asleep_mask |= bit;
+		}
+		break;
+	case STA_NOTIFY_AWAKE:
+		if (prev) {
+			wvif->sta_asleep_mask &= ~bit;
+			wvif->pspoll_mask &= ~bit;
+			if (link_id && !wvif->sta_asleep_mask)
+				schedule_work(&wvif->mcast_stop_work);
+			wfx_bh_request_tx(wvif->wdev);
+		}
+		break;
+	}
+	spin_unlock_bh(&wvif->ps_state_lock);
+}
+
+void wfx_sta_notify(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
+		    enum sta_notify_cmd notify_cmd, struct ieee80211_sta *sta)
+{
+	struct wfx_vif *wvif = (struct wfx_vif *) vif->drv_priv;
+	struct wfx_sta_priv *sta_priv = (struct wfx_sta_priv *) &sta->drv_priv;
+
+	wfx_ps_notify(wvif, notify_cmd, sta_priv->link_id);
+}
+
 static int wfx_set_tim_impl(struct wfx_vif *wvif, bool aid0_bit_set)
 {
 	struct sk_buff *skb;
@@ -33,8 +1208,11 @@ static int wfx_set_tim_impl(struct wfx_vif *wvif, bool aid0_bit_set)
 
 	skb = ieee80211_beacon_get_tim(wvif->wdev->hw, wvif->vif,
 				       &tim_offset, &tim_length);
-	if (!skb)
+	if (!skb) {
+		if (!__wfx_flush(wvif->wdev, true))
+			wfx_tx_unlock(wvif->wdev);
 		return -ENOENT;
+	}
 	tim_ptr = skb->data + tim_offset;
 
 	if (tim_offset && tim_length >= 6) {
@@ -56,16 +1234,34 @@ static int wfx_set_tim_impl(struct wfx_vif *wvif, bool aid0_bit_set)
 	return 0;
 }
 
+void wfx_set_tim_work(struct work_struct *work)
+{
+	struct wfx_vif *wvif = container_of(work, struct wfx_vif, set_tim_work);
+
+	wfx_set_tim_impl(wvif, wvif->aid0_bit_set);
+}
+
+int wfx_set_tim(struct ieee80211_hw *hw, struct ieee80211_sta *sta, bool set)
+{
+	struct wfx_dev *wdev = hw->priv;
+	struct wfx_sta_priv *sta_dev = (struct wfx_sta_priv *) &sta->drv_priv;
+	struct wfx_vif *wvif = wdev_to_wvif(wdev, sta_dev->vif_id);
+
+	schedule_work(&wvif->set_tim_work);
+	return 0;
+}
+
 static void wfx_mcast_start_work(struct work_struct *work)
 {
 	struct wfx_vif *wvif = container_of(work, struct wfx_vif, mcast_start_work);
+	long tmo = wvif->dtim_period * TU_TO_JIFFIES(wvif->beacon_int + 20);
 
 	cancel_work_sync(&wvif->mcast_stop_work);
 	if (!wvif->aid0_bit_set) {
 		wfx_tx_lock_flush(wvif->wdev);
 		wfx_set_tim_impl(wvif, true);
 		wvif->aid0_bit_set = true;
-		mod_timer(&wvif->mcast_timeout, TU_TO_JIFFIES(1000));
+		mod_timer(&wvif->mcast_timeout, jiffies + tmo);
 		wfx_tx_unlock(wvif->wdev);
 	}
 }
@@ -95,6 +1291,134 @@ static void wfx_mcast_timeout(struct timer_list *t)
 	spin_unlock_bh(&wvif->ps_state_lock);
 }
 
+int wfx_ampdu_action(struct ieee80211_hw *hw,
+		     struct ieee80211_vif *vif,
+		     struct ieee80211_ampdu_params *params)
+{
+	/* Aggregation is implemented fully in firmware,
+	 * including block ack negotiation. Do not allow
+	 * mac80211 stack to do anything: it interferes with
+	 * the firmware.
+	 */
+
+	/* Note that we still need this function stubbed. */
+
+	return -ENOTSUPP;
+}
+
+void wfx_suspend_resume(struct wfx_vif *wvif,
+			struct hif_ind_suspend_resume_tx *arg)
+{
+	if (arg->suspend_resume_flags.bc_mc_only) {
+		bool cancel_tmo = false;
+
+		spin_lock_bh(&wvif->ps_state_lock);
+		if (!arg->suspend_resume_flags.resume)
+			wvif->mcast_tx = false;
+		else
+			wvif->mcast_tx = wvif->aid0_bit_set && wvif->mcast_buffered;
+		if (wvif->mcast_tx) {
+			cancel_tmo = true;
+			wfx_bh_request_tx(wvif->wdev);
+		}
+		spin_unlock_bh(&wvif->ps_state_lock);
+		if (cancel_tmo)
+			del_timer_sync(&wvif->mcast_timeout);
+	} else if (arg->suspend_resume_flags.resume) {
+		// FIXME: should change each station status independently
+		wfx_ps_notify(wvif, STA_NOTIFY_AWAKE, 0);
+		wfx_bh_request_tx(wvif->wdev);
+	} else {
+		// FIXME: should change each station status independently
+		wfx_ps_notify(wvif, STA_NOTIFY_SLEEP, 0);
+	}
+}
+
+int wfx_add_chanctx(struct ieee80211_hw *hw,
+		    struct ieee80211_chanctx_conf *conf)
+{
+	return 0;
+}
+
+void wfx_remove_chanctx(struct ieee80211_hw *hw,
+			struct ieee80211_chanctx_conf *conf)
+{
+}
+
+void wfx_change_chanctx(struct ieee80211_hw *hw,
+			struct ieee80211_chanctx_conf *conf,
+			u32 changed)
+{
+}
+
+int wfx_assign_vif_chanctx(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
+			   struct ieee80211_chanctx_conf *conf)
+{
+	struct wfx_vif *wvif = (struct wfx_vif *) vif->drv_priv;
+	struct ieee80211_channel *ch = conf->def.chan;
+
+	WARN(wvif->channel, "channel overwrite");
+	wvif->channel = ch;
+	wvif->ht_info.channel_type = cfg80211_get_chandef_type(&conf->def);
+
+	return 0;
+}
+
+void wfx_unassign_vif_chanctx(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
+			      struct ieee80211_chanctx_conf *conf)
+{
+	struct wfx_vif *wvif = (struct wfx_vif *) vif->drv_priv;
+	struct ieee80211_channel *ch = conf->def.chan;
+
+	WARN(wvif->channel != ch, "channel mismatch");
+	wvif->channel = NULL;
+}
+
+int wfx_config(struct ieee80211_hw *hw, u32 changed)
+{
+	int ret = 0;
+	struct wfx_dev *wdev = hw->priv;
+	struct ieee80211_conf *conf = &hw->conf;
+	struct wfx_vif *wvif;
+
+	// FIXME: Interface id should not been hardcoded
+	wvif = wdev_to_wvif(wdev, 0);
+	if (!wvif) {
+		WARN(1, "interface 0 does not exist anymore");
+		return 0;
+	}
+
+	down(&wvif->scan.lock);
+	mutex_lock(&wdev->conf_mutex);
+	if (changed & IEEE80211_CONF_CHANGE_POWER) {
+		wdev->output_power = conf->power_level;
+		hif_set_output_power(wvif, wdev->output_power * 10);
+	}
+
+	if (changed & IEEE80211_CONF_CHANGE_PS) {
+		wvif = NULL;
+		while ((wvif = wvif_iterate(wdev, wvif)) != NULL) {
+			memset(&wvif->powersave_mode, 0, sizeof(wvif->powersave_mode));
+			if (conf->flags & IEEE80211_CONF_PS) {
+				wvif->powersave_mode.pm_mode.enter_psm = 1;
+				if (conf->dynamic_ps_timeout > 0) {
+					wvif->powersave_mode.pm_mode.fast_psm = 1;
+					// Firmware does not support more than 128ms
+					wvif->powersave_mode.fast_psm_idle_period =
+						min(conf->dynamic_ps_timeout * 2, 255);
+				}
+			}
+			if (wvif->state == WFX_STATE_STA && wvif->bss_params.aid)
+				wfx_set_pm(wvif, &wvif->powersave_mode);
+		}
+		wvif = wdev_to_wvif(wdev, 0);
+	}
+
+	mutex_unlock(&wdev->conf_mutex);
+	up(&wvif->scan.lock);
+	return ret;
+}
+
 int wfx_add_interface(struct ieee80211_hw *hw, struct ieee80211_vif *vif)
 {
 	int i;
@@ -138,8 +1462,22 @@ int wfx_add_interface(struct ieee80211_hw *hw, struct ieee80211_vif *vif)
 		default_edca_params[IEEE80211_AC_BK].queue_id = HIF_QUEUE_ID_BESTEFFORT;
 	}
 
+	vif->driver_flags |= IEEE80211_VIF_BEACON_FILTER |
+			     IEEE80211_VIF_SUPPORTS_UAPSD |
+			     IEEE80211_VIF_SUPPORTS_CQM_RSSI;
+
 	mutex_lock(&wdev->conf_mutex);
 
+	switch (vif->type) {
+	case NL80211_IFTYPE_STATION:
+	case NL80211_IFTYPE_ADHOC:
+	case NL80211_IFTYPE_AP:
+		break;
+	default:
+		mutex_unlock(&wdev->conf_mutex);
+		return -EOPNOTSUPP;
+	}
+
 	for (i = 0; i < ARRAY_SIZE(wdev->vif); i++) {
 		if (!wdev->vif[i]) {
 			wdev->vif[i] = vif;
@@ -151,6 +1489,7 @@ int wfx_add_interface(struct ieee80211_hw *hw, struct ieee80211_vif *vif)
 		mutex_unlock(&wdev->conf_mutex);
 		return -EOPNOTSUPP;
 	}
+	// FIXME: prefer use of container_of() to get vif
 	wvif->vif = vif;
 	wvif->wdev = wdev;
 
@@ -158,11 +1497,16 @@ int wfx_add_interface(struct ieee80211_hw *hw, struct ieee80211_vif *vif)
 	INIT_DELAYED_WORK(&wvif->link_id_gc_work, wfx_link_id_gc_work);
 
 	spin_lock_init(&wvif->ps_state_lock);
+	INIT_WORK(&wvif->set_tim_work, wfx_set_tim_work);
 
 	INIT_WORK(&wvif->mcast_start_work, wfx_mcast_start_work);
 	INIT_WORK(&wvif->mcast_stop_work, wfx_mcast_stop_work);
 	timer_setup(&wvif->mcast_timeout, wfx_mcast_timeout, 0);
 
+	wvif->setbssparams_done = false;
+	mutex_init(&wvif->bss_loss_lock);
+	INIT_DELAYED_WORK(&wvif->bss_loss_work, wfx_bss_loss_work);
+
 	wvif->wep_default_key_id = -1;
 	INIT_WORK(&wvif->wep_key_work, wfx_wep_key_work);
 
@@ -170,22 +1514,115 @@ int wfx_add_interface(struct ieee80211_hw *hw, struct ieee80211_vif *vif)
 	INIT_WORK(&wvif->scan.work, wfx_scan_work);
 	INIT_DELAYED_WORK(&wvif->scan.timeout, wfx_scan_timeout);
 
+	spin_lock_init(&wvif->event_queue_lock);
+	INIT_LIST_HEAD(&wvif->event_queue);
+	INIT_WORK(&wvif->event_handler_work, wfx_event_handler_work);
+
+	init_completion(&wvif->set_pm_mode_complete);
+	complete(&wvif->set_pm_mode_complete);
+	INIT_WORK(&wvif->set_beacon_wakeup_period_work, wfx_set_beacon_wakeup_period_work);
+	INIT_WORK(&wvif->update_filtering_work, wfx_update_filtering_work);
+	INIT_WORK(&wvif->bss_params_work, wfx_bss_params_work);
+	INIT_WORK(&wvif->set_cts_work, wfx_set_cts_work);
+	INIT_WORK(&wvif->unjoin_work, wfx_unjoin_work);
+
 	mutex_unlock(&wdev->conf_mutex);
+
+	hif_set_macaddr(wvif, vif->addr);
 	BUG_ON(ARRAY_SIZE(default_edca_params) != ARRAY_SIZE(wvif->edca.params));
-	for (i = 0; i < IEEE80211_NUM_ACS; i++)
+	for (i = 0; i < IEEE80211_NUM_ACS; i++) {
 		memcpy(&wvif->edca.params[i], &default_edca_params[i], sizeof(default_edca_params[i]));
+		wvif->edca.uapsd_enable[i] = false;
+		hif_set_edca_queue_params(wvif, &wvif->edca.params[i]);
+	}
+	wfx_set_uapsd_param(wvif, &wvif->edca);
+
 	tx_policy_init(wvif);
+	wvif = NULL;
+	while ((wvif = wvif_iterate(wdev, wvif)) != NULL) {
+		// Combo mode does not support Block Acks. We can re-enable them
+		if (wvif_count(wdev) == 1)
+			hif_set_block_ack_policy(wvif, 0xFF, 0xFF);
+		else
+			hif_set_block_ack_policy(wvif, 0x00, 0x00);
+		// Combo force powersave mode. We can re-enable it now
+		wfx_set_pm(wvif, &wvif->powersave_mode);
+	}
 	return 0;
 }
 
 void wfx_remove_interface(struct ieee80211_hw *hw,
 			  struct ieee80211_vif *vif)
 {
+	struct wfx_dev *wdev = hw->priv;
 	struct wfx_vif *wvif = (struct wfx_vif *) vif->drv_priv;
+	int i;
+
+	// If scan is in progress, stop it
+	while (down_trylock(&wvif->scan.lock))
+		schedule();
+	up(&wvif->scan.lock);
+	wait_for_completion_timeout(&wvif->set_pm_mode_complete, msecs_to_jiffies(300));
 
+	mutex_lock(&wdev->conf_mutex);
+	switch (wvif->state) {
+	case WFX_STATE_PRE_STA:
+	case WFX_STATE_STA:
+	case WFX_STATE_IBSS:
+		wfx_tx_lock_flush(wdev);
+		if (!schedule_work(&wvif->unjoin_work))
+			wfx_tx_unlock(wdev);
+		break;
+	case WFX_STATE_AP:
+		for (i = 0; wvif->link_id_map; ++i) {
+			if (wvif->link_id_map & BIT(i)) {
+				wfx_unmap_link(wvif, i);
+				wvif->link_id_map &= ~BIT(i);
+			}
+		}
+		memset(wvif->link_id_db, 0, sizeof(wvif->link_id_db));
+		wvif->sta_asleep_mask = 0;
+		wvif->enable_beacon = false;
+		wvif->mcast_tx = false;
+		wvif->aid0_bit_set = false;
+		wvif->mcast_buffered = false;
+		wvif->pspoll_mask = 0;
+		/* reset.link_id = 0; */
+		hif_reset(wvif, false);
+		break;
+	default:
+		break;
+	}
+
+	wvif->state = WFX_STATE_PASSIVE;
 	wfx_tx_queues_wait_empty_vif(wvif);
+	wfx_tx_unlock(wdev);
+
+	/* FIXME: In add to reset MAC address, try to reset interface */
+	hif_set_macaddr(wvif, NULL);
+
+	cancel_delayed_work_sync(&wvif->scan.timeout);
+
+	wfx_cqm_bssloss_sm(wvif, 0, 0, 0);
+	cancel_work_sync(&wvif->unjoin_work);
 	cancel_delayed_work_sync(&wvif->link_id_gc_work);
 	del_timer_sync(&wvif->mcast_timeout);
+	wfx_free_event_queue(wvif);
+
+	wdev->vif[wvif->id] = NULL;
+	wvif->vif = NULL;
+
+	mutex_unlock(&wdev->conf_mutex);
+	wvif = NULL;
+	while ((wvif = wvif_iterate(wdev, wvif)) != NULL) {
+		// Combo mode does not support Block Acks. We can re-enable them
+		if (wvif_count(wdev) == 1)
+			hif_set_block_ack_policy(wvif, 0xFF, 0xFF);
+		else
+			hif_set_block_ack_policy(wvif, 0x00, 0x00);
+		// Combo force powersave mode. We can re-enable it now
+		wfx_set_pm(wvif, &wvif->powersave_mode);
+	}
 }
 
 int wfx_start(struct ieee80211_hw *hw)

commit fb2490f693ee0151c0d847d1e4c575313a46b13b
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Thu Sep 19 14:25:47 2019 +0000

    staging: wfx: implement 802.11 key handling
    
    wfx_set_key() mostly copy bytes on correct offsets. A big piece of code
    for a simple work. Unfortunately, I did not found any way to factorize
    it.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20190919142527.31797-20-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index 5a8140100e97..2e709b8a3bf4 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -9,6 +9,7 @@
 
 #include "sta.h"
 #include "wfx.h"
+#include "key.h"
 #include "scan.h"
 #include "hif_tx_mib.h"
 
@@ -162,6 +163,9 @@ int wfx_add_interface(struct ieee80211_hw *hw, struct ieee80211_vif *vif)
 	INIT_WORK(&wvif->mcast_stop_work, wfx_mcast_stop_work);
 	timer_setup(&wvif->mcast_timeout, wfx_mcast_timeout, 0);
 
+	wvif->wep_default_key_id = -1;
+	INIT_WORK(&wvif->wep_key_work, wfx_wep_key_work);
+
 	sema_init(&wvif->scan.lock, 1);
 	INIT_WORK(&wvif->scan.work, wfx_scan_work);
 	INIT_DELAYED_WORK(&wvif->scan.timeout, wfx_scan_timeout);

commit 1a61af0f8cbecd1610c6fc380d0fb00f57fd43f2
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Thu Sep 19 14:25:47 2019 +0000

    staging: wfx: allow to scan networks
    
    Chip can make foreground scan or background, but both can't be mixed in
    same request. So, we need to split each mac80211 requests into multiple
    HIF requests.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20190919142527.31797-19-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index 5714aba1432c..5a8140100e97 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -9,9 +9,18 @@
 
 #include "sta.h"
 #include "wfx.h"
+#include "scan.h"
+#include "hif_tx_mib.h"
 
 #define TXOP_UNIT 32
 
+int wfx_fwd_probe_req(struct wfx_vif *wvif, bool enable)
+{
+	wvif->fwd_probe_req = enable;
+	return hif_set_rx_filter(wvif, wvif->filter_bssid,
+				 wvif->fwd_probe_req);
+}
+
 static int wfx_set_tim_impl(struct wfx_vif *wvif, bool aid0_bit_set)
 {
 	struct sk_buff *skb;
@@ -128,6 +137,8 @@ int wfx_add_interface(struct ieee80211_hw *hw, struct ieee80211_vif *vif)
 		default_edca_params[IEEE80211_AC_BK].queue_id = HIF_QUEUE_ID_BESTEFFORT;
 	}
 
+	mutex_lock(&wdev->conf_mutex);
+
 	for (i = 0; i < ARRAY_SIZE(wdev->vif); i++) {
 		if (!wdev->vif[i]) {
 			wdev->vif[i] = vif;
@@ -135,8 +146,10 @@ int wfx_add_interface(struct ieee80211_hw *hw, struct ieee80211_vif *vif)
 			break;
 		}
 	}
-	if (i == ARRAY_SIZE(wdev->vif))
+	if (i == ARRAY_SIZE(wdev->vif)) {
+		mutex_unlock(&wdev->conf_mutex);
 		return -EOPNOTSUPP;
+	}
 	wvif->vif = vif;
 	wvif->wdev = wdev;
 
@@ -148,6 +161,12 @@ int wfx_add_interface(struct ieee80211_hw *hw, struct ieee80211_vif *vif)
 	INIT_WORK(&wvif->mcast_start_work, wfx_mcast_start_work);
 	INIT_WORK(&wvif->mcast_stop_work, wfx_mcast_stop_work);
 	timer_setup(&wvif->mcast_timeout, wfx_mcast_timeout, 0);
+
+	sema_init(&wvif->scan.lock, 1);
+	INIT_WORK(&wvif->scan.work, wfx_scan_work);
+	INIT_DELAYED_WORK(&wvif->scan.timeout, wfx_scan_timeout);
+
+	mutex_unlock(&wdev->conf_mutex);
 	BUG_ON(ARRAY_SIZE(default_edca_params) != ARRAY_SIZE(wvif->edca.params));
 	for (i = 0; i < IEEE80211_NUM_ACS; i++)
 		memcpy(&wvif->edca.params[i], &default_edca_params[i], sizeof(default_edca_params[i]));
@@ -175,7 +194,9 @@ void wfx_stop(struct ieee80211_hw *hw)
 	struct wfx_dev *wdev = hw->priv;
 
 	wfx_tx_lock_flush(wdev);
+	mutex_lock(&wdev->conf_mutex);
 	wfx_tx_queues_clear(wdev);
+	mutex_unlock(&wdev->conf_mutex);
 	wfx_tx_unlock(wdev);
 	WARN(atomic_read(&wdev->tx_lock), "tx_lock is locked");
 }

commit 9bca45f3d6924f19f29c0d019e961af3f41bdc9e
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Thu Sep 19 14:25:45 2019 +0000

    staging: wfx: allow to send 802.11 frames
    
    Three things make this task more complex than it should:
      - Chip necessitate to associate a link-id to each station. It is same
        thing than association ID but, using 8 bits only.
      - Rate policy is sent separately from Tx frames
      - Driver try to handle itself power saving of stations and multicast
        data
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20190919142527.31797-17-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
index fe3ff6536a87..5714aba1432c 100644
--- a/drivers/staging/wfx/sta.c
+++ b/drivers/staging/wfx/sta.c
@@ -10,11 +10,123 @@
 #include "sta.h"
 #include "wfx.h"
 
+#define TXOP_UNIT 32
+
+static int wfx_set_tim_impl(struct wfx_vif *wvif, bool aid0_bit_set)
+{
+	struct sk_buff *skb;
+	struct hif_ie_flags target_frame = {
+		.beacon = 1,
+	};
+	u16 tim_offset, tim_length;
+	u8 *tim_ptr;
+
+	skb = ieee80211_beacon_get_tim(wvif->wdev->hw, wvif->vif,
+				       &tim_offset, &tim_length);
+	if (!skb)
+		return -ENOENT;
+	tim_ptr = skb->data + tim_offset;
+
+	if (tim_offset && tim_length >= 6) {
+		/* Ignore DTIM count from mac80211:
+		 * firmware handles DTIM internally.
+		 */
+		tim_ptr[2] = 0;
+
+		/* Set/reset aid0 bit */
+		if (aid0_bit_set)
+			tim_ptr[4] |= 1;
+		else
+			tim_ptr[4] &= ~1;
+	}
+
+	hif_update_ie(wvif, &target_frame, tim_ptr, tim_length);
+	dev_kfree_skb(skb);
+
+	return 0;
+}
+
+static void wfx_mcast_start_work(struct work_struct *work)
+{
+	struct wfx_vif *wvif = container_of(work, struct wfx_vif, mcast_start_work);
+
+	cancel_work_sync(&wvif->mcast_stop_work);
+	if (!wvif->aid0_bit_set) {
+		wfx_tx_lock_flush(wvif->wdev);
+		wfx_set_tim_impl(wvif, true);
+		wvif->aid0_bit_set = true;
+		mod_timer(&wvif->mcast_timeout, TU_TO_JIFFIES(1000));
+		wfx_tx_unlock(wvif->wdev);
+	}
+}
+
+static void wfx_mcast_stop_work(struct work_struct *work)
+{
+	struct wfx_vif *wvif = container_of(work, struct wfx_vif, mcast_stop_work);
+
+	if (wvif->aid0_bit_set) {
+		del_timer_sync(&wvif->mcast_timeout);
+		wfx_tx_lock_flush(wvif->wdev);
+		wvif->aid0_bit_set = false;
+		wfx_set_tim_impl(wvif, false);
+		wfx_tx_unlock(wvif->wdev);
+	}
+}
+
+static void wfx_mcast_timeout(struct timer_list *t)
+{
+	struct wfx_vif *wvif = from_timer(wvif, t, mcast_timeout);
+
+	dev_warn(wvif->wdev->dev, "multicast delivery timeout\n");
+	spin_lock_bh(&wvif->ps_state_lock);
+	wvif->mcast_tx = wvif->aid0_bit_set && wvif->mcast_buffered;
+	if (wvif->mcast_tx)
+		wfx_bh_request_tx(wvif->wdev);
+	spin_unlock_bh(&wvif->ps_state_lock);
+}
+
 int wfx_add_interface(struct ieee80211_hw *hw, struct ieee80211_vif *vif)
 {
 	int i;
 	struct wfx_dev *wdev = hw->priv;
 	struct wfx_vif *wvif = (struct wfx_vif *) vif->drv_priv;
+	// FIXME: parameters are set by kernel juste after interface_add.
+	// Keep struct hif_req_edca_queue_params blank?
+	struct hif_req_edca_queue_params default_edca_params[] = {
+		[IEEE80211_AC_VO] = {
+			.queue_id = HIF_QUEUE_ID_VOICE,
+			.aifsn = 2,
+			.cw_min = 3,
+			.cw_max = 7,
+			.tx_op_limit = TXOP_UNIT * 47,
+		},
+		[IEEE80211_AC_VI] = {
+			.queue_id = HIF_QUEUE_ID_VIDEO,
+			.aifsn = 2,
+			.cw_min = 7,
+			.cw_max = 15,
+			.tx_op_limit = TXOP_UNIT * 94,
+		},
+		[IEEE80211_AC_BE] = {
+			.queue_id = HIF_QUEUE_ID_BESTEFFORT,
+			.aifsn = 3,
+			.cw_min = 15,
+			.cw_max = 1023,
+			.tx_op_limit = TXOP_UNIT * 0,
+		},
+		[IEEE80211_AC_BK] = {
+			.queue_id = HIF_QUEUE_ID_BACKGROUND,
+			.aifsn = 7,
+			.cw_min = 15,
+			.cw_max = 1023,
+			.tx_op_limit = TXOP_UNIT * 0,
+		},
+	};
+
+	if (wfx_api_older_than(wdev, 2, 0)) {
+		default_edca_params[IEEE80211_AC_BE].queue_id = HIF_QUEUE_ID_BACKGROUND;
+		default_edca_params[IEEE80211_AC_BK].queue_id = HIF_QUEUE_ID_BESTEFFORT;
+	}
 
 	for (i = 0; i < ARRAY_SIZE(wdev->vif); i++) {
 		if (!wdev->vif[i]) {
@@ -28,12 +140,29 @@ int wfx_add_interface(struct ieee80211_hw *hw, struct ieee80211_vif *vif)
 	wvif->vif = vif;
 	wvif->wdev = wdev;
 
+	INIT_WORK(&wvif->link_id_work, wfx_link_id_work);
+	INIT_DELAYED_WORK(&wvif->link_id_gc_work, wfx_link_id_gc_work);
+
+	spin_lock_init(&wvif->ps_state_lock);
+
+	INIT_WORK(&wvif->mcast_start_work, wfx_mcast_start_work);
+	INIT_WORK(&wvif->mcast_stop_work, wfx_mcast_stop_work);
+	timer_setup(&wvif->mcast_timeout, wfx_mcast_timeout, 0);
+	BUG_ON(ARRAY_SIZE(default_edca_params) != ARRAY_SIZE(wvif->edca.params));
+	for (i = 0; i < IEEE80211_NUM_ACS; i++)
+		memcpy(&wvif->edca.params[i], &default_edca_params[i], sizeof(default_edca_params[i]));
+	tx_policy_init(wvif);
 	return 0;
 }
 
 void wfx_remove_interface(struct ieee80211_hw *hw,
 			  struct ieee80211_vif *vif)
 {
+	struct wfx_vif *wvif = (struct wfx_vif *) vif->drv_priv;
+
+	wfx_tx_queues_wait_empty_vif(wvif);
+	cancel_delayed_work_sync(&wvif->link_id_gc_work);
+	del_timer_sync(&wvif->mcast_timeout);
 }
 
 int wfx_start(struct ieee80211_hw *hw)
@@ -43,4 +172,10 @@ int wfx_start(struct ieee80211_hw *hw)
 
 void wfx_stop(struct ieee80211_hw *hw)
 {
+	struct wfx_dev *wdev = hw->priv;
+
+	wfx_tx_lock_flush(wdev);
+	wfx_tx_queues_clear(wdev);
+	wfx_tx_unlock(wdev);
+	WARN(atomic_read(&wdev->tx_lock), "tx_lock is locked");
 }

commit e16e7f0716a6ba9a690fc5229a6e35e00e03b805
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Thu Sep 19 14:25:41 2019 +0000

    staging: wfx: instantiate mac80211 data
    
    Allocate a struct ieee80211_hw but do not yet register it.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20190919142527.31797-11-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/sta.c b/drivers/staging/wfx/sta.c
new file mode 100644
index 000000000000..fe3ff6536a87
--- /dev/null
+++ b/drivers/staging/wfx/sta.c
@@ -0,0 +1,46 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Implementation of mac80211 API.
+ *
+ * Copyright (c) 2017-2019, Silicon Laboratories, Inc.
+ * Copyright (c) 2010, ST-Ericsson
+ */
+#include <net/mac80211.h>
+
+#include "sta.h"
+#include "wfx.h"
+
+int wfx_add_interface(struct ieee80211_hw *hw, struct ieee80211_vif *vif)
+{
+	int i;
+	struct wfx_dev *wdev = hw->priv;
+	struct wfx_vif *wvif = (struct wfx_vif *) vif->drv_priv;
+
+	for (i = 0; i < ARRAY_SIZE(wdev->vif); i++) {
+		if (!wdev->vif[i]) {
+			wdev->vif[i] = vif;
+			wvif->id = i;
+			break;
+		}
+	}
+	if (i == ARRAY_SIZE(wdev->vif))
+		return -EOPNOTSUPP;
+	wvif->vif = vif;
+	wvif->wdev = wdev;
+
+	return 0;
+}
+
+void wfx_remove_interface(struct ieee80211_hw *hw,
+			  struct ieee80211_vif *vif)
+{
+}
+
+int wfx_start(struct ieee80211_hw *hw)
+{
+	return 0;
+}
+
+void wfx_stop(struct ieee80211_hw *hw)
+{
+}
