commit be2e96222fb69b6e0c38888f10824200124c6d0d
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Tue May 26 19:18:14 2020 +0200

    staging: wfx: drop unused function wfx_pending_requeue()
    
    The function wfx_pending_requeue() is not used anymore since the
    commit 7a44644c9379e ("staging: wfx: introduce
    wfx_set_default_unicast_key()")
    
    Fixes: 7a44644c9379e ("staging: wfx: introduce wfx_set_default_unicast_key()")
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200526171821.934581-4-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/queue.h b/drivers/staging/wfx/queue.h
index 0cbe5f4b06f2..0c3b7244498e 100644
--- a/drivers/staging/wfx/queue.h
+++ b/drivers/staging/wfx/queue.h
@@ -38,7 +38,6 @@ void wfx_tx_queue_drop(struct wfx_dev *wdev, struct wfx_queue *queue,
 
 struct sk_buff *wfx_pending_get(struct wfx_dev *wdev, u32 packet_id);
 void wfx_pending_drop(struct wfx_dev *wdev, struct sk_buff_head *dropped);
-int wfx_pending_requeue(struct wfx_dev *wdev, struct sk_buff *skb);
 unsigned int wfx_pending_get_pkt_us_delay(struct wfx_dev *wdev,
 					  struct sk_buff *skb);
 void wfx_pending_dump_old_frames(struct wfx_dev *wdev, unsigned int limit_ms);

commit 525f469f7f9ce657b35dae2a9f555be1e71e16a6
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Tue May 5 14:37:54 2020 +0200

    staging: wfx: remove useless header inclusions
    
    In order to keep the compilation times reasonable, we try to only
    include the necessary headers (especially header included from other
    headers).
    
    This patch clean up unnecessary headers inclusions.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200505123757.39506-13-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/queue.h b/drivers/staging/wfx/queue.h
index 1020dfde399b..0cbe5f4b06f2 100644
--- a/drivers/staging/wfx/queue.h
+++ b/drivers/staging/wfx/queue.h
@@ -11,8 +11,6 @@
 #include <linux/skbuff.h>
 #include <linux/atomic.h>
 
-#include "hif_api_cmd.h"
-
 struct wfx_dev;
 struct wfx_vif;
 

commit d7dcf8a54ea51463ece2c7c5893d7941a53edae0
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Mon Apr 6 13:17:47 2020 +0200

    staging: wfx: relocate LINK_ID_NO_ASSOC and MAX_STA_IN_AP_MODE to hif API
    
    The definitions LINK_ID_NO_ASSOC and MAX_STA_IN_AP_MODE are imposed by
    the hardware. Therefore, they should be located in the hardware
    interface API.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200406111756.154086-3-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/queue.h b/drivers/staging/wfx/queue.h
index ab45e32cbfbc..1020dfde399b 100644
--- a/drivers/staging/wfx/queue.h
+++ b/drivers/staging/wfx/queue.h
@@ -13,9 +13,6 @@
 
 #include "hif_api_cmd.h"
 
-#define WFX_MAX_STA_IN_AP_MODE    14
-#define WFX_LINK_ID_NO_ASSOC      15
-
 struct wfx_dev;
 struct wfx_vif;
 

commit 4c6b3837c6dc0d9e5f9ec910da2e36349beea733
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Wed Apr 1 13:04:01 2020 +0200

    staging: wfx: repair wfx_flush()
    
    Until now, wfx_flush() flushed queue for while device instead of only
    the queue of the intended vif. It sometime failed with a timeout, but
    this error was not reported.
    
    Moreover, if the device was frozen, wfx_flush didn't do anything and it
    results a potential warning (and maybe a resource leak) when the frozen
    device was unregistered.
    
    We can also notice that wfx_tx_queues_wait_empty_vif() did only exist to
    work around the broken feature of wfx_flush().
    
    This patch repair wfx_flush() and therefore drop
    wfx_tx_queues_wait_empty_vif().
    
    Reviewed-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200401110405.80282-29-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/queue.h b/drivers/staging/wfx/queue.h
index 9bc1a5200e64..ab45e32cbfbc 100644
--- a/drivers/staging/wfx/queue.h
+++ b/drivers/staging/wfx/queue.h
@@ -31,16 +31,18 @@ void wfx_tx_flush(struct wfx_dev *wdev);
 void wfx_tx_lock_flush(struct wfx_dev *wdev);
 
 void wfx_tx_queues_init(struct wfx_dev *wdev);
-void wfx_tx_queues_deinit(struct wfx_dev *wdev);
-void wfx_tx_queues_clear(struct wfx_dev *wdev);
-bool wfx_tx_queues_empty(struct wfx_dev *wdev);
+void wfx_tx_queues_check_empty(struct wfx_dev *wdev);
 bool wfx_tx_queues_has_cab(struct wfx_vif *wvif);
-void wfx_tx_queues_wait_empty_vif(struct wfx_vif *wvif);
 void wfx_tx_queues_put(struct wfx_dev *wdev, struct sk_buff *skb);
 struct hif_msg *wfx_tx_queues_get(struct wfx_dev *wdev);
 
+bool wfx_tx_queue_empty(struct wfx_dev *wdev, struct wfx_queue *queue,
+			int vif_id);
+void wfx_tx_queue_drop(struct wfx_dev *wdev, struct wfx_queue *queue,
+		       int vif_id, struct sk_buff_head *dropped);
 
 struct sk_buff *wfx_pending_get(struct wfx_dev *wdev, u32 packet_id);
+void wfx_pending_drop(struct wfx_dev *wdev, struct sk_buff_head *dropped);
 int wfx_pending_requeue(struct wfx_dev *wdev, struct sk_buff *skb);
 unsigned int wfx_pending_get_pkt_us_delay(struct wfx_dev *wdev,
 					  struct sk_buff *skb);

commit 39dbfa536b406fbe516e0ec7b571264ccf567edb
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Wed Apr 1 13:03:59 2020 +0200

    staging: wfx: improve interface between data_tx.c and queue.c
    
    Currently, wfx_pending_remove() (from queue.c) call wfx_skb_dtor()
    (from data_tx.c) that forward the tx status to mac80211.
    
    Moreover, there no purpose to retrieve a frame from the pending queue
    without dequeuing it. So, the main purpose of wfx_pending_remove() is to
    forward the tx status to mac80211.
    
    Let's make the architecture cleaner:
      - merge wfx_pending_remove() into wfx_pending_get()
      - call wfx_skb_dtor() from data_tx.c
    
    Reviewed-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200401110405.80282-27-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/queue.h b/drivers/staging/wfx/queue.h
index 4851635d159b..9bc1a5200e64 100644
--- a/drivers/staging/wfx/queue.h
+++ b/drivers/staging/wfx/queue.h
@@ -41,7 +41,6 @@ struct hif_msg *wfx_tx_queues_get(struct wfx_dev *wdev);
 
 
 struct sk_buff *wfx_pending_get(struct wfx_dev *wdev, u32 packet_id);
-int wfx_pending_remove(struct wfx_dev *wdev, struct sk_buff *skb);
 int wfx_pending_requeue(struct wfx_dev *wdev, struct sk_buff *skb);
 unsigned int wfx_pending_get_pkt_us_delay(struct wfx_dev *wdev,
 					  struct sk_buff *skb);

commit cb851c867dc07aa643f8a9a1be4092775bae7532
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Wed Apr 1 13:03:58 2020 +0200

    staging: wfx: simplify usage of wfx_tx_queues_put()
    
    The queue used for wfx_tx_queue_put() can be deducted from the content
    of the skb. So drop this parameter from call to wfx_tx_queues_put().
    
    In add, this change uniformizes usage of functions wfx_tx_queues_*.
    
    Reviewed-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200401110405.80282-26-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/queue.h b/drivers/staging/wfx/queue.h
index 241ca3039b54..4851635d159b 100644
--- a/drivers/staging/wfx/queue.h
+++ b/drivers/staging/wfx/queue.h
@@ -36,10 +36,9 @@ void wfx_tx_queues_clear(struct wfx_dev *wdev);
 bool wfx_tx_queues_empty(struct wfx_dev *wdev);
 bool wfx_tx_queues_has_cab(struct wfx_vif *wvif);
 void wfx_tx_queues_wait_empty_vif(struct wfx_vif *wvif);
+void wfx_tx_queues_put(struct wfx_dev *wdev, struct sk_buff *skb);
 struct hif_msg *wfx_tx_queues_get(struct wfx_dev *wdev);
 
-void wfx_tx_queue_put(struct wfx_dev *wdev, struct wfx_queue *queue,
-		      struct sk_buff *skb);
 
 struct sk_buff *wfx_pending_get(struct wfx_dev *wdev, u32 packet_id);
 int wfx_pending_remove(struct wfx_dev *wdev, struct sk_buff *skb);

commit d32cedbec0a64e24548986a0159ab86cfe6a4097
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Wed Apr 1 13:03:57 2020 +0200

    staging: wfx: drop struct wfx_queue_stats
    
    There is no reason to keep the intermediate struct wfx_queue_stats.
    Relocate its members to struct wfx_dev.
    
    Reviewed-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200401110405.80282-25-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/queue.h b/drivers/staging/wfx/queue.h
index 8e99bb2792ed..241ca3039b54 100644
--- a/drivers/staging/wfx/queue.h
+++ b/drivers/staging/wfx/queue.h
@@ -25,11 +25,6 @@ struct wfx_queue {
 	atomic_t		pending_frames;
 };
 
-struct wfx_queue_stats {
-	struct sk_buff_head	pending;
-	wait_queue_head_t	wait_link_id_empty;
-};
-
 void wfx_tx_lock(struct wfx_dev *wdev);
 void wfx_tx_unlock(struct wfx_dev *wdev);
 void wfx_tx_flush(struct wfx_dev *wdev);

commit 6bf418c50f98a3ec0105d9e5b5b99a7772c47d87
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Wed Apr 1 13:03:55 2020 +0200

    staging: wfx: change the way to choose frame to send
    
    The current code computes itself the QoS policy to choose which frame
    should be sent. However, firmware already do that job. Firmware would
    prefer to have packets in every queues and be able to choose itself
    which queue to use.
    
    So, this patch sort the queues from the emptiest to the fulliest (thanks
    to the pending frames counter introduced a few commits earlier). It send
    frame to the least full queue.
    
    However, we continue to be careful with frames that have to be sent
    after a dtim ("cab": Content After (DTIM) Beacon).
    
    So, this patch splits AC queues in two skb_queues: one for normal frames
    and another for cab frames. It cares to send frames from CAB skb_queue
    if appropriate.
    
    Reviewed-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200401110405.80282-23-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/queue.h b/drivers/staging/wfx/queue.h
index c24b8cd41a78..8e99bb2792ed 100644
--- a/drivers/staging/wfx/queue.h
+++ b/drivers/staging/wfx/queue.h
@@ -20,7 +20,8 @@ struct wfx_dev;
 struct wfx_vif;
 
 struct wfx_queue {
-	struct sk_buff_head	queue;
+	struct sk_buff_head	normal;
+	struct sk_buff_head	cab; // Content After (DTIM) Beacon
 	atomic_t		pending_frames;
 };
 
@@ -44,7 +45,6 @@ struct hif_msg *wfx_tx_queues_get(struct wfx_dev *wdev);
 
 void wfx_tx_queue_put(struct wfx_dev *wdev, struct wfx_queue *queue,
 		      struct sk_buff *skb);
-int wfx_tx_queue_get_num_queued(struct wfx_queue *queue);
 
 struct sk_buff *wfx_pending_get(struct wfx_dev *wdev, u32 packet_id);
 int wfx_pending_remove(struct wfx_dev *wdev, struct sk_buff *skb);

commit 7ba22b075422bb761f1fc26ff6dcb05eabed6e63
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Wed Apr 1 13:03:54 2020 +0200

    staging: wfx: introduce a counter of pending frames
    
    This counter will be useful to know which queue is least full in a
    further patch.
    
    Reviewed-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200401110405.80282-22-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/queue.h b/drivers/staging/wfx/queue.h
index 2c4724699ed0..c24b8cd41a78 100644
--- a/drivers/staging/wfx/queue.h
+++ b/drivers/staging/wfx/queue.h
@@ -9,6 +9,7 @@
 #define WFX_QUEUE_H
 
 #include <linux/skbuff.h>
+#include <linux/atomic.h>
 
 #include "hif_api_cmd.h"
 
@@ -20,6 +21,7 @@ struct wfx_vif;
 
 struct wfx_queue {
 	struct sk_buff_head	queue;
+	atomic_t		pending_frames;
 };
 
 struct wfx_queue_stats {

commit b6ef154973384439c663f8c5fde0eafa51e54309
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Wed Apr 1 13:03:53 2020 +0200

    staging: wfx: replace wfx_tx_queues_get_after_dtim() by wfx_tx_queues_has_cab()
    
    It is not necessary to return a skb. Just getting the information if
    there is traffic to be sent after DTIM is sufficient.
    
    In add, the acronym "cab" (Content After (DTIM) Beacon) is used in
    mac80211 to designate this kind of traffic.
    
    So, make wfx_tx_queues_get_after_dtim() return a boolean and rename
    accordingly.
    
    Reviewed-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200401110405.80282-21-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/queue.h b/drivers/staging/wfx/queue.h
index 39c265e4b86e..2c4724699ed0 100644
--- a/drivers/staging/wfx/queue.h
+++ b/drivers/staging/wfx/queue.h
@@ -36,9 +36,9 @@ void wfx_tx_queues_init(struct wfx_dev *wdev);
 void wfx_tx_queues_deinit(struct wfx_dev *wdev);
 void wfx_tx_queues_clear(struct wfx_dev *wdev);
 bool wfx_tx_queues_empty(struct wfx_dev *wdev);
+bool wfx_tx_queues_has_cab(struct wfx_vif *wvif);
 void wfx_tx_queues_wait_empty_vif(struct wfx_vif *wvif);
 struct hif_msg *wfx_tx_queues_get(struct wfx_dev *wdev);
-struct hif_msg *wfx_tx_queues_get_after_dtim(struct wfx_vif *wvif);
 
 void wfx_tx_queue_put(struct wfx_dev *wdev, struct wfx_queue *queue,
 		      struct sk_buff *skb);

commit f4a4fe570b8a36bcb2172fcf229284cd818a3240
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Wed Apr 1 13:03:50 2020 +0200

    staging: wfx: drop unused link_id field
    
    It is not used anymore.
    
    Reviewed-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200401110405.80282-18-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/queue.h b/drivers/staging/wfx/queue.h
index dd141cb4bf63..39c265e4b86e 100644
--- a/drivers/staging/wfx/queue.h
+++ b/drivers/staging/wfx/queue.h
@@ -14,8 +14,6 @@
 
 #define WFX_MAX_STA_IN_AP_MODE    14
 #define WFX_LINK_ID_NO_ASSOC      15
-#define WFX_LINK_ID_AFTER_DTIM    (WFX_LINK_ID_NO_ASSOC + 1)
-#define WFX_LINK_ID_UAPSD         (WFX_LINK_ID_NO_ASSOC + 2)
 
 struct wfx_dev;
 struct wfx_vif;

commit 9e76ba774445f87f4374244c791758e853f7e1e1
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Wed Apr 1 13:03:48 2020 +0200

    staging: wfx: drop useless link_map_cache
    
    Driver does not use link_map_cache anymore. So we can drop it. In add,
    we do not have to keep this counter in sync with skb_queue item, so we
    can drop explicit spin_locks.
    
    Reviewed-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200401110405.80282-16-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/queue.h b/drivers/staging/wfx/queue.h
index 58da216d47dd..dd141cb4bf63 100644
--- a/drivers/staging/wfx/queue.h
+++ b/drivers/staging/wfx/queue.h
@@ -16,18 +16,15 @@
 #define WFX_LINK_ID_NO_ASSOC      15
 #define WFX_LINK_ID_AFTER_DTIM    (WFX_LINK_ID_NO_ASSOC + 1)
 #define WFX_LINK_ID_UAPSD         (WFX_LINK_ID_NO_ASSOC + 2)
-#define WFX_LINK_ID_MAX           (WFX_LINK_ID_NO_ASSOC + 3)
 
 struct wfx_dev;
 struct wfx_vif;
 
 struct wfx_queue {
 	struct sk_buff_head	queue;
-	int			link_map_cache[WFX_LINK_ID_MAX];
 };
 
 struct wfx_queue_stats {
-	int			link_map_cache[WFX_LINK_ID_MAX];
 	struct sk_buff_head	pending;
 	wait_queue_head_t	wait_link_id_empty;
 };

commit af72697196dcb9d23484ae32ea096955f715c1d1
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Wed Apr 1 13:03:46 2020 +0200

    staging: wfx: drop argument tx_allowed_mask since it is constant now
    
    Following the remove of asleep_mask, the tx_allowed_mask argument passed
    to various functions is now always the same. Drop this argument and
    simplify the code.
    
    Reviewed-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200401110405.80282-14-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/queue.h b/drivers/staging/wfx/queue.h
index 5a5aa38dbb2f..58da216d47dd 100644
--- a/drivers/staging/wfx/queue.h
+++ b/drivers/staging/wfx/queue.h
@@ -47,7 +47,7 @@ struct hif_msg *wfx_tx_queues_get_after_dtim(struct wfx_vif *wvif);
 
 void wfx_tx_queue_put(struct wfx_dev *wdev, struct wfx_queue *queue,
 		      struct sk_buff *skb);
-int wfx_tx_queue_get_num_queued(struct wfx_queue *queue, u32 link_id_map);
+int wfx_tx_queue_get_num_queued(struct wfx_queue *queue);
 
 struct sk_buff *wfx_pending_get(struct wfx_dev *wdev, u32 packet_id);
 int wfx_pending_remove(struct wfx_dev *wdev, struct sk_buff *skb);

commit f42483f9efefd9ea0ea4eb054cd1e1923626e414
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Wed Apr 1 13:03:42 2020 +0200

    staging: wfx: simplify wfx_tx_queues_empty()
    
    Thanks to skb_queue_empty_lockless(), it is not necessary to acquire the
    spin_lock before to check if the queue is empty.
    
    Reviewed-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200401110405.80282-10-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/queue.h b/drivers/staging/wfx/queue.h
index 2284fa64b625..5a5aa38dbb2f 100644
--- a/drivers/staging/wfx/queue.h
+++ b/drivers/staging/wfx/queue.h
@@ -40,7 +40,7 @@ void wfx_tx_lock_flush(struct wfx_dev *wdev);
 void wfx_tx_queues_init(struct wfx_dev *wdev);
 void wfx_tx_queues_deinit(struct wfx_dev *wdev);
 void wfx_tx_queues_clear(struct wfx_dev *wdev);
-bool wfx_tx_queues_is_empty(struct wfx_dev *wdev);
+bool wfx_tx_queues_empty(struct wfx_dev *wdev);
 void wfx_tx_queues_wait_empty_vif(struct wfx_vif *wvif);
 struct hif_msg *wfx_tx_queues_get(struct wfx_dev *wdev);
 struct hif_msg *wfx_tx_queues_get_after_dtim(struct wfx_vif *wvif);

commit 70b727314f90765c9267e1e1882b5b01fba5201b
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Wed Apr 1 13:03:39 2020 +0200

    staging: wfx: drop useless queue_id field
    
    The field queue_id is no more used.
    
    Reviewed-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200401110405.80282-7-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/queue.h b/drivers/staging/wfx/queue.h
index 88ee2bf56d11..2284fa64b625 100644
--- a/drivers/staging/wfx/queue.h
+++ b/drivers/staging/wfx/queue.h
@@ -24,7 +24,6 @@ struct wfx_vif;
 struct wfx_queue {
 	struct sk_buff_head	queue;
 	int			link_map_cache[WFX_LINK_ID_MAX];
-	u8			queue_id;
 };
 
 struct wfx_queue_stats {

commit 055d20cf72fe90f5b3141e2d88b98f15e4e190c5
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Wed Apr 1 13:03:36 2020 +0200

    staging: wfx: take advantage of ieee80211_{stop/start}_queues
    
    Instead of maintaining stop status for each queue, we can just maintain
    a global status for all queues.
    
    In add, wfx_tx_queues_{lock/unlock} are only used when no more
    tx_policies are available. Therefore, the counter of recursive locks
    ("tx_locked_cnt") is useless.
    
    So, wfx_tx_queues_{lock/unlock} can be replaced by
    ieee80211_{stop/start}_queues.
    
    Reviewed-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200401110405.80282-4-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/queue.h b/drivers/staging/wfx/queue.h
index 90bb060d1204..88ee2bf56d11 100644
--- a/drivers/staging/wfx/queue.h
+++ b/drivers/staging/wfx/queue.h
@@ -23,7 +23,6 @@ struct wfx_vif;
 
 struct wfx_queue {
 	struct sk_buff_head	queue;
-	int			tx_locked_cnt;
 	int			link_map_cache[WFX_LINK_ID_MAX];
 	u8			queue_id;
 };
@@ -41,8 +40,6 @@ void wfx_tx_lock_flush(struct wfx_dev *wdev);
 
 void wfx_tx_queues_init(struct wfx_dev *wdev);
 void wfx_tx_queues_deinit(struct wfx_dev *wdev);
-void wfx_tx_queues_lock(struct wfx_dev *wdev);
-void wfx_tx_queues_unlock(struct wfx_dev *wdev);
 void wfx_tx_queues_clear(struct wfx_dev *wdev);
 bool wfx_tx_queues_is_empty(struct wfx_dev *wdev);
 void wfx_tx_queues_wait_empty_vif(struct wfx_vif *wvif);

commit 2f5fd8b07745838e590b61d5b136be8b9f94cc4c
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Wed Jan 15 13:55:35 2020 +0000

    staging: wfx: simplify wfx_tx_queue_get_num_queued()
    
    wfx_tx_queue_get_num_queued() can take advantage of BIT() instead of
    maintaining one variable for a counter and another for a mask.
    
    In add, wfx_tx_queue_get_num_queued() has no real reason to return a
    size_t instead of an int.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200115135338.14374-64-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/queue.h b/drivers/staging/wfx/queue.h
index 096ae86135cc..90bb060d1204 100644
--- a/drivers/staging/wfx/queue.h
+++ b/drivers/staging/wfx/queue.h
@@ -51,7 +51,7 @@ struct hif_msg *wfx_tx_queues_get_after_dtim(struct wfx_vif *wvif);
 
 void wfx_tx_queue_put(struct wfx_dev *wdev, struct wfx_queue *queue,
 		      struct sk_buff *skb);
-size_t wfx_tx_queue_get_num_queued(struct wfx_queue *queue, u32 link_id_map);
+int wfx_tx_queue_get_num_queued(struct wfx_queue *queue, u32 link_id_map);
 
 struct sk_buff *wfx_pending_get(struct wfx_dev *wdev, u32 packet_id);
 int wfx_pending_remove(struct wfx_dev *wdev, struct sk_buff *skb);

commit a3c529a835890b0eecd324d9f0c37c67345f84e2
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Wed Jan 15 13:55:25 2020 +0000

    staging: wfx: simplify handling of IEEE80211_TX_CTL_SEND_AFTER_DTIM
    
    When mac80211 ask for a frame to be sent after a DTIM, driver should:
      1. Update TIM with multicast bit set (using update_ie). This function
         can be called whenever.
      2. Keep buffered all frames marked "after dtim"
      3. When it receive a suspend_resume indication (see
         wfx_suspend_resume_mc()), send all the buffered frames. This
         indication is sent by the firmware 4ms before the dtim.
      4. If one of the frames returns status "REQUEUE", it means that the
         DTIM period was ended before to be able to send the frame.
      5. When all the buffered frames were sent or if DTIM period was ended,
         driver should update the TIM with multicast bit reset.
    
    All the mess with the asynchronous works can be dropped.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200115135338.14374-58-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/queue.h b/drivers/staging/wfx/queue.h
index 813c2d09e034..096ae86135cc 100644
--- a/drivers/staging/wfx/queue.h
+++ b/drivers/staging/wfx/queue.h
@@ -47,6 +47,7 @@ void wfx_tx_queues_clear(struct wfx_dev *wdev);
 bool wfx_tx_queues_is_empty(struct wfx_dev *wdev);
 void wfx_tx_queues_wait_empty_vif(struct wfx_vif *wvif);
 struct hif_msg *wfx_tx_queues_get(struct wfx_dev *wdev);
+struct hif_msg *wfx_tx_queues_get_after_dtim(struct wfx_vif *wvif);
 
 void wfx_tx_queue_put(struct wfx_dev *wdev, struct wfx_queue *queue,
 		      struct sk_buff *skb);

commit d6aeba575f277104a95125584981d37c8f7cf762
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Wed Jan 15 13:55:15 2020 +0000

    staging: wfx: simplify the link-id allocation
    
    The "link-id" is a slot number provided to the chip. A link-id is
    allocated to every station associated with the chip (mainly when the
    chip is in AP mode). It is more or less the same thing than the
    association ID, but it is limited to 14 values.
    
    Firmware uses the link-id to track the power save status of the
    stations.
    
    The current code try to associate a link-id as soon as data are
    exchanged with station. It is far easier to rely on sta_add() and
    sta_remove().
    
    Until now the value WFX_LINK_ID_NO_ASSOC, was only used when no more
    link-id was available. Now, we also use this value for
    not-yet-associated stations (that was its primary behavior).
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200115135338.14374-51-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/queue.h b/drivers/staging/wfx/queue.h
index 21566e48b2c2..813c2d09e034 100644
--- a/drivers/staging/wfx/queue.h
+++ b/drivers/staging/wfx/queue.h
@@ -13,9 +13,10 @@
 #include "hif_api_cmd.h"
 
 #define WFX_MAX_STA_IN_AP_MODE    14
-#define WFX_LINK_ID_AFTER_DTIM    (WFX_MAX_STA_IN_AP_MODE + 1)
-#define WFX_LINK_ID_UAPSD         (WFX_MAX_STA_IN_AP_MODE + 2)
-#define WFX_LINK_ID_MAX           (WFX_MAX_STA_IN_AP_MODE + 3)
+#define WFX_LINK_ID_NO_ASSOC      15
+#define WFX_LINK_ID_AFTER_DTIM    (WFX_LINK_ID_NO_ASSOC + 1)
+#define WFX_LINK_ID_UAPSD         (WFX_LINK_ID_NO_ASSOC + 2)
+#define WFX_LINK_ID_MAX           (WFX_LINK_ID_NO_ASSOC + 3)
 
 struct wfx_dev;
 struct wfx_vif;

commit 8c7128c4cf4e0e6eb67bd65b4dbe619c3d297bb6
Author: Jules Irenge <jbi.octave@gmail.com>
Date:   Wed Nov 13 11:00:52 2019 +0000

    staging: align to fix warnings of line over 80 characters
    
    Align to fix multiple warnings of line over 80 characters.
    Issue detected by checkpatch tool.
    
    Signed-off-by: Jules Irenge <jbi.octave@gmail.com>
    Link: https://lore.kernel.org/r/20191113110052.14855-1-jbi.octave@gmail.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/queue.h b/drivers/staging/wfx/queue.h
index 938dbf3469e7..21566e48b2c2 100644
--- a/drivers/staging/wfx/queue.h
+++ b/drivers/staging/wfx/queue.h
@@ -47,13 +47,15 @@ bool wfx_tx_queues_is_empty(struct wfx_dev *wdev);
 void wfx_tx_queues_wait_empty_vif(struct wfx_vif *wvif);
 struct hif_msg *wfx_tx_queues_get(struct wfx_dev *wdev);
 
-void wfx_tx_queue_put(struct wfx_dev *wdev, struct wfx_queue *queue, struct sk_buff *skb);
+void wfx_tx_queue_put(struct wfx_dev *wdev, struct wfx_queue *queue,
+		      struct sk_buff *skb);
 size_t wfx_tx_queue_get_num_queued(struct wfx_queue *queue, u32 link_id_map);
 
 struct sk_buff *wfx_pending_get(struct wfx_dev *wdev, u32 packet_id);
 int wfx_pending_remove(struct wfx_dev *wdev, struct sk_buff *skb);
 int wfx_pending_requeue(struct wfx_dev *wdev, struct sk_buff *skb);
-unsigned int wfx_pending_get_pkt_us_delay(struct wfx_dev *wdev, struct sk_buff *skb);
+unsigned int wfx_pending_get_pkt_us_delay(struct wfx_dev *wdev,
+					  struct sk_buff *skb);
 void wfx_pending_dump_old_frames(struct wfx_dev *wdev, unsigned int limit_ms);
 
 #endif /* WFX_QUEUE_H */

commit 9bca45f3d6924f19f29c0d019e961af3f41bdc9e
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Thu Sep 19 14:25:45 2019 +0000

    staging: wfx: allow to send 802.11 frames
    
    Three things make this task more complex than it should:
      - Chip necessitate to associate a link-id to each station. It is same
        thing than association ID but, using 8 bits only.
      - Rate policy is sent separately from Tx frames
      - Driver try to handle itself power saving of stations and multicast
        data
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20190919142527.31797-17-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/queue.h b/drivers/staging/wfx/queue.h
new file mode 100644
index 000000000000..938dbf3469e7
--- /dev/null
+++ b/drivers/staging/wfx/queue.h
@@ -0,0 +1,59 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * O(1) TX queue with built-in allocator.
+ *
+ * Copyright (c) 2017-2018, Silicon Laboratories, Inc.
+ * Copyright (c) 2010, ST-Ericsson
+ */
+#ifndef WFX_QUEUE_H
+#define WFX_QUEUE_H
+
+#include <linux/skbuff.h>
+
+#include "hif_api_cmd.h"
+
+#define WFX_MAX_STA_IN_AP_MODE    14
+#define WFX_LINK_ID_AFTER_DTIM    (WFX_MAX_STA_IN_AP_MODE + 1)
+#define WFX_LINK_ID_UAPSD         (WFX_MAX_STA_IN_AP_MODE + 2)
+#define WFX_LINK_ID_MAX           (WFX_MAX_STA_IN_AP_MODE + 3)
+
+struct wfx_dev;
+struct wfx_vif;
+
+struct wfx_queue {
+	struct sk_buff_head	queue;
+	int			tx_locked_cnt;
+	int			link_map_cache[WFX_LINK_ID_MAX];
+	u8			queue_id;
+};
+
+struct wfx_queue_stats {
+	int			link_map_cache[WFX_LINK_ID_MAX];
+	struct sk_buff_head	pending;
+	wait_queue_head_t	wait_link_id_empty;
+};
+
+void wfx_tx_lock(struct wfx_dev *wdev);
+void wfx_tx_unlock(struct wfx_dev *wdev);
+void wfx_tx_flush(struct wfx_dev *wdev);
+void wfx_tx_lock_flush(struct wfx_dev *wdev);
+
+void wfx_tx_queues_init(struct wfx_dev *wdev);
+void wfx_tx_queues_deinit(struct wfx_dev *wdev);
+void wfx_tx_queues_lock(struct wfx_dev *wdev);
+void wfx_tx_queues_unlock(struct wfx_dev *wdev);
+void wfx_tx_queues_clear(struct wfx_dev *wdev);
+bool wfx_tx_queues_is_empty(struct wfx_dev *wdev);
+void wfx_tx_queues_wait_empty_vif(struct wfx_vif *wvif);
+struct hif_msg *wfx_tx_queues_get(struct wfx_dev *wdev);
+
+void wfx_tx_queue_put(struct wfx_dev *wdev, struct wfx_queue *queue, struct sk_buff *skb);
+size_t wfx_tx_queue_get_num_queued(struct wfx_queue *queue, u32 link_id_map);
+
+struct sk_buff *wfx_pending_get(struct wfx_dev *wdev, u32 packet_id);
+int wfx_pending_remove(struct wfx_dev *wdev, struct sk_buff *skb);
+int wfx_pending_requeue(struct wfx_dev *wdev, struct sk_buff *skb);
+unsigned int wfx_pending_get_pkt_us_delay(struct wfx_dev *wdev, struct sk_buff *skb);
+void wfx_pending_dump_old_frames(struct wfx_dev *wdev, unsigned int limit_ms);
+
+#endif /* WFX_QUEUE_H */
