commit 8cf509345096340416708d998bbb71a27c883880
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Fri May 29 14:16:03 2020 +0200

    staging: wfx: drop useless loop
    
    It is guarantee that the loop will stop at first iteration. So drop the
    loop.
    
    Fixes: 6bf418c50f98a ("staging: wfx: change the way to choose frame to send")
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200529121603.1050891-2-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/queue.c b/drivers/staging/wfx/queue.c
index 75df4aca29ac..93ea2b72febd 100644
--- a/drivers/staging/wfx/queue.c
+++ b/drivers/staging/wfx/queue.c
@@ -291,15 +291,12 @@ struct hif_msg *wfx_tx_queues_get(struct wfx_dev *wdev)
 
 	if (atomic_read(&wdev->tx_lock))
 		return NULL;
-
-	for (;;) {
-		skb = wfx_tx_queues_get_skb(wdev);
-		if (!skb)
-			return NULL;
-		skb_queue_tail(&wdev->tx_pending, skb);
-		wake_up(&wdev->tx_dequeue);
-		tx_priv = wfx_skb_tx_priv(skb);
-		tx_priv->xmit_timestamp = ktime_get();
-		return (struct hif_msg *)skb->data;
-	}
+	skb = wfx_tx_queues_get_skb(wdev);
+	if (!skb)
+		return NULL;
+	skb_queue_tail(&wdev->tx_pending, skb);
+	wake_up(&wdev->tx_dequeue);
+	tx_priv = wfx_skb_tx_priv(skb);
+	tx_priv->xmit_timestamp = ktime_get();
+	return (struct hif_msg *)skb->data;
 }

commit 6a9620536ffd287c67997da3bf4a984d33e3a760
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Fri May 29 14:16:02 2020 +0200

    staging: wfx: fix AC priority
    
    In order to work properly all the queues of the device must be filled (the
    device chooses itself the queue to use depending of AC parameters and
    other things). It is the job of wfx_tx_queues_get_skb() to choose which
    queue must be filled. However, the sorting algorithm was inverted, so it
    prioritized the already filled queue! Consequently, the AC priorities was
    badly broken.
    
    Fixes: 6bf418c50f98a ("staging: wfx: change the way to choose frame to send")
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200529121603.1050891-1-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/queue.c b/drivers/staging/wfx/queue.c
index 3248ecefda56..75df4aca29ac 100644
--- a/drivers/staging/wfx/queue.c
+++ b/drivers/staging/wfx/queue.c
@@ -246,7 +246,7 @@ static struct sk_buff *wfx_tx_queues_get_skb(struct wfx_dev *wdev)
 	for (i = 0; i < IEEE80211_NUM_ACS; i++) {
 		sorted_queues[i] = &wdev->tx_queue[i];
 		for (j = i; j > 0; j--)
-			if (atomic_read(&sorted_queues[j]->pending_frames) >
+			if (atomic_read(&sorted_queues[j]->pending_frames) <
 			    atomic_read(&sorted_queues[j - 1]->pending_frames))
 				swap(sorted_queues[j - 1], sorted_queues[j]);
 	}

commit be2e96222fb69b6e0c38888f10824200124c6d0d
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Tue May 26 19:18:14 2020 +0200

    staging: wfx: drop unused function wfx_pending_requeue()
    
    The function wfx_pending_requeue() is not used anymore since the
    commit 7a44644c9379e ("staging: wfx: introduce
    wfx_set_default_unicast_key()")
    
    Fixes: 7a44644c9379e ("staging: wfx: introduce wfx_set_default_unicast_key()")
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200526171821.934581-4-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/queue.c b/drivers/staging/wfx/queue.c
index 26b141cbd303..3248ecefda56 100644
--- a/drivers/staging/wfx/queue.c
+++ b/drivers/staging/wfx/queue.c
@@ -143,19 +143,6 @@ void wfx_tx_queues_put(struct wfx_dev *wdev, struct sk_buff *skb)
 		skb_queue_tail(&queue->normal, skb);
 }
 
-int wfx_pending_requeue(struct wfx_dev *wdev, struct sk_buff *skb)
-{
-	struct wfx_queue *queue = &wdev->tx_queue[skb_get_queue_mapping(skb)];
-
-	WARN_ON(skb_get_queue_mapping(skb) > 3);
-	WARN_ON(!atomic_read(&queue->pending_frames));
-
-	atomic_dec(&queue->pending_frames);
-	skb_unlink(skb, &wdev->tx_pending);
-	wfx_tx_queues_put(wdev, skb);
-	return 0;
-}
-
 void wfx_pending_drop(struct wfx_dev *wdev, struct sk_buff_head *dropped)
 {
 	struct wfx_queue *queue;

commit 7c5fc1d88c1e91b3319145fe30f291a2cb9b393a
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Fri May 15 10:33:23 2020 +0200

    staging: wfx: remove false-positive WARN()
    
    The function wfx_tx_flush() wait for there is no more queued frames in
    hardware queue. Then, for the sanity, it checks that there is no more
    pending frame on any AC queue.
    
    However, there is a race here. It may happens that hardware queues are
    empty, but the counters of the AC queues are not yet updated. So, it may
    produce false-positive warning.
    
    The easiest way to solve the problem is just to remove the sanity check.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200515083325.378539-18-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/queue.c b/drivers/staging/wfx/queue.c
index 0c799cedd101..26b141cbd303 100644
--- a/drivers/staging/wfx/queue.c
+++ b/drivers/staging/wfx/queue.c
@@ -30,7 +30,6 @@ void wfx_tx_unlock(struct wfx_dev *wdev)
 void wfx_tx_flush(struct wfx_dev *wdev)
 {
 	int ret;
-	int i;
 
 	// Do not wait for any reply if chip is frozen
 	if (wdev->chip_frozen)
@@ -41,12 +40,6 @@ void wfx_tx_flush(struct wfx_dev *wdev)
 	ret = wait_event_timeout(wdev->hif.tx_buffers_empty,
 				 !wdev->hif.tx_buffers_used,
 				 msecs_to_jiffies(3000));
-	if (ret) {
-		for (i = 0; i < IEEE80211_NUM_ACS; i++)
-			WARN(atomic_read(&wdev->tx_queue[i].pending_frames),
-			     "there are still %d pending frames on queue %d",
-			     atomic_read(&wdev->tx_queue[i].pending_frames), i);
-	}
 	if (!ret) {
 		dev_warn(wdev->dev, "cannot flush tx buffers (%d still busy)\n",
 			 wdev->hif.tx_buffers_used);

commit 18f0dddf1fe1d16405bb845da96c03cb4b340ad0
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Mon Apr 27 15:40:16 2020 +0200

    staging: wfx: change the field chip_frozen into a boolean
    
    The field chip_frozen is declared as an integer, but it is only used as
    a boolean. So, convert it into a boolean.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200427134031.323403-3-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/queue.c b/drivers/staging/wfx/queue.c
index 2f6f9faf15be..0c799cedd101 100644
--- a/drivers/staging/wfx/queue.c
+++ b/drivers/staging/wfx/queue.c
@@ -52,7 +52,7 @@ void wfx_tx_flush(struct wfx_dev *wdev)
 			 wdev->hif.tx_buffers_used);
 		wfx_pending_dump_old_frames(wdev, 3000);
 		// FIXME: drop pending frames here
-		wdev->chip_frozen = 1;
+		wdev->chip_frozen = true;
 	}
 	mutex_unlock(&wdev->hif_cmd.lock);
 	wfx_tx_unlock(wdev);

commit 7a44644c9379eb1bbb03ce8054a0b0179f470146
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Mon Apr 20 18:03:05 2020 +0200

    staging: wfx: introduce wfx_set_default_unicast_key()
    
    Currently code handle WEP keys manually. It is far easier to use
    the set_default_unicast_key() callback provided by mac80211.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200420160311.57323-11-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/queue.c b/drivers/staging/wfx/queue.c
index e9573e9d009f..2f6f9faf15be 100644
--- a/drivers/staging/wfx/queue.c
+++ b/drivers/staging/wfx/queue.c
@@ -254,36 +254,6 @@ bool wfx_tx_queues_has_cab(struct wfx_vif *wvif)
 	return false;
 }
 
-static bool wfx_handle_tx_data(struct wfx_dev *wdev, struct sk_buff *skb)
-{
-	struct hif_req_tx *req = wfx_skb_txreq(skb);
-	struct ieee80211_key_conf *hw_key = wfx_skb_tx_priv(skb)->hw_key;
-	struct ieee80211_hdr *frame =
-		(struct ieee80211_hdr *)(req->frame + req->data_flags.fc_offset);
-	struct wfx_vif *wvif =
-		wdev_to_wvif(wdev, ((struct hif_msg *)skb->data)->interface);
-
-	if (!wvif)
-		return false;
-
-	// FIXME: identify the exact scenario matched by this condition. Does it
-	// happen yet?
-	if (ieee80211_has_protected(frame->frame_control) &&
-	    hw_key && hw_key->keyidx != wvif->wep_default_key_id &&
-	    (hw_key->cipher == WLAN_CIPHER_SUITE_WEP40 ||
-	     hw_key->cipher == WLAN_CIPHER_SUITE_WEP104)) {
-		wfx_tx_lock(wdev);
-		WARN_ON(wvif->wep_pending_skb);
-		wvif->wep_default_key_id = hw_key->keyidx;
-		wvif->wep_pending_skb = skb;
-		if (!schedule_work(&wvif->wep_key_work))
-			wfx_tx_unlock(wdev);
-		return true;
-	} else {
-		return false;
-	}
-}
-
 static struct sk_buff *wfx_tx_queues_get_skb(struct wfx_dev *wdev)
 {
 	struct wfx_queue *sorted_queues[IEEE80211_NUM_ACS];
@@ -348,9 +318,6 @@ struct hif_msg *wfx_tx_queues_get(struct wfx_dev *wdev)
 			return NULL;
 		skb_queue_tail(&wdev->tx_pending, skb);
 		wake_up(&wdev->tx_dequeue);
-		// FIXME: is it useful?
-		if (wfx_handle_tx_data(wdev, skb))
-			continue;
 		tx_priv = wfx_skb_tx_priv(skb);
 		tx_priv->xmit_timestamp = ktime_get();
 		return (struct hif_msg *)skb->data;

commit 5a0af69888488d2b873f55bcba4cd17b162e4bea
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Mon Apr 20 18:02:57 2020 +0200

    staging: wfx: use ieee80211_beacon_loss() provided by mac80211
    
    The firmware is able to filter beacons and send a notification if one or
    multiple beacons are not received. Note that it send this notification
    only once. Only if it receive beacons gain, it send a new notification.
    
    Currently, the driver handle the connection loss itself (see
    wfx_cqm_bssloss_sm()). It send null frames and watch the answers.
    
    This patch fixes all this mess:
      - settle firmware to send a notification on the first beacon loss
      - call ieee80211_beacon_loss() and let mac80211 handle all the process
      - since we do have notification for each beacon loss, add a period
        task that call ieee80211_beacon_loss() until we receive "REGAIN"
        notification.
    
    Thus, we can drop the ugly wfx_cqm_bssloss_sm() and
    wfx_bss_params_work().
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200420160311.57323-3-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/queue.c b/drivers/staging/wfx/queue.c
index e6d7d0e45156..e9573e9d009f 100644
--- a/drivers/staging/wfx/queue.c
+++ b/drivers/staging/wfx/queue.c
@@ -266,17 +266,6 @@ static bool wfx_handle_tx_data(struct wfx_dev *wdev, struct sk_buff *skb)
 	if (!wvif)
 		return false;
 
-	// FIXME: mac80211 is smart enough to handle BSS loss. Driver should not
-	// try to do anything about that.
-	if (ieee80211_is_nullfunc(frame->frame_control)) {
-		mutex_lock(&wvif->bss_loss_lock);
-		if (wvif->bss_loss_state) {
-			wvif->bss_loss_confirm_id = req->packet_id;
-			req->queue_id.queue_id = HIF_QUEUE_ID_VOICE;
-		}
-		mutex_unlock(&wvif->bss_loss_lock);
-	}
-
 	// FIXME: identify the exact scenario matched by this condition. Does it
 	// happen yet?
 	if (ieee80211_has_protected(frame->frame_control) &&

commit a39e761aa4fefa2a8aaf549217329933b91da7c9
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Wed Apr 1 13:04:03 2020 +0200

    staging: wfx: fix potential deadlock in wfx_tx_flush()
    
    wfx_tx_flush() wait there are no more frame in device buffer. However,
    this event may never happens since wfx_tx_flush() don't forbid to
    enqueue new frames.
    
    Note that wfx_tx_flush() should only ensure that all frames currently in
    hardware queues are sent. So the current code is more restrictive that
    it should.
    
    Note that wfx_tx_flush() release the lock before to return while
    wfx_tx_lock_flush() keep the lock.
    
    Reviewed-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200401110405.80282-31-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/queue.c b/drivers/staging/wfx/queue.c
index d4302a30dc41..e6d7d0e45156 100644
--- a/drivers/staging/wfx/queue.c
+++ b/drivers/staging/wfx/queue.c
@@ -36,6 +36,7 @@ void wfx_tx_flush(struct wfx_dev *wdev)
 	if (wdev->chip_frozen)
 		return;
 
+	wfx_tx_lock(wdev);
 	mutex_lock(&wdev->hif_cmd.lock);
 	ret = wait_event_timeout(wdev->hif.tx_buffers_empty,
 				 !wdev->hif.tx_buffers_used,
@@ -54,6 +55,7 @@ void wfx_tx_flush(struct wfx_dev *wdev)
 		wdev->chip_frozen = 1;
 	}
 	mutex_unlock(&wdev->hif_cmd.lock);
+	wfx_tx_unlock(wdev);
 }
 
 void wfx_tx_lock_flush(struct wfx_dev *wdev)

commit 4c6b3837c6dc0d9e5f9ec910da2e36349beea733
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Wed Apr 1 13:04:01 2020 +0200

    staging: wfx: repair wfx_flush()
    
    Until now, wfx_flush() flushed queue for while device instead of only
    the queue of the intended vif. It sometime failed with a timeout, but
    this error was not reported.
    
    Moreover, if the device was frozen, wfx_flush didn't do anything and it
    results a potential warning (and maybe a resource leak) when the frozen
    device was unregistered.
    
    We can also notice that wfx_tx_queues_wait_empty_vif() did only exist to
    work around the broken feature of wfx_flush().
    
    This patch repair wfx_flush() and therefore drop
    wfx_tx_queues_wait_empty_vif().
    
    Reviewed-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200401110405.80282-29-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/queue.c b/drivers/staging/wfx/queue.c
index a1a2f7756a27..d4302a30dc41 100644
--- a/drivers/staging/wfx/queue.c
+++ b/drivers/staging/wfx/queue.c
@@ -62,92 +62,79 @@ void wfx_tx_lock_flush(struct wfx_dev *wdev)
 	wfx_tx_flush(wdev);
 }
 
-/* If successful, LOCKS the TX queue! */
-void wfx_tx_queues_wait_empty_vif(struct wfx_vif *wvif)
+void wfx_tx_queues_init(struct wfx_dev *wdev)
 {
 	int i;
-	bool done;
-	struct wfx_queue *queue;
-	struct sk_buff *item;
-	struct wfx_dev *wdev = wvif->wdev;
-	struct hif_msg *hif;
 
-	if (wvif->wdev->chip_frozen) {
-		wfx_tx_lock_flush(wdev);
-		wfx_tx_queues_clear(wdev);
-		return;
+	skb_queue_head_init(&wdev->tx_pending);
+	init_waitqueue_head(&wdev->tx_dequeue);
+	for (i = 0; i < IEEE80211_NUM_ACS; ++i) {
+		skb_queue_head_init(&wdev->tx_queue[i].normal);
+		skb_queue_head_init(&wdev->tx_queue[i].cab);
 	}
-
-	do {
-		done = true;
-		wfx_tx_lock_flush(wdev);
-		for (i = 0; i < IEEE80211_NUM_ACS && done; ++i) {
-			queue = &wdev->tx_queue[i];
-			spin_lock_bh(&queue->normal.lock);
-			skb_queue_walk(&queue->normal, item) {
-				hif = (struct hif_msg *)item->data;
-				if (hif->interface == wvif->id)
-					done = false;
-			}
-			spin_unlock_bh(&queue->normal.lock);
-			spin_lock_bh(&queue->cab.lock);
-			skb_queue_walk(&queue->cab, item) {
-				hif = (struct hif_msg *)item->data;
-				if (hif->interface == wvif->id)
-					done = false;
-			}
-			spin_unlock_bh(&queue->cab.lock);
-		}
-		if (!done) {
-			wfx_tx_unlock(wdev);
-			msleep(20);
-		}
-	} while (!done);
 }
 
-static void wfx_tx_queue_clear(struct wfx_dev *wdev, struct wfx_queue *queue,
-			       struct sk_buff_head *gc_list)
+void wfx_tx_queues_check_empty(struct wfx_dev *wdev)
 {
-	struct sk_buff *item;
+	int i;
 
-	while ((item = skb_dequeue(&queue->normal)) != NULL)
-		skb_queue_head(gc_list, item);
-	while ((item = skb_dequeue(&queue->cab)) != NULL)
-		skb_queue_head(gc_list, item);
+	WARN_ON(!skb_queue_empty_lockless(&wdev->tx_pending));
+	for (i = 0; i < IEEE80211_NUM_ACS; ++i) {
+		WARN_ON(atomic_read(&wdev->tx_queue[i].pending_frames));
+		WARN_ON(!skb_queue_empty_lockless(&wdev->tx_queue[i].normal));
+		WARN_ON(!skb_queue_empty_lockless(&wdev->tx_queue[i].cab));
+	}
 }
 
-void wfx_tx_queues_clear(struct wfx_dev *wdev)
+static bool __wfx_tx_queue_empty(struct wfx_dev *wdev,
+				 struct sk_buff_head *skb_queue, int vif_id)
 {
-	int i;
-	struct sk_buff *item;
-	struct sk_buff_head gc_list;
+	struct hif_msg *hif_msg;
+	struct sk_buff *skb;
 
-	skb_queue_head_init(&gc_list);
-	for (i = 0; i < IEEE80211_NUM_ACS; ++i)
-		wfx_tx_queue_clear(wdev, &wdev->tx_queue[i], &gc_list);
-	wake_up(&wdev->tx_dequeue);
-	while ((item = skb_dequeue(&gc_list)) != NULL)
-		wfx_skb_dtor(wdev, item);
+	spin_lock_bh(&skb_queue->lock);
+	skb_queue_walk(skb_queue, skb) {
+		hif_msg = (struct hif_msg *)skb->data;
+		if (vif_id < 0 || hif_msg->interface == vif_id) {
+			spin_unlock_bh(&skb_queue->lock);
+			return false;
+		}
+	}
+	spin_unlock_bh(&skb_queue->lock);
+	return true;
 }
 
-void wfx_tx_queues_init(struct wfx_dev *wdev)
+bool wfx_tx_queue_empty(struct wfx_dev *wdev,
+			struct wfx_queue *queue, int vif_id)
 {
-	int i;
-
-	memset(wdev->tx_queue, 0, sizeof(wdev->tx_queue));
-	skb_queue_head_init(&wdev->tx_pending);
-	init_waitqueue_head(&wdev->tx_dequeue);
+	return __wfx_tx_queue_empty(wdev, &queue->normal, vif_id) &&
+	       __wfx_tx_queue_empty(wdev, &queue->cab, vif_id);
+}
 
-	for (i = 0; i < IEEE80211_NUM_ACS; ++i) {
-		skb_queue_head_init(&wdev->tx_queue[i].normal);
-		skb_queue_head_init(&wdev->tx_queue[i].cab);
+static void __wfx_tx_queue_drop(struct wfx_dev *wdev,
+				struct sk_buff_head *skb_queue, int vif_id,
+				struct sk_buff_head *dropped)
+{
+	struct sk_buff *skb, *tmp;
+	struct hif_msg *hif_msg;
+
+	spin_lock_bh(&skb_queue->lock);
+	skb_queue_walk_safe(skb_queue, skb, tmp) {
+		hif_msg = (struct hif_msg *)skb->data;
+		if (vif_id < 0 || hif_msg->interface == vif_id) {
+			__skb_unlink(skb, skb_queue);
+			skb_queue_head(dropped, skb);
+		}
 	}
+	spin_unlock_bh(&skb_queue->lock);
 }
 
-void wfx_tx_queues_deinit(struct wfx_dev *wdev)
+void wfx_tx_queue_drop(struct wfx_dev *wdev, struct wfx_queue *queue,
+		       int vif_id, struct sk_buff_head *dropped)
 {
-	WARN_ON(!skb_queue_empty(&wdev->tx_pending));
-	wfx_tx_queues_clear(wdev);
+	__wfx_tx_queue_drop(wdev, &queue->cab, vif_id, dropped);
+	__wfx_tx_queue_drop(wdev, &queue->normal, vif_id, dropped);
+	wake_up(&wdev->tx_dequeue);
 }
 
 void wfx_tx_queues_put(struct wfx_dev *wdev, struct sk_buff *skb)
@@ -174,6 +161,22 @@ int wfx_pending_requeue(struct wfx_dev *wdev, struct sk_buff *skb)
 	return 0;
 }
 
+void wfx_pending_drop(struct wfx_dev *wdev, struct sk_buff_head *dropped)
+{
+	struct wfx_queue *queue;
+	struct sk_buff *skb;
+
+	WARN(!wdev->chip_frozen, "%s should only be used to recover a frozen device",
+	     __func__);
+	while ((skb = skb_dequeue(&wdev->tx_pending)) != NULL) {
+		queue = &wdev->tx_queue[skb_get_queue_mapping(skb)];
+		WARN_ON(skb_get_queue_mapping(skb) > 3);
+		WARN_ON(!atomic_read(&queue->pending_frames));
+		atomic_dec(&queue->pending_frames);
+		skb_queue_head(dropped, skb);
+	}
+}
+
 struct sk_buff *wfx_pending_get(struct wfx_dev *wdev, u32 packet_id)
 {
 	struct wfx_queue *queue;
@@ -249,17 +252,6 @@ bool wfx_tx_queues_has_cab(struct wfx_vif *wvif)
 	return false;
 }
 
-bool wfx_tx_queues_empty(struct wfx_dev *wdev)
-{
-	int i;
-
-	for (i = 0; i < IEEE80211_NUM_ACS; i++)
-		if (!skb_queue_empty_lockless(&wdev->tx_queue[i].normal) ||
-		    !skb_queue_empty_lockless(&wdev->tx_queue[i].cab))
-			return false;
-	return true;
-}
-
 static bool wfx_handle_tx_data(struct wfx_dev *wdev, struct sk_buff *skb)
 {
 	struct hif_req_tx *req = wfx_skb_txreq(skb);
@@ -364,8 +356,7 @@ struct hif_msg *wfx_tx_queues_get(struct wfx_dev *wdev)
 		if (!skb)
 			return NULL;
 		skb_queue_tail(&wdev->tx_pending, skb);
-		if (wfx_tx_queues_empty(wdev))
-			wake_up(&wdev->tx_dequeue);
+		wake_up(&wdev->tx_dequeue);
 		// FIXME: is it useful?
 		if (wfx_handle_tx_data(wdev, skb))
 			continue;

commit 39dbfa536b406fbe516e0ec7b571264ccf567edb
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Wed Apr 1 13:03:59 2020 +0200

    staging: wfx: improve interface between data_tx.c and queue.c
    
    Currently, wfx_pending_remove() (from queue.c) call wfx_skb_dtor()
    (from data_tx.c) that forward the tx status to mac80211.
    
    Moreover, there no purpose to retrieve a frame from the pending queue
    without dequeuing it. So, the main purpose of wfx_pending_remove() is to
    forward the tx status to mac80211.
    
    Let's make the architecture cleaner:
      - merge wfx_pending_remove() into wfx_pending_get()
      - call wfx_skb_dtor() from data_tx.c
    
    Reviewed-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200401110405.80282-27-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/queue.c b/drivers/staging/wfx/queue.c
index cc89bfe1dbb4..a1a2f7756a27 100644
--- a/drivers/staging/wfx/queue.c
+++ b/drivers/staging/wfx/queue.c
@@ -174,30 +174,22 @@ int wfx_pending_requeue(struct wfx_dev *wdev, struct sk_buff *skb)
 	return 0;
 }
 
-int wfx_pending_remove(struct wfx_dev *wdev, struct sk_buff *skb)
-{
-	struct wfx_queue *queue = &wdev->tx_queue[skb_get_queue_mapping(skb)];
-
-	WARN_ON(skb_get_queue_mapping(skb) > 3);
-	WARN_ON(!atomic_read(&queue->pending_frames));
-
-	atomic_dec(&queue->pending_frames);
-	skb_unlink(skb, &wdev->tx_pending);
-	wfx_skb_dtor(wdev, skb);
-
-	return 0;
-}
-
 struct sk_buff *wfx_pending_get(struct wfx_dev *wdev, u32 packet_id)
 {
-	struct sk_buff *skb;
+	struct wfx_queue *queue;
 	struct hif_req_tx *req;
+	struct sk_buff *skb;
 
 	spin_lock_bh(&wdev->tx_pending.lock);
 	skb_queue_walk(&wdev->tx_pending, skb) {
 		req = wfx_skb_txreq(skb);
 		if (req->packet_id == packet_id) {
 			spin_unlock_bh(&wdev->tx_pending.lock);
+			queue = &wdev->tx_queue[skb_get_queue_mapping(skb)];
+			WARN_ON(skb_get_queue_mapping(skb) > 3);
+			WARN_ON(!atomic_read(&queue->pending_frames));
+			atomic_dec(&queue->pending_frames);
+			skb_unlink(skb, &wdev->tx_pending);
 			return skb;
 		}
 	}

commit cb851c867dc07aa643f8a9a1be4092775bae7532
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Wed Apr 1 13:03:58 2020 +0200

    staging: wfx: simplify usage of wfx_tx_queues_put()
    
    The queue used for wfx_tx_queue_put() can be deducted from the content
    of the skb. So drop this parameter from call to wfx_tx_queues_put().
    
    In add, this change uniformizes usage of functions wfx_tx_queues_*.
    
    Reviewed-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200401110405.80282-26-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/queue.c b/drivers/staging/wfx/queue.c
index a03860db2f54..cc89bfe1dbb4 100644
--- a/drivers/staging/wfx/queue.c
+++ b/drivers/staging/wfx/queue.c
@@ -150,9 +150,9 @@ void wfx_tx_queues_deinit(struct wfx_dev *wdev)
 	wfx_tx_queues_clear(wdev);
 }
 
-void wfx_tx_queue_put(struct wfx_dev *wdev, struct wfx_queue *queue,
-		      struct sk_buff *skb)
+void wfx_tx_queues_put(struct wfx_dev *wdev, struct sk_buff *skb)
 {
+	struct wfx_queue *queue = &wdev->tx_queue[skb_get_queue_mapping(skb)];
 	struct ieee80211_tx_info *tx_info = IEEE80211_SKB_CB(skb);
 
 	if (tx_info->flags & IEEE80211_TX_CTL_SEND_AFTER_DTIM)
@@ -170,7 +170,7 @@ int wfx_pending_requeue(struct wfx_dev *wdev, struct sk_buff *skb)
 
 	atomic_dec(&queue->pending_frames);
 	skb_unlink(skb, &wdev->tx_pending);
-	wfx_tx_queue_put(wdev, queue, skb);
+	wfx_tx_queues_put(wdev, skb);
 	return 0;
 }
 

commit d32cedbec0a64e24548986a0159ab86cfe6a4097
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Wed Apr 1 13:03:57 2020 +0200

    staging: wfx: drop struct wfx_queue_stats
    
    There is no reason to keep the intermediate struct wfx_queue_stats.
    Relocate its members to struct wfx_dev.
    
    Reviewed-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200401110405.80282-25-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/queue.c b/drivers/staging/wfx/queue.c
index b45fb837f1cd..a03860db2f54 100644
--- a/drivers/staging/wfx/queue.c
+++ b/drivers/staging/wfx/queue.c
@@ -121,12 +121,11 @@ void wfx_tx_queues_clear(struct wfx_dev *wdev)
 	int i;
 	struct sk_buff *item;
 	struct sk_buff_head gc_list;
-	struct wfx_queue_stats *stats = &wdev->tx_queue_stats;
 
 	skb_queue_head_init(&gc_list);
 	for (i = 0; i < IEEE80211_NUM_ACS; ++i)
 		wfx_tx_queue_clear(wdev, &wdev->tx_queue[i], &gc_list);
-	wake_up(&stats->wait_link_id_empty);
+	wake_up(&wdev->tx_dequeue);
 	while ((item = skb_dequeue(&gc_list)) != NULL)
 		wfx_skb_dtor(wdev, item);
 }
@@ -135,10 +134,9 @@ void wfx_tx_queues_init(struct wfx_dev *wdev)
 {
 	int i;
 
-	memset(&wdev->tx_queue_stats, 0, sizeof(wdev->tx_queue_stats));
 	memset(wdev->tx_queue, 0, sizeof(wdev->tx_queue));
-	skb_queue_head_init(&wdev->tx_queue_stats.pending);
-	init_waitqueue_head(&wdev->tx_queue_stats.wait_link_id_empty);
+	skb_queue_head_init(&wdev->tx_pending);
+	init_waitqueue_head(&wdev->tx_dequeue);
 
 	for (i = 0; i < IEEE80211_NUM_ACS; ++i) {
 		skb_queue_head_init(&wdev->tx_queue[i].normal);
@@ -148,7 +146,7 @@ void wfx_tx_queues_init(struct wfx_dev *wdev)
 
 void wfx_tx_queues_deinit(struct wfx_dev *wdev)
 {
-	WARN_ON(!skb_queue_empty(&wdev->tx_queue_stats.pending));
+	WARN_ON(!skb_queue_empty(&wdev->tx_pending));
 	wfx_tx_queues_clear(wdev);
 }
 
@@ -165,28 +163,26 @@ void wfx_tx_queue_put(struct wfx_dev *wdev, struct wfx_queue *queue,
 
 int wfx_pending_requeue(struct wfx_dev *wdev, struct sk_buff *skb)
 {
-	struct wfx_queue_stats *stats = &wdev->tx_queue_stats;
 	struct wfx_queue *queue = &wdev->tx_queue[skb_get_queue_mapping(skb)];
 
 	WARN_ON(skb_get_queue_mapping(skb) > 3);
 	WARN_ON(!atomic_read(&queue->pending_frames));
 
 	atomic_dec(&queue->pending_frames);
-	skb_unlink(skb, &stats->pending);
+	skb_unlink(skb, &wdev->tx_pending);
 	wfx_tx_queue_put(wdev, queue, skb);
 	return 0;
 }
 
 int wfx_pending_remove(struct wfx_dev *wdev, struct sk_buff *skb)
 {
-	struct wfx_queue_stats *stats = &wdev->tx_queue_stats;
 	struct wfx_queue *queue = &wdev->tx_queue[skb_get_queue_mapping(skb)];
 
 	WARN_ON(skb_get_queue_mapping(skb) > 3);
 	WARN_ON(!atomic_read(&queue->pending_frames));
 
 	atomic_dec(&queue->pending_frames);
-	skb_unlink(skb, &stats->pending);
+	skb_unlink(skb, &wdev->tx_pending);
 	wfx_skb_dtor(wdev, skb);
 
 	return 0;
@@ -196,32 +192,30 @@ struct sk_buff *wfx_pending_get(struct wfx_dev *wdev, u32 packet_id)
 {
 	struct sk_buff *skb;
 	struct hif_req_tx *req;
-	struct wfx_queue_stats *stats = &wdev->tx_queue_stats;
 
-	spin_lock_bh(&stats->pending.lock);
-	skb_queue_walk(&stats->pending, skb) {
+	spin_lock_bh(&wdev->tx_pending.lock);
+	skb_queue_walk(&wdev->tx_pending, skb) {
 		req = wfx_skb_txreq(skb);
 		if (req->packet_id == packet_id) {
-			spin_unlock_bh(&stats->pending.lock);
+			spin_unlock_bh(&wdev->tx_pending.lock);
 			return skb;
 		}
 	}
-	spin_unlock_bh(&stats->pending.lock);
+	spin_unlock_bh(&wdev->tx_pending.lock);
 	WARN(1, "cannot find packet in pending queue");
 	return NULL;
 }
 
 void wfx_pending_dump_old_frames(struct wfx_dev *wdev, unsigned int limit_ms)
 {
-	struct wfx_queue_stats *stats = &wdev->tx_queue_stats;
 	ktime_t now = ktime_get();
 	struct wfx_tx_priv *tx_priv;
 	struct hif_req_tx *req;
 	struct sk_buff *skb;
 	bool first = true;
 
-	spin_lock_bh(&stats->pending.lock);
-	skb_queue_walk(&stats->pending, skb) {
+	spin_lock_bh(&wdev->tx_pending.lock);
+	skb_queue_walk(&wdev->tx_pending, skb) {
 		tx_priv = wfx_skb_tx_priv(skb);
 		req = wfx_skb_txreq(skb);
 		if (ktime_after(now, ktime_add_ms(tx_priv->xmit_timestamp,
@@ -236,7 +230,7 @@ void wfx_pending_dump_old_frames(struct wfx_dev *wdev, unsigned int limit_ms)
 				 ktime_ms_delta(now, tx_priv->xmit_timestamp));
 		}
 	}
-	spin_unlock_bh(&stats->pending.lock);
+	spin_unlock_bh(&wdev->tx_pending.lock);
 }
 
 unsigned int wfx_pending_get_pkt_us_delay(struct wfx_dev *wdev,
@@ -377,9 +371,9 @@ struct hif_msg *wfx_tx_queues_get(struct wfx_dev *wdev)
 		skb = wfx_tx_queues_get_skb(wdev);
 		if (!skb)
 			return NULL;
-		skb_queue_tail(&wdev->tx_queue_stats.pending, skb);
+		skb_queue_tail(&wdev->tx_pending, skb);
 		if (wfx_tx_queues_empty(wdev))
-			wake_up(&wdev->tx_queue_stats.wait_link_id_empty);
+			wake_up(&wdev->tx_dequeue);
 		// FIXME: is it useful?
 		if (wfx_handle_tx_data(wdev, skb))
 			continue;

commit 6bf418c50f98a3ec0105d9e5b5b99a7772c47d87
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Wed Apr 1 13:03:55 2020 +0200

    staging: wfx: change the way to choose frame to send
    
    The current code computes itself the QoS policy to choose which frame
    should be sent. However, firmware already do that job. Firmware would
    prefer to have packets in every queues and be able to choose itself
    which queue to use.
    
    So, this patch sort the queues from the emptiest to the fulliest (thanks
    to the pending frames counter introduced a few commits earlier). It send
    frame to the least full queue.
    
    However, we continue to be careful with frames that have to be sent
    after a dtim ("cab": Content After (DTIM) Beacon).
    
    So, this patch splits AC queues in two skb_queues: one for normal frames
    and another for cab frames. It cares to send frames from CAB skb_queue
    if appropriate.
    
    Reviewed-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200401110405.80282-23-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/queue.c b/drivers/staging/wfx/queue.c
index 21a2c8aabbb9..b45fb837f1cd 100644
--- a/drivers/staging/wfx/queue.c
+++ b/drivers/staging/wfx/queue.c
@@ -83,13 +83,20 @@ void wfx_tx_queues_wait_empty_vif(struct wfx_vif *wvif)
 		wfx_tx_lock_flush(wdev);
 		for (i = 0; i < IEEE80211_NUM_ACS && done; ++i) {
 			queue = &wdev->tx_queue[i];
-			spin_lock_bh(&queue->queue.lock);
-			skb_queue_walk(&queue->queue, item) {
-				hif = (struct hif_msg *) item->data;
+			spin_lock_bh(&queue->normal.lock);
+			skb_queue_walk(&queue->normal, item) {
+				hif = (struct hif_msg *)item->data;
 				if (hif->interface == wvif->id)
 					done = false;
 			}
-			spin_unlock_bh(&queue->queue.lock);
+			spin_unlock_bh(&queue->normal.lock);
+			spin_lock_bh(&queue->cab.lock);
+			skb_queue_walk(&queue->cab, item) {
+				hif = (struct hif_msg *)item->data;
+				if (hif->interface == wvif->id)
+					done = false;
+			}
+			spin_unlock_bh(&queue->cab.lock);
 		}
 		if (!done) {
 			wfx_tx_unlock(wdev);
@@ -103,7 +110,9 @@ static void wfx_tx_queue_clear(struct wfx_dev *wdev, struct wfx_queue *queue,
 {
 	struct sk_buff *item;
 
-	while ((item = skb_dequeue(&queue->queue)) != NULL)
+	while ((item = skb_dequeue(&queue->normal)) != NULL)
+		skb_queue_head(gc_list, item);
+	while ((item = skb_dequeue(&queue->cab)) != NULL)
 		skb_queue_head(gc_list, item);
 }
 
@@ -131,8 +140,10 @@ void wfx_tx_queues_init(struct wfx_dev *wdev)
 	skb_queue_head_init(&wdev->tx_queue_stats.pending);
 	init_waitqueue_head(&wdev->tx_queue_stats.wait_link_id_empty);
 
-	for (i = 0; i < IEEE80211_NUM_ACS; ++i)
-		skb_queue_head_init(&wdev->tx_queue[i].queue);
+	for (i = 0; i < IEEE80211_NUM_ACS; ++i) {
+		skb_queue_head_init(&wdev->tx_queue[i].normal);
+		skb_queue_head_init(&wdev->tx_queue[i].cab);
+	}
 }
 
 void wfx_tx_queues_deinit(struct wfx_dev *wdev)
@@ -141,57 +152,15 @@ void wfx_tx_queues_deinit(struct wfx_dev *wdev)
 	wfx_tx_queues_clear(wdev);
 }
 
-int wfx_tx_queue_get_num_queued(struct wfx_queue *queue)
-{
-	struct ieee80211_tx_info *tx_info;
-	struct sk_buff *skb;
-	int ret = 0;
-
-	spin_lock_bh(&queue->queue.lock);
-	skb_queue_walk(&queue->queue, skb) {
-		tx_info = IEEE80211_SKB_CB(skb);
-		if (!(tx_info->flags & IEEE80211_TX_CTL_SEND_AFTER_DTIM))
-			ret++;
-	}
-	spin_unlock_bh(&queue->queue.lock);
-	return ret;
-}
-
 void wfx_tx_queue_put(struct wfx_dev *wdev, struct wfx_queue *queue,
 		      struct sk_buff *skb)
 {
-	skb_queue_tail(&queue->queue, skb);
-}
-
-static struct sk_buff *wfx_tx_queue_get(struct wfx_dev *wdev,
-					struct wfx_queue *queue,
-					bool mcast)
-{
-	struct wfx_queue_stats *stats = &wdev->tx_queue_stats;
-	struct ieee80211_tx_info *tx_info;
-	struct sk_buff *item, *skb = NULL;
-	struct wfx_tx_priv *tx_priv;
+	struct ieee80211_tx_info *tx_info = IEEE80211_SKB_CB(skb);
 
-	spin_lock_bh(&queue->queue.lock);
-	skb_queue_walk(&queue->queue, item) {
-		tx_info = IEEE80211_SKB_CB(item);
-		if (mcast == !!(tx_info->flags & IEEE80211_TX_CTL_SEND_AFTER_DTIM)) {
-			skb = item;
-			break;
-		}
-	}
-	spin_unlock_bh(&queue->queue.lock);
-	if (skb) {
-		skb_unlink(skb, &queue->queue);
-		atomic_inc(&queue->pending_frames);
-		tx_priv = wfx_skb_tx_priv(skb);
-		tx_priv->xmit_timestamp = ktime_get();
-		skb_queue_tail(&stats->pending, skb);
-		if (skb_queue_empty(&queue->queue))
-			wake_up(&stats->wait_link_id_empty);
-		return skb;
-	}
-	return skb;
+	if (tx_info->flags & IEEE80211_TX_CTL_SEND_AFTER_DTIM)
+		skb_queue_tail(&queue->cab, skb);
+	else
+		skb_queue_tail(&queue->normal, skb);
 }
 
 int wfx_pending_requeue(struct wfx_dev *wdev, struct sk_buff *skb)
@@ -204,7 +173,7 @@ int wfx_pending_requeue(struct wfx_dev *wdev, struct sk_buff *skb)
 
 	atomic_dec(&queue->pending_frames);
 	skb_unlink(skb, &stats->pending);
-	skb_queue_tail(&queue->queue, skb);
+	wfx_tx_queue_put(wdev, queue, skb);
 	return 0;
 }
 
@@ -282,20 +251,15 @@ unsigned int wfx_pending_get_pkt_us_delay(struct wfx_dev *wdev,
 bool wfx_tx_queues_has_cab(struct wfx_vif *wvif)
 {
 	struct wfx_dev *wdev = wvif->wdev;
-	struct ieee80211_tx_info *tx_info;
-	struct hif_msg *hif;
-	struct sk_buff *skb;
 	int i;
 
-	for (i = 0; i < IEEE80211_NUM_ACS; ++i) {
-		skb_queue_walk(&wdev->tx_queue[i].queue, skb) {
-			tx_info = IEEE80211_SKB_CB(skb);
-			hif = (struct hif_msg *)skb->data;
-			if ((tx_info->flags & IEEE80211_TX_CTL_SEND_AFTER_DTIM) &&
-			    (hif->interface == wvif->id))
-				return true;
-		}
-	}
+	if (wvif->vif->type != NL80211_IFTYPE_AP)
+		return false;
+	for (i = 0; i < IEEE80211_NUM_ACS; ++i)
+		// Note: since only AP can have mcast frames in queue and only
+		// one vif can be AP, all queued frames has same interface id
+		if (!skb_queue_empty_lockless(&wdev->tx_queue[i].cab))
+			return true;
 	return false;
 }
 
@@ -304,7 +268,8 @@ bool wfx_tx_queues_empty(struct wfx_dev *wdev)
 	int i;
 
 	for (i = 0; i < IEEE80211_NUM_ACS; i++)
-		if (!skb_queue_empty_lockless(&wdev->tx_queue[i].queue))
+		if (!skb_queue_empty_lockless(&wdev->tx_queue[i].normal) ||
+		    !skb_queue_empty_lockless(&wdev->tx_queue[i].cab))
 			return false;
 	return true;
 }
@@ -350,95 +315,76 @@ static bool wfx_handle_tx_data(struct wfx_dev *wdev, struct sk_buff *skb)
 	}
 }
 
-static struct wfx_queue *wfx_tx_queue_mask_get(struct wfx_vif *wvif)
+static struct sk_buff *wfx_tx_queues_get_skb(struct wfx_dev *wdev)
 {
-	const struct ieee80211_tx_queue_params *edca;
-	unsigned int score, best = -1;
-	int winner = -1;
-	int i;
-
-	/* search for a winner using edca params */
-	for (i = 0; i < IEEE80211_NUM_ACS; ++i) {
-		int queued;
-
-		edca = &wvif->edca_params[i];
-		queued = wfx_tx_queue_get_num_queued(&wvif->wdev->tx_queue[i]);
-		if (!queued)
+	struct wfx_queue *sorted_queues[IEEE80211_NUM_ACS];
+	struct wfx_vif *wvif;
+	struct hif_msg *hif;
+	struct sk_buff *skb;
+	int i, j;
+
+	// bubble sort
+	for (i = 0; i < IEEE80211_NUM_ACS; i++) {
+		sorted_queues[i] = &wdev->tx_queue[i];
+		for (j = i; j > 0; j--)
+			if (atomic_read(&sorted_queues[j]->pending_frames) >
+			    atomic_read(&sorted_queues[j - 1]->pending_frames))
+				swap(sorted_queues[j - 1], sorted_queues[j]);
+	}
+	wvif = NULL;
+	while ((wvif = wvif_iterate(wdev, wvif)) != NULL) {
+		if (!wvif->after_dtim_tx_allowed)
 			continue;
-		score = ((edca->aifs + edca->cw_min) << 16) +
-			((edca->cw_max - edca->cw_min) *
-			 (get_random_int() & 0xFFFF));
-		if (score < best && (winner < 0 || i != 3)) {
-			best = score;
-			winner = i;
+		for (i = 0; i < IEEE80211_NUM_ACS; i++) {
+			skb = skb_dequeue(&sorted_queues[i]->cab);
+			if (!skb)
+				continue;
+			// Note: since only AP can have mcast frames in queue
+			// and only one vif can be AP, all queued frames has
+			// same interface id
+			hif = (struct hif_msg *)skb->data;
+			WARN_ON(hif->interface != wvif->id);
+			WARN_ON(sorted_queues[i] !=
+				&wdev->tx_queue[skb_get_queue_mapping(skb)]);
+			atomic_inc(&sorted_queues[i]->pending_frames);
+			return skb;
 		}
+		// No more multicast to sent
+		wvif->after_dtim_tx_allowed = false;
+		schedule_work(&wvif->update_tim_work);
 	}
-
-	if (winner < 0)
-		return NULL;
-	return &wvif->wdev->tx_queue[winner];
+	for (i = 0; i < IEEE80211_NUM_ACS; i++) {
+		skb = skb_dequeue(&sorted_queues[i]->normal);
+		if (skb) {
+			WARN_ON(sorted_queues[i] !=
+				&wdev->tx_queue[skb_get_queue_mapping(skb)]);
+			atomic_inc(&sorted_queues[i]->pending_frames);
+			return skb;
+		}
+	}
+	return NULL;
 }
 
 struct hif_msg *wfx_tx_queues_get(struct wfx_dev *wdev)
 {
+	struct wfx_tx_priv *tx_priv;
 	struct sk_buff *skb;
-	struct hif_msg *hif = NULL;
-	struct wfx_queue *queue = NULL;
-	struct wfx_queue *vif_queue = NULL;
-	struct wfx_vif *wvif;
-	int i;
 
 	if (atomic_read(&wdev->tx_lock))
 		return NULL;
 
-	wvif = NULL;
-	while ((wvif = wvif_iterate(wdev, wvif)) != NULL) {
-		if (wvif->after_dtim_tx_allowed) {
-			for (i = 0; i < IEEE80211_NUM_ACS; ++i) {
-				skb = wfx_tx_queue_get(wvif->wdev,
-						       &wdev->tx_queue[i],
-						       true);
-				if (skb) {
-					hif = (struct hif_msg *)skb->data;
-					// Cannot happen since only one vif can
-					// be AP at time
-					WARN_ON(wvif->id != hif->interface);
-					return hif;
-				}
-			}
-			// No more multicast to sent
-			wvif->after_dtim_tx_allowed = false;
-			schedule_work(&wvif->update_tim_work);
-		}
-	}
-
 	for (;;) {
-		int ret = -ENOENT;
-		int queue_num;
-
-		wvif = NULL;
-		while ((wvif = wvif_iterate(wdev, wvif)) != NULL) {
-			vif_queue = wfx_tx_queue_mask_get(wvif);
-			if (vif_queue) {
-				if (queue && queue != vif_queue)
-					dev_info(wdev->dev, "vifs disagree about queue priority\n");
-				queue = vif_queue;
-				ret = 0;
-			}
-		}
-
-		if (ret)
-			return NULL;
-
-		queue_num = queue - wdev->tx_queue;
-
-		skb = wfx_tx_queue_get(wdev, queue, false);
+		skb = wfx_tx_queues_get_skb(wdev);
 		if (!skb)
-			continue;
-
+			return NULL;
+		skb_queue_tail(&wdev->tx_queue_stats.pending, skb);
+		if (wfx_tx_queues_empty(wdev))
+			wake_up(&wdev->tx_queue_stats.wait_link_id_empty);
+		// FIXME: is it useful?
 		if (wfx_handle_tx_data(wdev, skb))
-			continue;  /* Handled by WSM */
-
+			continue;
+		tx_priv = wfx_skb_tx_priv(skb);
+		tx_priv->xmit_timestamp = ktime_get();
 		return (struct hif_msg *)skb->data;
 	}
 }

commit 7ba22b075422bb761f1fc26ff6dcb05eabed6e63
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Wed Apr 1 13:03:54 2020 +0200

    staging: wfx: introduce a counter of pending frames
    
    This counter will be useful to know which queue is least full in a
    further patch.
    
    Reviewed-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200401110405.80282-22-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/queue.c b/drivers/staging/wfx/queue.c
index 4ddb2c7370cd..21a2c8aabbb9 100644
--- a/drivers/staging/wfx/queue.c
+++ b/drivers/staging/wfx/queue.c
@@ -30,6 +30,7 @@ void wfx_tx_unlock(struct wfx_dev *wdev)
 void wfx_tx_flush(struct wfx_dev *wdev)
 {
 	int ret;
+	int i;
 
 	// Do not wait for any reply if chip is frozen
 	if (wdev->chip_frozen)
@@ -39,6 +40,12 @@ void wfx_tx_flush(struct wfx_dev *wdev)
 	ret = wait_event_timeout(wdev->hif.tx_buffers_empty,
 				 !wdev->hif.tx_buffers_used,
 				 msecs_to_jiffies(3000));
+	if (ret) {
+		for (i = 0; i < IEEE80211_NUM_ACS; i++)
+			WARN(atomic_read(&wdev->tx_queue[i].pending_frames),
+			     "there are still %d pending frames on queue %d",
+			     atomic_read(&wdev->tx_queue[i].pending_frames), i);
+	}
 	if (!ret) {
 		dev_warn(wdev->dev, "cannot flush tx buffers (%d still busy)\n",
 			 wdev->hif.tx_buffers_used);
@@ -176,6 +183,7 @@ static struct sk_buff *wfx_tx_queue_get(struct wfx_dev *wdev,
 	spin_unlock_bh(&queue->queue.lock);
 	if (skb) {
 		skb_unlink(skb, &queue->queue);
+		atomic_inc(&queue->pending_frames);
 		tx_priv = wfx_skb_tx_priv(skb);
 		tx_priv->xmit_timestamp = ktime_get();
 		skb_queue_tail(&stats->pending, skb);
@@ -192,7 +200,9 @@ int wfx_pending_requeue(struct wfx_dev *wdev, struct sk_buff *skb)
 	struct wfx_queue *queue = &wdev->tx_queue[skb_get_queue_mapping(skb)];
 
 	WARN_ON(skb_get_queue_mapping(skb) > 3);
+	WARN_ON(!atomic_read(&queue->pending_frames));
 
+	atomic_dec(&queue->pending_frames);
 	skb_unlink(skb, &stats->pending);
 	skb_queue_tail(&queue->queue, skb);
 	return 0;
@@ -201,7 +211,12 @@ int wfx_pending_requeue(struct wfx_dev *wdev, struct sk_buff *skb)
 int wfx_pending_remove(struct wfx_dev *wdev, struct sk_buff *skb)
 {
 	struct wfx_queue_stats *stats = &wdev->tx_queue_stats;
+	struct wfx_queue *queue = &wdev->tx_queue[skb_get_queue_mapping(skb)];
+
+	WARN_ON(skb_get_queue_mapping(skb) > 3);
+	WARN_ON(!atomic_read(&queue->pending_frames));
 
+	atomic_dec(&queue->pending_frames);
 	skb_unlink(skb, &stats->pending);
 	wfx_skb_dtor(wdev, skb);
 

commit b6ef154973384439c663f8c5fde0eafa51e54309
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Wed Apr 1 13:03:53 2020 +0200

    staging: wfx: replace wfx_tx_queues_get_after_dtim() by wfx_tx_queues_has_cab()
    
    It is not necessary to return a skb. Just getting the information if
    there is traffic to be sent after DTIM is sufficient.
    
    In add, the acronym "cab" (Content After (DTIM) Beacon) is used in
    mac80211 to designate this kind of traffic.
    
    So, make wfx_tx_queues_get_after_dtim() return a boolean and rename
    accordingly.
    
    Reviewed-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200401110405.80282-21-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/queue.c b/drivers/staging/wfx/queue.c
index 046aba77618a..4ddb2c7370cd 100644
--- a/drivers/staging/wfx/queue.c
+++ b/drivers/staging/wfx/queue.c
@@ -264,6 +264,26 @@ unsigned int wfx_pending_get_pkt_us_delay(struct wfx_dev *wdev,
 	return ktime_us_delta(now, tx_priv->xmit_timestamp);
 }
 
+bool wfx_tx_queues_has_cab(struct wfx_vif *wvif)
+{
+	struct wfx_dev *wdev = wvif->wdev;
+	struct ieee80211_tx_info *tx_info;
+	struct hif_msg *hif;
+	struct sk_buff *skb;
+	int i;
+
+	for (i = 0; i < IEEE80211_NUM_ACS; ++i) {
+		skb_queue_walk(&wdev->tx_queue[i].queue, skb) {
+			tx_info = IEEE80211_SKB_CB(skb);
+			hif = (struct hif_msg *)skb->data;
+			if ((tx_info->flags & IEEE80211_TX_CTL_SEND_AFTER_DTIM) &&
+			    (hif->interface == wvif->id))
+				return true;
+		}
+	}
+	return false;
+}
+
 bool wfx_tx_queues_empty(struct wfx_dev *wdev)
 {
 	int i;
@@ -344,26 +364,6 @@ static struct wfx_queue *wfx_tx_queue_mask_get(struct wfx_vif *wvif)
 	return &wvif->wdev->tx_queue[winner];
 }
 
-struct hif_msg *wfx_tx_queues_get_after_dtim(struct wfx_vif *wvif)
-{
-	struct wfx_dev *wdev = wvif->wdev;
-	struct ieee80211_tx_info *tx_info;
-	struct hif_msg *hif;
-	struct sk_buff *skb;
-	int i;
-
-	for (i = 0; i < IEEE80211_NUM_ACS; ++i) {
-		skb_queue_walk(&wdev->tx_queue[i].queue, skb) {
-			tx_info = IEEE80211_SKB_CB(skb);
-			hif = (struct hif_msg *)skb->data;
-			if ((tx_info->flags & IEEE80211_TX_CTL_SEND_AFTER_DTIM) &&
-			    (hif->interface == wvif->id))
-				return (struct hif_msg *)skb->data;
-		}
-	}
-	return NULL;
-}
-
 struct hif_msg *wfx_tx_queues_get(struct wfx_dev *wdev)
 {
 	struct sk_buff *skb;

commit 9251ad667d742ccc1430457266ee7206521668fc
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Wed Apr 1 13:03:49 2020 +0200

    staging: wfx: do not rely anymore on link_id to choose packet in queue
    
    link_id was expected to contain identifier of a station. It was also
    used to mark frames that has to sent after dtim. We do not use the
    further purpose. For the last purpose, we can directly check the flag
    value in tx_info.
    
    Reviewed-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200401110405.80282-17-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/queue.c b/drivers/staging/wfx/queue.c
index 82c2781b1f78..046aba77618a 100644
--- a/drivers/staging/wfx/queue.c
+++ b/drivers/staging/wfx/queue.c
@@ -158,16 +158,17 @@ void wfx_tx_queue_put(struct wfx_dev *wdev, struct wfx_queue *queue,
 
 static struct sk_buff *wfx_tx_queue_get(struct wfx_dev *wdev,
 					struct wfx_queue *queue,
-					u32 link_id_map)
+					bool mcast)
 {
 	struct wfx_queue_stats *stats = &wdev->tx_queue_stats;
+	struct ieee80211_tx_info *tx_info;
 	struct sk_buff *item, *skb = NULL;
 	struct wfx_tx_priv *tx_priv;
 
 	spin_lock_bh(&queue->queue.lock);
 	skb_queue_walk(&queue->queue, item) {
-		tx_priv = wfx_skb_tx_priv(item);
-		if (link_id_map & BIT(tx_priv->link_id)) {
+		tx_info = IEEE80211_SKB_CB(item);
+		if (mcast == !!(tx_info->flags & IEEE80211_TX_CTL_SEND_AFTER_DTIM)) {
 			skb = item;
 			break;
 		}
@@ -381,7 +382,7 @@ struct hif_msg *wfx_tx_queues_get(struct wfx_dev *wdev)
 			for (i = 0; i < IEEE80211_NUM_ACS; ++i) {
 				skb = wfx_tx_queue_get(wvif->wdev,
 						       &wdev->tx_queue[i],
-						       BIT(WFX_LINK_ID_AFTER_DTIM));
+						       true);
 				if (skb) {
 					hif = (struct hif_msg *)skb->data;
 					// Cannot happen since only one vif can
@@ -416,7 +417,7 @@ struct hif_msg *wfx_tx_queues_get(struct wfx_dev *wdev)
 
 		queue_num = queue - wdev->tx_queue;
 
-		skb = wfx_tx_queue_get(wdev, queue, ~BIT(WFX_LINK_ID_AFTER_DTIM));
+		skb = wfx_tx_queue_get(wdev, queue, false);
 		if (!skb)
 			continue;
 

commit 9e76ba774445f87f4374244c791758e853f7e1e1
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Wed Apr 1 13:03:48 2020 +0200

    staging: wfx: drop useless link_map_cache
    
    Driver does not use link_map_cache anymore. So we can drop it. In add,
    we do not have to keep this counter in sync with skb_queue item, so we
    can drop explicit spin_locks.
    
    Reviewed-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200401110405.80282-16-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/queue.c b/drivers/staging/wfx/queue.c
index 6fa8f4e083d3..82c2781b1f78 100644
--- a/drivers/staging/wfx/queue.c
+++ b/drivers/staging/wfx/queue.c
@@ -94,20 +94,10 @@ void wfx_tx_queues_wait_empty_vif(struct wfx_vif *wvif)
 static void wfx_tx_queue_clear(struct wfx_dev *wdev, struct wfx_queue *queue,
 			       struct sk_buff_head *gc_list)
 {
-	int i;
 	struct sk_buff *item;
-	struct wfx_queue_stats *stats = &wdev->tx_queue_stats;
 
-	spin_lock_bh(&queue->queue.lock);
-	while ((item = __skb_dequeue(&queue->queue)) != NULL)
+	while ((item = skb_dequeue(&queue->queue)) != NULL)
 		skb_queue_head(gc_list, item);
-	spin_lock_nested(&stats->pending.lock, 1);
-	for (i = 0; i < ARRAY_SIZE(stats->link_map_cache); ++i) {
-		stats->link_map_cache[i] -= queue->link_map_cache[i];
-		queue->link_map_cache[i] = 0;
-	}
-	spin_unlock(&stats->pending.lock);
-	spin_unlock_bh(&queue->queue.lock);
 }
 
 void wfx_tx_queues_clear(struct wfx_dev *wdev)
@@ -163,28 +153,15 @@ int wfx_tx_queue_get_num_queued(struct wfx_queue *queue)
 void wfx_tx_queue_put(struct wfx_dev *wdev, struct wfx_queue *queue,
 		      struct sk_buff *skb)
 {
-	struct wfx_queue_stats *stats = &wdev->tx_queue_stats;
-	struct wfx_tx_priv *tx_priv = wfx_skb_tx_priv(skb);
-
-	WARN(tx_priv->link_id >= ARRAY_SIZE(stats->link_map_cache), "invalid link-id value");
-	spin_lock_bh(&queue->queue.lock);
-	__skb_queue_tail(&queue->queue, skb);
-
-	++queue->link_map_cache[tx_priv->link_id];
-
-	spin_lock_nested(&stats->pending.lock, 1);
-	++stats->link_map_cache[tx_priv->link_id];
-	spin_unlock(&stats->pending.lock);
-	spin_unlock_bh(&queue->queue.lock);
+	skb_queue_tail(&queue->queue, skb);
 }
 
 static struct sk_buff *wfx_tx_queue_get(struct wfx_dev *wdev,
 					struct wfx_queue *queue,
 					u32 link_id_map)
 {
-	struct sk_buff *skb = NULL;
-	struct sk_buff *item;
 	struct wfx_queue_stats *stats = &wdev->tx_queue_stats;
+	struct sk_buff *item, *skb = NULL;
 	struct wfx_tx_priv *tx_priv;
 
 	spin_lock_bh(&queue->queue.lock);
@@ -195,39 +172,28 @@ static struct sk_buff *wfx_tx_queue_get(struct wfx_dev *wdev,
 			break;
 		}
 	}
+	spin_unlock_bh(&queue->queue.lock);
 	if (skb) {
+		skb_unlink(skb, &queue->queue);
 		tx_priv = wfx_skb_tx_priv(skb);
 		tx_priv->xmit_timestamp = ktime_get();
-		__skb_unlink(skb, &queue->queue);
-		--queue->link_map_cache[tx_priv->link_id];
-
-		spin_lock_nested(&stats->pending.lock, 1);
-		__skb_queue_tail(&stats->pending, skb);
-		--stats->link_map_cache[tx_priv->link_id];
-		spin_unlock(&stats->pending.lock);
+		skb_queue_tail(&stats->pending, skb);
+		if (skb_queue_empty(&queue->queue))
+			wake_up(&stats->wait_link_id_empty);
+		return skb;
 	}
-	spin_unlock_bh(&queue->queue.lock);
-	if (skb_queue_empty(&queue->queue))
-		wake_up(&stats->wait_link_id_empty);
 	return skb;
 }
 
 int wfx_pending_requeue(struct wfx_dev *wdev, struct sk_buff *skb)
 {
 	struct wfx_queue_stats *stats = &wdev->tx_queue_stats;
-	struct wfx_tx_priv *tx_priv = wfx_skb_tx_priv(skb);
 	struct wfx_queue *queue = &wdev->tx_queue[skb_get_queue_mapping(skb)];
 
 	WARN_ON(skb_get_queue_mapping(skb) > 3);
-	spin_lock_bh(&queue->queue.lock);
-	++queue->link_map_cache[tx_priv->link_id];
 
-	spin_lock_nested(&stats->pending.lock, 1);
-	++stats->link_map_cache[tx_priv->link_id];
-	__skb_unlink(skb, &stats->pending);
-	spin_unlock(&stats->pending.lock);
-	__skb_queue_tail(&queue->queue, skb);
-	spin_unlock_bh(&queue->queue.lock);
+	skb_unlink(skb, &stats->pending);
+	skb_queue_tail(&queue->queue, skb);
 	return 0;
 }
 
@@ -235,9 +201,7 @@ int wfx_pending_remove(struct wfx_dev *wdev, struct sk_buff *skb)
 {
 	struct wfx_queue_stats *stats = &wdev->tx_queue_stats;
 
-	spin_lock_bh(&stats->pending.lock);
-	__skb_unlink(skb, &stats->pending);
-	spin_unlock_bh(&stats->pending.lock);
+	skb_unlink(skb, &stats->pending);
 	wfx_skb_dtor(wdev, skb);
 
 	return 0;

commit 6c262beb41e6d3bd93f0b055c0b20ebda7dfed51
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Wed Apr 1 13:03:47 2020 +0200

    staging: wfx: do not use link_map_cache to track CAB
    
    Since we do not track power save status of the stations anymore,
    link_map_cache is now only used to track "Content After (DTIM) Beacon".
    We prefer to rely on flags from tx_info. So we will be able to drop
    link_map_cache.
    
    Reviewed-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200401110405.80282-15-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/queue.c b/drivers/staging/wfx/queue.c
index cecf9aa7b3ca..6fa8f4e083d3 100644
--- a/drivers/staging/wfx/queue.c
+++ b/drivers/staging/wfx/queue.c
@@ -146,13 +146,16 @@ void wfx_tx_queues_deinit(struct wfx_dev *wdev)
 
 int wfx_tx_queue_get_num_queued(struct wfx_queue *queue)
 {
-	int ret, i;
+	struct ieee80211_tx_info *tx_info;
+	struct sk_buff *skb;
+	int ret = 0;
 
-	ret = 0;
 	spin_lock_bh(&queue->queue.lock);
-	for (i = 0; i < ARRAY_SIZE(queue->link_map_cache); i++)
-		if (i != WFX_LINK_ID_AFTER_DTIM)
-			ret += queue->link_map_cache[i];
+	skb_queue_walk(&queue->queue, skb) {
+		tx_info = IEEE80211_SKB_CB(skb);
+		if (!(tx_info->flags & IEEE80211_TX_CTL_SEND_AFTER_DTIM))
+			ret++;
+	}
 	spin_unlock_bh(&queue->queue.lock);
 	return ret;
 }

commit af72697196dcb9d23484ae32ea096955f715c1d1
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Wed Apr 1 13:03:46 2020 +0200

    staging: wfx: drop argument tx_allowed_mask since it is constant now
    
    Following the remove of asleep_mask, the tx_allowed_mask argument passed
    to various functions is now always the same. Drop this argument and
    simplify the code.
    
    Reviewed-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200401110405.80282-14-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/queue.c b/drivers/staging/wfx/queue.c
index e66debd60e3f..cecf9aa7b3ca 100644
--- a/drivers/staging/wfx/queue.c
+++ b/drivers/staging/wfx/queue.c
@@ -144,22 +144,15 @@ void wfx_tx_queues_deinit(struct wfx_dev *wdev)
 	wfx_tx_queues_clear(wdev);
 }
 
-int wfx_tx_queue_get_num_queued(struct wfx_queue *queue, u32 link_id_map)
+int wfx_tx_queue_get_num_queued(struct wfx_queue *queue)
 {
 	int ret, i;
 
-	if (!link_id_map)
-		return 0;
-
+	ret = 0;
 	spin_lock_bh(&queue->queue.lock);
-	if (link_id_map == (u32)-1) {
-		ret = skb_queue_len(&queue->queue);
-	} else {
-		ret = 0;
-		for (i = 0; i < ARRAY_SIZE(queue->link_map_cache); i++)
-			if (link_id_map & BIT(i))
-				ret += queue->link_map_cache[i];
-	}
+	for (i = 0; i < ARRAY_SIZE(queue->link_map_cache); i++)
+		if (i != WFX_LINK_ID_AFTER_DTIM)
+			ret += queue->link_map_cache[i];
 	spin_unlock_bh(&queue->queue.lock);
 	return ret;
 }
@@ -354,7 +347,7 @@ static bool wfx_handle_tx_data(struct wfx_dev *wdev, struct sk_buff *skb)
 	}
 }
 
-static int wfx_get_prio_queue(struct wfx_vif *wvif, u32 tx_allowed_mask)
+static struct wfx_queue *wfx_tx_queue_mask_get(struct wfx_vif *wvif)
 {
 	const struct ieee80211_tx_queue_params *edca;
 	unsigned int score, best = -1;
@@ -366,8 +359,7 @@ static int wfx_get_prio_queue(struct wfx_vif *wvif, u32 tx_allowed_mask)
 		int queued;
 
 		edca = &wvif->edca_params[i];
-		queued = wfx_tx_queue_get_num_queued(&wvif->wdev->tx_queue[i],
-				tx_allowed_mask);
+		queued = wfx_tx_queue_get_num_queued(&wvif->wdev->tx_queue[i]);
 		if (!queued)
 			continue;
 		score = ((edca->aifs + edca->cw_min) << 16) +
@@ -379,23 +371,9 @@ static int wfx_get_prio_queue(struct wfx_vif *wvif, u32 tx_allowed_mask)
 		}
 	}
 
-	return winner;
-}
-
-static struct wfx_queue *wfx_tx_queue_mask_get(struct wfx_vif *wvif,
-					       u32 *tx_allowed_mask_p)
-{
-	int idx;
-	u32 tx_allowed_mask;
-
-	tx_allowed_mask = BIT(WFX_LINK_ID_MAX) - 1;
-	tx_allowed_mask &= ~BIT(WFX_LINK_ID_AFTER_DTIM);
-	idx = wfx_get_prio_queue(wvif, tx_allowed_mask);
-	if (idx < 0)
+	if (winner < 0)
 		return NULL;
-
-	*tx_allowed_mask_p = tx_allowed_mask;
-	return &wvif->wdev->tx_queue[idx];
+	return &wvif->wdev->tx_queue[winner];
 }
 
 struct hif_msg *wfx_tx_queues_get_after_dtim(struct wfx_vif *wvif)
@@ -424,8 +402,6 @@ struct hif_msg *wfx_tx_queues_get(struct wfx_dev *wdev)
 	struct hif_msg *hif = NULL;
 	struct wfx_queue *queue = NULL;
 	struct wfx_queue *vif_queue = NULL;
-	u32 tx_allowed_mask = 0;
-	u32 vif_tx_allowed_mask = 0;
 	struct wfx_vif *wvif;
 	int i;
 
@@ -459,12 +435,10 @@ struct hif_msg *wfx_tx_queues_get(struct wfx_dev *wdev)
 
 		wvif = NULL;
 		while ((wvif = wvif_iterate(wdev, wvif)) != NULL) {
-			vif_queue = wfx_tx_queue_mask_get(wvif,
-							  &vif_tx_allowed_mask);
+			vif_queue = wfx_tx_queue_mask_get(wvif);
 			if (vif_queue) {
 				if (queue && queue != vif_queue)
 					dev_info(wdev->dev, "vifs disagree about queue priority\n");
-				tx_allowed_mask |= vif_tx_allowed_mask;
 				queue = vif_queue;
 				ret = 0;
 			}
@@ -475,7 +449,7 @@ struct hif_msg *wfx_tx_queues_get(struct wfx_dev *wdev)
 
 		queue_num = queue - wdev->tx_queue;
 
-		skb = wfx_tx_queue_get(wdev, queue, tx_allowed_mask);
+		skb = wfx_tx_queue_get(wdev, queue, ~BIT(WFX_LINK_ID_AFTER_DTIM));
 		if (!skb)
 			continue;
 

commit 062a6c410258ca2e66f377e54ee229c937504e22
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Wed Apr 1 13:03:45 2020 +0200

    staging: wfx: drop useless sta_asleep_mask
    
    Currently, the driver tracks power save state of the stations with the
    variable sta_asleep_mask. Then, it takes care to not sent data to asleep
    stations.
    
    However, this work is already done by mac80211. Normally, there are no
    frames for asleep stations in our queues. So, driver do not have to
    filter frames in its queues (apart the frames marked "AFTER_DTIM").
    
    Notice that there is a risk of race between state of the station and
    data send to the firmware. However, this risk is limited since the
    number of frame in queues are small. In add, this race also exists with
    the current code. Anyway, the firmware is able to detect the problem and
    driver will receive a 'REQUEUE' status (translated in
    TX_STAT_TX_FILTERED for mac80211).
    
    Reviewed-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200401110405.80282-13-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/queue.c b/drivers/staging/wfx/queue.c
index c602496580f7..e66debd60e3f 100644
--- a/drivers/staging/wfx/queue.c
+++ b/drivers/staging/wfx/queue.c
@@ -388,13 +388,8 @@ static struct wfx_queue *wfx_tx_queue_mask_get(struct wfx_vif *wvif,
 	int idx;
 	u32 tx_allowed_mask;
 
-	/* Search for unicast traffic */
-	tx_allowed_mask = ~wvif->sta_asleep_mask;
-	tx_allowed_mask |= BIT(WFX_LINK_ID_UAPSD);
-	if (wvif->sta_asleep_mask)
-		tx_allowed_mask &= ~BIT(WFX_LINK_ID_AFTER_DTIM);
-	else
-		tx_allowed_mask |= BIT(WFX_LINK_ID_AFTER_DTIM);
+	tx_allowed_mask = BIT(WFX_LINK_ID_MAX) - 1;
+	tx_allowed_mask &= ~BIT(WFX_LINK_ID_AFTER_DTIM);
 	idx = wfx_get_prio_queue(wvif, tx_allowed_mask);
 	if (idx < 0)
 		return NULL;
@@ -464,13 +459,8 @@ struct hif_msg *wfx_tx_queues_get(struct wfx_dev *wdev)
 
 		wvif = NULL;
 		while ((wvif = wvif_iterate(wdev, wvif)) != NULL) {
-			spin_lock_bh(&wvif->ps_state_lock);
-
 			vif_queue = wfx_tx_queue_mask_get(wvif,
 							  &vif_tx_allowed_mask);
-
-			spin_unlock_bh(&wvif->ps_state_lock);
-
 			if (vif_queue) {
 				if (queue && queue != vif_queue)
 					dev_info(wdev->dev, "vifs disagree about queue priority\n");

commit 517b358fddd737e81a3e0762d0893722871fafe9
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Wed Apr 1 13:03:44 2020 +0200

    staging: wfx: simplify wfx_tx_queue_mask_get()
    
    It is far simpler to return a pointer instead of an error. Thus, it is
    no more necessary to pass a pointer reference as argument.
    
    Reviewed-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200401110405.80282-12-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/queue.c b/drivers/staging/wfx/queue.c
index bbab6b192b0c..c602496580f7 100644
--- a/drivers/staging/wfx/queue.c
+++ b/drivers/staging/wfx/queue.c
@@ -382,9 +382,8 @@ static int wfx_get_prio_queue(struct wfx_vif *wvif, u32 tx_allowed_mask)
 	return winner;
 }
 
-static int wfx_tx_queue_mask_get(struct wfx_vif *wvif,
-				     struct wfx_queue **queue_p,
-				     u32 *tx_allowed_mask_p)
+static struct wfx_queue *wfx_tx_queue_mask_get(struct wfx_vif *wvif,
+					       u32 *tx_allowed_mask_p)
 {
 	int idx;
 	u32 tx_allowed_mask;
@@ -398,11 +397,10 @@ static int wfx_tx_queue_mask_get(struct wfx_vif *wvif,
 		tx_allowed_mask |= BIT(WFX_LINK_ID_AFTER_DTIM);
 	idx = wfx_get_prio_queue(wvif, tx_allowed_mask);
 	if (idx < 0)
-		return -ENOENT;
+		return NULL;
 
-	*queue_p = &wvif->wdev->tx_queue[idx];
 	*tx_allowed_mask_p = tx_allowed_mask;
-	return 0;
+	return &wvif->wdev->tx_queue[idx];
 }
 
 struct hif_msg *wfx_tx_queues_get_after_dtim(struct wfx_vif *wvif)
@@ -434,7 +432,6 @@ struct hif_msg *wfx_tx_queues_get(struct wfx_dev *wdev)
 	u32 tx_allowed_mask = 0;
 	u32 vif_tx_allowed_mask = 0;
 	struct wfx_vif *wvif;
-	int not_found;
 	int i;
 
 	if (atomic_read(&wdev->tx_lock))
@@ -469,12 +466,12 @@ struct hif_msg *wfx_tx_queues_get(struct wfx_dev *wdev)
 		while ((wvif = wvif_iterate(wdev, wvif)) != NULL) {
 			spin_lock_bh(&wvif->ps_state_lock);
 
-			not_found = wfx_tx_queue_mask_get(wvif, &vif_queue,
+			vif_queue = wfx_tx_queue_mask_get(wvif,
 							  &vif_tx_allowed_mask);
 
 			spin_unlock_bh(&wvif->ps_state_lock);
 
-			if (!not_found) {
+			if (vif_queue) {
 				if (queue && queue != vif_queue)
 					dev_info(wdev->dev, "vifs disagree about queue priority\n");
 				tx_allowed_mask |= vif_tx_allowed_mask;

commit abaef5374e53be81ca46ef76d9c03e103b49da51
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Wed Apr 1 13:03:43 2020 +0200

    staging: wfx: drop unused argument in wfx_get_prio_queue()
    
    The argument "total" is not used anymore since commit a3c529a83589
    ("staging: wfx: simplify handling of IEEE80211_TX_CTL_SEND_AFTER_DTIM").
    
    Fixes: a3c529a83589 ("staging: wfx: simplify handling of IEEE80211_TX_CTL_SEND_AFTER_DTIM")
    Reviewed-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200401110405.80282-11-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/queue.c b/drivers/staging/wfx/queue.c
index 09f823929fb6..bbab6b192b0c 100644
--- a/drivers/staging/wfx/queue.c
+++ b/drivers/staging/wfx/queue.c
@@ -354,8 +354,7 @@ static bool wfx_handle_tx_data(struct wfx_dev *wdev, struct sk_buff *skb)
 	}
 }
 
-static int wfx_get_prio_queue(struct wfx_vif *wvif,
-				 u32 tx_allowed_mask, int *total)
+static int wfx_get_prio_queue(struct wfx_vif *wvif, u32 tx_allowed_mask)
 {
 	const struct ieee80211_tx_queue_params *edca;
 	unsigned int score, best = -1;
@@ -371,7 +370,6 @@ static int wfx_get_prio_queue(struct wfx_vif *wvif,
 				tx_allowed_mask);
 		if (!queued)
 			continue;
-		*total += queued;
 		score = ((edca->aifs + edca->cw_min) << 16) +
 			((edca->cw_max - edca->cw_min) *
 			 (get_random_int() & 0xFFFF));
@@ -390,7 +388,6 @@ static int wfx_tx_queue_mask_get(struct wfx_vif *wvif,
 {
 	int idx;
 	u32 tx_allowed_mask;
-	int total = 0;
 
 	/* Search for unicast traffic */
 	tx_allowed_mask = ~wvif->sta_asleep_mask;
@@ -399,7 +396,7 @@ static int wfx_tx_queue_mask_get(struct wfx_vif *wvif,
 		tx_allowed_mask &= ~BIT(WFX_LINK_ID_AFTER_DTIM);
 	else
 		tx_allowed_mask |= BIT(WFX_LINK_ID_AFTER_DTIM);
-	idx = wfx_get_prio_queue(wvif, tx_allowed_mask, &total);
+	idx = wfx_get_prio_queue(wvif, tx_allowed_mask);
 	if (idx < 0)
 		return -ENOENT;
 

commit f42483f9efefd9ea0ea4eb054cd1e1923626e414
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Wed Apr 1 13:03:42 2020 +0200

    staging: wfx: simplify wfx_tx_queues_empty()
    
    Thanks to skb_queue_empty_lockless(), it is not necessary to acquire the
    spin_lock before to check if the queue is empty.
    
    Reviewed-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200401110405.80282-10-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/queue.c b/drivers/staging/wfx/queue.c
index 8647731e02c0..09f823929fb6 100644
--- a/drivers/staging/wfx/queue.c
+++ b/drivers/staging/wfx/queue.c
@@ -303,20 +303,14 @@ unsigned int wfx_pending_get_pkt_us_delay(struct wfx_dev *wdev,
 	return ktime_us_delta(now, tx_priv->xmit_timestamp);
 }
 
-bool wfx_tx_queues_is_empty(struct wfx_dev *wdev)
+bool wfx_tx_queues_empty(struct wfx_dev *wdev)
 {
 	int i;
-	struct sk_buff_head *queue;
-	bool ret = true;
-
-	for (i = 0; i < IEEE80211_NUM_ACS; i++) {
-		queue = &wdev->tx_queue[i].queue;
-		spin_lock_bh(&queue->lock);
-		if (!skb_queue_empty(queue))
-			ret = false;
-		spin_unlock_bh(&queue->lock);
-	}
-	return ret;
+
+	for (i = 0; i < IEEE80211_NUM_ACS; i++)
+		if (!skb_queue_empty_lockless(&wdev->tx_queue[i].queue))
+			return false;
+	return true;
 }
 
 static bool wfx_handle_tx_data(struct wfx_dev *wdev, struct sk_buff *skb)

commit f5d331ee86a9906ab732d1391e6bebad53624d4e
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Wed Apr 1 13:03:41 2020 +0200

    staging: wfx: simplify hif_handle_tx_data()
    
    The last argument of hif_handle_tx_data() was now unused. In add,
    hif_handle_tx_data() has nothing to do with HIF layer and should be
    renamed. Finally, it not convenient to pass a wfx_vif as parameter. It
    is easier to let hif_handle_tx_data() find the interface itself.
    
    Reviewed-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200401110405.80282-9-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/queue.c b/drivers/staging/wfx/queue.c
index 2553f77522d9..8647731e02c0 100644
--- a/drivers/staging/wfx/queue.c
+++ b/drivers/staging/wfx/queue.c
@@ -319,13 +319,17 @@ bool wfx_tx_queues_is_empty(struct wfx_dev *wdev)
 	return ret;
 }
 
-static bool hif_handle_tx_data(struct wfx_vif *wvif, struct sk_buff *skb,
-			       struct wfx_queue *queue)
+static bool wfx_handle_tx_data(struct wfx_dev *wdev, struct sk_buff *skb)
 {
 	struct hif_req_tx *req = wfx_skb_txreq(skb);
 	struct ieee80211_key_conf *hw_key = wfx_skb_tx_priv(skb)->hw_key;
 	struct ieee80211_hdr *frame =
 		(struct ieee80211_hdr *)(req->frame + req->data_flags.fc_offset);
+	struct wfx_vif *wvif =
+		wdev_to_wvif(wdev, ((struct hif_msg *)skb->data)->interface);
+
+	if (!wvif)
+		return false;
 
 	// FIXME: mac80211 is smart enough to handle BSS loss. Driver should not
 	// try to do anything about that.
@@ -344,12 +348,12 @@ static bool hif_handle_tx_data(struct wfx_vif *wvif, struct sk_buff *skb,
 	    hw_key && hw_key->keyidx != wvif->wep_default_key_id &&
 	    (hw_key->cipher == WLAN_CIPHER_SUITE_WEP40 ||
 	     hw_key->cipher == WLAN_CIPHER_SUITE_WEP104)) {
-		wfx_tx_lock(wvif->wdev);
+		wfx_tx_lock(wdev);
 		WARN_ON(wvif->wep_pending_skb);
 		wvif->wep_default_key_id = hw_key->keyidx;
 		wvif->wep_pending_skb = skb;
 		if (!schedule_work(&wvif->wep_key_work))
-			wfx_tx_unlock(wvif->wdev);
+			wfx_tx_unlock(wdev);
 		return true;
 	} else {
 		return false;
@@ -496,13 +500,10 @@ struct hif_msg *wfx_tx_queues_get(struct wfx_dev *wdev)
 		skb = wfx_tx_queue_get(wdev, queue, tx_allowed_mask);
 		if (!skb)
 			continue;
-		hif = (struct hif_msg *)skb->data;
-		wvif = wdev_to_wvif(wdev, hif->interface);
-		WARN_ON(!wvif);
 
-		if (hif_handle_tx_data(wvif, skb, queue))
+		if (wfx_handle_tx_data(wdev, skb))
 			continue;  /* Handled by WSM */
 
-		return hif;
+		return (struct hif_msg *)skb->data;
 	}
 }

commit 566059cc5fe4d8b49e5f09efe468c046bdd9596d
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Wed Apr 1 13:03:40 2020 +0200

    staging: wfx: avoid useless wake_up
    
    __wfx_flush() wait for all queues to be empty. In current code,
    wait_link_id_empty is wake up each time there is no more data for a
    station. We can simplify the processing and avoid some wake-up by
    raising this event only when the queue is empty.
    
    Reviewed-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200401110405.80282-8-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/queue.c b/drivers/staging/wfx/queue.c
index 1df3b6f28c67..2553f77522d9 100644
--- a/drivers/staging/wfx/queue.c
+++ b/drivers/staging/wfx/queue.c
@@ -190,7 +190,6 @@ static struct sk_buff *wfx_tx_queue_get(struct wfx_dev *wdev,
 	struct sk_buff *item;
 	struct wfx_queue_stats *stats = &wdev->tx_queue_stats;
 	struct wfx_tx_priv *tx_priv;
-	bool wakeup_stats = false;
 
 	spin_lock_bh(&queue->queue.lock);
 	skb_queue_walk(&queue->queue, item) {
@@ -208,12 +207,11 @@ static struct sk_buff *wfx_tx_queue_get(struct wfx_dev *wdev,
 
 		spin_lock_nested(&stats->pending.lock, 1);
 		__skb_queue_tail(&stats->pending, skb);
-		if (!--stats->link_map_cache[tx_priv->link_id])
-			wakeup_stats = true;
+		--stats->link_map_cache[tx_priv->link_id];
 		spin_unlock(&stats->pending.lock);
 	}
 	spin_unlock_bh(&queue->queue.lock);
-	if (wakeup_stats)
+	if (skb_queue_empty(&queue->queue))
 		wake_up(&stats->wait_link_id_empty);
 	return skb;
 }

commit 70b727314f90765c9267e1e1882b5b01fba5201b
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Wed Apr 1 13:03:39 2020 +0200

    staging: wfx: drop useless queue_id field
    
    The field queue_id is no more used.
    
    Reviewed-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200401110405.80282-7-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/queue.c b/drivers/staging/wfx/queue.c
index 712ac783514b..1df3b6f28c67 100644
--- a/drivers/staging/wfx/queue.c
+++ b/drivers/staging/wfx/queue.c
@@ -134,10 +134,8 @@ void wfx_tx_queues_init(struct wfx_dev *wdev)
 	skb_queue_head_init(&wdev->tx_queue_stats.pending);
 	init_waitqueue_head(&wdev->tx_queue_stats.wait_link_id_empty);
 
-	for (i = 0; i < IEEE80211_NUM_ACS; ++i) {
-		wdev->tx_queue[i].queue_id = i;
+	for (i = 0; i < IEEE80211_NUM_ACS; ++i)
 		skb_queue_head_init(&wdev->tx_queue[i].queue);
-	}
 }
 
 void wfx_tx_queues_deinit(struct wfx_dev *wdev)

commit 57c5222004d39e8d914d7b6190593f31e3554892
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Wed Apr 1 13:03:37 2020 +0200

    staging: wfx: remove "burst" mechanism
    
    In the old days, the driver tried to reorder frames in order to send
    frames from the same queue grouped to the firmware. However, the
    firmware is able to do the job internally for a long time. There is no
    reasons to keep this mechanism.
    
    Reviewed-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200401110405.80282-5-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/queue.c b/drivers/staging/wfx/queue.c
index e3aa1e346c70..712ac783514b 100644
--- a/drivers/staging/wfx/queue.c
+++ b/drivers/staging/wfx/queue.c
@@ -363,8 +363,6 @@ static bool hif_handle_tx_data(struct wfx_vif *wvif, struct sk_buff *skb,
 static int wfx_get_prio_queue(struct wfx_vif *wvif,
 				 u32 tx_allowed_mask, int *total)
 {
-	static const int urgent = BIT(WFX_LINK_ID_AFTER_DTIM) |
-		BIT(WFX_LINK_ID_UAPSD);
 	const struct ieee80211_tx_queue_params *edca;
 	unsigned int score, best = -1;
 	int winner = -1;
@@ -389,14 +387,6 @@ static int wfx_get_prio_queue(struct wfx_vif *wvif,
 		}
 	}
 
-	/* override winner if bursting */
-	if (winner >= 0 && wvif->wdev->tx_burst_idx >= 0 &&
-	    winner != wvif->wdev->tx_burst_idx &&
-	    !wfx_tx_queue_get_num_queued(&wvif->wdev->tx_queue[winner],
-					 tx_allowed_mask & urgent) &&
-	    wfx_tx_queue_get_num_queued(&wvif->wdev->tx_queue[wvif->wdev->tx_burst_idx], tx_allowed_mask))
-		winner = wvif->wdev->tx_burst_idx;
-
 	return winner;
 }
 
@@ -454,7 +444,6 @@ struct hif_msg *wfx_tx_queues_get(struct wfx_dev *wdev)
 	u32 vif_tx_allowed_mask = 0;
 	struct wfx_vif *wvif;
 	int not_found;
-	int burst;
 	int i;
 
 	if (atomic_read(&wdev->tx_lock))
@@ -518,18 +507,6 @@ struct hif_msg *wfx_tx_queues_get(struct wfx_dev *wdev)
 		if (hif_handle_tx_data(wvif, skb, queue))
 			continue;  /* Handled by WSM */
 
-		/* allow bursting if txop is set */
-		if (wvif->edca_params[queue_num].txop)
-			burst = wfx_tx_queue_get_num_queued(queue, tx_allowed_mask) + 1;
-		else
-			burst = 1;
-
-		/* store index of bursting queue */
-		if (burst > 1)
-			wdev->tx_burst_idx = queue_num;
-		else
-			wdev->tx_burst_idx = -1;
-
 		return hif;
 	}
 }

commit 055d20cf72fe90f5b3141e2d88b98f15e4e190c5
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Wed Apr 1 13:03:36 2020 +0200

    staging: wfx: take advantage of ieee80211_{stop/start}_queues
    
    Instead of maintaining stop status for each queue, we can just maintain
    a global status for all queues.
    
    In add, wfx_tx_queues_{lock/unlock} are only used when no more
    tx_policies are available. Therefore, the counter of recursive locks
    ("tx_locked_cnt") is useless.
    
    So, wfx_tx_queues_{lock/unlock} can be replaced by
    ieee80211_{stop/start}_queues.
    
    Reviewed-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200401110405.80282-4-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/queue.c b/drivers/staging/wfx/queue.c
index 39d9127ce4b9..e3aa1e346c70 100644
--- a/drivers/staging/wfx/queue.c
+++ b/drivers/staging/wfx/queue.c
@@ -55,35 +55,6 @@ void wfx_tx_lock_flush(struct wfx_dev *wdev)
 	wfx_tx_flush(wdev);
 }
 
-void wfx_tx_queues_lock(struct wfx_dev *wdev)
-{
-	int i;
-	struct wfx_queue *queue;
-
-	for (i = 0; i < IEEE80211_NUM_ACS; ++i) {
-		queue = &wdev->tx_queue[i];
-		spin_lock_bh(&queue->queue.lock);
-		if (queue->tx_locked_cnt++ == 0)
-			ieee80211_stop_queue(wdev->hw, queue->queue_id);
-		spin_unlock_bh(&queue->queue.lock);
-	}
-}
-
-void wfx_tx_queues_unlock(struct wfx_dev *wdev)
-{
-	int i;
-	struct wfx_queue *queue;
-
-	for (i = 0; i < IEEE80211_NUM_ACS; ++i) {
-		queue = &wdev->tx_queue[i];
-		spin_lock_bh(&queue->queue.lock);
-		WARN(!queue->tx_locked_cnt, "queue already unlocked");
-		if (--queue->tx_locked_cnt == 0)
-			ieee80211_wake_queue(wdev->hw, queue->queue_id);
-		spin_unlock_bh(&queue->queue.lock);
-	}
-}
-
 /* If successful, LOCKS the TX queue! */
 void wfx_tx_queues_wait_empty_vif(struct wfx_vif *wvif)
 {

commit 76498b49f5bedbd5d184cceec05dde72749f9915
Author: Lourdes Pedrajas <lu@pplo.net>
Date:   Sun Mar 15 05:49:22 2020 +0100

    staging: wfx: remove unneeded spaces
    
    Remove spaces after type casting operators in order to comply codding
    standards.
    Issue found with checkpatch.
    
    Signed-off-by: Lourdes Pedrajas <lu@pplo.net>
    Link: https://lore.kernel.org/r/20200315044922.14249-1-lu@pplo.net
    Reviewed-by: Stefano Brivio <sbrivio@redhat.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/queue.c b/drivers/staging/wfx/queue.c
index ed6dc8297738..39d9127ce4b9 100644
--- a/drivers/staging/wfx/queue.c
+++ b/drivers/staging/wfx/queue.c
@@ -540,7 +540,7 @@ struct hif_msg *wfx_tx_queues_get(struct wfx_dev *wdev)
 		skb = wfx_tx_queue_get(wdev, queue, tx_allowed_mask);
 		if (!skb)
 			continue;
-		hif = (struct hif_msg *) skb->data;
+		hif = (struct hif_msg *)skb->data;
 		wvif = wdev_to_wvif(wdev, hif->interface);
 		WARN_ON(!wvif);
 

commit e2525a95cc0887c7dc0549cb5d0ac3e796e1d54c
Author: Michał Mirosław <mirq-linux@rere.qmqm.pl>
Date:   Tue Feb 11 11:35:01 2020 +0100

    staging: wfx: annotate nested gc_list vs tx queue locking
    
    Lockdep is complaining about recursive locking, because it can't make
    a difference between locked skb_queues. Annotate nested locks and avoid
    double bh_disable/enable.
    
    [...]
    insmod/815 is trying to acquire lock:
    cb7d6418 (&(&list->lock)->rlock){+...}, at: wfx_tx_queues_clear+0xfc/0x198 [wfx]
    
    but task is already holding lock:
    cb7d61f4 (&(&list->lock)->rlock){+...}, at: wfx_tx_queues_clear+0xa0/0x198 [wfx]
    
    [...]
    Possible unsafe locking scenario:
    
          CPU0
          ----
     lock(&(&list->lock)->rlock);
     lock(&(&list->lock)->rlock);
    
    Cc: stable@vger.kernel.org
    Fixes: 9bca45f3d692 ("staging: wfx: allow to send 802.11 frames")
    Signed-off-by: Michał Mirosław <mirq-linux@rere.qmqm.pl>
    Link: https://lore.kernel.org/r/5e30397af95854b4a7deea073b730c00229f42ba.1581416843.git.mirq-linux@rere.qmqm.pl
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/queue.c b/drivers/staging/wfx/queue.c
index c73d158668e3..ed6dc8297738 100644
--- a/drivers/staging/wfx/queue.c
+++ b/drivers/staging/wfx/queue.c
@@ -130,12 +130,12 @@ static void wfx_tx_queue_clear(struct wfx_dev *wdev, struct wfx_queue *queue,
 	spin_lock_bh(&queue->queue.lock);
 	while ((item = __skb_dequeue(&queue->queue)) != NULL)
 		skb_queue_head(gc_list, item);
-	spin_lock_bh(&stats->pending.lock);
+	spin_lock_nested(&stats->pending.lock, 1);
 	for (i = 0; i < ARRAY_SIZE(stats->link_map_cache); ++i) {
 		stats->link_map_cache[i] -= queue->link_map_cache[i];
 		queue->link_map_cache[i] = 0;
 	}
-	spin_unlock_bh(&stats->pending.lock);
+	spin_unlock(&stats->pending.lock);
 	spin_unlock_bh(&queue->queue.lock);
 }
 
@@ -207,9 +207,9 @@ void wfx_tx_queue_put(struct wfx_dev *wdev, struct wfx_queue *queue,
 
 	++queue->link_map_cache[tx_priv->link_id];
 
-	spin_lock_bh(&stats->pending.lock);
+	spin_lock_nested(&stats->pending.lock, 1);
 	++stats->link_map_cache[tx_priv->link_id];
-	spin_unlock_bh(&stats->pending.lock);
+	spin_unlock(&stats->pending.lock);
 	spin_unlock_bh(&queue->queue.lock);
 }
 
@@ -237,11 +237,11 @@ static struct sk_buff *wfx_tx_queue_get(struct wfx_dev *wdev,
 		__skb_unlink(skb, &queue->queue);
 		--queue->link_map_cache[tx_priv->link_id];
 
-		spin_lock_bh(&stats->pending.lock);
+		spin_lock_nested(&stats->pending.lock, 1);
 		__skb_queue_tail(&stats->pending, skb);
 		if (!--stats->link_map_cache[tx_priv->link_id])
 			wakeup_stats = true;
-		spin_unlock_bh(&stats->pending.lock);
+		spin_unlock(&stats->pending.lock);
 	}
 	spin_unlock_bh(&queue->queue.lock);
 	if (wakeup_stats)
@@ -259,10 +259,10 @@ int wfx_pending_requeue(struct wfx_dev *wdev, struct sk_buff *skb)
 	spin_lock_bh(&queue->queue.lock);
 	++queue->link_map_cache[tx_priv->link_id];
 
-	spin_lock_bh(&stats->pending.lock);
+	spin_lock_nested(&stats->pending.lock, 1);
 	++stats->link_map_cache[tx_priv->link_id];
 	__skb_unlink(skb, &stats->pending);
-	spin_unlock_bh(&stats->pending.lock);
+	spin_unlock(&stats->pending.lock);
 	__skb_queue_tail(&queue->queue, skb);
 	spin_unlock_bh(&queue->queue.lock);
 	return 0;

commit 032b423b31ad8ce70ec5665163231f37bd57d209
Author: YueHaibing <yuehaibing@huawei.com>
Date:   Tue Feb 11 22:03:34 2020 +0800

    staging: wfx: remove set but not used variable 'tx_priv'
    
    drivers/staging/wfx/queue.c: In function wfx_tx_queues_get:
    drivers/staging/wfx/queue.c:484:28: warning: variable tx_priv set but not used [-Wunused-but-set-variable]
    
    commit 2e57865e79cf ("staging: wfx: pspoll_mask make no sense")
    left behind this unused variable.
    
    Reported-by: Hulk Robot <hulkci@huawei.com>
    Signed-off-by: YueHaibing <yuehaibing@huawei.com>
    Reviewed-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200211140334.55248-1-yuehaibing@huawei.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/queue.c b/drivers/staging/wfx/queue.c
index 0bcc61feee1d..c73d158668e3 100644
--- a/drivers/staging/wfx/queue.c
+++ b/drivers/staging/wfx/queue.c
@@ -481,7 +481,6 @@ struct hif_msg *wfx_tx_queues_get(struct wfx_dev *wdev)
 	struct wfx_queue *vif_queue = NULL;
 	u32 tx_allowed_mask = 0;
 	u32 vif_tx_allowed_mask = 0;
-	const struct wfx_tx_priv *tx_priv = NULL;
 	struct wfx_vif *wvif;
 	int not_found;
 	int burst;
@@ -541,7 +540,6 @@ struct hif_msg *wfx_tx_queues_get(struct wfx_dev *wdev)
 		skb = wfx_tx_queue_get(wdev, queue, tx_allowed_mask);
 		if (!skb)
 			continue;
-		tx_priv = wfx_skb_tx_priv(skb);
 		hif = (struct hif_msg *) skb->data;
 		wvif = wdev_to_wvif(wdev, hif->interface);
 		WARN_ON(!wvif);

commit 2f5fd8b07745838e590b61d5b136be8b9f94cc4c
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Wed Jan 15 13:55:35 2020 +0000

    staging: wfx: simplify wfx_tx_queue_get_num_queued()
    
    wfx_tx_queue_get_num_queued() can take advantage of BIT() instead of
    maintaining one variable for a counter and another for a mask.
    
    In add, wfx_tx_queue_get_num_queued() has no real reason to return a
    size_t instead of an int.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200115135338.14374-64-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/queue.c b/drivers/staging/wfx/queue.c
index 024497eb19ac..0bcc61feee1d 100644
--- a/drivers/staging/wfx/queue.c
+++ b/drivers/staging/wfx/queue.c
@@ -175,11 +175,9 @@ void wfx_tx_queues_deinit(struct wfx_dev *wdev)
 	wfx_tx_queues_clear(wdev);
 }
 
-size_t wfx_tx_queue_get_num_queued(struct wfx_queue *queue,
-				   u32 link_id_map)
+int wfx_tx_queue_get_num_queued(struct wfx_queue *queue, u32 link_id_map)
 {
-	size_t ret;
-	int i, bit;
+	int ret, i;
 
 	if (!link_id_map)
 		return 0;
@@ -189,11 +187,9 @@ size_t wfx_tx_queue_get_num_queued(struct wfx_queue *queue,
 		ret = skb_queue_len(&queue->queue);
 	} else {
 		ret = 0;
-		for (i = 0, bit = 1; i < ARRAY_SIZE(queue->link_map_cache);
-		     ++i, bit <<= 1) {
-			if (link_id_map & bit)
+		for (i = 0; i < ARRAY_SIZE(queue->link_map_cache); i++)
+			if (link_id_map & BIT(i))
 				ret += queue->link_map_cache[i];
-		}
 	}
 	spin_unlock_bh(&queue->queue.lock);
 	return ret;
@@ -555,7 +551,7 @@ struct hif_msg *wfx_tx_queues_get(struct wfx_dev *wdev)
 
 		/* allow bursting if txop is set */
 		if (wvif->edca_params[queue_num].txop)
-			burst = (int)wfx_tx_queue_get_num_queued(queue, tx_allowed_mask) + 1;
+			burst = wfx_tx_queue_get_num_queued(queue, tx_allowed_mask) + 1;
 		else
 			burst = 1;
 

commit 5244357961a422100b73a9da423532578579324a
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Wed Jan 15 13:55:34 2020 +0000

    staging: wfx: simplify hif_handle_tx_data()
    
    Since enum action has now only two cases, it can be dropped. Then
    hif_handle_tx_data() can be simplified.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200115135338.14374-63-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/queue.c b/drivers/staging/wfx/queue.c
index e0c609c35a7b..024497eb19ac 100644
--- a/drivers/staging/wfx/queue.c
+++ b/drivers/staging/wfx/queue.c
@@ -359,16 +359,13 @@ bool wfx_tx_queues_is_empty(struct wfx_dev *wdev)
 static bool hif_handle_tx_data(struct wfx_vif *wvif, struct sk_buff *skb,
 			       struct wfx_queue *queue)
 {
-	bool handled = false;
-	struct wfx_tx_priv *tx_priv = wfx_skb_tx_priv(skb);
 	struct hif_req_tx *req = wfx_skb_txreq(skb);
-	struct ieee80211_hdr *frame = (struct ieee80211_hdr *) (req->frame + req->data_flags.fc_offset);
-
-	enum {
-		do_wep,
-		do_tx,
-	} action = do_tx;
+	struct ieee80211_key_conf *hw_key = wfx_skb_tx_priv(skb)->hw_key;
+	struct ieee80211_hdr *frame =
+		(struct ieee80211_hdr *)(req->frame + req->data_flags.fc_offset);
 
+	// FIXME: mac80211 is smart enough to handle BSS loss. Driver should not
+	// try to do anything about that.
 	if (ieee80211_is_nullfunc(frame->frame_control)) {
 		mutex_lock(&wvif->bss_loss_lock);
 		if (wvif->bss_loss_state) {
@@ -376,31 +373,24 @@ static bool hif_handle_tx_data(struct wfx_vif *wvif, struct sk_buff *skb,
 			req->queue_id.queue_id = HIF_QUEUE_ID_VOICE;
 		}
 		mutex_unlock(&wvif->bss_loss_lock);
-	} else if (ieee80211_has_protected(frame->frame_control) &&
-		   tx_priv->hw_key &&
-		   tx_priv->hw_key->keyidx != wvif->wep_default_key_id &&
-		   (tx_priv->hw_key->cipher == WLAN_CIPHER_SUITE_WEP40 ||
-		    tx_priv->hw_key->cipher == WLAN_CIPHER_SUITE_WEP104)) {
-		action = do_wep;
 	}
 
-	switch (action) {
-	case do_wep:
+	// FIXME: identify the exact scenario matched by this condition. Does it
+	// happen yet?
+	if (ieee80211_has_protected(frame->frame_control) &&
+	    hw_key && hw_key->keyidx != wvif->wep_default_key_id &&
+	    (hw_key->cipher == WLAN_CIPHER_SUITE_WEP40 ||
+	     hw_key->cipher == WLAN_CIPHER_SUITE_WEP104)) {
 		wfx_tx_lock(wvif->wdev);
 		WARN_ON(wvif->wep_pending_skb);
-		wvif->wep_default_key_id = tx_priv->hw_key->keyidx;
+		wvif->wep_default_key_id = hw_key->keyidx;
 		wvif->wep_pending_skb = skb;
 		if (!schedule_work(&wvif->wep_key_work))
 			wfx_tx_unlock(wvif->wdev);
-		handled = true;
-		break;
-	case do_tx:
-		break;
-	default:
-		/* Do nothing */
-		break;
+		return true;
+	} else {
+		return false;
 	}
-	return handled;
 }
 
 static int wfx_get_prio_queue(struct wfx_vif *wvif,

commit 7bc71e80bdaf623712352f25fba97a80716d7644
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Wed Jan 15 13:55:31 2020 +0000

    staging: wfx: remove check for interface state
    
    Obviously, the value of wvif->state as no reason to be wrong. At least,
    if it the case, dropping the frame is probably not the bast thing to do.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200115135338.14374-62-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/queue.c b/drivers/staging/wfx/queue.c
index c87d64fbb88f..e0c609c35a7b 100644
--- a/drivers/staging/wfx/queue.c
+++ b/drivers/staging/wfx/queue.c
@@ -365,52 +365,26 @@ static bool hif_handle_tx_data(struct wfx_vif *wvif, struct sk_buff *skb,
 	struct ieee80211_hdr *frame = (struct ieee80211_hdr *) (req->frame + req->data_flags.fc_offset);
 
 	enum {
-		do_drop,
 		do_wep,
 		do_tx,
 	} action = do_tx;
 
-	switch (wvif->vif->type) {
-	case NL80211_IFTYPE_STATION:
-		if (wvif->state < WFX_STATE_PRE_STA)
-			action = do_drop;
-		break;
-	case NL80211_IFTYPE_AP:
-		if (!wvif->state)
-			action = do_drop;
-		break;
-	case NL80211_IFTYPE_ADHOC:
-		if (wvif->state != WFX_STATE_IBSS)
-			action = do_drop;
-		break;
-	case NL80211_IFTYPE_MONITOR:
-	default:
-		action = do_drop;
-		break;
-	}
-
-	if (action == do_tx) {
-		if (ieee80211_is_nullfunc(frame->frame_control)) {
-			mutex_lock(&wvif->bss_loss_lock);
-			if (wvif->bss_loss_state) {
-				wvif->bss_loss_confirm_id = req->packet_id;
-				req->queue_id.queue_id = HIF_QUEUE_ID_VOICE;
-			}
-			mutex_unlock(&wvif->bss_loss_lock);
-		} else if (ieee80211_has_protected(frame->frame_control) &&
-			   tx_priv->hw_key &&
-			   tx_priv->hw_key->keyidx != wvif->wep_default_key_id &&
-			   (tx_priv->hw_key->cipher == WLAN_CIPHER_SUITE_WEP40 ||
-			    tx_priv->hw_key->cipher == WLAN_CIPHER_SUITE_WEP104)) {
-			action = do_wep;
+	if (ieee80211_is_nullfunc(frame->frame_control)) {
+		mutex_lock(&wvif->bss_loss_lock);
+		if (wvif->bss_loss_state) {
+			wvif->bss_loss_confirm_id = req->packet_id;
+			req->queue_id.queue_id = HIF_QUEUE_ID_VOICE;
 		}
+		mutex_unlock(&wvif->bss_loss_lock);
+	} else if (ieee80211_has_protected(frame->frame_control) &&
+		   tx_priv->hw_key &&
+		   tx_priv->hw_key->keyidx != wvif->wep_default_key_id &&
+		   (tx_priv->hw_key->cipher == WLAN_CIPHER_SUITE_WEP40 ||
+		    tx_priv->hw_key->cipher == WLAN_CIPHER_SUITE_WEP104)) {
+		action = do_wep;
 	}
 
 	switch (action) {
-	case do_drop:
-		wfx_pending_remove(wvif->wdev, skb);
-		handled = true;
-		break;
 	case do_wep:
 		wfx_tx_lock(wvif->wdev);
 		WARN_ON(wvif->wep_pending_skb);

commit 1b72dee6f8764dc9fb869a6f7de2901b647646a0
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Wed Jan 15 13:55:30 2020 +0000

    staging: wfx: remove unused do_probe
    
    The identifier do_probe is unused since "staging: wfx: remove workaround
    to send probe requests"
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200115135338.14374-61-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/queue.c b/drivers/staging/wfx/queue.c
index ec11a63a2ff9..c87d64fbb88f 100644
--- a/drivers/staging/wfx/queue.c
+++ b/drivers/staging/wfx/queue.c
@@ -365,7 +365,6 @@ static bool hif_handle_tx_data(struct wfx_vif *wvif, struct sk_buff *skb,
 	struct ieee80211_hdr *frame = (struct ieee80211_hdr *) (req->frame + req->data_flags.fc_offset);
 
 	enum {
-		do_probe,
 		do_drop,
 		do_wep,
 		do_tx,

commit a3c529a835890b0eecd324d9f0c37c67345f84e2
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Wed Jan 15 13:55:25 2020 +0000

    staging: wfx: simplify handling of IEEE80211_TX_CTL_SEND_AFTER_DTIM
    
    When mac80211 ask for a frame to be sent after a DTIM, driver should:
      1. Update TIM with multicast bit set (using update_ie). This function
         can be called whenever.
      2. Keep buffered all frames marked "after dtim"
      3. When it receive a suspend_resume indication (see
         wfx_suspend_resume_mc()), send all the buffered frames. This
         indication is sent by the firmware 4ms before the dtim.
      4. If one of the frames returns status "REQUEUE", it means that the
         DTIM period was ended before to be able to send the frame.
      5. When all the buffered frames were sent or if DTIM period was ended,
         driver should update the TIM with multicast bit reset.
    
    All the mess with the asynchronous works can be dropped.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200115135338.14374-58-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/queue.c b/drivers/staging/wfx/queue.c
index 42d64534c92c..ec11a63a2ff9 100644
--- a/drivers/staging/wfx/queue.c
+++ b/drivers/staging/wfx/queue.c
@@ -235,7 +235,6 @@ static struct sk_buff *wfx_tx_queue_get(struct wfx_dev *wdev,
 			break;
 		}
 	}
-	WARN_ON(!skb);
 	if (skb) {
 		tx_priv = wfx_skb_tx_priv(skb);
 		tx_priv->xmit_timestamp = ktime_get();
@@ -473,23 +472,12 @@ static int wfx_get_prio_queue(struct wfx_vif *wvif,
 
 static int wfx_tx_queue_mask_get(struct wfx_vif *wvif,
 				     struct wfx_queue **queue_p,
-				     u32 *tx_allowed_mask_p,
-				     bool *more)
+				     u32 *tx_allowed_mask_p)
 {
 	int idx;
 	u32 tx_allowed_mask;
 	int total = 0;
 
-	/* Search for a queue with multicast frames buffered */
-	if (wvif->mcast_tx) {
-		tx_allowed_mask = BIT(WFX_LINK_ID_AFTER_DTIM);
-		idx = wfx_get_prio_queue(wvif, tx_allowed_mask, &total);
-		if (idx >= 0) {
-			*more = total > 1;
-			goto found;
-		}
-	}
-
 	/* Search for unicast traffic */
 	tx_allowed_mask = ~wvif->sta_asleep_mask;
 	tx_allowed_mask |= BIT(WFX_LINK_ID_UAPSD);
@@ -501,64 +489,83 @@ static int wfx_tx_queue_mask_get(struct wfx_vif *wvif,
 	if (idx < 0)
 		return -ENOENT;
 
-found:
 	*queue_p = &wvif->wdev->tx_queue[idx];
 	*tx_allowed_mask_p = tx_allowed_mask;
 	return 0;
 }
 
+struct hif_msg *wfx_tx_queues_get_after_dtim(struct wfx_vif *wvif)
+{
+	struct wfx_dev *wdev = wvif->wdev;
+	struct ieee80211_tx_info *tx_info;
+	struct hif_msg *hif;
+	struct sk_buff *skb;
+	int i;
+
+	for (i = 0; i < IEEE80211_NUM_ACS; ++i) {
+		skb_queue_walk(&wdev->tx_queue[i].queue, skb) {
+			tx_info = IEEE80211_SKB_CB(skb);
+			hif = (struct hif_msg *)skb->data;
+			if ((tx_info->flags & IEEE80211_TX_CTL_SEND_AFTER_DTIM) &&
+			    (hif->interface == wvif->id))
+				return (struct hif_msg *)skb->data;
+		}
+	}
+	return NULL;
+}
+
 struct hif_msg *wfx_tx_queues_get(struct wfx_dev *wdev)
 {
 	struct sk_buff *skb;
 	struct hif_msg *hif = NULL;
-	struct hif_req_tx *req = NULL;
 	struct wfx_queue *queue = NULL;
 	struct wfx_queue *vif_queue = NULL;
 	u32 tx_allowed_mask = 0;
 	u32 vif_tx_allowed_mask = 0;
 	const struct wfx_tx_priv *tx_priv = NULL;
 	struct wfx_vif *wvif;
-	/* More is used only for broadcasts. */
-	bool more = false;
-	bool vif_more = false;
 	int not_found;
 	int burst;
+	int i;
+
+	if (atomic_read(&wdev->tx_lock))
+		return NULL;
+
+	wvif = NULL;
+	while ((wvif = wvif_iterate(wdev, wvif)) != NULL) {
+		if (wvif->after_dtim_tx_allowed) {
+			for (i = 0; i < IEEE80211_NUM_ACS; ++i) {
+				skb = wfx_tx_queue_get(wvif->wdev,
+						       &wdev->tx_queue[i],
+						       BIT(WFX_LINK_ID_AFTER_DTIM));
+				if (skb) {
+					hif = (struct hif_msg *)skb->data;
+					// Cannot happen since only one vif can
+					// be AP at time
+					WARN_ON(wvif->id != hif->interface);
+					return hif;
+				}
+			}
+			// No more multicast to sent
+			wvif->after_dtim_tx_allowed = false;
+			schedule_work(&wvif->update_tim_work);
+		}
+	}
 
 	for (;;) {
 		int ret = -ENOENT;
 		int queue_num;
-		struct ieee80211_hdr *hdr;
-
-		if (atomic_read(&wdev->tx_lock))
-			return NULL;
 
 		wvif = NULL;
 		while ((wvif = wvif_iterate(wdev, wvif)) != NULL) {
 			spin_lock_bh(&wvif->ps_state_lock);
 
 			not_found = wfx_tx_queue_mask_get(wvif, &vif_queue,
-							  &vif_tx_allowed_mask,
-							  &vif_more);
-
-			if (wvif->mcast_buffered && (not_found || !vif_more) &&
-					(wvif->mcast_tx ||
-					 !wvif->sta_asleep_mask)) {
-				wvif->mcast_buffered = false;
-				if (wvif->mcast_tx) {
-					wvif->mcast_tx = false;
-					schedule_work(&wvif->mcast_stop_work);
-				}
-			}
+							  &vif_tx_allowed_mask);
 
 			spin_unlock_bh(&wvif->ps_state_lock);
 
-			if (vif_more) {
-				more = true;
-				tx_allowed_mask = vif_tx_allowed_mask;
-				queue = vif_queue;
-				ret = 0;
-				break;
-			} else if (!not_found) {
+			if (!not_found) {
 				if (queue && queue != vif_queue)
 					dev_info(wdev->dev, "vifs disagree about queue priority\n");
 				tx_allowed_mask |= vif_tx_allowed_mask;
@@ -595,15 +602,6 @@ struct hif_msg *wfx_tx_queues_get(struct wfx_dev *wdev)
 		else
 			wdev->tx_burst_idx = -1;
 
-		/* more buffered multicast/broadcast frames
-		 *  ==> set MoreData flag in IEEE 802.11 header
-		 *  to inform PS STAs
-		 */
-		if (more) {
-			req = (struct hif_req_tx *) hif->body;
-			hdr = (struct ieee80211_hdr *) (req->frame + req->data_flags.fc_offset);
-			hdr->frame_control |= cpu_to_le16(IEEE80211_FCTL_MOREDATA);
-		}
 		return hif;
 	}
 }

commit 2e57865e79cfe82afcefff553300bb0eea07c1c2
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Wed Jan 15 13:55:19 2020 +0000

    staging: wfx: pspoll_mask make no sense
    
    pspoll_mask is here to send data buffered in driver. But since station
    is marked buffered, TIM for this station is 1 and mac80211 will call
    sta_notify when a ps-poll is received. So pspoll_mask is useless and
    sta_alseep_mask is sufficient.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200115135338.14374-54-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/queue.c b/drivers/staging/wfx/queue.c
index 3d40388739e3..42d64534c92c 100644
--- a/drivers/staging/wfx/queue.c
+++ b/drivers/staging/wfx/queue.c
@@ -493,12 +493,10 @@ static int wfx_tx_queue_mask_get(struct wfx_vif *wvif,
 	/* Search for unicast traffic */
 	tx_allowed_mask = ~wvif->sta_asleep_mask;
 	tx_allowed_mask |= BIT(WFX_LINK_ID_UAPSD);
-	if (wvif->sta_asleep_mask) {
-		tx_allowed_mask |= wvif->pspoll_mask;
+	if (wvif->sta_asleep_mask)
 		tx_allowed_mask &= ~BIT(WFX_LINK_ID_AFTER_DTIM);
-	} else {
+	else
 		tx_allowed_mask |= BIT(WFX_LINK_ID_AFTER_DTIM);
-	}
 	idx = wfx_get_prio_queue(wvif, tx_allowed_mask, &total);
 	if (idx < 0)
 		return -ENOENT;
@@ -585,8 +583,6 @@ struct hif_msg *wfx_tx_queues_get(struct wfx_dev *wdev)
 		if (hif_handle_tx_data(wvif, skb, queue))
 			continue;  /* Handled by WSM */
 
-		wvif->pspoll_mask &= ~BIT(tx_priv->raw_link_id);
-
 		/* allow bursting if txop is set */
 		if (wvif->edca_params[queue_num].txop)
 			burst = (int)wfx_tx_queue_get_num_queued(queue, tx_allowed_mask) + 1;

commit d6aeba575f277104a95125584981d37c8f7cf762
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Wed Jan 15 13:55:15 2020 +0000

    staging: wfx: simplify the link-id allocation
    
    The "link-id" is a slot number provided to the chip. A link-id is
    allocated to every station associated with the chip (mainly when the
    chip is in AP mode). It is more or less the same thing than the
    association ID, but it is limited to 14 values.
    
    Firmware uses the link-id to track the power save status of the
    stations.
    
    The current code try to associate a link-id as soon as data are
    exchanged with station. It is far easier to rely on sta_add() and
    sta_remove().
    
    Until now the value WFX_LINK_ID_NO_ASSOC, was only used when no more
    link-id was available. Now, we also use this value for
    not-yet-associated stations (that was its primary behavior).
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200115135338.14374-51-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/queue.c b/drivers/staging/wfx/queue.c
index 92bb9a794f30..3d40388739e3 100644
--- a/drivers/staging/wfx/queue.c
+++ b/drivers/staging/wfx/queue.c
@@ -378,13 +378,8 @@ static bool hif_handle_tx_data(struct wfx_vif *wvif, struct sk_buff *skb,
 			action = do_drop;
 		break;
 	case NL80211_IFTYPE_AP:
-		if (!wvif->state) {
+		if (!wvif->state)
 			action = do_drop;
-		} else if (!(BIT(tx_priv->raw_link_id) &
-			     (BIT(0) | wvif->link_id_map))) {
-			dev_warn(wvif->wdev->dev, "a frame with expired link-id is dropped\n");
-			action = do_drop;
-		}
 		break;
 	case NL80211_IFTYPE_ADHOC:
 		if (wvif->state != WFX_STATE_IBSS)

commit 044df863c98d4d4be6306f3251a9397f22418946
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Wed Jan 15 13:54:29 2020 +0000

    staging: wfx: fix __wfx_flush() when drop == false
    
    wfx_tx_queues_clear() only clear not yet sent requests. So, it always
    necessary to wait for tx_queue_stats.wait_link_id_empty whatever the
    value of "drop" argument.
    
    In add, it is not necessary to return with tx queue locked since all
    calls to __wfx_flush() unlock the tx queue just after the call to
    __wfx_tx_flush().
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200115135338.14374-20-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/queue.c b/drivers/staging/wfx/queue.c
index abfbad7c9f75..92bb9a794f30 100644
--- a/drivers/staging/wfx/queue.c
+++ b/drivers/staging/wfx/queue.c
@@ -31,8 +31,6 @@ void wfx_tx_flush(struct wfx_dev *wdev)
 {
 	int ret;
 
-	WARN(!atomic_read(&wdev->tx_lock), "tx_lock is not locked");
-
 	// Do not wait for any reply if chip is frozen
 	if (wdev->chip_frozen)
 		return;

commit 871341db220ab0b63153daf295946137f73e727a
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Tue Dec 17 16:15:27 2019 +0000

    staging: wfx: simplify hif_set_edca_queue_params() usage
    
    The struct hif_req_edca_queue_params comes from hardware API. It is not
    intended to be manipulated in upper layers of the driver.
    
    So, this patch:
      1. relocate the handling of this struct in hif_set_edca_queue_params()
         (the low level function)
      2. replace it in wfx_vif by the mac80211 equivalent: struct
         ieee80211_tx_queue_params
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20191217161318.31402-44-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/queue.c b/drivers/staging/wfx/queue.c
index 16216afe6cfc..abfbad7c9f75 100644
--- a/drivers/staging/wfx/queue.c
+++ b/drivers/staging/wfx/queue.c
@@ -443,7 +443,7 @@ static int wfx_get_prio_queue(struct wfx_vif *wvif,
 {
 	static const int urgent = BIT(WFX_LINK_ID_AFTER_DTIM) |
 		BIT(WFX_LINK_ID_UAPSD);
-	struct hif_req_edca_queue_params *edca;
+	const struct ieee80211_tx_queue_params *edca;
 	unsigned int score, best = -1;
 	int winner = -1;
 	int i;
@@ -458,7 +458,7 @@ static int wfx_get_prio_queue(struct wfx_vif *wvif,
 		if (!queued)
 			continue;
 		*total += queued;
-		score = ((edca->aifsn + edca->cw_min) << 16) +
+		score = ((edca->aifs + edca->cw_min) << 16) +
 			((edca->cw_max - edca->cw_min) *
 			 (get_random_int() & 0xFFFF));
 		if (score < best && (winner < 0 || i != 3)) {
@@ -595,7 +595,7 @@ struct hif_msg *wfx_tx_queues_get(struct wfx_dev *wdev)
 		wvif->pspoll_mask &= ~BIT(tx_priv->raw_link_id);
 
 		/* allow bursting if txop is set */
-		if (wvif->edca_params[queue_num].tx_op_limit)
+		if (wvif->edca_params[queue_num].txop)
 			burst = (int)wfx_tx_queue_get_num_queued(queue, tx_allowed_mask) + 1;
 		else
 			burst = 1;

commit 7e2b32f54f61cc5ebc9c18d605ee84cef53eb60d
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Tue Dec 17 16:15:24 2019 +0000

    staging: wfx: drop struct wfx_edca_params
    
    Intermediate structure wfx_edca_params does not help. This patch
    relocates its members directly in struct wfx_vif.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20191217161318.31402-42-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/queue.c b/drivers/staging/wfx/queue.c
index 680fed31cefb..16216afe6cfc 100644
--- a/drivers/staging/wfx/queue.c
+++ b/drivers/staging/wfx/queue.c
@@ -452,7 +452,7 @@ static int wfx_get_prio_queue(struct wfx_vif *wvif,
 	for (i = 0; i < IEEE80211_NUM_ACS; ++i) {
 		int queued;
 
-		edca = &wvif->edca.params[i];
+		edca = &wvif->edca_params[i];
 		queued = wfx_tx_queue_get_num_queued(&wvif->wdev->tx_queue[i],
 				tx_allowed_mask);
 		if (!queued)
@@ -595,7 +595,7 @@ struct hif_msg *wfx_tx_queues_get(struct wfx_dev *wdev)
 		wvif->pspoll_mask &= ~BIT(tx_priv->raw_link_id);
 
 		/* allow bursting if txop is set */
-		if (wvif->edca.params[queue_num].tx_op_limit)
+		if (wvif->edca_params[queue_num].tx_op_limit)
 			burst = (int)wfx_tx_queue_get_num_queued(queue, tx_allowed_mask) + 1;
 		else
 			burst = 1;

commit 8608ecdba5ce98031237add7727f8b9df457e381
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Tue Dec 17 16:14:37 2019 +0000

    staging: wfx: detect race condition in WEP authentication
    
    Current code has a special case to handle association with WEP. Before
    to rework the tx data handling, let's try to detect any possible misuse
    of this code.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20191217161318.31402-9-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/queue.c b/drivers/staging/wfx/queue.c
index c7ee90888f69..680fed31cefb 100644
--- a/drivers/staging/wfx/queue.c
+++ b/drivers/staging/wfx/queue.c
@@ -422,6 +422,7 @@ static bool hif_handle_tx_data(struct wfx_vif *wvif, struct sk_buff *skb,
 		break;
 	case do_wep:
 		wfx_tx_lock(wvif->wdev);
+		WARN_ON(wvif->wep_pending_skb);
 		wvif->wep_default_key_id = tx_priv->hw_key->keyidx;
 		wvif->wep_pending_skb = skb;
 		if (!schedule_work(&wvif->wep_key_work))

commit 8c7128c4cf4e0e6eb67bd65b4dbe619c3d297bb6
Author: Jules Irenge <jbi.octave@gmail.com>
Date:   Wed Nov 13 11:00:52 2019 +0000

    staging: align to fix warnings of line over 80 characters
    
    Align to fix multiple warnings of line over 80 characters.
    Issue detected by checkpatch tool.
    
    Signed-off-by: Jules Irenge <jbi.octave@gmail.com>
    Link: https://lore.kernel.org/r/20191113110052.14855-1-jbi.octave@gmail.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/queue.c b/drivers/staging/wfx/queue.c
index 71e92744fed0..c7ee90888f69 100644
--- a/drivers/staging/wfx/queue.c
+++ b/drivers/staging/wfx/queue.c
@@ -42,7 +42,8 @@ void wfx_tx_flush(struct wfx_dev *wdev)
 				 !wdev->hif.tx_buffers_used,
 				 msecs_to_jiffies(3000));
 	if (!ret) {
-		dev_warn(wdev->dev, "cannot flush tx buffers (%d still busy)\n", wdev->hif.tx_buffers_used);
+		dev_warn(wdev->dev, "cannot flush tx buffers (%d still busy)\n",
+			 wdev->hif.tx_buffers_used);
 		wfx_pending_dump_old_frames(wdev, 3000);
 		// FIXME: drop pending frames here
 		wdev->chip_frozen = 1;
@@ -121,7 +122,8 @@ void wfx_tx_queues_wait_empty_vif(struct wfx_vif *wvif)
 	} while (!done);
 }
 
-static void wfx_tx_queue_clear(struct wfx_dev *wdev, struct wfx_queue *queue, struct sk_buff_head *gc_list)
+static void wfx_tx_queue_clear(struct wfx_dev *wdev, struct wfx_queue *queue,
+			       struct sk_buff_head *gc_list)
 {
 	int i;
 	struct sk_buff *item;
@@ -189,7 +191,8 @@ size_t wfx_tx_queue_get_num_queued(struct wfx_queue *queue,
 		ret = skb_queue_len(&queue->queue);
 	} else {
 		ret = 0;
-		for (i = 0, bit = 1; i < ARRAY_SIZE(queue->link_map_cache); ++i, bit <<= 1) {
+		for (i = 0, bit = 1; i < ARRAY_SIZE(queue->link_map_cache);
+		     ++i, bit <<= 1) {
 			if (link_id_map & bit)
 				ret += queue->link_map_cache[i];
 		}
@@ -198,7 +201,8 @@ size_t wfx_tx_queue_get_num_queued(struct wfx_queue *queue,
 	return ret;
 }
 
-void wfx_tx_queue_put(struct wfx_dev *wdev, struct wfx_queue *queue, struct sk_buff *skb)
+void wfx_tx_queue_put(struct wfx_dev *wdev, struct wfx_queue *queue,
+		      struct sk_buff *skb)
 {
 	struct wfx_queue_stats *stats = &wdev->tx_queue_stats;
 	struct wfx_tx_priv *tx_priv = wfx_skb_tx_priv(skb);
@@ -315,7 +319,8 @@ void wfx_pending_dump_old_frames(struct wfx_dev *wdev, unsigned int limit_ms)
 	skb_queue_walk(&stats->pending, skb) {
 		tx_priv = wfx_skb_tx_priv(skb);
 		req = wfx_skb_txreq(skb);
-		if (ktime_after(now, ktime_add_ms(tx_priv->xmit_timestamp, limit_ms))) {
+		if (ktime_after(now, ktime_add_ms(tx_priv->xmit_timestamp,
+						  limit_ms))) {
 			if (first) {
 				dev_info(wdev->dev, "frames stuck in firmware since %dms or more:\n",
 					 limit_ms);
@@ -329,7 +334,8 @@ void wfx_pending_dump_old_frames(struct wfx_dev *wdev, unsigned int limit_ms)
 	spin_unlock_bh(&stats->pending.lock);
 }
 
-unsigned int wfx_pending_get_pkt_us_delay(struct wfx_dev *wdev, struct sk_buff *skb)
+unsigned int wfx_pending_get_pkt_us_delay(struct wfx_dev *wdev,
+					  struct sk_buff *skb)
 {
 	ktime_t now = ktime_get();
 	struct wfx_tx_priv *tx_priv = wfx_skb_tx_priv(skb);
@@ -376,7 +382,8 @@ static bool hif_handle_tx_data(struct wfx_vif *wvif, struct sk_buff *skb,
 	case NL80211_IFTYPE_AP:
 		if (!wvif->state) {
 			action = do_drop;
-		} else if (!(BIT(tx_priv->raw_link_id) & (BIT(0) | wvif->link_id_map))) {
+		} else if (!(BIT(tx_priv->raw_link_id) &
+			     (BIT(0) | wvif->link_id_map))) {
 			dev_warn(wvif->wdev->dev, "a frame with expired link-id is dropped\n");
 			action = do_drop;
 		}
@@ -462,7 +469,8 @@ static int wfx_get_prio_queue(struct wfx_vif *wvif,
 	/* override winner if bursting */
 	if (winner >= 0 && wvif->wdev->tx_burst_idx >= 0 &&
 	    winner != wvif->wdev->tx_burst_idx &&
-	    !wfx_tx_queue_get_num_queued(&wvif->wdev->tx_queue[winner], tx_allowed_mask & urgent) &&
+	    !wfx_tx_queue_get_num_queued(&wvif->wdev->tx_queue[winner],
+					 tx_allowed_mask & urgent) &&
 	    wfx_tx_queue_get_num_queued(&wvif->wdev->tx_queue[wvif->wdev->tx_burst_idx], tx_allowed_mask))
 		winner = wvif->wdev->tx_burst_idx;
 
@@ -536,10 +544,13 @@ struct hif_msg *wfx_tx_queues_get(struct wfx_dev *wdev)
 		while ((wvif = wvif_iterate(wdev, wvif)) != NULL) {
 			spin_lock_bh(&wvif->ps_state_lock);
 
-			not_found = wfx_tx_queue_mask_get(wvif, &vif_queue, &vif_tx_allowed_mask, &vif_more);
+			not_found = wfx_tx_queue_mask_get(wvif, &vif_queue,
+							  &vif_tx_allowed_mask,
+							  &vif_more);
 
 			if (wvif->mcast_buffered && (not_found || !vif_more) &&
-					(wvif->mcast_tx || !wvif->sta_asleep_mask)) {
+					(wvif->mcast_tx ||
+					 !wvif->sta_asleep_mask)) {
 				wvif->mcast_buffered = false;
 				if (wvif->mcast_tx) {
 					wvif->mcast_tx = false;

commit 168c7d76425d053ca6a311e450ac3627cffff5a7
Author: Jules Irenge <jbi.octave@gmail.com>
Date:   Tue Nov 5 01:03:52 2019 +0000

    staging: wfx: replace 1 by true
    
    Replace 1 by true when it is stored in a boolean variable.
    Recommended by coccinelle tool.
    
    Signed-off-by: Jules Irenge <jbi.octave@gmail.com>
    Link: https://lore.kernel.org/r/20191105010352.222479-3-jbi.octave@gmail.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/queue.c b/drivers/staging/wfx/queue.c
index 5d29bce65f71..71e92744fed0 100644
--- a/drivers/staging/wfx/queue.c
+++ b/drivers/staging/wfx/queue.c
@@ -550,7 +550,7 @@ struct hif_msg *wfx_tx_queues_get(struct wfx_dev *wdev)
 			spin_unlock_bh(&wvif->ps_state_lock);
 
 			if (vif_more) {
-				more = 1;
+				more = true;
 				tx_allowed_mask = vif_tx_allowed_mask;
 				queue = vif_queue;
 				ret = 0;

commit 2c1facbc437ceb00b022e4484900c831e39a773a
Author: Jules Irenge <jbi.octave@gmail.com>
Date:   Tue Nov 5 01:03:51 2019 +0000

    staging: wfx: replace 0 by NULL
    
    Replace 0 by NULL as the return value of a pointer-returning function.
    Issue detected by sparse tool.
    
    Signed-off-by: Jules Irenge <jbi.octave@gmail.com>
    Link: https://lore.kernel.org/r/20191105010352.222479-2-jbi.octave@gmail.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/queue.c b/drivers/staging/wfx/queue.c
index ef3ee55cf621..5d29bce65f71 100644
--- a/drivers/staging/wfx/queue.c
+++ b/drivers/staging/wfx/queue.c
@@ -565,7 +565,7 @@ struct hif_msg *wfx_tx_queues_get(struct wfx_dev *wdev)
 		}
 
 		if (ret)
-			return 0;
+			return NULL;
 
 		queue_num = queue - wdev->tx_queue;
 

commit dc3d13fba4695f53d55d4eebe0d714c8b1da62bd
Author: zhengbin <zhengbin13@huawei.com>
Date:   Wed Oct 9 21:50:29 2019 +0800

    staging: wfx: Make function 'wfx_tx_queue_get' static
    
    Fix sparse warnings:
    
    drivers/staging/wfx/queue.c:218:16: warning: symbol 'wfx_tx_queue_get' was not declared. Should it be static?
    
    Reported-by: Hulk Robot <hulkci@huawei.com>
    Signed-off-by: zhengbin <zhengbin13@huawei.com>
    Reviewed-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/1570629030-29888-3-git-send-email-zhengbin13@huawei.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/queue.c b/drivers/staging/wfx/queue.c
index ee9b2c3fde5a..ef3ee55cf621 100644
--- a/drivers/staging/wfx/queue.c
+++ b/drivers/staging/wfx/queue.c
@@ -215,7 +215,9 @@ void wfx_tx_queue_put(struct wfx_dev *wdev, struct wfx_queue *queue, struct sk_b
 	spin_unlock_bh(&queue->queue.lock);
 }
 
-struct sk_buff *wfx_tx_queue_get(struct wfx_dev *wdev, struct wfx_queue *queue, u32 link_id_map)
+static struct sk_buff *wfx_tx_queue_get(struct wfx_dev *wdev,
+					struct wfx_queue *queue,
+					u32 link_id_map)
 {
 	struct sk_buff *skb = NULL;
 	struct sk_buff *item;

commit b5be2aa3b3ac153f056f93406c520dc74a1cebbe
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Tue Oct 8 09:43:01 2019 +0000

    staging: wfx: drop calls to BUG_ON()
    
    Most of calls to BUG_ON() could replaced by WARN().
    
    By the way, this patch also try to favor WARN() (that include a comment
    about the problem) instead of WARN_ON().
    
    Reported-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20191008094232.10014-7-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/queue.c b/drivers/staging/wfx/queue.c
index 6f1be4f6f463..ee9b2c3fde5a 100644
--- a/drivers/staging/wfx/queue.c
+++ b/drivers/staging/wfx/queue.c
@@ -78,7 +78,7 @@ void wfx_tx_queues_unlock(struct wfx_dev *wdev)
 	for (i = 0; i < IEEE80211_NUM_ACS; ++i) {
 		queue = &wdev->tx_queue[i];
 		spin_lock_bh(&queue->queue.lock);
-		BUG_ON(!queue->tx_locked_cnt);
+		WARN(!queue->tx_locked_cnt, "queue already unlocked");
 		if (--queue->tx_locked_cnt == 0)
 			ieee80211_wake_queue(wdev->hw, queue->queue_id);
 		spin_unlock_bh(&queue->queue.lock);
@@ -295,8 +295,8 @@ struct sk_buff *wfx_pending_get(struct wfx_dev *wdev, u32 packet_id)
 			return skb;
 		}
 	}
-	WARN_ON(1);
 	spin_unlock_bh(&stats->pending.lock);
+	WARN(1, "cannot find packet in pending queue");
 	return NULL;
 }
 
@@ -408,7 +408,7 @@ static bool hif_handle_tx_data(struct wfx_vif *wvif, struct sk_buff *skb,
 
 	switch (action) {
 	case do_drop:
-		BUG_ON(wfx_pending_remove(wvif->wdev, skb));
+		wfx_pending_remove(wvif->wdev, skb);
 		handled = true;
 		break;
 	case do_wep:

commit 40115bbc40e2fd2de0e01ef2a28e0d09a1b5d0d1
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Thu Sep 19 14:25:48 2019 +0000

    staging: wfx: implement the rest of mac80211 API
    
    Finish to fill struct ieee80211_ops with necessary callbacks. Driver is
    now ready to be registered to mac80211.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20190919142527.31797-21-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/queue.c b/drivers/staging/wfx/queue.c
index aa438be21d37..6f1be4f6f463 100644
--- a/drivers/staging/wfx/queue.c
+++ b/drivers/staging/wfx/queue.c
@@ -351,6 +351,83 @@ bool wfx_tx_queues_is_empty(struct wfx_dev *wdev)
 	return ret;
 }
 
+static bool hif_handle_tx_data(struct wfx_vif *wvif, struct sk_buff *skb,
+			       struct wfx_queue *queue)
+{
+	bool handled = false;
+	struct wfx_tx_priv *tx_priv = wfx_skb_tx_priv(skb);
+	struct hif_req_tx *req = wfx_skb_txreq(skb);
+	struct ieee80211_hdr *frame = (struct ieee80211_hdr *) (req->frame + req->data_flags.fc_offset);
+
+	enum {
+		do_probe,
+		do_drop,
+		do_wep,
+		do_tx,
+	} action = do_tx;
+
+	switch (wvif->vif->type) {
+	case NL80211_IFTYPE_STATION:
+		if (wvif->state < WFX_STATE_PRE_STA)
+			action = do_drop;
+		break;
+	case NL80211_IFTYPE_AP:
+		if (!wvif->state) {
+			action = do_drop;
+		} else if (!(BIT(tx_priv->raw_link_id) & (BIT(0) | wvif->link_id_map))) {
+			dev_warn(wvif->wdev->dev, "a frame with expired link-id is dropped\n");
+			action = do_drop;
+		}
+		break;
+	case NL80211_IFTYPE_ADHOC:
+		if (wvif->state != WFX_STATE_IBSS)
+			action = do_drop;
+		break;
+	case NL80211_IFTYPE_MONITOR:
+	default:
+		action = do_drop;
+		break;
+	}
+
+	if (action == do_tx) {
+		if (ieee80211_is_nullfunc(frame->frame_control)) {
+			mutex_lock(&wvif->bss_loss_lock);
+			if (wvif->bss_loss_state) {
+				wvif->bss_loss_confirm_id = req->packet_id;
+				req->queue_id.queue_id = HIF_QUEUE_ID_VOICE;
+			}
+			mutex_unlock(&wvif->bss_loss_lock);
+		} else if (ieee80211_has_protected(frame->frame_control) &&
+			   tx_priv->hw_key &&
+			   tx_priv->hw_key->keyidx != wvif->wep_default_key_id &&
+			   (tx_priv->hw_key->cipher == WLAN_CIPHER_SUITE_WEP40 ||
+			    tx_priv->hw_key->cipher == WLAN_CIPHER_SUITE_WEP104)) {
+			action = do_wep;
+		}
+	}
+
+	switch (action) {
+	case do_drop:
+		BUG_ON(wfx_pending_remove(wvif->wdev, skb));
+		handled = true;
+		break;
+	case do_wep:
+		wfx_tx_lock(wvif->wdev);
+		wvif->wep_default_key_id = tx_priv->hw_key->keyidx;
+		wvif->wep_pending_skb = skb;
+		if (!schedule_work(&wvif->wep_key_work))
+			wfx_tx_unlock(wvif->wdev);
+		handled = true;
+		break;
+	case do_tx:
+		break;
+	default:
+		/* Do nothing */
+		break;
+	}
+	return handled;
+}
+
 static int wfx_get_prio_queue(struct wfx_vif *wvif,
 				 u32 tx_allowed_mask, int *total)
 {
@@ -498,6 +575,9 @@ struct hif_msg *wfx_tx_queues_get(struct wfx_dev *wdev)
 		wvif = wdev_to_wvif(wdev, hif->interface);
 		WARN_ON(!wvif);
 
+		if (hif_handle_tx_data(wvif, skb, queue))
+			continue;  /* Handled by WSM */
+
 		wvif->pspoll_mask &= ~BIT(tx_priv->raw_link_id);
 
 		/* allow bursting if txop is set */

commit 9bca45f3d6924f19f29c0d019e961af3f41bdc9e
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Thu Sep 19 14:25:45 2019 +0000

    staging: wfx: allow to send 802.11 frames
    
    Three things make this task more complex than it should:
      - Chip necessitate to associate a link-id to each station. It is same
        thing than association ID but, using 8 bits only.
      - Rate policy is sent separately from Tx frames
      - Driver try to handle itself power saving of stations and multicast
        data
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20190919142527.31797-17-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/queue.c b/drivers/staging/wfx/queue.c
new file mode 100644
index 000000000000..aa438be21d37
--- /dev/null
+++ b/drivers/staging/wfx/queue.c
@@ -0,0 +1,526 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * O(1) TX queue with built-in allocator.
+ *
+ * Copyright (c) 2017-2019, Silicon Laboratories, Inc.
+ * Copyright (c) 2010, ST-Ericsson
+ */
+#include <linux/sched.h>
+#include <net/mac80211.h>
+
+#include "queue.h"
+#include "wfx.h"
+#include "sta.h"
+#include "data_tx.h"
+
+void wfx_tx_lock(struct wfx_dev *wdev)
+{
+	atomic_inc(&wdev->tx_lock);
+}
+
+void wfx_tx_unlock(struct wfx_dev *wdev)
+{
+	int tx_lock = atomic_dec_return(&wdev->tx_lock);
+
+	WARN(tx_lock < 0, "inconsistent tx_lock value");
+	if (!tx_lock)
+		wfx_bh_request_tx(wdev);
+}
+
+void wfx_tx_flush(struct wfx_dev *wdev)
+{
+	int ret;
+
+	WARN(!atomic_read(&wdev->tx_lock), "tx_lock is not locked");
+
+	// Do not wait for any reply if chip is frozen
+	if (wdev->chip_frozen)
+		return;
+
+	mutex_lock(&wdev->hif_cmd.lock);
+	ret = wait_event_timeout(wdev->hif.tx_buffers_empty,
+				 !wdev->hif.tx_buffers_used,
+				 msecs_to_jiffies(3000));
+	if (!ret) {
+		dev_warn(wdev->dev, "cannot flush tx buffers (%d still busy)\n", wdev->hif.tx_buffers_used);
+		wfx_pending_dump_old_frames(wdev, 3000);
+		// FIXME: drop pending frames here
+		wdev->chip_frozen = 1;
+	}
+	mutex_unlock(&wdev->hif_cmd.lock);
+}
+
+void wfx_tx_lock_flush(struct wfx_dev *wdev)
+{
+	wfx_tx_lock(wdev);
+	wfx_tx_flush(wdev);
+}
+
+void wfx_tx_queues_lock(struct wfx_dev *wdev)
+{
+	int i;
+	struct wfx_queue *queue;
+
+	for (i = 0; i < IEEE80211_NUM_ACS; ++i) {
+		queue = &wdev->tx_queue[i];
+		spin_lock_bh(&queue->queue.lock);
+		if (queue->tx_locked_cnt++ == 0)
+			ieee80211_stop_queue(wdev->hw, queue->queue_id);
+		spin_unlock_bh(&queue->queue.lock);
+	}
+}
+
+void wfx_tx_queues_unlock(struct wfx_dev *wdev)
+{
+	int i;
+	struct wfx_queue *queue;
+
+	for (i = 0; i < IEEE80211_NUM_ACS; ++i) {
+		queue = &wdev->tx_queue[i];
+		spin_lock_bh(&queue->queue.lock);
+		BUG_ON(!queue->tx_locked_cnt);
+		if (--queue->tx_locked_cnt == 0)
+			ieee80211_wake_queue(wdev->hw, queue->queue_id);
+		spin_unlock_bh(&queue->queue.lock);
+	}
+}
+
+/* If successful, LOCKS the TX queue! */
+void wfx_tx_queues_wait_empty_vif(struct wfx_vif *wvif)
+{
+	int i;
+	bool done;
+	struct wfx_queue *queue;
+	struct sk_buff *item;
+	struct wfx_dev *wdev = wvif->wdev;
+	struct hif_msg *hif;
+
+	if (wvif->wdev->chip_frozen) {
+		wfx_tx_lock_flush(wdev);
+		wfx_tx_queues_clear(wdev);
+		return;
+	}
+
+	do {
+		done = true;
+		wfx_tx_lock_flush(wdev);
+		for (i = 0; i < IEEE80211_NUM_ACS && done; ++i) {
+			queue = &wdev->tx_queue[i];
+			spin_lock_bh(&queue->queue.lock);
+			skb_queue_walk(&queue->queue, item) {
+				hif = (struct hif_msg *) item->data;
+				if (hif->interface == wvif->id)
+					done = false;
+			}
+			spin_unlock_bh(&queue->queue.lock);
+		}
+		if (!done) {
+			wfx_tx_unlock(wdev);
+			msleep(20);
+		}
+	} while (!done);
+}
+
+static void wfx_tx_queue_clear(struct wfx_dev *wdev, struct wfx_queue *queue, struct sk_buff_head *gc_list)
+{
+	int i;
+	struct sk_buff *item;
+	struct wfx_queue_stats *stats = &wdev->tx_queue_stats;
+
+	spin_lock_bh(&queue->queue.lock);
+	while ((item = __skb_dequeue(&queue->queue)) != NULL)
+		skb_queue_head(gc_list, item);
+	spin_lock_bh(&stats->pending.lock);
+	for (i = 0; i < ARRAY_SIZE(stats->link_map_cache); ++i) {
+		stats->link_map_cache[i] -= queue->link_map_cache[i];
+		queue->link_map_cache[i] = 0;
+	}
+	spin_unlock_bh(&stats->pending.lock);
+	spin_unlock_bh(&queue->queue.lock);
+}
+
+void wfx_tx_queues_clear(struct wfx_dev *wdev)
+{
+	int i;
+	struct sk_buff *item;
+	struct sk_buff_head gc_list;
+	struct wfx_queue_stats *stats = &wdev->tx_queue_stats;
+
+	skb_queue_head_init(&gc_list);
+	for (i = 0; i < IEEE80211_NUM_ACS; ++i)
+		wfx_tx_queue_clear(wdev, &wdev->tx_queue[i], &gc_list);
+	wake_up(&stats->wait_link_id_empty);
+	while ((item = skb_dequeue(&gc_list)) != NULL)
+		wfx_skb_dtor(wdev, item);
+}
+
+void wfx_tx_queues_init(struct wfx_dev *wdev)
+{
+	int i;
+
+	memset(&wdev->tx_queue_stats, 0, sizeof(wdev->tx_queue_stats));
+	memset(wdev->tx_queue, 0, sizeof(wdev->tx_queue));
+	skb_queue_head_init(&wdev->tx_queue_stats.pending);
+	init_waitqueue_head(&wdev->tx_queue_stats.wait_link_id_empty);
+
+	for (i = 0; i < IEEE80211_NUM_ACS; ++i) {
+		wdev->tx_queue[i].queue_id = i;
+		skb_queue_head_init(&wdev->tx_queue[i].queue);
+	}
+}
+
+void wfx_tx_queues_deinit(struct wfx_dev *wdev)
+{
+	WARN_ON(!skb_queue_empty(&wdev->tx_queue_stats.pending));
+	wfx_tx_queues_clear(wdev);
+}
+
+size_t wfx_tx_queue_get_num_queued(struct wfx_queue *queue,
+				   u32 link_id_map)
+{
+	size_t ret;
+	int i, bit;
+
+	if (!link_id_map)
+		return 0;
+
+	spin_lock_bh(&queue->queue.lock);
+	if (link_id_map == (u32)-1) {
+		ret = skb_queue_len(&queue->queue);
+	} else {
+		ret = 0;
+		for (i = 0, bit = 1; i < ARRAY_SIZE(queue->link_map_cache); ++i, bit <<= 1) {
+			if (link_id_map & bit)
+				ret += queue->link_map_cache[i];
+		}
+	}
+	spin_unlock_bh(&queue->queue.lock);
+	return ret;
+}
+
+void wfx_tx_queue_put(struct wfx_dev *wdev, struct wfx_queue *queue, struct sk_buff *skb)
+{
+	struct wfx_queue_stats *stats = &wdev->tx_queue_stats;
+	struct wfx_tx_priv *tx_priv = wfx_skb_tx_priv(skb);
+
+	WARN(tx_priv->link_id >= ARRAY_SIZE(stats->link_map_cache), "invalid link-id value");
+	spin_lock_bh(&queue->queue.lock);
+	__skb_queue_tail(&queue->queue, skb);
+
+	++queue->link_map_cache[tx_priv->link_id];
+
+	spin_lock_bh(&stats->pending.lock);
+	++stats->link_map_cache[tx_priv->link_id];
+	spin_unlock_bh(&stats->pending.lock);
+	spin_unlock_bh(&queue->queue.lock);
+}
+
+struct sk_buff *wfx_tx_queue_get(struct wfx_dev *wdev, struct wfx_queue *queue, u32 link_id_map)
+{
+	struct sk_buff *skb = NULL;
+	struct sk_buff *item;
+	struct wfx_queue_stats *stats = &wdev->tx_queue_stats;
+	struct wfx_tx_priv *tx_priv;
+	bool wakeup_stats = false;
+
+	spin_lock_bh(&queue->queue.lock);
+	skb_queue_walk(&queue->queue, item) {
+		tx_priv = wfx_skb_tx_priv(item);
+		if (link_id_map & BIT(tx_priv->link_id)) {
+			skb = item;
+			break;
+		}
+	}
+	WARN_ON(!skb);
+	if (skb) {
+		tx_priv = wfx_skb_tx_priv(skb);
+		tx_priv->xmit_timestamp = ktime_get();
+		__skb_unlink(skb, &queue->queue);
+		--queue->link_map_cache[tx_priv->link_id];
+
+		spin_lock_bh(&stats->pending.lock);
+		__skb_queue_tail(&stats->pending, skb);
+		if (!--stats->link_map_cache[tx_priv->link_id])
+			wakeup_stats = true;
+		spin_unlock_bh(&stats->pending.lock);
+	}
+	spin_unlock_bh(&queue->queue.lock);
+	if (wakeup_stats)
+		wake_up(&stats->wait_link_id_empty);
+	return skb;
+}
+
+int wfx_pending_requeue(struct wfx_dev *wdev, struct sk_buff *skb)
+{
+	struct wfx_queue_stats *stats = &wdev->tx_queue_stats;
+	struct wfx_tx_priv *tx_priv = wfx_skb_tx_priv(skb);
+	struct wfx_queue *queue = &wdev->tx_queue[skb_get_queue_mapping(skb)];
+
+	WARN_ON(skb_get_queue_mapping(skb) > 3);
+	spin_lock_bh(&queue->queue.lock);
+	++queue->link_map_cache[tx_priv->link_id];
+
+	spin_lock_bh(&stats->pending.lock);
+	++stats->link_map_cache[tx_priv->link_id];
+	__skb_unlink(skb, &stats->pending);
+	spin_unlock_bh(&stats->pending.lock);
+	__skb_queue_tail(&queue->queue, skb);
+	spin_unlock_bh(&queue->queue.lock);
+	return 0;
+}
+
+int wfx_pending_remove(struct wfx_dev *wdev, struct sk_buff *skb)
+{
+	struct wfx_queue_stats *stats = &wdev->tx_queue_stats;
+
+	spin_lock_bh(&stats->pending.lock);
+	__skb_unlink(skb, &stats->pending);
+	spin_unlock_bh(&stats->pending.lock);
+	wfx_skb_dtor(wdev, skb);
+
+	return 0;
+}
+
+struct sk_buff *wfx_pending_get(struct wfx_dev *wdev, u32 packet_id)
+{
+	struct sk_buff *skb;
+	struct hif_req_tx *req;
+	struct wfx_queue_stats *stats = &wdev->tx_queue_stats;
+
+	spin_lock_bh(&stats->pending.lock);
+	skb_queue_walk(&stats->pending, skb) {
+		req = wfx_skb_txreq(skb);
+		if (req->packet_id == packet_id) {
+			spin_unlock_bh(&stats->pending.lock);
+			return skb;
+		}
+	}
+	WARN_ON(1);
+	spin_unlock_bh(&stats->pending.lock);
+	return NULL;
+}
+
+void wfx_pending_dump_old_frames(struct wfx_dev *wdev, unsigned int limit_ms)
+{
+	struct wfx_queue_stats *stats = &wdev->tx_queue_stats;
+	ktime_t now = ktime_get();
+	struct wfx_tx_priv *tx_priv;
+	struct hif_req_tx *req;
+	struct sk_buff *skb;
+	bool first = true;
+
+	spin_lock_bh(&stats->pending.lock);
+	skb_queue_walk(&stats->pending, skb) {
+		tx_priv = wfx_skb_tx_priv(skb);
+		req = wfx_skb_txreq(skb);
+		if (ktime_after(now, ktime_add_ms(tx_priv->xmit_timestamp, limit_ms))) {
+			if (first) {
+				dev_info(wdev->dev, "frames stuck in firmware since %dms or more:\n",
+					 limit_ms);
+				first = false;
+			}
+			dev_info(wdev->dev, "   id %08x sent %lldms ago\n",
+				 req->packet_id,
+				 ktime_ms_delta(now, tx_priv->xmit_timestamp));
+		}
+	}
+	spin_unlock_bh(&stats->pending.lock);
+}
+
+unsigned int wfx_pending_get_pkt_us_delay(struct wfx_dev *wdev, struct sk_buff *skb)
+{
+	ktime_t now = ktime_get();
+	struct wfx_tx_priv *tx_priv = wfx_skb_tx_priv(skb);
+
+	return ktime_us_delta(now, tx_priv->xmit_timestamp);
+}
+
+bool wfx_tx_queues_is_empty(struct wfx_dev *wdev)
+{
+	int i;
+	struct sk_buff_head *queue;
+	bool ret = true;
+
+	for (i = 0; i < IEEE80211_NUM_ACS; i++) {
+		queue = &wdev->tx_queue[i].queue;
+		spin_lock_bh(&queue->lock);
+		if (!skb_queue_empty(queue))
+			ret = false;
+		spin_unlock_bh(&queue->lock);
+	}
+	return ret;
+}
+
+static int wfx_get_prio_queue(struct wfx_vif *wvif,
+				 u32 tx_allowed_mask, int *total)
+{
+	static const int urgent = BIT(WFX_LINK_ID_AFTER_DTIM) |
+		BIT(WFX_LINK_ID_UAPSD);
+	struct hif_req_edca_queue_params *edca;
+	unsigned int score, best = -1;
+	int winner = -1;
+	int i;
+
+	/* search for a winner using edca params */
+	for (i = 0; i < IEEE80211_NUM_ACS; ++i) {
+		int queued;
+
+		edca = &wvif->edca.params[i];
+		queued = wfx_tx_queue_get_num_queued(&wvif->wdev->tx_queue[i],
+				tx_allowed_mask);
+		if (!queued)
+			continue;
+		*total += queued;
+		score = ((edca->aifsn + edca->cw_min) << 16) +
+			((edca->cw_max - edca->cw_min) *
+			 (get_random_int() & 0xFFFF));
+		if (score < best && (winner < 0 || i != 3)) {
+			best = score;
+			winner = i;
+		}
+	}
+
+	/* override winner if bursting */
+	if (winner >= 0 && wvif->wdev->tx_burst_idx >= 0 &&
+	    winner != wvif->wdev->tx_burst_idx &&
+	    !wfx_tx_queue_get_num_queued(&wvif->wdev->tx_queue[winner], tx_allowed_mask & urgent) &&
+	    wfx_tx_queue_get_num_queued(&wvif->wdev->tx_queue[wvif->wdev->tx_burst_idx], tx_allowed_mask))
+		winner = wvif->wdev->tx_burst_idx;
+
+	return winner;
+}
+
+static int wfx_tx_queue_mask_get(struct wfx_vif *wvif,
+				     struct wfx_queue **queue_p,
+				     u32 *tx_allowed_mask_p,
+				     bool *more)
+{
+	int idx;
+	u32 tx_allowed_mask;
+	int total = 0;
+
+	/* Search for a queue with multicast frames buffered */
+	if (wvif->mcast_tx) {
+		tx_allowed_mask = BIT(WFX_LINK_ID_AFTER_DTIM);
+		idx = wfx_get_prio_queue(wvif, tx_allowed_mask, &total);
+		if (idx >= 0) {
+			*more = total > 1;
+			goto found;
+		}
+	}
+
+	/* Search for unicast traffic */
+	tx_allowed_mask = ~wvif->sta_asleep_mask;
+	tx_allowed_mask |= BIT(WFX_LINK_ID_UAPSD);
+	if (wvif->sta_asleep_mask) {
+		tx_allowed_mask |= wvif->pspoll_mask;
+		tx_allowed_mask &= ~BIT(WFX_LINK_ID_AFTER_DTIM);
+	} else {
+		tx_allowed_mask |= BIT(WFX_LINK_ID_AFTER_DTIM);
+	}
+	idx = wfx_get_prio_queue(wvif, tx_allowed_mask, &total);
+	if (idx < 0)
+		return -ENOENT;
+
+found:
+	*queue_p = &wvif->wdev->tx_queue[idx];
+	*tx_allowed_mask_p = tx_allowed_mask;
+	return 0;
+}
+
+struct hif_msg *wfx_tx_queues_get(struct wfx_dev *wdev)
+{
+	struct sk_buff *skb;
+	struct hif_msg *hif = NULL;
+	struct hif_req_tx *req = NULL;
+	struct wfx_queue *queue = NULL;
+	struct wfx_queue *vif_queue = NULL;
+	u32 tx_allowed_mask = 0;
+	u32 vif_tx_allowed_mask = 0;
+	const struct wfx_tx_priv *tx_priv = NULL;
+	struct wfx_vif *wvif;
+	/* More is used only for broadcasts. */
+	bool more = false;
+	bool vif_more = false;
+	int not_found;
+	int burst;
+
+	for (;;) {
+		int ret = -ENOENT;
+		int queue_num;
+		struct ieee80211_hdr *hdr;
+
+		if (atomic_read(&wdev->tx_lock))
+			return NULL;
+
+		wvif = NULL;
+		while ((wvif = wvif_iterate(wdev, wvif)) != NULL) {
+			spin_lock_bh(&wvif->ps_state_lock);
+
+			not_found = wfx_tx_queue_mask_get(wvif, &vif_queue, &vif_tx_allowed_mask, &vif_more);
+
+			if (wvif->mcast_buffered && (not_found || !vif_more) &&
+					(wvif->mcast_tx || !wvif->sta_asleep_mask)) {
+				wvif->mcast_buffered = false;
+				if (wvif->mcast_tx) {
+					wvif->mcast_tx = false;
+					schedule_work(&wvif->mcast_stop_work);
+				}
+			}
+
+			spin_unlock_bh(&wvif->ps_state_lock);
+
+			if (vif_more) {
+				more = 1;
+				tx_allowed_mask = vif_tx_allowed_mask;
+				queue = vif_queue;
+				ret = 0;
+				break;
+			} else if (!not_found) {
+				if (queue && queue != vif_queue)
+					dev_info(wdev->dev, "vifs disagree about queue priority\n");
+				tx_allowed_mask |= vif_tx_allowed_mask;
+				queue = vif_queue;
+				ret = 0;
+			}
+		}
+
+		if (ret)
+			return 0;
+
+		queue_num = queue - wdev->tx_queue;
+
+		skb = wfx_tx_queue_get(wdev, queue, tx_allowed_mask);
+		if (!skb)
+			continue;
+		tx_priv = wfx_skb_tx_priv(skb);
+		hif = (struct hif_msg *) skb->data;
+		wvif = wdev_to_wvif(wdev, hif->interface);
+		WARN_ON(!wvif);
+
+		wvif->pspoll_mask &= ~BIT(tx_priv->raw_link_id);
+
+		/* allow bursting if txop is set */
+		if (wvif->edca.params[queue_num].tx_op_limit)
+			burst = (int)wfx_tx_queue_get_num_queued(queue, tx_allowed_mask) + 1;
+		else
+			burst = 1;
+
+		/* store index of bursting queue */
+		if (burst > 1)
+			wdev->tx_burst_idx = queue_num;
+		else
+			wdev->tx_burst_idx = -1;
+
+		/* more buffered multicast/broadcast frames
+		 *  ==> set MoreData flag in IEEE 802.11 header
+		 *  to inform PS STAs
+		 */
+		if (more) {
+			req = (struct hif_req_tx *) hif->body;
+			hdr = (struct ieee80211_hdr *) (req->frame + req->data_flags.fc_offset);
+			hdr->frame_control |= cpu_to_le16(IEEE80211_FCTL_MOREDATA);
+		}
+		return hif;
+	}
+}
