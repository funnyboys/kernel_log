commit 29de523a6270a308d12d21f4fecf52dac491e226
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Fri May 29 14:12:56 2020 +0200

    staging: wfx: fix coherency of hif_scan() prototype
    
    The function hif_scan() return the timeout for the completion of the
    scan request. It is the only function from hif_tx.c that return another
    thing than just an error code. This behavior is not coherent with the
    rest of file. Worse, if value returned is positive, the caller can't
    make say if it is a timeout or the value returned by the hardware.
    
    Uniformize API with other HIF functions, only return the error code and
    pass timeout with parameters.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200529121256.1045521-1-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/scan.c b/drivers/staging/wfx/scan.c
index 57ea9997800b..e9de19784865 100644
--- a/drivers/staging/wfx/scan.c
+++ b/drivers/staging/wfx/scan.c
@@ -56,10 +56,10 @@ static int send_scan_req(struct wfx_vif *wvif,
 	wfx_tx_lock_flush(wvif->wdev);
 	wvif->scan_abort = false;
 	reinit_completion(&wvif->scan_complete);
-	timeout = hif_scan(wvif, req, start_idx, i - start_idx);
-	if (timeout < 0) {
+	ret = hif_scan(wvif, req, start_idx, i - start_idx, &timeout);
+	if (ret) {
 		wfx_tx_unlock(wvif->wdev);
-		return timeout;
+		return -EIO;
 	}
 	ret = wait_for_completion_timeout(&wvif->scan_complete, timeout);
 	if (req->channels[start_idx]->max_power != wvif->vif->bss_conf.txpower)

commit c2312ff575fcaed96889d5bb5392afcc604c9442
Merge: a3975dea1696 9cb1fd0efd19
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon May 25 09:11:19 2020 +0200

    Merge 5.7-rc7 into staging-next
    
    We need the staging/iio fixes in here as well.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit f214b7b6e7c959b4306df8e5c687887c547e38b6
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Fri May 15 10:33:19 2020 +0200

    staging: wfx: fix potential dead lock between join and scan
    
    The device disallows to start a scan request between hif_join() and
    hif_set_bss_params(). The driver is not protected against that. The
    worst case happens when association is aborted and hif_set_bss_params()
    never happens.
    
    mac80211 would never ask for scan during the association process. So,
    this patch just aborts the association in progress when scan is
    requested.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200515083325.378539-14-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/scan.c b/drivers/staging/wfx/scan.c
index 76761e4960dd..ef411bcc2bf9 100644
--- a/drivers/staging/wfx/scan.c
+++ b/drivers/staging/wfx/scan.c
@@ -88,6 +88,11 @@ void wfx_hw_scan_work(struct work_struct *work)
 
 	mutex_lock(&wvif->wdev->conf_mutex);
 	mutex_lock(&wvif->scan_lock);
+	if (wvif->join_in_progress) {
+		dev_info(wvif->wdev->dev, "%s: abort in-progress REQ_JOIN",
+			 __func__);
+		wfx_reset(wvif);
+	}
 	update_probe_tmpl(wvif, &hw_req->req);
 	chan_cur = 0;
 	do {

commit f0b9d875faa4499afe3381404c3795e9da84bc00
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Tue May 12 11:36:56 2020 +0300

    staging: wfx: unlock on error path
    
    We need to release the tx_lock on the error path before returning.
    
    Fixes: d1c015b4ef6f ("staging: wfx: rewrite wfx_hw_scan()")
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Cc: stable <stable@vger.kernel.org>
    Reviewed-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200512083656.GA251760@mwanda
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/scan.c b/drivers/staging/wfx/scan.c
index 6e1e50048651..9aa14331affd 100644
--- a/drivers/staging/wfx/scan.c
+++ b/drivers/staging/wfx/scan.c
@@ -57,8 +57,10 @@ static int send_scan_req(struct wfx_vif *wvif,
 	wvif->scan_abort = false;
 	reinit_completion(&wvif->scan_complete);
 	timeout = hif_scan(wvif, req, start_idx, i - start_idx);
-	if (timeout < 0)
+	if (timeout < 0) {
+		wfx_tx_unlock(wvif->wdev);
 		return timeout;
+	}
 	ret = wait_for_completion_timeout(&wvif->scan_complete, timeout);
 	if (req->channels[start_idx]->max_power != wvif->vif->bss_conf.txpower)
 		hif_set_output_power(wvif, wvif->vif->bss_conf.txpower);

commit a2ed058918886b7a749ba884efc231b0977b3159
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Mon Apr 20 18:03:07 2020 +0200

    staging: wfx: drop protection for asynchronous join during scan
    
    In former code (before the inclusion of the driver in mainline kernel),
    hif_join() could run asynchronously. When a join request was in
    progress, it was forbidden to launch hif_scan().
    
    Now, hif_join() is always run synchronously. There is no more reasons to
    keep a protection against this case.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200420160311.57323-13-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/scan.c b/drivers/staging/wfx/scan.c
index 276fdacd7143..76761e4960dd 100644
--- a/drivers/staging/wfx/scan.c
+++ b/drivers/staging/wfx/scan.c
@@ -110,9 +110,6 @@ int wfx_hw_scan(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 	if (vif->type == NL80211_IFTYPE_AP)
 		return -EOPNOTSUPP;
 
-	if (wvif->state == WFX_STATE_PRE_STA)
-		return -EBUSY;
-
 	wvif->scan_req = hw_req;
 	schedule_work(&wvif->scan_work);
 	return 0;

commit 0f55a72e7e38b7fc2a7366f3e9dfd5e8d55e5232
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Wed Apr 15 18:11:36 2020 +0200

    staging: wfx: stop changing filtering rule in wfx_hw_scan()
    
    It is not very clear why driver ask to firmware to stop filtering probe
    request during scan. It is particularly weird because scan is not
    supported in AP mode. In add, it does not restore previous filtering
    state after scanning.
    
    It seems to be a mistake and should be dropped.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200415161147.69738-10-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/scan.c b/drivers/staging/wfx/scan.c
index 0c7f4eef045c..276fdacd7143 100644
--- a/drivers/staging/wfx/scan.c
+++ b/drivers/staging/wfx/scan.c
@@ -89,7 +89,6 @@ void wfx_hw_scan_work(struct work_struct *work)
 	mutex_lock(&wvif->wdev->conf_mutex);
 	mutex_lock(&wvif->scan_lock);
 	update_probe_tmpl(wvif, &hw_req->req);
-	wfx_fwd_probe_req(wvif, true);
 	chan_cur = 0;
 	do {
 		ret = send_scan_req(wvif, &hw_req->req, chan_cur);

commit 0f66c31eb6c457a8013c7093fd3204e7d8808115
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Fri Apr 10 15:32:21 2020 +0200

    staging: wfx: fix race between configure_filter and remove_interface
    
    wfx_remove_interface() and wfx_configure_filter() can be run
    concurrently. Therefore, this patch protect access to the list of
    interfaces from wfx_configure_filter().
    
    Notice that wfx_configure_filter() now lock "conf_lock" and "scan_lock".
    Beside that, wfx_hw_scan_work() also access to the same locks. So we
    have to lock them in same order to avoid any deadlock.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200410133239.438347-2-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/scan.c b/drivers/staging/wfx/scan.c
index 6e1e50048651..0c7f4eef045c 100644
--- a/drivers/staging/wfx/scan.c
+++ b/drivers/staging/wfx/scan.c
@@ -86,8 +86,8 @@ void wfx_hw_scan_work(struct work_struct *work)
 	struct ieee80211_scan_request *hw_req = wvif->scan_req;
 	int chan_cur, ret;
 
-	mutex_lock(&wvif->scan_lock);
 	mutex_lock(&wvif->wdev->conf_mutex);
+	mutex_lock(&wvif->scan_lock);
 	update_probe_tmpl(wvif, &hw_req->req);
 	wfx_fwd_probe_req(wvif, true);
 	chan_cur = 0;
@@ -96,8 +96,8 @@ void wfx_hw_scan_work(struct work_struct *work)
 		if (ret > 0)
 			chan_cur += ret;
 	} while (ret > 0 && chan_cur < hw_req->req.n_channels);
-	mutex_unlock(&wvif->wdev->conf_mutex);
 	mutex_unlock(&wvif->scan_lock);
+	mutex_unlock(&wvif->wdev->conf_mutex);
 	__ieee80211_scan_completed_compat(wvif->wdev->hw, ret < 0);
 }
 

commit 7f091d319eb54adc597cdb8db906d5835a611665
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Wed Jan 15 13:54:59 2020 +0000

    staging: wfx: simplify wfx_scan_complete()
    
    wfx_scan_complete() do nothing with argument hif_ind_scan_cmpl. In add,
    hif_ind_scan_cmpl come from hardware API and is not expected to be used
    with upper layers of the driver.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200115135338.14374-40-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/scan.c b/drivers/staging/wfx/scan.c
index 5cc9df5eb6a1..6e1e50048651 100644
--- a/drivers/staging/wfx/scan.c
+++ b/drivers/staging/wfx/scan.c
@@ -127,8 +127,7 @@ void wfx_cancel_hw_scan(struct ieee80211_hw *hw, struct ieee80211_vif *vif)
 	hif_stop_scan(wvif);
 }
 
-void wfx_scan_complete(struct wfx_vif *wvif,
-		       const struct hif_ind_scan_cmpl *arg)
+void wfx_scan_complete(struct wfx_vif *wvif)
 {
 	complete(&wvif->scan_complete);
 }

commit f050f3dac6686903f001862cc7b67bd2dcaeaea1
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Wed Jan 15 13:54:21 2020 +0000

    staging: wfx: drop wdev->output_power
    
    mac80211 and the device are both able to control tx power per vif. But,
    the current code retrieve tx power from wfx_config(). So, it does not
    allow to setup the tx power independently for each vif. Driver just has
    to rely on bss_conf->txpower to get the correct information.
    
    In add, it is no more necessary to protect access to wdev->output_power
    with scan_lock.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200115135338.14374-15-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/scan.c b/drivers/staging/wfx/scan.c
index 8e0ac89fd28f..5cc9df5eb6a1 100644
--- a/drivers/staging/wfx/scan.c
+++ b/drivers/staging/wfx/scan.c
@@ -60,8 +60,8 @@ static int send_scan_req(struct wfx_vif *wvif,
 	if (timeout < 0)
 		return timeout;
 	ret = wait_for_completion_timeout(&wvif->scan_complete, timeout);
-	if (req->channels[start_idx]->max_power != wvif->wdev->output_power)
-		hif_set_output_power(wvif, wvif->wdev->output_power);
+	if (req->channels[start_idx]->max_power != wvif->vif->bss_conf.txpower)
+		hif_set_output_power(wvif, wvif->vif->bss_conf.txpower);
 	wfx_tx_unlock(wvif->wdev);
 	if (!ret) {
 		dev_notice(wvif->wdev->dev, "scan timeout\n");

commit 5fd64673cf6e2ca08447a77de3d2fe7e73d54915
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Wed Jan 15 13:54:10 2020 +0000

    staging: wfx: simplify hif_set_output_power() usage
    
    Hardware API use 10th of dBm for output power unit. Upper layers should
    use same units than mac80211 and the conversion should be done by low
    level layer of the driver (hif_set_output_power())
    
    In add, current code of hif_set_output_power() use a __le32 while the
    device API specify a specific structure for this.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200115135338.14374-7-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/scan.c b/drivers/staging/wfx/scan.c
index 9b3674b3226a..8e0ac89fd28f 100644
--- a/drivers/staging/wfx/scan.c
+++ b/drivers/staging/wfx/scan.c
@@ -61,7 +61,7 @@ static int send_scan_req(struct wfx_vif *wvif,
 		return timeout;
 	ret = wait_for_completion_timeout(&wvif->scan_complete, timeout);
 	if (req->channels[start_idx]->max_power != wvif->wdev->output_power)
-		hif_set_output_power(wvif, wvif->wdev->output_power * 10);
+		hif_set_output_power(wvif, wvif->wdev->output_power);
 	wfx_tx_unlock(wvif->wdev);
 	if (!ret) {
 		dev_notice(wvif->wdev->dev, "scan timeout\n");

commit 99aa34a62bce1366aa0b856ba9262e19072a1faf
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Wed Jan 15 13:54:05 2020 +0000

    staging: wfx: make hif_scan() usage clearer
    
    hif_scan() return max number of jiffies to wait before the completion
    indication. However, if this value is negative, an error has occurred.
    
    Reword the code to reflect that behavior.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20200115135338.14374-3-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/scan.c b/drivers/staging/wfx/scan.c
index 24061d09c404..9b3674b3226a 100644
--- a/drivers/staging/wfx/scan.c
+++ b/drivers/staging/wfx/scan.c
@@ -56,10 +56,9 @@ static int send_scan_req(struct wfx_vif *wvif,
 	wfx_tx_lock_flush(wvif->wdev);
 	wvif->scan_abort = false;
 	reinit_completion(&wvif->scan_complete);
-	ret = hif_scan(wvif, req, start_idx, i - start_idx);
-	if (ret < 0)
-		return ret;
-	timeout = ret;
+	timeout = hif_scan(wvif, req, start_idx, i - start_idx);
+	if (timeout < 0)
+		return timeout;
 	ret = wait_for_completion_timeout(&wvif->scan_complete, timeout);
 	if (req->channels[start_idx]->max_power != wvif->wdev->output_power)
 		hif_set_output_power(wvif, wvif->wdev->output_power * 10);

commit 4337074be76d853e3677461dd19bd7c1759c55f6
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Tue Dec 17 16:15:41 2019 +0000

    staging: wfx: implement cancel_hw_scan()
    
    The device provides an API to abort a scan request. Expose this feature
    to mac80211.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20191217161318.31402-55-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/scan.c b/drivers/staging/wfx/scan.c
index dde2f8868147..24061d09c404 100644
--- a/drivers/staging/wfx/scan.c
+++ b/drivers/staging/wfx/scan.c
@@ -54,6 +54,7 @@ static int send_scan_req(struct wfx_vif *wvif,
 			break;
 	}
 	wfx_tx_lock_flush(wvif->wdev);
+	wvif->scan_abort = false;
 	reinit_completion(&wvif->scan_complete);
 	ret = hif_scan(wvif, req, start_idx, i - start_idx);
 	if (ret < 0)
@@ -68,6 +69,10 @@ static int send_scan_req(struct wfx_vif *wvif,
 		hif_stop_scan(wvif);
 		return -ETIMEDOUT;
 	}
+	if (wvif->scan_abort) {
+		dev_notice(wvif->wdev->dev, "scan abort\n");
+		return -ECONNABORTED;
+	}
 	return i - start_idx;
 }
 
@@ -115,6 +120,14 @@ int wfx_hw_scan(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 	return 0;
 }
 
+void wfx_cancel_hw_scan(struct ieee80211_hw *hw, struct ieee80211_vif *vif)
+{
+	struct wfx_vif *wvif = (struct wfx_vif *)vif->drv_priv;
+
+	wvif->scan_abort = true;
+	hif_stop_scan(wvif);
+}
+
 void wfx_scan_complete(struct wfx_vif *wvif,
 		       const struct hif_ind_scan_cmpl *arg)
 {

commit 3dc67854dfa95f7d3f132988536ace282828378a
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Tue Dec 17 16:15:39 2019 +0000

    staging: wfx: delayed_link_loss cannot happen
    
    Original code allows to detect an BSS loss during a scan and delaying
    the handling of BSS loss. However, there it is no real problem to just
    make these two events mutually exclusive (there is just a performance
    penalty).
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20191217161318.31402-54-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/scan.c b/drivers/staging/wfx/scan.c
index bdbce6926e91..dde2f8868147 100644
--- a/drivers/staging/wfx/scan.c
+++ b/drivers/staging/wfx/scan.c
@@ -95,10 +95,6 @@ void wfx_hw_scan_work(struct work_struct *work)
 	mutex_unlock(&wvif->wdev->conf_mutex);
 	mutex_unlock(&wvif->scan_lock);
 	__ieee80211_scan_completed_compat(wvif->wdev->hw, ret < 0);
-	if (wvif->delayed_link_loss) {
-		wvif->delayed_link_loss = false;
-		wfx_cqm_bssloss_sm(wvif, 1, 0, 0);
-	}
 }
 
 int wfx_hw_scan(struct ieee80211_hw *hw, struct ieee80211_vif *vif,

commit 9699c88a4427d592655977a8cbeae46864df7700
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Tue Dec 17 16:15:38 2019 +0000

    staging: wfx: delayed_unjoin cannot happen
    
    Original code allows to detect an unjoin request during a scan and
    delaying the unjoin request. However, it is far easier to just block the
    unjoin request until the end of the scan request.
    
    In fact, it is already the case since scan and unjoin are protected by
    conf_mutex. So, currently, the handling of delayed_unjoin is just dead
    code.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20191217161318.31402-53-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/scan.c b/drivers/staging/wfx/scan.c
index 540009b72240..bdbce6926e91 100644
--- a/drivers/staging/wfx/scan.c
+++ b/drivers/staging/wfx/scan.c
@@ -95,12 +95,7 @@ void wfx_hw_scan_work(struct work_struct *work)
 	mutex_unlock(&wvif->wdev->conf_mutex);
 	mutex_unlock(&wvif->scan_lock);
 	__ieee80211_scan_completed_compat(wvif->wdev->hw, ret < 0);
-	if (wvif->delayed_unjoin) {
-		wvif->delayed_unjoin = false;
-		wfx_tx_lock(wvif->wdev);
-		if (!schedule_work(&wvif->unjoin_work))
-			wfx_tx_unlock(wvif->wdev);
-	} else if (wvif->delayed_link_loss) {
+	if (wvif->delayed_link_loss) {
 		wvif->delayed_link_loss = false;
 		wfx_cqm_bssloss_sm(wvif, 1, 0, 0);
 	}

commit 3827e33d371ed2f4024fd42a4409e1b7af8e0938
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Tue Dec 17 16:15:37 2019 +0000

    staging: wfx: workaround bug with "iw scan"
    
    mac80211 specification does not forbid hw_scan() to call
    ieee80211_scan_completed(). However, from userspace point of view, not
    all applications support this behavior. In particular, the code of iw
    contains a big fat warning:
    
       /*
        * This code has a bug, which requires creating a separate
        * nl80211 socket to fix:
        * It is possible for a NL80211_CMD_NEW_SCAN_RESULTS or
        * NL80211_CMD_SCAN_ABORTED message to be sent by the kernel
        * before (!) we listen to it, because we only start listening
        * after we send our scan request.
        [...]
        * Alas, the kernel doesn't do that (yet).
        */
    
    So, we have to avoid to call ieee80211_scan_completed() from hw_scan()
    (it's a kind of unwritten rule).
    
    This patch relocates the hw_scan() process to a work_struct to fix the
    problem.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20191217161318.31402-52-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/scan.c b/drivers/staging/wfx/scan.c
index b73e61e8da46..540009b72240 100644
--- a/drivers/staging/wfx/scan.c
+++ b/drivers/staging/wfx/scan.c
@@ -71,23 +71,19 @@ static int send_scan_req(struct wfx_vif *wvif,
 	return i - start_idx;
 }
 
-int wfx_hw_scan(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
-		struct ieee80211_scan_request *hw_req)
+/*
+ * It is not really necessary to run scan request asynchronously. However,
+ * there is a bug in "iw scan" when ieee80211_scan_completed() is called before
+ * wfx_hw_scan() return
+ */
+void wfx_hw_scan_work(struct work_struct *work)
 {
-	struct wfx_dev *wdev = hw->priv;
-	struct wfx_vif *wvif = (struct wfx_vif *) vif->drv_priv;
+	struct wfx_vif *wvif = container_of(work, struct wfx_vif, scan_work);
+	struct ieee80211_scan_request *hw_req = wvif->scan_req;
 	int chan_cur, ret;
 
-	WARN_ON(hw_req->req.n_channels > HIF_API_MAX_NB_CHANNELS);
-
-	if (vif->type == NL80211_IFTYPE_AP)
-		return -EOPNOTSUPP;
-
-	if (wvif->state == WFX_STATE_PRE_STA)
-		return -EBUSY;
-
 	mutex_lock(&wvif->scan_lock);
-	mutex_lock(&wdev->conf_mutex);
+	mutex_lock(&wvif->wdev->conf_mutex);
 	update_probe_tmpl(wvif, &hw_req->req);
 	wfx_fwd_probe_req(wvif, true);
 	chan_cur = 0;
@@ -96,18 +92,35 @@ int wfx_hw_scan(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 		if (ret > 0)
 			chan_cur += ret;
 	} while (ret > 0 && chan_cur < hw_req->req.n_channels);
-	__ieee80211_scan_completed_compat(hw, ret < 0);
-	mutex_unlock(&wdev->conf_mutex);
+	mutex_unlock(&wvif->wdev->conf_mutex);
 	mutex_unlock(&wvif->scan_lock);
+	__ieee80211_scan_completed_compat(wvif->wdev->hw, ret < 0);
 	if (wvif->delayed_unjoin) {
 		wvif->delayed_unjoin = false;
-		wfx_tx_lock(wdev);
+		wfx_tx_lock(wvif->wdev);
 		if (!schedule_work(&wvif->unjoin_work))
-			wfx_tx_unlock(wdev);
+			wfx_tx_unlock(wvif->wdev);
 	} else if (wvif->delayed_link_loss) {
 		wvif->delayed_link_loss = false;
 		wfx_cqm_bssloss_sm(wvif, 1, 0, 0);
 	}
+}
+
+int wfx_hw_scan(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
+		struct ieee80211_scan_request *hw_req)
+{
+	struct wfx_vif *wvif = (struct wfx_vif *)vif->drv_priv;
+
+	WARN_ON(hw_req->req.n_channels > HIF_API_MAX_NB_CHANNELS);
+
+	if (vif->type == NL80211_IFTYPE_AP)
+		return -EOPNOTSUPP;
+
+	if (wvif->state == WFX_STATE_PRE_STA)
+		return -EBUSY;
+
+	wvif->scan_req = hw_req;
+	schedule_work(&wvif->scan_work);
 	return 0;
 }
 

commit d1c015b4ef6f2ab74b19c216cfff07742b7665cf
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Tue Dec 17 16:15:35 2019 +0000

    staging: wfx: rewrite wfx_hw_scan()
    
    Scan requests from mac80211 must be splitted in a few hardware requests
    (it is necessary to split channels with active scan and channels with
    passive scan). Current code schedules a work_struct for each hardware
    request and one delayed_work to handle scan timeout.
    
    It is far simpler to run send all the hardware requests synchronously
    and replace delayed_work with a simple wait_for_completion_timeout().
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20191217161318.31402-51-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/scan.c b/drivers/staging/wfx/scan.c
index c82c04ff5d06..b73e61e8da46 100644
--- a/drivers/staging/wfx/scan.c
+++ b/drivers/staging/wfx/scan.c
@@ -22,33 +22,6 @@ static void __ieee80211_scan_completed_compat(struct ieee80211_hw *hw,
 	ieee80211_scan_completed(hw, &info);
 }
 
-static void wfx_scan_restart_delayed(struct wfx_vif *wvif)
-{
-	if (wvif->delayed_unjoin) {
-		wvif->delayed_unjoin = false;
-		if (!schedule_work(&wvif->unjoin_work))
-			wfx_tx_unlock(wvif->wdev);
-	} else if (wvif->delayed_link_loss) {
-		wvif->delayed_link_loss = 0;
-		wfx_cqm_bssloss_sm(wvif, 1, 0, 0);
-	}
-}
-
-static int wfx_scan_start(struct wfx_vif *wvif,
-			  int chan_start_idx, int chan_num)
-{
-	int tmo;
-
-	if (wvif->state == WFX_STATE_PRE_STA)
-		return -EBUSY;
-
-	atomic_set(&wvif->scan.in_progress, 1);
-
-	tmo = hif_scan(wvif, wvif->scan.req, chan_start_idx, chan_num);
-	schedule_delayed_work(&wvif->scan.timeout, tmo);
-	return 0;
-}
-
 static int update_probe_tmpl(struct wfx_vif *wvif,
 			     struct cfg80211_scan_request *req)
 {
@@ -65,153 +38,81 @@ static int update_probe_tmpl(struct wfx_vif *wvif,
 	return 0;
 }
 
-int wfx_hw_scan(struct ieee80211_hw *hw,
-		   struct ieee80211_vif *vif,
-		   struct ieee80211_scan_request *hw_req)
+static int send_scan_req(struct wfx_vif *wvif,
+			 struct cfg80211_scan_request *req, int start_idx)
+{
+	int i, ret, timeout;
+	struct ieee80211_channel *ch_start, *ch_cur;
+
+	for (i = start_idx; i < req->n_channels; i++) {
+		ch_start = req->channels[start_idx];
+		ch_cur = req->channels[i];
+		WARN(ch_cur->band != NL80211_BAND_2GHZ, "band not supported");
+		if (ch_cur->max_power != ch_start->max_power)
+			break;
+		if ((ch_cur->flags ^ ch_start->flags) & IEEE80211_CHAN_NO_IR)
+			break;
+	}
+	wfx_tx_lock_flush(wvif->wdev);
+	reinit_completion(&wvif->scan_complete);
+	ret = hif_scan(wvif, req, start_idx, i - start_idx);
+	if (ret < 0)
+		return ret;
+	timeout = ret;
+	ret = wait_for_completion_timeout(&wvif->scan_complete, timeout);
+	if (req->channels[start_idx]->max_power != wvif->wdev->output_power)
+		hif_set_output_power(wvif, wvif->wdev->output_power * 10);
+	wfx_tx_unlock(wvif->wdev);
+	if (!ret) {
+		dev_notice(wvif->wdev->dev, "scan timeout\n");
+		hif_stop_scan(wvif);
+		return -ETIMEDOUT;
+	}
+	return i - start_idx;
+}
+
+int wfx_hw_scan(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
+		struct ieee80211_scan_request *hw_req)
 {
 	struct wfx_dev *wdev = hw->priv;
 	struct wfx_vif *wvif = (struct wfx_vif *) vif->drv_priv;
-	struct cfg80211_scan_request *req = &hw_req->req;
-	int i, ret;
+	int chan_cur, ret;
 
-	if (!wvif)
-		return -EINVAL;
+	WARN_ON(hw_req->req.n_channels > HIF_API_MAX_NB_CHANNELS);
 
-	if (wvif->state == WFX_STATE_AP)
+	if (vif->type == NL80211_IFTYPE_AP)
 		return -EOPNOTSUPP;
 
-	if (req->n_ssids == 1 && !req->ssids[0].ssid_len)
-		req->n_ssids = 0;
-
-	if (req->n_ssids > HIF_API_MAX_NB_SSIDS)
-		return -EINVAL;
+	if (wvif->state == WFX_STATE_PRE_STA)
+		return -EBUSY;
 
+	mutex_lock(&wvif->scan_lock);
 	mutex_lock(&wdev->conf_mutex);
-
-	ret = update_probe_tmpl(wvif, req);
-	if (ret)
-		goto failed;
-
-	ret = wfx_fwd_probe_req(wvif, true);
-	if (ret)
-		goto failed;
-
-	wfx_tx_lock_flush(wdev);
-
-	WARN(wvif->scan.req, "unexpected concurrent scan");
-	wvif->scan.req = req;
-	wvif->scan.n_ssids = 0;
-	wvif->scan.status = 0;
-	wvif->scan.begin = &req->channels[0];
-	wvif->scan.curr = wvif->scan.begin;
-	wvif->scan.end = &req->channels[req->n_channels];
-	wvif->scan.output_power = wdev->output_power;
-
-	for (i = 0; i < req->n_ssids; ++i) {
-		struct hif_ssid_def *dst = &wvif->scan.ssids[wvif->scan.n_ssids];
-
-		memcpy(&dst->ssid[0], req->ssids[i].ssid, sizeof(dst->ssid));
-		dst->ssid_length = req->ssids[i].ssid_len;
-		++wvif->scan.n_ssids;
-	}
-	schedule_work(&wvif->scan.work);
-
-failed:
+	update_probe_tmpl(wvif, &hw_req->req);
+	wfx_fwd_probe_req(wvif, true);
+	chan_cur = 0;
+	do {
+		ret = send_scan_req(wvif, &hw_req->req, chan_cur);
+		if (ret > 0)
+			chan_cur += ret;
+	} while (ret > 0 && chan_cur < hw_req->req.n_channels);
+	__ieee80211_scan_completed_compat(hw, ret < 0);
 	mutex_unlock(&wdev->conf_mutex);
-	return ret;
-}
-
-void wfx_scan_work(struct work_struct *work)
-{
-	struct wfx_vif *wvif = container_of(work, struct wfx_vif, scan.work);
-	struct ieee80211_channel **it;
-	struct ieee80211_channel *first;
-	int i;
-
-	down(&wvif->scan.lock);
-	mutex_lock(&wvif->wdev->conf_mutex);
-
-
-	if (!wvif->scan.req || wvif->scan.curr == wvif->scan.end) {
-		if (wvif->scan.output_power != wvif->wdev->output_power)
-			hif_set_output_power(wvif,
-					     wvif->wdev->output_power * 10);
-
-		if (wvif->scan.status < 0)
-			dev_warn(wvif->wdev->dev, "scan failed\n");
-		else if (wvif->scan.req)
-			dev_dbg(wvif->wdev->dev, "scan completed\n");
-		else
-			dev_dbg(wvif->wdev->dev, "scan canceled\n");
-
-		wvif->scan.req = NULL;
-		wfx_scan_restart_delayed(wvif);
-		wfx_tx_unlock(wvif->wdev);
-		mutex_unlock(&wvif->wdev->conf_mutex);
-		__ieee80211_scan_completed_compat(wvif->wdev->hw,
-						  wvif->scan.status ? 1 : 0);
-		up(&wvif->scan.lock);
-		return;
-	}
-	first = *wvif->scan.curr;
-
-	for (it = wvif->scan.curr + 1, i = 1;
-	     it != wvif->scan.end && i < HIF_API_MAX_NB_CHANNELS;
-	     ++it, ++i) {
-		if ((*it)->band != first->band)
-			break;
-		if (((*it)->flags ^ first->flags) &
-				IEEE80211_CHAN_NO_IR)
-			break;
-		if (!(first->flags & IEEE80211_CHAN_NO_IR) &&
-		    (*it)->max_power != first->max_power)
-			break;
-	}
-	if (!(first->flags & IEEE80211_CHAN_NO_IR) &&
-	    wvif->scan.output_power != first->max_power) {
-		wvif->scan.output_power = first->max_power;
-		hif_set_output_power(wvif, wvif->scan.output_power * 10);
-	}
-	wvif->scan.status = wfx_scan_start(wvif,
-					   wvif->scan.curr - wvif->scan.begin,
-					   it - wvif->scan.curr);
-	if (wvif->scan.status)
-		goto fail;
-	wvif->scan.curr = it;
-	mutex_unlock(&wvif->wdev->conf_mutex);
-	return;
-
-fail:
-	wvif->scan.curr = wvif->scan.end;
-	mutex_unlock(&wvif->wdev->conf_mutex);
-	up(&wvif->scan.lock);
-	schedule_work(&wvif->scan.work);
-}
-
-void wfx_scan_complete_cb(struct wfx_vif *wvif,
-			  const struct hif_ind_scan_cmpl *arg)
-{
-	if (cancel_delayed_work_sync(&wvif->scan.timeout) > 0) {
-		wvif->scan.status = 1;
-		schedule_work(&wvif->scan.timeout.work);
+	mutex_unlock(&wvif->scan_lock);
+	if (wvif->delayed_unjoin) {
+		wvif->delayed_unjoin = false;
+		wfx_tx_lock(wdev);
+		if (!schedule_work(&wvif->unjoin_work))
+			wfx_tx_unlock(wdev);
+	} else if (wvif->delayed_link_loss) {
+		wvif->delayed_link_loss = false;
+		wfx_cqm_bssloss_sm(wvif, 1, 0, 0);
 	}
+	return 0;
 }
 
-void wfx_scan_timeout(struct work_struct *work)
+void wfx_scan_complete(struct wfx_vif *wvif,
+		       const struct hif_ind_scan_cmpl *arg)
 {
-	struct wfx_vif *wvif = container_of(work, struct wfx_vif,
-					    scan.timeout.work);
-
-	if (atomic_xchg(&wvif->scan.in_progress, 0)) {
-		if (wvif->scan.status > 0) {
-			wvif->scan.status = 0;
-		} else if (!wvif->scan.status) {
-			dev_warn(wvif->wdev->dev, "timeout waiting for scan complete notification\n");
-			wvif->scan.status = -ETIMEDOUT;
-			wvif->scan.curr = wvif->scan.end;
-			hif_stop_scan(wvif);
-		}
-		up(&wvif->scan.lock);
-		wfx_scan_work(&wvif->scan.work);
-	}
+	complete(&wvif->scan_complete);
 }

commit 094ecec9be6096960cb4ae6a6256759bbba7aa0a
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Tue Dec 17 16:15:34 2019 +0000

    staging: wfx: simplify hif_set_template_frame() usage
    
    The structure hif_mib_template_frame come from hardware API. It is not
    intended to be manipulated in upper layers of the driver.
    
    In add, the current code for hif_set_template_frame() is dumb. All the
    difficult task is left to the caller. So, there is code to factorize
    here.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20191217161318.31402-50-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/scan.c b/drivers/staging/wfx/scan.c
index 8b184efad0cf..c82c04ff5d06 100644
--- a/drivers/staging/wfx/scan.c
+++ b/drivers/staging/wfx/scan.c
@@ -52,7 +52,6 @@ static int wfx_scan_start(struct wfx_vif *wvif,
 static int update_probe_tmpl(struct wfx_vif *wvif,
 			     struct cfg80211_scan_request *req)
 {
-	struct hif_mib_template_frame *tmpl;
 	struct sk_buff *skb;
 
 	skb = ieee80211_probereq_get(wvif->wdev->hw, wvif->vif->addr,
@@ -61,11 +60,7 @@ static int update_probe_tmpl(struct wfx_vif *wvif,
 		return -ENOMEM;
 
 	skb_put_data(skb, req->ie, req->ie_len);
-	skb_push(skb, 4);
-	tmpl = (struct hif_mib_template_frame *)skb->data;
-	tmpl->frame_type = HIF_TMPLT_PRBREQ;
-	tmpl->frame_length = cpu_to_le16(skb->len - 4);
-	hif_set_template_frame(wvif, tmpl);
+	hif_set_template_frame(wvif, skb, HIF_TMPLT_PRBREQ, 0);
 	dev_kfree_skb(skb);
 	return 0;
 }

commit 397f36c1c786b70fa24a27fde7c425fcf34313fa
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Tue Dec 17 16:15:33 2019 +0000

    staging: wfx: introduce update_probe_tmpl()
    
    Simplify wfx_hw_scan() by splitting out the update of the probe request.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20191217161318.31402-49-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/scan.c b/drivers/staging/wfx/scan.c
index 122da87bbf92..8b184efad0cf 100644
--- a/drivers/staging/wfx/scan.c
+++ b/drivers/staging/wfx/scan.c
@@ -49,6 +49,27 @@ static int wfx_scan_start(struct wfx_vif *wvif,
 	return 0;
 }
 
+static int update_probe_tmpl(struct wfx_vif *wvif,
+			     struct cfg80211_scan_request *req)
+{
+	struct hif_mib_template_frame *tmpl;
+	struct sk_buff *skb;
+
+	skb = ieee80211_probereq_get(wvif->wdev->hw, wvif->vif->addr,
+				     NULL, 0, req->ie_len);
+	if (!skb)
+		return -ENOMEM;
+
+	skb_put_data(skb, req->ie, req->ie_len);
+	skb_push(skb, 4);
+	tmpl = (struct hif_mib_template_frame *)skb->data;
+	tmpl->frame_type = HIF_TMPLT_PRBREQ;
+	tmpl->frame_length = cpu_to_le16(skb->len - 4);
+	hif_set_template_frame(wvif, tmpl);
+	dev_kfree_skb(skb);
+	return 0;
+}
+
 int wfx_hw_scan(struct ieee80211_hw *hw,
 		   struct ieee80211_vif *vif,
 		   struct ieee80211_scan_request *hw_req)
@@ -56,9 +77,7 @@ int wfx_hw_scan(struct ieee80211_hw *hw,
 	struct wfx_dev *wdev = hw->priv;
 	struct wfx_vif *wvif = (struct wfx_vif *) vif->drv_priv;
 	struct cfg80211_scan_request *req = &hw_req->req;
-	struct sk_buff *skb;
 	int i, ret;
-	struct hif_mib_template_frame *p;
 
 	if (!wvif)
 		return -EINVAL;
@@ -72,29 +91,15 @@ int wfx_hw_scan(struct ieee80211_hw *hw,
 	if (req->n_ssids > HIF_API_MAX_NB_SSIDS)
 		return -EINVAL;
 
-	skb = ieee80211_probereq_get(hw, wvif->vif->addr, NULL, 0, req->ie_len);
-	if (!skb)
-		return -ENOMEM;
-
-	if (req->ie_len)
-		memcpy(skb_put(skb, req->ie_len), req->ie, req->ie_len);
-
 	mutex_lock(&wdev->conf_mutex);
 
-	p = (struct hif_mib_template_frame *)skb_push(skb, 4);
-	p->frame_type = HIF_TMPLT_PRBREQ;
-	p->frame_length = cpu_to_le16(skb->len - 4);
-	ret = hif_set_template_frame(wvif, p);
-	skb_pull(skb, 4);
-
-	if (!ret)
-		/* Host want to be the probe responder. */
-		ret = wfx_fwd_probe_req(wvif, true);
-	if (ret) {
-		mutex_unlock(&wdev->conf_mutex);
-		dev_kfree_skb(skb);
-		return ret;
-	}
+	ret = update_probe_tmpl(wvif, req);
+	if (ret)
+		goto failed;
+
+	ret = wfx_fwd_probe_req(wvif, true);
+	if (ret)
+		goto failed;
 
 	wfx_tx_lock_flush(wdev);
 
@@ -114,13 +119,11 @@ int wfx_hw_scan(struct ieee80211_hw *hw,
 		dst->ssid_length = req->ssids[i].ssid_len;
 		++wvif->scan.n_ssids;
 	}
+	schedule_work(&wvif->scan.work);
 
+failed:
 	mutex_unlock(&wdev->conf_mutex);
-
-	if (skb)
-		dev_kfree_skb(skb);
-	schedule_work(&wvif->scan.work);
-	return 0;
+	return ret;
 }
 
 void wfx_scan_work(struct work_struct *work)

commit 945ce30aa52beec7eb01f3bcaf564ef60c46554a
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Tue Dec 17 16:15:32 2019 +0000

    staging: wfx: simplify hif_scan() usage
    
    The structures hif_req_start_scan and hif_ssid_def come from hardware
    API. It is not intended to be manipulated in upper layers of the driver.
    
    So, this patch relocate handling of theses structures to hif_scan()
    (the low level function). This change also allows to drop struct
    wfx_scan_params.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20191217161318.31402-48-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/scan.c b/drivers/staging/wfx/scan.c
index c043f2f79541..122da87bbf92 100644
--- a/drivers/staging/wfx/scan.c
+++ b/drivers/staging/wfx/scan.c
@@ -34,19 +34,18 @@ static void wfx_scan_restart_delayed(struct wfx_vif *wvif)
 	}
 }
 
-static int wfx_scan_start(struct wfx_vif *wvif, struct wfx_scan_params *scan)
+static int wfx_scan_start(struct wfx_vif *wvif,
+			  int chan_start_idx, int chan_num)
 {
-	int tmo = 500;
+	int tmo;
 
 	if (wvif->state == WFX_STATE_PRE_STA)
 		return -EBUSY;
 
-	tmo += scan->scan_req.num_of_channels *
-	       ((20 * (scan->scan_req.max_channel_time)) + 10);
 	atomic_set(&wvif->scan.in_progress, 1);
 
-	schedule_delayed_work(&wvif->scan.timeout, msecs_to_jiffies(tmo));
-	hif_scan(wvif, scan);
+	tmo = hif_scan(wvif, wvif->scan.req, chan_start_idx, chan_num);
+	schedule_delayed_work(&wvif->scan.timeout, tmo);
 	return 0;
 }
 
@@ -128,9 +127,6 @@ void wfx_scan_work(struct work_struct *work)
 {
 	struct wfx_vif *wvif = container_of(work, struct wfx_vif, scan.work);
 	struct ieee80211_channel **it;
-	struct wfx_scan_params scan = {
-		.scan_req.scan_type.type = 0,    /* Foreground */
-	};
 	struct ieee80211_channel *first;
 	int i;
 
@@ -173,48 +169,14 @@ void wfx_scan_work(struct work_struct *work)
 		    (*it)->max_power != first->max_power)
 			break;
 	}
-	scan.scan_req.band = first->band;
-
-	if (wvif->scan.req->no_cck)
-		scan.scan_req.max_transmit_rate = API_RATE_INDEX_G_6MBPS;
-	else
-		scan.scan_req.max_transmit_rate = API_RATE_INDEX_B_1MBPS;
-	scan.scan_req.num_of_probe_requests =
-		(first->flags & IEEE80211_CHAN_NO_IR) ? 0 : 2;
-	scan.scan_req.num_of_ssids = wvif->scan.n_ssids;
-	scan.ssids = &wvif->scan.ssids[0];
-	scan.scan_req.num_of_channels = it - wvif->scan.curr;
-	scan.scan_req.probe_delay = 100;
-	// FIXME: Check if FW can do active scan while joined.
-	if (wvif->state == WFX_STATE_STA) {
-		scan.scan_req.scan_type.type = 1;
-		scan.scan_req.scan_flags.fbg = 1;
-	}
-
-	scan.ch = kcalloc(scan.scan_req.num_of_channels,
-			  sizeof(u8), GFP_KERNEL);
-
-	if (!scan.ch) {
-		wvif->scan.status = -ENOMEM;
-		goto fail;
-	}
-	for (i = 0; i < scan.scan_req.num_of_channels; ++i)
-		scan.ch[i] = wvif->scan.curr[i]->hw_value;
-
-	if (wvif->scan.curr[0]->flags & IEEE80211_CHAN_NO_IR) {
-		scan.scan_req.min_channel_time = 50;
-		scan.scan_req.max_channel_time = 150;
-	} else {
-		scan.scan_req.min_channel_time = 10;
-		scan.scan_req.max_channel_time = 50;
-	}
 	if (!(first->flags & IEEE80211_CHAN_NO_IR) &&
 	    wvif->scan.output_power != first->max_power) {
 		wvif->scan.output_power = first->max_power;
 		hif_set_output_power(wvif, wvif->scan.output_power * 10);
 	}
-	wvif->scan.status = wfx_scan_start(wvif, &scan);
-	kfree(scan.ch);
+	wvif->scan.status = wfx_scan_start(wvif,
+					   wvif->scan.curr - wvif->scan.begin,
+					   it - wvif->scan.curr);
 	if (wvif->scan.status)
 		goto fail;
 	wvif->scan.curr = it;

commit 1a53df55346e1381406a6f4d161aa5acfa99a01c
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Tue Dec 17 16:15:30 2019 +0000

    staging: wfx: drop useless wfx_scan_complete()
    
    Since wfx_scan_complete() is now only called from
    wfx_scan_complete_cb(), it make sense to merge the both functions.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20191217161318.31402-47-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/scan.c b/drivers/staging/wfx/scan.c
index 397fe511d34a..c043f2f79541 100644
--- a/drivers/staging/wfx/scan.c
+++ b/drivers/staging/wfx/scan.c
@@ -228,12 +228,6 @@ void wfx_scan_work(struct work_struct *work)
 	schedule_work(&wvif->scan.work);
 }
 
-static void wfx_scan_complete(struct wfx_vif *wvif)
-{
-	up(&wvif->scan.lock);
-	wfx_scan_work(&wvif->scan.work);
-}
-
 void wfx_scan_complete_cb(struct wfx_vif *wvif,
 			  const struct hif_ind_scan_cmpl *arg)
 {
@@ -257,6 +251,7 @@ void wfx_scan_timeout(struct work_struct *work)
 			wvif->scan.curr = wvif->scan.end;
 			hif_stop_scan(wvif);
 		}
-		wfx_scan_complete(wvif);
+		up(&wvif->scan.lock);
+		wfx_scan_work(&wvif->scan.work);
 	}
 }

commit 7ceb4753ef58185b5a90ccbd3a55373b01a38219
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Tue Dec 17 16:15:29 2019 +0000

    staging: wfx: device already handle sleep mode during scan
    
    The device is not allowed to enter in sleep mode during scan. However,
    this is already handled by the device. So driver does not have to care
    about it.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20191217161318.31402-46-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/scan.c b/drivers/staging/wfx/scan.c
index cdccb67cb30e..397fe511d34a 100644
--- a/drivers/staging/wfx/scan.c
+++ b/drivers/staging/wfx/scan.c
@@ -44,7 +44,6 @@ static int wfx_scan_start(struct wfx_vif *wvif, struct wfx_scan_params *scan)
 	tmo += scan->scan_req.num_of_channels *
 	       ((20 * (scan->scan_req.max_channel_time)) + 10);
 	atomic_set(&wvif->scan.in_progress, 1);
-	atomic_set(&wvif->wdev->scan_in_progress, 1);
 
 	schedule_delayed_work(&wvif->scan.timeout, msecs_to_jiffies(tmo));
 	hif_scan(wvif, scan);
@@ -232,8 +231,6 @@ void wfx_scan_work(struct work_struct *work)
 static void wfx_scan_complete(struct wfx_vif *wvif)
 {
 	up(&wvif->scan.lock);
-	atomic_set(&wvif->wdev->scan_in_progress, 0);
-
 	wfx_scan_work(&wvif->scan.work);
 }
 

commit 154cca646720017837c811052ac2e106fbbdc8a7
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Tue Dec 17 16:15:28 2019 +0000

    staging: wfx: hif_scan() never fails
    
    If scan fails, status is returned in hif_ind_scan_cmpl. hif_scan
    always return a success. So, we can simplify the code.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20191217161318.31402-45-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/scan.c b/drivers/staging/wfx/scan.c
index 4b95e6a97df7..cdccb67cb30e 100644
--- a/drivers/staging/wfx/scan.c
+++ b/drivers/staging/wfx/scan.c
@@ -36,7 +36,6 @@ static void wfx_scan_restart_delayed(struct wfx_vif *wvif)
 
 static int wfx_scan_start(struct wfx_vif *wvif, struct wfx_scan_params *scan)
 {
-	int ret;
 	int tmo = 500;
 
 	if (wvif->state == WFX_STATE_PRE_STA)
@@ -48,15 +47,8 @@ static int wfx_scan_start(struct wfx_vif *wvif, struct wfx_scan_params *scan)
 	atomic_set(&wvif->wdev->scan_in_progress, 1);
 
 	schedule_delayed_work(&wvif->scan.timeout, msecs_to_jiffies(tmo));
-	ret = hif_scan(wvif, scan);
-	if (ret) {
-		wfx_scan_failed_cb(wvif);
-		atomic_set(&wvif->scan.in_progress, 0);
-		atomic_set(&wvif->wdev->scan_in_progress, 0);
-		cancel_delayed_work_sync(&wvif->scan.timeout);
-		wfx_scan_restart_delayed(wvif);
-	}
-	return ret;
+	hif_scan(wvif, scan);
+	return 0;
 }
 
 int wfx_hw_scan(struct ieee80211_hw *hw,
@@ -245,14 +237,6 @@ static void wfx_scan_complete(struct wfx_vif *wvif)
 	wfx_scan_work(&wvif->scan.work);
 }
 
-void wfx_scan_failed_cb(struct wfx_vif *wvif)
-{
-	if (cancel_delayed_work_sync(&wvif->scan.timeout) > 0) {
-		wvif->scan.status = -EIO;
-		schedule_work(&wvif->scan.timeout.work);
-	}
-}
-
 void wfx_scan_complete_cb(struct wfx_vif *wvif,
 			  const struct hif_ind_scan_cmpl *arg)
 {

commit 155665d87e08814d6e47277be2e706534497c638
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Tue Dec 17 16:15:09 2019 +0000

    staging: wfx: firmware already handle powersave mode during scan
    
    When user try to launch scan while connected, it is necessary to notify
    the AP that we cannot receive data (using power save mode).
    
    Firmware already handles this automatically so the code in the driver is
    redundant and can be dropped.
    
    By edge effect, hack of scan status in wfx_set_pm() is now useless.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20191217161318.31402-31-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/scan.c b/drivers/staging/wfx/scan.c
index cb7a1fdd0001..4b95e6a97df7 100644
--- a/drivers/staging/wfx/scan.c
+++ b/drivers/staging/wfx/scan.c
@@ -141,22 +141,11 @@ void wfx_scan_work(struct work_struct *work)
 		.scan_req.scan_type.type = 0,    /* Foreground */
 	};
 	struct ieee80211_channel *first;
-	bool first_run = (wvif->scan.begin == wvif->scan.curr &&
-			  wvif->scan.begin != wvif->scan.end);
 	int i;
 
 	down(&wvif->scan.lock);
 	mutex_lock(&wvif->wdev->conf_mutex);
 
-	if (first_run) {
-		if (wvif->state == WFX_STATE_STA &&
-		    !(wvif->powersave_mode.pm_mode.enter_psm)) {
-			struct hif_req_set_pm_mode pm = wvif->powersave_mode;
-
-			pm.pm_mode.enter_psm = 1;
-			wfx_set_pm(wvif, &pm);
-		}
-	}
 
 	if (!wvif->scan.req || wvif->scan.curr == wvif->scan.end) {
 		if (wvif->scan.output_power != wvif->wdev->output_power)
@@ -177,9 +166,6 @@ void wfx_scan_work(struct work_struct *work)
 		__ieee80211_scan_completed_compat(wvif->wdev->hw,
 						  wvif->scan.status ? 1 : 0);
 		up(&wvif->scan.lock);
-		if (wvif->state == WFX_STATE_STA &&
-		    !(wvif->powersave_mode.pm_mode.enter_psm))
-			wfx_set_pm(wvif, &wvif->powersave_mode);
 		return;
 	}
 	first = *wvif->scan.curr;

commit aedeb963c956ef2298aa2dee62ca2049e307e7b5
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Tue Dec 17 16:15:00 2019 +0000

    staging: wfx: fix typo in "num_of_ssi_ds"
    
    The script that has imported API headers has made a mistake in
    "num_of_ssi_ds".
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20191217161318.31402-24-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/scan.c b/drivers/staging/wfx/scan.c
index 45e78c5722ff..cb7a1fdd0001 100644
--- a/drivers/staging/wfx/scan.c
+++ b/drivers/staging/wfx/scan.c
@@ -204,7 +204,7 @@ void wfx_scan_work(struct work_struct *work)
 		scan.scan_req.max_transmit_rate = API_RATE_INDEX_B_1MBPS;
 	scan.scan_req.num_of_probe_requests =
 		(first->flags & IEEE80211_CHAN_NO_IR) ? 0 : 2;
-	scan.scan_req.num_of_ssi_ds = wvif->scan.n_ssids;
+	scan.scan_req.num_of_ssids = wvif->scan.n_ssids;
 	scan.ssids = &wvif->scan.ssids[0];
 	scan.scan_req.num_of_channels = it - wvif->scan.curr;
 	scan.scan_req.probe_delay = 100;

commit 36f7e3acaac6be7da831b9a0c31022954f79216d
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Tue Dec 17 16:14:59 2019 +0000

    staging: wfx: ensure that received hif messages are never modified
    
    There are no real reason to modify the data received from device. So,
    let's mark the arguments constant.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20191217161318.31402-23-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/scan.c b/drivers/staging/wfx/scan.c
index a6c93400a7ba..45e78c5722ff 100644
--- a/drivers/staging/wfx/scan.c
+++ b/drivers/staging/wfx/scan.c
@@ -267,7 +267,8 @@ void wfx_scan_failed_cb(struct wfx_vif *wvif)
 	}
 }
 
-void wfx_scan_complete_cb(struct wfx_vif *wvif, struct hif_ind_scan_cmpl *arg)
+void wfx_scan_complete_cb(struct wfx_vif *wvif,
+			  const struct hif_ind_scan_cmpl *arg)
 {
 	if (cancel_delayed_work_sync(&wvif->scan.timeout) > 0) {
 		wvif->scan.status = 1;

commit faffec8883cc2138fccc7a0c60f26bf9845d6b41
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Tue Dec 17 16:14:55 2019 +0000

    staging: wfx: simplify variable assignment
    
    Attribute "aborted" and argument "aborted" are both booleans.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20191217161318.31402-20-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/scan.c b/drivers/staging/wfx/scan.c
index 35fcf9119f96..a6c93400a7ba 100644
--- a/drivers/staging/wfx/scan.c
+++ b/drivers/staging/wfx/scan.c
@@ -16,7 +16,7 @@ static void __ieee80211_scan_completed_compat(struct ieee80211_hw *hw,
 					      bool aborted)
 {
 	struct cfg80211_scan_info info = {
-		.aborted = aborted ? 1 : 0,
+		.aborted = aborted,
 	};
 
 	ieee80211_scan_completed(hw, &info);

commit 8c7128c4cf4e0e6eb67bd65b4dbe619c3d297bb6
Author: Jules Irenge <jbi.octave@gmail.com>
Date:   Wed Nov 13 11:00:52 2019 +0000

    staging: align to fix warnings of line over 80 characters
    
    Align to fix multiple warnings of line over 80 characters.
    Issue detected by checkpatch tool.
    
    Signed-off-by: Jules Irenge <jbi.octave@gmail.com>
    Link: https://lore.kernel.org/r/20191113110052.14855-1-jbi.octave@gmail.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/scan.c b/drivers/staging/wfx/scan.c
index cba735c1e73c..35fcf9119f96 100644
--- a/drivers/staging/wfx/scan.c
+++ b/drivers/staging/wfx/scan.c
@@ -12,7 +12,8 @@
 #include "sta.h"
 #include "hif_tx_mib.h"
 
-static void __ieee80211_scan_completed_compat(struct ieee80211_hw *hw, bool aborted)
+static void __ieee80211_scan_completed_compat(struct ieee80211_hw *hw,
+					      bool aborted)
 {
 	struct cfg80211_scan_info info = {
 		.aborted = aborted ? 1 : 0,
@@ -159,7 +160,8 @@ void wfx_scan_work(struct work_struct *work)
 
 	if (!wvif->scan.req || wvif->scan.curr == wvif->scan.end) {
 		if (wvif->scan.output_power != wvif->wdev->output_power)
-			hif_set_output_power(wvif, wvif->wdev->output_power * 10);
+			hif_set_output_power(wvif,
+					     wvif->wdev->output_power * 10);
 
 		if (wvif->scan.status < 0)
 			dev_warn(wvif->wdev->dev, "scan failed\n");
@@ -172,7 +174,8 @@ void wfx_scan_work(struct work_struct *work)
 		wfx_scan_restart_delayed(wvif);
 		wfx_tx_unlock(wvif->wdev);
 		mutex_unlock(&wvif->wdev->conf_mutex);
-		__ieee80211_scan_completed_compat(wvif->wdev->hw, wvif->scan.status ? 1 : 0);
+		__ieee80211_scan_completed_compat(wvif->wdev->hw,
+						  wvif->scan.status ? 1 : 0);
 		up(&wvif->scan.lock);
 		if (wvif->state == WFX_STATE_STA &&
 		    !(wvif->powersave_mode.pm_mode.enter_psm))
@@ -211,7 +214,8 @@ void wfx_scan_work(struct work_struct *work)
 		scan.scan_req.scan_flags.fbg = 1;
 	}
 
-	scan.ch = kcalloc(scan.scan_req.num_of_channels, sizeof(u8), GFP_KERNEL);
+	scan.ch = kcalloc(scan.scan_req.num_of_channels,
+			  sizeof(u8), GFP_KERNEL);
 
 	if (!scan.ch) {
 		wvif->scan.status = -ENOMEM;
@@ -273,7 +277,8 @@ void wfx_scan_complete_cb(struct wfx_vif *wvif, struct hif_ind_scan_cmpl *arg)
 
 void wfx_scan_timeout(struct work_struct *work)
 {
-	struct wfx_vif *wvif = container_of(work, struct wfx_vif, scan.timeout.work);
+	struct wfx_vif *wvif = container_of(work, struct wfx_vif,
+					    scan.timeout.work);
 
 	if (atomic_xchg(&wvif->scan.in_progress, 0)) {
 		if (wvif->scan.status > 0) {

commit b5be2aa3b3ac153f056f93406c520dc74a1cebbe
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Tue Oct 8 09:43:01 2019 +0000

    staging: wfx: drop calls to BUG_ON()
    
    Most of calls to BUG_ON() could replaced by WARN().
    
    By the way, this patch also try to favor WARN() (that include a comment
    about the problem) instead of WARN_ON().
    
    Reported-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20191008094232.10014-7-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/scan.c b/drivers/staging/wfx/scan.c
index ea5001c915f6..cba735c1e73c 100644
--- a/drivers/staging/wfx/scan.c
+++ b/drivers/staging/wfx/scan.c
@@ -107,7 +107,7 @@ int wfx_hw_scan(struct ieee80211_hw *hw,
 
 	wfx_tx_lock_flush(wdev);
 
-	BUG_ON(wvif->scan.req);
+	WARN(wvif->scan.req, "unexpected concurrent scan");
 	wvif->scan.req = req;
 	wvif->scan.n_ssids = 0;
 	wvif->scan.status = 0;

commit 40115bbc40e2fd2de0e01ef2a28e0d09a1b5d0d1
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Thu Sep 19 14:25:48 2019 +0000

    staging: wfx: implement the rest of mac80211 API
    
    Finish to fill struct ieee80211_ops with necessary callbacks. Driver is
    now ready to be registered to mac80211.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20190919142527.31797-21-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/scan.c b/drivers/staging/wfx/scan.c
index 207b26ebc9fd..ea5001c915f6 100644
--- a/drivers/staging/wfx/scan.c
+++ b/drivers/staging/wfx/scan.c
@@ -21,11 +21,26 @@ static void __ieee80211_scan_completed_compat(struct ieee80211_hw *hw, bool abor
 	ieee80211_scan_completed(hw, &info);
 }
 
+static void wfx_scan_restart_delayed(struct wfx_vif *wvif)
+{
+	if (wvif->delayed_unjoin) {
+		wvif->delayed_unjoin = false;
+		if (!schedule_work(&wvif->unjoin_work))
+			wfx_tx_unlock(wvif->wdev);
+	} else if (wvif->delayed_link_loss) {
+		wvif->delayed_link_loss = 0;
+		wfx_cqm_bssloss_sm(wvif, 1, 0, 0);
+	}
+}
+
 static int wfx_scan_start(struct wfx_vif *wvif, struct wfx_scan_params *scan)
 {
 	int ret;
 	int tmo = 500;
 
+	if (wvif->state == WFX_STATE_PRE_STA)
+		return -EBUSY;
+
 	tmo += scan->scan_req.num_of_channels *
 	       ((20 * (scan->scan_req.max_channel_time)) + 10);
 	atomic_set(&wvif->scan.in_progress, 1);
@@ -38,6 +53,7 @@ static int wfx_scan_start(struct wfx_vif *wvif, struct wfx_scan_params *scan)
 		atomic_set(&wvif->scan.in_progress, 0);
 		atomic_set(&wvif->wdev->scan_in_progress, 0);
 		cancel_delayed_work_sync(&wvif->scan.timeout);
+		wfx_scan_restart_delayed(wvif);
 	}
 	return ret;
 }
@@ -56,6 +72,9 @@ int wfx_hw_scan(struct ieee80211_hw *hw,
 	if (!wvif)
 		return -EINVAL;
 
+	if (wvif->state == WFX_STATE_AP)
+		return -EOPNOTSUPP;
+
 	if (req->n_ssids == 1 && !req->ssids[0].ssid_len)
 		req->n_ssids = 0;
 
@@ -121,11 +140,23 @@ void wfx_scan_work(struct work_struct *work)
 		.scan_req.scan_type.type = 0,    /* Foreground */
 	};
 	struct ieee80211_channel *first;
+	bool first_run = (wvif->scan.begin == wvif->scan.curr &&
+			  wvif->scan.begin != wvif->scan.end);
 	int i;
 
 	down(&wvif->scan.lock);
 	mutex_lock(&wvif->wdev->conf_mutex);
 
+	if (first_run) {
+		if (wvif->state == WFX_STATE_STA &&
+		    !(wvif->powersave_mode.pm_mode.enter_psm)) {
+			struct hif_req_set_pm_mode pm = wvif->powersave_mode;
+
+			pm.pm_mode.enter_psm = 1;
+			wfx_set_pm(wvif, &pm);
+		}
+	}
+
 	if (!wvif->scan.req || wvif->scan.curr == wvif->scan.end) {
 		if (wvif->scan.output_power != wvif->wdev->output_power)
 			hif_set_output_power(wvif, wvif->wdev->output_power * 10);
@@ -138,10 +169,14 @@ void wfx_scan_work(struct work_struct *work)
 			dev_dbg(wvif->wdev->dev, "scan canceled\n");
 
 		wvif->scan.req = NULL;
+		wfx_scan_restart_delayed(wvif);
 		wfx_tx_unlock(wvif->wdev);
 		mutex_unlock(&wvif->wdev->conf_mutex);
 		__ieee80211_scan_completed_compat(wvif->wdev->hw, wvif->scan.status ? 1 : 0);
 		up(&wvif->scan.lock);
+		if (wvif->state == WFX_STATE_STA &&
+		    !(wvif->powersave_mode.pm_mode.enter_psm))
+			wfx_set_pm(wvif, &wvif->powersave_mode);
 		return;
 	}
 	first = *wvif->scan.curr;
@@ -170,6 +205,11 @@ void wfx_scan_work(struct work_struct *work)
 	scan.ssids = &wvif->scan.ssids[0];
 	scan.scan_req.num_of_channels = it - wvif->scan.curr;
 	scan.scan_req.probe_delay = 100;
+	// FIXME: Check if FW can do active scan while joined.
+	if (wvif->state == WFX_STATE_STA) {
+		scan.scan_req.scan_type.type = 1;
+		scan.scan_req.scan_flags.fbg = 1;
+	}
 
 	scan.ch = kcalloc(scan.scan_req.num_of_channels, sizeof(u8), GFP_KERNEL);
 

commit 1a61af0f8cbecd1610c6fc380d0fb00f57fd43f2
Author: Jérôme Pouiller <jerome.pouiller@silabs.com>
Date:   Thu Sep 19 14:25:47 2019 +0000

    staging: wfx: allow to scan networks
    
    Chip can make foreground scan or background, but both can't be mixed in
    same request. So, we need to split each mac80211 requests into multiple
    HIF requests.
    
    Signed-off-by: Jérôme Pouiller <jerome.pouiller@silabs.com>
    Link: https://lore.kernel.org/r/20190919142527.31797-19-Jerome.Pouiller@silabs.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/wfx/scan.c b/drivers/staging/wfx/scan.c
new file mode 100644
index 000000000000..207b26ebc9fd
--- /dev/null
+++ b/drivers/staging/wfx/scan.c
@@ -0,0 +1,249 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Scan related functions.
+ *
+ * Copyright (c) 2017-2019, Silicon Laboratories, Inc.
+ * Copyright (c) 2010, ST-Ericsson
+ */
+#include <net/mac80211.h>
+
+#include "scan.h"
+#include "wfx.h"
+#include "sta.h"
+#include "hif_tx_mib.h"
+
+static void __ieee80211_scan_completed_compat(struct ieee80211_hw *hw, bool aborted)
+{
+	struct cfg80211_scan_info info = {
+		.aborted = aborted ? 1 : 0,
+	};
+
+	ieee80211_scan_completed(hw, &info);
+}
+
+static int wfx_scan_start(struct wfx_vif *wvif, struct wfx_scan_params *scan)
+{
+	int ret;
+	int tmo = 500;
+
+	tmo += scan->scan_req.num_of_channels *
+	       ((20 * (scan->scan_req.max_channel_time)) + 10);
+	atomic_set(&wvif->scan.in_progress, 1);
+	atomic_set(&wvif->wdev->scan_in_progress, 1);
+
+	schedule_delayed_work(&wvif->scan.timeout, msecs_to_jiffies(tmo));
+	ret = hif_scan(wvif, scan);
+	if (ret) {
+		wfx_scan_failed_cb(wvif);
+		atomic_set(&wvif->scan.in_progress, 0);
+		atomic_set(&wvif->wdev->scan_in_progress, 0);
+		cancel_delayed_work_sync(&wvif->scan.timeout);
+	}
+	return ret;
+}
+
+int wfx_hw_scan(struct ieee80211_hw *hw,
+		   struct ieee80211_vif *vif,
+		   struct ieee80211_scan_request *hw_req)
+{
+	struct wfx_dev *wdev = hw->priv;
+	struct wfx_vif *wvif = (struct wfx_vif *) vif->drv_priv;
+	struct cfg80211_scan_request *req = &hw_req->req;
+	struct sk_buff *skb;
+	int i, ret;
+	struct hif_mib_template_frame *p;
+
+	if (!wvif)
+		return -EINVAL;
+
+	if (req->n_ssids == 1 && !req->ssids[0].ssid_len)
+		req->n_ssids = 0;
+
+	if (req->n_ssids > HIF_API_MAX_NB_SSIDS)
+		return -EINVAL;
+
+	skb = ieee80211_probereq_get(hw, wvif->vif->addr, NULL, 0, req->ie_len);
+	if (!skb)
+		return -ENOMEM;
+
+	if (req->ie_len)
+		memcpy(skb_put(skb, req->ie_len), req->ie, req->ie_len);
+
+	mutex_lock(&wdev->conf_mutex);
+
+	p = (struct hif_mib_template_frame *)skb_push(skb, 4);
+	p->frame_type = HIF_TMPLT_PRBREQ;
+	p->frame_length = cpu_to_le16(skb->len - 4);
+	ret = hif_set_template_frame(wvif, p);
+	skb_pull(skb, 4);
+
+	if (!ret)
+		/* Host want to be the probe responder. */
+		ret = wfx_fwd_probe_req(wvif, true);
+	if (ret) {
+		mutex_unlock(&wdev->conf_mutex);
+		dev_kfree_skb(skb);
+		return ret;
+	}
+
+	wfx_tx_lock_flush(wdev);
+
+	BUG_ON(wvif->scan.req);
+	wvif->scan.req = req;
+	wvif->scan.n_ssids = 0;
+	wvif->scan.status = 0;
+	wvif->scan.begin = &req->channels[0];
+	wvif->scan.curr = wvif->scan.begin;
+	wvif->scan.end = &req->channels[req->n_channels];
+	wvif->scan.output_power = wdev->output_power;
+
+	for (i = 0; i < req->n_ssids; ++i) {
+		struct hif_ssid_def *dst = &wvif->scan.ssids[wvif->scan.n_ssids];
+
+		memcpy(&dst->ssid[0], req->ssids[i].ssid, sizeof(dst->ssid));
+		dst->ssid_length = req->ssids[i].ssid_len;
+		++wvif->scan.n_ssids;
+	}
+
+	mutex_unlock(&wdev->conf_mutex);
+
+	if (skb)
+		dev_kfree_skb(skb);
+	schedule_work(&wvif->scan.work);
+	return 0;
+}
+
+void wfx_scan_work(struct work_struct *work)
+{
+	struct wfx_vif *wvif = container_of(work, struct wfx_vif, scan.work);
+	struct ieee80211_channel **it;
+	struct wfx_scan_params scan = {
+		.scan_req.scan_type.type = 0,    /* Foreground */
+	};
+	struct ieee80211_channel *first;
+	int i;
+
+	down(&wvif->scan.lock);
+	mutex_lock(&wvif->wdev->conf_mutex);
+
+	if (!wvif->scan.req || wvif->scan.curr == wvif->scan.end) {
+		if (wvif->scan.output_power != wvif->wdev->output_power)
+			hif_set_output_power(wvif, wvif->wdev->output_power * 10);
+
+		if (wvif->scan.status < 0)
+			dev_warn(wvif->wdev->dev, "scan failed\n");
+		else if (wvif->scan.req)
+			dev_dbg(wvif->wdev->dev, "scan completed\n");
+		else
+			dev_dbg(wvif->wdev->dev, "scan canceled\n");
+
+		wvif->scan.req = NULL;
+		wfx_tx_unlock(wvif->wdev);
+		mutex_unlock(&wvif->wdev->conf_mutex);
+		__ieee80211_scan_completed_compat(wvif->wdev->hw, wvif->scan.status ? 1 : 0);
+		up(&wvif->scan.lock);
+		return;
+	}
+	first = *wvif->scan.curr;
+
+	for (it = wvif->scan.curr + 1, i = 1;
+	     it != wvif->scan.end && i < HIF_API_MAX_NB_CHANNELS;
+	     ++it, ++i) {
+		if ((*it)->band != first->band)
+			break;
+		if (((*it)->flags ^ first->flags) &
+				IEEE80211_CHAN_NO_IR)
+			break;
+		if (!(first->flags & IEEE80211_CHAN_NO_IR) &&
+		    (*it)->max_power != first->max_power)
+			break;
+	}
+	scan.scan_req.band = first->band;
+
+	if (wvif->scan.req->no_cck)
+		scan.scan_req.max_transmit_rate = API_RATE_INDEX_G_6MBPS;
+	else
+		scan.scan_req.max_transmit_rate = API_RATE_INDEX_B_1MBPS;
+	scan.scan_req.num_of_probe_requests =
+		(first->flags & IEEE80211_CHAN_NO_IR) ? 0 : 2;
+	scan.scan_req.num_of_ssi_ds = wvif->scan.n_ssids;
+	scan.ssids = &wvif->scan.ssids[0];
+	scan.scan_req.num_of_channels = it - wvif->scan.curr;
+	scan.scan_req.probe_delay = 100;
+
+	scan.ch = kcalloc(scan.scan_req.num_of_channels, sizeof(u8), GFP_KERNEL);
+
+	if (!scan.ch) {
+		wvif->scan.status = -ENOMEM;
+		goto fail;
+	}
+	for (i = 0; i < scan.scan_req.num_of_channels; ++i)
+		scan.ch[i] = wvif->scan.curr[i]->hw_value;
+
+	if (wvif->scan.curr[0]->flags & IEEE80211_CHAN_NO_IR) {
+		scan.scan_req.min_channel_time = 50;
+		scan.scan_req.max_channel_time = 150;
+	} else {
+		scan.scan_req.min_channel_time = 10;
+		scan.scan_req.max_channel_time = 50;
+	}
+	if (!(first->flags & IEEE80211_CHAN_NO_IR) &&
+	    wvif->scan.output_power != first->max_power) {
+		wvif->scan.output_power = first->max_power;
+		hif_set_output_power(wvif, wvif->scan.output_power * 10);
+	}
+	wvif->scan.status = wfx_scan_start(wvif, &scan);
+	kfree(scan.ch);
+	if (wvif->scan.status)
+		goto fail;
+	wvif->scan.curr = it;
+	mutex_unlock(&wvif->wdev->conf_mutex);
+	return;
+
+fail:
+	wvif->scan.curr = wvif->scan.end;
+	mutex_unlock(&wvif->wdev->conf_mutex);
+	up(&wvif->scan.lock);
+	schedule_work(&wvif->scan.work);
+}
+
+static void wfx_scan_complete(struct wfx_vif *wvif)
+{
+	up(&wvif->scan.lock);
+	atomic_set(&wvif->wdev->scan_in_progress, 0);
+
+	wfx_scan_work(&wvif->scan.work);
+}
+
+void wfx_scan_failed_cb(struct wfx_vif *wvif)
+{
+	if (cancel_delayed_work_sync(&wvif->scan.timeout) > 0) {
+		wvif->scan.status = -EIO;
+		schedule_work(&wvif->scan.timeout.work);
+	}
+}
+
+void wfx_scan_complete_cb(struct wfx_vif *wvif, struct hif_ind_scan_cmpl *arg)
+{
+	if (cancel_delayed_work_sync(&wvif->scan.timeout) > 0) {
+		wvif->scan.status = 1;
+		schedule_work(&wvif->scan.timeout.work);
+	}
+}
+
+void wfx_scan_timeout(struct work_struct *work)
+{
+	struct wfx_vif *wvif = container_of(work, struct wfx_vif, scan.timeout.work);
+
+	if (atomic_xchg(&wvif->scan.in_progress, 0)) {
+		if (wvif->scan.status > 0) {
+			wvif->scan.status = 0;
+		} else if (!wvif->scan.status) {
+			dev_warn(wvif->wdev->dev, "timeout waiting for scan complete notification\n");
+			wvif->scan.status = -ETIMEDOUT;
+			wvif->scan.curr = wvif->scan.end;
+			hif_stop_scan(wvif);
+		}
+		wfx_scan_complete(wvif);
+	}
+}
