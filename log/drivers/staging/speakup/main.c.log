commit 6203da9803017701da5782998157d9826215059d
Merge: 3017e587e368 16fbf79b0f83
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon Mar 23 08:01:20 2020 +0100

    Merge 5.6-rc7 into staging-next
    
    We need the staging/iio fixes in here as well
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit f23519843b01fdc266dd70ca29ef0f0a54f8b064
Author: Lourdes Pedrajas <lu@pplo.net>
Date:   Sun Mar 15 23:12:47 2020 +0100

    staging: speakup: main: switch multiple assignment for one assignment per line
    
    One assignment per line is preferred, instead of multiple assignments.
    To make it more readable.
    Issue found with checkpatch.
    
    Signed-off-by: Lourdes Pedrajas <lu@pplo.net>
    Reviewed-by: Samuel Thibautl <samuel.thibault@ens-lyon.org>
    Link: https://lore.kernel.org/r/20200315221247.16629-1-lu@pplo.net
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/speakup/main.c b/drivers/staging/speakup/main.c
index 488f2539aa9a..5c47643b302c 100644
--- a/drivers/staging/speakup/main.c
+++ b/drivers/staging/speakup/main.c
@@ -2117,7 +2117,8 @@ speakup_key(struct vc_data *vc, int shift_state, int keycode, u_short keysym,
 			spk_keydown = 0;
 			goto out;
 		}
-		value = spk_lastkey = pad_chars[value];
+		value = pad_chars[value];
+		spk_lastkey = value;
 		spk_keydown++;
 		spk_parked &= 0xfe;
 		goto no_map;

commit 9d32c0cde4e2d1343dfb88a67b2ec6397705b32b
Author: Samuel Thibault <samuel.thibault@ens-lyon.org>
Date:   Fri Mar 6 01:30:47 2020 +0100

    staging/speakup: fix get_word non-space look-ahead
    
    get_char was erroneously given the address of the pointer to the text
    instead of the address of the text, thus leading to random crashes when
    the user requests speaking a word while the current position is on a space
    character and say_word_ctl is not enabled.
    
    Reported-on: https://github.com/bytefire/speakup/issues/1
    Reported-by: Kirk Reiser <kirk@reisers.ca>
    Reported-by: Janina Sajka <janina@rednote.net>
    Reported-by: Alexandr Epaneshnikov <aarnaarn2@gmail.com>
    Reported-by: Gregory Nowak <greg@gregn.net>
    Reported-by: deedra waters <deedra@the-brannons.com>
    Signed-off-by: Samuel Thibault <samuel.thibault@ens-lyon.org>
    Tested-by: Alexandr Epaneshnikov <aarnaarn2@gmail.com>
    Tested-by: Gregory Nowak <greg@gregn.net>
    Tested-by: Michael Taboada <michael@michaels.world>
    Cc: stable <stable@vger.kernel.org>
    Link: https://lore.kernel.org/r/20200306003047.thijtmqrnayd3dmw@function
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/speakup/main.c b/drivers/staging/speakup/main.c
index 488f2539aa9a..81ecfd1a200d 100644
--- a/drivers/staging/speakup/main.c
+++ b/drivers/staging/speakup/main.c
@@ -561,7 +561,7 @@ static u_long get_word(struct vc_data *vc)
 		return 0;
 	} else if (tmpx < vc->vc_cols - 2 &&
 		   (ch == SPACE || ch == 0 || (ch < 0x100 && IS_WDLM(ch))) &&
-		   get_char(vc, (u_short *)&tmp_pos + 1, &temp) > SPACE) {
+		   get_char(vc, (u_short *)tmp_pos + 1, &temp) > SPACE) {
 		tmp_pos += 2;
 		tmpx++;
 	} else {

commit 41f13084506aba1d50412026764cf7ad460fd9c2
Author: Okash Khawaja <okash.khawaja@gmail.com>
Date:   Wed Apr 17 13:21:14 2019 +0100

    staging: speakup: refactor to use existing code in vt
    
    This patch replaces speakup's implementations with calls to functions
    in tty/vt/selection.c. Those functions are:
    
    cancel_selection()
    set_selection_kernel()
    paste_selection()
    
    Currently setting selection is done in interrupt context. However,
    set_selection_kernel() can sleep - for instance, it requires console_lock
    which can sleep. Therefore we offload that work to a work_struct thread,
    following the same pattern which was already set for paste_selection().
    When setting selection, we also get a reference to tty and make sure to
    release the reference before returning.
    
    struct speakup_paste_work has been renamed to the more generic
    speakup_selection_work because it is now used for both pasting as well
    as setting selection. When paste work is cancelled, the code wasn't
    setting tty to NULL. This patch also fixes that by setting tty to NULL
    so that in case of failure we don't get EBUSY forever.
    
    Signed-off-by: Okash Khawaja <okash.khawaja@gmail.com>
    Reviewed-by: Samuel Thibault <samuel.thibault@ens-lyon.org>
    Tested-by: Gregory Nowak <greg@gregn.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/speakup/main.c b/drivers/staging/speakup/main.c
index b6a65b0c1896..488f2539aa9a 100644
--- a/drivers/staging/speakup/main.c
+++ b/drivers/staging/speakup/main.c
@@ -2319,6 +2319,7 @@ static void __exit speakup_exit(void)
 	unregister_keyboard_notifier(&keyboard_notifier_block);
 	unregister_vt_notifier(&vt_notifier_block);
 	speakup_unregister_devsynth();
+	speakup_cancel_selection();
 	speakup_cancel_paste();
 	del_timer_sync(&cursor_timer);
 	kthread_stop(speakup_task);

commit e2d55017ae1ce44247d03c1612e9b724ceff1388
Author: Bhagyashri Dighole <digholebhagyashri@gmail.com>
Date:   Thu Feb 28 17:59:04 2019 +0530

    staging: speakup: fix line over 80 characters.
    
    Fix coding style issues, which solves checkpatch.pl warning:
    "WARNING: line over 80 characters".
    
    Signed-off-by: Bhagyashri Dighole <digholebhagyashri@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/speakup/main.c b/drivers/staging/speakup/main.c
index c092a8ea45e2..b6a65b0c1896 100644
--- a/drivers/staging/speakup/main.c
+++ b/drivers/staging/speakup/main.c
@@ -901,7 +901,8 @@ static int get_sentence_buf(struct vc_data *vc, int read_punc)
 	while (start < end) {
 		sentbuf[bn][i] = get_char(vc, (u_short *)start, &tmp);
 		if (i > 0) {
-			if (sentbuf[bn][i] == SPACE && sentbuf[bn][i - 1] == '.' &&
+			if (sentbuf[bn][i] == SPACE &&
+			    sentbuf[bn][i - 1] == '.' &&
 			    numsentences[bn] < 9) {
 				/* Sentence Marker */
 				numsentences[bn]++;
@@ -1235,7 +1236,8 @@ int spk_set_key_info(const u_char *key_info, u_char *k_buffer)
 	key_data_len = (states + 1) * (num_keys + 1);
 	if (key_data_len + SHIFT_TBL_SIZE + 4 >= sizeof(spk_key_buf)) {
 		pr_debug("too many key_infos (%d over %u)\n",
-			 key_data_len + SHIFT_TBL_SIZE + 4, (unsigned int)(sizeof(spk_key_buf)));
+			 key_data_len + SHIFT_TBL_SIZE + 4,
+			 (unsigned int)(sizeof(spk_key_buf)));
 		return -EINVAL;
 	}
 	memset(k_buffer, 0, SHIFT_TBL_SIZE);
@@ -1249,8 +1251,8 @@ int spk_set_key_info(const u_char *key_info, u_char *k_buffer)
 	for (i = 1; i <= states; i++) {
 		ch = *cp1++;
 		if (ch >= SHIFT_TBL_SIZE) {
-			pr_debug("(%d) not valid shift state (max_allowed = %d)\n", ch,
-				 SHIFT_TBL_SIZE);
+			pr_debug("(%d) not valid shift state (max_allowed = %d)\n",
+				 ch, SHIFT_TBL_SIZE);
 			return -EINVAL;
 		}
 		spk_shift_table[ch] = i;
@@ -1258,7 +1260,8 @@ int spk_set_key_info(const u_char *key_info, u_char *k_buffer)
 	keymap_flags = *cp1++;
 	while ((ch = *cp1)) {
 		if (ch >= MAX_KEY) {
-			pr_debug("(%d), not valid key, (max_allowed = %d)\n", ch, MAX_KEY);
+			pr_debug("(%d), not valid key, (max_allowed = %d)\n",
+				 ch, MAX_KEY);
 			return -EINVAL;
 		}
 		spk_our_keys[ch] = cp1;

commit 615cba3557f1bad6061acde2067a3edbf80d90c2
Author: Samuel Thibault <samuel.thibault@ens-lyon.org>
Date:   Sat Feb 23 20:42:19 2019 +0100

    staging: speakup: Note that simple_strtoul can't simply be replaced by kstrtoul
    
    We often receive patches which erroneously try to use kstrtoul in these
    places.
    
    Signed-off-by: Samuel Thibault <samuel.thibault@ens-lyon.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/speakup/main.c b/drivers/staging/speakup/main.c
index 869f40ebf1a7..c092a8ea45e2 100644
--- a/drivers/staging/speakup/main.c
+++ b/drivers/staging/speakup/main.c
@@ -1979,6 +1979,7 @@ static int handle_goto(struct vc_data *vc, u_char type, u_char ch, u_short key)
 		return 1;
 	}
 
+	/* Do not replace with kstrtoul: here we need cp to be updated */
 	goto_pos = simple_strtoul(goto_buf, &cp, 10);
 
 	if (*cp == 'x') {

commit d1598d4e3b1c26215b70c8d7ea6dd1ec6d478bf9
Author: Samuel Thibault <samuel.thibault@ens-lyon.org>
Date:   Mon May 14 22:57:25 2018 +0200

    staging: speakup: use true/false instead of 1/0
    
    Signed-off-by: Samuel Thibault <samuel.thibault@ens-lyon.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/speakup/main.c b/drivers/staging/speakup/main.c
index 84dff6ef46d1..869f40ebf1a7 100644
--- a/drivers/staging/speakup/main.c
+++ b/drivers/staging/speakup/main.c
@@ -1786,7 +1786,7 @@ static void speakup_con_update(struct vc_data *vc)
 	speakup_date(vc);
 	if (vc->vc_mode == KD_GRAPHICS && !spk_paused && spk_str_pause[0]) {
 		synth_printf("%s", spk_str_pause);
-		spk_paused = 1;
+		spk_paused = true;
 	}
 	spin_unlock_irqrestore(&speakup_info.spinlock, flags);
 }

commit fbae47076e9307154fac38d57b260e8dd7c79b1d
Author: Samuel Thibault <samuel.thibault@ens-lyon.org>
Date:   Sun May 13 11:38:30 2018 +0200

    staging: speakup: Fix coding style
    
    Signed-off-by: Samuel Thibault <samuel.thibault@ens-lyon.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/speakup/main.c b/drivers/staging/speakup/main.c
index b7fae36d41d9..84dff6ef46d1 100644
--- a/drivers/staging/speakup/main.c
+++ b/drivers/staging/speakup/main.c
@@ -68,7 +68,7 @@ int spk_punc_level, spk_reading_punc;
 char spk_str_caps_start[MAXVARLEN + 1] = "\0";
 char spk_str_caps_stop[MAXVARLEN + 1] = "\0";
 char spk_str_pause[MAXVARLEN + 1] = "\0";
-bool spk_paused = 0;
+bool spk_paused;
 const struct st_bits_data spk_punc_info[] = {
 	{"none", "", 0},
 	{"some", "/$%&@", SOME},
@@ -1784,8 +1784,7 @@ static void speakup_con_update(struct vc_data *vc)
 		/* Speakup output, discard */
 		return;
 	speakup_date(vc);
-	if (vc->vc_mode == KD_GRAPHICS && !spk_paused && spk_str_pause[0])
-	{
+	if (vc->vc_mode == KD_GRAPHICS && !spk_paused && spk_str_pause[0]) {
 		synth_printf("%s", spk_str_pause);
 		spk_paused = 1;
 	}

commit 2610df41489f548e235171b86895d4b49e6acb1f
Author: Samuel Thibault <samuel.thibault@ens-lyon.org>
Date:   Wed May 2 02:56:10 2018 +0200

    staging: speakup: Add pause command used on switching to graphical mode
    
    For software speech syntheses to be able to manage concurrent audio card
    access, they need to know when speakup stops emitting text to be spoken
    because the console has switched to graphical mode.  This introduces a
    PAUSE command to do so.
    
    Signed-off-by: Samuel Thibault <samuel.thibault@ens-lyon.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/speakup/main.c b/drivers/staging/speakup/main.c
index af30b7099bed..b7fae36d41d9 100644
--- a/drivers/staging/speakup/main.c
+++ b/drivers/staging/speakup/main.c
@@ -67,6 +67,8 @@ short spk_punc_mask;
 int spk_punc_level, spk_reading_punc;
 char spk_str_caps_start[MAXVARLEN + 1] = "\0";
 char spk_str_caps_stop[MAXVARLEN + 1] = "\0";
+char spk_str_pause[MAXVARLEN + 1] = "\0";
+bool spk_paused = 0;
 const struct st_bits_data spk_punc_info[] = {
 	{"none", "", 0},
 	{"some", "/$%&@", SOME},
@@ -1782,6 +1784,11 @@ static void speakup_con_update(struct vc_data *vc)
 		/* Speakup output, discard */
 		return;
 	speakup_date(vc);
+	if (vc->vc_mode == KD_GRAPHICS && !spk_paused && spk_str_pause[0])
+	{
+		synth_printf("%s", spk_str_pause);
+		spk_paused = 1;
+	}
 	spin_unlock_irqrestore(&speakup_info.spinlock, flags);
 }
 

commit accb9343f58c6750c328645ca4b87fdf0fef3623
Author: Santha Meena Ramamoorthy <santhameena13@gmail.com>
Date:   Mon Mar 5 09:34:13 2018 -0800

    staging: speakup: match alignment with open parenthesis
    
    Match alignment with the open parenthesis to conform to the Linux kernel
    coding style. Issue found using checkpatch.
    
    Signed-off-by: Santha Meena Ramamoorthy <santhameena13@gmail.com>
    Acked-by: Samuel Thibault <samuel.thibault@ens-lyon.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/speakup/main.c b/drivers/staging/speakup/main.c
index d7cdec3271be..af30b7099bed 100644
--- a/drivers/staging/speakup/main.c
+++ b/drivers/staging/speakup/main.c
@@ -417,7 +417,7 @@ static void announce_edge(struct vc_data *vc, int msg_id)
 		bleep(spk_y);
 	if ((spk_bleeps & 2) && (msg_id < edge_quiet))
 		synth_printf("%s\n",
-			spk_msg_get(MSG_EDGE_MSGS_START + msg_id - 1));
+			     spk_msg_get(MSG_EDGE_MSGS_START + msg_id - 1));
 }
 
 static void speak_char(u16 ch)

commit 57352e12971e537ac641b0bf64709c958c6c7e78
Author: Santha Meena Ramamoorthy <santhameena13@gmail.com>
Date:   Sat Feb 24 15:25:49 2018 -0800

    staging: speakup: add braces around else statement
    
    Add braces {} around else statement to conform to the Linux kernel
    coding style. Issue found using checkpatch.
    
    Signed-off-by: Santha Meena Ramamoorthy <santhameena13@gmail.com>
    Acked-by: Samuel Thibault <samuel.thibault@ens-lyon.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/speakup/main.c b/drivers/staging/speakup/main.c
index cf1259059776..d7cdec3271be 100644
--- a/drivers/staging/speakup/main.c
+++ b/drivers/staging/speakup/main.c
@@ -449,8 +449,9 @@ static void speak_char(u16 ch)
 		if (*cp == '^') {
 			cp++;
 			synth_printf(" %s%s ", spk_msg_get(MSG_CTRL), cp);
-		} else
+		} else {
 			synth_printf(" %s ", cp);
+		}
 	}
 }
 
@@ -561,7 +562,7 @@ static u_long get_word(struct vc_data *vc)
 		   get_char(vc, (u_short *)&tmp_pos + 1, &temp) > SPACE) {
 		tmp_pos += 2;
 		tmpx++;
-	} else
+	} else {
 		while (tmpx > 0) {
 			ch = get_char(vc, (u_short *)tmp_pos - 1, &temp);
 			if ((ch == SPACE || ch == 0 ||
@@ -571,6 +572,7 @@ static u_long get_word(struct vc_data *vc)
 			tmp_pos -= 2;
 			tmpx--;
 		}
+	}
 	attr_ch = get_char(vc, (u_short *)tmp_pos, &spk_attr);
 	buf[cnt++] = attr_ch;
 	while (tmpx < vc->vc_cols - 1) {

commit a407235bf277d020b2970e725edaf9a7060cb11a
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Thu Jan 11 11:08:41 2018 +0100

    staging: speakup: remove redundant license text
    
    Now that the SPDX tag is in all drivers/staging/speakup/ files, that
    identifies the license in a specific and legally-defined manner.  So the
    extra GPL text wording can be removed as it is no longer needed at all.
    
    This is done on a quest to remove the 700+ different ways that files in
    the kernel describe the GPL license text.  And there's unneeded stuff
    like the address (sometimes incorrect) for the FSF which is never
    needed.
    
    No copyright headers or other non-license-description text was removed.
    
    Cc: William Hubbs <w.d.hubbs@gmail.com>
    Cc: Chris Brannon <chris@the-brannons.com>
    Cc: Kirk Reiser <kirk@reisers.ca>
    Cc: Samuel Thibault <samuel.thibault@ens-lyon.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/speakup/main.c b/drivers/staging/speakup/main.c
index 600221aac324..cf1259059776 100644
--- a/drivers/staging/speakup/main.c
+++ b/drivers/staging/speakup/main.c
@@ -7,16 +7,6 @@
  *
  ** Copyright (C) 1998  Kirk Reiser.
  *  Copyright (C) 2003  David Borowski.
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
  */
 
 #include <linux/kernel.h>

commit 6496922817e1a1cba8a2d9939ca5de53c5d55239
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Thu Jan 11 11:08:40 2018 +0100

    staging: speakup: add SPDX identifier.
    
    It's good to have SPDX identifiers in all files to make it easier to
    audit the kernel tree for correct licenses.
    
    Fix up the remaining staging speakup files to have a proper SPDX
    identifier, based on the license text in the file itself.  The SPDX
    identifier is a legally binding shorthand, which can be used instead of
    the full boiler plate text.
    
    This work is based on a script and data from Thomas Gleixner, Philippe
    Ombredanne, and Kate Stewart.
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: Philippe Ombredanne <pombredanne@nexb.com>
    Cc: William Hubbs <w.d.hubbs@gmail.com>
    Cc: Chris Brannon <chris@the-brannons.com>
    Cc: Kirk Reiser <kirk@reisers.ca>
    Cc: Samuel Thibault <samuel.thibault@ens-lyon.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/speakup/main.c b/drivers/staging/speakup/main.c
index aae868509e13..600221aac324 100644
--- a/drivers/staging/speakup/main.c
+++ b/drivers/staging/speakup/main.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0+
 /* speakup.c
  * review functions for the speakup screen review package.
  * originally written by: Kirk Reiser and Andy Berdan.

commit 24ed960abf1d50cb7834e99a0cfc081bc0656712
Author: Kees Cook <keescook@chromium.org>
Date:   Mon Aug 28 11:28:21 2017 -0700

    treewide: Switch DEFINE_TIMER callbacks to struct timer_list *
    
    This changes all DEFINE_TIMER() callbacks to use a struct timer_list
    pointer instead of unsigned long. Since the data argument has already been
    removed, none of these callbacks are using their argument currently, so
    this renames the argument to "unused".
    
    Done using the following semantic patch:
    
    @match_define_timer@
    declarer name DEFINE_TIMER;
    identifier _timer, _callback;
    @@
    
     DEFINE_TIMER(_timer, _callback);
    
    @change_callback depends on match_define_timer@
    identifier match_define_timer._callback;
    type _origtype;
    identifier _origarg;
    @@
    
     void
    -_callback(_origtype _origarg)
    +_callback(struct timer_list *unused)
     { ... }
    
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/drivers/staging/speakup/main.c b/drivers/staging/speakup/main.c
index 16497202473f..aae868509e13 100644
--- a/drivers/staging/speakup/main.c
+++ b/drivers/staging/speakup/main.c
@@ -1164,7 +1164,7 @@ static void spkup_write(const u16 *in_buf, int count)
 static const int NUM_CTL_LABELS = (MSG_CTL_END - MSG_CTL_START + 1);
 
 static void read_all_doc(struct vc_data *vc);
-static void cursor_done(u_long data);
+static void cursor_done(struct timer_list *unused);
 static DEFINE_TIMER(cursor_timer, cursor_done);
 
 static void do_handle_shift(struct vc_data *vc, u_char value, char up_flag)
@@ -1682,7 +1682,7 @@ static int speak_highlight(struct vc_data *vc)
 	return 0;
 }
 
-static void cursor_done(u_long data)
+static void cursor_done(struct timer_list *unused)
 {
 	struct vc_data *vc = vc_cons[cursor_con].d;
 	unsigned long flags;

commit 449fcf3ab0baf3dde9952385e6789f2ca10c3980
Merge: 3c073991eb41 c14dd9d5f8be
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Nov 13 20:53:28 2017 -0800

    Merge tag 'staging-4.15-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/staging
    
    Pull staging and IIO updates from Greg KH:
     "Here is the "big" staging and IIO driver update for 4.15-rc1.
    
      Lots and lots of little changes, almost all minor code cleanups as the
      Outreachy application process happened during this development cycle.
      Also happened was a lot of IIO driver activity, and the typec USB code
      moving out of staging to drivers/usb (same commits are in the USB tree
      on a persistent branch to not cause merge issues.)
    
      Overall, it's a wash, I think we added a few hundred more lines than
      removed, but really only a few thousand were modified at all.
    
      All of these have been in linux-next for a while. There might be a
      merge issue with Al's vfs tree in the pi433 driver (take his changes,
      they are always better), and the media tree with some of the odd
      atomisp cleanups (take the media tree's version)"
    
    * tag 'staging-4.15-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/staging: (507 commits)
      staging: lustre: add SPDX identifiers to all lustre files
      staging: greybus: Remove redundant license text
      staging: greybus: add SPDX identifiers to all greybus driver files
      staging: ccree: simplify ioread/iowrite
      staging: ccree: simplify registers access
      staging: ccree: simplify error handling logic
      staging: ccree: remove dead code
      staging: ccree: handle limiting of DMA masks
      staging: ccree: copy IV to DMAable memory
      staging: fbtft: remove redundant initialization of buf
      staging: sm750fb: Fix parameter mistake in poke32
      staging: wilc1000: Fix bssid buffer offset in Txq
      staging: fbtft: fb_ssd1331: fix mirrored display
      staging: android: Fix checkpatch.pl error
      staging: greybus: loopback: convert loopback to use generic async operations
      staging: greybus: operation: add private data with get/set accessors
      staging: greybus: loopback: Fix iteration count on async path
      staging: greybus: loopback: Hold per-connection mutex across operations
      staging: greybus/loopback: use ktime_get() for time intervals
      staging: fsl-dpaa2/eth: Extra headroom in RX buffers
      ...

commit 1236d6bb6e19fc72ffc6bbcdeb1bfefe450e54ee
Merge: 750b1a6894ec 8a5776a5f498
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon Oct 9 09:02:35 2017 +0200

    Merge 4.14-rc4 into staging-next
    
    We want the staging/iio fixes in here as well to handle merge issues.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 1d27e3e2252ba9d949ca82fbdb73cde102cb2067
Author: Kees Cook <keescook@chromium.org>
Date:   Wed Oct 4 16:27:04 2017 -0700

    timer: Remove expires and data arguments from DEFINE_TIMER
    
    Drop the arguments from the macro and adjust all callers with the
    following script:
    
      perl -pi -e 's/DEFINE_TIMER\((.*), 0, 0\);/DEFINE_TIMER($1);/g;' \
        $(git grep DEFINE_TIMER | cut -d: -f1 | sort -u | grep -v timer.h)
    
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Acked-by: Geert Uytterhoeven <geert@linux-m68k.org> # for m68k parts
    Acked-by: Guenter Roeck <linux@roeck-us.net> # for watchdog parts
    Acked-by: David S. Miller <davem@davemloft.net> # for networking parts
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Acked-by: Kalle Valo <kvalo@codeaurora.org> # for wireless parts
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Cc: linux-mips@linux-mips.org
    Cc: Petr Mladek <pmladek@suse.com>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Lai Jiangshan <jiangshanlai@gmail.com>
    Cc: Sebastian Reichel <sre@kernel.org>
    Cc: Kalle Valo <kvalo@qca.qualcomm.com>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Pavel Machek <pavel@ucw.cz>
    Cc: linux1394-devel@lists.sourceforge.net
    Cc: Chris Metcalf <cmetcalf@mellanox.com>
    Cc: linux-s390@vger.kernel.org
    Cc: linux-wireless@vger.kernel.org
    Cc: "James E.J. Bottomley" <jejb@linux.vnet.ibm.com>
    Cc: Wim Van Sebroeck <wim@iguana.be>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Ursula Braun <ubraun@linux.vnet.ibm.com>
    Cc: Viresh Kumar <viresh.kumar@linaro.org>
    Cc: Harish Patil <harish.patil@cavium.com>
    Cc: Stephen Boyd <sboyd@codeaurora.org>
    Cc: Michael Reed <mdr@sgi.com>
    Cc: Manish Chopra <manish.chopra@cavium.com>
    Cc: Len Brown <len.brown@intel.com>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: linux-pm@vger.kernel.org
    Cc: Heiko Carstens <heiko.carstens@de.ibm.com>
    Cc: Tejun Heo <tj@kernel.org>
    Cc: Julian Wiedmann <jwi@linux.vnet.ibm.com>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: Mark Gross <mark.gross@intel.com>
    Cc: linux-watchdog@vger.kernel.org
    Cc: linux-scsi@vger.kernel.org
    Cc: "Martin K. Petersen" <martin.petersen@oracle.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: "Rafael J. Wysocki" <rjw@rjwysocki.net>
    Cc: Oleg Nesterov <oleg@redhat.com>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: Stefan Richter <stefanr@s5r6.in-berlin.de>
    Cc: Guenter Roeck <linux@roeck-us.net>
    Cc: netdev@vger.kernel.org
    Cc: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: linuxppc-dev@lists.ozlabs.org
    Cc: Sudip Mukherjee <sudipm.mukherjee@gmail.com>
    Link: https://lkml.kernel.org/r/1507159627-127660-11-git-send-email-keescook@chromium.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/drivers/staging/speakup/main.c b/drivers/staging/speakup/main.c
index 56f7be6af1f6..585925bb49a4 100644
--- a/drivers/staging/speakup/main.c
+++ b/drivers/staging/speakup/main.c
@@ -1165,7 +1165,7 @@ static const int NUM_CTL_LABELS = (MSG_CTL_END - MSG_CTL_START + 1);
 
 static void read_all_doc(struct vc_data *vc);
 static void cursor_done(u_long data);
-static DEFINE_TIMER(cursor_timer, cursor_done, 0, 0);
+static DEFINE_TIMER(cursor_timer, cursor_done);
 
 static void do_handle_shift(struct vc_data *vc, u_char value, char up_flag)
 {

commit e5f5d0e20b6cecc0ebe6fc8e7df6f8823ad2d594
Author: Okash Khawaja <okash.khawaja@gmail.com>
Date:   Tue Sep 5 12:51:59 2017 +0100

    staging: speakup: fix speakup-r empty line lockup
    
    When cursor is at beginning of an empty or whitespace-only line and
    speakup-r typed, kernel locks up. This happens because deadlock of in
    input_event function over dev->event_lock, as demonstrated by lockdep
    logs. The reason for that is speakup simulates a down arrow - because
    cursor is at an empty line - while inside key press notifier handler
    which is ultimately triggered from input_event function. The simulated
    key press leads to input_event being called again, this time under its
    own context. So the spinlock is dev->event_lock is acquired while still
    being held.
    
    This patch ensures that key press is not simulated from inside key press
    notifier handler. Instead it delegates to cursor_timer. It starts the
    timer and passes RA_DOWN_ARROW as argument. When timer handler runs and
    sees RA_DOWN_ARROW, it will then call kbd_fakekey2(RA_DOWN_ARROW) which
    will correctly simulate the keypress inside timer context.
    
    When not inside key press notifier callback, the behaviour will remain
    the same as before this patch.
    
    Signed-off-by: Okash Khawaja <okash.khawaja@gmail.com>
    Reviewed-by: Samuel Thibault <samuel.thibault@ens-lyon.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/speakup/main.c b/drivers/staging/speakup/main.c
index 67956e24779c..56f7be6af1f6 100644
--- a/drivers/staging/speakup/main.c
+++ b/drivers/staging/speakup/main.c
@@ -1376,6 +1376,8 @@ static void reset_highlight_buffers(struct vc_data *);
 
 static int read_all_key;
 
+static int in_keyboard_notifier;
+
 static void start_read_all_timer(struct vc_data *vc, int command);
 
 enum {
@@ -1408,7 +1410,10 @@ static void read_all_doc(struct vc_data *vc)
 	cursor_track = read_all_mode;
 	spk_reset_index_count(0);
 	if (get_sentence_buf(vc, 0) == -1) {
-		kbd_fakekey2(vc, RA_DOWN_ARROW);
+		del_timer(&cursor_timer);
+		if (!in_keyboard_notifier)
+			speakup_fake_down_arrow();
+		start_read_all_timer(vc, RA_DOWN_ARROW);
 	} else {
 		say_sentence_num(0, 0);
 		synth_insert_next_index(0);
@@ -2212,8 +2217,10 @@ static int keyboard_notifier_call(struct notifier_block *nb,
 	int ret = NOTIFY_OK;
 	static int keycode;	/* to hold the current keycode */
 
+	in_keyboard_notifier = 1;
+
 	if (vc->vc_mode == KD_GRAPHICS)
-		return ret;
+		goto out;
 
 	/*
 	 * First, determine whether we are handling a fake keypress on
@@ -2225,7 +2232,7 @@ static int keyboard_notifier_call(struct notifier_block *nb,
 	 */
 
 	if (speakup_fake_key_pressed())
-		return ret;
+		goto out;
 
 	switch (code) {
 	case KBD_KEYCODE:
@@ -2266,6 +2273,8 @@ static int keyboard_notifier_call(struct notifier_block *nb,
 			break;
 		}
 	}
+out:
+	in_keyboard_notifier = 0;
 	return ret;
 }
 

commit f952ec5f429cf961e1a812591a39c6c5c5852c9c
Author: Aastha Gupta <aastha.gupta4104@gmail.com>
Date:   Mon Sep 18 01:30:35 2017 +0530

    staging: speakup: remove NULL comparison
    
    This was done using cocccinelle script:
    @@
    identifier arg;
    @@
    
    -arg==NULL
    +!arg
    
    Signed-off-by: Aastha Gupta <aastha.gupta4104@gmail.com>
    Reviewed-by: Samuel Thibault <samuel.thibault@ens-lyon.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/speakup/main.c b/drivers/staging/speakup/main.c
index 938a0aed7de5..e215d05fcffe 100644
--- a/drivers/staging/speakup/main.c
+++ b/drivers/staging/speakup/main.c
@@ -2096,7 +2096,7 @@ speakup_key(struct vc_data *vc, int shift_state, int keycode, u_short keysym,
 	u_char shift_info, offset;
 	int ret = 0;
 
-	if (synth == NULL)
+	if (!synth)
 		return 0;
 
 	spin_lock_irqsave(&speakup_info.spinlock, flags);

commit f38d3104688025b8157cf4e5a4b6fe37f4f7fd66
Author: Justin Skists <j.skists@gmail.com>
Date:   Wed Sep 6 13:14:25 2017 +0100

    staging/speakup: fix checkpatch.pl warning in speak_char()
    
    correct the following warning from checkpatch.pl:-
    
    WARNING: Prefer using '"%s...", __func__' to using 'speak_char', this
    function's name, in a string
    
    Signed-off-by: Justin Skists <j.skists@gmail.com>
    Acked-by: Samuel Thibault <samuel.thibault@ens-lyon.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/speakup/main.c b/drivers/staging/speakup/main.c
index 67956e24779c..938a0aed7de5 100644
--- a/drivers/staging/speakup/main.c
+++ b/drivers/staging/speakup/main.c
@@ -447,7 +447,7 @@ static void speak_char(u16 ch)
 
 	cp = spk_characters[ch];
 	if (!cp) {
-		pr_info("speak_char: cp == NULL!\n");
+		pr_info("%s: cp == NULL!\n", __func__);
 		return;
 	}
 	if (IS_CHAR(ch, B_CAP)) {

commit e23a9b439ce9bd9cbd3d92e4c15db086d3e11410
Author: Okash Khawaja <okash.khawaja@gmail.com>
Date:   Sun Jul 16 17:18:26 2017 +0100

    staging: speakup: safely register and unregister ldisc
    
    This patch makes use of functions added in the previous patch. It
    registers ldisc during init of main speakup module and unregisters it
    during exit. It also removes the code to register ldisc every time a
    synth module is loaded. This way we only register the ldisc once when
    main speakup module is loaded. Since main speakup module is required by
    all synth modules, it is only unloaded when all synths have been
    unloaded. Therefore we unregister the ldisc once, when all speakup
    related references to the ldisc have returned. In unlikely scenario of
    something outside speakup using the ldisc, the ldisc refcount check in
    tty_unregister_ldisc will ensure that it is not unregistered while in
    use.
    
    The function to register ldisc doesn't cause speakup init function to
    fail. That is different from current behaviour where failure to register
    ldisc results in failure to load the specific synth module. This is
    because speakup module is also required by those synths which don't use
    tty and ldisc. We don't want to prevent those modules from loading when
    ldisc fails to register. The synth modules will correctly fail when
    trying to set N_SPEAKUP to tty, if ldisc registrationi had failed.
    
    Signed-off-by: Okash Khawaja <okash.khawaja@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/speakup/main.c b/drivers/staging/speakup/main.c
index 82e5de248947..67956e24779c 100644
--- a/drivers/staging/speakup/main.c
+++ b/drivers/staging/speakup/main.c
@@ -2314,6 +2314,7 @@ static void __exit speakup_exit(void)
 	mutex_lock(&spk_mutex);
 	synth_release();
 	mutex_unlock(&spk_mutex);
+	spk_ttyio_unregister_ldisc();
 
 	speakup_kobj_exit();
 
@@ -2376,6 +2377,7 @@ static int __init speakup_init(void)
 	if (err)
 		goto error_kobjects;
 
+	spk_ttyio_register_ldisc();
 	synth_init(synth_name);
 	speakup_register_devsynth();
 	/*

commit 650b175d635d25c771eab2e8ff8a11584bb3273a
Author: Alexandre Ghiti <alex@ghiti.fr>
Date:   Fri Jun 9 14:14:32 2017 +0200

    staging: speakup: Add missing blank line after declaration
    
    This patch fixes checkpatch warnings about adding a blank line after
    variable declaration.
    
    Signed-off-by: Alexandre Ghiti <alex@ghiti.fr>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/speakup/main.c b/drivers/staging/speakup/main.c
index d2ad596850f3..82e5de248947 100644
--- a/drivers/staging/speakup/main.c
+++ b/drivers/staging/speakup/main.c
@@ -1945,6 +1945,7 @@ static int handle_goto(struct vc_data *vc, u_char type, u_char ch, u_short key)
 		goto oops;
 	if (ch == 8) {
 		u16 wch;
+
 		if (num == 0)
 			return -1;
 		wch = goto_buf[--num];
@@ -2287,6 +2288,7 @@ static int vt_notifier_call(struct notifier_block *nb,
 			speakup_bs(vc);
 		} else {
 			u16 d = param->c;
+
 			speakup_con_write(vc, &d, 1);
 		}
 		break;

commit 0d6ff6164977d3f205bc59b6df6fce0779b0c131
Author: Arushi Singhal <arushisinghal19971997@gmail.com>
Date:   Fri Mar 24 16:59:59 2017 +0530

    staging: speakup: Remove the explicit NULL comparison
    
    Fixed coding style for null comparisons in speakup driver to be more
    consistant with the rest of the kernel coding style.
    Replaced 'x != NULL' with 'x' and 'x = NULL' with '!x'.
    
    Signed-off-by: Arushi Singhal <arushisinghal19971997@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/speakup/main.c b/drivers/staging/speakup/main.c
index b811c869cd67..d2ad596850f3 100644
--- a/drivers/staging/speakup/main.c
+++ b/drivers/staging/speakup/main.c
@@ -301,7 +301,7 @@ static void speakup_shut_up(struct vc_data *vc)
 	spk_shut_up |= 0x01;
 	spk_parked &= 0xfe;
 	speakup_date(vc);
-	if (synth != NULL)
+	if (synth)
 		spk_do_flush();
 }
 
@@ -446,7 +446,7 @@ static void speak_char(u16 ch)
 	}
 
 	cp = spk_characters[ch];
-	if (cp == NULL) {
+	if (!cp) {
 		pr_info("speak_char: cp == NULL!\n");
 		return;
 	}
@@ -1171,7 +1171,7 @@ static void do_handle_shift(struct vc_data *vc, u_char value, char up_flag)
 {
 	unsigned long flags;
 
-	if (synth == NULL || up_flag || spk_killed)
+	if (!synth || up_flag || spk_killed)
 		return;
 	spin_lock_irqsave(&speakup_info.spinlock, flags);
 	if (cursor_track == read_all_mode) {
@@ -1209,7 +1209,7 @@ static void do_handle_latin(struct vc_data *vc, u_char value, char up_flag)
 		spin_unlock_irqrestore(&speakup_info.spinlock, flags);
 		return;
 	}
-	if (synth == NULL || spk_killed) {
+	if (!synth || spk_killed) {
 		spin_unlock_irqrestore(&speakup_info.spinlock, flags);
 		return;
 	}
@@ -1346,7 +1346,7 @@ static int speakup_allocate(struct vc_data *vc, gfp_t gfp_flags)
 	int vc_num;
 
 	vc_num = vc->vc_num;
-	if (speakup_console[vc_num] == NULL) {
+	if (!speakup_console[vc_num]) {
 		speakup_console[vc_num] = kzalloc(sizeof(*speakup_console[0]),
 						  gfp_flags);
 		if (!speakup_console[vc_num])
@@ -1399,7 +1399,7 @@ static void kbd_fakekey2(struct vc_data *vc, int command)
 
 static void read_all_doc(struct vc_data *vc)
 {
-	if ((vc->vc_num != fg_console) || synth == NULL || spk_shut_up)
+	if ((vc->vc_num != fg_console) || !synth || spk_shut_up)
 		return;
 	if (!synth_supports_indexing())
 		return;
@@ -1514,7 +1514,7 @@ static int pre_handle_cursor(struct vc_data *vc, u_char value, char up_flag)
 	spin_lock_irqsave(&speakup_info.spinlock, flags);
 	if (cursor_track == read_all_mode) {
 		spk_parked &= 0xfe;
-		if (synth == NULL || up_flag || spk_shut_up) {
+		if (!synth || up_flag || spk_shut_up) {
 			spin_unlock_irqrestore(&speakup_info.spinlock, flags);
 			return NOTIFY_STOP;
 		}
@@ -1536,7 +1536,7 @@ static void do_handle_cursor(struct vc_data *vc, u_char value, char up_flag)
 
 	spin_lock_irqsave(&speakup_info.spinlock, flags);
 	spk_parked &= 0xfe;
-	if (synth == NULL || up_flag || spk_shut_up || cursor_track == CT_Off) {
+	if (!synth || up_flag || spk_shut_up || cursor_track == CT_Off) {
 		spin_unlock_irqrestore(&speakup_info.spinlock, flags);
 		return;
 	}
@@ -1732,7 +1732,7 @@ static void speakup_bs(struct vc_data *vc)
 		return;
 	if (!spk_parked)
 		speakup_date(vc);
-	if (spk_shut_up || synth == NULL) {
+	if (spk_shut_up || !synth) {
 		spin_unlock_irqrestore(&speakup_info.spinlock, flags);
 		return;
 	}
@@ -1749,7 +1749,7 @@ static void speakup_con_write(struct vc_data *vc, u16 *str, int len)
 {
 	unsigned long flags;
 
-	if ((vc->vc_num != fg_console) || spk_shut_up || synth == NULL)
+	if ((vc->vc_num != fg_console) || spk_shut_up || !synth)
 		return;
 	if (!spin_trylock_irqsave(&speakup_info.spinlock, flags))
 		/* Speakup output, discard */
@@ -1778,7 +1778,7 @@ static void speakup_con_update(struct vc_data *vc)
 {
 	unsigned long flags;
 
-	if (speakup_console[vc->vc_num] == NULL || spk_parked)
+	if (!speakup_console[vc->vc_num] || spk_parked)
 		return;
 	if (!spin_trylock_irqsave(&speakup_info.spinlock, flags))
 		/* Speakup output, discard */
@@ -1793,7 +1793,7 @@ static void do_handle_spec(struct vc_data *vc, u_char value, char up_flag)
 	int on_off = 2;
 	char *label;
 
-	if (synth == NULL || up_flag || spk_killed)
+	if (!synth || up_flag || spk_killed)
 		return;
 	spin_lock_irqsave(&speakup_info.spinlock, flags);
 	spk_shut_up &= 0xfe;
@@ -1837,7 +1837,7 @@ static int inc_dec_var(u_char value)
 
 	var_id = var_id / 2 + FIRST_SET_VAR;
 	p_header = spk_get_var_header(var_id);
-	if (p_header == NULL)
+	if (!p_header)
 		return -1;
 	if (p_header->var_type != VAR_NUM)
 		return -1;
@@ -1920,7 +1920,7 @@ static void speakup_bits(struct vc_data *vc)
 {
 	int val = this_speakup_key - (FIRST_EDIT_BITS - 1);
 
-	if (spk_special_handler != NULL || val < 1 || val > 6) {
+	if (spk_special_handler || val < 1 || val > 6) {
 		synth_printf("%s\n", spk_msg_get(MSG_ERROR));
 		return;
 	}
@@ -2014,7 +2014,7 @@ static int handle_goto(struct vc_data *vc, u_char type, u_char ch, u_short key)
 
 static void speakup_goto(struct vc_data *vc)
 {
-	if (spk_special_handler != NULL) {
+	if (spk_special_handler) {
 		synth_printf("%s\n", spk_msg_get(MSG_ERROR));
 		return;
 	}
@@ -2165,7 +2165,7 @@ speakup_key(struct vc_data *vc, int shift_state, int keycode, u_short keysym,
 		}
 	}
 no_map:
-	if (type == KT_SPKUP && spk_special_handler == NULL) {
+	if (type == KT_SPKUP && !spk_special_handler) {
 		do_spkup(vc, new_key);
 		spk_close_press = 0;
 		ret = 1;

commit b1b2b3ca78757c3162d1dde283117c778133a276
Author: Pranay Kr. Srivastava <pranjas@gmail.com>
Date:   Fri Mar 24 14:07:11 2017 +0530

    staging: speakup: use speakup_allocate as per required context
    
    speakup_allocate used GFP_ATOMIC for allocations
    even while during initialization due to it's use
    in notifier call.
    
    Pass GFP_ flags as well to speakup_allocate depending
    on the context it is called in.
    
    Signed-off-by: Pranay Kr. Srivastava <pranjas@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/speakup/main.c b/drivers/staging/speakup/main.c
index 2db3f067dd23..b811c869cd67 100644
--- a/drivers/staging/speakup/main.c
+++ b/drivers/staging/speakup/main.c
@@ -1341,14 +1341,14 @@ static int edit_bits(struct vc_data *vc, u_char type, u_char ch, u_short key)
 }
 
 /* Allocation concurrency is protected by the console semaphore */
-static int speakup_allocate(struct vc_data *vc)
+static int speakup_allocate(struct vc_data *vc, gfp_t gfp_flags)
 {
 	int vc_num;
 
 	vc_num = vc->vc_num;
 	if (speakup_console[vc_num] == NULL) {
 		speakup_console[vc_num] = kzalloc(sizeof(*speakup_console[0]),
-						  GFP_ATOMIC);
+						  gfp_flags);
 		if (!speakup_console[vc_num])
 			return -ENOMEM;
 		speakup_date(vc);
@@ -2277,7 +2277,7 @@ static int vt_notifier_call(struct notifier_block *nb,
 	switch (code) {
 	case VT_ALLOCATE:
 		if (vc->vc_mode == KD_TEXT)
-			speakup_allocate(vc);
+			speakup_allocate(vc, GFP_ATOMIC);
 		break;
 	case VT_DEALLOCATE:
 		speakup_deallocate(vc);
@@ -2362,7 +2362,7 @@ static int __init speakup_init(void)
 
 	for (i = 0; i < MAX_NR_CONSOLES; i++)
 		if (vc_cons[i].d) {
-			err = speakup_allocate(vc_cons[i].d);
+			err = speakup_allocate(vc_cons[i].d, GFP_KERNEL);
 			if (err)
 				goto error_kobjects;
 		}

commit 65bf4ea10f31a72a9477d4602bcd728ffe510465
Author: Arushi Singhal <arushisinghal19971997@gmail.com>
Date:   Tue Mar 21 17:12:34 2017 +0530

    staging: speakup: Match alignment with open parenthesis.
    
    Fix checkpatch issues: "CHECK: Alignment should match open parenthesis".
    
    Signed-off-by: Arushi Singhal <arushisinghal19971997@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/speakup/main.c b/drivers/staging/speakup/main.c
index 8720de27b035..2db3f067dd23 100644
--- a/drivers/staging/speakup/main.c
+++ b/drivers/staging/speakup/main.c
@@ -1154,7 +1154,7 @@ static void spkup_write(const u16 *in_buf, int count)
 		if (last_type & CH_RPT) {
 			synth_printf(" ");
 			synth_printf(spk_msg_get(MSG_REPEAT_DESC2),
-					++rep_count);
+				     ++rep_count);
 			synth_printf(" ");
 		}
 		rep_count = 0;

commit 23996ee52eb74cb5c4e98adc816724a7030c11e0
Author: Arushi Singhal <arushisinghal19971997@gmail.com>
Date:   Tue Mar 21 17:12:30 2017 +0530

    staging: speakup: Moved OR operator to previous line.
    
    Moved logical OR operator to previous line to fix the following
    checkpatch issue:
    
    CHECK: Logical continuations should be on the previous line.
    
    Signed-off-by: Arushi Singhal <arushisinghal19971997@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/speakup/main.c b/drivers/staging/speakup/main.c
index bc159924d4aa..8720de27b035 100644
--- a/drivers/staging/speakup/main.c
+++ b/drivers/staging/speakup/main.c
@@ -2174,10 +2174,10 @@ speakup_key(struct vc_data *vc, int shift_state, int keycode, u_short keysym,
 	if (up_flag || spk_killed || type == KT_SHIFT)
 		goto out;
 	spk_shut_up &= 0xfe;
-	kh = (value == KVAL(K_DOWN))
-	    || (value == KVAL(K_UP))
-	    || (value == KVAL(K_LEFT))
-	    || (value == KVAL(K_RIGHT));
+	kh = (value == KVAL(K_DOWN)) ||
+	    (value == KVAL(K_UP)) ||
+	    (value == KVAL(K_LEFT)) ||
+	    (value == KVAL(K_RIGHT));
 	if ((cursor_track != read_all_mode) || !kh)
 		if (!spk_no_intr)
 			spk_do_flush();

commit 0dcb2124138a6cdaf76bb0a8247bae0bb3307743
Author: Arushi Singhal <arushisinghal19971997@gmail.com>
Date:   Tue Mar 21 17:12:28 2017 +0530

    staging: speakup: fixes braces {} should be used on all arms of this statement
    
    This patch fixes the checks reported by checkpatch.pl
    for braces {} should be used on all arms of this statement.
    
    Signed-off-by: Arushi Singhal <arushisinghal19971997@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/speakup/main.c b/drivers/staging/speakup/main.c
index 1ebe5cbdbb5a..bc159924d4aa 100644
--- a/drivers/staging/speakup/main.c
+++ b/drivers/staging/speakup/main.c
@@ -406,8 +406,9 @@ static void say_attributes(struct vc_data *vc)
 	if (bg > 7) {
 		synth_printf(" %s ", spk_msg_get(MSG_ON_BLINKING));
 		bg -= 8;
-	} else
+	} else {
 		synth_printf(" %s ", spk_msg_get(MSG_ON));
+	}
 	synth_printf("%s\n", spk_msg_get(MSG_COLORS_START + bg));
 }
 
@@ -637,8 +638,9 @@ static void say_prev_word(struct vc_data *vc)
 				break;
 			spk_y--;
 			spk_x = vc->vc_cols - 1;
-		} else
+		} else {
 			spk_x--;
+		}
 		spk_pos -= 2;
 		ch = get_char(vc, (u_short *)spk_pos, &temp);
 		if (ch == SPACE || ch == 0)
@@ -691,8 +693,9 @@ static void say_next_word(struct vc_data *vc)
 			spk_y++;
 			spk_x = 0;
 			edge_said = edge_right;
-		} else
+		} else {
 			spk_x++;
+		}
 		spk_pos += 2;
 		last_state = state;
 	}
@@ -723,8 +726,9 @@ static void spell_word(struct vc_data *vc)
 				spk_pitch_shift++;
 			else	/* synth has no pitch */
 				last_cap = spk_str_caps_stop;
-		} else
+		} else {
 			str_cap = spk_str_caps_stop;
+		}
 		if (str_cap != last_cap) {
 			synth_printf("%s", str_cap);
 			last_cap = str_cap;
@@ -1348,8 +1352,9 @@ static int speakup_allocate(struct vc_data *vc)
 		if (!speakup_console[vc_num])
 			return -ENOMEM;
 		speakup_date(vc);
-	} else if (!spk_parked)
+	} else if (!spk_parked) {
 		speakup_date(vc);
+	}
 
 	return 0;
 }
@@ -1402,9 +1407,9 @@ static void read_all_doc(struct vc_data *vc)
 		prev_cursor_track = cursor_track;
 	cursor_track = read_all_mode;
 	spk_reset_index_count(0);
-	if (get_sentence_buf(vc, 0) == -1)
+	if (get_sentence_buf(vc, 0) == -1) {
 		kbd_fakekey2(vc, RA_DOWN_ARROW);
-	else {
+	} else {
 		say_sentence_num(0, 0);
 		synth_insert_next_index(0);
 		start_read_all_timer(vc, RA_TIMER);
@@ -1451,8 +1456,9 @@ static void handle_cursor_read_all(struct vc_data *vc, int command)
 			if (!say_sentence_num(sentcount + 1, 1)) {
 				sn = 1;
 				spk_reset_index_count(sn);
-			} else
+			} else {
 				synth_insert_next_index(0);
+			}
 			if (!say_sentence_num(sn, 0)) {
 				kbd_fakekey2(vc, RA_FIND_NEXT_SENT);
 				return;
@@ -1481,9 +1487,9 @@ static void handle_cursor_read_all(struct vc_data *vc, int command)
 		rv = get_sentence_buf(vc, 0);
 		if (rv == -1)
 			read_all_doc(vc);
-		if (rv == 0)
+		if (rv == 0) {
 			kbd_fakekey2(vc, RA_FIND_NEXT_SENT);
-		else {
+		} else {
 			say_sentence_num(1, 0);
 			synth_insert_next_index(0);
 			start_read_all_timer(vc, RA_TIMER);
@@ -2179,10 +2185,11 @@ speakup_key(struct vc_data *vc, int shift_state, int keycode, u_short keysym,
 		if (type == KT_SPEC && value == 1) {
 			value = '\n';
 			type = KT_LATIN;
-		} else if (type == KT_LETTER)
+		} else if (type == KT_LETTER) {
 			type = KT_LATIN;
-		else if (value == 0x7f)
+		} else if (value == 0x7f) {
 			value = 8;	/* make del = backspace */
+		}
 		ret = (*spk_special_handler) (vc, type, value, keycode);
 		spk_close_press = 0;
 		if (ret < 0)
@@ -2276,9 +2283,9 @@ static int vt_notifier_call(struct notifier_block *nb,
 		speakup_deallocate(vc);
 		break;
 	case VT_WRITE:
-		if (param->c == '\b')
+		if (param->c == '\b') {
 			speakup_bs(vc);
-		else {
+		} else {
 			u16 d = param->c;
 			speakup_con_write(vc, &d, 1);
 		}

commit 049aa51558fbfe79606efe961ae452a63ea6df08
Author: Arushi Singhal <arushisinghal19971997@gmail.com>
Date:   Tue Mar 21 17:12:25 2017 +0530

    staging: speakup: Moved logical to previous line.
    
    Moved logical operator to previous line to fix the following
    checkpatch issue:
    
    CHECK: Logical continuations should be on the previous line.
    
    Signed-off-by: Arushi Singhal <arushisinghal19971997@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/speakup/main.c b/drivers/staging/speakup/main.c
index d890b9a864de..1ebe5cbdbb5a 100644
--- a/drivers/staging/speakup/main.c
+++ b/drivers/staging/speakup/main.c
@@ -902,8 +902,8 @@ static int get_sentence_buf(struct vc_data *vc, int read_punc)
 	while (start < end) {
 		sentbuf[bn][i] = get_char(vc, (u_short *)start, &tmp);
 		if (i > 0) {
-			if (sentbuf[bn][i] == SPACE && sentbuf[bn][i - 1] == '.'
-			    && numsentences[bn] < 9) {
+			if (sentbuf[bn][i] == SPACE && sentbuf[bn][i - 1] == '.' &&
+			    numsentences[bn] < 9) {
 				/* Sentence Marker */
 				numsentences[bn]++;
 				sentmarks[bn][numsentences[bn]] =
@@ -1300,8 +1300,8 @@ void spk_reset_default_chars(void)
 
 	/* First, free any non-default */
 	for (i = 0; i < 256; i++) {
-		if ((spk_characters[i] != NULL)
-		    && (spk_characters[i] != spk_default_chars[i]))
+		if (spk_characters[i] &&
+		    (spk_characters[i] != spk_default_chars[i]))
 			kfree(spk_characters[i]);
 	}
 
@@ -2096,8 +2096,8 @@ speakup_key(struct vc_data *vc, int shift_state, int keycode, u_short keysym,
 	tty = vc->port.tty;
 	if (type >= 0xf0)
 		type -= 0xf0;
-	if (type == KT_PAD
-		&& (vt_get_leds(fg_console, VC_NUMLOCK))) {
+	if (type == KT_PAD &&
+	    (vt_get_leds(fg_console, VC_NUMLOCK))) {
 		if (up_flag) {
 			spk_keydown = 0;
 			goto out;

commit ad5a942f6c2055597192b31f9a92c47bf851f90d
Author: Pranay Kr. Srivastava <pranjas@gmail.com>
Date:   Tue Mar 21 12:40:23 2017 +0530

    remove unnecessary initial allocation of vc
    
    This patch removes the unnecessary allocation of
    current foreground vc during initialization.
    
    This initialization is already handled in the loop
    that follows it for all available virtual consoles.
    
    Signed-off-by: Pranay Kr. Srivastava <pranjas@gmail.com>
    Reviewed-by: Samuel Thibault <samuel.thibault@ens-lyon.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/speakup/main.c b/drivers/staging/speakup/main.c
index 9e3d9c52255f..d890b9a864de 100644
--- a/drivers/staging/speakup/main.c
+++ b/drivers/staging/speakup/main.c
@@ -2329,7 +2329,6 @@ static int __init speakup_init(void)
 {
 	int i;
 	long err = 0;
-	struct st_spk_t *first_console;
 	struct vc_data *vc = vc_cons[fg_console].d;
 	struct var_t *var;
 
@@ -2354,15 +2353,6 @@ static int __init speakup_init(void)
 	if (err)
 		goto error_virtkeyboard;
 
-	first_console = kzalloc(sizeof(*first_console), GFP_KERNEL);
-	if (!first_console) {
-		err = -ENOMEM;
-		goto error_alloc;
-	}
-
-	speakup_console[vc->vc_num] = first_console;
-	speakup_date(vc);
-
 	for (i = 0; i < MAX_NR_CONSOLES; i++)
 		if (vc_cons[i].d) {
 			err = speakup_allocate(vc_cons[i].d);
@@ -2424,7 +2414,6 @@ static int __init speakup_init(void)
 	for (i = 0; i < MAX_NR_CONSOLES; i++)
 		kfree(speakup_console[i]);
 
-error_alloc:
 	speakup_remove_virtual_keyboard();
 
 error_virtkeyboard:

commit 4e9cc9a0a5b6c03f3ab652719b3add6562dde25e
Author: Pranay Kr. Srivastava <pranjas@gmail.com>
Date:   Tue Mar 21 12:40:22 2017 +0530

    return same error value from spk_set_key_info
    
    This patch makes spk_set_key_info return -EINVAL
    in case of failure instead of returning 4 different
    values for the type of error that occurred.
    
    Print the offending values instead as debug message.
    
    Signed-off-by: Pranay Kr. Srivastava <pranjas@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/speakup/main.c b/drivers/staging/speakup/main.c
index b81ca8e09542..9e3d9c52255f 100644
--- a/drivers/staging/speakup/main.c
+++ b/drivers/staging/speakup/main.c
@@ -1226,13 +1226,19 @@ int spk_set_key_info(const u_char *key_info, u_char *k_buffer)
 	u_char ch, version, num_keys;
 
 	version = *cp++;
-	if (version != KEY_MAP_VER)
-		return -1;
+	if (version != KEY_MAP_VER) {
+		pr_debug("version found %d should be %d\n",
+			 version, KEY_MAP_VER);
+		return -EINVAL;
+	}
 	num_keys = *cp;
 	states = (int)cp[1];
 	key_data_len = (states + 1) * (num_keys + 1);
-	if (key_data_len + SHIFT_TBL_SIZE + 4 >= sizeof(spk_key_buf))
-		return -2;
+	if (key_data_len + SHIFT_TBL_SIZE + 4 >= sizeof(spk_key_buf)) {
+		pr_debug("too many key_infos (%d over %u)\n",
+			 key_data_len + SHIFT_TBL_SIZE + 4, (unsigned int)(sizeof(spk_key_buf)));
+		return -EINVAL;
+	}
 	memset(k_buffer, 0, SHIFT_TBL_SIZE);
 	memset(spk_our_keys, 0, sizeof(spk_our_keys));
 	spk_shift_table = k_buffer;
@@ -1243,14 +1249,19 @@ int spk_set_key_info(const u_char *key_info, u_char *k_buffer)
 	cp1 += 2;		/* now pointing at shift states */
 	for (i = 1; i <= states; i++) {
 		ch = *cp1++;
-		if (ch >= SHIFT_TBL_SIZE)
-			return -3;
+		if (ch >= SHIFT_TBL_SIZE) {
+			pr_debug("(%d) not valid shift state (max_allowed = %d)\n", ch,
+				 SHIFT_TBL_SIZE);
+			return -EINVAL;
+		}
 		spk_shift_table[ch] = i;
 	}
 	keymap_flags = *cp1++;
 	while ((ch = *cp1)) {
-		if (ch >= MAX_KEY)
-			return -4;
+		if (ch >= MAX_KEY) {
+			pr_debug("(%d), not valid key, (max_allowed = %d)\n", ch, MAX_KEY);
+			return -EINVAL;
+		}
 		spk_our_keys[ch] = cp1;
 		cp1 += states + 1;
 	}

commit e1f28c86a22d2c923bcc18abb22874482ce55951
Author: Samuel Thibault <samuel.thibault@ens-lyon.org>
Date:   Wed Mar 22 00:55:31 2017 +0100

    speakup: Fix spurious space pronunciation on spelling letters
    
    This gathers emitting the caps start string, space, spelled letter
    string, space, and caps stop string, into one printf, to avoid
    sending to the synth a space character alone, which the synth would
    then pronounce.
    
    Similarly, emit space along control-letter and letter spelling.
    
    Signed-off-by: Samuel Thibault <samuel.thibault@ens-lyon.org>
    Tested-by: Zahari Yurukov <zahari.yurukov@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/speakup/main.c b/drivers/staging/speakup/main.c
index f280e22d7e15..b81ca8e09542 100644
--- a/drivers/staging/speakup/main.c
+++ b/drivers/staging/speakup/main.c
@@ -449,20 +449,17 @@ static void speak_char(u16 ch)
 		pr_info("speak_char: cp == NULL!\n");
 		return;
 	}
-	synth_buffer_add(SPACE);
 	if (IS_CHAR(ch, B_CAP)) {
 		spk_pitch_shift++;
-		synth_printf("%s", spk_str_caps_start);
-		synth_printf("%s", cp);
-		synth_printf("%s", spk_str_caps_stop);
+		synth_printf("%s %s %s",
+			     spk_str_caps_start, cp, spk_str_caps_stop);
 	} else {
 		if (*cp == '^') {
-			synth_printf("%s", spk_msg_get(MSG_CTRL));
 			cp++;
-		}
-		synth_printf("%s", cp);
+			synth_printf(" %s%s ", spk_msg_get(MSG_CTRL), cp);
+		} else
+			synth_printf(" %s ", cp);
 	}
-	synth_buffer_add(SPACE);
 }
 
 static u16 get_char(struct vc_data *vc, u16 *pos, u_char *attribs)

commit defaa9ad58dfc561192b350b826dc65b6fb84098
Author: Arushi Singhal <arushisinghal19971997@gmail.com>
Date:   Tue Mar 14 10:46:42 2017 +0530

    staging: speakup: Add blank line after declarations
    
    Patch fixes the warnings reported by checkpatch.pl
    for please use a blank line after function/struct/union/enum
    declarations.
    Add a blank line after enum and struct declarations.
    
    Signed-off-by: Arushi Singhal <arushisinghal19971997@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/speakup/main.c b/drivers/staging/speakup/main.c
index 6f1595737553..f280e22d7e15 100644
--- a/drivers/staging/speakup/main.c
+++ b/drivers/staging/speakup/main.c
@@ -108,6 +108,7 @@ enum {
 	CT_Window,
 	CT_Max
 };
+
 #define read_all_mode CT_Max
 
 static struct tty_struct *tty;

commit 0b4139ad5e654b53c593aa84eb6bf36eb6644512
Author: Samuel Thibault <samuel.thibault@ens-lyon.org>
Date:   Tue Mar 14 20:56:21 2017 +0100

    speakup: Fix bogus caps on speaking unicode characters
    
    commit 33590c185299 ("speakup: Support spelling unicode characters")
    mistakenly passed unicode characters to IS_CHAR(), which only
    supports latin1.  Let's assume non-latin1 is lower case, like is done
    in spell_word().
    
    Signed-off-by: Samuel Thibault <samuel.thibault@ens-lyon.org>
    Reviewed-by: Chris Brannon <chris@the-brannons.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/speakup/main.c b/drivers/staging/speakup/main.c
index dc07b2328bc0..6f1595737553 100644
--- a/drivers/staging/speakup/main.c
+++ b/drivers/staging/speakup/main.c
@@ -433,12 +433,12 @@ static void speak_char(u16 ch)
 	struct var_t *direct = spk_get_var(DIRECT);
 
 	if (ch >= 0x100 || (direct && direct->u.n.value)) {
-		if (IS_CHAR(ch, B_CAP)) {
+		if (ch < 0x100 && IS_CHAR(ch, B_CAP)) {
 			spk_pitch_shift++;
 			synth_printf("%s", spk_str_caps_start);
 		}
 		synth_putwc_s(ch);
-		if (IS_CHAR(ch, B_CAP))
+		if (ch < 0x100 && IS_CHAR(ch, B_CAP))
 			synth_printf("%s", spk_str_caps_stop);
 		return;
 	}

commit 33590c18529973683d41ba0bc942f8e162ab3a21
Author: Samuel Thibault <samuel.thibault@ens-lyon.org>
Date:   Mon Mar 13 01:17:14 2017 +0100

    speakup: Support spelling unicode characters
    
    This supports spelling unicode characters by just passing them to
    the speech synthesis in direct mode.
    
    Signed-off-by: Samuel Thibault <samuel.thibault@ens-lyon.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/speakup/main.c b/drivers/staging/speakup/main.c
index bd5fb32f812d..dc07b2328bc0 100644
--- a/drivers/staging/speakup/main.c
+++ b/drivers/staging/speakup/main.c
@@ -432,7 +432,7 @@ static void speak_char(u16 ch)
 	char *cp;
 	struct var_t *direct = spk_get_var(DIRECT);
 
-	if (direct && direct->u.n.value) {
+	if (ch >= 0x100 || (direct && direct->u.n.value)) {
 		if (IS_CHAR(ch, B_CAP)) {
 			spk_pitch_shift++;
 			synth_printf("%s", spk_str_caps_start);
@@ -443,8 +443,6 @@ static void speak_char(u16 ch)
 		return;
 	}
 
-	if (ch >= 0x100)
-		return;
 	cp = spk_characters[ch];
 	if (cp == NULL) {
 		pr_info("speak_char: cp == NULL!\n");
@@ -712,17 +710,16 @@ static void spell_word(struct vc_data *vc)
 	char *cp1;
 	char *str_cap = spk_str_caps_stop;
 	char *last_cap = spk_str_caps_stop;
+	struct var_t *direct = spk_get_var(DIRECT);
 	u16 ch;
 
 	if (!get_word(vc))
 		return;
 	while ((ch = *cp)) {
-		if (ch >= 0x100)
-			/* FIXME */
-			continue;
 		if (cp != buf)
 			synth_printf(" %s ", delay_str[spk_spell_delay]);
-		if (IS_CHAR(ch, B_CAP)) {
+		/* FIXME: Non-latin1 considered as lower case */
+		if (ch < 0x100 && IS_CHAR(ch, B_CAP)) {
 			str_cap = spk_str_caps_start;
 			if (*spk_str_caps_stop)
 				spk_pitch_shift++;
@@ -734,18 +731,21 @@ static void spell_word(struct vc_data *vc)
 			synth_printf("%s", str_cap);
 			last_cap = str_cap;
 		}
-		if (this_speakup_key == SPELL_PHONETIC &&
+		if (ch >= 0x100 || (direct && direct->u.n.value)) {
+			synth_putwc_s(ch);
+		} else if (this_speakup_key == SPELL_PHONETIC &&
 		    ch <= 0x7f && isalpha(ch)) {
 			ch &= 0x1f;
 			cp1 = phonetic[--ch];
+			synth_printf("%s", cp1);
 		} else {
 			cp1 = spk_characters[ch];
 			if (*cp1 == '^') {
 				synth_printf("%s", spk_msg_get(MSG_CTRL));
 				cp1++;
 			}
+			synth_printf("%s", cp1);
 		}
-		synth_printf("%s", cp1);
 		cp++;
 	}
 	if (str_cap != spk_str_caps_stop)

commit c188966067b48acb94fea37aed06a142e3001122
Author: Samuel Thibault <samuel.thibault@ens-lyon.org>
Date:   Mon Mar 13 01:17:13 2017 +0100

    speakup: make get_char actually get unicode characters
    
    9831013cbdbd3d06430a1db01d8c32d50c7d1c04 ('speakup: convert screen
    reading to 16bit characters') paved the way for handling unicode
    characters in speakup, but for the review mode, it missed actually
    getting unicode characters from the VC. This fixes by just turning the
    use_unicode parameter to 1.
    
    Signed-off-by: Samuel Thibault <samuel.thibault@ens-lyon.org>
    Tested-by: Zahari Yurukov <zahari.yurukov@gmail.com>
    Reviewed-by: Chris Brannon <chris@the-brannons.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/speakup/main.c b/drivers/staging/speakup/main.c
index fb8bef991cdf..bd5fb32f812d 100644
--- a/drivers/staging/speakup/main.c
+++ b/drivers/staging/speakup/main.c
@@ -483,7 +483,7 @@ static u16 get_char(struct vc_data *vc, u16 *pos, u_char *attribs)
 			c |= 0x100;
 		}
 
-		ch = inverse_translate(vc, c, 0);
+		ch = inverse_translate(vc, c, 1);
 		*attribs = (w & 0xff00) >> 8;
 	}
 	return ch;

commit 9831013cbdbd3d06430a1db01d8c32d50c7d1c04
Author: Samuel Thibault <samuel.thibault@ens-lyon.org>
Date:   Sat Mar 4 15:01:56 2017 +0100

    speakup: convert screen reading to 16bit characters
    
    This adds 16bit character support to most of the screen reading by
    extending characters to u16 throughout the code.
    
    Non-latin1 characters are assumed to be alphabetic type for now.
    
    non-latin1 vt_notifier_call-provided characters are not ignored any
    more, and the 16bit character returned by get_char is not truncated any
    more. For simplicity, speak_char still only supports latin1 characters.
    Its direct mode however does support 16bit characters, so in practice
    this will not be a limitation, non-latin1 languages will be handled by
    the synthesizer. spelling words does not support direct mode yet, for
    simplicity for now it will ignore 16bit characters.
    
    For simplicity again, speakup messages are left in latin1 for now.
    
    Some coding style is fixed along the way.
    
    Signed-off-by: Samuel Thibault <samuel.thibault@ens-lyon.org>
    Reviewed-by: Okash Khawaja <okash.khawaja@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/speakup/main.c b/drivers/staging/speakup/main.c
index 96e25eb631b5..fb8bef991cdf 100644
--- a/drivers/staging/speakup/main.c
+++ b/drivers/staging/speakup/main.c
@@ -67,7 +67,7 @@ MODULE_PARM_DESC(quiet, "Do not announce when the synthesizer is found.");
 special_func spk_special_handler;
 
 short spk_pitch_shift, synth_flags;
-static char buf[256];
+static u16 buf[256];
 int spk_attrib_bleep, spk_bleeps, spk_bleep_time = 10;
 int spk_no_intr, spk_spell_delay;
 int spk_key_echo, spk_say_word_ctl;
@@ -112,7 +112,7 @@ enum {
 
 static struct tty_struct *tty;
 
-static void spkup_write(const char *in_buf, int count);
+static void spkup_write(const u16 *in_buf, int count);
 
 static char *phonetic[] = {
 	"alfa", "bravo", "charlie", "delta", "echo", "foxtrot", "golf", "hotel",
@@ -238,7 +238,8 @@ static u_short default_chartab[256] = {
 struct task_struct *speakup_task;
 struct bleep spk_unprocessed_sound;
 static int spk_keydown;
-static u_char spk_lastkey, spk_close_press, keymap_flags;
+static u16 spk_lastkey;
+static u_char spk_close_press, keymap_flags;
 static u_char last_keycode, this_speakup_key;
 static u_long last_spk_jiffy;
 
@@ -426,9 +427,9 @@ static void announce_edge(struct vc_data *vc, int msg_id)
 			spk_msg_get(MSG_EDGE_MSGS_START + msg_id - 1));
 }
 
-static void speak_char(u_char ch)
+static void speak_char(u16 ch)
 {
-	char *cp = spk_characters[ch];
+	char *cp;
 	struct var_t *direct = spk_get_var(DIRECT);
 
 	if (direct && direct->u.n.value) {
@@ -436,11 +437,15 @@ static void speak_char(u_char ch)
 			spk_pitch_shift++;
 			synth_printf("%s", spk_str_caps_start);
 		}
-		synth_printf("%c", ch);
+		synth_putwc_s(ch);
 		if (IS_CHAR(ch, B_CAP))
 			synth_printf("%s", spk_str_caps_stop);
 		return;
 	}
+
+	if (ch >= 0x100)
+		return;
+	cp = spk_characters[ch];
 	if (cp == NULL) {
 		pr_info("speak_char: cp == NULL!\n");
 		return;
@@ -486,7 +491,7 @@ static u16 get_char(struct vc_data *vc, u16 *pos, u_char *attribs)
 
 static void say_char(struct vc_data *vc)
 {
-	u_short ch;
+	u16 ch;
 
 	spk_old_attr = spk_attr;
 	ch = get_char(vc, (u_short *)spk_pos, &spk_attr);
@@ -496,20 +501,20 @@ static void say_char(struct vc_data *vc)
 		if (spk_attrib_bleep & 2)
 			say_attributes(vc);
 	}
-	speak_char(ch & 0xff);
+	speak_char(ch);
 }
 
 static void say_phonetic_char(struct vc_data *vc)
 {
-	u_short ch;
+	u16 ch;
 
 	spk_old_attr = spk_attr;
 	ch = get_char(vc, (u_short *)spk_pos, &spk_attr);
-	if (isascii(ch) && isalpha(ch)) {
+	if (ch <= 0x7f && isalpha(ch)) {
 		ch &= 0x1f;
 		synth_printf("%s\n", phonetic[--ch]);
 	} else {
-		if (IS_CHAR(ch, B_NUM))
+		if (ch < 0x100 && IS_CHAR(ch, B_NUM))
 			synth_printf("%s ", spk_msg_get(MSG_NUMBER));
 		speak_char(ch);
 	}
@@ -551,42 +556,42 @@ static void say_next_char(struct vc_data *vc)
 static u_long get_word(struct vc_data *vc)
 {
 	u_long cnt = 0, tmpx = spk_x, tmp_pos = spk_pos;
-	char ch;
-	u_short attr_ch;
+	u16 ch;
+	u16 attr_ch;
 	u_char temp;
 
 	spk_old_attr = spk_attr;
-	ch = (char)get_char(vc, (u_short *)tmp_pos, &temp);
+	ch = get_char(vc, (u_short *)tmp_pos, &temp);
 
 /* decided to take out the sayword if on a space (mis-information */
 	if (spk_say_word_ctl && ch == SPACE) {
 		*buf = '\0';
 		synth_printf("%s\n", spk_msg_get(MSG_SPACE));
 		return 0;
-	} else if ((tmpx < vc->vc_cols - 2)
-		   && (ch == SPACE || ch == 0 || IS_WDLM(ch))
-		   && ((char)get_char(vc, (u_short *)&tmp_pos + 1, &temp) >
-		       SPACE)) {
+	} else if (tmpx < vc->vc_cols - 2 &&
+		   (ch == SPACE || ch == 0 || (ch < 0x100 && IS_WDLM(ch))) &&
+		   get_char(vc, (u_short *)&tmp_pos + 1, &temp) > SPACE) {
 		tmp_pos += 2;
 		tmpx++;
 	} else
 		while (tmpx > 0) {
-			ch = (char)get_char(vc, (u_short *)tmp_pos - 1, &temp);
-			if ((ch == SPACE || ch == 0 || IS_WDLM(ch))
-			    && ((char)get_char(vc, (u_short *)tmp_pos, &temp) >
-				SPACE))
+			ch = get_char(vc, (u_short *)tmp_pos - 1, &temp);
+			if ((ch == SPACE || ch == 0 ||
+			     (ch < 0x100 && IS_WDLM(ch))) &&
+			    get_char(vc, (u_short *)tmp_pos, &temp) > SPACE)
 				break;
 			tmp_pos -= 2;
 			tmpx--;
 		}
 	attr_ch = get_char(vc, (u_short *)tmp_pos, &spk_attr);
-	buf[cnt++] = attr_ch & 0xff;
+	buf[cnt++] = attr_ch;
 	while (tmpx < vc->vc_cols - 1) {
 		tmp_pos += 2;
 		tmpx++;
-		ch = (char)get_char(vc, (u_short *)tmp_pos, &temp);
-		if ((ch == SPACE) || ch == 0
-		    || (IS_WDLM(buf[cnt - 1]) && (ch > SPACE)))
+		ch = get_char(vc, (u_short *)tmp_pos, &temp);
+		if (ch == SPACE || ch == 0 ||
+		    (buf[cnt - 1] < 0x100 && IS_WDLM(buf[cnt - 1]) &&
+		     ch > SPACE))
 			break;
 		buf[cnt++] = ch;
 	}
@@ -610,7 +615,7 @@ static void say_word(struct vc_data *vc)
 static void say_prev_word(struct vc_data *vc)
 {
 	u_char temp;
-	char ch;
+	u16 ch;
 	u_short edge_said = 0, last_state = 0, state = 0;
 
 	spk_parked |= 0x01;
@@ -639,10 +644,10 @@ static void say_prev_word(struct vc_data *vc)
 		} else
 			spk_x--;
 		spk_pos -= 2;
-		ch = (char)get_char(vc, (u_short *)spk_pos, &temp);
+		ch = get_char(vc, (u_short *)spk_pos, &temp);
 		if (ch == SPACE || ch == 0)
 			state = 0;
-		else if (IS_WDLM(ch))
+		else if (ch < 0x100 && IS_WDLM(ch))
 			state = 1;
 		else
 			state = 2;
@@ -663,7 +668,7 @@ static void say_prev_word(struct vc_data *vc)
 static void say_next_word(struct vc_data *vc)
 {
 	u_char temp;
-	char ch;
+	u16 ch;
 	u_short edge_said = 0, last_state = 2, state = 0;
 
 	spk_parked |= 0x01;
@@ -672,10 +677,10 @@ static void say_next_word(struct vc_data *vc)
 		return;
 	}
 	while (1) {
-		ch = (char)get_char(vc, (u_short *)spk_pos, &temp);
+		ch = get_char(vc, (u_short *)spk_pos, &temp);
 		if (ch == SPACE || ch == 0)
 			state = 0;
-		else if (IS_WDLM(ch))
+		else if (ch < 0x100 && IS_WDLM(ch))
 			state = 1;
 		else
 			state = 2;
@@ -703,13 +708,18 @@ static void say_next_word(struct vc_data *vc)
 static void spell_word(struct vc_data *vc)
 {
 	static char const *delay_str[] = { "", ",", ".", ". .", ". . ." };
-	char *cp = buf, *str_cap = spk_str_caps_stop;
-	char *cp1, *last_cap = spk_str_caps_stop;
-	u_char ch;
+	u16 *cp = buf;
+	char *cp1;
+	char *str_cap = spk_str_caps_stop;
+	char *last_cap = spk_str_caps_stop;
+	u16 ch;
 
 	if (!get_word(vc))
 		return;
-	while ((ch = (u_char)*cp)) {
+	while ((ch = *cp)) {
+		if (ch >= 0x100)
+			/* FIXME */
+			continue;
 		if (cp != buf)
 			synth_printf(" %s ", delay_str[spk_spell_delay]);
 		if (IS_CHAR(ch, B_CAP)) {
@@ -724,9 +734,9 @@ static void spell_word(struct vc_data *vc)
 			synth_printf("%s", str_cap);
 			last_cap = str_cap;
 		}
-		if (this_speakup_key == SPELL_PHONETIC
-		    && (isascii(ch) && isalpha(ch))) {
-			ch &= 31;
+		if (this_speakup_key == SPELL_PHONETIC &&
+		    ch <= 0x7f && isalpha(ch)) {
+			ch &= 0x1f;
 			cp1 = phonetic[--ch];
 		} else {
 			cp1 = spk_characters[ch];
@@ -751,7 +761,7 @@ static int get_line(struct vc_data *vc)
 	spk_old_attr = spk_attr;
 	spk_attr = get_attributes(vc, (u_short *)spk_pos);
 	for (i = 0; i < vc->vc_cols; i++) {
-		buf[i] = (u_char)get_char(vc, (u_short *)tmp, &tmp2);
+		buf[i] = get_char(vc, (u_short *)tmp, &tmp2);
 		tmp += 2;
 	}
 	for (--i; i >= 0; i--)
@@ -763,7 +773,7 @@ static int get_line(struct vc_data *vc)
 static void say_line(struct vc_data *vc)
 {
 	int i = get_line(vc);
-	char *cp;
+	u16 *cp;
 	u_short saved_punc_mask = spk_punc_mask;
 
 	if (i == 0) {
@@ -816,7 +826,7 @@ static int say_from_to(struct vc_data *vc, u_long from, u_long to,
 	spk_old_attr = spk_attr;
 	spk_attr = get_attributes(vc, (u_short *)from);
 	while (from < to) {
-		buf[i++] = (char)get_char(vc, (u_short *)from, &tmp);
+		buf[i++] = get_char(vc, (u_short *)from, &tmp);
 		from += 2;
 		if (i >= vc->vc_size_row)
 			break;
@@ -852,11 +862,11 @@ static void say_line_from_to(struct vc_data *vc, u_long from, u_long to,
 
 static int currsentence;
 static int numsentences[2];
-static char *sentbufend[2];
-static char *sentmarks[2][10];
+static u16 *sentbufend[2];
+static u16 *sentmarks[2][10];
 static int currbuf;
 static int bn;
-static char sentbuf[2][256];
+static u16 sentbuf[2][256];
 
 static int say_sentence_num(int num, int prev)
 {
@@ -892,7 +902,7 @@ static int get_sentence_buf(struct vc_data *vc, int read_punc)
 	spk_attr = get_attributes(vc, (u_short *)start);
 
 	while (start < end) {
-		sentbuf[bn][i] = (char)get_char(vc, (u_short *)start, &tmp);
+		sentbuf[bn][i] = get_char(vc, (u_short *)start, &tmp);
 		if (i > 0) {
 			if (sentbuf[bn][i] == SPACE && sentbuf[bn][i - 1] == '.'
 			    && numsentences[bn] < 9) {
@@ -995,7 +1005,7 @@ static void right_edge(struct vc_data *vc)
 static void say_first_char(struct vc_data *vc)
 {
 	int i, len = get_line(vc);
-	u_char ch;
+	u16 ch;
 
 	spk_parked |= 0x01;
 	if (len == 0) {
@@ -1015,7 +1025,7 @@ static void say_first_char(struct vc_data *vc)
 static void say_last_char(struct vc_data *vc)
 {
 	int len = get_line(vc);
-	u_char ch;
+	u16 ch;
 
 	spk_parked |= 0x01;
 	if (len == 0) {
@@ -1040,9 +1050,8 @@ static void say_position(struct vc_data *vc)
 static void say_char_num(struct vc_data *vc)
 {
 	u_char tmp;
-	u_short ch = get_char(vc, (u_short *)spk_pos, &tmp);
+	u16 ch = get_char(vc, (u_short *)spk_pos, &tmp);
 
-	ch &= 0xff;
 	synth_printf(spk_msg_get(MSG_CHAR_INFO), ch, ch);
 }
 
@@ -1070,10 +1079,10 @@ static void say_to_right(struct vc_data *vc)
 
 /* end of stub functions. */
 
-static void spkup_write(const char *in_buf, int count)
+static void spkup_write(const u16 *in_buf, int count)
 {
 	static int rep_count;
-	static u_char ch = '\0', old_ch = '\0';
+	static u16 ch = '\0', old_ch = '\0';
 	static u_short char_type, last_type;
 	int in_count = count;
 
@@ -1085,8 +1094,11 @@ static void spkup_write(const char *in_buf, int count)
 			    (currsentence <= numsentences[bn]))
 				synth_insert_next_index(currsentence++);
 		}
-		ch = (u_char)*in_buf++;
-		char_type = spk_chartab[ch];
+		ch = *in_buf++;
+		if (ch < 0x100)
+			char_type = spk_chartab[ch];
+		else
+			char_type = ALPHA;
 		if (ch == old_ch && !(char_type & B_NUM)) {
 			if (++rep_count > 2)
 				continue;
@@ -1106,10 +1118,10 @@ static void spkup_write(const char *in_buf, int count)
 		} else if (char_type & B_ALPHA) {
 			if ((synth_flags & SF_DEC) && (last_type & PUNC))
 				synth_buffer_add(SPACE);
-			synth_printf("%c", ch);
+			synth_putwc_s(ch);
 		} else if (char_type & B_NUM) {
 			rep_count = 0;
-			synth_printf("%c", ch);
+			synth_putwc_s(ch);
 		} else if (char_type & spk_punc_mask) {
 			speak_char(ch);
 			char_type &= ~PUNC;	/* for dec nospell processing */
@@ -1122,7 +1134,7 @@ static void spkup_write(const char *in_buf, int count)
 			 * repeats on you don't get nothing repeated count
 			 */
 			if (ch != old_ch)
-				synth_printf("%c", ch);
+				synth_putwc_s(ch);
 			else
 				rep_count = 0;
 		} else {
@@ -1533,7 +1545,7 @@ static void do_handle_cursor(struct vc_data *vc, u_char value, char up_flag)
 	spin_unlock_irqrestore(&speakup_info.spinlock, flags);
 }
 
-static void update_color_buffer(struct vc_data *vc, const char *ic, int len)
+static void update_color_buffer(struct vc_data *vc, const u16 *ic, int len)
 {
 	int i, bi, hi;
 	int vc_num = vc->vc_num;
@@ -1548,7 +1560,7 @@ static void update_color_buffer(struct vc_data *vc, const char *ic, int len)
 		speakup_console[vc_num]->ht.ry[bi] = vc->vc_y;
 	}
 	while ((hi < COLOR_BUFFER_SIZE) && (i < len)) {
-		if ((ic[i] > 32) && (ic[i] < 127)) {
+		if (ic[i] > 32) {
 			speakup_console[vc_num]->ht.highbuf[bi][hi] = ic[i];
 			hi++;
 		} else if ((ic[i] == 32) && (hi != 0)) {
@@ -1718,7 +1730,7 @@ static void speakup_bs(struct vc_data *vc)
 }
 
 /* called by: vt_notifier_call() */
-static void speakup_con_write(struct vc_data *vc, const char *str, int len)
+static void speakup_con_write(struct vc_data *vc, u16 *str, int len)
 {
 	unsigned long flags;
 
@@ -1908,6 +1920,7 @@ static int handle_goto(struct vc_data *vc, u_char type, u_char ch, u_short key)
 	static int num;
 	int maxlen;
 	char *cp;
+	u16 wch;
 
 	if (type == KT_SPKUP && ch == SPEAKUP_GOTO)
 		goto do_goto;
@@ -1916,18 +1929,20 @@ static int handle_goto(struct vc_data *vc, u_char type, u_char ch, u_short key)
 	if (type != 0)
 		goto oops;
 	if (ch == 8) {
+		u16 wch;
 		if (num == 0)
 			return -1;
-		ch = goto_buf[--num];
+		wch = goto_buf[--num];
 		goto_buf[num] = '\0';
-		spkup_write(&ch, 1);
+		spkup_write(&wch, 1);
 		return 1;
 	}
 	if (ch < '+' || ch > 'y')
 		goto oops;
+	wch = ch;
 	goto_buf[num++] = ch;
 	goto_buf[num] = '\0';
-	spkup_write(&ch, 1);
+	spkup_write(&wch, 1);
 	maxlen = (*goto_buf >= '0') ? 3 : 4;
 	if ((ch == '+' || ch == '-') && num == 1)
 		return 1;
@@ -2254,9 +2269,8 @@ static int vt_notifier_call(struct notifier_block *nb,
 	case VT_WRITE:
 		if (param->c == '\b')
 			speakup_bs(vc);
-		else if (param->c < 0x100) {
-			char d = param->c;
-
+		else {
+			u16 d = param->c;
 			speakup_con_write(vc, &d, 1);
 		}
 		break;

commit 4be4c379299e47ca00768f67ae47515ac74af3bd
Author: simran singhal <singhalsimran0@gmail.com>
Date:   Sat Mar 4 22:16:54 2017 +0530

    staging: speakup: Clean up tests if NULL returned on failure
    
    Some functions like kmalloc/kzalloc return NULL on failure.
    When NULL represents failure, !x is commonly used.
    
    This was done using Coccinelle:
    @@
    expression *e;
    identifier l1;
    @@
    
    e = \(kmalloc\|kzalloc\|kcalloc\|devm_kzalloc\)(...);
    ...
    - e == NULL
    + !e
    
    Signed-off-by: simran singhal <singhalsimran0@gmail.com>
    Acked-by: Julia Lawall <julia.lawall@lip6.fr>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/speakup/main.c b/drivers/staging/speakup/main.c
index 5c174c98f108..96e25eb631b5 100644
--- a/drivers/staging/speakup/main.c
+++ b/drivers/staging/speakup/main.c
@@ -1324,7 +1324,7 @@ static int speakup_allocate(struct vc_data *vc)
 	if (speakup_console[vc_num] == NULL) {
 		speakup_console[vc_num] = kzalloc(sizeof(*speakup_console[0]),
 						  GFP_ATOMIC);
-		if (speakup_console[vc_num] == NULL)
+		if (!speakup_console[vc_num])
 			return -ENOMEM;
 		speakup_date(vc);
 	} else if (!spk_parked)

commit ae8784fcdc9bd3137fe65d6247129a19cab520b5
Author: Joe Perches <joe@perches.com>
Date:   Sat Mar 4 08:13:11 2017 -0800

    staging: speakup: Add __printf format/arg verification, fix fallout
    
    Using __printf allows the compiler to verify formats and arguments.
    Use it and fix the single misuse found.
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/speakup/main.c b/drivers/staging/speakup/main.c
index c2f70ef5b9b3..5c174c98f108 100644
--- a/drivers/staging/speakup/main.c
+++ b/drivers/staging/speakup/main.c
@@ -775,7 +775,7 @@ static void say_line(struct vc_data *vc)
 		cp = buf;
 		while (*cp == SPACE)
 			cp++;
-		synth_printf("%d, ", (cp - buf) + 1);
+		synth_printf("%zd, ", (cp - buf) + 1);
 	}
 	spk_punc_mask = spk_punc_masks[spk_reading_punc];
 	spkup_write(buf, i);

commit 4d0bdcb10c43056489b69186ee43669f2a73b8f9
Author: Arushi Singhal <arushisinghal19971997@gmail.com>
Date:   Sun Feb 12 16:15:58 2017 +0530

    staging: rtl8192e: Aligning the * on each line in block comments
    
    This patch fixes the issue by aligning the * on each line in block
    comments.
    
    Signed-off-by: Arushi Singhal <arushisinghal19971997@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/speakup/main.c b/drivers/staging/speakup/main.c
index bccccf539d38..c2f70ef5b9b3 100644
--- a/drivers/staging/speakup/main.c
+++ b/drivers/staging/speakup/main.c
@@ -16,7 +16,7 @@
  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  *  GNU General Public License for more details.
-*/
+ */
 
 #include <linux/kernel.h>
 #include <linux/vt.h>

commit 73c3700e86ab1d82b62b43ec24d12777e06935af
Author: Derek Robson <robsonde@gmail.com>
Date:   Sat Jan 28 19:35:01 2017 +1300

    Staging: speakup - syle fix permissions to octal
    
    A style fix across whole driver.
    changed permissions to octal style, found using checkpatch
    
    Signed-off-by: Derek Robson <robsonde@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/speakup/main.c b/drivers/staging/speakup/main.c
index 5c192042eeac..bccccf539d38 100644
--- a/drivers/staging/speakup/main.c
+++ b/drivers/staging/speakup/main.c
@@ -58,8 +58,8 @@ MODULE_LICENSE("GPL");
 MODULE_VERSION(SPEAKUP_VERSION);
 
 char *synth_name;
-module_param_named(synth, synth_name, charp, S_IRUGO);
-module_param_named(quiet, spk_quiet_boot, bool, S_IRUGO);
+module_param_named(synth, synth_name, charp, 0444);
+module_param_named(quiet, spk_quiet_boot, bool, 0444);
 
 MODULE_PARM_DESC(synth, "Synth to start if speakup is built in.");
 MODULE_PARM_DESC(quiet, "Do not announce when the synthesizer is found.");

commit d290effe7e47a15b65e8532dae48fc2d49047982
Author: Shiva Kerdel <shiva@exdev.nl>
Date:   Sun Nov 6 15:09:18 2016 +0100

    Staging: speakup: Remove unnecessary space after cast
    
    The affected files have been modified to remove redundant spaces after
    casts to solve checkpatch.pl checks.
    
    Signed-off-by: Shiva Kerdel <shiva@exdev.nl>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/speakup/main.c b/drivers/staging/speakup/main.c
index 97ca4ecca8a9..5c192042eeac 100644
--- a/drivers/staging/speakup/main.c
+++ b/drivers/staging/speakup/main.c
@@ -351,14 +351,14 @@ static void speakup_cut(struct vc_data *vc)
 
 	if (!mark_cut_flag) {
 		mark_cut_flag = 1;
-		spk_xs = (u_short) spk_x;
-		spk_ys = (u_short) spk_y;
+		spk_xs = (u_short)spk_x;
+		spk_ys = (u_short)spk_y;
 		spk_sel_cons = vc;
 		synth_printf("%s\n", spk_msg_get(MSG_MARK));
 		return;
 	}
-	spk_xe = (u_short) spk_x;
-	spk_ye = (u_short) spk_y;
+	spk_xe = (u_short)spk_x;
+	spk_ye = (u_short)spk_y;
 	mark_cut_flag = 0;
 	synth_printf("%s\n", spk_msg_get(MSG_CUT));
 
@@ -489,7 +489,7 @@ static void say_char(struct vc_data *vc)
 	u_short ch;
 
 	spk_old_attr = spk_attr;
-	ch = get_char(vc, (u_short *) spk_pos, &spk_attr);
+	ch = get_char(vc, (u_short *)spk_pos, &spk_attr);
 	if (spk_attr != spk_old_attr) {
 		if (spk_attrib_bleep & 1)
 			bleep(spk_y);
@@ -504,7 +504,7 @@ static void say_phonetic_char(struct vc_data *vc)
 	u_short ch;
 
 	spk_old_attr = spk_attr;
-	ch = get_char(vc, (u_short *) spk_pos, &spk_attr);
+	ch = get_char(vc, (u_short *)spk_pos, &spk_attr);
 	if (isascii(ch) && isalpha(ch)) {
 		ch &= 0x1f;
 		synth_printf("%s\n", phonetic[--ch]);
@@ -556,7 +556,7 @@ static u_long get_word(struct vc_data *vc)
 	u_char temp;
 
 	spk_old_attr = spk_attr;
-	ch = (char)get_char(vc, (u_short *) tmp_pos, &temp);
+	ch = (char)get_char(vc, (u_short *)tmp_pos, &temp);
 
 /* decided to take out the sayword if on a space (mis-information */
 	if (spk_say_word_ctl && ch == SPACE) {
@@ -565,26 +565,26 @@ static u_long get_word(struct vc_data *vc)
 		return 0;
 	} else if ((tmpx < vc->vc_cols - 2)
 		   && (ch == SPACE || ch == 0 || IS_WDLM(ch))
-		   && ((char)get_char(vc, (u_short *) &tmp_pos + 1, &temp) >
+		   && ((char)get_char(vc, (u_short *)&tmp_pos + 1, &temp) >
 		       SPACE)) {
 		tmp_pos += 2;
 		tmpx++;
 	} else
 		while (tmpx > 0) {
-			ch = (char)get_char(vc, (u_short *) tmp_pos - 1, &temp);
+			ch = (char)get_char(vc, (u_short *)tmp_pos - 1, &temp);
 			if ((ch == SPACE || ch == 0 || IS_WDLM(ch))
-			    && ((char)get_char(vc, (u_short *) tmp_pos, &temp) >
+			    && ((char)get_char(vc, (u_short *)tmp_pos, &temp) >
 				SPACE))
 				break;
 			tmp_pos -= 2;
 			tmpx--;
 		}
-	attr_ch = get_char(vc, (u_short *) tmp_pos, &spk_attr);
+	attr_ch = get_char(vc, (u_short *)tmp_pos, &spk_attr);
 	buf[cnt++] = attr_ch & 0xff;
 	while (tmpx < vc->vc_cols - 1) {
 		tmp_pos += 2;
 		tmpx++;
-		ch = (char)get_char(vc, (u_short *) tmp_pos, &temp);
+		ch = (char)get_char(vc, (u_short *)tmp_pos, &temp);
 		if ((ch == SPACE) || ch == 0
 		    || (IS_WDLM(buf[cnt - 1]) && (ch > SPACE)))
 			break;
@@ -639,7 +639,7 @@ static void say_prev_word(struct vc_data *vc)
 		} else
 			spk_x--;
 		spk_pos -= 2;
-		ch = (char)get_char(vc, (u_short *) spk_pos, &temp);
+		ch = (char)get_char(vc, (u_short *)spk_pos, &temp);
 		if (ch == SPACE || ch == 0)
 			state = 0;
 		else if (IS_WDLM(ch))
@@ -672,7 +672,7 @@ static void say_next_word(struct vc_data *vc)
 		return;
 	}
 	while (1) {
-		ch = (char)get_char(vc, (u_short *) spk_pos, &temp);
+		ch = (char)get_char(vc, (u_short *)spk_pos, &temp);
 		if (ch == SPACE || ch == 0)
 			state = 0;
 		else if (IS_WDLM(ch))
@@ -709,7 +709,7 @@ static void spell_word(struct vc_data *vc)
 
 	if (!get_word(vc))
 		return;
-	while ((ch = (u_char) *cp)) {
+	while ((ch = (u_char)*cp)) {
 		if (cp != buf)
 			synth_printf(" %s ", delay_str[spk_spell_delay]);
 		if (IS_CHAR(ch, B_CAP)) {
@@ -751,7 +751,7 @@ static int get_line(struct vc_data *vc)
 	spk_old_attr = spk_attr;
 	spk_attr = get_attributes(vc, (u_short *)spk_pos);
 	for (i = 0; i < vc->vc_cols; i++) {
-		buf[i] = (u_char) get_char(vc, (u_short *) tmp, &tmp2);
+		buf[i] = (u_char)get_char(vc, (u_short *)tmp, &tmp2);
 		tmp += 2;
 	}
 	for (--i; i >= 0; i--)
@@ -816,7 +816,7 @@ static int say_from_to(struct vc_data *vc, u_long from, u_long to,
 	spk_old_attr = spk_attr;
 	spk_attr = get_attributes(vc, (u_short *)from);
 	while (from < to) {
-		buf[i++] = (char)get_char(vc, (u_short *) from, &tmp);
+		buf[i++] = (char)get_char(vc, (u_short *)from, &tmp);
 		from += 2;
 		if (i >= vc->vc_size_row)
 			break;
@@ -892,7 +892,7 @@ static int get_sentence_buf(struct vc_data *vc, int read_punc)
 	spk_attr = get_attributes(vc, (u_short *)start);
 
 	while (start < end) {
-		sentbuf[bn][i] = (char)get_char(vc, (u_short *) start, &tmp);
+		sentbuf[bn][i] = (char)get_char(vc, (u_short *)start, &tmp);
 		if (i > 0) {
 			if (sentbuf[bn][i] == SPACE && sentbuf[bn][i - 1] == '.'
 			    && numsentences[bn] < 9) {
@@ -1040,7 +1040,7 @@ static void say_position(struct vc_data *vc)
 static void say_char_num(struct vc_data *vc)
 {
 	u_char tmp;
-	u_short ch = get_char(vc, (u_short *) spk_pos, &tmp);
+	u_short ch = get_char(vc, (u_short *)spk_pos, &tmp);
 
 	ch &= 0xff;
 	synth_printf(spk_msg_get(MSG_CHAR_INFO), ch, ch);
@@ -1085,7 +1085,7 @@ static void spkup_write(const char *in_buf, int count)
 			    (currsentence <= numsentences[bn]))
 				synth_insert_next_index(currsentence++);
 		}
-		ch = (u_char) *in_buf++;
+		ch = (u_char)*in_buf++;
 		char_type = spk_chartab[ch];
 		if (ch == old_ch && !(char_type & B_NUM)) {
 			if (++rep_count > 2)
@@ -1579,7 +1579,7 @@ static int count_highlight_color(struct vc_data *vc)
 	int cc;
 	int vc_num = vc->vc_num;
 	u16 ch;
-	u16 *start = (u16 *) vc->vc_origin;
+	u16 *start = (u16 *)vc->vc_origin;
 
 	for (i = 0; i < 8; i++)
 		speakup_console[vc_num]->ht.bgcount[i] = 0;

commit 779bee40b907de23771bb8eaf334b81be53018b1
Author: Samuel Thibault <samuel.thibault@ens-lyon.org>
Date:   Tue Mar 15 21:34:59 2016 +0100

    Staging: speakup: Clear hi font bit from attributes
    
    Previously, speakup would see the hi-font bit in attributes.
    Since this bit has nothing to do with attributes, we need to clear it.
    
    Signed-off-by: Samuel Thibault <samuel.thibault@ens-lyon.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/speakup/main.c b/drivers/staging/speakup/main.c
index a22fb07512a1..97ca4ecca8a9 100644
--- a/drivers/staging/speakup/main.c
+++ b/drivers/staging/speakup/main.c
@@ -263,7 +263,7 @@ static struct notifier_block vt_notifier_block = {
 static unsigned char get_attributes(struct vc_data *vc, u16 *pos)
 {
 	pos = screen_pos(vc, pos - (u16 *)vc->vc_origin, 1);
-	return (u_char) (scr_readw(pos) >> 8);
+	return (scr_readw(pos) & ~vc->vc_hi_font_mask) >> 8;
 }
 
 static void speakup_date(struct vc_data *vc)
@@ -473,8 +473,10 @@ static u16 get_char(struct vc_data *vc, u16 *pos, u_char *attribs)
 		w = scr_readw(pos);
 		c = w & 0xff;
 
-		if (w & vc->vc_hi_font_mask)
+		if (w & vc->vc_hi_font_mask) {
+			w &= ~vc->vc_hi_font_mask;
 			c |= 0x100;
+		}
 
 		ch = inverse_translate(vc, c, 0);
 		*attribs = (w & 0xff00) >> 8;

commit c943e13bd2bf4c344c3fe43ef39f07b57eff715e
Author: Amitoj Kaur Chawla <amitoj1606@gmail.com>
Date:   Sun Mar 6 06:45:07 2016 +0530

    staging: speakup: Replace del_timer with del_timer_sync
    
    Use del_timer_sync to ensure timer is stopped on all CPUs before
    the driver exists and the timer should not run when the module is
    being removed. Since the timer is not called from an interrupt
    context, this change is safe and will not cause deadlock.
    
    The Coccinelle semantic patch used to make this change is as
    follows:
    // <smpl>
    @r@
    declarer name module_exit;
    identifier ex;
    @@
    
    module_exit(ex);
    
    @@
    identifier r.ex;
    @@
    
    ex(...) {
      <...
    - del_timer
    + del_timer_sync
        (...)
      ...>
    }
    // </smpl>
    
    Signed-off-by: Amitoj Kaur Chawla <amitoj1606@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/speakup/main.c b/drivers/staging/speakup/main.c
index a87224c5510b..a22fb07512a1 100644
--- a/drivers/staging/speakup/main.c
+++ b/drivers/staging/speakup/main.c
@@ -2274,7 +2274,7 @@ static void __exit speakup_exit(void)
 	unregister_vt_notifier(&vt_notifier_block);
 	speakup_unregister_devsynth();
 	speakup_cancel_paste();
-	del_timer(&cursor_timer);
+	del_timer_sync(&cursor_timer);
 	kthread_stop(speakup_task);
 	speakup_task = NULL;
 	mutex_lock(&spk_mutex);

commit cd95ed989a5dee1bdbbdfe46659d274026f31bb4
Author: Alison Schofield <amsfield22@gmail.com>
Date:   Tue Feb 23 21:38:58 2016 -0800

    staging: speakup: remove multiple assignments
    
    Remove multiple assignments by factorizing.
    
    Coccinelle semantic patch used:
    @@ identifier x,y; constant z; @@
    - x=y=z;
    + x=z;
    + y=z;
    
    Signed-off-by: Alison Schofield <amsfield22@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/speakup/main.c b/drivers/staging/speakup/main.c
index eb8d65a96eb5..a87224c5510b 100644
--- a/drivers/staging/speakup/main.c
+++ b/drivers/staging/speakup/main.c
@@ -1188,7 +1188,8 @@ static void do_handle_latin(struct vc_data *vc, u_char value, char up_flag)
 
 	spin_lock_irqsave(&speakup_info.spinlock, flags);
 	if (up_flag) {
-		spk_lastkey = spk_keydown = 0;
+		spk_lastkey = 0;
+		spk_keydown = 0;
 		spin_unlock_irqrestore(&speakup_info.spinlock, flags);
 		return;
 	}
@@ -1662,7 +1663,8 @@ static void cursor_done(u_long data)
 	if (win_enabled) {
 		if (vc->vc_x >= win_left && vc->vc_x <= win_right &&
 		    vc->vc_y >= win_top && vc->vc_y <= win_bottom) {
-			spk_keydown = is_cursor = 0;
+			spk_keydown = 0;
+			is_cursor = 0;
 			goto out;
 		}
 	}
@@ -1672,7 +1674,8 @@ static void cursor_done(u_long data)
 	}
 	if (cursor_track == CT_Highlight) {
 		if (speak_highlight(vc)) {
-			spk_keydown = is_cursor = 0;
+			spk_keydown = 0;
+			is_cursor = 0;
 			goto out;
 		}
 	}
@@ -1682,7 +1685,8 @@ static void cursor_done(u_long data)
 		say_line_from_to(vc, 0, vc->vc_cols, 0);
 	else
 		say_char(vc);
-	spk_keydown = is_cursor = 0;
+	spk_keydown = 0;
+	is_cursor = 0;
 out:
 	spin_unlock_irqrestore(&speakup_info.spinlock, flags);
 }
@@ -1862,8 +1866,10 @@ static void speakup_win_set(struct vc_data *vc)
 
 static void speakup_win_clear(struct vc_data *vc)
 {
-	win_top = win_bottom = 0;
-	win_left = win_right = 0;
+	win_top = 0;
+	win_bottom = 0;
+	win_left = 0;
+	win_right = 0;
 	win_start = 0;
 	synth_printf("%s\n", spk_msg_get(MSG_WINDOW_CLEARED));
 }
@@ -1998,10 +2004,13 @@ static u_char key_speakup, spk_key_locked;
 
 static void speakup_lock(struct vc_data *vc)
 {
-	if (!spk_key_locked)
-		spk_key_locked = key_speakup = 16;
-	else
-		spk_key_locked = key_speakup = 0;
+	if (!spk_key_locked) {
+		spk_key_locked = 16;
+		key_speakup = 16;
+	} else {
+		spk_key_locked = 0;
+		key_speakup = 0;
+	}
 }
 
 typedef void (*spkup_hand) (struct vc_data *);

commit 4cff7adbebf4d25f662b13c6582b945d9d549e25
Merge: 7e3933df9874 36f90b0a2ddd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon Feb 1 12:50:26 2016 -0800

    Merge 4.5-rc2 into staging-next
    
    This fixes a merge issue with the panel driver, and picks up fixes in
    iio and other drivers that we want here.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 88867e3d0b7eea256c1cd432b0a3c7a21e8edf07
Author: Samuel Thibault <samuel.thibault@ens-lyon.org>
Date:   Mon Jan 25 01:32:08 2016 +0100

    Staging: speakup: fix read scrolled-back VT
    
    Previously, speakup would always read the non-scrolled part of the VT,
    even when the VT is scrolled back with shift-page.  This patch makes
    vt.c export screen_pos so that speakup can use it to properly access
    the content of the scrolled-back VT.
    
    This was tested with both vgacon and fbcon.
    
    Signed-off-by: Samuel Thibault <samuel.thibault@ens-lyon.org>
    Reviewed-by: Alan Cox <alan@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/speakup/main.c b/drivers/staging/speakup/main.c
index 63c59bc89b04..30cf973f326d 100644
--- a/drivers/staging/speakup/main.c
+++ b/drivers/staging/speakup/main.c
@@ -264,8 +264,9 @@ static struct notifier_block vt_notifier_block = {
 	.notifier_call = vt_notifier_call,
 };
 
-static unsigned char get_attributes(u16 *pos)
+static unsigned char get_attributes(struct vc_data *vc, u16 *pos)
 {
+	pos = screen_pos(vc, pos - (u16 *)vc->vc_origin, 1);
 	return (u_char) (scr_readw(pos) >> 8);
 }
 
@@ -275,7 +276,7 @@ static void speakup_date(struct vc_data *vc)
 	spk_y = spk_cy = vc->vc_y;
 	spk_pos = spk_cp = vc->vc_pos;
 	spk_old_attr = spk_attr;
-	spk_attr = get_attributes((u_short *) spk_pos);
+	spk_attr = get_attributes(vc, (u_short *)spk_pos);
 }
 
 static void bleep(u_short val)
@@ -469,8 +470,12 @@ static u16 get_char(struct vc_data *vc, u16 *pos, u_char *attribs)
 	u16 ch = ' ';
 
 	if (vc && pos) {
-		u16 w = scr_readw(pos);
-		u16 c = w & 0xff;
+		u16 w;
+		u16 c;
+
+		pos = screen_pos(vc, pos - (u16 *)vc->vc_origin, 1);
+		w = scr_readw(pos);
+		c = w & 0xff;
 
 		if (w & vc->vc_hi_font_mask)
 			c |= 0x100;
@@ -746,7 +751,7 @@ static int get_line(struct vc_data *vc)
 	u_char tmp2;
 
 	spk_old_attr = spk_attr;
-	spk_attr = get_attributes((u_short *) spk_pos);
+	spk_attr = get_attributes(vc, (u_short *)spk_pos);
 	for (i = 0; i < vc->vc_cols; i++) {
 		buf[i] = (u_char) get_char(vc, (u_short *) tmp, &tmp2);
 		tmp += 2;
@@ -811,7 +816,7 @@ static int say_from_to(struct vc_data *vc, u_long from, u_long to,
 	u_short saved_punc_mask = spk_punc_mask;
 
 	spk_old_attr = spk_attr;
-	spk_attr = get_attributes((u_short *) from);
+	spk_attr = get_attributes(vc, (u_short *)from);
 	while (from < to) {
 		buf[i++] = (char)get_char(vc, (u_short *) from, &tmp);
 		from += 2;
@@ -886,7 +891,7 @@ static int get_sentence_buf(struct vc_data *vc, int read_punc)
 	sentmarks[bn][0] = &sentbuf[bn][0];
 	i = 0;
 	spk_old_attr = spk_attr;
-	spk_attr = get_attributes((u_short *) start);
+	spk_attr = get_attributes(vc, (u_short *)start);
 
 	while (start < end) {
 		sentbuf[bn][i] = (char)get_char(vc, (u_short *) start, &tmp);
@@ -1585,7 +1590,7 @@ static int count_highlight_color(struct vc_data *vc)
 		u16 *ptr;
 
 		for (ptr = start; ptr < end; ptr++) {
-			ch = get_attributes(ptr);
+			ch = get_attributes(vc, ptr);
 			bg = (ch & 0x70) >> 4;
 			speakup_console[vc_num]->ht.bgcount[bg]++;
 		}

commit 5cb10d42de412c69dbf3f5670b3099037c35cc78
Author: Shraddha Barke <shraddha.6596@gmail.com>
Date:   Sun Dec 27 20:10:38 2015 +0530

    Staging: speakup: Remove FSF mailing address
    
    FSF mailing address is no longer required to be specified. Hence
    removed.
    Detected using checkpatch
    
    Signed-off-by: Shraddha Barke <shraddha.6596@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/speakup/main.c b/drivers/staging/speakup/main.c
index 63c59bc89b04..456f65043355 100644
--- a/drivers/staging/speakup/main.c
+++ b/drivers/staging/speakup/main.c
@@ -16,10 +16,6 @@
  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */
 
 #include <linux/kernel.h>

commit 13d825edd4441dd3453de58d1bd2ade44d5ad2ab
Author: Aleksei Fedotov <lexa@cfotr.com>
Date:   Fri Aug 14 22:34:37 2015 +0300

    staging: speakup: Fix warning reported by checkpatch
    
    This patch fixes the checkpatch.pl warnings:
    WARNING: Block comments use a trailing */ on a separate line
    WARNING: Block comments use * on subsequent lines
    
    Signed-off-by: Aleksey Fedotov <lexa@cfotr.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/speakup/main.c b/drivers/staging/speakup/main.c
index 6c4f9a1ed07f..63c59bc89b04 100644
--- a/drivers/staging/speakup/main.c
+++ b/drivers/staging/speakup/main.c
@@ -128,7 +128,8 @@ static char *phonetic[] = {
 
 /* array of 256 char pointers (one for each character description)
  * initialized to default_chars and user selectable via
- * /proc/speakup/characters */
+ * /proc/speakup/characters
+ */
 char *spk_characters[256];
 
 char *spk_default_chars[256] = {
@@ -194,7 +195,8 @@ char *spk_default_chars[256] = {
 
 /* array of 256 u_short (one for each character)
  * initialized to default_chartab and user selectable via
- * /sys/module/speakup/parameters/chartab */
+ * /sys/module/speakup/parameters/chartab
+ */
 u_short spk_chartab[256];
 
 static u_short default_chartab[256] = {
@@ -540,7 +542,8 @@ static void say_next_char(struct vc_data *vc)
  * see if there is a word starting on the next position to the right
  * and return that word if it exists.  If it does not exist it will
  * move left to the beginning of any previous word on the line or the
- * beginning off the line whichever comes first.. */
+ * beginning off the line whichever comes first..
+ */
 
 static u_long get_word(struct vc_data *vc)
 {
@@ -1113,7 +1116,8 @@ static void spkup_write(const char *in_buf, int count)
 			 * suppress multiple to get rid of long pauses and
 			 * clear repeat count
 			 * so if someone has
-			 * repeats on you don't get nothing repeated count */
+			 * repeats on you don't get nothing repeated count
+			 */
 			if (ch != old_ch)
 				synth_printf("%c", ch);
 			else
@@ -1509,7 +1513,8 @@ static void do_handle_cursor(struct vc_data *vc, u_char value, char up_flag)
 	if (spk_no_intr)
 		spk_do_flush();
 /* the key press flushes if !no_inter but we want to flush on cursor
- * moves regardless of no_inter state */
+ * moves regardless of no_inter state
+ */
 	is_cursor = value + 1;
 	old_cursor_pos = vc->vc_pos;
 	old_cursor_x = vc->vc_x;

commit 590aeb174ad41292322c12d4fe24885bc7f074e5
Author: Fabian Frederick <fabf@skynet.be>
Date:   Wed Jun 10 18:33:38 2015 +0200

    staging: speakup: use swap() in get_highlight_color()
    
    Use kernel.h macro definition.
    
    Thanks to Julia Lawall for Coccinelle scripting support.
    
    Signed-off-by: Fabian Frederick <fabf@skynet.be>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/speakup/main.c b/drivers/staging/speakup/main.c
index c955976414ee..6c4f9a1ed07f 100644
--- a/drivers/staging/speakup/main.c
+++ b/drivers/staging/speakup/main.c
@@ -1597,7 +1597,7 @@ static int count_highlight_color(struct vc_data *vc)
 static int get_highlight_color(struct vc_data *vc)
 {
 	int i, j;
-	unsigned int cptr[8], tmp;
+	unsigned int cptr[8];
 	int vc_num = vc->vc_num;
 
 	for (i = 0; i < 8; i++)
@@ -1606,11 +1606,8 @@ static int get_highlight_color(struct vc_data *vc)
 	for (i = 0; i < 7; i++)
 		for (j = i + 1; j < 8; j++)
 			if (speakup_console[vc_num]->ht.bgcount[cptr[i]] >
-			    speakup_console[vc_num]->ht.bgcount[cptr[j]]) {
-				tmp = cptr[i];
-				cptr[i] = cptr[j];
-				cptr[j] = tmp;
-			}
+			    speakup_console[vc_num]->ht.bgcount[cptr[j]])
+				swap(cptr[i], cptr[j]);
 
 	for (i = 0; i < 8; i++)
 		if (speakup_console[vc_num]->ht.bgcount[cptr[i]] != 0)

commit 63b8ebe44ab6bc812f849818250e49e9157c309c
Author: Shirish Gajera <gshirishfree@gmail.com>
Date:   Sat Mar 28 13:21:39 2015 -0700

    staging: speakup: Fix warning of line over 80 characters.
    
    This patch fixes the checkpatch.pl warning:
    WARNING: line over 80 characters
    
    All line over 80 characters in driver/staging/speakup/* are fixed.
    
    Signed-off-by: Shirish Gajera <gshirishfree@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/speakup/main.c b/drivers/staging/speakup/main.c
index 1249f910aed1..c955976414ee 100644
--- a/drivers/staging/speakup/main.c
+++ b/drivers/staging/speakup/main.c
@@ -423,7 +423,8 @@ static void announce_edge(struct vc_data *vc, int msg_id)
 	if (spk_bleeps & 1)
 		bleep(spk_y);
 	if ((spk_bleeps & 2) && (msg_id < edge_quiet))
-		synth_printf("%s\n", spk_msg_get(MSG_EDGE_MSGS_START + msg_id - 1));
+		synth_printf("%s\n",
+			spk_msg_get(MSG_EDGE_MSGS_START + msg_id - 1));
 }
 
 static void speak_char(u_char ch)
@@ -1131,7 +1132,8 @@ static void spkup_write(const char *in_buf, int count)
 	if (in_count > 2 && rep_count > 2) {
 		if (last_type & CH_RPT) {
 			synth_printf(" ");
-			synth_printf(spk_msg_get(MSG_REPEAT_DESC2), ++rep_count);
+			synth_printf(spk_msg_get(MSG_REPEAT_DESC2),
+					++rep_count);
 			synth_printf(" ");
 		}
 		rep_count = 0;
@@ -1847,7 +1849,8 @@ static void speakup_win_set(struct vc_data *vc)
 			win_right = spk_x;
 		}
 		snprintf(info, sizeof(info), spk_msg_get(MSG_WINDOW_BOUNDARY),
-			 (win_start) ? spk_msg_get(MSG_END) : spk_msg_get(MSG_START),
+			 (win_start) ?
+				spk_msg_get(MSG_END) : spk_msg_get(MSG_START),
 			 (int)spk_y + 1, (int)spk_x + 1);
 	}
 	synth_printf("%s\n", info);

commit 6de3f58bc32cc10516b286b26476d5aa65c6d1e5
Author: Aya Mahfouz <mahfouz.saif.elyazal@gmail.com>
Date:   Wed Mar 4 07:35:28 2015 +0200

    staging: speakup: remove extra parentheses around right bit shift operation
    
    Removes extra parentheses around bitwise right shift operation.
    The case handled is  when the resultant value is assigned to
    a variable. The issue was detected and resolved using the following
    coccinelle script:
    
    @@
    expression e, e1;
    constant c;
    @@
    
    e =
    -(e1
    +e1
    >>
    -c);
    +c;
    
    @@
    identifier i;
    constant c;
    type t;
    expression e;
    @@
    
    t i =
    -(e
    +e
    >>
    -c);
    +c;
    
    @@
    expression e, e1;
    identifier f;
    constant c;
    @@
    
    e1 = f(...,
    -(e
    +e
    >>
    -c)
    +c
    ,...);
    
    Signed-off-by: Aya Mahfouz <mahfouz.saif.elyazal@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/speakup/main.c b/drivers/staging/speakup/main.c
index e9f0c150d246..1249f910aed1 100644
--- a/drivers/staging/speakup/main.c
+++ b/drivers/staging/speakup/main.c
@@ -1527,7 +1527,7 @@ static void update_color_buffer(struct vc_data *vc, const char *ic, int len)
 	int i, bi, hi;
 	int vc_num = vc->vc_num;
 
-	bi = ((vc->vc_attr & 0x70) >> 4);
+	bi = (vc->vc_attr & 0x70) >> 4;
 	hi = speakup_console[vc_num]->ht.highsize[bi];
 
 	i = 0;

commit 0f709488c52c11abc36f7f9ba077f8232cb7cd9d
Author: Dilek Uzulmez <dilekuzulmez@gmail.com>
Date:   Tue Oct 7 10:59:18 2014 +0300

    staging: speakup: Change char * array type as static const
    
    This patch fixes "char * array declaration might be better as static
    const" checkpatch.pl warning in main.c
    
    Signed-off-by: Dilek Uzulmez <dilekuzulmez@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/speakup/main.c b/drivers/staging/speakup/main.c
index 3f30a1b6e72c..e9f0c150d246 100644
--- a/drivers/staging/speakup/main.c
+++ b/drivers/staging/speakup/main.c
@@ -695,7 +695,7 @@ static void say_next_word(struct vc_data *vc)
 
 static void spell_word(struct vc_data *vc)
 {
-	static char *delay_str[] = { "", ",", ".", ". .", ". . ." };
+	static char const *delay_str[] = { "", ",", ".", ". .", ". . ." };
 	char *cp = buf, *str_cap = spk_str_caps_stop;
 	char *cp1, *last_cap = spk_str_caps_stop;
 	u_char ch;

commit 0a3a725adb2c421ea79089ea12004a007fb371ce
Author: Roxana Blaj <roxanagabriela10@gmail.com>
Date:   Sun Sep 14 20:28:53 2014 +0300

    staging: speakup: fix checkpatch warning
    
    This fixes the cheackpatch warning:
    WARNING: Missing a blank line after declarations
    
    Signed-off-by: Roxana Blaj <roxanagabriela10@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/speakup/main.c b/drivers/staging/speakup/main.c
index 1cfff1648c60..3f30a1b6e72c 100644
--- a/drivers/staging/speakup/main.c
+++ b/drivers/staging/speakup/main.c
@@ -2239,6 +2239,7 @@ static int vt_notifier_call(struct notifier_block *nb,
 			speakup_bs(vc);
 		else if (param->c < 0x100) {
 			char d = param->c;
+
 			speakup_con_write(vc, &d, 1);
 		}
 		break;

commit 8e69a8110686572a4b88d006faa8c3c759c4c261
Author: Domagoj Trsan <domagoj.trsan@gmail.com>
Date:   Tue Sep 9 20:04:34 2014 +0200

    staging: speakup: fix missing blank lines after declarations
    
    Signed-off-by: Domagoj Trsan <domagoj.trsan@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/speakup/main.c b/drivers/staging/speakup/main.c
index d367bd08cb96..1cfff1648c60 100644
--- a/drivers/staging/speakup/main.c
+++ b/drivers/staging/speakup/main.c
@@ -283,6 +283,7 @@ static void bleep(u_short val)
 	};
 	short freq;
 	int time = spk_bleep_time;
+
 	freq = vals[val % 12];
 	if (val > 11)
 		freq *= (1 << (val / 12));
@@ -306,6 +307,7 @@ static void speakup_shut_up(struct vc_data *vc)
 static void speech_kill(struct vc_data *vc)
 {
 	char val = synth->is_alive(synth);
+
 	if (val == 0)
 		return;
 
@@ -394,6 +396,7 @@ static void say_attributes(struct vc_data *vc)
 {
 	int fg = spk_attr & 0x0f;
 	int bg = spk_attr >> 4;
+
 	if (fg > 8) {
 		synth_printf("%s ", spk_msg_get(MSG_BRIGHT));
 		fg -= 8;
@@ -427,6 +430,7 @@ static void speak_char(u_char ch)
 {
 	char *cp = spk_characters[ch];
 	struct var_t *direct = spk_get_var(DIRECT);
+
 	if (direct && direct->u.n.value) {
 		if (IS_CHAR(ch, B_CAP)) {
 			spk_pitch_shift++;
@@ -460,6 +464,7 @@ static void speak_char(u_char ch)
 static u16 get_char(struct vc_data *vc, u16 *pos, u_char *attribs)
 {
 	u16 ch = ' ';
+
 	if (vc && pos) {
 		u16 w = scr_readw(pos);
 		u16 c = w & 0xff;
@@ -476,6 +481,7 @@ static u16 get_char(struct vc_data *vc, u16 *pos, u_char *attribs)
 static void say_char(struct vc_data *vc)
 {
 	u_short ch;
+
 	spk_old_attr = spk_attr;
 	ch = get_char(vc, (u_short *) spk_pos, &spk_attr);
 	if (spk_attr != spk_old_attr) {
@@ -490,6 +496,7 @@ static void say_char(struct vc_data *vc)
 static void say_phonetic_char(struct vc_data *vc)
 {
 	u_short ch;
+
 	spk_old_attr = spk_attr;
 	ch = get_char(vc, (u_short *) spk_pos, &spk_attr);
 	if (isascii(ch) && isalpha(ch)) {
@@ -540,6 +547,7 @@ static u_long get_word(struct vc_data *vc)
 	char ch;
 	u_short attr_ch;
 	u_char temp;
+
 	spk_old_attr = spk_attr;
 	ch = (char)get_char(vc, (u_short *) tmp_pos, &temp);
 
@@ -583,6 +591,7 @@ static void say_word(struct vc_data *vc)
 {
 	u_long cnt = get_word(vc);
 	u_short saved_punc_mask = spk_punc_mask;
+
 	if (cnt == 0)
 		return;
 	spk_punc_mask = PUNC;
@@ -596,6 +605,7 @@ static void say_prev_word(struct vc_data *vc)
 	u_char temp;
 	char ch;
 	u_short edge_said = 0, last_state = 0, state = 0;
+
 	spk_parked |= 0x01;
 
 	if (spk_x == 0) {
@@ -648,8 +658,8 @@ static void say_next_word(struct vc_data *vc)
 	u_char temp;
 	char ch;
 	u_short edge_said = 0, last_state = 2, state = 0;
-	spk_parked |= 0x01;
 
+	spk_parked |= 0x01;
 	if (spk_x == vc->vc_cols - 1 && spk_y == vc->vc_rows - 1) {
 		announce_edge(vc, edge_bottom);
 		return;
@@ -689,6 +699,7 @@ static void spell_word(struct vc_data *vc)
 	char *cp = buf, *str_cap = spk_str_caps_stop;
 	char *cp1, *last_cap = spk_str_caps_stop;
 	u_char ch;
+
 	if (!get_word(vc))
 		return;
 	while ((ch = (u_char) *cp)) {
@@ -747,6 +758,7 @@ static void say_line(struct vc_data *vc)
 	int i = get_line(vc);
 	char *cp;
 	u_short saved_punc_mask = spk_punc_mask;
+
 	if (i == 0) {
 		synth_printf("%s\n", spk_msg_get(MSG_BLANK));
 		return;
@@ -793,6 +805,7 @@ static int say_from_to(struct vc_data *vc, u_long from, u_long to,
 	int i = 0;
 	u_char tmp;
 	u_short saved_punc_mask = spk_punc_mask;
+
 	spk_old_attr = spk_attr;
 	spk_attr = get_attributes((u_short *) from);
 	while (from < to) {
@@ -821,6 +834,7 @@ static void say_line_from_to(struct vc_data *vc, u_long from, u_long to,
 {
 	u_long start = vc->vc_origin + (spk_y * vc->vc_size_row);
 	u_long end = start + (to * 2);
+
 	start += from * 2;
 	if (say_from_to(vc, start, end, read_punc) <= 0)
 		if (cursor_track != read_all_mode)
@@ -904,6 +918,7 @@ static int get_sentence_buf(struct vc_data *vc, int read_punc)
 static void say_screen_from_to(struct vc_data *vc, u_long from, u_long to)
 {
 	u_long start = vc->vc_origin, end;
+
 	if (from > 0)
 		start += from * vc->vc_size_row;
 	if (to > vc->vc_rows)
@@ -923,6 +938,7 @@ static void say_screen(struct vc_data *vc)
 static void speakup_win_say(struct vc_data *vc)
 {
 	u_long start, end, from, to;
+
 	if (win_start < 2) {
 		synth_printf("%s\n", spk_msg_get(MSG_NO_WINDOW));
 		return;
@@ -973,6 +989,7 @@ static void say_first_char(struct vc_data *vc)
 {
 	int i, len = get_line(vc);
 	u_char ch;
+
 	spk_parked |= 0x01;
 	if (len == 0) {
 		synth_printf("%s\n", spk_msg_get(MSG_BLANK));
@@ -992,6 +1009,7 @@ static void say_last_char(struct vc_data *vc)
 {
 	int len = get_line(vc);
 	u_char ch;
+
 	spk_parked |= 0x01;
 	if (len == 0) {
 		synth_printf("%s\n", spk_msg_get(MSG_BLANK));
@@ -1016,6 +1034,7 @@ static void say_char_num(struct vc_data *vc)
 {
 	u_char tmp;
 	u_short ch = get_char(vc, (u_short *) spk_pos, &tmp);
+
 	ch &= 0xff;
 	synth_printf(spk_msg_get(MSG_CHAR_INFO), ch, ch);
 }
@@ -1050,6 +1069,7 @@ static void spkup_write(const char *in_buf, int count)
 	static u_char ch = '\0', old_ch = '\0';
 	static u_short char_type, last_type;
 	int in_count = count;
+
 	spk_keydown = 0;
 	while (count--) {
 		if (cursor_track == read_all_mode) {
@@ -1127,6 +1147,7 @@ static DEFINE_TIMER(cursor_timer, cursor_done, 0, 0);
 static void do_handle_shift(struct vc_data *vc, u_char value, char up_flag)
 {
 	unsigned long flags;
+
 	if (synth == NULL || up_flag || spk_killed)
 		return;
 	spin_lock_irqsave(&speakup_info.spinlock, flags);
@@ -1157,6 +1178,7 @@ static void do_handle_shift(struct vc_data *vc, u_char value, char up_flag)
 static void do_handle_latin(struct vc_data *vc, u_char value, char up_flag)
 {
 	unsigned long flags;
+
 	spin_lock_irqsave(&speakup_info.spinlock, flags);
 	if (up_flag) {
 		spk_lastkey = spk_keydown = 0;
@@ -1182,6 +1204,7 @@ int spk_set_key_info(const u_char *key_info, u_char *k_buffer)
 	const u_char *cp = key_info;
 	u_char *cp1 = k_buffer;
 	u_char ch, version, num_keys;
+
 	version = *cp++;
 	if (version != KEY_MAP_VER)
 		return -1;
@@ -1264,6 +1287,7 @@ static const struct st_bits_data *pb_edit;
 static int edit_bits(struct vc_data *vc, u_char type, u_char ch, u_short key)
 {
 	short mask = pb_edit->mask, ch_type = spk_chartab[ch];
+
 	if (type != KT_LATIN || (ch_type & B_NUM) || ch < SPACE)
 		return -1;
 	if (ch == SPACE) {
@@ -1449,6 +1473,7 @@ static void handle_cursor_read_all(struct vc_data *vc, int command)
 static int pre_handle_cursor(struct vc_data *vc, u_char value, char up_flag)
 {
 	unsigned long flags;
+
 	spin_lock_irqsave(&speakup_info.spinlock, flags);
 	if (cursor_track == read_all_mode) {
 		spk_parked &= 0xfe;
@@ -1532,6 +1557,7 @@ static void reset_highlight_buffers(struct vc_data *vc)
 {
 	int i;
 	int vc_num = vc->vc_num;
+
 	for (i = 0; i < 8; i++)
 		speakup_console[vc_num]->ht.highsize[i] = 0;
 }
@@ -1550,6 +1576,7 @@ static int count_highlight_color(struct vc_data *vc)
 	for (i = 0; i < vc->vc_rows; i++) {
 		u16 *end = start + vc->vc_cols * 2;
 		u16 *ptr;
+
 		for (ptr = start; ptr < end; ptr++) {
 			ch = get_attributes(ptr);
 			bg = (ch & 0x70) >> 4;
@@ -1594,6 +1621,7 @@ static int speak_highlight(struct vc_data *vc)
 {
 	int hc, d;
 	int vc_num = vc->vc_num;
+
 	if (count_highlight_color(vc) == 1)
 		return 0;
 	hc = get_highlight_color(vc);
@@ -1618,6 +1646,7 @@ static void cursor_done(u_long data)
 {
 	struct vc_data *vc = vc_cons[cursor_con].d;
 	unsigned long flags;
+
 	del_timer(&cursor_timer);
 	spin_lock_irqsave(&speakup_info.spinlock, flags);
 	if (cursor_con != fg_console) {
@@ -1657,6 +1686,7 @@ static void cursor_done(u_long data)
 static void speakup_bs(struct vc_data *vc)
 {
 	unsigned long flags;
+
 	if (!speakup_console[vc->vc_num])
 		return;
 	if (!spin_trylock_irqsave(&speakup_info.spinlock, flags))
@@ -1680,6 +1710,7 @@ static void speakup_bs(struct vc_data *vc)
 static void speakup_con_write(struct vc_data *vc, const char *str, int len)
 {
 	unsigned long flags;
+
 	if ((vc->vc_num != fg_console) || spk_shut_up || synth == NULL)
 		return;
 	if (!spin_trylock_irqsave(&speakup_info.spinlock, flags))
@@ -1708,6 +1739,7 @@ static void speakup_con_write(struct vc_data *vc, const char *str, int len)
 static void speakup_con_update(struct vc_data *vc)
 {
 	unsigned long flags;
+
 	if (speakup_console[vc->vc_num] == NULL || spk_parked)
 		return;
 	if (!spin_trylock_irqsave(&speakup_info.spinlock, flags))
@@ -1722,6 +1754,7 @@ static void do_handle_spec(struct vc_data *vc, u_char value, char up_flag)
 	unsigned long flags;
 	int on_off = 2;
 	char *label;
+
 	if (synth == NULL || up_flag || spk_killed)
 		return;
 	spin_lock_irqsave(&speakup_info.spinlock, flags);
@@ -1763,6 +1796,7 @@ static int inc_dec_var(u_char value)
 	char *pn;
 	int var_id = (int)value - VAR_START;
 	int how = (var_id & 1) ? E_INC : E_DEC;
+
 	var_id = var_id / 2 + FIRST_SET_VAR;
 	p_header = spk_get_var_header(var_id);
 	if (p_header == NULL)
@@ -1789,6 +1823,7 @@ static int inc_dec_var(u_char value)
 static void speakup_win_set(struct vc_data *vc)
 {
 	char info[40];
+
 	if (win_start > 1) {
 		synth_printf("%s\n", spk_msg_get(MSG_WINDOW_ALREADY_SET));
 		return;
@@ -1843,6 +1878,7 @@ static void speakup_win_enable(struct vc_data *vc)
 static void speakup_bits(struct vc_data *vc)
 {
 	int val = this_speakup_key - (FIRST_EDIT_BITS - 1);
+
 	if (spk_special_handler != NULL || val < 1 || val > 6) {
 		synth_printf("%s\n", spk_msg_get(MSG_ERROR));
 		return;
@@ -2011,6 +2047,7 @@ speakup_key(struct vc_data *vc, int shift_state, int keycode, u_short keysym,
 	u_char type = KTYP(keysym), value = KVAL(keysym), new_key = 0;
 	u_char shift_info, offset;
 	int ret = 0;
+
 	if (synth == NULL)
 		return 0;
 
@@ -2161,6 +2198,7 @@ static int keyboard_notifier_call(struct notifier_block *nb,
 	case KBD_POST_KEYSYM:{
 			unsigned char type = KTYP(param->value) - 0xf0;
 			unsigned char val = KVAL(param->value);
+
 			switch (type) {
 			case KT_SHIFT:
 				do_handle_shift(vc, val, up);
@@ -2187,6 +2225,7 @@ static int vt_notifier_call(struct notifier_block *nb,
 {
 	struct vt_notifier_param *param = _param;
 	struct vc_data *vc = param->vc;
+
 	switch (code) {
 	case VT_ALLOCATE:
 		if (vc->vc_mode == KD_TEXT)

commit 11a18fc3d1bb5a437755fd3e90568e64f6e7583e
Author: Domagoj Trsan <domagoj.trsan@gmail.com>
Date:   Tue Sep 9 20:04:32 2014 +0200

    staging: speakup: fix redundant return in void functions
    
    Signed-off-by: Domagoj Trsan <domagoj.trsan@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/speakup/main.c b/drivers/staging/speakup/main.c
index 592e9955f6d1..d367bd08cb96 100644
--- a/drivers/staging/speakup/main.c
+++ b/drivers/staging/speakup/main.c
@@ -1940,7 +1940,6 @@ static void speakup_goto(struct vc_data *vc)
 	}
 	synth_printf("%s\n", spk_msg_get(MSG_GOTO));
 	spk_special_handler = handle_goto;
-	return;
 }
 
 static void speakup_help(struct vc_data *vc)

commit e7027b9b2567cd3050d266bc56a2296840dd7f68
Author: Domagoj Trsan <domagoj.trsan@gmail.com>
Date:   Tue Sep 9 20:04:31 2014 +0200

    staging: speakup: fix warnings: line over 80 characters
    
    Signed-off-by: Domagoj Trsan <domagoj.trsan@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/speakup/main.c b/drivers/staging/speakup/main.c
index 0cd3cdba8644..592e9955f6d1 100644
--- a/drivers/staging/speakup/main.c
+++ b/drivers/staging/speakup/main.c
@@ -78,7 +78,8 @@ int spk_key_echo, spk_say_word_ctl;
 int spk_say_ctrl, spk_bell_pos;
 short spk_punc_mask;
 int spk_punc_level, spk_reading_punc;
-char spk_str_caps_start[MAXVARLEN + 1] = "\0", spk_str_caps_stop[MAXVARLEN + 1] = "\0";
+char spk_str_caps_start[MAXVARLEN + 1] = "\0";
+char spk_str_caps_stop[MAXVARLEN + 1] = "\0";
 const struct st_bits_data spk_punc_info[] = {
 	{"none", "", 0},
 	{"some", "/$%&@", SOME},

commit 3d3cb1bffde15ee6e69532457bee20b5d424952b
Author: Robin Schroer <sulamiification@gmail.com>
Date:   Fri Jun 13 01:17:30 2014 +0200

    drivers/staging/speakup/main: fixed jiffie comparison
    
    speakup_key() used manual comparison of jiffies to determine the time
    since the last keypress, replaced it with time_after()
    
    Signed-off-by: Robin Schroer <sulamiification@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/speakup/main.c b/drivers/staging/speakup/main.c
index 7de79d59a4cd..0cd3cdba8644 100644
--- a/drivers/staging/speakup/main.c
+++ b/drivers/staging/speakup/main.c
@@ -2067,7 +2067,7 @@ speakup_key(struct vc_data *vc, int shift_state, int keycode, u_short keysym,
 			if (up_flag)
 				goto out;
 			if (last_keycode == keycode &&
-			    last_spk_jiffy + MAX_DELAY > jiffies) {
+			    time_after(last_spk_jiffy + MAX_DELAY, jiffies)) {
 				spk_close_press = 1;
 				offset = spk_shift_table[shift_info + 32];
 				/* double press? */

commit d7500135802ca55b3f4e01a16544e8b34082f8c3
Author: Ben Hutchings <ben@decadent.org.uk>
Date:   Mon May 19 00:56:22 2014 +0100

    Staging: speakup: Move pasting into a work item
    
    Input is handled in softirq context, but when pasting we may
    need to sleep.  speakup_paste_selection() currently tries to
    bodge this by busy-waiting if in_atomic(), but that doesn't
    help because the ldisc may also sleep.
    
    For bonus breakage, speakup_paste_selection() changes the
    state of current, even though it's not running in process
    context.
    
    Move it into a work item and make sure to cancel it on exit.
    
    References: https://bugs.debian.org/735202
    References: https://bugs.debian.org/744015
    Reported-by: Paul Gevers <elbrus@debian.org>
    Reported-and-tested-by: Jarek Czekalski <jarekczek@poczta.onet.pl>
    Signed-off-by: Ben Hutchings <ben@decadent.org.uk>
    Cc: stable@vger.kernel.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/speakup/main.c b/drivers/staging/speakup/main.c
index 3b6e5358c723..7de79d59a4cd 100644
--- a/drivers/staging/speakup/main.c
+++ b/drivers/staging/speakup/main.c
@@ -2218,6 +2218,7 @@ static void __exit speakup_exit(void)
 	unregister_keyboard_notifier(&keyboard_notifier_block);
 	unregister_vt_notifier(&vt_notifier_block);
 	speakup_unregister_devsynth();
+	speakup_cancel_paste();
 	del_timer(&cursor_timer);
 	kthread_stop(speakup_task);
 	speakup_task = NULL;

commit ef35a4f44bdc6f8c9f99a561fd1fd318305a4d98
Author: Daeseok Youn <daeseok.youn@gmail.com>
Date:   Wed Apr 9 19:45:46 2014 +0900

    staging: speakup: fix misuse of kstrtol() in handle_goto()
    
    A string of goto_buf has a number followed by x or y.
    e.g. "3x" means move 3 lines down.
    The kstrtol() returns an error(-EINVAL) with this string so
    go_pos has unsigned a value of that error.
    And also "*cp" has not expected value.
    
    And fix sparse warnings:
     drivers/staging/speakup/main.c:1901 handle_goto() warn: unsigned '(speakup_console[vc->vc_num]->go_pos)' is never less than zero.
     drivers/staging/speakup/main.c:1911 handle_goto() warn: unsigned '(speakup_console[vc->vc_num]->go_pos)' is never less than zero.
    
    Signed-off-by: Daeseok Youn <daeseok.youn@gmail.com>
    Reviewed-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/speakup/main.c b/drivers/staging/speakup/main.c
index ef5933b93590..3b6e5358c723 100644
--- a/drivers/staging/speakup/main.c
+++ b/drivers/staging/speakup/main.c
@@ -1855,8 +1855,9 @@ static int handle_goto(struct vc_data *vc, u_char type, u_char ch, u_short key)
 {
 	static u_char goto_buf[8];
 	static int num;
-	int maxlen, go_pos;
+	int maxlen;
 	char *cp;
+
 	if (type == KT_SPKUP && ch == SPEAKUP_GOTO)
 		goto do_goto;
 	if (type == KT_LATIN && ch == '\n')
@@ -1891,25 +1892,24 @@ static int handle_goto(struct vc_data *vc, u_char type, u_char ch, u_short key)
 		spk_special_handler = NULL;
 		return 1;
 	}
-	go_pos = kstrtol(goto_buf, 10, (long *)&cp);
-	goto_pos = (u_long) go_pos;
+
+	goto_pos = simple_strtoul(goto_buf, &cp, 10);
+
 	if (*cp == 'x') {
 		if (*goto_buf < '0')
 			goto_pos += spk_x;
-		else
+		else if (goto_pos > 0)
 			goto_pos--;
-		if (goto_pos < 0)
-			goto_pos = 0;
+
 		if (goto_pos >= vc->vc_cols)
 			goto_pos = vc->vc_cols - 1;
 		goto_x = 1;
 	} else {
 		if (*goto_buf < '0')
 			goto_pos += spk_y;
-		else
+		else if (goto_pos > 0)
 			goto_pos--;
-		if (goto_pos < 0)
-			goto_pos = 0;
+
 		if (goto_pos >= vc->vc_rows)
 			goto_pos = vc->vc_rows - 1;
 		goto_x = 0;

commit 6c7b4ac9363488a5d19ea26f864f0a8866ea5b49
Author: Grygorii Strashko <grygorii.strashko@ti.com>
Date:   Fri Nov 8 18:41:42 2013 -0500

    mm/staging: remove unnecessary inclusion of bootmem.h
    
    Clean-up to remove depedency with bootmem headers.
    
    Cc: Yinghai Lu <yinghai@kernel.org>
    Cc: Tejun Heo <tj@kernel.org>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: William Hubbs <w.d.hubbs@gmail.com>
    Cc: Chris Brannon <chris@the-brannons.com>
    Cc: Kirk Reiser <kirk@reisers.ca>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    
    Signed-off-by: Grygorii Strashko <grygorii.strashko@ti.com>
    Signed-off-by: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/speakup/main.c b/drivers/staging/speakup/main.c
index 47502fa5f3f6..ef5933b93590 100644
--- a/drivers/staging/speakup/main.c
+++ b/drivers/staging/speakup/main.c
@@ -37,8 +37,6 @@
 #include <linux/input.h>
 #include <linux/kmod.h>
 
-#include <linux/bootmem.h>	/* for alloc_bootmem */
-
 /* speakup_*_selection */
 #include <linux/module.h>
 #include <linux/sched.h>

commit ab06e0f20ed4c4eb472a1e16f942d6e0150c00bc
Author: Shalin Mehta <shalinmehta85@gmail.com>
Date:   Thu Oct 3 01:08:42 2013 -0700

    staging: speakup: str initialization replaced with NULL where it was initialized with int
    
    Fixed warnings in all of three files where the string was initilized with an integer instead of NULL
    
    Signed-off-by: Shalin Mehta <shalinmehta85@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/speakup/main.c b/drivers/staging/speakup/main.c
index 14079c4949a8..47502fa5f3f6 100644
--- a/drivers/staging/speakup/main.c
+++ b/drivers/staging/speakup/main.c
@@ -90,7 +90,7 @@ const struct st_bits_data spk_punc_info[] = {
 	{"repeats", "()", CH_RPT},
 	{"extended numeric", "", B_EXNUM},
 	{"symbols", "", B_SYM},
-	{0, 0}
+	{NULL, NULL}
 };
 
 static char mark_cut_flag;

commit 0012196c165d5158a128e2accd2e511a306a6aa7
Author: Sachin Kamat <sachin.kamat@linaro.org>
Date:   Wed May 22 14:37:25 2013 +0530

    Staging: speakup/main: Staticize local symbols
    
    Symbols referenced only in this file are made static.
    
    Signed-off-by: Sachin Kamat <sachin.kamat@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/speakup/main.c b/drivers/staging/speakup/main.c
index c59b019eb443..14079c4949a8 100644
--- a/drivers/staging/speakup/main.c
+++ b/drivers/staging/speakup/main.c
@@ -95,7 +95,8 @@ const struct st_bits_data spk_punc_info[] = {
 
 static char mark_cut_flag;
 #define MAX_KEY 160
-u_char *spk_our_keys[MAX_KEY], *spk_shift_table;
+static u_char *spk_shift_table;
+u_char *spk_our_keys[MAX_KEY];
 u_char spk_key_buf[600];
 const u_char spk_key_defaults[] = {
 #include "speakupmap.h"
@@ -1282,7 +1283,7 @@ static int edit_bits(struct vc_data *vc, u_char type, u_char ch, u_short key)
 }
 
 /* Allocation concurrency is protected by the console semaphore */
-int speakup_allocate(struct vc_data *vc)
+static int speakup_allocate(struct vc_data *vc)
 {
 	int vc_num;
 
@@ -1299,7 +1300,7 @@ int speakup_allocate(struct vc_data *vc)
 	return 0;
 }
 
-void speakup_deallocate(struct vc_data *vc)
+static void speakup_deallocate(struct vc_data *vc)
 {
 	int vc_num;
 
@@ -1705,7 +1706,7 @@ static void speakup_con_write(struct vc_data *vc, const char *str, int len)
 	spin_unlock_irqrestore(&speakup_info.spinlock, flags);
 }
 
-void speakup_con_update(struct vc_data *vc)
+static void speakup_con_update(struct vc_data *vc)
 {
 	unsigned long flags;
 	if (speakup_console[vc->vc_num] == NULL || spk_parked)
@@ -1964,7 +1965,7 @@ static void speakup_lock(struct vc_data *vc)
 }
 
 typedef void (*spkup_hand) (struct vc_data *);
-spkup_hand spkup_handler[] = {
+static spkup_hand spkup_handler[] = {
 	/* must be ordered same as defines in speakup.h */
 	do_nothing, speakup_goto, speech_kill, speakup_shut_up,
 	speakup_cut, speakup_paste, say_first_char, say_last_char,
@@ -2002,7 +2003,7 @@ static void do_spkup(struct vc_data *vc, u_char value)
 
 static const char *pad_chars = "0123456789+-*/\015,.?()";
 
-int
+static int
 speakup_key(struct vc_data *vc, int shift_state, int keycode, u_short keysym,
 	    int up_flag)
 {

commit ff471ea823d8cdd790759febc358c3776a90c922
Author: Sachin Kamat <sachin.kamat@linaro.org>
Date:   Wed May 22 16:19:30 2013 +0530

    Staging: speakup/main: Use NULL instead of 0
    
    Use NULL instead of 0 for pointers.
    
    Signed-off-by: Sachin Kamat <sachin.kamat@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/speakup/main.c b/drivers/staging/speakup/main.c
index 4769c895e01f..c59b019eb443 100644
--- a/drivers/staging/speakup/main.c
+++ b/drivers/staging/speakup/main.c
@@ -2033,7 +2033,7 @@ speakup_key(struct vc_data *vc, int shift_state, int keycode, u_short keysym,
 	if (keycode >= MAX_KEY)
 		goto no_map;
 	key_info = spk_our_keys[keycode];
-	if (key_info == 0)
+	if (!key_info)
 		goto no_map;
 	/* Check valid read all mode keys */
 	if ((cursor_track == read_all_mode) && (!up_flag)) {
@@ -2265,7 +2265,7 @@ static int __init speakup_init(void)
 	     (var->var_id >= 0) && (var->var_id < MAXVARS); var++)
 		speakup_register_var(var);
 	for (i = 1; spk_punc_info[i].mask != 0; i++)
-		spk_set_mask_bits(0, i, 2);
+		spk_set_mask_bits(NULL, i, 2);
 
 	spk_set_key_info(spk_key_defaults, spk_key_buf);
 

commit f2ae62fe336f5194c06c213a32bbce0c8bf1511d
Author: Lisa Nguyen <lisa@xenapiadmin.com>
Date:   Tue May 21 13:31:48 2013 -0700

    staging/speakup: Changed parameters in kstrtol()
    
    Changed parameters in the kstrtol() function inside main.c to resolve
    warnings re: mismatched data types used.
    
    Signed-off-by: Lisa Nguyen <lisa@xenapiadmin.com>
    Reported-by: kbuild test robot <fengguang.wu@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/speakup/main.c b/drivers/staging/speakup/main.c
index e91d2132a873..4769c895e01f 100644
--- a/drivers/staging/speakup/main.c
+++ b/drivers/staging/speakup/main.c
@@ -1892,7 +1892,7 @@ static int handle_goto(struct vc_data *vc, u_char type, u_char ch, u_short key)
 		spk_special_handler = NULL;
 		return 1;
 	}
-	go_pos = kstrtol(goto_buf, &cp, 10);
+	go_pos = kstrtol(goto_buf, 10, (long *)&cp);
 	goto_pos = (u_long) go_pos;
 	if (*cp == 'x') {
 		if (*goto_buf < '0')

commit a87af7c58b1f5af0d6a6093465d1a5ed8054434c
Author: Lisa Nguyen <lisa@xenapiadmin.com>
Date:   Fri May 17 11:52:28 2013 -0700

    staging/speakup: Replaced deprecated function
    
    Replaced simple_strtol() function with kstrtol() function
    in main.c
    
    Signed-off-by: Lisa Nguyen <lisa@xenapiadmin.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/speakup/main.c b/drivers/staging/speakup/main.c
index 3ea251508673..e91d2132a873 100644
--- a/drivers/staging/speakup/main.c
+++ b/drivers/staging/speakup/main.c
@@ -1892,7 +1892,7 @@ static int handle_goto(struct vc_data *vc, u_char type, u_char ch, u_short key)
 		spk_special_handler = NULL;
 		return 1;
 	}
-	go_pos = simple_strtol(goto_buf, &cp, 10);
+	go_pos = kstrtol(goto_buf, &cp, 10);
 	goto_pos = (u_long) go_pos;
 	if (*cp == 'x') {
 		if (*goto_buf < '0')

commit 69d8ba56594a23af4901e109a5b9178105b863b3
Author: Lisa Nguyen <lisa@xenapiadmin.com>
Date:   Fri May 17 11:51:18 2013 -0700

    staging/speakup: Reformatted pointer variables
    
    Reformatted pointer variables in main.c to meet kernel coding
    standards.
    
    Signed-off-by: Lisa Nguyen <lisa@xenapiadmin.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/speakup/main.c b/drivers/staging/speakup/main.c
index 53110c82108e..3ea251508673 100644
--- a/drivers/staging/speakup/main.c
+++ b/drivers/staging/speakup/main.c
@@ -457,7 +457,7 @@ static void speak_char(u_char ch)
 	synth_buffer_add(SPACE);
 }
 
-static u16 get_char(struct vc_data *vc, u16 * pos, u_char * attribs)
+static u16 get_char(struct vc_data *vc, u16 *pos, u_char *attribs)
 {
 	u16 ch = ' ';
 	if (vc && pos) {

commit 3efe810f2322223eca3b3a1dea3ae40500cbd471
Author: William Hubbs <w.d.hubbs@gmail.com>
Date:   Mon May 13 00:02:56 2013 -0500

    staging: speakup: main: remove custom locking macros
    
    Signed-off-by: William Hubbs <w.d.hubbs@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/speakup/main.c b/drivers/staging/speakup/main.c
index 6c7b55c2947d..53110c82108e 100644
--- a/drivers/staging/speakup/main.c
+++ b/drivers/staging/speakup/main.c
@@ -1129,7 +1129,7 @@ static void do_handle_shift(struct vc_data *vc, u_char value, char up_flag)
 	unsigned long flags;
 	if (synth == NULL || up_flag || spk_killed)
 		return;
-	spk_lock(flags);
+	spin_lock_irqsave(&speakup_info.spinlock, flags);
 	if (cursor_track == read_all_mode) {
 		switch (value) {
 		case KVAL(K_SHIFT):
@@ -1151,20 +1151,20 @@ static void do_handle_shift(struct vc_data *vc, u_char value, char up_flag)
 	}
 	if (spk_say_ctrl && value < NUM_CTL_LABELS)
 		synth_printf("%s", spk_msg_get(MSG_CTL_START + value));
-	spk_unlock(flags);
+	spin_unlock_irqrestore(&speakup_info.spinlock, flags);
 }
 
 static void do_handle_latin(struct vc_data *vc, u_char value, char up_flag)
 {
 	unsigned long flags;
-	spk_lock(flags);
+	spin_lock_irqsave(&speakup_info.spinlock, flags);
 	if (up_flag) {
 		spk_lastkey = spk_keydown = 0;
-		spk_unlock(flags);
+		spin_unlock_irqrestore(&speakup_info.spinlock, flags);
 		return;
 	}
 	if (synth == NULL || spk_killed) {
-		spk_unlock(flags);
+		spin_unlock_irqrestore(&speakup_info.spinlock, flags);
 		return;
 	}
 	spk_shut_up &= 0xfe;
@@ -1173,7 +1173,7 @@ static void do_handle_latin(struct vc_data *vc, u_char value, char up_flag)
 	spk_parked &= 0xfe;
 	if (spk_key_echo == 2 && value >= MINECHOCHAR)
 		speak_char(value);
-	spk_unlock(flags);
+	spin_unlock_irqrestore(&speakup_info.spinlock, flags);
 }
 
 int spk_set_key_info(const u_char *key_info, u_char *k_buffer)
@@ -1449,21 +1449,21 @@ static void handle_cursor_read_all(struct vc_data *vc, int command)
 static int pre_handle_cursor(struct vc_data *vc, u_char value, char up_flag)
 {
 	unsigned long flags;
-	spk_lock(flags);
+	spin_lock_irqsave(&speakup_info.spinlock, flags);
 	if (cursor_track == read_all_mode) {
 		spk_parked &= 0xfe;
 		if (synth == NULL || up_flag || spk_shut_up) {
-			spk_unlock(flags);
+			spin_unlock_irqrestore(&speakup_info.spinlock, flags);
 			return NOTIFY_STOP;
 		}
 		del_timer(&cursor_timer);
 		spk_shut_up &= 0xfe;
 		spk_do_flush();
 		start_read_all_timer(vc, value + 1);
-		spk_unlock(flags);
+		spin_unlock_irqrestore(&speakup_info.spinlock, flags);
 		return NOTIFY_STOP;
 	}
-	spk_unlock(flags);
+	spin_unlock_irqrestore(&speakup_info.spinlock, flags);
 	return NOTIFY_OK;
 }
 
@@ -1472,10 +1472,10 @@ static void do_handle_cursor(struct vc_data *vc, u_char value, char up_flag)
 	unsigned long flags;
 	struct var_t *cursor_timeout;
 
-	spk_lock(flags);
+	spin_lock_irqsave(&speakup_info.spinlock, flags);
 	spk_parked &= 0xfe;
 	if (synth == NULL || up_flag || spk_shut_up || cursor_track == CT_Off) {
-		spk_unlock(flags);
+		spin_unlock_irqrestore(&speakup_info.spinlock, flags);
 		return;
 	}
 	spk_shut_up &= 0xfe;
@@ -1494,7 +1494,7 @@ static void do_handle_cursor(struct vc_data *vc, u_char value, char up_flag)
 	cursor_timeout = spk_get_var(CURSOR_TIME);
 	mod_timer(&cursor_timer,
 		  jiffies + msecs_to_jiffies(cursor_timeout->u.n.value));
-	spk_unlock(flags);
+	spin_unlock_irqrestore(&speakup_info.spinlock, flags);
 }
 
 static void update_color_buffer(struct vc_data *vc, const char *ic, int len)
@@ -1619,7 +1619,7 @@ static void cursor_done(u_long data)
 	struct vc_data *vc = vc_cons[cursor_con].d;
 	unsigned long flags;
 	del_timer(&cursor_timer);
-	spk_lock(flags);
+	spin_lock_irqsave(&speakup_info.spinlock, flags);
 	if (cursor_con != fg_console) {
 		is_cursor = 0;
 		goto out;
@@ -1650,7 +1650,7 @@ static void cursor_done(u_long data)
 		say_char(vc);
 	spk_keydown = is_cursor = 0;
 out:
-	spk_unlock(flags);
+	spin_unlock_irqrestore(&speakup_info.spinlock, flags);
 }
 
 /* called by: vt_notifier_call() */
@@ -1659,13 +1659,13 @@ static void speakup_bs(struct vc_data *vc)
 	unsigned long flags;
 	if (!speakup_console[vc->vc_num])
 		return;
-	if (!spk_trylock(flags))
+	if (!spin_trylock_irqsave(&speakup_info.spinlock, flags))
 		/* Speakup output, discard */
 		return;
 	if (!spk_parked)
 		speakup_date(vc);
 	if (spk_shut_up || synth == NULL) {
-		spk_unlock(flags);
+		spin_unlock_irqrestore(&speakup_info.spinlock, flags);
 		return;
 	}
 	if (vc->vc_num == fg_console && spk_keydown) {
@@ -1673,7 +1673,7 @@ static void speakup_bs(struct vc_data *vc)
 		if (!is_cursor)
 			say_char(vc);
 	}
-	spk_unlock(flags);
+	spin_unlock_irqrestore(&speakup_info.spinlock, flags);
 }
 
 /* called by: vt_notifier_call() */
@@ -1682,7 +1682,7 @@ static void speakup_con_write(struct vc_data *vc, const char *str, int len)
 	unsigned long flags;
 	if ((vc->vc_num != fg_console) || spk_shut_up || synth == NULL)
 		return;
-	if (!spk_trylock(flags))
+	if (!spin_trylock_irqsave(&speakup_info.spinlock, flags))
 		/* Speakup output, discard */
 		return;
 	if (spk_bell_pos && spk_keydown && (vc->vc_x == spk_bell_pos - 1))
@@ -1690,19 +1690,19 @@ static void speakup_con_write(struct vc_data *vc, const char *str, int len)
 	if ((is_cursor) || (cursor_track == read_all_mode)) {
 		if (cursor_track == CT_Highlight)
 			update_color_buffer(vc, str, len);
-		spk_unlock(flags);
+		spin_unlock_irqrestore(&speakup_info.spinlock, flags);
 		return;
 	}
 	if (win_enabled) {
 		if (vc->vc_x >= win_left && vc->vc_x <= win_right &&
 		    vc->vc_y >= win_top && vc->vc_y <= win_bottom) {
-			spk_unlock(flags);
+			spin_unlock_irqrestore(&speakup_info.spinlock, flags);
 			return;
 		}
 	}
 
 	spkup_write(str, len);
-	spk_unlock(flags);
+	spin_unlock_irqrestore(&speakup_info.spinlock, flags);
 }
 
 void speakup_con_update(struct vc_data *vc)
@@ -1710,11 +1710,11 @@ void speakup_con_update(struct vc_data *vc)
 	unsigned long flags;
 	if (speakup_console[vc->vc_num] == NULL || spk_parked)
 		return;
-	if (!spk_trylock(flags))
+	if (!spin_trylock_irqsave(&speakup_info.spinlock, flags))
 		/* Speakup output, discard */
 		return;
 	speakup_date(vc);
-	spk_unlock(flags);
+	spin_unlock_irqrestore(&speakup_info.spinlock, flags);
 }
 
 static void do_handle_spec(struct vc_data *vc, u_char value, char up_flag)
@@ -1724,7 +1724,7 @@ static void do_handle_spec(struct vc_data *vc, u_char value, char up_flag)
 	char *label;
 	if (synth == NULL || up_flag || spk_killed)
 		return;
-	spk_lock(flags);
+	spin_lock_irqsave(&speakup_info.spinlock, flags);
 	spk_shut_up &= 0xfe;
 	if (spk_no_intr)
 		spk_do_flush();
@@ -1745,13 +1745,13 @@ static void do_handle_spec(struct vc_data *vc, u_char value, char up_flag)
 		break;
 	default:
 		spk_parked &= 0xfe;
-		spk_unlock(flags);
+		spin_unlock_irqrestore(&speakup_info.spinlock, flags);
 		return;
 	}
 	if (on_off < 2)
 		synth_printf("%s %s\n",
 			     label, spk_msg_get(MSG_STATUS_START + on_off));
-	spk_unlock(flags);
+	spin_unlock_irqrestore(&speakup_info.spinlock, flags);
 }
 
 static int inc_dec_var(u_char value)
@@ -2015,7 +2015,7 @@ speakup_key(struct vc_data *vc, int shift_state, int keycode, u_short keysym,
 	if (synth == NULL)
 		return 0;
 
-	spk_lock(flags);
+	spin_lock_irqsave(&speakup_info.spinlock, flags);
 	tty = vc->port.tty;
 	if (type >= 0xf0)
 		type -= 0xf0;
@@ -2114,7 +2114,7 @@ speakup_key(struct vc_data *vc, int shift_state, int keycode, u_short keysym,
 	}
 	last_keycode = 0;
 out:
-	spk_unlock(flags);
+	spin_unlock_irqrestore(&speakup_info.spinlock, flags);
 	return ret;
 }
 

commit 1627ab92b2e6307525f43f775aaeac54407981ef
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Thu Mar 28 11:02:43 2013 +0200

    staging: speakup: reuse native kernel functions
    
    We have simple_strtoul and simple_strtol. Don't repeat their functionality
    here.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Acked-by: Samuel Thibault <samuel.thibault@ens-lyon.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/speakup/main.c b/drivers/staging/speakup/main.c
index 9916e94aa361..6c7b55c2947d 100644
--- a/drivers/staging/speakup/main.c
+++ b/drivers/staging/speakup/main.c
@@ -1892,7 +1892,7 @@ static int handle_goto(struct vc_data *vc, u_char type, u_char ch, u_short key)
 		spk_special_handler = NULL;
 		return 1;
 	}
-	cp = speakup_s2i(goto_buf, &go_pos);
+	go_pos = simple_strtol(goto_buf, &cp, 10);
 	goto_pos = (u_long) go_pos;
 	if (*cp == 'x') {
 		if (*goto_buf < '0')

commit d9f5420268ca9b2bbe62f14757fac3e10eaf1ebf
Author: Samuel Thibault <samuel.thibault@ens-lyon.org>
Date:   Wed Jan 2 02:36:56 2013 +0100

    staging: speakup: Turn some symbols static
    
    Turn static some symbols which do not actually need to be
    externally-visible
    
    Signed-off-by: Samuel Thibault <samuel.thibault@ens-lyon.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/speakup/main.c b/drivers/staging/speakup/main.c
index 463d125ee77b..9916e94aa361 100644
--- a/drivers/staging/speakup/main.c
+++ b/drivers/staging/speakup/main.c
@@ -251,14 +251,14 @@ DEFINE_MUTEX(spk_mutex);
 static int keyboard_notifier_call(struct notifier_block *,
 				  unsigned long code, void *param);
 
-struct notifier_block keyboard_notifier_block = {
+static struct notifier_block keyboard_notifier_block = {
 	.notifier_call = keyboard_notifier_call,
 };
 
 static int vt_notifier_call(struct notifier_block *,
 			    unsigned long code, void *param);
 
-struct notifier_block vt_notifier_block = {
+static struct notifier_block vt_notifier_block = {
 	.notifier_call = vt_notifier_call,
 };
 

commit ca2beaf84d9678c12b17d92623f0e90829d6ca13
Author: Samuel Thibault <samuel.thibault@ens-lyon.org>
Date:   Wed Jan 2 02:37:40 2013 +0100

    staging: speakup: Prefix externally-visible symbols
    
    This prefixes all externally-visible symbols of speakup with "spk_".
    
    Signed-off-by: Samuel Thibault <samuel.thibault@ens-lyon.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/speakup/main.c b/drivers/staging/speakup/main.c
index 40e2488b9679..463d125ee77b 100644
--- a/drivers/staging/speakup/main.c
+++ b/drivers/staging/speakup/main.c
@@ -65,23 +65,23 @@ MODULE_VERSION(SPEAKUP_VERSION);
 
 char *synth_name;
 module_param_named(synth, synth_name, charp, S_IRUGO);
-module_param_named(quiet, quiet_boot, bool, S_IRUGO);
+module_param_named(quiet, spk_quiet_boot, bool, S_IRUGO);
 
 MODULE_PARM_DESC(synth, "Synth to start if speakup is built in.");
 MODULE_PARM_DESC(quiet, "Do not announce when the synthesizer is found.");
 
-special_func special_handler;
+special_func spk_special_handler;
 
-short pitch_shift, synth_flags;
+short spk_pitch_shift, synth_flags;
 static char buf[256];
-int attrib_bleep, bleeps, bleep_time = 10;
-int no_intr, spell_delay;
-int key_echo, say_word_ctl;
-int say_ctrl, bell_pos;
-short punc_mask;
-int punc_level, reading_punc;
-char str_caps_start[MAXVARLEN + 1] = "\0", str_caps_stop[MAXVARLEN + 1] = "\0";
-const struct st_bits_data punc_info[] = {
+int spk_attrib_bleep, spk_bleeps, spk_bleep_time = 10;
+int spk_no_intr, spk_spell_delay;
+int spk_key_echo, spk_say_word_ctl;
+int spk_say_ctrl, spk_bell_pos;
+short spk_punc_mask;
+int spk_punc_level, spk_reading_punc;
+char spk_str_caps_start[MAXVARLEN + 1] = "\0", spk_str_caps_stop[MAXVARLEN + 1] = "\0";
+const struct st_bits_data spk_punc_info[] = {
 	{"none", "", 0},
 	{"some", "/$%&@", SOME},
 	{"most", "$%&#()=+*/@^<>|\\", MOST},
@@ -95,9 +95,9 @@ const struct st_bits_data punc_info[] = {
 
 static char mark_cut_flag;
 #define MAX_KEY 160
-u_char *our_keys[MAX_KEY], *shift_table;
-u_char key_buf[600];
-const u_char key_defaults[] = {
+u_char *spk_our_keys[MAX_KEY], *spk_shift_table;
+u_char spk_key_buf[600];
+const u_char spk_key_defaults[] = {
 #include "speakupmap.h"
 };
 
@@ -129,9 +129,9 @@ static char *phonetic[] = {
 /* array of 256 char pointers (one for each character description)
  * initialized to default_chars and user selectable via
  * /proc/speakup/characters */
-char *characters[256];
+char *spk_characters[256];
 
-char *default_chars[256] = {
+char *spk_default_chars[256] = {
 /*000*/ "null", "^a", "^b", "^c", "^d", "^e", "^f", "^g",
 /*008*/ "^h", "^i", "^j", "^k", "^l", "^m", "^n", "^o",
 /*016*/ "^p", "^q", "^r", "^s", "^t", "^u", "^v", "^w",
@@ -238,7 +238,7 @@ static u_short default_chartab[256] = {
 };
 
 struct task_struct *speakup_task;
-struct bleep unprocessed_sound;
+struct bleep spk_unprocessed_sound;
 static int spk_keydown;
 static u_char spk_lastkey, spk_close_press, keymap_flags;
 static u_char last_keycode, this_speakup_key;
@@ -282,13 +282,13 @@ static void bleep(u_short val)
 		350, 370, 392, 414, 440, 466, 491, 523, 554, 587, 619, 659
 	};
 	short freq;
-	int time = bleep_time;
+	int time = spk_bleep_time;
 	freq = vals[val % 12];
 	if (val > 11)
 		freq *= (1 << (val / 12));
-	unprocessed_sound.freq = freq;
-	unprocessed_sound.jiffies = msecs_to_jiffies(time);
-	unprocessed_sound.active = 1;
+	spk_unprocessed_sound.freq = freq;
+	spk_unprocessed_sound.jiffies = msecs_to_jiffies(time);
+	spk_unprocessed_sound.active = 1;
 	/* We can only have 1 active sound at a time. */
 }
 
@@ -300,7 +300,7 @@ static void speakup_shut_up(struct vc_data *vc)
 	spk_parked &= 0xfe;
 	speakup_date(vc);
 	if (synth != NULL)
-		do_flush();
+		spk_do_flush();
 }
 
 static void speech_kill(struct vc_data *vc)
@@ -313,9 +313,9 @@ static void speech_kill(struct vc_data *vc)
 	if (val == 2 || spk_killed) {
 		/* dead */
 		spk_shut_up &= ~0x40;
-		synth_printf("%s\n", msg_get(MSG_IAM_ALIVE));
+		synth_printf("%s\n", spk_msg_get(MSG_IAM_ALIVE));
 	} else {
-		synth_printf("%s\n", msg_get(MSG_YOU_KILLED_SPEAKUP));
+		synth_printf("%s\n", spk_msg_get(MSG_YOU_KILLED_SPEAKUP));
 		spk_shut_up |= 0x40;
 	}
 }
@@ -324,10 +324,10 @@ static void speakup_off(struct vc_data *vc)
 {
 	if (spk_shut_up & 0x80) {
 		spk_shut_up &= 0x7f;
-		synth_printf("%s\n", msg_get(MSG_HEY_THATS_BETTER));
+		synth_printf("%s\n", spk_msg_get(MSG_HEY_THATS_BETTER));
 	} else {
 		spk_shut_up |= 0x80;
-		synth_printf("%s\n", msg_get(MSG_YOU_TURNED_ME_OFF));
+		synth_printf("%s\n", spk_msg_get(MSG_YOU_TURNED_ME_OFF));
 	}
 	speakup_date(vc);
 }
@@ -336,10 +336,10 @@ static void speakup_parked(struct vc_data *vc)
 {
 	if (spk_parked & 0x80) {
 		spk_parked = 0;
-		synth_printf("%s\n", msg_get(MSG_UNPARKED));
+		synth_printf("%s\n", spk_msg_get(MSG_UNPARKED));
 	} else {
 		spk_parked |= 0x80;
-		synth_printf("%s\n", msg_get(MSG_PARKED));
+		synth_printf("%s\n", spk_msg_get(MSG_PARKED));
 	}
 }
 
@@ -350,16 +350,16 @@ static void speakup_cut(struct vc_data *vc)
 
 	if (!mark_cut_flag) {
 		mark_cut_flag = 1;
-		xs = (u_short) spk_x;
-		ys = (u_short) spk_y;
+		spk_xs = (u_short) spk_x;
+		spk_ys = (u_short) spk_y;
 		spk_sel_cons = vc;
-		synth_printf("%s\n", msg_get(MSG_MARK));
+		synth_printf("%s\n", spk_msg_get(MSG_MARK));
 		return;
 	}
-	xe = (u_short) spk_x;
-	ye = (u_short) spk_y;
+	spk_xe = (u_short) spk_x;
+	spk_ye = (u_short) spk_y;
 	mark_cut_flag = 0;
-	synth_printf("%s\n", msg_get(MSG_CUT));
+	synth_printf("%s\n", spk_msg_get(MSG_CUT));
 
 	speakup_clear_selection();
 	ret = speakup_set_selection(tty);
@@ -383,9 +383,9 @@ static void speakup_paste(struct vc_data *vc)
 {
 	if (mark_cut_flag) {
 		mark_cut_flag = 0;
-		synth_printf("%s\n", msg_get(MSG_MARK_CLEARED));
+		synth_printf("%s\n", spk_msg_get(MSG_MARK_CLEARED));
 	} else {
-		synth_printf("%s\n", msg_get(MSG_PASTE));
+		synth_printf("%s\n", spk_msg_get(MSG_PASTE));
 		speakup_paste_selection(tty);
 	}
 }
@@ -395,16 +395,16 @@ static void say_attributes(struct vc_data *vc)
 	int fg = spk_attr & 0x0f;
 	int bg = spk_attr >> 4;
 	if (fg > 8) {
-		synth_printf("%s ", msg_get(MSG_BRIGHT));
+		synth_printf("%s ", spk_msg_get(MSG_BRIGHT));
 		fg -= 8;
 	}
-	synth_printf("%s", msg_get(MSG_COLORS_START + fg));
+	synth_printf("%s", spk_msg_get(MSG_COLORS_START + fg));
 	if (bg > 7) {
-		synth_printf(" %s ", msg_get(MSG_ON_BLINKING));
+		synth_printf(" %s ", spk_msg_get(MSG_ON_BLINKING));
 		bg -= 8;
 	} else
-		synth_printf(" %s ", msg_get(MSG_ON));
-	synth_printf("%s\n", msg_get(MSG_COLORS_START + bg));
+		synth_printf(" %s ", spk_msg_get(MSG_ON));
+	synth_printf("%s\n", spk_msg_get(MSG_COLORS_START + bg));
 }
 
 enum {
@@ -417,24 +417,24 @@ enum {
 
 static void announce_edge(struct vc_data *vc, int msg_id)
 {
-	if (bleeps & 1)
+	if (spk_bleeps & 1)
 		bleep(spk_y);
-	if ((bleeps & 2) && (msg_id < edge_quiet))
-		synth_printf("%s\n", msg_get(MSG_EDGE_MSGS_START + msg_id - 1));
+	if ((spk_bleeps & 2) && (msg_id < edge_quiet))
+		synth_printf("%s\n", spk_msg_get(MSG_EDGE_MSGS_START + msg_id - 1));
 }
 
 static void speak_char(u_char ch)
 {
-	char *cp = characters[ch];
-	struct var_t *direct = get_var(DIRECT);
+	char *cp = spk_characters[ch];
+	struct var_t *direct = spk_get_var(DIRECT);
 	if (direct && direct->u.n.value) {
 		if (IS_CHAR(ch, B_CAP)) {
-			pitch_shift++;
-			synth_printf("%s", str_caps_start);
+			spk_pitch_shift++;
+			synth_printf("%s", spk_str_caps_start);
 		}
 		synth_printf("%c", ch);
 		if (IS_CHAR(ch, B_CAP))
-			synth_printf("%s", str_caps_stop);
+			synth_printf("%s", spk_str_caps_stop);
 		return;
 	}
 	if (cp == NULL) {
@@ -443,13 +443,13 @@ static void speak_char(u_char ch)
 	}
 	synth_buffer_add(SPACE);
 	if (IS_CHAR(ch, B_CAP)) {
-		pitch_shift++;
-		synth_printf("%s", str_caps_start);
+		spk_pitch_shift++;
+		synth_printf("%s", spk_str_caps_start);
 		synth_printf("%s", cp);
-		synth_printf("%s", str_caps_stop);
+		synth_printf("%s", spk_str_caps_stop);
 	} else {
 		if (*cp == '^') {
-			synth_printf("%s", msg_get(MSG_CTRL));
+			synth_printf("%s", spk_msg_get(MSG_CTRL));
 			cp++;
 		}
 		synth_printf("%s", cp);
@@ -479,9 +479,9 @@ static void say_char(struct vc_data *vc)
 	spk_old_attr = spk_attr;
 	ch = get_char(vc, (u_short *) spk_pos, &spk_attr);
 	if (spk_attr != spk_old_attr) {
-		if (attrib_bleep & 1)
+		if (spk_attrib_bleep & 1)
 			bleep(spk_y);
-		if (attrib_bleep & 2)
+		if (spk_attrib_bleep & 2)
 			say_attributes(vc);
 	}
 	speak_char(ch & 0xff);
@@ -497,7 +497,7 @@ static void say_phonetic_char(struct vc_data *vc)
 		synth_printf("%s\n", phonetic[--ch]);
 	} else {
 		if (IS_CHAR(ch, B_NUM))
-			synth_printf("%s ", msg_get(MSG_NUMBER));
+			synth_printf("%s ", spk_msg_get(MSG_NUMBER));
 		speak_char(ch);
 	}
 }
@@ -527,8 +527,8 @@ static void say_next_char(struct vc_data *vc)
 }
 
 /* get_word - will first check to see if the character under the
- * reading cursor is a space and if say_word_ctl is true it will
- * return the word space.  If say_word_ctl is not set it will check to
+ * reading cursor is a space and if spk_say_word_ctl is true it will
+ * return the word space.  If spk_say_word_ctl is not set it will check to
  * see if there is a word starting on the next position to the right
  * and return that word if it exists.  If it does not exist it will
  * move left to the beginning of any previous word on the line or the
@@ -544,9 +544,9 @@ static u_long get_word(struct vc_data *vc)
 	ch = (char)get_char(vc, (u_short *) tmp_pos, &temp);
 
 /* decided to take out the sayword if on a space (mis-information */
-	if (say_word_ctl && ch == SPACE) {
+	if (spk_say_word_ctl && ch == SPACE) {
 		*buf = '\0';
-		synth_printf("%s\n", msg_get(MSG_SPACE));
+		synth_printf("%s\n", spk_msg_get(MSG_SPACE));
 		return 0;
 	} else if ((tmpx < vc->vc_cols - 2)
 		   && (ch == SPACE || ch == 0 || IS_WDLM(ch))
@@ -582,13 +582,13 @@ static u_long get_word(struct vc_data *vc)
 static void say_word(struct vc_data *vc)
 {
 	u_long cnt = get_word(vc);
-	u_short saved_punc_mask = punc_mask;
+	u_short saved_punc_mask = spk_punc_mask;
 	if (cnt == 0)
 		return;
-	punc_mask = PUNC;
+	spk_punc_mask = PUNC;
 	buf[cnt++] = SPACE;
 	spkup_write(buf, cnt);
-	punc_mask = saved_punc_mask;
+	spk_punc_mask = saved_punc_mask;
 }
 
 static void say_prev_word(struct vc_data *vc)
@@ -686,22 +686,22 @@ static void say_next_word(struct vc_data *vc)
 static void spell_word(struct vc_data *vc)
 {
 	static char *delay_str[] = { "", ",", ".", ". .", ". . ." };
-	char *cp = buf, *str_cap = str_caps_stop;
-	char *cp1, *last_cap = str_caps_stop;
+	char *cp = buf, *str_cap = spk_str_caps_stop;
+	char *cp1, *last_cap = spk_str_caps_stop;
 	u_char ch;
 	if (!get_word(vc))
 		return;
 	while ((ch = (u_char) *cp)) {
 		if (cp != buf)
-			synth_printf(" %s ", delay_str[spell_delay]);
+			synth_printf(" %s ", delay_str[spk_spell_delay]);
 		if (IS_CHAR(ch, B_CAP)) {
-			str_cap = str_caps_start;
-			if (*str_caps_stop)
-				pitch_shift++;
+			str_cap = spk_str_caps_start;
+			if (*spk_str_caps_stop)
+				spk_pitch_shift++;
 			else	/* synth has no pitch */
-				last_cap = str_caps_stop;
+				last_cap = spk_str_caps_stop;
 		} else
-			str_cap = str_caps_stop;
+			str_cap = spk_str_caps_stop;
 		if (str_cap != last_cap) {
 			synth_printf("%s", str_cap);
 			last_cap = str_cap;
@@ -711,17 +711,17 @@ static void spell_word(struct vc_data *vc)
 			ch &= 31;
 			cp1 = phonetic[--ch];
 		} else {
-			cp1 = characters[ch];
+			cp1 = spk_characters[ch];
 			if (*cp1 == '^') {
-				synth_printf("%s", msg_get(MSG_CTRL));
+				synth_printf("%s", spk_msg_get(MSG_CTRL));
 				cp1++;
 			}
 		}
 		synth_printf("%s", cp1);
 		cp++;
 	}
-	if (str_cap != str_caps_stop)
-		synth_printf("%s", str_caps_stop);
+	if (str_cap != spk_str_caps_stop)
+		synth_printf("%s", spk_str_caps_stop);
 }
 
 static int get_line(struct vc_data *vc)
@@ -746,9 +746,9 @@ static void say_line(struct vc_data *vc)
 {
 	int i = get_line(vc);
 	char *cp;
-	u_short saved_punc_mask = punc_mask;
+	u_short saved_punc_mask = spk_punc_mask;
 	if (i == 0) {
-		synth_printf("%s\n", msg_get(MSG_BLANK));
+		synth_printf("%s\n", spk_msg_get(MSG_BLANK));
 		return;
 	}
 	buf[i++] = '\n';
@@ -758,9 +758,9 @@ static void say_line(struct vc_data *vc)
 			cp++;
 		synth_printf("%d, ", (cp - buf) + 1);
 	}
-	punc_mask = punc_masks[reading_punc];
+	spk_punc_mask = spk_punc_masks[spk_reading_punc];
 	spkup_write(buf, i);
-	punc_mask = saved_punc_mask;
+	spk_punc_mask = saved_punc_mask;
 }
 
 static void say_prev_line(struct vc_data *vc)
@@ -792,7 +792,7 @@ static int say_from_to(struct vc_data *vc, u_long from, u_long to,
 {
 	int i = 0;
 	u_char tmp;
-	u_short saved_punc_mask = punc_mask;
+	u_short saved_punc_mask = spk_punc_mask;
 	spk_old_attr = spk_attr;
 	spk_attr = get_attributes((u_short *) from);
 	while (from < to) {
@@ -809,10 +809,10 @@ static int say_from_to(struct vc_data *vc, u_long from, u_long to,
 	if (i < 1)
 		return i;
 	if (read_punc)
-		punc_mask = punc_info[reading_punc].mask;
+		spk_punc_mask = spk_punc_info[spk_reading_punc].mask;
 	spkup_write(buf, i);
 	if (read_punc)
-		punc_mask = saved_punc_mask;
+		spk_punc_mask = saved_punc_mask;
 	return i - 1;
 }
 
@@ -824,7 +824,7 @@ static void say_line_from_to(struct vc_data *vc, u_long from, u_long to,
 	start += from * 2;
 	if (say_from_to(vc, start, end, read_punc) <= 0)
 		if (cursor_track != read_all_mode)
-			synth_printf("%s\n", msg_get(MSG_BLANK));
+			synth_printf("%s\n", spk_msg_get(MSG_BLANK));
 }
 
 /* Sentence Reading Commands */
@@ -924,7 +924,7 @@ static void speakup_win_say(struct vc_data *vc)
 {
 	u_long start, end, from, to;
 	if (win_start < 2) {
-		synth_printf("%s\n", msg_get(MSG_NO_WINDOW));
+		synth_printf("%s\n", spk_msg_get(MSG_NO_WINDOW));
 		return;
 	}
 	start = vc->vc_origin + (win_top * vc->vc_size_row);
@@ -975,7 +975,7 @@ static void say_first_char(struct vc_data *vc)
 	u_char ch;
 	spk_parked |= 0x01;
 	if (len == 0) {
-		synth_printf("%s\n", msg_get(MSG_BLANK));
+		synth_printf("%s\n", spk_msg_get(MSG_BLANK));
 		return;
 	}
 	for (i = 0; i < len; i++)
@@ -994,7 +994,7 @@ static void say_last_char(struct vc_data *vc)
 	u_char ch;
 	spk_parked |= 0x01;
 	if (len == 0) {
-		synth_printf("%s\n", msg_get(MSG_BLANK));
+		synth_printf("%s\n", spk_msg_get(MSG_BLANK));
 		return;
 	}
 	ch = buf[--len];
@@ -1006,7 +1006,7 @@ static void say_last_char(struct vc_data *vc)
 
 static void say_position(struct vc_data *vc)
 {
-	synth_printf(msg_get(MSG_POS_INFO), spk_y + 1, spk_x + 1,
+	synth_printf(spk_msg_get(MSG_POS_INFO), spk_y + 1, spk_x + 1,
 		     vc->vc_num + 1);
 	synth_printf("\n");
 }
@@ -1017,7 +1017,7 @@ static void say_char_num(struct vc_data *vc)
 	u_char tmp;
 	u_short ch = get_char(vc, (u_short *) spk_pos, &tmp);
 	ch &= 0xff;
-	synth_printf(msg_get(MSG_CHAR_INFO), ch, ch);
+	synth_printf(spk_msg_get(MSG_CHAR_INFO), ch, ch);
 }
 
 /* these are stub functions to keep keyboard.c happy. */
@@ -1066,7 +1066,7 @@ static void spkup_write(const char *in_buf, int count)
 		} else {
 			if ((last_type & CH_RPT) && rep_count > 2) {
 				synth_printf(" ");
-				synth_printf(msg_get(MSG_REPEAT_DESC),
+				synth_printf(spk_msg_get(MSG_REPEAT_DESC),
 					     ++rep_count);
 				synth_printf(" ");
 			}
@@ -1074,7 +1074,7 @@ static void spkup_write(const char *in_buf, int count)
 		}
 		if (ch == spk_lastkey) {
 			rep_count = 0;
-			if (key_echo == 1 && ch >= MINECHOCHAR)
+			if (spk_key_echo == 1 && ch >= MINECHOCHAR)
 				speak_char(ch);
 		} else if (char_type & B_ALPHA) {
 			if ((synth_flags & SF_DEC) && (last_type & PUNC))
@@ -1083,7 +1083,7 @@ static void spkup_write(const char *in_buf, int count)
 		} else if (char_type & B_NUM) {
 			rep_count = 0;
 			synth_printf("%c", ch);
-		} else if (char_type & punc_mask) {
+		} else if (char_type & spk_punc_mask) {
 			speak_char(ch);
 			char_type &= ~PUNC;	/* for dec nospell processing */
 		} else if (char_type & SYNTH_OK) {
@@ -1111,7 +1111,7 @@ static void spkup_write(const char *in_buf, int count)
 	if (in_count > 2 && rep_count > 2) {
 		if (last_type & CH_RPT) {
 			synth_printf(" ");
-			synth_printf(msg_get(MSG_REPEAT_DESC2), ++rep_count);
+			synth_printf(spk_msg_get(MSG_REPEAT_DESC2), ++rep_count);
 			synth_printf(" ");
 		}
 		rep_count = 0;
@@ -1135,22 +1135,22 @@ static void do_handle_shift(struct vc_data *vc, u_char value, char up_flag)
 		case KVAL(K_SHIFT):
 			del_timer(&cursor_timer);
 			spk_shut_up &= 0xfe;
-			do_flush();
+			spk_do_flush();
 			read_all_doc(vc);
 			break;
 		case KVAL(K_CTRL):
 			del_timer(&cursor_timer);
 			cursor_track = prev_cursor_track;
 			spk_shut_up &= 0xfe;
-			do_flush();
+			spk_do_flush();
 			break;
 		}
 	} else {
 		spk_shut_up &= 0xfe;
-		do_flush();
+		spk_do_flush();
 	}
-	if (say_ctrl && value < NUM_CTL_LABELS)
-		synth_printf("%s", msg_get(MSG_CTL_START + value));
+	if (spk_say_ctrl && value < NUM_CTL_LABELS)
+		synth_printf("%s", spk_msg_get(MSG_CTL_START + value));
 	spk_unlock(flags);
 }
 
@@ -1171,12 +1171,12 @@ static void do_handle_latin(struct vc_data *vc, u_char value, char up_flag)
 	spk_lastkey = value;
 	spk_keydown++;
 	spk_parked &= 0xfe;
-	if (key_echo == 2 && value >= MINECHOCHAR)
+	if (spk_key_echo == 2 && value >= MINECHOCHAR)
 		speak_char(value);
 	spk_unlock(flags);
 }
 
-int set_key_info(const u_char *key_info, u_char *k_buffer)
+int spk_set_key_info(const u_char *key_info, u_char *k_buffer)
 {
 	int i = 0, states, key_data_len;
 	const u_char *cp = key_info;
@@ -1188,12 +1188,12 @@ int set_key_info(const u_char *key_info, u_char *k_buffer)
 	num_keys = *cp;
 	states = (int)cp[1];
 	key_data_len = (states + 1) * (num_keys + 1);
-	if (key_data_len + SHIFT_TBL_SIZE + 4 >= sizeof(key_buf))
+	if (key_data_len + SHIFT_TBL_SIZE + 4 >= sizeof(spk_key_buf))
 		return -2;
 	memset(k_buffer, 0, SHIFT_TBL_SIZE);
-	memset(our_keys, 0, sizeof(our_keys));
-	shift_table = k_buffer;
-	our_keys[0] = shift_table;
+	memset(spk_our_keys, 0, sizeof(spk_our_keys));
+	spk_shift_table = k_buffer;
+	spk_our_keys[0] = spk_shift_table;
 	cp1 += SHIFT_TBL_SIZE;
 	memcpy(cp1, cp, key_data_len + 3);
 	/* get num_keys, states and data */
@@ -1202,13 +1202,13 @@ int set_key_info(const u_char *key_info, u_char *k_buffer)
 		ch = *cp1++;
 		if (ch >= SHIFT_TBL_SIZE)
 			return -3;
-		shift_table[ch] = i;
+		spk_shift_table[ch] = i;
 	}
 	keymap_flags = *cp1++;
 	while ((ch = *cp1)) {
 		if (ch >= MAX_KEY)
 			return -4;
-		our_keys[ch] = cp1;
+		spk_our_keys[ch] = cp1;
 		cp1 += states + 1;
 	}
 	return 0;
@@ -1237,24 +1237,24 @@ static void toggle_cursoring(struct vc_data *vc)
 		cursor_track = prev_cursor_track;
 	if (++cursor_track >= CT_Max)
 		cursor_track = 0;
-	synth_printf("%s\n", msg_get(MSG_CURSOR_MSGS_START + cursor_track));
+	synth_printf("%s\n", spk_msg_get(MSG_CURSOR_MSGS_START + cursor_track));
 }
 
-void reset_default_chars(void)
+void spk_reset_default_chars(void)
 {
 	int i;
 
 	/* First, free any non-default */
 	for (i = 0; i < 256; i++) {
-		if ((characters[i] != NULL)
-		    && (characters[i] != default_chars[i]))
-			kfree(characters[i]);
+		if ((spk_characters[i] != NULL)
+		    && (spk_characters[i] != spk_default_chars[i]))
+			kfree(spk_characters[i]);
 	}
 
-	memcpy(characters, default_chars, sizeof(default_chars));
+	memcpy(spk_characters, spk_default_chars, sizeof(spk_default_chars));
 }
 
-void reset_default_chartab(void)
+void spk_reset_default_chartab(void)
 {
 	memcpy(spk_chartab, default_chartab, sizeof(default_chartab));
 }
@@ -1267,8 +1267,8 @@ static int edit_bits(struct vc_data *vc, u_char type, u_char ch, u_short key)
 	if (type != KT_LATIN || (ch_type & B_NUM) || ch < SPACE)
 		return -1;
 	if (ch == SPACE) {
-		synth_printf("%s\n", msg_get(MSG_EDIT_DONE));
-		special_handler = NULL;
+		synth_printf("%s\n", spk_msg_get(MSG_EDIT_DONE));
+		spk_special_handler = NULL;
 		return 1;
 	}
 	if (mask < PUNC && !(ch_type & PUNC))
@@ -1276,8 +1276,8 @@ static int edit_bits(struct vc_data *vc, u_char type, u_char ch, u_short key)
 	spk_chartab[ch] ^= mask;
 	speak_char(ch);
 	synth_printf(" %s\n",
-		     (spk_chartab[ch] & mask) ? msg_get(MSG_ON) :
-		     msg_get(MSG_OFF));
+		     (spk_chartab[ch] & mask) ? spk_msg_get(MSG_ON) :
+		     spk_msg_get(MSG_OFF));
 	return 1;
 }
 
@@ -1346,7 +1346,7 @@ static void read_all_doc(struct vc_data *vc)
 	if (cursor_track != read_all_mode)
 		prev_cursor_track = cursor_track;
 	cursor_track = read_all_mode;
-	reset_index_count(0);
+	spk_reset_index_count(0);
 	if (get_sentence_buf(vc, 0) == -1)
 		kbd_fakekey2(vc, RA_DOWN_ARROW);
 	else {
@@ -1361,7 +1361,7 @@ static void stop_read_all(struct vc_data *vc)
 	del_timer(&cursor_timer);
 	cursor_track = prev_cursor_track;
 	spk_shut_up &= 0xfe;
-	do_flush();
+	spk_do_flush();
 }
 
 static void start_read_all_timer(struct vc_data *vc, int command)
@@ -1370,7 +1370,7 @@ static void start_read_all_timer(struct vc_data *vc, int command)
 
 	cursor_con = vc->vc_num;
 	read_all_key = command;
-	cursor_timeout = get_var(CURSOR_TIME);
+	cursor_timeout = spk_get_var(CURSOR_TIME);
 	mod_timer(&cursor_timer,
 		  jiffies + msecs_to_jiffies(cursor_timeout->u.n.value));
 }
@@ -1382,9 +1382,9 @@ static void handle_cursor_read_all(struct vc_data *vc, int command)
 	switch (command) {
 	case RA_NEXT_SENT:
 		/* Get Current Sentence */
-		get_index_count(&indcount, &sentcount);
+		spk_get_index_count(&indcount, &sentcount);
 		/*printk("%d %d  ", indcount, sentcount); */
-		reset_index_count(sentcount + 1);
+		spk_reset_index_count(sentcount + 1);
 		if (indcount == 1) {
 			if (!say_sentence_num(sentcount + 1, 0)) {
 				kbd_fakekey2(vc, RA_FIND_NEXT_SENT);
@@ -1395,7 +1395,7 @@ static void handle_cursor_read_all(struct vc_data *vc, int command)
 			sn = 0;
 			if (!say_sentence_num(sentcount + 1, 1)) {
 				sn = 1;
-				reset_index_count(sn);
+				spk_reset_index_count(sn);
 			} else
 				synth_insert_next_index(0);
 			if (!say_sentence_num(sn, 0)) {
@@ -1437,7 +1437,7 @@ static void handle_cursor_read_all(struct vc_data *vc, int command)
 	case RA_FIND_PREV_SENT:
 		break;
 	case RA_TIMER:
-		get_index_count(&indcount, &sentcount);
+		spk_get_index_count(&indcount, &sentcount);
 		if (indcount < 2)
 			kbd_fakekey2(vc, RA_DOWN_ARROW);
 		else
@@ -1458,7 +1458,7 @@ static int pre_handle_cursor(struct vc_data *vc, u_char value, char up_flag)
 		}
 		del_timer(&cursor_timer);
 		spk_shut_up &= 0xfe;
-		do_flush();
+		spk_do_flush();
 		start_read_all_timer(vc, value + 1);
 		spk_unlock(flags);
 		return NOTIFY_STOP;
@@ -1479,8 +1479,8 @@ static void do_handle_cursor(struct vc_data *vc, u_char value, char up_flag)
 		return;
 	}
 	spk_shut_up &= 0xfe;
-	if (no_intr)
-		do_flush();
+	if (spk_no_intr)
+		spk_do_flush();
 /* the key press flushes if !no_inter but we want to flush on cursor
  * moves regardless of no_inter state */
 	is_cursor = value + 1;
@@ -1491,7 +1491,7 @@ static void do_handle_cursor(struct vc_data *vc, u_char value, char up_flag)
 	cursor_con = vc->vc_num;
 	if (cursor_track == CT_Highlight)
 		reset_highlight_buffers(vc);
-	cursor_timeout = get_var(CURSOR_TIME);
+	cursor_timeout = spk_get_var(CURSOR_TIME);
 	mod_timer(&cursor_timer,
 		  jiffies + msecs_to_jiffies(cursor_timeout->u.n.value));
 	spk_unlock(flags);
@@ -1603,7 +1603,7 @@ static int speak_highlight(struct vc_data *vc)
 			if (speakup_console[vc_num]->ht.ry[hc] != vc->vc_y)
 				return 0;
 		spk_parked |= 0x01;
-		do_flush();
+		spk_do_flush();
 		spkup_write(speakup_console[vc_num]->ht.highbuf[hc],
 			    speakup_console[vc_num]->ht.highsize[hc]);
 		spk_pos = spk_cp = speakup_console[vc_num]->ht.rpos[hc];
@@ -1685,7 +1685,7 @@ static void speakup_con_write(struct vc_data *vc, const char *str, int len)
 	if (!spk_trylock(flags))
 		/* Speakup output, discard */
 		return;
-	if (bell_pos && spk_keydown && (vc->vc_x == bell_pos - 1))
+	if (spk_bell_pos && spk_keydown && (vc->vc_x == spk_bell_pos - 1))
 		bleep(3);
 	if ((is_cursor) || (cursor_track == read_all_mode)) {
 		if (cursor_track == CT_Highlight)
@@ -1726,19 +1726,19 @@ static void do_handle_spec(struct vc_data *vc, u_char value, char up_flag)
 		return;
 	spk_lock(flags);
 	spk_shut_up &= 0xfe;
-	if (no_intr)
-		do_flush();
+	if (spk_no_intr)
+		spk_do_flush();
 	switch (value) {
 	case KVAL(K_CAPS):
-		label = msg_get(MSG_KEYNAME_CAPSLOCK);
+		label = spk_msg_get(MSG_KEYNAME_CAPSLOCK);
 		on_off = vt_get_leds(fg_console, VC_CAPSLOCK);
 		break;
 	case KVAL(K_NUM):
-		label = msg_get(MSG_KEYNAME_NUMLOCK);
+		label = spk_msg_get(MSG_KEYNAME_NUMLOCK);
 		on_off = vt_get_leds(fg_console, VC_NUMLOCK);
 		break;
 	case KVAL(K_HOLD):
-		label = msg_get(MSG_KEYNAME_SCROLLLOCK);
+		label = spk_msg_get(MSG_KEYNAME_SCROLLLOCK);
 		on_off = vt_get_leds(fg_console, VC_SCROLLOCK);
 		if (speakup_console[vc->vc_num])
 			speakup_console[vc->vc_num]->tty_stopped = on_off;
@@ -1750,7 +1750,7 @@ static void do_handle_spec(struct vc_data *vc, u_char value, char up_flag)
 	}
 	if (on_off < 2)
 		synth_printf("%s %s\n",
-			     label, msg_get(MSG_STATUS_START + on_off));
+			     label, spk_msg_get(MSG_STATUS_START + on_off));
 	spk_unlock(flags);
 }
 
@@ -1764,13 +1764,13 @@ static int inc_dec_var(u_char value)
 	int var_id = (int)value - VAR_START;
 	int how = (var_id & 1) ? E_INC : E_DEC;
 	var_id = var_id / 2 + FIRST_SET_VAR;
-	p_header = get_var_header(var_id);
+	p_header = spk_get_var_header(var_id);
 	if (p_header == NULL)
 		return -1;
 	if (p_header->var_type != VAR_NUM)
 		return -1;
 	var_data = p_header->data;
-	if (set_num_var(1, p_header, how) != 0)
+	if (spk_set_num_var(1, p_header, how) != 0)
 		return -1;
 	if (!spk_close_press) {
 		for (pn = p_header->name; *pn; pn++) {
@@ -1790,18 +1790,18 @@ static void speakup_win_set(struct vc_data *vc)
 {
 	char info[40];
 	if (win_start > 1) {
-		synth_printf("%s\n", msg_get(MSG_WINDOW_ALREADY_SET));
+		synth_printf("%s\n", spk_msg_get(MSG_WINDOW_ALREADY_SET));
 		return;
 	}
 	if (spk_x < win_left || spk_y < win_top) {
-		synth_printf("%s\n", msg_get(MSG_END_BEFORE_START));
+		synth_printf("%s\n", spk_msg_get(MSG_END_BEFORE_START));
 		return;
 	}
 	if (win_start && spk_x == win_left && spk_y == win_top) {
 		win_left = 0;
 		win_right = vc->vc_cols - 1;
 		win_bottom = spk_y;
-		snprintf(info, sizeof(info), msg_get(MSG_WINDOW_LINE),
+		snprintf(info, sizeof(info), spk_msg_get(MSG_WINDOW_LINE),
 			 (int)win_top + 1);
 	} else {
 		if (!win_start) {
@@ -1811,8 +1811,8 @@ static void speakup_win_set(struct vc_data *vc)
 			win_bottom = spk_y;
 			win_right = spk_x;
 		}
-		snprintf(info, sizeof(info), msg_get(MSG_WINDOW_BOUNDARY),
-			 (win_start) ? msg_get(MSG_END) : msg_get(MSG_START),
+		snprintf(info, sizeof(info), spk_msg_get(MSG_WINDOW_BOUNDARY),
+			 (win_start) ? spk_msg_get(MSG_END) : spk_msg_get(MSG_START),
 			 (int)spk_y + 1, (int)spk_x + 1);
 	}
 	synth_printf("%s\n", info);
@@ -1824,32 +1824,32 @@ static void speakup_win_clear(struct vc_data *vc)
 	win_top = win_bottom = 0;
 	win_left = win_right = 0;
 	win_start = 0;
-	synth_printf("%s\n", msg_get(MSG_WINDOW_CLEARED));
+	synth_printf("%s\n", spk_msg_get(MSG_WINDOW_CLEARED));
 }
 
 static void speakup_win_enable(struct vc_data *vc)
 {
 	if (win_start < 2) {
-		synth_printf("%s\n", msg_get(MSG_NO_WINDOW));
+		synth_printf("%s\n", spk_msg_get(MSG_NO_WINDOW));
 		return;
 	}
 	win_enabled ^= 1;
 	if (win_enabled)
-		synth_printf("%s\n", msg_get(MSG_WINDOW_SILENCED));
+		synth_printf("%s\n", spk_msg_get(MSG_WINDOW_SILENCED));
 	else
-		synth_printf("%s\n", msg_get(MSG_WINDOW_SILENCE_DISABLED));
+		synth_printf("%s\n", spk_msg_get(MSG_WINDOW_SILENCE_DISABLED));
 }
 
 static void speakup_bits(struct vc_data *vc)
 {
 	int val = this_speakup_key - (FIRST_EDIT_BITS - 1);
-	if (special_handler != NULL || val < 1 || val > 6) {
-		synth_printf("%s\n", msg_get(MSG_ERROR));
+	if (spk_special_handler != NULL || val < 1 || val > 6) {
+		synth_printf("%s\n", spk_msg_get(MSG_ERROR));
 		return;
 	}
-	pb_edit = &punc_info[val];
-	synth_printf(msg_get(MSG_EDIT_PROMPT), pb_edit->name);
-	special_handler = edit_bits;
+	pb_edit = &spk_punc_info[val];
+	synth_printf(spk_msg_get(MSG_EDIT_PROMPT), pb_edit->name);
+	spk_special_handler = edit_bits;
 }
 
 static int handle_goto(struct vc_data *vc, u_char type, u_char ch, u_short key)
@@ -1887,9 +1887,9 @@ static int handle_goto(struct vc_data *vc, u_char type, u_char ch, u_short key)
 	if (ch < 'x' || ch > 'y') {
 oops:
 		if (!spk_killed)
-			synth_printf(" %s\n", msg_get(MSG_GOTO_CANCELED));
+			synth_printf(" %s\n", spk_msg_get(MSG_GOTO_CANCELED));
 		goto_buf[num = 0] = '\0';
-		special_handler = NULL;
+		spk_special_handler = NULL;
 		return 1;
 	}
 	cp = speakup_s2i(goto_buf, &go_pos);
@@ -1917,7 +1917,7 @@ static int handle_goto(struct vc_data *vc, u_char type, u_char ch, u_short key)
 	}
 	goto_buf[num = 0] = '\0';
 do_goto:
-	special_handler = NULL;
+	spk_special_handler = NULL;
 	spk_parked |= 0x01;
 	if (goto_x) {
 		spk_pos -= spk_x * 2;
@@ -1934,18 +1934,18 @@ static int handle_goto(struct vc_data *vc, u_char type, u_char ch, u_short key)
 
 static void speakup_goto(struct vc_data *vc)
 {
-	if (special_handler != NULL) {
-		synth_printf("%s\n", msg_get(MSG_ERROR));
+	if (spk_special_handler != NULL) {
+		synth_printf("%s\n", spk_msg_get(MSG_ERROR));
 		return;
 	}
-	synth_printf("%s\n", msg_get(MSG_GOTO));
-	special_handler = handle_goto;
+	synth_printf("%s\n", spk_msg_get(MSG_GOTO));
+	spk_special_handler = handle_goto;
 	return;
 }
 
 static void speakup_help(struct vc_data *vc)
 {
-	handle_help(vc, KT_SPKUP, SPEAKUP_HELP, 0);
+	spk_handle_help(vc, KT_SPKUP, SPEAKUP_HELP, 0);
 }
 
 static void do_nothing(struct vc_data *vc)
@@ -1992,7 +1992,7 @@ static void do_spkup(struct vc_data *vc, u_char value)
 	spk_shut_up &= 0xfe;
 	this_speakup_key = value;
 	if (value < SPKUP_MAX_FUNC && spkup_handler[value]) {
-		do_flush();
+		spk_do_flush();
 		(*spkup_handler[value]) (vc);
 	} else {
 		if (inc_dec_var(value) < 0)
@@ -2032,7 +2032,7 @@ speakup_key(struct vc_data *vc, int shift_state, int keycode, u_short keysym,
 	}
 	if (keycode >= MAX_KEY)
 		goto no_map;
-	key_info = our_keys[keycode];
+	key_info = spk_our_keys[keycode];
 	if (key_info == 0)
 		goto no_map;
 	/* Check valid read all mode keys */
@@ -2051,7 +2051,7 @@ speakup_key(struct vc_data *vc, int shift_state, int keycode, u_short keysym,
 		}
 	}
 	shift_info = (shift_state & 0x0f) + key_speakup;
-	offset = shift_table[shift_info];
+	offset = spk_shift_table[shift_info];
 	if (offset) {
 		new_key = key_info[offset];
 		if (new_key) {
@@ -2062,7 +2062,7 @@ speakup_key(struct vc_data *vc, int shift_state, int keycode, u_short keysym,
 				if (up_flag || spk_killed)
 					goto out;
 				spk_shut_up &= 0xfe;
-				do_flush();
+				spk_do_flush();
 				goto out;
 			}
 			if (up_flag)
@@ -2070,7 +2070,7 @@ speakup_key(struct vc_data *vc, int shift_state, int keycode, u_short keysym,
 			if (last_keycode == keycode &&
 			    last_spk_jiffy + MAX_DELAY > jiffies) {
 				spk_close_press = 1;
-				offset = shift_table[shift_info + 32];
+				offset = spk_shift_table[shift_info + 32];
 				/* double press? */
 				if (offset && key_info[offset])
 					new_key = key_info[offset];
@@ -2082,7 +2082,7 @@ speakup_key(struct vc_data *vc, int shift_state, int keycode, u_short keysym,
 		}
 	}
 no_map:
-	if (type == KT_SPKUP && special_handler == NULL) {
+	if (type == KT_SPKUP && spk_special_handler == NULL) {
 		do_spkup(vc, new_key);
 		spk_close_press = 0;
 		ret = 1;
@@ -2096,9 +2096,9 @@ speakup_key(struct vc_data *vc, int shift_state, int keycode, u_short keysym,
 	    || (value == KVAL(K_LEFT))
 	    || (value == KVAL(K_RIGHT));
 	if ((cursor_track != read_all_mode) || !kh)
-		if (!no_intr)
-			do_flush();
-	if (special_handler) {
+		if (!spk_no_intr)
+			spk_do_flush();
+	if (spk_special_handler) {
 		if (type == KT_SPEC && value == 1) {
 			value = '\n';
 			type = KT_LATIN;
@@ -2106,7 +2106,7 @@ speakup_key(struct vc_data *vc, int shift_state, int keycode, u_short keysym,
 			type = KT_LATIN;
 		else if (value == 0x7f)
 			value = 8;	/* make del = backspace */
-		ret = (*special_handler) (vc, type, value, keycode);
+		ret = (*spk_special_handler) (vc, type, value, keycode);
 		spk_close_press = 0;
 		if (ret < 0)
 			bleep(9);
@@ -2237,11 +2237,11 @@ static void __exit speakup_exit(void)
 		speakup_unregister_var(i);
 
 	for (i = 0; i < 256; i++) {
-		if (characters[i] != default_chars[i])
-			kfree(characters[i]);
+		if (spk_characters[i] != spk_default_chars[i])
+			kfree(spk_characters[i]);
 	}
 
-	free_user_msgs();
+	spk_free_user_msgs();
 }
 
 /* call by: module_init() */
@@ -2254,20 +2254,20 @@ static int __init speakup_init(void)
 	struct var_t *var;
 
 	/* These first few initializations cannot fail. */
-	initialize_msgs();	/* Initialize arrays for i18n. */
-	reset_default_chars();
-	reset_default_chartab();
-	strlwr(synth_name);
+	spk_initialize_msgs();	/* Initialize arrays for i18n. */
+	spk_reset_default_chars();
+	spk_reset_default_chartab();
+	spk_strlwr(synth_name);
 	spk_vars[0].u.n.high = vc->vc_cols;
 	for (var = spk_vars; var->var_id != MAXVARS; var++)
 		speakup_register_var(var);
 	for (var = synth_time_vars;
 	     (var->var_id >= 0) && (var->var_id < MAXVARS); var++)
 		speakup_register_var(var);
-	for (i = 1; punc_info[i].mask != 0; i++)
-		set_mask_bits(0, i, 2);
+	for (i = 1; spk_punc_info[i].mask != 0; i++)
+		spk_set_mask_bits(0, i, 2);
 
-	set_key_info(key_defaults, key_buf);
+	spk_set_key_info(spk_key_defaults, spk_key_buf);
 
 	/* From here on out, initializations can fail. */
 	err = speakup_add_virtual_keyboard();
@@ -2290,7 +2290,7 @@ static int __init speakup_init(void)
 				goto error_kobjects;
 		}
 
-	if (quiet_boot)
+	if (spk_quiet_boot)
 		spk_shut_up |= 0x01;
 
 	err = speakup_kobj_init();
@@ -2352,11 +2352,11 @@ static int __init speakup_init(void)
 		speakup_unregister_var(i);
 
 	for (i = 0; i < 256; i++) {
-		if (characters[i] != default_chars[i])
-			kfree(characters[i]);
+		if (spk_characters[i] != spk_default_chars[i])
+			kfree(spk_characters[i]);
 	}
 
-	free_user_msgs();
+	spk_free_user_msgs();
 
 out:
 	return err;

commit 4ea418b8b2fa8a70d0fcc8231b65e67b3a72984b
Author: Christopher Brannon <chris@the-brannons.com>
Date:   Sat Jun 16 16:55:20 2012 -0500

    Staging: speakup: fix an improperly-declared variable.
    
    A local static variable was declared as a pointer to a string
    constant.  We're assigning to the underlying memory, so it
    needs to be an array instead.
    
    Signed-off-by: Christopher Brannon <chris@the-brannons.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/speakup/main.c b/drivers/staging/speakup/main.c
index 92b34e29ad06..40e2488b9679 100644
--- a/drivers/staging/speakup/main.c
+++ b/drivers/staging/speakup/main.c
@@ -1854,7 +1854,7 @@ static void speakup_bits(struct vc_data *vc)
 
 static int handle_goto(struct vc_data *vc, u_char type, u_char ch, u_short key)
 {
-	static u_char *goto_buf = "\0\0\0\0\0\0";
+	static u_char goto_buf[8];
 	static int num;
 	int maxlen, go_pos;
 	char *cp;

commit 079c9534a96da9a85a2a2f9715851050fbfbf749
Author: Alan Cox <alan@linux.intel.com>
Date:   Tue Feb 28 14:49:23 2012 +0000

    vt:tackle kbd_table
    
    Keyboard struct lifetime is easy, but the locking is not and is completely
    ignored by the existing code. Tackle this one head on
    
    - Make the kbd_table private so we can run down all direct users
    - Hoick the relevant ioctl handlers into the keyboard layer
    - Lock them with the keyboard lock so they don't change mid keypress
    - Add helpers for things like console stop/start so we isolate the poking
      around properly
    - Tweak the braille console so it still builds
    
    There are a couple of FIXME locking cases left for ioctls that are so hideous
    they should be addressed in a later patch. After this patch the kbd_table is
    private and all the keyboard jiggery pokery is in one place.
    
    This update fixes speakup and also a memory leak in the original.
    
    Signed-off-by: Alan Cox <alan@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/speakup/main.c b/drivers/staging/speakup/main.c
index c7b03f0ef2dd..92b34e29ad06 100644
--- a/drivers/staging/speakup/main.c
+++ b/drivers/staging/speakup/main.c
@@ -1731,15 +1731,15 @@ static void do_handle_spec(struct vc_data *vc, u_char value, char up_flag)
 	switch (value) {
 	case KVAL(K_CAPS):
 		label = msg_get(MSG_KEYNAME_CAPSLOCK);
-		on_off = (vc_kbd_led(kbd_table + vc->vc_num, VC_CAPSLOCK));
+		on_off = vt_get_leds(fg_console, VC_CAPSLOCK);
 		break;
 	case KVAL(K_NUM):
 		label = msg_get(MSG_KEYNAME_NUMLOCK);
-		on_off = (vc_kbd_led(kbd_table + vc->vc_num, VC_NUMLOCK));
+		on_off = vt_get_leds(fg_console, VC_NUMLOCK);
 		break;
 	case KVAL(K_HOLD):
 		label = msg_get(MSG_KEYNAME_SCROLLLOCK);
-		on_off = (vc_kbd_led(kbd_table + vc->vc_num, VC_SCROLLOCK));
+		on_off = vt_get_leds(fg_console, VC_SCROLLOCK);
 		if (speakup_console[vc->vc_num])
 			speakup_console[vc->vc_num]->tty_stopped = on_off;
 		break;
@@ -2020,7 +2020,7 @@ speakup_key(struct vc_data *vc, int shift_state, int keycode, u_short keysym,
 	if (type >= 0xf0)
 		type -= 0xf0;
 	if (type == KT_PAD
-		&& (vc_kbd_led(kbd_table + fg_console, VC_NUMLOCK))) {
+		&& (vt_get_leds(fg_console, VC_NUMLOCK))) {
 		if (up_flag) {
 			spk_keydown = 0;
 			goto out;

commit 4afaee1561e207683dbb886b30a842ffcc22e366
Author: Christopher Brannon <chris@the-brannons.com>
Date:   Tue Nov 22 13:46:23 2011 -0600

    Staging: speakup: Don't try to access an unallocated struct.
    
    In speakup_init, we have the following:
            if (quiet_boot)
                    spk_shut_up |= 0x01;
    And in spk_types.h:
    This patch moves the statement in speakup_init so that
    speakup_console[vc->vc_num] is guaranteed to be allocated when it
    executes.
    
    Signed-off-by: Christopher Brannon <chris@the-brannons.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/speakup/main.c b/drivers/staging/speakup/main.c
index 8be560458977..c7b03f0ef2dd 100644
--- a/drivers/staging/speakup/main.c
+++ b/drivers/staging/speakup/main.c
@@ -2268,8 +2268,6 @@ static int __init speakup_init(void)
 		set_mask_bits(0, i, 2);
 
 	set_key_info(key_defaults, key_buf);
-	if (quiet_boot)
-		spk_shut_up |= 0x01;
 
 	/* From here on out, initializations can fail. */
 	err = speakup_add_virtual_keyboard();
@@ -2292,6 +2290,9 @@ static int __init speakup_init(void)
 				goto error_kobjects;
 		}
 
+	if (quiet_boot)
+		spk_shut_up |= 0x01;
+
 	err = speakup_kobj_init();
 	if (err)
 		goto error_kobjects;

commit 37ca936e1d83041ac9981bd31802b2c28f36ce93
Author: Jesper Juhl <jj@chaosbits.net>
Date:   Fri Jun 24 01:01:50 2011 +0200

    Remove unneeded version.h includes from drivers/staging/speakup/
    
    It was pointed out by 'make versioncheck' that some includes of
    linux/version.h are not needed in drivers/staging/speakup/.
    This patch removes them.
    
    Signed-off-by: Jesper Juhl <jj@chaosbits.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/speakup/main.c b/drivers/staging/speakup/main.c
index 42fcf7e9cb64..8be560458977 100644
--- a/drivers/staging/speakup/main.c
+++ b/drivers/staging/speakup/main.c
@@ -23,7 +23,6 @@
 */
 
 #include <linux/kernel.h>
-#include <linux/version.h>
 #include <linux/vt.h>
 #include <linux/tty.h>
 #include <linux/mm.h>		/* __get_free_page() and friends */

commit 39dd3e5d7b09b5a5010ed1aef512f2d58b65cb99
Author: Ilia Mirkin <imirkin@alum.mit.edu>
Date:   Sun Mar 13 00:29:10 2011 -0500

    staging: speakup: Remove NULL check before kfree
    
    This patch was generated by the following semantic patch:
    // <smpl>
    @@ expression E; @@
    - if (E != NULL) { kfree(E); }
    + kfree(E);
    
    @@ expression E; @@
    - if (E != NULL) { kfree(E); E = NULL; }
    + kfree(E);
    + E = NULL;
    // </smpl>
    
    Signed-off-by: Ilia Mirkin <imirkin@alum.mit.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/speakup/main.c b/drivers/staging/speakup/main.c
index cd981a13c12d..42fcf7e9cb64 100644
--- a/drivers/staging/speakup/main.c
+++ b/drivers/staging/speakup/main.c
@@ -1305,10 +1305,8 @@ void speakup_deallocate(struct vc_data *vc)
 	int vc_num;
 
 	vc_num = vc->vc_num;
-	if (speakup_console[vc_num] != NULL) {
-		kfree(speakup_console[vc_num]);
-		speakup_console[vc_num] = NULL;
-	}
+	kfree(speakup_console[vc_num]);
+	speakup_console[vc_num] = NULL;
 }
 
 static u_char is_cursor;

commit 628f34282db49359576dcb8cbaea65b4bf083ebd
Author: Christopher Brannon <chris@the-brannons.com>
Date:   Sun Dec 19 22:50:24 2010 +0000

    staging: speakup: more fixes for init-failure handling.
    
    We still leaked many resources when Speakup failed to initialize.
    Examples of leaked resources include:
    /dev/synth, keyboard or VT notifiers, and heap-allocated st_spk_t
    structs.
    This is fixed.
    
    * We now use PTR_ERR to detect kthread_create failure
    (thank you Dan Carpenter).
    
    * The loop which frees members of the speakup_console array now iterates
    over the whole array, not stopping at the first NULL value.  Fixes
    a possible memory leak.  Safe because kfree(NULL) is a no-op.
    
    * The order of some initializations was changed.  The safe ones, which
    will never fail, are performed first.
    
    Signed-off-by: Christopher Brannon <chris@the-brannons.com>
    Acked-by: Dan Carpenter <error27@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/speakup/main.c b/drivers/staging/speakup/main.c
index 3cd00396a462..cd981a13c12d 100644
--- a/drivers/staging/speakup/main.c
+++ b/drivers/staging/speakup/main.c
@@ -1283,7 +1283,7 @@ static int edit_bits(struct vc_data *vc, u_char type, u_char ch, u_short key)
 }
 
 /* Allocation concurrency is protected by the console semaphore */
-void speakup_allocate(struct vc_data *vc)
+int speakup_allocate(struct vc_data *vc)
 {
 	int vc_num;
 
@@ -1292,10 +1292,12 @@ void speakup_allocate(struct vc_data *vc)
 		speakup_console[vc_num] = kzalloc(sizeof(*speakup_console[0]),
 						  GFP_ATOMIC);
 		if (speakup_console[vc_num] == NULL)
-			return;
+			return -ENOMEM;
 		speakup_date(vc);
 	} else if (!spk_parked)
 		speakup_date(vc);
+
+	return 0;
 }
 
 void speakup_deallocate(struct vc_data *vc)
@@ -2217,18 +2219,23 @@ static void __exit speakup_exit(void)
 {
 	int i;
 
-	free_user_msgs();
 	unregister_keyboard_notifier(&keyboard_notifier_block);
 	unregister_vt_notifier(&vt_notifier_block);
 	speakup_unregister_devsynth();
 	del_timer(&cursor_timer);
-
 	kthread_stop(speakup_task);
 	speakup_task = NULL;
 	mutex_lock(&spk_mutex);
 	synth_release();
 	mutex_unlock(&spk_mutex);
 
+	speakup_kobj_exit();
+
+	for (i = 0; i < MAX_NR_CONSOLES; i++)
+		kfree(speakup_console[i]);
+
+	speakup_remove_virtual_keyboard();
+
 	for (i = 0; i < MAXVARS; i++)
 		speakup_unregister_var(i);
 
@@ -2236,42 +2243,23 @@ static void __exit speakup_exit(void)
 		if (characters[i] != default_chars[i])
 			kfree(characters[i]);
 	}
-	for (i = 0; speakup_console[i]; i++)
-		kfree(speakup_console[i]);
-	speakup_kobj_exit();
-	speakup_remove_virtual_keyboard();
+
+	free_user_msgs();
 }
 
 /* call by: module_init() */
 static int __init speakup_init(void)
 {
 	int i;
-	int err;
+	long err = 0;
 	struct st_spk_t *first_console;
 	struct vc_data *vc = vc_cons[fg_console].d;
 	struct var_t *var;
 
-	err = speakup_add_virtual_keyboard();
-	if (err)
-		goto out;
-
+	/* These first few initializations cannot fail. */
 	initialize_msgs();	/* Initialize arrays for i18n. */
-	first_console = kzalloc(sizeof(*first_console), GFP_KERNEL);
-	if (!first_console) {
-		err = -ENOMEM;
-		goto err_cons;
-	}
-	err = speakup_kobj_init();
-	if (err)
-		goto err_kobject;
-
 	reset_default_chars();
 	reset_default_chartab();
-
-	speakup_console[vc->vc_num] = first_console;
-	speakup_date(vc);
-	pr_info("speakup %s: initialized\n", SPEAKUP_VERSION);
-
 	strlwr(synth_name);
 	spk_vars[0].u.n.high = vc->vc_cols;
 	for (var = spk_vars; var->var_id != MAXVARS; var++)
@@ -2286,31 +2274,92 @@ static int __init speakup_init(void)
 	if (quiet_boot)
 		spk_shut_up |= 0x01;
 
+	/* From here on out, initializations can fail. */
+	err = speakup_add_virtual_keyboard();
+	if (err)
+		goto error_virtkeyboard;
+
+	first_console = kzalloc(sizeof(*first_console), GFP_KERNEL);
+	if (!first_console) {
+		err = -ENOMEM;
+		goto error_alloc;
+	}
+
+	speakup_console[vc->vc_num] = first_console;
+	speakup_date(vc);
+
 	for (i = 0; i < MAX_NR_CONSOLES; i++)
-		if (vc_cons[i].d)
-			speakup_allocate(vc_cons[i].d);
+		if (vc_cons[i].d) {
+			err = speakup_allocate(vc_cons[i].d);
+			if (err)
+				goto error_kobjects;
+		}
+
+	err = speakup_kobj_init();
+	if (err)
+		goto error_kobjects;
 
-	pr_warn("synth name on entry is: %s\n", synth_name);
 	synth_init(synth_name);
 	speakup_register_devsynth();
+	/*
+	 * register_devsynth might fail, but this error is not fatal.
+	 * /dev/synth is an extra feature; the rest of Speakup
+	 * will work fine without it.
+	 */
 
-	register_keyboard_notifier(&keyboard_notifier_block);
-	register_vt_notifier(&vt_notifier_block);
+	err = register_keyboard_notifier(&keyboard_notifier_block);
+	if (err)
+		goto error_kbdnotifier;
+	err = register_vt_notifier(&vt_notifier_block);
+	if (err)
+		goto error_vtnotifier;
 
 	speakup_task = kthread_create(speakup_thread, NULL, "speakup");
-	set_user_nice(speakup_task, 10);
+
 	if (IS_ERR(speakup_task)) {
-		err = -ENOMEM;
-		goto err_kobject;
+		err = PTR_ERR(speakup_task);
+		goto error_task;
 	}
+
+	set_user_nice(speakup_task, 10);
 	wake_up_process(speakup_task);
+
+	pr_info("speakup %s: initialized\n", SPEAKUP_VERSION);
+	pr_info("synth name on entry is: %s\n", synth_name);
 	goto out;
 
-err_kobject:
-speakup_kobj_exit();
-	kfree(first_console);
-err_cons:
+error_task:
+	unregister_vt_notifier(&vt_notifier_block);
+
+error_vtnotifier:
+	unregister_keyboard_notifier(&keyboard_notifier_block);
+	del_timer(&cursor_timer);
+
+error_kbdnotifier:
+	speakup_unregister_devsynth();
+	mutex_lock(&spk_mutex);
+	synth_release();
+	mutex_unlock(&spk_mutex);
+	speakup_kobj_exit();
+
+error_kobjects:
+	for (i = 0; i < MAX_NR_CONSOLES; i++)
+		kfree(speakup_console[i]);
+
+error_alloc:
 	speakup_remove_virtual_keyboard();
+
+error_virtkeyboard:
+	for (i = 0; i < MAXVARS; i++)
+		speakup_unregister_var(i);
+
+	for (i = 0; i < 256; i++) {
+		if (characters[i] != default_chars[i])
+			kfree(characters[i]);
+	}
+
+	free_user_msgs();
+
 out:
 	return err;
 }

commit 7959d55679e4360205c9ebc89d40a5503c53bae2
Author: William Hubbs <w.d.hubbs@gmail.com>
Date:   Thu Dec 16 13:26:58 2010 -0600

    staging: speakup: fix failure handling
    
    fix the failure handling in kobjects and the main function so that we
    release the virtual keyboard if we exit due to another failure.
    
    Signed-off-by: William Hubbs <w.d.hubbs@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/speakup/main.c b/drivers/staging/speakup/main.c
index 4b7a9c2b965f..3cd00396a462 100644
--- a/drivers/staging/speakup/main.c
+++ b/drivers/staging/speakup/main.c
@@ -2253,17 +2253,17 @@ static int __init speakup_init(void)
 
 	err = speakup_add_virtual_keyboard();
 	if (err)
-		return err;
+		goto out;
 
 	initialize_msgs();	/* Initialize arrays for i18n. */
 	first_console = kzalloc(sizeof(*first_console), GFP_KERNEL);
-	if (!first_console)
-		return -ENOMEM;
-	err = speakup_kobj_init();
-	if (err) {
-		kfree(first_console);
-		return err;
+	if (!first_console) {
+		err = -ENOMEM;
+		goto err_cons;
 	}
+	err = speakup_kobj_init();
+	if (err)
+		goto err_kobject;
 
 	reset_default_chars();
 	reset_default_chartab();
@@ -2299,11 +2299,20 @@ static int __init speakup_init(void)
 
 	speakup_task = kthread_create(speakup_thread, NULL, "speakup");
 	set_user_nice(speakup_task, 10);
-	if (!IS_ERR(speakup_task))
-		wake_up_process(speakup_task);
-	else
-		return -ENOMEM;
-	return 0;
+	if (IS_ERR(speakup_task)) {
+		err = -ENOMEM;
+		goto err_kobject;
+	}
+	wake_up_process(speakup_task);
+	goto out;
+
+err_kobject:
+speakup_kobj_exit();
+	kfree(first_console);
+err_cons:
+	speakup_remove_virtual_keyboard();
+out:
+	return err;
 }
 
 module_init(speakup_init);

commit b3495cebaaa64c9e6df9ab663dfb75e86a08f9ce
Author: Vasiliy Kulikov <segooon@gmail.com>
Date:   Sun Oct 17 18:51:57 2010 +0400

    staging: speakup: fix memory leak
    
    speakup_init() didn't free first_console if speakup_kobj_init() fails.
    Also propagate speakup_kobj_init()'s return code.
    
    Signed-off-by: Vasiliy Kulikov <segooon@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/speakup/main.c b/drivers/staging/speakup/main.c
index a64704bd19bf..4b7a9c2b965f 100644
--- a/drivers/staging/speakup/main.c
+++ b/drivers/staging/speakup/main.c
@@ -2259,8 +2259,11 @@ static int __init speakup_init(void)
 	first_console = kzalloc(sizeof(*first_console), GFP_KERNEL);
 	if (!first_console)
 		return -ENOMEM;
-	if (speakup_kobj_init() < 0)
-		return -ENOMEM;
+	err = speakup_kobj_init();
+	if (err) {
+		kfree(first_console);
+		return err;
+	}
 
 	reset_default_chars();
 	reset_default_chartab();

commit 16d355156ba475c0fefb19133174cdf61a5101ba
Author: William Hubbs <w.d.hubbs@gmail.com>
Date:   Fri Oct 15 22:13:34 2010 -0500

    staging: speakup: main.c style fixes
    
    - fix issues reported by checkpatch.pl
    - run code through Lindent
    - move some prototypes to speakup.h
    
    Signed-off-by: William Hubbs <w.d.hubbs@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/speakup/main.c b/drivers/staging/speakup/main.c
index 2ef3b3982a2d..a64704bd19bf 100644
--- a/drivers/staging/speakup/main.c
+++ b/drivers/staging/speakup/main.c
@@ -1,32 +1,32 @@
 /* speakup.c
-   review functions for the speakup screen review package.
-   originally written by: Kirk Reiser and Andy Berdan.
-
-  extensively modified by David Borowski.
-
-    Copyright (C) 1998  Kirk Reiser.
-    Copyright (C) 2003  David Borowski.
-
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; either version 2 of the License, or
-    (at your option) any later version.
-
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * review functions for the speakup screen review package.
+ * originally written by: Kirk Reiser and Andy Berdan.
+ *
+ * extensively modified by David Borowski.
+ *
+ ** Copyright (C) 1998  Kirk Reiser.
+ *  Copyright (C) 2003  David Borowski.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */
 
 #include <linux/kernel.h>
 #include <linux/version.h>
 #include <linux/vt.h>
 #include <linux/tty.h>
-#include <linux/mm.h> /* __get_free_page() and friends */
+#include <linux/mm.h>		/* __get_free_page() and friends */
 #include <linux/vt_kern.h>
 #include <linux/ctype.h>
 #include <linux/selection.h>
@@ -34,7 +34,7 @@
 #include <linux/jiffies.h>
 #include <linux/kthread.h>
 #include <linux/keyboard.h>	/* for KT_SHIFT */
-#include <linux/kbd_kern.h> /* for vc_kbd_* and friends */
+#include <linux/kbd_kern.h>	/* for vc_kbd_* and friends */
 #include <linux/input.h>
 #include <linux/kmod.h>
 
@@ -50,7 +50,7 @@
 #include <linux/spinlock.h>
 #include <linux/notifier.h>
 
-#include <linux/uaccess.h> /* copy_from|to|user() and others */
+#include <linux/uaccess.h>	/* copy_from|to|user() and others */
 
 #include "spk_priv.h"
 #include "speakup.h"
@@ -81,18 +81,19 @@ int key_echo, say_word_ctl;
 int say_ctrl, bell_pos;
 short punc_mask;
 int punc_level, reading_punc;
-char str_caps_start[MAXVARLEN+1] = "\0", str_caps_stop[MAXVARLEN+1] = "\0";
+char str_caps_start[MAXVARLEN + 1] = "\0", str_caps_stop[MAXVARLEN + 1] = "\0";
 const struct st_bits_data punc_info[] = {
-	{ "none", "", 0 },
-	{ "some", "/$%&@", SOME },
-	{ "most", "$%&#()=+*/@^<>|\\", MOST },
-	{ "all", "!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~", PUNC },
-	{ "delimiters", "", B_WDLM },
-	{ "repeats", "()", CH_RPT },
-	{ "extended numeric", "", B_EXNUM },
-	{ "symbols", "", B_SYM },
-	{ 0, 0 }
+	{"none", "", 0},
+	{"some", "/$%&@", SOME},
+	{"most", "$%&#()=+*/@^<>|\\", MOST},
+	{"all", "!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~", PUNC},
+	{"delimiters", "", B_WDLM},
+	{"repeats", "()", CH_RPT},
+	{"extended numeric", "", B_EXNUM},
+	{"symbols", "", B_SYM},
+	{0, 0}
 };
+
 static char mark_cut_flag;
 #define MAX_KEY 160
 u_char *our_keys[MAX_KEY], *shift_table;
@@ -118,10 +119,10 @@ static struct tty_struct *tty;
 
 static void spkup_write(const char *in_buf, int count);
 
-
 static char *phonetic[] = {
 	"alfa", "bravo", "charlie", "delta", "echo", "foxtrot", "golf", "hotel",
-	"india", "juliett", "keelo", "leema", "mike", "november", "oscar", "papa",
+	"india", "juliett", "keelo", "leema", "mike", "november", "oscar",
+	    "papa",
 	"keh beck", "romeo", "sierra", "tango", "uniform", "victer", "whiskey",
 	"x ray", "yankee", "zulu"
 };
@@ -132,12 +133,15 @@ static char *phonetic[] = {
 char *characters[256];
 
 char *default_chars[256] = {
-/*000*/	"null", "^a", "^b", "^c", "^d", "^e", "^f", "^g",
+/*000*/ "null", "^a", "^b", "^c", "^d", "^e", "^f", "^g",
 /*008*/ "^h", "^i", "^j", "^k", "^l", "^m", "^n", "^o",
 /*016*/ "^p", "^q", "^r", "^s", "^t", "^u", "^v", "^w",
-/*024*/ "^x", "^y", "^z", "control", "control", "control", "control", "control",
-/*032*/ "space", "bang!", "quote", "number", "dollar", "percent", "and", "tick",
-/*040*/ "left paren", "right paren", "star", "plus", "comma", "dash", "dot",
+/*024*/ "^x", "^y", "^z", "control", "control", "control", "control",
+	    "control",
+/*032*/ "space", "bang!", "quote", "number", "dollar", "percent", "and",
+	    "tick",
+/*040*/ "left paren", "right paren", "star", "plus", "comma", "dash",
+	    "dot",
 	"slash",
 /*048*/ "zero", "one", "two", "three", "four", "five", "six", "seven",
 	"eight", "nine",
@@ -145,34 +149,47 @@ char *default_chars[256] = {
 /*065*/ "EIGH", "B", "C", "D", "E", "F", "G",
 /*072*/ "H", "I", "J", "K", "L", "M", "N", "O",
 /*080*/ "P", "Q", "R", "S", "T", "U", "V", "W", "X",
-/*089*/ "Y", "ZED", "left bracket", "backslash", "right bracket", "caret",
+/*089*/ "Y", "ZED", "left bracket", "backslash", "right bracket",
+	    "caret",
 	"line",
 /*096*/ "accent", "a", "b", "c", "d", "e", "f", "g",
 /*104*/ "h", "i", "j", "k", "l", "m", "n", "o",
 /*112*/ "p", "q", "r", "s", "t", "u", "v", "w",
 /*120*/ "x", "y", "zed", "left brace", "bar", "right brace", "tihlduh",
-/*127*/ "del", "control", "control", "control", "control", "control", "control", "control", "control", "control", "control",
-/*138*/ "control", "control", "control", "control", "control", "control", "control", "control", "control", "control", "control", "control",
-/*150*/ "control", "control", "control", "control", "control", "control", "control", "control", "control", "control",
+/*127*/ "del", "control", "control", "control", "control", "control",
+	    "control", "control", "control", "control", "control",
+/*138*/ "control", "control", "control", "control", "control",
+	    "control", "control", "control", "control", "control",
+	    "control", "control",
+/*150*/ "control", "control", "control", "control", "control",
+	    "control", "control", "control", "control", "control",
 /*160*/ "nbsp", "inverted bang",
-/*162*/ "cents", "pounds", "currency", "yen", "broken bar", "section", 
-/*168*/ "diaeresis", "copyright", "female ordinal", "double left angle", 
+/*162*/ "cents", "pounds", "currency", "yen", "broken bar", "section",
+/*168*/ "diaeresis", "copyright", "female ordinal", "double left angle",
 /*172*/ "not", "soft hyphen", "registered", "macron",
-/*176*/ "degrees", "plus or minus", "super two", "super three", 
-/*180*/ "acute accent", 	"micro", "pilcrow", "middle dot", 
+/*176*/ "degrees", "plus or minus", "super two", "super three",
+/*180*/ "acute accent", "micro", "pilcrow", "middle dot",
 /*184*/ "cedilla", "super one", "male ordinal", "double right angle",
-/*188*/ "one quarter", "one half", "three quarters", "inverted question",
-/*192*/ "A GRAVE", "A ACUTE", "A CIRCUMFLEX", "A TILDE", "A OOMLAUT", "A RING",
-/*198*/ "AE", "C CIDELLA", "E GRAVE", "E ACUTE", "E CIRCUMFLEX", "E OOMLAUT", 
-/*204*/ "I GRAVE", "I ACUTE", "I CIRCUMFLEX", "I OOMLAUT", "ETH", "N TILDE",
+/*188*/ "one quarter", "one half", "three quarters",
+	    "inverted question",
+/*192*/ "A GRAVE", "A ACUTE", "A CIRCUMFLEX", "A TILDE", "A OOMLAUT",
+	    "A RING",
+/*198*/ "AE", "C CIDELLA", "E GRAVE", "E ACUTE", "E CIRCUMFLEX",
+	    "E OOMLAUT",
+/*204*/ "I GRAVE", "I ACUTE", "I CIRCUMFLEX", "I OOMLAUT", "ETH",
+	    "N TILDE",
 /*210*/ "O GRAVE", "O ACUTE", "O CIRCUMFLEX", "O TILDE", "O OOMLAUT",
-/*215*/ "multiplied by", "O STROKE", "U GRAVE", "U ACUTE", "U CIRCUMFLEX", 
+/*215*/ "multiplied by", "O STROKE", "U GRAVE", "U ACUTE",
+	    "U CIRCUMFLEX",
 /*220*/ "U OOMLAUT", "Y ACUTE", "THORN", "sharp s", "a grave",
 /*225*/ "a acute", "a circumflex", "a tilde", "a oomlaut", "a ring",
 /*230*/ "ae", "c cidella", "e grave", "e acute",
-/*234*/ "e circumflex", "e oomlaut", "i grave", "i acute", "i circumflex",
-/*239*/ "i oomlaut", "eth", "n tilde","o grave", "o acute", "o circumflex",
-/*245*/"o tilde", "o oomlaut", "divided by", "o stroke", "u grave", "u acute",
+/*234*/ "e circumflex", "e oomlaut", "i grave", "i acute",
+	    "i circumflex",
+/*239*/ "i oomlaut", "eth", "n tilde", "o grave", "o acute",
+	    "o circumflex",
+/*245*/ "o tilde", "o oomlaut", "divided by", "o stroke", "u grave",
+	    "u acute",
 /* 251 */ "u circumflex", "u oomlaut", "y acute", "thorn", "y oomlaut"
 };
 
@@ -182,38 +199,43 @@ char *default_chars[256] = {
 u_short spk_chartab[256];
 
 static u_short default_chartab[256] = {
- B_CTL, B_CTL, B_CTL, B_CTL, B_CTL, B_CTL, B_CTL, B_CTL, /* 0-7 */
- B_CTL, B_CTL, A_CTL, B_CTL, B_CTL, B_CTL, B_CTL, B_CTL, /* 8-15 */
- B_CTL, B_CTL, B_CTL, B_CTL, B_CTL, B_CTL, B_CTL, B_CTL, /*16-23 */
- B_CTL, B_CTL, B_CTL, B_CTL, B_CTL, B_CTL, B_CTL, B_CTL, /* 24-31 */
-WDLM, A_PUNC, PUNC, PUNC, PUNC, PUNC, PUNC, A_PUNC, /*  !"#$%&' */
-PUNC, PUNC, PUNC, PUNC, A_PUNC, A_PUNC, A_PUNC, PUNC, /* ()*+, -./ */
-NUM, NUM, NUM, NUM, NUM, NUM, NUM, NUM, /* 01234567 */
-NUM, NUM, A_PUNC, PUNC, PUNC, PUNC, PUNC, A_PUNC, /* 89:;<=>? */
-PUNC, A_CAP, A_CAP, A_CAP, A_CAP, A_CAP, A_CAP, A_CAP, /* @ABCDEFG */
-A_CAP, A_CAP, A_CAP, A_CAP, A_CAP, A_CAP, A_CAP, A_CAP, /* HIJKLMNO */
-A_CAP, A_CAP, A_CAP, A_CAP, A_CAP, A_CAP, A_CAP, A_CAP, /* PQRSTUVW */
-A_CAP, A_CAP, A_CAP, PUNC, PUNC, PUNC, PUNC, PUNC, /* XYZ[\]^_ */
-PUNC, ALPHA, ALPHA, ALPHA, ALPHA, ALPHA, ALPHA, ALPHA, /* `abcdefg */
-ALPHA, ALPHA, ALPHA, ALPHA, ALPHA, ALPHA, ALPHA, ALPHA, /* hijklmno */
-ALPHA, ALPHA, ALPHA, ALPHA, ALPHA, ALPHA, ALPHA, ALPHA, /* pqrstuvw */
-ALPHA, ALPHA, ALPHA, PUNC, PUNC, PUNC, PUNC, 0, /* xyz{|}~ */
-B_CAPSYM, B_CAPSYM, B_SYM, B_SYM, B_SYM, B_SYM, B_SYM, B_SYM, /* 128-135 */
-B_SYM, B_SYM, B_SYM, B_SYM, B_SYM, B_SYM, B_SYM, B_CAPSYM, /* 136-143 */
-B_CAPSYM, B_CAPSYM, B_SYM, B_CAPSYM, B_SYM, B_SYM, B_SYM, B_SYM, /* 144-151 */
-B_SYM, B_SYM, B_CAPSYM, B_CAPSYM, B_SYM, B_SYM, B_SYM, B_SYM, /* 152-159 */
-WDLM, B_SYM, B_SYM, B_SYM, B_SYM, B_SYM, B_CAPSYM, B_SYM, /* 160-167 */
-B_SYM, B_SYM, B_SYM, B_SYM, B_SYM, B_SYM, B_SYM, B_SYM, /* 168-175 */
-B_SYM, B_SYM, B_SYM, B_SYM, B_SYM, B_SYM, B_SYM, B_SYM, /* 176-183 */
-B_SYM, B_SYM, B_SYM, B_SYM, B_SYM, B_SYM, B_SYM, B_SYM, /* 184-191 */
-A_CAP, A_CAP, A_CAP, A_CAP, A_CAP, A_CAP, A_CAP, A_CAP, /* 192-199 */
-A_CAP, A_CAP, A_CAP, A_CAP, A_CAP, A_CAP, A_CAP, A_CAP, /* 200-207 */
-A_CAP, A_CAP, A_CAP, A_CAP, A_CAP, A_CAP, A_CAP, B_SYM, /* 208-215 */
-A_CAP, A_CAP, A_CAP, A_CAP, A_CAP, A_CAP, A_CAP, ALPHA, /* 216-223 */
-ALPHA, ALPHA, ALPHA, ALPHA, ALPHA, ALPHA, ALPHA, ALPHA, /* 224-231 */
-ALPHA, ALPHA, ALPHA, ALPHA, ALPHA, ALPHA, ALPHA, ALPHA, /* 232-239 */
-ALPHA, ALPHA, ALPHA, ALPHA, ALPHA, ALPHA, ALPHA, B_SYM, /* 240-247 */
-ALPHA, ALPHA, ALPHA, ALPHA, ALPHA, ALPHA, ALPHA, ALPHA /* 248-255 */
+	B_CTL, B_CTL, B_CTL, B_CTL, B_CTL, B_CTL, B_CTL, B_CTL,	/* 0-7 */
+	B_CTL, B_CTL, A_CTL, B_CTL, B_CTL, B_CTL, B_CTL, B_CTL,	/* 8-15 */
+	B_CTL, B_CTL, B_CTL, B_CTL, B_CTL, B_CTL, B_CTL, B_CTL,	/*16-23 */
+	B_CTL, B_CTL, B_CTL, B_CTL, B_CTL, B_CTL, B_CTL, B_CTL,	/* 24-31 */
+	WDLM, A_PUNC, PUNC, PUNC, PUNC, PUNC, PUNC, A_PUNC,	/*  !"#$%&' */
+	PUNC, PUNC, PUNC, PUNC, A_PUNC, A_PUNC, A_PUNC, PUNC,	/* ()*+, -./ */
+	NUM, NUM, NUM, NUM, NUM, NUM, NUM, NUM,	/* 01234567 */
+	NUM, NUM, A_PUNC, PUNC, PUNC, PUNC, PUNC, A_PUNC,	/* 89:;<=>? */
+	PUNC, A_CAP, A_CAP, A_CAP, A_CAP, A_CAP, A_CAP, A_CAP,	/* @ABCDEFG */
+	A_CAP, A_CAP, A_CAP, A_CAP, A_CAP, A_CAP, A_CAP, A_CAP,	/* HIJKLMNO */
+	A_CAP, A_CAP, A_CAP, A_CAP, A_CAP, A_CAP, A_CAP, A_CAP,	/* PQRSTUVW */
+	A_CAP, A_CAP, A_CAP, PUNC, PUNC, PUNC, PUNC, PUNC,	/* XYZ[\]^_ */
+	PUNC, ALPHA, ALPHA, ALPHA, ALPHA, ALPHA, ALPHA, ALPHA,	/* `abcdefg */
+	ALPHA, ALPHA, ALPHA, ALPHA, ALPHA, ALPHA, ALPHA, ALPHA,	/* hijklmno */
+	ALPHA, ALPHA, ALPHA, ALPHA, ALPHA, ALPHA, ALPHA, ALPHA,	/* pqrstuvw */
+	ALPHA, ALPHA, ALPHA, PUNC, PUNC, PUNC, PUNC, 0,	/* xyz{|}~ */
+	B_CAPSYM, B_CAPSYM, B_SYM, B_SYM, B_SYM, B_SYM, B_SYM, /* 128-134 */
+	B_SYM,	/* 135 */
+	B_SYM, B_SYM, B_SYM, B_SYM, B_SYM, B_SYM, B_SYM, /* 136-142 */
+	B_CAPSYM,	/* 143 */
+	B_CAPSYM, B_CAPSYM, B_SYM, B_CAPSYM, B_SYM, B_SYM, B_SYM, /* 144-150 */
+	B_SYM,	/* 151 */
+	B_SYM, B_SYM, B_CAPSYM, B_CAPSYM, B_SYM, B_SYM, B_SYM, /*152-158 */
+	B_SYM,	/* 159 */
+	WDLM, B_SYM, B_SYM, B_SYM, B_SYM, B_SYM, B_CAPSYM, /* 160-166 */
+	B_SYM,	/* 167 */
+	B_SYM, B_SYM, B_SYM, B_SYM, B_SYM, B_SYM, B_SYM, B_SYM,	/* 168-175 */
+	B_SYM, B_SYM, B_SYM, B_SYM, B_SYM, B_SYM, B_SYM, B_SYM,	/* 176-183 */
+	B_SYM, B_SYM, B_SYM, B_SYM, B_SYM, B_SYM, B_SYM, B_SYM,	/* 184-191 */
+	A_CAP, A_CAP, A_CAP, A_CAP, A_CAP, A_CAP, A_CAP, A_CAP,	/* 192-199 */
+	A_CAP, A_CAP, A_CAP, A_CAP, A_CAP, A_CAP, A_CAP, A_CAP,	/* 200-207 */
+	A_CAP, A_CAP, A_CAP, A_CAP, A_CAP, A_CAP, A_CAP, B_SYM,	/* 208-215 */
+	A_CAP, A_CAP, A_CAP, A_CAP, A_CAP, A_CAP, A_CAP, ALPHA,	/* 216-223 */
+	ALPHA, ALPHA, ALPHA, ALPHA, ALPHA, ALPHA, ALPHA, ALPHA,	/* 224-231 */
+	ALPHA, ALPHA, ALPHA, ALPHA, ALPHA, ALPHA, ALPHA, ALPHA,	/* 232-239 */
+	ALPHA, ALPHA, ALPHA, ALPHA, ALPHA, ALPHA, ALPHA, B_SYM,	/* 240-247 */
+	ALPHA, ALPHA, ALPHA, ALPHA, ALPHA, ALPHA, ALPHA, ALPHA	/* 248-255 */
 };
 
 struct task_struct *speakup_task;
@@ -243,7 +265,7 @@ struct notifier_block vt_notifier_block = {
 
 static unsigned char get_attributes(u16 *pos)
 {
-	return (u_char)(scr_readw(pos) >> 8);
+	return (u_char) (scr_readw(pos) >> 8);
 }
 
 static void speakup_date(struct vc_data *vc)
@@ -262,9 +284,9 @@ static void bleep(u_short val)
 	};
 	short freq;
 	int time = bleep_time;
-	freq = vals[val%12];
+	freq = vals[val % 12];
 	if (val > 11)
-		freq *= (1 << (val/12));
+		freq *= (1 << (val / 12));
 	unprocessed_sound.freq = freq;
 	unprocessed_sound.jiffies = msecs_to_jiffies(time);
 	unprocessed_sound.active = 1;
@@ -345,14 +367,14 @@ static void speakup_cut(struct vc_data *vc)
 
 	switch (ret) {
 	case 0:
-		break; /* no error */
-	case -EFAULT :
+		break;		/* no error */
+	case -EFAULT:
 		pr_warn("%sEFAULT\n", err_buf);
 		break;
-	case -EINVAL :
+	case -EINVAL:
 		pr_warn("%sEINVAL\n", err_buf);
 		break;
-	case -ENOMEM :
+	case -ENOMEM:
 		pr_warn("%sENOMEM\n", err_buf);
 		break;
 	}
@@ -436,7 +458,7 @@ static void speak_char(u_char ch)
 	synth_buffer_add(SPACE);
 }
 
-static u16 get_char(struct vc_data *vc, u16 *pos, u_char *attribs)
+static u16 get_char(struct vc_data *vc, u16 * pos, u_char * attribs)
 {
 	u16 ch = ' ';
 	if (vc && pos) {
@@ -506,12 +528,12 @@ static void say_next_char(struct vc_data *vc)
 }
 
 /* get_word - will first check to see if the character under the
-   reading cursor is a space and if say_word_ctl is true it will
-   return the word space.  If say_word_ctl is not set it will check to
-   see if there is a word starting on the next position to the right
-   and return that word if it exists.  If it does not exist it will
-   move left to the beginning of any previous word on the line or the
-   beginning off the line whichever comes first.. */
+ * reading cursor is a space and if say_word_ctl is true it will
+ * return the word space.  If say_word_ctl is not set it will check to
+ * see if there is a word starting on the next position to the right
+ * and return that word if it exists.  If it does not exist it will
+ * move left to the beginning of any previous word on the line or the
+ * beginning off the line whichever comes first.. */
 
 static u_long get_word(struct vc_data *vc)
 {
@@ -520,7 +542,7 @@ static u_long get_word(struct vc_data *vc)
 	u_short attr_ch;
 	u_char temp;
 	spk_old_attr = spk_attr;
-	ch = (char) get_char(vc, (u_short *) tmp_pos, &temp);
+	ch = (char)get_char(vc, (u_short *) tmp_pos, &temp);
 
 /* decided to take out the sayword if on a space (mis-information */
 	if (say_word_ctl && ch == SPACE) {
@@ -529,15 +551,16 @@ static u_long get_word(struct vc_data *vc)
 		return 0;
 	} else if ((tmpx < vc->vc_cols - 2)
 		   && (ch == SPACE || ch == 0 || IS_WDLM(ch))
-		   && ((char) get_char(vc, (u_short *) &tmp_pos+1, &temp) > SPACE)) {
+		   && ((char)get_char(vc, (u_short *) &tmp_pos + 1, &temp) >
+		       SPACE)) {
 		tmp_pos += 2;
 		tmpx++;
 	} else
 		while (tmpx > 0) {
-			ch = (char) get_char(vc, (u_short *) tmp_pos - 1, &temp);
+			ch = (char)get_char(vc, (u_short *) tmp_pos - 1, &temp);
 			if ((ch == SPACE || ch == 0 || IS_WDLM(ch))
-			    && ((char) get_char(vc, (u_short *) tmp_pos, &temp) >
-									SPACE))
+			    && ((char)get_char(vc, (u_short *) tmp_pos, &temp) >
+				SPACE))
 				break;
 			tmp_pos -= 2;
 			tmpx--;
@@ -547,8 +570,9 @@ static u_long get_word(struct vc_data *vc)
 	while (tmpx < vc->vc_cols - 1) {
 		tmp_pos += 2;
 		tmpx++;
-		ch = (char) get_char(vc, (u_short *) tmp_pos, &temp);
-		if ((ch == SPACE) || ch == 0 || (IS_WDLM(buf[cnt-1]) && (ch > SPACE)))
+		ch = (char)get_char(vc, (u_short *) tmp_pos, &temp);
+		if ((ch == SPACE) || ch == 0
+		    || (IS_WDLM(buf[cnt - 1]) && (ch > SPACE)))
 			break;
 		buf[cnt++] = ch;
 	}
@@ -598,8 +622,8 @@ static void say_prev_word(struct vc_data *vc)
 			spk_x = vc->vc_cols - 1;
 		} else
 			spk_x--;
-			spk_pos -= 2;
-		ch = (char) get_char(vc, (u_short *) spk_pos, &temp);
+		spk_pos -= 2;
+		ch = (char)get_char(vc, (u_short *) spk_pos, &temp);
 		if (ch == SPACE || ch == 0)
 			state = 0;
 		else if (IS_WDLM(ch))
@@ -632,7 +656,7 @@ static void say_next_word(struct vc_data *vc)
 		return;
 	}
 	while (1) {
-		ch = (char) get_char(vc, (u_short *) spk_pos, &temp);
+		ch = (char)get_char(vc, (u_short *) spk_pos, &temp);
 		if (ch == SPACE || ch == 0)
 			state = 0;
 		else if (IS_WDLM(ch))
@@ -675,7 +699,7 @@ static void spell_word(struct vc_data *vc)
 			str_cap = str_caps_start;
 			if (*str_caps_stop)
 				pitch_shift++;
-			else /* synth has no pitch */
+			else	/* synth has no pitch */
 				last_cap = str_caps_stop;
 		} else
 			str_cap = str_caps_stop;
@@ -730,8 +754,9 @@ static void say_line(struct vc_data *vc)
 	}
 	buf[i++] = '\n';
 	if (this_speakup_key == SAY_LINE_INDENT) {
-		for (cp = buf; *cp == SPACE; cp++)
-			;
+		cp = buf;
+		while (*cp == SPACE)
+			cp++;
 		synth_printf("%d, ", (cp - buf) + 1);
 	}
 	punc_mask = punc_masks[reading_punc];
@@ -772,7 +797,7 @@ static int say_from_to(struct vc_data *vc, u_long from, u_long to,
 	spk_old_attr = spk_attr;
 	spk_attr = get_attributes((u_short *) from);
 	while (from < to) {
-		buf[i++] = (char) get_char(vc, (u_short *) from, &tmp);
+		buf[i++] = (char)get_char(vc, (u_short *) from, &tmp);
 		from += 2;
 		if (i >= vc->vc_size_row)
 			break;
@@ -805,8 +830,6 @@ static void say_line_from_to(struct vc_data *vc, u_long from, u_long to,
 
 /* Sentence Reading Commands */
 
-void synth_insert_next_index(int);
-
 static int currsentence;
 static int numsentences[2];
 static char *sentbufend[2];
@@ -815,7 +838,7 @@ static int currbuf;
 static int bn;
 static char sentbuf[2][256];
 
-static int say_sentence_num(int num , int prev)
+static int say_sentence_num(int num, int prev)
 {
 	bn = currbuf;
 	currsentence = num + 1;
@@ -840,7 +863,7 @@ static int get_sentence_buf(struct vc_data *vc, int read_punc)
 		currbuf = 0;
 	bn = currbuf;
 	start = vc->vc_origin + ((spk_y) * vc->vc_size_row);
-	end = vc->vc_origin+((spk_y) * vc->vc_size_row) + vc->vc_cols * 2;
+	end = vc->vc_origin + ((spk_y) * vc->vc_size_row) + vc->vc_cols * 2;
 
 	numsentences[bn] = 0;
 	sentmarks[bn][0] = &sentbuf[bn][0];
@@ -849,14 +872,14 @@ static int get_sentence_buf(struct vc_data *vc, int read_punc)
 	spk_attr = get_attributes((u_short *) start);
 
 	while (start < end) {
-		sentbuf[bn][i] = (char) get_char(vc, (u_short *) start, &tmp);
+		sentbuf[bn][i] = (char)get_char(vc, (u_short *) start, &tmp);
 		if (i > 0) {
-			if (sentbuf[bn][i] == SPACE && sentbuf[bn][i-1] == '.'
+			if (sentbuf[bn][i] == SPACE && sentbuf[bn][i - 1] == '.'
 			    && numsentences[bn] < 9) {
 				/* Sentence Marker */
 				numsentences[bn]++;
 				sentmarks[bn][numsentences[bn]] =
-					&sentbuf[bn][i];
+				    &sentbuf[bn][i];
 			}
 		}
 		i++;
@@ -985,7 +1008,7 @@ static void say_last_char(struct vc_data *vc)
 static void say_position(struct vc_data *vc)
 {
 	synth_printf(msg_get(MSG_POS_INFO), spk_y + 1, spk_x + 1,
-		vc->vc_num + 1);
+		     vc->vc_num + 1);
 	synth_printf("\n");
 }
 
@@ -1024,27 +1047,28 @@ static void say_to_right(struct vc_data *vc)
 
 static void spkup_write(const char *in_buf, int count)
 {
-	static int rep_count = 0;
+	static int rep_count;
 	static u_char ch = '\0', old_ch = '\0';
-	static u_short char_type = 0, last_type = 0;
+	static u_short char_type, last_type;
 	int in_count = count;
 	spk_keydown = 0;
 	while (count--) {
 		if (cursor_track == read_all_mode) {
 			/* Insert Sentence Index */
 			if ((in_buf == sentmarks[bn][currsentence]) &&
-			   (currsentence <= numsentences[bn]))
+			    (currsentence <= numsentences[bn]))
 				synth_insert_next_index(currsentence++);
 		}
-		ch = (u_char)*in_buf++;
+		ch = (u_char) *in_buf++;
 		char_type = spk_chartab[ch];
-		if (ch == old_ch && !(char_type&B_NUM)) {
+		if (ch == old_ch && !(char_type & B_NUM)) {
 			if (++rep_count > 2)
 				continue;
 		} else {
-			if ((last_type&CH_RPT) && rep_count > 2) {
+			if ((last_type & CH_RPT) && rep_count > 2) {
 				synth_printf(" ");
-				synth_printf(msg_get(MSG_REPEAT_DESC), ++rep_count);
+				synth_printf(msg_get(MSG_REPEAT_DESC),
+					     ++rep_count);
 				synth_printf(" ");
 			}
 			rep_count = 0;
@@ -1060,13 +1084,16 @@ static void spkup_write(const char *in_buf, int count)
 		} else if (char_type & B_NUM) {
 			rep_count = 0;
 			synth_printf("%c", ch);
-		} else if (char_type&punc_mask) {
+		} else if (char_type & punc_mask) {
 			speak_char(ch);
-			char_type &= ~PUNC; /* for dec nospell processing */
-		} else if (char_type&SYNTH_OK) {
-/* these are usually puncts like . and , which synth needs for expression.
- * suppress multiple to get rid of long pausesand clear repeat count so if
- *someone has repeats on you don't get nothing repeated count */
+			char_type &= ~PUNC;	/* for dec nospell processing */
+		} else if (char_type & SYNTH_OK) {
+			/* these are usually puncts like . and , which synth
+			 * needs for expression.
+			 * suppress multiple to get rid of long pauses and
+			 * clear repeat count
+			 * so if someone has
+			 * repeats on you don't get nothing repeated count */
 			if (ch != old_ch)
 				synth_printf("%c", ch);
 			else
@@ -1083,7 +1110,7 @@ static void spkup_write(const char *in_buf, int count)
 	}
 	spk_lastkey = 0;
 	if (in_count > 2 && rep_count > 2) {
-		if (last_type&CH_RPT) {
+		if (last_type & CH_RPT) {
 			synth_printf(" ");
 			synth_printf(msg_get(MSG_REPEAT_DESC2), ++rep_count);
 			synth_printf(" ");
@@ -1160,7 +1187,7 @@ int set_key_info(const u_char *key_info, u_char *k_buffer)
 	if (version != KEY_MAP_VER)
 		return -1;
 	num_keys = *cp;
-	states = (int) cp[1];
+	states = (int)cp[1];
 	key_data_len = (states + 1) * (num_keys + 1);
 	if (key_data_len + SHIFT_TBL_SIZE + 4 >= sizeof(key_buf))
 		return -2;
@@ -1170,8 +1197,8 @@ int set_key_info(const u_char *key_info, u_char *k_buffer)
 	our_keys[0] = shift_table;
 	cp1 += SHIFT_TBL_SIZE;
 	memcpy(cp1, cp, key_data_len + 3);
-	/* get num_keys, states and data*/
-	cp1 += 2; /* now pointing at shift states */
+	/* get num_keys, states and data */
+	cp1 += 2;		/* now pointing at shift states */
 	for (i = 1; i <= states; i++) {
 		ch = *cp1++;
 		if (ch >= SHIFT_TBL_SIZE)
@@ -1190,22 +1217,21 @@ int set_key_info(const u_char *key_info, u_char *k_buffer)
 
 static struct var_t spk_vars[] = {
 	/* bell must be first to set high limit */
-	{ BELL_POS, .u.n = {NULL, 0, 0, 0, 0, 0, NULL }},
-	{ SPELL_DELAY, .u.n = {NULL, 0, 0, 4, 0, 0, NULL }},
-	{ ATTRIB_BLEEP, .u.n = {NULL, 1, 0, 3, 0, 0, NULL }},
-	{ BLEEPS, .u.n = {NULL, 3, 0, 3, 0, 0, NULL }},
-	{ BLEEP_TIME, .u.n = {NULL, 30, 1, 200, 0, 0, NULL }},
-	{ PUNC_LEVEL, .u.n = {NULL, 1, 0, 4, 0, 0, NULL }},
-	{ READING_PUNC, .u.n = {NULL, 1, 0, 4, 0, 0, NULL }},
-	{ CURSOR_TIME, .u.n = {NULL, 120, 50, 600, 0, 0, NULL }},
-	{ SAY_CONTROL, TOGGLE_0 },
-	{ SAY_WORD_CTL, TOGGLE_0 },
-	{ NO_INTERRUPT, TOGGLE_0 },
-	{ KEY_ECHO, .u.n = {NULL, 1, 0, 2, 0, 0, NULL }},
+	{BELL_POS, .u.n = {NULL, 0, 0, 0, 0, 0, NULL} },
+	{SPELL_DELAY, .u.n = {NULL, 0, 0, 4, 0, 0, NULL} },
+	{ATTRIB_BLEEP, .u.n = {NULL, 1, 0, 3, 0, 0, NULL} },
+	{BLEEPS, .u.n = {NULL, 3, 0, 3, 0, 0, NULL} },
+	{BLEEP_TIME, .u.n = {NULL, 30, 1, 200, 0, 0, NULL} },
+	{PUNC_LEVEL, .u.n = {NULL, 1, 0, 4, 0, 0, NULL} },
+	{READING_PUNC, .u.n = {NULL, 1, 0, 4, 0, 0, NULL} },
+	{CURSOR_TIME, .u.n = {NULL, 120, 50, 600, 0, 0, NULL} },
+	{SAY_CONTROL, TOGGLE_0},
+	{SAY_WORD_CTL, TOGGLE_0},
+	{NO_INTERRUPT, TOGGLE_0},
+	{KEY_ECHO, .u.n = {NULL, 1, 0, 2, 0, 0, NULL} },
 	V_LAST_VAR
 };
 
-
 static void toggle_cursoring(struct vc_data *vc)
 {
 	if (cursor_track == read_all_mode)
@@ -1234,24 +1260,25 @@ void reset_default_chartab(void)
 	memcpy(spk_chartab, default_chartab, sizeof(default_chartab));
 }
 
-static const struct st_bits_data *pb_edit = NULL;
+static const struct st_bits_data *pb_edit;
 
 static int edit_bits(struct vc_data *vc, u_char type, u_char ch, u_short key)
 {
 	short mask = pb_edit->mask, ch_type = spk_chartab[ch];
-	if (type != KT_LATIN || (ch_type&B_NUM) || ch < SPACE)
+	if (type != KT_LATIN || (ch_type & B_NUM) || ch < SPACE)
 		return -1;
 	if (ch == SPACE) {
 		synth_printf("%s\n", msg_get(MSG_EDIT_DONE));
 		special_handler = NULL;
 		return 1;
 	}
-	if (mask < PUNC && !(ch_type&PUNC))
+	if (mask < PUNC && !(ch_type & PUNC))
 		return -1;
 	spk_chartab[ch] ^= mask;
 	speak_char(ch);
 	synth_printf(" %s\n",
-		(spk_chartab[ch]&mask) ? msg_get(MSG_ON) : msg_get(MSG_OFF));
+		     (spk_chartab[ch] & mask) ? msg_get(MSG_ON) :
+		     msg_get(MSG_OFF));
 	return 1;
 }
 
@@ -1263,7 +1290,7 @@ void speakup_allocate(struct vc_data *vc)
 	vc_num = vc->vc_num;
 	if (speakup_console[vc_num] == NULL) {
 		speakup_console[vc_num] = kzalloc(sizeof(*speakup_console[0]),
-			GFP_ATOMIC);
+						  GFP_ATOMIC);
 		if (speakup_console[vc_num] == NULL)
 			return;
 		speakup_date(vc);
@@ -1290,9 +1317,6 @@ static void reset_highlight_buffers(struct vc_data *);
 
 static int read_all_key;
 
-void reset_index_count(int);
-void get_index_count(int *, int *);
-/*int synth_supports_indexing(void); */
 static void start_read_all_timer(struct vc_data *vc, int command);
 
 enum {
@@ -1307,16 +1331,14 @@ enum {
 	RA_FIND_PREV_SENT,
 };
 
-static void
-kbd_fakekey2(struct vc_data *vc, int command)
+static void kbd_fakekey2(struct vc_data *vc, int command)
 {
 	del_timer(&cursor_timer);
 	speakup_fake_down_arrow();
 	start_read_all_timer(vc, command);
 }
 
-static void
-read_all_doc(struct vc_data *vc)
+static void read_all_doc(struct vc_data *vc)
 {
 	if ((vc->vc_num != fg_console) || synth == NULL || spk_shut_up)
 		return;
@@ -1335,8 +1357,7 @@ read_all_doc(struct vc_data *vc)
 	}
 }
 
-static void
-stop_read_all(struct vc_data *vc)
+static void stop_read_all(struct vc_data *vc)
 {
 	del_timer(&cursor_timer);
 	cursor_track = prev_cursor_track;
@@ -1344,19 +1365,18 @@ stop_read_all(struct vc_data *vc)
 	do_flush();
 }
 
-static void
-start_read_all_timer(struct vc_data *vc, int command)
+static void start_read_all_timer(struct vc_data *vc, int command)
 {
 	struct var_t *cursor_timeout;
 
 	cursor_con = vc->vc_num;
 	read_all_key = command;
 	cursor_timeout = get_var(CURSOR_TIME);
-	mod_timer(&cursor_timer, jiffies + msecs_to_jiffies(cursor_timeout->u.n.value));
+	mod_timer(&cursor_timer,
+		  jiffies + msecs_to_jiffies(cursor_timeout->u.n.value));
 }
 
-static void
-handle_cursor_read_all(struct vc_data *vc, int command)
+static void handle_cursor_read_all(struct vc_data *vc, int command)
 {
 	int indcount, sentcount, rv, sn;
 
@@ -1365,16 +1385,16 @@ handle_cursor_read_all(struct vc_data *vc, int command)
 		/* Get Current Sentence */
 		get_index_count(&indcount, &sentcount);
 		/*printk("%d %d  ", indcount, sentcount); */
-		reset_index_count(sentcount+1);
+		reset_index_count(sentcount + 1);
 		if (indcount == 1) {
-			if (!say_sentence_num(sentcount+1, 0)) {
+			if (!say_sentence_num(sentcount + 1, 0)) {
 				kbd_fakekey2(vc, RA_FIND_NEXT_SENT);
 				return;
 			}
 			synth_insert_next_index(0);
 		} else {
 			sn = 0;
-			if (!say_sentence_num(sentcount+1, 1)) {
+			if (!say_sentence_num(sentcount + 1, 1)) {
 				sn = 1;
 				reset_index_count(sn);
 			} else
@@ -1440,7 +1460,7 @@ static int pre_handle_cursor(struct vc_data *vc, u_char value, char up_flag)
 		del_timer(&cursor_timer);
 		spk_shut_up &= 0xfe;
 		do_flush();
-		start_read_all_timer(vc, value+1);
+		start_read_all_timer(vc, value + 1);
 		spk_unlock(flags);
 		return NOTIFY_STOP;
 	}
@@ -1473,17 +1493,17 @@ static void do_handle_cursor(struct vc_data *vc, u_char value, char up_flag)
 	if (cursor_track == CT_Highlight)
 		reset_highlight_buffers(vc);
 	cursor_timeout = get_var(CURSOR_TIME);
-	mod_timer(&cursor_timer, jiffies + msecs_to_jiffies(cursor_timeout->u.n.value));
+	mod_timer(&cursor_timer,
+		  jiffies + msecs_to_jiffies(cursor_timeout->u.n.value));
 	spk_unlock(flags);
 }
 
-static void
-update_color_buffer(struct vc_data *vc , const char *ic , int len)
+static void update_color_buffer(struct vc_data *vc, const char *ic, int len)
 {
 	int i, bi, hi;
 	int vc_num = vc->vc_num;
 
-	bi = ((vc->vc_attr & 0x70) >> 4) ;
+	bi = ((vc->vc_attr & 0x70) >> 4);
 	hi = speakup_console[vc_num]->ht.highsize[bi];
 
 	i = 0;
@@ -1497,10 +1517,10 @@ update_color_buffer(struct vc_data *vc , const char *ic , int len)
 			speakup_console[vc_num]->ht.highbuf[bi][hi] = ic[i];
 			hi++;
 		} else if ((ic[i] == 32) && (hi != 0)) {
-			if (speakup_console[vc_num]->ht.highbuf[bi][hi-1] !=
-									32) {
+			if (speakup_console[vc_num]->ht.highbuf[bi][hi - 1] !=
+			    32) {
 				speakup_console[vc_num]->ht.highbuf[bi][hi] =
-					ic[i];
+				    ic[i];
 				hi++;
 			}
 		}
@@ -1509,17 +1529,15 @@ update_color_buffer(struct vc_data *vc , const char *ic , int len)
 	speakup_console[vc_num]->ht.highsize[bi] = hi;
 }
 
-static void
-reset_highlight_buffers(struct vc_data *vc)
+static void reset_highlight_buffers(struct vc_data *vc)
 {
 	int i;
 	int vc_num = vc->vc_num;
-	for (i = 0 ; i < 8 ; i++)
+	for (i = 0; i < 8; i++)
 		speakup_console[vc_num]->ht.highsize[i] = 0;
 }
 
-static int
-count_highlight_color(struct vc_data *vc)
+static int count_highlight_color(struct vc_data *vc)
 {
 	int i, bg;
 	int cc;
@@ -1531,7 +1549,7 @@ count_highlight_color(struct vc_data *vc)
 		speakup_console[vc_num]->ht.bgcount[i] = 0;
 
 	for (i = 0; i < vc->vc_rows; i++) {
-		u16 *end = start + vc->vc_cols*2;
+		u16 *end = start + vc->vc_cols * 2;
 		u16 *ptr;
 		for (ptr = start; ptr < end; ptr++) {
 			ch = get_attributes(ptr);
@@ -1548,8 +1566,7 @@ count_highlight_color(struct vc_data *vc)
 	return cc;
 }
 
-static int
-get_highlight_color(struct vc_data *vc)
+static int get_highlight_color(struct vc_data *vc)
 {
 	int i, j;
 	unsigned int cptr[8], tmp;
@@ -1561,7 +1578,7 @@ get_highlight_color(struct vc_data *vc)
 	for (i = 0; i < 7; i++)
 		for (j = i + 1; j < 8; j++)
 			if (speakup_console[vc_num]->ht.bgcount[cptr[i]] >
-				speakup_console[vc_num]->ht.bgcount[cptr[j]]) {
+			    speakup_console[vc_num]->ht.bgcount[cptr[j]]) {
 				tmp = cptr[i];
 				cptr[i] = cptr[j];
 				cptr[j] = tmp;
@@ -1574,8 +1591,7 @@ get_highlight_color(struct vc_data *vc)
 	return -1;
 }
 
-static int
-speak_highlight(struct vc_data *vc)
+static int speak_highlight(struct vc_data *vc)
 {
 	int hc, d;
 	int vc_num = vc->vc_num;
@@ -1583,14 +1599,14 @@ speak_highlight(struct vc_data *vc)
 		return 0;
 	hc = get_highlight_color(vc);
 	if (hc != -1) {
-		d = vc->vc_y-speakup_console[vc_num]->ht.cy;
+		d = vc->vc_y - speakup_console[vc_num]->ht.cy;
 		if ((d == 1) || (d == -1))
 			if (speakup_console[vc_num]->ht.ry[hc] != vc->vc_y)
 				return 0;
 		spk_parked |= 0x01;
 		do_flush();
 		spkup_write(speakup_console[vc_num]->ht.highbuf[hc],
-				speakup_console[vc_num]->ht.highsize[hc]);
+			    speakup_console[vc_num]->ht.highsize[hc]);
 		spk_pos = spk_cp = speakup_console[vc_num]->ht.rpos[hc];
 		spk_x = spk_cx = speakup_console[vc_num]->ht.rx[hc];
 		spk_y = spk_cy = speakup_console[vc_num]->ht.ry[hc];
@@ -1599,8 +1615,7 @@ speak_highlight(struct vc_data *vc)
 	return 0;
 }
 
-static void
-cursor_done(u_long data)
+static void cursor_done(u_long data)
 {
 	struct vc_data *vc = vc_cons[cursor_con].d;
 	unsigned long flags;
@@ -1613,7 +1628,7 @@ cursor_done(u_long data)
 	speakup_date(vc);
 	if (win_enabled) {
 		if (vc->vc_x >= win_left && vc->vc_x <= win_right &&
-		vc->vc_y >= win_top && vc->vc_y <= win_bottom) {
+		    vc->vc_y >= win_top && vc->vc_y <= win_bottom) {
 			spk_keydown = is_cursor = 0;
 			goto out;
 		}
@@ -1681,7 +1696,7 @@ static void speakup_con_write(struct vc_data *vc, const char *str, int len)
 	}
 	if (win_enabled) {
 		if (vc->vc_x >= win_left && vc->vc_x <= win_right &&
-		vc->vc_y >= win_top && vc->vc_y <= win_bottom) {
+		    vc->vc_y >= win_top && vc->vc_y <= win_bottom) {
 			spk_unlock(flags);
 			return;
 		}
@@ -1691,8 +1706,7 @@ static void speakup_con_write(struct vc_data *vc, const char *str, int len)
 	spk_unlock(flags);
 }
 
-void
-speakup_con_update(struct vc_data *vc)
+void speakup_con_update(struct vc_data *vc)
 {
 	unsigned long flags;
 	if (speakup_console[vc->vc_num] == NULL || spk_parked)
@@ -1741,8 +1755,7 @@ static void do_handle_spec(struct vc_data *vc, u_char value, char up_flag)
 	spk_unlock(flags);
 }
 
-static int
-inc_dec_var(u_char value)
+static int inc_dec_var(u_char value)
 {
 	struct st_var_header *p_header;
 	struct var_t *var_data;
@@ -1750,8 +1763,8 @@ inc_dec_var(u_char value)
 	char *cp = num_buf;
 	char *pn;
 	int var_id = (int)value - VAR_START;
-	int how = (var_id&1) ? E_INC : E_DEC;
-	var_id = var_id/2+FIRST_SET_VAR;
+	int how = (var_id & 1) ? E_INC : E_DEC;
+	var_id = var_id / 2 + FIRST_SET_VAR;
 	p_header = get_var_header(var_id);
 	if (p_header == NULL)
 		return -1;
@@ -1769,13 +1782,12 @@ inc_dec_var(u_char value)
 		}
 	}
 	snprintf(cp, sizeof(num_buf) - (cp - num_buf), " %d ",
-			var_data->u.n.value);
+		 var_data->u.n.value);
 	synth_printf("%s", num_buf);
 	return 0;
 }
 
-static void
-speakup_win_set(struct vc_data *vc)
+static void speakup_win_set(struct vc_data *vc)
 {
 	char info[40];
 	if (win_start > 1) {
@@ -1788,10 +1800,10 @@ speakup_win_set(struct vc_data *vc)
 	}
 	if (win_start && spk_x == win_left && spk_y == win_top) {
 		win_left = 0;
-		win_right = vc->vc_cols-1;
+		win_right = vc->vc_cols - 1;
 		win_bottom = spk_y;
 		snprintf(info, sizeof(info), msg_get(MSG_WINDOW_LINE),
-				(int)win_top+1);
+			 (int)win_top + 1);
 	} else {
 		if (!win_start) {
 			win_top = spk_y;
@@ -1801,15 +1813,14 @@ speakup_win_set(struct vc_data *vc)
 			win_right = spk_x;
 		}
 		snprintf(info, sizeof(info), msg_get(MSG_WINDOW_BOUNDARY),
-			(win_start) ? msg_get(MSG_END) : msg_get(MSG_START),
-			(int)spk_y+1, (int)spk_x+1);
+			 (win_start) ? msg_get(MSG_END) : msg_get(MSG_START),
+			 (int)spk_y + 1, (int)spk_x + 1);
 	}
 	synth_printf("%s\n", info);
 	win_start++;
 }
 
-static void
-speakup_win_clear(struct vc_data *vc)
+static void speakup_win_clear(struct vc_data *vc)
 {
 	win_top = win_bottom = 0;
 	win_left = win_right = 0;
@@ -1817,8 +1828,7 @@ speakup_win_clear(struct vc_data *vc)
 	synth_printf("%s\n", msg_get(MSG_WINDOW_CLEARED));
 }
 
-static void
-speakup_win_enable(struct vc_data *vc)
+static void speakup_win_enable(struct vc_data *vc)
 {
 	if (win_start < 2) {
 		synth_printf("%s\n", msg_get(MSG_NO_WINDOW));
@@ -1831,8 +1841,7 @@ speakup_win_enable(struct vc_data *vc)
 		synth_printf("%s\n", msg_get(MSG_WINDOW_SILENCE_DISABLED));
 }
 
-static void
-speakup_bits(struct vc_data *vc)
+static void speakup_bits(struct vc_data *vc)
 {
 	int val = this_speakup_key - (FIRST_EDIT_BITS - 1);
 	if (special_handler != NULL || val < 1 || val > 6) {
@@ -1847,7 +1856,7 @@ speakup_bits(struct vc_data *vc)
 static int handle_goto(struct vc_data *vc, u_char type, u_char ch, u_short key)
 {
 	static u_char *goto_buf = "\0\0\0\0\0\0";
-	static int num = 0;
+	static int num;
 	int maxlen, go_pos;
 	char *cp;
 	if (type == KT_SPKUP && ch == SPEAKUP_GOTO)
@@ -1874,7 +1883,7 @@ static int handle_goto(struct vc_data *vc, u_char type, u_char ch, u_short key)
 		return 1;
 	if (ch >= '0' && ch <= '9' && num < maxlen)
 		return 1;
-	if (num < maxlen-1 || num > maxlen)
+	if (num < maxlen - 1 || num > maxlen)
 		goto oops;
 	if (ch < 'x' || ch > 'y') {
 oops:
@@ -1885,7 +1894,7 @@ static int handle_goto(struct vc_data *vc, u_char type, u_char ch, u_short key)
 		return 1;
 	}
 	cp = speakup_s2i(goto_buf, &go_pos);
-	goto_pos = (u_long)go_pos;
+	goto_pos = (u_long) go_pos;
 	if (*cp == 'x') {
 		if (*goto_buf < '0')
 			goto_pos += spk_x;
@@ -1894,7 +1903,7 @@ static int handle_goto(struct vc_data *vc, u_char type, u_char ch, u_short key)
 		if (goto_pos < 0)
 			goto_pos = 0;
 		if (goto_pos >= vc->vc_cols)
-			goto_pos = vc->vc_cols-1;
+			goto_pos = vc->vc_cols - 1;
 		goto_x = 1;
 	} else {
 		if (*goto_buf < '0')
@@ -1904,10 +1913,10 @@ static int handle_goto(struct vc_data *vc, u_char type, u_char ch, u_short key)
 		if (goto_pos < 0)
 			goto_pos = 0;
 		if (goto_pos >= vc->vc_rows)
-			goto_pos = vc->vc_rows-1;
+			goto_pos = vc->vc_rows - 1;
 		goto_x = 0;
 	}
-		goto_buf[num = 0] = '\0';
+	goto_buf[num = 0] = '\0';
 do_goto:
 	special_handler = NULL;
 	spk_parked |= 0x01;
@@ -1924,8 +1933,7 @@ static int handle_goto(struct vc_data *vc, u_char type, u_char ch, u_short key)
 	return 1;
 }
 
-static void
-speakup_goto(struct vc_data *vc)
+static void speakup_goto(struct vc_data *vc)
 {
 	if (special_handler != NULL) {
 		synth_printf("%s\n", msg_get(MSG_ERROR));
@@ -1941,15 +1949,14 @@ static void speakup_help(struct vc_data *vc)
 	handle_help(vc, KT_SPKUP, SPEAKUP_HELP, 0);
 }
 
-static void
-do_nothing(struct vc_data *vc)
+static void do_nothing(struct vc_data *vc)
 {
-	return; /* flush done in do_spkup */
+	return;			/* flush done in do_spkup */
 }
+
 static u_char key_speakup, spk_key_locked;
 
-static void
-speakup_lock(struct vc_data *vc)
+static void speakup_lock(struct vc_data *vc)
 {
 	if (!spk_key_locked)
 		spk_key_locked = key_speakup = 16;
@@ -1957,7 +1964,7 @@ speakup_lock(struct vc_data *vc)
 		spk_key_locked = key_speakup = 0;
 }
 
-typedef void(*spkup_hand)(struct vc_data *);
+typedef void (*spkup_hand) (struct vc_data *);
 spkup_hand spkup_handler[] = {
 	/* must be ordered same as defines in speakup.h */
 	do_nothing, speakup_goto, speech_kill, speakup_shut_up,
@@ -1968,7 +1975,7 @@ spkup_hand spkup_handler[] = {
 	top_edge, bottom_edge, left_edge, right_edge,
 	spell_word, spell_word, say_screen,
 	say_position, say_attributes,
-	speakup_off, speakup_parked, say_line, /* this is for indent */
+	speakup_off, speakup_parked, say_line,	/* this is for indent */
 	say_from_top, say_to_bottom,
 	say_from_left, say_to_right,
 	say_char_num, speakup_bits, speakup_bits, say_phonetic_char,
@@ -1987,7 +1994,7 @@ static void do_spkup(struct vc_data *vc, u_char value)
 	this_speakup_key = value;
 	if (value < SPKUP_MAX_FUNC && spkup_handler[value]) {
 		do_flush();
-		(*spkup_handler[value])(vc);
+		(*spkup_handler[value]) (vc);
 	} else {
 		if (inc_dec_var(value) < 0)
 			bleep(9);
@@ -1998,7 +2005,7 @@ static const char *pad_chars = "0123456789+-*/\015,.?()";
 
 int
 speakup_key(struct vc_data *vc, int shift_state, int keycode, u_short keysym,
-		int up_flag)
+	    int up_flag)
 {
 	unsigned long flags;
 	int kh;
@@ -2013,8 +2020,8 @@ speakup_key(struct vc_data *vc, int shift_state, int keycode, u_short keysym,
 	tty = vc->port.tty;
 	if (type >= 0xf0)
 		type -= 0xf0;
-	if (type == KT_PAD &&
-			(vc_kbd_led(kbd_table + fg_console, VC_NUMLOCK))) {
+	if (type == KT_PAD
+		&& (vc_kbd_led(kbd_table + fg_console, VC_NUMLOCK))) {
 		if (up_flag) {
 			spk_keydown = 0;
 			goto out;
@@ -2044,7 +2051,7 @@ speakup_key(struct vc_data *vc, int shift_state, int keycode, u_short keysym,
 			break;
 		}
 	}
-	shift_info = (shift_state&0x0f) + key_speakup;
+	shift_info = (shift_state & 0x0f) + key_speakup;
 	offset = shift_table[shift_info];
 	if (offset) {
 		new_key = key_info[offset];
@@ -2062,10 +2069,10 @@ speakup_key(struct vc_data *vc, int shift_state, int keycode, u_short keysym,
 			if (up_flag)
 				goto out;
 			if (last_keycode == keycode &&
-					last_spk_jiffy+MAX_DELAY > jiffies) {
+			    last_spk_jiffy + MAX_DELAY > jiffies) {
 				spk_close_press = 1;
-				offset = shift_table[shift_info+32];
-	/* double press? */
+				offset = shift_table[shift_info + 32];
+				/* double press? */
 				if (offset && key_info[offset])
 					new_key = key_info[offset];
 			}
@@ -2086,9 +2093,9 @@ speakup_key(struct vc_data *vc, int shift_state, int keycode, u_short keysym,
 		goto out;
 	spk_shut_up &= 0xfe;
 	kh = (value == KVAL(K_DOWN))
-		|| (value == KVAL(K_UP))
-		|| (value == KVAL(K_LEFT))
-		|| (value == KVAL(K_RIGHT));
+	    || (value == KVAL(K_UP))
+	    || (value == KVAL(K_LEFT))
+	    || (value == KVAL(K_RIGHT));
 	if ((cursor_track != read_all_mode) || !kh)
 		if (!no_intr)
 			do_flush();
@@ -2099,8 +2106,8 @@ speakup_key(struct vc_data *vc, int shift_state, int keycode, u_short keysym,
 		} else if (type == KT_LETTER)
 			type = KT_LATIN;
 		else if (value == 0x7f)
-			value = 8; /* make del = backspace */
-		ret = (*special_handler)(vc, type, value, keycode);
+			value = 8;	/* make del = backspace */
+		ret = (*special_handler) (vc, type, value, keycode);
 		spk_close_press = 0;
 		if (ret < 0)
 			bleep(9);
@@ -2113,13 +2120,13 @@ speakup_key(struct vc_data *vc, int shift_state, int keycode, u_short keysym,
 }
 
 static int keyboard_notifier_call(struct notifier_block *nb,
-		unsigned long code, void *_param)
+				  unsigned long code, void *_param)
 {
 	struct keyboard_notifier_param *param = _param;
 	struct vc_data *vc = param->vc;
 	int up = !param->down;
 	int ret = NOTIFY_OK;
-	static int keycode; /* to hold the current keycode */
+	static int keycode;	/* to hold the current keycode */
 
 	if (vc->vc_mode == KD_GRAPHICS)
 		return ret;
@@ -2150,37 +2157,35 @@ static int keyboard_notifier_call(struct notifier_block *nb,
 	case KBD_KEYSYM:
 		if (speakup_key(vc, param->shift, keycode, param->value, up))
 			ret = NOTIFY_STOP;
-		else
-			if (KTYP(param->value) == KT_CUR)
-				ret = pre_handle_cursor(vc,
-						KVAL(param->value), up);
+		else if (KTYP(param->value) == KT_CUR)
+			ret = pre_handle_cursor(vc, KVAL(param->value), up);
 		break;
-	case KBD_POST_KEYSYM: {
-		unsigned char type = KTYP(param->value) - 0xf0;
-		unsigned char val = KVAL(param->value);
-		switch (type) {
-		case KT_SHIFT:
-			do_handle_shift(vc, val, up);
-			break;
-		case KT_LATIN:
-		case KT_LETTER:
-			do_handle_latin(vc, val, up);
-			break;
-		case KT_CUR:
-			do_handle_cursor(vc, val, up);
-			break;
-		case KT_SPEC:
-			do_handle_spec(vc, val, up);
+	case KBD_POST_KEYSYM:{
+			unsigned char type = KTYP(param->value) - 0xf0;
+			unsigned char val = KVAL(param->value);
+			switch (type) {
+			case KT_SHIFT:
+				do_handle_shift(vc, val, up);
+				break;
+			case KT_LATIN:
+			case KT_LETTER:
+				do_handle_latin(vc, val, up);
+				break;
+			case KT_CUR:
+				do_handle_cursor(vc, val, up);
+				break;
+			case KT_SPEC:
+				do_handle_spec(vc, val, up);
+				break;
+			}
 			break;
 		}
-		break;
-		}
 	}
 	return ret;
 }
 
 static int vt_notifier_call(struct notifier_block *nb,
-		unsigned long code, void *_param)
+			    unsigned long code, void *_param)
 {
 	struct vt_notifier_param *param = _param;
 	struct vc_data *vc = param->vc;
@@ -2195,11 +2200,10 @@ static int vt_notifier_call(struct notifier_block *nb,
 	case VT_WRITE:
 		if (param->c == '\b')
 			speakup_bs(vc);
-		else
-			if (param->c < 0x100) {
-				char d = param->c;
-				speakup_con_write(vc, &d, 1);
-			}
+		else if (param->c < 0x100) {
+			char d = param->c;
+			speakup_con_write(vc, &d, 1);
+		}
 		break;
 	case VT_UPDATE:
 		speakup_con_update(vc);
@@ -2251,11 +2255,11 @@ static int __init speakup_init(void)
 	if (err)
 		return err;
 
-	initialize_msgs(); /* Initialize arrays for i18n. */
+	initialize_msgs();	/* Initialize arrays for i18n. */
 	first_console = kzalloc(sizeof(*first_console), GFP_KERNEL);
 	if (!first_console)
 		return -ENOMEM;
-	if (speakup_kobj_init() < 0) 
+	if (speakup_kobj_init() < 0)
 		return -ENOMEM;
 
 	reset_default_chars();
@@ -2267,9 +2271,10 @@ static int __init speakup_init(void)
 
 	strlwr(synth_name);
 	spk_vars[0].u.n.high = vc->vc_cols;
-	for (var = spk_vars; var->var_id !=MAXVARS; var++) 
+	for (var = spk_vars; var->var_id != MAXVARS; var++)
 		speakup_register_var(var);
-	for (var = synth_time_vars; (var->var_id >= 0) && (var->var_id < MAXVARS); var++)
+	for (var = synth_time_vars;
+	     (var->var_id >= 0) && (var->var_id < MAXVARS); var++)
 		speakup_register_var(var);
 	for (i = 1; punc_info[i].mask != 0; i++)
 		set_mask_bits(0, i, 2);
@@ -2291,14 +2296,12 @@ static int __init speakup_init(void)
 
 	speakup_task = kthread_create(speakup_thread, NULL, "speakup");
 	set_user_nice(speakup_task, 10);
-	if ( ! IS_ERR(speakup_task))
+	if (!IS_ERR(speakup_task))
 		wake_up_process(speakup_task);
 	else
 		return -ENOMEM;
 	return 0;
 }
 
-
 module_init(speakup_init);
 module_exit(speakup_exit);
-

commit 5b19208a5e236b26357162d6a28ff9e8d4296725
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Thu Oct 7 19:30:49 2010 -0700

    Staging: speakup: fix speakup core to build properly
    
    The vc_data structure changed to move the tty structure off to the port,
    so change the code to handle this.  Now the code will build properly,
    and hopefully work as well.
    
    Cc: William Hubbs <w.d.hubbs@gmail.com>
    Cc: Samuel Thibault <samuel.thibault@ens-lyon.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/speakup/main.c b/drivers/staging/speakup/main.c
index 8c549650f217..2ef3b3982a2d 100644
--- a/drivers/staging/speakup/main.c
+++ b/drivers/staging/speakup/main.c
@@ -2010,7 +2010,7 @@ speakup_key(struct vc_data *vc, int shift_state, int keycode, u_short keysym,
 		return 0;
 
 	spk_lock(flags);
-	tty = vc->vc_tty;
+	tty = vc->port.tty;
 	if (type >= 0xf0)
 		type -= 0xf0;
 	if (type == KT_PAD &&

commit c6e3fd22cd538365bfeb82997d5b89562e077d42
Author: William Hubbs <w.d.hubbs@gmail.com>
Date:   Thu Oct 7 13:20:02 2010 -0500

    Staging: add speakup to the staging directory
    
    Speakup is a kernel based screen review package for the linux operating
    system.  It allows blind users to interact with applications on the
    linux console by means of synthetic speech.
    
    The authors and maintainers of this code include the following:
    
    Kirk Reiser, Andy Berdan, John Covici, Brian and
    David Borowski, Christopher Brannon, Samuel Thibault and William Hubbs.
    
    Signed-off-by: William Hubbs <w.d.hubbs@gmail.com>
    Signed-off-by: Samuel Thibault <samuel.thibault@ens-lyon.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/speakup/main.c b/drivers/staging/speakup/main.c
new file mode 100644
index 000000000000..8c549650f217
--- /dev/null
+++ b/drivers/staging/speakup/main.c
@@ -0,0 +1,2304 @@
+/* speakup.c
+   review functions for the speakup screen review package.
+   originally written by: Kirk Reiser and Andy Berdan.
+
+  extensively modified by David Borowski.
+
+    Copyright (C) 1998  Kirk Reiser.
+    Copyright (C) 2003  David Borowski.
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
+
+#include <linux/kernel.h>
+#include <linux/version.h>
+#include <linux/vt.h>
+#include <linux/tty.h>
+#include <linux/mm.h> /* __get_free_page() and friends */
+#include <linux/vt_kern.h>
+#include <linux/ctype.h>
+#include <linux/selection.h>
+#include <linux/unistd.h>
+#include <linux/jiffies.h>
+#include <linux/kthread.h>
+#include <linux/keyboard.h>	/* for KT_SHIFT */
+#include <linux/kbd_kern.h> /* for vc_kbd_* and friends */
+#include <linux/input.h>
+#include <linux/kmod.h>
+
+#include <linux/bootmem.h>	/* for alloc_bootmem */
+
+/* speakup_*_selection */
+#include <linux/module.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/types.h>
+#include <linux/consolemap.h>
+
+#include <linux/spinlock.h>
+#include <linux/notifier.h>
+
+#include <linux/uaccess.h> /* copy_from|to|user() and others */
+
+#include "spk_priv.h"
+#include "speakup.h"
+
+#define MAX_DELAY msecs_to_jiffies(500)
+#define MINECHOCHAR SPACE
+
+MODULE_AUTHOR("Kirk Reiser <kirk@braille.uwo.ca>");
+MODULE_AUTHOR("Daniel Drake <dsd@gentoo.org>");
+MODULE_DESCRIPTION("Speakup console speech");
+MODULE_LICENSE("GPL");
+MODULE_VERSION(SPEAKUP_VERSION);
+
+char *synth_name;
+module_param_named(synth, synth_name, charp, S_IRUGO);
+module_param_named(quiet, quiet_boot, bool, S_IRUGO);
+
+MODULE_PARM_DESC(synth, "Synth to start if speakup is built in.");
+MODULE_PARM_DESC(quiet, "Do not announce when the synthesizer is found.");
+
+special_func special_handler;
+
+short pitch_shift, synth_flags;
+static char buf[256];
+int attrib_bleep, bleeps, bleep_time = 10;
+int no_intr, spell_delay;
+int key_echo, say_word_ctl;
+int say_ctrl, bell_pos;
+short punc_mask;
+int punc_level, reading_punc;
+char str_caps_start[MAXVARLEN+1] = "\0", str_caps_stop[MAXVARLEN+1] = "\0";
+const struct st_bits_data punc_info[] = {
+	{ "none", "", 0 },
+	{ "some", "/$%&@", SOME },
+	{ "most", "$%&#()=+*/@^<>|\\", MOST },
+	{ "all", "!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~", PUNC },
+	{ "delimiters", "", B_WDLM },
+	{ "repeats", "()", CH_RPT },
+	{ "extended numeric", "", B_EXNUM },
+	{ "symbols", "", B_SYM },
+	{ 0, 0 }
+};
+static char mark_cut_flag;
+#define MAX_KEY 160
+u_char *our_keys[MAX_KEY], *shift_table;
+u_char key_buf[600];
+const u_char key_defaults[] = {
+#include "speakupmap.h"
+};
+
+/* Speakup Cursor Track Variables */
+static int cursor_track = 1, prev_cursor_track = 1;
+
+/* cursor track modes, must be ordered same as cursor_msgs */
+enum {
+	CT_Off = 0,
+	CT_On,
+	CT_Highlight,
+	CT_Window,
+	CT_Max
+};
+#define read_all_mode CT_Max
+
+static struct tty_struct *tty;
+
+static void spkup_write(const char *in_buf, int count);
+
+
+static char *phonetic[] = {
+	"alfa", "bravo", "charlie", "delta", "echo", "foxtrot", "golf", "hotel",
+	"india", "juliett", "keelo", "leema", "mike", "november", "oscar", "papa",
+	"keh beck", "romeo", "sierra", "tango", "uniform", "victer", "whiskey",
+	"x ray", "yankee", "zulu"
+};
+
+/* array of 256 char pointers (one for each character description)
+ * initialized to default_chars and user selectable via
+ * /proc/speakup/characters */
+char *characters[256];
+
+char *default_chars[256] = {
+/*000*/	"null", "^a", "^b", "^c", "^d", "^e", "^f", "^g",
+/*008*/ "^h", "^i", "^j", "^k", "^l", "^m", "^n", "^o",
+/*016*/ "^p", "^q", "^r", "^s", "^t", "^u", "^v", "^w",
+/*024*/ "^x", "^y", "^z", "control", "control", "control", "control", "control",
+/*032*/ "space", "bang!", "quote", "number", "dollar", "percent", "and", "tick",
+/*040*/ "left paren", "right paren", "star", "plus", "comma", "dash", "dot",
+	"slash",
+/*048*/ "zero", "one", "two", "three", "four", "five", "six", "seven",
+	"eight", "nine",
+/*058*/ "colon", "semmy", "less", "equals", "greater", "question", "at",
+/*065*/ "EIGH", "B", "C", "D", "E", "F", "G",
+/*072*/ "H", "I", "J", "K", "L", "M", "N", "O",
+/*080*/ "P", "Q", "R", "S", "T", "U", "V", "W", "X",
+/*089*/ "Y", "ZED", "left bracket", "backslash", "right bracket", "caret",
+	"line",
+/*096*/ "accent", "a", "b", "c", "d", "e", "f", "g",
+/*104*/ "h", "i", "j", "k", "l", "m", "n", "o",
+/*112*/ "p", "q", "r", "s", "t", "u", "v", "w",
+/*120*/ "x", "y", "zed", "left brace", "bar", "right brace", "tihlduh",
+/*127*/ "del", "control", "control", "control", "control", "control", "control", "control", "control", "control", "control",
+/*138*/ "control", "control", "control", "control", "control", "control", "control", "control", "control", "control", "control", "control",
+/*150*/ "control", "control", "control", "control", "control", "control", "control", "control", "control", "control",
+/*160*/ "nbsp", "inverted bang",
+/*162*/ "cents", "pounds", "currency", "yen", "broken bar", "section", 
+/*168*/ "diaeresis", "copyright", "female ordinal", "double left angle", 
+/*172*/ "not", "soft hyphen", "registered", "macron",
+/*176*/ "degrees", "plus or minus", "super two", "super three", 
+/*180*/ "acute accent", 	"micro", "pilcrow", "middle dot", 
+/*184*/ "cedilla", "super one", "male ordinal", "double right angle",
+/*188*/ "one quarter", "one half", "three quarters", "inverted question",
+/*192*/ "A GRAVE", "A ACUTE", "A CIRCUMFLEX", "A TILDE", "A OOMLAUT", "A RING",
+/*198*/ "AE", "C CIDELLA", "E GRAVE", "E ACUTE", "E CIRCUMFLEX", "E OOMLAUT", 
+/*204*/ "I GRAVE", "I ACUTE", "I CIRCUMFLEX", "I OOMLAUT", "ETH", "N TILDE",
+/*210*/ "O GRAVE", "O ACUTE", "O CIRCUMFLEX", "O TILDE", "O OOMLAUT",
+/*215*/ "multiplied by", "O STROKE", "U GRAVE", "U ACUTE", "U CIRCUMFLEX", 
+/*220*/ "U OOMLAUT", "Y ACUTE", "THORN", "sharp s", "a grave",
+/*225*/ "a acute", "a circumflex", "a tilde", "a oomlaut", "a ring",
+/*230*/ "ae", "c cidella", "e grave", "e acute",
+/*234*/ "e circumflex", "e oomlaut", "i grave", "i acute", "i circumflex",
+/*239*/ "i oomlaut", "eth", "n tilde","o grave", "o acute", "o circumflex",
+/*245*/"o tilde", "o oomlaut", "divided by", "o stroke", "u grave", "u acute",
+/* 251 */ "u circumflex", "u oomlaut", "y acute", "thorn", "y oomlaut"
+};
+
+/* array of 256 u_short (one for each character)
+ * initialized to default_chartab and user selectable via
+ * /sys/module/speakup/parameters/chartab */
+u_short spk_chartab[256];
+
+static u_short default_chartab[256] = {
+ B_CTL, B_CTL, B_CTL, B_CTL, B_CTL, B_CTL, B_CTL, B_CTL, /* 0-7 */
+ B_CTL, B_CTL, A_CTL, B_CTL, B_CTL, B_CTL, B_CTL, B_CTL, /* 8-15 */
+ B_CTL, B_CTL, B_CTL, B_CTL, B_CTL, B_CTL, B_CTL, B_CTL, /*16-23 */
+ B_CTL, B_CTL, B_CTL, B_CTL, B_CTL, B_CTL, B_CTL, B_CTL, /* 24-31 */
+WDLM, A_PUNC, PUNC, PUNC, PUNC, PUNC, PUNC, A_PUNC, /*  !"#$%&' */
+PUNC, PUNC, PUNC, PUNC, A_PUNC, A_PUNC, A_PUNC, PUNC, /* ()*+, -./ */
+NUM, NUM, NUM, NUM, NUM, NUM, NUM, NUM, /* 01234567 */
+NUM, NUM, A_PUNC, PUNC, PUNC, PUNC, PUNC, A_PUNC, /* 89:;<=>? */
+PUNC, A_CAP, A_CAP, A_CAP, A_CAP, A_CAP, A_CAP, A_CAP, /* @ABCDEFG */
+A_CAP, A_CAP, A_CAP, A_CAP, A_CAP, A_CAP, A_CAP, A_CAP, /* HIJKLMNO */
+A_CAP, A_CAP, A_CAP, A_CAP, A_CAP, A_CAP, A_CAP, A_CAP, /* PQRSTUVW */
+A_CAP, A_CAP, A_CAP, PUNC, PUNC, PUNC, PUNC, PUNC, /* XYZ[\]^_ */
+PUNC, ALPHA, ALPHA, ALPHA, ALPHA, ALPHA, ALPHA, ALPHA, /* `abcdefg */
+ALPHA, ALPHA, ALPHA, ALPHA, ALPHA, ALPHA, ALPHA, ALPHA, /* hijklmno */
+ALPHA, ALPHA, ALPHA, ALPHA, ALPHA, ALPHA, ALPHA, ALPHA, /* pqrstuvw */
+ALPHA, ALPHA, ALPHA, PUNC, PUNC, PUNC, PUNC, 0, /* xyz{|}~ */
+B_CAPSYM, B_CAPSYM, B_SYM, B_SYM, B_SYM, B_SYM, B_SYM, B_SYM, /* 128-135 */
+B_SYM, B_SYM, B_SYM, B_SYM, B_SYM, B_SYM, B_SYM, B_CAPSYM, /* 136-143 */
+B_CAPSYM, B_CAPSYM, B_SYM, B_CAPSYM, B_SYM, B_SYM, B_SYM, B_SYM, /* 144-151 */
+B_SYM, B_SYM, B_CAPSYM, B_CAPSYM, B_SYM, B_SYM, B_SYM, B_SYM, /* 152-159 */
+WDLM, B_SYM, B_SYM, B_SYM, B_SYM, B_SYM, B_CAPSYM, B_SYM, /* 160-167 */
+B_SYM, B_SYM, B_SYM, B_SYM, B_SYM, B_SYM, B_SYM, B_SYM, /* 168-175 */
+B_SYM, B_SYM, B_SYM, B_SYM, B_SYM, B_SYM, B_SYM, B_SYM, /* 176-183 */
+B_SYM, B_SYM, B_SYM, B_SYM, B_SYM, B_SYM, B_SYM, B_SYM, /* 184-191 */
+A_CAP, A_CAP, A_CAP, A_CAP, A_CAP, A_CAP, A_CAP, A_CAP, /* 192-199 */
+A_CAP, A_CAP, A_CAP, A_CAP, A_CAP, A_CAP, A_CAP, A_CAP, /* 200-207 */
+A_CAP, A_CAP, A_CAP, A_CAP, A_CAP, A_CAP, A_CAP, B_SYM, /* 208-215 */
+A_CAP, A_CAP, A_CAP, A_CAP, A_CAP, A_CAP, A_CAP, ALPHA, /* 216-223 */
+ALPHA, ALPHA, ALPHA, ALPHA, ALPHA, ALPHA, ALPHA, ALPHA, /* 224-231 */
+ALPHA, ALPHA, ALPHA, ALPHA, ALPHA, ALPHA, ALPHA, ALPHA, /* 232-239 */
+ALPHA, ALPHA, ALPHA, ALPHA, ALPHA, ALPHA, ALPHA, B_SYM, /* 240-247 */
+ALPHA, ALPHA, ALPHA, ALPHA, ALPHA, ALPHA, ALPHA, ALPHA /* 248-255 */
+};
+
+struct task_struct *speakup_task;
+struct bleep unprocessed_sound;
+static int spk_keydown;
+static u_char spk_lastkey, spk_close_press, keymap_flags;
+static u_char last_keycode, this_speakup_key;
+static u_long last_spk_jiffy;
+
+struct st_spk_t *speakup_console[MAX_NR_CONSOLES];
+
+DEFINE_MUTEX(spk_mutex);
+
+static int keyboard_notifier_call(struct notifier_block *,
+				  unsigned long code, void *param);
+
+struct notifier_block keyboard_notifier_block = {
+	.notifier_call = keyboard_notifier_call,
+};
+
+static int vt_notifier_call(struct notifier_block *,
+			    unsigned long code, void *param);
+
+struct notifier_block vt_notifier_block = {
+	.notifier_call = vt_notifier_call,
+};
+
+static unsigned char get_attributes(u16 *pos)
+{
+	return (u_char)(scr_readw(pos) >> 8);
+}
+
+static void speakup_date(struct vc_data *vc)
+{
+	spk_x = spk_cx = vc->vc_x;
+	spk_y = spk_cy = vc->vc_y;
+	spk_pos = spk_cp = vc->vc_pos;
+	spk_old_attr = spk_attr;
+	spk_attr = get_attributes((u_short *) spk_pos);
+}
+
+static void bleep(u_short val)
+{
+	static const short vals[] = {
+		350, 370, 392, 414, 440, 466, 491, 523, 554, 587, 619, 659
+	};
+	short freq;
+	int time = bleep_time;
+	freq = vals[val%12];
+	if (val > 11)
+		freq *= (1 << (val/12));
+	unprocessed_sound.freq = freq;
+	unprocessed_sound.jiffies = msecs_to_jiffies(time);
+	unprocessed_sound.active = 1;
+	/* We can only have 1 active sound at a time. */
+}
+
+static void speakup_shut_up(struct vc_data *vc)
+{
+	if (spk_killed)
+		return;
+	spk_shut_up |= 0x01;
+	spk_parked &= 0xfe;
+	speakup_date(vc);
+	if (synth != NULL)
+		do_flush();
+}
+
+static void speech_kill(struct vc_data *vc)
+{
+	char val = synth->is_alive(synth);
+	if (val == 0)
+		return;
+
+	/* re-enables synth, if disabled */
+	if (val == 2 || spk_killed) {
+		/* dead */
+		spk_shut_up &= ~0x40;
+		synth_printf("%s\n", msg_get(MSG_IAM_ALIVE));
+	} else {
+		synth_printf("%s\n", msg_get(MSG_YOU_KILLED_SPEAKUP));
+		spk_shut_up |= 0x40;
+	}
+}
+
+static void speakup_off(struct vc_data *vc)
+{
+	if (spk_shut_up & 0x80) {
+		spk_shut_up &= 0x7f;
+		synth_printf("%s\n", msg_get(MSG_HEY_THATS_BETTER));
+	} else {
+		spk_shut_up |= 0x80;
+		synth_printf("%s\n", msg_get(MSG_YOU_TURNED_ME_OFF));
+	}
+	speakup_date(vc);
+}
+
+static void speakup_parked(struct vc_data *vc)
+{
+	if (spk_parked & 0x80) {
+		spk_parked = 0;
+		synth_printf("%s\n", msg_get(MSG_UNPARKED));
+	} else {
+		spk_parked |= 0x80;
+		synth_printf("%s\n", msg_get(MSG_PARKED));
+	}
+}
+
+static void speakup_cut(struct vc_data *vc)
+{
+	static const char err_buf[] = "set selection failed";
+	int ret;
+
+	if (!mark_cut_flag) {
+		mark_cut_flag = 1;
+		xs = (u_short) spk_x;
+		ys = (u_short) spk_y;
+		spk_sel_cons = vc;
+		synth_printf("%s\n", msg_get(MSG_MARK));
+		return;
+	}
+	xe = (u_short) spk_x;
+	ye = (u_short) spk_y;
+	mark_cut_flag = 0;
+	synth_printf("%s\n", msg_get(MSG_CUT));
+
+	speakup_clear_selection();
+	ret = speakup_set_selection(tty);
+
+	switch (ret) {
+	case 0:
+		break; /* no error */
+	case -EFAULT :
+		pr_warn("%sEFAULT\n", err_buf);
+		break;
+	case -EINVAL :
+		pr_warn("%sEINVAL\n", err_buf);
+		break;
+	case -ENOMEM :
+		pr_warn("%sENOMEM\n", err_buf);
+		break;
+	}
+}
+
+static void speakup_paste(struct vc_data *vc)
+{
+	if (mark_cut_flag) {
+		mark_cut_flag = 0;
+		synth_printf("%s\n", msg_get(MSG_MARK_CLEARED));
+	} else {
+		synth_printf("%s\n", msg_get(MSG_PASTE));
+		speakup_paste_selection(tty);
+	}
+}
+
+static void say_attributes(struct vc_data *vc)
+{
+	int fg = spk_attr & 0x0f;
+	int bg = spk_attr >> 4;
+	if (fg > 8) {
+		synth_printf("%s ", msg_get(MSG_BRIGHT));
+		fg -= 8;
+	}
+	synth_printf("%s", msg_get(MSG_COLORS_START + fg));
+	if (bg > 7) {
+		synth_printf(" %s ", msg_get(MSG_ON_BLINKING));
+		bg -= 8;
+	} else
+		synth_printf(" %s ", msg_get(MSG_ON));
+	synth_printf("%s\n", msg_get(MSG_COLORS_START + bg));
+}
+
+enum {
+	edge_top = 1,
+	edge_bottom,
+	edge_left,
+	edge_right,
+	edge_quiet
+};
+
+static void announce_edge(struct vc_data *vc, int msg_id)
+{
+	if (bleeps & 1)
+		bleep(spk_y);
+	if ((bleeps & 2) && (msg_id < edge_quiet))
+		synth_printf("%s\n", msg_get(MSG_EDGE_MSGS_START + msg_id - 1));
+}
+
+static void speak_char(u_char ch)
+{
+	char *cp = characters[ch];
+	struct var_t *direct = get_var(DIRECT);
+	if (direct && direct->u.n.value) {
+		if (IS_CHAR(ch, B_CAP)) {
+			pitch_shift++;
+			synth_printf("%s", str_caps_start);
+		}
+		synth_printf("%c", ch);
+		if (IS_CHAR(ch, B_CAP))
+			synth_printf("%s", str_caps_stop);
+		return;
+	}
+	if (cp == NULL) {
+		pr_info("speak_char: cp == NULL!\n");
+		return;
+	}
+	synth_buffer_add(SPACE);
+	if (IS_CHAR(ch, B_CAP)) {
+		pitch_shift++;
+		synth_printf("%s", str_caps_start);
+		synth_printf("%s", cp);
+		synth_printf("%s", str_caps_stop);
+	} else {
+		if (*cp == '^') {
+			synth_printf("%s", msg_get(MSG_CTRL));
+			cp++;
+		}
+		synth_printf("%s", cp);
+	}
+	synth_buffer_add(SPACE);
+}
+
+static u16 get_char(struct vc_data *vc, u16 *pos, u_char *attribs)
+{
+	u16 ch = ' ';
+	if (vc && pos) {
+		u16 w = scr_readw(pos);
+		u16 c = w & 0xff;
+
+		if (w & vc->vc_hi_font_mask)
+			c |= 0x100;
+
+		ch = inverse_translate(vc, c, 0);
+		*attribs = (w & 0xff00) >> 8;
+	}
+	return ch;
+}
+
+static void say_char(struct vc_data *vc)
+{
+	u_short ch;
+	spk_old_attr = spk_attr;
+	ch = get_char(vc, (u_short *) spk_pos, &spk_attr);
+	if (spk_attr != spk_old_attr) {
+		if (attrib_bleep & 1)
+			bleep(spk_y);
+		if (attrib_bleep & 2)
+			say_attributes(vc);
+	}
+	speak_char(ch & 0xff);
+}
+
+static void say_phonetic_char(struct vc_data *vc)
+{
+	u_short ch;
+	spk_old_attr = spk_attr;
+	ch = get_char(vc, (u_short *) spk_pos, &spk_attr);
+	if (isascii(ch) && isalpha(ch)) {
+		ch &= 0x1f;
+		synth_printf("%s\n", phonetic[--ch]);
+	} else {
+		if (IS_CHAR(ch, B_NUM))
+			synth_printf("%s ", msg_get(MSG_NUMBER));
+		speak_char(ch);
+	}
+}
+
+static void say_prev_char(struct vc_data *vc)
+{
+	spk_parked |= 0x01;
+	if (spk_x == 0) {
+		announce_edge(vc, edge_left);
+		return;
+	}
+	spk_x--;
+	spk_pos -= 2;
+	say_char(vc);
+}
+
+static void say_next_char(struct vc_data *vc)
+{
+	spk_parked |= 0x01;
+	if (spk_x == vc->vc_cols - 1) {
+		announce_edge(vc, edge_right);
+		return;
+	}
+	spk_x++;
+	spk_pos += 2;
+	say_char(vc);
+}
+
+/* get_word - will first check to see if the character under the
+   reading cursor is a space and if say_word_ctl is true it will
+   return the word space.  If say_word_ctl is not set it will check to
+   see if there is a word starting on the next position to the right
+   and return that word if it exists.  If it does not exist it will
+   move left to the beginning of any previous word on the line or the
+   beginning off the line whichever comes first.. */
+
+static u_long get_word(struct vc_data *vc)
+{
+	u_long cnt = 0, tmpx = spk_x, tmp_pos = spk_pos;
+	char ch;
+	u_short attr_ch;
+	u_char temp;
+	spk_old_attr = spk_attr;
+	ch = (char) get_char(vc, (u_short *) tmp_pos, &temp);
+
+/* decided to take out the sayword if on a space (mis-information */
+	if (say_word_ctl && ch == SPACE) {
+		*buf = '\0';
+		synth_printf("%s\n", msg_get(MSG_SPACE));
+		return 0;
+	} else if ((tmpx < vc->vc_cols - 2)
+		   && (ch == SPACE || ch == 0 || IS_WDLM(ch))
+		   && ((char) get_char(vc, (u_short *) &tmp_pos+1, &temp) > SPACE)) {
+		tmp_pos += 2;
+		tmpx++;
+	} else
+		while (tmpx > 0) {
+			ch = (char) get_char(vc, (u_short *) tmp_pos - 1, &temp);
+			if ((ch == SPACE || ch == 0 || IS_WDLM(ch))
+			    && ((char) get_char(vc, (u_short *) tmp_pos, &temp) >
+									SPACE))
+				break;
+			tmp_pos -= 2;
+			tmpx--;
+		}
+	attr_ch = get_char(vc, (u_short *) tmp_pos, &spk_attr);
+	buf[cnt++] = attr_ch & 0xff;
+	while (tmpx < vc->vc_cols - 1) {
+		tmp_pos += 2;
+		tmpx++;
+		ch = (char) get_char(vc, (u_short *) tmp_pos, &temp);
+		if ((ch == SPACE) || ch == 0 || (IS_WDLM(buf[cnt-1]) && (ch > SPACE)))
+			break;
+		buf[cnt++] = ch;
+	}
+	buf[cnt] = '\0';
+	return cnt;
+}
+
+static void say_word(struct vc_data *vc)
+{
+	u_long cnt = get_word(vc);
+	u_short saved_punc_mask = punc_mask;
+	if (cnt == 0)
+		return;
+	punc_mask = PUNC;
+	buf[cnt++] = SPACE;
+	spkup_write(buf, cnt);
+	punc_mask = saved_punc_mask;
+}
+
+static void say_prev_word(struct vc_data *vc)
+{
+	u_char temp;
+	char ch;
+	u_short edge_said = 0, last_state = 0, state = 0;
+	spk_parked |= 0x01;
+
+	if (spk_x == 0) {
+		if (spk_y == 0) {
+			announce_edge(vc, edge_top);
+			return;
+		}
+		spk_y--;
+		spk_x = vc->vc_cols;
+		edge_said = edge_quiet;
+	}
+	while (1) {
+		if (spk_x == 0) {
+			if (spk_y == 0) {
+				edge_said = edge_top;
+				break;
+			}
+			if (edge_said != edge_quiet)
+				edge_said = edge_left;
+			if (state > 0)
+				break;
+			spk_y--;
+			spk_x = vc->vc_cols - 1;
+		} else
+			spk_x--;
+			spk_pos -= 2;
+		ch = (char) get_char(vc, (u_short *) spk_pos, &temp);
+		if (ch == SPACE || ch == 0)
+			state = 0;
+		else if (IS_WDLM(ch))
+			state = 1;
+		else
+			state = 2;
+		if (state < last_state) {
+			spk_pos += 2;
+			spk_x++;
+			break;
+		}
+		last_state = state;
+	}
+	if (spk_x == 0 && edge_said == edge_quiet)
+		edge_said = edge_left;
+	if (edge_said > 0 && edge_said < edge_quiet)
+		announce_edge(vc, edge_said);
+	say_word(vc);
+}
+
+static void say_next_word(struct vc_data *vc)
+{
+	u_char temp;
+	char ch;
+	u_short edge_said = 0, last_state = 2, state = 0;
+	spk_parked |= 0x01;
+
+	if (spk_x == vc->vc_cols - 1 && spk_y == vc->vc_rows - 1) {
+		announce_edge(vc, edge_bottom);
+		return;
+	}
+	while (1) {
+		ch = (char) get_char(vc, (u_short *) spk_pos, &temp);
+		if (ch == SPACE || ch == 0)
+			state = 0;
+		else if (IS_WDLM(ch))
+			state = 1;
+		else
+			state = 2;
+		if (state > last_state)
+			break;
+		if (spk_x >= vc->vc_cols - 1) {
+			if (spk_y == vc->vc_rows - 1) {
+				edge_said = edge_bottom;
+				break;
+			}
+			state = 0;
+			spk_y++;
+			spk_x = 0;
+			edge_said = edge_right;
+		} else
+			spk_x++;
+		spk_pos += 2;
+		last_state = state;
+	}
+	if (edge_said > 0)
+		announce_edge(vc, edge_said);
+	say_word(vc);
+}
+
+static void spell_word(struct vc_data *vc)
+{
+	static char *delay_str[] = { "", ",", ".", ". .", ". . ." };
+	char *cp = buf, *str_cap = str_caps_stop;
+	char *cp1, *last_cap = str_caps_stop;
+	u_char ch;
+	if (!get_word(vc))
+		return;
+	while ((ch = (u_char) *cp)) {
+		if (cp != buf)
+			synth_printf(" %s ", delay_str[spell_delay]);
+		if (IS_CHAR(ch, B_CAP)) {
+			str_cap = str_caps_start;
+			if (*str_caps_stop)
+				pitch_shift++;
+			else /* synth has no pitch */
+				last_cap = str_caps_stop;
+		} else
+			str_cap = str_caps_stop;
+		if (str_cap != last_cap) {
+			synth_printf("%s", str_cap);
+			last_cap = str_cap;
+		}
+		if (this_speakup_key == SPELL_PHONETIC
+		    && (isascii(ch) && isalpha(ch))) {
+			ch &= 31;
+			cp1 = phonetic[--ch];
+		} else {
+			cp1 = characters[ch];
+			if (*cp1 == '^') {
+				synth_printf("%s", msg_get(MSG_CTRL));
+				cp1++;
+			}
+		}
+		synth_printf("%s", cp1);
+		cp++;
+	}
+	if (str_cap != str_caps_stop)
+		synth_printf("%s", str_caps_stop);
+}
+
+static int get_line(struct vc_data *vc)
+{
+	u_long tmp = spk_pos - (spk_x * 2);
+	int i = 0;
+	u_char tmp2;
+
+	spk_old_attr = spk_attr;
+	spk_attr = get_attributes((u_short *) spk_pos);
+	for (i = 0; i < vc->vc_cols; i++) {
+		buf[i] = (u_char) get_char(vc, (u_short *) tmp, &tmp2);
+		tmp += 2;
+	}
+	for (--i; i >= 0; i--)
+		if (buf[i] != SPACE)
+			break;
+	return ++i;
+}
+
+static void say_line(struct vc_data *vc)
+{
+	int i = get_line(vc);
+	char *cp;
+	u_short saved_punc_mask = punc_mask;
+	if (i == 0) {
+		synth_printf("%s\n", msg_get(MSG_BLANK));
+		return;
+	}
+	buf[i++] = '\n';
+	if (this_speakup_key == SAY_LINE_INDENT) {
+		for (cp = buf; *cp == SPACE; cp++)
+			;
+		synth_printf("%d, ", (cp - buf) + 1);
+	}
+	punc_mask = punc_masks[reading_punc];
+	spkup_write(buf, i);
+	punc_mask = saved_punc_mask;
+}
+
+static void say_prev_line(struct vc_data *vc)
+{
+	spk_parked |= 0x01;
+	if (spk_y == 0) {
+		announce_edge(vc, edge_top);
+		return;
+	}
+	spk_y--;
+	spk_pos -= vc->vc_size_row;
+	say_line(vc);
+}
+
+static void say_next_line(struct vc_data *vc)
+{
+	spk_parked |= 0x01;
+	if (spk_y == vc->vc_rows - 1) {
+		announce_edge(vc, edge_bottom);
+		return;
+	}
+	spk_y++;
+	spk_pos += vc->vc_size_row;
+	say_line(vc);
+}
+
+static int say_from_to(struct vc_data *vc, u_long from, u_long to,
+		       int read_punc)
+{
+	int i = 0;
+	u_char tmp;
+	u_short saved_punc_mask = punc_mask;
+	spk_old_attr = spk_attr;
+	spk_attr = get_attributes((u_short *) from);
+	while (from < to) {
+		buf[i++] = (char) get_char(vc, (u_short *) from, &tmp);
+		from += 2;
+		if (i >= vc->vc_size_row)
+			break;
+	}
+	for (--i; i >= 0; i--)
+		if (buf[i] != SPACE)
+			break;
+	buf[++i] = SPACE;
+	buf[++i] = '\0';
+	if (i < 1)
+		return i;
+	if (read_punc)
+		punc_mask = punc_info[reading_punc].mask;
+	spkup_write(buf, i);
+	if (read_punc)
+		punc_mask = saved_punc_mask;
+	return i - 1;
+}
+
+static void say_line_from_to(struct vc_data *vc, u_long from, u_long to,
+			     int read_punc)
+{
+	u_long start = vc->vc_origin + (spk_y * vc->vc_size_row);
+	u_long end = start + (to * 2);
+	start += from * 2;
+	if (say_from_to(vc, start, end, read_punc) <= 0)
+		if (cursor_track != read_all_mode)
+			synth_printf("%s\n", msg_get(MSG_BLANK));
+}
+
+/* Sentence Reading Commands */
+
+void synth_insert_next_index(int);
+
+static int currsentence;
+static int numsentences[2];
+static char *sentbufend[2];
+static char *sentmarks[2][10];
+static int currbuf;
+static int bn;
+static char sentbuf[2][256];
+
+static int say_sentence_num(int num , int prev)
+{
+	bn = currbuf;
+	currsentence = num + 1;
+	if (prev && --bn == -1)
+		bn = 1;
+
+	if (num > numsentences[bn])
+		return 0;
+
+	spkup_write(sentmarks[bn][num], sentbufend[bn] - sentmarks[bn][num]);
+	return 1;
+}
+
+static int get_sentence_buf(struct vc_data *vc, int read_punc)
+{
+	u_long start, end;
+	int i, bn;
+	u_char tmp;
+
+	currbuf++;
+	if (currbuf == 2)
+		currbuf = 0;
+	bn = currbuf;
+	start = vc->vc_origin + ((spk_y) * vc->vc_size_row);
+	end = vc->vc_origin+((spk_y) * vc->vc_size_row) + vc->vc_cols * 2;
+
+	numsentences[bn] = 0;
+	sentmarks[bn][0] = &sentbuf[bn][0];
+	i = 0;
+	spk_old_attr = spk_attr;
+	spk_attr = get_attributes((u_short *) start);
+
+	while (start < end) {
+		sentbuf[bn][i] = (char) get_char(vc, (u_short *) start, &tmp);
+		if (i > 0) {
+			if (sentbuf[bn][i] == SPACE && sentbuf[bn][i-1] == '.'
+			    && numsentences[bn] < 9) {
+				/* Sentence Marker */
+				numsentences[bn]++;
+				sentmarks[bn][numsentences[bn]] =
+					&sentbuf[bn][i];
+			}
+		}
+		i++;
+		start += 2;
+		if (i >= vc->vc_size_row)
+			break;
+	}
+
+	for (--i; i >= 0; i--)
+		if (sentbuf[bn][i] != SPACE)
+			break;
+
+	if (i < 1)
+		return -1;
+
+	sentbuf[bn][++i] = SPACE;
+	sentbuf[bn][++i] = '\0';
+
+	sentbufend[bn] = &sentbuf[bn][i];
+	return numsentences[bn];
+}
+
+static void say_screen_from_to(struct vc_data *vc, u_long from, u_long to)
+{
+	u_long start = vc->vc_origin, end;
+	if (from > 0)
+		start += from * vc->vc_size_row;
+	if (to > vc->vc_rows)
+		to = vc->vc_rows;
+	end = vc->vc_origin + (to * vc->vc_size_row);
+	for (from = start; from < end; from = to) {
+		to = from + vc->vc_size_row;
+		say_from_to(vc, from, to, 1);
+	}
+}
+
+static void say_screen(struct vc_data *vc)
+{
+	say_screen_from_to(vc, 0, vc->vc_rows);
+}
+
+static void speakup_win_say(struct vc_data *vc)
+{
+	u_long start, end, from, to;
+	if (win_start < 2) {
+		synth_printf("%s\n", msg_get(MSG_NO_WINDOW));
+		return;
+	}
+	start = vc->vc_origin + (win_top * vc->vc_size_row);
+	end = vc->vc_origin + (win_bottom * vc->vc_size_row);
+	while (start <= end) {
+		from = start + (win_left * 2);
+		to = start + (win_right * 2);
+		say_from_to(vc, from, to, 1);
+		start += vc->vc_size_row;
+	}
+}
+
+static void top_edge(struct vc_data *vc)
+{
+	spk_parked |= 0x01;
+	spk_pos = vc->vc_origin + 2 * spk_x;
+	spk_y = 0;
+	say_line(vc);
+}
+
+static void bottom_edge(struct vc_data *vc)
+{
+	spk_parked |= 0x01;
+	spk_pos += (vc->vc_rows - spk_y - 1) * vc->vc_size_row;
+	spk_y = vc->vc_rows - 1;
+	say_line(vc);
+}
+
+static void left_edge(struct vc_data *vc)
+{
+	spk_parked |= 0x01;
+	spk_pos -= spk_x * 2;
+	spk_x = 0;
+	say_char(vc);
+}
+
+static void right_edge(struct vc_data *vc)
+{
+	spk_parked |= 0x01;
+	spk_pos += (vc->vc_cols - spk_x - 1) * 2;
+	spk_x = vc->vc_cols - 1;
+	say_char(vc);
+}
+
+static void say_first_char(struct vc_data *vc)
+{
+	int i, len = get_line(vc);
+	u_char ch;
+	spk_parked |= 0x01;
+	if (len == 0) {
+		synth_printf("%s\n", msg_get(MSG_BLANK));
+		return;
+	}
+	for (i = 0; i < len; i++)
+		if (buf[i] != SPACE)
+			break;
+	ch = buf[i];
+	spk_pos -= (spk_x - i) * 2;
+	spk_x = i;
+	synth_printf("%d, ", ++i);
+	speak_char(ch);
+}
+
+static void say_last_char(struct vc_data *vc)
+{
+	int len = get_line(vc);
+	u_char ch;
+	spk_parked |= 0x01;
+	if (len == 0) {
+		synth_printf("%s\n", msg_get(MSG_BLANK));
+		return;
+	}
+	ch = buf[--len];
+	spk_pos -= (spk_x - len) * 2;
+	spk_x = len;
+	synth_printf("%d, ", ++len);
+	speak_char(ch);
+}
+
+static void say_position(struct vc_data *vc)
+{
+	synth_printf(msg_get(MSG_POS_INFO), spk_y + 1, spk_x + 1,
+		vc->vc_num + 1);
+	synth_printf("\n");
+}
+
+/* Added by brianb */
+static void say_char_num(struct vc_data *vc)
+{
+	u_char tmp;
+	u_short ch = get_char(vc, (u_short *) spk_pos, &tmp);
+	ch &= 0xff;
+	synth_printf(msg_get(MSG_CHAR_INFO), ch, ch);
+}
+
+/* these are stub functions to keep keyboard.c happy. */
+
+static void say_from_top(struct vc_data *vc)
+{
+	say_screen_from_to(vc, 0, spk_y);
+}
+
+static void say_to_bottom(struct vc_data *vc)
+{
+	say_screen_from_to(vc, spk_y, vc->vc_rows);
+}
+
+static void say_from_left(struct vc_data *vc)
+{
+	say_line_from_to(vc, 0, spk_x, 1);
+}
+
+static void say_to_right(struct vc_data *vc)
+{
+	say_line_from_to(vc, spk_x, vc->vc_cols, 1);
+}
+
+/* end of stub functions. */
+
+static void spkup_write(const char *in_buf, int count)
+{
+	static int rep_count = 0;
+	static u_char ch = '\0', old_ch = '\0';
+	static u_short char_type = 0, last_type = 0;
+	int in_count = count;
+	spk_keydown = 0;
+	while (count--) {
+		if (cursor_track == read_all_mode) {
+			/* Insert Sentence Index */
+			if ((in_buf == sentmarks[bn][currsentence]) &&
+			   (currsentence <= numsentences[bn]))
+				synth_insert_next_index(currsentence++);
+		}
+		ch = (u_char)*in_buf++;
+		char_type = spk_chartab[ch];
+		if (ch == old_ch && !(char_type&B_NUM)) {
+			if (++rep_count > 2)
+				continue;
+		} else {
+			if ((last_type&CH_RPT) && rep_count > 2) {
+				synth_printf(" ");
+				synth_printf(msg_get(MSG_REPEAT_DESC), ++rep_count);
+				synth_printf(" ");
+			}
+			rep_count = 0;
+		}
+		if (ch == spk_lastkey) {
+			rep_count = 0;
+			if (key_echo == 1 && ch >= MINECHOCHAR)
+				speak_char(ch);
+		} else if (char_type & B_ALPHA) {
+			if ((synth_flags & SF_DEC) && (last_type & PUNC))
+				synth_buffer_add(SPACE);
+			synth_printf("%c", ch);
+		} else if (char_type & B_NUM) {
+			rep_count = 0;
+			synth_printf("%c", ch);
+		} else if (char_type&punc_mask) {
+			speak_char(ch);
+			char_type &= ~PUNC; /* for dec nospell processing */
+		} else if (char_type&SYNTH_OK) {
+/* these are usually puncts like . and , which synth needs for expression.
+ * suppress multiple to get rid of long pausesand clear repeat count so if
+ *someone has repeats on you don't get nothing repeated count */
+			if (ch != old_ch)
+				synth_printf("%c", ch);
+			else
+				rep_count = 0;
+		} else {
+/* send space and record position, if next is num overwrite space */
+			if (old_ch != ch)
+				synth_buffer_add(SPACE);
+			else
+				rep_count = 0;
+		}
+		old_ch = ch;
+		last_type = char_type;
+	}
+	spk_lastkey = 0;
+	if (in_count > 2 && rep_count > 2) {
+		if (last_type&CH_RPT) {
+			synth_printf(" ");
+			synth_printf(msg_get(MSG_REPEAT_DESC2), ++rep_count);
+			synth_printf(" ");
+		}
+		rep_count = 0;
+	}
+}
+
+static const int NUM_CTL_LABELS = (MSG_CTL_END - MSG_CTL_START + 1);
+
+static void read_all_doc(struct vc_data *vc);
+static void cursor_done(u_long data);
+static DEFINE_TIMER(cursor_timer, cursor_done, 0, 0);
+
+static void do_handle_shift(struct vc_data *vc, u_char value, char up_flag)
+{
+	unsigned long flags;
+	if (synth == NULL || up_flag || spk_killed)
+		return;
+	spk_lock(flags);
+	if (cursor_track == read_all_mode) {
+		switch (value) {
+		case KVAL(K_SHIFT):
+			del_timer(&cursor_timer);
+			spk_shut_up &= 0xfe;
+			do_flush();
+			read_all_doc(vc);
+			break;
+		case KVAL(K_CTRL):
+			del_timer(&cursor_timer);
+			cursor_track = prev_cursor_track;
+			spk_shut_up &= 0xfe;
+			do_flush();
+			break;
+		}
+	} else {
+		spk_shut_up &= 0xfe;
+		do_flush();
+	}
+	if (say_ctrl && value < NUM_CTL_LABELS)
+		synth_printf("%s", msg_get(MSG_CTL_START + value));
+	spk_unlock(flags);
+}
+
+static void do_handle_latin(struct vc_data *vc, u_char value, char up_flag)
+{
+	unsigned long flags;
+	spk_lock(flags);
+	if (up_flag) {
+		spk_lastkey = spk_keydown = 0;
+		spk_unlock(flags);
+		return;
+	}
+	if (synth == NULL || spk_killed) {
+		spk_unlock(flags);
+		return;
+	}
+	spk_shut_up &= 0xfe;
+	spk_lastkey = value;
+	spk_keydown++;
+	spk_parked &= 0xfe;
+	if (key_echo == 2 && value >= MINECHOCHAR)
+		speak_char(value);
+	spk_unlock(flags);
+}
+
+int set_key_info(const u_char *key_info, u_char *k_buffer)
+{
+	int i = 0, states, key_data_len;
+	const u_char *cp = key_info;
+	u_char *cp1 = k_buffer;
+	u_char ch, version, num_keys;
+	version = *cp++;
+	if (version != KEY_MAP_VER)
+		return -1;
+	num_keys = *cp;
+	states = (int) cp[1];
+	key_data_len = (states + 1) * (num_keys + 1);
+	if (key_data_len + SHIFT_TBL_SIZE + 4 >= sizeof(key_buf))
+		return -2;
+	memset(k_buffer, 0, SHIFT_TBL_SIZE);
+	memset(our_keys, 0, sizeof(our_keys));
+	shift_table = k_buffer;
+	our_keys[0] = shift_table;
+	cp1 += SHIFT_TBL_SIZE;
+	memcpy(cp1, cp, key_data_len + 3);
+	/* get num_keys, states and data*/
+	cp1 += 2; /* now pointing at shift states */
+	for (i = 1; i <= states; i++) {
+		ch = *cp1++;
+		if (ch >= SHIFT_TBL_SIZE)
+			return -3;
+		shift_table[ch] = i;
+	}
+	keymap_flags = *cp1++;
+	while ((ch = *cp1)) {
+		if (ch >= MAX_KEY)
+			return -4;
+		our_keys[ch] = cp1;
+		cp1 += states + 1;
+	}
+	return 0;
+}
+
+static struct var_t spk_vars[] = {
+	/* bell must be first to set high limit */
+	{ BELL_POS, .u.n = {NULL, 0, 0, 0, 0, 0, NULL }},
+	{ SPELL_DELAY, .u.n = {NULL, 0, 0, 4, 0, 0, NULL }},
+	{ ATTRIB_BLEEP, .u.n = {NULL, 1, 0, 3, 0, 0, NULL }},
+	{ BLEEPS, .u.n = {NULL, 3, 0, 3, 0, 0, NULL }},
+	{ BLEEP_TIME, .u.n = {NULL, 30, 1, 200, 0, 0, NULL }},
+	{ PUNC_LEVEL, .u.n = {NULL, 1, 0, 4, 0, 0, NULL }},
+	{ READING_PUNC, .u.n = {NULL, 1, 0, 4, 0, 0, NULL }},
+	{ CURSOR_TIME, .u.n = {NULL, 120, 50, 600, 0, 0, NULL }},
+	{ SAY_CONTROL, TOGGLE_0 },
+	{ SAY_WORD_CTL, TOGGLE_0 },
+	{ NO_INTERRUPT, TOGGLE_0 },
+	{ KEY_ECHO, .u.n = {NULL, 1, 0, 2, 0, 0, NULL }},
+	V_LAST_VAR
+};
+
+
+static void toggle_cursoring(struct vc_data *vc)
+{
+	if (cursor_track == read_all_mode)
+		cursor_track = prev_cursor_track;
+	if (++cursor_track >= CT_Max)
+		cursor_track = 0;
+	synth_printf("%s\n", msg_get(MSG_CURSOR_MSGS_START + cursor_track));
+}
+
+void reset_default_chars(void)
+{
+	int i;
+
+	/* First, free any non-default */
+	for (i = 0; i < 256; i++) {
+		if ((characters[i] != NULL)
+		    && (characters[i] != default_chars[i]))
+			kfree(characters[i]);
+	}
+
+	memcpy(characters, default_chars, sizeof(default_chars));
+}
+
+void reset_default_chartab(void)
+{
+	memcpy(spk_chartab, default_chartab, sizeof(default_chartab));
+}
+
+static const struct st_bits_data *pb_edit = NULL;
+
+static int edit_bits(struct vc_data *vc, u_char type, u_char ch, u_short key)
+{
+	short mask = pb_edit->mask, ch_type = spk_chartab[ch];
+	if (type != KT_LATIN || (ch_type&B_NUM) || ch < SPACE)
+		return -1;
+	if (ch == SPACE) {
+		synth_printf("%s\n", msg_get(MSG_EDIT_DONE));
+		special_handler = NULL;
+		return 1;
+	}
+	if (mask < PUNC && !(ch_type&PUNC))
+		return -1;
+	spk_chartab[ch] ^= mask;
+	speak_char(ch);
+	synth_printf(" %s\n",
+		(spk_chartab[ch]&mask) ? msg_get(MSG_ON) : msg_get(MSG_OFF));
+	return 1;
+}
+
+/* Allocation concurrency is protected by the console semaphore */
+void speakup_allocate(struct vc_data *vc)
+{
+	int vc_num;
+
+	vc_num = vc->vc_num;
+	if (speakup_console[vc_num] == NULL) {
+		speakup_console[vc_num] = kzalloc(sizeof(*speakup_console[0]),
+			GFP_ATOMIC);
+		if (speakup_console[vc_num] == NULL)
+			return;
+		speakup_date(vc);
+	} else if (!spk_parked)
+		speakup_date(vc);
+}
+
+void speakup_deallocate(struct vc_data *vc)
+{
+	int vc_num;
+
+	vc_num = vc->vc_num;
+	if (speakup_console[vc_num] != NULL) {
+		kfree(speakup_console[vc_num]);
+		speakup_console[vc_num] = NULL;
+	}
+}
+
+static u_char is_cursor;
+static u_long old_cursor_pos, old_cursor_x, old_cursor_y;
+static int cursor_con;
+
+static void reset_highlight_buffers(struct vc_data *);
+
+static int read_all_key;
+
+void reset_index_count(int);
+void get_index_count(int *, int *);
+/*int synth_supports_indexing(void); */
+static void start_read_all_timer(struct vc_data *vc, int command);
+
+enum {
+	RA_NOTHING,
+	RA_NEXT_SENT,
+	RA_PREV_LINE,
+	RA_NEXT_LINE,
+	RA_PREV_SENT,
+	RA_DOWN_ARROW,
+	RA_TIMER,
+	RA_FIND_NEXT_SENT,
+	RA_FIND_PREV_SENT,
+};
+
+static void
+kbd_fakekey2(struct vc_data *vc, int command)
+{
+	del_timer(&cursor_timer);
+	speakup_fake_down_arrow();
+	start_read_all_timer(vc, command);
+}
+
+static void
+read_all_doc(struct vc_data *vc)
+{
+	if ((vc->vc_num != fg_console) || synth == NULL || spk_shut_up)
+		return;
+	if (!synth_supports_indexing())
+		return;
+	if (cursor_track != read_all_mode)
+		prev_cursor_track = cursor_track;
+	cursor_track = read_all_mode;
+	reset_index_count(0);
+	if (get_sentence_buf(vc, 0) == -1)
+		kbd_fakekey2(vc, RA_DOWN_ARROW);
+	else {
+		say_sentence_num(0, 0);
+		synth_insert_next_index(0);
+		start_read_all_timer(vc, RA_TIMER);
+	}
+}
+
+static void
+stop_read_all(struct vc_data *vc)
+{
+	del_timer(&cursor_timer);
+	cursor_track = prev_cursor_track;
+	spk_shut_up &= 0xfe;
+	do_flush();
+}
+
+static void
+start_read_all_timer(struct vc_data *vc, int command)
+{
+	struct var_t *cursor_timeout;
+
+	cursor_con = vc->vc_num;
+	read_all_key = command;
+	cursor_timeout = get_var(CURSOR_TIME);
+	mod_timer(&cursor_timer, jiffies + msecs_to_jiffies(cursor_timeout->u.n.value));
+}
+
+static void
+handle_cursor_read_all(struct vc_data *vc, int command)
+{
+	int indcount, sentcount, rv, sn;
+
+	switch (command) {
+	case RA_NEXT_SENT:
+		/* Get Current Sentence */
+		get_index_count(&indcount, &sentcount);
+		/*printk("%d %d  ", indcount, sentcount); */
+		reset_index_count(sentcount+1);
+		if (indcount == 1) {
+			if (!say_sentence_num(sentcount+1, 0)) {
+				kbd_fakekey2(vc, RA_FIND_NEXT_SENT);
+				return;
+			}
+			synth_insert_next_index(0);
+		} else {
+			sn = 0;
+			if (!say_sentence_num(sentcount+1, 1)) {
+				sn = 1;
+				reset_index_count(sn);
+			} else
+				synth_insert_next_index(0);
+			if (!say_sentence_num(sn, 0)) {
+				kbd_fakekey2(vc, RA_FIND_NEXT_SENT);
+				return;
+			}
+			synth_insert_next_index(0);
+		}
+		start_read_all_timer(vc, RA_TIMER);
+		break;
+	case RA_PREV_SENT:
+		break;
+	case RA_NEXT_LINE:
+		read_all_doc(vc);
+		break;
+	case RA_PREV_LINE:
+		break;
+	case RA_DOWN_ARROW:
+		if (get_sentence_buf(vc, 0) == -1) {
+			kbd_fakekey2(vc, RA_DOWN_ARROW);
+		} else {
+			say_sentence_num(0, 0);
+			synth_insert_next_index(0);
+			start_read_all_timer(vc, RA_TIMER);
+		}
+		break;
+	case RA_FIND_NEXT_SENT:
+		rv = get_sentence_buf(vc, 0);
+		if (rv == -1)
+			read_all_doc(vc);
+		if (rv == 0)
+			kbd_fakekey2(vc, RA_FIND_NEXT_SENT);
+		else {
+			say_sentence_num(1, 0);
+			synth_insert_next_index(0);
+			start_read_all_timer(vc, RA_TIMER);
+		}
+		break;
+	case RA_FIND_PREV_SENT:
+		break;
+	case RA_TIMER:
+		get_index_count(&indcount, &sentcount);
+		if (indcount < 2)
+			kbd_fakekey2(vc, RA_DOWN_ARROW);
+		else
+			start_read_all_timer(vc, RA_TIMER);
+		break;
+	}
+}
+
+static int pre_handle_cursor(struct vc_data *vc, u_char value, char up_flag)
+{
+	unsigned long flags;
+	spk_lock(flags);
+	if (cursor_track == read_all_mode) {
+		spk_parked &= 0xfe;
+		if (synth == NULL || up_flag || spk_shut_up) {
+			spk_unlock(flags);
+			return NOTIFY_STOP;
+		}
+		del_timer(&cursor_timer);
+		spk_shut_up &= 0xfe;
+		do_flush();
+		start_read_all_timer(vc, value+1);
+		spk_unlock(flags);
+		return NOTIFY_STOP;
+	}
+	spk_unlock(flags);
+	return NOTIFY_OK;
+}
+
+static void do_handle_cursor(struct vc_data *vc, u_char value, char up_flag)
+{
+	unsigned long flags;
+	struct var_t *cursor_timeout;
+
+	spk_lock(flags);
+	spk_parked &= 0xfe;
+	if (synth == NULL || up_flag || spk_shut_up || cursor_track == CT_Off) {
+		spk_unlock(flags);
+		return;
+	}
+	spk_shut_up &= 0xfe;
+	if (no_intr)
+		do_flush();
+/* the key press flushes if !no_inter but we want to flush on cursor
+ * moves regardless of no_inter state */
+	is_cursor = value + 1;
+	old_cursor_pos = vc->vc_pos;
+	old_cursor_x = vc->vc_x;
+	old_cursor_y = vc->vc_y;
+	speakup_console[vc->vc_num]->ht.cy = vc->vc_y;
+	cursor_con = vc->vc_num;
+	if (cursor_track == CT_Highlight)
+		reset_highlight_buffers(vc);
+	cursor_timeout = get_var(CURSOR_TIME);
+	mod_timer(&cursor_timer, jiffies + msecs_to_jiffies(cursor_timeout->u.n.value));
+	spk_unlock(flags);
+}
+
+static void
+update_color_buffer(struct vc_data *vc , const char *ic , int len)
+{
+	int i, bi, hi;
+	int vc_num = vc->vc_num;
+
+	bi = ((vc->vc_attr & 0x70) >> 4) ;
+	hi = speakup_console[vc_num]->ht.highsize[bi];
+
+	i = 0;
+	if (speakup_console[vc_num]->ht.highsize[bi] == 0) {
+		speakup_console[vc_num]->ht.rpos[bi] = vc->vc_pos;
+		speakup_console[vc_num]->ht.rx[bi] = vc->vc_x;
+		speakup_console[vc_num]->ht.ry[bi] = vc->vc_y;
+	}
+	while ((hi < COLOR_BUFFER_SIZE) && (i < len)) {
+		if ((ic[i] > 32) && (ic[i] < 127)) {
+			speakup_console[vc_num]->ht.highbuf[bi][hi] = ic[i];
+			hi++;
+		} else if ((ic[i] == 32) && (hi != 0)) {
+			if (speakup_console[vc_num]->ht.highbuf[bi][hi-1] !=
+									32) {
+				speakup_console[vc_num]->ht.highbuf[bi][hi] =
+					ic[i];
+				hi++;
+			}
+		}
+		i++;
+	}
+	speakup_console[vc_num]->ht.highsize[bi] = hi;
+}
+
+static void
+reset_highlight_buffers(struct vc_data *vc)
+{
+	int i;
+	int vc_num = vc->vc_num;
+	for (i = 0 ; i < 8 ; i++)
+		speakup_console[vc_num]->ht.highsize[i] = 0;
+}
+
+static int
+count_highlight_color(struct vc_data *vc)
+{
+	int i, bg;
+	int cc;
+	int vc_num = vc->vc_num;
+	u16 ch;
+	u16 *start = (u16 *) vc->vc_origin;
+
+	for (i = 0; i < 8; i++)
+		speakup_console[vc_num]->ht.bgcount[i] = 0;
+
+	for (i = 0; i < vc->vc_rows; i++) {
+		u16 *end = start + vc->vc_cols*2;
+		u16 *ptr;
+		for (ptr = start; ptr < end; ptr++) {
+			ch = get_attributes(ptr);
+			bg = (ch & 0x70) >> 4;
+			speakup_console[vc_num]->ht.bgcount[bg]++;
+		}
+		start += vc->vc_size_row;
+	}
+
+	cc = 0;
+	for (i = 0; i < 8; i++)
+		if (speakup_console[vc_num]->ht.bgcount[i] > 0)
+			cc++;
+	return cc;
+}
+
+static int
+get_highlight_color(struct vc_data *vc)
+{
+	int i, j;
+	unsigned int cptr[8], tmp;
+	int vc_num = vc->vc_num;
+
+	for (i = 0; i < 8; i++)
+		cptr[i] = i;
+
+	for (i = 0; i < 7; i++)
+		for (j = i + 1; j < 8; j++)
+			if (speakup_console[vc_num]->ht.bgcount[cptr[i]] >
+				speakup_console[vc_num]->ht.bgcount[cptr[j]]) {
+				tmp = cptr[i];
+				cptr[i] = cptr[j];
+				cptr[j] = tmp;
+			}
+
+	for (i = 0; i < 8; i++)
+		if (speakup_console[vc_num]->ht.bgcount[cptr[i]] != 0)
+			if (speakup_console[vc_num]->ht.highsize[cptr[i]] > 0)
+				return cptr[i];
+	return -1;
+}
+
+static int
+speak_highlight(struct vc_data *vc)
+{
+	int hc, d;
+	int vc_num = vc->vc_num;
+	if (count_highlight_color(vc) == 1)
+		return 0;
+	hc = get_highlight_color(vc);
+	if (hc != -1) {
+		d = vc->vc_y-speakup_console[vc_num]->ht.cy;
+		if ((d == 1) || (d == -1))
+			if (speakup_console[vc_num]->ht.ry[hc] != vc->vc_y)
+				return 0;
+		spk_parked |= 0x01;
+		do_flush();
+		spkup_write(speakup_console[vc_num]->ht.highbuf[hc],
+				speakup_console[vc_num]->ht.highsize[hc]);
+		spk_pos = spk_cp = speakup_console[vc_num]->ht.rpos[hc];
+		spk_x = spk_cx = speakup_console[vc_num]->ht.rx[hc];
+		spk_y = spk_cy = speakup_console[vc_num]->ht.ry[hc];
+		return 1;
+	}
+	return 0;
+}
+
+static void
+cursor_done(u_long data)
+{
+	struct vc_data *vc = vc_cons[cursor_con].d;
+	unsigned long flags;
+	del_timer(&cursor_timer);
+	spk_lock(flags);
+	if (cursor_con != fg_console) {
+		is_cursor = 0;
+		goto out;
+	}
+	speakup_date(vc);
+	if (win_enabled) {
+		if (vc->vc_x >= win_left && vc->vc_x <= win_right &&
+		vc->vc_y >= win_top && vc->vc_y <= win_bottom) {
+			spk_keydown = is_cursor = 0;
+			goto out;
+		}
+	}
+	if (cursor_track == read_all_mode) {
+		handle_cursor_read_all(vc, read_all_key);
+		goto out;
+	}
+	if (cursor_track == CT_Highlight) {
+		if (speak_highlight(vc)) {
+			spk_keydown = is_cursor = 0;
+			goto out;
+		}
+	}
+	if (cursor_track == CT_Window)
+		speakup_win_say(vc);
+	else if (is_cursor == 1 || is_cursor == 4)
+		say_line_from_to(vc, 0, vc->vc_cols, 0);
+	else
+		say_char(vc);
+	spk_keydown = is_cursor = 0;
+out:
+	spk_unlock(flags);
+}
+
+/* called by: vt_notifier_call() */
+static void speakup_bs(struct vc_data *vc)
+{
+	unsigned long flags;
+	if (!speakup_console[vc->vc_num])
+		return;
+	if (!spk_trylock(flags))
+		/* Speakup output, discard */
+		return;
+	if (!spk_parked)
+		speakup_date(vc);
+	if (spk_shut_up || synth == NULL) {
+		spk_unlock(flags);
+		return;
+	}
+	if (vc->vc_num == fg_console && spk_keydown) {
+		spk_keydown = 0;
+		if (!is_cursor)
+			say_char(vc);
+	}
+	spk_unlock(flags);
+}
+
+/* called by: vt_notifier_call() */
+static void speakup_con_write(struct vc_data *vc, const char *str, int len)
+{
+	unsigned long flags;
+	if ((vc->vc_num != fg_console) || spk_shut_up || synth == NULL)
+		return;
+	if (!spk_trylock(flags))
+		/* Speakup output, discard */
+		return;
+	if (bell_pos && spk_keydown && (vc->vc_x == bell_pos - 1))
+		bleep(3);
+	if ((is_cursor) || (cursor_track == read_all_mode)) {
+		if (cursor_track == CT_Highlight)
+			update_color_buffer(vc, str, len);
+		spk_unlock(flags);
+		return;
+	}
+	if (win_enabled) {
+		if (vc->vc_x >= win_left && vc->vc_x <= win_right &&
+		vc->vc_y >= win_top && vc->vc_y <= win_bottom) {
+			spk_unlock(flags);
+			return;
+		}
+	}
+
+	spkup_write(str, len);
+	spk_unlock(flags);
+}
+
+void
+speakup_con_update(struct vc_data *vc)
+{
+	unsigned long flags;
+	if (speakup_console[vc->vc_num] == NULL || spk_parked)
+		return;
+	if (!spk_trylock(flags))
+		/* Speakup output, discard */
+		return;
+	speakup_date(vc);
+	spk_unlock(flags);
+}
+
+static void do_handle_spec(struct vc_data *vc, u_char value, char up_flag)
+{
+	unsigned long flags;
+	int on_off = 2;
+	char *label;
+	if (synth == NULL || up_flag || spk_killed)
+		return;
+	spk_lock(flags);
+	spk_shut_up &= 0xfe;
+	if (no_intr)
+		do_flush();
+	switch (value) {
+	case KVAL(K_CAPS):
+		label = msg_get(MSG_KEYNAME_CAPSLOCK);
+		on_off = (vc_kbd_led(kbd_table + vc->vc_num, VC_CAPSLOCK));
+		break;
+	case KVAL(K_NUM):
+		label = msg_get(MSG_KEYNAME_NUMLOCK);
+		on_off = (vc_kbd_led(kbd_table + vc->vc_num, VC_NUMLOCK));
+		break;
+	case KVAL(K_HOLD):
+		label = msg_get(MSG_KEYNAME_SCROLLLOCK);
+		on_off = (vc_kbd_led(kbd_table + vc->vc_num, VC_SCROLLOCK));
+		if (speakup_console[vc->vc_num])
+			speakup_console[vc->vc_num]->tty_stopped = on_off;
+		break;
+	default:
+		spk_parked &= 0xfe;
+		spk_unlock(flags);
+		return;
+	}
+	if (on_off < 2)
+		synth_printf("%s %s\n",
+			     label, msg_get(MSG_STATUS_START + on_off));
+	spk_unlock(flags);
+}
+
+static int
+inc_dec_var(u_char value)
+{
+	struct st_var_header *p_header;
+	struct var_t *var_data;
+	char num_buf[32];
+	char *cp = num_buf;
+	char *pn;
+	int var_id = (int)value - VAR_START;
+	int how = (var_id&1) ? E_INC : E_DEC;
+	var_id = var_id/2+FIRST_SET_VAR;
+	p_header = get_var_header(var_id);
+	if (p_header == NULL)
+		return -1;
+	if (p_header->var_type != VAR_NUM)
+		return -1;
+	var_data = p_header->data;
+	if (set_num_var(1, p_header, how) != 0)
+		return -1;
+	if (!spk_close_press) {
+		for (pn = p_header->name; *pn; pn++) {
+			if (*pn == '_')
+				*cp = SPACE;
+			else
+				*cp++ = *pn;
+		}
+	}
+	snprintf(cp, sizeof(num_buf) - (cp - num_buf), " %d ",
+			var_data->u.n.value);
+	synth_printf("%s", num_buf);
+	return 0;
+}
+
+static void
+speakup_win_set(struct vc_data *vc)
+{
+	char info[40];
+	if (win_start > 1) {
+		synth_printf("%s\n", msg_get(MSG_WINDOW_ALREADY_SET));
+		return;
+	}
+	if (spk_x < win_left || spk_y < win_top) {
+		synth_printf("%s\n", msg_get(MSG_END_BEFORE_START));
+		return;
+	}
+	if (win_start && spk_x == win_left && spk_y == win_top) {
+		win_left = 0;
+		win_right = vc->vc_cols-1;
+		win_bottom = spk_y;
+		snprintf(info, sizeof(info), msg_get(MSG_WINDOW_LINE),
+				(int)win_top+1);
+	} else {
+		if (!win_start) {
+			win_top = spk_y;
+			win_left = spk_x;
+		} else {
+			win_bottom = spk_y;
+			win_right = spk_x;
+		}
+		snprintf(info, sizeof(info), msg_get(MSG_WINDOW_BOUNDARY),
+			(win_start) ? msg_get(MSG_END) : msg_get(MSG_START),
+			(int)spk_y+1, (int)spk_x+1);
+	}
+	synth_printf("%s\n", info);
+	win_start++;
+}
+
+static void
+speakup_win_clear(struct vc_data *vc)
+{
+	win_top = win_bottom = 0;
+	win_left = win_right = 0;
+	win_start = 0;
+	synth_printf("%s\n", msg_get(MSG_WINDOW_CLEARED));
+}
+
+static void
+speakup_win_enable(struct vc_data *vc)
+{
+	if (win_start < 2) {
+		synth_printf("%s\n", msg_get(MSG_NO_WINDOW));
+		return;
+	}
+	win_enabled ^= 1;
+	if (win_enabled)
+		synth_printf("%s\n", msg_get(MSG_WINDOW_SILENCED));
+	else
+		synth_printf("%s\n", msg_get(MSG_WINDOW_SILENCE_DISABLED));
+}
+
+static void
+speakup_bits(struct vc_data *vc)
+{
+	int val = this_speakup_key - (FIRST_EDIT_BITS - 1);
+	if (special_handler != NULL || val < 1 || val > 6) {
+		synth_printf("%s\n", msg_get(MSG_ERROR));
+		return;
+	}
+	pb_edit = &punc_info[val];
+	synth_printf(msg_get(MSG_EDIT_PROMPT), pb_edit->name);
+	special_handler = edit_bits;
+}
+
+static int handle_goto(struct vc_data *vc, u_char type, u_char ch, u_short key)
+{
+	static u_char *goto_buf = "\0\0\0\0\0\0";
+	static int num = 0;
+	int maxlen, go_pos;
+	char *cp;
+	if (type == KT_SPKUP && ch == SPEAKUP_GOTO)
+		goto do_goto;
+	if (type == KT_LATIN && ch == '\n')
+		goto do_goto;
+	if (type != 0)
+		goto oops;
+	if (ch == 8) {
+		if (num == 0)
+			return -1;
+		ch = goto_buf[--num];
+		goto_buf[num] = '\0';
+		spkup_write(&ch, 1);
+		return 1;
+	}
+	if (ch < '+' || ch > 'y')
+		goto oops;
+	goto_buf[num++] = ch;
+	goto_buf[num] = '\0';
+	spkup_write(&ch, 1);
+	maxlen = (*goto_buf >= '0') ? 3 : 4;
+	if ((ch == '+' || ch == '-') && num == 1)
+		return 1;
+	if (ch >= '0' && ch <= '9' && num < maxlen)
+		return 1;
+	if (num < maxlen-1 || num > maxlen)
+		goto oops;
+	if (ch < 'x' || ch > 'y') {
+oops:
+		if (!spk_killed)
+			synth_printf(" %s\n", msg_get(MSG_GOTO_CANCELED));
+		goto_buf[num = 0] = '\0';
+		special_handler = NULL;
+		return 1;
+	}
+	cp = speakup_s2i(goto_buf, &go_pos);
+	goto_pos = (u_long)go_pos;
+	if (*cp == 'x') {
+		if (*goto_buf < '0')
+			goto_pos += spk_x;
+		else
+			goto_pos--;
+		if (goto_pos < 0)
+			goto_pos = 0;
+		if (goto_pos >= vc->vc_cols)
+			goto_pos = vc->vc_cols-1;
+		goto_x = 1;
+	} else {
+		if (*goto_buf < '0')
+			goto_pos += spk_y;
+		else
+			goto_pos--;
+		if (goto_pos < 0)
+			goto_pos = 0;
+		if (goto_pos >= vc->vc_rows)
+			goto_pos = vc->vc_rows-1;
+		goto_x = 0;
+	}
+		goto_buf[num = 0] = '\0';
+do_goto:
+	special_handler = NULL;
+	spk_parked |= 0x01;
+	if (goto_x) {
+		spk_pos -= spk_x * 2;
+		spk_x = goto_pos;
+		spk_pos += goto_pos * 2;
+		say_word(vc);
+	} else {
+		spk_y = goto_pos;
+		spk_pos = vc->vc_origin + (goto_pos * vc->vc_size_row);
+		say_line(vc);
+	}
+	return 1;
+}
+
+static void
+speakup_goto(struct vc_data *vc)
+{
+	if (special_handler != NULL) {
+		synth_printf("%s\n", msg_get(MSG_ERROR));
+		return;
+	}
+	synth_printf("%s\n", msg_get(MSG_GOTO));
+	special_handler = handle_goto;
+	return;
+}
+
+static void speakup_help(struct vc_data *vc)
+{
+	handle_help(vc, KT_SPKUP, SPEAKUP_HELP, 0);
+}
+
+static void
+do_nothing(struct vc_data *vc)
+{
+	return; /* flush done in do_spkup */
+}
+static u_char key_speakup, spk_key_locked;
+
+static void
+speakup_lock(struct vc_data *vc)
+{
+	if (!spk_key_locked)
+		spk_key_locked = key_speakup = 16;
+	else
+		spk_key_locked = key_speakup = 0;
+}
+
+typedef void(*spkup_hand)(struct vc_data *);
+spkup_hand spkup_handler[] = {
+	/* must be ordered same as defines in speakup.h */
+	do_nothing, speakup_goto, speech_kill, speakup_shut_up,
+	speakup_cut, speakup_paste, say_first_char, say_last_char,
+	say_char, say_prev_char, say_next_char,
+	say_word, say_prev_word, say_next_word,
+	say_line, say_prev_line, say_next_line,
+	top_edge, bottom_edge, left_edge, right_edge,
+	spell_word, spell_word, say_screen,
+	say_position, say_attributes,
+	speakup_off, speakup_parked, say_line, /* this is for indent */
+	say_from_top, say_to_bottom,
+	say_from_left, say_to_right,
+	say_char_num, speakup_bits, speakup_bits, say_phonetic_char,
+	speakup_bits, speakup_bits, speakup_bits,
+	speakup_win_set, speakup_win_clear, speakup_win_enable, speakup_win_say,
+	speakup_lock, speakup_help, toggle_cursoring, read_all_doc, NULL
+};
+
+static void do_spkup(struct vc_data *vc, u_char value)
+{
+	if (spk_killed && value != SPEECH_KILL)
+		return;
+	spk_keydown = 0;
+	spk_lastkey = 0;
+	spk_shut_up &= 0xfe;
+	this_speakup_key = value;
+	if (value < SPKUP_MAX_FUNC && spkup_handler[value]) {
+		do_flush();
+		(*spkup_handler[value])(vc);
+	} else {
+		if (inc_dec_var(value) < 0)
+			bleep(9);
+	}
+}
+
+static const char *pad_chars = "0123456789+-*/\015,.?()";
+
+int
+speakup_key(struct vc_data *vc, int shift_state, int keycode, u_short keysym,
+		int up_flag)
+{
+	unsigned long flags;
+	int kh;
+	u_char *key_info;
+	u_char type = KTYP(keysym), value = KVAL(keysym), new_key = 0;
+	u_char shift_info, offset;
+	int ret = 0;
+	if (synth == NULL)
+		return 0;
+
+	spk_lock(flags);
+	tty = vc->vc_tty;
+	if (type >= 0xf0)
+		type -= 0xf0;
+	if (type == KT_PAD &&
+			(vc_kbd_led(kbd_table + fg_console, VC_NUMLOCK))) {
+		if (up_flag) {
+			spk_keydown = 0;
+			goto out;
+		}
+		value = spk_lastkey = pad_chars[value];
+		spk_keydown++;
+		spk_parked &= 0xfe;
+		goto no_map;
+	}
+	if (keycode >= MAX_KEY)
+		goto no_map;
+	key_info = our_keys[keycode];
+	if (key_info == 0)
+		goto no_map;
+	/* Check valid read all mode keys */
+	if ((cursor_track == read_all_mode) && (!up_flag)) {
+		switch (value) {
+		case KVAL(K_DOWN):
+		case KVAL(K_UP):
+		case KVAL(K_LEFT):
+		case KVAL(K_RIGHT):
+		case KVAL(K_PGUP):
+		case KVAL(K_PGDN):
+			break;
+		default:
+			stop_read_all(vc);
+			break;
+		}
+	}
+	shift_info = (shift_state&0x0f) + key_speakup;
+	offset = shift_table[shift_info];
+	if (offset) {
+		new_key = key_info[offset];
+		if (new_key) {
+			ret = 1;
+			if (new_key == SPK_KEY) {
+				if (!spk_key_locked)
+					key_speakup = (up_flag) ? 0 : 16;
+				if (up_flag || spk_killed)
+					goto out;
+				spk_shut_up &= 0xfe;
+				do_flush();
+				goto out;
+			}
+			if (up_flag)
+				goto out;
+			if (last_keycode == keycode &&
+					last_spk_jiffy+MAX_DELAY > jiffies) {
+				spk_close_press = 1;
+				offset = shift_table[shift_info+32];
+	/* double press? */
+				if (offset && key_info[offset])
+					new_key = key_info[offset];
+			}
+			last_keycode = keycode;
+			last_spk_jiffy = jiffies;
+			type = KT_SPKUP;
+			value = new_key;
+		}
+	}
+no_map:
+	if (type == KT_SPKUP && special_handler == NULL) {
+		do_spkup(vc, new_key);
+		spk_close_press = 0;
+		ret = 1;
+		goto out;
+	}
+	if (up_flag || spk_killed || type == KT_SHIFT)
+		goto out;
+	spk_shut_up &= 0xfe;
+	kh = (value == KVAL(K_DOWN))
+		|| (value == KVAL(K_UP))
+		|| (value == KVAL(K_LEFT))
+		|| (value == KVAL(K_RIGHT));
+	if ((cursor_track != read_all_mode) || !kh)
+		if (!no_intr)
+			do_flush();
+	if (special_handler) {
+		if (type == KT_SPEC && value == 1) {
+			value = '\n';
+			type = KT_LATIN;
+		} else if (type == KT_LETTER)
+			type = KT_LATIN;
+		else if (value == 0x7f)
+			value = 8; /* make del = backspace */
+		ret = (*special_handler)(vc, type, value, keycode);
+		spk_close_press = 0;
+		if (ret < 0)
+			bleep(9);
+		goto out;
+	}
+	last_keycode = 0;
+out:
+	spk_unlock(flags);
+	return ret;
+}
+
+static int keyboard_notifier_call(struct notifier_block *nb,
+		unsigned long code, void *_param)
+{
+	struct keyboard_notifier_param *param = _param;
+	struct vc_data *vc = param->vc;
+	int up = !param->down;
+	int ret = NOTIFY_OK;
+	static int keycode; /* to hold the current keycode */
+
+	if (vc->vc_mode == KD_GRAPHICS)
+		return ret;
+
+	/*
+	 * First, determine whether we are handling a fake keypress on
+	 * the current processor.  If we are, then return NOTIFY_OK,
+	 * to pass the keystroke up the chain.  This prevents us from
+	 * trying to take the Speakup lock while it is held by the
+	 * processor on which the simulated keystroke was generated.
+	 * Also, the simulated keystrokes should be ignored by Speakup.
+	 */
+
+	if (speakup_fake_key_pressed())
+		return ret;
+
+	switch (code) {
+	case KBD_KEYCODE:
+		/* speakup requires keycode and keysym currently */
+		keycode = param->value;
+		break;
+	case KBD_UNBOUND_KEYCODE:
+		/* not used yet */
+		break;
+	case KBD_UNICODE:
+		/* not used yet */
+		break;
+	case KBD_KEYSYM:
+		if (speakup_key(vc, param->shift, keycode, param->value, up))
+			ret = NOTIFY_STOP;
+		else
+			if (KTYP(param->value) == KT_CUR)
+				ret = pre_handle_cursor(vc,
+						KVAL(param->value), up);
+		break;
+	case KBD_POST_KEYSYM: {
+		unsigned char type = KTYP(param->value) - 0xf0;
+		unsigned char val = KVAL(param->value);
+		switch (type) {
+		case KT_SHIFT:
+			do_handle_shift(vc, val, up);
+			break;
+		case KT_LATIN:
+		case KT_LETTER:
+			do_handle_latin(vc, val, up);
+			break;
+		case KT_CUR:
+			do_handle_cursor(vc, val, up);
+			break;
+		case KT_SPEC:
+			do_handle_spec(vc, val, up);
+			break;
+		}
+		break;
+		}
+	}
+	return ret;
+}
+
+static int vt_notifier_call(struct notifier_block *nb,
+		unsigned long code, void *_param)
+{
+	struct vt_notifier_param *param = _param;
+	struct vc_data *vc = param->vc;
+	switch (code) {
+	case VT_ALLOCATE:
+		if (vc->vc_mode == KD_TEXT)
+			speakup_allocate(vc);
+		break;
+	case VT_DEALLOCATE:
+		speakup_deallocate(vc);
+		break;
+	case VT_WRITE:
+		if (param->c == '\b')
+			speakup_bs(vc);
+		else
+			if (param->c < 0x100) {
+				char d = param->c;
+				speakup_con_write(vc, &d, 1);
+			}
+		break;
+	case VT_UPDATE:
+		speakup_con_update(vc);
+		break;
+	}
+	return NOTIFY_OK;
+}
+
+/* called by: module_exit() */
+static void __exit speakup_exit(void)
+{
+	int i;
+
+	free_user_msgs();
+	unregister_keyboard_notifier(&keyboard_notifier_block);
+	unregister_vt_notifier(&vt_notifier_block);
+	speakup_unregister_devsynth();
+	del_timer(&cursor_timer);
+
+	kthread_stop(speakup_task);
+	speakup_task = NULL;
+	mutex_lock(&spk_mutex);
+	synth_release();
+	mutex_unlock(&spk_mutex);
+
+	for (i = 0; i < MAXVARS; i++)
+		speakup_unregister_var(i);
+
+	for (i = 0; i < 256; i++) {
+		if (characters[i] != default_chars[i])
+			kfree(characters[i]);
+	}
+	for (i = 0; speakup_console[i]; i++)
+		kfree(speakup_console[i]);
+	speakup_kobj_exit();
+	speakup_remove_virtual_keyboard();
+}
+
+/* call by: module_init() */
+static int __init speakup_init(void)
+{
+	int i;
+	int err;
+	struct st_spk_t *first_console;
+	struct vc_data *vc = vc_cons[fg_console].d;
+	struct var_t *var;
+
+	err = speakup_add_virtual_keyboard();
+	if (err)
+		return err;
+
+	initialize_msgs(); /* Initialize arrays for i18n. */
+	first_console = kzalloc(sizeof(*first_console), GFP_KERNEL);
+	if (!first_console)
+		return -ENOMEM;
+	if (speakup_kobj_init() < 0) 
+		return -ENOMEM;
+
+	reset_default_chars();
+	reset_default_chartab();
+
+	speakup_console[vc->vc_num] = first_console;
+	speakup_date(vc);
+	pr_info("speakup %s: initialized\n", SPEAKUP_VERSION);
+
+	strlwr(synth_name);
+	spk_vars[0].u.n.high = vc->vc_cols;
+	for (var = spk_vars; var->var_id !=MAXVARS; var++) 
+		speakup_register_var(var);
+	for (var = synth_time_vars; (var->var_id >= 0) && (var->var_id < MAXVARS); var++)
+		speakup_register_var(var);
+	for (i = 1; punc_info[i].mask != 0; i++)
+		set_mask_bits(0, i, 2);
+
+	set_key_info(key_defaults, key_buf);
+	if (quiet_boot)
+		spk_shut_up |= 0x01;
+
+	for (i = 0; i < MAX_NR_CONSOLES; i++)
+		if (vc_cons[i].d)
+			speakup_allocate(vc_cons[i].d);
+
+	pr_warn("synth name on entry is: %s\n", synth_name);
+	synth_init(synth_name);
+	speakup_register_devsynth();
+
+	register_keyboard_notifier(&keyboard_notifier_block);
+	register_vt_notifier(&vt_notifier_block);
+
+	speakup_task = kthread_create(speakup_thread, NULL, "speakup");
+	set_user_nice(speakup_task, 10);
+	if ( ! IS_ERR(speakup_task))
+		wake_up_process(speakup_task);
+	else
+		return -ENOMEM;
+	return 0;
+}
+
+
+module_init(speakup_init);
+module_exit(speakup_exit);
+
