commit 7cf9a79dbae127776a6ddd455494faec9f3af9fb
Author: Sam Muhammed <jane.pnx9@gmail.com>
Date:   Tue Mar 24 06:45:48 2020 -0400

    Staging: speakup: Use sizeof(*var) in kmalloc().
    
    Modifying struct allocation in kmalloc() to match the
    coding standards.
    
    Checkpatch.pl CHECK: Prefer kmalloc(sizeof(*ldisc_data)...)
    over kmalloc(sizeof(struct spk_ldisc_data)...)
    
    Signed-off-by: Sam Muhammed <jane.pnx9@gmail.com>
    Reviewed-by: Samuel Thibault <samuel.thibault@ens-lyon.org>
    Link: https://lore.kernel.org/r/19494bdab5709693126e0c0ee14b179a3b601207.1585046066.git.jane.pnx9@gmail.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/speakup/spk_ttyio.c b/drivers/staging/speakup/spk_ttyio.c
index 5a9eff08cb96..9b95f77f9265 100644
--- a/drivers/staging/speakup/spk_ttyio.c
+++ b/drivers/staging/speakup/spk_ttyio.c
@@ -51,7 +51,7 @@ static int spk_ttyio_ldisc_open(struct tty_struct *tty)
 		return -EOPNOTSUPP;
 	speakup_tty = tty;
 
-	ldisc_data = kmalloc(sizeof(struct spk_ldisc_data), GFP_KERNEL);
+	ldisc_data = kmalloc(sizeof(*ldisc_data), GFP_KERNEL);
 	if (!ldisc_data)
 		return -ENOMEM;
 

commit 2b90bf28ac38b697a3f48a6664a02b374aa18f99
Author: Bhagyashri Dighole <digholebhagyashri@gmail.com>
Date:   Wed Mar 6 14:25:41 2019 +0530

    staging: speakup: Comparison to NULL.
    
    Fix coding style issues, detected by checkpatch.pl "CHECK: Comparison to
    NULL could be written !tty->ops->write"
    
    Signed-off-by: Bhagyashri Dighole <digholebhagyashri@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/speakup/spk_ttyio.c b/drivers/staging/speakup/spk_ttyio.c
index 0057eb980bec..5a9eff08cb96 100644
--- a/drivers/staging/speakup/spk_ttyio.c
+++ b/drivers/staging/speakup/spk_ttyio.c
@@ -47,7 +47,7 @@ static int spk_ttyio_ldisc_open(struct tty_struct *tty)
 {
 	struct spk_ldisc_data *ldisc_data;
 
-	if (tty->ops->write == NULL)
+	if (!tty->ops->write)
 		return -EOPNOTSUPP;
 	speakup_tty = tty;
 

commit e2d55017ae1ce44247d03c1612e9b724ceff1388
Author: Bhagyashri Dighole <digholebhagyashri@gmail.com>
Date:   Thu Feb 28 17:59:04 2019 +0530

    staging: speakup: fix line over 80 characters.
    
    Fix coding style issues, which solves checkpatch.pl warning:
    "WARNING: line over 80 characters".
    
    Signed-off-by: Bhagyashri Dighole <digholebhagyashri@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/speakup/spk_ttyio.c b/drivers/staging/speakup/spk_ttyio.c
index 005de0024dd4..0057eb980bec 100644
--- a/drivers/staging/speakup/spk_ttyio.c
+++ b/drivers/staging/speakup/spk_ttyio.c
@@ -128,7 +128,8 @@ struct spk_io_ops spk_ttyio_ops = {
 };
 EXPORT_SYMBOL_GPL(spk_ttyio_ops);
 
-static inline void get_termios(struct tty_struct *tty, struct ktermios *out_termios)
+static inline void get_termios(struct tty_struct *tty,
+			       struct ktermios *out_termios)
 {
 	down_read(&tty->termios_rwsem);
 	*out_termios = tty->termios;
@@ -167,8 +168,9 @@ static int spk_ttyio_initialise_ldisc(struct spk_synth *synth)
 		tmp_termios.c_cflag |= CRTSCTS;
 		tty_set_termios(tty, &tmp_termios);
 		/*
-		 * check c_cflag to see if it's updated as tty_set_termios may not return
-		 * error even when no tty bits are changed by the request.
+		 * check c_cflag to see if it's updated as tty_set_termios
+		 * may not return error even when no tty bits are
+		 * changed by the request.
 		 */
 		get_termios(tty, &tmp_termios);
 		if (!(tmp_termios.c_cflag & CRTSCTS))
@@ -207,10 +209,11 @@ static int spk_ttyio_out(struct spk_synth *in_synth, const char ch)
 			/* No room */
 			return 0;
 		if (ret < 0) {
-			pr_warn("%s: I/O error, deactivating speakup\n", in_synth->long_name);
-			/* No synth any more, so nobody will restart TTYs, and we thus
-			 * need to do it ourselves.  Now that there is no synth we can
-			 * let application flood anyway
+			pr_warn("%s: I/O error, deactivating speakup\n",
+				in_synth->long_name);
+			/* No synth any more, so nobody will restart TTYs,
+			 * and we thus need to do it ourselves.  Now that there
+			 * is no synth we can let application flood anyway
 			 */
 			in_synth->alive = 0;
 			speakup_start_ttys();
@@ -371,7 +374,8 @@ const char *spk_ttyio_synth_immediate(struct spk_synth *synth, const char *buff)
 	while ((ch = *buff)) {
 		if (ch == '\n')
 			ch = synth->procspeech;
-		if (tty_write_room(speakup_tty) < 1 || !synth->io_ops->synth_out(synth, ch))
+		if (tty_write_room(speakup_tty) < 1 ||
+		    !synth->io_ops->synth_out(synth, ch))
 			return buff;
 		buff++;
 	}

commit a1960e0f1639cb1f7a3d94521760fc73091f6640
Author: Johan Hovold <johan@kernel.org>
Date:   Wed Jan 30 10:49:34 2019 +0100

    staging: speakup: fix tty-operation NULL derefs
    
    The send_xchar() and tiocmset() tty operations are optional. Add the
    missing sanity checks to prevent user-space triggerable NULL-pointer
    dereferences.
    
    Fixes: 6b9ad1c742bf ("staging: speakup: add send_xchar, tiocmset and input functionality for tty")
    Cc: stable <stable@vger.kernel.org>     # 4.13
    Cc: Okash Khawaja <okash.khawaja@gmail.com>
    Cc: Samuel Thibault <samuel.thibault@ens-lyon.org>
    Signed-off-by: Johan Hovold <johan@kernel.org>
    Reviewed-by: Samuel Thibault <samuel.thibault@ens-lyon.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/speakup/spk_ttyio.c b/drivers/staging/speakup/spk_ttyio.c
index c92bbd05516e..005de0024dd4 100644
--- a/drivers/staging/speakup/spk_ttyio.c
+++ b/drivers/staging/speakup/spk_ttyio.c
@@ -265,7 +265,8 @@ static void spk_ttyio_send_xchar(char ch)
 		return;
 	}
 
-	speakup_tty->ops->send_xchar(speakup_tty, ch);
+	if (speakup_tty->ops->send_xchar)
+		speakup_tty->ops->send_xchar(speakup_tty, ch);
 	mutex_unlock(&speakup_tty_mutex);
 }
 
@@ -277,7 +278,8 @@ static void spk_ttyio_tiocmset(unsigned int set, unsigned int clear)
 		return;
 	}
 
-	speakup_tty->ops->tiocmset(speakup_tty, set, clear);
+	if (speakup_tty->ops->tiocmset)
+		speakup_tty->ops->tiocmset(speakup_tty, set, clear);
 	mutex_unlock(&speakup_tty_mutex);
 }
 

commit d6a0de493374642ee8bb2f473d7b6e10cad82e85
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Mon Dec 10 22:41:50 2018 +0100

    staging: speakup: change semaphore to completion
    
    In this driver, both function the same way, but we want to eventually
    kill off semaphores, so a completion is the better choice here.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Reviewed-by: Samuel Thibault <samuel.thibault@ens-lyon.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/speakup/spk_ttyio.c b/drivers/staging/speakup/spk_ttyio.c
index 979e3ae249c1..c92bbd05516e 100644
--- a/drivers/staging/speakup/spk_ttyio.c
+++ b/drivers/staging/speakup/spk_ttyio.c
@@ -10,7 +10,7 @@
 
 struct spk_ldisc_data {
 	char buf;
-	struct semaphore sem;
+	struct completion completion;
 	bool buf_free;
 };
 
@@ -55,7 +55,7 @@ static int spk_ttyio_ldisc_open(struct tty_struct *tty)
 	if (!ldisc_data)
 		return -ENOMEM;
 
-	sema_init(&ldisc_data->sem, 0);
+	init_completion(&ldisc_data->completion);
 	ldisc_data->buf_free = true;
 	speakup_tty->disc_data = ldisc_data;
 
@@ -95,7 +95,7 @@ static int spk_ttyio_receive_buf2(struct tty_struct *tty,
 
 	ldisc_data->buf = cp[0];
 	ldisc_data->buf_free = false;
-	up(&ldisc_data->sem);
+	complete(&ldisc_data->completion);
 
 	return 1;
 }
@@ -286,7 +286,8 @@ static unsigned char ttyio_in(int timeout)
 	struct spk_ldisc_data *ldisc_data = speakup_tty->disc_data;
 	char rv;
 
-	if (down_timeout(&ldisc_data->sem, usecs_to_jiffies(timeout)) == -ETIME) {
+	if (wait_for_completion_timeout(&ldisc_data->completion,
+					usecs_to_jiffies(timeout)) == 0) {
 		if (timeout)
 			pr_warn("spk_ttyio: timeout (%d)  while waiting for input\n",
 				timeout);

commit 02e6b5ebeda1136f82ad685124918bab70e5107b
Author: Maya Nakamura <m.maya.nakamura@gmail.com>
Date:   Wed Oct 17 18:16:00 2018 -0700

    staging: speakup: Add a pair of braces
    
    Add a pair of braces to make all arms of the if statement consistent.
    Issue found by checkpatch.pl.
    
    Signed-off-by: Maya Nakamura <m.maya.nakamura@gmail.com>
    Acked-by: Samuel Thibault <samuel.thibault@ens-lyon.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/speakup/spk_ttyio.c b/drivers/staging/speakup/spk_ttyio.c
index eac63aab8162..979e3ae249c1 100644
--- a/drivers/staging/speakup/spk_ttyio.c
+++ b/drivers/staging/speakup/spk_ttyio.c
@@ -227,9 +227,9 @@ static int spk_ttyio_out_unicode(struct spk_synth *in_synth, u16 ch)
 {
 	int ret;
 
-	if (ch < 0x80)
+	if (ch < 0x80) {
 		ret = spk_ttyio_out(in_synth, ch);
-	else if (ch < 0x800) {
+	} else if (ch < 0x800) {
 		ret  = spk_ttyio_out(in_synth, 0xc0 | (ch >> 6));
 		ret &= spk_ttyio_out(in_synth, 0x80 | (ch & 0x3f));
 	} else {

commit 1d49c89dc80e16b3313e60e3fadc3ebc3cde7cba
Author: Nishka Dasgupta <nishka.dasgupta_ug18@ashoka.edu.in>
Date:   Wed Mar 14 18:22:10 2018 +0000

    staging: speakup: Add blank line after declaration
    
    Add blank line after declaration. Issue found with checkpatch.
    
    Signed-off-by: Nishka Dasgupta <nishka.dasgupta_ug18@ashoka.edu.in>
    Reviewed-by: Samuel Thibault <samuel.thibault@ens-lyon.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/speakup/spk_ttyio.c b/drivers/staging/speakup/spk_ttyio.c
index ade03b03bcd3..eac63aab8162 100644
--- a/drivers/staging/speakup/spk_ttyio.c
+++ b/drivers/staging/speakup/spk_ttyio.c
@@ -226,6 +226,7 @@ static int spk_ttyio_out(struct spk_synth *in_synth, const char ch)
 static int spk_ttyio_out_unicode(struct spk_synth *in_synth, u16 ch)
 {
 	int ret;
+
 	if (ch < 0x80)
 		ret = spk_ttyio_out(in_synth, ch);
 	else if (ch < 0x800) {

commit 65fa72d34360c571b058afeb0e64367d3eaf064b
Author: Samuel Thibault <samuel.thibault@ens-lyon.org>
Date:   Sat Mar 10 11:56:27 2018 +0100

    staging: speakup: Add unicode support to the speakup_dummy driver
    
    This extends spk_io_ops with a synth_out_unicode which takes a u16 character
    instead of just a byte, and extends spk_ttyio to implement it to emit
    utf-8. spk_do_catch_up_unicode can then be introduced to benefit from
    synth_out_unicode, and speakup_dummy made to use spk_do_catch_up_unicode instead
    of spk_do_catch_up.
    
    Signed-off-by: Samuel Thibault <samuel.thibault@ens-lyon.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/speakup/spk_ttyio.c b/drivers/staging/speakup/spk_ttyio.c
index 311940205bee..ade03b03bcd3 100644
--- a/drivers/staging/speakup/spk_ttyio.c
+++ b/drivers/staging/speakup/spk_ttyio.c
@@ -110,6 +110,7 @@ static struct tty_ldisc_ops spk_ttyio_ldisc_ops = {
 };
 
 static int spk_ttyio_out(struct spk_synth *in_synth, const char ch);
+static int spk_ttyio_out_unicode(struct spk_synth *in_synth, u16 ch);
 static void spk_ttyio_send_xchar(char ch);
 static void spk_ttyio_tiocmset(unsigned int set, unsigned int clear);
 static unsigned char spk_ttyio_in(void);
@@ -118,6 +119,7 @@ static void spk_ttyio_flush_buffer(void);
 
 struct spk_io_ops spk_ttyio_ops = {
 	.synth_out = spk_ttyio_out,
+	.synth_out_unicode = spk_ttyio_out_unicode,
 	.send_xchar = spk_ttyio_send_xchar,
 	.tiocmset = spk_ttyio_tiocmset,
 	.synth_in = spk_ttyio_in,
@@ -221,6 +223,22 @@ static int spk_ttyio_out(struct spk_synth *in_synth, const char ch)
 	return 0;
 }
 
+static int spk_ttyio_out_unicode(struct spk_synth *in_synth, u16 ch)
+{
+	int ret;
+	if (ch < 0x80)
+		ret = spk_ttyio_out(in_synth, ch);
+	else if (ch < 0x800) {
+		ret  = spk_ttyio_out(in_synth, 0xc0 | (ch >> 6));
+		ret &= spk_ttyio_out(in_synth, 0x80 | (ch & 0x3f));
+	} else {
+		ret  = spk_ttyio_out(in_synth, 0xe0 | (ch >> 12));
+		ret &= spk_ttyio_out(in_synth, 0x80 | ((ch >> 6) & 0x3f));
+		ret &= spk_ttyio_out(in_synth, 0x80 | (ch & 0x3f));
+	}
+	return ret;
+}
+
 static int check_tty(struct tty_struct *tty)
 {
 	if (!tty) {

commit accb9343f58c6750c328645ca4b87fdf0fef3623
Author: Santha Meena Ramamoorthy <santhameena13@gmail.com>
Date:   Mon Mar 5 09:34:13 2018 -0800

    staging: speakup: match alignment with open parenthesis
    
    Match alignment with the open parenthesis to conform to the Linux kernel
    coding style. Issue found using checkpatch.
    
    Signed-off-by: Santha Meena Ramamoorthy <santhameena13@gmail.com>
    Acked-by: Samuel Thibault <samuel.thibault@ens-lyon.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/speakup/spk_ttyio.c b/drivers/staging/speakup/spk_ttyio.c
index 5aa3ffa3772d..311940205bee 100644
--- a/drivers/staging/speakup/spk_ttyio.c
+++ b/drivers/staging/speakup/spk_ttyio.c
@@ -71,7 +71,7 @@ static void spk_ttyio_ldisc_close(struct tty_struct *tty)
 }
 
 static int spk_ttyio_receive_buf2(struct tty_struct *tty,
-		const unsigned char *cp, char *fp, int count)
+				  const unsigned char *cp, char *fp, int count)
 {
 	struct spk_ldisc_data *ldisc_data = tty->disc_data;
 

commit 6496922817e1a1cba8a2d9939ca5de53c5d55239
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Thu Jan 11 11:08:40 2018 +0100

    staging: speakup: add SPDX identifier.
    
    It's good to have SPDX identifiers in all files to make it easier to
    audit the kernel tree for correct licenses.
    
    Fix up the remaining staging speakup files to have a proper SPDX
    identifier, based on the license text in the file itself.  The SPDX
    identifier is a legally binding shorthand, which can be used instead of
    the full boiler plate text.
    
    This work is based on a script and data from Thomas Gleixner, Philippe
    Ombredanne, and Kate Stewart.
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: Philippe Ombredanne <pombredanne@nexb.com>
    Cc: William Hubbs <w.d.hubbs@gmail.com>
    Cc: Chris Brannon <chris@the-brannons.com>
    Cc: Kirk Reiser <kirk@reisers.ca>
    Cc: Samuel Thibault <samuel.thibault@ens-lyon.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/speakup/spk_ttyio.c b/drivers/staging/speakup/spk_ttyio.c
index 513cebbd161c..5aa3ffa3772d 100644
--- a/drivers/staging/speakup/spk_ttyio.c
+++ b/drivers/staging/speakup/spk_ttyio.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 #include <linux/types.h>
 #include <linux/tty.h>
 #include <linux/tty_flip.h>

commit b6e2b3e1c53c43ada97223ecb7678a8b7a33172e
Author: Mihaela Muraru <mihaela.muraru21@gmail.com>
Date:   Wed Sep 27 00:43:45 2017 -0700

    staging: speakup: Fix comment block coding style
    
    This is a patch to the spk_ttyio.c file that fix up a comment block
    warninig, found by checkpatch.pl tool, by adding */ on a separte line.
    
    WARNING: Block comments use a trailing */ on a separate line
    
    Signed-off-by: Mihaela Muraru <mihaela.muraru21@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/speakup/spk_ttyio.c b/drivers/staging/speakup/spk_ttyio.c
index a6330e2cb162..513cebbd161c 100644
--- a/drivers/staging/speakup/spk_ttyio.c
+++ b/drivers/staging/speakup/spk_ttyio.c
@@ -88,7 +88,8 @@ static int spk_ttyio_receive_buf2(struct tty_struct *tty,
 		return 0;
 
 	/* Make sure the consumer has read buf before we have seen
-	 * buf_free == true and overwrite buf */
+	 * buf_free == true and overwrite buf
+	 */
 	mb();
 
 	ldisc_data->buf = cp[0];
@@ -274,7 +275,8 @@ static unsigned char ttyio_in(int timeout)
 
 	rv = ldisc_data->buf;
 	/* Make sure we have read buf before we set buf_free to let
-	 * the producer overwrite it */
+	 * the producer overwrite it
+	 */
 	mb();
 	ldisc_data->buf_free = true;
 	/* Let TTY push more characters */

commit 08710da3cf932149de3440bbaec4dfdfba5a33df
Author: Meghana Madhyastha <meghana.madhyastha@gmail.com>
Date:   Sat Sep 16 10:34:05 2017 +0530

    Staging: speakup: Remove print following unsuccessful kmalloc
    
    Remove print statement following unsuccessful kmalloc when there
    is not enough memory. Kmalloc and variants normally produce a
    backtrace in such a case. Hence, a print statement is not necessary.
    
    Found using the following Coccinelle semantic patch:
    
    @@
    identifier i;
    @@
    
    i = (\(kmalloc\|devm_kzalloc\|kmalloc_array\|
    devm_ioremap\|usb_alloc_urb\|alloc_netdev\|dev_alloc_skb\|
    kzalloc\|kcalloc\|kmem_cache_alloc\|kmem_cache_zalloc\|
       kmem_cache_alloc_node\|kmalloc_node\|kzalloc_node\)(...));
    (
    if (i == NULL)
    {
    -\(DBG_8723A\|printk\|pr_err\|CERROR\|DBG_88E\)(...);
    ...when any
    }
    |
    if (!i)
    {
    -\(DBG_8723A\|printk\|pr_err\|CERROR\|DBG_88E\)(...);
    ...when any
    }
    )
    
    @@
    identifier i;
    @@
    (
    - if (i == NULL) {
    + if (i == NULL)
           return ...;
    - }
    |
    - if (!i) {
    + if (!i)
           return ...;
    - }
    )
    
    Signed-off-by: Meghana Madhyastha <meghana.madhyastha@gmail.com>
    Acked-by: Julia Lawall <julia.lawall@lip6.fr>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/speakup/spk_ttyio.c b/drivers/staging/speakup/spk_ttyio.c
index 4d7d8f2f66ea..a6330e2cb162 100644
--- a/drivers/staging/speakup/spk_ttyio.c
+++ b/drivers/staging/speakup/spk_ttyio.c
@@ -51,10 +51,8 @@ static int spk_ttyio_ldisc_open(struct tty_struct *tty)
 	speakup_tty = tty;
 
 	ldisc_data = kmalloc(sizeof(struct spk_ldisc_data), GFP_KERNEL);
-	if (!ldisc_data) {
-		pr_err("speakup: Failed to allocate ldisc_data.\n");
+	if (!ldisc_data)
 		return -ENOMEM;
-	}
 
 	sema_init(&ldisc_data->sem, 0);
 	ldisc_data->buf_free = true;

commit 084a473532a499eff5a14cbba82f43600df8f992
Author: Okash Khawaja <okash.khawaja@gmail.com>
Date:   Thu Jul 20 08:22:37 2017 +0100

    staging: speakup: use tty_kopen and tty_kclose
    
    This patch replaces call to tty_open_by_driver with a tty_kopen and
    uses tty_kclose instead of tty_release_struct to close it.
    
    Signed-off-by: Okash Khawaja <okash.khawaja@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/speakup/spk_ttyio.c b/drivers/staging/speakup/spk_ttyio.c
index f643167921c3..4d7d8f2f66ea 100644
--- a/drivers/staging/speakup/spk_ttyio.c
+++ b/drivers/staging/speakup/spk_ttyio.c
@@ -144,7 +144,7 @@ static int spk_ttyio_initialise_ldisc(struct spk_synth *synth)
 	if (ret)
 		return ret;
 
-	tty = tty_open_by_driver(dev, NULL, NULL);
+	tty = tty_kopen(dev);
 	if (IS_ERR(tty))
 		return PTR_ERR(tty);
 
@@ -337,7 +337,7 @@ void spk_ttyio_release(void)
 
 	tty_ldisc_flush(speakup_tty);
 	tty_unlock(speakup_tty);
-	tty_release_struct(speakup_tty, speakup_tty->index);
+	tty_kclose(speakup_tty);
 }
 EXPORT_SYMBOL_GPL(spk_ttyio_release);
 

commit f5bee24d866efd73413d7b88c734a194fa46fdc5
Author: Okash Khawaja <okash.khawaja@gmail.com>
Date:   Sat Aug 12 09:05:47 2017 +0100

    staging: speakup: fix async usb removal
    
    When an external USB synth is unplugged while the module is loaded, we
    get a null pointer deref. This is because the tty disappears while
    speakup tries to use to to communicate with the synth. This patch fixes
    it by checking tty for null before using it. Since tty can become null
    between the check and its usage, a mutex is introduced. tty usage is
    now surrounded by the mutex, as is the code in speakup_ldisc_close which
    sets the tty to null. The mutex also serialises calls to tty from
    speakup code.
    
    In case of tty being null, this sets synth->alive to zero and restarts
    ttys in case they were stopped by speakup.
    
    Signed-off-by: Okash Khawaja <okash.khawaja@gmail.com>
    Reviewed-by: Samuel Thibault <samuel.thibault@ens-lyon.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/speakup/spk_ttyio.c b/drivers/staging/speakup/spk_ttyio.c
index bcc3873c8c50..f643167921c3 100644
--- a/drivers/staging/speakup/spk_ttyio.c
+++ b/drivers/staging/speakup/spk_ttyio.c
@@ -15,6 +15,11 @@ struct spk_ldisc_data {
 
 static struct spk_synth *spk_ttyio_synth;
 static struct tty_struct *speakup_tty;
+/* mutex to protect against speakup_tty disappearing from underneath us while
+ * we are using it. this can happen when the device physically unplugged,
+ * while in use. it also serialises access to speakup_tty.
+ */
+static DEFINE_MUTEX(speakup_tty_mutex);
 
 static int ser_to_dev(int ser, dev_t *dev_no)
 {
@@ -60,8 +65,10 @@ static int spk_ttyio_ldisc_open(struct tty_struct *tty)
 
 static void spk_ttyio_ldisc_close(struct tty_struct *tty)
 {
+	mutex_lock(&speakup_tty_mutex);
 	kfree(speakup_tty->disc_data);
 	speakup_tty = NULL;
+	mutex_unlock(&speakup_tty_mutex);
 }
 
 static int spk_ttyio_receive_buf2(struct tty_struct *tty,
@@ -189,9 +196,11 @@ void spk_ttyio_unregister_ldisc(void)
 
 static int spk_ttyio_out(struct spk_synth *in_synth, const char ch)
 {
+	mutex_lock(&speakup_tty_mutex);
 	if (in_synth->alive && speakup_tty && speakup_tty->ops->write) {
 		int ret = speakup_tty->ops->write(speakup_tty, &ch, 1);
 
+		mutex_unlock(&speakup_tty_mutex);
 		if (ret == 0)
 			/* No room */
 			return 0;
@@ -207,17 +216,50 @@ static int spk_ttyio_out(struct spk_synth *in_synth, const char ch)
 		}
 		return 1;
 	}
+
+	mutex_unlock(&speakup_tty_mutex);
+	return 0;
+}
+
+static int check_tty(struct tty_struct *tty)
+{
+	if (!tty) {
+		pr_warn("%s: I/O error, deactivating speakup\n",
+			spk_ttyio_synth->long_name);
+		/* No synth any more, so nobody will restart TTYs, and we thus
+		 * need to do it ourselves.  Now that there is no synth we can
+		 * let application flood anyway
+		 */
+		spk_ttyio_synth->alive = 0;
+		speakup_start_ttys();
+		return 1;
+	}
+
 	return 0;
 }
 
 static void spk_ttyio_send_xchar(char ch)
 {
+	mutex_lock(&speakup_tty_mutex);
+	if (check_tty(speakup_tty)) {
+		mutex_unlock(&speakup_tty_mutex);
+		return;
+	}
+
 	speakup_tty->ops->send_xchar(speakup_tty, ch);
+	mutex_unlock(&speakup_tty_mutex);
 }
 
 static void spk_ttyio_tiocmset(unsigned int set, unsigned int clear)
 {
+	mutex_lock(&speakup_tty_mutex);
+	if (check_tty(speakup_tty)) {
+		mutex_unlock(&speakup_tty_mutex);
+		return;
+	}
+
 	speakup_tty->ops->tiocmset(speakup_tty, set, clear);
+	mutex_unlock(&speakup_tty_mutex);
 }
 
 static unsigned char ttyio_in(int timeout)
@@ -257,8 +299,16 @@ static unsigned char spk_ttyio_in_nowait(void)
 
 static void spk_ttyio_flush_buffer(void)
 {
+	mutex_lock(&speakup_tty_mutex);
+	if (check_tty(speakup_tty)) {
+		mutex_unlock(&speakup_tty_mutex);
+		return;
+	}
+
 	if (speakup_tty->ops->flush_buffer)
 		speakup_tty->ops->flush_buffer(speakup_tty);
+
+	mutex_unlock(&speakup_tty_mutex);
 }
 
 int spk_ttyio_synth_probe(struct spk_synth *synth)

commit 043a2e7520f23da5487c2493acf4712cd7c1461b
Author: Okash Khawaja <okash.khawaja@gmail.com>
Date:   Sat Aug 12 08:39:48 2017 +0100

    staging: speakup: remove support for lp*
    
    Testing has shown that lp* devices don't work correctly with speakup
    just yet. That will require some additional work. Until then, this patch
    removes code related to that.
    
    Signed-off-by: Okash Khawaja <okash.khawaja@gmail.com>
    Reviewed-by: Samuel Thibault <samuel.thibault@ens-lyon.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/speakup/spk_ttyio.c b/drivers/staging/speakup/spk_ttyio.c
index fe340b07c482..bcc3873c8c50 100644
--- a/drivers/staging/speakup/spk_ttyio.c
+++ b/drivers/staging/speakup/spk_ttyio.c
@@ -7,11 +7,6 @@
 #include "spk_types.h"
 #include "spk_priv.h"
 
-#define DEV_PREFIX_LP "lp"
-
-static const char * const lp_supported[] = { "acntsa", "bns", "dummy",
-	"txprt" };
-
 struct spk_ldisc_data {
 	char buf;
 	struct semaphore sem;
@@ -36,24 +31,8 @@ static int get_dev_to_use(struct spk_synth *synth, dev_t *dev_no)
 {
 	/* use ser only when dev is not specified */
 	if (strcmp(synth->dev_name, SYNTH_DEFAULT_DEV) ||
-	    synth->ser == SYNTH_DEFAULT_SER) {
-		/* for /dev/lp* check if synth is supported */
-		if (strncmp(synth->dev_name, DEV_PREFIX_LP,
-		    strlen(DEV_PREFIX_LP)) == 0)
-			if (match_string(lp_supported, ARRAY_SIZE(lp_supported),
-			    synth->name) < 0)  {
-				int i;
-
-				pr_err("speakup: lp* is only supported on:");
-				for (i = 0; i < ARRAY_SIZE(lp_supported); i++)
-					pr_cont(" %s", lp_supported[i]);
-				pr_cont("\n");
-
-				return -ENOTSUPP;
-			}
-
+	    synth->ser == SYNTH_DEFAULT_SER)
 		return tty_dev_name_to_number(synth->dev_name, dev_no);
-	}
 
 	return ser_to_dev(synth->ser, dev_no);
 }

commit e23a9b439ce9bd9cbd3d92e4c15db086d3e11410
Author: Okash Khawaja <okash.khawaja@gmail.com>
Date:   Sun Jul 16 17:18:26 2017 +0100

    staging: speakup: safely register and unregister ldisc
    
    This patch makes use of functions added in the previous patch. It
    registers ldisc during init of main speakup module and unregisters it
    during exit. It also removes the code to register ldisc every time a
    synth module is loaded. This way we only register the ldisc once when
    main speakup module is loaded. Since main speakup module is required by
    all synth modules, it is only unloaded when all synths have been
    unloaded. Therefore we unregister the ldisc once, when all speakup
    related references to the ldisc have returned. In unlikely scenario of
    something outside speakup using the ldisc, the ldisc refcount check in
    tty_unregister_ldisc will ensure that it is not unregistered while in
    use.
    
    The function to register ldisc doesn't cause speakup init function to
    fail. That is different from current behaviour where failure to register
    ldisc results in failure to load the specific synth module. This is
    because speakup module is also required by those synths which don't use
    tty and ldisc. We don't want to prevent those modules from loading when
    ldisc fails to register. The synth modules will correctly fail when
    trying to set N_SPEAKUP to tty, if ldisc registrationi had failed.
    
    Signed-off-by: Okash Khawaja <okash.khawaja@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/speakup/spk_ttyio.c b/drivers/staging/speakup/spk_ttyio.c
index 9b02345f66cc..fe340b07c482 100644
--- a/drivers/staging/speakup/spk_ttyio.c
+++ b/drivers/staging/speakup/spk_ttyio.c
@@ -154,12 +154,6 @@ static int spk_ttyio_initialise_ldisc(struct spk_synth *synth)
 	struct ktermios tmp_termios;
 	dev_t dev;
 
-	ret = tty_register_ldisc(N_SPEAKUP, &spk_ttyio_ldisc_ops);
-	if (ret) {
-		pr_err("Error registering line discipline.\n");
-		return ret;
-	}
-
 	ret = get_dev_to_use(synth, &dev);
 	if (ret)
 		return ret;
@@ -196,6 +190,8 @@ static int spk_ttyio_initialise_ldisc(struct spk_synth *synth)
 	tty_unlock(tty);
 
 	ret = tty_set_ldisc(tty, N_SPEAKUP);
+	if (ret)
+		pr_err("speakup: Failed to set N_SPEAKUP on tty\n");
 
 	return ret;
 }

commit 9f8dced2085c33a633d2f0a1abbf13ff5a7ed8c9
Author: Okash Khawaja <okash.khawaja@gmail.com>
Date:   Sun Jul 16 17:18:25 2017 +0100

    staging: speakup: add functions to register and unregister ldisc
    
    This patch adds the above two functions and makes them available to
    main.c where they will be called during init and exit functions of
    main speakup module. Following patch will make use of them.
    
    Signed-off-by: Okash Khawaja <okash.khawaja@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/speakup/spk_ttyio.c b/drivers/staging/speakup/spk_ttyio.c
index 924034a3de4b..9b02345f66cc 100644
--- a/drivers/staging/speakup/spk_ttyio.c
+++ b/drivers/staging/speakup/spk_ttyio.c
@@ -200,6 +200,18 @@ static int spk_ttyio_initialise_ldisc(struct spk_synth *synth)
 	return ret;
 }
 
+void spk_ttyio_register_ldisc(void)
+{
+	if (tty_register_ldisc(N_SPEAKUP, &spk_ttyio_ldisc_ops))
+		pr_warn("speakup: Error registering line discipline. Most synths won't work.\n");
+}
+
+void spk_ttyio_unregister_ldisc(void)
+{
+	if (tty_unregister_ldisc(N_SPEAKUP))
+		pr_warn("speakup: Couldn't unregister ldisc\n");
+}
+
 static int spk_ttyio_out(struct spk_synth *in_synth, const char ch)
 {
 	if (in_synth->alive && speakup_tty && speakup_tty->ops->write) {

commit 216ce2962089b6218708bf87d96e6b1fbadba1d7
Author: Okash Khawaja <okash.khawaja@gmail.com>
Date:   Sun Jul 16 10:28:21 2017 +0100

    staging: speakup: safely close tty
    
    Speakup opens tty using tty_open_by_driver. When closing, it calls
    tty_ldisc_release but doesn't close and remove the tty itself. As a
    result, that tty cannot be opened from user space. This patch calls
    tty_release_struct which ensures that tty is safely removed and freed
    up. It also calls tty_ldisc_release, so speakup doesn't need to call it.
    
    Signed-off-by: Okash Khawaja <okash.khawaja@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/speakup/spk_ttyio.c b/drivers/staging/speakup/spk_ttyio.c
index ed8e96b06ead..924034a3de4b 100644
--- a/drivers/staging/speakup/spk_ttyio.c
+++ b/drivers/staging/speakup/spk_ttyio.c
@@ -300,7 +300,7 @@ void spk_ttyio_release(void)
 
 	tty_ldisc_flush(speakup_tty);
 	tty_unlock(speakup_tty);
-	tty_ldisc_release(speakup_tty);
+	tty_release_struct(speakup_tty, speakup_tty->index);
 }
 EXPORT_SYMBOL_GPL(spk_ttyio_release);
 

commit ce73724d4d4f5f807ca0739b8993394ece9f4212
Author: Colin Ian King <colin.king@canonical.com>
Date:   Wed Jun 28 14:13:51 2017 +0100

    staging: speakup: make function ser_to_dev static
    
    The helper function ser_to_dev does not need to be in global scope, so
    make it static.
    
    Cleans up sparse warning:
    "warning: symbol 'ser_to_dev' was not declared. Should it be static?"
    
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Reviewed-by: Okash Khawaja <okash.khawaja@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/speakup/spk_ttyio.c b/drivers/staging/speakup/spk_ttyio.c
index 442f191a017e..ed8e96b06ead 100644
--- a/drivers/staging/speakup/spk_ttyio.c
+++ b/drivers/staging/speakup/spk_ttyio.c
@@ -21,7 +21,7 @@ struct spk_ldisc_data {
 static struct spk_synth *spk_ttyio_synth;
 static struct tty_struct *speakup_tty;
 
-int ser_to_dev(int ser, dev_t *dev_no)
+static int ser_to_dev(int ser, dev_t *dev_no)
 {
 	if (ser < 0 || ser > (255 - 64)) {
 		pr_err("speakup: Invalid ser param. Must be between 0 and 191 inclusive.\n");

commit 8a21ff775f5654eb078ae57ba64cdbd32b9297c4
Author: Okash Khawaja <okash.khawaja@gmail.com>
Date:   Sun Jun 25 19:40:02 2017 +0100

    staging: speakup: make ttyio synths use device name
    
    This patch introduces new module parameter, dev, which takes a string
    representing the device that the external synth is connected to, e.g.
    ttyS0, ttyUSB0 etc. This is then used to communicate with the synth.
    That way, speakup can support more than ttyS*. As of this patch, it
    only supports ttyS*, ttyUSB* and selected synths for lp*. dev parameter
    is only available for tty-migrated synths.
    
    Users will either use dev or ser as both serve same purpose. This patch
    maintains backward compatility by allowing ser to be specified. When
    both are specified, whichever is non-default, i.e. not ttyS0, is used.
    If both are non-default then dev is used.
    
    Signed-off-by: Okash Khawaja <okash.khawaja@gmail.com>
    Reviewed-by: Samuel Thibault <samuel.thibault@ens-lyon.org>
    Reviewed-by: Andy Shevchenko <andy.shevchenko@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/speakup/spk_ttyio.c b/drivers/staging/speakup/spk_ttyio.c
index 0a5436706e74..442f191a017e 100644
--- a/drivers/staging/speakup/spk_ttyio.c
+++ b/drivers/staging/speakup/spk_ttyio.c
@@ -147,11 +147,12 @@ static inline void get_termios(struct tty_struct *tty, struct ktermios *out_term
 	up_read(&tty->termios_rwsem);
 }
 
-static int spk_ttyio_initialise_ldisc(int ser)
+static int spk_ttyio_initialise_ldisc(struct spk_synth *synth)
 {
 	int ret = 0;
 	struct tty_struct *tty;
 	struct ktermios tmp_termios;
+	dev_t dev;
 
 	ret = tty_register_ldisc(N_SPEAKUP, &spk_ttyio_ldisc_ops);
 	if (ret) {
@@ -159,13 +160,11 @@ static int spk_ttyio_initialise_ldisc(int ser)
 		return ret;
 	}
 
-	if (ser < 0 || ser > (255 - 64)) {
-		pr_err("speakup: Invalid ser param. Must be between 0 and 191 inclusive.\n");
-		return -EINVAL;
-	}
+	ret = get_dev_to_use(synth, &dev);
+	if (ret)
+		return ret;
 
-	/* TODO: support more than ttyS* */
-	tty = tty_open_by_driver(MKDEV(4, (ser +  64)), NULL, NULL);
+	tty = tty_open_by_driver(dev, NULL, NULL);
 	if (IS_ERR(tty))
 		return PTR_ERR(tty);
 
@@ -277,7 +276,7 @@ static void spk_ttyio_flush_buffer(void)
 
 int spk_ttyio_synth_probe(struct spk_synth *synth)
 {
-	int rv = spk_ttyio_initialise_ldisc(synth->ser);
+	int rv = spk_ttyio_initialise_ldisc(synth);
 
 	if (rv)
 		return rv;

commit a5525dc0b8341cfa2d6c8bfe2796168a0ce83dfd
Author: Okash Khawaja <okash.khawaja@gmail.com>
Date:   Sun Jun 25 19:40:01 2017 +0100

    staging: speakup: check and convert dev name or ser to dev_t
    
    This patch adds functionality to validate and convert either a device
    name or 'ser' memmber of synth into dev_t. Subsequent patch in this set
    will call it to convert user-specified device into device number. For
    device name, this patch does some basic sanity checks on the string
    passed in. It currently supports ttyS*, ttyUSB* and, for selected
    synths, lp*.
    
    The patch also introduces a string member variable named 'dev_name' to
    struct spk_synth. 'dev_name' represents the device name - ttyUSB0 etc -
    which needs conversion to dev_t.
    
    Signed-off-by: Okash Khawaja <okash.khawaja@gmail.com>
    Reviewed-by: Andy Shevchenko <andy.shevchenko@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/speakup/spk_ttyio.c b/drivers/staging/speakup/spk_ttyio.c
index 4e346697e53d..0a5436706e74 100644
--- a/drivers/staging/speakup/spk_ttyio.c
+++ b/drivers/staging/speakup/spk_ttyio.c
@@ -7,6 +7,11 @@
 #include "spk_types.h"
 #include "spk_priv.h"
 
+#define DEV_PREFIX_LP "lp"
+
+static const char * const lp_supported[] = { "acntsa", "bns", "dummy",
+	"txprt" };
+
 struct spk_ldisc_data {
 	char buf;
 	struct semaphore sem;
@@ -16,6 +21,43 @@ struct spk_ldisc_data {
 static struct spk_synth *spk_ttyio_synth;
 static struct tty_struct *speakup_tty;
 
+int ser_to_dev(int ser, dev_t *dev_no)
+{
+	if (ser < 0 || ser > (255 - 64)) {
+		pr_err("speakup: Invalid ser param. Must be between 0 and 191 inclusive.\n");
+		return -EINVAL;
+	}
+
+	*dev_no = MKDEV(4, (64 + ser));
+	return 0;
+}
+
+static int get_dev_to_use(struct spk_synth *synth, dev_t *dev_no)
+{
+	/* use ser only when dev is not specified */
+	if (strcmp(synth->dev_name, SYNTH_DEFAULT_DEV) ||
+	    synth->ser == SYNTH_DEFAULT_SER) {
+		/* for /dev/lp* check if synth is supported */
+		if (strncmp(synth->dev_name, DEV_PREFIX_LP,
+		    strlen(DEV_PREFIX_LP)) == 0)
+			if (match_string(lp_supported, ARRAY_SIZE(lp_supported),
+			    synth->name) < 0)  {
+				int i;
+
+				pr_err("speakup: lp* is only supported on:");
+				for (i = 0; i < ARRAY_SIZE(lp_supported); i++)
+					pr_cont(" %s", lp_supported[i]);
+				pr_cont("\n");
+
+				return -ENOTSUPP;
+			}
+
+		return tty_dev_name_to_number(synth->dev_name, dev_no);
+	}
+
+	return ser_to_dev(synth->ser, dev_no);
+}
+
 static int spk_ttyio_ldisc_open(struct tty_struct *tty)
 {
 	struct spk_ldisc_data *ldisc_data;

commit 650b175d635d25c771eab2e8ff8a11584bb3273a
Author: Alexandre Ghiti <alex@ghiti.fr>
Date:   Fri Jun 9 14:14:32 2017 +0200

    staging: speakup: Add missing blank line after declaration
    
    This patch fixes checkpatch warnings about adding a blank line after
    variable declaration.
    
    Signed-off-by: Alexandre Ghiti <alex@ghiti.fr>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/speakup/spk_ttyio.c b/drivers/staging/speakup/spk_ttyio.c
index d55c056bbefe..4e346697e53d 100644
--- a/drivers/staging/speakup/spk_ttyio.c
+++ b/drivers/staging/speakup/spk_ttyio.c
@@ -50,6 +50,7 @@ static int spk_ttyio_receive_buf2(struct tty_struct *tty,
 
 	if (spk_ttyio_synth->read_buff_add) {
 		int i;
+
 		for (i = 0; i < count; i++)
 			spk_ttyio_synth->read_buff_add(cp[i]);
 
@@ -162,6 +163,7 @@ static int spk_ttyio_out(struct spk_synth *in_synth, const char ch)
 {
 	if (in_synth->alive && speakup_tty && speakup_tty->ops->write) {
 		int ret = speakup_tty->ops->write(speakup_tty, &ch, 1);
+
 		if (ret == 0)
 			/* No room */
 			return 0;

commit 349190d56be6eccb940df18831d8654b19a697aa
Author: Okash Khawaja <okash.khawaja@gmail.com>
Date:   Thu Jun 1 14:15:29 2017 +0100

    staging: speakup: remove unused code
    
    In spk_ttyio_release we read tty's index but never do anything with it.
    The patch removes this dead code.
    
    Signed-off-by: Okash Khawaja <okash.khawaja@gmail.com>
    Reviewed-by: Samuel Thibault <samuel.thibault@ens-lyon.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/speakup/spk_ttyio.c b/drivers/staging/speakup/spk_ttyio.c
index 7b1eaf976f52..d55c056bbefe 100644
--- a/drivers/staging/speakup/spk_ttyio.c
+++ b/drivers/staging/speakup/spk_ttyio.c
@@ -247,13 +247,10 @@ EXPORT_SYMBOL_GPL(spk_ttyio_synth_probe);
 
 void spk_ttyio_release(void)
 {
-	int idx;
-
 	if (!speakup_tty)
 		return;
 
 	tty_lock(speakup_tty);
-	idx = speakup_tty->index;
 
 	if (speakup_tty->ops->close)
 		speakup_tty->ops->close(speakup_tty, NULL);

commit 011cca558b6256ff14464e61c111707415a0484f
Author: Okash Khawaja <okash.khawaja@gmail.com>
Date:   Wed May 31 20:50:12 2017 +0100

    staging: speakup: check for null before calling TTY's flush_buffer
    
    We should check the flush_buffer method of a tty for null before
    invoking it. Some drivers such as usbserial don't implement
    flush_buffer. This will be required for upcoming patches where we expand
    spk_ttyio to support more than just ttyS*.
    
    Signed-off-by: Okash Khawaja <okash.khawaja@gmail.com>
    Reviewed-by: Samuel Thibault <samuel.thibault@ens-lyon.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/speakup/spk_ttyio.c b/drivers/staging/speakup/spk_ttyio.c
index ed36240cf382..7b1eaf976f52 100644
--- a/drivers/staging/speakup/spk_ttyio.c
+++ b/drivers/staging/speakup/spk_ttyio.c
@@ -227,7 +227,8 @@ static unsigned char spk_ttyio_in_nowait(void)
 
 static void spk_ttyio_flush_buffer(void)
 {
-	speakup_tty->ops->flush_buffer(speakup_tty);
+	if (speakup_tty->ops->flush_buffer)
+		speakup_tty->ops->flush_buffer(speakup_tty);
 }
 
 int spk_ttyio_synth_probe(struct spk_synth *synth)

commit fc0f0bd61230f4d85670928539db40ab5528b50c
Author: Rui Teng <rui.teng@linux.vnet.ibm.com>
Date:   Tue May 23 10:04:15 2017 +0800

    drivers/staging/speakup: fix indent coding style problem in spk_ttyio.c
    
    This is a patch to the spk_ttyio.c file which fixes up the indent error
    reported by the checkpatch.pl tool.
    
    Signed-off-by: Rui Teng <rui.teng@linux.vnet.ibm.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/speakup/spk_ttyio.c b/drivers/staging/speakup/spk_ttyio.c
index 8ed7c71c712f..ed36240cf382 100644
--- a/drivers/staging/speakup/spk_ttyio.c
+++ b/drivers/staging/speakup/spk_ttyio.c
@@ -61,7 +61,7 @@ static int spk_ttyio_receive_buf2(struct tty_struct *tty,
 		return 0;
 
 	/* Make sure the consumer has read buf before we have seen
-         * buf_free == true and overwrite buf */
+	 * buf_free == true and overwrite buf */
 	mb();
 
 	ldisc_data->buf = cp[0];

commit e45423d76f1c229b1a30ddde205a72774cdb12c6
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Sat May 20 00:27:18 2017 +0300

    staging: speakup: signedness bug in spk_ttyio_in_nowait()
    
    On most of the common arches char is signed so it can't ever == 0xff.
    Let's fix this by making it a u8.
    
    Fixes: 6b9ad1c742bf ("staging: speakup: add send_xchar, tiocmset and input functionality for tty")
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Reviewed-by: Samuel Thibault <samuel.thibault@ens-lyon.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/speakup/spk_ttyio.c b/drivers/staging/speakup/spk_ttyio.c
index 6e0f042f6a44..8ed7c71c712f 100644
--- a/drivers/staging/speakup/spk_ttyio.c
+++ b/drivers/staging/speakup/spk_ttyio.c
@@ -220,7 +220,7 @@ static unsigned char spk_ttyio_in(void)
 
 static unsigned char spk_ttyio_in_nowait(void)
 {
-	char rv = ttyio_in(0);
+	u8 rv = ttyio_in(0);
 
 	return (rv == 0xff) ? 0 : rv;
 }

commit 1c5973675cee92d5e8ad3a8a6e53a3e822bae271
Author: Okash Khawaja <okash.khawaja@gmail.com>
Date:   Mon May 15 18:45:37 2017 +0100

    staging: speakup: flush tty buffers and ensure hardware flow control
    
    This patch fixes the issue where TTY-migrated synths would take a while
    to shut up after hitting numpad enter key. When calling synth_flush,
    even though XOFF character is sent as high priority, data buffered in
    TTY layer is still sent to the synth. This patch flushes that buffered
    data when synth_flush is called.
    
    It also tries to ensure that hardware flow control is enabled, by
    setting CRTSCTS using tty's termios.
    
    Reported-by: John Covici <covici@ccs.covici.com>
    Signed-off-by: Okash Khawaja <okash.khawaja@gmail.com>
    Reviewed-by: Samuel Thibault <samuel.thibault@ens-lyon.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/speakup/spk_ttyio.c b/drivers/staging/speakup/spk_ttyio.c
index 61c01bfe17a8..6e0f042f6a44 100644
--- a/drivers/staging/speakup/spk_ttyio.c
+++ b/drivers/staging/speakup/spk_ttyio.c
@@ -85,6 +85,7 @@ static void spk_ttyio_send_xchar(char ch);
 static void spk_ttyio_tiocmset(unsigned int set, unsigned int clear);
 static unsigned char spk_ttyio_in(void);
 static unsigned char spk_ttyio_in_nowait(void);
+static void spk_ttyio_flush_buffer(void);
 
 struct spk_io_ops spk_ttyio_ops = {
 	.synth_out = spk_ttyio_out,
@@ -92,13 +93,22 @@ struct spk_io_ops spk_ttyio_ops = {
 	.tiocmset = spk_ttyio_tiocmset,
 	.synth_in = spk_ttyio_in,
 	.synth_in_nowait = spk_ttyio_in_nowait,
+	.flush_buffer = spk_ttyio_flush_buffer,
 };
 EXPORT_SYMBOL_GPL(spk_ttyio_ops);
 
+static inline void get_termios(struct tty_struct *tty, struct ktermios *out_termios)
+{
+	down_read(&tty->termios_rwsem);
+	*out_termios = tty->termios;
+	up_read(&tty->termios_rwsem);
+}
+
 static int spk_ttyio_initialise_ldisc(int ser)
 {
 	int ret = 0;
 	struct tty_struct *tty;
+	struct ktermios tmp_termios;
 
 	ret = tty_register_ldisc(N_SPEAKUP, &spk_ttyio_ldisc_ops);
 	if (ret) {
@@ -127,6 +137,20 @@ static int spk_ttyio_initialise_ldisc(int ser)
 	}
 
 	clear_bit(TTY_HUPPED, &tty->flags);
+	/* ensure hardware flow control is enabled */
+	get_termios(tty, &tmp_termios);
+	if (!(tmp_termios.c_cflag & CRTSCTS)) {
+		tmp_termios.c_cflag |= CRTSCTS;
+		tty_set_termios(tty, &tmp_termios);
+		/*
+		 * check c_cflag to see if it's updated as tty_set_termios may not return
+		 * error even when no tty bits are changed by the request.
+		 */
+		get_termios(tty, &tmp_termios);
+		if (!(tmp_termios.c_cflag & CRTSCTS))
+			pr_warn("speakup: Failed to set hardware flow control\n");
+	}
+
 	tty_unlock(tty);
 
 	ret = tty_set_ldisc(tty, N_SPEAKUP);
@@ -201,6 +225,11 @@ static unsigned char spk_ttyio_in_nowait(void)
 	return (rv == 0xff) ? 0 : rv;
 }
 
+static void spk_ttyio_flush_buffer(void)
+{
+	speakup_tty->ops->flush_buffer(speakup_tty);
+}
+
 int spk_ttyio_synth_probe(struct spk_synth *synth)
 {
 	int rv = spk_ttyio_initialise_ldisc(synth->ser);

commit 6b9ad1c742bf227b1005a41d8baa315b747e3e8d
Author: Okash Khawaja <okash.khawaja@gmail.com>
Date:   Mon May 15 18:45:35 2017 +0100

    staging: speakup: add send_xchar, tiocmset and input functionality for tty
    
    This patch adds further TTY-based functionality, specifically implementation
    of send_xchar and tiocmset methods, and input. send_xchar and tiocmset
    methods simply delegate to corresponding TTY operations.
    
    For input, it implements the receive_buf2 callback in tty_ldisc_ops of
    speakup's ldisc. If a synth defines read_buff_add method then receive_buf2
    simply delegates to that and returns.
    
    For spk_ttyio_in, the data is passed from receive_buf2 thread to
    spk_ttyio_in thread through spk_ldisc_data structure. It has following
    members:
    
    - char buf: represents data received
    - struct semaphore sem: used to signal to spk_ttyio_in thread that data
            is available to be read without having to busy wait
    - bool buf_free: this is used in comination with mb() calls to syncronise
            the two threads over buf
    
    receive_buf2 only writes to buf if buf_free is true. The check for buf_free
    and writing to buf are separated by mb() to ensure that spk_ttyio_in has read
    buf before receive_buf2 writes to it. After writing, it ups the semaphore to
    signal to spk_ttyio_in that there is now data to read.
    
    spk_ttyio_in waits for data to read by downing the semaphore. Thus when
    signalled by receive_buf2 thread above, it reads from buf and sets buf_free
    to true. These two operations are separated by mb() to ensure that
    receive_buf2 thread finds buf_free to be true only after buf has been read.
    After that spk_ttyio_in calls tty_schedule_flip for subsequent data to come
    in through receive_buf2.
    
    Signed-off-by: Okash Khawaja <okash.khawaja@gmail.com>
    Reviewed-by: Samuel Thibault <samuel.thibault@ens-lyon.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/speakup/spk_ttyio.c b/drivers/staging/speakup/spk_ttyio.c
index ee37550e59b3..61c01bfe17a8 100644
--- a/drivers/staging/speakup/spk_ttyio.c
+++ b/drivers/staging/speakup/spk_ttyio.c
@@ -1,36 +1,97 @@
 #include <linux/types.h>
 #include <linux/tty.h>
+#include <linux/tty_flip.h>
+#include <linux/slab.h>
 
 #include "speakup.h"
 #include "spk_types.h"
+#include "spk_priv.h"
 
+struct spk_ldisc_data {
+	char buf;
+	struct semaphore sem;
+	bool buf_free;
+};
+
+static struct spk_synth *spk_ttyio_synth;
 static struct tty_struct *speakup_tty;
 
 static int spk_ttyio_ldisc_open(struct tty_struct *tty)
 {
+	struct spk_ldisc_data *ldisc_data;
+
 	if (tty->ops->write == NULL)
 		return -EOPNOTSUPP;
 	speakup_tty = tty;
 
+	ldisc_data = kmalloc(sizeof(struct spk_ldisc_data), GFP_KERNEL);
+	if (!ldisc_data) {
+		pr_err("speakup: Failed to allocate ldisc_data.\n");
+		return -ENOMEM;
+	}
+
+	sema_init(&ldisc_data->sem, 0);
+	ldisc_data->buf_free = true;
+	speakup_tty->disc_data = ldisc_data;
+
 	return 0;
 }
 
 static void spk_ttyio_ldisc_close(struct tty_struct *tty)
 {
+	kfree(speakup_tty->disc_data);
 	speakup_tty = NULL;
 }
 
+static int spk_ttyio_receive_buf2(struct tty_struct *tty,
+		const unsigned char *cp, char *fp, int count)
+{
+	struct spk_ldisc_data *ldisc_data = tty->disc_data;
+
+	if (spk_ttyio_synth->read_buff_add) {
+		int i;
+		for (i = 0; i < count; i++)
+			spk_ttyio_synth->read_buff_add(cp[i]);
+
+		return count;
+	}
+
+	if (!ldisc_data->buf_free)
+		/* ttyio_in will tty_schedule_flip */
+		return 0;
+
+	/* Make sure the consumer has read buf before we have seen
+         * buf_free == true and overwrite buf */
+	mb();
+
+	ldisc_data->buf = cp[0];
+	ldisc_data->buf_free = false;
+	up(&ldisc_data->sem);
+
+	return 1;
+}
+
 static struct tty_ldisc_ops spk_ttyio_ldisc_ops = {
 	.owner          = THIS_MODULE,
 	.magic          = TTY_LDISC_MAGIC,
 	.name           = "speakup_ldisc",
 	.open           = spk_ttyio_ldisc_open,
 	.close          = spk_ttyio_ldisc_close,
+	.receive_buf2	= spk_ttyio_receive_buf2,
 };
 
 static int spk_ttyio_out(struct spk_synth *in_synth, const char ch);
+static void spk_ttyio_send_xchar(char ch);
+static void spk_ttyio_tiocmset(unsigned int set, unsigned int clear);
+static unsigned char spk_ttyio_in(void);
+static unsigned char spk_ttyio_in_nowait(void);
+
 struct spk_io_ops spk_ttyio_ops = {
 	.synth_out = spk_ttyio_out,
+	.send_xchar = spk_ttyio_send_xchar,
+	.tiocmset = spk_ttyio_tiocmset,
+	.synth_in = spk_ttyio_in,
+	.synth_in_nowait = spk_ttyio_in_nowait,
 };
 EXPORT_SYMBOL_GPL(spk_ttyio_ops);
 
@@ -95,6 +156,51 @@ static int spk_ttyio_out(struct spk_synth *in_synth, const char ch)
 	return 0;
 }
 
+static void spk_ttyio_send_xchar(char ch)
+{
+	speakup_tty->ops->send_xchar(speakup_tty, ch);
+}
+
+static void spk_ttyio_tiocmset(unsigned int set, unsigned int clear)
+{
+	speakup_tty->ops->tiocmset(speakup_tty, set, clear);
+}
+
+static unsigned char ttyio_in(int timeout)
+{
+	struct spk_ldisc_data *ldisc_data = speakup_tty->disc_data;
+	char rv;
+
+	if (down_timeout(&ldisc_data->sem, usecs_to_jiffies(timeout)) == -ETIME) {
+		if (timeout)
+			pr_warn("spk_ttyio: timeout (%d)  while waiting for input\n",
+				timeout);
+		return 0xff;
+	}
+
+	rv = ldisc_data->buf;
+	/* Make sure we have read buf before we set buf_free to let
+	 * the producer overwrite it */
+	mb();
+	ldisc_data->buf_free = true;
+	/* Let TTY push more characters */
+	tty_schedule_flip(speakup_tty->port);
+
+	return rv;
+}
+
+static unsigned char spk_ttyio_in(void)
+{
+	return ttyio_in(SPK_SYNTH_TIMEOUT);
+}
+
+static unsigned char spk_ttyio_in_nowait(void)
+{
+	char rv = ttyio_in(0);
+
+	return (rv == 0xff) ? 0 : rv;
+}
+
 int spk_ttyio_synth_probe(struct spk_synth *synth)
 {
 	int rv = spk_ttyio_initialise_ldisc(synth->ser);
@@ -103,6 +209,7 @@ int spk_ttyio_synth_probe(struct spk_synth *synth)
 		return rv;
 
 	synth->alive = 1;
+	spk_ttyio_synth = synth;
 
 	return 0;
 }

commit 1ab92da32e37758c0e2e2a455f06d5f40609f14e
Author: Okash Khawaja <okash.khawaja@gmail.com>
Date:   Mon May 15 18:45:33 2017 +0100

    staging: speakup: add tty-based comms functions
    
    This adds spk_ttyio.c file. It contains a set of functions which implement
    those methods in spk_synth struct which relate to sending bytes out using
    serial comms. Implementations in this file perform the same function but
    using TTY subsystem instead. Currently synths access serial ports, directly
    poking standard ISA ports by trying to steal them from serial driver. Some ISA
    cards actually need this way of doing it, but most other synthesizers don't,
    and can actually work by using the proper TTY subsystem through a new N_SPEAKUP
    line discipline. So this adds the methods for drivers to switch to accessing
    serial ports through the TTY subsystem, whenever appropriate.
    
    Signed-off-by: Okash Khawaja <okash.khawaja@gmail.com>
    Reviewed-by: Samuel Thibault <samuel.thibault@ens-lyon.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/speakup/spk_ttyio.c b/drivers/staging/speakup/spk_ttyio.c
new file mode 100644
index 000000000000..ee37550e59b3
--- /dev/null
+++ b/drivers/staging/speakup/spk_ttyio.c
@@ -0,0 +1,143 @@
+#include <linux/types.h>
+#include <linux/tty.h>
+
+#include "speakup.h"
+#include "spk_types.h"
+
+static struct tty_struct *speakup_tty;
+
+static int spk_ttyio_ldisc_open(struct tty_struct *tty)
+{
+	if (tty->ops->write == NULL)
+		return -EOPNOTSUPP;
+	speakup_tty = tty;
+
+	return 0;
+}
+
+static void spk_ttyio_ldisc_close(struct tty_struct *tty)
+{
+	speakup_tty = NULL;
+}
+
+static struct tty_ldisc_ops spk_ttyio_ldisc_ops = {
+	.owner          = THIS_MODULE,
+	.magic          = TTY_LDISC_MAGIC,
+	.name           = "speakup_ldisc",
+	.open           = spk_ttyio_ldisc_open,
+	.close          = spk_ttyio_ldisc_close,
+};
+
+static int spk_ttyio_out(struct spk_synth *in_synth, const char ch);
+struct spk_io_ops spk_ttyio_ops = {
+	.synth_out = spk_ttyio_out,
+};
+EXPORT_SYMBOL_GPL(spk_ttyio_ops);
+
+static int spk_ttyio_initialise_ldisc(int ser)
+{
+	int ret = 0;
+	struct tty_struct *tty;
+
+	ret = tty_register_ldisc(N_SPEAKUP, &spk_ttyio_ldisc_ops);
+	if (ret) {
+		pr_err("Error registering line discipline.\n");
+		return ret;
+	}
+
+	if (ser < 0 || ser > (255 - 64)) {
+		pr_err("speakup: Invalid ser param. Must be between 0 and 191 inclusive.\n");
+		return -EINVAL;
+	}
+
+	/* TODO: support more than ttyS* */
+	tty = tty_open_by_driver(MKDEV(4, (ser +  64)), NULL, NULL);
+	if (IS_ERR(tty))
+		return PTR_ERR(tty);
+
+	if (tty->ops->open)
+		ret = tty->ops->open(tty, NULL);
+	else
+		ret = -ENODEV;
+
+	if (ret) {
+		tty_unlock(tty);
+		return ret;
+	}
+
+	clear_bit(TTY_HUPPED, &tty->flags);
+	tty_unlock(tty);
+
+	ret = tty_set_ldisc(tty, N_SPEAKUP);
+
+	return ret;
+}
+
+static int spk_ttyio_out(struct spk_synth *in_synth, const char ch)
+{
+	if (in_synth->alive && speakup_tty && speakup_tty->ops->write) {
+		int ret = speakup_tty->ops->write(speakup_tty, &ch, 1);
+		if (ret == 0)
+			/* No room */
+			return 0;
+		if (ret < 0) {
+			pr_warn("%s: I/O error, deactivating speakup\n", in_synth->long_name);
+			/* No synth any more, so nobody will restart TTYs, and we thus
+			 * need to do it ourselves.  Now that there is no synth we can
+			 * let application flood anyway
+			 */
+			in_synth->alive = 0;
+			speakup_start_ttys();
+			return 0;
+		}
+		return 1;
+	}
+	return 0;
+}
+
+int spk_ttyio_synth_probe(struct spk_synth *synth)
+{
+	int rv = spk_ttyio_initialise_ldisc(synth->ser);
+
+	if (rv)
+		return rv;
+
+	synth->alive = 1;
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(spk_ttyio_synth_probe);
+
+void spk_ttyio_release(void)
+{
+	int idx;
+
+	if (!speakup_tty)
+		return;
+
+	tty_lock(speakup_tty);
+	idx = speakup_tty->index;
+
+	if (speakup_tty->ops->close)
+		speakup_tty->ops->close(speakup_tty, NULL);
+
+	tty_ldisc_flush(speakup_tty);
+	tty_unlock(speakup_tty);
+	tty_ldisc_release(speakup_tty);
+}
+EXPORT_SYMBOL_GPL(spk_ttyio_release);
+
+const char *spk_ttyio_synth_immediate(struct spk_synth *synth, const char *buff)
+{
+	u_char ch;
+
+	while ((ch = *buff)) {
+		if (ch == '\n')
+			ch = synth->procspeech;
+		if (tty_write_room(speakup_tty) < 1 || !synth->io_ops->synth_out(synth, ch))
+			return buff;
+		buff++;
+	}
+	return NULL;
+}
+EXPORT_SYMBOL_GPL(spk_ttyio_synth_immediate);
