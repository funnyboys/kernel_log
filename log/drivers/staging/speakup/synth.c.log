commit 45ac7b31bc6c4af885cc5b5d6c534c15bcbe7643
Author: Samuel Thibault <samuel.thibault@ens-lyon.org>
Date:   Thu Mar 7 23:06:57 2019 +0100

    staging: speakup_soft: Fix alternate speech with other synths
    
    When switching from speakup_soft to another synth, speakup_soft would
    keep calling synth_buffer_getc() from softsynthx_read.
    
    Let's thus make synth.c export the knowledge of the current synth, so
    that speakup_soft can determine whether it should be running.
    
    speakup_soft also needs to set itself alive, otherwise the switch would
    let it remain silent.
    
    Signed-off-by: Samuel Thibault <samuel.thibault@ens-lyon.org>
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/speakup/synth.c b/drivers/staging/speakup/synth.c
index 25f259ee4ffc..3568bfb89912 100644
--- a/drivers/staging/speakup/synth.c
+++ b/drivers/staging/speakup/synth.c
@@ -481,4 +481,10 @@ void synth_remove(struct spk_synth *in_synth)
 }
 EXPORT_SYMBOL_GPL(synth_remove);
 
+struct spk_synth *synth_current(void)
+{
+	return synth;
+}
+EXPORT_SYMBOL_GPL(synth_current);
+
 short spk_punc_masks[] = { 0, SOME, MOST, PUNC, PUNC | B_SYM };

commit 456aec73799f6cd31d5162d0814f8c372acffed6
Author: Justin Skists <justin.skists@juzza.co.uk>
Date:   Mon Jun 4 10:52:12 2018 +0100

    staging: speakup: refactor synths array to use a list
    
    The synths[] array is a collection of synths acting like a list.
    There is no need for synths to be an array, so refactor synths[] to use
    standard kernel list_head API, instead, and modify the usages to suit.
    As a side-effect, the maximum number of synths has also become redundant.
    
    Signed-off-by: Justin Skists <justin.skists@juzza.co.uk>
    Reviewed-by: Samuel Thibault <samuel.thibault@ens-lyon.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/speakup/synth.c b/drivers/staging/speakup/synth.c
index 7deeb7061018..25f259ee4ffc 100644
--- a/drivers/staging/speakup/synth.c
+++ b/drivers/staging/speakup/synth.c
@@ -18,8 +18,7 @@
 #include "speakup.h"
 #include "serialio.h"
 
-#define MAXSYNTHS       16      /* Max number of synths in array. */
-static struct spk_synth *synths[MAXSYNTHS + 1];
+static LIST_HEAD(synths);
 struct spk_synth *synth;
 char spk_pitch_buff[32] = "";
 static int module_status;
@@ -355,9 +354,8 @@ struct var_t synth_time_vars[] = {
 /* called by: speakup_init() */
 int synth_init(char *synth_name)
 {
-	int i;
 	int ret = 0;
-	struct spk_synth *synth = NULL;
+	struct spk_synth *tmp, *synth = NULL;
 
 	if (!synth_name)
 		return 0;
@@ -371,9 +369,10 @@ int synth_init(char *synth_name)
 
 	mutex_lock(&spk_mutex);
 	/* First, check if we already have it loaded. */
-	for (i = 0; i < MAXSYNTHS && synths[i]; i++)
-		if (strcmp(synths[i]->name, synth_name) == 0)
-			synth = synths[i];
+	list_for_each_entry(tmp, &synths, node) {
+		if (strcmp(tmp->name, synth_name) == 0)
+			synth = tmp;
+	}
 
 	/* If we got one, initialize it now. */
 	if (synth)
@@ -448,29 +447,23 @@ void synth_release(void)
 /* called by: all_driver_init() */
 int synth_add(struct spk_synth *in_synth)
 {
-	int i;
 	int status = 0;
+	struct spk_synth *tmp;
 
 	mutex_lock(&spk_mutex);
-	for (i = 0; i < MAXSYNTHS && synths[i]; i++)
-		/* synth_remove() is responsible for rotating the array down */
-		if (in_synth == synths[i]) {
+
+	list_for_each_entry(tmp, &synths, node) {
+		if (tmp == in_synth) {
 			mutex_unlock(&spk_mutex);
 			return 0;
 		}
-	if (i == MAXSYNTHS) {
-		pr_warn("Error: attempting to add a synth past end of array\n");
-		mutex_unlock(&spk_mutex);
-		return -1;
 	}
 
 	if (in_synth->startup)
 		status = do_synth_init(in_synth);
 
-	if (!status) {
-		synths[i++] = in_synth;
-		synths[i] = NULL;
-	}
+	if (!status)
+		list_add_tail(&in_synth->node, &synths);
 
 	mutex_unlock(&spk_mutex);
 	return status;
@@ -479,17 +472,10 @@ EXPORT_SYMBOL_GPL(synth_add);
 
 void synth_remove(struct spk_synth *in_synth)
 {
-	int i;
-
 	mutex_lock(&spk_mutex);
 	if (synth == in_synth)
 		synth_release();
-	for (i = 0; synths[i]; i++) {
-		if (in_synth == synths[i])
-			break;
-	}
-	for ( ; synths[i]; i++) /* compress table */
-		synths[i] = synths[i + 1];
+	list_del(&in_synth->node);
 	module_status = 0;
 	mutex_unlock(&spk_mutex);
 }

commit 65fa72d34360c571b058afeb0e64367d3eaf064b
Author: Samuel Thibault <samuel.thibault@ens-lyon.org>
Date:   Sat Mar 10 11:56:27 2018 +0100

    staging: speakup: Add unicode support to the speakup_dummy driver
    
    This extends spk_io_ops with a synth_out_unicode which takes a u16 character
    instead of just a byte, and extends spk_ttyio to implement it to emit
    utf-8. spk_do_catch_up_unicode can then be introduced to benefit from
    synth_out_unicode, and speakup_dummy made to use spk_do_catch_up_unicode instead
    of spk_do_catch_up.
    
    Signed-off-by: Samuel Thibault <samuel.thibault@ens-lyon.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/speakup/synth.c b/drivers/staging/speakup/synth.c
index c06e6a810999..7deeb7061018 100644
--- a/drivers/staging/speakup/synth.c
+++ b/drivers/staging/speakup/synth.c
@@ -52,9 +52,9 @@ static int do_synth_init(struct spk_synth *in_synth);
  * For devices that have a "full" notification mechanism, the driver can
  * adapt the loop the way they prefer.
  */
-void spk_do_catch_up(struct spk_synth *synth)
+static void _spk_do_catch_up(struct spk_synth *synth, int unicode)
 {
-	u_char ch;
+	u16 ch;
 	unsigned long flags;
 	unsigned long jiff_max;
 	struct var_t *delay_time;
@@ -63,6 +63,7 @@ void spk_do_catch_up(struct spk_synth *synth)
 	int jiffy_delta_val;
 	int delay_time_val;
 	int full_time_val;
+	int ret;
 
 	jiffy_delta = spk_get_var(JIFFY);
 	full_time = spk_get_var(FULL);
@@ -81,7 +82,8 @@ void spk_do_catch_up(struct spk_synth *synth)
 			synth->flush(synth);
 			continue;
 		}
-		synth_buffer_skip_nonlatin1();
+		if (!unicode)
+			synth_buffer_skip_nonlatin1();
 		if (synth_buffer_empty()) {
 			spin_unlock_irqrestore(&speakup_info.spinlock, flags);
 			break;
@@ -92,7 +94,11 @@ void spk_do_catch_up(struct spk_synth *synth)
 		spin_unlock_irqrestore(&speakup_info.spinlock, flags);
 		if (ch == '\n')
 			ch = synth->procspeech;
-		if (!synth->io_ops->synth_out(synth, ch)) {
+		if (unicode)
+			ret = synth->io_ops->synth_out_unicode(synth, ch);
+		else
+			ret = synth->io_ops->synth_out(synth, ch);
+		if (!ret) {
 			schedule_timeout(msecs_to_jiffies(full_time_val));
 			continue;
 		}
@@ -117,8 +123,19 @@ void spk_do_catch_up(struct spk_synth *synth)
 	}
 	synth->io_ops->synth_out(synth, synth->procspeech);
 }
+
+void spk_do_catch_up(struct spk_synth *synth)
+{
+	_spk_do_catch_up(synth, 0);
+}
 EXPORT_SYMBOL_GPL(spk_do_catch_up);
 
+void spk_do_catch_up_unicode(struct spk_synth *synth)
+{
+	_spk_do_catch_up(synth, 1);
+}
+EXPORT_SYMBOL_GPL(spk_do_catch_up_unicode);
+
 void spk_synth_flush(struct spk_synth *synth)
 {
 	synth->io_ops->flush_buffer();

commit 6496922817e1a1cba8a2d9939ca5de53c5d55239
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Thu Jan 11 11:08:40 2018 +0100

    staging: speakup: add SPDX identifier.
    
    It's good to have SPDX identifiers in all files to make it easier to
    audit the kernel tree for correct licenses.
    
    Fix up the remaining staging speakup files to have a proper SPDX
    identifier, based on the license text in the file itself.  The SPDX
    identifier is a legally binding shorthand, which can be used instead of
    the full boiler plate text.
    
    This work is based on a script and data from Thomas Gleixner, Philippe
    Ombredanne, and Kate Stewart.
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: Philippe Ombredanne <pombredanne@nexb.com>
    Cc: William Hubbs <w.d.hubbs@gmail.com>
    Cc: Chris Brannon <chris@the-brannons.com>
    Cc: Kirk Reiser <kirk@reisers.ca>
    Cc: Samuel Thibault <samuel.thibault@ens-lyon.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/speakup/synth.c b/drivers/staging/speakup/synth.c
index aac29c816d09..c06e6a810999 100644
--- a/drivers/staging/speakup/synth.c
+++ b/drivers/staging/speakup/synth.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 #include <linux/types.h>
 #include <linux/ctype.h>	/* for isdigit() and friends */
 #include <linux/fs.h>

commit 24ed960abf1d50cb7834e99a0cfc081bc0656712
Author: Kees Cook <keescook@chromium.org>
Date:   Mon Aug 28 11:28:21 2017 -0700

    treewide: Switch DEFINE_TIMER callbacks to struct timer_list *
    
    This changes all DEFINE_TIMER() callbacks to use a struct timer_list
    pointer instead of unsigned long. Since the data argument has already been
    removed, none of these callbacks are using their argument currently, so
    this renames the argument to "unused".
    
    Done using the following semantic patch:
    
    @match_define_timer@
    declarer name DEFINE_TIMER;
    identifier _timer, _callback;
    @@
    
     DEFINE_TIMER(_timer, _callback);
    
    @change_callback depends on match_define_timer@
    identifier match_define_timer._callback;
    type _origtype;
    identifier _origarg;
    @@
    
     void
    -_callback(_origtype _origarg)
    +_callback(struct timer_list *unused)
     { ... }
    
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/drivers/staging/speakup/synth.c b/drivers/staging/speakup/synth.c
index 6ddd3fc3f08d..aac29c816d09 100644
--- a/drivers/staging/speakup/synth.c
+++ b/drivers/staging/speakup/synth.c
@@ -153,7 +153,7 @@ int spk_synth_is_alive_restart(struct spk_synth *synth)
 }
 EXPORT_SYMBOL_GPL(spk_synth_is_alive_restart);
 
-static void thread_wake_up(u_long data)
+static void thread_wake_up(struct timer_list *unused)
 {
 	wake_up_interruptible_all(&speakup_event);
 }

commit 1d27e3e2252ba9d949ca82fbdb73cde102cb2067
Author: Kees Cook <keescook@chromium.org>
Date:   Wed Oct 4 16:27:04 2017 -0700

    timer: Remove expires and data arguments from DEFINE_TIMER
    
    Drop the arguments from the macro and adjust all callers with the
    following script:
    
      perl -pi -e 's/DEFINE_TIMER\((.*), 0, 0\);/DEFINE_TIMER($1);/g;' \
        $(git grep DEFINE_TIMER | cut -d: -f1 | sort -u | grep -v timer.h)
    
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Acked-by: Geert Uytterhoeven <geert@linux-m68k.org> # for m68k parts
    Acked-by: Guenter Roeck <linux@roeck-us.net> # for watchdog parts
    Acked-by: David S. Miller <davem@davemloft.net> # for networking parts
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Acked-by: Kalle Valo <kvalo@codeaurora.org> # for wireless parts
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Cc: linux-mips@linux-mips.org
    Cc: Petr Mladek <pmladek@suse.com>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Lai Jiangshan <jiangshanlai@gmail.com>
    Cc: Sebastian Reichel <sre@kernel.org>
    Cc: Kalle Valo <kvalo@qca.qualcomm.com>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Pavel Machek <pavel@ucw.cz>
    Cc: linux1394-devel@lists.sourceforge.net
    Cc: Chris Metcalf <cmetcalf@mellanox.com>
    Cc: linux-s390@vger.kernel.org
    Cc: linux-wireless@vger.kernel.org
    Cc: "James E.J. Bottomley" <jejb@linux.vnet.ibm.com>
    Cc: Wim Van Sebroeck <wim@iguana.be>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Ursula Braun <ubraun@linux.vnet.ibm.com>
    Cc: Viresh Kumar <viresh.kumar@linaro.org>
    Cc: Harish Patil <harish.patil@cavium.com>
    Cc: Stephen Boyd <sboyd@codeaurora.org>
    Cc: Michael Reed <mdr@sgi.com>
    Cc: Manish Chopra <manish.chopra@cavium.com>
    Cc: Len Brown <len.brown@intel.com>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: linux-pm@vger.kernel.org
    Cc: Heiko Carstens <heiko.carstens@de.ibm.com>
    Cc: Tejun Heo <tj@kernel.org>
    Cc: Julian Wiedmann <jwi@linux.vnet.ibm.com>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: Mark Gross <mark.gross@intel.com>
    Cc: linux-watchdog@vger.kernel.org
    Cc: linux-scsi@vger.kernel.org
    Cc: "Martin K. Petersen" <martin.petersen@oracle.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: "Rafael J. Wysocki" <rjw@rjwysocki.net>
    Cc: Oleg Nesterov <oleg@redhat.com>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: Stefan Richter <stefanr@s5r6.in-berlin.de>
    Cc: Guenter Roeck <linux@roeck-us.net>
    Cc: netdev@vger.kernel.org
    Cc: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: linuxppc-dev@lists.ozlabs.org
    Cc: Sudip Mukherjee <sudipm.mukherjee@gmail.com>
    Link: https://lkml.kernel.org/r/1507159627-127660-11-git-send-email-keescook@chromium.org
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/drivers/staging/speakup/synth.c b/drivers/staging/speakup/synth.c
index a1ca68c76579..6ddd3fc3f08d 100644
--- a/drivers/staging/speakup/synth.c
+++ b/drivers/staging/speakup/synth.c
@@ -158,7 +158,7 @@ static void thread_wake_up(u_long data)
 	wake_up_interruptible_all(&speakup_event);
 }
 
-static DEFINE_TIMER(thread_timer, thread_wake_up, 0, 0);
+static DEFINE_TIMER(thread_timer, thread_wake_up);
 
 void synth_start(void)
 {

commit e4dd8bca3d5153503c1c923feb5c056124ea56ae
Author: Okash Khawaja <okash.khawaja@gmail.com>
Date:   Tue Jun 20 11:07:32 2017 +0100

    staging: speakup: fix synth caching when synth init fails
    
    synths[] array caches currently loaded synths. synth_add checks
    synths[] before adding a new one. It however ignores the result of
    do_synth_init. So when do_synth_init fails, the failed synth is still
    cached. Since, as a result module loading fails too, synth_remove -
    which is responsible for removing the cached synth - is never called.
    Next time the failing synth is added again it succeeds because
    synth_add finds it cached inside synths[].
    
    This patch fixes this by caching a synth only after do_synth_init
    succeeds.
    
    Signed-off-by: Okash Khawaja <okash.khawaja@gmail.com>
    Reviewed-by: Samuel Thibault <samuel.thibault@ens-lyon.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/speakup/synth.c b/drivers/staging/speakup/synth.c
index 703553916097..a1ca68c76579 100644
--- a/drivers/staging/speakup/synth.c
+++ b/drivers/staging/speakup/synth.c
@@ -445,10 +445,15 @@ int synth_add(struct spk_synth *in_synth)
 		mutex_unlock(&spk_mutex);
 		return -1;
 	}
-	synths[i++] = in_synth;
-	synths[i] = NULL;
+
 	if (in_synth->startup)
 		status = do_synth_init(in_synth);
+
+	if (!status) {
+		synths[i++] = in_synth;
+		synths[i] = NULL;
+	}
+
 	mutex_unlock(&spk_mutex);
 	return status;
 }

commit 1c5973675cee92d5e8ad3a8a6e53a3e822bae271
Author: Okash Khawaja <okash.khawaja@gmail.com>
Date:   Mon May 15 18:45:37 2017 +0100

    staging: speakup: flush tty buffers and ensure hardware flow control
    
    This patch fixes the issue where TTY-migrated synths would take a while
    to shut up after hitting numpad enter key. When calling synth_flush,
    even though XOFF character is sent as high priority, data buffered in
    TTY layer is still sent to the synth. This patch flushes that buffered
    data when synth_flush is called.
    
    It also tries to ensure that hardware flow control is enabled, by
    setting CRTSCTS using tty's termios.
    
    Reported-by: John Covici <covici@ccs.covici.com>
    Signed-off-by: Okash Khawaja <okash.khawaja@gmail.com>
    Reviewed-by: Samuel Thibault <samuel.thibault@ens-lyon.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/speakup/synth.c b/drivers/staging/speakup/synth.c
index 9c2aa1b8b0ac..703553916097 100644
--- a/drivers/staging/speakup/synth.c
+++ b/drivers/staging/speakup/synth.c
@@ -120,6 +120,7 @@ EXPORT_SYMBOL_GPL(spk_do_catch_up);
 
 void spk_synth_flush(struct spk_synth *synth)
 {
+	synth->io_ops->flush_buffer();
 	synth->io_ops->synth_out(synth, synth->clear);
 }
 EXPORT_SYMBOL_GPL(spk_synth_flush);

commit ca693dcd5c02645063210e2352ff4909d9ddc7e9
Author: Okash Khawaja <okash.khawaja@gmail.com>
Date:   Sat Apr 29 20:52:58 2017 +0100

    staging: speakup: make input functionality swappable
    
    This moves functions which take input from external synth, into struct
    spk_io_ops. The calling code then uses serial implementation of those methods
    through spk_io_ops. That way we can add a parallel TTY-based implementation and
    simply replace serial with TTY. That is what the next patch in this series does.
    
    speakup_decext.c has get_last_char function which reads the most recent
    available character from the synth. This patch changes that by defining
    read_buff_add callback method of spk_syth and letting that update the last_char
    global character read from the synth. read_buff_add is called from ISR, so
    there is a possibility for last_char to be stale. Therefore it is marked as
    volatile. It also pulls a repeated get_index implementation into synth.c, to
    be used as a utility function.
    
    Signed-off-by: Okash Khawaja <okash.khawaja@gmail.com>
    Reviewed-by: Samuel Thibault <samuel.thibault@ens-lyon.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/speakup/synth.c b/drivers/staging/speakup/synth.c
index 352e9eebc3de..9c2aa1b8b0ac 100644
--- a/drivers/staging/speakup/synth.c
+++ b/drivers/staging/speakup/synth.c
@@ -124,6 +124,12 @@ void spk_synth_flush(struct spk_synth *synth)
 }
 EXPORT_SYMBOL_GPL(spk_synth_flush);
 
+unsigned char spk_synth_get_index(struct spk_synth *synth)
+{
+	return synth->io_ops->synth_in_nowait();
+}
+EXPORT_SYMBOL_GPL(spk_synth_get_index);
+
 int spk_synth_is_alive_nop(struct spk_synth *synth)
 {
 	synth->alive = 1;
@@ -249,7 +255,7 @@ void spk_reset_index_count(int sc)
 	if (first)
 		first = 0;
 	else
-		synth->get_index();
+		synth->get_index(synth);
 	index_count = 0;
 	sentence_count = sc;
 }
@@ -282,7 +288,7 @@ void synth_insert_next_index(int sent_num)
 
 void spk_get_index_count(int *linecount, int *sentcount)
 {
-	int ind = synth->get_index();
+	int ind = synth->get_index(synth);
 
 	if (ind) {
 		sentence_count = ind % 10;

commit 98c1fda752b604c68f2d7c9a0e10c6aaa3bd2a17
Author: Okash Khawaja <okash.khawaja@gmail.com>
Date:   Thu Mar 16 08:10:17 2017 +0000

    staging: speakup: move those functions which do outgoing serial comms, into serialio.c
    
    This moves spk_synth_immediate and spk_serial_synth_probe functions into
    serialio.c. These functions do outgoing serial comms. The move is a step
    towards collecting all serial comms in serialio.c. This also renames
    spk_synth_immediate to spk_serial_synth_immediate.
    
    Code inside those functions has not been changed. Along the way, this patch
    also fixes a couple of spots which were calling spk_synth_immediate directly,
    so that the calls now happen via the spk_syth struct.
    
    Signed-off-by: Okash Khawaja <okash.khawaja@gmail.com>
    
    Reviewed-by: Samuel Thibault <samuel.thibault@ens-lyon.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/speakup/synth.c b/drivers/staging/speakup/synth.c
index 989681dcb710..352e9eebc3de 100644
--- a/drivers/staging/speakup/synth.c
+++ b/drivers/staging/speakup/synth.c
@@ -44,35 +44,6 @@ EXPORT_SYMBOL_GPL(speakup_info);
 
 static int do_synth_init(struct spk_synth *in_synth);
 
-int spk_serial_synth_probe(struct spk_synth *synth)
-{
-	const struct old_serial_port *ser;
-	int failed = 0;
-
-	if ((synth->ser >= SPK_LO_TTY) && (synth->ser <= SPK_HI_TTY)) {
-		ser = spk_serial_init(synth->ser);
-		if (!ser) {
-			failed = -1;
-		} else {
-			outb_p(0, ser->port);
-			mdelay(1);
-			outb_p('\r', ser->port);
-		}
-	} else {
-		failed = -1;
-		pr_warn("ttyS%i is an invalid port\n", synth->ser);
-	}
-	if (failed) {
-		pr_info("%s: not found\n", synth->long_name);
-		return -ENODEV;
-	}
-	pr_info("%s: ttyS%i, Driver Version %s\n",
-		synth->long_name, synth->ser, synth->version);
-	synth->alive = 1;
-	return 0;
-}
-EXPORT_SYMBOL_GPL(spk_serial_synth_probe);
-
 /*
  * Main loop of the progression thread: keep eating from the buffer
  * and push to the serial port, waiting as needed
@@ -147,23 +118,6 @@ void spk_do_catch_up(struct spk_synth *synth)
 }
 EXPORT_SYMBOL_GPL(spk_do_catch_up);
 
-const char *spk_synth_immediate(struct spk_synth *synth, const char *buff)
-{
-	u_char ch;
-
-	while ((ch = *buff)) {
-		if (ch == '\n')
-			ch = synth->procspeech;
-		if (spk_wait_for_xmitr(synth))
-			outb(ch, speakup_info.port_tts);
-		else
-			return buff;
-		buff++;
-	}
-	return NULL;
-}
-EXPORT_SYMBOL_GPL(spk_synth_immediate);
-
 void spk_synth_flush(struct spk_synth *synth)
 {
 	synth->io_ops->synth_out(synth, synth->clear);

commit a50ef3165489c74c7d7c9f7559d9bbb198dca154
Author: Okash Khawaja <okash.khawaja@gmail.com>
Date:   Tue Mar 14 13:41:54 2017 +0000

    staging: speakup: move spk_stop_serial_interrupt into synth-specific release function
    
    This moves call to spk_stop_serial_interrupt() function out of synth_release()
    and into release() method of specific spk_synth instances. This is because
    the spk_stop_serial_interrupt() call is specific to current serial i/o
    implementation. Moving it into each synth's release() method gives the
    decision of calling  spk_stop_serial_interrupt() to that synth.
    
    Signed-off-by: Okash Khawaja <okash.khawaja@gmail.com>
    Reviewed-by: Samuel Thibault <samuel.thibault@ens-lyon.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/speakup/synth.c b/drivers/staging/speakup/synth.c
index 72d4f027e40a..989681dcb710 100644
--- a/drivers/staging/speakup/synth.c
+++ b/drivers/staging/speakup/synth.c
@@ -462,7 +462,6 @@ void synth_release(void)
 		sysfs_remove_group(speakup_kobj, &synth->attributes);
 	for (var = synth->vars; var->var_id != MAXVARS; var++)
 		speakup_unregister_var(var->var_id);
-	spk_stop_serial_interrupt();
 	synth->release();
 	synth = NULL;
 }

commit 1e441594e509c35a222e397d224de17cee103740
Author: Okash Khawaja <okash.khawaja@gmail.com>
Date:   Tue Mar 14 13:41:53 2017 +0000

    staging: speakup: add spk_io_ops struct to spk_synth
    
    This patch adds spk_io_ops struct which contain those methods whose job is to
    communicate with synth device. Currently, all comms with external synth
    device use raw serial i/o. The idea is to group all methods which do the
    actual communication with external device into this new struct. Then migrating
    a serial-based synth over to an alternative to raw serial i/o will mean
    swapping serial spk_io_ops instance with the io_ops instance of the new
    method, making the migration simpler.
    
    At the moment, this struct only contains one method, synth_out but more will
    be added in future when migrating synths which require input functionality.
    Also at the moment, synth_out method has one implementation which uses
    serial i/o. Plan is to add an alternative.
    
    Signed-off-by: Okash Khawaja <okash.khawaja@gmail.com>
    Reviewed-by: Samuel Thibault <samuel.thibault@ens-lyon.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/speakup/synth.c b/drivers/staging/speakup/synth.c
index 41967c9e5003..72d4f027e40a 100644
--- a/drivers/staging/speakup/synth.c
+++ b/drivers/staging/speakup/synth.c
@@ -120,7 +120,7 @@ void spk_do_catch_up(struct spk_synth *synth)
 		spin_unlock_irqrestore(&speakup_info.spinlock, flags);
 		if (ch == '\n')
 			ch = synth->procspeech;
-		if (!spk_serial_out(synth, ch)) {
+		if (!synth->io_ops->synth_out(synth, ch)) {
 			schedule_timeout(msecs_to_jiffies(full_time_val));
 			continue;
 		}
@@ -130,7 +130,7 @@ void spk_do_catch_up(struct spk_synth *synth)
 			delay_time_val = delay_time->u.n.value;
 			full_time_val = full_time->u.n.value;
 			spin_unlock_irqrestore(&speakup_info.spinlock, flags);
-			if (spk_serial_out(synth, synth->procspeech))
+			if (synth->io_ops->synth_out(synth, synth->procspeech))
 				schedule_timeout(
 					msecs_to_jiffies(delay_time_val));
 			else
@@ -143,7 +143,7 @@ void spk_do_catch_up(struct spk_synth *synth)
 		synth_buffer_getc();
 		spin_unlock_irqrestore(&speakup_info.spinlock, flags);
 	}
-	spk_serial_out(synth, synth->procspeech);
+	synth->io_ops->synth_out(synth, synth->procspeech);
 }
 EXPORT_SYMBOL_GPL(spk_do_catch_up);
 
@@ -166,7 +166,7 @@ EXPORT_SYMBOL_GPL(spk_synth_immediate);
 
 void spk_synth_flush(struct spk_synth *synth)
 {
-	spk_serial_out(synth, synth->clear);
+	synth->io_ops->synth_out(synth, synth->clear);
 }
 EXPORT_SYMBOL_GPL(spk_synth_flush);
 

commit 9176d156ca8d931bec0bf5fa3239524d94da866a
Author: Okash Khawaja <okash.khawaja@gmail.com>
Date:   Tue Mar 14 13:41:52 2017 +0000

    staging: speakup: spk_serial_out and spk_wait_for_xmitr to take synth arg
    
    These two functions are always called from a context where spk_synth instance
    is available. They also use the spk_synth instance but instead of taking it
    as an argument, they rely on a global spk_synth instance inside synth.c which
    points to the same synth as the one being passed in as argument.
    
    Signed-off-by: Okash Khawaja <okash.khawaja@gmail.com>
    Reviewed-by: Samuel Thibault <samuel.thibault@ens-lyon.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/speakup/synth.c b/drivers/staging/speakup/synth.c
index 4d59917a2961..41967c9e5003 100644
--- a/drivers/staging/speakup/synth.c
+++ b/drivers/staging/speakup/synth.c
@@ -120,7 +120,7 @@ void spk_do_catch_up(struct spk_synth *synth)
 		spin_unlock_irqrestore(&speakup_info.spinlock, flags);
 		if (ch == '\n')
 			ch = synth->procspeech;
-		if (!spk_serial_out(ch)) {
+		if (!spk_serial_out(synth, ch)) {
 			schedule_timeout(msecs_to_jiffies(full_time_val));
 			continue;
 		}
@@ -130,7 +130,7 @@ void spk_do_catch_up(struct spk_synth *synth)
 			delay_time_val = delay_time->u.n.value;
 			full_time_val = full_time->u.n.value;
 			spin_unlock_irqrestore(&speakup_info.spinlock, flags);
-			if (spk_serial_out(synth->procspeech))
+			if (spk_serial_out(synth, synth->procspeech))
 				schedule_timeout(
 					msecs_to_jiffies(delay_time_val));
 			else
@@ -143,7 +143,7 @@ void spk_do_catch_up(struct spk_synth *synth)
 		synth_buffer_getc();
 		spin_unlock_irqrestore(&speakup_info.spinlock, flags);
 	}
-	spk_serial_out(synth->procspeech);
+	spk_serial_out(synth, synth->procspeech);
 }
 EXPORT_SYMBOL_GPL(spk_do_catch_up);
 
@@ -154,7 +154,7 @@ const char *spk_synth_immediate(struct spk_synth *synth, const char *buff)
 	while ((ch = *buff)) {
 		if (ch == '\n')
 			ch = synth->procspeech;
-		if (spk_wait_for_xmitr())
+		if (spk_wait_for_xmitr(synth))
 			outb(ch, speakup_info.port_tts);
 		else
 			return buff;
@@ -166,7 +166,7 @@ EXPORT_SYMBOL_GPL(spk_synth_immediate);
 
 void spk_synth_flush(struct spk_synth *synth)
 {
-	spk_serial_out(synth->clear);
+	spk_serial_out(synth, synth->clear);
 }
 EXPORT_SYMBOL_GPL(spk_synth_flush);
 
@@ -181,7 +181,7 @@ int spk_synth_is_alive_restart(struct spk_synth *synth)
 {
 	if (synth->alive)
 		return 1;
-	if (spk_wait_for_xmitr() > 0) {
+	if (spk_wait_for_xmitr(synth) > 0) {
 		/* restart */
 		synth->alive = 1;
 		synth_printf("%s", synth->init);

commit 89fc2ae80bb1eeca1d967723c1918c0b156508a0
Author: Samuel Thibault <samuel.thibault@ens-lyon.org>
Date:   Sat Mar 4 15:01:55 2017 +0100

    speakup: extend synth buffer to 16bit unicode characters
    
    This extends the synth buffer slots to 16bit, so as to hold 16bit
    unicode characters.
    
    synth_buffer_getc and synth_buffer_peek now return 16bit characters.
    Speech synthesizers which do not support characters beyond latin1 can
    use the synth_buffer_skip_nonlatin1() helper to skip the non-latin1
    characters before getting or peeking. All synthesizers are made to use
    it for now.
    
    This makes synth_buffer_add take a 16bit character. For simplicity for
    now, synth_printf is left to using latin1 formats and strings.
    synth_putwc, synth_putwc_s, synth_putws and synth_putws_s helpers are
    however added to put 16bit characters and strings.
    
    Signed-off-by: Samuel Thibault <samuel.thibault@ens-lyon.org>
    Reviewed-by: Chris Brannon <chris@the-brannons.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/speakup/synth.c b/drivers/staging/speakup/synth.c
index 8340748ae9cb..4d59917a2961 100644
--- a/drivers/staging/speakup/synth.c
+++ b/drivers/staging/speakup/synth.c
@@ -109,6 +109,7 @@ void spk_do_catch_up(struct spk_synth *synth)
 			synth->flush(synth);
 			continue;
 		}
+		synth_buffer_skip_nonlatin1();
 		if (synth_buffer_empty()) {
 			spin_unlock_irqrestore(&speakup_info.spinlock, flags);
 			break;
@@ -255,6 +256,35 @@ void synth_printf(const char *fmt, ...)
 }
 EXPORT_SYMBOL_GPL(synth_printf);
 
+void synth_putwc(u16 wc)
+{
+	synth_buffer_add(wc);
+}
+EXPORT_SYMBOL_GPL(synth_putwc);
+
+void synth_putwc_s(u16 wc)
+{
+	synth_buffer_add(wc);
+	synth_start();
+}
+EXPORT_SYMBOL_GPL(synth_putwc_s);
+
+void synth_putws(const u16 *buf)
+{
+	const u16 *p;
+
+	for (p = buf; *p; p++)
+		synth_buffer_add(*p);
+}
+EXPORT_SYMBOL_GPL(synth_putws);
+
+void synth_putws_s(const u16 *buf)
+{
+	synth_putws(buf);
+	synth_start();
+}
+EXPORT_SYMBOL_GPL(synth_putws_s);
+
 static int index_count;
 static int sentence_count;
 

commit 904cf12dd3c6a1b5fd1166d73584509cb505eaf1
Author: Olav Haugan <ohaugan@codeaurora.org>
Date:   Thu Feb 16 21:08:32 2017 -0800

    staging: speakup: (coding style) Limit line to 80 chars
    
    Fix checkpatch warning about line being over 80 characters.
    
    Signed-off-by: Olav Haugan <ohaugan@codeaurora.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/speakup/synth.c b/drivers/staging/speakup/synth.c
index b57315110e67..8340748ae9cb 100644
--- a/drivers/staging/speakup/synth.c
+++ b/drivers/staging/speakup/synth.c
@@ -406,8 +406,8 @@ static int do_synth_init(struct spk_synth *in_synth)
 		speakup_register_var(var);
 	if (!spk_quiet_boot)
 		synth_printf("%s found\n", synth->long_name);
-	if (synth->attributes.name && sysfs_create_group(speakup_kobj,
-							 &synth->attributes) < 0)
+	if (synth->attributes.name &&
+	    sysfs_create_group(speakup_kobj, &synth->attributes) < 0)
 		return -ENOMEM;
 	synth_flags = synth->flags;
 	wake_up_interruptible_all(&speakup_event);

commit 2ffb795f4cc5c35eb576fb055fe279a1327473a9
Author: Olav Haugan <ohaugan@codeaurora.org>
Date:   Thu Feb 16 21:08:31 2017 -0800

    staging: speakup: (coding style) Simplify comparisons to NULL
    
    Fix checkpatch check notices by simplifying comparisons to NULL.
    
    Signed-off-by: Olav Haugan <ohaugan@codeaurora.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/speakup/synth.c b/drivers/staging/speakup/synth.c
index a61c02ba06da..b57315110e67 100644
--- a/drivers/staging/speakup/synth.c
+++ b/drivers/staging/speakup/synth.c
@@ -51,7 +51,7 @@ int spk_serial_synth_probe(struct spk_synth *synth)
 
 	if ((synth->ser >= SPK_LO_TTY) && (synth->ser <= SPK_HI_TTY)) {
 		ser = spk_serial_init(synth->ser);
-		if (ser == NULL) {
+		if (!ser) {
 			failed = -1;
 		} else {
 			outb_p(0, ser->port);
@@ -272,7 +272,7 @@ void spk_reset_index_count(int sc)
 
 int synth_supports_indexing(void)
 {
-	if (synth->get_index != NULL)
+	if (synth->get_index)
 		return 1;
 	return 0;
 }
@@ -350,7 +350,7 @@ int synth_init(char *synth_name)
 	int ret = 0;
 	struct spk_synth *synth = NULL;
 
-	if (synth_name == NULL)
+	if (!synth_name)
 		return 0;
 
 	if (strcmp(synth_name, "none") == 0) {
@@ -362,7 +362,7 @@ int synth_init(char *synth_name)
 
 	mutex_lock(&spk_mutex);
 	/* First, check if we already have it loaded. */
-	for (i = 0; i < MAXSYNTHS && synths[i] != NULL; i++)
+	for (i = 0; i < MAXSYNTHS && synths[i]; i++)
 		if (strcmp(synths[i]->name, synth_name) == 0)
 			synth = synths[i];
 
@@ -421,7 +421,7 @@ void synth_release(void)
 	struct var_t *var;
 	unsigned long flags;
 
-	if (synth == NULL)
+	if (!synth)
 		return;
 	spin_lock_irqsave(&speakup_info.spinlock, flags);
 	pr_info("releasing synth %s\n", synth->name);
@@ -444,7 +444,7 @@ int synth_add(struct spk_synth *in_synth)
 	int status = 0;
 
 	mutex_lock(&spk_mutex);
-	for (i = 0; i < MAXSYNTHS && synths[i] != NULL; i++)
+	for (i = 0; i < MAXSYNTHS && synths[i]; i++)
 		/* synth_remove() is responsible for rotating the array down */
 		if (in_synth == synths[i]) {
 			mutex_unlock(&spk_mutex);
@@ -471,11 +471,11 @@ void synth_remove(struct spk_synth *in_synth)
 	mutex_lock(&spk_mutex);
 	if (synth == in_synth)
 		synth_release();
-	for (i = 0; synths[i] != NULL; i++) {
+	for (i = 0; synths[i]; i++) {
 		if (in_synth == synths[i])
 			break;
 	}
-	for ( ; synths[i] != NULL; i++) /* compress table */
+	for ( ; synths[i]; i++) /* compress table */
 		synths[i] = synths[i + 1];
 	module_status = 0;
 	mutex_unlock(&spk_mutex);

commit 020f95cb51039fbb34a23828f7f6ef1b14be725a
Author: Walt Feasel <waltfeasel@gmail.com>
Date:   Sat Nov 19 12:35:47 2016 -0500

    staging: speakup: synth.c Align parenthesis
    
    Make suggested checkpatch modification for
    CHECK: Alignment should match open parenthesis
    
    Signed-off-by: Walt Feasel <waltfeasel@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/speakup/synth.c b/drivers/staging/speakup/synth.c
index 1bd78abce7e6..a61c02ba06da 100644
--- a/drivers/staging/speakup/synth.c
+++ b/drivers/staging/speakup/synth.c
@@ -67,7 +67,7 @@ int spk_serial_synth_probe(struct spk_synth *synth)
 		return -ENODEV;
 	}
 	pr_info("%s: ttyS%i, Driver Version %s\n",
-			synth->long_name, synth->ser, synth->version);
+		synth->long_name, synth->ser, synth->version);
 	synth->alive = 1;
 	return 0;
 }

commit d2ad9a8255064e30e785f9c1f5757c4308b6ba6a
Author: Walt Feasel <waltfeasel@gmail.com>
Date:   Sat Nov 19 12:35:46 2016 -0500

    staging: speakup: synth.c Comment modifications
    
    Make modifications to comment style
    
    Signed-off-by: Walt Feasel <waltfeasel@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/speakup/synth.c b/drivers/staging/speakup/synth.c
index f79dc4c81472..1bd78abce7e6 100644
--- a/drivers/staging/speakup/synth.c
+++ b/drivers/staging/speakup/synth.c
@@ -8,7 +8,7 @@
 #include <linux/delay.h>	/* for loops_per_sec */
 #include <linux/kmod.h>
 #include <linux/jiffies.h>
-#include <linux/uaccess.h> /* for copy_from_user */
+#include <linux/uaccess.h>	/* for copy_from_user */
 #include <linux/sched.h>
 #include <linux/timer.h>
 #include <linux/kthread.h>
@@ -73,7 +73,8 @@ int spk_serial_synth_probe(struct spk_synth *synth)
 }
 EXPORT_SYMBOL_GPL(spk_serial_synth_probe);
 
-/* Main loop of the progression thread: keep eating from the buffer
+/*
+ * Main loop of the progression thread: keep eating from the buffer
  * and push to the serial port, waiting as needed
  *
  * For devices that have a "full" notification mechanism, the driver can

commit eaf40ad456bc9c7e3c6eb539a3cab3e9a6a335d3
Author: Walt Feasel <waltfeasel@gmail.com>
Date:   Sat Nov 19 12:35:45 2016 -0500

    staging: speakup: synth.c Logical continuation
    
    Make suggested checkpatch modification for
    CHECK: Logical continuations should be on the
    previous line
    
    Signed-off-by: Walt Feasel <waltfeasel@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/speakup/synth.c b/drivers/staging/speakup/synth.c
index 7940807b0577..f79dc4c81472 100644
--- a/drivers/staging/speakup/synth.c
+++ b/drivers/staging/speakup/synth.c
@@ -405,8 +405,8 @@ static int do_synth_init(struct spk_synth *in_synth)
 		speakup_register_var(var);
 	if (!spk_quiet_boot)
 		synth_printf("%s found\n", synth->long_name);
-	if (synth->attributes.name
-	&& sysfs_create_group(speakup_kobj, &synth->attributes) < 0)
+	if (synth->attributes.name && sysfs_create_group(speakup_kobj,
+							 &synth->attributes) < 0)
 		return -ENOMEM;
 	synth_flags = synth->flags;
 	wake_up_interruptible_all(&speakup_event);

commit 99f01137b79c438675816e441fe37ba548f65717
Author: Walt Feasel <waltfeasel@gmail.com>
Date:   Sat Nov 19 12:35:44 2016 -0500

    staging: speakup: synth.c Blank line before }
    
    Make suggested checkpatch modification for
    CHECK: Blank lines aren't necessary before a close brace '}'
    
    Signed-off-by: Walt Feasel <waltfeasel@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/speakup/synth.c b/drivers/staging/speakup/synth.c
index 17aa44003aa8..7940807b0577 100644
--- a/drivers/staging/speakup/synth.c
+++ b/drivers/staging/speakup/synth.c
@@ -308,7 +308,6 @@ void spk_get_index_count(int *linecount, int *sentcount)
 			index_count = synth->indexing.currindex
 				- synth->indexing.lowindex
 				+ synth->indexing.highindex - (ind / 10) + 1;
-
 	}
 	*sentcount = sentence_count;
 	*linecount = index_count;

commit c67095cec558ee7893b034dec70f887310f497d3
Author: Walt Feasel <waltfeasel@gmail.com>
Date:   Sat Nov 19 14:34:35 2016 -0500

    staging: speakup: synth.c Spaces around operators
    
    Make suggested checkpatch modification for
    CHECK: spaces preferred around that '|,+,-,/'
    
    Signed-off-by: Walt Feasel <waltfeasel@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/speakup/synth.c b/drivers/staging/speakup/synth.c
index 54b2f3918628..17aa44003aa8 100644
--- a/drivers/staging/speakup/synth.c
+++ b/drivers/staging/speakup/synth.c
@@ -303,11 +303,11 @@ void spk_get_index_count(int *linecount, int *sentcount)
 		sentence_count = ind % 10;
 
 		if ((ind / 10) <= synth->indexing.currindex)
-			index_count = synth->indexing.currindex-(ind/10);
+			index_count = synth->indexing.currindex - (ind / 10);
 		else
 			index_count = synth->indexing.currindex
-				-synth->indexing.lowindex
-				+ synth->indexing.highindex-(ind/10)+1;
+				- synth->indexing.lowindex
+				+ synth->indexing.highindex - (ind / 10) + 1;
 
 	}
 	*sentcount = sentence_count;
@@ -476,10 +476,10 @@ void synth_remove(struct spk_synth *in_synth)
 			break;
 	}
 	for ( ; synths[i] != NULL; i++) /* compress table */
-		synths[i] = synths[i+1];
+		synths[i] = synths[i + 1];
 	module_status = 0;
 	mutex_unlock(&spk_mutex);
 }
 EXPORT_SYMBOL_GPL(synth_remove);
 
-short spk_punc_masks[] = { 0, SOME, MOST, PUNC, PUNC|B_SYM };
+short spk_punc_masks[] = { 0, SOME, MOST, PUNC, PUNC | B_SYM };

commit 3adc4aae0e597a7cdcb9ed3f99d0933bf9a4aaa6
Author: Katie Dunne <kdunne@mail.ccsf.edu>
Date:   Wed Sep 21 15:13:20 2016 -0700

    staging: speakup: Remove unnecessary parentheses
    
    Issue found by checkpatch.
    
    Signed-off-by: Katie Dunne <kdunne@mail.ccsf.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/speakup/synth.c b/drivers/staging/speakup/synth.c
index 810a21408715..54b2f3918628 100644
--- a/drivers/staging/speakup/synth.c
+++ b/drivers/staging/speakup/synth.c
@@ -407,7 +407,7 @@ static int do_synth_init(struct spk_synth *in_synth)
 	if (!spk_quiet_boot)
 		synth_printf("%s found\n", synth->long_name);
 	if (synth->attributes.name
-	&& sysfs_create_group(speakup_kobj, &(synth->attributes)) < 0)
+	&& sysfs_create_group(speakup_kobj, &synth->attributes) < 0)
 		return -ENOMEM;
 	synth_flags = synth->flags;
 	wake_up_interruptible_all(&speakup_event);
@@ -429,7 +429,7 @@ void synth_release(void)
 	del_timer(&thread_timer);
 	spin_unlock_irqrestore(&speakup_info.spinlock, flags);
 	if (synth->attributes.name)
-		sysfs_remove_group(speakup_kobj, &(synth->attributes));
+		sysfs_remove_group(speakup_kobj, &synth->attributes);
 	for (var = synth->vars; var->var_id != MAXVARS; var++)
 		speakup_unregister_var(var->var_id);
 	spk_stop_serial_interrupt();

commit 99a9ffacc1d390e9548b2370beb816c6739b84b2
Author: Colin Ian King <colin.king@canonical.com>
Date:   Mon May 9 23:22:14 2016 +0100

    staging: speakup: ensure we do not overrun synths array
    
    synth_add allows one to add MAXSYNTHS synths to the synths array;
    however it always NULLifies the next synth in the array which
    means that on the MAXSYNTHS synth we get an out-of-bounds write of
    the NULL to the synths array.  Make the synths array MAXSYNTHS + 1
    elements in size to allow for the final NULL sentinal to avoid the
    out-of-bounds write.
    
    Issue found wit CoverityScan, CID#744671
    
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Reviewed-by: Samuel Thibault <samuel.thibault@ens-lyon.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/speakup/synth.c b/drivers/staging/speakup/synth.c
index 4f462c35fdd9..810a21408715 100644
--- a/drivers/staging/speakup/synth.c
+++ b/drivers/staging/speakup/synth.c
@@ -18,7 +18,7 @@
 #include "serialio.h"
 
 #define MAXSYNTHS       16      /* Max number of synths in array. */
-static struct spk_synth *synths[MAXSYNTHS];
+static struct spk_synth *synths[MAXSYNTHS + 1];
 struct spk_synth *synth;
 char spk_pitch_buff[32] = "";
 static int module_status;

commit d6e29ca1f6cf566f67012dce269b5f9ba72a1659
Author: Amitoj Kaur Chawla <amitoj1606@gmail.com>
Date:   Wed Feb 24 20:54:28 2016 +0530

    staging: speakup: Remove unnecessary test in if condition
    
    Remove unnecessary test on synth->alive since it has already been
    tested previously.
    
    This fixes the following smatch warning:
    drivers/staging/speakup/synth.c:182 spk_synth_is_alive_restart() warn:
    we tested 'synth->alive' before and it was 'false'
    
    Signed-off-by: Amitoj Kaur Chawla <amitoj1606@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/speakup/synth.c b/drivers/staging/speakup/synth.c
index 01eddab93c66..4f462c35fdd9 100644
--- a/drivers/staging/speakup/synth.c
+++ b/drivers/staging/speakup/synth.c
@@ -179,7 +179,7 @@ int spk_synth_is_alive_restart(struct spk_synth *synth)
 {
 	if (synth->alive)
 		return 1;
-	if (!synth->alive && spk_wait_for_xmitr() > 0) {
+	if (spk_wait_for_xmitr() > 0) {
 		/* restart */
 		synth->alive = 1;
 		synth_printf("%s", synth->init);

commit 05719ac7d5684cc23967320ae3a4e90e496bd9f6
Author: Panir.Nyan <panir.nyan@gmail.com>
Date:   Wed Dec 24 04:07:31 2014 +0000

    staging: speakup: Split the comment to fit the length
    
    Split the comment to fit the length.
    
    Signed-off-by: Panir Nyan <Panir.Nyan@gmail.com>
    Acked-by: Samuel Thibault <samuel.thibault@ens-lyon.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/speakup/synth.c b/drivers/staging/speakup/synth.c
index f3aa4239dc68..01eddab93c66 100644
--- a/drivers/staging/speakup/synth.c
+++ b/drivers/staging/speakup/synth.c
@@ -30,9 +30,9 @@ struct speakup_info_t speakup_info = {
 	 * must be taken at each kernel->speakup transition and released at
 	 * each corresponding speakup->kernel transition.
 	 *
-	 * The progression thread only interferes with the speakup machinery through
-	 * the synth buffer, so only needs to take the lock while tinkering with
-	 * the buffer.
+	 * The progression thread only interferes with the speakup machinery
+	 * through the synth buffer, so only needs to take the lock
+	 * while tinkering with the buffer.
 	 *
 	 * We use spin_lock/trylock_irqsave and spin_unlock_irqrestore with this
 	 * spinlock because speakup needs to disable the keyboard IRQ.

commit 89021ecc8364e727a24b0683a74515c8ddf308db
Author: Tapasweni Pathak <tapaswenipathak@gmail.com>
Date:   Sun Sep 21 19:22:51 2014 +0530

    staging: speakup: remove jiffies comparison using time_after_eq()
    
    This patch fixes checkpatch.pl warning in files of speakup
    WARNING : Comparing jiffies is almost always wrong; prefer time_after,
    time_before and friends
    
    Signed-off-by: Tapasweni Pathak <tapaswenipathak@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/speakup/synth.c b/drivers/staging/speakup/synth.c
index 4c47b6d06a9f..f3aa4239dc68 100644
--- a/drivers/staging/speakup/synth.c
+++ b/drivers/staging/speakup/synth.c
@@ -122,7 +122,7 @@ void spk_do_catch_up(struct spk_synth *synth)
 			schedule_timeout(msecs_to_jiffies(full_time_val));
 			continue;
 		}
-		if ((jiffies >= jiff_max) && (ch == SPACE)) {
+		if (time_after_eq(jiffies, jiff_max) && (ch == SPACE)) {
 			spin_lock_irqsave(&speakup_info.spinlock, flags);
 			jiffy_delta_val = jiffy_delta->u.n.value;
 			delay_time_val = delay_time->u.n.value;

commit 8e69a8110686572a4b88d006faa8c3c759c4c261
Author: Domagoj Trsan <domagoj.trsan@gmail.com>
Date:   Tue Sep 9 20:04:34 2014 +0200

    staging: speakup: fix missing blank lines after declarations
    
    Signed-off-by: Domagoj Trsan <domagoj.trsan@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/speakup/synth.c b/drivers/staging/speakup/synth.c
index 172cf62b1aaf..4c47b6d06a9f 100644
--- a/drivers/staging/speakup/synth.c
+++ b/drivers/staging/speakup/synth.c
@@ -148,6 +148,7 @@ EXPORT_SYMBOL_GPL(spk_do_catch_up);
 const char *spk_synth_immediate(struct spk_synth *synth, const char *buff)
 {
 	u_char ch;
+
 	while ((ch = *buff)) {
 		if (ch == '\n')
 			ch = synth->procspeech;
@@ -259,6 +260,7 @@ static int sentence_count;
 void spk_reset_index_count(int sc)
 {
 	static int first = 1;
+
 	if (first)
 		first = 0;
 	else
@@ -277,6 +279,7 @@ int synth_supports_indexing(void)
 void synth_insert_next_index(int sent_num)
 {
 	int out;
+
 	if (synth->alive) {
 		if (sent_num == 0) {
 			synth->indexing.currindex++;
@@ -295,6 +298,7 @@ void synth_insert_next_index(int sent_num)
 void spk_get_index_count(int *linecount, int *sentcount)
 {
 	int ind = synth->get_index();
+
 	if (ind) {
 		sentence_count = ind % 10;
 
@@ -315,6 +319,7 @@ static struct resource synth_res;
 int synth_request_region(unsigned long start, unsigned long n)
 {
 	struct resource *parent = &ioport_resource;
+
 	memset(&synth_res, 0, sizeof(synth_res));
 	synth_res.name = synth->name;
 	synth_res.start = start;
@@ -437,6 +442,7 @@ int synth_add(struct spk_synth *in_synth)
 {
 	int i;
 	int status = 0;
+
 	mutex_lock(&spk_mutex);
 	for (i = 0; i < MAXSYNTHS && synths[i] != NULL; i++)
 		/* synth_remove() is responsible for rotating the array down */
@@ -461,6 +467,7 @@ EXPORT_SYMBOL_GPL(synth_add);
 void synth_remove(struct spk_synth *in_synth)
 {
 	int i;
+
 	mutex_lock(&spk_mutex);
 	if (synth == in_synth)
 		synth_release();

commit 8b9c012a425b23c1df52cc1ddfec8259035c6754
Author: Sasha Levin <sasha.levin@oracle.com>
Date:   Tue May 27 19:08:36 2014 -0400

    Staging: speakup: don't die if accessing sysfs without synth
    
    Setting a 'silent' parameter without a synth would crash the kernel.
    
    Signed-off-by: Sasha Levin <sasha.levin@oracle.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/speakup/synth.c b/drivers/staging/speakup/synth.c
index 0b3549bd909d..172cf62b1aaf 100644
--- a/drivers/staging/speakup/synth.c
+++ b/drivers/staging/speakup/synth.c
@@ -212,6 +212,9 @@ void synth_start(void)
 
 void spk_do_flush(void)
 {
+	if (!synth)
+		return;
+
 	speakup_info.flushing = 1;
 	synth_buffer_clear();
 	if (synth->alive) {

commit 4e595c0d23ff7bf3ae738c3ed563162fcc20678e
Author: Sachin Kamat <sachin.kamat@linaro.org>
Date:   Mon May 13 16:08:55 2013 +0530

    Staging: speakup: Fix return value in synth.c
    
    The function return type is a pointer. Hence return NULL instead
    of 0.
    
    Signed-off-by: Sachin Kamat <sachin.kamat@linaro.org>
    Acked-by: Samuel Thibault <samuel.thibault@ens-lyon.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/speakup/synth.c b/drivers/staging/speakup/synth.c
index e2d84c090d64..0b3549bd909d 100644
--- a/drivers/staging/speakup/synth.c
+++ b/drivers/staging/speakup/synth.c
@@ -157,7 +157,7 @@ const char *spk_synth_immediate(struct spk_synth *synth, const char *buff)
 			return buff;
 		buff++;
 	}
-	return 0;
+	return NULL;
 }
 EXPORT_SYMBOL_GPL(spk_synth_immediate);
 

commit 667b614118b3bae7d2a82732cdde71730a3d080c
Author: William Hubbs <w.d.hubbs@gmail.com>
Date:   Mon May 13 13:31:40 2013 -0500

    staging: speakup: remove custom locking macro definitions
    
    Signed-off-by: William Hubbs <w.d.hubbs@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/speakup/synth.c b/drivers/staging/speakup/synth.c
index 1036f47b9464..e2d84c090d64 100644
--- a/drivers/staging/speakup/synth.c
+++ b/drivers/staging/speakup/synth.c
@@ -25,6 +25,18 @@ static int module_status;
 bool spk_quiet_boot;
 
 struct speakup_info_t speakup_info = {
+	/*
+	 * This spinlock is used to protect the entire speakup machinery, and
+	 * must be taken at each kernel->speakup transition and released at
+	 * each corresponding speakup->kernel transition.
+	 *
+	 * The progression thread only interferes with the speakup machinery through
+	 * the synth buffer, so only needs to take the lock while tinkering with
+	 * the buffer.
+	 *
+	 * We use spin_lock/trylock_irqsave and spin_unlock_irqrestore with this
+	 * spinlock because speakup needs to disable the keyboard IRQ.
+	 */
 	.spinlock = __SPIN_LOCK_UNLOCKED(speakup_info.spinlock),
 	.flushing = 0,
 };

commit 6697330ac556541fff5e1430ca68fadd60c4247a
Author: William Hubbs <w.d.hubbs@gmail.com>
Date:   Mon May 13 00:03:08 2013 -0500

    staging: speakup: synth: remove custom locking macros
    
    Signed-off-by: William Hubbs <w.d.hubbs@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/speakup/synth.c b/drivers/staging/speakup/synth.c
index d867dd9109ed..1036f47b9464 100644
--- a/drivers/staging/speakup/synth.c
+++ b/drivers/staging/speakup/synth.c
@@ -83,27 +83,27 @@ void spk_do_catch_up(struct spk_synth *synth)
 	full_time = spk_get_var(FULL);
 	delay_time = spk_get_var(DELAY);
 
-	spk_lock(flags);
+	spin_lock_irqsave(&speakup_info.spinlock, flags);
 	jiffy_delta_val = jiffy_delta->u.n.value;
-	spk_unlock(flags);
+	spin_unlock_irqrestore(&speakup_info.spinlock, flags);
 
 	jiff_max = jiffies + jiffy_delta_val;
 	while (!kthread_should_stop()) {
-		spk_lock(flags);
+		spin_lock_irqsave(&speakup_info.spinlock, flags);
 		if (speakup_info.flushing) {
 			speakup_info.flushing = 0;
-			spk_unlock(flags);
+			spin_unlock_irqrestore(&speakup_info.spinlock, flags);
 			synth->flush(synth);
 			continue;
 		}
 		if (synth_buffer_empty()) {
-			spk_unlock(flags);
+			spin_unlock_irqrestore(&speakup_info.spinlock, flags);
 			break;
 		}
 		ch = synth_buffer_peek();
 		set_current_state(TASK_INTERRUPTIBLE);
 		full_time_val = full_time->u.n.value;
-		spk_unlock(flags);
+		spin_unlock_irqrestore(&speakup_info.spinlock, flags);
 		if (ch == '\n')
 			ch = synth->procspeech;
 		if (!spk_serial_out(ch)) {
@@ -111,11 +111,11 @@ void spk_do_catch_up(struct spk_synth *synth)
 			continue;
 		}
 		if ((jiffies >= jiff_max) && (ch == SPACE)) {
-			spk_lock(flags);
+			spin_lock_irqsave(&speakup_info.spinlock, flags);
 			jiffy_delta_val = jiffy_delta->u.n.value;
 			delay_time_val = delay_time->u.n.value;
 			full_time_val = full_time->u.n.value;
-			spk_unlock(flags);
+			spin_unlock_irqrestore(&speakup_info.spinlock, flags);
 			if (spk_serial_out(synth->procspeech))
 				schedule_timeout(
 					msecs_to_jiffies(delay_time_val));
@@ -125,9 +125,9 @@ void spk_do_catch_up(struct spk_synth *synth)
 			jiff_max = jiffies + jiffy_delta_val;
 		}
 		set_current_state(TASK_RUNNING);
-		spk_lock(flags);
+		spin_lock_irqsave(&speakup_info.spinlock, flags);
 		synth_buffer_getc();
-		spk_unlock(flags);
+		spin_unlock_irqrestore(&speakup_info.spinlock, flags);
 	}
 	spk_serial_out(synth->procspeech);
 }
@@ -403,11 +403,11 @@ void synth_release(void)
 
 	if (synth == NULL)
 		return;
-	spk_lock(flags);
+	spin_lock_irqsave(&speakup_info.spinlock, flags);
 	pr_info("releasing synth %s\n", synth->name);
 	synth->alive = 0;
 	del_timer(&thread_timer);
-	spk_unlock(flags);
+	spin_unlock_irqrestore(&speakup_info.spinlock, flags);
 	if (synth->attributes.name)
 		sysfs_remove_group(speakup_kobj, &(synth->attributes));
 	for (var = synth->vars; var->var_id != MAXVARS; var++)

commit 17cb3be61b45d716f6b21a9380925493413ce0ed
Merge: d7f9729f6e06 e16a922a27ec
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon Jan 7 15:17:52 2013 -0800

    Merge branch 'staging-linus' into staging-next
    
    This is to get the comedi fixes, and resolve the issue in comdi_test.c
    and comedi_fops.c that were caused by changes in both branches.
    
    It also allows the fwserial driver changes to be applied, as they
    required the fixes that are in staging-linus.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit ca2beaf84d9678c12b17d92623f0e90829d6ca13
Author: Samuel Thibault <samuel.thibault@ens-lyon.org>
Date:   Wed Jan 2 02:37:40 2013 +0100

    staging: speakup: Prefix externally-visible symbols
    
    This prefixes all externally-visible symbols of speakup with "spk_".
    
    Signed-off-by: Samuel Thibault <samuel.thibault@ens-lyon.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/speakup/synth.c b/drivers/staging/speakup/synth.c
index df9533798095..59c46a41b5a7 100644
--- a/drivers/staging/speakup/synth.c
+++ b/drivers/staging/speakup/synth.c
@@ -20,9 +20,9 @@
 #define MAXSYNTHS       16      /* Max number of synths in array. */
 static struct spk_synth *synths[MAXSYNTHS];
 struct spk_synth *synth;
-char pitch_buff[32] = "";
+char spk_pitch_buff[32] = "";
 static int module_status;
-bool quiet_boot;
+bool spk_quiet_boot;
 
 struct speakup_info_t speakup_info = {
 	.spinlock = __SPIN_LOCK_UNLOCKED(speakup_info.spinlock),
@@ -32,7 +32,7 @@ EXPORT_SYMBOL_GPL(speakup_info);
 
 static int do_synth_init(struct spk_synth *in_synth);
 
-int serial_synth_probe(struct spk_synth *synth)
+int spk_serial_synth_probe(struct spk_synth *synth)
 {
 	const struct old_serial_port *ser;
 	int failed = 0;
@@ -59,7 +59,7 @@ int serial_synth_probe(struct spk_synth *synth)
 	synth->alive = 1;
 	return 0;
 }
-EXPORT_SYMBOL_GPL(serial_synth_probe);
+EXPORT_SYMBOL_GPL(spk_serial_synth_probe);
 
 /* Main loop of the progression thread: keep eating from the buffer
  * and push to the serial port, waiting as needed
@@ -79,9 +79,9 @@ void spk_do_catch_up(struct spk_synth *synth)
 	int delay_time_val;
 	int full_time_val;
 
-	jiffy_delta = get_var(JIFFY);
-	full_time = get_var(FULL);
-	delay_time = get_var(DELAY);
+	jiffy_delta = spk_get_var(JIFFY);
+	full_time = spk_get_var(FULL);
+	delay_time = spk_get_var(DELAY);
 
 	spk_lock(flags);
 	jiffy_delta_val = jiffy_delta->u.n.value;
@@ -139,7 +139,7 @@ const char *spk_synth_immediate(struct spk_synth *synth, const char *buff)
 	while ((ch = *buff)) {
 		if (ch == '\n')
 			ch = synth->procspeech;
-		if (wait_for_xmitr())
+		if (spk_wait_for_xmitr())
 			outb(ch, speakup_info.port_tts);
 		else
 			return buff;
@@ -166,7 +166,7 @@ int spk_synth_is_alive_restart(struct spk_synth *synth)
 {
 	if (synth->alive)
 		return 1;
-	if (!synth->alive && wait_for_xmitr() > 0) {
+	if (!synth->alive && spk_wait_for_xmitr() > 0) {
 		/* restart */
 		synth->alive = 1;
 		synth_printf("%s", synth->init);
@@ -192,20 +192,20 @@ void synth_start(void)
 		synth_buffer_clear();
 		return;
 	}
-	trigger_time = get_var(TRIGGER);
+	trigger_time = spk_get_var(TRIGGER);
 	if (!timer_pending(&thread_timer))
 		mod_timer(&thread_timer, jiffies +
 			msecs_to_jiffies(trigger_time->u.n.value));
 }
 
-void do_flush(void)
+void spk_do_flush(void)
 {
 	speakup_info.flushing = 1;
 	synth_buffer_clear();
 	if (synth->alive) {
-		if (pitch_shift) {
-			synth_printf("%s", pitch_buff);
-			pitch_shift = 0;
+		if (spk_pitch_shift) {
+			synth_printf("%s", spk_pitch_buff);
+			spk_pitch_shift = 0;
 		}
 	}
 	wake_up_interruptible_all(&speakup_event);
@@ -241,7 +241,7 @@ EXPORT_SYMBOL_GPL(synth_printf);
 static int index_count;
 static int sentence_count;
 
-void reset_index_count(int sc)
+void spk_reset_index_count(int sc)
 {
 	static int first = 1;
 	if (first)
@@ -277,7 +277,7 @@ void synth_insert_next_index(int sent_num)
 	}
 }
 
-void get_index_count(int *linecount, int *sentcount)
+void spk_get_index_count(int *linecount, int *sentcount)
 {
 	int ind = synth->get_index();
 	if (ind) {
@@ -384,7 +384,7 @@ static int do_synth_init(struct spk_synth *in_synth)
 	for (var = synth->vars;
 		(var->var_id >= 0) && (var->var_id < MAXVARS); var++)
 		speakup_register_var(var);
-	if (!quiet_boot)
+	if (!spk_quiet_boot)
 		synth_printf("%s found\n", synth->long_name);
 	if (synth->attributes.name
 	&& sysfs_create_group(speakup_kobj, &(synth->attributes)) < 0)
@@ -412,7 +412,7 @@ void synth_release(void)
 		sysfs_remove_group(speakup_kobj, &(synth->attributes));
 	for (var = synth->vars; var->var_id != MAXVARS; var++)
 		speakup_unregister_var(var->var_id);
-	stop_serial_interrupt();
+	spk_stop_serial_interrupt();
 	synth->release();
 	synth = NULL;
 }
@@ -460,4 +460,4 @@ void synth_remove(struct spk_synth *in_synth)
 }
 EXPORT_SYMBOL_GPL(synth_remove);
 
-short punc_masks[] = { 0, SOME, MOST, PUNC, PUNC|B_SYM };
+short spk_punc_masks[] = { 0, SOME, MOST, PUNC, PUNC|B_SYM };

commit 6102c48bd421074a33e102f2ebda3724e8d275f9
Author: Samuel Thibault <samuel.thibault@ens-lyon.org>
Date:   Mon Jan 7 22:03:51 2013 +0100

    staging: speakup: avoid out-of-range access in synth_add()
    
    Check that array index is in-bounds before accessing the synths[] array.
    
    Signed-off-by: Samuel Thibault <samuel.thibault@ens-lyon.org>
    Cc: stable <stable@vger.kernel.org>
    Cc: Nickolai Zeldovich <nickolai@csail.mit.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/speakup/synth.c b/drivers/staging/speakup/synth.c
index b91d22b6330f..7616f058a00b 100644
--- a/drivers/staging/speakup/synth.c
+++ b/drivers/staging/speakup/synth.c
@@ -423,7 +423,7 @@ int synth_add(struct spk_synth *in_synth)
 	int i;
 	int status = 0;
 	mutex_lock(&spk_mutex);
-	for (i = 0; synths[i] != NULL && i < MAXSYNTHS; i++)
+	for (i = 0; i < MAXSYNTHS && synths[i] != NULL; i++)
 		/* synth_remove() is responsible for rotating the array down */
 		if (in_synth == synths[i]) {
 			mutex_unlock(&spk_mutex);

commit ae428655b826f2755a8101b27beda42a275ef8ad
Author: Nickolai Zeldovich <nickolai@csail.mit.edu>
Date:   Sat Jan 5 14:17:45 2013 -0500

    staging: speakup: avoid out-of-range access in synth_init()
    
    Check that array index is in-bounds before accessing the synths[] array.
    
    Signed-off-by: Nickolai Zeldovich <nickolai@csail.mit.edu>
    Cc: stable <stable@vger.kernel.org>
    Cc: Samuel Thibault <samuel.thibault@ens-lyon.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/speakup/synth.c b/drivers/staging/speakup/synth.c
index df9533798095..b91d22b6330f 100644
--- a/drivers/staging/speakup/synth.c
+++ b/drivers/staging/speakup/synth.c
@@ -342,7 +342,7 @@ int synth_init(char *synth_name)
 
 	mutex_lock(&spk_mutex);
 	/* First, check if we already have it loaded. */
-	for (i = 0; synths[i] != NULL && i < MAXSYNTHS; i++)
+	for (i = 0; i < MAXSYNTHS && synths[i] != NULL; i++)
 		if (strcmp(synths[i]->name, synth_name) == 0)
 			synth = synths[i];
 

commit 83414d528d2f97d6574c14afb892879c11bbcc7c
Author: Justin P. Mattock <justinmattock@gmail.com>
Date:   Mon Jul 9 07:30:27 2012 -0700

    staging "speakup" Fix typos.
    
    Signed-off-by: Justin P. Mattock <justinmattock@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/speakup/synth.c b/drivers/staging/speakup/synth.c
index 331eae788700..df9533798095 100644
--- a/drivers/staging/speakup/synth.c
+++ b/drivers/staging/speakup/synth.c
@@ -64,7 +64,7 @@ EXPORT_SYMBOL_GPL(serial_synth_probe);
 /* Main loop of the progression thread: keep eating from the buffer
  * and push to the serial port, waiting as needed
  *
- * For devices that have a "full" notification mecanism, the driver can
+ * For devices that have a "full" notification mechanism, the driver can
  * adapt the loop the way they prefer.
  */
 void spk_do_catch_up(struct spk_synth *synth)

commit 3ee0017e03cd790ed1adaa97ef6f99aff3706ec2
Author: Jiri Slaby <jslaby@suse.cz>
Date:   Mon Mar 5 14:52:11 2012 +0100

    TTY: speakup, do not use serialP
    
    The structures there are going away. And speakup has enough troubles
    already.
    
    So define a structure similar to what 8250 does: old_serial_port.
    There define an array of speed, port base and so on needed for
    configuration. Then use this structure instead of serial_state defined
    in serialP.h.
    
    Signed-off-by: Jiri Slaby <jslaby@suse.cz>
    Cc: William Hubbs <w.d.hubbs@gmail.com>
    Cc: Chris Brannon <chris@the-brannons.com>
    Cc: Kirk Reiser <kirk@braille.uwo.ca>
    Cc: Samuel Thibault <samuel.thibault@ens-lyon.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/speakup/synth.c b/drivers/staging/speakup/synth.c
index 2222d6919ef5..331eae788700 100644
--- a/drivers/staging/speakup/synth.c
+++ b/drivers/staging/speakup/synth.c
@@ -34,7 +34,7 @@ static int do_synth_init(struct spk_synth *in_synth);
 
 int serial_synth_probe(struct spk_synth *synth)
 {
-	struct serial_state *ser;
+	const struct old_serial_port *ser;
 	int failed = 0;
 
 	if ((synth->ser >= SPK_LO_TTY) && (synth->ser <= SPK_HI_TTY)) {

commit 90ab5ee94171b3e28de6bb42ee30b527014e0be7
Author: Rusty Russell <rusty@rustcorp.com.au>
Date:   Fri Jan 13 09:32:20 2012 +1030

    module_param: make bool parameters really bool (drivers & misc)
    
    module_param(bool) used to counter-intuitively take an int.  In
    fddd5201 (mid-2009) we allowed bool or int/unsigned int using a messy
    trick.
    
    It's time to remove the int/unsigned int option.  For this version
    it'll simply give a warning, but it'll break next kernel version.
    
    Acked-by: Mauro Carvalho Chehab <mchehab@redhat.com>
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>

diff --git a/drivers/staging/speakup/synth.c b/drivers/staging/speakup/synth.c
index c241074a4b5e..2222d6919ef5 100644
--- a/drivers/staging/speakup/synth.c
+++ b/drivers/staging/speakup/synth.c
@@ -22,7 +22,7 @@ static struct spk_synth *synths[MAXSYNTHS];
 struct spk_synth *synth;
 char pitch_buff[32] = "";
 static int module_status;
-int quiet_boot;
+bool quiet_boot;
 
 struct speakup_info_t speakup_info = {
 	.spinlock = __SPIN_LOCK_UNLOCKED(speakup_info.spinlock),

commit 1e560261b75e4d7a6584045e332230eb8e0058c4
Author: William Hubbs <w.d.hubbs@gmail.com>
Date:   Fri Oct 15 22:13:37 2010 -0500

    staging: speakup: synth.c style fixes
    
    fix issues reported by checkpatch.pl
    
    Signed-off-by: William Hubbs <w.d.hubbs@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/speakup/synth.c b/drivers/staging/speakup/synth.c
index 7f74f80be699..c241074a4b5e 100644
--- a/drivers/staging/speakup/synth.c
+++ b/drivers/staging/speakup/synth.c
@@ -19,13 +19,13 @@
 
 #define MAXSYNTHS       16      /* Max number of synths in array. */
 static struct spk_synth *synths[MAXSYNTHS];
-struct spk_synth *synth = NULL;
+struct spk_synth *synth;
 char pitch_buff[32] = "";
 static int module_status;
 int quiet_boot;
 
 struct speakup_info_t speakup_info = {
-	.spinlock = SPIN_LOCK_UNLOCKED,
+	.spinlock = __SPIN_LOCK_UNLOCKED(speakup_info.spinlock),
 	.flushing = 0,
 };
 EXPORT_SYMBOL_GPL(speakup_info);
@@ -117,9 +117,11 @@ void spk_do_catch_up(struct spk_synth *synth)
 			full_time_val = full_time->u.n.value;
 			spk_unlock(flags);
 			if (spk_serial_out(synth->procspeech))
-				schedule_timeout(msecs_to_jiffies(delay_time_val));
+				schedule_timeout(
+					msecs_to_jiffies(delay_time_val));
 			else
-				schedule_timeout(msecs_to_jiffies(full_time_val));
+				schedule_timeout(
+					msecs_to_jiffies(full_time_val));
 			jiff_max = jiffies + jiffy_delta_val;
 		}
 		set_current_state(TASK_RUNNING);
@@ -192,7 +194,8 @@ void synth_start(void)
 	}
 	trigger_time = get_var(TRIGGER);
 	if (!timer_pending(&thread_timer))
-		mod_timer(&thread_timer, jiffies + msecs_to_jiffies(trigger_time->u.n.value));
+		mod_timer(&thread_timer, jiffies +
+			msecs_to_jiffies(trigger_time->u.n.value));
 }
 
 void do_flush(void)
@@ -235,8 +238,8 @@ void synth_printf(const char *fmt, ...)
 }
 EXPORT_SYMBOL_GPL(synth_printf);
 
-static int index_count = 0;
-static int sentence_count = 0;
+static int index_count;
+static int sentence_count;
 
 void reset_index_count(int sc)
 {
@@ -283,7 +286,8 @@ void get_index_count(int *linecount, int *sentcount)
 		if ((ind / 10) <= synth->indexing.currindex)
 			index_count = synth->indexing.currindex-(ind/10);
 		else
-			index_count = synth->indexing.currindex-synth->indexing.lowindex
+			index_count = synth->indexing.currindex
+				-synth->indexing.lowindex
 				+ synth->indexing.highindex-(ind/10)+1;
 
 	}
@@ -312,10 +316,10 @@ int synth_release_region(unsigned long start, unsigned long n)
 EXPORT_SYMBOL_GPL(synth_release_region);
 
 struct var_t synth_time_vars[] = {
-	{ DELAY, .u.n = {NULL, 100, 100, 2000, 0, 0, NULL }},
-	{ TRIGGER, .u.n = {NULL, 20, 10, 2000, 0, 0, NULL }},
-	{ JIFFY, .u.n = {NULL, 50, 20, 200, 0, 0, NULL }},
-	{ FULL, .u.n = {NULL, 400, 200, 60000, 0, 0, NULL }},
+	{ DELAY, .u.n = {NULL, 100, 100, 2000, 0, 0, NULL } },
+	{ TRIGGER, .u.n = {NULL, 20, 10, 2000, 0, 0, NULL } },
+	{ JIFFY, .u.n = {NULL, 50, 20, 200, 0, 0, NULL } },
+	{ FULL, .u.n = {NULL, 400, 200, 60000, 0, 0, NULL } },
 	V_LAST_VAR
 };
 
@@ -377,7 +381,8 @@ static int do_synth_init(struct spk_synth *in_synth)
 	synth_time_vars[3].u.n.value =
 		synth_time_vars[3].u.n.default_val = synth->full;
 	synth_printf("%s", synth->init);
-	for (var = synth->vars; (var->var_id >= 0) && (var->var_id < MAXVARS); var++)
+	for (var = synth->vars;
+		(var->var_id >= 0) && (var->var_id < MAXVARS); var++)
 		speakup_register_var(var);
 	if (!quiet_boot)
 		synth_printf("%s found\n", synth->long_name);

commit c6e3fd22cd538365bfeb82997d5b89562e077d42
Author: William Hubbs <w.d.hubbs@gmail.com>
Date:   Thu Oct 7 13:20:02 2010 -0500

    Staging: add speakup to the staging directory
    
    Speakup is a kernel based screen review package for the linux operating
    system.  It allows blind users to interact with applications on the
    linux console by means of synthetic speech.
    
    The authors and maintainers of this code include the following:
    
    Kirk Reiser, Andy Berdan, John Covici, Brian and
    David Borowski, Christopher Brannon, Samuel Thibault and William Hubbs.
    
    Signed-off-by: William Hubbs <w.d.hubbs@gmail.com>
    Signed-off-by: Samuel Thibault <samuel.thibault@ens-lyon.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/speakup/synth.c b/drivers/staging/speakup/synth.c
new file mode 100644
index 000000000000..7f74f80be699
--- /dev/null
+++ b/drivers/staging/speakup/synth.c
@@ -0,0 +1,458 @@
+#include <linux/types.h>
+#include <linux/ctype.h>	/* for isdigit() and friends */
+#include <linux/fs.h>
+#include <linux/mm.h>		/* for verify_area */
+#include <linux/errno.h>	/* for -EBUSY */
+#include <linux/ioport.h>	/* for check_region, request_region */
+#include <linux/interrupt.h>
+#include <linux/delay.h>	/* for loops_per_sec */
+#include <linux/kmod.h>
+#include <linux/jiffies.h>
+#include <linux/uaccess.h> /* for copy_from_user */
+#include <linux/sched.h>
+#include <linux/timer.h>
+#include <linux/kthread.h>
+
+#include "spk_priv.h"
+#include "speakup.h"
+#include "serialio.h"
+
+#define MAXSYNTHS       16      /* Max number of synths in array. */
+static struct spk_synth *synths[MAXSYNTHS];
+struct spk_synth *synth = NULL;
+char pitch_buff[32] = "";
+static int module_status;
+int quiet_boot;
+
+struct speakup_info_t speakup_info = {
+	.spinlock = SPIN_LOCK_UNLOCKED,
+	.flushing = 0,
+};
+EXPORT_SYMBOL_GPL(speakup_info);
+
+static int do_synth_init(struct spk_synth *in_synth);
+
+int serial_synth_probe(struct spk_synth *synth)
+{
+	struct serial_state *ser;
+	int failed = 0;
+
+	if ((synth->ser >= SPK_LO_TTY) && (synth->ser <= SPK_HI_TTY)) {
+		ser = spk_serial_init(synth->ser);
+		if (ser == NULL) {
+			failed = -1;
+		} else {
+			outb_p(0, ser->port);
+			mdelay(1);
+			outb_p('\r', ser->port);
+		}
+	} else {
+		failed = -1;
+		pr_warn("ttyS%i is an invalid port\n", synth->ser);
+	}
+	if (failed) {
+		pr_info("%s: not found\n", synth->long_name);
+		return -ENODEV;
+	}
+	pr_info("%s: ttyS%i, Driver Version %s\n",
+			synth->long_name, synth->ser, synth->version);
+	synth->alive = 1;
+	return 0;
+}
+EXPORT_SYMBOL_GPL(serial_synth_probe);
+
+/* Main loop of the progression thread: keep eating from the buffer
+ * and push to the serial port, waiting as needed
+ *
+ * For devices that have a "full" notification mecanism, the driver can
+ * adapt the loop the way they prefer.
+ */
+void spk_do_catch_up(struct spk_synth *synth)
+{
+	u_char ch;
+	unsigned long flags;
+	unsigned long jiff_max;
+	struct var_t *delay_time;
+	struct var_t *full_time;
+	struct var_t *jiffy_delta;
+	int jiffy_delta_val;
+	int delay_time_val;
+	int full_time_val;
+
+	jiffy_delta = get_var(JIFFY);
+	full_time = get_var(FULL);
+	delay_time = get_var(DELAY);
+
+	spk_lock(flags);
+	jiffy_delta_val = jiffy_delta->u.n.value;
+	spk_unlock(flags);
+
+	jiff_max = jiffies + jiffy_delta_val;
+	while (!kthread_should_stop()) {
+		spk_lock(flags);
+		if (speakup_info.flushing) {
+			speakup_info.flushing = 0;
+			spk_unlock(flags);
+			synth->flush(synth);
+			continue;
+		}
+		if (synth_buffer_empty()) {
+			spk_unlock(flags);
+			break;
+		}
+		ch = synth_buffer_peek();
+		set_current_state(TASK_INTERRUPTIBLE);
+		full_time_val = full_time->u.n.value;
+		spk_unlock(flags);
+		if (ch == '\n')
+			ch = synth->procspeech;
+		if (!spk_serial_out(ch)) {
+			schedule_timeout(msecs_to_jiffies(full_time_val));
+			continue;
+		}
+		if ((jiffies >= jiff_max) && (ch == SPACE)) {
+			spk_lock(flags);
+			jiffy_delta_val = jiffy_delta->u.n.value;
+			delay_time_val = delay_time->u.n.value;
+			full_time_val = full_time->u.n.value;
+			spk_unlock(flags);
+			if (spk_serial_out(synth->procspeech))
+				schedule_timeout(msecs_to_jiffies(delay_time_val));
+			else
+				schedule_timeout(msecs_to_jiffies(full_time_val));
+			jiff_max = jiffies + jiffy_delta_val;
+		}
+		set_current_state(TASK_RUNNING);
+		spk_lock(flags);
+		synth_buffer_getc();
+		spk_unlock(flags);
+	}
+	spk_serial_out(synth->procspeech);
+}
+EXPORT_SYMBOL_GPL(spk_do_catch_up);
+
+const char *spk_synth_immediate(struct spk_synth *synth, const char *buff)
+{
+	u_char ch;
+	while ((ch = *buff)) {
+		if (ch == '\n')
+			ch = synth->procspeech;
+		if (wait_for_xmitr())
+			outb(ch, speakup_info.port_tts);
+		else
+			return buff;
+		buff++;
+	}
+	return 0;
+}
+EXPORT_SYMBOL_GPL(spk_synth_immediate);
+
+void spk_synth_flush(struct spk_synth *synth)
+{
+	spk_serial_out(synth->clear);
+}
+EXPORT_SYMBOL_GPL(spk_synth_flush);
+
+int spk_synth_is_alive_nop(struct spk_synth *synth)
+{
+	synth->alive = 1;
+	return 1;
+}
+EXPORT_SYMBOL_GPL(spk_synth_is_alive_nop);
+
+int spk_synth_is_alive_restart(struct spk_synth *synth)
+{
+	if (synth->alive)
+		return 1;
+	if (!synth->alive && wait_for_xmitr() > 0) {
+		/* restart */
+		synth->alive = 1;
+		synth_printf("%s", synth->init);
+		return 2; /* reenabled */
+	}
+	pr_warn("%s: can't restart synth\n", synth->long_name);
+	return 0;
+}
+EXPORT_SYMBOL_GPL(spk_synth_is_alive_restart);
+
+static void thread_wake_up(u_long data)
+{
+	wake_up_interruptible_all(&speakup_event);
+}
+
+static DEFINE_TIMER(thread_timer, thread_wake_up, 0, 0);
+
+void synth_start(void)
+{
+	struct var_t *trigger_time;
+
+	if (!synth->alive) {
+		synth_buffer_clear();
+		return;
+	}
+	trigger_time = get_var(TRIGGER);
+	if (!timer_pending(&thread_timer))
+		mod_timer(&thread_timer, jiffies + msecs_to_jiffies(trigger_time->u.n.value));
+}
+
+void do_flush(void)
+{
+	speakup_info.flushing = 1;
+	synth_buffer_clear();
+	if (synth->alive) {
+		if (pitch_shift) {
+			synth_printf("%s", pitch_buff);
+			pitch_shift = 0;
+		}
+	}
+	wake_up_interruptible_all(&speakup_event);
+	wake_up_process(speakup_task);
+}
+
+void synth_write(const char *buf, size_t count)
+{
+	while (count--)
+		synth_buffer_add(*buf++);
+	synth_start();
+}
+
+void synth_printf(const char *fmt, ...)
+{
+	va_list args;
+	unsigned char buf[160], *p;
+	int r;
+
+	va_start(args, fmt);
+	r = vsnprintf(buf, sizeof(buf), fmt, args);
+	va_end(args);
+	if (r > sizeof(buf) - 1)
+		r = sizeof(buf) - 1;
+
+	p = buf;
+	while (r--)
+		synth_buffer_add(*p++);
+	synth_start();
+}
+EXPORT_SYMBOL_GPL(synth_printf);
+
+static int index_count = 0;
+static int sentence_count = 0;
+
+void reset_index_count(int sc)
+{
+	static int first = 1;
+	if (first)
+		first = 0;
+	else
+		synth->get_index();
+	index_count = 0;
+	sentence_count = sc;
+}
+
+int synth_supports_indexing(void)
+{
+	if (synth->get_index != NULL)
+		return 1;
+	return 0;
+}
+
+void synth_insert_next_index(int sent_num)
+{
+	int out;
+	if (synth->alive) {
+		if (sent_num == 0) {
+			synth->indexing.currindex++;
+			index_count++;
+			if (synth->indexing.currindex >
+					synth->indexing.highindex)
+				synth->indexing.currindex =
+					synth->indexing.lowindex;
+		}
+
+		out = synth->indexing.currindex * 10 + sent_num;
+		synth_printf(synth->indexing.command, out, out);
+	}
+}
+
+void get_index_count(int *linecount, int *sentcount)
+{
+	int ind = synth->get_index();
+	if (ind) {
+		sentence_count = ind % 10;
+
+		if ((ind / 10) <= synth->indexing.currindex)
+			index_count = synth->indexing.currindex-(ind/10);
+		else
+			index_count = synth->indexing.currindex-synth->indexing.lowindex
+				+ synth->indexing.highindex-(ind/10)+1;
+
+	}
+	*sentcount = sentence_count;
+	*linecount = index_count;
+}
+
+static struct resource synth_res;
+
+int synth_request_region(unsigned long start, unsigned long n)
+{
+	struct resource *parent = &ioport_resource;
+	memset(&synth_res, 0, sizeof(synth_res));
+	synth_res.name = synth->name;
+	synth_res.start = start;
+	synth_res.end = start + n - 1;
+	synth_res.flags = IORESOURCE_BUSY;
+	return request_resource(parent, &synth_res);
+}
+EXPORT_SYMBOL_GPL(synth_request_region);
+
+int synth_release_region(unsigned long start, unsigned long n)
+{
+	return release_resource(&synth_res);
+}
+EXPORT_SYMBOL_GPL(synth_release_region);
+
+struct var_t synth_time_vars[] = {
+	{ DELAY, .u.n = {NULL, 100, 100, 2000, 0, 0, NULL }},
+	{ TRIGGER, .u.n = {NULL, 20, 10, 2000, 0, 0, NULL }},
+	{ JIFFY, .u.n = {NULL, 50, 20, 200, 0, 0, NULL }},
+	{ FULL, .u.n = {NULL, 400, 200, 60000, 0, 0, NULL }},
+	V_LAST_VAR
+};
+
+/* called by: speakup_init() */
+int synth_init(char *synth_name)
+{
+	int i;
+	int ret = 0;
+	struct spk_synth *synth = NULL;
+
+	if (synth_name == NULL)
+		return 0;
+
+	if (strcmp(synth_name, "none") == 0) {
+		mutex_lock(&spk_mutex);
+		synth_release();
+		mutex_unlock(&spk_mutex);
+		return 0;
+	}
+
+	mutex_lock(&spk_mutex);
+	/* First, check if we already have it loaded. */
+	for (i = 0; synths[i] != NULL && i < MAXSYNTHS; i++)
+		if (strcmp(synths[i]->name, synth_name) == 0)
+			synth = synths[i];
+
+	/* If we got one, initialize it now. */
+	if (synth)
+		ret = do_synth_init(synth);
+	else
+		ret = -ENODEV;
+	mutex_unlock(&spk_mutex);
+
+	return ret;
+}
+
+/* called by: synth_add() */
+static int do_synth_init(struct spk_synth *in_synth)
+{
+	struct var_t *var;
+
+	synth_release();
+	if (in_synth->checkval != SYNTH_CHECK)
+		return -EINVAL;
+	synth = in_synth;
+	synth->alive = 0;
+	pr_warn("synth probe\n");
+	if (synth->probe(synth) < 0) {
+		pr_warn("%s: device probe failed\n", in_synth->name);
+		synth = NULL;
+		return -ENODEV;
+	}
+	synth_time_vars[0].u.n.value =
+		synth_time_vars[0].u.n.default_val = synth->delay;
+	synth_time_vars[1].u.n.value =
+		synth_time_vars[1].u.n.default_val = synth->trigger;
+	synth_time_vars[2].u.n.value =
+		synth_time_vars[2].u.n.default_val = synth->jiffies;
+	synth_time_vars[3].u.n.value =
+		synth_time_vars[3].u.n.default_val = synth->full;
+	synth_printf("%s", synth->init);
+	for (var = synth->vars; (var->var_id >= 0) && (var->var_id < MAXVARS); var++)
+		speakup_register_var(var);
+	if (!quiet_boot)
+		synth_printf("%s found\n", synth->long_name);
+	if (synth->attributes.name
+	&& sysfs_create_group(speakup_kobj, &(synth->attributes)) < 0)
+		return -ENOMEM;
+	synth_flags = synth->flags;
+	wake_up_interruptible_all(&speakup_event);
+	if (speakup_task)
+		wake_up_process(speakup_task);
+	return 0;
+}
+
+void synth_release(void)
+{
+	struct var_t *var;
+	unsigned long flags;
+
+	if (synth == NULL)
+		return;
+	spk_lock(flags);
+	pr_info("releasing synth %s\n", synth->name);
+	synth->alive = 0;
+	del_timer(&thread_timer);
+	spk_unlock(flags);
+	if (synth->attributes.name)
+		sysfs_remove_group(speakup_kobj, &(synth->attributes));
+	for (var = synth->vars; var->var_id != MAXVARS; var++)
+		speakup_unregister_var(var->var_id);
+	stop_serial_interrupt();
+	synth->release();
+	synth = NULL;
+}
+
+/* called by: all_driver_init() */
+int synth_add(struct spk_synth *in_synth)
+{
+	int i;
+	int status = 0;
+	mutex_lock(&spk_mutex);
+	for (i = 0; synths[i] != NULL && i < MAXSYNTHS; i++)
+		/* synth_remove() is responsible for rotating the array down */
+		if (in_synth == synths[i]) {
+			mutex_unlock(&spk_mutex);
+			return 0;
+		}
+	if (i == MAXSYNTHS) {
+		pr_warn("Error: attempting to add a synth past end of array\n");
+		mutex_unlock(&spk_mutex);
+		return -1;
+	}
+	synths[i++] = in_synth;
+	synths[i] = NULL;
+	if (in_synth->startup)
+		status = do_synth_init(in_synth);
+	mutex_unlock(&spk_mutex);
+	return status;
+}
+EXPORT_SYMBOL_GPL(synth_add);
+
+void synth_remove(struct spk_synth *in_synth)
+{
+	int i;
+	mutex_lock(&spk_mutex);
+	if (synth == in_synth)
+		synth_release();
+	for (i = 0; synths[i] != NULL; i++) {
+		if (in_synth == synths[i])
+			break;
+	}
+	for ( ; synths[i] != NULL; i++) /* compress table */
+		synths[i] = synths[i+1];
+	module_status = 0;
+	mutex_unlock(&spk_mutex);
+}
+EXPORT_SYMBOL_GPL(synth_remove);
+
+short punc_masks[] = { 0, SOME, MOST, PUNC, PUNC|B_SYM };
