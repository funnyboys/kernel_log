commit d97a9d7aea04574959178557fa4c34efed64655a
Author: Samuel Thibault <samuel.thibault@ens-lyon.org>
Date:   Sat Apr 25 21:32:26 2020 +0200

    staging/speakup: Add inflection synth parameter
    
    The inflection parameter, i.e. the pitch range, allows to change the
    expressiveness of the synthesized voice.  This is supported by the DEC
    talk synths, and software synthesizers such as espeak/espeak-ng.
    
    Signed-off-by: Samuel Thibault <samuel.thibault@ens-lyon.org>
    Link: https://lore.kernel.org/r/20200425193226.nv3zfd4k3xavi353@function
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/speakup/varhandlers.c b/drivers/staging/speakup/varhandlers.c
index 5741d1cb6227..d7f6bec7ff06 100644
--- a/drivers/staging/speakup/varhandlers.c
+++ b/drivers/staging/speakup/varhandlers.c
@@ -37,6 +37,7 @@ static struct st_var_header var_headers[] = {
 	{ "bell_pos", BELL_POS, VAR_NUM, &spk_bell_pos, NULL },
 	{ "rate", RATE, VAR_NUM, NULL, NULL },
 	{ "pitch", PITCH, VAR_NUM, NULL, NULL },
+	{ "inflection", INFLECTION, VAR_NUM, NULL, NULL },
 	{ "vol", VOL, VAR_NUM, NULL, NULL },
 	{ "tone", TONE, VAR_NUM, NULL, NULL },
 	{ "punct", PUNCT, VAR_NUM, NULL, NULL   },

commit e2d55017ae1ce44247d03c1612e9b724ceff1388
Author: Bhagyashri Dighole <digholebhagyashri@gmail.com>
Date:   Thu Feb 28 17:59:04 2019 +0530

    staging: speakup: fix line over 80 characters.
    
    Fix coding style issues, which solves checkpatch.pl warning:
    "WARNING: line over 80 characters".
    
    Signed-off-by: Bhagyashri Dighole <digholebhagyashri@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/speakup/varhandlers.c b/drivers/staging/speakup/varhandlers.c
index 3c944cb8f547..5741d1cb6227 100644
--- a/drivers/staging/speakup/varhandlers.c
+++ b/drivers/staging/speakup/varhandlers.c
@@ -238,7 +238,8 @@ int spk_set_num_var(int input, struct st_var_header *var, int how)
 	if (!var_data->u.n.out_str)
 		sprintf(cp, var_data->u.n.synth_fmt, (int)val);
 	else
-		sprintf(cp, var_data->u.n.synth_fmt, var_data->u.n.out_str[val]);
+		sprintf(cp, var_data->u.n.synth_fmt,
+			var_data->u.n.out_str[val]);
 	synth_printf("%s", cp);
 	return 0;
 }

commit 615cba3557f1bad6061acde2067a3edbf80d90c2
Author: Samuel Thibault <samuel.thibault@ens-lyon.org>
Date:   Sat Feb 23 20:42:19 2019 +0100

    staging: speakup: Note that simple_strtoul can't simply be replaced by kstrtoul
    
    We often receive patches which erroneously try to use kstrtoul in these
    places.
    
    Signed-off-by: Samuel Thibault <samuel.thibault@ens-lyon.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/speakup/varhandlers.c b/drivers/staging/speakup/varhandlers.c
index 1b545152cc49..3c944cb8f547 100644
--- a/drivers/staging/speakup/varhandlers.c
+++ b/drivers/staging/speakup/varhandlers.c
@@ -328,6 +328,7 @@ char *spk_s2uchar(char *start, char *dest)
 {
 	int val;
 
+	/* Do not replace with kstrtoul: here we need start to be updated */
 	val = simple_strtoul(skip_spaces(start), &start, 10);
 	if (*start == ',')
 		start++;

commit 75ad9a33da2362868beb9c071d7f18020deac9ab
Author: Colin Ian King <colin.king@canonical.com>
Date:   Wed Jul 11 12:26:07 2018 +0100

    staging: speakup: remove redundant variable l
    
    Variable l is being assigned but is never used hence it is redundant
    and can be removed.
    
    Cleans up clang warning:
    warning: variable 'l' set but not used [-Wunused-but-set-variable
    
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/speakup/varhandlers.c b/drivers/staging/speakup/varhandlers.c
index 54a76b6752ad..1b545152cc49 100644
--- a/drivers/staging/speakup/varhandlers.c
+++ b/drivers/staging/speakup/varhandlers.c
@@ -179,7 +179,6 @@ int spk_set_num_var(int input, struct st_var_header *var, int how)
 {
 	int val;
 	int *p_val = var->p_val;
-	int l;
 	char buf[32];
 	char *cp;
 	struct var_t *var_data = var->data;
@@ -237,9 +236,9 @@ int spk_set_num_var(int input, struct st_var_header *var, int how)
 	else
 		cp = buf;
 	if (!var_data->u.n.out_str)
-		l = sprintf(cp, var_data->u.n.synth_fmt, (int)val);
+		sprintf(cp, var_data->u.n.synth_fmt, (int)val);
 	else
-		l = sprintf(cp,	var_data->u.n.synth_fmt, var_data->u.n.out_str[val]);
+		sprintf(cp, var_data->u.n.synth_fmt, var_data->u.n.out_str[val]);
 	synth_printf("%s", cp);
 	return 0;
 }

commit 2610df41489f548e235171b86895d4b49e6acb1f
Author: Samuel Thibault <samuel.thibault@ens-lyon.org>
Date:   Wed May 2 02:56:10 2018 +0200

    staging: speakup: Add pause command used on switching to graphical mode
    
    For software speech syntheses to be able to manage concurrent audio card
    access, they need to know when speakup stops emitting text to be spoken
    because the console has switched to graphical mode.  This introduces a
    PAUSE command to do so.
    
    Signed-off-by: Samuel Thibault <samuel.thibault@ens-lyon.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/speakup/varhandlers.c b/drivers/staging/speakup/varhandlers.c
index 321405532a8e..54a76b6752ad 100644
--- a/drivers/staging/speakup/varhandlers.c
+++ b/drivers/staging/speakup/varhandlers.c
@@ -45,6 +45,7 @@ static struct st_var_header var_headers[] = {
 	{ "lang", LANG, VAR_NUM, NULL, NULL },
 	{ "chartab", CHARTAB, VAR_PROC, NULL, NULL },
 	{ "direct", DIRECT, VAR_NUM, NULL, NULL },
+	{ "pause", PAUSE, VAR_STRING, spk_str_pause, NULL },
 };
 
 static struct st_var_header *var_ptrs[MAXVARS] = { NULL, NULL, NULL };

commit 6496922817e1a1cba8a2d9939ca5de53c5d55239
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Thu Jan 11 11:08:40 2018 +0100

    staging: speakup: add SPDX identifier.
    
    It's good to have SPDX identifiers in all files to make it easier to
    audit the kernel tree for correct licenses.
    
    Fix up the remaining staging speakup files to have a proper SPDX
    identifier, based on the license text in the file itself.  The SPDX
    identifier is a legally binding shorthand, which can be used instead of
    the full boiler plate text.
    
    This work is based on a script and data from Thomas Gleixner, Philippe
    Ombredanne, and Kate Stewart.
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: Philippe Ombredanne <pombredanne@nexb.com>
    Cc: William Hubbs <w.d.hubbs@gmail.com>
    Cc: Chris Brannon <chris@the-brannons.com>
    Cc: Kirk Reiser <kirk@reisers.ca>
    Cc: Samuel Thibault <samuel.thibault@ens-lyon.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/speakup/varhandlers.c b/drivers/staging/speakup/varhandlers.c
index d37d24e26641..321405532a8e 100644
--- a/drivers/staging/speakup/varhandlers.c
+++ b/drivers/staging/speakup/varhandlers.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 #include <linux/ctype.h>
 #include "spk_types.h"
 #include "spk_priv.h"

commit 0dcb2124138a6cdaf76bb0a8247bae0bb3307743
Author: Arushi Singhal <arushisinghal19971997@gmail.com>
Date:   Tue Mar 21 17:12:28 2017 +0530

    staging: speakup: fixes braces {} should be used on all arms of this statement
    
    This patch fixes the checks reported by checkpatch.pl
    for braces {} should be used on all arms of this statement.
    
    Signed-off-by: Arushi Singhal <arushisinghal19971997@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/speakup/varhandlers.c b/drivers/staging/speakup/varhandlers.c
index 5910fe0b1365..d37d24e26641 100644
--- a/drivers/staging/speakup/varhandlers.c
+++ b/drivers/staging/speakup/varhandlers.c
@@ -258,10 +258,11 @@ int spk_set_string_var(const char *page, struct st_var_header *var, int len)
 		if (var->p_val != var_data->u.s.default_val)
 			strcpy((char *)var->p_val, var_data->u.s.default_val);
 		return -ERESTART;
-	} else if (var->p_val)
+	} else if (var->p_val) {
 		strcpy((char *)var->p_val, page);
-	else
+	} else {
 		return -E2BIG;
+	}
 	return 0;
 }
 
@@ -281,17 +282,18 @@ int spk_set_mask_bits(const char *input, const int which, const int how)
 			spk_chartab[*cp] &= ~mask;
 	}
 	cp = (u_char *)input;
-	if (!cp)
+	if (!cp) {
 		cp = spk_punc_info[which].value;
-	else {
+	} else {
 		for (; *cp; cp++) {
 			if (*cp < SPACE)
 				break;
 			if (mask < PUNC) {
 				if (!(spk_chartab[*cp] & PUNC))
 					break;
-			} else if (spk_chartab[*cp] & B_NUM)
+			} else if (spk_chartab[*cp] & B_NUM) {
 				break;
+			}
 		}
 		if (*cp)
 			return -EINVAL;

commit b8f107bc90a7e901e68a5335879dafb7c5645819
Author: Arushi Singhal <arushisinghal19971997@gmail.com>
Date:   Tue Mar 21 17:12:27 2017 +0530

    staging: speakup: Simplify "NULL" comparisons
    
    Fixed coding style for null comparisons in speakup driver to be more
    consistant with the rest of the kernel coding style.
    Replaced 'x != NULL' with 'x' and 'x = NULL' with '!x'.
    
    Signed-off-by: Arushi Singhal <arushisinghal19971997@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/speakup/varhandlers.c b/drivers/staging/speakup/varhandlers.c
index cc984196020f..5910fe0b1365 100644
--- a/drivers/staging/speakup/varhandlers.c
+++ b/drivers/staging/speakup/varhandlers.c
@@ -98,7 +98,7 @@ void speakup_register_var(struct var_t *var)
 		}
 	}
 	p_header = var_ptrs[var->var_id];
-	if (p_header->data != NULL)
+	if (p_header->data)
 		return;
 	p_header->data = var;
 	switch (p_header->var_type) {
@@ -210,11 +210,11 @@ int spk_set_num_var(int input, struct st_var_header *var, int how)
 		return -ERANGE;
 
 	var_data->u.n.value = val;
-	if (var->var_type == VAR_TIME && p_val != NULL) {
+	if (var->var_type == VAR_TIME && p_val) {
 		*p_val = msecs_to_jiffies(val);
 		return 0;
 	}
-	if (p_val != NULL)
+	if (p_val)
 		*p_val = val;
 	if (var->var_id == PUNC_LEVEL) {
 		spk_punc_mask = spk_punc_masks[val];

commit 9eca657fff4a04f6959ba9f42f6b9bd5368c0c2f
Author: Walt Feasel <waltfeasel@gmail.com>
Date:   Sat Nov 19 11:50:53 2016 -0500

    staging: speakup: varhandlers.c Align parenthesis
    
    Make suggested checkpatch modification for
    CHECK: Alignment should match open parenthesis
    
    Signed-off-by: Walt Feasel <waltfeasel@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/speakup/varhandlers.c b/drivers/staging/speakup/varhandlers.c
index 5ab724589f27..cc984196020f 100644
--- a/drivers/staging/speakup/varhandlers.c
+++ b/drivers/staging/speakup/varhandlers.c
@@ -237,8 +237,7 @@ int spk_set_num_var(int input, struct st_var_header *var, int how)
 	if (!var_data->u.n.out_str)
 		l = sprintf(cp, var_data->u.n.synth_fmt, (int)val);
 	else
-		l = sprintf(cp,
-			var_data->u.n.synth_fmt, var_data->u.n.out_str[val]);
+		l = sprintf(cp,	var_data->u.n.synth_fmt, var_data->u.n.out_str[val]);
 	synth_printf("%s", cp);
 	return 0;
 }

commit 26ce8a4fce038639d19a1c140a73656615bffc4a
Author: Walt Feasel <waltfeasel@gmail.com>
Date:   Sat Nov 19 11:50:52 2016 -0500

    staging: speakup: varhandlers.c Comment style modifications
    
    Make modifications to comment style
    
    Signed-off-by: Walt Feasel <waltfeasel@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/speakup/varhandlers.c b/drivers/staging/speakup/varhandlers.c
index 21186e3dc7ad..5ab724589f27 100644
--- a/drivers/staging/speakup/varhandlers.c
+++ b/drivers/staging/speakup/varhandlers.c
@@ -266,7 +266,8 @@ int spk_set_string_var(const char *page, struct st_var_header *var, int len)
 	return 0;
 }
 
-/* spk_set_mask_bits sets or clears the punc/delim/repeat bits,
+/*
+ * spk_set_mask_bits sets or clears the punc/delim/repeat bits,
  * if input is null uses the defaults.
  * values for how: 0 clears bits of chars supplied,
  * 1 clears allk, 2 sets bits for chars

commit 114c9ec2fdcc492543c149fc1d0325ecbbf3d25e
Author: Sandhya Bankar <bankarsandhya512@gmail.com>
Date:   Thu Sep 22 15:23:55 2016 +0530

    Staging: speakup: varhandlers: Add space around the operator.
    
    This patch was found by checkpatch.
    
    Signed-off-by: Sandhya Bankar <bankarsandhya512@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/speakup/varhandlers.c b/drivers/staging/speakup/varhandlers.c
index e1393d2a2b0f..21186e3dc7ad 100644
--- a/drivers/staging/speakup/varhandlers.c
+++ b/drivers/staging/speakup/varhandlers.c
@@ -276,7 +276,7 @@ int spk_set_mask_bits(const char *input, const int which, const int how)
 	u_char *cp;
 	short mask = spk_punc_info[which].mask;
 
-	if (how&1) {
+	if (how & 1) {
 		for (cp = (u_char *)spk_punc_info[3].value; *cp; cp++)
 			spk_chartab[*cp] &= ~mask;
 	}
@@ -290,14 +290,14 @@ int spk_set_mask_bits(const char *input, const int which, const int how)
 			if (mask < PUNC) {
 				if (!(spk_chartab[*cp] & PUNC))
 					break;
-			} else if (spk_chartab[*cp]&B_NUM)
+			} else if (spk_chartab[*cp] & B_NUM)
 				break;
 		}
 		if (*cp)
 			return -EINVAL;
 		cp = (u_char *)input;
 	}
-	if (how&2) {
+	if (how & 2) {
 		for (; *cp; cp++)
 			if (*cp > SPACE)
 				spk_chartab[*cp] |= mask;

commit d86b4a71ca579914c971ae949335b4e971eec213
Author: Saurabh Sengar <saurabh.truth@gmail.com>
Date:   Mon Dec 7 18:35:11 2015 +0530

    Staging: speakup: varhandlers: cleanup of function spk_get_punc_var
    
    This patch does the following:
    * changed the complicated if statements to simple case statements
    * in case of E_DEFAULT, no need to return error as ERESTART,
    because this is the user asked for. Hence function should return success.
    * ret variable is 0 always, hence removed it.
    * removed one ternary operator, as it was always returning the status value only,
    and hence removed the status variable too
    
    Signed-off-by: Saurabh Sengar <saurabh.truth@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/speakup/varhandlers.c b/drivers/staging/speakup/varhandlers.c
index ab4fe8de415f..e1393d2a2b0f 100644
--- a/drivers/staging/speakup/varhandlers.c
+++ b/drivers/staging/speakup/varhandlers.c
@@ -176,7 +176,6 @@ struct punc_var_t *spk_get_punc_var(enum var_id_t var_id)
 int spk_set_num_var(int input, struct st_var_header *var, int how)
 {
 	int val;
-	short ret = 0;
 	int *p_val = var->p_val;
 	int l;
 	char buf[32];
@@ -186,50 +185,51 @@ int spk_set_num_var(int input, struct st_var_header *var, int how)
 	if (!var_data)
 		return -ENODATA;
 
-	if (how == E_NEW_DEFAULT) {
+	val = var_data->u.n.value;
+	switch (how) {
+	case E_NEW_DEFAULT:
 		if (input < var_data->u.n.low || input > var_data->u.n.high)
 			return -ERANGE;
 		var_data->u.n.default_val = input;
 		return 0;
-	}
-	if (how == E_DEFAULT) {
+	case E_DEFAULT:
 		val = var_data->u.n.default_val;
-		ret = -ERESTART;
-	} else {
-		if (how == E_SET)
-			val = input;
-		else
-			val = var_data->u.n.value;
-		if (how == E_INC)
-			val += input;
-		else if (how == E_DEC)
-			val -= input;
-		if (val < var_data->u.n.low || val > var_data->u.n.high)
-			return -ERANGE;
+		break;
+	case E_SET:
+		val = input;
+		break;
+	case E_INC:
+		val += input;
+		break;
+	case E_DEC:
+		val -= input;
+		break;
 	}
+
+	if (val < var_data->u.n.low || val > var_data->u.n.high)
+		return -ERANGE;
+
 	var_data->u.n.value = val;
 	if (var->var_type == VAR_TIME && p_val != NULL) {
 		*p_val = msecs_to_jiffies(val);
-		return ret;
+		return 0;
 	}
 	if (p_val != NULL)
 		*p_val = val;
 	if (var->var_id == PUNC_LEVEL) {
 		spk_punc_mask = spk_punc_masks[val];
-		return ret;
+		return 0;
 	}
 	if (var_data->u.n.multiplier != 0)
 		val *= var_data->u.n.multiplier;
 	val += var_data->u.n.offset;
 	if (var->var_id < FIRST_SYNTH_VAR || !synth)
-		return ret;
-	if (synth->synth_adjust) {
-		int status = synth->synth_adjust(var);
+		return 0;
+	if (synth->synth_adjust)
+		return synth->synth_adjust(var);
 
-		return (status != 0) ? status : ret;
-	}
 	if (!var_data->u.n.synth_fmt)
-		return ret;
+		return 0;
 	if (var->var_id == PITCH)
 		cp = spk_pitch_buff;
 	else
@@ -240,7 +240,7 @@ int spk_set_num_var(int input, struct st_var_header *var, int how)
 		l = sprintf(cp,
 			var_data->u.n.synth_fmt, var_data->u.n.out_str[val]);
 	synth_printf("%s", cp);
-	return ret;
+	return 0;
 }
 
 int spk_set_string_var(const char *page, struct st_var_header *var, int len)

commit b62c535cd0485804ab889fd8f9ac789ede230dd2
Author: Amitoj Kaur Chawla <amitoj1606@gmail.com>
Date:   Thu Oct 15 02:28:36 2015 +0530

    staging: speakup: varhandlers: Remove useless intialisation
    
    Remove intialisation of a variable that is immediately reassigned.
    
    The semantic patch used to find this is:
    
    // <smpl>
    @@
    type T;
    identifier x;
    constant C;
    expression e;
    @@
    
    T x
    - = C
     ;
    x = e;
    // </smpl>
    
    Signed-off-by: Amitoj Kaur Chawla <amitoj1606@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/speakup/varhandlers.c b/drivers/staging/speakup/varhandlers.c
index b2afec63a6dd..ab4fe8de415f 100644
--- a/drivers/staging/speakup/varhandlers.c
+++ b/drivers/staging/speakup/varhandlers.c
@@ -323,7 +323,7 @@ char *spk_strlwr(char *s)
 
 char *spk_s2uchar(char *start, char *dest)
 {
-	int val = 0;
+	int val;
 
 	val = simple_strtoul(skip_spaces(start), &start, 10);
 	if (*start == ',')

commit ff52fc380db676398fe92e2a3c802ecb41bc535e
Author: Shraddha Barke <shraddha.6596@gmail.com>
Date:   Fri Sep 11 11:32:29 2015 +0530

    Staging: speakup: varhandlers.c: Remove explicit NULL comparison
    
    Remove explicit NULL comparison and write it in its simpler form.
    Replacement done with coccinelle:
    
    @replace_rule@
    expression e;
    @@
    
    -e == NULL
    + !e
    
    Signed-off-by: Shraddha Barke <shraddha.6596@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/speakup/varhandlers.c b/drivers/staging/speakup/varhandlers.c
index 75bf40c14c79..b2afec63a6dd 100644
--- a/drivers/staging/speakup/varhandlers.c
+++ b/drivers/staging/speakup/varhandlers.c
@@ -90,7 +90,7 @@ void speakup_register_var(struct var_t *var)
 	struct st_var_header *p_header;
 
 	BUG_ON(!var || var->var_id < 0 || var->var_id >= MAXVARS);
-	if (var_ptrs[0] == NULL) {
+	if (!var_ptrs[0]) {
 		for (i = 0; i < MAXVARS; i++) {
 			p_header = &var_headers[i];
 			var_ptrs[p_header->var_id] = p_header;
@@ -130,7 +130,7 @@ struct st_var_header *spk_get_var_header(enum var_id_t var_id)
 	if (var_id < 0 || var_id >= MAXVARS)
 		return NULL;
 	p_header = var_ptrs[var_id];
-	if (p_header->data == NULL)
+	if (!p_header->data)
 		return NULL;
 	return p_header;
 }
@@ -163,7 +163,7 @@ struct punc_var_t *spk_get_punc_var(enum var_id_t var_id)
 	struct punc_var_t *where;
 
 	where = punc_vars;
-	while ((where->var_id != -1) && (rv == NULL)) {
+	while ((where->var_id != -1) && (!rv)) {
 		if (where->var_id == var_id)
 			rv = where;
 		else
@@ -183,7 +183,7 @@ int spk_set_num_var(int input, struct st_var_header *var, int how)
 	char *cp;
 	struct var_t *var_data = var->data;
 
-	if (var_data == NULL)
+	if (!var_data)
 		return -ENODATA;
 
 	if (how == E_NEW_DEFAULT) {
@@ -221,9 +221,9 @@ int spk_set_num_var(int input, struct st_var_header *var, int how)
 	if (var_data->u.n.multiplier != 0)
 		val *= var_data->u.n.multiplier;
 	val += var_data->u.n.offset;
-	if (var->var_id < FIRST_SYNTH_VAR || synth == NULL)
+	if (var->var_id < FIRST_SYNTH_VAR || !synth)
 		return ret;
-	if (synth->synth_adjust != NULL) {
+	if (synth->synth_adjust) {
 		int status = synth->synth_adjust(var);
 
 		return (status != 0) ? status : ret;
@@ -247,7 +247,7 @@ int spk_set_string_var(const char *page, struct st_var_header *var, int len)
 {
 	struct var_t *var_data = var->data;
 
-	if (var_data == NULL)
+	if (!var_data)
 		return -ENODATA;
 	if (len > MAXVARLEN)
 		return -E2BIG;
@@ -288,7 +288,7 @@ int spk_set_mask_bits(const char *input, const int which, const int how)
 			if (*cp < SPACE)
 				break;
 			if (mask < PUNC) {
-				if (!(spk_chartab[*cp]&PUNC))
+				if (!(spk_chartab[*cp] & PUNC))
 					break;
 			} else if (spk_chartab[*cp]&B_NUM)
 				break;
@@ -313,7 +313,7 @@ char *spk_strlwr(char *s)
 {
 	char *p;
 
-	if (s == NULL)
+	if (!s)
 		return NULL;
 
 	for (p = s; *p; p++)

commit 13d825edd4441dd3453de58d1bd2ade44d5ad2ab
Author: Aleksei Fedotov <lexa@cfotr.com>
Date:   Fri Aug 14 22:34:37 2015 +0300

    staging: speakup: Fix warning reported by checkpatch
    
    This patch fixes the checkpatch.pl warnings:
    WARNING: Block comments use a trailing */ on a separate line
    WARNING: Block comments use * on subsequent lines
    
    Signed-off-by: Aleksey Fedotov <lexa@cfotr.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/speakup/varhandlers.c b/drivers/staging/speakup/varhandlers.c
index 1b0d1c08741f..75bf40c14c79 100644
--- a/drivers/staging/speakup/varhandlers.c
+++ b/drivers/staging/speakup/varhandlers.c
@@ -269,7 +269,8 @@ int spk_set_string_var(const char *page, struct st_var_header *var, int len)
 /* spk_set_mask_bits sets or clears the punc/delim/repeat bits,
  * if input is null uses the defaults.
  * values for how: 0 clears bits of chars supplied,
- * 1 clears allk, 2 sets bits for chars */
+ * 1 clears allk, 2 sets bits for chars
+ */
 int spk_set_mask_bits(const char *input, const int which, const int how)
 {
 	u_char *cp;

commit 1a9c77d8c882f04a147c2a75bbc2a1fd9b63a66a
Author: Melike Yurtoglu <aysemelikeyurtoglu@gmail.com>
Date:   Wed Oct 1 01:36:29 2014 +0300

    staging: speakup: Fix missing blank line warning
    
    Fixes "Missing a blank line after declarations" checkpatch.pl warning
    in varhandlers.c
    
    Signed-off-by: Melike Yurtoglu <aysemelikeyurtoglu@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/speakup/varhandlers.c b/drivers/staging/speakup/varhandlers.c
index d758284061de..1b0d1c08741f 100644
--- a/drivers/staging/speakup/varhandlers.c
+++ b/drivers/staging/speakup/varhandlers.c
@@ -225,6 +225,7 @@ int spk_set_num_var(int input, struct st_var_header *var, int how)
 		return ret;
 	if (synth->synth_adjust != NULL) {
 		int status = synth->synth_adjust(var);
+
 		return (status != 0) ? status : ret;
 	}
 	if (!var_data->u.n.synth_fmt)

commit 8e69a8110686572a4b88d006faa8c3c759c4c261
Author: Domagoj Trsan <domagoj.trsan@gmail.com>
Date:   Tue Sep 9 20:04:34 2014 +0200

    staging: speakup: fix missing blank lines after declarations
    
    Signed-off-by: Domagoj Trsan <domagoj.trsan@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/speakup/varhandlers.c b/drivers/staging/speakup/varhandlers.c
index a65782c15ccc..d758284061de 100644
--- a/drivers/staging/speakup/varhandlers.c
+++ b/drivers/staging/speakup/varhandlers.c
@@ -117,6 +117,7 @@ void speakup_register_var(struct var_t *var)
 void speakup_unregister_var(enum var_id_t var_id)
 {
 	struct st_var_header *p_header;
+
 	BUG_ON(var_id < 0 || var_id >= MAXVARS);
 	p_header = var_ptrs[var_id];
 	p_header->data = NULL;
@@ -125,6 +126,7 @@ void speakup_unregister_var(enum var_id_t var_id)
 struct st_var_header *spk_get_var_header(enum var_id_t var_id)
 {
 	struct st_var_header *p_header;
+
 	if (var_id < 0 || var_id >= MAXVARS)
 		return NULL;
 	p_header = var_ptrs[var_id];
@@ -271,6 +273,7 @@ int spk_set_mask_bits(const char *input, const int which, const int how)
 {
 	u_char *cp;
 	short mask = spk_punc_info[which].mask;
+
 	if (how&1) {
 		for (cp = (u_char *)spk_punc_info[3].value; *cp; cp++)
 			spk_chartab[*cp] &= ~mask;
@@ -307,6 +310,7 @@ int spk_set_mask_bits(const char *input, const int which, const int how)
 char *spk_strlwr(char *s)
 {
 	char *p;
+
 	if (s == NULL)
 		return NULL;
 
@@ -318,6 +322,7 @@ char *spk_strlwr(char *s)
 char *spk_s2uchar(char *start, char *dest)
 {
 	int val = 0;
+
 	val = simple_strtoul(skip_spaces(start), &start, 10);
 	if (*start == ',')
 		start++;

commit 11a18fc3d1bb5a437755fd3e90568e64f6e7583e
Author: Domagoj Trsan <domagoj.trsan@gmail.com>
Date:   Tue Sep 9 20:04:32 2014 +0200

    staging: speakup: fix redundant return in void functions
    
    Signed-off-by: Domagoj Trsan <domagoj.trsan@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/speakup/varhandlers.c b/drivers/staging/speakup/varhandlers.c
index 445a3fda380e..a65782c15ccc 100644
--- a/drivers/staging/speakup/varhandlers.c
+++ b/drivers/staging/speakup/varhandlers.c
@@ -112,7 +112,6 @@ void speakup_register_var(struct var_t *var)
 	default:
 		break;
 	}
-	return;
 }
 
 void speakup_unregister_var(enum var_id_t var_id)

commit 1f2a55f23f32e7ad24848589fac3e2773b9557aa
Author: Nandini Hanumanthagowda <nandu.hgowda@gmail.com>
Date:   Sun Oct 13 16:21:07 2013 +0530

    staging: speakup: remove unnecessary space before semicolon
    
    Removed unnecessary space before semicolon which was
    leading to checkpatch.pl warning.
    
    Signed-off-by: Nandini Hanumanthagowda <nandu.hgowda@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/speakup/varhandlers.c b/drivers/staging/speakup/varhandlers.c
index 70231b6dabba..445a3fda380e 100644
--- a/drivers/staging/speakup/varhandlers.c
+++ b/drivers/staging/speakup/varhandlers.c
@@ -280,7 +280,7 @@ int spk_set_mask_bits(const char *input, const int which, const int how)
 	if (!cp)
 		cp = spk_punc_info[which].value;
 	else {
-		for ( ; *cp; cp++) {
+		for (; *cp; cp++) {
 			if (*cp < SPACE)
 				break;
 			if (mask < PUNC) {
@@ -294,11 +294,11 @@ int spk_set_mask_bits(const char *input, const int which, const int how)
 		cp = (u_char *)input;
 	}
 	if (how&2) {
-		for ( ; *cp; cp++)
+		for (; *cp; cp++)
 			if (*cp > SPACE)
 				spk_chartab[*cp] |= mask;
 	} else {
-		for ( ; *cp; cp++)
+		for (; *cp; cp++)
 			if (*cp > SPACE)
 				spk_chartab[*cp] &= ~mask;
 	}

commit ab06e0f20ed4c4eb472a1e16f942d6e0150c00bc
Author: Shalin Mehta <shalinmehta85@gmail.com>
Date:   Thu Oct 3 01:08:42 2013 -0700

    staging: speakup: str initialization replaced with NULL where it was initialized with int
    
    Fixed warnings in all of three files where the string was initilized with an integer instead of NULL
    
    Signed-off-by: Shalin Mehta <shalinmehta85@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/speakup/varhandlers.c b/drivers/staging/speakup/varhandlers.c
index 9aa2a78cd71c..70231b6dabba 100644
--- a/drivers/staging/speakup/varhandlers.c
+++ b/drivers/staging/speakup/varhandlers.c
@@ -46,7 +46,7 @@ static struct st_var_header var_headers[] = {
 	{ "direct", DIRECT, VAR_NUM, NULL, NULL },
 };
 
-static struct st_var_header *var_ptrs[MAXVARS] = { 0, 0, 0 };
+static struct st_var_header *var_ptrs[MAXVARS] = { NULL, NULL, NULL };
 
 static struct punc_var_t punc_vars[] = {
 	{ PUNC_SOME, 1 },

commit 15ab600ce34a51e1cbcd3446dd21b67473e1f79e
Author: Sachin Kamat <sachin.kamat@linaro.org>
Date:   Mon May 13 15:30:42 2013 +0530

    Staging: speakup: Fix sparse warning in varhandlers.c
    
    'cp' is a pointer. Fix the incorrect comparison with integer to
    avoid the below warning:
    drivers/staging/speakup/varhandlers.c:283:19: warning:
    Using plain integer as NULL pointer
    
    Signed-off-by: Sachin Kamat <sachin.kamat@linaro.org>
    Acked-by: Samuel Thibault <samuel.thibault@ens-lyon.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/speakup/varhandlers.c b/drivers/staging/speakup/varhandlers.c
index 2e8603d7b14a..9aa2a78cd71c 100644
--- a/drivers/staging/speakup/varhandlers.c
+++ b/drivers/staging/speakup/varhandlers.c
@@ -277,7 +277,7 @@ int spk_set_mask_bits(const char *input, const int which, const int how)
 			spk_chartab[*cp] &= ~mask;
 	}
 	cp = (u_char *)input;
-	if (cp == 0)
+	if (!cp)
 		cp = spk_punc_info[which].value;
 	else {
 		for ( ; *cp; cp++) {

commit 65545eaea9a3af263061e849e3af280b015bc938
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Thu May 9 21:31:59 2013 +0300

    staging: speakup: cleanup spk_var_header_by_name()
    
    There is a confusing while loop here and I have re-written it in
    canonical for loop format.  Also I reversed the NULL check on "name" and
    pulled everything in one tab stop.
    
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Acked-by: Samuel Thibault <samuel.thibault@ens-lyon.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/speakup/varhandlers.c b/drivers/staging/speakup/varhandlers.c
index 7f6288fc2299..2e8603d7b14a 100644
--- a/drivers/staging/speakup/varhandlers.c
+++ b/drivers/staging/speakup/varhandlers.c
@@ -137,18 +137,15 @@ struct st_var_header *spk_get_var_header(enum var_id_t var_id)
 struct st_var_header *spk_var_header_by_name(const char *name)
 {
 	int i;
-	struct st_var_header *where = NULL;
 
-	if (name != NULL) {
-		i = 0;
-		while ((i < MAXVARS) && (where == NULL)) {
-			if (strcmp(name, var_ptrs[i]->name) == 0)
-				where = var_ptrs[i];
-			else
-				i++;
-		}
+	if (!name)
+		return NULL;
+
+	for (i = 0; i < MAXVARS; i++) {
+		if (strcmp(name, var_ptrs[i]->name) == 0)
+			return var_ptrs[i];
 	}
-	return where;
+	return NULL;
 }
 
 struct var_t *spk_get_var(enum var_id_t var_id)

commit 576d742e4a0d0f1bab7950012addccb82fbc172a
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Tue Apr 30 15:27:31 2013 -0700

    staging: speakup: remove custom string_unescape_any_inplace
    
    There is generic implementation of the function to unescape strings.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Cc: Samuel Thibault <samuel.thibault@ens-lyon.org>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: William Hubbs <w.d.hubbs@gmail.com>
    Cc: Chris Brannon <chris@the-brannons.com>
    Cc: Kirk Reiser <kirk@braille.uwo.ca>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/staging/speakup/varhandlers.c b/drivers/staging/speakup/varhandlers.c
index 0099cb12e560..7f6288fc2299 100644
--- a/drivers/staging/speakup/varhandlers.c
+++ b/drivers/staging/speakup/varhandlers.c
@@ -328,49 +328,3 @@ char *spk_s2uchar(char *start, char *dest)
 	*dest = (u_char)val;
 	return start;
 }
-
-char *spk_xlate(char *s)
-{
-	static const char finds[] = "nrtvafe";
-	static const char subs[] = "\n\r\t\013\001\014\033";
-	static const char hx[] = "0123456789abcdefABCDEF";
-	char *p = s, *p1, *p2, c;
-	int num;
-	while ((p = strchr(p, '\\'))) {
-		p1 = p+1;
-		p2 = strchr(finds, *p1);
-		if (p2) {
-			*p++ = subs[p2-finds];
-			p1++;
-		} else if (*p1 >= '0' && *p1 <= '7') {
-			num = (*p1++)&7;
-			while (num < 32 && *p1 >= '0' && *p1 <= '7') {
-				num <<= 3;
-				num += (*p1++)&7;
-			}
-			*p++ = num;
-		} else if (*p1 == 'x' &&
-				strchr(hx, p1[1]) && strchr(hx, p1[2])) {
-			p1++;
-			c = *p1++;
-			if (c > '9')
-				c = (c - '7') & 0x0f;
-			else
-				c -= '0';
-			num = c << 4;
-			c = *p1++;
-			if (c > '9')
-				c = (c-'7')&0x0f;
-			else
-				c -= '0';
-			num += c;
-			*p++ = num;
-		} else
-			*p++ = *p1++;
-		p2 = p;
-		while (*p1)
-			*p2++ = *p1++;
-		*p2 = '\0';
-	}
-	return s;
-}

commit 3d2409d4f1d459ad734718ab19c731a934968ec0
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Tue Apr 9 15:22:16 2013 +0300

    staging: speakup: fix a bug when translate octal numbers
    
    There are actually overflow bug and typo. And bug was never happened due to the
    typo.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Acked-by: Samuel Thibault <samuel.thibault@ens-lyon.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/speakup/varhandlers.c b/drivers/staging/speakup/varhandlers.c
index be61a4ee78dd..0099cb12e560 100644
--- a/drivers/staging/speakup/varhandlers.c
+++ b/drivers/staging/speakup/varhandlers.c
@@ -344,9 +344,9 @@ char *spk_xlate(char *s)
 			p1++;
 		} else if (*p1 >= '0' && *p1 <= '7') {
 			num = (*p1++)&7;
-			while (num < 256 && *p1 >= '0' && *p1 <= '7') {
+			while (num < 32 && *p1 >= '0' && *p1 <= '7') {
 				num <<= 3;
-				num = (*p1++)&7;
+				num += (*p1++)&7;
 			}
 			*p++ = num;
 		} else if (*p1 == 'x' &&

commit 6a48f88b528fef7c4b6ad609111a8acfb5d65335
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Thu Mar 28 11:02:44 2013 +0200

    staging: speakup: use native error codes
    
    The mapping as follows:
            E_RANGE         -> ERANGE
            E_UNDEF         -> ENODATA
            E_TOOLONG       -> E2BIG
            SET_DEFAULT     -> ERESTART
    
    As a side effect it fixes a bug in spk_var_store() where return code was
    mistakenly compared to negative value instead of positive.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Acked-by: Samuel Thibault <samuel.thibault@ens-lyon.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/speakup/varhandlers.c b/drivers/staging/speakup/varhandlers.c
index 0a237da3acee..be61a4ee78dd 100644
--- a/drivers/staging/speakup/varhandlers.c
+++ b/drivers/staging/speakup/varhandlers.c
@@ -184,19 +184,19 @@ int spk_set_num_var(int input, struct st_var_header *var, int how)
 	char buf[32];
 	char *cp;
 	struct var_t *var_data = var->data;
+
 	if (var_data == NULL)
-		return E_UNDEF;
+		return -ENODATA;
 
 	if (how == E_NEW_DEFAULT) {
 		if (input < var_data->u.n.low || input > var_data->u.n.high)
-			ret = E_RANGE;
-		else
-			var_data->u.n.default_val = input;
-		return ret;
+			return -ERANGE;
+		var_data->u.n.default_val = input;
+		return 0;
 	}
 	if (how == E_DEFAULT) {
 		val = var_data->u.n.default_val;
-		ret = SET_DEFAULT;
+		ret = -ERESTART;
 	} else {
 		if (how == E_SET)
 			val = input;
@@ -207,7 +207,7 @@ int spk_set_num_var(int input, struct st_var_header *var, int how)
 		else if (how == E_DEC)
 			val -= input;
 		if (val < var_data->u.n.low || val > var_data->u.n.high)
-			return E_RANGE;
+			return -ERANGE;
 	}
 	var_data->u.n.value = val;
 	if (var->var_type == VAR_TIME && p_val != NULL) {
@@ -246,25 +246,25 @@ int spk_set_num_var(int input, struct st_var_header *var, int how)
 
 int spk_set_string_var(const char *page, struct st_var_header *var, int len)
 {
-	int ret = 0;
 	struct var_t *var_data = var->data;
+
 	if (var_data == NULL)
-		return E_UNDEF;
+		return -ENODATA;
 	if (len > MAXVARLEN)
-		return -E_TOOLONG;
+		return -E2BIG;
 	if (!len) {
 		if (!var_data->u.s.default_val)
 			return 0;
-		ret = SET_DEFAULT;
 		if (!var->p_val)
 			var->p_val = var_data->u.s.default_val;
 		if (var->p_val != var_data->u.s.default_val)
 			strcpy((char *)var->p_val, var_data->u.s.default_val);
+		return -ERESTART;
 	} else if (var->p_val)
 		strcpy((char *)var->p_val, page);
 	else
-		return -E_TOOLONG;
-	return ret;
+		return -E2BIG;
+	return 0;
 }
 
 /* spk_set_mask_bits sets or clears the punc/delim/repeat bits,

commit 1627ab92b2e6307525f43f775aaeac54407981ef
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Thu Mar 28 11:02:43 2013 +0200

    staging: speakup: reuse native kernel functions
    
    We have simple_strtoul and simple_strtol. Don't repeat their functionality
    here.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Acked-by: Samuel Thibault <samuel.thibault@ens-lyon.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/speakup/varhandlers.c b/drivers/staging/speakup/varhandlers.c
index f8c1e457d389..0a237da3acee 100644
--- a/drivers/staging/speakup/varhandlers.c
+++ b/drivers/staging/speakup/varhandlers.c
@@ -319,38 +319,10 @@ char *spk_strlwr(char *s)
 	return s;
 }
 
-char *speakup_s2i(char *start, int *dest)
-{
-	int val;
-	char ch = *start;
-	if (ch == '-' || ch == '+')
-		start++;
-	if (*start < '0' || *start > '9')
-		return start;
-	val = (*start) - '0';
-	start++;
-	while (*start >= '0' && *start <= '9') {
-		val *= 10;
-		val += (*start) - '0';
-		start++;
-	}
-	if (ch == '-')
-		*dest = -val;
-	else
-		*dest = val;
-	return start;
-}
-
 char *spk_s2uchar(char *start, char *dest)
 {
 	int val = 0;
-	while (*start && *start <= SPACE)
-		start++;
-	while (*start >= '0' && *start <= '9') {
-		val *= 10;
-		val += (*start) - '0';
-		start++;
-	}
+	val = simple_strtoul(skip_spaces(start), &start, 10);
 	if (*start == ',')
 		start++;
 	*dest = (u_char)val;

commit ca2beaf84d9678c12b17d92623f0e90829d6ca13
Author: Samuel Thibault <samuel.thibault@ens-lyon.org>
Date:   Wed Jan 2 02:37:40 2013 +0100

    staging: speakup: Prefix externally-visible symbols
    
    This prefixes all externally-visible symbols of speakup with "spk_".
    
    Signed-off-by: Samuel Thibault <samuel.thibault@ens-lyon.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/speakup/varhandlers.c b/drivers/staging/speakup/varhandlers.c
index ab7de9389dd6..f8c1e457d389 100644
--- a/drivers/staging/speakup/varhandlers.c
+++ b/drivers/staging/speakup/varhandlers.c
@@ -16,24 +16,24 @@ static struct st_var_header var_headers[] = {
 	{ "ex_num", EXNUMBER, VAR_PROC, NULL, NULL },
 	{ "characters", CHARS, VAR_PROC, NULL, NULL },
 	{ "synth_direct", SYNTH_DIRECT, VAR_PROC, NULL, NULL },
-	{ "caps_start", CAPS_START, VAR_STRING, str_caps_start, NULL },
-	{ "caps_stop", CAPS_STOP, VAR_STRING, str_caps_stop, NULL },
+	{ "caps_start", CAPS_START, VAR_STRING, spk_str_caps_start, NULL },
+	{ "caps_stop", CAPS_STOP, VAR_STRING, spk_str_caps_stop, NULL },
 	{ "delay_time", DELAY, VAR_TIME, NULL, NULL },
 	{ "trigger_time", TRIGGER, VAR_TIME, NULL, NULL },
 	{ "jiffy_delta", JIFFY, VAR_TIME, NULL, NULL },
 	{ "full_time", FULL, VAR_TIME, NULL, NULL },
-	{ "spell_delay", SPELL_DELAY, VAR_NUM, &spell_delay, NULL },
-	{ "bleeps", BLEEPS, VAR_NUM, &bleeps, NULL },
-	{ "attrib_bleep", ATTRIB_BLEEP, VAR_NUM, &attrib_bleep, NULL },
-	{ "bleep_time", BLEEP_TIME, VAR_TIME, &bleep_time, NULL },
+	{ "spell_delay", SPELL_DELAY, VAR_NUM, &spk_spell_delay, NULL },
+	{ "bleeps", BLEEPS, VAR_NUM, &spk_bleeps, NULL },
+	{ "attrib_bleep", ATTRIB_BLEEP, VAR_NUM, &spk_attrib_bleep, NULL },
+	{ "bleep_time", BLEEP_TIME, VAR_TIME, &spk_bleep_time, NULL },
 	{ "cursor_time", CURSOR_TIME, VAR_TIME, NULL, NULL },
-	{ "punc_level", PUNC_LEVEL, VAR_NUM, &punc_level, NULL },
-	{ "reading_punc", READING_PUNC, VAR_NUM, &reading_punc, NULL },
-	{ "say_control", SAY_CONTROL, VAR_NUM, &say_ctrl, NULL },
-	{ "say_word_ctl", SAY_WORD_CTL, VAR_NUM, &say_word_ctl, NULL },
-	{ "no_interrupt", NO_INTERRUPT, VAR_NUM, &no_intr, NULL },
-	{ "key_echo", KEY_ECHO, VAR_NUM, &key_echo, NULL },
-	{ "bell_pos", BELL_POS, VAR_NUM, &bell_pos, NULL },
+	{ "punc_level", PUNC_LEVEL, VAR_NUM, &spk_punc_level, NULL },
+	{ "reading_punc", READING_PUNC, VAR_NUM, &spk_reading_punc, NULL },
+	{ "say_control", SAY_CONTROL, VAR_NUM, &spk_say_ctrl, NULL },
+	{ "say_word_ctl", SAY_WORD_CTL, VAR_NUM, &spk_say_word_ctl, NULL },
+	{ "no_interrupt", NO_INTERRUPT, VAR_NUM, &spk_no_intr, NULL },
+	{ "key_echo", KEY_ECHO, VAR_NUM, &spk_key_echo, NULL },
+	{ "bell_pos", BELL_POS, VAR_NUM, &spk_bell_pos, NULL },
 	{ "rate", RATE, VAR_NUM, NULL, NULL },
 	{ "pitch", PITCH, VAR_NUM, NULL, NULL },
 	{ "vol", VOL, VAR_NUM, NULL, NULL },
@@ -58,7 +58,7 @@ static struct punc_var_t punc_vars[] = {
 	{ -1, -1 },
 };
 
-int chartab_get_value(char *keyword)
+int spk_chartab_get_value(char *keyword)
 {
 	int value = 0;
 
@@ -103,11 +103,11 @@ void speakup_register_var(struct var_t *var)
 	p_header->data = var;
 	switch (p_header->var_type) {
 	case VAR_STRING:
-		set_string_var(nothing, p_header, 0);
+		spk_set_string_var(nothing, p_header, 0);
 		break;
 	case VAR_NUM:
 	case VAR_TIME:
-		set_num_var(0, p_header, E_DEFAULT);
+		spk_set_num_var(0, p_header, E_DEFAULT);
 		break;
 	default:
 		break;
@@ -123,7 +123,7 @@ void speakup_unregister_var(enum var_id_t var_id)
 	p_header->data = NULL;
 }
 
-struct st_var_header *get_var_header(enum var_id_t var_id)
+struct st_var_header *spk_get_var_header(enum var_id_t var_id)
 {
 	struct st_var_header *p_header;
 	if (var_id < 0 || var_id >= MAXVARS)
@@ -134,7 +134,7 @@ struct st_var_header *get_var_header(enum var_id_t var_id)
 	return p_header;
 }
 
-struct st_var_header *var_header_by_name(const char *name)
+struct st_var_header *spk_var_header_by_name(const char *name)
 {
 	int i;
 	struct st_var_header *where = NULL;
@@ -151,15 +151,15 @@ struct st_var_header *var_header_by_name(const char *name)
 	return where;
 }
 
-struct var_t *get_var(enum var_id_t var_id)
+struct var_t *spk_get_var(enum var_id_t var_id)
 {
 	BUG_ON(var_id < 0 || var_id >= MAXVARS);
 	BUG_ON(!var_ptrs[var_id]);
 	return var_ptrs[var_id]->data;
 }
-EXPORT_SYMBOL_GPL(get_var);
+EXPORT_SYMBOL_GPL(spk_get_var);
 
-struct punc_var_t *get_punc_var(enum var_id_t var_id)
+struct punc_var_t *spk_get_punc_var(enum var_id_t var_id)
 {
 	struct punc_var_t *rv = NULL;
 	struct punc_var_t *where;
@@ -175,7 +175,7 @@ struct punc_var_t *get_punc_var(enum var_id_t var_id)
 }
 
 /* handlers for setting vars */
-int set_num_var(int input, struct st_var_header *var, int how)
+int spk_set_num_var(int input, struct st_var_header *var, int how)
 {
 	int val;
 	short ret = 0;
@@ -217,7 +217,7 @@ int set_num_var(int input, struct st_var_header *var, int how)
 	if (p_val != NULL)
 		*p_val = val;
 	if (var->var_id == PUNC_LEVEL) {
-		punc_mask = punc_masks[val];
+		spk_punc_mask = spk_punc_masks[val];
 		return ret;
 	}
 	if (var_data->u.n.multiplier != 0)
@@ -232,7 +232,7 @@ int set_num_var(int input, struct st_var_header *var, int how)
 	if (!var_data->u.n.synth_fmt)
 		return ret;
 	if (var->var_id == PITCH)
-		cp = pitch_buff;
+		cp = spk_pitch_buff;
 	else
 		cp = buf;
 	if (!var_data->u.n.out_str)
@@ -244,7 +244,7 @@ int set_num_var(int input, struct st_var_header *var, int how)
 	return ret;
 }
 
-int set_string_var(const char *page, struct st_var_header *var, int len)
+int spk_set_string_var(const char *page, struct st_var_header *var, int len)
 {
 	int ret = 0;
 	struct var_t *var_data = var->data;
@@ -267,21 +267,21 @@ int set_string_var(const char *page, struct st_var_header *var, int len)
 	return ret;
 }
 
-/* set_mask_bits sets or clears the punc/delim/repeat bits,
+/* spk_set_mask_bits sets or clears the punc/delim/repeat bits,
  * if input is null uses the defaults.
  * values for how: 0 clears bits of chars supplied,
  * 1 clears allk, 2 sets bits for chars */
-int set_mask_bits(const char *input, const int which, const int how)
+int spk_set_mask_bits(const char *input, const int which, const int how)
 {
 	u_char *cp;
-	short mask = punc_info[which].mask;
+	short mask = spk_punc_info[which].mask;
 	if (how&1) {
-		for (cp = (u_char *)punc_info[3].value; *cp; cp++)
+		for (cp = (u_char *)spk_punc_info[3].value; *cp; cp++)
 			spk_chartab[*cp] &= ~mask;
 	}
 	cp = (u_char *)input;
 	if (cp == 0)
-		cp = punc_info[which].value;
+		cp = spk_punc_info[which].value;
 	else {
 		for ( ; *cp; cp++) {
 			if (*cp < SPACE)
@@ -308,7 +308,7 @@ int set_mask_bits(const char *input, const int which, const int how)
 	return 0;
 }
 
-char *strlwr(char *s)
+char *spk_strlwr(char *s)
 {
 	char *p;
 	if (s == NULL)
@@ -341,7 +341,7 @@ char *speakup_s2i(char *start, int *dest)
 	return start;
 }
 
-char *s2uchar(char *start, char *dest)
+char *spk_s2uchar(char *start, char *dest)
 {
 	int val = 0;
 	while (*start && *start <= SPACE)
@@ -357,7 +357,7 @@ char *s2uchar(char *start, char *dest)
 	return start;
 }
 
-char *xlate(char *s)
+char *spk_xlate(char *s)
 {
 	static const char finds[] = "nrtvafe";
 	static const char subs[] = "\n\r\t\013\001\014\033";

commit a1277d85dc15a829d97b027de6e1f049c29a9306
Author: William Hubbs <w.d.hubbs@gmail.com>
Date:   Fri Oct 15 22:13:39 2010 -0500

    staging: speakup: varhandlers.c style fixes
    
    fix issues reported by checkpatch.pl
    
    Signed-off-by: William Hubbs <w.d.hubbs@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/speakup/varhandlers.c b/drivers/staging/speakup/varhandlers.c
index 2d137bd84df3..ab7de9389dd6 100644
--- a/drivers/staging/speakup/varhandlers.c
+++ b/drivers/staging/speakup/varhandlers.c
@@ -4,58 +4,58 @@
 #include "speakup.h"
 
 static struct st_var_header var_headers[] = {
-  { "version", VERSION, VAR_PROC, NULL, NULL },
-  { "synth_name", SYNTH, VAR_PROC, NULL, NULL },
-  { "keymap", KEYMAP, VAR_PROC, NULL, NULL },
-  { "silent", SILENT, VAR_PROC, NULL, NULL },
-  { "punc_some", PUNC_SOME, VAR_PROC, NULL, NULL },
-  { "punc_most", PUNC_MOST, VAR_PROC, NULL, NULL },
-  { "punc_all", PUNC_ALL, VAR_PROC, NULL, NULL },
-  { "delimiters", DELIM, VAR_PROC, NULL, NULL },
-  { "repeats", REPEATS, VAR_PROC, NULL, NULL },
-  { "ex_num", EXNUMBER, VAR_PROC, NULL, NULL },
-  { "characters", CHARS, VAR_PROC, NULL, NULL },
-  { "synth_direct", SYNTH_DIRECT, VAR_PROC, NULL, NULL },
-  { "caps_start", CAPS_START, VAR_STRING, str_caps_start, NULL },
-  { "caps_stop", CAPS_STOP, VAR_STRING, str_caps_stop, NULL },
-  { "delay_time", DELAY, VAR_TIME, NULL, NULL },
-  { "trigger_time", TRIGGER, VAR_TIME, NULL, NULL },
-  { "jiffy_delta", JIFFY, VAR_TIME, NULL, NULL },
-  { "full_time", FULL, VAR_TIME, NULL, NULL },
-  { "spell_delay", SPELL_DELAY, VAR_NUM, &spell_delay, NULL },
-  { "bleeps", BLEEPS, VAR_NUM, &bleeps, NULL },
-  { "attrib_bleep", ATTRIB_BLEEP, VAR_NUM, &attrib_bleep, NULL },
-  { "bleep_time", BLEEP_TIME, VAR_TIME, &bleep_time, NULL },
-  { "cursor_time", CURSOR_TIME, VAR_TIME, NULL, NULL },
-  { "punc_level", PUNC_LEVEL, VAR_NUM, &punc_level, NULL },
-  { "reading_punc", READING_PUNC, VAR_NUM, &reading_punc, NULL },
-  { "say_control", SAY_CONTROL, VAR_NUM, &say_ctrl, NULL },
-  { "say_word_ctl", SAY_WORD_CTL, VAR_NUM, &say_word_ctl, NULL },
-  { "no_interrupt", NO_INTERRUPT, VAR_NUM, &no_intr, NULL },
-  { "key_echo", KEY_ECHO, VAR_NUM, &key_echo, NULL },
-  { "bell_pos", BELL_POS, VAR_NUM, &bell_pos, NULL },
-  { "rate", RATE, VAR_NUM, NULL, NULL },
-  { "pitch", PITCH, VAR_NUM, NULL, NULL },
-  { "vol", VOL, VAR_NUM, NULL, NULL },
-  { "tone", TONE, VAR_NUM, NULL, NULL },
-  { "punct", PUNCT, VAR_NUM, NULL, NULL   },
-  { "voice", VOICE, VAR_NUM, NULL, NULL },
-  { "freq", FREQUENCY, VAR_NUM, NULL, NULL },
-  { "lang", LANG, VAR_NUM, NULL, NULL },
-  { "chartab", CHARTAB, VAR_PROC, NULL, NULL },
-  { "direct", DIRECT, VAR_NUM, NULL, NULL },
+	{ "version", VERSION, VAR_PROC, NULL, NULL },
+	{ "synth_name", SYNTH, VAR_PROC, NULL, NULL },
+	{ "keymap", KEYMAP, VAR_PROC, NULL, NULL },
+	{ "silent", SILENT, VAR_PROC, NULL, NULL },
+	{ "punc_some", PUNC_SOME, VAR_PROC, NULL, NULL },
+	{ "punc_most", PUNC_MOST, VAR_PROC, NULL, NULL },
+	{ "punc_all", PUNC_ALL, VAR_PROC, NULL, NULL },
+	{ "delimiters", DELIM, VAR_PROC, NULL, NULL },
+	{ "repeats", REPEATS, VAR_PROC, NULL, NULL },
+	{ "ex_num", EXNUMBER, VAR_PROC, NULL, NULL },
+	{ "characters", CHARS, VAR_PROC, NULL, NULL },
+	{ "synth_direct", SYNTH_DIRECT, VAR_PROC, NULL, NULL },
+	{ "caps_start", CAPS_START, VAR_STRING, str_caps_start, NULL },
+	{ "caps_stop", CAPS_STOP, VAR_STRING, str_caps_stop, NULL },
+	{ "delay_time", DELAY, VAR_TIME, NULL, NULL },
+	{ "trigger_time", TRIGGER, VAR_TIME, NULL, NULL },
+	{ "jiffy_delta", JIFFY, VAR_TIME, NULL, NULL },
+	{ "full_time", FULL, VAR_TIME, NULL, NULL },
+	{ "spell_delay", SPELL_DELAY, VAR_NUM, &spell_delay, NULL },
+	{ "bleeps", BLEEPS, VAR_NUM, &bleeps, NULL },
+	{ "attrib_bleep", ATTRIB_BLEEP, VAR_NUM, &attrib_bleep, NULL },
+	{ "bleep_time", BLEEP_TIME, VAR_TIME, &bleep_time, NULL },
+	{ "cursor_time", CURSOR_TIME, VAR_TIME, NULL, NULL },
+	{ "punc_level", PUNC_LEVEL, VAR_NUM, &punc_level, NULL },
+	{ "reading_punc", READING_PUNC, VAR_NUM, &reading_punc, NULL },
+	{ "say_control", SAY_CONTROL, VAR_NUM, &say_ctrl, NULL },
+	{ "say_word_ctl", SAY_WORD_CTL, VAR_NUM, &say_word_ctl, NULL },
+	{ "no_interrupt", NO_INTERRUPT, VAR_NUM, &no_intr, NULL },
+	{ "key_echo", KEY_ECHO, VAR_NUM, &key_echo, NULL },
+	{ "bell_pos", BELL_POS, VAR_NUM, &bell_pos, NULL },
+	{ "rate", RATE, VAR_NUM, NULL, NULL },
+	{ "pitch", PITCH, VAR_NUM, NULL, NULL },
+	{ "vol", VOL, VAR_NUM, NULL, NULL },
+	{ "tone", TONE, VAR_NUM, NULL, NULL },
+	{ "punct", PUNCT, VAR_NUM, NULL, NULL   },
+	{ "voice", VOICE, VAR_NUM, NULL, NULL },
+	{ "freq", FREQUENCY, VAR_NUM, NULL, NULL },
+	{ "lang", LANG, VAR_NUM, NULL, NULL },
+	{ "chartab", CHARTAB, VAR_PROC, NULL, NULL },
+	{ "direct", DIRECT, VAR_NUM, NULL, NULL },
 };
 
 static struct st_var_header *var_ptrs[MAXVARS] = { 0, 0, 0 };
 
 static struct punc_var_t punc_vars[] = {
- { PUNC_SOME, 1 },
- { PUNC_MOST, 2 },
- { PUNC_ALL, 3 },
- { DELIM, 4 },
- { REPEATS, 5 },
- { EXNUMBER, 6 },
- { -1, -1 },
+	{ PUNC_SOME, 1 },
+	{ PUNC_MOST, 2 },
+	{ PUNC_ALL, 3 },
+	{ DELIM, 4 },
+	{ REPEATS, 5 },
+	{ EXNUMBER, 6 },
+	{ -1, -1 },
 };
 
 int chartab_get_value(char *keyword)
@@ -154,8 +154,8 @@ struct st_var_header *var_header_by_name(const char *name)
 struct var_t *get_var(enum var_id_t var_id)
 {
 	BUG_ON(var_id < 0 || var_id >= MAXVARS);
-	BUG_ON(! var_ptrs[var_id]);
-	return (var_ptrs[var_id]->data);
+	BUG_ON(!var_ptrs[var_id]);
+	return var_ptrs[var_id]->data;
 }
 EXPORT_SYMBOL_GPL(get_var);
 
@@ -238,7 +238,8 @@ int set_num_var(int input, struct st_var_header *var, int how)
 	if (!var_data->u.n.out_str)
 		l = sprintf(cp, var_data->u.n.synth_fmt, (int)val);
 	else
-		l = sprintf(cp, var_data->u.n.synth_fmt, var_data->u.n.out_str[val]);
+		l = sprintf(cp,
+			var_data->u.n.synth_fmt, var_data->u.n.out_str[val]);
 	synth_printf("%s", cp);
 	return ret;
 }
@@ -252,15 +253,15 @@ int set_string_var(const char *page, struct st_var_header *var, int len)
 	if (len > MAXVARLEN)
 		return -E_TOOLONG;
 	if (!len) {
-	if (!var_data->u.s.default_val)
-		return 0;
+		if (!var_data->u.s.default_val)
+			return 0;
 		ret = SET_DEFAULT;
 		if (!var->p_val)
 			var->p_val = var_data->u.s.default_val;
 		if (var->p_val != var_data->u.s.default_val)
 			strcpy((char *)var->p_val, var_data->u.s.default_val);
-		} else if (var->p_val)
-			strcpy((char *)var->p_val, page);
+	} else if (var->p_val)
+		strcpy((char *)var->p_val, page);
 	else
 		return -E_TOOLONG;
 	return ret;

commit c6e3fd22cd538365bfeb82997d5b89562e077d42
Author: William Hubbs <w.d.hubbs@gmail.com>
Date:   Thu Oct 7 13:20:02 2010 -0500

    Staging: add speakup to the staging directory
    
    Speakup is a kernel based screen review package for the linux operating
    system.  It allows blind users to interact with applications on the
    linux console by means of synthetic speech.
    
    The authors and maintainers of this code include the following:
    
    Kirk Reiser, Andy Berdan, John Covici, Brian and
    David Borowski, Christopher Brannon, Samuel Thibault and William Hubbs.
    
    Signed-off-by: William Hubbs <w.d.hubbs@gmail.com>
    Signed-off-by: Samuel Thibault <samuel.thibault@ens-lyon.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/staging/speakup/varhandlers.c b/drivers/staging/speakup/varhandlers.c
new file mode 100644
index 000000000000..2d137bd84df3
--- /dev/null
+++ b/drivers/staging/speakup/varhandlers.c
@@ -0,0 +1,403 @@
+#include <linux/ctype.h>
+#include "spk_types.h"
+#include "spk_priv.h"
+#include "speakup.h"
+
+static struct st_var_header var_headers[] = {
+  { "version", VERSION, VAR_PROC, NULL, NULL },
+  { "synth_name", SYNTH, VAR_PROC, NULL, NULL },
+  { "keymap", KEYMAP, VAR_PROC, NULL, NULL },
+  { "silent", SILENT, VAR_PROC, NULL, NULL },
+  { "punc_some", PUNC_SOME, VAR_PROC, NULL, NULL },
+  { "punc_most", PUNC_MOST, VAR_PROC, NULL, NULL },
+  { "punc_all", PUNC_ALL, VAR_PROC, NULL, NULL },
+  { "delimiters", DELIM, VAR_PROC, NULL, NULL },
+  { "repeats", REPEATS, VAR_PROC, NULL, NULL },
+  { "ex_num", EXNUMBER, VAR_PROC, NULL, NULL },
+  { "characters", CHARS, VAR_PROC, NULL, NULL },
+  { "synth_direct", SYNTH_DIRECT, VAR_PROC, NULL, NULL },
+  { "caps_start", CAPS_START, VAR_STRING, str_caps_start, NULL },
+  { "caps_stop", CAPS_STOP, VAR_STRING, str_caps_stop, NULL },
+  { "delay_time", DELAY, VAR_TIME, NULL, NULL },
+  { "trigger_time", TRIGGER, VAR_TIME, NULL, NULL },
+  { "jiffy_delta", JIFFY, VAR_TIME, NULL, NULL },
+  { "full_time", FULL, VAR_TIME, NULL, NULL },
+  { "spell_delay", SPELL_DELAY, VAR_NUM, &spell_delay, NULL },
+  { "bleeps", BLEEPS, VAR_NUM, &bleeps, NULL },
+  { "attrib_bleep", ATTRIB_BLEEP, VAR_NUM, &attrib_bleep, NULL },
+  { "bleep_time", BLEEP_TIME, VAR_TIME, &bleep_time, NULL },
+  { "cursor_time", CURSOR_TIME, VAR_TIME, NULL, NULL },
+  { "punc_level", PUNC_LEVEL, VAR_NUM, &punc_level, NULL },
+  { "reading_punc", READING_PUNC, VAR_NUM, &reading_punc, NULL },
+  { "say_control", SAY_CONTROL, VAR_NUM, &say_ctrl, NULL },
+  { "say_word_ctl", SAY_WORD_CTL, VAR_NUM, &say_word_ctl, NULL },
+  { "no_interrupt", NO_INTERRUPT, VAR_NUM, &no_intr, NULL },
+  { "key_echo", KEY_ECHO, VAR_NUM, &key_echo, NULL },
+  { "bell_pos", BELL_POS, VAR_NUM, &bell_pos, NULL },
+  { "rate", RATE, VAR_NUM, NULL, NULL },
+  { "pitch", PITCH, VAR_NUM, NULL, NULL },
+  { "vol", VOL, VAR_NUM, NULL, NULL },
+  { "tone", TONE, VAR_NUM, NULL, NULL },
+  { "punct", PUNCT, VAR_NUM, NULL, NULL   },
+  { "voice", VOICE, VAR_NUM, NULL, NULL },
+  { "freq", FREQUENCY, VAR_NUM, NULL, NULL },
+  { "lang", LANG, VAR_NUM, NULL, NULL },
+  { "chartab", CHARTAB, VAR_PROC, NULL, NULL },
+  { "direct", DIRECT, VAR_NUM, NULL, NULL },
+};
+
+static struct st_var_header *var_ptrs[MAXVARS] = { 0, 0, 0 };
+
+static struct punc_var_t punc_vars[] = {
+ { PUNC_SOME, 1 },
+ { PUNC_MOST, 2 },
+ { PUNC_ALL, 3 },
+ { DELIM, 4 },
+ { REPEATS, 5 },
+ { EXNUMBER, 6 },
+ { -1, -1 },
+};
+
+int chartab_get_value(char *keyword)
+{
+	int value = 0;
+
+	if (!strcmp(keyword, "ALPHA"))
+		value = ALPHA;
+	else if (!strcmp(keyword, "B_CTL"))
+		value = B_CTL;
+	else if (!strcmp(keyword, "WDLM"))
+		value = WDLM;
+	else if (!strcmp(keyword, "A_PUNC"))
+		value = A_PUNC;
+	else if (!strcmp(keyword, "PUNC"))
+		value = PUNC;
+	else if (!strcmp(keyword, "NUM"))
+		value = NUM;
+	else if (!strcmp(keyword, "A_CAP"))
+		value = A_CAP;
+	else if (!strcmp(keyword, "B_CAPSYM"))
+		value = B_CAPSYM;
+	else if (!strcmp(keyword, "B_SYM"))
+		value = B_SYM;
+	return value;
+}
+
+void speakup_register_var(struct var_t *var)
+{
+	static char nothing[2] = "\0";
+	int i;
+	struct st_var_header *p_header;
+
+	BUG_ON(!var || var->var_id < 0 || var->var_id >= MAXVARS);
+	if (var_ptrs[0] == NULL) {
+		for (i = 0; i < MAXVARS; i++) {
+			p_header = &var_headers[i];
+			var_ptrs[p_header->var_id] = p_header;
+			p_header->data = NULL;
+		}
+	}
+	p_header = var_ptrs[var->var_id];
+	if (p_header->data != NULL)
+		return;
+	p_header->data = var;
+	switch (p_header->var_type) {
+	case VAR_STRING:
+		set_string_var(nothing, p_header, 0);
+		break;
+	case VAR_NUM:
+	case VAR_TIME:
+		set_num_var(0, p_header, E_DEFAULT);
+		break;
+	default:
+		break;
+	}
+	return;
+}
+
+void speakup_unregister_var(enum var_id_t var_id)
+{
+	struct st_var_header *p_header;
+	BUG_ON(var_id < 0 || var_id >= MAXVARS);
+	p_header = var_ptrs[var_id];
+	p_header->data = NULL;
+}
+
+struct st_var_header *get_var_header(enum var_id_t var_id)
+{
+	struct st_var_header *p_header;
+	if (var_id < 0 || var_id >= MAXVARS)
+		return NULL;
+	p_header = var_ptrs[var_id];
+	if (p_header->data == NULL)
+		return NULL;
+	return p_header;
+}
+
+struct st_var_header *var_header_by_name(const char *name)
+{
+	int i;
+	struct st_var_header *where = NULL;
+
+	if (name != NULL) {
+		i = 0;
+		while ((i < MAXVARS) && (where == NULL)) {
+			if (strcmp(name, var_ptrs[i]->name) == 0)
+				where = var_ptrs[i];
+			else
+				i++;
+		}
+	}
+	return where;
+}
+
+struct var_t *get_var(enum var_id_t var_id)
+{
+	BUG_ON(var_id < 0 || var_id >= MAXVARS);
+	BUG_ON(! var_ptrs[var_id]);
+	return (var_ptrs[var_id]->data);
+}
+EXPORT_SYMBOL_GPL(get_var);
+
+struct punc_var_t *get_punc_var(enum var_id_t var_id)
+{
+	struct punc_var_t *rv = NULL;
+	struct punc_var_t *where;
+
+	where = punc_vars;
+	while ((where->var_id != -1) && (rv == NULL)) {
+		if (where->var_id == var_id)
+			rv = where;
+		else
+			where++;
+	}
+	return rv;
+}
+
+/* handlers for setting vars */
+int set_num_var(int input, struct st_var_header *var, int how)
+{
+	int val;
+	short ret = 0;
+	int *p_val = var->p_val;
+	int l;
+	char buf[32];
+	char *cp;
+	struct var_t *var_data = var->data;
+	if (var_data == NULL)
+		return E_UNDEF;
+
+	if (how == E_NEW_DEFAULT) {
+		if (input < var_data->u.n.low || input > var_data->u.n.high)
+			ret = E_RANGE;
+		else
+			var_data->u.n.default_val = input;
+		return ret;
+	}
+	if (how == E_DEFAULT) {
+		val = var_data->u.n.default_val;
+		ret = SET_DEFAULT;
+	} else {
+		if (how == E_SET)
+			val = input;
+		else
+			val = var_data->u.n.value;
+		if (how == E_INC)
+			val += input;
+		else if (how == E_DEC)
+			val -= input;
+		if (val < var_data->u.n.low || val > var_data->u.n.high)
+			return E_RANGE;
+	}
+	var_data->u.n.value = val;
+	if (var->var_type == VAR_TIME && p_val != NULL) {
+		*p_val = msecs_to_jiffies(val);
+		return ret;
+	}
+	if (p_val != NULL)
+		*p_val = val;
+	if (var->var_id == PUNC_LEVEL) {
+		punc_mask = punc_masks[val];
+		return ret;
+	}
+	if (var_data->u.n.multiplier != 0)
+		val *= var_data->u.n.multiplier;
+	val += var_data->u.n.offset;
+	if (var->var_id < FIRST_SYNTH_VAR || synth == NULL)
+		return ret;
+	if (synth->synth_adjust != NULL) {
+		int status = synth->synth_adjust(var);
+		return (status != 0) ? status : ret;
+	}
+	if (!var_data->u.n.synth_fmt)
+		return ret;
+	if (var->var_id == PITCH)
+		cp = pitch_buff;
+	else
+		cp = buf;
+	if (!var_data->u.n.out_str)
+		l = sprintf(cp, var_data->u.n.synth_fmt, (int)val);
+	else
+		l = sprintf(cp, var_data->u.n.synth_fmt, var_data->u.n.out_str[val]);
+	synth_printf("%s", cp);
+	return ret;
+}
+
+int set_string_var(const char *page, struct st_var_header *var, int len)
+{
+	int ret = 0;
+	struct var_t *var_data = var->data;
+	if (var_data == NULL)
+		return E_UNDEF;
+	if (len > MAXVARLEN)
+		return -E_TOOLONG;
+	if (!len) {
+	if (!var_data->u.s.default_val)
+		return 0;
+		ret = SET_DEFAULT;
+		if (!var->p_val)
+			var->p_val = var_data->u.s.default_val;
+		if (var->p_val != var_data->u.s.default_val)
+			strcpy((char *)var->p_val, var_data->u.s.default_val);
+		} else if (var->p_val)
+			strcpy((char *)var->p_val, page);
+	else
+		return -E_TOOLONG;
+	return ret;
+}
+
+/* set_mask_bits sets or clears the punc/delim/repeat bits,
+ * if input is null uses the defaults.
+ * values for how: 0 clears bits of chars supplied,
+ * 1 clears allk, 2 sets bits for chars */
+int set_mask_bits(const char *input, const int which, const int how)
+{
+	u_char *cp;
+	short mask = punc_info[which].mask;
+	if (how&1) {
+		for (cp = (u_char *)punc_info[3].value; *cp; cp++)
+			spk_chartab[*cp] &= ~mask;
+	}
+	cp = (u_char *)input;
+	if (cp == 0)
+		cp = punc_info[which].value;
+	else {
+		for ( ; *cp; cp++) {
+			if (*cp < SPACE)
+				break;
+			if (mask < PUNC) {
+				if (!(spk_chartab[*cp]&PUNC))
+					break;
+			} else if (spk_chartab[*cp]&B_NUM)
+				break;
+		}
+		if (*cp)
+			return -EINVAL;
+		cp = (u_char *)input;
+	}
+	if (how&2) {
+		for ( ; *cp; cp++)
+			if (*cp > SPACE)
+				spk_chartab[*cp] |= mask;
+	} else {
+		for ( ; *cp; cp++)
+			if (*cp > SPACE)
+				spk_chartab[*cp] &= ~mask;
+	}
+	return 0;
+}
+
+char *strlwr(char *s)
+{
+	char *p;
+	if (s == NULL)
+		return NULL;
+
+	for (p = s; *p; p++)
+		*p = tolower(*p);
+	return s;
+}
+
+char *speakup_s2i(char *start, int *dest)
+{
+	int val;
+	char ch = *start;
+	if (ch == '-' || ch == '+')
+		start++;
+	if (*start < '0' || *start > '9')
+		return start;
+	val = (*start) - '0';
+	start++;
+	while (*start >= '0' && *start <= '9') {
+		val *= 10;
+		val += (*start) - '0';
+		start++;
+	}
+	if (ch == '-')
+		*dest = -val;
+	else
+		*dest = val;
+	return start;
+}
+
+char *s2uchar(char *start, char *dest)
+{
+	int val = 0;
+	while (*start && *start <= SPACE)
+		start++;
+	while (*start >= '0' && *start <= '9') {
+		val *= 10;
+		val += (*start) - '0';
+		start++;
+	}
+	if (*start == ',')
+		start++;
+	*dest = (u_char)val;
+	return start;
+}
+
+char *xlate(char *s)
+{
+	static const char finds[] = "nrtvafe";
+	static const char subs[] = "\n\r\t\013\001\014\033";
+	static const char hx[] = "0123456789abcdefABCDEF";
+	char *p = s, *p1, *p2, c;
+	int num;
+	while ((p = strchr(p, '\\'))) {
+		p1 = p+1;
+		p2 = strchr(finds, *p1);
+		if (p2) {
+			*p++ = subs[p2-finds];
+			p1++;
+		} else if (*p1 >= '0' && *p1 <= '7') {
+			num = (*p1++)&7;
+			while (num < 256 && *p1 >= '0' && *p1 <= '7') {
+				num <<= 3;
+				num = (*p1++)&7;
+			}
+			*p++ = num;
+		} else if (*p1 == 'x' &&
+				strchr(hx, p1[1]) && strchr(hx, p1[2])) {
+			p1++;
+			c = *p1++;
+			if (c > '9')
+				c = (c - '7') & 0x0f;
+			else
+				c -= '0';
+			num = c << 4;
+			c = *p1++;
+			if (c > '9')
+				c = (c-'7')&0x0f;
+			else
+				c -= '0';
+			num += c;
+			*p++ = num;
+		} else
+			*p++ = *p1++;
+		p2 = p;
+		while (*p1)
+			*p2++ = *p1++;
+		*p2 = '\0';
+	}
+	return s;
+}
