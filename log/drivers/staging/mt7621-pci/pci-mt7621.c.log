commit 8220be592d82637e3f7ac269eb9d33a247e942b6
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Mon Apr 13 17:50:18 2020 +0200

    staging: mt7621-pci: initialize 'n' variable when it is declared
    
    Variable 'n' in 'mt7621_pcie_init_virtual_bridges' function
    can be directly initialized when it is declared instead of
    doing it before using it first.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Link: https://lore.kernel.org/r/20200413155018.31921-3-sergio.paracuellos@gmail.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/mt7621-pci/pci-mt7621.c b/drivers/staging/mt7621-pci/pci-mt7621.c
index eede8d9268ac..f961b353c22e 100644
--- a/drivers/staging/mt7621-pci/pci-mt7621.c
+++ b/drivers/staging/mt7621-pci/pci-mt7621.c
@@ -605,7 +605,7 @@ static void mt7621_pcie_enable_ports(struct mt7621_pcie *pcie)
 static int mt7621_pcie_init_virtual_bridges(struct mt7621_pcie *pcie)
 {
 	u32 pcie_link_status = 0;
-	u32 n;
+	u32 n = 0;
 	int i = 0;
 	u32 p2p_br_devnum[PCIE_P2P_CNT];
 	int irqs[PCIE_P2P_CNT];
@@ -627,7 +627,6 @@ static int mt7621_pcie_init_virtual_bridges(struct mt7621_pcie *pcie)
 	 * then assigning remaining device numbers to any disabled
 	 * ports.
 	 */
-	n = 0;
 	for (i = 0; i < PCIE_P2P_CNT; i++)
 		if (pcie_link_status & BIT(i))
 			p2p_br_devnum[i] = n++;

commit cddc585ec92c074025d2d76bc0f6ec120e44fe8a
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Mon Apr 13 17:50:17 2020 +0200

    staging: mt7621-pci: add clarification comment in 'mt7621_pcie_init_virtual_bridges'
    
    Add a comment explaining a bit what is going on in this function.
    It would be helfulp for other people for a better understanding
    of the code.
    
    Suggested-by: NeilBrown <neil@brown.name>
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Link: https://lore.kernel.org/r/20200413155018.31921-2-sergio.paracuellos@gmail.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/mt7621-pci/pci-mt7621.c b/drivers/staging/mt7621-pci/pci-mt7621.c
index 6a9f4b6cdd93..eede8d9268ac 100644
--- a/drivers/staging/mt7621-pci/pci-mt7621.c
+++ b/drivers/staging/mt7621-pci/pci-mt7621.c
@@ -622,6 +622,11 @@ static int mt7621_pcie_init_virtual_bridges(struct mt7621_pcie *pcie)
 	if (pcie_link_status == 0)
 		return -1;
 
+	/*
+	 * Assign device numbers from zero to the enabled ports,
+	 * then assigning remaining device numbers to any disabled
+	 * ports.
+	 */
 	n = 0;
 	for (i = 0; i < PCIE_P2P_CNT; i++)
 		if (pcie_link_status & BIT(i))

commit 535bd126d65364b51d9bdeccf584979b7ff1ded3
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Mon Apr 13 17:50:16 2020 +0200

    staging: mt7621-pci: rename 'PCIE_P2P_MAX' into 'PCIE_P2P_CNT'
    
    Definition 'PCIE_P2P_MAX' is '3'. The value here is not a MAXimum.
    It is a count or a number. It is how many masks there are.
    The masks are numbered 0, 1, 2 so the maximum is 2. Hence rename
    variable into 'PCIE_P2P_CNT' which is a more accurate name.
    
    Suggested-by: NeilBrown <neil@brown.name>
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Link: https://lore.kernel.org/r/20200413155018.31921-1-sergio.paracuellos@gmail.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/mt7621-pci/pci-mt7621.c b/drivers/staging/mt7621-pci/pci-mt7621.c
index 36207243a71b..6a9f4b6cdd93 100644
--- a/drivers/staging/mt7621-pci/pci-mt7621.c
+++ b/drivers/staging/mt7621-pci/pci-mt7621.c
@@ -55,7 +55,7 @@
 #define RALINK_PCI_IOBASE		0x002C
 
 /* PCICFG virtual bridges */
-#define PCIE_P2P_MAX			3
+#define PCIE_P2P_CNT			3
 #define PCIE_P2P_BR_DEVNUM_SHIFT(p)	(16 + (p) * 4)
 #define PCIE_P2P_BR_DEVNUM0_SHIFT	PCIE_P2P_BR_DEVNUM_SHIFT(0)
 #define PCIE_P2P_BR_DEVNUM1_SHIFT	PCIE_P2P_BR_DEVNUM_SHIFT(1)
@@ -138,7 +138,7 @@ struct mt7621_pcie {
 	} offset;
 	unsigned long io_map_base;
 	struct list_head ports;
-	int irq_map[PCIE_P2P_MAX];
+	int irq_map[PCIE_P2P_CNT];
 	bool resets_inverted;
 };
 
@@ -607,8 +607,8 @@ static int mt7621_pcie_init_virtual_bridges(struct mt7621_pcie *pcie)
 	u32 pcie_link_status = 0;
 	u32 n;
 	int i = 0;
-	u32 p2p_br_devnum[PCIE_P2P_MAX];
-	int irqs[PCIE_P2P_MAX];
+	u32 p2p_br_devnum[PCIE_P2P_CNT];
+	int irqs[PCIE_P2P_CNT];
 	struct mt7621_pcie_port *port;
 
 	list_for_each_entry(port, &pcie->ports, list) {
@@ -623,11 +623,11 @@ static int mt7621_pcie_init_virtual_bridges(struct mt7621_pcie *pcie)
 		return -1;
 
 	n = 0;
-	for (i = 0; i < PCIE_P2P_MAX; i++)
+	for (i = 0; i < PCIE_P2P_CNT; i++)
 		if (pcie_link_status & BIT(i))
 			p2p_br_devnum[i] = n++;
 
-	for (i = 0; i < PCIE_P2P_MAX; i++)
+	for (i = 0; i < PCIE_P2P_CNT; i++)
 		if ((pcie_link_status & BIT(i)) == 0)
 			p2p_br_devnum[i] = n++;
 
@@ -639,11 +639,11 @@ static int mt7621_pcie_init_virtual_bridges(struct mt7621_pcie *pcie)
 
 	/* Assign IRQs */
 	n = 0;
-	for (i = 0; i < PCIE_P2P_MAX; i++)
+	for (i = 0; i < PCIE_P2P_CNT; i++)
 		if (pcie_link_status & BIT(i))
 			pcie->irq_map[n++] = irqs[i];
 
-	for (i = n; i < PCIE_P2P_MAX; i++)
+	for (i = n; i < PCIE_P2P_CNT; i++)
 		pcie->irq_map[i] = -1;
 
 	return 0;

commit fab6710e4c51f4eb622f95a08322ab5fdbe3f295
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Mon Apr 13 07:59:42 2020 +0200

    staging: mt7621-pci: fix PCIe interrupt mapping
    
    MT7621 has three assigned interrupts for the pcie. This
    interrupts should properly being mapped taking into account
    which devices are finally connected in which bus according
    to link status. So the irq mappings should be as follows
    according to link status (three bits indicating which devices
    are link up):
    
    * For PCIe Bus 1 slot 0:
      - status = 0x2 || status = 0x6 => IRQ = pcie1_irq (24).
      - status = 0x4 => IRQ = pcie2_irq (25).
      - default => IRQ = pcie0_irq (23).
    * For PCIe Bus 2 slot 0:
      - status = 0x5 || status = 0x6 => IRQ = pcie2_irq (25).
      - default => IRQ = pcie1_irq (24).
    * For PCIe Bus 2 slot 1:
      - status = 0x5 || status = 0x6 => IRQ = pcie2_irq (25).
      - default => IRQ = pcie1_irq (24).
    * For PCIe Bus 3 any slot:
      - default => IRQ = pcie2_irq (25).
    
    Because of this, the function 'of_irq_parse_and_map_pci' cannot
    be used and we need to change device tree information from using
    the 'interrupt-map' and 'interrupt-map-mask' properties into an
    'interrupts' property to be able to get irq information from the
    ports using the 'platform_get_irq' and storing an 'irq-map' into
    the pcie driver data node to properly map correct irq using a
    new 'mt7621_map_irq' function where this map will be read and the
    correct irq returned.
    
    Fixes: 46d093124df4 ("staging: mt7621-pci: improve interrupt mapping")
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Link: https://lore.kernel.org/r/20200413055942.2714-1-sergio.paracuellos@gmail.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/mt7621-pci/pci-mt7621.c b/drivers/staging/mt7621-pci/pci-mt7621.c
index b9d460a9c041..36207243a71b 100644
--- a/drivers/staging/mt7621-pci/pci-mt7621.c
+++ b/drivers/staging/mt7621-pci/pci-mt7621.c
@@ -97,6 +97,7 @@
  * @pcie_rst: pointer to port reset control
  * @gpio_rst: gpio reset
  * @slot: port slot
+ * @irq: GIC irq
  * @enabled: indicates if port is enabled
  */
 struct mt7621_pcie_port {
@@ -107,6 +108,7 @@ struct mt7621_pcie_port {
 	struct reset_control *pcie_rst;
 	struct gpio_desc *gpio_rst;
 	u32 slot;
+	int irq;
 	bool enabled;
 };
 
@@ -120,6 +122,7 @@ struct mt7621_pcie_port {
  * @dev: Pointer to PCIe device
  * @io_map_base: virtual memory base address for io
  * @ports: pointer to PCIe port information
+ * @irq_map: irq mapping info according pcie link status
  * @resets_inverted: depends on chip revision
  * reset lines are inverted.
  */
@@ -135,6 +138,7 @@ struct mt7621_pcie {
 	} offset;
 	unsigned long io_map_base;
 	struct list_head ports;
+	int irq_map[PCIE_P2P_MAX];
 	bool resets_inverted;
 };
 
@@ -279,6 +283,16 @@ static void setup_cm_memory_region(struct mt7621_pcie *pcie)
 	}
 }
 
+static int mt7621_map_irq(const struct pci_dev *pdev, u8 slot, u8 pin)
+{
+	struct mt7621_pcie *pcie = pdev->bus->sysdata;
+	struct device *dev = pcie->dev;
+	int irq = pcie->irq_map[slot];
+
+	dev_info(dev, "bus=%d slot=%d irq=%d\n", pdev->bus->number, slot, irq);
+	return irq;
+}
+
 static int mt7621_pci_parse_request_of_pci_ranges(struct mt7621_pcie *pcie)
 {
 	struct device *dev = pcie->dev;
@@ -330,6 +344,7 @@ static int mt7621_pcie_parse_port(struct mt7621_pcie *pcie,
 {
 	struct mt7621_pcie_port *port;
 	struct device *dev = pcie->dev;
+	struct platform_device *pdev = to_platform_device(dev);
 	struct device_node *pnode = dev->of_node;
 	struct resource regs;
 	char name[10];
@@ -371,6 +386,12 @@ static int mt7621_pcie_parse_port(struct mt7621_pcie *pcie,
 	port->slot = slot;
 	port->pcie = pcie;
 
+	port->irq = platform_get_irq(pdev, slot);
+	if (port->irq < 0) {
+		dev_err(dev, "Failed to get IRQ for PCIe%d\n", slot);
+		return -ENXIO;
+	}
+
 	INIT_LIST_HEAD(&port->list);
 	list_add_tail(&port->list, &pcie->ports);
 
@@ -585,13 +606,15 @@ static int mt7621_pcie_init_virtual_bridges(struct mt7621_pcie *pcie)
 {
 	u32 pcie_link_status = 0;
 	u32 n;
-	int i;
+	int i = 0;
 	u32 p2p_br_devnum[PCIE_P2P_MAX];
+	int irqs[PCIE_P2P_MAX];
 	struct mt7621_pcie_port *port;
 
 	list_for_each_entry(port, &pcie->ports, list) {
 		u32 slot = port->slot;
 
+		irqs[i++] = port->irq;
 		if (port->enabled)
 			pcie_link_status |= BIT(slot);
 	}
@@ -614,6 +637,15 @@ static int mt7621_pcie_init_virtual_bridges(struct mt7621_pcie *pcie)
 		 (p2p_br_devnum[1] << PCIE_P2P_BR_DEVNUM1_SHIFT) |
 		 (p2p_br_devnum[2] << PCIE_P2P_BR_DEVNUM2_SHIFT));
 
+	/* Assign IRQs */
+	n = 0;
+	for (i = 0; i < PCIE_P2P_MAX; i++)
+		if (pcie_link_status & BIT(i))
+			pcie->irq_map[n++] = irqs[i];
+
+	for (i = n; i < PCIE_P2P_MAX; i++)
+		pcie->irq_map[i] = -1;
+
 	return 0;
 }
 
@@ -638,7 +670,7 @@ static int mt7621_pcie_register_host(struct pci_host_bridge *host,
 	host->busnr = pcie->busn.start;
 	host->dev.parent = pcie->dev;
 	host->ops = &mt7621_pci_ops;
-	host->map_irq = of_irq_parse_and_map_pci;
+	host->map_irq = mt7621_map_irq;
 	host->swizzle_irq = pci_common_swizzle;
 	host->sysdata = pcie;
 

commit 5fcded5e857cf66c9592e4be28c4dab4520c9177
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Thu Apr 9 13:16:52 2020 +0200

    staging: mt7621-pci: properly power off dual-ported pcie phy
    
    Pcie phy for pcie0 and pcie1 is shared using a dual ported
    one. Current code was assuming that if nothing is connected
    in pcie0 it won't be also nothing connected in pcie1. This
    assumtion is wrong for some devices such us 'Mikrotik rbm33g'
    and 'ZyXEL LTE3301-PLUS' where only connecting a card to the
    second bus on the phy is possible. For such devices kernel
    hangs in the same point because of the wrong poweroff of the
    phy getting the following trace:
    
    mt7621-pci-phy 1e149000.pcie-phy: PHY for 0xbe149000 (dual port = 1)
    mt7621-pci-phy 1e14a000.pcie-phy: PHY for 0xbe14a000 (dual port = 0)
    mt7621-pci-phy 1e149000.pcie-phy: Xtal is 40MHz
    mt7621-pci-phy 1e14a000.pcie-phy: Xtal is 40MHz
    mt7621-pci 1e140000.pcie: pcie0 no card, disable it (RST & CLK)
    [hangs]
    
    The wrong assumption is located in the 'mt7621_pcie_init_ports'
    function where we are just making a power off of the phy for
    slots 0 and 2 if nothing is connected in them. Hence, only
    poweroff the phy if nothing is connected in both slot 0 and
    slot 1 avoiding the kernel to hang.
    
    Fixes: 5737cfe87a9c ("staging: mt7621-pci: avoid to poweroff the phy for slot one")
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Link: https://lore.kernel.org/r/20200409111652.30964-1-sergio.paracuellos@gmail.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/mt7621-pci/pci-mt7621.c b/drivers/staging/mt7621-pci/pci-mt7621.c
index f58e3a51fc71..b9d460a9c041 100644
--- a/drivers/staging/mt7621-pci/pci-mt7621.c
+++ b/drivers/staging/mt7621-pci/pci-mt7621.c
@@ -502,17 +502,25 @@ static void mt7621_pcie_init_ports(struct mt7621_pcie *pcie)
 
 	mt7621_pcie_reset_ep_deassert(pcie);
 
+	tmp = NULL;
 	list_for_each_entry(port, &pcie->ports, list) {
 		u32 slot = port->slot;
 
 		if (!mt7621_pcie_port_is_linkup(port)) {
 			dev_err(dev, "pcie%d no card, disable it (RST & CLK)\n",
 				slot);
-			if (slot != 1)
-				phy_power_off(port->phy);
 			mt7621_control_assert(port);
 			mt7621_pcie_port_clk_disable(port);
 			port->enabled = false;
+
+			if (slot == 0) {
+				tmp = port;
+				continue;
+			}
+
+			if (slot == 1 && tmp && !tmp->enabled)
+				phy_power_off(tmp->phy);
+
 		}
 	}
 }

commit 4bc0659d711294096efdb15880e3a1a8589c335a
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Sun Mar 22 08:21:28 2020 +0100

    staging: mt7621-pci: avoid to set 'iomem_resource' addresses
    
    Setting up kernel resource 'iomem_resource' for PCI with
    addresses parsed from device tree gots into a conflict within
    the usb xhci driver:
    
    xhci-mtk 1e1c0000.xhci: can't request region for resource [mem 0x1e1c0000-0x1e1c0fff]
    xhci-mtk: probe of 1e1c0000.xhci failed with error -16
    
    Don't assign it and maintain the default addresses for this
    resource seems to fix the problem. Checking legacy driver it
    is being only  setting the 'ioport_resource'.
    
    Fixes: 09dd629eeabb ("staging: mt7621-pci: fix io space and properly set resource limits")
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Link: https://lore.kernel.org/r/20200322072128.4454-1-sergio.paracuellos@gmail.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/mt7621-pci/pci-mt7621.c b/drivers/staging/mt7621-pci/pci-mt7621.c
index b8065b777ff6..f58e3a51fc71 100644
--- a/drivers/staging/mt7621-pci/pci-mt7621.c
+++ b/drivers/staging/mt7621-pci/pci-mt7621.c
@@ -679,8 +679,6 @@ static int mt7621_pci_probe(struct platform_device *pdev)
 	}
 
 	/* set resources limits */
-	iomem_resource.start = pcie->mem.start;
-	iomem_resource.end = pcie->mem.end;
 	ioport_resource.start = pcie->io.start;
 	ioport_resource.end = pcie->io.end;
 

commit 3856f4e65210597bed9972edb84e88b926872f36
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Sat Mar 21 14:36:21 2020 +0100

    staging: mt7621-pci: use builtin_platform_driver()
    
    Macro builtin_platform_driver can be used for builtin drivers
    that don't do anything in driver init. So, use the macro
    builtin_platform_driver and remove some boilerplate code.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Link: https://lore.kernel.org/r/20200321133624.31388-1-sergio.paracuellos@gmail.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/mt7621-pci/pci-mt7621.c b/drivers/staging/mt7621-pci/pci-mt7621.c
index 1a76968b70c3..b8065b777ff6 100644
--- a/drivers/staging/mt7621-pci/pci-mt7621.c
+++ b/drivers/staging/mt7621-pci/pci-mt7621.c
@@ -725,9 +725,4 @@ static struct platform_driver mt7621_pci_driver = {
 	},
 };
 
-static int __init mt7621_pci_init(void)
-{
-	return platform_driver_register(&mt7621_pci_driver);
-}
-
-module_init(mt7621_pci_init);
+builtin_platform_driver(mt7621_pci_driver);

commit 6bdf0ddd73ddc00b82855023f4cf4adb28c06803
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Sat Mar 21 08:26:50 2020 +0100

    staging: mt7621-pci: delete release gpios related code
    
    Making gpio8 and gpio9 vendor specific and putting them
    into the specific dts file makes not needed to release
    gpios anymore because we are not occupying those pins
    in the first place if it is not necessary. When the
    device tree is parsed we can also check and return for
    the error because we rely in the fact that the related
    device for the board is correct.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Link: https://lore.kernel.org/r/20200321072650.7784-3-sergio.paracuellos@gmail.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/mt7621-pci/pci-mt7621.c b/drivers/staging/mt7621-pci/pci-mt7621.c
index 23b51789f72e..1a76968b70c3 100644
--- a/drivers/staging/mt7621-pci/pci-mt7621.c
+++ b/drivers/staging/mt7621-pci/pci-mt7621.c
@@ -364,8 +364,8 @@ static int mt7621_pcie_parse_port(struct mt7621_pcie *pcie,
 	port->gpio_rst = devm_gpiod_get_index_optional(dev, "reset", slot,
 						       GPIOD_OUT_LOW);
 	if (IS_ERR(port->gpio_rst)) {
-		dev_notice(dev, "Failed to get GPIO for PCIe%d\n", slot);
-		port->gpio_rst = NULL;
+		dev_err(dev, "Failed to get GPIO for PCIe%d\n", slot);
+		return PTR_ERR(port->gpio_rst);
 	}
 
 	port->slot = slot;
@@ -474,15 +474,6 @@ static void mt7621_pcie_reset_ep_deassert(struct mt7621_pcie *pcie)
 	mdelay(PERST_DELAY_MS);
 }
 
-static void mt7621_pcie_release_gpios(struct mt7621_pcie *pcie)
-{
-	struct mt7621_pcie_port *port;
-
-	list_for_each_entry(port, &pcie->ports, list)
-		if (port->gpio_rst)
-			gpiod_put(port->gpio_rst);
-}
-
 static void mt7621_pcie_init_ports(struct mt7621_pcie *pcie)
 {
 	struct device *dev = pcie->dev;
@@ -684,7 +675,7 @@ static int mt7621_pci_probe(struct platform_device *pdev)
 	err = mt7621_pci_parse_request_of_pci_ranges(pcie);
 	if (err) {
 		dev_err(dev, "Error requesting pci resources from ranges");
-		goto out_release_gpios;
+		return err;
 	}
 
 	/* set resources limits */
@@ -698,8 +689,7 @@ static int mt7621_pci_probe(struct platform_device *pdev)
 	err = mt7621_pcie_init_virtual_bridges(pcie);
 	if (err) {
 		dev_err(dev, "Nothing is connected in virtual bridges. Exiting...");
-		err = 0;
-		goto out_release_gpios;
+		return 0;
 	}
 
 	mt7621_pcie_enable_ports(pcie);
@@ -709,19 +699,16 @@ static int mt7621_pci_probe(struct platform_device *pdev)
 	err = mt7621_pcie_request_resources(pcie, &res);
 	if (err) {
 		dev_err(dev, "Error requesting resources\n");
-		goto out_release_gpios;
+		return err;
 	}
 
 	err = mt7621_pcie_register_host(bridge, &res);
 	if (err) {
 		dev_err(dev, "Error registering host\n");
-		goto out_release_gpios;
+		return err;
 	}
 
-out_release_gpios:
-	mt7621_pcie_release_gpios(pcie);
-
-	return err;
+	return 0;
 }
 
 static const struct of_device_id mt7621_pci_ids[] = {

commit 5737cfe87a9c242ad0f60b34b5ac1688770a9236
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Fri Mar 20 16:38:37 2020 +0100

    staging: mt7621-pci: avoid to poweroff the phy for slot one
    
    Phy for slot 0 and 1 is shared and handled properly in slot 0.
    If there is only one port in use,(slot 0) we shall not call the
    'phy_power_off' function with an invalid slot because kernel
    will crash with an unaligned access fault like the following:
    
    mt7621-pci 1e140000.pcie: Error applying setting, reverse things back
    mt7621-pci-phy 1e149000.pcie-phy: PHY for 0xbe149000 (dual port = 1)
    mt7621-pci-phy 1e14a000.pcie-phy: PHY for 0xbe14a000 (dual port = 0)
    mt7621-pci-phy 1e149000.pcie-phy: Xtal is 40MHz
    mt7621-pci-phy 1e14a000.pcie-phy: Xtal is 40MHz
    mt7621-pci 1e140000.pcie: pcie1 no card, disable it (RST & CLK)
    Unhandled kernel unaligned access[#1]:
    CPU: 3 PID: 111 Comm: kworker/3:2 Not tainted 5.6.0-rc3-00347-g825c6f470c62-dirty #9
    Workqueue: events deferred_probe_work_func
    $ 0   : 00000000 00000001 5f60d043 8fe1ba80
    $ 4   : 0000010d 01eb9000 00000000 00000000
    $ 8   : 294b4c00 80940000 00000008 000000ce
    $12   : 2e303030 00000000 00000000 65696370
    $16   : ffffffed 0000010d 8e373cd0 8214c1e0
    $20   : 00000000 82144c80 82144680 8214c250
    $24   : 00000018 803ef8f4
    $28   : 8e372000 8e373c60 8214c080 803940e8
    Hi    : 00000125
    Lo    : 122f2000
    epc   : 807b3328 mutex_lock+0x8/0x44
    ra    : 803940e8 phy_power_off+0x28/0xb0
    Status: 1100fc03        KERNEL EXL IE
    Cause : 00800010 (ExcCode 04)
    BadVA : 0000010d
    PrId  : 0001992f (MIPS 1004Kc)
    Modules linked in:
    Process kworker/3:2 (pid: 111, threadinfo=(ptrval), task=(ptrval), tls=00000000)
    Stack : 8e373cd0 803fe4f4 8e372000 8e373c90 8214c080 804fde1c 8e373c98 808d62f4
             8e373c78 00000000 8214c254 804fe648 1e160000 804f27b8 00000001 808d62f4
             00000000 00000001 8214c228 808d62f4 80930000 809a0000 8fd47e10 808d63d4
             808d62d4 8fd47e10 808d0000 808d0000 8e373cd0 8e373cd0 809e2a74 809db510
             809db510 00000006 00000001 00000000 00000000 00000000 01000000 1e1440ff
             ...
    Call Trace:
    [<807b3328>] mutex_lock+0x8/0x44
    [<803940e8>] phy_power_off+0x28/0xb0
    [<804fe648>] mt7621_pci_probe+0xc20/0xd18
    [<80402ab8>] platform_drv_probe+0x40/0x94
    [<80400a74>] really_probe+0x104/0x364
    [<803feb74>] bus_for_each_drv+0x84/0xdc
    [<80400924>] __device_attach+0xdc/0x120
    [<803ffb5c>] bus_probe_device+0xa0/0xbc
    [<80400124>] deferred_probe_work_func+0x7c/0xbc
    [<800420e8>] process_one_work+0x230/0x450
    [<80042638>] worker_thread+0x330/0x5fc
    [<80048eb0>] kthread+0x12c/0x134
    [<80007438>] ret_from_kernel_thread+0x14/0x1c
    Code: 24050002  27bdfff8  8f830000 <c0850000> 14a00005  00000000  00600825  e0810000  1020fffa
    
    Fixes: bf516f413f4e ("staging: mt7621-pci: use only two phys from device tree")
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Link: https://lore.kernel.org/r/20200320153837.20415-1-sergio.paracuellos@gmail.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/mt7621-pci/pci-mt7621.c b/drivers/staging/mt7621-pci/pci-mt7621.c
index 739504f7e4fc..23b51789f72e 100644
--- a/drivers/staging/mt7621-pci/pci-mt7621.c
+++ b/drivers/staging/mt7621-pci/pci-mt7621.c
@@ -517,7 +517,8 @@ static void mt7621_pcie_init_ports(struct mt7621_pcie *pcie)
 		if (!mt7621_pcie_port_is_linkup(port)) {
 			dev_err(dev, "pcie%d no card, disable it (RST & CLK)\n",
 				slot);
-			phy_power_off(port->phy);
+			if (slot != 1)
+				phy_power_off(port->phy);
 			mt7621_control_assert(port);
 			mt7621_pcie_port_clk_disable(port);
 			port->enabled = false;

commit 825c6f470c62da05195fab57bb6561ccc1bdafcd
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Fri Mar 20 12:01:23 2020 +0100

    staging: mt7621-pci: be sure gpio descriptor is null on fails
    
    Function 'devm_gpiod_get_index_optional' returns NULL if the
    descriptor is invalid and the error associated for the error
    pointer is ENOENT. Sometimes if the pin is just assigned the
    error associated for the pointer might not be ENOENT but other.
    In order to avoid weirds behaviours if this happen set descriptor
    to NULL in the driver port structure.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Link: https://lore.kernel.org/r/20200320110123.9907-6-sergio.paracuellos@gmail.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/mt7621-pci/pci-mt7621.c b/drivers/staging/mt7621-pci/pci-mt7621.c
index bc410c3d9afc..739504f7e4fc 100644
--- a/drivers/staging/mt7621-pci/pci-mt7621.c
+++ b/drivers/staging/mt7621-pci/pci-mt7621.c
@@ -363,8 +363,10 @@ static int mt7621_pcie_parse_port(struct mt7621_pcie *pcie,
 
 	port->gpio_rst = devm_gpiod_get_index_optional(dev, "reset", slot,
 						       GPIOD_OUT_LOW);
-	if (IS_ERR(port->gpio_rst))
+	if (IS_ERR(port->gpio_rst)) {
 		dev_notice(dev, "Failed to get GPIO for PCIe%d\n", slot);
+		port->gpio_rst = NULL;
+	}
 
 	port->slot = slot;
 	port->pcie = pcie;

commit 7846a9828572cf6e7f6aefe61fcfe0195abe9ae1
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Fri Mar 20 12:01:22 2020 +0100

    staging: mt7621-pci: change variable to print for slot
    
    We are using the counter to print the slot which has been
    enabled. Use the correct associated slot for the port instead.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Link: https://lore.kernel.org/r/20200320110123.9907-5-sergio.paracuellos@gmail.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/mt7621-pci/pci-mt7621.c b/drivers/staging/mt7621-pci/pci-mt7621.c
index a521653d8dba..bc410c3d9afc 100644
--- a/drivers/staging/mt7621-pci/pci-mt7621.c
+++ b/drivers/staging/mt7621-pci/pci-mt7621.c
@@ -562,7 +562,7 @@ static void mt7621_pcie_enable_ports(struct mt7621_pcie *pcie)
 		if (port->enabled) {
 			mt7621_pcie_port_clk_enable(port);
 			mt7621_pcie_enable_port(port);
-			dev_info(dev, "PCIE%d enabled\n", num_slots_enabled);
+			dev_info(dev, "PCIE%d enabled\n", port->slot);
 			num_slots_enabled++;
 		}
 	}

commit bf516f413f4e8741ed83056429c24dd3ad648f09
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Fri Mar 20 12:01:21 2020 +0100

    staging: mt7621-pci: use only two phys from device tree
    
    In order to align work with the mt7621-pci-phy part of
    the driver and device tree which is now using only two
    real phys one of them dual ported properly parse the
    device tree and don't call phy initialization for the
    slot 1 because is being taking into account when the
    phy for the slot 0 is instantiated.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Link: https://lore.kernel.org/r/20200320110123.9907-4-sergio.paracuellos@gmail.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/mt7621-pci/pci-mt7621.c b/drivers/staging/mt7621-pci/pci-mt7621.c
index d6fc8a08c9bd..a521653d8dba 100644
--- a/drivers/staging/mt7621-pci/pci-mt7621.c
+++ b/drivers/staging/mt7621-pci/pci-mt7621.c
@@ -358,7 +358,7 @@ static int mt7621_pcie_parse_port(struct mt7621_pcie *pcie,
 
 	snprintf(name, sizeof(name), "pcie-phy%d", slot);
 	port->phy = devm_phy_get(dev, name);
-	if (IS_ERR(port->phy))
+	if (IS_ERR(port->phy) && slot != 1)
 		return PTR_ERR(port->phy);
 
 	port->gpio_rst = devm_gpiod_get_index_optional(dev, "reset", slot,
@@ -495,6 +495,11 @@ static void mt7621_pcie_init_ports(struct mt7621_pcie *pcie)
 	list_for_each_entry_safe(port, tmp, &pcie->ports, list) {
 		u32 slot = port->slot;
 
+		if (slot == 1) {
+			port->enabled = true;
+			continue;
+		}
+
 		err = mt7621_pcie_init_port(port);
 		if (err) {
 			dev_err(dev, "Initiating port %d failed\n", slot);

commit 8e37c13d958050abe9e4389355be57c6fb4119b5
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Thu Mar 19 17:14:16 2020 +0100

    staging: mt7621-pci: don't return if get gpio fails
    
    In some platforms gpio's are not used for reset but
    for other purposes. Because of that when we try to
    get them are valid gpio's but are already assigned
    to do other function. To avoid those kind of problems
    in those platforms just notice the fail in the kernel
    but continue doing normal boot.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Link: https://lore.kernel.org/r/20200319161416.19033-1-sergio.paracuellos@gmail.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/mt7621-pci/pci-mt7621.c b/drivers/staging/mt7621-pci/pci-mt7621.c
index 2a01645162a5..d6fc8a08c9bd 100644
--- a/drivers/staging/mt7621-pci/pci-mt7621.c
+++ b/drivers/staging/mt7621-pci/pci-mt7621.c
@@ -363,10 +363,8 @@ static int mt7621_pcie_parse_port(struct mt7621_pcie *pcie,
 
 	port->gpio_rst = devm_gpiod_get_index_optional(dev, "reset", slot,
 						       GPIOD_OUT_LOW);
-	if (IS_ERR(port->gpio_rst)) {
-		dev_err(dev, "Failed to get GPIO for PCIe%d\n", slot);
-		return PTR_ERR(port->gpio_rst);
-	}
+	if (IS_ERR(port->gpio_rst))
+		dev_notice(dev, "Failed to get GPIO for PCIe%d\n", slot);
 
 	port->slot = slot;
 	port->pcie = pcie;

commit 0432184f2f4a7bce6b02d1319277a6e7cefbff10
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Thu Mar 19 10:57:33 2020 +0100

    staging: mt7621-pci: fix register to set up virtual bridges
    
    Instead of being using PCI Configuration and Status Register to
    set up virtual bridges we are using CONFIG_ADDR Register which is
    wrong. Hence, set the correct value.
    
    Fixes: 9a5e71a68d20 ("staging: mt7621-pci: simplify 'mt7621_pcie_init_virtual_bridges' function")
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Link: https://lore.kernel.org/r/20200319095733.1557-1-sergio.paracuellos@gmail.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/mt7621-pci/pci-mt7621.c b/drivers/staging/mt7621-pci/pci-mt7621.c
index 7ef2099b01c5..2a01645162a5 100644
--- a/drivers/staging/mt7621-pci/pci-mt7621.c
+++ b/drivers/staging/mt7621-pci/pci-mt7621.c
@@ -603,7 +603,7 @@ static int mt7621_pcie_init_virtual_bridges(struct mt7621_pcie *pcie)
 		if ((pcie_link_status & BIT(i)) == 0)
 			p2p_br_devnum[i] = n++;
 
-	pcie_rmw(pcie, RALINK_PCI_CONFIG_ADDR,
+	pcie_rmw(pcie, RALINK_PCI_PCICFG_ADDR,
 		 PCIE_P2P_BR_DEVNUM_MASK_FULL,
 		 (p2p_br_devnum[0] << PCIE_P2P_BR_DEVNUM0_SHIFT) |
 		 (p2p_br_devnum[1] << PCIE_P2P_BR_DEVNUM1_SHIFT) |

commit 09dd629eeabb8af4d261ba9eb4b21d7e440362bc
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Wed Mar 18 10:44:45 2020 +0100

    staging: mt7621-pci: fix io space and properly set resource limits
    
    Function 'mt7621_pci_parse_request_of_pci_ranges' is using
    'of_pci_range_to_resource' to get both mem and io resources.
    Internally this function calls to 'pci_address_to_pio' which
    returns -1 if io space address is an address > IO_SPACE_LIMIT
    which is 0xFFFF for mips. This mt7621 soc has io space in physical
    address 0x1e160000. In order to fix this, overwrite invalid io
    0xffffffff  with properly values from the device tree and set
    mapped address of this resource as io port base memory address
    calling 'set_io_port_base' function. There is also need to properly
    setup resource limits and io and memory windows with properly
    parsed values instead of set them as 'no limit' which it is wrong.
    For any reason I don't really know legacy driver sets up mem window
    as 0xFFFFFFFF and any other value seems to does not work as expected,
    so set up also here with same values.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Link: https://lore.kernel.org/r/20200318094445.19669-1-sergio.paracuellos@gmail.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/mt7621-pci/pci-mt7621.c b/drivers/staging/mt7621-pci/pci-mt7621.c
index 973be9aa7bb2..7ef2099b01c5 100644
--- a/drivers/staging/mt7621-pci/pci-mt7621.c
+++ b/drivers/staging/mt7621-pci/pci-mt7621.c
@@ -118,6 +118,7 @@ struct mt7621_pcie_port {
  * @busn: bus range
  * @offset: IO / Memory offset
  * @dev: Pointer to PCIe device
+ * @io_map_base: virtual memory base address for io
  * @ports: pointer to PCIe port information
  * @resets_inverted: depends on chip revision
  * reset lines are inverted.
@@ -132,6 +133,7 @@ struct mt7621_pcie {
 		resource_size_t mem;
 		resource_size_t io;
 	} offset;
+	unsigned long io_map_base;
 	struct list_head ports;
 	bool resets_inverted;
 };
@@ -291,22 +293,21 @@ static int mt7621_pci_parse_request_of_pci_ranges(struct mt7621_pcie *pcie)
 	}
 
 	for_each_of_pci_range(&parser, &range) {
-		struct resource *res = NULL;
-
 		switch (range.flags & IORESOURCE_TYPE_BITS) {
 		case IORESOURCE_IO:
-			ioremap(range.cpu_addr, range.size);
-			res = &pcie->io;
+			pcie->io_map_base =
+				(unsigned long)ioremap(range.cpu_addr,
+						       range.size);
+			of_pci_range_to_resource(&range, node, &pcie->io);
+			pcie->io.start = range.cpu_addr;
+			pcie->io.end = range.cpu_addr + range.size - 1;
 			pcie->offset.io = 0x00000000UL;
 			break;
 		case IORESOURCE_MEM:
-			res = &pcie->mem;
+			of_pci_range_to_resource(&range, node, &pcie->mem);
 			pcie->offset.mem = 0x00000000UL;
 			break;
 		}
-
-		if (res)
-			of_pci_range_to_resource(&range, node, res);
 	}
 
 	err = of_pci_parse_bus_range(node, &pcie->busn);
@@ -318,6 +319,8 @@ static int mt7621_pci_parse_request_of_pci_ranges(struct mt7621_pcie *pcie)
 		pcie->busn.flags = IORESOURCE_BUS;
 	}
 
+	set_io_port_base(pcie->io_map_base);
+
 	return 0;
 }
 
@@ -548,6 +551,10 @@ static void mt7621_pcie_enable_ports(struct mt7621_pcie *pcie)
 	u32 slot;
 	u32 val;
 
+	/* Setup MEMWIN and IOWIN */
+	pcie_write(pcie, 0xffffffff, RALINK_PCI_MEMBASE);
+	pcie_write(pcie, pcie->io.start, RALINK_PCI_IOBASE);
+
 	list_for_each_entry(port, &pcie->ports, list) {
 		if (port->enabled) {
 			mt7621_pcie_port_clk_enable(port);
@@ -668,11 +675,17 @@ static int mt7621_pci_probe(struct platform_device *pdev)
 		return err;
 	}
 
+	err = mt7621_pci_parse_request_of_pci_ranges(pcie);
+	if (err) {
+		dev_err(dev, "Error requesting pci resources from ranges");
+		goto out_release_gpios;
+	}
+
 	/* set resources limits */
-	iomem_resource.start = 0;
-	iomem_resource.end = ~0UL; /* no limit */
-	ioport_resource.start = 0;
-	ioport_resource.end = ~0UL; /* no limit */
+	iomem_resource.start = pcie->mem.start;
+	iomem_resource.end = pcie->mem.end;
+	ioport_resource.start = pcie->io.start;
+	ioport_resource.end = pcie->io.end;
 
 	mt7621_pcie_init_ports(pcie);
 
@@ -685,12 +698,6 @@ static int mt7621_pci_probe(struct platform_device *pdev)
 
 	mt7621_pcie_enable_ports(pcie);
 
-	err = mt7621_pci_parse_request_of_pci_ranges(pcie);
-	if (err) {
-		dev_err(dev, "Error requesting pci resources from ranges");
-		goto out_release_gpios;
-	}
-
 	setup_cm_memory_region(pcie);
 
 	err = mt7621_pcie_request_resources(pcie, &res);

commit c0da4872c4ba698ce8122269bc996c722db51157
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Fri Mar 13 21:09:13 2020 +0100

    staging: mt7621-pci: delete no more needed 'mt7621_reset_port'
    
    After review all the resets at the beggining the function
    'mt7621_reset_port' is not needed anymore. Hence delete it
    and its uses.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Link: https://lore.kernel.org/r/20200313200913.24321-7-sergio.paracuellos@gmail.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/mt7621-pci/pci-mt7621.c b/drivers/staging/mt7621-pci/pci-mt7621.c
index 0d9dd14f6bec..973be9aa7bb2 100644
--- a/drivers/staging/mt7621-pci/pci-mt7621.c
+++ b/drivers/staging/mt7621-pci/pci-mt7621.c
@@ -255,13 +255,6 @@ static inline void mt7621_control_deassert(struct mt7621_pcie_port *port)
 		reset_control_assert(port->pcie_rst);
 }
 
-static void mt7621_reset_port(struct mt7621_pcie_port *port)
-{
-	mt7621_control_assert(port);
-	msleep(100);
-	mt7621_control_deassert(port);
-}
-
 static void setup_cm_memory_region(struct mt7621_pcie *pcie)
 {
 	struct resource *mem_resource = &pcie->mem;
@@ -427,12 +420,6 @@ static int mt7621_pcie_init_port(struct mt7621_pcie_port *port)
 	u32 slot = port->slot;
 	int err;
 
-	/*
-	 * Any MT7621 Ralink pcie controller that doesn't have 0x0101 at
-	 * the end of the chip_id has inverted PCI resets.
-	 */
-	mt7621_reset_port(port);
-
 	err = phy_init(port->phy);
 	if (err) {
 		dev_err(dev, "failed to initialize port%d phy\n", slot);

commit adfeee9b871a2ed26673c24ada23c13e11a21505
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Fri Mar 13 21:09:12 2020 +0100

    staging: mt7621-pci: release gpios after pci initialization
    
    R3G's LEDs fail to initialize because one of them uses GPIO8
    Hence, release the GPIO resources after PCIe initialization
    and properly release also in driver error path.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Link: https://lore.kernel.org/r/20200313200913.24321-6-sergio.paracuellos@gmail.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/mt7621-pci/pci-mt7621.c b/drivers/staging/mt7621-pci/pci-mt7621.c
index 3d85ce788f9f..0d9dd14f6bec 100644
--- a/drivers/staging/mt7621-pci/pci-mt7621.c
+++ b/drivers/staging/mt7621-pci/pci-mt7621.c
@@ -484,6 +484,15 @@ static void mt7621_pcie_reset_ep_deassert(struct mt7621_pcie *pcie)
 	mdelay(PERST_DELAY_MS);
 }
 
+static void mt7621_pcie_release_gpios(struct mt7621_pcie *pcie)
+{
+	struct mt7621_pcie_port *port;
+
+	list_for_each_entry(port, &pcie->ports, list)
+		if (port->gpio_rst)
+			gpiod_put(port->gpio_rst);
+}
+
 static void mt7621_pcie_init_ports(struct mt7621_pcie *pcie)
 {
 	struct device *dev = pcie->dev;
@@ -683,7 +692,8 @@ static int mt7621_pci_probe(struct platform_device *pdev)
 	err = mt7621_pcie_init_virtual_bridges(pcie);
 	if (err) {
 		dev_err(dev, "Nothing is connected in virtual bridges. Exiting...");
-		return 0;
+		err = 0;
+		goto out_release_gpios;
 	}
 
 	mt7621_pcie_enable_ports(pcie);
@@ -691,7 +701,7 @@ static int mt7621_pci_probe(struct platform_device *pdev)
 	err = mt7621_pci_parse_request_of_pci_ranges(pcie);
 	if (err) {
 		dev_err(dev, "Error requesting pci resources from ranges");
-		return err;
+		goto out_release_gpios;
 	}
 
 	setup_cm_memory_region(pcie);
@@ -699,16 +709,19 @@ static int mt7621_pci_probe(struct platform_device *pdev)
 	err = mt7621_pcie_request_resources(pcie, &res);
 	if (err) {
 		dev_err(dev, "Error requesting resources\n");
-		return err;
+		goto out_release_gpios;
 	}
 
 	err = mt7621_pcie_register_host(bridge, &res);
 	if (err) {
 		dev_err(dev, "Error registering host\n");
-		return err;
+		goto out_release_gpios;
 	}
 
-	return 0;
+out_release_gpios:
+	mt7621_pcie_release_gpios(pcie);
+
+	return err;
 }
 
 static const struct of_device_id mt7621_pci_ids[] = {

commit 475fe234bdfd4d7a9004b79f4f37fc5b47de51ed
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Fri Mar 13 21:09:09 2020 +0100

    staging: mt7621-pci: change value for 'PERST_DELAY_MS'
    
    Value of 'PERST_DELAY_MS' is too high and it is ok just
    to set up to 100 ms. Update also define name from
    'PERST_DELAY_US' into 'PERST_DELAY_MS'
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Link: https://lore.kernel.org/r/20200313200913.24321-3-sergio.paracuellos@gmail.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/mt7621-pci/pci-mt7621.c b/drivers/staging/mt7621-pci/pci-mt7621.c
index 9b4fe8d31101..3d85ce788f9f 100644
--- a/drivers/staging/mt7621-pci/pci-mt7621.c
+++ b/drivers/staging/mt7621-pci/pci-mt7621.c
@@ -86,7 +86,7 @@
 #define MEMORY_BASE			0x0
 #define PERST_MODE_MASK			GENMASK(11, 10)
 #define PERST_MODE_GPIO			BIT(10)
-#define PERST_DELAY_US			1000
+#define PERST_DELAY_MS			100
 
 /**
  * struct mt7621_pcie_port - PCIe port information
@@ -463,7 +463,7 @@ static void mt7621_pcie_reset_assert(struct mt7621_pcie *pcie)
 		mt7621_rst_gpio_pcie_assert(port);
 	}
 
-	mdelay(PERST_DELAY_US);
+	mdelay(PERST_DELAY_MS);
 }
 
 static void mt7621_pcie_reset_rc_deassert(struct mt7621_pcie *pcie)
@@ -481,7 +481,7 @@ static void mt7621_pcie_reset_ep_deassert(struct mt7621_pcie *pcie)
 	list_for_each_entry(port, &pcie->ports, list)
 		mt7621_rst_gpio_pcie_deassert(port);
 
-	mdelay(PERST_DELAY_US);
+	mdelay(PERST_DELAY_MS);
 }
 
 static void mt7621_pcie_init_ports(struct mt7621_pcie *pcie)

commit b27e35f91c75cfd7f1a4c85acfec247af8e20af2
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Fri Mar 13 21:09:08 2020 +0100

    staging: mt7621-pci: use gpios for properly reset
    
    Original driver code was using three gpio's for reset
    asserts and deasserts the pcis. Instead of using that
    a general reset control with a perst gpio was introduced
    and it seems it is partially working but sometimes there
    are some unexpected hangs on boot. This commit make use of
    the three original gpios using 'reset-gpios' property of
    the device tree and removes the reset line and perst gpio.
    According to the mediatek aplication note v0.1 there are
    three gpios used for pcie ports reset control: gpio#19,
    gpio#8 and gpio#7 for slots 0, 1 and 2 respectively.
    This schema can be used separately for mt7621A but in some
    boards due to pin share issue, if the PCM and I2S function
    are enable at the same time, there are no enough GPIO to
    control per-port PCIe reset. In those cases gpio#19 is enought
    for reset the three ports together. Because of this we just
    try to get the three gpios but if some of them fail we are not
    failing in boot process, just prints a kernel notice and take
    after into account if the descriptor is or not valid in order
    to use it. All of them are set as GPIO output low configuration.
    The gpio descriptor's API takes device tree property into account
    and invert value if the pin is configured as active low.
    So we also have to properly request pins from device tree
    and set values correct in assert and deassert functions.
    After this changes the order to make all assert and
    deassert in the 'probe' process makes more sense:
    * Parse device tree.
    * make assert of the RC's and EP's before doing anything else.
    * make deassert of the RC's before initializing the phy.
    * Init the phy.
    * make deassert of the EP's before initialize pci ports.
    * Normal PCI initialization.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Link: https://lore.kernel.org/r/20200313200913.24321-2-sergio.paracuellos@gmail.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/mt7621-pci/pci-mt7621.c b/drivers/staging/mt7621-pci/pci-mt7621.c
index 770dabd3a70d..9b4fe8d31101 100644
--- a/drivers/staging/mt7621-pci/pci-mt7621.c
+++ b/drivers/staging/mt7621-pci/pci-mt7621.c
@@ -95,6 +95,7 @@
  * @pcie: pointer to PCIe host info
  * @phy: pointer to PHY control block
  * @pcie_rst: pointer to port reset control
+ * @gpio_rst: gpio reset
  * @slot: port slot
  * @enabled: indicates if port is enabled
  */
@@ -104,6 +105,7 @@ struct mt7621_pcie_port {
 	struct mt7621_pcie *pcie;
 	struct phy *phy;
 	struct reset_control *pcie_rst;
+	struct gpio_desc *gpio_rst;
 	u32 slot;
 	bool enabled;
 };
@@ -117,8 +119,6 @@ struct mt7621_pcie_port {
  * @offset: IO / Memory offset
  * @dev: Pointer to PCIe device
  * @ports: pointer to PCIe port information
- * @perst: gpio reset
- * @rst: pointer to pcie reset
  * @resets_inverted: depends on chip revision
  * reset lines are inverted.
  */
@@ -133,8 +133,6 @@ struct mt7621_pcie {
 		resource_size_t io;
 	} offset;
 	struct list_head ports;
-	struct gpio_desc *perst;
-	struct reset_control *rst;
 	bool resets_inverted;
 };
 
@@ -210,16 +208,16 @@ static void write_config(struct mt7621_pcie *pcie, unsigned int dev,
 	pcie_write(pcie, val, RALINK_PCI_CONFIG_DATA);
 }
 
-static inline void mt7621_perst_gpio_pcie_assert(struct mt7621_pcie *pcie)
+static inline void mt7621_rst_gpio_pcie_assert(struct mt7621_pcie_port *port)
 {
-	gpiod_set_value(pcie->perst, 0);
-	mdelay(PERST_DELAY_US);
+	if (port->gpio_rst)
+		gpiod_set_value(port->gpio_rst, 1);
 }
 
-static inline void mt7621_perst_gpio_pcie_deassert(struct mt7621_pcie *pcie)
+static inline void mt7621_rst_gpio_pcie_deassert(struct mt7621_pcie_port *port)
 {
-	gpiod_set_value(pcie->perst, 1);
-	mdelay(PERST_DELAY_US);
+	if (port->gpio_rst)
+		gpiod_set_value(port->gpio_rst, 0);
 }
 
 static inline bool mt7621_pcie_port_is_linkup(struct mt7621_pcie_port *port)
@@ -367,6 +365,13 @@ static int mt7621_pcie_parse_port(struct mt7621_pcie *pcie,
 	if (IS_ERR(port->phy))
 		return PTR_ERR(port->phy);
 
+	port->gpio_rst = devm_gpiod_get_index_optional(dev, "reset", slot,
+						       GPIOD_OUT_LOW);
+	if (IS_ERR(port->gpio_rst)) {
+		dev_err(dev, "Failed to get GPIO for PCIe%d\n", slot);
+		return PTR_ERR(port->gpio_rst);
+	}
+
 	port->slot = slot;
 	port->pcie = pcie;
 
@@ -383,12 +388,6 @@ static int mt7621_pcie_parse_dt(struct mt7621_pcie *pcie)
 	struct resource regs;
 	int err;
 
-	pcie->perst = devm_gpiod_get(dev, "perst", GPIOD_OUT_HIGH);
-	if (IS_ERR(pcie->perst)) {
-		dev_err(dev, "failed to get gpio perst\n");
-		return PTR_ERR(pcie->perst);
-	}
-
 	err = of_address_to_resource(node, 0, &regs);
 	if (err) {
 		dev_err(dev, "missing \"reg\" property\n");
@@ -399,12 +398,6 @@ static int mt7621_pcie_parse_dt(struct mt7621_pcie *pcie)
 	if (IS_ERR(pcie->base))
 		return PTR_ERR(pcie->base);
 
-	pcie->rst = devm_reset_control_get_exclusive(dev, "pcie");
-	if (PTR_ERR(pcie->rst) == -EPROBE_DEFER) {
-		dev_err(dev, "failed to get pcie reset control\n");
-		return PTR_ERR(pcie->rst);
-	}
-
 	for_each_available_child_of_node(node, child) {
 		int slot;
 
@@ -458,16 +451,49 @@ static int mt7621_pcie_init_port(struct mt7621_pcie_port *port)
 	return 0;
 }
 
+static void mt7621_pcie_reset_assert(struct mt7621_pcie *pcie)
+{
+	struct mt7621_pcie_port *port;
+
+	list_for_each_entry(port, &pcie->ports, list) {
+		/* PCIe RC reset assert */
+		mt7621_control_assert(port);
+
+		/* PCIe EP reset assert */
+		mt7621_rst_gpio_pcie_assert(port);
+	}
+
+	mdelay(PERST_DELAY_US);
+}
+
+static void mt7621_pcie_reset_rc_deassert(struct mt7621_pcie *pcie)
+{
+	struct mt7621_pcie_port *port;
+
+	list_for_each_entry(port, &pcie->ports, list)
+		mt7621_control_deassert(port);
+}
+
+static void mt7621_pcie_reset_ep_deassert(struct mt7621_pcie *pcie)
+{
+	struct mt7621_pcie_port *port;
+
+	list_for_each_entry(port, &pcie->ports, list)
+		mt7621_rst_gpio_pcie_deassert(port);
+
+	mdelay(PERST_DELAY_US);
+}
+
 static void mt7621_pcie_init_ports(struct mt7621_pcie *pcie)
 {
 	struct device *dev = pcie->dev;
 	struct mt7621_pcie_port *port, *tmp;
-	u32 val = 0;
 	int err;
 
 	rt_sysc_m32(PERST_MODE_MASK, PERST_MODE_GPIO, MT7621_GPIO_MODE);
 
-	mt7621_perst_gpio_pcie_assert(pcie);
+	mt7621_pcie_reset_assert(pcie);
+	mt7621_pcie_reset_rc_deassert(pcie);
 
 	list_for_each_entry_safe(port, tmp, &pcie->ports, list) {
 		u32 slot = port->slot;
@@ -476,16 +502,10 @@ static void mt7621_pcie_init_ports(struct mt7621_pcie *pcie)
 		if (err) {
 			dev_err(dev, "Initiating port %d failed\n", slot);
 			list_del(&port->list);
-		} else {
-			val = read_config(pcie, slot, PCIE_FTS_NUM);
-			dev_info(dev, "Port %d N_FTS = %x\n", slot,
-				 (unsigned int)val);
 		}
 	}
 
-	reset_control_assert(pcie->rst);
-
-	mt7621_perst_gpio_pcie_deassert(pcie);
+	mt7621_pcie_reset_ep_deassert(pcie);
 
 	list_for_each_entry(port, &pcie->ports, list) {
 		u32 slot = port->slot;
@@ -499,8 +519,6 @@ static void mt7621_pcie_init_ports(struct mt7621_pcie *pcie)
 			port->enabled = false;
 		}
 	}
-
-	reset_control_deassert(pcie->rst);
 }
 
 static void mt7621_pcie_enable_port(struct mt7621_pcie_port *port)

commit 5ca61dffc7da1ca0ac63256b5713000229dc8f1e
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Tue Mar 10 12:34:59 2020 +0100

    staging: mt7621-pci: enable clock bit for each port
    
    The clock related code concerns me from the very beginning because
    there are some set ups got from legacy driver that are not documented
    anywhere. According to the programming guide 0x7c is 'CPE_ROSC_SEL1'
    register and 0x80 is 'CPU_CPE_CN'. I do think this set up is not needed
    at all and the proper thing to do is just enable the clock bit for each
    pcie port. Hence remove useless code and do the right thing which is
    setting up the clock bit for each port enabled.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Link: https://lore.kernel.org/r/20200310113459.30539-1-sergio.paracuellos@gmail.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/mt7621-pci/pci-mt7621.c b/drivers/staging/mt7621-pci/pci-mt7621.c
index 1f860c5ef588..770dabd3a70d 100644
--- a/drivers/staging/mt7621-pci/pci-mt7621.c
+++ b/drivers/staging/mt7621-pci/pci-mt7621.c
@@ -45,8 +45,6 @@
 
 /* rt_sysc_membase relative registers */
 #define RALINK_CLKCFG1			0x30
-#define RALINK_PCIE_CLK_GEN		0x7c
-#define RALINK_PCIE_CLK_GEN1		0x80
 
 /* Host-PCI bridge registers */
 #define RALINK_PCI_PCICFG_ADDR		0x0000
@@ -85,10 +83,6 @@
 #define PCIE_PORT_CLK_EN(x)		BIT(24 + (x))
 #define PCIE_PORT_LINKUP		BIT(0)
 
-#define PCIE_CLK_GEN_EN			BIT(31)
-#define PCIE_CLK_GEN_DIS		0
-#define PCIE_CLK_GEN1_DIS		GENMASK(30, 24)
-#define PCIE_CLK_GEN1_EN		(BIT(27) | BIT(25))
 #define MEMORY_BASE			0x0
 #define PERST_MODE_MASK			GENMASK(11, 10)
 #define PERST_MODE_GPIO			BIT(10)
@@ -233,6 +227,11 @@ static inline bool mt7621_pcie_port_is_linkup(struct mt7621_pcie_port *port)
 	return (pcie_port_read(port, RALINK_PCI_STATUS) & PCIE_PORT_LINKUP) != 0;
 }
 
+static inline void mt7621_pcie_port_clk_enable(struct mt7621_pcie_port *port)
+{
+	rt_sysc_m32(0, PCIE_PORT_CLK_EN(port->slot), RALINK_CLKCFG1);
+}
+
 static inline void mt7621_pcie_port_clk_disable(struct mt7621_pcie_port *port)
 {
 	rt_sysc_m32(PCIE_PORT_CLK_EN(port->slot), 0, RALINK_CLKCFG1);
@@ -501,11 +500,6 @@ static void mt7621_pcie_init_ports(struct mt7621_pcie *pcie)
 		}
 	}
 
-	rt_sysc_m32(0x30, 2 << 4, SYSC_REG_SYSTEM_CONFIG1);
-	rt_sysc_m32(PCIE_CLK_GEN_EN, PCIE_CLK_GEN_DIS, RALINK_PCIE_CLK_GEN);
-	rt_sysc_m32(PCIE_CLK_GEN1_DIS, PCIE_CLK_GEN1_EN, RALINK_PCIE_CLK_GEN1);
-	rt_sysc_m32(PCIE_CLK_GEN_DIS, PCIE_CLK_GEN_EN, RALINK_PCIE_CLK_GEN);
-	msleep(50);
 	reset_control_deassert(pcie->rst);
 }
 
@@ -542,6 +536,7 @@ static void mt7621_pcie_enable_ports(struct mt7621_pcie *pcie)
 
 	list_for_each_entry(port, &pcie->ports, list) {
 		if (port->enabled) {
+			mt7621_pcie_port_clk_enable(port);
 			mt7621_pcie_enable_port(port);
 			dev_info(dev, "PCIE%d enabled\n", num_slots_enabled);
 			num_slots_enabled++;

commit 9a5e71a68d201165adc3fa4157ed9bf94b901ec7
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Sun Mar 8 10:19:27 2020 +0100

    staging: mt7621-pci: simplify 'mt7621_pcie_init_virtual_bridges' function
    
    Function 'mt7621_pcie_init_virtual_bridges' is a bit mess and can be
    refactorized properly in a cleaner way. Introduce new 'pcie_rmw' inline
    function helper to do clear and set the correct bits this function needs
    to work.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Link: https://lore.kernel.org/r/20200308091928.17177-1-sergio.paracuellos@gmail.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/mt7621-pci/pci-mt7621.c b/drivers/staging/mt7621-pci/pci-mt7621.c
index 3633c924848e..1f860c5ef588 100644
--- a/drivers/staging/mt7621-pci/pci-mt7621.c
+++ b/drivers/staging/mt7621-pci/pci-mt7621.c
@@ -57,13 +57,13 @@
 #define RALINK_PCI_IOBASE		0x002C
 
 /* PCICFG virtual bridges */
-#define MT7621_BR0_MASK			GENMASK(19, 16)
-#define MT7621_BR1_MASK			GENMASK(23, 20)
-#define MT7621_BR2_MASK			GENMASK(27, 24)
-#define MT7621_BR_ALL_MASK		GENMASK(27, 16)
-#define MT7621_BR0_SHIFT		16
-#define MT7621_BR1_SHIFT		20
-#define MT7621_BR2_SHIFT		24
+#define PCIE_P2P_MAX			3
+#define PCIE_P2P_BR_DEVNUM_SHIFT(p)	(16 + (p) * 4)
+#define PCIE_P2P_BR_DEVNUM0_SHIFT	PCIE_P2P_BR_DEVNUM_SHIFT(0)
+#define PCIE_P2P_BR_DEVNUM1_SHIFT	PCIE_P2P_BR_DEVNUM_SHIFT(1)
+#define PCIE_P2P_BR_DEVNUM2_SHIFT	PCIE_P2P_BR_DEVNUM_SHIFT(2)
+#define PCIE_P2P_BR_DEVNUM_MASK		0xf
+#define PCIE_P2P_BR_DEVNUM_MASK_FULL	(0xfff << PCIE_P2P_BR_DEVNUM0_SHIFT)
 
 /* PCIe RC control registers */
 #define MT7621_PCIE_OFFSET		0x2000
@@ -154,6 +154,15 @@ static inline void pcie_write(struct mt7621_pcie *pcie, u32 val, u32 reg)
 	writel(val, pcie->base + reg);
 }
 
+static inline void pcie_rmw(struct mt7621_pcie *pcie, u32 reg, u32 clr, u32 set)
+{
+	u32 val = readl(pcie->base + reg);
+
+	val &= ~clr;
+	val |= set;
+	writel(val, pcie->base + reg);
+}
+
 static inline u32 pcie_port_read(struct mt7621_pcie_port *port, u32 reg)
 {
 	return readl(port->base + reg);
@@ -554,7 +563,9 @@ static void mt7621_pcie_enable_ports(struct mt7621_pcie *pcie)
 static int mt7621_pcie_init_virtual_bridges(struct mt7621_pcie *pcie)
 {
 	u32 pcie_link_status = 0;
-	u32 val = 0;
+	u32 n;
+	int i;
+	u32 p2p_br_devnum[PCIE_P2P_MAX];
 	struct mt7621_pcie_port *port;
 
 	list_for_each_entry(port, &pcie->ports, list) {
@@ -567,50 +578,20 @@ static int mt7621_pcie_init_virtual_bridges(struct mt7621_pcie *pcie)
 	if (pcie_link_status == 0)
 		return -1;
 
-	/*
-	 * pcie(2/1/0) link status	pcie2_num	pcie1_num	pcie0_num
-	 * 3'b000			x		x		x
-	 * 3'b001			x		x		0
-	 * 3'b010			x		0		x
-	 * 3'b011			x		1		0
-	 * 3'b100			0		x		x
-	 * 3'b101			1		x		0
-	 * 3'b110			1		0		x
-	 * 3'b111			2		1		0
-	 */
-	switch (pcie_link_status) {
-	case 2:
-		val = pcie_read(pcie, RALINK_PCI_PCICFG_ADDR);
-		val &= ~(MT7621_BR0_MASK | MT7621_BR1_MASK);
-		val |= 0x1 << MT7621_BR0_SHIFT;
-		val |= 0x0 << MT7621_BR1_SHIFT;
-		pcie_write(pcie, val, RALINK_PCI_PCICFG_ADDR);
-		break;
-	case 4:
-		val = pcie_read(pcie, RALINK_PCI_PCICFG_ADDR);
-		val &= ~MT7621_BR_ALL_MASK;
-		val |= 0x1 << MT7621_BR0_SHIFT;
-		val |= 0x2 << MT7621_BR1_SHIFT;
-		val |= 0x0 << MT7621_BR2_SHIFT;
-		pcie_write(pcie, val, RALINK_PCI_PCICFG_ADDR);
-		break;
-	case 5:
-		val = pcie_read(pcie, RALINK_PCI_PCICFG_ADDR);
-		val &= ~MT7621_BR_ALL_MASK;
-		val |= 0x0 << MT7621_BR0_SHIFT;
-		val |= 0x2 << MT7621_BR1_SHIFT;
-		val |= 0x1 << MT7621_BR2_SHIFT;
-		pcie_write(pcie, val, RALINK_PCI_PCICFG_ADDR);
-		break;
-	case 6:
-		val = pcie_read(pcie, RALINK_PCI_PCICFG_ADDR);
-		val &= ~MT7621_BR_ALL_MASK;
-		val |= 0x2 << MT7621_BR0_SHIFT;
-		val |= 0x0 << MT7621_BR1_SHIFT;
-		val |= 0x1 << MT7621_BR2_SHIFT;
-		pcie_write(pcie, val, RALINK_PCI_PCICFG_ADDR);
-		break;
-	}
+	n = 0;
+	for (i = 0; i < PCIE_P2P_MAX; i++)
+		if (pcie_link_status & BIT(i))
+			p2p_br_devnum[i] = n++;
+
+	for (i = 0; i < PCIE_P2P_MAX; i++)
+		if ((pcie_link_status & BIT(i)) == 0)
+			p2p_br_devnum[i] = n++;
+
+	pcie_rmw(pcie, RALINK_PCI_CONFIG_ADDR,
+		 PCIE_P2P_BR_DEVNUM_MASK_FULL,
+		 (p2p_br_devnum[0] << PCIE_P2P_BR_DEVNUM0_SHIFT) |
+		 (p2p_br_devnum[1] << PCIE_P2P_BR_DEVNUM1_SHIFT) |
+		 (p2p_br_devnum[2] << PCIE_P2P_BR_DEVNUM2_SHIFT));
 
 	return 0;
 }

commit b483b4e4d3f6bfd5089b9e6dc9ba259879c6ce6f
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Sun Oct 6 20:10:32 2019 +0200

    staging: mt7621-pci: add quirks for 'E2' revision using 'soc_device_attribute'
    
    Depending on revision of the chip, reset lines are inverted. Make code
    more readable making use of 'soc_device_match' in driver probe function.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Link: https://lore.kernel.org/r/20191006181032.19112-1-sergio.paracuellos@gmail.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/mt7621-pci/pci-mt7621.c b/drivers/staging/mt7621-pci/pci-mt7621.c
index 6b98827da57f..3633c924848e 100644
--- a/drivers/staging/mt7621-pci/pci-mt7621.c
+++ b/drivers/staging/mt7621-pci/pci-mt7621.c
@@ -29,15 +29,14 @@
 #include <linux/phy/phy.h>
 #include <linux/platform_device.h>
 #include <linux/reset.h>
+#include <linux/sys_soc.h>
 #include <mt7621.h>
 #include <ralink_regs.h>
 
 #include "../../pci/pci.h"
 
 /* sysctl */
-#define MT7621_CHIP_REV_ID		0x0c
 #define MT7621_GPIO_MODE		0x60
-#define CHIP_REV_MT7621_E2		0x0101
 
 /* MediaTek specific configuration registers */
 #define PCIE_FTS_NUM			0x70c
@@ -126,6 +125,8 @@ struct mt7621_pcie_port {
  * @ports: pointer to PCIe port information
  * @perst: gpio reset
  * @rst: pointer to pcie reset
+ * @resets_inverted: depends on chip revision
+ * reset lines are inverted.
  */
 struct mt7621_pcie {
 	void __iomem *base;
@@ -140,6 +141,7 @@ struct mt7621_pcie {
 	struct list_head ports;
 	struct gpio_desc *perst;
 	struct reset_control *rst;
+	bool resets_inverted;
 };
 
 static inline u32 pcie_read(struct mt7621_pcie *pcie, u32 reg)
@@ -229,9 +231,9 @@ static inline void mt7621_pcie_port_clk_disable(struct mt7621_pcie_port *port)
 
 static inline void mt7621_control_assert(struct mt7621_pcie_port *port)
 {
-	u32 chip_rev_id = rt_sysc_r32(MT7621_CHIP_REV_ID);
+	struct mt7621_pcie *pcie = port->pcie;
 
-	if ((chip_rev_id & 0xFFFF) == CHIP_REV_MT7621_E2)
+	if (pcie->resets_inverted)
 		reset_control_assert(port->pcie_rst);
 	else
 		reset_control_deassert(port->pcie_rst);
@@ -239,9 +241,9 @@ static inline void mt7621_control_assert(struct mt7621_pcie_port *port)
 
 static inline void mt7621_control_deassert(struct mt7621_pcie_port *port)
 {
-	u32 chip_rev_id = rt_sysc_r32(MT7621_CHIP_REV_ID);
+	struct mt7621_pcie *pcie = port->pcie;
 
-	if ((chip_rev_id & 0xFFFF) == CHIP_REV_MT7621_E2)
+	if (pcie->resets_inverted)
 		reset_control_deassert(port->pcie_rst);
 	else
 		reset_control_assert(port->pcie_rst);
@@ -641,9 +643,14 @@ static int mt7621_pcie_register_host(struct pci_host_bridge *host,
 	return pci_host_probe(host);
 }
 
+static const struct soc_device_attribute mt7621_pci_quirks_match[] = {
+	{ .soc_id = "mt7621", .revision = "E2" }
+};
+
 static int mt7621_pci_probe(struct platform_device *pdev)
 {
 	struct device *dev = &pdev->dev;
+	const struct soc_device_attribute *attr;
 	struct mt7621_pcie *pcie;
 	struct pci_host_bridge *bridge;
 	int err;
@@ -661,6 +668,10 @@ static int mt7621_pci_probe(struct platform_device *pdev)
 	platform_set_drvdata(pdev, pcie);
 	INIT_LIST_HEAD(&pcie->ports);
 
+	attr = soc_device_match(mt7621_pci_quirks_match);
+	if (attr)
+		pcie->resets_inverted = true;
+
 	err = mt7621_pcie_parse_dt(pcie);
 	if (err) {
 		dev_err(dev, "Parsing DT failed\n");

commit 7f9b583358a4fe31cdbde61e5f50d568be4cc69e
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Sat Jul 20 09:29:08 2019 +0200

    staging: mt7621-pci: avoid use 'err' local variable
    
    Function 'mt7621_pcie_request_resources' is using 'err'
    local variable to get value returned from 'devm_request_pci_bus_resources'
    and returning after that. This is not needed at all. Instead of that
    just directly return returned value by the function which is also
    returning zero on success.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Link: https://lore.kernel.org/r/20190720072908.16795-1-sergio.paracuellos@gmail.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/mt7621-pci/pci-mt7621.c b/drivers/staging/mt7621-pci/pci-mt7621.c
index 2e37fd136ab8..6b98827da57f 100644
--- a/drivers/staging/mt7621-pci/pci-mt7621.c
+++ b/drivers/staging/mt7621-pci/pci-mt7621.c
@@ -617,17 +617,12 @@ static int mt7621_pcie_request_resources(struct mt7621_pcie *pcie,
 					 struct list_head *res)
 {
 	struct device *dev = pcie->dev;
-	int err;
 
 	pci_add_resource_offset(res, &pcie->io, pcie->offset.io);
 	pci_add_resource_offset(res, &pcie->mem, pcie->offset.mem);
 	pci_add_resource(res, &pcie->busn);
 
-	err = devm_request_pci_bus_resources(dev, res);
-	if (err < 0)
-		return err;
-
-	return 0;
+	return devm_request_pci_bus_resources(dev, res);
 }
 
 static int mt7621_pcie_register_host(struct pci_host_bridge *host,

commit 2125a44149cdf6be61fdabce898d26e9ba37dcd0
Author: Nishka Dasgupta <nishkadg.linux@gmail.com>
Date:   Tue Jul 16 11:29:44 2019 +0530

    staging: mt7621-pci: Add of_node_put() before return
    
    Each iteration of for_each_available_child_of_node puts the previous
    node, but in the case of a return from the middle of the loop, there is
    no put, thus causing a memory leak. Hence add an of_node_put before the
    return in two places.
    Issue found with Coccinelle.
    
    Signed-off-by: Nishka Dasgupta <nishkadg.linux@gmail.com>
    Link: https://lore.kernel.org/r/20190716055944.3237-1-nishkadg.linux@gmail.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/mt7621-pci/pci-mt7621.c b/drivers/staging/mt7621-pci/pci-mt7621.c
index 89fa813142ab..2e37fd136ab8 100644
--- a/drivers/staging/mt7621-pci/pci-mt7621.c
+++ b/drivers/staging/mt7621-pci/pci-mt7621.c
@@ -400,6 +400,7 @@ static int mt7621_pcie_parse_dt(struct mt7621_pcie *pcie)
 
 		err = of_pci_get_devfn(child);
 		if (err < 0) {
+			of_node_put(child);
 			dev_err(dev, "failed to parse devfn: %d\n", err);
 			return err;
 		}
@@ -407,8 +408,10 @@ static int mt7621_pcie_parse_dt(struct mt7621_pcie *pcie)
 		slot = PCI_SLOT(err);
 
 		err = mt7621_pcie_parse_port(pcie, child, slot);
-		if (err)
+		if (err) {
+			of_node_put(child);
 			return err;
+		}
 	}
 
 	return 0;

commit 0ae0cf509d28d8539b88b5f7f24558f5bfe57cdf
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Wed Jun 26 14:43:18 2019 +0200

    staging: mt7621-pci: fix PCIE_FTS_NUM_LO macro
    
    Add missing parenthesis to PCIE_FTS_NUM_LO macro to do the
    same it was being done in original code.
    
    Fixes: a4b2eb912bb1 ("staging: mt7621-pci: rewrite RC FTS configuration")
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/mt7621-pci/pci-mt7621.c b/drivers/staging/mt7621-pci/pci-mt7621.c
index a981f4f0ed03..89fa813142ab 100644
--- a/drivers/staging/mt7621-pci/pci-mt7621.c
+++ b/drivers/staging/mt7621-pci/pci-mt7621.c
@@ -42,7 +42,7 @@
 /* MediaTek specific configuration registers */
 #define PCIE_FTS_NUM			0x70c
 #define PCIE_FTS_NUM_MASK		GENMASK(15, 8)
-#define PCIE_FTS_NUM_L0(x)		((x) & 0xff << 8)
+#define PCIE_FTS_NUM_L0(x)		(((x) & 0xff) << 8)
 
 /* rt_sysc_membase relative registers */
 #define RALINK_CLKCFG1			0x30

commit 2e26e96672c2c06e87312d5c5baad7fea29a35bc
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Fri Jun 21 08:15:17 2019 +0200

    staging: mt7621-pci: use 'module_init' instead of 'arch_initcall'
    
    This driver has dependencies on mt7621-gpio and mt7621-pci-phy which
    are init in later stages. Hence, when this driver is probed it is always
    returning 'EPROBE_DEFER' and being initialized afterwards. Use function
    'module_init' to just initialize later.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/mt7621-pci/pci-mt7621.c b/drivers/staging/mt7621-pci/pci-mt7621.c
index da2e180f8d19..a981f4f0ed03 100644
--- a/drivers/staging/mt7621-pci/pci-mt7621.c
+++ b/drivers/staging/mt7621-pci/pci-mt7621.c
@@ -727,4 +727,4 @@ static int __init mt7621_pci_init(void)
 	return platform_driver_register(&mt7621_pci_driver);
 }
 
-arch_initcall(mt7621_pci_init);
+module_init(mt7621_pci_init);

commit cdf6f83b3cca8ba89b6e492c590282395df35470
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Fri Jun 21 08:15:15 2019 +0200

    staging: mt7621-pci: add phy exit call if phy_power_on call fails
    
    Add missing call to 'phy_exit' function if the phy_power_on call fails.
    With this call added the error path is properly handled.
    
    Fixes: 07420a02b003 ("staging: mt7621-pci: use gpio perst instead of builtin behaviour")
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/mt7621-pci/pci-mt7621.c b/drivers/staging/mt7621-pci/pci-mt7621.c
index f6b91b29fb9c..da2e180f8d19 100644
--- a/drivers/staging/mt7621-pci/pci-mt7621.c
+++ b/drivers/staging/mt7621-pci/pci-mt7621.c
@@ -436,6 +436,7 @@ static int mt7621_pcie_init_port(struct mt7621_pcie_port *port)
 	err = phy_power_on(port->phy);
 	if (err) {
 		dev_err(dev, "failed to power on port%d phy\n", slot);
+		phy_exit(port->phy);
 		return err;
 	}
 

commit 36e92f611e33d5e00849d175805fc6c6d4332c25
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Fri Jun 21 08:15:14 2019 +0200

    staging: mt7621-pci: disable pcie port clock if there is no pcie link
    
    When there is no pcie link detected we have to properly disable the
    port pcie clock.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/mt7621-pci/pci-mt7621.c b/drivers/staging/mt7621-pci/pci-mt7621.c
index de09bda0b4cd..f6b91b29fb9c 100644
--- a/drivers/staging/mt7621-pci/pci-mt7621.c
+++ b/drivers/staging/mt7621-pci/pci-mt7621.c
@@ -45,6 +45,7 @@
 #define PCIE_FTS_NUM_L0(x)		((x) & 0xff << 8)
 
 /* rt_sysc_membase relative registers */
+#define RALINK_CLKCFG1			0x30
 #define RALINK_PCIE_CLK_GEN		0x7c
 #define RALINK_PCIE_CLK_GEN1		0x80
 
@@ -221,6 +222,11 @@ static inline bool mt7621_pcie_port_is_linkup(struct mt7621_pcie_port *port)
 	return (pcie_port_read(port, RALINK_PCI_STATUS) & PCIE_PORT_LINKUP) != 0;
 }
 
+static inline void mt7621_pcie_port_clk_disable(struct mt7621_pcie_port *port)
+{
+	rt_sysc_m32(PCIE_PORT_CLK_EN(port->slot), 0, RALINK_CLKCFG1);
+}
+
 static inline void mt7621_control_assert(struct mt7621_pcie_port *port)
 {
 	u32 chip_rev_id = rt_sysc_r32(MT7621_CHIP_REV_ID);
@@ -475,6 +481,7 @@ static void mt7621_pcie_init_ports(struct mt7621_pcie *pcie)
 				slot);
 			phy_power_off(port->phy);
 			mt7621_control_assert(port);
+			mt7621_pcie_port_clk_disable(port);
 			port->enabled = false;
 		}
 	}

commit 07420a02b003ea1f162c4f85a58b3458a4406ce6
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Wed Jun 19 09:44:56 2019 +0200

    staging: mt7621-pci: use gpio perst instead of builtin behaviour
    
    Some boards seems to ignore the PERST builtin behaviour to properly
    perform a pcie line reset. Use gpio PERST behaviour instead which
    seems to be more common.
    
    Fixes: bd1a05bd87ad ("staging: mt7621-pci: use PERST_N instead of gpio control")
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/mt7621-pci/pci-mt7621.c b/drivers/staging/mt7621-pci/pci-mt7621.c
index 7ba6ec93ac0f..de09bda0b4cd 100644
--- a/drivers/staging/mt7621-pci/pci-mt7621.c
+++ b/drivers/staging/mt7621-pci/pci-mt7621.c
@@ -17,6 +17,7 @@
 
 #include <linux/bitops.h>
 #include <linux/delay.h>
+#include <linux/gpio/consumer.h>
 #include <linux/iopoll.h>
 #include <linux/module.h>
 #include <linux/of.h>
@@ -35,6 +36,7 @@
 
 /* sysctl */
 #define MT7621_CHIP_REV_ID		0x0c
+#define MT7621_GPIO_MODE		0x60
 #define CHIP_REV_MT7621_E2		0x0101
 
 /* MediaTek specific configuration registers */
@@ -81,7 +83,6 @@
 #define PCIE_BAR_ENABLE			BIT(0)
 #define PCIE_PORT_INT_EN(x)		BIT(20 + (x))
 #define PCIE_PORT_CLK_EN(x)		BIT(24 + (x))
-#define PCIE_PORT_PERST(x)		BIT(1 + (x))
 #define PCIE_PORT_LINKUP		BIT(0)
 
 #define PCIE_CLK_GEN_EN			BIT(31)
@@ -89,6 +90,9 @@
 #define PCIE_CLK_GEN1_DIS		GENMASK(30, 24)
 #define PCIE_CLK_GEN1_EN		(BIT(27) | BIT(25))
 #define MEMORY_BASE			0x0
+#define PERST_MODE_MASK			GENMASK(11, 10)
+#define PERST_MODE_GPIO			BIT(10)
+#define PERST_DELAY_US			1000
 
 /**
  * struct mt7621_pcie_port - PCIe port information
@@ -119,6 +123,7 @@ struct mt7621_pcie_port {
  * @offset: IO / Memory offset
  * @dev: Pointer to PCIe device
  * @ports: pointer to PCIe port information
+ * @perst: gpio reset
  * @rst: pointer to pcie reset
  */
 struct mt7621_pcie {
@@ -132,6 +137,7 @@ struct mt7621_pcie {
 		resource_size_t io;
 	} offset;
 	struct list_head ports;
+	struct gpio_desc *perst;
 	struct reset_control *rst;
 };
 
@@ -198,6 +204,23 @@ static void write_config(struct mt7621_pcie *pcie, unsigned int dev,
 	pcie_write(pcie, val, RALINK_PCI_CONFIG_DATA);
 }
 
+static inline void mt7621_perst_gpio_pcie_assert(struct mt7621_pcie *pcie)
+{
+	gpiod_set_value(pcie->perst, 0);
+	mdelay(PERST_DELAY_US);
+}
+
+static inline void mt7621_perst_gpio_pcie_deassert(struct mt7621_pcie *pcie)
+{
+	gpiod_set_value(pcie->perst, 1);
+	mdelay(PERST_DELAY_US);
+}
+
+static inline bool mt7621_pcie_port_is_linkup(struct mt7621_pcie_port *port)
+{
+	return (pcie_port_read(port, RALINK_PCI_STATUS) & PCIE_PORT_LINKUP) != 0;
+}
+
 static inline void mt7621_control_assert(struct mt7621_pcie_port *port)
 {
 	u32 chip_rev_id = rt_sysc_r32(MT7621_CHIP_REV_ID);
@@ -344,6 +367,12 @@ static int mt7621_pcie_parse_dt(struct mt7621_pcie *pcie)
 	struct resource regs;
 	int err;
 
+	pcie->perst = devm_gpiod_get(dev, "perst", GPIOD_OUT_HIGH);
+	if (IS_ERR(pcie->perst)) {
+		dev_err(dev, "failed to get gpio perst\n");
+		return PTR_ERR(pcie->perst);
+	}
+
 	err = of_address_to_resource(node, 0, &regs);
 	if (err) {
 		dev_err(dev, "missing \"reg\" property\n");
@@ -384,7 +413,6 @@ static int mt7621_pcie_init_port(struct mt7621_pcie_port *port)
 	struct mt7621_pcie *pcie = port->pcie;
 	struct device *dev = pcie->dev;
 	u32 slot = port->slot;
-	u32 val = 0;
 	int err;
 
 	/*
@@ -393,47 +421,34 @@ static int mt7621_pcie_init_port(struct mt7621_pcie_port *port)
 	 */
 	mt7621_reset_port(port);
 
-	val = read_config(pcie, slot, PCIE_FTS_NUM);
-	dev_info(dev, "Port %d N_FTS = %x\n", slot, (unsigned int)val);
-
 	err = phy_init(port->phy);
 	if (err) {
 		dev_err(dev, "failed to initialize port%d phy\n", slot);
-		goto err_phy_init;
+		return err;
 	}
 
 	err = phy_power_on(port->phy);
 	if (err) {
 		dev_err(dev, "failed to power on port%d phy\n", slot);
-		goto err_phy_on;
-	}
-
-	if ((pcie_port_read(port, RALINK_PCI_STATUS) & PCIE_PORT_LINKUP) == 0) {
-		dev_err(dev, "pcie%d no card, disable it (RST & CLK)\n", slot);
-		mt7621_control_assert(port);
-		port->enabled = false;
-		err = -ENODEV;
-		goto err_no_link_up;
+		return err;
 	}
 
 	port->enabled = true;
 
 	return 0;
-
-err_no_link_up:
-	phy_power_off(port->phy);
-err_phy_on:
-	phy_exit(port->phy);
-err_phy_init:
-	return err;
 }
 
 static void mt7621_pcie_init_ports(struct mt7621_pcie *pcie)
 {
 	struct device *dev = pcie->dev;
 	struct mt7621_pcie_port *port, *tmp;
+	u32 val = 0;
 	int err;
 
+	rt_sysc_m32(PERST_MODE_MASK, PERST_MODE_GPIO, MT7621_GPIO_MODE);
+
+	mt7621_perst_gpio_pcie_assert(pcie);
+
 	list_for_each_entry_safe(port, tmp, &pcie->ports, list) {
 		u32 slot = port->slot;
 
@@ -441,10 +456,29 @@ static void mt7621_pcie_init_ports(struct mt7621_pcie *pcie)
 		if (err) {
 			dev_err(dev, "Initiating port %d failed\n", slot);
 			list_del(&port->list);
+		} else {
+			val = read_config(pcie, slot, PCIE_FTS_NUM);
+			dev_info(dev, "Port %d N_FTS = %x\n", slot,
+				 (unsigned int)val);
 		}
 	}
 
 	reset_control_assert(pcie->rst);
+
+	mt7621_perst_gpio_pcie_deassert(pcie);
+
+	list_for_each_entry(port, &pcie->ports, list) {
+		u32 slot = port->slot;
+
+		if (!mt7621_pcie_port_is_linkup(port)) {
+			dev_err(dev, "pcie%d no card, disable it (RST & CLK)\n",
+				slot);
+			phy_power_off(port->phy);
+			mt7621_control_assert(port);
+			port->enabled = false;
+		}
+	}
+
 	rt_sysc_m32(0x30, 2 << 4, SYSC_REG_SYSTEM_CONFIG1);
 	rt_sysc_m32(PCIE_CLK_GEN_EN, PCIE_CLK_GEN_DIS, RALINK_PCIE_CLK_GEN);
 	rt_sysc_m32(PCIE_CLK_GEN1_DIS, PCIE_CLK_GEN1_EN, RALINK_PCIE_CLK_GEN1);
@@ -453,30 +487,12 @@ static void mt7621_pcie_init_ports(struct mt7621_pcie *pcie)
 	reset_control_deassert(pcie->rst);
 }
 
-static int mt7621_pcie_enable_port(struct mt7621_pcie_port *port)
+static void mt7621_pcie_enable_port(struct mt7621_pcie_port *port)
 {
 	struct mt7621_pcie *pcie = port->pcie;
 	u32 slot = port->slot;
 	u32 offset = MT7621_PCIE_OFFSET + (slot * MT7621_NEXT_PORT);
 	u32 val;
-	int err;
-
-	/* assert port PERST_N */
-	val = pcie_read(pcie, RALINK_PCI_PCICFG_ADDR);
-	val |= PCIE_PORT_PERST(slot);
-	pcie_write(pcie, val, RALINK_PCI_PCICFG_ADDR);
-
-	/* de-assert port PERST_N */
-	val = pcie_read(pcie, RALINK_PCI_PCICFG_ADDR);
-	val &= ~PCIE_PORT_PERST(slot);
-	pcie_write(pcie, val, RALINK_PCI_PCICFG_ADDR);
-
-	/* 100ms timeout value should be enough for Gen1 training */
-	err = readl_poll_timeout(port->base + RALINK_PCI_STATUS,
-				 val, !!(val & PCIE_PORT_LINKUP),
-				 20, 100 * USEC_PER_MSEC);
-	if (err)
-		return -ETIMEDOUT;
 
 	/* enable pcie interrupt */
 	val = pcie_read(pcie, RALINK_PCI_PCIMSK_ADDR);
@@ -492,8 +508,6 @@ static int mt7621_pcie_enable_port(struct mt7621_pcie_port *port)
 	/* configure class code and revision ID */
 	pcie_write(pcie, PCIE_CLASS_CODE | PCIE_REVISION_ID,
 		   offset + RALINK_PCI_CLASS);
-
-	return 0;
 }
 
 static void mt7621_pcie_enable_ports(struct mt7621_pcie *pcie)
@@ -506,11 +520,7 @@ static void mt7621_pcie_enable_ports(struct mt7621_pcie *pcie)
 
 	list_for_each_entry(port, &pcie->ports, list) {
 		if (port->enabled) {
-			if (mt7621_pcie_enable_port(port)) {
-				dev_err(dev, "de-assert port %d PERST_N\n",
-					port->slot);
-				continue;
-			}
+			mt7621_pcie_enable_port(port);
 			dev_info(dev, "PCIE%d enabled\n", num_slots_enabled);
 			num_slots_enabled++;
 		}

commit fdd228cd6d9074b47854af31d224c4241a277618
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Wed Jun 19 09:44:55 2019 +0200

    staging: mt7621-pci: fix two messages in driver code
    
    There are two messages in driver code which are not correct.
    Fix both of them to clarify boot runs.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/mt7621-pci/pci-mt7621.c b/drivers/staging/mt7621-pci/pci-mt7621.c
index 03d919a94552..7ba6ec93ac0f 100644
--- a/drivers/staging/mt7621-pci/pci-mt7621.c
+++ b/drivers/staging/mt7621-pci/pci-mt7621.c
@@ -394,7 +394,7 @@ static int mt7621_pcie_init_port(struct mt7621_pcie_port *port)
 	mt7621_reset_port(port);
 
 	val = read_config(pcie, slot, PCIE_FTS_NUM);
-	dev_info(dev, "Port %d N_FTS = %x\n", (unsigned int)val, slot);
+	dev_info(dev, "Port %d N_FTS = %x\n", slot, (unsigned int)val);
 
 	err = phy_init(port->phy);
 	if (err) {
@@ -511,7 +511,7 @@ static void mt7621_pcie_enable_ports(struct mt7621_pcie *pcie)
 					port->slot);
 				continue;
 			}
-			dev_info(dev, "PCIE%d enabled\n", slot);
+			dev_info(dev, "PCIE%d enabled\n", num_slots_enabled);
 			num_slots_enabled++;
 		}
 	}

commit 6d49a15ead2b3399f8933f1396e4f50c9060f200
Author: Branden Bonaby <brandonbonaby94@gmail.com>
Date:   Tue Mar 12 14:06:15 2019 -0400

    staging: mt7621-pci: IF statement expression comparing to NULL
    
    Remove comparison to NULL in the if statement expression
    to match the Linux Kernel coding style.
    CHECK: Comparison to NULL could be written "res"
    
    Signed-off-by: Branden Bonaby <brandonbonaby94@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/mt7621-pci/pci-mt7621.c b/drivers/staging/mt7621-pci/pci-mt7621.c
index 379ae780c691..03d919a94552 100644
--- a/drivers/staging/mt7621-pci/pci-mt7621.c
+++ b/drivers/staging/mt7621-pci/pci-mt7621.c
@@ -275,7 +275,7 @@ static int mt7621_pci_parse_request_of_pci_ranges(struct mt7621_pcie *pcie)
 			break;
 		}
 
-		if (res != NULL)
+		if (res)
 			of_pci_range_to_resource(&range, node, res);
 	}
 

commit 8b20408a56629a0bd4b04d1a440457cde41503f9
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Fri Feb 15 13:10:40 2019 +0100

    staging: mt7621-pci: reverse condition to check for enabled port
    
    Each enabled port is being checked in 'mt7621_pcie_enable_ports"
    function calling 'mt7621_pcie_enable_port'. The return value for
    this function on success is zero, so the check is reversed. Fix it.
    
    Fixes: 802a2f7b2fe3: staging: mt7621-pci: factor out 'mt7621_pcie_enable_port' function
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/mt7621-pci/pci-mt7621.c b/drivers/staging/mt7621-pci/pci-mt7621.c
index 8a682ce22508..379ae780c691 100644
--- a/drivers/staging/mt7621-pci/pci-mt7621.c
+++ b/drivers/staging/mt7621-pci/pci-mt7621.c
@@ -506,7 +506,7 @@ static void mt7621_pcie_enable_ports(struct mt7621_pcie *pcie)
 
 	list_for_each_entry(port, &pcie->ports, list) {
 		if (port->enabled) {
-			if (!mt7621_pcie_enable_port(port)) {
+			if (mt7621_pcie_enable_port(port)) {
 				dev_err(dev, "de-assert port %d PERST_N\n",
 					port->slot);
 				continue;

commit 1623171dc1232cf5c29665c6477cee6b584ac603
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Tue Feb 12 09:19:22 2019 +0100

    staging: mt7621-pci: remove two register writes
    
    There is no need to write IO and memory space window Host PCI bridge
    registers before doing anything else. Just use its default values which
    should be ok.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Reviewed-by: NeilBrown <neil@brown.name>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/mt7621-pci/pci-mt7621.c b/drivers/staging/mt7621-pci/pci-mt7621.c
index fc2543d076c4..8a682ce22508 100644
--- a/drivers/staging/mt7621-pci/pci-mt7621.c
+++ b/drivers/staging/mt7621-pci/pci-mt7621.c
@@ -88,7 +88,6 @@
 #define PCIE_CLK_GEN_DIS		0
 #define PCIE_CLK_GEN1_DIS		GENMASK(30, 24)
 #define PCIE_CLK_GEN1_EN		(BIT(27) | BIT(25))
-#define RALINK_PCI_IO_MAP_BASE		0x1e160000
 #define MEMORY_BASE			0x0
 
 /**
@@ -666,9 +665,6 @@ static int mt7621_pci_probe(struct platform_device *pdev)
 		return 0;
 	}
 
-	pcie_write(pcie, 0xffffffff, RALINK_PCI_MEMBASE);
-	pcie_write(pcie, RALINK_PCI_IO_MAP_BASE, RALINK_PCI_IOBASE);
-
 	mt7621_pcie_enable_ports(pcie);
 
 	err = mt7621_pci_parse_request_of_pci_ranges(pcie);

commit 186e86806035834da4dad21ed8260d1062c8a2cf
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Tue Feb 12 09:19:21 2019 +0100

    staging: mt7621-pci: replace spaces with tabs in comment
    
    To properly follow kernel style replace spaces with tabs in comment
    where link status bits are explained.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Reviewed-by: NeilBrown <neil@brown.name>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/mt7621-pci/pci-mt7621.c b/drivers/staging/mt7621-pci/pci-mt7621.c
index 998d48fd3e7a..fc2543d076c4 100644
--- a/drivers/staging/mt7621-pci/pci-mt7621.c
+++ b/drivers/staging/mt7621-pci/pci-mt7621.c
@@ -546,15 +546,15 @@ static int mt7621_pcie_init_virtual_bridges(struct mt7621_pcie *pcie)
 		return -1;
 
 	/*
-	 * pcie(2/1/0) link status pcie2_num	pcie1_num	pcie0_num
-	 * 3'b000		   x	        x		x
-	 * 3'b001		   x	        x		0
-	 * 3'b010		   x	        0		x
-	 * 3'b011		   x	        1		0
-	 * 3'b100		   0	        x		x
-	 * 3'b101	           1 	        x		0
-	 * 3'b110	           1	        0		x
-	 * 3'b111		   2	        1		0
+	 * pcie(2/1/0) link status	pcie2_num	pcie1_num	pcie0_num
+	 * 3'b000			x		x		x
+	 * 3'b001			x		x		0
+	 * 3'b010			x		0		x
+	 * 3'b011			x		1		0
+	 * 3'b100			0		x		x
+	 * 3'b101			1		x		0
+	 * 3'b110			1		0		x
+	 * 3'b111			2		1		0
 	 */
 	switch (pcie_link_status) {
 	case 2:

commit fa461f6a4cbe02db9e72dfc6eafb01423c12e44a
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Tue Feb 12 09:19:20 2019 +0100

    staging: mt7621-pci: remove not used definitions
    
    There are two definitions which are not being used at all.
    Remove them.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Reviewed-by: NeilBrown <neil@brown.name>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/mt7621-pci/pci-mt7621.c b/drivers/staging/mt7621-pci/pci-mt7621.c
index ad38a787b2da..998d48fd3e7a 100644
--- a/drivers/staging/mt7621-pci/pci-mt7621.c
+++ b/drivers/staging/mt7621-pci/pci-mt7621.c
@@ -35,8 +35,6 @@
 
 /* sysctl */
 #define MT7621_CHIP_REV_ID		0x0c
-#define RALINK_CLKCFG1			0x30
-#define RALINK_RSTCTRL			0x34
 #define CHIP_REV_MT7621_E2		0x0101
 
 /* MediaTek specific configuration registers */

commit 47f87b690d2d8314fa607986c4bc9f3711b54ba5
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Tue Feb 12 09:19:18 2019 +0100

    staging: mt7621-pci: add reset control for general pcie reset
    
    There is still a reset line which is not being handled using reset_control
    properly and just being accessing writing registers. Use reset_control
    instead for pcie general reset line.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Reviewed-by: NeilBrown <neil@brown.name>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/mt7621-pci/pci-mt7621.c b/drivers/staging/mt7621-pci/pci-mt7621.c
index a5c31807bb8f..ad38a787b2da 100644
--- a/drivers/staging/mt7621-pci/pci-mt7621.c
+++ b/drivers/staging/mt7621-pci/pci-mt7621.c
@@ -39,9 +39,6 @@
 #define RALINK_RSTCTRL			0x34
 #define CHIP_REV_MT7621_E2		0x0101
 
-/* RALINK_RSTCTRL bits */
-#define RALINK_PCIE_RST			BIT(23)
-
 /* MediaTek specific configuration registers */
 #define PCIE_FTS_NUM			0x70c
 #define PCIE_FTS_NUM_MASK		GENMASK(15, 8)
@@ -125,6 +122,7 @@ struct mt7621_pcie_port {
  * @offset: IO / Memory offset
  * @dev: Pointer to PCIe device
  * @ports: pointer to PCIe port information
+ * @rst: pointer to pcie reset
  */
 struct mt7621_pcie {
 	void __iomem *base;
@@ -137,6 +135,7 @@ struct mt7621_pcie {
 		resource_size_t io;
 	} offset;
 	struct list_head ports;
+	struct reset_control *rst;
 };
 
 static inline u32 pcie_read(struct mt7621_pcie *pcie, u32 reg)
@@ -358,6 +357,12 @@ static int mt7621_pcie_parse_dt(struct mt7621_pcie *pcie)
 	if (IS_ERR(pcie->base))
 		return PTR_ERR(pcie->base);
 
+	pcie->rst = devm_reset_control_get_exclusive(dev, "pcie");
+	if (PTR_ERR(pcie->rst) == -EPROBE_DEFER) {
+		dev_err(dev, "failed to get pcie reset control\n");
+		return PTR_ERR(pcie->rst);
+	}
+
 	for_each_available_child_of_node(node, child) {
 		int slot;
 
@@ -442,13 +447,13 @@ static void mt7621_pcie_init_ports(struct mt7621_pcie *pcie)
 		}
 	}
 
-	rt_sysc_m32(0, RALINK_PCIE_RST, RALINK_RSTCTRL);
+	reset_control_assert(pcie->rst);
 	rt_sysc_m32(0x30, 2 << 4, SYSC_REG_SYSTEM_CONFIG1);
 	rt_sysc_m32(PCIE_CLK_GEN_EN, PCIE_CLK_GEN_DIS, RALINK_PCIE_CLK_GEN);
 	rt_sysc_m32(PCIE_CLK_GEN1_DIS, PCIE_CLK_GEN1_EN, RALINK_PCIE_CLK_GEN1);
 	rt_sysc_m32(PCIE_CLK_GEN_DIS, PCIE_CLK_GEN_EN, RALINK_PCIE_CLK_GEN);
 	msleep(50);
-	rt_sysc_m32(RALINK_PCIE_RST, 0, RALINK_RSTCTRL);
+	reset_control_deassert(pcie->rst);
 }
 
 static int mt7621_pcie_enable_port(struct mt7621_pcie_port *port)

commit d099c72d3868e54f1092ae0e9ed0d65baa22adc8
Author: Guilherme Tadashi Maeoka <gui.maeoka@gmail.com>
Date:   Sat Feb 9 15:17:18 2019 -0200

    Staging: mt7621-pci: Fix space required coding style
    
    Fix some space required coding style.
    
    Signed-off-by: Guilherme Tadashi Maeoka <gui.maeoka@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/mt7621-pci/pci-mt7621.c b/drivers/staging/mt7621-pci/pci-mt7621.c
index 507b8c68d20b..a5c31807bb8f 100644
--- a/drivers/staging/mt7621-pci/pci-mt7621.c
+++ b/drivers/staging/mt7621-pci/pci-mt7621.c
@@ -91,7 +91,7 @@
 
 #define PCIE_CLK_GEN_EN			BIT(31)
 #define PCIE_CLK_GEN_DIS		0
-#define PCIE_CLK_GEN1_DIS		GENMASK(30,24)
+#define PCIE_CLK_GEN1_DIS		GENMASK(30, 24)
 #define PCIE_CLK_GEN1_EN		(BIT(27) | BIT(25))
 #define RALINK_PCI_IO_MAP_BASE		0x1e160000
 #define MEMORY_BASE			0x0
@@ -529,7 +529,7 @@ static void mt7621_pcie_enable_ports(struct mt7621_pcie *pcie)
 static int mt7621_pcie_init_virtual_bridges(struct mt7621_pcie *pcie)
 {
 	u32 pcie_link_status = 0;
-	u32 val= 0;
+	u32 val = 0;
 	struct mt7621_pcie_port *port;
 
 	list_for_each_entry(port, &pcie->ports, list) {

commit 7c106cbb2ba8c86bedd2868b690aee8965476b3b
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Mon Jan 7 20:31:43 2019 +0100

    staging: mt7621-pci: use PCI definitions instead of hardcode values
    
    Seting up ports to enable PCI_COMMAND_MASTER is using '0x4' as a
    hardcore value and '0x4' also for PCI_COMMAND register instead
    of use definitions from linux pci system headers. Replace both.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/mt7621-pci/pci-mt7621.c b/drivers/staging/mt7621-pci/pci-mt7621.c
index 8db94fdbdd6d..507b8c68d20b 100644
--- a/drivers/staging/mt7621-pci/pci-mt7621.c
+++ b/drivers/staging/mt7621-pci/pci-mt7621.c
@@ -515,8 +515,9 @@ static void mt7621_pcie_enable_ports(struct mt7621_pcie *pcie)
 	}
 
 	for (slot = 0; slot < num_slots_enabled; slot++) {
-		val = read_config(pcie, slot, 0x4);
-		write_config(pcie, slot, 0x4, val | 0x4);
+		val = read_config(pcie, slot, PCI_COMMAND);
+		val |= PCI_COMMAND_MASTER;
+		write_config(pcie, slot, PCI_COMMAND, val);
 		/* configure RC FTS number to 250 when it leaves L0s */
 		val = read_config(pcie, slot, PCIE_FTS_NUM);
 		val &= ~PCIE_FTS_NUM_MASK;

commit 61f9bde6ea578f5baa1662c97365f7b36fc790fa
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Fri Jan 4 08:08:22 2019 +0100

    staging: mt7621-pci: handle phy using new generic phy 'pci-mt7621-phy' driver
    
    Phy part of this driver has been moved to a new 'pci-mt7621-phy' driver.
    Change code to use kernel's generic phy API removing also no more need
    moved code.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/mt7621-pci/pci-mt7621.c b/drivers/staging/mt7621-pci/pci-mt7621.c
index 31310b6fb7db..8db94fdbdd6d 100644
--- a/drivers/staging/mt7621-pci/pci-mt7621.c
+++ b/drivers/staging/mt7621-pci/pci-mt7621.c
@@ -25,6 +25,7 @@
 #include <linux/of_pci.h>
 #include <linux/of_platform.h>
 #include <linux/pci.h>
+#include <linux/phy/phy.h>
 #include <linux/platform_device.h>
 #include <linux/reset.h>
 #include <mt7621.h>
@@ -95,76 +96,12 @@
 #define RALINK_PCI_IO_MAP_BASE		0x1e160000
 #define MEMORY_BASE			0x0
 
-/* pcie phy related macros */
-#define RALINK_PCIEPHY_P0P1_CTL_OFFSET	0x9000
-#define RALINK_PCIEPHY_P2_CTL_OFFSET	0xA000
-
-#define RG_P0_TO_P1_WIDTH		0x100
-
-#define RG_PE1_PIPE_REG			0x02c
-#define RG_PE1_PIPE_RST			BIT(12)
-#define RG_PE1_PIPE_CMD_FRC		BIT(4)
-
-#define RG_PE1_H_LCDDS_REG		0x49c
-#define RG_PE1_H_LCDDS_PCW		GENMASK(30, 0)
-#define RG_PE1_H_LCDDS_PCW_VAL(x)	((0x7fffffff & (x)) << 0)
-
-#define RG_PE1_FRC_H_XTAL_REG		0x400
-#define RG_PE1_FRC_H_XTAL_TYPE          BIT(8)
-#define RG_PE1_H_XTAL_TYPE              GENMASK(10, 9)
-#define RG_PE1_H_XTAL_TYPE_VAL(x)       ((0x3 & (x)) << 9)
-
-#define RG_PE1_FRC_PHY_REG		0x000
-#define RG_PE1_FRC_PHY_EN               BIT(4)
-#define RG_PE1_PHY_EN                   BIT(5)
-
-#define RG_PE1_H_PLL_REG		0x490
-#define RG_PE1_H_PLL_BC			GENMASK(23, 22)
-#define RG_PE1_H_PLL_BC_VAL(x)		((0x3 & (x)) << 22)
-#define RG_PE1_H_PLL_BP			GENMASK(21, 18)
-#define RG_PE1_H_PLL_BP_VAL(x)		((0xf & (x)) << 18)
-#define RG_PE1_H_PLL_IR			GENMASK(15, 12)
-#define RG_PE1_H_PLL_IR_VAL(x)		((0xf & (x)) << 12)
-#define RG_PE1_H_PLL_IC			GENMASK(11, 8)
-#define RG_PE1_H_PLL_IC_VAL(x)		((0xf & (x)) << 8)
-#define RG_PE1_H_PLL_PREDIV             GENMASK(7, 6)
-#define RG_PE1_H_PLL_PREDIV_VAL(x)      ((0x3 & (x)) << 6)
-#define RG_PE1_PLL_DIVEN		GENMASK(3, 1)
-#define RG_PE1_PLL_DIVEN_VAL(x)		((0x7 & (x)) << 1)
-
-#define RG_PE1_H_PLL_FBKSEL_REG		0x4bc
-#define RG_PE1_H_PLL_FBKSEL             GENMASK(5, 4)
-#define RG_PE1_H_PLL_FBKSEL_VAL(x)      ((0x3 & (x)) << 4)
-
-#define	RG_PE1_H_LCDDS_SSC_PRD_REG	0x4a4
-#define RG_PE1_H_LCDDS_SSC_PRD          GENMASK(15, 0)
-#define RG_PE1_H_LCDDS_SSC_PRD_VAL(x)   ((0xffff & (x)) << 0)
-
-#define RG_PE1_H_LCDDS_SSC_DELTA_REG	0x4a8
-#define RG_PE1_H_LCDDS_SSC_DELTA        GENMASK(11, 0)
-#define RG_PE1_H_LCDDS_SSC_DELTA_VAL(x) ((0xfff & (x)) << 0)
-#define RG_PE1_H_LCDDS_SSC_DELTA1       GENMASK(27, 16)
-#define RG_PE1_H_LCDDS_SSC_DELTA1_VAL(x) ((0xff & (x)) << 16)
-
-#define RG_PE1_LCDDS_CLK_PH_INV_REG	0x4a0
-#define RG_PE1_LCDDS_CLK_PH_INV		BIT(5)
-
-#define RG_PE1_H_PLL_BR_REG		0x4ac
-#define RG_PE1_H_PLL_BR			GENMASK(18, 16)
-#define RG_PE1_H_PLL_BR_VAL(x)		((0x7 & (x)) << 16)
-
-#define	RG_PE1_MSTCKDIV_REG		0x414
-#define RG_PE1_MSTCKDIV			GENMASK(7, 6)
-#define RG_PE1_MSTCKDIV_VAL(x)		((0x3 & (x)) << 6)
-
-#define RG_PE1_FRC_MSTCKDIV		BIT(5)
-
 /**
  * struct mt7621_pcie_port - PCIe port information
  * @base: I/O mapped register base
  * @list: port list
  * @pcie: pointer to PCIe host info
- * @phy_reg_offset: offset to related phy registers
+ * @phy: pointer to PHY control block
  * @pcie_rst: pointer to port reset control
  * @slot: port slot
  * @enabled: indicates if port is enabled
@@ -173,7 +110,7 @@ struct mt7621_pcie_port {
 	void __iomem *base;
 	struct list_head list;
 	struct mt7621_pcie *pcie;
-	u32 phy_reg_offset;
+	struct phy *phy;
 	struct reset_control *pcie_rst;
 	u32 slot;
 	bool enabled;
@@ -265,150 +202,6 @@ static void write_config(struct mt7621_pcie *pcie, unsigned int dev,
 	pcie_write(pcie, val, RALINK_PCI_CONFIG_DATA);
 }
 
-static void bypass_pipe_rst(struct mt7621_pcie_port *port)
-{
-	struct mt7621_pcie *pcie = port->pcie;
-	u32 phy_offset = port->phy_reg_offset;
-	u32 offset = (port->slot != 1) ?
-		phy_offset + RG_PE1_PIPE_REG :
-		phy_offset + RG_PE1_PIPE_REG + RG_P0_TO_P1_WIDTH;
-	u32 reg = pcie_read(pcie, offset);
-
-	reg &= ~(RG_PE1_PIPE_RST | RG_PE1_PIPE_CMD_FRC);
-	reg |= (RG_PE1_PIPE_RST | RG_PE1_PIPE_CMD_FRC);
-	pcie_write(pcie, reg, offset);
-}
-
-static void set_phy_for_ssc(struct mt7621_pcie_port *port)
-{
-	struct mt7621_pcie *pcie = port->pcie;
-	struct device *dev = pcie->dev;
-	u32 phy_offset = port->phy_reg_offset;
-	u32 reg = rt_sysc_r32(SYSC_REG_SYSTEM_CONFIG0);
-	u32 offset;
-	u32 val;
-
-	reg = (reg >> 6) & 0x7;
-	/* Set PCIe Port PHY to disable SSC */
-	/* Debug Xtal Type */
-	offset = phy_offset + RG_PE1_FRC_H_XTAL_REG;
-	val = pcie_read(pcie, offset);
-	val &= ~(RG_PE1_FRC_H_XTAL_TYPE | RG_PE1_H_XTAL_TYPE);
-	val |= RG_PE1_FRC_H_XTAL_TYPE;
-	val |= RG_PE1_H_XTAL_TYPE_VAL(0x00);
-	pcie_write(pcie, val, offset);
-
-	/* disable port */
-	offset = (port->slot != 1) ?
-		phy_offset + RG_PE1_FRC_PHY_REG :
-		phy_offset + RG_PE1_FRC_PHY_REG + RG_P0_TO_P1_WIDTH;
-	val = pcie_read(pcie, offset);
-	val &= ~(RG_PE1_FRC_PHY_EN | RG_PE1_PHY_EN);
-	val |= RG_PE1_FRC_PHY_EN;
-	pcie_write(pcie, val, offset);
-
-	/* Set Pre-divider ratio (for host mode) */
-	offset =  phy_offset + RG_PE1_H_PLL_REG;
-	val = pcie_read(pcie, offset);
-	val &= ~(RG_PE1_H_PLL_PREDIV);
-
-	if (reg <= 5 && reg >= 3) { /* 40MHz Xtal */
-		val |= RG_PE1_H_PLL_PREDIV_VAL(0x01);
-		pcie_write(pcie, val, offset);
-		dev_info(dev, "Xtal is 40MHz\n");
-	} else { /* 25MHz | 20MHz Xtal */
-		val |= RG_PE1_H_PLL_PREDIV_VAL(0x00);
-		pcie_write(pcie, val, offset);
-		if (reg >= 6) {
-			dev_info(dev, "Xtal is 25MHz\n");
-
-			/* Select feedback clock */
-			offset = phy_offset + RG_PE1_H_PLL_FBKSEL_REG;
-			val = pcie_read(pcie, offset);
-			val &= ~(RG_PE1_H_PLL_FBKSEL);
-			val |= RG_PE1_H_PLL_FBKSEL_VAL(0x01);
-			pcie_write(pcie, val, offset);
-
-			/* DDS NCPO PCW (for host mode) */
-			offset = phy_offset + RG_PE1_H_LCDDS_SSC_PRD_REG;
-			val = pcie_read(pcie, offset);
-			val &= ~(RG_PE1_H_LCDDS_SSC_PRD);
-			val |= RG_PE1_H_LCDDS_SSC_PRD_VAL(0x18000000);
-			pcie_write(pcie, val, offset);
-
-			/* DDS SSC dither period control */
-			offset = phy_offset + RG_PE1_H_LCDDS_SSC_PRD_REG;
-			val = pcie_read(pcie, offset);
-			val &= ~(RG_PE1_H_LCDDS_SSC_PRD);
-			val |= RG_PE1_H_LCDDS_SSC_PRD_VAL(0x18d);
-			pcie_write(pcie, val, offset);
-
-			/* DDS SSC dither amplitude control */
-			offset = phy_offset + RG_PE1_H_LCDDS_SSC_DELTA_REG;
-			val = pcie_read(pcie, offset);
-			val &= ~(RG_PE1_H_LCDDS_SSC_DELTA |
-				 RG_PE1_H_LCDDS_SSC_DELTA1);
-			val |= RG_PE1_H_LCDDS_SSC_DELTA_VAL(0x4a);
-			val |= RG_PE1_H_LCDDS_SSC_DELTA1_VAL(0x4a);
-			pcie_write(pcie, val, offset);
-		} else {
-			dev_info(dev, "Xtal is 20MHz\n");
-		}
-	}
-
-	/* DDS clock inversion */
-	offset = phy_offset + RG_PE1_LCDDS_CLK_PH_INV_REG;
-	val = pcie_read(pcie, offset);
-	val &= ~(RG_PE1_LCDDS_CLK_PH_INV);
-	val |= RG_PE1_LCDDS_CLK_PH_INV;
-	pcie_write(pcie, val, offset);
-
-	/* Set PLL bits */
-	offset = phy_offset + RG_PE1_H_PLL_REG;
-	val = pcie_read(pcie, offset);
-	val &= ~(RG_PE1_H_PLL_BC | RG_PE1_H_PLL_BP | RG_PE1_H_PLL_IR |
-		 RG_PE1_H_PLL_IC | RG_PE1_PLL_DIVEN);
-	val |= RG_PE1_H_PLL_BC_VAL(0x02);
-	val |= RG_PE1_H_PLL_BP_VAL(0x06);
-	val |= RG_PE1_H_PLL_IR_VAL(0x02);
-	val |= RG_PE1_H_PLL_IC_VAL(0x01);
-	val |= RG_PE1_PLL_DIVEN_VAL(0x02);
-	pcie_write(pcie, val, offset);
-
-	offset = phy_offset + RG_PE1_H_PLL_BR_REG;
-	val = pcie_read(pcie, offset);
-	val &= ~(RG_PE1_H_PLL_BR);
-	val |= RG_PE1_H_PLL_BR_VAL(0x00);
-	pcie_write(pcie, val, offset);
-
-	if (reg <= 5 && reg >= 3) { /* 40MHz Xtal */
-		/* set force mode enable of da_pe1_mstckdiv */
-		offset = phy_offset + RG_PE1_MSTCKDIV_REG;
-		val = pcie_read(pcie, offset);
-		val &= ~(RG_PE1_MSTCKDIV | RG_PE1_FRC_MSTCKDIV);
-		val |= (RG_PE1_MSTCKDIV_VAL(0x01) | RG_PE1_FRC_MSTCKDIV);
-		pcie_write(pcie, val, offset);
-	}
-
-	/* Enable PHY and disable force mode */
-	offset = (port->slot != 1) ?
-		phy_offset + RG_PE1_FRC_PHY_REG :
-		phy_offset + RG_PE1_FRC_PHY_REG + RG_P0_TO_P1_WIDTH;
-	val = pcie_read(pcie, offset);
-	val &= ~(RG_PE1_FRC_PHY_EN | RG_PE1_PHY_EN);
-	val |= (RG_PE1_FRC_PHY_EN | RG_PE1_PHY_EN);
-	pcie_write(pcie, val, offset);
-}
-
-static void mt7621_enable_phy(struct mt7621_pcie_port *port)
-{
-	u32 chip_rev_id = rt_sysc_r32(MT7621_CHIP_REV_ID);
-
-	if ((chip_rev_id & 0xFFFF) == CHIP_REV_MT7621_E2)
-		bypass_pipe_rst(port);
-	set_phy_for_ssc(port);
-}
-
 static inline void mt7621_control_assert(struct mt7621_pcie_port *port)
 {
 	u32 chip_rev_id = rt_sysc_r32(MT7621_CHIP_REV_ID);
@@ -510,7 +303,7 @@ static int mt7621_pcie_parse_port(struct mt7621_pcie *pcie,
 	struct device *dev = pcie->dev;
 	struct device_node *pnode = dev->of_node;
 	struct resource regs;
-	char name[6];
+	char name[10];
 	int err;
 
 	port = devm_kzalloc(dev, sizeof(*port), GFP_KERNEL);
@@ -534,11 +327,13 @@ static int mt7621_pcie_parse_port(struct mt7621_pcie *pcie,
 		return PTR_ERR(port->pcie_rst);
 	}
 
+	snprintf(name, sizeof(name), "pcie-phy%d", slot);
+	port->phy = devm_phy_get(dev, name);
+	if (IS_ERR(port->phy))
+		return PTR_ERR(port->phy);
+
 	port->slot = slot;
 	port->pcie = pcie;
-	port->phy_reg_offset = (slot != 2) ?
-				RALINK_PCIEPHY_P0P1_CTL_OFFSET :
-				RALINK_PCIEPHY_P2_CTL_OFFSET;
 
 	INIT_LIST_HEAD(&port->list);
 	list_add_tail(&port->list, &pcie->ports);
@@ -588,6 +383,7 @@ static int mt7621_pcie_init_port(struct mt7621_pcie_port *port)
 	struct device *dev = pcie->dev;
 	u32 slot = port->slot;
 	u32 val = 0;
+	int err;
 
 	/*
 	 * Any MT7621 Ralink pcie controller that doesn't have 0x0101 at
@@ -598,18 +394,36 @@ static int mt7621_pcie_init_port(struct mt7621_pcie_port *port)
 	val = read_config(pcie, slot, PCIE_FTS_NUM);
 	dev_info(dev, "Port %d N_FTS = %x\n", (unsigned int)val, slot);
 
+	err = phy_init(port->phy);
+	if (err) {
+		dev_err(dev, "failed to initialize port%d phy\n", slot);
+		goto err_phy_init;
+	}
+
+	err = phy_power_on(port->phy);
+	if (err) {
+		dev_err(dev, "failed to power on port%d phy\n", slot);
+		goto err_phy_on;
+	}
+
 	if ((pcie_port_read(port, RALINK_PCI_STATUS) & PCIE_PORT_LINKUP) == 0) {
 		dev_err(dev, "pcie%d no card, disable it (RST & CLK)\n", slot);
 		mt7621_control_assert(port);
-		rt_sysc_m32(PCIE_PORT_CLK_EN(slot), 0, RALINK_CLKCFG1);
 		port->enabled = false;
-	} else {
-		port->enabled = true;
+		err = -ENODEV;
+		goto err_no_link_up;
 	}
 
-	mt7621_enable_phy(port);
+	port->enabled = true;
 
 	return 0;
+
+err_no_link_up:
+	phy_power_off(port->phy);
+err_phy_on:
+	phy_exit(port->phy);
+err_phy_init:
+	return err;
 }
 
 static void mt7621_pcie_init_ports(struct mt7621_pcie *pcie)

commit 8cfb722bd55ab3879486001797741e879fbc7095
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Thu Nov 29 19:39:55 2018 +0100

    staging: mt7621-pci: add comment clarifying inverted reset lines
    
    To avoid people reading this code being very confused, add a comment
    clarifying the need for invert resets on some chip revisions.
    
    Suggested-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/mt7621-pci/pci-mt7621.c b/drivers/staging/mt7621-pci/pci-mt7621.c
index c5e33fbdf225..31310b6fb7db 100644
--- a/drivers/staging/mt7621-pci/pci-mt7621.c
+++ b/drivers/staging/mt7621-pci/pci-mt7621.c
@@ -589,6 +589,10 @@ static int mt7621_pcie_init_port(struct mt7621_pcie_port *port)
 	u32 slot = port->slot;
 	u32 val = 0;
 
+	/*
+	 * Any MT7621 Ralink pcie controller that doesn't have 0x0101 at
+	 * the end of the chip_id has inverted PCI resets.
+	 */
 	mt7621_reset_port(port);
 
 	val = read_config(pcie, slot, PCIE_FTS_NUM);

commit 2f5496d878c6616235ab14e88ea056b9671514e6
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Sat Nov 24 18:54:55 2018 +0100

    staging: mt7621-pci: avoid using clk_* operations
    
    There is no clock driver for ralink mips and clk_enable
    are no-ops for this architecture. This has been also tested
    without using clocks and seems to work so avoid to use them
    in this driver.
    
    Fixes: ad9c87e129d1: "staging: mt7621-pci: parse and init
    port data from device tree"
    Reported-by: NeilBrown <neil@brown.name>
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Tested-by: NeilBrown <neil@brown.name>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/mt7621-pci/pci-mt7621.c b/drivers/staging/mt7621-pci/pci-mt7621.c
index 1b63706e129b..c5e33fbdf225 100644
--- a/drivers/staging/mt7621-pci/pci-mt7621.c
+++ b/drivers/staging/mt7621-pci/pci-mt7621.c
@@ -16,7 +16,6 @@
  */
 
 #include <linux/bitops.h>
-#include <linux/clk.h>
 #include <linux/delay.h>
 #include <linux/iopoll.h>
 #include <linux/module.h>
@@ -167,7 +166,6 @@
  * @pcie: pointer to PCIe host info
  * @phy_reg_offset: offset to related phy registers
  * @pcie_rst: pointer to port reset control
- * @pcie_clk: PCIe clock
  * @slot: port slot
  * @enabled: indicates if port is enabled
  */
@@ -177,7 +175,6 @@ struct mt7621_pcie_port {
 	struct mt7621_pcie *pcie;
 	u32 phy_reg_offset;
 	struct reset_control *pcie_rst;
-	struct clk *pcie_clk;
 	u32 slot;
 	bool enabled;
 };
@@ -531,12 +528,6 @@ static int mt7621_pcie_parse_port(struct mt7621_pcie *pcie,
 		return PTR_ERR(port->base);
 
 	snprintf(name, sizeof(name), "pcie%d", slot);
-	port->pcie_clk = devm_clk_get(dev, name);
-	if (IS_ERR(port->pcie_clk)) {
-		dev_err(dev, "failed to get pcie%d clock\n", slot);
-		return PTR_ERR(port->pcie_clk);
-	}
-
 	port->pcie_rst = devm_reset_control_get_exclusive(dev, name);
 	if (PTR_ERR(port->pcie_rst) == -EPROBE_DEFER) {
 		dev_err(dev, "failed to get pcie%d reset control\n", slot);
@@ -597,13 +588,6 @@ static int mt7621_pcie_init_port(struct mt7621_pcie_port *port)
 	struct device *dev = pcie->dev;
 	u32 slot = port->slot;
 	u32 val = 0;
-	int err;
-
-	err = clk_prepare_enable(port->pcie_clk);
-	if (err) {
-		dev_err(dev, "failed to enable pcie%d clock\n", slot);
-		return err;
-	}
 
 	mt7621_reset_port(port);
 

commit e51844bf825169024e0c743a92cf264e27f2366f
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Sat Nov 24 18:54:54 2018 +0100

    staging: mt7621-pci: fix reset lines for each pcie port
    
    Depending of chip revision reset lines are inverted. It is also
    necessary to read PCIE_FTS_NUM register before enabling the phy.
    Hence update the code to achieve this.
    
    Fixes: 745eeeac68d7 ("staging: mt7621-pci: factor out 'mt7621_pcie_enable_port' function")
    Reported-by: NeilBrown <neil@brown.name>
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Tested-by: NeilBrown <neil@brown.name>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/mt7621-pci/pci-mt7621.c b/drivers/staging/mt7621-pci/pci-mt7621.c
index ba81b34dc1b7..1b63706e129b 100644
--- a/drivers/staging/mt7621-pci/pci-mt7621.c
+++ b/drivers/staging/mt7621-pci/pci-mt7621.c
@@ -412,6 +412,33 @@ static void mt7621_enable_phy(struct mt7621_pcie_port *port)
 	set_phy_for_ssc(port);
 }
 
+static inline void mt7621_control_assert(struct mt7621_pcie_port *port)
+{
+	u32 chip_rev_id = rt_sysc_r32(MT7621_CHIP_REV_ID);
+
+	if ((chip_rev_id & 0xFFFF) == CHIP_REV_MT7621_E2)
+		reset_control_assert(port->pcie_rst);
+	else
+		reset_control_deassert(port->pcie_rst);
+}
+
+static inline void mt7621_control_deassert(struct mt7621_pcie_port *port)
+{
+	u32 chip_rev_id = rt_sysc_r32(MT7621_CHIP_REV_ID);
+
+	if ((chip_rev_id & 0xFFFF) == CHIP_REV_MT7621_E2)
+		reset_control_deassert(port->pcie_rst);
+	else
+		reset_control_assert(port->pcie_rst);
+}
+
+static void mt7621_reset_port(struct mt7621_pcie_port *port)
+{
+	mt7621_control_assert(port);
+	msleep(100);
+	mt7621_control_deassert(port);
+}
+
 static void setup_cm_memory_region(struct mt7621_pcie *pcie)
 {
 	struct resource *mem_resource = &pcie->mem;
@@ -578,12 +605,14 @@ static int mt7621_pcie_init_port(struct mt7621_pcie_port *port)
 		return err;
 	}
 
-	reset_control_assert(port->pcie_rst);
-	reset_control_deassert(port->pcie_rst);
+	mt7621_reset_port(port);
+
+	val = read_config(pcie, slot, PCIE_FTS_NUM);
+	dev_info(dev, "Port %d N_FTS = %x\n", (unsigned int)val, slot);
 
 	if ((pcie_port_read(port, RALINK_PCI_STATUS) & PCIE_PORT_LINKUP) == 0) {
 		dev_err(dev, "pcie%d no card, disable it (RST & CLK)\n", slot);
-		reset_control_assert(port->pcie_rst);
+		mt7621_control_assert(port);
 		rt_sysc_m32(PCIE_PORT_CLK_EN(slot), 0, RALINK_CLKCFG1);
 		port->enabled = false;
 	} else {
@@ -592,9 +621,6 @@ static int mt7621_pcie_init_port(struct mt7621_pcie_port *port)
 
 	mt7621_enable_phy(port);
 
-	val = read_config(pcie, slot, PCIE_FTS_NUM);
-	dev_info(dev, "Port %d N_FTS = %x\n", (unsigned int)val, slot);
-
 	return 0;
 }
 

commit ce0c99e22e458ac5ef7bdb14c143894146c8f4f8
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Sat Nov 24 18:54:51 2018 +0100

    staging: mt7621-pci: avoid mapping sysctls registers
    
    The sysctl register are already claimed by palmbus, so
    pci fails to claim it. The best way to access the sysc registers
    is to use rt_sysc_[rwm]32().
    
    Fixes: 89e9f6e6adfc: staging: mt7621-pci: remap and use sysctl from device tree
    Reported-by: NeilBrown <neil@brown.name>
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Tested-by: NeilBrown <neil@brown.name>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/mt7621-pci/pci-mt7621.c b/drivers/staging/mt7621-pci/pci-mt7621.c
index 14cec231946c..ba81b34dc1b7 100644
--- a/drivers/staging/mt7621-pci/pci-mt7621.c
+++ b/drivers/staging/mt7621-pci/pci-mt7621.c
@@ -185,7 +185,6 @@ struct mt7621_pcie_port {
 /**
  * struct mt7621_pcie - PCIe host information
  * @base: IO Mapped Register Base
- * @sysctl: system control mapped register base
  * @io: IO resource
  * @mem: non-prefetchable memory resource
  * @busn: bus range
@@ -195,7 +194,6 @@ struct mt7621_pcie_port {
  */
 struct mt7621_pcie {
 	void __iomem *base;
-	void __iomem *sysctl;
 	struct device *dev;
 	struct resource io;
 	struct resource mem;
@@ -407,8 +405,7 @@ static void set_phy_for_ssc(struct mt7621_pcie_port *port)
 
 static void mt7621_enable_phy(struct mt7621_pcie_port *port)
 {
-	struct mt7621_pcie *pcie = port->pcie;
-	u32 chip_rev_id = ioread32(pcie->sysctl + MT7621_CHIP_REV_ID);
+	u32 chip_rev_id = rt_sysc_r32(MT7621_CHIP_REV_ID);
 
 	if ((chip_rev_id & 0xFFFF) == CHIP_REV_MT7621_E2)
 		bypass_pipe_rst(port);
@@ -548,16 +545,6 @@ static int mt7621_pcie_parse_dt(struct mt7621_pcie *pcie)
 	if (IS_ERR(pcie->base))
 		return PTR_ERR(pcie->base);
 
-	err = of_address_to_resource(node, 4, &regs);
-	if (err) {
-		dev_err(dev, "missing \"reg\" property\n");
-		return err;
-	}
-
-	pcie->sysctl = devm_ioremap_resource(dev, &regs);
-	if (IS_ERR(pcie->sysctl))
-		return PTR_ERR(pcie->sysctl);
-
 	for_each_available_child_of_node(node, child) {
 		int slot;
 

commit 98afdd565f3cf0dfa2bd62e801bbfb7ee1698f6d
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Sun Nov 4 11:49:59 2018 +0100

    staging: mt7621-pci: replace 'mdelay()' with 'msleep()'
    
    Function 'mt7621_pcie_init_ports' is never called in atomic context.
    It calls mdelay() to busily wait, which is not necessary. mdelay()
    can be replaced with msleep().
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/mt7621-pci/pci-mt7621.c b/drivers/staging/mt7621-pci/pci-mt7621.c
index fb9aa6bbd5dc..14cec231946c 100644
--- a/drivers/staging/mt7621-pci/pci-mt7621.c
+++ b/drivers/staging/mt7621-pci/pci-mt7621.c
@@ -632,7 +632,7 @@ static void mt7621_pcie_init_ports(struct mt7621_pcie *pcie)
 	rt_sysc_m32(PCIE_CLK_GEN_EN, PCIE_CLK_GEN_DIS, RALINK_PCIE_CLK_GEN);
 	rt_sysc_m32(PCIE_CLK_GEN1_DIS, PCIE_CLK_GEN1_EN, RALINK_PCIE_CLK_GEN1);
 	rt_sysc_m32(PCIE_CLK_GEN_DIS, PCIE_CLK_GEN_EN, RALINK_PCIE_CLK_GEN);
-	mdelay(50);
+	msleep(50);
 	rt_sysc_m32(RALINK_PCIE_RST, 0, RALINK_RSTCTRL);
 }
 

commit b8d97d43bf7a4c1746ecdfa674c3e6ef5c73c11e
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Sun Nov 4 11:49:58 2018 +0100

    staging: mt7621-pci: move some code into 'mt7621_pcie_init_ports'
    
    Some clocks bits related code is in driver probe function and can
    perfectly be moved into 'mt7621_pcie_init_ports' function which is
    a more accurate place for it.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/mt7621-pci/pci-mt7621.c b/drivers/staging/mt7621-pci/pci-mt7621.c
index a069d7f5d8d9..fb9aa6bbd5dc 100644
--- a/drivers/staging/mt7621-pci/pci-mt7621.c
+++ b/drivers/staging/mt7621-pci/pci-mt7621.c
@@ -626,6 +626,14 @@ static void mt7621_pcie_init_ports(struct mt7621_pcie *pcie)
 			list_del(&port->list);
 		}
 	}
+
+	rt_sysc_m32(0, RALINK_PCIE_RST, RALINK_RSTCTRL);
+	rt_sysc_m32(0x30, 2 << 4, SYSC_REG_SYSTEM_CONFIG1);
+	rt_sysc_m32(PCIE_CLK_GEN_EN, PCIE_CLK_GEN_DIS, RALINK_PCIE_CLK_GEN);
+	rt_sysc_m32(PCIE_CLK_GEN1_DIS, PCIE_CLK_GEN1_EN, RALINK_PCIE_CLK_GEN1);
+	rt_sysc_m32(PCIE_CLK_GEN_DIS, PCIE_CLK_GEN_EN, RALINK_PCIE_CLK_GEN);
+	mdelay(50);
+	rt_sysc_m32(RALINK_PCIE_RST, 0, RALINK_RSTCTRL);
 }
 
 static int mt7621_pcie_enable_port(struct mt7621_pcie_port *port)
@@ -833,16 +841,6 @@ static int mt7621_pci_probe(struct platform_device *pdev)
 
 	mt7621_pcie_init_ports(pcie);
 
-	rt_sysc_m32(0, RALINK_PCIE_RST, RALINK_RSTCTRL);
-	rt_sysc_m32(0x30, 2 << 4, SYSC_REG_SYSTEM_CONFIG1);
-
-	rt_sysc_m32(PCIE_CLK_GEN_EN, PCIE_CLK_GEN_DIS, RALINK_PCIE_CLK_GEN);
-	rt_sysc_m32(PCIE_CLK_GEN1_DIS, PCIE_CLK_GEN1_EN, RALINK_PCIE_CLK_GEN1);
-	rt_sysc_m32(PCIE_CLK_GEN_DIS, PCIE_CLK_GEN_EN, RALINK_PCIE_CLK_GEN);
-
-	mdelay(50);
-	rt_sysc_m32(RALINK_PCIE_RST, 0, RALINK_RSTCTRL);
-
 	err = mt7621_pcie_init_virtual_bridges(pcie);
 	if (err) {
 		dev_err(dev, "Nothing is connected in virtual bridges. Exiting...");

commit 802a2f7b2fe36b06681f80a54a3eba167a8e500e
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Sun Nov 4 11:49:57 2018 +0100

    staging: mt7621-pci: factor out 'mt7621_pcie_enable_port' function
    
    Function 'mt7621_pcie_enable_ports' tries to enable all PCI ports.
    To make it more readable the single port initialization part has
    been factor out into a new 'mt7621_pcie_enable_port' function.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/mt7621-pci/pci-mt7621.c b/drivers/staging/mt7621-pci/pci-mt7621.c
index 5f7ff70e289f..a069d7f5d8d9 100644
--- a/drivers/staging/mt7621-pci/pci-mt7621.c
+++ b/drivers/staging/mt7621-pci/pci-mt7621.c
@@ -628,54 +628,64 @@ static void mt7621_pcie_init_ports(struct mt7621_pcie *pcie)
 	}
 }
 
+static int mt7621_pcie_enable_port(struct mt7621_pcie_port *port)
+{
+	struct mt7621_pcie *pcie = port->pcie;
+	u32 slot = port->slot;
+	u32 offset = MT7621_PCIE_OFFSET + (slot * MT7621_NEXT_PORT);
+	u32 val;
+	int err;
+
+	/* assert port PERST_N */
+	val = pcie_read(pcie, RALINK_PCI_PCICFG_ADDR);
+	val |= PCIE_PORT_PERST(slot);
+	pcie_write(pcie, val, RALINK_PCI_PCICFG_ADDR);
+
+	/* de-assert port PERST_N */
+	val = pcie_read(pcie, RALINK_PCI_PCICFG_ADDR);
+	val &= ~PCIE_PORT_PERST(slot);
+	pcie_write(pcie, val, RALINK_PCI_PCICFG_ADDR);
+
+	/* 100ms timeout value should be enough for Gen1 training */
+	err = readl_poll_timeout(port->base + RALINK_PCI_STATUS,
+				 val, !!(val & PCIE_PORT_LINKUP),
+				 20, 100 * USEC_PER_MSEC);
+	if (err)
+		return -ETIMEDOUT;
+
+	/* enable pcie interrupt */
+	val = pcie_read(pcie, RALINK_PCI_PCIMSK_ADDR);
+	val |= PCIE_PORT_INT_EN(slot);
+	pcie_write(pcie, val, RALINK_PCI_PCIMSK_ADDR);
+
+	/* map 2G DDR region */
+	pcie_write(pcie, PCIE_BAR_MAP_MAX | PCIE_BAR_ENABLE,
+		   offset + RALINK_PCI_BAR0SETUP_ADDR);
+	pcie_write(pcie, MEMORY_BASE,
+		   offset + RALINK_PCI_IMBASEBAR0_ADDR);
+
+	/* configure class code and revision ID */
+	pcie_write(pcie, PCIE_CLASS_CODE | PCIE_REVISION_ID,
+		   offset + RALINK_PCI_CLASS);
+
+	return 0;
+}
+
 static void mt7621_pcie_enable_ports(struct mt7621_pcie *pcie)
 {
 	struct device *dev = pcie->dev;
 	struct mt7621_pcie_port *port;
 	u8 num_slots_enabled = 0;
-	u32 offset;
 	u32 slot;
 	u32 val;
-	int err;
 
 	list_for_each_entry(port, &pcie->ports, list) {
-		slot = port->slot;
-		offset = MT7621_PCIE_OFFSET + (slot * MT7621_NEXT_PORT);
-
 		if (port->enabled) {
-			/* assert port PERST_N */
-			val = pcie_read(pcie, RALINK_PCI_PCICFG_ADDR);
-			val |= PCIE_PORT_PERST(slot);
-			pcie_write(pcie, val, RALINK_PCI_PCICFG_ADDR);
-
-			/* de-assert port PERST_N */
-			val = pcie_read(pcie, RALINK_PCI_PCICFG_ADDR);
-			val &= ~PCIE_PORT_PERST(slot);
-			pcie_write(pcie, val, RALINK_PCI_PCICFG_ADDR);
-
-			/* 100ms timeout value should be enough for Gen1 training */
-			err = readl_poll_timeout(port->base + RALINK_PCI_STATUS,
-						 val,!!(val & PCIE_PORT_LINKUP),
-						 20, 100 * USEC_PER_MSEC);
-			if (err) {
+			if (!mt7621_pcie_enable_port(port)) {
 				dev_err(dev, "de-assert port %d PERST_N\n",
-					slot);
+					port->slot);
 				continue;
 			}
-
-			/* enable pcie interrupt */
-			val = pcie_read(pcie, RALINK_PCI_PCIMSK_ADDR);
-			val |= PCIE_PORT_INT_EN(slot);
-			pcie_write(pcie, val, RALINK_PCI_PCIMSK_ADDR);
-
-			/* map 2G DDR region */
-			pcie_write(pcie, PCIE_BAR_MAP_MAX | PCIE_BAR_ENABLE,
-				   offset + RALINK_PCI_BAR0SETUP_ADDR);
-			pcie_write(pcie, MEMORY_BASE,
-				   offset + RALINK_PCI_IMBASEBAR0_ADDR);
-			/* configure class code and revision ID */
-			pcie_write(pcie, PCIE_CLASS_CODE | PCIE_REVISION_ID,
-				   offset + RALINK_PCI_CLASS);
 			dev_info(dev, "PCIE%d enabled\n", slot);
 			num_slots_enabled++;
 		}

commit 1e80699fd6a5e3f6940aa1209c30ca1b02f57819
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Sun Nov 4 11:49:56 2018 +0100

    staging: mt7621-pci: enable interrupt when port is being enabled
    
    Interrupt is being enabled in port initialization when the port phy
    has not been initialized yet. Just enable the interrupt when the port
    is being enabled which is a more accurate place for this.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/mt7621-pci/pci-mt7621.c b/drivers/staging/mt7621-pci/pci-mt7621.c
index 8b7c63d7e353..5f7ff70e289f 100644
--- a/drivers/staging/mt7621-pci/pci-mt7621.c
+++ b/drivers/staging/mt7621-pci/pci-mt7621.c
@@ -601,10 +601,6 @@ static int mt7621_pcie_init_port(struct mt7621_pcie_port *port)
 		port->enabled = false;
 	} else {
 		port->enabled = true;
-		/* enable pcie interrupt */
-		val = pcie_read(pcie, RALINK_PCI_PCIMSK_ADDR);
-		val |= PCIE_PORT_INT_EN(slot);
-		pcie_write(pcie, val, RALINK_PCI_PCIMSK_ADDR);
 	}
 
 	mt7621_enable_phy(port);
@@ -667,6 +663,11 @@ static void mt7621_pcie_enable_ports(struct mt7621_pcie *pcie)
 				continue;
 			}
 
+			/* enable pcie interrupt */
+			val = pcie_read(pcie, RALINK_PCI_PCIMSK_ADDR);
+			val |= PCIE_PORT_INT_EN(slot);
+			pcie_write(pcie, val, RALINK_PCI_PCIMSK_ADDR);
+
 			/* map 2G DDR region */
 			pcie_write(pcie, PCIE_BAR_MAP_MAX | PCIE_BAR_ENABLE,
 				   offset + RALINK_PCI_BAR0SETUP_ADDR);

commit bcb4530736a6f7215ab9306f669a8688adf7448c
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Sun Nov 4 11:49:55 2018 +0100

    staging: mt7621-pci: use PCIE_PORT_LINKUP instead of hardcode value
    
    PCIE_PORT_LINKUP is defined and can be used to check if link is up
    for each controller. Use it instead of use a hardcode value.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/mt7621-pci/pci-mt7621.c b/drivers/staging/mt7621-pci/pci-mt7621.c
index 7fa37b67808a..8b7c63d7e353 100644
--- a/drivers/staging/mt7621-pci/pci-mt7621.c
+++ b/drivers/staging/mt7621-pci/pci-mt7621.c
@@ -594,7 +594,7 @@ static int mt7621_pcie_init_port(struct mt7621_pcie_port *port)
 	reset_control_assert(port->pcie_rst);
 	reset_control_deassert(port->pcie_rst);
 
-	if ((pcie_port_read(port, RALINK_PCI_STATUS) & 0x1) == 0) {
+	if ((pcie_port_read(port, RALINK_PCI_STATUS) & PCIE_PORT_LINKUP) == 0) {
 		dev_err(dev, "pcie%d no card, disable it (RST & CLK)\n", slot);
 		reset_control_assert(port->pcie_rst);
 		rt_sysc_m32(PCIE_PORT_CLK_EN(slot), 0, RALINK_CLKCFG1);

commit bd1a05bd87ad8b66c9bad4614514a1551015074e
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Sun Nov 4 11:49:54 2018 +0100

    staging: mt7621-pci: use PERST_N instead of gpio control
    
    Driver is using gpio control instead of each port PERST_N
    bit. Use PERST_N bit of each port cleaning all the ugly
    gpio code in driver probe function.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/mt7621-pci/pci-mt7621.c b/drivers/staging/mt7621-pci/pci-mt7621.c
index 0c78cc2c0440..7fa37b67808a 100644
--- a/drivers/staging/mt7621-pci/pci-mt7621.c
+++ b/drivers/staging/mt7621-pci/pci-mt7621.c
@@ -18,6 +18,7 @@
 #include <linux/bitops.h>
 #include <linux/clk.h>
 #include <linux/delay.h>
+#include <linux/iopoll.h>
 #include <linux/module.h>
 #include <linux/of.h>
 #include <linux/of_address.h>
@@ -36,7 +37,6 @@
 #define MT7621_CHIP_REV_ID		0x0c
 #define RALINK_CLKCFG1			0x30
 #define RALINK_RSTCTRL			0x34
-#define MT7621_GPIO_MODE		0x60
 #define CHIP_REV_MT7621_E2		0x0101
 
 /* RALINK_RSTCTRL bits */
@@ -86,6 +86,8 @@
 #define PCIE_BAR_ENABLE			BIT(0)
 #define PCIE_PORT_INT_EN(x)		BIT(20 + (x))
 #define PCIE_PORT_CLK_EN(x)		BIT(24 + (x))
+#define PCIE_PORT_PERST(x)		BIT(1 + (x))
+#define PCIE_PORT_LINKUP		BIT(0)
 
 #define PCIE_CLK_GEN_EN			BIT(31)
 #define PCIE_CLK_GEN_DIS		0
@@ -638,12 +640,33 @@ static void mt7621_pcie_enable_ports(struct mt7621_pcie *pcie)
 	u32 offset;
 	u32 slot;
 	u32 val;
+	int err;
 
 	list_for_each_entry(port, &pcie->ports, list) {
 		slot = port->slot;
 		offset = MT7621_PCIE_OFFSET + (slot * MT7621_NEXT_PORT);
 
 		if (port->enabled) {
+			/* assert port PERST_N */
+			val = pcie_read(pcie, RALINK_PCI_PCICFG_ADDR);
+			val |= PCIE_PORT_PERST(slot);
+			pcie_write(pcie, val, RALINK_PCI_PCICFG_ADDR);
+
+			/* de-assert port PERST_N */
+			val = pcie_read(pcie, RALINK_PCI_PCICFG_ADDR);
+			val &= ~PCIE_PORT_PERST(slot);
+			pcie_write(pcie, val, RALINK_PCI_PCICFG_ADDR);
+
+			/* 100ms timeout value should be enough for Gen1 training */
+			err = readl_poll_timeout(port->base + RALINK_PCI_STATUS,
+						 val,!!(val & PCIE_PORT_LINKUP),
+						 20, 100 * USEC_PER_MSEC);
+			if (err) {
+				dev_err(dev, "de-assert port %d PERST_N\n",
+					slot);
+				continue;
+			}
+
 			/* map 2G DDR region */
 			pcie_write(pcie, PCIE_BAR_MAP_MAX | PCIE_BAR_ENABLE,
 				   offset + RALINK_PCI_BAR0SETUP_ADDR);
@@ -765,16 +788,6 @@ static int mt7621_pcie_register_host(struct pci_host_bridge *host,
 	return pci_host_probe(host);
 }
 
-static void mt7621_set_gpio_mode(struct mt7621_pcie *pcie)
-{
-	u32 reg = ioread32(pcie->sysctl + MT7621_GPIO_MODE);
-
-	reg &= ~(0x3 << 10 | 0x3 << 3);
-	reg |= (BIT(10) | BIT(3));
-	iowrite32(reg, pcie->sysctl + MT7621_GPIO_MODE);
-	mdelay(100);
-}
-
 static int mt7621_pci_probe(struct platform_device *pdev)
 {
 	struct device *dev = &pdev->dev;
@@ -807,13 +820,6 @@ static int mt7621_pci_probe(struct platform_device *pdev)
 	ioport_resource.start = 0;
 	ioport_resource.end = ~0UL; /* no limit */
 
-	mt7621_set_gpio_mode(pcie);
-	*(unsigned int *)(0xbe000600) |= BIT(19) | BIT(8) | BIT(7); // use GPIO19/GPIO8/GPIO7 (PERST_N/UART_RXD3/UART_TXD3)
-	mdelay(100);
-	*(unsigned int *)(0xbe000620) &= ~(BIT(19) | BIT(8) | BIT(7));		// clear DATA
-
-	mdelay(100);
-
 	mt7621_pcie_init_ports(pcie);
 
 	rt_sysc_m32(0, RALINK_PCIE_RST, RALINK_RSTCTRL);
@@ -826,10 +832,6 @@ static int mt7621_pci_probe(struct platform_device *pdev)
 	mdelay(50);
 	rt_sysc_m32(RALINK_PCIE_RST, 0, RALINK_RSTCTRL);
 
-	/* Use GPIO control instead of PERST_N */
-	*(unsigned int *)(0xbe000620) |= BIT(19) | BIT(8) | BIT(7);		// set DATA
-	mdelay(1000);
-
 	err = mt7621_pcie_init_virtual_bridges(pcie);
 	if (err) {
 		dev_err(dev, "Nothing is connected in virtual bridges. Exiting...");

commit fb672b450ccced9032c58c111c6aaf6aa39ab544
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Sun Nov 4 11:49:53 2018 +0100

    staging: mt7621-pci: add some definitions for enabling and disabling GEN and GEN1 clocks
    
    Instead of use hardcoded values when calling 'rt_sysc_m32' for enabling
    and disabling RALINK_PCIE_CLK_GEN and RALINK_PCIE_CLK_GEN1 create
    some preprocessor definitions.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/mt7621-pci/pci-mt7621.c b/drivers/staging/mt7621-pci/pci-mt7621.c
index 0e898a4b7b63..0c78cc2c0440 100644
--- a/drivers/staging/mt7621-pci/pci-mt7621.c
+++ b/drivers/staging/mt7621-pci/pci-mt7621.c
@@ -87,6 +87,10 @@
 #define PCIE_PORT_INT_EN(x)		BIT(20 + (x))
 #define PCIE_PORT_CLK_EN(x)		BIT(24 + (x))
 
+#define PCIE_CLK_GEN_EN			BIT(31)
+#define PCIE_CLK_GEN_DIS		0
+#define PCIE_CLK_GEN1_DIS		GENMASK(30,24)
+#define PCIE_CLK_GEN1_EN		(BIT(27) | BIT(25))
 #define RALINK_PCI_IO_MAP_BASE		0x1e160000
 #define MEMORY_BASE			0x0
 
@@ -815,9 +819,9 @@ static int mt7621_pci_probe(struct platform_device *pdev)
 	rt_sysc_m32(0, RALINK_PCIE_RST, RALINK_RSTCTRL);
 	rt_sysc_m32(0x30, 2 << 4, SYSC_REG_SYSTEM_CONFIG1);
 
-	rt_sysc_m32(0x80000000, 0, RALINK_PCIE_CLK_GEN);
-	rt_sysc_m32(0x7f000000, 0xa << 24, RALINK_PCIE_CLK_GEN1);
-	rt_sysc_m32(0, 0x80000000, RALINK_PCIE_CLK_GEN);
+	rt_sysc_m32(PCIE_CLK_GEN_EN, PCIE_CLK_GEN_DIS, RALINK_PCIE_CLK_GEN);
+	rt_sysc_m32(PCIE_CLK_GEN1_DIS, PCIE_CLK_GEN1_EN, RALINK_PCIE_CLK_GEN1);
+	rt_sysc_m32(PCIE_CLK_GEN_DIS, PCIE_CLK_GEN_EN, RALINK_PCIE_CLK_GEN);
 
 	mdelay(50);
 	rt_sysc_m32(RALINK_PCIE_RST, 0, RALINK_RSTCTRL);

commit 301c15be69afa98b188545d83422245c01f69743
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Sun Nov 4 11:49:52 2018 +0100

    staging: mt7621-pci: rewrite hardcoded code for enabling ports
    
    There are some hardcoded values in the process for enabling and
    disabling some stuff inside 'mt7621_pcie_enable_ports' function.
    Create some preprocessor definitions to make code more readable.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/mt7621-pci/pci-mt7621.c b/drivers/staging/mt7621-pci/pci-mt7621.c
index 604b2871a336..0e898a4b7b63 100644
--- a/drivers/staging/mt7621-pci/pci-mt7621.c
+++ b/drivers/staging/mt7621-pci/pci-mt7621.c
@@ -80,6 +80,13 @@
 #define RALINK_PCI_STATUS		0x0050
 
 /* Some definition values */
+#define PCIE_REVISION_ID		BIT(0)
+#define PCIE_CLASS_CODE			(0x60400 << 8)
+#define PCIE_BAR_MAP_MAX		GENMASK(30, 16)
+#define PCIE_BAR_ENABLE			BIT(0)
+#define PCIE_PORT_INT_EN(x)		BIT(20 + (x))
+#define PCIE_PORT_CLK_EN(x)		BIT(24 + (x))
+
 #define RALINK_PCI_IO_MAP_BASE		0x1e160000
 #define MEMORY_BASE			0x0
 
@@ -584,13 +591,13 @@ static int mt7621_pcie_init_port(struct mt7621_pcie_port *port)
 	if ((pcie_port_read(port, RALINK_PCI_STATUS) & 0x1) == 0) {
 		dev_err(dev, "pcie%d no card, disable it (RST & CLK)\n", slot);
 		reset_control_assert(port->pcie_rst);
-		rt_sysc_m32(BIT(24 + slot), 0, RALINK_CLKCFG1);
+		rt_sysc_m32(PCIE_PORT_CLK_EN(slot), 0, RALINK_CLKCFG1);
 		port->enabled = false;
 	} else {
 		port->enabled = true;
-		val = pcie_read(pcie, RALINK_PCI_PCIMSK_ADDR);
 		/* enable pcie interrupt */
-		val |= BIT(20 + slot);
+		val = pcie_read(pcie, RALINK_PCI_PCIMSK_ADDR);
+		val |= PCIE_PORT_INT_EN(slot);
 		pcie_write(pcie, val, RALINK_PCI_PCIMSK_ADDR);
 	}
 
@@ -633,12 +640,14 @@ static void mt7621_pcie_enable_ports(struct mt7621_pcie *pcie)
 		offset = MT7621_PCIE_OFFSET + (slot * MT7621_NEXT_PORT);
 
 		if (port->enabled) {
-			/* open 7FFF:2G; ENABLE */
-			pcie_write(pcie, 0x7FFF0001,
+			/* map 2G DDR region */
+			pcie_write(pcie, PCIE_BAR_MAP_MAX | PCIE_BAR_ENABLE,
 				   offset + RALINK_PCI_BAR0SETUP_ADDR);
 			pcie_write(pcie, MEMORY_BASE,
 				   offset + RALINK_PCI_IMBASEBAR0_ADDR);
-			pcie_write(pcie, 0x06040001, offset + RALINK_PCI_CLASS);
+			/* configure class code and revision ID */
+			pcie_write(pcie, PCIE_CLASS_CODE | PCIE_REVISION_ID,
+				   offset + RALINK_PCI_CLASS);
 			dev_info(dev, "PCIE%d enabled\n", slot);
 			num_slots_enabled++;
 		}

commit a4b2eb912bb13c3c55d2389ee7e954468d0df052
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Sun Nov 4 11:49:51 2018 +0100

    staging: mt7621-pci: rewrite RC FTS configuration
    
    The RC FTS configuration is done using hardcoded registers
    and bitshift operations. Make it a bit clean defining some
    prepocessor definitions and simple macros.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/mt7621-pci/pci-mt7621.c b/drivers/staging/mt7621-pci/pci-mt7621.c
index cca9a8245a30..604b2871a336 100644
--- a/drivers/staging/mt7621-pci/pci-mt7621.c
+++ b/drivers/staging/mt7621-pci/pci-mt7621.c
@@ -42,6 +42,11 @@
 /* RALINK_RSTCTRL bits */
 #define RALINK_PCIE_RST			BIT(23)
 
+/* MediaTek specific configuration registers */
+#define PCIE_FTS_NUM			0x70c
+#define PCIE_FTS_NUM_MASK		GENMASK(15, 8)
+#define PCIE_FTS_NUM_L0(x)		((x) & 0xff << 8)
+
 /* rt_sysc_membase relative registers */
 #define RALINK_PCIE_CLK_GEN		0x7c
 #define RALINK_PCIE_CLK_GEN1		0x80
@@ -591,7 +596,7 @@ static int mt7621_pcie_init_port(struct mt7621_pcie_port *port)
 
 	mt7621_enable_phy(port);
 
-	val = read_config(pcie, slot, 0x70c);
+	val = read_config(pcie, slot, PCIE_FTS_NUM);
 	dev_info(dev, "Port %d N_FTS = %x\n", (unsigned int)val, slot);
 
 	return 0;
@@ -642,10 +647,11 @@ static void mt7621_pcie_enable_ports(struct mt7621_pcie *pcie)
 	for (slot = 0; slot < num_slots_enabled; slot++) {
 		val = read_config(pcie, slot, 0x4);
 		write_config(pcie, slot, 0x4, val | 0x4);
-		val = read_config(pcie, slot, 0x70c);
-		val &= ~(0xff) << 8;
-		val |= 0x50 << 8;
-		write_config(pcie, slot, 0x70c, val);
+		/* configure RC FTS number to 250 when it leaves L0s */
+		val = read_config(pcie, slot, PCIE_FTS_NUM);
+		val &= ~PCIE_FTS_NUM_MASK;
+		val |= PCIE_FTS_NUM_L0(0x50);
+		write_config(pcie, slot, PCIE_FTS_NUM, val);
 	}
 }
 

commit ce3368dc942bdd518d599f1a452e03f81d3e9b30
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Sun Nov 4 11:49:50 2018 +0100

    staging: mt7621-pci: align function definition style along the code
    
    Make some function definition changes in order to get all the
    functions in the code with the same style.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/mt7621-pci/pci-mt7621.c b/drivers/staging/mt7621-pci/pci-mt7621.c
index 5d151298e631..cca9a8245a30 100644
--- a/drivers/staging/mt7621-pci/pci-mt7621.c
+++ b/drivers/staging/mt7621-pci/pci-mt7621.c
@@ -235,8 +235,7 @@ struct pci_ops mt7621_pci_ops = {
 	.write		= pci_generic_config_write,
 };
 
-static u32
-read_config(struct mt7621_pcie *pcie, unsigned int dev, u32 reg)
+static u32 read_config(struct mt7621_pcie *pcie, unsigned int dev, u32 reg)
 {
 	u32 address = mt7621_pci_get_cfgaddr(0, dev, 0, reg);
 
@@ -244,8 +243,8 @@ read_config(struct mt7621_pcie *pcie, unsigned int dev, u32 reg)
 	return pcie_read(pcie, RALINK_PCI_CONFIG_DATA);
 }
 
-static void
-write_config(struct mt7621_pcie *pcie, unsigned int dev, u32 reg, u32 val)
+static void write_config(struct mt7621_pcie *pcie, unsigned int dev,
+			 u32 reg, u32 val)
 {
 	u32 address = mt7621_pci_get_cfgaddr(0, dev, 0, reg);
 
@@ -253,8 +252,7 @@ write_config(struct mt7621_pcie *pcie, unsigned int dev, u32 reg, u32 val)
 	pcie_write(pcie, val, RALINK_PCI_CONFIG_DATA);
 }
 
-static void
-bypass_pipe_rst(struct mt7621_pcie_port *port)
+static void bypass_pipe_rst(struct mt7621_pcie_port *port)
 {
 	struct mt7621_pcie *pcie = port->pcie;
 	u32 phy_offset = port->phy_reg_offset;
@@ -268,8 +266,7 @@ bypass_pipe_rst(struct mt7621_pcie_port *port)
 	pcie_write(pcie, reg, offset);
 }
 
-static void
-set_phy_for_ssc(struct mt7621_pcie_port *port)
+static void set_phy_for_ssc(struct mt7621_pcie_port *port)
 {
 	struct mt7621_pcie *pcie = port->pcie;
 	struct device *dev = pcie->dev;

commit b842e0b972ab089518dc14f69f85c9a8575101c2
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Sun Nov 4 11:49:49 2018 +0100

    staging: mt7621-pci: remove non sense comment
    
    There is a comment at the beggining which has no sense at all.
    Remove it.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/mt7621-pci/pci-mt7621.c b/drivers/staging/mt7621-pci/pci-mt7621.c
index 1f764ad2247f..5d151298e631 100644
--- a/drivers/staging/mt7621-pci/pci-mt7621.c
+++ b/drivers/staging/mt7621-pci/pci-mt7621.c
@@ -32,11 +32,6 @@
 
 #include "../../pci/pci.h"
 
-/*
- * These functions and structures provide the BIOS scan and mapping of the PCI
- * devices.
- */
-
 /* sysctl */
 #define MT7621_CHIP_REV_ID		0x0c
 #define RALINK_CLKCFG1			0x30

commit a934d9017520cf418e9471a83cc53b55fc30b010
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Sun Nov 4 11:49:48 2018 +0100

    staging: mt7621-pci: reorder preprocessor definitions
    
    Reorder a bit register definitions and some values into
    logical groups adding some comments for each group. Also
    unify all of register to use 16 bit in definitions instead
    of having some with 16 bits and some with 8 bits.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/mt7621-pci/pci-mt7621.c b/drivers/staging/mt7621-pci/pci-mt7621.c
index 36436b1f5272..1f764ad2247f 100644
--- a/drivers/staging/mt7621-pci/pci-mt7621.c
+++ b/drivers/staging/mt7621-pci/pci-mt7621.c
@@ -39,24 +39,27 @@
 
 /* sysctl */
 #define MT7621_CHIP_REV_ID		0x0c
+#define RALINK_CLKCFG1			0x30
+#define RALINK_RSTCTRL			0x34
 #define MT7621_GPIO_MODE		0x60
 #define CHIP_REV_MT7621_E2		0x0101
 
-/* pcie */
-#define RALINK_PCI_CONFIG_ADDR		0x20
-#define RALINK_PCI_CONFIG_DATA		0x24
-#define RALINK_PCI_MEMBASE		0x28
-#define RALINK_PCI_IOBASE		0x2C
-
 /* RALINK_RSTCTRL bits */
 #define RALINK_PCIE_RST			BIT(23)
 
+/* rt_sysc_membase relative registers */
+#define RALINK_PCIE_CLK_GEN		0x7c
+#define RALINK_PCIE_CLK_GEN1		0x80
+
+/* Host-PCI bridge registers */
 #define RALINK_PCI_PCICFG_ADDR		0x0000
 #define RALINK_PCI_PCIMSK_ADDR		0x000C
+#define RALINK_PCI_CONFIG_ADDR		0x0020
+#define RALINK_PCI_CONFIG_DATA		0x0024
+#define RALINK_PCI_MEMBASE		0x0028
+#define RALINK_PCI_IOBASE		0x002C
 
-#define MT7621_PCIE_OFFSET		0x2000
-#define MT7621_NEXT_PORT		0x1000
-
+/* PCICFG virtual bridges */
 #define MT7621_BR0_MASK			GENMASK(19, 16)
 #define MT7621_BR1_MASK			GENMASK(23, 20)
 #define MT7621_BR2_MASK			GENMASK(27, 24)
@@ -65,6 +68,10 @@
 #define MT7621_BR1_SHIFT		20
 #define MT7621_BR2_SHIFT		24
 
+/* PCIe RC control registers */
+#define MT7621_PCIE_OFFSET		0x2000
+#define MT7621_NEXT_PORT		0x1000
+
 #define RALINK_PCI_BAR0SETUP_ADDR	0x0010
 #define RALINK_PCI_IMBASEBAR0_ADDR	0x0018
 #define RALINK_PCI_ID			0x0030
@@ -72,14 +79,9 @@
 #define RALINK_PCI_SUBID		0x0038
 #define RALINK_PCI_STATUS		0x0050
 
+/* Some definition values */
 #define RALINK_PCI_IO_MAP_BASE		0x1e160000
-
-#define RALINK_CLKCFG1			0x30
-#define RALINK_RSTCTRL			0x34
-#define RALINK_PCIE_CLK_GEN		0x7c
-#define RALINK_PCIE_CLK_GEN1		0x80
-
-#define MEMORY_BASE 0x0
+#define MEMORY_BASE			0x0
 
 /* pcie phy related macros */
 #define RALINK_PCIEPHY_P0P1_CTL_OFFSET	0x9000

commit 58180d33ee08b3b25255fed48cfc961ef9638bbb
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Sun Nov 4 11:49:47 2018 +0100

    staging: mt7621-pci: remove unused preprocessor definitions
    
    There are some preprocessor definition which are not being used at
    all. Remove them cleaning the code a bit.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/mt7621-pci/pci-mt7621.c b/drivers/staging/mt7621-pci/pci-mt7621.c
index cb677cd21792..36436b1f5272 100644
--- a/drivers/staging/mt7621-pci/pci-mt7621.c
+++ b/drivers/staging/mt7621-pci/pci-mt7621.c
@@ -43,10 +43,6 @@
 #define CHIP_REV_MT7621_E2		0x0101
 
 /* pcie */
-#define RALINK_PCIE0_CLK_EN		BIT(24)
-#define RALINK_PCIE1_CLK_EN		BIT(25)
-#define RALINK_PCIE2_CLK_EN		BIT(26)
-
 #define RALINK_PCI_CONFIG_ADDR		0x20
 #define RALINK_PCI_CONFIG_DATA		0x24
 #define RALINK_PCI_MEMBASE		0x28
@@ -54,9 +50,6 @@
 
 /* RALINK_RSTCTRL bits */
 #define RALINK_PCIE_RST			BIT(23)
-#define RALINK_PCIE0_RST		BIT(24)
-#define RALINK_PCIE1_RST		BIT(25)
-#define RALINK_PCIE2_RST		BIT(26)
 
 #define RALINK_PCI_PCICFG_ADDR		0x0000
 #define RALINK_PCI_PCIMSK_ADDR		0x000C
@@ -79,12 +72,10 @@
 #define RALINK_PCI_SUBID		0x0038
 #define RALINK_PCI_STATUS		0x0050
 
-#define RALINK_PCI_MM_MAP_BASE		0x60000000
 #define RALINK_PCI_IO_MAP_BASE		0x1e160000
 
 #define RALINK_CLKCFG1			0x30
 #define RALINK_RSTCTRL			0x34
-#define RALINK_GPIOMODE			0x60
 #define RALINK_PCIE_CLK_GEN		0x7c
 #define RALINK_PCIE_CLK_GEN1		0x80
 

commit cd910f19ac021307948c1169dc577cbaf89db015
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Sun Nov 4 11:49:46 2018 +0100

    staging: mt7621-pci: factor out 'mt7621_pcie_init_ports' function
    
    Instead of just inline this code in the probe driver function factor
    out a new 'mt7621_pcie_init_ports' function to achieve this.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/mt7621-pci/pci-mt7621.c b/drivers/staging/mt7621-pci/pci-mt7621.c
index 50c439b4dbc0..cb677cd21792 100644
--- a/drivers/staging/mt7621-pci/pci-mt7621.c
+++ b/drivers/staging/mt7621-pci/pci-mt7621.c
@@ -612,6 +612,23 @@ static int mt7621_pcie_init_port(struct mt7621_pcie_port *port)
 	return 0;
 }
 
+static void mt7621_pcie_init_ports(struct mt7621_pcie *pcie)
+{
+	struct device *dev = pcie->dev;
+	struct mt7621_pcie_port *port, *tmp;
+	int err;
+
+	list_for_each_entry_safe(port, tmp, &pcie->ports, list) {
+		u32 slot = port->slot;
+
+		err = mt7621_pcie_init_port(port);
+		if (err) {
+			dev_err(dev, "Initiating port %d failed\n", slot);
+			list_del(&port->list);
+		}
+	}
+}
+
 static void mt7621_pcie_enable_ports(struct mt7621_pcie *pcie)
 {
 	struct device *dev = pcie->dev;
@@ -759,7 +776,6 @@ static int mt7621_pci_probe(struct platform_device *pdev)
 	struct device *dev = &pdev->dev;
 	struct mt7621_pcie *pcie;
 	struct pci_host_bridge *bridge;
-	struct mt7621_pcie_port *port, *tmp;
 	int err;
 	LIST_HEAD(res);
 
@@ -794,15 +810,7 @@ static int mt7621_pci_probe(struct platform_device *pdev)
 
 	mdelay(100);
 
-	list_for_each_entry_safe(port, tmp, &pcie->ports, list) {
-		u32 slot = port->slot;
-
-		err = mt7621_pcie_init_port(port);
-		if (err) {
-			dev_err(dev, "enabling port %d failed\n", slot);
-			list_del(&port->list);
-		}
-	}
+	mt7621_pcie_init_ports(pcie);
 
 	rt_sysc_m32(0, RALINK_PCIE_RST, RALINK_RSTCTRL);
 	rt_sysc_m32(0x30, 2 << 4, SYSC_REG_SYSTEM_CONFIG1);

commit e2200279af2f0e4132feaf5d609e3a82cc484acc
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Sun Nov 4 11:49:45 2018 +0100

    staging: mt7621-pci: avoid use of global variable 'pcie_link_status'
    
    'pcie_link_status' is a global variable which is being used as a
    mask to know which virtual bridges are or not enabled. Instead of
    this extract a new 'mt7621_pcie_init_virtual_bridges' function where
    a similar local variable is used for the same task. This allow us to
    properly configure the virtual PCI-PCI bridges in configuration
    registers of the mt7621 pci controller. For a correct initiation of
    which is connected use 'enabled' field of 'mt7621_pcie_port' struct.
    With this change driver probe function gets a bit cleaner and readable.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/mt7621-pci/pci-mt7621.c b/drivers/staging/mt7621-pci/pci-mt7621.c
index 5f07b53c651b..50c439b4dbc0 100644
--- a/drivers/staging/mt7621-pci/pci-mt7621.c
+++ b/drivers/staging/mt7621-pci/pci-mt7621.c
@@ -64,6 +64,14 @@
 #define MT7621_PCIE_OFFSET		0x2000
 #define MT7621_NEXT_PORT		0x1000
 
+#define MT7621_BR0_MASK			GENMASK(19, 16)
+#define MT7621_BR1_MASK			GENMASK(23, 20)
+#define MT7621_BR2_MASK			GENMASK(27, 24)
+#define MT7621_BR_ALL_MASK		GENMASK(27, 16)
+#define MT7621_BR0_SHIFT		16
+#define MT7621_BR1_SHIFT		20
+#define MT7621_BR2_SHIFT		24
+
 #define RALINK_PCI_BAR0SETUP_ADDR	0x0010
 #define RALINK_PCI_IMBASEBAR0_ADDR	0x0018
 #define RALINK_PCI_ID			0x0030
@@ -82,8 +90,6 @@
 
 #define MEMORY_BASE 0x0
 
-static int pcie_link_status;
-
 /* pcie phy related macros */
 #define RALINK_PCIEPHY_P0P1_CTL_OFFSET	0x9000
 #define RALINK_PCIEPHY_P2_CTL_OFFSET	0xA000
@@ -589,10 +595,8 @@ static int mt7621_pcie_init_port(struct mt7621_pcie_port *port)
 		dev_err(dev, "pcie%d no card, disable it (RST & CLK)\n", slot);
 		reset_control_assert(port->pcie_rst);
 		rt_sysc_m32(BIT(24 + slot), 0, RALINK_CLKCFG1);
-		pcie_link_status &= ~(1 << slot);
 		port->enabled = false;
 	} else {
-		pcie_link_status |= BIT(slot);
 		port->enabled = true;
 		val = pcie_read(pcie, RALINK_PCI_PCIMSK_ADDR);
 		/* enable pcie interrupt */
@@ -643,6 +647,70 @@ static void mt7621_pcie_enable_ports(struct mt7621_pcie *pcie)
 	}
 }
 
+static int mt7621_pcie_init_virtual_bridges(struct mt7621_pcie *pcie)
+{
+	u32 pcie_link_status = 0;
+	u32 val= 0;
+	struct mt7621_pcie_port *port;
+
+	list_for_each_entry(port, &pcie->ports, list) {
+		u32 slot = port->slot;
+
+		if (port->enabled)
+			pcie_link_status |= BIT(slot);
+	}
+
+	if (pcie_link_status == 0)
+		return -1;
+
+	/*
+	 * pcie(2/1/0) link status pcie2_num	pcie1_num	pcie0_num
+	 * 3'b000		   x	        x		x
+	 * 3'b001		   x	        x		0
+	 * 3'b010		   x	        0		x
+	 * 3'b011		   x	        1		0
+	 * 3'b100		   0	        x		x
+	 * 3'b101	           1 	        x		0
+	 * 3'b110	           1	        0		x
+	 * 3'b111		   2	        1		0
+	 */
+	switch (pcie_link_status) {
+	case 2:
+		val = pcie_read(pcie, RALINK_PCI_PCICFG_ADDR);
+		val &= ~(MT7621_BR0_MASK | MT7621_BR1_MASK);
+		val |= 0x1 << MT7621_BR0_SHIFT;
+		val |= 0x0 << MT7621_BR1_SHIFT;
+		pcie_write(pcie, val, RALINK_PCI_PCICFG_ADDR);
+		break;
+	case 4:
+		val = pcie_read(pcie, RALINK_PCI_PCICFG_ADDR);
+		val &= ~MT7621_BR_ALL_MASK;
+		val |= 0x1 << MT7621_BR0_SHIFT;
+		val |= 0x2 << MT7621_BR1_SHIFT;
+		val |= 0x0 << MT7621_BR2_SHIFT;
+		pcie_write(pcie, val, RALINK_PCI_PCICFG_ADDR);
+		break;
+	case 5:
+		val = pcie_read(pcie, RALINK_PCI_PCICFG_ADDR);
+		val &= ~MT7621_BR_ALL_MASK;
+		val |= 0x0 << MT7621_BR0_SHIFT;
+		val |= 0x2 << MT7621_BR1_SHIFT;
+		val |= 0x1 << MT7621_BR2_SHIFT;
+		pcie_write(pcie, val, RALINK_PCI_PCICFG_ADDR);
+		break;
+	case 6:
+		val = pcie_read(pcie, RALINK_PCI_PCICFG_ADDR);
+		val &= ~MT7621_BR_ALL_MASK;
+		val |= 0x2 << MT7621_BR0_SHIFT;
+		val |= 0x0 << MT7621_BR1_SHIFT;
+		val |= 0x1 << MT7621_BR2_SHIFT;
+		pcie_write(pcie, val, RALINK_PCI_PCICFG_ADDR);
+		break;
+	}
+
+	return 0;
+}
+
 static int mt7621_pcie_request_resources(struct mt7621_pcie *pcie,
 					 struct list_head *res)
 {
@@ -693,7 +761,6 @@ static int mt7621_pci_probe(struct platform_device *pdev)
 	struct pci_host_bridge *bridge;
 	struct mt7621_pcie_port *port, *tmp;
 	int err;
-	u32 val = 0;
 	LIST_HEAD(res);
 
 	if (!dev->of_node)
@@ -751,52 +818,10 @@ static int mt7621_pci_probe(struct platform_device *pdev)
 	*(unsigned int *)(0xbe000620) |= BIT(19) | BIT(8) | BIT(7);		// set DATA
 	mdelay(1000);
 
-	if (pcie_link_status == 0)
+	err = mt7621_pcie_init_virtual_bridges(pcie);
+	if (err) {
+		dev_err(dev, "Nothing is connected in virtual bridges. Exiting...");
 		return 0;
-
-/*
-pcie(2/1/0) link status	pcie2_num	pcie1_num	pcie0_num
-3'b000			x		x		x
-3'b001			x		x		0
-3'b010			x		0		x
-3'b011			x		1		0
-3'b100			0		x		x
-3'b101			1		x		0
-3'b110			1		0		x
-3'b111			2		1		0
-*/
-	switch (pcie_link_status) {
-	case 2:
-		val = pcie_read(pcie, RALINK_PCI_PCICFG_ADDR);
-		val &= ~0x00ff0000;
-		val |= 0x1 << 16;	// port 0
-		val |= 0x0 << 20;	// port 1
-		pcie_write(pcie, val, RALINK_PCI_PCICFG_ADDR);
-		break;
-	case 4:
-		val = pcie_read(pcie, RALINK_PCI_PCICFG_ADDR);
-		val &= ~0x0fff0000;
-		val |= 0x1 << 16;	//port0
-		val |= 0x2 << 20;	//port1
-		val |= 0x0 << 24;	//port2
-		pcie_write(pcie, val, RALINK_PCI_PCICFG_ADDR);
-		break;
-	case 5:
-		val = pcie_read(pcie, RALINK_PCI_PCICFG_ADDR);
-		val &= ~0x0fff0000;
-		val |= 0x0 << 16;	//port0
-		val |= 0x2 << 20;	//port1
-		val |= 0x1 << 24;	//port2
-		pcie_write(pcie, val, RALINK_PCI_PCICFG_ADDR);
-		break;
-	case 6:
-		val = pcie_read(pcie, RALINK_PCI_PCICFG_ADDR);
-		val &= ~0x0fff0000;
-		val |= 0x2 << 16;	//port0
-		val |= 0x0 << 20;	//port1
-		val |= 0x1 << 24;	//port2
-		pcie_write(pcie, val, RALINK_PCI_PCICFG_ADDR);
-		break;
 	}
 
 	pcie_write(pcie, 0xffffffff, RALINK_PCI_MEMBASE);

commit a41a1f86189b31feebcb676cff824b83921db81a
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Sun Nov 4 11:49:44 2018 +0100

    staging: mt7621-pci: factor out 'mt7621_pcie_enable_ports' function
    
    Driver probe function check for a bit in 'pcie_link_status' for
    enabling the pcie port or not. Instead of this add 'enabled' field
    in 'mt7621_pcie_port' structure and check its value to achieve this
    inside a new 'mt7621_pcie_enable_ports' function. The offsets for
    the correct port are derived from the slot of the port. This field
    'enabled' is properly initilized in 'mt7621_pcie_init_port'. Also
    depending of the number of ports enabled we have to properly init
    its registers taking into account that we will use virtual bridges
    from zero to num_slots_enabled as follows:
        - Only one enabled -> only enable virtual bridge 0.
        - Two enabled -> enable virtual bridges 0 and 1.
        - Three enabled -> enable virtual bridges 0, 1 and 2.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/mt7621-pci/pci-mt7621.c b/drivers/staging/mt7621-pci/pci-mt7621.c
index 6d261809fcdf..5f07b53c651b 100644
--- a/drivers/staging/mt7621-pci/pci-mt7621.c
+++ b/drivers/staging/mt7621-pci/pci-mt7621.c
@@ -61,9 +61,8 @@
 #define RALINK_PCI_PCICFG_ADDR		0x0000
 #define RALINK_PCI_PCIMSK_ADDR		0x000C
 
-#define RT6855_PCIE0_OFFSET		0x2000
-#define RT6855_PCIE1_OFFSET		0x3000
-#define RT6855_PCIE2_OFFSET		0x4000
+#define MT7621_PCIE_OFFSET		0x2000
+#define MT7621_NEXT_PORT		0x1000
 
 #define RALINK_PCI_BAR0SETUP_ADDR	0x0010
 #define RALINK_PCI_IMBASEBAR0_ADDR	0x0018
@@ -158,6 +157,7 @@ static int pcie_link_status;
  * @pcie_rst: pointer to port reset control
  * @pcie_clk: PCIe clock
  * @slot: port slot
+ * @enabled: indicates if port is enabled
  */
 struct mt7621_pcie_port {
 	void __iomem *base;
@@ -167,6 +167,7 @@ struct mt7621_pcie_port {
 	struct reset_control *pcie_rst;
 	struct clk *pcie_clk;
 	u32 slot;
+	bool enabled;
 };
 
 /**
@@ -589,8 +590,10 @@ static int mt7621_pcie_init_port(struct mt7621_pcie_port *port)
 		reset_control_assert(port->pcie_rst);
 		rt_sysc_m32(BIT(24 + slot), 0, RALINK_CLKCFG1);
 		pcie_link_status &= ~(1 << slot);
+		port->enabled = false;
 	} else {
 		pcie_link_status |= BIT(slot);
+		port->enabled = true;
 		val = pcie_read(pcie, RALINK_PCI_PCIMSK_ADDR);
 		/* enable pcie interrupt */
 		val |= BIT(20 + slot);
@@ -605,6 +608,41 @@ static int mt7621_pcie_init_port(struct mt7621_pcie_port *port)
 	return 0;
 }
 
+static void mt7621_pcie_enable_ports(struct mt7621_pcie *pcie)
+{
+	struct device *dev = pcie->dev;
+	struct mt7621_pcie_port *port;
+	u8 num_slots_enabled = 0;
+	u32 offset;
+	u32 slot;
+	u32 val;
+
+	list_for_each_entry(port, &pcie->ports, list) {
+		slot = port->slot;
+		offset = MT7621_PCIE_OFFSET + (slot * MT7621_NEXT_PORT);
+
+		if (port->enabled) {
+			/* open 7FFF:2G; ENABLE */
+			pcie_write(pcie, 0x7FFF0001,
+				   offset + RALINK_PCI_BAR0SETUP_ADDR);
+			pcie_write(pcie, MEMORY_BASE,
+				   offset + RALINK_PCI_IMBASEBAR0_ADDR);
+			pcie_write(pcie, 0x06040001, offset + RALINK_PCI_CLASS);
+			dev_info(dev, "PCIE%d enabled\n", slot);
+			num_slots_enabled++;
+		}
+	}
+
+	for (slot = 0; slot < num_slots_enabled; slot++) {
+		val = read_config(pcie, slot, 0x4);
+		write_config(pcie, slot, 0x4, val | 0x4);
+		val = read_config(pcie, slot, 0x70c);
+		val &= ~(0xff) << 8;
+		val |= 0x50 << 8;
+		write_config(pcie, slot, 0x70c, val);
+	}
+}
+
 static int mt7621_pcie_request_resources(struct mt7621_pcie *pcie,
 					 struct list_head *res)
 {
@@ -764,67 +802,7 @@ pcie(2/1/0) link status	pcie2_num	pcie1_num	pcie0_num
 	pcie_write(pcie, 0xffffffff, RALINK_PCI_MEMBASE);
 	pcie_write(pcie, RALINK_PCI_IO_MAP_BASE, RALINK_PCI_IOBASE);
 
-	//PCIe0
-	if ((pcie_link_status & 0x1) != 0) {
-		/* open 7FFF:2G; ENABLE */
-		pcie_write(pcie, 0x7FFF0001,
-			   RT6855_PCIE0_OFFSET + RALINK_PCI_BAR0SETUP_ADDR);
-		pcie_write(pcie, MEMORY_BASE,
-			   RT6855_PCIE0_OFFSET + RALINK_PCI_IMBASEBAR0_ADDR);
-		pcie_write(pcie, 0x06040001,
-			   RT6855_PCIE0_OFFSET + RALINK_PCI_CLASS);
-		dev_info(dev, "PCIE0 enabled\n");
-	}
-
-	//PCIe1
-	if ((pcie_link_status & 0x2) != 0) {
-		/* open 7FFF:2G; ENABLE */
-		pcie_write(pcie, 0x7FFF0001,
-			   RT6855_PCIE1_OFFSET + RALINK_PCI_BAR0SETUP_ADDR);
-		pcie_write(pcie, MEMORY_BASE,
-			   RT6855_PCIE1_OFFSET + RALINK_PCI_IMBASEBAR0_ADDR);
-		pcie_write(pcie, 0x06040001,
-			   RT6855_PCIE1_OFFSET + RALINK_PCI_CLASS);
-		dev_info(dev, "PCIE1 enabled\n");
-	}
-
-	//PCIe2
-	if ((pcie_link_status & 0x4) != 0) {
-		/* open 7FFF:2G; ENABLE */
-		pcie_write(pcie, 0x7FFF0001,
-			   RT6855_PCIE2_OFFSET + RALINK_PCI_BAR0SETUP_ADDR);
-		pcie_write(pcie, MEMORY_BASE,
-			   RT6855_PCIE2_OFFSET + RALINK_PCI_IMBASEBAR0_ADDR);
-		pcie_write(pcie, 0x06040001,
-			   RT6855_PCIE2_OFFSET + RALINK_PCI_CLASS);
-		dev_info(dev, "PCIE2 enabled\n");
-	}
-
-	switch (pcie_link_status) {
-	case 7:
-		val = read_config(pcie, 2, 0x4);
-		write_config(pcie, 2, 0x4, val | 0x4);
-		val = read_config(pcie, 2, 0x70c);
-		val &= ~(0xff) << 8;
-		val |= 0x50 << 8;
-		write_config(pcie, 2, 0x70c, val);
-	case 3:
-	case 5:
-	case 6:
-		val = read_config(pcie, 1, 0x4);
-		write_config(pcie, 1, 0x4, val | 0x4);
-		val = read_config(pcie, 1, 0x70c);
-		val &= ~(0xff) << 8;
-		val |= 0x50 << 8;
-		write_config(pcie, 1, 0x70c, val);
-	default:
-		val = read_config(pcie, 0, 0x4);
-		write_config(pcie, 0, 0x4, val | 0x4); //bus master enable
-		val = read_config(pcie, 0, 0x70c);
-		val &= ~(0xff) << 8;
-		val |= 0x50 << 8;
-		write_config(pcie, 0, 0x70c, val);
-	}
+	mt7621_pcie_enable_ports(pcie);
 
 	err = mt7621_pci_parse_request_of_pci_ranges(pcie);
 	if (err) {

commit d936550784a23b8dac077733cdf2f554a019286b
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Sun Nov 4 11:49:43 2018 +0100

    staging: mt7621-pci: use dev_* functions instead of printk
    
    checkpatch script is complaining about the use of printk instead
    of use more proper dev_* kernel functions. Replace all of them
    removing warnings.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/mt7621-pci/pci-mt7621.c b/drivers/staging/mt7621-pci/pci-mt7621.c
index afc87203de52..6d261809fcdf 100644
--- a/drivers/staging/mt7621-pci/pci-mt7621.c
+++ b/drivers/staging/mt7621-pci/pci-mt7621.c
@@ -405,8 +405,10 @@ static void mt7621_enable_phy(struct mt7621_pcie_port *port)
 	set_phy_for_ssc(port);
 }
 
-static void setup_cm_memory_region(struct resource *mem_resource)
+static void setup_cm_memory_region(struct mt7621_pcie *pcie)
 {
+	struct resource *mem_resource = &pcie->mem;
+	struct device *dev = pcie->dev;
 	resource_size_t mask;
 
 	if (mips_cps_numiocu(0)) {
@@ -419,7 +421,7 @@ static void setup_cm_memory_region(struct resource *mem_resource)
 
 		write_gcr_reg1_base(mem_resource->start);
 		write_gcr_reg1_mask(mask | CM_GCR_REGn_MASK_CMTGT_IOCU0);
-		printk("PCI coherence region base: 0x%08llx, mask/settings: 0x%08llx\n",
+		dev_info(dev, "PCI coherence region base: 0x%08llx, mask/settings: 0x%08llx\n",
 			(unsigned long long)read_gcr_reg1_base(),
 			(unsigned long long)read_gcr_reg1_mask());
 	}
@@ -771,7 +773,7 @@ pcie(2/1/0) link status	pcie2_num	pcie1_num	pcie0_num
 			   RT6855_PCIE0_OFFSET + RALINK_PCI_IMBASEBAR0_ADDR);
 		pcie_write(pcie, 0x06040001,
 			   RT6855_PCIE0_OFFSET + RALINK_PCI_CLASS);
-		printk("PCIE0 enabled\n");
+		dev_info(dev, "PCIE0 enabled\n");
 	}
 
 	//PCIe1
@@ -783,7 +785,7 @@ pcie(2/1/0) link status	pcie2_num	pcie1_num	pcie0_num
 			   RT6855_PCIE1_OFFSET + RALINK_PCI_IMBASEBAR0_ADDR);
 		pcie_write(pcie, 0x06040001,
 			   RT6855_PCIE1_OFFSET + RALINK_PCI_CLASS);
-		printk("PCIE1 enabled\n");
+		dev_info(dev, "PCIE1 enabled\n");
 	}
 
 	//PCIe2
@@ -795,7 +797,7 @@ pcie(2/1/0) link status	pcie2_num	pcie1_num	pcie0_num
 			   RT6855_PCIE2_OFFSET + RALINK_PCI_IMBASEBAR0_ADDR);
 		pcie_write(pcie, 0x06040001,
 			   RT6855_PCIE2_OFFSET + RALINK_PCI_CLASS);
-		printk("PCIE2 enabled\n");
+		dev_info(dev, "PCIE2 enabled\n");
 	}
 
 	switch (pcie_link_status) {
@@ -830,7 +832,7 @@ pcie(2/1/0) link status	pcie2_num	pcie1_num	pcie0_num
 		return err;
 	}
 
-	setup_cm_memory_region(&pcie->mem);
+	setup_cm_memory_region(pcie);
 
 	err = mt7621_pcie_request_resources(pcie, &res);
 	if (err) {

commit d2bac2fd6daa917389e975f1a2f502b538b99271
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Sun Nov 4 11:49:42 2018 +0100

    staging: mt7621-pci: use a trailing */ on a separate line
    
    Chackpatch script is compalining about one comment which
    is not following the kernel style. Fix it.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/mt7621-pci/pci-mt7621.c b/drivers/staging/mt7621-pci/pci-mt7621.c
index 0fc98f78ae6e..afc87203de52 100644
--- a/drivers/staging/mt7621-pci/pci-mt7621.c
+++ b/drivers/staging/mt7621-pci/pci-mt7621.c
@@ -410,9 +410,11 @@ static void setup_cm_memory_region(struct resource *mem_resource)
 	resource_size_t mask;
 
 	if (mips_cps_numiocu(0)) {
-		/* FIXME: hardware doesn't accept mask values with 1s after
+		/*
+		 * FIXME: hardware doesn't accept mask values with 1s after
 		 * 0s (e.g. 0xffef), so it would be great to warn if that's
-		 * about to happen */
+		 * about to happen
+		 */
 		mask = ~(mem_resource->end - mem_resource->start);
 
 		write_gcr_reg1_base(mem_resource->start);

commit 89e9f6e6adfcd0d92fb33f975897db1b0d154565
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Sun Nov 4 11:49:41 2018 +0100

    staging: mt7621-pci: remap and use sysctl from device tree
    
    There are some pointer read and writes which can be replaced
    properly using sysctl registers readed from device tree. Remap
    sysctl registers and replace in proper places.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/mt7621-pci/pci-mt7621.c b/drivers/staging/mt7621-pci/pci-mt7621.c
index 11fe9ffcb8e8..0fc98f78ae6e 100644
--- a/drivers/staging/mt7621-pci/pci-mt7621.c
+++ b/drivers/staging/mt7621-pci/pci-mt7621.c
@@ -37,6 +37,12 @@
  * devices.
  */
 
+/* sysctl */
+#define MT7621_CHIP_REV_ID		0x0c
+#define MT7621_GPIO_MODE		0x60
+#define CHIP_REV_MT7621_E2		0x0101
+
+/* pcie */
 #define RALINK_PCIE0_CLK_EN		BIT(24)
 #define RALINK_PCIE1_CLK_EN		BIT(25)
 #define RALINK_PCIE2_CLK_EN		BIT(26)
@@ -166,6 +172,7 @@ struct mt7621_pcie_port {
 /**
  * struct mt7621_pcie - PCIe host information
  * @base: IO Mapped Register Base
+ * @sysctl: system control mapped register base
  * @io: IO resource
  * @mem: non-prefetchable memory resource
  * @busn: bus range
@@ -175,6 +182,7 @@ struct mt7621_pcie_port {
  */
 struct mt7621_pcie {
 	void __iomem *base;
+	void __iomem *sysctl;
 	struct device *dev;
 	struct resource io;
 	struct resource mem;
@@ -389,8 +397,10 @@ set_phy_for_ssc(struct mt7621_pcie_port *port)
 
 static void mt7621_enable_phy(struct mt7621_pcie_port *port)
 {
-	/* MT7621 E2 */
-	if ((*(unsigned int *)(0xbe00000c) & 0xFFFF) == 0x0101)
+	struct mt7621_pcie *pcie = port->pcie;
+	u32 chip_rev_id = ioread32(pcie->sysctl + MT7621_CHIP_REV_ID);
+
+	if ((chip_rev_id & 0xFFFF) == CHIP_REV_MT7621_E2)
 		bypass_pipe_rst(port);
 	set_phy_for_ssc(port);
 }
@@ -524,6 +534,16 @@ static int mt7621_pcie_parse_dt(struct mt7621_pcie *pcie)
 	if (IS_ERR(pcie->base))
 		return PTR_ERR(pcie->base);
 
+	err = of_address_to_resource(node, 4, &regs);
+	if (err) {
+		dev_err(dev, "missing \"reg\" property\n");
+		return err;
+	}
+
+	pcie->sysctl = devm_ioremap_resource(dev, &regs);
+	if (IS_ERR(pcie->sysctl))
+		return PTR_ERR(pcie->sysctl);
+
 	for_each_available_child_of_node(node, child) {
 		int slot;
 
@@ -614,6 +634,16 @@ static int mt7621_pcie_register_host(struct pci_host_bridge *host,
 	return pci_host_probe(host);
 }
 
+static void mt7621_set_gpio_mode(struct mt7621_pcie *pcie)
+{
+	u32 reg = ioread32(pcie->sysctl + MT7621_GPIO_MODE);
+
+	reg &= ~(0x3 << 10 | 0x3 << 3);
+	reg |= (BIT(10) | BIT(3));
+	iowrite32(reg, pcie->sysctl + MT7621_GPIO_MODE);
+	mdelay(100);
+}
+
 static int mt7621_pci_probe(struct platform_device *pdev)
 {
 	struct device *dev = &pdev->dev;
@@ -648,9 +678,7 @@ static int mt7621_pci_probe(struct platform_device *pdev)
 	ioport_resource.start = 0;
 	ioport_resource.end = ~0UL; /* no limit */
 
-	*(unsigned int *)(0xbe000060) &= ~(0x3 << 10 | 0x3 << 3);
-	*(unsigned int *)(0xbe000060) |=  BIT(10) | BIT(3);
-	mdelay(100);
+	mt7621_set_gpio_mode(pcie);
 	*(unsigned int *)(0xbe000600) |= BIT(19) | BIT(8) | BIT(7); // use GPIO19/GPIO8/GPIO7 (PERST_N/UART_RXD3/UART_TXD3)
 	mdelay(100);
 	*(unsigned int *)(0xbe000620) &= ~(BIT(19) | BIT(8) | BIT(7));		// clear DATA

commit 4fdf3abcba03e57635cc05c8b3377151848438b7
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Sun Nov 4 11:49:39 2018 +0100

    staging: mt7621-pci: rename 'mt7621_pcie_enable_port' into 'mt7621_pcie_init_port'
    
    Rename function 'mt7621_pcie_enable_port' with a name which is better
    for what the function is really doing calling it 'mt7621_pcie_init_port'.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/mt7621-pci/pci-mt7621.c b/drivers/staging/mt7621-pci/pci-mt7621.c
index 50c7bd79ba44..11fe9ffcb8e8 100644
--- a/drivers/staging/mt7621-pci/pci-mt7621.c
+++ b/drivers/staging/mt7621-pci/pci-mt7621.c
@@ -543,7 +543,7 @@ static int mt7621_pcie_parse_dt(struct mt7621_pcie *pcie)
 	return 0;
 }
 
-static int mt7621_pcie_enable_port(struct mt7621_pcie_port *port)
+static int mt7621_pcie_init_port(struct mt7621_pcie_port *port)
 {
 	struct mt7621_pcie *pcie = port->pcie;
 	struct device *dev = pcie->dev;
@@ -660,7 +660,7 @@ static int mt7621_pci_probe(struct platform_device *pdev)
 	list_for_each_entry_safe(port, tmp, &pcie->ports, list) {
 		u32 slot = port->slot;
 
-		err = mt7621_pcie_enable_port(port);
+		err = mt7621_pcie_init_port(port);
 		if (err) {
 			dev_err(dev, "enabling port %d failed\n", slot);
 			list_del(&port->list);

commit f443b5c22ebdbd4f3543d1f7ec44b0c455420665
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Sun Nov 4 11:49:38 2018 +0100

    staging: mt7621-pci: debug port N_FTS inside 'mt7621_pcie_enable_port'
    
    Move debug for the port N_FTS from driver probe function to the more
    appropiate one 'mt7621_pcie_enable_port'.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/mt7621-pci/pci-mt7621.c b/drivers/staging/mt7621-pci/pci-mt7621.c
index 7e76d30907c4..50c7bd79ba44 100644
--- a/drivers/staging/mt7621-pci/pci-mt7621.c
+++ b/drivers/staging/mt7621-pci/pci-mt7621.c
@@ -575,6 +575,9 @@ static int mt7621_pcie_enable_port(struct mt7621_pcie_port *port)
 
 	mt7621_enable_phy(port);
 
+	val = read_config(pcie, slot, 0x70c);
+	dev_info(dev, "Port %d N_FTS = %x\n", (unsigned int)val, slot);
+
 	return 0;
 }
 
@@ -661,9 +664,6 @@ static int mt7621_pci_probe(struct platform_device *pdev)
 		if (err) {
 			dev_err(dev, "enabling port %d failed\n", slot);
 			list_del(&port->list);
-		} else {
-			val = read_config(pcie, slot, 0x70c);
-			dev_info(dev, "Port %d N_FTS = %x\n", (unsigned int)val, slot);
 		}
 	}
 

commit 3beb6da5d52a1722b33a9355fc191995d0abb6de
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Sun Nov 4 11:49:37 2018 +0100

    staging: mt7621-pci: factor out 'mt7621_enable_phy' function
    
    Factor out a new function 'mt7621_enable_phy' for enabling the
    pcie phy for each port and call it from 'mt7621_pcie_enable_port'.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/mt7621-pci/pci-mt7621.c b/drivers/staging/mt7621-pci/pci-mt7621.c
index 5dce7afc125d..7e76d30907c4 100644
--- a/drivers/staging/mt7621-pci/pci-mt7621.c
+++ b/drivers/staging/mt7621-pci/pci-mt7621.c
@@ -387,6 +387,14 @@ set_phy_for_ssc(struct mt7621_pcie_port *port)
 	pcie_write(pcie, val, offset);
 }
 
+static void mt7621_enable_phy(struct mt7621_pcie_port *port)
+{
+	/* MT7621 E2 */
+	if ((*(unsigned int *)(0xbe00000c) & 0xFFFF) == 0x0101)
+		bypass_pipe_rst(port);
+	set_phy_for_ssc(port);
+}
+
 static void setup_cm_memory_region(struct resource *mem_resource)
 {
 	resource_size_t mask;
@@ -565,6 +573,8 @@ static int mt7621_pcie_enable_port(struct mt7621_pcie_port *port)
 		pcie_write(pcie, val, RALINK_PCI_PCIMSK_ADDR);
 	}
 
+	mt7621_enable_phy(port);
+
 	return 0;
 }
 
@@ -652,9 +662,6 @@ static int mt7621_pci_probe(struct platform_device *pdev)
 			dev_err(dev, "enabling port %d failed\n", slot);
 			list_del(&port->list);
 		} else {
-			if ((*(unsigned int *)(0xbe00000c) & 0xFFFF) == 0x0101) // MT7621 E2
-				bypass_pipe_rst(port);
-			set_phy_for_ssc(port);
 			val = read_config(pcie, slot, 0x70c);
 			dev_info(dev, "Port %d N_FTS = %x\n", (unsigned int)val, slot);
 		}

commit 6b767904b90e323626f72a6c3365d63de81c4207
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Sun Nov 4 11:49:36 2018 +0100

    staging: mt7621-pci: rewrite pcie phy related functions
    
    Function 'bypass_pipe_rst' and 'set_phy_for_ssc' can be
    written in a cleaner way. Instead of use comments to see which
    bits are the ones which are being enabled add new macros with
    that information using BIT and GENMASK kernel macros. Avoid the
    use of set_pcie_phy which is kind of dark and use new macros also
    resetting and adding bits using bitwise operators directly in the
    code. Now these function are offset-based on the port to use them
    cleaner in driver probe functio and improving readability.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/mt7621-pci/pci-mt7621.c b/drivers/staging/mt7621-pci/pci-mt7621.c
index 28c3f0a91075..5dce7afc125d 100644
--- a/drivers/staging/mt7621-pci/pci-mt7621.c
+++ b/drivers/staging/mt7621-pci/pci-mt7621.c
@@ -66,9 +66,6 @@
 #define RALINK_PCI_SUBID		0x0038
 #define RALINK_PCI_STATUS		0x0050
 
-#define RALINK_PCIEPHY_P0P1_CTL_OFFSET	0x9000
-#define RALINK_PCIEPHY_P2_CTL_OFFSET	0xA000
-
 #define RALINK_PCI_MM_MAP_BASE		0x60000000
 #define RALINK_PCI_IO_MAP_BASE		0x1e160000
 
@@ -79,13 +76,79 @@
 #define RALINK_PCIE_CLK_GEN1		0x80
 
 #define MEMORY_BASE 0x0
+
 static int pcie_link_status;
 
+/* pcie phy related macros */
+#define RALINK_PCIEPHY_P0P1_CTL_OFFSET	0x9000
+#define RALINK_PCIEPHY_P2_CTL_OFFSET	0xA000
+
+#define RG_P0_TO_P1_WIDTH		0x100
+
+#define RG_PE1_PIPE_REG			0x02c
+#define RG_PE1_PIPE_RST			BIT(12)
+#define RG_PE1_PIPE_CMD_FRC		BIT(4)
+
+#define RG_PE1_H_LCDDS_REG		0x49c
+#define RG_PE1_H_LCDDS_PCW		GENMASK(30, 0)
+#define RG_PE1_H_LCDDS_PCW_VAL(x)	((0x7fffffff & (x)) << 0)
+
+#define RG_PE1_FRC_H_XTAL_REG		0x400
+#define RG_PE1_FRC_H_XTAL_TYPE          BIT(8)
+#define RG_PE1_H_XTAL_TYPE              GENMASK(10, 9)
+#define RG_PE1_H_XTAL_TYPE_VAL(x)       ((0x3 & (x)) << 9)
+
+#define RG_PE1_FRC_PHY_REG		0x000
+#define RG_PE1_FRC_PHY_EN               BIT(4)
+#define RG_PE1_PHY_EN                   BIT(5)
+
+#define RG_PE1_H_PLL_REG		0x490
+#define RG_PE1_H_PLL_BC			GENMASK(23, 22)
+#define RG_PE1_H_PLL_BC_VAL(x)		((0x3 & (x)) << 22)
+#define RG_PE1_H_PLL_BP			GENMASK(21, 18)
+#define RG_PE1_H_PLL_BP_VAL(x)		((0xf & (x)) << 18)
+#define RG_PE1_H_PLL_IR			GENMASK(15, 12)
+#define RG_PE1_H_PLL_IR_VAL(x)		((0xf & (x)) << 12)
+#define RG_PE1_H_PLL_IC			GENMASK(11, 8)
+#define RG_PE1_H_PLL_IC_VAL(x)		((0xf & (x)) << 8)
+#define RG_PE1_H_PLL_PREDIV             GENMASK(7, 6)
+#define RG_PE1_H_PLL_PREDIV_VAL(x)      ((0x3 & (x)) << 6)
+#define RG_PE1_PLL_DIVEN		GENMASK(3, 1)
+#define RG_PE1_PLL_DIVEN_VAL(x)		((0x7 & (x)) << 1)
+
+#define RG_PE1_H_PLL_FBKSEL_REG		0x4bc
+#define RG_PE1_H_PLL_FBKSEL             GENMASK(5, 4)
+#define RG_PE1_H_PLL_FBKSEL_VAL(x)      ((0x3 & (x)) << 4)
+
+#define	RG_PE1_H_LCDDS_SSC_PRD_REG	0x4a4
+#define RG_PE1_H_LCDDS_SSC_PRD          GENMASK(15, 0)
+#define RG_PE1_H_LCDDS_SSC_PRD_VAL(x)   ((0xffff & (x)) << 0)
+
+#define RG_PE1_H_LCDDS_SSC_DELTA_REG	0x4a8
+#define RG_PE1_H_LCDDS_SSC_DELTA        GENMASK(11, 0)
+#define RG_PE1_H_LCDDS_SSC_DELTA_VAL(x) ((0xfff & (x)) << 0)
+#define RG_PE1_H_LCDDS_SSC_DELTA1       GENMASK(27, 16)
+#define RG_PE1_H_LCDDS_SSC_DELTA1_VAL(x) ((0xff & (x)) << 16)
+
+#define RG_PE1_LCDDS_CLK_PH_INV_REG	0x4a0
+#define RG_PE1_LCDDS_CLK_PH_INV		BIT(5)
+
+#define RG_PE1_H_PLL_BR_REG		0x4ac
+#define RG_PE1_H_PLL_BR			GENMASK(18, 16)
+#define RG_PE1_H_PLL_BR_VAL(x)		((0x7 & (x)) << 16)
+
+#define	RG_PE1_MSTCKDIV_REG		0x414
+#define RG_PE1_MSTCKDIV			GENMASK(7, 6)
+#define RG_PE1_MSTCKDIV_VAL(x)		((0x3 & (x)) << 6)
+
+#define RG_PE1_FRC_MSTCKDIV		BIT(5)
+
 /**
  * struct mt7621_pcie_port - PCIe port information
  * @base: I/O mapped register base
  * @list: port list
  * @pcie: pointer to PCIe host info
+ * @phy_reg_offset: offset to related phy registers
  * @pcie_rst: pointer to port reset control
  * @pcie_clk: PCIe clock
  * @slot: port slot
@@ -94,6 +157,7 @@ struct mt7621_pcie_port {
 	void __iomem *base;
 	struct list_head list;
 	struct mt7621_pcie *pcie;
+	u32 phy_reg_offset;
 	struct reset_control *pcie_rst;
 	struct clk *pcie_clk;
 	u32 slot;
@@ -187,109 +251,140 @@ write_config(struct mt7621_pcie *pcie, unsigned int dev, u32 reg, u32 val)
 }
 
 static void
-set_pcie_phy(struct mt7621_pcie *pcie, u32 offset,
-	     int start_b, int bits, int val)
+bypass_pipe_rst(struct mt7621_pcie_port *port)
 {
+	struct mt7621_pcie *pcie = port->pcie;
+	u32 phy_offset = port->phy_reg_offset;
+	u32 offset = (port->slot != 1) ?
+		phy_offset + RG_PE1_PIPE_REG :
+		phy_offset + RG_PE1_PIPE_REG + RG_P0_TO_P1_WIDTH;
 	u32 reg = pcie_read(pcie, offset);
 
-	reg &= ~(((1 << bits) - 1) << start_b);
-	reg |= val << start_b;
+	reg &= ~(RG_PE1_PIPE_RST | RG_PE1_PIPE_CMD_FRC);
+	reg |= (RG_PE1_PIPE_RST | RG_PE1_PIPE_CMD_FRC);
 	pcie_write(pcie, reg, offset);
 }
 
 static void
-bypass_pipe_rst(struct mt7621_pcie *pcie)
+set_phy_for_ssc(struct mt7621_pcie_port *port)
 {
-	/* PCIe Port 0 */
-	set_pcie_phy(pcie, (RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x02c), 12, 1, 0x01);	// rg_pe1_pipe_rst_b
-	set_pcie_phy(pcie, (RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x02c),  4, 1, 0x01);	// rg_pe1_pipe_cmd_frc[4]
-	/* PCIe Port 1 */
-	set_pcie_phy(pcie, (RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x12c), 12, 1, 0x01);	// rg_pe1_pipe_rst_b
-	set_pcie_phy(pcie, (RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x12c),  4, 1, 0x01);	// rg_pe1_pipe_cmd_frc[4]
-	/* PCIe Port 2 */
-	set_pcie_phy(pcie, (RALINK_PCIEPHY_P2_CTL_OFFSET + 0x02c), 12, 1, 0x01);	// rg_pe1_pipe_rst_b
-	set_pcie_phy(pcie, (RALINK_PCIEPHY_P2_CTL_OFFSET + 0x02c),  4, 1, 0x01);	// rg_pe1_pipe_cmd_frc[4]
-}
-
-static void
-set_phy_for_ssc(struct mt7621_pcie *pcie)
-{
-	unsigned long reg = rt_sysc_r32(SYSC_REG_SYSTEM_CONFIG0);
+	struct mt7621_pcie *pcie = port->pcie;
+	struct device *dev = pcie->dev;
+	u32 phy_offset = port->phy_reg_offset;
+	u32 reg = rt_sysc_r32(SYSC_REG_SYSTEM_CONFIG0);
+	u32 offset;
+	u32 val;
 
 	reg = (reg >> 6) & 0x7;
-	/* Set PCIe Port0 & Port1 PHY to disable SSC */
+	/* Set PCIe Port PHY to disable SSC */
 	/* Debug Xtal Type */
-	set_pcie_phy(pcie, (RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x400),  8, 1, 0x01);	// rg_pe1_frc_h_xtal_type
-	set_pcie_phy(pcie, (RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x400),  9, 2, 0x00);	// rg_pe1_h_xtal_type
-	set_pcie_phy(pcie, (RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x000),  4, 1, 0x01);	// rg_pe1_frc_phy_en	//Force Port 0 enable control
-	set_pcie_phy(pcie, (RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x100),  4, 1, 0x01);	// rg_pe1_frc_phy_en	//Force Port 1 enable control
-	set_pcie_phy(pcie, (RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x000),  5, 1, 0x00);	// rg_pe1_phy_en	//Port 0 disable
-	set_pcie_phy(pcie, (RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x100),  5, 1, 0x00);	// rg_pe1_phy_en	//Port 1 disable
-	if (reg <= 5 && reg >= 3) {	// 40MHz Xtal
-		set_pcie_phy(pcie, (RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x490),  6, 2, 0x01);	// RG_PE1_H_PLL_PREDIV	//Pre-divider ratio (for host mode)
-		printk("***** Xtal 40MHz *****\n");
-	} else {			// 25MHz | 20MHz Xtal
-		set_pcie_phy(pcie, (RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x490),  6, 2, 0x00);	// RG_PE1_H_PLL_PREDIV	//Pre-divider ratio (for host mode)
+	offset = phy_offset + RG_PE1_FRC_H_XTAL_REG;
+	val = pcie_read(pcie, offset);
+	val &= ~(RG_PE1_FRC_H_XTAL_TYPE | RG_PE1_H_XTAL_TYPE);
+	val |= RG_PE1_FRC_H_XTAL_TYPE;
+	val |= RG_PE1_H_XTAL_TYPE_VAL(0x00);
+	pcie_write(pcie, val, offset);
+
+	/* disable port */
+	offset = (port->slot != 1) ?
+		phy_offset + RG_PE1_FRC_PHY_REG :
+		phy_offset + RG_PE1_FRC_PHY_REG + RG_P0_TO_P1_WIDTH;
+	val = pcie_read(pcie, offset);
+	val &= ~(RG_PE1_FRC_PHY_EN | RG_PE1_PHY_EN);
+	val |= RG_PE1_FRC_PHY_EN;
+	pcie_write(pcie, val, offset);
+
+	/* Set Pre-divider ratio (for host mode) */
+	offset =  phy_offset + RG_PE1_H_PLL_REG;
+	val = pcie_read(pcie, offset);
+	val &= ~(RG_PE1_H_PLL_PREDIV);
+
+	if (reg <= 5 && reg >= 3) { /* 40MHz Xtal */
+		val |= RG_PE1_H_PLL_PREDIV_VAL(0x01);
+		pcie_write(pcie, val, offset);
+		dev_info(dev, "Xtal is 40MHz\n");
+	} else { /* 25MHz | 20MHz Xtal */
+		val |= RG_PE1_H_PLL_PREDIV_VAL(0x00);
+		pcie_write(pcie, val, offset);
 		if (reg >= 6) {
-			printk("***** Xtal 25MHz *****\n");
-			set_pcie_phy(pcie, (RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x4bc),  4, 2, 0x01);	// RG_PE1_H_PLL_FBKSEL	//Feedback clock select
-			set_pcie_phy(pcie, (RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x49c),  0, 31, 0x18000000);	// RG_PE1_H_LCDDS_PCW_NCPO	//DDS NCPO PCW (for host mode)
-			set_pcie_phy(pcie, (RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x4a4),  0, 16, 0x18d);	// RG_PE1_H_LCDDS_SSC_PRD	//DDS SSC dither period control
-			set_pcie_phy(pcie, (RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x4a8),  0, 12, 0x4a);	// RG_PE1_H_LCDDS_SSC_DELTA	//DDS SSC dither amplitude control
-			set_pcie_phy(pcie, (RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x4a8), 16, 12, 0x4a);	// RG_PE1_H_LCDDS_SSC_DELTA1	//DDS SSC dither amplitude control for initial
+			dev_info(dev, "Xtal is 25MHz\n");
+
+			/* Select feedback clock */
+			offset = phy_offset + RG_PE1_H_PLL_FBKSEL_REG;
+			val = pcie_read(pcie, offset);
+			val &= ~(RG_PE1_H_PLL_FBKSEL);
+			val |= RG_PE1_H_PLL_FBKSEL_VAL(0x01);
+			pcie_write(pcie, val, offset);
+
+			/* DDS NCPO PCW (for host mode) */
+			offset = phy_offset + RG_PE1_H_LCDDS_SSC_PRD_REG;
+			val = pcie_read(pcie, offset);
+			val &= ~(RG_PE1_H_LCDDS_SSC_PRD);
+			val |= RG_PE1_H_LCDDS_SSC_PRD_VAL(0x18000000);
+			pcie_write(pcie, val, offset);
+
+			/* DDS SSC dither period control */
+			offset = phy_offset + RG_PE1_H_LCDDS_SSC_PRD_REG;
+			val = pcie_read(pcie, offset);
+			val &= ~(RG_PE1_H_LCDDS_SSC_PRD);
+			val |= RG_PE1_H_LCDDS_SSC_PRD_VAL(0x18d);
+			pcie_write(pcie, val, offset);
+
+			/* DDS SSC dither amplitude control */
+			offset = phy_offset + RG_PE1_H_LCDDS_SSC_DELTA_REG;
+			val = pcie_read(pcie, offset);
+			val &= ~(RG_PE1_H_LCDDS_SSC_DELTA |
+				 RG_PE1_H_LCDDS_SSC_DELTA1);
+			val |= RG_PE1_H_LCDDS_SSC_DELTA_VAL(0x4a);
+			val |= RG_PE1_H_LCDDS_SSC_DELTA1_VAL(0x4a);
+			pcie_write(pcie, val, offset);
 		} else {
-			printk("***** Xtal 20MHz *****\n");
+			dev_info(dev, "Xtal is 20MHz\n");
 		}
 	}
-	set_pcie_phy(pcie, (RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x4a0),  5, 1, 0x01);	// RG_PE1_LCDDS_CLK_PH_INV	//DDS clock inversion
-	set_pcie_phy(pcie, (RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x490), 22, 2, 0x02);	// RG_PE1_H_PLL_BC
-	set_pcie_phy(pcie, (RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x490), 18, 4, 0x06);	// RG_PE1_H_PLL_BP
-	set_pcie_phy(pcie, (RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x490), 12, 4, 0x02);	// RG_PE1_H_PLL_IR
-	set_pcie_phy(pcie, (RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x490),  8, 4, 0x01);	// RG_PE1_H_PLL_IC
-	set_pcie_phy(pcie, (RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x4ac), 16, 3, 0x00);	// RG_PE1_H_PLL_BR
-	set_pcie_phy(pcie, (RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x490),  1, 3, 0x02);	// RG_PE1_PLL_DIVEN
-	if (reg <= 5 && reg >= 3) {	// 40MHz Xtal
-		set_pcie_phy(pcie, (RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x414),  6, 2, 0x01);	// rg_pe1_mstckdiv		//value of da_pe1_mstckdiv when force mode enable
-		set_pcie_phy(pcie, (RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x414),  5, 1, 0x01);	// rg_pe1_frc_mstckdiv	//force mode enable of da_pe1_mstckdiv
-	}
-	/* Enable PHY and disable force mode */
-	set_pcie_phy(pcie, (RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x000),  5, 1, 0x01);	// rg_pe1_phy_en	//Port 0 enable
-	set_pcie_phy(pcie, (RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x100),  5, 1, 0x01);	// rg_pe1_phy_en	//Port 1 enable
-	set_pcie_phy(pcie, (RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x000),  4, 1, 0x00);	// rg_pe1_frc_phy_en	//Force Port 0 disable control
-	set_pcie_phy(pcie, (RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x100),  4, 1, 0x00);	// rg_pe1_frc_phy_en	//Force Port 1 disable control
 
-	/* Set PCIe Port2 PHY to disable SSC */
-	/* Debug Xtal Type */
-	set_pcie_phy(pcie, (RALINK_PCIEPHY_P2_CTL_OFFSET + 0x400),  8, 1, 0x01);	// rg_pe1_frc_h_xtal_type
-	set_pcie_phy(pcie, (RALINK_PCIEPHY_P2_CTL_OFFSET + 0x400),  9, 2, 0x00);	// rg_pe1_h_xtal_type
-	set_pcie_phy(pcie, (RALINK_PCIEPHY_P2_CTL_OFFSET + 0x000),  4, 1, 0x01);	// rg_pe1_frc_phy_en	//Force Port 0 enable control
-	set_pcie_phy(pcie, (RALINK_PCIEPHY_P2_CTL_OFFSET + 0x000),  5, 1, 0x00);	// rg_pe1_phy_en	//Port 0 disable
-	if (reg <= 5 && reg >= 3) {	// 40MHz Xtal
-		set_pcie_phy(pcie, (RALINK_PCIEPHY_P2_CTL_OFFSET + 0x490),  6, 2, 0x01);	// RG_PE1_H_PLL_PREDIV	//Pre-divider ratio (for host mode)
-	} else {			// 25MHz | 20MHz Xtal
-		set_pcie_phy(pcie, (RALINK_PCIEPHY_P2_CTL_OFFSET + 0x490),  6, 2, 0x00);	// RG_PE1_H_PLL_PREDIV	//Pre-divider ratio (for host mode)
-		if (reg >= 6) {		// 25MHz Xtal
-			set_pcie_phy(pcie, (RALINK_PCIEPHY_P2_CTL_OFFSET + 0x4bc),  4, 2, 0x01);	// RG_PE1_H_PLL_FBKSEL	//Feedback clock select
-			set_pcie_phy(pcie, (RALINK_PCIEPHY_P2_CTL_OFFSET + 0x49c),  0, 31, 0x18000000);	// RG_PE1_H_LCDDS_PCW_NCPO	//DDS NCPO PCW (for host mode)
-			set_pcie_phy(pcie, (RALINK_PCIEPHY_P2_CTL_OFFSET + 0x4a4),  0, 16, 0x18d);	// RG_PE1_H_LCDDS_SSC_PRD	//DDS SSC dither period control
-			set_pcie_phy(pcie, (RALINK_PCIEPHY_P2_CTL_OFFSET + 0x4a8),  0, 12, 0x4a);	// RG_PE1_H_LCDDS_SSC_DELTA	//DDS SSC dither amplitude control
-			set_pcie_phy(pcie, (RALINK_PCIEPHY_P2_CTL_OFFSET + 0x4a8), 16, 12, 0x4a);	// RG_PE1_H_LCDDS_SSC_DELTA1	//DDS SSC dither amplitude control for initial
-		}
-	}
-	set_pcie_phy(pcie, (RALINK_PCIEPHY_P2_CTL_OFFSET + 0x4a0),  5, 1, 0x01);	// RG_PE1_LCDDS_CLK_PH_INV	//DDS clock inversion
-	set_pcie_phy(pcie, (RALINK_PCIEPHY_P2_CTL_OFFSET + 0x490), 22, 2, 0x02);	// RG_PE1_H_PLL_BC
-	set_pcie_phy(pcie, (RALINK_PCIEPHY_P2_CTL_OFFSET + 0x490), 18, 4, 0x06);	// RG_PE1_H_PLL_BP
-	set_pcie_phy(pcie, (RALINK_PCIEPHY_P2_CTL_OFFSET + 0x490), 12, 4, 0x02);	// RG_PE1_H_PLL_IR
-	set_pcie_phy(pcie, (RALINK_PCIEPHY_P2_CTL_OFFSET + 0x490),  8, 4, 0x01);	// RG_PE1_H_PLL_IC
-	set_pcie_phy(pcie, (RALINK_PCIEPHY_P2_CTL_OFFSET + 0x4ac), 16, 3, 0x00);	// RG_PE1_H_PLL_BR
-	set_pcie_phy(pcie, (RALINK_PCIEPHY_P2_CTL_OFFSET + 0x490),  1, 3, 0x02);	// RG_PE1_PLL_DIVEN
-	if (reg <= 5 && reg >= 3) {	// 40MHz Xtal
-		set_pcie_phy(pcie, (RALINK_PCIEPHY_P2_CTL_OFFSET + 0x414),  6, 2, 0x01);	// rg_pe1_mstckdiv		//value of da_pe1_mstckdiv when force mode enable
-		set_pcie_phy(pcie, (RALINK_PCIEPHY_P2_CTL_OFFSET + 0x414),  5, 1, 0x01);	// rg_pe1_frc_mstckdiv	//force mode enable of da_pe1_mstckdiv
+	/* DDS clock inversion */
+	offset = phy_offset + RG_PE1_LCDDS_CLK_PH_INV_REG;
+	val = pcie_read(pcie, offset);
+	val &= ~(RG_PE1_LCDDS_CLK_PH_INV);
+	val |= RG_PE1_LCDDS_CLK_PH_INV;
+	pcie_write(pcie, val, offset);
+
+	/* Set PLL bits */
+	offset = phy_offset + RG_PE1_H_PLL_REG;
+	val = pcie_read(pcie, offset);
+	val &= ~(RG_PE1_H_PLL_BC | RG_PE1_H_PLL_BP | RG_PE1_H_PLL_IR |
+		 RG_PE1_H_PLL_IC | RG_PE1_PLL_DIVEN);
+	val |= RG_PE1_H_PLL_BC_VAL(0x02);
+	val |= RG_PE1_H_PLL_BP_VAL(0x06);
+	val |= RG_PE1_H_PLL_IR_VAL(0x02);
+	val |= RG_PE1_H_PLL_IC_VAL(0x01);
+	val |= RG_PE1_PLL_DIVEN_VAL(0x02);
+	pcie_write(pcie, val, offset);
+
+	offset = phy_offset + RG_PE1_H_PLL_BR_REG;
+	val = pcie_read(pcie, offset);
+	val &= ~(RG_PE1_H_PLL_BR);
+	val |= RG_PE1_H_PLL_BR_VAL(0x00);
+	pcie_write(pcie, val, offset);
+
+	if (reg <= 5 && reg >= 3) { /* 40MHz Xtal */
+		/* set force mode enable of da_pe1_mstckdiv */
+		offset = phy_offset + RG_PE1_MSTCKDIV_REG;
+		val = pcie_read(pcie, offset);
+		val &= ~(RG_PE1_MSTCKDIV | RG_PE1_FRC_MSTCKDIV);
+		val |= (RG_PE1_MSTCKDIV_VAL(0x01) | RG_PE1_FRC_MSTCKDIV);
+		pcie_write(pcie, val, offset);
 	}
+
 	/* Enable PHY and disable force mode */
-	set_pcie_phy(pcie, (RALINK_PCIEPHY_P2_CTL_OFFSET + 0x000),  5, 1, 0x01);	// rg_pe1_phy_en	//Port 0 enable
-	set_pcie_phy(pcie, (RALINK_PCIEPHY_P2_CTL_OFFSET + 0x000),  4, 1, 0x00);	// rg_pe1_frc_phy_en	//Force Port 0 disable control
+	offset = (port->slot != 1) ?
+		phy_offset + RG_PE1_FRC_PHY_REG :
+		phy_offset + RG_PE1_FRC_PHY_REG + RG_P0_TO_P1_WIDTH;
+	val = pcie_read(pcie, offset);
+	val &= ~(RG_PE1_FRC_PHY_EN | RG_PE1_PHY_EN);
+	val |= (RG_PE1_FRC_PHY_EN | RG_PE1_PHY_EN);
+	pcie_write(pcie, val, offset);
 }
 
 static void setup_cm_memory_region(struct resource *mem_resource)
@@ -394,6 +489,9 @@ static int mt7621_pcie_parse_port(struct mt7621_pcie *pcie,
 
 	port->slot = slot;
 	port->pcie = pcie;
+	port->phy_reg_offset = (slot != 2) ?
+				RALINK_PCIEPHY_P0P1_CTL_OFFSET :
+				RALINK_PCIEPHY_P2_CTL_OFFSET;
 
 	INIT_LIST_HEAD(&port->list);
 	list_add_tail(&port->list, &pcie->ports);
@@ -547,23 +645,21 @@ static int mt7621_pci_probe(struct platform_device *pdev)
 	mdelay(100);
 
 	list_for_each_entry_safe(port, tmp, &pcie->ports, list) {
+		u32 slot = port->slot;
+
 		err = mt7621_pcie_enable_port(port);
 		if (err) {
-			dev_err(dev, "enabling port %d failed\n", port->slot);
+			dev_err(dev, "enabling port %d failed\n", slot);
 			list_del(&port->list);
+		} else {
+			if ((*(unsigned int *)(0xbe00000c) & 0xFFFF) == 0x0101) // MT7621 E2
+				bypass_pipe_rst(port);
+			set_phy_for_ssc(port);
+			val = read_config(pcie, slot, 0x70c);
+			dev_info(dev, "Port %d N_FTS = %x\n", (unsigned int)val, slot);
 		}
 	}
 
-	if ((*(unsigned int *)(0xbe00000c) & 0xFFFF) == 0x0101) // MT7621 E2
-		bypass_pipe_rst(pcie);
-	set_phy_for_ssc(pcie);
-
-	list_for_each_entry_safe(port, tmp, &pcie->ports, list) {
-		u32 slot = port->slot;
-		val = read_config(pcie, slot, 0x70c);
-		dev_info(dev, "Port %d N_FTS = %x\n", (unsigned int)val, slot);
-	}
-
 	rt_sysc_m32(0, RALINK_PCIE_RST, RALINK_RSTCTRL);
 	rt_sysc_m32(0x30, 2 << 4, SYSC_REG_SYSTEM_CONFIG1);
 

commit 7bf10a7261c42aea8c6620038fc640683dab4603
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Sun Nov 4 11:49:35 2018 +0100

    staging: mt7621-pci: reagroup reset related macros all together
    
    Reset bits related macros are in different parts. Reagroup
    all of them together to  improve readability.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/mt7621-pci/pci-mt7621.c b/drivers/staging/mt7621-pci/pci-mt7621.c
index c9ac92e1b660..28c3f0a91075 100644
--- a/drivers/staging/mt7621-pci/pci-mt7621.c
+++ b/drivers/staging/mt7621-pci/pci-mt7621.c
@@ -45,6 +45,9 @@
 #define RALINK_PCI_CONFIG_DATA		0x24
 #define RALINK_PCI_MEMBASE		0x28
 #define RALINK_PCI_IOBASE		0x2C
+
+/* RALINK_RSTCTRL bits */
+#define RALINK_PCIE_RST			BIT(23)
 #define RALINK_PCIE0_RST		BIT(24)
 #define RALINK_PCIE1_RST		BIT(25)
 #define RALINK_PCIE2_RST		BIT(26)
@@ -74,8 +77,6 @@
 #define RALINK_GPIOMODE			0x60
 #define RALINK_PCIE_CLK_GEN		0x7c
 #define RALINK_PCIE_CLK_GEN1		0x80
-//RALINK_RSTCTRL bit
-#define RALINK_PCIE_RST			BIT(23)
 
 #define MEMORY_BASE 0x0
 static int pcie_link_status;

commit d9ecdd396cd5037b38ebd791aae032faab89c5bc
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Sun Nov 4 11:49:34 2018 +0100

    staging: mt7621-pci: remove reset related unused macros
    
    There are three macros which are not being used at all.
    Remove them.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/mt7621-pci/pci-mt7621.c b/drivers/staging/mt7621-pci/pci-mt7621.c
index c4adf86b3220..c9ac92e1b660 100644
--- a/drivers/staging/mt7621-pci/pci-mt7621.c
+++ b/drivers/staging/mt7621-pci/pci-mt7621.c
@@ -76,10 +76,6 @@
 #define RALINK_PCIE_CLK_GEN1		0x80
 //RALINK_RSTCTRL bit
 #define RALINK_PCIE_RST			BIT(23)
-#define RALINK_PCI_RST			BIT(24)
-//RALINK_CLKCFG1 bit
-#define RALINK_PCI_CLK_EN		BIT(19)
-#define RALINK_PCIE_CLK_EN		BIT(21)
 
 #define MEMORY_BASE 0x0
 static int pcie_link_status;

commit bd74b4a290f207bfc60592f6ff98a8b638a32601
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Sun Nov 4 11:49:33 2018 +0100

    staging: mt7621-pci: remove two commented code lines
    
    This two lines whch are commented are not needed at all.
    Remove them.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/mt7621-pci/pci-mt7621.c b/drivers/staging/mt7621-pci/pci-mt7621.c
index d61b28794610..c4adf86b3220 100644
--- a/drivers/staging/mt7621-pci/pci-mt7621.c
+++ b/drivers/staging/mt7621-pci/pci-mt7621.c
@@ -629,11 +629,6 @@ pcie(2/1/0) link status	pcie2_num	pcie1_num	pcie0_num
 		break;
 	}
 
-/*
-	ioport_resource.start = mt7621_res_pci_io1.start;
-	ioport_resource.end = mt7621_res_pci_io1.end;
-*/
-
 	pcie_write(pcie, 0xffffffff, RALINK_PCI_MEMBASE);
 	pcie_write(pcie, RALINK_PCI_IO_MAP_BASE, RALINK_PCI_IOBASE);
 

commit 335bbd9ed7f967c54933005359304c1336b99d2e
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Sun Nov 4 11:49:32 2018 +0100

    staging: mt7621-pci: remove GPL2+ text from license header
    
    This file has a valid SPDX license line added so reamining
    GPL2+ boilerplate text is not needed at all. Remove it.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/mt7621-pci/pci-mt7621.c b/drivers/staging/mt7621-pci/pci-mt7621.c
index d94587e1e699..d61b28794610 100644
--- a/drivers/staging/mt7621-pci/pci-mt7621.c
+++ b/drivers/staging/mt7621-pci/pci-mt7621.c
@@ -1,33 +1,10 @@
 // SPDX-License-Identifier: GPL-2.0+
-/**************************************************************************
- *
- *  BRIEF MODULE DESCRIPTION
+/*
+ * BRIEF MODULE DESCRIPTION
  *     PCI init for Ralink RT2880 solution
  *
- *  Copyright 2007 Ralink Inc. (bruce_chang@ralinktech.com.tw)
- *
- *  This program is free software; you can redistribute  it and/or modify it
- *  under  the terms of  the GNU General  Public License as published by the
- *  Free Software Foundation;  either version 2 of the  License, or (at your
- *  option) any later version.
- *
- *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
- *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
- *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
- *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
- *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
- *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
- *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
- *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * Copyright 2007 Ralink Inc. (bruce_chang@ralinktech.com.tw)
  *
- *  You should have received a copy of the  GNU General Public License along
- *  with this program; if not, write  to the Free Software Foundation, Inc.,
- *  675 Mass Ave, Cambridge, MA 02139, USA.
- *
- *
- **************************************************************************
  * May 2007 Bruce Chang
  * Initial Release
  *
@@ -36,8 +13,6 @@
  *
  * May 2011 Bruce Chang
  * support RT6855/MT7620 PCIe
- *
- **************************************************************************
  */
 
 #include <linux/bitops.h>

commit ed611974bd2200404947dba26a2069bca2c7166f
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Sun Nov 4 11:49:31 2018 +0100

    staging: mt7621-pci: remove [ASSERT|DEASSERT]_SYSRST_PCIE macros
    
    Driver is using reset_control kernel API's to manage this so this
    two macros are not needed anymore. Remove them.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/mt7621-pci/pci-mt7621.c b/drivers/staging/mt7621-pci/pci-mt7621.c
index 9be5ca109a1b..d94587e1e699 100644
--- a/drivers/staging/mt7621-pci/pci-mt7621.c
+++ b/drivers/staging/mt7621-pci/pci-mt7621.c
@@ -94,21 +94,6 @@
 #define RALINK_PCI_MM_MAP_BASE		0x60000000
 #define RALINK_PCI_IO_MAP_BASE		0x1e160000
 
-#define ASSERT_SYSRST_PCIE(val)		\
-	do {								\
-		if (rt_sysc_r32(SYSC_REG_CHIP_REV) == 0x00030101)	\
-			rt_sysc_m32(0, val, RALINK_RSTCTRL);		\
-		else							\
-			rt_sysc_m32(val, 0, RALINK_RSTCTRL);		\
-	} while (0)
-#define DEASSERT_SYSRST_PCIE(val)	\
-	do {								\
-		if (rt_sysc_r32(SYSC_REG_CHIP_REV) == 0x00030101)	\
-			rt_sysc_m32(val, 0, RALINK_RSTCTRL);		\
-		else							\
-			rt_sysc_m32(0, val, RALINK_RSTCTRL);		\
-	} while (0)
-
 #define RALINK_CLKCFG1			0x30
 #define RALINK_RSTCTRL			0x34
 #define RALINK_GPIOMODE			0x60

commit 745eeeac68d7834676f023e01b46e40d63f90fab
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Sun Nov 4 11:49:30 2018 +0100

    staging: mt7621-pci: factor out 'mt7621_pcie_enable_port' function
    
    Driver probe function is a mess and shall be refactored a lot. At first
    make use of assert and deassert control factoring out a new function
    called 'mt7621_pcie_enable_port'.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/mt7621-pci/pci-mt7621.c b/drivers/staging/mt7621-pci/pci-mt7621.c
index 04e82c30c2e0..9be5ca109a1b 100644
--- a/drivers/staging/mt7621-pci/pci-mt7621.c
+++ b/drivers/staging/mt7621-pci/pci-mt7621.c
@@ -480,6 +480,39 @@ static int mt7621_pcie_parse_dt(struct mt7621_pcie *pcie)
 	return 0;
 }
 
+static int mt7621_pcie_enable_port(struct mt7621_pcie_port *port)
+{
+	struct mt7621_pcie *pcie = port->pcie;
+	struct device *dev = pcie->dev;
+	u32 slot = port->slot;
+	u32 val = 0;
+	int err;
+
+	err = clk_prepare_enable(port->pcie_clk);
+	if (err) {
+		dev_err(dev, "failed to enable pcie%d clock\n", slot);
+		return err;
+	}
+
+	reset_control_assert(port->pcie_rst);
+	reset_control_deassert(port->pcie_rst);
+
+	if ((pcie_port_read(port, RALINK_PCI_STATUS) & 0x1) == 0) {
+		dev_err(dev, "pcie%d no card, disable it (RST & CLK)\n", slot);
+		reset_control_assert(port->pcie_rst);
+		rt_sysc_m32(BIT(24 + slot), 0, RALINK_CLKCFG1);
+		pcie_link_status &= ~(1 << slot);
+	} else {
+		pcie_link_status |= BIT(slot);
+		val = pcie_read(pcie, RALINK_PCI_PCIMSK_ADDR);
+		/* enable pcie interrupt */
+		val |= BIT(20 + slot);
+		pcie_write(pcie, val, RALINK_PCI_PCIMSK_ADDR);
+	}
+
+	return 0;
+}
+
 static int mt7621_pcie_request_resources(struct mt7621_pcie *pcie,
 					 struct list_head *res)
 {
@@ -518,6 +551,7 @@ static int mt7621_pci_probe(struct platform_device *pdev)
 	struct device *dev = &pdev->dev;
 	struct mt7621_pcie *pcie;
 	struct pci_host_bridge *bridge;
+	struct mt7621_pcie_port *port, *tmp;
 	int err;
 	u32 val = 0;
 	LIST_HEAD(res);
@@ -546,12 +580,6 @@ static int mt7621_pci_probe(struct platform_device *pdev)
 	ioport_resource.start = 0;
 	ioport_resource.end = ~0UL; /* no limit */
 
-	val = RALINK_PCIE0_RST;
-	val |= RALINK_PCIE1_RST;
-	val |= RALINK_PCIE2_RST;
-
-	ASSERT_SYSRST_PCIE(RALINK_PCIE0_RST | RALINK_PCIE1_RST | RALINK_PCIE2_RST);
-
 	*(unsigned int *)(0xbe000060) &= ~(0x3 << 10 | 0x3 << 3);
 	*(unsigned int *)(0xbe000060) |=  BIT(10) | BIT(3);
 	mdelay(100);
@@ -561,11 +589,13 @@ static int mt7621_pci_probe(struct platform_device *pdev)
 
 	mdelay(100);
 
-	val = RALINK_PCIE0_RST;
-	val |= RALINK_PCIE1_RST;
-	val |= RALINK_PCIE2_RST;
-
-	DEASSERT_SYSRST_PCIE(val);
+	list_for_each_entry_safe(port, tmp, &pcie->ports, list) {
+		err = mt7621_pcie_enable_port(port);
+		if (err) {
+			dev_err(dev, "enabling port %d failed\n", port->slot);
+			list_del(&port->list);
+		}
+	}
 
 	if ((*(unsigned int *)(0xbe00000c) & 0xFFFF) == 0x0101) // MT7621 E2
 		bypass_pipe_rst(pcie);
@@ -591,42 +621,6 @@ static int mt7621_pci_probe(struct platform_device *pdev)
 	*(unsigned int *)(0xbe000620) |= BIT(19) | BIT(8) | BIT(7);		// set DATA
 	mdelay(1000);
 
-	if ((pcie_read(pcie, RT6855_PCIE0_OFFSET + RALINK_PCI_STATUS) & 0x1) == 0) {
-		printk("PCIE0 no card, disable it(RST&CLK)\n");
-		ASSERT_SYSRST_PCIE(RALINK_PCIE0_RST);
-		rt_sysc_m32(RALINK_PCIE0_CLK_EN, 0, RALINK_CLKCFG1);
-		pcie_link_status &= ~(BIT(0));
-	} else {
-		pcie_link_status |=  BIT(0);
-		val = pcie_read(pcie, RALINK_PCI_PCIMSK_ADDR);
-		val |= BIT(20); // enable pcie1 interrupt
-		pcie_write(pcie, val, RALINK_PCI_PCIMSK_ADDR);
-	}
-
-	if ((pcie_read(pcie, RT6855_PCIE1_OFFSET + RALINK_PCI_STATUS) & 0x1) == 0) {
-		printk("PCIE1 no card, disable it(RST&CLK)\n");
-		ASSERT_SYSRST_PCIE(RALINK_PCIE1_RST);
-		rt_sysc_m32(RALINK_PCIE1_CLK_EN, 0, RALINK_CLKCFG1);
-		pcie_link_status &= ~(BIT(1));
-	} else {
-		pcie_link_status |= BIT(1);
-		val = pcie_read(pcie, RALINK_PCI_PCIMSK_ADDR);
-		val |= BIT(21); // enable pcie1 interrupt
-		pcie_write(pcie, val, RALINK_PCI_PCIMSK_ADDR);
-	}
-
-	if ((pcie_read(pcie, RT6855_PCIE2_OFFSET + RALINK_PCI_STATUS) & 0x1) == 0) {
-		printk("PCIE2 no card, disable it(RST&CLK)\n");
-		ASSERT_SYSRST_PCIE(RALINK_PCIE2_RST);
-		rt_sysc_m32(RALINK_PCIE2_CLK_EN, 0, RALINK_CLKCFG1);
-		pcie_link_status &= ~(BIT(2));
-	} else {
-		pcie_link_status |=  BIT(2);
-		val = pcie_read(pcie, RALINK_PCI_PCIMSK_ADDR);
-		val |= BIT(22); // enable pcie2 interrupt
-		pcie_write(pcie, val, RALINK_PCI_PCIMSK_ADDR);
-	}
-
 	if (pcie_link_status == 0)
 		return 0;
 

commit c8242bef7c02c5fe16cb2d2b7e16f998a64b1604
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Sun Nov 4 11:49:29 2018 +0100

    staging: mt7621-pci: add two helpers for read and write pcie register ports
    
    mt7621-pcie_port data structure has filed 'base' as the base address for
    read and write related port registers. Create two inline functions
    'pcie_port_read' and 'pcie_port_write' to make this task easier and
    code more readable.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/mt7621-pci/pci-mt7621.c b/drivers/staging/mt7621-pci/pci-mt7621.c
index 357bbddb02ad..04e82c30c2e0 100644
--- a/drivers/staging/mt7621-pci/pci-mt7621.c
+++ b/drivers/staging/mt7621-pci/pci-mt7621.c
@@ -175,6 +175,17 @@ static inline void pcie_write(struct mt7621_pcie *pcie, u32 val, u32 reg)
 	writel(val, pcie->base + reg);
 }
 
+static inline u32 pcie_port_read(struct mt7621_pcie_port *port, u32 reg)
+{
+	return readl(port->base + reg);
+}
+
+static inline void pcie_port_write(struct mt7621_pcie_port *port,
+				   u32 val, u32 reg)
+{
+	writel(val, port->base + reg);
+}
+
 static inline u32 mt7621_pci_get_cfgaddr(unsigned int bus, unsigned int slot,
 					 unsigned int func, unsigned int where)
 {

commit a80775d647d3f9b3e25081ca49cc2311a78b7419
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Sun Nov 4 11:49:28 2018 +0100

    staging: mt7621-pci: replace return value if devm_pci_alloc_host_bridge call fails
    
    Driver probe function calls 'devm_pci_alloc_host_bridge'. If this call fails
    it is returning -ENODEV. Return -ENOMEM instead which is more accurate for
    this.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/mt7621-pci/pci-mt7621.c b/drivers/staging/mt7621-pci/pci-mt7621.c
index b7cb2733a9ea..357bbddb02ad 100644
--- a/drivers/staging/mt7621-pci/pci-mt7621.c
+++ b/drivers/staging/mt7621-pci/pci-mt7621.c
@@ -516,7 +516,7 @@ static int mt7621_pci_probe(struct platform_device *pdev)
 
 	bridge = devm_pci_alloc_host_bridge(dev, sizeof(*pcie));
 	if (!bridge)
-		return -ENODEV;
+		return -ENOMEM;
 
 	pcie = pci_host_bridge_priv(bridge);
 	pcie->dev = dev;

commit ad9c87e129d139129958d5f97d108a21ec8628e9
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Sun Nov 4 11:49:27 2018 +0100

    staging: mt7621-pci: parse and init port data from device tree
    
    Add initialization of each PCIe port reading and initializing
    data using device tree.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/mt7621-pci/pci-mt7621.c b/drivers/staging/mt7621-pci/pci-mt7621.c
index 8371a9cdb164..b7cb2733a9ea 100644
--- a/drivers/staging/mt7621-pci/pci-mt7621.c
+++ b/drivers/staging/mt7621-pci/pci-mt7621.c
@@ -126,16 +126,20 @@ static int pcie_link_status;
 
 /**
  * struct mt7621_pcie_port - PCIe port information
- * @base: IO mapped register base
+ * @base: I/O mapped register base
  * @list: port list
  * @pcie: pointer to PCIe host info
- * @reset: pointer to port reset control
+ * @pcie_rst: pointer to port reset control
+ * @pcie_clk: PCIe clock
+ * @slot: port slot
  */
 struct mt7621_pcie_port {
 	void __iomem *base;
 	struct list_head list;
 	struct mt7621_pcie *pcie;
-	struct reset_control *reset;
+	struct reset_control *pcie_rst;
+	struct clk *pcie_clk;
+	u32 slot;
 };
 
 /**
@@ -382,10 +386,57 @@ static int mt7621_pci_parse_request_of_pci_ranges(struct mt7621_pcie *pcie)
 	return 0;
 }
 
+static int mt7621_pcie_parse_port(struct mt7621_pcie *pcie,
+				  struct device_node *node,
+				  int slot)
+{
+	struct mt7621_pcie_port *port;
+	struct device *dev = pcie->dev;
+	struct device_node *pnode = dev->of_node;
+	struct resource regs;
+	char name[6];
+	int err;
+
+	port = devm_kzalloc(dev, sizeof(*port), GFP_KERNEL);
+	if (!port)
+		return -ENOMEM;
+
+	err = of_address_to_resource(pnode, slot + 1, &regs);
+	if (err) {
+		dev_err(dev, "missing \"reg\" property\n");
+		return err;
+	}
+
+	port->base = devm_ioremap_resource(dev, &regs);
+	if (IS_ERR(port->base))
+		return PTR_ERR(port->base);
+
+	snprintf(name, sizeof(name), "pcie%d", slot);
+	port->pcie_clk = devm_clk_get(dev, name);
+	if (IS_ERR(port->pcie_clk)) {
+		dev_err(dev, "failed to get pcie%d clock\n", slot);
+		return PTR_ERR(port->pcie_clk);
+	}
+
+	port->pcie_rst = devm_reset_control_get_exclusive(dev, name);
+	if (PTR_ERR(port->pcie_rst) == -EPROBE_DEFER) {
+		dev_err(dev, "failed to get pcie%d reset control\n", slot);
+		return PTR_ERR(port->pcie_rst);
+	}
+
+	port->slot = slot;
+	port->pcie = pcie;
+
+	INIT_LIST_HEAD(&port->list);
+	list_add_tail(&port->list, &pcie->ports);
+
+	return 0;
+}
+
 static int mt7621_pcie_parse_dt(struct mt7621_pcie *pcie)
 {
 	struct device *dev = pcie->dev;
-	struct device_node *node = dev->of_node;
+	struct device_node *node = dev->of_node, *child;
 	struct resource regs;
 	int err;
 
@@ -399,6 +450,22 @@ static int mt7621_pcie_parse_dt(struct mt7621_pcie *pcie)
 	if (IS_ERR(pcie->base))
 		return PTR_ERR(pcie->base);
 
+	for_each_available_child_of_node(node, child) {
+		int slot;
+
+		err = of_pci_get_devfn(child);
+		if (err < 0) {
+			dev_err(dev, "failed to parse devfn: %d\n", err);
+			return err;
+		}
+
+		slot = PCI_SLOT(err);
+
+		err = mt7621_pcie_parse_port(pcie, child, slot);
+		if (err)
+			return err;
+	}
+
 	return 0;
 }
 

commit 984e165b8a4b7170d945bd1d7f26df895411adda
Author: Mamta Shukla <mamtashukla555@gmail.com>
Date:   Fri Oct 5 13:02:06 2018 +0530

    staging: mt7621-pci: Prefer using the BIT macro
    
    Replace all occurrences of (1<<x) with BIT(x).
    
    Signed-off-by: Mamta Shukla <mamtashukla555@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/mt7621-pci/pci-mt7621.c b/drivers/staging/mt7621-pci/pci-mt7621.c
index 31b448d6449a..8371a9cdb164 100644
--- a/drivers/staging/mt7621-pci/pci-mt7621.c
+++ b/drivers/staging/mt7621-pci/pci-mt7621.c
@@ -475,11 +475,11 @@ static int mt7621_pci_probe(struct platform_device *pdev)
 	ASSERT_SYSRST_PCIE(RALINK_PCIE0_RST | RALINK_PCIE1_RST | RALINK_PCIE2_RST);
 
 	*(unsigned int *)(0xbe000060) &= ~(0x3 << 10 | 0x3 << 3);
-	*(unsigned int *)(0xbe000060) |= 0x1 << 10 | 0x1 << 3;
+	*(unsigned int *)(0xbe000060) |=  BIT(10) | BIT(3);
 	mdelay(100);
-	*(unsigned int *)(0xbe000600) |= 0x1 << 19 | 0x1 << 8 | 0x1 << 7; // use GPIO19/GPIO8/GPIO7 (PERST_N/UART_RXD3/UART_TXD3)
+	*(unsigned int *)(0xbe000600) |= BIT(19) | BIT(8) | BIT(7); // use GPIO19/GPIO8/GPIO7 (PERST_N/UART_RXD3/UART_TXD3)
 	mdelay(100);
-	*(unsigned int *)(0xbe000620) &= ~(0x1 << 19 | 0x1 << 8 | 0x1 << 7);		// clear DATA
+	*(unsigned int *)(0xbe000620) &= ~(BIT(19) | BIT(8) | BIT(7));		// clear DATA
 
 	mdelay(100);
 
@@ -510,18 +510,18 @@ static int mt7621_pci_probe(struct platform_device *pdev)
 	rt_sysc_m32(RALINK_PCIE_RST, 0, RALINK_RSTCTRL);
 
 	/* Use GPIO control instead of PERST_N */
-	*(unsigned int *)(0xbe000620) |= 0x1 << 19 | 0x1 << 8 | 0x1 << 7;		// set DATA
+	*(unsigned int *)(0xbe000620) |= BIT(19) | BIT(8) | BIT(7);		// set DATA
 	mdelay(1000);
 
 	if ((pcie_read(pcie, RT6855_PCIE0_OFFSET + RALINK_PCI_STATUS) & 0x1) == 0) {
 		printk("PCIE0 no card, disable it(RST&CLK)\n");
 		ASSERT_SYSRST_PCIE(RALINK_PCIE0_RST);
 		rt_sysc_m32(RALINK_PCIE0_CLK_EN, 0, RALINK_CLKCFG1);
-		pcie_link_status &= ~(1 << 0);
+		pcie_link_status &= ~(BIT(0));
 	} else {
-		pcie_link_status |= 1 << 0;
+		pcie_link_status |=  BIT(0);
 		val = pcie_read(pcie, RALINK_PCI_PCIMSK_ADDR);
-		val |= (1 << 20); // enable pcie1 interrupt
+		val |= BIT(20); // enable pcie1 interrupt
 		pcie_write(pcie, val, RALINK_PCI_PCIMSK_ADDR);
 	}
 
@@ -529,11 +529,11 @@ static int mt7621_pci_probe(struct platform_device *pdev)
 		printk("PCIE1 no card, disable it(RST&CLK)\n");
 		ASSERT_SYSRST_PCIE(RALINK_PCIE1_RST);
 		rt_sysc_m32(RALINK_PCIE1_CLK_EN, 0, RALINK_CLKCFG1);
-		pcie_link_status &= ~(1 << 1);
+		pcie_link_status &= ~(BIT(1));
 	} else {
-		pcie_link_status |= 1 << 1;
+		pcie_link_status |= BIT(1);
 		val = pcie_read(pcie, RALINK_PCI_PCIMSK_ADDR);
-		val |= (1 << 21); // enable pcie1 interrupt
+		val |= BIT(21); // enable pcie1 interrupt
 		pcie_write(pcie, val, RALINK_PCI_PCIMSK_ADDR);
 	}
 
@@ -541,11 +541,11 @@ static int mt7621_pci_probe(struct platform_device *pdev)
 		printk("PCIE2 no card, disable it(RST&CLK)\n");
 		ASSERT_SYSRST_PCIE(RALINK_PCIE2_RST);
 		rt_sysc_m32(RALINK_PCIE2_CLK_EN, 0, RALINK_CLKCFG1);
-		pcie_link_status &= ~(1 << 2);
+		pcie_link_status &= ~(BIT(2));
 	} else {
-		pcie_link_status |= 1 << 2;
+		pcie_link_status |=  BIT(2);
 		val = pcie_read(pcie, RALINK_PCI_PCIMSK_ADDR);
-		val |= (1 << 22); // enable pcie2 interrupt
+		val |= BIT(22); // enable pcie2 interrupt
 		pcie_write(pcie, val, RALINK_PCI_PCIMSK_ADDR);
 	}
 

commit 5cfa4f700771b4252dd08935b8d0e69a4325d22b
Author: Mamta Shukla <mamtashukla555@gmail.com>
Date:   Fri Oct 5 12:58:08 2018 +0530

    staging: mt7621-pci: Add spaces around '<<'
    
    Add spaces around '<<' to fix checkpatch issue.
    CHECK: spaces preferred around that '<<' (ctx:VxV)
    
    Signed-off-by: Mamta Shukla <mamtashukla555@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/mt7621-pci/pci-mt7621.c b/drivers/staging/mt7621-pci/pci-mt7621.c
index 780ba56a3d61..31b448d6449a 100644
--- a/drivers/staging/mt7621-pci/pci-mt7621.c
+++ b/drivers/staging/mt7621-pci/pci-mt7621.c
@@ -474,12 +474,12 @@ static int mt7621_pci_probe(struct platform_device *pdev)
 
 	ASSERT_SYSRST_PCIE(RALINK_PCIE0_RST | RALINK_PCIE1_RST | RALINK_PCIE2_RST);
 
-	*(unsigned int *)(0xbe000060) &= ~(0x3<<10 | 0x3<<3);
-	*(unsigned int *)(0xbe000060) |= 0x1<<10 | 0x1<<3;
+	*(unsigned int *)(0xbe000060) &= ~(0x3 << 10 | 0x3 << 3);
+	*(unsigned int *)(0xbe000060) |= 0x1 << 10 | 0x1 << 3;
 	mdelay(100);
-	*(unsigned int *)(0xbe000600) |= 0x1<<19 | 0x1<<8 | 0x1<<7; // use GPIO19/GPIO8/GPIO7 (PERST_N/UART_RXD3/UART_TXD3)
+	*(unsigned int *)(0xbe000600) |= 0x1 << 19 | 0x1 << 8 | 0x1 << 7; // use GPIO19/GPIO8/GPIO7 (PERST_N/UART_RXD3/UART_TXD3)
 	mdelay(100);
-	*(unsigned int *)(0xbe000620) &= ~(0x1<<19 | 0x1<<8 | 0x1<<7);		// clear DATA
+	*(unsigned int *)(0xbe000620) &= ~(0x1 << 19 | 0x1 << 8 | 0x1 << 7);		// clear DATA
 
 	mdelay(100);
 
@@ -510,18 +510,18 @@ static int mt7621_pci_probe(struct platform_device *pdev)
 	rt_sysc_m32(RALINK_PCIE_RST, 0, RALINK_RSTCTRL);
 
 	/* Use GPIO control instead of PERST_N */
-	*(unsigned int *)(0xbe000620) |= 0x1<<19 | 0x1<<8 | 0x1<<7;		// set DATA
+	*(unsigned int *)(0xbe000620) |= 0x1 << 19 | 0x1 << 8 | 0x1 << 7;		// set DATA
 	mdelay(1000);
 
 	if ((pcie_read(pcie, RT6855_PCIE0_OFFSET + RALINK_PCI_STATUS) & 0x1) == 0) {
 		printk("PCIE0 no card, disable it(RST&CLK)\n");
 		ASSERT_SYSRST_PCIE(RALINK_PCIE0_RST);
 		rt_sysc_m32(RALINK_PCIE0_CLK_EN, 0, RALINK_CLKCFG1);
-		pcie_link_status &= ~(1<<0);
+		pcie_link_status &= ~(1 << 0);
 	} else {
-		pcie_link_status |= 1<<0;
+		pcie_link_status |= 1 << 0;
 		val = pcie_read(pcie, RALINK_PCI_PCIMSK_ADDR);
-		val |= (1<<20); // enable pcie1 interrupt
+		val |= (1 << 20); // enable pcie1 interrupt
 		pcie_write(pcie, val, RALINK_PCI_PCIMSK_ADDR);
 	}
 
@@ -529,11 +529,11 @@ static int mt7621_pci_probe(struct platform_device *pdev)
 		printk("PCIE1 no card, disable it(RST&CLK)\n");
 		ASSERT_SYSRST_PCIE(RALINK_PCIE1_RST);
 		rt_sysc_m32(RALINK_PCIE1_CLK_EN, 0, RALINK_CLKCFG1);
-		pcie_link_status &= ~(1<<1);
+		pcie_link_status &= ~(1 << 1);
 	} else {
-		pcie_link_status |= 1<<1;
+		pcie_link_status |= 1 << 1;
 		val = pcie_read(pcie, RALINK_PCI_PCIMSK_ADDR);
-		val |= (1<<21); // enable pcie1 interrupt
+		val |= (1 << 21); // enable pcie1 interrupt
 		pcie_write(pcie, val, RALINK_PCI_PCIMSK_ADDR);
 	}
 
@@ -541,11 +541,11 @@ static int mt7621_pci_probe(struct platform_device *pdev)
 		printk("PCIE2 no card, disable it(RST&CLK)\n");
 		ASSERT_SYSRST_PCIE(RALINK_PCIE2_RST);
 		rt_sysc_m32(RALINK_PCIE2_CLK_EN, 0, RALINK_CLKCFG1);
-		pcie_link_status &= ~(1<<2);
+		pcie_link_status &= ~(1 << 2);
 	} else {
-		pcie_link_status |= 1<<2;
+		pcie_link_status |= 1 << 2;
 		val = pcie_read(pcie, RALINK_PCI_PCIMSK_ADDR);
-		val |= (1<<22); // enable pcie2 interrupt
+		val |= (1 << 22); // enable pcie2 interrupt
 		pcie_write(pcie, val, RALINK_PCI_PCIMSK_ADDR);
 	}
 
@@ -646,8 +646,8 @@ pcie(2/1/0) link status	pcie2_num	pcie1_num	pcie0_num
 		val = read_config(pcie, 2, 0x4);
 		write_config(pcie, 2, 0x4, val | 0x4);
 		val = read_config(pcie, 2, 0x70c);
-		val &= ~(0xff)<<8;
-		val |= 0x50<<8;
+		val &= ~(0xff) << 8;
+		val |= 0x50 << 8;
 		write_config(pcie, 2, 0x70c, val);
 	case 3:
 	case 5:
@@ -655,15 +655,15 @@ pcie(2/1/0) link status	pcie2_num	pcie1_num	pcie0_num
 		val = read_config(pcie, 1, 0x4);
 		write_config(pcie, 1, 0x4, val | 0x4);
 		val = read_config(pcie, 1, 0x70c);
-		val &= ~(0xff)<<8;
-		val |= 0x50<<8;
+		val &= ~(0xff) << 8;
+		val |= 0x50 << 8;
 		write_config(pcie, 1, 0x70c, val);
 	default:
 		val = read_config(pcie, 0, 0x4);
 		write_config(pcie, 0, 0x4, val | 0x4); //bus master enable
 		val = read_config(pcie, 0, 0x70c);
-		val &= ~(0xff)<<8;
-		val |= 0x50<<8;
+		val &= ~(0xff) << 8;
+		val |= 0x50 << 8;
 		write_config(pcie, 0, 0x70c, val);
 	}
 

commit 0c5ca367ad4160864de3accc4d1ca8f1a47b2f0e
Author: Mamta Shukla <mamtashukla555@gmail.com>
Date:   Fri Oct 5 12:53:34 2018 +0530

    staging: mt7621-pci: Add spaces around '|'
    
    Add spaces around '|' to fix checkpatch issue
    CHECK: spaces preferred around that '|' (ctx:VxV)
    
    Signed-off-by: Mamta Shukla <mamtashukla555@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/mt7621-pci/pci-mt7621.c b/drivers/staging/mt7621-pci/pci-mt7621.c
index 14aac0844351..780ba56a3d61 100644
--- a/drivers/staging/mt7621-pci/pci-mt7621.c
+++ b/drivers/staging/mt7621-pci/pci-mt7621.c
@@ -644,7 +644,7 @@ pcie(2/1/0) link status	pcie2_num	pcie1_num	pcie0_num
 	switch (pcie_link_status) {
 	case 7:
 		val = read_config(pcie, 2, 0x4);
-		write_config(pcie, 2, 0x4, val|0x4);
+		write_config(pcie, 2, 0x4, val | 0x4);
 		val = read_config(pcie, 2, 0x70c);
 		val &= ~(0xff)<<8;
 		val |= 0x50<<8;
@@ -653,14 +653,14 @@ pcie(2/1/0) link status	pcie2_num	pcie1_num	pcie0_num
 	case 5:
 	case 6:
 		val = read_config(pcie, 1, 0x4);
-		write_config(pcie, 1, 0x4, val|0x4);
+		write_config(pcie, 1, 0x4, val | 0x4);
 		val = read_config(pcie, 1, 0x70c);
 		val &= ~(0xff)<<8;
 		val |= 0x50<<8;
 		write_config(pcie, 1, 0x70c, val);
 	default:
 		val = read_config(pcie, 0, 0x4);
-		write_config(pcie, 0, 0x4, val|0x4); //bus master enable
+		write_config(pcie, 0, 0x4, val | 0x4); //bus master enable
 		val = read_config(pcie, 0, 0x70c);
 		val &= ~(0xff)<<8;
 		val |= 0x50<<8;

commit 8f36481fbb00f70546a63018543519130187fa4e
Author: Mamta Shukla <mamtashukla555@gmail.com>
Date:   Fri Oct 5 12:51:41 2018 +0530

    staging: mt7621-pci: Add spaces around '&'
    
    Add spaces around '&' to fix checkpatch issue.
    CHECK: spaces preferred around that '&' (ctx:VxV)
    
    Signed-off-by: Mamta Shukla <mamtashukla555@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/mt7621-pci/pci-mt7621.c b/drivers/staging/mt7621-pci/pci-mt7621.c
index 3182d8a21010..14aac0844351 100644
--- a/drivers/staging/mt7621-pci/pci-mt7621.c
+++ b/drivers/staging/mt7621-pci/pci-mt7621.c
@@ -489,7 +489,7 @@ static int mt7621_pci_probe(struct platform_device *pdev)
 
 	DEASSERT_SYSRST_PCIE(val);
 
-	if ((*(unsigned int *)(0xbe00000c)&0xFFFF) == 0x0101) // MT7621 E2
+	if ((*(unsigned int *)(0xbe00000c) & 0xFFFF) == 0x0101) // MT7621 E2
 		bypass_pipe_rst(pcie);
 	set_phy_for_ssc(pcie);
 

commit 101c82f23957d5772553787fdffa292aa3195bbd
Author: Mamta Shukla <mamtashukla555@gmail.com>
Date:   Fri Oct 5 12:49:38 2018 +0530

    staging: mt7621-pci: Do not initialise statics to 0
    
    Remove initialisation for static global variable to fix checkpatch issue.
    ERROR: do not initialise statics to 0
    
    Signed-off-by: Mamta Shukla <mamtashukla555@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/mt7621-pci/pci-mt7621.c b/drivers/staging/mt7621-pci/pci-mt7621.c
index ba1f117a47ce..3182d8a21010 100644
--- a/drivers/staging/mt7621-pci/pci-mt7621.c
+++ b/drivers/staging/mt7621-pci/pci-mt7621.c
@@ -122,7 +122,7 @@
 #define RALINK_PCIE_CLK_EN		BIT(21)
 
 #define MEMORY_BASE 0x0
-static int pcie_link_status = 0;
+static int pcie_link_status;
 
 /**
  * struct mt7621_pcie_port - PCIe port information

commit 7e33f3850c53e10704990f21a160705474f72f43
Author: Rob Herring <robh@kernel.org>
Date:   Wed Aug 29 13:34:03 2018 -0500

    staging: mt7621-pci: remove unnecessary check of device_type == pci
    
    PCI host drivers have already matched on compatible strings, so checking
    device_type is redundant. Also, device_type is considered deprecated for
    FDT though we've still been requiring it for PCI hosts as it is useful
    for finding PCI buses.
    
    Cc: devel@driverdev.osuosl.org
    Signed-off-by: Rob Herring <robh@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/mt7621-pci/pci-mt7621.c b/drivers/staging/mt7621-pci/pci-mt7621.c
index df2d522abac4..ba1f117a47ce 100644
--- a/drivers/staging/mt7621-pci/pci-mt7621.c
+++ b/drivers/staging/mt7621-pci/pci-mt7621.c
@@ -387,15 +387,8 @@ static int mt7621_pcie_parse_dt(struct mt7621_pcie *pcie)
 	struct device *dev = pcie->dev;
 	struct device_node *node = dev->of_node;
 	struct resource regs;
-	const char *type;
 	int err;
 
-	type = of_get_property(node, "device_type", NULL);
-	if (!type || strcmp(type, "pci") != 0) {
-		dev_err(dev, "invalid \"device_type\" %s\n", type);
-		return -EINVAL;
-	}
-
 	err = of_address_to_resource(node, 0, &regs);
 	if (err) {
 		dev_err(dev, "missing \"reg\" property\n");

commit 293dcd6592a29eec392312246f2b158195d700d6
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Fri Aug 10 18:58:46 2018 +0200

    staging: mt7621-pci: show N_FTS status using a loop
    
    There are some printk's which can be replaced properly
    using dev_* kernel functions. Use dev_info to show
    N_FTS status for each port using a loop instead of duplicating
    lines of code.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/mt7621-pci/pci-mt7621.c b/drivers/staging/mt7621-pci/pci-mt7621.c
index e904adc3b8c9..df2d522abac4 100644
--- a/drivers/staging/mt7621-pci/pci-mt7621.c
+++ b/drivers/staging/mt7621-pci/pci-mt7621.c
@@ -500,14 +500,11 @@ static int mt7621_pci_probe(struct platform_device *pdev)
 		bypass_pipe_rst(pcie);
 	set_phy_for_ssc(pcie);
 
-	val = read_config(pcie, 0, 0x70c);
-	printk("Port 0 N_FTS = %x\n", (unsigned int)val);
-
-	val = read_config(pcie, 1, 0x70c);
-	printk("Port 1 N_FTS = %x\n", (unsigned int)val);
-
-	val = read_config(pcie, 2, 0x70c);
-	printk("Port 2 N_FTS = %x\n", (unsigned int)val);
+	list_for_each_entry_safe(port, tmp, &pcie->ports, list) {
+		u32 slot = port->slot;
+		val = read_config(pcie, slot, 0x70c);
+		dev_info(dev, "Port %d N_FTS = %x\n", (unsigned int)val, slot);
+	}
 
 	rt_sysc_m32(0, RALINK_PCIE_RST, RALINK_RSTCTRL);
 	rt_sysc_m32(0x30, 2 << 4, SYSC_REG_SYSTEM_CONFIG1);

commit 02d72eef1814ea05e2613e5ab6136d8393f8a682
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Fri Aug 10 18:58:45 2018 +0200

    staging: mt7621-pci: make some function static
    
    There are some functions in driver code that can be declared
    'static'. Just do it.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/mt7621-pci/pci-mt7621.c b/drivers/staging/mt7621-pci/pci-mt7621.c
index a49e2795af6b..e904adc3b8c9 100644
--- a/drivers/staging/mt7621-pci/pci-mt7621.c
+++ b/drivers/staging/mt7621-pci/pci-mt7621.c
@@ -214,7 +214,7 @@ write_config(struct mt7621_pcie *pcie, unsigned int dev, u32 reg, u32 val)
 	pcie_write(pcie, val, RALINK_PCI_CONFIG_DATA);
 }
 
-void
+static void
 set_pcie_phy(struct mt7621_pcie *pcie, u32 offset,
 	     int start_b, int bits, int val)
 {
@@ -225,7 +225,7 @@ set_pcie_phy(struct mt7621_pcie *pcie, u32 offset,
 	pcie_write(pcie, reg, offset);
 }
 
-void
+static void
 bypass_pipe_rst(struct mt7621_pcie *pcie)
 {
 	/* PCIe Port 0 */
@@ -239,7 +239,7 @@ bypass_pipe_rst(struct mt7621_pcie *pcie)
 	set_pcie_phy(pcie, (RALINK_PCIEPHY_P2_CTL_OFFSET + 0x02c),  4, 1, 0x01);	// rg_pe1_pipe_cmd_frc[4]
 }
 
-void
+static void
 set_phy_for_ssc(struct mt7621_pcie *pcie)
 {
 	unsigned long reg = rt_sysc_r32(SYSC_REG_SYSTEM_CONFIG0);

commit 4cafd03a916e2f7c15520fed0b7894cf25f4ecc5
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Fri Aug 3 10:27:07 2018 +0200

    staging: mt7621-pci: remove remaining pci_legacy dependant code
    
    pcibios_* remaining code is not neccessary at all. We can use
    map_irq set to of_irq_parse_and_map_pci driver 'probe' function.
    Remove this code.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Tested-by: NeilBrown <neil@brown.name>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/mt7621-pci/pci-mt7621.c b/drivers/staging/mt7621-pci/pci-mt7621.c
index dd1a72890caf..a49e2795af6b 100644
--- a/drivers/staging/mt7621-pci/pci-mt7621.c
+++ b/drivers/staging/mt7621-pci/pci-mt7621.c
@@ -214,32 +214,6 @@ write_config(struct mt7621_pcie *pcie, unsigned int dev, u32 reg, u32 val)
 	pcie_write(pcie, val, RALINK_PCI_CONFIG_DATA);
 }
 
-int
-pcibios_map_irq(const struct pci_dev *dev, u8 slot, u8 pin)
-{
-	struct mt7621_pcie *pcie = dev->bus->sysdata;
-	u16 cmd;
-	u32 val;
-	int irq;
-
-	if (dev->bus->number == 0) {
-		write_config(pcie, slot, PCI_BASE_ADDRESS_0, MEMORY_BASE);
-		val = read_config(pcie, slot, PCI_BASE_ADDRESS_0);
-		printk("BAR0 at slot %d = %x\n", slot, val);
-	}
-
-	pci_write_config_byte(dev, PCI_CACHE_LINE_SIZE, 0x14);  //configure cache line size 0x14
-	pci_write_config_byte(dev, PCI_LATENCY_TIMER, 0xFF);  //configure latency timer 0x10
-	pci_read_config_word(dev, PCI_COMMAND, &cmd);
-	cmd = cmd | PCI_COMMAND_MASTER | PCI_COMMAND_IO | PCI_COMMAND_MEMORY;
-	pci_write_config_word(dev, PCI_COMMAND, cmd);
-
-	irq = of_irq_parse_and_map_pci(dev, slot, pin);
-
-	pci_write_config_byte(dev, PCI_INTERRUPT_LINE, irq);
-	return irq;
-}
-
 void
 set_pcie_phy(struct mt7621_pcie *pcie, u32 offset,
 	     int start_b, int bits, int val)
@@ -461,7 +435,7 @@ static int mt7621_pcie_register_host(struct pci_host_bridge *host,
 	host->busnr = pcie->busn.start;
 	host->dev.parent = pcie->dev;
 	host->ops = &mt7621_pci_ops;
-	host->map_irq = pcibios_map_irq;
+	host->map_irq = of_irq_parse_and_map_pci;
 	host->swizzle_irq = pci_common_swizzle;
 	host->sysdata = pcie;
 
@@ -726,11 +700,6 @@ pcie(2/1/0) link status	pcie2_num	pcie1_num	pcie0_num
 	return 0;
 }
 
-int pcibios_plat_dev_init(struct pci_dev *dev)
-{
-	return 0;
-}
-
 static const struct of_device_id mt7621_pci_ids[] = {
 	{ .compatible = "mediatek,mt7621-pci" },
 	{},

commit 8594351af0f9e065885a6bbcb5248736e8a5612a
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Fri Aug 3 10:27:06 2018 +0200

    staging: mt7621-pci: rename RALINK_PCI_CONFIG_DATA_VIRTUAL_REG definition
    
    RALINK_PCI_CONFIG_DATA_VIRTUAL_REG is a very long name. Make it a bit
    shorter renaming it to RALINK_PCI_CONFIG_DATA.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Tested-by: NeilBrown <neil@brown.name>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/mt7621-pci/pci-mt7621.c b/drivers/staging/mt7621-pci/pci-mt7621.c
index c288b26db16d..dd1a72890caf 100644
--- a/drivers/staging/mt7621-pci/pci-mt7621.c
+++ b/drivers/staging/mt7621-pci/pci-mt7621.c
@@ -67,7 +67,7 @@
 #define RALINK_PCIE2_CLK_EN		BIT(26)
 
 #define RALINK_PCI_CONFIG_ADDR		0x20
-#define RALINK_PCI_CONFIG_DATA_VIRTUAL_REG	0x24
+#define RALINK_PCI_CONFIG_DATA		0x24
 #define RALINK_PCI_MEMBASE		0x28
 #define RALINK_PCI_IOBASE		0x2C
 #define RALINK_PCIE0_RST		BIT(24)
@@ -187,7 +187,7 @@ static void __iomem *mt7621_pcie_map_bus(struct pci_bus *bus,
 
 	writel(address, pcie->base + RALINK_PCI_CONFIG_ADDR);
 
-	return pcie->base + RALINK_PCI_CONFIG_DATA_VIRTUAL_REG + (where & 3);
+	return pcie->base + RALINK_PCI_CONFIG_DATA + (where & 3);
 }
 
 struct pci_ops mt7621_pci_ops = {
@@ -202,7 +202,7 @@ read_config(struct mt7621_pcie *pcie, unsigned int dev, u32 reg)
 	u32 address = mt7621_pci_get_cfgaddr(0, dev, 0, reg);
 
 	pcie_write(pcie, address, RALINK_PCI_CONFIG_ADDR);
-	return pcie_read(pcie, RALINK_PCI_CONFIG_DATA_VIRTUAL_REG);
+	return pcie_read(pcie, RALINK_PCI_CONFIG_DATA);
 }
 
 static void
@@ -211,7 +211,7 @@ write_config(struct mt7621_pcie *pcie, unsigned int dev, u32 reg, u32 val)
 	u32 address = mt7621_pci_get_cfgaddr(0, dev, 0, reg);
 
 	pcie_write(pcie, address, RALINK_PCI_CONFIG_ADDR);
-	pcie_write(pcie, val, RALINK_PCI_CONFIG_DATA_VIRTUAL_REG);
+	pcie_write(pcie, val, RALINK_PCI_CONFIG_DATA);
 }
 
 int

commit 88e8fa0c26ba400ac15fad9cf6461f746ddb3aca
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Fri Aug 3 10:27:05 2018 +0200

    staging: mt7621-pci: use BIT macro in preprocessor definitions
    
    Some preprocessor definitions are using a custom implementation of
    BIT macro. Just use linux kernel BIT macro instead.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Tested-by: NeilBrown <neil@brown.name>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/mt7621-pci/pci-mt7621.c b/drivers/staging/mt7621-pci/pci-mt7621.c
index 972a8024a1ae..c288b26db16d 100644
--- a/drivers/staging/mt7621-pci/pci-mt7621.c
+++ b/drivers/staging/mt7621-pci/pci-mt7621.c
@@ -62,17 +62,17 @@
  * devices.
  */
 
-#define RALINK_PCIE0_CLK_EN		(1<<24)
-#define RALINK_PCIE1_CLK_EN		(1<<25)
-#define RALINK_PCIE2_CLK_EN		(1<<26)
+#define RALINK_PCIE0_CLK_EN		BIT(24)
+#define RALINK_PCIE1_CLK_EN		BIT(25)
+#define RALINK_PCIE2_CLK_EN		BIT(26)
 
 #define RALINK_PCI_CONFIG_ADDR		0x20
 #define RALINK_PCI_CONFIG_DATA_VIRTUAL_REG	0x24
 #define RALINK_PCI_MEMBASE		0x28
 #define RALINK_PCI_IOBASE		0x2C
-#define RALINK_PCIE0_RST		(1<<24)
-#define RALINK_PCIE1_RST		(1<<25)
-#define RALINK_PCIE2_RST		(1<<26)
+#define RALINK_PCIE0_RST		BIT(24)
+#define RALINK_PCIE1_RST		BIT(25)
+#define RALINK_PCIE2_RST		BIT(26)
 
 #define RALINK_PCI_PCICFG_ADDR		0x0000
 #define RALINK_PCI_PCIMSK_ADDR		0x000C
@@ -115,11 +115,11 @@
 #define RALINK_PCIE_CLK_GEN		0x7c
 #define RALINK_PCIE_CLK_GEN1		0x80
 //RALINK_RSTCTRL bit
-#define RALINK_PCIE_RST			(1<<23)
-#define RALINK_PCI_RST			(1<<24)
+#define RALINK_PCIE_RST			BIT(23)
+#define RALINK_PCI_RST			BIT(24)
 //RALINK_CLKCFG1 bit
-#define RALINK_PCI_CLK_EN		(1<<19)
-#define RALINK_PCIE_CLK_EN		(1<<21)
+#define RALINK_PCI_CLK_EN		BIT(19)
+#define RALINK_PCIE_CLK_EN		BIT(21)
 
 #define MEMORY_BASE 0x0
 static int pcie_link_status = 0;

commit c00f0352bed0ff03d193a56387eb421e04d9415b
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Fri Aug 3 10:27:04 2018 +0200

    staging: mt7621-pci: remove RALINK_PCI_BASE from remaining definitions
    
    RALINK_PCI_BASE has no sense and this driver has base address readed
    and mapped from device tree. Remove remaining uses of it and
    change code to use pcie_read and pcie_write functions in places
    where this was being used.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Tested-by: NeilBrown <neil@brown.name>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/mt7621-pci/pci-mt7621.c b/drivers/staging/mt7621-pci/pci-mt7621.c
index 1a301e834455..972a8024a1ae 100644
--- a/drivers/staging/mt7621-pci/pci-mt7621.c
+++ b/drivers/staging/mt7621-pci/pci-mt7621.c
@@ -76,7 +76,6 @@
 
 #define RALINK_PCI_PCICFG_ADDR		0x0000
 #define RALINK_PCI_PCIMSK_ADDR		0x000C
-#define RALINK_PCI_BASE	0xBE140000
 
 #define RT6855_PCIE0_OFFSET		0x2000
 #define RT6855_PCIE1_OFFSET		0x3000
@@ -89,8 +88,8 @@
 #define RALINK_PCI_SUBID		0x0038
 #define RALINK_PCI_STATUS		0x0050
 
-#define RALINK_PCIEPHY_P0P1_CTL_OFFSET	(RALINK_PCI_BASE + 0x9000)
-#define RALINK_PCIEPHY_P2_CTL_OFFSET	(RALINK_PCI_BASE + 0xA000)
+#define RALINK_PCIEPHY_P0P1_CTL_OFFSET	0x9000
+#define RALINK_PCIEPHY_P2_CTL_OFFSET	0xA000
 
 #define RALINK_PCI_MM_MAP_BASE		0x60000000
 #define RALINK_PCI_IO_MAP_BASE		0x1e160000
@@ -242,105 +241,109 @@ pcibios_map_irq(const struct pci_dev *dev, u8 slot, u8 pin)
 }
 
 void
-set_pcie_phy(u32 *addr, int start_b, int bits, int val)
+set_pcie_phy(struct mt7621_pcie *pcie, u32 offset,
+	     int start_b, int bits, int val)
 {
-	*(unsigned int *)(addr) &= ~(((1<<bits) - 1)<<start_b);
-	*(unsigned int *)(addr) |= val << start_b;
+	u32 reg = pcie_read(pcie, offset);
+
+	reg &= ~(((1 << bits) - 1) << start_b);
+	reg |= val << start_b;
+	pcie_write(pcie, reg, offset);
 }
 
 void
-bypass_pipe_rst(void)
+bypass_pipe_rst(struct mt7621_pcie *pcie)
 {
 	/* PCIe Port 0 */
-	set_pcie_phy((u32 *)(RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x02c), 12, 1, 0x01);	// rg_pe1_pipe_rst_b
-	set_pcie_phy((u32 *)(RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x02c),  4, 1, 0x01);	// rg_pe1_pipe_cmd_frc[4]
+	set_pcie_phy(pcie, (RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x02c), 12, 1, 0x01);	// rg_pe1_pipe_rst_b
+	set_pcie_phy(pcie, (RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x02c),  4, 1, 0x01);	// rg_pe1_pipe_cmd_frc[4]
 	/* PCIe Port 1 */
-	set_pcie_phy((u32 *)(RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x12c), 12, 1, 0x01);	// rg_pe1_pipe_rst_b
-	set_pcie_phy((u32 *)(RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x12c),  4, 1, 0x01);	// rg_pe1_pipe_cmd_frc[4]
+	set_pcie_phy(pcie, (RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x12c), 12, 1, 0x01);	// rg_pe1_pipe_rst_b
+	set_pcie_phy(pcie, (RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x12c),  4, 1, 0x01);	// rg_pe1_pipe_cmd_frc[4]
 	/* PCIe Port 2 */
-	set_pcie_phy((u32 *)(RALINK_PCIEPHY_P2_CTL_OFFSET + 0x02c), 12, 1, 0x01);	// rg_pe1_pipe_rst_b
-	set_pcie_phy((u32 *)(RALINK_PCIEPHY_P2_CTL_OFFSET + 0x02c),  4, 1, 0x01);	// rg_pe1_pipe_cmd_frc[4]
+	set_pcie_phy(pcie, (RALINK_PCIEPHY_P2_CTL_OFFSET + 0x02c), 12, 1, 0x01);	// rg_pe1_pipe_rst_b
+	set_pcie_phy(pcie, (RALINK_PCIEPHY_P2_CTL_OFFSET + 0x02c),  4, 1, 0x01);	// rg_pe1_pipe_cmd_frc[4]
 }
 
 void
-set_phy_for_ssc(void)
+set_phy_for_ssc(struct mt7621_pcie *pcie)
 {
 	unsigned long reg = rt_sysc_r32(SYSC_REG_SYSTEM_CONFIG0);
 
 	reg = (reg >> 6) & 0x7;
 	/* Set PCIe Port0 & Port1 PHY to disable SSC */
 	/* Debug Xtal Type */
-	set_pcie_phy((u32 *)(RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x400),  8, 1, 0x01);	// rg_pe1_frc_h_xtal_type
-	set_pcie_phy((u32 *)(RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x400),  9, 2, 0x00);	// rg_pe1_h_xtal_type
-	set_pcie_phy((u32 *)(RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x000),  4, 1, 0x01);	// rg_pe1_frc_phy_en	//Force Port 0 enable control
-	set_pcie_phy((u32 *)(RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x100),  4, 1, 0x01);	// rg_pe1_frc_phy_en	//Force Port 1 enable control
-	set_pcie_phy((u32 *)(RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x000),  5, 1, 0x00);	// rg_pe1_phy_en	//Port 0 disable
-	set_pcie_phy((u32 *)(RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x100),  5, 1, 0x00);	// rg_pe1_phy_en	//Port 1 disable
+	set_pcie_phy(pcie, (RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x400),  8, 1, 0x01);	// rg_pe1_frc_h_xtal_type
+	set_pcie_phy(pcie, (RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x400),  9, 2, 0x00);	// rg_pe1_h_xtal_type
+	set_pcie_phy(pcie, (RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x000),  4, 1, 0x01);	// rg_pe1_frc_phy_en	//Force Port 0 enable control
+	set_pcie_phy(pcie, (RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x100),  4, 1, 0x01);	// rg_pe1_frc_phy_en	//Force Port 1 enable control
+	set_pcie_phy(pcie, (RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x000),  5, 1, 0x00);	// rg_pe1_phy_en	//Port 0 disable
+	set_pcie_phy(pcie, (RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x100),  5, 1, 0x00);	// rg_pe1_phy_en	//Port 1 disable
 	if (reg <= 5 && reg >= 3) {	// 40MHz Xtal
-		set_pcie_phy((u32 *)(RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x490),  6, 2, 0x01);	// RG_PE1_H_PLL_PREDIV	//Pre-divider ratio (for host mode)
+		set_pcie_phy(pcie, (RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x490),  6, 2, 0x01);	// RG_PE1_H_PLL_PREDIV	//Pre-divider ratio (for host mode)
 		printk("***** Xtal 40MHz *****\n");
 	} else {			// 25MHz | 20MHz Xtal
-		set_pcie_phy((u32 *)(RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x490),  6, 2, 0x00);	// RG_PE1_H_PLL_PREDIV	//Pre-divider ratio (for host mode)
+		set_pcie_phy(pcie, (RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x490),  6, 2, 0x00);	// RG_PE1_H_PLL_PREDIV	//Pre-divider ratio (for host mode)
 		if (reg >= 6) {
 			printk("***** Xtal 25MHz *****\n");
-			set_pcie_phy((u32 *)(RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x4bc),  4, 2, 0x01);	// RG_PE1_H_PLL_FBKSEL	//Feedback clock select
-			set_pcie_phy((u32 *)(RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x49c),  0, 31, 0x18000000);	// RG_PE1_H_LCDDS_PCW_NCPO	//DDS NCPO PCW (for host mode)
-			set_pcie_phy((u32 *)(RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x4a4),  0, 16, 0x18d);	// RG_PE1_H_LCDDS_SSC_PRD	//DDS SSC dither period control
-			set_pcie_phy((u32 *)(RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x4a8),  0, 12, 0x4a);	// RG_PE1_H_LCDDS_SSC_DELTA	//DDS SSC dither amplitude control
-			set_pcie_phy((u32 *)(RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x4a8), 16, 12, 0x4a);	// RG_PE1_H_LCDDS_SSC_DELTA1	//DDS SSC dither amplitude control for initial
+			set_pcie_phy(pcie, (RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x4bc),  4, 2, 0x01);	// RG_PE1_H_PLL_FBKSEL	//Feedback clock select
+			set_pcie_phy(pcie, (RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x49c),  0, 31, 0x18000000);	// RG_PE1_H_LCDDS_PCW_NCPO	//DDS NCPO PCW (for host mode)
+			set_pcie_phy(pcie, (RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x4a4),  0, 16, 0x18d);	// RG_PE1_H_LCDDS_SSC_PRD	//DDS SSC dither period control
+			set_pcie_phy(pcie, (RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x4a8),  0, 12, 0x4a);	// RG_PE1_H_LCDDS_SSC_DELTA	//DDS SSC dither amplitude control
+			set_pcie_phy(pcie, (RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x4a8), 16, 12, 0x4a);	// RG_PE1_H_LCDDS_SSC_DELTA1	//DDS SSC dither amplitude control for initial
 		} else {
 			printk("***** Xtal 20MHz *****\n");
 		}
 	}
-	set_pcie_phy((u32 *)(RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x4a0),  5, 1, 0x01);	// RG_PE1_LCDDS_CLK_PH_INV	//DDS clock inversion
-	set_pcie_phy((u32 *)(RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x490), 22, 2, 0x02);	// RG_PE1_H_PLL_BC
-	set_pcie_phy((u32 *)(RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x490), 18, 4, 0x06);	// RG_PE1_H_PLL_BP
-	set_pcie_phy((u32 *)(RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x490), 12, 4, 0x02);	// RG_PE1_H_PLL_IR
-	set_pcie_phy((u32 *)(RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x490),  8, 4, 0x01);	// RG_PE1_H_PLL_IC
-	set_pcie_phy((u32 *)(RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x4ac), 16, 3, 0x00);	// RG_PE1_H_PLL_BR
-	set_pcie_phy((u32 *)(RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x490),  1, 3, 0x02);	// RG_PE1_PLL_DIVEN
+	set_pcie_phy(pcie, (RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x4a0),  5, 1, 0x01);	// RG_PE1_LCDDS_CLK_PH_INV	//DDS clock inversion
+	set_pcie_phy(pcie, (RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x490), 22, 2, 0x02);	// RG_PE1_H_PLL_BC
+	set_pcie_phy(pcie, (RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x490), 18, 4, 0x06);	// RG_PE1_H_PLL_BP
+	set_pcie_phy(pcie, (RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x490), 12, 4, 0x02);	// RG_PE1_H_PLL_IR
+	set_pcie_phy(pcie, (RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x490),  8, 4, 0x01);	// RG_PE1_H_PLL_IC
+	set_pcie_phy(pcie, (RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x4ac), 16, 3, 0x00);	// RG_PE1_H_PLL_BR
+	set_pcie_phy(pcie, (RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x490),  1, 3, 0x02);	// RG_PE1_PLL_DIVEN
 	if (reg <= 5 && reg >= 3) {	// 40MHz Xtal
-		set_pcie_phy((u32 *)(RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x414),  6, 2, 0x01);	// rg_pe1_mstckdiv		//value of da_pe1_mstckdiv when force mode enable
-		set_pcie_phy((u32 *)(RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x414),  5, 1, 0x01);	// rg_pe1_frc_mstckdiv	//force mode enable of da_pe1_mstckdiv
+		set_pcie_phy(pcie, (RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x414),  6, 2, 0x01);	// rg_pe1_mstckdiv		//value of da_pe1_mstckdiv when force mode enable
+		set_pcie_phy(pcie, (RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x414),  5, 1, 0x01);	// rg_pe1_frc_mstckdiv	//force mode enable of da_pe1_mstckdiv
 	}
 	/* Enable PHY and disable force mode */
-	set_pcie_phy((u32 *)(RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x000),  5, 1, 0x01);	// rg_pe1_phy_en	//Port 0 enable
-	set_pcie_phy((u32 *)(RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x100),  5, 1, 0x01);	// rg_pe1_phy_en	//Port 1 enable
-	set_pcie_phy((u32 *)(RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x000),  4, 1, 0x00);	// rg_pe1_frc_phy_en	//Force Port 0 disable control
-	set_pcie_phy((u32 *)(RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x100),  4, 1, 0x00);	// rg_pe1_frc_phy_en	//Force Port 1 disable control
+	set_pcie_phy(pcie, (RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x000),  5, 1, 0x01);	// rg_pe1_phy_en	//Port 0 enable
+	set_pcie_phy(pcie, (RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x100),  5, 1, 0x01);	// rg_pe1_phy_en	//Port 1 enable
+	set_pcie_phy(pcie, (RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x000),  4, 1, 0x00);	// rg_pe1_frc_phy_en	//Force Port 0 disable control
+	set_pcie_phy(pcie, (RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x100),  4, 1, 0x00);	// rg_pe1_frc_phy_en	//Force Port 1 disable control
 
 	/* Set PCIe Port2 PHY to disable SSC */
 	/* Debug Xtal Type */
-	set_pcie_phy((u32 *)(RALINK_PCIEPHY_P2_CTL_OFFSET + 0x400),  8, 1, 0x01);	// rg_pe1_frc_h_xtal_type
-	set_pcie_phy((u32 *)(RALINK_PCIEPHY_P2_CTL_OFFSET + 0x400),  9, 2, 0x00);	// rg_pe1_h_xtal_type
-	set_pcie_phy((u32 *)(RALINK_PCIEPHY_P2_CTL_OFFSET + 0x000),  4, 1, 0x01);	// rg_pe1_frc_phy_en	//Force Port 0 enable control
-	set_pcie_phy((u32 *)(RALINK_PCIEPHY_P2_CTL_OFFSET + 0x000),  5, 1, 0x00);	// rg_pe1_phy_en	//Port 0 disable
+	set_pcie_phy(pcie, (RALINK_PCIEPHY_P2_CTL_OFFSET + 0x400),  8, 1, 0x01);	// rg_pe1_frc_h_xtal_type
+	set_pcie_phy(pcie, (RALINK_PCIEPHY_P2_CTL_OFFSET + 0x400),  9, 2, 0x00);	// rg_pe1_h_xtal_type
+	set_pcie_phy(pcie, (RALINK_PCIEPHY_P2_CTL_OFFSET + 0x000),  4, 1, 0x01);	// rg_pe1_frc_phy_en	//Force Port 0 enable control
+	set_pcie_phy(pcie, (RALINK_PCIEPHY_P2_CTL_OFFSET + 0x000),  5, 1, 0x00);	// rg_pe1_phy_en	//Port 0 disable
 	if (reg <= 5 && reg >= 3) {	// 40MHz Xtal
-		set_pcie_phy((u32 *)(RALINK_PCIEPHY_P2_CTL_OFFSET + 0x490),  6, 2, 0x01);	// RG_PE1_H_PLL_PREDIV	//Pre-divider ratio (for host mode)
+		set_pcie_phy(pcie, (RALINK_PCIEPHY_P2_CTL_OFFSET + 0x490),  6, 2, 0x01);	// RG_PE1_H_PLL_PREDIV	//Pre-divider ratio (for host mode)
 	} else {			// 25MHz | 20MHz Xtal
-		set_pcie_phy((u32 *)(RALINK_PCIEPHY_P2_CTL_OFFSET + 0x490),  6, 2, 0x00);	// RG_PE1_H_PLL_PREDIV	//Pre-divider ratio (for host mode)
+		set_pcie_phy(pcie, (RALINK_PCIEPHY_P2_CTL_OFFSET + 0x490),  6, 2, 0x00);	// RG_PE1_H_PLL_PREDIV	//Pre-divider ratio (for host mode)
 		if (reg >= 6) {		// 25MHz Xtal
-			set_pcie_phy((u32 *)(RALINK_PCIEPHY_P2_CTL_OFFSET + 0x4bc),  4, 2, 0x01);	// RG_PE1_H_PLL_FBKSEL	//Feedback clock select
-			set_pcie_phy((u32 *)(RALINK_PCIEPHY_P2_CTL_OFFSET + 0x49c),  0, 31, 0x18000000);	// RG_PE1_H_LCDDS_PCW_NCPO	//DDS NCPO PCW (for host mode)
-			set_pcie_phy((u32 *)(RALINK_PCIEPHY_P2_CTL_OFFSET + 0x4a4),  0, 16, 0x18d);	// RG_PE1_H_LCDDS_SSC_PRD	//DDS SSC dither period control
-			set_pcie_phy((u32 *)(RALINK_PCIEPHY_P2_CTL_OFFSET + 0x4a8),  0, 12, 0x4a);	// RG_PE1_H_LCDDS_SSC_DELTA	//DDS SSC dither amplitude control
-			set_pcie_phy((u32 *)(RALINK_PCIEPHY_P2_CTL_OFFSET + 0x4a8), 16, 12, 0x4a);	// RG_PE1_H_LCDDS_SSC_DELTA1	//DDS SSC dither amplitude control for initial
+			set_pcie_phy(pcie, (RALINK_PCIEPHY_P2_CTL_OFFSET + 0x4bc),  4, 2, 0x01);	// RG_PE1_H_PLL_FBKSEL	//Feedback clock select
+			set_pcie_phy(pcie, (RALINK_PCIEPHY_P2_CTL_OFFSET + 0x49c),  0, 31, 0x18000000);	// RG_PE1_H_LCDDS_PCW_NCPO	//DDS NCPO PCW (for host mode)
+			set_pcie_phy(pcie, (RALINK_PCIEPHY_P2_CTL_OFFSET + 0x4a4),  0, 16, 0x18d);	// RG_PE1_H_LCDDS_SSC_PRD	//DDS SSC dither period control
+			set_pcie_phy(pcie, (RALINK_PCIEPHY_P2_CTL_OFFSET + 0x4a8),  0, 12, 0x4a);	// RG_PE1_H_LCDDS_SSC_DELTA	//DDS SSC dither amplitude control
+			set_pcie_phy(pcie, (RALINK_PCIEPHY_P2_CTL_OFFSET + 0x4a8), 16, 12, 0x4a);	// RG_PE1_H_LCDDS_SSC_DELTA1	//DDS SSC dither amplitude control for initial
 		}
 	}
-	set_pcie_phy((u32 *)(RALINK_PCIEPHY_P2_CTL_OFFSET + 0x4a0),  5, 1, 0x01);	// RG_PE1_LCDDS_CLK_PH_INV	//DDS clock inversion
-	set_pcie_phy((u32 *)(RALINK_PCIEPHY_P2_CTL_OFFSET + 0x490), 22, 2, 0x02);	// RG_PE1_H_PLL_BC
-	set_pcie_phy((u32 *)(RALINK_PCIEPHY_P2_CTL_OFFSET + 0x490), 18, 4, 0x06);	// RG_PE1_H_PLL_BP
-	set_pcie_phy((u32 *)(RALINK_PCIEPHY_P2_CTL_OFFSET + 0x490), 12, 4, 0x02);	// RG_PE1_H_PLL_IR
-	set_pcie_phy((u32 *)(RALINK_PCIEPHY_P2_CTL_OFFSET + 0x490),  8, 4, 0x01);	// RG_PE1_H_PLL_IC
-	set_pcie_phy((u32 *)(RALINK_PCIEPHY_P2_CTL_OFFSET + 0x4ac), 16, 3, 0x00);	// RG_PE1_H_PLL_BR
-	set_pcie_phy((u32 *)(RALINK_PCIEPHY_P2_CTL_OFFSET + 0x490),  1, 3, 0x02);	// RG_PE1_PLL_DIVEN
+	set_pcie_phy(pcie, (RALINK_PCIEPHY_P2_CTL_OFFSET + 0x4a0),  5, 1, 0x01);	// RG_PE1_LCDDS_CLK_PH_INV	//DDS clock inversion
+	set_pcie_phy(pcie, (RALINK_PCIEPHY_P2_CTL_OFFSET + 0x490), 22, 2, 0x02);	// RG_PE1_H_PLL_BC
+	set_pcie_phy(pcie, (RALINK_PCIEPHY_P2_CTL_OFFSET + 0x490), 18, 4, 0x06);	// RG_PE1_H_PLL_BP
+	set_pcie_phy(pcie, (RALINK_PCIEPHY_P2_CTL_OFFSET + 0x490), 12, 4, 0x02);	// RG_PE1_H_PLL_IR
+	set_pcie_phy(pcie, (RALINK_PCIEPHY_P2_CTL_OFFSET + 0x490),  8, 4, 0x01);	// RG_PE1_H_PLL_IC
+	set_pcie_phy(pcie, (RALINK_PCIEPHY_P2_CTL_OFFSET + 0x4ac), 16, 3, 0x00);	// RG_PE1_H_PLL_BR
+	set_pcie_phy(pcie, (RALINK_PCIEPHY_P2_CTL_OFFSET + 0x490),  1, 3, 0x02);	// RG_PE1_PLL_DIVEN
 	if (reg <= 5 && reg >= 3) {	// 40MHz Xtal
-		set_pcie_phy((u32 *)(RALINK_PCIEPHY_P2_CTL_OFFSET + 0x414),  6, 2, 0x01);	// rg_pe1_mstckdiv		//value of da_pe1_mstckdiv when force mode enable
-		set_pcie_phy((u32 *)(RALINK_PCIEPHY_P2_CTL_OFFSET + 0x414),  5, 1, 0x01);	// rg_pe1_frc_mstckdiv	//force mode enable of da_pe1_mstckdiv
+		set_pcie_phy(pcie, (RALINK_PCIEPHY_P2_CTL_OFFSET + 0x414),  6, 2, 0x01);	// rg_pe1_mstckdiv		//value of da_pe1_mstckdiv when force mode enable
+		set_pcie_phy(pcie, (RALINK_PCIEPHY_P2_CTL_OFFSET + 0x414),  5, 1, 0x01);	// rg_pe1_frc_mstckdiv	//force mode enable of da_pe1_mstckdiv
 	}
 	/* Enable PHY and disable force mode */
-	set_pcie_phy((u32 *)(RALINK_PCIEPHY_P2_CTL_OFFSET + 0x000),  5, 1, 0x01);	// rg_pe1_phy_en	//Port 0 enable
-	set_pcie_phy((u32 *)(RALINK_PCIEPHY_P2_CTL_OFFSET + 0x000),  4, 1, 0x00);	// rg_pe1_frc_phy_en	//Force Port 0 disable control
+	set_pcie_phy(pcie, (RALINK_PCIEPHY_P2_CTL_OFFSET + 0x000),  5, 1, 0x01);	// rg_pe1_phy_en	//Port 0 enable
+	set_pcie_phy(pcie, (RALINK_PCIEPHY_P2_CTL_OFFSET + 0x000),  4, 1, 0x00);	// rg_pe1_frc_phy_en	//Force Port 0 disable control
 }
 
 static void setup_cm_memory_region(struct resource *mem_resource)
@@ -520,8 +523,8 @@ static int mt7621_pci_probe(struct platform_device *pdev)
 	DEASSERT_SYSRST_PCIE(val);
 
 	if ((*(unsigned int *)(0xbe00000c)&0xFFFF) == 0x0101) // MT7621 E2
-		bypass_pipe_rst();
-	set_phy_for_ssc();
+		bypass_pipe_rst(pcie);
+	set_phy_for_ssc(pcie);
 
 	val = read_config(pcie, 0, 0x70c);
 	printk("Port 0 N_FTS = %x\n", (unsigned int)val);

commit 152f3893f4bdcbf2202c08d376b837b62f54a7e4
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Fri Aug 3 10:27:03 2018 +0200

    staging: mt7621-pci: use pcie_[read|write] in RALINK_PCI_PCICFG_ADDR and RALINK_PCI_PCIMSK_ADDR
    
    RALINK_PCI_PCICFG_ADDR and RALINK_PCI_PCIMSK_ADDR are defined to be directly
    referenced for read and write. Use pcie_read and pcie_write instead changing
    its definition to a simple relative offset to pcie base address.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Tested-by: NeilBrown <neil@brown.name>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/mt7621-pci/pci-mt7621.c b/drivers/staging/mt7621-pci/pci-mt7621.c
index 4a20138fb91a..1a301e834455 100644
--- a/drivers/staging/mt7621-pci/pci-mt7621.c
+++ b/drivers/staging/mt7621-pci/pci-mt7621.c
@@ -74,8 +74,8 @@
 #define RALINK_PCIE1_RST		(1<<25)
 #define RALINK_PCIE2_RST		(1<<26)
 
-#define RALINK_PCI_PCICFG_ADDR		*(volatile u32 *)(RALINK_PCI_BASE + 0x0000)
-#define RALINK_PCI_PCIMSK_ADDR		*(volatile u32 *)(RALINK_PCI_BASE + 0x000C)
+#define RALINK_PCI_PCICFG_ADDR		0x0000
+#define RALINK_PCI_PCIMSK_ADDR		0x000C
 #define RALINK_PCI_BASE	0xBE140000
 
 #define RT6855_PCIE0_OFFSET		0x2000
@@ -553,7 +553,9 @@ static int mt7621_pci_probe(struct platform_device *pdev)
 		pcie_link_status &= ~(1<<0);
 	} else {
 		pcie_link_status |= 1<<0;
-		RALINK_PCI_PCIMSK_ADDR |= (1<<20); // enable pcie1 interrupt
+		val = pcie_read(pcie, RALINK_PCI_PCIMSK_ADDR);
+		val |= (1<<20); // enable pcie1 interrupt
+		pcie_write(pcie, val, RALINK_PCI_PCIMSK_ADDR);
 	}
 
 	if ((pcie_read(pcie, RT6855_PCIE1_OFFSET + RALINK_PCI_STATUS) & 0x1) == 0) {
@@ -563,7 +565,9 @@ static int mt7621_pci_probe(struct platform_device *pdev)
 		pcie_link_status &= ~(1<<1);
 	} else {
 		pcie_link_status |= 1<<1;
-		RALINK_PCI_PCIMSK_ADDR |= (1<<21); // enable pcie1 interrupt
+		val = pcie_read(pcie, RALINK_PCI_PCIMSK_ADDR);
+		val |= (1<<21); // enable pcie1 interrupt
+		pcie_write(pcie, val, RALINK_PCI_PCIMSK_ADDR);
 	}
 
 	if ((pcie_read(pcie, RT6855_PCIE2_OFFSET + RALINK_PCI_STATUS) & 0x1) == 0) {
@@ -573,7 +577,9 @@ static int mt7621_pci_probe(struct platform_device *pdev)
 		pcie_link_status &= ~(1<<2);
 	} else {
 		pcie_link_status |= 1<<2;
-		RALINK_PCI_PCIMSK_ADDR |= (1<<22); // enable pcie2 interrupt
+		val = pcie_read(pcie, RALINK_PCI_PCIMSK_ADDR);
+		val |= (1<<22); // enable pcie2 interrupt
+		pcie_write(pcie, val, RALINK_PCI_PCIMSK_ADDR);
 	}
 
 	if (pcie_link_status == 0)
@@ -592,27 +598,35 @@ pcie(2/1/0) link status	pcie2_num	pcie1_num	pcie0_num
 */
 	switch (pcie_link_status) {
 	case 2:
-		RALINK_PCI_PCICFG_ADDR &= ~0x00ff0000;
-		RALINK_PCI_PCICFG_ADDR |= 0x1 << 16;	//port0
-		RALINK_PCI_PCICFG_ADDR |= 0x0 << 20;	//port1
+		val = pcie_read(pcie, RALINK_PCI_PCICFG_ADDR);
+		val &= ~0x00ff0000;
+		val |= 0x1 << 16;	// port 0
+		val |= 0x0 << 20;	// port 1
+		pcie_write(pcie, val, RALINK_PCI_PCICFG_ADDR);
 		break;
 	case 4:
-		RALINK_PCI_PCICFG_ADDR &= ~0x0fff0000;
-		RALINK_PCI_PCICFG_ADDR |= 0x1 << 16;	//port0
-		RALINK_PCI_PCICFG_ADDR |= 0x2 << 20;	//port1
-		RALINK_PCI_PCICFG_ADDR |= 0x0 << 24;	//port2
+		val = pcie_read(pcie, RALINK_PCI_PCICFG_ADDR);
+		val &= ~0x0fff0000;
+		val |= 0x1 << 16;	//port0
+		val |= 0x2 << 20;	//port1
+		val |= 0x0 << 24;	//port2
+		pcie_write(pcie, val, RALINK_PCI_PCICFG_ADDR);
 		break;
 	case 5:
-		RALINK_PCI_PCICFG_ADDR &= ~0x0fff0000;
-		RALINK_PCI_PCICFG_ADDR |= 0x0 << 16;	//port0
-		RALINK_PCI_PCICFG_ADDR |= 0x2 << 20;	//port1
-		RALINK_PCI_PCICFG_ADDR |= 0x1 << 24;	//port2
+		val = pcie_read(pcie, RALINK_PCI_PCICFG_ADDR);
+		val &= ~0x0fff0000;
+		val |= 0x0 << 16;	//port0
+		val |= 0x2 << 20;	//port1
+		val |= 0x1 << 24;	//port2
+		pcie_write(pcie, val, RALINK_PCI_PCICFG_ADDR);
 		break;
 	case 6:
-		RALINK_PCI_PCICFG_ADDR &= ~0x0fff0000;
-		RALINK_PCI_PCICFG_ADDR |= 0x2 << 16;	//port0
-		RALINK_PCI_PCICFG_ADDR |= 0x0 << 20;	//port1
-		RALINK_PCI_PCICFG_ADDR |= 0x1 << 24;	//port2
+		val = pcie_read(pcie, RALINK_PCI_PCICFG_ADDR);
+		val &= ~0x0fff0000;
+		val |= 0x2 << 16;	//port0
+		val |= 0x0 << 20;	//port1
+		val |= 0x1 << 24;	//port2
+		pcie_write(pcie, val, RALINK_PCI_PCICFG_ADDR);
 		break;
 	}
 

commit cd7d07db8b83cfc88d4ee3a1d5f751cf6af58f13
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Fri Aug 3 10:27:02 2018 +0200

    staging: mt7621-pci: review includes putting them in alphabethic order
    
    There are some includes that are being used that are not really
    needed to correct driver compilation. Remove them and reorder the
    rest alphabetically.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Tested-by: NeilBrown <neil@brown.name>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/mt7621-pci/pci-mt7621.c b/drivers/staging/mt7621-pci/pci-mt7621.c
index e1245a4297dc..4a20138fb91a 100644
--- a/drivers/staging/mt7621-pci/pci-mt7621.c
+++ b/drivers/staging/mt7621-pci/pci-mt7621.c
@@ -40,26 +40,20 @@
  **************************************************************************
  */
 
-#include <linux/types.h>
-#include <linux/pci.h>
-#include <linux/kernel.h>
-#include <linux/slab.h>
-#include <linux/version.h>
-#include <linux/pci.h>
-#include <linux/io.h>
-#include <asm/mips-cm.h>
-#include <linux/init.h>
-#include <linux/module.h>
+#include <linux/bitops.h>
+#include <linux/clk.h>
 #include <linux/delay.h>
+#include <linux/module.h>
 #include <linux/of.h>
-#include <linux/of_pci.h>
-#include <linux/of_platform.h>
 #include <linux/of_address.h>
 #include <linux/of_irq.h>
+#include <linux/of_pci.h>
+#include <linux/of_platform.h>
+#include <linux/pci.h>
 #include <linux/platform_device.h>
-
-#include <ralink_regs.h>
+#include <linux/reset.h>
 #include <mt7621.h>
+#include <ralink_regs.h>
 
 #include "../../pci/pci.h"
 

commit e38bb1754003d9a0fba5b59f23c850615664cbe6
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Fri Aug 3 10:27:01 2018 +0200

    staging: mt7621-pci: avoid register duplication per controller using pcie_[read|write]
    
    Use pcie_[read|write] fucntions to read and write controller registers.
    Define those only by offset and pass controller offset + register offset
    relative to base address to functions.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Tested-by: NeilBrown <neil@brown.name>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/mt7621-pci/pci-mt7621.c b/drivers/staging/mt7621-pci/pci-mt7621.c
index 4200c68eb65e..e1245a4297dc 100644
--- a/drivers/staging/mt7621-pci/pci-mt7621.c
+++ b/drivers/staging/mt7621-pci/pci-mt7621.c
@@ -74,8 +74,8 @@
 
 #define RALINK_PCI_CONFIG_ADDR		0x20
 #define RALINK_PCI_CONFIG_DATA_VIRTUAL_REG	0x24
-#define RALINK_PCI_MEMBASE		*(volatile u32 *)(RALINK_PCI_BASE + 0x0028)
-#define RALINK_PCI_IOBASE		*(volatile u32 *)(RALINK_PCI_BASE + 0x002C)
+#define RALINK_PCI_MEMBASE		0x28
+#define RALINK_PCI_IOBASE		0x2C
 #define RALINK_PCIE0_RST		(1<<24)
 #define RALINK_PCIE1_RST		(1<<25)
 #define RALINK_PCIE2_RST		(1<<26)
@@ -88,26 +88,12 @@
 #define RT6855_PCIE1_OFFSET		0x3000
 #define RT6855_PCIE2_OFFSET		0x4000
 
-#define RALINK_PCI0_BAR0SETUP_ADDR	*(volatile u32 *)(RALINK_PCI_BASE + RT6855_PCIE0_OFFSET + 0x0010)
-#define RALINK_PCI0_IMBASEBAR0_ADDR	*(volatile u32 *)(RALINK_PCI_BASE + RT6855_PCIE0_OFFSET + 0x0018)
-#define RALINK_PCI0_ID			*(volatile u32 *)(RALINK_PCI_BASE + RT6855_PCIE0_OFFSET + 0x0030)
-#define RALINK_PCI0_CLASS		*(volatile u32 *)(RALINK_PCI_BASE + RT6855_PCIE0_OFFSET + 0x0034)
-#define RALINK_PCI0_SUBID		*(volatile u32 *)(RALINK_PCI_BASE + RT6855_PCIE0_OFFSET + 0x0038)
-#define RALINK_PCI0_STATUS		*(volatile u32 *)(RALINK_PCI_BASE + RT6855_PCIE0_OFFSET + 0x0050)
-
-#define RALINK_PCI1_BAR0SETUP_ADDR	*(volatile u32 *)(RALINK_PCI_BASE + RT6855_PCIE1_OFFSET + 0x0010)
-#define RALINK_PCI1_IMBASEBAR0_ADDR	*(volatile u32 *)(RALINK_PCI_BASE + RT6855_PCIE1_OFFSET + 0x0018)
-#define RALINK_PCI1_ID			*(volatile u32 *)(RALINK_PCI_BASE + RT6855_PCIE1_OFFSET + 0x0030)
-#define RALINK_PCI1_CLASS		*(volatile u32 *)(RALINK_PCI_BASE + RT6855_PCIE1_OFFSET + 0x0034)
-#define RALINK_PCI1_SUBID		*(volatile u32 *)(RALINK_PCI_BASE + RT6855_PCIE1_OFFSET + 0x0038)
-#define RALINK_PCI1_STATUS		*(volatile u32 *)(RALINK_PCI_BASE + RT6855_PCIE1_OFFSET + 0x0050)
-
-#define RALINK_PCI2_BAR0SETUP_ADDR	*(volatile u32 *)(RALINK_PCI_BASE + RT6855_PCIE2_OFFSET + 0x0010)
-#define RALINK_PCI2_IMBASEBAR0_ADDR	*(volatile u32 *)(RALINK_PCI_BASE + RT6855_PCIE2_OFFSET + 0x0018)
-#define RALINK_PCI2_ID			*(volatile u32 *)(RALINK_PCI_BASE + RT6855_PCIE2_OFFSET + 0x0030)
-#define RALINK_PCI2_CLASS		*(volatile u32 *)(RALINK_PCI_BASE + RT6855_PCIE2_OFFSET + 0x0034)
-#define RALINK_PCI2_SUBID		*(volatile u32 *)(RALINK_PCI_BASE + RT6855_PCIE2_OFFSET + 0x0038)
-#define RALINK_PCI2_STATUS		*(volatile u32 *)(RALINK_PCI_BASE + RT6855_PCIE2_OFFSET + 0x0050)
+#define RALINK_PCI_BAR0SETUP_ADDR	0x0010
+#define RALINK_PCI_IMBASEBAR0_ADDR	0x0018
+#define RALINK_PCI_ID			0x0030
+#define RALINK_PCI_CLASS		0x0034
+#define RALINK_PCI_SUBID		0x0038
+#define RALINK_PCI_STATUS		0x0050
 
 #define RALINK_PCIEPHY_P0P1_CTL_OFFSET	(RALINK_PCI_BASE + 0x9000)
 #define RALINK_PCIEPHY_P2_CTL_OFFSET	(RALINK_PCI_BASE + 0xA000)
@@ -566,7 +552,7 @@ static int mt7621_pci_probe(struct platform_device *pdev)
 	*(unsigned int *)(0xbe000620) |= 0x1<<19 | 0x1<<8 | 0x1<<7;		// set DATA
 	mdelay(1000);
 
-	if ((RALINK_PCI0_STATUS & 0x1) == 0) {
+	if ((pcie_read(pcie, RT6855_PCIE0_OFFSET + RALINK_PCI_STATUS) & 0x1) == 0) {
 		printk("PCIE0 no card, disable it(RST&CLK)\n");
 		ASSERT_SYSRST_PCIE(RALINK_PCIE0_RST);
 		rt_sysc_m32(RALINK_PCIE0_CLK_EN, 0, RALINK_CLKCFG1);
@@ -576,7 +562,7 @@ static int mt7621_pci_probe(struct platform_device *pdev)
 		RALINK_PCI_PCIMSK_ADDR |= (1<<20); // enable pcie1 interrupt
 	}
 
-	if ((RALINK_PCI1_STATUS & 0x1) == 0) {
+	if ((pcie_read(pcie, RT6855_PCIE1_OFFSET + RALINK_PCI_STATUS) & 0x1) == 0) {
 		printk("PCIE1 no card, disable it(RST&CLK)\n");
 		ASSERT_SYSRST_PCIE(RALINK_PCIE1_RST);
 		rt_sysc_m32(RALINK_PCIE1_CLK_EN, 0, RALINK_CLKCFG1);
@@ -586,7 +572,7 @@ static int mt7621_pci_probe(struct platform_device *pdev)
 		RALINK_PCI_PCIMSK_ADDR |= (1<<21); // enable pcie1 interrupt
 	}
 
-	if ((RALINK_PCI2_STATUS & 0x1) == 0) {
+	if ((pcie_read(pcie, RT6855_PCIE2_OFFSET + RALINK_PCI_STATUS) & 0x1) == 0) {
 		printk("PCIE2 no card, disable it(RST&CLK)\n");
 		ASSERT_SYSRST_PCIE(RALINK_PCIE2_RST);
 		rt_sysc_m32(RALINK_PCIE2_CLK_EN, 0, RALINK_CLKCFG1);
@@ -641,30 +627,42 @@ pcie(2/1/0) link status	pcie2_num	pcie1_num	pcie0_num
 	ioport_resource.end = mt7621_res_pci_io1.end;
 */
 
-	RALINK_PCI_MEMBASE = 0xffffffff; //RALINK_PCI_MM_MAP_BASE;
-	RALINK_PCI_IOBASE = RALINK_PCI_IO_MAP_BASE;
+	pcie_write(pcie, 0xffffffff, RALINK_PCI_MEMBASE);
+	pcie_write(pcie, RALINK_PCI_IO_MAP_BASE, RALINK_PCI_IOBASE);
 
 	//PCIe0
 	if ((pcie_link_status & 0x1) != 0) {
-		RALINK_PCI0_BAR0SETUP_ADDR = 0x7FFF0001;	//open 7FFF:2G; ENABLE
-		RALINK_PCI0_IMBASEBAR0_ADDR = MEMORY_BASE;
-		RALINK_PCI0_CLASS = 0x06040001;
+		/* open 7FFF:2G; ENABLE */
+		pcie_write(pcie, 0x7FFF0001,
+			   RT6855_PCIE0_OFFSET + RALINK_PCI_BAR0SETUP_ADDR);
+		pcie_write(pcie, MEMORY_BASE,
+			   RT6855_PCIE0_OFFSET + RALINK_PCI_IMBASEBAR0_ADDR);
+		pcie_write(pcie, 0x06040001,
+			   RT6855_PCIE0_OFFSET + RALINK_PCI_CLASS);
 		printk("PCIE0 enabled\n");
 	}
 
 	//PCIe1
 	if ((pcie_link_status & 0x2) != 0) {
-		RALINK_PCI1_BAR0SETUP_ADDR = 0x7FFF0001;	//open 7FFF:2G; ENABLE
-		RALINK_PCI1_IMBASEBAR0_ADDR = MEMORY_BASE;
-		RALINK_PCI1_CLASS = 0x06040001;
+		/* open 7FFF:2G; ENABLE */
+		pcie_write(pcie, 0x7FFF0001,
+			   RT6855_PCIE1_OFFSET + RALINK_PCI_BAR0SETUP_ADDR);
+		pcie_write(pcie, MEMORY_BASE,
+			   RT6855_PCIE1_OFFSET + RALINK_PCI_IMBASEBAR0_ADDR);
+		pcie_write(pcie, 0x06040001,
+			   RT6855_PCIE1_OFFSET + RALINK_PCI_CLASS);
 		printk("PCIE1 enabled\n");
 	}
 
 	//PCIe2
 	if ((pcie_link_status & 0x4) != 0) {
-		RALINK_PCI2_BAR0SETUP_ADDR = 0x7FFF0001;	//open 7FFF:2G; ENABLE
-		RALINK_PCI2_IMBASEBAR0_ADDR = MEMORY_BASE;
-		RALINK_PCI2_CLASS = 0x06040001;
+		/* open 7FFF:2G; ENABLE */
+		pcie_write(pcie, 0x7FFF0001,
+			   RT6855_PCIE2_OFFSET + RALINK_PCI_BAR0SETUP_ADDR);
+		pcie_write(pcie, MEMORY_BASE,
+			   RT6855_PCIE2_OFFSET + RALINK_PCI_IMBASEBAR0_ADDR);
+		pcie_write(pcie, 0x06040001,
+			   RT6855_PCIE2_OFFSET + RALINK_PCI_CLASS);
 		printk("PCIE2 enabled\n");
 	}
 

commit edec14020e3fcfb0a86bfa9f1d512b922697890f
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Fri Aug 3 10:27:00 2018 +0200

    staging: mt7621-pci: remove unused macros
    
    There some macros that are not being used. Remove them.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Tested-by: NeilBrown <neil@brown.name>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/mt7621-pci/pci-mt7621.c b/drivers/staging/mt7621-pci/pci-mt7621.c
index 3b45c592d10f..4200c68eb65e 100644
--- a/drivers/staging/mt7621-pci/pci-mt7621.c
+++ b/drivers/staging/mt7621-pci/pci-mt7621.c
@@ -84,7 +84,6 @@
 #define RALINK_PCI_PCIMSK_ADDR		*(volatile u32 *)(RALINK_PCI_BASE + 0x000C)
 #define RALINK_PCI_BASE	0xBE140000
 
-#define RALINK_PCIEPHY_P0P1_CTL_OFFSET	(RALINK_PCI_BASE + 0x9000)
 #define RT6855_PCIE0_OFFSET		0x2000
 #define RT6855_PCIE1_OFFSET		0x3000
 #define RT6855_PCIE2_OFFSET		0x4000
@@ -95,8 +94,6 @@
 #define RALINK_PCI0_CLASS		*(volatile u32 *)(RALINK_PCI_BASE + RT6855_PCIE0_OFFSET + 0x0034)
 #define RALINK_PCI0_SUBID		*(volatile u32 *)(RALINK_PCI_BASE + RT6855_PCIE0_OFFSET + 0x0038)
 #define RALINK_PCI0_STATUS		*(volatile u32 *)(RALINK_PCI_BASE + RT6855_PCIE0_OFFSET + 0x0050)
-#define RALINK_PCI0_DERR		*(volatile u32 *)(RALINK_PCI_BASE + RT6855_PCIE0_OFFSET + 0x0060)
-#define RALINK_PCI0_ECRC		*(volatile u32 *)(RALINK_PCI_BASE + RT6855_PCIE0_OFFSET + 0x0064)
 
 #define RALINK_PCI1_BAR0SETUP_ADDR	*(volatile u32 *)(RALINK_PCI_BASE + RT6855_PCIE1_OFFSET + 0x0010)
 #define RALINK_PCI1_IMBASEBAR0_ADDR	*(volatile u32 *)(RALINK_PCI_BASE + RT6855_PCIE1_OFFSET + 0x0018)
@@ -104,8 +101,6 @@
 #define RALINK_PCI1_CLASS		*(volatile u32 *)(RALINK_PCI_BASE + RT6855_PCIE1_OFFSET + 0x0034)
 #define RALINK_PCI1_SUBID		*(volatile u32 *)(RALINK_PCI_BASE + RT6855_PCIE1_OFFSET + 0x0038)
 #define RALINK_PCI1_STATUS		*(volatile u32 *)(RALINK_PCI_BASE + RT6855_PCIE1_OFFSET + 0x0050)
-#define RALINK_PCI1_DERR		*(volatile u32 *)(RALINK_PCI_BASE + RT6855_PCIE1_OFFSET + 0x0060)
-#define RALINK_PCI1_ECRC		*(volatile u32 *)(RALINK_PCI_BASE + RT6855_PCIE1_OFFSET + 0x0064)
 
 #define RALINK_PCI2_BAR0SETUP_ADDR	*(volatile u32 *)(RALINK_PCI_BASE + RT6855_PCIE2_OFFSET + 0x0010)
 #define RALINK_PCI2_IMBASEBAR0_ADDR	*(volatile u32 *)(RALINK_PCI_BASE + RT6855_PCIE2_OFFSET + 0x0018)
@@ -113,17 +108,10 @@
 #define RALINK_PCI2_CLASS		*(volatile u32 *)(RALINK_PCI_BASE + RT6855_PCIE2_OFFSET + 0x0034)
 #define RALINK_PCI2_SUBID		*(volatile u32 *)(RALINK_PCI_BASE + RT6855_PCIE2_OFFSET + 0x0038)
 #define RALINK_PCI2_STATUS		*(volatile u32 *)(RALINK_PCI_BASE + RT6855_PCIE2_OFFSET + 0x0050)
-#define RALINK_PCI2_DERR		*(volatile u32 *)(RALINK_PCI_BASE + RT6855_PCIE2_OFFSET + 0x0060)
-#define RALINK_PCI2_ECRC		*(volatile u32 *)(RALINK_PCI_BASE + RT6855_PCIE2_OFFSET + 0x0064)
 
 #define RALINK_PCIEPHY_P0P1_CTL_OFFSET	(RALINK_PCI_BASE + 0x9000)
 #define RALINK_PCIEPHY_P2_CTL_OFFSET	(RALINK_PCI_BASE + 0xA000)
 
-#define MV_WRITE(ofs, data)	\
-	*(volatile u32 *)(RALINK_PCI_BASE+(ofs)) = cpu_to_le32(data)
-#define MV_READ(ofs, data)	\
-	*(data) = le32_to_cpu(*(volatile u32 *)(RALINK_PCI_BASE+(ofs)))
-
 #define RALINK_PCI_MM_MAP_BASE		0x60000000
 #define RALINK_PCI_IO_MAP_BASE		0x1e160000
 
@@ -141,28 +129,18 @@
 		else							\
 			rt_sysc_m32(0, val, RALINK_RSTCTRL);		\
 	} while (0)
+
 #define RALINK_CLKCFG1			0x30
 #define RALINK_RSTCTRL			0x34
 #define RALINK_GPIOMODE			0x60
 #define RALINK_PCIE_CLK_GEN		0x7c
 #define RALINK_PCIE_CLK_GEN1		0x80
-#define PPLL_CFG1			0x9c
-#define PPLL_DRV			0xa0
-/* SYSC_REG_SYSTEM_CONFIG1 bits */
-#define RALINK_PCI_HOST_MODE_EN		(1<<7)
-#define RALINK_PCIE_RC_MODE_EN		(1<<8)
 //RALINK_RSTCTRL bit
 #define RALINK_PCIE_RST			(1<<23)
 #define RALINK_PCI_RST			(1<<24)
 //RALINK_CLKCFG1 bit
 #define RALINK_PCI_CLK_EN		(1<<19)
 #define RALINK_PCIE_CLK_EN		(1<<21)
-//RALINK_GPIOMODE bit
-#define PCI_SLOTx2			(1<<11)
-#define PCI_SLOTx1			(2<<11)
-//MTK PCIE PLL bit
-#define PDRV_SW_SET			(1<<31)
-#define LC_CKDRVPD_			(1<<19)
 
 #define MEMORY_BASE 0x0
 static int pcie_link_status = 0;

commit f8427fae570988deb5a78514ae6d70be1af0d358
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Fri Aug 3 10:26:59 2018 +0200

    staging: mt7621-pci: simplify write_config function
    
    write_config function is always called with bus and func
    being 0. Avoid those params and just use 0 inside the
    function. Review parameter types changing for more proper
    ones.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Tested-by: NeilBrown <neil@brown.name>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/mt7621-pci/pci-mt7621.c b/drivers/staging/mt7621-pci/pci-mt7621.c
index ad480f2f0b79..3b45c592d10f 100644
--- a/drivers/staging/mt7621-pci/pci-mt7621.c
+++ b/drivers/staging/mt7621-pci/pci-mt7621.c
@@ -249,11 +249,9 @@ read_config(struct mt7621_pcie *pcie, unsigned int dev, u32 reg)
 }
 
 static void
-write_config(struct mt7621_pcie *pcie,
-	     unsigned long bus, unsigned long dev,
-	     unsigned long func, unsigned long reg, unsigned long val)
+write_config(struct mt7621_pcie *pcie, unsigned int dev, u32 reg, u32 val)
 {
-	u32 address = mt7621_pci_get_cfgaddr(bus, dev, func, reg);
+	u32 address = mt7621_pci_get_cfgaddr(0, dev, 0, reg);
 
 	pcie_write(pcie, address, RALINK_PCI_CONFIG_ADDR);
 	pcie_write(pcie, val, RALINK_PCI_CONFIG_DATA_VIRTUAL_REG);
@@ -268,7 +266,7 @@ pcibios_map_irq(const struct pci_dev *dev, u8 slot, u8 pin)
 	int irq;
 
 	if (dev->bus->number == 0) {
-		write_config(pcie, 0, slot, 0, PCI_BASE_ADDRESS_0, MEMORY_BASE);
+		write_config(pcie, slot, PCI_BASE_ADDRESS_0, MEMORY_BASE);
 		val = read_config(pcie, slot, PCI_BASE_ADDRESS_0);
 		printk("BAR0 at slot %d = %x\n", slot, val);
 	}
@@ -695,27 +693,27 @@ pcie(2/1/0) link status	pcie2_num	pcie1_num	pcie0_num
 	switch (pcie_link_status) {
 	case 7:
 		val = read_config(pcie, 2, 0x4);
-		write_config(pcie, 0, 2, 0, 0x4, val|0x4);
+		write_config(pcie, 2, 0x4, val|0x4);
 		val = read_config(pcie, 2, 0x70c);
 		val &= ~(0xff)<<8;
 		val |= 0x50<<8;
-		write_config(pcie, 0, 2, 0, 0x70c, val);
+		write_config(pcie, 2, 0x70c, val);
 	case 3:
 	case 5:
 	case 6:
 		val = read_config(pcie, 1, 0x4);
-		write_config(pcie, 0, 1, 0, 0x4, val|0x4);
+		write_config(pcie, 1, 0x4, val|0x4);
 		val = read_config(pcie, 1, 0x70c);
 		val &= ~(0xff)<<8;
 		val |= 0x50<<8;
-		write_config(pcie, 0, 1, 0, 0x70c, val);
+		write_config(pcie, 1, 0x70c, val);
 	default:
 		val = read_config(pcie, 0, 0x4);
-		write_config(pcie, 0, 0, 0, 0x4, val|0x4); //bus master enable
+		write_config(pcie, 0, 0x4, val|0x4); //bus master enable
 		val = read_config(pcie, 0, 0x70c);
 		val &= ~(0xff)<<8;
 		val |= 0x50<<8;
-		write_config(pcie, 0, 0, 0, 0x70c, val);
+		write_config(pcie, 0, 0x70c, val);
 	}
 
 	err = mt7621_pci_parse_request_of_pci_ranges(pcie);

commit c0431f4f4aef9a52875d19af3c220e6c8f60d427
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Fri Aug 3 10:26:58 2018 +0200

    staging: mt7621-pci: simplify read_config function
    
    read_config function is always called with bus and func
    being 0. Avoid those params and just use 0 inside the
    function. Return readed value instead pass a reference
    parameter.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Tested-by: NeilBrown <neil@brown.name>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/mt7621-pci/pci-mt7621.c b/drivers/staging/mt7621-pci/pci-mt7621.c
index f1abf6c6939d..ad480f2f0b79 100644
--- a/drivers/staging/mt7621-pci/pci-mt7621.c
+++ b/drivers/staging/mt7621-pci/pci-mt7621.c
@@ -239,15 +239,13 @@ struct pci_ops mt7621_pci_ops = {
 	.write		= pci_generic_config_write,
 };
 
-static void
-read_config(struct mt7621_pcie *pcie,
-	    unsigned long bus, unsigned long dev,
-	    unsigned long func, unsigned long reg, unsigned long *val)
+static u32
+read_config(struct mt7621_pcie *pcie, unsigned int dev, u32 reg)
 {
-	u32 address = mt7621_pci_get_cfgaddr(bus, dev, func, reg);
+	u32 address = mt7621_pci_get_cfgaddr(0, dev, 0, reg);
 
 	pcie_write(pcie, address, RALINK_PCI_CONFIG_ADDR);
-	*val = pcie_read(pcie, RALINK_PCI_CONFIG_DATA_VIRTUAL_REG);
+	return pcie_read(pcie, RALINK_PCI_CONFIG_DATA_VIRTUAL_REG);
 }
 
 static void
@@ -271,7 +269,7 @@ pcibios_map_irq(const struct pci_dev *dev, u8 slot, u8 pin)
 
 	if (dev->bus->number == 0) {
 		write_config(pcie, 0, slot, 0, PCI_BASE_ADDRESS_0, MEMORY_BASE);
-		read_config(pcie, 0, slot, 0, PCI_BASE_ADDRESS_0, (unsigned long *)&val);
+		val = read_config(pcie, slot, PCI_BASE_ADDRESS_0);
 		printk("BAR0 at slot %d = %x\n", slot, val);
 	}
 
@@ -517,7 +515,7 @@ static int mt7621_pci_probe(struct platform_device *pdev)
 	struct mt7621_pcie *pcie;
 	struct pci_host_bridge *bridge;
 	int err;
-	unsigned long val = 0;
+	u32 val = 0;
 	LIST_HEAD(res);
 
 	if (!dev->of_node)
@@ -569,13 +567,13 @@ static int mt7621_pci_probe(struct platform_device *pdev)
 		bypass_pipe_rst();
 	set_phy_for_ssc();
 
-	read_config(pcie, 0, 0, 0, 0x70c, &val);
+	val = read_config(pcie, 0, 0x70c);
 	printk("Port 0 N_FTS = %x\n", (unsigned int)val);
 
-	read_config(pcie, 0, 1, 0, 0x70c, &val);
+	val = read_config(pcie, 1, 0x70c);
 	printk("Port 1 N_FTS = %x\n", (unsigned int)val);
 
-	read_config(pcie, 0, 2, 0, 0x70c, &val);
+	val = read_config(pcie, 2, 0x70c);
 	printk("Port 2 N_FTS = %x\n", (unsigned int)val);
 
 	rt_sysc_m32(0, RALINK_PCIE_RST, RALINK_RSTCTRL);
@@ -696,25 +694,25 @@ pcie(2/1/0) link status	pcie2_num	pcie1_num	pcie0_num
 
 	switch (pcie_link_status) {
 	case 7:
-		read_config(pcie, 0, 2, 0, 0x4, &val);
+		val = read_config(pcie, 2, 0x4);
 		write_config(pcie, 0, 2, 0, 0x4, val|0x4);
-		read_config(pcie, 0, 2, 0, 0x70c, &val);
+		val = read_config(pcie, 2, 0x70c);
 		val &= ~(0xff)<<8;
 		val |= 0x50<<8;
 		write_config(pcie, 0, 2, 0, 0x70c, val);
 	case 3:
 	case 5:
 	case 6:
-		read_config(pcie, 0, 1, 0, 0x4, &val);
+		val = read_config(pcie, 1, 0x4);
 		write_config(pcie, 0, 1, 0, 0x4, val|0x4);
-		read_config(pcie, 0, 1, 0, 0x70c, &val);
+		val = read_config(pcie, 1, 0x70c);
 		val &= ~(0xff)<<8;
 		val |= 0x50<<8;
 		write_config(pcie, 0, 1, 0, 0x70c, val);
 	default:
-		read_config(pcie, 0, 0, 0, 0x4, &val);
+		val = read_config(pcie, 0, 0x4);
 		write_config(pcie, 0, 0, 0, 0x4, val|0x4); //bus master enable
-		read_config(pcie, 0, 0, 0, 0x70c, &val);
+		val = read_config(pcie, 0, 0x70c);
 		val &= ~(0xff)<<8;
 		val |= 0x50<<8;
 		write_config(pcie, 0, 0, 0, 0x70c, val);

commit 9f999b41502714e7a33f3723f4a3aba85bd0324c
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Fri Aug 3 10:26:57 2018 +0200

    staging: mt7621-pci: use pcie_[read|write] in [write|read]_config
    
    Instead of custom macros use pcie_read and pcie_write functions.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Tested-by: NeilBrown <neil@brown.name>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/mt7621-pci/pci-mt7621.c b/drivers/staging/mt7621-pci/pci-mt7621.c
index fe9c68fbe364..f1abf6c6939d 100644
--- a/drivers/staging/mt7621-pci/pci-mt7621.c
+++ b/drivers/staging/mt7621-pci/pci-mt7621.c
@@ -240,41 +240,38 @@ struct pci_ops mt7621_pci_ops = {
 };
 
 static void
-read_config(unsigned long bus, unsigned long dev, unsigned long func, unsigned long reg, unsigned long *val)
+read_config(struct mt7621_pcie *pcie,
+	    unsigned long bus, unsigned long dev,
+	    unsigned long func, unsigned long reg, unsigned long *val)
 {
-	u32 address_reg, data_reg, address;
-
-	address_reg = RALINK_PCI_CONFIG_ADDR;
-	data_reg = RALINK_PCI_CONFIG_DATA_VIRTUAL_REG;
-	address = mt7621_pci_get_cfgaddr(bus, dev, func, reg);
-	MV_WRITE(address_reg, address);
-	MV_READ(data_reg, val);
-	return;
+	u32 address = mt7621_pci_get_cfgaddr(bus, dev, func, reg);
+
+	pcie_write(pcie, address, RALINK_PCI_CONFIG_ADDR);
+	*val = pcie_read(pcie, RALINK_PCI_CONFIG_DATA_VIRTUAL_REG);
 }
 
 static void
-write_config(unsigned long bus, unsigned long dev, unsigned long func, unsigned long reg, unsigned long val)
+write_config(struct mt7621_pcie *pcie,
+	     unsigned long bus, unsigned long dev,
+	     unsigned long func, unsigned long reg, unsigned long val)
 {
-	u32 address_reg, data_reg, address;
-
-	address_reg = RALINK_PCI_CONFIG_ADDR;
-	data_reg = RALINK_PCI_CONFIG_DATA_VIRTUAL_REG;
-	address = mt7621_pci_get_cfgaddr(bus, dev, func, reg);
-	MV_WRITE(address_reg, address);
-	MV_WRITE(data_reg, val);
-	return;
+	u32 address = mt7621_pci_get_cfgaddr(bus, dev, func, reg);
+
+	pcie_write(pcie, address, RALINK_PCI_CONFIG_ADDR);
+	pcie_write(pcie, val, RALINK_PCI_CONFIG_DATA_VIRTUAL_REG);
 }
 
 int
 pcibios_map_irq(const struct pci_dev *dev, u8 slot, u8 pin)
 {
+	struct mt7621_pcie *pcie = dev->bus->sysdata;
 	u16 cmd;
 	u32 val;
 	int irq;
 
 	if (dev->bus->number == 0) {
-		write_config(0, slot, 0, PCI_BASE_ADDRESS_0, MEMORY_BASE);
-		read_config(0, slot, 0, PCI_BASE_ADDRESS_0, (unsigned long *)&val);
+		write_config(pcie, 0, slot, 0, PCI_BASE_ADDRESS_0, MEMORY_BASE);
+		read_config(pcie, 0, slot, 0, PCI_BASE_ADDRESS_0, (unsigned long *)&val);
 		printk("BAR0 at slot %d = %x\n", slot, val);
 	}
 
@@ -572,13 +569,13 @@ static int mt7621_pci_probe(struct platform_device *pdev)
 		bypass_pipe_rst();
 	set_phy_for_ssc();
 
-	read_config(0, 0, 0, 0x70c, &val);
+	read_config(pcie, 0, 0, 0, 0x70c, &val);
 	printk("Port 0 N_FTS = %x\n", (unsigned int)val);
 
-	read_config(0, 1, 0, 0x70c, &val);
+	read_config(pcie, 0, 1, 0, 0x70c, &val);
 	printk("Port 1 N_FTS = %x\n", (unsigned int)val);
 
-	read_config(0, 2, 0, 0x70c, &val);
+	read_config(pcie, 0, 2, 0, 0x70c, &val);
 	printk("Port 2 N_FTS = %x\n", (unsigned int)val);
 
 	rt_sysc_m32(0, RALINK_PCIE_RST, RALINK_RSTCTRL);
@@ -699,28 +696,28 @@ pcie(2/1/0) link status	pcie2_num	pcie1_num	pcie0_num
 
 	switch (pcie_link_status) {
 	case 7:
-		read_config(0, 2, 0, 0x4, &val);
-		write_config(0, 2, 0, 0x4, val|0x4);
-		read_config(0, 2, 0, 0x70c, &val);
+		read_config(pcie, 0, 2, 0, 0x4, &val);
+		write_config(pcie, 0, 2, 0, 0x4, val|0x4);
+		read_config(pcie, 0, 2, 0, 0x70c, &val);
 		val &= ~(0xff)<<8;
 		val |= 0x50<<8;
-		write_config(0, 2, 0, 0x70c, val);
+		write_config(pcie, 0, 2, 0, 0x70c, val);
 	case 3:
 	case 5:
 	case 6:
-		read_config(0, 1, 0, 0x4, &val);
-		write_config(0, 1, 0, 0x4, val|0x4);
-		read_config(0, 1, 0, 0x70c, &val);
+		read_config(pcie, 0, 1, 0, 0x4, &val);
+		write_config(pcie, 0, 1, 0, 0x4, val|0x4);
+		read_config(pcie, 0, 1, 0, 0x70c, &val);
 		val &= ~(0xff)<<8;
 		val |= 0x50<<8;
-		write_config(0, 1, 0, 0x70c, val);
+		write_config(pcie, 0, 1, 0, 0x70c, val);
 	default:
-		read_config(0, 0, 0, 0x4, &val);
-		write_config(0, 0, 0, 0x4, val|0x4); //bus master enable
-		read_config(0, 0, 0, 0x70c, &val);
+		read_config(pcie, 0, 0, 0, 0x4, &val);
+		write_config(pcie, 0, 0, 0, 0x4, val|0x4); //bus master enable
+		read_config(pcie, 0, 0, 0, 0x70c, &val);
 		val &= ~(0xff)<<8;
 		val |= 0x50<<8;
-		write_config(0, 0, 0, 0x70c, val);
+		write_config(pcie, 0, 0, 0, 0x70c, val);
 	}
 
 	err = mt7621_pci_parse_request_of_pci_ranges(pcie);

commit 52ed727ca031ca7a6fcfde55a2902ac4845d736c
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Fri Aug 3 10:26:56 2018 +0200

    staging: mt7621-pci: add pcie_write and pcie_read helpers
    
    Introdice this functions to make easier to write/read to/from
    an offset relative to base address
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Tested-by: NeilBrown <neil@brown.name>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/mt7621-pci/pci-mt7621.c b/drivers/staging/mt7621-pci/pci-mt7621.c
index 68f47147cbdb..fe9c68fbe364 100644
--- a/drivers/staging/mt7621-pci/pci-mt7621.c
+++ b/drivers/staging/mt7621-pci/pci-mt7621.c
@@ -204,6 +204,16 @@ struct mt7621_pcie {
 	struct list_head ports;
 };
 
+static inline u32 pcie_read(struct mt7621_pcie *pcie, u32 reg)
+{
+	return readl(pcie->base + reg);
+}
+
+static inline void pcie_write(struct mt7621_pcie *pcie, u32 val, u32 reg)
+{
+	writel(val, pcie->base + reg);
+}
+
 static inline u32 mt7621_pci_get_cfgaddr(unsigned int bus, unsigned int slot,
 					 unsigned int func, unsigned int where)
 {

commit e9d03d17dd94399bbc658394501d41a10ea1ef70
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Fri Aug 3 10:26:55 2018 +0200

    staging: mt7621-pci: remove dead code derived to not use custom reads and writes
    
    Driver is using now pci subsystem generics reads and writes and requesting
    bus resources without using legacy code functions. Because of this there is
    a lot of dead code that can be removed.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Tested-by: NeilBrown <neil@brown.name>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/mt7621-pci/pci-mt7621.c b/drivers/staging/mt7621-pci/pci-mt7621.c
index 12702917bbaa..68f47147cbdb 100644
--- a/drivers/staging/mt7621-pci/pci-mt7621.c
+++ b/drivers/staging/mt7621-pci/pci-mt7621.c
@@ -123,15 +123,6 @@
 	*(volatile u32 *)(RALINK_PCI_BASE+(ofs)) = cpu_to_le32(data)
 #define MV_READ(ofs, data)	\
 	*(data) = le32_to_cpu(*(volatile u32 *)(RALINK_PCI_BASE+(ofs)))
-#define MV_WRITE_16(ofs, data)	\
-	*(volatile u16 *)(RALINK_PCI_BASE+(ofs)) = cpu_to_le16(data)
-#define MV_READ_16(ofs, data)	\
-	*(data) = le16_to_cpu(*(volatile u16 *)(RALINK_PCI_BASE+(ofs)))
-
-#define MV_WRITE_8(ofs, data)	\
-	*(volatile u8 *)(RALINK_PCI_BASE+(ofs)) = data
-#define MV_READ_8(ofs, data)	\
-	*(data) = *(volatile u8 *)(RALINK_PCI_BASE+(ofs))
 
 #define RALINK_PCI_MM_MAP_BASE		0x60000000
 #define RALINK_PCI_IO_MAP_BASE		0x1e160000
@@ -176,13 +167,6 @@
 #define MEMORY_BASE 0x0
 static int pcie_link_status = 0;
 
-#define PCI_ACCESS_READ_1  0
-#define PCI_ACCESS_READ_2  1
-#define PCI_ACCESS_READ_4  2
-#define PCI_ACCESS_WRITE_1 3
-#define PCI_ACCESS_WRITE_2 4
-#define PCI_ACCESS_WRITE_4 5
-
 /**
  * struct mt7621_pcie_port - PCIe port information
  * @base: IO mapped register base
@@ -227,118 +211,6 @@ static inline u32 mt7621_pci_get_cfgaddr(unsigned int bus, unsigned int slot,
 		(func << 8) | (where & 0xfc) | 0x80000000;
 }
 
-static int config_access(unsigned char access_type, struct pci_bus *bus,
-			unsigned int devfn, unsigned int where, u32 *data)
-{
-	unsigned int slot = PCI_SLOT(devfn);
-	u8 func = PCI_FUNC(devfn);
-	u32 address_reg, data_reg;
-	unsigned int address;
-
-	address_reg = RALINK_PCI_CONFIG_ADDR;
-	data_reg = RALINK_PCI_CONFIG_DATA_VIRTUAL_REG;
-
-	address = mt7621_pci_get_cfgaddr(bus->number, slot, func, where);
-
-	MV_WRITE(address_reg, address);
-
-	switch (access_type) {
-	case PCI_ACCESS_WRITE_1:
-		MV_WRITE_8(data_reg+(where&0x3), *data);
-		break;
-	case PCI_ACCESS_WRITE_2:
-		MV_WRITE_16(data_reg+(where&0x3), *data);
-		break;
-	case PCI_ACCESS_WRITE_4:
-		MV_WRITE(data_reg, *data);
-		break;
-	case PCI_ACCESS_READ_1:
-		MV_READ_8(data_reg+(where&0x3), data);
-		break;
-	case PCI_ACCESS_READ_2:
-		MV_READ_16(data_reg+(where&0x3), data);
-		break;
-	case PCI_ACCESS_READ_4:
-		MV_READ(data_reg, data);
-		break;
-	default:
-		printk("no specify access type\n");
-		break;
-	}
-	return 0;
-}
-
-static int
-read_config_byte(struct pci_bus *bus, unsigned int devfn, int where, u8 *val)
-{
-	return config_access(PCI_ACCESS_READ_1, bus, devfn, (unsigned int)where, (u32 *)val);
-}
-
-static int
-read_config_word(struct pci_bus *bus, unsigned int devfn, int where, u16 *val)
-{
-	return config_access(PCI_ACCESS_READ_2, bus, devfn, (unsigned int)where, (u32 *)val);
-}
-
-static int
-read_config_dword(struct pci_bus *bus, unsigned int devfn, int where, u32 *val)
-{
-	return config_access(PCI_ACCESS_READ_4, bus, devfn, (unsigned int)where, (u32 *)val);
-}
-
-static int
-write_config_byte(struct pci_bus *bus, unsigned int devfn, int where, u8 val)
-{
-	if (config_access(PCI_ACCESS_WRITE_1, bus, devfn, (unsigned int)where, (u32 *)&val))
-		return -1;
-
-	return PCIBIOS_SUCCESSFUL;
-}
-
-static int
-write_config_word(struct pci_bus *bus, unsigned int devfn, int where, u16 val)
-{
-	if (config_access(PCI_ACCESS_WRITE_2, bus, devfn, where, (u32 *)&val))
-		return -1;
-
-	return PCIBIOS_SUCCESSFUL;
-}
-
-static int
-write_config_dword(struct pci_bus *bus, unsigned int devfn, int where, u32 val)
-{
-	if (config_access(PCI_ACCESS_WRITE_4, bus, devfn, where, &val))
-		return -1;
-
-	return PCIBIOS_SUCCESSFUL;
-}
-
-static int
-pci_config_read(struct pci_bus *bus, unsigned int devfn, int where, int size, u32 *val)
-{
-	switch (size) {
-	case 1:
-		return read_config_byte(bus, devfn, where, (u8 *) val);
-	case 2:
-		return read_config_word(bus, devfn, where, (u16 *) val);
-	default:
-		return read_config_dword(bus, devfn, where, val);
-	}
-}
-
-static int
-pci_config_write(struct pci_bus *bus, unsigned int devfn, int where, int size, u32 val)
-{
-	switch (size) {
-	case 1:
-		return write_config_byte(bus, devfn, where, (u8) val);
-	case 2:
-		return write_config_word(bus, devfn, where, (u16) val);
-	default:
-		return write_config_dword(bus, devfn, where, val);
-	}
-}
-
 static void __iomem *mt7621_pcie_map_bus(struct pci_bus *bus,
 					 unsigned int devfn, int where)
 {

commit 8571c62d45cb7e9fdff87fe5132002d17fbce7a3
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Fri Aug 3 10:26:54 2018 +0200

    staging: mt7621-pci: use generic kernel pci subsystem read and write
    
    map_bus callback is called before every .read/.write operation.
    Implement it and change custom read write operations for the
    pci subsystem generics. Make the probe function to don't use
    legacy stuff and request bus resources directly. Get pci register
    base and ranges from device tree.
    The driver is not using PCI_LEGACY code anymore and shall use the
    PCI_DRIVERS_GENERIC option to correct compile it. Add also new
    Kconfig file for this controller setting there its correct dependencies.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Tested-by: NeilBrown <neil@brown.name>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/mt7621-pci/pci-mt7621.c b/drivers/staging/mt7621-pci/pci-mt7621.c
index 650e49b995e3..12702917bbaa 100644
--- a/drivers/staging/mt7621-pci/pci-mt7621.c
+++ b/drivers/staging/mt7621-pci/pci-mt7621.c
@@ -53,11 +53,16 @@
 #include <linux/delay.h>
 #include <linux/of.h>
 #include <linux/of_pci.h>
+#include <linux/of_platform.h>
+#include <linux/of_address.h>
+#include <linux/of_irq.h>
 #include <linux/platform_device.h>
 
 #include <ralink_regs.h>
 #include <mt7621.h>
 
+#include "../../pci/pci.h"
+
 /*
  * These functions and structures provide the BIOS scan and mapping of the PCI
  * devices.
@@ -178,6 +183,43 @@ static int pcie_link_status = 0;
 #define PCI_ACCESS_WRITE_2 4
 #define PCI_ACCESS_WRITE_4 5
 
+/**
+ * struct mt7621_pcie_port - PCIe port information
+ * @base: IO mapped register base
+ * @list: port list
+ * @pcie: pointer to PCIe host info
+ * @reset: pointer to port reset control
+ */
+struct mt7621_pcie_port {
+	void __iomem *base;
+	struct list_head list;
+	struct mt7621_pcie *pcie;
+	struct reset_control *reset;
+};
+
+/**
+ * struct mt7621_pcie - PCIe host information
+ * @base: IO Mapped Register Base
+ * @io: IO resource
+ * @mem: non-prefetchable memory resource
+ * @busn: bus range
+ * @offset: IO / Memory offset
+ * @dev: Pointer to PCIe device
+ * @ports: pointer to PCIe port information
+ */
+struct mt7621_pcie {
+	void __iomem *base;
+	struct device *dev;
+	struct resource io;
+	struct resource mem;
+	struct resource busn;
+	struct {
+		resource_size_t mem;
+		resource_size_t io;
+	} offset;
+	struct list_head ports;
+};
+
 static inline u32 mt7621_pci_get_cfgaddr(unsigned int bus, unsigned int slot,
 					 unsigned int func, unsigned int where)
 {
@@ -297,17 +339,22 @@ pci_config_write(struct pci_bus *bus, unsigned int devfn, int where, int size, u
 	}
 }
 
-struct pci_ops mt7621_pci_ops = {
-	.read		= pci_config_read,
-	.write		= pci_config_write,
-};
+static void __iomem *mt7621_pcie_map_bus(struct pci_bus *bus,
+					 unsigned int devfn, int where)
+{
+	struct mt7621_pcie *pcie = bus->sysdata;
+	u32 address = mt7621_pci_get_cfgaddr(bus->number, PCI_SLOT(devfn),
+					     PCI_FUNC(devfn), where);
+
+	writel(address, pcie->base + RALINK_PCI_CONFIG_ADDR);
+
+	return pcie->base + RALINK_PCI_CONFIG_DATA_VIRTUAL_REG + (where & 3);
+}
 
-static struct resource mt7621_res_pci_mem1;
-static struct resource mt7621_res_pci_io1;
-static struct pci_controller mt7621_controller = {
-	.pci_ops	= &mt7621_pci_ops,
-	.mem_resource	= &mt7621_res_pci_mem1,
-	.io_resource	= &mt7621_res_pci_io1,
+struct pci_ops mt7621_pci_ops = {
+	.map_bus	= mt7621_pcie_map_bus,
+	.read		= pci_generic_config_read,
+	.write		= pci_generic_config_write,
 };
 
 static void
@@ -463,9 +510,10 @@ set_phy_for_ssc(void)
 	set_pcie_phy((u32 *)(RALINK_PCIEPHY_P2_CTL_OFFSET + 0x000),  4, 1, 0x00);	// rg_pe1_frc_phy_en	//Force Port 0 disable control
 }
 
-void setup_cm_memory_region(struct resource *mem_resource)
+static void setup_cm_memory_region(struct resource *mem_resource)
 {
 	resource_size_t mask;
+
 	if (mips_cps_numiocu(0)) {
 		/* FIXME: hardware doesn't accept mask values with 1s after
 		 * 0s (e.g. 0xffef), so it would be great to warn if that's
@@ -480,14 +528,142 @@ void setup_cm_memory_region(struct resource *mem_resource)
 	}
 }
 
+static int mt7621_pci_parse_request_of_pci_ranges(struct mt7621_pcie *pcie)
+{
+	struct device *dev = pcie->dev;
+	struct device_node *node = dev->of_node;
+	struct of_pci_range_parser parser;
+	struct of_pci_range range;
+	int err;
+
+	if (of_pci_range_parser_init(&parser, node)) {
+		dev_err(dev, "missing \"ranges\" property\n");
+		return -EINVAL;
+	}
+
+	for_each_of_pci_range(&parser, &range) {
+		struct resource *res = NULL;
+
+		switch (range.flags & IORESOURCE_TYPE_BITS) {
+		case IORESOURCE_IO:
+			ioremap(range.cpu_addr, range.size);
+			res = &pcie->io;
+			pcie->offset.io = 0x00000000UL;
+			break;
+		case IORESOURCE_MEM:
+			res = &pcie->mem;
+			pcie->offset.mem = 0x00000000UL;
+			break;
+		}
+
+		if (res != NULL)
+			of_pci_range_to_resource(&range, node, res);
+	}
+
+	err = of_pci_parse_bus_range(node, &pcie->busn);
+	if (err < 0) {
+		dev_err(dev, "failed to parse bus ranges property: %d\n", err);
+		pcie->busn.name = node->name;
+		pcie->busn.start = 0;
+		pcie->busn.end = 0xff;
+		pcie->busn.flags = IORESOURCE_BUS;
+	}
+
+	return 0;
+}
+
+static int mt7621_pcie_parse_dt(struct mt7621_pcie *pcie)
+{
+	struct device *dev = pcie->dev;
+	struct device_node *node = dev->of_node;
+	struct resource regs;
+	const char *type;
+	int err;
+
+	type = of_get_property(node, "device_type", NULL);
+	if (!type || strcmp(type, "pci") != 0) {
+		dev_err(dev, "invalid \"device_type\" %s\n", type);
+		return -EINVAL;
+	}
+
+	err = of_address_to_resource(node, 0, &regs);
+	if (err) {
+		dev_err(dev, "missing \"reg\" property\n");
+		return err;
+	}
+
+	pcie->base = devm_ioremap_resource(dev, &regs);
+	if (IS_ERR(pcie->base))
+		return PTR_ERR(pcie->base);
+
+	return 0;
+}
+
+static int mt7621_pcie_request_resources(struct mt7621_pcie *pcie,
+					 struct list_head *res)
+{
+	struct device *dev = pcie->dev;
+	int err;
+
+	pci_add_resource_offset(res, &pcie->io, pcie->offset.io);
+	pci_add_resource_offset(res, &pcie->mem, pcie->offset.mem);
+	pci_add_resource(res, &pcie->busn);
+
+	err = devm_request_pci_bus_resources(dev, res);
+	if (err < 0)
+		return err;
+
+	return 0;
+}
+
+static int mt7621_pcie_register_host(struct pci_host_bridge *host,
+				     struct list_head *res)
+{
+	struct mt7621_pcie *pcie = pci_host_bridge_priv(host);
+
+	list_splice_init(res, &host->windows);
+	host->busnr = pcie->busn.start;
+	host->dev.parent = pcie->dev;
+	host->ops = &mt7621_pci_ops;
+	host->map_irq = pcibios_map_irq;
+	host->swizzle_irq = pci_common_swizzle;
+	host->sysdata = pcie;
+
+	return pci_host_probe(host);
+}
+
 static int mt7621_pci_probe(struct platform_device *pdev)
 {
+	struct device *dev = &pdev->dev;
+	struct mt7621_pcie *pcie;
+	struct pci_host_bridge *bridge;
+	int err;
 	unsigned long val = 0;
+	LIST_HEAD(res);
+
+	if (!dev->of_node)
+		return -ENODEV;
+
+	bridge = devm_pci_alloc_host_bridge(dev, sizeof(*pcie));
+	if (!bridge)
+		return -ENODEV;
 
+	pcie = pci_host_bridge_priv(bridge);
+	pcie->dev = dev;
+	platform_set_drvdata(pdev, pcie);
+	INIT_LIST_HEAD(&pcie->ports);
+
+	err = mt7621_pcie_parse_dt(pcie);
+	if (err) {
+		dev_err(dev, "Parsing DT failed\n");
+		return err;
+	}
+
+	/* set resources limits */
 	iomem_resource.start = 0;
-	iomem_resource.end = ~0;
+	iomem_resource.end = ~0UL; /* no limit */
 	ioport_resource.start = 0;
-	ioport_resource.end = ~0;
+	ioport_resource.end = ~0UL; /* no limit */
 
 	val = RALINK_PCIE0_RST;
 	val |= RALINK_PCIE1_RST;
@@ -665,11 +841,27 @@ pcie(2/1/0) link status	pcie2_num	pcie1_num	pcie0_num
 		write_config(0, 0, 0, 0x70c, val);
 	}
 
-	pci_load_of_ranges(&mt7621_controller, pdev->dev.of_node);
-	setup_cm_memory_region(mt7621_controller.mem_resource);
-	register_pci_controller(&mt7621_controller);
-	return 0;
+	err = mt7621_pci_parse_request_of_pci_ranges(pcie);
+	if (err) {
+		dev_err(dev, "Error requesting pci resources from ranges");
+		return err;
+	}
+
+	setup_cm_memory_region(&pcie->mem);
+
+	err = mt7621_pcie_request_resources(pcie, &res);
+	if (err) {
+		dev_err(dev, "Error requesting resources\n");
+		return err;
+	}
 
+	err = mt7621_pcie_register_host(bridge, &res);
+	if (err) {
+		dev_err(dev, "Error registering host\n");
+		return err;
+	}
+
+	return 0;
 }
 
 int pcibios_plat_dev_init(struct pci_dev *dev)

commit 7d6bc56932de5c0b337b783dc837e9d92f24c45e
Author: Oliver Hbers <oliver.huebers@web.de>
Date:   Fri Jul 13 15:41:06 2018 +0200

    staging: mt7621: Add SPDX license identifier
    
    Signed-off-by: Oliver Hbers <oliver.huebers@web.de>
    Signed-off-by: Vanessa Borgmann <nessa.x@web.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/mt7621-pci/pci-mt7621.c b/drivers/staging/mt7621-pci/pci-mt7621.c
index e092b5dc2bc1..650e49b995e3 100644
--- a/drivers/staging/mt7621-pci/pci-mt7621.c
+++ b/drivers/staging/mt7621-pci/pci-mt7621.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0+
 /**************************************************************************
  *
  *  BRIEF MODULE DESCRIPTION

commit bb4e1ca9b2008c0dc124ec39b68e94964f45e8c0
Author: Oliver Hbers <oliver.huebers@web.de>
Date:   Fri Jul 13 15:41:03 2018 +0200

    staging: mt7621-pci: Include preferred headers
    
    This fixes the following checkpatch warnings:
    Use #include <linux/pci.h> instead of <asm/pci.h>
    Use #include <linux/io.h> instead of <asm/io.h>
    
    Signed-off-by: Oliver Hbers <oliver.huebers@web.de>
    Signed-off-by: Vanessa Borgmann <nessa.x@web.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/mt7621-pci/pci-mt7621.c b/drivers/staging/mt7621-pci/pci-mt7621.c
index 4f568401b37e..e092b5dc2bc1 100644
--- a/drivers/staging/mt7621-pci/pci-mt7621.c
+++ b/drivers/staging/mt7621-pci/pci-mt7621.c
@@ -44,8 +44,8 @@
 #include <linux/kernel.h>
 #include <linux/slab.h>
 #include <linux/version.h>
-#include <asm/pci.h>
-#include <asm/io.h>
+#include <linux/pci.h>
+#include <linux/io.h>
 #include <asm/mips-cm.h>
 #include <linux/init.h>
 #include <linux/module.h>

commit 2427d174a476199111a20e74f76fda21296134f7
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Mon Jul 9 22:21:04 2018 +0200

    staging: mt7621-pci: factor out mt7621_pci_get_cfgaddr function
    
    To get config address the same pattern is repeated in some functions
    along the code. Factor out a new mt7621_pci_get_cfgaddr for calculate
    it and use it in convenient places. Adjust types to match to u32 where
    is neccesary.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/mt7621-pci/pci-mt7621.c b/drivers/staging/mt7621-pci/pci-mt7621.c
index 89a57a02ae57..4f568401b37e 100644
--- a/drivers/staging/mt7621-pci/pci-mt7621.c
+++ b/drivers/staging/mt7621-pci/pci-mt7621.c
@@ -177,19 +177,26 @@ static int pcie_link_status = 0;
 #define PCI_ACCESS_WRITE_2 4
 #define PCI_ACCESS_WRITE_4 5
 
+static inline u32 mt7621_pci_get_cfgaddr(unsigned int bus, unsigned int slot,
+					 unsigned int func, unsigned int where)
+{
+	return (((where & 0xF00) >> 8) << 24) | (bus << 16) | (slot << 11) |
+		(func << 8) | (where & 0xfc) | 0x80000000;
+}
+
 static int config_access(unsigned char access_type, struct pci_bus *bus,
 			unsigned int devfn, unsigned int where, u32 *data)
 {
 	unsigned int slot = PCI_SLOT(devfn);
 	u8 func = PCI_FUNC(devfn);
-	uint32_t address_reg, data_reg;
+	u32 address_reg, data_reg;
 	unsigned int address;
 
 	address_reg = RALINK_PCI_CONFIG_ADDR;
 	data_reg = RALINK_PCI_CONFIG_DATA_VIRTUAL_REG;
 
-	address = (((where&0xF00)>>8)<<24) |(bus->number << 16) | (slot << 11) |
-				(func << 8) | (where & 0xfc) | 0x80000000;
+	address = mt7621_pci_get_cfgaddr(bus->number, slot, func, where);
+
 	MV_WRITE(address_reg, address);
 
 	switch (access_type) {
@@ -305,11 +312,11 @@ static struct pci_controller mt7621_controller = {
 static void
 read_config(unsigned long bus, unsigned long dev, unsigned long func, unsigned long reg, unsigned long *val)
 {
-	unsigned int address_reg, data_reg, address;
+	u32 address_reg, data_reg, address;
 
 	address_reg = RALINK_PCI_CONFIG_ADDR;
 	data_reg = RALINK_PCI_CONFIG_DATA_VIRTUAL_REG;
-	address = (((reg & 0xF00)>>8)<<24) | (bus << 16) | (dev << 11) | (func << 8) | (reg & 0xfc) | 0x80000000 ;
+	address = mt7621_pci_get_cfgaddr(bus, dev, func, reg);
 	MV_WRITE(address_reg, address);
 	MV_READ(data_reg, val);
 	return;
@@ -318,11 +325,11 @@ read_config(unsigned long bus, unsigned long dev, unsigned long func, unsigned l
 static void
 write_config(unsigned long bus, unsigned long dev, unsigned long func, unsigned long reg, unsigned long val)
 {
-	unsigned int address_reg, data_reg, address;
+	u32 address_reg, data_reg, address;
 
 	address_reg = RALINK_PCI_CONFIG_ADDR;
 	data_reg = RALINK_PCI_CONFIG_DATA_VIRTUAL_REG;
-	address = (((reg & 0xF00)>>8)<<24) | (bus << 16) | (dev << 11) | (func << 8) | (reg & 0xfc) | 0x80000000 ;
+	address = mt7621_pci_get_cfgaddr(bus, dev, func, reg);
 	MV_WRITE(address_reg, address);
 	MV_WRITE(data_reg, val);
 	return;

commit fc4afdfea0428f8a564b62a6d668da95935b6cbf
Author: Sergio Paracuellos <sergio.paracuellos@gmail.com>
Date:   Mon Jul 9 22:21:03 2018 +0200

    staging: mt7621-pci: remove unused macro MV_READ_DATA
    
    This macro is not being used at all along the code.
    Just remove it.
    
    Signed-off-by: Sergio Paracuellos <sergio.paracuellos@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/mt7621-pci/pci-mt7621.c b/drivers/staging/mt7621-pci/pci-mt7621.c
index c12447dfbc0f..89a57a02ae57 100644
--- a/drivers/staging/mt7621-pci/pci-mt7621.c
+++ b/drivers/staging/mt7621-pci/pci-mt7621.c
@@ -117,9 +117,6 @@
 	*(volatile u32 *)(RALINK_PCI_BASE+(ofs)) = cpu_to_le32(data)
 #define MV_READ(ofs, data)	\
 	*(data) = le32_to_cpu(*(volatile u32 *)(RALINK_PCI_BASE+(ofs)))
-#define MV_READ_DATA(ofs)	\
-	le32_to_cpu(*(volatile u32 *)(RALINK_PCI_BASE+(ofs)))
-
 #define MV_WRITE_16(ofs, data)	\
 	*(volatile u16 *)(RALINK_PCI_BASE+(ofs)) = cpu_to_le16(data)
 #define MV_READ_16(ofs, data)	\

commit 4cd6bacfaa74ecf15b5e6f50b94100d62f00c52c
Author: Peter Vernia <peter.vernia@gmail.com>
Date:   Sat Jul 7 03:10:22 2018 -0400

    staging: mt7621-pci: Move open-braces to match kernel code style
    
    Moves some open-braces to the end of the conditional statement to match the
    kernel's coding style
    
    Signed-off-by: Peter Vernia <peter.vernia@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/mt7621-pci/pci-mt7621.c b/drivers/staging/mt7621-pci/pci-mt7621.c
index 3c7978e4355d..c12447dfbc0f 100644
--- a/drivers/staging/mt7621-pci/pci-mt7621.c
+++ b/drivers/staging/mt7621-pci/pci-mt7621.c
@@ -532,8 +532,7 @@ static int mt7621_pci_probe(struct platform_device *pdev)
 	*(unsigned int *)(0xbe000620) |= 0x1<<19 | 0x1<<8 | 0x1<<7;		// set DATA
 	mdelay(1000);
 
-	if ((RALINK_PCI0_STATUS & 0x1) == 0)
-	{
+	if ((RALINK_PCI0_STATUS & 0x1) == 0) {
 		printk("PCIE0 no card, disable it(RST&CLK)\n");
 		ASSERT_SYSRST_PCIE(RALINK_PCIE0_RST);
 		rt_sysc_m32(RALINK_PCIE0_CLK_EN, 0, RALINK_CLKCFG1);
@@ -543,8 +542,7 @@ static int mt7621_pci_probe(struct platform_device *pdev)
 		RALINK_PCI_PCIMSK_ADDR |= (1<<20); // enable pcie1 interrupt
 	}
 
-	if ((RALINK_PCI1_STATUS & 0x1) == 0)
-	{
+	if ((RALINK_PCI1_STATUS & 0x1) == 0) {
 		printk("PCIE1 no card, disable it(RST&CLK)\n");
 		ASSERT_SYSRST_PCIE(RALINK_PCIE1_RST);
 		rt_sysc_m32(RALINK_PCIE1_CLK_EN, 0, RALINK_CLKCFG1);

commit bd84b268351db4bd26843974a3c0ca917f7e0cca
Author: Peter Vernia <peter.vernia@gmail.com>
Date:   Sat Jul 7 03:09:19 2018 -0400

    staging: mt7621-pci: Add spaces after commas in pci-mt7621.c
    
    Adds spaces after commas in parameter lists in pci-mt7621.c
    
    Signed-off-by: Peter Vernia <peter.vernia@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/mt7621-pci/pci-mt7621.c b/drivers/staging/mt7621-pci/pci-mt7621.c
index c7932ae00db1..3c7978e4355d 100644
--- a/drivers/staging/mt7621-pci/pci-mt7621.c
+++ b/drivers/staging/mt7621-pci/pci-mt7621.c
@@ -399,10 +399,10 @@ set_phy_for_ssc(void)
 		if (reg >= 6) {
 			printk("***** Xtal 25MHz *****\n");
 			set_pcie_phy((u32 *)(RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x4bc),  4, 2, 0x01);	// RG_PE1_H_PLL_FBKSEL	//Feedback clock select
-			set_pcie_phy((u32 *)(RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x49c),  0,31, 0x18000000);	// RG_PE1_H_LCDDS_PCW_NCPO	//DDS NCPO PCW (for host mode)
-			set_pcie_phy((u32 *)(RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x4a4),  0,16, 0x18d);	// RG_PE1_H_LCDDS_SSC_PRD	//DDS SSC dither period control
-			set_pcie_phy((u32 *)(RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x4a8),  0,12, 0x4a);	// RG_PE1_H_LCDDS_SSC_DELTA	//DDS SSC dither amplitude control
-			set_pcie_phy((u32 *)(RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x4a8), 16,12, 0x4a);	// RG_PE1_H_LCDDS_SSC_DELTA1	//DDS SSC dither amplitude control for initial
+			set_pcie_phy((u32 *)(RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x49c),  0, 31, 0x18000000);	// RG_PE1_H_LCDDS_PCW_NCPO	//DDS NCPO PCW (for host mode)
+			set_pcie_phy((u32 *)(RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x4a4),  0, 16, 0x18d);	// RG_PE1_H_LCDDS_SSC_PRD	//DDS SSC dither period control
+			set_pcie_phy((u32 *)(RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x4a8),  0, 12, 0x4a);	// RG_PE1_H_LCDDS_SSC_DELTA	//DDS SSC dither amplitude control
+			set_pcie_phy((u32 *)(RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x4a8), 16, 12, 0x4a);	// RG_PE1_H_LCDDS_SSC_DELTA1	//DDS SSC dither amplitude control for initial
 		} else {
 			printk("***** Xtal 20MHz *****\n");
 		}
@@ -436,10 +436,10 @@ set_phy_for_ssc(void)
 		set_pcie_phy((u32 *)(RALINK_PCIEPHY_P2_CTL_OFFSET + 0x490),  6, 2, 0x00);	// RG_PE1_H_PLL_PREDIV	//Pre-divider ratio (for host mode)
 		if (reg >= 6) {		// 25MHz Xtal
 			set_pcie_phy((u32 *)(RALINK_PCIEPHY_P2_CTL_OFFSET + 0x4bc),  4, 2, 0x01);	// RG_PE1_H_PLL_FBKSEL	//Feedback clock select
-			set_pcie_phy((u32 *)(RALINK_PCIEPHY_P2_CTL_OFFSET + 0x49c),  0,31, 0x18000000);	// RG_PE1_H_LCDDS_PCW_NCPO	//DDS NCPO PCW (for host mode)
-			set_pcie_phy((u32 *)(RALINK_PCIEPHY_P2_CTL_OFFSET + 0x4a4),  0,16, 0x18d);	// RG_PE1_H_LCDDS_SSC_PRD	//DDS SSC dither period control
-			set_pcie_phy((u32 *)(RALINK_PCIEPHY_P2_CTL_OFFSET + 0x4a8),  0,12, 0x4a);	// RG_PE1_H_LCDDS_SSC_DELTA	//DDS SSC dither amplitude control
-			set_pcie_phy((u32 *)(RALINK_PCIEPHY_P2_CTL_OFFSET + 0x4a8), 16,12, 0x4a);	// RG_PE1_H_LCDDS_SSC_DELTA1	//DDS SSC dither amplitude control for initial
+			set_pcie_phy((u32 *)(RALINK_PCIEPHY_P2_CTL_OFFSET + 0x49c),  0, 31, 0x18000000);	// RG_PE1_H_LCDDS_PCW_NCPO	//DDS NCPO PCW (for host mode)
+			set_pcie_phy((u32 *)(RALINK_PCIEPHY_P2_CTL_OFFSET + 0x4a4),  0, 16, 0x18d);	// RG_PE1_H_LCDDS_SSC_PRD	//DDS SSC dither period control
+			set_pcie_phy((u32 *)(RALINK_PCIEPHY_P2_CTL_OFFSET + 0x4a8),  0, 12, 0x4a);	// RG_PE1_H_LCDDS_SSC_DELTA	//DDS SSC dither amplitude control
+			set_pcie_phy((u32 *)(RALINK_PCIEPHY_P2_CTL_OFFSET + 0x4a8), 16, 12, 0x4a);	// RG_PE1_H_LCDDS_SSC_DELTA1	//DDS SSC dither amplitude control for initial
 		}
 	}
 	set_pcie_phy((u32 *)(RALINK_PCIEPHY_P2_CTL_OFFSET + 0x4a0),  5, 1, 0x01);	// RG_PE1_LCDDS_CLK_PH_INV	//DDS clock inversion

commit d723b7cca52b89de0945cd7f90fad3c49930b394
Author: Peter Vernia <peter.vernia@gmail.com>
Date:   Sat Jul 7 03:08:36 2018 -0400

    staging: mt7621-pci: Fix spacing around equals sign
    
    Add spaces in front of the equals sign in assignment operations
    
    Signed-off-by: Peter Vernia <peter.vernia@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/mt7621-pci/pci-mt7621.c b/drivers/staging/mt7621-pci/pci-mt7621.c
index ded58bad08e7..c7932ae00db1 100644
--- a/drivers/staging/mt7621-pci/pci-mt7621.c
+++ b/drivers/staging/mt7621-pci/pci-mt7621.c
@@ -292,7 +292,7 @@ pci_config_write(struct pci_bus *bus, unsigned int devfn, int where, int size, u
 	}
 }
 
-struct pci_ops mt7621_pci_ops= {
+struct pci_ops mt7621_pci_ops = {
 	.read		= pci_config_read,
 	.write		= pci_config_write,
 };
@@ -480,8 +480,8 @@ static int mt7621_pci_probe(struct platform_device *pdev)
 	unsigned long val = 0;
 
 	iomem_resource.start = 0;
-	iomem_resource.end= ~0;
-	ioport_resource.start= 0;
+	iomem_resource.end = ~0;
+	ioport_resource.start = 0;
 	ioport_resource.end = ~0;
 
 	val = RALINK_PCIE0_RST;

commit b6c319606eb62c393a95bc53f9d4cbee31d5b88d
Author: Peter Vernia <peter.vernia@gmail.com>
Date:   Sat Jul 7 03:07:55 2018 -0400

    staging: mt7621-pci: Fix spaces around parenthesis in pci-7621.c
    
    Adds spaces before open parenthesis, and removes spaces after open parenthesis
    
    Signed-off-by: Peter Vernia <peter.vernia@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/mt7621-pci/pci-mt7621.c b/drivers/staging/mt7621-pci/pci-mt7621.c
index b373d761312a..ded58bad08e7 100644
--- a/drivers/staging/mt7621-pci/pci-mt7621.c
+++ b/drivers/staging/mt7621-pci/pci-mt7621.c
@@ -139,14 +139,14 @@
 			rt_sysc_m32(0, val, RALINK_RSTCTRL);		\
 		else							\
 			rt_sysc_m32(val, 0, RALINK_RSTCTRL);		\
-	} while(0)
+	} while (0)
 #define DEASSERT_SYSRST_PCIE(val)	\
 	do {								\
 		if (rt_sysc_r32(SYSC_REG_CHIP_REV) == 0x00030101)	\
 			rt_sysc_m32(val, 0, RALINK_RSTCTRL);		\
 		else							\
 			rt_sysc_m32(0, val, RALINK_RSTCTRL);		\
-	} while(0)
+	} while (0)
 #define RALINK_CLKCFG1			0x30
 #define RALINK_RSTCTRL			0x34
 #define RALINK_GPIOMODE			0x60
@@ -195,7 +195,7 @@ static int config_access(unsigned char access_type, struct pci_bus *bus,
 				(func << 8) | (where & 0xfc) | 0x80000000;
 	MV_WRITE(address_reg, address);
 
-	switch(access_type) {
+	switch (access_type) {
 	case PCI_ACCESS_WRITE_1:
 		MV_WRITE_8(data_reg+(where&0x3), *data);
 		break;
@@ -206,7 +206,7 @@ static int config_access(unsigned char access_type, struct pci_bus *bus,
 		MV_WRITE(data_reg, *data);
 		break;
 	case PCI_ACCESS_READ_1:
-		MV_READ_8( data_reg+(where&0x3), data);
+		MV_READ_8(data_reg+(where&0x3), data);
 		break;
 	case PCI_ACCESS_READ_2:
 		MV_READ_16(data_reg+(where&0x3), data);
@@ -391,7 +391,7 @@ set_phy_for_ssc(void)
 	set_pcie_phy((u32 *)(RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x100),  4, 1, 0x01);	// rg_pe1_frc_phy_en	//Force Port 1 enable control
 	set_pcie_phy((u32 *)(RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x000),  5, 1, 0x00);	// rg_pe1_phy_en	//Port 0 disable
 	set_pcie_phy((u32 *)(RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x100),  5, 1, 0x00);	// rg_pe1_phy_en	//Port 1 disable
-	if(reg <= 5 && reg >= 3) {	// 40MHz Xtal
+	if (reg <= 5 && reg >= 3) {	// 40MHz Xtal
 		set_pcie_phy((u32 *)(RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x490),  6, 2, 0x01);	// RG_PE1_H_PLL_PREDIV	//Pre-divider ratio (for host mode)
 		printk("***** Xtal 40MHz *****\n");
 	} else {			// 25MHz | 20MHz Xtal
@@ -414,7 +414,7 @@ set_phy_for_ssc(void)
 	set_pcie_phy((u32 *)(RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x490),  8, 4, 0x01);	// RG_PE1_H_PLL_IC
 	set_pcie_phy((u32 *)(RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x4ac), 16, 3, 0x00);	// RG_PE1_H_PLL_BR
 	set_pcie_phy((u32 *)(RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x490),  1, 3, 0x02);	// RG_PE1_PLL_DIVEN
-	if(reg <= 5 && reg >= 3) {	// 40MHz Xtal
+	if (reg <= 5 && reg >= 3) {	// 40MHz Xtal
 		set_pcie_phy((u32 *)(RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x414),  6, 2, 0x01);	// rg_pe1_mstckdiv		//value of da_pe1_mstckdiv when force mode enable
 		set_pcie_phy((u32 *)(RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x414),  5, 1, 0x01);	// rg_pe1_frc_mstckdiv	//force mode enable of da_pe1_mstckdiv
 	}
@@ -430,7 +430,7 @@ set_phy_for_ssc(void)
 	set_pcie_phy((u32 *)(RALINK_PCIEPHY_P2_CTL_OFFSET + 0x400),  9, 2, 0x00);	// rg_pe1_h_xtal_type
 	set_pcie_phy((u32 *)(RALINK_PCIEPHY_P2_CTL_OFFSET + 0x000),  4, 1, 0x01);	// rg_pe1_frc_phy_en	//Force Port 0 enable control
 	set_pcie_phy((u32 *)(RALINK_PCIEPHY_P2_CTL_OFFSET + 0x000),  5, 1, 0x00);	// rg_pe1_phy_en	//Port 0 disable
-	if(reg <= 5 && reg >= 3) {	// 40MHz Xtal
+	if (reg <= 5 && reg >= 3) {	// 40MHz Xtal
 		set_pcie_phy((u32 *)(RALINK_PCIEPHY_P2_CTL_OFFSET + 0x490),  6, 2, 0x01);	// RG_PE1_H_PLL_PREDIV	//Pre-divider ratio (for host mode)
 	} else {			// 25MHz | 20MHz Xtal
 		set_pcie_phy((u32 *)(RALINK_PCIEPHY_P2_CTL_OFFSET + 0x490),  6, 2, 0x00);	// RG_PE1_H_PLL_PREDIV	//Pre-divider ratio (for host mode)
@@ -449,7 +449,7 @@ set_phy_for_ssc(void)
 	set_pcie_phy((u32 *)(RALINK_PCIEPHY_P2_CTL_OFFSET + 0x490),  8, 4, 0x01);	// RG_PE1_H_PLL_IC
 	set_pcie_phy((u32 *)(RALINK_PCIEPHY_P2_CTL_OFFSET + 0x4ac), 16, 3, 0x00);	// RG_PE1_H_PLL_BR
 	set_pcie_phy((u32 *)(RALINK_PCIEPHY_P2_CTL_OFFSET + 0x490),  1, 3, 0x02);	// RG_PE1_PLL_DIVEN
-	if(reg <= 5 && reg >= 3) {	// 40MHz Xtal
+	if (reg <= 5 && reg >= 3) {	// 40MHz Xtal
 		set_pcie_phy((u32 *)(RALINK_PCIEPHY_P2_CTL_OFFSET + 0x414),  6, 2, 0x01);	// rg_pe1_mstckdiv		//value of da_pe1_mstckdiv when force mode enable
 		set_pcie_phy((u32 *)(RALINK_PCIEPHY_P2_CTL_OFFSET + 0x414),  5, 1, 0x01);	// rg_pe1_frc_mstckdiv	//force mode enable of da_pe1_mstckdiv
 	}
@@ -532,7 +532,7 @@ static int mt7621_pci_probe(struct platform_device *pdev)
 	*(unsigned int *)(0xbe000620) |= 0x1<<19 | 0x1<<8 | 0x1<<7;		// set DATA
 	mdelay(1000);
 
-	if(( RALINK_PCI0_STATUS & 0x1) == 0)
+	if ((RALINK_PCI0_STATUS & 0x1) == 0)
 	{
 		printk("PCIE0 no card, disable it(RST&CLK)\n");
 		ASSERT_SYSRST_PCIE(RALINK_PCIE0_RST);
@@ -543,7 +543,7 @@ static int mt7621_pci_probe(struct platform_device *pdev)
 		RALINK_PCI_PCIMSK_ADDR |= (1<<20); // enable pcie1 interrupt
 	}
 
-	if(( RALINK_PCI1_STATUS & 0x1) == 0)
+	if ((RALINK_PCI1_STATUS & 0x1) == 0)
 	{
 		printk("PCIE1 no card, disable it(RST&CLK)\n");
 		ASSERT_SYSRST_PCIE(RALINK_PCIE1_RST);
@@ -554,7 +554,7 @@ static int mt7621_pci_probe(struct platform_device *pdev)
 		RALINK_PCI_PCIMSK_ADDR |= (1<<21); // enable pcie1 interrupt
 	}
 
-	if (( RALINK_PCI2_STATUS & 0x1) == 0) {
+	if ((RALINK_PCI2_STATUS & 0x1) == 0) {
 		printk("PCIE2 no card, disable it(RST&CLK)\n");
 		ASSERT_SYSRST_PCIE(RALINK_PCIE2_RST);
 		rt_sysc_m32(RALINK_PCIE2_CLK_EN, 0, RALINK_CLKCFG1);
@@ -578,7 +578,7 @@ pcie(2/1/0) link status	pcie2_num	pcie1_num	pcie0_num
 3'b110			1		0		x
 3'b111			2		1		0
 */
-	switch(pcie_link_status) {
+	switch (pcie_link_status) {
 	case 2:
 		RALINK_PCI_PCICFG_ADDR &= ~0x00ff0000;
 		RALINK_PCI_PCICFG_ADDR |= 0x1 << 16;	//port0
@@ -613,7 +613,7 @@ pcie(2/1/0) link status	pcie2_num	pcie1_num	pcie0_num
 	RALINK_PCI_IOBASE = RALINK_PCI_IO_MAP_BASE;
 
 	//PCIe0
-	if((pcie_link_status & 0x1) != 0) {
+	if ((pcie_link_status & 0x1) != 0) {
 		RALINK_PCI0_BAR0SETUP_ADDR = 0x7FFF0001;	//open 7FFF:2G; ENABLE
 		RALINK_PCI0_IMBASEBAR0_ADDR = MEMORY_BASE;
 		RALINK_PCI0_CLASS = 0x06040001;
@@ -636,7 +636,7 @@ pcie(2/1/0) link status	pcie2_num	pcie1_num	pcie0_num
 		printk("PCIE2 enabled\n");
 	}
 
-	switch(pcie_link_status) {
+	switch (pcie_link_status) {
 	case 7:
 		read_config(0, 2, 0, 0x4, &val);
 		write_config(0, 2, 0, 0x4, val|0x4);

commit 0d6485282a2eb8839ecb98d4da2dc1c35aab7223
Author: Abdun Nihaal <abdun.nihaal@gmail.com>
Date:   Sat Jun 9 18:37:42 2018 +0530

    staging: mt7621-pci: Fix coding style error
    
    This patch removes space after * to fix the following checkpatch error:
    
    ERROR: "foo * bar" should be "foo *bar"
    
    Signed-off-by: Abdun Nihaal <abdun.nihaal@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/mt7621-pci/pci-mt7621.c b/drivers/staging/mt7621-pci/pci-mt7621.c
index 5957205feb46..b373d761312a 100644
--- a/drivers/staging/mt7621-pci/pci-mt7621.c
+++ b/drivers/staging/mt7621-pci/pci-mt7621.c
@@ -181,7 +181,7 @@ static int pcie_link_status = 0;
 #define PCI_ACCESS_WRITE_4 5
 
 static int config_access(unsigned char access_type, struct pci_bus *bus,
-			unsigned int devfn, unsigned int where, u32 * data)
+			unsigned int devfn, unsigned int where, u32 *data)
 {
 	unsigned int slot = PCI_SLOT(devfn);
 	u8 func = PCI_FUNC(devfn);
@@ -222,19 +222,19 @@ static int config_access(unsigned char access_type, struct pci_bus *bus,
 }
 
 static int
-read_config_byte(struct pci_bus *bus, unsigned int devfn, int where, u8 * val)
+read_config_byte(struct pci_bus *bus, unsigned int devfn, int where, u8 *val)
 {
 	return config_access(PCI_ACCESS_READ_1, bus, devfn, (unsigned int)where, (u32 *)val);
 }
 
 static int
-read_config_word(struct pci_bus *bus, unsigned int devfn, int where, u16 * val)
+read_config_word(struct pci_bus *bus, unsigned int devfn, int where, u16 *val)
 {
 	return config_access(PCI_ACCESS_READ_2, bus, devfn, (unsigned int)where, (u32 *)val);
 }
 
 static int
-read_config_dword(struct pci_bus *bus, unsigned int devfn, int where, u32 * val)
+read_config_dword(struct pci_bus *bus, unsigned int devfn, int where, u32 *val)
 {
 	return config_access(PCI_ACCESS_READ_4, bus, devfn, (unsigned int)where, (u32 *)val);
 }
@@ -267,7 +267,7 @@ write_config_dword(struct pci_bus *bus, unsigned int devfn, int where, u32 val)
 }
 
 static int
-pci_config_read(struct pci_bus *bus, unsigned int devfn, int where, int size, u32 * val)
+pci_config_read(struct pci_bus *bus, unsigned int devfn, int where, int size, u32 *val)
 {
 	switch (size) {
 	case 1:

commit c0f784ba92e051d0de33ca7e1fd192317cfdb738
Author: NeilBrown <neil@brown.name>
Date:   Thu Jun 7 08:04:20 2018 +1000

    staging: mt7621-pci: use rt_sysc_?32() to access system-control register.
    
    This driver currently has internal knowledge ofthe address
    of system-control registers and accesses them by dereferencing
    a constant pointer.
    
    It is cleaner to use rt_sysc_r32(), rt_sysc_w32(), rt_sysc_m32()
    which is a more standard interface.
    So change the defined names to offsets instead of pointers,
    and use these functions.
    
    Signed-off-by: NeilBrown <neil@brown.name>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/mt7621-pci/pci-mt7621.c b/drivers/staging/mt7621-pci/pci-mt7621.c
index 17f2105ec698..5957205feb46 100644
--- a/drivers/staging/mt7621-pci/pci-mt7621.c
+++ b/drivers/staging/mt7621-pci/pci-mt7621.c
@@ -55,6 +55,7 @@
 #include <linux/platform_device.h>
 
 #include <ralink_regs.h>
+#include <mt7621.h>
 
 /*
  * These functions and structures provide the BIOS scan and mapping of the PCI
@@ -72,7 +73,6 @@
 #define RALINK_PCIE0_RST		(1<<24)
 #define RALINK_PCIE1_RST		(1<<25)
 #define RALINK_PCIE2_RST		(1<<26)
-#define RALINK_SYSCTL_BASE		0xBE000000
 
 #define RALINK_PCI_PCICFG_ADDR		*(volatile u32 *)(RALINK_PCI_BASE + 0x0000)
 #define RALINK_PCI_PCIMSK_ADDR		*(volatile u32 *)(RALINK_PCI_BASE + 0x000C)
@@ -133,31 +133,28 @@
 #define RALINK_PCI_MM_MAP_BASE		0x60000000
 #define RALINK_PCI_IO_MAP_BASE		0x1e160000
 
-#define RALINK_SYSTEM_CONTROL_BASE	0xbe000000
-
 #define ASSERT_SYSRST_PCIE(val)		\
 	do {								\
-		if (*(unsigned int *)(0xbe00000c) == 0x00030101)	\
-			RALINK_RSTCTRL |= val;				\
+		if (rt_sysc_r32(SYSC_REG_CHIP_REV) == 0x00030101)	\
+			rt_sysc_m32(0, val, RALINK_RSTCTRL);		\
 		else							\
-			RALINK_RSTCTRL &= ~val;				\
+			rt_sysc_m32(val, 0, RALINK_RSTCTRL);		\
 	} while(0)
 #define DEASSERT_SYSRST_PCIE(val)	\
 	do {								\
-		if (*(unsigned int *)(0xbe00000c) == 0x00030101)	\
-			RALINK_RSTCTRL &= ~val;				\
+		if (rt_sysc_r32(SYSC_REG_CHIP_REV) == 0x00030101)	\
+			rt_sysc_m32(val, 0, RALINK_RSTCTRL);		\
 		else							\
-			RALINK_RSTCTRL |= val;				\
+			rt_sysc_m32(0, val, RALINK_RSTCTRL);		\
 	} while(0)
-#define RALINK_SYSCFG1			*(unsigned int *)(RALINK_SYSTEM_CONTROL_BASE + 0x14)
-#define RALINK_CLKCFG1			*(unsigned int *)(RALINK_SYSTEM_CONTROL_BASE + 0x30)
-#define RALINK_RSTCTRL			*(unsigned int *)(RALINK_SYSTEM_CONTROL_BASE + 0x34)
-#define RALINK_GPIOMODE			*(unsigned int *)(RALINK_SYSTEM_CONTROL_BASE + 0x60)
-#define RALINK_PCIE_CLK_GEN		*(unsigned int *)(RALINK_SYSTEM_CONTROL_BASE + 0x7c)
-#define RALINK_PCIE_CLK_GEN1		*(unsigned int *)(RALINK_SYSTEM_CONTROL_BASE + 0x80)
-#define PPLL_CFG1			*(unsigned int *)(RALINK_SYSTEM_CONTROL_BASE + 0x9c)
-#define PPLL_DRV			*(unsigned int *)(RALINK_SYSTEM_CONTROL_BASE + 0xa0)
-//RALINK_SYSCFG1 bit
+#define RALINK_CLKCFG1			0x30
+#define RALINK_RSTCTRL			0x34
+#define RALINK_GPIOMODE			0x60
+#define RALINK_PCIE_CLK_GEN		0x7c
+#define RALINK_PCIE_CLK_GEN1		0x80
+#define PPLL_CFG1			0x9c
+#define PPLL_DRV			0xa0
+/* SYSC_REG_SYSTEM_CONFIG1 bits */
 #define RALINK_PCI_HOST_MODE_EN		(1<<7)
 #define RALINK_PCIE_RC_MODE_EN		(1<<8)
 //RALINK_RSTCTRL bit
@@ -383,7 +380,7 @@ bypass_pipe_rst(void)
 void
 set_phy_for_ssc(void)
 {
-	unsigned long reg = (*(volatile u32 *)(RALINK_SYSCTL_BASE + 0x10));
+	unsigned long reg = rt_sysc_r32(SYSC_REG_SYSTEM_CONFIG0);
 
 	reg = (reg >> 6) & 0x7;
 	/* Set PCIe Port0 & Port1 PHY to disable SSC */
@@ -521,15 +518,15 @@ static int mt7621_pci_probe(struct platform_device *pdev)
 	read_config(0, 2, 0, 0x70c, &val);
 	printk("Port 2 N_FTS = %x\n", (unsigned int)val);
 
-	RALINK_RSTCTRL = (RALINK_RSTCTRL | RALINK_PCIE_RST);
-	RALINK_SYSCFG1 &= ~(0x30);
-	RALINK_SYSCFG1 |= (2<<4);
-	RALINK_PCIE_CLK_GEN &= 0x7fffffff;
-	RALINK_PCIE_CLK_GEN1 &= 0x80ffffff;
-	RALINK_PCIE_CLK_GEN1 |= 0xa << 24;
-	RALINK_PCIE_CLK_GEN |= 0x80000000;
+	rt_sysc_m32(0, RALINK_PCIE_RST, RALINK_RSTCTRL);
+	rt_sysc_m32(0x30, 2 << 4, SYSC_REG_SYSTEM_CONFIG1);
+
+	rt_sysc_m32(0x80000000, 0, RALINK_PCIE_CLK_GEN);
+	rt_sysc_m32(0x7f000000, 0xa << 24, RALINK_PCIE_CLK_GEN1);
+	rt_sysc_m32(0, 0x80000000, RALINK_PCIE_CLK_GEN);
+
 	mdelay(50);
-	RALINK_RSTCTRL = (RALINK_RSTCTRL & ~RALINK_PCIE_RST);
+	rt_sysc_m32(RALINK_PCIE_RST, 0, RALINK_RSTCTRL);
 
 	/* Use GPIO control instead of PERST_N */
 	*(unsigned int *)(0xbe000620) |= 0x1<<19 | 0x1<<8 | 0x1<<7;		// set DATA
@@ -539,7 +536,7 @@ static int mt7621_pci_probe(struct platform_device *pdev)
 	{
 		printk("PCIE0 no card, disable it(RST&CLK)\n");
 		ASSERT_SYSRST_PCIE(RALINK_PCIE0_RST);
-		RALINK_CLKCFG1 = (RALINK_CLKCFG1 & ~RALINK_PCIE0_CLK_EN);
+		rt_sysc_m32(RALINK_PCIE0_CLK_EN, 0, RALINK_CLKCFG1);
 		pcie_link_status &= ~(1<<0);
 	} else {
 		pcie_link_status |= 1<<0;
@@ -550,7 +547,7 @@ static int mt7621_pci_probe(struct platform_device *pdev)
 	{
 		printk("PCIE1 no card, disable it(RST&CLK)\n");
 		ASSERT_SYSRST_PCIE(RALINK_PCIE1_RST);
-		RALINK_CLKCFG1 = (RALINK_CLKCFG1 & ~RALINK_PCIE1_CLK_EN);
+		rt_sysc_m32(RALINK_PCIE1_CLK_EN, 0, RALINK_CLKCFG1);
 		pcie_link_status &= ~(1<<1);
 	} else {
 		pcie_link_status |= 1<<1;
@@ -560,7 +557,7 @@ static int mt7621_pci_probe(struct platform_device *pdev)
 	if (( RALINK_PCI2_STATUS & 0x1) == 0) {
 		printk("PCIE2 no card, disable it(RST&CLK)\n");
 		ASSERT_SYSRST_PCIE(RALINK_PCIE2_RST);
-		RALINK_CLKCFG1 = (RALINK_CLKCFG1 & ~RALINK_PCIE2_CLK_EN);
+		rt_sysc_m32(RALINK_PCIE2_CLK_EN, 0, RALINK_CLKCFG1);
 		pcie_link_status &= ~(1<<2);
 	} else {
 		pcie_link_status |= 1<<2;

commit 86417b7cccbc8728924b3b8304d6e9c51a146af0
Author: Sankalp Negi <sankalpnegi2310@gmail.com>
Date:   Sun May 27 18:42:15 2018 +0530

    staging: mt7621-pci: Fix line size exceeding 80 columns.
    
    This patch fixes the checkpatch.pl warning:
    
    WARNING: line over 80 characters
    
    Signed-off-by: Sankalp Negi <sankalpnegi2310@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/mt7621-pci/pci-mt7621.c b/drivers/staging/mt7621-pci/pci-mt7621.c
index edd95013faf3..17f2105ec698 100644
--- a/drivers/staging/mt7621-pci/pci-mt7621.c
+++ b/drivers/staging/mt7621-pci/pci-mt7621.c
@@ -194,7 +194,8 @@ static int config_access(unsigned char access_type, struct pci_bus *bus,
 	address_reg = RALINK_PCI_CONFIG_ADDR;
 	data_reg = RALINK_PCI_CONFIG_DATA_VIRTUAL_REG;
 
-	address = (((where&0xF00)>>8)<<24) |(bus->number << 16) | (slot << 11) | (func << 8) | (where & 0xfc) | 0x80000000;
+	address = (((where&0xF00)>>8)<<24) |(bus->number << 16) | (slot << 11) |
+				(func << 8) | (where & 0xfc) | 0x80000000;
 	MV_WRITE(address_reg, address);
 
 	switch(access_type) {

commit bb52645a9ce9fa16600a5c189d22527e871422de
Author: NeilBrown <neil@brown.name>
Date:   Fri May 4 14:58:36 2018 +1000

    staging: mt7621-pci: remove some dead code.
    
    Some code is dead because it is commented out.
    Some is dead because it is uninteresting printks.
    Some is dead because it declares unused functions.
    
    Remove it all.
    
    Signed-off-by: NeilBrown <neil@brown.name>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/mt7621-pci/pci-mt7621.c b/drivers/staging/mt7621-pci/pci-mt7621.c
index 5094e90eaf69..edd95013faf3 100644
--- a/drivers/staging/mt7621-pci/pci-mt7621.c
+++ b/drivers/staging/mt7621-pci/pci-mt7621.c
@@ -56,9 +56,6 @@
 
 #include <ralink_regs.h>
 
-extern void pcie_phy_init(void);
-extern void chk_phy_pll(void);
-
 /*
  * These functions and structures provide the BIOS scan and mapping of the PCI
  * devices.
@@ -364,11 +361,8 @@ pcibios_map_irq(const struct pci_dev *dev, u8 slot, u8 pin)
 void
 set_pcie_phy(u32 *addr, int start_b, int bits, int val)
 {
-//	printk("0x%p:", addr);
-//	printk(" %x", *addr);
 	*(unsigned int *)(addr) &= ~(((1<<bits) - 1)<<start_b);
 	*(unsigned int *)(addr) |= val << start_b;
-//	printk(" -> %x\n", *addr);
 }
 
 void
@@ -497,7 +491,6 @@ static int mt7621_pci_probe(struct platform_device *pdev)
 	val |= RALINK_PCIE2_RST;
 
 	ASSERT_SYSRST_PCIE(RALINK_PCIE0_RST | RALINK_PCIE1_RST | RALINK_PCIE2_RST);
-	printk("pull PCIe RST: RALINK_RSTCTRL = %x\n", RALINK_RSTCTRL);
 
 	*(unsigned int *)(0xbe000060) &= ~(0x3<<10 | 0x3<<3);
 	*(unsigned int *)(0xbe000060) |= 0x1<<10 | 0x1<<3;
@@ -513,12 +506,10 @@ static int mt7621_pci_probe(struct platform_device *pdev)
 	val |= RALINK_PCIE2_RST;
 
 	DEASSERT_SYSRST_PCIE(val);
-	printk("release PCIe RST: RALINK_RSTCTRL = %x\n", RALINK_RSTCTRL);
 
 	if ((*(unsigned int *)(0xbe00000c)&0xFFFF) == 0x0101) // MT7621 E2
 		bypass_pipe_rst();
 	set_phy_for_ssc();
-	printk("release PCIe RST: RALINK_RSTCTRL = %x\n", RALINK_RSTCTRL);
 
 	read_config(0, 0, 0, 0x70c, &val);
 	printk("Port 0 N_FTS = %x\n", (unsigned int)val);
@@ -614,8 +605,6 @@ pcie(2/1/0) link status	pcie2_num	pcie1_num	pcie0_num
 		RALINK_PCI_PCICFG_ADDR |= 0x1 << 24;	//port2
 		break;
 	}
-	printk(" -> %x\n", RALINK_PCI_PCICFG_ADDR);
-	//printk(" RALINK_PCI_ARBCTL = %x\n", RALINK_PCI_ARBCTL);
 
 /*
 	ioport_resource.start = mt7621_res_pci_io1.start;
@@ -653,7 +642,6 @@ pcie(2/1/0) link status	pcie2_num	pcie1_num	pcie0_num
 	case 7:
 		read_config(0, 2, 0, 0x4, &val);
 		write_config(0, 2, 0, 0x4, val|0x4);
-		// write_config(0, 1, 0, 0x4, val|0x7);
 		read_config(0, 2, 0, 0x70c, &val);
 		val &= ~(0xff)<<8;
 		val |= 0x50<<8;
@@ -663,7 +651,6 @@ pcie(2/1/0) link status	pcie2_num	pcie1_num	pcie0_num
 	case 6:
 		read_config(0, 1, 0, 0x4, &val);
 		write_config(0, 1, 0, 0x4, val|0x4);
-		// write_config(0, 1, 0, 0x4, val|0x7);
 		read_config(0, 1, 0, 0x70c, &val);
 		val &= ~(0xff)<<8;
 		val |= 0x50<<8;
@@ -671,7 +658,6 @@ pcie(2/1/0) link status	pcie2_num	pcie1_num	pcie0_num
 	default:
 		read_config(0, 0, 0, 0x4, &val);
 		write_config(0, 0, 0, 0x4, val|0x4); //bus master enable
-		// write_config(0, 0, 0, 0x4, val|0x7); //bus master enable
 		read_config(0, 0, 0, 0x70c, &val);
 		val &= ~(0xff)<<8;
 		val |= 0x50<<8;

commit a6f17484153391aab8feedd6c9574cc3db80d6cd
Author: NeilBrown <neil@brown.name>
Date:   Fri May 4 14:58:36 2018 +1000

    staging: mt7621-pci: remove unnecessary resource details.
    
    These resources are extracted from devicetree, so they aren't
    needed here.
    
    Signed-off-by: NeilBrown <neil@brown.name>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/mt7621-pci/pci-mt7621.c b/drivers/staging/mt7621-pci/pci-mt7621.c
index 616960e01052..5094e90eaf69 100644
--- a/drivers/staging/mt7621-pci/pci-mt7621.c
+++ b/drivers/staging/mt7621-pci/pci-mt7621.c
@@ -302,27 +302,12 @@ struct pci_ops mt7621_pci_ops= {
 	.write		= pci_config_write,
 };
 
-static struct resource mt7621_res_pci_mem1 = {
-	.name		= "PCI MEM1",
-	.start		= RALINK_PCI_MM_MAP_BASE,
-	.end		= (u32)((RALINK_PCI_MM_MAP_BASE + (unsigned char *)0x0fffffff)),
-	.flags		= IORESOURCE_MEM,
-};
-
-static struct resource mt7621_res_pci_io1 = {
-	.name		= "PCI I/O1",
-	.start		= RALINK_PCI_IO_MAP_BASE,
-	.end		= (u32)((RALINK_PCI_IO_MAP_BASE + (unsigned char *)0x0ffff)),
-	.flags		= IORESOURCE_IO,
-};
-
+static struct resource mt7621_res_pci_mem1;
+static struct resource mt7621_res_pci_io1;
 static struct pci_controller mt7621_controller = {
 	.pci_ops	= &mt7621_pci_ops,
 	.mem_resource	= &mt7621_res_pci_mem1,
 	.io_resource	= &mt7621_res_pci_io1,
-	.mem_offset	= 0x00000000UL,
-	.io_offset	= 0x00000000UL,
-	.io_map_base	= 0xa0000000,
 };
 
 static void

commit bba9b3ec0f1891d8b516f5502794be6fa3eb0d13
Author: NeilBrown <neil@brown.name>
Date:   Fri May 4 14:58:36 2018 +1000

    staging: mt7621-pci: remove conditional compilation.
    
    Code currently defines:
    
    #define CONFIG_PCIE_PORT0
    #define CONFIG_PCIE_PORT1
    #define CONFIG_PCIE_PORT2
    #define GPIO_PERST
    
    and then compiles code only if they are defined.
    We might want to disable some of these via devicetree one
    day, but for now just remove the #defines and the
    conditions - all the code for different ports is
    easy to identify.
    
    Signed-off-by: NeilBrown <neil@brown.name>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/mt7621-pci/pci-mt7621.c b/drivers/staging/mt7621-pci/pci-mt7621.c
index c8d7b47c8952..616960e01052 100644
--- a/drivers/staging/mt7621-pci/pci-mt7621.c
+++ b/drivers/staging/mt7621-pci/pci-mt7621.c
@@ -64,9 +64,6 @@ extern void chk_phy_pll(void);
  * devices.
  */
 
-#define CONFIG_PCIE_PORT0
-#define CONFIG_PCIE_PORT1
-#define CONFIG_PCIE_PORT2
 #define RALINK_PCIE0_CLK_EN		(1<<24)
 #define RALINK_PCIE1_CLK_EN		(1<<25)
 #define RALINK_PCIE2_CLK_EN		(1<<26)
@@ -140,7 +137,7 @@ extern void chk_phy_pll(void);
 #define RALINK_PCI_IO_MAP_BASE		0x1e160000
 
 #define RALINK_SYSTEM_CONTROL_BASE	0xbe000000
-#define GPIO_PERST
+
 #define ASSERT_SYSRST_PCIE(val)		\
 	do {								\
 		if (*(unsigned int *)(0xbe00000c) == 0x00030101)	\
@@ -392,21 +389,15 @@ set_pcie_phy(u32 *addr, int start_b, int bits, int val)
 void
 bypass_pipe_rst(void)
 {
-#if defined (CONFIG_PCIE_PORT0)
 	/* PCIe Port 0 */
 	set_pcie_phy((u32 *)(RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x02c), 12, 1, 0x01);	// rg_pe1_pipe_rst_b
 	set_pcie_phy((u32 *)(RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x02c),  4, 1, 0x01);	// rg_pe1_pipe_cmd_frc[4]
-#endif
-#if defined (CONFIG_PCIE_PORT1)
 	/* PCIe Port 1 */
 	set_pcie_phy((u32 *)(RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x12c), 12, 1, 0x01);	// rg_pe1_pipe_rst_b
 	set_pcie_phy((u32 *)(RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x12c),  4, 1, 0x01);	// rg_pe1_pipe_cmd_frc[4]
-#endif
-#if defined (CONFIG_PCIE_PORT2)
 	/* PCIe Port 2 */
 	set_pcie_phy((u32 *)(RALINK_PCIEPHY_P2_CTL_OFFSET + 0x02c), 12, 1, 0x01);	// rg_pe1_pipe_rst_b
 	set_pcie_phy((u32 *)(RALINK_PCIEPHY_P2_CTL_OFFSET + 0x02c),  4, 1, 0x01);	// rg_pe1_pipe_cmd_frc[4]
-#endif
 }
 
 void
@@ -415,7 +406,6 @@ set_phy_for_ssc(void)
 	unsigned long reg = (*(volatile u32 *)(RALINK_SYSCTL_BASE + 0x10));
 
 	reg = (reg >> 6) & 0x7;
-#if defined (CONFIG_PCIE_PORT0) || defined (CONFIG_PCIE_PORT1)
 	/* Set PCIe Port0 & Port1 PHY to disable SSC */
 	/* Debug Xtal Type */
 	set_pcie_phy((u32 *)(RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x400),  8, 1, 0x01);	// rg_pe1_frc_h_xtal_type
@@ -456,8 +446,7 @@ set_phy_for_ssc(void)
 	set_pcie_phy((u32 *)(RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x100),  5, 1, 0x01);	// rg_pe1_phy_en	//Port 1 enable
 	set_pcie_phy((u32 *)(RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x000),  4, 1, 0x00);	// rg_pe1_frc_phy_en	//Force Port 0 disable control
 	set_pcie_phy((u32 *)(RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x100),  4, 1, 0x00);	// rg_pe1_frc_phy_en	//Force Port 1 disable control
-#endif
-#if defined (CONFIG_PCIE_PORT2)
+
 	/* Set PCIe Port2 PHY to disable SSC */
 	/* Debug Xtal Type */
 	set_pcie_phy((u32 *)(RALINK_PCIEPHY_P2_CTL_OFFSET + 0x400),  8, 1, 0x01);	// rg_pe1_frc_h_xtal_type
@@ -490,7 +479,6 @@ set_phy_for_ssc(void)
 	/* Enable PHY and disable force mode */
 	set_pcie_phy((u32 *)(RALINK_PCIEPHY_P2_CTL_OFFSET + 0x000),  5, 1, 0x01);	// rg_pe1_phy_en	//Port 0 enable
 	set_pcie_phy((u32 *)(RALINK_PCIEPHY_P2_CTL_OFFSET + 0x000),  4, 1, 0x00);	// rg_pe1_frc_phy_en	//Force Port 0 disable control
-#endif
 }
 
 void setup_cm_memory_region(struct resource *mem_resource)
@@ -519,18 +507,13 @@ static int mt7621_pci_probe(struct platform_device *pdev)
 	ioport_resource.start= 0;
 	ioport_resource.end = ~0;
 
-#if defined (CONFIG_PCIE_PORT0)
 	val = RALINK_PCIE0_RST;
-#endif
-#if defined (CONFIG_PCIE_PORT1)
 	val |= RALINK_PCIE1_RST;
-#endif
-#if defined (CONFIG_PCIE_PORT2)
 	val |= RALINK_PCIE2_RST;
-#endif
+
 	ASSERT_SYSRST_PCIE(RALINK_PCIE0_RST | RALINK_PCIE1_RST | RALINK_PCIE2_RST);
 	printk("pull PCIe RST: RALINK_RSTCTRL = %x\n", RALINK_RSTCTRL);
-#if defined GPIO_PERST /* add GPIO control instead of PERST_N */ /*chhung*/
+
 	*(unsigned int *)(0xbe000060) &= ~(0x3<<10 | 0x3<<3);
 	*(unsigned int *)(0xbe000060) |= 0x1<<10 | 0x1<<3;
 	mdelay(100);
@@ -539,18 +522,11 @@ static int mt7621_pci_probe(struct platform_device *pdev)
 	*(unsigned int *)(0xbe000620) &= ~(0x1<<19 | 0x1<<8 | 0x1<<7);		// clear DATA
 
 	mdelay(100);
-#else
-	*(unsigned int *)(0xbe000060) &= ~0x00000c00;
-#endif
-#if defined (CONFIG_PCIE_PORT0)
+
 	val = RALINK_PCIE0_RST;
-#endif
-#if defined (CONFIG_PCIE_PORT1)
 	val |= RALINK_PCIE1_RST;
-#endif
-#if defined (CONFIG_PCIE_PORT2)
 	val |= RALINK_PCIE2_RST;
-#endif
+
 	DEASSERT_SYSRST_PCIE(val);
 	printk("release PCIe RST: RALINK_RSTCTRL = %x\n", RALINK_RSTCTRL);
 
@@ -559,18 +535,14 @@ static int mt7621_pci_probe(struct platform_device *pdev)
 	set_phy_for_ssc();
 	printk("release PCIe RST: RALINK_RSTCTRL = %x\n", RALINK_RSTCTRL);
 
-#if defined (CONFIG_PCIE_PORT0)
 	read_config(0, 0, 0, 0x70c, &val);
 	printk("Port 0 N_FTS = %x\n", (unsigned int)val);
-#endif
-#if defined (CONFIG_PCIE_PORT1)
+
 	read_config(0, 1, 0, 0x70c, &val);
 	printk("Port 1 N_FTS = %x\n", (unsigned int)val);
-#endif
-#if defined (CONFIG_PCIE_PORT2)
+
 	read_config(0, 2, 0, 0x70c, &val);
 	printk("Port 2 N_FTS = %x\n", (unsigned int)val);
-#endif
 
 	RALINK_RSTCTRL = (RALINK_RSTCTRL | RALINK_PCIE_RST);
 	RALINK_SYSCFG1 &= ~(0x30);
@@ -582,16 +554,10 @@ static int mt7621_pci_probe(struct platform_device *pdev)
 	mdelay(50);
 	RALINK_RSTCTRL = (RALINK_RSTCTRL & ~RALINK_PCIE_RST);
 
-#if defined GPIO_PERST /* add GPIO control instead of PERST_N */  /*chhung*/
+	/* Use GPIO control instead of PERST_N */
 	*(unsigned int *)(0xbe000620) |= 0x1<<19 | 0x1<<8 | 0x1<<7;		// set DATA
-	mdelay(100);
-#else
-	RALINK_PCI_PCICFG_ADDR &= ~(1<<1); //de-assert PERST
-#endif
-	mdelay(500);
+	mdelay(1000);
 
-	mdelay(500);
-#if defined (CONFIG_PCIE_PORT0)
 	if(( RALINK_PCI0_STATUS & 0x1) == 0)
 	{
 		printk("PCIE0 no card, disable it(RST&CLK)\n");
@@ -602,8 +568,7 @@ static int mt7621_pci_probe(struct platform_device *pdev)
 		pcie_link_status |= 1<<0;
 		RALINK_PCI_PCIMSK_ADDR |= (1<<20); // enable pcie1 interrupt
 	}
-#endif
-#if defined (CONFIG_PCIE_PORT1)
+
 	if(( RALINK_PCI1_STATUS & 0x1) == 0)
 	{
 		printk("PCIE1 no card, disable it(RST&CLK)\n");
@@ -614,8 +579,7 @@ static int mt7621_pci_probe(struct platform_device *pdev)
 		pcie_link_status |= 1<<1;
 		RALINK_PCI_PCIMSK_ADDR |= (1<<21); // enable pcie1 interrupt
 	}
-#endif
-#if defined (CONFIG_PCIE_PORT2)
+
 	if (( RALINK_PCI2_STATUS & 0x1) == 0) {
 		printk("PCIE2 no card, disable it(RST&CLK)\n");
 		ASSERT_SYSRST_PCIE(RALINK_PCIE2_RST);
@@ -625,7 +589,7 @@ static int mt7621_pci_probe(struct platform_device *pdev)
 		pcie_link_status |= 1<<2;
 		RALINK_PCI_PCIMSK_ADDR |= (1<<22); // enable pcie2 interrupt
 	}
-#endif
+
 	if (pcie_link_status == 0)
 		return 0;
 
@@ -676,7 +640,6 @@ pcie(2/1/0) link status	pcie2_num	pcie1_num	pcie0_num
 	RALINK_PCI_MEMBASE = 0xffffffff; //RALINK_PCI_MM_MAP_BASE;
 	RALINK_PCI_IOBASE = RALINK_PCI_IO_MAP_BASE;
 
-#if defined (CONFIG_PCIE_PORT0)
 	//PCIe0
 	if((pcie_link_status & 0x1) != 0) {
 		RALINK_PCI0_BAR0SETUP_ADDR = 0x7FFF0001;	//open 7FFF:2G; ENABLE
@@ -684,8 +647,7 @@ pcie(2/1/0) link status	pcie2_num	pcie1_num	pcie0_num
 		RALINK_PCI0_CLASS = 0x06040001;
 		printk("PCIE0 enabled\n");
 	}
-#endif
-#if defined (CONFIG_PCIE_PORT1)
+
 	//PCIe1
 	if ((pcie_link_status & 0x2) != 0) {
 		RALINK_PCI1_BAR0SETUP_ADDR = 0x7FFF0001;	//open 7FFF:2G; ENABLE
@@ -693,8 +655,7 @@ pcie(2/1/0) link status	pcie2_num	pcie1_num	pcie0_num
 		RALINK_PCI1_CLASS = 0x06040001;
 		printk("PCIE1 enabled\n");
 	}
-#endif
-#if defined (CONFIG_PCIE_PORT2)
+
 	//PCIe2
 	if ((pcie_link_status & 0x4) != 0) {
 		RALINK_PCI2_BAR0SETUP_ADDR = 0x7FFF0001;	//open 7FFF:2G; ENABLE
@@ -702,7 +663,6 @@ pcie(2/1/0) link status	pcie2_num	pcie1_num	pcie0_num
 		RALINK_PCI2_CLASS = 0x06040001;
 		printk("PCIE2 enabled\n");
 	}
-#endif
 
 	switch(pcie_link_status) {
 	case 7:

commit d4e3a1f6cea79ef49ad1de098a4f9ca5a4f5f00c
Author: NeilBrown <neil@brown.name>
Date:   Fri May 4 14:58:36 2018 +1000

    staging: mt7621-pci: white-space cleanups.
    
    - remove white space at end of line.
    - no more than 2 blank line at a time
    - remove spaces before tabs
    - use tabs to line things up
    - re-indent some #define do{}while(0)
    
    Signed-off-by: NeilBrown <neil@brown.name>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/mt7621-pci/pci-mt7621.c b/drivers/staging/mt7621-pci/pci-mt7621.c
index cc89d464ef7f..c8d7b47c8952 100644
--- a/drivers/staging/mt7621-pci/pci-mt7621.c
+++ b/drivers/staging/mt7621-pci/pci-mt7621.c
@@ -67,95 +67,94 @@ extern void chk_phy_pll(void);
 #define CONFIG_PCIE_PORT0
 #define CONFIG_PCIE_PORT1
 #define CONFIG_PCIE_PORT2
-#define RALINK_PCIE0_CLK_EN             (1<<24)
-#define RALINK_PCIE1_CLK_EN             (1<<25)
-#define RALINK_PCIE2_CLK_EN             (1<<26)
-
-#define RALINK_PCI_CONFIG_ADDR                         0x20
-#define RALINK_PCI_CONFIG_DATA_VIRTUAL_REG     0x24
-#define RALINK_PCI_MEMBASE              *(volatile u32 *)(RALINK_PCI_BASE + 0x0028)
-#define RALINK_PCI_IOBASE               *(volatile u32 *)(RALINK_PCI_BASE + 0x002C)
-#define RALINK_PCIE0_RST                (1<<24)
-#define RALINK_PCIE1_RST                (1<<25)
-#define RALINK_PCIE2_RST                (1<<26)
-#define RALINK_SYSCTL_BASE              0xBE000000
-
-#define RALINK_PCI_PCICFG_ADDR          *(volatile u32 *)(RALINK_PCI_BASE + 0x0000)
-#define RALINK_PCI_PCIMSK_ADDR          *(volatile u32 *)(RALINK_PCI_BASE + 0x000C)
-#define RALINK_PCI_BASE                 0xBE140000
-
-#define RALINK_PCIEPHY_P0P1_CTL_OFFSET (RALINK_PCI_BASE + 0x9000)
-#define RT6855_PCIE0_OFFSET     0x2000
-#define RT6855_PCIE1_OFFSET     0x3000
-#define RT6855_PCIE2_OFFSET     0x4000
-
-#define RALINK_PCI0_BAR0SETUP_ADDR      *(volatile u32 *)(RALINK_PCI_BASE + RT6855_PCIE0_OFFSET + 0x0010)
-#define RALINK_PCI0_IMBASEBAR0_ADDR     *(volatile u32 *)(RALINK_PCI_BASE + RT6855_PCIE0_OFFSET + 0x0018)
-#define RALINK_PCI0_ID                  *(volatile u32 *)(RALINK_PCI_BASE + RT6855_PCIE0_OFFSET + 0x0030)
-#define RALINK_PCI0_CLASS               *(volatile u32 *)(RALINK_PCI_BASE + RT6855_PCIE0_OFFSET + 0x0034)
-#define RALINK_PCI0_SUBID               *(volatile u32 *)(RALINK_PCI_BASE + RT6855_PCIE0_OFFSET + 0x0038)
-#define RALINK_PCI0_STATUS              *(volatile u32 *)(RALINK_PCI_BASE + RT6855_PCIE0_OFFSET + 0x0050)
-#define RALINK_PCI0_DERR                *(volatile u32 *)(RALINK_PCI_BASE + RT6855_PCIE0_OFFSET + 0x0060)
-#define RALINK_PCI0_ECRC                *(volatile u32 *)(RALINK_PCI_BASE + RT6855_PCIE0_OFFSET + 0x0064)
-
-#define RALINK_PCI1_BAR0SETUP_ADDR      *(volatile u32 *)(RALINK_PCI_BASE + RT6855_PCIE1_OFFSET + 0x0010)
-#define RALINK_PCI1_IMBASEBAR0_ADDR     *(volatile u32 *)(RALINK_PCI_BASE + RT6855_PCIE1_OFFSET + 0x0018)
-#define RALINK_PCI1_ID                  *(volatile u32 *)(RALINK_PCI_BASE + RT6855_PCIE1_OFFSET + 0x0030)
-#define RALINK_PCI1_CLASS               *(volatile u32 *)(RALINK_PCI_BASE + RT6855_PCIE1_OFFSET + 0x0034)
-#define RALINK_PCI1_SUBID               *(volatile u32 *)(RALINK_PCI_BASE + RT6855_PCIE1_OFFSET + 0x0038)
-#define RALINK_PCI1_STATUS              *(volatile u32 *)(RALINK_PCI_BASE + RT6855_PCIE1_OFFSET + 0x0050)
-#define RALINK_PCI1_DERR                *(volatile u32 *)(RALINK_PCI_BASE + RT6855_PCIE1_OFFSET + 0x0060)
-#define RALINK_PCI1_ECRC                *(volatile u32 *)(RALINK_PCI_BASE + RT6855_PCIE1_OFFSET + 0x0064)
-
-#define RALINK_PCI2_BAR0SETUP_ADDR      *(volatile u32 *)(RALINK_PCI_BASE + RT6855_PCIE2_OFFSET + 0x0010)
-#define RALINK_PCI2_IMBASEBAR0_ADDR     *(volatile u32 *)(RALINK_PCI_BASE + RT6855_PCIE2_OFFSET + 0x0018)
-#define RALINK_PCI2_ID                  *(volatile u32 *)(RALINK_PCI_BASE + RT6855_PCIE2_OFFSET + 0x0030)
-#define RALINK_PCI2_CLASS               *(volatile u32 *)(RALINK_PCI_BASE + RT6855_PCIE2_OFFSET + 0x0034)
-#define RALINK_PCI2_SUBID               *(volatile u32 *)(RALINK_PCI_BASE + RT6855_PCIE2_OFFSET + 0x0038)
-#define RALINK_PCI2_STATUS              *(volatile u32 *)(RALINK_PCI_BASE + RT6855_PCIE2_OFFSET + 0x0050)
-#define RALINK_PCI2_DERR                *(volatile u32 *)(RALINK_PCI_BASE + RT6855_PCIE2_OFFSET + 0x0060)
-#define RALINK_PCI2_ECRC                *(volatile u32 *)(RALINK_PCI_BASE + RT6855_PCIE2_OFFSET + 0x0064)
-
-#define RALINK_PCIEPHY_P0P1_CTL_OFFSET  (RALINK_PCI_BASE + 0x9000)
-#define RALINK_PCIEPHY_P2_CTL_OFFSET    (RALINK_PCI_BASE + 0xA000)
-
-
-#define MV_WRITE(ofs, data)  \
-        *(volatile u32 *)(RALINK_PCI_BASE+(ofs)) = cpu_to_le32(data)
-#define MV_READ(ofs, data)   \
-	        *(data) = le32_to_cpu(*(volatile u32 *)(RALINK_PCI_BASE+(ofs)))
-#define MV_READ_DATA(ofs)    \
-		        le32_to_cpu(*(volatile u32 *)(RALINK_PCI_BASE+(ofs)))
-
-#define MV_WRITE_16(ofs, data)  \
-        *(volatile u16 *)(RALINK_PCI_BASE+(ofs)) = cpu_to_le16(data)
-#define MV_READ_16(ofs, data)   \
-	        *(data) = le16_to_cpu(*(volatile u16 *)(RALINK_PCI_BASE+(ofs)))
-
-#define MV_WRITE_8(ofs, data)  \
-        *(volatile u8 *)(RALINK_PCI_BASE+(ofs)) = data
-#define MV_READ_8(ofs, data)   \
-	        *(data) = *(volatile u8 *)(RALINK_PCI_BASE+(ofs))
-
-
-
-#define RALINK_PCI_MM_MAP_BASE	0x60000000
-#define RALINK_PCI_IO_MAP_BASE	0x1e160000
+#define RALINK_PCIE0_CLK_EN		(1<<24)
+#define RALINK_PCIE1_CLK_EN		(1<<25)
+#define RALINK_PCIE2_CLK_EN		(1<<26)
+
+#define RALINK_PCI_CONFIG_ADDR		0x20
+#define RALINK_PCI_CONFIG_DATA_VIRTUAL_REG	0x24
+#define RALINK_PCI_MEMBASE		*(volatile u32 *)(RALINK_PCI_BASE + 0x0028)
+#define RALINK_PCI_IOBASE		*(volatile u32 *)(RALINK_PCI_BASE + 0x002C)
+#define RALINK_PCIE0_RST		(1<<24)
+#define RALINK_PCIE1_RST		(1<<25)
+#define RALINK_PCIE2_RST		(1<<26)
+#define RALINK_SYSCTL_BASE		0xBE000000
+
+#define RALINK_PCI_PCICFG_ADDR		*(volatile u32 *)(RALINK_PCI_BASE + 0x0000)
+#define RALINK_PCI_PCIMSK_ADDR		*(volatile u32 *)(RALINK_PCI_BASE + 0x000C)
+#define RALINK_PCI_BASE	0xBE140000
+
+#define RALINK_PCIEPHY_P0P1_CTL_OFFSET	(RALINK_PCI_BASE + 0x9000)
+#define RT6855_PCIE0_OFFSET		0x2000
+#define RT6855_PCIE1_OFFSET		0x3000
+#define RT6855_PCIE2_OFFSET		0x4000
+
+#define RALINK_PCI0_BAR0SETUP_ADDR	*(volatile u32 *)(RALINK_PCI_BASE + RT6855_PCIE0_OFFSET + 0x0010)
+#define RALINK_PCI0_IMBASEBAR0_ADDR	*(volatile u32 *)(RALINK_PCI_BASE + RT6855_PCIE0_OFFSET + 0x0018)
+#define RALINK_PCI0_ID			*(volatile u32 *)(RALINK_PCI_BASE + RT6855_PCIE0_OFFSET + 0x0030)
+#define RALINK_PCI0_CLASS		*(volatile u32 *)(RALINK_PCI_BASE + RT6855_PCIE0_OFFSET + 0x0034)
+#define RALINK_PCI0_SUBID		*(volatile u32 *)(RALINK_PCI_BASE + RT6855_PCIE0_OFFSET + 0x0038)
+#define RALINK_PCI0_STATUS		*(volatile u32 *)(RALINK_PCI_BASE + RT6855_PCIE0_OFFSET + 0x0050)
+#define RALINK_PCI0_DERR		*(volatile u32 *)(RALINK_PCI_BASE + RT6855_PCIE0_OFFSET + 0x0060)
+#define RALINK_PCI0_ECRC		*(volatile u32 *)(RALINK_PCI_BASE + RT6855_PCIE0_OFFSET + 0x0064)
+
+#define RALINK_PCI1_BAR0SETUP_ADDR	*(volatile u32 *)(RALINK_PCI_BASE + RT6855_PCIE1_OFFSET + 0x0010)
+#define RALINK_PCI1_IMBASEBAR0_ADDR	*(volatile u32 *)(RALINK_PCI_BASE + RT6855_PCIE1_OFFSET + 0x0018)
+#define RALINK_PCI1_ID			*(volatile u32 *)(RALINK_PCI_BASE + RT6855_PCIE1_OFFSET + 0x0030)
+#define RALINK_PCI1_CLASS		*(volatile u32 *)(RALINK_PCI_BASE + RT6855_PCIE1_OFFSET + 0x0034)
+#define RALINK_PCI1_SUBID		*(volatile u32 *)(RALINK_PCI_BASE + RT6855_PCIE1_OFFSET + 0x0038)
+#define RALINK_PCI1_STATUS		*(volatile u32 *)(RALINK_PCI_BASE + RT6855_PCIE1_OFFSET + 0x0050)
+#define RALINK_PCI1_DERR		*(volatile u32 *)(RALINK_PCI_BASE + RT6855_PCIE1_OFFSET + 0x0060)
+#define RALINK_PCI1_ECRC		*(volatile u32 *)(RALINK_PCI_BASE + RT6855_PCIE1_OFFSET + 0x0064)
+
+#define RALINK_PCI2_BAR0SETUP_ADDR	*(volatile u32 *)(RALINK_PCI_BASE + RT6855_PCIE2_OFFSET + 0x0010)
+#define RALINK_PCI2_IMBASEBAR0_ADDR	*(volatile u32 *)(RALINK_PCI_BASE + RT6855_PCIE2_OFFSET + 0x0018)
+#define RALINK_PCI2_ID			*(volatile u32 *)(RALINK_PCI_BASE + RT6855_PCIE2_OFFSET + 0x0030)
+#define RALINK_PCI2_CLASS		*(volatile u32 *)(RALINK_PCI_BASE + RT6855_PCIE2_OFFSET + 0x0034)
+#define RALINK_PCI2_SUBID		*(volatile u32 *)(RALINK_PCI_BASE + RT6855_PCIE2_OFFSET + 0x0038)
+#define RALINK_PCI2_STATUS		*(volatile u32 *)(RALINK_PCI_BASE + RT6855_PCIE2_OFFSET + 0x0050)
+#define RALINK_PCI2_DERR		*(volatile u32 *)(RALINK_PCI_BASE + RT6855_PCIE2_OFFSET + 0x0060)
+#define RALINK_PCI2_ECRC		*(volatile u32 *)(RALINK_PCI_BASE + RT6855_PCIE2_OFFSET + 0x0064)
+
+#define RALINK_PCIEPHY_P0P1_CTL_OFFSET	(RALINK_PCI_BASE + 0x9000)
+#define RALINK_PCIEPHY_P2_CTL_OFFSET	(RALINK_PCI_BASE + 0xA000)
+
+#define MV_WRITE(ofs, data)	\
+	*(volatile u32 *)(RALINK_PCI_BASE+(ofs)) = cpu_to_le32(data)
+#define MV_READ(ofs, data)	\
+	*(data) = le32_to_cpu(*(volatile u32 *)(RALINK_PCI_BASE+(ofs)))
+#define MV_READ_DATA(ofs)	\
+	le32_to_cpu(*(volatile u32 *)(RALINK_PCI_BASE+(ofs)))
+
+#define MV_WRITE_16(ofs, data)	\
+	*(volatile u16 *)(RALINK_PCI_BASE+(ofs)) = cpu_to_le16(data)
+#define MV_READ_16(ofs, data)	\
+	*(data) = le16_to_cpu(*(volatile u16 *)(RALINK_PCI_BASE+(ofs)))
+
+#define MV_WRITE_8(ofs, data)	\
+	*(volatile u8 *)(RALINK_PCI_BASE+(ofs)) = data
+#define MV_READ_8(ofs, data)	\
+	*(data) = *(volatile u8 *)(RALINK_PCI_BASE+(ofs))
+
+#define RALINK_PCI_MM_MAP_BASE		0x60000000
+#define RALINK_PCI_IO_MAP_BASE		0x1e160000
 
 #define RALINK_SYSTEM_CONTROL_BASE	0xbe000000
 #define GPIO_PERST
-#define ASSERT_SYSRST_PCIE(val)		do {	\
-						if (*(unsigned int *)(0xbe00000c) == 0x00030101)	\
-							RALINK_RSTCTRL |= val;	\
-						else	\
-							RALINK_RSTCTRL &= ~val;	\
-					} while(0)
-#define DEASSERT_SYSRST_PCIE(val) 	do {	\
-						if (*(unsigned int *)(0xbe00000c) == 0x00030101)	\
-							RALINK_RSTCTRL &= ~val;	\
-						else	\
-							RALINK_RSTCTRL |= val;	\
-					} while(0)
+#define ASSERT_SYSRST_PCIE(val)		\
+	do {								\
+		if (*(unsigned int *)(0xbe00000c) == 0x00030101)	\
+			RALINK_RSTCTRL |= val;				\
+		else							\
+			RALINK_RSTCTRL &= ~val;				\
+	} while(0)
+#define DEASSERT_SYSRST_PCIE(val)	\
+	do {								\
+		if (*(unsigned int *)(0xbe00000c) == 0x00030101)	\
+			RALINK_RSTCTRL &= ~val;				\
+		else							\
+			RALINK_RSTCTRL |= val;				\
+	} while(0)
 #define RALINK_SYSCFG1			*(unsigned int *)(RALINK_SYSTEM_CONTROL_BASE + 0x14)
 #define RALINK_CLKCFG1			*(unsigned int *)(RALINK_SYSTEM_CONTROL_BASE + 0x30)
 #define RALINK_RSTCTRL			*(unsigned int *)(RALINK_SYSTEM_CONTROL_BASE + 0x34)
@@ -275,7 +274,6 @@ write_config_dword(struct pci_bus *bus, unsigned int devfn, int where, u32 val)
 	return PCIBIOS_SUCCESSFUL;
 }
 
-
 static int
 pci_config_read(struct pci_bus *bus, unsigned int devfn, int where, int size, u32 * val)
 {
@@ -303,7 +301,7 @@ pci_config_write(struct pci_bus *bus, unsigned int devfn, int where, int size, u
 }
 
 struct pci_ops mt7621_pci_ops= {
-	.read		=  pci_config_read,
+	.read		= pci_config_read,
 	.write		= pci_config_write,
 };
 
@@ -313,6 +311,7 @@ static struct resource mt7621_res_pci_mem1 = {
 	.end		= (u32)((RALINK_PCI_MM_MAP_BASE + (unsigned char *)0x0fffffff)),
 	.flags		= IORESOURCE_MEM,
 };
+
 static struct resource mt7621_res_pci_io1 = {
 	.name		= "PCI I/O1",
 	.start		= RALINK_PCI_IO_MAP_BASE,
@@ -335,10 +334,10 @@ read_config(unsigned long bus, unsigned long dev, unsigned long func, unsigned l
 	unsigned int address_reg, data_reg, address;
 
 	address_reg = RALINK_PCI_CONFIG_ADDR;
-        data_reg = RALINK_PCI_CONFIG_DATA_VIRTUAL_REG;
+	data_reg = RALINK_PCI_CONFIG_DATA_VIRTUAL_REG;
 	address = (((reg & 0xF00)>>8)<<24) | (bus << 16) | (dev << 11) | (func << 8) | (reg & 0xfc) | 0x80000000 ;
-        MV_WRITE(address_reg, address);
-        MV_READ(data_reg, val);
+	MV_WRITE(address_reg, address);
+	MV_READ(data_reg, val);
 	return;
 }
 
@@ -355,7 +354,6 @@ write_config(unsigned long bus, unsigned long dev, unsigned long func, unsigned
 	return;
 }
 
-
 int
 pcibios_map_irq(const struct pci_dev *dev, u8 slot, u8 pin)
 {
@@ -422,76 +420,76 @@ set_phy_for_ssc(void)
 	/* Debug Xtal Type */
 	set_pcie_phy((u32 *)(RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x400),  8, 1, 0x01);	// rg_pe1_frc_h_xtal_type
 	set_pcie_phy((u32 *)(RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x400),  9, 2, 0x00);	// rg_pe1_h_xtal_type
-	set_pcie_phy((u32 *)(RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x000),  4, 1, 0x01);	// rg_pe1_frc_phy_en               //Force Port 0 enable control
-	set_pcie_phy((u32 *)(RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x100),  4, 1, 0x01);	// rg_pe1_frc_phy_en               //Force Port 1 enable control
-	set_pcie_phy((u32 *)(RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x000),  5, 1, 0x00);	// rg_pe1_phy_en                   //Port 0 disable
-	set_pcie_phy((u32 *)(RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x100),  5, 1, 0x00);	// rg_pe1_phy_en                   //Port 1 disable
-	if(reg <= 5 && reg >= 3) { 	// 40MHz Xtal
-		set_pcie_phy((u32 *)(RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x490),  6, 2, 0x01);	// RG_PE1_H_PLL_PREDIV             //Pre-divider ratio (for host mode)
+	set_pcie_phy((u32 *)(RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x000),  4, 1, 0x01);	// rg_pe1_frc_phy_en	//Force Port 0 enable control
+	set_pcie_phy((u32 *)(RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x100),  4, 1, 0x01);	// rg_pe1_frc_phy_en	//Force Port 1 enable control
+	set_pcie_phy((u32 *)(RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x000),  5, 1, 0x00);	// rg_pe1_phy_en	//Port 0 disable
+	set_pcie_phy((u32 *)(RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x100),  5, 1, 0x00);	// rg_pe1_phy_en	//Port 1 disable
+	if(reg <= 5 && reg >= 3) {	// 40MHz Xtal
+		set_pcie_phy((u32 *)(RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x490),  6, 2, 0x01);	// RG_PE1_H_PLL_PREDIV	//Pre-divider ratio (for host mode)
 		printk("***** Xtal 40MHz *****\n");
 	} else {			// 25MHz | 20MHz Xtal
-		set_pcie_phy((u32 *)(RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x490),  6, 2, 0x00);	// RG_PE1_H_PLL_PREDIV             //Pre-divider ratio (for host mode)
-		if (reg >= 6) { 	
+		set_pcie_phy((u32 *)(RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x490),  6, 2, 0x00);	// RG_PE1_H_PLL_PREDIV	//Pre-divider ratio (for host mode)
+		if (reg >= 6) {
 			printk("***** Xtal 25MHz *****\n");
-			set_pcie_phy((u32 *)(RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x4bc),  4, 2, 0x01);	// RG_PE1_H_PLL_FBKSEL             //Feedback clock select
-			set_pcie_phy((u32 *)(RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x49c),  0,31, 0x18000000);	// RG_PE1_H_LCDDS_PCW_NCPO         //DDS NCPO PCW (for host mode)
-			set_pcie_phy((u32 *)(RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x4a4),  0,16, 0x18d);	// RG_PE1_H_LCDDS_SSC_PRD          //DDS SSC dither period control
-			set_pcie_phy((u32 *)(RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x4a8),  0,12, 0x4a);	// RG_PE1_H_LCDDS_SSC_DELTA        //DDS SSC dither amplitude control
-			set_pcie_phy((u32 *)(RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x4a8), 16,12, 0x4a);	// RG_PE1_H_LCDDS_SSC_DELTA1       //DDS SSC dither amplitude control for initial
+			set_pcie_phy((u32 *)(RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x4bc),  4, 2, 0x01);	// RG_PE1_H_PLL_FBKSEL	//Feedback clock select
+			set_pcie_phy((u32 *)(RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x49c),  0,31, 0x18000000);	// RG_PE1_H_LCDDS_PCW_NCPO	//DDS NCPO PCW (for host mode)
+			set_pcie_phy((u32 *)(RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x4a4),  0,16, 0x18d);	// RG_PE1_H_LCDDS_SSC_PRD	//DDS SSC dither period control
+			set_pcie_phy((u32 *)(RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x4a8),  0,12, 0x4a);	// RG_PE1_H_LCDDS_SSC_DELTA	//DDS SSC dither amplitude control
+			set_pcie_phy((u32 *)(RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x4a8), 16,12, 0x4a);	// RG_PE1_H_LCDDS_SSC_DELTA1	//DDS SSC dither amplitude control for initial
 		} else {
 			printk("***** Xtal 20MHz *****\n");
 		}
 	}
-	set_pcie_phy((u32 *)(RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x4a0),  5, 1, 0x01);	// RG_PE1_LCDDS_CLK_PH_INV         //DDS clock inversion
-	set_pcie_phy((u32 *)(RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x490), 22, 2, 0x02);	// RG_PE1_H_PLL_BC                 
-	set_pcie_phy((u32 *)(RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x490), 18, 4, 0x06);	// RG_PE1_H_PLL_BP                 
-	set_pcie_phy((u32 *)(RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x490), 12, 4, 0x02);	// RG_PE1_H_PLL_IR                 
-	set_pcie_phy((u32 *)(RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x490),  8, 4, 0x01);	// RG_PE1_H_PLL_IC                 
-	set_pcie_phy((u32 *)(RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x4ac), 16, 3, 0x00);	// RG_PE1_H_PLL_BR                 
-	set_pcie_phy((u32 *)(RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x490),  1, 3, 0x02);	// RG_PE1_PLL_DIVEN                
-	if(reg <= 5 && reg >= 3) { 	// 40MHz Xtal
+	set_pcie_phy((u32 *)(RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x4a0),  5, 1, 0x01);	// RG_PE1_LCDDS_CLK_PH_INV	//DDS clock inversion
+	set_pcie_phy((u32 *)(RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x490), 22, 2, 0x02);	// RG_PE1_H_PLL_BC
+	set_pcie_phy((u32 *)(RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x490), 18, 4, 0x06);	// RG_PE1_H_PLL_BP
+	set_pcie_phy((u32 *)(RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x490), 12, 4, 0x02);	// RG_PE1_H_PLL_IR
+	set_pcie_phy((u32 *)(RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x490),  8, 4, 0x01);	// RG_PE1_H_PLL_IC
+	set_pcie_phy((u32 *)(RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x4ac), 16, 3, 0x00);	// RG_PE1_H_PLL_BR
+	set_pcie_phy((u32 *)(RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x490),  1, 3, 0x02);	// RG_PE1_PLL_DIVEN
+	if(reg <= 5 && reg >= 3) {	// 40MHz Xtal
 		set_pcie_phy((u32 *)(RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x414),  6, 2, 0x01);	// rg_pe1_mstckdiv		//value of da_pe1_mstckdiv when force mode enable
-		set_pcie_phy((u32 *)(RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x414),  5, 1, 0x01);	// rg_pe1_frc_mstckdiv          //force mode enable of da_pe1_mstckdiv      
+		set_pcie_phy((u32 *)(RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x414),  5, 1, 0x01);	// rg_pe1_frc_mstckdiv	//force mode enable of da_pe1_mstckdiv
 	}
 	/* Enable PHY and disable force mode */
-	set_pcie_phy((u32 *)(RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x000),  5, 1, 0x01);	// rg_pe1_phy_en                   //Port 0 enable
-	set_pcie_phy((u32 *)(RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x100),  5, 1, 0x01);	// rg_pe1_phy_en                   //Port 1 enable
-	set_pcie_phy((u32 *)(RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x000),  4, 1, 0x00);	// rg_pe1_frc_phy_en               //Force Port 0 disable control
-	set_pcie_phy((u32 *)(RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x100),  4, 1, 0x00);	// rg_pe1_frc_phy_en               //Force Port 1 disable control
+	set_pcie_phy((u32 *)(RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x000),  5, 1, 0x01);	// rg_pe1_phy_en	//Port 0 enable
+	set_pcie_phy((u32 *)(RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x100),  5, 1, 0x01);	// rg_pe1_phy_en	//Port 1 enable
+	set_pcie_phy((u32 *)(RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x000),  4, 1, 0x00);	// rg_pe1_frc_phy_en	//Force Port 0 disable control
+	set_pcie_phy((u32 *)(RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x100),  4, 1, 0x00);	// rg_pe1_frc_phy_en	//Force Port 1 disable control
 #endif
 #if defined (CONFIG_PCIE_PORT2)
 	/* Set PCIe Port2 PHY to disable SSC */
 	/* Debug Xtal Type */
 	set_pcie_phy((u32 *)(RALINK_PCIEPHY_P2_CTL_OFFSET + 0x400),  8, 1, 0x01);	// rg_pe1_frc_h_xtal_type
 	set_pcie_phy((u32 *)(RALINK_PCIEPHY_P2_CTL_OFFSET + 0x400),  9, 2, 0x00);	// rg_pe1_h_xtal_type
-	set_pcie_phy((u32 *)(RALINK_PCIEPHY_P2_CTL_OFFSET + 0x000),  4, 1, 0x01);	// rg_pe1_frc_phy_en               //Force Port 0 enable control
-	set_pcie_phy((u32 *)(RALINK_PCIEPHY_P2_CTL_OFFSET + 0x000),  5, 1, 0x00);	// rg_pe1_phy_en                   //Port 0 disable
-	if(reg <= 5 && reg >= 3) { 	// 40MHz Xtal
-		set_pcie_phy((u32 *)(RALINK_PCIEPHY_P2_CTL_OFFSET + 0x490),  6, 2, 0x01);	// RG_PE1_H_PLL_PREDIV             //Pre-divider ratio (for host mode)
+	set_pcie_phy((u32 *)(RALINK_PCIEPHY_P2_CTL_OFFSET + 0x000),  4, 1, 0x01);	// rg_pe1_frc_phy_en	//Force Port 0 enable control
+	set_pcie_phy((u32 *)(RALINK_PCIEPHY_P2_CTL_OFFSET + 0x000),  5, 1, 0x00);	// rg_pe1_phy_en	//Port 0 disable
+	if(reg <= 5 && reg >= 3) {	// 40MHz Xtal
+		set_pcie_phy((u32 *)(RALINK_PCIEPHY_P2_CTL_OFFSET + 0x490),  6, 2, 0x01);	// RG_PE1_H_PLL_PREDIV	//Pre-divider ratio (for host mode)
 	} else {			// 25MHz | 20MHz Xtal
-		set_pcie_phy((u32 *)(RALINK_PCIEPHY_P2_CTL_OFFSET + 0x490),  6, 2, 0x00);	// RG_PE1_H_PLL_PREDIV             //Pre-divider ratio (for host mode)
-		if (reg >= 6) { 	// 25MHz Xtal
-			set_pcie_phy((u32 *)(RALINK_PCIEPHY_P2_CTL_OFFSET + 0x4bc),  4, 2, 0x01);	// RG_PE1_H_PLL_FBKSEL             //Feedback clock select
-			set_pcie_phy((u32 *)(RALINK_PCIEPHY_P2_CTL_OFFSET + 0x49c),  0,31, 0x18000000);	// RG_PE1_H_LCDDS_PCW_NCPO         //DDS NCPO PCW (for host mode)
-			set_pcie_phy((u32 *)(RALINK_PCIEPHY_P2_CTL_OFFSET + 0x4a4),  0,16, 0x18d);	// RG_PE1_H_LCDDS_SSC_PRD          //DDS SSC dither period control
-			set_pcie_phy((u32 *)(RALINK_PCIEPHY_P2_CTL_OFFSET + 0x4a8),  0,12, 0x4a);	// RG_PE1_H_LCDDS_SSC_DELTA        //DDS SSC dither amplitude control
-			set_pcie_phy((u32 *)(RALINK_PCIEPHY_P2_CTL_OFFSET + 0x4a8), 16,12, 0x4a);	// RG_PE1_H_LCDDS_SSC_DELTA1       //DDS SSC dither amplitude control for initial
+		set_pcie_phy((u32 *)(RALINK_PCIEPHY_P2_CTL_OFFSET + 0x490),  6, 2, 0x00);	// RG_PE1_H_PLL_PREDIV	//Pre-divider ratio (for host mode)
+		if (reg >= 6) {		// 25MHz Xtal
+			set_pcie_phy((u32 *)(RALINK_PCIEPHY_P2_CTL_OFFSET + 0x4bc),  4, 2, 0x01);	// RG_PE1_H_PLL_FBKSEL	//Feedback clock select
+			set_pcie_phy((u32 *)(RALINK_PCIEPHY_P2_CTL_OFFSET + 0x49c),  0,31, 0x18000000);	// RG_PE1_H_LCDDS_PCW_NCPO	//DDS NCPO PCW (for host mode)
+			set_pcie_phy((u32 *)(RALINK_PCIEPHY_P2_CTL_OFFSET + 0x4a4),  0,16, 0x18d);	// RG_PE1_H_LCDDS_SSC_PRD	//DDS SSC dither period control
+			set_pcie_phy((u32 *)(RALINK_PCIEPHY_P2_CTL_OFFSET + 0x4a8),  0,12, 0x4a);	// RG_PE1_H_LCDDS_SSC_DELTA	//DDS SSC dither amplitude control
+			set_pcie_phy((u32 *)(RALINK_PCIEPHY_P2_CTL_OFFSET + 0x4a8), 16,12, 0x4a);	// RG_PE1_H_LCDDS_SSC_DELTA1	//DDS SSC dither amplitude control for initial
 		}
 	}
-	set_pcie_phy((u32 *)(RALINK_PCIEPHY_P2_CTL_OFFSET + 0x4a0),  5, 1, 0x01);	// RG_PE1_LCDDS_CLK_PH_INV         //DDS clock inversion
-	set_pcie_phy((u32 *)(RALINK_PCIEPHY_P2_CTL_OFFSET + 0x490), 22, 2, 0x02);	// RG_PE1_H_PLL_BC                 
-	set_pcie_phy((u32 *)(RALINK_PCIEPHY_P2_CTL_OFFSET + 0x490), 18, 4, 0x06);	// RG_PE1_H_PLL_BP                 
-	set_pcie_phy((u32 *)(RALINK_PCIEPHY_P2_CTL_OFFSET + 0x490), 12, 4, 0x02);	// RG_PE1_H_PLL_IR                 
-	set_pcie_phy((u32 *)(RALINK_PCIEPHY_P2_CTL_OFFSET + 0x490),  8, 4, 0x01);	// RG_PE1_H_PLL_IC                 
-	set_pcie_phy((u32 *)(RALINK_PCIEPHY_P2_CTL_OFFSET + 0x4ac), 16, 3, 0x00);	// RG_PE1_H_PLL_BR                 
-	set_pcie_phy((u32 *)(RALINK_PCIEPHY_P2_CTL_OFFSET + 0x490),  1, 3, 0x02);	// RG_PE1_PLL_DIVEN                
-	if(reg <= 5 && reg >= 3) { 	// 40MHz Xtal
+	set_pcie_phy((u32 *)(RALINK_PCIEPHY_P2_CTL_OFFSET + 0x4a0),  5, 1, 0x01);	// RG_PE1_LCDDS_CLK_PH_INV	//DDS clock inversion
+	set_pcie_phy((u32 *)(RALINK_PCIEPHY_P2_CTL_OFFSET + 0x490), 22, 2, 0x02);	// RG_PE1_H_PLL_BC
+	set_pcie_phy((u32 *)(RALINK_PCIEPHY_P2_CTL_OFFSET + 0x490), 18, 4, 0x06);	// RG_PE1_H_PLL_BP
+	set_pcie_phy((u32 *)(RALINK_PCIEPHY_P2_CTL_OFFSET + 0x490), 12, 4, 0x02);	// RG_PE1_H_PLL_IR
+	set_pcie_phy((u32 *)(RALINK_PCIEPHY_P2_CTL_OFFSET + 0x490),  8, 4, 0x01);	// RG_PE1_H_PLL_IC
+	set_pcie_phy((u32 *)(RALINK_PCIEPHY_P2_CTL_OFFSET + 0x4ac), 16, 3, 0x00);	// RG_PE1_H_PLL_BR
+	set_pcie_phy((u32 *)(RALINK_PCIEPHY_P2_CTL_OFFSET + 0x490),  1, 3, 0x02);	// RG_PE1_PLL_DIVEN
+	if(reg <= 5 && reg >= 3) {	// 40MHz Xtal
 		set_pcie_phy((u32 *)(RALINK_PCIEPHY_P2_CTL_OFFSET + 0x414),  6, 2, 0x01);	// rg_pe1_mstckdiv		//value of da_pe1_mstckdiv when force mode enable
-		set_pcie_phy((u32 *)(RALINK_PCIEPHY_P2_CTL_OFFSET + 0x414),  5, 1, 0x01);	// rg_pe1_frc_mstckdiv          //force mode enable of da_pe1_mstckdiv      
+		set_pcie_phy((u32 *)(RALINK_PCIEPHY_P2_CTL_OFFSET + 0x414),  5, 1, 0x01);	// rg_pe1_frc_mstckdiv	//force mode enable of da_pe1_mstckdiv
 	}
 	/* Enable PHY and disable force mode */
-	set_pcie_phy((u32 *)(RALINK_PCIEPHY_P2_CTL_OFFSET + 0x000),  5, 1, 0x01);	// rg_pe1_phy_en                   //Port 0 enable
-	set_pcie_phy((u32 *)(RALINK_PCIEPHY_P2_CTL_OFFSET + 0x000),  4, 1, 0x00);	// rg_pe1_frc_phy_en               //Force Port 0 disable control
+	set_pcie_phy((u32 *)(RALINK_PCIEPHY_P2_CTL_OFFSET + 0x000),  5, 1, 0x01);	// rg_pe1_phy_en	//Port 0 enable
+	set_pcie_phy((u32 *)(RALINK_PCIEPHY_P2_CTL_OFFSET + 0x000),  4, 1, 0x00);	// rg_pe1_frc_phy_en	//Force Port 0 disable control
 #endif
 }
 
@@ -500,15 +498,15 @@ void setup_cm_memory_region(struct resource *mem_resource)
 	resource_size_t mask;
 	if (mips_cps_numiocu(0)) {
 		/* FIXME: hardware doesn't accept mask values with 1s after
-		   0s (e.g. 0xffef), so it would be great to warn if that's
-		   about to happen */
+		 * 0s (e.g. 0xffef), so it would be great to warn if that's
+		 * about to happen */
 		mask = ~(mem_resource->end - mem_resource->start);
 
 		write_gcr_reg1_base(mem_resource->start);
 		write_gcr_reg1_mask(mask | CM_GCR_REGn_MASK_CMTGT_IOCU0);
 		printk("PCI coherence region base: 0x%08llx, mask/settings: 0x%08llx\n",
-		       (unsigned long long)read_gcr_reg1_base(),
-		       (unsigned long long)read_gcr_reg1_mask());
+			(unsigned long long)read_gcr_reg1_base(),
+			(unsigned long long)read_gcr_reg1_mask());
 	}
 }
 
@@ -583,7 +581,6 @@ static int mt7621_pci_probe(struct platform_device *pdev)
 	RALINK_PCIE_CLK_GEN |= 0x80000000;
 	mdelay(50);
 	RALINK_RSTCTRL = (RALINK_RSTCTRL & ~RALINK_PCIE_RST);
-	
 
 #if defined GPIO_PERST /* add GPIO control instead of PERST_N */  /*chhung*/
 	*(unsigned int *)(0xbe000620) |= 0x1<<19 | 0x1<<8 | 0x1<<7;		// set DATA
@@ -593,7 +590,6 @@ static int mt7621_pci_probe(struct platform_device *pdev)
 #endif
 	mdelay(500);
 
-
 	mdelay(500);
 #if defined (CONFIG_PCIE_PORT0)
 	if(( RALINK_PCI0_STATUS & 0x1) == 0)
@@ -674,7 +670,7 @@ pcie(2/1/0) link status	pcie2_num	pcie1_num	pcie0_num
 
 /*
 	ioport_resource.start = mt7621_res_pci_io1.start;
-  	ioport_resource.end = mt7621_res_pci_io1.end;
+	ioport_resource.end = mt7621_res_pci_io1.end;
 */
 
 	RALINK_PCI_MEMBASE = 0xffffffff; //RALINK_PCI_MM_MAP_BASE;
@@ -708,7 +704,6 @@ pcie(2/1/0) link status	pcie2_num	pcie1_num	pcie0_num
 	}
 #endif
 
-
 	switch(pcie_link_status) {
 	case 7:
 		read_config(0, 2, 0, 0x4, &val);

commit 46d093124df4ce37c3805445bba9e7843df05d3e
Author: NeilBrown <neil@brown.name>
Date:   Fri May 4 14:58:36 2018 +1000

    staging: mt7621-pci: improve interrupt mapping
    
    As the Interrupts for the PCI adapters are listed in
    devicetree we shouldn't need to have them explicit in the code.
    
    The simplest way to do this is to use of_irq_parse_and_map_pci()
    and specify an interrupt-map which identifies the different
    PCI hosts by bus/slot numbers.
    This has the advantage that the hwirq number are mapped to virq
    numbers for us, so the ugly hack can go.
    
    Signed-off-by: NeilBrown <neil@brown.name>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/mt7621-pci/pci-mt7621.c b/drivers/staging/mt7621-pci/pci-mt7621.c
index c49442c9b187..cc89d464ef7f 100644
--- a/drivers/staging/mt7621-pci/pci-mt7621.c
+++ b/drivers/staging/mt7621-pci/pci-mt7621.c
@@ -73,12 +73,6 @@ extern void chk_phy_pll(void);
 
 #define RALINK_PCI_CONFIG_ADDR                         0x20
 #define RALINK_PCI_CONFIG_DATA_VIRTUAL_REG     0x24
-#define SURFBOARDINT_PCIE0       11      /* PCIE0 */
-#define RALINK_INT_PCIE0         SURFBOARDINT_PCIE0
-#define RALINK_INT_PCIE1         SURFBOARDINT_PCIE1
-#define RALINK_INT_PCIE2         SURFBOARDINT_PCIE2
-#define SURFBOARDINT_PCIE1       31     /* PCIE1 */
-#define SURFBOARDINT_PCIE2       32     /* PCIE2 */
 #define RALINK_PCI_MEMBASE              *(volatile u32 *)(RALINK_PCI_BASE + 0x0028)
 #define RALINK_PCI_IOBASE               *(volatile u32 *)(RALINK_PCI_BASE + 0x002C)
 #define RALINK_PCIE0_RST                (1<<24)
@@ -367,68 +361,12 @@ pcibios_map_irq(const struct pci_dev *dev, u8 slot, u8 pin)
 {
 	u16 cmd;
 	u32 val;
-	int irq = 0;
-
-	if ((dev->bus->number == 0) && (slot == 0)) {
-		write_config(0, 0, 0, PCI_BASE_ADDRESS_0, MEMORY_BASE);
-		read_config(0, 0, 0, PCI_BASE_ADDRESS_0, (unsigned long *)&val);
-		printk("BAR0 at slot 0 = %x\n", val);
-		printk("bus=0x%x, slot = 0x%x\n",dev->bus->number, slot);
-	} else if((dev->bus->number == 0) && (slot == 0x1)) {
-		write_config(0, 1, 0, PCI_BASE_ADDRESS_0, MEMORY_BASE);
-		read_config(0, 1, 0, PCI_BASE_ADDRESS_0, (unsigned long *)&val);
-		printk("BAR0 at slot 1 = %x\n", val);
-		printk("bus=0x%x, slot = 0x%x\n",dev->bus->number, slot);
-	} else if((dev->bus->number == 0) && (slot == 0x2)) {
-		write_config(0, 2, 0, PCI_BASE_ADDRESS_0, MEMORY_BASE);
-		read_config(0, 2, 0, PCI_BASE_ADDRESS_0, (unsigned long *)&val);
-		printk("BAR0 at slot 2 = %x\n", val);
-		printk("bus=0x%x, slot = 0x%x\n",dev->bus->number, slot);
-	} else if ((dev->bus->number == 1) && (slot == 0x0)) {
-		switch (pcie_link_status) {
-		case 2:
-		case 6:
-			irq = RALINK_INT_PCIE1;
-			break;
-		case 4:
-			irq = RALINK_INT_PCIE2;
-			break;
-		default:
-			irq = RALINK_INT_PCIE0;
-		}
-		printk("bus=0x%x, slot = 0x%x, irq=0x%x\n",dev->bus->number, slot, dev->irq);
-	} else if ((dev->bus->number == 2) && (slot == 0x0)) {
-		switch (pcie_link_status) {
-		case 5:
-		case 6:
-			irq = RALINK_INT_PCIE2;
-			break;
-		default:
-			irq = RALINK_INT_PCIE1;
-		}
-		printk("bus=0x%x, slot = 0x%x, irq=0x%x\n",dev->bus->number, slot, dev->irq);
-	} else if ((dev->bus->number == 2) && (slot == 0x1)) {
-		switch (pcie_link_status) {
-		case 5:
-		case 6:
-			irq = RALINK_INT_PCIE2;
-			break;
-		default:
-			irq = RALINK_INT_PCIE1;
-		}
-		printk("bus=0x%x, slot = 0x%x, irq=0x%x\n",dev->bus->number, slot, dev->irq);
-	} else if ((dev->bus->number ==3) && (slot == 0x0)) {
-		irq = RALINK_INT_PCIE2;
-		printk("bus=0x%x, slot = 0x%x, irq=0x%x\n",dev->bus->number, slot, dev->irq);
-	} else if ((dev->bus->number ==3) && (slot == 0x1)) {
-		irq = RALINK_INT_PCIE2;
-		printk("bus=0x%x, slot = 0x%x, irq=0x%x\n",dev->bus->number, slot, dev->irq);
-	} else if ((dev->bus->number ==3) && (slot == 0x2)) {
-		irq = RALINK_INT_PCIE2;
-		printk("bus=0x%x, slot = 0x%x, irq=0x%x\n",dev->bus->number, slot, dev->irq);
-	} else {
-		printk("bus=0x%x, slot = 0x%x\n",dev->bus->number, slot);
-		return 0;
+	int irq;
+
+	if (dev->bus->number == 0) {
+		write_config(0, slot, 0, PCI_BASE_ADDRESS_0, MEMORY_BASE);
+		read_config(0, slot, 0, PCI_BASE_ADDRESS_0, (unsigned long *)&val);
+		printk("BAR0 at slot %d = %x\n", slot, val);
 	}
 
 	pci_write_config_byte(dev, PCI_CACHE_LINE_SIZE, 0x14);  //configure cache line size 0x14
@@ -436,20 +374,10 @@ pcibios_map_irq(const struct pci_dev *dev, u8 slot, u8 pin)
 	pci_read_config_word(dev, PCI_COMMAND, &cmd);
 	cmd = cmd | PCI_COMMAND_MASTER | PCI_COMMAND_IO | PCI_COMMAND_MEMORY;
 	pci_write_config_word(dev, PCI_COMMAND, cmd);
+
+	irq = of_irq_parse_and_map_pci(dev, slot, pin);
+
 	pci_write_config_byte(dev, PCI_INTERRUPT_LINE, irq);
-#ifdef	CONFIG_DTB_GNUBEE1
-	/*
-	 * 'irq' here is a hwirq, but a virq is needed.  Until we know how and where
-	 * to convert one to the other, we have this hack for the GNUBEE1
-	 * Similarly 31->23 and 32->24.
-	 */
-	if (irq == 11)
-		return 22;
-	if (irq == 31)
-		return 23;
-	if (irq == 32)
-		return 24;
-#endif
 	return irq;
 }
 

commit 70100e25ae98281e430e11e7cb0d82c410c58f36
Author: Christian Ltke-Stetzkamp <christian@lkamp.de>
Date:   Wed Apr 18 18:40:11 2018 +0200

    staging: mt7621-pci: Remove redundant owner assignment
    
    Remove the owner assignment form the platform driver as
    platform_driver_register() already initializes the owner.
    Found using coccinelle.
    
    Signed-off-by: Christian Ltke-Stetzkamp <christian@lkamp.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/mt7621-pci/pci-mt7621.c b/drivers/staging/mt7621-pci/pci-mt7621.c
index 602321522198..c49442c9b187 100644
--- a/drivers/staging/mt7621-pci/pci-mt7621.c
+++ b/drivers/staging/mt7621-pci/pci-mt7621.c
@@ -832,7 +832,6 @@ static struct platform_driver mt7621_pci_driver = {
 	.probe = mt7621_pci_probe,
 	.driver = {
 		.name = "mt7621-pci",
-		.owner = THIS_MODULE,
 		.of_match_table = of_match_ptr(mt7621_pci_ids),
 	},
 };

commit c4c11ae8e4b9ec4ec9172726af67737818044a6a
Author: NeilBrown <neil@brown.name>
Date:   Mon Apr 2 10:20:15 2018 +1000

    staging: mt7621-pci: Hack 2 more PCI interrupts for gnubee1
    
    The mt7621-pci support 3 pci devices and has 3 interrupts.
    Each of these need to be enabled by the same sort of hack to
    map hwirq number to virq number.
    This is a hack which will go as soon as I understand how this is
    supposed to work.
    
    Signed-off-by: NeilBrown <neil@brown.name>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/mt7621-pci/pci-mt7621.c b/drivers/staging/mt7621-pci/pci-mt7621.c
index 1fa41eb8a87f..602321522198 100644
--- a/drivers/staging/mt7621-pci/pci-mt7621.c
+++ b/drivers/staging/mt7621-pci/pci-mt7621.c
@@ -441,11 +441,16 @@ pcibios_map_irq(const struct pci_dev *dev, u8 slot, u8 pin)
 	/*
 	 * 'irq' here is a hwirq, but a virq is needed.  Until we know how and where
 	 * to convert one to the other, we have this hack for the GNUBEE1
+	 * Similarly 31->23 and 32->24.
 	 */
-	return irq == 11 ? 22 : irq;
-#else
-	return irq;
+	if (irq == 11)
+		return 22;
+	if (irq == 31)
+		return 23;
+	if (irq == 32)
+		return 24;
 #endif
+	return irq;
 }
 
 void

commit 03f152e31f4ae89c37ab240f45dd77c8a916dd26
Author: John Crispin <blogic@openwrt.org>
Date:   Thu Mar 15 07:22:35 2018 +1100

    staging: mt7621-pci: MIPS/ralink: add MT7621 pcie driver
    
    NeilBrown: forward port and hack to work on GNUBEE1
    
    Signed-off-by: John Crispin <blogic@openwrt.org>
    Signed-off-by: NeilBrown <neil@brown.name>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/mt7621-pci/pci-mt7621.c b/drivers/staging/mt7621-pci/pci-mt7621.c
new file mode 100644
index 000000000000..1fa41eb8a87f
--- /dev/null
+++ b/drivers/staging/mt7621-pci/pci-mt7621.c
@@ -0,0 +1,840 @@
+/**************************************************************************
+ *
+ *  BRIEF MODULE DESCRIPTION
+ *     PCI init for Ralink RT2880 solution
+ *
+ *  Copyright 2007 Ralink Inc. (bruce_chang@ralinktech.com.tw)
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *
+ **************************************************************************
+ * May 2007 Bruce Chang
+ * Initial Release
+ *
+ * May 2009 Bruce Chang
+ * support RT2880/RT3883 PCIe
+ *
+ * May 2011 Bruce Chang
+ * support RT6855/MT7620 PCIe
+ *
+ **************************************************************************
+ */
+
+#include <linux/types.h>
+#include <linux/pci.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/version.h>
+#include <asm/pci.h>
+#include <asm/io.h>
+#include <asm/mips-cm.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/of.h>
+#include <linux/of_pci.h>
+#include <linux/platform_device.h>
+
+#include <ralink_regs.h>
+
+extern void pcie_phy_init(void);
+extern void chk_phy_pll(void);
+
+/*
+ * These functions and structures provide the BIOS scan and mapping of the PCI
+ * devices.
+ */
+
+#define CONFIG_PCIE_PORT0
+#define CONFIG_PCIE_PORT1
+#define CONFIG_PCIE_PORT2
+#define RALINK_PCIE0_CLK_EN             (1<<24)
+#define RALINK_PCIE1_CLK_EN             (1<<25)
+#define RALINK_PCIE2_CLK_EN             (1<<26)
+
+#define RALINK_PCI_CONFIG_ADDR                         0x20
+#define RALINK_PCI_CONFIG_DATA_VIRTUAL_REG     0x24
+#define SURFBOARDINT_PCIE0       11      /* PCIE0 */
+#define RALINK_INT_PCIE0         SURFBOARDINT_PCIE0
+#define RALINK_INT_PCIE1         SURFBOARDINT_PCIE1
+#define RALINK_INT_PCIE2         SURFBOARDINT_PCIE2
+#define SURFBOARDINT_PCIE1       31     /* PCIE1 */
+#define SURFBOARDINT_PCIE2       32     /* PCIE2 */
+#define RALINK_PCI_MEMBASE              *(volatile u32 *)(RALINK_PCI_BASE + 0x0028)
+#define RALINK_PCI_IOBASE               *(volatile u32 *)(RALINK_PCI_BASE + 0x002C)
+#define RALINK_PCIE0_RST                (1<<24)
+#define RALINK_PCIE1_RST                (1<<25)
+#define RALINK_PCIE2_RST                (1<<26)
+#define RALINK_SYSCTL_BASE              0xBE000000
+
+#define RALINK_PCI_PCICFG_ADDR          *(volatile u32 *)(RALINK_PCI_BASE + 0x0000)
+#define RALINK_PCI_PCIMSK_ADDR          *(volatile u32 *)(RALINK_PCI_BASE + 0x000C)
+#define RALINK_PCI_BASE                 0xBE140000
+
+#define RALINK_PCIEPHY_P0P1_CTL_OFFSET (RALINK_PCI_BASE + 0x9000)
+#define RT6855_PCIE0_OFFSET     0x2000
+#define RT6855_PCIE1_OFFSET     0x3000
+#define RT6855_PCIE2_OFFSET     0x4000
+
+#define RALINK_PCI0_BAR0SETUP_ADDR      *(volatile u32 *)(RALINK_PCI_BASE + RT6855_PCIE0_OFFSET + 0x0010)
+#define RALINK_PCI0_IMBASEBAR0_ADDR     *(volatile u32 *)(RALINK_PCI_BASE + RT6855_PCIE0_OFFSET + 0x0018)
+#define RALINK_PCI0_ID                  *(volatile u32 *)(RALINK_PCI_BASE + RT6855_PCIE0_OFFSET + 0x0030)
+#define RALINK_PCI0_CLASS               *(volatile u32 *)(RALINK_PCI_BASE + RT6855_PCIE0_OFFSET + 0x0034)
+#define RALINK_PCI0_SUBID               *(volatile u32 *)(RALINK_PCI_BASE + RT6855_PCIE0_OFFSET + 0x0038)
+#define RALINK_PCI0_STATUS              *(volatile u32 *)(RALINK_PCI_BASE + RT6855_PCIE0_OFFSET + 0x0050)
+#define RALINK_PCI0_DERR                *(volatile u32 *)(RALINK_PCI_BASE + RT6855_PCIE0_OFFSET + 0x0060)
+#define RALINK_PCI0_ECRC                *(volatile u32 *)(RALINK_PCI_BASE + RT6855_PCIE0_OFFSET + 0x0064)
+
+#define RALINK_PCI1_BAR0SETUP_ADDR      *(volatile u32 *)(RALINK_PCI_BASE + RT6855_PCIE1_OFFSET + 0x0010)
+#define RALINK_PCI1_IMBASEBAR0_ADDR     *(volatile u32 *)(RALINK_PCI_BASE + RT6855_PCIE1_OFFSET + 0x0018)
+#define RALINK_PCI1_ID                  *(volatile u32 *)(RALINK_PCI_BASE + RT6855_PCIE1_OFFSET + 0x0030)
+#define RALINK_PCI1_CLASS               *(volatile u32 *)(RALINK_PCI_BASE + RT6855_PCIE1_OFFSET + 0x0034)
+#define RALINK_PCI1_SUBID               *(volatile u32 *)(RALINK_PCI_BASE + RT6855_PCIE1_OFFSET + 0x0038)
+#define RALINK_PCI1_STATUS              *(volatile u32 *)(RALINK_PCI_BASE + RT6855_PCIE1_OFFSET + 0x0050)
+#define RALINK_PCI1_DERR                *(volatile u32 *)(RALINK_PCI_BASE + RT6855_PCIE1_OFFSET + 0x0060)
+#define RALINK_PCI1_ECRC                *(volatile u32 *)(RALINK_PCI_BASE + RT6855_PCIE1_OFFSET + 0x0064)
+
+#define RALINK_PCI2_BAR0SETUP_ADDR      *(volatile u32 *)(RALINK_PCI_BASE + RT6855_PCIE2_OFFSET + 0x0010)
+#define RALINK_PCI2_IMBASEBAR0_ADDR     *(volatile u32 *)(RALINK_PCI_BASE + RT6855_PCIE2_OFFSET + 0x0018)
+#define RALINK_PCI2_ID                  *(volatile u32 *)(RALINK_PCI_BASE + RT6855_PCIE2_OFFSET + 0x0030)
+#define RALINK_PCI2_CLASS               *(volatile u32 *)(RALINK_PCI_BASE + RT6855_PCIE2_OFFSET + 0x0034)
+#define RALINK_PCI2_SUBID               *(volatile u32 *)(RALINK_PCI_BASE + RT6855_PCIE2_OFFSET + 0x0038)
+#define RALINK_PCI2_STATUS              *(volatile u32 *)(RALINK_PCI_BASE + RT6855_PCIE2_OFFSET + 0x0050)
+#define RALINK_PCI2_DERR                *(volatile u32 *)(RALINK_PCI_BASE + RT6855_PCIE2_OFFSET + 0x0060)
+#define RALINK_PCI2_ECRC                *(volatile u32 *)(RALINK_PCI_BASE + RT6855_PCIE2_OFFSET + 0x0064)
+
+#define RALINK_PCIEPHY_P0P1_CTL_OFFSET  (RALINK_PCI_BASE + 0x9000)
+#define RALINK_PCIEPHY_P2_CTL_OFFSET    (RALINK_PCI_BASE + 0xA000)
+
+
+#define MV_WRITE(ofs, data)  \
+        *(volatile u32 *)(RALINK_PCI_BASE+(ofs)) = cpu_to_le32(data)
+#define MV_READ(ofs, data)   \
+	        *(data) = le32_to_cpu(*(volatile u32 *)(RALINK_PCI_BASE+(ofs)))
+#define MV_READ_DATA(ofs)    \
+		        le32_to_cpu(*(volatile u32 *)(RALINK_PCI_BASE+(ofs)))
+
+#define MV_WRITE_16(ofs, data)  \
+        *(volatile u16 *)(RALINK_PCI_BASE+(ofs)) = cpu_to_le16(data)
+#define MV_READ_16(ofs, data)   \
+	        *(data) = le16_to_cpu(*(volatile u16 *)(RALINK_PCI_BASE+(ofs)))
+
+#define MV_WRITE_8(ofs, data)  \
+        *(volatile u8 *)(RALINK_PCI_BASE+(ofs)) = data
+#define MV_READ_8(ofs, data)   \
+	        *(data) = *(volatile u8 *)(RALINK_PCI_BASE+(ofs))
+
+
+
+#define RALINK_PCI_MM_MAP_BASE	0x60000000
+#define RALINK_PCI_IO_MAP_BASE	0x1e160000
+
+#define RALINK_SYSTEM_CONTROL_BASE	0xbe000000
+#define GPIO_PERST
+#define ASSERT_SYSRST_PCIE(val)		do {	\
+						if (*(unsigned int *)(0xbe00000c) == 0x00030101)	\
+							RALINK_RSTCTRL |= val;	\
+						else	\
+							RALINK_RSTCTRL &= ~val;	\
+					} while(0)
+#define DEASSERT_SYSRST_PCIE(val) 	do {	\
+						if (*(unsigned int *)(0xbe00000c) == 0x00030101)	\
+							RALINK_RSTCTRL &= ~val;	\
+						else	\
+							RALINK_RSTCTRL |= val;	\
+					} while(0)
+#define RALINK_SYSCFG1			*(unsigned int *)(RALINK_SYSTEM_CONTROL_BASE + 0x14)
+#define RALINK_CLKCFG1			*(unsigned int *)(RALINK_SYSTEM_CONTROL_BASE + 0x30)
+#define RALINK_RSTCTRL			*(unsigned int *)(RALINK_SYSTEM_CONTROL_BASE + 0x34)
+#define RALINK_GPIOMODE			*(unsigned int *)(RALINK_SYSTEM_CONTROL_BASE + 0x60)
+#define RALINK_PCIE_CLK_GEN		*(unsigned int *)(RALINK_SYSTEM_CONTROL_BASE + 0x7c)
+#define RALINK_PCIE_CLK_GEN1		*(unsigned int *)(RALINK_SYSTEM_CONTROL_BASE + 0x80)
+#define PPLL_CFG1			*(unsigned int *)(RALINK_SYSTEM_CONTROL_BASE + 0x9c)
+#define PPLL_DRV			*(unsigned int *)(RALINK_SYSTEM_CONTROL_BASE + 0xa0)
+//RALINK_SYSCFG1 bit
+#define RALINK_PCI_HOST_MODE_EN		(1<<7)
+#define RALINK_PCIE_RC_MODE_EN		(1<<8)
+//RALINK_RSTCTRL bit
+#define RALINK_PCIE_RST			(1<<23)
+#define RALINK_PCI_RST			(1<<24)
+//RALINK_CLKCFG1 bit
+#define RALINK_PCI_CLK_EN		(1<<19)
+#define RALINK_PCIE_CLK_EN		(1<<21)
+//RALINK_GPIOMODE bit
+#define PCI_SLOTx2			(1<<11)
+#define PCI_SLOTx1			(2<<11)
+//MTK PCIE PLL bit
+#define PDRV_SW_SET			(1<<31)
+#define LC_CKDRVPD_			(1<<19)
+
+#define MEMORY_BASE 0x0
+static int pcie_link_status = 0;
+
+#define PCI_ACCESS_READ_1  0
+#define PCI_ACCESS_READ_2  1
+#define PCI_ACCESS_READ_4  2
+#define PCI_ACCESS_WRITE_1 3
+#define PCI_ACCESS_WRITE_2 4
+#define PCI_ACCESS_WRITE_4 5
+
+static int config_access(unsigned char access_type, struct pci_bus *bus,
+			unsigned int devfn, unsigned int where, u32 * data)
+{
+	unsigned int slot = PCI_SLOT(devfn);
+	u8 func = PCI_FUNC(devfn);
+	uint32_t address_reg, data_reg;
+	unsigned int address;
+
+	address_reg = RALINK_PCI_CONFIG_ADDR;
+	data_reg = RALINK_PCI_CONFIG_DATA_VIRTUAL_REG;
+
+	address = (((where&0xF00)>>8)<<24) |(bus->number << 16) | (slot << 11) | (func << 8) | (where & 0xfc) | 0x80000000;
+	MV_WRITE(address_reg, address);
+
+	switch(access_type) {
+	case PCI_ACCESS_WRITE_1:
+		MV_WRITE_8(data_reg+(where&0x3), *data);
+		break;
+	case PCI_ACCESS_WRITE_2:
+		MV_WRITE_16(data_reg+(where&0x3), *data);
+		break;
+	case PCI_ACCESS_WRITE_4:
+		MV_WRITE(data_reg, *data);
+		break;
+	case PCI_ACCESS_READ_1:
+		MV_READ_8( data_reg+(where&0x3), data);
+		break;
+	case PCI_ACCESS_READ_2:
+		MV_READ_16(data_reg+(where&0x3), data);
+		break;
+	case PCI_ACCESS_READ_4:
+		MV_READ(data_reg, data);
+		break;
+	default:
+		printk("no specify access type\n");
+		break;
+	}
+	return 0;
+}
+
+static int
+read_config_byte(struct pci_bus *bus, unsigned int devfn, int where, u8 * val)
+{
+	return config_access(PCI_ACCESS_READ_1, bus, devfn, (unsigned int)where, (u32 *)val);
+}
+
+static int
+read_config_word(struct pci_bus *bus, unsigned int devfn, int where, u16 * val)
+{
+	return config_access(PCI_ACCESS_READ_2, bus, devfn, (unsigned int)where, (u32 *)val);
+}
+
+static int
+read_config_dword(struct pci_bus *bus, unsigned int devfn, int where, u32 * val)
+{
+	return config_access(PCI_ACCESS_READ_4, bus, devfn, (unsigned int)where, (u32 *)val);
+}
+
+static int
+write_config_byte(struct pci_bus *bus, unsigned int devfn, int where, u8 val)
+{
+	if (config_access(PCI_ACCESS_WRITE_1, bus, devfn, (unsigned int)where, (u32 *)&val))
+		return -1;
+
+	return PCIBIOS_SUCCESSFUL;
+}
+
+static int
+write_config_word(struct pci_bus *bus, unsigned int devfn, int where, u16 val)
+{
+	if (config_access(PCI_ACCESS_WRITE_2, bus, devfn, where, (u32 *)&val))
+		return -1;
+
+	return PCIBIOS_SUCCESSFUL;
+}
+
+static int
+write_config_dword(struct pci_bus *bus, unsigned int devfn, int where, u32 val)
+{
+	if (config_access(PCI_ACCESS_WRITE_4, bus, devfn, where, &val))
+		return -1;
+
+	return PCIBIOS_SUCCESSFUL;
+}
+
+
+static int
+pci_config_read(struct pci_bus *bus, unsigned int devfn, int where, int size, u32 * val)
+{
+	switch (size) {
+	case 1:
+		return read_config_byte(bus, devfn, where, (u8 *) val);
+	case 2:
+		return read_config_word(bus, devfn, where, (u16 *) val);
+	default:
+		return read_config_dword(bus, devfn, where, val);
+	}
+}
+
+static int
+pci_config_write(struct pci_bus *bus, unsigned int devfn, int where, int size, u32 val)
+{
+	switch (size) {
+	case 1:
+		return write_config_byte(bus, devfn, where, (u8) val);
+	case 2:
+		return write_config_word(bus, devfn, where, (u16) val);
+	default:
+		return write_config_dword(bus, devfn, where, val);
+	}
+}
+
+struct pci_ops mt7621_pci_ops= {
+	.read		=  pci_config_read,
+	.write		= pci_config_write,
+};
+
+static struct resource mt7621_res_pci_mem1 = {
+	.name		= "PCI MEM1",
+	.start		= RALINK_PCI_MM_MAP_BASE,
+	.end		= (u32)((RALINK_PCI_MM_MAP_BASE + (unsigned char *)0x0fffffff)),
+	.flags		= IORESOURCE_MEM,
+};
+static struct resource mt7621_res_pci_io1 = {
+	.name		= "PCI I/O1",
+	.start		= RALINK_PCI_IO_MAP_BASE,
+	.end		= (u32)((RALINK_PCI_IO_MAP_BASE + (unsigned char *)0x0ffff)),
+	.flags		= IORESOURCE_IO,
+};
+
+static struct pci_controller mt7621_controller = {
+	.pci_ops	= &mt7621_pci_ops,
+	.mem_resource	= &mt7621_res_pci_mem1,
+	.io_resource	= &mt7621_res_pci_io1,
+	.mem_offset	= 0x00000000UL,
+	.io_offset	= 0x00000000UL,
+	.io_map_base	= 0xa0000000,
+};
+
+static void
+read_config(unsigned long bus, unsigned long dev, unsigned long func, unsigned long reg, unsigned long *val)
+{
+	unsigned int address_reg, data_reg, address;
+
+	address_reg = RALINK_PCI_CONFIG_ADDR;
+        data_reg = RALINK_PCI_CONFIG_DATA_VIRTUAL_REG;
+	address = (((reg & 0xF00)>>8)<<24) | (bus << 16) | (dev << 11) | (func << 8) | (reg & 0xfc) | 0x80000000 ;
+        MV_WRITE(address_reg, address);
+        MV_READ(data_reg, val);
+	return;
+}
+
+static void
+write_config(unsigned long bus, unsigned long dev, unsigned long func, unsigned long reg, unsigned long val)
+{
+	unsigned int address_reg, data_reg, address;
+
+	address_reg = RALINK_PCI_CONFIG_ADDR;
+	data_reg = RALINK_PCI_CONFIG_DATA_VIRTUAL_REG;
+	address = (((reg & 0xF00)>>8)<<24) | (bus << 16) | (dev << 11) | (func << 8) | (reg & 0xfc) | 0x80000000 ;
+	MV_WRITE(address_reg, address);
+	MV_WRITE(data_reg, val);
+	return;
+}
+
+
+int
+pcibios_map_irq(const struct pci_dev *dev, u8 slot, u8 pin)
+{
+	u16 cmd;
+	u32 val;
+	int irq = 0;
+
+	if ((dev->bus->number == 0) && (slot == 0)) {
+		write_config(0, 0, 0, PCI_BASE_ADDRESS_0, MEMORY_BASE);
+		read_config(0, 0, 0, PCI_BASE_ADDRESS_0, (unsigned long *)&val);
+		printk("BAR0 at slot 0 = %x\n", val);
+		printk("bus=0x%x, slot = 0x%x\n",dev->bus->number, slot);
+	} else if((dev->bus->number == 0) && (slot == 0x1)) {
+		write_config(0, 1, 0, PCI_BASE_ADDRESS_0, MEMORY_BASE);
+		read_config(0, 1, 0, PCI_BASE_ADDRESS_0, (unsigned long *)&val);
+		printk("BAR0 at slot 1 = %x\n", val);
+		printk("bus=0x%x, slot = 0x%x\n",dev->bus->number, slot);
+	} else if((dev->bus->number == 0) && (slot == 0x2)) {
+		write_config(0, 2, 0, PCI_BASE_ADDRESS_0, MEMORY_BASE);
+		read_config(0, 2, 0, PCI_BASE_ADDRESS_0, (unsigned long *)&val);
+		printk("BAR0 at slot 2 = %x\n", val);
+		printk("bus=0x%x, slot = 0x%x\n",dev->bus->number, slot);
+	} else if ((dev->bus->number == 1) && (slot == 0x0)) {
+		switch (pcie_link_status) {
+		case 2:
+		case 6:
+			irq = RALINK_INT_PCIE1;
+			break;
+		case 4:
+			irq = RALINK_INT_PCIE2;
+			break;
+		default:
+			irq = RALINK_INT_PCIE0;
+		}
+		printk("bus=0x%x, slot = 0x%x, irq=0x%x\n",dev->bus->number, slot, dev->irq);
+	} else if ((dev->bus->number == 2) && (slot == 0x0)) {
+		switch (pcie_link_status) {
+		case 5:
+		case 6:
+			irq = RALINK_INT_PCIE2;
+			break;
+		default:
+			irq = RALINK_INT_PCIE1;
+		}
+		printk("bus=0x%x, slot = 0x%x, irq=0x%x\n",dev->bus->number, slot, dev->irq);
+	} else if ((dev->bus->number == 2) && (slot == 0x1)) {
+		switch (pcie_link_status) {
+		case 5:
+		case 6:
+			irq = RALINK_INT_PCIE2;
+			break;
+		default:
+			irq = RALINK_INT_PCIE1;
+		}
+		printk("bus=0x%x, slot = 0x%x, irq=0x%x\n",dev->bus->number, slot, dev->irq);
+	} else if ((dev->bus->number ==3) && (slot == 0x0)) {
+		irq = RALINK_INT_PCIE2;
+		printk("bus=0x%x, slot = 0x%x, irq=0x%x\n",dev->bus->number, slot, dev->irq);
+	} else if ((dev->bus->number ==3) && (slot == 0x1)) {
+		irq = RALINK_INT_PCIE2;
+		printk("bus=0x%x, slot = 0x%x, irq=0x%x\n",dev->bus->number, slot, dev->irq);
+	} else if ((dev->bus->number ==3) && (slot == 0x2)) {
+		irq = RALINK_INT_PCIE2;
+		printk("bus=0x%x, slot = 0x%x, irq=0x%x\n",dev->bus->number, slot, dev->irq);
+	} else {
+		printk("bus=0x%x, slot = 0x%x\n",dev->bus->number, slot);
+		return 0;
+	}
+
+	pci_write_config_byte(dev, PCI_CACHE_LINE_SIZE, 0x14);  //configure cache line size 0x14
+	pci_write_config_byte(dev, PCI_LATENCY_TIMER, 0xFF);  //configure latency timer 0x10
+	pci_read_config_word(dev, PCI_COMMAND, &cmd);
+	cmd = cmd | PCI_COMMAND_MASTER | PCI_COMMAND_IO | PCI_COMMAND_MEMORY;
+	pci_write_config_word(dev, PCI_COMMAND, cmd);
+	pci_write_config_byte(dev, PCI_INTERRUPT_LINE, irq);
+#ifdef	CONFIG_DTB_GNUBEE1
+	/*
+	 * 'irq' here is a hwirq, but a virq is needed.  Until we know how and where
+	 * to convert one to the other, we have this hack for the GNUBEE1
+	 */
+	return irq == 11 ? 22 : irq;
+#else
+	return irq;
+#endif
+}
+
+void
+set_pcie_phy(u32 *addr, int start_b, int bits, int val)
+{
+//	printk("0x%p:", addr);
+//	printk(" %x", *addr);
+	*(unsigned int *)(addr) &= ~(((1<<bits) - 1)<<start_b);
+	*(unsigned int *)(addr) |= val << start_b;
+//	printk(" -> %x\n", *addr);
+}
+
+void
+bypass_pipe_rst(void)
+{
+#if defined (CONFIG_PCIE_PORT0)
+	/* PCIe Port 0 */
+	set_pcie_phy((u32 *)(RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x02c), 12, 1, 0x01);	// rg_pe1_pipe_rst_b
+	set_pcie_phy((u32 *)(RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x02c),  4, 1, 0x01);	// rg_pe1_pipe_cmd_frc[4]
+#endif
+#if defined (CONFIG_PCIE_PORT1)
+	/* PCIe Port 1 */
+	set_pcie_phy((u32 *)(RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x12c), 12, 1, 0x01);	// rg_pe1_pipe_rst_b
+	set_pcie_phy((u32 *)(RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x12c),  4, 1, 0x01);	// rg_pe1_pipe_cmd_frc[4]
+#endif
+#if defined (CONFIG_PCIE_PORT2)
+	/* PCIe Port 2 */
+	set_pcie_phy((u32 *)(RALINK_PCIEPHY_P2_CTL_OFFSET + 0x02c), 12, 1, 0x01);	// rg_pe1_pipe_rst_b
+	set_pcie_phy((u32 *)(RALINK_PCIEPHY_P2_CTL_OFFSET + 0x02c),  4, 1, 0x01);	// rg_pe1_pipe_cmd_frc[4]
+#endif
+}
+
+void
+set_phy_for_ssc(void)
+{
+	unsigned long reg = (*(volatile u32 *)(RALINK_SYSCTL_BASE + 0x10));
+
+	reg = (reg >> 6) & 0x7;
+#if defined (CONFIG_PCIE_PORT0) || defined (CONFIG_PCIE_PORT1)
+	/* Set PCIe Port0 & Port1 PHY to disable SSC */
+	/* Debug Xtal Type */
+	set_pcie_phy((u32 *)(RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x400),  8, 1, 0x01);	// rg_pe1_frc_h_xtal_type
+	set_pcie_phy((u32 *)(RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x400),  9, 2, 0x00);	// rg_pe1_h_xtal_type
+	set_pcie_phy((u32 *)(RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x000),  4, 1, 0x01);	// rg_pe1_frc_phy_en               //Force Port 0 enable control
+	set_pcie_phy((u32 *)(RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x100),  4, 1, 0x01);	// rg_pe1_frc_phy_en               //Force Port 1 enable control
+	set_pcie_phy((u32 *)(RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x000),  5, 1, 0x00);	// rg_pe1_phy_en                   //Port 0 disable
+	set_pcie_phy((u32 *)(RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x100),  5, 1, 0x00);	// rg_pe1_phy_en                   //Port 1 disable
+	if(reg <= 5 && reg >= 3) { 	// 40MHz Xtal
+		set_pcie_phy((u32 *)(RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x490),  6, 2, 0x01);	// RG_PE1_H_PLL_PREDIV             //Pre-divider ratio (for host mode)
+		printk("***** Xtal 40MHz *****\n");
+	} else {			// 25MHz | 20MHz Xtal
+		set_pcie_phy((u32 *)(RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x490),  6, 2, 0x00);	// RG_PE1_H_PLL_PREDIV             //Pre-divider ratio (for host mode)
+		if (reg >= 6) { 	
+			printk("***** Xtal 25MHz *****\n");
+			set_pcie_phy((u32 *)(RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x4bc),  4, 2, 0x01);	// RG_PE1_H_PLL_FBKSEL             //Feedback clock select
+			set_pcie_phy((u32 *)(RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x49c),  0,31, 0x18000000);	// RG_PE1_H_LCDDS_PCW_NCPO         //DDS NCPO PCW (for host mode)
+			set_pcie_phy((u32 *)(RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x4a4),  0,16, 0x18d);	// RG_PE1_H_LCDDS_SSC_PRD          //DDS SSC dither period control
+			set_pcie_phy((u32 *)(RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x4a8),  0,12, 0x4a);	// RG_PE1_H_LCDDS_SSC_DELTA        //DDS SSC dither amplitude control
+			set_pcie_phy((u32 *)(RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x4a8), 16,12, 0x4a);	// RG_PE1_H_LCDDS_SSC_DELTA1       //DDS SSC dither amplitude control for initial
+		} else {
+			printk("***** Xtal 20MHz *****\n");
+		}
+	}
+	set_pcie_phy((u32 *)(RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x4a0),  5, 1, 0x01);	// RG_PE1_LCDDS_CLK_PH_INV         //DDS clock inversion
+	set_pcie_phy((u32 *)(RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x490), 22, 2, 0x02);	// RG_PE1_H_PLL_BC                 
+	set_pcie_phy((u32 *)(RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x490), 18, 4, 0x06);	// RG_PE1_H_PLL_BP                 
+	set_pcie_phy((u32 *)(RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x490), 12, 4, 0x02);	// RG_PE1_H_PLL_IR                 
+	set_pcie_phy((u32 *)(RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x490),  8, 4, 0x01);	// RG_PE1_H_PLL_IC                 
+	set_pcie_phy((u32 *)(RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x4ac), 16, 3, 0x00);	// RG_PE1_H_PLL_BR                 
+	set_pcie_phy((u32 *)(RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x490),  1, 3, 0x02);	// RG_PE1_PLL_DIVEN                
+	if(reg <= 5 && reg >= 3) { 	// 40MHz Xtal
+		set_pcie_phy((u32 *)(RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x414),  6, 2, 0x01);	// rg_pe1_mstckdiv		//value of da_pe1_mstckdiv when force mode enable
+		set_pcie_phy((u32 *)(RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x414),  5, 1, 0x01);	// rg_pe1_frc_mstckdiv          //force mode enable of da_pe1_mstckdiv      
+	}
+	/* Enable PHY and disable force mode */
+	set_pcie_phy((u32 *)(RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x000),  5, 1, 0x01);	// rg_pe1_phy_en                   //Port 0 enable
+	set_pcie_phy((u32 *)(RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x100),  5, 1, 0x01);	// rg_pe1_phy_en                   //Port 1 enable
+	set_pcie_phy((u32 *)(RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x000),  4, 1, 0x00);	// rg_pe1_frc_phy_en               //Force Port 0 disable control
+	set_pcie_phy((u32 *)(RALINK_PCIEPHY_P0P1_CTL_OFFSET + 0x100),  4, 1, 0x00);	// rg_pe1_frc_phy_en               //Force Port 1 disable control
+#endif
+#if defined (CONFIG_PCIE_PORT2)
+	/* Set PCIe Port2 PHY to disable SSC */
+	/* Debug Xtal Type */
+	set_pcie_phy((u32 *)(RALINK_PCIEPHY_P2_CTL_OFFSET + 0x400),  8, 1, 0x01);	// rg_pe1_frc_h_xtal_type
+	set_pcie_phy((u32 *)(RALINK_PCIEPHY_P2_CTL_OFFSET + 0x400),  9, 2, 0x00);	// rg_pe1_h_xtal_type
+	set_pcie_phy((u32 *)(RALINK_PCIEPHY_P2_CTL_OFFSET + 0x000),  4, 1, 0x01);	// rg_pe1_frc_phy_en               //Force Port 0 enable control
+	set_pcie_phy((u32 *)(RALINK_PCIEPHY_P2_CTL_OFFSET + 0x000),  5, 1, 0x00);	// rg_pe1_phy_en                   //Port 0 disable
+	if(reg <= 5 && reg >= 3) { 	// 40MHz Xtal
+		set_pcie_phy((u32 *)(RALINK_PCIEPHY_P2_CTL_OFFSET + 0x490),  6, 2, 0x01);	// RG_PE1_H_PLL_PREDIV             //Pre-divider ratio (for host mode)
+	} else {			// 25MHz | 20MHz Xtal
+		set_pcie_phy((u32 *)(RALINK_PCIEPHY_P2_CTL_OFFSET + 0x490),  6, 2, 0x00);	// RG_PE1_H_PLL_PREDIV             //Pre-divider ratio (for host mode)
+		if (reg >= 6) { 	// 25MHz Xtal
+			set_pcie_phy((u32 *)(RALINK_PCIEPHY_P2_CTL_OFFSET + 0x4bc),  4, 2, 0x01);	// RG_PE1_H_PLL_FBKSEL             //Feedback clock select
+			set_pcie_phy((u32 *)(RALINK_PCIEPHY_P2_CTL_OFFSET + 0x49c),  0,31, 0x18000000);	// RG_PE1_H_LCDDS_PCW_NCPO         //DDS NCPO PCW (for host mode)
+			set_pcie_phy((u32 *)(RALINK_PCIEPHY_P2_CTL_OFFSET + 0x4a4),  0,16, 0x18d);	// RG_PE1_H_LCDDS_SSC_PRD          //DDS SSC dither period control
+			set_pcie_phy((u32 *)(RALINK_PCIEPHY_P2_CTL_OFFSET + 0x4a8),  0,12, 0x4a);	// RG_PE1_H_LCDDS_SSC_DELTA        //DDS SSC dither amplitude control
+			set_pcie_phy((u32 *)(RALINK_PCIEPHY_P2_CTL_OFFSET + 0x4a8), 16,12, 0x4a);	// RG_PE1_H_LCDDS_SSC_DELTA1       //DDS SSC dither amplitude control for initial
+		}
+	}
+	set_pcie_phy((u32 *)(RALINK_PCIEPHY_P2_CTL_OFFSET + 0x4a0),  5, 1, 0x01);	// RG_PE1_LCDDS_CLK_PH_INV         //DDS clock inversion
+	set_pcie_phy((u32 *)(RALINK_PCIEPHY_P2_CTL_OFFSET + 0x490), 22, 2, 0x02);	// RG_PE1_H_PLL_BC                 
+	set_pcie_phy((u32 *)(RALINK_PCIEPHY_P2_CTL_OFFSET + 0x490), 18, 4, 0x06);	// RG_PE1_H_PLL_BP                 
+	set_pcie_phy((u32 *)(RALINK_PCIEPHY_P2_CTL_OFFSET + 0x490), 12, 4, 0x02);	// RG_PE1_H_PLL_IR                 
+	set_pcie_phy((u32 *)(RALINK_PCIEPHY_P2_CTL_OFFSET + 0x490),  8, 4, 0x01);	// RG_PE1_H_PLL_IC                 
+	set_pcie_phy((u32 *)(RALINK_PCIEPHY_P2_CTL_OFFSET + 0x4ac), 16, 3, 0x00);	// RG_PE1_H_PLL_BR                 
+	set_pcie_phy((u32 *)(RALINK_PCIEPHY_P2_CTL_OFFSET + 0x490),  1, 3, 0x02);	// RG_PE1_PLL_DIVEN                
+	if(reg <= 5 && reg >= 3) { 	// 40MHz Xtal
+		set_pcie_phy((u32 *)(RALINK_PCIEPHY_P2_CTL_OFFSET + 0x414),  6, 2, 0x01);	// rg_pe1_mstckdiv		//value of da_pe1_mstckdiv when force mode enable
+		set_pcie_phy((u32 *)(RALINK_PCIEPHY_P2_CTL_OFFSET + 0x414),  5, 1, 0x01);	// rg_pe1_frc_mstckdiv          //force mode enable of da_pe1_mstckdiv      
+	}
+	/* Enable PHY and disable force mode */
+	set_pcie_phy((u32 *)(RALINK_PCIEPHY_P2_CTL_OFFSET + 0x000),  5, 1, 0x01);	// rg_pe1_phy_en                   //Port 0 enable
+	set_pcie_phy((u32 *)(RALINK_PCIEPHY_P2_CTL_OFFSET + 0x000),  4, 1, 0x00);	// rg_pe1_frc_phy_en               //Force Port 0 disable control
+#endif
+}
+
+void setup_cm_memory_region(struct resource *mem_resource)
+{
+	resource_size_t mask;
+	if (mips_cps_numiocu(0)) {
+		/* FIXME: hardware doesn't accept mask values with 1s after
+		   0s (e.g. 0xffef), so it would be great to warn if that's
+		   about to happen */
+		mask = ~(mem_resource->end - mem_resource->start);
+
+		write_gcr_reg1_base(mem_resource->start);
+		write_gcr_reg1_mask(mask | CM_GCR_REGn_MASK_CMTGT_IOCU0);
+		printk("PCI coherence region base: 0x%08llx, mask/settings: 0x%08llx\n",
+		       (unsigned long long)read_gcr_reg1_base(),
+		       (unsigned long long)read_gcr_reg1_mask());
+	}
+}
+
+static int mt7621_pci_probe(struct platform_device *pdev)
+{
+	unsigned long val = 0;
+
+	iomem_resource.start = 0;
+	iomem_resource.end= ~0;
+	ioport_resource.start= 0;
+	ioport_resource.end = ~0;
+
+#if defined (CONFIG_PCIE_PORT0)
+	val = RALINK_PCIE0_RST;
+#endif
+#if defined (CONFIG_PCIE_PORT1)
+	val |= RALINK_PCIE1_RST;
+#endif
+#if defined (CONFIG_PCIE_PORT2)
+	val |= RALINK_PCIE2_RST;
+#endif
+	ASSERT_SYSRST_PCIE(RALINK_PCIE0_RST | RALINK_PCIE1_RST | RALINK_PCIE2_RST);
+	printk("pull PCIe RST: RALINK_RSTCTRL = %x\n", RALINK_RSTCTRL);
+#if defined GPIO_PERST /* add GPIO control instead of PERST_N */ /*chhung*/
+	*(unsigned int *)(0xbe000060) &= ~(0x3<<10 | 0x3<<3);
+	*(unsigned int *)(0xbe000060) |= 0x1<<10 | 0x1<<3;
+	mdelay(100);
+	*(unsigned int *)(0xbe000600) |= 0x1<<19 | 0x1<<8 | 0x1<<7; // use GPIO19/GPIO8/GPIO7 (PERST_N/UART_RXD3/UART_TXD3)
+	mdelay(100);
+	*(unsigned int *)(0xbe000620) &= ~(0x1<<19 | 0x1<<8 | 0x1<<7);		// clear DATA
+
+	mdelay(100);
+#else
+	*(unsigned int *)(0xbe000060) &= ~0x00000c00;
+#endif
+#if defined (CONFIG_PCIE_PORT0)
+	val = RALINK_PCIE0_RST;
+#endif
+#if defined (CONFIG_PCIE_PORT1)
+	val |= RALINK_PCIE1_RST;
+#endif
+#if defined (CONFIG_PCIE_PORT2)
+	val |= RALINK_PCIE2_RST;
+#endif
+	DEASSERT_SYSRST_PCIE(val);
+	printk("release PCIe RST: RALINK_RSTCTRL = %x\n", RALINK_RSTCTRL);
+
+	if ((*(unsigned int *)(0xbe00000c)&0xFFFF) == 0x0101) // MT7621 E2
+		bypass_pipe_rst();
+	set_phy_for_ssc();
+	printk("release PCIe RST: RALINK_RSTCTRL = %x\n", RALINK_RSTCTRL);
+
+#if defined (CONFIG_PCIE_PORT0)
+	read_config(0, 0, 0, 0x70c, &val);
+	printk("Port 0 N_FTS = %x\n", (unsigned int)val);
+#endif
+#if defined (CONFIG_PCIE_PORT1)
+	read_config(0, 1, 0, 0x70c, &val);
+	printk("Port 1 N_FTS = %x\n", (unsigned int)val);
+#endif
+#if defined (CONFIG_PCIE_PORT2)
+	read_config(0, 2, 0, 0x70c, &val);
+	printk("Port 2 N_FTS = %x\n", (unsigned int)val);
+#endif
+
+	RALINK_RSTCTRL = (RALINK_RSTCTRL | RALINK_PCIE_RST);
+	RALINK_SYSCFG1 &= ~(0x30);
+	RALINK_SYSCFG1 |= (2<<4);
+	RALINK_PCIE_CLK_GEN &= 0x7fffffff;
+	RALINK_PCIE_CLK_GEN1 &= 0x80ffffff;
+	RALINK_PCIE_CLK_GEN1 |= 0xa << 24;
+	RALINK_PCIE_CLK_GEN |= 0x80000000;
+	mdelay(50);
+	RALINK_RSTCTRL = (RALINK_RSTCTRL & ~RALINK_PCIE_RST);
+	
+
+#if defined GPIO_PERST /* add GPIO control instead of PERST_N */  /*chhung*/
+	*(unsigned int *)(0xbe000620) |= 0x1<<19 | 0x1<<8 | 0x1<<7;		// set DATA
+	mdelay(100);
+#else
+	RALINK_PCI_PCICFG_ADDR &= ~(1<<1); //de-assert PERST
+#endif
+	mdelay(500);
+
+
+	mdelay(500);
+#if defined (CONFIG_PCIE_PORT0)
+	if(( RALINK_PCI0_STATUS & 0x1) == 0)
+	{
+		printk("PCIE0 no card, disable it(RST&CLK)\n");
+		ASSERT_SYSRST_PCIE(RALINK_PCIE0_RST);
+		RALINK_CLKCFG1 = (RALINK_CLKCFG1 & ~RALINK_PCIE0_CLK_EN);
+		pcie_link_status &= ~(1<<0);
+	} else {
+		pcie_link_status |= 1<<0;
+		RALINK_PCI_PCIMSK_ADDR |= (1<<20); // enable pcie1 interrupt
+	}
+#endif
+#if defined (CONFIG_PCIE_PORT1)
+	if(( RALINK_PCI1_STATUS & 0x1) == 0)
+	{
+		printk("PCIE1 no card, disable it(RST&CLK)\n");
+		ASSERT_SYSRST_PCIE(RALINK_PCIE1_RST);
+		RALINK_CLKCFG1 = (RALINK_CLKCFG1 & ~RALINK_PCIE1_CLK_EN);
+		pcie_link_status &= ~(1<<1);
+	} else {
+		pcie_link_status |= 1<<1;
+		RALINK_PCI_PCIMSK_ADDR |= (1<<21); // enable pcie1 interrupt
+	}
+#endif
+#if defined (CONFIG_PCIE_PORT2)
+	if (( RALINK_PCI2_STATUS & 0x1) == 0) {
+		printk("PCIE2 no card, disable it(RST&CLK)\n");
+		ASSERT_SYSRST_PCIE(RALINK_PCIE2_RST);
+		RALINK_CLKCFG1 = (RALINK_CLKCFG1 & ~RALINK_PCIE2_CLK_EN);
+		pcie_link_status &= ~(1<<2);
+	} else {
+		pcie_link_status |= 1<<2;
+		RALINK_PCI_PCIMSK_ADDR |= (1<<22); // enable pcie2 interrupt
+	}
+#endif
+	if (pcie_link_status == 0)
+		return 0;
+
+/*
+pcie(2/1/0) link status	pcie2_num	pcie1_num	pcie0_num
+3'b000			x		x		x
+3'b001			x		x		0
+3'b010			x		0		x
+3'b011			x		1		0
+3'b100			0		x		x
+3'b101			1		x		0
+3'b110			1		0		x
+3'b111			2		1		0
+*/
+	switch(pcie_link_status) {
+	case 2:
+		RALINK_PCI_PCICFG_ADDR &= ~0x00ff0000;
+		RALINK_PCI_PCICFG_ADDR |= 0x1 << 16;	//port0
+		RALINK_PCI_PCICFG_ADDR |= 0x0 << 20;	//port1
+		break;
+	case 4:
+		RALINK_PCI_PCICFG_ADDR &= ~0x0fff0000;
+		RALINK_PCI_PCICFG_ADDR |= 0x1 << 16;	//port0
+		RALINK_PCI_PCICFG_ADDR |= 0x2 << 20;	//port1
+		RALINK_PCI_PCICFG_ADDR |= 0x0 << 24;	//port2
+		break;
+	case 5:
+		RALINK_PCI_PCICFG_ADDR &= ~0x0fff0000;
+		RALINK_PCI_PCICFG_ADDR |= 0x0 << 16;	//port0
+		RALINK_PCI_PCICFG_ADDR |= 0x2 << 20;	//port1
+		RALINK_PCI_PCICFG_ADDR |= 0x1 << 24;	//port2
+		break;
+	case 6:
+		RALINK_PCI_PCICFG_ADDR &= ~0x0fff0000;
+		RALINK_PCI_PCICFG_ADDR |= 0x2 << 16;	//port0
+		RALINK_PCI_PCICFG_ADDR |= 0x0 << 20;	//port1
+		RALINK_PCI_PCICFG_ADDR |= 0x1 << 24;	//port2
+		break;
+	}
+	printk(" -> %x\n", RALINK_PCI_PCICFG_ADDR);
+	//printk(" RALINK_PCI_ARBCTL = %x\n", RALINK_PCI_ARBCTL);
+
+/*
+	ioport_resource.start = mt7621_res_pci_io1.start;
+  	ioport_resource.end = mt7621_res_pci_io1.end;
+*/
+
+	RALINK_PCI_MEMBASE = 0xffffffff; //RALINK_PCI_MM_MAP_BASE;
+	RALINK_PCI_IOBASE = RALINK_PCI_IO_MAP_BASE;
+
+#if defined (CONFIG_PCIE_PORT0)
+	//PCIe0
+	if((pcie_link_status & 0x1) != 0) {
+		RALINK_PCI0_BAR0SETUP_ADDR = 0x7FFF0001;	//open 7FFF:2G; ENABLE
+		RALINK_PCI0_IMBASEBAR0_ADDR = MEMORY_BASE;
+		RALINK_PCI0_CLASS = 0x06040001;
+		printk("PCIE0 enabled\n");
+	}
+#endif
+#if defined (CONFIG_PCIE_PORT1)
+	//PCIe1
+	if ((pcie_link_status & 0x2) != 0) {
+		RALINK_PCI1_BAR0SETUP_ADDR = 0x7FFF0001;	//open 7FFF:2G; ENABLE
+		RALINK_PCI1_IMBASEBAR0_ADDR = MEMORY_BASE;
+		RALINK_PCI1_CLASS = 0x06040001;
+		printk("PCIE1 enabled\n");
+	}
+#endif
+#if defined (CONFIG_PCIE_PORT2)
+	//PCIe2
+	if ((pcie_link_status & 0x4) != 0) {
+		RALINK_PCI2_BAR0SETUP_ADDR = 0x7FFF0001;	//open 7FFF:2G; ENABLE
+		RALINK_PCI2_IMBASEBAR0_ADDR = MEMORY_BASE;
+		RALINK_PCI2_CLASS = 0x06040001;
+		printk("PCIE2 enabled\n");
+	}
+#endif
+
+
+	switch(pcie_link_status) {
+	case 7:
+		read_config(0, 2, 0, 0x4, &val);
+		write_config(0, 2, 0, 0x4, val|0x4);
+		// write_config(0, 1, 0, 0x4, val|0x7);
+		read_config(0, 2, 0, 0x70c, &val);
+		val &= ~(0xff)<<8;
+		val |= 0x50<<8;
+		write_config(0, 2, 0, 0x70c, val);
+	case 3:
+	case 5:
+	case 6:
+		read_config(0, 1, 0, 0x4, &val);
+		write_config(0, 1, 0, 0x4, val|0x4);
+		// write_config(0, 1, 0, 0x4, val|0x7);
+		read_config(0, 1, 0, 0x70c, &val);
+		val &= ~(0xff)<<8;
+		val |= 0x50<<8;
+		write_config(0, 1, 0, 0x70c, val);
+	default:
+		read_config(0, 0, 0, 0x4, &val);
+		write_config(0, 0, 0, 0x4, val|0x4); //bus master enable
+		// write_config(0, 0, 0, 0x4, val|0x7); //bus master enable
+		read_config(0, 0, 0, 0x70c, &val);
+		val &= ~(0xff)<<8;
+		val |= 0x50<<8;
+		write_config(0, 0, 0, 0x70c, val);
+	}
+
+	pci_load_of_ranges(&mt7621_controller, pdev->dev.of_node);
+	setup_cm_memory_region(mt7621_controller.mem_resource);
+	register_pci_controller(&mt7621_controller);
+	return 0;
+
+}
+
+int pcibios_plat_dev_init(struct pci_dev *dev)
+{
+	return 0;
+}
+
+static const struct of_device_id mt7621_pci_ids[] = {
+	{ .compatible = "mediatek,mt7621-pci" },
+	{},
+};
+MODULE_DEVICE_TABLE(of, mt7621_pci_ids);
+
+static struct platform_driver mt7621_pci_driver = {
+	.probe = mt7621_pci_probe,
+	.driver = {
+		.name = "mt7621-pci",
+		.owner = THIS_MODULE,
+		.of_match_table = of_match_ptr(mt7621_pci_ids),
+	},
+};
+
+static int __init mt7621_pci_init(void)
+{
+	return platform_driver_register(&mt7621_pci_driver);
+}
+
+arch_initcall(mt7621_pci_init);
