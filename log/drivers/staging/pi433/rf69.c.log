commit d0222e9a6b4bb1d7c01b952468aab6296807411c
Author: Yannick Loeck <yannick.loeck@gmail.com>
Date:   Mon May 20 17:28:52 2019 +0200

    staging: pi433: fix misspelling of packet
    
    Fixes the misspelling of packet in
    <MASK_PACKETCONFIG1_PAKET_FORMAT_VARIABLE>
    
    Signed-off-by: Yannick Loeck <yannick.loeck@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/pi433/rf69.c b/drivers/staging/pi433/rf69.c
index 4cd16257f0aa..7d86bb8be245 100644
--- a/drivers/staging/pi433/rf69.c
+++ b/drivers/staging/pi433/rf69.c
@@ -722,10 +722,10 @@ int rf69_set_packet_format(struct spi_device *spi,
 	switch (packet_format) {
 	case packet_length_var:
 		return rf69_set_bit(spi, REG_PACKETCONFIG1,
-				    MASK_PACKETCONFIG1_PAKET_FORMAT_VARIABLE);
+				    MASK_PACKETCONFIG1_PACKET_FORMAT_VARIABLE);
 	case packet_length_fix:
 		return rf69_clear_bit(spi, REG_PACKETCONFIG1,
-				      MASK_PACKETCONFIG1_PAKET_FORMAT_VARIABLE);
+				      MASK_PACKETCONFIG1_PACKET_FORMAT_VARIABLE);
 	default:
 		dev_dbg(&spi->dev, "set: illegal input param");
 		return -EINVAL;

commit 7be2b288be66e08d78ede27d8ab0adb61b30d4db
Author: Sidong Yang <realwakka@gmail.com>
Date:   Wed Apr 10 05:09:06 2019 +0000

    staging: pi433: add dependency to PA0, 1, 2 setting for output power level
    
    When setting output power level called, the power level should be
    checked by power amplifier level register and high power option. There
    was todo about it. Add some variables for checking power level range.
    The values that used for checking high power or minimum power are from
    rf69 datasheets. The maximum power level is always same regardless of
    mode.
    
    Signed-off-by: Sidong Yang <realwakka@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/pi433/rf69.c b/drivers/staging/pi433/rf69.c
index 340ffa7ccf18..4cd16257f0aa 100644
--- a/drivers/staging/pi433/rf69.c
+++ b/drivers/staging/pi433/rf69.c
@@ -349,18 +349,51 @@ int rf69_disable_amplifier(struct spi_device *spi, u8 amplifier_mask)
 
 int rf69_set_output_power_level(struct spi_device *spi, u8 power_level)
 {
-	// TODO: Dependency to PA0,1,2 setting
-	power_level += 18;
+	u8 pa_level, ocp, test_pa1, test_pa2;
+	bool pa0, pa1, pa2, high_power;
+	u8 min_power_level;
+
+	// check register pa_level
+	pa_level = rf69_read_reg(spi, REG_PALEVEL);
+	pa0 = pa_level & MASK_PALEVEL_PA0;
+	pa1 = pa_level & MASK_PALEVEL_PA1;
+	pa2 = pa_level & MASK_PALEVEL_PA2;
+
+	// check high power mode
+	ocp = rf69_read_reg(spi, REG_OCP);
+	test_pa1 = rf69_read_reg(spi, REG_TESTPA1);
+	test_pa2 = rf69_read_reg(spi, REG_TESTPA2);
+	high_power = (ocp == 0x0f) && (test_pa1 == 0x5d) && (test_pa2 == 0x7c);
+
+	if (pa0 && !pa1 && !pa2) {
+		power_level += 18;
+		min_power_level = 0;
+	} else if (!pa0 && pa1 && !pa2) {
+		power_level += 18;
+		min_power_level = 16;
+	} else if (!pa0 && pa1 && pa2) {
+		if (high_power)
+			power_level += 11;
+		else
+			power_level += 14;
+		min_power_level = 16;
+	} else {
+		goto failed;
+	}
 
 	// check input value
-	if (power_level > 0x1f) {
-		dev_dbg(&spi->dev, "set: illegal input param");
-		return -EINVAL;
-	}
+	if (power_level > 0x1f)
+		goto failed;
+
+	if (power_level < min_power_level)
+		goto failed;
 
 	// write value
 	return rf69_read_mod_write(spi, REG_PALEVEL, MASK_PALEVEL_OUTPUT_POWER,
 				   power_level);
+failed:
+	dev_dbg(&spi->dev, "set: illegal input param");
+	return -EINVAL;
 }
 
 int rf69_set_pa_ramp(struct spi_device *spi, enum pa_ramp pa_ramp)

commit 3df3162f1d52c143f48fb213d8d2c7fcce5b41d5
Author: Bhagyashri Dighole <digholebhagyashri@gmail.com>
Date:   Thu Mar 14 00:37:17 2019 +0530

    staging: pi433: Remove unused variable.
    
    Remove unused variable which is used to store return value,
    Detected by Coccinelle semantic patch returnvar.cocci
    
    Signed-off-by: Bhagyashri Dighole <digholebhagyashri@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/pi433/rf69.c b/drivers/staging/pi433/rf69.c
index e19b9ce794a8..340ffa7ccf18 100644
--- a/drivers/staging/pi433/rf69.c
+++ b/drivers/staging/pi433/rf69.c
@@ -624,9 +624,7 @@ int rf69_set_preamble_length(struct spi_device *spi, u16 preamble_length)
 	retval = rf69_write_reg(spi, REG_PREAMBLE_MSB, msb);
 	if (retval)
 		return retval;
-	retval = rf69_write_reg(spi, REG_PREAMBLE_LSB, lsb);
-
-	return retval;
+	return rf69_write_reg(spi, REG_PREAMBLE_LSB, lsb);
 }
 
 int rf69_enable_sync(struct spi_device *spi)

commit 7e9463709c582d661cb1e703b40877f8334c5637
Author: Michael Straube <straube.linux@gmail.com>
Date:   Tue Nov 13 18:13:40 2018 +0100

    staging: pi433: remove GPL boiler plate text
    
    The SPDX identifier is a legally binding shorthand,
    which can be used instead of the full boiler plate text.
    
    All source and header files have SPDX identifiers.
    Remove the GPL boiler plate text to reduce file size.
    
    Signed-off-by: Michael Straube <straube.linux@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/pi433/rf69.c b/drivers/staging/pi433/rf69.c
index 4fa6c0237e59..e19b9ce794a8 100644
--- a/drivers/staging/pi433/rf69.c
+++ b/drivers/staging/pi433/rf69.c
@@ -4,16 +4,6 @@
  *
  * Copyright (C) 2016 Wolf-Entwicklungen
  *	Marcus Wolf <linux@wolf-entwicklungen.de>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
  */
 
 /* enable prosa debug info */

commit d947dddf1c95122f5a6e2de19b4483c7ba74aeca
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Mon Aug 27 12:24:10 2018 +0300

    staging: pi433: eliminate a temporary variable
    
    We can just get rid of the "spi_address".  It's not clear what the
    "address" part of the name means, and the type should have been a u8.
    
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/pi433/rf69.c b/drivers/staging/pi433/rf69.c
index 085272fb393f..4fa6c0237e59 100644
--- a/drivers/staging/pi433/rf69.c
+++ b/drivers/staging/pi433/rf69.c
@@ -853,7 +853,6 @@ int rf69_write_fifo(struct spi_device *spi, u8 *buffer, unsigned int size)
 #ifdef DEBUG_FIFO_ACCESS
 	int i;
 #endif
-	char spi_address = REG_FIFO | WRITE_BIT;
 	u8 local_buffer[FIFO_SIZE + 1];
 
 	if (size > FIFO_SIZE) {
@@ -862,7 +861,7 @@ int rf69_write_fifo(struct spi_device *spi, u8 *buffer, unsigned int size)
 		return -EMSGSIZE;
 	}
 
-	local_buffer[0] = spi_address;
+	local_buffer[0] = REG_FIFO | WRITE_BIT;
 	memcpy(&local_buffer[1], buffer, size);
 
 #ifdef DEBUG_FIFO_ACCESS

commit 75971225d8700ce968fe876a971d714913b845c7
Author: Sophie Matter <sophie.matter@web.de>
Date:   Wed Jul 11 11:45:53 2018 +0200

    staging: pi433: Make only one statement per line
    
    Lines containing multiple statements were broken into multiple
    lines, increasing readability and complying with the coding standard.
    This also fixes several checkpatch.pl errors complaining about
    the lines being too long.
    
    Signed-off-by: Sophie Matter <sophie.matter@web.de>
    Signed-off-by: Rico Schrage <rico.schrage@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/pi433/rf69.c b/drivers/staging/pi433/rf69.c
index 2dcda814fce0..085272fb393f 100644
--- a/drivers/staging/pi433/rf69.c
+++ b/drivers/staging/pi433/rf69.c
@@ -525,22 +525,34 @@ int rf69_set_dio_mapping(struct spi_device *spi, u8 dio_number, u8 value)
 
 	switch (dio_number) {
 	case 0:
-		mask = MASK_DIO0; shift = SHIFT_DIO0; dio_addr = REG_DIOMAPPING1;
+		mask = MASK_DIO0;
+		shift = SHIFT_DIO0;
+		dio_addr = REG_DIOMAPPING1;
 		break;
 	case 1:
-		mask = MASK_DIO1; shift = SHIFT_DIO1; dio_addr = REG_DIOMAPPING1;
+		mask = MASK_DIO1;
+		shift = SHIFT_DIO1;
+		dio_addr = REG_DIOMAPPING1;
 		break;
 	case 2:
-		mask = MASK_DIO2; shift = SHIFT_DIO2; dio_addr = REG_DIOMAPPING1;
+		mask = MASK_DIO2;
+		shift = SHIFT_DIO2;
+		dio_addr = REG_DIOMAPPING1;
 		break;
 	case 3:
-		mask = MASK_DIO3; shift = SHIFT_DIO3; dio_addr = REG_DIOMAPPING1;
+		mask = MASK_DIO3;
+		shift = SHIFT_DIO3;
+		dio_addr = REG_DIOMAPPING1;
 		break;
 	case 4:
-		mask = MASK_DIO4; shift = SHIFT_DIO4; dio_addr = REG_DIOMAPPING2;
+		mask = MASK_DIO4;
+		shift = SHIFT_DIO4;
+		dio_addr = REG_DIOMAPPING2;
 		break;
 	case 5:
-		mask = MASK_DIO5; shift = SHIFT_DIO5; dio_addr = REG_DIOMAPPING2;
+		mask = MASK_DIO5;
+		shift = SHIFT_DIO5;
+		dio_addr = REG_DIOMAPPING2;
 		break;
 	default:
 	dev_dbg(&spi->dev, "set: illegal input param");

commit 368928160477d7315a2b06cf640e34374aa36fcb
Author: Sophie Matter <sophie.matter@web.de>
Date:   Wed Jul 11 11:45:52 2018 +0200

    staging: pi433: Use preferred commenting style
    
    For multi-line comments, the preferred commenting style from the
    coding style Documentation was applied to the comments, meaning
    almost blank lines at the beginning and end of the comment.
    One changed comment includes a line over 80 characters, causing
    checkpatch.pl to complain, however breaking this line would not
    make much sense, so it is kept like it is.
    
    Signed-off-by: Sophie Matter <sophie.matter@web.de>
    Signed-off-by: Rico Schrage <rico.schrage@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/pi433/rf69.c b/drivers/staging/pi433/rf69.c
index 77e0a677ea96..2dcda814fce0 100644
--- a/drivers/staging/pi433/rf69.c
+++ b/drivers/staging/pi433/rf69.c
@@ -42,7 +42,8 @@ static u8 rf69_read_reg(struct spi_device *spi, u8 addr)
 
 #ifdef DEBUG_VALUES
 	if (retval < 0)
-		/* should never happen, since we already checked,
+		/*
+		 * should never happen, since we already checked,
 		 * that module is connected. Therefore no error
 		 * handling, just an optional error message...
 		 */
@@ -66,7 +67,8 @@ static int rf69_write_reg(struct spi_device *spi, u8 addr, u8 value)
 
 #ifdef DEBUG_VALUES
 	if (retval < 0)
-		/* should never happen, since we already checked,
+		/*
+		 * should never happen, since we already checked,
 		 * that module is connected. Therefore no error
 		 * handling, just an optional error message...
 		 */
@@ -576,8 +578,10 @@ bool rf69_get_flag(struct spi_device *spi, enum flag flag)
 		return (rf69_read_reg(spi, REG_IRQFLAGS1) & MASK_IRQFLAGS1_SYNC_ADDRESS_MATCH);
 	case fifo_full:
 		return (rf69_read_reg(spi, REG_IRQFLAGS2) & MASK_IRQFLAGS2_FIFO_FULL);
-/*	case fifo_not_empty:
- *		return (rf69_read_reg(spi, REG_IRQFLAGS2) & MASK_IRQFLAGS2_FIFO_NOT_EMPTY); */
+/*
+ *	case fifo_not_empty:
+ *		return (rf69_read_reg(spi, REG_IRQFLAGS2) & MASK_IRQFLAGS2_FIFO_NOT_EMPTY);
+ */
 	case fifo_empty:
 		return !(rf69_read_reg(spi, REG_IRQFLAGS2) & MASK_IRQFLAGS2_FIFO_NOT_EMPTY);
 	case fifo_level_below_threshold:
@@ -773,7 +777,8 @@ int rf69_set_fifo_threshold(struct spi_device *spi, u8 threshold)
 	if (retval)
 		return retval;
 
-	/* access the fifo to activate new threshold
+	/*
+	 * access the fifo to activate new threshold
 	 * retval (mis-) used as buffer here
 	 */
 	return rf69_read_fifo(spi, (u8 *)&retval, 1);

commit 63688e61d5629c3b931562315bd0373335269880
Author: Sophie Matter <sophie.matter@web.de>
Date:   Wed Jul 11 11:45:51 2018 +0200

    staging: pi433: Comply with 80 character column limit
    
    Lines have been split where it makes sense to shorten them in order
    to comply with the coding standards and fix checkpatch.pl warnings.
    There are still lines left that are too long, however breaking
    those would impair readability.
    
    Changes in v2:
     - now working on staging-next branch of the staging tree
     - the changes to the defines previously made are deleted
       due to readability
    
    Signed-off-by: Sophie Matter <sophie.matter@web.de>
    Signed-off-by: Rico Schrage <rico.schrage@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/pi433/rf69.c b/drivers/staging/pi433/rf69.c
index 724c24ce1428..77e0a677ea96 100644
--- a/drivers/staging/pi433/rf69.c
+++ b/drivers/staging/pi433/rf69.c
@@ -128,9 +128,13 @@ int rf69_set_mode(struct spi_device *spi, enum mode mode)
 	return rf69_read_mod_write(spi, REG_OPMODE, MASK_OPMODE_MODE,
 				   mode_map[mode]);
 
-	// we are using packet mode, so this check is not really needed
-	// but waiting for mode ready is necessary when going from sleep because the FIFO may not be immediately available from previous mode
-	//while (_mode == RF69_MODE_SLEEP && (READ_REG(REG_IRQFLAGS1) & RF_IRQFLAGS1_MODEREADY) == 0x00); // Wait for ModeReady
+	/*
+	 * we are using packet mode, so this check is not really needed
+	 * but waiting for mode ready is necessary when going from sleep
+	 * because the FIFO may not be immediately available from previous mode
+	 * while (_mode == RF69_MODE_SLEEP && (READ_REG(REG_IRQFLAGS1) &
+		  RF_IRQFLAGS1_MODEREADY) == 0x00); // Wait for ModeReady
+	 */
 }
 
 int rf69_set_data_mode(struct spi_device *spi, u8 data_mode)

commit ecfacacf3ff0feef2387b4c7440b256aa798065d
Author: Valentin Vidic <Valentin.Vidic@CARNet.hr>
Date:   Mon Jun 25 13:52:23 2018 +0200

    staging: pi433: add SPDX-License-Identifier tag
    
    Use GPL-2.0+ based on the license text in each of the files.
    
    Signed-off-by: Valentin Vidic <Valentin.Vidic@CARNet.hr>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/pi433/rf69.c b/drivers/staging/pi433/rf69.c
index 341d6901a801..724c24ce1428 100644
--- a/drivers/staging/pi433/rf69.c
+++ b/drivers/staging/pi433/rf69.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0+
 /*
  * abstraction of the spi interface of HopeRf rf69 radio module
  *

commit 8679339524c11497b7b7019fa7e24fe8e9a78a91
Author: Valentin Vidic <Valentin.Vidic@CARNet.hr>
Date:   Sun Jun 24 18:31:38 2018 +0200

    staging: pi433: replace simple switch statements
    
    Use const array to map switch cases to resulting values.
    
    Signed-off-by: Valentin Vidic <Valentin.Vidic@CARNet.hr>
    Reviewed-by: Marcus Wolf <Marcus.Wolf@Wolf-Entwicklungen.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/pi433/rf69.c b/drivers/staging/pi433/rf69.c
index 90280e9b006d..341d6901a801 100644
--- a/drivers/staging/pi433/rf69.c
+++ b/drivers/staging/pi433/rf69.c
@@ -111,27 +111,22 @@ static inline int rf69_read_mod_write(struct spi_device *spi, u8 reg,
 
 int rf69_set_mode(struct spi_device *spi, enum mode mode)
 {
-	switch (mode) {
-	case transmit:
-		return rf69_read_mod_write(spi, REG_OPMODE, MASK_OPMODE_MODE,
-					   OPMODE_MODE_TRANSMIT);
-	case receive:
-		return rf69_read_mod_write(spi, REG_OPMODE, MASK_OPMODE_MODE,
-					   OPMODE_MODE_RECEIVE);
-	case synthesizer:
-		return rf69_read_mod_write(spi, REG_OPMODE, MASK_OPMODE_MODE,
-					   OPMODE_MODE_SYNTHESIZER);
-	case standby:
-		return rf69_read_mod_write(spi, REG_OPMODE, MASK_OPMODE_MODE,
-					   OPMODE_MODE_STANDBY);
-	case mode_sleep:
-		return rf69_read_mod_write(spi, REG_OPMODE, MASK_OPMODE_MODE,
-					   OPMODE_MODE_SLEEP);
-	default:
+	static const u8 mode_map[] = {
+		[transmit] = OPMODE_MODE_TRANSMIT,
+		[receive] = OPMODE_MODE_RECEIVE,
+		[synthesizer] = OPMODE_MODE_SYNTHESIZER,
+		[standby] = OPMODE_MODE_STANDBY,
+		[mode_sleep] = OPMODE_MODE_SLEEP,
+	};
+
+	if (unlikely(mode >= ARRAY_SIZE(mode_map))) {
 		dev_dbg(&spi->dev, "set: illegal input param");
 		return -EINVAL;
 	}
 
+	return rf69_read_mod_write(spi, REG_OPMODE, MASK_OPMODE_MODE,
+				   mode_map[mode]);
+
 	// we are using packet mode, so this check is not really needed
 	// but waiting for mode ready is necessary when going from sleep because the FIFO may not be immediately available from previous mode
 	//while (_mode == RF69_MODE_SLEEP && (READ_REG(REG_IRQFLAGS1) & RF_IRQFLAGS1_MODEREADY) == 0x00); // Wait for ModeReady
@@ -145,19 +140,19 @@ int rf69_set_data_mode(struct spi_device *spi, u8 data_mode)
 
 int rf69_set_modulation(struct spi_device *spi, enum modulation modulation)
 {
-	switch (modulation) {
-	case OOK:
-		return rf69_read_mod_write(spi, REG_DATAMODUL,
-					   MASK_DATAMODUL_MODULATION_TYPE,
-					   DATAMODUL_MODULATION_TYPE_OOK);
-	case FSK:
-		return rf69_read_mod_write(spi, REG_DATAMODUL,
-					   MASK_DATAMODUL_MODULATION_TYPE,
-					   DATAMODUL_MODULATION_TYPE_FSK);
-	default:
+	static const u8 modulation_map[] = {
+		[OOK] = DATAMODUL_MODULATION_TYPE_OOK,
+		[FSK] = DATAMODUL_MODULATION_TYPE_FSK,
+	};
+
+	if (unlikely(modulation >= ARRAY_SIZE(modulation_map))) {
 		dev_dbg(&spi->dev, "set: illegal input param");
 		return -EINVAL;
 	}
+
+	return rf69_read_mod_write(spi, REG_DATAMODUL,
+				   MASK_DATAMODUL_MODULATION_TYPE,
+				   modulation_map[modulation]);
 }
 
 static enum modulation rf69_get_modulation(struct spi_device *spi)
@@ -373,43 +368,30 @@ int rf69_set_output_power_level(struct spi_device *spi, u8 power_level)
 
 int rf69_set_pa_ramp(struct spi_device *spi, enum pa_ramp pa_ramp)
 {
-	switch (pa_ramp) {
-	case ramp3400:
-		return rf69_write_reg(spi, REG_PARAMP, PARAMP_3400);
-	case ramp2000:
-		return rf69_write_reg(spi, REG_PARAMP, PARAMP_2000);
-	case ramp1000:
-		return rf69_write_reg(spi, REG_PARAMP, PARAMP_1000);
-	case ramp500:
-		return rf69_write_reg(spi, REG_PARAMP, PARAMP_500);
-	case ramp250:
-		return rf69_write_reg(spi, REG_PARAMP, PARAMP_250);
-	case ramp125:
-		return rf69_write_reg(spi, REG_PARAMP, PARAMP_125);
-	case ramp100:
-		return rf69_write_reg(spi, REG_PARAMP, PARAMP_100);
-	case ramp62:
-		return rf69_write_reg(spi, REG_PARAMP, PARAMP_62);
-	case ramp50:
-		return rf69_write_reg(spi, REG_PARAMP, PARAMP_50);
-	case ramp40:
-		return rf69_write_reg(spi, REG_PARAMP, PARAMP_40);
-	case ramp31:
-		return rf69_write_reg(spi, REG_PARAMP, PARAMP_31);
-	case ramp25:
-		return rf69_write_reg(spi, REG_PARAMP, PARAMP_25);
-	case ramp20:
-		return rf69_write_reg(spi, REG_PARAMP, PARAMP_20);
-	case ramp15:
-		return rf69_write_reg(spi, REG_PARAMP, PARAMP_15);
-	case ramp12:
-		return rf69_write_reg(spi, REG_PARAMP, PARAMP_12);
-	case ramp10:
-		return rf69_write_reg(spi, REG_PARAMP, PARAMP_10);
-	default:
+	static const u8 pa_ramp_map[] = {
+		[ramp3400] = PARAMP_3400,
+		[ramp2000] = PARAMP_2000,
+		[ramp1000] = PARAMP_1000,
+		[ramp500] = PARAMP_500,
+		[ramp250] = PARAMP_250,
+		[ramp125] = PARAMP_125,
+		[ramp100] = PARAMP_100,
+		[ramp62] = PARAMP_62,
+		[ramp50] = PARAMP_50,
+		[ramp40] = PARAMP_40,
+		[ramp31] = PARAMP_31,
+		[ramp25] = PARAMP_25,
+		[ramp20] = PARAMP_20,
+		[ramp15] = PARAMP_15,
+		[ramp10] = PARAMP_10,
+	};
+
+	if (unlikely(pa_ramp >= ARRAY_SIZE(pa_ramp_map))) {
 		dev_dbg(&spi->dev, "set: illegal input param");
 		return -EINVAL;
 	}
+
+	return rf69_write_reg(spi, REG_PARAMP, pa_ramp_map[pa_ramp]);
 }
 
 int rf69_set_antenna_impedance(struct spi_device *spi,
@@ -428,32 +410,23 @@ int rf69_set_antenna_impedance(struct spi_device *spi,
 
 int rf69_set_lna_gain(struct spi_device *spi, enum lna_gain lna_gain)
 {
-	switch (lna_gain) {
-	case automatic:
-		return rf69_read_mod_write(spi, REG_LNA, MASK_LNA_GAIN,
-					   LNA_GAIN_AUTO);
-	case max:
-		return rf69_read_mod_write(spi, REG_LNA, MASK_LNA_GAIN,
-					   LNA_GAIN_MAX);
-	case max_minus_6:
-		return rf69_read_mod_write(spi, REG_LNA, MASK_LNA_GAIN,
-					   LNA_GAIN_MAX_MINUS_6);
-	case max_minus_12:
-		return rf69_read_mod_write(spi, REG_LNA, MASK_LNA_GAIN,
-					   LNA_GAIN_MAX_MINUS_12);
-	case max_minus_24:
-		return rf69_read_mod_write(spi, REG_LNA, MASK_LNA_GAIN,
-					   LNA_GAIN_MAX_MINUS_24);
-	case max_minus_36:
-		return rf69_read_mod_write(spi, REG_LNA, MASK_LNA_GAIN,
-					   LNA_GAIN_MAX_MINUS_36);
-	case max_minus_48:
-		return rf69_read_mod_write(spi, REG_LNA, MASK_LNA_GAIN,
-					   LNA_GAIN_MAX_MINUS_48);
-	default:
+	static const u8 lna_gain_map[] = {
+		[automatic] = LNA_GAIN_AUTO,
+		[max] = LNA_GAIN_MAX,
+		[max_minus_6] = LNA_GAIN_MAX_MINUS_6,
+		[max_minus_12] = LNA_GAIN_MAX_MINUS_12,
+		[max_minus_24] = LNA_GAIN_MAX_MINUS_24,
+		[max_minus_36] = LNA_GAIN_MAX_MINUS_36,
+		[max_minus_48] = LNA_GAIN_MAX_MINUS_48,
+	};
+
+	if (unlikely(lna_gain >= ARRAY_SIZE(lna_gain_map))) {
 		dev_dbg(&spi->dev, "set: illegal input param");
 		return -EINVAL;
 	}
+
+	return rf69_read_mod_write(spi, REG_LNA, MASK_LNA_GAIN,
+				   lna_gain_map[lna_gain]);
 }
 
 static int rf69_set_bandwidth_intern(struct spi_device *spi, u8 reg,
@@ -516,43 +489,24 @@ int rf69_set_bandwidth_during_afc(struct spi_device *spi,
 int rf69_set_ook_threshold_dec(struct spi_device *spi,
 			       enum threshold_decrement threshold_decrement)
 {
-	switch (threshold_decrement) {
-	case dec_every8th:
-		return rf69_read_mod_write(spi, REG_OOKPEAK,
-					   MASK_OOKPEAK_THRESDEC,
-					   OOKPEAK_THRESHDEC_EVERY_8TH);
-	case dec_every4th:
-		return rf69_read_mod_write(spi, REG_OOKPEAK,
-					   MASK_OOKPEAK_THRESDEC,
-					   OOKPEAK_THRESHDEC_EVERY_4TH);
-	case dec_every2nd:
-		return rf69_read_mod_write(spi, REG_OOKPEAK,
-					   MASK_OOKPEAK_THRESDEC,
-					   OOKPEAK_THRESHDEC_EVERY_2ND);
-	case dec_once:
-		return rf69_read_mod_write(spi, REG_OOKPEAK,
-					   MASK_OOKPEAK_THRESDEC,
-					   OOKPEAK_THRESHDEC_ONCE);
-	case dec_twice:
-		return rf69_read_mod_write(spi, REG_OOKPEAK,
-					   MASK_OOKPEAK_THRESDEC,
-					   OOKPEAK_THRESHDEC_TWICE);
-	case dec_4times:
-		return rf69_read_mod_write(spi, REG_OOKPEAK,
-					   MASK_OOKPEAK_THRESDEC,
-					   OOKPEAK_THRESHDEC_4_TIMES);
-	case dec_8times:
-		return rf69_read_mod_write(spi, REG_OOKPEAK,
-					   MASK_OOKPEAK_THRESDEC,
-					   OOKPEAK_THRESHDEC_8_TIMES);
-	case dec_16times:
-		return rf69_read_mod_write(spi, REG_OOKPEAK,
-					   MASK_OOKPEAK_THRESDEC,
-					   OOKPEAK_THRESHDEC_16_TIMES);
-	default:
+	static const u8 td_map[] = {
+		[dec_every8th] = OOKPEAK_THRESHDEC_EVERY_8TH,
+		[dec_every4th] = OOKPEAK_THRESHDEC_EVERY_4TH,
+		[dec_every2nd] = OOKPEAK_THRESHDEC_EVERY_2ND,
+		[dec_once] = OOKPEAK_THRESHDEC_ONCE,
+		[dec_twice] = OOKPEAK_THRESHDEC_TWICE,
+		[dec_4times] = OOKPEAK_THRESHDEC_4_TIMES,
+		[dec_8times] = OOKPEAK_THRESHDEC_8_TIMES,
+		[dec_16times] = OOKPEAK_THRESHDEC_16_TIMES,
+	};
+
+	if (unlikely(threshold_decrement >= ARRAY_SIZE(td_map))) {
 		dev_dbg(&spi->dev, "set: illegal input param");
 		return -EINVAL;
 	}
+
+	return rf69_read_mod_write(spi, REG_OOKPEAK, MASK_OOKPEAK_THRESDEC,
+				   td_map[threshold_decrement]);
 }
 
 int rf69_set_dio_mapping(struct spi_device *spi, u8 dio_number, u8 value)
@@ -749,23 +703,21 @@ int rf69_disable_crc(struct spi_device *spi)
 int rf69_set_address_filtering(struct spi_device *spi,
 			       enum address_filtering address_filtering)
 {
-	switch (address_filtering) {
-	case filtering_off:
-		return rf69_read_mod_write(spi, REG_PACKETCONFIG1,
-					   MASK_PACKETCONFIG1_ADDRESSFILTERING,
-					   PACKETCONFIG1_ADDRESSFILTERING_OFF);
-	case node_address:
-		return rf69_read_mod_write(spi, REG_PACKETCONFIG1,
-					   MASK_PACKETCONFIG1_ADDRESSFILTERING,
-					   PACKETCONFIG1_ADDRESSFILTERING_NODE);
-	case node_or_broadcast_address:
-		return rf69_read_mod_write(spi, REG_PACKETCONFIG1,
-					   MASK_PACKETCONFIG1_ADDRESSFILTERING,
-					   PACKETCONFIG1_ADDRESSFILTERING_NODEBROADCAST);
-	default:
+	static const u8 af_map[] = {
+		[filtering_off] = PACKETCONFIG1_ADDRESSFILTERING_OFF,
+		[node_address] = PACKETCONFIG1_ADDRESSFILTERING_NODE,
+		[node_or_broadcast_address] =
+			PACKETCONFIG1_ADDRESSFILTERING_NODEBROADCAST,
+	};
+
+	if (unlikely(address_filtering >= ARRAY_SIZE(af_map))) {
 		dev_dbg(&spi->dev, "set: illegal input param");
 		return -EINVAL;
 	}
+
+	return rf69_read_mod_write(spi, REG_PACKETCONFIG1,
+				   MASK_PACKETCONFIG1_ADDRESSFILTERING,
+				   af_map[address_filtering]);
 }
 
 int rf69_set_payload_length(struct spi_device *spi, u8 payload_length)
@@ -824,17 +776,18 @@ int rf69_set_fifo_threshold(struct spi_device *spi, u8 threshold)
 
 int rf69_set_dagc(struct spi_device *spi, enum dagc dagc)
 {
-	switch (dagc) {
-	case normal_mode:
-		return rf69_write_reg(spi, REG_TESTDAGC, DAGC_NORMAL);
-	case improve:
-		return rf69_write_reg(spi, REG_TESTDAGC, DAGC_IMPROVED_LOWBETA0);
-	case improve_for_low_modulation_index:
-		return rf69_write_reg(spi, REG_TESTDAGC, DAGC_IMPROVED_LOWBETA1);
-	default:
+	static const u8 dagc_map[] = {
+		[normal_mode] = DAGC_NORMAL,
+		[improve] = DAGC_IMPROVED_LOWBETA0,
+		[improve_for_low_modulation_index] = DAGC_IMPROVED_LOWBETA1,
+	};
+
+	if (unlikely(dagc >= ARRAY_SIZE(dagc_map))) {
 		dev_dbg(&spi->dev, "set: illegal input param");
 		return -EINVAL;
 	}
+
+	return rf69_write_reg(spi, REG_TESTDAGC, dagc_map[dagc]);
 }
 
 /*-------------------------------------------------------------------------*/

commit d7b09e652125a654acc89279c688f066b85437a5
Author: Simon Sandström <simon@nikanor.nu>
Date:   Fri Apr 6 23:05:15 2018 +0200

    staging: pi433: break long lines in rf69.c
    
    Breaks long lines in rf69.c, fixing checkpatch.pl warnings:
    "WARNING: line over 80 characters"
    
    Signed-off-by: Simon Sandström <simon@nikanor.nu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/pi433/rf69.c b/drivers/staging/pi433/rf69.c
index 5b0554823263..90280e9b006d 100644
--- a/drivers/staging/pi433/rf69.c
+++ b/drivers/staging/pi433/rf69.c
@@ -97,7 +97,8 @@ static int rf69_clear_bit(struct spi_device *spi, u8 reg, u8 mask)
 	return rf69_write_reg(spi, reg, tmp);
 }
 
-static inline int rf69_read_mod_write(struct spi_device *spi, u8 reg, u8 mask, u8 value)
+static inline int rf69_read_mod_write(struct spi_device *spi, u8 reg,
+				      u8 mask, u8 value)
 {
 	u8 tmp;
 
@@ -112,15 +113,20 @@ int rf69_set_mode(struct spi_device *spi, enum mode mode)
 {
 	switch (mode) {
 	case transmit:
-		return rf69_read_mod_write(spi, REG_OPMODE, MASK_OPMODE_MODE, OPMODE_MODE_TRANSMIT);
+		return rf69_read_mod_write(spi, REG_OPMODE, MASK_OPMODE_MODE,
+					   OPMODE_MODE_TRANSMIT);
 	case receive:
-		return rf69_read_mod_write(spi, REG_OPMODE, MASK_OPMODE_MODE, OPMODE_MODE_RECEIVE);
+		return rf69_read_mod_write(spi, REG_OPMODE, MASK_OPMODE_MODE,
+					   OPMODE_MODE_RECEIVE);
 	case synthesizer:
-		return rf69_read_mod_write(spi, REG_OPMODE, MASK_OPMODE_MODE, OPMODE_MODE_SYNTHESIZER);
+		return rf69_read_mod_write(spi, REG_OPMODE, MASK_OPMODE_MODE,
+					   OPMODE_MODE_SYNTHESIZER);
 	case standby:
-		return rf69_read_mod_write(spi, REG_OPMODE, MASK_OPMODE_MODE, OPMODE_MODE_STANDBY);
+		return rf69_read_mod_write(spi, REG_OPMODE, MASK_OPMODE_MODE,
+					   OPMODE_MODE_STANDBY);
 	case mode_sleep:
-		return rf69_read_mod_write(spi, REG_OPMODE, MASK_OPMODE_MODE, OPMODE_MODE_SLEEP);
+		return rf69_read_mod_write(spi, REG_OPMODE, MASK_OPMODE_MODE,
+					   OPMODE_MODE_SLEEP);
 	default:
 		dev_dbg(&spi->dev, "set: illegal input param");
 		return -EINVAL;
@@ -133,16 +139,21 @@ int rf69_set_mode(struct spi_device *spi, enum mode mode)
 
 int rf69_set_data_mode(struct spi_device *spi, u8 data_mode)
 {
-	return rf69_read_mod_write(spi, REG_DATAMODUL, MASK_DATAMODUL_MODE, data_mode);
+	return rf69_read_mod_write(spi, REG_DATAMODUL, MASK_DATAMODUL_MODE,
+				   data_mode);
 }
 
 int rf69_set_modulation(struct spi_device *spi, enum modulation modulation)
 {
 	switch (modulation) {
 	case OOK:
-		return rf69_read_mod_write(spi, REG_DATAMODUL, MASK_DATAMODUL_MODULATION_TYPE, DATAMODUL_MODULATION_TYPE_OOK);
+		return rf69_read_mod_write(spi, REG_DATAMODUL,
+					   MASK_DATAMODUL_MODULATION_TYPE,
+					   DATAMODUL_MODULATION_TYPE_OOK);
 	case FSK:
-		return rf69_read_mod_write(spi, REG_DATAMODUL, MASK_DATAMODUL_MODULATION_TYPE, DATAMODUL_MODULATION_TYPE_FSK);
+		return rf69_read_mod_write(spi, REG_DATAMODUL,
+					   MASK_DATAMODUL_MODULATION_TYPE,
+					   DATAMODUL_MODULATION_TYPE_FSK);
 	default:
 		dev_dbg(&spi->dev, "set: illegal input param");
 		return -EINVAL;
@@ -172,13 +183,21 @@ int rf69_set_modulation_shaping(struct spi_device *spi,
 	case FSK:
 		switch (mod_shaping) {
 		case SHAPING_OFF:
-			return rf69_read_mod_write(spi, REG_DATAMODUL, MASK_DATAMODUL_MODULATION_SHAPE, DATAMODUL_MODULATION_SHAPE_NONE);
+			return rf69_read_mod_write(spi, REG_DATAMODUL,
+						   MASK_DATAMODUL_MODULATION_SHAPE,
+						   DATAMODUL_MODULATION_SHAPE_NONE);
 		case SHAPING_1_0:
-			return rf69_read_mod_write(spi, REG_DATAMODUL, MASK_DATAMODUL_MODULATION_SHAPE, DATAMODUL_MODULATION_SHAPE_1_0);
+			return rf69_read_mod_write(spi, REG_DATAMODUL,
+						   MASK_DATAMODUL_MODULATION_SHAPE,
+						   DATAMODUL_MODULATION_SHAPE_1_0);
 		case SHAPING_0_5:
-			return rf69_read_mod_write(spi, REG_DATAMODUL, MASK_DATAMODUL_MODULATION_SHAPE, DATAMODUL_MODULATION_SHAPE_0_5);
+			return rf69_read_mod_write(spi, REG_DATAMODUL,
+						   MASK_DATAMODUL_MODULATION_SHAPE,
+						   DATAMODUL_MODULATION_SHAPE_0_5);
 		case SHAPING_0_3:
-			return rf69_read_mod_write(spi, REG_DATAMODUL, MASK_DATAMODUL_MODULATION_SHAPE, DATAMODUL_MODULATION_SHAPE_0_3);
+			return rf69_read_mod_write(spi, REG_DATAMODUL,
+						   MASK_DATAMODUL_MODULATION_SHAPE,
+						   DATAMODUL_MODULATION_SHAPE_0_3);
 		default:
 			dev_dbg(&spi->dev, "set: illegal input param");
 			return -EINVAL;
@@ -186,11 +205,17 @@ int rf69_set_modulation_shaping(struct spi_device *spi,
 	case OOK:
 		switch (mod_shaping) {
 		case SHAPING_OFF:
-			return rf69_read_mod_write(spi, REG_DATAMODUL, MASK_DATAMODUL_MODULATION_SHAPE, DATAMODUL_MODULATION_SHAPE_NONE);
+			return rf69_read_mod_write(spi, REG_DATAMODUL,
+						   MASK_DATAMODUL_MODULATION_SHAPE,
+						   DATAMODUL_MODULATION_SHAPE_NONE);
 		case SHAPING_BR:
-			return rf69_read_mod_write(spi, REG_DATAMODUL, MASK_DATAMODUL_MODULATION_SHAPE, DATAMODUL_MODULATION_SHAPE_BR);
+			return rf69_read_mod_write(spi, REG_DATAMODUL,
+						   MASK_DATAMODUL_MODULATION_SHAPE,
+						   DATAMODUL_MODULATION_SHAPE_BR);
 		case SHAPING_2BR:
-			return rf69_read_mod_write(spi, REG_DATAMODUL, MASK_DATAMODUL_MODULATION_SHAPE, DATAMODUL_MODULATION_SHAPE_2BR);
+			return rf69_read_mod_write(spi, REG_DATAMODUL,
+						   MASK_DATAMODUL_MODULATION_SHAPE,
+						   DATAMODUL_MODULATION_SHAPE_2BR);
 		default:
 			dev_dbg(&spi->dev, "set: illegal input param");
 			return -EINVAL;
@@ -342,7 +367,8 @@ int rf69_set_output_power_level(struct spi_device *spi, u8 power_level)
 	}
 
 	// write value
-	return rf69_read_mod_write(spi, REG_PALEVEL, MASK_PALEVEL_OUTPUT_POWER, power_level);
+	return rf69_read_mod_write(spi, REG_PALEVEL, MASK_PALEVEL_OUTPUT_POWER,
+				   power_level);
 }
 
 int rf69_set_pa_ramp(struct spi_device *spi, enum pa_ramp pa_ramp)
@@ -386,7 +412,8 @@ int rf69_set_pa_ramp(struct spi_device *spi, enum pa_ramp pa_ramp)
 	}
 }
 
-int rf69_set_antenna_impedance(struct spi_device *spi, enum antenna_impedance antenna_impedance)
+int rf69_set_antenna_impedance(struct spi_device *spi,
+			       enum antenna_impedance antenna_impedance)
 {
 	switch (antenna_impedance) {
 	case fifty_ohm:
@@ -403,19 +430,26 @@ int rf69_set_lna_gain(struct spi_device *spi, enum lna_gain lna_gain)
 {
 	switch (lna_gain) {
 	case automatic:
-		return rf69_read_mod_write(spi, REG_LNA, MASK_LNA_GAIN, LNA_GAIN_AUTO);
+		return rf69_read_mod_write(spi, REG_LNA, MASK_LNA_GAIN,
+					   LNA_GAIN_AUTO);
 	case max:
-		return rf69_read_mod_write(spi, REG_LNA, MASK_LNA_GAIN, LNA_GAIN_MAX);
+		return rf69_read_mod_write(spi, REG_LNA, MASK_LNA_GAIN,
+					   LNA_GAIN_MAX);
 	case max_minus_6:
-		return rf69_read_mod_write(spi, REG_LNA, MASK_LNA_GAIN, LNA_GAIN_MAX_MINUS_6);
+		return rf69_read_mod_write(spi, REG_LNA, MASK_LNA_GAIN,
+					   LNA_GAIN_MAX_MINUS_6);
 	case max_minus_12:
-		return rf69_read_mod_write(spi, REG_LNA, MASK_LNA_GAIN, LNA_GAIN_MAX_MINUS_12);
+		return rf69_read_mod_write(spi, REG_LNA, MASK_LNA_GAIN,
+					   LNA_GAIN_MAX_MINUS_12);
 	case max_minus_24:
-		return rf69_read_mod_write(spi, REG_LNA, MASK_LNA_GAIN, LNA_GAIN_MAX_MINUS_24);
+		return rf69_read_mod_write(spi, REG_LNA, MASK_LNA_GAIN,
+					   LNA_GAIN_MAX_MINUS_24);
 	case max_minus_36:
-		return rf69_read_mod_write(spi, REG_LNA, MASK_LNA_GAIN, LNA_GAIN_MAX_MINUS_36);
+		return rf69_read_mod_write(spi, REG_LNA, MASK_LNA_GAIN,
+					   LNA_GAIN_MAX_MINUS_36);
 	case max_minus_48:
-		return rf69_read_mod_write(spi, REG_LNA, MASK_LNA_GAIN, LNA_GAIN_MAX_MINUS_48);
+		return rf69_read_mod_write(spi, REG_LNA, MASK_LNA_GAIN,
+					   LNA_GAIN_MAX_MINUS_48);
 	default:
 		dev_dbg(&spi->dev, "set: illegal input param");
 		return -EINVAL;
@@ -466,35 +500,55 @@ static int rf69_set_bandwidth_intern(struct spi_device *spi, u8 reg,
 	return rf69_write_reg(spi, reg, bandwidth);
 }
 
-int rf69_set_bandwidth(struct spi_device *spi, enum mantisse mantisse, u8 exponent)
+int rf69_set_bandwidth(struct spi_device *spi, enum mantisse mantisse,
+		       u8 exponent)
 {
 	return rf69_set_bandwidth_intern(spi, REG_RXBW, mantisse, exponent);
 }
 
-int rf69_set_bandwidth_during_afc(struct spi_device *spi, enum mantisse mantisse, u8 exponent)
+int rf69_set_bandwidth_during_afc(struct spi_device *spi,
+				  enum mantisse mantisse,
+				  u8 exponent)
 {
 	return rf69_set_bandwidth_intern(spi, REG_AFCBW, mantisse, exponent);
 }
 
-int rf69_set_ook_threshold_dec(struct spi_device *spi, enum threshold_decrement threshold_decrement)
+int rf69_set_ook_threshold_dec(struct spi_device *spi,
+			       enum threshold_decrement threshold_decrement)
 {
 	switch (threshold_decrement) {
 	case dec_every8th:
-		return rf69_read_mod_write(spi, REG_OOKPEAK, MASK_OOKPEAK_THRESDEC, OOKPEAK_THRESHDEC_EVERY_8TH);
+		return rf69_read_mod_write(spi, REG_OOKPEAK,
+					   MASK_OOKPEAK_THRESDEC,
+					   OOKPEAK_THRESHDEC_EVERY_8TH);
 	case dec_every4th:
-		return rf69_read_mod_write(spi, REG_OOKPEAK, MASK_OOKPEAK_THRESDEC, OOKPEAK_THRESHDEC_EVERY_4TH);
+		return rf69_read_mod_write(spi, REG_OOKPEAK,
+					   MASK_OOKPEAK_THRESDEC,
+					   OOKPEAK_THRESHDEC_EVERY_4TH);
 	case dec_every2nd:
-		return rf69_read_mod_write(spi, REG_OOKPEAK, MASK_OOKPEAK_THRESDEC, OOKPEAK_THRESHDEC_EVERY_2ND);
+		return rf69_read_mod_write(spi, REG_OOKPEAK,
+					   MASK_OOKPEAK_THRESDEC,
+					   OOKPEAK_THRESHDEC_EVERY_2ND);
 	case dec_once:
-		return rf69_read_mod_write(spi, REG_OOKPEAK, MASK_OOKPEAK_THRESDEC, OOKPEAK_THRESHDEC_ONCE);
+		return rf69_read_mod_write(spi, REG_OOKPEAK,
+					   MASK_OOKPEAK_THRESDEC,
+					   OOKPEAK_THRESHDEC_ONCE);
 	case dec_twice:
-		return rf69_read_mod_write(spi, REG_OOKPEAK, MASK_OOKPEAK_THRESDEC, OOKPEAK_THRESHDEC_TWICE);
+		return rf69_read_mod_write(spi, REG_OOKPEAK,
+					   MASK_OOKPEAK_THRESDEC,
+					   OOKPEAK_THRESHDEC_TWICE);
 	case dec_4times:
-		return rf69_read_mod_write(spi, REG_OOKPEAK, MASK_OOKPEAK_THRESDEC, OOKPEAK_THRESHDEC_4_TIMES);
+		return rf69_read_mod_write(spi, REG_OOKPEAK,
+					   MASK_OOKPEAK_THRESDEC,
+					   OOKPEAK_THRESHDEC_4_TIMES);
 	case dec_8times:
-		return rf69_read_mod_write(spi, REG_OOKPEAK, MASK_OOKPEAK_THRESDEC, OOKPEAK_THRESHDEC_8_TIMES);
+		return rf69_read_mod_write(spi, REG_OOKPEAK,
+					   MASK_OOKPEAK_THRESDEC,
+					   OOKPEAK_THRESHDEC_8_TIMES);
 	case dec_16times:
-		return rf69_read_mod_write(spi, REG_OOKPEAK, MASK_OOKPEAK_THRESDEC, OOKPEAK_THRESHDEC_16_TIMES);
+		return rf69_read_mod_write(spi, REG_OOKPEAK,
+					   MASK_OOKPEAK_THRESDEC,
+					   OOKPEAK_THRESHDEC_16_TIMES);
 	default:
 		dev_dbg(&spi->dev, "set: illegal input param");
 		return -EINVAL;
@@ -620,13 +674,16 @@ int rf69_disable_sync(struct spi_device *spi)
 	return rf69_clear_bit(spi, REG_SYNC_CONFIG, MASK_SYNC_CONFIG_SYNC_ON);
 }
 
-int rf69_set_fifo_fill_condition(struct spi_device *spi, enum fifo_fill_condition fifo_fill_condition)
+int rf69_set_fifo_fill_condition(struct spi_device *spi,
+				 enum fifo_fill_condition fifo_fill_condition)
 {
 	switch (fifo_fill_condition) {
 	case always:
-		return rf69_set_bit(spi, REG_SYNC_CONFIG, MASK_SYNC_CONFIG_FIFO_FILL_CONDITION);
+		return rf69_set_bit(spi, REG_SYNC_CONFIG,
+				    MASK_SYNC_CONFIG_FIFO_FILL_CONDITION);
 	case after_sync_interrupt:
-		return rf69_clear_bit(spi, REG_SYNC_CONFIG, MASK_SYNC_CONFIG_FIFO_FILL_CONDITION);
+		return rf69_clear_bit(spi, REG_SYNC_CONFIG,
+				      MASK_SYNC_CONFIG_FIFO_FILL_CONDITION);
 	default:
 		dev_dbg(&spi->dev, "set: illegal input param");
 		return -EINVAL;
@@ -642,7 +699,9 @@ int rf69_set_sync_size(struct spi_device *spi, u8 sync_size)
 	}
 
 	// write value
-	return rf69_read_mod_write(spi, REG_SYNC_CONFIG, MASK_SYNC_CONFIG_SYNC_SIZE, (sync_size << 3));
+	return rf69_read_mod_write(spi, REG_SYNC_CONFIG,
+				   MASK_SYNC_CONFIG_SYNC_SIZE,
+				   (sync_size << 3));
 }
 
 int rf69_set_sync_values(struct spi_device *spi, u8 sync_values[8])
@@ -661,13 +720,16 @@ int rf69_set_sync_values(struct spi_device *spi, u8 sync_values[8])
 	return retval;
 }
 
-int rf69_set_packet_format(struct spi_device *spi, enum packet_format packet_format)
+int rf69_set_packet_format(struct spi_device *spi,
+			   enum packet_format packet_format)
 {
 	switch (packet_format) {
 	case packet_length_var:
-		return rf69_set_bit(spi, REG_PACKETCONFIG1, MASK_PACKETCONFIG1_PAKET_FORMAT_VARIABLE);
+		return rf69_set_bit(spi, REG_PACKETCONFIG1,
+				    MASK_PACKETCONFIG1_PAKET_FORMAT_VARIABLE);
 	case packet_length_fix:
-		return rf69_clear_bit(spi, REG_PACKETCONFIG1, MASK_PACKETCONFIG1_PAKET_FORMAT_VARIABLE);
+		return rf69_clear_bit(spi, REG_PACKETCONFIG1,
+				      MASK_PACKETCONFIG1_PAKET_FORMAT_VARIABLE);
 	default:
 		dev_dbg(&spi->dev, "set: illegal input param");
 		return -EINVAL;
@@ -684,15 +746,22 @@ int rf69_disable_crc(struct spi_device *spi)
 	return rf69_clear_bit(spi, REG_PACKETCONFIG1, MASK_PACKETCONFIG1_CRC_ON);
 }
 
-int rf69_set_address_filtering(struct spi_device *spi, enum address_filtering address_filtering)
+int rf69_set_address_filtering(struct spi_device *spi,
+			       enum address_filtering address_filtering)
 {
 	switch (address_filtering) {
 	case filtering_off:
-		return rf69_read_mod_write(spi, REG_PACKETCONFIG1, MASK_PACKETCONFIG1_ADDRESSFILTERING, PACKETCONFIG1_ADDRESSFILTERING_OFF);
+		return rf69_read_mod_write(spi, REG_PACKETCONFIG1,
+					   MASK_PACKETCONFIG1_ADDRESSFILTERING,
+					   PACKETCONFIG1_ADDRESSFILTERING_OFF);
 	case node_address:
-		return rf69_read_mod_write(spi, REG_PACKETCONFIG1, MASK_PACKETCONFIG1_ADDRESSFILTERING, PACKETCONFIG1_ADDRESSFILTERING_NODE);
+		return rf69_read_mod_write(spi, REG_PACKETCONFIG1,
+					   MASK_PACKETCONFIG1_ADDRESSFILTERING,
+					   PACKETCONFIG1_ADDRESSFILTERING_NODE);
 	case node_or_broadcast_address:
-		return rf69_read_mod_write(spi, REG_PACKETCONFIG1, MASK_PACKETCONFIG1_ADDRESSFILTERING, PACKETCONFIG1_ADDRESSFILTERING_NODEBROADCAST);
+		return rf69_read_mod_write(spi, REG_PACKETCONFIG1,
+					   MASK_PACKETCONFIG1_ADDRESSFILTERING,
+					   PACKETCONFIG1_ADDRESSFILTERING_NODEBROADCAST);
 	default:
 		dev_dbg(&spi->dev, "set: illegal input param");
 		return -EINVAL;
@@ -714,13 +783,16 @@ int rf69_set_broadcast_address(struct spi_device *spi, u8 broadcast_address)
 	return rf69_write_reg(spi, REG_BROADCASTADRS, broadcast_address);
 }
 
-int rf69_set_tx_start_condition(struct spi_device *spi, enum tx_start_condition tx_start_condition)
+int rf69_set_tx_start_condition(struct spi_device *spi,
+				enum tx_start_condition tx_start_condition)
 {
 	switch (tx_start_condition) {
 	case fifo_level:
-		return rf69_clear_bit(spi, REG_FIFO_THRESH, MASK_FIFO_THRESH_TXSTART);
+		return rf69_clear_bit(spi, REG_FIFO_THRESH,
+				      MASK_FIFO_THRESH_TXSTART);
 	case fifo_not_empty:
-		return rf69_set_bit(spi, REG_FIFO_THRESH, MASK_FIFO_THRESH_TXSTART);
+		return rf69_set_bit(spi, REG_FIFO_THRESH,
+				    MASK_FIFO_THRESH_TXSTART);
 	default:
 		dev_dbg(&spi->dev, "set: illegal input param");
 		return -EINVAL;
@@ -738,7 +810,9 @@ int rf69_set_fifo_threshold(struct spi_device *spi, u8 threshold)
 	}
 
 	/* write value */
-	retval = rf69_read_mod_write(spi, REG_FIFO_THRESH, MASK_FIFO_THRESH_VALUE, threshold);
+	retval = rf69_read_mod_write(spi, REG_FIFO_THRESH,
+				     MASK_FIFO_THRESH_VALUE,
+				     threshold);
 	if (retval)
 		return retval;
 
@@ -775,7 +849,8 @@ int rf69_read_fifo(struct spi_device *spi, u8 *buffer, unsigned int size)
 	int retval;
 
 	if (size > FIFO_SIZE) {
-		dev_dbg(&spi->dev, "read fifo: passed in buffer bigger then internal buffer\n");
+		dev_dbg(&spi->dev,
+			"read fifo: passed in buffer bigger then internal buffer\n");
 		return -EMSGSIZE;
 	}
 
@@ -807,7 +882,8 @@ int rf69_write_fifo(struct spi_device *spi, u8 *buffer, unsigned int size)
 	u8 local_buffer[FIFO_SIZE + 1];
 
 	if (size > FIFO_SIZE) {
-		dev_dbg(&spi->dev, "read fifo: passed in buffer bigger then internal buffer\n");
+		dev_dbg(&spi->dev,
+			"read fifo: passed in buffer bigger then internal buffer\n");
 		return -EMSGSIZE;
 	}
 

commit bcb4f0d75bde920a3e86eeea743c6002863455fb
Author: Valentin Vidic <Valentin.Vidic@CARNet.hr>
Date:   Wed Mar 14 21:44:07 2018 +0100

    staging: pi433: fix CamelCase for dagc enum
    
    Fixes checkpatch warnings:
    
      CHECK: Avoid CamelCase: <normalMode>
      CHECK: Avoid CamelCase: <improve4LowModulationIndex>
    
    Signed-off-by: Valentin Vidic <Valentin.Vidic@CARNet.hr>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/pi433/rf69.c b/drivers/staging/pi433/rf69.c
index 0bc459e32f6b..5b0554823263 100644
--- a/drivers/staging/pi433/rf69.c
+++ b/drivers/staging/pi433/rf69.c
@@ -751,11 +751,11 @@ int rf69_set_fifo_threshold(struct spi_device *spi, u8 threshold)
 int rf69_set_dagc(struct spi_device *spi, enum dagc dagc)
 {
 	switch (dagc) {
-	case normalMode:
+	case normal_mode:
 		return rf69_write_reg(spi, REG_TESTDAGC, DAGC_NORMAL);
 	case improve:
 		return rf69_write_reg(spi, REG_TESTDAGC, DAGC_IMPROVED_LOWBETA0);
-	case improve4LowModulationIndex:
+	case improve_for_low_modulation_index:
 		return rf69_write_reg(spi, REG_TESTDAGC, DAGC_IMPROVED_LOWBETA1);
 	default:
 		dev_dbg(&spi->dev, "set: illegal input param");

commit e4928ac29b3d1ef70bd069cf768d86ca22d88abf
Author: Valentin Vidic <Valentin.Vidic@CARNet.hr>
Date:   Wed Mar 14 21:44:06 2018 +0100

    staging: pi433: fix CamelCase for lnaGain enum
    
    Fixes checkpatch warning:
    
      CHECK: Avoid CamelCase: <lnaGain>
    
    Signed-off-by: Valentin Vidic <Valentin.Vidic@CARNet.hr>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/pi433/rf69.c b/drivers/staging/pi433/rf69.c
index e3394094f6a1..0bc459e32f6b 100644
--- a/drivers/staging/pi433/rf69.c
+++ b/drivers/staging/pi433/rf69.c
@@ -399,9 +399,9 @@ int rf69_set_antenna_impedance(struct spi_device *spi, enum antenna_impedance an
 	}
 }
 
-int rf69_set_lna_gain(struct spi_device *spi, enum lnaGain lnaGain)
+int rf69_set_lna_gain(struct spi_device *spi, enum lna_gain lna_gain)
 {
-	switch (lnaGain) {
+	switch (lna_gain) {
 	case automatic:
 		return rf69_read_mod_write(spi, REG_LNA, MASK_LNA_GAIN, LNA_GAIN_AUTO);
 	case max:

commit 9d985d127abf93d80fd038d33248ca999ac686d5
Author: Valentin Vidic <Valentin.Vidic@CARNet.hr>
Date:   Wed Mar 14 21:44:05 2018 +0100

    staging: pi433: fix CamelCase for DIONumber variable
    
    Fixes checkpatch warning:
    
      CHECK: Avoid CamelCase: <DIONumber>
    
    Signed-off-by: Valentin Vidic <Valentin.Vidic@CARNet.hr>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/pi433/rf69.c b/drivers/staging/pi433/rf69.c
index e11c9cca447b..e3394094f6a1 100644
--- a/drivers/staging/pi433/rf69.c
+++ b/drivers/staging/pi433/rf69.c
@@ -501,14 +501,14 @@ int rf69_set_ook_threshold_dec(struct spi_device *spi, enum threshold_decrement
 	}
 }
 
-int rf69_set_dio_mapping(struct spi_device *spi, u8 DIONumber, u8 value)
+int rf69_set_dio_mapping(struct spi_device *spi, u8 dio_number, u8 value)
 {
 	u8 mask;
 	u8 shift;
 	u8 dio_addr;
 	u8 dio_value;
 
-	switch (DIONumber) {
+	switch (dio_number) {
 	case 0:
 		mask = MASK_DIO0; shift = SHIFT_DIO0; dio_addr = REG_DIOMAPPING1;
 		break;

commit 31e045ab546fa63ad4d7d3a9ccae5922b3f88612
Author: Valentin Vidic <Valentin.Vidic@CARNet.hr>
Date:   Wed Mar 14 21:44:04 2018 +0100

    staging: pi433: fix CamelCase for bitRate variables
    
    Fixes checkpatch warnings:
    
      CHECK: Avoid CamelCase: <bitRate>
      CHECK: Avoid CamelCase: <bitRate_min>
      CHECK: Avoid CamelCase: <bitRate_reg>
    
    Signed-off-by: Valentin Vidic <Valentin.Vidic@CARNet.hr>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/pi433/rf69.c b/drivers/staging/pi433/rf69.c
index b57d3f4e9321..e11c9cca447b 100644
--- a/drivers/staging/pi433/rf69.c
+++ b/drivers/staging/pi433/rf69.c
@@ -201,26 +201,26 @@ int rf69_set_modulation_shaping(struct spi_device *spi,
 	}
 }
 
-int rf69_set_bit_rate(struct spi_device *spi, u16 bitRate)
+int rf69_set_bit_rate(struct spi_device *spi, u16 bit_rate)
 {
 	int retval;
-	u32 bitRate_min;
-	u32 bitRate_reg;
+	u32 bit_rate_min;
+	u32 bit_rate_reg;
 	u8 msb;
 	u8 lsb;
 
 	// check input value
-	bitRate_min = F_OSC / 8388608; // 8388608 = 2^23;
-	if (bitRate < bitRate_min) {
+	bit_rate_min = F_OSC / 8388608; // 8388608 = 2^23;
+	if (bit_rate < bit_rate_min) {
 		dev_dbg(&spi->dev, "setBitRate: illegal input param");
 		return -EINVAL;
 	}
 
 	// calculate reg settings
-	bitRate_reg = (F_OSC / bitRate);
+	bit_rate_reg = (F_OSC / bit_rate);
 
-	msb = (bitRate_reg & 0xff00) >> 8;
-	lsb = (bitRate_reg & 0xff);
+	msb = (bit_rate_reg & 0xff00) >> 8;
+	lsb = (bit_rate_reg & 0xff);
 
 	// transmit to RF 69
 	retval = rf69_write_reg(spi, REG_BITRATE_MSB, msb);

commit 803058902bbe0f905f85fa085a242cf2f02f92ad
Author: Valentin Vidic <Valentin.Vidic@CARNet.hr>
Date:   Wed Mar 14 21:44:03 2018 +0100

    staging: pi433: fix CamelCase for syncSize variable
    
    Fixes checkpatch warning:
    
      CHECK: Avoid CamelCase: <syncSize>
    
    Signed-off-by: Valentin Vidic <Valentin.Vidic@CARNet.hr>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/pi433/rf69.c b/drivers/staging/pi433/rf69.c
index b2c54999b022..b57d3f4e9321 100644
--- a/drivers/staging/pi433/rf69.c
+++ b/drivers/staging/pi433/rf69.c
@@ -633,16 +633,16 @@ int rf69_set_fifo_fill_condition(struct spi_device *spi, enum fifo_fill_conditio
 	}
 }
 
-int rf69_set_sync_size(struct spi_device *spi, u8 syncSize)
+int rf69_set_sync_size(struct spi_device *spi, u8 sync_size)
 {
 	// check input value
-	if (syncSize > 0x07) {
+	if (sync_size > 0x07) {
 		dev_dbg(&spi->dev, "set: illegal input param");
 		return -EINVAL;
 	}
 
 	// write value
-	return rf69_read_mod_write(spi, REG_SYNC_CONFIG, MASK_SYNC_CONFIG_SYNC_SIZE, (syncSize << 3));
+	return rf69_read_mod_write(spi, REG_SYNC_CONFIG, MASK_SYNC_CONFIG_SYNC_SIZE, (sync_size << 3));
 }
 
 int rf69_set_sync_values(struct spi_device *spi, u8 sync_values[8])

commit 4e3290dbf39e8797d9523683d3af093bbe7ba4ae
Author: Valentin Vidic <Valentin.Vidic@CARNet.hr>
Date:   Wed Mar 14 21:44:02 2018 +0100

    staging: pi433: fix CamelCase for preambleLength variable
    
    Fixes checkpatch warning:
    
      CHECK: Avoid CamelCase: <preambleLength>
    
    Signed-off-by: Valentin Vidic <Valentin.Vidic@CARNet.hr>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/pi433/rf69.c b/drivers/staging/pi433/rf69.c
index e5c7e48a3b86..b2c54999b022 100644
--- a/drivers/staging/pi433/rf69.c
+++ b/drivers/staging/pi433/rf69.c
@@ -590,7 +590,7 @@ int rf69_set_rssi_threshold(struct spi_device *spi, u8 threshold)
 	return rf69_write_reg(spi, REG_RSSITHRESH, threshold);
 }
 
-int rf69_set_preamble_length(struct spi_device *spi, u16 preambleLength)
+int rf69_set_preamble_length(struct spi_device *spi, u16 preamble_length)
 {
 	int retval;
 	u8 msb, lsb;
@@ -598,8 +598,8 @@ int rf69_set_preamble_length(struct spi_device *spi, u16 preambleLength)
 	/* no value check needed - u16 exactly matches register size */
 
 	/* calculate reg settings */
-	msb = (preambleLength & 0xff00) >> 8;
-	lsb = (preambleLength & 0xff);
+	msb = (preamble_length & 0xff00) >> 8;
+	lsb = (preamble_length & 0xff);
 
 	/* transmit to chip */
 	retval = rf69_write_reg(spi, REG_PREAMBLE_MSB, msb);

commit a9f83a65f18105d74e8806c3869fb1ac17469c61
Author: Valentin Vidic <Valentin.Vidic@CARNet.hr>
Date:   Mon Mar 5 08:02:19 2018 +0100

    staging: pi433: fix CamelCase for paRamp enum
    
    Fixes checkpatch warning:
    
      CHECK: Avoid CamelCase: <paRamp>
    
    Signed-off-by: Valentin Vidic <Valentin.Vidic@CARNet.hr>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/pi433/rf69.c b/drivers/staging/pi433/rf69.c
index c143ffc7596f..e5c7e48a3b86 100644
--- a/drivers/staging/pi433/rf69.c
+++ b/drivers/staging/pi433/rf69.c
@@ -345,9 +345,9 @@ int rf69_set_output_power_level(struct spi_device *spi, u8 power_level)
 	return rf69_read_mod_write(spi, REG_PALEVEL, MASK_PALEVEL_OUTPUT_POWER, power_level);
 }
 
-int rf69_set_pa_ramp(struct spi_device *spi, enum paRamp paRamp)
+int rf69_set_pa_ramp(struct spi_device *spi, enum pa_ramp pa_ramp)
 {
-	switch (paRamp) {
+	switch (pa_ramp) {
 	case ramp3400:
 		return rf69_write_reg(spi, REG_PARAMP, PARAMP_3400);
 	case ramp2000:

commit d9a74d5f1eee238b54adccf835120670c7eb6034
Author: Valentin Vidic <Valentin.Vidic@CARNet.hr>
Date:   Mon Mar 5 08:02:18 2018 +0100

    staging: pi433: fix CamelCase for Address variables
    
    Fixes checkpatch warnings:
    
      CHECK: Avoid CamelCase: <nodeAddress>
      CHECK: Avoid CamelCase: <broadcastAddress>
    
    Signed-off-by: Valentin Vidic <Valentin.Vidic@CARNet.hr>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/pi433/rf69.c b/drivers/staging/pi433/rf69.c
index f419a3d4485b..c143ffc7596f 100644
--- a/drivers/staging/pi433/rf69.c
+++ b/drivers/staging/pi433/rf69.c
@@ -704,14 +704,14 @@ int rf69_set_payload_length(struct spi_device *spi, u8 payload_length)
 	return rf69_write_reg(spi, REG_PAYLOAD_LENGTH, payload_length);
 }
 
-int rf69_set_node_address(struct spi_device *spi, u8 nodeAddress)
+int rf69_set_node_address(struct spi_device *spi, u8 node_address)
 {
-	return rf69_write_reg(spi, REG_NODEADRS, nodeAddress);
+	return rf69_write_reg(spi, REG_NODEADRS, node_address);
 }
 
-int rf69_set_broadcast_address(struct spi_device *spi, u8 broadcastAddress)
+int rf69_set_broadcast_address(struct spi_device *spi, u8 broadcast_address)
 {
-	return rf69_write_reg(spi, REG_BROADCASTADRS, broadcastAddress);
+	return rf69_write_reg(spi, REG_BROADCASTADRS, broadcast_address);
 }
 
 int rf69_set_tx_start_condition(struct spi_device *spi, enum tx_start_condition tx_start_condition)

commit cd9d5291bb1839865c04f23686c205a013ec4d0d
Author: Valentin Vidic <Valentin.Vidic@CARNet.hr>
Date:   Mon Mar 5 08:02:17 2018 +0100

    staging: pi433: fix CamelCase for address_filtering enum
    
    Fixes checkpatch warnings:
    
      CHECK: Avoid CamelCase: <filteringOff>
      CHECK: Avoid CamelCase: <nodeAddress>
      CHECK: Avoid CamelCase: <nodeOrBroadcastAddress>
    
    Signed-off-by: Valentin Vidic <Valentin.Vidic@CARNet.hr>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/pi433/rf69.c b/drivers/staging/pi433/rf69.c
index a73a3d2c0685..f419a3d4485b 100644
--- a/drivers/staging/pi433/rf69.c
+++ b/drivers/staging/pi433/rf69.c
@@ -687,11 +687,11 @@ int rf69_disable_crc(struct spi_device *spi)
 int rf69_set_address_filtering(struct spi_device *spi, enum address_filtering address_filtering)
 {
 	switch (address_filtering) {
-	case filteringOff:
+	case filtering_off:
 		return rf69_read_mod_write(spi, REG_PACKETCONFIG1, MASK_PACKETCONFIG1_ADDRESSFILTERING, PACKETCONFIG1_ADDRESSFILTERING_OFF);
-	case nodeAddress:
+	case node_address:
 		return rf69_read_mod_write(spi, REG_PACKETCONFIG1, MASK_PACKETCONFIG1_ADDRESSFILTERING, PACKETCONFIG1_ADDRESSFILTERING_NODE);
-	case nodeOrBroadcastAddress:
+	case node_or_broadcast_address:
 		return rf69_read_mod_write(spi, REG_PACKETCONFIG1, MASK_PACKETCONFIG1_ADDRESSFILTERING, PACKETCONFIG1_ADDRESSFILTERING_NODEBROADCAST);
 	default:
 		dev_dbg(&spi->dev, "set: illegal input param");

commit 53e0b83d01c3bcafed968101531c903a86c4efbd
Author: Valentin Vidic <Valentin.Vidic@CARNet.hr>
Date:   Mon Mar 5 08:02:16 2018 +0100

    staging: pi433: fix CamelCase for afterSyncInterrupt
    
    Fixes checkpatch warning:
    
      CHECK: Avoid CamelCase: <afterSyncInterrupt>
    
    Signed-off-by: Valentin Vidic <Valentin.Vidic@CARNet.hr>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/pi433/rf69.c b/drivers/staging/pi433/rf69.c
index fc4919711477..a73a3d2c0685 100644
--- a/drivers/staging/pi433/rf69.c
+++ b/drivers/staging/pi433/rf69.c
@@ -625,7 +625,7 @@ int rf69_set_fifo_fill_condition(struct spi_device *spi, enum fifo_fill_conditio
 	switch (fifo_fill_condition) {
 	case always:
 		return rf69_set_bit(spi, REG_SYNC_CONFIG, MASK_SYNC_CONFIG_FIFO_FILL_CONDITION);
-	case afterSyncInterrupt:
+	case after_sync_interrupt:
 		return rf69_clear_bit(spi, REG_SYNC_CONFIG, MASK_SYNC_CONFIG_FIFO_FILL_CONDITION);
 	default:
 		dev_dbg(&spi->dev, "set: illegal input param");

commit 1cd41fc3f32b18a2a82135ed74b0107bc7ce1523
Author: Valentin Vidic <Valentin.Vidic@CARNet.hr>
Date:   Mon Mar 5 08:02:15 2018 +0100

    staging: pi433: fix CamelCase for flag enum
    
    Fixes checkpatch warnings:
    
      CHECK: Avoid CamelCase: <modeSwitchCompleted>
      CHECK: Avoid CamelCase: <readyToReceive>
      CHECK: Avoid CamelCase: <readyToSend>
      CHECK: Avoid CamelCase: <pllLocked>
      CHECK: Avoid CamelCase: <rssiExceededThreshold>
      CHECK: Avoid CamelCase: <syncAddressMatch>
      CHECK: Avoid CamelCase: <packetSent>
      CHECK: Avoid CamelCase: <crcOk>
      CHECK: Avoid CamelCase: <batteryLow>
    
    Signed-off-by: Valentin Vidic <Valentin.Vidic@CARNet.hr>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/pi433/rf69.c b/drivers/staging/pi433/rf69.c
index 54d8105b5812..fc4919711477 100644
--- a/drivers/staging/pi433/rf69.c
+++ b/drivers/staging/pi433/rf69.c
@@ -545,21 +545,21 @@ int rf69_set_dio_mapping(struct spi_device *spi, u8 DIONumber, u8 value)
 bool rf69_get_flag(struct spi_device *spi, enum flag flag)
 {
 	switch (flag) {
-	case modeSwitchCompleted:
+	case mode_switch_completed:
 		return (rf69_read_reg(spi, REG_IRQFLAGS1) & MASK_IRQFLAGS1_MODE_READY);
-	case readyToReceive:
+	case ready_to_receive:
 		return (rf69_read_reg(spi, REG_IRQFLAGS1) & MASK_IRQFLAGS1_RX_READY);
-	case readyToSend:
+	case ready_to_send:
 		return (rf69_read_reg(spi, REG_IRQFLAGS1) & MASK_IRQFLAGS1_TX_READY);
-	case pllLocked:
+	case pll_locked:
 		return (rf69_read_reg(spi, REG_IRQFLAGS1) & MASK_IRQFLAGS1_PLL_LOCK);
-	case rssiExceededThreshold:
+	case rssi_exceeded_threshold:
 		return (rf69_read_reg(spi, REG_IRQFLAGS1) & MASK_IRQFLAGS1_RSSI);
 	case timeout:
 		return (rf69_read_reg(spi, REG_IRQFLAGS1) & MASK_IRQFLAGS1_TIMEOUT);
 	case automode:
 		return (rf69_read_reg(spi, REG_IRQFLAGS1) & MASK_IRQFLAGS1_AUTOMODE);
-	case syncAddressMatch:
+	case sync_address_match:
 		return (rf69_read_reg(spi, REG_IRQFLAGS1) & MASK_IRQFLAGS1_SYNC_ADDRESS_MATCH);
 	case fifo_full:
 		return (rf69_read_reg(spi, REG_IRQFLAGS2) & MASK_IRQFLAGS2_FIFO_FULL);
@@ -571,13 +571,13 @@ bool rf69_get_flag(struct spi_device *spi, enum flag flag)
 		return (rf69_read_reg(spi, REG_IRQFLAGS2) & MASK_IRQFLAGS2_FIFO_LEVEL);
 	case fifo_overrun:
 		return (rf69_read_reg(spi, REG_IRQFLAGS2) & MASK_IRQFLAGS2_FIFO_OVERRUN);
-	case packetSent:
+	case packet_sent:
 		return (rf69_read_reg(spi, REG_IRQFLAGS2) & MASK_IRQFLAGS2_PACKET_SENT);
 	case payload_ready:
 		return (rf69_read_reg(spi, REG_IRQFLAGS2) & MASK_IRQFLAGS2_PAYLOAD_READY);
-	case crcOk:
+	case crc_ok:
 		return (rf69_read_reg(spi, REG_IRQFLAGS2) & MASK_IRQFLAGS2_CRC_OK);
-	case batteryLow:
+	case battery_low:
 		return (rf69_read_reg(spi, REG_IRQFLAGS2) & MASK_IRQFLAGS2_LOW_BAT);
 	default:			 return false;
 	}

commit c436ef3b9abfcdb3b6db0c87f3d11d628cd0d426
Author: Valentin Vidic <Valentin.Vidic@CARNet.hr>
Date:   Mon Mar 5 08:02:14 2018 +0100

    staging: pi433: fix CamelCase for packetFormat enum
    
    Fixes checkpatch warnings:
    
      CHECK: Avoid CamelCase: <packetFormat>
      CHECK: Avoid CamelCase: <packetLengthFix>
      CHECK: Avoid CamelCase: <packetLengthVar>
    
    Signed-off-by: Valentin Vidic <Valentin.Vidic@CARNet.hr>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/pi433/rf69.c b/drivers/staging/pi433/rf69.c
index b2cea5f52eea..54d8105b5812 100644
--- a/drivers/staging/pi433/rf69.c
+++ b/drivers/staging/pi433/rf69.c
@@ -661,12 +661,12 @@ int rf69_set_sync_values(struct spi_device *spi, u8 sync_values[8])
 	return retval;
 }
 
-int rf69_set_packet_format(struct spi_device *spi, enum packetFormat packetFormat)
+int rf69_set_packet_format(struct spi_device *spi, enum packet_format packet_format)
 {
-	switch (packetFormat) {
-	case packetLengthVar:
+	switch (packet_format) {
+	case packet_length_var:
 		return rf69_set_bit(spi, REG_PACKETCONFIG1, MASK_PACKETCONFIG1_PAKET_FORMAT_VARIABLE);
-	case packetLengthFix:
+	case packet_length_fix:
 		return rf69_clear_bit(spi, REG_PACKETCONFIG1, MASK_PACKETCONFIG1_PAKET_FORMAT_VARIABLE);
 	default:
 		dev_dbg(&spi->dev, "set: illegal input param");

commit e69a0500f23dc643bf974e04386c6f1a427c6448
Author: Valentin Vidic <Valentin.Vidic@CARNet.hr>
Date:   Tue Feb 20 15:13:07 2018 +0100

    staging: pi433: fix CamelCase for addressFiltering
    
    Fixes checkpatch warning:
    
      CHECK: Avoid CamelCase: <addressFiltering>
    
    Signed-off-by: Valentin Vidic <Valentin.Vidic@CARNet.hr>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/pi433/rf69.c b/drivers/staging/pi433/rf69.c
index 91c834059710..b2cea5f52eea 100644
--- a/drivers/staging/pi433/rf69.c
+++ b/drivers/staging/pi433/rf69.c
@@ -684,9 +684,9 @@ int rf69_disable_crc(struct spi_device *spi)
 	return rf69_clear_bit(spi, REG_PACKETCONFIG1, MASK_PACKETCONFIG1_CRC_ON);
 }
 
-int rf69_set_adressFiltering(struct spi_device *spi, enum addressFiltering addressFiltering)
+int rf69_set_address_filtering(struct spi_device *spi, enum address_filtering address_filtering)
 {
-	switch (addressFiltering) {
+	switch (address_filtering) {
 	case filteringOff:
 		return rf69_read_mod_write(spi, REG_PACKETCONFIG1, MASK_PACKETCONFIG1_ADDRESSFILTERING, PACKETCONFIG1_ADDRESSFILTERING_OFF);
 	case nodeAddress:

commit b52a5b79367ccbe4f1c9d89e21e4405e7fa0e6dc
Author: Valentin Vidic <Valentin.Vidic@CARNet.hr>
Date:   Tue Feb 20 15:03:30 2018 +0100

    staging: pi433: fix CamelCase for thresholdDecrement
    
    Fixes checkpatch warning:
    
      CHECK: Avoid CamelCase: <thresholdDecrement>
    
    Signed-off-by: Valentin Vidic <Valentin.Vidic@CARNet.hr>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/pi433/rf69.c b/drivers/staging/pi433/rf69.c
index 722d95a3777f..91c834059710 100644
--- a/drivers/staging/pi433/rf69.c
+++ b/drivers/staging/pi433/rf69.c
@@ -476,9 +476,9 @@ int rf69_set_bandwidth_during_afc(struct spi_device *spi, enum mantisse mantisse
 	return rf69_set_bandwidth_intern(spi, REG_AFCBW, mantisse, exponent);
 }
 
-int rf69_set_ook_threshold_dec(struct spi_device *spi, enum thresholdDecrement thresholdDecrement)
+int rf69_set_ook_threshold_dec(struct spi_device *spi, enum threshold_decrement threshold_decrement)
 {
-	switch (thresholdDecrement) {
+	switch (threshold_decrement) {
 	case dec_every8th:
 		return rf69_read_mod_write(spi, REG_OOKPEAK, MASK_OOKPEAK_THRESDEC, OOKPEAK_THRESHDEC_EVERY_8TH);
 	case dec_every4th:

commit 6252016c8697c4597cd16628c2d3081b8d4a22e6
Author: Valentin Vidic <Valentin.Vidic@CARNet.hr>
Date:   Tue Feb 20 14:56:45 2018 +0100

    staging: pi433: fix CamelCase for txStartCondition
    
    Fixes checkpatch warning:
    
      CHECK: Avoid CamelCase: <txStartCondition>
    
    Signed-off-by: Valentin Vidic <Valentin.Vidic@CARNet.hr>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/pi433/rf69.c b/drivers/staging/pi433/rf69.c
index 42c2e1c6b386..722d95a3777f 100644
--- a/drivers/staging/pi433/rf69.c
+++ b/drivers/staging/pi433/rf69.c
@@ -714,9 +714,9 @@ int rf69_set_broadcast_address(struct spi_device *spi, u8 broadcastAddress)
 	return rf69_write_reg(spi, REG_BROADCASTADRS, broadcastAddress);
 }
 
-int rf69_set_tx_start_condition(struct spi_device *spi, enum txStartCondition txStartCondition)
+int rf69_set_tx_start_condition(struct spi_device *spi, enum tx_start_condition tx_start_condition)
 {
-	switch (txStartCondition) {
+	switch (tx_start_condition) {
 	case fifo_level:
 		return rf69_clear_bit(spi, REG_FIFO_THRESH, MASK_FIFO_THRESH_TXSTART);
 	case fifo_not_empty:

commit e6dd870a0080787b472ab8895bef91486c70ebcf
Author: Valentin Vidic <Valentin.Vidic@CARNet.hr>
Date:   Sat Jan 27 10:42:16 2018 +0100

    staging: pi433: fix CamelCase for regValue
    
    Local variable storing the new value for dio register
    so replace with dio_value.  Update regaddr to dio_addr
    to match.
    
    Fixes checkpatch warnings:
    
      CHECK: Avoid CamelCase: <regValue>
    
    Signed-off-by: Valentin Vidic <Valentin.Vidic@CARNet.hr>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/pi433/rf69.c b/drivers/staging/pi433/rf69.c
index ef56deccd0af..42c2e1c6b386 100644
--- a/drivers/staging/pi433/rf69.c
+++ b/drivers/staging/pi433/rf69.c
@@ -505,27 +505,27 @@ int rf69_set_dio_mapping(struct spi_device *spi, u8 DIONumber, u8 value)
 {
 	u8 mask;
 	u8 shift;
-	u8 regaddr;
-	u8 regValue;
+	u8 dio_addr;
+	u8 dio_value;
 
 	switch (DIONumber) {
 	case 0:
-		mask = MASK_DIO0; shift = SHIFT_DIO0; regaddr = REG_DIOMAPPING1;
+		mask = MASK_DIO0; shift = SHIFT_DIO0; dio_addr = REG_DIOMAPPING1;
 		break;
 	case 1:
-		mask = MASK_DIO1; shift = SHIFT_DIO1; regaddr = REG_DIOMAPPING1;
+		mask = MASK_DIO1; shift = SHIFT_DIO1; dio_addr = REG_DIOMAPPING1;
 		break;
 	case 2:
-		mask = MASK_DIO2; shift = SHIFT_DIO2; regaddr = REG_DIOMAPPING1;
+		mask = MASK_DIO2; shift = SHIFT_DIO2; dio_addr = REG_DIOMAPPING1;
 		break;
 	case 3:
-		mask = MASK_DIO3; shift = SHIFT_DIO3; regaddr = REG_DIOMAPPING1;
+		mask = MASK_DIO3; shift = SHIFT_DIO3; dio_addr = REG_DIOMAPPING1;
 		break;
 	case 4:
-		mask = MASK_DIO4; shift = SHIFT_DIO4; regaddr = REG_DIOMAPPING2;
+		mask = MASK_DIO4; shift = SHIFT_DIO4; dio_addr = REG_DIOMAPPING2;
 		break;
 	case 5:
-		mask = MASK_DIO5; shift = SHIFT_DIO5; regaddr = REG_DIOMAPPING2;
+		mask = MASK_DIO5; shift = SHIFT_DIO5; dio_addr = REG_DIOMAPPING2;
 		break;
 	default:
 	dev_dbg(&spi->dev, "set: illegal input param");
@@ -533,13 +533,13 @@ int rf69_set_dio_mapping(struct spi_device *spi, u8 DIONumber, u8 value)
 	}
 
 	// read reg
-	regValue = rf69_read_reg(spi, regaddr);
+	dio_value = rf69_read_reg(spi, dio_addr);
 	// delete old value
-	regValue = regValue & ~mask;
+	dio_value = dio_value & ~mask;
 	// add new value
-	regValue = regValue | value << shift;
+	dio_value = dio_value | value << shift;
 	// write back
-	return rf69_write_reg(spi, regaddr, regValue);
+	return rf69_write_reg(spi, dio_addr, dio_value);
 }
 
 bool rf69_get_flag(struct spi_device *spi, enum flag flag)

commit f53c5d92b596b6f0a7dd1a636d1018e51230b271
Author: Valentin Vidic <Valentin.Vidic@CARNet.hr>
Date:   Sat Jan 27 10:42:15 2018 +0100

    staging: pi433: fix CamelCase for newValue
    
    Local variable storing the new value for bandwidth register
    so replace with bandwidth.
    
    Fixes checkpatch warnings:
    
      CHECK: Avoid CamelCase: <newValue>
    
    Signed-off-by: Valentin Vidic <Valentin.Vidic@CARNet.hr>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/pi433/rf69.c b/drivers/staging/pi433/rf69.c
index 261ba1643f5a..ef56deccd0af 100644
--- a/drivers/staging/pi433/rf69.c
+++ b/drivers/staging/pi433/rf69.c
@@ -425,7 +425,7 @@ int rf69_set_lna_gain(struct spi_device *spi, enum lnaGain lnaGain)
 static int rf69_set_bandwidth_intern(struct spi_device *spi, u8 reg,
 				     enum mantisse mantisse, u8 exponent)
 {
-	u8 newValue;
+	u8 bandwidth;
 
 	// check value for mantisse and exponent
 	if (exponent > 7) {
@@ -441,29 +441,29 @@ static int rf69_set_bandwidth_intern(struct spi_device *spi, u8 reg,
 	}
 
 	// read old value
-	newValue = rf69_read_reg(spi, reg);
+	bandwidth = rf69_read_reg(spi, reg);
 
 	// "delete" mantisse and exponent = just keep the DCC setting
-	newValue = newValue & MASK_BW_DCC_FREQ;
+	bandwidth = bandwidth & MASK_BW_DCC_FREQ;
 
 	// add new mantisse
 	switch (mantisse) {
 	case mantisse16:
-		newValue = newValue | BW_MANT_16;
+		bandwidth = bandwidth | BW_MANT_16;
 		break;
 	case mantisse20:
-		newValue = newValue | BW_MANT_20;
+		bandwidth = bandwidth | BW_MANT_20;
 		break;
 	case mantisse24:
-		newValue = newValue | BW_MANT_24;
+		bandwidth = bandwidth | BW_MANT_24;
 		break;
 	}
 
 	// add new exponent
-	newValue = newValue | exponent;
+	bandwidth = bandwidth | exponent;
 
 	// write back
-	return rf69_write_reg(spi, reg, newValue);
+	return rf69_write_reg(spi, reg, bandwidth);
 }
 
 int rf69_set_bandwidth(struct spi_device *spi, enum mantisse mantisse, u8 exponent)

commit e64dbd5cd0577396112c2703f52a822f7240b253
Author: Valentin Vidic <Valentin.Vidic@CARNet.hr>
Date:   Sat Jan 27 10:42:14 2018 +0100

    staging: pi433: fix CamelCase for currentValue
    
    Local variable storing the value for modulation register so replace
    with modulation_reg.
    
    Fixes checkpatch warnings:
    
      CHECK: Avoid CamelCase: <currentValue>
    
    Signed-off-by: Valentin Vidic <Valentin.Vidic@CARNet.hr>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/pi433/rf69.c b/drivers/staging/pi433/rf69.c
index c69e63ffe537..261ba1643f5a 100644
--- a/drivers/staging/pi433/rf69.c
+++ b/drivers/staging/pi433/rf69.c
@@ -151,11 +151,11 @@ int rf69_set_modulation(struct spi_device *spi, enum modulation modulation)
 
 static enum modulation rf69_get_modulation(struct spi_device *spi)
 {
-	u8 currentValue;
+	u8 modulation_reg;
 
-	currentValue = rf69_read_reg(spi, REG_DATAMODUL);
+	modulation_reg = rf69_read_reg(spi, REG_DATAMODUL);
 
-	switch (currentValue & MASK_DATAMODUL_MODULATION_TYPE) {
+	switch (modulation_reg & MASK_DATAMODUL_MODULATION_TYPE) {
 	case DATAMODUL_MODULATION_TYPE_OOK:
 		return OOK;
 	case DATAMODUL_MODULATION_TYPE_FSK:

commit 0b897065834f25c6dfff19c149139572a8c7301c
Author: Valentin Vidic <Valentin.Vidic@CARNet.hr>
Date:   Sat Jan 27 10:42:13 2018 +0100

    staging: pi433: fix CamelCase for Ohm identifiers
    
    Fixes checkpatch warnings:
    
      CHECK: Avoid CamelCase: <fiftyOhm>
      CHECK: Avoid CamelCase: <twohundretOhm>
    
    Signed-off-by: Valentin Vidic <Valentin.Vidic@CARNet.hr>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/pi433/rf69.c b/drivers/staging/pi433/rf69.c
index 34ea865e55de..c69e63ffe537 100644
--- a/drivers/staging/pi433/rf69.c
+++ b/drivers/staging/pi433/rf69.c
@@ -389,9 +389,9 @@ int rf69_set_pa_ramp(struct spi_device *spi, enum paRamp paRamp)
 int rf69_set_antenna_impedance(struct spi_device *spi, enum antenna_impedance antenna_impedance)
 {
 	switch (antenna_impedance) {
-	case fiftyOhm:
+	case fifty_ohm:
 		return rf69_clear_bit(spi, REG_LNA, MASK_LNA_ZIN);
-	case twohundretOhm:
+	case two_hundred_ohm:
 		return rf69_set_bit(spi, REG_LNA, MASK_LNA_ZIN);
 	default:
 		dev_dbg(&spi->dev, "set: illegal input param");

commit 370d7ce625bb5ce338ccaf4d3843288958d937fd
Author: Valentin Vidic <Valentin.Vidic@CARNet.hr>
Date:   Sat Jan 27 10:42:12 2018 +0100

    staging: pi433: fix CamelCase for antennaImpedance
    
    Fixes checkpatch warnings:
    
      CHECK: Avoid CamelCase: <antennaImpedance>
    
    Signed-off-by: Valentin Vidic <Valentin.Vidic@CARNet.hr>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/pi433/rf69.c b/drivers/staging/pi433/rf69.c
index 096bf84e9034..34ea865e55de 100644
--- a/drivers/staging/pi433/rf69.c
+++ b/drivers/staging/pi433/rf69.c
@@ -386,9 +386,9 @@ int rf69_set_pa_ramp(struct spi_device *spi, enum paRamp paRamp)
 	}
 }
 
-int rf69_set_antenna_impedance(struct spi_device *spi, enum antennaImpedance antennaImpedance)
+int rf69_set_antenna_impedance(struct spi_device *spi, enum antenna_impedance antenna_impedance)
 {
-	switch (antennaImpedance) {
+	switch (antenna_impedance) {
 	case fiftyOhm:
 		return rf69_clear_bit(spi, REG_LNA, MASK_LNA_ZIN);
 	case twohundretOhm:

commit 842e05d52d24e9a31724d607e06685310ae2e1f3
Author: Valentin Vidic <Valentin.Vidic@CARNet.hr>
Date:   Sat Jan 27 10:42:11 2018 +0100

    staging: pi433: fix CamelCase for powerLevel
    
    Fixes checkpatch warnings:
    
      CHECK: Avoid CamelCase: <powerLevel>
    
    Signed-off-by: Valentin Vidic <Valentin.Vidic@CARNet.hr>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/pi433/rf69.c b/drivers/staging/pi433/rf69.c
index d55ef95b723e..096bf84e9034 100644
--- a/drivers/staging/pi433/rf69.c
+++ b/drivers/staging/pi433/rf69.c
@@ -330,19 +330,19 @@ int rf69_disable_amplifier(struct spi_device *spi, u8 amplifier_mask)
 	return rf69_clear_bit(spi, REG_PALEVEL, amplifier_mask);
 }
 
-int rf69_set_output_power_level(struct spi_device *spi, u8 powerLevel)
+int rf69_set_output_power_level(struct spi_device *spi, u8 power_level)
 {
 	// TODO: Dependency to PA0,1,2 setting
-	powerLevel += 18;
+	power_level += 18;
 
 	// check input value
-	if (powerLevel > 0x1f) {
+	if (power_level > 0x1f) {
 		dev_dbg(&spi->dev, "set: illegal input param");
 		return -EINVAL;
 	}
 
 	// write value
-	return rf69_read_mod_write(spi, REG_PALEVEL, MASK_PALEVEL_OUTPUT_POWER, powerLevel);
+	return rf69_read_mod_write(spi, REG_PALEVEL, MASK_PALEVEL_OUTPUT_POWER, power_level);
 }
 
 int rf69_set_pa_ramp(struct spi_device *spi, enum paRamp paRamp)

commit 5ca565adaf9690b7f731883c8de066d2b26a7239
Author: Valentin Vidic <Valentin.Vidic@CARNet.hr>
Date:   Sat Jan 27 10:42:10 2018 +0100

    staging: pi433: fix CamelCase for syncValues
    
    Fixes checkpatch warnings:
    
      CHECK: Avoid CamelCase: <syncValues>
    
    Signed-off-by: Valentin Vidic <Valentin.Vidic@CARNet.hr>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/pi433/rf69.c b/drivers/staging/pi433/rf69.c
index 7ccdff6ae213..d55ef95b723e 100644
--- a/drivers/staging/pi433/rf69.c
+++ b/drivers/staging/pi433/rf69.c
@@ -645,18 +645,18 @@ int rf69_set_sync_size(struct spi_device *spi, u8 syncSize)
 	return rf69_read_mod_write(spi, REG_SYNC_CONFIG, MASK_SYNC_CONFIG_SYNC_SIZE, (syncSize << 3));
 }
 
-int rf69_set_sync_values(struct spi_device *spi, u8 syncValues[8])
+int rf69_set_sync_values(struct spi_device *spi, u8 sync_values[8])
 {
 	int retval = 0;
 
-	retval += rf69_write_reg(spi, REG_SYNCVALUE1, syncValues[0]);
-	retval += rf69_write_reg(spi, REG_SYNCVALUE2, syncValues[1]);
-	retval += rf69_write_reg(spi, REG_SYNCVALUE3, syncValues[2]);
-	retval += rf69_write_reg(spi, REG_SYNCVALUE4, syncValues[3]);
-	retval += rf69_write_reg(spi, REG_SYNCVALUE5, syncValues[4]);
-	retval += rf69_write_reg(spi, REG_SYNCVALUE6, syncValues[5]);
-	retval += rf69_write_reg(spi, REG_SYNCVALUE7, syncValues[6]);
-	retval += rf69_write_reg(spi, REG_SYNCVALUE8, syncValues[7]);
+	retval += rf69_write_reg(spi, REG_SYNCVALUE1, sync_values[0]);
+	retval += rf69_write_reg(spi, REG_SYNCVALUE2, sync_values[1]);
+	retval += rf69_write_reg(spi, REG_SYNCVALUE3, sync_values[2]);
+	retval += rf69_write_reg(spi, REG_SYNCVALUE4, sync_values[3]);
+	retval += rf69_write_reg(spi, REG_SYNCVALUE5, sync_values[4]);
+	retval += rf69_write_reg(spi, REG_SYNCVALUE6, sync_values[5]);
+	retval += rf69_write_reg(spi, REG_SYNCVALUE7, sync_values[6]);
+	retval += rf69_write_reg(spi, REG_SYNCVALUE8, sync_values[7]);
 
 	return retval;
 }

commit a66a4e8e01f3b607a9aa5b5ed9ca588b4c3a962e
Author: Michael Panzlaff <michael.panzlaff@fau.de>
Date:   Tue Jan 9 17:20:58 2018 +0100

    staging: pi433: Cleanup codestyle, indent statements after case labels
    
    This patch changes the indentation of the statements after case labels.
    The linux coding guidelines do not explicitly mentiond this but pretty
    much all existing code doesn't put any statements into the same line of
    their belonging case labels. Therefore this adapts to the more usual style.
    
    Please note that there is still a lot of > 80 character lines which will
    cause checkpatch warnings. This patch does not intent to fix this
    already existing issue.
    
    Signed-off-by: Michael Panzlaff <michael.panzlaff@fau.de>
    Signed-off-by: Tillmann Zipperer <tillmann.zipperer@fau.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/pi433/rf69.c b/drivers/staging/pi433/rf69.c
index bdd00f750765..7ccdff6ae213 100644
--- a/drivers/staging/pi433/rf69.c
+++ b/drivers/staging/pi433/rf69.c
@@ -111,11 +111,16 @@ static inline int rf69_read_mod_write(struct spi_device *spi, u8 reg, u8 mask, u
 int rf69_set_mode(struct spi_device *spi, enum mode mode)
 {
 	switch (mode) {
-	case transmit:	  return rf69_read_mod_write(spi, REG_OPMODE, MASK_OPMODE_MODE, OPMODE_MODE_TRANSMIT);
-	case receive:	  return rf69_read_mod_write(spi, REG_OPMODE, MASK_OPMODE_MODE, OPMODE_MODE_RECEIVE);
-	case synthesizer: return rf69_read_mod_write(spi, REG_OPMODE, MASK_OPMODE_MODE, OPMODE_MODE_SYNTHESIZER);
-	case standby:	  return rf69_read_mod_write(spi, REG_OPMODE, MASK_OPMODE_MODE, OPMODE_MODE_STANDBY);
-	case mode_sleep:  return rf69_read_mod_write(spi, REG_OPMODE, MASK_OPMODE_MODE, OPMODE_MODE_SLEEP);
+	case transmit:
+		return rf69_read_mod_write(spi, REG_OPMODE, MASK_OPMODE_MODE, OPMODE_MODE_TRANSMIT);
+	case receive:
+		return rf69_read_mod_write(spi, REG_OPMODE, MASK_OPMODE_MODE, OPMODE_MODE_RECEIVE);
+	case synthesizer:
+		return rf69_read_mod_write(spi, REG_OPMODE, MASK_OPMODE_MODE, OPMODE_MODE_SYNTHESIZER);
+	case standby:
+		return rf69_read_mod_write(spi, REG_OPMODE, MASK_OPMODE_MODE, OPMODE_MODE_STANDBY);
+	case mode_sleep:
+		return rf69_read_mod_write(spi, REG_OPMODE, MASK_OPMODE_MODE, OPMODE_MODE_SLEEP);
 	default:
 		dev_dbg(&spi->dev, "set: illegal input param");
 		return -EINVAL;
@@ -134,8 +139,10 @@ int rf69_set_data_mode(struct spi_device *spi, u8 data_mode)
 int rf69_set_modulation(struct spi_device *spi, enum modulation modulation)
 {
 	switch (modulation) {
-	case OOK: return rf69_read_mod_write(spi, REG_DATAMODUL, MASK_DATAMODUL_MODULATION_TYPE, DATAMODUL_MODULATION_TYPE_OOK);
-	case FSK: return rf69_read_mod_write(spi, REG_DATAMODUL, MASK_DATAMODUL_MODULATION_TYPE, DATAMODUL_MODULATION_TYPE_FSK);
+	case OOK:
+		return rf69_read_mod_write(spi, REG_DATAMODUL, MASK_DATAMODUL_MODULATION_TYPE, DATAMODUL_MODULATION_TYPE_OOK);
+	case FSK:
+		return rf69_read_mod_write(spi, REG_DATAMODUL, MASK_DATAMODUL_MODULATION_TYPE, DATAMODUL_MODULATION_TYPE_FSK);
 	default:
 		dev_dbg(&spi->dev, "set: illegal input param");
 		return -EINVAL;
@@ -149,9 +156,12 @@ static enum modulation rf69_get_modulation(struct spi_device *spi)
 	currentValue = rf69_read_reg(spi, REG_DATAMODUL);
 
 	switch (currentValue & MASK_DATAMODUL_MODULATION_TYPE) {
-	case DATAMODUL_MODULATION_TYPE_OOK: return OOK;
-	case DATAMODUL_MODULATION_TYPE_FSK: return FSK;
-	default:			    return UNDEF;
+	case DATAMODUL_MODULATION_TYPE_OOK:
+		return OOK;
+	case DATAMODUL_MODULATION_TYPE_FSK:
+		return FSK;
+	default:
+		return UNDEF;
 	}
 }
 
@@ -161,19 +171,26 @@ int rf69_set_modulation_shaping(struct spi_device *spi,
 	switch (rf69_get_modulation(spi)) {
 	case FSK:
 		switch (mod_shaping) {
-		case SHAPING_OFF: return rf69_read_mod_write(spi, REG_DATAMODUL, MASK_DATAMODUL_MODULATION_SHAPE, DATAMODUL_MODULATION_SHAPE_NONE);
-		case SHAPING_1_0: return rf69_read_mod_write(spi, REG_DATAMODUL, MASK_DATAMODUL_MODULATION_SHAPE, DATAMODUL_MODULATION_SHAPE_1_0);
-		case SHAPING_0_5: return rf69_read_mod_write(spi, REG_DATAMODUL, MASK_DATAMODUL_MODULATION_SHAPE, DATAMODUL_MODULATION_SHAPE_0_5);
-		case SHAPING_0_3: return rf69_read_mod_write(spi, REG_DATAMODUL, MASK_DATAMODUL_MODULATION_SHAPE, DATAMODUL_MODULATION_SHAPE_0_3);
+		case SHAPING_OFF:
+			return rf69_read_mod_write(spi, REG_DATAMODUL, MASK_DATAMODUL_MODULATION_SHAPE, DATAMODUL_MODULATION_SHAPE_NONE);
+		case SHAPING_1_0:
+			return rf69_read_mod_write(spi, REG_DATAMODUL, MASK_DATAMODUL_MODULATION_SHAPE, DATAMODUL_MODULATION_SHAPE_1_0);
+		case SHAPING_0_5:
+			return rf69_read_mod_write(spi, REG_DATAMODUL, MASK_DATAMODUL_MODULATION_SHAPE, DATAMODUL_MODULATION_SHAPE_0_5);
+		case SHAPING_0_3:
+			return rf69_read_mod_write(spi, REG_DATAMODUL, MASK_DATAMODUL_MODULATION_SHAPE, DATAMODUL_MODULATION_SHAPE_0_3);
 		default:
 			dev_dbg(&spi->dev, "set: illegal input param");
 			return -EINVAL;
 		}
 	case OOK:
 		switch (mod_shaping) {
-		case SHAPING_OFF: return rf69_read_mod_write(spi, REG_DATAMODUL, MASK_DATAMODUL_MODULATION_SHAPE, DATAMODUL_MODULATION_SHAPE_NONE);
-		case SHAPING_BR:  return rf69_read_mod_write(spi, REG_DATAMODUL, MASK_DATAMODUL_MODULATION_SHAPE, DATAMODUL_MODULATION_SHAPE_BR);
-		case SHAPING_2BR: return rf69_read_mod_write(spi, REG_DATAMODUL, MASK_DATAMODUL_MODULATION_SHAPE, DATAMODUL_MODULATION_SHAPE_2BR);
+		case SHAPING_OFF:
+			return rf69_read_mod_write(spi, REG_DATAMODUL, MASK_DATAMODUL_MODULATION_SHAPE, DATAMODUL_MODULATION_SHAPE_NONE);
+		case SHAPING_BR:
+			return rf69_read_mod_write(spi, REG_DATAMODUL, MASK_DATAMODUL_MODULATION_SHAPE, DATAMODUL_MODULATION_SHAPE_BR);
+		case SHAPING_2BR:
+			return rf69_read_mod_write(spi, REG_DATAMODUL, MASK_DATAMODUL_MODULATION_SHAPE, DATAMODUL_MODULATION_SHAPE_2BR);
 		default:
 			dev_dbg(&spi->dev, "set: illegal input param");
 			return -EINVAL;
@@ -331,22 +348,38 @@ int rf69_set_output_power_level(struct spi_device *spi, u8 powerLevel)
 int rf69_set_pa_ramp(struct spi_device *spi, enum paRamp paRamp)
 {
 	switch (paRamp) {
-	case ramp3400:	return rf69_write_reg(spi, REG_PARAMP, PARAMP_3400);
-	case ramp2000:	return rf69_write_reg(spi, REG_PARAMP, PARAMP_2000);
-	case ramp1000:	return rf69_write_reg(spi, REG_PARAMP, PARAMP_1000);
-	case ramp500:	return rf69_write_reg(spi, REG_PARAMP, PARAMP_500);
-	case ramp250:	return rf69_write_reg(spi, REG_PARAMP, PARAMP_250);
-	case ramp125:	return rf69_write_reg(spi, REG_PARAMP, PARAMP_125);
-	case ramp100:	return rf69_write_reg(spi, REG_PARAMP, PARAMP_100);
-	case ramp62:	return rf69_write_reg(spi, REG_PARAMP, PARAMP_62);
-	case ramp50:	return rf69_write_reg(spi, REG_PARAMP, PARAMP_50);
-	case ramp40:	return rf69_write_reg(spi, REG_PARAMP, PARAMP_40);
-	case ramp31:	return rf69_write_reg(spi, REG_PARAMP, PARAMP_31);
-	case ramp25:	return rf69_write_reg(spi, REG_PARAMP, PARAMP_25);
-	case ramp20:	return rf69_write_reg(spi, REG_PARAMP, PARAMP_20);
-	case ramp15:	return rf69_write_reg(spi, REG_PARAMP, PARAMP_15);
-	case ramp12:	return rf69_write_reg(spi, REG_PARAMP, PARAMP_12);
-	case ramp10:	return rf69_write_reg(spi, REG_PARAMP, PARAMP_10);
+	case ramp3400:
+		return rf69_write_reg(spi, REG_PARAMP, PARAMP_3400);
+	case ramp2000:
+		return rf69_write_reg(spi, REG_PARAMP, PARAMP_2000);
+	case ramp1000:
+		return rf69_write_reg(spi, REG_PARAMP, PARAMP_1000);
+	case ramp500:
+		return rf69_write_reg(spi, REG_PARAMP, PARAMP_500);
+	case ramp250:
+		return rf69_write_reg(spi, REG_PARAMP, PARAMP_250);
+	case ramp125:
+		return rf69_write_reg(spi, REG_PARAMP, PARAMP_125);
+	case ramp100:
+		return rf69_write_reg(spi, REG_PARAMP, PARAMP_100);
+	case ramp62:
+		return rf69_write_reg(spi, REG_PARAMP, PARAMP_62);
+	case ramp50:
+		return rf69_write_reg(spi, REG_PARAMP, PARAMP_50);
+	case ramp40:
+		return rf69_write_reg(spi, REG_PARAMP, PARAMP_40);
+	case ramp31:
+		return rf69_write_reg(spi, REG_PARAMP, PARAMP_31);
+	case ramp25:
+		return rf69_write_reg(spi, REG_PARAMP, PARAMP_25);
+	case ramp20:
+		return rf69_write_reg(spi, REG_PARAMP, PARAMP_20);
+	case ramp15:
+		return rf69_write_reg(spi, REG_PARAMP, PARAMP_15);
+	case ramp12:
+		return rf69_write_reg(spi, REG_PARAMP, PARAMP_12);
+	case ramp10:
+		return rf69_write_reg(spi, REG_PARAMP, PARAMP_10);
 	default:
 		dev_dbg(&spi->dev, "set: illegal input param");
 		return -EINVAL;
@@ -356,8 +389,10 @@ int rf69_set_pa_ramp(struct spi_device *spi, enum paRamp paRamp)
 int rf69_set_antenna_impedance(struct spi_device *spi, enum antennaImpedance antennaImpedance)
 {
 	switch (antennaImpedance) {
-	case fiftyOhm:	    return rf69_clear_bit(spi, REG_LNA, MASK_LNA_ZIN);
-	case twohundretOhm: return rf69_set_bit(spi, REG_LNA, MASK_LNA_ZIN);
+	case fiftyOhm:
+		return rf69_clear_bit(spi, REG_LNA, MASK_LNA_ZIN);
+	case twohundretOhm:
+		return rf69_set_bit(spi, REG_LNA, MASK_LNA_ZIN);
 	default:
 		dev_dbg(&spi->dev, "set: illegal input param");
 		return -EINVAL;
@@ -367,13 +402,20 @@ int rf69_set_antenna_impedance(struct spi_device *spi, enum antennaImpedance ant
 int rf69_set_lna_gain(struct spi_device *spi, enum lnaGain lnaGain)
 {
 	switch (lnaGain) {
-	case automatic:	   return rf69_read_mod_write(spi, REG_LNA, MASK_LNA_GAIN, LNA_GAIN_AUTO);
-	case max:	   return rf69_read_mod_write(spi, REG_LNA, MASK_LNA_GAIN, LNA_GAIN_MAX);
-	case max_minus_6:  return rf69_read_mod_write(spi, REG_LNA, MASK_LNA_GAIN, LNA_GAIN_MAX_MINUS_6);
-	case max_minus_12: return rf69_read_mod_write(spi, REG_LNA, MASK_LNA_GAIN, LNA_GAIN_MAX_MINUS_12);
-	case max_minus_24: return rf69_read_mod_write(spi, REG_LNA, MASK_LNA_GAIN, LNA_GAIN_MAX_MINUS_24);
-	case max_minus_36: return rf69_read_mod_write(spi, REG_LNA, MASK_LNA_GAIN, LNA_GAIN_MAX_MINUS_36);
-	case max_minus_48: return rf69_read_mod_write(spi, REG_LNA, MASK_LNA_GAIN, LNA_GAIN_MAX_MINUS_48);
+	case automatic:
+		return rf69_read_mod_write(spi, REG_LNA, MASK_LNA_GAIN, LNA_GAIN_AUTO);
+	case max:
+		return rf69_read_mod_write(spi, REG_LNA, MASK_LNA_GAIN, LNA_GAIN_MAX);
+	case max_minus_6:
+		return rf69_read_mod_write(spi, REG_LNA, MASK_LNA_GAIN, LNA_GAIN_MAX_MINUS_6);
+	case max_minus_12:
+		return rf69_read_mod_write(spi, REG_LNA, MASK_LNA_GAIN, LNA_GAIN_MAX_MINUS_12);
+	case max_minus_24:
+		return rf69_read_mod_write(spi, REG_LNA, MASK_LNA_GAIN, LNA_GAIN_MAX_MINUS_24);
+	case max_minus_36:
+		return rf69_read_mod_write(spi, REG_LNA, MASK_LNA_GAIN, LNA_GAIN_MAX_MINUS_36);
+	case max_minus_48:
+		return rf69_read_mod_write(spi, REG_LNA, MASK_LNA_GAIN, LNA_GAIN_MAX_MINUS_48);
 	default:
 		dev_dbg(&spi->dev, "set: illegal input param");
 		return -EINVAL;
@@ -437,14 +479,22 @@ int rf69_set_bandwidth_during_afc(struct spi_device *spi, enum mantisse mantisse
 int rf69_set_ook_threshold_dec(struct spi_device *spi, enum thresholdDecrement thresholdDecrement)
 {
 	switch (thresholdDecrement) {
-	case dec_every8th: return rf69_read_mod_write(spi, REG_OOKPEAK, MASK_OOKPEAK_THRESDEC, OOKPEAK_THRESHDEC_EVERY_8TH);
-	case dec_every4th: return rf69_read_mod_write(spi, REG_OOKPEAK, MASK_OOKPEAK_THRESDEC, OOKPEAK_THRESHDEC_EVERY_4TH);
-	case dec_every2nd: return rf69_read_mod_write(spi, REG_OOKPEAK, MASK_OOKPEAK_THRESDEC, OOKPEAK_THRESHDEC_EVERY_2ND);
-	case dec_once:	   return rf69_read_mod_write(spi, REG_OOKPEAK, MASK_OOKPEAK_THRESDEC, OOKPEAK_THRESHDEC_ONCE);
-	case dec_twice:	   return rf69_read_mod_write(spi, REG_OOKPEAK, MASK_OOKPEAK_THRESDEC, OOKPEAK_THRESHDEC_TWICE);
-	case dec_4times:   return rf69_read_mod_write(spi, REG_OOKPEAK, MASK_OOKPEAK_THRESDEC, OOKPEAK_THRESHDEC_4_TIMES);
-	case dec_8times:   return rf69_read_mod_write(spi, REG_OOKPEAK, MASK_OOKPEAK_THRESDEC, OOKPEAK_THRESHDEC_8_TIMES);
-	case dec_16times:  return rf69_read_mod_write(spi, REG_OOKPEAK, MASK_OOKPEAK_THRESDEC, OOKPEAK_THRESHDEC_16_TIMES);
+	case dec_every8th:
+		return rf69_read_mod_write(spi, REG_OOKPEAK, MASK_OOKPEAK_THRESDEC, OOKPEAK_THRESHDEC_EVERY_8TH);
+	case dec_every4th:
+		return rf69_read_mod_write(spi, REG_OOKPEAK, MASK_OOKPEAK_THRESDEC, OOKPEAK_THRESHDEC_EVERY_4TH);
+	case dec_every2nd:
+		return rf69_read_mod_write(spi, REG_OOKPEAK, MASK_OOKPEAK_THRESDEC, OOKPEAK_THRESHDEC_EVERY_2ND);
+	case dec_once:
+		return rf69_read_mod_write(spi, REG_OOKPEAK, MASK_OOKPEAK_THRESDEC, OOKPEAK_THRESHDEC_ONCE);
+	case dec_twice:
+		return rf69_read_mod_write(spi, REG_OOKPEAK, MASK_OOKPEAK_THRESDEC, OOKPEAK_THRESHDEC_TWICE);
+	case dec_4times:
+		return rf69_read_mod_write(spi, REG_OOKPEAK, MASK_OOKPEAK_THRESDEC, OOKPEAK_THRESHDEC_4_TIMES);
+	case dec_8times:
+		return rf69_read_mod_write(spi, REG_OOKPEAK, MASK_OOKPEAK_THRESDEC, OOKPEAK_THRESHDEC_8_TIMES);
+	case dec_16times:
+		return rf69_read_mod_write(spi, REG_OOKPEAK, MASK_OOKPEAK_THRESDEC, OOKPEAK_THRESHDEC_16_TIMES);
 	default:
 		dev_dbg(&spi->dev, "set: illegal input param");
 		return -EINVAL;
@@ -495,23 +545,40 @@ int rf69_set_dio_mapping(struct spi_device *spi, u8 DIONumber, u8 value)
 bool rf69_get_flag(struct spi_device *spi, enum flag flag)
 {
 	switch (flag) {
-	case modeSwitchCompleted:	 return (rf69_read_reg(spi, REG_IRQFLAGS1) & MASK_IRQFLAGS1_MODE_READY);
-	case readyToReceive:		 return (rf69_read_reg(spi, REG_IRQFLAGS1) & MASK_IRQFLAGS1_RX_READY);
-	case readyToSend:		 return (rf69_read_reg(spi, REG_IRQFLAGS1) & MASK_IRQFLAGS1_TX_READY);
-	case pllLocked:			 return (rf69_read_reg(spi, REG_IRQFLAGS1) & MASK_IRQFLAGS1_PLL_LOCK);
-	case rssiExceededThreshold:	 return (rf69_read_reg(spi, REG_IRQFLAGS1) & MASK_IRQFLAGS1_RSSI);
-	case timeout:			 return (rf69_read_reg(spi, REG_IRQFLAGS1) & MASK_IRQFLAGS1_TIMEOUT);
-	case automode:			 return (rf69_read_reg(spi, REG_IRQFLAGS1) & MASK_IRQFLAGS1_AUTOMODE);
-	case syncAddressMatch:		 return (rf69_read_reg(spi, REG_IRQFLAGS1) & MASK_IRQFLAGS1_SYNC_ADDRESS_MATCH);
-	case fifo_full:			 return (rf69_read_reg(spi, REG_IRQFLAGS2) & MASK_IRQFLAGS2_FIFO_FULL);
-/*	case fifo_not_empty:		 return (rf69_read_reg(spi, REG_IRQFLAGS2) & MASK_IRQFLAGS2_FIFO_NOT_EMPTY); */
-	case fifo_empty:		 return !(rf69_read_reg(spi, REG_IRQFLAGS2) & MASK_IRQFLAGS2_FIFO_NOT_EMPTY);
-	case fifo_level_below_threshold: return (rf69_read_reg(spi, REG_IRQFLAGS2) & MASK_IRQFLAGS2_FIFO_LEVEL);
-	case fifo_overrun:		 return (rf69_read_reg(spi, REG_IRQFLAGS2) & MASK_IRQFLAGS2_FIFO_OVERRUN);
-	case packetSent:		 return (rf69_read_reg(spi, REG_IRQFLAGS2) & MASK_IRQFLAGS2_PACKET_SENT);
-	case payload_ready:		 return (rf69_read_reg(spi, REG_IRQFLAGS2) & MASK_IRQFLAGS2_PAYLOAD_READY);
-	case crcOk:			 return (rf69_read_reg(spi, REG_IRQFLAGS2) & MASK_IRQFLAGS2_CRC_OK);
-	case batteryLow:		 return (rf69_read_reg(spi, REG_IRQFLAGS2) & MASK_IRQFLAGS2_LOW_BAT);
+	case modeSwitchCompleted:
+		return (rf69_read_reg(spi, REG_IRQFLAGS1) & MASK_IRQFLAGS1_MODE_READY);
+	case readyToReceive:
+		return (rf69_read_reg(spi, REG_IRQFLAGS1) & MASK_IRQFLAGS1_RX_READY);
+	case readyToSend:
+		return (rf69_read_reg(spi, REG_IRQFLAGS1) & MASK_IRQFLAGS1_TX_READY);
+	case pllLocked:
+		return (rf69_read_reg(spi, REG_IRQFLAGS1) & MASK_IRQFLAGS1_PLL_LOCK);
+	case rssiExceededThreshold:
+		return (rf69_read_reg(spi, REG_IRQFLAGS1) & MASK_IRQFLAGS1_RSSI);
+	case timeout:
+		return (rf69_read_reg(spi, REG_IRQFLAGS1) & MASK_IRQFLAGS1_TIMEOUT);
+	case automode:
+		return (rf69_read_reg(spi, REG_IRQFLAGS1) & MASK_IRQFLAGS1_AUTOMODE);
+	case syncAddressMatch:
+		return (rf69_read_reg(spi, REG_IRQFLAGS1) & MASK_IRQFLAGS1_SYNC_ADDRESS_MATCH);
+	case fifo_full:
+		return (rf69_read_reg(spi, REG_IRQFLAGS2) & MASK_IRQFLAGS2_FIFO_FULL);
+/*	case fifo_not_empty:
+ *		return (rf69_read_reg(spi, REG_IRQFLAGS2) & MASK_IRQFLAGS2_FIFO_NOT_EMPTY); */
+	case fifo_empty:
+		return !(rf69_read_reg(spi, REG_IRQFLAGS2) & MASK_IRQFLAGS2_FIFO_NOT_EMPTY);
+	case fifo_level_below_threshold:
+		return (rf69_read_reg(spi, REG_IRQFLAGS2) & MASK_IRQFLAGS2_FIFO_LEVEL);
+	case fifo_overrun:
+		return (rf69_read_reg(spi, REG_IRQFLAGS2) & MASK_IRQFLAGS2_FIFO_OVERRUN);
+	case packetSent:
+		return (rf69_read_reg(spi, REG_IRQFLAGS2) & MASK_IRQFLAGS2_PACKET_SENT);
+	case payload_ready:
+		return (rf69_read_reg(spi, REG_IRQFLAGS2) & MASK_IRQFLAGS2_PAYLOAD_READY);
+	case crcOk:
+		return (rf69_read_reg(spi, REG_IRQFLAGS2) & MASK_IRQFLAGS2_CRC_OK);
+	case batteryLow:
+		return (rf69_read_reg(spi, REG_IRQFLAGS2) & MASK_IRQFLAGS2_LOW_BAT);
 	default:			 return false;
 	}
 }
@@ -556,8 +623,10 @@ int rf69_disable_sync(struct spi_device *spi)
 int rf69_set_fifo_fill_condition(struct spi_device *spi, enum fifo_fill_condition fifo_fill_condition)
 {
 	switch (fifo_fill_condition) {
-	case always:		 return rf69_set_bit(spi, REG_SYNC_CONFIG, MASK_SYNC_CONFIG_FIFO_FILL_CONDITION);
-	case afterSyncInterrupt: return rf69_clear_bit(spi, REG_SYNC_CONFIG, MASK_SYNC_CONFIG_FIFO_FILL_CONDITION);
+	case always:
+		return rf69_set_bit(spi, REG_SYNC_CONFIG, MASK_SYNC_CONFIG_FIFO_FILL_CONDITION);
+	case afterSyncInterrupt:
+		return rf69_clear_bit(spi, REG_SYNC_CONFIG, MASK_SYNC_CONFIG_FIFO_FILL_CONDITION);
 	default:
 		dev_dbg(&spi->dev, "set: illegal input param");
 		return -EINVAL;
@@ -595,8 +664,10 @@ int rf69_set_sync_values(struct spi_device *spi, u8 syncValues[8])
 int rf69_set_packet_format(struct spi_device *spi, enum packetFormat packetFormat)
 {
 	switch (packetFormat) {
-	case packetLengthVar: return rf69_set_bit(spi, REG_PACKETCONFIG1, MASK_PACKETCONFIG1_PAKET_FORMAT_VARIABLE);
-	case packetLengthFix: return rf69_clear_bit(spi, REG_PACKETCONFIG1, MASK_PACKETCONFIG1_PAKET_FORMAT_VARIABLE);
+	case packetLengthVar:
+		return rf69_set_bit(spi, REG_PACKETCONFIG1, MASK_PACKETCONFIG1_PAKET_FORMAT_VARIABLE);
+	case packetLengthFix:
+		return rf69_clear_bit(spi, REG_PACKETCONFIG1, MASK_PACKETCONFIG1_PAKET_FORMAT_VARIABLE);
 	default:
 		dev_dbg(&spi->dev, "set: illegal input param");
 		return -EINVAL;
@@ -616,9 +687,12 @@ int rf69_disable_crc(struct spi_device *spi)
 int rf69_set_adressFiltering(struct spi_device *spi, enum addressFiltering addressFiltering)
 {
 	switch (addressFiltering) {
-	case filteringOff:	     return rf69_read_mod_write(spi, REG_PACKETCONFIG1, MASK_PACKETCONFIG1_ADDRESSFILTERING, PACKETCONFIG1_ADDRESSFILTERING_OFF);
-	case nodeAddress:	     return rf69_read_mod_write(spi, REG_PACKETCONFIG1, MASK_PACKETCONFIG1_ADDRESSFILTERING, PACKETCONFIG1_ADDRESSFILTERING_NODE);
-	case nodeOrBroadcastAddress: return rf69_read_mod_write(spi, REG_PACKETCONFIG1, MASK_PACKETCONFIG1_ADDRESSFILTERING, PACKETCONFIG1_ADDRESSFILTERING_NODEBROADCAST);
+	case filteringOff:
+		return rf69_read_mod_write(spi, REG_PACKETCONFIG1, MASK_PACKETCONFIG1_ADDRESSFILTERING, PACKETCONFIG1_ADDRESSFILTERING_OFF);
+	case nodeAddress:
+		return rf69_read_mod_write(spi, REG_PACKETCONFIG1, MASK_PACKETCONFIG1_ADDRESSFILTERING, PACKETCONFIG1_ADDRESSFILTERING_NODE);
+	case nodeOrBroadcastAddress:
+		return rf69_read_mod_write(spi, REG_PACKETCONFIG1, MASK_PACKETCONFIG1_ADDRESSFILTERING, PACKETCONFIG1_ADDRESSFILTERING_NODEBROADCAST);
 	default:
 		dev_dbg(&spi->dev, "set: illegal input param");
 		return -EINVAL;
@@ -643,8 +717,10 @@ int rf69_set_broadcast_address(struct spi_device *spi, u8 broadcastAddress)
 int rf69_set_tx_start_condition(struct spi_device *spi, enum txStartCondition txStartCondition)
 {
 	switch (txStartCondition) {
-	case fifo_level:	return rf69_clear_bit(spi, REG_FIFO_THRESH, MASK_FIFO_THRESH_TXSTART);
-	case fifo_not_empty:	return rf69_set_bit(spi, REG_FIFO_THRESH, MASK_FIFO_THRESH_TXSTART);
+	case fifo_level:
+		return rf69_clear_bit(spi, REG_FIFO_THRESH, MASK_FIFO_THRESH_TXSTART);
+	case fifo_not_empty:
+		return rf69_set_bit(spi, REG_FIFO_THRESH, MASK_FIFO_THRESH_TXSTART);
 	default:
 		dev_dbg(&spi->dev, "set: illegal input param");
 		return -EINVAL;
@@ -675,9 +751,12 @@ int rf69_set_fifo_threshold(struct spi_device *spi, u8 threshold)
 int rf69_set_dagc(struct spi_device *spi, enum dagc dagc)
 {
 	switch (dagc) {
-	case normalMode:		 return rf69_write_reg(spi, REG_TESTDAGC, DAGC_NORMAL);
-	case improve:			 return rf69_write_reg(spi, REG_TESTDAGC, DAGC_IMPROVED_LOWBETA0);
-	case improve4LowModulationIndex: return rf69_write_reg(spi, REG_TESTDAGC, DAGC_IMPROVED_LOWBETA1);
+	case normalMode:
+		return rf69_write_reg(spi, REG_TESTDAGC, DAGC_NORMAL);
+	case improve:
+		return rf69_write_reg(spi, REG_TESTDAGC, DAGC_IMPROVED_LOWBETA0);
+	case improve4LowModulationIndex:
+		return rf69_write_reg(spi, REG_TESTDAGC, DAGC_IMPROVED_LOWBETA1);
 	default:
 		dev_dbg(&spi->dev, "set: illegal input param");
 		return -EINVAL;

commit 0b9acf7ddb444c1009d549ba3864059f31e2f480
Author: Valentin Vidic <Valentin.Vidic@CARNet.hr>
Date:   Mon Dec 25 19:20:56 2017 +0100

    staging: pi433: fix CamelCase for payload identifiers
    
    Fixes checkpatch warnings:
    
      CHECK: Avoid CamelCase: <payloadLength>
      CHECK: Avoid CamelCase: <payloadReady>
    
    Signed-off-by: Valentin Vidic <Valentin.Vidic@CARNet.hr>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/pi433/rf69.c b/drivers/staging/pi433/rf69.c
index c214b4a159f2..bdd00f750765 100644
--- a/drivers/staging/pi433/rf69.c
+++ b/drivers/staging/pi433/rf69.c
@@ -509,7 +509,7 @@ bool rf69_get_flag(struct spi_device *spi, enum flag flag)
 	case fifo_level_below_threshold: return (rf69_read_reg(spi, REG_IRQFLAGS2) & MASK_IRQFLAGS2_FIFO_LEVEL);
 	case fifo_overrun:		 return (rf69_read_reg(spi, REG_IRQFLAGS2) & MASK_IRQFLAGS2_FIFO_OVERRUN);
 	case packetSent:		 return (rf69_read_reg(spi, REG_IRQFLAGS2) & MASK_IRQFLAGS2_PACKET_SENT);
-	case payloadReady:		 return (rf69_read_reg(spi, REG_IRQFLAGS2) & MASK_IRQFLAGS2_PAYLOAD_READY);
+	case payload_ready:		 return (rf69_read_reg(spi, REG_IRQFLAGS2) & MASK_IRQFLAGS2_PAYLOAD_READY);
 	case crcOk:			 return (rf69_read_reg(spi, REG_IRQFLAGS2) & MASK_IRQFLAGS2_CRC_OK);
 	case batteryLow:		 return (rf69_read_reg(spi, REG_IRQFLAGS2) & MASK_IRQFLAGS2_LOW_BAT);
 	default:			 return false;
@@ -625,9 +625,9 @@ int rf69_set_adressFiltering(struct spi_device *spi, enum addressFiltering addre
 	}
 }
 
-int rf69_set_payload_length(struct spi_device *spi, u8 payloadLength)
+int rf69_set_payload_length(struct spi_device *spi, u8 payload_length)
 {
-	return rf69_write_reg(spi, REG_PAYLOAD_LENGTH, payloadLength);
+	return rf69_write_reg(spi, REG_PAYLOAD_LENGTH, payload_length);
 }
 
 int rf69_set_node_address(struct spi_device *spi, u8 nodeAddress)

commit b167a524d218904e4cdfa73d696973158e160b43
Author: Valentin Vidic <Valentin.Vidic@CARNet.hr>
Date:   Fri Dec 22 09:36:59 2017 +0100

    staging: pi433: fix CamelCase for maxMinus variables
    
    Fixes checkpatch warnings:
    
      CHECK: Avoid CamelCase: <maxMinus12>
      CHECK: Avoid CamelCase: <maxMinus24>
      CHECK: Avoid CamelCase: <maxMinus36>
      CHECK: Avoid CamelCase: <maxMinus48>
      CHECK: Avoid CamelCase: <maxMinus6>
    
    Signed-off-by: Valentin Vidic <Valentin.Vidic@CARNet.hr>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/pi433/rf69.c b/drivers/staging/pi433/rf69.c
index 9ad358c30225..c214b4a159f2 100644
--- a/drivers/staging/pi433/rf69.c
+++ b/drivers/staging/pi433/rf69.c
@@ -367,13 +367,13 @@ int rf69_set_antenna_impedance(struct spi_device *spi, enum antennaImpedance ant
 int rf69_set_lna_gain(struct spi_device *spi, enum lnaGain lnaGain)
 {
 	switch (lnaGain) {
-	case automatic:	 return rf69_read_mod_write(spi, REG_LNA, MASK_LNA_GAIN, LNA_GAIN_AUTO);
-	case max:	 return rf69_read_mod_write(spi, REG_LNA, MASK_LNA_GAIN, LNA_GAIN_MAX);
-	case maxMinus6:  return rf69_read_mod_write(spi, REG_LNA, MASK_LNA_GAIN, LNA_GAIN_MAX_MINUS_6);
-	case maxMinus12: return rf69_read_mod_write(spi, REG_LNA, MASK_LNA_GAIN, LNA_GAIN_MAX_MINUS_12);
-	case maxMinus24: return rf69_read_mod_write(spi, REG_LNA, MASK_LNA_GAIN, LNA_GAIN_MAX_MINUS_24);
-	case maxMinus36: return rf69_read_mod_write(spi, REG_LNA, MASK_LNA_GAIN, LNA_GAIN_MAX_MINUS_36);
-	case maxMinus48: return rf69_read_mod_write(spi, REG_LNA, MASK_LNA_GAIN, LNA_GAIN_MAX_MINUS_48);
+	case automatic:	   return rf69_read_mod_write(spi, REG_LNA, MASK_LNA_GAIN, LNA_GAIN_AUTO);
+	case max:	   return rf69_read_mod_write(spi, REG_LNA, MASK_LNA_GAIN, LNA_GAIN_MAX);
+	case max_minus_6:  return rf69_read_mod_write(spi, REG_LNA, MASK_LNA_GAIN, LNA_GAIN_MAX_MINUS_6);
+	case max_minus_12: return rf69_read_mod_write(spi, REG_LNA, MASK_LNA_GAIN, LNA_GAIN_MAX_MINUS_12);
+	case max_minus_24: return rf69_read_mod_write(spi, REG_LNA, MASK_LNA_GAIN, LNA_GAIN_MAX_MINUS_24);
+	case max_minus_36: return rf69_read_mod_write(spi, REG_LNA, MASK_LNA_GAIN, LNA_GAIN_MAX_MINUS_36);
+	case max_minus_48: return rf69_read_mod_write(spi, REG_LNA, MASK_LNA_GAIN, LNA_GAIN_MAX_MINUS_48);
 	default:
 		dev_dbg(&spi->dev, "set: illegal input param");
 		return -EINVAL;

commit 7ebee24ba128c8dd63a859a5f639e5748f8688ac
Author: Marcin Ciupak <marcin.s.ciupak@gmail.com>
Date:   Thu Dec 21 21:39:41 2017 +0000

    staging: pi433: remove unused rf69_reset_flag function
    
    Function rf69_reset_flag is unused and should be removed.
    
    Signed-off-by: Marcin Ciupak <marcin.s.ciupak@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/pi433/rf69.c b/drivers/staging/pi433/rf69.c
index 7a64ef065a2e..9ad358c30225 100644
--- a/drivers/staging/pi433/rf69.c
+++ b/drivers/staging/pi433/rf69.c
@@ -516,18 +516,6 @@ bool rf69_get_flag(struct spi_device *spi, enum flag flag)
 	}
 }
 
-int rf69_reset_flag(struct spi_device *spi, enum flag flag)
-{
-	switch (flag) {
-	case rssiExceededThreshold: return rf69_write_reg(spi, REG_IRQFLAGS1, MASK_IRQFLAGS1_RSSI);
-	case syncAddressMatch:	    return rf69_write_reg(spi, REG_IRQFLAGS1, MASK_IRQFLAGS1_SYNC_ADDRESS_MATCH);
-	case fifo_overrun:	    return rf69_write_reg(spi, REG_IRQFLAGS2, MASK_IRQFLAGS2_FIFO_OVERRUN);
-	default:
-		dev_dbg(&spi->dev, "set: illegal input param");
-		return -EINVAL;
-	}
-}
-
 int rf69_set_rssi_threshold(struct spi_device *spi, u8 threshold)
 {
 	/* no value check needed - u8 exactly matches register size */

commit 109fb18fccaa2aac4d005e402066f479f6a15a6b
Author: Marcin Ciupak <marcin.s.ciupak@gmail.com>
Date:   Thu Dec 21 21:39:12 2017 +0000

    staging: pi433: remove unused rf69_set_sync_tolerance function
    
    Function rf69_set_sync_tolerance is unused and should be removed.
    
    Signed-off-by: Marcin Ciupak <marcin.s.ciupak@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/pi433/rf69.c b/drivers/staging/pi433/rf69.c
index 8bc09e10a582..7a64ef065a2e 100644
--- a/drivers/staging/pi433/rf69.c
+++ b/drivers/staging/pi433/rf69.c
@@ -588,18 +588,6 @@ int rf69_set_sync_size(struct spi_device *spi, u8 syncSize)
 	return rf69_read_mod_write(spi, REG_SYNC_CONFIG, MASK_SYNC_CONFIG_SYNC_SIZE, (syncSize << 3));
 }
 
-int rf69_set_sync_tolerance(struct spi_device *spi, u8 syncTolerance)
-{
-	// check input value
-	if (syncTolerance > 0x07) {
-		dev_dbg(&spi->dev, "set: illegal input param");
-		return -EINVAL;
-	}
-
-	// write value
-	return rf69_read_mod_write(spi, REG_SYNC_CONFIG, MASK_SYNC_CONFIG_SYNC_SIZE, syncTolerance);
-}
-
 int rf69_set_sync_values(struct spi_device *spi, u8 syncValues[8])
 {
 	int retval = 0;

commit f235bcfe6a0b678c16517142d906652a7befed73
Author: Marcin Ciupak <marcin.s.ciupak@gmail.com>
Date:   Wed Dec 20 16:18:29 2017 +0000

    staging: pi433: remove unused rf69_set_dc_cut_off_frequency* functions
    
    The following functions:
    * rf69_set_dc_cut_off_frequency,
    * rf69_set_dc_cut_off_frequency_intern,
    * rf69_set_dc_cut_off_frequency_during_afc
    are unused and should be removed along with type enum dcc_percent which
    was used only by these functions.
    
    Signed-off-by: Marcin Ciupak <marcin.s.ciupak@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/pi433/rf69.c b/drivers/staging/pi433/rf69.c
index eb84257b51a9..8bc09e10a582 100644
--- a/drivers/staging/pi433/rf69.c
+++ b/drivers/staging/pi433/rf69.c
@@ -380,33 +380,6 @@ int rf69_set_lna_gain(struct spi_device *spi, enum lnaGain lnaGain)
 	}
 }
 
-int rf69_set_dc_cut_off_frequency_intern(struct spi_device *spi, u8 reg, enum dcc_percent dcc_percent)
-{
-	switch (dcc_percent) {
-	case dcc_16_percent:	return rf69_read_mod_write(spi, reg, MASK_BW_DCC_FREQ, BW_DCC_16_PERCENT);
-	case dcc_8_percent:	return rf69_read_mod_write(spi, reg, MASK_BW_DCC_FREQ, BW_DCC_8_PERCENT);
-	case dcc_4_percent:	return rf69_read_mod_write(spi, reg, MASK_BW_DCC_FREQ, BW_DCC_4_PERCENT);
-	case dcc_2_percent:	return rf69_read_mod_write(spi, reg, MASK_BW_DCC_FREQ, BW_DCC_2_PERCENT);
-	case dcc_1_percent:	return rf69_read_mod_write(spi, reg, MASK_BW_DCC_FREQ, BW_DCC_1_PERCENT);
-	case dcc_0_5_percent:	return rf69_read_mod_write(spi, reg, MASK_BW_DCC_FREQ, BW_DCC_0_5_PERCENT);
-	case dcc_0_25_percent:	return rf69_read_mod_write(spi, reg, MASK_BW_DCC_FREQ, BW_DCC_0_25_PERCENT);
-	case dcc_0_125_percent:	return rf69_read_mod_write(spi, reg, MASK_BW_DCC_FREQ, BW_DCC_0_125_PERCENT);
-	default:
-		dev_dbg(&spi->dev, "set: illegal input param");
-		return -EINVAL;
-	}
-}
-
-int rf69_set_dc_cut_off_frequency(struct spi_device *spi, enum dcc_percent dcc_percent)
-{
-	return rf69_set_dc_cut_off_frequency_intern(spi, REG_RXBW, dcc_percent);
-}
-
-int rf69_set_dc_cut_off_frequency_during_afc(struct spi_device *spi, enum dcc_percent dcc_percent)
-{
-	return rf69_set_dc_cut_off_frequency_intern(spi, REG_AFCBW, dcc_percent);
-}
-
 static int rf69_set_bandwidth_intern(struct spi_device *spi, u8 reg,
 				     enum mantisse mantisse, u8 exponent)
 {

commit 9924a8339f09bee5f9365cb7b77849e0885b03ab
Author: Marcin Ciupak <marcin.s.ciupak@gmail.com>
Date:   Wed Dec 20 16:17:27 2017 +0000

    staging: pi433: remove unused rf69_set_ook_threshold_type function
    
    Function rf69_set_ook_threshold_type is unused and should be removed
    along with type enum thresholdType which was used only by that function.
    
    Signed-off-by: Marcin Ciupak <marcin.s.ciupak@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/pi433/rf69.c b/drivers/staging/pi433/rf69.c
index dcc73c8a74cf..eb84257b51a9 100644
--- a/drivers/staging/pi433/rf69.c
+++ b/drivers/staging/pi433/rf69.c
@@ -461,18 +461,6 @@ int rf69_set_bandwidth_during_afc(struct spi_device *spi, enum mantisse mantisse
 	return rf69_set_bandwidth_intern(spi, REG_AFCBW, mantisse, exponent);
 }
 
-int rf69_set_ook_threshold_type(struct spi_device *spi, enum thresholdType thresholdType)
-{
-	switch (thresholdType) {
-	case fixed:	return rf69_read_mod_write(spi, REG_OOKPEAK, MASK_OOKPEAK_THRESTYPE, OOKPEAK_THRESHTYPE_FIXED);
-	case peak:	return rf69_read_mod_write(spi, REG_OOKPEAK, MASK_OOKPEAK_THRESTYPE, OOKPEAK_THRESHTYPE_PEAK);
-	case average:	return rf69_read_mod_write(spi, REG_OOKPEAK, MASK_OOKPEAK_THRESTYPE, OOKPEAK_THRESHTYPE_AVERAGE);
-	default:
-		dev_dbg(&spi->dev, "set: illegal input param");
-		return -EINVAL;
-	}
-}
-
 int rf69_set_ook_threshold_dec(struct spi_device *spi, enum thresholdDecrement thresholdDecrement)
 {
 	switch (thresholdDecrement) {

commit 418e175a99b376d0bebd12e83c40b7017c61333d
Author: Marcin Ciupak <marcin.s.ciupak@gmail.com>
Date:   Wed Dec 20 16:17:02 2017 +0000

    staging: pi433: remove unused rf69_set_ook_threshold_step function
    
    Function rf69_set_ook_threshold_step is unused and should be removed
    along with type enum thresholdStep which was used only by that function.
    
    Signed-off-by: Marcin Ciupak <marcin.s.ciupak@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/pi433/rf69.c b/drivers/staging/pi433/rf69.c
index 94a5c2553b91..dcc73c8a74cf 100644
--- a/drivers/staging/pi433/rf69.c
+++ b/drivers/staging/pi433/rf69.c
@@ -473,23 +473,6 @@ int rf69_set_ook_threshold_type(struct spi_device *spi, enum thresholdType thres
 	}
 }
 
-int rf69_set_ook_threshold_step(struct spi_device *spi, enum thresholdStep thresholdStep)
-{
-	switch (thresholdStep) {
-	case step_0_5db: return rf69_read_mod_write(spi, REG_OOKPEAK, MASK_OOKPEAK_THRESSTEP, OOKPEAK_THRESHSTEP_0_5_DB);
-	case step_1_0db: return rf69_read_mod_write(spi, REG_OOKPEAK, MASK_OOKPEAK_THRESSTEP, OOKPEAK_THRESHSTEP_1_0_DB);
-	case step_1_5db: return rf69_read_mod_write(spi, REG_OOKPEAK, MASK_OOKPEAK_THRESSTEP, OOKPEAK_THRESHSTEP_1_5_DB);
-	case step_2_0db: return rf69_read_mod_write(spi, REG_OOKPEAK, MASK_OOKPEAK_THRESSTEP, OOKPEAK_THRESHSTEP_2_0_DB);
-	case step_3_0db: return rf69_read_mod_write(spi, REG_OOKPEAK, MASK_OOKPEAK_THRESSTEP, OOKPEAK_THRESHSTEP_3_0_DB);
-	case step_4_0db: return rf69_read_mod_write(spi, REG_OOKPEAK, MASK_OOKPEAK_THRESSTEP, OOKPEAK_THRESHSTEP_4_0_DB);
-	case step_5_0db: return rf69_read_mod_write(spi, REG_OOKPEAK, MASK_OOKPEAK_THRESSTEP, OOKPEAK_THRESHSTEP_5_0_DB);
-	case step_6_0db: return rf69_read_mod_write(spi, REG_OOKPEAK, MASK_OOKPEAK_THRESSTEP, OOKPEAK_THRESHSTEP_6_0_DB);
-	default:
-		dev_dbg(&spi->dev, "set: illegal input param");
-		return -EINVAL;
-	}
-}
-
 int rf69_set_ook_threshold_dec(struct spi_device *spi, enum thresholdDecrement thresholdDecrement)
 {
 	switch (thresholdDecrement) {

commit b44badd30bf9a7a53f78a662e5a0bd52bc9106bb
Author: Marcin Ciupak <marcin.s.ciupak@gmail.com>
Date:   Wed Dec 20 16:15:49 2017 +0000

    staging: pi433: remove unused rf69_set_rx_start_timeout function
    
    Function rf69_set_rx_start_timeout is unused and should be removed.
    
    Signed-off-by: Marcin Ciupak <marcin.s.ciupak@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/pi433/rf69.c b/drivers/staging/pi433/rf69.c
index c5af4650db71..94a5c2553b91 100644
--- a/drivers/staging/pi433/rf69.c
+++ b/drivers/staging/pi433/rf69.c
@@ -591,13 +591,6 @@ int rf69_set_rssi_threshold(struct spi_device *spi, u8 threshold)
 	return rf69_write_reg(spi, REG_RSSITHRESH, threshold);
 }
 
-int rf69_set_rx_start_timeout(struct spi_device *spi, u8 timeout)
-{
-	/* no value check needed - u8 exactly matches register size */
-
-	return rf69_write_reg(spi, REG_RXTIMEOUT1, timeout);
-}
-
 int rf69_set_preamble_length(struct spi_device *spi, u16 preambleLength)
 {
 	int retval;

commit 68701fb146b32a1b1d70af68deb800c1a76fe0b1
Author: Marcin Ciupak <marcin.s.ciupak@gmail.com>
Date:   Wed Dec 20 16:15:10 2017 +0000

    staging: pi433: remove unused rf69_set_rssi_timeout function
    
    Function rf69_set_rssi_timeout is unused and should be removed.
    
    Signed-off-by: Marcin Ciupak <marcin.s.ciupak@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/pi433/rf69.c b/drivers/staging/pi433/rf69.c
index 0d715091aa9f..c5af4650db71 100644
--- a/drivers/staging/pi433/rf69.c
+++ b/drivers/staging/pi433/rf69.c
@@ -598,13 +598,6 @@ int rf69_set_rx_start_timeout(struct spi_device *spi, u8 timeout)
 	return rf69_write_reg(spi, REG_RXTIMEOUT1, timeout);
 }
 
-int rf69_set_rssi_timeout(struct spi_device *spi, u8 timeout)
-{
-	/* no value check needed - u8 exactly matches register size */
-
-	return rf69_write_reg(spi, REG_RXTIMEOUT2, timeout);
-}
-
 int rf69_set_preamble_length(struct spi_device *spi, u16 preambleLength)
 {
 	int retval;

commit 68a87a9a23975e977040d397e6035cf4a0baa362
Author: Marcin Ciupak <marcin.s.ciupak@gmail.com>
Date:   Wed Dec 20 16:14:14 2017 +0000

    staging: pi433: remove unused rf69_get_payload_length function
    
    Function rf69_get_payload_length is unused and should be removed.
    
    Signed-off-by: Marcin Ciupak <marcin.s.ciupak@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/pi433/rf69.c b/drivers/staging/pi433/rf69.c
index 61d7dfd7c873..0d715091aa9f 100644
--- a/drivers/staging/pi433/rf69.c
+++ b/drivers/staging/pi433/rf69.c
@@ -724,11 +724,6 @@ int rf69_set_payload_length(struct spi_device *spi, u8 payloadLength)
 	return rf69_write_reg(spi, REG_PAYLOAD_LENGTH, payloadLength);
 }
 
-u8  rf69_get_payload_length(struct spi_device *spi)
-{
-	return (u8)rf69_read_reg(spi, REG_PAYLOAD_LENGTH);
-}
-
 int rf69_set_node_address(struct spi_device *spi, u8 nodeAddress)
 {
 	return rf69_write_reg(spi, REG_NODEADRS, nodeAddress);

commit db1bad5235e4e5300155b80fae19a4290a853f1e
Author: Marcin Ciupak <marcin.s.ciupak@gmail.com>
Date:   Wed Dec 20 16:13:52 2017 +0000

    staging: pi433: make local functions static
    
    Following functions:
    * rf69_get_modulation
    * rf69_read_reg
    * rf69_write_reg
    are used locally only and should be declared as static
    
    Signed-off-by: Marcin Ciupak <marcin.s.ciupak@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/pi433/rf69.c b/drivers/staging/pi433/rf69.c
index 2d3c6ab0a12a..61d7dfd7c873 100644
--- a/drivers/staging/pi433/rf69.c
+++ b/drivers/staging/pi433/rf69.c
@@ -33,6 +33,52 @@
 
 /*-------------------------------------------------------------------------*/
 
+static u8 rf69_read_reg(struct spi_device *spi, u8 addr)
+{
+	int retval;
+
+	retval = spi_w8r8(spi, addr);
+
+#ifdef DEBUG_VALUES
+	if (retval < 0)
+		/* should never happen, since we already checked,
+		 * that module is connected. Therefore no error
+		 * handling, just an optional error message...
+		 */
+		dev_dbg(&spi->dev, "read 0x%x FAILED\n", addr);
+	else
+		dev_dbg(&spi->dev, "read 0x%x from reg 0x%x\n", retval, addr);
+#endif
+
+	return retval;
+}
+
+static int rf69_write_reg(struct spi_device *spi, u8 addr, u8 value)
+{
+	int retval;
+	char buffer[2];
+
+	buffer[0] = addr | WRITE_BIT;
+	buffer[1] = value;
+
+	retval = spi_write(spi, &buffer, 2);
+
+#ifdef DEBUG_VALUES
+	if (retval < 0)
+		/* should never happen, since we already checked,
+		 * that module is connected. Therefore no error
+		 * handling, just an optional error message...
+		 */
+		dev_dbg(&spi->dev, "write 0x%x to 0x%x FAILED\n", value, addr);
+	else
+		dev_dbg(&spi->dev, "wrote 0x%x to reg 0x%x\n", value, addr);
+#endif
+
+	return retval;
+}
+
+/*-------------------------------------------------------------------------*/
+
 static int rf69_set_bit(struct spi_device *spi, u8 reg, u8 mask)
 {
 	u8 tmp;
@@ -96,7 +142,7 @@ int rf69_set_modulation(struct spi_device *spi, enum modulation modulation)
 	}
 }
 
-enum modulation rf69_get_modulation(struct spi_device *spi)
+static enum modulation rf69_get_modulation(struct spi_device *spi)
 {
 	u8 currentValue;
 
@@ -796,49 +842,3 @@ int rf69_write_fifo(struct spi_device *spi, u8 *buffer, unsigned int size)
 	return spi_write(spi, local_buffer, size + 1);
 }
 
-/*-------------------------------------------------------------------------*/
-
-u8 rf69_read_reg(struct spi_device *spi, u8 addr)
-{
-	int retval;
-
-	retval = spi_w8r8(spi, addr);
-
-#ifdef DEBUG_VALUES
-	if (retval < 0)
-		/* should never happen, since we already checked,
-		 * that module is connected. Therefore no error
-		 * handling, just an optional error message...
-		 */
-		dev_dbg(&spi->dev, "read 0x%x FAILED\n", addr);
-	else
-		dev_dbg(&spi->dev, "read 0x%x from reg 0x%x\n", retval, addr);
-#endif
-
-	return retval;
-}
-
-int rf69_write_reg(struct spi_device *spi, u8 addr, u8 value)
-{
-	int retval;
-	char buffer[2];
-
-	buffer[0] = addr | WRITE_BIT;
-	buffer[1] = value;
-
-	retval = spi_write(spi, &buffer, 2);
-
-#ifdef DEBUG_VALUES
-	if (retval < 0)
-		/* should never happen, since we already checked,
-		 * that module is connected. Therefore no error
-		 * handling, just an optional error message...
-		 */
-		dev_dbg(&spi->dev, "write 0x%x to 0x%x FAILED\n", value, addr);
-	else
-		dev_dbg(&spi->dev, "wrote 0x%x to reg 0x%x\n", value, addr);
-#endif
-
-	return retval;
-}
-

commit acf71f8dfc00fb254f85b0b9853d848a299028aa
Author: Valentin Vidic <Valentin.Vidic@CARNet.hr>
Date:   Tue Dec 19 17:02:22 2017 +0100

    staging: pi433: fix CamelCase for fifo variables
    
    Fixes checkpatch warnings:
    
      CHECK: Avoid CamelCase: <fifoEmpty>
      CHECK: Avoid CamelCase: <fifoFillCondition>
      CHECK: Avoid CamelCase: <fifoFull>
      CHECK: Avoid CamelCase: <fifoLevel>
      CHECK: Avoid CamelCase: <fifoLevelBelowThreshold>
      CHECK: Avoid CamelCase: <fifoNotEmpty>
      CHECK: Avoid CamelCase: <fifoOverrun>
    
    Signed-off-by: Valentin Vidic <Valentin.Vidic@CARNet.hr>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/pi433/rf69.c b/drivers/staging/pi433/rf69.c
index f58b925bb1da..2d3c6ab0a12a 100644
--- a/drivers/staging/pi433/rf69.c
+++ b/drivers/staging/pi433/rf69.c
@@ -505,24 +505,24 @@ int rf69_set_dio_mapping(struct spi_device *spi, u8 DIONumber, u8 value)
 bool rf69_get_flag(struct spi_device *spi, enum flag flag)
 {
 	switch (flag) {
-	case modeSwitchCompleted:     return (rf69_read_reg(spi, REG_IRQFLAGS1) & MASK_IRQFLAGS1_MODE_READY);
-	case readyToReceive:	      return (rf69_read_reg(spi, REG_IRQFLAGS1) & MASK_IRQFLAGS1_RX_READY);
-	case readyToSend:	      return (rf69_read_reg(spi, REG_IRQFLAGS1) & MASK_IRQFLAGS1_TX_READY);
-	case pllLocked:		      return (rf69_read_reg(spi, REG_IRQFLAGS1) & MASK_IRQFLAGS1_PLL_LOCK);
-	case rssiExceededThreshold:   return (rf69_read_reg(spi, REG_IRQFLAGS1) & MASK_IRQFLAGS1_RSSI);
-	case timeout:		      return (rf69_read_reg(spi, REG_IRQFLAGS1) & MASK_IRQFLAGS1_TIMEOUT);
-	case automode:		      return (rf69_read_reg(spi, REG_IRQFLAGS1) & MASK_IRQFLAGS1_AUTOMODE);
-	case syncAddressMatch:	      return (rf69_read_reg(spi, REG_IRQFLAGS1) & MASK_IRQFLAGS1_SYNC_ADDRESS_MATCH);
-	case fifoFull:		      return (rf69_read_reg(spi, REG_IRQFLAGS2) & MASK_IRQFLAGS2_FIFO_FULL);
-/*	case fifoNotEmpty:	      return (rf69_read_reg(spi, REG_IRQFLAGS2) & MASK_IRQFLAGS2_FIFO_NOT_EMPTY); */
-	case fifoEmpty:		      return !(rf69_read_reg(spi, REG_IRQFLAGS2) & MASK_IRQFLAGS2_FIFO_NOT_EMPTY);
-	case fifoLevelBelowThreshold: return (rf69_read_reg(spi, REG_IRQFLAGS2) & MASK_IRQFLAGS2_FIFO_LEVEL);
-	case fifoOverrun:	      return (rf69_read_reg(spi, REG_IRQFLAGS2) & MASK_IRQFLAGS2_FIFO_OVERRUN);
-	case packetSent:	      return (rf69_read_reg(spi, REG_IRQFLAGS2) & MASK_IRQFLAGS2_PACKET_SENT);
-	case payloadReady:	      return (rf69_read_reg(spi, REG_IRQFLAGS2) & MASK_IRQFLAGS2_PAYLOAD_READY);
-	case crcOk:		      return (rf69_read_reg(spi, REG_IRQFLAGS2) & MASK_IRQFLAGS2_CRC_OK);
-	case batteryLow:	      return (rf69_read_reg(spi, REG_IRQFLAGS2) & MASK_IRQFLAGS2_LOW_BAT);
-	default:		      return false;
+	case modeSwitchCompleted:	 return (rf69_read_reg(spi, REG_IRQFLAGS1) & MASK_IRQFLAGS1_MODE_READY);
+	case readyToReceive:		 return (rf69_read_reg(spi, REG_IRQFLAGS1) & MASK_IRQFLAGS1_RX_READY);
+	case readyToSend:		 return (rf69_read_reg(spi, REG_IRQFLAGS1) & MASK_IRQFLAGS1_TX_READY);
+	case pllLocked:			 return (rf69_read_reg(spi, REG_IRQFLAGS1) & MASK_IRQFLAGS1_PLL_LOCK);
+	case rssiExceededThreshold:	 return (rf69_read_reg(spi, REG_IRQFLAGS1) & MASK_IRQFLAGS1_RSSI);
+	case timeout:			 return (rf69_read_reg(spi, REG_IRQFLAGS1) & MASK_IRQFLAGS1_TIMEOUT);
+	case automode:			 return (rf69_read_reg(spi, REG_IRQFLAGS1) & MASK_IRQFLAGS1_AUTOMODE);
+	case syncAddressMatch:		 return (rf69_read_reg(spi, REG_IRQFLAGS1) & MASK_IRQFLAGS1_SYNC_ADDRESS_MATCH);
+	case fifo_full:			 return (rf69_read_reg(spi, REG_IRQFLAGS2) & MASK_IRQFLAGS2_FIFO_FULL);
+/*	case fifo_not_empty:		 return (rf69_read_reg(spi, REG_IRQFLAGS2) & MASK_IRQFLAGS2_FIFO_NOT_EMPTY); */
+	case fifo_empty:		 return !(rf69_read_reg(spi, REG_IRQFLAGS2) & MASK_IRQFLAGS2_FIFO_NOT_EMPTY);
+	case fifo_level_below_threshold: return (rf69_read_reg(spi, REG_IRQFLAGS2) & MASK_IRQFLAGS2_FIFO_LEVEL);
+	case fifo_overrun:		 return (rf69_read_reg(spi, REG_IRQFLAGS2) & MASK_IRQFLAGS2_FIFO_OVERRUN);
+	case packetSent:		 return (rf69_read_reg(spi, REG_IRQFLAGS2) & MASK_IRQFLAGS2_PACKET_SENT);
+	case payloadReady:		 return (rf69_read_reg(spi, REG_IRQFLAGS2) & MASK_IRQFLAGS2_PAYLOAD_READY);
+	case crcOk:			 return (rf69_read_reg(spi, REG_IRQFLAGS2) & MASK_IRQFLAGS2_CRC_OK);
+	case batteryLow:		 return (rf69_read_reg(spi, REG_IRQFLAGS2) & MASK_IRQFLAGS2_LOW_BAT);
+	default:			 return false;
 	}
 }
 
@@ -531,7 +531,7 @@ int rf69_reset_flag(struct spi_device *spi, enum flag flag)
 	switch (flag) {
 	case rssiExceededThreshold: return rf69_write_reg(spi, REG_IRQFLAGS1, MASK_IRQFLAGS1_RSSI);
 	case syncAddressMatch:	    return rf69_write_reg(spi, REG_IRQFLAGS1, MASK_IRQFLAGS1_SYNC_ADDRESS_MATCH);
-	case fifoOverrun:	    return rf69_write_reg(spi, REG_IRQFLAGS2, MASK_IRQFLAGS2_FIFO_OVERRUN);
+	case fifo_overrun:	    return rf69_write_reg(spi, REG_IRQFLAGS2, MASK_IRQFLAGS2_FIFO_OVERRUN);
 	default:
 		dev_dbg(&spi->dev, "set: illegal input param");
 		return -EINVAL;
@@ -589,9 +589,9 @@ int rf69_disable_sync(struct spi_device *spi)
 	return rf69_clear_bit(spi, REG_SYNC_CONFIG, MASK_SYNC_CONFIG_SYNC_ON);
 }
 
-int rf69_set_fifo_fill_condition(struct spi_device *spi, enum fifoFillCondition fifoFillCondition)
+int rf69_set_fifo_fill_condition(struct spi_device *spi, enum fifo_fill_condition fifo_fill_condition)
 {
-	switch (fifoFillCondition) {
+	switch (fifo_fill_condition) {
 	case always:		 return rf69_set_bit(spi, REG_SYNC_CONFIG, MASK_SYNC_CONFIG_FIFO_FILL_CONDITION);
 	case afterSyncInterrupt: return rf69_clear_bit(spi, REG_SYNC_CONFIG, MASK_SYNC_CONFIG_FIFO_FILL_CONDITION);
 	default:
@@ -696,8 +696,8 @@ int rf69_set_broadcast_address(struct spi_device *spi, u8 broadcastAddress)
 int rf69_set_tx_start_condition(struct spi_device *spi, enum txStartCondition txStartCondition)
 {
 	switch (txStartCondition) {
-	case fifoLevel:	   return rf69_clear_bit(spi, REG_FIFO_THRESH, MASK_FIFO_THRESH_TXSTART);
-	case fifoNotEmpty: return rf69_set_bit(spi, REG_FIFO_THRESH, MASK_FIFO_THRESH_TXSTART);
+	case fifo_level:	return rf69_clear_bit(spi, REG_FIFO_THRESH, MASK_FIFO_THRESH_TXSTART);
+	case fifo_not_empty:	return rf69_set_bit(spi, REG_FIFO_THRESH, MASK_FIFO_THRESH_TXSTART);
 	default:
 		dev_dbg(&spi->dev, "set: illegal input param");
 		return -EINVAL;

commit f772fa121d50d980457dc0c37152e30bf60c6452
Author: Valentin Vidic <Valentin.Vidic@CARNet.hr>
Date:   Tue Dec 19 15:56:23 2017 +0100

    staging: pi433: remove unused function
    
    As it turns out rf69_get_lna_gain is not used at all.
    
    Signed-off-by: Valentin Vidic <Valentin.Vidic@CARNet.hr>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/pi433/rf69.c b/drivers/staging/pi433/rf69.c
index d777e31688ad..f58b925bb1da 100644
--- a/drivers/staging/pi433/rf69.c
+++ b/drivers/staging/pi433/rf69.c
@@ -334,24 +334,6 @@ int rf69_set_lna_gain(struct spi_device *spi, enum lnaGain lnaGain)
 	}
 }
 
-enum lnaGain rf69_get_lna_gain(struct spi_device *spi)
-{
-	u8 currentValue;
-
-	currentValue = rf69_read_reg(spi, REG_LNA);
-
-	switch (currentValue & MASK_LNA_CURRENT_GAIN >> 3) { // improvement: change 3 to define
-	case LNA_GAIN_AUTO:	    return automatic;
-	case LNA_GAIN_MAX:	    return max;
-	case LNA_GAIN_MAX_MINUS_6:  return maxMinus6;
-	case LNA_GAIN_MAX_MINUS_12: return maxMinus12;
-	case LNA_GAIN_MAX_MINUS_24: return maxMinus24;
-	case LNA_GAIN_MAX_MINUS_36: return maxMinus36;
-	case LNA_GAIN_MAX_MINUS_48: return maxMinus48;
-	default:		    return undefined;
-	}
-}
-
 int rf69_set_dc_cut_off_frequency_intern(struct spi_device *spi, u8 reg, enum dcc_percent dcc_percent)
 {
 	switch (dcc_percent) {

commit 6106cfbd05b603612c7cb3c08a6ac870d1c8b5da
Author: Valentin Vidic <Valentin.Vidic@CARNet.hr>
Date:   Wed Dec 13 21:01:30 2017 +0100

    staging: pi433: fix CamelCase for dccPercent variables
    
    Fixes checkpatch warning:
    
      CHECK: Avoid CamelCase: <dccPercent>
    
    Signed-off-by: Valentin Vidic <Valentin.Vidic@CARNet.hr>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/pi433/rf69.c b/drivers/staging/pi433/rf69.c
index 3675dc03a7d3..d777e31688ad 100644
--- a/drivers/staging/pi433/rf69.c
+++ b/drivers/staging/pi433/rf69.c
@@ -352,31 +352,31 @@ enum lnaGain rf69_get_lna_gain(struct spi_device *spi)
 	}
 }
 
-int rf69_set_dc_cut_off_frequency_intern(struct spi_device *spi, u8 reg, enum dccPercent dccPercent)
-{
-	switch (dccPercent) {
-	case dcc16Percent:	return rf69_read_mod_write(spi, reg, MASK_BW_DCC_FREQ, BW_DCC_16_PERCENT);
-	case dcc8Percent:	return rf69_read_mod_write(spi, reg, MASK_BW_DCC_FREQ, BW_DCC_8_PERCENT);
-	case dcc4Percent:	return rf69_read_mod_write(spi, reg, MASK_BW_DCC_FREQ, BW_DCC_4_PERCENT);
-	case dcc2Percent:	return rf69_read_mod_write(spi, reg, MASK_BW_DCC_FREQ, BW_DCC_2_PERCENT);
-	case dcc1Percent:	return rf69_read_mod_write(spi, reg, MASK_BW_DCC_FREQ, BW_DCC_1_PERCENT);
-	case dcc0_5Percent:	return rf69_read_mod_write(spi, reg, MASK_BW_DCC_FREQ, BW_DCC_0_5_PERCENT);
-	case dcc0_25Percent:	return rf69_read_mod_write(spi, reg, MASK_BW_DCC_FREQ, BW_DCC_0_25_PERCENT);
-	case dcc0_125Percent:	return rf69_read_mod_write(spi, reg, MASK_BW_DCC_FREQ, BW_DCC_0_125_PERCENT);
+int rf69_set_dc_cut_off_frequency_intern(struct spi_device *spi, u8 reg, enum dcc_percent dcc_percent)
+{
+	switch (dcc_percent) {
+	case dcc_16_percent:	return rf69_read_mod_write(spi, reg, MASK_BW_DCC_FREQ, BW_DCC_16_PERCENT);
+	case dcc_8_percent:	return rf69_read_mod_write(spi, reg, MASK_BW_DCC_FREQ, BW_DCC_8_PERCENT);
+	case dcc_4_percent:	return rf69_read_mod_write(spi, reg, MASK_BW_DCC_FREQ, BW_DCC_4_PERCENT);
+	case dcc_2_percent:	return rf69_read_mod_write(spi, reg, MASK_BW_DCC_FREQ, BW_DCC_2_PERCENT);
+	case dcc_1_percent:	return rf69_read_mod_write(spi, reg, MASK_BW_DCC_FREQ, BW_DCC_1_PERCENT);
+	case dcc_0_5_percent:	return rf69_read_mod_write(spi, reg, MASK_BW_DCC_FREQ, BW_DCC_0_5_PERCENT);
+	case dcc_0_25_percent:	return rf69_read_mod_write(spi, reg, MASK_BW_DCC_FREQ, BW_DCC_0_25_PERCENT);
+	case dcc_0_125_percent:	return rf69_read_mod_write(spi, reg, MASK_BW_DCC_FREQ, BW_DCC_0_125_PERCENT);
 	default:
 		dev_dbg(&spi->dev, "set: illegal input param");
 		return -EINVAL;
 	}
 }
 
-int rf69_set_dc_cut_off_frequency(struct spi_device *spi, enum dccPercent dccPercent)
+int rf69_set_dc_cut_off_frequency(struct spi_device *spi, enum dcc_percent dcc_percent)
 {
-	return rf69_set_dc_cut_off_frequency_intern(spi, REG_RXBW, dccPercent);
+	return rf69_set_dc_cut_off_frequency_intern(spi, REG_RXBW, dcc_percent);
 }
 
-int rf69_set_dc_cut_off_frequency_during_afc(struct spi_device *spi, enum dccPercent dccPercent)
+int rf69_set_dc_cut_off_frequency_during_afc(struct spi_device *spi, enum dcc_percent dcc_percent)
 {
-	return rf69_set_dc_cut_off_frequency_intern(spi, REG_AFCBW, dccPercent);
+	return rf69_set_dc_cut_off_frequency_intern(spi, REG_AFCBW, dcc_percent);
 }
 
 static int rf69_set_bandwidth_intern(struct spi_device *spi, u8 reg,

commit 7f9d04bc568d22e573a10e2a0a316599942786f7
Merge: 9a38450ac3d1 1291a0d5049d
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon Dec 18 09:12:51 2017 +0100

    Merge 4.15-rc4 into staging-next
    
    We want the staging fixes in here as well.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 9a38450ac3d1f665fdbe06a2fd2e06fcf70defbc
Author: Kari Argillander <kari.argillander@gmail.com>
Date:   Wed Dec 13 00:02:11 2017 +0200

    staging: pi433: Fix disordered switch case
    
    Case: SHAPING_0_5 is writing DATAMODUL_MODLATION_SHAPE_0_3 value and
    vice versa
    
    Signed-off-by: Kari Argillander <kari.argillander@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/pi433/rf69.c b/drivers/staging/pi433/rf69.c
index 0121186015fd..f77ecd60f43a 100644
--- a/drivers/staging/pi433/rf69.c
+++ b/drivers/staging/pi433/rf69.c
@@ -117,8 +117,8 @@ int rf69_set_modulation_shaping(struct spi_device *spi,
 		switch (mod_shaping) {
 		case SHAPING_OFF: return rf69_read_mod_write(spi, REG_DATAMODUL, MASK_DATAMODUL_MODULATION_SHAPE, DATAMODUL_MODULATION_SHAPE_NONE);
 		case SHAPING_1_0: return rf69_read_mod_write(spi, REG_DATAMODUL, MASK_DATAMODUL_MODULATION_SHAPE, DATAMODUL_MODULATION_SHAPE_1_0);
-		case SHAPING_0_5: return rf69_read_mod_write(spi, REG_DATAMODUL, MASK_DATAMODUL_MODULATION_SHAPE, DATAMODUL_MODULATION_SHAPE_0_3);
-		case SHAPING_0_3: return rf69_read_mod_write(spi, REG_DATAMODUL, MASK_DATAMODUL_MODULATION_SHAPE, DATAMODUL_MODULATION_SHAPE_0_5);
+		case SHAPING_0_5: return rf69_read_mod_write(spi, REG_DATAMODUL, MASK_DATAMODUL_MODULATION_SHAPE, DATAMODUL_MODULATION_SHAPE_0_5);
+		case SHAPING_0_3: return rf69_read_mod_write(spi, REG_DATAMODUL, MASK_DATAMODUL_MODULATION_SHAPE, DATAMODUL_MODULATION_SHAPE_0_3);
 		default:
 			dev_dbg(&spi->dev, "set: illegal input param");
 			return -EINVAL;

commit 2f58f293c26be2668ce2f10c13156d6cbd44d95c
Author: Valentin Vidic <Valentin.Vidic@CARNet.hr>
Date:   Sun Dec 10 15:31:13 2017 +0100

    staging: pi433: remove spaces before tabs
    
    Fixes checkpatch warning for hidden spaces before tabs.
    
    Signed-off-by: Valentin Vidic <Valentin.Vidic@CARNet.hr>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/pi433/rf69.c b/drivers/staging/pi433/rf69.c
index 770c33c9e60e..0121186015fd 100644
--- a/drivers/staging/pi433/rf69.c
+++ b/drivers/staging/pi433/rf69.c
@@ -29,7 +29,7 @@
 #include "rf69_registers.h"
 
 #define F_OSC	  32000000 /* in Hz */
-#define FIFO_SIZE 66 	   /* in byte */
+#define FIFO_SIZE 66	   /* in byte */
 
 /*-------------------------------------------------------------------------*/
 

commit 7b15049c4d66a426f782936ce3de1f719889f97a
Author: Valentin Vidic <Valentin.Vidic@CARNet.hr>
Date:   Sun Dec 10 15:31:09 2017 +0100

    staging: pi433: remove space inside parenthesis
    
    Fixes checkpatch error for prohibited spaces.
    
    Signed-off-by: Valentin Vidic <Valentin.Vidic@CARNet.hr>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/pi433/rf69.c b/drivers/staging/pi433/rf69.c
index 6e38e6a515a4..770c33c9e60e 100644
--- a/drivers/staging/pi433/rf69.c
+++ b/drivers/staging/pi433/rf69.c
@@ -757,7 +757,7 @@ int rf69_set_dagc(struct spi_device *spi, enum dagc dagc)
 
 /*-------------------------------------------------------------------------*/
 
-int rf69_read_fifo (struct spi_device *spi, u8 *buffer, unsigned int size)
+int rf69_read_fifo(struct spi_device *spi, u8 *buffer, unsigned int size)
 {
 #ifdef DEBUG_FIFO_ACCESS
 	int i;
@@ -811,7 +811,7 @@ int rf69_write_fifo(struct spi_device *spi, u8 *buffer, unsigned int size)
 		dev_dbg(&spi->dev, "0x%x\n", buffer[i]);
 #endif
 
-	return spi_write (spi, local_buffer, size + 1);
+	return spi_write(spi, local_buffer, size + 1);
 }
 
 /*-------------------------------------------------------------------------*/

commit b01c3553a91332f326222597efdeb61bc50249e7
Author: Simon Sandström <simon@nikanor.nu>
Date:   Sat Dec 9 19:02:57 2017 +0100

    staging: pi433: Remove unnecessary #ifdef DEBUG around dev_dbg
    
    dev_dbg() already depends on DEBUG.
    
    Signed-off-by: Simon Sandström <simon@nikanor.nu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/pi433/rf69.c b/drivers/staging/pi433/rf69.c
index 04a74423c325..6e38e6a515a4 100644
--- a/drivers/staging/pi433/rf69.c
+++ b/drivers/staging/pi433/rf69.c
@@ -767,9 +767,7 @@ int rf69_read_fifo (struct spi_device *spi, u8 *buffer, unsigned int size)
 	int retval;
 
 	if (size > FIFO_SIZE) {
-#ifdef DEBUG
 		dev_dbg(&spi->dev, "read fifo: passed in buffer bigger then internal buffer\n");
-#endif
 		return -EMSGSIZE;
 	}
 
@@ -801,9 +799,7 @@ int rf69_write_fifo(struct spi_device *spi, u8 *buffer, unsigned int size)
 	u8 local_buffer[FIFO_SIZE + 1];
 
 	if (size > FIFO_SIZE) {
-#ifdef DEBUG
 		dev_dbg(&spi->dev, "read fifo: passed in buffer bigger then internal buffer\n");
-#endif
 		return -EMSGSIZE;
 	}
 

commit 49f43ef226146969866e628fbbf28bfce2099170
Author: Simon Sandström <simon@nikanor.nu>
Date:   Sat Dec 9 19:02:56 2017 +0100

    staging: pi433: Remove function entry dev_dbg()
    
    ftrace can be used to trace function calls, so there is no need to use
    dev_dbg() here.
    
    Signed-off-by: Simon Sandström <simon@nikanor.nu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/pi433/rf69.c b/drivers/staging/pi433/rf69.c
index 39920240c05c..04a74423c325 100644
--- a/drivers/staging/pi433/rf69.c
+++ b/drivers/staging/pi433/rf69.c
@@ -64,10 +64,6 @@ static inline int rf69_read_mod_write(struct spi_device *spi, u8 reg, u8 mask, u
 
 int rf69_set_mode(struct spi_device *spi, enum mode mode)
 {
-#ifdef DEBUG
-	dev_dbg(&spi->dev, "set: mode");
-#endif
-
 	switch (mode) {
 	case transmit:	  return rf69_read_mod_write(spi, REG_OPMODE, MASK_OPMODE_MODE, OPMODE_MODE_TRANSMIT);
 	case receive:	  return rf69_read_mod_write(spi, REG_OPMODE, MASK_OPMODE_MODE, OPMODE_MODE_RECEIVE);
@@ -91,10 +87,6 @@ int rf69_set_data_mode(struct spi_device *spi, u8 data_mode)
 
 int rf69_set_modulation(struct spi_device *spi, enum modulation modulation)
 {
-#ifdef DEBUG
-	dev_dbg(&spi->dev, "set: modulation");
-#endif
-
 	switch (modulation) {
 	case OOK: return rf69_read_mod_write(spi, REG_DATAMODUL, MASK_DATAMODUL_MODULATION_TYPE, DATAMODUL_MODULATION_TYPE_OOK);
 	case FSK: return rf69_read_mod_write(spi, REG_DATAMODUL, MASK_DATAMODUL_MODULATION_TYPE, DATAMODUL_MODULATION_TYPE_FSK);
@@ -108,10 +100,6 @@ enum modulation rf69_get_modulation(struct spi_device *spi)
 {
 	u8 currentValue;
 
-#ifdef DEBUG
-	dev_dbg(&spi->dev, "get: mode");
-#endif
-
 	currentValue = rf69_read_reg(spi, REG_DATAMODUL);
 
 	switch (currentValue & MASK_DATAMODUL_MODULATION_TYPE >> 3) { // TODO improvement: change 3 to define
@@ -124,10 +112,6 @@ enum modulation rf69_get_modulation(struct spi_device *spi)
 int rf69_set_modulation_shaping(struct spi_device *spi,
 				enum mod_shaping mod_shaping)
 {
-#ifdef DEBUG
-	dev_dbg(&spi->dev, "set: mod shaping");
-#endif
-
 	switch (rf69_get_modulation(spi)) {
 	case FSK:
 		switch (mod_shaping) {
@@ -162,10 +146,6 @@ int rf69_set_bit_rate(struct spi_device *spi, u16 bitRate)
 	u8 msb;
 	u8 lsb;
 
-#ifdef DEBUG
-	dev_dbg(&spi->dev, "set: bit rate");
-#endif
-
 	// check input value
 	bitRate_min = F_OSC / 8388608; // 8388608 = 2^23;
 	if (bitRate < bitRate_min) {
@@ -199,10 +179,6 @@ int rf69_set_deviation(struct spi_device *spi, u32 deviation)
 	u8 lsb;
 	u64 factor = 1000000; // to improve precision of calculation
 
-#ifdef DEBUG
-	dev_dbg(&spi->dev, "set: deviation");
-#endif
-
 	// TODO: Dependency to bitrate
 	if (deviation < 600 || deviation > 500000) {
 		dev_dbg(&spi->dev, "set_deviation: illegal input param");
@@ -248,10 +224,6 @@ int rf69_set_frequency(struct spi_device *spi, u32 frequency)
 	u8 lsb;
 	u64 factor = 1000000; // to improve precision of calculation
 
-#ifdef DEBUG
-	dev_dbg(&spi->dev, "set: frequency");
-#endif
-
 	// calculat f step
 	f_step = F_OSC * factor;
 	do_div(f_step, 524288); //  524288 = 2^19
@@ -297,10 +269,6 @@ int rf69_disable_amplifier(struct spi_device *spi, u8 amplifier_mask)
 
 int rf69_set_output_power_level(struct spi_device *spi, u8 powerLevel)
 {
-#ifdef DEBUG
-	dev_dbg(&spi->dev, "set: power level");
-#endif
-
 	// TODO: Dependency to PA0,1,2 setting
 	powerLevel += 18;
 
@@ -316,10 +284,6 @@ int rf69_set_output_power_level(struct spi_device *spi, u8 powerLevel)
 
 int rf69_set_pa_ramp(struct spi_device *spi, enum paRamp paRamp)
 {
-#ifdef DEBUG
-	dev_dbg(&spi->dev, "set: pa ramp");
-#endif
-
 	switch (paRamp) {
 	case ramp3400:	return rf69_write_reg(spi, REG_PARAMP, PARAMP_3400);
 	case ramp2000:	return rf69_write_reg(spi, REG_PARAMP, PARAMP_2000);
@@ -345,10 +309,6 @@ int rf69_set_pa_ramp(struct spi_device *spi, enum paRamp paRamp)
 
 int rf69_set_antenna_impedance(struct spi_device *spi, enum antennaImpedance antennaImpedance)
 {
-#ifdef DEBUG
-	dev_dbg(&spi->dev, "set: antenna impedance");
-#endif
-
 	switch (antennaImpedance) {
 	case fiftyOhm:	    return rf69_clear_bit(spi, REG_LNA, MASK_LNA_ZIN);
 	case twohundretOhm: return rf69_set_bit(spi, REG_LNA, MASK_LNA_ZIN);
@@ -360,10 +320,6 @@ int rf69_set_antenna_impedance(struct spi_device *spi, enum antennaImpedance ant
 
 int rf69_set_lna_gain(struct spi_device *spi, enum lnaGain lnaGain)
 {
-#ifdef DEBUG
-	dev_dbg(&spi->dev, "set: lna gain");
-#endif
-
 	switch (lnaGain) {
 	case automatic:	 return rf69_read_mod_write(spi, REG_LNA, MASK_LNA_GAIN, LNA_GAIN_AUTO);
 	case max:	 return rf69_read_mod_write(spi, REG_LNA, MASK_LNA_GAIN, LNA_GAIN_MAX);
@@ -382,10 +338,6 @@ enum lnaGain rf69_get_lna_gain(struct spi_device *spi)
 {
 	u8 currentValue;
 
-#ifdef DEBUG
-	dev_dbg(&spi->dev, "get: lna gain");
-#endif
-
 	currentValue = rf69_read_reg(spi, REG_LNA);
 
 	switch (currentValue & MASK_LNA_CURRENT_GAIN >> 3) { // improvement: change 3 to define
@@ -419,19 +371,11 @@ int rf69_set_dc_cut_off_frequency_intern(struct spi_device *spi, u8 reg, enum dc
 
 int rf69_set_dc_cut_off_frequency(struct spi_device *spi, enum dccPercent dccPercent)
 {
-#ifdef DEBUG
-	dev_dbg(&spi->dev, "set: cut off freq");
-#endif
-
 	return rf69_set_dc_cut_off_frequency_intern(spi, REG_RXBW, dccPercent);
 }
 
 int rf69_set_dc_cut_off_frequency_during_afc(struct spi_device *spi, enum dccPercent dccPercent)
 {
-#ifdef DEBUG
-	dev_dbg(&spi->dev, "set: cut off freq during afc");
-#endif
-
 	return rf69_set_dc_cut_off_frequency_intern(spi, REG_AFCBW, dccPercent);
 }
 
@@ -481,28 +425,16 @@ static int rf69_set_bandwidth_intern(struct spi_device *spi, u8 reg,
 
 int rf69_set_bandwidth(struct spi_device *spi, enum mantisse mantisse, u8 exponent)
 {
-#ifdef DEBUG
-	dev_dbg(&spi->dev, "set: band width");
-#endif
-
 	return rf69_set_bandwidth_intern(spi, REG_RXBW, mantisse, exponent);
 }
 
 int rf69_set_bandwidth_during_afc(struct spi_device *spi, enum mantisse mantisse, u8 exponent)
 {
-#ifdef DEBUG
-	dev_dbg(&spi->dev, "set: band width during afc");
-#endif
-
 	return rf69_set_bandwidth_intern(spi, REG_AFCBW, mantisse, exponent);
 }
 
 int rf69_set_ook_threshold_type(struct spi_device *spi, enum thresholdType thresholdType)
 {
-#ifdef DEBUG
-	dev_dbg(&spi->dev, "set: threshold type");
-#endif
-
 	switch (thresholdType) {
 	case fixed:	return rf69_read_mod_write(spi, REG_OOKPEAK, MASK_OOKPEAK_THRESTYPE, OOKPEAK_THRESHTYPE_FIXED);
 	case peak:	return rf69_read_mod_write(spi, REG_OOKPEAK, MASK_OOKPEAK_THRESTYPE, OOKPEAK_THRESHTYPE_PEAK);
@@ -515,10 +447,6 @@ int rf69_set_ook_threshold_type(struct spi_device *spi, enum thresholdType thres
 
 int rf69_set_ook_threshold_step(struct spi_device *spi, enum thresholdStep thresholdStep)
 {
-#ifdef DEBUG
-	dev_dbg(&spi->dev, "set: threshold step");
-#endif
-
 	switch (thresholdStep) {
 	case step_0_5db: return rf69_read_mod_write(spi, REG_OOKPEAK, MASK_OOKPEAK_THRESSTEP, OOKPEAK_THRESHSTEP_0_5_DB);
 	case step_1_0db: return rf69_read_mod_write(spi, REG_OOKPEAK, MASK_OOKPEAK_THRESSTEP, OOKPEAK_THRESHSTEP_1_0_DB);
@@ -536,10 +464,6 @@ int rf69_set_ook_threshold_step(struct spi_device *spi, enum thresholdStep thres
 
 int rf69_set_ook_threshold_dec(struct spi_device *spi, enum thresholdDecrement thresholdDecrement)
 {
-#ifdef DEBUG
-	dev_dbg(&spi->dev, "set: threshold decrement");
-#endif
-
 	switch (thresholdDecrement) {
 	case dec_every8th: return rf69_read_mod_write(spi, REG_OOKPEAK, MASK_OOKPEAK_THRESDEC, OOKPEAK_THRESHDEC_EVERY_8TH);
 	case dec_every4th: return rf69_read_mod_write(spi, REG_OOKPEAK, MASK_OOKPEAK_THRESDEC, OOKPEAK_THRESHDEC_EVERY_4TH);
@@ -562,10 +486,6 @@ int rf69_set_dio_mapping(struct spi_device *spi, u8 DIONumber, u8 value)
 	u8 regaddr;
 	u8 regValue;
 
-#ifdef DEBUG
-	dev_dbg(&spi->dev, "set: DIO mapping");
-#endif
-
 	switch (DIONumber) {
 	case 0:
 		mask = MASK_DIO0; shift = SHIFT_DIO0; regaddr = REG_DIOMAPPING1;
@@ -602,10 +522,6 @@ int rf69_set_dio_mapping(struct spi_device *spi, u8 DIONumber, u8 value)
 
 bool rf69_get_flag(struct spi_device *spi, enum flag flag)
 {
-#ifdef DEBUG
-	dev_dbg(&spi->dev, "get: flag");
-#endif
-
 	switch (flag) {
 	case modeSwitchCompleted:     return (rf69_read_reg(spi, REG_IRQFLAGS1) & MASK_IRQFLAGS1_MODE_READY);
 	case readyToReceive:	      return (rf69_read_reg(spi, REG_IRQFLAGS1) & MASK_IRQFLAGS1_RX_READY);
@@ -630,10 +546,6 @@ bool rf69_get_flag(struct spi_device *spi, enum flag flag)
 
 int rf69_reset_flag(struct spi_device *spi, enum flag flag)
 {
-#ifdef DEBUG
-	dev_dbg(&spi->dev, "reset: flag");
-#endif
-
 	switch (flag) {
 	case rssiExceededThreshold: return rf69_write_reg(spi, REG_IRQFLAGS1, MASK_IRQFLAGS1_RSSI);
 	case syncAddressMatch:	    return rf69_write_reg(spi, REG_IRQFLAGS1, MASK_IRQFLAGS1_SYNC_ADDRESS_MATCH);
@@ -646,10 +558,6 @@ int rf69_reset_flag(struct spi_device *spi, enum flag flag)
 
 int rf69_set_rssi_threshold(struct spi_device *spi, u8 threshold)
 {
-#ifdef DEBUG
-	dev_dbg(&spi->dev, "set: rssi threshold");
-#endif
-
 	/* no value check needed - u8 exactly matches register size */
 
 	return rf69_write_reg(spi, REG_RSSITHRESH, threshold);
@@ -657,10 +565,6 @@ int rf69_set_rssi_threshold(struct spi_device *spi, u8 threshold)
 
 int rf69_set_rx_start_timeout(struct spi_device *spi, u8 timeout)
 {
-#ifdef DEBUG
-	dev_dbg(&spi->dev, "set: start timeout");
-#endif
-
 	/* no value check needed - u8 exactly matches register size */
 
 	return rf69_write_reg(spi, REG_RXTIMEOUT1, timeout);
@@ -668,10 +572,6 @@ int rf69_set_rx_start_timeout(struct spi_device *spi, u8 timeout)
 
 int rf69_set_rssi_timeout(struct spi_device *spi, u8 timeout)
 {
-#ifdef DEBUG
-	dev_dbg(&spi->dev, "set: rssi timeout");
-#endif
-
 	/* no value check needed - u8 exactly matches register size */
 
 	return rf69_write_reg(spi, REG_RXTIMEOUT2, timeout);
@@ -682,10 +582,6 @@ int rf69_set_preamble_length(struct spi_device *spi, u16 preambleLength)
 	int retval;
 	u8 msb, lsb;
 
-#ifdef DEBUG
-	dev_dbg(&spi->dev, "set: preamble length");
-#endif
-
 	/* no value check needed - u16 exactly matches register size */
 
 	/* calculate reg settings */
@@ -713,10 +609,6 @@ int rf69_disable_sync(struct spi_device *spi)
 
 int rf69_set_fifo_fill_condition(struct spi_device *spi, enum fifoFillCondition fifoFillCondition)
 {
-#ifdef DEBUG
-	dev_dbg(&spi->dev, "set: fifo fill condition");
-#endif
-
 	switch (fifoFillCondition) {
 	case always:		 return rf69_set_bit(spi, REG_SYNC_CONFIG, MASK_SYNC_CONFIG_FIFO_FILL_CONDITION);
 	case afterSyncInterrupt: return rf69_clear_bit(spi, REG_SYNC_CONFIG, MASK_SYNC_CONFIG_FIFO_FILL_CONDITION);
@@ -728,10 +620,6 @@ int rf69_set_fifo_fill_condition(struct spi_device *spi, enum fifoFillCondition
 
 int rf69_set_sync_size(struct spi_device *spi, u8 syncSize)
 {
-#ifdef DEBUG
-	dev_dbg(&spi->dev, "set: sync size");
-#endif
-
 	// check input value
 	if (syncSize > 0x07) {
 		dev_dbg(&spi->dev, "set: illegal input param");
@@ -744,10 +632,6 @@ int rf69_set_sync_size(struct spi_device *spi, u8 syncSize)
 
 int rf69_set_sync_tolerance(struct spi_device *spi, u8 syncTolerance)
 {
-#ifdef DEBUG
-	dev_dbg(&spi->dev, "set: sync tolerance");
-#endif
-
 	// check input value
 	if (syncTolerance > 0x07) {
 		dev_dbg(&spi->dev, "set: illegal input param");
@@ -762,10 +646,6 @@ int rf69_set_sync_values(struct spi_device *spi, u8 syncValues[8])
 {
 	int retval = 0;
 
-#ifdef DEBUG
-	dev_dbg(&spi->dev, "set: sync values");
-#endif
-
 	retval += rf69_write_reg(spi, REG_SYNCVALUE1, syncValues[0]);
 	retval += rf69_write_reg(spi, REG_SYNCVALUE2, syncValues[1]);
 	retval += rf69_write_reg(spi, REG_SYNCVALUE3, syncValues[2]);
@@ -780,10 +660,6 @@ int rf69_set_sync_values(struct spi_device *spi, u8 syncValues[8])
 
 int rf69_set_packet_format(struct spi_device *spi, enum packetFormat packetFormat)
 {
-#ifdef DEBUG
-	dev_dbg(&spi->dev, "set: packet format");
-#endif
-
 	switch (packetFormat) {
 	case packetLengthVar: return rf69_set_bit(spi, REG_PACKETCONFIG1, MASK_PACKETCONFIG1_PAKET_FORMAT_VARIABLE);
 	case packetLengthFix: return rf69_clear_bit(spi, REG_PACKETCONFIG1, MASK_PACKETCONFIG1_PAKET_FORMAT_VARIABLE);
@@ -805,10 +681,6 @@ int rf69_disable_crc(struct spi_device *spi)
 
 int rf69_set_adressFiltering(struct spi_device *spi, enum addressFiltering addressFiltering)
 {
-#ifdef DEBUG
-	dev_dbg(&spi->dev, "set: address filtering");
-#endif
-
 	switch (addressFiltering) {
 	case filteringOff:	     return rf69_read_mod_write(spi, REG_PACKETCONFIG1, MASK_PACKETCONFIG1_ADDRESSFILTERING, PACKETCONFIG1_ADDRESSFILTERING_OFF);
 	case nodeAddress:	     return rf69_read_mod_write(spi, REG_PACKETCONFIG1, MASK_PACKETCONFIG1_ADDRESSFILTERING, PACKETCONFIG1_ADDRESSFILTERING_NODE);
@@ -821,46 +693,26 @@ int rf69_set_adressFiltering(struct spi_device *spi, enum addressFiltering addre
 
 int rf69_set_payload_length(struct spi_device *spi, u8 payloadLength)
 {
-#ifdef DEBUG
-	dev_dbg(&spi->dev, "set: payload length");
-#endif
-
 	return rf69_write_reg(spi, REG_PAYLOAD_LENGTH, payloadLength);
 }
 
 u8  rf69_get_payload_length(struct spi_device *spi)
 {
-#ifdef DEBUG
-	dev_dbg(&spi->dev, "get: payload length");
-#endif
-
 	return (u8)rf69_read_reg(spi, REG_PAYLOAD_LENGTH);
 }
 
 int rf69_set_node_address(struct spi_device *spi, u8 nodeAddress)
 {
-#ifdef DEBUG
-	dev_dbg(&spi->dev, "set: node address");
-#endif
-
 	return rf69_write_reg(spi, REG_NODEADRS, nodeAddress);
 }
 
 int rf69_set_broadcast_address(struct spi_device *spi, u8 broadcastAddress)
 {
-#ifdef DEBUG
-	dev_dbg(&spi->dev, "set: broadcast address");
-#endif
-
 	return rf69_write_reg(spi, REG_BROADCASTADRS, broadcastAddress);
 }
 
 int rf69_set_tx_start_condition(struct spi_device *spi, enum txStartCondition txStartCondition)
 {
-#ifdef DEBUG
-	dev_dbg(&spi->dev, "set: start condition");
-#endif
-
 	switch (txStartCondition) {
 	case fifoLevel:	   return rf69_clear_bit(spi, REG_FIFO_THRESH, MASK_FIFO_THRESH_TXSTART);
 	case fifoNotEmpty: return rf69_set_bit(spi, REG_FIFO_THRESH, MASK_FIFO_THRESH_TXSTART);
@@ -874,10 +726,6 @@ int rf69_set_fifo_threshold(struct spi_device *spi, u8 threshold)
 {
 	int retval;
 
-#ifdef DEBUG
-	dev_dbg(&spi->dev, "set: fifo threshold");
-#endif
-
 	/* check input value */
 	if (threshold & 0x80) {
 		dev_dbg(&spi->dev, "set: illegal input param");
@@ -897,10 +745,6 @@ int rf69_set_fifo_threshold(struct spi_device *spi, u8 threshold)
 
 int rf69_set_dagc(struct spi_device *spi, enum dagc dagc)
 {
-#ifdef DEBUG
-	dev_dbg(&spi->dev, "set: dagc");
-#endif
-
 	switch (dagc) {
 	case normalMode:		 return rf69_write_reg(spi, REG_TESTDAGC, DAGC_NORMAL);
 	case improve:			 return rf69_write_reg(spi, REG_TESTDAGC, DAGC_IMPROVED_LOWBETA0);

commit 178dd42aa40f27035165672ec1c64c86049337ab
Author: Simon Sandström <simon@nikanor.nu>
Date:   Sat Dec 9 19:02:55 2017 +0100

    staging: pi433: Remove indentation on #ifdef blocks
    
    ifdef blocks should not increase indentation level.
    
    Signed-off-by: Simon Sandström <simon@nikanor.nu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/pi433/rf69.c b/drivers/staging/pi433/rf69.c
index 8b6d68f10e8a..39920240c05c 100644
--- a/drivers/staging/pi433/rf69.c
+++ b/drivers/staging/pi433/rf69.c
@@ -64,9 +64,9 @@ static inline int rf69_read_mod_write(struct spi_device *spi, u8 reg, u8 mask, u
 
 int rf69_set_mode(struct spi_device *spi, enum mode mode)
 {
-	#ifdef DEBUG
-		dev_dbg(&spi->dev, "set: mode");
-	#endif
+#ifdef DEBUG
+	dev_dbg(&spi->dev, "set: mode");
+#endif
 
 	switch (mode) {
 	case transmit:	  return rf69_read_mod_write(spi, REG_OPMODE, MASK_OPMODE_MODE, OPMODE_MODE_TRANSMIT);
@@ -91,9 +91,9 @@ int rf69_set_data_mode(struct spi_device *spi, u8 data_mode)
 
 int rf69_set_modulation(struct spi_device *spi, enum modulation modulation)
 {
-	#ifdef DEBUG
-		dev_dbg(&spi->dev, "set: modulation");
-	#endif
+#ifdef DEBUG
+	dev_dbg(&spi->dev, "set: modulation");
+#endif
 
 	switch (modulation) {
 	case OOK: return rf69_read_mod_write(spi, REG_DATAMODUL, MASK_DATAMODUL_MODULATION_TYPE, DATAMODUL_MODULATION_TYPE_OOK);
@@ -108,9 +108,9 @@ enum modulation rf69_get_modulation(struct spi_device *spi)
 {
 	u8 currentValue;
 
-	#ifdef DEBUG
-		dev_dbg(&spi->dev, "get: mode");
-	#endif
+#ifdef DEBUG
+	dev_dbg(&spi->dev, "get: mode");
+#endif
 
 	currentValue = rf69_read_reg(spi, REG_DATAMODUL);
 
@@ -124,9 +124,9 @@ enum modulation rf69_get_modulation(struct spi_device *spi)
 int rf69_set_modulation_shaping(struct spi_device *spi,
 				enum mod_shaping mod_shaping)
 {
-	#ifdef DEBUG
-		dev_dbg(&spi->dev, "set: mod shaping");
-	#endif
+#ifdef DEBUG
+	dev_dbg(&spi->dev, "set: mod shaping");
+#endif
 
 	switch (rf69_get_modulation(spi)) {
 	case FSK:
@@ -162,9 +162,9 @@ int rf69_set_bit_rate(struct spi_device *spi, u16 bitRate)
 	u8 msb;
 	u8 lsb;
 
-	#ifdef DEBUG
-		dev_dbg(&spi->dev, "set: bit rate");
-	#endif
+#ifdef DEBUG
+	dev_dbg(&spi->dev, "set: bit rate");
+#endif
 
 	// check input value
 	bitRate_min = F_OSC / 8388608; // 8388608 = 2^23;
@@ -199,9 +199,9 @@ int rf69_set_deviation(struct spi_device *spi, u32 deviation)
 	u8 lsb;
 	u64 factor = 1000000; // to improve precision of calculation
 
-	#ifdef DEBUG
-		dev_dbg(&spi->dev, "set: deviation");
-	#endif
+#ifdef DEBUG
+	dev_dbg(&spi->dev, "set: deviation");
+#endif
 
 	// TODO: Dependency to bitrate
 	if (deviation < 600 || deviation > 500000) {
@@ -248,9 +248,9 @@ int rf69_set_frequency(struct spi_device *spi, u32 frequency)
 	u8 lsb;
 	u64 factor = 1000000; // to improve precision of calculation
 
-	#ifdef DEBUG
-		dev_dbg(&spi->dev, "set: frequency");
-	#endif
+#ifdef DEBUG
+	dev_dbg(&spi->dev, "set: frequency");
+#endif
 
 	// calculat f step
 	f_step = F_OSC * factor;
@@ -297,9 +297,9 @@ int rf69_disable_amplifier(struct spi_device *spi, u8 amplifier_mask)
 
 int rf69_set_output_power_level(struct spi_device *spi, u8 powerLevel)
 {
-	#ifdef DEBUG
-		dev_dbg(&spi->dev, "set: power level");
-	#endif
+#ifdef DEBUG
+	dev_dbg(&spi->dev, "set: power level");
+#endif
 
 	// TODO: Dependency to PA0,1,2 setting
 	powerLevel += 18;
@@ -316,9 +316,9 @@ int rf69_set_output_power_level(struct spi_device *spi, u8 powerLevel)
 
 int rf69_set_pa_ramp(struct spi_device *spi, enum paRamp paRamp)
 {
-	#ifdef DEBUG
-		dev_dbg(&spi->dev, "set: pa ramp");
-	#endif
+#ifdef DEBUG
+	dev_dbg(&spi->dev, "set: pa ramp");
+#endif
 
 	switch (paRamp) {
 	case ramp3400:	return rf69_write_reg(spi, REG_PARAMP, PARAMP_3400);
@@ -345,9 +345,9 @@ int rf69_set_pa_ramp(struct spi_device *spi, enum paRamp paRamp)
 
 int rf69_set_antenna_impedance(struct spi_device *spi, enum antennaImpedance antennaImpedance)
 {
-	#ifdef DEBUG
-		dev_dbg(&spi->dev, "set: antenna impedance");
-	#endif
+#ifdef DEBUG
+	dev_dbg(&spi->dev, "set: antenna impedance");
+#endif
 
 	switch (antennaImpedance) {
 	case fiftyOhm:	    return rf69_clear_bit(spi, REG_LNA, MASK_LNA_ZIN);
@@ -360,9 +360,9 @@ int rf69_set_antenna_impedance(struct spi_device *spi, enum antennaImpedance ant
 
 int rf69_set_lna_gain(struct spi_device *spi, enum lnaGain lnaGain)
 {
-	#ifdef DEBUG
-		dev_dbg(&spi->dev, "set: lna gain");
-	#endif
+#ifdef DEBUG
+	dev_dbg(&spi->dev, "set: lna gain");
+#endif
 
 	switch (lnaGain) {
 	case automatic:	 return rf69_read_mod_write(spi, REG_LNA, MASK_LNA_GAIN, LNA_GAIN_AUTO);
@@ -382,9 +382,9 @@ enum lnaGain rf69_get_lna_gain(struct spi_device *spi)
 {
 	u8 currentValue;
 
-	#ifdef DEBUG
-		dev_dbg(&spi->dev, "get: lna gain");
-	#endif
+#ifdef DEBUG
+	dev_dbg(&spi->dev, "get: lna gain");
+#endif
 
 	currentValue = rf69_read_reg(spi, REG_LNA);
 
@@ -419,18 +419,18 @@ int rf69_set_dc_cut_off_frequency_intern(struct spi_device *spi, u8 reg, enum dc
 
 int rf69_set_dc_cut_off_frequency(struct spi_device *spi, enum dccPercent dccPercent)
 {
-	#ifdef DEBUG
-		dev_dbg(&spi->dev, "set: cut off freq");
-	#endif
+#ifdef DEBUG
+	dev_dbg(&spi->dev, "set: cut off freq");
+#endif
 
 	return rf69_set_dc_cut_off_frequency_intern(spi, REG_RXBW, dccPercent);
 }
 
 int rf69_set_dc_cut_off_frequency_during_afc(struct spi_device *spi, enum dccPercent dccPercent)
 {
-	#ifdef DEBUG
-		dev_dbg(&spi->dev, "set: cut off freq during afc");
-	#endif
+#ifdef DEBUG
+	dev_dbg(&spi->dev, "set: cut off freq during afc");
+#endif
 
 	return rf69_set_dc_cut_off_frequency_intern(spi, REG_AFCBW, dccPercent);
 }
@@ -481,27 +481,27 @@ static int rf69_set_bandwidth_intern(struct spi_device *spi, u8 reg,
 
 int rf69_set_bandwidth(struct spi_device *spi, enum mantisse mantisse, u8 exponent)
 {
-	#ifdef DEBUG
-		dev_dbg(&spi->dev, "set: band width");
-	#endif
+#ifdef DEBUG
+	dev_dbg(&spi->dev, "set: band width");
+#endif
 
 	return rf69_set_bandwidth_intern(spi, REG_RXBW, mantisse, exponent);
 }
 
 int rf69_set_bandwidth_during_afc(struct spi_device *spi, enum mantisse mantisse, u8 exponent)
 {
-	#ifdef DEBUG
-		dev_dbg(&spi->dev, "set: band width during afc");
-	#endif
+#ifdef DEBUG
+	dev_dbg(&spi->dev, "set: band width during afc");
+#endif
 
 	return rf69_set_bandwidth_intern(spi, REG_AFCBW, mantisse, exponent);
 }
 
 int rf69_set_ook_threshold_type(struct spi_device *spi, enum thresholdType thresholdType)
 {
-	#ifdef DEBUG
-		dev_dbg(&spi->dev, "set: threshold type");
-	#endif
+#ifdef DEBUG
+	dev_dbg(&spi->dev, "set: threshold type");
+#endif
 
 	switch (thresholdType) {
 	case fixed:	return rf69_read_mod_write(spi, REG_OOKPEAK, MASK_OOKPEAK_THRESTYPE, OOKPEAK_THRESHTYPE_FIXED);
@@ -515,9 +515,9 @@ int rf69_set_ook_threshold_type(struct spi_device *spi, enum thresholdType thres
 
 int rf69_set_ook_threshold_step(struct spi_device *spi, enum thresholdStep thresholdStep)
 {
-	#ifdef DEBUG
-		dev_dbg(&spi->dev, "set: threshold step");
-	#endif
+#ifdef DEBUG
+	dev_dbg(&spi->dev, "set: threshold step");
+#endif
 
 	switch (thresholdStep) {
 	case step_0_5db: return rf69_read_mod_write(spi, REG_OOKPEAK, MASK_OOKPEAK_THRESSTEP, OOKPEAK_THRESHSTEP_0_5_DB);
@@ -536,9 +536,9 @@ int rf69_set_ook_threshold_step(struct spi_device *spi, enum thresholdStep thres
 
 int rf69_set_ook_threshold_dec(struct spi_device *spi, enum thresholdDecrement thresholdDecrement)
 {
-	#ifdef DEBUG
-		dev_dbg(&spi->dev, "set: threshold decrement");
-	#endif
+#ifdef DEBUG
+	dev_dbg(&spi->dev, "set: threshold decrement");
+#endif
 
 	switch (thresholdDecrement) {
 	case dec_every8th: return rf69_read_mod_write(spi, REG_OOKPEAK, MASK_OOKPEAK_THRESDEC, OOKPEAK_THRESHDEC_EVERY_8TH);
@@ -562,9 +562,9 @@ int rf69_set_dio_mapping(struct spi_device *spi, u8 DIONumber, u8 value)
 	u8 regaddr;
 	u8 regValue;
 
-	#ifdef DEBUG
-		dev_dbg(&spi->dev, "set: DIO mapping");
-	#endif
+#ifdef DEBUG
+	dev_dbg(&spi->dev, "set: DIO mapping");
+#endif
 
 	switch (DIONumber) {
 	case 0:
@@ -602,9 +602,9 @@ int rf69_set_dio_mapping(struct spi_device *spi, u8 DIONumber, u8 value)
 
 bool rf69_get_flag(struct spi_device *spi, enum flag flag)
 {
-	#ifdef DEBUG
-		dev_dbg(&spi->dev, "get: flag");
-	#endif
+#ifdef DEBUG
+	dev_dbg(&spi->dev, "get: flag");
+#endif
 
 	switch (flag) {
 	case modeSwitchCompleted:     return (rf69_read_reg(spi, REG_IRQFLAGS1) & MASK_IRQFLAGS1_MODE_READY);
@@ -630,9 +630,9 @@ bool rf69_get_flag(struct spi_device *spi, enum flag flag)
 
 int rf69_reset_flag(struct spi_device *spi, enum flag flag)
 {
-	#ifdef DEBUG
-		dev_dbg(&spi->dev, "reset: flag");
-	#endif
+#ifdef DEBUG
+	dev_dbg(&spi->dev, "reset: flag");
+#endif
 
 	switch (flag) {
 	case rssiExceededThreshold: return rf69_write_reg(spi, REG_IRQFLAGS1, MASK_IRQFLAGS1_RSSI);
@@ -646,9 +646,9 @@ int rf69_reset_flag(struct spi_device *spi, enum flag flag)
 
 int rf69_set_rssi_threshold(struct spi_device *spi, u8 threshold)
 {
-	#ifdef DEBUG
-		dev_dbg(&spi->dev, "set: rssi threshold");
-	#endif
+#ifdef DEBUG
+	dev_dbg(&spi->dev, "set: rssi threshold");
+#endif
 
 	/* no value check needed - u8 exactly matches register size */
 
@@ -657,9 +657,9 @@ int rf69_set_rssi_threshold(struct spi_device *spi, u8 threshold)
 
 int rf69_set_rx_start_timeout(struct spi_device *spi, u8 timeout)
 {
-	#ifdef DEBUG
-		dev_dbg(&spi->dev, "set: start timeout");
-	#endif
+#ifdef DEBUG
+	dev_dbg(&spi->dev, "set: start timeout");
+#endif
 
 	/* no value check needed - u8 exactly matches register size */
 
@@ -668,9 +668,9 @@ int rf69_set_rx_start_timeout(struct spi_device *spi, u8 timeout)
 
 int rf69_set_rssi_timeout(struct spi_device *spi, u8 timeout)
 {
-	#ifdef DEBUG
-		dev_dbg(&spi->dev, "set: rssi timeout");
-	#endif
+#ifdef DEBUG
+	dev_dbg(&spi->dev, "set: rssi timeout");
+#endif
 
 	/* no value check needed - u8 exactly matches register size */
 
@@ -682,9 +682,9 @@ int rf69_set_preamble_length(struct spi_device *spi, u16 preambleLength)
 	int retval;
 	u8 msb, lsb;
 
-	#ifdef DEBUG
-		dev_dbg(&spi->dev, "set: preamble length");
-	#endif
+#ifdef DEBUG
+	dev_dbg(&spi->dev, "set: preamble length");
+#endif
 
 	/* no value check needed - u16 exactly matches register size */
 
@@ -713,9 +713,9 @@ int rf69_disable_sync(struct spi_device *spi)
 
 int rf69_set_fifo_fill_condition(struct spi_device *spi, enum fifoFillCondition fifoFillCondition)
 {
-	#ifdef DEBUG
-		dev_dbg(&spi->dev, "set: fifo fill condition");
-	#endif
+#ifdef DEBUG
+	dev_dbg(&spi->dev, "set: fifo fill condition");
+#endif
 
 	switch (fifoFillCondition) {
 	case always:		 return rf69_set_bit(spi, REG_SYNC_CONFIG, MASK_SYNC_CONFIG_FIFO_FILL_CONDITION);
@@ -728,9 +728,9 @@ int rf69_set_fifo_fill_condition(struct spi_device *spi, enum fifoFillCondition
 
 int rf69_set_sync_size(struct spi_device *spi, u8 syncSize)
 {
-	#ifdef DEBUG
-		dev_dbg(&spi->dev, "set: sync size");
-	#endif
+#ifdef DEBUG
+	dev_dbg(&spi->dev, "set: sync size");
+#endif
 
 	// check input value
 	if (syncSize > 0x07) {
@@ -744,9 +744,9 @@ int rf69_set_sync_size(struct spi_device *spi, u8 syncSize)
 
 int rf69_set_sync_tolerance(struct spi_device *spi, u8 syncTolerance)
 {
-	#ifdef DEBUG
-		dev_dbg(&spi->dev, "set: sync tolerance");
-	#endif
+#ifdef DEBUG
+	dev_dbg(&spi->dev, "set: sync tolerance");
+#endif
 
 	// check input value
 	if (syncTolerance > 0x07) {
@@ -762,9 +762,9 @@ int rf69_set_sync_values(struct spi_device *spi, u8 syncValues[8])
 {
 	int retval = 0;
 
-	#ifdef DEBUG
-		dev_dbg(&spi->dev, "set: sync values");
-	#endif
+#ifdef DEBUG
+	dev_dbg(&spi->dev, "set: sync values");
+#endif
 
 	retval += rf69_write_reg(spi, REG_SYNCVALUE1, syncValues[0]);
 	retval += rf69_write_reg(spi, REG_SYNCVALUE2, syncValues[1]);
@@ -780,9 +780,9 @@ int rf69_set_sync_values(struct spi_device *spi, u8 syncValues[8])
 
 int rf69_set_packet_format(struct spi_device *spi, enum packetFormat packetFormat)
 {
-	#ifdef DEBUG
-		dev_dbg(&spi->dev, "set: packet format");
-	#endif
+#ifdef DEBUG
+	dev_dbg(&spi->dev, "set: packet format");
+#endif
 
 	switch (packetFormat) {
 	case packetLengthVar: return rf69_set_bit(spi, REG_PACKETCONFIG1, MASK_PACKETCONFIG1_PAKET_FORMAT_VARIABLE);
@@ -805,9 +805,9 @@ int rf69_disable_crc(struct spi_device *spi)
 
 int rf69_set_adressFiltering(struct spi_device *spi, enum addressFiltering addressFiltering)
 {
-	#ifdef DEBUG
-		dev_dbg(&spi->dev, "set: address filtering");
-	#endif
+#ifdef DEBUG
+	dev_dbg(&spi->dev, "set: address filtering");
+#endif
 
 	switch (addressFiltering) {
 	case filteringOff:	     return rf69_read_mod_write(spi, REG_PACKETCONFIG1, MASK_PACKETCONFIG1_ADDRESSFILTERING, PACKETCONFIG1_ADDRESSFILTERING_OFF);
@@ -821,45 +821,45 @@ int rf69_set_adressFiltering(struct spi_device *spi, enum addressFiltering addre
 
 int rf69_set_payload_length(struct spi_device *spi, u8 payloadLength)
 {
-	#ifdef DEBUG
-		dev_dbg(&spi->dev, "set: payload length");
-	#endif
+#ifdef DEBUG
+	dev_dbg(&spi->dev, "set: payload length");
+#endif
 
 	return rf69_write_reg(spi, REG_PAYLOAD_LENGTH, payloadLength);
 }
 
 u8  rf69_get_payload_length(struct spi_device *spi)
 {
-	#ifdef DEBUG
-		dev_dbg(&spi->dev, "get: payload length");
-	#endif
+#ifdef DEBUG
+	dev_dbg(&spi->dev, "get: payload length");
+#endif
 
 	return (u8)rf69_read_reg(spi, REG_PAYLOAD_LENGTH);
 }
 
 int rf69_set_node_address(struct spi_device *spi, u8 nodeAddress)
 {
-	#ifdef DEBUG
-		dev_dbg(&spi->dev, "set: node address");
-	#endif
+#ifdef DEBUG
+	dev_dbg(&spi->dev, "set: node address");
+#endif
 
 	return rf69_write_reg(spi, REG_NODEADRS, nodeAddress);
 }
 
 int rf69_set_broadcast_address(struct spi_device *spi, u8 broadcastAddress)
 {
-	#ifdef DEBUG
-		dev_dbg(&spi->dev, "set: broadcast address");
-	#endif
+#ifdef DEBUG
+	dev_dbg(&spi->dev, "set: broadcast address");
+#endif
 
 	return rf69_write_reg(spi, REG_BROADCASTADRS, broadcastAddress);
 }
 
 int rf69_set_tx_start_condition(struct spi_device *spi, enum txStartCondition txStartCondition)
 {
-	#ifdef DEBUG
-		dev_dbg(&spi->dev, "set: start condition");
-	#endif
+#ifdef DEBUG
+	dev_dbg(&spi->dev, "set: start condition");
+#endif
 
 	switch (txStartCondition) {
 	case fifoLevel:	   return rf69_clear_bit(spi, REG_FIFO_THRESH, MASK_FIFO_THRESH_TXSTART);
@@ -874,9 +874,9 @@ int rf69_set_fifo_threshold(struct spi_device *spi, u8 threshold)
 {
 	int retval;
 
-	#ifdef DEBUG
-		dev_dbg(&spi->dev, "set: fifo threshold");
-	#endif
+#ifdef DEBUG
+	dev_dbg(&spi->dev, "set: fifo threshold");
+#endif
 
 	/* check input value */
 	if (threshold & 0x80) {
@@ -897,9 +897,9 @@ int rf69_set_fifo_threshold(struct spi_device *spi, u8 threshold)
 
 int rf69_set_dagc(struct spi_device *spi, enum dagc dagc)
 {
-	#ifdef DEBUG
-		dev_dbg(&spi->dev, "set: dagc");
-	#endif
+#ifdef DEBUG
+	dev_dbg(&spi->dev, "set: dagc");
+#endif
 
 	switch (dagc) {
 	case normalMode:		 return rf69_write_reg(spi, REG_TESTDAGC, DAGC_NORMAL);
@@ -915,17 +915,17 @@ int rf69_set_dagc(struct spi_device *spi, enum dagc dagc)
 
 int rf69_read_fifo (struct spi_device *spi, u8 *buffer, unsigned int size)
 {
-	#ifdef DEBUG_FIFO_ACCESS
-		int i;
-	#endif
+#ifdef DEBUG_FIFO_ACCESS
+	int i;
+#endif
 	struct spi_transfer transfer;
 	u8 local_buffer[FIFO_SIZE + 1];
 	int retval;
 
 	if (size > FIFO_SIZE) {
-		#ifdef DEBUG
-			dev_dbg(&spi->dev, "read fifo: passed in buffer bigger then internal buffer \n");
-		#endif
+#ifdef DEBUG
+		dev_dbg(&spi->dev, "read fifo: passed in buffer bigger then internal buffer\n");
+#endif
 		return -EMSGSIZE;
 	}
 
@@ -950,26 +950,26 @@ int rf69_read_fifo (struct spi_device *spi, u8 *buffer, unsigned int size)
 
 int rf69_write_fifo(struct spi_device *spi, u8 *buffer, unsigned int size)
 {
-	#ifdef DEBUG_FIFO_ACCESS
-		int i;
-	#endif
+#ifdef DEBUG_FIFO_ACCESS
+	int i;
+#endif
 	char spi_address = REG_FIFO | WRITE_BIT;
 	u8 local_buffer[FIFO_SIZE + 1];
 
 	if (size > FIFO_SIZE) {
-		#ifdef DEBUG
-			dev_dbg(&spi->dev, "read fifo: passed in buffer bigger then internal buffer \n");
-		#endif
+#ifdef DEBUG
+		dev_dbg(&spi->dev, "read fifo: passed in buffer bigger then internal buffer\n");
+#endif
 		return -EMSGSIZE;
 	}
 
 	local_buffer[0] = spi_address;
 	memcpy(&local_buffer[1], buffer, size);
 
-	#ifdef DEBUG_FIFO_ACCESS
-		for (i = 0; i < size; i++)
-			dev_dbg(&spi->dev, "0x%x\n", buffer[i]);
-	#endif
+#ifdef DEBUG_FIFO_ACCESS
+	for (i = 0; i < size; i++)
+		dev_dbg(&spi->dev, "0x%x\n", buffer[i]);
+#endif
 
 	return spi_write (spi, local_buffer, size + 1);
 }
@@ -982,19 +982,16 @@ u8 rf69_read_reg(struct spi_device *spi, u8 addr)
 
 	retval = spi_w8r8(spi, addr);
 
-	#ifdef DEBUG_VALUES
-		if (retval < 0)
-			/* should never happen, since we already checked,
-			 * that module is connected. Therefore no error
-			 * handling, just an optional error message...
-			 */
-			dev_dbg(&spi->dev, "read 0x%x FAILED\n",
-				addr);
-		else
-			dev_dbg(&spi->dev, "read 0x%x from reg 0x%x\n",
-				retval,
-				addr);
-	#endif
+#ifdef DEBUG_VALUES
+	if (retval < 0)
+		/* should never happen, since we already checked,
+		 * that module is connected. Therefore no error
+		 * handling, just an optional error message...
+		 */
+		dev_dbg(&spi->dev, "read 0x%x FAILED\n", addr);
+	else
+		dev_dbg(&spi->dev, "read 0x%x from reg 0x%x\n", retval, addr);
+#endif
 
 	return retval;
 }
@@ -1009,22 +1006,17 @@ int rf69_write_reg(struct spi_device *spi, u8 addr, u8 value)
 
 	retval = spi_write(spi, &buffer, 2);
 
-	#ifdef DEBUG_VALUES
-		if (retval < 0)
-			/* should never happen, since we already checked,
-			 * that module is connected. Therefore no error
-			 * handling, just an optional error message...
-			 */
-			dev_dbg(&spi->dev, "write 0x%x to 0x%x FAILED\n",
-				value,
-				addr);
-		else
-			dev_dbg(&spi->dev, "wrote 0x%x to reg 0x%x\n",
-				value,
-				addr);
-	#endif
+#ifdef DEBUG_VALUES
+	if (retval < 0)
+		/* should never happen, since we already checked,
+		 * that module is connected. Therefore no error
+		 * handling, just an optional error message...
+		 */
+		dev_dbg(&spi->dev, "write 0x%x to 0x%x FAILED\n", value, addr);
+	else
+		dev_dbg(&spi->dev, "wrote 0x%x to reg 0x%x\n", value, addr);
+#endif
 
 	return retval;
 }
 
-

commit 84f1e4b08919a3981a5dc0234e6c059e958f73e7
Author: Marcin Ciupak <marcin.s.ciupak@gmail.com>
Date:   Fri Dec 8 15:31:54 2017 +0000

    staging: pi433: Fix validation of rf69_get_modulation value
    
    Checking of modulation in rf69_set_modulation_shaping is done by
    if-else and since else part covers OOK and UNDEF values it possible to
    set modulation shaping for undefined modulation type.
    To fix this validation should be done by switch clause and in case of
    undefined modulation error returned.
    
    Signed-off-by: Marcin Ciupak <marcin.s.ciupak@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/pi433/rf69.c b/drivers/staging/pi433/rf69.c
index 1ae23764b911..8b6d68f10e8a 100644
--- a/drivers/staging/pi433/rf69.c
+++ b/drivers/staging/pi433/rf69.c
@@ -128,7 +128,8 @@ int rf69_set_modulation_shaping(struct spi_device *spi,
 		dev_dbg(&spi->dev, "set: mod shaping");
 	#endif
 
-	if (rf69_get_modulation(spi) == FSK) {
+	switch (rf69_get_modulation(spi)) {
+	case FSK:
 		switch (mod_shaping) {
 		case SHAPING_OFF: return rf69_read_mod_write(spi, REG_DATAMODUL, MASK_DATAMODUL_MODULATION_SHAPE, DATAMODUL_MODULATION_SHAPE_NONE);
 		case SHAPING_1_0: return rf69_read_mod_write(spi, REG_DATAMODUL, MASK_DATAMODUL_MODULATION_SHAPE, DATAMODUL_MODULATION_SHAPE_1_0);
@@ -138,7 +139,7 @@ int rf69_set_modulation_shaping(struct spi_device *spi,
 			dev_dbg(&spi->dev, "set: illegal input param");
 			return -EINVAL;
 		}
-	} else {
+	case OOK:
 		switch (mod_shaping) {
 		case SHAPING_OFF: return rf69_read_mod_write(spi, REG_DATAMODUL, MASK_DATAMODUL_MODULATION_SHAPE, DATAMODUL_MODULATION_SHAPE_NONE);
 		case SHAPING_BR:  return rf69_read_mod_write(spi, REG_DATAMODUL, MASK_DATAMODUL_MODULATION_SHAPE, DATAMODUL_MODULATION_SHAPE_BR);
@@ -147,6 +148,9 @@ int rf69_set_modulation_shaping(struct spi_device *spi,
 			dev_dbg(&spi->dev, "set: illegal input param");
 			return -EINVAL;
 		}
+	default:
+		dev_dbg(&spi->dev, "set: modulation undefined");
+		return -EINVAL;
 	}
 }
 

commit 1c12da3576ce2a37dd59a5648b7c41656d06ae47
Author: Marcin Ciupak <marcin.s.ciupak@gmail.com>
Date:   Fri Dec 8 15:31:28 2017 +0000

    staging: pi433: Fix missing 'undefined' value in enum modulation
    
    It is possible that rf69_get_modulation() function will return
    'undefined' value and this value is missing in enum modulation. Fix this
    by adding appropriate entry in enum modulation.
    
    Signed-off-by: Marcin Ciupak <marcin.s.ciupak@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/pi433/rf69.c b/drivers/staging/pi433/rf69.c
index 70827034f5d0..1ae23764b911 100644
--- a/drivers/staging/pi433/rf69.c
+++ b/drivers/staging/pi433/rf69.c
@@ -117,7 +117,7 @@ enum modulation rf69_get_modulation(struct spi_device *spi)
 	switch (currentValue & MASK_DATAMODUL_MODULATION_TYPE >> 3) { // TODO improvement: change 3 to define
 	case DATAMODUL_MODULATION_TYPE_OOK: return OOK;
 	case DATAMODUL_MODULATION_TYPE_FSK: return FSK;
-	default:			    return undefined;
+	default:			    return UNDEF;
 	}
 }
 

commit 9b65e91010b569dc3661a7e67ef0f499518c59ff
Author: Simon Sandström <simon@nikanor.nu>
Date:   Thu Dec 7 22:15:02 2017 +0100

    staging: pi433: Add spaces around & and + operator
    
    Fixes checkpatch warning: "spaces preferred around that '&'".
    
    Signed-off-by: Simon Sandström <simon@nikanor.nu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/pi433/rf69.c b/drivers/staging/pi433/rf69.c
index 5ec225024fe6..70827034f5d0 100644
--- a/drivers/staging/pi433/rf69.c
+++ b/drivers/staging/pi433/rf69.c
@@ -82,7 +82,6 @@ int rf69_set_mode(struct spi_device *spi, enum mode mode)
 	// we are using packet mode, so this check is not really needed
 	// but waiting for mode ready is necessary when going from sleep because the FIFO may not be immediately available from previous mode
 	//while (_mode == RF69_MODE_SLEEP && (READ_REG(REG_IRQFLAGS1) & RF_IRQFLAGS1_MODEREADY) == 0x00); // Wait for ModeReady
-
 }
 
 int rf69_set_data_mode(struct spi_device *spi, u8 data_mode)
@@ -173,8 +172,8 @@ int rf69_set_bit_rate(struct spi_device *spi, u16 bitRate)
 	// calculate reg settings
 	bitRate_reg = (F_OSC / bitRate);
 
-	msb = (bitRate_reg&0xff00)   >>  8;
-	lsb = (bitRate_reg&0xff);
+	msb = (bitRate_reg & 0xff00) >> 8;
+	lsb = (bitRate_reg & 0xff);
 
 	// transmit to RF 69
 	retval = rf69_write_reg(spi, REG_BITRATE_MSB, msb);
@@ -214,8 +213,8 @@ int rf69_set_deviation(struct spi_device *spi, u32 deviation)
 	f_reg = deviation * factor;
 	do_div(f_reg, f_step);
 
-	msb = (f_reg&0xff00)   >>  8;
-	lsb = (f_reg&0xff);
+	msb = (f_reg & 0xff00) >> 8;
+	lsb = (f_reg & 0xff);
 
 	// check msb
 	if (msb & ~FDEVMASB_MASK) {
@@ -264,9 +263,9 @@ int rf69_set_frequency(struct spi_device *spi, u32 frequency)
 	f_reg = frequency * factor;
 	do_div(f_reg, f_step);
 
-	msb = (f_reg&0xff0000) >> 16;
-	mid = (f_reg&0xff00)   >>  8;
-	lsb = (f_reg&0xff);
+	msb = (f_reg & 0xff0000) >> 16;
+	mid = (f_reg & 0xff00)   >>  8;
+	lsb = (f_reg & 0xff);
 
 	// write to chip
 	retval = rf69_write_reg(spi, REG_FRF_MSB, msb);
@@ -686,8 +685,8 @@ int rf69_set_preamble_length(struct spi_device *spi, u16 preambleLength)
 	/* no value check needed - u16 exactly matches register size */
 
 	/* calculate reg settings */
-	msb = (preambleLength&0xff00)   >>  8;
-	lsb = (preambleLength&0xff);
+	msb = (preambleLength & 0xff00) >> 8;
+	lsb = (preambleLength & 0xff);
 
 	/* transmit to chip */
 	retval = rf69_write_reg(spi, REG_PREAMBLE_MSB, msb);
@@ -931,14 +930,14 @@ int rf69_read_fifo (struct spi_device *spi, u8 *buffer, unsigned int size)
 	memset(&transfer, 0, sizeof(transfer));
 	transfer.tx_buf = local_buffer;
 	transfer.rx_buf = local_buffer;
-	transfer.len	= size+1;
+	transfer.len	= size + 1;
 
 	retval = spi_sync_transfer(spi, &transfer, 1);
 
-	#ifdef DEBUG_FIFO_ACCESS
-		for (i = 0; i < size; i++)
-			dev_dbg(&spi->dev, "%d - 0x%x\n", i, local_buffer[i+1]);
-	#endif
+#ifdef DEBUG_FIFO_ACCESS
+	for (i = 0; i < size; i++)
+		dev_dbg(&spi->dev, "%d - 0x%x\n", i, local_buffer[i + 1]);
+#endif
 
 	memcpy(buffer, &local_buffer[1], size);
 

commit 02dd7bc27ae97e8cb8f4df84f9a9068116cfb50e
Author: Simon Sandström <simon@nikanor.nu>
Date:   Thu Dec 7 21:49:22 2017 +0100

    staging: pi433: Fix ISO-8859 encoded non-english comments
    
    Some comments, like "without memcpy would be nice", are removed.
    Other comments are just translated to english.
    rf69.c is now plain ASCII.
    
    Signed-off-by: Simon Sandström <simon@nikanor.nu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/pi433/rf69.c b/drivers/staging/pi433/rf69.c
index 7140fa2ea592..5ec225024fe6 100644
--- a/drivers/staging/pi433/rf69.c
+++ b/drivers/staging/pi433/rf69.c
@@ -190,7 +190,6 @@ int rf69_set_bit_rate(struct spi_device *spi, u16 bitRate)
 int rf69_set_deviation(struct spi_device *spi, u32 deviation)
 {
 	int retval;
-//	u32 f_max; TODO: Abhngigkeit von Bitrate beachten!!
 	u64 f_reg;
 	u64 f_step;
 	u8 msb;
@@ -201,7 +200,8 @@ int rf69_set_deviation(struct spi_device *spi, u32 deviation)
 		dev_dbg(&spi->dev, "set: deviation");
 	#endif
 
-	if (deviation < 600 || deviation > 500000) { //TODO: Abhngigkeit von Bitrate beachten!!
+	// TODO: Dependency to bitrate
+	if (deviation < 600 || deviation > 500000) {
 		dev_dbg(&spi->dev, "set_deviation: illegal input param");
 		return -EINVAL;
 	}
@@ -298,7 +298,8 @@ int rf69_set_output_power_level(struct spi_device *spi, u8 powerLevel)
 		dev_dbg(&spi->dev, "set: power level");
 	#endif
 
-	powerLevel += 18; // TODO Abhngigkeit von PA0,1,2 setting
+	// TODO: Dependency to PA0,1,2 setting
+	powerLevel += 18;
 
 	// check input value
 	if (powerLevel > 0x1f) {
@@ -939,7 +940,7 @@ int rf69_read_fifo (struct spi_device *spi, u8 *buffer, unsigned int size)
 			dev_dbg(&spi->dev, "%d - 0x%x\n", i, local_buffer[i+1]);
 	#endif
 
-	memcpy(buffer, &local_buffer[1], size);  // TODO: ohne memcopy wre schner
+	memcpy(buffer, &local_buffer[1], size);
 
 	return retval;
 }
@@ -960,7 +961,7 @@ int rf69_write_fifo(struct spi_device *spi, u8 *buffer, unsigned int size)
 	}
 
 	local_buffer[0] = spi_address;
-	memcpy(&local_buffer[1], buffer, size);  // TODO: ohne memcopy wre schner
+	memcpy(&local_buffer[1], buffer, size);
 
 	#ifdef DEBUG_FIFO_ACCESS
 		for (i = 0; i < size; i++)

commit c5a5bd6bdab597606ff80151dcf34159e21f3e8b
Author: Simon Sandström <simon@nikanor.nu>
Date:   Wed Dec 6 21:42:22 2017 +0100

    staging: pi433: Combine all rf69_set_amplifier_x()
    
    Replaces the functions rf69_set_amplifier_1, _2, _3 with two
    functions: rf69_enable_amplifier(dev, amp_mask) and
    rf69_disable_amplifier(dev, amp_mask).
    
    Signed-off-by: Simon Sandström <simon@nikanor.nu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/pi433/rf69.c b/drivers/staging/pi433/rf69.c
index 9f2ffb89033e..7140fa2ea592 100644
--- a/drivers/staging/pi433/rf69.c
+++ b/drivers/staging/pi433/rf69.c
@@ -282,52 +282,14 @@ int rf69_set_frequency(struct spi_device *spi, u32 frequency)
 	return 0;
 }
 
-int rf69_set_amplifier_0(struct spi_device *spi,
-			 enum option_on_off option_on_off)
+int rf69_enable_amplifier(struct spi_device *spi, u8 amplifier_mask)
 {
-	#ifdef DEBUG
-		dev_dbg(&spi->dev, "set: amp #0");
-	#endif
-
-	switch (option_on_off) {
-	case OPTION_ON: return rf69_set_bit(spi, REG_PALEVEL, MASK_PALEVEL_PA0);
-	case OPTION_OFF: return rf69_clear_bit(spi, REG_PALEVEL, MASK_PALEVEL_PA0);
-	default:
-		dev_dbg(&spi->dev, "set: illegal input param");
-		return -EINVAL;
-	}
-}
-
-int rf69_set_amplifier_1(struct spi_device *spi,
-			 enum option_on_off option_on_off)
-{
-	#ifdef DEBUG
-		dev_dbg(&spi->dev, "set: amp #1");
-	#endif
-
-	switch (option_on_off) {
-	case OPTION_ON:	return rf69_set_bit(spi, REG_PALEVEL, MASK_PALEVEL_PA1);
-	case OPTION_OFF: return rf69_clear_bit(spi, REG_PALEVEL, MASK_PALEVEL_PA1);
-	default:
-		dev_dbg(&spi->dev, "set: illegal input param");
-		return -EINVAL;
-	}
+	return rf69_set_bit(spi, REG_PALEVEL, amplifier_mask);
 }
 
-int rf69_set_amplifier_2(struct spi_device *spi,
-			 enum option_on_off option_on_off)
+int rf69_disable_amplifier(struct spi_device *spi, u8 amplifier_mask)
 {
-	#ifdef DEBUG
-		dev_dbg(&spi->dev, "set: amp #2");
-	#endif
-
-	switch (option_on_off) {
-	case OPTION_ON: return rf69_set_bit(spi, REG_PALEVEL, MASK_PALEVEL_PA2);
-	case OPTION_OFF: return rf69_clear_bit(spi, REG_PALEVEL, MASK_PALEVEL_PA2);
-	default:
-		dev_dbg(&spi->dev, "set: illegal input param");
-		return -EINVAL;
-	}
+	return rf69_clear_bit(spi, REG_PALEVEL, amplifier_mask);
 }
 
 int rf69_set_output_power_level(struct spi_device *spi, u8 powerLevel)

commit b92025a80c36f3e833f9a91a9d4802f0c7f40441
Author: Simon Sandström <simon@nikanor.nu>
Date:   Wed Dec 6 21:42:21 2017 +0100

    staging: pi433: Remove enum data_mode
    
    Call rf69_set_data_mode with DATAMODUL_MODE value directly.
    
    Signed-off-by: Simon Sandström <simon@nikanor.nu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/pi433/rf69.c b/drivers/staging/pi433/rf69.c
index 12a1091d9936..9f2ffb89033e 100644
--- a/drivers/staging/pi433/rf69.c
+++ b/drivers/staging/pi433/rf69.c
@@ -85,20 +85,9 @@ int rf69_set_mode(struct spi_device *spi, enum mode mode)
 
 }
 
-int rf69_set_data_mode(struct spi_device *spi, enum dataMode dataMode)
+int rf69_set_data_mode(struct spi_device *spi, u8 data_mode)
 {
-	#ifdef DEBUG
-		dev_dbg(&spi->dev, "set: data mode");
-	#endif
-
-	switch (dataMode) {
-	case packet:		return rf69_read_mod_write(spi, REG_DATAMODUL, MASK_DATAMODUL_MODE, DATAMODUL_MODE_PACKET);
-	case continuous:	return rf69_read_mod_write(spi, REG_DATAMODUL, MASK_DATAMODUL_MODE, DATAMODUL_MODE_CONTINUOUS);
-	case continuousNoSync:	return rf69_read_mod_write(spi, REG_DATAMODUL, MASK_DATAMODUL_MODE, DATAMODUL_MODE_CONTINUOUS_NOSYNC);
-	default:
-		dev_dbg(&spi->dev, "set: illegal input param");
-		return -EINVAL;
-	}
+	return rf69_read_mod_write(spi, REG_DATAMODUL, MASK_DATAMODUL_MODE, data_mode);
 }
 
 int rf69_set_modulation(struct spi_device *spi, enum modulation modulation)

commit 966debe09eae5124e05b9c1374efa3610dccdc2a
Author: Simon Sandström <simon@nikanor.nu>
Date:   Wed Dec 6 21:42:20 2017 +0100

    staging: pi433: Split rf69_set_sync_enabled into two functions
    
    Splits rf69_set_sync_enabled(dev, enabled) into
    rf69_enable_sync(dev) and rf69_disable_sync(dev).
    
    Signed-off-by: Simon Sandström <simon@nikanor.nu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/pi433/rf69.c b/drivers/staging/pi433/rf69.c
index 8c9c9bb91c53..12a1091d9936 100644
--- a/drivers/staging/pi433/rf69.c
+++ b/drivers/staging/pi433/rf69.c
@@ -746,20 +746,14 @@ int rf69_set_preamble_length(struct spi_device *spi, u16 preambleLength)
 	return retval;
 }
 
-int rf69_set_sync_enable(struct spi_device *spi,
-			 enum option_on_off option_on_off)
+int rf69_enable_sync(struct spi_device *spi)
 {
-	#ifdef DEBUG
-		dev_dbg(&spi->dev, "set: sync enable");
-	#endif
+	return rf69_set_bit(spi, REG_SYNC_CONFIG, MASK_SYNC_CONFIG_SYNC_ON);
+}
 
-	switch (option_on_off) {
-	case OPTION_ON: return rf69_set_bit(spi, REG_SYNC_CONFIG, MASK_SYNC_CONFIG_SYNC_ON);
-	case OPTION_OFF: return rf69_clear_bit(spi, REG_SYNC_CONFIG, MASK_SYNC_CONFIG_SYNC_ON);
-	default:
-		dev_dbg(&spi->dev, "set: illegal input param");
-		return -EINVAL;
-	}
+int rf69_disable_sync(struct spi_device *spi)
+{
+	return rf69_clear_bit(spi, REG_SYNC_CONFIG, MASK_SYNC_CONFIG_SYNC_ON);
 }
 
 int rf69_set_fifo_fill_condition(struct spi_device *spi, enum fifoFillCondition fifoFillCondition)

commit 39252a4bcf63d9dbc168b9ef56eb4ca42e045b9d
Author: Simon Sandström <simon@nikanor.nu>
Date:   Wed Dec 6 21:42:19 2017 +0100

    staging: pi433: Split rf69_set_crc_enabled into two functions
    
    Splits rf69_set_crc_enabled(dev, enabled) into
    rf69_enable_crc(dev) and rf69_disable_crc(dev).
    
    Signed-off-by: Simon Sandström <simon@nikanor.nu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/pi433/rf69.c b/drivers/staging/pi433/rf69.c
index c97fd8031ecb..8c9c9bb91c53 100644
--- a/drivers/staging/pi433/rf69.c
+++ b/drivers/staging/pi433/rf69.c
@@ -844,20 +844,14 @@ int rf69_set_packet_format(struct spi_device *spi, enum packetFormat packetForma
 	}
 }
 
-int rf69_set_crc_enable(struct spi_device *spi,
-			enum option_on_off option_on_off)
+int rf69_enable_crc(struct spi_device *spi)
 {
-	#ifdef DEBUG
-		dev_dbg(&spi->dev, "set: crc enable");
-	#endif
+	return rf69_set_bit(spi, REG_PACKETCONFIG1, MASK_PACKETCONFIG1_CRC_ON);
+}
 
-	switch (option_on_off) {
-	case OPTION_ON: return rf69_set_bit(spi, REG_PACKETCONFIG1, MASK_PACKETCONFIG1_CRC_ON);
-	case OPTION_OFF: return rf69_clear_bit(spi, REG_PACKETCONFIG1, MASK_PACKETCONFIG1_CRC_ON);
-	default:
-		dev_dbg(&spi->dev, "set: illegal input param");
-		return -EINVAL;
-	}
+int rf69_disable_crc(struct spi_device *spi)
+{
+	return rf69_clear_bit(spi, REG_PACKETCONFIG1, MASK_PACKETCONFIG1_CRC_ON);
 }
 
 int rf69_set_adressFiltering(struct spi_device *spi, enum addressFiltering addressFiltering)

commit 494b11b6621da440f4b90435e4628cc91f510395
Author: Simon Sandström <simon@nikanor.nu>
Date:   Tue Dec 5 23:08:43 2017 +0100

    staging: pi433: Rename enum modShaping in rf69_enum.h
    
    Renames enum modShaping and its values to get rid of checkpatch.pl
    warnings: "Avoid CamelCase: <modShaping>".
    
    Signed-off-by: Simon Sandström <simon@nikanor.nu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/pi433/rf69.c b/drivers/staging/pi433/rf69.c
index 45d2f5a930eb..c97fd8031ecb 100644
--- a/drivers/staging/pi433/rf69.c
+++ b/drivers/staging/pi433/rf69.c
@@ -133,27 +133,28 @@ enum modulation rf69_get_modulation(struct spi_device *spi)
 	}
 }
 
-int rf69_set_modulation_shaping(struct spi_device *spi, enum modShaping modShaping)
+int rf69_set_modulation_shaping(struct spi_device *spi,
+				enum mod_shaping mod_shaping)
 {
 	#ifdef DEBUG
 		dev_dbg(&spi->dev, "set: mod shaping");
 	#endif
 
 	if (rf69_get_modulation(spi) == FSK) {
-		switch (modShaping) {
-		case shapingOff: return rf69_read_mod_write(spi, REG_DATAMODUL, MASK_DATAMODUL_MODULATION_SHAPE, DATAMODUL_MODULATION_SHAPE_NONE);
-		case shaping1_0: return rf69_read_mod_write(spi, REG_DATAMODUL, MASK_DATAMODUL_MODULATION_SHAPE, DATAMODUL_MODULATION_SHAPE_1_0);
-		case shaping0_5: return rf69_read_mod_write(spi, REG_DATAMODUL, MASK_DATAMODUL_MODULATION_SHAPE, DATAMODUL_MODULATION_SHAPE_0_3);
-		case shaping0_3: return rf69_read_mod_write(spi, REG_DATAMODUL, MASK_DATAMODUL_MODULATION_SHAPE, DATAMODUL_MODULATION_SHAPE_0_5);
+		switch (mod_shaping) {
+		case SHAPING_OFF: return rf69_read_mod_write(spi, REG_DATAMODUL, MASK_DATAMODUL_MODULATION_SHAPE, DATAMODUL_MODULATION_SHAPE_NONE);
+		case SHAPING_1_0: return rf69_read_mod_write(spi, REG_DATAMODUL, MASK_DATAMODUL_MODULATION_SHAPE, DATAMODUL_MODULATION_SHAPE_1_0);
+		case SHAPING_0_5: return rf69_read_mod_write(spi, REG_DATAMODUL, MASK_DATAMODUL_MODULATION_SHAPE, DATAMODUL_MODULATION_SHAPE_0_3);
+		case SHAPING_0_3: return rf69_read_mod_write(spi, REG_DATAMODUL, MASK_DATAMODUL_MODULATION_SHAPE, DATAMODUL_MODULATION_SHAPE_0_5);
 		default:
 			dev_dbg(&spi->dev, "set: illegal input param");
 			return -EINVAL;
 		}
 	} else {
-		switch (modShaping) {
-		case shapingOff: return rf69_read_mod_write(spi, REG_DATAMODUL, MASK_DATAMODUL_MODULATION_SHAPE, DATAMODUL_MODULATION_SHAPE_NONE);
-		case shapingBR:	 return rf69_read_mod_write(spi, REG_DATAMODUL, MASK_DATAMODUL_MODULATION_SHAPE, DATAMODUL_MODULATION_SHAPE_BR);
-		case shaping2BR: return rf69_read_mod_write(spi, REG_DATAMODUL, MASK_DATAMODUL_MODULATION_SHAPE, DATAMODUL_MODULATION_SHAPE_2BR);
+		switch (mod_shaping) {
+		case SHAPING_OFF: return rf69_read_mod_write(spi, REG_DATAMODUL, MASK_DATAMODUL_MODULATION_SHAPE, DATAMODUL_MODULATION_SHAPE_NONE);
+		case SHAPING_BR:  return rf69_read_mod_write(spi, REG_DATAMODUL, MASK_DATAMODUL_MODULATION_SHAPE, DATAMODUL_MODULATION_SHAPE_BR);
+		case SHAPING_2BR: return rf69_read_mod_write(spi, REG_DATAMODUL, MASK_DATAMODUL_MODULATION_SHAPE, DATAMODUL_MODULATION_SHAPE_2BR);
 		default:
 			dev_dbg(&spi->dev, "set: illegal input param");
 			return -EINVAL;

commit d7b8943cf44d468961a4c153f45698928f0883d2
Author: Marcus Wolf <linux@wolf-entwicklungen.de>
Date:   Mon Dec 4 23:45:16 2017 +0200

    staging: pi433: rf69.c: Replace macros READ_REG and WRITE_REG with smarter functions
    
    To increase the readability of the register accesses, the abstraction
    of the helpers was increased from simple read and write to set bit,
    clear bit and read modify write bit.
    
    Annotation: This patch contains a lot of long lines and camel case
    var names. These long lines and camel case vars weren't introduced
    by this patch, but were long and camel cased before.
    
    Signed-off-by: Marcus Wolf <linux@wolf-entwicklungen.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/pi433/rf69.c b/drivers/staging/pi433/rf69.c
index ebb3ddd1a957..45d2f5a930eb 100644
--- a/drivers/staging/pi433/rf69.c
+++ b/drivers/staging/pi433/rf69.c
@@ -33,8 +33,32 @@
 
 /*-------------------------------------------------------------------------*/
 
-#define READ_REG(x)	rf69_read_reg (spi, x)
-#define WRITE_REG(x, y)	rf69_write_reg(spi, x, y)
+static int rf69_set_bit(struct spi_device *spi, u8 reg, u8 mask)
+{
+	u8 tmp;
+
+	tmp = rf69_read_reg(spi, reg);
+	tmp = tmp | mask;
+	return rf69_write_reg(spi, reg, tmp);
+}
+
+static int rf69_clear_bit(struct spi_device *spi, u8 reg, u8 mask)
+{
+	u8 tmp;
+
+	tmp = rf69_read_reg(spi, reg);
+	tmp = tmp & ~mask;
+	return rf69_write_reg(spi, reg, tmp);
+}
+
+static inline int rf69_read_mod_write(struct spi_device *spi, u8 reg, u8 mask, u8 value)
+{
+	u8 tmp;
+
+	tmp = rf69_read_reg(spi, reg);
+	tmp = (tmp & ~mask) | value;
+	return rf69_write_reg(spi, reg, tmp);
+}
 
 /*-------------------------------------------------------------------------*/
 
@@ -45,11 +69,11 @@ int rf69_set_mode(struct spi_device *spi, enum mode mode)
 	#endif
 
 	switch (mode) {
-	case transmit:	  return WRITE_REG(REG_OPMODE, (READ_REG(REG_OPMODE) & ~MASK_OPMODE_MODE) | OPMODE_MODE_TRANSMIT);
-	case receive:	  return WRITE_REG(REG_OPMODE, (READ_REG(REG_OPMODE) & ~MASK_OPMODE_MODE) | OPMODE_MODE_RECEIVE);
-	case synthesizer: return WRITE_REG(REG_OPMODE, (READ_REG(REG_OPMODE) & ~MASK_OPMODE_MODE) | OPMODE_MODE_SYNTHESIZER);
-	case standby:	  return WRITE_REG(REG_OPMODE, (READ_REG(REG_OPMODE) & ~MASK_OPMODE_MODE) | OPMODE_MODE_STANDBY);
-	case mode_sleep:  return WRITE_REG(REG_OPMODE, (READ_REG(REG_OPMODE) & ~MASK_OPMODE_MODE) | OPMODE_MODE_SLEEP);
+	case transmit:	  return rf69_read_mod_write(spi, REG_OPMODE, MASK_OPMODE_MODE, OPMODE_MODE_TRANSMIT);
+	case receive:	  return rf69_read_mod_write(spi, REG_OPMODE, MASK_OPMODE_MODE, OPMODE_MODE_RECEIVE);
+	case synthesizer: return rf69_read_mod_write(spi, REG_OPMODE, MASK_OPMODE_MODE, OPMODE_MODE_SYNTHESIZER);
+	case standby:	  return rf69_read_mod_write(spi, REG_OPMODE, MASK_OPMODE_MODE, OPMODE_MODE_STANDBY);
+	case mode_sleep:  return rf69_read_mod_write(spi, REG_OPMODE, MASK_OPMODE_MODE, OPMODE_MODE_SLEEP);
 	default:
 		dev_dbg(&spi->dev, "set: illegal input param");
 		return -EINVAL;
@@ -68,9 +92,9 @@ int rf69_set_data_mode(struct spi_device *spi, enum dataMode dataMode)
 	#endif
 
 	switch (dataMode) {
-	case packet:		return WRITE_REG(REG_DATAMODUL, (READ_REG(REG_DATAMODUL) & ~MASK_DATAMODUL_MODE) | DATAMODUL_MODE_PACKET);
-	case continuous:	return WRITE_REG(REG_DATAMODUL, (READ_REG(REG_DATAMODUL) & ~MASK_DATAMODUL_MODE) | DATAMODUL_MODE_CONTINUOUS);
-	case continuousNoSync:  return WRITE_REG(REG_DATAMODUL, (READ_REG(REG_DATAMODUL) & ~MASK_DATAMODUL_MODE) | DATAMODUL_MODE_CONTINUOUS_NOSYNC);
+	case packet:		return rf69_read_mod_write(spi, REG_DATAMODUL, MASK_DATAMODUL_MODE, DATAMODUL_MODE_PACKET);
+	case continuous:	return rf69_read_mod_write(spi, REG_DATAMODUL, MASK_DATAMODUL_MODE, DATAMODUL_MODE_CONTINUOUS);
+	case continuousNoSync:	return rf69_read_mod_write(spi, REG_DATAMODUL, MASK_DATAMODUL_MODE, DATAMODUL_MODE_CONTINUOUS_NOSYNC);
 	default:
 		dev_dbg(&spi->dev, "set: illegal input param");
 		return -EINVAL;
@@ -84,8 +108,8 @@ int rf69_set_modulation(struct spi_device *spi, enum modulation modulation)
 	#endif
 
 	switch (modulation) {
-	case OOK:   return WRITE_REG(REG_DATAMODUL, (READ_REG(REG_DATAMODUL) & ~MASK_DATAMODUL_MODULATION_TYPE) | DATAMODUL_MODULATION_TYPE_OOK);
-	case FSK:   return WRITE_REG(REG_DATAMODUL, (READ_REG(REG_DATAMODUL) & ~MASK_DATAMODUL_MODULATION_TYPE) | DATAMODUL_MODULATION_TYPE_FSK);
+	case OOK: return rf69_read_mod_write(spi, REG_DATAMODUL, MASK_DATAMODUL_MODULATION_TYPE, DATAMODUL_MODULATION_TYPE_OOK);
+	case FSK: return rf69_read_mod_write(spi, REG_DATAMODUL, MASK_DATAMODUL_MODULATION_TYPE, DATAMODUL_MODULATION_TYPE_FSK);
 	default:
 		dev_dbg(&spi->dev, "set: illegal input param");
 		return -EINVAL;
@@ -100,7 +124,7 @@ enum modulation rf69_get_modulation(struct spi_device *spi)
 		dev_dbg(&spi->dev, "get: mode");
 	#endif
 
-	currentValue = READ_REG(REG_DATAMODUL);
+	currentValue = rf69_read_reg(spi, REG_DATAMODUL);
 
 	switch (currentValue & MASK_DATAMODUL_MODULATION_TYPE >> 3) { // TODO improvement: change 3 to define
 	case DATAMODUL_MODULATION_TYPE_OOK: return OOK;
@@ -117,19 +141,19 @@ int rf69_set_modulation_shaping(struct spi_device *spi, enum modShaping modShapi
 
 	if (rf69_get_modulation(spi) == FSK) {
 		switch (modShaping) {
-		case shapingOff: return WRITE_REG(REG_DATAMODUL, (READ_REG(REG_DATAMODUL) & ~MASK_DATAMODUL_MODULATION_SHAPE) | DATAMODUL_MODULATION_SHAPE_NONE);
-		case shaping1_0: return WRITE_REG(REG_DATAMODUL, (READ_REG(REG_DATAMODUL) & ~MASK_DATAMODUL_MODULATION_SHAPE) | DATAMODUL_MODULATION_SHAPE_1_0);
-		case shaping0_5: return WRITE_REG(REG_DATAMODUL, (READ_REG(REG_DATAMODUL) & ~MASK_DATAMODUL_MODULATION_SHAPE) | DATAMODUL_MODULATION_SHAPE_0_3);
-		case shaping0_3: return WRITE_REG(REG_DATAMODUL, (READ_REG(REG_DATAMODUL) & ~MASK_DATAMODUL_MODULATION_SHAPE) | DATAMODUL_MODULATION_SHAPE_0_5);
+		case shapingOff: return rf69_read_mod_write(spi, REG_DATAMODUL, MASK_DATAMODUL_MODULATION_SHAPE, DATAMODUL_MODULATION_SHAPE_NONE);
+		case shaping1_0: return rf69_read_mod_write(spi, REG_DATAMODUL, MASK_DATAMODUL_MODULATION_SHAPE, DATAMODUL_MODULATION_SHAPE_1_0);
+		case shaping0_5: return rf69_read_mod_write(spi, REG_DATAMODUL, MASK_DATAMODUL_MODULATION_SHAPE, DATAMODUL_MODULATION_SHAPE_0_3);
+		case shaping0_3: return rf69_read_mod_write(spi, REG_DATAMODUL, MASK_DATAMODUL_MODULATION_SHAPE, DATAMODUL_MODULATION_SHAPE_0_5);
 		default:
 			dev_dbg(&spi->dev, "set: illegal input param");
 			return -EINVAL;
 		}
 	} else {
 		switch (modShaping) {
-		case shapingOff: return WRITE_REG(REG_DATAMODUL, (READ_REG(REG_DATAMODUL) & ~MASK_DATAMODUL_MODULATION_SHAPE) | DATAMODUL_MODULATION_SHAPE_NONE);
-		case shapingBR:	 return WRITE_REG(REG_DATAMODUL, (READ_REG(REG_DATAMODUL) & ~MASK_DATAMODUL_MODULATION_SHAPE) | DATAMODUL_MODULATION_SHAPE_BR);
-		case shaping2BR: return WRITE_REG(REG_DATAMODUL, (READ_REG(REG_DATAMODUL) & ~MASK_DATAMODUL_MODULATION_SHAPE) | DATAMODUL_MODULATION_SHAPE_2BR);
+		case shapingOff: return rf69_read_mod_write(spi, REG_DATAMODUL, MASK_DATAMODUL_MODULATION_SHAPE, DATAMODUL_MODULATION_SHAPE_NONE);
+		case shapingBR:	 return rf69_read_mod_write(spi, REG_DATAMODUL, MASK_DATAMODUL_MODULATION_SHAPE, DATAMODUL_MODULATION_SHAPE_BR);
+		case shaping2BR: return rf69_read_mod_write(spi, REG_DATAMODUL, MASK_DATAMODUL_MODULATION_SHAPE, DATAMODUL_MODULATION_SHAPE_2BR);
 		default:
 			dev_dbg(&spi->dev, "set: illegal input param");
 			return -EINVAL;
@@ -163,11 +187,10 @@ int rf69_set_bit_rate(struct spi_device *spi, u16 bitRate)
 	lsb = (bitRate_reg&0xff);
 
 	// transmit to RF 69
-	retval = WRITE_REG(REG_BITRATE_MSB, msb);
+	retval = rf69_write_reg(spi, REG_BITRATE_MSB, msb);
 	if (retval)
 		return retval;
-
-	retval = WRITE_REG(REG_BITRATE_LSB, lsb);
+	retval = rf69_write_reg(spi, REG_BITRATE_LSB, lsb);
 	if (retval)
 		return retval;
 
@@ -211,11 +234,10 @@ int rf69_set_deviation(struct spi_device *spi, u32 deviation)
 	}
 
 	// write to chip
-	retval = WRITE_REG(REG_FDEV_MSB, msb);
+	retval = rf69_write_reg(spi, REG_FDEV_MSB, msb);
 	if (retval)
 		return retval;
-
-	retval = WRITE_REG(REG_FDEV_LSB, lsb);
+	retval = rf69_write_reg(spi, REG_FDEV_LSB, lsb);
 	if (retval)
 		return retval;
 
@@ -257,15 +279,13 @@ int rf69_set_frequency(struct spi_device *spi, u32 frequency)
 	lsb = (f_reg&0xff);
 
 	// write to chip
-	retval = WRITE_REG(REG_FRF_MSB, msb);
+	retval = rf69_write_reg(spi, REG_FRF_MSB, msb);
 	if (retval)
 		return retval;
-
-	retval = WRITE_REG(REG_FRF_MID, mid);
+	retval = rf69_write_reg(spi, REG_FRF_MID, mid);
 	if (retval)
 		return retval;
-
-	retval = WRITE_REG(REG_FRF_LSB, lsb);
+	retval = rf69_write_reg(spi, REG_FRF_LSB, lsb);
 	if (retval)
 		return retval;
 
@@ -280,8 +300,8 @@ int rf69_set_amplifier_0(struct spi_device *spi,
 	#endif
 
 	switch (option_on_off) {
-	case OPTION_ON:  return WRITE_REG(REG_PALEVEL, (READ_REG(REG_PALEVEL) |  MASK_PALEVEL_PA0));
-	case OPTION_OFF: return WRITE_REG(REG_PALEVEL, (READ_REG(REG_PALEVEL) & ~MASK_PALEVEL_PA0));
+	case OPTION_ON: return rf69_set_bit(spi, REG_PALEVEL, MASK_PALEVEL_PA0);
+	case OPTION_OFF: return rf69_clear_bit(spi, REG_PALEVEL, MASK_PALEVEL_PA0);
 	default:
 		dev_dbg(&spi->dev, "set: illegal input param");
 		return -EINVAL;
@@ -296,8 +316,8 @@ int rf69_set_amplifier_1(struct spi_device *spi,
 	#endif
 
 	switch (option_on_off) {
-	case OPTION_ON:  return WRITE_REG(REG_PALEVEL, (READ_REG(REG_PALEVEL) |  MASK_PALEVEL_PA1));
-	case OPTION_OFF: return WRITE_REG(REG_PALEVEL, (READ_REG(REG_PALEVEL) & ~MASK_PALEVEL_PA1));
+	case OPTION_ON:	return rf69_set_bit(spi, REG_PALEVEL, MASK_PALEVEL_PA1);
+	case OPTION_OFF: return rf69_clear_bit(spi, REG_PALEVEL, MASK_PALEVEL_PA1);
 	default:
 		dev_dbg(&spi->dev, "set: illegal input param");
 		return -EINVAL;
@@ -312,8 +332,8 @@ int rf69_set_amplifier_2(struct spi_device *spi,
 	#endif
 
 	switch (option_on_off) {
-	case OPTION_ON:	 return WRITE_REG(REG_PALEVEL, (READ_REG(REG_PALEVEL) |  MASK_PALEVEL_PA2));
-	case OPTION_OFF: return WRITE_REG(REG_PALEVEL, (READ_REG(REG_PALEVEL) & ~MASK_PALEVEL_PA2));
+	case OPTION_ON: return rf69_set_bit(spi, REG_PALEVEL, MASK_PALEVEL_PA2);
+	case OPTION_OFF: return rf69_clear_bit(spi, REG_PALEVEL, MASK_PALEVEL_PA2);
 	default:
 		dev_dbg(&spi->dev, "set: illegal input param");
 		return -EINVAL;
@@ -335,7 +355,7 @@ int rf69_set_output_power_level(struct spi_device *spi, u8 powerLevel)
 	}
 
 	// write value
-	return WRITE_REG(REG_PALEVEL, (READ_REG(REG_PALEVEL) & ~MASK_PALEVEL_OUTPUT_POWER) | powerLevel);
+	return rf69_read_mod_write(spi, REG_PALEVEL, MASK_PALEVEL_OUTPUT_POWER, powerLevel);
 }
 
 int rf69_set_pa_ramp(struct spi_device *spi, enum paRamp paRamp)
@@ -345,22 +365,22 @@ int rf69_set_pa_ramp(struct spi_device *spi, enum paRamp paRamp)
 	#endif
 
 	switch (paRamp) {
-	case ramp3400:	return WRITE_REG(REG_PARAMP, PARAMP_3400);
-	case ramp2000:	return WRITE_REG(REG_PARAMP, PARAMP_2000);
-	case ramp1000:	return WRITE_REG(REG_PARAMP, PARAMP_1000);
-	case ramp500:	return WRITE_REG(REG_PARAMP, PARAMP_500);
-	case ramp250:	return WRITE_REG(REG_PARAMP, PARAMP_250);
-	case ramp125:	return WRITE_REG(REG_PARAMP, PARAMP_125);
-	case ramp100:	return WRITE_REG(REG_PARAMP, PARAMP_100);
-	case ramp62:	return WRITE_REG(REG_PARAMP, PARAMP_62);
-	case ramp50:	return WRITE_REG(REG_PARAMP, PARAMP_50);
-	case ramp40:	return WRITE_REG(REG_PARAMP, PARAMP_40);
-	case ramp31:	return WRITE_REG(REG_PARAMP, PARAMP_31);
-	case ramp25:	return WRITE_REG(REG_PARAMP, PARAMP_25);
-	case ramp20:	return WRITE_REG(REG_PARAMP, PARAMP_20);
-	case ramp15:	return WRITE_REG(REG_PARAMP, PARAMP_15);
-	case ramp12:	return WRITE_REG(REG_PARAMP, PARAMP_12);
-	case ramp10:	return WRITE_REG(REG_PARAMP, PARAMP_10);
+	case ramp3400:	return rf69_write_reg(spi, REG_PARAMP, PARAMP_3400);
+	case ramp2000:	return rf69_write_reg(spi, REG_PARAMP, PARAMP_2000);
+	case ramp1000:	return rf69_write_reg(spi, REG_PARAMP, PARAMP_1000);
+	case ramp500:	return rf69_write_reg(spi, REG_PARAMP, PARAMP_500);
+	case ramp250:	return rf69_write_reg(spi, REG_PARAMP, PARAMP_250);
+	case ramp125:	return rf69_write_reg(spi, REG_PARAMP, PARAMP_125);
+	case ramp100:	return rf69_write_reg(spi, REG_PARAMP, PARAMP_100);
+	case ramp62:	return rf69_write_reg(spi, REG_PARAMP, PARAMP_62);
+	case ramp50:	return rf69_write_reg(spi, REG_PARAMP, PARAMP_50);
+	case ramp40:	return rf69_write_reg(spi, REG_PARAMP, PARAMP_40);
+	case ramp31:	return rf69_write_reg(spi, REG_PARAMP, PARAMP_31);
+	case ramp25:	return rf69_write_reg(spi, REG_PARAMP, PARAMP_25);
+	case ramp20:	return rf69_write_reg(spi, REG_PARAMP, PARAMP_20);
+	case ramp15:	return rf69_write_reg(spi, REG_PARAMP, PARAMP_15);
+	case ramp12:	return rf69_write_reg(spi, REG_PARAMP, PARAMP_12);
+	case ramp10:	return rf69_write_reg(spi, REG_PARAMP, PARAMP_10);
 	default:
 		dev_dbg(&spi->dev, "set: illegal input param");
 		return -EINVAL;
@@ -374,8 +394,8 @@ int rf69_set_antenna_impedance(struct spi_device *spi, enum antennaImpedance ant
 	#endif
 
 	switch (antennaImpedance) {
-	case fiftyOhm:	    return WRITE_REG(REG_LNA, (READ_REG(REG_LNA) & ~MASK_LNA_ZIN));
-	case twohundretOhm: return WRITE_REG(REG_LNA, (READ_REG(REG_LNA) |  MASK_LNA_ZIN));
+	case fiftyOhm:	    return rf69_clear_bit(spi, REG_LNA, MASK_LNA_ZIN);
+	case twohundretOhm: return rf69_set_bit(spi, REG_LNA, MASK_LNA_ZIN);
 	default:
 		dev_dbg(&spi->dev, "set: illegal input param");
 		return -EINVAL;
@@ -389,13 +409,13 @@ int rf69_set_lna_gain(struct spi_device *spi, enum lnaGain lnaGain)
 	#endif
 
 	switch (lnaGain) {
-	case automatic:	 return WRITE_REG(REG_LNA, ((READ_REG(REG_LNA) & ~MASK_LNA_GAIN) & LNA_GAIN_AUTO));
-	case max:	 return WRITE_REG(REG_LNA, ((READ_REG(REG_LNA) & ~MASK_LNA_GAIN) & LNA_GAIN_MAX));
-	case maxMinus6:  return WRITE_REG(REG_LNA, ((READ_REG(REG_LNA) & ~MASK_LNA_GAIN) & LNA_GAIN_MAX_MINUS_6));
-	case maxMinus12: return WRITE_REG(REG_LNA, ((READ_REG(REG_LNA) & ~MASK_LNA_GAIN) & LNA_GAIN_MAX_MINUS_12));
-	case maxMinus24: return WRITE_REG(REG_LNA, ((READ_REG(REG_LNA) & ~MASK_LNA_GAIN) & LNA_GAIN_MAX_MINUS_24));
-	case maxMinus36: return WRITE_REG(REG_LNA, ((READ_REG(REG_LNA) & ~MASK_LNA_GAIN) & LNA_GAIN_MAX_MINUS_36));
-	case maxMinus48: return WRITE_REG(REG_LNA, ((READ_REG(REG_LNA) & ~MASK_LNA_GAIN) & LNA_GAIN_MAX_MINUS_48));
+	case automatic:	 return rf69_read_mod_write(spi, REG_LNA, MASK_LNA_GAIN, LNA_GAIN_AUTO);
+	case max:	 return rf69_read_mod_write(spi, REG_LNA, MASK_LNA_GAIN, LNA_GAIN_MAX);
+	case maxMinus6:  return rf69_read_mod_write(spi, REG_LNA, MASK_LNA_GAIN, LNA_GAIN_MAX_MINUS_6);
+	case maxMinus12: return rf69_read_mod_write(spi, REG_LNA, MASK_LNA_GAIN, LNA_GAIN_MAX_MINUS_12);
+	case maxMinus24: return rf69_read_mod_write(spi, REG_LNA, MASK_LNA_GAIN, LNA_GAIN_MAX_MINUS_24);
+	case maxMinus36: return rf69_read_mod_write(spi, REG_LNA, MASK_LNA_GAIN, LNA_GAIN_MAX_MINUS_36);
+	case maxMinus48: return rf69_read_mod_write(spi, REG_LNA, MASK_LNA_GAIN, LNA_GAIN_MAX_MINUS_48);
 	default:
 		dev_dbg(&spi->dev, "set: illegal input param");
 		return -EINVAL;
@@ -410,7 +430,7 @@ enum lnaGain rf69_get_lna_gain(struct spi_device *spi)
 		dev_dbg(&spi->dev, "get: lna gain");
 	#endif
 
-	currentValue = READ_REG(REG_LNA);
+	currentValue = rf69_read_reg(spi, REG_LNA);
 
 	switch (currentValue & MASK_LNA_CURRENT_GAIN >> 3) { // improvement: change 3 to define
 	case LNA_GAIN_AUTO:	    return automatic;
@@ -427,14 +447,14 @@ enum lnaGain rf69_get_lna_gain(struct spi_device *spi)
 int rf69_set_dc_cut_off_frequency_intern(struct spi_device *spi, u8 reg, enum dccPercent dccPercent)
 {
 	switch (dccPercent) {
-	case dcc16Percent:	return WRITE_REG(reg, ((READ_REG(reg) & ~MASK_BW_DCC_FREQ) | BW_DCC_16_PERCENT));
-	case dcc8Percent:	return WRITE_REG(reg, ((READ_REG(reg) & ~MASK_BW_DCC_FREQ) | BW_DCC_8_PERCENT));
-	case dcc4Percent:	return WRITE_REG(reg, ((READ_REG(reg) & ~MASK_BW_DCC_FREQ) | BW_DCC_4_PERCENT));
-	case dcc2Percent:	return WRITE_REG(reg, ((READ_REG(reg) & ~MASK_BW_DCC_FREQ) | BW_DCC_2_PERCENT));
-	case dcc1Percent:	return WRITE_REG(reg, ((READ_REG(reg) & ~MASK_BW_DCC_FREQ) | BW_DCC_1_PERCENT));
-	case dcc0_5Percent:	return WRITE_REG(reg, ((READ_REG(reg) & ~MASK_BW_DCC_FREQ) | BW_DCC_0_5_PERCENT));
-	case dcc0_25Percent:	return WRITE_REG(reg, ((READ_REG(reg) & ~MASK_BW_DCC_FREQ) | BW_DCC_0_25_PERCENT));
-	case dcc0_125Percent:	return WRITE_REG(reg, ((READ_REG(reg) & ~MASK_BW_DCC_FREQ) | BW_DCC_0_125_PERCENT));
+	case dcc16Percent:	return rf69_read_mod_write(spi, reg, MASK_BW_DCC_FREQ, BW_DCC_16_PERCENT);
+	case dcc8Percent:	return rf69_read_mod_write(spi, reg, MASK_BW_DCC_FREQ, BW_DCC_8_PERCENT);
+	case dcc4Percent:	return rf69_read_mod_write(spi, reg, MASK_BW_DCC_FREQ, BW_DCC_4_PERCENT);
+	case dcc2Percent:	return rf69_read_mod_write(spi, reg, MASK_BW_DCC_FREQ, BW_DCC_2_PERCENT);
+	case dcc1Percent:	return rf69_read_mod_write(spi, reg, MASK_BW_DCC_FREQ, BW_DCC_1_PERCENT);
+	case dcc0_5Percent:	return rf69_read_mod_write(spi, reg, MASK_BW_DCC_FREQ, BW_DCC_0_5_PERCENT);
+	case dcc0_25Percent:	return rf69_read_mod_write(spi, reg, MASK_BW_DCC_FREQ, BW_DCC_0_25_PERCENT);
+	case dcc0_125Percent:	return rf69_read_mod_write(spi, reg, MASK_BW_DCC_FREQ, BW_DCC_0_125_PERCENT);
 	default:
 		dev_dbg(&spi->dev, "set: illegal input param");
 		return -EINVAL;
@@ -478,7 +498,7 @@ static int rf69_set_bandwidth_intern(struct spi_device *spi, u8 reg,
 	}
 
 	// read old value
-	newValue = READ_REG(reg);
+	newValue = rf69_read_reg(spi, reg);
 
 	// "delete" mantisse and exponent = just keep the DCC setting
 	newValue = newValue & MASK_BW_DCC_FREQ;
@@ -500,7 +520,7 @@ static int rf69_set_bandwidth_intern(struct spi_device *spi, u8 reg,
 	newValue = newValue | exponent;
 
 	// write back
-	return WRITE_REG(reg, newValue);
+	return rf69_write_reg(spi, reg, newValue);
 }
 
 int rf69_set_bandwidth(struct spi_device *spi, enum mantisse mantisse, u8 exponent)
@@ -528,9 +548,9 @@ int rf69_set_ook_threshold_type(struct spi_device *spi, enum thresholdType thres
 	#endif
 
 	switch (thresholdType) {
-	case fixed:	return WRITE_REG(REG_OOKPEAK, ((READ_REG(REG_OOKPEAK) & ~MASK_OOKPEAK_THRESTYPE) | OOKPEAK_THRESHTYPE_FIXED));
-	case peak:	return WRITE_REG(REG_OOKPEAK, ((READ_REG(REG_OOKPEAK) & ~MASK_OOKPEAK_THRESTYPE) | OOKPEAK_THRESHTYPE_PEAK));
-	case average:	return WRITE_REG(REG_OOKPEAK, ((READ_REG(REG_OOKPEAK) & ~MASK_OOKPEAK_THRESTYPE) | OOKPEAK_THRESHTYPE_AVERAGE));
+	case fixed:	return rf69_read_mod_write(spi, REG_OOKPEAK, MASK_OOKPEAK_THRESTYPE, OOKPEAK_THRESHTYPE_FIXED);
+	case peak:	return rf69_read_mod_write(spi, REG_OOKPEAK, MASK_OOKPEAK_THRESTYPE, OOKPEAK_THRESHTYPE_PEAK);
+	case average:	return rf69_read_mod_write(spi, REG_OOKPEAK, MASK_OOKPEAK_THRESTYPE, OOKPEAK_THRESHTYPE_AVERAGE);
 	default:
 		dev_dbg(&spi->dev, "set: illegal input param");
 		return -EINVAL;
@@ -544,14 +564,14 @@ int rf69_set_ook_threshold_step(struct spi_device *spi, enum thresholdStep thres
 	#endif
 
 	switch (thresholdStep) {
-	case step_0_5db: return WRITE_REG(REG_OOKPEAK, ((READ_REG(REG_OOKPEAK) & ~MASK_OOKPEAK_THRESSTEP) | OOKPEAK_THRESHSTEP_0_5_DB));
-	case step_1_0db: return WRITE_REG(REG_OOKPEAK, ((READ_REG(REG_OOKPEAK) & ~MASK_OOKPEAK_THRESSTEP) | OOKPEAK_THRESHSTEP_1_0_DB));
-	case step_1_5db: return WRITE_REG(REG_OOKPEAK, ((READ_REG(REG_OOKPEAK) & ~MASK_OOKPEAK_THRESSTEP) | OOKPEAK_THRESHSTEP_1_5_DB));
-	case step_2_0db: return WRITE_REG(REG_OOKPEAK, ((READ_REG(REG_OOKPEAK) & ~MASK_OOKPEAK_THRESSTEP) | OOKPEAK_THRESHSTEP_2_0_DB));
-	case step_3_0db: return WRITE_REG(REG_OOKPEAK, ((READ_REG(REG_OOKPEAK) & ~MASK_OOKPEAK_THRESSTEP) | OOKPEAK_THRESHSTEP_3_0_DB));
-	case step_4_0db: return WRITE_REG(REG_OOKPEAK, ((READ_REG(REG_OOKPEAK) & ~MASK_OOKPEAK_THRESSTEP) | OOKPEAK_THRESHSTEP_4_0_DB));
-	case step_5_0db: return WRITE_REG(REG_OOKPEAK, ((READ_REG(REG_OOKPEAK) & ~MASK_OOKPEAK_THRESSTEP) | OOKPEAK_THRESHSTEP_5_0_DB));
-	case step_6_0db: return WRITE_REG(REG_OOKPEAK, ((READ_REG(REG_OOKPEAK) & ~MASK_OOKPEAK_THRESSTEP) | OOKPEAK_THRESHSTEP_6_0_DB));
+	case step_0_5db: return rf69_read_mod_write(spi, REG_OOKPEAK, MASK_OOKPEAK_THRESSTEP, OOKPEAK_THRESHSTEP_0_5_DB);
+	case step_1_0db: return rf69_read_mod_write(spi, REG_OOKPEAK, MASK_OOKPEAK_THRESSTEP, OOKPEAK_THRESHSTEP_1_0_DB);
+	case step_1_5db: return rf69_read_mod_write(spi, REG_OOKPEAK, MASK_OOKPEAK_THRESSTEP, OOKPEAK_THRESHSTEP_1_5_DB);
+	case step_2_0db: return rf69_read_mod_write(spi, REG_OOKPEAK, MASK_OOKPEAK_THRESSTEP, OOKPEAK_THRESHSTEP_2_0_DB);
+	case step_3_0db: return rf69_read_mod_write(spi, REG_OOKPEAK, MASK_OOKPEAK_THRESSTEP, OOKPEAK_THRESHSTEP_3_0_DB);
+	case step_4_0db: return rf69_read_mod_write(spi, REG_OOKPEAK, MASK_OOKPEAK_THRESSTEP, OOKPEAK_THRESHSTEP_4_0_DB);
+	case step_5_0db: return rf69_read_mod_write(spi, REG_OOKPEAK, MASK_OOKPEAK_THRESSTEP, OOKPEAK_THRESHSTEP_5_0_DB);
+	case step_6_0db: return rf69_read_mod_write(spi, REG_OOKPEAK, MASK_OOKPEAK_THRESSTEP, OOKPEAK_THRESHSTEP_6_0_DB);
 	default:
 		dev_dbg(&spi->dev, "set: illegal input param");
 		return -EINVAL;
@@ -565,14 +585,14 @@ int rf69_set_ook_threshold_dec(struct spi_device *spi, enum thresholdDecrement t
 	#endif
 
 	switch (thresholdDecrement) {
-	case dec_every8th: return WRITE_REG(REG_OOKPEAK, ((READ_REG(REG_OOKPEAK) & ~MASK_OOKPEAK_THRESDEC) | OOKPEAK_THRESHDEC_EVERY_8TH));
-	case dec_every4th: return WRITE_REG(REG_OOKPEAK, ((READ_REG(REG_OOKPEAK) & ~MASK_OOKPEAK_THRESDEC) | OOKPEAK_THRESHDEC_EVERY_4TH));
-	case dec_every2nd: return WRITE_REG(REG_OOKPEAK, ((READ_REG(REG_OOKPEAK) & ~MASK_OOKPEAK_THRESDEC) | OOKPEAK_THRESHDEC_EVERY_2ND));
-	case dec_once:	   return WRITE_REG(REG_OOKPEAK, ((READ_REG(REG_OOKPEAK) & ~MASK_OOKPEAK_THRESDEC) | OOKPEAK_THRESHDEC_ONCE));
-	case dec_twice:	   return WRITE_REG(REG_OOKPEAK, ((READ_REG(REG_OOKPEAK) & ~MASK_OOKPEAK_THRESDEC) | OOKPEAK_THRESHDEC_TWICE));
-	case dec_4times:   return WRITE_REG(REG_OOKPEAK, ((READ_REG(REG_OOKPEAK) & ~MASK_OOKPEAK_THRESDEC) | OOKPEAK_THRESHDEC_4_TIMES));
-	case dec_8times:   return WRITE_REG(REG_OOKPEAK, ((READ_REG(REG_OOKPEAK) & ~MASK_OOKPEAK_THRESDEC) | OOKPEAK_THRESHDEC_8_TIMES));
-	case dec_16times:  return WRITE_REG(REG_OOKPEAK, ((READ_REG(REG_OOKPEAK) & ~MASK_OOKPEAK_THRESDEC) | OOKPEAK_THRESHDEC_16_TIMES));
+	case dec_every8th: return rf69_read_mod_write(spi, REG_OOKPEAK, MASK_OOKPEAK_THRESDEC, OOKPEAK_THRESHDEC_EVERY_8TH);
+	case dec_every4th: return rf69_read_mod_write(spi, REG_OOKPEAK, MASK_OOKPEAK_THRESDEC, OOKPEAK_THRESHDEC_EVERY_4TH);
+	case dec_every2nd: return rf69_read_mod_write(spi, REG_OOKPEAK, MASK_OOKPEAK_THRESDEC, OOKPEAK_THRESHDEC_EVERY_2ND);
+	case dec_once:	   return rf69_read_mod_write(spi, REG_OOKPEAK, MASK_OOKPEAK_THRESDEC, OOKPEAK_THRESHDEC_ONCE);
+	case dec_twice:	   return rf69_read_mod_write(spi, REG_OOKPEAK, MASK_OOKPEAK_THRESDEC, OOKPEAK_THRESHDEC_TWICE);
+	case dec_4times:   return rf69_read_mod_write(spi, REG_OOKPEAK, MASK_OOKPEAK_THRESDEC, OOKPEAK_THRESHDEC_4_TIMES);
+	case dec_8times:   return rf69_read_mod_write(spi, REG_OOKPEAK, MASK_OOKPEAK_THRESDEC, OOKPEAK_THRESHDEC_8_TIMES);
+	case dec_16times:  return rf69_read_mod_write(spi, REG_OOKPEAK, MASK_OOKPEAK_THRESDEC, OOKPEAK_THRESHDEC_16_TIMES);
 	default:
 		dev_dbg(&spi->dev, "set: illegal input param");
 		return -EINVAL;
@@ -610,18 +630,18 @@ int rf69_set_dio_mapping(struct spi_device *spi, u8 DIONumber, u8 value)
 		mask = MASK_DIO5; shift = SHIFT_DIO5; regaddr = REG_DIOMAPPING2;
 		break;
 	default:
-		dev_dbg(&spi->dev, "set: illegal input param");
+	dev_dbg(&spi->dev, "set: illegal input param");
 		return -EINVAL;
 	}
 
 	// read reg
-	regValue = READ_REG(regaddr);
+	regValue = rf69_read_reg(spi, regaddr);
 	// delete old value
 	regValue = regValue & ~mask;
 	// add new value
 	regValue = regValue | value << shift;
 	// write back
-	return WRITE_REG(regaddr, regValue);
+	return rf69_write_reg(spi, regaddr, regValue);
 }
 
 bool rf69_get_flag(struct spi_device *spi, enum flag flag)
@@ -631,23 +651,23 @@ bool rf69_get_flag(struct spi_device *spi, enum flag flag)
 	#endif
 
 	switch (flag) {
-	case modeSwitchCompleted:     return (READ_REG(REG_IRQFLAGS1) & MASK_IRQFLAGS1_MODE_READY);
-	case readyToReceive:	      return (READ_REG(REG_IRQFLAGS1) & MASK_IRQFLAGS1_RX_READY);
-	case readyToSend:	      return (READ_REG(REG_IRQFLAGS1) & MASK_IRQFLAGS1_TX_READY);
-	case pllLocked:		      return (READ_REG(REG_IRQFLAGS1) & MASK_IRQFLAGS1_PLL_LOCK);
-	case rssiExceededThreshold:   return (READ_REG(REG_IRQFLAGS1) & MASK_IRQFLAGS1_RSSI);
-	case timeout:		      return (READ_REG(REG_IRQFLAGS1) & MASK_IRQFLAGS1_TIMEOUT);
-	case automode:		      return (READ_REG(REG_IRQFLAGS1) & MASK_IRQFLAGS1_AUTOMODE);
-	case syncAddressMatch:	      return (READ_REG(REG_IRQFLAGS1) & MASK_IRQFLAGS1_SYNC_ADDRESS_MATCH);
-	case fifoFull:		      return (READ_REG(REG_IRQFLAGS2) & MASK_IRQFLAGS2_FIFO_FULL);
-/*	case fifoNotEmpty:	      return (READ_REG(REG_IRQFLAGS2) & MASK_IRQFLAGS2_FIFO_NOT_EMPTY); */
-	case fifoEmpty:		      return !(READ_REG(REG_IRQFLAGS2) & MASK_IRQFLAGS2_FIFO_NOT_EMPTY);
-	case fifoLevelBelowThreshold: return (READ_REG(REG_IRQFLAGS2) & MASK_IRQFLAGS2_FIFO_LEVEL);
-	case fifoOverrun:	      return (READ_REG(REG_IRQFLAGS2) & MASK_IRQFLAGS2_FIFO_OVERRUN);
-	case packetSent:	      return (READ_REG(REG_IRQFLAGS2) & MASK_IRQFLAGS2_PACKET_SENT);
-	case payloadReady:	      return (READ_REG(REG_IRQFLAGS2) & MASK_IRQFLAGS2_PAYLOAD_READY);
-	case crcOk:		      return (READ_REG(REG_IRQFLAGS2) & MASK_IRQFLAGS2_CRC_OK);
-	case batteryLow:	      return (READ_REG(REG_IRQFLAGS2) & MASK_IRQFLAGS2_LOW_BAT);
+	case modeSwitchCompleted:     return (rf69_read_reg(spi, REG_IRQFLAGS1) & MASK_IRQFLAGS1_MODE_READY);
+	case readyToReceive:	      return (rf69_read_reg(spi, REG_IRQFLAGS1) & MASK_IRQFLAGS1_RX_READY);
+	case readyToSend:	      return (rf69_read_reg(spi, REG_IRQFLAGS1) & MASK_IRQFLAGS1_TX_READY);
+	case pllLocked:		      return (rf69_read_reg(spi, REG_IRQFLAGS1) & MASK_IRQFLAGS1_PLL_LOCK);
+	case rssiExceededThreshold:   return (rf69_read_reg(spi, REG_IRQFLAGS1) & MASK_IRQFLAGS1_RSSI);
+	case timeout:		      return (rf69_read_reg(spi, REG_IRQFLAGS1) & MASK_IRQFLAGS1_TIMEOUT);
+	case automode:		      return (rf69_read_reg(spi, REG_IRQFLAGS1) & MASK_IRQFLAGS1_AUTOMODE);
+	case syncAddressMatch:	      return (rf69_read_reg(spi, REG_IRQFLAGS1) & MASK_IRQFLAGS1_SYNC_ADDRESS_MATCH);
+	case fifoFull:		      return (rf69_read_reg(spi, REG_IRQFLAGS2) & MASK_IRQFLAGS2_FIFO_FULL);
+/*	case fifoNotEmpty:	      return (rf69_read_reg(spi, REG_IRQFLAGS2) & MASK_IRQFLAGS2_FIFO_NOT_EMPTY); */
+	case fifoEmpty:		      return !(rf69_read_reg(spi, REG_IRQFLAGS2) & MASK_IRQFLAGS2_FIFO_NOT_EMPTY);
+	case fifoLevelBelowThreshold: return (rf69_read_reg(spi, REG_IRQFLAGS2) & MASK_IRQFLAGS2_FIFO_LEVEL);
+	case fifoOverrun:	      return (rf69_read_reg(spi, REG_IRQFLAGS2) & MASK_IRQFLAGS2_FIFO_OVERRUN);
+	case packetSent:	      return (rf69_read_reg(spi, REG_IRQFLAGS2) & MASK_IRQFLAGS2_PACKET_SENT);
+	case payloadReady:	      return (rf69_read_reg(spi, REG_IRQFLAGS2) & MASK_IRQFLAGS2_PAYLOAD_READY);
+	case crcOk:		      return (rf69_read_reg(spi, REG_IRQFLAGS2) & MASK_IRQFLAGS2_CRC_OK);
+	case batteryLow:	      return (rf69_read_reg(spi, REG_IRQFLAGS2) & MASK_IRQFLAGS2_LOW_BAT);
 	default:		      return false;
 	}
 }
@@ -659,9 +679,9 @@ int rf69_reset_flag(struct spi_device *spi, enum flag flag)
 	#endif
 
 	switch (flag) {
-	case rssiExceededThreshold: return WRITE_REG(REG_IRQFLAGS1, MASK_IRQFLAGS1_RSSI);
-	case syncAddressMatch:	    return WRITE_REG(REG_IRQFLAGS1, MASK_IRQFLAGS1_SYNC_ADDRESS_MATCH);
-	case fifoOverrun:	    return WRITE_REG(REG_IRQFLAGS2, MASK_IRQFLAGS2_FIFO_OVERRUN);
+	case rssiExceededThreshold: return rf69_write_reg(spi, REG_IRQFLAGS1, MASK_IRQFLAGS1_RSSI);
+	case syncAddressMatch:	    return rf69_write_reg(spi, REG_IRQFLAGS1, MASK_IRQFLAGS1_SYNC_ADDRESS_MATCH);
+	case fifoOverrun:	    return rf69_write_reg(spi, REG_IRQFLAGS2, MASK_IRQFLAGS2_FIFO_OVERRUN);
 	default:
 		dev_dbg(&spi->dev, "set: illegal input param");
 		return -EINVAL;
@@ -676,7 +696,7 @@ int rf69_set_rssi_threshold(struct spi_device *spi, u8 threshold)
 
 	/* no value check needed - u8 exactly matches register size */
 
-	return WRITE_REG(REG_RSSITHRESH, threshold);
+	return rf69_write_reg(spi, REG_RSSITHRESH, threshold);
 }
 
 int rf69_set_rx_start_timeout(struct spi_device *spi, u8 timeout)
@@ -687,7 +707,7 @@ int rf69_set_rx_start_timeout(struct spi_device *spi, u8 timeout)
 
 	/* no value check needed - u8 exactly matches register size */
 
-	return WRITE_REG(REG_RXTIMEOUT1, timeout);
+	return rf69_write_reg(spi, REG_RXTIMEOUT1, timeout);
 }
 
 int rf69_set_rssi_timeout(struct spi_device *spi, u8 timeout)
@@ -698,7 +718,7 @@ int rf69_set_rssi_timeout(struct spi_device *spi, u8 timeout)
 
 	/* no value check needed - u8 exactly matches register size */
 
-	return WRITE_REG(REG_RXTIMEOUT2, timeout);
+	return rf69_write_reg(spi, REG_RXTIMEOUT2, timeout);
 }
 
 int rf69_set_preamble_length(struct spi_device *spi, u16 preambleLength)
@@ -717,10 +737,12 @@ int rf69_set_preamble_length(struct spi_device *spi, u16 preambleLength)
 	lsb = (preambleLength&0xff);
 
 	/* transmit to chip */
-	retval = WRITE_REG(REG_PREAMBLE_MSB, msb);
+	retval = rf69_write_reg(spi, REG_PREAMBLE_MSB, msb);
 	if (retval)
 		return retval;
-	return WRITE_REG(REG_PREAMBLE_LSB, lsb);
+	retval = rf69_write_reg(spi, REG_PREAMBLE_LSB, lsb);
+
+	return retval;
 }
 
 int rf69_set_sync_enable(struct spi_device *spi,
@@ -731,8 +753,8 @@ int rf69_set_sync_enable(struct spi_device *spi,
 	#endif
 
 	switch (option_on_off) {
-	case OPTION_ON:  return WRITE_REG(REG_SYNC_CONFIG, (READ_REG(REG_SYNC_CONFIG) |  MASK_SYNC_CONFIG_SYNC_ON));
-	case OPTION_OFF: return WRITE_REG(REG_SYNC_CONFIG, (READ_REG(REG_SYNC_CONFIG) & ~MASK_SYNC_CONFIG_SYNC_ON));
+	case OPTION_ON: return rf69_set_bit(spi, REG_SYNC_CONFIG, MASK_SYNC_CONFIG_SYNC_ON);
+	case OPTION_OFF: return rf69_clear_bit(spi, REG_SYNC_CONFIG, MASK_SYNC_CONFIG_SYNC_ON);
 	default:
 		dev_dbg(&spi->dev, "set: illegal input param");
 		return -EINVAL;
@@ -746,8 +768,8 @@ int rf69_set_fifo_fill_condition(struct spi_device *spi, enum fifoFillCondition
 	#endif
 
 	switch (fifoFillCondition) {
-	case always:		 return WRITE_REG(REG_SYNC_CONFIG, (READ_REG(REG_SYNC_CONFIG) |  MASK_SYNC_CONFIG_FIFO_FILL_CONDITION));
-	case afterSyncInterrupt: return WRITE_REG(REG_SYNC_CONFIG, (READ_REG(REG_SYNC_CONFIG) & ~MASK_SYNC_CONFIG_FIFO_FILL_CONDITION));
+	case always:		 return rf69_set_bit(spi, REG_SYNC_CONFIG, MASK_SYNC_CONFIG_FIFO_FILL_CONDITION);
+	case afterSyncInterrupt: return rf69_clear_bit(spi, REG_SYNC_CONFIG, MASK_SYNC_CONFIG_FIFO_FILL_CONDITION);
 	default:
 		dev_dbg(&spi->dev, "set: illegal input param");
 		return -EINVAL;
@@ -767,7 +789,7 @@ int rf69_set_sync_size(struct spi_device *spi, u8 syncSize)
 	}
 
 	// write value
-	return WRITE_REG(REG_SYNC_CONFIG, (READ_REG(REG_SYNC_CONFIG) & ~MASK_SYNC_CONFIG_SYNC_SIZE) | (syncSize << 3));
+	return rf69_read_mod_write(spi, REG_SYNC_CONFIG, MASK_SYNC_CONFIG_SYNC_SIZE, (syncSize << 3));
 }
 
 int rf69_set_sync_tolerance(struct spi_device *spi, u8 syncTolerance)
@@ -783,7 +805,7 @@ int rf69_set_sync_tolerance(struct spi_device *spi, u8 syncTolerance)
 	}
 
 	// write value
-	return WRITE_REG(REG_SYNC_CONFIG, (READ_REG(REG_SYNC_CONFIG) & ~MASK_SYNC_CONFIG_SYNC_SIZE) | syncTolerance);
+	return rf69_read_mod_write(spi, REG_SYNC_CONFIG, MASK_SYNC_CONFIG_SYNC_SIZE, syncTolerance);
 }
 
 int rf69_set_sync_values(struct spi_device *spi, u8 syncValues[8])
@@ -794,14 +816,14 @@ int rf69_set_sync_values(struct spi_device *spi, u8 syncValues[8])
 		dev_dbg(&spi->dev, "set: sync values");
 	#endif
 
-	retval += WRITE_REG(REG_SYNCVALUE1, syncValues[0]);
-	retval += WRITE_REG(REG_SYNCVALUE2, syncValues[1]);
-	retval += WRITE_REG(REG_SYNCVALUE3, syncValues[2]);
-	retval += WRITE_REG(REG_SYNCVALUE4, syncValues[3]);
-	retval += WRITE_REG(REG_SYNCVALUE5, syncValues[4]);
-	retval += WRITE_REG(REG_SYNCVALUE6, syncValues[5]);
-	retval += WRITE_REG(REG_SYNCVALUE7, syncValues[6]);
-	retval += WRITE_REG(REG_SYNCVALUE8, syncValues[7]);
+	retval += rf69_write_reg(spi, REG_SYNCVALUE1, syncValues[0]);
+	retval += rf69_write_reg(spi, REG_SYNCVALUE2, syncValues[1]);
+	retval += rf69_write_reg(spi, REG_SYNCVALUE3, syncValues[2]);
+	retval += rf69_write_reg(spi, REG_SYNCVALUE4, syncValues[3]);
+	retval += rf69_write_reg(spi, REG_SYNCVALUE5, syncValues[4]);
+	retval += rf69_write_reg(spi, REG_SYNCVALUE6, syncValues[5]);
+	retval += rf69_write_reg(spi, REG_SYNCVALUE7, syncValues[6]);
+	retval += rf69_write_reg(spi, REG_SYNCVALUE8, syncValues[7]);
 
 	return retval;
 }
@@ -813,8 +835,8 @@ int rf69_set_packet_format(struct spi_device *spi, enum packetFormat packetForma
 	#endif
 
 	switch (packetFormat) {
-	case packetLengthVar: return WRITE_REG(REG_PACKETCONFIG1, (READ_REG(REG_PACKETCONFIG1) |  MASK_PACKETCONFIG1_PAKET_FORMAT_VARIABLE));
-	case packetLengthFix: return WRITE_REG(REG_PACKETCONFIG1, (READ_REG(REG_PACKETCONFIG1) & ~MASK_PACKETCONFIG1_PAKET_FORMAT_VARIABLE));
+	case packetLengthVar: return rf69_set_bit(spi, REG_PACKETCONFIG1, MASK_PACKETCONFIG1_PAKET_FORMAT_VARIABLE);
+	case packetLengthFix: return rf69_clear_bit(spi, REG_PACKETCONFIG1, MASK_PACKETCONFIG1_PAKET_FORMAT_VARIABLE);
 	default:
 		dev_dbg(&spi->dev, "set: illegal input param");
 		return -EINVAL;
@@ -829,8 +851,8 @@ int rf69_set_crc_enable(struct spi_device *spi,
 	#endif
 
 	switch (option_on_off) {
-	case OPTION_ON:  return WRITE_REG(REG_PACKETCONFIG1, (READ_REG(REG_PACKETCONFIG1) |  MASK_PACKETCONFIG1_CRC_ON));
-	case OPTION_OFF: return WRITE_REG(REG_PACKETCONFIG1, (READ_REG(REG_PACKETCONFIG1) & ~MASK_PACKETCONFIG1_CRC_ON));
+	case OPTION_ON: return rf69_set_bit(spi, REG_PACKETCONFIG1, MASK_PACKETCONFIG1_CRC_ON);
+	case OPTION_OFF: return rf69_clear_bit(spi, REG_PACKETCONFIG1, MASK_PACKETCONFIG1_CRC_ON);
 	default:
 		dev_dbg(&spi->dev, "set: illegal input param");
 		return -EINVAL;
@@ -844,9 +866,9 @@ int rf69_set_adressFiltering(struct spi_device *spi, enum addressFiltering addre
 	#endif
 
 	switch (addressFiltering) {
-	case filteringOff:	     return WRITE_REG(REG_PACKETCONFIG1, ((READ_REG(REG_PACKETCONFIG1) & ~MASK_PACKETCONFIG1_ADDRESSFILTERING) | PACKETCONFIG1_ADDRESSFILTERING_OFF));
-	case nodeAddress:	     return WRITE_REG(REG_PACKETCONFIG1, ((READ_REG(REG_PACKETCONFIG1) & ~MASK_PACKETCONFIG1_ADDRESSFILTERING) | PACKETCONFIG1_ADDRESSFILTERING_NODE));
-	case nodeOrBroadcastAddress: return WRITE_REG(REG_PACKETCONFIG1, ((READ_REG(REG_PACKETCONFIG1) & ~MASK_PACKETCONFIG1_ADDRESSFILTERING) | PACKETCONFIG1_ADDRESSFILTERING_NODEBROADCAST));
+	case filteringOff:	     return rf69_read_mod_write(spi, REG_PACKETCONFIG1, MASK_PACKETCONFIG1_ADDRESSFILTERING, PACKETCONFIG1_ADDRESSFILTERING_OFF);
+	case nodeAddress:	     return rf69_read_mod_write(spi, REG_PACKETCONFIG1, MASK_PACKETCONFIG1_ADDRESSFILTERING, PACKETCONFIG1_ADDRESSFILTERING_NODE);
+	case nodeOrBroadcastAddress: return rf69_read_mod_write(spi, REG_PACKETCONFIG1, MASK_PACKETCONFIG1_ADDRESSFILTERING, PACKETCONFIG1_ADDRESSFILTERING_NODEBROADCAST);
 	default:
 		dev_dbg(&spi->dev, "set: illegal input param");
 		return -EINVAL;
@@ -859,7 +881,7 @@ int rf69_set_payload_length(struct spi_device *spi, u8 payloadLength)
 		dev_dbg(&spi->dev, "set: payload length");
 	#endif
 
-	return WRITE_REG(REG_PAYLOAD_LENGTH, payloadLength);
+	return rf69_write_reg(spi, REG_PAYLOAD_LENGTH, payloadLength);
 }
 
 u8  rf69_get_payload_length(struct spi_device *spi)
@@ -868,7 +890,7 @@ u8  rf69_get_payload_length(struct spi_device *spi)
 		dev_dbg(&spi->dev, "get: payload length");
 	#endif
 
-	return (u8) READ_REG(REG_PAYLOAD_LENGTH);
+	return (u8)rf69_read_reg(spi, REG_PAYLOAD_LENGTH);
 }
 
 int rf69_set_node_address(struct spi_device *spi, u8 nodeAddress)
@@ -877,7 +899,7 @@ int rf69_set_node_address(struct spi_device *spi, u8 nodeAddress)
 		dev_dbg(&spi->dev, "set: node address");
 	#endif
 
-	return WRITE_REG(REG_NODEADRS, nodeAddress);
+	return rf69_write_reg(spi, REG_NODEADRS, nodeAddress);
 }
 
 int rf69_set_broadcast_address(struct spi_device *spi, u8 broadcastAddress)
@@ -886,7 +908,7 @@ int rf69_set_broadcast_address(struct spi_device *spi, u8 broadcastAddress)
 		dev_dbg(&spi->dev, "set: broadcast address");
 	#endif
 
-	return WRITE_REG(REG_BROADCASTADRS, broadcastAddress);
+	return rf69_write_reg(spi, REG_BROADCASTADRS, broadcastAddress);
 }
 
 int rf69_set_tx_start_condition(struct spi_device *spi, enum txStartCondition txStartCondition)
@@ -896,8 +918,8 @@ int rf69_set_tx_start_condition(struct spi_device *spi, enum txStartCondition tx
 	#endif
 
 	switch (txStartCondition) {
-	case fifoLevel:	   return WRITE_REG(REG_FIFO_THRESH, (READ_REG(REG_FIFO_THRESH) & ~MASK_FIFO_THRESH_TXSTART));
-	case fifoNotEmpty: return WRITE_REG(REG_FIFO_THRESH, (READ_REG(REG_FIFO_THRESH) |  MASK_FIFO_THRESH_TXSTART));
+	case fifoLevel:	   return rf69_clear_bit(spi, REG_FIFO_THRESH, MASK_FIFO_THRESH_TXSTART);
+	case fifoNotEmpty: return rf69_set_bit(spi, REG_FIFO_THRESH, MASK_FIFO_THRESH_TXSTART);
 	default:
 		dev_dbg(&spi->dev, "set: illegal input param");
 		return -EINVAL;
@@ -912,19 +934,21 @@ int rf69_set_fifo_threshold(struct spi_device *spi, u8 threshold)
 		dev_dbg(&spi->dev, "set: fifo threshold");
 	#endif
 
-	// check input value
+	/* check input value */
 	if (threshold & 0x80) {
 		dev_dbg(&spi->dev, "set: illegal input param");
 		return -EINVAL;
 	}
 
-	// write value
-	retval = WRITE_REG(REG_FIFO_THRESH, (READ_REG(REG_FIFO_THRESH) & ~MASK_FIFO_THRESH_VALUE) | threshold);
+	/* write value */
+	retval = rf69_read_mod_write(spi, REG_FIFO_THRESH, MASK_FIFO_THRESH_VALUE, threshold);
 	if (retval)
 		return retval;
 
-	// access the fifo to activate new threshold
-	return rf69_read_fifo(spi, (u8 *)&retval, 1); // retval used as buffer
+	/* access the fifo to activate new threshold
+	 * retval (mis-) used as buffer here
+	 */
+	return rf69_read_fifo(spi, (u8 *)&retval, 1);
 }
 
 int rf69_set_dagc(struct spi_device *spi, enum dagc dagc)
@@ -934,9 +958,9 @@ int rf69_set_dagc(struct spi_device *spi, enum dagc dagc)
 	#endif
 
 	switch (dagc) {
-	case normalMode:		 return WRITE_REG(REG_TESTDAGC, DAGC_NORMAL);
-	case improve:			 return WRITE_REG(REG_TESTDAGC, DAGC_IMPROVED_LOWBETA0);
-	case improve4LowModulationIndex: return WRITE_REG(REG_TESTDAGC, DAGC_IMPROVED_LOWBETA1);
+	case normalMode:		 return rf69_write_reg(spi, REG_TESTDAGC, DAGC_NORMAL);
+	case improve:			 return rf69_write_reg(spi, REG_TESTDAGC, DAGC_IMPROVED_LOWBETA0);
+	case improve4LowModulationIndex: return rf69_write_reg(spi, REG_TESTDAGC, DAGC_IMPROVED_LOWBETA1);
 	default:
 		dev_dbg(&spi->dev, "set: illegal input param");
 		return -EINVAL;

commit d423c80929ba56c67a6eefc7653edd87f4ca3abe
Author: Simon Sandström <simon@nikanor.nu>
Date:   Tue Dec 5 23:08:42 2017 +0100

    staging: pi433: Rename enum optionOnOff in rf69_enum.h
    
    Renames the enum optionOnOff and its values optionOn, optionOff to enum
    option_on_off and OPTION_ON, OPTION_OFF. Fixes checkpatch.pl warnings:
    "Avoid CamelCase: <optionOnOff>, <optionOn>, <optionOff>".
    
    Signed-off-by: Simon Sandström <simon@nikanor.nu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/pi433/rf69.c b/drivers/staging/pi433/rf69.c
index e69a2153c999..ebb3ddd1a957 100644
--- a/drivers/staging/pi433/rf69.c
+++ b/drivers/staging/pi433/rf69.c
@@ -272,45 +272,48 @@ int rf69_set_frequency(struct spi_device *spi, u32 frequency)
 	return 0;
 }
 
-int rf69_set_amplifier_0(struct spi_device *spi, enum optionOnOff optionOnOff)
+int rf69_set_amplifier_0(struct spi_device *spi,
+			 enum option_on_off option_on_off)
 {
 	#ifdef DEBUG
 		dev_dbg(&spi->dev, "set: amp #0");
 	#endif
 
-	switch (optionOnOff) {
-	case optionOn:	return WRITE_REG(REG_PALEVEL, (READ_REG(REG_PALEVEL) |  MASK_PALEVEL_PA0));
-	case optionOff:	return WRITE_REG(REG_PALEVEL, (READ_REG(REG_PALEVEL) & ~MASK_PALEVEL_PA0));
+	switch (option_on_off) {
+	case OPTION_ON:  return WRITE_REG(REG_PALEVEL, (READ_REG(REG_PALEVEL) |  MASK_PALEVEL_PA0));
+	case OPTION_OFF: return WRITE_REG(REG_PALEVEL, (READ_REG(REG_PALEVEL) & ~MASK_PALEVEL_PA0));
 	default:
 		dev_dbg(&spi->dev, "set: illegal input param");
 		return -EINVAL;
 	}
 }
 
-int rf69_set_amplifier_1(struct spi_device *spi, enum optionOnOff optionOnOff)
+int rf69_set_amplifier_1(struct spi_device *spi,
+			 enum option_on_off option_on_off)
 {
 	#ifdef DEBUG
 		dev_dbg(&spi->dev, "set: amp #1");
 	#endif
 
-	switch (optionOnOff) {
-	case optionOn:	return WRITE_REG(REG_PALEVEL, (READ_REG(REG_PALEVEL) |  MASK_PALEVEL_PA1));
-	case optionOff: return WRITE_REG(REG_PALEVEL, (READ_REG(REG_PALEVEL) & ~MASK_PALEVEL_PA1));
+	switch (option_on_off) {
+	case OPTION_ON:  return WRITE_REG(REG_PALEVEL, (READ_REG(REG_PALEVEL) |  MASK_PALEVEL_PA1));
+	case OPTION_OFF: return WRITE_REG(REG_PALEVEL, (READ_REG(REG_PALEVEL) & ~MASK_PALEVEL_PA1));
 	default:
 		dev_dbg(&spi->dev, "set: illegal input param");
 		return -EINVAL;
 	}
 }
 
-int rf69_set_amplifier_2(struct spi_device *spi, enum optionOnOff optionOnOff)
+int rf69_set_amplifier_2(struct spi_device *spi,
+			 enum option_on_off option_on_off)
 {
 	#ifdef DEBUG
 		dev_dbg(&spi->dev, "set: amp #2");
 	#endif
 
-	switch (optionOnOff) {
-	case optionOn:	return WRITE_REG(REG_PALEVEL, (READ_REG(REG_PALEVEL) |  MASK_PALEVEL_PA2));
-	case optionOff:	return WRITE_REG(REG_PALEVEL, (READ_REG(REG_PALEVEL) & ~MASK_PALEVEL_PA2));
+	switch (option_on_off) {
+	case OPTION_ON:	 return WRITE_REG(REG_PALEVEL, (READ_REG(REG_PALEVEL) |  MASK_PALEVEL_PA2));
+	case OPTION_OFF: return WRITE_REG(REG_PALEVEL, (READ_REG(REG_PALEVEL) & ~MASK_PALEVEL_PA2));
 	default:
 		dev_dbg(&spi->dev, "set: illegal input param");
 		return -EINVAL;
@@ -720,15 +723,16 @@ int rf69_set_preamble_length(struct spi_device *spi, u16 preambleLength)
 	return WRITE_REG(REG_PREAMBLE_LSB, lsb);
 }
 
-int rf69_set_sync_enable(struct spi_device *spi, enum optionOnOff optionOnOff)
+int rf69_set_sync_enable(struct spi_device *spi,
+			 enum option_on_off option_on_off)
 {
 	#ifdef DEBUG
 		dev_dbg(&spi->dev, "set: sync enable");
 	#endif
 
-	switch (optionOnOff) {
-	case optionOn:	return WRITE_REG(REG_SYNC_CONFIG, (READ_REG(REG_SYNC_CONFIG) |  MASK_SYNC_CONFIG_SYNC_ON));
-	case optionOff:	return WRITE_REG(REG_SYNC_CONFIG, (READ_REG(REG_SYNC_CONFIG) & ~MASK_SYNC_CONFIG_SYNC_ON));
+	switch (option_on_off) {
+	case OPTION_ON:  return WRITE_REG(REG_SYNC_CONFIG, (READ_REG(REG_SYNC_CONFIG) |  MASK_SYNC_CONFIG_SYNC_ON));
+	case OPTION_OFF: return WRITE_REG(REG_SYNC_CONFIG, (READ_REG(REG_SYNC_CONFIG) & ~MASK_SYNC_CONFIG_SYNC_ON));
 	default:
 		dev_dbg(&spi->dev, "set: illegal input param");
 		return -EINVAL;
@@ -817,15 +821,16 @@ int rf69_set_packet_format(struct spi_device *spi, enum packetFormat packetForma
 	}
 }
 
-int rf69_set_crc_enable(struct spi_device *spi, enum optionOnOff optionOnOff)
+int rf69_set_crc_enable(struct spi_device *spi,
+			enum option_on_off option_on_off)
 {
 	#ifdef DEBUG
 		dev_dbg(&spi->dev, "set: crc enable");
 	#endif
 
-	switch (optionOnOff) {
-	case optionOn:	return WRITE_REG(REG_PACKETCONFIG1, (READ_REG(REG_PACKETCONFIG1) |  MASK_PACKETCONFIG1_CRC_ON));
-	case optionOff:	return WRITE_REG(REG_PACKETCONFIG1, (READ_REG(REG_PACKETCONFIG1) & ~MASK_PACKETCONFIG1_CRC_ON));
+	switch (option_on_off) {
+	case OPTION_ON:  return WRITE_REG(REG_PACKETCONFIG1, (READ_REG(REG_PACKETCONFIG1) |  MASK_PACKETCONFIG1_CRC_ON));
+	case OPTION_OFF: return WRITE_REG(REG_PACKETCONFIG1, (READ_REG(REG_PACKETCONFIG1) & ~MASK_PACKETCONFIG1_CRC_ON));
 	default:
 		dev_dbg(&spi->dev, "set: illegal input param");
 		return -EINVAL;

commit 202fc673c626e4ffe6b888c469b248ecc6d50265
Author: Marcus Wolf <linux@wolf-entwicklungen.de>
Date:   Wed Nov 8 19:13:56 2017 +0200

    staging: pi433: Fixes issue with bit shift in rf69_get_modulation
    
    Fixes issue with bit shift in rf69_get_modulation
    
    Signed-off-by: Marcus Wolf <linux@wolf-entwicklungen.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/pi433/rf69.c b/drivers/staging/pi433/rf69.c
index e69a2153c999..12c9df9cddde 100644
--- a/drivers/staging/pi433/rf69.c
+++ b/drivers/staging/pi433/rf69.c
@@ -102,7 +102,7 @@ enum modulation rf69_get_modulation(struct spi_device *spi)
 
 	currentValue = READ_REG(REG_DATAMODUL);
 
-	switch (currentValue & MASK_DATAMODUL_MODULATION_TYPE >> 3) { // TODO improvement: change 3 to define
+	switch (currentValue & MASK_DATAMODUL_MODULATION_TYPE) {
 	case DATAMODUL_MODULATION_TYPE_OOK: return OOK;
 	case DATAMODUL_MODULATION_TYPE_FSK: return FSK;
 	default:			    return undefined;

commit db8c7f2b6443f2f255f6e8cd2c594ea9beec8fb5
Author: Marcin Ciupak <marcin.s.ciupak@gmail.com>
Date:   Wed Oct 11 21:24:40 2017 +0200

    staging: pi433: rf69.c style fix - space before asterisk
    
    This patch fixes the following checkpatch.pl error:
    
    ERROR: "(foo*)" should be "(foo *)"
    
    in rf69.c file as requested by TODO file.
    
    Additionally some style warnings remain valid here and could be fixed by
    another patch.
    
    Signed-off-by: Marcin Ciupak <marcin.s.ciupak@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/pi433/rf69.c b/drivers/staging/pi433/rf69.c
index 6420d1b67ccc..e69a2153c999 100644
--- a/drivers/staging/pi433/rf69.c
+++ b/drivers/staging/pi433/rf69.c
@@ -919,7 +919,7 @@ int rf69_set_fifo_threshold(struct spi_device *spi, u8 threshold)
 		return retval;
 
 	// access the fifo to activate new threshold
-	return rf69_read_fifo (spi, (u8*) &retval, 1); // retval used as buffer
+	return rf69_read_fifo(spi, (u8 *)&retval, 1); // retval used as buffer
 }
 
 int rf69_set_dagc(struct spi_device *spi, enum dagc dagc)

commit b3fbc42249ebccb132808133f0fb72df029eb6a6
Author: Marcin Ciupak <marcin.s.ciupak@gmail.com>
Date:   Wed Oct 11 21:24:17 2017 +0200

    staging: pi433: rf69.c style fix - code indent should use tabs
    
    This patch fixes the following checkpatch.pl error:
    
    ERROR: code indent should use tabs where possible
    
    in rf69.c file as requested by TODO file.
    
    Additionally some style warnings remain valid here and could be fixed by
    another patch.
    
    Signed-off-by: Marcin Ciupak <marcin.s.ciupak@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/pi433/rf69.c b/drivers/staging/pi433/rf69.c
index 23d609474836..6420d1b67ccc 100644
--- a/drivers/staging/pi433/rf69.c
+++ b/drivers/staging/pi433/rf69.c
@@ -959,8 +959,8 @@ int rf69_read_fifo (struct spi_device *spi, u8 *buffer, unsigned int size)
 	/* prepare a bidirectional transfer */
 	local_buffer[0] = REG_FIFO;
 	memset(&transfer, 0, sizeof(transfer));
-  	transfer.tx_buf = local_buffer;
-  	transfer.rx_buf = local_buffer;
+	transfer.tx_buf = local_buffer;
+	transfer.rx_buf = local_buffer;
 	transfer.len	= size+1;
 
 	retval = spi_sync_transfer(spi, &transfer, 1);

commit 329822a02fd25948ac22562cf3cc6acd7f7ba542
Author: Marcin Ciupak <marcin.s.ciupak@gmail.com>
Date:   Wed Oct 11 21:24:01 2017 +0200

    staging: pi433: rf69.c style fix - spaces before/after
    
    his patch fixes the following checkpatch.pl errors:
    
    ERROR: space prohibited after that open parenthesis '('
    ERROR: space prohibited before that ',' (ctx:WxV)
    ERROR: space prohibited before that close parenthesis ')'
    ERROR: space required after that ',' (ctx:VxV)
    ERROR: space required before the open parenthesis '('
    
    in rf69.c file as requested by TODO file.
    
    Additionally some style warnings remain valid here and could be fixed by
    another patch.
    
    Signed-off-by: Marcin Ciupak <marcin.s.ciupak@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/pi433/rf69.c b/drivers/staging/pi433/rf69.c
index 7a79973641c9..23d609474836 100644
--- a/drivers/staging/pi433/rf69.c
+++ b/drivers/staging/pi433/rf69.c
@@ -34,7 +34,7 @@
 /*-------------------------------------------------------------------------*/
 
 #define READ_REG(x)	rf69_read_reg (spi, x)
-#define WRITE_REG(x,y)	rf69_write_reg(spi, x, y)
+#define WRITE_REG(x, y)	rf69_write_reg(spi, x, y)
 
 /*-------------------------------------------------------------------------*/
 
@@ -199,7 +199,7 @@ int rf69_set_deviation(struct spi_device *spi, u32 deviation)
 
 	// calculate register settings
 	f_reg = deviation * factor;
-	do_div(f_reg  , f_step);
+	do_div(f_reg, f_step);
 
 	msb = (f_reg&0xff00)   >>  8;
 	lsb = (f_reg&0xff);
@@ -250,7 +250,7 @@ int rf69_set_frequency(struct spi_device *spi, u32 frequency)
 
 	// calculate reg settings
 	f_reg = frequency * factor;
-	do_div(f_reg  , f_step);
+	do_div(f_reg, f_step);
 
 	msb = (f_reg&0xff0000) >> 16;
 	mid = (f_reg&0xff00)   >>  8;
@@ -278,9 +278,9 @@ int rf69_set_amplifier_0(struct spi_device *spi, enum optionOnOff optionOnOff)
 		dev_dbg(&spi->dev, "set: amp #0");
 	#endif
 
-	switch(optionOnOff) {
-	case optionOn:	return WRITE_REG(REG_PALEVEL, (READ_REG(REG_PALEVEL) |  MASK_PALEVEL_PA0) );
-	case optionOff:	return WRITE_REG(REG_PALEVEL, (READ_REG(REG_PALEVEL) & ~MASK_PALEVEL_PA0) );
+	switch (optionOnOff) {
+	case optionOn:	return WRITE_REG(REG_PALEVEL, (READ_REG(REG_PALEVEL) |  MASK_PALEVEL_PA0));
+	case optionOff:	return WRITE_REG(REG_PALEVEL, (READ_REG(REG_PALEVEL) & ~MASK_PALEVEL_PA0));
 	default:
 		dev_dbg(&spi->dev, "set: illegal input param");
 		return -EINVAL;
@@ -293,9 +293,9 @@ int rf69_set_amplifier_1(struct spi_device *spi, enum optionOnOff optionOnOff)
 		dev_dbg(&spi->dev, "set: amp #1");
 	#endif
 
-	switch(optionOnOff) {
-	case optionOn:	return WRITE_REG(REG_PALEVEL, (READ_REG(REG_PALEVEL) |  MASK_PALEVEL_PA1) );
-	case optionOff: return WRITE_REG(REG_PALEVEL, (READ_REG(REG_PALEVEL) & ~MASK_PALEVEL_PA1) );
+	switch (optionOnOff) {
+	case optionOn:	return WRITE_REG(REG_PALEVEL, (READ_REG(REG_PALEVEL) |  MASK_PALEVEL_PA1));
+	case optionOff: return WRITE_REG(REG_PALEVEL, (READ_REG(REG_PALEVEL) & ~MASK_PALEVEL_PA1));
 	default:
 		dev_dbg(&spi->dev, "set: illegal input param");
 		return -EINVAL;
@@ -308,9 +308,9 @@ int rf69_set_amplifier_2(struct spi_device *spi, enum optionOnOff optionOnOff)
 		dev_dbg(&spi->dev, "set: amp #2");
 	#endif
 
-	switch(optionOnOff) {
-	case optionOn:	return WRITE_REG(REG_PALEVEL, (READ_REG(REG_PALEVEL) |  MASK_PALEVEL_PA2) );
-	case optionOff:	return WRITE_REG(REG_PALEVEL, (READ_REG(REG_PALEVEL) & ~MASK_PALEVEL_PA2) );
+	switch (optionOnOff) {
+	case optionOn:	return WRITE_REG(REG_PALEVEL, (READ_REG(REG_PALEVEL) |  MASK_PALEVEL_PA2));
+	case optionOff:	return WRITE_REG(REG_PALEVEL, (READ_REG(REG_PALEVEL) & ~MASK_PALEVEL_PA2));
 	default:
 		dev_dbg(&spi->dev, "set: illegal input param");
 		return -EINVAL;
@@ -341,7 +341,7 @@ int rf69_set_pa_ramp(struct spi_device *spi, enum paRamp paRamp)
 		dev_dbg(&spi->dev, "set: pa ramp");
 	#endif
 
-	switch(paRamp) {
+	switch (paRamp) {
 	case ramp3400:	return WRITE_REG(REG_PARAMP, PARAMP_3400);
 	case ramp2000:	return WRITE_REG(REG_PARAMP, PARAMP_2000);
 	case ramp1000:	return WRITE_REG(REG_PARAMP, PARAMP_1000);
@@ -370,9 +370,9 @@ int rf69_set_antenna_impedance(struct spi_device *spi, enum antennaImpedance ant
 		dev_dbg(&spi->dev, "set: antenna impedance");
 	#endif
 
-	switch(antennaImpedance) {
-	case fiftyOhm:	    return WRITE_REG(REG_LNA, (READ_REG(REG_LNA) & ~MASK_LNA_ZIN) );
-	case twohundretOhm: return WRITE_REG(REG_LNA, (READ_REG(REG_LNA) |  MASK_LNA_ZIN) );
+	switch (antennaImpedance) {
+	case fiftyOhm:	    return WRITE_REG(REG_LNA, (READ_REG(REG_LNA) & ~MASK_LNA_ZIN));
+	case twohundretOhm: return WRITE_REG(REG_LNA, (READ_REG(REG_LNA) |  MASK_LNA_ZIN));
 	default:
 		dev_dbg(&spi->dev, "set: illegal input param");
 		return -EINVAL;
@@ -385,14 +385,14 @@ int rf69_set_lna_gain(struct spi_device *spi, enum lnaGain lnaGain)
 		dev_dbg(&spi->dev, "set: lna gain");
 	#endif
 
-	switch(lnaGain) {
-	case automatic:	 return WRITE_REG(REG_LNA, ( (READ_REG(REG_LNA) & ~MASK_LNA_GAIN) & LNA_GAIN_AUTO) );
-	case max:	 return WRITE_REG(REG_LNA, ( (READ_REG(REG_LNA) & ~MASK_LNA_GAIN) & LNA_GAIN_MAX) );
-	case maxMinus6:  return WRITE_REG(REG_LNA, ( (READ_REG(REG_LNA) & ~MASK_LNA_GAIN) & LNA_GAIN_MAX_MINUS_6) );
-	case maxMinus12: return WRITE_REG(REG_LNA, ( (READ_REG(REG_LNA) & ~MASK_LNA_GAIN) & LNA_GAIN_MAX_MINUS_12) );
-	case maxMinus24: return WRITE_REG(REG_LNA, ( (READ_REG(REG_LNA) & ~MASK_LNA_GAIN) & LNA_GAIN_MAX_MINUS_24) );
-	case maxMinus36: return WRITE_REG(REG_LNA, ( (READ_REG(REG_LNA) & ~MASK_LNA_GAIN) & LNA_GAIN_MAX_MINUS_36) );
-	case maxMinus48: return WRITE_REG(REG_LNA, ( (READ_REG(REG_LNA) & ~MASK_LNA_GAIN) & LNA_GAIN_MAX_MINUS_48) );
+	switch (lnaGain) {
+	case automatic:	 return WRITE_REG(REG_LNA, ((READ_REG(REG_LNA) & ~MASK_LNA_GAIN) & LNA_GAIN_AUTO));
+	case max:	 return WRITE_REG(REG_LNA, ((READ_REG(REG_LNA) & ~MASK_LNA_GAIN) & LNA_GAIN_MAX));
+	case maxMinus6:  return WRITE_REG(REG_LNA, ((READ_REG(REG_LNA) & ~MASK_LNA_GAIN) & LNA_GAIN_MAX_MINUS_6));
+	case maxMinus12: return WRITE_REG(REG_LNA, ((READ_REG(REG_LNA) & ~MASK_LNA_GAIN) & LNA_GAIN_MAX_MINUS_12));
+	case maxMinus24: return WRITE_REG(REG_LNA, ((READ_REG(REG_LNA) & ~MASK_LNA_GAIN) & LNA_GAIN_MAX_MINUS_24));
+	case maxMinus36: return WRITE_REG(REG_LNA, ((READ_REG(REG_LNA) & ~MASK_LNA_GAIN) & LNA_GAIN_MAX_MINUS_36));
+	case maxMinus48: return WRITE_REG(REG_LNA, ((READ_REG(REG_LNA) & ~MASK_LNA_GAIN) & LNA_GAIN_MAX_MINUS_48));
 	default:
 		dev_dbg(&spi->dev, "set: illegal input param");
 		return -EINVAL;
@@ -421,17 +421,17 @@ enum lnaGain rf69_get_lna_gain(struct spi_device *spi)
 	}
 }
 
-int rf69_set_dc_cut_off_frequency_intern(struct spi_device *spi ,u8 reg, enum dccPercent dccPercent)
+int rf69_set_dc_cut_off_frequency_intern(struct spi_device *spi, u8 reg, enum dccPercent dccPercent)
 {
 	switch (dccPercent) {
-	case dcc16Percent:	return WRITE_REG(reg, ( (READ_REG(reg) & ~MASK_BW_DCC_FREQ) | BW_DCC_16_PERCENT) );
-	case dcc8Percent:	return WRITE_REG(reg, ( (READ_REG(reg) & ~MASK_BW_DCC_FREQ) | BW_DCC_8_PERCENT) );
-	case dcc4Percent:	return WRITE_REG(reg, ( (READ_REG(reg) & ~MASK_BW_DCC_FREQ) | BW_DCC_4_PERCENT) );
-	case dcc2Percent:	return WRITE_REG(reg, ( (READ_REG(reg) & ~MASK_BW_DCC_FREQ) | BW_DCC_2_PERCENT) );
-	case dcc1Percent:	return WRITE_REG(reg, ( (READ_REG(reg) & ~MASK_BW_DCC_FREQ) | BW_DCC_1_PERCENT) );
-	case dcc0_5Percent:	return WRITE_REG(reg, ( (READ_REG(reg) & ~MASK_BW_DCC_FREQ) | BW_DCC_0_5_PERCENT) );
-	case dcc0_25Percent:	return WRITE_REG(reg, ( (READ_REG(reg) & ~MASK_BW_DCC_FREQ) | BW_DCC_0_25_PERCENT) );
-	case dcc0_125Percent:	return WRITE_REG(reg, ( (READ_REG(reg) & ~MASK_BW_DCC_FREQ) | BW_DCC_0_125_PERCENT) );
+	case dcc16Percent:	return WRITE_REG(reg, ((READ_REG(reg) & ~MASK_BW_DCC_FREQ) | BW_DCC_16_PERCENT));
+	case dcc8Percent:	return WRITE_REG(reg, ((READ_REG(reg) & ~MASK_BW_DCC_FREQ) | BW_DCC_8_PERCENT));
+	case dcc4Percent:	return WRITE_REG(reg, ((READ_REG(reg) & ~MASK_BW_DCC_FREQ) | BW_DCC_4_PERCENT));
+	case dcc2Percent:	return WRITE_REG(reg, ((READ_REG(reg) & ~MASK_BW_DCC_FREQ) | BW_DCC_2_PERCENT));
+	case dcc1Percent:	return WRITE_REG(reg, ((READ_REG(reg) & ~MASK_BW_DCC_FREQ) | BW_DCC_1_PERCENT));
+	case dcc0_5Percent:	return WRITE_REG(reg, ((READ_REG(reg) & ~MASK_BW_DCC_FREQ) | BW_DCC_0_5_PERCENT));
+	case dcc0_25Percent:	return WRITE_REG(reg, ((READ_REG(reg) & ~MASK_BW_DCC_FREQ) | BW_DCC_0_25_PERCENT));
+	case dcc0_125Percent:	return WRITE_REG(reg, ((READ_REG(reg) & ~MASK_BW_DCC_FREQ) | BW_DCC_0_125_PERCENT));
 	default:
 		dev_dbg(&spi->dev, "set: illegal input param");
 		return -EINVAL;
@@ -481,7 +481,7 @@ static int rf69_set_bandwidth_intern(struct spi_device *spi, u8 reg,
 	newValue = newValue & MASK_BW_DCC_FREQ;
 
 	// add new mantisse
-	switch(mantisse) {
+	switch (mantisse) {
 	case mantisse16:
 		newValue = newValue | BW_MANT_16;
 		break;
@@ -525,9 +525,9 @@ int rf69_set_ook_threshold_type(struct spi_device *spi, enum thresholdType thres
 	#endif
 
 	switch (thresholdType) {
-	case fixed:	return WRITE_REG(REG_OOKPEAK, ( (READ_REG(REG_OOKPEAK) & ~MASK_OOKPEAK_THRESTYPE) | OOKPEAK_THRESHTYPE_FIXED) );
-	case peak:	return WRITE_REG(REG_OOKPEAK, ( (READ_REG(REG_OOKPEAK) & ~MASK_OOKPEAK_THRESTYPE) | OOKPEAK_THRESHTYPE_PEAK) );
-	case average:	return WRITE_REG(REG_OOKPEAK, ( (READ_REG(REG_OOKPEAK) & ~MASK_OOKPEAK_THRESTYPE) | OOKPEAK_THRESHTYPE_AVERAGE) );
+	case fixed:	return WRITE_REG(REG_OOKPEAK, ((READ_REG(REG_OOKPEAK) & ~MASK_OOKPEAK_THRESTYPE) | OOKPEAK_THRESHTYPE_FIXED));
+	case peak:	return WRITE_REG(REG_OOKPEAK, ((READ_REG(REG_OOKPEAK) & ~MASK_OOKPEAK_THRESTYPE) | OOKPEAK_THRESHTYPE_PEAK));
+	case average:	return WRITE_REG(REG_OOKPEAK, ((READ_REG(REG_OOKPEAK) & ~MASK_OOKPEAK_THRESTYPE) | OOKPEAK_THRESHTYPE_AVERAGE));
 	default:
 		dev_dbg(&spi->dev, "set: illegal input param");
 		return -EINVAL;
@@ -541,14 +541,14 @@ int rf69_set_ook_threshold_step(struct spi_device *spi, enum thresholdStep thres
 	#endif
 
 	switch (thresholdStep) {
-	case step_0_5db: return WRITE_REG(REG_OOKPEAK, ( (READ_REG(REG_OOKPEAK) & ~MASK_OOKPEAK_THRESSTEP) | OOKPEAK_THRESHSTEP_0_5_DB) );
-	case step_1_0db: return WRITE_REG(REG_OOKPEAK, ( (READ_REG(REG_OOKPEAK) & ~MASK_OOKPEAK_THRESSTEP) | OOKPEAK_THRESHSTEP_1_0_DB) );
-	case step_1_5db: return WRITE_REG(REG_OOKPEAK, ( (READ_REG(REG_OOKPEAK) & ~MASK_OOKPEAK_THRESSTEP) | OOKPEAK_THRESHSTEP_1_5_DB) );
-	case step_2_0db: return WRITE_REG(REG_OOKPEAK, ( (READ_REG(REG_OOKPEAK) & ~MASK_OOKPEAK_THRESSTEP) | OOKPEAK_THRESHSTEP_2_0_DB) );
-	case step_3_0db: return WRITE_REG(REG_OOKPEAK, ( (READ_REG(REG_OOKPEAK) & ~MASK_OOKPEAK_THRESSTEP) | OOKPEAK_THRESHSTEP_3_0_DB) );
-	case step_4_0db: return WRITE_REG(REG_OOKPEAK, ( (READ_REG(REG_OOKPEAK) & ~MASK_OOKPEAK_THRESSTEP) | OOKPEAK_THRESHSTEP_4_0_DB) );
-	case step_5_0db: return WRITE_REG(REG_OOKPEAK, ( (READ_REG(REG_OOKPEAK) & ~MASK_OOKPEAK_THRESSTEP) | OOKPEAK_THRESHSTEP_5_0_DB) );
-	case step_6_0db: return WRITE_REG(REG_OOKPEAK, ( (READ_REG(REG_OOKPEAK) & ~MASK_OOKPEAK_THRESSTEP) | OOKPEAK_THRESHSTEP_6_0_DB) );
+	case step_0_5db: return WRITE_REG(REG_OOKPEAK, ((READ_REG(REG_OOKPEAK) & ~MASK_OOKPEAK_THRESSTEP) | OOKPEAK_THRESHSTEP_0_5_DB));
+	case step_1_0db: return WRITE_REG(REG_OOKPEAK, ((READ_REG(REG_OOKPEAK) & ~MASK_OOKPEAK_THRESSTEP) | OOKPEAK_THRESHSTEP_1_0_DB));
+	case step_1_5db: return WRITE_REG(REG_OOKPEAK, ((READ_REG(REG_OOKPEAK) & ~MASK_OOKPEAK_THRESSTEP) | OOKPEAK_THRESHSTEP_1_5_DB));
+	case step_2_0db: return WRITE_REG(REG_OOKPEAK, ((READ_REG(REG_OOKPEAK) & ~MASK_OOKPEAK_THRESSTEP) | OOKPEAK_THRESHSTEP_2_0_DB));
+	case step_3_0db: return WRITE_REG(REG_OOKPEAK, ((READ_REG(REG_OOKPEAK) & ~MASK_OOKPEAK_THRESSTEP) | OOKPEAK_THRESHSTEP_3_0_DB));
+	case step_4_0db: return WRITE_REG(REG_OOKPEAK, ((READ_REG(REG_OOKPEAK) & ~MASK_OOKPEAK_THRESSTEP) | OOKPEAK_THRESHSTEP_4_0_DB));
+	case step_5_0db: return WRITE_REG(REG_OOKPEAK, ((READ_REG(REG_OOKPEAK) & ~MASK_OOKPEAK_THRESSTEP) | OOKPEAK_THRESHSTEP_5_0_DB));
+	case step_6_0db: return WRITE_REG(REG_OOKPEAK, ((READ_REG(REG_OOKPEAK) & ~MASK_OOKPEAK_THRESSTEP) | OOKPEAK_THRESHSTEP_6_0_DB));
 	default:
 		dev_dbg(&spi->dev, "set: illegal input param");
 		return -EINVAL;
@@ -562,14 +562,14 @@ int rf69_set_ook_threshold_dec(struct spi_device *spi, enum thresholdDecrement t
 	#endif
 
 	switch (thresholdDecrement) {
-	case dec_every8th: return WRITE_REG(REG_OOKPEAK, ( (READ_REG(REG_OOKPEAK) & ~MASK_OOKPEAK_THRESDEC) | OOKPEAK_THRESHDEC_EVERY_8TH) );
-	case dec_every4th: return WRITE_REG(REG_OOKPEAK, ( (READ_REG(REG_OOKPEAK) & ~MASK_OOKPEAK_THRESDEC) | OOKPEAK_THRESHDEC_EVERY_4TH) );
-	case dec_every2nd: return WRITE_REG(REG_OOKPEAK, ( (READ_REG(REG_OOKPEAK) & ~MASK_OOKPEAK_THRESDEC) | OOKPEAK_THRESHDEC_EVERY_2ND) );
-	case dec_once:	   return WRITE_REG(REG_OOKPEAK, ( (READ_REG(REG_OOKPEAK) & ~MASK_OOKPEAK_THRESDEC) | OOKPEAK_THRESHDEC_ONCE) );
-	case dec_twice:	   return WRITE_REG(REG_OOKPEAK, ( (READ_REG(REG_OOKPEAK) & ~MASK_OOKPEAK_THRESDEC) | OOKPEAK_THRESHDEC_TWICE) );
-	case dec_4times:   return WRITE_REG(REG_OOKPEAK, ( (READ_REG(REG_OOKPEAK) & ~MASK_OOKPEAK_THRESDEC) | OOKPEAK_THRESHDEC_4_TIMES) );
-	case dec_8times:   return WRITE_REG(REG_OOKPEAK, ( (READ_REG(REG_OOKPEAK) & ~MASK_OOKPEAK_THRESDEC) | OOKPEAK_THRESHDEC_8_TIMES) );
-	case dec_16times:  return WRITE_REG(REG_OOKPEAK, ( (READ_REG(REG_OOKPEAK) & ~MASK_OOKPEAK_THRESDEC) | OOKPEAK_THRESHDEC_16_TIMES) );
+	case dec_every8th: return WRITE_REG(REG_OOKPEAK, ((READ_REG(REG_OOKPEAK) & ~MASK_OOKPEAK_THRESDEC) | OOKPEAK_THRESHDEC_EVERY_8TH));
+	case dec_every4th: return WRITE_REG(REG_OOKPEAK, ((READ_REG(REG_OOKPEAK) & ~MASK_OOKPEAK_THRESDEC) | OOKPEAK_THRESHDEC_EVERY_4TH));
+	case dec_every2nd: return WRITE_REG(REG_OOKPEAK, ((READ_REG(REG_OOKPEAK) & ~MASK_OOKPEAK_THRESDEC) | OOKPEAK_THRESHDEC_EVERY_2ND));
+	case dec_once:	   return WRITE_REG(REG_OOKPEAK, ((READ_REG(REG_OOKPEAK) & ~MASK_OOKPEAK_THRESDEC) | OOKPEAK_THRESHDEC_ONCE));
+	case dec_twice:	   return WRITE_REG(REG_OOKPEAK, ((READ_REG(REG_OOKPEAK) & ~MASK_OOKPEAK_THRESDEC) | OOKPEAK_THRESHDEC_TWICE));
+	case dec_4times:   return WRITE_REG(REG_OOKPEAK, ((READ_REG(REG_OOKPEAK) & ~MASK_OOKPEAK_THRESDEC) | OOKPEAK_THRESHDEC_4_TIMES));
+	case dec_8times:   return WRITE_REG(REG_OOKPEAK, ((READ_REG(REG_OOKPEAK) & ~MASK_OOKPEAK_THRESDEC) | OOKPEAK_THRESHDEC_8_TIMES));
+	case dec_16times:  return WRITE_REG(REG_OOKPEAK, ((READ_REG(REG_OOKPEAK) & ~MASK_OOKPEAK_THRESDEC) | OOKPEAK_THRESHDEC_16_TIMES));
 	default:
 		dev_dbg(&spi->dev, "set: illegal input param");
 		return -EINVAL;
@@ -618,7 +618,7 @@ int rf69_set_dio_mapping(struct spi_device *spi, u8 DIONumber, u8 value)
 	// add new value
 	regValue = regValue | value << shift;
 	// write back
-	return WRITE_REG(regaddr,regValue);
+	return WRITE_REG(regaddr, regValue);
 }
 
 bool rf69_get_flag(struct spi_device *spi, enum flag flag)
@@ -627,7 +627,7 @@ bool rf69_get_flag(struct spi_device *spi, enum flag flag)
 		dev_dbg(&spi->dev, "get: flag");
 	#endif
 
-	switch(flag) {
+	switch (flag) {
 	case modeSwitchCompleted:     return (READ_REG(REG_IRQFLAGS1) & MASK_IRQFLAGS1_MODE_READY);
 	case readyToReceive:	      return (READ_REG(REG_IRQFLAGS1) & MASK_IRQFLAGS1_RX_READY);
 	case readyToSend:	      return (READ_REG(REG_IRQFLAGS1) & MASK_IRQFLAGS1_TX_READY);
@@ -655,7 +655,7 @@ int rf69_reset_flag(struct spi_device *spi, enum flag flag)
 		dev_dbg(&spi->dev, "reset: flag");
 	#endif
 
-	switch(flag) {
+	switch (flag) {
 	case rssiExceededThreshold: return WRITE_REG(REG_IRQFLAGS1, MASK_IRQFLAGS1_RSSI);
 	case syncAddressMatch:	    return WRITE_REG(REG_IRQFLAGS1, MASK_IRQFLAGS1_SYNC_ADDRESS_MATCH);
 	case fifoOverrun:	    return WRITE_REG(REG_IRQFLAGS2, MASK_IRQFLAGS2_FIFO_OVERRUN);
@@ -726,9 +726,9 @@ int rf69_set_sync_enable(struct spi_device *spi, enum optionOnOff optionOnOff)
 		dev_dbg(&spi->dev, "set: sync enable");
 	#endif
 
-	switch(optionOnOff) {
-	case optionOn:	return WRITE_REG(REG_SYNC_CONFIG, (READ_REG(REG_SYNC_CONFIG) |  MASK_SYNC_CONFIG_SYNC_ON) );
-	case optionOff:	return WRITE_REG(REG_SYNC_CONFIG, (READ_REG(REG_SYNC_CONFIG) & ~MASK_SYNC_CONFIG_SYNC_ON) );
+	switch (optionOnOff) {
+	case optionOn:	return WRITE_REG(REG_SYNC_CONFIG, (READ_REG(REG_SYNC_CONFIG) |  MASK_SYNC_CONFIG_SYNC_ON));
+	case optionOff:	return WRITE_REG(REG_SYNC_CONFIG, (READ_REG(REG_SYNC_CONFIG) & ~MASK_SYNC_CONFIG_SYNC_ON));
 	default:
 		dev_dbg(&spi->dev, "set: illegal input param");
 		return -EINVAL;
@@ -741,9 +741,9 @@ int rf69_set_fifo_fill_condition(struct spi_device *spi, enum fifoFillCondition
 		dev_dbg(&spi->dev, "set: fifo fill condition");
 	#endif
 
-	switch(fifoFillCondition) {
-	case always:		 return WRITE_REG(REG_SYNC_CONFIG, (READ_REG(REG_SYNC_CONFIG) |  MASK_SYNC_CONFIG_FIFO_FILL_CONDITION) );
-	case afterSyncInterrupt: return WRITE_REG(REG_SYNC_CONFIG, (READ_REG(REG_SYNC_CONFIG) & ~MASK_SYNC_CONFIG_FIFO_FILL_CONDITION) );
+	switch (fifoFillCondition) {
+	case always:		 return WRITE_REG(REG_SYNC_CONFIG, (READ_REG(REG_SYNC_CONFIG) |  MASK_SYNC_CONFIG_FIFO_FILL_CONDITION));
+	case afterSyncInterrupt: return WRITE_REG(REG_SYNC_CONFIG, (READ_REG(REG_SYNC_CONFIG) & ~MASK_SYNC_CONFIG_FIFO_FILL_CONDITION));
 	default:
 		dev_dbg(&spi->dev, "set: illegal input param");
 		return -EINVAL;
@@ -763,7 +763,7 @@ int rf69_set_sync_size(struct spi_device *spi, u8 syncSize)
 	}
 
 	// write value
-	return WRITE_REG(REG_SYNC_CONFIG, (READ_REG(REG_SYNC_CONFIG) & ~MASK_SYNC_CONFIG_SYNC_SIZE) | (syncSize << 3) );
+	return WRITE_REG(REG_SYNC_CONFIG, (READ_REG(REG_SYNC_CONFIG) & ~MASK_SYNC_CONFIG_SYNC_SIZE) | (syncSize << 3));
 }
 
 int rf69_set_sync_tolerance(struct spi_device *spi, u8 syncTolerance)
@@ -808,9 +808,9 @@ int rf69_set_packet_format(struct spi_device *spi, enum packetFormat packetForma
 		dev_dbg(&spi->dev, "set: packet format");
 	#endif
 
-	switch(packetFormat) {
-	case packetLengthVar: return WRITE_REG(REG_PACKETCONFIG1, (READ_REG(REG_PACKETCONFIG1) |  MASK_PACKETCONFIG1_PAKET_FORMAT_VARIABLE) );
-	case packetLengthFix: return WRITE_REG(REG_PACKETCONFIG1, (READ_REG(REG_PACKETCONFIG1) & ~MASK_PACKETCONFIG1_PAKET_FORMAT_VARIABLE) );
+	switch (packetFormat) {
+	case packetLengthVar: return WRITE_REG(REG_PACKETCONFIG1, (READ_REG(REG_PACKETCONFIG1) |  MASK_PACKETCONFIG1_PAKET_FORMAT_VARIABLE));
+	case packetLengthFix: return WRITE_REG(REG_PACKETCONFIG1, (READ_REG(REG_PACKETCONFIG1) & ~MASK_PACKETCONFIG1_PAKET_FORMAT_VARIABLE));
 	default:
 		dev_dbg(&spi->dev, "set: illegal input param");
 		return -EINVAL;
@@ -823,9 +823,9 @@ int rf69_set_crc_enable(struct spi_device *spi, enum optionOnOff optionOnOff)
 		dev_dbg(&spi->dev, "set: crc enable");
 	#endif
 
-	switch(optionOnOff) {
-	case optionOn:	return WRITE_REG(REG_PACKETCONFIG1, (READ_REG(REG_PACKETCONFIG1) |  MASK_PACKETCONFIG1_CRC_ON) );
-	case optionOff:	return WRITE_REG(REG_PACKETCONFIG1, (READ_REG(REG_PACKETCONFIG1) & ~MASK_PACKETCONFIG1_CRC_ON) );
+	switch (optionOnOff) {
+	case optionOn:	return WRITE_REG(REG_PACKETCONFIG1, (READ_REG(REG_PACKETCONFIG1) |  MASK_PACKETCONFIG1_CRC_ON));
+	case optionOff:	return WRITE_REG(REG_PACKETCONFIG1, (READ_REG(REG_PACKETCONFIG1) & ~MASK_PACKETCONFIG1_CRC_ON));
 	default:
 		dev_dbg(&spi->dev, "set: illegal input param");
 		return -EINVAL;
@@ -839,9 +839,9 @@ int rf69_set_adressFiltering(struct spi_device *spi, enum addressFiltering addre
 	#endif
 
 	switch (addressFiltering) {
-	case filteringOff:	     return WRITE_REG(REG_PACKETCONFIG1, ( (READ_REG(REG_PACKETCONFIG1) & ~MASK_PACKETCONFIG1_ADDRESSFILTERING) | PACKETCONFIG1_ADDRESSFILTERING_OFF) );
-	case nodeAddress:	     return WRITE_REG(REG_PACKETCONFIG1, ( (READ_REG(REG_PACKETCONFIG1) & ~MASK_PACKETCONFIG1_ADDRESSFILTERING) | PACKETCONFIG1_ADDRESSFILTERING_NODE) );
-	case nodeOrBroadcastAddress: return WRITE_REG(REG_PACKETCONFIG1, ( (READ_REG(REG_PACKETCONFIG1) & ~MASK_PACKETCONFIG1_ADDRESSFILTERING) | PACKETCONFIG1_ADDRESSFILTERING_NODEBROADCAST) );
+	case filteringOff:	     return WRITE_REG(REG_PACKETCONFIG1, ((READ_REG(REG_PACKETCONFIG1) & ~MASK_PACKETCONFIG1_ADDRESSFILTERING) | PACKETCONFIG1_ADDRESSFILTERING_OFF));
+	case nodeAddress:	     return WRITE_REG(REG_PACKETCONFIG1, ((READ_REG(REG_PACKETCONFIG1) & ~MASK_PACKETCONFIG1_ADDRESSFILTERING) | PACKETCONFIG1_ADDRESSFILTERING_NODE));
+	case nodeOrBroadcastAddress: return WRITE_REG(REG_PACKETCONFIG1, ((READ_REG(REG_PACKETCONFIG1) & ~MASK_PACKETCONFIG1_ADDRESSFILTERING) | PACKETCONFIG1_ADDRESSFILTERING_NODEBROADCAST));
 	default:
 		dev_dbg(&spi->dev, "set: illegal input param");
 		return -EINVAL;
@@ -890,9 +890,9 @@ int rf69_set_tx_start_condition(struct spi_device *spi, enum txStartCondition tx
 		dev_dbg(&spi->dev, "set: start condition");
 	#endif
 
-	switch(txStartCondition) {
-	case fifoLevel:	   return WRITE_REG(REG_FIFO_THRESH, (READ_REG(REG_FIFO_THRESH) & ~MASK_FIFO_THRESH_TXSTART) );
-	case fifoNotEmpty: return WRITE_REG(REG_FIFO_THRESH, (READ_REG(REG_FIFO_THRESH) |  MASK_FIFO_THRESH_TXSTART) );
+	switch (txStartCondition) {
+	case fifoLevel:	   return WRITE_REG(REG_FIFO_THRESH, (READ_REG(REG_FIFO_THRESH) & ~MASK_FIFO_THRESH_TXSTART));
+	case fifoNotEmpty: return WRITE_REG(REG_FIFO_THRESH, (READ_REG(REG_FIFO_THRESH) |  MASK_FIFO_THRESH_TXSTART));
 	default:
 		dev_dbg(&spi->dev, "set: illegal input param");
 		return -EINVAL;
@@ -928,7 +928,7 @@ int rf69_set_dagc(struct spi_device *spi, enum dagc dagc)
 		dev_dbg(&spi->dev, "set: dagc");
 	#endif
 
-	switch(dagc) {
+	switch (dagc) {
 	case normalMode:		 return WRITE_REG(REG_TESTDAGC, DAGC_NORMAL);
 	case improve:			 return WRITE_REG(REG_TESTDAGC, DAGC_IMPROVED_LOWBETA0);
 	case improve4LowModulationIndex: return WRITE_REG(REG_TESTDAGC, DAGC_IMPROVED_LOWBETA1);
@@ -995,7 +995,7 @@ int rf69_write_fifo(struct spi_device *spi, u8 *buffer, unsigned int size)
 
 	#ifdef DEBUG_FIFO_ACCESS
 		for (i = 0; i < size; i++)
-			dev_dbg(&spi->dev, "0x%x\n",buffer[i]);
+			dev_dbg(&spi->dev, "0x%x\n", buffer[i]);
 	#endif
 
 	return spi_write (spi, local_buffer, size + 1);

commit 308d32efc4c7609efc34a289d0a7f0a632f67f3b
Author: Marcin Ciupak <marcin.s.ciupak@gmail.com>
Date:   Wed Oct 11 21:23:39 2017 +0200

    staging: pi433: rf69.c style fix - spaces required around
    
    This patch fixes the following checkpatch.pl errors:
    
    ERROR: spaces required around that '+=' (ctx:WxV)
    ERROR: spaces required around that '=' (ctx:VxV)
    ERROR: spaces required around that '<' (ctx:VxV)
    
    in rf69.c file as requested by TODO file.
    
    Additionally some style warnings remain valid here and could be fixed by
    another patch.
    
    Signed-off-by: Marcin Ciupak <marcin.s.ciupak@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/pi433/rf69.c b/drivers/staging/pi433/rf69.c
index 3d9cf2cac4ef..7a79973641c9 100644
--- a/drivers/staging/pi433/rf69.c
+++ b/drivers/staging/pi433/rf69.c
@@ -323,7 +323,7 @@ int rf69_set_output_power_level(struct spi_device *spi, u8 powerLevel)
 		dev_dbg(&spi->dev, "set: power level");
 	#endif
 
-	powerLevel +=18; // TODO Abhngigkeit von PA0,1,2 setting
+	powerLevel += 18; // TODO Abhngigkeit von PA0,1,2 setting
 
 	// check input value
 	if (powerLevel > 0x1f) {
@@ -589,24 +589,30 @@ int rf69_set_dio_mapping(struct spi_device *spi, u8 DIONumber, u8 value)
 
 	switch (DIONumber) {
 	case 0:
-		mask=MASK_DIO0; shift=SHIFT_DIO0; regaddr=REG_DIOMAPPING1; break;
+		mask = MASK_DIO0; shift = SHIFT_DIO0; regaddr = REG_DIOMAPPING1;
+		break;
 	case 1:
-		mask=MASK_DIO1; shift=SHIFT_DIO1; regaddr=REG_DIOMAPPING1; break;
+		mask = MASK_DIO1; shift = SHIFT_DIO1; regaddr = REG_DIOMAPPING1;
+		break;
 	case 2:
-		mask=MASK_DIO2; shift=SHIFT_DIO2; regaddr=REG_DIOMAPPING1; break;
+		mask = MASK_DIO2; shift = SHIFT_DIO2; regaddr = REG_DIOMAPPING1;
+		break;
 	case 3:
-		mask=MASK_DIO3; shift=SHIFT_DIO3; regaddr=REG_DIOMAPPING1; break;
+		mask = MASK_DIO3; shift = SHIFT_DIO3; regaddr = REG_DIOMAPPING1;
+		break;
 	case 4:
-		mask=MASK_DIO4; shift=SHIFT_DIO4; regaddr=REG_DIOMAPPING2; break;
+		mask = MASK_DIO4; shift = SHIFT_DIO4; regaddr = REG_DIOMAPPING2;
+		break;
 	case 5:
-		mask=MASK_DIO5; shift=SHIFT_DIO5; regaddr=REG_DIOMAPPING2; break;
+		mask = MASK_DIO5; shift = SHIFT_DIO5; regaddr = REG_DIOMAPPING2;
+		break;
 	default:
 		dev_dbg(&spi->dev, "set: illegal input param");
 		return -EINVAL;
 	}
 
 	// read reg
-	regValue=READ_REG(regaddr);
+	regValue = READ_REG(regaddr);
 	// delete old value
 	regValue = regValue & ~mask;
 	// add new value
@@ -960,7 +966,7 @@ int rf69_read_fifo (struct spi_device *spi, u8 *buffer, unsigned int size)
 	retval = spi_sync_transfer(spi, &transfer, 1);
 
 	#ifdef DEBUG_FIFO_ACCESS
-		for (i=0; i<size; i++)
+		for (i = 0; i < size; i++)
 			dev_dbg(&spi->dev, "%d - 0x%x\n", i, local_buffer[i+1]);
 	#endif
 
@@ -988,7 +994,7 @@ int rf69_write_fifo(struct spi_device *spi, u8 *buffer, unsigned int size)
 	memcpy(&local_buffer[1], buffer, size);  // TODO: ohne memcopy wre schner
 
 	#ifdef DEBUG_FIFO_ACCESS
-		for (i=0; i<size; i++)
+		for (i = 0; i < size; i++)
 			dev_dbg(&spi->dev, "0x%x\n",buffer[i]);
 	#endif
 

commit 4a74749a50a8f143df53a9ff139236790f1f6fd3
Author: Marcin Ciupak <marcin.s.ciupak@gmail.com>
Date:   Wed Oct 11 21:23:26 2017 +0200

    staging: pi433: rf69.c style fix - trailing statements
    
    This patch fixes the following checkpatch.pl error:
    
    ERROR: trailing statements should be on next line
    
    in rf69.c file as requested by TODO file.
    
    Note:
    ERROR: spaces required around that '=' (ctx:VxV)
    remains valid here and is going to be fixed by the next patch in set.
    
    Additionally some style warnings remain valid here and could be fixed by
    another patch.
    
    Signed-off-by: Marcin Ciupak <marcin.s.ciupak@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/pi433/rf69.c b/drivers/staging/pi433/rf69.c
index 0305edc16861..3d9cf2cac4ef 100644
--- a/drivers/staging/pi433/rf69.c
+++ b/drivers/staging/pi433/rf69.c
@@ -164,9 +164,12 @@ int rf69_set_bit_rate(struct spi_device *spi, u16 bitRate)
 
 	// transmit to RF 69
 	retval = WRITE_REG(REG_BITRATE_MSB, msb);
-	if (retval)  return retval;
+	if (retval)
+		return retval;
+
 	retval = WRITE_REG(REG_BITRATE_LSB, lsb);
-	if (retval)  return retval;
+	if (retval)
+		return retval;
 
 	return 0;
 }
@@ -209,9 +212,12 @@ int rf69_set_deviation(struct spi_device *spi, u32 deviation)
 
 	// write to chip
 	retval = WRITE_REG(REG_FDEV_MSB, msb);
-	if (retval)  return retval;
+	if (retval)
+		return retval;
+
 	retval = WRITE_REG(REG_FDEV_LSB, lsb);
-	if (retval)  return retval;
+	if (retval)
+		return retval;
 
 	return 0;
 }
@@ -252,11 +258,16 @@ int rf69_set_frequency(struct spi_device *spi, u32 frequency)
 
 	// write to chip
 	retval = WRITE_REG(REG_FRF_MSB, msb);
-	if (retval)  return retval;
+	if (retval)
+		return retval;
+
 	retval = WRITE_REG(REG_FRF_MID, mid);
-	if (retval)  return retval;
+	if (retval)
+		return retval;
+
 	retval = WRITE_REG(REG_FRF_LSB, lsb);
-	if (retval)  return retval;
+	if (retval)
+		return retval;
 
 	return 0;
 }
@@ -471,9 +482,15 @@ static int rf69_set_bandwidth_intern(struct spi_device *spi, u8 reg,
 
 	// add new mantisse
 	switch(mantisse) {
-	case mantisse16: newValue = newValue | BW_MANT_16;	break;
-	case mantisse20: newValue = newValue | BW_MANT_20;	break;
-	case mantisse24: newValue = newValue | BW_MANT_24;	break;
+	case mantisse16:
+		newValue = newValue | BW_MANT_16;
+		break;
+	case mantisse20:
+		newValue = newValue | BW_MANT_20;
+		break;
+	case mantisse24:
+		newValue = newValue | BW_MANT_24;
+		break;
 	}
 
 	// add new exponent
@@ -571,12 +588,18 @@ int rf69_set_dio_mapping(struct spi_device *spi, u8 DIONumber, u8 value)
 	#endif
 
 	switch (DIONumber) {
-	case 0: mask=MASK_DIO0; shift=SHIFT_DIO0; regaddr=REG_DIOMAPPING1; break;
-	case 1: mask=MASK_DIO1; shift=SHIFT_DIO1; regaddr=REG_DIOMAPPING1; break;
-	case 2: mask=MASK_DIO2; shift=SHIFT_DIO2; regaddr=REG_DIOMAPPING1; break;
-	case 3: mask=MASK_DIO3; shift=SHIFT_DIO3; regaddr=REG_DIOMAPPING1; break;
-	case 4: mask=MASK_DIO4; shift=SHIFT_DIO4; regaddr=REG_DIOMAPPING2; break;
-	case 5: mask=MASK_DIO5; shift=SHIFT_DIO5; regaddr=REG_DIOMAPPING2; break;
+	case 0:
+		mask=MASK_DIO0; shift=SHIFT_DIO0; regaddr=REG_DIOMAPPING1; break;
+	case 1:
+		mask=MASK_DIO1; shift=SHIFT_DIO1; regaddr=REG_DIOMAPPING1; break;
+	case 2:
+		mask=MASK_DIO2; shift=SHIFT_DIO2; regaddr=REG_DIOMAPPING1; break;
+	case 3:
+		mask=MASK_DIO3; shift=SHIFT_DIO3; regaddr=REG_DIOMAPPING1; break;
+	case 4:
+		mask=MASK_DIO4; shift=SHIFT_DIO4; regaddr=REG_DIOMAPPING2; break;
+	case 5:
+		mask=MASK_DIO5; shift=SHIFT_DIO5; regaddr=REG_DIOMAPPING2; break;
 	default:
 		dev_dbg(&spi->dev, "set: illegal input param");
 		return -EINVAL;
@@ -686,7 +709,8 @@ int rf69_set_preamble_length(struct spi_device *spi, u16 preambleLength)
 
 	/* transmit to chip */
 	retval = WRITE_REG(REG_PREAMBLE_MSB, msb);
-	if (retval) return retval;
+	if (retval)
+		return retval;
 	return WRITE_REG(REG_PREAMBLE_LSB, lsb);
 }
 

commit 1236d6bb6e19fc72ffc6bbcdeb1bfefe450e54ee
Merge: 750b1a6894ec 8a5776a5f498
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon Oct 9 09:02:35 2017 +0200

    Merge 4.14-rc4 into staging-next
    
    We want the staging/iio fixes in here as well to handle merge issues.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit b72703e26b9478da531144ce5c4552dd22f1103d
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Wed Sep 6 17:40:25 2017 +0200

    staging: pi433: Move limit check to switch default to kill warning
    
    With gcc-4.1.2:
    
        drivers/staging/pi433/rf69.c: In function ‘rf69_set_dio_mapping’:
        drivers/staging/pi433/rf69.c:566: warning: ‘regaddr’ may be used uninitialized in this function
        drivers/staging/pi433/rf69.c:565: warning: ‘shift’ may be used uninitialized in this function
        drivers/staging/pi433/rf69.c:564: warning: ‘mask’ may be used uninitialized in this function
    
    While this is a false positive, it can easily be fixed by moving the
    limit check into the "default" case of the switch statement.
    
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/pi433/rf69.c b/drivers/staging/pi433/rf69.c
index c4b1b218ea38..290b419aa9dd 100644
--- a/drivers/staging/pi433/rf69.c
+++ b/drivers/staging/pi433/rf69.c
@@ -570,12 +570,6 @@ int rf69_set_dio_mapping(struct spi_device *spi, u8 DIONumber, u8 value)
 		dev_dbg(&spi->dev, "set: DIO mapping");
 	#endif
 
-	// check DIO number
-	if (DIONumber > 5) {
-		dev_dbg(&spi->dev, "set: illegal input param");
-		return -EINVAL;
-	}
-
 	switch (DIONumber) {
 	case 0: mask=MASK_DIO0; shift=SHIFT_DIO0; regaddr=REG_DIOMAPPING1; break;
 	case 1: mask=MASK_DIO1; shift=SHIFT_DIO1; regaddr=REG_DIOMAPPING1; break;
@@ -583,6 +577,9 @@ int rf69_set_dio_mapping(struct spi_device *spi, u8 DIONumber, u8 value)
 	case 3: mask=MASK_DIO3; shift=SHIFT_DIO3; regaddr=REG_DIOMAPPING1; break;
 	case 4: mask=MASK_DIO4; shift=SHIFT_DIO4; regaddr=REG_DIOMAPPING2; break;
 	case 5: mask=MASK_DIO5; shift=SHIFT_DIO5; regaddr=REG_DIOMAPPING2; break;
+	default:
+		dev_dbg(&spi->dev, "set: illegal input param");
+		return -EINVAL;
 	}
 
 	// read reg

commit e2614ef1b2ecb3f9f1e17762b01c2b29dbc344aa
Author: Meghana Madhyastha <meghana.madhyastha@gmail.com>
Date:   Fri Sep 15 12:34:30 2017 +0530

    Staging: pi433: Merge assignment with return value
    
    Removes the unnecessary assignment of retval preceding
    the return statement.
    
    Detected using the following Coccinelle script:
    @@
    local idexpression ret;
    expression e;
    @@
    
    -ret =
    +return
         e;
    -return ret;
    
    Signed-off-by: Meghana Madhyastha <meghana.madhyastha@gmail.com>
    Acked-by: Julia Lawall <julia.lawall@lip6.fr>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/pi433/rf69.c b/drivers/staging/pi433/rf69.c
index c4b1b218ea38..f5b90aa759ea 100644
--- a/drivers/staging/pi433/rf69.c
+++ b/drivers/staging/pi433/rf69.c
@@ -690,9 +690,7 @@ int rf69_set_preamble_length(struct spi_device *spi, u16 preambleLength)
 	/* transmit to chip */
 	retval = WRITE_REG(REG_PREAMBLE_MSB, msb);
 	if (retval) return retval;
-	retval = WRITE_REG(REG_PREAMBLE_LSB, lsb);
-
-	return retval;
+	return WRITE_REG(REG_PREAMBLE_LSB, lsb);
 }
 
 int rf69_set_sync_enable(struct spi_device *spi, enum optionOnOff optionOnOff)

commit 5dcf92266cdc994fc380521258b2e81025e31df9
Author: Colin Ian King <colin.king@canonical.com>
Date:   Wed Aug 30 13:05:38 2017 +0100

    staging: pi433: fix spelling mistake: "preample" -> "preamble"
    
    Trivial fix to spelling mistake in dev_dbg message
    
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/pi433/rf69.c b/drivers/staging/pi433/rf69.c
index f04840a799bb..c4b1b218ea38 100644
--- a/drivers/staging/pi433/rf69.c
+++ b/drivers/staging/pi433/rf69.c
@@ -678,7 +678,7 @@ int rf69_set_preamble_length(struct spi_device *spi, u16 preambleLength)
 	u8 msb, lsb;
 
 	#ifdef DEBUG
-		dev_dbg(&spi->dev, "set: preample length");
+		dev_dbg(&spi->dev, "set: preamble length");
 	#endif
 
 	/* no value check needed - u16 exactly matches register size */

commit e221b2b11bdc3f5b0a42165422335044c472964b
Author: Marcin Ciupak <marcin.s.ciupak@gmail.com>
Date:   Thu Aug 17 17:00:17 2017 +0200

    staging: pi433: replace INVALID_PARAM macro with inline code
    
    The following macro:
    \#define INVALID_PARAM
            { \
                    dev_dbg(&spi->dev, "set: illegal input param"); \
                    return -EINVAL; \
            }
    affects control flow by having return statement. This is against
    Linux Kernel Coding Style and should be avoided and therefore
    this macro is replaced by inline code.
    
    Additionally following 3 minor issues:
    
    ERROR: code indent should use tabs where possible
    ERROR: spaces required around that '!=' (ctx:VxV)
    ERROR: space prohibited before that close parenthesis ')'
    
    were fiexed inline.
    
    Signed-off-by: Marcin Ciupak <marcin.s.ciupak@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/pi433/rf69.c b/drivers/staging/pi433/rf69.c
index 3265786e8046..f04840a799bb 100644
--- a/drivers/staging/pi433/rf69.c
+++ b/drivers/staging/pi433/rf69.c
@@ -35,11 +35,6 @@
 
 #define READ_REG(x)	rf69_read_reg (spi, x)
 #define WRITE_REG(x,y)	rf69_write_reg(spi, x, y)
-#define INVALID_PARAM \
-	{ \
-		dev_dbg(&spi->dev, "set: illegal input param"); \
-		return -EINVAL; \
-	}
 
 /*-------------------------------------------------------------------------*/
 
@@ -55,7 +50,9 @@ int rf69_set_mode(struct spi_device *spi, enum mode mode)
 	case synthesizer: return WRITE_REG(REG_OPMODE, (READ_REG(REG_OPMODE) & ~MASK_OPMODE_MODE) | OPMODE_MODE_SYNTHESIZER);
 	case standby:	  return WRITE_REG(REG_OPMODE, (READ_REG(REG_OPMODE) & ~MASK_OPMODE_MODE) | OPMODE_MODE_STANDBY);
 	case mode_sleep:  return WRITE_REG(REG_OPMODE, (READ_REG(REG_OPMODE) & ~MASK_OPMODE_MODE) | OPMODE_MODE_SLEEP);
-	default:	  INVALID_PARAM;
+	default:
+		dev_dbg(&spi->dev, "set: illegal input param");
+		return -EINVAL;
 	}
 
 	// we are using packet mode, so this check is not really needed
@@ -74,7 +71,9 @@ int rf69_set_data_mode(struct spi_device *spi, enum dataMode dataMode)
 	case packet:		return WRITE_REG(REG_DATAMODUL, (READ_REG(REG_DATAMODUL) & ~MASK_DATAMODUL_MODE) | DATAMODUL_MODE_PACKET);
 	case continuous:	return WRITE_REG(REG_DATAMODUL, (READ_REG(REG_DATAMODUL) & ~MASK_DATAMODUL_MODE) | DATAMODUL_MODE_CONTINUOUS);
 	case continuousNoSync:  return WRITE_REG(REG_DATAMODUL, (READ_REG(REG_DATAMODUL) & ~MASK_DATAMODUL_MODE) | DATAMODUL_MODE_CONTINUOUS_NOSYNC);
-	default:		INVALID_PARAM;
+	default:
+		dev_dbg(&spi->dev, "set: illegal input param");
+		return -EINVAL;
 	}
 }
 
@@ -87,7 +86,9 @@ int rf69_set_modulation(struct spi_device *spi, enum modulation modulation)
 	switch (modulation) {
 	case OOK:   return WRITE_REG(REG_DATAMODUL, (READ_REG(REG_DATAMODUL) & ~MASK_DATAMODUL_MODULATION_TYPE) | DATAMODUL_MODULATION_TYPE_OOK);
 	case FSK:   return WRITE_REG(REG_DATAMODUL, (READ_REG(REG_DATAMODUL) & ~MASK_DATAMODUL_MODULATION_TYPE) | DATAMODUL_MODULATION_TYPE_FSK);
-	default:    INVALID_PARAM;
+	default:
+		dev_dbg(&spi->dev, "set: illegal input param");
+		return -EINVAL;
 	}
 }
 
@@ -120,14 +121,18 @@ int rf69_set_modulation_shaping(struct spi_device *spi, enum modShaping modShapi
 		case shaping1_0: return WRITE_REG(REG_DATAMODUL, (READ_REG(REG_DATAMODUL) & ~MASK_DATAMODUL_MODULATION_SHAPE) | DATAMODUL_MODULATION_SHAPE_1_0);
 		case shaping0_5: return WRITE_REG(REG_DATAMODUL, (READ_REG(REG_DATAMODUL) & ~MASK_DATAMODUL_MODULATION_SHAPE) | DATAMODUL_MODULATION_SHAPE_0_3);
 		case shaping0_3: return WRITE_REG(REG_DATAMODUL, (READ_REG(REG_DATAMODUL) & ~MASK_DATAMODUL_MODULATION_SHAPE) | DATAMODUL_MODULATION_SHAPE_0_5);
-		default:	 INVALID_PARAM;
+		default:
+			dev_dbg(&spi->dev, "set: illegal input param");
+			return -EINVAL;
 		}
 	} else {
 		switch (modShaping) {
 		case shapingOff: return WRITE_REG(REG_DATAMODUL, (READ_REG(REG_DATAMODUL) & ~MASK_DATAMODUL_MODULATION_SHAPE) | DATAMODUL_MODULATION_SHAPE_NONE);
 		case shapingBR:	 return WRITE_REG(REG_DATAMODUL, (READ_REG(REG_DATAMODUL) & ~MASK_DATAMODUL_MODULATION_SHAPE) | DATAMODUL_MODULATION_SHAPE_BR);
 		case shaping2BR: return WRITE_REG(REG_DATAMODUL, (READ_REG(REG_DATAMODUL) & ~MASK_DATAMODUL_MODULATION_SHAPE) | DATAMODUL_MODULATION_SHAPE_2BR);
-		default:	 INVALID_PARAM;
+		default:
+			dev_dbg(&spi->dev, "set: illegal input param");
+			return -EINVAL;
 		}
 	}
 }
@@ -148,7 +153,7 @@ int rf69_set_bit_rate(struct spi_device *spi, u16 bitRate)
 	bitRate_min = F_OSC / 8388608; // 8388608 = 2^23;
 	if (bitRate < bitRate_min) {
 		dev_dbg(&spi->dev, "setBitRate: illegal input param");
-		INVALID_PARAM;
+		return -EINVAL;
 	}
 
 	// calculate reg settings
@@ -182,7 +187,7 @@ int rf69_set_deviation(struct spi_device *spi, u32 deviation)
 
 	if (deviation < 600 || deviation > 500000) { //TODO: Abhngigkeit von Bitrate beachten!!
 		dev_dbg(&spi->dev, "set_deviation: illegal input param");
-		INVALID_PARAM;
+		return -EINVAL;
 	}
 
 	// calculat f step
@@ -199,7 +204,7 @@ int rf69_set_deviation(struct spi_device *spi, u32 deviation)
 	// check msb
 	if (msb & ~FDEVMASB_MASK) {
 		dev_dbg(&spi->dev, "set_deviation: err in calc of msb");
-		INVALID_PARAM;
+		return -EINVAL;
 	}
 
 	// write to chip
@@ -234,7 +239,7 @@ int rf69_set_frequency(struct spi_device *spi, u32 frequency)
 	f_max = div_u64(f_step * 8388608, factor);
 	if (frequency > f_max) {
 		dev_dbg(&spi->dev, "setFrequency: illegal input param");
-		INVALID_PARAM;
+		return -EINVAL;
 	}
 
 	// calculate reg settings
@@ -265,7 +270,9 @@ int rf69_set_amplifier_0(struct spi_device *spi, enum optionOnOff optionOnOff)
 	switch(optionOnOff) {
 	case optionOn:	return WRITE_REG(REG_PALEVEL, (READ_REG(REG_PALEVEL) |  MASK_PALEVEL_PA0) );
 	case optionOff:	return WRITE_REG(REG_PALEVEL, (READ_REG(REG_PALEVEL) & ~MASK_PALEVEL_PA0) );
-	default:	INVALID_PARAM;
+	default:
+		dev_dbg(&spi->dev, "set: illegal input param");
+		return -EINVAL;
 	}
 }
 
@@ -278,7 +285,9 @@ int rf69_set_amplifier_1(struct spi_device *spi, enum optionOnOff optionOnOff)
 	switch(optionOnOff) {
 	case optionOn:	return WRITE_REG(REG_PALEVEL, (READ_REG(REG_PALEVEL) |  MASK_PALEVEL_PA1) );
 	case optionOff: return WRITE_REG(REG_PALEVEL, (READ_REG(REG_PALEVEL) & ~MASK_PALEVEL_PA1) );
-	default:	INVALID_PARAM;
+	default:
+		dev_dbg(&spi->dev, "set: illegal input param");
+		return -EINVAL;
 	}
 }
 
@@ -291,7 +300,9 @@ int rf69_set_amplifier_2(struct spi_device *spi, enum optionOnOff optionOnOff)
 	switch(optionOnOff) {
 	case optionOn:	return WRITE_REG(REG_PALEVEL, (READ_REG(REG_PALEVEL) |  MASK_PALEVEL_PA2) );
 	case optionOff:	return WRITE_REG(REG_PALEVEL, (READ_REG(REG_PALEVEL) & ~MASK_PALEVEL_PA2) );
-	default:	INVALID_PARAM;
+	default:
+		dev_dbg(&spi->dev, "set: illegal input param");
+		return -EINVAL;
 	}
 }
 
@@ -304,8 +315,10 @@ int rf69_set_output_power_level(struct spi_device *spi, u8 powerLevel)
 	powerLevel +=18; // TODO Abhngigkeit von PA0,1,2 setting
 
 	// check input value
-	if (powerLevel > 0x1f)
-		INVALID_PARAM;
+	if (powerLevel > 0x1f) {
+		dev_dbg(&spi->dev, "set: illegal input param");
+		return -EINVAL;
+	}
 
 	// write value
 	return WRITE_REG(REG_PALEVEL, (READ_REG(REG_PALEVEL) & ~MASK_PALEVEL_OUTPUT_POWER) | powerLevel);
@@ -334,7 +347,9 @@ int rf69_set_pa_ramp(struct spi_device *spi, enum paRamp paRamp)
 	case ramp15:	return WRITE_REG(REG_PARAMP, PARAMP_15);
 	case ramp12:	return WRITE_REG(REG_PARAMP, PARAMP_12);
 	case ramp10:	return WRITE_REG(REG_PARAMP, PARAMP_10);
-	default:	INVALID_PARAM;
+	default:
+		dev_dbg(&spi->dev, "set: illegal input param");
+		return -EINVAL;
 	}
 }
 
@@ -347,7 +362,9 @@ int rf69_set_antenna_impedance(struct spi_device *spi, enum antennaImpedance ant
 	switch(antennaImpedance) {
 	case fiftyOhm:	    return WRITE_REG(REG_LNA, (READ_REG(REG_LNA) & ~MASK_LNA_ZIN) );
 	case twohundretOhm: return WRITE_REG(REG_LNA, (READ_REG(REG_LNA) |  MASK_LNA_ZIN) );
-	default:	    INVALID_PARAM;
+	default:
+		dev_dbg(&spi->dev, "set: illegal input param");
+		return -EINVAL;
 	}
 }
 
@@ -365,7 +382,9 @@ int rf69_set_lna_gain(struct spi_device *spi, enum lnaGain lnaGain)
 	case maxMinus24: return WRITE_REG(REG_LNA, ( (READ_REG(REG_LNA) & ~MASK_LNA_GAIN) & LNA_GAIN_MAX_MINUS_24) );
 	case maxMinus36: return WRITE_REG(REG_LNA, ( (READ_REG(REG_LNA) & ~MASK_LNA_GAIN) & LNA_GAIN_MAX_MINUS_36) );
 	case maxMinus48: return WRITE_REG(REG_LNA, ( (READ_REG(REG_LNA) & ~MASK_LNA_GAIN) & LNA_GAIN_MAX_MINUS_48) );
-	default:	 INVALID_PARAM;
+	default:
+		dev_dbg(&spi->dev, "set: illegal input param");
+		return -EINVAL;
 	}
 }
 
@@ -402,7 +421,9 @@ int rf69_set_dc_cut_off_frequency_intern(struct spi_device *spi ,u8 reg, enum dc
 	case dcc0_5Percent:	return WRITE_REG(reg, ( (READ_REG(reg) & ~MASK_BW_DCC_FREQ) | BW_DCC_0_5_PERCENT) );
 	case dcc0_25Percent:	return WRITE_REG(reg, ( (READ_REG(reg) & ~MASK_BW_DCC_FREQ) | BW_DCC_0_25_PERCENT) );
 	case dcc0_125Percent:	return WRITE_REG(reg, ( (READ_REG(reg) & ~MASK_BW_DCC_FREQ) | BW_DCC_0_125_PERCENT) );
-	default:		INVALID_PARAM;
+	default:
+		dev_dbg(&spi->dev, "set: illegal input param");
+		return -EINVAL;
 	}
 }
 
@@ -430,10 +451,17 @@ static int rf69_set_bandwidth_intern(struct spi_device *spi, u8 reg,
 	u8 newValue;
 
 	// check value for mantisse and exponent
-	if (exponent > 7)   INVALID_PARAM;
-	if ( (mantisse!=mantisse16) &&
-	     (mantisse!=mantisse20) &&
-             (mantisse!=mantisse24) ) INVALID_PARAM;
+	if (exponent > 7) {
+		dev_dbg(&spi->dev, "set: illegal input param");
+		return -EINVAL;
+	}
+
+	if ((mantisse != mantisse16) &&
+	    (mantisse != mantisse20) &&
+	    (mantisse != mantisse24)) {
+		dev_dbg(&spi->dev, "set: illegal input param");
+		return -EINVAL;
+	}
 
 	// read old value
 	newValue = READ_REG(reg);
@@ -483,7 +511,9 @@ int rf69_set_ook_threshold_type(struct spi_device *spi, enum thresholdType thres
 	case fixed:	return WRITE_REG(REG_OOKPEAK, ( (READ_REG(REG_OOKPEAK) & ~MASK_OOKPEAK_THRESTYPE) | OOKPEAK_THRESHTYPE_FIXED) );
 	case peak:	return WRITE_REG(REG_OOKPEAK, ( (READ_REG(REG_OOKPEAK) & ~MASK_OOKPEAK_THRESTYPE) | OOKPEAK_THRESHTYPE_PEAK) );
 	case average:	return WRITE_REG(REG_OOKPEAK, ( (READ_REG(REG_OOKPEAK) & ~MASK_OOKPEAK_THRESTYPE) | OOKPEAK_THRESHTYPE_AVERAGE) );
-	default:	INVALID_PARAM;
+	default:
+		dev_dbg(&spi->dev, "set: illegal input param");
+		return -EINVAL;
 	}
 }
 
@@ -502,7 +532,9 @@ int rf69_set_ook_threshold_step(struct spi_device *spi, enum thresholdStep thres
 	case step_4_0db: return WRITE_REG(REG_OOKPEAK, ( (READ_REG(REG_OOKPEAK) & ~MASK_OOKPEAK_THRESSTEP) | OOKPEAK_THRESHSTEP_4_0_DB) );
 	case step_5_0db: return WRITE_REG(REG_OOKPEAK, ( (READ_REG(REG_OOKPEAK) & ~MASK_OOKPEAK_THRESSTEP) | OOKPEAK_THRESHSTEP_5_0_DB) );
 	case step_6_0db: return WRITE_REG(REG_OOKPEAK, ( (READ_REG(REG_OOKPEAK) & ~MASK_OOKPEAK_THRESSTEP) | OOKPEAK_THRESHSTEP_6_0_DB) );
-	default:	 INVALID_PARAM;
+	default:
+		dev_dbg(&spi->dev, "set: illegal input param");
+		return -EINVAL;
 	}
 }
 
@@ -521,7 +553,9 @@ int rf69_set_ook_threshold_dec(struct spi_device *spi, enum thresholdDecrement t
 	case dec_4times:   return WRITE_REG(REG_OOKPEAK, ( (READ_REG(REG_OOKPEAK) & ~MASK_OOKPEAK_THRESDEC) | OOKPEAK_THRESHDEC_4_TIMES) );
 	case dec_8times:   return WRITE_REG(REG_OOKPEAK, ( (READ_REG(REG_OOKPEAK) & ~MASK_OOKPEAK_THRESDEC) | OOKPEAK_THRESHDEC_8_TIMES) );
 	case dec_16times:  return WRITE_REG(REG_OOKPEAK, ( (READ_REG(REG_OOKPEAK) & ~MASK_OOKPEAK_THRESDEC) | OOKPEAK_THRESHDEC_16_TIMES) );
-	default:	   INVALID_PARAM;
+	default:
+		dev_dbg(&spi->dev, "set: illegal input param");
+		return -EINVAL;
 	}
 }
 
@@ -537,7 +571,10 @@ int rf69_set_dio_mapping(struct spi_device *spi, u8 DIONumber, u8 value)
 	#endif
 
 	// check DIO number
-	if (DIONumber > 5) INVALID_PARAM;
+	if (DIONumber > 5) {
+		dev_dbg(&spi->dev, "set: illegal input param");
+		return -EINVAL;
+	}
 
 	switch (DIONumber) {
 	case 0: mask=MASK_DIO0; shift=SHIFT_DIO0; regaddr=REG_DIOMAPPING1; break;
@@ -596,7 +633,9 @@ int rf69_reset_flag(struct spi_device *spi, enum flag flag)
 	case rssiExceededThreshold: return WRITE_REG(REG_IRQFLAGS1, MASK_IRQFLAGS1_RSSI);
 	case syncAddressMatch:	    return WRITE_REG(REG_IRQFLAGS1, MASK_IRQFLAGS1_SYNC_ADDRESS_MATCH);
 	case fifoOverrun:	    return WRITE_REG(REG_IRQFLAGS2, MASK_IRQFLAGS2_FIFO_OVERRUN);
-	default:		    INVALID_PARAM;
+	default:
+		dev_dbg(&spi->dev, "set: illegal input param");
+		return -EINVAL;
 	}
 }
 
@@ -665,7 +704,9 @@ int rf69_set_sync_enable(struct spi_device *spi, enum optionOnOff optionOnOff)
 	switch(optionOnOff) {
 	case optionOn:	return WRITE_REG(REG_SYNC_CONFIG, (READ_REG(REG_SYNC_CONFIG) |  MASK_SYNC_CONFIG_SYNC_ON) );
 	case optionOff:	return WRITE_REG(REG_SYNC_CONFIG, (READ_REG(REG_SYNC_CONFIG) & ~MASK_SYNC_CONFIG_SYNC_ON) );
-	default:	INVALID_PARAM;
+	default:
+		dev_dbg(&spi->dev, "set: illegal input param");
+		return -EINVAL;
 	}
 }
 
@@ -678,7 +719,9 @@ int rf69_set_fifo_fill_condition(struct spi_device *spi, enum fifoFillCondition
 	switch(fifoFillCondition) {
 	case always:		 return WRITE_REG(REG_SYNC_CONFIG, (READ_REG(REG_SYNC_CONFIG) |  MASK_SYNC_CONFIG_FIFO_FILL_CONDITION) );
 	case afterSyncInterrupt: return WRITE_REG(REG_SYNC_CONFIG, (READ_REG(REG_SYNC_CONFIG) & ~MASK_SYNC_CONFIG_FIFO_FILL_CONDITION) );
-	default:		 INVALID_PARAM;
+	default:
+		dev_dbg(&spi->dev, "set: illegal input param");
+		return -EINVAL;
 	}
 }
 
@@ -689,8 +732,10 @@ int rf69_set_sync_size(struct spi_device *spi, u8 syncSize)
 	#endif
 
 	// check input value
-	if (syncSize > 0x07)
-		INVALID_PARAM;
+	if (syncSize > 0x07) {
+		dev_dbg(&spi->dev, "set: illegal input param");
+		return -EINVAL;
+	}
 
 	// write value
 	return WRITE_REG(REG_SYNC_CONFIG, (READ_REG(REG_SYNC_CONFIG) & ~MASK_SYNC_CONFIG_SYNC_SIZE) | (syncSize << 3) );
@@ -703,8 +748,10 @@ int rf69_set_sync_tolerance(struct spi_device *spi, u8 syncTolerance)
 	#endif
 
 	// check input value
-	if (syncTolerance > 0x07)
-		INVALID_PARAM;
+	if (syncTolerance > 0x07) {
+		dev_dbg(&spi->dev, "set: illegal input param");
+		return -EINVAL;
+	}
 
 	// write value
 	return WRITE_REG(REG_SYNC_CONFIG, (READ_REG(REG_SYNC_CONFIG) & ~MASK_SYNC_CONFIG_SYNC_SIZE) | syncTolerance);
@@ -739,7 +786,9 @@ int rf69_set_packet_format(struct spi_device *spi, enum packetFormat packetForma
 	switch(packetFormat) {
 	case packetLengthVar: return WRITE_REG(REG_PACKETCONFIG1, (READ_REG(REG_PACKETCONFIG1) |  MASK_PACKETCONFIG1_PAKET_FORMAT_VARIABLE) );
 	case packetLengthFix: return WRITE_REG(REG_PACKETCONFIG1, (READ_REG(REG_PACKETCONFIG1) & ~MASK_PACKETCONFIG1_PAKET_FORMAT_VARIABLE) );
-	default:	      INVALID_PARAM;
+	default:
+		dev_dbg(&spi->dev, "set: illegal input param");
+		return -EINVAL;
 	}
 }
 
@@ -752,7 +801,9 @@ int rf69_set_crc_enable(struct spi_device *spi, enum optionOnOff optionOnOff)
 	switch(optionOnOff) {
 	case optionOn:	return WRITE_REG(REG_PACKETCONFIG1, (READ_REG(REG_PACKETCONFIG1) |  MASK_PACKETCONFIG1_CRC_ON) );
 	case optionOff:	return WRITE_REG(REG_PACKETCONFIG1, (READ_REG(REG_PACKETCONFIG1) & ~MASK_PACKETCONFIG1_CRC_ON) );
-	default:	INVALID_PARAM;
+	default:
+		dev_dbg(&spi->dev, "set: illegal input param");
+		return -EINVAL;
 	}
 }
 
@@ -766,7 +817,9 @@ int rf69_set_adressFiltering(struct spi_device *spi, enum addressFiltering addre
 	case filteringOff:	     return WRITE_REG(REG_PACKETCONFIG1, ( (READ_REG(REG_PACKETCONFIG1) & ~MASK_PACKETCONFIG1_ADDRESSFILTERING) | PACKETCONFIG1_ADDRESSFILTERING_OFF) );
 	case nodeAddress:	     return WRITE_REG(REG_PACKETCONFIG1, ( (READ_REG(REG_PACKETCONFIG1) & ~MASK_PACKETCONFIG1_ADDRESSFILTERING) | PACKETCONFIG1_ADDRESSFILTERING_NODE) );
 	case nodeOrBroadcastAddress: return WRITE_REG(REG_PACKETCONFIG1, ( (READ_REG(REG_PACKETCONFIG1) & ~MASK_PACKETCONFIG1_ADDRESSFILTERING) | PACKETCONFIG1_ADDRESSFILTERING_NODEBROADCAST) );
-	default:		     INVALID_PARAM;
+	default:
+		dev_dbg(&spi->dev, "set: illegal input param");
+		return -EINVAL;
 	}
 }
 
@@ -815,7 +868,9 @@ int rf69_set_tx_start_condition(struct spi_device *spi, enum txStartCondition tx
 	switch(txStartCondition) {
 	case fifoLevel:	   return WRITE_REG(REG_FIFO_THRESH, (READ_REG(REG_FIFO_THRESH) & ~MASK_FIFO_THRESH_TXSTART) );
 	case fifoNotEmpty: return WRITE_REG(REG_FIFO_THRESH, (READ_REG(REG_FIFO_THRESH) |  MASK_FIFO_THRESH_TXSTART) );
-	default:	   INVALID_PARAM;
+	default:
+		dev_dbg(&spi->dev, "set: illegal input param");
+		return -EINVAL;
 	}
 }
 
@@ -828,8 +883,10 @@ int rf69_set_fifo_threshold(struct spi_device *spi, u8 threshold)
 	#endif
 
 	// check input value
-	if (threshold & 0x80)
-		INVALID_PARAM;
+	if (threshold & 0x80) {
+		dev_dbg(&spi->dev, "set: illegal input param");
+		return -EINVAL;
+	}
 
 	// write value
 	retval = WRITE_REG(REG_FIFO_THRESH, (READ_REG(REG_FIFO_THRESH) & ~MASK_FIFO_THRESH_VALUE) | threshold);
@@ -850,7 +907,9 @@ int rf69_set_dagc(struct spi_device *spi, enum dagc dagc)
 	case normalMode:		 return WRITE_REG(REG_TESTDAGC, DAGC_NORMAL);
 	case improve:			 return WRITE_REG(REG_TESTDAGC, DAGC_IMPROVED_LOWBETA0);
 	case improve4LowModulationIndex: return WRITE_REG(REG_TESTDAGC, DAGC_IMPROVED_LOWBETA1);
-	default:			 INVALID_PARAM;
+	default:
+		dev_dbg(&spi->dev, "set: illegal input param");
+		return -EINVAL;
 	}
 }
 

commit f2aee92d1865d8ff49fa7d715be638c849c650cf
Author: Quentin Swain <dudebrobro179@gmail.com>
Date:   Mon Aug 14 21:48:17 2017 -0400

    staging: pi433: replace logical not with bitwise
    
    sparse reports the following warning  "warning: dubious: x & !y".
    Replaced te logical not with bitwise to resolve the warning
    
    Signed-off-by: Quentin Swain <dudebrobro179@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/pi433/rf69.c b/drivers/staging/pi433/rf69.c
index 85cd70d403ba..3265786e8046 100644
--- a/drivers/staging/pi433/rf69.c
+++ b/drivers/staging/pi433/rf69.c
@@ -197,7 +197,7 @@ int rf69_set_deviation(struct spi_device *spi, u32 deviation)
 	lsb = (f_reg&0xff);
 
 	// check msb
-	if (msb & !FDEVMASB_MASK) {
+	if (msb & ~FDEVMASB_MASK) {
 		dev_dbg(&spi->dev, "set_deviation: err in calc of msb");
 		INVALID_PARAM;
 	}

commit b4bac77f2a2e3faada7313e8f6b8b4fcca7e07b8
Author: Marcin Ciupak <marcin.s.ciupak@gmail.com>
Date:   Thu Aug 10 17:44:13 2017 +0200

    staging: pi433: rf69.c style fix - spaces open brace
    
    This patch fixes the following checkpatch.pl error:
    
    ERROR: space required before the open brace '{'
    
    in rf69.c file as requested by TODO file.
    
    Signed-off-by: Marcin Ciupak <marcin.s.ciupak@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/pi433/rf69.c b/drivers/staging/pi433/rf69.c
index 590822a5a52f..85cd70d403ba 100644
--- a/drivers/staging/pi433/rf69.c
+++ b/drivers/staging/pi433/rf69.c
@@ -49,7 +49,7 @@ int rf69_set_mode(struct spi_device *spi, enum mode mode)
 		dev_dbg(&spi->dev, "set: mode");
 	#endif
 
-	switch (mode){
+	switch (mode) {
 	case transmit:	  return WRITE_REG(REG_OPMODE, (READ_REG(REG_OPMODE) & ~MASK_OPMODE_MODE) | OPMODE_MODE_TRANSMIT);
 	case receive:	  return WRITE_REG(REG_OPMODE, (READ_REG(REG_OPMODE) & ~MASK_OPMODE_MODE) | OPMODE_MODE_RECEIVE);
 	case synthesizer: return WRITE_REG(REG_OPMODE, (READ_REG(REG_OPMODE) & ~MASK_OPMODE_MODE) | OPMODE_MODE_SYNTHESIZER);

commit 46659ed7f68526783044e994ef03719813cedfa6
Author: Marcin Ciupak <marcin.s.ciupak@gmail.com>
Date:   Thu Aug 10 17:43:50 2017 +0200

    staging: pi433: rf69.c style fix - else close brace
    
    This patch fixes the following checkpatch.pl error:
    
    ERROR: else should follow close brace '}'
    
    in rf69.c file as requested by TODO file.
    
    Signed-off-by: Marcin Ciupak <marcin.s.ciupak@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/pi433/rf69.c b/drivers/staging/pi433/rf69.c
index 89a80557cbe6..590822a5a52f 100644
--- a/drivers/staging/pi433/rf69.c
+++ b/drivers/staging/pi433/rf69.c
@@ -122,8 +122,7 @@ int rf69_set_modulation_shaping(struct spi_device *spi, enum modShaping modShapi
 		case shaping0_3: return WRITE_REG(REG_DATAMODUL, (READ_REG(REG_DATAMODUL) & ~MASK_DATAMODUL_MODULATION_SHAPE) | DATAMODUL_MODULATION_SHAPE_0_5);
 		default:	 INVALID_PARAM;
 		}
-	}
-	else {
+	} else {
 		switch (modShaping) {
 		case shapingOff: return WRITE_REG(REG_DATAMODUL, (READ_REG(REG_DATAMODUL) & ~MASK_DATAMODUL_MODULATION_SHAPE) | DATAMODUL_MODULATION_SHAPE_NONE);
 		case shapingBR:	 return WRITE_REG(REG_DATAMODUL, (READ_REG(REG_DATAMODUL) & ~MASK_DATAMODUL_MODULATION_SHAPE) | DATAMODUL_MODULATION_SHAPE_BR);

commit 9391cb316076a169916815ee4f90d1264896ccb6
Author: Marcin Ciupak <marcin.s.ciupak@gmail.com>
Date:   Thu Aug 10 17:43:32 2017 +0200

    staging: pi433: rf69.c style fix - that open brace
    
    This patch fixes the following checkpatch.pl error:
    
    ERROR: that open brace { should be on the previous line
    
    in rf69.c file as requested by TODO file.
    
    Note:
    ERROR: else should follow close brace '}'
    remains valid here and is going to be fixed by the next patch in set.
    
    Additionally some style warnings remain valid here and could be fixed by
    another patch.
    
    Signed-off-by: Marcin Ciupak <marcin.s.ciupak@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/pi433/rf69.c b/drivers/staging/pi433/rf69.c
index 9f4e7173c688..89a80557cbe6 100644
--- a/drivers/staging/pi433/rf69.c
+++ b/drivers/staging/pi433/rf69.c
@@ -101,8 +101,7 @@ enum modulation rf69_get_modulation(struct spi_device *spi)
 
 	currentValue = READ_REG(REG_DATAMODUL);
 
-	switch (currentValue & MASK_DATAMODUL_MODULATION_TYPE >> 3)  // TODO improvement: change 3 to define
-	{
+	switch (currentValue & MASK_DATAMODUL_MODULATION_TYPE >> 3) { // TODO improvement: change 3 to define
 	case DATAMODUL_MODULATION_TYPE_OOK: return OOK;
 	case DATAMODUL_MODULATION_TYPE_FSK: return FSK;
 	default:			    return undefined;
@@ -115,8 +114,7 @@ int rf69_set_modulation_shaping(struct spi_device *spi, enum modShaping modShapi
 		dev_dbg(&spi->dev, "set: mod shaping");
 	#endif
 
-	if (rf69_get_modulation(spi) == FSK)
-	{
+	if (rf69_get_modulation(spi) == FSK) {
 		switch (modShaping) {
 		case shapingOff: return WRITE_REG(REG_DATAMODUL, (READ_REG(REG_DATAMODUL) & ~MASK_DATAMODUL_MODULATION_SHAPE) | DATAMODUL_MODULATION_SHAPE_NONE);
 		case shaping1_0: return WRITE_REG(REG_DATAMODUL, (READ_REG(REG_DATAMODUL) & ~MASK_DATAMODUL_MODULATION_SHAPE) | DATAMODUL_MODULATION_SHAPE_1_0);
@@ -125,8 +123,7 @@ int rf69_set_modulation_shaping(struct spi_device *spi, enum modShaping modShapi
 		default:	 INVALID_PARAM;
 		}
 	}
-	else
-	{
+	else {
 		switch (modShaping) {
 		case shapingOff: return WRITE_REG(REG_DATAMODUL, (READ_REG(REG_DATAMODUL) & ~MASK_DATAMODUL_MODULATION_SHAPE) | DATAMODUL_MODULATION_SHAPE_NONE);
 		case shapingBR:	 return WRITE_REG(REG_DATAMODUL, (READ_REG(REG_DATAMODUL) & ~MASK_DATAMODUL_MODULATION_SHAPE) | DATAMODUL_MODULATION_SHAPE_BR);
@@ -150,8 +147,7 @@ int rf69_set_bit_rate(struct spi_device *spi, u16 bitRate)
 
 	// check input value
 	bitRate_min = F_OSC / 8388608; // 8388608 = 2^23;
-	if (bitRate < bitRate_min)
-	{
+	if (bitRate < bitRate_min) {
 		dev_dbg(&spi->dev, "setBitRate: illegal input param");
 		INVALID_PARAM;
 	}
@@ -185,8 +181,7 @@ int rf69_set_deviation(struct spi_device *spi, u32 deviation)
 		dev_dbg(&spi->dev, "set: deviation");
 	#endif
 
-	if (deviation < 600 || deviation > 500000) //TODO: Abhngigkeit von Bitrate beachten!!
-	{
+	if (deviation < 600 || deviation > 500000) { //TODO: Abhngigkeit von Bitrate beachten!!
 		dev_dbg(&spi->dev, "set_deviation: illegal input param");
 		INVALID_PARAM;
 	}
@@ -203,8 +198,7 @@ int rf69_set_deviation(struct spi_device *spi, u32 deviation)
 	lsb = (f_reg&0xff);
 
 	// check msb
-	if (msb & !FDEVMASB_MASK)
-	{
+	if (msb & !FDEVMASB_MASK) {
 		dev_dbg(&spi->dev, "set_deviation: err in calc of msb");
 		INVALID_PARAM;
 	}
@@ -239,8 +233,7 @@ int rf69_set_frequency(struct spi_device *spi, u32 frequency)
 
 	// check input value
 	f_max = div_u64(f_step * 8388608, factor);
-	if (frequency > f_max)
-	{
+	if (frequency > f_max) {
 		dev_dbg(&spi->dev, "setFrequency: illegal input param");
 		INVALID_PARAM;
 	}
@@ -387,8 +380,7 @@ enum lnaGain rf69_get_lna_gain(struct spi_device *spi)
 
 	currentValue = READ_REG(REG_LNA);
 
-	switch (currentValue & MASK_LNA_CURRENT_GAIN >> 3)  // improvement: change 3 to define
-	{
+	switch (currentValue & MASK_LNA_CURRENT_GAIN >> 3) { // improvement: change 3 to define
 	case LNA_GAIN_AUTO:	    return automatic;
 	case LNA_GAIN_MAX:	    return max;
 	case LNA_GAIN_MAX_MINUS_6:  return maxMinus6;
@@ -488,8 +480,7 @@ int rf69_set_ook_threshold_type(struct spi_device *spi, enum thresholdType thres
 		dev_dbg(&spi->dev, "set: threshold type");
 	#endif
 
-	switch (thresholdType)
-	{
+	switch (thresholdType) {
 	case fixed:	return WRITE_REG(REG_OOKPEAK, ( (READ_REG(REG_OOKPEAK) & ~MASK_OOKPEAK_THRESTYPE) | OOKPEAK_THRESHTYPE_FIXED) );
 	case peak:	return WRITE_REG(REG_OOKPEAK, ( (READ_REG(REG_OOKPEAK) & ~MASK_OOKPEAK_THRESTYPE) | OOKPEAK_THRESHTYPE_PEAK) );
 	case average:	return WRITE_REG(REG_OOKPEAK, ( (READ_REG(REG_OOKPEAK) & ~MASK_OOKPEAK_THRESTYPE) | OOKPEAK_THRESHTYPE_AVERAGE) );
@@ -875,8 +866,7 @@ int rf69_read_fifo (struct spi_device *spi, u8 *buffer, unsigned int size)
 	u8 local_buffer[FIFO_SIZE + 1];
 	int retval;
 
-	if (size > FIFO_SIZE)
-	{
+	if (size > FIFO_SIZE) {
 		#ifdef DEBUG
 			dev_dbg(&spi->dev, "read fifo: passed in buffer bigger then internal buffer \n");
 		#endif
@@ -910,8 +900,7 @@ int rf69_write_fifo(struct spi_device *spi, u8 *buffer, unsigned int size)
 	char spi_address = REG_FIFO | WRITE_BIT;
 	u8 local_buffer[FIFO_SIZE + 1];
 
-	if (size > FIFO_SIZE)
-	{
+	if (size > FIFO_SIZE) {
 		#ifdef DEBUG
 			dev_dbg(&spi->dev, "read fifo: passed in buffer bigger then internal buffer \n");
 		#endif

commit 35acd78f05560711a0d1798fd3b6b33339a6ccf6
Author: Marcin Ciupak <marcin.s.ciupak@gmail.com>
Date:   Tue Aug 8 15:54:13 2017 +0200

    staging: pi433: style fix - space after asterisk
    
    This patch is intended to fix coding style issues in order to comply
    with kernel coding style guide as requested by TODO file.
    
    It fixes the following checkpatch.pl error:
    
    ERROR: "foo * bar" should be "foo *bar"
    
    Note:
    "WARNING: line over 80 characters" remains valid here and could be fixed
    by another patch.
    
    Signed-off-by: Marcin Ciupak <marcin.s.ciupak@gmail.com>
    Reviewed-by: Marcus Wolf <linux@wolf-entwicklungen.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/pi433/rf69.c b/drivers/staging/pi433/rf69.c
index f83523e3395d..9f4e7173c688 100644
--- a/drivers/staging/pi433/rf69.c
+++ b/drivers/staging/pi433/rf69.c
@@ -740,7 +740,7 @@ int rf69_set_sync_values(struct spi_device *spi, u8 syncValues[8])
 	return retval;
 }
 
-int rf69_set_packet_format(struct spi_device * spi, enum packetFormat packetFormat)
+int rf69_set_packet_format(struct spi_device *spi, enum packetFormat packetFormat)
 {
 	#ifdef DEBUG
 		dev_dbg(&spi->dev, "set: packet format");

commit 99859541a92de570eb624c2488754d2406375c74
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Fri Jul 28 15:23:12 2017 +0200

    staging: pi433: use div_u64 for 64-bit division
    
    I ran into this link error on an ARM OABI build:
    
    drivers/staging/pi433/rf69.o: In function `rf69_set_frequency':
    rf69.c:(.text+0xc9c): undefined reference to `__udivdi3'
    
    No idea why I didn't see it with the default EABI configurations,
    but the right solution here seems to be to use div_u64()
    to get the external division implementation.
    
    Fixes: 874bcba65f9a ("staging: pi433: New driver")
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/pi433/rf69.c b/drivers/staging/pi433/rf69.c
index 1b094c38f401..f83523e3395d 100644
--- a/drivers/staging/pi433/rf69.c
+++ b/drivers/staging/pi433/rf69.c
@@ -238,7 +238,7 @@ int rf69_set_frequency(struct spi_device *spi, u32 frequency)
 	do_div(f_step, 524288); //  524288 = 2^19
 
 	// check input value
-	f_max = f_step * 8388608 / factor;
+	f_max = div_u64(f_step * 8388608, factor);
 	if (frequency > f_max)
 	{
 		dev_dbg(&spi->dev, "setFrequency: illegal input param");

commit 056eeda2f9e637a7389e5fb4f330e40d3b301389
Author: Derek Robson <robsonde@gmail.com>
Date:   Sat Jul 22 15:50:50 2017 +1200

    staging: pi433: Style fix - align block comments
    
    Fixed the alignment of block comments
    Found using checkpatch
    
    Signed-off-by: Derek Robson <robsonde@gmail.com>
    Reviewed-by: Marcus Wolf <linux@wolf-entwicklungen.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/pi433/rf69.c b/drivers/staging/pi433/rf69.c
index 04af906476e3..1b094c38f401 100644
--- a/drivers/staging/pi433/rf69.c
+++ b/drivers/staging/pi433/rf69.c
@@ -940,8 +940,9 @@ u8 rf69_read_reg(struct spi_device *spi, u8 addr)
 	#ifdef DEBUG_VALUES
 		if (retval < 0)
 			/* should never happen, since we already checked,
-			   that module is connected. Therefore no error
-			   handling, just an optional error message... */
+			 * that module is connected. Therefore no error
+			 * handling, just an optional error message...
+			 */
 			dev_dbg(&spi->dev, "read 0x%x FAILED\n",
 				addr);
 		else
@@ -966,8 +967,9 @@ int rf69_write_reg(struct spi_device *spi, u8 addr, u8 value)
 	#ifdef DEBUG_VALUES
 		if (retval < 0)
 			/* should never happen, since we already checked,
-			   that module is connected. Therefore no error
-			   handling, just an optional error message... */
+			 * that module is connected. Therefore no error
+			 * handling, just an optional error message...
+			 */
 			dev_dbg(&spi->dev, "write 0x%x to 0x%x FAILED\n",
 				value,
 				addr);

commit 775f6ab013d3166600f49df4916fdbfdbbfa15fe
Author: Colin Ian King <colin.king@canonical.com>
Date:   Tue Jul 18 14:03:59 2017 +0100

    staging: pi433: Make functions rf69_set_bandwidth_intern static
    
    The function rf69_set_bandwidth_intern is local to the source
    and do not need to be in global scope, so make it static. Also
    break overly wide line.
    
    Cleans up sparse warning:
    symbol 'update_share_count' was not declared. Should it be static?
    
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Reviewed-by: Marcus Wolf <linux@wolf-entwicklungen.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/pi433/rf69.c b/drivers/staging/pi433/rf69.c
index e391ce777bc7..04af906476e3 100644
--- a/drivers/staging/pi433/rf69.c
+++ b/drivers/staging/pi433/rf69.c
@@ -433,7 +433,8 @@ int rf69_set_dc_cut_off_frequency_during_afc(struct spi_device *spi, enum dccPer
 	return rf69_set_dc_cut_off_frequency_intern(spi, REG_AFCBW, dccPercent);
 }
 
-int rf69_set_bandwidth_intern(struct spi_device *spi, u8 reg, enum mantisse mantisse, u8 exponent)
+static int rf69_set_bandwidth_intern(struct spi_device *spi, u8 reg,
+				     enum mantisse mantisse, u8 exponent)
 {
 	u8 newValue;
 

commit 874bcba65f9a3a2a304b5f520529c046887c3cdc
Author: Marcus Wolf <linux@Wolf-Entwicklungen.de>
Date:   Sun Jul 16 11:52:06 2017 +0100

    staging: pi433: New driver
    
    Added a driver for the pi433 radio module
    (see https://www.pi433.de/en.html for details).
    
    Signed-off-by: Marcus Wolf <linux@Wolf-Entwicklungen.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/pi433/rf69.c b/drivers/staging/pi433/rf69.c
new file mode 100644
index 000000000000..e391ce777bc7
--- /dev/null
+++ b/drivers/staging/pi433/rf69.c
@@ -0,0 +1,982 @@
+/*
+ * abstraction of the spi interface of HopeRf rf69 radio module
+ *
+ * Copyright (C) 2016 Wolf-Entwicklungen
+ *	Marcus Wolf <linux@wolf-entwicklungen.de>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+/* enable prosa debug info */
+#undef DEBUG
+/* enable print of values on reg access */
+#undef DEBUG_VALUES
+/* enable print of values on fifo access */
+#undef DEBUG_FIFO_ACCESS
+
+#include <linux/types.h>
+#include <linux/spi/spi.h>
+
+#include "rf69.h"
+#include "rf69_registers.h"
+
+#define F_OSC	  32000000 /* in Hz */
+#define FIFO_SIZE 66 	   /* in byte */
+
+/*-------------------------------------------------------------------------*/
+
+#define READ_REG(x)	rf69_read_reg (spi, x)
+#define WRITE_REG(x,y)	rf69_write_reg(spi, x, y)
+#define INVALID_PARAM \
+	{ \
+		dev_dbg(&spi->dev, "set: illegal input param"); \
+		return -EINVAL; \
+	}
+
+/*-------------------------------------------------------------------------*/
+
+int rf69_set_mode(struct spi_device *spi, enum mode mode)
+{
+	#ifdef DEBUG
+		dev_dbg(&spi->dev, "set: mode");
+	#endif
+
+	switch (mode){
+	case transmit:	  return WRITE_REG(REG_OPMODE, (READ_REG(REG_OPMODE) & ~MASK_OPMODE_MODE) | OPMODE_MODE_TRANSMIT);
+	case receive:	  return WRITE_REG(REG_OPMODE, (READ_REG(REG_OPMODE) & ~MASK_OPMODE_MODE) | OPMODE_MODE_RECEIVE);
+	case synthesizer: return WRITE_REG(REG_OPMODE, (READ_REG(REG_OPMODE) & ~MASK_OPMODE_MODE) | OPMODE_MODE_SYNTHESIZER);
+	case standby:	  return WRITE_REG(REG_OPMODE, (READ_REG(REG_OPMODE) & ~MASK_OPMODE_MODE) | OPMODE_MODE_STANDBY);
+	case mode_sleep:  return WRITE_REG(REG_OPMODE, (READ_REG(REG_OPMODE) & ~MASK_OPMODE_MODE) | OPMODE_MODE_SLEEP);
+	default:	  INVALID_PARAM;
+	}
+
+	// we are using packet mode, so this check is not really needed
+	// but waiting for mode ready is necessary when going from sleep because the FIFO may not be immediately available from previous mode
+	//while (_mode == RF69_MODE_SLEEP && (READ_REG(REG_IRQFLAGS1) & RF_IRQFLAGS1_MODEREADY) == 0x00); // Wait for ModeReady
+
+}
+
+int rf69_set_data_mode(struct spi_device *spi, enum dataMode dataMode)
+{
+	#ifdef DEBUG
+		dev_dbg(&spi->dev, "set: data mode");
+	#endif
+
+	switch (dataMode) {
+	case packet:		return WRITE_REG(REG_DATAMODUL, (READ_REG(REG_DATAMODUL) & ~MASK_DATAMODUL_MODE) | DATAMODUL_MODE_PACKET);
+	case continuous:	return WRITE_REG(REG_DATAMODUL, (READ_REG(REG_DATAMODUL) & ~MASK_DATAMODUL_MODE) | DATAMODUL_MODE_CONTINUOUS);
+	case continuousNoSync:  return WRITE_REG(REG_DATAMODUL, (READ_REG(REG_DATAMODUL) & ~MASK_DATAMODUL_MODE) | DATAMODUL_MODE_CONTINUOUS_NOSYNC);
+	default:		INVALID_PARAM;
+	}
+}
+
+int rf69_set_modulation(struct spi_device *spi, enum modulation modulation)
+{
+	#ifdef DEBUG
+		dev_dbg(&spi->dev, "set: modulation");
+	#endif
+
+	switch (modulation) {
+	case OOK:   return WRITE_REG(REG_DATAMODUL, (READ_REG(REG_DATAMODUL) & ~MASK_DATAMODUL_MODULATION_TYPE) | DATAMODUL_MODULATION_TYPE_OOK);
+	case FSK:   return WRITE_REG(REG_DATAMODUL, (READ_REG(REG_DATAMODUL) & ~MASK_DATAMODUL_MODULATION_TYPE) | DATAMODUL_MODULATION_TYPE_FSK);
+	default:    INVALID_PARAM;
+	}
+}
+
+enum modulation rf69_get_modulation(struct spi_device *spi)
+{
+	u8 currentValue;
+
+	#ifdef DEBUG
+		dev_dbg(&spi->dev, "get: mode");
+	#endif
+
+	currentValue = READ_REG(REG_DATAMODUL);
+
+	switch (currentValue & MASK_DATAMODUL_MODULATION_TYPE >> 3)  // TODO improvement: change 3 to define
+	{
+	case DATAMODUL_MODULATION_TYPE_OOK: return OOK;
+	case DATAMODUL_MODULATION_TYPE_FSK: return FSK;
+	default:			    return undefined;
+	}
+}
+
+int rf69_set_modulation_shaping(struct spi_device *spi, enum modShaping modShaping)
+{
+	#ifdef DEBUG
+		dev_dbg(&spi->dev, "set: mod shaping");
+	#endif
+
+	if (rf69_get_modulation(spi) == FSK)
+	{
+		switch (modShaping) {
+		case shapingOff: return WRITE_REG(REG_DATAMODUL, (READ_REG(REG_DATAMODUL) & ~MASK_DATAMODUL_MODULATION_SHAPE) | DATAMODUL_MODULATION_SHAPE_NONE);
+		case shaping1_0: return WRITE_REG(REG_DATAMODUL, (READ_REG(REG_DATAMODUL) & ~MASK_DATAMODUL_MODULATION_SHAPE) | DATAMODUL_MODULATION_SHAPE_1_0);
+		case shaping0_5: return WRITE_REG(REG_DATAMODUL, (READ_REG(REG_DATAMODUL) & ~MASK_DATAMODUL_MODULATION_SHAPE) | DATAMODUL_MODULATION_SHAPE_0_3);
+		case shaping0_3: return WRITE_REG(REG_DATAMODUL, (READ_REG(REG_DATAMODUL) & ~MASK_DATAMODUL_MODULATION_SHAPE) | DATAMODUL_MODULATION_SHAPE_0_5);
+		default:	 INVALID_PARAM;
+		}
+	}
+	else
+	{
+		switch (modShaping) {
+		case shapingOff: return WRITE_REG(REG_DATAMODUL, (READ_REG(REG_DATAMODUL) & ~MASK_DATAMODUL_MODULATION_SHAPE) | DATAMODUL_MODULATION_SHAPE_NONE);
+		case shapingBR:	 return WRITE_REG(REG_DATAMODUL, (READ_REG(REG_DATAMODUL) & ~MASK_DATAMODUL_MODULATION_SHAPE) | DATAMODUL_MODULATION_SHAPE_BR);
+		case shaping2BR: return WRITE_REG(REG_DATAMODUL, (READ_REG(REG_DATAMODUL) & ~MASK_DATAMODUL_MODULATION_SHAPE) | DATAMODUL_MODULATION_SHAPE_2BR);
+		default:	 INVALID_PARAM;
+		}
+	}
+}
+
+int rf69_set_bit_rate(struct spi_device *spi, u16 bitRate)
+{
+	int retval;
+	u32 bitRate_min;
+	u32 bitRate_reg;
+	u8 msb;
+	u8 lsb;
+
+	#ifdef DEBUG
+		dev_dbg(&spi->dev, "set: bit rate");
+	#endif
+
+	// check input value
+	bitRate_min = F_OSC / 8388608; // 8388608 = 2^23;
+	if (bitRate < bitRate_min)
+	{
+		dev_dbg(&spi->dev, "setBitRate: illegal input param");
+		INVALID_PARAM;
+	}
+
+	// calculate reg settings
+	bitRate_reg = (F_OSC / bitRate);
+
+	msb = (bitRate_reg&0xff00)   >>  8;
+	lsb = (bitRate_reg&0xff);
+
+	// transmit to RF 69
+	retval = WRITE_REG(REG_BITRATE_MSB, msb);
+	if (retval)  return retval;
+	retval = WRITE_REG(REG_BITRATE_LSB, lsb);
+	if (retval)  return retval;
+
+	return 0;
+}
+
+int rf69_set_deviation(struct spi_device *spi, u32 deviation)
+{
+	int retval;
+//	u32 f_max; TODO: Abhngigkeit von Bitrate beachten!!
+	u64 f_reg;
+	u64 f_step;
+	u8 msb;
+	u8 lsb;
+	u64 factor = 1000000; // to improve precision of calculation
+
+	#ifdef DEBUG
+		dev_dbg(&spi->dev, "set: deviation");
+	#endif
+
+	if (deviation < 600 || deviation > 500000) //TODO: Abhngigkeit von Bitrate beachten!!
+	{
+		dev_dbg(&spi->dev, "set_deviation: illegal input param");
+		INVALID_PARAM;
+	}
+
+	// calculat f step
+	f_step = F_OSC * factor;
+	do_div(f_step, 524288); //  524288 = 2^19
+
+	// calculate register settings
+	f_reg = deviation * factor;
+	do_div(f_reg  , f_step);
+
+	msb = (f_reg&0xff00)   >>  8;
+	lsb = (f_reg&0xff);
+
+	// check msb
+	if (msb & !FDEVMASB_MASK)
+	{
+		dev_dbg(&spi->dev, "set_deviation: err in calc of msb");
+		INVALID_PARAM;
+	}
+
+	// write to chip
+	retval = WRITE_REG(REG_FDEV_MSB, msb);
+	if (retval)  return retval;
+	retval = WRITE_REG(REG_FDEV_LSB, lsb);
+	if (retval)  return retval;
+
+	return 0;
+}
+
+int rf69_set_frequency(struct spi_device *spi, u32 frequency)
+{
+	int retval;
+	u32 f_max;
+	u64 f_reg;
+	u64 f_step;
+	u8 msb;
+	u8 mid;
+	u8 lsb;
+	u64 factor = 1000000; // to improve precision of calculation
+
+	#ifdef DEBUG
+		dev_dbg(&spi->dev, "set: frequency");
+	#endif
+
+	// calculat f step
+	f_step = F_OSC * factor;
+	do_div(f_step, 524288); //  524288 = 2^19
+
+	// check input value
+	f_max = f_step * 8388608 / factor;
+	if (frequency > f_max)
+	{
+		dev_dbg(&spi->dev, "setFrequency: illegal input param");
+		INVALID_PARAM;
+	}
+
+	// calculate reg settings
+	f_reg = frequency * factor;
+	do_div(f_reg  , f_step);
+
+	msb = (f_reg&0xff0000) >> 16;
+	mid = (f_reg&0xff00)   >>  8;
+	lsb = (f_reg&0xff);
+
+	// write to chip
+	retval = WRITE_REG(REG_FRF_MSB, msb);
+	if (retval)  return retval;
+	retval = WRITE_REG(REG_FRF_MID, mid);
+	if (retval)  return retval;
+	retval = WRITE_REG(REG_FRF_LSB, lsb);
+	if (retval)  return retval;
+
+	return 0;
+}
+
+int rf69_set_amplifier_0(struct spi_device *spi, enum optionOnOff optionOnOff)
+{
+	#ifdef DEBUG
+		dev_dbg(&spi->dev, "set: amp #0");
+	#endif
+
+	switch(optionOnOff) {
+	case optionOn:	return WRITE_REG(REG_PALEVEL, (READ_REG(REG_PALEVEL) |  MASK_PALEVEL_PA0) );
+	case optionOff:	return WRITE_REG(REG_PALEVEL, (READ_REG(REG_PALEVEL) & ~MASK_PALEVEL_PA0) );
+	default:	INVALID_PARAM;
+	}
+}
+
+int rf69_set_amplifier_1(struct spi_device *spi, enum optionOnOff optionOnOff)
+{
+	#ifdef DEBUG
+		dev_dbg(&spi->dev, "set: amp #1");
+	#endif
+
+	switch(optionOnOff) {
+	case optionOn:	return WRITE_REG(REG_PALEVEL, (READ_REG(REG_PALEVEL) |  MASK_PALEVEL_PA1) );
+	case optionOff: return WRITE_REG(REG_PALEVEL, (READ_REG(REG_PALEVEL) & ~MASK_PALEVEL_PA1) );
+	default:	INVALID_PARAM;
+	}
+}
+
+int rf69_set_amplifier_2(struct spi_device *spi, enum optionOnOff optionOnOff)
+{
+	#ifdef DEBUG
+		dev_dbg(&spi->dev, "set: amp #2");
+	#endif
+
+	switch(optionOnOff) {
+	case optionOn:	return WRITE_REG(REG_PALEVEL, (READ_REG(REG_PALEVEL) |  MASK_PALEVEL_PA2) );
+	case optionOff:	return WRITE_REG(REG_PALEVEL, (READ_REG(REG_PALEVEL) & ~MASK_PALEVEL_PA2) );
+	default:	INVALID_PARAM;
+	}
+}
+
+int rf69_set_output_power_level(struct spi_device *spi, u8 powerLevel)
+{
+	#ifdef DEBUG
+		dev_dbg(&spi->dev, "set: power level");
+	#endif
+
+	powerLevel +=18; // TODO Abhngigkeit von PA0,1,2 setting
+
+	// check input value
+	if (powerLevel > 0x1f)
+		INVALID_PARAM;
+
+	// write value
+	return WRITE_REG(REG_PALEVEL, (READ_REG(REG_PALEVEL) & ~MASK_PALEVEL_OUTPUT_POWER) | powerLevel);
+}
+
+int rf69_set_pa_ramp(struct spi_device *spi, enum paRamp paRamp)
+{
+	#ifdef DEBUG
+		dev_dbg(&spi->dev, "set: pa ramp");
+	#endif
+
+	switch(paRamp) {
+	case ramp3400:	return WRITE_REG(REG_PARAMP, PARAMP_3400);
+	case ramp2000:	return WRITE_REG(REG_PARAMP, PARAMP_2000);
+	case ramp1000:	return WRITE_REG(REG_PARAMP, PARAMP_1000);
+	case ramp500:	return WRITE_REG(REG_PARAMP, PARAMP_500);
+	case ramp250:	return WRITE_REG(REG_PARAMP, PARAMP_250);
+	case ramp125:	return WRITE_REG(REG_PARAMP, PARAMP_125);
+	case ramp100:	return WRITE_REG(REG_PARAMP, PARAMP_100);
+	case ramp62:	return WRITE_REG(REG_PARAMP, PARAMP_62);
+	case ramp50:	return WRITE_REG(REG_PARAMP, PARAMP_50);
+	case ramp40:	return WRITE_REG(REG_PARAMP, PARAMP_40);
+	case ramp31:	return WRITE_REG(REG_PARAMP, PARAMP_31);
+	case ramp25:	return WRITE_REG(REG_PARAMP, PARAMP_25);
+	case ramp20:	return WRITE_REG(REG_PARAMP, PARAMP_20);
+	case ramp15:	return WRITE_REG(REG_PARAMP, PARAMP_15);
+	case ramp12:	return WRITE_REG(REG_PARAMP, PARAMP_12);
+	case ramp10:	return WRITE_REG(REG_PARAMP, PARAMP_10);
+	default:	INVALID_PARAM;
+	}
+}
+
+int rf69_set_antenna_impedance(struct spi_device *spi, enum antennaImpedance antennaImpedance)
+{
+	#ifdef DEBUG
+		dev_dbg(&spi->dev, "set: antenna impedance");
+	#endif
+
+	switch(antennaImpedance) {
+	case fiftyOhm:	    return WRITE_REG(REG_LNA, (READ_REG(REG_LNA) & ~MASK_LNA_ZIN) );
+	case twohundretOhm: return WRITE_REG(REG_LNA, (READ_REG(REG_LNA) |  MASK_LNA_ZIN) );
+	default:	    INVALID_PARAM;
+	}
+}
+
+int rf69_set_lna_gain(struct spi_device *spi, enum lnaGain lnaGain)
+{
+	#ifdef DEBUG
+		dev_dbg(&spi->dev, "set: lna gain");
+	#endif
+
+	switch(lnaGain) {
+	case automatic:	 return WRITE_REG(REG_LNA, ( (READ_REG(REG_LNA) & ~MASK_LNA_GAIN) & LNA_GAIN_AUTO) );
+	case max:	 return WRITE_REG(REG_LNA, ( (READ_REG(REG_LNA) & ~MASK_LNA_GAIN) & LNA_GAIN_MAX) );
+	case maxMinus6:  return WRITE_REG(REG_LNA, ( (READ_REG(REG_LNA) & ~MASK_LNA_GAIN) & LNA_GAIN_MAX_MINUS_6) );
+	case maxMinus12: return WRITE_REG(REG_LNA, ( (READ_REG(REG_LNA) & ~MASK_LNA_GAIN) & LNA_GAIN_MAX_MINUS_12) );
+	case maxMinus24: return WRITE_REG(REG_LNA, ( (READ_REG(REG_LNA) & ~MASK_LNA_GAIN) & LNA_GAIN_MAX_MINUS_24) );
+	case maxMinus36: return WRITE_REG(REG_LNA, ( (READ_REG(REG_LNA) & ~MASK_LNA_GAIN) & LNA_GAIN_MAX_MINUS_36) );
+	case maxMinus48: return WRITE_REG(REG_LNA, ( (READ_REG(REG_LNA) & ~MASK_LNA_GAIN) & LNA_GAIN_MAX_MINUS_48) );
+	default:	 INVALID_PARAM;
+	}
+}
+
+enum lnaGain rf69_get_lna_gain(struct spi_device *spi)
+{
+	u8 currentValue;
+
+	#ifdef DEBUG
+		dev_dbg(&spi->dev, "get: lna gain");
+	#endif
+
+	currentValue = READ_REG(REG_LNA);
+
+	switch (currentValue & MASK_LNA_CURRENT_GAIN >> 3)  // improvement: change 3 to define
+	{
+	case LNA_GAIN_AUTO:	    return automatic;
+	case LNA_GAIN_MAX:	    return max;
+	case LNA_GAIN_MAX_MINUS_6:  return maxMinus6;
+	case LNA_GAIN_MAX_MINUS_12: return maxMinus12;
+	case LNA_GAIN_MAX_MINUS_24: return maxMinus24;
+	case LNA_GAIN_MAX_MINUS_36: return maxMinus36;
+	case LNA_GAIN_MAX_MINUS_48: return maxMinus48;
+	default:		    return undefined;
+	}
+}
+
+int rf69_set_dc_cut_off_frequency_intern(struct spi_device *spi ,u8 reg, enum dccPercent dccPercent)
+{
+	switch (dccPercent) {
+	case dcc16Percent:	return WRITE_REG(reg, ( (READ_REG(reg) & ~MASK_BW_DCC_FREQ) | BW_DCC_16_PERCENT) );
+	case dcc8Percent:	return WRITE_REG(reg, ( (READ_REG(reg) & ~MASK_BW_DCC_FREQ) | BW_DCC_8_PERCENT) );
+	case dcc4Percent:	return WRITE_REG(reg, ( (READ_REG(reg) & ~MASK_BW_DCC_FREQ) | BW_DCC_4_PERCENT) );
+	case dcc2Percent:	return WRITE_REG(reg, ( (READ_REG(reg) & ~MASK_BW_DCC_FREQ) | BW_DCC_2_PERCENT) );
+	case dcc1Percent:	return WRITE_REG(reg, ( (READ_REG(reg) & ~MASK_BW_DCC_FREQ) | BW_DCC_1_PERCENT) );
+	case dcc0_5Percent:	return WRITE_REG(reg, ( (READ_REG(reg) & ~MASK_BW_DCC_FREQ) | BW_DCC_0_5_PERCENT) );
+	case dcc0_25Percent:	return WRITE_REG(reg, ( (READ_REG(reg) & ~MASK_BW_DCC_FREQ) | BW_DCC_0_25_PERCENT) );
+	case dcc0_125Percent:	return WRITE_REG(reg, ( (READ_REG(reg) & ~MASK_BW_DCC_FREQ) | BW_DCC_0_125_PERCENT) );
+	default:		INVALID_PARAM;
+	}
+}
+
+int rf69_set_dc_cut_off_frequency(struct spi_device *spi, enum dccPercent dccPercent)
+{
+	#ifdef DEBUG
+		dev_dbg(&spi->dev, "set: cut off freq");
+	#endif
+
+	return rf69_set_dc_cut_off_frequency_intern(spi, REG_RXBW, dccPercent);
+}
+
+int rf69_set_dc_cut_off_frequency_during_afc(struct spi_device *spi, enum dccPercent dccPercent)
+{
+	#ifdef DEBUG
+		dev_dbg(&spi->dev, "set: cut off freq during afc");
+	#endif
+
+	return rf69_set_dc_cut_off_frequency_intern(spi, REG_AFCBW, dccPercent);
+}
+
+int rf69_set_bandwidth_intern(struct spi_device *spi, u8 reg, enum mantisse mantisse, u8 exponent)
+{
+	u8 newValue;
+
+	// check value for mantisse and exponent
+	if (exponent > 7)   INVALID_PARAM;
+	if ( (mantisse!=mantisse16) &&
+	     (mantisse!=mantisse20) &&
+             (mantisse!=mantisse24) ) INVALID_PARAM;
+
+	// read old value
+	newValue = READ_REG(reg);
+
+	// "delete" mantisse and exponent = just keep the DCC setting
+	newValue = newValue & MASK_BW_DCC_FREQ;
+
+	// add new mantisse
+	switch(mantisse) {
+	case mantisse16: newValue = newValue | BW_MANT_16;	break;
+	case mantisse20: newValue = newValue | BW_MANT_20;	break;
+	case mantisse24: newValue = newValue | BW_MANT_24;	break;
+	}
+
+	// add new exponent
+	newValue = newValue | exponent;
+
+	// write back
+	return WRITE_REG(reg, newValue);
+}
+
+int rf69_set_bandwidth(struct spi_device *spi, enum mantisse mantisse, u8 exponent)
+{
+	#ifdef DEBUG
+		dev_dbg(&spi->dev, "set: band width");
+	#endif
+
+	return rf69_set_bandwidth_intern(spi, REG_RXBW, mantisse, exponent);
+}
+
+int rf69_set_bandwidth_during_afc(struct spi_device *spi, enum mantisse mantisse, u8 exponent)
+{
+	#ifdef DEBUG
+		dev_dbg(&spi->dev, "set: band width during afc");
+	#endif
+
+	return rf69_set_bandwidth_intern(spi, REG_AFCBW, mantisse, exponent);
+}
+
+int rf69_set_ook_threshold_type(struct spi_device *spi, enum thresholdType thresholdType)
+{
+	#ifdef DEBUG
+		dev_dbg(&spi->dev, "set: threshold type");
+	#endif
+
+	switch (thresholdType)
+	{
+	case fixed:	return WRITE_REG(REG_OOKPEAK, ( (READ_REG(REG_OOKPEAK) & ~MASK_OOKPEAK_THRESTYPE) | OOKPEAK_THRESHTYPE_FIXED) );
+	case peak:	return WRITE_REG(REG_OOKPEAK, ( (READ_REG(REG_OOKPEAK) & ~MASK_OOKPEAK_THRESTYPE) | OOKPEAK_THRESHTYPE_PEAK) );
+	case average:	return WRITE_REG(REG_OOKPEAK, ( (READ_REG(REG_OOKPEAK) & ~MASK_OOKPEAK_THRESTYPE) | OOKPEAK_THRESHTYPE_AVERAGE) );
+	default:	INVALID_PARAM;
+	}
+}
+
+int rf69_set_ook_threshold_step(struct spi_device *spi, enum thresholdStep thresholdStep)
+{
+	#ifdef DEBUG
+		dev_dbg(&spi->dev, "set: threshold step");
+	#endif
+
+	switch (thresholdStep) {
+	case step_0_5db: return WRITE_REG(REG_OOKPEAK, ( (READ_REG(REG_OOKPEAK) & ~MASK_OOKPEAK_THRESSTEP) | OOKPEAK_THRESHSTEP_0_5_DB) );
+	case step_1_0db: return WRITE_REG(REG_OOKPEAK, ( (READ_REG(REG_OOKPEAK) & ~MASK_OOKPEAK_THRESSTEP) | OOKPEAK_THRESHSTEP_1_0_DB) );
+	case step_1_5db: return WRITE_REG(REG_OOKPEAK, ( (READ_REG(REG_OOKPEAK) & ~MASK_OOKPEAK_THRESSTEP) | OOKPEAK_THRESHSTEP_1_5_DB) );
+	case step_2_0db: return WRITE_REG(REG_OOKPEAK, ( (READ_REG(REG_OOKPEAK) & ~MASK_OOKPEAK_THRESSTEP) | OOKPEAK_THRESHSTEP_2_0_DB) );
+	case step_3_0db: return WRITE_REG(REG_OOKPEAK, ( (READ_REG(REG_OOKPEAK) & ~MASK_OOKPEAK_THRESSTEP) | OOKPEAK_THRESHSTEP_3_0_DB) );
+	case step_4_0db: return WRITE_REG(REG_OOKPEAK, ( (READ_REG(REG_OOKPEAK) & ~MASK_OOKPEAK_THRESSTEP) | OOKPEAK_THRESHSTEP_4_0_DB) );
+	case step_5_0db: return WRITE_REG(REG_OOKPEAK, ( (READ_REG(REG_OOKPEAK) & ~MASK_OOKPEAK_THRESSTEP) | OOKPEAK_THRESHSTEP_5_0_DB) );
+	case step_6_0db: return WRITE_REG(REG_OOKPEAK, ( (READ_REG(REG_OOKPEAK) & ~MASK_OOKPEAK_THRESSTEP) | OOKPEAK_THRESHSTEP_6_0_DB) );
+	default:	 INVALID_PARAM;
+	}
+}
+
+int rf69_set_ook_threshold_dec(struct spi_device *spi, enum thresholdDecrement thresholdDecrement)
+{
+	#ifdef DEBUG
+		dev_dbg(&spi->dev, "set: threshold decrement");
+	#endif
+
+	switch (thresholdDecrement) {
+	case dec_every8th: return WRITE_REG(REG_OOKPEAK, ( (READ_REG(REG_OOKPEAK) & ~MASK_OOKPEAK_THRESDEC) | OOKPEAK_THRESHDEC_EVERY_8TH) );
+	case dec_every4th: return WRITE_REG(REG_OOKPEAK, ( (READ_REG(REG_OOKPEAK) & ~MASK_OOKPEAK_THRESDEC) | OOKPEAK_THRESHDEC_EVERY_4TH) );
+	case dec_every2nd: return WRITE_REG(REG_OOKPEAK, ( (READ_REG(REG_OOKPEAK) & ~MASK_OOKPEAK_THRESDEC) | OOKPEAK_THRESHDEC_EVERY_2ND) );
+	case dec_once:	   return WRITE_REG(REG_OOKPEAK, ( (READ_REG(REG_OOKPEAK) & ~MASK_OOKPEAK_THRESDEC) | OOKPEAK_THRESHDEC_ONCE) );
+	case dec_twice:	   return WRITE_REG(REG_OOKPEAK, ( (READ_REG(REG_OOKPEAK) & ~MASK_OOKPEAK_THRESDEC) | OOKPEAK_THRESHDEC_TWICE) );
+	case dec_4times:   return WRITE_REG(REG_OOKPEAK, ( (READ_REG(REG_OOKPEAK) & ~MASK_OOKPEAK_THRESDEC) | OOKPEAK_THRESHDEC_4_TIMES) );
+	case dec_8times:   return WRITE_REG(REG_OOKPEAK, ( (READ_REG(REG_OOKPEAK) & ~MASK_OOKPEAK_THRESDEC) | OOKPEAK_THRESHDEC_8_TIMES) );
+	case dec_16times:  return WRITE_REG(REG_OOKPEAK, ( (READ_REG(REG_OOKPEAK) & ~MASK_OOKPEAK_THRESDEC) | OOKPEAK_THRESHDEC_16_TIMES) );
+	default:	   INVALID_PARAM;
+	}
+}
+
+int rf69_set_dio_mapping(struct spi_device *spi, u8 DIONumber, u8 value)
+{
+	u8 mask;
+	u8 shift;
+	u8 regaddr;
+	u8 regValue;
+
+	#ifdef DEBUG
+		dev_dbg(&spi->dev, "set: DIO mapping");
+	#endif
+
+	// check DIO number
+	if (DIONumber > 5) INVALID_PARAM;
+
+	switch (DIONumber) {
+	case 0: mask=MASK_DIO0; shift=SHIFT_DIO0; regaddr=REG_DIOMAPPING1; break;
+	case 1: mask=MASK_DIO1; shift=SHIFT_DIO1; regaddr=REG_DIOMAPPING1; break;
+	case 2: mask=MASK_DIO2; shift=SHIFT_DIO2; regaddr=REG_DIOMAPPING1; break;
+	case 3: mask=MASK_DIO3; shift=SHIFT_DIO3; regaddr=REG_DIOMAPPING1; break;
+	case 4: mask=MASK_DIO4; shift=SHIFT_DIO4; regaddr=REG_DIOMAPPING2; break;
+	case 5: mask=MASK_DIO5; shift=SHIFT_DIO5; regaddr=REG_DIOMAPPING2; break;
+	}
+
+	// read reg
+	regValue=READ_REG(regaddr);
+	// delete old value
+	regValue = regValue & ~mask;
+	// add new value
+	regValue = regValue | value << shift;
+	// write back
+	return WRITE_REG(regaddr,regValue);
+}
+
+bool rf69_get_flag(struct spi_device *spi, enum flag flag)
+{
+	#ifdef DEBUG
+		dev_dbg(&spi->dev, "get: flag");
+	#endif
+
+	switch(flag) {
+	case modeSwitchCompleted:     return (READ_REG(REG_IRQFLAGS1) & MASK_IRQFLAGS1_MODE_READY);
+	case readyToReceive:	      return (READ_REG(REG_IRQFLAGS1) & MASK_IRQFLAGS1_RX_READY);
+	case readyToSend:	      return (READ_REG(REG_IRQFLAGS1) & MASK_IRQFLAGS1_TX_READY);
+	case pllLocked:		      return (READ_REG(REG_IRQFLAGS1) & MASK_IRQFLAGS1_PLL_LOCK);
+	case rssiExceededThreshold:   return (READ_REG(REG_IRQFLAGS1) & MASK_IRQFLAGS1_RSSI);
+	case timeout:		      return (READ_REG(REG_IRQFLAGS1) & MASK_IRQFLAGS1_TIMEOUT);
+	case automode:		      return (READ_REG(REG_IRQFLAGS1) & MASK_IRQFLAGS1_AUTOMODE);
+	case syncAddressMatch:	      return (READ_REG(REG_IRQFLAGS1) & MASK_IRQFLAGS1_SYNC_ADDRESS_MATCH);
+	case fifoFull:		      return (READ_REG(REG_IRQFLAGS2) & MASK_IRQFLAGS2_FIFO_FULL);
+/*	case fifoNotEmpty:	      return (READ_REG(REG_IRQFLAGS2) & MASK_IRQFLAGS2_FIFO_NOT_EMPTY); */
+	case fifoEmpty:		      return !(READ_REG(REG_IRQFLAGS2) & MASK_IRQFLAGS2_FIFO_NOT_EMPTY);
+	case fifoLevelBelowThreshold: return (READ_REG(REG_IRQFLAGS2) & MASK_IRQFLAGS2_FIFO_LEVEL);
+	case fifoOverrun:	      return (READ_REG(REG_IRQFLAGS2) & MASK_IRQFLAGS2_FIFO_OVERRUN);
+	case packetSent:	      return (READ_REG(REG_IRQFLAGS2) & MASK_IRQFLAGS2_PACKET_SENT);
+	case payloadReady:	      return (READ_REG(REG_IRQFLAGS2) & MASK_IRQFLAGS2_PAYLOAD_READY);
+	case crcOk:		      return (READ_REG(REG_IRQFLAGS2) & MASK_IRQFLAGS2_CRC_OK);
+	case batteryLow:	      return (READ_REG(REG_IRQFLAGS2) & MASK_IRQFLAGS2_LOW_BAT);
+	default:		      return false;
+	}
+}
+
+int rf69_reset_flag(struct spi_device *spi, enum flag flag)
+{
+	#ifdef DEBUG
+		dev_dbg(&spi->dev, "reset: flag");
+	#endif
+
+	switch(flag) {
+	case rssiExceededThreshold: return WRITE_REG(REG_IRQFLAGS1, MASK_IRQFLAGS1_RSSI);
+	case syncAddressMatch:	    return WRITE_REG(REG_IRQFLAGS1, MASK_IRQFLAGS1_SYNC_ADDRESS_MATCH);
+	case fifoOverrun:	    return WRITE_REG(REG_IRQFLAGS2, MASK_IRQFLAGS2_FIFO_OVERRUN);
+	default:		    INVALID_PARAM;
+	}
+}
+
+int rf69_set_rssi_threshold(struct spi_device *spi, u8 threshold)
+{
+	#ifdef DEBUG
+		dev_dbg(&spi->dev, "set: rssi threshold");
+	#endif
+
+	/* no value check needed - u8 exactly matches register size */
+
+	return WRITE_REG(REG_RSSITHRESH, threshold);
+}
+
+int rf69_set_rx_start_timeout(struct spi_device *spi, u8 timeout)
+{
+	#ifdef DEBUG
+		dev_dbg(&spi->dev, "set: start timeout");
+	#endif
+
+	/* no value check needed - u8 exactly matches register size */
+
+	return WRITE_REG(REG_RXTIMEOUT1, timeout);
+}
+
+int rf69_set_rssi_timeout(struct spi_device *spi, u8 timeout)
+{
+	#ifdef DEBUG
+		dev_dbg(&spi->dev, "set: rssi timeout");
+	#endif
+
+	/* no value check needed - u8 exactly matches register size */
+
+	return WRITE_REG(REG_RXTIMEOUT2, timeout);
+}
+
+int rf69_set_preamble_length(struct spi_device *spi, u16 preambleLength)
+{
+	int retval;
+	u8 msb, lsb;
+
+	#ifdef DEBUG
+		dev_dbg(&spi->dev, "set: preample length");
+	#endif
+
+	/* no value check needed - u16 exactly matches register size */
+
+	/* calculate reg settings */
+	msb = (preambleLength&0xff00)   >>  8;
+	lsb = (preambleLength&0xff);
+
+	/* transmit to chip */
+	retval = WRITE_REG(REG_PREAMBLE_MSB, msb);
+	if (retval) return retval;
+	retval = WRITE_REG(REG_PREAMBLE_LSB, lsb);
+
+	return retval;
+}
+
+int rf69_set_sync_enable(struct spi_device *spi, enum optionOnOff optionOnOff)
+{
+	#ifdef DEBUG
+		dev_dbg(&spi->dev, "set: sync enable");
+	#endif
+
+	switch(optionOnOff) {
+	case optionOn:	return WRITE_REG(REG_SYNC_CONFIG, (READ_REG(REG_SYNC_CONFIG) |  MASK_SYNC_CONFIG_SYNC_ON) );
+	case optionOff:	return WRITE_REG(REG_SYNC_CONFIG, (READ_REG(REG_SYNC_CONFIG) & ~MASK_SYNC_CONFIG_SYNC_ON) );
+	default:	INVALID_PARAM;
+	}
+}
+
+int rf69_set_fifo_fill_condition(struct spi_device *spi, enum fifoFillCondition fifoFillCondition)
+{
+	#ifdef DEBUG
+		dev_dbg(&spi->dev, "set: fifo fill condition");
+	#endif
+
+	switch(fifoFillCondition) {
+	case always:		 return WRITE_REG(REG_SYNC_CONFIG, (READ_REG(REG_SYNC_CONFIG) |  MASK_SYNC_CONFIG_FIFO_FILL_CONDITION) );
+	case afterSyncInterrupt: return WRITE_REG(REG_SYNC_CONFIG, (READ_REG(REG_SYNC_CONFIG) & ~MASK_SYNC_CONFIG_FIFO_FILL_CONDITION) );
+	default:		 INVALID_PARAM;
+	}
+}
+
+int rf69_set_sync_size(struct spi_device *spi, u8 syncSize)
+{
+	#ifdef DEBUG
+		dev_dbg(&spi->dev, "set: sync size");
+	#endif
+
+	// check input value
+	if (syncSize > 0x07)
+		INVALID_PARAM;
+
+	// write value
+	return WRITE_REG(REG_SYNC_CONFIG, (READ_REG(REG_SYNC_CONFIG) & ~MASK_SYNC_CONFIG_SYNC_SIZE) | (syncSize << 3) );
+}
+
+int rf69_set_sync_tolerance(struct spi_device *spi, u8 syncTolerance)
+{
+	#ifdef DEBUG
+		dev_dbg(&spi->dev, "set: sync tolerance");
+	#endif
+
+	// check input value
+	if (syncTolerance > 0x07)
+		INVALID_PARAM;
+
+	// write value
+	return WRITE_REG(REG_SYNC_CONFIG, (READ_REG(REG_SYNC_CONFIG) & ~MASK_SYNC_CONFIG_SYNC_SIZE) | syncTolerance);
+}
+
+int rf69_set_sync_values(struct spi_device *spi, u8 syncValues[8])
+{
+	int retval = 0;
+
+	#ifdef DEBUG
+		dev_dbg(&spi->dev, "set: sync values");
+	#endif
+
+	retval += WRITE_REG(REG_SYNCVALUE1, syncValues[0]);
+	retval += WRITE_REG(REG_SYNCVALUE2, syncValues[1]);
+	retval += WRITE_REG(REG_SYNCVALUE3, syncValues[2]);
+	retval += WRITE_REG(REG_SYNCVALUE4, syncValues[3]);
+	retval += WRITE_REG(REG_SYNCVALUE5, syncValues[4]);
+	retval += WRITE_REG(REG_SYNCVALUE6, syncValues[5]);
+	retval += WRITE_REG(REG_SYNCVALUE7, syncValues[6]);
+	retval += WRITE_REG(REG_SYNCVALUE8, syncValues[7]);
+
+	return retval;
+}
+
+int rf69_set_packet_format(struct spi_device * spi, enum packetFormat packetFormat)
+{
+	#ifdef DEBUG
+		dev_dbg(&spi->dev, "set: packet format");
+	#endif
+
+	switch(packetFormat) {
+	case packetLengthVar: return WRITE_REG(REG_PACKETCONFIG1, (READ_REG(REG_PACKETCONFIG1) |  MASK_PACKETCONFIG1_PAKET_FORMAT_VARIABLE) );
+	case packetLengthFix: return WRITE_REG(REG_PACKETCONFIG1, (READ_REG(REG_PACKETCONFIG1) & ~MASK_PACKETCONFIG1_PAKET_FORMAT_VARIABLE) );
+	default:	      INVALID_PARAM;
+	}
+}
+
+int rf69_set_crc_enable(struct spi_device *spi, enum optionOnOff optionOnOff)
+{
+	#ifdef DEBUG
+		dev_dbg(&spi->dev, "set: crc enable");
+	#endif
+
+	switch(optionOnOff) {
+	case optionOn:	return WRITE_REG(REG_PACKETCONFIG1, (READ_REG(REG_PACKETCONFIG1) |  MASK_PACKETCONFIG1_CRC_ON) );
+	case optionOff:	return WRITE_REG(REG_PACKETCONFIG1, (READ_REG(REG_PACKETCONFIG1) & ~MASK_PACKETCONFIG1_CRC_ON) );
+	default:	INVALID_PARAM;
+	}
+}
+
+int rf69_set_adressFiltering(struct spi_device *spi, enum addressFiltering addressFiltering)
+{
+	#ifdef DEBUG
+		dev_dbg(&spi->dev, "set: address filtering");
+	#endif
+
+	switch (addressFiltering) {
+	case filteringOff:	     return WRITE_REG(REG_PACKETCONFIG1, ( (READ_REG(REG_PACKETCONFIG1) & ~MASK_PACKETCONFIG1_ADDRESSFILTERING) | PACKETCONFIG1_ADDRESSFILTERING_OFF) );
+	case nodeAddress:	     return WRITE_REG(REG_PACKETCONFIG1, ( (READ_REG(REG_PACKETCONFIG1) & ~MASK_PACKETCONFIG1_ADDRESSFILTERING) | PACKETCONFIG1_ADDRESSFILTERING_NODE) );
+	case nodeOrBroadcastAddress: return WRITE_REG(REG_PACKETCONFIG1, ( (READ_REG(REG_PACKETCONFIG1) & ~MASK_PACKETCONFIG1_ADDRESSFILTERING) | PACKETCONFIG1_ADDRESSFILTERING_NODEBROADCAST) );
+	default:		     INVALID_PARAM;
+	}
+}
+
+int rf69_set_payload_length(struct spi_device *spi, u8 payloadLength)
+{
+	#ifdef DEBUG
+		dev_dbg(&spi->dev, "set: payload length");
+	#endif
+
+	return WRITE_REG(REG_PAYLOAD_LENGTH, payloadLength);
+}
+
+u8  rf69_get_payload_length(struct spi_device *spi)
+{
+	#ifdef DEBUG
+		dev_dbg(&spi->dev, "get: payload length");
+	#endif
+
+	return (u8) READ_REG(REG_PAYLOAD_LENGTH);
+}
+
+int rf69_set_node_address(struct spi_device *spi, u8 nodeAddress)
+{
+	#ifdef DEBUG
+		dev_dbg(&spi->dev, "set: node address");
+	#endif
+
+	return WRITE_REG(REG_NODEADRS, nodeAddress);
+}
+
+int rf69_set_broadcast_address(struct spi_device *spi, u8 broadcastAddress)
+{
+	#ifdef DEBUG
+		dev_dbg(&spi->dev, "set: broadcast address");
+	#endif
+
+	return WRITE_REG(REG_BROADCASTADRS, broadcastAddress);
+}
+
+int rf69_set_tx_start_condition(struct spi_device *spi, enum txStartCondition txStartCondition)
+{
+	#ifdef DEBUG
+		dev_dbg(&spi->dev, "set: start condition");
+	#endif
+
+	switch(txStartCondition) {
+	case fifoLevel:	   return WRITE_REG(REG_FIFO_THRESH, (READ_REG(REG_FIFO_THRESH) & ~MASK_FIFO_THRESH_TXSTART) );
+	case fifoNotEmpty: return WRITE_REG(REG_FIFO_THRESH, (READ_REG(REG_FIFO_THRESH) |  MASK_FIFO_THRESH_TXSTART) );
+	default:	   INVALID_PARAM;
+	}
+}
+
+int rf69_set_fifo_threshold(struct spi_device *spi, u8 threshold)
+{
+	int retval;
+
+	#ifdef DEBUG
+		dev_dbg(&spi->dev, "set: fifo threshold");
+	#endif
+
+	// check input value
+	if (threshold & 0x80)
+		INVALID_PARAM;
+
+	// write value
+	retval = WRITE_REG(REG_FIFO_THRESH, (READ_REG(REG_FIFO_THRESH) & ~MASK_FIFO_THRESH_VALUE) | threshold);
+	if (retval)
+		return retval;
+
+	// access the fifo to activate new threshold
+	return rf69_read_fifo (spi, (u8*) &retval, 1); // retval used as buffer
+}
+
+int rf69_set_dagc(struct spi_device *spi, enum dagc dagc)
+{
+	#ifdef DEBUG
+		dev_dbg(&spi->dev, "set: dagc");
+	#endif
+
+	switch(dagc) {
+	case normalMode:		 return WRITE_REG(REG_TESTDAGC, DAGC_NORMAL);
+	case improve:			 return WRITE_REG(REG_TESTDAGC, DAGC_IMPROVED_LOWBETA0);
+	case improve4LowModulationIndex: return WRITE_REG(REG_TESTDAGC, DAGC_IMPROVED_LOWBETA1);
+	default:			 INVALID_PARAM;
+	}
+}
+
+/*-------------------------------------------------------------------------*/
+
+int rf69_read_fifo (struct spi_device *spi, u8 *buffer, unsigned int size)
+{
+	#ifdef DEBUG_FIFO_ACCESS
+		int i;
+	#endif
+	struct spi_transfer transfer;
+	u8 local_buffer[FIFO_SIZE + 1];
+	int retval;
+
+	if (size > FIFO_SIZE)
+	{
+		#ifdef DEBUG
+			dev_dbg(&spi->dev, "read fifo: passed in buffer bigger then internal buffer \n");
+		#endif
+		return -EMSGSIZE;
+	}
+
+	/* prepare a bidirectional transfer */
+	local_buffer[0] = REG_FIFO;
+	memset(&transfer, 0, sizeof(transfer));
+  	transfer.tx_buf = local_buffer;
+  	transfer.rx_buf = local_buffer;
+	transfer.len	= size+1;
+
+	retval = spi_sync_transfer(spi, &transfer, 1);
+
+	#ifdef DEBUG_FIFO_ACCESS
+		for (i=0; i<size; i++)
+			dev_dbg(&spi->dev, "%d - 0x%x\n", i, local_buffer[i+1]);
+	#endif
+
+	memcpy(buffer, &local_buffer[1], size);  // TODO: ohne memcopy wre schner
+
+	return retval;
+}
+
+int rf69_write_fifo(struct spi_device *spi, u8 *buffer, unsigned int size)
+{
+	#ifdef DEBUG_FIFO_ACCESS
+		int i;
+	#endif
+	char spi_address = REG_FIFO | WRITE_BIT;
+	u8 local_buffer[FIFO_SIZE + 1];
+
+	if (size > FIFO_SIZE)
+	{
+		#ifdef DEBUG
+			dev_dbg(&spi->dev, "read fifo: passed in buffer bigger then internal buffer \n");
+		#endif
+		return -EMSGSIZE;
+	}
+
+	local_buffer[0] = spi_address;
+	memcpy(&local_buffer[1], buffer, size);  // TODO: ohne memcopy wre schner
+
+	#ifdef DEBUG_FIFO_ACCESS
+		for (i=0; i<size; i++)
+			dev_dbg(&spi->dev, "0x%x\n",buffer[i]);
+	#endif
+
+	return spi_write (spi, local_buffer, size + 1);
+}
+
+/*-------------------------------------------------------------------------*/
+
+u8 rf69_read_reg(struct spi_device *spi, u8 addr)
+{
+	int retval;
+
+	retval = spi_w8r8(spi, addr);
+
+	#ifdef DEBUG_VALUES
+		if (retval < 0)
+			/* should never happen, since we already checked,
+			   that module is connected. Therefore no error
+			   handling, just an optional error message... */
+			dev_dbg(&spi->dev, "read 0x%x FAILED\n",
+				addr);
+		else
+			dev_dbg(&spi->dev, "read 0x%x from reg 0x%x\n",
+				retval,
+				addr);
+	#endif
+
+	return retval;
+}
+
+int rf69_write_reg(struct spi_device *spi, u8 addr, u8 value)
+{
+	int retval;
+	char buffer[2];
+
+	buffer[0] = addr | WRITE_BIT;
+	buffer[1] = value;
+
+	retval = spi_write(spi, &buffer, 2);
+
+	#ifdef DEBUG_VALUES
+		if (retval < 0)
+			/* should never happen, since we already checked,
+			   that module is connected. Therefore no error
+			   handling, just an optional error message... */
+			dev_dbg(&spi->dev, "write 0x%x to 0x%x FAILED\n",
+				value,
+				addr);
+		else
+			dev_dbg(&spi->dev, "wrote 0x%x to reg 0x%x\n",
+				value,
+				addr);
+	#endif
+
+	return retval;
+}
+
+
