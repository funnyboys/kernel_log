commit fbacec8f2a0e05dd72de475224f3ab1c705c70fb
Author: Nishad Kamdar <nishadkamdar@gmail.com>
Date:   Mon Jan 14 20:27:31 2019 +0530

    staging: greybus: arche-apb-ctrl.c: Switch to the gpio descriptor interface
    
    Use the gpiod interface instead of the deprecated old non-descriptor
    interface while continuing to ignore gpio flags from device tree in
    functions "deassert_reset()" and "assert_reset()" for now.
    
    Reviewed-by: Johan Hovold <johan@kernel.org>
    Signed-off-by: Nishad Kamdar <nishadkamdar@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/arche-apb-ctrl.c b/drivers/staging/greybus/arche-apb-ctrl.c
index be5ffed90bcf..bbf3ba744fc4 100644
--- a/drivers/staging/greybus/arche-apb-ctrl.c
+++ b/drivers/staging/greybus/arche-apb-ctrl.c
@@ -8,9 +8,8 @@
 
 #include <linux/clk.h>
 #include <linux/delay.h>
-#include <linux/gpio.h>
+#include <linux/gpio/consumer.h>
 #include <linux/interrupt.h>
-#include <linux/of_gpio.h>
 #include <linux/of_irq.h>
 #include <linux/module.h>
 #include <linux/pinctrl/consumer.h>
@@ -24,12 +23,12 @@ static void apb_bootret_deassert(struct device *dev);
 
 struct arche_apb_ctrl_drvdata {
 	/* Control GPIO signals to and from AP <=> AP Bridges */
-	int resetn_gpio;
-	int boot_ret_gpio;
-	int pwroff_gpio;
-	int wake_in_gpio;
-	int wake_out_gpio;
-	int pwrdn_gpio;
+	struct gpio_desc *resetn;
+	struct gpio_desc *boot_ret;
+	struct gpio_desc *pwroff;
+	struct gpio_desc *wake_in;
+	struct gpio_desc *wake_out;
+	struct gpio_desc *pwrdn;
 
 	enum arche_platform_state state;
 	bool init_disabled;
@@ -37,28 +36,28 @@ struct arche_apb_ctrl_drvdata {
 	struct regulator *vcore;
 	struct regulator *vio;
 
-	int clk_en_gpio;
+	struct gpio_desc *clk_en;
 	struct clk *clk;
 
 	struct pinctrl *pinctrl;
 	struct pinctrl_state *pin_default;
 
 	/* V2: SPI Bus control  */
-	int spi_en_gpio;
+	struct gpio_desc *spi_en;
 	bool spi_en_polarity_high;
 };
 
 /*
  * Note that these low level api's are active high
  */
-static inline void deassert_reset(unsigned int gpio)
+static inline void deassert_reset(struct gpio_desc *gpio)
 {
-	gpio_set_value(gpio, 1);
+	gpiod_set_raw_value(gpio, 1);
 }
 
-static inline void assert_reset(unsigned int gpio)
+static inline void assert_reset(struct gpio_desc *gpio)
 {
-	gpio_set_value(gpio, 0);
+	gpiod_set_raw_value(gpio, 0);
 }
 
 /*
@@ -75,11 +74,10 @@ static int coldboot_seq(struct platform_device *pdev)
 		return 0;
 
 	/* Hold APB in reset state */
-	assert_reset(apb->resetn_gpio);
+	assert_reset(apb->resetn);
 
-	if (apb->state == ARCHE_PLATFORM_STATE_FW_FLASHING &&
-	    gpio_is_valid(apb->spi_en_gpio))
-		devm_gpio_free(dev, apb->spi_en_gpio);
+	if (apb->state == ARCHE_PLATFORM_STATE_FW_FLASHING && apb->spi_en)
+		devm_gpiod_put(dev, apb->spi_en);
 
 	/* Enable power to APB */
 	if (!IS_ERR(apb->vcore)) {
@@ -101,13 +99,13 @@ static int coldboot_seq(struct platform_device *pdev)
 	apb_bootret_deassert(dev);
 
 	/* On DB3 clock was not mandatory */
-	if (gpio_is_valid(apb->clk_en_gpio))
-		gpio_set_value(apb->clk_en_gpio, 1);
+	if (apb->clk_en)
+		gpiod_set_value(apb->clk_en, 1);
 
 	usleep_range(100, 200);
 
 	/* deassert reset to APB : Active-low signal */
-	deassert_reset(apb->resetn_gpio);
+	deassert_reset(apb->resetn);
 
 	apb->state = ARCHE_PLATFORM_STATE_ACTIVE;
 
@@ -136,25 +134,25 @@ static int fw_flashing_seq(struct platform_device *pdev)
 		return ret;
 	}
 
-	if (gpio_is_valid(apb->spi_en_gpio)) {
+	if (apb->spi_en) {
 		unsigned long flags;
 
 		if (apb->spi_en_polarity_high)
-			flags = GPIOF_OUT_INIT_HIGH;
+			flags = GPIOD_OUT_HIGH;
 		else
-			flags = GPIOF_OUT_INIT_LOW;
+			flags = GPIOD_OUT_LOW;
 
-		ret = devm_gpio_request_one(dev, apb->spi_en_gpio,
-					    flags, "apb_spi_en");
-		if (ret) {
-			dev_err(dev, "Failed requesting SPI bus en gpio %d\n",
-				apb->spi_en_gpio);
+		apb->spi_en = devm_gpiod_get(dev, "spi-en", flags);
+		if (IS_ERR(apb->spi_en)) {
+			ret = PTR_ERR(apb->spi_en);
+			dev_err(dev, "Failed requesting SPI bus en GPIO: %d\n",
+				ret);
 			return ret;
 		}
 	}
 
 	/* for flashing device should be in reset state */
-	assert_reset(apb->resetn_gpio);
+	assert_reset(apb->resetn);
 	apb->state = ARCHE_PLATFORM_STATE_FW_FLASHING;
 
 	return 0;
@@ -176,9 +174,8 @@ static int standby_boot_seq(struct platform_device *pdev)
 	    apb->state == ARCHE_PLATFORM_STATE_OFF)
 		return 0;
 
-	if (apb->state == ARCHE_PLATFORM_STATE_FW_FLASHING &&
-	    gpio_is_valid(apb->spi_en_gpio))
-		devm_gpio_free(dev, apb->spi_en_gpio);
+	if (apb->state == ARCHE_PLATFORM_STATE_FW_FLASHING && apb->spi_en)
+		devm_gpiod_put(dev, apb->spi_en);
 
 	/*
 	 * As per WDM spec, do nothing
@@ -201,13 +198,12 @@ static void poweroff_seq(struct platform_device *pdev)
 	if (apb->init_disabled || apb->state == ARCHE_PLATFORM_STATE_OFF)
 		return;
 
-	if (apb->state == ARCHE_PLATFORM_STATE_FW_FLASHING &&
-	    gpio_is_valid(apb->spi_en_gpio))
-		devm_gpio_free(dev, apb->spi_en_gpio);
+	if (apb->state == ARCHE_PLATFORM_STATE_FW_FLASHING && apb->spi_en)
+		devm_gpiod_put(dev, apb->spi_en);
 
 	/* disable the clock */
-	if (gpio_is_valid(apb->clk_en_gpio))
-		gpio_set_value(apb->clk_en_gpio, 0);
+	if (apb->clk_en)
+		gpiod_set_value(apb->clk_en, 0);
 
 	if (!IS_ERR(apb->vcore) && regulator_is_enabled(apb->vcore) > 0)
 		regulator_disable(apb->vcore);
@@ -216,7 +212,7 @@ static void poweroff_seq(struct platform_device *pdev)
 		regulator_disable(apb->vio);
 
 	/* As part of exit, put APB back in reset state */
-	assert_reset(apb->resetn_gpio);
+	assert_reset(apb->resetn);
 	apb->state = ARCHE_PLATFORM_STATE_OFF;
 
 	/* TODO: May have to send an event to SVC about this exit */
@@ -226,7 +222,7 @@ static void apb_bootret_deassert(struct device *dev)
 {
 	struct arche_apb_ctrl_drvdata *apb = dev_get_drvdata(dev);
 
-	gpio_set_value(apb->boot_ret_gpio, 0);
+	gpiod_set_value(apb->boot_ret, 0);
 }
 
 int apb_ctrl_coldboot(struct device *dev)
@@ -322,66 +318,44 @@ static int apb_ctrl_get_devtree_data(struct platform_device *pdev,
 				     struct arche_apb_ctrl_drvdata *apb)
 {
 	struct device *dev = &pdev->dev;
-	struct device_node *np = dev->of_node;
 	int ret;
 
-	apb->resetn_gpio = of_get_named_gpio(np, "reset-gpios", 0);
-	if (apb->resetn_gpio < 0) {
-		dev_err(dev, "failed to get reset gpio\n");
-		return apb->resetn_gpio;
-	}
-	ret = devm_gpio_request_one(dev, apb->resetn_gpio,
-				    GPIOF_OUT_INIT_LOW, "apb-reset");
-	if (ret) {
-		dev_err(dev, "Failed requesting reset gpio %d\n",
-			apb->resetn_gpio);
+	apb->resetn = devm_gpiod_get(dev, "reset", GPIOD_OUT_LOW);
+	if (IS_ERR(apb->resetn)) {
+		ret = PTR_ERR(apb->resetn);
+		dev_err(dev, "Failed requesting reset GPIO: %d\n", ret);
 		return ret;
 	}
 
-	apb->boot_ret_gpio = of_get_named_gpio(np, "boot-ret-gpios", 0);
-	if (apb->boot_ret_gpio < 0) {
-		dev_err(dev, "failed to get boot retention gpio\n");
-		return apb->boot_ret_gpio;
-	}
-	ret = devm_gpio_request_one(dev, apb->boot_ret_gpio,
-				    GPIOF_OUT_INIT_LOW, "boot retention");
-	if (ret) {
-		dev_err(dev, "Failed requesting bootret gpio %d\n",
-			apb->boot_ret_gpio);
+	apb->boot_ret = devm_gpiod_get(dev, "boot-ret", GPIOD_OUT_LOW);
+	if (IS_ERR(apb->boot_ret)) {
+		ret = PTR_ERR(apb->boot_ret);
+		dev_err(dev, "Failed requesting bootret GPIO: %d\n", ret);
 		return ret;
 	}
 
 	/* It's not mandatory to support power management interface */
-	apb->pwroff_gpio = of_get_named_gpio(np, "pwr-off-gpios", 0);
-	if (apb->pwroff_gpio < 0) {
-		dev_err(dev, "failed to get power off gpio\n");
-		return apb->pwroff_gpio;
-	}
-	ret = devm_gpio_request_one(dev, apb->pwroff_gpio,
-				    GPIOF_IN, "pwroff_n");
-	if (ret) {
-		dev_err(dev, "Failed requesting pwroff_n gpio %d\n",
-			apb->pwroff_gpio);
+	apb->pwroff = devm_gpiod_get_optional(dev, "pwr-off", GPIOD_IN);
+	if (IS_ERR(apb->pwroff)) {
+		ret = PTR_ERR(apb->pwroff);
+		dev_err(dev, "Failed requesting pwroff_n GPIO: %d\n", ret);
 		return ret;
 	}
 
 	/* Do not make clock mandatory as of now (for DB3) */
-	apb->clk_en_gpio = of_get_named_gpio(np, "clock-en-gpio", 0);
-	if (apb->clk_en_gpio < 0) {
-		dev_warn(dev, "failed to get clock en gpio\n");
-	} else if (gpio_is_valid(apb->clk_en_gpio)) {
-		ret = devm_gpio_request_one(dev, apb->clk_en_gpio,
-					    GPIOF_OUT_INIT_LOW, "apb_clk_en");
-		if (ret) {
-			dev_warn(dev, "Failed requesting APB clock en gpio %d\n",
-				 apb->clk_en_gpio);
-			return ret;
-		}
+	apb->clk_en = devm_gpiod_get_optional(dev, "clock-en", GPIOD_OUT_LOW);
+	if (IS_ERR(apb->clk_en)) {
+		ret = PTR_ERR(apb->clk_en);
+		dev_err(dev, "Failed requesting APB clock en GPIO: %d\n", ret);
+		return ret;
 	}
 
-	apb->pwrdn_gpio = of_get_named_gpio(np, "pwr-down-gpios", 0);
-	if (apb->pwrdn_gpio < 0)
-		dev_warn(dev, "failed to get power down gpio\n");
+	apb->pwrdn = devm_gpiod_get(dev, "pwr-down", GPIOD_OUT_LOW);
+	if (IS_ERR(apb->pwrdn)) {
+		ret = PTR_ERR(apb->pwrdn);
+		dev_warn(dev, "Failed requesting power down GPIO: %d\n", ret);
+		return ret;
+	}
 
 	/* Regulators are optional, as we may have fixed supply coming in */
 	apb->vcore = devm_regulator_get(dev, "vcore");
@@ -404,12 +378,8 @@ static int apb_ctrl_get_devtree_data(struct platform_device *pdev,
 	}
 
 	/* Only applicable for platform >= V2 */
-	apb->spi_en_gpio = of_get_named_gpio(np, "spi-en-gpio", 0);
-	if (apb->spi_en_gpio >= 0) {
-		if (of_property_read_bool(pdev->dev.of_node,
-					  "spi-en-active-high"))
-			apb->spi_en_polarity_high = true;
-	}
+	if (of_property_read_bool(pdev->dev.of_node, "gb,spi-en-active-high"))
+		apb->spi_en_polarity_high = true;
 
 	return 0;
 }

commit fea06c0ba4f0d9e4603cb9937060159682453497
Author: Ioannis Valasakis <code@wizofe.uk>
Date:   Fri Nov 9 13:54:09 2018 +0000

    staging: greybus: remove multiple blank lines
    
    Remove continuous multiple blank lines.
    Reported by checkpatch.
    
    Signed-off-by: Ioannis Valasakis <code@wizofe.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/arche-apb-ctrl.c b/drivers/staging/greybus/arche-apb-ctrl.c
index cc8d6fc831b4..be5ffed90bcf 100644
--- a/drivers/staging/greybus/arche-apb-ctrl.c
+++ b/drivers/staging/greybus/arche-apb-ctrl.c
@@ -20,7 +20,6 @@
 #include <linux/spinlock.h>
 #include "arche_platform.h"
 
-
 static void apb_bootret_deassert(struct device *dev);
 
 struct arche_apb_ctrl_drvdata {

commit 339744e242907a7920fcea8cf47babc10155d85f
Author: Kamal Heib <kamalheib1@gmail.com>
Date:   Sun Dec 17 19:56:26 2017 +0200

    staging: greybus: arche-apb-ctrl.c: Fix alignment should match open parenthesis
    
    Fix "alignment should match open parenthesis" checkpatch.pl error.
    
    Signed-off-by: Kamal Heib <kamalheib1@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/arche-apb-ctrl.c b/drivers/staging/greybus/arche-apb-ctrl.c
index b0c66112eb18..cc8d6fc831b4 100644
--- a/drivers/staging/greybus/arche-apb-ctrl.c
+++ b/drivers/staging/greybus/arche-apb-ctrl.c
@@ -72,14 +72,14 @@ static int coldboot_seq(struct platform_device *pdev)
 	int ret;
 
 	if (apb->init_disabled ||
-			apb->state == ARCHE_PLATFORM_STATE_ACTIVE)
+	    apb->state == ARCHE_PLATFORM_STATE_ACTIVE)
 		return 0;
 
 	/* Hold APB in reset state */
 	assert_reset(apb->resetn_gpio);
 
 	if (apb->state == ARCHE_PLATFORM_STATE_FW_FLASHING &&
-			gpio_is_valid(apb->spi_en_gpio))
+	    gpio_is_valid(apb->spi_en_gpio))
 		devm_gpio_free(dev, apb->spi_en_gpio);
 
 	/* Enable power to APB */
@@ -122,7 +122,7 @@ static int fw_flashing_seq(struct platform_device *pdev)
 	int ret;
 
 	if (apb->init_disabled ||
-			apb->state == ARCHE_PLATFORM_STATE_FW_FLASHING)
+	    apb->state == ARCHE_PLATFORM_STATE_FW_FLASHING)
 		return 0;
 
 	ret = regulator_enable(apb->vcore);
@@ -146,7 +146,7 @@ static int fw_flashing_seq(struct platform_device *pdev)
 			flags = GPIOF_OUT_INIT_LOW;
 
 		ret = devm_gpio_request_one(dev, apb->spi_en_gpio,
-				flags, "apb_spi_en");
+					    flags, "apb_spi_en");
 		if (ret) {
 			dev_err(dev, "Failed requesting SPI bus en gpio %d\n",
 				apb->spi_en_gpio);
@@ -174,11 +174,11 @@ static int standby_boot_seq(struct platform_device *pdev)
 	 * then we do not want to change the state
 	 */
 	if (apb->state == ARCHE_PLATFORM_STATE_STANDBY ||
-			apb->state == ARCHE_PLATFORM_STATE_OFF)
+	    apb->state == ARCHE_PLATFORM_STATE_OFF)
 		return 0;
 
 	if (apb->state == ARCHE_PLATFORM_STATE_FW_FLASHING &&
-			gpio_is_valid(apb->spi_en_gpio))
+	    gpio_is_valid(apb->spi_en_gpio))
 		devm_gpio_free(dev, apb->spi_en_gpio);
 
 	/*
@@ -203,7 +203,7 @@ static void poweroff_seq(struct platform_device *pdev)
 		return;
 
 	if (apb->state == ARCHE_PLATFORM_STATE_FW_FLASHING &&
-			gpio_is_valid(apb->spi_en_gpio))
+	    gpio_is_valid(apb->spi_en_gpio))
 		devm_gpio_free(dev, apb->spi_en_gpio);
 
 	/* disable the clock */
@@ -251,7 +251,8 @@ void apb_ctrl_poweroff(struct device *dev)
 }
 
 static ssize_t state_store(struct device *dev,
-		struct device_attribute *attr, const char *buf, size_t count)
+			   struct device_attribute *attr,
+			   const char *buf, size_t count)
 {
 	struct platform_device *pdev = to_platform_device(dev);
 	struct arche_apb_ctrl_drvdata *apb = platform_get_drvdata(pdev);
@@ -297,7 +298,7 @@ static ssize_t state_store(struct device *dev,
 }
 
 static ssize_t state_show(struct device *dev,
-		struct device_attribute *attr, char *buf)
+			  struct device_attribute *attr, char *buf)
 {
 	struct arche_apb_ctrl_drvdata *apb = dev_get_drvdata(dev);
 
@@ -319,7 +320,7 @@ static ssize_t state_show(struct device *dev,
 static DEVICE_ATTR_RW(state);
 
 static int apb_ctrl_get_devtree_data(struct platform_device *pdev,
-		struct arche_apb_ctrl_drvdata *apb)
+				     struct arche_apb_ctrl_drvdata *apb)
 {
 	struct device *dev = &pdev->dev;
 	struct device_node *np = dev->of_node;
@@ -331,10 +332,10 @@ static int apb_ctrl_get_devtree_data(struct platform_device *pdev,
 		return apb->resetn_gpio;
 	}
 	ret = devm_gpio_request_one(dev, apb->resetn_gpio,
-			GPIOF_OUT_INIT_LOW, "apb-reset");
+				    GPIOF_OUT_INIT_LOW, "apb-reset");
 	if (ret) {
 		dev_err(dev, "Failed requesting reset gpio %d\n",
-				apb->resetn_gpio);
+			apb->resetn_gpio);
 		return ret;
 	}
 
@@ -344,10 +345,10 @@ static int apb_ctrl_get_devtree_data(struct platform_device *pdev,
 		return apb->boot_ret_gpio;
 	}
 	ret = devm_gpio_request_one(dev, apb->boot_ret_gpio,
-			GPIOF_OUT_INIT_LOW, "boot retention");
+				    GPIOF_OUT_INIT_LOW, "boot retention");
 	if (ret) {
 		dev_err(dev, "Failed requesting bootret gpio %d\n",
-				apb->boot_ret_gpio);
+			apb->boot_ret_gpio);
 		return ret;
 	}
 
@@ -358,10 +359,10 @@ static int apb_ctrl_get_devtree_data(struct platform_device *pdev,
 		return apb->pwroff_gpio;
 	}
 	ret = devm_gpio_request_one(dev, apb->pwroff_gpio,
-			GPIOF_IN, "pwroff_n");
+				    GPIOF_IN, "pwroff_n");
 	if (ret) {
 		dev_err(dev, "Failed requesting pwroff_n gpio %d\n",
-				apb->pwroff_gpio);
+			apb->pwroff_gpio);
 		return ret;
 	}
 
@@ -371,10 +372,10 @@ static int apb_ctrl_get_devtree_data(struct platform_device *pdev,
 		dev_warn(dev, "failed to get clock en gpio\n");
 	} else if (gpio_is_valid(apb->clk_en_gpio)) {
 		ret = devm_gpio_request_one(dev, apb->clk_en_gpio,
-				GPIOF_OUT_INIT_LOW, "apb_clk_en");
+					    GPIOF_OUT_INIT_LOW, "apb_clk_en");
 		if (ret) {
 			dev_warn(dev, "Failed requesting APB clock en gpio %d\n",
-					apb->clk_en_gpio);
+				 apb->clk_en_gpio);
 			return ret;
 		}
 	}
@@ -407,7 +408,7 @@ static int apb_ctrl_get_devtree_data(struct platform_device *pdev,
 	apb->spi_en_gpio = of_get_named_gpio(np, "spi-en-gpio", 0);
 	if (apb->spi_en_gpio >= 0) {
 		if (of_property_read_bool(pdev->dev.of_node,
-					"spi-en-active-high"))
+					  "spi-en-active-high"))
 			apb->spi_en_polarity_high = true;
 	}
 

commit 863dbc52e7f0e5acd7b4883f3933543a81c474c7
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Nov 7 14:58:42 2017 +0100

    staging: greybus: Remove redundant license text
    
    Now that the SPDX tag is in all greybus files, that identifies the
    license in a specific and legally-defined manner.  So the extra GPL text
    wording can be removed as it is no longer needed at all.
    
    This is done on a quest to remove the 700+ different ways that files in
    the kernel describe the GPL license text.  And there's unneeded stuff
    like the address (sometimes incorrect) for the FSF which is never
    needed.
    
    No copyright headers or other non-license-description text was removed.
    
    Cc: Vaibhav Hiremath <hvaibhav.linux@gmail.com>
    Reviewed-by: Alex Elder <elder@linaro.org>
    Acked-by: Vaibhav Agarwal <vaibhav.sr@gmail.com>
    Acked-by: David Lin <dtwlin@gmail.com>
    Acked-by: Johan Hovold <johan@kernel.org>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Acked-by: Mark Greer <mgreer@animalcreek.com>
    Acked-by: Rui Miguel Silva <rmfrfs@gmail.com>
    Acked-by: "Bryan O'Donoghue" <pure.logic@nexus-software.ie>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/arche-apb-ctrl.c b/drivers/staging/greybus/arche-apb-ctrl.c
index c6c3d01395ed..b0c66112eb18 100644
--- a/drivers/staging/greybus/arche-apb-ctrl.c
+++ b/drivers/staging/greybus/arche-apb-ctrl.c
@@ -4,8 +4,6 @@
  *
  * Copyright 2014-2015 Google Inc.
  * Copyright 2014-2015 Linaro Ltd.
- *
- * Released under the GPLv2 only.
  */
 
 #include <linux/clk.h>

commit eb50fd3a22c770f36be275295b782f3ea52e3215
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Nov 7 14:58:41 2017 +0100

    staging: greybus: add SPDX identifiers to all greybus driver files
    
    It's good to have SPDX identifiers in all files to make it easier to
    audit the kernel tree for correct licenses.
    
    Update the drivers/staging/greybus files files with the correct SPDX
    license identifier based on the license text in the file itself.  The
    SPDX identifier is a legally binding shorthand, which can be used
    instead of the full boiler plate text.
    
    This work is based on a script and data from Thomas Gleixner, Philippe
    Ombredanne, and Kate Stewart.
    
    Cc: Vaibhav Hiremath <hvaibhav.linux@gmail.com>
    Cc: "Bryan O'Donoghue" <pure.logic@nexus-software.ie>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: Philippe Ombredanne <pombredanne@nexb.com>
    Acked-by: Vaibhav Agarwal <vaibhav.sr@gmail.com>
    Acked-by: David Lin <dtwlin@gmail.com>
    Reviewed-by: Alex Elder <elder@linaro.org>
    Acked-by: Johan Hovold <johan@kernel.org>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Acked-by: Mark Greer <mgreer@animalcreek.com>
    Acked-by: Rui Miguel Silva <rmfrfs@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/arche-apb-ctrl.c b/drivers/staging/greybus/arche-apb-ctrl.c
index 0412f3d06efb..c6c3d01395ed 100644
--- a/drivers/staging/greybus/arche-apb-ctrl.c
+++ b/drivers/staging/greybus/arche-apb-ctrl.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * Arche Platform driver to control APB.
  *

commit 1e029b836108d0b68ba574482604247c97cb4757
Author: Johan Hovold <johan@kernel.org>
Date:   Tue May 16 10:01:38 2017 +0200

    staging: greybus: arche: remove timesync remains
    
    Remove the remaining timesync bits that were left in the arche platform
    driver and which prevented the driver from being compiled.
    
    Fixes: bdfb95c4baab ("staging: greybus: remove timesync protocol support")
    Signed-off-by: Johan Hovold <johan@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/arche-apb-ctrl.c b/drivers/staging/greybus/arche-apb-ctrl.c
index 02243b4fd898..0412f3d06efb 100644
--- a/drivers/staging/greybus/arche-apb-ctrl.c
+++ b/drivers/staging/greybus/arche-apb-ctrl.c
@@ -22,6 +22,8 @@
 #include "arche_platform.h"
 
 
+static void apb_bootret_deassert(struct device *dev);
+
 struct arche_apb_ctrl_drvdata {
 	/* Control GPIO signals to and from AP <=> AP Bridges */
 	int resetn_gpio;
@@ -222,14 +224,7 @@ static void poweroff_seq(struct platform_device *pdev)
 	/* TODO: May have to send an event to SVC about this exit */
 }
 
-void apb_bootret_assert(struct device *dev)
-{
-	struct arche_apb_ctrl_drvdata *apb = dev_get_drvdata(dev);
-
-	gpio_set_value(apb->boot_ret_gpio, 1);
-}
-
-void apb_bootret_deassert(struct device *dev)
+static void apb_bootret_deassert(struct device *dev)
 {
 	struct arche_apb_ctrl_drvdata *apb = dev_get_drvdata(dev);
 

commit 461ab8077d573d4a35529572c774a71e5a898a84
Author: Gioh Kim <gi-oh.kim@profitbricks.com>
Date:   Thu Feb 9 17:30:11 2017 +0100

    staging: greybus: fix "line over 80 characters" coding style issues
    
    This patch fixes only obvious lines.
    There are still more issues.
    
    Signed-off-by: Gioh Kim <gi-oh.kim@profitbricks.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/arche-apb-ctrl.c b/drivers/staging/greybus/arche-apb-ctrl.c
index 17fa29061e5b..02243b4fd898 100644
--- a/drivers/staging/greybus/arche-apb-ctrl.c
+++ b/drivers/staging/greybus/arche-apb-ctrl.c
@@ -168,7 +168,10 @@ static int standby_boot_seq(struct platform_device *pdev)
 	if (apb->init_disabled)
 		return 0;
 
-	/* Even if it is in OFF state, then we do not want to change the state */
+	/*
+	 * Even if it is in OFF state,
+	 * then we do not want to change the state
+	 */
 	if (apb->state == ARCHE_PLATFORM_STATE_STANDBY ||
 			apb->state == ARCHE_PLATFORM_STATE_OFF)
 		return 0;

commit 6da8086375c316c8bddc6c6fdfe62dee513e6ee1
Author: Jérémy Lefaure <jeremy.lefaure@lse.epita.fr>
Date:   Fri Dec 16 19:33:02 2016 -0500

    staging: greybus: arche-apb-ctrl: fix unused warnings on resume/suspend
    
    When CONFIG_PM_SLEEP is disabled, SIMPLE_DEV_PM_OPS does not use
    arche_apb_ctrl_resume and arche_apb_ctrl_suspend functions:
    
    drivers/staging/greybus/arche-apb-ctrl.c:478:12: warning:
    ‘arche_apb_ctrl_resume’ defined but not used [-Wunused-function]
     static int arche_apb_ctrl_resume(struct device *dev)
                ^~~~~~~~~~~~~~~~~~~~~
    drivers/staging/greybus/arche-apb-ctrl.c:464:12: warning:
    ‘arche_apb_ctrl_suspend’ defined but not used [-Wunused-function]
     static int arche_apb_ctrl_suspend(struct device *dev)
                ^~~~~~~~~~~~~~~~~~~~~~
    
    Adding __maybe_unused to the declaration of these functions removes the
    warnings.
    
    Signed-off-by: Jérémy Lefaure <jeremy.lefaure@lse.epita.fr>
    Acked-by: Johan Hovold <johan@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/arche-apb-ctrl.c b/drivers/staging/greybus/arche-apb-ctrl.c
index 3fda0cd6bb42..17fa29061e5b 100644
--- a/drivers/staging/greybus/arche-apb-ctrl.c
+++ b/drivers/staging/greybus/arche-apb-ctrl.c
@@ -461,7 +461,7 @@ static int arche_apb_ctrl_remove(struct platform_device *pdev)
 	return 0;
 }
 
-static int arche_apb_ctrl_suspend(struct device *dev)
+static int __maybe_unused arche_apb_ctrl_suspend(struct device *dev)
 {
 	/*
 	 * If timing profile permits, we may shutdown bridge
@@ -475,7 +475,7 @@ static int arche_apb_ctrl_suspend(struct device *dev)
 	return 0;
 }
 
-static int arche_apb_ctrl_resume(struct device *dev)
+static int __maybe_unused arche_apb_ctrl_resume(struct device *dev)
 {
 	/*
 	 * Atleast for ES2 we have to meet the delay requirement between

commit 1047cc1359a2f502fc7a148dcaf7ebcaba8c62bc
Author: Hisao Tanabe <xtanabe@gmail.com>
Date:   Mon Oct 3 23:45:15 2016 +0900

    staging: greybus: fix block comment
    
    This patch fix the coding style problem of block comment detected by the
    checkpatch.pl.
    
    WARNING: Block comments use a trailing */ on a separate line
    
    Signed-off-by: Hisao Tanabe <xtanabe@gmail.com>
    Acked-by: Johan Hovold <johan@kernel.org>
    Acked-by: Viresh Kumar  <viresh.kumar@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/arche-apb-ctrl.c b/drivers/staging/greybus/arche-apb-ctrl.c
index 103d629043cd..3fda0cd6bb42 100644
--- a/drivers/staging/greybus/arche-apb-ctrl.c
+++ b/drivers/staging/greybus/arche-apb-ctrl.c
@@ -183,7 +183,7 @@ static int standby_boot_seq(struct platform_device *pdev)
 	 * Pasted from WDM spec,
 	 *  - A falling edge on POWEROFF_L is detected (a)
 	 *  - WDM enters standby mode, but no output signals are changed
-	 * */
+	 */
 
 	/* TODO: POWEROFF_L is input to WDM module  */
 	apb->state = ARCHE_PLATFORM_STATE_STANDBY;

commit cb026e398852729cae02b105cf42a1863df78988
Author: Sidhant Gupta <guptasidhant004@gmail.com>
Date:   Mon Oct 3 16:21:09 2016 +0530

    staging: greybus: Fix a commit coding style issue.
    
    Fixes a comment coding style warning by adding 2 blank lines. Issue
    found by checkpatch.
    
    Signed-off-by: Sidhant Gupta <guptasidhant004@gmail.com>
    Acked-by: Johan Hovold <johan@kernel.org>
    Reviewed-by: Vaishali Thakkar <vaishali.thakkar@oracle.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/arche-apb-ctrl.c b/drivers/staging/greybus/arche-apb-ctrl.c
index 70323aa11f24..103d629043cd 100644
--- a/drivers/staging/greybus/arche-apb-ctrl.c
+++ b/drivers/staging/greybus/arche-apb-ctrl.c
@@ -285,8 +285,10 @@ static ssize_t state_store(struct device *dev,
 		if (apb->state == ARCHE_PLATFORM_STATE_FW_FLASHING)
 			return count;
 
-		/* First we want to make sure we power off everything
-		 * and then enter FW flashing state */
+		/*
+		 * First we want to make sure we power off everything
+		 * and then enter FW flashing state
+		 */
 		poweroff_seq(pdev);
 		ret = fw_flashing_seq(pdev);
 	} else {

commit 5c925fe2a496da4849f1f874b9fa54cad7f2386c
Author: Eva Rachel Retuya <eraretuya@gmail.com>
Date:   Thu Sep 22 23:33:33 2016 +0800

    staging: greybus: arche-apb-ctrl: declare struct of_device_id as const
    
    Declare the 'arche_apb_ctrl_of_match' array as const. This array is only stored
    in the .of_match_table field of a device_driver structure, which is declared as
    const. This addresses the checkpatch warning:
    
    WARNING: struct of_device_id should be normally const
    
    Signed-off-by: Eva Rachel Retuya <eraretuya@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/arche-apb-ctrl.c b/drivers/staging/greybus/arche-apb-ctrl.c
index 59d9d422cf04..70323aa11f24 100644
--- a/drivers/staging/greybus/arche-apb-ctrl.c
+++ b/drivers/staging/greybus/arche-apb-ctrl.c
@@ -495,7 +495,7 @@ static void arche_apb_ctrl_shutdown(struct platform_device *pdev)
 static SIMPLE_DEV_PM_OPS(arche_apb_ctrl_pm_ops, arche_apb_ctrl_suspend,
 			 arche_apb_ctrl_resume);
 
-static struct of_device_id arche_apb_ctrl_of_match[] = {
+static const struct of_device_id arche_apb_ctrl_of_match[] = {
 	{ .compatible = "usbffff,2", },
 	{ },
 };

commit 921dbe52b40b2573d9a0e8337c768930bef25fb4
Author: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
Date:   Thu Jul 28 13:47:37 2016 +0530

    greybus: arche-platform: Add support for SPI bus sharing for Mihi
    
    In case of Mihi, SPI bus is shared between APB1 and APB2
    SPI ROMs, so their FW flashing must be sequential and
    arche-platform driver should make sure that they are mutual
    exclusive in nature.
    
    So this patch adds certain restrictions to the user of the
    arche-platform driver,
    
     - User can no longer flash APB1 and APB2 SPI ROM in parallel
     - SPI bus becomes an resource, so user must claim it by moving
       respective APB device into FW_FLASHING mode and release it
       by exiting FW_FLASHING mode. User can exit FW_FLASHING mode by
       switching to any other modes (ACTIVE, OFF, STANDBY).
     - If APB1 is in FW_FLASHING mode, APB2 can no longer enter into
       FW_FLASHING mode. User will get -EBUSY.
    
    Having said that, while APB1 is into FW_FLASHING mode,
    APB2 can independently boot from its own SPI ROM.
    
    Testing Done: Tested by simulating usecase on EVT2.
     - Made sure that APB1 and APB2 FW_FLASHING mode is mutual exclusive
       in nature. Confirmed that an attempt on second device return -EBUSY.
     - Added simulating code, where printed state of dummy gpio for
       spi-en and verified that it shows right pin status for both APBs
    
    Signed-off-by: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/arche-apb-ctrl.c b/drivers/staging/greybus/arche-apb-ctrl.c
index 049d496a41f4..59d9d422cf04 100644
--- a/drivers/staging/greybus/arche-apb-ctrl.c
+++ b/drivers/staging/greybus/arche-apb-ctrl.c
@@ -42,6 +42,10 @@ struct arche_apb_ctrl_drvdata {
 
 	struct pinctrl *pinctrl;
 	struct pinctrl_state *pin_default;
+
+	/* V2: SPI Bus control  */
+	int spi_en_gpio;
+	bool spi_en_polarity_high;
 };
 
 /*
@@ -73,6 +77,10 @@ static int coldboot_seq(struct platform_device *pdev)
 	/* Hold APB in reset state */
 	assert_reset(apb->resetn_gpio);
 
+	if (apb->state == ARCHE_PLATFORM_STATE_FW_FLASHING &&
+			gpio_is_valid(apb->spi_en_gpio))
+		devm_gpio_free(dev, apb->spi_en_gpio);
+
 	/* Enable power to APB */
 	if (!IS_ERR(apb->vcore)) {
 		ret = regulator_enable(apb->vcore);
@@ -128,6 +136,23 @@ static int fw_flashing_seq(struct platform_device *pdev)
 		return ret;
 	}
 
+	if (gpio_is_valid(apb->spi_en_gpio)) {
+		unsigned long flags;
+
+		if (apb->spi_en_polarity_high)
+			flags = GPIOF_OUT_INIT_HIGH;
+		else
+			flags = GPIOF_OUT_INIT_LOW;
+
+		ret = devm_gpio_request_one(dev, apb->spi_en_gpio,
+				flags, "apb_spi_en");
+		if (ret) {
+			dev_err(dev, "Failed requesting SPI bus en gpio %d\n",
+				apb->spi_en_gpio);
+			return ret;
+		}
+	}
+
 	/* for flashing device should be in reset state */
 	assert_reset(apb->resetn_gpio);
 	apb->state = ARCHE_PLATFORM_STATE_FW_FLASHING;
@@ -137,6 +162,7 @@ static int fw_flashing_seq(struct platform_device *pdev)
 
 static int standby_boot_seq(struct platform_device *pdev)
 {
+	struct device *dev = &pdev->dev;
 	struct arche_apb_ctrl_drvdata *apb = platform_get_drvdata(pdev);
 
 	if (apb->init_disabled)
@@ -147,6 +173,10 @@ static int standby_boot_seq(struct platform_device *pdev)
 			apb->state == ARCHE_PLATFORM_STATE_OFF)
 		return 0;
 
+	if (apb->state == ARCHE_PLATFORM_STATE_FW_FLASHING &&
+			gpio_is_valid(apb->spi_en_gpio))
+		devm_gpio_free(dev, apb->spi_en_gpio);
+
 	/*
 	 * As per WDM spec, do nothing
 	 *
@@ -162,11 +192,16 @@ static int standby_boot_seq(struct platform_device *pdev)
 
 static void poweroff_seq(struct platform_device *pdev)
 {
+	struct device *dev = &pdev->dev;
 	struct arche_apb_ctrl_drvdata *apb = platform_get_drvdata(pdev);
 
 	if (apb->init_disabled || apb->state == ARCHE_PLATFORM_STATE_OFF)
 		return;
 
+	if (apb->state == ARCHE_PLATFORM_STATE_FW_FLASHING &&
+			gpio_is_valid(apb->spi_en_gpio))
+		devm_gpio_free(dev, apb->spi_en_gpio);
+
 	/* disable the clock */
 	if (gpio_is_valid(apb->clk_en_gpio))
 		gpio_set_value(apb->clk_en_gpio, 0);
@@ -369,6 +404,14 @@ static int apb_ctrl_get_devtree_data(struct platform_device *pdev,
 		return PTR_ERR(apb->pin_default);
 	}
 
+	/* Only applicable for platform >= V2 */
+	apb->spi_en_gpio = of_get_named_gpio(np, "spi-en-gpio", 0);
+	if (apb->spi_en_gpio >= 0) {
+		if (of_property_read_bool(pdev->dev.of_node,
+					"spi-en-active-high"))
+			apb->spi_en_polarity_high = true;
+	}
+
 	return 0;
 }
 

commit 20de72f5dee480e72d82d702e709a07217c0900f
Author: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
Date:   Thu Jul 28 13:56:44 2016 +0530

    greybus: arche-apb-ctrl: Rename ara,init-disable => arche,init-disable
    
    Inline with other properties used for arche-platform driver,
    rename ara,init-disable => arche,init-disable.
    
    Testing Done: Boot tested on EVT2 platform
    
    Signed-off-by: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/arche-apb-ctrl.c b/drivers/staging/greybus/arche-apb-ctrl.c
index cae56fc0a6e5..049d496a41f4 100644
--- a/drivers/staging/greybus/arche-apb-ctrl.c
+++ b/drivers/staging/greybus/arche-apb-ctrl.c
@@ -391,7 +391,7 @@ static int arche_apb_ctrl_probe(struct platform_device *pdev)
 	/* Initially set APB to OFF state */
 	apb->state = ARCHE_PLATFORM_STATE_OFF;
 	/* Check whether device needs to be enabled on boot */
-	if (of_property_read_bool(pdev->dev.of_node, "ara,init-disable"))
+	if (of_property_read_bool(pdev->dev.of_node, "arche,init-disable"))
 		apb->init_disabled = true;
 
 	platform_set_drvdata(pdev, apb);

commit 1f77b363bef417e28d8556a11c9a82f3e6cf24f0
Author: David Lin <dtwlin@google.com>
Date:   Tue Jul 12 17:41:21 2016 -0700

    greybus: hd: arche-platform: implement greybus shutdown
    
    Implement platform driver shutdown callback to perform proper greybus
    shutdown so that the userspace unipro_shutdown service that shuts down
    the APB/SVC abruptly can be removed. The shutdown callback in
    arche-platform will first remove SVC so that all the Interface can be
    Deactivated in a sequence according to the spec before powering off the
    APB:
    
    Before:
     -> Arche/APB power off
     -> SoC power off
    
    After this patch:
     -> HD shutdown
         -> SVC shutdown
             -> Module shutdown
                 -> Interface shutdown
                     -> Bundle shutdown
     -> Arche/APB power off
     -> SoC power off
    
    Testing Done:
     - Observe all Interfaces are deactivated in the log during shutdown
     - Measure power off current and make sure no regression
    
    Signed-off-by: David Lin <dtwlin@google.com>
    Reviewed-by: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
    Reviewed-by: Johan Hovold <johan@hovoldconsulting.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/arche-apb-ctrl.c b/drivers/staging/greybus/arche-apb-ctrl.c
index fce6a187ecfe..cae56fc0a6e5 100644
--- a/drivers/staging/greybus/arche-apb-ctrl.c
+++ b/drivers/staging/greybus/arche-apb-ctrl.c
@@ -444,6 +444,11 @@ static int arche_apb_ctrl_resume(struct device *dev)
 	return 0;
 }
 
+static void arche_apb_ctrl_shutdown(struct platform_device *pdev)
+{
+	apb_ctrl_poweroff(&pdev->dev);
+}
+
 static SIMPLE_DEV_PM_OPS(arche_apb_ctrl_pm_ops, arche_apb_ctrl_suspend,
 			 arche_apb_ctrl_resume);
 
@@ -455,6 +460,7 @@ static struct of_device_id arche_apb_ctrl_of_match[] = {
 static struct platform_driver arche_apb_ctrl_device_driver = {
 	.probe		= arche_apb_ctrl_probe,
 	.remove		= arche_apb_ctrl_remove,
+	.shutdown	= arche_apb_ctrl_shutdown,
 	.driver		= {
 		.name	= "arche-apb-ctrl",
 		.pm	= &arche_apb_ctrl_pm_ops,

commit 970dc85bd95d931def5926ae81b5aa84ef14fb7c
Author: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
Date:   Sun Jun 5 14:03:26 2016 +0100

    greybus: timesync: Add timesync core driver
    
    This patch adds the core timesync functionality.
    
    0. arche-platform.c/arche-apb-ctrl.c
       Modifies the platform layer to hook the incoming TIME_SYNC signal up to
       the timesync strobe IRQ handler. If the arche-platform driver can't
       satisfy the request for the wake-detect line, it will return -EAGAIN and
       the calling work-queue must reschedule the attempt to get exclusive
       access to the wake-detect pin logic. A private data field is added to
       the arche-platform driver to enable passing of a timesync pointer to the
       ISR responsible for synchronizing time.
    
    1. timesync.c
       A new file added which contains all of the logic associated with sending
       greybus commands to SVC, APBx or Interfaces to enable, disable and
       disseminate timing information.
    
    2. timesync_platform.c
       Any platform/arch specific code goes into timesync_platform.c.
       Originally the idea was to keep the x86 and ARM arch dependencies in a
       timesync_platform_arch.c file - however with further refinement that's
       currently not necessary however just-in-case it becomes necessary to
       resuscitate arch or platform specific methods for accessing timer
       resources that access shouldn't be part of the core timesync.c logic and
       so for the moment we access these timer resources through a thin access
       layer in timesync_platform.c. Expect this to go away long term ideally.
    
    Signed-off-by: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
    Acked-by: Alex Elder <elder@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/arche-apb-ctrl.c b/drivers/staging/greybus/arche-apb-ctrl.c
index a9d78a85939a..fce6a187ecfe 100644
--- a/drivers/staging/greybus/arche-apb-ctrl.c
+++ b/drivers/staging/greybus/arche-apb-ctrl.c
@@ -90,7 +90,7 @@ static int coldboot_seq(struct platform_device *pdev)
 		}
 	}
 
-	gpio_set_value(apb->boot_ret_gpio, 0);
+	apb_bootret_deassert(dev);
 
 	/* On DB3 clock was not mandatory */
 	if (gpio_is_valid(apb->clk_en_gpio))
@@ -184,6 +184,20 @@ static void poweroff_seq(struct platform_device *pdev)
 	/* TODO: May have to send an event to SVC about this exit */
 }
 
+void apb_bootret_assert(struct device *dev)
+{
+	struct arche_apb_ctrl_drvdata *apb = dev_get_drvdata(dev);
+
+	gpio_set_value(apb->boot_ret_gpio, 1);
+}
+
+void apb_bootret_deassert(struct device *dev)
+{
+	struct arche_apb_ctrl_drvdata *apb = dev_get_drvdata(dev);
+
+	gpio_set_value(apb->boot_ret_gpio, 0);
+}
+
 int apb_ctrl_coldboot(struct device *dev)
 {
 	return coldboot_seq(to_platform_device(dev));

commit 7b62b61c752a4700ecf11d63a7ec40aeb3cee66c
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Wed Apr 20 11:48:37 2016 +0530

    greybus: arche-ctrl: Don't expose driver internals to arche-platform driver
    
    We have chosen the *ugly* way of registering two platform drivers from
    the module_init() of only one of them, so that we can avoid having two
    separate modules for them.
    
    But we should still be doing this in a sane way. There is no need to
    expose internals of arche-ctrl to arche-platform, like PM-ops, probe,
    resume, id-table, etc. Just expose an init and a exit callback.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Reviewed-by: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/arche-apb-ctrl.c b/drivers/staging/greybus/arche-apb-ctrl.c
index 3a092a5b7fb8..a9d78a85939a 100644
--- a/drivers/staging/greybus/arche-apb-ctrl.c
+++ b/drivers/staging/greybus/arche-apb-ctrl.c
@@ -358,7 +358,7 @@ static int apb_ctrl_get_devtree_data(struct platform_device *pdev,
 	return 0;
 }
 
-int arche_apb_ctrl_probe(struct platform_device *pdev)
+static int arche_apb_ctrl_probe(struct platform_device *pdev)
 {
 	int ret;
 	struct arche_apb_ctrl_drvdata *apb;
@@ -393,7 +393,7 @@ int arche_apb_ctrl_probe(struct platform_device *pdev)
 	return 0;
 }
 
-int arche_apb_ctrl_remove(struct platform_device *pdev)
+static int arche_apb_ctrl_remove(struct platform_device *pdev)
 {
 	device_remove_file(&pdev->dev, &dev_attr_state);
 	poweroff_seq(pdev);
@@ -430,6 +430,30 @@ static int arche_apb_ctrl_resume(struct device *dev)
 	return 0;
 }
 
-SIMPLE_DEV_PM_OPS(arche_apb_ctrl_pm_ops,
-		  arche_apb_ctrl_suspend,
-		  arche_apb_ctrl_resume);
+static SIMPLE_DEV_PM_OPS(arche_apb_ctrl_pm_ops, arche_apb_ctrl_suspend,
+			 arche_apb_ctrl_resume);
+
+static struct of_device_id arche_apb_ctrl_of_match[] = {
+	{ .compatible = "usbffff,2", },
+	{ },
+};
+
+static struct platform_driver arche_apb_ctrl_device_driver = {
+	.probe		= arche_apb_ctrl_probe,
+	.remove		= arche_apb_ctrl_remove,
+	.driver		= {
+		.name	= "arche-apb-ctrl",
+		.pm	= &arche_apb_ctrl_pm_ops,
+		.of_match_table = arche_apb_ctrl_of_match,
+	}
+};
+
+int __init arche_apb_init(void)
+{
+	return platform_driver_register(&arche_apb_ctrl_device_driver);
+}
+
+void __exit arche_apb_exit(void)
+{
+	platform_driver_unregister(&arche_apb_ctrl_device_driver);
+}

commit 7fe9301422444a1fca71bb8c4c0673fb44eb0f2d
Author: David Lin <dtwlin@google.com>
Date:   Mon Mar 7 21:52:54 2016 -0800

    greybus: arche-platform: fix incorrect gpio variable type
    
    GPIO number obtained from of_get_named_gpio() should be signed to allow
    error handling.
    
    Testing Done:
    Built & booted on EVT1.5
    
    Signed-off-by: David Lin <dtwlin@google.com>
    Reviewed-by: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/arche-apb-ctrl.c b/drivers/staging/greybus/arche-apb-ctrl.c
index 55806bdf5898..3a092a5b7fb8 100644
--- a/drivers/staging/greybus/arche-apb-ctrl.c
+++ b/drivers/staging/greybus/arche-apb-ctrl.c
@@ -37,7 +37,7 @@ struct arche_apb_ctrl_drvdata {
 	struct regulator *vcore;
 	struct regulator *vio;
 
-	unsigned int clk_en_gpio;
+	int clk_en_gpio;
 	struct clk *clk;
 
 	struct pinctrl *pinctrl;

commit 037a4028be8d6551dc226fc48c0c16063774e649
Author: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
Date:   Thu Feb 25 04:37:33 2016 +0530

    greybus: arche-apb-ctrl: Remove extra delay in APB reset
    
    With synchronization between SVC <=> AP over wake/detect line to
    bring APB's out of reset, we do not need any extra delays now.
    So remove it.
    
    Testing Done: Tested for DB3.5 and EVT1.2 platform.
    
    Signed-off-by: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
    Reviewed-by: Michael Scott <michael.scott@linaro.org>
    Tested-by: Michael Scott <michael.scott@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/arche-apb-ctrl.c b/drivers/staging/greybus/arche-apb-ctrl.c
index c2f0776f04f4..55806bdf5898 100644
--- a/drivers/staging/greybus/arche-apb-ctrl.c
+++ b/drivers/staging/greybus/arche-apb-ctrl.c
@@ -50,7 +50,6 @@ struct arche_apb_ctrl_drvdata {
 static inline void deassert_reset(unsigned int gpio)
 {
 	gpio_set_value(gpio, 1);
-	msleep(500);
 }
 
 static inline void assert_reset(unsigned int gpio)

commit c5e7cbaf3ab8842278a9162dfaf04464ce21f0e4
Author: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
Date:   Mon Feb 22 17:27:26 2016 +0530

    greybus: arche-apb-ctrl: Return immediately if in same state from state change fns
    
    Have a check inside all individual operational state change functions
    to check whether device is in same state, and if yes, then return
    immediately.
    
    Testing Done: Tested on DB3.5 platform.
    
    Signed-off-by: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/arche-apb-ctrl.c b/drivers/staging/greybus/arche-apb-ctrl.c
index 3086306f04fb..c2f0776f04f4 100644
--- a/drivers/staging/greybus/arche-apb-ctrl.c
+++ b/drivers/staging/greybus/arche-apb-ctrl.c
@@ -67,7 +67,8 @@ static int coldboot_seq(struct platform_device *pdev)
 	struct arche_apb_ctrl_drvdata *apb = platform_get_drvdata(pdev);
 	int ret;
 
-	if (apb->init_disabled)
+	if (apb->init_disabled ||
+			apb->state == ARCHE_PLATFORM_STATE_ACTIVE)
 		return 0;
 
 	/* Hold APB in reset state */
@@ -112,7 +113,8 @@ static int fw_flashing_seq(struct platform_device *pdev)
 	struct arche_apb_ctrl_drvdata *apb = platform_get_drvdata(pdev);
 	int ret;
 
-	if (apb->init_disabled)
+	if (apb->init_disabled ||
+			apb->state == ARCHE_PLATFORM_STATE_FW_FLASHING)
 		return 0;
 
 	ret = regulator_enable(apb->vcore);
@@ -141,8 +143,9 @@ static int standby_boot_seq(struct platform_device *pdev)
 	if (apb->init_disabled)
 		return 0;
 
-	/* If it is in OFF state, then we do not want to change the state */
-	if (apb->state == ARCHE_PLATFORM_STATE_OFF)
+	/* Even if it is in OFF state, then we do not want to change the state */
+	if (apb->state == ARCHE_PLATFORM_STATE_STANDBY ||
+			apb->state == ARCHE_PLATFORM_STATE_OFF)
 		return 0;
 
 	/*
@@ -162,7 +165,7 @@ static void poweroff_seq(struct platform_device *pdev)
 {
 	struct arche_apb_ctrl_drvdata *apb = platform_get_drvdata(pdev);
 
-	if (apb->init_disabled)
+	if (apb->init_disabled || apb->state == ARCHE_PLATFORM_STATE_OFF)
 		return;
 
 	/* disable the clock */

commit ee97e24ac63510c5836ac71ce88c9f61e265ee84
Author: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
Date:   Wed Feb 17 01:27:52 2016 +0530

    greybus: arche-apb-ctrl: Do not coldboot APBs in probe
    
    Since parent driver (SVC) is controlling APBs directly, we do not
    need to bringup APBs in its own probe.
    
    Testing Done: Tested on EVT1.2.
    
    Signed-off-by: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
    Reviewed-by: Michael Scott <michael.scott@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/arche-apb-ctrl.c b/drivers/staging/greybus/arche-apb-ctrl.c
index b888da376b21..3086306f04fb 100644
--- a/drivers/staging/greybus/arche-apb-ctrl.c
+++ b/drivers/staging/greybus/arche-apb-ctrl.c
@@ -387,15 +387,6 @@ int arche_apb_ctrl_probe(struct platform_device *pdev)
 		return ret;
 	}
 
-	ret = coldboot_seq(pdev);
-	if (ret) {
-		dev_err(dev, "failed to set init state of control signal %d\n",
-				ret);
-		device_remove_file(dev, &dev_attr_state);
-		platform_set_drvdata(pdev, NULL);
-		return ret;
-	}
-
 	dev_info(&pdev->dev, "Device registered successfully\n");
 	return 0;
 }

commit bc8eadd46c05280f7ddcf2ab7cf97d1cd15a578c
Author: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
Date:   Sat Feb 13 02:04:19 2016 +0530

    greybus: arche-apb-ctrl: Do not export any gpios
    
    With addition of operational state in driver, user/developer
    can switch to FW flashing state through sysfs. So no need to
    export any gpios to userspace now.
    
    Testing Done: Tested on EVT1.2 and DB3.5 platform
    
    Signed-off-by: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/arche-apb-ctrl.c b/drivers/staging/greybus/arche-apb-ctrl.c
index e1df998ca877..b888da376b21 100644
--- a/drivers/staging/greybus/arche-apb-ctrl.c
+++ b/drivers/staging/greybus/arche-apb-ctrl.c
@@ -58,17 +58,6 @@ static inline void assert_reset(unsigned int gpio)
 	gpio_set_value(gpio, 0);
 }
 
-/* Export gpio's to user space */
-static void export_gpios(struct arche_apb_ctrl_drvdata *apb)
-{
-	gpio_export(apb->resetn_gpio, false);
-}
-
-static void unexport_gpios(struct arche_apb_ctrl_drvdata *apb)
-{
-	gpio_unexport(apb->resetn_gpio);
-}
-
 /*
  * Note: Please do not modify the below sequence, as it is as per the spec
  */
@@ -407,20 +396,15 @@ int arche_apb_ctrl_probe(struct platform_device *pdev)
 		return ret;
 	}
 
-	export_gpios(apb);
-
 	dev_info(&pdev->dev, "Device registered successfully\n");
 	return 0;
 }
 
 int arche_apb_ctrl_remove(struct platform_device *pdev)
 {
-	struct arche_apb_ctrl_drvdata *apb = platform_get_drvdata(pdev);
-
 	device_remove_file(&pdev->dev, &dev_attr_state);
 	poweroff_seq(pdev);
 	platform_set_drvdata(pdev, NULL);
-	unexport_gpios(apb);
 
 	return 0;
 }

commit 65fd5a5018c8c5b7ddf14dffa75474b3a9040851
Author: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
Date:   Sat Feb 13 02:04:16 2016 +0530

    greybus: arche-apb-ctrl: Export operational fns from driver
    
    In order to use single wake/detect line for both APB's we need to have
    access to APB operational functions to parent/SVC driver.
    So export coldboot, standby_boot, fw_flashing and poweroff operation
    functions from the driver.
    
    Testing Done: Tested on EVT1.2 and DB3.5 platform
    
    Signed-off-by: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/arche-apb-ctrl.c b/drivers/staging/greybus/arche-apb-ctrl.c
index 50d27a626ec6..e1df998ca877 100644
--- a/drivers/staging/greybus/arche-apb-ctrl.c
+++ b/drivers/staging/greybus/arche-apb-ctrl.c
@@ -193,6 +193,26 @@ static void poweroff_seq(struct platform_device *pdev)
 	/* TODO: May have to send an event to SVC about this exit */
 }
 
+int apb_ctrl_coldboot(struct device *dev)
+{
+	return coldboot_seq(to_platform_device(dev));
+}
+
+int apb_ctrl_fw_flashing(struct device *dev)
+{
+	return fw_flashing_seq(to_platform_device(dev));
+}
+
+int apb_ctrl_standby_boot(struct device *dev)
+{
+	return standby_boot_seq(to_platform_device(dev));
+}
+
+void apb_ctrl_poweroff(struct device *dev)
+{
+	poweroff_seq(to_platform_device(dev));
+}
+
 static ssize_t state_store(struct device *dev,
 		struct device_attribute *attr, const char *buf, size_t count)
 {

commit 80a057aa6c170403261f8d1d2ce435d3668848f6
Author: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
Date:   Sat Feb 13 02:04:15 2016 +0530

    greybus: arche-apb-ctrl: Rename internal operational state fns
    
    This is preparation for enabling export set of operational fns
    to parent driver.
    So it is important to differentiate internal ops function against
    externally accessed (from parent).
    
    Testing Done: Tested on EVT1.2 and DB3.5 platform.
    
    Signed-off-by: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/arche-apb-ctrl.c b/drivers/staging/greybus/arche-apb-ctrl.c
index 04ba8365f7bf..50d27a626ec6 100644
--- a/drivers/staging/greybus/arche-apb-ctrl.c
+++ b/drivers/staging/greybus/arche-apb-ctrl.c
@@ -72,7 +72,7 @@ static void unexport_gpios(struct arche_apb_ctrl_drvdata *apb)
 /*
  * Note: Please do not modify the below sequence, as it is as per the spec
  */
-static int apb_ctrl_coldboot_seq(struct platform_device *pdev)
+static int coldboot_seq(struct platform_device *pdev)
 {
 	struct device *dev = &pdev->dev;
 	struct arche_apb_ctrl_drvdata *apb = platform_get_drvdata(pdev);
@@ -117,7 +117,7 @@ static int apb_ctrl_coldboot_seq(struct platform_device *pdev)
 	return 0;
 }
 
-static int apb_ctrl_fw_flashing_seq(struct platform_device *pdev)
+static int fw_flashing_seq(struct platform_device *pdev)
 {
 	struct device *dev = &pdev->dev;
 	struct arche_apb_ctrl_drvdata *apb = platform_get_drvdata(pdev);
@@ -145,7 +145,7 @@ static int apb_ctrl_fw_flashing_seq(struct platform_device *pdev)
 	return 0;
 }
 
-static int apb_ctrl_standby_boot_seq(struct platform_device *pdev)
+static int standby_boot_seq(struct platform_device *pdev)
 {
 	struct arche_apb_ctrl_drvdata *apb = platform_get_drvdata(pdev);
 
@@ -169,7 +169,7 @@ static int apb_ctrl_standby_boot_seq(struct platform_device *pdev)
 	return 0;
 }
 
-static void apb_ctrl_poweroff_seq(struct platform_device *pdev)
+static void poweroff_seq(struct platform_device *pdev)
 {
 	struct arche_apb_ctrl_drvdata *apb = platform_get_drvdata(pdev);
 
@@ -205,30 +205,30 @@ static ssize_t state_store(struct device *dev,
 		if (apb->state == ARCHE_PLATFORM_STATE_OFF)
 			return count;
 
-		apb_ctrl_poweroff_seq(pdev);
+		poweroff_seq(pdev);
 	} else if (sysfs_streq(buf, "active")) {
 		if (apb->state == ARCHE_PLATFORM_STATE_ACTIVE)
 			return count;
 
-		apb_ctrl_poweroff_seq(pdev);
+		poweroff_seq(pdev);
 		is_disabled = apb->init_disabled;
 		apb->init_disabled = false;
-		ret = apb_ctrl_coldboot_seq(pdev);
+		ret = coldboot_seq(pdev);
 		if (ret)
 			apb->init_disabled = is_disabled;
 	} else if (sysfs_streq(buf, "standby")) {
 		if (apb->state == ARCHE_PLATFORM_STATE_STANDBY)
 			return count;
 
-		ret = apb_ctrl_standby_boot_seq(pdev);
+		ret = standby_boot_seq(pdev);
 	} else if (sysfs_streq(buf, "fw_flashing")) {
 		if (apb->state == ARCHE_PLATFORM_STATE_FW_FLASHING)
 			return count;
 
 		/* First we want to make sure we power off everything
 		 * and then enter FW flashing state */
-		apb_ctrl_poweroff_seq(pdev);
-		ret = apb_ctrl_fw_flashing_seq(pdev);
+		poweroff_seq(pdev);
+		ret = fw_flashing_seq(pdev);
 	} else {
 		dev_err(dev, "unknown state\n");
 		ret = -EINVAL;
@@ -378,7 +378,7 @@ int arche_apb_ctrl_probe(struct platform_device *pdev)
 		return ret;
 	}
 
-	ret = apb_ctrl_coldboot_seq(pdev);
+	ret = coldboot_seq(pdev);
 	if (ret) {
 		dev_err(dev, "failed to set init state of control signal %d\n",
 				ret);
@@ -398,7 +398,7 @@ int arche_apb_ctrl_remove(struct platform_device *pdev)
 	struct arche_apb_ctrl_drvdata *apb = platform_get_drvdata(pdev);
 
 	device_remove_file(&pdev->dev, &dev_attr_state);
-	apb_ctrl_poweroff_seq(pdev);
+	poweroff_seq(pdev);
 	platform_set_drvdata(pdev, NULL);
 	unexport_gpios(apb);
 

commit af3aae10f16f05acba27294bc1ae234f3cb61a61
Author: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
Date:   Sat Feb 13 02:04:14 2016 +0530

    greybus: arche-apb-ctrl: Introduce ara,init-disable property for APB
    
    New DT property "ara,init-disable" will allow user to disable
    APB1 or APB2 during boot and enable it only when needed through
    command prompt via sysfs interface.
    
     - To disable APB2 during boot, specify "ara,init-disable" property in
       respective APB node.
    
     - How to check the state
       # cat /sys/devices/arche_platform.*/apb*/state
    
       It should be 'off', if 'ara,init-disable' enabled in DT.
    
     - During runtime if user/developer desired to enable APB2 (strictly and
       only for development purpose) then respective APB can be enabled
       through,
    
       # echo active > /sys/devices/arche_platform.*/apb*/state
    
    Note:
      - If APB device is in 'off,disabled' state, then no state transitions
        are permitted.
      - User/developer must first activate APB device
    
        # echo active > /sys/devices/arche_platform.*/apb*/state
    
        This will clear the 'init-disable' flag and allow state transition
        from here onwards.
        Note that, 'off,disabled' is only indicative state and is only
        applicable during init/boot.
    
    Testing Done: Tested on EVT1.2 and DB3.5 platform
    
    Signed-off-by: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/arche-apb-ctrl.c b/drivers/staging/greybus/arche-apb-ctrl.c
index e4fd34ddf465..04ba8365f7bf 100644
--- a/drivers/staging/greybus/arche-apb-ctrl.c
+++ b/drivers/staging/greybus/arche-apb-ctrl.c
@@ -32,6 +32,7 @@ struct arche_apb_ctrl_drvdata {
 	int pwrdn_gpio;
 
 	enum arche_platform_state state;
+	bool init_disabled;
 
 	struct regulator *vcore;
 	struct regulator *vio;
@@ -77,6 +78,9 @@ static int apb_ctrl_coldboot_seq(struct platform_device *pdev)
 	struct arche_apb_ctrl_drvdata *apb = platform_get_drvdata(pdev);
 	int ret;
 
+	if (apb->init_disabled)
+		return 0;
+
 	/* Hold APB in reset state */
 	assert_reset(apb->resetn_gpio);
 
@@ -119,6 +123,9 @@ static int apb_ctrl_fw_flashing_seq(struct platform_device *pdev)
 	struct arche_apb_ctrl_drvdata *apb = platform_get_drvdata(pdev);
 	int ret;
 
+	if (apb->init_disabled)
+		return 0;
+
 	ret = regulator_enable(apb->vcore);
 	if (ret) {
 		dev_err(dev, "failed to enable core regulator\n");
@@ -142,6 +149,9 @@ static int apb_ctrl_standby_boot_seq(struct platform_device *pdev)
 {
 	struct arche_apb_ctrl_drvdata *apb = platform_get_drvdata(pdev);
 
+	if (apb->init_disabled)
+		return 0;
+
 	/* If it is in OFF state, then we do not want to change the state */
 	if (apb->state == ARCHE_PLATFORM_STATE_OFF)
 		return 0;
@@ -163,6 +173,9 @@ static void apb_ctrl_poweroff_seq(struct platform_device *pdev)
 {
 	struct arche_apb_ctrl_drvdata *apb = platform_get_drvdata(pdev);
 
+	if (apb->init_disabled)
+		return;
+
 	/* disable the clock */
 	if (gpio_is_valid(apb->clk_en_gpio))
 		gpio_set_value(apb->clk_en_gpio, 0);
@@ -186,6 +199,7 @@ static ssize_t state_store(struct device *dev,
 	struct platform_device *pdev = to_platform_device(dev);
 	struct arche_apb_ctrl_drvdata *apb = platform_get_drvdata(pdev);
 	int ret = 0;
+	bool is_disabled;
 
 	if (sysfs_streq(buf, "off")) {
 		if (apb->state == ARCHE_PLATFORM_STATE_OFF)
@@ -197,7 +211,11 @@ static ssize_t state_store(struct device *dev,
 			return count;
 
 		apb_ctrl_poweroff_seq(pdev);
+		is_disabled = apb->init_disabled;
+		apb->init_disabled = false;
 		ret = apb_ctrl_coldboot_seq(pdev);
+		if (ret)
+			apb->init_disabled = is_disabled;
 	} else if (sysfs_streq(buf, "standby")) {
 		if (apb->state == ARCHE_PLATFORM_STATE_STANDBY)
 			return count;
@@ -226,7 +244,8 @@ static ssize_t state_show(struct device *dev,
 
 	switch (apb->state) {
 	case ARCHE_PLATFORM_STATE_OFF:
-		return sprintf(buf, "off\n");
+		return sprintf(buf, "off%s\n",
+				apb->init_disabled ? ",disabled" : "");
 	case ARCHE_PLATFORM_STATE_ACTIVE:
 		return sprintf(buf, "active\n");
 	case ARCHE_PLATFORM_STATE_STANDBY:
@@ -346,6 +365,9 @@ int arche_apb_ctrl_probe(struct platform_device *pdev)
 
 	/* Initially set APB to OFF state */
 	apb->state = ARCHE_PLATFORM_STATE_OFF;
+	/* Check whether device needs to be enabled on boot */
+	if (of_property_read_bool(pdev->dev.of_node, "ara,init-disable"))
+		apb->init_disabled = true;
 
 	platform_set_drvdata(pdev, apb);
 

commit 33d76291073dd9408055a23cd96a23c375944377
Author: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
Date:   Sat Feb 13 02:04:13 2016 +0530

    greybus: arche-apb-ctrl: Add sysfs to allow user to change state
    
    This patch introduces sysfs interface for the user space to enable
    state change of the driver. Driver supports below operational
    states,
    
     - off
     - active
     - standby
     - fw_flashing
    
    To see the current state
    
    i # cat /sys/devices/arche_platform.*/apb*/state
    
    And to change the state
     # echo [off/active/standby/fw_flashing] > /sys/devices/arche_platform.*/apb*/state
    
    Testing Done: Tested on EVT1.2 and DB3.5 platform
    
    Signed-off-by: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/arche-apb-ctrl.c b/drivers/staging/greybus/arche-apb-ctrl.c
index 8f6f0962421e..e4fd34ddf465 100644
--- a/drivers/staging/greybus/arche-apb-ctrl.c
+++ b/drivers/staging/greybus/arche-apb-ctrl.c
@@ -113,6 +113,52 @@ static int apb_ctrl_coldboot_seq(struct platform_device *pdev)
 	return 0;
 }
 
+static int apb_ctrl_fw_flashing_seq(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct arche_apb_ctrl_drvdata *apb = platform_get_drvdata(pdev);
+	int ret;
+
+	ret = regulator_enable(apb->vcore);
+	if (ret) {
+		dev_err(dev, "failed to enable core regulator\n");
+		return ret;
+	}
+
+	ret = regulator_enable(apb->vio);
+	if (ret) {
+		dev_err(dev, "failed to enable IO regulator\n");
+		return ret;
+	}
+
+	/* for flashing device should be in reset state */
+	assert_reset(apb->resetn_gpio);
+	apb->state = ARCHE_PLATFORM_STATE_FW_FLASHING;
+
+	return 0;
+}
+
+static int apb_ctrl_standby_boot_seq(struct platform_device *pdev)
+{
+	struct arche_apb_ctrl_drvdata *apb = platform_get_drvdata(pdev);
+
+	/* If it is in OFF state, then we do not want to change the state */
+	if (apb->state == ARCHE_PLATFORM_STATE_OFF)
+		return 0;
+
+	/*
+	 * As per WDM spec, do nothing
+	 *
+	 * Pasted from WDM spec,
+	 *  - A falling edge on POWEROFF_L is detected (a)
+	 *  - WDM enters standby mode, but no output signals are changed
+	 * */
+
+	/* TODO: POWEROFF_L is input to WDM module  */
+	apb->state = ARCHE_PLATFORM_STATE_STANDBY;
+	return 0;
+}
+
 static void apb_ctrl_poweroff_seq(struct platform_device *pdev)
 {
 	struct arche_apb_ctrl_drvdata *apb = platform_get_drvdata(pdev);
@@ -134,6 +180,66 @@ static void apb_ctrl_poweroff_seq(struct platform_device *pdev)
 	/* TODO: May have to send an event to SVC about this exit */
 }
 
+static ssize_t state_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct arche_apb_ctrl_drvdata *apb = platform_get_drvdata(pdev);
+	int ret = 0;
+
+	if (sysfs_streq(buf, "off")) {
+		if (apb->state == ARCHE_PLATFORM_STATE_OFF)
+			return count;
+
+		apb_ctrl_poweroff_seq(pdev);
+	} else if (sysfs_streq(buf, "active")) {
+		if (apb->state == ARCHE_PLATFORM_STATE_ACTIVE)
+			return count;
+
+		apb_ctrl_poweroff_seq(pdev);
+		ret = apb_ctrl_coldboot_seq(pdev);
+	} else if (sysfs_streq(buf, "standby")) {
+		if (apb->state == ARCHE_PLATFORM_STATE_STANDBY)
+			return count;
+
+		ret = apb_ctrl_standby_boot_seq(pdev);
+	} else if (sysfs_streq(buf, "fw_flashing")) {
+		if (apb->state == ARCHE_PLATFORM_STATE_FW_FLASHING)
+			return count;
+
+		/* First we want to make sure we power off everything
+		 * and then enter FW flashing state */
+		apb_ctrl_poweroff_seq(pdev);
+		ret = apb_ctrl_fw_flashing_seq(pdev);
+	} else {
+		dev_err(dev, "unknown state\n");
+		ret = -EINVAL;
+	}
+
+	return ret ? ret : count;
+}
+
+static ssize_t state_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct arche_apb_ctrl_drvdata *apb = dev_get_drvdata(dev);
+
+	switch (apb->state) {
+	case ARCHE_PLATFORM_STATE_OFF:
+		return sprintf(buf, "off\n");
+	case ARCHE_PLATFORM_STATE_ACTIVE:
+		return sprintf(buf, "active\n");
+	case ARCHE_PLATFORM_STATE_STANDBY:
+		return sprintf(buf, "standby\n");
+	case ARCHE_PLATFORM_STATE_FW_FLASHING:
+		return sprintf(buf, "fw_flashing\n");
+	default:
+		return sprintf(buf, "unknown state\n");
+	}
+}
+
+static DEVICE_ATTR_RW(state);
+
 static int apb_ctrl_get_devtree_data(struct platform_device *pdev,
 		struct arche_apb_ctrl_drvdata *apb)
 {
@@ -243,10 +349,18 @@ int arche_apb_ctrl_probe(struct platform_device *pdev)
 
 	platform_set_drvdata(pdev, apb);
 
+	/* Create sysfs interface to allow user to change state dynamically */
+	ret = device_create_file(dev, &dev_attr_state);
+	if (ret) {
+		dev_err(dev, "failed to create state file in sysfs\n");
+		return ret;
+	}
+
 	ret = apb_ctrl_coldboot_seq(pdev);
 	if (ret) {
 		dev_err(dev, "failed to set init state of control signal %d\n",
 				ret);
+		device_remove_file(dev, &dev_attr_state);
 		platform_set_drvdata(pdev, NULL);
 		return ret;
 	}
@@ -261,6 +375,7 @@ int arche_apb_ctrl_remove(struct platform_device *pdev)
 {
 	struct arche_apb_ctrl_drvdata *apb = platform_get_drvdata(pdev);
 
+	device_remove_file(&pdev->dev, &dev_attr_state);
 	apb_ctrl_poweroff_seq(pdev);
 	platform_set_drvdata(pdev, NULL);
 	unexport_gpios(apb);

commit 6961e0466575608639e91ddbcc62d9385d45a198
Author: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
Date:   Sat Feb 13 02:04:12 2016 +0530

    greybus: arche-apb-ctrl: Pass only platform_device to _seq fns
    
    Pass only pointer to platform_device to _seq fns and fetch handle to
    arche_apb_ctrl_drvdata from platform_device.
    
    This is preparation for support for dynamic switching between operational
    states for the device, where these functions will be called from parent
    driver.
    
    Testing Done: Tested on EVT1.2 and DB3.5 platform.
    
    Signed-off-by: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/arche-apb-ctrl.c b/drivers/staging/greybus/arche-apb-ctrl.c
index 1d3c112e974a..8f6f0962421e 100644
--- a/drivers/staging/greybus/arche-apb-ctrl.c
+++ b/drivers/staging/greybus/arche-apb-ctrl.c
@@ -71,10 +71,10 @@ static void unexport_gpios(struct arche_apb_ctrl_drvdata *apb)
 /*
  * Note: Please do not modify the below sequence, as it is as per the spec
  */
-static int apb_ctrl_coldboot_seq(struct platform_device *pdev,
-		struct arche_apb_ctrl_drvdata *apb)
+static int apb_ctrl_coldboot_seq(struct platform_device *pdev)
 {
 	struct device *dev = &pdev->dev;
+	struct arche_apb_ctrl_drvdata *apb = platform_get_drvdata(pdev);
 	int ret;
 
 	/* Hold APB in reset state */
@@ -113,8 +113,10 @@ static int apb_ctrl_coldboot_seq(struct platform_device *pdev,
 	return 0;
 }
 
-static void apb_ctrl_poweroff_seq(struct arche_apb_ctrl_drvdata *apb)
+static void apb_ctrl_poweroff_seq(struct platform_device *pdev)
 {
+	struct arche_apb_ctrl_drvdata *apb = platform_get_drvdata(pdev);
+
 	/* disable the clock */
 	if (gpio_is_valid(apb->clk_en_gpio))
 		gpio_set_value(apb->clk_en_gpio, 0);
@@ -239,15 +241,16 @@ int arche_apb_ctrl_probe(struct platform_device *pdev)
 	/* Initially set APB to OFF state */
 	apb->state = ARCHE_PLATFORM_STATE_OFF;
 
-	ret = apb_ctrl_coldboot_seq(pdev, apb);
+	platform_set_drvdata(pdev, apb);
+
+	ret = apb_ctrl_coldboot_seq(pdev);
 	if (ret) {
 		dev_err(dev, "failed to set init state of control signal %d\n",
 				ret);
+		platform_set_drvdata(pdev, NULL);
 		return ret;
 	}
 
-	platform_set_drvdata(pdev, apb);
-
 	export_gpios(apb);
 
 	dev_info(&pdev->dev, "Device registered successfully\n");
@@ -258,7 +261,7 @@ int arche_apb_ctrl_remove(struct platform_device *pdev)
 {
 	struct arche_apb_ctrl_drvdata *apb = platform_get_drvdata(pdev);
 
-	apb_ctrl_poweroff_seq(apb);
+	apb_ctrl_poweroff_seq(pdev);
 	platform_set_drvdata(pdev, NULL);
 	unexport_gpios(apb);
 

commit f2222a41db55f89bfafad03bd04ffdfb317b2edb
Author: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
Date:   Sat Feb 13 02:04:11 2016 +0530

    greybus: arche-apb-ctrl: Set default state value to OFF
    
    Explicitly set default apb->state value to ARCHE_PLATFORM_STATE_OFF
    in probe() fn.
    
    Testing Done: Tested on EVT1.2 and DB3.5 platform
    
    Signed-off-by: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/arche-apb-ctrl.c b/drivers/staging/greybus/arche-apb-ctrl.c
index 9b7d61fc9267..1d3c112e974a 100644
--- a/drivers/staging/greybus/arche-apb-ctrl.c
+++ b/drivers/staging/greybus/arche-apb-ctrl.c
@@ -236,6 +236,9 @@ int arche_apb_ctrl_probe(struct platform_device *pdev)
 		return ret;
 	}
 
+	/* Initially set APB to OFF state */
+	apb->state = ARCHE_PLATFORM_STATE_OFF;
+
 	ret = apb_ctrl_coldboot_seq(pdev, apb);
 	if (ret) {
 		dev_err(dev, "failed to set init state of control signal %d\n",

commit 5667ab17999a16c2bb1a5cdcaf183d8710aeb717
Author: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
Date:   Sat Feb 13 02:04:10 2016 +0530

    greybus: arche-apb-ctrl: Rename init_seq and cleanup fn
    
    apb_ctrl_coldboot_seq() and apb_ctrl_poweroff_seq()
    is appropriate name as per spec and implementation, so rename it.
    Also move apb_ctrl_poweroff_seq() fn above, to group it with
    other _seq functions.
    
    Testing Done: Tested on EVT1.2 and DB3.5 platform.
    
    Signed-off-by: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/arche-apb-ctrl.c b/drivers/staging/greybus/arche-apb-ctrl.c
index 772015393221..9b7d61fc9267 100644
--- a/drivers/staging/greybus/arche-apb-ctrl.c
+++ b/drivers/staging/greybus/arche-apb-ctrl.c
@@ -71,7 +71,7 @@ static void unexport_gpios(struct arche_apb_ctrl_drvdata *apb)
 /*
  * Note: Please do not modify the below sequence, as it is as per the spec
  */
-static int apb_ctrl_init_seq(struct platform_device *pdev,
+static int apb_ctrl_coldboot_seq(struct platform_device *pdev,
 		struct arche_apb_ctrl_drvdata *apb)
 {
 	struct device *dev = &pdev->dev;
@@ -113,6 +113,25 @@ static int apb_ctrl_init_seq(struct platform_device *pdev,
 	return 0;
 }
 
+static void apb_ctrl_poweroff_seq(struct arche_apb_ctrl_drvdata *apb)
+{
+	/* disable the clock */
+	if (gpio_is_valid(apb->clk_en_gpio))
+		gpio_set_value(apb->clk_en_gpio, 0);
+
+	if (!IS_ERR(apb->vcore) && regulator_is_enabled(apb->vcore) > 0)
+		regulator_disable(apb->vcore);
+
+	if (!IS_ERR(apb->vio) && regulator_is_enabled(apb->vio) > 0)
+		regulator_disable(apb->vio);
+
+	/* As part of exit, put APB back in reset state */
+	assert_reset(apb->resetn_gpio);
+	apb->state = ARCHE_PLATFORM_STATE_OFF;
+
+	/* TODO: May have to send an event to SVC about this exit */
+}
+
 static int apb_ctrl_get_devtree_data(struct platform_device *pdev,
 		struct arche_apb_ctrl_drvdata *apb)
 {
@@ -201,25 +220,6 @@ static int apb_ctrl_get_devtree_data(struct platform_device *pdev,
 	return 0;
 }
 
-static void apb_ctrl_cleanup(struct arche_apb_ctrl_drvdata *apb)
-{
-	/* disable the clock */
-	if (gpio_is_valid(apb->clk_en_gpio))
-		gpio_set_value(apb->clk_en_gpio, 0);
-
-	if (!IS_ERR(apb->vcore) && regulator_is_enabled(apb->vcore) > 0)
-		regulator_disable(apb->vcore);
-
-	if (!IS_ERR(apb->vio) && regulator_is_enabled(apb->vio) > 0)
-		regulator_disable(apb->vio);
-
-	/* As part of exit, put APB back in reset state */
-	assert_reset(apb->resetn_gpio);
-	apb->state = ARCHE_PLATFORM_STATE_OFF;
-
-	/* TODO: May have to send an event to SVC about this exit */
-}
-
 int arche_apb_ctrl_probe(struct platform_device *pdev)
 {
 	int ret;
@@ -236,7 +236,7 @@ int arche_apb_ctrl_probe(struct platform_device *pdev)
 		return ret;
 	}
 
-	ret = apb_ctrl_init_seq(pdev, apb);
+	ret = apb_ctrl_coldboot_seq(pdev, apb);
 	if (ret) {
 		dev_err(dev, "failed to set init state of control signal %d\n",
 				ret);
@@ -255,7 +255,7 @@ int arche_apb_ctrl_remove(struct platform_device *pdev)
 {
 	struct arche_apb_ctrl_drvdata *apb = platform_get_drvdata(pdev);
 
-	apb_ctrl_cleanup(apb);
+	apb_ctrl_poweroff_seq(apb);
 	platform_set_drvdata(pdev, NULL);
 	unexport_gpios(apb);
 

commit 6ceed512e68ea8a82cc320630e24656f03c50424
Author: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
Date:   Sat Feb 13 02:04:09 2016 +0530

    greybus: arche-apb-ctrl: Re-arrange init sequence
    
    In order to allow APB2 disable by default on boot/init, and also
    provide interface to user to enable it later on, re-arrange the init_seq
    fn.
    The idea here is, the apb_ctrl_init_seq() fn will be renamed to
    apb_ctrl_coldboot_seq(), and should not try to claim any resources.
    All the resource claim should happen in apb_ctrl_get_devtree_data() fn.
    
    And also uses devm_gpio_request_one() fn wherever possible.
    
    Testing Done: Tested on EVT1.2 and DB3.5  platform.
    
    Signed-off-by: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/arche-apb-ctrl.c b/drivers/staging/greybus/arche-apb-ctrl.c
index 42267fa121f5..772015393221 100644
--- a/drivers/staging/greybus/arche-apb-ctrl.c
+++ b/drivers/staging/greybus/arche-apb-ctrl.c
@@ -78,29 +78,7 @@ static int apb_ctrl_init_seq(struct platform_device *pdev,
 	int ret;
 
 	/* Hold APB in reset state */
-	ret = devm_gpio_request(dev, apb->resetn_gpio, "apb-reset");
-	if (ret) {
-		dev_err(dev, "Failed requesting reset gpio %d\n",
-				apb->resetn_gpio);
-		return ret;
-	}
-	ret = gpio_direction_output(apb->resetn_gpio, 0);
-	if (ret) {
-		dev_err(dev, "failed to set reset gpio dir:%d\n", ret);
-		return ret;
-	}
-
-	ret = devm_gpio_request(dev, apb->pwroff_gpio, "pwroff_n");
-	if (ret) {
-		dev_err(dev, "Failed requesting pwroff_n gpio %d\n",
-				apb->pwroff_gpio);
-		return ret;
-	}
-	ret = gpio_direction_input(apb->pwroff_gpio);
-	if (ret) {
-		dev_err(dev, "failed to set pwroff gpio dir:%d\n", ret);
-		return ret;
-	}
+	assert_reset(apb->resetn_gpio);
 
 	/* Enable power to APB */
 	if (!IS_ERR(apb->vcore)) {
@@ -115,45 +93,24 @@ static int apb_ctrl_init_seq(struct platform_device *pdev,
 		ret = regulator_enable(apb->vio);
 		if (ret) {
 			dev_err(dev, "failed to enable IO regulator\n");
-			goto out_vcore_disable;
+			return ret;
 		}
 	}
 
-	ret = devm_gpio_request_one(dev, apb->boot_ret_gpio,
-			GPIOF_OUT_INIT_LOW, "boot retention");
-	if (ret) {
-		dev_err(dev, "Failed requesting bootret gpio %d\n",
-				apb->boot_ret_gpio);
-		goto out_vio_disable;
-	}
 	gpio_set_value(apb->boot_ret_gpio, 0);
 
 	/* On DB3 clock was not mandatory */
-	if (gpio_is_valid(apb->clk_en_gpio)) {
-		ret = devm_gpio_request(dev, apb->clk_en_gpio, "apb_clk_en");
-		if (ret) {
-			dev_warn(dev, "Failed requesting APB clock en gpio %d\n",
-				 apb->clk_en_gpio);
-		} else {
-			ret = gpio_direction_output(apb->clk_en_gpio, 1);
-			if (ret)
-				dev_warn(dev, "failed to set APB clock en gpio dir:%d\n",
-					 ret);
-		}
-	}
+	if (gpio_is_valid(apb->clk_en_gpio))
+		gpio_set_value(apb->clk_en_gpio, 1);
 
 	usleep_range(100, 200);
 
-	return 0;
+	/* deassert reset to APB : Active-low signal */
+	deassert_reset(apb->resetn_gpio);
 
-out_vio_disable:
-	if (!IS_ERR(apb->vio))
-		regulator_disable(apb->vio);
-out_vcore_disable:
-	if (!IS_ERR(apb->vcore))
-		regulator_disable(apb->vcore);
+	apb->state = ARCHE_PLATFORM_STATE_ACTIVE;
 
-	return ret;
+	return 0;
 }
 
 static int apb_ctrl_get_devtree_data(struct platform_device *pdev,
@@ -161,18 +118,33 @@ static int apb_ctrl_get_devtree_data(struct platform_device *pdev,
 {
 	struct device *dev = &pdev->dev;
 	struct device_node *np = dev->of_node;
+	int ret;
 
 	apb->resetn_gpio = of_get_named_gpio(np, "reset-gpios", 0);
 	if (apb->resetn_gpio < 0) {
 		dev_err(dev, "failed to get reset gpio\n");
 		return apb->resetn_gpio;
 	}
+	ret = devm_gpio_request_one(dev, apb->resetn_gpio,
+			GPIOF_OUT_INIT_LOW, "apb-reset");
+	if (ret) {
+		dev_err(dev, "Failed requesting reset gpio %d\n",
+				apb->resetn_gpio);
+		return ret;
+	}
 
 	apb->boot_ret_gpio = of_get_named_gpio(np, "boot-ret-gpios", 0);
 	if (apb->boot_ret_gpio < 0) {
 		dev_err(dev, "failed to get boot retention gpio\n");
 		return apb->boot_ret_gpio;
 	}
+	ret = devm_gpio_request_one(dev, apb->boot_ret_gpio,
+			GPIOF_OUT_INIT_LOW, "boot retention");
+	if (ret) {
+		dev_err(dev, "Failed requesting bootret gpio %d\n",
+				apb->boot_ret_gpio);
+		return ret;
+	}
 
 	/* It's not mandatory to support power management interface */
 	apb->pwroff_gpio = of_get_named_gpio(np, "pwr-off-gpios", 0);
@@ -180,11 +152,27 @@ static int apb_ctrl_get_devtree_data(struct platform_device *pdev,
 		dev_err(dev, "failed to get power off gpio\n");
 		return apb->pwroff_gpio;
 	}
+	ret = devm_gpio_request_one(dev, apb->pwroff_gpio,
+			GPIOF_IN, "pwroff_n");
+	if (ret) {
+		dev_err(dev, "Failed requesting pwroff_n gpio %d\n",
+				apb->pwroff_gpio);
+		return ret;
+	}
 
 	/* Do not make clock mandatory as of now (for DB3) */
 	apb->clk_en_gpio = of_get_named_gpio(np, "clock-en-gpio", 0);
-	if (apb->clk_en_gpio < 0)
+	if (apb->clk_en_gpio < 0) {
 		dev_warn(dev, "failed to get clock en gpio\n");
+	} else if (gpio_is_valid(apb->clk_en_gpio)) {
+		ret = devm_gpio_request_one(dev, apb->clk_en_gpio,
+				GPIOF_OUT_INIT_LOW, "apb_clk_en");
+		if (ret) {
+			dev_warn(dev, "Failed requesting APB clock en gpio %d\n",
+					apb->clk_en_gpio);
+			return ret;
+		}
+	}
 
 	apb->pwrdn_gpio = of_get_named_gpio(np, "pwr-down-gpios", 0);
 	if (apb->pwrdn_gpio < 0)
@@ -255,10 +243,6 @@ int arche_apb_ctrl_probe(struct platform_device *pdev)
 		return ret;
 	}
 
-	/* deassert reset to APB : Active-low signal */
-	deassert_reset(apb->resetn_gpio);
-	apb->state = ARCHE_PLATFORM_STATE_ACTIVE;
-
 	platform_set_drvdata(pdev, apb);
 
 	export_gpios(apb);

commit a821adb47d28e22f96716b0ab8c4a8d5f7d3dadb
Author: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
Date:   Sat Feb 13 02:04:02 2016 +0530

    greybus: arche-platform: make apb_state common to both platform drivers
    
    Make 'enum apb_state' common to both platform drivers, so that
    both drivers can make use of same state and user will have
    unified control configuration across devices (SVC, APB1 and APB2)
    
    Testing Done: Tested on EVT1.2 and DB3.5 platform.
    
    Signed-off-by: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/arche-apb-ctrl.c b/drivers/staging/greybus/arche-apb-ctrl.c
index f2bad8df0cf7..42267fa121f5 100644
--- a/drivers/staging/greybus/arche-apb-ctrl.c
+++ b/drivers/staging/greybus/arche-apb-ctrl.c
@@ -21,11 +21,6 @@
 #include <linux/spinlock.h>
 #include "arche_platform.h"
 
-enum apb_state {
-	APB_STATE_OFF,
-	APB_STATE_ACTIVE,
-	APB_STATE_STANDBY,
-};
 
 struct arche_apb_ctrl_drvdata {
 	/* Control GPIO signals to and from AP <=> AP Bridges */
@@ -36,7 +31,7 @@ struct arche_apb_ctrl_drvdata {
 	int wake_out_gpio;
 	int pwrdn_gpio;
 
-	enum apb_state state;
+	enum arche_platform_state state;
 
 	struct regulator *vcore;
 	struct regulator *vio;
@@ -232,7 +227,7 @@ static void apb_ctrl_cleanup(struct arche_apb_ctrl_drvdata *apb)
 
 	/* As part of exit, put APB back in reset state */
 	assert_reset(apb->resetn_gpio);
-	apb->state = APB_STATE_OFF;
+	apb->state = ARCHE_PLATFORM_STATE_OFF;
 
 	/* TODO: May have to send an event to SVC about this exit */
 }
@@ -262,7 +257,7 @@ int arche_apb_ctrl_probe(struct platform_device *pdev)
 
 	/* deassert reset to APB : Active-low signal */
 	deassert_reset(apb->resetn_gpio);
-	apb->state = APB_STATE_ACTIVE;
+	apb->state = ARCHE_PLATFORM_STATE_ACTIVE;
 
 	platform_set_drvdata(pdev, apb);
 

commit f6d6f5bd29f76721d7ac5c64426a1f45203c622a
Author: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
Date:   Tue Feb 9 22:09:16 2016 +0530

    greybus: Revert "arche-apb-ctrl: Remove extra delay in APB reset"
    
    We are seeing failures on DB3.1 board, and Axel root-caused it to this
    commit, so revert it as of now.
    
    This reverts commit 942627227684c187b727ba5fb581bc2d886b6708.
    
    Signed-off-by: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/arche-apb-ctrl.c b/drivers/staging/greybus/arche-apb-ctrl.c
index 4e5ce37ea37e..f2bad8df0cf7 100644
--- a/drivers/staging/greybus/arche-apb-ctrl.c
+++ b/drivers/staging/greybus/arche-apb-ctrl.c
@@ -54,6 +54,7 @@ struct arche_apb_ctrl_drvdata {
 static inline void deassert_reset(unsigned int gpio)
 {
 	gpio_set_value(gpio, 1);
+	msleep(500);
 }
 
 static inline void assert_reset(unsigned int gpio)

commit 6084653541ac5fb619c4338e6fa6a9d5d4a51713
Author: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
Date:   Fri Feb 5 01:10:56 2016 +0530

    greybus: arche-apb-ctrl: Remove extra delay in APB reset
    
    With synchronization between SVC <=> AP over wake/detect line to
    bring APB's out of reset, we do not need any extra delays now.
    So remove it.
    
    Testing Done: Tested for 10 iterations on EVT1
    
    Signed-off-by: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
    Reviewed-by: Michael Scott <michael.scott@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/arche-apb-ctrl.c b/drivers/staging/greybus/arche-apb-ctrl.c
index f2bad8df0cf7..4e5ce37ea37e 100644
--- a/drivers/staging/greybus/arche-apb-ctrl.c
+++ b/drivers/staging/greybus/arche-apb-ctrl.c
@@ -54,7 +54,6 @@ struct arche_apb_ctrl_drvdata {
 static inline void deassert_reset(unsigned int gpio)
 {
 	gpio_set_value(gpio, 1);
-	msleep(500);
 }
 
 static inline void assert_reset(unsigned int gpio)

commit d8b16338df9bcef1fa0a047bd3e8d2e922dc5bb8
Author: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
Date:   Tue Jan 26 07:23:29 2016 +0530

    greybus: arche-platform: Disable clock as part of driver remove
    
    As part of driver remove (cleanup) function, disable the clock for both
    SVC, APB1 & APB2.
    
    Testing Done:
    Tested on EVT1 platform with Connect=>disconnect=>connect
    iteration, almost close to 100 iterations have passed (demo branch).
    And also tested with kernel-only build.
    
    Signed-off-by: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/arche-apb-ctrl.c b/drivers/staging/greybus/arche-apb-ctrl.c
index d073543963a5..f2bad8df0cf7 100644
--- a/drivers/staging/greybus/arche-apb-ctrl.c
+++ b/drivers/staging/greybus/arche-apb-ctrl.c
@@ -220,6 +220,10 @@ static int apb_ctrl_get_devtree_data(struct platform_device *pdev,
 
 static void apb_ctrl_cleanup(struct arche_apb_ctrl_drvdata *apb)
 {
+	/* disable the clock */
+	if (gpio_is_valid(apb->clk_en_gpio))
+		gpio_set_value(apb->clk_en_gpio, 0);
+
 	if (!IS_ERR(apb->vcore) && regulator_is_enabled(apb->vcore) > 0)
 		regulator_disable(apb->vcore);
 

commit aa187d33129ba102756600aa27f6e7992a6c814a
Author: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
Date:   Thu Jan 14 02:06:47 2016 +0530

    greybus: arche-apb-ctrl: Enable the clocks after regulator enable
    
    It makes more sense to enable the clock after power is enabled
    to the device, so move clock enable code after regulator_enable
    and setting up BOOT_RET pin.
    
    Signed-off-by: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
    Tested-by: Michael Scott <michael.scott@linaro.org>
    Reviewed-by: Laurent Pinchart <laurent.pinchart@linaro.org>
    Tested-by: Laurent Pinchart <laurent.pinchart@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/arche-apb-ctrl.c b/drivers/staging/greybus/arche-apb-ctrl.c
index 65b1e9a700e7..d073543963a5 100644
--- a/drivers/staging/greybus/arche-apb-ctrl.c
+++ b/drivers/staging/greybus/arche-apb-ctrl.c
@@ -82,19 +82,6 @@ static int apb_ctrl_init_seq(struct platform_device *pdev,
 	struct device *dev = &pdev->dev;
 	int ret;
 
-	/* On DB3 clock was not mandatory */
-	if (gpio_is_valid(apb->clk_en_gpio)) {
-		ret = devm_gpio_request(dev, apb->clk_en_gpio, "apb_clk_en");
-		if (ret) {
-			dev_warn(dev, "Failed requesting APB clock en gpio %d\n",
-				 apb->clk_en_gpio);
-		} else {
-			ret = gpio_direction_output(apb->clk_en_gpio, 1);
-			if (ret)
-				dev_warn(dev, "failed to set APB clock en gpio dir:%d\n",
-					 ret);
-		}
-	}
 	/* Hold APB in reset state */
 	ret = devm_gpio_request(dev, apb->resetn_gpio, "apb-reset");
 	if (ret) {
@@ -128,6 +115,7 @@ static int apb_ctrl_init_seq(struct platform_device *pdev,
 			return ret;
 		}
 	}
+
 	if (!IS_ERR(apb->vio)) {
 		ret = regulator_enable(apb->vio);
 		if (ret) {
@@ -144,7 +132,22 @@ static int apb_ctrl_init_seq(struct platform_device *pdev,
 		goto out_vio_disable;
 	}
 	gpio_set_value(apb->boot_ret_gpio, 0);
-	udelay(50);
+
+	/* On DB3 clock was not mandatory */
+	if (gpio_is_valid(apb->clk_en_gpio)) {
+		ret = devm_gpio_request(dev, apb->clk_en_gpio, "apb_clk_en");
+		if (ret) {
+			dev_warn(dev, "Failed requesting APB clock en gpio %d\n",
+				 apb->clk_en_gpio);
+		} else {
+			ret = gpio_direction_output(apb->clk_en_gpio, 1);
+			if (ret)
+				dev_warn(dev, "failed to set APB clock en gpio dir:%d\n",
+					 ret);
+		}
+	}
+
+	usleep_range(100, 200);
 
 	return 0;
 

commit f1e9cbd5a097aa6ec62f261bdf44879bbaefb72a
Author: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
Date:   Mon Jan 11 17:41:23 2016 +0530

    greybus: arche-apb-ctrl: deassert reset at the end of probe
    
    Now the complete handshaking between AP<=>SVC would be
    offloaded to parent driver (arche-platform) who is
    responsible for SVC control, so the apb-ctrl driver can
    just simply bring APB's out of reset during probe itself.
    
    Along with deasserting reset, this patch renames the local fn
    to exclusively use it for reset purpose.
    
    Note that, driver is exporting reset gpio to
    user, so user can still flash FW from prompt.
    
    Signed-off-by: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
    Tested-by: Michael Scott <michael.scott@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/arche-apb-ctrl.c b/drivers/staging/greybus/arche-apb-ctrl.c
index 5b9a3ed212af..65b1e9a700e7 100644
--- a/drivers/staging/greybus/arche-apb-ctrl.c
+++ b/drivers/staging/greybus/arche-apb-ctrl.c
@@ -51,13 +51,13 @@ struct arche_apb_ctrl_drvdata {
 /*
  * Note that these low level api's are active high
  */
-static inline void assert_gpio(unsigned int gpio)
+static inline void deassert_reset(unsigned int gpio)
 {
 	gpio_set_value(gpio, 1);
 	msleep(500);
 }
 
-static inline void deassert_gpio(unsigned int gpio)
+static inline void assert_reset(unsigned int gpio)
 {
 	gpio_set_value(gpio, 0);
 }
@@ -224,7 +224,7 @@ static void apb_ctrl_cleanup(struct arche_apb_ctrl_drvdata *apb)
 		regulator_disable(apb->vio);
 
 	/* As part of exit, put APB back in reset state */
-	gpio_set_value(apb->resetn_gpio, 0);
+	assert_reset(apb->resetn_gpio);
 	apb->state = APB_STATE_OFF;
 
 	/* TODO: May have to send an event to SVC about this exit */
@@ -253,8 +253,9 @@ int arche_apb_ctrl_probe(struct platform_device *pdev)
 		return ret;
 	}
 
-	apb->state = APB_STATE_OFF;
-
+	/* deassert reset to APB : Active-low signal */
+	deassert_reset(apb->resetn_gpio);
+	apb->state = APB_STATE_ACTIVE;
 
 	platform_set_drvdata(pdev, apb);
 

commit 33036178bf04a06ad7e87513c76d7075959088e8
Author: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
Date:   Mon Jan 11 17:41:22 2016 +0530

    greybus: arche-apb-ctrl: Remove wake_detect gpio and related code
    
    With TIME_SYNC functionality, assignment of wake/detect pin
    will change,
      WD_8A => to bring APB's out of reset
      WD_8B => TIME_SYNC operation
    
    So in order to support this, we can no longer keep wake_detect
    gpio in apb-ctrl driver. So remove it.
    In the subsequent patches, wake_detect support will be added
    to parent SVC driver (arche-platform) who is responsible for SVC control.
    
    Note that, this patch also removes ISR related code.
    The APB state still is maintained, for future use.
    
    Signed-off-by: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
    Tested-by: Michael Scott <michael.scott@linaro.org>
    Reviewed-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/arche-apb-ctrl.c b/drivers/staging/greybus/arche-apb-ctrl.c
index afdaeca999ca..5b9a3ed212af 100644
--- a/drivers/staging/greybus/arche-apb-ctrl.c
+++ b/drivers/staging/greybus/arche-apb-ctrl.c
@@ -29,7 +29,6 @@ enum apb_state {
 
 struct arche_apb_ctrl_drvdata {
 	/* Control GPIO signals to and from AP <=> AP Bridges */
-	int wake_detect_gpio; /* bi-dir,maps to WAKE_MOD & WAKE_FRAME signals */
 	int resetn_gpio;
 	int boot_ret_gpio;
 	int pwroff_gpio;
@@ -37,7 +36,6 @@ struct arche_apb_ctrl_drvdata {
 	int wake_out_gpio;
 	int pwrdn_gpio;
 
-	unsigned int wake_detect_irq;
 	enum apb_state state;
 
 	struct regulator *vcore;
@@ -48,9 +46,6 @@ struct arche_apb_ctrl_drvdata {
 
 	struct pinctrl *pinctrl;
 	struct pinctrl_state *pin_default;
-
-	/* To protect concurrent access of GPIO registers, need protection */
-	spinlock_t lock;
 };
 
 /*
@@ -78,45 +73,6 @@ static void unexport_gpios(struct arche_apb_ctrl_drvdata *apb)
 	gpio_unexport(apb->resetn_gpio);
 }
 
-static irqreturn_t apb_ctrl_wake_detect_irq(int irq, void *devid)
-{
-	struct arche_apb_ctrl_drvdata *apb = devid;
-	unsigned long flags;
-
-	/*
-	 * TODO:
-	 * Since currently SoC GPIOs are being used we are safe here
-	 * But ideally we should create a workqueue and process the control
-	 * signals, especially when we start using GPIOs over slow
-	 * buses like I2C.
-	 */
-	spin_lock_irqsave(&apb->lock, flags);
-
-	if (apb->state != APB_STATE_ACTIVE) {
-		/* Bring bridge out of reset on this event */
-		gpio_set_value(apb->resetn_gpio, 1);
-		apb->state = APB_STATE_ACTIVE;
-	} else {
-		/*
-		 * Assert Wake_OUT signal to APB
-		 * It would resemble WakeDetect module's signal pass-through
-		 */
-		/*
-		 * We have to generate the pulse, so we may need to schedule
-		 * workqueue here.
-		 *
-		 * Also, since we are using both rising and falling edge for
-		 * interrupt trigger, we may not need workqueue. Just pass
-		 * through the value to bridge.
-		 * Just read GPIO value and pass it to the bridge
-		 */
-	}
-
-	spin_unlock_irqrestore(&apb->lock, flags);
-
-	return IRQ_HANDLED;
-}
-
 /*
  * Note: Please do not modify the below sequence, as it is as per the spec
  */
@@ -190,14 +146,6 @@ static int apb_ctrl_init_seq(struct platform_device *pdev,
 	gpio_set_value(apb->boot_ret_gpio, 0);
 	udelay(50);
 
-	ret = devm_gpio_request_one(dev, apb->wake_detect_gpio,
-			GPIOF_INIT_LOW, "wake detect");
-	if (ret) {
-		dev_err(dev, "Failed requesting wake_detect gpio %d\n",
-				apb->wake_detect_gpio);
-		goto out_vio_disable;
-	}
-
 	return 0;
 
 out_vio_disable:
@@ -216,12 +164,6 @@ static int apb_ctrl_get_devtree_data(struct platform_device *pdev,
 	struct device *dev = &pdev->dev;
 	struct device_node *np = dev->of_node;
 
-	apb->wake_detect_gpio = of_get_named_gpio(np, "wake-detect-gpios", 0);
-	if (apb->wake_detect_gpio < 0) {
-		dev_err(dev, "failed to get wake detect gpio\n");
-		return apb->wake_detect_gpio;
-	}
-
 	apb->resetn_gpio = of_get_named_gpio(np, "reset-gpios", 0);
 	if (apb->resetn_gpio < 0) {
 		dev_err(dev, "failed to get reset gpio\n");
@@ -275,19 +217,15 @@ static int apb_ctrl_get_devtree_data(struct platform_device *pdev,
 
 static void apb_ctrl_cleanup(struct arche_apb_ctrl_drvdata *apb)
 {
-	unsigned long flags;
-
 	if (!IS_ERR(apb->vcore) && regulator_is_enabled(apb->vcore) > 0)
 		regulator_disable(apb->vcore);
 
 	if (!IS_ERR(apb->vio) && regulator_is_enabled(apb->vio) > 0)
 		regulator_disable(apb->vio);
 
-	spin_lock_irqsave(&apb->lock, flags);
 	/* As part of exit, put APB back in reset state */
 	gpio_set_value(apb->resetn_gpio, 0);
 	apb->state = APB_STATE_OFF;
-	spin_unlock_irqrestore(&apb->lock, flags);
 
 	/* TODO: May have to send an event to SVC about this exit */
 }
@@ -315,27 +253,8 @@ int arche_apb_ctrl_probe(struct platform_device *pdev)
 		return ret;
 	}
 
-	spin_lock_init(&apb->lock);
-
 	apb->state = APB_STATE_OFF;
-	/*
-	 * Assert AP module detect signal by pulling wake_detect low
-	 */
-	assert_gpio(apb->wake_detect_gpio);
 
-	/*
-	 * In order to receive an interrupt, the GPIO must be set to input mode
-	 */
-	gpio_direction_input(apb->wake_detect_gpio);
-
-	ret = devm_request_irq(dev, gpio_to_irq(apb->wake_detect_gpio),
-			apb_ctrl_wake_detect_irq, IRQF_TRIGGER_FALLING,
-			"wake detect", apb);
-	if (ret) {
-		dev_err(dev, "failed to request wake detect IRQ\n");
-		apb_ctrl_cleanup(apb);
-		return ret;
-	}
 
 	platform_set_drvdata(pdev, apb);
 

commit 3b858df01fe936bbd329ecf13c3a3d81486f1f16
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Mon Jan 11 11:29:17 2016 +0530

    greybus: arche: Remove unwanted headers and rearrange others
    
    This removes few unwanted headers related to irq, interrupt, regulator,
    spinlock, etc.
    
    Also arrange the rest in alphabetical order to make it more readable.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Reviewed-by: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/arche-apb-ctrl.c b/drivers/staging/greybus/arche-apb-ctrl.c
index 04c44675926e..afdaeca999ca 100644
--- a/drivers/staging/greybus/arche-apb-ctrl.c
+++ b/drivers/staging/greybus/arche-apb-ctrl.c
@@ -7,22 +7,18 @@
  * Released under the GPLv2 only.
  */
 
-#include <linux/module.h>
-#include <linux/init.h>
-#include <linux/interrupt.h>
-#include <linux/irq.h>
-#include <linux/sched.h>
-#include <linux/pm.h>
+#include <linux/clk.h>
 #include <linux/delay.h>
-#include <linux/platform_device.h>
 #include <linux/gpio.h>
-#include <linux/clk.h>
-#include <linux/of_platform.h>
+#include <linux/interrupt.h>
 #include <linux/of_gpio.h>
 #include <linux/of_irq.h>
-#include <linux/spinlock.h>
-#include <linux/regulator/consumer.h>
+#include <linux/module.h>
 #include <linux/pinctrl/consumer.h>
+#include <linux/platform_device.h>
+#include <linux/pm.h>
+#include <linux/regulator/consumer.h>
+#include <linux/spinlock.h>
 #include "arche_platform.h"
 
 enum apb_state {

commit 40989cf3c1e3c114d3558ad4d7513344ed612ac2
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Mon Jan 11 11:29:16 2016 +0530

    greybus: arche-apb: Drop unnecessary checks
    
    wake_detect_gpio and resetn_gpio are guaranteed to be valid in
    apb_ctrl_cleanup() and irq-handler, no need to check for their validity.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Reviewed-by: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/arche-apb-ctrl.c b/drivers/staging/greybus/arche-apb-ctrl.c
index 859d22e3f149..04c44675926e 100644
--- a/drivers/staging/greybus/arche-apb-ctrl.c
+++ b/drivers/staging/greybus/arche-apb-ctrl.c
@@ -94,10 +94,6 @@ static irqreturn_t apb_ctrl_wake_detect_irq(int irq, void *devid)
 	 * signals, especially when we start using GPIOs over slow
 	 * buses like I2C.
 	 */
-	if (!gpio_is_valid(apb->wake_detect_gpio) &&
-			!gpio_is_valid(apb->resetn_gpio))
-		return IRQ_HANDLED; /* Should it be IRQ_NONE ?? */
-
 	spin_lock_irqsave(&apb->lock, flags);
 
 	if (apb->state != APB_STATE_ACTIVE) {
@@ -293,9 +289,7 @@ static void apb_ctrl_cleanup(struct arche_apb_ctrl_drvdata *apb)
 
 	spin_lock_irqsave(&apb->lock, flags);
 	/* As part of exit, put APB back in reset state */
-	if (gpio_is_valid(apb->resetn_gpio))
-		gpio_set_value(apb->resetn_gpio, 0);
-
+	gpio_set_value(apb->resetn_gpio, 0);
 	apb->state = APB_STATE_OFF;
 	spin_unlock_irqrestore(&apb->lock, flags);
 

commit d258432fb2fbf1a5a4910dbc31aba99d04801268
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Mon Jan 11 11:29:15 2016 +0530

    greybus: arche-apb: Do cleanup within apb_ctrl_init_seq() for error cases
    
    Relying on apb_ctrl_cleanup() to do the cleanup for errors that occurred
    within apb_ctrl_init_seq() isn't a very clean idea. Handle that
    separately within apb_ctrl_init_seq().
    
    This will clean apb_ctrl_cleanup() in later patches.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Reviewed-by: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/arche-apb-ctrl.c b/drivers/staging/greybus/arche-apb-ctrl.c
index f83230deb4b4..859d22e3f149 100644
--- a/drivers/staging/greybus/arche-apb-ctrl.c
+++ b/drivers/staging/greybus/arche-apb-ctrl.c
@@ -184,7 +184,7 @@ static int apb_ctrl_init_seq(struct platform_device *pdev,
 		ret = regulator_enable(apb->vio);
 		if (ret) {
 			dev_err(dev, "failed to enable IO regulator\n");
-			return ret;
+			goto out_vcore_disable;
 		}
 	}
 
@@ -193,16 +193,27 @@ static int apb_ctrl_init_seq(struct platform_device *pdev,
 	if (ret) {
 		dev_err(dev, "Failed requesting bootret gpio %d\n",
 				apb->boot_ret_gpio);
-		return ret;
+		goto out_vio_disable;
 	}
 	gpio_set_value(apb->boot_ret_gpio, 0);
 	udelay(50);
 
 	ret = devm_gpio_request_one(dev, apb->wake_detect_gpio,
 			GPIOF_INIT_LOW, "wake detect");
-	if (ret)
+	if (ret) {
 		dev_err(dev, "Failed requesting wake_detect gpio %d\n",
 				apb->wake_detect_gpio);
+		goto out_vio_disable;
+	}
+
+	return 0;
+
+out_vio_disable:
+	if (!IS_ERR(apb->vio))
+		regulator_disable(apb->vio);
+out_vcore_disable:
+	if (!IS_ERR(apb->vcore))
+		regulator_disable(apb->vcore);
 
 	return ret;
 }
@@ -311,7 +322,7 @@ int arche_apb_ctrl_probe(struct platform_device *pdev)
 	if (ret) {
 		dev_err(dev, "failed to set init state of control signal %d\n",
 				ret);
-		goto exit;
+		return ret;
 	}
 
 	spin_lock_init(&apb->lock);
@@ -332,7 +343,8 @@ int arche_apb_ctrl_probe(struct platform_device *pdev)
 			"wake detect", apb);
 	if (ret) {
 		dev_err(dev, "failed to request wake detect IRQ\n");
-		goto exit;
+		apb_ctrl_cleanup(apb);
+		return ret;
 	}
 
 	platform_set_drvdata(pdev, apb);
@@ -341,10 +353,6 @@ int arche_apb_ctrl_probe(struct platform_device *pdev)
 
 	dev_info(&pdev->dev, "Device registered successfully\n");
 	return 0;
-
-exit:
-	apb_ctrl_cleanup(apb);
-	return ret;
 }
 
 int arche_apb_ctrl_remove(struct platform_device *pdev)

commit a7a794ec540c442999598cf16605ba7962aa3861
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Mon Jan 11 11:29:14 2016 +0530

    greybus: arche-apb: Don't use gpio after failing to request it
    
    If devm_gpio_request() returns an error, we shouldn't try to set the
    direction of the same gpio.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Reviewed-by: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/arche-apb-ctrl.c b/drivers/staging/greybus/arche-apb-ctrl.c
index 8582a4849221..f83230deb4b4 100644
--- a/drivers/staging/greybus/arche-apb-ctrl.c
+++ b/drivers/staging/greybus/arche-apb-ctrl.c
@@ -137,12 +137,15 @@ static int apb_ctrl_init_seq(struct platform_device *pdev,
 	/* On DB3 clock was not mandatory */
 	if (gpio_is_valid(apb->clk_en_gpio)) {
 		ret = devm_gpio_request(dev, apb->clk_en_gpio, "apb_clk_en");
-		if (ret)
+		if (ret) {
 			dev_warn(dev, "Failed requesting APB clock en gpio %d\n",
-					apb->clk_en_gpio);
-		ret = gpio_direction_output(apb->clk_en_gpio, 1);
-		if (ret)
-			dev_warn(dev, "failed to set APB clock en gpio dir:%d\n", ret);
+				 apb->clk_en_gpio);
+		} else {
+			ret = gpio_direction_output(apb->clk_en_gpio, 1);
+			if (ret)
+				dev_warn(dev, "failed to set APB clock en gpio dir:%d\n",
+					 ret);
+		}
 	}
 	/* Hold APB in reset state */
 	ret = devm_gpio_request(dev, apb->resetn_gpio, "apb-reset");

commit db0cff554a612715701a04143df595cc87737d55
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Mon Jan 11 11:29:13 2016 +0530

    greybus: arche-apb: Properly use dev_err/info/warn
    
    Use dev_err for errors after which we need to abort the currently
    running routine and dev_warn for resource allocation failure, with which
    we can continue to work.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Reviewed-by: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/arche-apb-ctrl.c b/drivers/staging/greybus/arche-apb-ctrl.c
index acdeb71dde7b..8582a4849221 100644
--- a/drivers/staging/greybus/arche-apb-ctrl.c
+++ b/drivers/staging/greybus/arche-apb-ctrl.c
@@ -138,11 +138,11 @@ static int apb_ctrl_init_seq(struct platform_device *pdev,
 	if (gpio_is_valid(apb->clk_en_gpio)) {
 		ret = devm_gpio_request(dev, apb->clk_en_gpio, "apb_clk_en");
 		if (ret)
-			dev_err(dev, "Failed requesting APB clock en gpio %d\n",
+			dev_warn(dev, "Failed requesting APB clock en gpio %d\n",
 					apb->clk_en_gpio);
 		ret = gpio_direction_output(apb->clk_en_gpio, 1);
 		if (ret)
-			dev_err(dev, "failed to set APB clock en gpio dir:%d\n", ret);
+			dev_warn(dev, "failed to set APB clock en gpio dir:%d\n", ret);
 	}
 	/* Hold APB in reset state */
 	ret = devm_gpio_request(dev, apb->resetn_gpio, "apb-reset");
@@ -231,27 +231,27 @@ static int apb_ctrl_get_devtree_data(struct platform_device *pdev,
 	/* It's not mandatory to support power management interface */
 	apb->pwroff_gpio = of_get_named_gpio(np, "pwr-off-gpios", 0);
 	if (apb->pwroff_gpio < 0) {
-		dev_info(dev, "failed to get power off gpio\n");
+		dev_err(dev, "failed to get power off gpio\n");
 		return apb->pwroff_gpio;
 	}
 
 	/* Do not make clock mandatory as of now (for DB3) */
 	apb->clk_en_gpio = of_get_named_gpio(np, "clock-en-gpio", 0);
 	if (apb->clk_en_gpio < 0)
-		dev_err(dev, "failed to get clock en gpio\n");
+		dev_warn(dev, "failed to get clock en gpio\n");
 
 	apb->pwrdn_gpio = of_get_named_gpio(np, "pwr-down-gpios", 0);
 	if (apb->pwrdn_gpio < 0)
-		dev_info(dev, "failed to get power down gpio\n");
+		dev_warn(dev, "failed to get power down gpio\n");
 
 	/* Regulators are optional, as we may have fixed supply coming in */
 	apb->vcore = devm_regulator_get(dev, "vcore");
 	if (IS_ERR(apb->vcore))
-		dev_info(dev, "no core regulator found\n");
+		dev_warn(dev, "no core regulator found\n");
 
 	apb->vio = devm_regulator_get(dev, "vio");
 	if (IS_ERR(apb->vio))
-		dev_info(dev, "no IO regulator found\n");
+		dev_warn(dev, "no IO regulator found\n");
 
 	apb->pinctrl = devm_pinctrl_get(&pdev->dev);
 	if (IS_ERR(apb->pinctrl)) {

commit dcf77c397918178af09b72f63145eed3fde788ba
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Mon Jan 11 11:29:12 2016 +0530

    greybus: arche-apb: NULL is a valid regulator
    
    Since NULL could in theory be a valid regulator we ought to check for
    IS_ERR() rather than for NULL. In practice this is unlikely to be an
    issue but it's better for neatness.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Reviewed-by: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/arche-apb-ctrl.c b/drivers/staging/greybus/arche-apb-ctrl.c
index 1ae2c06c8e33..acdeb71dde7b 100644
--- a/drivers/staging/greybus/arche-apb-ctrl.c
+++ b/drivers/staging/greybus/arche-apb-ctrl.c
@@ -170,14 +170,14 @@ static int apb_ctrl_init_seq(struct platform_device *pdev,
 	}
 
 	/* Enable power to APB */
-	if (apb->vcore) {
+	if (!IS_ERR(apb->vcore)) {
 		ret = regulator_enable(apb->vcore);
 		if (ret) {
 			dev_err(dev, "failed to enable core regulator\n");
 			return ret;
 		}
 	}
-	if (apb->vio) {
+	if (!IS_ERR(apb->vio)) {
 		ret = regulator_enable(apb->vio);
 		if (ret) {
 			dev_err(dev, "failed to enable IO regulator\n");
@@ -246,16 +246,12 @@ static int apb_ctrl_get_devtree_data(struct platform_device *pdev,
 
 	/* Regulators are optional, as we may have fixed supply coming in */
 	apb->vcore = devm_regulator_get(dev, "vcore");
-	if (IS_ERR(apb->vcore)) {
+	if (IS_ERR(apb->vcore))
 		dev_info(dev, "no core regulator found\n");
-		apb->vcore = NULL;
-	}
 
 	apb->vio = devm_regulator_get(dev, "vio");
-	if (IS_ERR(apb->vio)) {
+	if (IS_ERR(apb->vio))
 		dev_info(dev, "no IO regulator found\n");
-		apb->vio = NULL;
-	}
 
 	apb->pinctrl = devm_pinctrl_get(&pdev->dev);
 	if (IS_ERR(apb->pinctrl)) {
@@ -275,10 +271,10 @@ static void apb_ctrl_cleanup(struct arche_apb_ctrl_drvdata *apb)
 {
 	unsigned long flags;
 
-	if (apb->vcore && regulator_is_enabled(apb->vcore) > 0)
+	if (!IS_ERR(apb->vcore) && regulator_is_enabled(apb->vcore) > 0)
 		regulator_disable(apb->vcore);
 
-	if (apb->vio && regulator_is_enabled(apb->vio) > 0)
+	if (!IS_ERR(apb->vio) && regulator_is_enabled(apb->vio) > 0)
 		regulator_disable(apb->vio);
 
 	spin_lock_irqsave(&apb->lock, flags);

commit bd62fa5e1067bd5a3c8421ae3de0021a67223e22
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Mon Jan 11 11:29:11 2016 +0530

    greybus: arche-apb: devm_regulator_get() doesn't return NULL
    
    And so we don't need to check for it.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Reviewed-by: Alex Elder <elder@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/arche-apb-ctrl.c b/drivers/staging/greybus/arche-apb-ctrl.c
index b06bb3453ca4..1ae2c06c8e33 100644
--- a/drivers/staging/greybus/arche-apb-ctrl.c
+++ b/drivers/staging/greybus/arche-apb-ctrl.c
@@ -246,13 +246,13 @@ static int apb_ctrl_get_devtree_data(struct platform_device *pdev,
 
 	/* Regulators are optional, as we may have fixed supply coming in */
 	apb->vcore = devm_regulator_get(dev, "vcore");
-	if (IS_ERR_OR_NULL(apb->vcore)) {
+	if (IS_ERR(apb->vcore)) {
 		dev_info(dev, "no core regulator found\n");
 		apb->vcore = NULL;
 	}
 
 	apb->vio = devm_regulator_get(dev, "vio");
-	if (IS_ERR_OR_NULL(apb->vio)) {
+	if (IS_ERR(apb->vio)) {
 		dev_info(dev, "no IO regulator found\n");
 		apb->vio = NULL;
 	}

commit 7541c1a1c6b0e5531545c400e27b8aee2ba71610
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Mon Jan 11 11:29:10 2016 +0530

    greybus: arche-apb: Replace gpio_is_valid() with gpio < 0 checks
    
    There can be no invalid values in the DTS. The actual pin numbers are
    assigned by gpiolib when the gpio controller is registered.
    
    And so a simple 'gpio < 0' is enough instead of gpio_is_valid() which
    also checks for 'gpio < ARCH_NR_GPIOS'.
    
    This will make the usage of of_get_named_gpio() similar with how it is
    done in arche-platform driver.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Reviewed-by: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/arche-apb-ctrl.c b/drivers/staging/greybus/arche-apb-ctrl.c
index 3d71093c4697..b06bb3453ca4 100644
--- a/drivers/staging/greybus/arche-apb-ctrl.c
+++ b/drivers/staging/greybus/arche-apb-ctrl.c
@@ -211,37 +211,37 @@ static int apb_ctrl_get_devtree_data(struct platform_device *pdev,
 	struct device_node *np = dev->of_node;
 
 	apb->wake_detect_gpio = of_get_named_gpio(np, "wake-detect-gpios", 0);
-	if (!gpio_is_valid(apb->wake_detect_gpio)) {
+	if (apb->wake_detect_gpio < 0) {
 		dev_err(dev, "failed to get wake detect gpio\n");
 		return apb->wake_detect_gpio;
 	}
 
 	apb->resetn_gpio = of_get_named_gpio(np, "reset-gpios", 0);
-	if (!gpio_is_valid(apb->resetn_gpio)) {
+	if (apb->resetn_gpio < 0) {
 		dev_err(dev, "failed to get reset gpio\n");
 		return apb->resetn_gpio;
 	}
 
 	apb->boot_ret_gpio = of_get_named_gpio(np, "boot-ret-gpios", 0);
-	if (!gpio_is_valid(apb->boot_ret_gpio)) {
+	if (apb->boot_ret_gpio < 0) {
 		dev_err(dev, "failed to get boot retention gpio\n");
 		return apb->boot_ret_gpio;
 	}
 
 	/* It's not mandatory to support power management interface */
 	apb->pwroff_gpio = of_get_named_gpio(np, "pwr-off-gpios", 0);
-	if (!gpio_is_valid(apb->pwroff_gpio)) {
+	if (apb->pwroff_gpio < 0) {
 		dev_info(dev, "failed to get power off gpio\n");
 		return apb->pwroff_gpio;
 	}
 
 	/* Do not make clock mandatory as of now (for DB3) */
 	apb->clk_en_gpio = of_get_named_gpio(np, "clock-en-gpio", 0);
-	if (!gpio_is_valid(apb->clk_en_gpio))
+	if (apb->clk_en_gpio < 0)
 		dev_err(dev, "failed to get clock en gpio\n");
 
 	apb->pwrdn_gpio = of_get_named_gpio(np, "pwr-down-gpios", 0);
-	if (!gpio_is_valid(apb->pwrdn_gpio))
+	if (apb->pwrdn_gpio < 0)
 		dev_info(dev, "failed to get power down gpio\n");
 
 	/* Regulators are optional, as we may have fixed supply coming in */

commit 977ff250755f4ae01ef50e98d792fabebb199c34
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Mon Jan 11 11:29:09 2016 +0530

    greybus: arche-apb: platform data 'apb' is guaranteed to be valid
    
    Platform data 'apb' is guaranteed to be valid in arche_apb_ctrl_remove()
    and so no need to check it.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Reviewed-by: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/arche-apb-ctrl.c b/drivers/staging/greybus/arche-apb-ctrl.c
index 4fe2d110c4ae..3d71093c4697 100644
--- a/drivers/staging/greybus/arche-apb-ctrl.c
+++ b/drivers/staging/greybus/arche-apb-ctrl.c
@@ -352,9 +352,7 @@ int arche_apb_ctrl_remove(struct platform_device *pdev)
 {
 	struct arche_apb_ctrl_drvdata *apb = platform_get_drvdata(pdev);
 
-	if (apb)
-		apb_ctrl_cleanup(apb);
-
+	apb_ctrl_cleanup(apb);
 	platform_set_drvdata(pdev, NULL);
 	unexport_gpios(apb);
 

commit 3b538c399c3273ec268f7c641c8ce35c1235763a
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Mon Jan 11 11:29:08 2016 +0530

    greybus: arche-apb: Spelling and whitespace fixes
    
    - s/premits/permits
    - Remove blank lines at the end of the file
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Reviewed-by: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/arche-apb-ctrl.c b/drivers/staging/greybus/arche-apb-ctrl.c
index 701cd5654449..4fe2d110c4ae 100644
--- a/drivers/staging/greybus/arche-apb-ctrl.c
+++ b/drivers/staging/greybus/arche-apb-ctrl.c
@@ -364,7 +364,7 @@ int arche_apb_ctrl_remove(struct platform_device *pdev)
 static int arche_apb_ctrl_suspend(struct device *dev)
 {
 	/*
-	 * If timing profile premits, we may shutdown bridge
+	 * If timing profile permits, we may shutdown bridge
 	 * completely
 	 *
 	 * TODO: sequence ??
@@ -392,5 +392,3 @@ static int arche_apb_ctrl_resume(struct device *dev)
 SIMPLE_DEV_PM_OPS(arche_apb_ctrl_pm_ops,
 		  arche_apb_ctrl_suspend,
 		  arche_apb_ctrl_resume);
-
-

commit e49268cc336eceb0653a03c4a0f9eb53eadf4d64
Author: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
Date:   Wed Jan 6 23:46:46 2016 +0530

    greybus: arche-apb-ctrl: Do not bring APB out of reset in probe
    
    With addition of handshaking between AP <=> SVC, driver
    brings out APB out of reset only on reception of WAKE_MOD
    signal from SVC. So remove the deassertion from probe.
    
    Signed-off-by: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/arche-apb-ctrl.c b/drivers/staging/greybus/arche-apb-ctrl.c
index d3db7fbb33b4..701cd5654449 100644
--- a/drivers/staging/greybus/arche-apb-ctrl.c
+++ b/drivers/staging/greybus/arche-apb-ctrl.c
@@ -338,8 +338,6 @@ int arche_apb_ctrl_probe(struct platform_device *pdev)
 
 	platform_set_drvdata(pdev, apb);
 
-	assert_gpio(apb->resetn_gpio);
-
 	export_gpios(apb);
 
 	dev_info(&pdev->dev, "Device registered successfully\n");

commit ae0bf3a62805fa80c8277dd293d9d9d9b8b4c7c0
Author: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
Date:   Wed Jan 6 23:46:45 2016 +0530

    greybus: arche-apb-ctrl: Set wake_detect gpio to low initially
    
    This patch enables handshaking of AP and SVC using wake_detect
    gpio (WD_8A and WD_8B).
    Note that WAKE_DETECT polarity is active-high, so in order to
    enable handshaking between AP <=> SVC, we need to set wake_detect
    gpio to low initially, so that driver can send WAKE_DET signal
    (active-high) to SVC and then SVC can send back WAKE_MOD signal
    (active-low).
    And on reception of WAKE_MOD signal, driver would bring respective
    APB out of reset.
    
      WD_8A => APB1
      WD_8B => APB2
    
    Signed-off-by: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/arche-apb-ctrl.c b/drivers/staging/greybus/arche-apb-ctrl.c
index 8046e1eced83..d3db7fbb33b4 100644
--- a/drivers/staging/greybus/arche-apb-ctrl.c
+++ b/drivers/staging/greybus/arche-apb-ctrl.c
@@ -195,7 +195,8 @@ static int apb_ctrl_init_seq(struct platform_device *pdev,
 	gpio_set_value(apb->boot_ret_gpio, 0);
 	udelay(50);
 
-	ret = devm_gpio_request(dev, apb->wake_detect_gpio, "wake detect");
+	ret = devm_gpio_request_one(dev, apb->wake_detect_gpio,
+			GPIOF_INIT_LOW, "wake detect");
 	if (ret)
 		dev_err(dev, "Failed requesting wake_detect gpio %d\n",
 				apb->wake_detect_gpio);

commit 6da86df3a4aa6dfbb9af350df4a908a7a9254be0
Author: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
Date:   Wed Jan 6 11:31:20 2016 +0530

    greybus: arche-platform: Export gpio (reset & sys_boot) to user
    
    In order to allow user to flash the firmware to,
    
    SVC:
    user need to assert the reset first, set sysboot pin and
    deassert reset. And then issue a flashing command.
    
    And APB:
    User need to assert the reset first, and then issue flashing
    command.
    
    So this patch exports the gpio's to user.
    
    Signed-off-by: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/arche-apb-ctrl.c b/drivers/staging/greybus/arche-apb-ctrl.c
index f02b8add6ebc..8046e1eced83 100644
--- a/drivers/staging/greybus/arche-apb-ctrl.c
+++ b/drivers/staging/greybus/arche-apb-ctrl.c
@@ -71,6 +71,17 @@ static inline void deassert_gpio(unsigned int gpio)
 	gpio_set_value(gpio, 0);
 }
 
+/* Export gpio's to user space */
+static void export_gpios(struct arche_apb_ctrl_drvdata *apb)
+{
+	gpio_export(apb->resetn_gpio, false);
+}
+
+static void unexport_gpios(struct arche_apb_ctrl_drvdata *apb)
+{
+	gpio_unexport(apb->resetn_gpio);
+}
+
 static irqreturn_t apb_ctrl_wake_detect_irq(int irq, void *devid)
 {
 	struct arche_apb_ctrl_drvdata *apb = devid;
@@ -328,6 +339,8 @@ int arche_apb_ctrl_probe(struct platform_device *pdev)
 
 	assert_gpio(apb->resetn_gpio);
 
+	export_gpios(apb);
+
 	dev_info(&pdev->dev, "Device registered successfully\n");
 	return 0;
 
@@ -344,6 +357,7 @@ int arche_apb_ctrl_remove(struct platform_device *pdev)
 		apb_ctrl_cleanup(apb);
 
 	platform_set_drvdata(pdev, NULL);
+	unexport_gpios(apb);
 
 	return 0;
 }

commit 1e5dd1f8279a8a934b9df7adec47b944fe6b10f4
Author: Greg Kroah-Hartman <gregkh@google.com>
Date:   Wed Dec 30 13:38:33 2015 -0800

    greybus: arche-platform: merge arche-apb-ctrl and arche-platform
    
    No need to have two separate arche platform drivers, that's just crazy,
    so merge them both together to be only one kernel module.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>
    Reviewed-by: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
    Tested-by: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>

diff --git a/drivers/staging/greybus/arche-apb-ctrl.c b/drivers/staging/greybus/arche-apb-ctrl.c
index 68f8d3cc8e97..f02b8add6ebc 100644
--- a/drivers/staging/greybus/arche-apb-ctrl.c
+++ b/drivers/staging/greybus/arche-apb-ctrl.c
@@ -23,6 +23,7 @@
 #include <linux/spinlock.h>
 #include <linux/regulator/consumer.h>
 #include <linux/pinctrl/consumer.h>
+#include "arche_platform.h"
 
 enum apb_state {
 	APB_STATE_OFF,
@@ -279,7 +280,7 @@ static void apb_ctrl_cleanup(struct arche_apb_ctrl_drvdata *apb)
 	/* TODO: May have to send an event to SVC about this exit */
 }
 
-static int arche_apb_ctrl_probe(struct platform_device *pdev)
+int arche_apb_ctrl_probe(struct platform_device *pdev)
 {
 	int ret;
 	struct arche_apb_ctrl_drvdata *apb;
@@ -335,7 +336,7 @@ static int arche_apb_ctrl_probe(struct platform_device *pdev)
 	return ret;
 }
 
-static int arche_apb_ctrl_remove(struct platform_device *pdev)
+int arche_apb_ctrl_remove(struct platform_device *pdev)
 {
 	struct arche_apb_ctrl_drvdata *apb = platform_get_drvdata(pdev);
 
@@ -375,28 +376,8 @@ static int arche_apb_ctrl_resume(struct device *dev)
 	return 0;
 }
 
-static SIMPLE_DEV_PM_OPS(arche_apb_ctrl_pm_ops,
-			arche_apb_ctrl_suspend,
-			arche_apb_ctrl_resume);
+SIMPLE_DEV_PM_OPS(arche_apb_ctrl_pm_ops,
+		  arche_apb_ctrl_suspend,
+		  arche_apb_ctrl_resume);
 
-static struct of_device_id arche_apb_ctrl_of_match[] = {
-	{ .compatible = "usbffff,2", },
-	{ },
-};
-MODULE_DEVICE_TABLE(of, arche_apb_ctrl_of_match);
-
-static struct platform_driver arche_apb_ctrl_device_driver = {
-	.probe		= arche_apb_ctrl_probe,
-	.remove		= arche_apb_ctrl_remove,
-	.driver		= {
-		.name	= "arche-apb-ctrl",
-		.pm	= &arche_apb_ctrl_pm_ops,
-		.of_match_table = of_match_ptr(arche_apb_ctrl_of_match),
-	}
-};
-
-module_platform_driver(arche_apb_ctrl_device_driver);
 
-MODULE_LICENSE("GPL");
-MODULE_AUTHOR("Vaibhav Hiremath <vaibhav.hiremath@linaro.org>");
-MODULE_DESCRIPTION("Arche APB control Driver");

commit 166f0aed325f7bcb7c1ee8c2665d5cb05d36d931
Author: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
Date:   Wed Dec 16 16:29:20 2015 +0530

    greybus: arche-apb-ctrl: Assert reset to APB at the end of probe
    
    Until we have proper handshake mechanism implemented with SVC
    assert reset to APB at the end of probe.
    We are safe here to do that, as SVC always enables clock to APB's
    currently.
    And also from EVT1 perspective, we should be good, as clock control
    signals are now moved to AP.
    
    Signed-off-by: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/arche-apb-ctrl.c b/drivers/staging/greybus/arche-apb-ctrl.c
index efc1e42f8c61..68f8d3cc8e97 100644
--- a/drivers/staging/greybus/arche-apb-ctrl.c
+++ b/drivers/staging/greybus/arche-apb-ctrl.c
@@ -325,6 +325,8 @@ static int arche_apb_ctrl_probe(struct platform_device *pdev)
 
 	platform_set_drvdata(pdev, apb);
 
+	assert_gpio(apb->resetn_gpio);
+
 	dev_info(&pdev->dev, "Device registered successfully\n");
 	return 0;
 

commit 5a78178718b9e50ee60a1129431758125cfa2f6a
Author: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
Date:   Wed Dec 16 16:29:19 2015 +0530

    greybus: arche-apb-ctrl: Add APB control driver
    
    It was messy to integrate both SVC, APB (and any other arche
    platform specific control) into one single driver. Especially
    due to cross-dependency.
    
    AP first needs to bringup SVC, as SVC should enable clock to APB.
    APB should come up before HUB, as due to some reason HUB wouldn't
    enumerate APB's is APB comes up later.
    And on top of that we should have clean picture of hardware description
    in DT file.
    
    So this patch introduces APB control driver. Mostly copied from original
    arche-platform driver + fixed boot sequence.
    
    Signed-off-by: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/arche-apb-ctrl.c b/drivers/staging/greybus/arche-apb-ctrl.c
new file mode 100644
index 000000000000..efc1e42f8c61
--- /dev/null
+++ b/drivers/staging/greybus/arche-apb-ctrl.c
@@ -0,0 +1,400 @@
+/*
+ * Arche Platform driver to control APB.
+ *
+ * Copyright 2014-2015 Google Inc.
+ * Copyright 2014-2015 Linaro Ltd.
+ *
+ * Released under the GPLv2 only.
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/sched.h>
+#include <linux/pm.h>
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+#include <linux/gpio.h>
+#include <linux/clk.h>
+#include <linux/of_platform.h>
+#include <linux/of_gpio.h>
+#include <linux/of_irq.h>
+#include <linux/spinlock.h>
+#include <linux/regulator/consumer.h>
+#include <linux/pinctrl/consumer.h>
+
+enum apb_state {
+	APB_STATE_OFF,
+	APB_STATE_ACTIVE,
+	APB_STATE_STANDBY,
+};
+
+struct arche_apb_ctrl_drvdata {
+	/* Control GPIO signals to and from AP <=> AP Bridges */
+	int wake_detect_gpio; /* bi-dir,maps to WAKE_MOD & WAKE_FRAME signals */
+	int resetn_gpio;
+	int boot_ret_gpio;
+	int pwroff_gpio;
+	int wake_in_gpio;
+	int wake_out_gpio;
+	int pwrdn_gpio;
+
+	unsigned int wake_detect_irq;
+	enum apb_state state;
+
+	struct regulator *vcore;
+	struct regulator *vio;
+
+	unsigned int clk_en_gpio;
+	struct clk *clk;
+
+	struct pinctrl *pinctrl;
+	struct pinctrl_state *pin_default;
+
+	/* To protect concurrent access of GPIO registers, need protection */
+	spinlock_t lock;
+};
+
+/*
+ * Note that these low level api's are active high
+ */
+static inline void assert_gpio(unsigned int gpio)
+{
+	gpio_set_value(gpio, 1);
+	msleep(500);
+}
+
+static inline void deassert_gpio(unsigned int gpio)
+{
+	gpio_set_value(gpio, 0);
+}
+
+static irqreturn_t apb_ctrl_wake_detect_irq(int irq, void *devid)
+{
+	struct arche_apb_ctrl_drvdata *apb = devid;
+	unsigned long flags;
+
+	/*
+	 * TODO:
+	 * Since currently SoC GPIOs are being used we are safe here
+	 * But ideally we should create a workqueue and process the control
+	 * signals, especially when we start using GPIOs over slow
+	 * buses like I2C.
+	 */
+	if (!gpio_is_valid(apb->wake_detect_gpio) &&
+			!gpio_is_valid(apb->resetn_gpio))
+		return IRQ_HANDLED; /* Should it be IRQ_NONE ?? */
+
+	spin_lock_irqsave(&apb->lock, flags);
+
+	if (apb->state != APB_STATE_ACTIVE) {
+		/* Bring bridge out of reset on this event */
+		gpio_set_value(apb->resetn_gpio, 1);
+		apb->state = APB_STATE_ACTIVE;
+	} else {
+		/*
+		 * Assert Wake_OUT signal to APB
+		 * It would resemble WakeDetect module's signal pass-through
+		 */
+		/*
+		 * We have to generate the pulse, so we may need to schedule
+		 * workqueue here.
+		 *
+		 * Also, since we are using both rising and falling edge for
+		 * interrupt trigger, we may not need workqueue. Just pass
+		 * through the value to bridge.
+		 * Just read GPIO value and pass it to the bridge
+		 */
+	}
+
+	spin_unlock_irqrestore(&apb->lock, flags);
+
+	return IRQ_HANDLED;
+}
+
+/*
+ * Note: Please do not modify the below sequence, as it is as per the spec
+ */
+static int apb_ctrl_init_seq(struct platform_device *pdev,
+		struct arche_apb_ctrl_drvdata *apb)
+{
+	struct device *dev = &pdev->dev;
+	int ret;
+
+	/* On DB3 clock was not mandatory */
+	if (gpio_is_valid(apb->clk_en_gpio)) {
+		ret = devm_gpio_request(dev, apb->clk_en_gpio, "apb_clk_en");
+		if (ret)
+			dev_err(dev, "Failed requesting APB clock en gpio %d\n",
+					apb->clk_en_gpio);
+		ret = gpio_direction_output(apb->clk_en_gpio, 1);
+		if (ret)
+			dev_err(dev, "failed to set APB clock en gpio dir:%d\n", ret);
+	}
+	/* Hold APB in reset state */
+	ret = devm_gpio_request(dev, apb->resetn_gpio, "apb-reset");
+	if (ret) {
+		dev_err(dev, "Failed requesting reset gpio %d\n",
+				apb->resetn_gpio);
+		return ret;
+	}
+	ret = gpio_direction_output(apb->resetn_gpio, 0);
+	if (ret) {
+		dev_err(dev, "failed to set reset gpio dir:%d\n", ret);
+		return ret;
+	}
+
+	ret = devm_gpio_request(dev, apb->pwroff_gpio, "pwroff_n");
+	if (ret) {
+		dev_err(dev, "Failed requesting pwroff_n gpio %d\n",
+				apb->pwroff_gpio);
+		return ret;
+	}
+	ret = gpio_direction_input(apb->pwroff_gpio);
+	if (ret) {
+		dev_err(dev, "failed to set pwroff gpio dir:%d\n", ret);
+		return ret;
+	}
+
+	/* Enable power to APB */
+	if (apb->vcore) {
+		ret = regulator_enable(apb->vcore);
+		if (ret) {
+			dev_err(dev, "failed to enable core regulator\n");
+			return ret;
+		}
+	}
+	if (apb->vio) {
+		ret = regulator_enable(apb->vio);
+		if (ret) {
+			dev_err(dev, "failed to enable IO regulator\n");
+			return ret;
+		}
+	}
+
+	ret = devm_gpio_request_one(dev, apb->boot_ret_gpio,
+			GPIOF_OUT_INIT_LOW, "boot retention");
+	if (ret) {
+		dev_err(dev, "Failed requesting bootret gpio %d\n",
+				apb->boot_ret_gpio);
+		return ret;
+	}
+	gpio_set_value(apb->boot_ret_gpio, 0);
+	udelay(50);
+
+	ret = devm_gpio_request(dev, apb->wake_detect_gpio, "wake detect");
+	if (ret)
+		dev_err(dev, "Failed requesting wake_detect gpio %d\n",
+				apb->wake_detect_gpio);
+
+	return ret;
+}
+
+static int apb_ctrl_get_devtree_data(struct platform_device *pdev,
+		struct arche_apb_ctrl_drvdata *apb)
+{
+	struct device *dev = &pdev->dev;
+	struct device_node *np = dev->of_node;
+
+	apb->wake_detect_gpio = of_get_named_gpio(np, "wake-detect-gpios", 0);
+	if (!gpio_is_valid(apb->wake_detect_gpio)) {
+		dev_err(dev, "failed to get wake detect gpio\n");
+		return apb->wake_detect_gpio;
+	}
+
+	apb->resetn_gpio = of_get_named_gpio(np, "reset-gpios", 0);
+	if (!gpio_is_valid(apb->resetn_gpio)) {
+		dev_err(dev, "failed to get reset gpio\n");
+		return apb->resetn_gpio;
+	}
+
+	apb->boot_ret_gpio = of_get_named_gpio(np, "boot-ret-gpios", 0);
+	if (!gpio_is_valid(apb->boot_ret_gpio)) {
+		dev_err(dev, "failed to get boot retention gpio\n");
+		return apb->boot_ret_gpio;
+	}
+
+	/* It's not mandatory to support power management interface */
+	apb->pwroff_gpio = of_get_named_gpio(np, "pwr-off-gpios", 0);
+	if (!gpio_is_valid(apb->pwroff_gpio)) {
+		dev_info(dev, "failed to get power off gpio\n");
+		return apb->pwroff_gpio;
+	}
+
+	/* Do not make clock mandatory as of now (for DB3) */
+	apb->clk_en_gpio = of_get_named_gpio(np, "clock-en-gpio", 0);
+	if (!gpio_is_valid(apb->clk_en_gpio))
+		dev_err(dev, "failed to get clock en gpio\n");
+
+	apb->pwrdn_gpio = of_get_named_gpio(np, "pwr-down-gpios", 0);
+	if (!gpio_is_valid(apb->pwrdn_gpio))
+		dev_info(dev, "failed to get power down gpio\n");
+
+	/* Regulators are optional, as we may have fixed supply coming in */
+	apb->vcore = devm_regulator_get(dev, "vcore");
+	if (IS_ERR_OR_NULL(apb->vcore)) {
+		dev_info(dev, "no core regulator found\n");
+		apb->vcore = NULL;
+	}
+
+	apb->vio = devm_regulator_get(dev, "vio");
+	if (IS_ERR_OR_NULL(apb->vio)) {
+		dev_info(dev, "no IO regulator found\n");
+		apb->vio = NULL;
+	}
+
+	apb->pinctrl = devm_pinctrl_get(&pdev->dev);
+	if (IS_ERR(apb->pinctrl)) {
+		dev_err(&pdev->dev, "could not get pinctrl handle\n");
+		return PTR_ERR(apb->pinctrl);
+	}
+	apb->pin_default = pinctrl_lookup_state(apb->pinctrl, "default");
+	if (IS_ERR(apb->pin_default)) {
+		dev_err(&pdev->dev, "could not get default pin state\n");
+		return PTR_ERR(apb->pin_default);
+	}
+
+	return 0;
+}
+
+static void apb_ctrl_cleanup(struct arche_apb_ctrl_drvdata *apb)
+{
+	unsigned long flags;
+
+	if (apb->vcore && regulator_is_enabled(apb->vcore) > 0)
+		regulator_disable(apb->vcore);
+
+	if (apb->vio && regulator_is_enabled(apb->vio) > 0)
+		regulator_disable(apb->vio);
+
+	spin_lock_irqsave(&apb->lock, flags);
+	/* As part of exit, put APB back in reset state */
+	if (gpio_is_valid(apb->resetn_gpio))
+		gpio_set_value(apb->resetn_gpio, 0);
+
+	apb->state = APB_STATE_OFF;
+	spin_unlock_irqrestore(&apb->lock, flags);
+
+	/* TODO: May have to send an event to SVC about this exit */
+}
+
+static int arche_apb_ctrl_probe(struct platform_device *pdev)
+{
+	int ret;
+	struct arche_apb_ctrl_drvdata *apb;
+	struct device *dev = &pdev->dev;
+
+	apb = devm_kzalloc(&pdev->dev, sizeof(*apb), GFP_KERNEL);
+	if (!apb)
+		return -ENOMEM;
+
+	ret = apb_ctrl_get_devtree_data(pdev, apb);
+	if (ret) {
+		dev_err(dev, "failed to get apb devicetree data %d\n", ret);
+		return ret;
+	}
+
+	ret = apb_ctrl_init_seq(pdev, apb);
+	if (ret) {
+		dev_err(dev, "failed to set init state of control signal %d\n",
+				ret);
+		goto exit;
+	}
+
+	spin_lock_init(&apb->lock);
+
+	apb->state = APB_STATE_OFF;
+	/*
+	 * Assert AP module detect signal by pulling wake_detect low
+	 */
+	assert_gpio(apb->wake_detect_gpio);
+
+	/*
+	 * In order to receive an interrupt, the GPIO must be set to input mode
+	 */
+	gpio_direction_input(apb->wake_detect_gpio);
+
+	ret = devm_request_irq(dev, gpio_to_irq(apb->wake_detect_gpio),
+			apb_ctrl_wake_detect_irq, IRQF_TRIGGER_FALLING,
+			"wake detect", apb);
+	if (ret) {
+		dev_err(dev, "failed to request wake detect IRQ\n");
+		goto exit;
+	}
+
+	platform_set_drvdata(pdev, apb);
+
+	dev_info(&pdev->dev, "Device registered successfully\n");
+	return 0;
+
+exit:
+	apb_ctrl_cleanup(apb);
+	return ret;
+}
+
+static int arche_apb_ctrl_remove(struct platform_device *pdev)
+{
+	struct arche_apb_ctrl_drvdata *apb = platform_get_drvdata(pdev);
+
+	if (apb)
+		apb_ctrl_cleanup(apb);
+
+	platform_set_drvdata(pdev, NULL);
+
+	return 0;
+}
+
+static int arche_apb_ctrl_suspend(struct device *dev)
+{
+	/*
+	 * If timing profile premits, we may shutdown bridge
+	 * completely
+	 *
+	 * TODO: sequence ??
+	 *
+	 * Also, need to make sure we meet precondition for unipro suspend
+	 * Precondition: Definition ???
+	 */
+	return 0;
+}
+
+static int arche_apb_ctrl_resume(struct device *dev)
+{
+	/*
+	 * Atleast for ES2 we have to meet the delay requirement between
+	 * unipro switch and AP bridge init, depending on whether bridge is in
+	 * OFF state or standby state.
+	 *
+	 * Based on whether bridge is in standby or OFF state we may have to
+	 * assert multiple signals. Please refer to WDM spec, for more info.
+	 *
+	 */
+	return 0;
+}
+
+static SIMPLE_DEV_PM_OPS(arche_apb_ctrl_pm_ops,
+			arche_apb_ctrl_suspend,
+			arche_apb_ctrl_resume);
+
+static struct of_device_id arche_apb_ctrl_of_match[] = {
+	{ .compatible = "usbffff,2", },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, arche_apb_ctrl_of_match);
+
+static struct platform_driver arche_apb_ctrl_device_driver = {
+	.probe		= arche_apb_ctrl_probe,
+	.remove		= arche_apb_ctrl_remove,
+	.driver		= {
+		.name	= "arche-apb-ctrl",
+		.pm	= &arche_apb_ctrl_pm_ops,
+		.of_match_table = of_match_ptr(arche_apb_ctrl_of_match),
+	}
+};
+
+module_platform_driver(arche_apb_ctrl_device_driver);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Vaibhav Hiremath <vaibhav.hiremath@linaro.org>");
+MODULE_DESCRIPTION("Arche APB control Driver");
