commit 3b75d8bd3be49ffb4878f2370dc565a36e11fe07
Author: Till Varoquaux <till.varoquaux@gmail.com>
Date:   Mon May 25 02:10:43 2020 -0400

    staging: greybus: loopback: fix a spelling error.
    
    Successed -> succeeded.
    
    Signed-off-by: Till Varoquaux <till.varoquaux@gmail.com>
    Reviewed-by: Alex Elder <elder@linaro.org>
    Link: https://lore.kernel.org/r/20200518051314.1785567-1-till.varoquaux@gmail.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/loopback.c b/drivers/staging/greybus/loopback.c
index 583d9708a191..2471448ba42a 100644
--- a/drivers/staging/greybus/loopback.c
+++ b/drivers/staging/greybus/loopback.c
@@ -135,7 +135,7 @@ static ssize_t name##_##field##_show(struct device *dev,	\
 			    char *buf)					\
 {									\
 	struct gb_loopback *gb = dev_get_drvdata(dev);			\
-	/* Report 0 for min and max if no transfer successed */		\
+	/* Report 0 for min and max if no transfer succeeded */		\
 	if (!gb->requests_completed)					\
 		return sprintf(buf, "0\n");				\
 	return sprintf(buf, "%" #type "\n", gb->name.field);		\

commit ec0ad868173da8a75121f9dc116a5d5478ff614d
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Sun Aug 25 07:54:27 2019 +0200

    staging: greybus: move core include files to include/linux/greybus/
    
    With the goal of moving the core of the greybus code out of staging, the
    include files need to be moved to include/linux/greybus.h and
    include/linux/greybus/
    
    Cc: Vaibhav Hiremath <hvaibhav.linux@gmail.com>
    Cc: Johan Hovold <johan@kernel.org>
    Cc: Vaibhav Agarwal <vaibhav.sr@gmail.com>
    Cc: Rui Miguel Silva <rmfrfs@gmail.com>
    Cc: David Lin <dtwlin@gmail.com>
    Cc: "Bryan O'Donoghue" <pure.logic@nexus-software.ie>
    Cc: greybus-dev@lists.linaro.org
    Cc: devel@driverdev.osuosl.org
    Acked-by: Mark Greer <mgreer@animalcreek.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Acked-by: Alex Elder <elder@kernel.org>
    Link: https://lore.kernel.org/r/20190825055429.18547-8-gregkh@linuxfoundation.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/loopback.c b/drivers/staging/greybus/loopback.c
index b0ab0eed5c18..583d9708a191 100644
--- a/drivers/staging/greybus/loopback.c
+++ b/drivers/staging/greybus/loopback.c
@@ -25,12 +25,9 @@
 #include <linux/workqueue.h>
 #include <linux/atomic.h>
 #include <linux/pm_runtime.h>
-
+#include <linux/greybus.h>
 #include <asm/div64.h>
 
-#include "greybus.h"
-#include "connection.h"
-
 #define NSEC_PER_DAY 86400000000000ULL
 
 struct gb_loopback_stats {

commit 9c31973907fb157ac91f61f479e8bf43bb43aded
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Sun Aug 25 07:54:26 2019 +0200

    staging: greybus: loopback: Fix up some alignment checkpatch issues
    
    Some function prototypes do not match the expected alignment formatting
    so fix that up so that checkpatch is happy.
    
    Cc: "Bryan O'Donoghue" <pure.logic@nexus-software.ie>
    Cc: Johan Hovold <johan@kernel.org>
    Cc: greybus-dev@lists.linaro.org
    Cc: devel@driverdev.osuosl.org
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Acked-by: Alex Elder <elder@kernel.org>
    Link: https://lore.kernel.org/r/20190825055429.18547-7-gregkh@linuxfoundation.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/loopback.c b/drivers/staging/greybus/loopback.c
index 48d85ebe404a..b0ab0eed5c18 100644
--- a/drivers/staging/greybus/loopback.c
+++ b/drivers/staging/greybus/loopback.c
@@ -882,7 +882,7 @@ static int gb_loopback_fn(void *data)
 				gb->type = 0;
 				gb->send_count = 0;
 				sysfs_notify(&gb->dev->kobj,  NULL,
-						"iteration_count");
+					     "iteration_count");
 				dev_dbg(&bundle->dev, "load test complete\n");
 			} else {
 				dev_dbg(&bundle->dev,
@@ -1054,7 +1054,7 @@ static int gb_loopback_probe(struct gb_bundle *bundle,
 
 	/* Allocate kfifo */
 	if (kfifo_alloc(&gb->kfifo_lat, kfifo_depth * sizeof(u32),
-			  GFP_KERNEL)) {
+			GFP_KERNEL)) {
 		retval = -ENOMEM;
 		goto out_conn;
 	}

commit 0022290f1e12e87512d37dec702cab2090a91dc4
Author: Yangtao Li <tiny.windzz@gmail.com>
Date:   Sat Dec 15 03:53:12 2018 -0500

    staging: greybus: convert to DEFINE_SHOW_ATTRIBUTE
    
    Use DEFINE_SHOW_ATTRIBUTE macro to simplify the code.
    
    Signed-off-by: Yangtao Li <tiny.windzz@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/loopback.c b/drivers/staging/greybus/loopback.c
index 28973c246474..48d85ebe404a 100644
--- a/drivers/staging/greybus/loopback.c
+++ b/drivers/staging/greybus/loopback.c
@@ -970,19 +970,7 @@ static int gb_loopback_dbgfs_latency_show(struct seq_file *s, void *unused)
 	return gb_loopback_dbgfs_latency_show_common(s, &gb->kfifo_lat,
 						     &gb->mutex);
 }
-
-static int gb_loopback_latency_open(struct inode *inode, struct file *file)
-{
-	return single_open(file, gb_loopback_dbgfs_latency_show,
-			   inode->i_private);
-}
-
-static const struct file_operations gb_loopback_debugfs_latency_ops = {
-	.open		= gb_loopback_latency_open,
-	.read		= seq_read,
-	.llseek		= seq_lseek,
-	.release	= single_release,
-};
+DEFINE_SHOW_ATTRIBUTE(gb_loopback_dbgfs_latency);
 
 #define DEBUGFS_NAMELEN 32
 
@@ -1042,7 +1030,7 @@ static int gb_loopback_probe(struct gb_bundle *bundle,
 	snprintf(name, sizeof(name), "raw_latency_%s",
 		 dev_name(&connection->bundle->dev));
 	gb->file = debugfs_create_file(name, S_IFREG | 0444, gb_dev.root, gb,
-				       &gb_loopback_debugfs_latency_ops);
+				       &gb_loopback_dbgfs_latency_fops);
 
 	gb->id = ida_simple_get(&loopback_ida, 0, 0, GFP_KERNEL);
 	if (gb->id < 0) {

commit 0668d5b5921c82e82bc6f5fa97baec5a50e92ab4
Author: Cristian Sicilia <sicilia.cristian@gmail.com>
Date:   Tue Dec 4 21:58:20 2018 +0100

    staging: greybus: Added space between string concatenated
    
    Some concatenated strings are now spaced.
    
    Signed-off-by: Cristian Sicilia <sicilia.cristian@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/loopback.c b/drivers/staging/greybus/loopback.c
index e4d42c1dc284..28973c246474 100644
--- a/drivers/staging/greybus/loopback.c
+++ b/drivers/staging/greybus/loopback.c
@@ -141,7 +141,7 @@ static ssize_t name##_##field##_show(struct device *dev,	\
 	/* Report 0 for min and max if no transfer successed */		\
 	if (!gb->requests_completed)					\
 		return sprintf(buf, "0\n");				\
-	return sprintf(buf, "%"#type"\n", gb->name.field);	\
+	return sprintf(buf, "%" #type "\n", gb->name.field);		\
 }									\
 static DEVICE_ATTR_RO(name##_##field)
 
@@ -176,7 +176,7 @@ static ssize_t field##_show(struct device *dev,				\
 			    char *buf)					\
 {									\
 	struct gb_loopback *gb = dev_get_drvdata(dev);			\
-	return sprintf(buf, "%"#type"\n", gb->field);			\
+	return sprintf(buf, "%" #type "\n", gb->field);			\
 }									\
 static ssize_t field##_store(struct device *dev,			\
 			    struct device_attribute *attr,		\
@@ -212,7 +212,7 @@ static ssize_t field##_show(struct device *dev,				\
 			    char *buf)					\
 {									\
 	struct gb_loopback *gb = dev_get_drvdata(dev);			\
-	return sprintf(buf, "%"#type"\n", gb->field);			\
+	return sprintf(buf, "%" #type "\n", gb->field);			\
 }									\
 static ssize_t field##_store(struct device *dev,			\
 			    struct device_attribute *attr,		\

commit c49d3f3fa686dd03112de4c97f652dc67e4da7af
Author: Rasmus Villemoes <linux@rasmusvillemoes.dk>
Date:   Wed Oct 24 11:48:20 2018 +0100

    staging: greybus: loopback.c: remove unused lists
    
    gb_loopback_device::list_op_async is never used except for the
    LIST_INIT. The ::list field appears to have a few more uses, but on
    closer inspection the linked list of struct gb_loopbacks that it heads
    is never used for anything, so there's no reason to maintain it, much
    less to keep it sorted.
    
    Reviewed-by: Bryan O'Donoghue <pure.logic@nexus-software.ie>
    Signed-off-by: Rasmus Villemoes <linux@rasmusvillemoes.dk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/loopback.c b/drivers/staging/greybus/loopback.c
index 7080294f705c..e4d42c1dc284 100644
--- a/drivers/staging/greybus/loopback.c
+++ b/drivers/staging/greybus/loopback.c
@@ -47,8 +47,6 @@ struct gb_loopback_device {
 
 	/* We need to take a lock in atomic context */
 	spinlock_t lock;
-	struct list_head list;
-	struct list_head list_op_async;
 	wait_queue_head_t wq;
 };
 
@@ -68,7 +66,6 @@ struct gb_loopback {
 	struct kfifo kfifo_lat;
 	struct mutex mutex;
 	struct task_struct *task;
-	struct list_head entry;
 	struct device *dev;
 	wait_queue_head_t wq;
 	wait_queue_head_t wq_completion;
@@ -987,37 +984,6 @@ static const struct file_operations gb_loopback_debugfs_latency_ops = {
 	.release	= single_release,
 };
 
-static int gb_loopback_bus_id_compare(void *priv, struct list_head *lha,
-				      struct list_head *lhb)
-{
-	struct gb_loopback *a = list_entry(lha, struct gb_loopback, entry);
-	struct gb_loopback *b = list_entry(lhb, struct gb_loopback, entry);
-	struct gb_connection *ca = a->connection;
-	struct gb_connection *cb = b->connection;
-
-	if (ca->bundle->intf->interface_id < cb->bundle->intf->interface_id)
-		return -1;
-	if (cb->bundle->intf->interface_id < ca->bundle->intf->interface_id)
-		return 1;
-	if (ca->bundle->id < cb->bundle->id)
-		return -1;
-	if (cb->bundle->id < ca->bundle->id)
-		return 1;
-	if (ca->intf_cport_id < cb->intf_cport_id)
-		return -1;
-	else if (cb->intf_cport_id < ca->intf_cport_id)
-		return 1;
-
-	return 0;
-}
-
-static void gb_loopback_insert_id(struct gb_loopback *gb)
-{
-	/* perform an insertion sort */
-	list_add_tail(&gb->entry, &gb_dev.list);
-	list_sort(NULL, &gb_dev.list, gb_loopback_bus_id_compare);
-}
-
 #define DEBUGFS_NAMELEN 32
 
 static int gb_loopback_probe(struct gb_bundle *bundle,
@@ -1113,7 +1079,6 @@ static int gb_loopback_probe(struct gb_bundle *bundle,
 	}
 
 	spin_lock_irqsave(&gb_dev.lock, flags);
-	gb_loopback_insert_id(gb);
 	gb_dev.count++;
 	spin_unlock_irqrestore(&gb_dev.lock, flags);
 
@@ -1169,7 +1134,6 @@ static void gb_loopback_disconnect(struct gb_bundle *bundle)
 
 	spin_lock_irqsave(&gb_dev.lock, flags);
 	gb_dev.count--;
-	list_del(&gb->entry);
 	spin_unlock_irqrestore(&gb_dev.lock, flags);
 
 	device_unregister(gb->dev);
@@ -1196,8 +1160,6 @@ static int loopback_init(void)
 {
 	int retval;
 
-	INIT_LIST_HEAD(&gb_dev.list);
-	INIT_LIST_HEAD(&gb_dev.list_op_async);
 	spin_lock_init(&gb_dev.lock);
 	gb_dev.root = debugfs_create_dir("gb_loopback", NULL);
 

commit b4fc4e8340784e000030c5a59bf0791f9c3ce15e
Author: Rasmus Villemoes <linux@rasmusvillemoes.dk>
Date:   Fri Oct 5 16:28:24 2018 +0200

    staging: greybus: loopback.c: remove unused gb_loopback::lbid
    
    It's not obvious how the code prevents adding more than 31 elements to
    the list and thus invoking undefined behaviour in the 1 << new_lbid
    expression, and in practice causing ->lbid values to repeat every 32
    elements.
    
    But the definition of struct gb_loopback is local to loopback.c, and the
    lbid field is entirely unused outside of this function, so it seems we
    can just drop it entirely.
    
    Signed-off-by: Rasmus Villemoes <linux@rasmusvillemoes.dk>
    Reviewed-by: Bryan O'Donoghue <pure.logic@nexus-software.ie>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/loopback.c b/drivers/staging/greybus/loopback.c
index 42f6f3de967c..7080294f705c 100644
--- a/drivers/staging/greybus/loopback.c
+++ b/drivers/staging/greybus/loopback.c
@@ -97,7 +97,6 @@ struct gb_loopback {
 	u32 timeout_min;
 	u32 timeout_max;
 	u32 outstanding_operations_max;
-	u32 lbid;
 	u64 elapsed_nsecs;
 	u32 apbridge_latency_ts;
 	u32 gbphy_latency_ts;
@@ -1014,16 +1013,9 @@ static int gb_loopback_bus_id_compare(void *priv, struct list_head *lha,
 
 static void gb_loopback_insert_id(struct gb_loopback *gb)
 {
-	struct gb_loopback *gb_list;
-	u32 new_lbid = 0;
-
 	/* perform an insertion sort */
 	list_add_tail(&gb->entry, &gb_dev.list);
 	list_sort(NULL, &gb_dev.list, gb_loopback_bus_id_compare);
-	list_for_each_entry(gb_list, &gb_dev.list, entry) {
-		gb_list->lbid = 1 << new_lbid;
-		new_lbid++;
-	}
 }
 
 #define DEBUGFS_NAMELEN 32

commit 863dbc52e7f0e5acd7b4883f3933543a81c474c7
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Nov 7 14:58:42 2017 +0100

    staging: greybus: Remove redundant license text
    
    Now that the SPDX tag is in all greybus files, that identifies the
    license in a specific and legally-defined manner.  So the extra GPL text
    wording can be removed as it is no longer needed at all.
    
    This is done on a quest to remove the 700+ different ways that files in
    the kernel describe the GPL license text.  And there's unneeded stuff
    like the address (sometimes incorrect) for the FSF which is never
    needed.
    
    No copyright headers or other non-license-description text was removed.
    
    Cc: Vaibhav Hiremath <hvaibhav.linux@gmail.com>
    Reviewed-by: Alex Elder <elder@linaro.org>
    Acked-by: Vaibhav Agarwal <vaibhav.sr@gmail.com>
    Acked-by: David Lin <dtwlin@gmail.com>
    Acked-by: Johan Hovold <johan@kernel.org>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Acked-by: Mark Greer <mgreer@animalcreek.com>
    Acked-by: Rui Miguel Silva <rmfrfs@gmail.com>
    Acked-by: "Bryan O'Donoghue" <pure.logic@nexus-software.ie>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/loopback.c b/drivers/staging/greybus/loopback.c
index 9c4367e674ab..42f6f3de967c 100644
--- a/drivers/staging/greybus/loopback.c
+++ b/drivers/staging/greybus/loopback.c
@@ -4,8 +4,6 @@
  *
  * Copyright 2014 Google Inc.
  * Copyright 2014 Linaro Ltd.
- *
- * Released under the GPLv2 only.
  */
 
 #define pr_fmt(fmt) KBUILD_MODNAME ": " fmt

commit eb50fd3a22c770f36be275295b782f3ea52e3215
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Nov 7 14:58:41 2017 +0100

    staging: greybus: add SPDX identifiers to all greybus driver files
    
    It's good to have SPDX identifiers in all files to make it easier to
    audit the kernel tree for correct licenses.
    
    Update the drivers/staging/greybus files files with the correct SPDX
    license identifier based on the license text in the file itself.  The
    SPDX identifier is a legally binding shorthand, which can be used
    instead of the full boiler plate text.
    
    This work is based on a script and data from Thomas Gleixner, Philippe
    Ombredanne, and Kate Stewart.
    
    Cc: Vaibhav Hiremath <hvaibhav.linux@gmail.com>
    Cc: "Bryan O'Donoghue" <pure.logic@nexus-software.ie>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: Philippe Ombredanne <pombredanne@nexb.com>
    Acked-by: Vaibhav Agarwal <vaibhav.sr@gmail.com>
    Acked-by: David Lin <dtwlin@gmail.com>
    Reviewed-by: Alex Elder <elder@linaro.org>
    Acked-by: Johan Hovold <johan@kernel.org>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Acked-by: Mark Greer <mgreer@animalcreek.com>
    Acked-by: Rui Miguel Silva <rmfrfs@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/loopback.c b/drivers/staging/greybus/loopback.c
index 6d51998b74b4..9c4367e674ab 100644
--- a/drivers/staging/greybus/loopback.c
+++ b/drivers/staging/greybus/loopback.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * Loopback bridge driver for the Greybus loopback module.
  *

commit 262edc359d429488af243eb45e007d360a738211
Author: Bryan O'Donoghue <pure.logic@nexus-software.ie>
Date:   Mon Nov 6 01:32:22 2017 +0000

    staging: greybus: loopback: convert loopback to use generic async operations
    
    Loopback has its own internal method for tracking and timing out
    asynchronous operations however previous patches make it possible to use
    functionality provided by operation.c to do this instead. Using the code in
    operation.c means we can completely subtract the timer, the work-queue, the
    kref and the cringe-worthy 'pending' flag. The completion callback
    triggered by operation.c will provide an authoritative result code -
    including -ETIMEDOUT for asynchronous operations.
    
    Signed-off-by: Bryan O'Donoghue <pure.logic@nexus-software.ie>
    Reviewed-by: Johan Hovold <johan@kernel.org>
    Cc: Alex Elder <elder@kernel.org>
    Cc: Kees Cook <keescook@chromium.org>
    Cc: Mitch Tasman <tasman@leaflabs.com>
    Cc: greybus-dev@lists.linaro.org
    Cc: devel@driverdev.osuosl.org
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/loopback.c b/drivers/staging/greybus/loopback.c
index 9c5980cc7791..6d51998b74b4 100644
--- a/drivers/staging/greybus/loopback.c
+++ b/drivers/staging/greybus/loopback.c
@@ -59,11 +59,6 @@ struct gb_loopback_async_operation {
 	struct gb_loopback *gb;
 	struct gb_operation *operation;
 	ktime_t ts;
-	struct timer_list timer;
-	struct list_head entry;
-	struct work_struct work;
-	struct kref kref;
-	bool pending;
 	int (*completion)(struct gb_loopback_async_operation *op_async);
 };
 
@@ -427,56 +422,6 @@ static int gb_loopback_operation_sync(struct gb_loopback *gb, int type,
 	return ret;
 }
 
-static void __gb_loopback_async_operation_destroy(struct kref *kref)
-{
-	struct gb_loopback_async_operation *op_async;
-
-	op_async = container_of(kref, struct gb_loopback_async_operation, kref);
-
-	list_del(&op_async->entry);
-	if (op_async->operation)
-		gb_operation_put(op_async->operation);
-	atomic_dec(&op_async->gb->outstanding_operations);
-	wake_up(&op_async->gb->wq_completion);
-	kfree(op_async);
-}
-
-static void gb_loopback_async_operation_get(struct gb_loopback_async_operation
-					    *op_async)
-{
-	kref_get(&op_async->kref);
-}
-
-static void gb_loopback_async_operation_put(struct gb_loopback_async_operation
-					    *op_async)
-{
-	unsigned long flags;
-
-	spin_lock_irqsave(&gb_dev.lock, flags);
-	kref_put(&op_async->kref, __gb_loopback_async_operation_destroy);
-	spin_unlock_irqrestore(&gb_dev.lock, flags);
-}
-
-static struct gb_loopback_async_operation *
-	gb_loopback_operation_find(u16 id)
-{
-	struct gb_loopback_async_operation *op_async;
-	bool found = false;
-	unsigned long flags;
-
-	spin_lock_irqsave(&gb_dev.lock, flags);
-	list_for_each_entry(op_async, &gb_dev.list_op_async, entry) {
-		if (op_async->operation->id == id) {
-			gb_loopback_async_operation_get(op_async);
-			found = true;
-			break;
-		}
-	}
-	spin_unlock_irqrestore(&gb_dev.lock, flags);
-
-	return found ? op_async : NULL;
-}
-
 static void gb_loopback_async_wait_all(struct gb_loopback *gb)
 {
 	wait_event(gb->wq_completion,
@@ -488,83 +433,41 @@ static void gb_loopback_async_operation_callback(struct gb_operation *operation)
 	struct gb_loopback_async_operation *op_async;
 	struct gb_loopback *gb;
 	ktime_t te;
-	bool err = false;
+	int result;
 
 	te = ktime_get();
-	op_async = gb_loopback_operation_find(operation->id);
-	if (!op_async)
-		return;
-
+	result = gb_operation_result(operation);
+	op_async = gb_operation_get_data(operation);
 	gb = op_async->gb;
+
 	mutex_lock(&gb->mutex);
 
-	if (!op_async->pending || gb_operation_result(operation)) {
-		err = true;
-	} else {
-		if (op_async->completion)
-			if (op_async->completion(op_async))
-				err = true;
-	}
+	if (!result && op_async->completion)
+		result = op_async->completion(op_async);
 
-	if (!err)
+	if (!result) {
 		gb->elapsed_nsecs = gb_loopback_calc_latency(op_async->ts, te);
-
-	if (op_async->pending) {
-		if (err)
-			gb->error++;
-		gb->iteration_count++;
-		op_async->pending = false;
-		del_timer_sync(&op_async->timer);
-		gb_loopback_async_operation_put(op_async);
-		gb_loopback_calculate_stats(gb, err);
+	} else {
+		gb->error++;
+		if (result == -ETIMEDOUT)
+			gb->requests_timedout++;
 	}
-	mutex_unlock(&gb->mutex);
-
-	dev_dbg(&gb->connection->bundle->dev, "complete operation %d\n",
-		operation->id);
-
-	gb_loopback_async_operation_put(op_async);
-}
-
-static void gb_loopback_async_operation_work(struct work_struct *work)
-{
-	struct gb_loopback *gb;
-	struct gb_operation *operation;
-	struct gb_loopback_async_operation *op_async;
 
-	op_async = container_of(work, struct gb_loopback_async_operation, work);
-	gb = op_async->gb;
-	operation = op_async->operation;
+	gb->iteration_count++;
+	gb_loopback_calculate_stats(gb, result);
 
-	mutex_lock(&gb->mutex);
-	if (op_async->pending) {
-		gb->requests_timedout++;
-		gb->error++;
-		gb->iteration_count++;
-		op_async->pending = false;
-		gb_loopback_async_operation_put(op_async);
-		gb_loopback_calculate_stats(gb, true);
-	}
 	mutex_unlock(&gb->mutex);
 
-	dev_dbg(&gb->connection->bundle->dev, "timeout operation %d\n",
+	dev_dbg(&gb->connection->bundle->dev, "complete operation %d\n",
 		operation->id);
 
-	gb_operation_cancel(operation, -ETIMEDOUT);
-	gb_loopback_async_operation_put(op_async);
-}
-
-static void gb_loopback_async_operation_timeout(unsigned long data)
-{
-	struct gb_loopback_async_operation *op_async;
-	u16 id = data;
+	/* Wake up waiters */
+	atomic_dec(&op_async->gb->outstanding_operations);
+	wake_up(&gb->wq_completion);
 
-	op_async = gb_loopback_operation_find(id);
-	if (!op_async) {
-		pr_err("operation %d not found - time out ?\n", id);
-		return;
-	}
-	schedule_work(&op_async->work);
+	/* Release resources */
+	gb_operation_put(operation);
+	kfree(op_async);
 }
 
 static int gb_loopback_async_operation(struct gb_loopback *gb, int type,
@@ -575,15 +478,11 @@ static int gb_loopback_async_operation(struct gb_loopback *gb, int type,
 	struct gb_loopback_async_operation *op_async;
 	struct gb_operation *operation;
 	int ret;
-	unsigned long flags;
 
 	op_async = kzalloc(sizeof(*op_async), GFP_KERNEL);
 	if (!op_async)
 		return -ENOMEM;
 
-	INIT_WORK(&op_async->work, gb_loopback_async_operation_work);
-	kref_init(&op_async->kref);
-
 	operation = gb_operation_create(gb->connection, type, request_size,
 					response_size, GFP_KERNEL);
 	if (!operation) {
@@ -594,33 +493,24 @@ static int gb_loopback_async_operation(struct gb_loopback *gb, int type,
 	if (request_size)
 		memcpy(operation->request->payload, request, request_size);
 
+	gb_operation_set_data(operation, op_async);
+
 	op_async->gb = gb;
 	op_async->operation = operation;
 	op_async->completion = completion;
 
-	spin_lock_irqsave(&gb_dev.lock, flags);
-	list_add_tail(&op_async->entry, &gb_dev.list_op_async);
-	spin_unlock_irqrestore(&gb_dev.lock, flags);
-
 	op_async->ts = ktime_get();
-	op_async->pending = true;
+
 	atomic_inc(&gb->outstanding_operations);
 	ret = gb_operation_request_send(operation,
 					gb_loopback_async_operation_callback,
-					0,
+					jiffies_to_msecs(gb->jiffy_timeout),
 					GFP_KERNEL);
-	if (ret)
-		goto error;
-
-	setup_timer(&op_async->timer, gb_loopback_async_operation_timeout,
-			(unsigned long)operation->id);
-	op_async->timer.expires = jiffies + gb->jiffy_timeout;
-	add_timer(&op_async->timer);
-
-	goto done;
-error:
-	gb_loopback_async_operation_put(op_async);
-done:
+	if (ret) {
+		atomic_dec(&gb->outstanding_operations);
+		gb_operation_put(operation);
+		kfree(op_async);
+	}
 	return ret;
 }
 

commit 44b02da39210e6dd67e39ff1f48d30c56d384240
Author: Bryan O'Donoghue <pure.logic@nexus-software.ie>
Date:   Mon Nov 6 01:32:20 2017 +0000

    staging: greybus: loopback: Fix iteration count on async path
    
    Commit 12927835d211 ("greybus: loopback: Add asynchronous bi-directional
    support") does what it says on the tin - namely, adds support for
    asynchronous bi-directional loopback operations.
    
    What it neglects to do though is increment the per-connection
    gb->iteration_count on an asynchronous operation error. This patch fixes
    that omission.
    
    Fixes: 12927835d211 ("greybus: loopback: Add asynchronous bi-directional support")
    
    Signed-off-by: Bryan O'Donoghue <pure.logic@nexus-software.ie>
    Reported-by: Mitch Tasman <tasman@leaflabs.com>
    Reviewed-by: Johan Hovold <johan@kernel.org>
    Cc: Alex Elder <elder@kernel.org>
    Cc: Mitch Tasman <tasman@leaflabs.com>
    Cc: greybus-dev@lists.linaro.org
    Cc: devel@driverdev.osuosl.org
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/loopback.c b/drivers/staging/greybus/loopback.c
index 20d1b4505817..9c5980cc7791 100644
--- a/drivers/staging/greybus/loopback.c
+++ b/drivers/staging/greybus/loopback.c
@@ -1021,8 +1021,10 @@ static int gb_loopback_fn(void *data)
 			else if (type == GB_LOOPBACK_TYPE_SINK)
 				error = gb_loopback_async_sink(gb, size);
 
-			if (error)
+			if (error) {
 				gb->error++;
+				gb->iteration_count++;
+			}
 		} else {
 			/* We are effectively single threaded here */
 			if (type == GB_LOOPBACK_TYPE_PING)

commit 5a70524bbf3b2764a2e2cd32f5109fd22c8a135f
Author: Bryan O'Donoghue <pure.logic@nexus-software.ie>
Date:   Mon Nov 6 01:32:19 2017 +0000

    staging: greybus: loopback: Hold per-connection mutex across operations
    
    Commit d9fb3754ecf8 ("greybus: loopback: Relax locking during loopback
    operations") changes the holding of the per-connection mutex to be less
    restrictive because at the time of that commit per-connection mutexes were
    encapsulated by a per-driver level gb_dev.mutex.
    
    Commit 8e1d6c336d74 ("greybus: loopback: drop bus aggregate calculation")
    on the other hand subtracts the driver level gb_dev.mutex but neglects to
    move the mutex back to the place it was prior to commit d9fb3754ecf8
    ("greybus: loopback: Relax locking during loopback operations"), as a
    result several members of the per connection struct gb_loopback are racy.
    
    The solution is restoring the old location of mutex_unlock(&gb->mutex) as
    it was in commit d9fb3754ecf8 ("greybus: loopback: Relax locking during
    loopback operations").
    
    Fixes: 8e1d6c336d74 ("greybus: loopback: drop bus aggregate calculation")
    
    Signed-off-by: Bryan O'Donoghue <pure.logic@nexus-software.ie>
    Reviewed-by: Johan Hovold <johan@kernel.org>
    Cc: Alex Elder <elder@kernel.org>
    Cc: Mitch Tasman <tasman@leaflabs.com>
    Cc: greybus-dev@lists.linaro.org
    Cc: devel@driverdev.osuosl.org
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/loopback.c b/drivers/staging/greybus/loopback.c
index 3d92638c424b..20d1b4505817 100644
--- a/drivers/staging/greybus/loopback.c
+++ b/drivers/staging/greybus/loopback.c
@@ -605,7 +605,6 @@ static int gb_loopback_async_operation(struct gb_loopback *gb, int type,
 	op_async->ts = ktime_get();
 	op_async->pending = true;
 	atomic_inc(&gb->outstanding_operations);
-	mutex_lock(&gb->mutex);
 	ret = gb_operation_request_send(operation,
 					gb_loopback_async_operation_callback,
 					0,
@@ -622,7 +621,6 @@ static int gb_loopback_async_operation(struct gb_loopback *gb, int type,
 error:
 	gb_loopback_async_operation_put(op_async);
 done:
-	mutex_unlock(&gb->mutex);
 	return ret;
 }
 
@@ -1013,7 +1011,6 @@ static int gb_loopback_fn(void *data)
 		type = gb->type;
 		if (ktime_to_ns(gb->ts) == 0)
 			gb->ts = ktime_get();
-		mutex_unlock(&gb->mutex);
 
 		/* Else operations to perform */
 		if (gb->async) {
@@ -1041,6 +1038,7 @@ static int gb_loopback_fn(void *data)
 			gb_loopback_calculate_stats(gb, !!error);
 		}
 		gb->send_count++;
+		mutex_unlock(&gb->mutex);
 
 		if (us_wait) {
 			if (us_wait < 20000)

commit 31408d16c21bf19587bf7c862354ea1b37a2ed9c
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Thu Nov 2 15:32:52 2017 +0100

    staging: greybus/loopback: use ktime_get() for time intervals
    
    This driver is the only one using the deprecated timeval_to_ns()
    helper. Changing it from do_gettimeofday() to ktime_get() makes
    the code more efficient, more robust against concurrent
    settimeofday(), more accurate and lets us get rid of that helper
    in the future.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Reviewed-by: Viresh Kumar <viresh.kumar@linaro.org>
    Acked-by: Bryan O'Donoghue <pure.logic@nexus-software.ie>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/loopback.c b/drivers/staging/greybus/loopback.c
index 85046fb16aad..3d92638c424b 100644
--- a/drivers/staging/greybus/loopback.c
+++ b/drivers/staging/greybus/loopback.c
@@ -58,7 +58,7 @@ static struct gb_loopback_device gb_dev;
 struct gb_loopback_async_operation {
 	struct gb_loopback *gb;
 	struct gb_operation *operation;
-	struct timeval ts;
+	ktime_t ts;
 	struct timer_list timer;
 	struct list_head entry;
 	struct work_struct work;
@@ -81,7 +81,7 @@ struct gb_loopback {
 	atomic_t outstanding_operations;
 
 	/* Per connection stats */
-	struct timeval ts;
+	ktime_t ts;
 	struct gb_loopback_stats latency;
 	struct gb_loopback_stats throughput;
 	struct gb_loopback_stats requests_per_second;
@@ -375,14 +375,9 @@ static u64 __gb_loopback_calc_latency(u64 t1, u64 t2)
 		return NSEC_PER_DAY - t2 + t1;
 }
 
-static u64 gb_loopback_calc_latency(struct timeval *ts, struct timeval *te)
+static u64 gb_loopback_calc_latency(ktime_t ts, ktime_t te)
 {
-	u64 t1, t2;
-
-	t1 = timeval_to_ns(ts);
-	t2 = timeval_to_ns(te);
-
-	return __gb_loopback_calc_latency(t1, t2);
+	return __gb_loopback_calc_latency(ktime_to_ns(ts), ktime_to_ns(te));
 }
 
 static int gb_loopback_operation_sync(struct gb_loopback *gb, int type,
@@ -390,10 +385,10 @@ static int gb_loopback_operation_sync(struct gb_loopback *gb, int type,
 				      void *response, int response_size)
 {
 	struct gb_operation *operation;
-	struct timeval ts, te;
+	ktime_t ts, te;
 	int ret;
 
-	do_gettimeofday(&ts);
+	ts = ktime_get();
 	operation = gb_operation_create(gb->connection, type, request_size,
 					response_size, GFP_KERNEL);
 	if (!operation)
@@ -421,10 +416,10 @@ static int gb_loopback_operation_sync(struct gb_loopback *gb, int type,
 		}
 	}
 
-	do_gettimeofday(&te);
+	te = ktime_get();
 
 	/* Calculate the total time the message took */
-	gb->elapsed_nsecs = gb_loopback_calc_latency(&ts, &te);
+	gb->elapsed_nsecs = gb_loopback_calc_latency(ts, te);
 
 out_put_operation:
 	gb_operation_put(operation);
@@ -492,10 +487,10 @@ static void gb_loopback_async_operation_callback(struct gb_operation *operation)
 {
 	struct gb_loopback_async_operation *op_async;
 	struct gb_loopback *gb;
-	struct timeval te;
+	ktime_t te;
 	bool err = false;
 
-	do_gettimeofday(&te);
+	te = ktime_get();
 	op_async = gb_loopback_operation_find(operation->id);
 	if (!op_async)
 		return;
@@ -512,8 +507,7 @@ static void gb_loopback_async_operation_callback(struct gb_operation *operation)
 	}
 
 	if (!err)
-		gb->elapsed_nsecs = gb_loopback_calc_latency(&op_async->ts,
-							     &te);
+		gb->elapsed_nsecs = gb_loopback_calc_latency(op_async->ts, te);
 
 	if (op_async->pending) {
 		if (err)
@@ -608,7 +602,7 @@ static int gb_loopback_async_operation(struct gb_loopback *gb, int type,
 	list_add_tail(&op_async->entry, &gb_dev.list_op_async);
 	spin_unlock_irqrestore(&gb_dev.lock, flags);
 
-	do_gettimeofday(&op_async->ts);
+	op_async->ts = ktime_get();
 	op_async->pending = true;
 	atomic_inc(&gb->outstanding_operations);
 	mutex_lock(&gb->mutex);
@@ -842,7 +836,7 @@ static void gb_loopback_reset_stats(struct gb_loopback *gb)
 	/* Should be initialized at least once per transaction set */
 	gb->apbridge_latency_ts = 0;
 	gb->gbphy_latency_ts = 0;
-	memset(&gb->ts, 0, sizeof(struct timeval));
+	gb->ts = ktime_set(0, 0);
 }
 
 static void gb_loopback_update_stats(struct gb_loopback_stats *stats, u32 val)
@@ -925,15 +919,15 @@ static void gb_loopback_calculate_stats(struct gb_loopback *gb, bool error)
 {
 	u64 nlat;
 	u32 lat;
-	struct timeval te;
+	ktime_t te;
 
 	if (!error) {
 		gb->requests_completed++;
 		gb_loopback_calculate_latency_stats(gb);
 	}
 
-	do_gettimeofday(&te);
-	nlat = gb_loopback_calc_latency(&gb->ts, &te);
+	te = ktime_get();
+	nlat = gb_loopback_calc_latency(gb->ts, te);
 	if (nlat >= NSEC_PER_SEC || gb->iteration_count == gb->iteration_max) {
 		lat = gb_loopback_nsec_to_usec_latency(nlat);
 
@@ -1017,8 +1011,8 @@ static int gb_loopback_fn(void *data)
 		size = gb->size;
 		us_wait = gb->us_wait;
 		type = gb->type;
-		if (gb->ts.tv_usec == 0 && gb->ts.tv_sec == 0)
-			do_gettimeofday(&gb->ts);
+		if (ktime_to_ns(gb->ts) == 0)
+			gb->ts = ktime_get();
 		mutex_unlock(&gb->mutex);
 
 		/* Else operations to perform */

commit 8563a49c4382adcb9b4ce21da46bd0067b90db31
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Thu Nov 2 15:32:51 2017 +0100

    staging: greybus: remove unused kfifo_ts
    
    As of commit 8e1d6c336d74 ("greybus: loopback: drop bus aggregate
    calculation"), nothing ever reads from kfifo_ts, so there is no
    reason to write to it or even allocate it any more.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Reviewed-by: Viresh Kumar <viresh.kumar@linaro.org>
    Reviewed-by: Bryan O'Donoghue <pure.logic@nexus-software.ie>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/loopback.c b/drivers/staging/greybus/loopback.c
index 08e255884206..85046fb16aad 100644
--- a/drivers/staging/greybus/loopback.c
+++ b/drivers/staging/greybus/loopback.c
@@ -72,7 +72,6 @@ struct gb_loopback {
 
 	struct dentry *file;
 	struct kfifo kfifo_lat;
-	struct kfifo kfifo_ts;
 	struct mutex mutex;
 	struct task_struct *task;
 	struct list_head entry;
@@ -262,7 +261,6 @@ static void gb_loopback_check_attr(struct gb_loopback *gb)
 			 gb->iteration_max, kfifo_depth);
 	}
 	kfifo_reset_out(&gb->kfifo_lat);
-	kfifo_reset_out(&gb->kfifo_ts);
 
 	switch (gb->type) {
 	case GB_LOOPBACK_TYPE_PING:
@@ -387,13 +385,6 @@ static u64 gb_loopback_calc_latency(struct timeval *ts, struct timeval *te)
 	return __gb_loopback_calc_latency(t1, t2);
 }
 
-static void gb_loopback_push_latency_ts(struct gb_loopback *gb,
-					struct timeval *ts, struct timeval *te)
-{
-	kfifo_in(&gb->kfifo_ts, (unsigned char *)ts, sizeof(*ts));
-	kfifo_in(&gb->kfifo_ts, (unsigned char *)te, sizeof(*te));
-}
-
 static int gb_loopback_operation_sync(struct gb_loopback *gb, int type,
 				      void *request, int request_size,
 				      void *response, int response_size)
@@ -433,7 +424,6 @@ static int gb_loopback_operation_sync(struct gb_loopback *gb, int type,
 	do_gettimeofday(&te);
 
 	/* Calculate the total time the message took */
-	gb_loopback_push_latency_ts(gb, &ts, &te);
 	gb->elapsed_nsecs = gb_loopback_calc_latency(&ts, &te);
 
 out_put_operation:
@@ -521,11 +511,9 @@ static void gb_loopback_async_operation_callback(struct gb_operation *operation)
 				err = true;
 	}
 
-	if (!err) {
-		gb_loopback_push_latency_ts(gb, &op_async->ts, &te);
+	if (!err)
 		gb->elapsed_nsecs = gb_loopback_calc_latency(&op_async->ts,
 							     &te);
-	}
 
 	if (op_async->pending) {
 		if (err)
@@ -1241,18 +1229,12 @@ static int gb_loopback_probe(struct gb_bundle *bundle,
 		retval = -ENOMEM;
 		goto out_conn;
 	}
-	if (kfifo_alloc(&gb->kfifo_ts, kfifo_depth * sizeof(struct timeval) * 2,
-			  GFP_KERNEL)) {
-		retval = -ENOMEM;
-		goto out_kfifo0;
-	}
-
 	/* Fork worker thread */
 	mutex_init(&gb->mutex);
 	gb->task = kthread_run(gb_loopback_fn, gb, "gb_loopback");
 	if (IS_ERR(gb->task)) {
 		retval = PTR_ERR(gb->task);
-		goto out_kfifo1;
+		goto out_kfifo;
 	}
 
 	spin_lock_irqsave(&gb_dev.lock, flags);
@@ -1266,9 +1248,7 @@ static int gb_loopback_probe(struct gb_bundle *bundle,
 
 	return 0;
 
-out_kfifo1:
-	kfifo_free(&gb->kfifo_ts);
-out_kfifo0:
+out_kfifo:
 	kfifo_free(&gb->kfifo_lat);
 out_conn:
 	device_unregister(dev);
@@ -1302,7 +1282,6 @@ static void gb_loopback_disconnect(struct gb_bundle *bundle)
 		kthread_stop(gb->task);
 
 	kfifo_free(&gb->kfifo_lat);
-	kfifo_free(&gb->kfifo_ts);
 	gb_connection_latency_tag_disable(gb->connection);
 	debugfs_remove(gb->file);
 

commit 5c143123321cd30553528e92ef7353f8488a461d
Author: Arushi Singhal <arushisinghal19971997@gmail.com>
Date:   Sat Mar 25 10:50:07 2017 +0530

    staging: greybus: compress return logic
    
    Simplify function returns by merging assignment and return.
    
    Signed-off-by: Arushi Singhal <arushisinghal19971997@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/loopback.c b/drivers/staging/greybus/loopback.c
index aaf29a5fac83..08e255884206 100644
--- a/drivers/staging/greybus/loopback.c
+++ b/drivers/staging/greybus/loopback.c
@@ -365,11 +365,8 @@ static void gb_loopback_calculate_stats(struct gb_loopback *gb, bool error);
 
 static u32 gb_loopback_nsec_to_usec_latency(u64 elapsed_nsecs)
 {
-	u32 lat;
-
 	do_div(elapsed_nsecs, NSEC_PER_USEC);
-	lat = elapsed_nsecs;
-	return lat;
+	return elapsed_nsecs;
 }
 
 static u64 __gb_loopback_calc_latency(u64 t1, u64 t2)

commit 563a8412c563cd68b90bb55603deb0a4d397d2bb
Author: Gioh Kim <gi-oh.kim@profitbricks.com>
Date:   Thu Feb 9 17:30:12 2017 +0100

    staging: greybus: fix symbolic permission coding style issues
    
    Fix "Octal permissions are preffered than symbolic ones" issues.
    
    Signed-off-by: Gioh Kim <gi-oh.kim@profitbricks.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/loopback.c b/drivers/staging/greybus/loopback.c
index 43692b86e0b2..aaf29a5fac83 100644
--- a/drivers/staging/greybus/loopback.c
+++ b/drivers/staging/greybus/loopback.c
@@ -1215,7 +1215,7 @@ static int gb_loopback_probe(struct gb_bundle *bundle,
 	/* Create per-connection sysfs and debugfs data-points */
 	snprintf(name, sizeof(name), "raw_latency_%s",
 		 dev_name(&connection->bundle->dev));
-	gb->file = debugfs_create_file(name, S_IFREG | S_IRUGO, gb_dev.root, gb,
+	gb->file = debugfs_create_file(name, S_IFREG | 0444, gb_dev.root, gb,
 				       &gb_loopback_debugfs_latency_ops);
 
 	gb->id = ida_simple_get(&loopback_ida, 0, 0, GFP_KERNEL);

commit dbec27298b0df86eaa6bc02e5df0ce55ec7d97f2
Author: Johan Hovold <johan@kernel.org>
Date:   Mon Jan 23 13:04:14 2017 +0100

    staging: greybus: operation: add generic timeout support
    
    Add a struct timer_list to struct gb_operation and use that to implement
    generic operation timeouts.
    
    This simplifies the synchronous operation handling somewhat while also
    providing a generic timeout mechanism that drivers can use for
    asynchronous operations.
    
    Signed-off-by: Johan Hovold <johan@kernel.org>
    Acked-by: Bryan O'Donoghue <pure.logic@nexus-software.ie>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/loopback.c b/drivers/staging/greybus/loopback.c
index a8329daf1e57..43692b86e0b2 100644
--- a/drivers/staging/greybus/loopback.c
+++ b/drivers/staging/greybus/loopback.c
@@ -629,6 +629,7 @@ static int gb_loopback_async_operation(struct gb_loopback *gb, int type,
 	mutex_lock(&gb->mutex);
 	ret = gb_operation_request_send(operation,
 					gb_loopback_async_operation_callback,
+					0,
 					GFP_KERNEL);
 	if (ret)
 		goto error;

commit 33b8807a6fe10d0e675e0704444373a6fad93188
Author: Johan Hovold <johan@kernel.org>
Date:   Thu Jan 26 12:37:32 2017 +0100

    staging: greybus: loopback: fix broken udelay
    
    The loopback driver allows the user to set a minimum delay of up to one
    second to be inserted between test iterations (i.e. request
    submissions). The delay is currently specified in microseconds and is
    implemented using udelay.
    
    Busy looping for long periods is not just anti-social; udelay must not
    be used for delays longer than a few milliseconds due to the risk of
    integer overflow.
    
    Replace the broken udelay with a usleep_range with a 100 us range for
    short delays (< 20 ms) and otherwise revert to using msleep.
    
    Fixes: b36f04fa9417 ("greybus: loopback: Convert thread delay to microseconds")
    Signed-off-by: Johan Hovold <johan@kernel.org>
    Cc: stable <stable@vger.kernel.org> # 4.9+
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/loopback.c b/drivers/staging/greybus/loopback.c
index 6c2a41c638c3..a8329daf1e57 100644
--- a/drivers/staging/greybus/loopback.c
+++ b/drivers/staging/greybus/loopback.c
@@ -1061,8 +1061,13 @@ static int gb_loopback_fn(void *data)
 			gb_loopback_calculate_stats(gb, !!error);
 		}
 		gb->send_count++;
-		if (us_wait)
-			udelay(us_wait);
+
+		if (us_wait) {
+			if (us_wait < 20000)
+				usleep_range(us_wait, us_wait + 100);
+			else
+				msleep(us_wait / 1000);
+		}
 	}
 
 	gb_pm_runtime_put_autosuspend(bundle);

commit 1d3dfbd1dd34bd373140d43e4bc827c3c480d3a9
Author: Roman Sommer <roman.sommer@fau.de>
Date:   Fri Jan 13 21:54:51 2017 +0100

    staging: greybus: fix checkpatch unsigned warnings
    
    Fix checkpatch warnings for parameter type unsigned in greybus.
    Note that this patch does not fix all checkpatch warnings for the
    affected files.
    
    Signed-off-by: Christian Bewermeyer <christian.bewermeyer@fau.de>
    Signed-off-by: Roman Sommer <roman.sommer@fau.de>
    Reviewed-by: Johan Hovold <johan@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/loopback.c b/drivers/staging/greybus/loopback.c
index 5ede67fcdd61..6c2a41c638c3 100644
--- a/drivers/staging/greybus/loopback.c
+++ b/drivers/staging/greybus/loopback.c
@@ -124,7 +124,7 @@ static DEFINE_IDA(loopback_ida);
 
 #define GB_LOOPBACK_FIFO_DEFAULT			8192
 
-static unsigned kfifo_depth = GB_LOOPBACK_FIFO_DEFAULT;
+static unsigned int kfifo_depth = GB_LOOPBACK_FIFO_DEFAULT;
 module_param(kfifo_depth, uint, 0444);
 
 /* Maximum size of any one send data buffer we support */

commit a1f10771cad204313ed692f1288a0596ff3b553d
Author: Abdul Rauf <abdulraufmujahid@gmail.com>
Date:   Wed Jan 11 00:55:59 2017 +0000

    staging: greybus: fix checkpatch braces not necessary warning
    
    Fix the following warnings:
    braces {} are not necessary for any arm of this statement
    
    Signed-off-by: Abdul Rauf <abdulraufmujahid@gmail.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/loopback.c b/drivers/staging/greybus/loopback.c
index 3184dd3999b5..5ede67fcdd61 100644
--- a/drivers/staging/greybus/loopback.c
+++ b/drivers/staging/greybus/loopback.c
@@ -1037,13 +1037,12 @@ static int gb_loopback_fn(void *data)
 
 		/* Else operations to perform */
 		if (gb->async) {
-			if (type == GB_LOOPBACK_TYPE_PING) {
+			if (type == GB_LOOPBACK_TYPE_PING)
 				error = gb_loopback_async_ping(gb);
-			} else if (type == GB_LOOPBACK_TYPE_TRANSFER) {
+			else if (type == GB_LOOPBACK_TYPE_TRANSFER)
 				error = gb_loopback_async_transfer(gb, size);
-			} else if (type == GB_LOOPBACK_TYPE_SINK) {
+			else if (type == GB_LOOPBACK_TYPE_SINK)
 				error = gb_loopback_async_sink(gb, size);
-			}
 
 			if (error)
 				gb->error++;

commit a072a72da96f8fedda3312686456c18c34ca179a
Author: Bryan O'Donoghue <pure.logic@nexus-software.ie>
Date:   Thu Dec 22 00:37:28 2016 +0000

    staging: greybus: loopback: use gb_loopback_async_wait_all don't spin
    
    Currently the greybus-loopback thread logic spins around waiting for
    send_count == iteration_max which on real hardware doesn't make a
    difference to us but in simulation is excruciatingly slow, anti-social and
    bad manners. Use the existing gb_loopback_async_wait_all() function to gate
    continuing when the send_count == iteration_max and go to sleep until
    there's something worthwhile to-do.
    
    Signed-off-by: Bryan O'Donoghue <pure.logic@nexus-software.ie>
    Reviewed-by: Johan Hovold <johan@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/loopback.c b/drivers/staging/greybus/loopback.c
index 7882306adeca..3184dd3999b5 100644
--- a/drivers/staging/greybus/loopback.c
+++ b/drivers/staging/greybus/loopback.c
@@ -1008,11 +1008,22 @@ static int gb_loopback_fn(void *data)
 
 		/* Optionally terminate */
 		if (gb->send_count == gb->iteration_max) {
+			mutex_unlock(&gb->mutex);
+
+			/* Wait for synchronous and asynchronus completion */
+			gb_loopback_async_wait_all(gb);
+
+			/* Mark complete unless user-space has poked us */
+			mutex_lock(&gb->mutex);
 			if (gb->iteration_count == gb->iteration_max) {
 				gb->type = 0;
 				gb->send_count = 0;
 				sysfs_notify(&gb->dev->kobj,  NULL,
 						"iteration_count");
+				dev_dbg(&bundle->dev, "load test complete\n");
+			} else {
+				dev_dbg(&bundle->dev,
+					"continuing on with new test set\n");
 			}
 			mutex_unlock(&gb->mutex);
 			continue;

commit 82af03f7b945634bfa93fef4e2f50db4459aabea
Author: sayli karnik <karniksayli1995@gmail.com>
Date:   Thu Sep 22 22:09:06 2016 +0530

    staging: greybus: Use setup_timer function
    
    This patch uses setup_timer function instead of initializing timer with the
    function and data fields.
    
    Signed-off-by: sayli karnik <karniksayli1995@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/loopback.c b/drivers/staging/greybus/loopback.c
index 8b0d0dc2ed8b..7882306adeca 100644
--- a/drivers/staging/greybus/loopback.c
+++ b/drivers/staging/greybus/loopback.c
@@ -603,7 +603,6 @@ static int gb_loopback_async_operation(struct gb_loopback *gb, int type,
 		return -ENOMEM;
 
 	INIT_WORK(&op_async->work, gb_loopback_async_operation_work);
-	init_timer(&op_async->timer);
 	kref_init(&op_async->kref);
 
 	operation = gb_operation_create(gb->connection, type, request_size,
@@ -634,9 +633,9 @@ static int gb_loopback_async_operation(struct gb_loopback *gb, int type,
 	if (ret)
 		goto error;
 
-	op_async->timer.function = gb_loopback_async_operation_timeout;
+	setup_timer(&op_async->timer, gb_loopback_async_operation_timeout,
+			(unsigned long)operation->id);
 	op_async->timer.expires = jiffies + gb->jiffy_timeout;
-	op_async->timer.data = (unsigned long)operation->id;
 	add_timer(&op_async->timer);
 
 	goto done;

commit e854ff58ed7011f73c7cdfcb7966ffa9c103571e
Author: Axel Haslam <haslam_axel@projectara.com>
Date:   Thu Jul 14 15:13:00 2016 -0500

    greybus: loopback: add runtime pm support
    
    Add runtime pm to the loopback driver so that
    the module wakes up from suspend while a test
    is executed.
    
    Testing Done: Let the module enter standby and
    execute a loopback test.
    
    Signed-off-by: Axel Haslam <haslam_axel@projectara.com>
    Signed-off-by: David Lin <dtwlin@google.com>
    Reviewed-by: Johan Hovold <johan@hovoldconsulting.com>
    Signed-off-by: Alex Elder <elder@linaro.org>

diff --git a/drivers/staging/greybus/loopback.c b/drivers/staging/greybus/loopback.c
index 702cf069eefd..8b0d0dc2ed8b 100644
--- a/drivers/staging/greybus/loopback.c
+++ b/drivers/staging/greybus/loopback.c
@@ -25,6 +25,7 @@
 #include <linux/spinlock.h>
 #include <linux/workqueue.h>
 #include <linux/atomic.h>
+#include <linux/pm_runtime.h>
 
 #include <asm/div64.h>
 
@@ -976,14 +977,26 @@ static int gb_loopback_fn(void *data)
 	int error = 0;
 	int us_wait = 0;
 	int type;
+	int ret;
 	u32 size;
 
 	struct gb_loopback *gb = data;
+	struct gb_bundle *bundle = gb->connection->bundle;
+
+	ret = gb_pm_runtime_get_sync(bundle);
+	if (ret)
+		return ret;
 
 	while (1) {
-		if (!gb->type)
+		if (!gb->type) {
+			gb_pm_runtime_put_autosuspend(bundle);
 			wait_event_interruptible(gb->wq, gb->type ||
 						 kthread_should_stop());
+			ret = gb_pm_runtime_get_sync(bundle);
+			if (ret)
+				return ret;
+		}
+
 		if (kthread_should_stop())
 			break;
 
@@ -1042,6 +1055,9 @@ static int gb_loopback_fn(void *data)
 		if (us_wait)
 			udelay(us_wait);
 	}
+
+	gb_pm_runtime_put_autosuspend(bundle);
+
 	return 0;
 }
 
@@ -1233,6 +1249,9 @@ static int gb_loopback_probe(struct gb_bundle *bundle,
 	spin_unlock_irqrestore(&gb_dev.lock, flags);
 
 	gb_connection_latency_tag_enable(connection);
+
+	gb_pm_runtime_put_autosuspend(bundle);
+
 	return 0;
 
 out_kfifo1:
@@ -1259,6 +1278,11 @@ static void gb_loopback_disconnect(struct gb_bundle *bundle)
 {
 	struct gb_loopback *gb = greybus_get_drvdata(bundle);
 	unsigned long flags;
+	int ret;
+
+	ret = gb_pm_runtime_get_sync(bundle);
+	if (ret)
+		gb_pm_runtime_get_noresume(bundle);
 
 	gb_connection_disable(gb->connection);
 

commit e54b106dd1be50377fe8365392466e080b659ab6
Author: Sandeep Patil <patil_sandeep@projectara.com>
Date:   Thu May 19 08:52:39 2016 -0700

    greybus: gpbridge: rename 'gpbridge' to 'gbphy' everywhere
    
    The 'gpbridge' name didn't relaly reflect what the bus is; which
    is a bus for bridged-phy devices. So, rename all instances
    of 'gpbridge' to more appropriate 'gbphy'
    
    Testing Done:
    Build and boot tested. 'lsgb' will stop displaying 'GPBridge' devices
    until I change the library to reflect this change.
    
    Signed-off-by: Sandeep Patil <patil_sandeep@projectara.com>
    Suggested-by: Greg Kroah-Hartman <gregkh@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/loopback.c b/drivers/staging/greybus/loopback.c
index ccb2799c3b0a..702cf069eefd 100644
--- a/drivers/staging/greybus/loopback.c
+++ b/drivers/staging/greybus/loopback.c
@@ -86,7 +86,7 @@ struct gb_loopback {
 	struct gb_loopback_stats throughput;
 	struct gb_loopback_stats requests_per_second;
 	struct gb_loopback_stats apbridge_unipro_latency;
-	struct gb_loopback_stats gpbridge_firmware_latency;
+	struct gb_loopback_stats gbphy_firmware_latency;
 
 	int type;
 	int async;
@@ -106,7 +106,7 @@ struct gb_loopback {
 	u32 lbid;
 	u64 elapsed_nsecs;
 	u32 apbridge_latency_ts;
-	u32 gpbridge_latency_ts;
+	u32 gbphy_latency_ts;
 
 	u32 send_count;
 };
@@ -290,7 +290,7 @@ gb_loopback_stats_attrs(throughput);
 /* Latency across the UniPro link from APBridge's perspective */
 gb_loopback_stats_attrs(apbridge_unipro_latency);
 /* Firmware induced overhead in the GPBridge */
-gb_loopback_stats_attrs(gpbridge_firmware_latency);
+gb_loopback_stats_attrs(gbphy_firmware_latency);
 
 /* Number of errors encountered during loop */
 gb_loopback_ro_attr(error);
@@ -340,9 +340,9 @@ static struct attribute *loopback_attrs[] = {
 	&dev_attr_apbridge_unipro_latency_min.attr,
 	&dev_attr_apbridge_unipro_latency_max.attr,
 	&dev_attr_apbridge_unipro_latency_avg.attr,
-	&dev_attr_gpbridge_firmware_latency_min.attr,
-	&dev_attr_gpbridge_firmware_latency_max.attr,
-	&dev_attr_gpbridge_firmware_latency_avg.attr,
+	&dev_attr_gbphy_firmware_latency_min.attr,
+	&dev_attr_gbphy_firmware_latency_max.attr,
+	&dev_attr_gbphy_firmware_latency_avg.attr,
 	&dev_attr_type.attr,
 	&dev_attr_size.attr,
 	&dev_attr_us_wait.attr,
@@ -670,7 +670,7 @@ static int gb_loopback_sync_transfer(struct gb_loopback *gb, u32 len)
 	int retval;
 
 	gb->apbridge_latency_ts = 0;
-	gb->gpbridge_latency_ts = 0;
+	gb->gbphy_latency_ts = 0;
 
 	request = kmalloc(len + sizeof(*request), GFP_KERNEL);
 	if (!request)
@@ -696,7 +696,7 @@ static int gb_loopback_sync_transfer(struct gb_loopback *gb, u32 len)
 		retval = -EREMOTEIO;
 	}
 	gb->apbridge_latency_ts = (u32)__le32_to_cpu(response->reserved0);
-	gb->gpbridge_latency_ts = (u32)__le32_to_cpu(response->reserved1);
+	gb->gbphy_latency_ts = (u32)__le32_to_cpu(response->reserved1);
 
 gb_error:
 	kfree(request);
@@ -752,7 +752,7 @@ static int gb_loopback_async_transfer_complete(
 	} else {
 		gb->apbridge_latency_ts =
 			(u32)__le32_to_cpu(response->reserved0);
-		gb->gpbridge_latency_ts =
+		gb->gbphy_latency_ts =
 			(u32)__le32_to_cpu(response->reserved1);
 	}
 
@@ -850,12 +850,12 @@ static void gb_loopback_reset_stats(struct gb_loopback *gb)
 	       sizeof(struct gb_loopback_stats));
 	memcpy(&gb->apbridge_unipro_latency, &reset,
 	       sizeof(struct gb_loopback_stats));
-	memcpy(&gb->gpbridge_firmware_latency, &reset,
+	memcpy(&gb->gbphy_firmware_latency, &reset,
 	       sizeof(struct gb_loopback_stats));
 
 	/* Should be initialized at least once per transaction set */
 	gb->apbridge_latency_ts = 0;
-	gb->gpbridge_latency_ts = 0;
+	gb->gbphy_latency_ts = 0;
 	memset(&gb->ts, 0, sizeof(struct timeval));
 }
 
@@ -931,8 +931,8 @@ static void gb_loopback_calculate_latency_stats(struct gb_loopback *gb)
 	/* Log the firmware supplied latency values */
 	gb_loopback_update_stats(&gb->apbridge_unipro_latency,
 				 gb->apbridge_latency_ts);
-	gb_loopback_update_stats(&gb->gpbridge_firmware_latency,
-				 gb->gpbridge_latency_ts);
+	gb_loopback_update_stats(&gb->gbphy_firmware_latency,
+				 gb->gbphy_latency_ts);
 }
 
 static void gb_loopback_calculate_stats(struct gb_loopback *gb, bool error)

commit b1f8bfea65183b4575e3dde64641f7340a3dfa38
Author: Johan Hovold <johan@hovoldconsulting.com>
Date:   Fri Apr 29 17:08:35 2016 +0200

    greybus: loopback: remove unsupported version request
    
    Remove the unsupported version request from the loopback-driver request
    handler.
    
    Unsupported requests are already handled and logged using the default
    case.
    
    Signed-off-by: Johan Hovold <johan@hovoldconsulting.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/loopback.c b/drivers/staging/greybus/loopback.c
index 5e009e1955ab..ccb2799c3b0a 100644
--- a/drivers/staging/greybus/loopback.c
+++ b/drivers/staging/greybus/loopback.c
@@ -800,9 +800,6 @@ static int gb_loopback_request_handler(struct gb_operation *operation)
 
 	/* By convention, the AP initiates the version operation */
 	switch (operation->type) {
-	case GB_REQUEST_TYPE_PROTOCOL_VERSION:
-		dev_err(dev, "module-initiated version operation\n");
-		return -EINVAL;
 	case GB_LOOPBACK_TYPE_PING:
 	case GB_LOOPBACK_TYPE_SINK:
 		return 0;

commit fece9c87cb80aceec7dd0205a77c37ff7ba831fe
Author: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
Date:   Wed Mar 16 11:29:59 2016 +0000

    greybus: Ensure gb->mutex is held when adding timer
    
    Currently in loopback on the async path we issue an operation and then add
    a timer to time-out that operation should it fail to complete. Looking at a
    backtrace given in its feasible op_async->pending can be true and
    del_timer() can run before add_timer() has run. In the callback handler we
    already hold gb->mutex. This patch fixes that potential race by ensuring we
    hold gb->mutex both when we are adding and when we are removing the
    relevant timer.
    
    Signed-off-by: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
    Reported-and-tested-by: Axel Haslam <ahaslam@baylibre.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/loopback.c b/drivers/staging/greybus/loopback.c
index 9b732a866455..5e009e1955ab 100644
--- a/drivers/staging/greybus/loopback.c
+++ b/drivers/staging/greybus/loopback.c
@@ -626,6 +626,7 @@ static int gb_loopback_async_operation(struct gb_loopback *gb, int type,
 	do_gettimeofday(&op_async->ts);
 	op_async->pending = true;
 	atomic_inc(&gb->outstanding_operations);
+	mutex_lock(&gb->mutex);
 	ret = gb_operation_request_send(operation,
 					gb_loopback_async_operation_callback,
 					GFP_KERNEL);
@@ -637,9 +638,11 @@ static int gb_loopback_async_operation(struct gb_loopback *gb, int type,
 	op_async->timer.data = (unsigned long)operation->id;
 	add_timer(&op_async->timer);
 
-	return ret;
+	goto done;
 error:
 	gb_loopback_async_operation_put(op_async);
+done:
+	mutex_unlock(&gb->mutex);
 	return ret;
 }
 

commit 1dc8d3d7c568d9a80fa20570a764da57677f1050
Author: Alexandre Bailon <abailon@baylibre.com>
Date:   Fri Mar 11 17:23:37 2016 +0100

    greybus: loopback: Fix broken loopback min values
    
    Currently, when a loopback test completely fail,
    loopback will return 4294967295 for every min value.
    Return 0 instead of 4294967295 in such case.
    
    Signed-off-by: Alexandre Bailon <abailon@baylibre.com>
    Reviewed-by: Johan Hovold <johan@hovoldconsulting.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/loopback.c b/drivers/staging/greybus/loopback.c
index 6c62706bb94c..9b732a866455 100644
--- a/drivers/staging/greybus/loopback.c
+++ b/drivers/staging/greybus/loopback.c
@@ -148,6 +148,9 @@ static ssize_t name##_##field##_show(struct device *dev,	\
 			    char *buf)					\
 {									\
 	struct gb_loopback *gb = dev_get_drvdata(dev);			\
+	/* Report 0 for min and max if no transfer successed */		\
+	if (!gb->requests_completed)					\
+		return sprintf(buf, "0\n");				\
 	return sprintf(buf, "%"#type"\n", gb->name.field);	\
 }									\
 static DEVICE_ATTR_RO(name##_##field)

commit 01480ba336982d49e2208636e38c0a80b732eba8
Author: Alexandre Bailon <abailon@baylibre.com>
Date:   Tue Mar 8 17:40:16 2016 +0100

    greybus: loopback: Fix broken synchonous test
    
    loopback driver use the send_count variable to know the test progress.
    The test may be stopped or change but this variable is never cleaned.
    Such situation may break the next run.
    
    Signed-off-by: Alexandre Bailon <abailon@baylibre.com>
    Reviewed-by: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/loopback.c b/drivers/staging/greybus/loopback.c
index 9f1cd9d6cd54..6c62706bb94c 100644
--- a/drivers/staging/greybus/loopback.c
+++ b/drivers/staging/greybus/loopback.c
@@ -107,6 +107,8 @@ struct gb_loopback {
 	u64 elapsed_nsecs;
 	u32 apbridge_latency_ts;
 	u32 gpbridge_latency_ts;
+
+	u32 send_count;
 };
 
 static struct class loopback_class = {
@@ -247,6 +249,7 @@ static void gb_loopback_check_attr(struct gb_loopback *gb)
 	gb->requests_timedout = 0;
 	gb->requests_completed = 0;
 	gb->iteration_count = 0;
+	gb->send_count = 0;
 	gb->error = 0;
 
 	if (kfifo_depth < gb->iteration_max) {
@@ -971,7 +974,7 @@ static int gb_loopback_fn(void *data)
 	int us_wait = 0;
 	int type;
 	u32 size;
-	u32 send_count = 0;
+
 	struct gb_loopback *gb = data;
 
 	while (1) {
@@ -989,10 +992,10 @@ static int gb_loopback_fn(void *data)
 		mutex_lock(&gb->mutex);
 
 		/* Optionally terminate */
-		if (send_count == gb->iteration_max) {
+		if (gb->send_count == gb->iteration_max) {
 			if (gb->iteration_count == gb->iteration_max) {
 				gb->type = 0;
-				send_count = 0;
+				gb->send_count = 0;
 				sysfs_notify(&gb->dev->kobj,  NULL,
 						"iteration_count");
 			}
@@ -1032,7 +1035,7 @@ static int gb_loopback_fn(void *data)
 			gb->iteration_count++;
 			gb_loopback_calculate_stats(gb, !!error);
 		}
-		send_count++;
+		gb->send_count++;
 		if (us_wait)
 			udelay(us_wait);
 	}

commit 58a527afff2b27bc912dbb7111d3f23d4f28105b
Author: Alexandre Bailon <abailon@baylibre.com>
Date:   Tue Mar 8 16:37:37 2016 +0100

    greybus: loopback: round closest the sixth decimal
    
    The original round was removed becaused it was rounding
    the integer whereas we had decimals.
    Round the sixth decimal.
    
    Signed-off-by: Alexandre Bailon <abailon@baylibre.com>
    Reviewed-by: Johan Hovold <johan@hovoldconsulting.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/loopback.c b/drivers/staging/greybus/loopback.c
index 75bff56b48c3..9f1cd9d6cd54 100644
--- a/drivers/staging/greybus/loopback.c
+++ b/drivers/staging/greybus/loopback.c
@@ -162,7 +162,7 @@ static ssize_t name##_avg_show(struct device *dev,		\
 	gb = dev_get_drvdata(dev);			\
 	stats = &gb->name;					\
 	count = stats->count ? stats->count : 1;			\
-	avg = stats->sum;						\
+	avg = stats->sum + count / 2000000; /* round closest */		\
 	rem = do_div(avg, count);					\
 	rem *= 1000000;							\
 	do_div(rem, count);						\

commit 89ec14ceaedf887fb666f09e1b768afdc32cb291
Author: Alexandre Bailon <abailon@baylibre.com>
Date:   Tue Mar 8 16:37:36 2016 +0100

    greybus: loopback: Fix warning on 32-bit build
    
    gb_loopback_ro_avg_attr() is using "/" to divide two 64-bit integer,
    causing a reference to __aeabi_uldivmod() that is not availalbe on 32-bit.
    Instead, use do_div().
    
    Signed-off-by: Alexandre Bailon <abailon@baylibre.com>
    Reviewed-by: Johan Hovold <johan@hovoldconsulting.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/loopback.c b/drivers/staging/greybus/loopback.c
index ba6e12a3648c..75bff56b48c3 100644
--- a/drivers/staging/greybus/loopback.c
+++ b/drivers/staging/greybus/loopback.c
@@ -164,7 +164,8 @@ static ssize_t name##_avg_show(struct device *dev,		\
 	count = stats->count ? stats->count : 1;			\
 	avg = stats->sum;						\
 	rem = do_div(avg, count);					\
-	rem = 1000000 * rem / count;					\
+	rem *= 1000000;							\
+	do_div(rem, count);						\
 	return sprintf(buf, "%llu.%06u\n", avg, (u32)rem);		\
 }									\
 static DEVICE_ATTR_RO(name##_avg)

commit 41993cd54fdc5c774cc4881e18a21e3e4a2544cd
Author: Johan Hovold <johan@hovoldconsulting.com>
Date:   Thu Mar 3 15:29:39 2016 +0100

    greybus: loopback: fix double error count
    
    Make sure not count errors during asynchronous tests twice (first in
    the timeout handler then again in the completion handler) to avoid
    obviously broken error stats such as:
    
    $ loopback_test -i 1000 -t transfer -p -o 200000 -c 64 -x -s 2000
    
    1970-1-1 1:3:35
     test:                  transfer
     path:                  gb_loopback0
     size:                  2000
     iterations:            1000
     errors:                1998
     async:                 Enabled
     requests per-sec:      min=0, max=0, average=0.310556, jitter=0
     ap-throughput B/s:     min=0 max=4026 average=1254.647461 jitter=4026
     ap-latency usec:       min=12803 max=12803 average=12803.000000 jitter=0
     apbridge-latency usec: min=89 max=89 average=89.000000 jitter=0
     gpbridge-latency usec: min=294 max=294 average=294.000000 jitter=0
    
    where we supposedly have more errors than iterations (operations
    initiated).
    
    Signed-off-by: Johan Hovold <johan@hovoldconsulting.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/loopback.c b/drivers/staging/greybus/loopback.c
index 9014c2b51ae0..ba6e12a3648c 100644
--- a/drivers/staging/greybus/loopback.c
+++ b/drivers/staging/greybus/loopback.c
@@ -516,15 +516,15 @@ static void gb_loopback_async_operation_callback(struct gb_operation *operation)
 				err = true;
 	}
 
-	if (err) {
-		gb->error++;
-	} else {
+	if (!err) {
 		gb_loopback_push_latency_ts(gb, &op_async->ts, &te);
 		gb->elapsed_nsecs = gb_loopback_calc_latency(&op_async->ts,
 							     &te);
 	}
 
 	if (op_async->pending) {
+		if (err)
+			gb->error++;
 		gb->iteration_count++;
 		op_async->pending = false;
 		del_timer_sync(&op_async->timer);

commit 39c2787b120a6e69e065b255d4db97ee60d73bf8
Author: Axel Haslam <ahaslam@baylibre.com>
Date:   Fri Feb 26 11:39:48 2016 +0100

    greybus: Notify user space only when the test finished.
    
    Currently, user space is notified for every message sent,
    but this is not really needed and does not work in the async case
    where all messages are sent from the start.
    
    Instead, notify userspace only when all the transfers are complete.
    This allows userspace to wait in a poll loop and wakeup only when
    the test is finished.
    
    Also, don't use the bundle kobj to send the notification it is
    the loopback device that contains the loopback attributes.
    
    Signed-off-by: Axel Haslam <ahaslam@baylibre.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/loopback.c b/drivers/staging/greybus/loopback.c
index 9f0da577d842..9014c2b51ae0 100644
--- a/drivers/staging/greybus/loopback.c
+++ b/drivers/staging/greybus/loopback.c
@@ -986,14 +986,14 @@ static int gb_loopback_fn(void *data)
 			break;
 
 		mutex_lock(&gb->mutex);
-		sysfs_notify(&gb->connection->bundle->dev.kobj,
-			     NULL, "iteration_count");
 
 		/* Optionally terminate */
 		if (send_count == gb->iteration_max) {
 			if (gb->iteration_count == gb->iteration_max) {
 				gb->type = 0;
 				send_count = 0;
+				sysfs_notify(&gb->dev->kobj,  NULL,
+						"iteration_count");
 			}
 			mutex_unlock(&gb->mutex);
 			continue;

commit fb37f137b78f186275b15e8ce1e5a26b51a6e6ad
Author: Alexandre Bailon <abailon@baylibre.com>
Date:   Thu Feb 25 18:19:16 2016 +0100

    greybus: loopback: Fix averaging
    
    Currently, we are adding 0.5 to the average to round the average.
    But we are using the remainder to calculate the decimal, so we do not
    need to round the average.
    In addition, use a u64 type for the remainder to avoid overflow
    that might happen when stats->sum value is too big,
    usually for requests per seconds and the throughput.
    
    Signed-off-by: Alexandre Bailon <abailon@baylibre.com>
    Reviewed-by: Johan Hovold <johan@hovoldconsulting.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/loopback.c b/drivers/staging/greybus/loopback.c
index 85d3e35e6a5f..9f0da577d842 100644
--- a/drivers/staging/greybus/loopback.c
+++ b/drivers/staging/greybus/loopback.c
@@ -157,14 +157,15 @@ static ssize_t name##_avg_show(struct device *dev,		\
 {									\
 	struct gb_loopback_stats *stats;				\
 	struct gb_loopback *gb;						\
-	u64 avg;							\
-	u32 count, rem;							\
+	u64 avg, rem;							\
+	u32 count;							\
 	gb = dev_get_drvdata(dev);			\
 	stats = &gb->name;					\
 	count = stats->count ? stats->count : 1;			\
-	avg = stats->sum + count / 2;	/* round closest */		\
+	avg = stats->sum;						\
 	rem = do_div(avg, count);					\
-	return sprintf(buf, "%llu.%06u\n", avg, 1000000 * rem / count);	\
+	rem = 1000000 * rem / count;					\
+	return sprintf(buf, "%llu.%06u\n", avg, (u32)rem);		\
 }									\
 static DEVICE_ATTR_RO(name##_avg)
 

commit ab81bb9c68d9fb899b79fa622fedf294e66fa53d
Author: Alexandre Bailon <abailon@baylibre.com>
Date:   Thu Feb 25 18:19:15 2016 +0100

    greybus: loopback: Fix throughput calculations
    
    Throughput and requests per second calculations are broken for
    asynchronous request.
    Instead of calculate the throughput for each iteration,
    calculate it once at the end of the test.
    In addition, update every seconds the min and the max
    for throughput and requests per second.
    
    Signed-off-by: Alexandre Bailon <abailon@baylibre.com>
    Reviewed-by: Johan Hovold <johan@hovoldconsulting.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/loopback.c b/drivers/staging/greybus/loopback.c
index a1f878b24e74..85d3e35e6a5f 100644
--- a/drivers/staging/greybus/loopback.c
+++ b/drivers/staging/greybus/loopback.c
@@ -81,6 +81,7 @@ struct gb_loopback {
 	atomic_t outstanding_operations;
 
 	/* Per connection stats */
+	struct timeval ts;
 	struct gb_loopback_stats latency;
 	struct gb_loopback_stats throughput;
 	struct gb_loopback_stats requests_per_second;
@@ -351,7 +352,7 @@ static struct attribute *loopback_attrs[] = {
 };
 ATTRIBUTE_GROUPS(loopback);
 
-static void gb_loopback_calculate_stats(struct gb_loopback *gb);
+static void gb_loopback_calculate_stats(struct gb_loopback *gb, bool error);
 
 static u32 gb_loopback_nsec_to_usec_latency(u64 elapsed_nsecs)
 {
@@ -517,11 +518,9 @@ static void gb_loopback_async_operation_callback(struct gb_operation *operation)
 	if (err) {
 		gb->error++;
 	} else {
-		gb->requests_completed++;
 		gb_loopback_push_latency_ts(gb, &op_async->ts, &te);
 		gb->elapsed_nsecs = gb_loopback_calc_latency(&op_async->ts,
 							     &te);
-		gb_loopback_calculate_stats(gb);
 	}
 
 	if (op_async->pending) {
@@ -529,6 +528,7 @@ static void gb_loopback_async_operation_callback(struct gb_operation *operation)
 		op_async->pending = false;
 		del_timer_sync(&op_async->timer);
 		gb_loopback_async_operation_put(op_async);
+		gb_loopback_calculate_stats(gb, err);
 	}
 	mutex_unlock(&gb->mutex);
 
@@ -555,6 +555,7 @@ static void gb_loopback_async_operation_work(struct work_struct *work)
 		gb->iteration_count++;
 		op_async->pending = false;
 		gb_loopback_async_operation_put(op_async);
+		gb_loopback_calculate_stats(gb, true);
 	}
 	mutex_unlock(&gb->mutex);
 
@@ -847,6 +848,7 @@ static void gb_loopback_reset_stats(struct gb_loopback *gb)
 	/* Should be initialized at least once per transaction set */
 	gb->apbridge_latency_ts = 0;
 	gb->gpbridge_latency_ts = 0;
+	memset(&gb->ts, 0, sizeof(struct timeval));
 }
 
 static void gb_loopback_update_stats(struct gb_loopback_stats *stats, u32 val)
@@ -859,18 +861,29 @@ static void gb_loopback_update_stats(struct gb_loopback_stats *stats, u32 val)
 	stats->count++;
 }
 
+static void gb_loopback_update_stats_window(struct gb_loopback_stats *stats,
+					    u64 val, u32 count)
+{
+	stats->sum += val;
+	stats->count += count;
+
+	do_div(val, count);
+	if (stats->min > val)
+		stats->min = val;
+	if (stats->max < val)
+		stats->max = val;
+}
+
 static void gb_loopback_requests_update(struct gb_loopback *gb, u32 latency)
 {
-	u32 req = USEC_PER_SEC;
+	u64 req = gb->requests_completed * USEC_PER_SEC;
 
-	do_div(req, latency);
-	gb_loopback_update_stats(&gb->requests_per_second, req);
+	gb_loopback_update_stats_window(&gb->requests_per_second, req, latency);
 }
 
 static void gb_loopback_throughput_update(struct gb_loopback *gb, u32 latency)
 {
-	u32 throughput;
-	u32 aggregate_size = sizeof(struct gb_operation_msg_hdr) * 2;
+	u64 aggregate_size = sizeof(struct gb_operation_msg_hdr) * 2;
 
 	switch (gb->type) {
 	case GB_LOOPBACK_TYPE_PING:
@@ -888,14 +901,13 @@ static void gb_loopback_throughput_update(struct gb_loopback *gb, u32 latency)
 		return;
 	}
 
-	/* Calculate bytes per second */
-	throughput = USEC_PER_SEC;
-	do_div(throughput, latency);
-	throughput *= aggregate_size;
-	gb_loopback_update_stats(&gb->throughput, throughput);
+	aggregate_size *= gb->requests_completed;
+	aggregate_size *= USEC_PER_SEC;
+	gb_loopback_update_stats_window(&gb->throughput, aggregate_size,
+					latency);
 }
 
-static void gb_loopback_calculate_stats(struct gb_loopback *gb)
+static void gb_loopback_calculate_latency_stats(struct gb_loopback *gb)
 {
 	u32 lat;
 
@@ -908,10 +920,6 @@ static void gb_loopback_calculate_stats(struct gb_loopback *gb)
 	/* Raw latency log on a per thread basis */
 	kfifo_in(&gb->kfifo_lat, (unsigned char *)&lat, sizeof(lat));
 
-	/* Log throughput and requests using latency as benchmark */
-	gb_loopback_throughput_update(gb, lat);
-	gb_loopback_requests_update(gb, lat);
-
 	/* Log the firmware supplied latency values */
 	gb_loopback_update_stats(&gb->apbridge_unipro_latency,
 				 gb->apbridge_latency_ts);
@@ -919,6 +927,32 @@ static void gb_loopback_calculate_stats(struct gb_loopback *gb)
 				 gb->gpbridge_latency_ts);
 }
 
+static void gb_loopback_calculate_stats(struct gb_loopback *gb, bool error)
+{
+	u64 nlat;
+	u32 lat;
+	struct timeval te;
+
+	if (!error) {
+		gb->requests_completed++;
+		gb_loopback_calculate_latency_stats(gb);
+	}
+
+	do_gettimeofday(&te);
+	nlat = gb_loopback_calc_latency(&gb->ts, &te);
+	if (nlat >= NSEC_PER_SEC || gb->iteration_count == gb->iteration_max) {
+		lat = gb_loopback_nsec_to_usec_latency(nlat);
+
+		gb_loopback_throughput_update(gb, lat);
+		gb_loopback_requests_update(gb, lat);
+
+		if (gb->iteration_count != gb->iteration_max) {
+			gb->ts = te;
+			gb->requests_completed = 0;
+		}
+	}
+}
+
 static void gb_loopback_async_wait_to_send(struct gb_loopback *gb)
 {
 	if (!(gb->async && gb->outstanding_operations_max))
@@ -956,14 +990,18 @@ static int gb_loopback_fn(void *data)
 
 		/* Optionally terminate */
 		if (send_count == gb->iteration_max) {
-			gb->type = 0;
-			send_count = 0;
+			if (gb->iteration_count == gb->iteration_max) {
+				gb->type = 0;
+				send_count = 0;
+			}
 			mutex_unlock(&gb->mutex);
 			continue;
 		}
 		size = gb->size;
 		us_wait = gb->us_wait;
 		type = gb->type;
+		if (gb->ts.tv_usec == 0 && gb->ts.tv_sec == 0)
+			do_gettimeofday(&gb->ts);
 		mutex_unlock(&gb->mutex);
 
 		/* Else operations to perform */
@@ -989,9 +1027,8 @@ static int gb_loopback_fn(void *data)
 
 			if (error)
 				gb->error++;
-			else
-				gb_loopback_calculate_stats(gb);
 			gb->iteration_count++;
+			gb_loopback_calculate_stats(gb, !!error);
 		}
 		send_count++;
 		if (us_wait)

commit d9048d8c96bfe2d18cdf7205b3de97aa344283a7
Author: Alexandre Bailon <abailon@baylibre.com>
Date:   Thu Feb 25 18:19:14 2016 +0100

    greybus: loopback: Fix incoherency in calculations in the case of error
    
    Currently, in case the case of error, statistics are updated for
    asynchronous but not for an asynchronous operation.
    Do not update the statistics in the case of error.
    
    Signed-off-by: Alexandre Bailon <abailon@baylibre.com>
    Reviewed-by: Johan Hovold <johan@hovoldconsulting.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/loopback.c b/drivers/staging/greybus/loopback.c
index b40c95eb8801..a1f878b24e74 100644
--- a/drivers/staging/greybus/loopback.c
+++ b/drivers/staging/greybus/loopback.c
@@ -398,10 +398,8 @@ static int gb_loopback_operation_sync(struct gb_loopback *gb, int type,
 	do_gettimeofday(&ts);
 	operation = gb_operation_create(gb->connection, type, request_size,
 					response_size, GFP_KERNEL);
-	if (!operation) {
-		ret = -ENOMEM;
-		goto error;
-	}
+	if (!operation)
+		return -ENOMEM;
 
 	if (request_size)
 		memcpy(operation->request->payload, request, request_size);
@@ -410,6 +408,7 @@ static int gb_loopback_operation_sync(struct gb_loopback *gb, int type,
 	if (ret) {
 		dev_err(&gb->connection->bundle->dev,
 			"synchronous operation failed: %d\n", ret);
+		goto out_put_operation;
 	} else {
 		if (response_size == operation->response->payload_size) {
 			memcpy(response, operation->response->payload,
@@ -419,18 +418,20 @@ static int gb_loopback_operation_sync(struct gb_loopback *gb, int type,
 				"response size %zu expected %d\n",
 				operation->response->payload_size,
 				response_size);
+			ret = -EINVAL;
+			goto out_put_operation;
 		}
 	}
 
-	gb_operation_put(operation);
-
-error:
 	do_gettimeofday(&te);
 
 	/* Calculate the total time the message took */
 	gb_loopback_push_latency_ts(gb, &ts, &te);
 	gb->elapsed_nsecs = gb_loopback_calc_latency(&ts, &te);
 
+out_put_operation:
+	gb_operation_put(operation);
+
 	return ret;
 }
 
@@ -988,8 +989,9 @@ static int gb_loopback_fn(void *data)
 
 			if (error)
 				gb->error++;
+			else
+				gb_loopback_calculate_stats(gb);
 			gb->iteration_count++;
-			gb_loopback_calculate_stats(gb);
 		}
 		send_count++;
 		if (us_wait)

commit d97bbf3ed6211c01bd7df77d405dee2e9846cd68
Author: Alexandre Bailon <abailon@baylibre.com>
Date:   Thu Feb 25 18:19:13 2016 +0100

    greybus: loopback: Fix calculations error for ping transfers
    
    For the async ping transfer, statistics are counted twice,
    once after the after the gb_loopback_async_operation() and
    once in the callback.
    Only keep the one in the callback.
    
    Signed-off-by: Alexandre Bailon <abailon@baylibre.com>
    Reported-by: Johan Hovold <johan@hovoldconsulting.com>
    Reviewed-by: Johan Hovold <johan@hovoldconsulting.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/loopback.c b/drivers/staging/greybus/loopback.c
index f3ae2e9fc1bb..b40c95eb8801 100644
--- a/drivers/staging/greybus/loopback.c
+++ b/drivers/staging/greybus/loopback.c
@@ -969,7 +969,6 @@ static int gb_loopback_fn(void *data)
 		if (gb->async) {
 			if (type == GB_LOOPBACK_TYPE_PING) {
 				error = gb_loopback_async_ping(gb);
-				gb_loopback_calculate_stats(gb);
 			} else if (type == GB_LOOPBACK_TYPE_TRANSFER) {
 				error = gb_loopback_async_transfer(gb, size);
 			} else if (type == GB_LOOPBACK_TYPE_SINK) {

commit 2422d36696f36ea92f17bb34a129a74f9b173891
Author: Greg Kroah-Hartman <gregkh@google.com>
Date:   Wed Feb 17 16:30:38 2016 -0800

    greybus: Revert "gb_loopback: Fix throughput calculations"
    
    This reverts commit 9b9b046af237f5674c2f7ca991dc62332b2d4041
    
    Bryan wants more feedback first.
    
    Reported-by: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/loopback.c b/drivers/staging/greybus/loopback.c
index c022edbfb135..f3ae2e9fc1bb 100644
--- a/drivers/staging/greybus/loopback.c
+++ b/drivers/staging/greybus/loopback.c
@@ -81,7 +81,6 @@ struct gb_loopback {
 	atomic_t outstanding_operations;
 
 	/* Per connection stats */
-	struct timeval ts;
 	struct gb_loopback_stats latency;
 	struct gb_loopback_stats throughput;
 	struct gb_loopback_stats requests_per_second;
@@ -521,6 +520,7 @@ static void gb_loopback_async_operation_callback(struct gb_operation *operation)
 		gb_loopback_push_latency_ts(gb, &op_async->ts, &te);
 		gb->elapsed_nsecs = gb_loopback_calc_latency(&op_async->ts,
 							     &te);
+		gb_loopback_calculate_stats(gb);
 	}
 
 	if (op_async->pending) {
@@ -529,7 +529,6 @@ static void gb_loopback_async_operation_callback(struct gb_operation *operation)
 		del_timer_sync(&op_async->timer);
 		gb_loopback_async_operation_put(op_async);
 	}
-	gb_loopback_calculate_stats(gb);
 	mutex_unlock(&gb->mutex);
 
 	dev_dbg(&gb->connection->bundle->dev, "complete operation %d\n",
@@ -847,7 +846,6 @@ static void gb_loopback_reset_stats(struct gb_loopback *gb)
 	/* Should be initialized at least once per transaction set */
 	gb->apbridge_latency_ts = 0;
 	gb->gpbridge_latency_ts = 0;
-	memset(&gb->ts, 0, sizeof(struct timeval));
 }
 
 static void gb_loopback_update_stats(struct gb_loopback_stats *stats, u32 val)
@@ -862,15 +860,15 @@ static void gb_loopback_update_stats(struct gb_loopback_stats *stats, u32 val)
 
 static void gb_loopback_requests_update(struct gb_loopback *gb, u32 latency)
 {
-	u64 req = gb->requests_completed * USEC_PER_SEC;
+	u32 req = USEC_PER_SEC;
 
 	do_div(req, latency);
-	gb_loopback_update_stats(&gb->requests_per_second, (u32)req);
+	gb_loopback_update_stats(&gb->requests_per_second, req);
 }
 
 static void gb_loopback_throughput_update(struct gb_loopback *gb, u32 latency)
 {
-	u64 throughput;
+	u32 throughput;
 	u32 aggregate_size = sizeof(struct gb_operation_msg_hdr) * 2;
 
 	switch (gb->type) {
@@ -889,13 +887,14 @@ static void gb_loopback_throughput_update(struct gb_loopback *gb, u32 latency)
 		return;
 	}
 
-	aggregate_size *= gb->requests_completed;
-	throughput = aggregate_size * USEC_PER_SEC;
+	/* Calculate bytes per second */
+	throughput = USEC_PER_SEC;
 	do_div(throughput, latency);
-	gb_loopback_update_stats(&gb->throughput, (u32)throughput);
+	throughput *= aggregate_size;
+	gb_loopback_update_stats(&gb->throughput, throughput);
 }
 
-static void gb_loopback_calculate_latency_stats(struct gb_loopback *gb)
+static void gb_loopback_calculate_stats(struct gb_loopback *gb)
 {
 	u32 lat;
 
@@ -908,6 +907,10 @@ static void gb_loopback_calculate_latency_stats(struct gb_loopback *gb)
 	/* Raw latency log on a per thread basis */
 	kfifo_in(&gb->kfifo_lat, (unsigned char *)&lat, sizeof(lat));
 
+	/* Log throughput and requests using latency as benchmark */
+	gb_loopback_throughput_update(gb, lat);
+	gb_loopback_requests_update(gb, lat);
+
 	/* Log the firmware supplied latency values */
 	gb_loopback_update_stats(&gb->apbridge_unipro_latency,
 				 gb->apbridge_latency_ts);
@@ -915,27 +918,6 @@ static void gb_loopback_calculate_latency_stats(struct gb_loopback *gb)
 				 gb->gpbridge_latency_ts);
 }
 
-static void gb_loopback_calculate_stats(struct gb_loopback *gb)
-{
-	u64 nlat;
-	u32 lat;
-	struct timeval te;
-
-	gb_loopback_calculate_latency_stats(gb);
-
-	if (gb->iteration_count == gb->iteration_max) {
-		do_gettimeofday(&te);
-		nlat = gb_loopback_calc_latency(&gb->ts, &te);
-		lat = gb_loopback_nsec_to_usec_latency(nlat);
-
-		gb_loopback_throughput_update(gb, lat);
-		gb_loopback_requests_update(gb, lat);
-
-		memset(&gb->ts, 0, sizeof(struct timeval));
-		gb->type = 0;
-	}
-}
-
 static void gb_loopback_async_wait_to_send(struct gb_loopback *gb)
 {
 	if (!(gb->async && gb->outstanding_operations_max))
@@ -973,10 +955,8 @@ static int gb_loopback_fn(void *data)
 
 		/* Optionally terminate */
 		if (send_count == gb->iteration_max) {
-			if (!gb->async)
-				send_count = 0;
-			else if (gb->iteration_count == gb->iteration_max)
-				send_count = 0;
+			gb->type = 0;
+			send_count = 0;
 			mutex_unlock(&gb->mutex);
 			continue;
 		}
@@ -985,15 +965,10 @@ static int gb_loopback_fn(void *data)
 		type = gb->type;
 		mutex_unlock(&gb->mutex);
 
-		if (gb->ts.tv_usec == 0 && gb->ts.tv_sec == 0)
-			do_gettimeofday(&gb->ts);
-
 		/* Else operations to perform */
 		if (gb->async) {
 			if (type == GB_LOOPBACK_TYPE_PING) {
 				error = gb_loopback_async_ping(gb);
-				if (!error)
-					gb->requests_completed++;
 				gb_loopback_calculate_stats(gb);
 			} else if (type == GB_LOOPBACK_TYPE_TRANSFER) {
 				error = gb_loopback_async_transfer(gb, size);
@@ -1014,8 +989,6 @@ static int gb_loopback_fn(void *data)
 
 			if (error)
 				gb->error++;
-			else
-				gb->requests_completed++;
 			gb->iteration_count++;
 			gb_loopback_calculate_stats(gb);
 		}

commit c53b0b27d57cc1dff50080c911b48b2af7728dc4
Author: Alexandre Bailon <abailon@baylibre.com>
Date:   Wed Feb 17 18:21:06 2016 +0100

    greybus: gb_loopback: Fix throughput calculations
    
    Throughput and requests per second calculations are broken for
    asynchronous request.
    Instead of calculate the throughput for each iteration,
    calculate it once at the end of the test.
    
    Signed-off-by: Alexandre Bailon <abailon@baylibre.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/loopback.c b/drivers/staging/greybus/loopback.c
index f3ae2e9fc1bb..c022edbfb135 100644
--- a/drivers/staging/greybus/loopback.c
+++ b/drivers/staging/greybus/loopback.c
@@ -81,6 +81,7 @@ struct gb_loopback {
 	atomic_t outstanding_operations;
 
 	/* Per connection stats */
+	struct timeval ts;
 	struct gb_loopback_stats latency;
 	struct gb_loopback_stats throughput;
 	struct gb_loopback_stats requests_per_second;
@@ -520,7 +521,6 @@ static void gb_loopback_async_operation_callback(struct gb_operation *operation)
 		gb_loopback_push_latency_ts(gb, &op_async->ts, &te);
 		gb->elapsed_nsecs = gb_loopback_calc_latency(&op_async->ts,
 							     &te);
-		gb_loopback_calculate_stats(gb);
 	}
 
 	if (op_async->pending) {
@@ -529,6 +529,7 @@ static void gb_loopback_async_operation_callback(struct gb_operation *operation)
 		del_timer_sync(&op_async->timer);
 		gb_loopback_async_operation_put(op_async);
 	}
+	gb_loopback_calculate_stats(gb);
 	mutex_unlock(&gb->mutex);
 
 	dev_dbg(&gb->connection->bundle->dev, "complete operation %d\n",
@@ -846,6 +847,7 @@ static void gb_loopback_reset_stats(struct gb_loopback *gb)
 	/* Should be initialized at least once per transaction set */
 	gb->apbridge_latency_ts = 0;
 	gb->gpbridge_latency_ts = 0;
+	memset(&gb->ts, 0, sizeof(struct timeval));
 }
 
 static void gb_loopback_update_stats(struct gb_loopback_stats *stats, u32 val)
@@ -860,15 +862,15 @@ static void gb_loopback_update_stats(struct gb_loopback_stats *stats, u32 val)
 
 static void gb_loopback_requests_update(struct gb_loopback *gb, u32 latency)
 {
-	u32 req = USEC_PER_SEC;
+	u64 req = gb->requests_completed * USEC_PER_SEC;
 
 	do_div(req, latency);
-	gb_loopback_update_stats(&gb->requests_per_second, req);
+	gb_loopback_update_stats(&gb->requests_per_second, (u32)req);
 }
 
 static void gb_loopback_throughput_update(struct gb_loopback *gb, u32 latency)
 {
-	u32 throughput;
+	u64 throughput;
 	u32 aggregate_size = sizeof(struct gb_operation_msg_hdr) * 2;
 
 	switch (gb->type) {
@@ -887,14 +889,13 @@ static void gb_loopback_throughput_update(struct gb_loopback *gb, u32 latency)
 		return;
 	}
 
-	/* Calculate bytes per second */
-	throughput = USEC_PER_SEC;
+	aggregate_size *= gb->requests_completed;
+	throughput = aggregate_size * USEC_PER_SEC;
 	do_div(throughput, latency);
-	throughput *= aggregate_size;
-	gb_loopback_update_stats(&gb->throughput, throughput);
+	gb_loopback_update_stats(&gb->throughput, (u32)throughput);
 }
 
-static void gb_loopback_calculate_stats(struct gb_loopback *gb)
+static void gb_loopback_calculate_latency_stats(struct gb_loopback *gb)
 {
 	u32 lat;
 
@@ -907,10 +908,6 @@ static void gb_loopback_calculate_stats(struct gb_loopback *gb)
 	/* Raw latency log on a per thread basis */
 	kfifo_in(&gb->kfifo_lat, (unsigned char *)&lat, sizeof(lat));
 
-	/* Log throughput and requests using latency as benchmark */
-	gb_loopback_throughput_update(gb, lat);
-	gb_loopback_requests_update(gb, lat);
-
 	/* Log the firmware supplied latency values */
 	gb_loopback_update_stats(&gb->apbridge_unipro_latency,
 				 gb->apbridge_latency_ts);
@@ -918,6 +915,27 @@ static void gb_loopback_calculate_stats(struct gb_loopback *gb)
 				 gb->gpbridge_latency_ts);
 }
 
+static void gb_loopback_calculate_stats(struct gb_loopback *gb)
+{
+	u64 nlat;
+	u32 lat;
+	struct timeval te;
+
+	gb_loopback_calculate_latency_stats(gb);
+
+	if (gb->iteration_count == gb->iteration_max) {
+		do_gettimeofday(&te);
+		nlat = gb_loopback_calc_latency(&gb->ts, &te);
+		lat = gb_loopback_nsec_to_usec_latency(nlat);
+
+		gb_loopback_throughput_update(gb, lat);
+		gb_loopback_requests_update(gb, lat);
+
+		memset(&gb->ts, 0, sizeof(struct timeval));
+		gb->type = 0;
+	}
+}
+
 static void gb_loopback_async_wait_to_send(struct gb_loopback *gb)
 {
 	if (!(gb->async && gb->outstanding_operations_max))
@@ -955,8 +973,10 @@ static int gb_loopback_fn(void *data)
 
 		/* Optionally terminate */
 		if (send_count == gb->iteration_max) {
-			gb->type = 0;
-			send_count = 0;
+			if (!gb->async)
+				send_count = 0;
+			else if (gb->iteration_count == gb->iteration_max)
+				send_count = 0;
 			mutex_unlock(&gb->mutex);
 			continue;
 		}
@@ -965,10 +985,15 @@ static int gb_loopback_fn(void *data)
 		type = gb->type;
 		mutex_unlock(&gb->mutex);
 
+		if (gb->ts.tv_usec == 0 && gb->ts.tv_sec == 0)
+			do_gettimeofday(&gb->ts);
+
 		/* Else operations to perform */
 		if (gb->async) {
 			if (type == GB_LOOPBACK_TYPE_PING) {
 				error = gb_loopback_async_ping(gb);
+				if (!error)
+					gb->requests_completed++;
 				gb_loopback_calculate_stats(gb);
 			} else if (type == GB_LOOPBACK_TYPE_TRANSFER) {
 				error = gb_loopback_async_transfer(gb, size);
@@ -989,6 +1014,8 @@ static int gb_loopback_fn(void *data)
 
 			if (error)
 				gb->error++;
+			else
+				gb->requests_completed++;
 			gb->iteration_count++;
 			gb_loopback_calculate_stats(gb);
 		}

commit e82a11dcbd37f0b5596d08636859b372713d4460
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Fri Feb 12 16:08:29 2016 +0530

    greybus: loopback: convert to bundle driver
    
    Convert the legacy loopback protocol driver to a bundle driver.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Reviewed-by: Johan Hovold <johan@hovoldconsulting.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/loopback.c b/drivers/staging/greybus/loopback.c
index 66b3fcaca9b0..f3ae2e9fc1bb 100644
--- a/drivers/staging/greybus/loopback.c
+++ b/drivers/staging/greybus/loopback.c
@@ -777,7 +777,7 @@ static int gb_loopback_async_ping(struct gb_loopback *gb)
 					   NULL, 0, 0, NULL);
 }
 
-static int gb_loopback_request_recv(u8 type, struct gb_operation *operation)
+static int gb_loopback_request_handler(struct gb_operation *operation)
 {
 	struct gb_connection *connection = operation->connection;
 	struct gb_loopback_transfer_request *request;
@@ -786,7 +786,7 @@ static int gb_loopback_request_recv(u8 type, struct gb_operation *operation)
 	size_t len;
 
 	/* By convention, the AP initiates the version operation */
-	switch (type) {
+	switch (operation->type) {
 	case GB_REQUEST_TYPE_PROTOCOL_VERSION:
 		dev_err(dev, "module-initiated version operation\n");
 		return -EINVAL;
@@ -820,7 +820,7 @@ static int gb_loopback_request_recv(u8 type, struct gb_operation *operation)
 
 		return 0;
 	default:
-		dev_err(dev, "unsupported request: %u\n", type);
+		dev_err(dev, "unsupported request: %u\n", operation->type);
 		return -EINVAL;
 	}
 }
@@ -1083,18 +1083,38 @@ static void gb_loopback_insert_id(struct gb_loopback *gb)
 
 #define DEBUGFS_NAMELEN 32
 
-static int gb_loopback_connection_init(struct gb_connection *connection)
+static int gb_loopback_probe(struct gb_bundle *bundle,
+			     const struct greybus_bundle_id *id)
 {
+	struct greybus_descriptor_cport *cport_desc;
+	struct gb_connection *connection;
 	struct gb_loopback *gb;
 	struct device *dev;
 	int retval;
 	char name[DEBUGFS_NAMELEN];
 	unsigned long flags;
 
+	if (bundle->num_cports != 1)
+		return -ENODEV;
+
+	cport_desc = &bundle->cport_desc[0];
+	if (cport_desc->protocol_id != GREYBUS_PROTOCOL_LOOPBACK)
+		return -ENODEV;
+
 	gb = kzalloc(sizeof(*gb), GFP_KERNEL);
 	if (!gb)
 		return -ENOMEM;
 
+	connection = gb_connection_create(bundle, le16_to_cpu(cport_desc->id),
+					  gb_loopback_request_handler);
+	if (IS_ERR(connection)) {
+		retval = PTR_ERR(connection);
+		goto out_kzalloc;
+	}
+
+	gb->connection = connection;
+	greybus_set_drvdata(bundle, gb);
+
 	init_waitqueue_head(&gb->wq);
 	init_waitqueue_head(&gb->wq_completion);
 	atomic_set(&gb->outstanding_operations, 0);
@@ -1110,7 +1130,7 @@ static int gb_loopback_connection_init(struct gb_connection *connection)
 		if (gb_dev.size_max <=
 			sizeof(struct gb_loopback_transfer_request)) {
 			retval = -EINVAL;
-			goto out_kzalloc;
+			goto out_connection_destroy;
 		}
 		gb_dev.size_max -= sizeof(struct gb_loopback_transfer_request);
 	}
@@ -1120,22 +1140,24 @@ static int gb_loopback_connection_init(struct gb_connection *connection)
 		 dev_name(&connection->bundle->dev));
 	gb->file = debugfs_create_file(name, S_IFREG | S_IRUGO, gb_dev.root, gb,
 				       &gb_loopback_debugfs_latency_ops);
-	gb->connection = connection;
-	connection->private = gb;
 
 	gb->id = ida_simple_get(&loopback_ida, 0, 0, GFP_KERNEL);
 	if (gb->id < 0) {
 		retval = gb->id;
-		goto out_ida;
+		goto out_debugfs_remove;
 	}
 
+	retval = gb_connection_enable(connection);
+	if (retval)
+		goto out_ida_remove;
+
 	dev = device_create_with_groups(&loopback_class,
 					&connection->bundle->dev,
 					MKDEV(0, 0), gb, loopback_groups,
 					"gb_loopback%d", gb->id);
 	if (IS_ERR(dev)) {
 		retval = PTR_ERR(dev);
-		goto out_dev;
+		goto out_connection_disable;
 	}
 	gb->dev = dev;
 
@@ -1173,28 +1195,40 @@ static int gb_loopback_connection_init(struct gb_connection *connection)
 	kfifo_free(&gb->kfifo_lat);
 out_conn:
 	device_unregister(dev);
-out_dev:
+out_connection_disable:
+	gb_connection_disable(connection);
+out_ida_remove:
 	ida_simple_remove(&loopback_ida, gb->id);
-out_ida:
+out_debugfs_remove:
 	debugfs_remove(gb->file);
+out_connection_destroy:
+	gb_connection_destroy(connection);
 out_kzalloc:
 	kfree(gb);
 
 	return retval;
 }
 
-static void gb_loopback_connection_exit(struct gb_connection *connection)
+static void gb_loopback_disconnect(struct gb_bundle *bundle)
 {
-	struct gb_loopback *gb = connection->private;
+	struct gb_loopback *gb = greybus_get_drvdata(bundle);
 	unsigned long flags;
 
+	gb_connection_disable(gb->connection);
+
 	if (!IS_ERR_OR_NULL(gb->task))
 		kthread_stop(gb->task);
 
 	kfifo_free(&gb->kfifo_lat);
 	kfifo_free(&gb->kfifo_ts);
-	gb_connection_latency_tag_disable(connection);
+	gb_connection_latency_tag_disable(gb->connection);
 	debugfs_remove(gb->file);
+
+	/*
+	 * FIXME: gb_loopback_async_wait_all() is redundant now, as connection
+	 * is disabled at the beginning and so we can't have any more
+	 * incoming/outgoing requests.
+	 */
 	gb_loopback_async_wait_all(gb);
 
 	spin_lock_irqsave(&gb_dev.lock, flags);
@@ -1205,17 +1239,21 @@ static void gb_loopback_connection_exit(struct gb_connection *connection)
 	device_unregister(gb->dev);
 	ida_simple_remove(&loopback_ida, gb->id);
 
+	gb_connection_destroy(gb->connection);
 	kfree(gb);
 }
 
-static struct gb_protocol loopback_protocol = {
-	.name			= "loopback",
-	.id			= GREYBUS_PROTOCOL_LOOPBACK,
-	.major			= GB_LOOPBACK_VERSION_MAJOR,
-	.minor			= GB_LOOPBACK_VERSION_MINOR,
-	.connection_init	= gb_loopback_connection_init,
-	.connection_exit	= gb_loopback_connection_exit,
-	.request_recv		= gb_loopback_request_recv,
+static const struct greybus_bundle_id gb_loopback_id_table[] = {
+	{ GREYBUS_DEVICE_CLASS(GREYBUS_CLASS_LOOPBACK) },
+	{ }
+};
+MODULE_DEVICE_TABLE(greybus, gb_loopback_id_table);
+
+static struct greybus_driver gb_loopback_driver = {
+	.name		= "loopback",
+	.probe		= gb_loopback_probe,
+	.disconnect	= gb_loopback_disconnect,
+	.id_table	= gb_loopback_id_table,
 };
 
 static int loopback_init(void)
@@ -1231,7 +1269,7 @@ static int loopback_init(void)
 	if (retval)
 		goto err;
 
-	retval = gb_protocol_register(&loopback_protocol);
+	retval = greybus_register(&gb_loopback_driver);
 	if (retval)
 		goto err_unregister;
 
@@ -1248,7 +1286,7 @@ module_init(loopback_init);
 static void __exit loopback_exit(void)
 {
 	debugfs_remove_recursive(gb_dev.root);
-	gb_protocol_deregister(&loopback_protocol);
+	greybus_deregister(&gb_loopback_driver);
 	class_unregister(&loopback_class);
 	ida_destroy(&loopback_ida);
 }

commit 8d46ec49819599d33ee5cffd43b19bf21f9472b8
Author: Johan Hovold <johan@hovoldconsulting.com>
Date:   Wed Feb 10 12:31:03 2016 +0100

    greybus: bundle: remove private data field
    
    Remove the private data field from the bundle structure as it is no
    longer needed. Bundle drivers can use the driver data field in the
    bundle device.
    
    Update the only current user to use the connection private data until it
    has been converted to a bundle driver.
    
    Signed-off-by: Johan Hovold <johan@hovoldconsulting.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/loopback.c b/drivers/staging/greybus/loopback.c
index 3f32dee1ec93..66b3fcaca9b0 100644
--- a/drivers/staging/greybus/loopback.c
+++ b/drivers/staging/greybus/loopback.c
@@ -1121,7 +1121,7 @@ static int gb_loopback_connection_init(struct gb_connection *connection)
 	gb->file = debugfs_create_file(name, S_IFREG | S_IRUGO, gb_dev.root, gb,
 				       &gb_loopback_debugfs_latency_ops);
 	gb->connection = connection;
-	connection->bundle->private = gb;
+	connection->private = gb;
 
 	gb->id = ida_simple_get(&loopback_ida, 0, 0, GFP_KERNEL);
 	if (gb->id < 0) {
@@ -1177,7 +1177,6 @@ static int gb_loopback_connection_init(struct gb_connection *connection)
 	ida_simple_remove(&loopback_ida, gb->id);
 out_ida:
 	debugfs_remove(gb->file);
-	connection->bundle->private = NULL;
 out_kzalloc:
 	kfree(gb);
 
@@ -1186,13 +1185,12 @@ static int gb_loopback_connection_init(struct gb_connection *connection)
 
 static void gb_loopback_connection_exit(struct gb_connection *connection)
 {
-	struct gb_loopback *gb = connection->bundle->private;
+	struct gb_loopback *gb = connection->private;
 	unsigned long flags;
 
 	if (!IS_ERR_OR_NULL(gb->task))
 		kthread_stop(gb->task);
 
-	connection->bundle->private = NULL;
 	kfifo_free(&gb->kfifo_lat);
 	kfifo_free(&gb->kfifo_ts);
 	gb_connection_latency_tag_disable(connection);

commit 8923c5b59ffd18b8a31b18dd02332fdfe801f7c9
Author: Johan Hovold <johan@hovoldconsulting.com>
Date:   Thu Feb 11 13:52:49 2016 +0100

    greybus: loopback: add missing pr_fmt
    
    Add missing pr_fmt so we can at least tell what module the sole
    remaining pr_err was from.
    
    Testing Done:
    Tested on DB3.5 with the generic bridge firmware on APB2.
    
    Signed-off-by: Johan Hovold <johan@hovoldconsulting.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/loopback.c b/drivers/staging/greybus/loopback.c
index c35d22733a36..3f32dee1ec93 100644
--- a/drivers/staging/greybus/loopback.c
+++ b/drivers/staging/greybus/loopback.c
@@ -6,6 +6,9 @@
  *
  * Released under the GPLv2 only.
  */
+
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+
 #include <linux/kernel.h>
 #include <linux/module.h>
 #include <linux/mutex.h>

commit 8e3fba55d379bb67732c878988cf9859bfea2812
Author: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
Date:   Fri Dec 11 13:46:53 2015 +0000

    greybus: loopback: Add asynchronous backoff
    
    A specific request from the firmware people is the ability to back-off from
    sending more asynchronous operations once a specific number of operations
    are in-flight.
    
    This patch adds that ability - with a new sysfs parameter
    'outstanding_operations_max' which controls the maximum number of
    operations that can be outstanding/in-flight at any time.
    
    When outstanding_operations_max contains a non-zero value and asynchronous
    operations are being used - we will back-off until the completion counter
    is < outstanding_operations_max. Tested in both synchronous and
    asynchronous mode and with gb_loopback_connection_exit() interrupting
    in-flight operations.
    
    Suggested-by: Johan Hovold <johan@hovoldconsulting.com>
    Signed-off-by: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
    Reviewed-by: Johan Hovold <johan@hovoldconsulting.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/loopback.c b/drivers/staging/greybus/loopback.c
index 4814f948eea3..c35d22733a36 100644
--- a/drivers/staging/greybus/loopback.c
+++ b/drivers/staging/greybus/loopback.c
@@ -98,6 +98,7 @@ struct gb_loopback {
 	u32 jiffy_timeout;
 	u32 timeout_min;
 	u32 timeout_max;
+	u32 outstanding_operations_max;
 	u32 lbid;
 	u64 elapsed_nsecs;
 	u32 apbridge_latency_ts;
@@ -311,6 +312,8 @@ gb_dev_loopback_ro_attr(iteration_count, false);
 gb_dev_loopback_rw_attr(async, u);
 /* Timeout of an individual asynchronous request */
 gb_dev_loopback_rw_attr(timeout, u);
+/* Maximum number of in-flight operations before back-off */
+gb_dev_loopback_rw_attr(outstanding_operations_max, u);
 
 static struct attribute *loopback_attrs[] = {
 	&dev_attr_latency_min.attr,
@@ -338,6 +341,7 @@ static struct attribute *loopback_attrs[] = {
 	&dev_attr_requests_completed.attr,
 	&dev_attr_requests_timedout.attr,
 	&dev_attr_timeout.attr,
+	&dev_attr_outstanding_operations_max.attr,
 	&dev_attr_timeout_min.attr,
 	&dev_attr_timeout_max.attr,
 	NULL,
@@ -911,6 +915,16 @@ static void gb_loopback_calculate_stats(struct gb_loopback *gb)
 				 gb->gpbridge_latency_ts);
 }
 
+static void gb_loopback_async_wait_to_send(struct gb_loopback *gb)
+{
+	if (!(gb->async && gb->outstanding_operations_max))
+		return;
+	wait_event_interruptible(gb->wq_completion,
+				 (atomic_read(&gb->outstanding_operations) <
+				  gb->outstanding_operations_max) ||
+				  kthread_should_stop());
+}
+
 static int gb_loopback_fn(void *data)
 {
 	int error = 0;
@@ -924,7 +938,11 @@ static int gb_loopback_fn(void *data)
 		if (!gb->type)
 			wait_event_interruptible(gb->wq, gb->type ||
 						 kthread_should_stop());
+		if (kthread_should_stop())
+			break;
 
+		/* Limit the maximum number of in-flight async operations */
+		gb_loopback_async_wait_to_send(gb);
 		if (kthread_should_stop())
 			break;
 

commit 36f241fff4720f205e36bda5900d4ef7b6662bd7
Author: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
Date:   Fri Dec 11 13:46:52 2015 +0000

    greybus: loopback: Wait for all async operations to complete on exit
    
    On gb_loopback_connection_exit() we should ensure every issued asynchronous
    operation completes before exiting connection_exit(). This patch introduces
    a waitqueue with a counter which represents the number of incomplete
    asynchronous operations. When the counter reaches zero connection_exit()
    will complete. At the point which we wait for outstanding operations to
    complete the connection-specific loopback thread will have ceased to issue
    new operations. Tested with both synchronous and asynchronous operations.
    
    Reviewed-by: Johan Hovold <johan@hovoldconsulting.com>
    Suggested-by: Johan Hovold <johan@hovoldconsulting.com>
    Signed-off-by: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/loopback.c b/drivers/staging/greybus/loopback.c
index eb6a0138fb1d..4814f948eea3 100644
--- a/drivers/staging/greybus/loopback.c
+++ b/drivers/staging/greybus/loopback.c
@@ -21,6 +21,7 @@
 #include <linux/list_sort.h>
 #include <linux/spinlock.h>
 #include <linux/workqueue.h>
+#include <linux/atomic.h>
 
 #include <asm/div64.h>
 
@@ -73,6 +74,8 @@ struct gb_loopback {
 	struct list_head entry;
 	struct device *dev;
 	wait_queue_head_t wq;
+	wait_queue_head_t wq_completion;
+	atomic_t outstanding_operations;
 
 	/* Per connection stats */
 	struct gb_loopback_stats latency;
@@ -433,6 +436,8 @@ static void __gb_loopback_async_operation_destroy(struct kref *kref)
 	list_del(&op_async->entry);
 	if (op_async->operation)
 		gb_operation_put(op_async->operation);
+	atomic_dec(&op_async->gb->outstanding_operations);
+	wake_up(&op_async->gb->wq_completion);
 	kfree(op_async);
 }
 
@@ -472,6 +477,12 @@ static struct gb_loopback_async_operation *
 	return found ? op_async : NULL;
 }
 
+static void gb_loopback_async_wait_all(struct gb_loopback *gb)
+{
+	wait_event(gb->wq_completion,
+		   !atomic_read(&gb->outstanding_operations));
+}
+
 static void gb_loopback_async_operation_callback(struct gb_operation *operation)
 {
 	struct gb_loopback_async_operation *op_async;
@@ -597,6 +608,7 @@ static int gb_loopback_async_operation(struct gb_loopback *gb, int type,
 
 	do_gettimeofday(&op_async->ts);
 	op_async->pending = true;
+	atomic_inc(&gb->outstanding_operations);
 	ret = gb_operation_request_send(operation,
 					gb_loopback_async_operation_callback,
 					GFP_KERNEL);
@@ -1063,6 +1075,8 @@ static int gb_loopback_connection_init(struct gb_connection *connection)
 		return -ENOMEM;
 
 	init_waitqueue_head(&gb->wq);
+	init_waitqueue_head(&gb->wq_completion);
+	atomic_set(&gb->outstanding_operations, 0);
 	gb_loopback_reset_stats(gb);
 
 	/* Reported values to user-space for min/max timeouts */
@@ -1162,6 +1176,7 @@ static void gb_loopback_connection_exit(struct gb_connection *connection)
 	kfifo_free(&gb->kfifo_ts);
 	gb_connection_latency_tag_disable(connection);
 	debugfs_remove(gb->file);
+	gb_loopback_async_wait_all(gb);
 
 	spin_lock_irqsave(&gb_dev.lock, flags);
 	gb_dev.count--;

commit c7aae4e613ef471f9f785e4b85de4d46d552c86b
Author: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
Date:   Fri Dec 11 13:46:51 2015 +0000

    greybus: loopback: Retrun -ENOMEM if operation allocation fails
    
    If operation allocation fails we should return -ENOMEM in the asynchronous
    operation send routine. If we don't return here then the
    gb_loopback_async_operation_put() later can dereference a NULL pointer if
    the previous gb_operation_create() failed.
    
    Reported-by: Johan Hovold <johan@hovoldconsulting.com>
    Signed-off-by: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
    Reviewed-by: Johan Hovold <johan@hovoldconsulting.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/loopback.c b/drivers/staging/greybus/loopback.c
index 0828772fc901..eb6a0138fb1d 100644
--- a/drivers/staging/greybus/loopback.c
+++ b/drivers/staging/greybus/loopback.c
@@ -580,8 +580,8 @@ static int gb_loopback_async_operation(struct gb_loopback *gb, int type,
 	operation = gb_operation_create(gb->connection, type, request_size,
 					response_size, GFP_KERNEL);
 	if (!operation) {
-		ret = -ENOMEM;
-		goto error;
+		kfree(op_async);
+		return -ENOMEM;
 	}
 
 	if (request_size)

commit 578a0ab8dd02f1de4b3b0e7b227ff78ae54fa4e1
Author: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
Date:   Fri Dec 11 13:46:50 2015 +0000

    greybus: loopback: Drop NULL check on container_of pointer
    
    container_of cannot return NULL and the pointer passed to this context uses
    reference counter bumped inside a spinlock, so the base pointer will be
    valid at this point.
    
    Suggested-by: Johan Hovold <johan@hovoldconstulting.com>
    Signed-off-by: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
    Reviewed-by: Johan Hovold <johan@hovoldconsulting.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/loopback.c b/drivers/staging/greybus/loopback.c
index 68372918f653..0828772fc901 100644
--- a/drivers/staging/greybus/loopback.c
+++ b/drivers/staging/greybus/loopback.c
@@ -526,9 +526,6 @@ static void gb_loopback_async_operation_work(struct work_struct *work)
 	struct gb_loopback_async_operation *op_async;
 
 	op_async = container_of(work, struct gb_loopback_async_operation, work);
-	if (!op_async)
-		return;
-
 	gb = op_async->gb;
 	operation = op_async->operation;
 

commit 079fa32ba53a205a745e75b045361beeffdfeaba
Author: Axel Haslam <ahaslam@baylibre.com>
Date:   Fri Dec 11 11:49:45 2015 +0100

    greybus: loopback: register a struct device.
    
    Instead of having the loopback attributes in the bundle device,
    Add a struct device to the gb_loopback struct and register it on
    connection_init, deregister it at connection_exit, and move the
    loopback attribute group over to the new device.
    
    Use device_create_with_groups to create sysfs attributes
    together with device.
    
    Suggested-by: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
    Suggested-by: Johan Hovold <johan@hovoldconsulting.com>
    Signed-off-by: Axel Haslam <ahaslam@baylibre.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/loopback.c b/drivers/staging/greybus/loopback.c
index 6a5eee35e9c0..68372918f653 100644
--- a/drivers/staging/greybus/loopback.c
+++ b/drivers/staging/greybus/loopback.c
@@ -71,6 +71,7 @@ struct gb_loopback {
 	struct mutex mutex;
 	struct task_struct *task;
 	struct list_head entry;
+	struct device *dev;
 	wait_queue_head_t wq;
 
 	/* Per connection stats */
@@ -82,6 +83,7 @@ struct gb_loopback {
 
 	int type;
 	int async;
+	int id;
 	u32 size;
 	u32 iteration_max;
 	u32 iteration_count;
@@ -99,6 +101,12 @@ struct gb_loopback {
 	u32 gpbridge_latency_ts;
 };
 
+static struct class loopback_class = {
+	.name		= "gb_loopback",
+	.owner		= THIS_MODULE,
+};
+static DEFINE_IDA(loopback_ida);
+
 /* Min/max values in jiffies */
 #define GB_LOOPBACK_TIMEOUT_MIN				1
 #define GB_LOOPBACK_TIMEOUT_MAX				10000
@@ -119,10 +127,7 @@ static ssize_t field##_show(struct device *dev,			\
 			    struct device_attribute *attr,		\
 			    char *buf)					\
 {									\
-	struct gb_bundle *bundle;					\
-	struct gb_loopback *gb;						\
-	bundle = to_gb_bundle(dev);				\
-	gb = bundle->private;					\
+	struct gb_loopback *gb = dev_get_drvdata(dev);			\
 	return sprintf(buf, "%u\n", gb->field);			\
 }									\
 static DEVICE_ATTR_RO(field)
@@ -132,10 +137,7 @@ static ssize_t name##_##field##_show(struct device *dev,	\
 			    struct device_attribute *attr,		\
 			    char *buf)					\
 {									\
-	struct gb_bundle *bundle;					\
-	struct gb_loopback *gb;						\
-	bundle = to_gb_bundle(dev);				\
-	gb = bundle->private;					\
+	struct gb_loopback *gb = dev_get_drvdata(dev);			\
 	return sprintf(buf, "%"#type"\n", gb->name.field);	\
 }									\
 static DEVICE_ATTR_RO(name##_##field)
@@ -146,12 +148,10 @@ static ssize_t name##_avg_show(struct device *dev,		\
 			    char *buf)					\
 {									\
 	struct gb_loopback_stats *stats;				\
-	struct gb_bundle *bundle;					\
 	struct gb_loopback *gb;						\
 	u64 avg;							\
 	u32 count, rem;							\
-	bundle = to_gb_bundle(dev);				\
-	gb = bundle->private;					\
+	gb = dev_get_drvdata(dev);			\
 	stats = &gb->name;					\
 	count = stats->count ? stats->count : 1;			\
 	avg = stats->sum + count / 2;	/* round closest */		\
@@ -170,8 +170,7 @@ static ssize_t field##_show(struct device *dev,				\
 			    struct device_attribute *attr,		\
 			    char *buf)					\
 {									\
-	struct gb_bundle *bundle = to_gb_bundle(dev);			\
-	struct gb_loopback *gb = bundle->private;			\
+	struct gb_loopback *gb = dev_get_drvdata(dev);			\
 	return sprintf(buf, "%"#type"\n", gb->field);			\
 }									\
 static ssize_t field##_store(struct device *dev,			\
@@ -180,8 +179,7 @@ static ssize_t field##_store(struct device *dev,			\
 			    size_t len)					\
 {									\
 	int ret;							\
-	struct gb_bundle *bundle = to_gb_bundle(dev);			\
-	struct gb_loopback *gb = bundle->private;			\
+	struct gb_loopback *gb = dev_get_drvdata(dev);			\
 	mutex_lock(&gb->mutex);						\
 	ret = sscanf(buf, "%"#type, &gb->field);			\
 	if (ret != 1)							\
@@ -198,8 +196,7 @@ static ssize_t field##_show(struct device *dev,		\
 			    struct device_attribute *attr,		\
 			    char *buf)					\
 {									\
-	struct gb_bundle *bundle = to_gb_bundle(dev);			\
-	struct gb_loopback *gb = bundle->private;			\
+	struct gb_loopback *gb = dev_get_drvdata(dev);			\
 	return sprintf(buf, "%u\n", gb->field);				\
 }									\
 static DEVICE_ATTR_RO(field)
@@ -209,8 +206,7 @@ static ssize_t field##_show(struct device *dev,				\
 			    struct device_attribute *attr,		\
 			    char *buf)					\
 {									\
-	struct gb_bundle *bundle = to_gb_bundle(dev);			\
-	struct gb_loopback *gb = bundle->private;			\
+	struct gb_loopback *gb = dev_get_drvdata(dev);			\
 	return sprintf(buf, "%"#type"\n", gb->field);			\
 }									\
 static ssize_t field##_store(struct device *dev,			\
@@ -219,22 +215,20 @@ static ssize_t field##_store(struct device *dev,			\
 			    size_t len)					\
 {									\
 	int ret;							\
-	struct gb_bundle *bundle = to_gb_bundle(dev);			\
-	struct gb_loopback *gb = bundle->private;			\
+	struct gb_loopback *gb = dev_get_drvdata(dev);			\
 	mutex_lock(&gb->mutex);						\
 	ret = sscanf(buf, "%"#type, &gb->field);			\
 	if (ret != 1)							\
 		len = -EINVAL;						\
 	else								\
-		gb_loopback_check_attr(gb, bundle);		\
+		gb_loopback_check_attr(gb);		\
 	mutex_unlock(&gb->mutex);					\
 	return len;							\
 }									\
 static DEVICE_ATTR_RW(field)
 
 static void gb_loopback_reset_stats(struct gb_loopback *gb);
-static void gb_loopback_check_attr(struct gb_loopback *gb,
-				   struct gb_bundle *bundle)
+static void gb_loopback_check_attr(struct gb_loopback *gb)
 {
 	if (gb->us_wait > GB_LOOPBACK_US_WAIT_MAX)
 		gb->us_wait = GB_LOOPBACK_US_WAIT_MAX;
@@ -246,7 +240,7 @@ static void gb_loopback_check_attr(struct gb_loopback *gb,
 	gb->error = 0;
 
 	if (kfifo_depth < gb->iteration_max) {
-		dev_warn(&bundle->dev,
+		dev_warn(gb->dev,
 			 "cannot log bytes %u kfifo_depth %u\n",
 			 gb->iteration_max, kfifo_depth);
 	}
@@ -1062,6 +1056,7 @@ static void gb_loopback_insert_id(struct gb_loopback *gb)
 static int gb_loopback_connection_init(struct gb_connection *connection)
 {
 	struct gb_loopback *gb;
+	struct device *dev;
 	int retval;
 	char name[DEBUGFS_NAMELEN];
 	unsigned long flags;
@@ -1095,16 +1090,28 @@ static int gb_loopback_connection_init(struct gb_connection *connection)
 				       &gb_loopback_debugfs_latency_ops);
 	gb->connection = connection;
 	connection->bundle->private = gb;
-	retval = sysfs_create_groups(&connection->bundle->dev.kobj,
-				     loopback_groups);
-	if (retval)
-		goto out_sysfs;
+
+	gb->id = ida_simple_get(&loopback_ida, 0, 0, GFP_KERNEL);
+	if (gb->id < 0) {
+		retval = gb->id;
+		goto out_ida;
+	}
+
+	dev = device_create_with_groups(&loopback_class,
+					&connection->bundle->dev,
+					MKDEV(0, 0), gb, loopback_groups,
+					"gb_loopback%d", gb->id);
+	if (IS_ERR(dev)) {
+		retval = PTR_ERR(dev);
+		goto out_dev;
+	}
+	gb->dev = dev;
 
 	/* Allocate kfifo */
 	if (kfifo_alloc(&gb->kfifo_lat, kfifo_depth * sizeof(u32),
 			  GFP_KERNEL)) {
 		retval = -ENOMEM;
-		goto out_sysfs_conn;
+		goto out_conn;
 	}
 	if (kfifo_alloc(&gb->kfifo_ts, kfifo_depth * sizeof(struct timeval) * 2,
 			  GFP_KERNEL)) {
@@ -1132,9 +1139,11 @@ static int gb_loopback_connection_init(struct gb_connection *connection)
 	kfifo_free(&gb->kfifo_ts);
 out_kfifo0:
 	kfifo_free(&gb->kfifo_lat);
-out_sysfs_conn:
-	sysfs_remove_groups(&connection->bundle->dev.kobj, loopback_groups);
-out_sysfs:
+out_conn:
+	device_unregister(dev);
+out_dev:
+	ida_simple_remove(&loopback_ida, gb->id);
+out_ida:
 	debugfs_remove(gb->file);
 	connection->bundle->private = NULL;
 out_kzalloc:
@@ -1155,8 +1164,6 @@ static void gb_loopback_connection_exit(struct gb_connection *connection)
 	kfifo_free(&gb->kfifo_lat);
 	kfifo_free(&gb->kfifo_ts);
 	gb_connection_latency_tag_disable(connection);
-	sysfs_remove_groups(&connection->bundle->dev.kobj,
-			    loopback_groups);
 	debugfs_remove(gb->file);
 
 	spin_lock_irqsave(&gb_dev.lock, flags);
@@ -1164,6 +1171,9 @@ static void gb_loopback_connection_exit(struct gb_connection *connection)
 	list_del(&gb->entry);
 	spin_unlock_irqrestore(&gb_dev.lock, flags);
 
+	device_unregister(gb->dev);
+	ida_simple_remove(&loopback_ida, gb->id);
+
 	kfree(gb);
 }
 
@@ -1186,10 +1196,19 @@ static int loopback_init(void)
 	spin_lock_init(&gb_dev.lock);
 	gb_dev.root = debugfs_create_dir("gb_loopback", NULL);
 
+	retval = class_register(&loopback_class);
+	if (retval)
+		goto err;
+
 	retval = gb_protocol_register(&loopback_protocol);
-	if (!retval)
-		return retval;
+	if (retval)
+		goto err_unregister;
+
+	return 0;
 
+err_unregister:
+	class_unregister(&loopback_class);
+err:
 	debugfs_remove_recursive(gb_dev.root);
 	return retval;
 }
@@ -1199,6 +1218,8 @@ static void __exit loopback_exit(void)
 {
 	debugfs_remove_recursive(gb_dev.root);
 	gb_protocol_deregister(&loopback_protocol);
+	class_unregister(&loopback_class);
+	ida_destroy(&loopback_ida);
 }
 module_exit(loopback_exit);
 

commit 3647a313de367e98840c4dfab491dfbeaf2cf9a4
Author: Axel Haslam <ahaslam@baylibre.com>
Date:   Tue Dec 8 18:26:31 2015 +0100

    greybus: loopback: remove mask attribute
    
    The mask attribute is not used on the driver anymore and can be
    removed.
    
    Signed-off-by: Axel Haslam <ahaslam@baylibre.com>
    Reviewed-by: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/loopback.c b/drivers/staging/greybus/loopback.c
index 626a841b1fe2..6a5eee35e9c0 100644
--- a/drivers/staging/greybus/loopback.c
+++ b/drivers/staging/greybus/loopback.c
@@ -82,7 +82,6 @@ struct gb_loopback {
 
 	int type;
 	int async;
-	u32 mask;
 	u32 size;
 	u32 iteration_max;
 	u32 iteration_count;
@@ -311,8 +310,6 @@ gb_dev_loopback_rw_attr(us_wait, d);
 gb_dev_loopback_rw_attr(iteration_max, u);
 /* The current index of the for (i = 0; i < iteration_max; i++) loop */
 gb_dev_loopback_ro_attr(iteration_count, false);
-/* A bit-mask of destination connections to include in the test run */
-gb_dev_loopback_rw_attr(mask, u);
 /* A flag to indicate synchronous or asynchronous operations */
 gb_dev_loopback_rw_attr(async, u);
 /* Timeout of an individual asynchronous request */
@@ -339,7 +336,6 @@ static struct attribute *loopback_attrs[] = {
 	&dev_attr_us_wait.attr,
 	&dev_attr_iteration_count.attr,
 	&dev_attr_iteration_max.attr,
-	&dev_attr_mask.attr,
 	&dev_attr_async.attr,
 	&dev_attr_error.attr,
 	&dev_attr_requests_completed.attr,

commit f42a6891d18a156f41813e3cb924470d1e2ff9ad
Author: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
Date:   Mon Dec 7 01:59:08 2015 +0000

    greybus: loopback: Ensure we reset stats once and once only
    
    9445c54c ('greybus/loopback: drop bus aggregate calculation') removed the
    aggregation of data in-kernel but instead of dropping the reset of
    aggregate stastics, converted that reset into a second reset of the
    connection-level stats. While this doesn't result in anything bad it's
    also definitely a dumb thing to be doing, so, drop it now.
    
    Also ensure we reset the bridge-specific tracking variables at least once.
    
    Signed-off-by: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/loopback.c b/drivers/staging/greybus/loopback.c
index b8297d6b7e60..626a841b1fe2 100644
--- a/drivers/staging/greybus/loopback.c
+++ b/drivers/staging/greybus/loopback.c
@@ -837,19 +837,9 @@ static void gb_loopback_reset_stats(struct gb_loopback *gb)
 	memcpy(&gb->gpbridge_firmware_latency, &reset,
 	       sizeof(struct gb_loopback_stats));
 
-	/* Set values to report min/max timeout to user-space */
-	gb->timeout_min = jiffies_to_usecs(GB_LOOPBACK_TIMEOUT_MIN);
-	gb->timeout_max = jiffies_to_usecs(GB_LOOPBACK_TIMEOUT_MAX);
-
-	/* Reset aggregate stats */
-	memcpy(&gb->latency, &reset, sizeof(struct gb_loopback_stats));
-	memcpy(&gb->throughput, &reset, sizeof(struct gb_loopback_stats));
-	memcpy(&gb->requests_per_second, &reset,
-	       sizeof(struct gb_loopback_stats));
-	memcpy(&gb->apbridge_unipro_latency, &reset,
-	       sizeof(struct gb_loopback_stats));
-	memcpy(&gb->gpbridge_firmware_latency, &reset,
-	       sizeof(struct gb_loopback_stats));
+	/* Should be initialized at least once per transaction set */
+	gb->apbridge_latency_ts = 0;
+	gb->gpbridge_latency_ts = 0;
 }
 
 static void gb_loopback_update_stats(struct gb_loopback_stats *stats, u32 val)

commit b36f04fa9417c58d53b1c54bf868b9da8f73810f
Author: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
Date:   Mon Dec 7 01:59:07 2015 +0000

    greybus: loopback: Convert thread delay to microseconds
    
    Currently the loopback code allows a delay between operations specified in
    milliseconds. Having added asynchronous bi-directional support to loopback
    its obvious that the delay value would be far more useful specified in
    microseconds than milliseconds. So, this patch makes the necessary
    conversion.
    
    Signed-off-by: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/loopback.c b/drivers/staging/greybus/loopback.c
index 392f9854ff56..b8297d6b7e60 100644
--- a/drivers/staging/greybus/loopback.c
+++ b/drivers/staging/greybus/loopback.c
@@ -86,7 +86,7 @@ struct gb_loopback {
 	u32 size;
 	u32 iteration_max;
 	u32 iteration_count;
-	int ms_wait;
+	int us_wait;
 	u32 error;
 	u32 requests_completed;
 	u32 requests_timedout;
@@ -112,7 +112,7 @@ module_param(kfifo_depth, uint, 0444);
 /* Maximum size of any one send data buffer we support */
 #define MAX_PACKET_SIZE (PAGE_SIZE * 2)
 
-#define GB_LOOPBACK_MS_WAIT_MAX				1000
+#define GB_LOOPBACK_US_WAIT_MAX				1000000
 
 /* interface sysfs attributes */
 #define gb_loopback_ro_attr(field)				\
@@ -237,8 +237,8 @@ static void gb_loopback_reset_stats(struct gb_loopback *gb);
 static void gb_loopback_check_attr(struct gb_loopback *gb,
 				   struct gb_bundle *bundle)
 {
-	if (gb->ms_wait > GB_LOOPBACK_MS_WAIT_MAX)
-		gb->ms_wait = GB_LOOPBACK_MS_WAIT_MAX;
+	if (gb->us_wait > GB_LOOPBACK_US_WAIT_MAX)
+		gb->us_wait = GB_LOOPBACK_US_WAIT_MAX;
 	if (gb->size > gb_dev.size_max)
 		gb->size = gb_dev.size_max;
 	gb->requests_timedout = 0;
@@ -306,7 +306,7 @@ gb_dev_loopback_rw_attr(type, d);
 /* Size of transfer message payload: 0-4096 bytes */
 gb_dev_loopback_rw_attr(size, u);
 /* Time to wait between two messages: 0-1000 ms */
-gb_dev_loopback_rw_attr(ms_wait, d);
+gb_dev_loopback_rw_attr(us_wait, d);
 /* Maximum iterations for a given operation: 1-(2^32-1), 0 implies infinite */
 gb_dev_loopback_rw_attr(iteration_max, u);
 /* The current index of the for (i = 0; i < iteration_max; i++) loop */
@@ -336,7 +336,7 @@ static struct attribute *loopback_attrs[] = {
 	&dev_attr_gpbridge_firmware_latency_avg.attr,
 	&dev_attr_type.attr,
 	&dev_attr_size.attr,
-	&dev_attr_ms_wait.attr,
+	&dev_attr_us_wait.attr,
 	&dev_attr_iteration_count.attr,
 	&dev_attr_iteration_max.attr,
 	&dev_attr_mask.attr,
@@ -925,7 +925,7 @@ static void gb_loopback_calculate_stats(struct gb_loopback *gb)
 static int gb_loopback_fn(void *data)
 {
 	int error = 0;
-	int ms_wait = 0;
+	int us_wait = 0;
 	int type;
 	u32 size;
 	u32 send_count = 0;
@@ -951,7 +951,7 @@ static int gb_loopback_fn(void *data)
 			continue;
 		}
 		size = gb->size;
-		ms_wait = gb->ms_wait;
+		us_wait = gb->us_wait;
 		type = gb->type;
 		mutex_unlock(&gb->mutex);
 
@@ -983,8 +983,8 @@ static int gb_loopback_fn(void *data)
 			gb_loopback_calculate_stats(gb);
 		}
 		send_count++;
-		if (ms_wait)
-			msleep(ms_wait);
+		if (us_wait)
+			udelay(us_wait);
 	}
 	return 0;
 }

commit 12927835d21127d7e528b9ed56fc334ac96db985
Author: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
Date:   Mon Dec 7 01:59:06 2015 +0000

    greybus: loopback: Add asynchronous bi-directional support
    
    A particular ask from the firmware people for some time now has been the
    ability to drive multiple outstanding bi-directional operations from
    loopback to loopback Interfaces. This patch implments that change.
    
    The approach taken is to make a call to gb_operation_send() and have
    loopback capture the completion callback itself, with a parallel timer to
    timeout completion callbacks that take too long. The calling thread will
    issue each gb_operation_send() as fast as it can within the constraints of
    thread-safety.
    
    In order to support this addition the following new sysfs entries are
    created on a per-connection basis.
    
    - async
      Zero indicates loopback should use the traditional synchronous model
      i.e. gb_operation_request_send_sync().
    
      Non-zero indicates loopback should use the new asynchronous model i.e.
      gb_operation_send()
    
    - requests_completed
      This value indicates the number of requests successfully completed.
    
    - requests_timedout
      This value indicates the number of requests which timed out.
    
    - timeout
      The number of microseconds to give an individual asynchronous request
      before timing that request out.
    
    - timeout_min
      Read-only attribute informs user-space of the minimum allowed timeout.
    
    - timeout_max
      Read-only attribute informs user-space of the maximum allowed timeout.
    
    Note requests_completed + requests_timedout should always equal
    iteration_max, once iteration_count == iteration_max. Also, at this time we
    support either synchronous or asynchronous operations in one set of
    transactions.
    
    Signed-off-by: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/loopback.c b/drivers/staging/greybus/loopback.c
index b65e3e591105..392f9854ff56 100644
--- a/drivers/staging/greybus/loopback.c
+++ b/drivers/staging/greybus/loopback.c
@@ -20,6 +20,7 @@
 #include <linux/debugfs.h>
 #include <linux/list_sort.h>
 #include <linux/spinlock.h>
+#include <linux/workqueue.h>
 
 #include <asm/div64.h>
 
@@ -43,10 +44,24 @@ struct gb_loopback_device {
 	/* We need to take a lock in atomic context */
 	spinlock_t lock;
 	struct list_head list;
+	struct list_head list_op_async;
+	wait_queue_head_t wq;
 };
 
 static struct gb_loopback_device gb_dev;
 
+struct gb_loopback_async_operation {
+	struct gb_loopback *gb;
+	struct gb_operation *operation;
+	struct timeval ts;
+	struct timer_list timer;
+	struct list_head entry;
+	struct work_struct work;
+	struct kref kref;
+	bool pending;
+	int (*completion)(struct gb_loopback_async_operation *op_async);
+};
+
 struct gb_loopback {
 	struct gb_connection *connection;
 
@@ -66,18 +81,29 @@ struct gb_loopback {
 	struct gb_loopback_stats gpbridge_firmware_latency;
 
 	int type;
+	int async;
 	u32 mask;
 	u32 size;
 	u32 iteration_max;
 	u32 iteration_count;
 	int ms_wait;
 	u32 error;
+	u32 requests_completed;
+	u32 requests_timedout;
+	u32 timeout;
+	u32 jiffy_timeout;
+	u32 timeout_min;
+	u32 timeout_max;
 	u32 lbid;
 	u64 elapsed_nsecs;
 	u32 apbridge_latency_ts;
 	u32 gpbridge_latency_ts;
 };
 
+/* Min/max values in jiffies */
+#define GB_LOOPBACK_TIMEOUT_MIN				1
+#define GB_LOOPBACK_TIMEOUT_MAX				10000
+
 #define GB_LOOPBACK_FIFO_DEFAULT			8192
 
 static unsigned kfifo_depth = GB_LOOPBACK_FIFO_DEFAULT;
@@ -215,6 +241,8 @@ static void gb_loopback_check_attr(struct gb_loopback *gb,
 		gb->ms_wait = GB_LOOPBACK_MS_WAIT_MAX;
 	if (gb->size > gb_dev.size_max)
 		gb->size = gb_dev.size_max;
+	gb->requests_timedout = 0;
+	gb->requests_completed = 0;
 	gb->iteration_count = 0;
 	gb->error = 0;
 
@@ -230,6 +258,11 @@ static void gb_loopback_check_attr(struct gb_loopback *gb,
 	case GB_LOOPBACK_TYPE_PING:
 	case GB_LOOPBACK_TYPE_TRANSFER:
 	case GB_LOOPBACK_TYPE_SINK:
+		gb->jiffy_timeout = usecs_to_jiffies(gb->timeout);
+		if (!gb->jiffy_timeout)
+			gb->jiffy_timeout = GB_LOOPBACK_TIMEOUT_MIN;
+		else if (gb->jiffy_timeout > GB_LOOPBACK_TIMEOUT_MAX)
+			gb->jiffy_timeout = GB_LOOPBACK_TIMEOUT_MAX;
 		gb_loopback_reset_stats(gb);
 		wake_up(&gb->wq);
 		break;
@@ -252,6 +285,14 @@ gb_loopback_stats_attrs(gpbridge_firmware_latency);
 
 /* Number of errors encountered during loop */
 gb_loopback_ro_attr(error);
+/* Number of requests successfully completed async */
+gb_loopback_ro_attr(requests_completed);
+/* Number of requests timed out async */
+gb_loopback_ro_attr(requests_timedout);
+/* Timeout minimum in useconds */
+gb_loopback_ro_attr(timeout_min);
+/* Timeout minimum in useconds */
+gb_loopback_ro_attr(timeout_max);
 
 /*
  * Type of loopback message to send based on protocol type definitions
@@ -270,8 +311,12 @@ gb_dev_loopback_rw_attr(ms_wait, d);
 gb_dev_loopback_rw_attr(iteration_max, u);
 /* The current index of the for (i = 0; i < iteration_max; i++) loop */
 gb_dev_loopback_ro_attr(iteration_count, false);
-/* A bit-mask of destination connecitons to include in the test run */
+/* A bit-mask of destination connections to include in the test run */
 gb_dev_loopback_rw_attr(mask, u);
+/* A flag to indicate synchronous or asynchronous operations */
+gb_dev_loopback_rw_attr(async, u);
+/* Timeout of an individual asynchronous request */
+gb_dev_loopback_rw_attr(timeout, u);
 
 static struct attribute *loopback_attrs[] = {
 	&dev_attr_latency_min.attr,
@@ -295,11 +340,19 @@ static struct attribute *loopback_attrs[] = {
 	&dev_attr_iteration_count.attr,
 	&dev_attr_iteration_max.attr,
 	&dev_attr_mask.attr,
+	&dev_attr_async.attr,
 	&dev_attr_error.attr,
+	&dev_attr_requests_completed.attr,
+	&dev_attr_requests_timedout.attr,
+	&dev_attr_timeout.attr,
+	&dev_attr_timeout_min.attr,
+	&dev_attr_timeout_max.attr,
 	NULL,
 };
 ATTRIBUTE_GROUPS(loopback);
 
+static void gb_loopback_calculate_stats(struct gb_loopback *gb);
+
 static u32 gb_loopback_nsec_to_usec_latency(u64 elapsed_nsecs)
 {
 	u32 lat;
@@ -381,7 +434,200 @@ static int gb_loopback_operation_sync(struct gb_loopback *gb, int type,
 	return ret;
 }
 
-static int gb_loopback_sink(struct gb_loopback *gb, u32 len)
+static void __gb_loopback_async_operation_destroy(struct kref *kref)
+{
+	struct gb_loopback_async_operation *op_async;
+
+	op_async = container_of(kref, struct gb_loopback_async_operation, kref);
+
+	list_del(&op_async->entry);
+	if (op_async->operation)
+		gb_operation_put(op_async->operation);
+	kfree(op_async);
+}
+
+static void gb_loopback_async_operation_get(struct gb_loopback_async_operation
+					    *op_async)
+{
+	kref_get(&op_async->kref);
+}
+
+static void gb_loopback_async_operation_put(struct gb_loopback_async_operation
+					    *op_async)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&gb_dev.lock, flags);
+	kref_put(&op_async->kref, __gb_loopback_async_operation_destroy);
+	spin_unlock_irqrestore(&gb_dev.lock, flags);
+}
+
+static struct gb_loopback_async_operation *
+	gb_loopback_operation_find(u16 id)
+{
+	struct gb_loopback_async_operation *op_async;
+	bool found = false;
+	unsigned long flags;
+
+	spin_lock_irqsave(&gb_dev.lock, flags);
+	list_for_each_entry(op_async, &gb_dev.list_op_async, entry) {
+		if (op_async->operation->id == id) {
+			gb_loopback_async_operation_get(op_async);
+			found = true;
+			break;
+		}
+	}
+	spin_unlock_irqrestore(&gb_dev.lock, flags);
+
+	return found ? op_async : NULL;
+}
+
+static void gb_loopback_async_operation_callback(struct gb_operation *operation)
+{
+	struct gb_loopback_async_operation *op_async;
+	struct gb_loopback *gb;
+	struct timeval te;
+	bool err = false;
+
+	do_gettimeofday(&te);
+	op_async = gb_loopback_operation_find(operation->id);
+	if (!op_async)
+		return;
+
+	gb = op_async->gb;
+	mutex_lock(&gb->mutex);
+
+	if (!op_async->pending || gb_operation_result(operation)) {
+		err = true;
+	} else {
+		if (op_async->completion)
+			if (op_async->completion(op_async))
+				err = true;
+	}
+
+	if (err) {
+		gb->error++;
+	} else {
+		gb->requests_completed++;
+		gb_loopback_push_latency_ts(gb, &op_async->ts, &te);
+		gb->elapsed_nsecs = gb_loopback_calc_latency(&op_async->ts,
+							     &te);
+		gb_loopback_calculate_stats(gb);
+	}
+
+	if (op_async->pending) {
+		gb->iteration_count++;
+		op_async->pending = false;
+		del_timer_sync(&op_async->timer);
+		gb_loopback_async_operation_put(op_async);
+	}
+	mutex_unlock(&gb->mutex);
+
+	dev_dbg(&gb->connection->bundle->dev, "complete operation %d\n",
+		operation->id);
+
+	gb_loopback_async_operation_put(op_async);
+}
+
+static void gb_loopback_async_operation_work(struct work_struct *work)
+{
+	struct gb_loopback *gb;
+	struct gb_operation *operation;
+	struct gb_loopback_async_operation *op_async;
+
+	op_async = container_of(work, struct gb_loopback_async_operation, work);
+	if (!op_async)
+		return;
+
+	gb = op_async->gb;
+	operation = op_async->operation;
+
+	mutex_lock(&gb->mutex);
+	if (op_async->pending) {
+		gb->requests_timedout++;
+		gb->error++;
+		gb->iteration_count++;
+		op_async->pending = false;
+		gb_loopback_async_operation_put(op_async);
+	}
+	mutex_unlock(&gb->mutex);
+
+	dev_dbg(&gb->connection->bundle->dev, "timeout operation %d\n",
+		operation->id);
+
+	gb_operation_cancel(operation, -ETIMEDOUT);
+	gb_loopback_async_operation_put(op_async);
+}
+
+static void gb_loopback_async_operation_timeout(unsigned long data)
+{
+	struct gb_loopback_async_operation *op_async;
+	u16 id = data;
+
+	op_async = gb_loopback_operation_find(id);
+	if (!op_async) {
+		pr_err("operation %d not found - time out ?\n", id);
+		return;
+	}
+	schedule_work(&op_async->work);
+}
+
+static int gb_loopback_async_operation(struct gb_loopback *gb, int type,
+				       void *request, int request_size,
+				       int response_size,
+				       void *completion)
+{
+	struct gb_loopback_async_operation *op_async;
+	struct gb_operation *operation;
+	int ret;
+	unsigned long flags;
+
+	op_async = kzalloc(sizeof(*op_async), GFP_KERNEL);
+	if (!op_async)
+		return -ENOMEM;
+
+	INIT_WORK(&op_async->work, gb_loopback_async_operation_work);
+	init_timer(&op_async->timer);
+	kref_init(&op_async->kref);
+
+	operation = gb_operation_create(gb->connection, type, request_size,
+					response_size, GFP_KERNEL);
+	if (!operation) {
+		ret = -ENOMEM;
+		goto error;
+	}
+
+	if (request_size)
+		memcpy(operation->request->payload, request, request_size);
+
+	op_async->gb = gb;
+	op_async->operation = operation;
+	op_async->completion = completion;
+
+	spin_lock_irqsave(&gb_dev.lock, flags);
+	list_add_tail(&op_async->entry, &gb_dev.list_op_async);
+	spin_unlock_irqrestore(&gb_dev.lock, flags);
+
+	do_gettimeofday(&op_async->ts);
+	op_async->pending = true;
+	ret = gb_operation_request_send(operation,
+					gb_loopback_async_operation_callback,
+					GFP_KERNEL);
+	if (ret)
+		goto error;
+
+	op_async->timer.function = gb_loopback_async_operation_timeout;
+	op_async->timer.expires = jiffies + gb->jiffy_timeout;
+	op_async->timer.data = (unsigned long)operation->id;
+	add_timer(&op_async->timer);
+
+	return ret;
+error:
+	gb_loopback_async_operation_put(op_async);
+	return ret;
+}
+
+static int gb_loopback_sync_sink(struct gb_loopback *gb, u32 len)
 {
 	struct gb_loopback_transfer_request *request;
 	int retval;
@@ -398,7 +644,7 @@ static int gb_loopback_sink(struct gb_loopback *gb, u32 len)
 	return retval;
 }
 
-static int gb_loopback_transfer(struct gb_loopback *gb, u32 len)
+static int gb_loopback_sync_transfer(struct gb_loopback *gb, u32 len)
 {
 	struct gb_loopback_transfer_request *request;
 	struct gb_loopback_transfer_response *response;
@@ -440,12 +686,91 @@ static int gb_loopback_transfer(struct gb_loopback *gb, u32 len)
 	return retval;
 }
 
-static int gb_loopback_ping(struct gb_loopback *gb)
+static int gb_loopback_sync_ping(struct gb_loopback *gb)
 {
 	return gb_loopback_operation_sync(gb, GB_LOOPBACK_TYPE_PING,
 					  NULL, 0, NULL, 0);
 }
 
+static int gb_loopback_async_sink(struct gb_loopback *gb, u32 len)
+{
+	struct gb_loopback_transfer_request *request;
+	int retval;
+
+	request = kmalloc(len + sizeof(*request), GFP_KERNEL);
+	if (!request)
+		return -ENOMEM;
+
+	request->len = cpu_to_le32(len);
+	retval = gb_loopback_async_operation(gb, GB_LOOPBACK_TYPE_SINK,
+					     request, len + sizeof(*request),
+					     0, NULL);
+	kfree(request);
+	return retval;
+}
+
+static int gb_loopback_async_transfer_complete(
+				struct gb_loopback_async_operation *op_async)
+{
+	struct gb_loopback *gb;
+	struct gb_operation *operation;
+	struct gb_loopback_transfer_request *request;
+	struct gb_loopback_transfer_response *response;
+	size_t len;
+	int retval = 0;
+
+	gb = op_async->gb;
+	operation = op_async->operation;
+	request = operation->request->payload;
+	response = operation->response->payload;
+	len = le32_to_cpu(request->len);
+
+	if (memcmp(request->data, response->data, len)) {
+		dev_err(&gb->connection->bundle->dev,
+			"Loopback Data doesn't match operation id %d\n",
+			operation->id);
+		retval = -EREMOTEIO;
+	} else {
+		gb->apbridge_latency_ts =
+			(u32)__le32_to_cpu(response->reserved0);
+		gb->gpbridge_latency_ts =
+			(u32)__le32_to_cpu(response->reserved1);
+	}
+
+	return retval;
+}
+
+static int gb_loopback_async_transfer(struct gb_loopback *gb, u32 len)
+{
+	struct gb_loopback_transfer_request *request;
+	int retval, response_len;
+
+	request = kmalloc(len + sizeof(*request), GFP_KERNEL);
+	if (!request)
+		return -ENOMEM;
+
+	memset(request->data, 0x5A, len);
+
+	request->len = cpu_to_le32(len);
+	response_len = sizeof(struct gb_loopback_transfer_response);
+	retval = gb_loopback_async_operation(gb, GB_LOOPBACK_TYPE_TRANSFER,
+					     request, len + sizeof(*request),
+					     len + response_len,
+					     gb_loopback_async_transfer_complete);
+	if (retval)
+		goto gb_error;
+
+gb_error:
+	kfree(request);
+	return retval;
+}
+
+static int gb_loopback_async_ping(struct gb_loopback *gb)
+{
+	return gb_loopback_async_operation(gb, GB_LOOPBACK_TYPE_PING,
+					   NULL, 0, 0, NULL);
+}
+
 static int gb_loopback_request_recv(u8 type, struct gb_operation *operation)
 {
 	struct gb_connection *connection = operation->connection;
@@ -512,6 +837,10 @@ static void gb_loopback_reset_stats(struct gb_loopback *gb)
 	memcpy(&gb->gpbridge_firmware_latency, &reset,
 	       sizeof(struct gb_loopback_stats));
 
+	/* Set values to report min/max timeout to user-space */
+	gb->timeout_min = jiffies_to_usecs(GB_LOOPBACK_TIMEOUT_MIN);
+	gb->timeout_max = jiffies_to_usecs(GB_LOOPBACK_TIMEOUT_MAX);
+
 	/* Reset aggregate stats */
 	memcpy(&gb->latency, &reset, sizeof(struct gb_loopback_stats));
 	memcpy(&gb->throughput, &reset, sizeof(struct gb_loopback_stats));
@@ -599,23 +928,25 @@ static int gb_loopback_fn(void *data)
 	int ms_wait = 0;
 	int type;
 	u32 size;
+	u32 send_count = 0;
 	struct gb_loopback *gb = data;
 
 	while (1) {
 		if (!gb->type)
 			wait_event_interruptible(gb->wq, gb->type ||
 						 kthread_should_stop());
+
 		if (kthread_should_stop())
 			break;
 
 		mutex_lock(&gb->mutex);
-
 		sysfs_notify(&gb->connection->bundle->dev.kobj,
 			     NULL, "iteration_count");
 
 		/* Optionally terminate */
-		if (gb->iteration_count == gb->iteration_max) {
+		if (send_count == gb->iteration_max) {
 			gb->type = 0;
+			send_count = 0;
 			mutex_unlock(&gb->mutex);
 			continue;
 		}
@@ -625,19 +956,33 @@ static int gb_loopback_fn(void *data)
 		mutex_unlock(&gb->mutex);
 
 		/* Else operations to perform */
-		if (type == GB_LOOPBACK_TYPE_PING)
-			error = gb_loopback_ping(gb);
-		else if (type == GB_LOOPBACK_TYPE_TRANSFER)
-			error = gb_loopback_transfer(gb, size);
-		else if (type == GB_LOOPBACK_TYPE_SINK)
-			error = gb_loopback_sink(gb, size);
-
-		if (error)
-			gb->error++;
-
-		gb_loopback_calculate_stats(gb);
-		gb->iteration_count++;
-
+		if (gb->async) {
+			if (type == GB_LOOPBACK_TYPE_PING) {
+				error = gb_loopback_async_ping(gb);
+				gb_loopback_calculate_stats(gb);
+			} else if (type == GB_LOOPBACK_TYPE_TRANSFER) {
+				error = gb_loopback_async_transfer(gb, size);
+			} else if (type == GB_LOOPBACK_TYPE_SINK) {
+				error = gb_loopback_async_sink(gb, size);
+			}
+
+			if (error)
+				gb->error++;
+		} else {
+			/* We are effectively single threaded here */
+			if (type == GB_LOOPBACK_TYPE_PING)
+				error = gb_loopback_sync_ping(gb);
+			else if (type == GB_LOOPBACK_TYPE_TRANSFER)
+				error = gb_loopback_sync_transfer(gb, size);
+			else if (type == GB_LOOPBACK_TYPE_SINK)
+				error = gb_loopback_sync_sink(gb, size);
+
+			if (error)
+				gb->error++;
+			gb->iteration_count++;
+			gb_loopback_calculate_stats(gb);
+		}
+		send_count++;
 		if (ms_wait)
 			msleep(ms_wait);
 	}
@@ -742,6 +1087,10 @@ static int gb_loopback_connection_init(struct gb_connection *connection)
 	init_waitqueue_head(&gb->wq);
 	gb_loopback_reset_stats(gb);
 
+	/* Reported values to user-space for min/max timeouts */
+	gb->timeout_min = jiffies_to_usecs(GB_LOOPBACK_TIMEOUT_MIN);
+	gb->timeout_max = jiffies_to_usecs(GB_LOOPBACK_TIMEOUT_MAX);
+
 	if (!gb_dev.count) {
 		/* Calculate maximum payload */
 		gb_dev.size_max = gb_operation_get_payload_size_max(connection);
@@ -847,6 +1196,7 @@ static int loopback_init(void)
 	int retval;
 
 	INIT_LIST_HEAD(&gb_dev.list);
+	INIT_LIST_HEAD(&gb_dev.list_op_async);
 	spin_lock_init(&gb_dev.lock);
 	gb_dev.root = debugfs_create_dir("gb_loopback", NULL);
 

commit 2e238d71edadf03bed470cf58514ee10795a806b
Author: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
Date:   Mon Dec 7 01:59:05 2015 +0000

    greybus: loopback: Convert cross-thread mutex to spinlock while relaxing connect locks
    
    This patch converts the cross-thread mutex used to synchronize threads with
    respect to each other to a spinlock. This is done to enable taking of locks
    in the following patches while in atomic context. A small re-order of
    locking in connection setup/tear-down is done to minimize the amount of
    time spent in spinlock_irqsave().
    
    Signed-off-by: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/loopback.c b/drivers/staging/greybus/loopback.c
index 689ebfdb456e..b65e3e591105 100644
--- a/drivers/staging/greybus/loopback.c
+++ b/drivers/staging/greybus/loopback.c
@@ -19,6 +19,7 @@
 #include <linux/kfifo.h>
 #include <linux/debugfs.h>
 #include <linux/list_sort.h>
+#include <linux/spinlock.h>
 
 #include <asm/div64.h>
 
@@ -39,7 +40,8 @@ struct gb_loopback_device {
 	u32 count;
 	size_t size_max;
 
-	struct mutex mutex;
+	/* We need to take a lock in atomic context */
+	spinlock_t lock;
 	struct list_head list;
 };
 
@@ -731,6 +733,7 @@ static int gb_loopback_connection_init(struct gb_connection *connection)
 	struct gb_loopback *gb;
 	int retval;
 	char name[DEBUGFS_NAMELEN];
+	unsigned long flags;
 
 	gb = kzalloc(sizeof(*gb), GFP_KERNEL);
 	if (!gb)
@@ -739,14 +742,13 @@ static int gb_loopback_connection_init(struct gb_connection *connection)
 	init_waitqueue_head(&gb->wq);
 	gb_loopback_reset_stats(gb);
 
-	mutex_lock(&gb_dev.mutex);
 	if (!gb_dev.count) {
 		/* Calculate maximum payload */
 		gb_dev.size_max = gb_operation_get_payload_size_max(connection);
 		if (gb_dev.size_max <=
 			sizeof(struct gb_loopback_transfer_request)) {
 			retval = -EINVAL;
-			goto out_sysfs;
+			goto out_kzalloc;
 		}
 		gb_dev.size_max -= sizeof(struct gb_loopback_transfer_request);
 	}
@@ -783,10 +785,12 @@ static int gb_loopback_connection_init(struct gb_connection *connection)
 		goto out_kfifo1;
 	}
 
+	spin_lock_irqsave(&gb_dev.lock, flags);
 	gb_loopback_insert_id(gb);
-	gb_connection_latency_tag_enable(connection);
 	gb_dev.count++;
-	mutex_unlock(&gb_dev.mutex);
+	spin_unlock_irqrestore(&gb_dev.lock, flags);
+
+	gb_connection_latency_tag_enable(connection);
 	return 0;
 
 out_kfifo1:
@@ -798,7 +802,7 @@ static int gb_loopback_connection_init(struct gb_connection *connection)
 out_sysfs:
 	debugfs_remove(gb->file);
 	connection->bundle->private = NULL;
-	mutex_unlock(&gb_dev.mutex);
+out_kzalloc:
 	kfree(gb);
 
 	return retval;
@@ -807,22 +811,24 @@ static int gb_loopback_connection_init(struct gb_connection *connection)
 static void gb_loopback_connection_exit(struct gb_connection *connection)
 {
 	struct gb_loopback *gb = connection->bundle->private;
+	unsigned long flags;
 
 	if (!IS_ERR_OR_NULL(gb->task))
 		kthread_stop(gb->task);
 
-	mutex_lock(&gb_dev.mutex);
-
 	connection->bundle->private = NULL;
 	kfifo_free(&gb->kfifo_lat);
 	kfifo_free(&gb->kfifo_ts);
 	gb_connection_latency_tag_disable(connection);
-	gb_dev.count--;
 	sysfs_remove_groups(&connection->bundle->dev.kobj,
 			    loopback_groups);
 	debugfs_remove(gb->file);
+
+	spin_lock_irqsave(&gb_dev.lock, flags);
+	gb_dev.count--;
 	list_del(&gb->entry);
-	mutex_unlock(&gb_dev.mutex);
+	spin_unlock_irqrestore(&gb_dev.lock, flags);
+
 	kfree(gb);
 }
 
@@ -841,7 +847,7 @@ static int loopback_init(void)
 	int retval;
 
 	INIT_LIST_HEAD(&gb_dev.list);
-	mutex_init(&gb_dev.mutex);
+	spin_lock_init(&gb_dev.lock);
 	gb_dev.root = debugfs_create_dir("gb_loopback", NULL);
 
 	retval = gb_protocol_register(&loopback_protocol);

commit 2f3db927cdf7627aa5359ff46c80ab72f7971980
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Fri Dec 4 21:30:09 2015 +0530

    greybus: don't use %h and %hh for printing short and char variables
    
    Because the width of our fields is already known, we can use %0Nx (for
    hex) to print N bytes and %u (for unsigned decimal), instead of using %h
    and %hh, which isn't that readable.
    
    This patch makes following changes:
    - s/%hx/%04x
    - s/%04hx/%04x
    - s/%hhx/%02x
    - s/%02hhx/%02x
    - s/%hhu/%u
    - s/%hu/%u
    - s/%x/%02x for u8 value (only at a single place)
    
    Suggested-by: Johan Hovold <johan@hovoldconsulting.com>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Reviewed-by: Johan Hovold <johan@hovoldconsulting.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/loopback.c b/drivers/staging/greybus/loopback.c
index 8524ce128738..689ebfdb456e 100644
--- a/drivers/staging/greybus/loopback.c
+++ b/drivers/staging/greybus/loopback.c
@@ -487,7 +487,7 @@ static int gb_loopback_request_recv(u8 type, struct gb_operation *operation)
 
 		return 0;
 	default:
-		dev_err(dev, "unsupported request: %hhu\n", type);
+		dev_err(dev, "unsupported request: %u\n", type);
 		return -EINVAL;
 	}
 }

commit 8e1d6c336d74977403b0d7ca81e1e9a098518ff0
Author: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
Date:   Thu Dec 3 17:29:41 2015 +0000

    greybus: loopback: drop bus aggregate calculation
    
    At some point we had a statement in a Jira work item to pull out 'bus
    level' data from greybus and to have messages to different interfaces be
    synchronized with respect to each other. Synchronizing threads with respect
    to each other is slow and it turns out we can get the same 'bus level'
    stastics by making the user-space test application smarter.
    
    That's great news for the in-kernel code since it means we can cut out a
    whole lot of code to-do with calculating 'bus level' aggregate data and we
    can stop forcing threads to hit a rendezvous before sending out another
    loopback operation.
    
    So this patch drops bus level aggregates in favour of doing that in
    user-space. It subtracts a lot of code and cycles that in practice nobody
    cares about anyway.
    
    Signed-off-by: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/loopback.c b/drivers/staging/greybus/loopback.c
index c1943f2b83fb..8524ce128738 100644
--- a/drivers/staging/greybus/loopback.c
+++ b/drivers/staging/greybus/loopback.c
@@ -36,29 +36,11 @@ struct gb_loopback_stats {
 
 struct gb_loopback_device {
 	struct dentry *root;
-	struct dentry *file;
 	u32 count;
+	size_t size_max;
 
-	struct kfifo kfifo;
 	struct mutex mutex;
 	struct list_head list;
-	wait_queue_head_t wq;
-
-	int type;
-	u32 mask;
-	u32 size;
-	u32 iteration_max;
-	u32 iteration_count;
-	size_t size_max;
-	int ms_wait;
-	u32 error;
-
-	/* Overall stats */
-	struct gb_loopback_stats latency;
-	struct gb_loopback_stats throughput;
-	struct gb_loopback_stats requests_per_second;
-	struct gb_loopback_stats apbridge_unipro_latency;
-	struct gb_loopback_stats gpbridge_firmware_latency;
 };
 
 static struct gb_loopback_device gb_dev;
@@ -72,6 +54,7 @@ struct gb_loopback {
 	struct mutex mutex;
 	struct task_struct *task;
 	struct list_head entry;
+	wait_queue_head_t wq;
 
 	/* Per connection stats */
 	struct gb_loopback_stats latency;
@@ -80,10 +63,15 @@ struct gb_loopback {
 	struct gb_loopback_stats apbridge_unipro_latency;
 	struct gb_loopback_stats gpbridge_firmware_latency;
 
-	u32 lbid;
+	int type;
+	u32 mask;
+	u32 size;
+	u32 iteration_max;
 	u32 iteration_count;
-	u64 elapsed_nsecs;
+	int ms_wait;
 	u32 error;
+	u32 lbid;
+	u64 elapsed_nsecs;
 	u32 apbridge_latency_ts;
 	u32 gpbridge_latency_ts;
 };
@@ -99,42 +87,34 @@ module_param(kfifo_depth, uint, 0444);
 #define GB_LOOPBACK_MS_WAIT_MAX				1000
 
 /* interface sysfs attributes */
-#define gb_loopback_ro_attr(field, pfx, conn)				\
-static ssize_t field##_##pfx##_show(struct device *dev,			\
+#define gb_loopback_ro_attr(field)				\
+static ssize_t field##_show(struct device *dev,			\
 			    struct device_attribute *attr,		\
 			    char *buf)					\
 {									\
 	struct gb_bundle *bundle;					\
 	struct gb_loopback *gb;						\
-	if (conn) {							\
-		bundle = to_gb_bundle(dev);				\
-		gb = bundle->private;					\
-		return sprintf(buf, "%u\n", gb->field);			\
-	} else {							\
-		return sprintf(buf, "%u\n", gb_dev.field);		\
-	}								\
+	bundle = to_gb_bundle(dev);				\
+	gb = bundle->private;					\
+	return sprintf(buf, "%u\n", gb->field);			\
 }									\
-static DEVICE_ATTR_RO(field##_##pfx)
+static DEVICE_ATTR_RO(field)
 
-#define gb_loopback_ro_stats_attr(name, field, type, pfx, conn)		\
-static ssize_t name##_##field##_##pfx##_show(struct device *dev,	\
+#define gb_loopback_ro_stats_attr(name, field, type)		\
+static ssize_t name##_##field##_show(struct device *dev,	\
 			    struct device_attribute *attr,		\
 			    char *buf)					\
 {									\
 	struct gb_bundle *bundle;					\
 	struct gb_loopback *gb;						\
-	if (conn) {							\
-		bundle = to_gb_bundle(dev);				\
-		gb = bundle->private;					\
-		return sprintf(buf, "%"#type"\n", gb->name.field);	\
-	} else {							\
-		return sprintf(buf, "%"#type"\n", gb_dev.name.field);	\
-	}								\
+	bundle = to_gb_bundle(dev);				\
+	gb = bundle->private;					\
+	return sprintf(buf, "%"#type"\n", gb->name.field);	\
 }									\
-static DEVICE_ATTR_RO(name##_##field##_##pfx)
+static DEVICE_ATTR_RO(name##_##field)
 
-#define gb_loopback_ro_avg_attr(name, pfx, conn)			\
-static ssize_t name##_avg_##pfx##_show(struct device *dev,		\
+#define gb_loopback_ro_avg_attr(name)			\
+static ssize_t name##_avg_show(struct device *dev,		\
 			    struct device_attribute *attr,		\
 			    char *buf)					\
 {									\
@@ -143,24 +123,20 @@ static ssize_t name##_avg_##pfx##_show(struct device *dev,		\
 	struct gb_loopback *gb;						\
 	u64 avg;							\
 	u32 count, rem;							\
-	if (conn) {							\
-		bundle = to_gb_bundle(dev);				\
-		gb = bundle->private;					\
-		stats = &gb->name;					\
-	} else {							\
-		stats = &gb_dev.name;					\
-	}								\
+	bundle = to_gb_bundle(dev);				\
+	gb = bundle->private;					\
+	stats = &gb->name;					\
 	count = stats->count ? stats->count : 1;			\
 	avg = stats->sum + count / 2;	/* round closest */		\
 	rem = do_div(avg, count);					\
 	return sprintf(buf, "%llu.%06u\n", avg, 1000000 * rem / count);	\
 }									\
-static DEVICE_ATTR_RO(name##_avg_##pfx)
+static DEVICE_ATTR_RO(name##_avg)
 
-#define gb_loopback_stats_attrs(field, pfx, conn)			\
-	gb_loopback_ro_stats_attr(field, min, u, pfx, conn);		\
-	gb_loopback_ro_stats_attr(field, max, u, pfx, conn);		\
-	gb_loopback_ro_avg_attr(field, pfx, conn)
+#define gb_loopback_stats_attrs(field)				\
+	gb_loopback_ro_stats_attr(field, min, u);		\
+	gb_loopback_ro_stats_attr(field, max, u);		\
+	gb_loopback_ro_avg_attr(field)
 
 #define gb_loopback_attr(field, type)					\
 static ssize_t field##_show(struct device *dev,				\
@@ -178,13 +154,14 @@ static ssize_t field##_store(struct device *dev,			\
 {									\
 	int ret;							\
 	struct gb_bundle *bundle = to_gb_bundle(dev);			\
-	mutex_lock(&gb_dev.mutex);					\
+	struct gb_loopback *gb = bundle->private;			\
+	mutex_lock(&gb->mutex);						\
 	ret = sscanf(buf, "%"#type, &gb->field);			\
 	if (ret != 1)							\
 		len = -EINVAL;						\
 	else								\
-		gb_loopback_check_attr(&gb_dev, bundle);		\
-	mutex_unlock(&gb_dev.mutex);					\
+		gb_loopback_check_attr(gb, bundle);			\
+	mutex_unlock(&gb->mutex);					\
 	return len;							\
 }									\
 static DEVICE_ATTR_RW(field)
@@ -194,7 +171,9 @@ static ssize_t field##_show(struct device *dev,		\
 			    struct device_attribute *attr,		\
 			    char *buf)					\
 {									\
-	return sprintf(buf, "%u\n", gb_dev.field);			\
+	struct gb_bundle *bundle = to_gb_bundle(dev);			\
+	struct gb_loopback *gb = bundle->private;			\
+	return sprintf(buf, "%u\n", gb->field);				\
 }									\
 static DEVICE_ATTR_RO(field)
 
@@ -203,7 +182,9 @@ static ssize_t field##_show(struct device *dev,				\
 			    struct device_attribute *attr,		\
 			    char *buf)					\
 {									\
-	return sprintf(buf, "%"#type"\n", gb_dev.field);		\
+	struct gb_bundle *bundle = to_gb_bundle(dev);			\
+	struct gb_loopback *gb = bundle->private;			\
+	return sprintf(buf, "%"#type"\n", gb->field);			\
 }									\
 static ssize_t field##_store(struct device *dev,			\
 			    struct device_attribute *attr,		\
@@ -212,76 +193,63 @@ static ssize_t field##_store(struct device *dev,			\
 {									\
 	int ret;							\
 	struct gb_bundle *bundle = to_gb_bundle(dev);			\
-	mutex_lock(&gb_dev.mutex);					\
-	ret = sscanf(buf, "%"#type, &gb_dev.field);			\
+	struct gb_loopback *gb = bundle->private;			\
+	mutex_lock(&gb->mutex);						\
+	ret = sscanf(buf, "%"#type, &gb->field);			\
 	if (ret != 1)							\
 		len = -EINVAL;						\
 	else								\
-		gb_loopback_check_attr(&gb_dev, bundle);		\
-	mutex_unlock(&gb_dev.mutex);					\
+		gb_loopback_check_attr(gb, bundle);		\
+	mutex_unlock(&gb->mutex);					\
 	return len;							\
 }									\
 static DEVICE_ATTR_RW(field)
 
-static void gb_loopback_reset_stats(struct gb_loopback_device *gb_dev);
-static void gb_loopback_check_attr(struct gb_loopback_device *gb_dev,
+static void gb_loopback_reset_stats(struct gb_loopback *gb);
+static void gb_loopback_check_attr(struct gb_loopback *gb,
 				   struct gb_bundle *bundle)
 {
-	struct gb_loopback *gb;
-
-	if (gb_dev->ms_wait > GB_LOOPBACK_MS_WAIT_MAX)
-		gb_dev->ms_wait = GB_LOOPBACK_MS_WAIT_MAX;
-	if (gb_dev->size > gb_dev->size_max)
-		gb_dev->size = gb_dev->size_max;
-	gb_dev->iteration_count = 0;
-	gb_dev->error = 0;
-
-	list_for_each_entry(gb, &gb_dev->list, entry) {
-		mutex_lock(&gb->mutex);
-		gb->iteration_count = 0;
-		gb->error = 0;
-		if (kfifo_depth < gb_dev->iteration_max) {
-			dev_warn(&bundle->dev,
-				 "cannot log bytes %u kfifo_depth %u\n",
-				 gb_dev->iteration_max, kfifo_depth);
-		}
-		kfifo_reset_out(&gb->kfifo_lat);
-		kfifo_reset_out(&gb->kfifo_ts);
-		mutex_unlock(&gb->mutex);
+	if (gb->ms_wait > GB_LOOPBACK_MS_WAIT_MAX)
+		gb->ms_wait = GB_LOOPBACK_MS_WAIT_MAX;
+	if (gb->size > gb_dev.size_max)
+		gb->size = gb_dev.size_max;
+	gb->iteration_count = 0;
+	gb->error = 0;
+
+	if (kfifo_depth < gb->iteration_max) {
+		dev_warn(&bundle->dev,
+			 "cannot log bytes %u kfifo_depth %u\n",
+			 gb->iteration_max, kfifo_depth);
 	}
+	kfifo_reset_out(&gb->kfifo_lat);
+	kfifo_reset_out(&gb->kfifo_ts);
 
-	switch (gb_dev->type) {
+	switch (gb->type) {
 	case GB_LOOPBACK_TYPE_PING:
 	case GB_LOOPBACK_TYPE_TRANSFER:
 	case GB_LOOPBACK_TYPE_SINK:
-		kfifo_reset_out(&gb_dev->kfifo);
-		gb_loopback_reset_stats(gb_dev);
-		wake_up(&gb_dev->wq);
+		gb_loopback_reset_stats(gb);
+		wake_up(&gb->wq);
 		break;
 	default:
-		gb_dev->type = 0;
+		gb->type = 0;
 		break;
 	}
 }
 
 /* Time to send and receive one message */
-gb_loopback_stats_attrs(latency, dev, false);
-gb_loopback_stats_attrs(latency, con, true);
+gb_loopback_stats_attrs(latency);
 /* Number of requests sent per second on this cport */
-gb_loopback_stats_attrs(requests_per_second, dev, false);
-gb_loopback_stats_attrs(requests_per_second, con, true);
+gb_loopback_stats_attrs(requests_per_second);
 /* Quantity of data sent and received on this cport */
-gb_loopback_stats_attrs(throughput, dev, false);
-gb_loopback_stats_attrs(throughput, con, true);
+gb_loopback_stats_attrs(throughput);
 /* Latency across the UniPro link from APBridge's perspective */
-gb_loopback_stats_attrs(apbridge_unipro_latency, dev, false);
-gb_loopback_stats_attrs(apbridge_unipro_latency, con, true);
+gb_loopback_stats_attrs(apbridge_unipro_latency);
 /* Firmware induced overhead in the GPBridge */
-gb_loopback_stats_attrs(gpbridge_firmware_latency, dev, false);
-gb_loopback_stats_attrs(gpbridge_firmware_latency, con, true);
+gb_loopback_stats_attrs(gpbridge_firmware_latency);
+
 /* Number of errors encountered during loop */
-gb_loopback_ro_attr(error, dev, false);
-gb_loopback_ro_attr(error, con, true);
+gb_loopback_ro_attr(error);
 
 /*
  * Type of loopback message to send based on protocol type definitions
@@ -303,53 +271,32 @@ gb_dev_loopback_ro_attr(iteration_count, false);
 /* A bit-mask of destination connecitons to include in the test run */
 gb_dev_loopback_rw_attr(mask, u);
 
-static struct attribute *loopback_dev_attrs[] = {
-	&dev_attr_latency_min_dev.attr,
-	&dev_attr_latency_max_dev.attr,
-	&dev_attr_latency_avg_dev.attr,
-	&dev_attr_requests_per_second_min_dev.attr,
-	&dev_attr_requests_per_second_max_dev.attr,
-	&dev_attr_requests_per_second_avg_dev.attr,
-	&dev_attr_throughput_min_dev.attr,
-	&dev_attr_throughput_max_dev.attr,
-	&dev_attr_throughput_avg_dev.attr,
-	&dev_attr_apbridge_unipro_latency_min_dev.attr,
-	&dev_attr_apbridge_unipro_latency_max_dev.attr,
-	&dev_attr_apbridge_unipro_latency_avg_dev.attr,
-	&dev_attr_gpbridge_firmware_latency_min_dev.attr,
-	&dev_attr_gpbridge_firmware_latency_max_dev.attr,
-	&dev_attr_gpbridge_firmware_latency_avg_dev.attr,
+static struct attribute *loopback_attrs[] = {
+	&dev_attr_latency_min.attr,
+	&dev_attr_latency_max.attr,
+	&dev_attr_latency_avg.attr,
+	&dev_attr_requests_per_second_min.attr,
+	&dev_attr_requests_per_second_max.attr,
+	&dev_attr_requests_per_second_avg.attr,
+	&dev_attr_throughput_min.attr,
+	&dev_attr_throughput_max.attr,
+	&dev_attr_throughput_avg.attr,
+	&dev_attr_apbridge_unipro_latency_min.attr,
+	&dev_attr_apbridge_unipro_latency_max.attr,
+	&dev_attr_apbridge_unipro_latency_avg.attr,
+	&dev_attr_gpbridge_firmware_latency_min.attr,
+	&dev_attr_gpbridge_firmware_latency_max.attr,
+	&dev_attr_gpbridge_firmware_latency_avg.attr,
 	&dev_attr_type.attr,
 	&dev_attr_size.attr,
 	&dev_attr_ms_wait.attr,
 	&dev_attr_iteration_count.attr,
 	&dev_attr_iteration_max.attr,
 	&dev_attr_mask.attr,
-	&dev_attr_error_dev.attr,
+	&dev_attr_error.attr,
 	NULL,
 };
-ATTRIBUTE_GROUPS(loopback_dev);
-
-static struct attribute *loopback_con_attrs[] = {
-	&dev_attr_latency_min_con.attr,
-	&dev_attr_latency_max_con.attr,
-	&dev_attr_latency_avg_con.attr,
-	&dev_attr_requests_per_second_min_con.attr,
-	&dev_attr_requests_per_second_max_con.attr,
-	&dev_attr_requests_per_second_avg_con.attr,
-	&dev_attr_throughput_min_con.attr,
-	&dev_attr_throughput_max_con.attr,
-	&dev_attr_throughput_avg_con.attr,
-	&dev_attr_apbridge_unipro_latency_min_con.attr,
-	&dev_attr_apbridge_unipro_latency_max_con.attr,
-	&dev_attr_apbridge_unipro_latency_avg_con.attr,
-	&dev_attr_gpbridge_firmware_latency_min_con.attr,
-	&dev_attr_gpbridge_firmware_latency_max_con.attr,
-	&dev_attr_gpbridge_firmware_latency_avg_con.attr,
-	&dev_attr_error_con.attr,
-	NULL,
-};
-ATTRIBUTE_GROUPS(loopback_con);
+ATTRIBUTE_GROUPS(loopback);
 
 static u32 gb_loopback_nsec_to_usec_latency(u64 elapsed_nsecs)
 {
@@ -385,11 +332,6 @@ static void gb_loopback_push_latency_ts(struct gb_loopback *gb,
 	kfifo_in(&gb->kfifo_ts, (unsigned char *)te, sizeof(*te));
 }
 
-static int gb_loopback_active(struct gb_loopback *gb)
-{
-	return (gb_dev.mask == 0 || (gb_dev.mask & gb->lbid));
-}
-
 static int gb_loopback_operation_sync(struct gb_loopback *gb, int type,
 				      void *request, int request_size,
 				      void *response, int response_size)
@@ -550,37 +492,32 @@ static int gb_loopback_request_recv(u8 type, struct gb_operation *operation)
 	}
 }
 
-static void gb_loopback_reset_stats(struct gb_loopback_device *gb_dev)
+static void gb_loopback_reset_stats(struct gb_loopback *gb)
 {
 	struct gb_loopback_stats reset = {
 		.min = U32_MAX,
 	};
-	struct gb_loopback *gb;
 
 	/* Reset per-connection stats */
-	list_for_each_entry(gb, &gb_dev->list, entry) {
-		mutex_lock(&gb->mutex);
-		memcpy(&gb->latency, &reset,
-		       sizeof(struct gb_loopback_stats));
-		memcpy(&gb->throughput, &reset,
-		       sizeof(struct gb_loopback_stats));
-		memcpy(&gb->requests_per_second, &reset,
-		       sizeof(struct gb_loopback_stats));
-		memcpy(&gb->apbridge_unipro_latency, &reset,
-		       sizeof(struct gb_loopback_stats));
-		memcpy(&gb->gpbridge_firmware_latency, &reset,
-		       sizeof(struct gb_loopback_stats));
-		mutex_unlock(&gb->mutex);
-	}
+	memcpy(&gb->latency, &reset,
+	       sizeof(struct gb_loopback_stats));
+	memcpy(&gb->throughput, &reset,
+	       sizeof(struct gb_loopback_stats));
+	memcpy(&gb->requests_per_second, &reset,
+	       sizeof(struct gb_loopback_stats));
+	memcpy(&gb->apbridge_unipro_latency, &reset,
+	       sizeof(struct gb_loopback_stats));
+	memcpy(&gb->gpbridge_firmware_latency, &reset,
+	       sizeof(struct gb_loopback_stats));
 
 	/* Reset aggregate stats */
-	memcpy(&gb_dev->latency, &reset, sizeof(struct gb_loopback_stats));
-	memcpy(&gb_dev->throughput, &reset, sizeof(struct gb_loopback_stats));
-	memcpy(&gb_dev->requests_per_second, &reset,
+	memcpy(&gb->latency, &reset, sizeof(struct gb_loopback_stats));
+	memcpy(&gb->throughput, &reset, sizeof(struct gb_loopback_stats));
+	memcpy(&gb->requests_per_second, &reset,
 	       sizeof(struct gb_loopback_stats));
-	memcpy(&gb_dev->apbridge_unipro_latency, &reset,
+	memcpy(&gb->apbridge_unipro_latency, &reset,
 	       sizeof(struct gb_loopback_stats));
-	memcpy(&gb_dev->gpbridge_firmware_latency, &reset,
+	memcpy(&gb->gpbridge_firmware_latency, &reset,
 	       sizeof(struct gb_loopback_stats));
 }
 
@@ -599,7 +536,6 @@ static void gb_loopback_requests_update(struct gb_loopback *gb, u32 latency)
 	u32 req = USEC_PER_SEC;
 
 	do_div(req, latency);
-	gb_loopback_update_stats(&gb_dev.requests_per_second, req);
 	gb_loopback_update_stats(&gb->requests_per_second, req);
 }
 
@@ -608,17 +544,17 @@ static void gb_loopback_throughput_update(struct gb_loopback *gb, u32 latency)
 	u32 throughput;
 	u32 aggregate_size = sizeof(struct gb_operation_msg_hdr) * 2;
 
-	switch (gb_dev.type) {
+	switch (gb->type) {
 	case GB_LOOPBACK_TYPE_PING:
 		break;
 	case GB_LOOPBACK_TYPE_SINK:
 		aggregate_size += sizeof(struct gb_loopback_transfer_request) +
-				  gb_dev.size;
+				  gb->size;
 		break;
 	case GB_LOOPBACK_TYPE_TRANSFER:
 		aggregate_size += sizeof(struct gb_loopback_transfer_request) +
 				  sizeof(struct gb_loopback_transfer_response) +
-				  gb_dev.size * 2;
+				  gb->size * 2;
 		break;
 	default:
 		return;
@@ -628,65 +564,9 @@ static void gb_loopback_throughput_update(struct gb_loopback *gb, u32 latency)
 	throughput = USEC_PER_SEC;
 	do_div(throughput, latency);
 	throughput *= aggregate_size;
-	gb_loopback_update_stats(&gb_dev.throughput, throughput);
 	gb_loopback_update_stats(&gb->throughput, throughput);
 }
 
-static int gb_loopback_calculate_aggregate_stats(void)
-{
-	struct gb_loopback *gb;
-	struct timeval ts;
-	struct timeval te;
-	u64 t1, t2;
-	u64 ts_min;
-	u64 te_max;
-	u64 elapsed_nsecs;
-	u32 lat;
-	int i, latched;
-	int rollover = 0;
-
-	for (i = 0; i < gb_dev.iteration_max; i++) {
-		latched = 0;
-		ts_min = 0;
-		te_max = 0;
-		list_for_each_entry(gb, &gb_dev.list, entry) {
-			if (!gb_loopback_active(gb))
-				continue;
-			if (kfifo_out(&gb->kfifo_ts, &ts, sizeof(ts)) < sizeof(ts))
-				goto error;
-			if (kfifo_out(&gb->kfifo_ts, &te, sizeof(te)) < sizeof(te))
-				goto error;
-			t1 = timeval_to_ns(&ts);
-			t2 = timeval_to_ns(&te);
-
-			/* minimum timestamp is always what we want */
-			if (latched == 0 || t1 < ts_min)
-				ts_min = t1;
-
-			/* maximum timestamp needs to handle rollover */
-			if (t2 > t1) {
-				if (latched == 0 || t2 > te_max)
-					te_max = t2;
-			} else {
-				if (latched == 0 || rollover == 0)
-					te_max = t2;
-				if (rollover == 1 && t2 > te_max)
-					te_max = t2;
-				rollover = 1;
-			}
-			latched = 1;
-		}
-		/* Calculate the aggregate timestamp */
-		elapsed_nsecs = __gb_loopback_calc_latency(ts_min, te_max);
-		lat = gb_loopback_nsec_to_usec_latency(elapsed_nsecs);
-		kfifo_in(&gb_dev.kfifo, (unsigned char *)&lat, sizeof(lat));
-	}
-	return 0;
-error:
-	kfifo_reset_out(&gb_dev.kfifo);
-	return -ENOMEM;
-}
-
 static void gb_loopback_calculate_stats(struct gb_loopback *gb)
 {
 	u32 lat;
@@ -695,7 +575,6 @@ static void gb_loopback_calculate_stats(struct gb_loopback *gb)
 	lat = gb_loopback_nsec_to_usec_latency(gb->elapsed_nsecs);
 
 	/* Log latency stastic */
-	gb_loopback_update_stats(&gb_dev.latency, lat);
 	gb_loopback_update_stats(&gb->latency, lat);
 
 	/* Raw latency log on a per thread basis */
@@ -706,12 +585,8 @@ static void gb_loopback_calculate_stats(struct gb_loopback *gb)
 	gb_loopback_requests_update(gb, lat);
 
 	/* Log the firmware supplied latency values */
-	gb_loopback_update_stats(&gb_dev.apbridge_unipro_latency,
-				 gb->apbridge_latency_ts);
 	gb_loopback_update_stats(&gb->apbridge_unipro_latency,
 				 gb->apbridge_latency_ts);
-	gb_loopback_update_stats(&gb_dev.gpbridge_firmware_latency,
-				 gb->gpbridge_latency_ts);
 	gb_loopback_update_stats(&gb->gpbridge_firmware_latency,
 				 gb->gpbridge_latency_ts);
 }
@@ -722,56 +597,29 @@ static int gb_loopback_fn(void *data)
 	int ms_wait = 0;
 	int type;
 	u32 size;
-	u32 low_count;
 	struct gb_loopback *gb = data;
-	struct gb_loopback *gb_list;
 
 	while (1) {
-		if (!gb_dev.type)
-			wait_event_interruptible(gb_dev.wq, gb_dev.type ||
+		if (!gb->type)
+			wait_event_interruptible(gb->wq, gb->type ||
 						 kthread_should_stop());
 		if (kthread_should_stop())
 			break;
 
-		mutex_lock(&gb_dev.mutex);
-		if (!gb_loopback_active(gb)) {
-			ms_wait = 100;
-			goto unlock_continue;
-		}
-		if (gb_dev.iteration_max) {
-			/* Determine overall lowest count */
-			low_count = gb->iteration_count;
-			list_for_each_entry(gb_list, &gb_dev.list, entry) {
-				if (!gb_loopback_active(gb_list))
-					continue;
-				if (gb_list->iteration_count < low_count)
-					low_count = gb_list->iteration_count;
-			}
-			/* All threads achieved at least low_count iterations */
-			if (gb_dev.iteration_count < low_count) {
-				gb_dev.iteration_count = low_count;
-				sysfs_notify(&gb->connection->bundle->dev.kobj,
-					     NULL, "iteration_count");
-			}
-			/* Optionally terminate */
-			if (gb_dev.iteration_count == gb_dev.iteration_max) {
-				gb_loopback_calculate_aggregate_stats();
-				gb_dev.type = 0;
-				goto unlock_continue;
-			}
-		}
-		size = gb_dev.size;
-		ms_wait = gb_dev.ms_wait;
-		type = gb_dev.type;
-		mutex_unlock(&gb_dev.mutex);
-
 		mutex_lock(&gb->mutex);
-		if (gb->iteration_count >= gb_dev.iteration_max) {
-			/* If this thread finished before siblings then sleep */
-			ms_wait = 1;
+
+		sysfs_notify(&gb->connection->bundle->dev.kobj,
+			     NULL, "iteration_count");
+
+		/* Optionally terminate */
+		if (gb->iteration_count == gb->iteration_max) {
+			gb->type = 0;
 			mutex_unlock(&gb->mutex);
-			goto sleep;
+			continue;
 		}
+		size = gb->size;
+		ms_wait = gb->ms_wait;
+		type = gb->type;
 		mutex_unlock(&gb->mutex);
 
 		/* Else operations to perform */
@@ -782,20 +630,12 @@ static int gb_loopback_fn(void *data)
 		else if (type == GB_LOOPBACK_TYPE_SINK)
 			error = gb_loopback_sink(gb, size);
 
-		mutex_lock(&gb_dev.mutex);
-		mutex_lock(&gb->mutex);
-
-		if (error) {
-			gb_dev.error++;
+		if (error)
 			gb->error++;
-		}
+
 		gb_loopback_calculate_stats(gb);
 		gb->iteration_count++;
 
-		mutex_unlock(&gb->mutex);
-unlock_continue:
-		mutex_unlock(&gb_dev.mutex);
-sleep:
 		if (ms_wait)
 			msleep(ms_wait);
 	}
@@ -846,27 +686,6 @@ static const struct file_operations gb_loopback_debugfs_latency_ops = {
 	.release	= single_release,
 };
 
-static int gb_loopback_dbgfs_dev_latency_show(struct seq_file *s, void *unused)
-{
-	struct gb_loopback_device *gb_dev = s->private;
-
-	return gb_loopback_dbgfs_latency_show_common(s, &gb_dev->kfifo,
-						     &gb_dev->mutex);
-}
-
-static int gb_loopback_dev_latency_open(struct inode *inode, struct file *file)
-{
-	return single_open(file, gb_loopback_dbgfs_dev_latency_show,
-			   inode->i_private);
-}
-
-static const struct file_operations gb_loopback_debugfs_dev_latency_ops = {
-	.open		= gb_loopback_dev_latency_open,
-	.read		= seq_read,
-	.llseek		= seq_lseek,
-	.release	= single_release,
-};
-
 static int gb_loopback_bus_id_compare(void *priv, struct list_head *lha,
 				      struct list_head *lhb)
 {
@@ -912,31 +731,22 @@ static int gb_loopback_connection_init(struct gb_connection *connection)
 	struct gb_loopback *gb;
 	int retval;
 	char name[DEBUGFS_NAMELEN];
-	struct kobject *kobj = &connection->bundle->dev.kobj;
 
 	gb = kzalloc(sizeof(*gb), GFP_KERNEL);
 	if (!gb)
 		return -ENOMEM;
-	gb_loopback_reset_stats(&gb_dev);
 
-	/* If this is the first connection - create a per-bus entry */
+	init_waitqueue_head(&gb->wq);
+	gb_loopback_reset_stats(gb);
+
 	mutex_lock(&gb_dev.mutex);
 	if (!gb_dev.count) {
-		snprintf(name, sizeof(name), "raw_latency_%d",
-				connection->bundle->intf->hd->bus_id);
-		gb_dev.file = debugfs_create_file(name, S_IFREG | S_IRUGO,
-						  gb_dev.root, &gb_dev,
-				  &gb_loopback_debugfs_dev_latency_ops);
-		retval = sysfs_create_groups(kobj, loopback_dev_groups);
-		if (retval)
-			goto out_sysfs;
-
 		/* Calculate maximum payload */
 		gb_dev.size_max = gb_operation_get_payload_size_max(connection);
 		if (gb_dev.size_max <=
 			sizeof(struct gb_loopback_transfer_request)) {
 			retval = -EINVAL;
-			goto out_sysfs_dev;
+			goto out_sysfs;
 		}
 		gb_dev.size_max -= sizeof(struct gb_loopback_transfer_request);
 	}
@@ -949,9 +759,9 @@ static int gb_loopback_connection_init(struct gb_connection *connection)
 	gb->connection = connection;
 	connection->bundle->private = gb;
 	retval = sysfs_create_groups(&connection->bundle->dev.kobj,
-				     loopback_con_groups);
+				     loopback_groups);
 	if (retval)
-		goto out_sysfs_dev;
+		goto out_sysfs;
 
 	/* Allocate kfifo */
 	if (kfifo_alloc(&gb->kfifo_lat, kfifo_depth * sizeof(u32),
@@ -984,15 +794,10 @@ static int gb_loopback_connection_init(struct gb_connection *connection)
 out_kfifo0:
 	kfifo_free(&gb->kfifo_lat);
 out_sysfs_conn:
-	sysfs_remove_groups(&connection->bundle->dev.kobj, loopback_con_groups);
-out_sysfs_dev:
-	if (!gb_dev.count) {
-		sysfs_remove_groups(kobj, loopback_dev_groups);
-		debugfs_remove(gb_dev.file);
-	}
+	sysfs_remove_groups(&connection->bundle->dev.kobj, loopback_groups);
+out_sysfs:
 	debugfs_remove(gb->file);
 	connection->bundle->private = NULL;
-out_sysfs:
 	mutex_unlock(&gb_dev.mutex);
 	kfree(gb);
 
@@ -1002,7 +807,6 @@ static int gb_loopback_connection_init(struct gb_connection *connection)
 static void gb_loopback_connection_exit(struct gb_connection *connection)
 {
 	struct gb_loopback *gb = connection->bundle->private;
-	struct kobject *kobj = &connection->bundle->dev.kobj;
 
 	if (!IS_ERR_OR_NULL(gb->task))
 		kthread_stop(gb->task);
@@ -1014,12 +818,8 @@ static void gb_loopback_connection_exit(struct gb_connection *connection)
 	kfifo_free(&gb->kfifo_ts);
 	gb_connection_latency_tag_disable(connection);
 	gb_dev.count--;
-	if (!gb_dev.count) {
-		sysfs_remove_groups(kobj, loopback_dev_groups);
-		debugfs_remove(gb_dev.file);
-	}
 	sysfs_remove_groups(&connection->bundle->dev.kobj,
-			    loopback_con_groups);
+			    loopback_groups);
 	debugfs_remove(gb->file);
 	list_del(&gb->entry);
 	mutex_unlock(&gb_dev.mutex);
@@ -1040,21 +840,14 @@ static int loopback_init(void)
 {
 	int retval;
 
-	init_waitqueue_head(&gb_dev.wq);
 	INIT_LIST_HEAD(&gb_dev.list);
 	mutex_init(&gb_dev.mutex);
 	gb_dev.root = debugfs_create_dir("gb_loopback", NULL);
 
-	if (kfifo_alloc(&gb_dev.kfifo, kfifo_depth * sizeof(u32), GFP_KERNEL)) {
-		retval = -ENOMEM;
-		goto error_debugfs;
-	}
-
 	retval = gb_protocol_register(&loopback_protocol);
 	if (!retval)
 		return retval;
 
-error_debugfs:
 	debugfs_remove_recursive(gb_dev.root);
 	return retval;
 }
@@ -1063,7 +856,6 @@ module_init(loopback_init);
 static void __exit loopback_exit(void)
 {
 	debugfs_remove_recursive(gb_dev.root);
-	kfifo_free(&gb_dev.kfifo);
 	gb_protocol_deregister(&loopback_protocol);
 }
 module_exit(loopback_exit);

commit 9673dcebe472f298ba9781db84c5880d55372cc9
Author: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
Date:   Thu Dec 3 17:29:40 2015 +0000

    greybus: loopback: Drop unused timeval variables
    
    start and end aren't used and should be dropped.
    
    Signed-off-by: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/loopback.c b/drivers/staging/greybus/loopback.c
index 7d582cd8127b..c1943f2b83fb 100644
--- a/drivers/staging/greybus/loopback.c
+++ b/drivers/staging/greybus/loopback.c
@@ -53,9 +53,6 @@ struct gb_loopback_device {
 	int ms_wait;
 	u32 error;
 
-	struct timeval start;
-	struct timeval end;
-
 	/* Overall stats */
 	struct gb_loopback_stats latency;
 	struct gb_loopback_stats throughput;
@@ -577,8 +574,6 @@ static void gb_loopback_reset_stats(struct gb_loopback_device *gb_dev)
 	}
 
 	/* Reset aggregate stats */
-	memset(&gb_dev->start, 0, sizeof(struct timeval));
-	memset(&gb_dev->end, 0, sizeof(struct timeval));
 	memcpy(&gb_dev->latency, &reset, sizeof(struct gb_loopback_stats));
 	memcpy(&gb_dev->throughput, &reset, sizeof(struct gb_loopback_stats));
 	memcpy(&gb_dev->requests_per_second, &reset,

commit d6a1a3b5ea08c7828a177b48e6e39943b0fadf3c
Author: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
Date:   Thu Dec 3 17:29:39 2015 +0000

    greybus: loopback: Move latency_ts initialization to transfer routine
    
    Initializing the bridge specific latency variables is only relevant to the
    transfer operation, so make it loopback-transfer specific.
    
    Signed-off-by: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/loopback.c b/drivers/staging/greybus/loopback.c
index e0be130afb70..7d582cd8127b 100644
--- a/drivers/staging/greybus/loopback.c
+++ b/drivers/staging/greybus/loopback.c
@@ -463,6 +463,9 @@ static int gb_loopback_transfer(struct gb_loopback *gb, u32 len)
 	struct gb_loopback_transfer_response *response;
 	int retval;
 
+	gb->apbridge_latency_ts = 0;
+	gb->gpbridge_latency_ts = 0;
+
 	request = kmalloc(len + sizeof(*request), GFP_KERNEL);
 	if (!request)
 		return -ENOMEM;
@@ -777,8 +780,6 @@ static int gb_loopback_fn(void *data)
 		mutex_unlock(&gb->mutex);
 
 		/* Else operations to perform */
-		gb->apbridge_latency_ts = 0;
-		gb->gpbridge_latency_ts = 0;
 		if (type == GB_LOOPBACK_TYPE_PING)
 			error = gb_loopback_ping(gb);
 		else if (type == GB_LOOPBACK_TYPE_TRANSFER)

commit d9fb3754ecf807f6c6bbe63ff2fbd29e00fad131
Author: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
Date:   Thu Dec 3 17:29:38 2015 +0000

    greybus: loopback: Relax locking during loopback operations
    
    Currently a per-connection mutex is held during calls to
    gb_operation_send_sync. It is not necessary to hold this lock and later
    patches supporting multiple-outstanding bi-directional operations need to
    take the per-connection lock and the gb_dev level lock. Since gb_dev must
    always be taken before per-connection locks, it is both desirable and safe
    to drop the lock now.
    
    Signed-off-by: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/loopback.c b/drivers/staging/greybus/loopback.c
index ef16ca579ca1..e0be130afb70 100644
--- a/drivers/staging/greybus/loopback.c
+++ b/drivers/staging/greybus/loopback.c
@@ -774,6 +774,8 @@ static int gb_loopback_fn(void *data)
 			mutex_unlock(&gb->mutex);
 			goto sleep;
 		}
+		mutex_unlock(&gb->mutex);
+
 		/* Else operations to perform */
 		gb->apbridge_latency_ts = 0;
 		gb->gpbridge_latency_ts = 0;
@@ -783,7 +785,6 @@ static int gb_loopback_fn(void *data)
 			error = gb_loopback_transfer(gb, size);
 		else if (type == GB_LOOPBACK_TYPE_SINK)
 			error = gb_loopback_sink(gb, size);
-		mutex_unlock(&gb->mutex);
 
 		mutex_lock(&gb_dev.mutex);
 		mutex_lock(&gb->mutex);

commit dc3da5db2858c3fb33441988d1b6d56c06e53d7d
Author: Johan Hovold <johan@hovoldconsulting.com>
Date:   Wed Nov 25 15:59:20 2015 +0100

    greybus: loopback: remove endo reference
    
    Replace reference to "endo0" and generate the raw-latency filename based
    on the host-device bus id instead.
    
    Signed-off-by: Johan Hovold <johan@hovoldconsulting.com>
    Reviewed-by: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/loopback.c b/drivers/staging/greybus/loopback.c
index ededfef40e9c..ef16ca579ca1 100644
--- a/drivers/staging/greybus/loopback.c
+++ b/drivers/staging/greybus/loopback.c
@@ -922,10 +922,11 @@ static int gb_loopback_connection_init(struct gb_connection *connection)
 		return -ENOMEM;
 	gb_loopback_reset_stats(&gb_dev);
 
-	/* If this is the first connection - create a module endo0 entry */
+	/* If this is the first connection - create a per-bus entry */
 	mutex_lock(&gb_dev.mutex);
 	if (!gb_dev.count) {
-		snprintf(name, sizeof(name), "raw_latency_endo0");
+		snprintf(name, sizeof(name), "raw_latency_%d",
+				connection->bundle->intf->hd->bus_id);
 		gb_dev.file = debugfs_create_file(name, S_IFREG | S_IRUGO,
 						  gb_dev.root, &gb_dev,
 				  &gb_loopback_debugfs_dev_latency_ops);

commit 8b0df4b2eaf2f741ae44e8f5bad4ecb223f87932
Author: Johan Hovold <johan@hovoldconsulting.com>
Date:   Wed Nov 25 15:59:04 2015 +0100

    greybus: interface: make interfaces children of host devices
    
    Make interfaces child devices of host devices.
    
    The new interface device name is "<bus_id>-<intf_id>", where bus_id is
    the dynamically allocated bus id for the host device and intf_id is the
    svc-allocated interface id.
    
    Signed-off-by: Johan Hovold <johan@hovoldconsulting.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/loopback.c b/drivers/staging/greybus/loopback.c
index 0c38414a3e06..ededfef40e9c 100644
--- a/drivers/staging/greybus/loopback.c
+++ b/drivers/staging/greybus/loopback.c
@@ -878,12 +878,6 @@ static int gb_loopback_bus_id_compare(void *priv, struct list_head *lha,
 	struct gb_connection *ca = a->connection;
 	struct gb_connection *cb = b->connection;
 
-	if (ca->bundle->intf->module->module_id <
-	    cb->bundle->intf->module->module_id)
-		return -1;
-	if (cb->bundle->intf->module->module_id <
-	    ca->bundle->intf->module->module_id)
-		return 1;
 	if (ca->bundle->intf->interface_id < cb->bundle->intf->interface_id)
 		return -1;
 	if (cb->bundle->intf->interface_id < ca->bundle->intf->interface_id)

commit 81ad6994611706270bc68a8dd951d7c69e2ed175
Author: Bartosz Golaszewski <bgolaszewski@baylibre.com>
Date:   Thu Nov 19 13:46:43 2015 +0100

    greybus: loopback: allocate a response even for a 0-byte request
    
    If payload length of a transfer packet is 0, no response is allocated.
    Send a well-formed response even in that case.
    
    Signed-off-by: Bartosz Golaszewski <bgolaszewski@baylibre.com>
    Reviewed-by: Johan Hovold <johan@hovoldconsulting.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/loopback.c b/drivers/staging/greybus/loopback.c
index ec68247f5bdb..0c38414a3e06 100644
--- a/drivers/staging/greybus/loopback.c
+++ b/drivers/staging/greybus/loopback.c
@@ -533,16 +533,16 @@ static int gb_loopback_request_recv(u8 type, struct gb_operation *operation)
 			return -EINVAL;
 		}
 
-		if (len) {
-			if (!gb_operation_response_alloc(operation,
-					len + sizeof(*response), GFP_KERNEL)) {
-				dev_err(dev, "error allocating response\n");
-				return -ENOMEM;
-			}
-			response = operation->response->payload;
-			response->len = cpu_to_le32(len);
-			memcpy(response->data, request->data, len);
+		if (!gb_operation_response_alloc(operation,
+				len + sizeof(*response), GFP_KERNEL)) {
+			dev_err(dev, "error allocating response\n");
+			return -ENOMEM;
 		}
+		response = operation->response->payload;
+		response->len = cpu_to_le32(len);
+		if (len)
+			memcpy(response->data, request->data, len);
+
 		return 0;
 	default:
 		dev_err(dev, "unsupported request: %hhu\n", type);

commit 9864756be7542d3fe4e18297e0a45b5e2dec2f62
Author: Alexandre Bailon <abailon@baylibre.com>
Date:   Thu Nov 19 12:44:46 2015 +0100

    greybus: loopback: fix invalid response size
    
    The size of timestamps is not taken into account, which makes the
    loopback driver in the firmware drop invalid packages.
    
    Signed-off-by: Alexandre Bailon <abailon@baylibre.com>
    Signed-off-by: Bartosz Golaszewski <bgolaszewski@baylibre.com>
    Reviewed-by: Johan Hovold <johan@hovoldconsulting.com>
    Reviewed-by: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/loopback.c b/drivers/staging/greybus/loopback.c
index 9a44dcc7d7d7..ec68247f5bdb 100644
--- a/drivers/staging/greybus/loopback.c
+++ b/drivers/staging/greybus/loopback.c
@@ -534,8 +534,8 @@ static int gb_loopback_request_recv(u8 type, struct gb_operation *operation)
 		}
 
 		if (len) {
-			if (!gb_operation_response_alloc(operation, len,
-							 GFP_KERNEL)) {
+			if (!gb_operation_response_alloc(operation,
+					len + sizeof(*response), GFP_KERNEL)) {
 				dev_err(dev, "error allocating response\n");
 				return -ENOMEM;
 			}

commit 0d1d6ee209e1129c584c2b00a48a33ff1fb7312c
Author: Johan Hovold <johan@hovoldconsulting.com>
Date:   Wed Nov 11 10:07:02 2015 +0100

    greybus: loopback: fix layer violation
    
    A bundle (protocol) driver has no business creating sysfs entries for an
    ancestor device.
    
    Move the sysfs entries to the bundle device for now.
    
    Signed-off-by: Johan Hovold <johan@hovoldconsulting.com>
    Reviewed-by: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/loopback.c b/drivers/staging/greybus/loopback.c
index e1b1be0687a8..9a44dcc7d7d7 100644
--- a/drivers/staging/greybus/loopback.c
+++ b/drivers/staging/greybus/loopback.c
@@ -921,7 +921,7 @@ static int gb_loopback_connection_init(struct gb_connection *connection)
 	struct gb_loopback *gb;
 	int retval;
 	char name[DEBUGFS_NAMELEN];
-	struct kobject *kobj = &connection->hd->endo->dev.kobj;
+	struct kobject *kobj = &connection->bundle->dev.kobj;
 
 	gb = kzalloc(sizeof(*gb), GFP_KERNEL);
 	if (!gb)
@@ -1010,7 +1010,7 @@ static int gb_loopback_connection_init(struct gb_connection *connection)
 static void gb_loopback_connection_exit(struct gb_connection *connection)
 {
 	struct gb_loopback *gb = connection->bundle->private;
-	struct kobject *kobj = &connection->hd->endo->dev.kobj;
+	struct kobject *kobj = &connection->bundle->dev.kobj;
 
 	if (!IS_ERR_OR_NULL(gb->task))
 		kthread_stop(gb->task);

commit d9a9ea1b88190a31957489377fd3fee246888373
Author: Greg Kroah-Hartman <gregkh@google.com>
Date:   Fri Oct 16 16:55:46 2015 -0700

    greybus: loopback: use the bundle struct device instead of the connector
    
    We are removing struct device from the gb_connection structure in the
    near future.  The gb_bundle structure's struct device should be used as
    a replacement.
    
    This patch moves the loopback driver to use the bundle pointer instead
    of the connection pointer.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>
    Reviewed-by: Viresh Kumar <viresh.kumar@linaro.org>
    Reviewed-by: Alex Elder <elder@linaro.org>
    Reviewed-by: Johan Hovold <johan@hovoldconsulting.com>

diff --git a/drivers/staging/greybus/loopback.c b/drivers/staging/greybus/loopback.c
index 1ac86c15e974..e1b1be0687a8 100644
--- a/drivers/staging/greybus/loopback.c
+++ b/drivers/staging/greybus/loopback.c
@@ -107,11 +107,11 @@ static ssize_t field##_##pfx##_show(struct device *dev,			\
 			    struct device_attribute *attr,		\
 			    char *buf)					\
 {									\
-	struct gb_connection *connection;				\
+	struct gb_bundle *bundle;					\
 	struct gb_loopback *gb;						\
 	if (conn) {							\
-		connection = to_gb_connection(dev);			\
-		gb = connection->private;				\
+		bundle = to_gb_bundle(dev);				\
+		gb = bundle->private;					\
 		return sprintf(buf, "%u\n", gb->field);			\
 	} else {							\
 		return sprintf(buf, "%u\n", gb_dev.field);		\
@@ -124,11 +124,11 @@ static ssize_t name##_##field##_##pfx##_show(struct device *dev,	\
 			    struct device_attribute *attr,		\
 			    char *buf)					\
 {									\
-	struct gb_connection *connection;				\
+	struct gb_bundle *bundle;					\
 	struct gb_loopback *gb;						\
 	if (conn) {							\
-		connection = to_gb_connection(dev);			\
-		gb = connection->private;				\
+		bundle = to_gb_bundle(dev);				\
+		gb = bundle->private;					\
 		return sprintf(buf, "%"#type"\n", gb->name.field);	\
 	} else {							\
 		return sprintf(buf, "%"#type"\n", gb_dev.name.field);	\
@@ -142,13 +142,13 @@ static ssize_t name##_avg_##pfx##_show(struct device *dev,		\
 			    char *buf)					\
 {									\
 	struct gb_loopback_stats *stats;				\
-	struct gb_connection *connection;				\
+	struct gb_bundle *bundle;					\
 	struct gb_loopback *gb;						\
 	u64 avg;							\
 	u32 count, rem;							\
 	if (conn) {							\
-		connection = to_gb_connection(dev);			\
-		gb = connection->private;				\
+		bundle = to_gb_bundle(dev);				\
+		gb = bundle->private;					\
 		stats = &gb->name;					\
 	} else {							\
 		stats = &gb_dev.name;					\
@@ -170,8 +170,8 @@ static ssize_t field##_show(struct device *dev,				\
 			    struct device_attribute *attr,		\
 			    char *buf)					\
 {									\
-	struct gb_connection *connection = to_gb_connection(dev);	\
-	struct gb_loopback *gb = connection->private;			\
+	struct gb_bundle *bundle = to_gb_bundle(dev);			\
+	struct gb_loopback *gb = bundle->private;			\
 	return sprintf(buf, "%"#type"\n", gb->field);			\
 }									\
 static ssize_t field##_store(struct device *dev,			\
@@ -180,13 +180,13 @@ static ssize_t field##_store(struct device *dev,			\
 			    size_t len)					\
 {									\
 	int ret;							\
-	struct gb_connection *connection = to_gb_connection(dev);	\
+	struct gb_bundle *bundle = to_gb_bundle(dev);			\
 	mutex_lock(&gb_dev.mutex);					\
 	ret = sscanf(buf, "%"#type, &gb->field);			\
 	if (ret != 1)							\
 		len = -EINVAL;						\
 	else								\
-		gb_loopback_check_attr(connection);			\
+		gb_loopback_check_attr(&gb_dev, bundle);		\
 	mutex_unlock(&gb_dev.mutex);					\
 	return len;							\
 }									\
@@ -214,13 +214,13 @@ static ssize_t field##_store(struct device *dev,			\
 			    size_t len)					\
 {									\
 	int ret;							\
-	struct gb_connection *connection = to_gb_connection(dev);	\
+	struct gb_bundle *bundle = to_gb_bundle(dev);			\
 	mutex_lock(&gb_dev.mutex);					\
 	ret = sscanf(buf, "%"#type, &gb_dev.field);			\
 	if (ret != 1)							\
 		len = -EINVAL;						\
 	else								\
-		gb_loopback_check_attr(&gb_dev, connection);		\
+		gb_loopback_check_attr(&gb_dev, bundle);		\
 	mutex_unlock(&gb_dev.mutex);					\
 	return len;							\
 }									\
@@ -228,7 +228,7 @@ static DEVICE_ATTR_RW(field)
 
 static void gb_loopback_reset_stats(struct gb_loopback_device *gb_dev);
 static void gb_loopback_check_attr(struct gb_loopback_device *gb_dev,
-				   struct gb_connection *connection)
+				   struct gb_bundle *bundle)
 {
 	struct gb_loopback *gb;
 
@@ -244,7 +244,7 @@ static void gb_loopback_check_attr(struct gb_loopback_device *gb_dev,
 		gb->iteration_count = 0;
 		gb->error = 0;
 		if (kfifo_depth < gb_dev->iteration_max) {
-			dev_warn(&connection->dev,
+			dev_warn(&bundle->dev,
 				 "cannot log bytes %u kfifo_depth %u\n",
 				 gb_dev->iteration_max, kfifo_depth);
 		}
@@ -414,14 +414,14 @@ static int gb_loopback_operation_sync(struct gb_loopback *gb, int type,
 
 	ret = gb_operation_request_send_sync(operation);
 	if (ret) {
-		dev_err(&gb->connection->dev,
+		dev_err(&gb->connection->bundle->dev,
 			"synchronous operation failed: %d\n", ret);
 	} else {
 		if (response_size == operation->response->payload_size) {
 			memcpy(response, operation->response->payload,
 			       response_size);
 		} else {
-			dev_err(&gb->connection->dev,
+			dev_err(&gb->connection->bundle->dev,
 				"response size %zu expected %d\n",
 				operation->response->payload_size,
 				response_size);
@@ -482,7 +482,8 @@ static int gb_loopback_transfer(struct gb_loopback *gb, u32 len)
 		goto gb_error;
 
 	if (memcmp(request->data, response->data, len)) {
-		dev_err(&gb->connection->dev, "Loopback Data doesn't match\n");
+		dev_err(&gb->connection->bundle->dev,
+			"Loopback Data doesn't match\n");
 		retval = -EREMOTEIO;
 	}
 	gb->apbridge_latency_ts = (u32)__le32_to_cpu(response->reserved0);
@@ -506,21 +507,20 @@ static int gb_loopback_request_recv(u8 type, struct gb_operation *operation)
 	struct gb_connection *connection = operation->connection;
 	struct gb_loopback_transfer_request *request;
 	struct gb_loopback_transfer_response *response;
+	struct device *dev = &connection->bundle->dev;
 	size_t len;
 
 	/* By convention, the AP initiates the version operation */
 	switch (type) {
 	case GB_REQUEST_TYPE_PROTOCOL_VERSION:
-		dev_err(&connection->dev,
-			"module-initiated version operation\n");
+		dev_err(dev, "module-initiated version operation\n");
 		return -EINVAL;
 	case GB_LOOPBACK_TYPE_PING:
 	case GB_LOOPBACK_TYPE_SINK:
 		return 0;
 	case GB_LOOPBACK_TYPE_TRANSFER:
 		if (operation->request->payload_size < sizeof(*request)) {
-			dev_err(&connection->dev,
-				"transfer request too small (%zu < %zu)\n",
+			dev_err(dev, "transfer request too small (%zu < %zu)\n",
 				operation->request->payload_size,
 				sizeof(*request));
 			return -EINVAL;	/* -EMSGSIZE */
@@ -528,8 +528,7 @@ static int gb_loopback_request_recv(u8 type, struct gb_operation *operation)
 		request = operation->request->payload;
 		len = le32_to_cpu(request->len);
 		if (len > gb_dev.size_max) {
-			dev_err(&connection->dev,
-				"transfer request too large (%zu > %zu)\n",
+			dev_err(dev, "transfer request too large (%zu > %zu)\n",
 				len, gb_dev.size_max);
 			return -EINVAL;
 		}
@@ -537,8 +536,7 @@ static int gb_loopback_request_recv(u8 type, struct gb_operation *operation)
 		if (len) {
 			if (!gb_operation_response_alloc(operation, len,
 							 GFP_KERNEL)) {
-				dev_err(&connection->dev,
-					"error allocating response\n");
+				dev_err(dev, "error allocating response\n");
 				return -ENOMEM;
 			}
 			response = operation->response->payload;
@@ -547,8 +545,7 @@ static int gb_loopback_request_recv(u8 type, struct gb_operation *operation)
 		}
 		return 0;
 	default:
-		dev_err(&connection->dev,
-			"unsupported request: %hhu\n", type);
+		dev_err(dev, "unsupported request: %hhu\n", type);
 		return -EINVAL;
 	}
 }
@@ -755,8 +752,8 @@ static int gb_loopback_fn(void *data)
 			/* All threads achieved at least low_count iterations */
 			if (gb_dev.iteration_count < low_count) {
 				gb_dev.iteration_count = low_count;
-				sysfs_notify(&gb->connection->dev.kobj, NULL,
-					     "iteration_count");
+				sysfs_notify(&gb->connection->bundle->dev.kobj,
+					     NULL, "iteration_count");
 			}
 			/* Optionally terminate */
 			if (gb_dev.iteration_count == gb_dev.iteration_max) {
@@ -954,12 +951,12 @@ static int gb_loopback_connection_init(struct gb_connection *connection)
 
 	/* Create per-connection sysfs and debugfs data-points */
 	snprintf(name, sizeof(name), "raw_latency_%s",
-		 dev_name(&connection->dev));
+		 dev_name(&connection->bundle->dev));
 	gb->file = debugfs_create_file(name, S_IFREG | S_IRUGO, gb_dev.root, gb,
 				       &gb_loopback_debugfs_latency_ops);
 	gb->connection = connection;
-	connection->private = gb;
-	retval = sysfs_create_groups(&connection->dev.kobj,
+	connection->bundle->private = gb;
+	retval = sysfs_create_groups(&connection->bundle->dev.kobj,
 				     loopback_con_groups);
 	if (retval)
 		goto out_sysfs_dev;
@@ -995,14 +992,14 @@ static int gb_loopback_connection_init(struct gb_connection *connection)
 out_kfifo0:
 	kfifo_free(&gb->kfifo_lat);
 out_sysfs_conn:
-	sysfs_remove_groups(&connection->dev.kobj, loopback_con_groups);
+	sysfs_remove_groups(&connection->bundle->dev.kobj, loopback_con_groups);
 out_sysfs_dev:
 	if (!gb_dev.count) {
 		sysfs_remove_groups(kobj, loopback_dev_groups);
 		debugfs_remove(gb_dev.file);
 	}
 	debugfs_remove(gb->file);
-	connection->private = NULL;
+	connection->bundle->private = NULL;
 out_sysfs:
 	mutex_unlock(&gb_dev.mutex);
 	kfree(gb);
@@ -1012,7 +1009,7 @@ static int gb_loopback_connection_init(struct gb_connection *connection)
 
 static void gb_loopback_connection_exit(struct gb_connection *connection)
 {
-	struct gb_loopback *gb = connection->private;
+	struct gb_loopback *gb = connection->bundle->private;
 	struct kobject *kobj = &connection->hd->endo->dev.kobj;
 
 	if (!IS_ERR_OR_NULL(gb->task))
@@ -1020,7 +1017,7 @@ static void gb_loopback_connection_exit(struct gb_connection *connection)
 
 	mutex_lock(&gb_dev.mutex);
 
-	connection->private = NULL;
+	connection->bundle->private = NULL;
 	kfifo_free(&gb->kfifo_lat);
 	kfifo_free(&gb->kfifo_ts);
 	gb_connection_latency_tag_disable(connection);
@@ -1029,7 +1026,8 @@ static void gb_loopback_connection_exit(struct gb_connection *connection)
 		sysfs_remove_groups(kobj, loopback_dev_groups);
 		debugfs_remove(gb_dev.file);
 	}
-	sysfs_remove_groups(&connection->dev.kobj, loopback_con_groups);
+	sysfs_remove_groups(&connection->bundle->dev.kobj,
+			    loopback_con_groups);
 	debugfs_remove(gb->file);
 	list_del(&gb->entry);
 	mutex_unlock(&gb_dev.mutex);

commit 1ec5843ee9889914be80a6763e58a79064716023
Author: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
Date:   Thu Oct 15 16:10:45 2015 +0100

    greybus: loopback: capture and present firmware supplied latencies
    
    In order to provide deep inspection of the greybus/UniPro system
    instrumentation of
    
    1. APBridge's view of UniPro latency
    2. GPBridge's view of internal firmware-only latency
    
    have both been added and reported to the AP in the transfer loopback
    response header. When this data are present we latch and average it over
    the number of requested cycles, presenting it to user-space via sysfs.
    
    This patch adds the following sysfs entries for each loopback CPort
    
    - apbridge_unipro_latency_avg_con
    - apbridge_unipro_latency_max_con
    - apbridge_unipro_latency_min_con
    - gpbridge_firmware_latency_avg_con
    - gpbridge_firmware_latency_max_con
    - gpbridge_firmware_latency_min_con
    
    and the following sysfs entries representing the average values across all
    available CPorts
    
    - apbridge_unipro_latency_avg_dev
    - apbridge_unipro_latency_max_dev
    - apbridge_unipro_latency_min_dev
    - gpbridge_firmware_latency_avg_dev
    - gpbridge_firmware_latency_max_dev
    - gpbridge_firmware_latency_min_dev
    
    Signed-off-by: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/loopback.c b/drivers/staging/greybus/loopback.c
index d2a88af1f290..1ac86c15e974 100644
--- a/drivers/staging/greybus/loopback.c
+++ b/drivers/staging/greybus/loopback.c
@@ -60,6 +60,8 @@ struct gb_loopback_device {
 	struct gb_loopback_stats latency;
 	struct gb_loopback_stats throughput;
 	struct gb_loopback_stats requests_per_second;
+	struct gb_loopback_stats apbridge_unipro_latency;
+	struct gb_loopback_stats gpbridge_firmware_latency;
 };
 
 static struct gb_loopback_device gb_dev;
@@ -78,6 +80,8 @@ struct gb_loopback {
 	struct gb_loopback_stats latency;
 	struct gb_loopback_stats throughput;
 	struct gb_loopback_stats requests_per_second;
+	struct gb_loopback_stats apbridge_unipro_latency;
+	struct gb_loopback_stats gpbridge_firmware_latency;
 
 	u32 lbid;
 	u32 iteration_count;
@@ -272,6 +276,12 @@ gb_loopback_stats_attrs(requests_per_second, con, true);
 /* Quantity of data sent and received on this cport */
 gb_loopback_stats_attrs(throughput, dev, false);
 gb_loopback_stats_attrs(throughput, con, true);
+/* Latency across the UniPro link from APBridge's perspective */
+gb_loopback_stats_attrs(apbridge_unipro_latency, dev, false);
+gb_loopback_stats_attrs(apbridge_unipro_latency, con, true);
+/* Firmware induced overhead in the GPBridge */
+gb_loopback_stats_attrs(gpbridge_firmware_latency, dev, false);
+gb_loopback_stats_attrs(gpbridge_firmware_latency, con, true);
 /* Number of errors encountered during loop */
 gb_loopback_ro_attr(error, dev, false);
 gb_loopback_ro_attr(error, con, true);
@@ -306,6 +316,12 @@ static struct attribute *loopback_dev_attrs[] = {
 	&dev_attr_throughput_min_dev.attr,
 	&dev_attr_throughput_max_dev.attr,
 	&dev_attr_throughput_avg_dev.attr,
+	&dev_attr_apbridge_unipro_latency_min_dev.attr,
+	&dev_attr_apbridge_unipro_latency_max_dev.attr,
+	&dev_attr_apbridge_unipro_latency_avg_dev.attr,
+	&dev_attr_gpbridge_firmware_latency_min_dev.attr,
+	&dev_attr_gpbridge_firmware_latency_max_dev.attr,
+	&dev_attr_gpbridge_firmware_latency_avg_dev.attr,
 	&dev_attr_type.attr,
 	&dev_attr_size.attr,
 	&dev_attr_ms_wait.attr,
@@ -327,6 +343,12 @@ static struct attribute *loopback_con_attrs[] = {
 	&dev_attr_throughput_min_con.attr,
 	&dev_attr_throughput_max_con.attr,
 	&dev_attr_throughput_avg_con.attr,
+	&dev_attr_apbridge_unipro_latency_min_con.attr,
+	&dev_attr_apbridge_unipro_latency_max_con.attr,
+	&dev_attr_apbridge_unipro_latency_avg_con.attr,
+	&dev_attr_gpbridge_firmware_latency_min_con.attr,
+	&dev_attr_gpbridge_firmware_latency_max_con.attr,
+	&dev_attr_gpbridge_firmware_latency_avg_con.attr,
 	&dev_attr_error_con.attr,
 	NULL,
 };
@@ -463,6 +485,8 @@ static int gb_loopback_transfer(struct gb_loopback *gb, u32 len)
 		dev_err(&gb->connection->dev, "Loopback Data doesn't match\n");
 		retval = -EREMOTEIO;
 	}
+	gb->apbridge_latency_ts = (u32)__le32_to_cpu(response->reserved0);
+	gb->gpbridge_latency_ts = (u32)__le32_to_cpu(response->reserved1);
 
 gb_error:
 	kfree(request);
@@ -545,6 +569,10 @@ static void gb_loopback_reset_stats(struct gb_loopback_device *gb_dev)
 		       sizeof(struct gb_loopback_stats));
 		memcpy(&gb->requests_per_second, &reset,
 		       sizeof(struct gb_loopback_stats));
+		memcpy(&gb->apbridge_unipro_latency, &reset,
+		       sizeof(struct gb_loopback_stats));
+		memcpy(&gb->gpbridge_firmware_latency, &reset,
+		       sizeof(struct gb_loopback_stats));
 		mutex_unlock(&gb->mutex);
 	}
 
@@ -555,6 +583,10 @@ static void gb_loopback_reset_stats(struct gb_loopback_device *gb_dev)
 	memcpy(&gb_dev->throughput, &reset, sizeof(struct gb_loopback_stats));
 	memcpy(&gb_dev->requests_per_second, &reset,
 	       sizeof(struct gb_loopback_stats));
+	memcpy(&gb_dev->apbridge_unipro_latency, &reset,
+	       sizeof(struct gb_loopback_stats));
+	memcpy(&gb_dev->gpbridge_firmware_latency, &reset,
+	       sizeof(struct gb_loopback_stats));
 }
 
 static void gb_loopback_update_stats(struct gb_loopback_stats *stats, u32 val)
@@ -677,6 +709,16 @@ static void gb_loopback_calculate_stats(struct gb_loopback *gb)
 	/* Log throughput and requests using latency as benchmark */
 	gb_loopback_throughput_update(gb, lat);
 	gb_loopback_requests_update(gb, lat);
+
+	/* Log the firmware supplied latency values */
+	gb_loopback_update_stats(&gb_dev.apbridge_unipro_latency,
+				 gb->apbridge_latency_ts);
+	gb_loopback_update_stats(&gb->apbridge_unipro_latency,
+				 gb->apbridge_latency_ts);
+	gb_loopback_update_stats(&gb_dev.gpbridge_firmware_latency,
+				 gb->gpbridge_latency_ts);
+	gb_loopback_update_stats(&gb->gpbridge_firmware_latency,
+				 gb->gpbridge_latency_ts);
 }
 
 static int gb_loopback_fn(void *data)
@@ -736,6 +778,8 @@ static int gb_loopback_fn(void *data)
 			goto sleep;
 		}
 		/* Else operations to perform */
+		gb->apbridge_latency_ts = 0;
+		gb->gpbridge_latency_ts = 0;
 		if (type == GB_LOOPBACK_TYPE_PING)
 			error = gb_loopback_ping(gb);
 		else if (type == GB_LOOPBACK_TYPE_TRANSFER)

commit e6227ee64782e1cda88a70512ac2b0ae8fda2203
Author: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
Date:   Thu Oct 15 16:10:44 2015 +0100

    greybus: loopback: add tracker variables to hold firmware timestamps
    
    This patch adds tracker variables to hold the incoming firmware derived
    timestamps where apbridge_latency_ts will contain the APBridge's view of
    the UniPro turn-around time and gpbridge_latency_ts will contain the
    GPBridge's view of it's own internal latency. Both values are reported
    in microseconds.
    
    Signed-off-by: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/loopback.c b/drivers/staging/greybus/loopback.c
index 95cba823ff90..d2a88af1f290 100644
--- a/drivers/staging/greybus/loopback.c
+++ b/drivers/staging/greybus/loopback.c
@@ -83,6 +83,8 @@ struct gb_loopback {
 	u32 iteration_count;
 	u64 elapsed_nsecs;
 	u32 error;
+	u32 apbridge_latency_ts;
+	u32 gpbridge_latency_ts;
 };
 
 #define GB_LOOPBACK_FIFO_DEFAULT			8192

commit fd58926ebef4a5afa238f35cc99c1f99653c40a4
Author: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
Date:   Thu Oct 15 16:10:43 2015 +0100

    greybus: loopback: send command to APBridge to tag throughput
    
    A USB vendor command has been added to APBridge to allow for tagging of
    specific CPort identifiers with internal timing data, specifically geared
    towards capturing and understanding latencies in the UniPro fabric. This
    patch sends a command to APBridge for each known loopback CPort to tag data
    as appropriate. Subsequent patches will present this data to user-space for
    ongoing integration analysis.
    
    Signed-off-by: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/loopback.c b/drivers/staging/greybus/loopback.c
index 5cbb8cb7fd9b..95cba823ff90 100644
--- a/drivers/staging/greybus/loopback.c
+++ b/drivers/staging/greybus/loopback.c
@@ -23,6 +23,7 @@
 #include <asm/div64.h>
 
 #include "greybus.h"
+#include "connection.h"
 
 #define NSEC_PER_DAY 86400000000000ULL
 
@@ -938,6 +939,7 @@ static int gb_loopback_connection_init(struct gb_connection *connection)
 	}
 
 	gb_loopback_insert_id(gb);
+	gb_connection_latency_tag_enable(connection);
 	gb_dev.count++;
 	mutex_unlock(&gb_dev.mutex);
 	return 0;
@@ -975,6 +977,7 @@ static void gb_loopback_connection_exit(struct gb_connection *connection)
 	connection->private = NULL;
 	kfifo_free(&gb->kfifo_lat);
 	kfifo_free(&gb->kfifo_ts);
+	gb_connection_latency_tag_disable(connection);
 	gb_dev.count--;
 	if (!gb_dev.count) {
 		sysfs_remove_groups(kobj, loopback_dev_groups);

commit 6ab1ce4d542ea1b5ffa40321e021d95de47880ea
Author: Johan Hovold <johan@hovoldconsulting.com>
Date:   Sat Sep 26 17:59:15 2015 -0700

    greybus: operation: remove gb_operation_destroy
    
    Remove legacy interface to "destroy" operations, which is now just a
    wrapper for gb_operation_put.
    
    The old interface name hides the fact that all operations are refcounted
    and may live on even after having "destroyed" them.
    
    Signed-off-by: Johan Hovold <johan@hovoldconsulting.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/loopback.c b/drivers/staging/greybus/loopback.c
index 5a6354eb4ea9..5cbb8cb7fd9b 100644
--- a/drivers/staging/greybus/loopback.c
+++ b/drivers/staging/greybus/loopback.c
@@ -402,7 +402,8 @@ static int gb_loopback_operation_sync(struct gb_loopback *gb, int type,
 				response_size);
 		}
 	}
-	gb_operation_destroy(operation);
+
+	gb_operation_put(operation);
 
 error:
 	do_gettimeofday(&te);

commit c83d4abe1dfd6aec45f594ad756fb5256263c5b8
Author: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
Date:   Wed Sep 23 09:31:34 2015 -0700

    greybus: loopback: remove module specific identifier from debugfs name
    
    The datapoint we are using to return metrics across modules and cports
    shouldn't have a module identifier in it i.e.
    
    /sys/kernel/debug/gb_loopback/raw_latency_endo0
    not
    /sys/kernel/debug/gb_loopback/raw_latency_endo0:X
    
    This patch removes the module_id used up to this point. Including module_id
    actually ends up making life harder in user-space so dropping it.
    
    Signed-off-by: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
    Reviewed-by: Patrick Titiano <ptitiano@baylibre.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/loopback.c b/drivers/staging/greybus/loopback.c
index e728216a61cb..5a6354eb4ea9 100644
--- a/drivers/staging/greybus/loopback.c
+++ b/drivers/staging/greybus/loopback.c
@@ -883,11 +883,10 @@ static int gb_loopback_connection_init(struct gb_connection *connection)
 		return -ENOMEM;
 	gb_loopback_reset_stats(&gb_dev);
 
-	/* If this is the first connection - create a module endo0:x entries */
+	/* If this is the first connection - create a module endo0 entry */
 	mutex_lock(&gb_dev.mutex);
 	if (!gb_dev.count) {
-		snprintf(name, sizeof(name), "raw_latency_endo0:%d",
-			 connection->bundle->intf->module->module_id);
+		snprintf(name, sizeof(name), "raw_latency_endo0");
 		gb_dev.file = debugfs_create_file(name, S_IFREG | S_IRUGO,
 						  gb_dev.root, &gb_dev,
 				  &gb_loopback_debugfs_dev_latency_ops);

commit 8d8d36da750ccba4c9ba9a293b3a338afd0b75b0
Author: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
Date:   Wed Sep 23 09:31:33 2015 -0700

    greybus: loopback: drop redundant endo0 string from debugfs entry name
    
    dev_name() will return the endo0 component of the string on it's own,
    there's no need to include it in the snprintf() when construting the
    debugfs name. This fixes 'endo0' appearing more than once in the debugfs
    name - shamefully slipped through testing cb570c93783f
    ('greybus/loopback: use dev_name to populate sysfsname').
    
    Signed-off-by: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/loopback.c b/drivers/staging/greybus/loopback.c
index 764ee83df082..e728216a61cb 100644
--- a/drivers/staging/greybus/loopback.c
+++ b/drivers/staging/greybus/loopback.c
@@ -906,7 +906,7 @@ static int gb_loopback_connection_init(struct gb_connection *connection)
 	}
 
 	/* Create per-connection sysfs and debugfs data-points */
-	snprintf(name, sizeof(name), "raw_latency_endo0:%s",
+	snprintf(name, sizeof(name), "raw_latency_%s",
 		 dev_name(&connection->dev));
 	gb->file = debugfs_create_file(name, S_IFREG | S_IRUGO, gb_dev.root, gb,
 				       &gb_loopback_debugfs_latency_ops);

commit 42d7f7e884fcce78301ca88da3434f0fcbf3fee5
Author: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
Date:   Wed Sep 23 09:31:32 2015 -0700

    greybus: loopback: masked out threads should sleep
    
    If a thread is masked out it should not consume CPU cycles during a test.
    We set an arbitrary 100 millisecond sleep time for each masked out thread.
    Reasonably blunt instrument to ensure threads with nothing to do don't end
    up thrashing the acquisition/release of mutexes.
    
    Signed-off-by: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
    Reviewed-by: Patrick Titiano <ptitiano@baylibre.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/loopback.c b/drivers/staging/greybus/loopback.c
index 3151876a717c..764ee83df082 100644
--- a/drivers/staging/greybus/loopback.c
+++ b/drivers/staging/greybus/loopback.c
@@ -693,8 +693,10 @@ static int gb_loopback_fn(void *data)
 			break;
 
 		mutex_lock(&gb_dev.mutex);
-		if (!gb_loopback_active(gb))
+		if (!gb_loopback_active(gb)) {
+			ms_wait = 100;
 			goto unlock_continue;
+		}
 		if (gb_dev.iteration_max) {
 			/* Determine overall lowest count */
 			low_count = gb->iteration_count;

commit f01f7a9851f9c75467373ba7797394dba91825da
Author: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
Date:   Wed Sep 23 09:31:31 2015 -0700

    greybus: loopback: move sysfs entries to /sys/bus/greybus/devices/endo0
    
    Currently we have sysfs entries that are created when the first incoming
    connection is created as sub-nodes of the module associated with that
    connection e.g. /sys/bus/grebus/devices/endo0:X where X is the module
    identifier associated with the new connection. This is conceptually
    incorrect since the sysfs entries we create actually aren't bound to a
    module. Depending on the order connections are brought up we can also have
    a situation where /sys/bus/greybus/devices/endo0:X has high-level control
    sysfs data-points but /sys/bus/greybus/devices/endo0:Y does not. Rather
    than needlessly replicate data-points across each endo0:X, endo0:Y, endo0:Z
    sysfs directories it is more sensible to locate the entries in
    /sys/bus/greybus/devices/endo0.
    
    Signed-off-by: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
    Reviewed-by: Patrick Titiano <ptitiano@baylibre.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/loopback.c b/drivers/staging/greybus/loopback.c
index 7ccf9a26dab3..3151876a717c 100644
--- a/drivers/staging/greybus/loopback.c
+++ b/drivers/staging/greybus/loopback.c
@@ -874,7 +874,7 @@ static int gb_loopback_connection_init(struct gb_connection *connection)
 	struct gb_loopback *gb;
 	int retval;
 	char name[DEBUGFS_NAMELEN];
-	struct kobject *kobj = &connection->bundle->intf->module->dev.kobj;
+	struct kobject *kobj = &connection->hd->endo->dev.kobj;
 
 	gb = kzalloc(sizeof(*gb), GFP_KERNEL);
 	if (!gb)
@@ -963,7 +963,7 @@ static int gb_loopback_connection_init(struct gb_connection *connection)
 static void gb_loopback_connection_exit(struct gb_connection *connection)
 {
 	struct gb_loopback *gb = connection->private;
-	struct kobject *kobj = &connection->bundle->intf->module->dev.kobj;
+	struct kobject *kobj = &connection->hd->endo->dev.kobj;
 
 	if (!IS_ERR_OR_NULL(gb->task))
 		kthread_stop(gb->task);

commit d090446a915f109e65f3b2643269b134e1ddb4ef
Author: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
Date:   Tue Sep 22 18:06:37 2015 -0700

    greybus: loopback: drop dependency on internal timestamps
    
    This patch drops tracking of internal latencies, it's possible to derive
    these times via kernel tracepoints and some user-space scripting. Since
    there's no other use of the internal timestamp than the loopback driver we
    remove the connection.c, connection.h, es1.c, es2.c and loopback.c
    inter-dependency in one go.
    
    Signed-off-by: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/loopback.c b/drivers/staging/greybus/loopback.c
index 512453621a9b..7ccf9a26dab3 100644
--- a/drivers/staging/greybus/loopback.c
+++ b/drivers/staging/greybus/loopback.c
@@ -57,7 +57,6 @@ struct gb_loopback_device {
 
 	/* Overall stats */
 	struct gb_loopback_stats latency;
-	struct gb_loopback_stats latency_gb;
 	struct gb_loopback_stats throughput;
 	struct gb_loopback_stats requests_per_second;
 };
@@ -76,14 +75,12 @@ struct gb_loopback {
 
 	/* Per connection stats */
 	struct gb_loopback_stats latency;
-	struct gb_loopback_stats latency_gb;
 	struct gb_loopback_stats throughput;
 	struct gb_loopback_stats requests_per_second;
 
 	u32 lbid;
 	u32 iteration_count;
 	u64 elapsed_nsecs;
-	u64 elapsed_nsecs_gb;
 	u32 error;
 };
 
@@ -266,9 +263,6 @@ static void gb_loopback_check_attr(struct gb_loopback_device *gb_dev,
 /* Time to send and receive one message */
 gb_loopback_stats_attrs(latency, dev, false);
 gb_loopback_stats_attrs(latency, con, true);
-/* Time to send and receive one message not including greybus */
-gb_loopback_stats_attrs(latency_gb, dev, false);
-gb_loopback_stats_attrs(latency_gb, con, true);
 /* Number of requests sent per second on this cport */
 gb_loopback_stats_attrs(requests_per_second, dev, false);
 gb_loopback_stats_attrs(requests_per_second, con, true);
@@ -303,9 +297,6 @@ static struct attribute *loopback_dev_attrs[] = {
 	&dev_attr_latency_min_dev.attr,
 	&dev_attr_latency_max_dev.attr,
 	&dev_attr_latency_avg_dev.attr,
-	&dev_attr_latency_gb_min_dev.attr,
-	&dev_attr_latency_gb_max_dev.attr,
-	&dev_attr_latency_gb_avg_dev.attr,
 	&dev_attr_requests_per_second_min_dev.attr,
 	&dev_attr_requests_per_second_max_dev.attr,
 	&dev_attr_requests_per_second_avg_dev.attr,
@@ -327,9 +318,6 @@ static struct attribute *loopback_con_attrs[] = {
 	&dev_attr_latency_min_con.attr,
 	&dev_attr_latency_max_con.attr,
 	&dev_attr_latency_avg_con.attr,
-	&dev_attr_latency_gb_min_con.attr,
-	&dev_attr_latency_gb_max_con.attr,
-	&dev_attr_latency_gb_avg_con.attr,
 	&dev_attr_requests_per_second_min_con.attr,
 	&dev_attr_requests_per_second_max_con.attr,
 	&dev_attr_requests_per_second_avg_con.attr,
@@ -423,11 +411,6 @@ static int gb_loopback_operation_sync(struct gb_loopback *gb, int type,
 	gb_loopback_push_latency_ts(gb, &ts, &te);
 	gb->elapsed_nsecs = gb_loopback_calc_latency(&ts, &te);
 
-	/* Calculate non-greybus related component of the latency */
-	gb_connection_pop_timestamp(gb->connection, &ts);
-	gb_connection_pop_timestamp(gb->connection, &te);
-	gb->elapsed_nsecs_gb = gb_loopback_calc_latency(&ts, &te);
-
 	return ret;
 }
 
@@ -554,8 +537,6 @@ static void gb_loopback_reset_stats(struct gb_loopback_device *gb_dev)
 		mutex_lock(&gb->mutex);
 		memcpy(&gb->latency, &reset,
 		       sizeof(struct gb_loopback_stats));
-		memcpy(&gb->latency_gb, &reset,
-		       sizeof(struct gb_loopback_stats));
 		memcpy(&gb->throughput, &reset,
 		       sizeof(struct gb_loopback_stats));
 		memcpy(&gb->requests_per_second, &reset,
@@ -567,7 +548,6 @@ static void gb_loopback_reset_stats(struct gb_loopback_device *gb_dev)
 	memset(&gb_dev->start, 0, sizeof(struct timeval));
 	memset(&gb_dev->end, 0, sizeof(struct timeval));
 	memcpy(&gb_dev->latency, &reset, sizeof(struct gb_loopback_stats));
-	memcpy(&gb_dev->latency_gb, &reset, sizeof(struct gb_loopback_stats));
 	memcpy(&gb_dev->throughput, &reset, sizeof(struct gb_loopback_stats));
 	memcpy(&gb_dev->requests_per_second, &reset,
 	       sizeof(struct gb_loopback_stats));
@@ -679,7 +659,6 @@ static int gb_loopback_calculate_aggregate_stats(void)
 static void gb_loopback_calculate_stats(struct gb_loopback *gb)
 {
 	u32 lat;
-	u64 tmp;
 
 	/* Express latency in terms of microseconds */
 	lat = gb_loopback_nsec_to_usec_latency(gb->elapsed_nsecs);
@@ -694,12 +673,6 @@ static void gb_loopback_calculate_stats(struct gb_loopback *gb)
 	/* Log throughput and requests using latency as benchmark */
 	gb_loopback_throughput_update(gb, lat);
 	gb_loopback_requests_update(gb, lat);
-
-	/* Calculate the greybus related latency number in nanoseconds */
-	tmp = gb->elapsed_nsecs - gb->elapsed_nsecs_gb;
-	lat = tmp;
-	gb_loopback_update_stats(&gb_dev.latency_gb, lat);
-	gb_loopback_update_stats(&gb->latency_gb, lat);
 }
 
 static int gb_loopback_fn(void *data)

commit 26717ed328b5d238b5c6268912d45703b99b79d0
Author: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
Date:   Mon Sep 14 10:48:55 2015 +0100

    greybus: loopback: use dev_name to populate sysfsname
    
    dev_name() will give a nice string representing the end0:X:Y:Z:W name
    mitigating the need to pick apart the various nested data structures and
    print out their various identifiers.
    
    Signed-off-by: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
    Suggested-by: Viresh Kumar <viresh.kumar@linaro.org>
    Reviewed-by: Patrick Titiano <ptitiano@baylibre.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/loopback.c b/drivers/staging/greybus/loopback.c
index 6155b50b6702..512453621a9b 100644
--- a/drivers/staging/greybus/loopback.c
+++ b/drivers/staging/greybus/loopback.c
@@ -931,11 +931,8 @@ static int gb_loopback_connection_init(struct gb_connection *connection)
 	}
 
 	/* Create per-connection sysfs and debugfs data-points */
-	snprintf(name, sizeof(name), "raw_latency_endo0:%d:%d:%d:%d",
-		connection->bundle->intf->module->module_id,
-		connection->bundle->intf->interface_id,
-		connection->bundle->id,
-		connection->intf_cport_id);
+	snprintf(name, sizeof(name), "raw_latency_endo0:%s",
+		 dev_name(&connection->dev));
 	gb->file = debugfs_create_file(name, S_IFREG | S_IRUGO, gb_dev.root, gb,
 				       &gb_loopback_debugfs_latency_ops);
 	gb->connection = connection;

commit fbb8edbafe1525c4168108a46c1134f5a7cd27c4
Author: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
Date:   Mon Sep 14 10:48:47 2015 +0100

    greybus: loopback: add gb_loopback_operation_sync
    
    In order to extract timestamps from gb_message instead of gb_connection we
    will need access to the gb_operation structure. A first step to that is to
    create our own gb_loopback_operation_sync which will call
    gb_operation_request_send_sync() directly. Once loopback is using this
    function internally it will be possible to convert to gb_message based
    timestamps and drop gb_connection based timestamps in two seperate patches.
    
    Signed-off-by: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
    Reviewed-by: Patrick Titiano <ptitiano@baylibre.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/loopback.c b/drivers/staging/greybus/loopback.c
index a62e122c2bcc..6155b50b6702 100644
--- a/drivers/staging/greybus/loopback.c
+++ b/drivers/staging/greybus/loopback.c
@@ -380,22 +380,43 @@ static int gb_loopback_active(struct gb_loopback *gb)
 	return (gb_dev.mask == 0 || (gb_dev.mask & gb->lbid));
 }
 
-static int gb_loopback_sink(struct gb_loopback *gb, u32 len)
+static int gb_loopback_operation_sync(struct gb_loopback *gb, int type,
+				      void *request, int request_size,
+				      void *response, int response_size)
 {
+	struct gb_operation *operation;
 	struct timeval ts, te;
-	struct gb_loopback_transfer_request *request;
-	int retval;
-
-	request = kmalloc(len + sizeof(*request), GFP_KERNEL);
-	if (!request)
-		return -ENOMEM;
-
-	request->len = cpu_to_le32(len);
+	int ret;
 
 	do_gettimeofday(&ts);
-	retval = gb_operation_sync(gb->connection, GB_LOOPBACK_TYPE_SINK,
-				   request, len + sizeof(*request), NULL, 0);
+	operation = gb_operation_create(gb->connection, type, request_size,
+					response_size, GFP_KERNEL);
+	if (!operation) {
+		ret = -ENOMEM;
+		goto error;
+	}
 
+	if (request_size)
+		memcpy(operation->request->payload, request, request_size);
+
+	ret = gb_operation_request_send_sync(operation);
+	if (ret) {
+		dev_err(&gb->connection->dev,
+			"synchronous operation failed: %d\n", ret);
+	} else {
+		if (response_size == operation->response->payload_size) {
+			memcpy(response, operation->response->payload,
+			       response_size);
+		} else {
+			dev_err(&gb->connection->dev,
+				"response size %zu expected %d\n",
+				operation->response->payload_size,
+				response_size);
+		}
+	}
+	gb_operation_destroy(operation);
+
+error:
 	do_gettimeofday(&te);
 
 	/* Calculate the total time the message took */
@@ -407,14 +428,28 @@ static int gb_loopback_sink(struct gb_loopback *gb, u32 len)
 	gb_connection_pop_timestamp(gb->connection, &te);
 	gb->elapsed_nsecs_gb = gb_loopback_calc_latency(&ts, &te);
 
+	return ret;
+}
+
+static int gb_loopback_sink(struct gb_loopback *gb, u32 len)
+{
+	struct gb_loopback_transfer_request *request;
+	int retval;
+
+	request = kmalloc(len + sizeof(*request), GFP_KERNEL);
+	if (!request)
+		return -ENOMEM;
 
+	request->len = cpu_to_le32(len);
+	retval = gb_loopback_operation_sync(gb, GB_LOOPBACK_TYPE_SINK,
+					    request, len + sizeof(*request),
+					    NULL, 0);
 	kfree(request);
 	return retval;
 }
 
 static int gb_loopback_transfer(struct gb_loopback *gb, u32 len)
 {
-	struct timeval ts, te;
 	struct gb_loopback_transfer_request *request;
 	struct gb_loopback_transfer_response *response;
 	int retval;
@@ -431,22 +466,9 @@ static int gb_loopback_transfer(struct gb_loopback *gb, u32 len)
 	memset(request->data, 0x5A, len);
 
 	request->len = cpu_to_le32(len);
-
-	do_gettimeofday(&ts);
-	retval = gb_operation_sync(gb->connection, GB_LOOPBACK_TYPE_TRANSFER,
-				   request, len + sizeof(*request),
-				   response, len + sizeof(*response));
-	do_gettimeofday(&te);
-
-	/* Calculate the total time the message took */
-	gb_loopback_push_latency_ts(gb, &ts, &te);
-	gb->elapsed_nsecs = gb_loopback_calc_latency(&ts, &te);
-
-	/* Calculate non-greybus related component of the latency */
-	gb_connection_pop_timestamp(gb->connection, &ts);
-	gb_connection_pop_timestamp(gb->connection, &te);
-	gb->elapsed_nsecs_gb = gb_loopback_calc_latency(&ts, &te);
-
+	retval = gb_loopback_operation_sync(gb, GB_LOOPBACK_TYPE_TRANSFER,
+					    request, len + sizeof(*request),
+					    response, len + sizeof(*response));
 	if (retval)
 		goto gb_error;
 
@@ -464,24 +486,8 @@ static int gb_loopback_transfer(struct gb_loopback *gb, u32 len)
 
 static int gb_loopback_ping(struct gb_loopback *gb)
 {
-	struct timeval ts, te;
-	int retval;
-
-	do_gettimeofday(&ts);
-	retval = gb_operation_sync(gb->connection, GB_LOOPBACK_TYPE_PING,
-				   NULL, 0, NULL, 0);
-	do_gettimeofday(&te);
-
-	/* Calculate the total time the message took */
-	gb_loopback_push_latency_ts(gb, &ts, &te);
-	gb->elapsed_nsecs = gb_loopback_calc_latency(&ts, &te);
-
-	/* Calculate non-greybus related component of the latency */
-	gb_connection_pop_timestamp(gb->connection, &ts);
-	gb_connection_pop_timestamp(gb->connection, &te);
-	gb->elapsed_nsecs_gb = gb_loopback_calc_latency(&ts, &te);
-
-	return retval;
+	return gb_loopback_operation_sync(gb, GB_LOOPBACK_TYPE_PING,
+					  NULL, 0, NULL, 0);
 }
 
 static int gb_loopback_request_recv(u8 type, struct gb_operation *operation)

commit 5015115def3ed9907fb018180be969cf2f2f116d
Author: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
Date:   Mon Sep 14 10:48:46 2015 +0100

    greybus: loopback: sort list of connections for masking purposes
    
    In user-space we specify a list of connections as a bit-mask with the
    assumption that a list such is indexed as indicated below.
    
    end0:3:3:1:1 = 1
    end0:3:3:2:3 = 2
    end0:3:3:3:4 = 4
    
    Current code assigns bitmask ids based on the order of discovery, however
    user-space has no idea what the order of discovery is. This patch sorts the
    linked list of connections associated with the loopback driver and assigns
    a bit-id based on the sorted list - not the order of discovery. This
    change therefore enforces the end-users idea that end0:3:3:1:1 above is
    always denoted by bit 1 - even if from the AP's perspective it was the last
    entry discovered.
    
    Signed-off-by: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
    Reviewed-by: Patrick Titiano <ptitiano@baylibre.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/loopback.c b/drivers/staging/greybus/loopback.c
index ba65457f9f70..a62e122c2bcc 100644
--- a/drivers/staging/greybus/loopback.c
+++ b/drivers/staging/greybus/loopback.c
@@ -18,6 +18,7 @@
 #include <linux/fs.h>
 #include <linux/kfifo.h>
 #include <linux/debugfs.h>
+#include <linux/list_sort.h>
 
 #include <asm/div64.h>
 
@@ -843,6 +844,50 @@ static const struct file_operations gb_loopback_debugfs_dev_latency_ops = {
 	.release	= single_release,
 };
 
+static int gb_loopback_bus_id_compare(void *priv, struct list_head *lha,
+				      struct list_head *lhb)
+{
+	struct gb_loopback *a = list_entry(lha, struct gb_loopback, entry);
+	struct gb_loopback *b = list_entry(lhb, struct gb_loopback, entry);
+	struct gb_connection *ca = a->connection;
+	struct gb_connection *cb = b->connection;
+
+	if (ca->bundle->intf->module->module_id <
+	    cb->bundle->intf->module->module_id)
+		return -1;
+	if (cb->bundle->intf->module->module_id <
+	    ca->bundle->intf->module->module_id)
+		return 1;
+	if (ca->bundle->intf->interface_id < cb->bundle->intf->interface_id)
+		return -1;
+	if (cb->bundle->intf->interface_id < ca->bundle->intf->interface_id)
+		return 1;
+	if (ca->bundle->id < cb->bundle->id)
+		return -1;
+	if (cb->bundle->id < ca->bundle->id)
+		return 1;
+	if (ca->intf_cport_id < cb->intf_cport_id)
+		return -1;
+	else if (cb->intf_cport_id < ca->intf_cport_id)
+		return 1;
+
+	return 0;
+}
+
+static void gb_loopback_insert_id(struct gb_loopback *gb)
+{
+	struct gb_loopback *gb_list;
+	u32 new_lbid = 0;
+
+	/* perform an insertion sort */
+	list_add_tail(&gb->entry, &gb_dev.list);
+	list_sort(NULL, &gb_dev.list, gb_loopback_bus_id_compare);
+	list_for_each_entry(gb_list, &gb_dev.list, entry) {
+		gb_list->lbid = 1 << new_lbid;
+		new_lbid++;
+	}
+}
+
 #define DEBUGFS_NAMELEN 32
 
 static int gb_loopback_connection_init(struct gb_connection *connection)
@@ -908,14 +953,13 @@ static int gb_loopback_connection_init(struct gb_connection *connection)
 
 	/* Fork worker thread */
 	mutex_init(&gb->mutex);
-	gb->lbid = 1 << gb_dev.count;
 	gb->task = kthread_run(gb_loopback_fn, gb, "gb_loopback");
 	if (IS_ERR(gb->task)) {
 		retval = PTR_ERR(gb->task);
 		goto out_kfifo1;
 	}
 
-	list_add_tail(&gb->entry, &gb_dev.list);
+	gb_loopback_insert_id(gb);
 	gb_dev.count++;
 	mutex_unlock(&gb_dev.mutex);
 	return 0;

commit 4a655ad4c2b83815ccab5057e29bf0f6c981a94e
Author: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
Date:   Mon Sep 14 10:48:45 2015 +0100

    greybus: loopback: add response len to loopback protocol
    
    This patch adds a len field to the loopback protocol.
    This field is validated in gb_loopback_transfer() and stuffed in
    gb_loopback_request_recv().
    
    Signed-off-by: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
    Reviewed-by: Patrick Titiano <ptitiano@baylibre.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/loopback.c b/drivers/staging/greybus/loopback.c
index a9b901fbeb5c..ba65457f9f70 100644
--- a/drivers/staging/greybus/loopback.c
+++ b/drivers/staging/greybus/loopback.c
@@ -524,6 +524,7 @@ static int gb_loopback_request_recv(u8 type, struct gb_operation *operation)
 				return -ENOMEM;
 			}
 			response = operation->response->payload;
+			response->len = cpu_to_le32(len);
 			memcpy(response->data, request->data, len);
 		}
 		return 0;

commit f2cfa7043940cdda5c9e945b1cf5c66da172bc33
Author: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
Date:   Mon Sep 14 10:48:44 2015 +0100

    greybus: loopback: convert pr_info to dev_err
    
    This patch fixes and invalid use of pr_info() in favour of dev_err();
    
    Signed-off-by: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
    Reviewed-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/loopback.c b/drivers/staging/greybus/loopback.c
index 338522a49f9d..a9b901fbeb5c 100644
--- a/drivers/staging/greybus/loopback.c
+++ b/drivers/staging/greybus/loopback.c
@@ -450,7 +450,7 @@ static int gb_loopback_transfer(struct gb_loopback *gb, u32 len)
 		goto gb_error;
 
 	if (memcmp(request->data, response->data, len)) {
-		pr_info("%s: Loopback Data doesn't match\n", __func__);
+		dev_err(&gb->connection->dev, "Loopback Data doesn't match\n");
 		retval = -EREMOTEIO;
 	}
 

commit 909cdeb5d81926bb294394919ba84bf9b98d5744
Author: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
Date:   Mon Sep 14 10:48:43 2015 +0100

    greybus: loopback: ensure sysfs entries are cleaned up on exit
    
    bdd4bba4 ('greybus/loopback: add module level sys/debug fs data points')
    added a sysfs entry attached to gb_dev but missed the jump to out_sysfs_dev
    This patchs fixes the missing jump to out_sysfs_dev.
    
    Signed-off-by: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
    Reported-by: Viresh Kumar <viresh.kumar@linaro.org>
    Reviewed-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/loopback.c b/drivers/staging/greybus/loopback.c
index 8bfeec8f71a0..338522a49f9d 100644
--- a/drivers/staging/greybus/loopback.c
+++ b/drivers/staging/greybus/loopback.c
@@ -873,7 +873,7 @@ static int gb_loopback_connection_init(struct gb_connection *connection)
 		if (gb_dev.size_max <=
 			sizeof(struct gb_loopback_transfer_request)) {
 			retval = -EINVAL;
-			goto out_sysfs;
+			goto out_sysfs_dev;
 		}
 		gb_dev.size_max -= sizeof(struct gb_loopback_transfer_request);
 	}

commit c7ea5ed6f2790240a8ddaf98905a9465a37e839e
Author: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
Date:   Mon Sep 14 10:48:42 2015 +0100

    greybus: loopback: ensure debugfs entires are cleaned up on exit
    
    bdd4bba4 ('greybus/loopback: add module level sys/debug fs data points')
    added a debugfs entry attached to gb_dev but omitted the cleanup on gb_init
    error and gb_exit. This patchs fixes the missing debugfs_remove().
    
    Signed-off-by: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
    Reported-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/loopback.c b/drivers/staging/greybus/loopback.c
index 745490af7e47..8bfeec8f71a0 100644
--- a/drivers/staging/greybus/loopback.c
+++ b/drivers/staging/greybus/loopback.c
@@ -34,6 +34,7 @@ struct gb_loopback_stats {
 
 struct gb_loopback_device {
 	struct dentry *root;
+	struct dentry *file;
 	u32 count;
 
 	struct kfifo kfifo;
@@ -860,9 +861,9 @@ static int gb_loopback_connection_init(struct gb_connection *connection)
 	if (!gb_dev.count) {
 		snprintf(name, sizeof(name), "raw_latency_endo0:%d",
 			 connection->bundle->intf->module->module_id);
-		debugfs_create_file(name, S_IFREG | S_IRUGO,
-				    gb_dev.root, &gb_dev,
-				    &gb_loopback_debugfs_dev_latency_ops);
+		gb_dev.file = debugfs_create_file(name, S_IFREG | S_IRUGO,
+						  gb_dev.root, &gb_dev,
+				  &gb_loopback_debugfs_dev_latency_ops);
 		retval = sysfs_create_groups(kobj, loopback_dev_groups);
 		if (retval)
 			goto out_sysfs;
@@ -925,8 +926,10 @@ static int gb_loopback_connection_init(struct gb_connection *connection)
 out_sysfs_conn:
 	sysfs_remove_groups(&connection->dev.kobj, loopback_con_groups);
 out_sysfs_dev:
-	if (!gb_dev.count)
+	if (!gb_dev.count) {
 		sysfs_remove_groups(kobj, loopback_dev_groups);
+		debugfs_remove(gb_dev.file);
+	}
 	debugfs_remove(gb->file);
 	connection->private = NULL;
 out_sysfs:
@@ -950,8 +953,10 @@ static void gb_loopback_connection_exit(struct gb_connection *connection)
 	kfifo_free(&gb->kfifo_lat);
 	kfifo_free(&gb->kfifo_ts);
 	gb_dev.count--;
-	if (!gb_dev.count)
+	if (!gb_dev.count) {
 		sysfs_remove_groups(kobj, loopback_dev_groups);
+		debugfs_remove(gb_dev.file);
+	}
 	sysfs_remove_groups(&connection->dev.kobj, loopback_con_groups);
 	debugfs_remove(gb->file);
 	list_del(&gb->entry);

commit 5f3e0d17a3938ee253b6e6b7d16033121645b3a4
Author: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
Date:   Mon Sep 14 10:48:41 2015 +0100

    greybus: loopback: exit kfree after mutex release
    
    init doesn't have a lock for kzalloc so exit shouldn't have lock with the
    corresponding kfree.
    
    Signed-off-by: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
    Reviewed-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/loopback.c b/drivers/staging/greybus/loopback.c
index 7e1f527e3aef..745490af7e47 100644
--- a/drivers/staging/greybus/loopback.c
+++ b/drivers/staging/greybus/loopback.c
@@ -955,8 +955,8 @@ static void gb_loopback_connection_exit(struct gb_connection *connection)
 	sysfs_remove_groups(&connection->dev.kobj, loopback_con_groups);
 	debugfs_remove(gb->file);
 	list_del(&gb->entry);
-	kfree(gb);
 	mutex_unlock(&gb_dev.mutex);
+	kfree(gb);
 }
 
 static struct gb_protocol loopback_protocol = {

commit 29f020290d8897e3ed6ed8a8f8938c0b8545bbcd
Author: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
Date:   Mon Sep 14 10:48:40 2015 +0100

    greybus: loopback: hold a coarse lock while init/exit run
    
    This patch holds gb_dev.mutex for the duration of init and exit to reduce
    complexity while ensuring that init and exit run atomically with respect
    to slave threads @ gb_loopback_fn().
    
    Signed-off-by: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
    Reviewed-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/loopback.c b/drivers/staging/greybus/loopback.c
index 33c21cf22687..7e1f527e3aef 100644
--- a/drivers/staging/greybus/loopback.c
+++ b/drivers/staging/greybus/loopback.c
@@ -864,21 +864,18 @@ static int gb_loopback_connection_init(struct gb_connection *connection)
 				    gb_dev.root, &gb_dev,
 				    &gb_loopback_debugfs_dev_latency_ops);
 		retval = sysfs_create_groups(kobj, loopback_dev_groups);
-		if (retval) {
-			mutex_unlock(&gb_dev.mutex);
+		if (retval)
 			goto out_sysfs;
-		}
+
 		/* Calculate maximum payload */
 		gb_dev.size_max = gb_operation_get_payload_size_max(connection);
 		if (gb_dev.size_max <=
 			sizeof(struct gb_loopback_transfer_request)) {
 			retval = -EINVAL;
-			mutex_unlock(&gb_dev.mutex);
 			goto out_sysfs;
 		}
 		gb_dev.size_max -= sizeof(struct gb_loopback_transfer_request);
 	}
-	mutex_unlock(&gb_dev.mutex);
 
 	/* Create per-connection sysfs and debugfs data-points */
 	snprintf(name, sizeof(name), "raw_latency_endo0:%d:%d:%d:%d",
@@ -916,10 +913,9 @@ static int gb_loopback_connection_init(struct gb_connection *connection)
 		goto out_kfifo1;
 	}
 
-	mutex_lock(&gb_dev.mutex);
 	list_add_tail(&gb->entry, &gb_dev.list);
-	mutex_unlock(&gb_dev.mutex);
 	gb_dev.count++;
+	mutex_unlock(&gb_dev.mutex);
 	return 0;
 
 out_kfifo1:
@@ -934,6 +930,7 @@ static int gb_loopback_connection_init(struct gb_connection *connection)
 	debugfs_remove(gb->file);
 	connection->private = NULL;
 out_sysfs:
+	mutex_unlock(&gb_dev.mutex);
 	kfree(gb);
 
 	return retval;

commit 6de00a5f32e09b58879175f2942ebeac699d3534
Author: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
Date:   Mon Sep 14 10:48:39 2015 +0100

    greybus: loopback: ensure count decrement happens before sysfs_remove_groups
    
    This patches fixes a case where gb_dev.count is decremented too late in the
    exit() routine.
    
    Signed-off-by: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
    Reported-by: Viresh Kumar <viresh.kumar@linaro.org>
    Reviewed-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/loopback.c b/drivers/staging/greybus/loopback.c
index 231d1d4c1104..33c21cf22687 100644
--- a/drivers/staging/greybus/loopback.c
+++ b/drivers/staging/greybus/loopback.c
@@ -952,14 +952,13 @@ static void gb_loopback_connection_exit(struct gb_connection *connection)
 	connection->private = NULL;
 	kfifo_free(&gb->kfifo_lat);
 	kfifo_free(&gb->kfifo_ts);
+	gb_dev.count--;
 	if (!gb_dev.count)
 		sysfs_remove_groups(kobj, loopback_dev_groups);
 	sysfs_remove_groups(&connection->dev.kobj, loopback_con_groups);
 	debugfs_remove(gb->file);
 	list_del(&gb->entry);
 	kfree(gb);
-	gb_dev.count--;
-
 	mutex_unlock(&gb_dev.mutex);
 }
 

commit ff477d073f2e71a1fa59f86cb44bd9d48674a71b
Author: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
Date:   Fri Sep 4 16:53:31 2015 +0100

    greybus: loopback: make sure to list_del on connection_exit
    
    gb_loopback_connection_exit does a kfree on a data structure associated
    with a loopback connection but fails to do a corresponding list_del(). On
    subsequent enumerations this can lead to a NULL pointer dereference. Each
    list_add in gb_loopback_connection_init() must have a corresponding
    list_del in gb_loopback_connection_exit(), this patch adds the relevant
    list_del() and ensures that an appropriate mutex protecting gb_dev.list is
    held while doing so.
    
    Signed-off-by: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
    Reported-by: Johan Hovold <johan@hovoldconsulting.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/loopback.c b/drivers/staging/greybus/loopback.c
index 8dd648cc0796..231d1d4c1104 100644
--- a/drivers/staging/greybus/loopback.c
+++ b/drivers/staging/greybus/loopback.c
@@ -944,18 +944,23 @@ static void gb_loopback_connection_exit(struct gb_connection *connection)
 	struct gb_loopback *gb = connection->private;
 	struct kobject *kobj = &connection->bundle->intf->module->dev.kobj;
 
-	gb_dev.count--;
-	connection->private = NULL;
 	if (!IS_ERR_OR_NULL(gb->task))
 		kthread_stop(gb->task);
 
+	mutex_lock(&gb_dev.mutex);
+
+	connection->private = NULL;
 	kfifo_free(&gb->kfifo_lat);
 	kfifo_free(&gb->kfifo_ts);
 	if (!gb_dev.count)
 		sysfs_remove_groups(kobj, loopback_dev_groups);
 	sysfs_remove_groups(&connection->dev.kobj, loopback_con_groups);
 	debugfs_remove(gb->file);
+	list_del(&gb->entry);
 	kfree(gb);
+	gb_dev.count--;
+
+	mutex_unlock(&gb_dev.mutex);
 }
 
 static struct gb_protocol loopback_protocol = {

commit 98676ca83680a2ca6afb38e900b3d956f6917185
Author: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
Date:   Mon Aug 17 00:55:12 2015 +0100

    greybus: loopback: fix typo in comment
    
    Alex previously post a patch to fix this typo. Somehow it fell through the
    cracks in the meantime. Do it again 'stastic' is a word 'statistic' is not.
    
    Signed-off-by: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/loopback.c b/drivers/staging/greybus/loopback.c
index 01bed4398826..8dd648cc0796 100644
--- a/drivers/staging/greybus/loopback.c
+++ b/drivers/staging/greybus/loopback.c
@@ -675,7 +675,7 @@ static void gb_loopback_calculate_stats(struct gb_loopback *gb)
 	/* Express latency in terms of microseconds */
 	lat = gb_loopback_nsec_to_usec_latency(gb->elapsed_nsecs);
 
-	/* Log latency statistic */
+	/* Log latency stastic */
 	gb_loopback_update_stats(&gb_dev.latency, lat);
 	gb_loopback_update_stats(&gb->latency, lat);
 

commit f06272b283e15951bae9b9af24cff74b7fcabaef
Author: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
Date:   Mon Aug 17 00:55:11 2015 +0100

    greybus: loopback: add module level sys/debug fs data points
    
    Code this far has used the first connection's sysfs entry to present
    variables intended to control the entire test - across multiple
    connections. This patch changes that so that the module level variables
    only appear at the end0:x level in sysfs.
    
    Example:
    
    Total counts for errors over the entire set of connections will be here
    /sys/bus/greybus/devices/endo0:x/error_dev
    
    In contrast an error for each connection will be presented like this
    /sys/bus/greybus/devices/endo0:x:y:z:w/error_con
    
    x = <module-id>
    y = <interface-id>
    z = <bundle-id>
    w = <cport-id>
    
    Signed-off-by: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/loopback.c b/drivers/staging/greybus/loopback.c
index 0a9bc9139109..01bed4398826 100644
--- a/drivers/staging/greybus/loopback.c
+++ b/drivers/staging/greybus/loopback.c
@@ -96,47 +96,68 @@ module_param(kfifo_depth, uint, 0444);
 #define GB_LOOPBACK_MS_WAIT_MAX				1000
 
 /* interface sysfs attributes */
-#define gb_loopback_ro_attr(field)					\
-static ssize_t field##_show(struct device *dev,				\
+#define gb_loopback_ro_attr(field, pfx, conn)				\
+static ssize_t field##_##pfx##_show(struct device *dev,			\
 			    struct device_attribute *attr,		\
 			    char *buf)					\
 {									\
-	struct gb_connection *connection = to_gb_connection(dev);	\
-	struct gb_loopback *gb = connection->private;			\
-	return sprintf(buf, "%u\n", gb->field);				\
+	struct gb_connection *connection;				\
+	struct gb_loopback *gb;						\
+	if (conn) {							\
+		connection = to_gb_connection(dev);			\
+		gb = connection->private;				\
+		return sprintf(buf, "%u\n", gb->field);			\
+	} else {							\
+		return sprintf(buf, "%u\n", gb_dev.field);		\
+	}								\
 }									\
-static DEVICE_ATTR_RO(field)
+static DEVICE_ATTR_RO(field##_##pfx)
 
-#define gb_loopback_ro_stats_attr(name, field, type)			\
-static ssize_t name##_##field##_show(struct device *dev,		\
+#define gb_loopback_ro_stats_attr(name, field, type, pfx, conn)		\
+static ssize_t name##_##field##_##pfx##_show(struct device *dev,	\
 			    struct device_attribute *attr,		\
 			    char *buf)					\
 {									\
-	struct gb_connection *connection = to_gb_connection(dev);	\
-	struct gb_loopback *gb = connection->private;			\
-	return sprintf(buf, "%"#type"\n", gb->name.field);		\
+	struct gb_connection *connection;				\
+	struct gb_loopback *gb;						\
+	if (conn) {							\
+		connection = to_gb_connection(dev);			\
+		gb = connection->private;				\
+		return sprintf(buf, "%"#type"\n", gb->name.field);	\
+	} else {							\
+		return sprintf(buf, "%"#type"\n", gb_dev.name.field);	\
+	}								\
 }									\
-static DEVICE_ATTR_RO(name##_##field)
+static DEVICE_ATTR_RO(name##_##field##_##pfx)
 
-#define gb_loopback_ro_avg_attr(name)					\
-static ssize_t name##_avg_show(struct device *dev,			\
+#define gb_loopback_ro_avg_attr(name, pfx, conn)			\
+static ssize_t name##_avg_##pfx##_show(struct device *dev,		\
 			    struct device_attribute *attr,		\
 			    char *buf)					\
 {									\
-	struct gb_connection *connection = to_gb_connection(dev);	\
-	struct gb_loopback *gb = connection->private;			\
-	struct gb_loopback_stats *stats = &gb->name;			\
-	u32 count = stats->count ? stats->count : 1;			\
-	u64 avg = stats->sum + count / 2;	/* round closest */	\
-	u32 rem = do_div(avg, count);					\
+	struct gb_loopback_stats *stats;				\
+	struct gb_connection *connection;				\
+	struct gb_loopback *gb;						\
+	u64 avg;							\
+	u32 count, rem;							\
+	if (conn) {							\
+		connection = to_gb_connection(dev);			\
+		gb = connection->private;				\
+		stats = &gb->name;					\
+	} else {							\
+		stats = &gb_dev.name;					\
+	}								\
+	count = stats->count ? stats->count : 1;			\
+	avg = stats->sum + count / 2;	/* round closest */		\
+	rem = do_div(avg, count);					\
 	return sprintf(buf, "%llu.%06u\n", avg, 1000000 * rem / count);	\
 }									\
-static DEVICE_ATTR_RO(name##_avg)
+static DEVICE_ATTR_RO(name##_avg_##pfx)
 
-#define gb_loopback_stats_attrs(field)					\
-	gb_loopback_ro_stats_attr(field, min, u);			\
-	gb_loopback_ro_stats_attr(field, max, u);			\
-	gb_loopback_ro_avg_attr(field);
+#define gb_loopback_stats_attrs(field, pfx, conn)			\
+	gb_loopback_ro_stats_attr(field, min, u, pfx, conn);		\
+	gb_loopback_ro_stats_attr(field, max, u, pfx, conn);		\
+	gb_loopback_ro_avg_attr(field, pfx, conn)
 
 #define gb_loopback_attr(field, type)					\
 static ssize_t field##_show(struct device *dev,				\
@@ -165,8 +186,8 @@ static ssize_t field##_store(struct device *dev,			\
 }									\
 static DEVICE_ATTR_RW(field)
 
-#define gb_dev_loopback_ro_attr(field)					\
-static ssize_t field##_show(struct device *dev,				\
+#define gb_dev_loopback_ro_attr(field, conn)				\
+static ssize_t field##_show(struct device *dev,		\
 			    struct device_attribute *attr,		\
 			    char *buf)					\
 {									\
@@ -241,15 +262,20 @@ static void gb_loopback_check_attr(struct gb_loopback_device *gb_dev,
 }
 
 /* Time to send and receive one message */
-gb_loopback_stats_attrs(latency);
+gb_loopback_stats_attrs(latency, dev, false);
+gb_loopback_stats_attrs(latency, con, true);
 /* Time to send and receive one message not including greybus */
-gb_loopback_stats_attrs(latency_gb);
+gb_loopback_stats_attrs(latency_gb, dev, false);
+gb_loopback_stats_attrs(latency_gb, con, true);
 /* Number of requests sent per second on this cport */
-gb_loopback_stats_attrs(requests_per_second);
+gb_loopback_stats_attrs(requests_per_second, dev, false);
+gb_loopback_stats_attrs(requests_per_second, con, true);
 /* Quantity of data sent and received on this cport */
-gb_loopback_stats_attrs(throughput);
+gb_loopback_stats_attrs(throughput, dev, false);
+gb_loopback_stats_attrs(throughput, con, true);
 /* Number of errors encountered during loop */
-gb_loopback_ro_attr(error);
+gb_loopback_ro_attr(error, dev, false);
+gb_loopback_ro_attr(error, con, true);
 
 /*
  * Type of loopback message to send based on protocol type definitions
@@ -267,33 +293,51 @@ gb_dev_loopback_rw_attr(ms_wait, d);
 /* Maximum iterations for a given operation: 1-(2^32-1), 0 implies infinite */
 gb_dev_loopback_rw_attr(iteration_max, u);
 /* The current index of the for (i = 0; i < iteration_max; i++) loop */
-gb_dev_loopback_ro_attr(iteration_count);
+gb_dev_loopback_ro_attr(iteration_count, false);
 /* A bit-mask of destination connecitons to include in the test run */
 gb_dev_loopback_rw_attr(mask, u);
 
-static struct attribute *loopback_attrs[] = {
-	&dev_attr_latency_min.attr,
-	&dev_attr_latency_max.attr,
-	&dev_attr_latency_avg.attr,
-	&dev_attr_latency_gb_min.attr,
-	&dev_attr_latency_gb_max.attr,
-	&dev_attr_latency_gb_avg.attr,
-	&dev_attr_requests_per_second_min.attr,
-	&dev_attr_requests_per_second_max.attr,
-	&dev_attr_requests_per_second_avg.attr,
-	&dev_attr_throughput_min.attr,
-	&dev_attr_throughput_max.attr,
-	&dev_attr_throughput_avg.attr,
+static struct attribute *loopback_dev_attrs[] = {
+	&dev_attr_latency_min_dev.attr,
+	&dev_attr_latency_max_dev.attr,
+	&dev_attr_latency_avg_dev.attr,
+	&dev_attr_latency_gb_min_dev.attr,
+	&dev_attr_latency_gb_max_dev.attr,
+	&dev_attr_latency_gb_avg_dev.attr,
+	&dev_attr_requests_per_second_min_dev.attr,
+	&dev_attr_requests_per_second_max_dev.attr,
+	&dev_attr_requests_per_second_avg_dev.attr,
+	&dev_attr_throughput_min_dev.attr,
+	&dev_attr_throughput_max_dev.attr,
+	&dev_attr_throughput_avg_dev.attr,
 	&dev_attr_type.attr,
 	&dev_attr_size.attr,
 	&dev_attr_ms_wait.attr,
 	&dev_attr_iteration_count.attr,
 	&dev_attr_iteration_max.attr,
 	&dev_attr_mask.attr,
-	&dev_attr_error.attr,
+	&dev_attr_error_dev.attr,
 	NULL,
 };
-ATTRIBUTE_GROUPS(loopback);
+ATTRIBUTE_GROUPS(loopback_dev);
+
+static struct attribute *loopback_con_attrs[] = {
+	&dev_attr_latency_min_con.attr,
+	&dev_attr_latency_max_con.attr,
+	&dev_attr_latency_avg_con.attr,
+	&dev_attr_latency_gb_min_con.attr,
+	&dev_attr_latency_gb_max_con.attr,
+	&dev_attr_latency_gb_avg_con.attr,
+	&dev_attr_requests_per_second_min_con.attr,
+	&dev_attr_requests_per_second_max_con.attr,
+	&dev_attr_requests_per_second_avg_con.attr,
+	&dev_attr_throughput_min_con.attr,
+	&dev_attr_throughput_max_con.attr,
+	&dev_attr_throughput_avg_con.attr,
+	&dev_attr_error_con.attr,
+	NULL,
+};
+ATTRIBUTE_GROUPS(loopback_con);
 
 static u32 gb_loopback_nsec_to_usec_latency(u64 elapsed_nsecs)
 {
@@ -776,6 +820,27 @@ static const struct file_operations gb_loopback_debugfs_latency_ops = {
 	.release	= single_release,
 };
 
+static int gb_loopback_dbgfs_dev_latency_show(struct seq_file *s, void *unused)
+{
+	struct gb_loopback_device *gb_dev = s->private;
+
+	return gb_loopback_dbgfs_latency_show_common(s, &gb_dev->kfifo,
+						     &gb_dev->mutex);
+}
+
+static int gb_loopback_dev_latency_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, gb_loopback_dbgfs_dev_latency_show,
+			   inode->i_private);
+}
+
+static const struct file_operations gb_loopback_debugfs_dev_latency_ops = {
+	.open		= gb_loopback_dev_latency_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+
 #define DEBUGFS_NAMELEN 32
 
 static int gb_loopback_connection_init(struct gb_connection *connection)
@@ -783,12 +848,39 @@ static int gb_loopback_connection_init(struct gb_connection *connection)
 	struct gb_loopback *gb;
 	int retval;
 	char name[DEBUGFS_NAMELEN];
+	struct kobject *kobj = &connection->bundle->intf->module->dev.kobj;
 
 	gb = kzalloc(sizeof(*gb), GFP_KERNEL);
 	if (!gb)
 		return -ENOMEM;
 	gb_loopback_reset_stats(&gb_dev);
 
+	/* If this is the first connection - create a module endo0:x entries */
+	mutex_lock(&gb_dev.mutex);
+	if (!gb_dev.count) {
+		snprintf(name, sizeof(name), "raw_latency_endo0:%d",
+			 connection->bundle->intf->module->module_id);
+		debugfs_create_file(name, S_IFREG | S_IRUGO,
+				    gb_dev.root, &gb_dev,
+				    &gb_loopback_debugfs_dev_latency_ops);
+		retval = sysfs_create_groups(kobj, loopback_dev_groups);
+		if (retval) {
+			mutex_unlock(&gb_dev.mutex);
+			goto out_sysfs;
+		}
+		/* Calculate maximum payload */
+		gb_dev.size_max = gb_operation_get_payload_size_max(connection);
+		if (gb_dev.size_max <=
+			sizeof(struct gb_loopback_transfer_request)) {
+			retval = -EINVAL;
+			mutex_unlock(&gb_dev.mutex);
+			goto out_sysfs;
+		}
+		gb_dev.size_max -= sizeof(struct gb_loopback_transfer_request);
+	}
+	mutex_unlock(&gb_dev.mutex);
+
+	/* Create per-connection sysfs and debugfs data-points */
 	snprintf(name, sizeof(name), "raw_latency_endo0:%d:%d:%d:%d",
 		connection->bundle->intf->module->module_id,
 		connection->bundle->intf->interface_id,
@@ -798,25 +890,16 @@ static int gb_loopback_connection_init(struct gb_connection *connection)
 				       &gb_loopback_debugfs_latency_ops);
 	gb->connection = connection;
 	connection->private = gb;
-	retval = sysfs_create_groups(&connection->dev.kobj, loopback_groups);
+	retval = sysfs_create_groups(&connection->dev.kobj,
+				     loopback_con_groups);
 	if (retval)
-		goto out_debugfs;
-
-	/* Calculate maximum payload */
-	mutex_lock(&gb_dev.mutex);
-	gb_dev.size_max = gb_operation_get_payload_size_max(connection);
-	if (gb_dev.size_max <= sizeof(struct gb_loopback_transfer_request)) {
-		retval = -EINVAL;
-		goto out_sysfs;
-	}
-	gb_dev.size_max -= sizeof(struct gb_loopback_transfer_request);
-	mutex_unlock(&gb_dev.mutex);
+		goto out_sysfs_dev;
 
 	/* Allocate kfifo */
 	if (kfifo_alloc(&gb->kfifo_lat, kfifo_depth * sizeof(u32),
 			  GFP_KERNEL)) {
 		retval = -ENOMEM;
-		goto out_sysfs;
+		goto out_sysfs_conn;
 	}
 	if (kfifo_alloc(&gb->kfifo_ts, kfifo_depth * sizeof(struct timeval) * 2,
 			  GFP_KERNEL)) {
@@ -843,11 +926,14 @@ static int gb_loopback_connection_init(struct gb_connection *connection)
 	kfifo_free(&gb->kfifo_ts);
 out_kfifo0:
 	kfifo_free(&gb->kfifo_lat);
-out_sysfs:
-	sysfs_remove_groups(&connection->dev.kobj, loopback_groups);
-out_debugfs:
+out_sysfs_conn:
+	sysfs_remove_groups(&connection->dev.kobj, loopback_con_groups);
+out_sysfs_dev:
+	if (!gb_dev.count)
+		sysfs_remove_groups(kobj, loopback_dev_groups);
 	debugfs_remove(gb->file);
 	connection->private = NULL;
+out_sysfs:
 	kfree(gb);
 
 	return retval;
@@ -856,6 +942,7 @@ static int gb_loopback_connection_init(struct gb_connection *connection)
 static void gb_loopback_connection_exit(struct gb_connection *connection)
 {
 	struct gb_loopback *gb = connection->private;
+	struct kobject *kobj = &connection->bundle->intf->module->dev.kobj;
 
 	gb_dev.count--;
 	connection->private = NULL;
@@ -864,7 +951,9 @@ static void gb_loopback_connection_exit(struct gb_connection *connection)
 
 	kfifo_free(&gb->kfifo_lat);
 	kfifo_free(&gb->kfifo_ts);
-	sysfs_remove_groups(&connection->dev.kobj, loopback_groups);
+	if (!gb_dev.count)
+		sysfs_remove_groups(kobj, loopback_dev_groups);
+	sysfs_remove_groups(&connection->dev.kobj, loopback_con_groups);
 	debugfs_remove(gb->file);
 	kfree(gb);
 }
@@ -879,27 +968,6 @@ static struct gb_protocol loopback_protocol = {
 	.request_recv		= gb_loopback_request_recv,
 };
 
-static int gb_loopback_dbgfs_dev_latency_show(struct seq_file *s, void *unused)
-{
-	struct gb_loopback_device *gb_dev = s->private;
-
-	return gb_loopback_dbgfs_latency_show_common(s, &gb_dev->kfifo,
-						     &gb_dev->mutex);
-}
-
-static int gb_loopback_dev_latency_open(struct inode *inode, struct file *file)
-{
-	return single_open(file, gb_loopback_dbgfs_dev_latency_show,
-			   inode->i_private);
-}
-
-static const struct file_operations gb_loopback_debugfs_dev_latency_ops = {
-	.open		= gb_loopback_dev_latency_open,
-	.read		= seq_read,
-	.llseek		= seq_lseek,
-	.release	= single_release,
-};
-
 static int loopback_init(void)
 {
 	int retval;
@@ -914,9 +982,6 @@ static int loopback_init(void)
 		goto error_debugfs;
 	}
 
-	debugfs_create_file("aggregate_latency", S_IFREG | S_IRUGO,
-			    gb_dev.root, &gb_dev,
-			    &gb_loopback_debugfs_dev_latency_ops);
 	retval = gb_protocol_register(&loopback_protocol);
 	if (!retval)
 		return retval;

commit a5a0ba4318aafaa0686893ba62b2ab34598d88c7
Author: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
Date:   Mon Aug 17 00:55:10 2015 +0100

    greybus: loopback: remove checkpatch error causing macro
    
    checkpatch.pl is choking on a later change to dev_stats_attrs, where
    checkpatch expects to see the values encapsulated in curly brackets.
    Encapsulating in curly brackets will cause a compiler error. To resolve the
    dichotomy this patch drops the macros and adds the arrary declarations
    directly.
    
    Signed-off-by: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/loopback.c b/drivers/staging/greybus/loopback.c
index ff2e79212877..0a9bc9139109 100644
--- a/drivers/staging/greybus/loopback.c
+++ b/drivers/staging/greybus/loopback.c
@@ -271,16 +271,19 @@ gb_dev_loopback_ro_attr(iteration_count);
 /* A bit-mask of destination connecitons to include in the test run */
 gb_dev_loopback_rw_attr(mask, u);
 
-#define dev_stats_attrs(name)						\
-	&dev_attr_##name##_min.attr,					\
-	&dev_attr_##name##_max.attr,					\
-	&dev_attr_##name##_avg.attr
-
 static struct attribute *loopback_attrs[] = {
-	dev_stats_attrs(latency),
-	dev_stats_attrs(latency_gb),
-	dev_stats_attrs(requests_per_second),
-	dev_stats_attrs(throughput),
+	&dev_attr_latency_min.attr,
+	&dev_attr_latency_max.attr,
+	&dev_attr_latency_avg.attr,
+	&dev_attr_latency_gb_min.attr,
+	&dev_attr_latency_gb_max.attr,
+	&dev_attr_latency_gb_avg.attr,
+	&dev_attr_requests_per_second_min.attr,
+	&dev_attr_requests_per_second_max.attr,
+	&dev_attr_requests_per_second_avg.attr,
+	&dev_attr_throughput_min.attr,
+	&dev_attr_throughput_max.attr,
+	&dev_attr_throughput_avg.attr,
 	&dev_attr_type.attr,
 	&dev_attr_size.attr,
 	&dev_attr_ms_wait.attr,

commit 42b9da5efe63e42298094a23edf00d2e0830812c
Author: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
Date:   Mon Aug 17 00:55:09 2015 +0100

    greybus: loopback: initialized ms_wait negate warning
    
    ms_wait = 0; caught by a compiler warning.
    
    Signed-off-by: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/loopback.c b/drivers/staging/greybus/loopback.c
index b362635d8a54..ff2e79212877 100644
--- a/drivers/staging/greybus/loopback.c
+++ b/drivers/staging/greybus/loopback.c
@@ -649,7 +649,7 @@ static void gb_loopback_calculate_stats(struct gb_loopback *gb)
 static int gb_loopback_fn(void *data)
 {
 	int error = 0;
-	int ms_wait;
+	int ms_wait = 0;
 	int type;
 	u32 size;
 	u32 low_count;

commit 84cfad02b7d9ee0ec910a40aa96850c337a0d745
Author: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
Date:   Mon Aug 17 00:55:08 2015 +0100

    greybus: loopback: add bitmask of connections to include in test
    
    Feature add which enables the ability to select a bit-mask of connections
    to run when executing a loopback test set. This is a feature add to
    facilitate testing on the firmware side minus the necessity to recompile
    firmware to support unicast (v) multicast (v) bitmask.
    
    Signed-off-by: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/loopback.c b/drivers/staging/greybus/loopback.c
index 0d2de708ec0b..b362635d8a54 100644
--- a/drivers/staging/greybus/loopback.c
+++ b/drivers/staging/greybus/loopback.c
@@ -42,6 +42,7 @@ struct gb_loopback_device {
 	wait_queue_head_t wq;
 
 	int type;
+	u32 mask;
 	u32 size;
 	u32 iteration_max;
 	u32 iteration_count;
@@ -267,6 +268,8 @@ gb_dev_loopback_rw_attr(ms_wait, d);
 gb_dev_loopback_rw_attr(iteration_max, u);
 /* The current index of the for (i = 0; i < iteration_max; i++) loop */
 gb_dev_loopback_ro_attr(iteration_count);
+/* A bit-mask of destination connecitons to include in the test run */
+gb_dev_loopback_rw_attr(mask, u);
 
 #define dev_stats_attrs(name)						\
 	&dev_attr_##name##_min.attr,					\
@@ -283,6 +286,7 @@ static struct attribute *loopback_attrs[] = {
 	&dev_attr_ms_wait.attr,
 	&dev_attr_iteration_count.attr,
 	&dev_attr_iteration_max.attr,
+	&dev_attr_mask.attr,
 	&dev_attr_error.attr,
 	NULL,
 };
@@ -322,6 +326,11 @@ static void gb_loopback_push_latency_ts(struct gb_loopback *gb,
 	kfifo_in(&gb->kfifo_ts, (unsigned char *)te, sizeof(*te));
 }
 
+static int gb_loopback_active(struct gb_loopback *gb)
+{
+	return (gb_dev.mask == 0 || (gb_dev.mask & gb->lbid));
+}
+
 static int gb_loopback_sink(struct gb_loopback *gb, u32 len)
 {
 	struct timeval ts, te;
@@ -574,6 +583,8 @@ static int gb_loopback_calculate_aggregate_stats(void)
 		ts_min = 0;
 		te_max = 0;
 		list_for_each_entry(gb, &gb_dev.list, entry) {
+			if (!gb_loopback_active(gb))
+				continue;
 			if (kfifo_out(&gb->kfifo_ts, &ts, sizeof(ts)) < sizeof(ts))
 				goto error;
 			if (kfifo_out(&gb->kfifo_ts, &te, sizeof(te)) < sizeof(te))
@@ -653,10 +664,14 @@ static int gb_loopback_fn(void *data)
 			break;
 
 		mutex_lock(&gb_dev.mutex);
+		if (!gb_loopback_active(gb))
+			goto unlock_continue;
 		if (gb_dev.iteration_max) {
 			/* Determine overall lowest count */
 			low_count = gb->iteration_count;
 			list_for_each_entry(gb_list, &gb_dev.list, entry) {
+				if (!gb_loopback_active(gb_list))
+					continue;
 				if (gb_list->iteration_count < low_count)
 					low_count = gb_list->iteration_count;
 			}
@@ -670,8 +685,7 @@ static int gb_loopback_fn(void *data)
 			if (gb_dev.iteration_count == gb_dev.iteration_max) {
 				gb_loopback_calculate_aggregate_stats();
 				gb_dev.type = 0;
-				mutex_unlock(&gb_dev.mutex);
-				continue;
+				goto unlock_continue;
 			}
 		}
 		size = gb_dev.size;
@@ -706,6 +720,7 @@ static int gb_loopback_fn(void *data)
 		gb->iteration_count++;
 
 		mutex_unlock(&gb->mutex);
+unlock_continue:
 		mutex_unlock(&gb_dev.mutex);
 sleep:
 		if (ms_wait)

commit 4b0ea00caf837160b25482d48d1f7a95ba47d318
Author: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
Date:   Mon Aug 17 00:55:07 2015 +0100

    greybus: loopback: graph round-trip time for all threads
    
    This patch adds the ability to time the delta between all threads like this
    
    t1 = timestmap();
    thread1:gb_operation_sync();
    thread2:gb_operation_sync();
    t2 = timestamp();
    
    In order to enable that behaviour without forcing an undesirable
    checkpointing scheme this patch introduces a kfifo for each thread to store
    the raw timestamps and calculate a time difference.
    
    Signed-off-by: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/loopback.c b/drivers/staging/greybus/loopback.c
index 39375f1e0d8e..0d2de708ec0b 100644
--- a/drivers/staging/greybus/loopback.c
+++ b/drivers/staging/greybus/loopback.c
@@ -36,6 +36,7 @@ struct gb_loopback_device {
 	struct dentry *root;
 	u32 count;
 
+	struct kfifo kfifo;
 	struct mutex mutex;
 	struct list_head list;
 	wait_queue_head_t wq;
@@ -64,7 +65,8 @@ struct gb_loopback {
 	struct gb_connection *connection;
 
 	struct dentry *file;
-	struct kfifo kfifo;
+	struct kfifo kfifo_lat;
+	struct kfifo kfifo_ts;
 	struct mutex mutex;
 	struct task_struct *task;
 	struct list_head entry;
@@ -75,6 +77,7 @@ struct gb_loopback {
 	struct gb_loopback_stats throughput;
 	struct gb_loopback_stats requests_per_second;
 
+	u32 lbid;
 	u32 iteration_count;
 	u64 elapsed_nsecs;
 	u64 elapsed_nsecs_gb;
@@ -217,7 +220,8 @@ static void gb_loopback_check_attr(struct gb_loopback_device *gb_dev,
 				 "cannot log bytes %u kfifo_depth %u\n",
 				 gb_dev->iteration_max, kfifo_depth);
 		}
-		kfifo_reset_out(&gb->kfifo);
+		kfifo_reset_out(&gb->kfifo_lat);
+		kfifo_reset_out(&gb->kfifo_ts);
 		mutex_unlock(&gb->mutex);
 	}
 
@@ -225,6 +229,7 @@ static void gb_loopback_check_attr(struct gb_loopback_device *gb_dev,
 	case GB_LOOPBACK_TYPE_PING:
 	case GB_LOOPBACK_TYPE_TRANSFER:
 	case GB_LOOPBACK_TYPE_SINK:
+		kfifo_reset_out(&gb_dev->kfifo);
 		gb_loopback_reset_stats(gb_dev);
 		wake_up(&gb_dev->wq);
 		break;
@@ -310,6 +315,13 @@ static u64 gb_loopback_calc_latency(struct timeval *ts, struct timeval *te)
 	return __gb_loopback_calc_latency(t1, t2);
 }
 
+static void gb_loopback_push_latency_ts(struct gb_loopback *gb,
+					struct timeval *ts, struct timeval *te)
+{
+	kfifo_in(&gb->kfifo_ts, (unsigned char *)ts, sizeof(*ts));
+	kfifo_in(&gb->kfifo_ts, (unsigned char *)te, sizeof(*te));
+}
+
 static int gb_loopback_sink(struct gb_loopback *gb, u32 len)
 {
 	struct timeval ts, te;
@@ -329,6 +341,7 @@ static int gb_loopback_sink(struct gb_loopback *gb, u32 len)
 	do_gettimeofday(&te);
 
 	/* Calculate the total time the message took */
+	gb_loopback_push_latency_ts(gb, &ts, &te);
 	gb->elapsed_nsecs = gb_loopback_calc_latency(&ts, &te);
 
 	/* Calculate non-greybus related component of the latency */
@@ -368,6 +381,7 @@ static int gb_loopback_transfer(struct gb_loopback *gb, u32 len)
 	do_gettimeofday(&te);
 
 	/* Calculate the total time the message took */
+	gb_loopback_push_latency_ts(gb, &ts, &te);
 	gb->elapsed_nsecs = gb_loopback_calc_latency(&ts, &te);
 
 	/* Calculate non-greybus related component of the latency */
@@ -401,6 +415,7 @@ static int gb_loopback_ping(struct gb_loopback *gb)
 	do_gettimeofday(&te);
 
 	/* Calculate the total time the message took */
+	gb_loopback_push_latency_ts(gb, &ts, &te);
 	gb->elapsed_nsecs = gb_loopback_calc_latency(&ts, &te);
 
 	/* Calculate non-greybus related component of the latency */
@@ -541,6 +556,59 @@ static void gb_loopback_throughput_update(struct gb_loopback *gb, u32 latency)
 	gb_loopback_update_stats(&gb->throughput, throughput);
 }
 
+static int gb_loopback_calculate_aggregate_stats(void)
+{
+	struct gb_loopback *gb;
+	struct timeval ts;
+	struct timeval te;
+	u64 t1, t2;
+	u64 ts_min;
+	u64 te_max;
+	u64 elapsed_nsecs;
+	u32 lat;
+	int i, latched;
+	int rollover = 0;
+
+	for (i = 0; i < gb_dev.iteration_max; i++) {
+		latched = 0;
+		ts_min = 0;
+		te_max = 0;
+		list_for_each_entry(gb, &gb_dev.list, entry) {
+			if (kfifo_out(&gb->kfifo_ts, &ts, sizeof(ts)) < sizeof(ts))
+				goto error;
+			if (kfifo_out(&gb->kfifo_ts, &te, sizeof(te)) < sizeof(te))
+				goto error;
+			t1 = timeval_to_ns(&ts);
+			t2 = timeval_to_ns(&te);
+
+			/* minimum timestamp is always what we want */
+			if (latched == 0 || t1 < ts_min)
+				ts_min = t1;
+
+			/* maximum timestamp needs to handle rollover */
+			if (t2 > t1) {
+				if (latched == 0 || t2 > te_max)
+					te_max = t2;
+			} else {
+				if (latched == 0 || rollover == 0)
+					te_max = t2;
+				if (rollover == 1 && t2 > te_max)
+					te_max = t2;
+				rollover = 1;
+			}
+			latched = 1;
+		}
+		/* Calculate the aggregate timestamp */
+		elapsed_nsecs = __gb_loopback_calc_latency(ts_min, te_max);
+		lat = gb_loopback_nsec_to_usec_latency(elapsed_nsecs);
+		kfifo_in(&gb_dev.kfifo, (unsigned char *)&lat, sizeof(lat));
+	}
+	return 0;
+error:
+	kfifo_reset_out(&gb_dev.kfifo);
+	return -ENOMEM;
+}
+
 static void gb_loopback_calculate_stats(struct gb_loopback *gb)
 {
 	u32 lat;
@@ -554,7 +622,7 @@ static void gb_loopback_calculate_stats(struct gb_loopback *gb)
 	gb_loopback_update_stats(&gb->latency, lat);
 
 	/* Raw latency log on a per thread basis */
-	kfifo_in(&gb->kfifo, (unsigned char *)&lat, sizeof(lat));
+	kfifo_in(&gb->kfifo_lat, (unsigned char *)&lat, sizeof(lat));
 
 	/* Log throughput and requests using latency as benchmark */
 	gb_loopback_throughput_update(gb, lat);
@@ -600,6 +668,7 @@ static int gb_loopback_fn(void *data)
 			}
 			/* Optionally terminate */
 			if (gb_dev.iteration_count == gb_dev.iteration_max) {
+				gb_loopback_calculate_aggregate_stats();
 				gb_dev.type = 0;
 				mutex_unlock(&gb_dev.mutex);
 				continue;
@@ -645,28 +714,37 @@ static int gb_loopback_fn(void *data)
 	return 0;
 }
 
-static int gb_loopback_dbgfs_latency_show(struct seq_file *s, void *unused)
+static int gb_loopback_dbgfs_latency_show_common(struct seq_file *s,
+						 struct kfifo *kfifo,
+						 struct mutex *mutex)
 {
-	struct gb_loopback *gb = s->private;
 	u32 latency;
 	int retval;
 
-	if (kfifo_len(&gb->kfifo) == 0) {
+	if (kfifo_len(kfifo) == 0) {
 		retval = -EAGAIN;
 		goto done;
 	}
 
-	mutex_lock(&gb->mutex);
-	retval = kfifo_out(&gb->kfifo, &latency, sizeof(latency));
+	mutex_lock(mutex);
+	retval = kfifo_out(kfifo, &latency, sizeof(latency));
 	if (retval > 0) {
 		seq_printf(s, "%u", latency);
 		retval = 0;
 	}
-	mutex_unlock(&gb->mutex);
+	mutex_unlock(mutex);
 done:
 	return retval;
 }
 
+static int gb_loopback_dbgfs_latency_show(struct seq_file *s, void *unused)
+{
+	struct gb_loopback *gb = s->private;
+
+	return gb_loopback_dbgfs_latency_show_common(s, &gb->kfifo_lat,
+						     &gb->mutex);
+}
+
 static int gb_loopback_latency_open(struct inode *inode, struct file *file)
 {
 	return single_open(file, gb_loopback_dbgfs_latency_show,
@@ -717,18 +795,24 @@ static int gb_loopback_connection_init(struct gb_connection *connection)
 	mutex_unlock(&gb_dev.mutex);
 
 	/* Allocate kfifo */
-	if (kfifo_alloc(&gb->kfifo, kfifo_depth * sizeof(u32),
+	if (kfifo_alloc(&gb->kfifo_lat, kfifo_depth * sizeof(u32),
 			  GFP_KERNEL)) {
 		retval = -ENOMEM;
 		goto out_sysfs;
 	}
+	if (kfifo_alloc(&gb->kfifo_ts, kfifo_depth * sizeof(struct timeval) * 2,
+			  GFP_KERNEL)) {
+		retval = -ENOMEM;
+		goto out_kfifo0;
+	}
 
 	/* Fork worker thread */
 	mutex_init(&gb->mutex);
+	gb->lbid = 1 << gb_dev.count;
 	gb->task = kthread_run(gb_loopback_fn, gb, "gb_loopback");
 	if (IS_ERR(gb->task)) {
 		retval = PTR_ERR(gb->task);
-		goto out_kfifo;
+		goto out_kfifo1;
 	}
 
 	mutex_lock(&gb_dev.mutex);
@@ -737,8 +821,10 @@ static int gb_loopback_connection_init(struct gb_connection *connection)
 	gb_dev.count++;
 	return 0;
 
-out_kfifo:
-	kfifo_free(&gb->kfifo);
+out_kfifo1:
+	kfifo_free(&gb->kfifo_ts);
+out_kfifo0:
+	kfifo_free(&gb->kfifo_lat);
 out_sysfs:
 	sysfs_remove_groups(&connection->dev.kobj, loopback_groups);
 out_debugfs:
@@ -758,7 +844,8 @@ static void gb_loopback_connection_exit(struct gb_connection *connection)
 	if (!IS_ERR_OR_NULL(gb->task))
 		kthread_stop(gb->task);
 
-	kfifo_free(&gb->kfifo);
+	kfifo_free(&gb->kfifo_lat);
+	kfifo_free(&gb->kfifo_ts);
 	sysfs_remove_groups(&connection->dev.kobj, loopback_groups);
 	debugfs_remove(gb->file);
 	kfree(gb);
@@ -774,20 +861,58 @@ static struct gb_protocol loopback_protocol = {
 	.request_recv		= gb_loopback_request_recv,
 };
 
+static int gb_loopback_dbgfs_dev_latency_show(struct seq_file *s, void *unused)
+{
+	struct gb_loopback_device *gb_dev = s->private;
+
+	return gb_loopback_dbgfs_latency_show_common(s, &gb_dev->kfifo,
+						     &gb_dev->mutex);
+}
+
+static int gb_loopback_dev_latency_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, gb_loopback_dbgfs_dev_latency_show,
+			   inode->i_private);
+}
+
+static const struct file_operations gb_loopback_debugfs_dev_latency_ops = {
+	.open		= gb_loopback_dev_latency_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+
 static int loopback_init(void)
 {
+	int retval;
+
 	init_waitqueue_head(&gb_dev.wq);
 	INIT_LIST_HEAD(&gb_dev.list);
 	mutex_init(&gb_dev.mutex);
 	gb_dev.root = debugfs_create_dir("gb_loopback", NULL);
 
-	return gb_protocol_register(&loopback_protocol);
+	if (kfifo_alloc(&gb_dev.kfifo, kfifo_depth * sizeof(u32), GFP_KERNEL)) {
+		retval = -ENOMEM;
+		goto error_debugfs;
+	}
+
+	debugfs_create_file("aggregate_latency", S_IFREG | S_IRUGO,
+			    gb_dev.root, &gb_dev,
+			    &gb_loopback_debugfs_dev_latency_ops);
+	retval = gb_protocol_register(&loopback_protocol);
+	if (!retval)
+		return retval;
+
+error_debugfs:
+	debugfs_remove_recursive(gb_dev.root);
+	return retval;
 }
 module_init(loopback_init);
 
 static void __exit loopback_exit(void)
 {
 	debugfs_remove_recursive(gb_dev.root);
+	kfifo_free(&gb_dev.kfifo);
 	gb_protocol_deregister(&loopback_protocol);
 }
 module_exit(loopback_exit);

commit 7c985351d40475ab752b230d5761e646973cb59b
Author: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
Date:   Mon Aug 17 00:55:06 2015 +0100

    greybus: loopback: functionally decompose gb_loopback_calc_latency
    
    The __gb_loopback_calc_latency will be useful in later patches. Provide it
    here and use as intended. Later on we just want to use the timestamp
    rollover detection, so split it out now.
    
    Signed-off-by: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/loopback.c b/drivers/staging/greybus/loopback.c
index 4879edda982a..39375f1e0d8e 100644
--- a/drivers/staging/greybus/loopback.c
+++ b/drivers/staging/greybus/loopback.c
@@ -292,16 +292,22 @@ static u32 gb_loopback_nsec_to_usec_latency(u64 elapsed_nsecs)
 	return lat;
 }
 
+static u64 __gb_loopback_calc_latency(u64 t1, u64 t2)
+{
+	if (t2 > t1)
+		return t2 - t1;
+	else
+		return NSEC_PER_DAY - t2 + t1;
+}
+
 static u64 gb_loopback_calc_latency(struct timeval *ts, struct timeval *te)
 {
 	u64 t1, t2;
 
 	t1 = timeval_to_ns(ts);
 	t2 = timeval_to_ns(te);
-	if (t2 > t1)
-		return t2 - t1;
-	else
-		return NSEC_PER_DAY - t2 + t1;
+
+	return __gb_loopback_calc_latency(t1, t2);
 }
 
 static int gb_loopback_sink(struct gb_loopback *gb, u32 len)

commit bd416103b204494e29b095e28c5a7b6a77e8f2b9
Author: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
Date:   Mon Aug 17 00:55:05 2015 +0100

    greybus: loopback: add gb_loopback_nsec_to_usec_latency
    
    A helper function to convert from a nanosecond value to a latency value
    expressed in mircoseconds. This will be used again in subsequent patches.
    
    Signed-off-by: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/loopback.c b/drivers/staging/greybus/loopback.c
index b46ded22b533..4879edda982a 100644
--- a/drivers/staging/greybus/loopback.c
+++ b/drivers/staging/greybus/loopback.c
@@ -283,6 +283,15 @@ static struct attribute *loopback_attrs[] = {
 };
 ATTRIBUTE_GROUPS(loopback);
 
+static u32 gb_loopback_nsec_to_usec_latency(u64 elapsed_nsecs)
+{
+	u32 lat;
+
+	do_div(elapsed_nsecs, NSEC_PER_USEC);
+	lat = elapsed_nsecs;
+	return lat;
+}
+
 static u64 gb_loopback_calc_latency(struct timeval *ts, struct timeval *te)
 {
 	u64 t1, t2;
@@ -532,9 +541,7 @@ static void gb_loopback_calculate_stats(struct gb_loopback *gb)
 	u64 tmp;
 
 	/* Express latency in terms of microseconds */
-	tmp = gb->elapsed_nsecs;
-	do_div(tmp, NSEC_PER_USEC);
-	lat = tmp;
+	lat = gb_loopback_nsec_to_usec_latency(gb->elapsed_nsecs);
 
 	/* Log latency statistic */
 	gb_loopback_update_stats(&gb_dev.latency, lat);

commit 67d1eeceb1aab4a192a0f132cd230d41932ba91e
Author: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
Date:   Mon Aug 17 00:55:04 2015 +0100

    greybus: loopback: support synchronized tests over multiple cports
    
    The loopback code as currently implemented allows free running threads to
    blast data to cports in isolation, however no overall stastics are gathered
    for the aggregate throughput to a given module.
    
    This patch moves derivation of stastics for all cports to one structure
    so that 1 to n cports will report their overall stastics in one place.
    Later patches update the sysfs/debugfs accessor functions to provide the
    per-module and per-connection data separately.
    
    Signed-off-by: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/loopback.c b/drivers/staging/greybus/loopback.c
index 5f66048927a7..b46ded22b533 100644
--- a/drivers/staging/greybus/loopback.c
+++ b/drivers/staging/greybus/loopback.c
@@ -35,6 +35,27 @@ struct gb_loopback_stats {
 struct gb_loopback_device {
 	struct dentry *root;
 	u32 count;
+
+	struct mutex mutex;
+	struct list_head list;
+	wait_queue_head_t wq;
+
+	int type;
+	u32 size;
+	u32 iteration_max;
+	u32 iteration_count;
+	size_t size_max;
+	int ms_wait;
+	u32 error;
+
+	struct timeval start;
+	struct timeval end;
+
+	/* Overall stats */
+	struct gb_loopback_stats latency;
+	struct gb_loopback_stats latency_gb;
+	struct gb_loopback_stats throughput;
+	struct gb_loopback_stats requests_per_second;
 };
 
 static struct gb_loopback_device gb_dev;
@@ -46,19 +67,15 @@ struct gb_loopback {
 	struct kfifo kfifo;
 	struct mutex mutex;
 	struct task_struct *task;
-	wait_queue_head_t wq;
-
-	int type;
-	u32 size;
-	u32 iteration_max;
-	u32 iteration_count;
-	size_t size_max;
-	int ms_wait;
+	struct list_head entry;
 
+	/* Per connection stats */
 	struct gb_loopback_stats latency;
 	struct gb_loopback_stats latency_gb;
 	struct gb_loopback_stats throughput;
 	struct gb_loopback_stats requests_per_second;
+
+	u32 iteration_count;
 	u64 elapsed_nsecs;
 	u64 elapsed_nsecs_gb;
 	u32 error;
@@ -133,45 +150,86 @@ static ssize_t field##_store(struct device *dev,			\
 {									\
 	int ret;							\
 	struct gb_connection *connection = to_gb_connection(dev);	\
-	struct gb_loopback *gb = connection->private;			\
-	mutex_lock(&gb->mutex);						\
+	mutex_lock(&gb_dev.mutex);					\
 	ret = sscanf(buf, "%"#type, &gb->field);			\
 	if (ret != 1)							\
 		len = -EINVAL;						\
 	else								\
-		gb_loopback_check_attr(connection, gb);			\
-	mutex_unlock(&gb->mutex);					\
+		gb_loopback_check_attr(connection);			\
+	mutex_unlock(&gb_dev.mutex);					\
 	return len;							\
 }									\
 static DEVICE_ATTR_RW(field)
 
-static void gb_loopback_reset_stats(struct gb_loopback *gb);
-static void gb_loopback_check_attr(struct gb_connection *connection,
-				   struct gb_loopback *gb)
+#define gb_dev_loopback_ro_attr(field)					\
+static ssize_t field##_show(struct device *dev,				\
+			    struct device_attribute *attr,		\
+			    char *buf)					\
+{									\
+	return sprintf(buf, "%u\n", gb_dev.field);			\
+}									\
+static DEVICE_ATTR_RO(field)
+
+#define gb_dev_loopback_rw_attr(field, type)				\
+static ssize_t field##_show(struct device *dev,				\
+			    struct device_attribute *attr,		\
+			    char *buf)					\
+{									\
+	return sprintf(buf, "%"#type"\n", gb_dev.field);		\
+}									\
+static ssize_t field##_store(struct device *dev,			\
+			    struct device_attribute *attr,		\
+			    const char *buf,				\
+			    size_t len)					\
+{									\
+	int ret;							\
+	struct gb_connection *connection = to_gb_connection(dev);	\
+	mutex_lock(&gb_dev.mutex);					\
+	ret = sscanf(buf, "%"#type, &gb_dev.field);			\
+	if (ret != 1)							\
+		len = -EINVAL;						\
+	else								\
+		gb_loopback_check_attr(&gb_dev, connection);		\
+	mutex_unlock(&gb_dev.mutex);					\
+	return len;							\
+}									\
+static DEVICE_ATTR_RW(field)
+
+static void gb_loopback_reset_stats(struct gb_loopback_device *gb_dev);
+static void gb_loopback_check_attr(struct gb_loopback_device *gb_dev,
+				   struct gb_connection *connection)
 {
-	if (gb->ms_wait > GB_LOOPBACK_MS_WAIT_MAX)
-		gb->ms_wait = GB_LOOPBACK_MS_WAIT_MAX;
-	if (gb->size > gb->size_max)
-		gb->size = gb->size_max;
-	gb->error = 0;
-	gb->iteration_count = 0;
-	gb_loopback_reset_stats(gb);
-
-	if (kfifo_depth < gb->iteration_max) {
-		dev_warn(&connection->dev,
-			 "iteration_max %u kfifo_depth %u cannot log all data\n",
-			 gb->iteration_max, kfifo_depth);
+	struct gb_loopback *gb;
+
+	if (gb_dev->ms_wait > GB_LOOPBACK_MS_WAIT_MAX)
+		gb_dev->ms_wait = GB_LOOPBACK_MS_WAIT_MAX;
+	if (gb_dev->size > gb_dev->size_max)
+		gb_dev->size = gb_dev->size_max;
+	gb_dev->iteration_count = 0;
+	gb_dev->error = 0;
+
+	list_for_each_entry(gb, &gb_dev->list, entry) {
+		mutex_lock(&gb->mutex);
+		gb->iteration_count = 0;
+		gb->error = 0;
+		if (kfifo_depth < gb_dev->iteration_max) {
+			dev_warn(&connection->dev,
+				 "cannot log bytes %u kfifo_depth %u\n",
+				 gb_dev->iteration_max, kfifo_depth);
+		}
+		kfifo_reset_out(&gb->kfifo);
+		mutex_unlock(&gb->mutex);
 	}
 
-	switch (gb->type) {
+	switch (gb_dev->type) {
 	case GB_LOOPBACK_TYPE_PING:
 	case GB_LOOPBACK_TYPE_TRANSFER:
 	case GB_LOOPBACK_TYPE_SINK:
-		kfifo_reset_out(&gb->kfifo);
-		wake_up(&gb->wq);
+		gb_loopback_reset_stats(gb_dev);
+		wake_up(&gb_dev->wq);
 		break;
 	default:
-		gb->type = 0;
+		gb_dev->type = 0;
 		break;
 	}
 }
@@ -186,8 +244,6 @@ gb_loopback_stats_attrs(requests_per_second);
 gb_loopback_stats_attrs(throughput);
 /* Number of errors encountered during loop */
 gb_loopback_ro_attr(error);
-/* The current index of the for (i = 0; i < iteration_max; i++) loop */
-gb_loopback_ro_attr(iteration_count);
 
 /*
  * Type of loopback message to send based on protocol type definitions
@@ -197,13 +253,15 @@ gb_loopback_ro_attr(iteration_count);
  *					   payload returned in response)
  * 4 => Send a sink message (message with payload, no payload in response)
  */
-gb_loopback_attr(type, d);
+gb_dev_loopback_rw_attr(type, d);
 /* Size of transfer message payload: 0-4096 bytes */
-gb_loopback_attr(size, u);
+gb_dev_loopback_rw_attr(size, u);
 /* Time to wait between two messages: 0-1000 ms */
-gb_loopback_attr(ms_wait, d);
+gb_dev_loopback_rw_attr(ms_wait, d);
 /* Maximum iterations for a given operation: 1-(2^32-1), 0 implies infinite */
-gb_loopback_attr(iteration_max, u);
+gb_dev_loopback_rw_attr(iteration_max, u);
+/* The current index of the for (i = 0; i < iteration_max; i++) loop */
+gb_dev_loopback_ro_attr(iteration_count);
 
 #define dev_stats_attrs(name)						\
 	&dev_attr_##name##_min.attr,					\
@@ -341,7 +399,6 @@ static int gb_loopback_ping(struct gb_loopback *gb)
 static int gb_loopback_request_recv(u8 type, struct gb_operation *operation)
 {
 	struct gb_connection *connection = operation->connection;
-	struct gb_loopback *gb = connection->private;
 	struct gb_loopback_transfer_request *request;
 	struct gb_loopback_transfer_response *response;
 	size_t len;
@@ -365,10 +422,10 @@ static int gb_loopback_request_recv(u8 type, struct gb_operation *operation)
 		}
 		request = operation->request->payload;
 		len = le32_to_cpu(request->len);
-		if (len > gb->size_max) {
+		if (len > gb_dev.size_max) {
 			dev_err(&connection->dev,
 				"transfer request too large (%zu > %zu)\n",
-				len, gb->size_max);
+				len, gb_dev.size_max);
 			return -EINVAL;
 		}
 
@@ -390,15 +447,34 @@ static int gb_loopback_request_recv(u8 type, struct gb_operation *operation)
 	}
 }
 
-static void gb_loopback_reset_stats(struct gb_loopback *gb)
+static void gb_loopback_reset_stats(struct gb_loopback_device *gb_dev)
 {
 	struct gb_loopback_stats reset = {
 		.min = U32_MAX,
 	};
-	memcpy(&gb->latency, &reset, sizeof(struct gb_loopback_stats));
-	memcpy(&gb->latency_gb, &reset, sizeof(struct gb_loopback_stats));
-	memcpy(&gb->throughput, &reset, sizeof(struct gb_loopback_stats));
-	memcpy(&gb->requests_per_second, &reset,
+	struct gb_loopback *gb;
+
+	/* Reset per-connection stats */
+	list_for_each_entry(gb, &gb_dev->list, entry) {
+		mutex_lock(&gb->mutex);
+		memcpy(&gb->latency, &reset,
+		       sizeof(struct gb_loopback_stats));
+		memcpy(&gb->latency_gb, &reset,
+		       sizeof(struct gb_loopback_stats));
+		memcpy(&gb->throughput, &reset,
+		       sizeof(struct gb_loopback_stats));
+		memcpy(&gb->requests_per_second, &reset,
+		       sizeof(struct gb_loopback_stats));
+		mutex_unlock(&gb->mutex);
+	}
+
+	/* Reset aggregate stats */
+	memset(&gb_dev->start, 0, sizeof(struct timeval));
+	memset(&gb_dev->end, 0, sizeof(struct timeval));
+	memcpy(&gb_dev->latency, &reset, sizeof(struct gb_loopback_stats));
+	memcpy(&gb_dev->latency_gb, &reset, sizeof(struct gb_loopback_stats));
+	memcpy(&gb_dev->throughput, &reset, sizeof(struct gb_loopback_stats));
+	memcpy(&gb_dev->requests_per_second, &reset,
 	       sizeof(struct gb_loopback_stats));
 }
 
@@ -417,6 +493,7 @@ static void gb_loopback_requests_update(struct gb_loopback *gb, u32 latency)
 	u32 req = USEC_PER_SEC;
 
 	do_div(req, latency);
+	gb_loopback_update_stats(&gb_dev.requests_per_second, req);
 	gb_loopback_update_stats(&gb->requests_per_second, req);
 }
 
@@ -425,17 +502,17 @@ static void gb_loopback_throughput_update(struct gb_loopback *gb, u32 latency)
 	u32 throughput;
 	u32 aggregate_size = sizeof(struct gb_operation_msg_hdr) * 2;
 
-	switch (gb->type) {
+	switch (gb_dev.type) {
 	case GB_LOOPBACK_TYPE_PING:
 		break;
 	case GB_LOOPBACK_TYPE_SINK:
 		aggregate_size += sizeof(struct gb_loopback_transfer_request) +
-				  gb->size;
+				  gb_dev.size;
 		break;
 	case GB_LOOPBACK_TYPE_TRANSFER:
 		aggregate_size += sizeof(struct gb_loopback_transfer_request) +
 				  sizeof(struct gb_loopback_transfer_response) +
-				  gb->size * 2;
+				  gb_dev.size * 2;
 		break;
 	default:
 		return;
@@ -445,6 +522,7 @@ static void gb_loopback_throughput_update(struct gb_loopback *gb, u32 latency)
 	throughput = USEC_PER_SEC;
 	do_div(throughput, latency);
 	throughput *= aggregate_size;
+	gb_loopback_update_stats(&gb_dev.throughput, throughput);
 	gb_loopback_update_stats(&gb->throughput, throughput);
 }
 
@@ -459,7 +537,10 @@ static void gb_loopback_calculate_stats(struct gb_loopback *gb)
 	lat = tmp;
 
 	/* Log latency statistic */
+	gb_loopback_update_stats(&gb_dev.latency, lat);
 	gb_loopback_update_stats(&gb->latency, lat);
+
+	/* Raw latency log on a per thread basis */
 	kfifo_in(&gb->kfifo, (unsigned char *)&lat, sizeof(lat));
 
 	/* Log throughput and requests using latency as benchmark */
@@ -469,6 +550,7 @@ static void gb_loopback_calculate_stats(struct gb_loopback *gb)
 	/* Calculate the greybus related latency number in nanoseconds */
 	tmp = gb->elapsed_nsecs - gb->elapsed_nsecs_gb;
 	lat = tmp;
+	gb_loopback_update_stats(&gb_dev.latency_gb, lat);
 	gb_loopback_update_stats(&gb->latency_gb, lat);
 }
 
@@ -476,38 +558,74 @@ static int gb_loopback_fn(void *data)
 {
 	int error = 0;
 	int ms_wait;
+	int type;
+	u32 size;
+	u32 low_count;
 	struct gb_loopback *gb = data;
+	struct gb_loopback *gb_list;
 
 	while (1) {
-		if (!gb->type)
-			wait_event_interruptible(gb->wq, gb->type ||
+		if (!gb_dev.type)
+			wait_event_interruptible(gb_dev.wq, gb_dev.type ||
 						 kthread_should_stop());
 		if (kthread_should_stop())
 			break;
 
-		mutex_lock(&gb->mutex);
-		if (gb->iteration_max) {
-			if (gb->iteration_count < gb->iteration_max) {
-				gb->iteration_count++;
+		mutex_lock(&gb_dev.mutex);
+		if (gb_dev.iteration_max) {
+			/* Determine overall lowest count */
+			low_count = gb->iteration_count;
+			list_for_each_entry(gb_list, &gb_dev.list, entry) {
+				if (gb_list->iteration_count < low_count)
+					low_count = gb_list->iteration_count;
+			}
+			/* All threads achieved at least low_count iterations */
+			if (gb_dev.iteration_count < low_count) {
+				gb_dev.iteration_count = low_count;
 				sysfs_notify(&gb->connection->dev.kobj, NULL,
 					     "iteration_count");
-			} else {
-				gb->type = 0;
-				mutex_unlock(&gb->mutex);
+			}
+			/* Optionally terminate */
+			if (gb_dev.iteration_count == gb_dev.iteration_max) {
+				gb_dev.type = 0;
+				mutex_unlock(&gb_dev.mutex);
 				continue;
 			}
 		}
-		if (gb->type == GB_LOOPBACK_TYPE_PING)
+		size = gb_dev.size;
+		ms_wait = gb_dev.ms_wait;
+		type = gb_dev.type;
+		mutex_unlock(&gb_dev.mutex);
+
+		mutex_lock(&gb->mutex);
+		if (gb->iteration_count >= gb_dev.iteration_max) {
+			/* If this thread finished before siblings then sleep */
+			ms_wait = 1;
+			mutex_unlock(&gb->mutex);
+			goto sleep;
+		}
+		/* Else operations to perform */
+		if (type == GB_LOOPBACK_TYPE_PING)
 			error = gb_loopback_ping(gb);
-		else if (gb->type == GB_LOOPBACK_TYPE_TRANSFER)
-			error = gb_loopback_transfer(gb, gb->size);
-		else if (gb->type == GB_LOOPBACK_TYPE_SINK)
-			error = gb_loopback_sink(gb, gb->size);
-		if (error)
+		else if (type == GB_LOOPBACK_TYPE_TRANSFER)
+			error = gb_loopback_transfer(gb, size);
+		else if (type == GB_LOOPBACK_TYPE_SINK)
+			error = gb_loopback_sink(gb, size);
+		mutex_unlock(&gb->mutex);
+
+		mutex_lock(&gb_dev.mutex);
+		mutex_lock(&gb->mutex);
+
+		if (error) {
+			gb_dev.error++;
 			gb->error++;
+		}
 		gb_loopback_calculate_stats(gb);
-		ms_wait = gb->ms_wait;
+		gb->iteration_count++;
+
 		mutex_unlock(&gb->mutex);
+		mutex_unlock(&gb_dev.mutex);
+sleep:
 		if (ms_wait)
 			msleep(ms_wait);
 	}
@@ -549,7 +667,7 @@ static const struct file_operations gb_loopback_debugfs_latency_ops = {
 	.release	= single_release,
 };
 
-#define DEBUGFS_NAMELEN 24
+#define DEBUGFS_NAMELEN 32
 
 static int gb_loopback_connection_init(struct gb_connection *connection)
 {
@@ -560,7 +678,7 @@ static int gb_loopback_connection_init(struct gb_connection *connection)
 	gb = kzalloc(sizeof(*gb), GFP_KERNEL);
 	if (!gb)
 		return -ENOMEM;
-	gb_loopback_reset_stats(gb);
+	gb_loopback_reset_stats(&gb_dev);
 
 	snprintf(name, sizeof(name), "raw_latency_endo0:%d:%d:%d:%d",
 		connection->bundle->intf->module->module_id,
@@ -576,12 +694,14 @@ static int gb_loopback_connection_init(struct gb_connection *connection)
 		goto out_debugfs;
 
 	/* Calculate maximum payload */
-	gb->size_max = gb_operation_get_payload_size_max(connection);
-	if (gb->size_max <= sizeof(struct gb_loopback_transfer_request)) {
+	mutex_lock(&gb_dev.mutex);
+	gb_dev.size_max = gb_operation_get_payload_size_max(connection);
+	if (gb_dev.size_max <= sizeof(struct gb_loopback_transfer_request)) {
 		retval = -EINVAL;
 		goto out_sysfs;
 	}
-	gb->size_max -= sizeof(struct gb_loopback_transfer_request);
+	gb_dev.size_max -= sizeof(struct gb_loopback_transfer_request);
+	mutex_unlock(&gb_dev.mutex);
 
 	/* Allocate kfifo */
 	if (kfifo_alloc(&gb->kfifo, kfifo_depth * sizeof(u32),
@@ -591,7 +711,6 @@ static int gb_loopback_connection_init(struct gb_connection *connection)
 	}
 
 	/* Fork worker thread */
-	init_waitqueue_head(&gb->wq);
 	mutex_init(&gb->mutex);
 	gb->task = kthread_run(gb_loopback_fn, gb, "gb_loopback");
 	if (IS_ERR(gb->task)) {
@@ -599,6 +718,9 @@ static int gb_loopback_connection_init(struct gb_connection *connection)
 		goto out_kfifo;
 	}
 
+	mutex_lock(&gb_dev.mutex);
+	list_add_tail(&gb->entry, &gb_dev.list);
+	mutex_unlock(&gb_dev.mutex);
 	gb_dev.count++;
 	return 0;
 
@@ -641,7 +763,11 @@ static struct gb_protocol loopback_protocol = {
 
 static int loopback_init(void)
 {
+	init_waitqueue_head(&gb_dev.wq);
+	INIT_LIST_HEAD(&gb_dev.list);
+	mutex_init(&gb_dev.mutex);
 	gb_dev.root = debugfs_create_dir("gb_loopback", NULL);
+
 	return gb_protocol_register(&loopback_protocol);
 }
 module_init(loopback_init);

commit aa27bf82694de73f850581d5c928d99b16032be7
Author: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
Date:   Mon Aug 17 00:55:03 2015 +0100

    greybus: loopback: convert sample report interface to debugfs
    
    Greg previously suggested switching over to debugfs instead of a char
    interface to report raw samples to user-space. At the time we agreed not
    to go for that change. However later patches in this series are made
    simpler if debugfs is used instead of /dev, so it makes sense to make the
    conversion now for that reason. This patch removes the char interface and
    replaces it with a debugfs interface. Raw samples will be acquired from
    /sys/kernel/debug/gb_loopback/raw_latency_endo0:x:y:z:w where
    
    x = <module-id>
    y = <interface-id>
    z = <bundle-id>
    w = <cport-number>
    
    Signed-off-by: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/loopback.c b/drivers/staging/greybus/loopback.c
index 74bc2b4eec63..5f66048927a7 100644
--- a/drivers/staging/greybus/loopback.c
+++ b/drivers/staging/greybus/loopback.c
@@ -17,6 +17,7 @@
 #include <linux/cdev.h>
 #include <linux/fs.h>
 #include <linux/kfifo.h>
+#include <linux/debugfs.h>
 
 #include <asm/div64.h>
 
@@ -31,16 +32,21 @@ struct gb_loopback_stats {
 	u32 count;
 };
 
+struct gb_loopback_device {
+	struct dentry *root;
+	u32 count;
+};
+
+static struct gb_loopback_device gb_dev;
+
 struct gb_loopback {
 	struct gb_connection *connection;
 
+	struct dentry *file;
 	struct kfifo kfifo;
 	struct mutex mutex;
 	struct task_struct *task;
 	wait_queue_head_t wq;
-	dev_t dev;
-	struct cdev cdev;
-	struct device *device;
 
 	int type;
 	u32 size;
@@ -60,16 +66,9 @@ struct gb_loopback {
 
 #define GB_LOOPBACK_FIFO_DEFAULT			8192
 
-static struct class *loopback_class;
-static int loopback_major;
-static const struct file_operations loopback_fops;
-static DEFINE_IDA(minors);
 static unsigned kfifo_depth = GB_LOOPBACK_FIFO_DEFAULT;
 module_param(kfifo_depth, uint, 0444);
 
-/* Number of minor devices this driver supports */
-#define NUM_MINORS      256
-
 /* Maximum size of any one send data buffer we support */
 #define MAX_PACKET_SIZE (PAGE_SIZE * 2)
 
@@ -515,35 +514,72 @@ static int gb_loopback_fn(void *data)
 	return 0;
 }
 
+static int gb_loopback_dbgfs_latency_show(struct seq_file *s, void *unused)
+{
+	struct gb_loopback *gb = s->private;
+	u32 latency;
+	int retval;
+
+	if (kfifo_len(&gb->kfifo) == 0) {
+		retval = -EAGAIN;
+		goto done;
+	}
+
+	mutex_lock(&gb->mutex);
+	retval = kfifo_out(&gb->kfifo, &latency, sizeof(latency));
+	if (retval > 0) {
+		seq_printf(s, "%u", latency);
+		retval = 0;
+	}
+	mutex_unlock(&gb->mutex);
+done:
+	return retval;
+}
+
+static int gb_loopback_latency_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, gb_loopback_dbgfs_latency_show,
+			   inode->i_private);
+}
+
+static const struct file_operations gb_loopback_debugfs_latency_ops = {
+	.open		= gb_loopback_latency_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+
+#define DEBUGFS_NAMELEN 24
+
 static int gb_loopback_connection_init(struct gb_connection *connection)
 {
 	struct gb_loopback *gb;
 	int retval;
-	int minor;
+	char name[DEBUGFS_NAMELEN];
 
 	gb = kzalloc(sizeof(*gb), GFP_KERNEL);
 	if (!gb)
 		return -ENOMEM;
 	gb_loopback_reset_stats(gb);
 
+	snprintf(name, sizeof(name), "raw_latency_endo0:%d:%d:%d:%d",
+		connection->bundle->intf->module->module_id,
+		connection->bundle->intf->interface_id,
+		connection->bundle->id,
+		connection->intf_cport_id);
+	gb->file = debugfs_create_file(name, S_IFREG | S_IRUGO, gb_dev.root, gb,
+				       &gb_loopback_debugfs_latency_ops);
 	gb->connection = connection;
 	connection->private = gb;
 	retval = sysfs_create_groups(&connection->dev.kobj, loopback_groups);
 	if (retval)
-		goto out_free;
-
-	/* Get a minor number */
-	minor = ida_simple_get(&minors, 0, 0, GFP_KERNEL);
-	if (minor < 0) {
-		retval = minor;
-		goto out_sysfs;
-	}
+		goto out_debugfs;
 
 	/* Calculate maximum payload */
 	gb->size_max = gb_operation_get_payload_size_max(connection);
 	if (gb->size_max <= sizeof(struct gb_loopback_transfer_request)) {
 		retval = -EINVAL;
-		goto out_minor;
+		goto out_sysfs;
 	}
 	gb->size_max -= sizeof(struct gb_loopback_transfer_request);
 
@@ -551,21 +587,7 @@ static int gb_loopback_connection_init(struct gb_connection *connection)
 	if (kfifo_alloc(&gb->kfifo, kfifo_depth * sizeof(u32),
 			  GFP_KERNEL)) {
 		retval = -ENOMEM;
-		goto out_minor;
-	}
-
-	/* Create device entry */
-	gb->dev = MKDEV(loopback_major, minor);
-	cdev_init(&gb->cdev, &loopback_fops);
-	retval = cdev_add(&gb->cdev, gb->dev, 1);
-	if (retval)
-		goto out_kfifo;
-
-	gb->device = device_create(loopback_class, &connection->dev, gb->dev,
-				   gb, "gb!loopback%d", minor);
-	if (IS_ERR(gb->device)) {
-		retval = PTR_ERR(gb->device);
-		goto out_cdev;
+		goto out_sysfs;
 	}
 
 	/* Fork worker thread */
@@ -574,22 +596,18 @@ static int gb_loopback_connection_init(struct gb_connection *connection)
 	gb->task = kthread_run(gb_loopback_fn, gb, "gb_loopback");
 	if (IS_ERR(gb->task)) {
 		retval = PTR_ERR(gb->task);
-		goto out_device;
+		goto out_kfifo;
 	}
 
+	gb_dev.count++;
 	return 0;
 
-out_device:
-	device_del(gb->device);
-out_cdev:
-	cdev_del(&gb->cdev);
 out_kfifo:
 	kfifo_free(&gb->kfifo);
-out_minor:
-	ida_simple_remove(&minors, minor);
 out_sysfs:
 	sysfs_remove_groups(&connection->dev.kobj, loopback_groups);
-out_free:
+out_debugfs:
+	debugfs_remove(gb->file);
 	connection->private = NULL;
 	kfree(gb);
 
@@ -600,15 +618,14 @@ static void gb_loopback_connection_exit(struct gb_connection *connection)
 {
 	struct gb_loopback *gb = connection->private;
 
+	gb_dev.count--;
 	connection->private = NULL;
 	if (!IS_ERR_OR_NULL(gb->task))
 		kthread_stop(gb->task);
 
-	device_del(gb->device);
-	cdev_del(&gb->cdev);
 	kfifo_free(&gb->kfifo);
-	ida_simple_remove(&minors, MINOR(gb->dev));
 	sysfs_remove_groups(&connection->dev.kobj, loopback_groups);
+	debugfs_remove(gb->file);
 	kfree(gb);
 }
 
@@ -622,79 +639,17 @@ static struct gb_protocol loopback_protocol = {
 	.request_recv		= gb_loopback_request_recv,
 };
 
-static int loopback_open(struct inode *inode, struct file *file)
-{
-	struct cdev *cdev = inode->i_cdev;
-	struct gb_loopback *gb = container_of(cdev, struct gb_loopback, cdev);
-
-	file->private_data = gb;
-	return 0;
-}
-
-static ssize_t loopback_read(struct file *file, char __user *buf, size_t count,
-			     loff_t *ppos)
-{
-	struct gb_loopback *gb = file->private_data;
-	size_t fifo_len;
-	int retval;
-
-	if (!count || count % sizeof(u32))
-		return -EINVAL;
-
-	mutex_lock(&gb->mutex);
-	fifo_len = kfifo_len(&gb->kfifo);
-	if (kfifo_to_user(&gb->kfifo, buf, min(fifo_len, count), &retval) != 0)
-		retval = -EIO;
-	mutex_unlock(&gb->mutex);
-
-	return retval;
-}
-
-static const struct file_operations loopback_fops = {
-	.owner          = THIS_MODULE,
-	.read           = loopback_read,
-	.open           = loopback_open,
-	.llseek         = noop_llseek,
-};
-
 static int loopback_init(void)
 {
-	dev_t dev;
-	int retval;
-
-	loopback_class = class_create(THIS_MODULE, "gb_loopback");
-	if (IS_ERR(loopback_class)) {
-		retval = PTR_ERR(loopback_class);
-		goto error_class;
-	}
-
-	retval = alloc_chrdev_region(&dev, 0, NUM_MINORS, "gb_loopback");
-	if (retval < 0)
-		goto error_chrdev;
-
-	loopback_major = MAJOR(dev);
-
-	retval = gb_protocol_register(&loopback_protocol);
-	if (retval)
-		goto error_gb;
-
-	return 0;
-
-error_gb:
-	unregister_chrdev_region(dev, NUM_MINORS);
-error_chrdev:
-	class_destroy(loopback_class);
-error_class:
-	return retval;
+	gb_dev.root = debugfs_create_dir("gb_loopback", NULL);
+	return gb_protocol_register(&loopback_protocol);
 }
 module_init(loopback_init);
 
 static void __exit loopback_exit(void)
 {
+	debugfs_remove_recursive(gb_dev.root);
 	gb_protocol_deregister(&loopback_protocol);
-	unregister_chrdev_region(MKDEV(loopback_major, 0), NUM_MINORS);
-	class_destroy(loopback_class);
-	ida_destroy(&minors);
 }
 module_exit(loopback_exit);
 

commit 2f8423046f21093818ffc4fae917f8e9dd8e9931
Author: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
Date:   Mon Aug 17 00:55:02 2015 +0100

    greybus: loopback: add ability to graph greybus latency
    
    This patch adds the ability to graph the latency of the overhead introduced
    by the greybus stack in the roundtrip time AP->Module->AP.
    
    Since this is a small number it is reported in nanoseconds, not
    mircoseconds. This data can also be derived with tracepoints but it's being
    provided in this format to export to CSV file more easily than with
    tracepoints.
    
    Signed-off-by: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/loopback.c b/drivers/staging/greybus/loopback.c
index 3263d8351aa3..74bc2b4eec63 100644
--- a/drivers/staging/greybus/loopback.c
+++ b/drivers/staging/greybus/loopback.c
@@ -50,9 +50,11 @@ struct gb_loopback {
 	int ms_wait;
 
 	struct gb_loopback_stats latency;
+	struct gb_loopback_stats latency_gb;
 	struct gb_loopback_stats throughput;
 	struct gb_loopback_stats requests_per_second;
 	u64 elapsed_nsecs;
+	u64 elapsed_nsecs_gb;
 	u32 error;
 };
 
@@ -177,6 +179,8 @@ static void gb_loopback_check_attr(struct gb_connection *connection,
 
 /* Time to send and receive one message */
 gb_loopback_stats_attrs(latency);
+/* Time to send and receive one message not including greybus */
+gb_loopback_stats_attrs(latency_gb);
 /* Number of requests sent per second on this cport */
 gb_loopback_stats_attrs(requests_per_second);
 /* Quantity of data sent and received on this cport */
@@ -209,6 +213,7 @@ gb_loopback_attr(iteration_max, u);
 
 static struct attribute *loopback_attrs[] = {
 	dev_stats_attrs(latency),
+	dev_stats_attrs(latency_gb),
 	dev_stats_attrs(requests_per_second),
 	dev_stats_attrs(throughput),
 	&dev_attr_type.attr,
@@ -221,17 +226,16 @@ static struct attribute *loopback_attrs[] = {
 };
 ATTRIBUTE_GROUPS(loopback);
 
-static void gb_loopback_calc_latency(struct gb_loopback *gb,
-				     struct timeval *ts, struct timeval *te)
+static u64 gb_loopback_calc_latency(struct timeval *ts, struct timeval *te)
 {
 	u64 t1, t2;
 
 	t1 = timeval_to_ns(ts);
 	t2 = timeval_to_ns(te);
 	if (t2 > t1)
-		gb->elapsed_nsecs = t2 - t1;
+		return t2 - t1;
 	else
-		gb->elapsed_nsecs = NSEC_PER_DAY - t2 + t1;
+		return NSEC_PER_DAY - t2 + t1;
 }
 
 static int gb_loopback_sink(struct gb_loopback *gb, u32 len)
@@ -251,7 +255,15 @@ static int gb_loopback_sink(struct gb_loopback *gb, u32 len)
 				   request, len + sizeof(*request), NULL, 0);
 
 	do_gettimeofday(&te);
-	gb_loopback_calc_latency(gb, &ts, &te);
+
+	/* Calculate the total time the message took */
+	gb->elapsed_nsecs = gb_loopback_calc_latency(&ts, &te);
+
+	/* Calculate non-greybus related component of the latency */
+	gb_connection_pop_timestamp(gb->connection, &ts);
+	gb_connection_pop_timestamp(gb->connection, &te);
+	gb->elapsed_nsecs_gb = gb_loopback_calc_latency(&ts, &te);
+
 
 	kfree(request);
 	return retval;
@@ -282,7 +294,14 @@ static int gb_loopback_transfer(struct gb_loopback *gb, u32 len)
 				   request, len + sizeof(*request),
 				   response, len + sizeof(*response));
 	do_gettimeofday(&te);
-	gb_loopback_calc_latency(gb, &ts, &te);
+
+	/* Calculate the total time the message took */
+	gb->elapsed_nsecs = gb_loopback_calc_latency(&ts, &te);
+
+	/* Calculate non-greybus related component of the latency */
+	gb_connection_pop_timestamp(gb->connection, &ts);
+	gb_connection_pop_timestamp(gb->connection, &te);
+	gb->elapsed_nsecs_gb = gb_loopback_calc_latency(&ts, &te);
 
 	if (retval)
 		goto gb_error;
@@ -308,7 +327,14 @@ static int gb_loopback_ping(struct gb_loopback *gb)
 	retval = gb_operation_sync(gb->connection, GB_LOOPBACK_TYPE_PING,
 				   NULL, 0, NULL, 0);
 	do_gettimeofday(&te);
-	gb_loopback_calc_latency(gb, &ts, &te);
+
+	/* Calculate the total time the message took */
+	gb->elapsed_nsecs = gb_loopback_calc_latency(&ts, &te);
+
+	/* Calculate non-greybus related component of the latency */
+	gb_connection_pop_timestamp(gb->connection, &ts);
+	gb_connection_pop_timestamp(gb->connection, &te);
+	gb->elapsed_nsecs_gb = gb_loopback_calc_latency(&ts, &te);
 
 	return retval;
 }
@@ -371,6 +397,7 @@ static void gb_loopback_reset_stats(struct gb_loopback *gb)
 		.min = U32_MAX,
 	};
 	memcpy(&gb->latency, &reset, sizeof(struct gb_loopback_stats));
+	memcpy(&gb->latency_gb, &reset, sizeof(struct gb_loopback_stats));
 	memcpy(&gb->throughput, &reset, sizeof(struct gb_loopback_stats));
 	memcpy(&gb->requests_per_second, &reset,
 	       sizeof(struct gb_loopback_stats));
@@ -439,6 +466,11 @@ static void gb_loopback_calculate_stats(struct gb_loopback *gb)
 	/* Log throughput and requests using latency as benchmark */
 	gb_loopback_throughput_update(gb, lat);
 	gb_loopback_requests_update(gb, lat);
+
+	/* Calculate the greybus related latency number in nanoseconds */
+	tmp = gb->elapsed_nsecs - gb->elapsed_nsecs_gb;
+	lat = tmp;
+	gb_loopback_update_stats(&gb->latency_gb, lat);
 }
 
 static int gb_loopback_fn(void *data)

commit dc366f8e397c41ba582821e24abdc2bc4ae80a47
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Fri Aug 14 17:07:11 2015 +0530

    greybus: loopback: Print error on data mismatch
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Reviewed-by: Bryan O'Donoghue <bryan.odnoghue@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/loopback.c b/drivers/staging/greybus/loopback.c
index 39ad4141ba8c..3263d8351aa3 100644
--- a/drivers/staging/greybus/loopback.c
+++ b/drivers/staging/greybus/loopback.c
@@ -287,8 +287,10 @@ static int gb_loopback_transfer(struct gb_loopback *gb, u32 len)
 	if (retval)
 		goto gb_error;
 
-	if (memcmp(request->data, response->data, len))
+	if (memcmp(request->data, response->data, len)) {
+		pr_info("%s: Loopback Data doesn't match\n", __func__);
 		retval = -EREMOTEIO;
+	}
 
 gb_error:
 	kfree(request);

commit dc4a10693f3f0e6658b06dd1947643637c0476a4
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Fri Aug 14 17:07:10 2015 +0530

    greybus: loopback: Send some sensible data
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Reviewed-by: Bryan O'Donoghue <bryan.odnoghue@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/loopback.c b/drivers/staging/greybus/loopback.c
index cf525f8f942a..39ad4141ba8c 100644
--- a/drivers/staging/greybus/loopback.c
+++ b/drivers/staging/greybus/loopback.c
@@ -273,6 +273,8 @@ static int gb_loopback_transfer(struct gb_loopback *gb, u32 len)
 		return -ENOMEM;
 	}
 
+	memset(request->data, 0x5A, len);
+
 	request->len = cpu_to_le32(len);
 
 	do_gettimeofday(&ts);

commit 0e2462d1b71b15790d37f9f66b01cdf1003a8e72
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Fri Aug 14 07:57:38 2015 +0530

    greybus: Drop protocol specific _PROTOCOL_VERSION and _INVALID macros
    
    Greybus core supports protocol independent macros for this now, use
    them.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/loopback.c b/drivers/staging/greybus/loopback.c
index 852b6beaecac..cf525f8f942a 100644
--- a/drivers/staging/greybus/loopback.c
+++ b/drivers/staging/greybus/loopback.c
@@ -319,7 +319,7 @@ static int gb_loopback_request_recv(u8 type, struct gb_operation *operation)
 
 	/* By convention, the AP initiates the version operation */
 	switch (type) {
-	case GB_LOOPBACK_TYPE_PROTOCOL_VERSION:
+	case GB_REQUEST_TYPE_PROTOCOL_VERSION:
 		dev_err(&connection->dev,
 			"module-initiated version operation\n");
 		return -EINVAL;

commit fd489e1ac617d662e248557afd8aa06ee731440b
Author: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
Date:   Tue Aug 11 13:50:54 2015 +0100

    greybus: loopback: handle timestamp roll-over
    
    This patch ensures we account for roll-over in the loopback driver.
    do_gettimeofday() is used to grab a timestamp. Two timestamps are derived
    one before and one after a gb_operation_sync(), however since
    do_gettimeofday() returns the number of seconds and mircoseconds that have
    elapsed today - we need to account for a situation where the timestamp
    starts at say 23:59:999us rolls over and the end time is now earlier than
    the start time.
    
    Signed-off-by: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/loopback.c b/drivers/staging/greybus/loopback.c
index ac38644c4a48..852b6beaecac 100644
--- a/drivers/staging/greybus/loopback.c
+++ b/drivers/staging/greybus/loopback.c
@@ -22,6 +22,8 @@
 
 #include "greybus.h"
 
+#define NSEC_PER_DAY 86400000000000ULL
+
 struct gb_loopback_stats {
 	u32 min;
 	u32 max;
@@ -226,7 +228,10 @@ static void gb_loopback_calc_latency(struct gb_loopback *gb,
 
 	t1 = timeval_to_ns(ts);
 	t2 = timeval_to_ns(te);
-	gb->elapsed_nsecs = t2 - t1;
+	if (t2 > t1)
+		gb->elapsed_nsecs = t2 - t1;
+	else
+		gb->elapsed_nsecs = NSEC_PER_DAY - t2 + t1;
 }
 
 static int gb_loopback_sink(struct gb_loopback *gb, u32 len)

commit 4c192665f0183150cff38b6954687752f3461e13
Author: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
Date:   Tue Aug 11 13:50:53 2015 +0100

    greybus: loopback: functionally decompose calculation of turn-around times
    
    We have a pattern similar to this over and over again gb->elapsed_nsecs =
    timeval_to_ns(&te) - timeval_to_ns(&ts); good software practice dictates we
    functionally decompose this. This patch decomposes into
    gb_loopback_calc_latency().
    
    Signed-off-by: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/loopback.c b/drivers/staging/greybus/loopback.c
index 88c329afd3ea..ac38644c4a48 100644
--- a/drivers/staging/greybus/loopback.c
+++ b/drivers/staging/greybus/loopback.c
@@ -219,6 +219,16 @@ static struct attribute *loopback_attrs[] = {
 };
 ATTRIBUTE_GROUPS(loopback);
 
+static void gb_loopback_calc_latency(struct gb_loopback *gb,
+				     struct timeval *ts, struct timeval *te)
+{
+	u64 t1, t2;
+
+	t1 = timeval_to_ns(ts);
+	t2 = timeval_to_ns(te);
+	gb->elapsed_nsecs = t2 - t1;
+}
+
 static int gb_loopback_sink(struct gb_loopback *gb, u32 len)
 {
 	struct timeval ts, te;
@@ -236,7 +246,7 @@ static int gb_loopback_sink(struct gb_loopback *gb, u32 len)
 				   request, len + sizeof(*request), NULL, 0);
 
 	do_gettimeofday(&te);
-	gb->elapsed_nsecs = timeval_to_ns(&te) - timeval_to_ns(&ts);
+	gb_loopback_calc_latency(gb, &ts, &te);
 
 	kfree(request);
 	return retval;
@@ -265,7 +275,7 @@ static int gb_loopback_transfer(struct gb_loopback *gb, u32 len)
 				   request, len + sizeof(*request),
 				   response, len + sizeof(*response));
 	do_gettimeofday(&te);
-	gb->elapsed_nsecs = timeval_to_ns(&te) - timeval_to_ns(&ts);
+	gb_loopback_calc_latency(gb, &ts, &te);
 
 	if (retval)
 		goto gb_error;
@@ -289,7 +299,7 @@ static int gb_loopback_ping(struct gb_loopback *gb)
 	retval = gb_operation_sync(gb->connection, GB_LOOPBACK_TYPE_PING,
 				   NULL, 0, NULL, 0);
 	do_gettimeofday(&te);
-	gb->elapsed_nsecs = timeval_to_ns(&te) - timeval_to_ns(&ts);
+	gb_loopback_calc_latency(gb, &ts, &te);
 
 	return retval;
 }

commit 47d3cfbbadfb761aaf3967df314f860f8a324f8d
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Tue Aug 11 07:36:06 2015 +0530

    greybus: loopback: Drop get_version support
    
    This is done from a common place now, no need to replicate it.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/loopback.c b/drivers/staging/greybus/loopback.c
index 564276d90da2..88c329afd3ea 100644
--- a/drivers/staging/greybus/loopback.c
+++ b/drivers/staging/greybus/loopback.c
@@ -31,8 +31,6 @@ struct gb_loopback_stats {
 
 struct gb_loopback {
 	struct gb_connection *connection;
-	u8 version_major;
-	u8 version_minor;
 
 	struct kfifo kfifo;
 	struct mutex mutex;
@@ -73,9 +71,6 @@ module_param(kfifo_depth, uint, 0444);
 
 #define GB_LOOPBACK_MS_WAIT_MAX				1000
 
-/* Define get_version() routine */
-define_get_version(gb_loopback, LOOPBACK);
-
 /* interface sysfs attributes */
 #define gb_loopback_ro_attr(field)					\
 static ssize_t field##_show(struct device *dev,				\
@@ -493,11 +488,6 @@ static int gb_loopback_connection_init(struct gb_connection *connection)
 		goto out_sysfs;
 	}
 
-	/* Check the version */
-	retval = get_version(gb);
-	if (retval)
-		goto out_minor;
-
 	/* Calculate maximum payload */
 	gb->size_max = gb_operation_get_payload_size_max(connection);
 	if (gb->size_max <= sizeof(struct gb_loopback_transfer_request)) {

commit 1fb807cf6da0b65af4ba6ab100d38ebef17ff25e
Author: Alex Elder <elder@linaro.org>
Date:   Mon Aug 3 12:57:20 2015 -0500

    greybus: loopback: fix connection cleanup paths
    
    The error paths in gb_loopback_connection_init() are kind of screwed
    up--not in proper order, and the label naming convention seems a
    little inconsistent.
    
    Fix this, ensuring each error cleans up the setup that's been done
    up to that point.  Use the convention that the label indicates the
    first thing that needs to be cleaned up.
    
    Reorder the statements in gb_loopback_connection_exit() to match
    the order of cleanup in gb_loopback_connection_init().
    
    Signed-off-by: Alex Elder <elder@linaro.org>
    Reviewed-by: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/loopback.c b/drivers/staging/greybus/loopback.c
index e76f8a70d113..564276d90da2 100644
--- a/drivers/staging/greybus/loopback.c
+++ b/drivers/staging/greybus/loopback.c
@@ -490,19 +490,19 @@ static int gb_loopback_connection_init(struct gb_connection *connection)
 	minor = ida_simple_get(&minors, 0, 0, GFP_KERNEL);
 	if (minor < 0) {
 		retval = minor;
-		goto out_free;
+		goto out_sysfs;
 	}
 
 	/* Check the version */
 	retval = get_version(gb);
 	if (retval)
-		goto out_get_ver;
+		goto out_minor;
 
 	/* Calculate maximum payload */
 	gb->size_max = gb_operation_get_payload_size_max(connection);
 	if (gb->size_max <= sizeof(struct gb_loopback_transfer_request)) {
 		retval = -EINVAL;
-		goto out_get_ver;
+		goto out_minor;
 	}
 	gb->size_max -= sizeof(struct gb_loopback_transfer_request);
 
@@ -510,7 +510,7 @@ static int gb_loopback_connection_init(struct gb_connection *connection)
 	if (kfifo_alloc(&gb->kfifo, kfifo_depth * sizeof(u32),
 			  GFP_KERNEL)) {
 		retval = -ENOMEM;
-		goto out_get_ver;
+		goto out_minor;
 	}
 
 	/* Create device entry */
@@ -518,13 +518,13 @@ static int gb_loopback_connection_init(struct gb_connection *connection)
 	cdev_init(&gb->cdev, &loopback_fops);
 	retval = cdev_add(&gb->cdev, gb->dev, 1);
 	if (retval)
-		goto out_cdev;
+		goto out_kfifo;
 
 	gb->device = device_create(loopback_class, &connection->dev, gb->dev,
 				   gb, "gb!loopback%d", minor);
 	if (IS_ERR(gb->device)) {
 		retval = PTR_ERR(gb->device);
-		goto out_device;
+		goto out_cdev;
 	}
 
 	/* Fork worker thread */
@@ -533,21 +533,25 @@ static int gb_loopback_connection_init(struct gb_connection *connection)
 	gb->task = kthread_run(gb_loopback_fn, gb, "gb_loopback");
 	if (IS_ERR(gb->task)) {
 		retval = PTR_ERR(gb->task);
-		goto out_kfifo;
+		goto out_device;
 	}
 
 	return 0;
 
 out_device:
-	cdev_del(&gb->cdev);
+	device_del(gb->device);
 out_cdev:
-	ida_simple_remove(&minors, minor);
+	cdev_del(&gb->cdev);
 out_kfifo:
 	kfifo_free(&gb->kfifo);
-out_get_ver:
+out_minor:
+	ida_simple_remove(&minors, minor);
+out_sysfs:
 	sysfs_remove_groups(&connection->dev.kobj, loopback_groups);
 out_free:
+	connection->private = NULL;
 	kfree(gb);
+
 	return retval;
 }
 
@@ -555,13 +559,14 @@ static void gb_loopback_connection_exit(struct gb_connection *connection)
 {
 	struct gb_loopback *gb = connection->private;
 
+	connection->private = NULL;
 	if (!IS_ERR_OR_NULL(gb->task))
 		kthread_stop(gb->task);
 
-	cdev_del(&gb->cdev);
-	ida_simple_remove(&minors, MINOR(gb->dev));
 	device_del(gb->device);
+	cdev_del(&gb->cdev);
 	kfifo_free(&gb->kfifo);
+	ida_simple_remove(&minors, MINOR(gb->dev));
 	sysfs_remove_groups(&connection->dev.kobj, loopback_groups);
 	kfree(gb);
 }

commit ff71d395f3cd5e5efe4b9b3c94c2d41581fb9d8c
Author: Alex Elder <elder@linaro.org>
Date:   Mon Aug 3 12:57:19 2015 -0500

    greybus: loopback: compute average stats on demand only
    
    Stop recording and updating the average every time a sample
    is recorded.  Instead, compute it from the sum and count only
    when it's required.
    
    Signed-off-by: Alex Elder <elder@linaro.org>
    Reviewed-by: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/loopback.c b/drivers/staging/greybus/loopback.c
index 432eeabe963b..e76f8a70d113 100644
--- a/drivers/staging/greybus/loopback.c
+++ b/drivers/staging/greybus/loopback.c
@@ -25,7 +25,6 @@
 struct gb_loopback_stats {
 	u32 min;
 	u32 max;
-	u64 avg;
 	u64 sum;
 	u32 count;
 };
@@ -107,7 +106,11 @@ static ssize_t name##_avg_show(struct device *dev,			\
 {									\
 	struct gb_connection *connection = to_gb_connection(dev);	\
 	struct gb_loopback *gb = connection->private;			\
-	return sprintf(buf, "%llu\n", gb->name.avg);			\
+	struct gb_loopback_stats *stats = &gb->name;			\
+	u32 count = stats->count ? stats->count : 1;			\
+	u64 avg = stats->sum + count / 2;	/* round closest */	\
+	u32 rem = do_div(avg, count);					\
+	return sprintf(buf, "%llu.%06u\n", avg, 1000000 * rem / count);	\
 }									\
 static DEVICE_ATTR_RO(name##_avg)
 
@@ -367,8 +370,6 @@ static void gb_loopback_update_stats(struct gb_loopback_stats *stats, u32 val)
 		stats->max = val;
 	stats->sum += val;
 	stats->count++;
-	stats->avg = stats->sum;
-	do_div(stats->avg, stats->count);
 }
 
 static void gb_loopback_requests_update(struct gb_loopback *gb, u32 latency)

commit 7a135a965c62f7abdf8f3acc5ca45a03d27b272c
Author: Alex Elder <elder@linaro.org>
Date:   Mon Aug 3 12:57:18 2015 -0500

    greybus: loopback: use separate attribute macro for average
    
    Define a separate macro for displaying the average of the samples
    collected.  This will be used so we can calculate the average only
    when requested, rather than every time a new value gets recorded.
    
    Signed-off-by: Alex Elder <elder@linaro.org>
    Reviewed-by: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/loopback.c b/drivers/staging/greybus/loopback.c
index 6afacdba619f..432eeabe963b 100644
--- a/drivers/staging/greybus/loopback.c
+++ b/drivers/staging/greybus/loopback.c
@@ -100,10 +100,21 @@ static ssize_t name##_##field##_show(struct device *dev,		\
 }									\
 static DEVICE_ATTR_RO(name##_##field)
 
+#define gb_loopback_ro_avg_attr(name)					\
+static ssize_t name##_avg_show(struct device *dev,			\
+			    struct device_attribute *attr,		\
+			    char *buf)					\
+{									\
+	struct gb_connection *connection = to_gb_connection(dev);	\
+	struct gb_loopback *gb = connection->private;			\
+	return sprintf(buf, "%llu\n", gb->name.avg);			\
+}									\
+static DEVICE_ATTR_RO(name##_avg)
+
 #define gb_loopback_stats_attrs(field)					\
 	gb_loopback_ro_stats_attr(field, min, u);			\
 	gb_loopback_ro_stats_attr(field, max, u);			\
-	gb_loopback_ro_stats_attr(field, avg, llu);
+	gb_loopback_ro_avg_attr(field);
 
 #define gb_loopback_attr(field, type)					\
 static ssize_t field##_show(struct device *dev,				\

commit 19c2a443c9efc87ae19d0ef7a5d212614a92479e
Author: Alex Elder <elder@linaro.org>
Date:   Mon Aug 3 12:57:17 2015 -0500

    greybus: loopback: all read-only attributes are unsigned
    
    The only values passed to the gb_loopback_ro_attr() macro are
    unsigned 32-bit values.  So there's no need to pass a "type"
    format specifier.
    
    Signed-off-by: Alex Elder <elder@linaro.org>
    Reviewed-by: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/loopback.c b/drivers/staging/greybus/loopback.c
index 283a68448232..6afacdba619f 100644
--- a/drivers/staging/greybus/loopback.c
+++ b/drivers/staging/greybus/loopback.c
@@ -78,14 +78,14 @@ module_param(kfifo_depth, uint, 0444);
 define_get_version(gb_loopback, LOOPBACK);
 
 /* interface sysfs attributes */
-#define gb_loopback_ro_attr(field, type)				\
+#define gb_loopback_ro_attr(field)					\
 static ssize_t field##_show(struct device *dev,				\
 			    struct device_attribute *attr,		\
 			    char *buf)					\
 {									\
 	struct gb_connection *connection = to_gb_connection(dev);	\
 	struct gb_loopback *gb = connection->private;			\
-	return sprintf(buf, "%"#type"\n", gb->field);			\
+	return sprintf(buf, "%u\n", gb->field);				\
 }									\
 static DEVICE_ATTR_RO(field)
 
@@ -171,9 +171,9 @@ gb_loopback_stats_attrs(requests_per_second);
 /* Quantity of data sent and received on this cport */
 gb_loopback_stats_attrs(throughput);
 /* Number of errors encountered during loop */
-gb_loopback_ro_attr(error, u);
+gb_loopback_ro_attr(error);
 /* The current index of the for (i = 0; i < iteration_max; i++) loop */
-gb_loopback_ro_attr(iteration_count, u);
+gb_loopback_ro_attr(iteration_count);
 
 /*
  * Type of loopback message to send based on protocol type definitions

commit b937aa9e2a5e69cea4a0cc59b2d4dc7a0323ef60
Author: Alex Elder <elder@linaro.org>
Date:   Mon Aug 3 12:57:16 2015 -0500

    greybus: loopback: error is an unsigned attribute
    
    The error count is unsigned, so fix the format specifier used in its
    attribute definition.
    
    Signed-off-by: Alex Elder <elder@linaro.org>
    Reviewed-by: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/loopback.c b/drivers/staging/greybus/loopback.c
index 580e00247a78..283a68448232 100644
--- a/drivers/staging/greybus/loopback.c
+++ b/drivers/staging/greybus/loopback.c
@@ -171,7 +171,7 @@ gb_loopback_stats_attrs(requests_per_second);
 /* Quantity of data sent and received on this cport */
 gb_loopback_stats_attrs(throughput);
 /* Number of errors encountered during loop */
-gb_loopback_ro_attr(error, d);
+gb_loopback_ro_attr(error, u);
 /* The current index of the for (i = 0; i < iteration_max; i++) loop */
 gb_loopback_ro_attr(iteration_count, u);
 

commit e13fc28f728ae6aa5e72c90a35d4fb0298205c6c
Author: Alex Elder <elder@linaro.org>
Date:   Mon Aug 3 12:57:15 2015 -0500

    greybus: loopback: use a 32-bit count
    
    The count of statistical samples recorded is currently a 64-bit
    value.  32 bits is sufficient, and in fact anything more than
    that won't work for the do_div() call it's pass to anyway.  So make
    the count field be 32 bits.
    
    Signed-off-by: Alex Elder <elder@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/loopback.c b/drivers/staging/greybus/loopback.c
index 2ec6c8071754..580e00247a78 100644
--- a/drivers/staging/greybus/loopback.c
+++ b/drivers/staging/greybus/loopback.c
@@ -27,7 +27,7 @@ struct gb_loopback_stats {
 	u32 max;
 	u64 avg;
 	u64 sum;
-	u64 count;
+	u32 count;
 };
 
 struct gb_loopback {

commit e051c82b2ba7fb3e237595c4f6d106e04a86baa1
Author: Alex Elder <elder@linaro.org>
Date:   Mon Aug 3 12:57:14 2015 -0500

    greybus: loopback: record 32-bit min and max
    
    The minimum and maximum values for stats values are always 32 bits.
    Change the type for these fields to reflect this.
    
    Signed-off-by: Alex Elder <elder@linaro.org>
    Reviewed-by: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/loopback.c b/drivers/staging/greybus/loopback.c
index 2042bed075d4..2ec6c8071754 100644
--- a/drivers/staging/greybus/loopback.c
+++ b/drivers/staging/greybus/loopback.c
@@ -23,8 +23,8 @@
 #include "greybus.h"
 
 struct gb_loopback_stats {
-	u64 min;
-	u64 max;
+	u32 min;
+	u32 max;
 	u64 avg;
 	u64 sum;
 	u64 count;
@@ -101,8 +101,8 @@ static ssize_t name##_##field##_show(struct device *dev,		\
 static DEVICE_ATTR_RO(name##_##field)
 
 #define gb_loopback_stats_attrs(field)					\
-	gb_loopback_ro_stats_attr(field, min, llu);			\
-	gb_loopback_ro_stats_attr(field, max, llu);			\
+	gb_loopback_ro_stats_attr(field, min, u);			\
+	gb_loopback_ro_stats_attr(field, max, u);			\
 	gb_loopback_ro_stats_attr(field, avg, llu);
 
 #define gb_loopback_attr(field, type)					\
@@ -340,7 +340,7 @@ static int gb_loopback_request_recv(u8 type, struct gb_operation *operation)
 static void gb_loopback_reset_stats(struct gb_loopback *gb)
 {
 	struct gb_loopback_stats reset = {
-		.min = U64_MAX,
+		.min = U32_MAX,
 	};
 	memcpy(&gb->latency, &reset, sizeof(struct gb_loopback_stats));
 	memcpy(&gb->throughput, &reset, sizeof(struct gb_loopback_stats));

commit a6e7e53548b0d54aab0a5c5449e7093a495555d8
Author: Alex Elder <elder@linaro.org>
Date:   Mon Aug 3 12:57:13 2015 -0500

    greybus: loopback: use u32 for stats update
    
    The only values supplied to gb_loopback_update_stats() are 32-bits,
    so change the type of the second argument to reflect that.
    
    Signed-off-by: Alex Elder <elder@linaro.org>
    Reviewed-by: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/loopback.c b/drivers/staging/greybus/loopback.c
index cdefaffc2184..2042bed075d4 100644
--- a/drivers/staging/greybus/loopback.c
+++ b/drivers/staging/greybus/loopback.c
@@ -348,7 +348,7 @@ static void gb_loopback_reset_stats(struct gb_loopback *gb)
 	       sizeof(struct gb_loopback_stats));
 }
 
-static void gb_loopback_update_stats(struct gb_loopback_stats *stats, u64 val)
+static void gb_loopback_update_stats(struct gb_loopback_stats *stats, u32 val)
 {
 	if (stats->min > val)
 		stats->min = val;

commit 3320e784550551ae8ae5c22d58e6b90addafe8a4
Author: Alex Elder <elder@linaro.org>
Date:   Mon Aug 3 12:57:12 2015 -0500

    greybus: loopback: use U64_MAX for initialization
    
    Use the largest representable value when initializing the "min"
    field when resetting loopback statistics.
    
    Signed-off-by: Alex Elder <elder@linaro.org>
    Reviewed-by: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/loopback.c b/drivers/staging/greybus/loopback.c
index 66059a96bb17..cdefaffc2184 100644
--- a/drivers/staging/greybus/loopback.c
+++ b/drivers/staging/greybus/loopback.c
@@ -340,7 +340,7 @@ static int gb_loopback_request_recv(u8 type, struct gb_operation *operation)
 static void gb_loopback_reset_stats(struct gb_loopback *gb)
 {
 	struct gb_loopback_stats reset = {
-		.min = 0xffffffff,
+		.min = U64_MAX,
 	};
 	memcpy(&gb->latency, &reset, sizeof(struct gb_loopback_stats));
 	memcpy(&gb->throughput, &reset, sizeof(struct gb_loopback_stats));

commit 3f12c3ed21d9e28ae2dc50a6c567ee5d5c6054d1
Author: Alex Elder <elder@linaro.org>
Date:   Mon Aug 3 12:57:11 2015 -0500

    greybus: loopback: drop unneeded casts for void pointers
    
    There is no need to cast a void pointer to a particular type.
    Drop the casts used in this way, mainly in the attribute definition
    macros.
    
    Signed-off-by: Alex Elder <elder@linaro.org>
    Reviewed-by: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/loopback.c b/drivers/staging/greybus/loopback.c
index 08f77808e99d..66059a96bb17 100644
--- a/drivers/staging/greybus/loopback.c
+++ b/drivers/staging/greybus/loopback.c
@@ -84,8 +84,7 @@ static ssize_t field##_show(struct device *dev,				\
 			    char *buf)					\
 {									\
 	struct gb_connection *connection = to_gb_connection(dev);	\
-	struct gb_loopback *gb =					\
-		(struct gb_loopback *)connection->private;		\
+	struct gb_loopback *gb = connection->private;			\
 	return sprintf(buf, "%"#type"\n", gb->field);			\
 }									\
 static DEVICE_ATTR_RO(field)
@@ -96,8 +95,7 @@ static ssize_t name##_##field##_show(struct device *dev,		\
 			    char *buf)					\
 {									\
 	struct gb_connection *connection = to_gb_connection(dev);	\
-	struct gb_loopback *gb =					\
-		(struct gb_loopback *)connection->private;		\
+	struct gb_loopback *gb = connection->private;			\
 	return sprintf(buf, "%"#type"\n", gb->name.field);		\
 }									\
 static DEVICE_ATTR_RO(name##_##field)
@@ -113,8 +111,7 @@ static ssize_t field##_show(struct device *dev,				\
 			    char *buf)					\
 {									\
 	struct gb_connection *connection = to_gb_connection(dev);	\
-	struct gb_loopback *gb =					\
-		(struct gb_loopback *)connection->private;		\
+	struct gb_loopback *gb = connection->private;			\
 	return sprintf(buf, "%"#type"\n", gb->field);			\
 }									\
 static ssize_t field##_store(struct device *dev,			\
@@ -124,8 +121,7 @@ static ssize_t field##_store(struct device *dev,			\
 {									\
 	int ret;							\
 	struct gb_connection *connection = to_gb_connection(dev);	\
-	struct gb_loopback *gb =					\
-		(struct gb_loopback *)connection->private;		\
+	struct gb_loopback *gb = connection->private;			\
 	mutex_lock(&gb->mutex);						\
 	ret = sscanf(buf, "%"#type, &gb->field);			\
 	if (ret != 1)							\
@@ -423,7 +419,7 @@ static int gb_loopback_fn(void *data)
 {
 	int error = 0;
 	int ms_wait;
-	struct gb_loopback *gb = (struct gb_loopback *)data;
+	struct gb_loopback *gb = data;
 
 	while (1) {
 		if (!gb->type)

commit 006335a02677ed20dbff44f398a9cbf823db0293
Author: Alex Elder <elder@linaro.org>
Date:   Mon Aug 3 12:57:10 2015 -0500

    greybus: looback: fix two typos
    
    Fix two misspellings.  And add spaces around a '%' operator.
    
    Signed-off-by: Alex Elder <elder@linaro.org>
    Reviewed-by: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/loopback.c b/drivers/staging/greybus/loopback.c
index 08a77fee385a..08f77808e99d 100644
--- a/drivers/staging/greybus/loopback.c
+++ b/drivers/staging/greybus/loopback.c
@@ -183,7 +183,7 @@ gb_loopback_ro_attr(iteration_count, u);
  * Type of loopback message to send based on protocol type definitions
  * 0 => Don't send message
  * 2 => Send ping message continuously (message without payload)
- * 3 => Send transer message continuously (message with payload,
+ * 3 => Send transfer message continuously (message with payload,
  *					   payload returned in response)
  * 4 => Send a sink message (message with payload, no payload in response)
  */
@@ -410,7 +410,7 @@ static void gb_loopback_calculate_stats(struct gb_loopback *gb)
 	do_div(tmp, NSEC_PER_USEC);
 	lat = tmp;
 
-	/* Log latency stastic */
+	/* Log latency statistic */
 	gb_loopback_update_stats(&gb->latency, lat);
 	kfifo_in(&gb->kfifo, (unsigned char *)&lat, sizeof(lat));
 
@@ -584,7 +584,7 @@ static ssize_t loopback_read(struct file *file, char __user *buf, size_t count,
 	size_t fifo_len;
 	int retval;
 
-	if (!count || count%sizeof(u32))
+	if (!count || count % sizeof(u32))
 		return -EINVAL;
 
 	mutex_lock(&gb->mutex);

commit cb60f4960ea03d373899c2c21b0611404025c31f
Author: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
Date:   Tue Jul 28 18:34:39 2015 +0100

    greybus: loopback: warn user if kfifo cannot log all data
    
    The depth of the kfifo used to log the latency data for user-space can be
    moved upwards or downward by way of a module parameter. The user may still
    specify a test set that's larger than the number of kfifo elements we have
    available. If the user specifies more iterations than can be logged give a
    warning as feedback and continue with the test.
    
    Signed-off-by: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/loopback.c b/drivers/staging/greybus/loopback.c
index 7b3ce13032c5..08a77fee385a 100644
--- a/drivers/staging/greybus/loopback.c
+++ b/drivers/staging/greybus/loopback.c
@@ -131,14 +131,15 @@ static ssize_t field##_store(struct device *dev,			\
 	if (ret != 1)							\
 		len = -EINVAL;						\
 	else								\
-		gb_loopback_check_attr(gb);				\
+		gb_loopback_check_attr(connection, gb);			\
 	mutex_unlock(&gb->mutex);					\
 	return len;							\
 }									\
 static DEVICE_ATTR_RW(field)
 
 static void gb_loopback_reset_stats(struct gb_loopback *gb);
-static void gb_loopback_check_attr(struct gb_loopback *gb)
+static void gb_loopback_check_attr(struct gb_connection *connection,
+				   struct gb_loopback *gb)
 {
 	if (gb->ms_wait > GB_LOOPBACK_MS_WAIT_MAX)
 		gb->ms_wait = GB_LOOPBACK_MS_WAIT_MAX;
@@ -148,6 +149,12 @@ static void gb_loopback_check_attr(struct gb_loopback *gb)
 	gb->iteration_count = 0;
 	gb_loopback_reset_stats(gb);
 
+	if (kfifo_depth < gb->iteration_max) {
+		dev_warn(&connection->dev,
+			 "iteration_max %u kfifo_depth %u cannot log all data\n",
+			 gb->iteration_max, kfifo_depth);
+	}
+
 	switch (gb->type) {
 	case GB_LOOPBACK_TYPE_PING:
 	case GB_LOOPBACK_TYPE_TRANSFER:

commit cbd204b48dc445a194d3892e2f46644f9074f308
Author: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
Date:   Tue Jul 28 18:34:38 2015 +0100

    greybus: loopback: provide interface to read all latency data-points
    
    The current loopback code provides the minimum, maximum and average latency
    values for a given test set. It would be highly useful for user-space to
    have access to each one of the latency metrics in order to graph outliers.
    
    This patch adds a simple character device interface implmenting a read()
    interface that allows user-space to read out the saved latency metrics
    which have been stored in a kfifo for this purpose.
    
    A module parameter is provided to allow varying the depth of the kfifo in
    order to allow a user to capture potentially large data sets. This version
    sets the default depth for the kfifo at 8192 dwords.
    
    Signed-off-by: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/loopback.c b/drivers/staging/greybus/loopback.c
index afba4225defd..7b3ce13032c5 100644
--- a/drivers/staging/greybus/loopback.c
+++ b/drivers/staging/greybus/loopback.c
@@ -14,6 +14,10 @@
 #include <linux/delay.h>
 #include <linux/random.h>
 #include <linux/sizes.h>
+#include <linux/cdev.h>
+#include <linux/fs.h>
+#include <linux/kfifo.h>
+
 #include <asm/div64.h>
 
 #include "greybus.h"
@@ -31,9 +35,13 @@ struct gb_loopback {
 	u8 version_major;
 	u8 version_minor;
 
+	struct kfifo kfifo;
 	struct mutex mutex;
 	struct task_struct *task;
 	wait_queue_head_t wq;
+	dev_t dev;
+	struct cdev cdev;
+	struct device *device;
 
 	int type;
 	u32 size;
@@ -49,6 +57,21 @@ struct gb_loopback {
 	u32 error;
 };
 
+#define GB_LOOPBACK_FIFO_DEFAULT			8192
+
+static struct class *loopback_class;
+static int loopback_major;
+static const struct file_operations loopback_fops;
+static DEFINE_IDA(minors);
+static unsigned kfifo_depth = GB_LOOPBACK_FIFO_DEFAULT;
+module_param(kfifo_depth, uint, 0444);
+
+/* Number of minor devices this driver supports */
+#define NUM_MINORS      256
+
+/* Maximum size of any one send data buffer we support */
+#define MAX_PACKET_SIZE (PAGE_SIZE * 2)
+
 #define GB_LOOPBACK_MS_WAIT_MAX				1000
 
 /* Define get_version() routine */
@@ -129,6 +152,7 @@ static void gb_loopback_check_attr(struct gb_loopback *gb)
 	case GB_LOOPBACK_TYPE_PING:
 	case GB_LOOPBACK_TYPE_TRANSFER:
 	case GB_LOOPBACK_TYPE_SINK:
+		kfifo_reset_out(&gb->kfifo);
 		wake_up(&gb->wq);
 		break;
 	default:
@@ -381,6 +405,7 @@ static void gb_loopback_calculate_stats(struct gb_loopback *gb)
 
 	/* Log latency stastic */
 	gb_loopback_update_stats(&gb->latency, lat);
+	kfifo_in(&gb->kfifo, (unsigned char *)&lat, sizeof(lat));
 
 	/* Log throughput and requests using latency as benchmark */
 	gb_loopback_throughput_update(gb, lat);
@@ -433,10 +458,12 @@ static int gb_loopback_connection_init(struct gb_connection *connection)
 {
 	struct gb_loopback *gb;
 	int retval;
+	int minor;
 
 	gb = kzalloc(sizeof(*gb), GFP_KERNEL);
 	if (!gb)
 		return -ENOMEM;
+	gb_loopback_reset_stats(gb);
 
 	gb->connection = connection;
 	connection->private = gb;
@@ -444,6 +471,13 @@ static int gb_loopback_connection_init(struct gb_connection *connection)
 	if (retval)
 		goto out_free;
 
+	/* Get a minor number */
+	minor = ida_simple_get(&minors, 0, 0, GFP_KERNEL);
+	if (minor < 0) {
+		retval = minor;
+		goto out_free;
+	}
+
 	/* Check the version */
 	retval = get_version(gb);
 	if (retval)
@@ -457,17 +491,44 @@ static int gb_loopback_connection_init(struct gb_connection *connection)
 	}
 	gb->size_max -= sizeof(struct gb_loopback_transfer_request);
 
-	gb_loopback_reset_stats(gb);
+	/* Allocate kfifo */
+	if (kfifo_alloc(&gb->kfifo, kfifo_depth * sizeof(u32),
+			  GFP_KERNEL)) {
+		retval = -ENOMEM;
+		goto out_get_ver;
+	}
+
+	/* Create device entry */
+	gb->dev = MKDEV(loopback_major, minor);
+	cdev_init(&gb->cdev, &loopback_fops);
+	retval = cdev_add(&gb->cdev, gb->dev, 1);
+	if (retval)
+		goto out_cdev;
+
+	gb->device = device_create(loopback_class, &connection->dev, gb->dev,
+				   gb, "gb!loopback%d", minor);
+	if (IS_ERR(gb->device)) {
+		retval = PTR_ERR(gb->device);
+		goto out_device;
+	}
+
+	/* Fork worker thread */
 	init_waitqueue_head(&gb->wq);
 	mutex_init(&gb->mutex);
 	gb->task = kthread_run(gb_loopback_fn, gb, "gb_loopback");
 	if (IS_ERR(gb->task)) {
 		retval = PTR_ERR(gb->task);
-		goto out_get_ver;
+		goto out_kfifo;
 	}
 
 	return 0;
 
+out_device:
+	cdev_del(&gb->cdev);
+out_cdev:
+	ida_simple_remove(&minors, minor);
+out_kfifo:
+	kfifo_free(&gb->kfifo);
 out_get_ver:
 	sysfs_remove_groups(&connection->dev.kobj, loopback_groups);
 out_free:
@@ -481,6 +542,11 @@ static void gb_loopback_connection_exit(struct gb_connection *connection)
 
 	if (!IS_ERR_OR_NULL(gb->task))
 		kthread_stop(gb->task);
+
+	cdev_del(&gb->cdev);
+	ida_simple_remove(&minors, MINOR(gb->dev));
+	device_del(gb->device);
+	kfifo_free(&gb->kfifo);
 	sysfs_remove_groups(&connection->dev.kobj, loopback_groups);
 	kfree(gb);
 }
@@ -495,6 +561,80 @@ static struct gb_protocol loopback_protocol = {
 	.request_recv		= gb_loopback_request_recv,
 };
 
-gb_protocol_driver(&loopback_protocol);
+static int loopback_open(struct inode *inode, struct file *file)
+{
+	struct cdev *cdev = inode->i_cdev;
+	struct gb_loopback *gb = container_of(cdev, struct gb_loopback, cdev);
+
+	file->private_data = gb;
+	return 0;
+}
+
+static ssize_t loopback_read(struct file *file, char __user *buf, size_t count,
+			     loff_t *ppos)
+{
+	struct gb_loopback *gb = file->private_data;
+	size_t fifo_len;
+	int retval;
+
+	if (!count || count%sizeof(u32))
+		return -EINVAL;
+
+	mutex_lock(&gb->mutex);
+	fifo_len = kfifo_len(&gb->kfifo);
+	if (kfifo_to_user(&gb->kfifo, buf, min(fifo_len, count), &retval) != 0)
+		retval = -EIO;
+	mutex_unlock(&gb->mutex);
+
+	return retval;
+}
+
+static const struct file_operations loopback_fops = {
+	.owner          = THIS_MODULE,
+	.read           = loopback_read,
+	.open           = loopback_open,
+	.llseek         = noop_llseek,
+};
+
+static int loopback_init(void)
+{
+	dev_t dev;
+	int retval;
+
+	loopback_class = class_create(THIS_MODULE, "gb_loopback");
+	if (IS_ERR(loopback_class)) {
+		retval = PTR_ERR(loopback_class);
+		goto error_class;
+	}
+
+	retval = alloc_chrdev_region(&dev, 0, NUM_MINORS, "gb_loopback");
+	if (retval < 0)
+		goto error_chrdev;
+
+	loopback_major = MAJOR(dev);
+
+	retval = gb_protocol_register(&loopback_protocol);
+	if (retval)
+		goto error_gb;
+
+	return 0;
+
+error_gb:
+	unregister_chrdev_region(dev, NUM_MINORS);
+error_chrdev:
+	class_destroy(loopback_class);
+error_class:
+	return retval;
+}
+module_init(loopback_init);
+
+static void __exit loopback_exit(void)
+{
+	gb_protocol_deregister(&loopback_protocol);
+	unregister_chrdev_region(MKDEV(loopback_major, 0), NUM_MINORS);
+	class_destroy(loopback_class);
+	ida_destroy(&minors);
+}
+module_exit(loopback_exit);
 
 MODULE_LICENSE("GPL v2");

commit 85d678c0bee883c63b760b35a4104feac9018a0f
Author: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
Date:   Tue Jul 28 18:34:36 2015 +0100

    greybus: loopback: make loopback code thread safe
    
    Current code allows a sysfs callback and a kernel worker thread to write
    all over and act upon data that could be in the process of being updated by
    the other. This patch adds a reasonably coarse mutex to enscure sync
    between the two.
    
    Signed-off-by: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/loopback.c b/drivers/staging/greybus/loopback.c
index 5f7c1a6256cc..afba4225defd 100644
--- a/drivers/staging/greybus/loopback.c
+++ b/drivers/staging/greybus/loopback.c
@@ -8,6 +8,7 @@
  */
 #include <linux/kernel.h>
 #include <linux/module.h>
+#include <linux/mutex.h>
 #include <linux/slab.h>
 #include <linux/kthread.h>
 #include <linux/delay.h>
@@ -30,6 +31,7 @@ struct gb_loopback {
 	u8 version_major;
 	u8 version_minor;
 
+	struct mutex mutex;
 	struct task_struct *task;
 	wait_queue_head_t wq;
 
@@ -101,10 +103,13 @@ static ssize_t field##_store(struct device *dev,			\
 	struct gb_connection *connection = to_gb_connection(dev);	\
 	struct gb_loopback *gb =					\
 		(struct gb_loopback *)connection->private;		\
+	mutex_lock(&gb->mutex);						\
 	ret = sscanf(buf, "%"#type, &gb->field);			\
 	if (ret != 1)							\
-		return -EINVAL;						\
-	gb_loopback_check_attr(gb);					\
+		len = -EINVAL;						\
+	else								\
+		gb_loopback_check_attr(gb);				\
+	mutex_unlock(&gb->mutex);					\
 	return len;							\
 }									\
 static DEVICE_ATTR_RW(field)
@@ -385,6 +390,7 @@ static void gb_loopback_calculate_stats(struct gb_loopback *gb)
 static int gb_loopback_fn(void *data)
 {
 	int error = 0;
+	int ms_wait;
 	struct gb_loopback *gb = (struct gb_loopback *)data;
 
 	while (1) {
@@ -393,6 +399,8 @@ static int gb_loopback_fn(void *data)
 						 kthread_should_stop());
 		if (kthread_should_stop())
 			break;
+
+		mutex_lock(&gb->mutex);
 		if (gb->iteration_max) {
 			if (gb->iteration_count < gb->iteration_max) {
 				gb->iteration_count++;
@@ -400,6 +408,7 @@ static int gb_loopback_fn(void *data)
 					     "iteration_count");
 			} else {
 				gb->type = 0;
+				mutex_unlock(&gb->mutex);
 				continue;
 			}
 		}
@@ -412,8 +421,10 @@ static int gb_loopback_fn(void *data)
 		if (error)
 			gb->error++;
 		gb_loopback_calculate_stats(gb);
-		if (gb->ms_wait)
-			msleep(gb->ms_wait);
+		ms_wait = gb->ms_wait;
+		mutex_unlock(&gb->mutex);
+		if (ms_wait)
+			msleep(ms_wait);
 	}
 	return 0;
 }
@@ -448,6 +459,7 @@ static int gb_loopback_connection_init(struct gb_connection *connection)
 
 	gb_loopback_reset_stats(gb);
 	init_waitqueue_head(&gb->wq);
+	mutex_init(&gb->mutex);
 	gb->task = kthread_run(gb_loopback_fn, gb, "gb_loopback");
 	if (IS_ERR(gb->task)) {
 		retval = PTR_ERR(gb->task);

commit a7e60062b022d1ce1104610d0b0c37322aeb66b6
Author: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
Date:   Tue Jul 28 18:34:35 2015 +0100

    greybus: loopback: remove redundant timestamping
    
    It is of more interest to graphing system performance to base our
    timestamps on the time it takes a greybus_operation_sync() to complete.
    Higher level timestamping code is less accurate and not relevant to
    throughput and latency characterization.
    
    Signed-off-by: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/loopback.c b/drivers/staging/greybus/loopback.c
index 229494833a16..5f7c1a6256cc 100644
--- a/drivers/staging/greybus/loopback.c
+++ b/drivers/staging/greybus/loopback.c
@@ -43,8 +43,6 @@ struct gb_loopback {
 	struct gb_loopback_stats latency;
 	struct gb_loopback_stats throughput;
 	struct gb_loopback_stats requests_per_second;
-	struct timeval ts;
-	struct timeval te;
 	u64 elapsed_nsecs;
 	u32 error;
 };
@@ -180,11 +178,9 @@ static struct attribute *loopback_attrs[] = {
 };
 ATTRIBUTE_GROUPS(loopback);
 
-static int gb_loopback_sink(struct gb_loopback *gb,
-				struct timeval *tping, u32 len)
+static int gb_loopback_sink(struct gb_loopback *gb, u32 len)
 {
 	struct timeval ts, te;
-	u64 elapsed_nsecs;
 	struct gb_loopback_transfer_request *request;
 	int retval;
 
@@ -199,18 +195,15 @@ static int gb_loopback_sink(struct gb_loopback *gb,
 				   request, len + sizeof(*request), NULL, 0);
 
 	do_gettimeofday(&te);
-	elapsed_nsecs = timeval_to_ns(&te) - timeval_to_ns(&ts);
-	*tping = ns_to_timeval(elapsed_nsecs);
+	gb->elapsed_nsecs = timeval_to_ns(&te) - timeval_to_ns(&ts);
 
 	kfree(request);
 	return retval;
 }
 
-static int gb_loopback_transfer(struct gb_loopback *gb,
-				struct timeval *tping, u32 len)
+static int gb_loopback_transfer(struct gb_loopback *gb, u32 len)
 {
 	struct timeval ts, te;
-	u64 elapsed_nsecs;
 	struct gb_loopback_transfer_request *request;
 	struct gb_loopback_transfer_response *response;
 	int retval;
@@ -231,8 +224,7 @@ static int gb_loopback_transfer(struct gb_loopback *gb,
 				   request, len + sizeof(*request),
 				   response, len + sizeof(*response));
 	do_gettimeofday(&te);
-	elapsed_nsecs = timeval_to_ns(&te) - timeval_to_ns(&ts);
-	*tping = ns_to_timeval(elapsed_nsecs);
+	gb->elapsed_nsecs = timeval_to_ns(&te) - timeval_to_ns(&ts);
 
 	if (retval)
 		goto gb_error;
@@ -247,18 +239,16 @@ static int gb_loopback_transfer(struct gb_loopback *gb,
 	return retval;
 }
 
-static int gb_loopback_ping(struct gb_loopback *gb, struct timeval *tping)
+static int gb_loopback_ping(struct gb_loopback *gb)
 {
 	struct timeval ts, te;
-	u64 elapsed_nsecs;
 	int retval;
 
 	do_gettimeofday(&ts);
 	retval = gb_operation_sync(gb->connection, GB_LOOPBACK_TYPE_PING,
 				   NULL, 0, NULL, 0);
 	do_gettimeofday(&te);
-	elapsed_nsecs = timeval_to_ns(&te) - timeval_to_ns(&ts);
-	*tping = ns_to_timeval(elapsed_nsecs);
+	gb->elapsed_nsecs = timeval_to_ns(&te) - timeval_to_ns(&ts);
 
 	return retval;
 }
@@ -324,7 +314,6 @@ static void gb_loopback_reset_stats(struct gb_loopback *gb)
 	memcpy(&gb->throughput, &reset, sizeof(struct gb_loopback_stats));
 	memcpy(&gb->requests_per_second, &reset,
 	       sizeof(struct gb_loopback_stats));
-	memset(&gb->ts, 0, sizeof(struct timeval));
 }
 
 static void gb_loopback_update_stats(struct gb_loopback_stats *stats, u64 val)
@@ -375,8 +364,7 @@ static void gb_loopback_throughput_update(struct gb_loopback *gb, u32 latency)
 	gb_loopback_update_stats(&gb->throughput, throughput);
 }
 
-static void gb_loopback_calculate_stats(struct gb_loopback *gb,
-					struct timeval *tlat)
+static void gb_loopback_calculate_stats(struct gb_loopback *gb)
 {
 	u32 lat;
 	u64 tmp;
@@ -397,7 +385,6 @@ static void gb_loopback_calculate_stats(struct gb_loopback *gb,
 static int gb_loopback_fn(void *data)
 {
 	int error = 0;
-	struct timeval tlat = {0, 0};
 	struct gb_loopback *gb = (struct gb_loopback *)data;
 
 	while (1) {
@@ -416,21 +403,15 @@ static int gb_loopback_fn(void *data)
 				continue;
 			}
 		}
-		if (gb->ts.tv_usec == 0 && gb->ts.tv_sec == 0)
-			do_gettimeofday(&gb->ts);
 		if (gb->type == GB_LOOPBACK_TYPE_PING)
-			error = gb_loopback_ping(gb, &tlat);
+			error = gb_loopback_ping(gb);
 		else if (gb->type == GB_LOOPBACK_TYPE_TRANSFER)
-			error = gb_loopback_transfer(gb, &tlat, gb->size);
+			error = gb_loopback_transfer(gb, gb->size);
 		else if (gb->type == GB_LOOPBACK_TYPE_SINK)
-			error = gb_loopback_sink(gb, &tlat, gb->size);
+			error = gb_loopback_sink(gb, gb->size);
 		if (error)
 			gb->error++;
-		do_gettimeofday(&gb->te);
-		gb->elapsed_nsecs = timeval_to_ns(&gb->te) -
-					timeval_to_ns(&gb->ts);
-		gb_loopback_calculate_stats(gb, &tlat);
-		gb->ts = gb->te;
+		gb_loopback_calculate_stats(gb);
 		if (gb->ms_wait)
 			msleep(gb->ms_wait);
 	}

commit 3dfe8aaaeede22b0601c95cf1a4c2eadcb3851ba
Author: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
Date:   Fri Jul 24 10:02:56 2015 +0100

    greybus: loopback: convert loopback wake/sleep to a waitqueue
    
    Current code will incrementally poll for gb->type == 0 and sleep.
    This type of polling strategy wastes cycles.
    
    This patch changes the sleep strategy by introducing a wait-queue which
    waits for gb->type != 0 or kthread_should_stop() to wake-up and work or
    to wake-up and terminate.
    
    Signed-off-by: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/loopback.c b/drivers/staging/greybus/loopback.c
index 08f0bee198c2..229494833a16 100644
--- a/drivers/staging/greybus/loopback.c
+++ b/drivers/staging/greybus/loopback.c
@@ -31,6 +31,7 @@ struct gb_loopback {
 	u8 version_minor;
 
 	struct task_struct *task;
+	wait_queue_head_t wq;
 
 	int type;
 	u32 size;
@@ -113,22 +114,24 @@ static DEVICE_ATTR_RW(field)
 static void gb_loopback_reset_stats(struct gb_loopback *gb);
 static void gb_loopback_check_attr(struct gb_loopback *gb)
 {
+	if (gb->ms_wait > GB_LOOPBACK_MS_WAIT_MAX)
+		gb->ms_wait = GB_LOOPBACK_MS_WAIT_MAX;
+	if (gb->size > gb->size_max)
+		gb->size = gb->size_max;
+	gb->error = 0;
+	gb->iteration_count = 0;
+	gb_loopback_reset_stats(gb);
+
 	switch (gb->type) {
 	case GB_LOOPBACK_TYPE_PING:
 	case GB_LOOPBACK_TYPE_TRANSFER:
 	case GB_LOOPBACK_TYPE_SINK:
+		wake_up(&gb->wq);
 		break;
 	default:
 		gb->type = 0;
 		break;
 	}
-	if (gb->ms_wait > GB_LOOPBACK_MS_WAIT_MAX)
-		gb->ms_wait = GB_LOOPBACK_MS_WAIT_MAX;
-	if (gb->size > gb->size_max)
-		gb->size = gb->size_max;
-	gb->error = 0;
-	gb->iteration_count = 0;
-	gb_loopback_reset_stats(gb);
 }
 
 /* Time to send and receive one message */
@@ -397,11 +400,12 @@ static int gb_loopback_fn(void *data)
 	struct timeval tlat = {0, 0};
 	struct gb_loopback *gb = (struct gb_loopback *)data;
 
-	while (!kthread_should_stop()) {
-		if (!gb->type) {
-			msleep(1000);
-			continue;
-		}
+	while (1) {
+		if (!gb->type)
+			wait_event_interruptible(gb->wq, gb->type ||
+						 kthread_should_stop());
+		if (kthread_should_stop())
+			break;
 		if (gb->iteration_max) {
 			if (gb->iteration_count < gb->iteration_max) {
 				gb->iteration_count++;
@@ -429,7 +433,6 @@ static int gb_loopback_fn(void *data)
 		gb->ts = gb->te;
 		if (gb->ms_wait)
 			msleep(gb->ms_wait);
-
 	}
 	return 0;
 }
@@ -463,6 +466,7 @@ static int gb_loopback_connection_init(struct gb_connection *connection)
 	gb->size_max -= sizeof(struct gb_loopback_transfer_request);
 
 	gb_loopback_reset_stats(gb);
+	init_waitqueue_head(&gb->wq);
 	gb->task = kthread_run(gb_loopback_fn, gb, "gb_loopback");
 	if (IS_ERR(gb->task)) {
 		retval = PTR_ERR(gb->task);

commit c2939f41bca86d30388e6fa48e469a4e748b71e2
Author: Greg Kroah-Hartman <gregkh@google.com>
Date:   Wed Jul 22 11:09:23 2015 -0700

    greybus: loopback: add poll support to the iteration_count sysfs file
    
    This adds the ability to poll on "iteration_count" in sysfs and be woken
    up when it changes, saving some cycles constantly hammering on the file
    waiting for it to change.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>
    Tested-by: Bryan O'Donoghue <bryan.odonoghue@linaro.org>

diff --git a/drivers/staging/greybus/loopback.c b/drivers/staging/greybus/loopback.c
index 50eacd1e11a3..08f0bee198c2 100644
--- a/drivers/staging/greybus/loopback.c
+++ b/drivers/staging/greybus/loopback.c
@@ -141,7 +141,6 @@ gb_loopback_stats_attrs(throughput);
 gb_loopback_ro_attr(error, d);
 /* The current index of the for (i = 0; i < iteration_max; i++) loop */
 gb_loopback_ro_attr(iteration_count, u);
-/* TODO iteration_count might be better with the KOBJ_CHANGE event */
 
 /*
  * Type of loopback message to send based on protocol type definitions
@@ -406,6 +405,8 @@ static int gb_loopback_fn(void *data)
 		if (gb->iteration_max) {
 			if (gb->iteration_count < gb->iteration_max) {
 				gb->iteration_count++;
+				sysfs_notify(&gb->connection->dev.kobj, NULL,
+					     "iteration_count");
 			} else {
 				gb->type = 0;
 				continue;

commit 583cbf50e0a4c8918811f245860922353420a378
Author: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
Date:   Tue Jul 21 23:50:10 2015 +0100

    greybus: loopback: rename frequency to requests
    
    The name frequency does not adequately describe the data-point tracking the
    number of greybus operations performed in a second by the loopback code.
    Firmware team is moving towards calling this variable requests-per-second
    or similar. This patch renames to keep the namespace consistent.
    
    Signed-off-by: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
    Reviewed-by: Patrick Titiano <ptitiano@baylibre.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/loopback.c b/drivers/staging/greybus/loopback.c
index cc19f1be7e2f..50eacd1e11a3 100644
--- a/drivers/staging/greybus/loopback.c
+++ b/drivers/staging/greybus/loopback.c
@@ -41,7 +41,7 @@ struct gb_loopback {
 
 	struct gb_loopback_stats latency;
 	struct gb_loopback_stats throughput;
-	struct gb_loopback_stats frequency;
+	struct gb_loopback_stats requests_per_second;
 	struct timeval ts;
 	struct timeval te;
 	u64 elapsed_nsecs;
@@ -133,8 +133,8 @@ static void gb_loopback_check_attr(struct gb_loopback *gb)
 
 /* Time to send and receive one message */
 gb_loopback_stats_attrs(latency);
-/* Number of packet sent per second on this cport */
-gb_loopback_stats_attrs(frequency);
+/* Number of requests sent per second on this cport */
+gb_loopback_stats_attrs(requests_per_second);
 /* Quantity of data sent and received on this cport */
 gb_loopback_stats_attrs(throughput);
 /* Number of errors encountered during loop */
@@ -166,7 +166,7 @@ gb_loopback_attr(iteration_max, u);
 
 static struct attribute *loopback_attrs[] = {
 	dev_stats_attrs(latency),
-	dev_stats_attrs(frequency),
+	dev_stats_attrs(requests_per_second),
 	dev_stats_attrs(throughput),
 	&dev_attr_type.attr,
 	&dev_attr_size.attr,
@@ -320,7 +320,8 @@ static void gb_loopback_reset_stats(struct gb_loopback *gb)
 	};
 	memcpy(&gb->latency, &reset, sizeof(struct gb_loopback_stats));
 	memcpy(&gb->throughput, &reset, sizeof(struct gb_loopback_stats));
-	memcpy(&gb->frequency, &reset, sizeof(struct gb_loopback_stats));
+	memcpy(&gb->requests_per_second, &reset,
+	       sizeof(struct gb_loopback_stats));
 	memset(&gb->ts, 0, sizeof(struct timeval));
 }
 
@@ -336,12 +337,12 @@ static void gb_loopback_update_stats(struct gb_loopback_stats *stats, u64 val)
 	do_div(stats->avg, stats->count);
 }
 
-static void gb_loopback_frequency_update(struct gb_loopback *gb, u32 latency)
+static void gb_loopback_requests_update(struct gb_loopback *gb, u32 latency)
 {
-	u32 freq = USEC_PER_SEC;
+	u32 req = USEC_PER_SEC;
 
-	do_div(freq, latency);
-	gb_loopback_update_stats(&gb->frequency, freq);
+	do_div(req, latency);
+	gb_loopback_update_stats(&gb->requests_per_second, req);
 }
 
 static void gb_loopback_throughput_update(struct gb_loopback *gb, u32 latency)
@@ -386,9 +387,9 @@ static void gb_loopback_calculate_stats(struct gb_loopback *gb,
 	/* Log latency stastic */
 	gb_loopback_update_stats(&gb->latency, lat);
 
-	/* Log throughput and frequency using latency as benchmark */
+	/* Log throughput and requests using latency as benchmark */
 	gb_loopback_throughput_update(gb, lat);
-	gb_loopback_frequency_update(gb, lat);
+	gb_loopback_requests_update(gb, lat);
 }
 
 static int gb_loopback_fn(void *data)

commit e140c75ed9f6897c682e7ac321ef64948f005e64
Author: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
Date:   Tue Jul 21 23:50:09 2015 +0100

    greybus: loopback: add commentary to sysfs variables
    
    Add some missing comments.
    Add a TODO to look at doing iteration_count with KOBJ_CHANGE event instead
    of having user-space poll the value reported in iteration_count to
    determine when a test set is complete.
    
    Signed-off-by: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
    Reviewed-by: Patrick Titiano <ptitiano@baylibre.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/loopback.c b/drivers/staging/greybus/loopback.c
index 65973948a091..cc19f1be7e2f 100644
--- a/drivers/staging/greybus/loopback.c
+++ b/drivers/staging/greybus/loopback.c
@@ -137,8 +137,11 @@ gb_loopback_stats_attrs(latency);
 gb_loopback_stats_attrs(frequency);
 /* Quantity of data sent and received on this cport */
 gb_loopback_stats_attrs(throughput);
+/* Number of errors encountered during loop */
 gb_loopback_ro_attr(error, d);
+/* The current index of the for (i = 0; i < iteration_max; i++) loop */
 gb_loopback_ro_attr(iteration_count, u);
+/* TODO iteration_count might be better with the KOBJ_CHANGE event */
 
 /*
  * Type of loopback message to send based on protocol type definitions

commit 00af6583d15038cfaa81a99632122b67d49de403
Author: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
Date:   Tue Jul 21 23:50:08 2015 +0100

    greybus: loopback: run operations a set number of times
    
    In order to extract a meaningful set of data out of loopback metrics it
    makes sense to have the ability to specify how many times a loopback
    operation should run and then to stop when the threshold is hit.
    
    This will allow exactly the same loopback data pattern to be run again and
    again, which is a fundamental prerequisite to instrumenting and
    characterizing the loopback interface over time.
    
    This patch introduces a simple sysfs controlled variable iteration_max.
    iteration_max is the maximum number of iterations to run for a given set.
    iteration_count is used internally to count from zero to iteration_max
    if-and-only-if iteration_max is non zero. If iteration_max is zero then the
    original behaviour of running the test command ad infinitum is maintained.
    User-space should incrementally poll the iteration_count to determine when
    the sequence is finished.
    
    To accomplish this we move away from running as many commands as possible
    in a one second window and instead run a fixed number of commands and log
    the time it takes for those commands to complete in aggregate. Since we are
    no longer resetting counters every one second, the tracker variables have
    been moved from u32 to u64 to allow for reasonably long tests to gather
    reasonably large amounts of data, without fear of over-flowing the
    data-points.
    
    Signed-off-by: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/loopback.c b/drivers/staging/greybus/loopback.c
index 66385c91673e..65973948a091 100644
--- a/drivers/staging/greybus/loopback.c
+++ b/drivers/staging/greybus/loopback.c
@@ -18,11 +18,11 @@
 #include "greybus.h"
 
 struct gb_loopback_stats {
-	u32 min;
-	u32 max;
-	u32 avg;
-	u32 sum;
-	u32 count;
+	u64 min;
+	u64 max;
+	u64 avg;
+	u64 sum;
+	u64 count;
 };
 
 struct gb_loopback {
@@ -34,6 +34,8 @@ struct gb_loopback {
 
 	int type;
 	u32 size;
+	u32 iteration_max;
+	u32 iteration_count;
 	size_t size_max;
 	int ms_wait;
 
@@ -77,9 +79,9 @@ static ssize_t name##_##field##_show(struct device *dev,		\
 static DEVICE_ATTR_RO(name##_##field)
 
 #define gb_loopback_stats_attrs(field)					\
-	gb_loopback_ro_stats_attr(field, min, d);			\
-	gb_loopback_ro_stats_attr(field, max, d);			\
-	gb_loopback_ro_stats_attr(field, avg, d);
+	gb_loopback_ro_stats_attr(field, min, llu);			\
+	gb_loopback_ro_stats_attr(field, max, llu);			\
+	gb_loopback_ro_stats_attr(field, avg, llu);
 
 #define gb_loopback_attr(field, type)					\
 static ssize_t field##_show(struct device *dev,				\
@@ -125,6 +127,7 @@ static void gb_loopback_check_attr(struct gb_loopback *gb)
 	if (gb->size > gb->size_max)
 		gb->size = gb->size_max;
 	gb->error = 0;
+	gb->iteration_count = 0;
 	gb_loopback_reset_stats(gb);
 }
 
@@ -135,6 +138,7 @@ gb_loopback_stats_attrs(frequency);
 /* Quantity of data sent and received on this cport */
 gb_loopback_stats_attrs(throughput);
 gb_loopback_ro_attr(error, d);
+gb_loopback_ro_attr(iteration_count, u);
 
 /*
  * Type of loopback message to send based on protocol type definitions
@@ -149,6 +153,8 @@ gb_loopback_attr(type, d);
 gb_loopback_attr(size, u);
 /* Time to wait between two messages: 0-1000 ms */
 gb_loopback_attr(ms_wait, d);
+/* Maximum iterations for a given operation: 1-(2^32-1), 0 implies infinite */
+gb_loopback_attr(iteration_max, u);
 
 #define dev_stats_attrs(name)						\
 	&dev_attr_##name##_min.attr,					\
@@ -162,6 +168,8 @@ static struct attribute *loopback_attrs[] = {
 	&dev_attr_type.attr,
 	&dev_attr_size.attr,
 	&dev_attr_ms_wait.attr,
+	&dev_attr_iteration_count.attr,
+	&dev_attr_iteration_max.attr,
 	&dev_attr_error.attr,
 	NULL,
 };
@@ -313,38 +321,29 @@ static void gb_loopback_reset_stats(struct gb_loopback *gb)
 	memset(&gb->ts, 0, sizeof(struct timeval));
 }
 
-static void gb_loopback_update_stats(struct gb_loopback_stats *stats,
-					u64 elapsed_nsecs)
+static void gb_loopback_update_stats(struct gb_loopback_stats *stats, u64 val)
 {
-	u32 avg;
-	u64 tmp;
-
-	if (elapsed_nsecs >= NSEC_PER_SEC) {
-		if (!stats->count) {
-			tmp = elapsed_nsecs;
-			do_div(tmp, NSEC_PER_SEC);
-			avg = stats->sum * tmp;
-		} else {
-			avg = stats->sum / stats->count;
-		}
-		if (stats->min > avg)
-			stats->min = avg;
-		if (stats->max < avg)
-			stats->max = avg;
-		stats->avg = avg;
-		stats->count = 0;
-		stats->sum = 0;
-	}
+	if (stats->min > val)
+		stats->min = val;
+	if (stats->max < val)
+		stats->max = val;
+	stats->sum += val;
+	stats->count++;
+	stats->avg = stats->sum;
+	do_div(stats->avg, stats->count);
 }
 
-static void gb_loopback_freq_update(struct gb_loopback *gb)
+static void gb_loopback_frequency_update(struct gb_loopback *gb, u32 latency)
 {
-	gb->frequency.sum++;
-	gb_loopback_update_stats(&gb->frequency, gb->elapsed_nsecs);
+	u32 freq = USEC_PER_SEC;
+
+	do_div(freq, latency);
+	gb_loopback_update_stats(&gb->frequency, freq);
 }
 
-static void gb_loopback_throughput_update(struct gb_loopback *gb)
+static void gb_loopback_throughput_update(struct gb_loopback *gb, u32 latency)
 {
+	u32 throughput;
 	u32 aggregate_size = sizeof(struct gb_operation_msg_hdr) * 2;
 
 	switch (gb->type) {
@@ -362,27 +361,31 @@ static void gb_loopback_throughput_update(struct gb_loopback *gb)
 	default:
 		return;
 	}
-	gb->throughput.sum += aggregate_size;
-	gb_loopback_update_stats(&gb->throughput, gb->elapsed_nsecs);
+
+	/* Calculate bytes per second */
+	throughput = USEC_PER_SEC;
+	do_div(throughput, latency);
+	throughput *= aggregate_size;
+	gb_loopback_update_stats(&gb->throughput, throughput);
 }
 
-static void gb_loopback_latency_update(struct gb_loopback *gb,
+static void gb_loopback_calculate_stats(struct gb_loopback *gb,
 					struct timeval *tlat)
 {
 	u32 lat;
 	u64 tmp;
 
-	tmp = timeval_to_ns(tlat);
-	do_div(tmp, NSEC_PER_MSEC);
+	/* Express latency in terms of microseconds */
+	tmp = gb->elapsed_nsecs;
+	do_div(tmp, NSEC_PER_USEC);
 	lat = tmp;
 
-	if (gb->latency.min > lat)
-		gb->latency.min = lat;
-	if (gb->latency.max < lat)
-		gb->latency.max = lat;
-	gb->latency.sum += lat;
-	gb->latency.count++;
-	gb_loopback_update_stats(&gb->latency, gb->elapsed_nsecs);
+	/* Log latency stastic */
+	gb_loopback_update_stats(&gb->latency, lat);
+
+	/* Log throughput and frequency using latency as benchmark */
+	gb_loopback_throughput_update(gb, lat);
+	gb_loopback_frequency_update(gb, lat);
 }
 
 static int gb_loopback_fn(void *data)
@@ -396,6 +399,14 @@ static int gb_loopback_fn(void *data)
 			msleep(1000);
 			continue;
 		}
+		if (gb->iteration_max) {
+			if (gb->iteration_count < gb->iteration_max) {
+				gb->iteration_count++;
+			} else {
+				gb->type = 0;
+				continue;
+			}
+		}
 		if (gb->ts.tv_usec == 0 && gb->ts.tv_sec == 0)
 			do_gettimeofday(&gb->ts);
 		if (gb->type == GB_LOOPBACK_TYPE_PING)
@@ -409,11 +420,8 @@ static int gb_loopback_fn(void *data)
 		do_gettimeofday(&gb->te);
 		gb->elapsed_nsecs = timeval_to_ns(&gb->te) -
 					timeval_to_ns(&gb->ts);
-		gb_loopback_freq_update(gb);
-		gb_loopback_throughput_update(gb);
-		gb_loopback_latency_update(gb, &tlat);
-		if (gb->elapsed_nsecs >= NSEC_PER_SEC)
-			gb->ts = gb->te;
+		gb_loopback_calculate_stats(gb, &tlat);
+		gb->ts = gb->te;
 		if (gb->ms_wait)
 			msleep(gb->ms_wait);
 

commit 799a3f03572afa77913f2adc136c87a4b0c64850
Author: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
Date:   Tue Jul 21 23:50:07 2015 +0100

    greybus: loopback: update loopback operation description comment
    
    Old comment needs updating to match 8a282c411ba0 ('greybus/loopback: make
    loopback type input equivalent to protocol type')
    
    Signed-off-by: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
    Reviewed-by: Patrick Titiano <ptitiano@baylibre.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/loopback.c b/drivers/staging/greybus/loopback.c
index 2de939f298af..66385c91673e 100644
--- a/drivers/staging/greybus/loopback.c
+++ b/drivers/staging/greybus/loopback.c
@@ -137,10 +137,12 @@ gb_loopback_stats_attrs(throughput);
 gb_loopback_ro_attr(error, d);
 
 /*
- * Type of loopback message to send
+ * Type of loopback message to send based on protocol type definitions
  * 0 => Don't send message
- * 1 => Send ping message continuously (message without payload)
- * 2 => Send transer message continuously (message with payload)
+ * 2 => Send ping message continuously (message without payload)
+ * 3 => Send transer message continuously (message with payload,
+ *					   payload returned in response)
+ * 4 => Send a sink message (message with payload, no payload in response)
  */
 gb_loopback_attr(type, d);
 /* Size of transfer message payload: 0-4096 bytes */

commit 3156be7deec47564853d13308090828c35f89cb9
Author: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
Date:   Tue Jul 21 23:50:06 2015 +0100

    greybus: loopback: timestamp seeding should not drop metrics
    
    In the current code if the ts variable is not initialized then any data
    already gathered in a previous loopback command is dropped instead of
    logged. Also the timestamping of ts is done after the greybus operation.
    
    This delayed time-stamping means that the delta between the before and
    after timestamps is incorrect and if a delay in-between loopback operations
    has been specified by the user, the ts timestamp will be very skewed
    indeed.
    
    - Move the ts initialization directly before the greybus operation.
    - Remove the continue statement on first initialization of the ts variable.
    
    Signed-off-by: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/loopback.c b/drivers/staging/greybus/loopback.c
index fe3a57bff99c..2de939f298af 100644
--- a/drivers/staging/greybus/loopback.c
+++ b/drivers/staging/greybus/loopback.c
@@ -394,6 +394,8 @@ static int gb_loopback_fn(void *data)
 			msleep(1000);
 			continue;
 		}
+		if (gb->ts.tv_usec == 0 && gb->ts.tv_sec == 0)
+			do_gettimeofday(&gb->ts);
 		if (gb->type == GB_LOOPBACK_TYPE_PING)
 			error = gb_loopback_ping(gb, &tlat);
 		else if (gb->type == GB_LOOPBACK_TYPE_TRANSFER)
@@ -402,10 +404,6 @@ static int gb_loopback_fn(void *data)
 			error = gb_loopback_sink(gb, &tlat, gb->size);
 		if (error)
 			gb->error++;
-		if (gb->ts.tv_usec == 0 && gb->ts.tv_sec == 0) {
-			do_gettimeofday(&gb->ts);
-			continue;
-		}
 		do_gettimeofday(&gb->te);
 		gb->elapsed_nsecs = timeval_to_ns(&gb->te) -
 					timeval_to_ns(&gb->ts);

commit 1c7658cf5165586acff901b7e6ef27d8d5f2818d
Author: Johan Hovold <johan@hovoldconsulting.com>
Date:   Fri Jul 17 18:50:25 2015 +0200

    greybus: operation: fix atomic response allocation
    
    Response allocation also needs a GFP-flags argument as a response is
    allocated as part of an outgoing operation.
    
    Fixes: 9aa174d202e5 ("operation: allow atomic operation allocations")
    Signed-off-by: Johan Hovold <johan@hovoldconsulting.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/loopback.c b/drivers/staging/greybus/loopback.c
index f07fc0a837d5..fe3a57bff99c 100644
--- a/drivers/staging/greybus/loopback.c
+++ b/drivers/staging/greybus/loopback.c
@@ -283,7 +283,8 @@ static int gb_loopback_request_recv(u8 type, struct gb_operation *operation)
 		}
 
 		if (len) {
-			if (!gb_operation_response_alloc(operation, len)) {
+			if (!gb_operation_response_alloc(operation, len,
+							 GFP_KERNEL)) {
 				dev_err(&connection->dev,
 					"error allocating response\n");
 				return -ENOMEM;

commit e51eafebf83b236d4d43ed13b809c504e2d38d54
Author: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
Date:   Tue Jul 14 00:53:13 2015 +0100

    greybus: loopback: fix 64bit printf format error
    
    Last patchset missed compilation on 64 bit contained warning.
    
    Signed-off-by: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/loopback.c b/drivers/staging/greybus/loopback.c
index b92232b7a881..f07fc0a837d5 100644
--- a/drivers/staging/greybus/loopback.c
+++ b/drivers/staging/greybus/loopback.c
@@ -34,7 +34,7 @@ struct gb_loopback {
 
 	int type;
 	u32 size;
-	u32 size_max;
+	size_t size_max;
 	int ms_wait;
 
 	struct gb_loopback_stats latency;
@@ -254,7 +254,7 @@ static int gb_loopback_request_recv(u8 type, struct gb_operation *operation)
 	struct gb_loopback *gb = connection->private;
 	struct gb_loopback_transfer_request *request;
 	struct gb_loopback_transfer_response *response;
-	u32 len;
+	size_t len;
 
 	/* By convention, the AP initiates the version operation */
 	switch (type) {

commit f7908e4d6def2cbeb16af29abceb1c6944d91f0c
Author: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
Date:   Mon Jul 13 20:20:51 2015 +0100

    greybus: loopback: update throughput metrics to improve granularity
    
    Throughput capture should account for the entire size of the data going out
    on the wire. In addition throughput should be captured for each supported
    loopback operation.
    
    Signed-off-by: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/loopback.c b/drivers/staging/greybus/loopback.c
index f490648648ce..b92232b7a881 100644
--- a/drivers/staging/greybus/loopback.c
+++ b/drivers/staging/greybus/loopback.c
@@ -340,10 +340,26 @@ static void gb_loopback_freq_update(struct gb_loopback *gb)
 	gb_loopback_update_stats(&gb->frequency, gb->elapsed_nsecs);
 }
 
-static void gb_loopback_bw_update(struct gb_loopback *gb, int error)
+static void gb_loopback_throughput_update(struct gb_loopback *gb)
 {
-	if (!error)
-		gb->throughput.sum += gb->size * 2;
+	u32 aggregate_size = sizeof(struct gb_operation_msg_hdr) * 2;
+
+	switch (gb->type) {
+	case GB_LOOPBACK_TYPE_PING:
+		break;
+	case GB_LOOPBACK_TYPE_SINK:
+		aggregate_size += sizeof(struct gb_loopback_transfer_request) +
+				  gb->size;
+		break;
+	case GB_LOOPBACK_TYPE_TRANSFER:
+		aggregate_size += sizeof(struct gb_loopback_transfer_request) +
+				  sizeof(struct gb_loopback_transfer_response) +
+				  gb->size * 2;
+		break;
+	default:
+		return;
+	}
+	gb->throughput.sum += aggregate_size;
 	gb_loopback_update_stats(&gb->throughput, gb->elapsed_nsecs);
 }
 
@@ -393,8 +409,7 @@ static int gb_loopback_fn(void *data)
 		gb->elapsed_nsecs = timeval_to_ns(&gb->te) -
 					timeval_to_ns(&gb->ts);
 		gb_loopback_freq_update(gb);
-		if (gb->type == GB_LOOPBACK_TYPE_PING)
-			gb_loopback_bw_update(gb, error);
+		gb_loopback_throughput_update(gb);
 		gb_loopback_latency_update(gb, &tlat);
 		if (gb->elapsed_nsecs >= NSEC_PER_SEC)
 			gb->ts = gb->te;

commit c3bba87a7ab57e636a8c96ddd36fdedfefe4848c
Author: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
Date:   Mon Jul 13 20:20:50 2015 +0100

    greybus: loopback: truncate maximum loop data to link size
    
    Get maximum payload by way of gb_operation_get_payload_size_max() and
    truncate any requested loopback size greater than this value. RX of data
    from firmware over the specified size will not be accepted.
    
    Signed-off-by: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/loopback.c b/drivers/staging/greybus/loopback.c
index 678690fbbc93..f490648648ce 100644
--- a/drivers/staging/greybus/loopback.c
+++ b/drivers/staging/greybus/loopback.c
@@ -34,6 +34,7 @@ struct gb_loopback {
 
 	int type;
 	u32 size;
+	u32 size_max;
 	int ms_wait;
 
 	struct gb_loopback_stats latency;
@@ -46,7 +47,6 @@ struct gb_loopback {
 };
 
 #define GB_LOOPBACK_MS_WAIT_MAX				1000
-#define GB_LOOPBACK_SIZE_MAX				SZ_4K
 
 /* Define get_version() routine */
 define_get_version(gb_loopback, LOOPBACK);
@@ -122,8 +122,8 @@ static void gb_loopback_check_attr(struct gb_loopback *gb)
 	}
 	if (gb->ms_wait > GB_LOOPBACK_MS_WAIT_MAX)
 		gb->ms_wait = GB_LOOPBACK_MS_WAIT_MAX;
-	if (gb->size > GB_LOOPBACK_SIZE_MAX)
-		gb->size = GB_LOOPBACK_SIZE_MAX;
+	if (gb->size > gb->size_max)
+		gb->size = gb->size_max;
 	gb->error = 0;
 	gb_loopback_reset_stats(gb);
 }
@@ -182,6 +182,7 @@ static int gb_loopback_sink(struct gb_loopback *gb,
 	do_gettimeofday(&ts);
 	retval = gb_operation_sync(gb->connection, GB_LOOPBACK_TYPE_SINK,
 				   request, len + sizeof(*request), NULL, 0);
+
 	do_gettimeofday(&te);
 	elapsed_nsecs = timeval_to_ns(&te) - timeval_to_ns(&ts);
 	*tping = ns_to_timeval(elapsed_nsecs);
@@ -250,6 +251,7 @@ static int gb_loopback_ping(struct gb_loopback *gb, struct timeval *tping)
 static int gb_loopback_request_recv(u8 type, struct gb_operation *operation)
 {
 	struct gb_connection *connection = operation->connection;
+	struct gb_loopback *gb = connection->private;
 	struct gb_loopback_transfer_request *request;
 	struct gb_loopback_transfer_response *response;
 	u32 len;
@@ -273,6 +275,13 @@ static int gb_loopback_request_recv(u8 type, struct gb_operation *operation)
 		}
 		request = operation->request->payload;
 		len = le32_to_cpu(request->len);
+		if (len > gb->size_max) {
+			dev_err(&connection->dev,
+				"transfer request too large (%zu > %zu)\n",
+				len, gb->size_max);
+			return -EINVAL;
+		}
+
 		if (len) {
 			if (!gb_operation_response_alloc(operation, len)) {
 				dev_err(&connection->dev,
@@ -416,6 +425,14 @@ static int gb_loopback_connection_init(struct gb_connection *connection)
 	if (retval)
 		goto out_get_ver;
 
+	/* Calculate maximum payload */
+	gb->size_max = gb_operation_get_payload_size_max(connection);
+	if (gb->size_max <= sizeof(struct gb_loopback_transfer_request)) {
+		retval = -EINVAL;
+		goto out_get_ver;
+	}
+	gb->size_max -= sizeof(struct gb_loopback_transfer_request);
+
 	gb_loopback_reset_stats(gb);
 	gb->task = kthread_run(gb_loopback_fn, gb, "gb_loopback");
 	if (IS_ERR(gb->task)) {

commit 384a7a3c4f8bf96a6b2e0bddafec41f929b50958
Author: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
Date:   Mon Jul 13 20:20:49 2015 +0100

    greybus: loopback: add sink to loopback protocol
    
    Loopback sink command will operate as an amalgam of the ping and tranfer
    operations. Sink will send an ACK'd variable size operation over greybus.
    Unlike the transfer type which transmits the received data back, the sink
    type will simply ACK without sending the received data back.
    
    This patch adds the kernel side of the sink command.
    
    Signed-off-by: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/loopback.c b/drivers/staging/greybus/loopback.c
index bdbebd6dbede..678690fbbc93 100644
--- a/drivers/staging/greybus/loopback.c
+++ b/drivers/staging/greybus/loopback.c
@@ -114,6 +114,7 @@ static void gb_loopback_check_attr(struct gb_loopback *gb)
 	switch (gb->type) {
 	case GB_LOOPBACK_TYPE_PING:
 	case GB_LOOPBACK_TYPE_TRANSFER:
+	case GB_LOOPBACK_TYPE_SINK:
 		break;
 	default:
 		gb->type = 0;
@@ -164,6 +165,31 @@ static struct attribute *loopback_attrs[] = {
 };
 ATTRIBUTE_GROUPS(loopback);
 
+static int gb_loopback_sink(struct gb_loopback *gb,
+				struct timeval *tping, u32 len)
+{
+	struct timeval ts, te;
+	u64 elapsed_nsecs;
+	struct gb_loopback_transfer_request *request;
+	int retval;
+
+	request = kmalloc(len + sizeof(*request), GFP_KERNEL);
+	if (!request)
+		return -ENOMEM;
+
+	request->len = cpu_to_le32(len);
+
+	do_gettimeofday(&ts);
+	retval = gb_operation_sync(gb->connection, GB_LOOPBACK_TYPE_SINK,
+				   request, len + sizeof(*request), NULL, 0);
+	do_gettimeofday(&te);
+	elapsed_nsecs = timeval_to_ns(&te) - timeval_to_ns(&ts);
+	*tping = ns_to_timeval(elapsed_nsecs);
+
+	kfree(request);
+	return retval;
+}
+
 static int gb_loopback_transfer(struct gb_loopback *gb,
 				struct timeval *tping, u32 len)
 {
@@ -235,6 +261,7 @@ static int gb_loopback_request_recv(u8 type, struct gb_operation *operation)
 			"module-initiated version operation\n");
 		return -EINVAL;
 	case GB_LOOPBACK_TYPE_PING:
+	case GB_LOOPBACK_TYPE_SINK:
 		return 0;
 	case GB_LOOPBACK_TYPE_TRANSFER:
 		if (operation->request->payload_size < sizeof(*request)) {
@@ -345,6 +372,8 @@ static int gb_loopback_fn(void *data)
 			error = gb_loopback_ping(gb, &tlat);
 		else if (gb->type == GB_LOOPBACK_TYPE_TRANSFER)
 			error = gb_loopback_transfer(gb, &tlat, gb->size);
+		else if (gb->type == GB_LOOPBACK_TYPE_SINK)
+			error = gb_loopback_sink(gb, &tlat, gb->size);
 		if (error)
 			gb->error++;
 		if (gb->ts.tv_usec == 0 && gb->ts.tv_sec == 0) {

commit a598f4384d9e95532781adc316793983ed27139d
Author: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
Date:   Mon Jul 13 20:20:48 2015 +0100

    greybus: loopback: make loopback type input equivalent to protocol type
    
    Sepcifying loopback operation type with a type value that is internal to
    the loopback driver is non-intunitive and requires reading code to
    understand. Remove confusing duplicate definitions and update code to
    accept the greybus-specification function identity defintiions as the
    appropriate type values for initiating loopback operations.
    
    See greybus-spec section 10.16.1 'Greybus Loopback Message Types' for a
    full list of valid messages to set this type field to.
    
    Signed-off-by: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/loopback.c b/drivers/staging/greybus/loopback.c
index 6cd4acf93bf6..bdbebd6dbede 100644
--- a/drivers/staging/greybus/loopback.c
+++ b/drivers/staging/greybus/loopback.c
@@ -45,12 +45,6 @@ struct gb_loopback {
 	u32 error;
 };
 
-/* Current function (type of traffic generated by the loopback thread) */
-#define GB_LOOPBACK_FN_NONE				0x00
-#define GB_LOOPBACK_FN_PING				0x01
-#define GB_LOOPBACK_FN_XFER				0x02
-#define GB_LOOPBACK_FN_COUNT				0x03
-
 #define GB_LOOPBACK_MS_WAIT_MAX				1000
 #define GB_LOOPBACK_SIZE_MAX				SZ_4K
 
@@ -117,10 +111,16 @@ static DEVICE_ATTR_RW(field)
 static void gb_loopback_reset_stats(struct gb_loopback *gb);
 static void gb_loopback_check_attr(struct gb_loopback *gb)
 {
+	switch (gb->type) {
+	case GB_LOOPBACK_TYPE_PING:
+	case GB_LOOPBACK_TYPE_TRANSFER:
+		break;
+	default:
+		gb->type = 0;
+		break;
+	}
 	if (gb->ms_wait > GB_LOOPBACK_MS_WAIT_MAX)
 		gb->ms_wait = GB_LOOPBACK_MS_WAIT_MAX;
-	if (gb->type >= GB_LOOPBACK_FN_COUNT)
-		gb->type = GB_LOOPBACK_FN_NONE;
 	if (gb->size > GB_LOOPBACK_SIZE_MAX)
 		gb->size = GB_LOOPBACK_SIZE_MAX;
 	gb->error = 0;
@@ -337,13 +337,13 @@ static int gb_loopback_fn(void *data)
 	struct gb_loopback *gb = (struct gb_loopback *)data;
 
 	while (!kthread_should_stop()) {
-		if (gb->type == GB_LOOPBACK_FN_NONE) {
+		if (!gb->type) {
 			msleep(1000);
 			continue;
 		}
-		if (gb->type == GB_LOOPBACK_FN_PING)
+		if (gb->type == GB_LOOPBACK_TYPE_PING)
 			error = gb_loopback_ping(gb, &tlat);
-		else if (gb->type == GB_LOOPBACK_FN_XFER)
+		else if (gb->type == GB_LOOPBACK_TYPE_TRANSFER)
 			error = gb_loopback_transfer(gb, &tlat, gb->size);
 		if (error)
 			gb->error++;

commit 74a240a029fd0fa692bd857f15ceb6eda4897c5d
Author: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
Date:   Mon Jul 13 20:20:47 2015 +0100

    greybus: loopback: remove spurious pr_err in sysfs store
    
    Dangling debug code removed.
    
    Signed-off-by: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/loopback.c b/drivers/staging/greybus/loopback.c
index 9ede48058666..6cd4acf93bf6 100644
--- a/drivers/staging/greybus/loopback.c
+++ b/drivers/staging/greybus/loopback.c
@@ -107,7 +107,6 @@ static ssize_t field##_store(struct device *dev,			\
 	struct gb_loopback *gb =					\
 		(struct gb_loopback *)connection->private;		\
 	ret = sscanf(buf, "%"#type, &gb->field);			\
-	pr_err("%s = %"#type"\n", #field, gb->field);			\
 	if (ret != 1)							\
 		return -EINVAL;						\
 	gb_loopback_check_attr(gb);					\

commit a0ee3d3ea6c1b8d731ca68c78db53035862ab3ae
Author: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
Date:   Mon Jul 13 20:20:46 2015 +0100

    greybus: loopback: remove magic number in state-machine
    
    Magic number 2 used instead of define GB_LOOPBACK_TYPE_PING, remove and and
    use the define instead.
    
    Signed-off-by: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/loopback.c b/drivers/staging/greybus/loopback.c
index 59c437bdd58c..9ede48058666 100644
--- a/drivers/staging/greybus/loopback.c
+++ b/drivers/staging/greybus/loopback.c
@@ -356,7 +356,7 @@ static int gb_loopback_fn(void *data)
 		gb->elapsed_nsecs = timeval_to_ns(&gb->te) -
 					timeval_to_ns(&gb->ts);
 		gb_loopback_freq_update(gb);
-		if (gb->type == 2)
+		if (gb->type == GB_LOOPBACK_TYPE_PING)
 			gb_loopback_bw_update(gb, error);
 		gb_loopback_latency_update(gb, &tlat);
 		if (gb->elapsed_nsecs >= NSEC_PER_SEC)

commit f9f971a2e5b5094cf12480976fb1765376414eac
Author: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
Date:   Mon Jul 13 20:20:45 2015 +0100

    greybus: loopback: Move loopback operation definitions
    
    In order to have one point of type definition for gbsim move the loopback
    operation definitions to greybus_protocols.h.
    
    Signed-off-by: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/loopback.c b/drivers/staging/greybus/loopback.c
index eeec3323ad6d..59c437bdd58c 100644
--- a/drivers/staging/greybus/loopback.c
+++ b/drivers/staging/greybus/loopback.c
@@ -45,16 +45,6 @@ struct gb_loopback {
 	u32 error;
 };
 
-/* Version of the Greybus loopback protocol we support */
-#define	GB_LOOPBACK_VERSION_MAJOR			0x00
-#define	GB_LOOPBACK_VERSION_MINOR			0x01
-
-/* Greybus loopback request types */
-#define	GB_LOOPBACK_TYPE_INVALID			0x00
-#define	GB_LOOPBACK_TYPE_PROTOCOL_VERSION		0x01
-#define	GB_LOOPBACK_TYPE_PING				0x02
-#define	GB_LOOPBACK_TYPE_TRANSFER			0x03
-
 /* Current function (type of traffic generated by the loopback thread) */
 #define GB_LOOPBACK_FN_NONE				0x00
 #define GB_LOOPBACK_FN_PING				0x01
@@ -175,16 +165,6 @@ static struct attribute *loopback_attrs[] = {
 };
 ATTRIBUTE_GROUPS(loopback);
 
-struct gb_loopback_transfer_request {
-	__le32	len;
-	__u8	data[0];
-};
-
-struct gb_loopback_transfer_response {
-	__u8	data[0];
-};
-
-
 static int gb_loopback_transfer(struct gb_loopback *gb,
 				struct timeval *tping, u32 len)
 {

commit 6f8528e0bea76850a153a98e47ad60aecf112801
Author: Phong Tran <tranmanphong@gmail.com>
Date:   Thu May 14 23:03:04 2015 +0700

    greybus: loopback: add more clean up when init connection fails
    
    It should remove the object from sysfs when loopback
    connection init error.
    
    Signed-off-by: Phong Tran <tranmanphong@gmail.com>
    Reviewed-by: Alex Elder <elder@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/loopback.c b/drivers/staging/greybus/loopback.c
index 285e44b9431f..eeec3323ad6d 100644
--- a/drivers/staging/greybus/loopback.c
+++ b/drivers/staging/greybus/loopback.c
@@ -401,23 +401,25 @@ static int gb_loopback_connection_init(struct gb_connection *connection)
 	connection->private = gb;
 	retval = sysfs_create_groups(&connection->dev.kobj, loopback_groups);
 	if (retval)
-		goto error;
+		goto out_free;
 
 	/* Check the version */
 	retval = get_version(gb);
 	if (retval)
-		goto error;
+		goto out_get_ver;
 
 	gb_loopback_reset_stats(gb);
 	gb->task = kthread_run(gb_loopback_fn, gb, "gb_loopback");
 	if (IS_ERR(gb->task)) {
 		retval = PTR_ERR(gb->task);
-		goto error;
+		goto out_get_ver;
 	}
 
 	return 0;
 
-error:
+out_get_ver:
+	sysfs_remove_groups(&connection->dev.kobj, loopback_groups);
+out_free:
 	kfree(gb);
 	return retval;
 }

commit ac1c2840bd41e89d55fccabe86cf9a3e2d56a652
Author: Alex Elder <elder@linaro.org>
Date:   Mon May 11 21:16:39 2015 -0500

    greybus: loopback: support module-initiated requests
    
    There's no reason we can't support loopback pings or transfers
    initiated by the module.  Allow it.
    
    Signed-off-by: Alex Elder <elder@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/loopback.c b/drivers/staging/greybus/loopback.c
index decaf71fb6e4..285e44b9431f 100644
--- a/drivers/staging/greybus/loopback.c
+++ b/drivers/staging/greybus/loopback.c
@@ -242,6 +242,48 @@ static int gb_loopback_ping(struct gb_loopback *gb, struct timeval *tping)
 	return retval;
 }
 
+static int gb_loopback_request_recv(u8 type, struct gb_operation *operation)
+{
+	struct gb_connection *connection = operation->connection;
+	struct gb_loopback_transfer_request *request;
+	struct gb_loopback_transfer_response *response;
+	u32 len;
+
+	/* By convention, the AP initiates the version operation */
+	switch (type) {
+	case GB_LOOPBACK_TYPE_PROTOCOL_VERSION:
+		dev_err(&connection->dev,
+			"module-initiated version operation\n");
+		return -EINVAL;
+	case GB_LOOPBACK_TYPE_PING:
+		return 0;
+	case GB_LOOPBACK_TYPE_TRANSFER:
+		if (operation->request->payload_size < sizeof(*request)) {
+			dev_err(&connection->dev,
+				"transfer request too small (%zu < %zu)\n",
+				operation->request->payload_size,
+				sizeof(*request));
+			return -EINVAL;	/* -EMSGSIZE */
+		}
+		request = operation->request->payload;
+		len = le32_to_cpu(request->len);
+		if (len) {
+			if (!gb_operation_response_alloc(operation, len)) {
+				dev_err(&connection->dev,
+					"error allocating response\n");
+				return -ENOMEM;
+			}
+			response = operation->response->payload;
+			memcpy(response->data, request->data, len);
+		}
+		return 0;
+	default:
+		dev_err(&connection->dev,
+			"unsupported request: %hhu\n", type);
+		return -EINVAL;
+	}
+}
+
 static void gb_loopback_reset_stats(struct gb_loopback *gb)
 {
 	struct gb_loopback_stats reset = {
@@ -397,7 +439,7 @@ static struct gb_protocol loopback_protocol = {
 	.minor			= GB_LOOPBACK_VERSION_MINOR,
 	.connection_init	= gb_loopback_connection_init,
 	.connection_exit	= gb_loopback_connection_exit,
-	.request_recv		= NULL,	/* no incoming requests */
+	.request_recv		= gb_loopback_request_recv,
 };
 
 gb_protocol_driver(&loopback_protocol);

commit 48cc8b8bbaf0a6767380e4e2e55df3258e47bef6
Author: Alex Elder <elder@linaro.org>
Date:   Mon May 11 21:16:38 2015 -0500

    greybus: loopback: define loopback functions symbolically
    
    Add some symbols to indicate what kind of "function" the
    loopback thread is supposed to be performing--the type of
    traffic it generates over its connection.
    
    Signed-off-by: Alex Elder <elder@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/loopback.c b/drivers/staging/greybus/loopback.c
index f7538aa5fcd4..decaf71fb6e4 100644
--- a/drivers/staging/greybus/loopback.c
+++ b/drivers/staging/greybus/loopback.c
@@ -55,6 +55,12 @@ struct gb_loopback {
 #define	GB_LOOPBACK_TYPE_PING				0x02
 #define	GB_LOOPBACK_TYPE_TRANSFER			0x03
 
+/* Current function (type of traffic generated by the loopback thread) */
+#define GB_LOOPBACK_FN_NONE				0x00
+#define GB_LOOPBACK_FN_PING				0x01
+#define GB_LOOPBACK_FN_XFER				0x02
+#define GB_LOOPBACK_FN_COUNT				0x03
+
 #define GB_LOOPBACK_MS_WAIT_MAX				1000
 #define GB_LOOPBACK_SIZE_MAX				SZ_4K
 
@@ -124,8 +130,8 @@ static void gb_loopback_check_attr(struct gb_loopback *gb)
 {
 	if (gb->ms_wait > GB_LOOPBACK_MS_WAIT_MAX)
 		gb->ms_wait = GB_LOOPBACK_MS_WAIT_MAX;
-	if (gb->type > 2)
-		gb->type = 0;
+	if (gb->type >= GB_LOOPBACK_FN_COUNT)
+		gb->type = GB_LOOPBACK_FN_NONE;
 	if (gb->size > GB_LOOPBACK_SIZE_MAX)
 		gb->size = GB_LOOPBACK_SIZE_MAX;
 	gb->error = 0;
@@ -310,13 +316,13 @@ static int gb_loopback_fn(void *data)
 	struct gb_loopback *gb = (struct gb_loopback *)data;
 
 	while (!kthread_should_stop()) {
-		if (gb->type == 0) {
+		if (gb->type == GB_LOOPBACK_FN_NONE) {
 			msleep(1000);
 			continue;
 		}
-		if (gb->type == 1)
+		if (gb->type == GB_LOOPBACK_FN_PING)
 			error = gb_loopback_ping(gb, &tlat);
-		if (gb->type == 2)
+		else if (gb->type == GB_LOOPBACK_FN_XFER)
 			error = gb_loopback_transfer(gb, &tlat, gb->size);
 		if (error)
 			gb->error++;

commit 91262c3ab70a02949db294b55b4cd49b8ae6505e
Author: Alex Elder <elder@linaro.org>
Date:   Mon May 11 21:16:37 2015 -0500

    greybus: loopback: symbolically define max wait time
    
    Use a symbolic constant to define the maximum time (number of
    milliseconds) to delay between initiated operations.
    
    Signed-off-by: Alex Elder <elder@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/loopback.c b/drivers/staging/greybus/loopback.c
index e1e40ea44ccf..f7538aa5fcd4 100644
--- a/drivers/staging/greybus/loopback.c
+++ b/drivers/staging/greybus/loopback.c
@@ -55,6 +55,7 @@ struct gb_loopback {
 #define	GB_LOOPBACK_TYPE_PING				0x02
 #define	GB_LOOPBACK_TYPE_TRANSFER			0x03
 
+#define GB_LOOPBACK_MS_WAIT_MAX				1000
 #define GB_LOOPBACK_SIZE_MAX				SZ_4K
 
 /* Define get_version() routine */
@@ -121,8 +122,8 @@ static DEVICE_ATTR_RW(field)
 static void gb_loopback_reset_stats(struct gb_loopback *gb);
 static void gb_loopback_check_attr(struct gb_loopback *gb)
 {
-	if (gb->ms_wait > 1000)
-		gb->ms_wait = 1000;
+	if (gb->ms_wait > GB_LOOPBACK_MS_WAIT_MAX)
+		gb->ms_wait = GB_LOOPBACK_MS_WAIT_MAX;
 	if (gb->type > 2)
 		gb->type = 0;
 	if (gb->size > GB_LOOPBACK_SIZE_MAX)

commit 48f19ee8244776a8e7fb47bac1a2b09e9920d035
Author: Alex Elder <elder@linaro.org>
Date:   Mon May 11 21:16:36 2015 -0500

    greybus: loopback: fix an incorrect comment
    
    Fix a comment that incorrectly says the delay between messages is
    limited to 1024 msec; it actually must be <= 1000 msec.
    
    Signed-off-by: Alex Elder <elder@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/loopback.c b/drivers/staging/greybus/loopback.c
index 85e2fe7b5d76..e1e40ea44ccf 100644
--- a/drivers/staging/greybus/loopback.c
+++ b/drivers/staging/greybus/loopback.c
@@ -148,7 +148,7 @@ gb_loopback_ro_attr(error, d);
 gb_loopback_attr(type, d);
 /* Size of transfer message payload: 0-4096 bytes */
 gb_loopback_attr(size, u);
-/* Time to wait between two messages: 0-1024 ms */
+/* Time to wait between two messages: 0-1000 ms */
 gb_loopback_attr(ms_wait, d);
 
 #define dev_stats_attrs(name)						\

commit 69f6034792faf0f930f3797a0a3c3c9cf9ac73cc
Author: Alex Elder <elder@linaro.org>
Date:   Mon May 11 21:16:35 2015 -0500

    greybus: loopback: return the right error value
    
    If an error occurs starting up the loopback thread, the error code
    is not extracted properly.  Fix that.
    
    Signed-off-by: Alex Elder <elder@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/loopback.c b/drivers/staging/greybus/loopback.c
index 20aabebf0140..85e2fe7b5d76 100644
--- a/drivers/staging/greybus/loopback.c
+++ b/drivers/staging/greybus/loopback.c
@@ -362,7 +362,7 @@ static int gb_loopback_connection_init(struct gb_connection *connection)
 	gb_loopback_reset_stats(gb);
 	gb->task = kthread_run(gb_loopback_fn, gb, "gb_loopback");
 	if (IS_ERR(gb->task)) {
-		retval = IS_ERR(gb->task);
+		retval = PTR_ERR(gb->task);
 		goto error;
 	}
 

commit a04c640e5cf342a491afc06b0d931b7a046aa76b
Author: Alex Elder <elder@linaro.org>
Date:   Mon May 11 21:16:34 2015 -0500

    greybus: loopback: fix the type attribute check
    
    In gb_loopback_check_attr(), the value of gb->type is checked for
    validity.  The only valid values are 0, 1, and 2.  But the check
    allows the value 3.  Fix that.
    
    Signed-off-by: Alex Elder <elder@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/loopback.c b/drivers/staging/greybus/loopback.c
index 9860d64e50ba..20aabebf0140 100644
--- a/drivers/staging/greybus/loopback.c
+++ b/drivers/staging/greybus/loopback.c
@@ -123,7 +123,7 @@ static void gb_loopback_check_attr(struct gb_loopback *gb)
 {
 	if (gb->ms_wait > 1000)
 		gb->ms_wait = 1000;
-	if (gb->type > 3)
+	if (gb->type > 2)
 		gb->type = 0;
 	if (gb->size > GB_LOOPBACK_SIZE_MAX)
 		gb->size = GB_LOOPBACK_SIZE_MAX;

commit 1ffc12be5549085faac2d6116f666cb9cbcb2930
Author: Johan Hovold <johan@hovoldconsulting.com>
Date:   Thu Apr 16 09:53:59 2015 +0200

    greybus: loopback: fix 64-bit divisions
    
    The code uses 64-bit divisions, which should be avoided, and also
    prevents the module from loading on 32-bit systems:
    
            gb_loopback: Unknown symbol __aeabi_uldivmod (err 0)
    
    Fix by using the kernel's 64-bit by 32-bit division implementation
    do_div.
    
    Compile tested only. I did not look very closely at the code itself.
    Perhaps this could be worked around in some other way, but this silences
    the linker warning and allows the module to be loaded.
    
    Reviewed-by: Alex Elder <elder@linaro.org>
    Signed-off-by: Johan Hovold <johan@hovoldconsulting.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/loopback.c b/drivers/staging/greybus/loopback.c
index 9914b52c71ce..9860d64e50ba 100644
--- a/drivers/staging/greybus/loopback.c
+++ b/drivers/staging/greybus/loopback.c
@@ -13,6 +13,8 @@
 #include <linux/delay.h>
 #include <linux/random.h>
 #include <linux/sizes.h>
+#include <asm/div64.h>
+
 #include "greybus.h"
 
 struct gb_loopback_stats {
@@ -248,12 +250,16 @@ static void gb_loopback_update_stats(struct gb_loopback_stats *stats,
 					u64 elapsed_nsecs)
 {
 	u32 avg;
+	u64 tmp;
 
 	if (elapsed_nsecs >= NSEC_PER_SEC) {
-		if (!stats->count)
-			avg = stats->sum * (elapsed_nsecs / NSEC_PER_SEC);
-		else
+		if (!stats->count) {
+			tmp = elapsed_nsecs;
+			do_div(tmp, NSEC_PER_SEC);
+			avg = stats->sum * tmp;
+		} else {
 			avg = stats->sum / stats->count;
+		}
 		if (stats->min > avg)
 			stats->min = avg;
 		if (stats->max < avg)
@@ -281,10 +287,11 @@ static void gb_loopback_latency_update(struct gb_loopback *gb,
 					struct timeval *tlat)
 {
 	u32 lat;
-	u64 nsecs;
+	u64 tmp;
 
-	nsecs = timeval_to_ns(tlat);
-	lat = nsecs / NSEC_PER_MSEC;
+	tmp = timeval_to_ns(tlat);
+	do_div(tmp, NSEC_PER_MSEC);
+	lat = tmp;
 
 	if (gb->latency.min > lat)
 		gb->latency.min = lat;

commit 7a51b9362b547b2f02ef88c10636950637c71fa5
Author: Greg Kroah-Hartman <greg@kroah.com>
Date:   Tue Mar 31 23:02:34 2015 +0200

    greybus: loopback: use the attribute groups, not group
    
    We should use the attribute groups, not group, for the device, so
    add and remove it.  No one should ever be updating a sysfs group for a
    device, as that can be pretty dangerous if you don't duplicate _all_
    existing attribute for that device, and I don't think we were doing that
    here.
    
    Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>

diff --git a/drivers/staging/greybus/loopback.c b/drivers/staging/greybus/loopback.c
index 7003bce148ff..9914b52c71ce 100644
--- a/drivers/staging/greybus/loopback.c
+++ b/drivers/staging/greybus/loopback.c
@@ -343,7 +343,7 @@ static int gb_loopback_connection_init(struct gb_connection *connection)
 
 	gb->connection = connection;
 	connection->private = gb;
-	retval = sysfs_update_group(&connection->dev.kobj, &loopback_group);
+	retval = sysfs_create_groups(&connection->dev.kobj, loopback_groups);
 	if (retval)
 		goto error;
 
@@ -372,7 +372,7 @@ static void gb_loopback_connection_exit(struct gb_connection *connection)
 
 	if (!IS_ERR_OR_NULL(gb->task))
 		kthread_stop(gb->task);
-	sysfs_remove_group(&connection->dev.kobj, &loopback_group);
+	sysfs_remove_groups(&connection->dev.kobj, loopback_groups);
 	kfree(gb);
 }
 

commit 5679f783b1ef953f5c5706f226580abf45c82c46
Author: Greg Kroah-Hartman <greg@kroah.com>
Date:   Tue Mar 31 23:01:45 2015 +0200

    greybus: loopback: fix build breakage about SZ_4K
    
    x86 doesn't include SZ_4K somehow so explicitly include <linux/sizes.h>
    to fix the build breakage.
    
    Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>

diff --git a/drivers/staging/greybus/loopback.c b/drivers/staging/greybus/loopback.c
index ae8cc9da8347..7003bce148ff 100644
--- a/drivers/staging/greybus/loopback.c
+++ b/drivers/staging/greybus/loopback.c
@@ -12,6 +12,7 @@
 #include <linux/kthread.h>
 #include <linux/delay.h>
 #include <linux/random.h>
+#include <linux/sizes.h>
 #include "greybus.h"
 
 struct gb_loopback_stats {

commit 355a7058153e04b53bed3fcb792110294693d386
Author: Alexandre Bailon <abailon@baylibre.com>
Date:   Tue Mar 31 09:51:59 2015 +0200

    greybus: Add loopback protocol
    
    Add a simple Greybus protocol in order to stress USB and Greybus.
    This protocol currently support 2 requests: ping and transfer.
    
    ping request is useful to measure latency.
    Kernel send a ping request and firmware should respond with a ping.
    
    The transfer request request is useful to stress Greybus and USB.
    Kernel can send data from 0 to 4k and the firmware must send back the data to kernel.
    
    This behaviour of gb-loopback module is controlled via sysfs.
    Curently, connection sysfs folder is updated with new entries:
    - type: Type of loopback message to send
      * 0 => Don't send message
      * 1 => Send ping message continuously (message without payload)
      * 2 => Send transer message continuously (message with payload)
    - size: Size of transfer message payload: 0-4096 bytes
    - ms_wait: Time to wait between two messages: 0-1024 ms
    
    Module also export some statistics about connection:
    - latency: Time to send and receive one message
    - frequency: Number of packet sent per second on this cport
    - throughput: Quantity of data sent and received on this cport
    - error
    All this statistics are cleared everytime type, size or ms_wait entries are updated.
    
    Signed-off-by: Alexandre Bailon <abailon@baylibre.com>
    Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>

diff --git a/drivers/staging/greybus/loopback.c b/drivers/staging/greybus/loopback.c
new file mode 100644
index 000000000000..ae8cc9da8347
--- /dev/null
+++ b/drivers/staging/greybus/loopback.c
@@ -0,0 +1,390 @@
+/*
+ * Loopback bridge driver for the Greybus loopback module.
+ *
+ * Copyright 2014 Google Inc.
+ * Copyright 2014 Linaro Ltd.
+ *
+ * Released under the GPLv2 only.
+ */
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/kthread.h>
+#include <linux/delay.h>
+#include <linux/random.h>
+#include "greybus.h"
+
+struct gb_loopback_stats {
+	u32 min;
+	u32 max;
+	u32 avg;
+	u32 sum;
+	u32 count;
+};
+
+struct gb_loopback {
+	struct gb_connection *connection;
+	u8 version_major;
+	u8 version_minor;
+
+	struct task_struct *task;
+
+	int type;
+	u32 size;
+	int ms_wait;
+
+	struct gb_loopback_stats latency;
+	struct gb_loopback_stats throughput;
+	struct gb_loopback_stats frequency;
+	struct timeval ts;
+	struct timeval te;
+	u64 elapsed_nsecs;
+	u32 error;
+};
+
+/* Version of the Greybus loopback protocol we support */
+#define	GB_LOOPBACK_VERSION_MAJOR			0x00
+#define	GB_LOOPBACK_VERSION_MINOR			0x01
+
+/* Greybus loopback request types */
+#define	GB_LOOPBACK_TYPE_INVALID			0x00
+#define	GB_LOOPBACK_TYPE_PROTOCOL_VERSION		0x01
+#define	GB_LOOPBACK_TYPE_PING				0x02
+#define	GB_LOOPBACK_TYPE_TRANSFER			0x03
+
+#define GB_LOOPBACK_SIZE_MAX				SZ_4K
+
+/* Define get_version() routine */
+define_get_version(gb_loopback, LOOPBACK);
+
+/* interface sysfs attributes */
+#define gb_loopback_ro_attr(field, type)				\
+static ssize_t field##_show(struct device *dev,				\
+			    struct device_attribute *attr,		\
+			    char *buf)					\
+{									\
+	struct gb_connection *connection = to_gb_connection(dev);	\
+	struct gb_loopback *gb =					\
+		(struct gb_loopback *)connection->private;		\
+	return sprintf(buf, "%"#type"\n", gb->field);			\
+}									\
+static DEVICE_ATTR_RO(field)
+
+#define gb_loopback_ro_stats_attr(name, field, type)			\
+static ssize_t name##_##field##_show(struct device *dev,		\
+			    struct device_attribute *attr,		\
+			    char *buf)					\
+{									\
+	struct gb_connection *connection = to_gb_connection(dev);	\
+	struct gb_loopback *gb =					\
+		(struct gb_loopback *)connection->private;		\
+	return sprintf(buf, "%"#type"\n", gb->name.field);		\
+}									\
+static DEVICE_ATTR_RO(name##_##field)
+
+#define gb_loopback_stats_attrs(field)					\
+	gb_loopback_ro_stats_attr(field, min, d);			\
+	gb_loopback_ro_stats_attr(field, max, d);			\
+	gb_loopback_ro_stats_attr(field, avg, d);
+
+#define gb_loopback_attr(field, type)					\
+static ssize_t field##_show(struct device *dev,				\
+			    struct device_attribute *attr,		\
+			    char *buf)					\
+{									\
+	struct gb_connection *connection = to_gb_connection(dev);	\
+	struct gb_loopback *gb =					\
+		(struct gb_loopback *)connection->private;		\
+	return sprintf(buf, "%"#type"\n", gb->field);			\
+}									\
+static ssize_t field##_store(struct device *dev,			\
+			    struct device_attribute *attr,		\
+			    const char *buf,				\
+			    size_t len)					\
+{									\
+	int ret;							\
+	struct gb_connection *connection = to_gb_connection(dev);	\
+	struct gb_loopback *gb =					\
+		(struct gb_loopback *)connection->private;		\
+	ret = sscanf(buf, "%"#type, &gb->field);			\
+	pr_err("%s = %"#type"\n", #field, gb->field);			\
+	if (ret != 1)							\
+		return -EINVAL;						\
+	gb_loopback_check_attr(gb);					\
+	return len;							\
+}									\
+static DEVICE_ATTR_RW(field)
+
+static void gb_loopback_reset_stats(struct gb_loopback *gb);
+static void gb_loopback_check_attr(struct gb_loopback *gb)
+{
+	if (gb->ms_wait > 1000)
+		gb->ms_wait = 1000;
+	if (gb->type > 3)
+		gb->type = 0;
+	if (gb->size > GB_LOOPBACK_SIZE_MAX)
+		gb->size = GB_LOOPBACK_SIZE_MAX;
+	gb->error = 0;
+	gb_loopback_reset_stats(gb);
+}
+
+/* Time to send and receive one message */
+gb_loopback_stats_attrs(latency);
+/* Number of packet sent per second on this cport */
+gb_loopback_stats_attrs(frequency);
+/* Quantity of data sent and received on this cport */
+gb_loopback_stats_attrs(throughput);
+gb_loopback_ro_attr(error, d);
+
+/*
+ * Type of loopback message to send
+ * 0 => Don't send message
+ * 1 => Send ping message continuously (message without payload)
+ * 2 => Send transer message continuously (message with payload)
+ */
+gb_loopback_attr(type, d);
+/* Size of transfer message payload: 0-4096 bytes */
+gb_loopback_attr(size, u);
+/* Time to wait between two messages: 0-1024 ms */
+gb_loopback_attr(ms_wait, d);
+
+#define dev_stats_attrs(name)						\
+	&dev_attr_##name##_min.attr,					\
+	&dev_attr_##name##_max.attr,					\
+	&dev_attr_##name##_avg.attr
+
+static struct attribute *loopback_attrs[] = {
+	dev_stats_attrs(latency),
+	dev_stats_attrs(frequency),
+	dev_stats_attrs(throughput),
+	&dev_attr_type.attr,
+	&dev_attr_size.attr,
+	&dev_attr_ms_wait.attr,
+	&dev_attr_error.attr,
+	NULL,
+};
+ATTRIBUTE_GROUPS(loopback);
+
+struct gb_loopback_transfer_request {
+	__le32	len;
+	__u8	data[0];
+};
+
+struct gb_loopback_transfer_response {
+	__u8	data[0];
+};
+
+
+static int gb_loopback_transfer(struct gb_loopback *gb,
+				struct timeval *tping, u32 len)
+{
+	struct timeval ts, te;
+	u64 elapsed_nsecs;
+	struct gb_loopback_transfer_request *request;
+	struct gb_loopback_transfer_response *response;
+	int retval;
+
+	request = kmalloc(len + sizeof(*request), GFP_KERNEL);
+	if (!request)
+		return -ENOMEM;
+	response = kmalloc(len + sizeof(*response), GFP_KERNEL);
+	if (!response) {
+		kfree(request);
+		return -ENOMEM;
+	}
+
+	request->len = cpu_to_le32(len);
+
+	do_gettimeofday(&ts);
+	retval = gb_operation_sync(gb->connection, GB_LOOPBACK_TYPE_TRANSFER,
+				   request, len + sizeof(*request),
+				   response, len + sizeof(*response));
+	do_gettimeofday(&te);
+	elapsed_nsecs = timeval_to_ns(&te) - timeval_to_ns(&ts);
+	*tping = ns_to_timeval(elapsed_nsecs);
+
+	if (retval)
+		goto gb_error;
+
+	if (memcmp(request->data, response->data, len))
+		retval = -EREMOTEIO;
+
+gb_error:
+	kfree(request);
+	kfree(response);
+
+	return retval;
+}
+
+static int gb_loopback_ping(struct gb_loopback *gb, struct timeval *tping)
+{
+	struct timeval ts, te;
+	u64 elapsed_nsecs;
+	int retval;
+
+	do_gettimeofday(&ts);
+	retval = gb_operation_sync(gb->connection, GB_LOOPBACK_TYPE_PING,
+				   NULL, 0, NULL, 0);
+	do_gettimeofday(&te);
+	elapsed_nsecs = timeval_to_ns(&te) - timeval_to_ns(&ts);
+	*tping = ns_to_timeval(elapsed_nsecs);
+
+	return retval;
+}
+
+static void gb_loopback_reset_stats(struct gb_loopback *gb)
+{
+	struct gb_loopback_stats reset = {
+		.min = 0xffffffff,
+	};
+	memcpy(&gb->latency, &reset, sizeof(struct gb_loopback_stats));
+	memcpy(&gb->throughput, &reset, sizeof(struct gb_loopback_stats));
+	memcpy(&gb->frequency, &reset, sizeof(struct gb_loopback_stats));
+	memset(&gb->ts, 0, sizeof(struct timeval));
+}
+
+static void gb_loopback_update_stats(struct gb_loopback_stats *stats,
+					u64 elapsed_nsecs)
+{
+	u32 avg;
+
+	if (elapsed_nsecs >= NSEC_PER_SEC) {
+		if (!stats->count)
+			avg = stats->sum * (elapsed_nsecs / NSEC_PER_SEC);
+		else
+			avg = stats->sum / stats->count;
+		if (stats->min > avg)
+			stats->min = avg;
+		if (stats->max < avg)
+			stats->max = avg;
+		stats->avg = avg;
+		stats->count = 0;
+		stats->sum = 0;
+	}
+}
+
+static void gb_loopback_freq_update(struct gb_loopback *gb)
+{
+	gb->frequency.sum++;
+	gb_loopback_update_stats(&gb->frequency, gb->elapsed_nsecs);
+}
+
+static void gb_loopback_bw_update(struct gb_loopback *gb, int error)
+{
+	if (!error)
+		gb->throughput.sum += gb->size * 2;
+	gb_loopback_update_stats(&gb->throughput, gb->elapsed_nsecs);
+}
+
+static void gb_loopback_latency_update(struct gb_loopback *gb,
+					struct timeval *tlat)
+{
+	u32 lat;
+	u64 nsecs;
+
+	nsecs = timeval_to_ns(tlat);
+	lat = nsecs / NSEC_PER_MSEC;
+
+	if (gb->latency.min > lat)
+		gb->latency.min = lat;
+	if (gb->latency.max < lat)
+		gb->latency.max = lat;
+	gb->latency.sum += lat;
+	gb->latency.count++;
+	gb_loopback_update_stats(&gb->latency, gb->elapsed_nsecs);
+}
+
+static int gb_loopback_fn(void *data)
+{
+	int error = 0;
+	struct timeval tlat = {0, 0};
+	struct gb_loopback *gb = (struct gb_loopback *)data;
+
+	while (!kthread_should_stop()) {
+		if (gb->type == 0) {
+			msleep(1000);
+			continue;
+		}
+		if (gb->type == 1)
+			error = gb_loopback_ping(gb, &tlat);
+		if (gb->type == 2)
+			error = gb_loopback_transfer(gb, &tlat, gb->size);
+		if (error)
+			gb->error++;
+		if (gb->ts.tv_usec == 0 && gb->ts.tv_sec == 0) {
+			do_gettimeofday(&gb->ts);
+			continue;
+		}
+		do_gettimeofday(&gb->te);
+		gb->elapsed_nsecs = timeval_to_ns(&gb->te) -
+					timeval_to_ns(&gb->ts);
+		gb_loopback_freq_update(gb);
+		if (gb->type == 2)
+			gb_loopback_bw_update(gb, error);
+		gb_loopback_latency_update(gb, &tlat);
+		if (gb->elapsed_nsecs >= NSEC_PER_SEC)
+			gb->ts = gb->te;
+		if (gb->ms_wait)
+			msleep(gb->ms_wait);
+
+	}
+	return 0;
+}
+
+static int gb_loopback_connection_init(struct gb_connection *connection)
+{
+	struct gb_loopback *gb;
+	int retval;
+
+	gb = kzalloc(sizeof(*gb), GFP_KERNEL);
+	if (!gb)
+		return -ENOMEM;
+
+	gb->connection = connection;
+	connection->private = gb;
+	retval = sysfs_update_group(&connection->dev.kobj, &loopback_group);
+	if (retval)
+		goto error;
+
+	/* Check the version */
+	retval = get_version(gb);
+	if (retval)
+		goto error;
+
+	gb_loopback_reset_stats(gb);
+	gb->task = kthread_run(gb_loopback_fn, gb, "gb_loopback");
+	if (IS_ERR(gb->task)) {
+		retval = IS_ERR(gb->task);
+		goto error;
+	}
+
+	return 0;
+
+error:
+	kfree(gb);
+	return retval;
+}
+
+static void gb_loopback_connection_exit(struct gb_connection *connection)
+{
+	struct gb_loopback *gb = connection->private;
+
+	if (!IS_ERR_OR_NULL(gb->task))
+		kthread_stop(gb->task);
+	sysfs_remove_group(&connection->dev.kobj, &loopback_group);
+	kfree(gb);
+}
+
+static struct gb_protocol loopback_protocol = {
+	.name			= "loopback",
+	.id			= GREYBUS_PROTOCOL_LOOPBACK,
+	.major			= GB_LOOPBACK_VERSION_MAJOR,
+	.minor			= GB_LOOPBACK_VERSION_MINOR,
+	.connection_init	= gb_loopback_connection_init,
+	.connection_exit	= gb_loopback_connection_exit,
+	.request_recv		= NULL,	/* no incoming requests */
+};
+
+gb_protocol_driver(&loopback_protocol);
+
+MODULE_LICENSE("GPL v2");
