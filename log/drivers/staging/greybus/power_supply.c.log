commit ec0ad868173da8a75121f9dc116a5d5478ff614d
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Sun Aug 25 07:54:27 2019 +0200

    staging: greybus: move core include files to include/linux/greybus/
    
    With the goal of moving the core of the greybus code out of staging, the
    include files need to be moved to include/linux/greybus.h and
    include/linux/greybus/
    
    Cc: Vaibhav Hiremath <hvaibhav.linux@gmail.com>
    Cc: Johan Hovold <johan@kernel.org>
    Cc: Vaibhav Agarwal <vaibhav.sr@gmail.com>
    Cc: Rui Miguel Silva <rmfrfs@gmail.com>
    Cc: David Lin <dtwlin@gmail.com>
    Cc: "Bryan O'Donoghue" <pure.logic@nexus-software.ie>
    Cc: greybus-dev@lists.linaro.org
    Cc: devel@driverdev.osuosl.org
    Acked-by: Mark Greer <mgreer@animalcreek.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Acked-by: Alex Elder <elder@kernel.org>
    Link: https://lore.kernel.org/r/20190825055429.18547-8-gregkh@linuxfoundation.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/power_supply.c b/drivers/staging/greybus/power_supply.c
index 34b40a409ea3..ec96f28887f9 100644
--- a/drivers/staging/greybus/power_supply.c
+++ b/drivers/staging/greybus/power_supply.c
@@ -10,8 +10,7 @@
 #include <linux/module.h>
 #include <linux/power_supply.h>
 #include <linux/slab.h>
-
-#include "greybus.h"
+#include <linux/greybus.h>
 
 #define PROP_MAX 32
 

commit 827c085baede48155c57dff16396620c5377e755
Author: Gustavo A. R. Silva <gustavo@embeddedor.com>
Date:   Wed Apr 17 13:44:40 2019 -0500

    staging: greybus: power_supply: use struct_size() helper
    
    Make use of the struct_size() helper instead of an open-coded version
    in order to avoid any potential type mistakes, in particular in the
    context in which this code is being used.
    
    So, replace code of the following form:
    
    sizeof(*resp) + props_count * sizeof(struct gb_power_supply_props_desc)
    
    with:
    
    struct_size(resp, props, props_count)
    
    This code was detected with the help of Coccinelle.
    
    Signed-off-by: Gustavo A. R. Silva <gustavo@embeddedor.com>
    Reviewed-by: Rui Miguel Silva <rmfrfs@gmail.com>
    Reviewed-by: Johan Hovold <johan@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/power_supply.c b/drivers/staging/greybus/power_supply.c
index ae5c0285a942..34b40a409ea3 100644
--- a/drivers/staging/greybus/power_supply.c
+++ b/drivers/staging/greybus/power_supply.c
@@ -520,8 +520,8 @@ static int gb_power_supply_prop_descriptors_get(struct gb_power_supply *gbpsy)
 
 	op = gb_operation_create(connection,
 				 GB_POWER_SUPPLY_TYPE_GET_PROP_DESCRIPTORS,
-				 sizeof(*req), sizeof(*resp) + props_count *
-				 sizeof(struct gb_power_supply_props_desc),
+				 sizeof(*req),
+				 struct_size(resp, props, props_count),
 				 GFP_KERNEL);
 	if (!op)
 		return -ENOMEM;

commit 47830c1127ef166af787caf2f871f23089610a7f
Author: Johan Hovold <johan@kernel.org>
Date:   Thu Apr 4 08:53:30 2019 +0200

    staging: greybus: power_supply: fix prop-descriptor request size
    
    Since moving the message buffers off the stack, the dynamically
    allocated get-prop-descriptor request buffer is incorrectly sized due to
    using the pointer rather than request-struct size when creating the
    operation.
    
    Fortunately, the pointer size is always larger than this one-byte
    request, but this could still cause trouble on the remote end due to the
    unexpected message size.
    
    Fixes: 9d15134d067e ("greybus: power_supply: rework get descriptors")
    Cc: stable <stable@vger.kernel.org>     # 4.9
    Cc: Rui Miguel Silva <rui.silva@linaro.org>
    Signed-off-by: Johan Hovold <johan@kernel.org>
    Reviewed-by: Rui Miguel Silva <rmfrfs@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/power_supply.c b/drivers/staging/greybus/power_supply.c
index 0529e5628c24..ae5c0285a942 100644
--- a/drivers/staging/greybus/power_supply.c
+++ b/drivers/staging/greybus/power_supply.c
@@ -520,7 +520,7 @@ static int gb_power_supply_prop_descriptors_get(struct gb_power_supply *gbpsy)
 
 	op = gb_operation_create(connection,
 				 GB_POWER_SUPPLY_TYPE_GET_PROP_DESCRIPTORS,
-				 sizeof(req), sizeof(*resp) + props_count *
+				 sizeof(*req), sizeof(*resp) + props_count *
 				 sizeof(struct gb_power_supply_props_desc),
 				 GFP_KERNEL);
 	if (!op)

commit 863dbc52e7f0e5acd7b4883f3933543a81c474c7
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Nov 7 14:58:42 2017 +0100

    staging: greybus: Remove redundant license text
    
    Now that the SPDX tag is in all greybus files, that identifies the
    license in a specific and legally-defined manner.  So the extra GPL text
    wording can be removed as it is no longer needed at all.
    
    This is done on a quest to remove the 700+ different ways that files in
    the kernel describe the GPL license text.  And there's unneeded stuff
    like the address (sometimes incorrect) for the FSF which is never
    needed.
    
    No copyright headers or other non-license-description text was removed.
    
    Cc: Vaibhav Hiremath <hvaibhav.linux@gmail.com>
    Reviewed-by: Alex Elder <elder@linaro.org>
    Acked-by: Vaibhav Agarwal <vaibhav.sr@gmail.com>
    Acked-by: David Lin <dtwlin@gmail.com>
    Acked-by: Johan Hovold <johan@kernel.org>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Acked-by: Mark Greer <mgreer@animalcreek.com>
    Acked-by: Rui Miguel Silva <rmfrfs@gmail.com>
    Acked-by: "Bryan O'Donoghue" <pure.logic@nexus-software.ie>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/power_supply.c b/drivers/staging/greybus/power_supply.c
index bc16307c73b8..0529e5628c24 100644
--- a/drivers/staging/greybus/power_supply.c
+++ b/drivers/staging/greybus/power_supply.c
@@ -4,8 +4,6 @@
  *
  * Copyright 2014-2015 Google Inc.
  * Copyright 2014-2015 Linaro Ltd.
- *
- * Released under the GPLv2 only.
  */
 
 #include <linux/kernel.h>

commit eb50fd3a22c770f36be275295b782f3ea52e3215
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Nov 7 14:58:41 2017 +0100

    staging: greybus: add SPDX identifiers to all greybus driver files
    
    It's good to have SPDX identifiers in all files to make it easier to
    audit the kernel tree for correct licenses.
    
    Update the drivers/staging/greybus files files with the correct SPDX
    license identifier based on the license text in the file itself.  The
    SPDX identifier is a legally binding shorthand, which can be used
    instead of the full boiler plate text.
    
    This work is based on a script and data from Thomas Gleixner, Philippe
    Ombredanne, and Kate Stewart.
    
    Cc: Vaibhav Hiremath <hvaibhav.linux@gmail.com>
    Cc: "Bryan O'Donoghue" <pure.logic@nexus-software.ie>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: Philippe Ombredanne <pombredanne@nexb.com>
    Acked-by: Vaibhav Agarwal <vaibhav.sr@gmail.com>
    Acked-by: David Lin <dtwlin@gmail.com>
    Reviewed-by: Alex Elder <elder@linaro.org>
    Acked-by: Johan Hovold <johan@kernel.org>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Acked-by: Mark Greer <mgreer@animalcreek.com>
    Acked-by: Rui Miguel Silva <rmfrfs@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/power_supply.c b/drivers/staging/greybus/power_supply.c
index 20cac20518d7..bc16307c73b8 100644
--- a/drivers/staging/greybus/power_supply.c
+++ b/drivers/staging/greybus/power_supply.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * Power Supply driver for a Greybus module.
  *

commit 03d261deea9d0b8fbb908d7f1f29f26fd272984d
Author: JB Van Puyvelde <jbvanpuyvelde@gmail.com>
Date:   Thu May 11 22:58:56 2017 +0200

    staging: greybus: power_supply: replace kzalloc by kcalloc
    
    According to checkpatch.pl, kcalloc should be preferred to kzalloc with
    multiply.
    
    Signed-off-by: JB Van Puyvelde <jbvanpuyvelde@gmail.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Reviewed-by: Rui Miguel Silva <rmfrfs@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/power_supply.c b/drivers/staging/greybus/power_supply.c
index e85c988b7034..20cac20518d7 100644
--- a/drivers/staging/greybus/power_supply.c
+++ b/drivers/staging/greybus/power_supply.c
@@ -944,7 +944,7 @@ static int gb_power_supplies_setup(struct gb_power_supplies *supplies)
 	if (ret < 0)
 		goto out;
 
-	supplies->supply = kzalloc(supplies->supplies_count *
+	supplies->supply = kcalloc(supplies->supplies_count,
 				     sizeof(struct gb_power_supply),
 				     GFP_KERNEL);
 

commit 722a133a6a6687bba21cfdf33bde5767109d0dea
Author: Rui Miguel Silva <rui.silva@linaro.org>
Date:   Thu Sep 8 17:17:50 2016 +0100

    staging: greybus: power_supply: remove KERNEL_VERSION checks
    
    No need to support older kernel versions in the Greybus Power Supply
    driver, so remove the checks as needed, we can now rely on all of the
    correct Power Supply core apis being present. Also move some properties
    definitions to the power supply greybus code.
    
    Signed-off-by: Rui Miguel Silva <rui.silva@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/power_supply.c b/drivers/staging/greybus/power_supply.c
index 68dd3d2f7585..e85c988b7034 100644
--- a/drivers/staging/greybus/power_supply.c
+++ b/drivers/staging/greybus/power_supply.c
@@ -27,14 +27,8 @@ struct gb_power_supply_prop {
 struct gb_power_supply {
 	u8				id;
 	bool				registered;
-#ifndef CORE_OWNS_PSY_STRUCT
-	struct power_supply		psy;
-#define to_gb_power_supply(x) container_of(x, struct gb_power_supply, psy)
-#else
 	struct power_supply		*psy;
 	struct power_supply_desc	desc;
-#define to_gb_power_supply(x) power_supply_get_drvdata(x)
-#endif
 	char				name[64];
 	struct gb_power_supplies	*supplies;
 	struct delayed_work		work;
@@ -61,6 +55,22 @@ struct gb_power_supplies {
 	struct mutex		supplies_lock;
 };
 
+#define to_gb_power_supply(x) power_supply_get_drvdata(x)
+
+/*
+ * General power supply properties that could be absent from various reasons,
+ * like kernel versions or vendor specific versions
+ */
+#ifndef POWER_SUPPLY_PROP_VOLTAGE_BOOT
+	#define POWER_SUPPLY_PROP_VOLTAGE_BOOT	-1
+#endif
+#ifndef POWER_SUPPLY_PROP_CURRENT_BOOT
+	#define POWER_SUPPLY_PROP_CURRENT_BOOT	-1
+#endif
+#ifndef POWER_SUPPLY_PROP_CALIBRATE
+	#define POWER_SUPPLY_PROP_CALIBRATE	-1
+#endif
+
 /* cache time in milliseconds, if cache_time is set to 0 cache is disable */
 static unsigned int cache_time = 1000;
 /*
@@ -342,17 +352,10 @@ static void next_interval(struct gb_power_supply *gbpsy)
 		gbpsy->update_interval = update_interval_max;
 }
 
-#ifndef CORE_OWNS_PSY_STRUCT
-static void __gb_power_supply_changed(struct gb_power_supply *gbpsy)
-{
-	power_supply_changed(&gbpsy->psy);
-}
-#else
 static void __gb_power_supply_changed(struct gb_power_supply *gbpsy)
 {
 	power_supply_changed(gbpsy->psy);
 }
-#endif
 
 static void gb_power_supply_state_change(struct gb_power_supply *gbpsy,
 					 struct gb_power_supply_prop *prop)
@@ -451,9 +454,8 @@ static int __gb_power_supply_set_name(char *init_name, char *name, size_t len)
 	strlcpy(name, init_name, len);
 
 	while ((ret < len) && (psy = power_supply_get_by_name(name))) {
-#ifdef PSY_HAVE_PUT
 		power_supply_put(psy);
-#endif
+
 		ret = snprintf(name, len, "%s_%u", init_name, ++i);
 	}
 	if (ret >= len)
@@ -814,23 +816,6 @@ static int property_is_writeable(struct power_supply *b,
 	return is_psy_prop_writeable(gbpsy, psp);
 }
 
-#ifndef CORE_OWNS_PSY_STRUCT
-static int gb_power_supply_register(struct gb_power_supply *gbpsy)
-{
-	struct gb_connection *connection = get_conn_from_psy(gbpsy);
-
-	gbpsy->psy.name			= gbpsy->name;
-	gbpsy->psy.type			= gbpsy->type;
-	gbpsy->psy.properties		= gbpsy->props_raw;
-	gbpsy->psy.num_properties	= total_props(gbpsy);
-	gbpsy->psy.get_property		= get_property;
-	gbpsy->psy.set_property		= set_property;
-	gbpsy->psy.property_is_writeable = property_is_writeable;
-
-	return power_supply_register(&connection->bundle->dev,
-				     &gbpsy->psy);
-}
-#else
 static int gb_power_supply_register(struct gb_power_supply *gbpsy)
 {
 	struct gb_connection *connection = get_conn_from_psy(gbpsy);
@@ -850,7 +835,6 @@ static int gb_power_supply_register(struct gb_power_supply *gbpsy)
 					   &gbpsy->desc, &cfg);
 	return PTR_ERR_OR_ZERO(gbpsy->psy);
 }
-#endif
 
 static void _gb_power_supply_free(struct gb_power_supply *gbpsy)
 {
@@ -866,13 +850,9 @@ static void _gb_power_supply_release(struct gb_power_supply *gbpsy)
 	gbpsy->update_interval = 0;
 
 	cancel_delayed_work_sync(&gbpsy->work);
-#ifndef CORE_OWNS_PSY_STRUCT
-	if (gbpsy->registered)
-		power_supply_unregister(&gbpsy->psy);
-#else
+
 	if (gbpsy->registered)
 		power_supply_unregister(gbpsy->psy);
-#endif
 
 	_gb_power_supply_free(gbpsy);
 }

commit 4e013b64c1ee3a60438caa0df6bf79664e0272bc
Author: Philip Yang <yang_philip@projectara.com>
Date:   Wed Aug 31 11:11:18 2016 +0800

    greybus: power_supply: Add runtime pm support
    
    Modify Power_supply greybus driver to support runtime PM framework.
    
    During charging state, the driver will block remote device of suspending,
    and then enables runtime suspend when remote device is in none chargin
    state.
    
    Testing Done: Compiled and verified on EVT2, EVT2 1x2 GPB test module
                  and Device class daughter board.
    
    Signed-off-by: Philip Yang <yang_philip@projectara.com>
    Reviewed-by: Rui Miguel Silva <rui.silva@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/power_supply.c b/drivers/staging/greybus/power_supply.c
index 578d38b25d71..68dd3d2f7585 100644
--- a/drivers/staging/greybus/power_supply.c
+++ b/drivers/staging/greybus/power_supply.c
@@ -50,6 +50,8 @@ struct gb_power_supply {
 	bool				changed;
 	struct gb_power_supply_prop	*props;
 	enum power_supply_property	*props_raw;
+	bool				pm_acquired;
+	struct mutex			supply_lock;
 };
 
 struct gb_power_supplies {
@@ -75,10 +77,13 @@ struct gb_power_supply_changes {
 			     struct gb_power_supply_prop *prop);
 };
 
+static void gb_power_supply_state_change(struct gb_power_supply *gbpsy,
+					 struct gb_power_supply_prop *prop);
+
 static const struct gb_power_supply_changes psy_props_changes[] = {
 	{	.prop			= GB_POWER_SUPPLY_PROP_STATUS,
 		.tolerance_change	= 0,
-		.prop_changed		= NULL,
+		.prop_changed		= gb_power_supply_state_change,
 	},
 	{	.prop			= GB_POWER_SUPPLY_PROP_TEMP,
 		.tolerance_change	= 500,
@@ -349,6 +354,40 @@ static void __gb_power_supply_changed(struct gb_power_supply *gbpsy)
 }
 #endif
 
+static void gb_power_supply_state_change(struct gb_power_supply *gbpsy,
+					 struct gb_power_supply_prop *prop)
+{
+	struct gb_connection *connection = get_conn_from_psy(gbpsy);
+	int ret;
+
+	/*
+	 * Check gbpsy->pm_acquired to make sure only one pair of 'get_sync'
+	 * and 'put_autosuspend' runtime pm call for state property change.
+	 */
+	mutex_lock(&gbpsy->supply_lock);
+
+	if ((prop->val == GB_POWER_SUPPLY_STATUS_CHARGING) &&
+	    !gbpsy->pm_acquired) {
+		ret = gb_pm_runtime_get_sync(connection->bundle);
+		if (ret)
+			dev_err(&connection->bundle->dev,
+				"Fail to set wake lock for charging state\n");
+		else
+			gbpsy->pm_acquired = true;
+	} else {
+		if (gbpsy->pm_acquired) {
+			ret = gb_pm_runtime_put_autosuspend(connection->bundle);
+			if (ret)
+				dev_err(&connection->bundle->dev,
+					"Fail to set wake unlock for none charging\n");
+			else
+				gbpsy->pm_acquired = false;
+		}
+	}
+
+	mutex_unlock(&gbpsy->supply_lock);
+}
+
 static void check_changed(struct gb_power_supply *gbpsy,
 			  struct gb_power_supply_prop *prop)
 {
@@ -655,12 +694,17 @@ static int is_cache_valid(struct gb_power_supply *gbpsy)
 
 static int gb_power_supply_status_get(struct gb_power_supply *gbpsy)
 {
+	struct gb_connection *connection = get_conn_from_psy(gbpsy);
 	int ret = 0;
 	int i;
 
 	if (is_cache_valid(gbpsy))
 		return 0;
 
+	ret = gb_pm_runtime_get_sync(connection->bundle);
+	if (ret)
+		return ret;
+
 	for (i = 0; i < gbpsy->properties_count; i++) {
 		ret = __gb_power_supply_property_update(gbpsy,
 							gbpsy->props[i].prop);
@@ -671,6 +715,7 @@ static int gb_power_supply_status_get(struct gb_power_supply *gbpsy)
 	if (ret == 0)
 		gbpsy->last_update = jiffies;
 
+	gb_pm_runtime_put_autosuspend(connection->bundle);
 	return ret;
 }
 
@@ -725,9 +770,16 @@ static int gb_power_supply_property_set(struct gb_power_supply *gbpsy,
 	struct gb_power_supply_set_property_request req;
 	int ret;
 
+	ret = gb_pm_runtime_get_sync(connection->bundle);
+	if (ret)
+		return ret;
+
 	prop = get_psy_prop(gbpsy, psp);
-	if (!prop)
-		return -EINVAL;
+	if (!prop) {
+		ret = -EINVAL;
+		goto out;
+	}
+
 	req.psy_id = gbpsy->id;
 	req.property = prop->gb_prop;
 	req.prop_val = cpu_to_le32((s32)val);
@@ -741,6 +793,7 @@ static int gb_power_supply_property_set(struct gb_power_supply *gbpsy,
 	prop->val = val;
 
 out:
+	gb_pm_runtime_put_autosuspend(connection->bundle);
 	return ret;
 }
 
@@ -883,6 +936,8 @@ static int gb_power_supply_enable(struct gb_power_supply *gbpsy)
 	if (ret < 0)
 		return ret;
 
+	mutex_init(&gbpsy->supply_lock);
+
 	ret = gb_power_supply_register(gbpsy);
 	if (ret < 0)
 		return ret;
@@ -1067,6 +1122,7 @@ static int gb_power_supply_probe(struct gb_bundle *bundle,
 	if (ret < 0)
 		goto error_connection_disable;
 
+	gb_pm_runtime_put_autosuspend(bundle);
 	return 0;
 
 error_connection_disable:

commit 6ac9166d4e91a6dea03b64b64f128e0f927aa7ec
Author: Rui Miguel Silva <rui.silva@linaro.org>
Date:   Fri Aug 26 11:52:05 2016 +0100

    greybus: power_supply: fix name setting location
    
    We were checking for existing power supply names in the wrong place,
    i.e, we were checking before any of the module power supply were
    registered, because of that of course no name collision was detected.
    
    Move the check to the register loop and with that we guarantee that this
    mechanism works for greybus power supply naming.
    
    Tested: using gbsim and using power supply with the same name and check
    that: 1. no problems creating sysfs entries; 2. naming is done following
    the desired rules.
    
    Signed-off-by: Rui Miguel Silva <rui.silva@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/power_supply.c b/drivers/staging/greybus/power_supply.c
index 199a19a634b6..578d38b25d71 100644
--- a/drivers/staging/greybus/power_supply.c
+++ b/drivers/staging/greybus/power_supply.c
@@ -870,19 +870,19 @@ static int gb_power_supply_config(struct gb_power_supplies *supplies, int id)
 	if (ret < 0)
 		return ret;
 
-	ret = gb_power_supply_prop_descriptors_get(gbpsy);
-	if (ret < 0)
-		return ret;
-
-	/* guarantee that we have an unique name, before register */
-	return __gb_power_supply_set_name(gbpsy->model_name, gbpsy->name,
-					  sizeof(gbpsy->name));
+	return gb_power_supply_prop_descriptors_get(gbpsy);
 }
 
 static int gb_power_supply_enable(struct gb_power_supply *gbpsy)
 {
 	int ret;
 
+	/* guarantee that we have an unique name, before register */
+	ret =  __gb_power_supply_set_name(gbpsy->model_name, gbpsy->name,
+					  sizeof(gbpsy->name));
+	if (ret < 0)
+		return ret;
+
 	ret = gb_power_supply_register(gbpsy);
 	if (ret < 0)
 		return ret;

commit b5fbe819af2f8d8dceb421635a976462bb6885b8
Author: Rui Miguel Silva <rui.silva@linaro.org>
Date:   Tue Aug 16 22:31:57 2016 +0100

    greybus: power_supply: invalidate cache at update request
    
    When we receive a update request we shall not trust the cache mechanism
    and for that we need a way to invalidate the cache. Add a field that
    will control the cache status and refactor the code to check if cache is
    valid in a helper function.
    
    This will fix the scenario where an update request is received within
    the cache expiration time after a previous update as happened and would
    be ignored.
    
    Signed-off-by: Rui Miguel Silva <rui.silva@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/power_supply.c b/drivers/staging/greybus/power_supply.c
index 3d6f81017d98..199a19a634b6 100644
--- a/drivers/staging/greybus/power_supply.c
+++ b/drivers/staging/greybus/power_supply.c
@@ -45,6 +45,7 @@ struct gb_power_supply {
 	u8				properties_count;
 	u8				properties_count_str;
 	unsigned long			last_update;
+	u8				cache_invalid;
 	unsigned int			update_interval;
 	bool				changed;
 	struct gb_power_supply_prop	*props;
@@ -636,15 +637,28 @@ static int _gb_power_supply_property_get(struct gb_power_supply *gbpsy,
 	return 0;
 }
 
-static int gb_power_supply_status_get(struct gb_power_supply *gbpsy)
+static int is_cache_valid(struct gb_power_supply *gbpsy)
 {
-	int ret = 0;
-	int i;
+	/* check if cache is good enough or it has expired */
+	if (gbpsy->cache_invalid) {
+		gbpsy->cache_invalid = 0;
+		return 0;
+	}
 
-	/* check if cache is good enough */
 	if (gbpsy->last_update &&
 	    time_is_after_jiffies(gbpsy->last_update +
 				  msecs_to_jiffies(cache_time)))
+		return 1;
+
+	return 0;
+}
+
+static int gb_power_supply_status_get(struct gb_power_supply *gbpsy)
+{
+	int ret = 0;
+	int i;
+
+	if (is_cache_valid(gbpsy))
 		return 0;
 
 	for (i = 0; i < gbpsy->properties_count; i++) {
@@ -987,8 +1001,15 @@ static int gb_supplies_request_handler(struct gb_operation *op)
 		goto out_unlock;
 	}
 
-	if (event & GB_POWER_SUPPLY_UPDATE)
+	if (event & GB_POWER_SUPPLY_UPDATE) {
+		/*
+		 * we need to make sure we invalidate cache, if not no new
+		 * values for the properties will be fetch and the all propose
+		 * of this event is missed
+		 */
+		gbpsy->cache_invalid = 1;
 		gb_power_supply_status_update(gbpsy);
+	}
 
 out_unlock:
 	mutex_unlock(&supplies->supplies_lock);

commit 5f66d62e8372d8a9c97bd75d772a5a5788925218
Author: Rui Miguel Silva <rui.silva@linaro.org>
Date:   Tue Aug 16 22:31:56 2016 +0100

    greybus: power_supply: fix update interval check at request handler
    
    We use the update interval to control the remove path and we set it to
    zero when we do not want to have more updates in transit. That means
    that the check in the request handler needs to be for interval update
    zero to discard the newly received request and not the other way around
    like it is.
    
    This will fix the issue that all incoming requests were being discard.
    
    Signed-off-by: Rui Miguel Silva <rui.silva@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/power_supply.c b/drivers/staging/greybus/power_supply.c
index aeb6a07e43a6..3d6f81017d98 100644
--- a/drivers/staging/greybus/power_supply.c
+++ b/drivers/staging/greybus/power_supply.c
@@ -982,7 +982,7 @@ static int gb_supplies_request_handler(struct gb_operation *op)
 	 * running. For that just check update_interval.
 	 */
 	gbpsy = &supplies->supply[psy_id];
-	if (gbpsy->update_interval) {
+	if (!gbpsy->update_interval) {
 		ret = -ESHUTDOWN;
 		goto out_unlock;
 	}

commit c4582f9d7969019dc67234e96340e21dd3712c46
Author: Rui Miguel Silva <rui.silva@linaro.org>
Date:   Tue Aug 16 22:31:55 2016 +0100

    greybus: power_supply: add callback to handle power supply changes
    
    When checking for property changes we may need to act upon that change
    besides reporting it using power_supply_changed. So, add a function that
    will be call if the specific property changed.
    
    As at it, adjust some indentation of the psy_props_changes array.
    
    Signed-off-by: Rui Miguel Silva <rui.silva@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/power_supply.c b/drivers/staging/greybus/power_supply.c
index 058fd3c60bd4..aeb6a07e43a6 100644
--- a/drivers/staging/greybus/power_supply.c
+++ b/drivers/staging/greybus/power_supply.c
@@ -70,17 +70,22 @@ static unsigned int update_interval_max = 30 * HZ;
 struct gb_power_supply_changes {
 	enum power_supply_property	prop;
 	u32				tolerance_change;
+	void (*prop_changed)(struct gb_power_supply *gbpsy,
+			     struct gb_power_supply_prop *prop);
 };
 
 static const struct gb_power_supply_changes psy_props_changes[] = {
-	{	.prop =			GB_POWER_SUPPLY_PROP_STATUS,
-		.tolerance_change =	0,
+	{	.prop			= GB_POWER_SUPPLY_PROP_STATUS,
+		.tolerance_change	= 0,
+		.prop_changed		= NULL,
 	},
-	{	.prop =			GB_POWER_SUPPLY_PROP_TEMP,
-		.tolerance_change =	500,
+	{	.prop			= GB_POWER_SUPPLY_PROP_TEMP,
+		.tolerance_change	= 500,
+		.prop_changed		= NULL,
 	},
-	{	.prop =			GB_POWER_SUPPLY_PROP_ONLINE,
-		.tolerance_change =	0,
+	{	.prop			= GB_POWER_SUPPLY_PROP_ONLINE,
+		.tolerance_change	= 0,
+		.prop_changed		= NULL,
 	},
 };
 
@@ -349,18 +354,25 @@ static void check_changed(struct gb_power_supply *gbpsy,
 	const struct gb_power_supply_changes *psyc;
 	int val = prop->val;
 	int prev_val = prop->previous_val;
+	bool changed = false;
 	int i;
 
 	for (i = 0; i < ARRAY_SIZE(psy_props_changes); i++) {
 		psyc = &psy_props_changes[i];
 		if (prop->prop == psyc->prop) {
 			if (!psyc->tolerance_change)
-				gbpsy->changed = true;
+				changed = true;
 			else if (val < prev_val &&
 				 prev_val - val > psyc->tolerance_change)
-				gbpsy->changed = true;
+				changed = true;
 			else if (val > prev_val &&
 				 val - prev_val > psyc->tolerance_change)
+				changed = true;
+
+			if (changed && psyc->prop_changed)
+				psyc->prop_changed(gbpsy, prop);
+
+			if (changed)
 				gbpsy->changed = true;
 			break;
 		}

commit 47becc556d4e8dc5bcd370100edebd6ad749b702
Author: Rui Miguel Silva <rui.silva@linaro.org>
Date:   Wed Jul 13 14:11:20 2016 +0100

    greybus: power_supply: convert greybus properties to power supply properties
    
    We need to translate greybus properties to power supply core properties,
    for that when parsing the properties that were fetch during
    configuration we check if there is a match to the running kernel version
    and store it in a new field (gb_prop) in the gb_power_supply_prop
    struct.
    
    If the corresponding property does not exist in the running
    kernel (because of version or vendor specific property) we drop that
    property.
    
    A collection of properties that, at this time, may diverge are defined
    in the kernel_ver.h to avoid breakage at build time and run time if this
    properties are not supported by the kernel.
    
    Signed-off-by: Rui Miguel Silva <rui.silva@linaro.org>
    Reviewed-by: Sandeep Patil <sspatil@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/power_supply.c b/drivers/staging/greybus/power_supply.c
index f905c3c5c2ac..058fd3c60bd4 100644
--- a/drivers/staging/greybus/power_supply.c
+++ b/drivers/staging/greybus/power_supply.c
@@ -18,6 +18,7 @@
 
 struct gb_power_supply_prop {
 	enum power_supply_property	prop;
+	u8				gb_prop;
 	int				val;
 	int				previous_val;
 	bool				is_writeable;
@@ -83,6 +84,210 @@ static const struct gb_power_supply_changes psy_props_changes[] = {
 	},
 };
 
+static int get_psp_from_gb_prop(int gb_prop, enum power_supply_property *psp)
+{
+	int prop;
+
+	switch (gb_prop) {
+	case GB_POWER_SUPPLY_PROP_STATUS:
+		prop = POWER_SUPPLY_PROP_STATUS;
+		break;
+	case GB_POWER_SUPPLY_PROP_CHARGE_TYPE:
+		prop = POWER_SUPPLY_PROP_CHARGE_TYPE;
+		break;
+	case GB_POWER_SUPPLY_PROP_HEALTH:
+		prop = POWER_SUPPLY_PROP_HEALTH;
+		break;
+	case GB_POWER_SUPPLY_PROP_PRESENT:
+		prop = POWER_SUPPLY_PROP_PRESENT;
+		break;
+	case GB_POWER_SUPPLY_PROP_ONLINE:
+		prop = POWER_SUPPLY_PROP_ONLINE;
+		break;
+	case GB_POWER_SUPPLY_PROP_AUTHENTIC:
+		prop = POWER_SUPPLY_PROP_AUTHENTIC;
+		break;
+	case GB_POWER_SUPPLY_PROP_TECHNOLOGY:
+		prop = POWER_SUPPLY_PROP_TECHNOLOGY;
+		break;
+	case GB_POWER_SUPPLY_PROP_CYCLE_COUNT:
+		prop = POWER_SUPPLY_PROP_CYCLE_COUNT;
+		break;
+	case GB_POWER_SUPPLY_PROP_VOLTAGE_MAX:
+		prop = POWER_SUPPLY_PROP_VOLTAGE_MAX;
+		break;
+	case GB_POWER_SUPPLY_PROP_VOLTAGE_MIN:
+		prop = POWER_SUPPLY_PROP_VOLTAGE_MIN;
+		break;
+	case GB_POWER_SUPPLY_PROP_VOLTAGE_MAX_DESIGN:
+		prop = POWER_SUPPLY_PROP_VOLTAGE_MAX_DESIGN;
+		break;
+	case GB_POWER_SUPPLY_PROP_VOLTAGE_MIN_DESIGN:
+		prop = POWER_SUPPLY_PROP_VOLTAGE_MIN_DESIGN;
+		break;
+	case GB_POWER_SUPPLY_PROP_VOLTAGE_NOW:
+		prop = POWER_SUPPLY_PROP_VOLTAGE_NOW;
+		break;
+	case GB_POWER_SUPPLY_PROP_VOLTAGE_AVG:
+		prop = POWER_SUPPLY_PROP_VOLTAGE_AVG;
+		break;
+	case GB_POWER_SUPPLY_PROP_VOLTAGE_OCV:
+		prop = POWER_SUPPLY_PROP_VOLTAGE_OCV;
+		break;
+	case GB_POWER_SUPPLY_PROP_VOLTAGE_BOOT:
+		prop = POWER_SUPPLY_PROP_VOLTAGE_BOOT;
+		break;
+	case GB_POWER_SUPPLY_PROP_CURRENT_MAX:
+		prop = POWER_SUPPLY_PROP_CURRENT_MAX;
+		break;
+	case GB_POWER_SUPPLY_PROP_CURRENT_NOW:
+		prop = POWER_SUPPLY_PROP_CURRENT_NOW;
+		break;
+	case GB_POWER_SUPPLY_PROP_CURRENT_AVG:
+		prop = POWER_SUPPLY_PROP_CURRENT_AVG;
+		break;
+	case GB_POWER_SUPPLY_PROP_CURRENT_BOOT:
+		prop = POWER_SUPPLY_PROP_CURRENT_BOOT;
+		break;
+	case GB_POWER_SUPPLY_PROP_POWER_NOW:
+		prop = POWER_SUPPLY_PROP_POWER_NOW;
+		break;
+	case GB_POWER_SUPPLY_PROP_POWER_AVG:
+		prop = POWER_SUPPLY_PROP_POWER_AVG;
+		break;
+	case GB_POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN:
+		prop = POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN;
+		break;
+	case GB_POWER_SUPPLY_PROP_CHARGE_EMPTY_DESIGN:
+		prop = POWER_SUPPLY_PROP_CHARGE_EMPTY_DESIGN;
+		break;
+	case GB_POWER_SUPPLY_PROP_CHARGE_FULL:
+		prop = POWER_SUPPLY_PROP_CHARGE_FULL;
+		break;
+	case GB_POWER_SUPPLY_PROP_CHARGE_EMPTY:
+		prop = POWER_SUPPLY_PROP_CHARGE_EMPTY;
+		break;
+	case GB_POWER_SUPPLY_PROP_CHARGE_NOW:
+		prop = POWER_SUPPLY_PROP_CHARGE_NOW;
+		break;
+	case GB_POWER_SUPPLY_PROP_CHARGE_AVG:
+		prop = POWER_SUPPLY_PROP_CHARGE_AVG;
+		break;
+	case GB_POWER_SUPPLY_PROP_CHARGE_COUNTER:
+		prop = POWER_SUPPLY_PROP_CHARGE_COUNTER;
+		break;
+	case GB_POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT:
+		prop = POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT;
+		break;
+	case GB_POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT_MAX:
+		prop = POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT_MAX;
+		break;
+	case GB_POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE:
+		prop = POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE;
+		break;
+	case GB_POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE_MAX:
+		prop = POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE_MAX;
+		break;
+	case GB_POWER_SUPPLY_PROP_CHARGE_CONTROL_LIMIT:
+		prop = POWER_SUPPLY_PROP_CHARGE_CONTROL_LIMIT;
+		break;
+	case GB_POWER_SUPPLY_PROP_CHARGE_CONTROL_LIMIT_MAX:
+		prop = POWER_SUPPLY_PROP_CHARGE_CONTROL_LIMIT_MAX;
+		break;
+	case GB_POWER_SUPPLY_PROP_INPUT_CURRENT_LIMIT:
+		prop = POWER_SUPPLY_PROP_INPUT_CURRENT_LIMIT;
+		break;
+	case GB_POWER_SUPPLY_PROP_ENERGY_FULL_DESIGN:
+		prop = POWER_SUPPLY_PROP_ENERGY_FULL_DESIGN;
+		break;
+	case GB_POWER_SUPPLY_PROP_ENERGY_EMPTY_DESIGN:
+		prop = POWER_SUPPLY_PROP_ENERGY_EMPTY_DESIGN;
+		break;
+	case GB_POWER_SUPPLY_PROP_ENERGY_FULL:
+		prop = POWER_SUPPLY_PROP_ENERGY_FULL;
+		break;
+	case GB_POWER_SUPPLY_PROP_ENERGY_EMPTY:
+		prop = POWER_SUPPLY_PROP_ENERGY_EMPTY;
+		break;
+	case GB_POWER_SUPPLY_PROP_ENERGY_NOW:
+		prop = POWER_SUPPLY_PROP_ENERGY_NOW;
+		break;
+	case GB_POWER_SUPPLY_PROP_ENERGY_AVG:
+		prop = POWER_SUPPLY_PROP_ENERGY_AVG;
+		break;
+	case GB_POWER_SUPPLY_PROP_CAPACITY:
+		prop = POWER_SUPPLY_PROP_CAPACITY;
+		break;
+	case GB_POWER_SUPPLY_PROP_CAPACITY_ALERT_MIN:
+		prop = POWER_SUPPLY_PROP_CAPACITY_ALERT_MIN;
+		break;
+	case GB_POWER_SUPPLY_PROP_CAPACITY_ALERT_MAX:
+		prop = POWER_SUPPLY_PROP_CAPACITY_ALERT_MAX;
+		break;
+	case GB_POWER_SUPPLY_PROP_CAPACITY_LEVEL:
+		prop = POWER_SUPPLY_PROP_CAPACITY_LEVEL;
+		break;
+	case GB_POWER_SUPPLY_PROP_TEMP:
+		prop = POWER_SUPPLY_PROP_TEMP;
+		break;
+	case GB_POWER_SUPPLY_PROP_TEMP_MAX:
+		prop = POWER_SUPPLY_PROP_TEMP_MAX;
+		break;
+	case GB_POWER_SUPPLY_PROP_TEMP_MIN:
+		prop = POWER_SUPPLY_PROP_TEMP_MIN;
+		break;
+	case GB_POWER_SUPPLY_PROP_TEMP_ALERT_MIN:
+		prop = POWER_SUPPLY_PROP_TEMP_ALERT_MIN;
+		break;
+	case GB_POWER_SUPPLY_PROP_TEMP_ALERT_MAX:
+		prop = POWER_SUPPLY_PROP_TEMP_ALERT_MAX;
+		break;
+	case GB_POWER_SUPPLY_PROP_TEMP_AMBIENT:
+		prop = POWER_SUPPLY_PROP_TEMP_AMBIENT;
+		break;
+	case GB_POWER_SUPPLY_PROP_TEMP_AMBIENT_ALERT_MIN:
+		prop = POWER_SUPPLY_PROP_TEMP_AMBIENT_ALERT_MIN;
+		break;
+	case GB_POWER_SUPPLY_PROP_TEMP_AMBIENT_ALERT_MAX:
+		prop = POWER_SUPPLY_PROP_TEMP_AMBIENT_ALERT_MAX;
+		break;
+	case GB_POWER_SUPPLY_PROP_TIME_TO_EMPTY_NOW:
+		prop = POWER_SUPPLY_PROP_TIME_TO_EMPTY_NOW;
+		break;
+	case GB_POWER_SUPPLY_PROP_TIME_TO_EMPTY_AVG:
+		prop = POWER_SUPPLY_PROP_TIME_TO_EMPTY_AVG;
+		break;
+	case GB_POWER_SUPPLY_PROP_TIME_TO_FULL_NOW:
+		prop = POWER_SUPPLY_PROP_TIME_TO_FULL_NOW;
+		break;
+	case GB_POWER_SUPPLY_PROP_TIME_TO_FULL_AVG:
+		prop = POWER_SUPPLY_PROP_TIME_TO_FULL_AVG;
+		break;
+	case GB_POWER_SUPPLY_PROP_TYPE:
+		prop = POWER_SUPPLY_PROP_TYPE;
+		break;
+	case GB_POWER_SUPPLY_PROP_SCOPE:
+		prop = POWER_SUPPLY_PROP_SCOPE;
+		break;
+	case GB_POWER_SUPPLY_PROP_CHARGE_TERM_CURRENT:
+		prop = POWER_SUPPLY_PROP_CHARGE_TERM_CURRENT;
+		break;
+	case GB_POWER_SUPPLY_PROP_CALIBRATE:
+		prop = POWER_SUPPLY_PROP_CALIBRATE;
+		break;
+	default:
+		prop = -1;
+		break;
+	}
+
+	if (prop < 0)
+		return prop;
+
+	*psp = (enum power_supply_property)prop;
+
+	return 0;
+}
+
 static struct gb_connection *get_conn_from_psy(struct gb_power_supply *gbpsy)
 {
 	return gbpsy->supplies->connection;
@@ -253,8 +458,9 @@ static int gb_power_supply_prop_descriptors_get(struct gb_power_supply *gbpsy)
 	struct gb_power_supply_get_property_descriptors_response *resp;
 	struct gb_operation *op;
 	u8 props_count = gbpsy->properties_count;
+	enum power_supply_property psp;
 	int ret;
-	int i;
+	int i, r = 0;
 
 	if (props_count == 0)
 		return 0;
@@ -276,6 +482,17 @@ static int gb_power_supply_prop_descriptors_get(struct gb_power_supply *gbpsy)
 
 	resp = op->response->payload;
 
+	/* validate received properties */
+	for (i = 0; i < props_count; i++) {
+		ret = get_psp_from_gb_prop(resp->props[i].property, &psp);
+		if (ret < 0) {
+			dev_warn(&connection->bundle->dev,
+				 "greybus property %u it is not supported by this kernel, dropped\n",
+				 resp->props[i].property);
+			gbpsy->properties_count--;
+		}
+	}
+
 	gbpsy->props = kcalloc(gbpsy->properties_count, sizeof(*gbpsy->props),
 			      GFP_KERNEL);
 	if (!gbpsy->props) {
@@ -290,12 +507,18 @@ static int gb_power_supply_prop_descriptors_get(struct gb_power_supply *gbpsy)
 		goto out_put_operation;
 	}
 
-	/* Store available properties */
-	for (i = 0; i < gbpsy->properties_count; i++) {
-		gbpsy->props[i].prop = resp->props[i].property;
-		gbpsy->props_raw[i] = resp->props[i].property;
+	/* Store available properties, skip the ones we do not support */
+	for (i = 0; i < props_count; i++) {
+		ret = get_psp_from_gb_prop(resp->props[i].property, &psp);
+		if (ret < 0) {
+			r++;
+			continue;
+		}
+		gbpsy->props[i - r].prop = psp;
+		gbpsy->props[i - r].gb_prop = resp->props[i].property;
+		gbpsy->props_raw[i - r] = psp;
 		if (resp->props[i].is_writeable)
-			gbpsy->props[i].is_writeable = true;
+			gbpsy->props[i - r].is_writeable = true;
 	}
 
 	/*
@@ -304,6 +527,7 @@ static int gb_power_supply_prop_descriptors_get(struct gb_power_supply *gbpsy)
 	 */
 	_gb_power_supply_append_props(gbpsy);
 
+	ret = 0;
 out_put_operation:
 	gb_operation_put(op);
 
@@ -324,7 +548,7 @@ static int __gb_power_supply_property_update(struct gb_power_supply *gbpsy,
 	if (!prop)
 		return -EINVAL;
 	req.psy_id = gbpsy->id;
-	req.property = (u8)psp;
+	req.property = prop->gb_prop;
 
 	ret = gb_operation_sync(connection, GB_POWER_SUPPLY_TYPE_GET_PROPERTY,
 				&req, sizeof(req), &resp, sizeof(resp));
@@ -479,8 +703,7 @@ static int gb_power_supply_property_set(struct gb_power_supply *gbpsy,
 	if (!prop)
 		return -EINVAL;
 	req.psy_id = gbpsy->id;
-	req.property = (u8)psp;
-	req.prop_val = cpu_to_le32(val);
+	req.property = prop->gb_prop;
 	req.prop_val = cpu_to_le32((s32)val);
 
 	ret = gb_operation_sync(connection, GB_POWER_SUPPLY_TYPE_SET_PROPERTY,

commit 6e720c277ad126de2052b90dd4114953f2d00f79
Author: Rui Miguel Silva <rui.silva@linaro.org>
Date:   Wed Jul 13 14:11:19 2016 +0100

    greybus: power_supply: change property values to integer
    
    To align with power supply core values type (integer) move the val and
    previous_val to integer also.
    
    Signed-off-by: Rui Miguel Silva <rui.silva@linaro.org>
    Reviewed-by: Sandeep Patil <sspatil@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/power_supply.c b/drivers/staging/greybus/power_supply.c
index e96c24da007b..f905c3c5c2ac 100644
--- a/drivers/staging/greybus/power_supply.c
+++ b/drivers/staging/greybus/power_supply.c
@@ -18,8 +18,8 @@
 
 struct gb_power_supply_prop {
 	enum power_supply_property	prop;
-	u32				val;
-	u32				previous_val;
+	int				val;
+	int				previous_val;
 	bool				is_writeable;
 };
 
@@ -142,8 +142,8 @@ static void check_changed(struct gb_power_supply *gbpsy,
 			  struct gb_power_supply_prop *prop)
 {
 	const struct gb_power_supply_changes *psyc;
-	u32 val = prop->val;
-	u32 prev_val = prop->previous_val;
+	int val = prop->val;
+	int prev_val = prop->previous_val;
 	int i;
 
 	for (i = 0; i < ARRAY_SIZE(psy_props_changes); i++) {
@@ -317,7 +317,7 @@ static int __gb_power_supply_property_update(struct gb_power_supply *gbpsy,
 	struct gb_power_supply_prop *prop;
 	struct gb_power_supply_get_property_request req;
 	struct gb_power_supply_get_property_response resp;
-	u32 val;
+	int val;
 	int ret;
 
 	prop = get_psy_prop(gbpsy, psp);
@@ -481,6 +481,7 @@ static int gb_power_supply_property_set(struct gb_power_supply *gbpsy,
 	req.psy_id = gbpsy->id;
 	req.property = (u8)psp;
 	req.prop_val = cpu_to_le32(val);
+	req.prop_val = cpu_to_le32((s32)val);
 
 	ret = gb_operation_sync(connection, GB_POWER_SUPPLY_TYPE_SET_PROPERTY,
 				&req, sizeof(req), NULL, 0);

commit 60fb3405c73ea0bbab942c699496123f9e987c04
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Fri Jun 10 14:59:07 2016 +0530

    greybus: Remove extra blank lines
    
    This patch removes few blank lines across the repository at places where
    two blank lines were present together or when a blank line is present at
    the start or end of a routine.
    
    Note that this doesn't remove most of them from greybus_protocols.h as
    they were added on purpose.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/power_supply.c b/drivers/staging/greybus/power_supply.c
index 8d6570d1bb61..e96c24da007b 100644
--- a/drivers/staging/greybus/power_supply.c
+++ b/drivers/staging/greybus/power_supply.c
@@ -290,7 +290,6 @@ static int gb_power_supply_prop_descriptors_get(struct gb_power_supply *gbpsy)
 		goto out_put_operation;
 	}
 
-
 	/* Store available properties */
 	for (i = 0; i < gbpsy->properties_count; i++) {
 		gbpsy->props[i].prop = resp->props[i].property;
@@ -512,7 +511,6 @@ static int property_is_writeable(struct power_supply *b,
 	return is_psy_prop_writeable(gbpsy, psp);
 }
 
-
 #ifndef CORE_OWNS_PSY_STRUCT
 static int gb_power_supply_register(struct gb_power_supply *gbpsy)
 {
@@ -562,7 +560,6 @@ static void _gb_power_supply_free(struct gb_power_supply *gbpsy)
 
 static void _gb_power_supply_release(struct gb_power_supply *gbpsy)
 {
-
 	gbpsy->update_interval = 0;
 
 	cancel_delayed_work_sync(&gbpsy->work);

commit 95073cc2e53c1352f2c244408d1bd005b07650fd
Author: Alex Elder <elder@linaro.org>
Date:   Tue May 24 13:34:51 2016 -0500

    greybus: use PTR_ERR_OR_ZERO()
    
    Coccinelle points out that the macro PTR_ERR_OR_ZERO() handles the
    frequent case of converting a pointer into either error code (if its
    value is an encoded error value) or 0 (otherwise).  Switch some code
    in gb_power_supply_register() to use that macro.  I have verified
    this is true of the kernel we're now working with (arche-6.0).
    
    Signed-off-by: Alex Elder <elder@linaro.org>
    Reviewed-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/power_supply.c b/drivers/staging/greybus/power_supply.c
index 9cae396c6115..8d6570d1bb61 100644
--- a/drivers/staging/greybus/power_supply.c
+++ b/drivers/staging/greybus/power_supply.c
@@ -547,10 +547,7 @@ static int gb_power_supply_register(struct gb_power_supply *gbpsy)
 
 	gbpsy->psy = power_supply_register(&connection->bundle->dev,
 					   &gbpsy->desc, &cfg);
-	if (IS_ERR(gbpsy->psy))
-		return PTR_ERR(gbpsy->psy);
-
-	return 0;
+	return PTR_ERR_OR_ZERO(gbpsy->psy);
 }
 #endif
 

commit 0ec306324423444d3ee0222708ef9de7f5586b93
Author: Greg Kroah-Hartman <gregkh@google.com>
Date:   Tue Mar 22 14:30:35 2016 -0400

    greybus: convert drivers to use connection->private set/get
    
    This converts all drivers to use the gb_connection_get_data() and
    gb_connection_set_data() functions to make it a bit more explicit as to
    what is going on.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>
    Reviewed-by: Alex Elder <elder@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/power_supply.c b/drivers/staging/greybus/power_supply.c
index ec8fb1b84024..9cae396c6115 100644
--- a/drivers/staging/greybus/power_supply.c
+++ b/drivers/staging/greybus/power_supply.c
@@ -711,7 +711,7 @@ static int gb_power_supplies_register(struct gb_power_supplies *supplies)
 static int gb_supplies_request_handler(struct gb_operation *op)
 {
 	struct gb_connection *connection = op->connection;
-	struct gb_power_supplies *supplies = connection->private;
+	struct gb_power_supplies *supplies = gb_connection_get_data(connection);
 	struct gb_power_supply *gbpsy;
 	struct gb_message *request;
 	struct gb_power_supply_event_request *payload;
@@ -792,7 +792,7 @@ static int gb_power_supply_probe(struct gb_bundle *bundle,
 	}
 
 	supplies->connection = connection;
-	connection->private = supplies;
+	gb_connection_set_data(connection, supplies);
 
 	mutex_init(&supplies->supplies_lock);
 

commit f8811c7630912617d1bc0e0b18e3221fec26f9cf
Author: Sandeep Patil <sspatil@google.com>
Date:   Tue Mar 15 12:28:38 2016 -0700

    greybus: power_supply: reverse version check for new psy API
    
    Reversing the kernel version check for new power supply APIs will
    easily allow us to use older kernels with backported power supply APIs
    by defining "CORE_OWNS_PSY_STRUCT" in power supply core header
    
    Testing Done:
    - Build tested with arche kernel with backported power supply APIs
    - Build tested also with current arche kernel to make sure we build with
      3.10 kernels
    
    Signed-off-by: Sandeep Patil <sspatil@google.com>
    Reviewed-by: Rui Miguel Silva <rui.silva@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/power_supply.c b/drivers/staging/greybus/power_supply.c
index 0467537bf4f6..ec8fb1b84024 100644
--- a/drivers/staging/greybus/power_supply.c
+++ b/drivers/staging/greybus/power_supply.c
@@ -26,7 +26,7 @@ struct gb_power_supply_prop {
 struct gb_power_supply {
 	u8				id;
 	bool				registered;
-#ifdef DRIVER_OWNS_PSY_STRUCT
+#ifndef CORE_OWNS_PSY_STRUCT
 	struct power_supply		psy;
 #define to_gb_power_supply(x) container_of(x, struct gb_power_supply, psy)
 #else
@@ -126,7 +126,7 @@ static void next_interval(struct gb_power_supply *gbpsy)
 		gbpsy->update_interval = update_interval_max;
 }
 
-#ifdef DRIVER_OWNS_PSY_STRUCT
+#ifndef CORE_OWNS_PSY_STRUCT
 static void __gb_power_supply_changed(struct gb_power_supply *gbpsy)
 {
 	power_supply_changed(&gbpsy->psy);
@@ -513,7 +513,7 @@ static int property_is_writeable(struct power_supply *b,
 }
 
 
-#ifdef DRIVER_OWNS_PSY_STRUCT
+#ifndef CORE_OWNS_PSY_STRUCT
 static int gb_power_supply_register(struct gb_power_supply *gbpsy)
 {
 	struct gb_connection *connection = get_conn_from_psy(gbpsy);
@@ -569,7 +569,7 @@ static void _gb_power_supply_release(struct gb_power_supply *gbpsy)
 	gbpsy->update_interval = 0;
 
 	cancel_delayed_work_sync(&gbpsy->work);
-#ifdef DRIVER_OWNS_PSY_STRUCT
+#ifndef CORE_OWNS_PSY_STRUCT
 	if (gbpsy->registered)
 		power_supply_unregister(&gbpsy->psy);
 #else

commit 68b1309be689ec4e93d2b48e09ccaaa8abf5b0b6
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Fri Feb 12 16:08:33 2016 +0530

    greybus: power_supply: convert to bundle driver
    
    Convert the legacy power_supply protocol driver to a bundle driver.
    
    This also fixes a potential crash should a (malicious) module have sent
    an early request before the private data had been initialised.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Reviewed-by: Johan Hovold <johan@hovoldconsulting.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/power_supply.c b/drivers/staging/greybus/power_supply.c
index c50b30d1a632..0467537bf4f6 100644
--- a/drivers/staging/greybus/power_supply.c
+++ b/drivers/staging/greybus/power_supply.c
@@ -708,7 +708,7 @@ static int gb_power_supplies_register(struct gb_power_supplies *supplies)
 	return ret;
 }
 
-static int gb_power_supply_event_recv(u8 type, struct gb_operation *op)
+static int gb_supplies_request_handler(struct gb_operation *op)
 {
 	struct gb_connection *connection = op->connection;
 	struct gb_power_supplies *supplies = connection->private;
@@ -719,9 +719,9 @@ static int gb_power_supply_event_recv(u8 type, struct gb_operation *op)
 	u8 event;
 	int ret = 0;
 
-	if (type != GB_POWER_SUPPLY_TYPE_EVENT) {
+	if (op->type != GB_POWER_SUPPLY_TYPE_EVENT) {
 		dev_err(&connection->bundle->dev,
-			"Unsupported unsolicited event: %u\n", type);
+			"Unsupported unsolicited event: %u\n", op->type);
 		return -EINVAL;
 	}
 
@@ -765,52 +765,90 @@ static int gb_power_supply_event_recv(u8 type, struct gb_operation *op)
 	return ret;
 }
 
-static int gb_power_supply_connection_init(struct gb_connection *connection)
+static int gb_power_supply_probe(struct gb_bundle *bundle,
+				 const struct greybus_bundle_id *id)
 {
+	struct greybus_descriptor_cport *cport_desc;
+	struct gb_connection *connection;
 	struct gb_power_supplies *supplies;
 	int ret;
 
+	if (bundle->num_cports != 1)
+		return -ENODEV;
+
+	cport_desc = &bundle->cport_desc[0];
+	if (cport_desc->protocol_id != GREYBUS_PROTOCOL_POWER_SUPPLY)
+		return -ENODEV;
+
 	supplies = kzalloc(sizeof(*supplies), GFP_KERNEL);
 	if (!supplies)
 		return -ENOMEM;
 
+	connection = gb_connection_create(bundle, le16_to_cpu(cport_desc->id),
+					  gb_supplies_request_handler);
+	if (IS_ERR(connection)) {
+		ret = PTR_ERR(connection);
+		goto out;
+	}
+
 	supplies->connection = connection;
 	connection->private = supplies;
 
 	mutex_init(&supplies->supplies_lock);
 
+	greybus_set_drvdata(bundle, supplies);
+
+	/* We aren't ready to receive an incoming request yet */
+	ret = gb_connection_enable_tx(connection);
+	if (ret)
+		goto error_connection_destroy;
+
 	ret = gb_power_supplies_setup(supplies);
 	if (ret < 0)
-		goto out;
+		goto error_connection_disable;
+
+	/* We are ready to receive an incoming request now, enable RX as well */
+	ret = gb_connection_enable(connection);
+	if (ret)
+		goto error_connection_disable;
 
 	ret = gb_power_supplies_register(supplies);
 	if (ret < 0)
-		goto out;
+		goto error_connection_disable;
 
 	return 0;
 
+error_connection_disable:
+	gb_connection_disable(connection);
+error_connection_destroy:
+	gb_connection_destroy(connection);
 out:
 	_gb_power_supplies_release(supplies);
 	return ret;
 }
 
-static void gb_power_supply_connection_exit(struct gb_connection *connection)
+static void gb_power_supply_disconnect(struct gb_bundle *bundle)
 {
-	struct gb_power_supplies *supplies = connection->private;
+	struct gb_power_supplies *supplies = greybus_get_drvdata(bundle);
+
+	gb_connection_disable(supplies->connection);
+	gb_connection_destroy(supplies->connection);
 
 	_gb_power_supplies_release(supplies);
 }
 
-static struct gb_protocol power_supply_protocol = {
-	.name			= "power_supply",
-	.id			= GREYBUS_PROTOCOL_POWER_SUPPLY,
-	.major			= GB_POWER_SUPPLY_VERSION_MAJOR,
-	.minor			= GB_POWER_SUPPLY_VERSION_MINOR,
-	.connection_init	= gb_power_supply_connection_init,
-	.connection_exit	= gb_power_supply_connection_exit,
-	.request_recv		= gb_power_supply_event_recv,
+static const struct greybus_bundle_id gb_power_supply_id_table[] = {
+	{ GREYBUS_DEVICE_CLASS(GREYBUS_CLASS_POWER_SUPPLY) },
+	{ }
 };
+MODULE_DEVICE_TABLE(greybus, gb_power_supply_id_table);
 
-gb_protocol_driver(&power_supply_protocol);
+static struct greybus_driver gb_power_supply_driver = {
+	.name		= "power_supply",
+	.probe		= gb_power_supply_probe,
+	.disconnect	= gb_power_supply_disconnect,
+	.id_table	= gb_power_supply_id_table,
+};
+module_greybus_driver(gb_power_supply_driver);
 
 MODULE_LICENSE("GPL v2");

commit 7e9fba8df7606bcace9d22394f59c2047dd55091
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Fri Feb 12 16:08:32 2016 +0530

    greybus: power_supply: Break supply setup into two parts
    
    This breaks the power supply setup routine into two parts, the first one
    allocates all the necessary resources and the second on registers
    supplies to the required frameworks.
    
    This is required to enable only TX on the connection, until we have
    allocated all the resources, otherwise the request handler might get
    called for partially initialized structures.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Reviewed-by: Rui Miguel Silva <rui.silva@linaro.org>
    Reviewed-by: Johan Hovold <johan@hovoldconsulting.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/power_supply.c b/drivers/staging/greybus/power_supply.c
index 37bea9c0cea8..c50b30d1a632 100644
--- a/drivers/staging/greybus/power_supply.c
+++ b/drivers/staging/greybus/power_supply.c
@@ -624,31 +624,33 @@ static int gb_power_supply_config(struct gb_power_supplies *supplies, int id)
 
 	ret = gb_power_supply_description_get(gbpsy);
 	if (ret < 0)
-		goto out;
+		return ret;
 
 	ret = gb_power_supply_prop_descriptors_get(gbpsy);
 	if (ret < 0)
-		goto out;
+		return ret;
 
 	/* guarantee that we have an unique name, before register */
-	ret = __gb_power_supply_set_name(gbpsy->model_name, gbpsy->name,
-					 sizeof(gbpsy->name));
-	if (ret < 0)
-		goto out;
+	return __gb_power_supply_set_name(gbpsy->model_name, gbpsy->name,
+					  sizeof(gbpsy->name));
+}
+
+static int gb_power_supply_enable(struct gb_power_supply *gbpsy)
+{
+	int ret;
 
 	ret = gb_power_supply_register(gbpsy);
 	if (ret < 0)
-		goto out;
+		return ret;
 
 	gbpsy->update_interval = update_interval_init;
 	INIT_DELAYED_WORK(&gbpsy->work, gb_power_supply_work);
 	schedule_delayed_work(&gbpsy->work, 0);
 
-out:
-	/* if everything went fine just mark it for release code to know */
-	if (ret == 0)
-		gbpsy->registered = true;
-	return ret;
+	/* everything went fine, mark it for release code to know */
+	gbpsy->registered = true;
+
+	return 0;
 }
 
 static int gb_power_supplies_setup(struct gb_power_supplies *supplies)
@@ -685,6 +687,27 @@ static int gb_power_supplies_setup(struct gb_power_supplies *supplies)
 	return ret;
 }
 
+static int gb_power_supplies_register(struct gb_power_supplies *supplies)
+{
+	struct gb_connection *connection = supplies->connection;
+	int ret = 0;
+	int i;
+
+	mutex_lock(&supplies->supplies_lock);
+
+	for (i = 0; i < supplies->supplies_count; i++) {
+		ret = gb_power_supply_enable(&supplies->supply[i]);
+		if (ret < 0) {
+			dev_err(&connection->bundle->dev,
+				"Fail to enable supplies devices\n");
+			break;
+		}
+	}
+
+	mutex_unlock(&supplies->supplies_lock);
+	return ret;
+}
+
 static int gb_power_supply_event_recv(u8 type, struct gb_operation *op)
 {
 	struct gb_connection *connection = op->connection;
@@ -758,8 +781,16 @@ static int gb_power_supply_connection_init(struct gb_connection *connection)
 
 	ret = gb_power_supplies_setup(supplies);
 	if (ret < 0)
-		_gb_power_supplies_release(supplies);
+		goto out;
+
+	ret = gb_power_supplies_register(supplies);
+	if (ret < 0)
+		goto out;
+
+	return 0;
 
+out:
+	_gb_power_supplies_release(supplies);
 	return ret;
 }
 

commit 9d15134d067ecb52bf02136234fbd1d09e1706d8
Author: Rui Miguel Silva <rui.silva@linaro.org>
Date:   Thu Feb 4 14:00:36 2016 +0000

    greybus: power_supply: rework get descriptors
    
    Rework the get property descriptors function to fix a memory handling
    error for the response structure. This could corrupt the stack and
    throw nonalignment PC or SP error:
    
    Internal error: SP or PC abort: 8a000000 1 PREEMPT SMP
    Modules linked in: gb_power_supply(O) gb_arche(O) gb_camera(O) gb_es2(O) gb_vibrator(O) gb_raw(O) g]
    CPU: 3 PID: 51 Comm: kworker/u16:2 Tainted: G W O 3.10.73-g8a6af60-00118-g599a5c1 #1
    Workqueue: greybus1:svc gb_svc_connection_destroy [greybus]
    task: ffffffc0ba249580 ti: ffffffc0ba294000 task.ti: ffffffc0ba294000
    PC is at gb_power_supply_connection_init+0x81/0x1dc [gb_power_supply]
    LR is at gb_power_supply_connection_init+0x81/0x1dc [gb_power_supply]
    pc : [<ffffffbffc03b901>] lr : [<ffffffbffc03b901>] pstate: 80000145
    sp : ffffffc0ba297a00
    x29: 32002e002a001100 x28: ffffffc042cb2c80
    
    To fix this, allocate firstly the operation and handle request and
    response using operation payload.
    
    Signed-off-by: Rui Miguel Silva <rui.silva@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/power_supply.c b/drivers/staging/greybus/power_supply.c
index 2dc193a081b0..37bea9c0cea8 100644
--- a/drivers/staging/greybus/power_supply.c
+++ b/drivers/staging/greybus/power_supply.c
@@ -249,39 +249,53 @@ static int gb_power_supply_description_get(struct gb_power_supply *gbpsy)
 static int gb_power_supply_prop_descriptors_get(struct gb_power_supply *gbpsy)
 {
 	struct gb_connection *connection = get_conn_from_psy(gbpsy);
-	struct gb_power_supply_get_property_descriptors_request req;
-	struct gb_power_supply_get_property_descriptors_response resp;
+	struct gb_power_supply_get_property_descriptors_request *req;
+	struct gb_power_supply_get_property_descriptors_response *resp;
+	struct gb_operation *op;
+	u8 props_count = gbpsy->properties_count;
 	int ret;
 	int i;
 
-	if (gbpsy->properties_count == 0)
+	if (props_count == 0)
 		return 0;
 
-	req.psy_id = gbpsy->id;
+	op = gb_operation_create(connection,
+				 GB_POWER_SUPPLY_TYPE_GET_PROP_DESCRIPTORS,
+				 sizeof(req), sizeof(*resp) + props_count *
+				 sizeof(struct gb_power_supply_props_desc),
+				 GFP_KERNEL);
+	if (!op)
+		return -ENOMEM;
 
-	ret = gb_operation_sync(connection,
-				GB_POWER_SUPPLY_TYPE_GET_PROP_DESCRIPTORS,
-				&req, sizeof(req), &resp,
-				sizeof(resp) + gbpsy->properties_count *
-				sizeof(struct gb_power_supply_props_desc));
+	req = op->request->payload;
+	req->psy_id = gbpsy->id;
+
+	ret = gb_operation_request_send_sync(op);
 	if (ret < 0)
-		return ret;
+		goto out_put_operation;
+
+	resp = op->response->payload;
 
 	gbpsy->props = kcalloc(gbpsy->properties_count, sizeof(*gbpsy->props),
 			      GFP_KERNEL);
-	if (!gbpsy->props)
-		return -ENOMEM;
+	if (!gbpsy->props) {
+		ret = -ENOMEM;
+		goto out_put_operation;
+	}
+
+	gbpsy->props_raw = kcalloc(gbpsy->properties_count,
+				   sizeof(*gbpsy->props_raw), GFP_KERNEL);
+	if (!gbpsy->props_raw) {
+		ret = -ENOMEM;
+		goto out_put_operation;
+	}
 
-	gbpsy->props_raw = kzalloc(gbpsy->properties_count *
-				  sizeof(*gbpsy->props_raw), GFP_KERNEL);
-	if (!gbpsy->props_raw)
-		return -ENOMEM;
 
 	/* Store available properties */
 	for (i = 0; i < gbpsy->properties_count; i++) {
-		gbpsy->props[i].prop = resp.props[i].property;
-		gbpsy->props_raw[i] = resp.props[i].property;
-		if (resp.props[i].is_writeable)
+		gbpsy->props[i].prop = resp->props[i].property;
+		gbpsy->props_raw[i] = resp->props[i].property;
+		if (resp->props[i].is_writeable)
 			gbpsy->props[i].is_writeable = true;
 	}
 
@@ -291,7 +305,10 @@ static int gb_power_supply_prop_descriptors_get(struct gb_power_supply *gbpsy)
 	 */
 	_gb_power_supply_append_props(gbpsy);
 
-	return 0;
+out_put_operation:
+	gb_operation_put(op);
+
+	return ret;
 }
 
 static int __gb_power_supply_property_update(struct gb_power_supply *gbpsy,

commit adb57cff54dd4418f4d5b17f03a976dfdc670226
Author: Rui Miguel Silva <rui.silva@linaro.org>
Date:   Tue Jan 12 14:38:21 2016 +0000

    greybus: power_supply: fix check for configured supply
    
    The correct check for if the power supply is ready to receive event is
    wrong and it should check for the registered flag.
    
    Signed-off-by: Rui Miguel Silva <rui.silva@linaro.org>
    Reported-by: Johan Hovold <johan@hovoldconsulting.com>
    Reviewed-by: Johan Hovold <johan@hovoldconsulting.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/power_supply.c b/drivers/staging/greybus/power_supply.c
index d985e13b5a0d..2dc193a081b0 100644
--- a/drivers/staging/greybus/power_supply.c
+++ b/drivers/staging/greybus/power_supply.c
@@ -697,7 +697,8 @@ static int gb_power_supply_event_recv(u8 type, struct gb_operation *op)
 	payload = request->payload;
 	psy_id = payload->psy_id;
 	mutex_lock(&supplies->supplies_lock);
-	if (psy_id >= supplies->supplies_count || !&supplies->supply[psy_id]) {
+	if (psy_id >= supplies->supplies_count ||
+	    !supplies->supply[psy_id].registered) {
 		dev_err(&connection->bundle->dev,
 			"Event received for unconfigured power_supply id: %d\n",
 			psy_id);

commit accad1ba7d62543ab3bcf08813726ea87d237bb6
Author: Rui Miguel Silva <rui.silva@linaro.org>
Date:   Fri Jan 8 13:53:47 2016 +0000

    greybus: power_supply: fix use after free of power supply
    
    Individual power supply were being freed and checked using the wrong
    pointers and at the wrong place, which would make several issues, like
    used after free and so on.
    Fix it by freeing all allocated memory after release individual power
    supply.
    
    Signed-off-by: Rui Miguel Silva <rui.silva@linaro.org>
    Reported-by: Johan Hovold <johan@hovoldconsulting.com>
    Reviewed-by: Johan Hovold <johan@hovoldconsulting.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/power_supply.c b/drivers/staging/greybus/power_supply.c
index 3c9bb12351e4..d985e13b5a0d 100644
--- a/drivers/staging/greybus/power_supply.c
+++ b/drivers/staging/greybus/power_supply.c
@@ -544,13 +544,10 @@ static void _gb_power_supply_free(struct gb_power_supply *gbpsy)
 	kfree(gbpsy->manufacturer);
 	kfree(gbpsy->props_raw);
 	kfree(gbpsy->props);
-	kfree(gbpsy);
 }
 
 static void _gb_power_supply_release(struct gb_power_supply *gbpsy)
 {
-	if (!gbpsy)
-		return;
 
 	gbpsy->update_interval = 0;
 
@@ -576,6 +573,7 @@ static void _gb_power_supplies_release(struct gb_power_supplies *supplies)
 	mutex_lock(&supplies->supplies_lock);
 	for (i = 0; i < supplies->supplies_count; i++)
 		_gb_power_supply_release(&supplies->supply[i]);
+	kfree(supplies->supply);
 	mutex_unlock(&supplies->supplies_lock);
 	kfree(supplies);
 }

commit f921fb139bd5ee008ec993c76b8a89a535fd11e9
Author: Rui Miguel Silva <rui.silva@linaro.org>
Date:   Fri Jan 8 13:53:46 2016 +0000

    greybus: power_supply: fix leak getting string properties
    
    When fetching string properties, memory was being allocated and leaked
    when it was not necessary to do so.
    
    Signed-off-by: Rui Miguel Silva <rui.silva@linaro.org>
    Reviewed-by: Johan Hovold <johan@hovoldconsulting.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/power_supply.c b/drivers/staging/greybus/power_supply.c
index 28548a243240..3c9bb12351e4 100644
--- a/drivers/staging/greybus/power_supply.c
+++ b/drivers/staging/greybus/power_supply.c
@@ -347,15 +347,13 @@ static int __gb_power_supply_property_strval_get(struct gb_power_supply *gbpsy,
 {
 	switch (psp) {
 	case POWER_SUPPLY_PROP_MODEL_NAME:
-		val->strval = kstrndup(gbpsy->model_name, PROP_MAX, GFP_KERNEL);
+		val->strval = gbpsy->model_name;
 		break;
 	case POWER_SUPPLY_PROP_MANUFACTURER:
-		val->strval = kstrndup(gbpsy->manufacturer, PROP_MAX,
-				       GFP_KERNEL);
+		val->strval = gbpsy->manufacturer;
 		break;
 	case POWER_SUPPLY_PROP_SERIAL_NUMBER:
-		val->strval = kstrndup(gbpsy->serial_number, PROP_MAX,
-				       GFP_KERNEL);
+		val->strval = gbpsy->serial_number;
 		break;
 	default:
 		break;

commit d9eafd58e3e365d71cd7d477a1c5675db1931027
Author: Rui Miguel Silva <rui.silva@linaro.org>
Date:   Fri Jan 8 13:53:45 2016 +0000

    greybus: power_supply: fix error path at supplies setup
    
    If something goes wrong at setup time for the supplies, we need to
    release all the resources allocated already.
    
    Call the supplies release function which will handle the correct
    teardown of the supplies.
    
    Signed-off-by: Rui Miguel Silva <rui.silva@linaro.org>
    Reported-by: Johan Hovold <johan@hovoldconsulting.com>
    Reviewed-by: Johan Hovold <johan@hovoldconsulting.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/power_supply.c b/drivers/staging/greybus/power_supply.c
index 7d1848b99d9b..28548a243240 100644
--- a/drivers/staging/greybus/power_supply.c
+++ b/drivers/staging/greybus/power_supply.c
@@ -731,6 +731,7 @@ static int gb_power_supply_event_recv(u8 type, struct gb_operation *op)
 static int gb_power_supply_connection_init(struct gb_connection *connection)
 {
 	struct gb_power_supplies *supplies;
+	int ret;
 
 	supplies = kzalloc(sizeof(*supplies), GFP_KERNEL);
 	if (!supplies)
@@ -741,7 +742,11 @@ static int gb_power_supply_connection_init(struct gb_connection *connection)
 
 	mutex_init(&supplies->supplies_lock);
 
-	return gb_power_supplies_setup(supplies);
+	ret = gb_power_supplies_setup(supplies);
+	if (ret < 0)
+		_gb_power_supplies_release(supplies);
+
+	return ret;
 }
 
 static void gb_power_supply_connection_exit(struct gb_connection *connection)

commit 23f25ba6edd4121eb70baf3df12f5592bee8a1e9
Author: Rui Miguel Silva <rui.silva@linaro.org>
Date:   Fri Jan 8 13:53:44 2016 +0000

    greybus: power_supply: free supplies at release
    
    After freeing each individual power_supply, free the top controller, if
    not it will leak memory at each module insert/remove.
    
    Signed-off-by: Rui Miguel Silva <rui.silva@linaro.org>
    Reported-by: Johan Hovold <johan@hovoldconsulting.com>
    Reviewed-by: Johan Hovold <johan@hovoldconsulting.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/power_supply.c b/drivers/staging/greybus/power_supply.c
index 764d2f640164..7d1848b99d9b 100644
--- a/drivers/staging/greybus/power_supply.c
+++ b/drivers/staging/greybus/power_supply.c
@@ -579,6 +579,7 @@ static void _gb_power_supplies_release(struct gb_power_supplies *supplies)
 	for (i = 0; i < supplies->supplies_count; i++)
 		_gb_power_supply_release(&supplies->supply[i]);
 	mutex_unlock(&supplies->supplies_lock);
+	kfree(supplies);
 }
 
 static int gb_power_supplies_get_count(struct gb_power_supplies *supplies)

commit ff85f723ca362986dc984217433cbdd133fc03d6
Author: Rui Miguel Silva <rui.silva@linaro.org>
Date:   Fri Jan 8 13:53:43 2016 +0000

    greybus: power_supply: fix unregister on error path
    
    If setup fail the release for each supply needs to know the status at
    unregister time. So, add the field to the structure, update it at setup
    time and use it at release.
    
    Signed-off-by: Rui Miguel Silva <rui.silva@linaro.org>
    Reported-by: Johan Hovold <johan@hovoldconsulting.com>
    Reviewed-by: Johan Hovold <johan@hovoldconsulting.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/power_supply.c b/drivers/staging/greybus/power_supply.c
index 1ce57f6333da..764d2f640164 100644
--- a/drivers/staging/greybus/power_supply.c
+++ b/drivers/staging/greybus/power_supply.c
@@ -25,6 +25,7 @@ struct gb_power_supply_prop {
 
 struct gb_power_supply {
 	u8				id;
+	bool				registered;
 #ifdef DRIVER_OWNS_PSY_STRUCT
 	struct power_supply		psy;
 #define to_gb_power_supply(x) container_of(x, struct gb_power_supply, psy)
@@ -557,9 +558,11 @@ static void _gb_power_supply_release(struct gb_power_supply *gbpsy)
 
 	cancel_delayed_work_sync(&gbpsy->work);
 #ifdef DRIVER_OWNS_PSY_STRUCT
-	power_supply_unregister(&gbpsy->psy);
+	if (gbpsy->registered)
+		power_supply_unregister(&gbpsy->psy);
 #else
-	power_supply_unregister(gbpsy->psy);
+	if (gbpsy->registered)
+		power_supply_unregister(gbpsy->psy);
 #endif
 
 	_gb_power_supply_free(gbpsy);
@@ -628,6 +631,9 @@ static int gb_power_supply_config(struct gb_power_supplies *supplies, int id)
 	schedule_delayed_work(&gbpsy->work, 0);
 
 out:
+	/* if everything went fine just mark it for release code to know */
+	if (ret == 0)
+		gbpsy->registered = true;
 	return ret;
 }
 

commit 7ccac20d59ca45a2efea93a24a99d57022ff8911
Author: Rui Miguel Silva <rui.silva@linaro.org>
Date:   Fri Jan 8 13:53:42 2016 +0000

    greybus: power_supply: do not release failed supply alloc
    
    If allocation of memory for each supply fail, we should get out of
    release any individual supply.
    
    Signed-off-by: Rui Miguel Silva <rui.silva@linaro.org>
    Reported-by: Johan Hovold <johan@hovoldconsulting.com>
    Reviewed-by: Johan Hovold <johan@hovoldconsulting.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/power_supply.c b/drivers/staging/greybus/power_supply.c
index 1f3884bccf97..1ce57f6333da 100644
--- a/drivers/staging/greybus/power_supply.c
+++ b/drivers/staging/greybus/power_supply.c
@@ -569,6 +569,9 @@ static void _gb_power_supplies_release(struct gb_power_supplies *supplies)
 {
 	int i;
 
+	if (!supplies->supply)
+		return;
+
 	mutex_lock(&supplies->supplies_lock);
 	for (i = 0; i < supplies->supplies_count; i++)
 		_gb_power_supply_release(&supplies->supply[i]);

commit e0d91ff127cf68e6369cfccd51af18b07bf462e3
Author: Johan Hovold <johan@hovoldconsulting.com>
Date:   Thu Jan 7 12:28:29 2016 +0100

    greybus: power_supply: fix lock imbalance in init error path
    
    Make sure to release the supplies_lock before returning on errors in
    gb_power_supplies_setup().
    
    Signed-off-by: Johan Hovold <johan@hovoldconsulting.com>
    Reviewed-by: Rui Miguel Silva <rui.silva@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/power_supply.c b/drivers/staging/greybus/power_supply.c
index 4a7381650bb7..1f3884bccf97 100644
--- a/drivers/staging/greybus/power_supply.c
+++ b/drivers/staging/greybus/power_supply.c
@@ -644,8 +644,10 @@ static int gb_power_supplies_setup(struct gb_power_supplies *supplies)
 				     sizeof(struct gb_power_supply),
 				     GFP_KERNEL);
 
-	if (!supplies->supply)
-		return -ENOMEM;
+	if (!supplies->supply) {
+		ret = -ENOMEM;
+		goto out;
+	}
 
 	for (i = 0; i < supplies->supplies_count; i++) {
 		ret = gb_power_supply_config(supplies, i);

commit ffe2e2487a388cf01ec44439346363aa8d654cd4
Author: Rui Miguel Silva <rui.silva@linaro.org>
Date:   Thu Nov 12 15:36:02 2015 +0000

    greybus: power_supply: rework and operation changes
    
    This is a major rework and changes to the current implementation of the
    battery protocol. The previous implementation lack the support of a more
    dynamic handle of power supply properties and updating of status. Also,
    reflect the actual state of the greybus specification
    
    So, with this new approach a set of operations to fetch the battery
    module configuration and properties is add, new methods to cache and
    update the values of properties, new operation to set properties if
    declared writable and an event operation that can be triggered by the
    module to force an update read on the properties values.
    
    Signed-off-by: Rui Miguel Silva <rui.silva@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/power_supply.c b/drivers/staging/greybus/power_supply.c
index d7797a24e00d..4a7381650bb7 100644
--- a/drivers/staging/greybus/power_supply.c
+++ b/drivers/staging/greybus/power_supply.c
@@ -1,308 +1,742 @@
 /*
  * Power Supply driver for a Greybus module.
  *
- * Copyright 2014 Google Inc.
- * Copyright 2014 Linaro Ltd.
+ * Copyright 2014-2015 Google Inc.
+ * Copyright 2014-2015 Linaro Ltd.
  *
  * Released under the GPLv2 only.
  */
 
 #include <linux/kernel.h>
 #include <linux/module.h>
-#include <linux/slab.h>
 #include <linux/power_supply.h>
+#include <linux/slab.h>
+
 #include "greybus.h"
 
+#define PROP_MAX 32
+
+struct gb_power_supply_prop {
+	enum power_supply_property	prop;
+	u32				val;
+	u32				previous_val;
+	bool				is_writeable;
+};
+
 struct gb_power_supply {
-	/*
-	 * The power supply api changed in 4.1, so handle both the old
-	 * and new apis in the same driver for now, until this is merged
-	 * upstream, when all of these version checks can be removed.
-	 */
+	u8				id;
 #ifdef DRIVER_OWNS_PSY_STRUCT
-	struct power_supply psy;
+	struct power_supply		psy;
 #define to_gb_power_supply(x) container_of(x, struct gb_power_supply, psy)
 #else
-	struct power_supply *psy;
-	struct power_supply_desc desc;
+	struct power_supply		*psy;
+	struct power_supply_desc	desc;
 #define to_gb_power_supply(x) power_supply_get_drvdata(x)
 #endif
-	// FIXME
-	// we will want to keep the power supply stats in here as we will be
-	// getting updates from the SVC "on the fly" so we don't have to always
-	// go ask the power supply for some information. Hopefully...
-	struct gb_connection *connection;
+	char				name[64];
+	struct gb_power_supplies	*supplies;
+	struct delayed_work		work;
+	char				*manufacturer;
+	char				*model_name;
+	char				*serial_number;
+	u8				type;
+	u8				properties_count;
+	u8				properties_count_str;
+	unsigned long			last_update;
+	unsigned int			update_interval;
+	bool				changed;
+	struct gb_power_supply_prop	*props;
+	enum power_supply_property	*props_raw;
+};
+
+struct gb_power_supplies {
+	struct gb_connection	*connection;
+	u8			supplies_count;
+	struct gb_power_supply	*supply;
+	struct mutex		supplies_lock;
+};
+
+/* cache time in milliseconds, if cache_time is set to 0 cache is disable */
+static unsigned int cache_time = 1000;
+/*
+ * update interval initial and maximum value, between the two will
+ * back-off exponential
+ */
+static unsigned int update_interval_init = 1 * HZ;
+static unsigned int update_interval_max = 30 * HZ;
+
+struct gb_power_supply_changes {
+	enum power_supply_property	prop;
+	u32				tolerance_change;
+};
 
+static const struct gb_power_supply_changes psy_props_changes[] = {
+	{	.prop =			GB_POWER_SUPPLY_PROP_STATUS,
+		.tolerance_change =	0,
+	},
+	{	.prop =			GB_POWER_SUPPLY_PROP_TEMP,
+		.tolerance_change =	500,
+	},
+	{	.prop =			GB_POWER_SUPPLY_PROP_ONLINE,
+		.tolerance_change =	0,
+	},
 };
 
-static int get_tech(struct gb_power_supply *gb)
+static struct gb_connection *get_conn_from_psy(struct gb_power_supply *gbpsy)
 {
-	struct gb_power_supply_technology_response tech_response;
-	u32 technology;
-	int retval;
+	return gbpsy->supplies->connection;
+}
 
-	retval = gb_operation_sync(gb->connection,
-				   GB_POWER_SUPPLY_TYPE_TECHNOLOGY,
-				   NULL, 0,
-				   &tech_response, sizeof(tech_response));
-	if (retval)
-		return retval;
+static struct gb_power_supply_prop *get_psy_prop(struct gb_power_supply *gbpsy,
+						 enum power_supply_property psp)
+{
+	int i;
 
-	/*
-	 * Map greybus values to power_supply values.  Hopefully these are
-	 * "identical" which should allow gcc to optimize the code away to
-	 * nothing.
-	 */
-	technology = le32_to_cpu(tech_response.technology);
-	switch (technology) {
-	case GB_POWER_SUPPLY_TECH_NiMH:
-		technology = POWER_SUPPLY_TECHNOLOGY_NiMH;
-		break;
-	case GB_POWER_SUPPLY_TECH_LION:
-		technology = POWER_SUPPLY_TECHNOLOGY_LION;
-		break;
-	case GB_POWER_SUPPLY_TECH_LIPO:
-		technology = POWER_SUPPLY_TECHNOLOGY_LIPO;
-		break;
-	case GB_POWER_SUPPLY_TECH_LiFe:
-		technology = POWER_SUPPLY_TECHNOLOGY_LiFe;
-		break;
-	case GB_POWER_SUPPLY_TECH_NiCd:
-		technology = POWER_SUPPLY_TECHNOLOGY_NiCd;
-		break;
-	case GB_POWER_SUPPLY_TECH_LiMn:
-		technology = POWER_SUPPLY_TECHNOLOGY_LiMn;
-		break;
-	case GB_POWER_SUPPLY_TECH_UNKNOWN:
-	default:
-		technology = POWER_SUPPLY_TECHNOLOGY_UNKNOWN;
-		break;
+	for (i = 0; i < gbpsy->properties_count; i++)
+		if (gbpsy->props[i].prop == psp)
+			return &gbpsy->props[i];
+	return NULL;
+}
+
+static int is_psy_prop_writeable(struct gb_power_supply *gbpsy,
+				     enum power_supply_property psp)
+{
+	struct gb_power_supply_prop *prop;
+
+	prop = get_psy_prop(gbpsy, psp);
+	if (!prop)
+		return -ENOENT;
+	return prop->is_writeable ? 1 : 0;
+}
+
+static int is_prop_valint(enum power_supply_property psp)
+{
+	return ((psp < POWER_SUPPLY_PROP_MODEL_NAME) ? 1 : 0);
+}
+
+static void next_interval(struct gb_power_supply *gbpsy)
+{
+	if (gbpsy->update_interval == update_interval_max)
+		return;
+
+	/* do some exponential back-off in the update interval */
+	gbpsy->update_interval *= 2;
+	if (gbpsy->update_interval > update_interval_max)
+		gbpsy->update_interval = update_interval_max;
+}
+
+#ifdef DRIVER_OWNS_PSY_STRUCT
+static void __gb_power_supply_changed(struct gb_power_supply *gbpsy)
+{
+	power_supply_changed(&gbpsy->psy);
+}
+#else
+static void __gb_power_supply_changed(struct gb_power_supply *gbpsy)
+{
+	power_supply_changed(gbpsy->psy);
+}
+#endif
+
+static void check_changed(struct gb_power_supply *gbpsy,
+			  struct gb_power_supply_prop *prop)
+{
+	const struct gb_power_supply_changes *psyc;
+	u32 val = prop->val;
+	u32 prev_val = prop->previous_val;
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(psy_props_changes); i++) {
+		psyc = &psy_props_changes[i];
+		if (prop->prop == psyc->prop) {
+			if (!psyc->tolerance_change)
+				gbpsy->changed = true;
+			else if (val < prev_val &&
+				 prev_val - val > psyc->tolerance_change)
+				gbpsy->changed = true;
+			else if (val > prev_val &&
+				 val - prev_val > psyc->tolerance_change)
+				gbpsy->changed = true;
+			break;
+		}
 	}
-	return technology;
 }
 
-static int get_status(struct gb_power_supply *gb)
+static int total_props(struct gb_power_supply *gbpsy)
 {
-	struct gb_power_supply_status_response status_response;
-	u16 psy_status;
-	int retval;
+	/* this return the intval plus the strval properties */
+	return (gbpsy->properties_count + gbpsy->properties_count_str);
+}
 
-	retval = gb_operation_sync(gb->connection, GB_POWER_SUPPLY_TYPE_STATUS,
-				   NULL, 0,
-				   &status_response, sizeof(status_response));
-	if (retval)
-		return retval;
+static void prop_append(struct gb_power_supply *gbpsy,
+			enum power_supply_property prop)
+{
+	enum power_supply_property *new_props_raw;
+
+	gbpsy->properties_count_str++;
+	new_props_raw = krealloc(gbpsy->props_raw, total_props(gbpsy) *
+				 sizeof(enum power_supply_property),
+				 GFP_KERNEL);
+	if (!new_props_raw)
+		return;
+	gbpsy->props_raw = new_props_raw;
+	gbpsy->props_raw[total_props(gbpsy) - 1] = prop;
+}
+
+static int __gb_power_supply_set_name(char *init_name, char *name, size_t len)
+{
+	unsigned int i = 0;
+	int ret = 0;
+	struct power_supply *psy;
+
+	if (!strlen(init_name))
+		init_name = "gb_power_supply";
+	strlcpy(name, init_name, len);
+
+	while ((ret < len) && (psy = power_supply_get_by_name(name))) {
+#ifdef PSY_HAVE_PUT
+		power_supply_put(psy);
+#endif
+		ret = snprintf(name, len, "%s_%u", init_name, ++i);
+	}
+	if (ret >= len)
+		return -ENOMEM;
+	return i;
+}
+
+static void _gb_power_supply_append_props(struct gb_power_supply *gbpsy)
+{
+	if (strlen(gbpsy->manufacturer))
+		prop_append(gbpsy, POWER_SUPPLY_PROP_MANUFACTURER);
+	if (strlen(gbpsy->model_name))
+		prop_append(gbpsy, POWER_SUPPLY_PROP_MODEL_NAME);
+	if (strlen(gbpsy->serial_number))
+		prop_append(gbpsy, POWER_SUPPLY_PROP_SERIAL_NUMBER);
+}
+
+static int gb_power_supply_description_get(struct gb_power_supply *gbpsy)
+{
+	struct gb_connection *connection = get_conn_from_psy(gbpsy);
+	struct gb_power_supply_get_description_request req;
+	struct gb_power_supply_get_description_response resp;
+	int ret;
+
+	req.psy_id = gbpsy->id;
+
+	ret = gb_operation_sync(connection,
+				GB_POWER_SUPPLY_TYPE_GET_DESCRIPTION,
+				&req, sizeof(req), &resp, sizeof(resp));
+	if (ret < 0)
+		return ret;
+
+	gbpsy->manufacturer = kstrndup(resp.manufacturer, PROP_MAX, GFP_KERNEL);
+	if (!gbpsy->manufacturer)
+		return -ENOMEM;
+	gbpsy->model_name = kstrndup(resp.model, PROP_MAX, GFP_KERNEL);
+	if (!gbpsy->model_name)
+		return -ENOMEM;
+	gbpsy->serial_number = kstrndup(resp.serial_number, PROP_MAX,
+				       GFP_KERNEL);
+	if (!gbpsy->serial_number)
+		return -ENOMEM;
+
+	gbpsy->type = le16_to_cpu(resp.type);
+	gbpsy->properties_count = resp.properties_count;
+
+	return 0;
+}
+
+static int gb_power_supply_prop_descriptors_get(struct gb_power_supply *gbpsy)
+{
+	struct gb_connection *connection = get_conn_from_psy(gbpsy);
+	struct gb_power_supply_get_property_descriptors_request req;
+	struct gb_power_supply_get_property_descriptors_response resp;
+	int ret;
+	int i;
+
+	if (gbpsy->properties_count == 0)
+		return 0;
+
+	req.psy_id = gbpsy->id;
+
+	ret = gb_operation_sync(connection,
+				GB_POWER_SUPPLY_TYPE_GET_PROP_DESCRIPTORS,
+				&req, sizeof(req), &resp,
+				sizeof(resp) + gbpsy->properties_count *
+				sizeof(struct gb_power_supply_props_desc));
+	if (ret < 0)
+		return ret;
+
+	gbpsy->props = kcalloc(gbpsy->properties_count, sizeof(*gbpsy->props),
+			      GFP_KERNEL);
+	if (!gbpsy->props)
+		return -ENOMEM;
+
+	gbpsy->props_raw = kzalloc(gbpsy->properties_count *
+				  sizeof(*gbpsy->props_raw), GFP_KERNEL);
+	if (!gbpsy->props_raw)
+		return -ENOMEM;
+
+	/* Store available properties */
+	for (i = 0; i < gbpsy->properties_count; i++) {
+		gbpsy->props[i].prop = resp.props[i].property;
+		gbpsy->props_raw[i] = resp.props[i].property;
+		if (resp.props[i].is_writeable)
+			gbpsy->props[i].is_writeable = true;
+	}
 
 	/*
-	 * Map greybus values to power_supply values.  Hopefully these are
-	 * "identical" which should allow gcc to optimize the code away to
-	 * nothing.
+	 * now append the properties that we already got information in the
+	 * get_description operation. (char * ones)
 	 */
-	psy_status = le16_to_cpu(status_response.psy_status);
-	switch (psy_status) {
-	case GB_POWER_SUPPLY_STATUS_CHARGING:
-		psy_status = POWER_SUPPLY_STATUS_CHARGING;
-		break;
-	case GB_POWER_SUPPLY_STATUS_DISCHARGING:
-		psy_status = POWER_SUPPLY_STATUS_DISCHARGING;
+	_gb_power_supply_append_props(gbpsy);
+
+	return 0;
+}
+
+static int __gb_power_supply_property_update(struct gb_power_supply *gbpsy,
+					     enum power_supply_property psp)
+{
+	struct gb_connection *connection = get_conn_from_psy(gbpsy);
+	struct gb_power_supply_prop *prop;
+	struct gb_power_supply_get_property_request req;
+	struct gb_power_supply_get_property_response resp;
+	u32 val;
+	int ret;
+
+	prop = get_psy_prop(gbpsy, psp);
+	if (!prop)
+		return -EINVAL;
+	req.psy_id = gbpsy->id;
+	req.property = (u8)psp;
+
+	ret = gb_operation_sync(connection, GB_POWER_SUPPLY_TYPE_GET_PROPERTY,
+				&req, sizeof(req), &resp, sizeof(resp));
+	if (ret < 0)
+		return ret;
+
+	val = le32_to_cpu(resp.prop_val);
+	if (val == prop->val)
+		return 0;
+
+	prop->previous_val = prop->val;
+	prop->val = val;
+
+	check_changed(gbpsy, prop);
+
+	return 0;
+}
+
+static int __gb_power_supply_property_get(struct gb_power_supply *gbpsy,
+					  enum power_supply_property psp,
+					  union power_supply_propval *val)
+{
+	struct gb_power_supply_prop *prop;
+
+	prop = get_psy_prop(gbpsy, psp);
+	if (!prop)
+		return -EINVAL;
+
+	val->intval = prop->val;
+	return 0;
+}
+
+static int __gb_power_supply_property_strval_get(struct gb_power_supply *gbpsy,
+						enum power_supply_property psp,
+						union power_supply_propval *val)
+{
+	switch (psp) {
+	case POWER_SUPPLY_PROP_MODEL_NAME:
+		val->strval = kstrndup(gbpsy->model_name, PROP_MAX, GFP_KERNEL);
 		break;
-	case GB_POWER_SUPPLY_STATUS_NOT_CHARGING:
-		psy_status = POWER_SUPPLY_STATUS_NOT_CHARGING;
+	case POWER_SUPPLY_PROP_MANUFACTURER:
+		val->strval = kstrndup(gbpsy->manufacturer, PROP_MAX,
+				       GFP_KERNEL);
 		break;
-	case GB_POWER_SUPPLY_STATUS_FULL:
-		psy_status = POWER_SUPPLY_STATUS_FULL;
+	case POWER_SUPPLY_PROP_SERIAL_NUMBER:
+		val->strval = kstrndup(gbpsy->serial_number, PROP_MAX,
+				       GFP_KERNEL);
 		break;
-	case GB_POWER_SUPPLY_STATUS_UNKNOWN:
 	default:
-		psy_status = POWER_SUPPLY_STATUS_UNKNOWN;
 		break;
 	}
-	return psy_status;
+
+	return 0;
 }
 
-static int get_max_voltage(struct gb_power_supply *gb)
+static int _gb_power_supply_property_get(struct gb_power_supply *gbpsy,
+					 enum power_supply_property psp,
+					 union power_supply_propval *val)
 {
-	struct gb_power_supply_max_voltage_response volt_response;
-	u32 max_voltage;
-	int retval;
+	struct gb_connection *connection = get_conn_from_psy(gbpsy);
+	int ret;
+
+	/*
+	 * Properties of type const char *, were already fetched on
+	 * get_description operation and should be cached in gb
+	 */
+	if (is_prop_valint(psp))
+		ret = __gb_power_supply_property_get(gbpsy, psp, val);
+	else
+		ret = __gb_power_supply_property_strval_get(gbpsy, psp, val);
 
-	retval = gb_operation_sync(gb->connection,
-				   GB_POWER_SUPPLY_TYPE_MAX_VOLTAGE,
-				   NULL, 0,
-				   &volt_response, sizeof(volt_response));
-	if (retval)
-		return retval;
+	if (ret < 0)
+		dev_err(&connection->bundle->dev, "get property %u\n", psp);
 
-	max_voltage = le32_to_cpu(volt_response.max_voltage);
-	return max_voltage;
+	return 0;
 }
 
-static int get_percent_capacity(struct gb_power_supply *gb)
+static int gb_power_supply_status_get(struct gb_power_supply *gbpsy)
 {
-	struct gb_power_supply_capacity_response capacity_response;
-	u32 capacity;
-	int retval;
+	int ret = 0;
+	int i;
+
+	/* check if cache is good enough */
+	if (gbpsy->last_update &&
+	    time_is_after_jiffies(gbpsy->last_update +
+				  msecs_to_jiffies(cache_time)))
+		return 0;
+
+	for (i = 0; i < gbpsy->properties_count; i++) {
+		ret = __gb_power_supply_property_update(gbpsy,
+							gbpsy->props[i].prop);
+		if (ret < 0)
+			break;
+	}
 
-	retval = gb_operation_sync(gb->connection,
-				   GB_POWER_SUPPLY_TYPE_PERCENT_CAPACITY,
-				   NULL, 0, &capacity_response,
-				   sizeof(capacity_response));
-	if (retval)
-		return retval;
+	if (ret == 0)
+		gbpsy->last_update = jiffies;
 
-	capacity = le32_to_cpu(capacity_response.capacity);
-	return capacity;
+	return ret;
 }
 
-static int get_temp(struct gb_power_supply *gb)
+static void gb_power_supply_status_update(struct gb_power_supply *gbpsy)
 {
-	struct gb_power_supply_temperature_response temp_response;
-	u32 temperature;
-	int retval;
+	/* check if there a change that need to be reported */
+	gb_power_supply_status_get(gbpsy);
 
-	retval = gb_operation_sync(gb->connection,
-				   GB_POWER_SUPPLY_TYPE_TEMPERATURE,
-				   NULL, 0,
-				   &temp_response, sizeof(temp_response));
-	if (retval)
-		return retval;
+	if (!gbpsy->changed)
+		return;
 
-	temperature = le32_to_cpu(temp_response.temperature);
-	return temperature;
+	gbpsy->update_interval = update_interval_init;
+	__gb_power_supply_changed(gbpsy);
+	gbpsy->changed = false;
 }
 
-static int get_voltage(struct gb_power_supply *gb)
+static void gb_power_supply_work(struct work_struct *work)
 {
-	struct gb_power_supply_voltage_response voltage_response;
-	u32 voltage;
-	int retval;
+	struct gb_power_supply *gbpsy = container_of(work,
+						     struct gb_power_supply,
+						     work.work);
 
-	retval = gb_operation_sync(gb->connection, GB_POWER_SUPPLY_TYPE_VOLTAGE,
-				   NULL, 0,
-				   &voltage_response, sizeof(voltage_response));
-	if (retval)
-		return retval;
+	/*
+	 * if the poll interval is not set, disable polling, this is helpful
+	 * specially at unregister time.
+	 */
+	if (!gbpsy->update_interval)
+		return;
 
-	voltage = le32_to_cpu(voltage_response.voltage);
-	return voltage;
+	gb_power_supply_status_update(gbpsy);
+	next_interval(gbpsy);
+	schedule_delayed_work(&gbpsy->work, gbpsy->update_interval);
 }
 
 static int get_property(struct power_supply *b,
 			enum power_supply_property psp,
 			union power_supply_propval *val)
 {
-	struct gb_power_supply *gb = to_gb_power_supply(b);
+	struct gb_power_supply *gbpsy = to_gb_power_supply(b);
 
-	switch (psp) {
-	case POWER_SUPPLY_PROP_TECHNOLOGY:
-		val->intval = get_tech(gb);
-		break;
+	gb_power_supply_status_get(gbpsy);
 
-	case POWER_SUPPLY_PROP_STATUS:
-		val->intval = get_status(gb);
-		break;
+	return _gb_power_supply_property_get(gbpsy, psp, val);
+}
 
-	case POWER_SUPPLY_PROP_VOLTAGE_MAX_DESIGN:
-		val->intval = get_max_voltage(gb);
-		break;
+static int gb_power_supply_property_set(struct gb_power_supply *gbpsy,
+					enum power_supply_property psp,
+					int val)
+{
+	struct gb_connection *connection = get_conn_from_psy(gbpsy);
+	struct gb_power_supply_prop *prop;
+	struct gb_power_supply_set_property_request req;
+	int ret;
 
-	case POWER_SUPPLY_PROP_CAPACITY:
-		val->intval = get_percent_capacity(gb);
-		break;
+	prop = get_psy_prop(gbpsy, psp);
+	if (!prop)
+		return -EINVAL;
+	req.psy_id = gbpsy->id;
+	req.property = (u8)psp;
+	req.prop_val = cpu_to_le32(val);
 
-	case POWER_SUPPLY_PROP_TEMP:
-		val->intval = get_temp(gb);
-		break;
+	ret = gb_operation_sync(connection, GB_POWER_SUPPLY_TYPE_SET_PROPERTY,
+				&req, sizeof(req), NULL, 0);
+	if (ret < 0)
+		goto out;
 
-	case POWER_SUPPLY_PROP_VOLTAGE_NOW:
-		val->intval = get_voltage(gb);
-		break;
+	/* cache immediately the new value */
+	prop->val = val;
 
-	default:
-		return -EINVAL;
-	}
+out:
+	return ret;
+}
 
-	return (val->intval < 0) ? val->intval : 0;
+static int set_property(struct power_supply *b,
+			enum power_supply_property psp,
+			const union power_supply_propval *val)
+{
+	struct gb_power_supply *gbpsy = to_gb_power_supply(b);
+
+	return gb_power_supply_property_set(gbpsy, psp, val->intval);
+}
+
+static int property_is_writeable(struct power_supply *b,
+				 enum power_supply_property psp)
+{
+	struct gb_power_supply *gbpsy = to_gb_power_supply(b);
+
+	return is_psy_prop_writeable(gbpsy, psp);
 }
 
-// FIXME - verify this list, odds are some can be removed and others added.
-static enum power_supply_property psy_props[] = {
-	POWER_SUPPLY_PROP_TECHNOLOGY,
-	POWER_SUPPLY_PROP_STATUS,
-	POWER_SUPPLY_PROP_VOLTAGE_MAX_DESIGN,
-	POWER_SUPPLY_PROP_CAPACITY,
-	POWER_SUPPLY_PROP_TEMP,
-	POWER_SUPPLY_PROP_VOLTAGE_NOW,
-};
 
 #ifdef DRIVER_OWNS_PSY_STRUCT
-static int init_and_register(struct gb_connection *connection,
-			     struct gb_battery *gb)
+static int gb_power_supply_register(struct gb_power_supply *gbpsy)
 {
-	// FIXME - get a better (i.e. unique) name
-	// FIXME - anything else needs to be set?
-	gb->psy.name		= "gb_battery";
-	gb->psy.type		= POWER_SUPPLY_TYPE_BATTERY;
-	gb->psy.properties	= psy_props;
-	gb->psy.num_properties	= ARRAY_SIZE(psy_props);
-	gb->psy.get_property	= get_property;
-
-	return power_supply_register(&connection->bundle->dev, &gb->psy);
+	struct gb_connection *connection = get_conn_from_psy(gbpsy);
+
+	gbpsy->psy.name			= gbpsy->name;
+	gbpsy->psy.type			= gbpsy->type;
+	gbpsy->psy.properties		= gbpsy->props_raw;
+	gbpsy->psy.num_properties	= total_props(gbpsy);
+	gbpsy->psy.get_property		= get_property;
+	gbpsy->psy.set_property		= set_property;
+	gbpsy->psy.property_is_writeable = property_is_writeable;
+
+	return power_supply_register(&connection->bundle->dev,
+				     &gbpsy->psy);
 }
 #else
-static int init_and_register(struct gb_connection *connection,
-			     struct gb_power_supply *gb)
+static int gb_power_supply_register(struct gb_power_supply *gbpsy)
 {
+	struct gb_connection *connection = get_conn_from_psy(gbpsy);
 	struct power_supply_config cfg = {};
 
-	cfg.drv_data = gb;
+	cfg.drv_data = gbpsy;
 
-	// FIXME - get a better (i.e. unique) name
-	// FIXME - anything else needs to be set?
-	gb->desc.name		= "gb_battery";
-	gb->desc.type		= POWER_SUPPLY_TYPE_BATTERY;
-	gb->desc.properties	= psy_props;
-	gb->desc.num_properties	= ARRAY_SIZE(psy_props);
-	gb->desc.get_property	= get_property;
+	gbpsy->desc.name		= gbpsy->name;
+	gbpsy->desc.type		= gbpsy->type;
+	gbpsy->desc.properties		= gbpsy->props_raw;
+	gbpsy->desc.num_properties	= total_props(gbpsy);
+	gbpsy->desc.get_property	= get_property;
+	gbpsy->desc.set_property	= set_property;
+	gbpsy->desc.property_is_writeable = property_is_writeable;
 
-	gb->psy = power_supply_register(&connection->bundle->dev,
-					&gb->desc, &cfg);
-	if (IS_ERR(gb->psy))
-		return PTR_ERR(gb->psy);
+	gbpsy->psy = power_supply_register(&connection->bundle->dev,
+					   &gbpsy->desc, &cfg);
+	if (IS_ERR(gbpsy->psy))
+		return PTR_ERR(gbpsy->psy);
 
 	return 0;
 }
 #endif
 
+static void _gb_power_supply_free(struct gb_power_supply *gbpsy)
+{
+	kfree(gbpsy->serial_number);
+	kfree(gbpsy->model_name);
+	kfree(gbpsy->manufacturer);
+	kfree(gbpsy->props_raw);
+	kfree(gbpsy->props);
+	kfree(gbpsy);
+}
+
+static void _gb_power_supply_release(struct gb_power_supply *gbpsy)
+{
+	if (!gbpsy)
+		return;
+
+	gbpsy->update_interval = 0;
+
+	cancel_delayed_work_sync(&gbpsy->work);
+#ifdef DRIVER_OWNS_PSY_STRUCT
+	power_supply_unregister(&gbpsy->psy);
+#else
+	power_supply_unregister(gbpsy->psy);
+#endif
+
+	_gb_power_supply_free(gbpsy);
+}
+
+static void _gb_power_supplies_release(struct gb_power_supplies *supplies)
+{
+	int i;
+
+	mutex_lock(&supplies->supplies_lock);
+	for (i = 0; i < supplies->supplies_count; i++)
+		_gb_power_supply_release(&supplies->supply[i]);
+	mutex_unlock(&supplies->supplies_lock);
+}
+
+static int gb_power_supplies_get_count(struct gb_power_supplies *supplies)
+{
+	struct gb_power_supply_get_supplies_response resp;
+	int ret;
+
+	ret = gb_operation_sync(supplies->connection,
+				GB_POWER_SUPPLY_TYPE_GET_SUPPLIES,
+				NULL, 0, &resp, sizeof(resp));
+	if (ret < 0)
+		return ret;
+
+	if  (!resp.supplies_count)
+		return -EINVAL;
+
+	supplies->supplies_count = resp.supplies_count;
+
+	return ret;
+}
+
+static int gb_power_supply_config(struct gb_power_supplies *supplies, int id)
+{
+	struct gb_power_supply *gbpsy = &supplies->supply[id];
+	int ret;
+
+	gbpsy->supplies = supplies;
+	gbpsy->id = id;
+
+	ret = gb_power_supply_description_get(gbpsy);
+	if (ret < 0)
+		goto out;
+
+	ret = gb_power_supply_prop_descriptors_get(gbpsy);
+	if (ret < 0)
+		goto out;
+
+	/* guarantee that we have an unique name, before register */
+	ret = __gb_power_supply_set_name(gbpsy->model_name, gbpsy->name,
+					 sizeof(gbpsy->name));
+	if (ret < 0)
+		goto out;
+
+	ret = gb_power_supply_register(gbpsy);
+	if (ret < 0)
+		goto out;
+
+	gbpsy->update_interval = update_interval_init;
+	INIT_DELAYED_WORK(&gbpsy->work, gb_power_supply_work);
+	schedule_delayed_work(&gbpsy->work, 0);
+
+out:
+	return ret;
+}
+
+static int gb_power_supplies_setup(struct gb_power_supplies *supplies)
+{
+	struct gb_connection *connection = supplies->connection;
+	int ret;
+	int i;
+
+	mutex_lock(&supplies->supplies_lock);
+
+	ret = gb_power_supplies_get_count(supplies);
+	if (ret < 0)
+		goto out;
+
+	supplies->supply = kzalloc(supplies->supplies_count *
+				     sizeof(struct gb_power_supply),
+				     GFP_KERNEL);
+
+	if (!supplies->supply)
+		return -ENOMEM;
+
+	for (i = 0; i < supplies->supplies_count; i++) {
+		ret = gb_power_supply_config(supplies, i);
+		if (ret < 0) {
+			dev_err(&connection->bundle->dev,
+				"Fail to configure supplies devices\n");
+			goto out;
+		}
+	}
+out:
+	mutex_unlock(&supplies->supplies_lock);
+	return ret;
+}
+
+static int gb_power_supply_event_recv(u8 type, struct gb_operation *op)
+{
+	struct gb_connection *connection = op->connection;
+	struct gb_power_supplies *supplies = connection->private;
+	struct gb_power_supply *gbpsy;
+	struct gb_message *request;
+	struct gb_power_supply_event_request *payload;
+	u8 psy_id;
+	u8 event;
+	int ret = 0;
+
+	if (type != GB_POWER_SUPPLY_TYPE_EVENT) {
+		dev_err(&connection->bundle->dev,
+			"Unsupported unsolicited event: %u\n", type);
+		return -EINVAL;
+	}
+
+	request = op->request;
+
+	if (request->payload_size < sizeof(*payload)) {
+		dev_err(&connection->bundle->dev,
+			"Wrong event size received (%zu < %zu)\n",
+			request->payload_size, sizeof(*payload));
+		return -EINVAL;
+	}
+
+	payload = request->payload;
+	psy_id = payload->psy_id;
+	mutex_lock(&supplies->supplies_lock);
+	if (psy_id >= supplies->supplies_count || !&supplies->supply[psy_id]) {
+		dev_err(&connection->bundle->dev,
+			"Event received for unconfigured power_supply id: %d\n",
+			psy_id);
+		ret = -EINVAL;
+		goto out_unlock;
+	}
+
+	event = payload->event;
+	/*
+	 * we will only handle events after setup is done and before release is
+	 * running. For that just check update_interval.
+	 */
+	gbpsy = &supplies->supply[psy_id];
+	if (gbpsy->update_interval) {
+		ret = -ESHUTDOWN;
+		goto out_unlock;
+	}
+
+	if (event & GB_POWER_SUPPLY_UPDATE)
+		gb_power_supply_status_update(gbpsy);
+
+out_unlock:
+	mutex_unlock(&supplies->supplies_lock);
+	return ret;
+}
+
 static int gb_power_supply_connection_init(struct gb_connection *connection)
 {
-	struct gb_power_supply *gb;
-	int retval;
+	struct gb_power_supplies *supplies;
 
-	gb = kzalloc(sizeof(*gb), GFP_KERNEL);
-	if (!gb)
+	supplies = kzalloc(sizeof(*supplies), GFP_KERNEL);
+	if (!supplies)
 		return -ENOMEM;
 
-	gb->connection = connection;
-	connection->private = gb;
+	supplies->connection = connection;
+	connection->private = supplies;
 
-	retval = init_and_register(connection, gb);
-	if (retval)
-		kfree(gb);
+	mutex_init(&supplies->supplies_lock);
 
-	return retval;
+	return gb_power_supplies_setup(supplies);
 }
 
 static void gb_power_supply_connection_exit(struct gb_connection *connection)
 {
-	struct gb_power_supply *gb = connection->private;
+	struct gb_power_supplies *supplies = connection->private;
 
-#ifdef DRIVER_OWNS_PSY_STRUCT
-	power_supply_unregister(&gb->psy);
-#else
-	power_supply_unregister(gb->psy);
-#endif
-	kfree(gb);
+	_gb_power_supplies_release(supplies);
 }
 
 static struct gb_protocol power_supply_protocol = {
@@ -312,7 +746,7 @@ static struct gb_protocol power_supply_protocol = {
 	.minor			= GB_POWER_SUPPLY_VERSION_MINOR,
 	.connection_init	= gb_power_supply_connection_init,
 	.connection_exit	= gb_power_supply_connection_exit,
-	.request_recv		= NULL,	/* no incoming requests */
+	.request_recv		= gb_power_supply_event_recv,
 };
 
 gb_protocol_driver(&power_supply_protocol);

commit 2724be0305bc8def0ad05b226fb9867549b35c16
Author: Rui Miguel Silva <rui.silva@linaro.org>
Date:   Thu Nov 12 15:36:00 2015 +0000

    greybus: battery: move implementation to power_supply
    
    Rename protocol to POWER_SUPPLY and implementation details from battery
    to power_supply.
    
    Also fix some tabs between define and macro name.
    
    Signed-off-by: Rui Miguel Silva <rui.silva@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/power_supply.c b/drivers/staging/greybus/power_supply.c
index e119775fb19b..d7797a24e00d 100644
--- a/drivers/staging/greybus/power_supply.c
+++ b/drivers/staging/greybus/power_supply.c
@@ -1,5 +1,5 @@
 /*
- * Battery driver for a Greybus module.
+ * Power Supply driver for a Greybus module.
  *
  * Copyright 2014 Google Inc.
  * Copyright 2014 Linaro Ltd.
@@ -13,35 +13,36 @@
 #include <linux/power_supply.h>
 #include "greybus.h"
 
-struct gb_battery {
+struct gb_power_supply {
 	/*
 	 * The power supply api changed in 4.1, so handle both the old
 	 * and new apis in the same driver for now, until this is merged
 	 * upstream, when all of these version checks can be removed.
 	 */
 #ifdef DRIVER_OWNS_PSY_STRUCT
-	struct power_supply bat;
-#define to_gb_battery(x) container_of(x, struct gb_battery, bat)
+	struct power_supply psy;
+#define to_gb_power_supply(x) container_of(x, struct gb_power_supply, psy)
 #else
-	struct power_supply *bat;
+	struct power_supply *psy;
 	struct power_supply_desc desc;
-#define to_gb_battery(x) power_supply_get_drvdata(x)
+#define to_gb_power_supply(x) power_supply_get_drvdata(x)
 #endif
 	// FIXME
-	// we will want to keep the battery stats in here as we will be getting
-	// updates from the SVC "on the fly" so we don't have to always go ask
-	// the battery for some information.  Hopefully...
+	// we will want to keep the power supply stats in here as we will be
+	// getting updates from the SVC "on the fly" so we don't have to always
+	// go ask the power supply for some information. Hopefully...
 	struct gb_connection *connection;
 
 };
 
-static int get_tech(struct gb_battery *gb)
+static int get_tech(struct gb_power_supply *gb)
 {
-	struct gb_battery_technology_response tech_response;
+	struct gb_power_supply_technology_response tech_response;
 	u32 technology;
 	int retval;
 
-	retval = gb_operation_sync(gb->connection, GB_BATTERY_TYPE_TECHNOLOGY,
+	retval = gb_operation_sync(gb->connection,
+				   GB_POWER_SUPPLY_TYPE_TECHNOLOGY,
 				   NULL, 0,
 				   &tech_response, sizeof(tech_response));
 	if (retval)
@@ -54,25 +55,25 @@ static int get_tech(struct gb_battery *gb)
 	 */
 	technology = le32_to_cpu(tech_response.technology);
 	switch (technology) {
-	case GB_BATTERY_TECH_NiMH:
+	case GB_POWER_SUPPLY_TECH_NiMH:
 		technology = POWER_SUPPLY_TECHNOLOGY_NiMH;
 		break;
-	case GB_BATTERY_TECH_LION:
+	case GB_POWER_SUPPLY_TECH_LION:
 		technology = POWER_SUPPLY_TECHNOLOGY_LION;
 		break;
-	case GB_BATTERY_TECH_LIPO:
+	case GB_POWER_SUPPLY_TECH_LIPO:
 		technology = POWER_SUPPLY_TECHNOLOGY_LIPO;
 		break;
-	case GB_BATTERY_TECH_LiFe:
+	case GB_POWER_SUPPLY_TECH_LiFe:
 		technology = POWER_SUPPLY_TECHNOLOGY_LiFe;
 		break;
-	case GB_BATTERY_TECH_NiCd:
+	case GB_POWER_SUPPLY_TECH_NiCd:
 		technology = POWER_SUPPLY_TECHNOLOGY_NiCd;
 		break;
-	case GB_BATTERY_TECH_LiMn:
+	case GB_POWER_SUPPLY_TECH_LiMn:
 		technology = POWER_SUPPLY_TECHNOLOGY_LiMn;
 		break;
-	case GB_BATTERY_TECH_UNKNOWN:
+	case GB_POWER_SUPPLY_TECH_UNKNOWN:
 	default:
 		technology = POWER_SUPPLY_TECHNOLOGY_UNKNOWN;
 		break;
@@ -80,13 +81,13 @@ static int get_tech(struct gb_battery *gb)
 	return technology;
 }
 
-static int get_status(struct gb_battery *gb)
+static int get_status(struct gb_power_supply *gb)
 {
-	struct gb_battery_status_response status_response;
-	u16 battery_status;
+	struct gb_power_supply_status_response status_response;
+	u16 psy_status;
 	int retval;
 
-	retval = gb_operation_sync(gb->connection, GB_BATTERY_TYPE_STATUS,
+	retval = gb_operation_sync(gb->connection, GB_POWER_SUPPLY_TYPE_STATUS,
 				   NULL, 0,
 				   &status_response, sizeof(status_response));
 	if (retval)
@@ -97,35 +98,36 @@ static int get_status(struct gb_battery *gb)
 	 * "identical" which should allow gcc to optimize the code away to
 	 * nothing.
 	 */
-	battery_status = le16_to_cpu(status_response.battery_status);
-	switch (battery_status) {
-	case GB_BATTERY_STATUS_CHARGING:
-		battery_status = POWER_SUPPLY_STATUS_CHARGING;
+	psy_status = le16_to_cpu(status_response.psy_status);
+	switch (psy_status) {
+	case GB_POWER_SUPPLY_STATUS_CHARGING:
+		psy_status = POWER_SUPPLY_STATUS_CHARGING;
 		break;
-	case GB_BATTERY_STATUS_DISCHARGING:
-		battery_status = POWER_SUPPLY_STATUS_DISCHARGING;
+	case GB_POWER_SUPPLY_STATUS_DISCHARGING:
+		psy_status = POWER_SUPPLY_STATUS_DISCHARGING;
 		break;
-	case GB_BATTERY_STATUS_NOT_CHARGING:
-		battery_status = POWER_SUPPLY_STATUS_NOT_CHARGING;
+	case GB_POWER_SUPPLY_STATUS_NOT_CHARGING:
+		psy_status = POWER_SUPPLY_STATUS_NOT_CHARGING;
 		break;
-	case GB_BATTERY_STATUS_FULL:
-		battery_status = POWER_SUPPLY_STATUS_FULL;
+	case GB_POWER_SUPPLY_STATUS_FULL:
+		psy_status = POWER_SUPPLY_STATUS_FULL;
 		break;
-	case GB_BATTERY_STATUS_UNKNOWN:
+	case GB_POWER_SUPPLY_STATUS_UNKNOWN:
 	default:
-		battery_status = POWER_SUPPLY_STATUS_UNKNOWN;
+		psy_status = POWER_SUPPLY_STATUS_UNKNOWN;
 		break;
 	}
-	return battery_status;
+	return psy_status;
 }
 
-static int get_max_voltage(struct gb_battery *gb)
+static int get_max_voltage(struct gb_power_supply *gb)
 {
-	struct gb_battery_max_voltage_response volt_response;
+	struct gb_power_supply_max_voltage_response volt_response;
 	u32 max_voltage;
 	int retval;
 
-	retval = gb_operation_sync(gb->connection, GB_BATTERY_TYPE_MAX_VOLTAGE,
+	retval = gb_operation_sync(gb->connection,
+				   GB_POWER_SUPPLY_TYPE_MAX_VOLTAGE,
 				   NULL, 0,
 				   &volt_response, sizeof(volt_response));
 	if (retval)
@@ -135,14 +137,14 @@ static int get_max_voltage(struct gb_battery *gb)
 	return max_voltage;
 }
 
-static int get_percent_capacity(struct gb_battery *gb)
+static int get_percent_capacity(struct gb_power_supply *gb)
 {
-	struct gb_battery_capacity_response capacity_response;
+	struct gb_power_supply_capacity_response capacity_response;
 	u32 capacity;
 	int retval;
 
 	retval = gb_operation_sync(gb->connection,
-				   GB_BATTERY_TYPE_PERCENT_CAPACITY,
+				   GB_POWER_SUPPLY_TYPE_PERCENT_CAPACITY,
 				   NULL, 0, &capacity_response,
 				   sizeof(capacity_response));
 	if (retval)
@@ -152,13 +154,14 @@ static int get_percent_capacity(struct gb_battery *gb)
 	return capacity;
 }
 
-static int get_temp(struct gb_battery *gb)
+static int get_temp(struct gb_power_supply *gb)
 {
-	struct gb_battery_temperature_response temp_response;
+	struct gb_power_supply_temperature_response temp_response;
 	u32 temperature;
 	int retval;
 
-	retval = gb_operation_sync(gb->connection, GB_BATTERY_TYPE_TEMPERATURE,
+	retval = gb_operation_sync(gb->connection,
+				   GB_POWER_SUPPLY_TYPE_TEMPERATURE,
 				   NULL, 0,
 				   &temp_response, sizeof(temp_response));
 	if (retval)
@@ -168,13 +171,13 @@ static int get_temp(struct gb_battery *gb)
 	return temperature;
 }
 
-static int get_voltage(struct gb_battery *gb)
+static int get_voltage(struct gb_power_supply *gb)
 {
-	struct gb_battery_voltage_response voltage_response;
+	struct gb_power_supply_voltage_response voltage_response;
 	u32 voltage;
 	int retval;
 
-	retval = gb_operation_sync(gb->connection, GB_BATTERY_TYPE_VOLTAGE,
+	retval = gb_operation_sync(gb->connection, GB_POWER_SUPPLY_TYPE_VOLTAGE,
 				   NULL, 0,
 				   &voltage_response, sizeof(voltage_response));
 	if (retval)
@@ -188,7 +191,7 @@ static int get_property(struct power_supply *b,
 			enum power_supply_property psp,
 			union power_supply_propval *val)
 {
-	struct gb_battery *gb = to_gb_battery(b);
+	struct gb_power_supply *gb = to_gb_power_supply(b);
 
 	switch (psp) {
 	case POWER_SUPPLY_PROP_TECHNOLOGY:
@@ -223,7 +226,7 @@ static int get_property(struct power_supply *b,
 }
 
 // FIXME - verify this list, odds are some can be removed and others added.
-static enum power_supply_property battery_props[] = {
+static enum power_supply_property psy_props[] = {
 	POWER_SUPPLY_PROP_TECHNOLOGY,
 	POWER_SUPPLY_PROP_STATUS,
 	POWER_SUPPLY_PROP_VOLTAGE_MAX_DESIGN,
@@ -238,17 +241,17 @@ static int init_and_register(struct gb_connection *connection,
 {
 	// FIXME - get a better (i.e. unique) name
 	// FIXME - anything else needs to be set?
-	gb->bat.name		= "gb_battery";
-	gb->bat.type		= POWER_SUPPLY_TYPE_BATTERY;
-	gb->bat.properties	= battery_props;
-	gb->bat.num_properties	= ARRAY_SIZE(battery_props);
-	gb->bat.get_property	= get_property;
+	gb->psy.name		= "gb_battery";
+	gb->psy.type		= POWER_SUPPLY_TYPE_BATTERY;
+	gb->psy.properties	= psy_props;
+	gb->psy.num_properties	= ARRAY_SIZE(psy_props);
+	gb->psy.get_property	= get_property;
 
-	return power_supply_register(&connection->bundle->dev, &gb->bat);
+	return power_supply_register(&connection->bundle->dev, &gb->psy);
 }
 #else
 static int init_and_register(struct gb_connection *connection,
-			     struct gb_battery *gb)
+			     struct gb_power_supply *gb)
 {
 	struct power_supply_config cfg = {};
 
@@ -258,22 +261,22 @@ static int init_and_register(struct gb_connection *connection,
 	// FIXME - anything else needs to be set?
 	gb->desc.name		= "gb_battery";
 	gb->desc.type		= POWER_SUPPLY_TYPE_BATTERY;
-	gb->desc.properties	= battery_props;
-	gb->desc.num_properties	= ARRAY_SIZE(battery_props);
+	gb->desc.properties	= psy_props;
+	gb->desc.num_properties	= ARRAY_SIZE(psy_props);
 	gb->desc.get_property	= get_property;
 
-	gb->bat = power_supply_register(&connection->bundle->dev,
+	gb->psy = power_supply_register(&connection->bundle->dev,
 					&gb->desc, &cfg);
-	if (IS_ERR(gb->bat))
-		return PTR_ERR(gb->bat);
+	if (IS_ERR(gb->psy))
+		return PTR_ERR(gb->psy);
 
 	return 0;
 }
 #endif
 
-static int gb_battery_connection_init(struct gb_connection *connection)
+static int gb_power_supply_connection_init(struct gb_connection *connection)
 {
-	struct gb_battery *gb;
+	struct gb_power_supply *gb;
 	int retval;
 
 	gb = kzalloc(sizeof(*gb), GFP_KERNEL);
@@ -290,28 +293,28 @@ static int gb_battery_connection_init(struct gb_connection *connection)
 	return retval;
 }
 
-static void gb_battery_connection_exit(struct gb_connection *connection)
+static void gb_power_supply_connection_exit(struct gb_connection *connection)
 {
-	struct gb_battery *gb = connection->private;
+	struct gb_power_supply *gb = connection->private;
 
 #ifdef DRIVER_OWNS_PSY_STRUCT
-	power_supply_unregister(&gb->bat);
+	power_supply_unregister(&gb->psy);
 #else
-	power_supply_unregister(gb->bat);
+	power_supply_unregister(gb->psy);
 #endif
 	kfree(gb);
 }
 
-static struct gb_protocol battery_protocol = {
-	.name			= "battery",
-	.id			= GREYBUS_PROTOCOL_BATTERY,
-	.major			= GB_BATTERY_VERSION_MAJOR,
-	.minor			= GB_BATTERY_VERSION_MINOR,
-	.connection_init	= gb_battery_connection_init,
-	.connection_exit	= gb_battery_connection_exit,
+static struct gb_protocol power_supply_protocol = {
+	.name			= "power_supply",
+	.id			= GREYBUS_PROTOCOL_POWER_SUPPLY,
+	.major			= GB_POWER_SUPPLY_VERSION_MAJOR,
+	.minor			= GB_POWER_SUPPLY_VERSION_MINOR,
+	.connection_init	= gb_power_supply_connection_init,
+	.connection_exit	= gb_power_supply_connection_exit,
 	.request_recv		= NULL,	/* no incoming requests */
 };
 
-gb_protocol_driver(&battery_protocol);
+gb_protocol_driver(&power_supply_protocol);
 
 MODULE_LICENSE("GPL v2");

commit 464888410d3499708baf168bc52e13f18d0cf0ae
Author: Rui Miguel Silva <rui.silva@linaro.org>
Date:   Thu Nov 12 15:35:59 2015 +0000

    greybus: battery: move battery file to power_supply
    
    Rename the battery.c to power_supply.c and update the makefile as the
    Greybus protocol is being renamed from battery to power_supply.
    
    Signed-off-by: Rui Miguel Silva <rui.silva@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/power_supply.c b/drivers/staging/greybus/power_supply.c
new file mode 100644
index 000000000000..e119775fb19b
--- /dev/null
+++ b/drivers/staging/greybus/power_supply.c
@@ -0,0 +1,317 @@
+/*
+ * Battery driver for a Greybus module.
+ *
+ * Copyright 2014 Google Inc.
+ * Copyright 2014 Linaro Ltd.
+ *
+ * Released under the GPLv2 only.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/power_supply.h>
+#include "greybus.h"
+
+struct gb_battery {
+	/*
+	 * The power supply api changed in 4.1, so handle both the old
+	 * and new apis in the same driver for now, until this is merged
+	 * upstream, when all of these version checks can be removed.
+	 */
+#ifdef DRIVER_OWNS_PSY_STRUCT
+	struct power_supply bat;
+#define to_gb_battery(x) container_of(x, struct gb_battery, bat)
+#else
+	struct power_supply *bat;
+	struct power_supply_desc desc;
+#define to_gb_battery(x) power_supply_get_drvdata(x)
+#endif
+	// FIXME
+	// we will want to keep the battery stats in here as we will be getting
+	// updates from the SVC "on the fly" so we don't have to always go ask
+	// the battery for some information.  Hopefully...
+	struct gb_connection *connection;
+
+};
+
+static int get_tech(struct gb_battery *gb)
+{
+	struct gb_battery_technology_response tech_response;
+	u32 technology;
+	int retval;
+
+	retval = gb_operation_sync(gb->connection, GB_BATTERY_TYPE_TECHNOLOGY,
+				   NULL, 0,
+				   &tech_response, sizeof(tech_response));
+	if (retval)
+		return retval;
+
+	/*
+	 * Map greybus values to power_supply values.  Hopefully these are
+	 * "identical" which should allow gcc to optimize the code away to
+	 * nothing.
+	 */
+	technology = le32_to_cpu(tech_response.technology);
+	switch (technology) {
+	case GB_BATTERY_TECH_NiMH:
+		technology = POWER_SUPPLY_TECHNOLOGY_NiMH;
+		break;
+	case GB_BATTERY_TECH_LION:
+		technology = POWER_SUPPLY_TECHNOLOGY_LION;
+		break;
+	case GB_BATTERY_TECH_LIPO:
+		technology = POWER_SUPPLY_TECHNOLOGY_LIPO;
+		break;
+	case GB_BATTERY_TECH_LiFe:
+		technology = POWER_SUPPLY_TECHNOLOGY_LiFe;
+		break;
+	case GB_BATTERY_TECH_NiCd:
+		technology = POWER_SUPPLY_TECHNOLOGY_NiCd;
+		break;
+	case GB_BATTERY_TECH_LiMn:
+		technology = POWER_SUPPLY_TECHNOLOGY_LiMn;
+		break;
+	case GB_BATTERY_TECH_UNKNOWN:
+	default:
+		technology = POWER_SUPPLY_TECHNOLOGY_UNKNOWN;
+		break;
+	}
+	return technology;
+}
+
+static int get_status(struct gb_battery *gb)
+{
+	struct gb_battery_status_response status_response;
+	u16 battery_status;
+	int retval;
+
+	retval = gb_operation_sync(gb->connection, GB_BATTERY_TYPE_STATUS,
+				   NULL, 0,
+				   &status_response, sizeof(status_response));
+	if (retval)
+		return retval;
+
+	/*
+	 * Map greybus values to power_supply values.  Hopefully these are
+	 * "identical" which should allow gcc to optimize the code away to
+	 * nothing.
+	 */
+	battery_status = le16_to_cpu(status_response.battery_status);
+	switch (battery_status) {
+	case GB_BATTERY_STATUS_CHARGING:
+		battery_status = POWER_SUPPLY_STATUS_CHARGING;
+		break;
+	case GB_BATTERY_STATUS_DISCHARGING:
+		battery_status = POWER_SUPPLY_STATUS_DISCHARGING;
+		break;
+	case GB_BATTERY_STATUS_NOT_CHARGING:
+		battery_status = POWER_SUPPLY_STATUS_NOT_CHARGING;
+		break;
+	case GB_BATTERY_STATUS_FULL:
+		battery_status = POWER_SUPPLY_STATUS_FULL;
+		break;
+	case GB_BATTERY_STATUS_UNKNOWN:
+	default:
+		battery_status = POWER_SUPPLY_STATUS_UNKNOWN;
+		break;
+	}
+	return battery_status;
+}
+
+static int get_max_voltage(struct gb_battery *gb)
+{
+	struct gb_battery_max_voltage_response volt_response;
+	u32 max_voltage;
+	int retval;
+
+	retval = gb_operation_sync(gb->connection, GB_BATTERY_TYPE_MAX_VOLTAGE,
+				   NULL, 0,
+				   &volt_response, sizeof(volt_response));
+	if (retval)
+		return retval;
+
+	max_voltage = le32_to_cpu(volt_response.max_voltage);
+	return max_voltage;
+}
+
+static int get_percent_capacity(struct gb_battery *gb)
+{
+	struct gb_battery_capacity_response capacity_response;
+	u32 capacity;
+	int retval;
+
+	retval = gb_operation_sync(gb->connection,
+				   GB_BATTERY_TYPE_PERCENT_CAPACITY,
+				   NULL, 0, &capacity_response,
+				   sizeof(capacity_response));
+	if (retval)
+		return retval;
+
+	capacity = le32_to_cpu(capacity_response.capacity);
+	return capacity;
+}
+
+static int get_temp(struct gb_battery *gb)
+{
+	struct gb_battery_temperature_response temp_response;
+	u32 temperature;
+	int retval;
+
+	retval = gb_operation_sync(gb->connection, GB_BATTERY_TYPE_TEMPERATURE,
+				   NULL, 0,
+				   &temp_response, sizeof(temp_response));
+	if (retval)
+		return retval;
+
+	temperature = le32_to_cpu(temp_response.temperature);
+	return temperature;
+}
+
+static int get_voltage(struct gb_battery *gb)
+{
+	struct gb_battery_voltage_response voltage_response;
+	u32 voltage;
+	int retval;
+
+	retval = gb_operation_sync(gb->connection, GB_BATTERY_TYPE_VOLTAGE,
+				   NULL, 0,
+				   &voltage_response, sizeof(voltage_response));
+	if (retval)
+		return retval;
+
+	voltage = le32_to_cpu(voltage_response.voltage);
+	return voltage;
+}
+
+static int get_property(struct power_supply *b,
+			enum power_supply_property psp,
+			union power_supply_propval *val)
+{
+	struct gb_battery *gb = to_gb_battery(b);
+
+	switch (psp) {
+	case POWER_SUPPLY_PROP_TECHNOLOGY:
+		val->intval = get_tech(gb);
+		break;
+
+	case POWER_SUPPLY_PROP_STATUS:
+		val->intval = get_status(gb);
+		break;
+
+	case POWER_SUPPLY_PROP_VOLTAGE_MAX_DESIGN:
+		val->intval = get_max_voltage(gb);
+		break;
+
+	case POWER_SUPPLY_PROP_CAPACITY:
+		val->intval = get_percent_capacity(gb);
+		break;
+
+	case POWER_SUPPLY_PROP_TEMP:
+		val->intval = get_temp(gb);
+		break;
+
+	case POWER_SUPPLY_PROP_VOLTAGE_NOW:
+		val->intval = get_voltage(gb);
+		break;
+
+	default:
+		return -EINVAL;
+	}
+
+	return (val->intval < 0) ? val->intval : 0;
+}
+
+// FIXME - verify this list, odds are some can be removed and others added.
+static enum power_supply_property battery_props[] = {
+	POWER_SUPPLY_PROP_TECHNOLOGY,
+	POWER_SUPPLY_PROP_STATUS,
+	POWER_SUPPLY_PROP_VOLTAGE_MAX_DESIGN,
+	POWER_SUPPLY_PROP_CAPACITY,
+	POWER_SUPPLY_PROP_TEMP,
+	POWER_SUPPLY_PROP_VOLTAGE_NOW,
+};
+
+#ifdef DRIVER_OWNS_PSY_STRUCT
+static int init_and_register(struct gb_connection *connection,
+			     struct gb_battery *gb)
+{
+	// FIXME - get a better (i.e. unique) name
+	// FIXME - anything else needs to be set?
+	gb->bat.name		= "gb_battery";
+	gb->bat.type		= POWER_SUPPLY_TYPE_BATTERY;
+	gb->bat.properties	= battery_props;
+	gb->bat.num_properties	= ARRAY_SIZE(battery_props);
+	gb->bat.get_property	= get_property;
+
+	return power_supply_register(&connection->bundle->dev, &gb->bat);
+}
+#else
+static int init_and_register(struct gb_connection *connection,
+			     struct gb_battery *gb)
+{
+	struct power_supply_config cfg = {};
+
+	cfg.drv_data = gb;
+
+	// FIXME - get a better (i.e. unique) name
+	// FIXME - anything else needs to be set?
+	gb->desc.name		= "gb_battery";
+	gb->desc.type		= POWER_SUPPLY_TYPE_BATTERY;
+	gb->desc.properties	= battery_props;
+	gb->desc.num_properties	= ARRAY_SIZE(battery_props);
+	gb->desc.get_property	= get_property;
+
+	gb->bat = power_supply_register(&connection->bundle->dev,
+					&gb->desc, &cfg);
+	if (IS_ERR(gb->bat))
+		return PTR_ERR(gb->bat);
+
+	return 0;
+}
+#endif
+
+static int gb_battery_connection_init(struct gb_connection *connection)
+{
+	struct gb_battery *gb;
+	int retval;
+
+	gb = kzalloc(sizeof(*gb), GFP_KERNEL);
+	if (!gb)
+		return -ENOMEM;
+
+	gb->connection = connection;
+	connection->private = gb;
+
+	retval = init_and_register(connection, gb);
+	if (retval)
+		kfree(gb);
+
+	return retval;
+}
+
+static void gb_battery_connection_exit(struct gb_connection *connection)
+{
+	struct gb_battery *gb = connection->private;
+
+#ifdef DRIVER_OWNS_PSY_STRUCT
+	power_supply_unregister(&gb->bat);
+#else
+	power_supply_unregister(gb->bat);
+#endif
+	kfree(gb);
+}
+
+static struct gb_protocol battery_protocol = {
+	.name			= "battery",
+	.id			= GREYBUS_PROTOCOL_BATTERY,
+	.major			= GB_BATTERY_VERSION_MAJOR,
+	.minor			= GB_BATTERY_VERSION_MINOR,
+	.connection_init	= gb_battery_connection_init,
+	.connection_exit	= gb_battery_connection_exit,
+	.request_recv		= NULL,	/* no incoming requests */
+};
+
+gb_protocol_driver(&battery_protocol);
+
+MODULE_LICENSE("GPL v2");
