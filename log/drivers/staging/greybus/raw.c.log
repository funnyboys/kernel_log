commit 8acd7c56c1b502b745c7b0dc341abcd1415ba5ad
Author: Gustavo A. R. Silva <gustavo@embeddedor.com>
Date:   Tue Feb 11 15:12:19 2020 -0600

    staging: greybus: Replace zero-length array with flexible-array member
    
    The current codebase makes use of the zero-length array language
    extension to the C90 standard, but the preferred mechanism to declare
    variable-length types such as these ones is a flexible array member[1][2],
    introduced in C99:
    
    struct foo {
            int stuff;
            struct boo array[];
    };
    
    By making use of the mechanism above, we will get a compiler warning
    in case the flexible array does not occur last in the structure, which
    will help us prevent some kind of undefined behavior bugs from being
    inadvertenly introduced[3] to the codebase from now on.
    
    This issue was found with the help of Coccinelle.
    
    [1] https://gcc.gnu.org/onlinedocs/gcc/Zero-Length.html
    [2] https://github.com/KSPP/linux/issues/21
    [3] commit 76497732932f ("cxgb3/l2t: Fix undefined behaviour")
    
    Signed-off-by: Gustavo A. R. Silva <gustavo@embeddedor.com>
    Link: https://lore.kernel.org/r/20200211211219.GA673@embeddedor
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/raw.c b/drivers/staging/greybus/raw.c
index 64a17dfe3b6e..2a375f407d38 100644
--- a/drivers/staging/greybus/raw.c
+++ b/drivers/staging/greybus/raw.c
@@ -29,7 +29,7 @@ struct gb_raw {
 struct raw_data {
 	struct list_head entry;
 	u32 len;
-	u8 data[0];
+	u8 data[];
 };
 
 static struct class *raw_class;

commit ec0ad868173da8a75121f9dc116a5d5478ff614d
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Sun Aug 25 07:54:27 2019 +0200

    staging: greybus: move core include files to include/linux/greybus/
    
    With the goal of moving the core of the greybus code out of staging, the
    include files need to be moved to include/linux/greybus.h and
    include/linux/greybus/
    
    Cc: Vaibhav Hiremath <hvaibhav.linux@gmail.com>
    Cc: Johan Hovold <johan@kernel.org>
    Cc: Vaibhav Agarwal <vaibhav.sr@gmail.com>
    Cc: Rui Miguel Silva <rmfrfs@gmail.com>
    Cc: David Lin <dtwlin@gmail.com>
    Cc: "Bryan O'Donoghue" <pure.logic@nexus-software.ie>
    Cc: greybus-dev@lists.linaro.org
    Cc: devel@driverdev.osuosl.org
    Acked-by: Mark Greer <mgreer@animalcreek.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Acked-by: Alex Elder <elder@kernel.org>
    Link: https://lore.kernel.org/r/20190825055429.18547-8-gregkh@linuxfoundation.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/raw.c b/drivers/staging/greybus/raw.c
index 838acbe84ca0..64a17dfe3b6e 100644
--- a/drivers/staging/greybus/raw.c
+++ b/drivers/staging/greybus/raw.c
@@ -13,8 +13,7 @@
 #include <linux/fs.h>
 #include <linux/idr.h>
 #include <linux/uaccess.h>
-
-#include "greybus.h"
+#include <linux/greybus.h>
 
 struct gb_raw {
 	struct gb_connection *connection;

commit 863dbc52e7f0e5acd7b4883f3933543a81c474c7
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Nov 7 14:58:42 2017 +0100

    staging: greybus: Remove redundant license text
    
    Now that the SPDX tag is in all greybus files, that identifies the
    license in a specific and legally-defined manner.  So the extra GPL text
    wording can be removed as it is no longer needed at all.
    
    This is done on a quest to remove the 700+ different ways that files in
    the kernel describe the GPL license text.  And there's unneeded stuff
    like the address (sometimes incorrect) for the FSF which is never
    needed.
    
    No copyright headers or other non-license-description text was removed.
    
    Cc: Vaibhav Hiremath <hvaibhav.linux@gmail.com>
    Reviewed-by: Alex Elder <elder@linaro.org>
    Acked-by: Vaibhav Agarwal <vaibhav.sr@gmail.com>
    Acked-by: David Lin <dtwlin@gmail.com>
    Acked-by: Johan Hovold <johan@kernel.org>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Acked-by: Mark Greer <mgreer@animalcreek.com>
    Acked-by: Rui Miguel Silva <rmfrfs@gmail.com>
    Acked-by: "Bryan O'Donoghue" <pure.logic@nexus-software.ie>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/raw.c b/drivers/staging/greybus/raw.c
index e330375d8105..838acbe84ca0 100644
--- a/drivers/staging/greybus/raw.c
+++ b/drivers/staging/greybus/raw.c
@@ -4,8 +4,6 @@
  *
  * Copyright 2015 Google Inc.
  * Copyright 2015 Linaro Ltd.
- *
- * Released under the GPLv2 only.
  */
 #include <linux/kernel.h>
 #include <linux/module.h>

commit eb50fd3a22c770f36be275295b782f3ea52e3215
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Nov 7 14:58:41 2017 +0100

    staging: greybus: add SPDX identifiers to all greybus driver files
    
    It's good to have SPDX identifiers in all files to make it easier to
    audit the kernel tree for correct licenses.
    
    Update the drivers/staging/greybus files files with the correct SPDX
    license identifier based on the license text in the file itself.  The
    SPDX identifier is a legally binding shorthand, which can be used
    instead of the full boiler plate text.
    
    This work is based on a script and data from Thomas Gleixner, Philippe
    Ombredanne, and Kate Stewart.
    
    Cc: Vaibhav Hiremath <hvaibhav.linux@gmail.com>
    Cc: "Bryan O'Donoghue" <pure.logic@nexus-software.ie>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: Philippe Ombredanne <pombredanne@nexb.com>
    Acked-by: Vaibhav Agarwal <vaibhav.sr@gmail.com>
    Acked-by: David Lin <dtwlin@gmail.com>
    Reviewed-by: Alex Elder <elder@linaro.org>
    Acked-by: Johan Hovold <johan@kernel.org>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Acked-by: Mark Greer <mgreer@animalcreek.com>
    Acked-by: Rui Miguel Silva <rmfrfs@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/raw.c b/drivers/staging/greybus/raw.c
index 729d25811568..e330375d8105 100644
--- a/drivers/staging/greybus/raw.c
+++ b/drivers/staging/greybus/raw.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * Greybus driver for the Raw protocol
  *

commit c7733b6167750a42da81133189e9cca33ce7584f
Author: Johan Hovold <johan@hovoldconsulting.com>
Date:   Wed Mar 2 18:00:51 2016 +0100

    greybus: raw: use hexadecimal notation for request types
    
    Use hexadecimal notation for request types in log messages.
    
    Signed-off-by: Johan Hovold <johan@hovoldconsulting.com>
    Reviewed-by: Viresh Kumar <viresh.kumar@linaro.org>
    Reviewed-by: Alex Elder <elder@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/raw.c b/drivers/staging/greybus/raw.c
index 338139e815af..729d25811568 100644
--- a/drivers/staging/greybus/raw.c
+++ b/drivers/staging/greybus/raw.c
@@ -97,7 +97,7 @@ static int gb_raw_request_handler(struct gb_operation *op)
 	u32 len;
 
 	if (op->type != GB_RAW_TYPE_SEND) {
-		dev_err(dev, "unknown request type %d\n", op->type);
+		dev_err(dev, "unknown request type 0x%02x\n", op->type);
 		return -EINVAL;
 	}
 

commit 512cc327625651260b2ba885b63cf2cf14ff54d1
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Mon Feb 15 10:47:27 2016 +0530

    greybus: raw: convert to bundle driver
    
    Convert the legacy raw protocol driver to a bundle driver.
    
    This also fixes a potential crash should a (malicious) module have sent
    an early request before the private data had been initialised.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Reviewed-by: Johan Hovold <johan@hovoldconsulting.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/raw.c b/drivers/staging/greybus/raw.c
index ed17ba3ca0b3..338139e815af 100644
--- a/drivers/staging/greybus/raw.c
+++ b/drivers/staging/greybus/raw.c
@@ -88,16 +88,16 @@ static int receive_data(struct gb_raw *raw, u32 len, u8 *data)
 	return retval;
 }
 
-static int gb_raw_receive(u8 type, struct gb_operation *op)
+static int gb_raw_request_handler(struct gb_operation *op)
 {
 	struct gb_connection *connection = op->connection;
 	struct device *dev = &connection->bundle->dev;
-	struct gb_raw *raw = connection->private;
+	struct gb_raw *raw = greybus_get_drvdata(connection->bundle);
 	struct gb_raw_send_request *receive;
 	u32 len;
 
-	if (type != GB_RAW_TYPE_SEND) {
-		dev_err(dev, "unknown request type %d\n", type);
+	if (op->type != GB_RAW_TYPE_SEND) {
+		dev_err(dev, "unknown request type %d\n", op->type);
 		return -EINVAL;
 	}
 
@@ -147,34 +147,56 @@ static int gb_raw_send(struct gb_raw *raw, u32 len, const char __user *data)
 	return retval;
 }
 
-static int gb_raw_connection_init(struct gb_connection *connection)
+static int gb_raw_probe(struct gb_bundle *bundle,
+			const struct greybus_bundle_id *id)
 {
+	struct greybus_descriptor_cport *cport_desc;
+	struct gb_connection *connection;
 	struct gb_raw *raw;
 	int retval;
 	int minor;
 
+	if (bundle->num_cports != 1)
+		return -ENODEV;
+
+	cport_desc = &bundle->cport_desc[0];
+	if (cport_desc->protocol_id != GREYBUS_PROTOCOL_RAW)
+		return -ENODEV;
+
 	raw = kzalloc(sizeof(*raw), GFP_KERNEL);
 	if (!raw)
 		return -ENOMEM;
 
-	raw->connection = connection;
-	connection->private = raw;
+	connection = gb_connection_create(bundle, le16_to_cpu(cport_desc->id),
+					  gb_raw_request_handler);
+	if (IS_ERR(connection)) {
+		retval = PTR_ERR(connection);
+		goto error_free;
+	}
 
 	INIT_LIST_HEAD(&raw->list);
 	mutex_init(&raw->list_lock);
 
+	raw->connection = connection;
+	greybus_set_drvdata(bundle, raw);
+
 	minor = ida_simple_get(&minors, 0, 0, GFP_KERNEL);
 	if (minor < 0) {
 		retval = minor;
-		goto error_free;
+		goto error_connection_destroy;
 	}
 
 	raw->dev = MKDEV(raw_major, minor);
 	cdev_init(&raw->cdev, &raw_fops);
-	retval = cdev_add(&raw->cdev, raw->dev, 1);
+
+	retval = gb_connection_enable(connection);
 	if (retval)
 		goto error_remove_ida;
 
+	retval = cdev_add(&raw->cdev, raw->dev, 1);
+	if (retval)
+		goto error_connection_disable;
+
 	raw->device = device_create(raw_class, &connection->bundle->dev,
 				    raw->dev, raw, "gb!raw%d", minor);
 	if (IS_ERR(raw->device)) {
@@ -187,24 +209,34 @@ static int gb_raw_connection_init(struct gb_connection *connection)
 error_del_cdev:
 	cdev_del(&raw->cdev);
 
+error_connection_disable:
+	gb_connection_disable(connection);
+
 error_remove_ida:
 	ida_simple_remove(&minors, minor);
 
+error_connection_destroy:
+	gb_connection_destroy(connection);
+
 error_free:
 	kfree(raw);
 	return retval;
 }
 
-static void gb_raw_connection_exit(struct gb_connection *connection)
+static void gb_raw_disconnect(struct gb_bundle *bundle)
 {
-	struct gb_raw *raw = connection->private;
+	struct gb_raw *raw = greybus_get_drvdata(bundle);
+	struct gb_connection *connection = raw->connection;
 	struct raw_data *raw_data;
 	struct raw_data *temp;
 
 	// FIXME - handle removing a connection when the char device node is open.
 	device_destroy(raw_class, raw->dev);
 	cdev_del(&raw->cdev);
+	gb_connection_disable(connection);
 	ida_simple_remove(&minors, MINOR(raw->dev));
+	gb_connection_destroy(connection);
+
 	mutex_lock(&raw->list_lock);
 	list_for_each_entry_safe(raw_data, temp, &raw->list, entry) {
 		list_del(&raw_data->entry);
@@ -215,16 +247,6 @@ static void gb_raw_connection_exit(struct gb_connection *connection)
 	kfree(raw);
 }
 
-static struct gb_protocol raw_protocol = {
-	.name			= "raw",
-	.id			= GREYBUS_PROTOCOL_RAW,
-	.major			= GB_RAW_VERSION_MAJOR,
-	.minor			= GB_RAW_VERSION_MINOR,
-	.connection_init	= gb_raw_connection_init,
-	.connection_exit	= gb_raw_connection_exit,
-	.request_recv		= gb_raw_receive,
-};
-
 /*
  * Character device node interfaces.
  *
@@ -302,6 +324,19 @@ static const struct file_operations raw_fops = {
 	.llseek		= noop_llseek,
 };
 
+static const struct greybus_bundle_id gb_raw_id_table[] = {
+	{ GREYBUS_DEVICE_CLASS(GREYBUS_CLASS_RAW) },
+	{ }
+};
+MODULE_DEVICE_TABLE(greybus, gb_raw_id_table);
+
+static struct greybus_driver gb_raw_driver = {
+	.name		= "raw",
+	.probe		= gb_raw_probe,
+	.disconnect	= gb_raw_disconnect,
+	.id_table	= gb_raw_id_table,
+};
+
 static int raw_init(void)
 {
 	dev_t dev;
@@ -317,10 +352,9 @@ static int raw_init(void)
 	if (retval < 0)
 		goto error_chrdev;
 
-
 	raw_major = MAJOR(dev);
 
-	retval = gb_protocol_register(&raw_protocol);
+	retval = greybus_register(&gb_raw_driver);
 	if (retval)
 		goto error_gb;
 
@@ -337,7 +371,7 @@ module_init(raw_init);
 
 static void __exit raw_exit(void)
 {
-	gb_protocol_deregister(&raw_protocol);
+	greybus_deregister(&gb_raw_driver);
 	unregister_chrdev_region(MKDEV(raw_major, 0), NUM_MINORS);
 	class_destroy(raw_class);
 	ida_destroy(&minors);

commit 2554eda5756a37118ab310bd02de78491303ab5f
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Fri Feb 12 16:08:27 2016 +0530

    greybus: raw: Don't use (possibly) uninitialized raw->device in gb_raw_receive()
    
    If an incoming request comes on the connection, before the driver has
    allocated its raw->device in gb_raw_connection_init(), then it might
    result in a crash while printing error messages.
    
    Fix that by using bundle->dev for printing error messages.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Reviewed-by: Johan Hovold <johan@hovoldconsulting.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/raw.c b/drivers/staging/greybus/raw.c
index d2e0281e86c5..ed17ba3ca0b3 100644
--- a/drivers/staging/greybus/raw.c
+++ b/drivers/staging/greybus/raw.c
@@ -57,17 +57,17 @@ static DEFINE_IDA(minors);
 static int receive_data(struct gb_raw *raw, u32 len, u8 *data)
 {
 	struct raw_data *raw_data;
+	struct device *dev = &raw->connection->bundle->dev;
 	int retval = 0;
 
 	if (len > MAX_PACKET_SIZE) {
-		dev_err(raw->device, "Too big of a data packet, rejected\n");
+		dev_err(dev, "Too big of a data packet, rejected\n");
 		return -EINVAL;
 	}
 
 	mutex_lock(&raw->list_lock);
 	if ((raw->list_data + len) > MAX_DATA_SIZE) {
-		dev_err(raw->device,
-			"Too much data in receive buffer, now dropping packets\n");
+		dev_err(dev, "Too much data in receive buffer, now dropping packets\n");
 		retval = -EINVAL;
 		goto exit;
 	}
@@ -91,32 +91,31 @@ static int receive_data(struct gb_raw *raw, u32 len, u8 *data)
 static int gb_raw_receive(u8 type, struct gb_operation *op)
 {
 	struct gb_connection *connection = op->connection;
+	struct device *dev = &connection->bundle->dev;
 	struct gb_raw *raw = connection->private;
 	struct gb_raw_send_request *receive;
 	u32 len;
 
 	if (type != GB_RAW_TYPE_SEND) {
-		dev_err(raw->device, "unknown request type %d\n", type);
+		dev_err(dev, "unknown request type %d\n", type);
 		return -EINVAL;
 	}
 
 	/* Verify size of payload */
 	if (op->request->payload_size < sizeof(*receive)) {
-		dev_err(raw->device, "raw receive request too small (%zu < %zu)\n",
+		dev_err(dev, "raw receive request too small (%zu < %zu)\n",
 			op->request->payload_size, sizeof(*receive));
 		return -EINVAL;
 	}
 	receive = op->request->payload;
 	len = le32_to_cpu(receive->len);
 	if (len != (int)(op->request->payload_size - sizeof(__le32))) {
-		dev_err(raw->device,
-			"raw receive request wrong size %d vs %d\n",
-			len,
+		dev_err(dev, "raw receive request wrong size %d vs %d\n", len,
 			(int)(op->request->payload_size - sizeof(__le32)));
 		return -EINVAL;
 	}
 	if (len == 0) {
-		dev_err(raw->device, "raw receive request of 0 bytes?\n");
+		dev_err(dev, "raw receive request of 0 bytes?\n");
 		return -EINVAL;
 	}
 

commit c463593c3dbc8d4dcb132538b0116256fa0cc455
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Fri Feb 12 16:08:26 2016 +0530

    greybus: raw: Use consistent label names in connection_init()
    
    Some of the labels are named based on what they are going to undo, while
    others are based on where we failed in connection_init().
    
    Follow only the first type of naming.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Reviewed-by: Johan Hovold <johan@hovoldconsulting.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/raw.c b/drivers/staging/greybus/raw.c
index a6e795996053..d2e0281e86c5 100644
--- a/drivers/staging/greybus/raw.c
+++ b/drivers/staging/greybus/raw.c
@@ -174,21 +174,21 @@ static int gb_raw_connection_init(struct gb_connection *connection)
 	cdev_init(&raw->cdev, &raw_fops);
 	retval = cdev_add(&raw->cdev, raw->dev, 1);
 	if (retval)
-		goto error_cdev;
+		goto error_remove_ida;
 
 	raw->device = device_create(raw_class, &connection->bundle->dev,
 				    raw->dev, raw, "gb!raw%d", minor);
 	if (IS_ERR(raw->device)) {
 		retval = PTR_ERR(raw->device);
-		goto error_device;
+		goto error_del_cdev;
 	}
 
 	return 0;
 
-error_device:
+error_del_cdev:
 	cdev_del(&raw->cdev);
 
-error_cdev:
+error_remove_ida:
 	ida_simple_remove(&minors, minor);
 
 error_free:

commit 397d34152423d2ddbff3e48495ef988cbb07776b
Author: Johan Hovold <johan@hovoldconsulting.com>
Date:   Wed Feb 10 11:08:29 2016 +0100

    greybus: raw: fix memory leak on disconnect
    
    Make sure the class device is freed as well as deregistered on
    disconnect.
    
    Also deregister the class device before character device as the former
    depends on the latter.
    
    Signed-off-by: Johan Hovold <johan@hovoldconsulting.com>
    Reviewed-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/raw.c b/drivers/staging/greybus/raw.c
index fa5025dd17a3..a6e795996053 100644
--- a/drivers/staging/greybus/raw.c
+++ b/drivers/staging/greybus/raw.c
@@ -203,9 +203,9 @@ static void gb_raw_connection_exit(struct gb_connection *connection)
 	struct raw_data *temp;
 
 	// FIXME - handle removing a connection when the char device node is open.
+	device_destroy(raw_class, raw->dev);
 	cdev_del(&raw->cdev);
 	ida_simple_remove(&minors, MINOR(raw->dev));
-	device_del(raw->device);
 	mutex_lock(&raw->list_lock);
 	list_for_each_entry_safe(raw_data, temp, &raw->list, entry) {
 		list_del(&raw_data->entry);

commit 29a167ec87fb971931a033766e9e387d0fcabe7d
Author: Greg Kroah-Hartman <gregkh@google.com>
Date:   Wed Oct 14 11:31:00 2015 -0700

    greybus: raw: use the bundle struct device instead of the connector
    
    We are removing struct device from the gb_connection structure in the
    near future.  The gb_bundle structure's struct device should be used as
    a replacement.
    
    This patch moves the raw driver to use the bundle pointer instead of the
    connection pointer.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>
    Reviewed-by: Alex Elder <elder@linaro.org>

diff --git a/drivers/staging/greybus/raw.c b/drivers/staging/greybus/raw.c
index ce0f59d08e0d..fa5025dd17a3 100644
--- a/drivers/staging/greybus/raw.c
+++ b/drivers/staging/greybus/raw.c
@@ -176,8 +176,8 @@ static int gb_raw_connection_init(struct gb_connection *connection)
 	if (retval)
 		goto error_cdev;
 
-	raw->device = device_create(raw_class, &connection->dev, raw->dev, raw,
-				    "gb!raw%d", minor);
+	raw->device = device_create(raw_class, &connection->bundle->dev,
+				    raw->dev, raw, "gb!raw%d", minor);
 	if (IS_ERR(raw->device)) {
 		retval = PTR_ERR(raw->device);
 		goto error_device;

commit d65e3a22aa3ef28f068cdc38ac82f3e1914cde9a
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Thu Aug 13 10:04:45 2015 +0530

    greybus: raw: Move request/response structure/definitions to greybus_protocols.h
    
    These must be exposed to external modules, like gbsim. Move them to
    greybus_protocols.h file.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/raw.c b/drivers/staging/greybus/raw.c
index 215d42165282..ce0f59d08e0d 100644
--- a/drivers/staging/greybus/raw.c
+++ b/drivers/staging/greybus/raw.c
@@ -28,18 +28,6 @@ struct gb_raw {
 	struct device *device;
 };
 
-/* Version of the Greybus raw protocol we support */
-#define	GB_RAW_VERSION_MAJOR			0x00
-#define	GB_RAW_VERSION_MINOR			0x01
-
-/* Greybus raw request types */
-#define	GB_RAW_TYPE_SEND			0x02
-
-struct gb_raw_send_request {
-	__le32	len;
-	__u8	data[0];
-};
-
 struct raw_data {
 	struct list_head entry;
 	u32 len;

commit f06eda1b1744fcde6769eee22bceb7d9fee23bf5
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Tue Aug 11 07:36:08 2015 +0530

    greybus: raw: Drop get_version support
    
    This is done from a common place now, no need to replicate it.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/raw.c b/drivers/staging/greybus/raw.c
index a17a9868a08e..215d42165282 100644
--- a/drivers/staging/greybus/raw.c
+++ b/drivers/staging/greybus/raw.c
@@ -19,8 +19,6 @@
 
 struct gb_raw {
 	struct gb_connection *connection;
-	u8 version_major;
-	u8 version_minor;
 
 	struct list_head list;
 	int list_data;
@@ -35,13 +33,8 @@ struct gb_raw {
 #define	GB_RAW_VERSION_MINOR			0x01
 
 /* Greybus raw request types */
-#define	GB_RAW_TYPE_INVALID			0x00
-#define	GB_RAW_TYPE_PROTOCOL_VERSION		0x01
 #define	GB_RAW_TYPE_SEND			0x02
 
-/* Define get_version() routine */
-define_get_version(gb_raw, RAW);
-
 struct gb_raw_send_request {
 	__le32	len;
 	__u8	data[0];
@@ -180,11 +173,6 @@ static int gb_raw_connection_init(struct gb_connection *connection)
 	raw->connection = connection;
 	connection->private = raw;
 
-	/* Check the protocol version */
-	retval = get_version(raw);
-	if (retval)
-		goto error_free;
-
 	INIT_LIST_HEAD(&raw->list);
 	mutex_init(&raw->list_lock);
 

commit 7fea641c94d645bf30712cb6e6c498597c7e5634
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Thu Aug 6 12:44:52 2015 +0530

    greybus: raw: Print expected/actual payload size on mismatch
    
    Print (expected-payload-size actual-payload-size), when the size doesn't
    match for requests received by the module. This gives more details
    required for debugging the issue.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Reviewed-by: Alex Elder <elder@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/raw.c b/drivers/staging/greybus/raw.c
index 3be96db2588b..a17a9868a08e 100644
--- a/drivers/staging/greybus/raw.c
+++ b/drivers/staging/greybus/raw.c
@@ -121,7 +121,8 @@ static int gb_raw_receive(u8 type, struct gb_operation *op)
 
 	/* Verify size of payload */
 	if (op->request->payload_size < sizeof(*receive)) {
-		dev_err(raw->device, "raw receive request too small\n");
+		dev_err(raw->device, "raw receive request too small (%zu < %zu)\n",
+			op->request->payload_size, sizeof(*receive));
 		return -EINVAL;
 	}
 	receive = op->request->payload;

commit 5c1ac6945526c76258869c8c04632ab5ae61bdab
Author: Greg Kroah-Hartman <gregkh@google.com>
Date:   Wed Jul 8 10:44:09 2015 -0700

    greybus: properly cleanup ida and idr structures when shutting down
    
    idr and ida structures have internal memory allocated that needs to be
    freed when modules are removed.  So call the proper idr_destroy() or
    ida_destroy() functions on the module exit path to free the memory.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>
    Reviewed-by: Alex Elder <elder@linaro.org>

diff --git a/drivers/staging/greybus/raw.c b/drivers/staging/greybus/raw.c
index d93d052a8a7e..3be96db2588b 100644
--- a/drivers/staging/greybus/raw.c
+++ b/drivers/staging/greybus/raw.c
@@ -364,6 +364,7 @@ static void __exit raw_exit(void)
 	gb_protocol_deregister(&raw_protocol);
 	unregister_chrdev_region(MKDEV(raw_major, 0), NUM_MINORS);
 	class_destroy(raw_class);
+	ida_destroy(&minors);
 }
 module_exit(raw_exit);
 

commit 8ba2522fa8397c894c2d42ed3461e23862ea6a45
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Wed May 20 16:54:22 2015 +0530

    greybus: raw: move module_{init|exit} to the end of functions
    
    This is what coding guidelines say. Lets do it.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Reviewed-by: Alex Elder <elder@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/raw.c b/drivers/staging/greybus/raw.c
index 515c1877bc7f..d93d052a8a7e 100644
--- a/drivers/staging/greybus/raw.c
+++ b/drivers/staging/greybus/raw.c
@@ -357,6 +357,7 @@ static int raw_init(void)
 error_class:
 	return retval;
 }
+module_init(raw_init);
 
 static void __exit raw_exit(void)
 {
@@ -364,8 +365,6 @@ static void __exit raw_exit(void)
 	unregister_chrdev_region(MKDEV(raw_major, 0), NUM_MINORS);
 	class_destroy(raw_class);
 }
-
-module_init(raw_init);
 module_exit(raw_exit);
 
 MODULE_LICENSE("GPL v2");

commit 4f8ab1105da2f13ae52dc2f2c31fb7bea1301793
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Wed May 20 16:31:19 2015 +0530

    greybus: raw: include uaccess.h to fix warning
    
    This is what I get over mainline:
    
    greybus/raw.c: In function 'gb_raw_send':
    greybus/raw.c:153:2: error: implicit declaration of function 'copy_from_user' [-Werror=implicit-function-declaration]
      if (copy_from_user(&request->data[0], data, len)) {
      ^
    greybus/raw.c: In function 'raw_read':
    greybus/raw.c:305:2: error: implicit declaration of function 'copy_to_user' [-Werror=implicit-function-declaration]
      if (copy_to_user(buf, &raw_data->data[0], raw_data->len)) {
      ^
    
    Fix this by including uaccess.h.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/raw.c b/drivers/staging/greybus/raw.c
index eb43acc91e66..515c1877bc7f 100644
--- a/drivers/staging/greybus/raw.c
+++ b/drivers/staging/greybus/raw.c
@@ -13,6 +13,7 @@
 #include <linux/cdev.h>
 #include <linux/fs.h>
 #include <linux/idr.h>
+#include <linux/uaccess.h>
 
 #include "greybus.h"
 

commit e806c7fb8e9bae87fc23958c3789f2c2f96f54a4
Author: Greg Kroah-Hartman <gregkh@google.com>
Date:   Fri May 8 15:50:17 2015 +0200

    greybus: raw: add raw greybus kernel driver
    
    This adds a driver that implements the greybus Raw protocol as
    specified.
    
    It preserves the message boundries by only allowing a read to receive
    a "full" message, and any write() call also is passed in a single
    greybus request.
    
    Totally untested, given that we have no raw firmware or gbsim code yet.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>
    Reviewed-by: Rui Miguel Silva <rui.silva@linaro.org>

diff --git a/drivers/staging/greybus/raw.c b/drivers/staging/greybus/raw.c
new file mode 100644
index 000000000000..eb43acc91e66
--- /dev/null
+++ b/drivers/staging/greybus/raw.c
@@ -0,0 +1,370 @@
+/*
+ * Greybus driver for the Raw protocol
+ *
+ * Copyright 2015 Google Inc.
+ * Copyright 2015 Linaro Ltd.
+ *
+ * Released under the GPLv2 only.
+ */
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/sizes.h>
+#include <linux/cdev.h>
+#include <linux/fs.h>
+#include <linux/idr.h>
+
+#include "greybus.h"
+
+struct gb_raw {
+	struct gb_connection *connection;
+	u8 version_major;
+	u8 version_minor;
+
+	struct list_head list;
+	int list_data;
+	struct mutex list_lock;
+	dev_t dev;
+	struct cdev cdev;
+	struct device *device;
+};
+
+/* Version of the Greybus raw protocol we support */
+#define	GB_RAW_VERSION_MAJOR			0x00
+#define	GB_RAW_VERSION_MINOR			0x01
+
+/* Greybus raw request types */
+#define	GB_RAW_TYPE_INVALID			0x00
+#define	GB_RAW_TYPE_PROTOCOL_VERSION		0x01
+#define	GB_RAW_TYPE_SEND			0x02
+
+/* Define get_version() routine */
+define_get_version(gb_raw, RAW);
+
+struct gb_raw_send_request {
+	__le32	len;
+	__u8	data[0];
+};
+
+struct raw_data {
+	struct list_head entry;
+	u32 len;
+	u8 data[0];
+};
+
+static struct class *raw_class;
+static int raw_major;
+static const struct file_operations raw_fops;
+static DEFINE_IDA(minors);
+
+/* Number of minor devices this driver supports */
+#define NUM_MINORS	256
+
+/* Maximum size of any one send data buffer we support */
+#define MAX_PACKET_SIZE	(PAGE_SIZE * 2)
+
+/*
+ * Maximum size of the data in the receive buffer we allow before we start to
+ * drop messages on the floor
+ */
+#define MAX_DATA_SIZE	(MAX_PACKET_SIZE * 8)
+
+/*
+ * Add the raw data message to the list of received messages.
+ */
+static int receive_data(struct gb_raw *raw, u32 len, u8 *data)
+{
+	struct raw_data *raw_data;
+	int retval = 0;
+
+	if (len > MAX_PACKET_SIZE) {
+		dev_err(raw->device, "Too big of a data packet, rejected\n");
+		return -EINVAL;
+	}
+
+	mutex_lock(&raw->list_lock);
+	if ((raw->list_data + len) > MAX_DATA_SIZE) {
+		dev_err(raw->device,
+			"Too much data in receive buffer, now dropping packets\n");
+		retval = -EINVAL;
+		goto exit;
+	}
+
+	raw_data = kmalloc(sizeof(*raw_data) + len, GFP_KERNEL);
+	if (!raw_data) {
+		retval = -ENOMEM;
+		goto exit;
+	}
+
+	raw->list_data += len;
+	raw_data->len = len;
+	memcpy(&raw_data->data[0], data, len);
+
+	list_add_tail(&raw_data->entry, &raw->list);
+exit:
+	mutex_unlock(&raw->list_lock);
+	return retval;
+}
+
+static int gb_raw_receive(u8 type, struct gb_operation *op)
+{
+	struct gb_connection *connection = op->connection;
+	struct gb_raw *raw = connection->private;
+	struct gb_raw_send_request *receive;
+	u32 len;
+
+	if (type != GB_RAW_TYPE_SEND) {
+		dev_err(raw->device, "unknown request type %d\n", type);
+		return -EINVAL;
+	}
+
+	/* Verify size of payload */
+	if (op->request->payload_size < sizeof(*receive)) {
+		dev_err(raw->device, "raw receive request too small\n");
+		return -EINVAL;
+	}
+	receive = op->request->payload;
+	len = le32_to_cpu(receive->len);
+	if (len != (int)(op->request->payload_size - sizeof(__le32))) {
+		dev_err(raw->device,
+			"raw receive request wrong size %d vs %d\n",
+			len,
+			(int)(op->request->payload_size - sizeof(__le32)));
+		return -EINVAL;
+	}
+	if (len == 0) {
+		dev_err(raw->device, "raw receive request of 0 bytes?\n");
+		return -EINVAL;
+	}
+
+	return receive_data(raw, len, receive->data);
+}
+
+static int gb_raw_send(struct gb_raw *raw, u32 len, const char __user *data)
+{
+	struct gb_connection *connection = raw->connection;
+	struct gb_raw_send_request *request;
+	int retval;
+
+	request = kmalloc(len + sizeof(*request), GFP_KERNEL);
+	if (!request)
+		return -ENOMEM;
+
+	if (copy_from_user(&request->data[0], data, len)) {
+		kfree(request);
+		return -EFAULT;
+	}
+
+	request->len = cpu_to_le32(len);
+
+	retval = gb_operation_sync(connection, GB_RAW_TYPE_SEND,
+				   request, len + sizeof(*request),
+				   NULL, 0);
+
+	kfree(request);
+	return retval;
+}
+
+static int gb_raw_connection_init(struct gb_connection *connection)
+{
+	struct gb_raw *raw;
+	int retval;
+	int minor;
+
+	raw = kzalloc(sizeof(*raw), GFP_KERNEL);
+	if (!raw)
+		return -ENOMEM;
+
+	raw->connection = connection;
+	connection->private = raw;
+
+	/* Check the protocol version */
+	retval = get_version(raw);
+	if (retval)
+		goto error_free;
+
+	INIT_LIST_HEAD(&raw->list);
+	mutex_init(&raw->list_lock);
+
+	minor = ida_simple_get(&minors, 0, 0, GFP_KERNEL);
+	if (minor < 0) {
+		retval = minor;
+		goto error_free;
+	}
+
+	raw->dev = MKDEV(raw_major, minor);
+	cdev_init(&raw->cdev, &raw_fops);
+	retval = cdev_add(&raw->cdev, raw->dev, 1);
+	if (retval)
+		goto error_cdev;
+
+	raw->device = device_create(raw_class, &connection->dev, raw->dev, raw,
+				    "gb!raw%d", minor);
+	if (IS_ERR(raw->device)) {
+		retval = PTR_ERR(raw->device);
+		goto error_device;
+	}
+
+	return 0;
+
+error_device:
+	cdev_del(&raw->cdev);
+
+error_cdev:
+	ida_simple_remove(&minors, minor);
+
+error_free:
+	kfree(raw);
+	return retval;
+}
+
+static void gb_raw_connection_exit(struct gb_connection *connection)
+{
+	struct gb_raw *raw = connection->private;
+	struct raw_data *raw_data;
+	struct raw_data *temp;
+
+	// FIXME - handle removing a connection when the char device node is open.
+	cdev_del(&raw->cdev);
+	ida_simple_remove(&minors, MINOR(raw->dev));
+	device_del(raw->device);
+	mutex_lock(&raw->list_lock);
+	list_for_each_entry_safe(raw_data, temp, &raw->list, entry) {
+		list_del(&raw_data->entry);
+		kfree(raw_data);
+	}
+	mutex_unlock(&raw->list_lock);
+
+	kfree(raw);
+}
+
+static struct gb_protocol raw_protocol = {
+	.name			= "raw",
+	.id			= GREYBUS_PROTOCOL_RAW,
+	.major			= GB_RAW_VERSION_MAJOR,
+	.minor			= GB_RAW_VERSION_MINOR,
+	.connection_init	= gb_raw_connection_init,
+	.connection_exit	= gb_raw_connection_exit,
+	.request_recv		= gb_raw_receive,
+};
+
+/*
+ * Character device node interfaces.
+ *
+ * Note, we are using read/write to only allow a single read/write per message.
+ * This means for read(), you have to provide a big enough buffer for the full
+ * message to be copied into.  If the buffer isn't big enough, the read() will
+ * fail with -ENOSPC.
+ */
+
+static int raw_open(struct inode *inode, struct file *file)
+{
+	struct cdev *cdev = inode->i_cdev;
+	struct gb_raw *raw = container_of(cdev, struct gb_raw, cdev);
+
+	file->private_data = raw;
+	return 0;
+}
+
+static ssize_t raw_write(struct file *file, const char __user *buf,
+			 size_t count, loff_t *ppos)
+{
+	struct gb_raw *raw = file->private_data;
+	int retval;
+
+	if (!count)
+		return 0;
+
+	if (count > MAX_PACKET_SIZE)
+		return -E2BIG;
+
+	retval = gb_raw_send(raw, count, buf);
+	if (retval)
+		return retval;
+
+	return count;
+}
+
+static ssize_t raw_read(struct file *file, char __user *buf, size_t count,
+			loff_t *ppos)
+{
+	struct gb_raw *raw = file->private_data;
+	int retval = 0;
+	struct raw_data *raw_data;
+
+	mutex_lock(&raw->list_lock);
+	if (list_empty(&raw->list))
+		goto exit;
+
+	raw_data = list_first_entry(&raw->list, struct raw_data, entry);
+	if (raw_data->len > count) {
+		retval = -ENOSPC;
+		goto exit;
+	}
+
+	if (copy_to_user(buf, &raw_data->data[0], raw_data->len)) {
+		retval = -EFAULT;
+		goto exit;
+	}
+
+	list_del(&raw_data->entry);
+	raw->list_data -= raw_data->len;
+	retval = raw_data->len;
+	kfree(raw_data);
+
+exit:
+	mutex_unlock(&raw->list_lock);
+	return retval;
+}
+
+static const struct file_operations raw_fops = {
+	.owner		= THIS_MODULE,
+	.write		= raw_write,
+	.read		= raw_read,
+	.open		= raw_open,
+	.llseek		= noop_llseek,
+};
+
+static int raw_init(void)
+{
+	dev_t dev;
+	int retval;
+
+	raw_class = class_create(THIS_MODULE, "gb_raw");
+	if (IS_ERR(raw_class)) {
+		retval = PTR_ERR(raw_class);
+		goto error_class;
+	}
+
+	retval = alloc_chrdev_region(&dev, 0, NUM_MINORS, "gb_raw");
+	if (retval < 0)
+		goto error_chrdev;
+
+
+	raw_major = MAJOR(dev);
+
+	retval = gb_protocol_register(&raw_protocol);
+	if (retval)
+		goto error_gb;
+
+	return 0;
+
+error_gb:
+	unregister_chrdev_region(dev, NUM_MINORS);
+error_chrdev:
+	class_destroy(raw_class);
+error_class:
+	return retval;
+}
+
+static void __exit raw_exit(void)
+{
+	gb_protocol_deregister(&raw_protocol);
+	unregister_chrdev_region(MKDEV(raw_major, 0), NUM_MINORS);
+	class_destroy(raw_class);
+}
+
+module_init(raw_init);
+module_exit(raw_exit);
+
+MODULE_LICENSE("GPL v2");
