commit ec0ad868173da8a75121f9dc116a5d5478ff614d
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Sun Aug 25 07:54:27 2019 +0200

    staging: greybus: move core include files to include/linux/greybus/
    
    With the goal of moving the core of the greybus code out of staging, the
    include files need to be moved to include/linux/greybus.h and
    include/linux/greybus/
    
    Cc: Vaibhav Hiremath <hvaibhav.linux@gmail.com>
    Cc: Johan Hovold <johan@kernel.org>
    Cc: Vaibhav Agarwal <vaibhav.sr@gmail.com>
    Cc: Rui Miguel Silva <rmfrfs@gmail.com>
    Cc: David Lin <dtwlin@gmail.com>
    Cc: "Bryan O'Donoghue" <pure.logic@nexus-software.ie>
    Cc: greybus-dev@lists.linaro.org
    Cc: devel@driverdev.osuosl.org
    Acked-by: Mark Greer <mgreer@animalcreek.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Acked-by: Alex Elder <elder@kernel.org>
    Link: https://lore.kernel.org/r/20190825055429.18547-8-gregkh@linuxfoundation.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/camera.c b/drivers/staging/greybus/camera.c
index 615c8e7fd51e..b570e13394ac 100644
--- a/drivers/staging/greybus/camera.c
+++ b/drivers/staging/greybus/camera.c
@@ -14,9 +14,9 @@
 #include <linux/string.h>
 #include <linux/uaccess.h>
 #include <linux/vmalloc.h>
+#include <linux/greybus.h>
 
 #include "gb-camera.h"
-#include "greybus.h"
 #include "greybus_protocols.h"
 
 enum gb_camera_debugs_buffer_id {

commit 8478c35a858c75bf2b00917009ba1b46c1b9b7b4
Author: Cristian Sicilia <sicilia.cristian@gmail.com>
Date:   Sun Nov 25 17:58:15 2018 +0100

    staging: greybus: Parenthesis alignment
    
    Some parameters are aligned with parentheses.
    Some parentheses was opened at end of line.
    
    Signed-off-by: Cristian Sicilia <sicilia.cristian@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/camera.c b/drivers/staging/greybus/camera.c
index c6d65430ea4c..615c8e7fd51e 100644
--- a/drivers/staging/greybus/camera.c
+++ b/drivers/staging/greybus/camera.c
@@ -841,8 +841,8 @@ static int gb_camera_op_configure_streams(void *priv, unsigned int *nstreams,
 }
 
 static int gb_camera_op_capture(void *priv, u32 request_id,
-		unsigned int streams, unsigned int num_frames,
-		size_t settings_size, const void *settings)
+				unsigned int streams, unsigned int num_frames,
+				size_t settings_size, const void *settings)
 {
 	struct gb_camera *gcam = priv;
 
@@ -869,7 +869,7 @@ static const struct gb_camera_ops gb_cam_ops = {
  */
 
 static ssize_t gb_camera_debugfs_capabilities(struct gb_camera *gcam,
-		char *buf, size_t len)
+					      char *buf, size_t len)
 {
 	struct gb_camera_debugfs_buffer *buffer =
 		&gcam->debugfs.buffers[GB_CAMERA_DEBUGFS_BUFFER_CAPABILITIES];
@@ -905,7 +905,7 @@ static ssize_t gb_camera_debugfs_capabilities(struct gb_camera *gcam,
 }
 
 static ssize_t gb_camera_debugfs_configure_streams(struct gb_camera *gcam,
-		char *buf, size_t len)
+						   char *buf, size_t len)
 {
 	struct gb_camera_debugfs_buffer *buffer =
 		&gcam->debugfs.buffers[GB_CAMERA_DEBUGFS_BUFFER_STREAMS];
@@ -999,7 +999,7 @@ static ssize_t gb_camera_debugfs_configure_streams(struct gb_camera *gcam,
 };
 
 static ssize_t gb_camera_debugfs_capture(struct gb_camera *gcam,
-		char *buf, size_t len)
+					 char *buf, size_t len)
 {
 	unsigned int request_id;
 	unsigned int streams_mask;
@@ -1040,7 +1040,7 @@ static ssize_t gb_camera_debugfs_capture(struct gb_camera *gcam,
 }
 
 static ssize_t gb_camera_debugfs_flush(struct gb_camera *gcam,
-		char *buf, size_t len)
+				       char *buf, size_t len)
 {
 	struct gb_camera_debugfs_buffer *buffer =
 		&gcam->debugfs.buffers[GB_CAMERA_DEBUGFS_BUFFER_FLUSH];

commit e48adf19ea503a6f1b6d6a7c975221ab84ed79ab
Author: Ioannis Valasakis <code@wizofe.uk>
Date:   Fri Nov 9 13:55:09 2018 +0000

    staging: greybus: remove unmatched right bracket
    
    Remove unmatched right bracket. Reported by uncrustify.
    
    Signed-off-by: Ioannis Valasakis <code@wizofe.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/camera.c b/drivers/staging/greybus/camera.c
index 6dded10f4155..c6d65430ea4c 100644
--- a/drivers/staging/greybus/camera.c
+++ b/drivers/staging/greybus/camera.c
@@ -1190,7 +1190,6 @@ static int gb_camera_debugfs_init(struct gb_camera *gcam)
 		debugfs_create_file(entry->name, entry->mask,
 				    gcam->debugfs.root, gcam,
 				    &gb_camera_debugfs_ops);
-		}
 	}
 
 	return 0;

commit 42bc47b35320e0e587a88e437e18f80f9c5bcbb2
Author: Kees Cook <keescook@chromium.org>
Date:   Tue Jun 12 14:27:11 2018 -0700

    treewide: Use array_size() in vmalloc()
    
    The vmalloc() function has no 2-factor argument form, so multiplication
    factors need to be wrapped in array_size(). This patch replaces cases of:
    
            vmalloc(a * b)
    
    with:
            vmalloc(array_size(a, b))
    
    as well as handling cases of:
    
            vmalloc(a * b * c)
    
    with:
    
            vmalloc(array3_size(a, b, c))
    
    This does, however, attempt to ignore constant size factors like:
    
            vmalloc(4 * 1024)
    
    though any constants defined via macros get caught up in the conversion.
    
    Any factors with a sizeof() of "unsigned char", "char", and "u8" were
    dropped, since they're redundant.
    
    The Coccinelle script used for this was:
    
    // Fix redundant parens around sizeof().
    @@
    type TYPE;
    expression THING, E;
    @@
    
    (
      vmalloc(
    -       (sizeof(TYPE)) * E
    +       sizeof(TYPE) * E
      , ...)
    |
      vmalloc(
    -       (sizeof(THING)) * E
    +       sizeof(THING) * E
      , ...)
    )
    
    // Drop single-byte sizes and redundant parens.
    @@
    expression COUNT;
    typedef u8;
    typedef __u8;
    @@
    
    (
      vmalloc(
    -       sizeof(u8) * (COUNT)
    +       COUNT
      , ...)
    |
      vmalloc(
    -       sizeof(__u8) * (COUNT)
    +       COUNT
      , ...)
    |
      vmalloc(
    -       sizeof(char) * (COUNT)
    +       COUNT
      , ...)
    |
      vmalloc(
    -       sizeof(unsigned char) * (COUNT)
    +       COUNT
      , ...)
    |
      vmalloc(
    -       sizeof(u8) * COUNT
    +       COUNT
      , ...)
    |
      vmalloc(
    -       sizeof(__u8) * COUNT
    +       COUNT
      , ...)
    |
      vmalloc(
    -       sizeof(char) * COUNT
    +       COUNT
      , ...)
    |
      vmalloc(
    -       sizeof(unsigned char) * COUNT
    +       COUNT
      , ...)
    )
    
    // 2-factor product with sizeof(type/expression) and identifier or constant.
    @@
    type TYPE;
    expression THING;
    identifier COUNT_ID;
    constant COUNT_CONST;
    @@
    
    (
      vmalloc(
    -       sizeof(TYPE) * (COUNT_ID)
    +       array_size(COUNT_ID, sizeof(TYPE))
      , ...)
    |
      vmalloc(
    -       sizeof(TYPE) * COUNT_ID
    +       array_size(COUNT_ID, sizeof(TYPE))
      , ...)
    |
      vmalloc(
    -       sizeof(TYPE) * (COUNT_CONST)
    +       array_size(COUNT_CONST, sizeof(TYPE))
      , ...)
    |
      vmalloc(
    -       sizeof(TYPE) * COUNT_CONST
    +       array_size(COUNT_CONST, sizeof(TYPE))
      , ...)
    |
      vmalloc(
    -       sizeof(THING) * (COUNT_ID)
    +       array_size(COUNT_ID, sizeof(THING))
      , ...)
    |
      vmalloc(
    -       sizeof(THING) * COUNT_ID
    +       array_size(COUNT_ID, sizeof(THING))
      , ...)
    |
      vmalloc(
    -       sizeof(THING) * (COUNT_CONST)
    +       array_size(COUNT_CONST, sizeof(THING))
      , ...)
    |
      vmalloc(
    -       sizeof(THING) * COUNT_CONST
    +       array_size(COUNT_CONST, sizeof(THING))
      , ...)
    )
    
    // 2-factor product, only identifiers.
    @@
    identifier SIZE, COUNT;
    @@
    
      vmalloc(
    -       SIZE * COUNT
    +       array_size(COUNT, SIZE)
      , ...)
    
    // 3-factor product with 1 sizeof(type) or sizeof(expression), with
    // redundant parens removed.
    @@
    expression THING;
    identifier STRIDE, COUNT;
    type TYPE;
    @@
    
    (
      vmalloc(
    -       sizeof(TYPE) * (COUNT) * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      vmalloc(
    -       sizeof(TYPE) * (COUNT) * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      vmalloc(
    -       sizeof(TYPE) * COUNT * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      vmalloc(
    -       sizeof(TYPE) * COUNT * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      vmalloc(
    -       sizeof(THING) * (COUNT) * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    |
      vmalloc(
    -       sizeof(THING) * (COUNT) * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    |
      vmalloc(
    -       sizeof(THING) * COUNT * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    |
      vmalloc(
    -       sizeof(THING) * COUNT * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    )
    
    // 3-factor product with 2 sizeof(variable), with redundant parens removed.
    @@
    expression THING1, THING2;
    identifier COUNT;
    type TYPE1, TYPE2;
    @@
    
    (
      vmalloc(
    -       sizeof(TYPE1) * sizeof(TYPE2) * COUNT
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(TYPE2))
      , ...)
    |
      vmalloc(
    -       sizeof(TYPE1) * sizeof(THING2) * (COUNT)
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(TYPE2))
      , ...)
    |
      vmalloc(
    -       sizeof(THING1) * sizeof(THING2) * COUNT
    +       array3_size(COUNT, sizeof(THING1), sizeof(THING2))
      , ...)
    |
      vmalloc(
    -       sizeof(THING1) * sizeof(THING2) * (COUNT)
    +       array3_size(COUNT, sizeof(THING1), sizeof(THING2))
      , ...)
    |
      vmalloc(
    -       sizeof(TYPE1) * sizeof(THING2) * COUNT
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(THING2))
      , ...)
    |
      vmalloc(
    -       sizeof(TYPE1) * sizeof(THING2) * (COUNT)
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(THING2))
      , ...)
    )
    
    // 3-factor product, only identifiers, with redundant parens removed.
    @@
    identifier STRIDE, SIZE, COUNT;
    @@
    
    (
      vmalloc(
    -       (COUNT) * STRIDE * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      vmalloc(
    -       COUNT * (STRIDE) * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      vmalloc(
    -       COUNT * STRIDE * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      vmalloc(
    -       (COUNT) * (STRIDE) * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      vmalloc(
    -       COUNT * (STRIDE) * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      vmalloc(
    -       (COUNT) * STRIDE * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      vmalloc(
    -       (COUNT) * (STRIDE) * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      vmalloc(
    -       COUNT * STRIDE * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    )
    
    // Any remaining multi-factor products, first at least 3-factor products
    // when they're not all constants...
    @@
    expression E1, E2, E3;
    constant C1, C2, C3;
    @@
    
    (
      vmalloc(C1 * C2 * C3, ...)
    |
      vmalloc(
    -       E1 * E2 * E3
    +       array3_size(E1, E2, E3)
      , ...)
    )
    
    // And then all remaining 2 factors products when they're not all constants.
    @@
    expression E1, E2;
    constant C1, C2;
    @@
    
    (
      vmalloc(C1 * C2, ...)
    |
      vmalloc(
    -       E1 * E2
    +       array_size(E1, E2)
      , ...)
    )
    
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/drivers/staging/greybus/camera.c b/drivers/staging/greybus/camera.c
index 341f729a9779..6dded10f4155 100644
--- a/drivers/staging/greybus/camera.c
+++ b/drivers/staging/greybus/camera.c
@@ -1175,8 +1175,9 @@ static int gb_camera_debugfs_init(struct gb_camera *gcam)
 
 	gcam->debugfs.root = debugfs_create_dir(dirname, gb_debugfs_get());
 
-	gcam->debugfs.buffers = vmalloc(sizeof(*gcam->debugfs.buffers) *
-					GB_CAMERA_DEBUGFS_BUFFER_MAX);
+	gcam->debugfs.buffers =
+		vmalloc(array_size(GB_CAMERA_DEBUGFS_BUFFER_MAX,
+				   sizeof(*gcam->debugfs.buffers)));
 	if (!gcam->debugfs.buffers)
 		return -ENOMEM;
 

commit 00aaa6b138d967cd815f427c59c4e4162084e574
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue May 29 16:29:35 2018 +0200

    staging: greybus: camera: no need to check debugfs return values
    
    When calling debugfs functions, there is no need to ever check the
    return value.  The function can work or not, but the code logic should
    never do something different based on this.
    
    Clean up the greybus camera driver by not caring about the value of
    debugfs calls.  This ends up removing a number of lines of code that
    are not needed.
    
    Cc: Alex Elder <elder@kernel.org>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: greybus-dev@lists.linaro.org
    Reviewed-by: Viresh Kumar <viresh.kumar@linaro.org>
    Acked-by: Johan Hovold <johan@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/camera.c b/drivers/staging/greybus/camera.c
index 07ebfb88db9b..341f729a9779 100644
--- a/drivers/staging/greybus/camera.c
+++ b/drivers/staging/greybus/camera.c
@@ -1174,11 +1174,6 @@ static int gb_camera_debugfs_init(struct gb_camera *gcam)
 		 gcam->bundle->id);
 
 	gcam->debugfs.root = debugfs_create_dir(dirname, gb_debugfs_get());
-	if (IS_ERR(gcam->debugfs.root)) {
-		gcam_err(gcam, "debugfs root create failed (%ld)\n",
-			 PTR_ERR(gcam->debugfs.root));
-		return PTR_ERR(gcam->debugfs.root);
-	}
 
 	gcam->debugfs.buffers = vmalloc(sizeof(*gcam->debugfs.buffers) *
 					GB_CAMERA_DEBUGFS_BUFFER_MAX);
@@ -1188,18 +1183,12 @@ static int gb_camera_debugfs_init(struct gb_camera *gcam)
 	for (i = 0; i < ARRAY_SIZE(gb_camera_debugfs_entries); ++i) {
 		const struct gb_camera_debugfs_entry *entry =
 			&gb_camera_debugfs_entries[i];
-		struct dentry *dentry;
 
 		gcam->debugfs.buffers[i].length = 0;
 
-		dentry = debugfs_create_file(entry->name, entry->mask,
-					     gcam->debugfs.root, gcam,
-					     &gb_camera_debugfs_ops);
-		if (IS_ERR(dentry)) {
-			gcam_err(gcam,
-				 "debugfs operation %s create failed (%ld)\n",
-				 entry->name, PTR_ERR(dentry));
-			return PTR_ERR(dentry);
+		debugfs_create_file(entry->name, entry->mask,
+				    gcam->debugfs.root, gcam,
+				    &gb_camera_debugfs_ops);
 		}
 	}
 

commit b5c54c4520ce192e417cfaa5eaf7b709996eb9b5
Author: Sumit Pundir <pundirsumit11@gmail.com>
Date:   Mon Jan 8 22:20:15 2018 +0530

    Staging: greybus: camera: cleanup multiple checks for null pointers
    
    Fixed coding style issue regarding null comparison at multiple lines.
    Issue reported by checkpatch.pl
    
    Signed-off-by: Sumit Pundir <pundirsumit11@gmail.com>
    Acked-by: Johan Hovold <johan@kernel.org>
    Reviewed-by: Alex Elder <elder@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/camera.c b/drivers/staging/greybus/camera.c
index f13f16b63d7e..07ebfb88db9b 100644
--- a/drivers/staging/greybus/camera.c
+++ b/drivers/staging/greybus/camera.c
@@ -918,7 +918,7 @@ static ssize_t gb_camera_debugfs_configure_streams(struct gb_camera *gcam,
 
 	/* Retrieve number of streams to configure */
 	token = strsep(&buf, ";");
-	if (token == NULL)
+	if (!token)
 		return -EINVAL;
 
 	ret = kstrtouint(token, 10, &nstreams);
@@ -929,7 +929,7 @@ static ssize_t gb_camera_debugfs_configure_streams(struct gb_camera *gcam,
 		return -EINVAL;
 
 	token = strsep(&buf, ";");
-	if (token == NULL)
+	if (!token)
 		return -EINVAL;
 
 	ret = kstrtouint(token, 10, &flags);
@@ -946,7 +946,7 @@ static ssize_t gb_camera_debugfs_configure_streams(struct gb_camera *gcam,
 
 		/* width */
 		token = strsep(&buf, ";");
-		if (token == NULL) {
+		if (!token) {
 			ret = -EINVAL;
 			goto done;
 		}
@@ -956,7 +956,7 @@ static ssize_t gb_camera_debugfs_configure_streams(struct gb_camera *gcam,
 
 		/* height */
 		token = strsep(&buf, ";");
-		if (token == NULL)
+		if (!token)
 			goto done;
 
 		ret = kstrtouint(token, 10, &stream->height);
@@ -965,7 +965,7 @@ static ssize_t gb_camera_debugfs_configure_streams(struct gb_camera *gcam,
 
 		/* Image format code */
 		token = strsep(&buf, ";");
-		if (token == NULL)
+		if (!token)
 			goto done;
 
 		ret = kstrtouint(token, 16, &stream->format);
@@ -1009,7 +1009,7 @@ static ssize_t gb_camera_debugfs_capture(struct gb_camera *gcam,
 
 	/* Request id */
 	token = strsep(&buf, ";");
-	if (token == NULL)
+	if (!token)
 		return -EINVAL;
 	ret = kstrtouint(token, 10, &request_id);
 	if (ret < 0)
@@ -1017,7 +1017,7 @@ static ssize_t gb_camera_debugfs_capture(struct gb_camera *gcam,
 
 	/* Stream mask */
 	token = strsep(&buf, ";");
-	if (token == NULL)
+	if (!token)
 		return -EINVAL;
 	ret = kstrtouint(token, 16, &streams_mask);
 	if (ret < 0)
@@ -1025,7 +1025,7 @@ static ssize_t gb_camera_debugfs_capture(struct gb_camera *gcam,
 
 	/* number of frames */
 	token = strsep(&buf, ";");
-	if (token == NULL)
+	if (!token)
 		return -EINVAL;
 	ret = kstrtouint(token, 10, &num_frames);
 	if (ret < 0)

commit 863dbc52e7f0e5acd7b4883f3933543a81c474c7
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Nov 7 14:58:42 2017 +0100

    staging: greybus: Remove redundant license text
    
    Now that the SPDX tag is in all greybus files, that identifies the
    license in a specific and legally-defined manner.  So the extra GPL text
    wording can be removed as it is no longer needed at all.
    
    This is done on a quest to remove the 700+ different ways that files in
    the kernel describe the GPL license text.  And there's unneeded stuff
    like the address (sometimes incorrect) for the FSF which is never
    needed.
    
    No copyright headers or other non-license-description text was removed.
    
    Cc: Vaibhav Hiremath <hvaibhav.linux@gmail.com>
    Reviewed-by: Alex Elder <elder@linaro.org>
    Acked-by: Vaibhav Agarwal <vaibhav.sr@gmail.com>
    Acked-by: David Lin <dtwlin@gmail.com>
    Acked-by: Johan Hovold <johan@kernel.org>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Acked-by: Mark Greer <mgreer@animalcreek.com>
    Acked-by: Rui Miguel Silva <rmfrfs@gmail.com>
    Acked-by: "Bryan O'Donoghue" <pure.logic@nexus-software.ie>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/camera.c b/drivers/staging/greybus/camera.c
index 2ce5b20a3df0..f13f16b63d7e 100644
--- a/drivers/staging/greybus/camera.c
+++ b/drivers/staging/greybus/camera.c
@@ -4,8 +4,6 @@
  *
  * Copyright 2015 Google Inc.
  * Copyright 2015 Linaro Ltd.
- *
- * Released under the GPLv2 only.
  */
 
 #include <linux/debugfs.h>

commit eb50fd3a22c770f36be275295b782f3ea52e3215
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Nov 7 14:58:41 2017 +0100

    staging: greybus: add SPDX identifiers to all greybus driver files
    
    It's good to have SPDX identifiers in all files to make it easier to
    audit the kernel tree for correct licenses.
    
    Update the drivers/staging/greybus files files with the correct SPDX
    license identifier based on the license text in the file itself.  The
    SPDX identifier is a legally binding shorthand, which can be used
    instead of the full boiler plate text.
    
    This work is based on a script and data from Thomas Gleixner, Philippe
    Ombredanne, and Kate Stewart.
    
    Cc: Vaibhav Hiremath <hvaibhav.linux@gmail.com>
    Cc: "Bryan O'Donoghue" <pure.logic@nexus-software.ie>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: Philippe Ombredanne <pombredanne@nexb.com>
    Acked-by: Vaibhav Agarwal <vaibhav.sr@gmail.com>
    Acked-by: David Lin <dtwlin@gmail.com>
    Reviewed-by: Alex Elder <elder@linaro.org>
    Acked-by: Johan Hovold <johan@kernel.org>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Acked-by: Mark Greer <mgreer@animalcreek.com>
    Acked-by: Rui Miguel Silva <rmfrfs@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/camera.c b/drivers/staging/greybus/camera.c
index a64517eabff4..2ce5b20a3df0 100644
--- a/drivers/staging/greybus/camera.c
+++ b/drivers/staging/greybus/camera.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * Greybus Camera protocol driver.
  *

commit 0a8d852234b35ddfe6b28769967d538dc39b9517
Author: Derek Robson <robsonde@gmail.com>
Date:   Thu Jan 12 17:59:40 2017 +1300

    Staging: greybus: style fix, permissions as octal
    
    Changed permissions to be in octal style.
    Found by checkpatch.
    
    Signed-off-by: Derek Robson <robsonde@gmail.com>
    Acked-by: Johan Hovold <johan@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/camera.c b/drivers/staging/greybus/camera.c
index 0ee291ca2c72..a64517eabff4 100644
--- a/drivers/staging/greybus/camera.c
+++ b/drivers/staging/greybus/camera.c
@@ -1067,22 +1067,22 @@ struct gb_camera_debugfs_entry {
 static const struct gb_camera_debugfs_entry gb_camera_debugfs_entries[] = {
 	{
 		.name = "capabilities",
-		.mask = S_IFREG | S_IRUGO,
+		.mask = S_IFREG | 0444,
 		.buffer = GB_CAMERA_DEBUGFS_BUFFER_CAPABILITIES,
 		.execute = gb_camera_debugfs_capabilities,
 	}, {
 		.name = "configure_streams",
-		.mask = S_IFREG | S_IRUGO | S_IWUGO,
+		.mask = S_IFREG | 0666,
 		.buffer = GB_CAMERA_DEBUGFS_BUFFER_STREAMS,
 		.execute = gb_camera_debugfs_configure_streams,
 	}, {
 		.name = "capture",
-		.mask = S_IFREG | S_IRUGO | S_IWUGO,
+		.mask = S_IFREG | 0666,
 		.buffer = GB_CAMERA_DEBUGFS_BUFFER_CAPTURE,
 		.execute = gb_camera_debugfs_capture,
 	}, {
 		.name = "flush",
-		.mask = S_IFREG | S_IRUGO | S_IWUGO,
+		.mask = S_IFREG | 0666,
 		.buffer = GB_CAMERA_DEBUGFS_BUFFER_FLUSH,
 		.execute = gb_camera_debugfs_flush,
 	},
@@ -1097,7 +1097,7 @@ static ssize_t gb_camera_debugfs_read(struct file *file, char __user *buf,
 	ssize_t ret;
 
 	/* For read-only entries the operation is triggered by a read. */
-	if (!(op->mask & S_IWUGO)) {
+	if (!(op->mask & 0222)) {
 		ret = op->execute(gcam, NULL, 0);
 		if (ret < 0)
 			return ret;

commit 9a19a6db37ee0b7a6db796b3dcd6bb6e7237d6ea
Merge: bd9999cd6a5e c4364f837caf
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Dec 16 10:24:44 2016 -0800

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs
    
    Pull vfs updates from Al Viro:
    
     - more ->d_init() stuff (work.dcache)
    
     - pathname resolution cleanups (work.namei)
    
     - a few missing iov_iter primitives - copy_from_iter_full() and
       friends. Either copy the full requested amount, advance the iterator
       and return true, or fail, return false and do _not_ advance the
       iterator. Quite a few open-coded callers converted (and became more
       readable and harder to fuck up that way) (work.iov_iter)
    
     - several assorted patches, the big one being logfs removal
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs:
      logfs: remove from tree
      vfs: fix put_compat_statfs64() does not handle errors
      namei: fold should_follow_link() with the step into not-followed link
      namei: pass both WALK_GET and WALK_MORE to should_follow_link()
      namei: invert WALK_PUT logics
      namei: shift interpretation of LOOKUP_FOLLOW inside should_follow_link()
      namei: saner calling conventions for mountpoint_last()
      namei.c: get rid of user_path_parent()
      switch getfrag callbacks to ..._full() primitives
      make skb_add_data,{_nocache}() and skb_copy_to_page_nocache() advance only on success
      [iov_iter] new primitives - copy_from_iter_full() and friends
      don't open-code file_inode()
      ceph: switch to use of ->d_init()
      ceph: unify dentry_operations instances
      lustre: switch to use of ->d_init()

commit 450630975da9e7dffe540753e169dc4da5fe7c29
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sun Dec 4 18:24:56 2016 -0500

    don't open-code file_inode()
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/drivers/staging/greybus/camera.c b/drivers/staging/greybus/camera.c
index 491bdd720c0c..cebb76e7d55c 100644
--- a/drivers/staging/greybus/camera.c
+++ b/drivers/staging/greybus/camera.c
@@ -1091,7 +1091,7 @@ static ssize_t gb_camera_debugfs_read(struct file *file, char __user *buf,
 				      size_t len, loff_t *offset)
 {
 	const struct gb_camera_debugfs_entry *op = file->private_data;
-	struct gb_camera *gcam = file->f_inode->i_private;
+	struct gb_camera *gcam = file_inode(file)->i_private;
 	struct gb_camera_debugfs_buffer *buffer;
 	ssize_t ret;
 
@@ -1113,7 +1113,7 @@ static ssize_t gb_camera_debugfs_write(struct file *file,
 				       loff_t *offset)
 {
 	const struct gb_camera_debugfs_entry *op = file->private_data;
-	struct gb_camera *gcam = file->f_inode->i_private;
+	struct gb_camera *gcam = file_inode(file)->i_private;
 	ssize_t ret;
 	char *kbuf;
 

commit c4fc2ebcbf762a1fe827931d670452aa27abef00
Author: Elise Lennion <elise.lennion@gmail.com>
Date:   Wed Oct 12 14:14:14 2016 -0300

    staging: greybus: camera: Use kcalloc for array's memory allocation.
    
    Fix checkpatch warning:
    
    WARNING: Prefer kcalloc over kzalloc with multiply
    
    kcalloc is designed to allocate memory for arrays, its use is
    preferable than kzalloc in these cases.
    
    Signed-off-by: Elise Lennion <elise.lennion@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/camera.c b/drivers/staging/greybus/camera.c
index 0c73445737b5..1c5b41ae6774 100644
--- a/drivers/staging/greybus/camera.c
+++ b/drivers/staging/greybus/camera.c
@@ -797,7 +797,7 @@ static int gb_camera_op_configure_streams(void *priv, unsigned int *nstreams,
 	if (gb_nstreams > GB_CAMERA_MAX_STREAMS)
 		return -EINVAL;
 
-	gb_streams = kzalloc(gb_nstreams * sizeof(*gb_streams), GFP_KERNEL);
+	gb_streams = kcalloc(gb_nstreams, sizeof(*gb_streams), GFP_KERNEL);
 	if (!gb_streams)
 		return -ENOMEM;
 
@@ -938,7 +938,7 @@ static ssize_t gb_camera_debugfs_configure_streams(struct gb_camera *gcam,
 		return ret;
 
 	/* For each stream to configure parse width, height and format */
-	streams = kzalloc(nstreams * sizeof(*streams), GFP_KERNEL);
+	streams = kcalloc(nstreams, sizeof(*streams), GFP_KERNEL);
 	if (!streams)
 		return -ENOMEM;
 

commit 9d3318f48ce383cdd261719f4fa95c979bdd7ce4
Author: Elise Lennion <elise.lennion@gmail.com>
Date:   Wed Oct 12 14:13:01 2016 -0300

    staging: greybus: camera: Replace blank spaces with tabstops.
    
    Fix checkpatch warning:
    
    WARNING: Statements should start on a tabstop
    
    Signed-off-by: Elise Lennion <elise.lennion@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/camera.c b/drivers/staging/greybus/camera.c
index d89a329a7b5f..0c73445737b5 100644
--- a/drivers/staging/greybus/camera.c
+++ b/drivers/staging/greybus/camera.c
@@ -1119,7 +1119,7 @@ static ssize_t gb_camera_debugfs_write(struct file *file,
 	char *kbuf;
 
 	if (len > 1024)
-	       return -EINVAL;
+		return -EINVAL;
 
 	kbuf = kmalloc(len + 1, GFP_KERNEL);
 	if (!kbuf)

commit cd7b701f52d27c2278669e4de5c911807be8c10c
Author: Elise Lennion <elise.lennion@gmail.com>
Date:   Wed Oct 12 14:11:31 2016 -0300

    staging: greybus: camera: Add blank lines after variable declarations.
    
    Fix checkpatch warning:
    
    WARNING: Missing a blank line after declarations
    
    Signed-off-by: Elise Lennion <elise.lennion@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/camera.c b/drivers/staging/greybus/camera.c
index 491bdd720c0c..d89a329a7b5f 100644
--- a/drivers/staging/greybus/camera.c
+++ b/drivers/staging/greybus/camera.c
@@ -289,6 +289,7 @@ static const int gb_camera_configure_streams_validate_response(
 
 	for (i = 0; i < resp->num_streams; i++) {
 		struct gb_camera_stream_config_response *cfg = &resp->config[i];
+
 		if (cfg->padding) {
 			gcam_err(gcam, "stream #%u padding != 0\n", i);
 			return -EIO;

commit ce35e9be62837d8242472264b511f9c27992adfa
Author: Eva Rachel Retuya <eraretuya@gmail.com>
Date:   Wed Sep 21 12:59:29 2016 +0800

    staging: greybus: camera: simplify NULL test
    
    Replace direct comparisons to NULL i.e. 'x == NULL' with '!x' for consistency.
    Coccinelle semantic patch used:
    
    @@
    identifier func;
    expression x;
    statement Z;
    @@
    
    x = func(...);
    
    if (
    (
    +       !
            x
    -       == NULL
    |
    +       !
    -       NULL ==
            x
    )
       ) Z
    
    Signed-off-by: Eva Rachel Retuya <eraretuya@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/camera.c b/drivers/staging/greybus/camera.c
index 46d2e8a9e490..491bdd720c0c 100644
--- a/drivers/staging/greybus/camera.c
+++ b/drivers/staging/greybus/camera.c
@@ -1121,7 +1121,7 @@ static ssize_t gb_camera_debugfs_write(struct file *file,
 	       return -EINVAL;
 
 	kbuf = kmalloc(len + 1, GFP_KERNEL);
-	if (kbuf == NULL)
+	if (!kbuf)
 		return -ENOMEM;
 
 	if (copy_from_user(kbuf, buf, len)) {

commit 948c6227e76ef2443b327a409dc8eced92b32bda
Author: Greg Kroah-Hartman <gregkh@google.com>
Date:   Fri Sep 9 09:47:01 2016 +0200

    staging: greybus: remove CONFIG_PM_RUNTIME from kernel_ver.h
    
    The last thing remaining in kernel_ver.h was the setting of
    CONFIG_PM_RUNTIME, which isn't needed in a in-tree implementation.  So
    remove the setting of this value, and the .h file entirely as that was
    the last thing left in it.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/camera.c b/drivers/staging/greybus/camera.c
index e1f3046105c1..46d2e8a9e490 100644
--- a/drivers/staging/greybus/camera.c
+++ b/drivers/staging/greybus/camera.c
@@ -1344,7 +1344,7 @@ static const struct greybus_bundle_id gb_camera_id_table[] = {
 	{ },
 };
 
-#ifdef CONFIG_PM_RUNTIME
+#ifdef CONFIG_PM
 static int gb_camera_suspend(struct device *dev)
 {
 	struct gb_bundle *bundle = to_gb_bundle(dev);

commit c9161d72b33ff5a3e43dd60c87adf113363866a1
Author: Jacopo Mondi <jacopo.mondi@linaro.org>
Date:   Fri Aug 12 10:05:41 2016 +0200

    greybus: camera: Remove support for legacy modules
    
    Remove support for module implementing legacy version of camera bandwidth
    requirements specifications, now that all available camera modules have
    been updated to use the new version
    
    Signed-off-by: Jacopo Mondi <jacopo.mondi@linaro.org>
    Reviewed-by: Laurent Pinchart <laurent.pinchart@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/camera.c b/drivers/staging/greybus/camera.c
index 94b67123c05b..e1f3046105c1 100644
--- a/drivers/staging/greybus/camera.c
+++ b/drivers/staging/greybus/camera.c
@@ -264,125 +264,35 @@ static int gb_camera_get_max_pkt_size(struct gb_camera *gcam,
 	return max_pkt_size;
 }
 
-/*
- * Temporary support for camera modules implementing legacy version
- * of camera specifications
- */
-static int gb_camera_configure_stream_translate_deprecated(
-			struct gb_camera *gcam,
-			void *module_resp,
-			struct gb_camera_configure_streams_response *resp)
-{
-	unsigned int i;
-	struct gb_camera_configure_streams_response_deprecated *dresp =
-		(struct gb_camera_configure_streams_response_deprecated *)
-		module_resp;
-
-	if (dresp->padding != 0) {
-		gcam_err(gcam, "legacy response padding != 0\n");
-		return -EIO;
-	}
-
-	resp->num_streams = dresp->num_streams;
-	resp->flags = dresp->flags;
-	resp->data_rate = dresp->bus_freq;
-
-	for (i = 0; i < dresp->num_streams; i++) {
-		const struct gb_camera_fmt_info *fmt_info;
-		struct gb_camera_stream_config_response *cfg;
-
-		if (dresp->config[i].padding ||
-		    dresp->config[i].max_pkt_size) {
-			gcam_err(gcam, "legacy stream #%u padding != 0\n", i);
-			return -EIO;
-		}
-
-		resp->config[i] = dresp->config[i];
-		cfg = &resp->config[i];
-
-		/*
-		 * As implementations of legacy version of camera protocol do
-		 * not provide the max_pkt_size attribute, re-calculate it on
-		 * AP side.
-		 */
-		fmt_info = gb_camera_get_format_info(cfg->format);
-		if (!fmt_info) {
-			gcam_err(gcam, "unsupported greybus image format %d\n",
-				 cfg->format);
-			return -EIO;
-		}
-
-		if (fmt_info->bpp == 0) {
-			cfg->max_pkt_size = cpu_to_le16(4096);
-		} else if (fmt_info->bpp > 0) {
-			unsigned int width = le16_to_cpu(cfg->width);
-
-			cfg->max_pkt_size = cpu_to_le32(width * fmt_info->bpp / 8);
-		}
-	}
-
-	return 0;
-}
-
 /*
  * Validate the stream configuration response verifying padding is correctly
  * set and the returned number of streams is supported
- *
- * FIXME: The function also checks which protocol version the camera module
- *	  implements and if it supports or not the new bandwidth requirements
- *	  definition parameters.
- *	  In case the camera implements the legacy version of protocol
- *	  specifications, it gets translated to the new one.
  */
-static int gb_camera_configure_streams_validate_response(
+static const int gb_camera_configure_streams_validate_response(
 		struct gb_camera *gcam,
-		void *module_resp,
-		struct gb_camera_configure_streams_response *ap_resp,
-		unsigned int resp_size,
+		struct gb_camera_configure_streams_response *resp,
 		unsigned int nstreams)
 {
-	struct gb_camera_configure_streams_response *resp;
 	unsigned int i;
-	unsigned int module_resp_size =
-			resp_size -
-			sizeof(struct gb_camera_stream_config_response) *
-			nstreams;
-
-	/* TODO: remove support for legacy camera modules */
-	if (module_resp_size == GB_CAMERA_CONFIGURE_STREAMS_DEPRECATED_SIZE)
-		return gb_camera_configure_stream_translate_deprecated(gcam,
-							module_resp, ap_resp);
-
-	if (module_resp_size != GB_CAMERA_CONFIGURE_STREAMS_SIZE) {
-		gcam_err(gcam, "unrecognized protocol version %u\n",
-			 module_resp_size);
-		return -EIO;
-	}
-
-	resp = (struct gb_camera_configure_streams_response *) module_resp;
-	*ap_resp = *resp;
 
 	/* Validate the returned response structure */
-	if (ap_resp->padding[0] || ap_resp->padding[1]) {
+	if (resp->padding[0] || resp->padding[1]) {
 		gcam_err(gcam, "response padding != 0\n");
 		return -EIO;
 	}
 
-	if (ap_resp->num_streams > nstreams) {
+	if (resp->num_streams > nstreams) {
 		gcam_err(gcam, "got #streams %u > request %u\n",
 			 resp->num_streams, nstreams);
 		return -EIO;
 	}
 
-	for (i = 0; i < ap_resp->num_streams; i++) {
+	for (i = 0; i < resp->num_streams; i++) {
 		struct gb_camera_stream_config_response *cfg = &resp->config[i];
-
 		if (cfg->padding) {
 			gcam_err(gcam, "stream #%u padding != 0\n", i);
 			return -EIO;
 		}
-
-		ap_resp->config[i] = *cfg;
 	}
 
 	return 0;
@@ -616,12 +526,10 @@ static int gb_camera_configure_streams(struct gb_camera *gcam,
 {
 	struct gb_camera_configure_streams_request *req;
 	struct gb_camera_configure_streams_response *resp;
-	void *module_resp;
 	unsigned int nstreams = *num_streams;
 	unsigned int i;
 	size_t req_size;
 	size_t resp_size;
-	size_t module_resp_size;
 	int ret;
 
 	if (nstreams > GB_CAMERA_MAX_STREAMS)
@@ -630,21 +538,11 @@ static int gb_camera_configure_streams(struct gb_camera *gcam,
 	req_size = sizeof(*req) + nstreams * sizeof(req->config[0]);
 	resp_size = sizeof(*resp) + nstreams * sizeof(resp->config[0]);
 
-	/*
-	 * FIXME: Reserve enough space for the deprecated version of the
-	 *	  configure_stream response, as it is bigger than the
-	 *	  newly defined one
-	 */
-	module_resp_size = GB_CAMERA_CONFIGURE_STREAMS_DEPRECATED_SIZE +
-			   nstreams * sizeof(resp->config[0]);
-
 	req = kmalloc(req_size, GFP_KERNEL);
 	resp = kmalloc(resp_size, GFP_KERNEL);
-	module_resp = kmalloc(module_resp_size, GFP_KERNEL);
-	if (!req || !resp || !module_resp) {
+	if (!req || !resp) {
 		kfree(req);
 		kfree(resp);
-		kfree(module_resp);
 		return -ENOMEM;
 	}
 
@@ -676,12 +574,12 @@ static int gb_camera_configure_streams(struct gb_camera *gcam,
 					     GB_CAMERA_TYPE_CONFIGURE_STREAMS,
 					     GB_OPERATION_FLAG_SHORT_RESPONSE,
 					     req, req_size,
-					     module_resp, &module_resp_size);
+					     resp, &resp_size);
 	if (ret < 0)
 		goto done;
 
-	ret = gb_camera_configure_streams_validate_response(gcam,
-			module_resp, resp, module_resp_size, nstreams);
+	ret = gb_camera_configure_streams_validate_response(gcam, resp,
+							    nstreams);
 	if (ret < 0)
 		goto done;
 
@@ -750,7 +648,6 @@ static int gb_camera_configure_streams(struct gb_camera *gcam,
 	mutex_unlock(&gcam->mutex);
 	kfree(req);
 	kfree(resp);
-	kfree(module_resp);
 	return ret;
 }
 

commit 127bada1a1951d9624c08eeab99234ced0df900e
Author: Jacopo Mondi <jacopo.mondi@linaro.org>
Date:   Wed Aug 10 09:08:19 2016 +0200

    greybus: camera: Remove reference to ara subdevice
    
    Remove last occurrence of "ara" term in camera driver.
    Replace reference to "ara subdevice" with "gmp subdevice"
    
    Signed-off-by: Jacopo Mondi <jacopo.mondi@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/camera.c b/drivers/staging/greybus/camera.c
index 0e7f64392bbd..94b67123c05b 100644
--- a/drivers/staging/greybus/camera.c
+++ b/drivers/staging/greybus/camera.c
@@ -848,7 +848,7 @@ static int gb_camera_request_handler(struct gb_operation *op)
 }
 
 /* -----------------------------------------------------------------------------
- * Interface with HOST ara camera.
+ * Interface with HOST gmp camera.
  */
 static unsigned int gb_camera_mbus_to_gb(enum v4l2_mbus_pixelcode mbus_code)
 {

commit 563c742adab959362aca106248b4ab24c4186217
Author: Gjorgji Rosikopulos <grosikopulos@mm-sol.com>
Date:   Wed Jul 27 11:47:01 2016 -0700

    greybus: camera: Rename debug and metadata mbus formats
    
    Change ARA prefix to GB_CAM for greyus camera specific
    formats.
    
    Change-Id: I1a0552516e8ea727c48085c59fc49f2409a89486
    Signed-off-by: Gjorgji Rosikopulos <grosikopulos@mm-sol.com>
    Signed-off-by: Blagovest Borisov Kolenichev <kolenichev_blagovest@projectara.com>
    Acked-by: Laurent Pinchart <laurent.pinchart@linaro.org>

diff --git a/drivers/staging/greybus/camera.c b/drivers/staging/greybus/camera.c
index e0719e2db4e6..0e7f64392bbd 100644
--- a/drivers/staging/greybus/camera.c
+++ b/drivers/staging/greybus/camera.c
@@ -113,12 +113,12 @@ static const struct gb_camera_fmt_info gb_fmt_info[] = {
 		.bpp	   = 0,
 	},
 	{
-		.mbus_code = V4L2_MBUS_FMT_ARA_METADATA_1X8,
+		.mbus_code = V4L2_MBUS_FMT_GB_CAM_METADATA_1X8,
 		.gb_format = 0x41,
 		.bpp	   = 0,
 	},
 	{
-		.mbus_code = V4L2_MBUS_FMT_ARA_DEBUG_DATA_1X8,
+		.mbus_code = V4L2_MBUS_FMT_GB_CAM_DEBUG_DATA_1X8,
 		.gb_format = 0x42,
 		.bpp	   = 0,
 	},

commit f88b94ec2a3b37e8f9fd20f8fb17d9e0a104fe1f
Author: Jacopo Mondi <jacopo.mondi@linaro.org>
Date:   Fri Jul 15 11:03:45 2016 +0200

    greybus: camera: Configure APB-A with new params
    
    Update the configuration supplied to APB-A to use new parameters, while
    keeping compatibility with legacy camera modules.
    Substitute hard-coded clock frequency with information provided by camera
    module, and retrieve the maximum CSI Long Packet length from the
    returned stream configuration.
    
    This patch requires APB-A csi-tx driver to be updated to comply with
    newly defined bandwidth requirements.
    
    Testing Done: preview, capture and video recording with updated csi-tx
    driver on APB-A side, and legacy white camera module firmware
    
    Signed-off-by: Jacopo Mondi <jacopo.mondi@linaro.org>
    Reviewed-by: Laurent Pinchart <laurent.pinchart@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/camera.c b/drivers/staging/greybus/camera.c
index 9cf0d4dcc9f2..e0719e2db4e6 100644
--- a/drivers/staging/greybus/camera.c
+++ b/drivers/staging/greybus/camera.c
@@ -220,6 +220,50 @@ static int gb_camera_operation_sync_flags(struct gb_connection *connection,
 	return ret;
 }
 
+static int gb_camera_get_max_pkt_size(struct gb_camera *gcam,
+		struct gb_camera_configure_streams_response *resp)
+{
+	unsigned int max_pkt_size = 0;
+	unsigned int i;
+
+	for (i = 0; i < resp->num_streams; i++) {
+		struct gb_camera_stream_config_response *cfg = &resp->config[i];
+		const struct gb_camera_fmt_info *fmt_info;
+		unsigned int pkt_size;
+
+		fmt_info = gb_camera_get_format_info(cfg->format);
+		if (!fmt_info) {
+			gcam_err(gcam, "unsupported greybus image format: %d\n",
+				 cfg->format);
+			return -EIO;
+		}
+
+		if (fmt_info->bpp == 0) {
+			pkt_size = le32_to_cpu(cfg->max_pkt_size);
+
+			if (pkt_size == 0) {
+				gcam_err(gcam,
+					 "Stream %u: invalid zero maximum packet size\n",
+					 i);
+				return -EIO;
+			}
+		} else {
+			pkt_size = le16_to_cpu(cfg->width) * fmt_info->bpp / 8;
+
+			if (pkt_size != le32_to_cpu(cfg->max_pkt_size)) {
+				gcam_err(gcam,
+					 "Stream %u: maximum packet size mismatch (%u/%u)\n",
+					 i, pkt_size, cfg->max_pkt_size);
+				return -EIO;
+			}
+		}
+
+		max_pkt_size = max(pkt_size, max_pkt_size);
+	}
+
+	return max_pkt_size;
+}
+
 /*
  * Temporary support for camera modules implementing legacy version
  * of camera specifications
@@ -409,8 +453,8 @@ struct ap_csi_config_request {
 #define GB_CAMERA_CSI_FLAG_CLOCK_CONTINUOUS 0x01
 	__u8 num_lanes;
 	__u8 padding;
-	__le32 bus_freq;
-	__le32 lines_per_second;
+	__le32 csi_clk_freq;
+	__le32 max_pkt_size;
 } __packed;
 
 /*
@@ -418,14 +462,18 @@ struct ap_csi_config_request {
  * requirements.
  */
 #define GB_CAMERA_CSI_NUM_DATA_LANES		4
-#define GB_CAMERA_LINES_PER_SECOND		(1280 * 30)
+
+#define GB_CAMERA_CSI_CLK_FREQ_MAX		999000000U
+#define GB_CAMERA_CSI_CLK_FREQ_MIN		100000000U
+#define GB_CAMERA_CSI_CLK_FREQ_MARGIN		150000000U
 
 static int gb_camera_setup_data_connection(struct gb_camera *gcam,
-		const struct gb_camera_configure_streams_response *resp,
+		struct gb_camera_configure_streams_response *resp,
 		struct gb_camera_csi_params *csi_params)
 {
 	struct ap_csi_config_request csi_cfg;
 	struct gb_connection *conn;
+	unsigned int clk_freq;
 	int ret;
 
 	/*
@@ -451,34 +499,40 @@ static int gb_camera_setup_data_connection(struct gb_camera *gcam,
 		goto error_conn_disable;
 
 	/*
-	 * Configure the APB1 CSI transmitter with hard-coded bus frequency,
-	 * lanes number and lines per second.
+	 * Configure the APB-A CSI-2 transmitter.
 	 *
-	 * TODO: Use the data rate and size information reported by camera
-	 * module to compute the required CSI bandwidth, and configure the
-	 * CSI receiver on AP side, and the CSI transmitter on APB1 side
-	 * accordingly.
+	 * Hardcode the number of lanes to 4 and compute the bus clock frequency
+	 * based on the module bandwidth requirements with a safety margin.
 	 */
 	memset(&csi_cfg, 0, sizeof(csi_cfg));
 	csi_cfg.csi_id = 1;
 	csi_cfg.flags = 0;
 	csi_cfg.num_lanes = GB_CAMERA_CSI_NUM_DATA_LANES;
-	csi_cfg.bus_freq = cpu_to_le32(960000000);
-	csi_cfg.lines_per_second = GB_CAMERA_LINES_PER_SECOND;
+
+	clk_freq = resp->data_rate / 2 / GB_CAMERA_CSI_NUM_DATA_LANES;
+	clk_freq = clamp(clk_freq + GB_CAMERA_CSI_CLK_FREQ_MARGIN,
+			 GB_CAMERA_CSI_CLK_FREQ_MIN,
+			 GB_CAMERA_CSI_CLK_FREQ_MAX);
+	csi_cfg.csi_clk_freq = clk_freq;
+
+	ret = gb_camera_get_max_pkt_size(gcam, resp);
+	if (ret < 0) {
+		ret = -EIO;
+		goto error_power;
+	}
+	csi_cfg.max_pkt_size = ret;
 
 	ret = gb_hd_output(gcam->connection->hd, &csi_cfg,
 			   sizeof(csi_cfg),
 			   GB_APB_REQUEST_CSI_TX_CONTROL, false);
-
 	if (ret < 0) {
 		gcam_err(gcam, "failed to start the CSI transmitter\n");
 		goto error_power;
 	}
 
 	if (csi_params) {
+		csi_params->clk_freq = csi_cfg.csi_clk_freq;
 		csi_params->num_lanes = csi_cfg.num_lanes;
-		/* Transmitting two bits per cycle. (DDR clock) */
-		csi_params->clk_freq = csi_cfg.bus_freq / 2;
 	}
 
 	return 0;
@@ -664,29 +718,31 @@ static int gb_camera_configure_streams(struct gb_camera *gcam,
 		gb_pm_runtime_put_noidle(gcam->bundle);
 	}
 
-	if (resp->num_streams) {
-		/*
-		 * Make sure the bundle won't be suspended until streams get
-		 * unconfigured after the stream is configured successfully
-		 */
-		gb_pm_runtime_get_noresume(gcam->bundle);
-
-		ret = gb_camera_setup_data_connection(gcam, resp, csi_params);
-		if (ret < 0) {
-			memset(req, 0, sizeof(*req));
-			gb_operation_sync(gcam->connection,
-					  GB_CAMERA_TYPE_CONFIGURE_STREAMS,
-					  req, sizeof(*req),
-					  resp, sizeof(*resp));
-			*flags = 0;
-			*num_streams = 0;
-			gb_pm_runtime_put_noidle(gcam->bundle);
-			goto done;
-		}
+	if (resp->num_streams == 0)
+		goto done;
+
+	/*
+	 * Make sure the bundle won't be suspended until streams get
+	 * unconfigured after the stream is configured successfully
+	 */
+	gb_pm_runtime_get_noresume(gcam->bundle);
 
-		gcam->state = GB_CAMERA_STATE_CONFIGURED;
+	/* Setup CSI-2 connection from APB-A to AP */
+	ret = gb_camera_setup_data_connection(gcam, resp, csi_params);
+	if (ret < 0) {
+		memset(req, 0, sizeof(*req));
+		gb_operation_sync(gcam->connection,
+				  GB_CAMERA_TYPE_CONFIGURE_STREAMS,
+				  req, sizeof(*req),
+				  resp, sizeof(*resp));
+		*flags = 0;
+		*num_streams = 0;
+		gb_pm_runtime_put_noidle(gcam->bundle);
+		goto done;
 	}
 
+	gcam->state = GB_CAMERA_STATE_CONFIGURED;
+
 done:
 	gb_pm_runtime_put_autosuspend(gcam->bundle);
 

commit d165a618a14c8871f8e14090791298e1b2ef8231
Author: Jacopo Mondi <jacopo.mondi@linaro.org>
Date:   Fri Jul 15 11:03:44 2016 +0200

    greybus: camera: Update Configure Streams Response
    
    As camera specification gets updated, and Configure Stream Response
    payload modified, define here the new response structure.
    In order to not break non up-to-date camera modules, keep the existing
    structure and add the _deprecated suffix to it.
    
    Add the size of both new and old structure in order to discriminate
    dynamically which version of Camera Specification the camera module
    implements and translate deprecated version of configure_streams response
    in the new one.
    
    In order not to break camera functionalities, for testing purposes,
    hard-code values the APB-A CSI Tx driver still requires for proper
    interface configuration (lines_per_second and num_lanes)
    
    Testing Done: Preview, capture and video recording with white camera
    module and APB-A with legacy firmware implementations
    
    Signed-off-by: Jacopo Mondi <jacopo.mondi@linaro.org>
    Reviewed-by: Laurent Pinchart <laurent.pinchart@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/camera.c b/drivers/staging/greybus/camera.c
index ceffe14201d1..9cf0d4dcc9f2 100644
--- a/drivers/staging/greybus/camera.c
+++ b/drivers/staging/greybus/camera.c
@@ -164,6 +164,18 @@ static const struct gb_camera_fmt_info gb_fmt_info[] = {
 	},
 };
 
+static const struct gb_camera_fmt_info *gb_camera_get_format_info(u16 gb_fmt)
+{
+	unsigned int i;
+
+	for (i = 0; i < ARRAY_SIZE(gb_fmt_info); i++) {
+		if (gb_fmt_info[i].gb_format == gb_fmt)
+			return &gb_fmt_info[i];
+	}
+
+	return NULL;
+}
+
 #define ES2_APB_CDSI0_CPORT		16
 #define ES2_APB_CDSI1_CPORT		17
 
@@ -208,6 +220,130 @@ static int gb_camera_operation_sync_flags(struct gb_connection *connection,
 	return ret;
 }
 
+/*
+ * Temporary support for camera modules implementing legacy version
+ * of camera specifications
+ */
+static int gb_camera_configure_stream_translate_deprecated(
+			struct gb_camera *gcam,
+			void *module_resp,
+			struct gb_camera_configure_streams_response *resp)
+{
+	unsigned int i;
+	struct gb_camera_configure_streams_response_deprecated *dresp =
+		(struct gb_camera_configure_streams_response_deprecated *)
+		module_resp;
+
+	if (dresp->padding != 0) {
+		gcam_err(gcam, "legacy response padding != 0\n");
+		return -EIO;
+	}
+
+	resp->num_streams = dresp->num_streams;
+	resp->flags = dresp->flags;
+	resp->data_rate = dresp->bus_freq;
+
+	for (i = 0; i < dresp->num_streams; i++) {
+		const struct gb_camera_fmt_info *fmt_info;
+		struct gb_camera_stream_config_response *cfg;
+
+		if (dresp->config[i].padding ||
+		    dresp->config[i].max_pkt_size) {
+			gcam_err(gcam, "legacy stream #%u padding != 0\n", i);
+			return -EIO;
+		}
+
+		resp->config[i] = dresp->config[i];
+		cfg = &resp->config[i];
+
+		/*
+		 * As implementations of legacy version of camera protocol do
+		 * not provide the max_pkt_size attribute, re-calculate it on
+		 * AP side.
+		 */
+		fmt_info = gb_camera_get_format_info(cfg->format);
+		if (!fmt_info) {
+			gcam_err(gcam, "unsupported greybus image format %d\n",
+				 cfg->format);
+			return -EIO;
+		}
+
+		if (fmt_info->bpp == 0) {
+			cfg->max_pkt_size = cpu_to_le16(4096);
+		} else if (fmt_info->bpp > 0) {
+			unsigned int width = le16_to_cpu(cfg->width);
+
+			cfg->max_pkt_size = cpu_to_le32(width * fmt_info->bpp / 8);
+		}
+	}
+
+	return 0;
+}
+
+/*
+ * Validate the stream configuration response verifying padding is correctly
+ * set and the returned number of streams is supported
+ *
+ * FIXME: The function also checks which protocol version the camera module
+ *	  implements and if it supports or not the new bandwidth requirements
+ *	  definition parameters.
+ *	  In case the camera implements the legacy version of protocol
+ *	  specifications, it gets translated to the new one.
+ */
+static int gb_camera_configure_streams_validate_response(
+		struct gb_camera *gcam,
+		void *module_resp,
+		struct gb_camera_configure_streams_response *ap_resp,
+		unsigned int resp_size,
+		unsigned int nstreams)
+{
+	struct gb_camera_configure_streams_response *resp;
+	unsigned int i;
+	unsigned int module_resp_size =
+			resp_size -
+			sizeof(struct gb_camera_stream_config_response) *
+			nstreams;
+
+	/* TODO: remove support for legacy camera modules */
+	if (module_resp_size == GB_CAMERA_CONFIGURE_STREAMS_DEPRECATED_SIZE)
+		return gb_camera_configure_stream_translate_deprecated(gcam,
+							module_resp, ap_resp);
+
+	if (module_resp_size != GB_CAMERA_CONFIGURE_STREAMS_SIZE) {
+		gcam_err(gcam, "unrecognized protocol version %u\n",
+			 module_resp_size);
+		return -EIO;
+	}
+
+	resp = (struct gb_camera_configure_streams_response *) module_resp;
+	*ap_resp = *resp;
+
+	/* Validate the returned response structure */
+	if (ap_resp->padding[0] || ap_resp->padding[1]) {
+		gcam_err(gcam, "response padding != 0\n");
+		return -EIO;
+	}
+
+	if (ap_resp->num_streams > nstreams) {
+		gcam_err(gcam, "got #streams %u > request %u\n",
+			 resp->num_streams, nstreams);
+		return -EIO;
+	}
+
+	for (i = 0; i < ap_resp->num_streams; i++) {
+		struct gb_camera_stream_config_response *cfg = &resp->config[i];
+
+		if (cfg->padding) {
+			gcam_err(gcam, "stream #%u padding != 0\n", i);
+			return -EIO;
+		}
+
+		ap_resp->config[i] = *cfg;
+	}
+
+	return 0;
+}
+
 /* -----------------------------------------------------------------------------
  * Hardware Configuration
  */
@@ -318,9 +454,10 @@ static int gb_camera_setup_data_connection(struct gb_camera *gcam,
 	 * Configure the APB1 CSI transmitter with hard-coded bus frequency,
 	 * lanes number and lines per second.
 	 *
-	 * TODO: use the clocking and size informations reported by camera module
-	 * to compute the required CSI bandwidth, and configure the CSI receiver
-	 * on AP side, and the CSI transmitter on APB1 side accordingly.
+	 * TODO: Use the data rate and size information reported by camera
+	 * module to compute the required CSI bandwidth, and configure the
+	 * CSI receiver on AP side, and the CSI transmitter on APB1 side
+	 * accordingly.
 	 */
 	memset(&csi_cfg, 0, sizeof(csi_cfg));
 	csi_cfg.csi_id = 1;
@@ -425,10 +562,12 @@ static int gb_camera_configure_streams(struct gb_camera *gcam,
 {
 	struct gb_camera_configure_streams_request *req;
 	struct gb_camera_configure_streams_response *resp;
+	void *module_resp;
 	unsigned int nstreams = *num_streams;
 	unsigned int i;
 	size_t req_size;
 	size_t resp_size;
+	size_t module_resp_size;
 	int ret;
 
 	if (nstreams > GB_CAMERA_MAX_STREAMS)
@@ -437,11 +576,21 @@ static int gb_camera_configure_streams(struct gb_camera *gcam,
 	req_size = sizeof(*req) + nstreams * sizeof(req->config[0]);
 	resp_size = sizeof(*resp) + nstreams * sizeof(resp->config[0]);
 
+	/*
+	 * FIXME: Reserve enough space for the deprecated version of the
+	 *	  configure_stream response, as it is bigger than the
+	 *	  newly defined one
+	 */
+	module_resp_size = GB_CAMERA_CONFIGURE_STREAMS_DEPRECATED_SIZE +
+			   nstreams * sizeof(resp->config[0]);
+
 	req = kmalloc(req_size, GFP_KERNEL);
 	resp = kmalloc(resp_size, GFP_KERNEL);
-	if (!req || !resp) {
+	module_resp = kmalloc(module_resp_size, GFP_KERNEL);
+	if (!req || !resp || !module_resp) {
 		kfree(req);
 		kfree(resp);
+		kfree(module_resp);
 		return -ENOMEM;
 	}
 
@@ -469,24 +618,18 @@ static int gb_camera_configure_streams(struct gb_camera *gcam,
 		goto done;
 	}
 
-	ret = gb_operation_sync(gcam->connection,
-				GB_CAMERA_TYPE_CONFIGURE_STREAMS,
-				req, req_size, resp, resp_size);
+	ret = gb_camera_operation_sync_flags(gcam->connection,
+					     GB_CAMERA_TYPE_CONFIGURE_STREAMS,
+					     GB_OPERATION_FLAG_SHORT_RESPONSE,
+					     req, req_size,
+					     module_resp, &module_resp_size);
 	if (ret < 0)
 		goto done;
 
-	if (resp->num_streams > nstreams) {
-		gcam_dbg(gcam, "got #streams %u > request %u\n",
-			 resp->num_streams, nstreams);
-		ret = -EIO;
-		goto done;
-	}
-
-	if (resp->padding != 0) {
-		gcam_dbg(gcam, "response padding != 0");
-		ret = -EIO;
+	ret = gb_camera_configure_streams_validate_response(gcam,
+			module_resp, resp, module_resp_size, nstreams);
+	if (ret < 0)
 		goto done;
-	}
 
 	*flags = resp->flags;
 	*num_streams = resp->num_streams;
@@ -501,12 +644,6 @@ static int gb_camera_configure_streams(struct gb_camera *gcam,
 		streams[i].dt[0] = cfg->data_type[0];
 		streams[i].dt[1] = cfg->data_type[1];
 		streams[i].max_size = le32_to_cpu(cfg->max_size);
-
-		if (cfg->padding[0] || cfg->padding[1] || cfg->padding[2]) {
-			gcam_dbg(gcam, "stream #%u padding != 0", i);
-			ret = -EIO;
-			goto done;
-		}
 	}
 
 	if ((resp->flags & GB_CAMERA_CONFIGURE_STREAMS_ADJUSTED) ||
@@ -557,6 +694,7 @@ static int gb_camera_configure_streams(struct gb_camera *gcam,
 	mutex_unlock(&gcam->mutex);
 	kfree(req);
 	kfree(resp);
+	kfree(module_resp);
 	return ret;
 }
 

commit 24f9a6e4942d7a8b15a1bac9a96a605a433b9478
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Fri Jul 15 11:03:43 2016 +0200

    greybus: camera: Hardcode the APB-A CSI-2 TX parameters
    
    Camera modules will stop reporting the number of lines per second,
    hardcode the parameter in the driver until the APB-A CSI-2 TX
    configuration protocol gets updated as well to use a more appropriate
    form of bandwidth information.
    
    The number of data lanes is also hardcoded as it should not depend on
    the module's CSI-2 bus configuration.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/camera.c b/drivers/staging/greybus/camera.c
index 9d9746f434e4..ceffe14201d1 100644
--- a/drivers/staging/greybus/camera.c
+++ b/drivers/staging/greybus/camera.c
@@ -277,6 +277,13 @@ struct ap_csi_config_request {
 	__le32 lines_per_second;
 } __packed;
 
+/*
+ * TODO: Compute the number of lanes dynamically based on bandwidth
+ * requirements.
+ */
+#define GB_CAMERA_CSI_NUM_DATA_LANES		4
+#define GB_CAMERA_LINES_PER_SECOND		(1280 * 30)
+
 static int gb_camera_setup_data_connection(struct gb_camera *gcam,
 		const struct gb_camera_configure_streams_response *resp,
 		struct gb_camera_csi_params *csi_params)
@@ -308,8 +315,8 @@ static int gb_camera_setup_data_connection(struct gb_camera *gcam,
 		goto error_conn_disable;
 
 	/*
-	 * Configure the APB1 CSI transmitter using the lines count reported by
-	 * the  camera module, but with hard-coded bus frequency and lanes number.
+	 * Configure the APB1 CSI transmitter with hard-coded bus frequency,
+	 * lanes number and lines per second.
 	 *
 	 * TODO: use the clocking and size informations reported by camera module
 	 * to compute the required CSI bandwidth, and configure the CSI receiver
@@ -318,9 +325,9 @@ static int gb_camera_setup_data_connection(struct gb_camera *gcam,
 	memset(&csi_cfg, 0, sizeof(csi_cfg));
 	csi_cfg.csi_id = 1;
 	csi_cfg.flags = 0;
-	csi_cfg.num_lanes = resp->num_lanes;
+	csi_cfg.num_lanes = GB_CAMERA_CSI_NUM_DATA_LANES;
 	csi_cfg.bus_freq = cpu_to_le32(960000000);
-	csi_cfg.lines_per_second = resp->lines_per_second;
+	csi_cfg.lines_per_second = GB_CAMERA_LINES_PER_SECOND;
 
 	ret = gb_hd_output(gcam->connection->hd, &csi_cfg,
 			   sizeof(csi_cfg),
@@ -335,7 +342,6 @@ static int gb_camera_setup_data_connection(struct gb_camera *gcam,
 		csi_params->num_lanes = csi_cfg.num_lanes;
 		/* Transmitting two bits per cycle. (DDR clock) */
 		csi_params->clk_freq = csi_cfg.bus_freq / 2;
-		csi_params->lines_per_second = csi_cfg.lines_per_second;
 	}
 
 	return 0;

commit fdf73c00c8872f6f59730955d54b2cdc963e2485
Author: Jacopo Mondi <jacopo.mondi@linaro.org>
Date:   Fri Jul 15 11:03:42 2016 +0200

    greybus: camera: Add wrapper for sync operation with flags
    
    The greybus operation core synchronous operation call doesn't support
    operation flags. Create a new synchronous operation wrapper with flags,
    and modify the capabilities operation implementation to use it.
    
    The code could be later moved to the greybus core if other drivers have
    a similar need.
    
    Signed-off-by: Jacopo Mondi <jacopo.mondi@linaro.org>
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/camera.c b/drivers/staging/greybus/camera.c
index 7835ed78570a..9d9746f434e4 100644
--- a/drivers/staging/greybus/camera.c
+++ b/drivers/staging/greybus/camera.c
@@ -173,6 +173,41 @@ static const struct gb_camera_fmt_info gb_fmt_info[] = {
 #define gcam_info(gcam, format...)	dev_info(&gcam->bundle->dev, format)
 #define gcam_err(gcam, format...)	dev_err(&gcam->bundle->dev, format)
 
+static int gb_camera_operation_sync_flags(struct gb_connection *connection,
+					  int type, unsigned int flags,
+					  void *request, size_t request_size,
+					  void *response, size_t *response_size)
+{
+	struct gb_operation *operation;
+	int ret;
+
+	operation = gb_operation_create_flags(connection, type, request_size,
+					      *response_size, flags,
+					      GFP_KERNEL);
+	if (!operation)
+		return  -ENOMEM;
+
+	if (request_size)
+		memcpy(operation->request->payload, request, request_size);
+
+	ret = gb_operation_request_send_sync(operation);
+	if (ret) {
+		dev_err(&connection->hd->dev,
+			"%s: synchronous operation of type 0x%02x failed: %d\n",
+			connection->name, type, ret);
+	} else {
+		*response_size = operation->response->payload_size;
+
+		if (operation->response->payload_size)
+			memcpy(response, operation->response->payload,
+			       operation->response->payload_size);
+	}
+
+	gb_operation_put(operation);
+
+	return ret;
+}
+
 /* -----------------------------------------------------------------------------
  * Hardware Configuration
  */
@@ -347,7 +382,6 @@ static void gb_camera_teardown_data_connection(struct gb_camera *gcam)
 static int gb_camera_capabilities(struct gb_camera *gcam,
 				  u8 *capabilities, size_t *size)
 {
-	struct gb_operation *op = NULL;
 	int ret;
 
 	ret = gb_pm_runtime_get_sync(gcam->bundle);
@@ -361,28 +395,16 @@ static int gb_camera_capabilities(struct gb_camera *gcam,
 		goto done;
 	}
 
-	op = gb_operation_create_flags(gcam->connection,
-				       GB_CAMERA_TYPE_CAPABILITIES, 0, *size,
-				       GB_OPERATION_FLAG_SHORT_RESPONSE,
-				       GFP_KERNEL);
-	if (!op) {
-		ret = -ENOMEM;
-		goto done;
-	}
-
-	ret = gb_operation_request_send_sync(op);
-	if (ret) {
+	ret = gb_camera_operation_sync_flags(gcam->connection,
+					     GB_CAMERA_TYPE_CAPABILITIES,
+					     GB_OPERATION_FLAG_SHORT_RESPONSE,
+					     NULL, 0,
+					     (void *)capabilities, size);
+	if (ret)
 		gcam_err(gcam, "failed to retrieve capabilities: %d\n", ret);
-		goto done;
-	}
-
-	memcpy(capabilities, op->response->payload, op->response->payload_size);
-	*size = op->response->payload_size;
 
 done:
 	mutex_unlock(&gcam->mutex);
-	if (op)
-		gb_operation_put(op);
 
 	gb_pm_runtime_put_autosuspend(gcam->bundle);
 

commit 6cc270483c550f1d3f7098bb7fb0de20537947a2
Author: Jacopo Mondi <jacopo.mondi@linaro.org>
Date:   Fri Jul 15 11:03:41 2016 +0200

    greybus: camera: Add bpp to Greybus Format description
    
    Add the bytes per pixel value to the structure describing a Greybus
    Protocol Image Format.
    The bpp information will be used to compute the length in bytes of a
    line of pixel data
    
    Signed-off-by: Jacopo Mondi <jacopo.mondi@linaro.org>
    Reviewed-by: Gjorgji Rosikopulos <grosikopulos@mm-sol.com>
    Reviewed-by: Laurent Pinchart <laurent.pinchart@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/camera.c b/drivers/staging/greybus/camera.c
index bdceb77200c6..7835ed78570a 100644
--- a/drivers/staging/greybus/camera.c
+++ b/drivers/staging/greybus/camera.c
@@ -74,76 +74,93 @@ struct gb_camera_stream_config {
 	unsigned int max_size;
 };
 
-struct gb_camera_fmt_map {
+struct gb_camera_fmt_info {
 	enum v4l2_mbus_pixelcode mbus_code;
 	unsigned int gb_format;
+	unsigned int bpp;
 };
 
 /* GB format to media code map */
-static const struct gb_camera_fmt_map mbus_to_gbus_format[] = {
+static const struct gb_camera_fmt_info gb_fmt_info[] = {
 	{
 		.mbus_code = V4L2_MBUS_FMT_UYVY8_1X16,
 		.gb_format = 0x01,
+		.bpp	   = 16,
 	},
 	{
 		.mbus_code = V4L2_MBUS_FMT_NV12_1x8,
 		.gb_format = 0x12,
+		.bpp	   = 12,
 	},
 	{
 		.mbus_code = V4L2_MBUS_FMT_NV21_1x8,
 		.gb_format = 0x13,
+		.bpp	   = 12,
 	},
 	{
 		.mbus_code = V4L2_MBUS_FMT_YU12_1x8,
 		.gb_format = 0x16,
+		.bpp	   = 12,
 	},
 	{
 		.mbus_code = V4L2_MBUS_FMT_YV12_1x8,
 		.gb_format = 0x17,
+		.bpp	   = 12,
 	},
 	{
 		.mbus_code = V4L2_MBUS_FMT_JPEG_1X8,
 		.gb_format = 0x40,
+		.bpp	   = 0,
 	},
 	{
 		.mbus_code = V4L2_MBUS_FMT_ARA_METADATA_1X8,
 		.gb_format = 0x41,
+		.bpp	   = 0,
 	},
 	{
 		.mbus_code = V4L2_MBUS_FMT_ARA_DEBUG_DATA_1X8,
 		.gb_format = 0x42,
+		.bpp	   = 0,
 	},
 	{
 		.mbus_code = V4L2_MBUS_FMT_SBGGR10_1X10,
 		.gb_format = 0x80,
+		.bpp	   = 10,
 	},
 	{
 		.mbus_code = V4L2_MBUS_FMT_SGBRG10_1X10,
 		.gb_format = 0x81,
+		.bpp	   = 10,
 	},
 	{
 		.mbus_code = V4L2_MBUS_FMT_SGRBG10_1X10,
 		.gb_format = 0x82,
+		.bpp	   = 10,
 	},
 	{
 		.mbus_code = V4L2_MBUS_FMT_SRGGB10_1X10,
 		.gb_format = 0x83,
+		.bpp	   = 10,
 	},
 	{
 		.mbus_code = V4L2_MBUS_FMT_SBGGR12_1X12,
 		.gb_format = 0x84,
+		.bpp	   = 12,
 	},
 	{
 		.mbus_code = V4L2_MBUS_FMT_SGBRG12_1X12,
 		.gb_format = 0x85,
+		.bpp	   = 12,
 	},
 	{
 		.mbus_code = V4L2_MBUS_FMT_SGRBG12_1X12,
 		.gb_format = 0x86,
+		.bpp	   = 12,
 	},
 	{
 		.mbus_code = V4L2_MBUS_FMT_SRGGB12_1X12,
 		.gb_format = 0x87,
+		.bpp	   = 12,
 	},
 };
 
@@ -615,22 +632,22 @@ static unsigned int gb_camera_mbus_to_gb(enum v4l2_mbus_pixelcode mbus_code)
 {
 	unsigned int i;
 
-	for (i = 0; i < ARRAY_SIZE(mbus_to_gbus_format); i++) {
-		if (mbus_to_gbus_format[i].mbus_code == mbus_code)
-			return mbus_to_gbus_format[i].gb_format;
+	for (i = 0; i < ARRAY_SIZE(gb_fmt_info); i++) {
+		if (gb_fmt_info[i].mbus_code == mbus_code)
+			return gb_fmt_info[i].gb_format;
 	}
-	return mbus_to_gbus_format[0].gb_format;
+	return gb_fmt_info[0].gb_format;
 }
 
 static enum v4l2_mbus_pixelcode gb_camera_gb_to_mbus(u16 gb_fmt)
 {
 	unsigned int i;
 
-	for (i = 0; i < ARRAY_SIZE(mbus_to_gbus_format); i++) {
-		if (mbus_to_gbus_format[i].gb_format == gb_fmt)
-			return mbus_to_gbus_format[i].mbus_code;
+	for (i = 0; i < ARRAY_SIZE(gb_fmt_info); i++) {
+		if (gb_fmt_info[i].gb_format == gb_fmt)
+			return gb_fmt_info[i].mbus_code;
 	}
-	return mbus_to_gbus_format[0].mbus_code;
+	return gb_fmt_info[0].mbus_code;
 }
 
 static ssize_t gb_camera_op_capabilities(void *priv, char *data, size_t len)

commit 211634f2ca165947e37ba8b259c046a2e07b5f3c
Author: David Lin <dtwlin@google.com>
Date:   Thu Jul 14 15:13:00 2016 -0500

    greybus: camera: add runtime pm support
    
    Add runtime pm support to camera protocol device class driver.
    
    Testing Done:
     - Make sure white camera module is able to runtime suspend and resume
       when the camera is being used
    
    Signed-off-by: David Lin <dtwlin@google.com>
    Signed-off-by: Axel Haslam <ahaslam@baylibre.com>
    Reviewed-by: Laurent Pinchart <laurent.pinchart@linaro.org>
    Signed-off-by: Alex Elder <elder@linaro.org>

diff --git a/drivers/staging/greybus/camera.c b/drivers/staging/greybus/camera.c
index ce0ff759f3ce..bdceb77200c6 100644
--- a/drivers/staging/greybus/camera.c
+++ b/drivers/staging/greybus/camera.c
@@ -333,6 +333,10 @@ static int gb_camera_capabilities(struct gb_camera *gcam,
 	struct gb_operation *op = NULL;
 	int ret;
 
+	ret = gb_pm_runtime_get_sync(gcam->bundle);
+	if (ret)
+		return ret;
+
 	mutex_lock(&gcam->mutex);
 
 	if (!gcam->connection) {
@@ -362,6 +366,9 @@ static int gb_camera_capabilities(struct gb_camera *gcam,
 	mutex_unlock(&gcam->mutex);
 	if (op)
 		gb_operation_put(op);
+
+	gb_pm_runtime_put_autosuspend(gcam->bundle);
+
 	return ret;
 }
 
@@ -408,6 +415,10 @@ static int gb_camera_configure_streams(struct gb_camera *gcam,
 
 	mutex_lock(&gcam->mutex);
 
+	ret = gb_pm_runtime_get_sync(gcam->bundle);
+	if (ret)
+		goto done_skip_pm_put;
+
 	if (!gcam->connection) {
 		ret = -EINVAL;
 		goto done;
@@ -460,9 +471,24 @@ static int gb_camera_configure_streams(struct gb_camera *gcam,
 	if (gcam->state == GB_CAMERA_STATE_CONFIGURED) {
 		gb_camera_teardown_data_connection(gcam);
 		gcam->state = GB_CAMERA_STATE_UNCONFIGURED;
+
+		/*
+		 * When unconfiguring streams release the PM runtime reference
+		 * that was acquired when streams were configured. The bundle
+		 * won't be suspended until the PM runtime reference acquired at
+		 * the beginning of this function gets released right before
+		 * returning.
+		 */
+		gb_pm_runtime_put_noidle(gcam->bundle);
 	}
 
 	if (resp->num_streams) {
+		/*
+		 * Make sure the bundle won't be suspended until streams get
+		 * unconfigured after the stream is configured successfully
+		 */
+		gb_pm_runtime_get_noresume(gcam->bundle);
+
 		ret = gb_camera_setup_data_connection(gcam, resp, csi_params);
 		if (ret < 0) {
 			memset(req, 0, sizeof(*req));
@@ -472,6 +498,7 @@ static int gb_camera_configure_streams(struct gb_camera *gcam,
 					  resp, sizeof(*resp));
 			*flags = 0;
 			*num_streams = 0;
+			gb_pm_runtime_put_noidle(gcam->bundle);
 			goto done;
 		}
 
@@ -479,6 +506,9 @@ static int gb_camera_configure_streams(struct gb_camera *gcam,
 	}
 
 done:
+	gb_pm_runtime_put_autosuspend(gcam->bundle);
+
+done_skip_pm_put:
 	mutex_unlock(&gcam->mutex);
 	kfree(req);
 	kfree(resp);
@@ -1150,6 +1180,8 @@ static int gb_camera_probe(struct gb_bundle *bundle,
 
 	greybus_set_drvdata(bundle, gcam);
 
+	gb_pm_runtime_put_autosuspend(gcam->bundle);
+
 	return 0;
 
 error:
@@ -1161,6 +1193,11 @@ static int gb_camera_probe(struct gb_bundle *bundle,
 static void gb_camera_disconnect(struct gb_bundle *bundle)
 {
 	struct gb_camera *gcam = greybus_get_drvdata(bundle);
+	int ret;
+
+	ret = gb_pm_runtime_get_sync(bundle);
+	if (ret)
+		gb_pm_runtime_get_noresume(bundle);
 
 	gb_camera_cleanup(gcam);
 	gb_camera_unregister(&gcam->module);
@@ -1171,11 +1208,55 @@ static const struct greybus_bundle_id gb_camera_id_table[] = {
 	{ },
 };
 
+#ifdef CONFIG_PM_RUNTIME
+static int gb_camera_suspend(struct device *dev)
+{
+	struct gb_bundle *bundle = to_gb_bundle(dev);
+	struct gb_camera *gcam = greybus_get_drvdata(bundle);
+
+	if (gcam->data_connection)
+		gb_connection_disable(gcam->data_connection);
+
+	gb_connection_disable(gcam->connection);
+
+	return 0;
+}
+
+static int gb_camera_resume(struct device *dev)
+{
+	struct gb_bundle *bundle = to_gb_bundle(dev);
+	struct gb_camera *gcam = greybus_get_drvdata(bundle);
+	int ret;
+
+	ret = gb_connection_enable(gcam->connection);
+	if (ret) {
+		gcam_err(gcam, "failed to enable connection: %d\n", ret);
+		return ret;
+	}
+
+	if (gcam->data_connection) {
+		ret = gb_connection_enable(gcam->data_connection);
+		if (ret) {
+			gcam_err(gcam,
+				 "failed to enable data connection: %d\n", ret);
+			return ret;
+		}
+	}
+
+	return 0;
+}
+#endif
+
+static const struct dev_pm_ops gb_camera_pm_ops = {
+	SET_RUNTIME_PM_OPS(gb_camera_suspend, gb_camera_resume, NULL)
+};
+
 static struct greybus_driver gb_camera_driver = {
 	.name		= "camera",
 	.probe		= gb_camera_probe,
 	.disconnect	= gb_camera_disconnect,
 	.id_table	= gb_camera_id_table,
+	.driver.pm	= &gb_camera_pm_ops,
 };
 
 module_greybus_driver(gb_camera_driver);

commit 80b3982b8d1ca463963b9d2d406098c18add2baf
Author: Jacopo Mondi <jacopo.mondi@linaro.org>
Date:   Thu Jun 30 09:18:00 2016 -0500

    greybus: camera: Fix size of configure_streams(0)
    
    When APB-A CSI-Tx configuration fails, it is necessary to unconfigure
    the camera module issuesing a 0 stream configuration request.
    Fix size of request and response to avoid Greybus core complain about
    Response size differences.
    
    Testing Done: Triggering the error condition after APB-A CSI-tx
                  configuration does not make Greybus core complain anymore
    
    Signed-off-by: Jacopo Mondi <jacopo.mondi@linaro.org>
    Reviewed-by: Laurent Pinchart <laurent.pinchart@linaro.org>
    Signed-off-by: Alex Elder <elder@linaro.org>

diff --git a/drivers/staging/greybus/camera.c b/drivers/staging/greybus/camera.c
index 41891b24ef05..ce0ff759f3ce 100644
--- a/drivers/staging/greybus/camera.c
+++ b/drivers/staging/greybus/camera.c
@@ -468,7 +468,8 @@ static int gb_camera_configure_streams(struct gb_camera *gcam,
 			memset(req, 0, sizeof(*req));
 			gb_operation_sync(gcam->connection,
 					  GB_CAMERA_TYPE_CONFIGURE_STREAMS,
-					  req, req_size, resp, resp_size);
+					  req, sizeof(*req),
+					  resp, sizeof(*resp));
 			*flags = 0;
 			*num_streams = 0;
 			goto done;

commit 36ab1108b60eb649c7c0f0653f854afc1234cfcb
Author: Jacopo Mondi <jacopo.mondi@linaro.org>
Date:   Thu Jun 30 09:18:00 2016 -0500

    greybus: camera: Fix number of configured streams
    
    Camera Module may report a lower number of configured streams than the
    one requested by the AP.
    All the non-supported stream configuration are zeroed.
    Make the stream configuration inspection loop take only the valid stream
    into account, to avoid unnecessarily accessing zeroed memory areas.
    
    So far, inspecting non valid streams configuration has prove to be
    harmless, but as we'll need to inspect stream characteristics as reported
    image sizes and format, we have to take only valid configurations into
    account.
    
    Testing Done: White Camera Module preview and capture.
    
    Signed-off-by: Jacopo Mondi <jacopo.mondi@linaro.org>
    Reviewed-by: Laurent Pinchart <laurent.pinchart@linaro.org>
    Signed-off-by: Alex Elder <elder@linaro.org>

diff --git a/drivers/staging/greybus/camera.c b/drivers/staging/greybus/camera.c
index 584f85e7a02d..41891b24ef05 100644
--- a/drivers/staging/greybus/camera.c
+++ b/drivers/staging/greybus/camera.c
@@ -435,7 +435,7 @@ static int gb_camera_configure_streams(struct gb_camera *gcam,
 	*flags = resp->flags;
 	*num_streams = resp->num_streams;
 
-	for (i = 0; i < nstreams; ++i) {
+	for (i = 0; i < resp->num_streams; ++i) {
 		struct gb_camera_stream_config_response *cfg = &resp->config[i];
 
 		streams[i].width = le16_to_cpu(cfg->width);

commit 7f93eab7c705527b0579b1bfd4d6e9f6acc9e5ca
Author: Jacopo Mondi <jacopo.mondi@linaro.org>
Date:   Thu Jun 30 09:18:00 2016 -0500

    greybus: camera: Early update num_streams and flags
    
    In configure_streams Operation, when returning from the greybus
    operation call, we can assign the num_streams and flags variable earlier
    so that if the following stream configuration inspection fails, the
    caller receives the right number of configured streams anyway
    
    Testing Done: White camera module preview and capture.
                  Triggering failure during stream configuration inspection
                  makes configuration fails, but avoid segfaulting as
                  was previously happening
    
    Signed-off-by: Jacopo Mondi <jacopo.mondi@linaro.org>
    Reviewed-by: Laurent Pinchart <laurent.pinchart@linaro.org>
    Signed-off-by: Alex Elder <elder@linaro.org>

diff --git a/drivers/staging/greybus/camera.c b/drivers/staging/greybus/camera.c
index c47e4244a132..584f85e7a02d 100644
--- a/drivers/staging/greybus/camera.c
+++ b/drivers/staging/greybus/camera.c
@@ -432,6 +432,9 @@ static int gb_camera_configure_streams(struct gb_camera *gcam,
 		goto done;
 	}
 
+	*flags = resp->flags;
+	*num_streams = resp->num_streams;
+
 	for (i = 0; i < nstreams; ++i) {
 		struct gb_camera_stream_config_response *cfg = &resp->config[i];
 
@@ -451,11 +454,8 @@ static int gb_camera_configure_streams(struct gb_camera *gcam,
 	}
 
 	if ((resp->flags & GB_CAMERA_CONFIGURE_STREAMS_ADJUSTED) ||
-	    (*flags & GB_CAMERA_CONFIGURE_STREAMS_TEST_ONLY)) {
-		*flags = resp->flags;
-		*num_streams = resp->num_streams;
+	    (req->flags & GB_CAMERA_CONFIGURE_STREAMS_TEST_ONLY))
 		goto done;
-	}
 
 	if (gcam->state == GB_CAMERA_STATE_CONFIGURED) {
 		gb_camera_teardown_data_connection(gcam);
@@ -469,15 +469,14 @@ static int gb_camera_configure_streams(struct gb_camera *gcam,
 			gb_operation_sync(gcam->connection,
 					  GB_CAMERA_TYPE_CONFIGURE_STREAMS,
 					  req, req_size, resp, resp_size);
+			*flags = 0;
+			*num_streams = 0;
 			goto done;
 		}
 
 		gcam->state = GB_CAMERA_STATE_CONFIGURED;
 	}
 
-	*flags = resp->flags;
-	*num_streams = resp->num_streams;
-
 done:
 	mutex_unlock(&gcam->mutex);
 	kfree(req);

commit caad3090ab37d47e21505b613ad611ad6d20358d
Author: Evgeniy Borisov <borisov_evgeniy@projectara.com>
Date:   Thu Jun 23 12:39:18 2016 +0300

    greybus: camera: Add RAW data format
    
    Add support for greybus RAW data format.
    Greybus RAW data formats starts from 0x80.
    
    Signed-off-by: Evgeniy Borisov <eborisov@mm-sol.com>
    Reviewed-by: Laurent Pinchart <laurent.pinchart@linaro.org>
    Reviewed-by: Gjorgji Rosikopulos <grosikopulos@mm-sol.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/camera.c b/drivers/staging/greybus/camera.c
index 0062f483fc2e..c47e4244a132 100644
--- a/drivers/staging/greybus/camera.c
+++ b/drivers/staging/greybus/camera.c
@@ -113,6 +113,38 @@ static const struct gb_camera_fmt_map mbus_to_gbus_format[] = {
 		.mbus_code = V4L2_MBUS_FMT_ARA_DEBUG_DATA_1X8,
 		.gb_format = 0x42,
 	},
+	{
+		.mbus_code = V4L2_MBUS_FMT_SBGGR10_1X10,
+		.gb_format = 0x80,
+	},
+	{
+		.mbus_code = V4L2_MBUS_FMT_SGBRG10_1X10,
+		.gb_format = 0x81,
+	},
+	{
+		.mbus_code = V4L2_MBUS_FMT_SGRBG10_1X10,
+		.gb_format = 0x82,
+	},
+	{
+		.mbus_code = V4L2_MBUS_FMT_SRGGB10_1X10,
+		.gb_format = 0x83,
+	},
+	{
+		.mbus_code = V4L2_MBUS_FMT_SBGGR12_1X12,
+		.gb_format = 0x84,
+	},
+	{
+		.mbus_code = V4L2_MBUS_FMT_SGBRG12_1X12,
+		.gb_format = 0x85,
+	},
+	{
+		.mbus_code = V4L2_MBUS_FMT_SGRBG12_1X12,
+		.gb_format = 0x86,
+	},
+	{
+		.mbus_code = V4L2_MBUS_FMT_SRGGB12_1X12,
+		.gb_format = 0x87,
+	},
 };
 
 #define ES2_APB_CDSI0_CPORT		16

commit 9120b9060bca4528d13de5c4e6522e6a78110704
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Tue Jun 14 15:59:25 2016 +0300

    greybus: camera: Create and destroy data connection on demand
    
    Creating the data connection at probe time makes it impossible to
    support multiple inserted camera modules as they would all try to
    establish a data connection to the same CPort on the AP side. Create and
    destroy the data connection when configuring the streams instead, as a
    single module can be streaming at a time.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Gjorgji Rosikopulos <grosikopulos@mm-sol.com>
    Tested-by: Gjorgji Rosikopulos <grosikopulos@mm-sol.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/camera.c b/drivers/staging/greybus/camera.c
index db7cdcee1c53..0062f483fc2e 100644
--- a/drivers/staging/greybus/camera.c
+++ b/drivers/staging/greybus/camera.c
@@ -42,6 +42,7 @@ enum gb_camera_state {
  * struct gb_camera - A Greybus Camera Device
  * @connection: the greybus connection for camera management
  * @data_connection: the greybus connection for camera data
+ * @data_cport_id: the data CPort ID on the module side
  * @mutex: protects the connection and state fields
  * @state: the current module state
  * @debugfs: debugfs entries for camera protocol operations testing
@@ -51,6 +52,7 @@ struct gb_camera {
 	struct gb_bundle *bundle;
 	struct gb_connection *connection;
 	struct gb_connection *data_connection;
+	u16 data_cport_id;
 
 	struct mutex mutex;
 	enum gb_camera_state state;
@@ -196,12 +198,30 @@ static int gb_camera_setup_data_connection(struct gb_camera *gcam,
 		struct gb_camera_csi_params *csi_params)
 {
 	struct ap_csi_config_request csi_cfg;
+	struct gb_connection *conn;
 	int ret;
 
+	/*
+	 * Create the data connection between the camera module data CPort and
+	 * APB CDSI1. The CDSI1 CPort ID is hardcoded by the ES2 bridge.
+	 */
+	conn = gb_connection_create_offloaded(gcam->bundle, gcam->data_cport_id,
+					      GB_CONNECTION_FLAG_NO_FLOWCTRL |
+					      GB_CONNECTION_FLAG_CDSI1);
+	if (IS_ERR(conn))
+		return PTR_ERR(conn);
+
+	gcam->data_connection = conn;
+	gb_connection_set_data(conn, gcam);
+
+	ret = gb_connection_enable(conn);
+	if (ret)
+		goto error_conn_destroy;
+
 	/* Set the UniPro link to high speed mode. */
 	ret = gb_camera_set_power_mode(gcam, true);
 	if (ret < 0)
-		return ret;
+		goto error_conn_disable;
 
 	/*
 	 * Configure the APB1 CSI transmitter using the lines count reported by
@@ -224,8 +244,7 @@ static int gb_camera_setup_data_connection(struct gb_camera *gcam,
 
 	if (ret < 0) {
 		gcam_err(gcam, "failed to start the CSI transmitter\n");
-		gb_camera_set_power_mode(gcam, false);
-		return ret;
+		goto error_power;
 	}
 
 	if (csi_params) {
@@ -236,6 +255,15 @@ static int gb_camera_setup_data_connection(struct gb_camera *gcam,
 	}
 
 	return 0;
+
+error_power:
+	gb_camera_set_power_mode(gcam, false);
+error_conn_disable:
+	gb_connection_disable(gcam->data_connection);
+error_conn_destroy:
+	gb_connection_destroy(gcam->data_connection);
+	gcam->data_connection = NULL;
+	return ret;
 }
 
 static void gb_camera_teardown_data_connection(struct gb_camera *gcam)
@@ -256,6 +284,11 @@ static void gb_camera_teardown_data_connection(struct gb_camera *gcam)
 
 	/* Set the UniPro link to low speed mode. */
 	gb_camera_set_power_mode(gcam, false);
+
+	/* Destroy the data connection. */
+	gb_connection_disable(gcam->data_connection);
+	gb_connection_destroy(gcam->data_connection);
+	gcam->data_connection = NULL;
 }
 
 /* -----------------------------------------------------------------------------
@@ -990,13 +1023,13 @@ static void gb_camera_cleanup(struct gb_camera *gcam)
 {
 	gb_camera_debugfs_cleanup(gcam);
 
+	mutex_lock(&gcam->mutex);
 	if (gcam->data_connection) {
 		gb_connection_disable(gcam->data_connection);
 		gb_connection_destroy(gcam->data_connection);
 		gcam->data_connection = NULL;
 	}
 
-	mutex_lock(&gcam->mutex);
 	if (gcam->connection) {
 		gb_connection_disable(gcam->connection);
 		gb_connection_destroy(gcam->connection);
@@ -1055,6 +1088,7 @@ static int gb_camera_probe(struct gb_bundle *bundle,
 
 	gcam->bundle = bundle;
 	gcam->state = GB_CAMERA_STATE_UNCONFIGURED;
+	gcam->data_cport_id = data_cport_id;
 
 	conn = gb_connection_create(bundle, mgmt_cport_id,
 				    gb_camera_request_handler);
@@ -1066,24 +1100,6 @@ static int gb_camera_probe(struct gb_bundle *bundle,
 	gcam->connection = conn;
 	gb_connection_set_data(conn, gcam);
 
-	ret = gb_connection_enable(conn);
-	if (ret)
-		goto error;
-
-	/*
-	 * Create the data connection between the camera module data CPort and
-	 * APB CDSI1. The CDSI1 CPort ID is hardcoded by the ES2 bridge.
-	 */
-	conn = gb_connection_create_offloaded(bundle, data_cport_id,
-					      GB_CONNECTION_FLAG_NO_FLOWCTRL |
-					      GB_CONNECTION_FLAG_CDSI1);
-	if (IS_ERR(conn)) {
-		ret = PTR_ERR(conn);
-		goto error;
-	}
-	gcam->data_connection = conn;
-	gb_connection_set_data(conn, gcam);
-
 	ret = gb_connection_enable(conn);
 	if (ret)
 		goto error;

commit 3b8ebfeb32daf13ef5fccb7ec3d163783e6a01a2
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Tue Jun 14 15:59:24 2016 +0300

    greybus: camera: Fix data connection setup
    
    When the module is in the configured state, an attempt to change the
    configuration must first tear down the data connection to update its
    parameters, as the APB1 bridge doesn't support modifying the CSI
    transmitter configuration when it is already started.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Gjorgji Rosikopulos <grosikopulos@mm-sol.com>
    Tested-by: Gjorgji Rosikopulos <grosikopulos@mm-sol.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/camera.c b/drivers/staging/greybus/camera.c
index bbf54d7f52a1..db7cdcee1c53 100644
--- a/drivers/staging/greybus/camera.c
+++ b/drivers/staging/greybus/camera.c
@@ -33,11 +33,17 @@ struct gb_camera_debugfs_buffer {
 	size_t length;
 };
 
+enum gb_camera_state {
+	GB_CAMERA_STATE_UNCONFIGURED,
+	GB_CAMERA_STATE_CONFIGURED,
+};
+
 /**
  * struct gb_camera - A Greybus Camera Device
  * @connection: the greybus connection for camera management
  * @data_connection: the greybus connection for camera data
- * @mutex: protects the connection field
+ * @mutex: protects the connection and state fields
+ * @state: the current module state
  * @debugfs: debugfs entries for camera protocol operations testing
  * @module: Greybus camera module registered to HOST processor.
  */
@@ -45,7 +51,9 @@ struct gb_camera {
 	struct gb_bundle *bundle;
 	struct gb_connection *connection;
 	struct gb_connection *data_connection;
+
 	struct mutex mutex;
+	enum gb_camera_state state;
 
 	struct {
 		struct dentry *root;
@@ -300,7 +308,6 @@ static int gb_camera_configure_streams(struct gb_camera *gcam,
 {
 	struct gb_camera_configure_streams_request *req;
 	struct gb_camera_configure_streams_response *resp;
-
 	unsigned int nstreams = *num_streams;
 	unsigned int i;
 	size_t req_size;
@@ -385,6 +392,11 @@ static int gb_camera_configure_streams(struct gb_camera *gcam,
 		goto done;
 	}
 
+	if (gcam->state == GB_CAMERA_STATE_CONFIGURED) {
+		gb_camera_teardown_data_connection(gcam);
+		gcam->state = GB_CAMERA_STATE_UNCONFIGURED;
+	}
+
 	if (resp->num_streams) {
 		ret = gb_camera_setup_data_connection(gcam, resp, csi_params);
 		if (ret < 0) {
@@ -394,8 +406,8 @@ static int gb_camera_configure_streams(struct gb_camera *gcam,
 					  req, req_size, resp, resp_size);
 			goto done;
 		}
-	} else {
-		gb_camera_teardown_data_connection(gcam);
+
+		gcam->state = GB_CAMERA_STATE_CONFIGURED;
 	}
 
 	*flags = resp->flags;
@@ -1039,9 +1051,11 @@ static int gb_camera_probe(struct gb_bundle *bundle,
 	if (!gcam)
 		return -ENOMEM;
 
-	gcam->bundle = bundle;
 	mutex_init(&gcam->mutex);
 
+	gcam->bundle = bundle;
+	gcam->state = GB_CAMERA_STATE_UNCONFIGURED;
+
 	conn = gb_connection_create(bundle, mgmt_cport_id,
 				    gb_camera_request_handler);
 	if (IS_ERR(conn)) {

commit f3d5f6613f0da3ba1135f6e06b9692202fb9920b
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Tue Jun 14 15:59:23 2016 +0300

    greybus: camera: Clean up on stream configuration failure
    
    When the camera pipeline can't be configured due to a failure of one of
    the components (failure to start the CSI transmitter for instance),
    components that have already been setup for video streaming need to be
    set back to a quiescient state. This is especially important to ensure
    that a stream configuration failure won't keep the UniPro links in high
    speed mode forever.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Gjorgji Rosikopulos <grosikopulos@mm-sol.com>
    Tested-by: Gjorgji Rosikopulos <grosikopulos@mm-sol.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/camera.c b/drivers/staging/greybus/camera.c
index 0d20c6b8b015..bbf54d7f52a1 100644
--- a/drivers/staging/greybus/camera.c
+++ b/drivers/staging/greybus/camera.c
@@ -115,7 +115,7 @@ static const struct gb_camera_fmt_map mbus_to_gbus_format[] = {
 #define gcam_err(gcam, format...)	dev_err(&gcam->bundle->dev, format)
 
 /* -----------------------------------------------------------------------------
- * Camera Protocol Operations
+ * Hardware Configuration
  */
 
 static int gb_camera_set_intf_power_mode(struct gb_camera *gcam, u8 intf_id,
@@ -173,6 +173,87 @@ static int gb_camera_set_power_mode(struct gb_camera *gcam, bool hs)
 	return 0;
 }
 
+struct ap_csi_config_request {
+	__u8 csi_id;
+	__u8 flags;
+#define GB_CAMERA_CSI_FLAG_CLOCK_CONTINUOUS 0x01
+	__u8 num_lanes;
+	__u8 padding;
+	__le32 bus_freq;
+	__le32 lines_per_second;
+} __packed;
+
+static int gb_camera_setup_data_connection(struct gb_camera *gcam,
+		const struct gb_camera_configure_streams_response *resp,
+		struct gb_camera_csi_params *csi_params)
+{
+	struct ap_csi_config_request csi_cfg;
+	int ret;
+
+	/* Set the UniPro link to high speed mode. */
+	ret = gb_camera_set_power_mode(gcam, true);
+	if (ret < 0)
+		return ret;
+
+	/*
+	 * Configure the APB1 CSI transmitter using the lines count reported by
+	 * the  camera module, but with hard-coded bus frequency and lanes number.
+	 *
+	 * TODO: use the clocking and size informations reported by camera module
+	 * to compute the required CSI bandwidth, and configure the CSI receiver
+	 * on AP side, and the CSI transmitter on APB1 side accordingly.
+	 */
+	memset(&csi_cfg, 0, sizeof(csi_cfg));
+	csi_cfg.csi_id = 1;
+	csi_cfg.flags = 0;
+	csi_cfg.num_lanes = resp->num_lanes;
+	csi_cfg.bus_freq = cpu_to_le32(960000000);
+	csi_cfg.lines_per_second = resp->lines_per_second;
+
+	ret = gb_hd_output(gcam->connection->hd, &csi_cfg,
+			   sizeof(csi_cfg),
+			   GB_APB_REQUEST_CSI_TX_CONTROL, false);
+
+	if (ret < 0) {
+		gcam_err(gcam, "failed to start the CSI transmitter\n");
+		gb_camera_set_power_mode(gcam, false);
+		return ret;
+	}
+
+	if (csi_params) {
+		csi_params->num_lanes = csi_cfg.num_lanes;
+		/* Transmitting two bits per cycle. (DDR clock) */
+		csi_params->clk_freq = csi_cfg.bus_freq / 2;
+		csi_params->lines_per_second = csi_cfg.lines_per_second;
+	}
+
+	return 0;
+}
+
+static void gb_camera_teardown_data_connection(struct gb_camera *gcam)
+{
+	struct ap_csi_config_request csi_cfg;
+	int ret;
+
+	/* Stop the APB1 CSI transmitter. */
+	memset(&csi_cfg, 0, sizeof(csi_cfg));
+	csi_cfg.csi_id = 1;
+
+	ret = gb_hd_output(gcam->connection->hd, &csi_cfg,
+			   sizeof(csi_cfg),
+			   GB_APB_REQUEST_CSI_TX_CONTROL, false);
+
+	if (ret < 0)
+		gcam_err(gcam, "failed to stop the CSI transmitter\n");
+
+	/* Set the UniPro link to low speed mode. */
+	gb_camera_set_power_mode(gcam, false);
+}
+
+/* -----------------------------------------------------------------------------
+ * Camera Protocol Operations
+ */
+
 static int gb_camera_capabilities(struct gb_camera *gcam,
 				  u8 *capabilities, size_t *size)
 {
@@ -211,16 +292,6 @@ static int gb_camera_capabilities(struct gb_camera *gcam,
 	return ret;
 }
 
-struct ap_csi_config_request {
-	__u8 csi_id;
-	__u8 flags;
-#define GB_CAMERA_CSI_FLAG_CLOCK_CONTINUOUS 0x01
-	__u8 num_lanes;
-	__u8 padding;
-	__le32 bus_freq;
-	__le32 lines_per_second;
-} __packed;
-
 static int gb_camera_configure_streams(struct gb_camera *gcam,
 				       unsigned int *num_streams,
 				       unsigned int *flags,
@@ -229,7 +300,6 @@ static int gb_camera_configure_streams(struct gb_camera *gcam,
 {
 	struct gb_camera_configure_streams_request *req;
 	struct gb_camera_configure_streams_response *resp;
-	struct ap_csi_config_request csi_cfg;
 
 	unsigned int nstreams = *num_streams;
 	unsigned int i;
@@ -315,50 +385,21 @@ static int gb_camera_configure_streams(struct gb_camera *gcam,
 		goto done;
 	}
 
-	/* Setup unipro link speed. */
-	ret = gb_camera_set_power_mode(gcam, nstreams != 0);
-	if (ret < 0)
-		goto done;
-
-	/*
-	 * Configure the APB1 CSI transmitter using the lines count reported by
-	 * the  camera module, but with hard-coded bus frequency and lanes number.
-	 *
-	 * TODO: use the clocking and size informations reported by camera module
-	 * to compute the required CSI bandwidth, and configure the CSI receiver
-	 * on AP side, and the CSI transmitter on APB1 side accordingly.
-	 */
-	memset(&csi_cfg, 0, sizeof(csi_cfg));
-
-	if (nstreams) {
-		csi_cfg.csi_id = 1;
-		csi_cfg.flags = 0;
-		csi_cfg.num_lanes = resp->num_lanes;
-		csi_cfg.bus_freq = cpu_to_le32(960000000);
-		csi_cfg.lines_per_second = resp->lines_per_second;
-		ret = gb_hd_output(gcam->connection->hd, &csi_cfg,
-				   sizeof(csi_cfg),
-				   GB_APB_REQUEST_CSI_TX_CONTROL, false);
-		if (csi_params) {
-			csi_params->num_lanes = csi_cfg.num_lanes;
-			/* Transmitting two bits per cycle. (DDR clock) */
-			csi_params->clk_freq = csi_cfg.bus_freq / 2;
-			csi_params->lines_per_second = csi_cfg.lines_per_second;
+	if (resp->num_streams) {
+		ret = gb_camera_setup_data_connection(gcam, resp, csi_params);
+		if (ret < 0) {
+			memset(req, 0, sizeof(*req));
+			gb_operation_sync(gcam->connection,
+					  GB_CAMERA_TYPE_CONFIGURE_STREAMS,
+					  req, req_size, resp, resp_size);
+			goto done;
 		}
 	} else {
-		csi_cfg.csi_id = 1;
-		ret = gb_hd_output(gcam->connection->hd, &csi_cfg,
-				   sizeof(csi_cfg),
-				   GB_APB_REQUEST_CSI_TX_CONTROL, false);
+		gb_camera_teardown_data_connection(gcam);
 	}
 
-	if (ret < 0)
-		gcam_err(gcam, "failed to %s the CSI transmitter\n",
-			 nstreams ? "start" : "stop");
-
 	*flags = resp->flags;
 	*num_streams = resp->num_streams;
-	ret = 0;
 
 done:
 	mutex_unlock(&gcam->mutex);

commit d9e4c4ee12e490aca06a0a70d534c60648e2f43a
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Mon Jun 13 15:08:01 2016 +0530

    greybus: camera: Initialize mutex before using it
    
    We are using the mutex from gb_camera_cleanup(), which can get called
    even before the mutex is initialized.
    
    Fix it by initializing the mutex early enough.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Reviewed-by: Laurent Pinchart <laurent.pinchart@linaro.org>
    Reviewed-by: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/camera.c b/drivers/staging/greybus/camera.c
index ca1f4989197f..0d20c6b8b015 100644
--- a/drivers/staging/greybus/camera.c
+++ b/drivers/staging/greybus/camera.c
@@ -999,6 +999,7 @@ static int gb_camera_probe(struct gb_bundle *bundle,
 		return -ENOMEM;
 
 	gcam->bundle = bundle;
+	mutex_init(&gcam->mutex);
 
 	conn = gb_connection_create(bundle, mgmt_cport_id,
 				    gb_camera_request_handler);
@@ -1014,8 +1015,6 @@ static int gb_camera_probe(struct gb_bundle *bundle,
 	if (ret)
 		goto error;
 
-	mutex_init(&gcam->mutex);
-
 	/*
 	 * Create the data connection between the camera module data CPort and
 	 * APB CDSI1. The CDSI1 CPort ID is hardcoded by the ES2 bridge.

commit 8c2522d87ab20ba245ddf92e4e8b19a76e5760fd
Author: Eli Sennesh <esennesh@leaflabs.com>
Date:   Fri Jun 3 11:24:44 2016 -0400

    greybus: update UniPro Set Interface Power Mode operation to match spec
    
    Bring the gb_svc_intf_set_power_mode() up-to-date with the current Greybus
    specification.  This largely involves adding more members to the structure
    sent across the wire.  Also change the camera code to use the new
    operation properly, with default values passed for the new necessary
    arguments.  The correctness of these default values is confirmed via testing
    and by asking Rob Johnson.
    
    We must make sure to zero the request structure sent across the wire, lest
    bite us most cruelly, and we fix by changing the Set Power Mode
    Response structure to use a __u8 rather than a __le16.
    
    Testing Done: Took a picture with a camera module, received error code
    when passing deliberately incorrect values for new parameters, got proper
    -EIO and Greybus result code printed when operation stopped halfway
    through.  Could induce error by initializing request struct with random
    nonsense, and can stop it by initializing request struct with zeroes.
    
    Associated Firmware Changes: 1669-1671 on Android N Gerrit for SW-2945
    
    Signed-off-by: Eli Sennesh <esennesh@leaflabs.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/camera.c b/drivers/staging/greybus/camera.c
index 162cb7d294cd..ca1f4989197f 100644
--- a/drivers/staging/greybus/camera.c
+++ b/drivers/staging/greybus/camera.c
@@ -128,17 +128,23 @@ static int gb_camera_set_intf_power_mode(struct gb_camera *gcam, u8 intf_id,
 		ret = gb_svc_intf_set_power_mode(svc, intf_id,
 						 GB_SVC_UNIPRO_HS_SERIES_A,
 						 GB_SVC_UNIPRO_FAST_MODE, 2, 2,
+						 GB_SVC_SMALL_AMPLITUDE,
+						 GB_SVC_NO_DE_EMPHASIS,
 						 GB_SVC_UNIPRO_FAST_MODE, 2, 2,
 						 GB_SVC_PWRM_RXTERMINATION |
-						 GB_SVC_PWRM_TXTERMINATION, 0);
+						 GB_SVC_PWRM_TXTERMINATION, 0,
+						 NULL, NULL);
 	else
 		ret = gb_svc_intf_set_power_mode(svc, intf_id,
 						 GB_SVC_UNIPRO_HS_SERIES_A,
 						 GB_SVC_UNIPRO_SLOW_AUTO_MODE,
 						 2, 1,
+						 GB_SVC_SMALL_AMPLITUDE,
+						 GB_SVC_NO_DE_EMPHASIS,
 						 GB_SVC_UNIPRO_SLOW_AUTO_MODE,
 						 2, 1,
-						 0, 0);
+						 0, 0,
+						 NULL, NULL);
 
 	return ret;
 }

commit cb14e97623d9289a30c3cfab02747581dda22f58
Author: Gjorgji Rosikopulos <grosikopulos@mms-0359.ent.mm-sol.com>
Date:   Thu Jun 9 11:53:15 2016 +0300

    greybus: camera: Add debug data format
    
    Add support for greybus debug data format.
    Greybus debug data format id is 0x42.
    
    Signed-off-by: Gjorgji Rosikopulos <grosikopulos@mm-sol.com>
    Acked-by: Laurent Pinchart <laurent.pinchart@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/camera.c b/drivers/staging/greybus/camera.c
index d7cef2ac5aee..162cb7d294cd 100644
--- a/drivers/staging/greybus/camera.c
+++ b/drivers/staging/greybus/camera.c
@@ -98,7 +98,11 @@ static const struct gb_camera_fmt_map mbus_to_gbus_format[] = {
 	{
 		.mbus_code = V4L2_MBUS_FMT_ARA_METADATA_1X8,
 		.gb_format = 0x41,
-	}
+	},
+	{
+		.mbus_code = V4L2_MBUS_FMT_ARA_DEBUG_DATA_1X8,
+		.gb_format = 0x42,
+	},
 };
 
 #define ES2_APB_CDSI0_CPORT		16

commit 17ca677018117deee1bd75b301894dca975e7fc5
Author: Evgeniy Borisov <borisov_evgeniy@projectara.com>
Date:   Tue May 31 11:33:11 2016 +0300

    greybus: camera-gb: Implement camera module reference counting as subject.
    
    In explanation:
    
    The main idea for implementing reference counting is to not block exit
    until any other modules are in use. Camera responsibility is to handle
    properly any additional calls after camera exit and that what this
    patch is doing:
    
    1. Free camera module when reference count is zero.
    2. After camera cleanup handle properly any additional ongoing
       transaction. Return error if connection is destroyed.
    
    Signed-off-by: Evgeniy Borisov <eborisov@mm-sol.com>
    Reviewed-by: Gjorgji Rosikopulos <grosikopulos@mm-sol.com>
    Reviewed-by: Laurent Pinchart <laurent.pinchart@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/camera.c b/drivers/staging/greybus/camera.c
index d5496f8a7b89..d7cef2ac5aee 100644
--- a/drivers/staging/greybus/camera.c
+++ b/drivers/staging/greybus/camera.c
@@ -35,7 +35,9 @@ struct gb_camera_debugfs_buffer {
 
 /**
  * struct gb_camera - A Greybus Camera Device
- * @connection: the greybus connection for camera control
+ * @connection: the greybus connection for camera management
+ * @data_connection: the greybus connection for camera data
+ * @mutex: protects the connection field
  * @debugfs: debugfs entries for camera protocol operations testing
  * @module: Greybus camera module registered to HOST processor.
  */
@@ -43,6 +45,7 @@ struct gb_camera {
 	struct gb_bundle *bundle;
 	struct gb_connection *connection;
 	struct gb_connection *data_connection;
+	struct mutex mutex;
 
 	struct {
 		struct dentry *root;
@@ -163,15 +166,24 @@ static int gb_camera_set_power_mode(struct gb_camera *gcam, bool hs)
 static int gb_camera_capabilities(struct gb_camera *gcam,
 				  u8 *capabilities, size_t *size)
 {
-	struct gb_operation *op;
+	struct gb_operation *op = NULL;
 	int ret;
 
+	mutex_lock(&gcam->mutex);
+
+	if (!gcam->connection) {
+		ret = -EINVAL;
+		goto done;
+	}
+
 	op = gb_operation_create_flags(gcam->connection,
 				       GB_CAMERA_TYPE_CAPABILITIES, 0, *size,
 				       GB_OPERATION_FLAG_SHORT_RESPONSE,
 				       GFP_KERNEL);
-	if (!op)
-		return -ENOMEM;
+	if (!op) {
+		ret = -ENOMEM;
+		goto done;
+	}
 
 	ret = gb_operation_request_send_sync(op);
 	if (ret) {
@@ -183,7 +195,9 @@ static int gb_camera_capabilities(struct gb_camera *gcam,
 	*size = op->response->payload_size;
 
 done:
-	gb_operation_put(op);
+	mutex_unlock(&gcam->mutex);
+	if (op)
+		gb_operation_put(op);
 	return ret;
 }
 
@@ -222,8 +236,9 @@ static int gb_camera_configure_streams(struct gb_camera *gcam,
 	req = kmalloc(req_size, GFP_KERNEL);
 	resp = kmalloc(resp_size, GFP_KERNEL);
 	if (!req || !resp) {
-		ret = -ENOMEM;
-		goto done;
+		kfree(req);
+		kfree(resp);
+		return -ENOMEM;
 	}
 
 	req->num_streams = nstreams;
@@ -239,6 +254,13 @@ static int gb_camera_configure_streams(struct gb_camera *gcam,
 		cfg->padding = 0;
 	}
 
+	mutex_lock(&gcam->mutex);
+
+	if (!gcam->connection) {
+		ret = -EINVAL;
+		goto done;
+	}
+
 	ret = gb_operation_sync(gcam->connection,
 				GB_CAMERA_TYPE_CONFIGURE_STREAMS,
 				req, req_size, resp, resp_size);
@@ -329,6 +351,7 @@ static int gb_camera_configure_streams(struct gb_camera *gcam,
 	ret = 0;
 
 done:
+	mutex_unlock(&gcam->mutex);
 	kfree(req);
 	kfree(resp);
 	return ret;
@@ -356,8 +379,17 @@ static int gb_camera_capture(struct gb_camera *gcam, u32 request_id,
 	req->num_frames = cpu_to_le16(num_frames);
 	memcpy(req->settings, settings, settings_size);
 
+	mutex_lock(&gcam->mutex);
+
+	if (!gcam->connection) {
+		ret = -EINVAL;
+		goto done;
+	}
+
 	ret = gb_operation_sync(gcam->connection, GB_CAMERA_TYPE_CAPTURE,
-				 req, req_size, NULL, 0);
+				req, req_size, NULL, 0);
+done:
+	mutex_unlock(&gcam->mutex);
 
 	kfree(req);
 
@@ -369,15 +401,26 @@ static int gb_camera_flush(struct gb_camera *gcam, u32 *request_id)
 	struct gb_camera_flush_response resp;
 	int ret;
 
+	mutex_lock(&gcam->mutex);
+
+	if (!gcam->connection) {
+		ret = -EINVAL;
+		goto done;
+	}
+
 	ret = gb_operation_sync(gcam->connection, GB_CAMERA_TYPE_FLUSH, NULL, 0,
 				&resp, sizeof(resp));
+
 	if (ret < 0)
-		return ret;
+		goto done;
 
 	if (request_id)
 		*request_id = le32_to_cpu(resp.request_id);
 
-	return 0;
+done:
+	mutex_unlock(&gcam->mutex);
+
+	return ret;
 }
 
 static int gb_camera_request_handler(struct gb_operation *op)
@@ -527,18 +570,6 @@ static const struct gb_camera_ops gb_cam_ops = {
 	.flush = gb_camera_op_flush,
 };
 
-static int gb_camera_register_intf_ops(struct gb_camera *gcam)
-{
-	gcam->module.priv = gcam;
-	gcam->module.ops = &gb_cam_ops;
-	return gb_camera_register(&gcam->module);
-}
-
-static int gb_camera_unregister_intf_ops(struct gb_camera *gcam)
-{
-	return gb_camera_unregister(&gcam->module);
-}
-
 /* -----------------------------------------------------------------------------
  * DebugFS
  */
@@ -899,14 +930,23 @@ static void gb_camera_cleanup(struct gb_camera *gcam)
 	if (gcam->data_connection) {
 		gb_connection_disable(gcam->data_connection);
 		gb_connection_destroy(gcam->data_connection);
+		gcam->data_connection = NULL;
 	}
 
+	mutex_lock(&gcam->mutex);
 	if (gcam->connection) {
 		gb_connection_disable(gcam->connection);
 		gb_connection_destroy(gcam->connection);
+		gcam->connection = NULL;
 	}
+	mutex_unlock(&gcam->mutex);
+}
 
-	kfree(gcam);
+static void gb_camera_release_module(struct kref *ref)
+{
+	struct gb_camera_module *cam_mod =
+		container_of(ref, struct gb_camera_module, refcount);
+	kfree(cam_mod->priv);
 }
 
 static int gb_camera_probe(struct gb_bundle *bundle,
@@ -964,6 +1004,8 @@ static int gb_camera_probe(struct gb_bundle *bundle,
 	if (ret)
 		goto error;
 
+	mutex_init(&gcam->mutex);
+
 	/*
 	 * Create the data connection between the camera module data CPort and
 	 * APB CDSI1. The CDSI1 CPort ID is hardcoded by the ES2 bridge.
@@ -986,7 +1028,11 @@ static int gb_camera_probe(struct gb_bundle *bundle,
 	if (ret < 0)
 		goto error;
 
-	ret = gb_camera_register_intf_ops(gcam);
+	gcam->module.priv = gcam;
+	gcam->module.ops = &gb_cam_ops;
+	gcam->module.interface_id = gcam->connection->intf->interface_id;
+	gcam->module.release = gb_camera_release_module;
+	ret = gb_camera_register(&gcam->module);
 	if (ret < 0)
 		goto error;
 
@@ -996,6 +1042,7 @@ static int gb_camera_probe(struct gb_bundle *bundle,
 
 error:
 	gb_camera_cleanup(gcam);
+	kfree(gcam);
 	return ret;
 }
 
@@ -1003,8 +1050,8 @@ static void gb_camera_disconnect(struct gb_bundle *bundle)
 {
 	struct gb_camera *gcam = greybus_get_drvdata(bundle);
 
-	gb_camera_unregister_intf_ops(gcam);
 	gb_camera_cleanup(gcam);
+	gb_camera_unregister(&gcam->module);
 }
 
 static const struct greybus_bundle_id gb_camera_id_table[] = {

commit 66394300c37e9321a913f269021b3d6c92d786ad
Author: Alex Elder <elder@linaro.org>
Date:   Tue May 24 13:34:49 2016 -0500

    greybus: eliminate unneeded null check
    
    Coccinelle points out that debugfs_remove_recursive() handles a null
    argument properly, so there's no need to check for NULL before
    making the call.  I have verified this is true of the kernel we're
    now working with (arche-6.0).
    
    Signed-off-by: Alex Elder <elder@linaro.org>
    Reviewed-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/camera.c b/drivers/staging/greybus/camera.c
index dda871912c10..d5496f8a7b89 100644
--- a/drivers/staging/greybus/camera.c
+++ b/drivers/staging/greybus/camera.c
@@ -883,8 +883,7 @@ static int gb_camera_debugfs_init(struct gb_camera *gcam)
 
 static void gb_camera_debugfs_cleanup(struct gb_camera *gcam)
 {
-	if (gcam->debugfs.root)
-		debugfs_remove_recursive(gcam->debugfs.root);
+	debugfs_remove_recursive(gcam->debugfs.root);
 
 	vfree(gcam->debugfs.buffers);
 }

commit f9340fc7dd9f42edfcd7a0e332798ae01a6b48ac
Author: Alex Elder <elder@linaro.org>
Date:   Tue May 24 13:34:47 2016 -0500

    greybus: report right error value
    
    Running "make coccicheck" on the Greybus code discovered that
    an error message in gb_camera_debugfs_init() was interpreting
    the wrong value in reporting the error code.  Fix that.
    
    Signed-off-by: Alex Elder <elder@linaro.org>
    Reviewed-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/camera.c b/drivers/staging/greybus/camera.c
index dd482bd94637..dda871912c10 100644
--- a/drivers/staging/greybus/camera.c
+++ b/drivers/staging/greybus/camera.c
@@ -873,7 +873,7 @@ static int gb_camera_debugfs_init(struct gb_camera *gcam)
 		if (IS_ERR(dentry)) {
 			gcam_err(gcam,
 				 "debugfs operation %s create failed (%ld)\n",
-				 entry->name, PTR_ERR(gcam->debugfs.root));
+				 entry->name, PTR_ERR(dentry));
 			return PTR_ERR(dentry);
 		}
 	}

commit 91a8030f781d27e84661c4a4edf1e108bfc1c594
Author: Jeffrey Carlyle <jcarlyle@google.com>
Date:   Wed May 25 16:38:47 2016 -0700

    greybus: Revert "update UniPro Set Interface Power Mode operation to match spec"
    
    This reverts commit 29fee8c55b59bb6ac59b99a0563c89c514cba42b.
    
    This change and its companion NuttX changes seem to be triggering a
    storm of POWERMODEIND switch interrupts on the SVC.
    
    Signed-off-by: Jeffrey Carlyle <jcarlyle@google.com>
    Acked-by: Sandeep Patil <sspatil@google.com>

diff --git a/drivers/staging/greybus/camera.c b/drivers/staging/greybus/camera.c
index 654bfcd852a2..dd482bd94637 100644
--- a/drivers/staging/greybus/camera.c
+++ b/drivers/staging/greybus/camera.c
@@ -121,23 +121,17 @@ static int gb_camera_set_intf_power_mode(struct gb_camera *gcam, u8 intf_id,
 		ret = gb_svc_intf_set_power_mode(svc, intf_id,
 						 GB_SVC_UNIPRO_HS_SERIES_A,
 						 GB_SVC_UNIPRO_FAST_MODE, 2, 2,
-						 GB_SVC_SMALL_AMPLITUDE,
-						 GB_SVC_NO_DE_EMPHASIS,
 						 GB_SVC_UNIPRO_FAST_MODE, 2, 2,
 						 GB_SVC_PWRM_RXTERMINATION |
-						 GB_SVC_PWRM_TXTERMINATION, 0,
-						 NULL, NULL);
+						 GB_SVC_PWRM_TXTERMINATION, 0);
 	else
 		ret = gb_svc_intf_set_power_mode(svc, intf_id,
 						 GB_SVC_UNIPRO_HS_SERIES_A,
 						 GB_SVC_UNIPRO_SLOW_AUTO_MODE,
 						 2, 1,
-						 GB_SVC_SMALL_AMPLITUDE,
-						 GB_SVC_NO_DE_EMPHASIS,
 						 GB_SVC_UNIPRO_SLOW_AUTO_MODE,
 						 2, 1,
-						 0, 0,
-						 NULL, NULL);
+						 0, 0);
 
 	return ret;
 }

commit 00606367141cf518e94d8354a02d298475de67e5
Author: Eli Sennesh <esennesh@leaflabs.com>
Date:   Mon May 16 14:55:17 2016 -0400

    greybus: update UniPro Set Interface Power Mode operation to match spec
    
    Bring the gb_svc_intf_set_power_mode() up-to-date with the current Greybus
    specification.  This largely involves adding more members to the structure
    sent across the wire.  Also change the camera code to use the new
    operation properly, with default values passed for the new necessary
    arguments.  The correctness of these default values is confirmed via testing
    and by asking Rob Johnson.
    
    Testing Done: Took a picture with a camera module, received error code
    when passing deliberately incorrect values for new parameters, got proper
    -EIO and Greybus result code printed when operation stopped halfway
    through.
    
    Associated Firmware Changes: 6810-6812 on Gerrit for SW-1239, 6870 and
    5612-5613 on Gerrit for SW-2945
    
    Signed-off-by: Eli Sennesh <esennesh@leaflabs.com>
    Reviewed-by: Alex Elder <elder@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/camera.c b/drivers/staging/greybus/camera.c
index dd482bd94637..654bfcd852a2 100644
--- a/drivers/staging/greybus/camera.c
+++ b/drivers/staging/greybus/camera.c
@@ -121,17 +121,23 @@ static int gb_camera_set_intf_power_mode(struct gb_camera *gcam, u8 intf_id,
 		ret = gb_svc_intf_set_power_mode(svc, intf_id,
 						 GB_SVC_UNIPRO_HS_SERIES_A,
 						 GB_SVC_UNIPRO_FAST_MODE, 2, 2,
+						 GB_SVC_SMALL_AMPLITUDE,
+						 GB_SVC_NO_DE_EMPHASIS,
 						 GB_SVC_UNIPRO_FAST_MODE, 2, 2,
 						 GB_SVC_PWRM_RXTERMINATION |
-						 GB_SVC_PWRM_TXTERMINATION, 0);
+						 GB_SVC_PWRM_TXTERMINATION, 0,
+						 NULL, NULL);
 	else
 		ret = gb_svc_intf_set_power_mode(svc, intf_id,
 						 GB_SVC_UNIPRO_HS_SERIES_A,
 						 GB_SVC_UNIPRO_SLOW_AUTO_MODE,
 						 2, 1,
+						 GB_SVC_SMALL_AMPLITUDE,
+						 GB_SVC_NO_DE_EMPHASIS,
 						 GB_SVC_UNIPRO_SLOW_AUTO_MODE,
 						 2, 1,
-						 0, 0);
+						 0, 0,
+						 NULL, NULL);
 
 	return ret;
 }

commit 68b66c28010ebc2ebe21d6bad2de2eda1bed01fc
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Fri May 20 14:33:35 2016 +0300

    greybus: camera: Convert to bundle driver
    
    Convert the legacy camera protocol driver to a bundle driver.
    
    Modules now can (and must) declare the camera data cport in their
    manifest as the data connection isn't hardcoded anymore.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Johan Hovold <johan@hovoldconsulting.com>
    Reviewed-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/camera.c b/drivers/staging/greybus/camera.c
index 4831ad652c04..dd482bd94637 100644
--- a/drivers/staging/greybus/camera.c
+++ b/drivers/staging/greybus/camera.c
@@ -36,11 +36,11 @@ struct gb_camera_debugfs_buffer {
 /**
  * struct gb_camera - A Greybus Camera Device
  * @connection: the greybus connection for camera control
- * @data_connected: whether the data connection has been established
  * @debugfs: debugfs entries for camera protocol operations testing
  * @module: Greybus camera module registered to HOST processor.
  */
 struct gb_camera {
+	struct gb_bundle *bundle;
 	struct gb_connection *connection;
 	struct gb_connection *data_connection;
 
@@ -103,12 +103,9 @@ static const struct gb_camera_fmt_map mbus_to_gbus_format[] = {
 
 #define GB_CAMERA_MAX_SETTINGS_SIZE	8192
 
-#define gcam_dbg(gcam, format...) \
-	dev_dbg(&gcam->connection->bundle->dev, format)
-#define gcam_info(gcam, format...) \
-	dev_info(&gcam->connection->bundle->dev, format)
-#define gcam_err(gcam, format...) \
-	dev_err(&gcam->connection->bundle->dev, format)
+#define gcam_dbg(gcam, format...)	dev_dbg(&gcam->bundle->dev, format)
+#define gcam_info(gcam, format...)	dev_info(&gcam->bundle->dev, format)
+#define gcam_err(gcam, format...)	dev_err(&gcam->bundle->dev, format)
 
 /* -----------------------------------------------------------------------------
  * Camera Protocol Operations
@@ -383,14 +380,14 @@ static int gb_camera_flush(struct gb_camera *gcam, u32 *request_id)
 	return 0;
 }
 
-static int gb_camera_event_recv(u8 type, struct gb_operation *op)
+static int gb_camera_request_handler(struct gb_operation *op)
 {
 	struct gb_camera *gcam = gb_connection_get_data(op->connection);
 	struct gb_camera_metadata_request *payload;
 	struct gb_message *request;
 
-	if (type != GB_CAMERA_TYPE_METADATA) {
-		gcam_err(gcam, "Unsupported unsolicited event: %u\n", type);
+	if (op->type != GB_CAMERA_TYPE_METADATA) {
+		gcam_err(gcam, "Unsupported unsolicited event: %u\n", op->type);
 		return -EINVAL;
 	}
 
@@ -849,7 +846,7 @@ static int gb_camera_debugfs_init(struct gb_camera *gcam)
 	 * Create root debugfs entry and a file entry for each camera operation.
 	 */
 	snprintf(dirname, 27, "camera-%u.%u", connection->intf->interface_id,
-		 connection->bundle->id);
+		 gcam->bundle->id);
 
 	gcam->debugfs.root = debugfs_create_dir(dirname, gb_debugfs_get());
 	if (IS_ERR(gcam->debugfs.root)) {
@@ -905,39 +902,84 @@ static void gb_camera_cleanup(struct gb_camera *gcam)
 		gb_connection_destroy(gcam->data_connection);
 	}
 
+	if (gcam->connection) {
+		gb_connection_disable(gcam->connection);
+		gb_connection_destroy(gcam->connection);
+	}
+
 	kfree(gcam);
 }
 
-static int gb_camera_connection_init(struct gb_connection *connection)
+static int gb_camera_probe(struct gb_bundle *bundle,
+			   const struct greybus_bundle_id *id)
 {
-	struct gb_connection *data;
+	struct gb_connection *conn;
 	struct gb_camera *gcam;
-	unsigned long data_flags;
+	u16 mgmt_cport_id = 0;
+	u16 data_cport_id = 0;
+	unsigned int i;
 	int ret;
 
+	/*
+	 * The camera bundle must contain exactly two CPorts, one for the
+	 * camera management protocol and one for the camera data protocol.
+	 */
+	if (bundle->num_cports != 2)
+		return -ENODEV;
+
+	for (i = 0; i < bundle->num_cports; ++i) {
+		struct greybus_descriptor_cport *desc = &bundle->cport_desc[i];
+
+		switch (desc->protocol_id) {
+		case GREYBUS_PROTOCOL_CAMERA_MGMT:
+			mgmt_cport_id = le16_to_cpu(desc->id);
+			break;
+		case GREYBUS_PROTOCOL_CAMERA_DATA:
+			data_cport_id = le16_to_cpu(desc->id);
+			break;
+		default:
+			return -ENODEV;
+		}
+	}
+
+	if (!mgmt_cport_id || !data_cport_id)
+		return -ENODEV;
+
 	gcam = kzalloc(sizeof(*gcam), GFP_KERNEL);
 	if (!gcam)
 		return -ENOMEM;
 
-	gcam->connection = connection;
-	gb_connection_set_data(connection, gcam);
+	gcam->bundle = bundle;
+
+	conn = gb_connection_create(bundle, mgmt_cport_id,
+				    gb_camera_request_handler);
+	if (IS_ERR(conn)) {
+		ret = PTR_ERR(conn);
+		goto error;
+	}
+
+	gcam->connection = conn;
+	gb_connection_set_data(conn, gcam);
+
+	ret = gb_connection_enable(conn);
+	if (ret)
+		goto error;
 
 	/*
-	 * Create the data connection between camera module CDSI0 and APB CDS1.
-	 * The CPort IDs are hardcoded by the ES2 bridges.
+	 * Create the data connection between the camera module data CPort and
+	 * APB CDSI1. The CDSI1 CPort ID is hardcoded by the ES2 bridge.
 	 */
-	data_flags = GB_CONNECTION_FLAG_NO_FLOWCTRL | GB_CONNECTION_FLAG_CDSI1;
-
-	data = gb_connection_create_offloaded(connection->bundle,
-					      ES2_APB_CDSI0_CPORT,
-					      data_flags);
-	if (IS_ERR(data)) {
-		ret = PTR_ERR(data);
+	conn = gb_connection_create_offloaded(bundle, data_cport_id,
+					      GB_CONNECTION_FLAG_NO_FLOWCTRL |
+					      GB_CONNECTION_FLAG_CDSI1);
+	if (IS_ERR(conn)) {
+		ret = PTR_ERR(conn);
 		goto error;
 	}
-	gcam->data_connection = data;
+	gcam->data_connection = conn;
+	gb_connection_set_data(conn, gcam);
 
-	ret = gb_connection_enable(data);
+	ret = gb_connection_enable(conn);
 	if (ret)
 		goto error;
 
@@ -949,6 +991,8 @@ static int gb_camera_connection_init(struct gb_connection *connection)
 	if (ret < 0)
 		goto error;
 
+	greybus_set_drvdata(bundle, gcam);
+
 	return 0;
 
 error:
@@ -956,25 +1000,26 @@ static int gb_camera_connection_init(struct gb_connection *connection)
 	return ret;
 }
 
-static void gb_camera_connection_exit(struct gb_connection *connection)
+static void gb_camera_disconnect(struct gb_bundle *bundle)
 {
-	struct gb_camera *gcam = gb_connection_get_data(connection);
+	struct gb_camera *gcam = greybus_get_drvdata(bundle);
 
 	gb_camera_unregister_intf_ops(gcam);
-
 	gb_camera_cleanup(gcam);
 }
 
-static struct gb_protocol camera_protocol = {
-	.name			= "camera",
-	.id			= GREYBUS_PROTOCOL_CAMERA_MGMT,
-	.major			= GB_CAMERA_VERSION_MAJOR,
-	.minor			= GB_CAMERA_VERSION_MINOR,
-	.connection_init	= gb_camera_connection_init,
-	.connection_exit	= gb_camera_connection_exit,
-	.request_recv		= gb_camera_event_recv,
+static const struct greybus_bundle_id gb_camera_id_table[] = {
+	{ GREYBUS_DEVICE_CLASS(GREYBUS_CLASS_CAMERA) },
+	{ },
+};
+
+static struct greybus_driver gb_camera_driver = {
+	.name		= "camera",
+	.probe		= gb_camera_probe,
+	.disconnect	= gb_camera_disconnect,
+	.id_table	= gb_camera_id_table,
 };
 
-gb_protocol_driver(&camera_protocol);
+module_greybus_driver(gb_camera_driver);
 
 MODULE_LICENSE("GPL v2");

commit 3ba9fa5c9220e5a6dbbe0b88fc40f857f299b040
Author: Johan Hovold <johan@hovoldconsulting.com>
Date:   Wed May 11 10:18:06 2016 +0200

    greybus: camera: fix data-connection handling
    
    Now that core supports offloaded connections, we can remove the hack
    that was used to setup the data connection.
    
    Note that offloaded-resource management may need to be refined later,
    but the current minimal implementation is enough to allow core to manage
    the connections (e.g. needed for proper connection tear down and power
    management).
    
    This will also allow the camera driver to be converted to a bundle
    driver.
    
    Signed-off-by: Johan Hovold <johan@hovoldconsulting.com>
    Reviewed-by: Laurent Pinchart <laurent.pinchart@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/camera.c b/drivers/staging/greybus/camera.c
index ba76f5633256..4831ad652c04 100644
--- a/drivers/staging/greybus/camera.c
+++ b/drivers/staging/greybus/camera.c
@@ -42,7 +42,7 @@ struct gb_camera_debugfs_buffer {
  */
 struct gb_camera {
 	struct gb_connection *connection;
-	bool data_connected;
+	struct gb_connection *data_connection;
 
 	struct {
 		struct dentry *root;
@@ -900,13 +900,9 @@ static void gb_camera_cleanup(struct gb_camera *gcam)
 {
 	gb_camera_debugfs_cleanup(gcam);
 
-	if (gcam->data_connected) {
-		struct gb_interface *intf = gcam->connection->intf;
-		struct gb_svc *svc = gcam->connection->hd->svc;
-
-		gb_svc_connection_destroy(svc, intf->interface_id,
-					  ES2_APB_CDSI0_CPORT, svc->ap_intf_id,
-					  ES2_APB_CDSI1_CPORT);
+	if (gcam->data_connection) {
+		gb_connection_disable(gcam->data_connection);
+		gb_connection_destroy(gcam->data_connection);
 	}
 
 	kfree(gcam);
@@ -914,9 +910,9 @@ static void gb_camera_cleanup(struct gb_camera *gcam)
 
 static int gb_camera_connection_init(struct gb_connection *connection)
 {
-	struct gb_svc *svc = connection->hd->svc;
+	struct gb_connection *data;
 	struct gb_camera *gcam;
-	u8 cport_flags;
+	unsigned long data_flags;
 	int ret;
 
 	gcam = kzalloc(sizeof(*gcam), GFP_KERNEL);
@@ -930,14 +926,20 @@ static int gb_camera_connection_init(struct gb_connection *connection)
 	 * Create the data connection between camera module CDSI0 and APB CDS1.
 	 * The CPort IDs are hardcoded by the ES2 bridges.
 	 */
-	cport_flags = GB_SVC_CPORT_FLAG_CSD_N | GB_SVC_CPORT_FLAG_CSV_N;
-	ret = gb_svc_connection_create(svc, connection->intf->interface_id,
-				       ES2_APB_CDSI0_CPORT, svc->ap_intf_id,
-				       ES2_APB_CDSI1_CPORT, cport_flags);
-	if (ret < 0)
+	data_flags = GB_CONNECTION_FLAG_NO_FLOWCTRL | GB_CONNECTION_FLAG_CDSI1;
+
+	data = gb_connection_create_offloaded(connection->bundle,
+					      ES2_APB_CDSI0_CPORT,
+					      data_flags);
+	if (IS_ERR(data)) {
+		ret = PTR_ERR(data);
 		goto error;
+	}
+	gcam->data_connection = data;
 
-	gcam->data_connected = true;
+	ret = gb_connection_enable(data);
+	if (ret)
+		goto error;
 
 	ret = gb_camera_debugfs_init(gcam);
 	if (ret < 0)

commit ee2f2074fdb20d4939c943d0372f3751d833dedf
Author: Mitchell Tasman <tasman@leaflabs.com>
Date:   Wed May 4 17:30:23 2016 -0400

    greybus: svc: reconfig APBridgeA-Switch link to handle required load
    
    SW-4894, SW-4389, and share a common root cause, namely that
    the power-on reset configuration of the APBridgeA-Switch link of PWM
    Gear 1, 1 Lane, Slow Auto, is insufficient to handle some required
    traffic loads, such as 3 audio streams plus boot-over-UniPro or 4 audio
    streams.
    
    The correct long-term solution is to implement a UniPro Power Mode
    Manager as in that considers the demands placed on the network,
    and adjusts power modes accordingly.
    
    The present commit implements a short-term, brute-force hack to allow
    continued system testing:
    - Upon receiving an SVC HELLO request, schedule deferred work to
      reconfigure the APB1-Switch link to PWM G2, 1 lane, Slow Auto
    - When the Camera driver transitions a White Camera module from active to
      inactive, return the APB1-Switch link to PWM G2, 1 lane, Slow Auto
    
    The Camera driver already steps up the APBridgeA-Camera link speed while a
    camera module is active, which affords sufficient margin for simultaneous
    audio and hotplug activity, and the Camera driver already steps down the
    link speed thereafter: the change made by the present patch is simply to
    tweak the stepped-down power mode to match the new baseline configuration.
    
    Signed-off-by: Mitchell Tasman <tasman@leaflabs.com>
    Tested-by: Mark Greer <mgreer@animalcreek.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/camera.c b/drivers/staging/greybus/camera.c
index 956fbf05b8e0..ba76f5633256 100644
--- a/drivers/staging/greybus/camera.c
+++ b/drivers/staging/greybus/camera.c
@@ -131,9 +131,9 @@ static int gb_camera_set_intf_power_mode(struct gb_camera *gcam, u8 intf_id,
 		ret = gb_svc_intf_set_power_mode(svc, intf_id,
 						 GB_SVC_UNIPRO_HS_SERIES_A,
 						 GB_SVC_UNIPRO_SLOW_AUTO_MODE,
-						 1, 2,
+						 2, 1,
 						 GB_SVC_UNIPRO_SLOW_AUTO_MODE,
-						 1, 2,
+						 2, 1,
 						 0, 0);
 
 	return ret;

commit 698bdcbf87f3c8a2f998058d58f4baa8ab8e192a
Author: Evgeniy Borisov <borisov_evgeniy@projectara.com>
Date:   Mon Apr 18 16:27:36 2016 +0300

    greybus: camera-gb: Remove hardcode for CSI TX number of lanes
    
    The number of CSI TX lanes is hardcoded to 4. Removing
    this and start using value from configure stream response.
    
    NOTE: The patch depends on the CSI init change:
    "Use GB CSI params to init camera sub-devs"
    
    Signed-off-by: Evgeniy Borisov <eborisov@mm-sol.com>
    Reviewed-by: Gjorgji Rosikopulos <grosikopulos@mm-sol.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/camera.c b/drivers/staging/greybus/camera.c
index d3ee5b7240db..956fbf05b8e0 100644
--- a/drivers/staging/greybus/camera.c
+++ b/drivers/staging/greybus/camera.c
@@ -304,7 +304,7 @@ static int gb_camera_configure_streams(struct gb_camera *gcam,
 	if (nstreams) {
 		csi_cfg.csi_id = 1;
 		csi_cfg.flags = 0;
-		csi_cfg.num_lanes = 4;
+		csi_cfg.num_lanes = resp->num_lanes;
 		csi_cfg.bus_freq = cpu_to_le32(960000000);
 		csi_cfg.lines_per_second = resp->lines_per_second;
 		ret = gb_hd_output(gcam->connection->hd, &csi_cfg,

commit b4905038965fb986d8496e47cc52a08428408ae5
Author: Evgeniy Borisov <borisov_evgeniy@projectara.com>
Date:   Wed Apr 6 15:22:45 2016 +0300

    greybus: camera-gb: Extend the configure streams interface
    
    Extending the configure streams interface with CSI params.
    Getting CSI frequency data form configure streams response.
     * num_lanes - Number of CSI data lanes
     * clk_freq - CSI clock frequency in Hz
     * lines_per_second - Total number of lines in a second of
    transmission (blanking included)
    
    From the AP side we need to know for the CSI speed
    configuration. This information is needed for dynamically
    bandwidth calculations.
    
    NOTE: Change should be along merged with corresponding
          interface change in kernel:
          "camera: Extend the configure streams
          interface with CSI params"
    
    Signed-off-by: Evgeniy Borisov <eborisov@mm-sol.com>
    Reviewed-by: Gjorgji Rosikopulos <grosikopulos@mm-sol.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/camera.c b/drivers/staging/greybus/camera.c
index 6db89efb8f0e..d3ee5b7240db 100644
--- a/drivers/staging/greybus/camera.c
+++ b/drivers/staging/greybus/camera.c
@@ -203,7 +203,8 @@ struct ap_csi_config_request {
 static int gb_camera_configure_streams(struct gb_camera *gcam,
 				       unsigned int *num_streams,
 				       unsigned int *flags,
-				       struct gb_camera_stream_config *streams)
+				       struct gb_camera_stream_config *streams,
+				       struct gb_camera_csi_params *csi_params)
 {
 	struct gb_camera_configure_streams_request *req;
 	struct gb_camera_configure_streams_response *resp;
@@ -309,6 +310,12 @@ static int gb_camera_configure_streams(struct gb_camera *gcam,
 		ret = gb_hd_output(gcam->connection->hd, &csi_cfg,
 				   sizeof(csi_cfg),
 				   GB_APB_REQUEST_CSI_TX_CONTROL, false);
+		if (csi_params) {
+			csi_params->num_lanes = csi_cfg.num_lanes;
+			/* Transmitting two bits per cycle. (DDR clock) */
+			csi_params->clk_freq = csi_cfg.bus_freq / 2;
+			csi_params->lines_per_second = csi_cfg.lines_per_second;
+		}
 	} else {
 		csi_cfg.csi_id = 1;
 		ret = gb_hd_output(gcam->connection->hd, &csi_cfg,
@@ -442,7 +449,8 @@ static ssize_t gb_camera_op_capabilities(void *priv, char *data, size_t len)
 }
 
 static int gb_camera_op_configure_streams(void *priv, unsigned int *nstreams,
-		unsigned int *flags, struct gb_camera_stream *streams)
+		unsigned int *flags, struct gb_camera_stream *streams,
+		struct gb_camera_csi_params *csi_params)
 {
 	struct gb_camera *gcam = priv;
 	struct gb_camera_stream_config *gb_streams;
@@ -469,7 +477,7 @@ static int gb_camera_op_configure_streams(void *priv, unsigned int *nstreams,
 		gb_flags |= GB_CAMERA_CONFIGURE_STREAMS_TEST_ONLY;
 
 	ret = gb_camera_configure_streams(gcam, &gb_nstreams,
-					  &gb_flags, gb_streams);
+					  &gb_flags, gb_streams, csi_params);
 	if (ret < 0)
 		goto done;
 	if (gb_nstreams > *nstreams) {
@@ -643,7 +651,8 @@ static ssize_t gb_camera_debugfs_configure_streams(struct gb_camera *gcam,
 			goto done;
 	}
 
-	ret = gb_camera_configure_streams(gcam, &nstreams, &flags, streams);
+	ret = gb_camera_configure_streams(gcam, &nstreams, &flags, streams,
+					  NULL);
 	if (ret < 0)
 		goto done;
 

commit dc5cc72cc6c219868ad5b87b26c79ac778444210
Author: Gjorgji Rosikopulos <grosikopulos@mm-sol.com>
Date:   Fri Apr 1 17:32:43 2016 +0300

    greybus: camera: Add metadata format
    
    Add support for greybus metadata format.
    Greybus metadata format id is 0x41.
    
    Signed-off-by: Gjorgji Rosikopulos <grosikopulos@mm-sol.com>
    Acked-by: Laurent Pinchart <laurent.pinchart@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/camera.c b/drivers/staging/greybus/camera.c
index 2de91d59a54e..6db89efb8f0e 100644
--- a/drivers/staging/greybus/camera.c
+++ b/drivers/staging/greybus/camera.c
@@ -91,6 +91,10 @@ static const struct gb_camera_fmt_map mbus_to_gbus_format[] = {
 	{
 		.mbus_code = V4L2_MBUS_FMT_JPEG_1X8,
 		.gb_format = 0x40,
+	},
+	{
+		.mbus_code = V4L2_MBUS_FMT_ARA_METADATA_1X8,
+		.gb_format = 0x41,
 	}
 };
 

commit 1472ec67f734d9707d4758fddd4787113fe0b0b2
Author: Gjorgji Rosikopulos <grosikopulos@mm-sol.com>
Date:   Thu Mar 31 14:12:45 2016 +0300

    greybus: camera: Use pointer for gb camera module ops
    
    No need to duplicate module ops on every registration.
    
    NOTE: Change should be along merged with:
    "msm: camera: Change gb_camera_module ops to pointer"
    
    Signed-off-by: Gjorgji Rosikopulos <grosikopulos@mm-sol.com>
    Reviewed-by: Laurent Pinchart <laurent.pinchart@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/camera.c b/drivers/staging/greybus/camera.c
index a871b0f33733..2de91d59a54e 100644
--- a/drivers/staging/greybus/camera.c
+++ b/drivers/staging/greybus/camera.c
@@ -498,23 +498,30 @@ static int gb_camera_op_capture(void *priv, u32 request_id,
 		unsigned int streams, unsigned int num_frames,
 		size_t settings_size, const void *settings)
 {
-	return gb_camera_capture(priv, request_id, streams, num_frames,
+	struct gb_camera *gcam = priv;
+
+	return gb_camera_capture(gcam, request_id, streams, num_frames,
 				 settings_size, settings);
 }
 
 static int gb_camera_op_flush(void *priv, u32 *request_id)
 {
-	return gb_camera_flush(priv, request_id);
+	struct gb_camera *gcam = priv;
+
+	return gb_camera_flush(gcam, request_id);
 }
 
+static const struct gb_camera_ops gb_cam_ops = {
+	.capabilities = gb_camera_op_capabilities,
+	.configure_streams = gb_camera_op_configure_streams,
+	.capture = gb_camera_op_capture,
+	.flush = gb_camera_op_flush,
+};
+
 static int gb_camera_register_intf_ops(struct gb_camera *gcam)
 {
 	gcam->module.priv = gcam;
-	gcam->module.ops.capabilities = gb_camera_op_capabilities;
-	gcam->module.ops.configure_streams = gb_camera_op_configure_streams;
-	gcam->module.ops.capture = gb_camera_op_capture;
-	gcam->module.ops.flush = gb_camera_op_flush;
-
+	gcam->module.ops = &gb_cam_ops;
 	return gb_camera_register(&gcam->module);
 }
 

commit 0ec306324423444d3ee0222708ef9de7f5586b93
Author: Greg Kroah-Hartman <gregkh@google.com>
Date:   Tue Mar 22 14:30:35 2016 -0400

    greybus: convert drivers to use connection->private set/get
    
    This converts all drivers to use the gb_connection_get_data() and
    gb_connection_set_data() functions to make it a bit more explicit as to
    what is going on.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>
    Reviewed-by: Alex Elder <elder@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/camera.c b/drivers/staging/greybus/camera.c
index 722f2b4fe54d..a871b0f33733 100644
--- a/drivers/staging/greybus/camera.c
+++ b/drivers/staging/greybus/camera.c
@@ -374,7 +374,7 @@ static int gb_camera_flush(struct gb_camera *gcam, u32 *request_id)
 
 static int gb_camera_event_recv(u8 type, struct gb_operation *op)
 {
-	struct gb_camera *gcam = op->connection->private;
+	struct gb_camera *gcam = gb_connection_get_data(op->connection);
 	struct gb_camera_metadata_request *payload;
 	struct gb_message *request;
 
@@ -904,7 +904,7 @@ static int gb_camera_connection_init(struct gb_connection *connection)
 		return -ENOMEM;
 
 	gcam->connection = connection;
-	connection->private = gcam;
+	gb_connection_set_data(connection, gcam);
 
 	/*
 	 * Create the data connection between camera module CDSI0 and APB CDS1.
@@ -936,7 +936,7 @@ static int gb_camera_connection_init(struct gb_connection *connection)
 
 static void gb_camera_connection_exit(struct gb_connection *connection)
 {
-	struct gb_camera *gcam = connection->private;
+	struct gb_camera *gcam = gb_connection_get_data(connection);
 
 	gb_camera_unregister_intf_ops(gcam);
 

commit c3d77f71308e38ef98909c317c57d906f4d51cb9
Author: Gjorgji Rosikopulos <grosikopulos@mm-sol.com>
Date:   Mon Mar 14 18:44:53 2016 +0200

    greybus: camera: Improve module registration mechanism
    
    Registering more then one module at same time was not
    possible with previous implementation. Also unregistering
    of the module was missing leading to many instability issues
    when camera module is ejected when camera is still active.
    
    Signed-off-by: Gjorgji Rosikopulos <grosikopulos@mm-sol.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/camera.c b/drivers/staging/greybus/camera.c
index e862659a5ccc..722f2b4fe54d 100644
--- a/drivers/staging/greybus/camera.c
+++ b/drivers/staging/greybus/camera.c
@@ -38,6 +38,7 @@ struct gb_camera_debugfs_buffer {
  * @connection: the greybus connection for camera control
  * @data_connected: whether the data connection has been established
  * @debugfs: debugfs entries for camera protocol operations testing
+ * @module: Greybus camera module registered to HOST processor.
  */
 struct gb_camera {
 	struct gb_connection *connection;
@@ -47,6 +48,8 @@ struct gb_camera {
 		struct dentry *root;
 		struct gb_camera_debugfs_buffer *buffers;
 	} debugfs;
+
+	struct gb_camera_module module;
 };
 
 struct gb_camera_stream_config {
@@ -504,16 +507,20 @@ static int gb_camera_op_flush(void *priv, u32 *request_id)
 	return gb_camera_flush(priv, request_id);
 }
 
-struct gb_camera_ops gb_cam_ops = {
-	.capabilities = gb_camera_op_capabilities,
-	.configure_streams = gb_camera_op_configure_streams,
-	.capture = gb_camera_op_capture,
-	.flush = gb_camera_op_flush,
-};
-
 static int gb_camera_register_intf_ops(struct gb_camera *gcam)
 {
-	return gb_camera_register(&gb_cam_ops, gcam);
+	gcam->module.priv = gcam;
+	gcam->module.ops.capabilities = gb_camera_op_capabilities;
+	gcam->module.ops.configure_streams = gb_camera_op_configure_streams;
+	gcam->module.ops.capture = gb_camera_op_capture;
+	gcam->module.ops.flush = gb_camera_op_flush;
+
+	return gb_camera_register(&gcam->module);
+}
+
+static int gb_camera_unregister_intf_ops(struct gb_camera *gcam)
+{
+	return gb_camera_unregister(&gcam->module);
 }
 
 /* -----------------------------------------------------------------------------
@@ -931,6 +938,8 @@ static void gb_camera_connection_exit(struct gb_connection *connection)
 {
 	struct gb_camera *gcam = connection->private;
 
+	gb_camera_unregister_intf_ops(gcam);
+
 	gb_camera_cleanup(gcam);
 }
 

commit a883b0eb434c6ad0237b559b1b5c8cee89ef6350
Author: Jacopo Mondi <jacopo.mondi@linaro.org>
Date:   Thu Mar 17 11:02:03 2016 +0100

    greybus: camera: Register capabilities operation
    
    Register the greybus camera driver capabilities operation to the
    ara_camera subdevice
    
    Signed-off-by: Jacopo Mondi <jacopo.mondi@linaro.org>
    Reviewed-by: Gjorgji Rosikopulos <grosikopulos@mm-sol.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/camera.c b/drivers/staging/greybus/camera.c
index 6042c681b8b6..e862659a5ccc 100644
--- a/drivers/staging/greybus/camera.c
+++ b/drivers/staging/greybus/camera.c
@@ -421,6 +421,19 @@ static enum v4l2_mbus_pixelcode gb_camera_gb_to_mbus(u16 gb_fmt)
 	return mbus_to_gbus_format[0].mbus_code;
 }
 
+static ssize_t gb_camera_op_capabilities(void *priv, char *data, size_t len)
+{
+	struct gb_camera *gcam = priv;
+	size_t capabilities_len = len;
+	int ret;
+
+	ret = gb_camera_capabilities(gcam, data, &capabilities_len);
+	if (ret)
+		return ret;
+
+	return capabilities_len;
+}
+
 static int gb_camera_op_configure_streams(void *priv, unsigned int *nstreams,
 		unsigned int *flags, struct gb_camera_stream *streams)
 {
@@ -492,6 +505,7 @@ static int gb_camera_op_flush(void *priv, u32 *request_id)
 }
 
 struct gb_camera_ops gb_cam_ops = {
+	.capabilities = gb_camera_op_capabilities,
 	.configure_streams = gb_camera_op_configure_streams,
 	.capture = gb_camera_op_capture,
 	.flush = gb_camera_op_flush,

commit 48b15a9b119d945933bfed6204d51e071d35328b
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Thu Mar 17 11:02:02 2016 +0100

    greybus: camera: Implement the capabilities operation
    
    The operation queries the camera module for its capabilities. The
    debugfs interface just prints a hex dump of the binary message.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Jacopo Mondi <jacopo.mondi@linaro.org>
    Reviewed-by: Gjorgji Rosikopulos <grosikopulos@mm-sol.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/camera.c b/drivers/staging/greybus/camera.c
index d499ffdb786b..6042c681b8b6 100644
--- a/drivers/staging/greybus/camera.c
+++ b/drivers/staging/greybus/camera.c
@@ -156,6 +156,33 @@ static int gb_camera_set_power_mode(struct gb_camera *gcam, bool hs)
 	return 0;
 }
 
+static int gb_camera_capabilities(struct gb_camera *gcam,
+				  u8 *capabilities, size_t *size)
+{
+	struct gb_operation *op;
+	int ret;
+
+	op = gb_operation_create_flags(gcam->connection,
+				       GB_CAMERA_TYPE_CAPABILITIES, 0, *size,
+				       GB_OPERATION_FLAG_SHORT_RESPONSE,
+				       GFP_KERNEL);
+	if (!op)
+		return -ENOMEM;
+
+	ret = gb_operation_request_send_sync(op);
+	if (ret) {
+		gcam_err(gcam, "failed to retrieve capabilities: %d\n", ret);
+		goto done;
+	}
+
+	memcpy(capabilities, op->response->payload, op->response->payload_size);
+	*size = op->response->payload_size;
+
+done:
+	gb_operation_put(op);
+	return ret;
+}
+
 struct ap_csi_config_request {
 	__u8 csi_id;
 	__u8 flags;
@@ -478,10 +505,41 @@ static int gb_camera_register_intf_ops(struct gb_camera *gcam)
 /* -----------------------------------------------------------------------------
  * DebugFS
  */
+
 static ssize_t gb_camera_debugfs_capabilities(struct gb_camera *gcam,
 		char *buf, size_t len)
 {
-	return len;
+	struct gb_camera_debugfs_buffer *buffer =
+		&gcam->debugfs.buffers[GB_CAMERA_DEBUGFS_BUFFER_CAPABILITIES];
+	size_t size = 1024;
+	unsigned int i;
+	u8 *caps;
+	int ret;
+
+	caps = kmalloc(size, GFP_KERNEL);
+	if (!caps)
+		return -ENOMEM;
+
+	ret = gb_camera_capabilities(gcam, caps, &size);
+	if (ret < 0)
+		goto done;
+
+	/*
+	 * hex_dump_to_buffer() doesn't return the number of bytes dumped prior
+	 * to v4.0, we need our own implementation :-(
+	 */
+	buffer->length = 0;
+
+	for (i = 0; i < size; i += 16) {
+		unsigned int nbytes = min_t(unsigned int, size - i, 16);
+
+		buffer->length += sprintf(buffer->data + buffer->length,
+					  "%*ph\n", nbytes, caps + i);
+	}
+
+done:
+	kfree(caps);
+	return ret;
 }
 
 static ssize_t gb_camera_debugfs_configure_streams(struct gb_camera *gcam,

commit 53f965065a5eb067621e4734fee9719942976a86
Author: Fabien Parent <fparent@baylibre.com>
Date:   Fri Mar 4 17:32:20 2016 +0100

    greybus: camera: disable E2EFC on CSI connection
    
    Following Toshiba's recommendation we shouldn't use E2EFC on a CSI connection.
    Disable E2EFC on the CSI connection.
    
    Signed-off-by: Fabien Parent <fparent@baylibre.com>
    Acked-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/camera.c b/drivers/staging/greybus/camera.c
index 3ca585f08b85..d499ffdb786b 100644
--- a/drivers/staging/greybus/camera.c
+++ b/drivers/staging/greybus/camera.c
@@ -831,9 +831,7 @@ static int gb_camera_connection_init(struct gb_connection *connection)
 	 * Create the data connection between camera module CDSI0 and APB CDS1.
 	 * The CPort IDs are hardcoded by the ES2 bridges.
 	 */
-	/* FIXME: remove E2EFC */
-	cport_flags = GB_SVC_CPORT_FLAG_E2EFC | GB_SVC_CPORT_FLAG_CSD_N |
-			GB_SVC_CPORT_FLAG_CSV_N;
+	cport_flags = GB_SVC_CPORT_FLAG_CSD_N | GB_SVC_CPORT_FLAG_CSV_N;
 	ret = gb_svc_connection_create(svc, connection->intf->interface_id,
 				       ES2_APB_CDSI0_CPORT, svc->ap_intf_id,
 				       ES2_APB_CDSI1_CPORT, cport_flags);

commit 27f25c17ad7fa2b24a24a4e617077dec20a026ce
Author: Johan Hovold <johan@hovoldconsulting.com>
Date:   Thu Mar 3 13:34:38 2016 +0100

    greybus: connection: generalise CPortFlags handling
    
    Generalise the svc connection-create helper to accept a cport-flags
    argument and handle the flags in the connection code instead.
    
    Note that the camera driver currently manages its data connection
    directly. We keep E2EFC enabled for now even though it will soon need
    to be disabled due to some pending firmware updates.
    
    Reviewed-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Johan Hovold <johan@hovoldconsulting.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/camera.c b/drivers/staging/greybus/camera.c
index 444e218e15ab..3ca585f08b85 100644
--- a/drivers/staging/greybus/camera.c
+++ b/drivers/staging/greybus/camera.c
@@ -817,6 +817,7 @@ static int gb_camera_connection_init(struct gb_connection *connection)
 {
 	struct gb_svc *svc = connection->hd->svc;
 	struct gb_camera *gcam;
+	u8 cport_flags;
 	int ret;
 
 	gcam = kzalloc(sizeof(*gcam), GFP_KERNEL);
@@ -830,9 +831,12 @@ static int gb_camera_connection_init(struct gb_connection *connection)
 	 * Create the data connection between camera module CDSI0 and APB CDS1.
 	 * The CPort IDs are hardcoded by the ES2 bridges.
 	 */
+	/* FIXME: remove E2EFC */
+	cport_flags = GB_SVC_CPORT_FLAG_E2EFC | GB_SVC_CPORT_FLAG_CSD_N |
+			GB_SVC_CPORT_FLAG_CSV_N;
 	ret = gb_svc_connection_create(svc, connection->intf->interface_id,
 				       ES2_APB_CDSI0_CPORT, svc->ap_intf_id,
-				       ES2_APB_CDSI1_CPORT, false);
+				       ES2_APB_CDSI1_CPORT, cport_flags);
 	if (ret < 0)
 		goto error;
 

commit 27e18d8c6967f554b374a713c6bd21bcc985389b
Author: Jacopo Mondi <jacopo.mondi@linaro.org>
Date:   Tue Feb 23 11:22:49 2016 +0100

    greybus: camera: Rename clock_mode to flags
    
    Rename the 'clock_mode' parameter to a more generic 'flags' in the csi
    bus configuration structure.
    Define flags value for continuous clock mode.
    
    Signed-off-by: Jacopo Mondi <jacopo.mondi@linaro.org>
    Acked-by: Laurent Pinchart <laurent.pinchart@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/camera.c b/drivers/staging/greybus/camera.c
index 3f205cbcb21b..444e218e15ab 100644
--- a/drivers/staging/greybus/camera.c
+++ b/drivers/staging/greybus/camera.c
@@ -158,7 +158,8 @@ static int gb_camera_set_power_mode(struct gb_camera *gcam, bool hs)
 
 struct ap_csi_config_request {
 	__u8 csi_id;
-	__u8 clock_mode;
+	__u8 flags;
+#define GB_CAMERA_CSI_FLAG_CLOCK_CONTINUOUS 0x01
 	__u8 num_lanes;
 	__u8 padding;
 	__le32 bus_freq;
@@ -267,7 +268,7 @@ static int gb_camera_configure_streams(struct gb_camera *gcam,
 
 	if (nstreams) {
 		csi_cfg.csi_id = 1;
-		csi_cfg.clock_mode = 0;
+		csi_cfg.flags = 0;
 		csi_cfg.num_lanes = 4;
 		csi_cfg.bus_freq = cpu_to_le32(960000000);
 		csi_cfg.lines_per_second = resp->lines_per_second;

commit 446091c999388f9365e8d206f70b0c1a860212a0
Author: Jacopo Mondi <jacopo.mondi@linaro.org>
Date:   Tue Feb 23 11:22:48 2016 +0100

    greybus: camera: Add CSI configuration parameters
    
    Add CSI configuration parameters to the configure_stream operation
    response.
    Currently, only the total number of lines in a second is used to configure the
    the AP-Bridge CSI transmitter, all other parameters (number of CSI data
    lanes, and CSI bus clock frequency) are kept hard-coded for two reasons:
    1) We need to configure the CSI receiver on AP side accordingly to these
    settings, before sending them to APB1 CSI transmitter.
    2) We cannot use the camera module provided parameters as-is, but use
    those information to compute the required bandwidth on the CSI bus, and
    configure the # of CSI data lanes, and the CSI bus clock speed in a way that
    satisfies that bandwidth requirement.
    
    Signed-off-by: Jacopo Mondi <jacopo.mondi@linaro.org>
    Acked-by: Laurent Pinchart <laurent.pinchart@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/camera.c b/drivers/staging/greybus/camera.c
index bb8bc175dc0a..3f205cbcb21b 100644
--- a/drivers/staging/greybus/camera.c
+++ b/drivers/staging/greybus/camera.c
@@ -162,6 +162,7 @@ struct ap_csi_config_request {
 	__u8 num_lanes;
 	__u8 padding;
 	__le32 bus_freq;
+	__le32 lines_per_second;
 } __packed;
 
 static int gb_camera_configure_streams(struct gb_camera *gcam,
@@ -254,7 +255,14 @@ static int gb_camera_configure_streams(struct gb_camera *gcam,
 	if (ret < 0)
 		goto done;
 
-	/* Configure the CSI transmitter. Hardcode the parameters for now. */
+	/*
+	 * Configure the APB1 CSI transmitter using the lines count reported by
+	 * the  camera module, but with hard-coded bus frequency and lanes number.
+	 *
+	 * TODO: use the clocking and size informations reported by camera module
+	 * to compute the required CSI bandwidth, and configure the CSI receiver
+	 * on AP side, and the CSI transmitter on APB1 side accordingly.
+	 */
 	memset(&csi_cfg, 0, sizeof(csi_cfg));
 
 	if (nstreams) {
@@ -262,6 +270,7 @@ static int gb_camera_configure_streams(struct gb_camera *gcam,
 		csi_cfg.clock_mode = 0;
 		csi_cfg.num_lanes = 4;
 		csi_cfg.bus_freq = cpu_to_le32(960000000);
+		csi_cfg.lines_per_second = resp->lines_per_second;
 		ret = gb_hd_output(gcam->connection->hd, &csi_cfg,
 				   sizeof(csi_cfg),
 				   GB_APB_REQUEST_CSI_TX_CONTROL, false);

commit 640924d2172da9b6f8a0c9372c3ea3b83f68e2f8
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Sun Feb 14 02:33:07 2016 +0200

    greybus: camera: Don't configure CSI TX in test only mode
    
    When the GB_CAMERA_CONFIGURE_STREAMS_TEST_ONLY flag is set by the caller
    the configure streams operation should only test the requested settings
    without modifying the hardware state. This applies for both the module,
    the UniPro links power modes and the AP bridge settings. Return early
    when the flag is set to avoid modifying the AP bridge CSI TX settings.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Gjorgji Rosikopulos <grosikopulos@mm-sol.com>
    Tested-by: Jacopo Mondi <jacopo.mondi@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/camera.c b/drivers/staging/greybus/camera.c
index 7eef6eceec6c..bb8bc175dc0a 100644
--- a/drivers/staging/greybus/camera.c
+++ b/drivers/staging/greybus/camera.c
@@ -242,26 +242,21 @@ static int gb_camera_configure_streams(struct gb_camera *gcam,
 		}
 	}
 
-	if (nstreams && resp->flags & GB_CAMERA_CONFIGURE_STREAMS_ADJUSTED) {
+	if ((resp->flags & GB_CAMERA_CONFIGURE_STREAMS_ADJUSTED) ||
+	    (*flags & GB_CAMERA_CONFIGURE_STREAMS_TEST_ONLY)) {
 		*flags = resp->flags;
 		*num_streams = resp->num_streams;
 		goto done;
 	}
 
 	/* Setup unipro link speed. */
-	if (nstreams && !(*flags & GB_CAMERA_CONFIGURE_STREAMS_TEST_ONLY)) {
-		ret = gb_camera_set_power_mode(gcam, true);
-		if (ret < 0)
-			goto done;
-	} else if (nstreams == 0) {
-		ret = gb_camera_set_power_mode(gcam, false);
-		if (ret < 0)
-			goto done;
-	}
+	ret = gb_camera_set_power_mode(gcam, nstreams != 0);
+	if (ret < 0)
+		goto done;
 
+	/* Configure the CSI transmitter. Hardcode the parameters for now. */
 	memset(&csi_cfg, 0, sizeof(csi_cfg));
 
-	/* Configure the CSI transmitter. Hardcode the parameters for now. */
 	if (nstreams) {
 		csi_cfg.csi_id = 1;
 		csi_cfg.clock_mode = 0;

commit 66c3607076e7e801ab20077dc2d0ed45693eea10
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Sun Feb 14 02:33:06 2016 +0200

    greybus: camera: Set power mode after configuring streams
    
    There's no need to set the power mode before configuring streams, doing
    it after simplifies code.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Gjorgji Rosikopulos <grosikopulos@mm-sol.com>
    Tested-by: Jacopo Mondi <jacopo.mondi@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/camera.c b/drivers/staging/greybus/camera.c
index 25dbf690e1fc..7eef6eceec6c 100644
--- a/drivers/staging/greybus/camera.c
+++ b/drivers/staging/greybus/camera.c
@@ -192,21 +192,6 @@ static int gb_camera_configure_streams(struct gb_camera *gcam,
 		goto done;
 	}
 
-	/*
-	 * Setup unipro link speed before actually issuing configuration
-	 * to the camera module, to assure unipro network speed is set
-	 * before CSI interfaces gets configured
-	 */
-	if (nstreams && !(*flags & GB_CAMERA_CONFIGURE_STREAMS_TEST_ONLY)) {
-		ret = gb_camera_set_power_mode(gcam, true);
-		if (ret < 0)
-			goto done;
-	} else if (nstreams == 0) {
-		ret = gb_camera_set_power_mode(gcam, false);
-		if (ret < 0)
-			goto done;
-	}
-
 	req->num_streams = nstreams;
 	req->flags = *flags;
 	req->padding = 0;
@@ -224,19 +209,19 @@ static int gb_camera_configure_streams(struct gb_camera *gcam,
 				GB_CAMERA_TYPE_CONFIGURE_STREAMS,
 				req, req_size, resp, resp_size);
 	if (ret < 0)
-		goto set_unipro_slow_mode;
+		goto done;
 
 	if (resp->num_streams > nstreams) {
 		gcam_dbg(gcam, "got #streams %u > request %u\n",
 			 resp->num_streams, nstreams);
 		ret = -EIO;
-		goto set_unipro_slow_mode;
+		goto done;
 	}
 
 	if (resp->padding != 0) {
 		gcam_dbg(gcam, "response padding != 0");
 		ret = -EIO;
-		goto set_unipro_slow_mode;
+		goto done;
 	}
 
 	for (i = 0; i < nstreams; ++i) {
@@ -253,14 +238,25 @@ static int gb_camera_configure_streams(struct gb_camera *gcam,
 		if (cfg->padding[0] || cfg->padding[1] || cfg->padding[2]) {
 			gcam_dbg(gcam, "stream #%u padding != 0", i);
 			ret = -EIO;
-			goto set_unipro_slow_mode;
+			goto done;
 		}
 	}
 
 	if (nstreams && resp->flags & GB_CAMERA_CONFIGURE_STREAMS_ADJUSTED) {
 		*flags = resp->flags;
 		*num_streams = resp->num_streams;
-		goto set_unipro_slow_mode;
+		goto done;
+	}
+
+	/* Setup unipro link speed. */
+	if (nstreams && !(*flags & GB_CAMERA_CONFIGURE_STREAMS_TEST_ONLY)) {
+		ret = gb_camera_set_power_mode(gcam, true);
+		if (ret < 0)
+			goto done;
+	} else if (nstreams == 0) {
+		ret = gb_camera_set_power_mode(gcam, false);
+		if (ret < 0)
+			goto done;
 	}
 
 	memset(&csi_cfg, 0, sizeof(csi_cfg));
@@ -289,13 +285,6 @@ static int gb_camera_configure_streams(struct gb_camera *gcam,
 	*num_streams = resp->num_streams;
 	ret = 0;
 
-	kfree(req);
-	kfree(resp);
-	return ret;
-
-set_unipro_slow_mode:
-	ret = gb_camera_set_power_mode(gcam, false);
-
 done:
 	kfree(req);
 	kfree(resp);

commit b573b0e65616c1ae5c5dd2c14fd62d3ded3d5466
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Sun Feb 14 02:33:05 2016 +0200

    greybus: camera: Clean up when AP link power mode configuration failed
    
    Restore the module link power mode to the previous state in that case.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reviewed-by: Gjorgji Rosikopulos <grosikopulos@mm-sol.com>
    Tested-by: Jacopo Mondi <jacopo.mondi@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/camera.c b/drivers/staging/greybus/camera.c
index 8383770910c5..25dbf690e1fc 100644
--- a/drivers/staging/greybus/camera.c
+++ b/drivers/staging/greybus/camera.c
@@ -147,6 +147,7 @@ static int gb_camera_set_power_mode(struct gb_camera *gcam, bool hs)
 
 	ret = gb_camera_set_intf_power_mode(gcam, svc->ap_intf_id, hs);
 	if (ret < 0) {
+		gb_camera_set_intf_power_mode(gcam, intf->interface_id, !hs);
 		gcam_err(gcam, "failed to set AP interface to %s (%d)\n",
 			 hs ? "HS" : "PWM", ret);
 		return ret;

commit c161c0fc2f18ab8c299d6cb716d6264427e38867
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Sun Feb 14 02:33:04 2016 +0200

    greybus: camera: Factorize link power mode configuration code into a function
    
    Avoid duplicating the same code block multiple times.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Tested-by: Jacopo Mondi <jacopo.mondi@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/camera.c b/drivers/staging/greybus/camera.c
index 3f31a2fd7e5e..8383770910c5 100644
--- a/drivers/staging/greybus/camera.c
+++ b/drivers/staging/greybus/camera.c
@@ -107,6 +107,54 @@ static const struct gb_camera_fmt_map mbus_to_gbus_format[] = {
  * Camera Protocol Operations
  */
 
+static int gb_camera_set_intf_power_mode(struct gb_camera *gcam, u8 intf_id,
+					 bool hs)
+{
+	struct gb_svc *svc = gcam->connection->hd->svc;
+	int ret;
+
+	if (hs)
+		ret = gb_svc_intf_set_power_mode(svc, intf_id,
+						 GB_SVC_UNIPRO_HS_SERIES_A,
+						 GB_SVC_UNIPRO_FAST_MODE, 2, 2,
+						 GB_SVC_UNIPRO_FAST_MODE, 2, 2,
+						 GB_SVC_PWRM_RXTERMINATION |
+						 GB_SVC_PWRM_TXTERMINATION, 0);
+	else
+		ret = gb_svc_intf_set_power_mode(svc, intf_id,
+						 GB_SVC_UNIPRO_HS_SERIES_A,
+						 GB_SVC_UNIPRO_SLOW_AUTO_MODE,
+						 1, 2,
+						 GB_SVC_UNIPRO_SLOW_AUTO_MODE,
+						 1, 2,
+						 0, 0);
+
+	return ret;
+}
+
+static int gb_camera_set_power_mode(struct gb_camera *gcam, bool hs)
+{
+	struct gb_interface *intf = gcam->connection->intf;
+	struct gb_svc *svc = gcam->connection->hd->svc;
+	int ret;
+
+	ret = gb_camera_set_intf_power_mode(gcam, intf->interface_id, hs);
+	if (ret < 0) {
+		gcam_err(gcam, "failed to set module interface to %s (%d)\n",
+			 hs ? "HS" : "PWM", ret);
+		return ret;
+	}
+
+	ret = gb_camera_set_intf_power_mode(gcam, svc->ap_intf_id, hs);
+	if (ret < 0) {
+		gcam_err(gcam, "failed to set AP interface to %s (%d)\n",
+			 hs ? "HS" : "PWM", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
 struct ap_csi_config_request {
 	__u8 csi_id;
 	__u8 clock_mode;
@@ -120,8 +168,6 @@ static int gb_camera_configure_streams(struct gb_camera *gcam,
 				       unsigned int *flags,
 				       struct gb_camera_stream_config *streams)
 {
-	struct gb_interface *intf = gcam->connection->intf;
-	struct gb_svc *svc = gcam->connection->hd->svc;
 	struct gb_camera_configure_streams_request *req;
 	struct gb_camera_configure_streams_response *resp;
 	struct ap_csi_config_request csi_cfg;
@@ -151,49 +197,13 @@ static int gb_camera_configure_streams(struct gb_camera *gcam,
 	 * before CSI interfaces gets configured
 	 */
 	if (nstreams && !(*flags & GB_CAMERA_CONFIGURE_STREAMS_TEST_ONLY)) {
-		ret = gb_svc_intf_set_power_mode(svc, intf->interface_id,
-						 GB_SVC_UNIPRO_HS_SERIES_A,
-						 GB_SVC_UNIPRO_FAST_MODE, 2, 2,
-						 GB_SVC_UNIPRO_FAST_MODE, 2, 2,
-						 GB_SVC_PWRM_RXTERMINATION |
-						 GB_SVC_PWRM_TXTERMINATION, 0);
-		if (ret < 0)
-			goto done;
-
-		ret = gb_svc_intf_set_power_mode(svc, svc->ap_intf_id,
-						 GB_SVC_UNIPRO_HS_SERIES_A,
-						 GB_SVC_UNIPRO_FAST_MODE, 2, 2,
-						 GB_SVC_UNIPRO_FAST_MODE, 2, 2,
-						 GB_SVC_PWRM_RXTERMINATION |
-						 GB_SVC_PWRM_TXTERMINATION, 0);
+		ret = gb_camera_set_power_mode(gcam, true);
 		if (ret < 0)
 			goto done;
 	} else if (nstreams == 0) {
-		ret = gb_svc_intf_set_power_mode(svc, intf->interface_id,
-						 GB_SVC_UNIPRO_HS_SERIES_A,
-						 GB_SVC_UNIPRO_SLOW_AUTO_MODE,
-						 1, 2,
-						 GB_SVC_UNIPRO_SLOW_AUTO_MODE,
-						 1, 2,
-						 0, 0);
-		if (ret < 0) {
-			gcam_err(gcam, "can't take camera link to PWM-G1 auto: %d\n",
-				 ret);
-			goto done;
-		}
-
-		ret = gb_svc_intf_set_power_mode(svc, svc->ap_intf_id,
-						 GB_SVC_UNIPRO_HS_SERIES_A,
-						 GB_SVC_UNIPRO_SLOW_AUTO_MODE,
-						 1, 2,
-						 GB_SVC_UNIPRO_SLOW_AUTO_MODE,
-						 1, 2,
-						 0, 0);
-		if (ret < 0) {
-			gcam_err(gcam, "can't take AP link to PWM-G1 auto: %d\n",
-				 ret);
+		ret = gb_camera_set_power_mode(gcam, false);
+		if (ret < 0)
 			goto done;
-		}
 	}
 
 	req->num_streams = nstreams;
@@ -283,29 +293,7 @@ static int gb_camera_configure_streams(struct gb_camera *gcam,
 	return ret;
 
 set_unipro_slow_mode:
-	ret = gb_svc_intf_set_power_mode(svc, intf->interface_id,
-					 GB_SVC_UNIPRO_HS_SERIES_A,
-					 GB_SVC_UNIPRO_SLOW_AUTO_MODE,
-					 1, 2,
-					 GB_SVC_UNIPRO_SLOW_AUTO_MODE,
-					 1, 2,
-					 0, 0);
-	if (ret < 0) {
-		gcam_err(gcam, "can't take camera link to PWM-G1 auto: %d\n",
-			 ret);
-		goto done;
-	}
-
-	ret = gb_svc_intf_set_power_mode(svc, svc->ap_intf_id,
-				   GB_SVC_UNIPRO_HS_SERIES_A,
-				   GB_SVC_UNIPRO_SLOW_AUTO_MODE,
-				   1, 2,
-				   GB_SVC_UNIPRO_SLOW_AUTO_MODE,
-				   1, 2,
-				   0, 0);
-	if (ret < 0)
-		gcam_err(gcam, "can't take AP link to PWM-G1 auto: %d\n",
-			 ret);
+	ret = gb_camera_set_power_mode(gcam, false);
 
 done:
 	kfree(req);

commit db81b76970a2e9f3ffa1ca66e7761f9f4b84efc6
Author: Jacopo Mondi <jacopo.mondi@linaro.org>
Date:   Fri Feb 5 09:35:33 2016 +0100

    greybus: camera: Add missing return value
    
    Add missing return value assignement when changing unipro power mode to
    PWM-G1.
    
    Signed-off-by: Jacopo Mondi <jacopo.mondi@linaro.org>
    Reviewed-by: Gjorgji Rosikopulos <grosikopulos@mm-sol.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/camera.c b/drivers/staging/greybus/camera.c
index 90eef23bf654..3f31a2fd7e5e 100644
--- a/drivers/staging/greybus/camera.c
+++ b/drivers/staging/greybus/camera.c
@@ -296,7 +296,7 @@ static int gb_camera_configure_streams(struct gb_camera *gcam,
 		goto done;
 	}
 
-	gb_svc_intf_set_power_mode(svc, svc->ap_intf_id,
+	ret = gb_svc_intf_set_power_mode(svc, svc->ap_intf_id,
 				   GB_SVC_UNIPRO_HS_SERIES_A,
 				   GB_SVC_UNIPRO_SLOW_AUTO_MODE,
 				   1, 2,
@@ -307,7 +307,6 @@ static int gb_camera_configure_streams(struct gb_camera *gcam,
 		gcam_err(gcam, "can't take AP link to PWM-G1 auto: %d\n",
 			 ret);
 
-
 done:
 	kfree(req);
 	kfree(resp);

commit f121d79d8acb0852f42b42b111967a3ef265362b
Author: Jacopo Mondi <jacopo.mondi@linaro.org>
Date:   Fri Feb 5 09:35:32 2016 +0100

    greybus: camera: Reset link speed on failed config
    
    Improve the management of unipro power mode changes in response
    to a configure_stream operation.
    When sending a "test only" request to camera module, do not change power
    mode to HS-G2 as no frame will be actually transmitted.
    When receiveing an "adjusted" configuration response, reset power
    mode to PWM-G1.
    
    Signed-off-by: Jacopo Mondi <jacopo.mondi@linaro.org>
    Reviewed-by: Gjorgji Rosikopulos <grosikopulos@mm-sol.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/camera.c b/drivers/staging/greybus/camera.c
index c7359088e259..90eef23bf654 100644
--- a/drivers/staging/greybus/camera.c
+++ b/drivers/staging/greybus/camera.c
@@ -150,7 +150,7 @@ static int gb_camera_configure_streams(struct gb_camera *gcam,
 	 * to the camera module, to assure unipro network speed is set
 	 * before CSI interfaces gets configured
 	 */
-	if (nstreams) {
+	if (nstreams && !(*flags & GB_CAMERA_CONFIGURE_STREAMS_TEST_ONLY)) {
 		ret = gb_svc_intf_set_power_mode(svc, intf->interface_id,
 						 GB_SVC_UNIPRO_HS_SERIES_A,
 						 GB_SVC_UNIPRO_FAST_MODE, 2, 2,
@@ -168,7 +168,7 @@ static int gb_camera_configure_streams(struct gb_camera *gcam,
 						 GB_SVC_PWRM_TXTERMINATION, 0);
 		if (ret < 0)
 			goto done;
-	} else {
+	} else if (nstreams == 0) {
 		ret = gb_svc_intf_set_power_mode(svc, intf->interface_id,
 						 GB_SVC_UNIPRO_HS_SERIES_A,
 						 GB_SVC_UNIPRO_SLOW_AUTO_MODE,
@@ -228,8 +228,6 @@ static int gb_camera_configure_streams(struct gb_camera *gcam,
 		goto set_unipro_slow_mode;
 	}
 
-	*flags = resp->flags;
-
 	for (i = 0; i < nstreams; ++i) {
 		struct gb_camera_stream_config_response *cfg = &resp->config[i];
 
@@ -248,10 +246,16 @@ static int gb_camera_configure_streams(struct gb_camera *gcam,
 		}
 	}
 
+	if (nstreams && resp->flags & GB_CAMERA_CONFIGURE_STREAMS_ADJUSTED) {
+		*flags = resp->flags;
+		*num_streams = resp->num_streams;
+		goto set_unipro_slow_mode;
+	}
+
 	memset(&csi_cfg, 0, sizeof(csi_cfg));
 
 	/* Configure the CSI transmitter. Hardcode the parameters for now. */
-	if (nstreams && !(resp->flags & GB_CAMERA_CONFIGURE_STREAMS_ADJUSTED)) {
+	if (nstreams) {
 		csi_cfg.csi_id = 1;
 		csi_cfg.clock_mode = 0;
 		csi_cfg.num_lanes = 4;
@@ -259,7 +263,7 @@ static int gb_camera_configure_streams(struct gb_camera *gcam,
 		ret = gb_hd_output(gcam->connection->hd, &csi_cfg,
 				   sizeof(csi_cfg),
 				   GB_APB_REQUEST_CSI_TX_CONTROL, false);
-	} else if (nstreams == 0) {
+	} else {
 		csi_cfg.csi_id = 1;
 		ret = gb_hd_output(gcam->connection->hd, &csi_cfg,
 				   sizeof(csi_cfg),
@@ -270,6 +274,7 @@ static int gb_camera_configure_streams(struct gb_camera *gcam,
 		gcam_err(gcam, "failed to %s the CSI transmitter\n",
 			 nstreams ? "start" : "stop");
 
+	*flags = resp->flags;
 	*num_streams = resp->num_streams;
 	ret = 0;
 

commit 4fbf69c71cdd3248745fd842481e946d1685f13c
Author: Jacopo Mondi <jacopo.mondi@linaro.org>
Date:   Sat Jan 23 19:44:46 2016 -0800

    greybus: camera: Stream config change unipro speed
    
    Unipro network speed was increased at camera initialization time and
    never slowed down.
    This unnecessary drains power during the entire time camera module is
    plugged in.
    Increasing/decreasing unipro link speed before issuing stream
    configuration request to camera module prevents this from happening.
    
    Signed-off-by: Jacopo Mondi <jacopo.mondi@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/camera.c b/drivers/staging/greybus/camera.c
index bcef3920d002..c7359088e259 100644
--- a/drivers/staging/greybus/camera.c
+++ b/drivers/staging/greybus/camera.c
@@ -120,9 +120,12 @@ static int gb_camera_configure_streams(struct gb_camera *gcam,
 				       unsigned int *flags,
 				       struct gb_camera_stream_config *streams)
 {
+	struct gb_interface *intf = gcam->connection->intf;
+	struct gb_svc *svc = gcam->connection->hd->svc;
 	struct gb_camera_configure_streams_request *req;
 	struct gb_camera_configure_streams_response *resp;
 	struct ap_csi_config_request csi_cfg;
+
 	unsigned int nstreams = *num_streams;
 	unsigned int i;
 	size_t req_size;
@@ -142,6 +145,57 @@ static int gb_camera_configure_streams(struct gb_camera *gcam,
 		goto done;
 	}
 
+	/*
+	 * Setup unipro link speed before actually issuing configuration
+	 * to the camera module, to assure unipro network speed is set
+	 * before CSI interfaces gets configured
+	 */
+	if (nstreams) {
+		ret = gb_svc_intf_set_power_mode(svc, intf->interface_id,
+						 GB_SVC_UNIPRO_HS_SERIES_A,
+						 GB_SVC_UNIPRO_FAST_MODE, 2, 2,
+						 GB_SVC_UNIPRO_FAST_MODE, 2, 2,
+						 GB_SVC_PWRM_RXTERMINATION |
+						 GB_SVC_PWRM_TXTERMINATION, 0);
+		if (ret < 0)
+			goto done;
+
+		ret = gb_svc_intf_set_power_mode(svc, svc->ap_intf_id,
+						 GB_SVC_UNIPRO_HS_SERIES_A,
+						 GB_SVC_UNIPRO_FAST_MODE, 2, 2,
+						 GB_SVC_UNIPRO_FAST_MODE, 2, 2,
+						 GB_SVC_PWRM_RXTERMINATION |
+						 GB_SVC_PWRM_TXTERMINATION, 0);
+		if (ret < 0)
+			goto done;
+	} else {
+		ret = gb_svc_intf_set_power_mode(svc, intf->interface_id,
+						 GB_SVC_UNIPRO_HS_SERIES_A,
+						 GB_SVC_UNIPRO_SLOW_AUTO_MODE,
+						 1, 2,
+						 GB_SVC_UNIPRO_SLOW_AUTO_MODE,
+						 1, 2,
+						 0, 0);
+		if (ret < 0) {
+			gcam_err(gcam, "can't take camera link to PWM-G1 auto: %d\n",
+				 ret);
+			goto done;
+		}
+
+		ret = gb_svc_intf_set_power_mode(svc, svc->ap_intf_id,
+						 GB_SVC_UNIPRO_HS_SERIES_A,
+						 GB_SVC_UNIPRO_SLOW_AUTO_MODE,
+						 1, 2,
+						 GB_SVC_UNIPRO_SLOW_AUTO_MODE,
+						 1, 2,
+						 0, 0);
+		if (ret < 0) {
+			gcam_err(gcam, "can't take AP link to PWM-G1 auto: %d\n",
+				 ret);
+			goto done;
+		}
+	}
+
 	req->num_streams = nstreams;
 	req->flags = *flags;
 	req->padding = 0;
@@ -159,19 +213,19 @@ static int gb_camera_configure_streams(struct gb_camera *gcam,
 				GB_CAMERA_TYPE_CONFIGURE_STREAMS,
 				req, req_size, resp, resp_size);
 	if (ret < 0)
-		goto done;
+		goto set_unipro_slow_mode;
 
 	if (resp->num_streams > nstreams) {
 		gcam_dbg(gcam, "got #streams %u > request %u\n",
 			 resp->num_streams, nstreams);
 		ret = -EIO;
-		goto done;
+		goto set_unipro_slow_mode;
 	}
 
 	if (resp->padding != 0) {
 		gcam_dbg(gcam, "response padding != 0");
 		ret = -EIO;
-		goto done;
+		goto set_unipro_slow_mode;
 	}
 
 	*flags = resp->flags;
@@ -190,7 +244,7 @@ static int gb_camera_configure_streams(struct gb_camera *gcam,
 		if (cfg->padding[0] || cfg->padding[1] || cfg->padding[2]) {
 			gcam_dbg(gcam, "stream #%u padding != 0", i);
 			ret = -EIO;
-			goto done;
+			goto set_unipro_slow_mode;
 		}
 	}
 
@@ -219,6 +273,36 @@ static int gb_camera_configure_streams(struct gb_camera *gcam,
 	*num_streams = resp->num_streams;
 	ret = 0;
 
+	kfree(req);
+	kfree(resp);
+	return ret;
+
+set_unipro_slow_mode:
+	ret = gb_svc_intf_set_power_mode(svc, intf->interface_id,
+					 GB_SVC_UNIPRO_HS_SERIES_A,
+					 GB_SVC_UNIPRO_SLOW_AUTO_MODE,
+					 1, 2,
+					 GB_SVC_UNIPRO_SLOW_AUTO_MODE,
+					 1, 2,
+					 0, 0);
+	if (ret < 0) {
+		gcam_err(gcam, "can't take camera link to PWM-G1 auto: %d\n",
+			 ret);
+		goto done;
+	}
+
+	gb_svc_intf_set_power_mode(svc, svc->ap_intf_id,
+				   GB_SVC_UNIPRO_HS_SERIES_A,
+				   GB_SVC_UNIPRO_SLOW_AUTO_MODE,
+				   1, 2,
+				   GB_SVC_UNIPRO_SLOW_AUTO_MODE,
+				   1, 2,
+				   0, 0);
+	if (ret < 0)
+		gcam_err(gcam, "can't take AP link to PWM-G1 auto: %d\n",
+			 ret);
+
+
 done:
 	kfree(req);
 	kfree(resp);
@@ -767,24 +851,6 @@ static int gb_camera_connection_init(struct gb_connection *connection)
 
 	gcam->data_connected = true;
 
-	ret = gb_svc_intf_set_power_mode(svc, connection->intf->interface_id,
-					 GB_SVC_UNIPRO_HS_SERIES_A,
-					 GB_SVC_UNIPRO_FAST_MODE, 2, 2,
-					 GB_SVC_UNIPRO_FAST_MODE, 2, 2,
-					 GB_SVC_PWRM_RXTERMINATION |
-					 GB_SVC_PWRM_TXTERMINATION, 0);
-	if (ret < 0)
-		goto error;
-
-	ret = gb_svc_intf_set_power_mode(svc, svc->ap_intf_id,
-					 GB_SVC_UNIPRO_HS_SERIES_A,
-					 GB_SVC_UNIPRO_FAST_MODE, 2, 2,
-					 GB_SVC_UNIPRO_FAST_MODE, 2, 2,
-					 GB_SVC_PWRM_RXTERMINATION |
-					 GB_SVC_PWRM_TXTERMINATION, 0);
-	if (ret < 0)
-		goto error;
-
 	ret = gb_camera_debugfs_init(gcam);
 	if (ret < 0)
 		goto error;

commit 7c154711a6705bbc3036d8f64944e8882fe3fd84
Author: Gjorgji Rosikopulos <grosikopulos@mm-sol.com>
Date:   Fri Jan 22 17:59:44 2016 +0200

    greybus: camera: add semiplanar and planar formats
    
    This change adds missing planar and semiplanar
    formats from gb specification.
    
    Mbus to Gb format map:
    V4L2_MBUS_FMT_NV12_1x8 -> 0x12
    V4L2_MBUS_FMT_NV21_1x8 -> 0x13
    V4L2_MBUS_FMT_YV12_1x8 -> 0x16
    V4L2_MBUS_FMT_YU12_1x8 -> 0x17
    
    Change depends on:
    "media: add new mediabus format enums for ara camera"
    
    Signed-off-by: Gjorgji Rosikopulos <grosikopulos@mm-sol.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/camera.c b/drivers/staging/greybus/camera.c
index 6f14848fa854..bcef3920d002 100644
--- a/drivers/staging/greybus/camera.c
+++ b/drivers/staging/greybus/camera.c
@@ -70,11 +70,19 @@ static const struct gb_camera_fmt_map mbus_to_gbus_format[] = {
 		.gb_format = 0x01,
 	},
 	{
-		.mbus_code = V4L2_MBUS_FMT_YUYV8_1_5X8,
+		.mbus_code = V4L2_MBUS_FMT_NV12_1x8,
+		.gb_format = 0x12,
+	},
+	{
+		.mbus_code = V4L2_MBUS_FMT_NV21_1x8,
+		.gb_format = 0x13,
+	},
+	{
+		.mbus_code = V4L2_MBUS_FMT_YU12_1x8,
 		.gb_format = 0x16,
 	},
 	{
-		.mbus_code = V4L2_MBUS_FMT_YVYU8_1_5X8,
+		.mbus_code = V4L2_MBUS_FMT_YV12_1x8,
 		.gb_format = 0x17,
 	},
 	{

commit 5b0327103ff0f5498af008cb7189770c1a33b67b
Author: Gjorgji Rosikopulos <grosikopulos@mm-sol.com>
Date:   Sun Jan 17 19:52:21 2016 +0200

    greybus: camera: Update configure stream based on new interface
    
    Interface has been changed.
    return code will not return number of configured streams but
    just error code.
    Number of streams is passed as pointer and if operation result
    is changed number of streams will be updated.
    
    Flags are also used for information regarding configure stream
    operation result.
    
    Signed-off-by: Gjorgji Rosikopulos <grosikopulos@mm-sol.com>
    Acked-by: Laurent Pinchart <laurent.pinchart@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/camera.c b/drivers/staging/greybus/camera.c
index deb55da9032e..6f14848fa854 100644
--- a/drivers/staging/greybus/camera.c
+++ b/drivers/staging/greybus/camera.c
@@ -315,34 +315,47 @@ static enum v4l2_mbus_pixelcode gb_camera_gb_to_mbus(u16 gb_fmt)
 	return mbus_to_gbus_format[0].mbus_code;
 }
 
-static int gb_camera_op_configure_streams(void *priv, unsigned int nstreams,
-			struct gb_camera_stream *streams)
+static int gb_camera_op_configure_streams(void *priv, unsigned int *nstreams,
+		unsigned int *flags, struct gb_camera_stream *streams)
 {
 	struct gb_camera *gcam = priv;
 	struct gb_camera_stream_config *gb_streams;
-	unsigned int flags = 0;
+	unsigned int gb_flags = 0;
+	unsigned int gb_nstreams = *nstreams;
 	unsigned int i;
 	int ret;
 
-	if (nstreams > GB_CAMERA_MAX_STREAMS)
+	if (gb_nstreams > GB_CAMERA_MAX_STREAMS)
 		return -EINVAL;
 
-	gb_streams = kzalloc(nstreams * sizeof(*gb_streams), GFP_KERNEL);
+	gb_streams = kzalloc(gb_nstreams * sizeof(*gb_streams), GFP_KERNEL);
 	if (!gb_streams)
 		return -ENOMEM;
 
-	for (i = 0; i < nstreams; i++) {
+	for (i = 0; i < gb_nstreams; i++) {
 		gb_streams[i].width = streams[i].width;
 		gb_streams[i].height = streams[i].height;
 		gb_streams[i].format =
 			gb_camera_mbus_to_gb(streams[i].pixel_code);
 	}
 
-	ret = gb_camera_configure_streams(gcam, &nstreams, &flags, gb_streams);
+	if (*flags & GB_CAMERA_IN_FLAG_TEST)
+		gb_flags |= GB_CAMERA_CONFIGURE_STREAMS_TEST_ONLY;
+
+	ret = gb_camera_configure_streams(gcam, &gb_nstreams,
+					  &gb_flags, gb_streams);
 	if (ret < 0)
 		goto done;
+	if (gb_nstreams > *nstreams) {
+		ret = -EINVAL;
+		goto done;
+	}
+
+	*flags = 0;
+	if (gb_flags & GB_CAMERA_CONFIGURE_STREAMS_ADJUSTED)
+		*flags |= GB_CAMERA_OUT_FLAG_ADJUSTED;
 
-	for (i = 0; i < nstreams; i++) {
+	for (i = 0; i < gb_nstreams; i++) {
 		streams[i].width = gb_streams[i].width;
 		streams[i].height = gb_streams[i].height;
 		streams[i].vc = gb_streams[i].vc;
@@ -352,6 +365,7 @@ static int gb_camera_op_configure_streams(void *priv, unsigned int nstreams,
 		streams[i].pixel_code =
 			gb_camera_gb_to_mbus(gb_streams[i].format);
 	}
+	*nstreams = gb_nstreams;
 
 done:
 	kfree(gb_streams);

commit b55d9431d62d6ce762d4b50ec93bbb81dce783c6
Author: Greg Kroah-Hartman <gregkh@google.com>
Date:   Fri Jan 15 14:41:02 2016 -0800

    greybus: Revert "camera: Fix backword compatibility in configure streams"
    
    This reverts commit 48cc91e52dba9abad4c9b56f911994c65071bfc4 as the
    caller should be changed instead.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/camera.c b/drivers/staging/greybus/camera.c
index 8b214337c4f9..deb55da9032e 100644
--- a/drivers/staging/greybus/camera.c
+++ b/drivers/staging/greybus/camera.c
@@ -352,8 +352,6 @@ static int gb_camera_op_configure_streams(void *priv, unsigned int nstreams,
 		streams[i].pixel_code =
 			gb_camera_gb_to_mbus(gb_streams[i].format);
 	}
-	/* For backward compatibility return number of streams in ret code */
-	ret = nstreams;
 
 done:
 	kfree(gb_streams);

commit 11ca550c226b87c4bf457580a817e4529c7aca62
Author: Gjorgji Rosikopulos <grosikopulos@mm-sol.com>
Date:   Fri Jan 15 21:34:56 2016 +0200

    greybus: camera: Fix backword compatibility in configure streams
    
    Configure streams ret code should be number of streams in
    gb operation exported to HOST camera.
    Until gb operation is migrated to new interface return
    number of streams in ret code.
    
    Signed-off-by: Gjorgji Rosikopulos <grosikopulos@mm-sol.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/camera.c b/drivers/staging/greybus/camera.c
index deb55da9032e..8b214337c4f9 100644
--- a/drivers/staging/greybus/camera.c
+++ b/drivers/staging/greybus/camera.c
@@ -352,6 +352,8 @@ static int gb_camera_op_configure_streams(void *priv, unsigned int nstreams,
 		streams[i].pixel_code =
 			gb_camera_gb_to_mbus(gb_streams[i].format);
 	}
+	/* For backward compatibility return number of streams in ret code */
+	ret = nstreams;
 
 done:
 	kfree(gb_streams);

commit 4068487ce3dba22bdc7bf34e7327b474494430b5
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Fri Jan 15 01:33:55 2016 +0200

    greybus: camera: Return the result flags from the configure_streams response
    
    And return the response num_streams field through a pointer variable
    instead of using the return value of the function as both an error code
    and a positive number of streams, it makes the API more consistent.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/camera.c b/drivers/staging/greybus/camera.c
index a69797b13c84..deb55da9032e 100644
--- a/drivers/staging/greybus/camera.c
+++ b/drivers/staging/greybus/camera.c
@@ -108,13 +108,14 @@ struct ap_csi_config_request {
 } __packed;
 
 static int gb_camera_configure_streams(struct gb_camera *gcam,
-				       unsigned int nstreams,
-				       unsigned int flags,
+				       unsigned int *num_streams,
+				       unsigned int *flags,
 				       struct gb_camera_stream_config *streams)
 {
 	struct gb_camera_configure_streams_request *req;
 	struct gb_camera_configure_streams_response *resp;
 	struct ap_csi_config_request csi_cfg;
+	unsigned int nstreams = *num_streams;
 	unsigned int i;
 	size_t req_size;
 	size_t resp_size;
@@ -134,7 +135,7 @@ static int gb_camera_configure_streams(struct gb_camera *gcam,
 	}
 
 	req->num_streams = nstreams;
-	req->flags = flags;
+	req->flags = *flags;
 	req->padding = 0;
 
 	for (i = 0; i < nstreams; ++i) {
@@ -165,6 +166,8 @@ static int gb_camera_configure_streams(struct gb_camera *gcam,
 		goto done;
 	}
 
+	*flags = resp->flags;
+
 	for (i = 0; i < nstreams; ++i) {
 		struct gb_camera_stream_config_response *cfg = &resp->config[i];
 
@@ -205,7 +208,8 @@ static int gb_camera_configure_streams(struct gb_camera *gcam,
 		gcam_err(gcam, "failed to %s the CSI transmitter\n",
 			 nstreams ? "start" : "stop");
 
-	ret = resp->num_streams;
+	*num_streams = resp->num_streams;
+	ret = 0;
 
 done:
 	kfree(req);
@@ -316,6 +320,7 @@ static int gb_camera_op_configure_streams(void *priv, unsigned int nstreams,
 {
 	struct gb_camera *gcam = priv;
 	struct gb_camera_stream_config *gb_streams;
+	unsigned int flags = 0;
 	unsigned int i;
 	int ret;
 
@@ -333,7 +338,7 @@ static int gb_camera_op_configure_streams(void *priv, unsigned int nstreams,
 			gb_camera_mbus_to_gb(streams[i].pixel_code);
 	}
 
-	ret = gb_camera_configure_streams(gcam, nstreams, 0, gb_streams);
+	ret = gb_camera_configure_streams(gcam, &nstreams, &flags, gb_streams);
 	if (ret < 0)
 		goto done;
 
@@ -455,12 +460,11 @@ static ssize_t gb_camera_debugfs_configure_streams(struct gb_camera *gcam,
 			goto done;
 	}
 
-	ret = gb_camera_configure_streams(gcam, nstreams, flags, streams);
+	ret = gb_camera_configure_streams(gcam, &nstreams, &flags, streams);
 	if (ret < 0)
 		goto done;
 
-	nstreams = ret;
-	buffer->length = sprintf(buffer->data, "%u;", nstreams);
+	buffer->length = sprintf(buffer->data, "%u;%u;", nstreams, flags);
 
 	for (i = 0; i < nstreams; ++i) {
 		struct gb_camera_stream_config *stream = &streams[i];

commit 3a8dba4e57d11965fa8f649753dc1507dd8331eb
Author: Gjorgji Rosikopulos <grosikopulos@mm-sol.com>
Date:   Wed Jan 13 21:52:38 2016 +0200

    greybus: camera: HACK: Register gb camera to the HOST camera
    
    This change implements gb camera interface and register
    gb camera to the HOST driver.
    This implementation need to be reworked after the demo.
    
    Tested with db3 with two camera modules.
    
    Signed-off-by: Gjorgji Rosikopulos <grosikopulos@mm-sol.com>
    Acked-by: Laurent Pinchart <laurent.pinchart@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/camera.c b/drivers/staging/greybus/camera.c
index 783a435bbae6..a69797b13c84 100644
--- a/drivers/staging/greybus/camera.c
+++ b/drivers/staging/greybus/camera.c
@@ -16,6 +16,7 @@
 #include <linux/uaccess.h>
 #include <linux/vmalloc.h>
 
+#include "gb-camera.h"
 #include "greybus.h"
 #include "greybus_protocols.h"
 
@@ -57,6 +58,31 @@ struct gb_camera_stream_config {
 	unsigned int max_size;
 };
 
+struct gb_camera_fmt_map {
+	enum v4l2_mbus_pixelcode mbus_code;
+	unsigned int gb_format;
+};
+
+/* GB format to media code map */
+static const struct gb_camera_fmt_map mbus_to_gbus_format[] = {
+	{
+		.mbus_code = V4L2_MBUS_FMT_UYVY8_1X16,
+		.gb_format = 0x01,
+	},
+	{
+		.mbus_code = V4L2_MBUS_FMT_YUYV8_1_5X8,
+		.gb_format = 0x16,
+	},
+	{
+		.mbus_code = V4L2_MBUS_FMT_YVYU8_1_5X8,
+		.gb_format = 0x17,
+	},
+	{
+		.mbus_code = V4L2_MBUS_FMT_JPEG_1X8,
+		.gb_format = 0x40,
+	}
+};
+
 #define ES2_APB_CDSI0_CPORT		16
 #define ES2_APB_CDSI1_CPORT		17
 
@@ -260,6 +286,97 @@ static int gb_camera_event_recv(u8 type, struct gb_operation *op)
 	return 0;
 }
 
+/* -----------------------------------------------------------------------------
+ * Interface with HOST ara camera.
+ */
+static unsigned int gb_camera_mbus_to_gb(enum v4l2_mbus_pixelcode mbus_code)
+{
+	unsigned int i;
+
+	for (i = 0; i < ARRAY_SIZE(mbus_to_gbus_format); i++) {
+		if (mbus_to_gbus_format[i].mbus_code == mbus_code)
+			return mbus_to_gbus_format[i].gb_format;
+	}
+	return mbus_to_gbus_format[0].gb_format;
+}
+
+static enum v4l2_mbus_pixelcode gb_camera_gb_to_mbus(u16 gb_fmt)
+{
+	unsigned int i;
+
+	for (i = 0; i < ARRAY_SIZE(mbus_to_gbus_format); i++) {
+		if (mbus_to_gbus_format[i].gb_format == gb_fmt)
+			return mbus_to_gbus_format[i].mbus_code;
+	}
+	return mbus_to_gbus_format[0].mbus_code;
+}
+
+static int gb_camera_op_configure_streams(void *priv, unsigned int nstreams,
+			struct gb_camera_stream *streams)
+{
+	struct gb_camera *gcam = priv;
+	struct gb_camera_stream_config *gb_streams;
+	unsigned int i;
+	int ret;
+
+	if (nstreams > GB_CAMERA_MAX_STREAMS)
+		return -EINVAL;
+
+	gb_streams = kzalloc(nstreams * sizeof(*gb_streams), GFP_KERNEL);
+	if (!gb_streams)
+		return -ENOMEM;
+
+	for (i = 0; i < nstreams; i++) {
+		gb_streams[i].width = streams[i].width;
+		gb_streams[i].height = streams[i].height;
+		gb_streams[i].format =
+			gb_camera_mbus_to_gb(streams[i].pixel_code);
+	}
+
+	ret = gb_camera_configure_streams(gcam, nstreams, 0, gb_streams);
+	if (ret < 0)
+		goto done;
+
+	for (i = 0; i < nstreams; i++) {
+		streams[i].width = gb_streams[i].width;
+		streams[i].height = gb_streams[i].height;
+		streams[i].vc = gb_streams[i].vc;
+		streams[i].dt[0] = gb_streams[i].dt[0];
+		streams[i].dt[1] = gb_streams[i].dt[1];
+		streams[i].max_size = gb_streams[i].max_size;
+		streams[i].pixel_code =
+			gb_camera_gb_to_mbus(gb_streams[i].format);
+	}
+
+done:
+	kfree(gb_streams);
+	return ret;
+}
+
+static int gb_camera_op_capture(void *priv, u32 request_id,
+		unsigned int streams, unsigned int num_frames,
+		size_t settings_size, const void *settings)
+{
+	return gb_camera_capture(priv, request_id, streams, num_frames,
+				 settings_size, settings);
+}
+
+static int gb_camera_op_flush(void *priv, u32 *request_id)
+{
+	return gb_camera_flush(priv, request_id);
+}
+
+struct gb_camera_ops gb_cam_ops = {
+	.configure_streams = gb_camera_op_configure_streams,
+	.capture = gb_camera_op_capture,
+	.flush = gb_camera_op_flush,
+};
+
+static int gb_camera_register_intf_ops(struct gb_camera *gcam)
+{
+	return gb_camera_register(&gb_cam_ops, gcam);
+}
+
 /* -----------------------------------------------------------------------------
  * DebugFS
  */
@@ -646,6 +763,10 @@ static int gb_camera_connection_init(struct gb_connection *connection)
 	if (ret < 0)
 		goto error;
 
+	ret = gb_camera_register_intf_ops(gcam);
+	if (ret < 0)
+		goto error;
+
 	return 0;
 
 error:

commit e5273381041fc75215fb50661db39d2f8ed5544e
Author: Greg Kroah-Hartman <gregkh@google.com>
Date:   Thu Dec 31 11:14:33 2015 -0800

    greybus: APBridge: move APBridge request protocol to a common .h file
    
    This moves all of the APBridge request protocol commands that are
    currently used to a common .h file for everyone to be able to use them
    in the future, where needed.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>
    Tested-by: Mark Greer <mgreer@animalcreek.com>
    Reviewed-by: Johan Hovold <johan@hovoldconsulting.com>

diff --git a/drivers/staging/greybus/camera.c b/drivers/staging/greybus/camera.c
index ac9ade367e0a..783a435bbae6 100644
--- a/drivers/staging/greybus/camera.c
+++ b/drivers/staging/greybus/camera.c
@@ -73,9 +73,6 @@ struct gb_camera_stream_config {
  * Camera Protocol Operations
  */
 
-/* vendor request to control the CSI transmitter */
-#define REQUEST_CSI_TX_CONTROL	0x08
-
 struct ap_csi_config_request {
 	__u8 csi_id;
 	__u8 clock_mode;
@@ -169,13 +166,13 @@ static int gb_camera_configure_streams(struct gb_camera *gcam,
 		csi_cfg.num_lanes = 4;
 		csi_cfg.bus_freq = cpu_to_le32(960000000);
 		ret = gb_hd_output(gcam->connection->hd, &csi_cfg,
-				   sizeof(csi_cfg), REQUEST_CSI_TX_CONTROL,
-				   false);
+				   sizeof(csi_cfg),
+				   GB_APB_REQUEST_CSI_TX_CONTROL, false);
 	} else if (nstreams == 0) {
 		csi_cfg.csi_id = 1;
 		ret = gb_hd_output(gcam->connection->hd, &csi_cfg,
-				   sizeof(csi_cfg), REQUEST_CSI_TX_CONTROL,
-				   false);
+				   sizeof(csi_cfg),
+				   GB_APB_REQUEST_CSI_TX_CONTROL, false);
 	}
 
 	if (ret < 0)

commit ed4596e9b19104ccc1e87bde8fcadee3a473c101
Author: Greg Kroah-Hartman <gregkh@google.com>
Date:   Tue Dec 22 18:21:51 2015 -0800

    greybus: host: provide "generic" apbridge output calls
    
    Provide a new function, gb_hd_output() to send data to the apbridge.
    This is useful for the camera and audio drivers that need to do this
    type of messaging.
    
    The camera driver is converted to use this new function, the audio
    driver can use it when it gets merged later.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>
    Tested-by: Mark Greer <mgreer@animalcreek.com>
    Reviewed-by: Johan Hovold <johan@hovoldconsulting.com>

diff --git a/drivers/staging/greybus/camera.c b/drivers/staging/greybus/camera.c
index 06ea5293d389..ac9ade367e0a 100644
--- a/drivers/staging/greybus/camera.c
+++ b/drivers/staging/greybus/camera.c
@@ -16,7 +16,6 @@
 #include <linux/uaccess.h>
 #include <linux/vmalloc.h>
 
-#include "es2.h"
 #include "greybus.h"
 #include "greybus_protocols.h"
 
@@ -74,6 +73,17 @@ struct gb_camera_stream_config {
  * Camera Protocol Operations
  */
 
+/* vendor request to control the CSI transmitter */
+#define REQUEST_CSI_TX_CONTROL	0x08
+
+struct ap_csi_config_request {
+	__u8 csi_id;
+	__u8 clock_mode;
+	__u8 num_lanes;
+	__u8 padding;
+	__le32 bus_freq;
+} __packed;
+
 static int gb_camera_configure_streams(struct gb_camera *gcam,
 				       unsigned int nstreams,
 				       unsigned int flags,
@@ -81,7 +91,7 @@ static int gb_camera_configure_streams(struct gb_camera *gcam,
 {
 	struct gb_camera_configure_streams_request *req;
 	struct gb_camera_configure_streams_response *resp;
-	struct es2_ap_csi_config csi_cfg;
+	struct ap_csi_config_request csi_cfg;
 	unsigned int i;
 	size_t req_size;
 	size_t resp_size;
@@ -150,21 +160,22 @@ static int gb_camera_configure_streams(struct gb_camera *gcam,
 		}
 	}
 
+	memset(&csi_cfg, 0, sizeof(csi_cfg));
+
 	/* Configure the CSI transmitter. Hardcode the parameters for now. */
 	if (nstreams && !(resp->flags & GB_CAMERA_CONFIGURE_STREAMS_ADJUSTED)) {
 		csi_cfg.csi_id = 1;
 		csi_cfg.clock_mode = 0;
 		csi_cfg.num_lanes = 4;
-		csi_cfg.bus_freq = 960000000;
-
-		ret = es2_ap_csi_setup(gcam->connection->hd, true, &csi_cfg);
+		csi_cfg.bus_freq = cpu_to_le32(960000000);
+		ret = gb_hd_output(gcam->connection->hd, &csi_cfg,
+				   sizeof(csi_cfg), REQUEST_CSI_TX_CONTROL,
+				   false);
 	} else if (nstreams == 0) {
 		csi_cfg.csi_id = 1;
-		csi_cfg.clock_mode = 0;
-		csi_cfg.num_lanes = 0;
-		csi_cfg.bus_freq = 0;
-
-		ret = es2_ap_csi_setup(gcam->connection->hd, false, &csi_cfg);
+		ret = gb_hd_output(gcam->connection->hd, &csi_cfg,
+				   sizeof(csi_cfg), REQUEST_CSI_TX_CONTROL,
+				   false);
 	}
 
 	if (ret < 0)

commit b787d413e0d99ae74e21cdab600ea3c5b0886ec2
Author: Jacopo Mondi <jacopo.mondi@linaro.org>
Date:   Fri Jan 8 18:13:20 2016 +0200

    greybus: camera: Add support for flags to stream_configure
    
    Add support for the flags field of the stream configure request that was
    recently added to the camera protocol and update the debugfs arguments
    parsing accordingly. The stream configure response layout is also
    updated to the latest protocol specification.
    
    Signed-off-by: Jacopo Mondi <jacopo.mondi@linaro.org>
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/camera.c b/drivers/staging/greybus/camera.c
index 4e96e1fcfcdf..06ea5293d389 100644
--- a/drivers/staging/greybus/camera.c
+++ b/drivers/staging/greybus/camera.c
@@ -76,6 +76,7 @@ struct gb_camera_stream_config {
 
 static int gb_camera_configure_streams(struct gb_camera *gcam,
 				       unsigned int nstreams,
+				       unsigned int flags,
 				       struct gb_camera_stream_config *streams)
 {
 	struct gb_camera_configure_streams_request *req;
@@ -99,7 +100,8 @@ static int gb_camera_configure_streams(struct gb_camera *gcam,
 		goto done;
 	}
 
-	req->num_streams = cpu_to_le16(nstreams);
+	req->num_streams = nstreams;
+	req->flags = flags;
 	req->padding = 0;
 
 	for (i = 0; i < nstreams; ++i) {
@@ -117,9 +119,9 @@ static int gb_camera_configure_streams(struct gb_camera *gcam,
 	if (ret < 0)
 		goto done;
 
-	if (le16_to_cpu(resp->num_streams) > nstreams) {
+	if (resp->num_streams > nstreams) {
 		gcam_dbg(gcam, "got #streams %u > request %u\n",
-			 le16_to_cpu(resp->num_streams), nstreams);
+			 resp->num_streams, nstreams);
 		ret = -EIO;
 		goto done;
 	}
@@ -169,7 +171,7 @@ static int gb_camera_configure_streams(struct gb_camera *gcam,
 		gcam_err(gcam, "failed to %s the CSI transmitter\n",
 			 nstreams ? "start" : "stop");
 
-	ret = le16_to_cpu(resp->num_streams);
+	ret = resp->num_streams;
 
 done:
 	kfree(req);
@@ -266,13 +268,13 @@ static ssize_t gb_camera_debugfs_configure_streams(struct gb_camera *gcam,
 		&gcam->debugfs.buffers[GB_CAMERA_DEBUGFS_BUFFER_STREAMS];
 	struct gb_camera_stream_config *streams;
 	unsigned int nstreams;
-	const char *sep = ";";
+	unsigned int flags;
 	unsigned int i;
 	char *token;
 	int ret;
 
 	/* Retrieve number of streams to configure */
-	token = strsep(&buf, sep);
+	token = strsep(&buf, ";");
 	if (token == NULL)
 		return -EINVAL;
 
@@ -283,6 +285,14 @@ static ssize_t gb_camera_debugfs_configure_streams(struct gb_camera *gcam,
 	if (nstreams > GB_CAMERA_MAX_STREAMS)
 		return -EINVAL;
 
+	token = strsep(&buf, ";");
+	if (token == NULL)
+		return -EINVAL;
+
+	ret = kstrtouint(token, 10, &flags);
+	if (ret < 0)
+		return ret;
+
 	/* For each stream to configure parse width, height and format */
 	streams = kzalloc(nstreams * sizeof(*streams), GFP_KERNEL);
 	if (!streams)
@@ -320,7 +330,7 @@ static ssize_t gb_camera_debugfs_configure_streams(struct gb_camera *gcam,
 			goto done;
 	}
 
-	ret = gb_camera_configure_streams(gcam, nstreams, streams);
+	ret = gb_camera_configure_streams(gcam, nstreams, flags, streams);
 	if (ret < 0)
 		goto done;
 

commit aab4a1a3684a46b423af23e4bdc9afe1b28dc389
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Wed Jan 6 16:16:46 2016 +0200

    greybus: svc: Replace link config hack with standard operation
    
    The link config operation was a hack only designed to fulfill the camera
    driver's needs. Now that a standard operation is defined for the same
    purpose, implement it and remove the hack.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/camera.c b/drivers/staging/greybus/camera.c
index 7be7cfca49bf..4e96e1fcfcdf 100644
--- a/drivers/staging/greybus/camera.c
+++ b/drivers/staging/greybus/camera.c
@@ -606,13 +606,21 @@ static int gb_camera_connection_init(struct gb_connection *connection)
 
 	gcam->data_connected = true;
 
-	ret = gb_svc_link_config(svc, connection->intf->interface_id,
-				 GB_SVC_LINK_CONFIG_BURST_HS_A, 2, 2, 0);
+	ret = gb_svc_intf_set_power_mode(svc, connection->intf->interface_id,
+					 GB_SVC_UNIPRO_HS_SERIES_A,
+					 GB_SVC_UNIPRO_FAST_MODE, 2, 2,
+					 GB_SVC_UNIPRO_FAST_MODE, 2, 2,
+					 GB_SVC_PWRM_RXTERMINATION |
+					 GB_SVC_PWRM_TXTERMINATION, 0);
 	if (ret < 0)
 		goto error;
 
-	ret = gb_svc_link_config(svc, svc->ap_intf_id,
-				 GB_SVC_LINK_CONFIG_BURST_HS_A, 2, 2, 0);
+	ret = gb_svc_intf_set_power_mode(svc, svc->ap_intf_id,
+					 GB_SVC_UNIPRO_HS_SERIES_A,
+					 GB_SVC_UNIPRO_FAST_MODE, 2, 2,
+					 GB_SVC_UNIPRO_FAST_MODE, 2, 2,
+					 GB_SVC_PWRM_RXTERMINATION |
+					 GB_SVC_PWRM_TXTERMINATION, 0);
 	if (ret < 0)
 		goto error;
 

commit 1f67ee5c04c9690c4c99fc4d31f4add46ea7be73
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Thu Dec 31 04:20:56 2015 +0200

    greybus: camera: Raise the CSI-2 bandwidth
    
    Use 4 lanes at 960MHz to support camera modules requiring higher
    bandwidths until we implement support for dynamic bandwidth calculation.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/camera.c b/drivers/staging/greybus/camera.c
index b181ac49e783..7be7cfca49bf 100644
--- a/drivers/staging/greybus/camera.c
+++ b/drivers/staging/greybus/camera.c
@@ -152,8 +152,8 @@ static int gb_camera_configure_streams(struct gb_camera *gcam,
 	if (nstreams && !(resp->flags & GB_CAMERA_CONFIGURE_STREAMS_ADJUSTED)) {
 		csi_cfg.csi_id = 1;
 		csi_cfg.clock_mode = 0;
-		csi_cfg.num_lanes = 2;
-		csi_cfg.bus_freq = 250000000;
+		csi_cfg.num_lanes = 4;
+		csi_cfg.bus_freq = 960000000;
 
 		ret = es2_ap_csi_setup(gcam->connection->hd, true, &csi_cfg);
 	} else if (nstreams == 0) {

commit 41c23958557d9b37755768849ee39b99a9826a9c
Author: Johan Hovold <johan@hovoldconsulting.com>
Date:   Wed Dec 30 11:23:51 2015 +0100

    greybus: camera: destroy data connection on link-config errors
    
    Make sure to tear down the data connection also on failure to configure
    the link by setting the data_connected flag immediately after creating
    the connection.
    
    Signed-off-by: Johan Hovold <johan@hovoldconsulting.com>
    Reviewed-by: Laurent Pinchart <laurent.pinchart@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/camera.c b/drivers/staging/greybus/camera.c
index ec7d4a082ab1..b181ac49e783 100644
--- a/drivers/staging/greybus/camera.c
+++ b/drivers/staging/greybus/camera.c
@@ -604,6 +604,8 @@ static int gb_camera_connection_init(struct gb_connection *connection)
 	if (ret < 0)
 		goto error;
 
+	gcam->data_connected = true;
+
 	ret = gb_svc_link_config(svc, connection->intf->interface_id,
 				 GB_SVC_LINK_CONFIG_BURST_HS_A, 2, 2, 0);
 	if (ret < 0)
@@ -614,8 +616,6 @@ static int gb_camera_connection_init(struct gb_connection *connection)
 	if (ret < 0)
 		goto error;
 
-	gcam->data_connected = true;
-
 	ret = gb_camera_debugfs_init(gcam);
 	if (ret < 0)
 		goto error;

commit b9f71bc854105148f38d0c2336ed7c9b50a97800
Author: Johan Hovold <johan@hovoldconsulting.com>
Date:   Wed Dec 30 11:08:01 2015 +0100

    greybus: camera: fix memory leak in capture-request handler
    
    Fix memory leak in capture-request handler by making sure to release the
    operation request buffer after sending the request.
    
    Signed-off-by: Johan Hovold <johan@hovoldconsulting.com>
    Reviewed-by: Laurent Pinchart <laurent.pinchart@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/camera.c b/drivers/staging/greybus/camera.c
index 8b2eedd29cb3..ec7d4a082ab1 100644
--- a/drivers/staging/greybus/camera.c
+++ b/drivers/staging/greybus/camera.c
@@ -183,6 +183,7 @@ static int gb_camera_capture(struct gb_camera *gcam, u32 request_id,
 {
 	struct gb_camera_capture_request *req;
 	size_t req_size;
+	int ret;
 
 	if (settings_size > GB_CAMERA_MAX_SETTINGS_SIZE)
 		return -EINVAL;
@@ -198,8 +199,12 @@ static int gb_camera_capture(struct gb_camera *gcam, u32 request_id,
 	req->num_frames = cpu_to_le16(num_frames);
 	memcpy(req->settings, settings, settings_size);
 
-	return gb_operation_sync(gcam->connection, GB_CAMERA_TYPE_CAPTURE,
+	ret = gb_operation_sync(gcam->connection, GB_CAMERA_TYPE_CAPTURE,
 				 req, req_size, NULL, 0);
+
+	kfree(req);
+
+	return ret;
 }
 
 static int gb_camera_flush(struct gb_camera *gcam, u32 *request_id)

commit 12c8b0dcc884cc7f1f925cd1ed08cf8cdc95e7ef
Author: Johan Hovold <johan@hovoldconsulting.com>
Date:   Wed Dec 30 11:08:00 2015 +0100

    greybus: camera: fix memory leak in configure-streams error path
    
    Fix memory leak in configure-streams error path by making sure to
    release the operation buffers before returning.
    
    Signed-off-by: Johan Hovold <johan@hovoldconsulting.com>
    Reviewed-by: Laurent Pinchart <laurent.pinchart@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/camera.c b/drivers/staging/greybus/camera.c
index c742fea29492..8b2eedd29cb3 100644
--- a/drivers/staging/greybus/camera.c
+++ b/drivers/staging/greybus/camera.c
@@ -115,7 +115,7 @@ static int gb_camera_configure_streams(struct gb_camera *gcam,
 				GB_CAMERA_TYPE_CONFIGURE_STREAMS,
 				req, req_size, resp, resp_size);
 	if (ret < 0)
-		return ret;
+		goto done;
 
 	if (le16_to_cpu(resp->num_streams) > nstreams) {
 		gcam_dbg(gcam, "got #streams %u > request %u\n",

commit 98ce3b0a71c23f924dd031d41171a96eee7fe313
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Tue Dec 22 03:00:35 2015 +0200

    greybus: camera: Fix remaining endian conversion issues
    
    Convert all Greybus operation fields between CPU and protocol
    endianness.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/camera.c b/drivers/staging/greybus/camera.c
index 592c3efefb65..c742fea29492 100644
--- a/drivers/staging/greybus/camera.c
+++ b/drivers/staging/greybus/camera.c
@@ -99,7 +99,7 @@ static int gb_camera_configure_streams(struct gb_camera *gcam,
 		goto done;
 	}
 
-	req->num_streams = nstreams;
+	req->num_streams = cpu_to_le16(nstreams);
 	req->padding = 0;
 
 	for (i = 0; i < nstreams; ++i) {
@@ -117,9 +117,9 @@ static int gb_camera_configure_streams(struct gb_camera *gcam,
 	if (ret < 0)
 		return ret;
 
-	if (resp->num_streams > nstreams) {
+	if (le16_to_cpu(resp->num_streams) > nstreams) {
 		gcam_dbg(gcam, "got #streams %u > request %u\n",
-			 resp->num_streams, nstreams);
+			 le16_to_cpu(resp->num_streams), nstreams);
 		ret = -EIO;
 		goto done;
 	}
@@ -169,7 +169,7 @@ static int gb_camera_configure_streams(struct gb_camera *gcam,
 		gcam_err(gcam, "failed to %s the CSI transmitter\n",
 			 nstreams ? "start" : "stop");
 
-	ret = resp->num_streams;
+	ret = le16_to_cpu(resp->num_streams);
 
 done:
 	kfree(req);

commit b1c7d67e886be3baf1b2e1f061d09f758709ba9b
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Sat Dec 19 08:38:56 2015 +0200

    greybus: camera: Set link power mode to HS-G2 with 2 lanes
    
    HS-G1 isn't enough for all camera modules. The gear will need to be
    computed dynamically, but for now hardcode it to 2 with 2 lanes.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/camera.c b/drivers/staging/greybus/camera.c
index 556226a19ada..592c3efefb65 100644
--- a/drivers/staging/greybus/camera.c
+++ b/drivers/staging/greybus/camera.c
@@ -600,12 +600,12 @@ static int gb_camera_connection_init(struct gb_connection *connection)
 		goto error;
 
 	ret = gb_svc_link_config(svc, connection->intf->interface_id,
-				 GB_SVC_LINK_CONFIG_BURST_HS_A, 1, 1, 0);
+				 GB_SVC_LINK_CONFIG_BURST_HS_A, 2, 2, 0);
 	if (ret < 0)
 		goto error;
 
 	ret = gb_svc_link_config(svc, svc->ap_intf_id,
-				 GB_SVC_LINK_CONFIG_BURST_HS_A, 1, 1, 0);
+				 GB_SVC_LINK_CONFIG_BURST_HS_A, 2, 2, 0);
 	if (ret < 0)
 		goto error;
 

commit 142b21fee07e858a85bb1b8091d9803cf9fa13e3
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Fri Dec 18 21:23:25 2015 +0200

    greybus: camera: Configure the bridge CSI transmitter
    
    Start or stop the CSI transmitter when configuring and unconfiguring the
    streams respectively. The CSI configuration parameters are currently
    hardcoded.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/camera.c b/drivers/staging/greybus/camera.c
index f163689f50a5..556226a19ada 100644
--- a/drivers/staging/greybus/camera.c
+++ b/drivers/staging/greybus/camera.c
@@ -16,6 +16,7 @@
 #include <linux/uaccess.h>
 #include <linux/vmalloc.h>
 
+#include "es2.h"
 #include "greybus.h"
 #include "greybus_protocols.h"
 
@@ -79,6 +80,7 @@ static int gb_camera_configure_streams(struct gb_camera *gcam,
 {
 	struct gb_camera_configure_streams_request *req;
 	struct gb_camera_configure_streams_response *resp;
+	struct es2_ap_csi_config csi_cfg;
 	unsigned int i;
 	size_t req_size;
 	size_t resp_size;
@@ -146,6 +148,27 @@ static int gb_camera_configure_streams(struct gb_camera *gcam,
 		}
 	}
 
+	/* Configure the CSI transmitter. Hardcode the parameters for now. */
+	if (nstreams && !(resp->flags & GB_CAMERA_CONFIGURE_STREAMS_ADJUSTED)) {
+		csi_cfg.csi_id = 1;
+		csi_cfg.clock_mode = 0;
+		csi_cfg.num_lanes = 2;
+		csi_cfg.bus_freq = 250000000;
+
+		ret = es2_ap_csi_setup(gcam->connection->hd, true, &csi_cfg);
+	} else if (nstreams == 0) {
+		csi_cfg.csi_id = 1;
+		csi_cfg.clock_mode = 0;
+		csi_cfg.num_lanes = 0;
+		csi_cfg.bus_freq = 0;
+
+		ret = es2_ap_csi_setup(gcam->connection->hd, false, &csi_cfg);
+	}
+
+	if (ret < 0)
+		gcam_err(gcam, "failed to %s the CSI transmitter\n",
+			 nstreams ? "start" : "stop");
+
 	ret = resp->num_streams;
 
 done:

commit bcc050be962179f8004629b0869db8996eb8596c
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Fri Dec 18 21:23:23 2015 +0200

    greybus: camera: Configure link speed for the data connection
    
    Hardcode the speed to HS-G1 for now.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/camera.c b/drivers/staging/greybus/camera.c
index 545ed632901a..f163689f50a5 100644
--- a/drivers/staging/greybus/camera.c
+++ b/drivers/staging/greybus/camera.c
@@ -576,6 +576,16 @@ static int gb_camera_connection_init(struct gb_connection *connection)
 	if (ret < 0)
 		goto error;
 
+	ret = gb_svc_link_config(svc, connection->intf->interface_id,
+				 GB_SVC_LINK_CONFIG_BURST_HS_A, 1, 1, 0);
+	if (ret < 0)
+		goto error;
+
+	ret = gb_svc_link_config(svc, svc->ap_intf_id,
+				 GB_SVC_LINK_CONFIG_BURST_HS_A, 1, 1, 0);
+	if (ret < 0)
+		goto error;
+
 	gcam->data_connected = true;
 
 	ret = gb_camera_debugfs_init(gcam);

commit c6622216ffaacc6286189121e63cdaae1b6bcbce
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Fri Dec 18 21:23:21 2015 +0200

    greybus: camera: Fix endian conversion issues
    
    Convert all Greybus operation fields between CPU and protocol
    endianness.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Reported-by: Rui Silva <rui.silva@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/camera.c b/drivers/staging/greybus/camera.c
index b7d9384e9471..545ed632901a 100644
--- a/drivers/staging/greybus/camera.c
+++ b/drivers/staging/greybus/camera.c
@@ -103,9 +103,9 @@ static int gb_camera_configure_streams(struct gb_camera *gcam,
 	for (i = 0; i < nstreams; ++i) {
 		struct gb_camera_stream_config_request *cfg = &req->config[i];
 
-		cfg->width = streams[i].width;
-		cfg->height = streams[i].height;
-		cfg->format = streams[i].format;
+		cfg->width = cpu_to_le16(streams[i].width);
+		cfg->height = cpu_to_le16(streams[i].height);
+		cfg->format = cpu_to_le16(streams[i].format);
 		cfg->padding = 0;
 	}
 
@@ -131,13 +131,13 @@ static int gb_camera_configure_streams(struct gb_camera *gcam,
 	for (i = 0; i < nstreams; ++i) {
 		struct gb_camera_stream_config_response *cfg = &resp->config[i];
 
-		streams[i].width = cfg->width;
-		streams[i].height = cfg->height;
-		streams[i].format = cfg->format;
+		streams[i].width = le16_to_cpu(cfg->width);
+		streams[i].height = le16_to_cpu(cfg->height);
+		streams[i].format = le16_to_cpu(cfg->format);
 		streams[i].vc = cfg->virtual_channel;
 		streams[i].dt[0] = cfg->data_type[0];
 		streams[i].dt[1] = cfg->data_type[1];
-		streams[i].max_size = cfg->max_size;
+		streams[i].max_size = le32_to_cpu(cfg->max_size);
 
 		if (cfg->padding[0] || cfg->padding[1] || cfg->padding[2]) {
 			gcam_dbg(gcam, "stream #%u padding != 0", i);
@@ -169,10 +169,10 @@ static int gb_camera_capture(struct gb_camera *gcam, u32 request_id,
 	if (!req)
 		return -ENOMEM;
 
-	req->request_id = request_id;
+	req->request_id = cpu_to_le32(request_id);
 	req->streams = streams;
 	req->padding = 0;
-	req->num_frames = num_frames;
+	req->num_frames = cpu_to_le16(num_frames);
 	memcpy(req->settings, settings, settings_size);
 
 	return gb_operation_sync(gcam->connection, GB_CAMERA_TYPE_CAPTURE,
@@ -190,7 +190,7 @@ static int gb_camera_flush(struct gb_camera *gcam, u32 *request_id)
 		return ret;
 
 	if (request_id)
-		*request_id = resp.request_id;
+		*request_id = le32_to_cpu(resp.request_id);
 
 	return 0;
 }

commit 4dda744c2a26d7ee63ceaf834bfe19ab038e4064
Author: Greg Kroah-Hartman <gregkh@google.com>
Date:   Mon Dec 14 18:33:19 2015 -0800

    greybus: Camera: remove f_dentry usage
    
    On newer kernels f_dentry is gone, so use f_path.dentry instead.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/camera.c b/drivers/staging/greybus/camera.c
index 38b209c93eab..b7d9384e9471 100644
--- a/drivers/staging/greybus/camera.c
+++ b/drivers/staging/greybus/camera.c
@@ -465,7 +465,7 @@ static int gb_camera_debugfs_open(struct inode *inode, struct file *file)
 		const struct gb_camera_debugfs_entry *entry =
 			&gb_camera_debugfs_entries[i];
 
-		if (!strcmp(file->f_dentry->d_iname, entry->name)) {
+		if (!strcmp(file->f_path.dentry->d_iname, entry->name)) {
 			file->private_data = (void *)entry;
 			break;
 		}

commit 3265edaf0d70433699eece915fcca6509332c0e8
Author: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date:   Tue Dec 15 03:18:06 2015 +0200

    greybus: Add driver for the camera class protocol
    
    Integration with the V4L2 camera drivers isn't available yet, a debugfs
    interface is exposed instead to call the camera Greybus operations.
    
    The debugfs interface will be kept for module testing purpose in order
    to exercise all the protocol operations with various valid and invalid
    parameters.
    
    Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
    Signed-off-by: Jacopo Mondi <jacopo.mondi@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/camera.c b/drivers/staging/greybus/camera.c
new file mode 100644
index 000000000000..38b209c93eab
--- /dev/null
+++ b/drivers/staging/greybus/camera.c
@@ -0,0 +1,611 @@
+/*
+ * Greybus Camera protocol driver.
+ *
+ * Copyright 2015 Google Inc.
+ * Copyright 2015 Linaro Ltd.
+ *
+ * Released under the GPLv2 only.
+ */
+
+#include <linux/debugfs.h>
+#include <linux/fs.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+#include <linux/uaccess.h>
+#include <linux/vmalloc.h>
+
+#include "greybus.h"
+#include "greybus_protocols.h"
+
+enum gb_camera_debugs_buffer_id {
+	GB_CAMERA_DEBUGFS_BUFFER_CAPABILITIES,
+	GB_CAMERA_DEBUGFS_BUFFER_STREAMS,
+	GB_CAMERA_DEBUGFS_BUFFER_CAPTURE,
+	GB_CAMERA_DEBUGFS_BUFFER_FLUSH,
+	GB_CAMERA_DEBUGFS_BUFFER_MAX,
+};
+
+struct gb_camera_debugfs_buffer {
+	char data[PAGE_SIZE];
+	size_t length;
+};
+
+/**
+ * struct gb_camera - A Greybus Camera Device
+ * @connection: the greybus connection for camera control
+ * @data_connected: whether the data connection has been established
+ * @debugfs: debugfs entries for camera protocol operations testing
+ */
+struct gb_camera {
+	struct gb_connection *connection;
+	bool data_connected;
+
+	struct {
+		struct dentry *root;
+		struct gb_camera_debugfs_buffer *buffers;
+	} debugfs;
+};
+
+struct gb_camera_stream_config {
+	unsigned int width;
+	unsigned int height;
+	unsigned int format;
+	unsigned int vc;
+	unsigned int dt[2];
+	unsigned int max_size;
+};
+
+#define ES2_APB_CDSI0_CPORT		16
+#define ES2_APB_CDSI1_CPORT		17
+
+#define GB_CAMERA_MAX_SETTINGS_SIZE	8192
+
+#define gcam_dbg(gcam, format...) \
+	dev_dbg(&gcam->connection->bundle->dev, format)
+#define gcam_info(gcam, format...) \
+	dev_info(&gcam->connection->bundle->dev, format)
+#define gcam_err(gcam, format...) \
+	dev_err(&gcam->connection->bundle->dev, format)
+
+/* -----------------------------------------------------------------------------
+ * Camera Protocol Operations
+ */
+
+static int gb_camera_configure_streams(struct gb_camera *gcam,
+				       unsigned int nstreams,
+				       struct gb_camera_stream_config *streams)
+{
+	struct gb_camera_configure_streams_request *req;
+	struct gb_camera_configure_streams_response *resp;
+	unsigned int i;
+	size_t req_size;
+	size_t resp_size;
+	int ret;
+
+	if (nstreams > GB_CAMERA_MAX_STREAMS)
+		return -EINVAL;
+
+	req_size = sizeof(*req) + nstreams * sizeof(req->config[0]);
+	resp_size = sizeof(*resp) + nstreams * sizeof(resp->config[0]);
+
+	req = kmalloc(req_size, GFP_KERNEL);
+	resp = kmalloc(resp_size, GFP_KERNEL);
+	if (!req || !resp) {
+		ret = -ENOMEM;
+		goto done;
+	}
+
+	req->num_streams = nstreams;
+	req->padding = 0;
+
+	for (i = 0; i < nstreams; ++i) {
+		struct gb_camera_stream_config_request *cfg = &req->config[i];
+
+		cfg->width = streams[i].width;
+		cfg->height = streams[i].height;
+		cfg->format = streams[i].format;
+		cfg->padding = 0;
+	}
+
+	ret = gb_operation_sync(gcam->connection,
+				GB_CAMERA_TYPE_CONFIGURE_STREAMS,
+				req, req_size, resp, resp_size);
+	if (ret < 0)
+		return ret;
+
+	if (resp->num_streams > nstreams) {
+		gcam_dbg(gcam, "got #streams %u > request %u\n",
+			 resp->num_streams, nstreams);
+		ret = -EIO;
+		goto done;
+	}
+
+	if (resp->padding != 0) {
+		gcam_dbg(gcam, "response padding != 0");
+		ret = -EIO;
+		goto done;
+	}
+
+	for (i = 0; i < nstreams; ++i) {
+		struct gb_camera_stream_config_response *cfg = &resp->config[i];
+
+		streams[i].width = cfg->width;
+		streams[i].height = cfg->height;
+		streams[i].format = cfg->format;
+		streams[i].vc = cfg->virtual_channel;
+		streams[i].dt[0] = cfg->data_type[0];
+		streams[i].dt[1] = cfg->data_type[1];
+		streams[i].max_size = cfg->max_size;
+
+		if (cfg->padding[0] || cfg->padding[1] || cfg->padding[2]) {
+			gcam_dbg(gcam, "stream #%u padding != 0", i);
+			ret = -EIO;
+			goto done;
+		}
+	}
+
+	ret = resp->num_streams;
+
+done:
+	kfree(req);
+	kfree(resp);
+	return ret;
+}
+
+static int gb_camera_capture(struct gb_camera *gcam, u32 request_id,
+			     unsigned int streams, unsigned int num_frames,
+			     size_t settings_size, const void *settings)
+{
+	struct gb_camera_capture_request *req;
+	size_t req_size;
+
+	if (settings_size > GB_CAMERA_MAX_SETTINGS_SIZE)
+		return -EINVAL;
+
+	req_size = sizeof(*req) + settings_size;
+	req = kmalloc(req_size, GFP_KERNEL);
+	if (!req)
+		return -ENOMEM;
+
+	req->request_id = request_id;
+	req->streams = streams;
+	req->padding = 0;
+	req->num_frames = num_frames;
+	memcpy(req->settings, settings, settings_size);
+
+	return gb_operation_sync(gcam->connection, GB_CAMERA_TYPE_CAPTURE,
+				 req, req_size, NULL, 0);
+}
+
+static int gb_camera_flush(struct gb_camera *gcam, u32 *request_id)
+{
+	struct gb_camera_flush_response resp;
+	int ret;
+
+	ret = gb_operation_sync(gcam->connection, GB_CAMERA_TYPE_FLUSH, NULL, 0,
+				&resp, sizeof(resp));
+	if (ret < 0)
+		return ret;
+
+	if (request_id)
+		*request_id = resp.request_id;
+
+	return 0;
+}
+
+static int gb_camera_event_recv(u8 type, struct gb_operation *op)
+{
+	struct gb_camera *gcam = op->connection->private;
+	struct gb_camera_metadata_request *payload;
+	struct gb_message *request;
+
+	if (type != GB_CAMERA_TYPE_METADATA) {
+		gcam_err(gcam, "Unsupported unsolicited event: %u\n", type);
+		return -EINVAL;
+	}
+
+	request = op->request;
+
+	if (request->payload_size < sizeof(*payload)) {
+		gcam_err(gcam, "Wrong event size received (%zu < %zu)\n",
+			 request->payload_size, sizeof(*payload));
+		return -EINVAL;
+	}
+
+	payload = request->payload;
+
+	gcam_dbg(gcam, "received metadata for request %u, frame %u, stream %u\n",
+		 payload->request_id, payload->frame_number, payload->stream);
+
+	return 0;
+}
+
+/* -----------------------------------------------------------------------------
+ * DebugFS
+ */
+static ssize_t gb_camera_debugfs_capabilities(struct gb_camera *gcam,
+		char *buf, size_t len)
+{
+	return len;
+}
+
+static ssize_t gb_camera_debugfs_configure_streams(struct gb_camera *gcam,
+		char *buf, size_t len)
+{
+	struct gb_camera_debugfs_buffer *buffer =
+		&gcam->debugfs.buffers[GB_CAMERA_DEBUGFS_BUFFER_STREAMS];
+	struct gb_camera_stream_config *streams;
+	unsigned int nstreams;
+	const char *sep = ";";
+	unsigned int i;
+	char *token;
+	int ret;
+
+	/* Retrieve number of streams to configure */
+	token = strsep(&buf, sep);
+	if (token == NULL)
+		return -EINVAL;
+
+	ret = kstrtouint(token, 10, &nstreams);
+	if (ret < 0)
+		return ret;
+
+	if (nstreams > GB_CAMERA_MAX_STREAMS)
+		return -EINVAL;
+
+	/* For each stream to configure parse width, height and format */
+	streams = kzalloc(nstreams * sizeof(*streams), GFP_KERNEL);
+	if (!streams)
+		return -ENOMEM;
+
+	for (i = 0; i < nstreams; ++i) {
+		struct gb_camera_stream_config *stream = &streams[i];
+
+		/* width */
+		token = strsep(&buf, ";");
+		if (token == NULL) {
+			ret = -EINVAL;
+			goto done;
+		}
+		ret = kstrtouint(token, 10, &stream->width);
+		if (ret < 0)
+			goto done;
+
+		/* height */
+		token = strsep(&buf, ";");
+		if (token == NULL)
+			goto done;
+
+		ret = kstrtouint(token, 10, &stream->height);
+		if (ret < 0)
+			goto done;
+
+		/* Image format code */
+		token = strsep(&buf, ";");
+		if (token == NULL)
+			goto done;
+
+		ret = kstrtouint(token, 16, &stream->format);
+		if (ret < 0)
+			goto done;
+	}
+
+	ret = gb_camera_configure_streams(gcam, nstreams, streams);
+	if (ret < 0)
+		goto done;
+
+	nstreams = ret;
+	buffer->length = sprintf(buffer->data, "%u;", nstreams);
+
+	for (i = 0; i < nstreams; ++i) {
+		struct gb_camera_stream_config *stream = &streams[i];
+
+		buffer->length += sprintf(buffer->data + buffer->length,
+					  "%u;%u;%u;%u;%u;%u;%u;",
+					  stream->width, stream->height,
+					  stream->format, stream->vc,
+					  stream->dt[0], stream->dt[1],
+					  stream->max_size);
+	}
+
+	ret = len;
+
+done:
+	kfree(streams);
+	return ret;
+};
+
+static ssize_t gb_camera_debugfs_capture(struct gb_camera *gcam,
+		char *buf, size_t len)
+{
+	unsigned int request_id;
+	unsigned int streams_mask;
+	unsigned int num_frames;
+	char *token;
+	int ret;
+
+	/* Request id */
+	token = strsep(&buf, ";");
+	if (token == NULL)
+		return -EINVAL;
+	ret = kstrtouint(token, 10, &request_id);
+	if (ret < 0)
+		return ret;
+
+	/* Stream mask */
+	token = strsep(&buf, ";");
+	if (token == NULL)
+		return -EINVAL;
+	ret = kstrtouint(token, 16, &streams_mask);
+	if (ret < 0)
+		return ret;
+
+	/* number of frames */
+	token = strsep(&buf, ";");
+	if (token == NULL)
+		return -EINVAL;
+	ret = kstrtouint(token, 10, &num_frames);
+	if (ret < 0)
+		return ret;
+
+	ret = gb_camera_capture(gcam, request_id, streams_mask, num_frames, 0,
+				NULL);
+	if (ret < 0)
+		return ret;
+
+	return len;
+}
+
+static ssize_t gb_camera_debugfs_flush(struct gb_camera *gcam,
+		char *buf, size_t len)
+{
+	struct gb_camera_debugfs_buffer *buffer =
+		&gcam->debugfs.buffers[GB_CAMERA_DEBUGFS_BUFFER_FLUSH];
+	unsigned int req_id;
+	int ret;
+
+	ret = gb_camera_flush(gcam, &req_id);
+	if (ret < 0)
+		return ret;
+
+	buffer->length = sprintf(buffer->data, "%u", req_id);
+
+	return len;
+}
+
+struct gb_camera_debugfs_entry {
+	const char *name;
+	unsigned int mask;
+	unsigned int buffer;
+	ssize_t (*execute)(struct gb_camera *gcam, char *buf, size_t len);
+};
+
+static const struct gb_camera_debugfs_entry gb_camera_debugfs_entries[] = {
+	{
+		.name = "capabilities",
+		.mask = S_IFREG | S_IRUGO,
+		.buffer = GB_CAMERA_DEBUGFS_BUFFER_CAPABILITIES,
+		.execute = gb_camera_debugfs_capabilities,
+	}, {
+		.name = "configure_streams",
+		.mask = S_IFREG | S_IRUGO | S_IWUGO,
+		.buffer = GB_CAMERA_DEBUGFS_BUFFER_STREAMS,
+		.execute = gb_camera_debugfs_configure_streams,
+	}, {
+		.name = "capture",
+		.mask = S_IFREG | S_IRUGO | S_IWUGO,
+		.buffer = GB_CAMERA_DEBUGFS_BUFFER_CAPTURE,
+		.execute = gb_camera_debugfs_capture,
+	}, {
+		.name = "flush",
+		.mask = S_IFREG | S_IRUGO | S_IWUGO,
+		.buffer = GB_CAMERA_DEBUGFS_BUFFER_FLUSH,
+		.execute = gb_camera_debugfs_flush,
+	},
+};
+
+static ssize_t gb_camera_debugfs_read(struct file *file, char __user *buf,
+				      size_t len, loff_t *offset)
+{
+	const struct gb_camera_debugfs_entry *op = file->private_data;
+	struct gb_camera *gcam = file->f_inode->i_private;
+	struct gb_camera_debugfs_buffer *buffer;
+	ssize_t ret;
+
+	/* For read-only entries the operation is triggered by a read. */
+	if (!(op->mask & S_IWUGO)) {
+		ret = op->execute(gcam, NULL, 0);
+		if (ret < 0)
+			return ret;
+	}
+
+	buffer = &gcam->debugfs.buffers[op->buffer];
+
+	return simple_read_from_buffer(buf, len, offset, buffer->data,
+				       buffer->length);
+}
+
+static ssize_t gb_camera_debugfs_write(struct file *file,
+				       const char __user *buf, size_t len,
+				       loff_t *offset)
+{
+	const struct gb_camera_debugfs_entry *op = file->private_data;
+	struct gb_camera *gcam = file->f_inode->i_private;
+	ssize_t ret;
+	char *kbuf;
+
+	if (len > 1024)
+	       return -EINVAL;
+
+	kbuf = kmalloc(len + 1, GFP_KERNEL);
+	if (kbuf == NULL)
+		return -ENOMEM;
+
+	if (copy_from_user(kbuf, buf, len)) {
+		ret = -EFAULT;
+		goto done;
+	}
+
+	kbuf[len] = '\0';
+
+	ret = op->execute(gcam, kbuf, len);
+
+done:
+	kfree(kbuf);
+	return ret;
+}
+
+static int gb_camera_debugfs_open(struct inode *inode, struct file *file)
+{
+	unsigned int i;
+
+	for (i = 0; i < ARRAY_SIZE(gb_camera_debugfs_entries); ++i) {
+		const struct gb_camera_debugfs_entry *entry =
+			&gb_camera_debugfs_entries[i];
+
+		if (!strcmp(file->f_dentry->d_iname, entry->name)) {
+			file->private_data = (void *)entry;
+			break;
+		}
+	}
+
+	return 0;
+}
+
+static const struct file_operations gb_camera_debugfs_ops = {
+	.open = gb_camera_debugfs_open,
+	.read = gb_camera_debugfs_read,
+	.write = gb_camera_debugfs_write,
+};
+
+static int gb_camera_debugfs_init(struct gb_camera *gcam)
+{
+	struct gb_connection *connection = gcam->connection;
+	char dirname[27];
+	unsigned int i;
+
+	/*
+	 * Create root debugfs entry and a file entry for each camera operation.
+	 */
+	snprintf(dirname, 27, "camera-%u.%u", connection->intf->interface_id,
+		 connection->bundle->id);
+
+	gcam->debugfs.root = debugfs_create_dir(dirname, gb_debugfs_get());
+	if (IS_ERR(gcam->debugfs.root)) {
+		gcam_err(gcam, "debugfs root create failed (%ld)\n",
+			 PTR_ERR(gcam->debugfs.root));
+		return PTR_ERR(gcam->debugfs.root);
+	}
+
+	gcam->debugfs.buffers = vmalloc(sizeof(*gcam->debugfs.buffers) *
+					GB_CAMERA_DEBUGFS_BUFFER_MAX);
+	if (!gcam->debugfs.buffers)
+		return -ENOMEM;
+
+	for (i = 0; i < ARRAY_SIZE(gb_camera_debugfs_entries); ++i) {
+		const struct gb_camera_debugfs_entry *entry =
+			&gb_camera_debugfs_entries[i];
+		struct dentry *dentry;
+
+		gcam->debugfs.buffers[i].length = 0;
+
+		dentry = debugfs_create_file(entry->name, entry->mask,
+					     gcam->debugfs.root, gcam,
+					     &gb_camera_debugfs_ops);
+		if (IS_ERR(dentry)) {
+			gcam_err(gcam,
+				 "debugfs operation %s create failed (%ld)\n",
+				 entry->name, PTR_ERR(gcam->debugfs.root));
+			return PTR_ERR(dentry);
+		}
+	}
+
+	return 0;
+}
+
+static void gb_camera_debugfs_cleanup(struct gb_camera *gcam)
+{
+	if (gcam->debugfs.root)
+		debugfs_remove_recursive(gcam->debugfs.root);
+
+	vfree(gcam->debugfs.buffers);
+}
+
+/* -----------------------------------------------------------------------------
+ * Init & Cleanup
+ */
+
+static void gb_camera_cleanup(struct gb_camera *gcam)
+{
+	gb_camera_debugfs_cleanup(gcam);
+
+	if (gcam->data_connected) {
+		struct gb_interface *intf = gcam->connection->intf;
+		struct gb_svc *svc = gcam->connection->hd->svc;
+
+		gb_svc_connection_destroy(svc, intf->interface_id,
+					  ES2_APB_CDSI0_CPORT, svc->ap_intf_id,
+					  ES2_APB_CDSI1_CPORT);
+	}
+
+	kfree(gcam);
+}
+
+static int gb_camera_connection_init(struct gb_connection *connection)
+{
+	struct gb_svc *svc = connection->hd->svc;
+	struct gb_camera *gcam;
+	int ret;
+
+	gcam = kzalloc(sizeof(*gcam), GFP_KERNEL);
+	if (!gcam)
+		return -ENOMEM;
+
+	gcam->connection = connection;
+	connection->private = gcam;
+
+	/*
+	 * Create the data connection between camera module CDSI0 and APB CDS1.
+	 * The CPort IDs are hardcoded by the ES2 bridges.
+	 */
+	ret = gb_svc_connection_create(svc, connection->intf->interface_id,
+				       ES2_APB_CDSI0_CPORT, svc->ap_intf_id,
+				       ES2_APB_CDSI1_CPORT, false);
+	if (ret < 0)
+		goto error;
+
+	gcam->data_connected = true;
+
+	ret = gb_camera_debugfs_init(gcam);
+	if (ret < 0)
+		goto error;
+
+	return 0;
+
+error:
+	gb_camera_cleanup(gcam);
+	return ret;
+}
+
+static void gb_camera_connection_exit(struct gb_connection *connection)
+{
+	struct gb_camera *gcam = connection->private;
+
+	gb_camera_cleanup(gcam);
+}
+
+static struct gb_protocol camera_protocol = {
+	.name			= "camera",
+	.id			= GREYBUS_PROTOCOL_CAMERA_MGMT,
+	.major			= GB_CAMERA_VERSION_MAJOR,
+	.minor			= GB_CAMERA_VERSION_MINOR,
+	.connection_init	= gb_camera_connection_init,
+	.connection_exit	= gb_camera_connection_exit,
+	.request_recv		= gb_camera_event_recv,
+};
+
+gb_protocol_driver(&camera_protocol);
+
+MODULE_LICENSE("GPL v2");
