commit ec0ad868173da8a75121f9dc116a5d5478ff614d
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Sun Aug 25 07:54:27 2019 +0200

    staging: greybus: move core include files to include/linux/greybus/
    
    With the goal of moving the core of the greybus code out of staging, the
    include files need to be moved to include/linux/greybus.h and
    include/linux/greybus/
    
    Cc: Vaibhav Hiremath <hvaibhav.linux@gmail.com>
    Cc: Johan Hovold <johan@kernel.org>
    Cc: Vaibhav Agarwal <vaibhav.sr@gmail.com>
    Cc: Rui Miguel Silva <rmfrfs@gmail.com>
    Cc: David Lin <dtwlin@gmail.com>
    Cc: "Bryan O'Donoghue" <pure.logic@nexus-software.ie>
    Cc: greybus-dev@lists.linaro.org
    Cc: devel@driverdev.osuosl.org
    Acked-by: Mark Greer <mgreer@animalcreek.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Acked-by: Alex Elder <elder@kernel.org>
    Link: https://lore.kernel.org/r/20190825055429.18547-8-gregkh@linuxfoundation.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/spilib.c b/drivers/staging/greybus/spilib.c
index 2e07c6b41334..fc27c52de74a 100644
--- a/drivers/staging/greybus/spilib.c
+++ b/drivers/staging/greybus/spilib.c
@@ -10,9 +10,9 @@
 #include <linux/kernel.h>
 #include <linux/module.h>
 #include <linux/slab.h>
+#include <linux/greybus.h>
 #include <linux/spi/spi.h>
 
-#include "greybus.h"
 #include "spilib.h"
 
 struct gb_spilib {

commit 863dbc52e7f0e5acd7b4883f3933543a81c474c7
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Nov 7 14:58:42 2017 +0100

    staging: greybus: Remove redundant license text
    
    Now that the SPDX tag is in all greybus files, that identifies the
    license in a specific and legally-defined manner.  So the extra GPL text
    wording can be removed as it is no longer needed at all.
    
    This is done on a quest to remove the 700+ different ways that files in
    the kernel describe the GPL license text.  And there's unneeded stuff
    like the address (sometimes incorrect) for the FSF which is never
    needed.
    
    No copyright headers or other non-license-description text was removed.
    
    Cc: Vaibhav Hiremath <hvaibhav.linux@gmail.com>
    Reviewed-by: Alex Elder <elder@linaro.org>
    Acked-by: Vaibhav Agarwal <vaibhav.sr@gmail.com>
    Acked-by: David Lin <dtwlin@gmail.com>
    Acked-by: Johan Hovold <johan@kernel.org>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Acked-by: Mark Greer <mgreer@animalcreek.com>
    Acked-by: Rui Miguel Silva <rmfrfs@gmail.com>
    Acked-by: "Bryan O'Donoghue" <pure.logic@nexus-software.ie>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/spilib.c b/drivers/staging/greybus/spilib.c
index 9b4424d9910e..2e07c6b41334 100644
--- a/drivers/staging/greybus/spilib.c
+++ b/drivers/staging/greybus/spilib.c
@@ -4,8 +4,6 @@
  *
  * Copyright 2014-2016 Google Inc.
  * Copyright 2014-2016 Linaro Ltd.
- *
- * Released under the GPLv2 only.
  */
 
 #include <linux/bitops.h>

commit eb50fd3a22c770f36be275295b782f3ea52e3215
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Nov 7 14:58:41 2017 +0100

    staging: greybus: add SPDX identifiers to all greybus driver files
    
    It's good to have SPDX identifiers in all files to make it easier to
    audit the kernel tree for correct licenses.
    
    Update the drivers/staging/greybus files files with the correct SPDX
    license identifier based on the license text in the file itself.  The
    SPDX identifier is a legally binding shorthand, which can be used
    instead of the full boiler plate text.
    
    This work is based on a script and data from Thomas Gleixner, Philippe
    Ombredanne, and Kate Stewart.
    
    Cc: Vaibhav Hiremath <hvaibhav.linux@gmail.com>
    Cc: "Bryan O'Donoghue" <pure.logic@nexus-software.ie>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: Philippe Ombredanne <pombredanne@nexb.com>
    Acked-by: Vaibhav Agarwal <vaibhav.sr@gmail.com>
    Acked-by: David Lin <dtwlin@gmail.com>
    Reviewed-by: Alex Elder <elder@linaro.org>
    Acked-by: Johan Hovold <johan@kernel.org>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Acked-by: Mark Greer <mgreer@animalcreek.com>
    Acked-by: Rui Miguel Silva <rmfrfs@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/spilib.c b/drivers/staging/greybus/spilib.c
index 1e7321a1404c..9b4424d9910e 100644
--- a/drivers/staging/greybus/spilib.c
+++ b/drivers/staging/greybus/spilib.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * Greybus SPI library
  *

commit 770b03c2ca4aa44d226cf248f86aa23e546147d0
Author: Johan Hovold <johan@kernel.org>
Date:   Sun Oct 29 13:01:33 2017 +0100

    staging: greybus: spilib: fix use-after-free after deregistration
    
    Remove erroneous spi_master_put() after controller deregistration which
    would access the already freed spi controller.
    
    Note that spi_unregister_master() drops our only controller reference.
    
    Fixes: ba3e67001b42 ("greybus: SPI: convert to a gpbridge driver")
    Cc: stable <stable@vger.kernel.org>     # 4.9
    Signed-off-by: Johan Hovold <johan@kernel.org>
    Reviewed-by: Rui Miguel Silva <rmfrfs@gmail.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/spilib.c b/drivers/staging/greybus/spilib.c
index e97b19148497..1e7321a1404c 100644
--- a/drivers/staging/greybus/spilib.c
+++ b/drivers/staging/greybus/spilib.c
@@ -544,11 +544,14 @@ int gb_spilib_master_init(struct gb_connection *connection, struct device *dev,
 
 	return 0;
 
-exit_spi_unregister:
-	spi_unregister_master(master);
 exit_spi_put:
 	spi_master_put(master);
 
+	return ret;
+
+exit_spi_unregister:
+	spi_unregister_master(master);
+
 	return ret;
 }
 EXPORT_SYMBOL_GPL(gb_spilib_master_init);
@@ -558,7 +561,6 @@ void gb_spilib_master_exit(struct gb_connection *connection)
 	struct spi_master *master = gb_connection_get_data(connection);
 
 	spi_unregister_master(master);
-	spi_master_put(master);
 }
 EXPORT_SYMBOL_GPL(gb_spilib_master_exit);
 

commit 148e0b8f48a83008596876befe1d9aed256c8ea1
Author: Greg Kroah-Hartman <gregkh@google.com>
Date:   Thu Sep 8 16:06:27 2016 +0200

    staging: greybus: spi: remove KERNEL_VERSION checks
    
    No need to support older kernel versions in the Greybus SPI and spilib
    driver, so remove the checks as needed, we can now rely on all of the
    correct SPI core apis being present.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/spilib.c b/drivers/staging/greybus/spilib.c
index 9427c313dd4e..e97b19148497 100644
--- a/drivers/staging/greybus/spilib.c
+++ b/drivers/staging/greybus/spilib.c
@@ -456,10 +456,10 @@ static int gb_spi_setup_device(struct gb_spilib *spi, u8 cs)
 	dev_type = response.device_type;
 
 	if (dev_type == GB_SPI_SPI_DEV)
-		strlcpy(spi_board.modalias, SPI_DEV_MODALIAS,
+		strlcpy(spi_board.modalias, "spidev",
 			sizeof(spi_board.modalias));
 	else if (dev_type == GB_SPI_SPI_NOR)
-		strlcpy(spi_board.modalias, SPI_NOR_MODALIAS,
+		strlcpy(spi_board.modalias, "spi-nor",
 			sizeof(spi_board.modalias));
 	else if (dev_type == GB_SPI_SPI_MODALIAS)
 		memcpy(spi_board.modalias, response.name,
@@ -526,9 +526,7 @@ int gb_spilib_master_init(struct gb_connection *connection, struct device *dev,
 			gb_spi_unprepare_transfer_hardware;
 	}
 
-#ifdef SPI_CORE_SUPPORT_PM
 	master->auto_runtime_pm = true;
-#endif
 
 	ret = spi_register_master(master);
 	if (ret < 0)

commit 92bcaddea3197e477bb37439805fcb5a2f9942d7
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Thu Jul 21 14:45:06 2016 -0700

    greybus: spilib: make spilib independent of gbphy
    
    spilib is used by multiple users currently (spi.c and fw-core.c) but
    commit aa52b62a0556 broke that hierarchy and introduced gbphy dependent
    code in spilib.
    
    This may have unreliable consequences as we are doing following
    operation unconditionally now:
    
            gbphy_dev = to_gbphy_dev(spi->parent);
            gbphy_runtime_get_sync(gbphy_dev);
    
    which may not go well when the parent is of type &bundle->dev
    (fw-core.c).
    
    This patch introduces spilib_ops and lets the users of the core register
    them. This shall have no functional change for the spi.c usecase and
    shall fix the unreliable results for the fw-core.c usecase.
    
    Tested by writing to mtd0 dev and verifying (with print messages) that
    the below routines are getting called for a gpbridge-test module.
    
    Fixes: aa52b62a0556 ("spi: Add runtime_pm support")
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/spilib.c b/drivers/staging/greybus/spilib.c
index e4c82e0a322b..9427c313dd4e 100644
--- a/drivers/staging/greybus/spilib.c
+++ b/drivers/staging/greybus/spilib.c
@@ -15,13 +15,13 @@
 
 #include "greybus.h"
 #include "spilib.h"
-#include "gbphy.h"
 
 struct gb_spilib {
 	struct gb_connection	*connection;
 	struct device		*parent;
 	struct spi_transfer	*first_xfer;
 	struct spi_transfer	*last_xfer;
+	struct spilib_ops	*ops;
 	u32			rx_xfer_offset;
 	u32			tx_xfer_offset;
 	u32			last_xfer_size;
@@ -373,25 +373,21 @@ static int gb_spi_transfer_one_message(struct spi_master *master,
 	return ret;
 }
 
-#ifndef SPI_CORE_SUPPORT_PM
 static int gb_spi_prepare_transfer_hardware(struct spi_master *master)
 {
 	struct gb_spilib *spi = spi_master_get_devdata(master);
-	struct gbphy_device *gbphy_dev = to_gbphy_dev(spi->parent);
 
-	return gbphy_runtime_get_sync(gbphy_dev);
+	return spi->ops->prepare_transfer_hardware(spi->parent);
 }
 
 static int gb_spi_unprepare_transfer_hardware(struct spi_master *master)
 {
 	struct gb_spilib *spi = spi_master_get_devdata(master);
-	struct gbphy_device *gbphy_dev = to_gbphy_dev(spi->parent);
 
-	gbphy_runtime_put_autosuspend(gbphy_dev);
+	spi->ops->unprepare_transfer_hardware(spi->parent);
 
 	return 0;
 }
-#endif
 
 static int gb_spi_setup(struct spi_device *spi)
 {
@@ -483,7 +479,8 @@ static int gb_spi_setup_device(struct gb_spilib *spi, u8 cs)
 	return 0;
 }
 
-int gb_spilib_master_init(struct gb_connection *connection, struct device *dev)
+int gb_spilib_master_init(struct gb_connection *connection, struct device *dev,
+			  struct spilib_ops *ops)
 {
 	struct gb_spilib *spi;
 	struct spi_master *master;
@@ -501,6 +498,7 @@ int gb_spilib_master_init(struct gb_connection *connection, struct device *dev)
 	spi->connection = connection;
 	gb_connection_set_data(connection, master);
 	spi->parent = dev;
+	spi->ops = ops;
 
 	/* get master configuration */
 	ret = gb_spi_get_master_config(spi);
@@ -518,11 +516,17 @@ int gb_spilib_master_init(struct gb_connection *connection, struct device *dev)
 	master->setup = gb_spi_setup;
 	master->transfer_one_message = gb_spi_transfer_one_message;
 
-#ifndef SPI_CORE_SUPPORT_PM
-	master->prepare_transfer_hardware = gb_spi_prepare_transfer_hardware;
-	master->unprepare_transfer_hardware =
+	if (ops && ops->prepare_transfer_hardware) {
+		master->prepare_transfer_hardware =
+			gb_spi_prepare_transfer_hardware;
+	}
+
+	if (ops && ops->unprepare_transfer_hardware) {
+		master->unprepare_transfer_hardware =
 			gb_spi_unprepare_transfer_hardware;
-#else
+	}
+
+#ifdef SPI_CORE_SUPPORT_PM
 	master->auto_runtime_pm = true;
 #endif
 

commit 4c615dcc6a9d910f8f68e4b57889b628e80165d4
Author: Axel Haslam <ahaslam@baylibre.com>
Date:   Thu Jul 14 15:13:00 2016 -0500

    greybus: spi: Add runtime_pm support
    
    Add runtime operations to the spi driver so that the
    module is woken up when an spi transfer is started
    and put back to sleep when the transfer is done.
    
    Testing Done: Let the module enter standby and initiate
    an spi operation. The operation wakes up the module
    and succeeds.
    
    Signed-off-by: Axel Haslam <ahaslam@baylibre.com>
    Signed-off-by: David Lin <dtwlin@google.com>
    Reviewed-by: Rui Miguel Silva <rui.silva@linaro.org>
    Signed-off-by: Alex Elder <elder@linaro.org>

diff --git a/drivers/staging/greybus/spilib.c b/drivers/staging/greybus/spilib.c
index 527909b26d79..e4c82e0a322b 100644
--- a/drivers/staging/greybus/spilib.c
+++ b/drivers/staging/greybus/spilib.c
@@ -15,6 +15,7 @@
 
 #include "greybus.h"
 #include "spilib.h"
+#include "gbphy.h"
 
 struct gb_spilib {
 	struct gb_connection	*connection;
@@ -372,6 +373,26 @@ static int gb_spi_transfer_one_message(struct spi_master *master,
 	return ret;
 }
 
+#ifndef SPI_CORE_SUPPORT_PM
+static int gb_spi_prepare_transfer_hardware(struct spi_master *master)
+{
+	struct gb_spilib *spi = spi_master_get_devdata(master);
+	struct gbphy_device *gbphy_dev = to_gbphy_dev(spi->parent);
+
+	return gbphy_runtime_get_sync(gbphy_dev);
+}
+
+static int gb_spi_unprepare_transfer_hardware(struct spi_master *master)
+{
+	struct gb_spilib *spi = spi_master_get_devdata(master);
+	struct gbphy_device *gbphy_dev = to_gbphy_dev(spi->parent);
+
+	gbphy_runtime_put_autosuspend(gbphy_dev);
+
+	return 0;
+}
+#endif
+
 static int gb_spi_setup(struct spi_device *spi)
 {
 	/* Nothing to do for now */
@@ -497,6 +518,14 @@ int gb_spilib_master_init(struct gb_connection *connection, struct device *dev)
 	master->setup = gb_spi_setup;
 	master->transfer_one_message = gb_spi_transfer_one_message;
 
+#ifndef SPI_CORE_SUPPORT_PM
+	master->prepare_transfer_hardware = gb_spi_prepare_transfer_hardware;
+	master->unprepare_transfer_hardware =
+			gb_spi_unprepare_transfer_hardware;
+#else
+	master->auto_runtime_pm = true;
+#endif
+
 	ret = spi_register_master(master);
 	if (ret < 0)
 		goto exit_spi_put;

commit 60fb3405c73ea0bbab942c699496123f9e987c04
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Fri Jun 10 14:59:07 2016 +0530

    greybus: Remove extra blank lines
    
    This patch removes few blank lines across the repository at places where
    two blank lines were present together or when a blank line is present at
    the start or end of a routine.
    
    Note that this doesn't remove most of them from greybus_protocols.h as
    they were added on purpose.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/spilib.c b/drivers/staging/greybus/spilib.c
index 79ae044b78f3..527909b26d79 100644
--- a/drivers/staging/greybus/spilib.c
+++ b/drivers/staging/greybus/spilib.c
@@ -383,7 +383,6 @@ static void gb_spi_cleanup(struct spi_device *spi)
 	/* Nothing to do for now */
 }
 
-
 /* Routines to get controller information */
 
 /*

commit 3a238fc7844f93c799283d8b822178af9638ff0c
Author: Rui Miguel Silva <rui.silva@linaro.org>
Date:   Mon May 16 10:33:21 2016 +0100

    greybus: spi: add inprogress bit to xfer_flags
    
    When a SPI transfer needs to be split by more than one greybus spi
    transfer operation, we need to indicate it so the controller can handle
    the chip select lines correctly.
    
    Add a new bit to indicate it, GB_SPI_XFER_INPROGRESS, and create an
    helper function to calculate when the transfer is done. As we need this
    information also in other places.
    
    Signed-off-by: Rui Miguel Silva <rui.silva@linaro.org>
    Reviewed-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/spilib.c b/drivers/staging/greybus/spilib.c
index 9eecbf391259..79ae044b78f3 100644
--- a/drivers/staging/greybus/spilib.c
+++ b/drivers/staging/greybus/spilib.c
@@ -102,6 +102,17 @@ static void clean_xfer_state(struct gb_spilib *spi)
 	spi->op_timeout = 0;
 }
 
+static bool is_last_xfer_done(struct gb_spilib *spi)
+{
+	struct spi_transfer *last_xfer = spi->last_xfer;
+
+	if ((spi->tx_xfer_offset + spi->last_xfer_size == last_xfer->len) ||
+	    (spi->rx_xfer_offset + spi->last_xfer_size == last_xfer->len))
+		return true;
+
+	return false;
+}
+
 static int setup_next_xfer(struct gb_spilib *spi, struct spi_message *msg)
 {
 	struct spi_transfer *last_xfer = spi->last_xfer;
@@ -113,8 +124,7 @@ static int setup_next_xfer(struct gb_spilib *spi, struct spi_message *msg)
 	 * if we transferred all content of the last transfer, reset values and
 	 * check if this was the last transfer in the message
 	 */
-	if ((spi->tx_xfer_offset + spi->last_xfer_size == last_xfer->len) ||
-	    (spi->rx_xfer_offset + spi->last_xfer_size == last_xfer->len)) {
+	if (is_last_xfer_done(spi)) {
 		spi->tx_xfer_offset = 0;
 		spi->rx_xfer_offset = 0;
 		spi->op_timeout = 0;
@@ -265,6 +275,8 @@ static struct gb_operation *gb_spi_operation_create(struct gb_spilib *spi,
 			gb_xfer->xfer_flags |= GB_SPI_XFER_READ;
 
 		if (xfer == spi->last_xfer) {
+			if (!is_last_xfer_done(spi))
+				gb_xfer->xfer_flags |= GB_SPI_XFER_INPROGRESS;
 			msg->state = GB_SPI_STATE_OP_DONE;
 			continue;
 		}

commit 22e26a3a13503f3c35ed8bbb6a7e9e33ad2c6987
Author: Rui Miguel Silva <rui.silva@linaro.org>
Date:   Mon May 16 10:33:20 2016 +0100

    greybus: spi: rename rdwr field to xfer_flags
    
    As more bits will be added to the field, let's make the field more
    generic and name it accordingly. So, rename it from rdwr to xfer_flags.
    
    Signed-off-by: Rui Miguel Silva <rui.silva@linaro.org>
    Reviewed-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/spilib.c b/drivers/staging/greybus/spilib.c
index 6ab1c5f77b7a..9eecbf391259 100644
--- a/drivers/staging/greybus/spilib.c
+++ b/drivers/staging/greybus/spilib.c
@@ -255,14 +255,14 @@ static struct gb_operation *gb_spi_operation_create(struct gb_spilib *spi,
 
 		/* Copy tx data */
 		if (xfer->tx_buf) {
-			gb_xfer->rdwr |= GB_SPI_XFER_WRITE;
+			gb_xfer->xfer_flags |= GB_SPI_XFER_WRITE;
 			memcpy(tx_data, xfer->tx_buf + spi->tx_xfer_offset,
 			       xfer_len);
 			tx_data += xfer_len;
 		}
 
 		if (xfer->rx_buf)
-			gb_xfer->rdwr |= GB_SPI_XFER_READ;
+			gb_xfer->xfer_flags |= GB_SPI_XFER_READ;
 
 		if (xfer == spi->last_xfer) {
 			msg->state = GB_SPI_STATE_OP_DONE;

commit 8888b963743be7aad2a98bc165fb51150db5fd9f
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Sat May 14 23:42:20 2016 +0530

    greybus: spi: Separate out spilib from spi bridged PHY bundle driver
    
    spilib can be used by multiple bridge drivers implementing different
    bundle classes. Separate out bridged PHY bundle drivers parts.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Reviewed-by: Rui Miguel Silva <rui.silva@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/spilib.c b/drivers/staging/greybus/spilib.c
index c7fe87801187..6ab1c5f77b7a 100644
--- a/drivers/staging/greybus/spilib.c
+++ b/drivers/staging/greybus/spilib.c
@@ -14,7 +14,6 @@
 #include <linux/spi/spi.h>
 
 #include "greybus.h"
-#include "gpbridge.h"
 #include "spilib.h"
 
 struct gb_spilib {
@@ -521,63 +520,4 @@ void gb_spilib_master_exit(struct gb_connection *connection)
 }
 EXPORT_SYMBOL_GPL(gb_spilib_master_exit);
 
-static int gb_spi_probe(struct gpbridge_device *gpbdev,
-			const struct gpbridge_device_id *id)
-{
-	struct gb_connection *connection;
-	int ret;
-
-	connection = gb_connection_create(gpbdev->bundle,
-					  le16_to_cpu(gpbdev->cport_desc->id),
-					  NULL);
-	if (IS_ERR(connection))
-		return PTR_ERR(connection);
-
-	ret = gb_connection_enable(connection);
-	if (ret)
-		goto exit_connection_destroy;
-
-	ret = gb_gpbridge_get_version(connection);
-	if (ret)
-		goto exit_connection_disable;
-
-	ret = gb_spilib_master_init(connection, &gpbdev->dev);
-	if (ret)
-		goto exit_connection_disable;
-
-	gb_gpbridge_set_data(gpbdev, connection);
-
-	return 0;
-
-exit_connection_disable:
-	gb_connection_disable(connection);
-exit_connection_destroy:
-	gb_connection_destroy(connection);
-
-	return ret;
-}
-
-static void gb_spi_remove(struct gpbridge_device *gpbdev)
-{
-	struct gb_connection *connection = gb_gpbridge_get_data(gpbdev);
-
-	gb_spilib_master_exit(connection);
-	gb_connection_disable(connection);
-	gb_connection_destroy(connection);
-}
-
-static const struct gpbridge_device_id gb_spi_id_table[] = {
-	{ GPBRIDGE_PROTOCOL(GREYBUS_PROTOCOL_SPI) },
-	{ },
-};
-MODULE_DEVICE_TABLE(gpbridge, gb_spi_id_table);
-
-static struct gpbridge_driver spi_driver = {
-	.name		= "spi",
-	.probe		= gb_spi_probe,
-	.remove		= gb_spi_remove,
-	.id_table	= gb_spi_id_table,
-};
-
-module_gpbridge_driver(spi_driver);
 MODULE_LICENSE("GPL v2");

commit 4c412921c78732f8f803a5906c97746ede5cf77c
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Sat May 14 23:42:19 2016 +0530

    greybus: spi: Restructure spi.c to share it with other bundle drivers
    
    This patch restructures spi.c as spilib core, so that the same logic can
    be reused for SPI connections implemented as part of different bundle
    types. This is required for Firmware Management Bundle.
    
    Note that the 'struct gb_protocol' and its callback aren't moved to
    a separate file in this commit to make its reviews easier. That will be
    done by a following patch.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Reviewed-by: Rui Miguel Silva <rui.silva@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/spilib.c b/drivers/staging/greybus/spilib.c
new file mode 100644
index 000000000000..c7fe87801187
--- /dev/null
+++ b/drivers/staging/greybus/spilib.c
@@ -0,0 +1,583 @@
+/*
+ * Greybus SPI library
+ *
+ * Copyright 2014-2016 Google Inc.
+ * Copyright 2014-2016 Linaro Ltd.
+ *
+ * Released under the GPLv2 only.
+ */
+
+#include <linux/bitops.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/spi/spi.h>
+
+#include "greybus.h"
+#include "gpbridge.h"
+#include "spilib.h"
+
+struct gb_spilib {
+	struct gb_connection	*connection;
+	struct device		*parent;
+	struct spi_transfer	*first_xfer;
+	struct spi_transfer	*last_xfer;
+	u32			rx_xfer_offset;
+	u32			tx_xfer_offset;
+	u32			last_xfer_size;
+	unsigned int		op_timeout;
+	u16			mode;
+	u16			flags;
+	u32			bits_per_word_mask;
+	u8			num_chipselect;
+	u32			min_speed_hz;
+	u32			max_speed_hz;
+};
+
+#define GB_SPI_STATE_MSG_DONE		((void *)0)
+#define GB_SPI_STATE_MSG_IDLE		((void *)1)
+#define GB_SPI_STATE_MSG_RUNNING	((void *)2)
+#define GB_SPI_STATE_OP_READY		((void *)3)
+#define GB_SPI_STATE_OP_DONE		((void *)4)
+#define GB_SPI_STATE_MSG_ERROR		((void *)-1)
+
+#define XFER_TIMEOUT_TOLERANCE		200
+
+static struct spi_master *get_master_from_spi(struct gb_spilib *spi)
+{
+	return gb_connection_get_data(spi->connection);
+}
+
+static int tx_header_fit_operation(u32 tx_size, u32 count, size_t data_max)
+{
+	size_t headers_size;
+
+	data_max -= sizeof(struct gb_spi_transfer_request);
+	headers_size = (count + 1) * sizeof(struct gb_spi_transfer);
+
+	return tx_size + headers_size > data_max ? 0 : 1;
+}
+
+static size_t calc_rx_xfer_size(u32 rx_size, u32 *tx_xfer_size, u32 len,
+				size_t data_max)
+{
+	size_t rx_xfer_size;
+
+	data_max -= sizeof(struct gb_spi_transfer_response);
+
+	if (rx_size + len > data_max)
+		rx_xfer_size = data_max - rx_size;
+	else
+		rx_xfer_size = len;
+
+	/* if this is a write_read, for symmetry read the same as write */
+	if (*tx_xfer_size && rx_xfer_size > *tx_xfer_size)
+		rx_xfer_size = *tx_xfer_size;
+	if (*tx_xfer_size && rx_xfer_size < *tx_xfer_size)
+		*tx_xfer_size = rx_xfer_size;
+
+	return rx_xfer_size;
+}
+
+static size_t calc_tx_xfer_size(u32 tx_size, u32 count, size_t len,
+				size_t data_max)
+{
+	size_t headers_size;
+
+	data_max -= sizeof(struct gb_spi_transfer_request);
+	headers_size = (count + 1) * sizeof(struct gb_spi_transfer);
+
+	if (tx_size + headers_size + len > data_max)
+		return data_max - (tx_size + sizeof(struct gb_spi_transfer));
+
+	return len;
+}
+
+static void clean_xfer_state(struct gb_spilib *spi)
+{
+	spi->first_xfer = NULL;
+	spi->last_xfer = NULL;
+	spi->rx_xfer_offset = 0;
+	spi->tx_xfer_offset = 0;
+	spi->last_xfer_size = 0;
+	spi->op_timeout = 0;
+}
+
+static int setup_next_xfer(struct gb_spilib *spi, struct spi_message *msg)
+{
+	struct spi_transfer *last_xfer = spi->last_xfer;
+
+	if (msg->state != GB_SPI_STATE_OP_DONE)
+		return 0;
+
+	/*
+	 * if we transferred all content of the last transfer, reset values and
+	 * check if this was the last transfer in the message
+	 */
+	if ((spi->tx_xfer_offset + spi->last_xfer_size == last_xfer->len) ||
+	    (spi->rx_xfer_offset + spi->last_xfer_size == last_xfer->len)) {
+		spi->tx_xfer_offset = 0;
+		spi->rx_xfer_offset = 0;
+		spi->op_timeout = 0;
+		if (last_xfer == list_last_entry(&msg->transfers,
+						 struct spi_transfer,
+						 transfer_list))
+			msg->state = GB_SPI_STATE_MSG_DONE;
+		else
+			spi->first_xfer = list_next_entry(last_xfer,
+							  transfer_list);
+		return 0;
+	}
+
+	spi->first_xfer = last_xfer;
+	if (last_xfer->tx_buf)
+		spi->tx_xfer_offset += spi->last_xfer_size;
+
+	if (last_xfer->rx_buf)
+		spi->rx_xfer_offset += spi->last_xfer_size;
+
+	return 0;
+}
+
+static struct spi_transfer *get_next_xfer(struct spi_transfer *xfer,
+					  struct spi_message *msg)
+{
+	if (xfer == list_last_entry(&msg->transfers, struct spi_transfer,
+				    transfer_list))
+		return NULL;
+
+	return list_next_entry(xfer, transfer_list);
+}
+
+/* Routines to transfer data */
+static struct gb_operation *gb_spi_operation_create(struct gb_spilib *spi,
+		struct gb_connection *connection, struct spi_message *msg)
+{
+	struct gb_spi_transfer_request *request;
+	struct spi_device *dev = msg->spi;
+	struct spi_transfer *xfer;
+	struct gb_spi_transfer *gb_xfer;
+	struct gb_operation *operation;
+	u32 tx_size = 0, rx_size = 0, count = 0, xfer_len = 0, request_size;
+	u32 tx_xfer_size = 0, rx_xfer_size = 0, len;
+	u32 total_len = 0;
+	unsigned int xfer_timeout;
+	size_t data_max;
+	void *tx_data;
+
+	data_max = gb_operation_get_payload_size_max(connection);
+	xfer = spi->first_xfer;
+
+	/* Find number of transfers queued and tx/rx length in the message */
+
+	while (msg->state != GB_SPI_STATE_OP_READY) {
+		msg->state = GB_SPI_STATE_MSG_RUNNING;
+		spi->last_xfer = xfer;
+
+		if (!xfer->tx_buf && !xfer->rx_buf) {
+			dev_err(spi->parent,
+				"bufferless transfer, length %u\n", xfer->len);
+			msg->state = GB_SPI_STATE_MSG_ERROR;
+			return NULL;
+		}
+
+		tx_xfer_size = 0;
+		rx_xfer_size = 0;
+
+		if (xfer->tx_buf) {
+			len = xfer->len - spi->tx_xfer_offset;
+			if (!tx_header_fit_operation(tx_size, count, data_max))
+				break;
+			tx_xfer_size = calc_tx_xfer_size(tx_size, count,
+							 len, data_max);
+			spi->last_xfer_size = tx_xfer_size;
+		}
+
+		if (xfer->rx_buf) {
+			len = xfer->len - spi->rx_xfer_offset;
+			rx_xfer_size = calc_rx_xfer_size(rx_size, &tx_xfer_size,
+							 len, data_max);
+			spi->last_xfer_size = rx_xfer_size;
+		}
+
+		tx_size += tx_xfer_size;
+		rx_size += rx_xfer_size;
+
+		total_len += spi->last_xfer_size;
+		count++;
+
+		xfer = get_next_xfer(xfer, msg);
+		if (!xfer || total_len >= data_max)
+			msg->state = GB_SPI_STATE_OP_READY;
+	}
+
+	/*
+	 * In addition to space for all message descriptors we need
+	 * to have enough to hold all tx data.
+	 */
+	request_size = sizeof(*request);
+	request_size += count * sizeof(*gb_xfer);
+	request_size += tx_size;
+
+	/* Response consists only of incoming data */
+	operation = gb_operation_create(connection, GB_SPI_TYPE_TRANSFER,
+					request_size, rx_size, GFP_KERNEL);
+	if (!operation)
+		return NULL;
+
+	request = operation->request->payload;
+	request->count = cpu_to_le16(count);
+	request->mode = dev->mode;
+	request->chip_select = dev->chip_select;
+
+	gb_xfer = &request->transfers[0];
+	tx_data = gb_xfer + count;	/* place tx data after last gb_xfer */
+
+	/* Fill in the transfers array */
+	xfer = spi->first_xfer;
+	while (msg->state != GB_SPI_STATE_OP_DONE) {
+		if (xfer == spi->last_xfer)
+			xfer_len = spi->last_xfer_size;
+		else
+			xfer_len = xfer->len;
+
+		/* make sure we do not timeout in a slow transfer */
+		xfer_timeout = xfer_len * 8 * MSEC_PER_SEC / xfer->speed_hz;
+		xfer_timeout += GB_OPERATION_TIMEOUT_DEFAULT;
+
+		if (xfer_timeout > spi->op_timeout)
+			spi->op_timeout = xfer_timeout;
+
+		gb_xfer->speed_hz = cpu_to_le32(xfer->speed_hz);
+		gb_xfer->len = cpu_to_le32(xfer_len);
+		gb_xfer->delay_usecs = cpu_to_le16(xfer->delay_usecs);
+		gb_xfer->cs_change = xfer->cs_change;
+		gb_xfer->bits_per_word = xfer->bits_per_word;
+
+		/* Copy tx data */
+		if (xfer->tx_buf) {
+			gb_xfer->rdwr |= GB_SPI_XFER_WRITE;
+			memcpy(tx_data, xfer->tx_buf + spi->tx_xfer_offset,
+			       xfer_len);
+			tx_data += xfer_len;
+		}
+
+		if (xfer->rx_buf)
+			gb_xfer->rdwr |= GB_SPI_XFER_READ;
+
+		if (xfer == spi->last_xfer) {
+			msg->state = GB_SPI_STATE_OP_DONE;
+			continue;
+		}
+
+		gb_xfer++;
+		xfer = get_next_xfer(xfer, msg);
+	}
+
+	msg->actual_length += total_len;
+
+	return operation;
+}
+
+static void gb_spi_decode_response(struct gb_spilib *spi,
+				   struct spi_message *msg,
+				   struct gb_spi_transfer_response *response)
+{
+	struct spi_transfer *xfer = spi->first_xfer;
+	void *rx_data = response->data;
+	u32 xfer_len;
+
+	while (xfer) {
+		/* Copy rx data */
+		if (xfer->rx_buf) {
+			if (xfer == spi->first_xfer)
+				xfer_len = xfer->len - spi->rx_xfer_offset;
+			else if (xfer == spi->last_xfer)
+				xfer_len = spi->last_xfer_size;
+			else
+				xfer_len = xfer->len;
+
+			memcpy(xfer->rx_buf + spi->rx_xfer_offset, rx_data,
+			       xfer_len);
+			rx_data += xfer_len;
+		}
+
+		if (xfer == spi->last_xfer)
+			break;
+
+		xfer = list_next_entry(xfer, transfer_list);
+	}
+}
+
+static int gb_spi_transfer_one_message(struct spi_master *master,
+				       struct spi_message *msg)
+{
+	struct gb_spilib *spi = spi_master_get_devdata(master);
+	struct gb_connection *connection = spi->connection;
+	struct gb_spi_transfer_response *response;
+	struct gb_operation *operation;
+	int ret = 0;
+
+	spi->first_xfer = list_first_entry_or_null(&msg->transfers,
+						   struct spi_transfer,
+						   transfer_list);
+	if (!spi->first_xfer) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	msg->state = GB_SPI_STATE_MSG_IDLE;
+
+	while (msg->state != GB_SPI_STATE_MSG_DONE &&
+	       msg->state != GB_SPI_STATE_MSG_ERROR) {
+		operation = gb_spi_operation_create(spi, connection, msg);
+		if (!operation) {
+			msg->state = GB_SPI_STATE_MSG_ERROR;
+			ret = -EINVAL;
+			continue;
+		}
+
+		ret = gb_operation_request_send_sync_timeout(operation,
+							     spi->op_timeout);
+		if (!ret) {
+			response = operation->response->payload;
+			if (response)
+				gb_spi_decode_response(spi, msg, response);
+		} else {
+			dev_err(spi->parent,
+				"transfer operation failed: %d\n", ret);
+			msg->state = GB_SPI_STATE_MSG_ERROR;
+		}
+
+		gb_operation_put(operation);
+		setup_next_xfer(spi, msg);
+	}
+
+out:
+	msg->status = ret;
+	clean_xfer_state(spi);
+	spi_finalize_current_message(master);
+
+	return ret;
+}
+
+static int gb_spi_setup(struct spi_device *spi)
+{
+	/* Nothing to do for now */
+	return 0;
+}
+
+static void gb_spi_cleanup(struct spi_device *spi)
+{
+	/* Nothing to do for now */
+}
+
+
+/* Routines to get controller information */
+
+/*
+ * Map Greybus spi mode bits/flags/bpw into Linux ones.
+ * All bits are same for now and so these macro's return same values.
+ */
+#define gb_spi_mode_map(mode) mode
+#define gb_spi_flags_map(flags) flags
+
+static int gb_spi_get_master_config(struct gb_spilib *spi)
+{
+	struct gb_spi_master_config_response response;
+	u16 mode, flags;
+	int ret;
+
+	ret = gb_operation_sync(spi->connection, GB_SPI_TYPE_MASTER_CONFIG,
+				NULL, 0, &response, sizeof(response));
+	if (ret < 0)
+		return ret;
+
+	mode = le16_to_cpu(response.mode);
+	spi->mode = gb_spi_mode_map(mode);
+
+	flags = le16_to_cpu(response.flags);
+	spi->flags = gb_spi_flags_map(flags);
+
+	spi->bits_per_word_mask = le32_to_cpu(response.bits_per_word_mask);
+	spi->num_chipselect = response.num_chipselect;
+
+	spi->min_speed_hz = le32_to_cpu(response.min_speed_hz);
+	spi->max_speed_hz = le32_to_cpu(response.max_speed_hz);
+
+	return 0;
+}
+
+static int gb_spi_setup_device(struct gb_spilib *spi, u8 cs)
+{
+	struct spi_master *master = get_master_from_spi(spi);
+	struct gb_spi_device_config_request request;
+	struct gb_spi_device_config_response response;
+	struct spi_board_info spi_board = { {0} };
+	struct spi_device *spidev;
+	int ret;
+	u8 dev_type;
+
+	request.chip_select = cs;
+
+	ret = gb_operation_sync(spi->connection, GB_SPI_TYPE_DEVICE_CONFIG,
+				&request, sizeof(request),
+				&response, sizeof(response));
+	if (ret < 0)
+		return ret;
+
+	dev_type = response.device_type;
+
+	if (dev_type == GB_SPI_SPI_DEV)
+		strlcpy(spi_board.modalias, SPI_DEV_MODALIAS,
+			sizeof(spi_board.modalias));
+	else if (dev_type == GB_SPI_SPI_NOR)
+		strlcpy(spi_board.modalias, SPI_NOR_MODALIAS,
+			sizeof(spi_board.modalias));
+	else if (dev_type == GB_SPI_SPI_MODALIAS)
+		memcpy(spi_board.modalias, response.name,
+		       sizeof(spi_board.modalias));
+	else
+		return -EINVAL;
+
+	spi_board.mode		= le16_to_cpu(response.mode);
+	spi_board.bus_num	= master->bus_num;
+	spi_board.chip_select	= cs;
+	spi_board.max_speed_hz	= le32_to_cpu(response.max_speed_hz);
+
+	spidev = spi_new_device(master, &spi_board);
+	if (!spidev)
+		return -EINVAL;
+
+	return 0;
+}
+
+int gb_spilib_master_init(struct gb_connection *connection, struct device *dev)
+{
+	struct gb_spilib *spi;
+	struct spi_master *master;
+	int ret;
+	u8 i;
+
+	/* Allocate master with space for data */
+	master = spi_alloc_master(dev, sizeof(*spi));
+	if (!master) {
+		dev_err(dev, "cannot alloc SPI master\n");
+		return -ENOMEM;
+	}
+
+	spi = spi_master_get_devdata(master);
+	spi->connection = connection;
+	gb_connection_set_data(connection, master);
+	spi->parent = dev;
+
+	/* get master configuration */
+	ret = gb_spi_get_master_config(spi);
+	if (ret)
+		goto exit_spi_put;
+
+	master->bus_num = -1; /* Allow spi-core to allocate it dynamically */
+	master->num_chipselect = spi->num_chipselect;
+	master->mode_bits = spi->mode;
+	master->flags = spi->flags;
+	master->bits_per_word_mask = spi->bits_per_word_mask;
+
+	/* Attach methods */
+	master->cleanup = gb_spi_cleanup;
+	master->setup = gb_spi_setup;
+	master->transfer_one_message = gb_spi_transfer_one_message;
+
+	ret = spi_register_master(master);
+	if (ret < 0)
+		goto exit_spi_put;
+
+	/* now, fetch the devices configuration */
+	for (i = 0; i < spi->num_chipselect; i++) {
+		ret = gb_spi_setup_device(spi, i);
+		if (ret < 0) {
+			dev_err(dev, "failed to allocate spi device %d: %d\n",
+				i, ret);
+			goto exit_spi_unregister;
+		}
+	}
+
+	return 0;
+
+exit_spi_unregister:
+	spi_unregister_master(master);
+exit_spi_put:
+	spi_master_put(master);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(gb_spilib_master_init);
+
+void gb_spilib_master_exit(struct gb_connection *connection)
+{
+	struct spi_master *master = gb_connection_get_data(connection);
+
+	spi_unregister_master(master);
+	spi_master_put(master);
+}
+EXPORT_SYMBOL_GPL(gb_spilib_master_exit);
+
+static int gb_spi_probe(struct gpbridge_device *gpbdev,
+			const struct gpbridge_device_id *id)
+{
+	struct gb_connection *connection;
+	int ret;
+
+	connection = gb_connection_create(gpbdev->bundle,
+					  le16_to_cpu(gpbdev->cport_desc->id),
+					  NULL);
+	if (IS_ERR(connection))
+		return PTR_ERR(connection);
+
+	ret = gb_connection_enable(connection);
+	if (ret)
+		goto exit_connection_destroy;
+
+	ret = gb_gpbridge_get_version(connection);
+	if (ret)
+		goto exit_connection_disable;
+
+	ret = gb_spilib_master_init(connection, &gpbdev->dev);
+	if (ret)
+		goto exit_connection_disable;
+
+	gb_gpbridge_set_data(gpbdev, connection);
+
+	return 0;
+
+exit_connection_disable:
+	gb_connection_disable(connection);
+exit_connection_destroy:
+	gb_connection_destroy(connection);
+
+	return ret;
+}
+
+static void gb_spi_remove(struct gpbridge_device *gpbdev)
+{
+	struct gb_connection *connection = gb_gpbridge_get_data(gpbdev);
+
+	gb_spilib_master_exit(connection);
+	gb_connection_disable(connection);
+	gb_connection_destroy(connection);
+}
+
+static const struct gpbridge_device_id gb_spi_id_table[] = {
+	{ GPBRIDGE_PROTOCOL(GREYBUS_PROTOCOL_SPI) },
+	{ },
+};
+MODULE_DEVICE_TABLE(gpbridge, gb_spi_id_table);
+
+static struct gpbridge_driver spi_driver = {
+	.name		= "spi",
+	.probe		= gb_spi_probe,
+	.remove		= gb_spi_remove,
+	.id_table	= gb_spi_id_table,
+};
+
+module_gpbridge_driver(spi_driver);
+MODULE_LICENSE("GPL v2");
