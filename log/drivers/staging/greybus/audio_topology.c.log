commit a0e0c9208f1283f46a55a5a5d577b98387dbc9ba
Author: Bhanusree Pola <bhanusreemahesh@gmail.com>
Date:   Tue Feb 26 06:02:45 2019 +0530

    Staging: greybus: Blank lines not required before '}'
    
    Remove blank line to resolve checkpatch.pl issue:
    CHECK: Blank lines aren't necessary before a close brace '}'
    
    Signed-off-by: Bhanusree Pola <bhanusreemahesh@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/audio_topology.c b/drivers/staging/greybus/audio_topology.c
index 8bcbc3c4588c..4ac30accf226 100644
--- a/drivers/staging/greybus/audio_topology.c
+++ b/drivers/staging/greybus/audio_topology.c
@@ -923,7 +923,6 @@ static int gbaudio_tplg_create_wcontrol(struct gbaudio_module_info *gb,
 		break;
 	default:
 		return -EINVAL;
-
 	}
 
 	dev_dbg(gb->dev, "%s:%d DAPM control created, ret:%d\n", ctl->name,

commit 8478c35a858c75bf2b00917009ba1b46c1b9b7b4
Author: Cristian Sicilia <sicilia.cristian@gmail.com>
Date:   Sun Nov 25 17:58:15 2018 +0100

    staging: greybus: Parenthesis alignment
    
    Some parameters are aligned with parentheses.
    Some parentheses was opened at end of line.
    
    Signed-off-by: Cristian Sicilia <sicilia.cristian@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/audio_topology.c b/drivers/staging/greybus/audio_topology.c
index b71078339e86..8bcbc3c4588c 100644
--- a/drivers/staging/greybus/audio_topology.c
+++ b/drivers/staging/greybus/audio_topology.c
@@ -158,7 +158,7 @@ static const char **gb_generate_enum_strings(struct gbaudio_module_info *gb,
 }
 
 static int gbcodec_mixer_ctl_info(struct snd_kcontrol *kcontrol,
-		     struct snd_ctl_elem_info *uinfo)
+				  struct snd_ctl_elem_info *uinfo)
 {
 	unsigned int max;
 	const char *name;
@@ -209,7 +209,7 @@ static int gbcodec_mixer_ctl_info(struct snd_kcontrol *kcontrol,
 }
 
 static int gbcodec_mixer_ctl_get(struct snd_kcontrol *kcontrol,
-	struct snd_ctl_elem_value *ucontrol)
+				 struct snd_ctl_elem_value *ucontrol)
 {
 	int ret;
 	struct gb_audio_ctl_elem_info *info;
@@ -271,7 +271,7 @@ static int gbcodec_mixer_ctl_get(struct snd_kcontrol *kcontrol,
 }
 
 static int gbcodec_mixer_ctl_put(struct snd_kcontrol *kcontrol,
-			      struct snd_ctl_elem_value *ucontrol)
+				 struct snd_ctl_elem_value *ucontrol)
 {
 	int ret = 0;
 	struct gb_audio_ctl_elem_info *info;
@@ -347,7 +347,7 @@ static int gbcodec_mixer_ctl_put(struct snd_kcontrol *kcontrol,
  * of DAPM related sequencing, etc.
  */
 static int gbcodec_mixer_dapm_ctl_info(struct snd_kcontrol *kcontrol,
-		     struct snd_ctl_elem_info *uinfo)
+				       struct snd_ctl_elem_info *uinfo)
 {
 	int platform_max, platform_min;
 	struct gbaudio_ctl_pvt *data;
@@ -378,7 +378,7 @@ static int gbcodec_mixer_dapm_ctl_info(struct snd_kcontrol *kcontrol,
 }
 
 static int gbcodec_mixer_dapm_ctl_get(struct snd_kcontrol *kcontrol,
-	struct snd_ctl_elem_value *ucontrol)
+				      struct snd_ctl_elem_value *ucontrol)
 {
 	int ret;
 	struct gb_audio_ctl_elem_info *info;
@@ -427,7 +427,7 @@ static int gbcodec_mixer_dapm_ctl_get(struct snd_kcontrol *kcontrol,
 }
 
 static int gbcodec_mixer_dapm_ctl_put(struct snd_kcontrol *kcontrol,
-			      struct snd_ctl_elem_value *ucontrol)
+				      struct snd_ctl_elem_value *ucontrol)
 {
 	int ret, wi, max, connect;
 	unsigned int mask, val;
@@ -501,7 +501,7 @@ static int gbcodec_mixer_dapm_ctl_put(struct snd_kcontrol *kcontrol,
 	.private_value = (unsigned long)data}
 
 static int gbcodec_event_spk(struct snd_soc_dapm_widget *w,
-					struct snd_kcontrol *k, int event)
+			     struct snd_kcontrol *k, int event)
 {
 	/* Ensure GB speaker is connected */
 
@@ -509,7 +509,7 @@ static int gbcodec_event_spk(struct snd_soc_dapm_widget *w,
 }
 
 static int gbcodec_event_hp(struct snd_soc_dapm_widget *w,
-					struct snd_kcontrol *k, int event)
+			    struct snd_kcontrol *k, int event)
 {
 	/* Ensure GB module supports jack slot */
 
@@ -517,7 +517,7 @@ static int gbcodec_event_hp(struct snd_soc_dapm_widget *w,
 }
 
 static int gbcodec_event_int_mic(struct snd_soc_dapm_widget *w,
-					struct snd_kcontrol *k, int event)
+				 struct snd_kcontrol *k, int event)
 {
 	/* Ensure GB module supports jack slot */
 
@@ -664,7 +664,7 @@ static int gbaudio_tplg_create_enum_kctl(struct gbaudio_module_info *gb,
 
 	/* debug enum info */
 	dev_dbg(gb->dev, "Max:%d, name_length:%d\n", gbe->max,
-		 le16_to_cpu(gb_enum->names_length));
+		le16_to_cpu(gb_enum->names_length));
 	for (i = 0; i < gbe->max; i++)
 		dev_dbg(gb->dev, "src[%d]: %s\n", i, gbe->texts[i]);
 
@@ -873,7 +873,7 @@ static int gbaudio_tplg_create_enum_ctl(struct gbaudio_module_info *gb,
 
 	/* debug enum info */
 	dev_dbg(gb->dev, "Max:%d, name_length:%d\n", gbe->max,
-		 le16_to_cpu(gb_enum->names_length));
+		le16_to_cpu(gb_enum->names_length));
 	for (i = 0; i < gbe->max; i++)
 		dev_dbg(gb->dev, "src[%d]: %s\n", i, gbe->texts[i]);
 
@@ -884,8 +884,8 @@ static int gbaudio_tplg_create_enum_ctl(struct gbaudio_module_info *gb,
 }
 
 static int gbaudio_tplg_create_mixer_ctl(struct gbaudio_module_info *gb,
-					     struct snd_kcontrol_new *kctl,
-					     struct gb_audio_control *ctl)
+					 struct snd_kcontrol_new *kctl,
+					 struct gb_audio_control *ctl)
 {
 	struct gbaudio_ctl_pvt *ctldata;
 
@@ -905,8 +905,8 @@ static int gbaudio_tplg_create_mixer_ctl(struct gbaudio_module_info *gb,
 }
 
 static int gbaudio_tplg_create_wcontrol(struct gbaudio_module_info *gb,
-					     struct snd_kcontrol_new *kctl,
-					     struct gb_audio_control *ctl)
+					struct snd_kcontrol_new *kctl,
+					struct gb_audio_control *ctl)
 {
 	int ret;
 
@@ -1086,9 +1086,10 @@ static int gbaudio_tplg_create_widget(struct gbaudio_module_info *module,
 	case snd_soc_dapm_switch:
 		*dw = (struct snd_soc_dapm_widget)
 			SND_SOC_DAPM_SWITCH_E(w->name, SND_SOC_NOPM, 0, 0,
-					    widget_kctls, gbaudio_widget_event,
-					    SND_SOC_DAPM_PRE_PMU |
-					    SND_SOC_DAPM_POST_PMD);
+					      widget_kctls,
+					      gbaudio_widget_event,
+					      SND_SOC_DAPM_PRE_PMU |
+					      SND_SOC_DAPM_POST_PMD);
 		break;
 	case snd_soc_dapm_pga:
 		*dw = (struct snd_soc_dapm_widget)
@@ -1100,16 +1101,16 @@ static int gbaudio_tplg_create_widget(struct gbaudio_module_info *module,
 	case snd_soc_dapm_mixer:
 		*dw = (struct snd_soc_dapm_widget)
 			SND_SOC_DAPM_MIXER_E(w->name, SND_SOC_NOPM, 0, 0, NULL,
-					   0, gbaudio_widget_event,
-					   SND_SOC_DAPM_PRE_PMU |
-					   SND_SOC_DAPM_POST_PMD);
+					     0, gbaudio_widget_event,
+					     SND_SOC_DAPM_PRE_PMU |
+					     SND_SOC_DAPM_POST_PMD);
 		break;
 	case snd_soc_dapm_mux:
 		*dw = (struct snd_soc_dapm_widget)
 			SND_SOC_DAPM_MUX_E(w->name, SND_SOC_NOPM, 0, 0,
-					 widget_kctls, gbaudio_widget_event,
-					 SND_SOC_DAPM_PRE_PMU |
-					 SND_SOC_DAPM_POST_PMD);
+					   widget_kctls, gbaudio_widget_event,
+					   SND_SOC_DAPM_PRE_PMU |
+					   SND_SOC_DAPM_POST_PMD);
 		break;
 	case snd_soc_dapm_aif_in:
 		*dw = (struct snd_soc_dapm_widget)
@@ -1145,7 +1146,7 @@ static int gbaudio_tplg_create_widget(struct gbaudio_module_info *module,
 }
 
 static int gbaudio_tplg_process_kcontrols(struct gbaudio_module_info *module,
-				   struct gb_audio_control *controls)
+					  struct gb_audio_control *controls)
 {
 	int i, csize, ret;
 	struct snd_kcontrol_new *dapm_kctls;
@@ -1215,7 +1216,7 @@ static int gbaudio_tplg_process_kcontrols(struct gbaudio_module_info *module,
 }
 
 static int gbaudio_tplg_process_widgets(struct gbaudio_module_info *module,
-				   struct gb_audio_widget *widgets)
+					struct gb_audio_widget *widgets)
 {
 	int i, ret, w_size;
 	struct snd_soc_dapm_widget *dapm_widgets;
@@ -1264,7 +1265,7 @@ static int gbaudio_tplg_process_widgets(struct gbaudio_module_info *module,
 }
 
 static int gbaudio_tplg_process_routes(struct gbaudio_module_info *module,
-				   struct gb_audio_route *routes)
+				       struct gb_audio_route *routes)
 {
 	int i, ret;
 	struct snd_soc_dapm_route *dapm_routes;
@@ -1300,8 +1301,8 @@ static int gbaudio_tplg_process_routes(struct gbaudio_module_info *module,
 		}
 		dapm_routes->control =
 			gbaudio_map_controlid(module,
-						      curr->control_id,
-						      curr->index);
+					      curr->control_id,
+					      curr->index);
 		if ((curr->control_id !=  GBAUDIO_INVALID_ID) &&
 		    !dapm_routes->control) {
 			dev_err(module->dev, "%d:%d:%d:%d - Invalid control\n",
@@ -1325,7 +1326,7 @@ static int gbaudio_tplg_process_routes(struct gbaudio_module_info *module,
 }
 
 static int gbaudio_tplg_process_header(struct gbaudio_module_info *module,
-				 struct gb_audio_topology *tplg_data)
+				       struct gb_audio_topology *tplg_data)
 {
 	/* fetch no. of kcontrols, widgets & routes */
 	module->num_controls = tplg_data->num_controls;
@@ -1351,7 +1352,7 @@ static int gbaudio_tplg_process_header(struct gbaudio_module_info *module,
 }
 
 int gbaudio_tplg_parse_data(struct gbaudio_module_info *module,
-			       struct gb_audio_topology *tplg_data)
+			    struct gb_audio_topology *tplg_data)
 {
 	int ret;
 	struct gb_audio_control *controls;

commit a86854d0c599b3202307abceb68feee4d7061578
Author: Kees Cook <keescook@chromium.org>
Date:   Tue Jun 12 14:07:58 2018 -0700

    treewide: devm_kzalloc() -> devm_kcalloc()
    
    The devm_kzalloc() function has a 2-factor argument form, devm_kcalloc().
    This patch replaces cases of:
    
            devm_kzalloc(handle, a * b, gfp)
    
    with:
            devm_kcalloc(handle, a * b, gfp)
    
    as well as handling cases of:
    
            devm_kzalloc(handle, a * b * c, gfp)
    
    with:
    
            devm_kzalloc(handle, array3_size(a, b, c), gfp)
    
    as it's slightly less ugly than:
    
            devm_kcalloc(handle, array_size(a, b), c, gfp)
    
    This does, however, attempt to ignore constant size factors like:
    
            devm_kzalloc(handle, 4 * 1024, gfp)
    
    though any constants defined via macros get caught up in the conversion.
    
    Any factors with a sizeof() of "unsigned char", "char", and "u8" were
    dropped, since they're redundant.
    
    Some manual whitespace fixes were needed in this patch, as Coccinelle
    really liked to write "=devm_kcalloc..." instead of "= devm_kcalloc...".
    
    The Coccinelle script used for this was:
    
    // Fix redundant parens around sizeof().
    @@
    expression HANDLE;
    type TYPE;
    expression THING, E;
    @@
    
    (
      devm_kzalloc(HANDLE,
    -       (sizeof(TYPE)) * E
    +       sizeof(TYPE) * E
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       (sizeof(THING)) * E
    +       sizeof(THING) * E
      , ...)
    )
    
    // Drop single-byte sizes and redundant parens.
    @@
    expression HANDLE;
    expression COUNT;
    typedef u8;
    typedef __u8;
    @@
    
    (
      devm_kzalloc(HANDLE,
    -       sizeof(u8) * (COUNT)
    +       COUNT
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(__u8) * (COUNT)
    +       COUNT
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(char) * (COUNT)
    +       COUNT
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(unsigned char) * (COUNT)
    +       COUNT
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(u8) * COUNT
    +       COUNT
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(__u8) * COUNT
    +       COUNT
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(char) * COUNT
    +       COUNT
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(unsigned char) * COUNT
    +       COUNT
      , ...)
    )
    
    // 2-factor product with sizeof(type/expression) and identifier or constant.
    @@
    expression HANDLE;
    type TYPE;
    expression THING;
    identifier COUNT_ID;
    constant COUNT_CONST;
    @@
    
    (
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(TYPE) * (COUNT_ID)
    +       COUNT_ID, sizeof(TYPE)
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(TYPE) * COUNT_ID
    +       COUNT_ID, sizeof(TYPE)
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(TYPE) * (COUNT_CONST)
    +       COUNT_CONST, sizeof(TYPE)
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(TYPE) * COUNT_CONST
    +       COUNT_CONST, sizeof(TYPE)
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(THING) * (COUNT_ID)
    +       COUNT_ID, sizeof(THING)
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(THING) * COUNT_ID
    +       COUNT_ID, sizeof(THING)
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(THING) * (COUNT_CONST)
    +       COUNT_CONST, sizeof(THING)
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(THING) * COUNT_CONST
    +       COUNT_CONST, sizeof(THING)
      , ...)
    )
    
    // 2-factor product, only identifiers.
    @@
    expression HANDLE;
    identifier SIZE, COUNT;
    @@
    
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       SIZE * COUNT
    +       COUNT, SIZE
      , ...)
    
    // 3-factor product with 1 sizeof(type) or sizeof(expression), with
    // redundant parens removed.
    @@
    expression HANDLE;
    expression THING;
    identifier STRIDE, COUNT;
    type TYPE;
    @@
    
    (
      devm_kzalloc(HANDLE,
    -       sizeof(TYPE) * (COUNT) * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(TYPE) * (COUNT) * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(TYPE) * COUNT * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(TYPE) * COUNT * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(THING) * (COUNT) * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(THING) * (COUNT) * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(THING) * COUNT * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(THING) * COUNT * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    )
    
    // 3-factor product with 2 sizeof(variable), with redundant parens removed.
    @@
    expression HANDLE;
    expression THING1, THING2;
    identifier COUNT;
    type TYPE1, TYPE2;
    @@
    
    (
      devm_kzalloc(HANDLE,
    -       sizeof(TYPE1) * sizeof(TYPE2) * COUNT
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(TYPE2))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(TYPE1) * sizeof(THING2) * (COUNT)
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(TYPE2))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(THING1) * sizeof(THING2) * COUNT
    +       array3_size(COUNT, sizeof(THING1), sizeof(THING2))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(THING1) * sizeof(THING2) * (COUNT)
    +       array3_size(COUNT, sizeof(THING1), sizeof(THING2))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(TYPE1) * sizeof(THING2) * COUNT
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(THING2))
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       sizeof(TYPE1) * sizeof(THING2) * (COUNT)
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(THING2))
      , ...)
    )
    
    // 3-factor product, only identifiers, with redundant parens removed.
    @@
    expression HANDLE;
    identifier STRIDE, SIZE, COUNT;
    @@
    
    (
      devm_kzalloc(HANDLE,
    -       (COUNT) * STRIDE * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       COUNT * (STRIDE) * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       COUNT * STRIDE * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       (COUNT) * (STRIDE) * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       COUNT * (STRIDE) * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       (COUNT) * STRIDE * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       (COUNT) * (STRIDE) * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       COUNT * STRIDE * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    )
    
    // Any remaining multi-factor products, first at least 3-factor products,
    // when they're not all constants...
    @@
    expression HANDLE;
    expression E1, E2, E3;
    constant C1, C2, C3;
    @@
    
    (
      devm_kzalloc(HANDLE, C1 * C2 * C3, ...)
    |
      devm_kzalloc(HANDLE,
    -       (E1) * E2 * E3
    +       array3_size(E1, E2, E3)
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       (E1) * (E2) * E3
    +       array3_size(E1, E2, E3)
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       (E1) * (E2) * (E3)
    +       array3_size(E1, E2, E3)
      , ...)
    |
      devm_kzalloc(HANDLE,
    -       E1 * E2 * E3
    +       array3_size(E1, E2, E3)
      , ...)
    )
    
    // And then all remaining 2 factors products when they're not all constants,
    // keeping sizeof() as the second factor argument.
    @@
    expression HANDLE;
    expression THING, E1, E2;
    type TYPE;
    constant C1, C2, C3;
    @@
    
    (
      devm_kzalloc(HANDLE, sizeof(THING) * C2, ...)
    |
      devm_kzalloc(HANDLE, sizeof(TYPE) * C2, ...)
    |
      devm_kzalloc(HANDLE, C1 * C2 * C3, ...)
    |
      devm_kzalloc(HANDLE, C1 * C2, ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(TYPE) * (E2)
    +       E2, sizeof(TYPE)
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(TYPE) * E2
    +       E2, sizeof(TYPE)
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(THING) * (E2)
    +       E2, sizeof(THING)
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       sizeof(THING) * E2
    +       E2, sizeof(THING)
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       (E1) * E2
    +       E1, E2
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       (E1) * (E2)
    +       E1, E2
      , ...)
    |
    - devm_kzalloc
    + devm_kcalloc
      (HANDLE,
    -       E1 * E2
    +       E1, E2
      , ...)
    )
    
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/drivers/staging/greybus/audio_topology.c b/drivers/staging/greybus/audio_topology.c
index 15e57f701630..b71078339e86 100644
--- a/drivers/staging/greybus/audio_topology.c
+++ b/drivers/staging/greybus/audio_topology.c
@@ -144,7 +144,7 @@ static const char **gb_generate_enum_strings(struct gbaudio_module_info *gb,
 	__u8 *data;
 
 	items = le32_to_cpu(gbenum->items);
-	strings = devm_kzalloc(gb->dev, sizeof(char *) * items, GFP_KERNEL);
+	strings = devm_kcalloc(gb->dev, items, sizeof(char *), GFP_KERNEL);
 	data = gbenum->names;
 
 	for (i = 0; i < items; i++) {

commit ac5d6d869c053e0b9c6d375742fc0135358297aa
Author: Colin Ian King <colin.king@canonical.com>
Date:   Tue May 22 09:33:42 2018 +0100

    staging: greybus: fix spelling mistake: "Inavlid" -> "Invalid"
    
    Trivial fix to spelling mistake in dev_err error message
    
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Acked-by: Vaibhav Agarwal <vaibhav.sr@gmail.com>
    Acked-by: Mark Greer <mgreer@animalcreek.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/audio_topology.c b/drivers/staging/greybus/audio_topology.c
index de4b1b2b12f3..15e57f701630 100644
--- a/drivers/staging/greybus/audio_topology.c
+++ b/drivers/staging/greybus/audio_topology.c
@@ -996,7 +996,7 @@ static int gbaudio_tplg_create_widget(struct gbaudio_module_info *module,
 
 	ret = gbaudio_validate_kcontrol_count(w);
 	if (ret) {
-		dev_err(module->dev, "Inavlid kcontrol count=%d for %s\n",
+		dev_err(module->dev, "Invalid kcontrol count=%d for %s\n",
 			w->ncontrols, w->name);
 		return ret;
 	}

commit 863dbc52e7f0e5acd7b4883f3933543a81c474c7
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Nov 7 14:58:42 2017 +0100

    staging: greybus: Remove redundant license text
    
    Now that the SPDX tag is in all greybus files, that identifies the
    license in a specific and legally-defined manner.  So the extra GPL text
    wording can be removed as it is no longer needed at all.
    
    This is done on a quest to remove the 700+ different ways that files in
    the kernel describe the GPL license text.  And there's unneeded stuff
    like the address (sometimes incorrect) for the FSF which is never
    needed.
    
    No copyright headers or other non-license-description text was removed.
    
    Cc: Vaibhav Hiremath <hvaibhav.linux@gmail.com>
    Reviewed-by: Alex Elder <elder@linaro.org>
    Acked-by: Vaibhav Agarwal <vaibhav.sr@gmail.com>
    Acked-by: David Lin <dtwlin@gmail.com>
    Acked-by: Johan Hovold <johan@kernel.org>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Acked-by: Mark Greer <mgreer@animalcreek.com>
    Acked-by: Rui Miguel Silva <rmfrfs@gmail.com>
    Acked-by: "Bryan O'Donoghue" <pure.logic@nexus-software.ie>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/audio_topology.c b/drivers/staging/greybus/audio_topology.c
index 28fba9bccf29..de4b1b2b12f3 100644
--- a/drivers/staging/greybus/audio_topology.c
+++ b/drivers/staging/greybus/audio_topology.c
@@ -3,8 +3,6 @@
  * Greybus audio driver
  * Copyright 2015-2016 Google Inc.
  * Copyright 2015-2016 Linaro Ltd.
- *
- * Released under the GPLv2 only.
  */
 
 #include "audio_codec.h"

commit eb50fd3a22c770f36be275295b782f3ea52e3215
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Nov 7 14:58:41 2017 +0100

    staging: greybus: add SPDX identifiers to all greybus driver files
    
    It's good to have SPDX identifiers in all files to make it easier to
    audit the kernel tree for correct licenses.
    
    Update the drivers/staging/greybus files files with the correct SPDX
    license identifier based on the license text in the file itself.  The
    SPDX identifier is a legally binding shorthand, which can be used
    instead of the full boiler plate text.
    
    This work is based on a script and data from Thomas Gleixner, Philippe
    Ombredanne, and Kate Stewart.
    
    Cc: Vaibhav Hiremath <hvaibhav.linux@gmail.com>
    Cc: "Bryan O'Donoghue" <pure.logic@nexus-software.ie>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: Philippe Ombredanne <pombredanne@nexb.com>
    Acked-by: Vaibhav Agarwal <vaibhav.sr@gmail.com>
    Acked-by: David Lin <dtwlin@gmail.com>
    Reviewed-by: Alex Elder <elder@linaro.org>
    Acked-by: Johan Hovold <johan@kernel.org>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Acked-by: Mark Greer <mgreer@animalcreek.com>
    Acked-by: Rui Miguel Silva <rmfrfs@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/audio_topology.c b/drivers/staging/greybus/audio_topology.c
index 07fac3948f3a..28fba9bccf29 100644
--- a/drivers/staging/greybus/audio_topology.c
+++ b/drivers/staging/greybus/audio_topology.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * Greybus audio driver
  * Copyright 2015-2016 Google Inc.

commit 055fb9ce92d59da9e8d1040b54ecd9b6fff439d7
Author: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
Date:   Wed Jan 18 22:51:53 2017 +0530

    staging: greybus: audio: Ensure proper byte order
    
    Proper byte order was completely disregarded for multi byte data shared
    between AP and module (and APB1). Fix this.
    
    Signed-off-by: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
    Signed-off-by: Vaibhav Agarwal <vaibhav.sr@gmail.com>
    Acked-by: Mark Greer <mgreer@animalcreek.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/audio_topology.c b/drivers/staging/greybus/audio_topology.c
index ee2113eb899e..07fac3948f3a 100644
--- a/drivers/staging/greybus/audio_topology.c
+++ b/drivers/staging/greybus/audio_topology.c
@@ -141,13 +141,14 @@ static const char **gb_generate_enum_strings(struct gbaudio_module_info *gb,
 {
 	const char **strings;
 	int i;
+	unsigned int items;
 	__u8 *data;
 
-	strings = devm_kzalloc(gb->dev, sizeof(char *) * gbenum->items,
-			       GFP_KERNEL);
+	items = le32_to_cpu(gbenum->items);
+	strings = devm_kzalloc(gb->dev, sizeof(char *) * items, GFP_KERNEL);
 	data = gbenum->names;
 
-	for (i = 0; i < gbenum->items; i++) {
+	for (i = 0; i < items; i++) {
 		strings[i] = (const char *)data;
 		while (*data != '\0')
 			data++;
@@ -185,11 +186,11 @@ static int gbcodec_mixer_ctl_info(struct snd_kcontrol *kcontrol,
 	switch (info->type) {
 	case GB_AUDIO_CTL_ELEM_TYPE_BOOLEAN:
 	case GB_AUDIO_CTL_ELEM_TYPE_INTEGER:
-		uinfo->value.integer.min = info->value.integer.min;
-		uinfo->value.integer.max = info->value.integer.max;
+		uinfo->value.integer.min = le32_to_cpu(info->value.integer.min);
+		uinfo->value.integer.max = le32_to_cpu(info->value.integer.max);
 		break;
 	case GB_AUDIO_CTL_ELEM_TYPE_ENUMERATED:
-		max = info->value.enumerated.items;
+		max = le32_to_cpu(info->value.enumerated.items);
 		uinfo->value.enumerated.items = max;
 		if (uinfo->value.enumerated.item > max - 1)
 			uinfo->value.enumerated.item = max - 1;
@@ -249,17 +250,17 @@ static int gbcodec_mixer_ctl_get(struct snd_kcontrol *kcontrol,
 	case GB_AUDIO_CTL_ELEM_TYPE_BOOLEAN:
 	case GB_AUDIO_CTL_ELEM_TYPE_INTEGER:
 		ucontrol->value.integer.value[0] =
-			gbvalue.value.integer_value[0];
+			le32_to_cpu(gbvalue.value.integer_value[0]);
 		if (data->vcount == 2)
 			ucontrol->value.integer.value[1] =
-				gbvalue.value.integer_value[1];
+				le32_to_cpu(gbvalue.value.integer_value[1]);
 		break;
 	case GB_AUDIO_CTL_ELEM_TYPE_ENUMERATED:
 		ucontrol->value.enumerated.item[0] =
-			gbvalue.value.enumerated_item[0];
+			le32_to_cpu(gbvalue.value.enumerated_item[0]);
 		if (data->vcount == 2)
 			ucontrol->value.enumerated.item[1] =
-				gbvalue.value.enumerated_item[1];
+				le32_to_cpu(gbvalue.value.enumerated_item[1]);
 		break;
 	default:
 		dev_err(codec->dev, "Invalid type: %d for %s:kcontrol\n",
@@ -296,17 +297,17 @@ static int gbcodec_mixer_ctl_put(struct snd_kcontrol *kcontrol,
 	case GB_AUDIO_CTL_ELEM_TYPE_BOOLEAN:
 	case GB_AUDIO_CTL_ELEM_TYPE_INTEGER:
 		gbvalue.value.integer_value[0] =
-			ucontrol->value.integer.value[0];
+			cpu_to_le32(ucontrol->value.integer.value[0]);
 		if (data->vcount == 2)
 			gbvalue.value.integer_value[1] =
-				ucontrol->value.integer.value[1];
+				cpu_to_le32(ucontrol->value.integer.value[1]);
 		break;
 	case GB_AUDIO_CTL_ELEM_TYPE_ENUMERATED:
 		gbvalue.value.enumerated_item[0] =
-			ucontrol->value.enumerated.item[0];
+			cpu_to_le32(ucontrol->value.enumerated.item[0]);
 		if (data->vcount == 2)
 			gbvalue.value.enumerated_item[1] =
-				ucontrol->value.enumerated.item[1];
+				cpu_to_le32(ucontrol->value.enumerated.item[1]);
 		break;
 	default:
 		dev_err(codec->dev, "Invalid type: %d for %s:kcontrol\n",
@@ -361,8 +362,8 @@ static int gbcodec_mixer_dapm_ctl_info(struct snd_kcontrol *kcontrol,
 	info = (struct gb_audio_ctl_elem_info *)data->info;
 
 	/* update uinfo */
-	platform_max = info->value.integer.max;
-	platform_min = info->value.integer.min;
+	platform_max = le32_to_cpu(info->value.integer.max);
+	platform_min = le32_to_cpu(info->value.integer.min);
 
 	if (platform_max == 1 &&
 	    !strnstr(kcontrol->id.name, " Volume", NAME_SIZE))
@@ -420,7 +421,8 @@ static int gbcodec_mixer_dapm_ctl_get(struct snd_kcontrol *kcontrol,
 		return ret;
 	}
 	/* update ucontrol */
-	ucontrol->value.integer.value[0] = gbvalue.value.integer_value[0];
+	ucontrol->value.integer.value[0] =
+		le32_to_cpu(gbvalue.value.integer_value[0]);
 
 	return ret;
 }
@@ -454,7 +456,7 @@ static int gbcodec_mixer_dapm_ctl_put(struct snd_kcontrol *kcontrol,
 			 "GB: Control '%s' is stereo, which is not supported\n",
 			 kcontrol->id.name);
 
-	max = info->value.integer.max;
+	max = le32_to_cpu(info->value.integer.max);
 	mask = (1 << fls(max)) - 1;
 	val = ucontrol->value.integer.value[0] & mask;
 	connect = !!val;
@@ -470,7 +472,7 @@ static int gbcodec_mixer_dapm_ctl_put(struct snd_kcontrol *kcontrol,
 							connect);
 		}
 		gbvalue.value.integer_value[0] =
-			ucontrol->value.integer.value[0];
+			cpu_to_le32(ucontrol->value.integer.value[0]);
 
 		ret = gb_pm_runtime_get_sync(bundle);
 		if (ret)
@@ -584,10 +586,11 @@ static int gbcodec_enum_ctl_get(struct snd_kcontrol *kcontrol,
 		return ret;
 	}
 
-	ucontrol->value.enumerated.item[0] = gbvalue.value.enumerated_item[0];
+	ucontrol->value.enumerated.item[0] =
+		le32_to_cpu(gbvalue.value.enumerated_item[0]);
 	if (e->shift_l != e->shift_r)
 		ucontrol->value.enumerated.item[1] =
-			gbvalue.value.enumerated_item[1];
+			le32_to_cpu(gbvalue.value.enumerated_item[1]);
 
 	return 0;
 }
@@ -613,13 +616,14 @@ static int gbcodec_enum_ctl_put(struct snd_kcontrol *kcontrol,
 
 	if (ucontrol->value.enumerated.item[0] > e->max - 1)
 		return -EINVAL;
-	gbvalue.value.enumerated_item[0] = ucontrol->value.enumerated.item[0];
+	gbvalue.value.enumerated_item[0] =
+		cpu_to_le32(ucontrol->value.enumerated.item[0]);
 
 	if (e->shift_l != e->shift_r) {
 		if (ucontrol->value.enumerated.item[1] > e->max - 1)
 			return -EINVAL;
 		gbvalue.value.enumerated_item[1] =
-			ucontrol->value.enumerated.item[1];
+			cpu_to_le32(ucontrol->value.enumerated.item[1]);
 	}
 
 	bundle = to_gb_bundle(module->dev);
@@ -656,13 +660,13 @@ static int gbaudio_tplg_create_enum_kctl(struct gbaudio_module_info *gb,
 	gb_enum = &ctl->info.value.enumerated;
 
 	/* since count=1, and reg is dummy */
-	gbe->max = gb_enum->items;
+	gbe->max = le32_to_cpu(gb_enum->items);
 	gbe->texts = gb_generate_enum_strings(gb, gb_enum);
 
 	/* debug enum info */
-	dev_dbg(gb->dev, "Max:%d, name_length:%d\n", gb_enum->items,
-		 gb_enum->names_length);
-	for (i = 0; i < gb_enum->items; i++)
+	dev_dbg(gb->dev, "Max:%d, name_length:%d\n", gbe->max,
+		 le16_to_cpu(gb_enum->names_length));
+	for (i = 0; i < gbe->max; i++)
 		dev_dbg(gb->dev, "src[%d]: %s\n", i, gbe->texts[i]);
 
 	*kctl = (struct snd_kcontrol_new)
@@ -691,7 +695,7 @@ static int gbaudio_tplg_create_kcontrol(struct gbaudio_module_info *gb,
 			if (!ctldata)
 				return -ENOMEM;
 			ctldata->ctl_id = ctl->id;
-			ctldata->data_cport = ctl->data_cport;
+			ctldata->data_cport = le16_to_cpu(ctl->data_cport);
 			ctldata->access = ctl->access;
 			ctldata->vcount = ctl->count_values;
 			ctldata->info = &ctl->info;
@@ -865,13 +869,13 @@ static int gbaudio_tplg_create_enum_ctl(struct gbaudio_module_info *gb,
 	gb_enum = &ctl->info.value.enumerated;
 
 	/* since count=1, and reg is dummy */
-	gbe->max = gb_enum->items;
+	gbe->max = le32_to_cpu(gb_enum->items);
 	gbe->texts = gb_generate_enum_strings(gb, gb_enum);
 
 	/* debug enum info */
-	dev_dbg(gb->dev, "Max:%d, name_length:%d\n", gb_enum->items,
-		 gb_enum->names_length);
-	for (i = 0; i < gb_enum->items; i++)
+	dev_dbg(gb->dev, "Max:%d, name_length:%d\n", gbe->max,
+		 le16_to_cpu(gb_enum->names_length));
+	for (i = 0; i < gbe->max; i++)
 		dev_dbg(gb->dev, "src[%d]: %s\n", i, gbe->texts[i]);
 
 	*kctl = (struct snd_kcontrol_new)
@@ -891,7 +895,7 @@ static int gbaudio_tplg_create_mixer_ctl(struct gbaudio_module_info *gb,
 	if (!ctldata)
 		return -ENOMEM;
 	ctldata->ctl_id = ctl->id;
-	ctldata->data_cport = ctl->data_cport;
+	ctldata->data_cport = le16_to_cpu(ctl->data_cport);
 	ctldata->access = ctl->access;
 	ctldata->vcount = ctl->count_values;
 	ctldata->info = &ctl->info;
@@ -1037,10 +1041,10 @@ static int gbaudio_tplg_create_widget(struct gbaudio_module_info *module,
 			csize = offsetof(struct gb_audio_control, info);
 			csize += offsetof(struct gb_audio_ctl_elem_info, value);
 			csize += offsetof(struct gb_audio_enumerated, names);
-			csize += gbenum->names_length;
+			csize += le16_to_cpu(gbenum->names_length);
 			control->texts = (const char * const *)
 				gb_generate_enum_strings(module, gbenum);
-			control->items = gbenum->items;
+			control->items = le32_to_cpu(gbenum->items);
 		} else {
 			csize = sizeof(struct gb_audio_control);
 		}
@@ -1185,10 +1189,10 @@ static int gbaudio_tplg_process_kcontrols(struct gbaudio_module_info *module,
 			csize = offsetof(struct gb_audio_control, info);
 			csize += offsetof(struct gb_audio_ctl_elem_info, value);
 			csize += offsetof(struct gb_audio_enumerated, names);
-			csize += gbenum->names_length;
+			csize += le16_to_cpu(gbenum->names_length);
 			control->texts = (const char * const *)
 				gb_generate_enum_strings(module, gbenum);
-			control->items = gbenum->items;
+			control->items = le32_to_cpu(gbenum->items);
 		} else {
 			csize = sizeof(struct gb_audio_control);
 		}
@@ -1331,11 +1335,12 @@ static int gbaudio_tplg_process_header(struct gbaudio_module_info *module,
 
 	/* update block offset */
 	module->dai_offset = (unsigned long)&tplg_data->data;
-	module->control_offset = module->dai_offset + tplg_data->size_dais;
+	module->control_offset = module->dai_offset +
+					le32_to_cpu(tplg_data->size_dais);
 	module->widget_offset = module->control_offset +
-		tplg_data->size_controls;
+					le32_to_cpu(tplg_data->size_controls);
 	module->route_offset = module->widget_offset +
-		tplg_data->size_widgets;
+					le32_to_cpu(tplg_data->size_widgets);
 
 	dev_dbg(module->dev, "DAI offset is 0x%lx\n", module->dai_offset);
 	dev_dbg(module->dev, "control offset is %lx\n",
@@ -1353,6 +1358,7 @@ int gbaudio_tplg_parse_data(struct gbaudio_module_info *module,
 	struct gb_audio_control *controls;
 	struct gb_audio_widget *widgets;
 	struct gb_audio_route *routes;
+	unsigned int jack_type;
 
 	if (!tplg_data)
 		return -EINVAL;
@@ -1395,10 +1401,10 @@ int gbaudio_tplg_parse_data(struct gbaudio_module_info *module,
 	dev_dbg(module->dev, "Route parsing finished\n");
 
 	/* parse jack capabilities */
-	if (tplg_data->jack_type) {
-		module->jack_mask = tplg_data->jack_type & GBCODEC_JACK_MASK;
-		module->button_mask = tplg_data->jack_type &
-			GBCODEC_JACK_BUTTON_MASK;
+	jack_type = le32_to_cpu(tplg_data->jack_type);
+	if (jack_type) {
+		module->jack_mask = jack_type & GBCODEC_JACK_MASK;
+		module->button_mask = jack_type & GBCODEC_JACK_BUTTON_MASK;
 	}
 
 	return ret;

commit 84510052d658221282e6860f2ed1c347fd51add3
Author: Vaibhav Agarwal <vaibhav.sr@gmail.com>
Date:   Wed Jan 18 22:51:50 2017 +0530

    staging: greybus: audio: Avoid less than zero check for le32 variable
    
    mixer control->info call back function checks for -ve values to rebase
    min and max values. However, le32 variable is used to fetch values from
    GB module FW. Thus negative value checking is not required. Fix this!!
    
    Signed-off-by: Vaibhav Agarwal <vaibhav.sr@gmail.com>
    Acked-by: Mark Greer <mgreer@animalcreek.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/audio_topology.c b/drivers/staging/greybus/audio_topology.c
index 3001a4971c06..ee2113eb899e 100644
--- a/drivers/staging/greybus/audio_topology.c
+++ b/drivers/staging/greybus/audio_topology.c
@@ -371,12 +371,8 @@ static int gbcodec_mixer_dapm_ctl_info(struct snd_kcontrol *kcontrol,
 		uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
 
 	uinfo->count = data->vcount;
-	uinfo->value.integer.min = 0;
-	if (info->value.integer.min < 0 &&
-	    (uinfo->type == SNDRV_CTL_ELEM_TYPE_INTEGER))
-		uinfo->value.integer.max = platform_max - platform_min;
-	else
-		uinfo->value.integer.max = platform_max;
+	uinfo->value.integer.min = platform_min;
+	uinfo->value.integer.max = platform_max;
 
 	return 0;
 }

commit 8a983614ca956fbf6329be22214de2c1fc47ea1e
Author: Emmanuil Chatzipetru <chatzi.emanuel@gmail.com>
Date:   Wed Jan 4 17:08:18 2017 +0100

    staging: greybus: audio_topology: Fix spaces between operator and string
    
    Fix coding style issue caught by checkpatch.pl related to the following
    warning:
            - "CHECK: spaces preferred around that '*' (ctx:VxV) "
    
    Signed-off-by: Emmanuil Chatzipetru <chatzi.emanuel@gmail.com>
    Acked-by: Johan Hovold <johan@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/audio_topology.c b/drivers/staging/greybus/audio_topology.c
index 8b216ca99cf9..3001a4971c06 100644
--- a/drivers/staging/greybus/audio_topology.c
+++ b/drivers/staging/greybus/audio_topology.c
@@ -1312,7 +1312,7 @@ static int gbaudio_tplg_process_routes(struct gbaudio_module_info *module,
 			goto error;
 		}
 		dev_dbg(module->dev, "Route {%s, %s, %s}\n", dapm_routes->sink,
-			(dapm_routes->control) ? dapm_routes->control:"NULL",
+			(dapm_routes->control) ? dapm_routes->control : "NULL",
 			dapm_routes->source);
 		dapm_routes++;
 		curr++;

commit 02ae32f754a6cb006a7dc5305bf6e5ade1a95095
Author: Chase Metzger <chasemetzger15@gmail.com>
Date:   Thu Oct 6 19:38:41 2016 -0700

    drivers: staging: greybus: Fixed CHECKS for brace issues
    
    Added braces to else statements where checkpatch complained.
    
    Signed-off-by: Chase Metzger <chasemetzger15@gmail.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Reviewed-by: Vaibhav Agarwal <vaibhav.sr@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/audio_topology.c b/drivers/staging/greybus/audio_topology.c
index 5c76067a55f7..8b216ca99cf9 100644
--- a/drivers/staging/greybus/audio_topology.c
+++ b/drivers/staging/greybus/audio_topology.c
@@ -1045,8 +1045,10 @@ static int gbaudio_tplg_create_widget(struct gbaudio_module_info *module,
 			control->texts = (const char * const *)
 				gb_generate_enum_strings(module, gbenum);
 			control->items = gbenum->items;
-		} else
+		} else {
 			csize = sizeof(struct gb_audio_control);
+		}
+
 		*w_size += csize;
 		curr = (void *)curr + csize;
 		list_add(&control->list, &module->widget_ctl_list);
@@ -1191,8 +1193,9 @@ static int gbaudio_tplg_process_kcontrols(struct gbaudio_module_info *module,
 			control->texts = (const char * const *)
 				gb_generate_enum_strings(module, gbenum);
 			control->items = gbenum->items;
-		} else
+		} else {
 			csize = sizeof(struct gb_audio_control);
+		}
 
 		list_add(&control->list, &module->ctl_list);
 		dev_dbg(module->dev, "%d:%s created of type %d\n", curr->id,

commit a2a87b224b33f30ca5172945c132e39260e95403
Author: Elizabeth Ferdman <gnudevliz@gmail.com>
Date:   Tue Oct 4 13:06:10 2016 -0700

    staging: greybus: Add blank line after declaration
    
    Add a blank line after a declaration. Error found by checkpatch.
    
    Signed-off-by: Elizabeth Ferdman <gnudevliz@gmail.com>
    Reviewed-by: Vaibhav Agarwal <vaibhav.sr@gmail.com>
    Reviewed-by: Mark Greer <mgreer@animalcreek.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/audio_topology.c b/drivers/staging/greybus/audio_topology.c
index b6251691a33d..5c76067a55f7 100644
--- a/drivers/staging/greybus/audio_topology.c
+++ b/drivers/staging/greybus/audio_topology.c
@@ -114,6 +114,7 @@ static int gbaudio_map_widgetname(struct gbaudio_module_info *module,
 				  const char *name)
 {
 	struct gbaudio_widget *widget;
+
 	list_for_each_entry(widget, &module->widget_list, list) {
 		if (!strncmp(widget->name, name, NAME_SIZE))
 			return widget->id;

commit 7224a2a50a29871b2ae04cac731ea199adedbe68
Author: Vaibhav Agarwal <vaibhav.sr@gmail.com>
Date:   Sat Sep 24 23:06:26 2016 +0530

    greybus: audio: fix uninitialized variable errors found by cppcheck
    
    Currently, if info is null, the dev_err message is dereferencing an
    uninitialized module pointer.  Instead, it should use codec->dev pointer
    in dev_err call and better align with other err msg in this function.
    
    Also, ret variable might be used uninitialized in a specific case.
    Avoid using it this way.
    
    Found using static analysis with cppcheck:
    Checking drivers/staging/greybus/audio_topology.c...
    [drivers/staging/greybus/audio_topology.c:175]: (error) Uninitialized
    variable: module
    [drivers/staging/greybus/audio_topology.c:495]: (error) Uninitialized
    variable: ret
    
    Reported-by: Colin Ian King <colin.king@canonical.com>
    Signed-off-by: Vaibhav Agarwal <vaibhav.sr@gmail.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/audio_topology.c b/drivers/staging/greybus/audio_topology.c
index f9f33817a092..b6251691a33d 100644
--- a/drivers/staging/greybus/audio_topology.c
+++ b/drivers/staging/greybus/audio_topology.c
@@ -172,7 +172,7 @@ static int gbcodec_mixer_ctl_info(struct snd_kcontrol *kcontrol,
 	info = (struct gb_audio_ctl_elem_info *)data->info;
 
 	if (!info) {
-		dev_err(module->dev, "NULL info for %s\n", uinfo->id.name);
+		dev_err(codec->dev, "NULL info for %s\n", uinfo->id.name);
 		return -EINVAL;
 	}
 
@@ -489,10 +489,11 @@ static int gbcodec_mixer_dapm_ctl_put(struct snd_kcontrol *kcontrol,
 			dev_err_ratelimited(codec->dev,
 					    "%d:Error in %s for %s\n", ret,
 					    __func__, kcontrol->id.name);
+			return ret;
 		}
 	}
 
-	return ret;
+	return 0;
 }
 
 #define SOC_DAPM_MIXER_GB(xname, kcount, data) \

commit 4f1cbe2a7b4fa50e5ae09e0a564c9dc4101b02fd
Author: Eva Rachel Retuya <eraretuya@gmail.com>
Date:   Wed Sep 21 13:03:24 2016 +0800

    staging: greybus: audio: delete unnecessary parentheses
    
    Eliminate unneeded parentheses around the right hand side of an assignment.
    Coccinelle semantic patch used:
    
    @@
    expression e1, e2;
    identifier v;
    @@
    
    (
     v = (e1 == e2)
    |
     v = (e1 != e2)
    |
     v = (e1 <= e2)
    |
     v = (e1 >= e2)
    |
     v =
    - (
            e1
    - )
    )
    
    Signed-off-by: Eva Rachel Retuya <eraretuya@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/audio_topology.c b/drivers/staging/greybus/audio_topology.c
index 5eef5367896c..f9f33817a092 100644
--- a/drivers/staging/greybus/audio_topology.c
+++ b/drivers/staging/greybus/audio_topology.c
@@ -459,7 +459,7 @@ static int gbcodec_mixer_dapm_ctl_put(struct snd_kcontrol *kcontrol,
 
 	max = info->value.integer.max;
 	mask = (1 << fls(max)) - 1;
-	val = (ucontrol->value.integer.value[0] & mask);
+	val = ucontrol->value.integer.value[0] & mask;
 	connect = !!val;
 
 	/* update ucontrol */

commit 847175e8e660045f9366e7efd091969e8f32cc0c
Author: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
Date:   Thu Sep 1 11:38:40 2016 +0530

    greybus: audio: Fetch jack_mask, button_mask from module's topology data
    
    Added extra fields namely jack_mask & button_mask for each module_info.
    These fields are required while registering jack & reporting jack
    events.
    
    Earlier, these were hard coded values assuming fixed capabilities say
    HEADSET, LINEOUT, etc. supported by GB-codec driver. Now these are
    computed dynamically based on module's jack capability shared via
    topology data.
    
    Signed-off-by: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
    Reviewed-by: Mark Greer <mgreer@animalcreek.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/audio_topology.c b/drivers/staging/greybus/audio_topology.c
index e2fc186756a7..5eef5367896c 100644
--- a/drivers/staging/greybus/audio_topology.c
+++ b/drivers/staging/greybus/audio_topology.c
@@ -1393,6 +1393,13 @@ int gbaudio_tplg_parse_data(struct gbaudio_module_info *module,
 	}
 	dev_dbg(module->dev, "Route parsing finished\n");
 
+	/* parse jack capabilities */
+	if (tplg_data->jack_type) {
+		module->jack_mask = tplg_data->jack_type & GBCODEC_JACK_MASK;
+		module->button_mask = tplg_data->jack_type &
+			GBCODEC_JACK_BUTTON_MASK;
+	}
+
 	return ret;
 }
 

commit 79c222bcb72789456076a26a9bad2acc62cb2cdc
Author: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
Date:   Thu Sep 1 11:38:38 2016 +0530

    greybus: audio: Remove unnecessary num_jack field from module_info
    
    snd_jack will be registered based on real capabilities shared by
    module's FW instead of parsing widgets and register it with fixed
    capabilities. Remove module_info->num_jack, since it is no more
    required.
    
    Signed-off-by: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
    Reviewed-by: Mark Greer <mgreer@animalcreek.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/audio_topology.c b/drivers/staging/greybus/audio_topology.c
index e54078ad0583..e2fc186756a7 100644
--- a/drivers/staging/greybus/audio_topology.c
+++ b/drivers/staging/greybus/audio_topology.c
@@ -1065,7 +1065,6 @@ static int gbaudio_tplg_create_widget(struct gbaudio_module_info *module,
 	case snd_soc_dapm_hp:
 		*dw = (struct snd_soc_dapm_widget)
 			SND_SOC_DAPM_HP(w->name, gbcodec_event_hp);
-		module->num_jacks++;
 		module->op_devices |= (GBAUDIO_DEVICE_OUT_WIRED_HEADSET
 					| GBAUDIO_DEVICE_OUT_WIRED_HEADPHONE);
 		module->ip_devices |= GBAUDIO_DEVICE_IN_WIRED_HEADSET;

commit 6198f892fafbb3e5875c8a410eb2229a9cbac6ca
Author: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
Date:   Tue Aug 16 12:36:51 2016 +0530

    greybus: Use valid control pointer while freeing memory
    
    While releasing memory during error path exit, invalid memory pointer
    was used for dapm_routes. Use a valid one.
    
    Signed-off-by: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
    Reviewed-by: Mark Greer <mgreer@animalcreek.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/audio_topology.c b/drivers/staging/greybus/audio_topology.c
index 5c5b813b75d3..e54078ad0583 100644
--- a/drivers/staging/greybus/audio_topology.c
+++ b/drivers/staging/greybus/audio_topology.c
@@ -1317,7 +1317,7 @@ static int gbaudio_tplg_process_routes(struct gbaudio_module_info *module,
 	return 0;
 
 error:
-	devm_kfree(module->dev, dapm_routes);
+	devm_kfree(module->dev, module->dapm_routes);
 	return ret;
 }
 

commit 15c726ea5218b4e40d2331bd8b25b85848f73c42
Author: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
Date:   Tue Aug 16 12:36:50 2016 +0530

    greybus: audio: Add check for invalid index while mapping control
    
    While mapping control id to define DAPM routes, invalid control index
    may cause kernel oops. Add extra check to validate index while mapping
    names to control_id.
    
    Signed-off-by: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
    Reviewed-by: Mark Greer <mgreer@animalcreek.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/audio_topology.c b/drivers/staging/greybus/audio_topology.c
index 937529653cd3..5c5b813b75d3 100644
--- a/drivers/staging/greybus/audio_topology.c
+++ b/drivers/staging/greybus/audio_topology.c
@@ -64,6 +64,8 @@ static const char *gbaudio_map_controlid(struct gbaudio_module_info *module,
 		if (control->id == control_id) {
 			if (index == GBAUDIO_INVALID_ID)
 				return control->name;
+			if (index >= control->items)
+				return NULL;
 			return control->texts[index];
 		}
 	}
@@ -71,6 +73,8 @@ static const char *gbaudio_map_controlid(struct gbaudio_module_info *module,
 		if (control->id == control_id) {
 			if (index == GBAUDIO_INVALID_ID)
 				return control->name;
+			if (index >= control->items)
+				return NULL;
 			return control->texts[index];
 		}
 	}
@@ -1038,6 +1042,7 @@ static int gbaudio_tplg_create_widget(struct gbaudio_module_info *module,
 			csize += gbenum->names_length;
 			control->texts = (const char * const *)
 				gb_generate_enum_strings(module, gbenum);
+			control->items = gbenum->items;
 		} else
 			csize = sizeof(struct gb_audio_control);
 		*w_size += csize;
@@ -1184,6 +1189,7 @@ static int gbaudio_tplg_process_kcontrols(struct gbaudio_module_info *module,
 			csize += gbenum->names_length;
 			control->texts = (const char * const *)
 				gb_generate_enum_strings(module, gbenum);
+			control->items = gbenum->items;
 		} else
 			csize = sizeof(struct gb_audio_control);
 

commit 4ffca62a051c3e1722bcaf6a367b419e6e5e40e0
Author: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
Date:   Thu Aug 4 15:14:32 2016 +0530

    greybus: audio: Update parameters for gbaudio_module_update API
    
    Earlier, module path was enabled based on module's control switch e.g.
    'SPK Amp switch'.  Thus widget's name was sufficient to parse and
    identify the direction. Now individual modules' path will be enabled
    based on AIF widget status. So, it is required to get complete widget
    details, say w->type is used to identify direction (playback/capture)
    and w->sname is used to identify module's DATA connection used for
    communication via greybus.
    
    Signed-off-by: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
    Reviewed-by: Mark Greer <mgreer@animalcreek.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/audio_topology.c b/drivers/staging/greybus/audio_topology.c
index 3c7c786d3b03..937529653cd3 100644
--- a/drivers/staging/greybus/audio_topology.c
+++ b/drivers/staging/greybus/audio_topology.c
@@ -960,14 +960,12 @@ static int gbaudio_widget_event(struct snd_soc_dapm_widget *w,
 	case SND_SOC_DAPM_PRE_PMU:
 		ret = gb_audio_gb_enable_widget(module->mgmt_connection, wid);
 		if (!ret)
-			ret = gbaudio_module_update(gbcodec, w->name, module,
-						    1);
+			ret = gbaudio_module_update(gbcodec, w, module, 1);
 		break;
 	case SND_SOC_DAPM_POST_PMD:
 		ret = gb_audio_gb_disable_widget(module->mgmt_connection, wid);
 		if (!ret)
-			ret = gbaudio_module_update(gbcodec, w->name, module,
-						    0);
+			ret = gbaudio_module_update(gbcodec, w, module, 0);
 		break;
 	}
 	if (ret)

commit 9d3717f71c22c4f39723f18ed094c552f4b73146
Author: David Lin <dtwlin@google.com>
Date:   Mon Jul 25 16:29:20 2016 -0700

    greybus: audio: add runtime pm to enumerated control and DAPM widget
    
    There's an issue that the userspace is not able to control both the
    enumerated control and DAPM widget when audio bundle is in the SUSPEND
    state. This patch fixes the issue by adding pm_runtime_get/put() calls
    for the both controls.
    
    Testing Done:
     - Use tinymix to get and put both enumerated control and DAPM widget as
       the followings, and observe audio bundle is able to wake up from
       suspend.
    
    $ tinymix "GB 3 PB source" 1
    $ tinymix "GB 3 PB source"
    GB 3 PB source: AIF1    >AIF2
    
    $ tinymix "GB 3 AIF1_RX MUX" 2
    $ tinymix "GB 3 AIF1_RX MUX"
    GB 3 AIF1_RX MUX:       Stereo  Left    >Right
    
    Reported-by: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
    Signed-off-by: David Lin <dtwlin@google.com>
    Reviewed-by: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
    Reviewed-by: Mark Greer <mgreer@animalcreek.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/audio_topology.c b/drivers/staging/greybus/audio_topology.c
index 17ba0a028426..3c7c786d3b03 100644
--- a/drivers/staging/greybus/audio_topology.c
+++ b/drivers/staging/greybus/audio_topology.c
@@ -555,6 +555,7 @@ static int gbcodec_enum_ctl_get(struct snd_kcontrol *kcontrol,
 	struct gb_audio_ctl_elem_value gbvalue;
 	struct gbaudio_module_info *module;
 	struct gbaudio_codec_info *gb = snd_soc_codec_get_drvdata(codec);
+	struct gb_bundle *bundle;
 
 	module = find_gb_module(gb, kcontrol->id.name);
 	if (!module)
@@ -564,8 +565,17 @@ static int gbcodec_enum_ctl_get(struct snd_kcontrol *kcontrol,
 	if (ctl_id < 0)
 		return -EINVAL;
 
+	bundle = to_gb_bundle(module->dev);
+
+	ret = gb_pm_runtime_get_sync(bundle);
+	if (ret)
+		return ret;
+
 	ret = gb_audio_gb_get_control(module->mgmt_connection, ctl_id,
 				      GB_AUDIO_INVALID_INDEX, &gbvalue);
+
+	gb_pm_runtime_put_autosuspend(bundle);
+
 	if (ret) {
 		dev_err_ratelimited(codec->dev, "%d:Error in %s for %s\n", ret,
 				    __func__, kcontrol->id.name);
@@ -589,6 +599,7 @@ static int gbcodec_enum_ctl_put(struct snd_kcontrol *kcontrol,
 	struct gb_audio_ctl_elem_value gbvalue;
 	struct gbaudio_module_info *module;
 	struct gbaudio_codec_info *gb = snd_soc_codec_get_drvdata(codec);
+	struct gb_bundle *bundle;
 
 	module = find_gb_module(gb, kcontrol->id.name);
 	if (!module)
@@ -609,8 +620,17 @@ static int gbcodec_enum_ctl_put(struct snd_kcontrol *kcontrol,
 			ucontrol->value.enumerated.item[1];
 	}
 
+	bundle = to_gb_bundle(module->dev);
+
+	ret = gb_pm_runtime_get_sync(bundle);
+	if (ret)
+		return ret;
+
 	ret = gb_audio_gb_set_control(module->mgmt_connection, ctl_id,
 				      GB_AUDIO_INVALID_INDEX, &gbvalue);
+
+	gb_pm_runtime_put_autosuspend(bundle);
+
 	if (ret) {
 		dev_err_ratelimited(codec->dev, "%d:Error in %s for %s\n", ret,
 				    __func__, kcontrol->id.name);
@@ -698,6 +718,7 @@ static int gbcodec_enum_dapm_ctl_get(struct snd_kcontrol *kcontrol,
 	struct snd_soc_codec *codec = widget->codec;
 	struct gbaudio_codec_info *gb = snd_soc_codec_get_drvdata(codec);
 	struct soc_enum *e = (struct soc_enum *)kcontrol->private_value;
+	struct gb_bundle *bundle;
 
 	module = find_gb_module(gb, kcontrol->id.name);
 	if (!module)
@@ -707,8 +728,17 @@ static int gbcodec_enum_dapm_ctl_get(struct snd_kcontrol *kcontrol,
 	if (ctl_id < 0)
 		return -EINVAL;
 
+	bundle = to_gb_bundle(module->dev);
+
+	ret = gb_pm_runtime_get_sync(bundle);
+	if (ret)
+		return ret;
+
 	ret = gb_audio_gb_get_control(module->mgmt_connection, ctl_id,
 				      GB_AUDIO_INVALID_INDEX, &gbvalue);
+
+	gb_pm_runtime_put_autosuspend(bundle);
+
 	if (ret) {
 		dev_err_ratelimited(codec->dev, "%d:Error in %s for %s\n", ret,
 				    __func__, kcontrol->id.name);
@@ -736,6 +766,7 @@ static int gbcodec_enum_dapm_ctl_put(struct snd_kcontrol *kcontrol,
 	struct snd_soc_codec *codec = widget->codec;
 	struct gbaudio_codec_info *gb = snd_soc_codec_get_drvdata(codec);
 	struct soc_enum *e = (struct soc_enum *)kcontrol->private_value;
+	struct gb_bundle *bundle;
 
 	if (ucontrol->value.enumerated.item[0] > e->max - 1)
 		return -EINVAL;
@@ -749,8 +780,17 @@ static int gbcodec_enum_dapm_ctl_put(struct snd_kcontrol *kcontrol,
 		return -EINVAL;
 
 	change = 0;
+	bundle = to_gb_bundle(module->dev);
+
+	ret = gb_pm_runtime_get_sync(bundle);
+	if (ret)
+		return ret;
+
 	ret = gb_audio_gb_get_control(module->mgmt_connection, ctl_id,
 				      GB_AUDIO_INVALID_INDEX, &gbvalue);
+
+	gb_pm_runtime_put_autosuspend(bundle);
+
 	if (ret) {
 		dev_err_ratelimited(codec->dev, "%d:Error in %s for %s\n", ret,
 				    __func__, kcontrol->id.name);
@@ -782,8 +822,15 @@ static int gbcodec_enum_dapm_ctl_put(struct snd_kcontrol *kcontrol,
 	}
 
 	if (change) {
+		ret = gb_pm_runtime_get_sync(bundle);
+		if (ret)
+			return ret;
+
 		ret = gb_audio_gb_set_control(module->mgmt_connection, ctl_id,
 					      GB_AUDIO_INVALID_INDEX, &gbvalue);
+
+		gb_pm_runtime_put_autosuspend(bundle);
+
 		if (ret) {
 			dev_err_ratelimited(codec->dev,
 					    "%d:Error in %s for %s\n", ret,

commit a0de502ed39663d47b568de27f46971e41f0abdf
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Sat Jul 16 09:44:28 2016 -0700

    greybus: audio_topology: Fix compile warning
    
    Fix following compile warning by staticizing gb_generate_enum_strings().
    
    greybus/audio_topology.c:134:12: warning: symbol 'gb_generate_enum_strings' was not declared. Should it be static?
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/audio_topology.c b/drivers/staging/greybus/audio_topology.c
index 487f74455a1c..17ba0a028426 100644
--- a/drivers/staging/greybus/audio_topology.c
+++ b/drivers/staging/greybus/audio_topology.c
@@ -131,8 +131,8 @@ static const char *gbaudio_map_widgetid(struct gbaudio_module_info *module,
 	return NULL;
 }
 
-const char **gb_generate_enum_strings(struct gbaudio_module_info *gb,
-				      struct gb_audio_enumerated *gbenum)
+static const char **gb_generate_enum_strings(struct gbaudio_module_info *gb,
+					     struct gb_audio_enumerated *gbenum)
 {
 	const char **strings;
 	int i;

commit 6ba7fad430d6300b966800bc5d2c782e2baf6f1d
Author: David Lin <dtwlin@google.com>
Date:   Thu Jul 14 15:13:00 2016 -0500

    greybus: audio: add runtime pm support
    
    Add runtime pm support to audio protocol device class driver.
    
    Testing Done:
     - Use white speaker module and check the interface is autosuspended when
       it's idle and resumed when playback audio
    
    Signed-off-by: David Lin <dtwlin@google.com>
    Signed-off-by: Axel Haslam <ahaslam@baylibre.com>
    Reviewed-by: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
    Signed-off-by: Alex Elder <elder@linaro.org>

diff --git a/drivers/staging/greybus/audio_topology.c b/drivers/staging/greybus/audio_topology.c
index e0779ca64388..487f74455a1c 100644
--- a/drivers/staging/greybus/audio_topology.c
+++ b/drivers/staging/greybus/audio_topology.c
@@ -213,6 +213,7 @@ static int gbcodec_mixer_ctl_get(struct snd_kcontrol *kcontrol,
 	struct gbaudio_module_info *module;
 	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
 	struct gbaudio_codec_info *gb = snd_soc_codec_get_drvdata(codec);
+	struct gb_bundle *bundle;
 
 	dev_dbg(codec->dev, "Entered %s:%s\n", __func__, kcontrol->id.name);
 	module = find_gb_module(gb, kcontrol->id.name);
@@ -221,9 +222,17 @@ static int gbcodec_mixer_ctl_get(struct snd_kcontrol *kcontrol,
 
 	data = (struct gbaudio_ctl_pvt *)kcontrol->private_value;
 	info = (struct gb_audio_ctl_elem_info *)data->info;
+	bundle = to_gb_bundle(module->dev);
+
+	ret = gb_pm_runtime_get_sync(bundle);
+	if (ret)
+		return ret;
 
 	ret = gb_audio_gb_get_control(module->mgmt_connection, data->ctl_id,
 				      GB_AUDIO_INVALID_INDEX, &gbvalue);
+
+	gb_pm_runtime_put_autosuspend(bundle);
+
 	if (ret) {
 		dev_err_ratelimited(codec->dev, "%d:Error in %s for %s\n", ret,
 				    __func__, kcontrol->id.name);
@@ -266,6 +275,7 @@ static int gbcodec_mixer_ctl_put(struct snd_kcontrol *kcontrol,
 	struct gbaudio_module_info *module;
 	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
 	struct gbaudio_codec_info *gb = snd_soc_codec_get_drvdata(codec);
+	struct gb_bundle *bundle;
 
 	dev_dbg(codec->dev, "Entered %s:%s\n", __func__, kcontrol->id.name);
 	module = find_gb_module(gb, kcontrol->id.name);
@@ -274,6 +284,7 @@ static int gbcodec_mixer_ctl_put(struct snd_kcontrol *kcontrol,
 
 	data = (struct gbaudio_ctl_pvt *)kcontrol->private_value;
 	info = (struct gb_audio_ctl_elem_info *)data->info;
+	bundle = to_gb_bundle(module->dev);
 
 	/* update ucontrol */
 	switch (info->type) {
@@ -299,11 +310,18 @@ static int gbcodec_mixer_ctl_put(struct snd_kcontrol *kcontrol,
 		break;
 	}
 
+	if (ret)
+		return ret;
+
+	ret = gb_pm_runtime_get_sync(bundle);
 	if (ret)
 		return ret;
 
 	ret = gb_audio_gb_set_control(module->mgmt_connection, data->ctl_id,
 				      GB_AUDIO_INVALID_INDEX, &gbvalue);
+
+	gb_pm_runtime_put_autosuspend(bundle);
+
 	if (ret) {
 		dev_err_ratelimited(codec->dev, "%d:Error in %s for %s\n", ret,
 				    __func__, kcontrol->id.name);
@@ -370,6 +388,7 @@ static int gbcodec_mixer_dapm_ctl_get(struct snd_kcontrol *kcontrol,
 	struct snd_soc_dapm_widget *widget = wlist->widgets[0];
 	struct snd_soc_codec *codec = widget->codec;
 	struct gbaudio_codec_info *gb = snd_soc_codec_get_drvdata(codec);
+	struct gb_bundle *bundle;
 
 	dev_dbg(codec->dev, "Entered %s:%s\n", __func__, kcontrol->id.name);
 	module = find_gb_module(gb, kcontrol->id.name);
@@ -378,14 +397,22 @@ static int gbcodec_mixer_dapm_ctl_get(struct snd_kcontrol *kcontrol,
 
 	data = (struct gbaudio_ctl_pvt *)kcontrol->private_value;
 	info = (struct gb_audio_ctl_elem_info *)data->info;
+	bundle = to_gb_bundle(module->dev);
 
 	if (data->vcount == 2)
 		dev_warn(widget->dapm->dev,
 			 "GB: Control '%s' is stereo, which is not supported\n",
 			 kcontrol->id.name);
 
+	ret = gb_pm_runtime_get_sync(bundle);
+	if (ret)
+		return ret;
+
 	ret = gb_audio_gb_get_control(module->mgmt_connection, data->ctl_id,
 				      GB_AUDIO_INVALID_INDEX, &gbvalue);
+
+	gb_pm_runtime_put_autosuspend(bundle);
+
 	if (ret) {
 		dev_err_ratelimited(codec->dev, "%d:Error in %s for %s\n", ret,
 				    __func__, kcontrol->id.name);
@@ -410,6 +437,7 @@ static int gbcodec_mixer_dapm_ctl_put(struct snd_kcontrol *kcontrol,
 	struct snd_soc_dapm_widget *widget = wlist->widgets[0];
 	struct snd_soc_codec *codec = widget->codec;
 	struct gbaudio_codec_info *gb = snd_soc_codec_get_drvdata(codec);
+	struct gb_bundle *bundle;
 
 	dev_dbg(codec->dev, "Entered %s:%s\n", __func__, kcontrol->id.name);
 	module = find_gb_module(gb, kcontrol->id.name);
@@ -418,6 +446,7 @@ static int gbcodec_mixer_dapm_ctl_put(struct snd_kcontrol *kcontrol,
 
 	data = (struct gbaudio_ctl_pvt *)kcontrol->private_value;
 	info = (struct gb_audio_ctl_elem_info *)data->info;
+	bundle = to_gb_bundle(module->dev);
 
 	if (data->vcount == 2)
 		dev_warn(widget->dapm->dev,
@@ -441,9 +470,17 @@ static int gbcodec_mixer_dapm_ctl_put(struct snd_kcontrol *kcontrol,
 		}
 		gbvalue.value.integer_value[0] =
 			ucontrol->value.integer.value[0];
+
+		ret = gb_pm_runtime_get_sync(bundle);
+		if (ret)
+			return ret;
+
 		ret = gb_audio_gb_set_control(module->mgmt_connection,
 					      data->ctl_id,
 					      GB_AUDIO_INVALID_INDEX, &gbvalue);
+
+		gb_pm_runtime_put_autosuspend(bundle);
+
 		if (ret) {
 			dev_err_ratelimited(codec->dev,
 					    "%d:Error in %s for %s\n", ret,
@@ -850,6 +887,7 @@ static int gbaudio_widget_event(struct snd_soc_dapm_widget *w,
 	struct snd_soc_codec *codec = w->codec;
 	struct gbaudio_codec_info *gbcodec = snd_soc_codec_get_drvdata(codec);
 	struct gbaudio_module_info *module;
+	struct gb_bundle *bundle;
 
 	dev_dbg(codec->dev, "%s %s %d\n", __func__, w->name, event);
 
@@ -865,6 +903,12 @@ static int gbaudio_widget_event(struct snd_soc_dapm_widget *w,
 		return -EINVAL;
 	}
 
+	bundle = to_gb_bundle(module->dev);
+
+	ret = gb_pm_runtime_get_sync(bundle);
+	if (ret)
+		return ret;
+
 	switch (event) {
 	case SND_SOC_DAPM_PRE_PMU:
 		ret = gb_audio_gb_enable_widget(module->mgmt_connection, wid);
@@ -883,6 +927,9 @@ static int gbaudio_widget_event(struct snd_soc_dapm_widget *w,
 		dev_err_ratelimited(codec->dev,
 				    "%d: widget, event:%d failed:%d\n", wid,
 				    event, ret);
+
+	gb_pm_runtime_put_autosuspend(bundle);
+
 	return ret;
 }
 

commit e65579e335da0a65b5a76a343ddff6a6f3c77dd1
Author: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
Date:   Thu Jun 30 18:45:37 2016 +0530

    greybus: audio: topology: Enable enumerated control support
    
    Added .get/.set callback and relevant changes in parser to enable
    enumerated control support for kcontrols and DAPM widget controls.
    Currently, it is limited to enumerated strings only.
    
    Signed-off-by: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
    Reviewed-by: Mark Greer <mark.greer@animalcreek.com>
    Signed-off-by: Alex Elder <elder@linaro.org>

diff --git a/drivers/staging/greybus/audio_topology.c b/drivers/staging/greybus/audio_topology.c
index 130548313454..e0779ca64388 100644
--- a/drivers/staging/greybus/audio_topology.c
+++ b/drivers/staging/greybus/audio_topology.c
@@ -53,7 +53,7 @@ static struct gbaudio_module_info *find_gb_module(
 }
 
 static const char *gbaudio_map_controlid(struct gbaudio_module_info *module,
-					   __u8 control_id, __u8 index)
+					 __u8 control_id, __u8 index)
 {
 	struct gbaudio_control *control;
 
@@ -77,8 +77,23 @@ static const char *gbaudio_map_controlid(struct gbaudio_module_info *module,
 	return NULL;
 }
 
+static int gbaudio_map_controlname(struct gbaudio_module_info *module,
+				   const char *name)
+{
+	struct gbaudio_control *control;
+
+	list_for_each_entry(control, &module->ctl_list, list) {
+		if (!strncmp(control->name, name, NAME_SIZE))
+			return control->id;
+	}
+
+	dev_warn(module->dev, "%s: missing in modules controls list\n", name);
+
+	return -EINVAL;
+}
+
 static int gbaudio_map_wcontrolname(struct gbaudio_module_info *module,
-					  const char *name)
+				    const char *name)
 {
 	struct gbaudio_control *control;
 
@@ -92,7 +107,7 @@ static int gbaudio_map_wcontrolname(struct gbaudio_module_info *module,
 }
 
 static int gbaudio_map_widgetname(struct gbaudio_module_info *module,
-					  const char *name)
+				  const char *name)
 {
 	struct gbaudio_widget *widget;
 	list_for_each_entry(widget, &module->widget_list, list) {
@@ -105,7 +120,7 @@ static int gbaudio_map_widgetname(struct gbaudio_module_info *module,
 }
 
 static const char *gbaudio_map_widgetid(struct gbaudio_module_info *module,
-					  __u8 widget_id)
+					__u8 widget_id)
 {
 	struct gbaudio_widget *widget;
 
@@ -116,6 +131,27 @@ static const char *gbaudio_map_widgetid(struct gbaudio_module_info *module,
 	return NULL;
 }
 
+const char **gb_generate_enum_strings(struct gbaudio_module_info *gb,
+				      struct gb_audio_enumerated *gbenum)
+{
+	const char **strings;
+	int i;
+	__u8 *data;
+
+	strings = devm_kzalloc(gb->dev, sizeof(char *) * gbenum->items,
+			       GFP_KERNEL);
+	data = gbenum->names;
+
+	for (i = 0; i < gbenum->items; i++) {
+		strings[i] = (const char *)data;
+		while (*data != '\0')
+			data++;
+		data++;
+	}
+
+	return strings;
+}
+
 static int gbcodec_mixer_ctl_info(struct snd_kcontrol *kcontrol,
 		     struct snd_ctl_elem_info *uinfo)
 {
@@ -473,60 +509,288 @@ static int gbaudio_validate_kcontrol_count(struct gb_audio_widget *w)
 	return ret;
 }
 
+static int gbcodec_enum_ctl_get(struct snd_kcontrol *kcontrol,
+				struct snd_ctl_elem_value *ucontrol)
+{
+	int ret, ctl_id;
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+	struct soc_enum *e = (struct soc_enum *)kcontrol->private_value;
+	struct gb_audio_ctl_elem_value gbvalue;
+	struct gbaudio_module_info *module;
+	struct gbaudio_codec_info *gb = snd_soc_codec_get_drvdata(codec);
+
+	module = find_gb_module(gb, kcontrol->id.name);
+	if (!module)
+		return -EINVAL;
+
+	ctl_id = gbaudio_map_controlname(module, kcontrol->id.name);
+	if (ctl_id < 0)
+		return -EINVAL;
+
+	ret = gb_audio_gb_get_control(module->mgmt_connection, ctl_id,
+				      GB_AUDIO_INVALID_INDEX, &gbvalue);
+	if (ret) {
+		dev_err_ratelimited(codec->dev, "%d:Error in %s for %s\n", ret,
+				    __func__, kcontrol->id.name);
+		return ret;
+	}
+
+	ucontrol->value.enumerated.item[0] = gbvalue.value.enumerated_item[0];
+	if (e->shift_l != e->shift_r)
+		ucontrol->value.enumerated.item[1] =
+			gbvalue.value.enumerated_item[1];
+
+	return 0;
+}
+
+static int gbcodec_enum_ctl_put(struct snd_kcontrol *kcontrol,
+				struct snd_ctl_elem_value *ucontrol)
+{
+	int ret, ctl_id;
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+	struct soc_enum *e = (struct soc_enum *)kcontrol->private_value;
+	struct gb_audio_ctl_elem_value gbvalue;
+	struct gbaudio_module_info *module;
+	struct gbaudio_codec_info *gb = snd_soc_codec_get_drvdata(codec);
+
+	module = find_gb_module(gb, kcontrol->id.name);
+	if (!module)
+		return -EINVAL;
+
+	ctl_id = gbaudio_map_controlname(module, kcontrol->id.name);
+	if (ctl_id < 0)
+		return -EINVAL;
+
+	if (ucontrol->value.enumerated.item[0] > e->max - 1)
+		return -EINVAL;
+	gbvalue.value.enumerated_item[0] = ucontrol->value.enumerated.item[0];
+
+	if (e->shift_l != e->shift_r) {
+		if (ucontrol->value.enumerated.item[1] > e->max - 1)
+			return -EINVAL;
+		gbvalue.value.enumerated_item[1] =
+			ucontrol->value.enumerated.item[1];
+	}
+
+	ret = gb_audio_gb_set_control(module->mgmt_connection, ctl_id,
+				      GB_AUDIO_INVALID_INDEX, &gbvalue);
+	if (ret) {
+		dev_err_ratelimited(codec->dev, "%d:Error in %s for %s\n", ret,
+				    __func__, kcontrol->id.name);
+	}
+
+	return ret;
+}
+
+static int gbaudio_tplg_create_enum_kctl(struct gbaudio_module_info *gb,
+					 struct snd_kcontrol_new *kctl,
+					 struct gb_audio_control *ctl)
+{
+	struct soc_enum *gbe;
+	struct gb_audio_enumerated *gb_enum;
+	int i;
+
+	gbe = devm_kzalloc(gb->dev, sizeof(*gbe), GFP_KERNEL);
+	if (!gbe)
+		return -ENOMEM;
+
+	gb_enum = &ctl->info.value.enumerated;
+
+	/* since count=1, and reg is dummy */
+	gbe->max = gb_enum->items;
+	gbe->texts = gb_generate_enum_strings(gb, gb_enum);
+
+	/* debug enum info */
+	dev_dbg(gb->dev, "Max:%d, name_length:%d\n", gb_enum->items,
+		 gb_enum->names_length);
+	for (i = 0; i < gb_enum->items; i++)
+		dev_dbg(gb->dev, "src[%d]: %s\n", i, gbe->texts[i]);
+
+	*kctl = (struct snd_kcontrol_new)
+		SOC_ENUM_EXT(ctl->name, *gbe, gbcodec_enum_ctl_get,
+			     gbcodec_enum_ctl_put);
+	return 0;
+}
+
 static int gbaudio_tplg_create_kcontrol(struct gbaudio_module_info *gb,
 					struct snd_kcontrol_new *kctl,
 					struct gb_audio_control *ctl)
 {
+	int ret = 0;
 	struct gbaudio_ctl_pvt *ctldata;
 
 	switch (ctl->iface) {
 	case SNDRV_CTL_ELEM_IFACE_MIXER:
-		ctldata = devm_kzalloc(gb->dev, sizeof(struct gbaudio_ctl_pvt),
-				       GFP_KERNEL);
-		if (!ctldata)
-			return -ENOMEM;
-		ctldata->ctl_id = ctl->id;
-		ctldata->data_cport = ctl->data_cport;
-		ctldata->access = ctl->access;
-		ctldata->vcount = ctl->count_values;
-		ctldata->info = &ctl->info;
-		*kctl = (struct snd_kcontrol_new)
-			SOC_MIXER_GB(ctl->name, ctl->count, ctldata);
-		ctldata = NULL;
+		switch (ctl->info.type) {
+		case GB_AUDIO_CTL_ELEM_TYPE_ENUMERATED:
+			ret = gbaudio_tplg_create_enum_kctl(gb, kctl, ctl);
+			break;
+		default:
+			ctldata = devm_kzalloc(gb->dev,
+					       sizeof(struct gbaudio_ctl_pvt),
+					       GFP_KERNEL);
+			if (!ctldata)
+				return -ENOMEM;
+			ctldata->ctl_id = ctl->id;
+			ctldata->data_cport = ctl->data_cport;
+			ctldata->access = ctl->access;
+			ctldata->vcount = ctl->count_values;
+			ctldata->info = &ctl->info;
+			*kctl = (struct snd_kcontrol_new)
+				SOC_MIXER_GB(ctl->name, ctl->count, ctldata);
+			ctldata = NULL;
+			break;
+		}
 		break;
 	default:
 		return -EINVAL;
 	}
 
 	dev_dbg(gb->dev, "%s:%d control created\n", ctl->name, ctl->id);
+	return ret;
+}
+
+static int gbcodec_enum_dapm_ctl_get(struct snd_kcontrol *kcontrol,
+				     struct snd_ctl_elem_value *ucontrol)
+{
+	int ret, ctl_id;
+	struct snd_soc_dapm_widget_list *wlist = snd_kcontrol_chip(kcontrol);
+	struct snd_soc_dapm_widget *widget = wlist->widgets[0];
+	struct gbaudio_module_info *module;
+	struct gb_audio_ctl_elem_value gbvalue;
+	struct snd_soc_codec *codec = widget->codec;
+	struct gbaudio_codec_info *gb = snd_soc_codec_get_drvdata(codec);
+	struct soc_enum *e = (struct soc_enum *)kcontrol->private_value;
+
+	module = find_gb_module(gb, kcontrol->id.name);
+	if (!module)
+		return -EINVAL;
+
+	ctl_id = gbaudio_map_wcontrolname(module, kcontrol->id.name);
+	if (ctl_id < 0)
+		return -EINVAL;
+
+	ret = gb_audio_gb_get_control(module->mgmt_connection, ctl_id,
+				      GB_AUDIO_INVALID_INDEX, &gbvalue);
+	if (ret) {
+		dev_err_ratelimited(codec->dev, "%d:Error in %s for %s\n", ret,
+				    __func__, kcontrol->id.name);
+		return ret;
+	}
+
+	ucontrol->value.enumerated.item[0] = gbvalue.value.enumerated_item[0];
+	if (e->shift_l != e->shift_r)
+		ucontrol->value.enumerated.item[1] =
+			gbvalue.value.enumerated_item[1];
+
 	return 0;
 }
 
-static const char * const gbtexts[] = {"Stereo", "Left", "Right"};
+static int gbcodec_enum_dapm_ctl_put(struct snd_kcontrol *kcontrol,
+				     struct snd_ctl_elem_value *ucontrol)
+{
+	int ret, wi, ctl_id;
+	unsigned int val, mux, change;
+	unsigned int mask;
+	struct snd_soc_dapm_widget_list *wlist = snd_kcontrol_chip(kcontrol);
+	struct snd_soc_dapm_widget *widget = wlist->widgets[0];
+	struct gb_audio_ctl_elem_value gbvalue;
+	struct gbaudio_module_info *module;
+	struct snd_soc_codec *codec = widget->codec;
+	struct gbaudio_codec_info *gb = snd_soc_codec_get_drvdata(codec);
+	struct soc_enum *e = (struct soc_enum *)kcontrol->private_value;
+
+	if (ucontrol->value.enumerated.item[0] > e->max - 1)
+		return -EINVAL;
+
+	module = find_gb_module(gb, kcontrol->id.name);
+	if (!module)
+		return -EINVAL;
+
+	ctl_id = gbaudio_map_wcontrolname(module, kcontrol->id.name);
+	if (ctl_id < 0)
+		return -EINVAL;
+
+	change = 0;
+	ret = gb_audio_gb_get_control(module->mgmt_connection, ctl_id,
+				      GB_AUDIO_INVALID_INDEX, &gbvalue);
+	if (ret) {
+		dev_err_ratelimited(codec->dev, "%d:Error in %s for %s\n", ret,
+				    __func__, kcontrol->id.name);
+		return ret;
+	}
 
-static const SOC_ENUM_SINGLE_DECL(
-	module_apb1_rx_enum, GBCODEC_APB1_MUX_REG, 0, gbtexts);
+	mux = ucontrol->value.enumerated.item[0];
+	val = mux << e->shift_l;
+	mask = e->mask << e->shift_l;
 
-static const SOC_ENUM_SINGLE_DECL(
-	module_mic_enum, GBCODEC_APB1_MUX_REG, 4, gbtexts);
+	if (gbvalue.value.enumerated_item[0] !=
+	    ucontrol->value.enumerated.item[0]) {
+		change = 1;
+		gbvalue.value.enumerated_item[0] =
+			ucontrol->value.enumerated.item[0];
+	}
+
+	if (e->shift_l != e->shift_r) {
+		if (ucontrol->value.enumerated.item[1] > e->max - 1)
+			return -EINVAL;
+		val |= ucontrol->value.enumerated.item[1] << e->shift_r;
+		mask |= e->mask << e->shift_r;
+		if (gbvalue.value.enumerated_item[1] !=
+		    ucontrol->value.enumerated.item[1]) {
+			change = 1;
+			gbvalue.value.enumerated_item[1] =
+				ucontrol->value.enumerated.item[1];
+		}
+	}
+
+	if (change) {
+		ret = gb_audio_gb_set_control(module->mgmt_connection, ctl_id,
+					      GB_AUDIO_INVALID_INDEX, &gbvalue);
+		if (ret) {
+			dev_err_ratelimited(codec->dev,
+					    "%d:Error in %s for %s\n", ret,
+					    __func__, kcontrol->id.name);
+		}
+		for (wi = 0; wi < wlist->num_widgets; wi++) {
+			widget = wlist->widgets[wi];
+
+			widget->value = val;
+			widget->dapm->update = NULL;
+			snd_soc_dapm_mux_update_power(widget, kcontrol, mux, e);
+		}
+	}
+
+	return change;
+}
 
 static int gbaudio_tplg_create_enum_ctl(struct gbaudio_module_info *gb,
 					struct snd_kcontrol_new *kctl,
 					struct gb_audio_control *ctl)
 {
-	switch (ctl->id) {
-	case 8:
-		*kctl = (struct snd_kcontrol_new)
-			SOC_DAPM_ENUM(ctl->name, module_apb1_rx_enum);
-		break;
-	case 9:
-		*kctl = (struct snd_kcontrol_new)
-			SOC_DAPM_ENUM(ctl->name, module_mic_enum);
-		break;
-	default:
-		return -EINVAL;
-	}
+	struct soc_enum *gbe;
+	struct gb_audio_enumerated *gb_enum;
+	int i;
+
+	gbe = devm_kzalloc(gb->dev, sizeof(*gbe), GFP_KERNEL);
+	if (!gbe)
+		return -ENOMEM;
 
+	gb_enum = &ctl->info.value.enumerated;
+
+	/* since count=1, and reg is dummy */
+	gbe->max = gb_enum->items;
+	gbe->texts = gb_generate_enum_strings(gb, gb_enum);
+
+	/* debug enum info */
+	dev_dbg(gb->dev, "Max:%d, name_length:%d\n", gb_enum->items,
+		 gb_enum->names_length);
+	for (i = 0; i < gb_enum->items; i++)
+		dev_dbg(gb->dev, "src[%d]: %s\n", i, gbe->texts[i]);
+
+	*kctl = (struct snd_kcontrol_new)
+		SOC_DAPM_ENUM_EXT(ctl->name, *gbe, gbcodec_enum_dapm_ctl_get,
+				  gbcodec_enum_dapm_ctl_put);
 	return 0;
 }
 
@@ -672,10 +936,18 @@ static int gbaudio_tplg_create_widget(struct gbaudio_module_info *module,
 		control->name = curr->name;
 		control->wname = w->name;
 
-		if (curr->info.type == GB_AUDIO_CTL_ELEM_TYPE_ENUMERATED)
+		if (curr->info.type == GB_AUDIO_CTL_ELEM_TYPE_ENUMERATED) {
+			struct gb_audio_enumerated *gbenum =
+				&curr->info.value.enumerated;
+
+			csize = offsetof(struct gb_audio_control, info);
+			csize += offsetof(struct gb_audio_ctl_elem_info, value);
+			csize += offsetof(struct gb_audio_enumerated, names);
+			csize += gbenum->names_length;
 			control->texts = (const char * const *)
-				curr->info.value.enumerated.names;
-		csize = sizeof(struct gb_audio_control);
+				gb_generate_enum_strings(module, gbenum);
+		} else
+			csize = sizeof(struct gb_audio_control);
 		*w_size += csize;
 		curr = (void *)curr + csize;
 		list_add(&control->list, &module->widget_ctl_list);
@@ -810,10 +1082,18 @@ static int gbaudio_tplg_process_kcontrols(struct gbaudio_module_info *module,
 		snprintf(curr->name, NAME_SIZE, "GB %d %s", module->dev_id,
 			 temp_name);
 		control->name = curr->name;
-		if (curr->info.type == GB_AUDIO_CTL_ELEM_TYPE_ENUMERATED)
+		if (curr->info.type == GB_AUDIO_CTL_ELEM_TYPE_ENUMERATED) {
+			struct gb_audio_enumerated *gbenum =
+				&curr->info.value.enumerated;
+
+			csize = offsetof(struct gb_audio_control, info);
+			csize += offsetof(struct gb_audio_ctl_elem_info, value);
+			csize += offsetof(struct gb_audio_enumerated, names);
+			csize += gbenum->names_length;
 			control->texts = (const char * const *)
-				curr->info.value.enumerated.names;
-		csize = sizeof(struct gb_audio_control);
+				gb_generate_enum_strings(module, gbenum);
+		} else
+			csize = sizeof(struct gb_audio_control);
 
 		list_add(&control->list, &module->ctl_list);
 		dev_dbg(module->dev, "%d:%s created of type %d\n", curr->id,

commit d4cd9daa49b2dc46497d40d0251b27d0d685754e
Author: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
Date:   Tue Jul 5 17:09:20 2016 -0500

    greybus: audio: topology: Use csize while computing next_ptr in parser
    
    Size of control elements vary in case of enumerated controls. As a
    preparation to enable enumerated control in topology parser, this patch
    uses csize while parsing controls & wsize while parsing widgets & its
    control to update next pointer.
    
    Signed-off-by: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
    Reviewed-by: Mark Greer <mark.greer@animalcreek.com>
    Signed-off-by: Alex Elder <elder@linaro.org>

diff --git a/drivers/staging/greybus/audio_topology.c b/drivers/staging/greybus/audio_topology.c
index 92f2ada60be8..130548313454 100644
--- a/drivers/staging/greybus/audio_topology.c
+++ b/drivers/staging/greybus/audio_topology.c
@@ -624,9 +624,9 @@ static int gbaudio_widget_event(struct snd_soc_dapm_widget *w,
 
 static int gbaudio_tplg_create_widget(struct gbaudio_module_info *module,
 				      struct snd_soc_dapm_widget *dw,
-				      struct gb_audio_widget *w)
+				      struct gb_audio_widget *w, int *w_size)
 {
-	int i, ret;
+	int i, ret, csize;
 	struct snd_kcontrol_new *widget_kctls;
 	struct gb_audio_control *curr;
 	struct gbaudio_control *control, *_control;
@@ -648,9 +648,11 @@ static int gbaudio_tplg_create_widget(struct gbaudio_module_info *module,
 			return -ENOMEM;
 	}
 
+	*w_size = sizeof(struct gb_audio_widget);
+
 	/* create relevant kcontrols */
+	curr = w->ctl;
 	for (i = 0; i < w->ncontrols; i++) {
-		curr = &w->ctl[i];
 		ret = gbaudio_tplg_create_wcontrol(module, &widget_kctls[i],
 						   curr);
 		if (ret) {
@@ -673,6 +675,9 @@ static int gbaudio_tplg_create_widget(struct gbaudio_module_info *module,
 		if (curr->info.type == GB_AUDIO_CTL_ELEM_TYPE_ENUMERATED)
 			control->texts = (const char * const *)
 				curr->info.value.enumerated.names;
+		csize = sizeof(struct gb_audio_control);
+		*w_size += csize;
+		curr = (void *)curr + csize;
 		list_add(&control->list, &module->widget_ctl_list);
 		dev_dbg(module->dev, "%s: control of type %d created\n",
 			widget_kctls[i].name, widget_kctls[i].iface);
@@ -771,7 +776,7 @@ static int gbaudio_tplg_create_widget(struct gbaudio_module_info *module,
 static int gbaudio_tplg_process_kcontrols(struct gbaudio_module_info *module,
 				   struct gb_audio_control *controls)
 {
-	int i, ret;
+	int i, csize, ret;
 	struct snd_kcontrol_new *dapm_kctls;
 	struct gb_audio_control *curr;
 	struct gbaudio_control *control, *_control;
@@ -808,10 +813,12 @@ static int gbaudio_tplg_process_kcontrols(struct gbaudio_module_info *module,
 		if (curr->info.type == GB_AUDIO_CTL_ELEM_TYPE_ENUMERATED)
 			control->texts = (const char * const *)
 				curr->info.value.enumerated.names;
+		csize = sizeof(struct gb_audio_control);
+
 		list_add(&control->list, &module->ctl_list);
 		dev_dbg(module->dev, "%d:%s created of type %d\n", curr->id,
 			curr->name, curr->info.type);
-		curr++;
+		curr = (void *)curr + csize;
 	}
 	module->controls = dapm_kctls;
 
@@ -829,7 +836,7 @@ static int gbaudio_tplg_process_kcontrols(struct gbaudio_module_info *module,
 static int gbaudio_tplg_process_widgets(struct gbaudio_module_info *module,
 				   struct gb_audio_widget *widgets)
 {
-	int i, ret, ncontrols;
+	int i, ret, w_size;
 	struct snd_soc_dapm_widget *dapm_widgets;
 	struct gb_audio_widget *curr;
 	struct gbaudio_widget *widget, *_widget;
@@ -843,7 +850,7 @@ static int gbaudio_tplg_process_widgets(struct gbaudio_module_info *module,
 	curr = widgets;
 	for (i = 0; i < module->num_dapm_widgets; i++) {
 		ret = gbaudio_tplg_create_widget(module, &dapm_widgets[i],
-						 curr);
+						 curr, &w_size);
 		if (ret) {
 			dev_err(module->dev, "%s:%d type not supported\n",
 				curr->name, curr->type);
@@ -859,9 +866,7 @@ static int gbaudio_tplg_process_widgets(struct gbaudio_module_info *module,
 		widget->id = curr->id;
 		widget->name = curr->name;
 		list_add(&widget->list, &module->widget_list);
-		ncontrols = curr->ncontrols;
-		curr++;
-		curr = (void *)curr + ncontrols*sizeof(struct gb_audio_control);
+		curr = (void *)curr + w_size;
 	}
 	module->dapm_widgets = dapm_widgets;
 

commit bb296b48038010dee1c55aa24264f3205ec949fd
Author: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
Date:   Thu Jun 30 18:45:35 2016 +0530

    greybus: added warning message in case of missing widget
    
    Additional warning message added to notify in case above layer tries to
    access widget that is already removed from the list.
    
    Signed-off-by: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
    Reviewed-by: Mark Greer <mark.greer@animalcreek.com>
    Signed-off-by: Alex Elder <elder@linaro.org>

diff --git a/drivers/staging/greybus/audio_topology.c b/drivers/staging/greybus/audio_topology.c
index 1bc987449180..92f2ada60be8 100644
--- a/drivers/staging/greybus/audio_topology.c
+++ b/drivers/staging/greybus/audio_topology.c
@@ -99,6 +99,8 @@ static int gbaudio_map_widgetname(struct gbaudio_module_info *module,
 		if (!strncmp(widget->name, name, NAME_SIZE))
 			return widget->id;
 	}
+	dev_warn(module->dev, "%s: missing in modules widgets list\n", name);
+
 	return -EINVAL;
 }
 

commit 0c15a9e0f3f7174718351fcb1c16be944f3b8a57
Author: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
Date:   Tue Jul 5 17:09:20 2016 -0500

    greybus: audio: topology: Add helper API to map controlid with widget name
    
    This API is used by enumerated controls .get/.set callback functions to
    fetch control id associated with a widget.
    
    Signed-off-by: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
    Reviewed-by: Mark Greer <mark.greer@animalcreek.com>
    Signed-off-by: Alex Elder <elder@linaro.org>

diff --git a/drivers/staging/greybus/audio_topology.c b/drivers/staging/greybus/audio_topology.c
index 1f9e8b6178dd..1bc987449180 100644
--- a/drivers/staging/greybus/audio_topology.c
+++ b/drivers/staging/greybus/audio_topology.c
@@ -77,6 +77,20 @@ static const char *gbaudio_map_controlid(struct gbaudio_module_info *module,
 	return NULL;
 }
 
+static int gbaudio_map_wcontrolname(struct gbaudio_module_info *module,
+					  const char *name)
+{
+	struct gbaudio_control *control;
+
+	list_for_each_entry(control, &module->widget_ctl_list, list) {
+		if (!strncmp(control->wname, name, NAME_SIZE))
+			return control->id;
+	}
+	dev_warn(module->dev, "%s: missing in modules controls list\n", name);
+
+	return -EINVAL;
+}
+
 static int gbaudio_map_widgetname(struct gbaudio_module_info *module,
 					  const char *name)
 {
@@ -652,6 +666,8 @@ static int gbaudio_tplg_create_widget(struct gbaudio_module_info *module,
 		}
 		control->id = curr->id;
 		control->name = curr->name;
+		control->wname = w->name;
+
 		if (curr->info.type == GB_AUDIO_CTL_ELEM_TYPE_ENUMERATED)
 			control->texts = (const char * const *)
 				curr->info.value.enumerated.names;

commit 60fb3405c73ea0bbab942c699496123f9e987c04
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Fri Jun 10 14:59:07 2016 +0530

    greybus: Remove extra blank lines
    
    This patch removes few blank lines across the repository at places where
    two blank lines were present together or when a blank line is present at
    the start or end of a routine.
    
    Note that this doesn't remove most of them from greybus_protocols.h as
    they were added on purpose.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/audio_topology.c b/drivers/staging/greybus/audio_topology.c
index 1e0768670b69..1f9e8b6178dd 100644
--- a/drivers/staging/greybus/audio_topology.c
+++ b/drivers/staging/greybus/audio_topology.c
@@ -872,7 +872,6 @@ static int gbaudio_tplg_process_routes(struct gbaudio_module_info *module,
 	if (!dapm_routes)
 		return -ENOMEM;
 
-
 	module->dapm_routes = dapm_routes;
 	curr = routes;
 

commit c6722ab5d3c3d23021dd32bd1ae569665ee2263b
Author: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
Date:   Fri Jun 10 12:59:11 2016 +0530

    greybus: audio: Ratelimit err messages in bundle, topology driver
    
    Earlier I have shared a patch to rate limit err messages in audio_codec
    driver. However, missed to include suggestion from Mark to do similar
    changes in audio bundle & topology parser as well. Doing it now.
    
    Testing Done: Compile tested
    
    Fixes: 4cb3d109e5fc ("audio: Ratelimit err messages")
    Signed-off-by: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
    Reviewed-by: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/audio_topology.c b/drivers/staging/greybus/audio_topology.c
index dfe120baecad..1e0768670b69 100644
--- a/drivers/staging/greybus/audio_topology.c
+++ b/drivers/staging/greybus/audio_topology.c
@@ -173,8 +173,8 @@ static int gbcodec_mixer_ctl_get(struct snd_kcontrol *kcontrol,
 	ret = gb_audio_gb_get_control(module->mgmt_connection, data->ctl_id,
 				      GB_AUDIO_INVALID_INDEX, &gbvalue);
 	if (ret) {
-		dev_err(codec->dev, "%d:Error in %s for %s\n", ret, __func__,
-			kcontrol->id.name);
+		dev_err_ratelimited(codec->dev, "%d:Error in %s for %s\n", ret,
+				    __func__, kcontrol->id.name);
 		return ret;
 	}
 
@@ -253,8 +253,8 @@ static int gbcodec_mixer_ctl_put(struct snd_kcontrol *kcontrol,
 	ret = gb_audio_gb_set_control(module->mgmt_connection, data->ctl_id,
 				      GB_AUDIO_INVALID_INDEX, &gbvalue);
 	if (ret) {
-		dev_err(codec->dev, "%d:Error in %s for %s\n", ret, __func__,
-			kcontrol->id.name);
+		dev_err_ratelimited(codec->dev, "%d:Error in %s for %s\n", ret,
+				    __func__, kcontrol->id.name);
 	}
 
 	return ret;
@@ -335,8 +335,8 @@ static int gbcodec_mixer_dapm_ctl_get(struct snd_kcontrol *kcontrol,
 	ret = gb_audio_gb_get_control(module->mgmt_connection, data->ctl_id,
 				      GB_AUDIO_INVALID_INDEX, &gbvalue);
 	if (ret) {
-		dev_err(codec->dev, "%d:Error in %s for %s\n", ret, __func__,
-			kcontrol->id.name);
+		dev_err_ratelimited(codec->dev, "%d:Error in %s for %s\n", ret,
+				    __func__, kcontrol->id.name);
 		return ret;
 	}
 	/* update ucontrol */
@@ -393,9 +393,9 @@ static int gbcodec_mixer_dapm_ctl_put(struct snd_kcontrol *kcontrol,
 					      data->ctl_id,
 					      GB_AUDIO_INVALID_INDEX, &gbvalue);
 		if (ret) {
-			dev_err(codec->dev,
-				"%d:Error in %s for %s\n", ret, __func__,
-				kcontrol->id.name);
+			dev_err_ratelimited(codec->dev,
+					    "%d:Error in %s for %s\n", ret,
+					    __func__, kcontrol->id.name);
 		}
 	}
 
@@ -600,8 +600,9 @@ static int gbaudio_widget_event(struct snd_soc_dapm_widget *w,
 		break;
 	}
 	if (ret)
-		dev_err(codec->dev, "%d: widget, event:%d failed:%d\n", wid,
-			event, ret);
+		dev_err_ratelimited(codec->dev,
+				    "%d: widget, event:%d failed:%d\n", wid,
+				    event, ret);
 	return ret;
 }
 

commit 02f1c12cca45ed684a268563919787f06877bef2
Author: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
Date:   Fri Jun 3 17:45:29 2016 +0530

    greybus: audio: Report warning in case module is already removed
    
    Added warning message in find_gb_module(). This will help to identify
    invalid mixer control/widget modification triggered from above layer.
    
    Signed-off-by: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
    Reviewed-by: Mark Greer <mgreer@animalcreek.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/audio_topology.c b/drivers/staging/greybus/audio_topology.c
index e423e6d16a25..dfe120baecad 100644
--- a/drivers/staging/greybus/audio_topology.c
+++ b/drivers/staging/greybus/audio_topology.c
@@ -47,6 +47,8 @@ static struct gbaudio_module_info *find_gb_module(
 		}
 	}
 	mutex_unlock(&codec->lock);
+	dev_warn(codec->dev, "%s: module#%d missing in codec list\n", name,
+		 dev_id);
 	return NULL;
 }
 

commit 89de9a06213240b9266f9f368a867cf90d0024bf
Author: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
Date:   Wed Mar 30 13:23:56 2016 +0530

    greybus: audio: Update device type based on widget types
    
    Device type info shared to above HAL is currently hard coded
    to SPK only. Actual device type is identifed while parsing
    widget types from topology FW shared by codec module.
    
    Signed-off-by: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
    Reviewed-by: Mark Greer <mgreer@animalcreek.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/audio_topology.c b/drivers/staging/greybus/audio_topology.c
index 79161c1b74ce..e423e6d16a25 100644
--- a/drivers/staging/greybus/audio_topology.c
+++ b/drivers/staging/greybus/audio_topology.c
@@ -665,15 +665,20 @@ static int gbaudio_tplg_create_widget(struct gbaudio_module_info *module,
 	case snd_soc_dapm_spk:
 		*dw = (struct snd_soc_dapm_widget)
 			SND_SOC_DAPM_SPK(w->name, gbcodec_event_spk);
+		module->op_devices |= GBAUDIO_DEVICE_OUT_SPEAKER;
 		break;
 	case snd_soc_dapm_hp:
 		*dw = (struct snd_soc_dapm_widget)
 			SND_SOC_DAPM_HP(w->name, gbcodec_event_hp);
 		module->num_jacks++;
+		module->op_devices |= (GBAUDIO_DEVICE_OUT_WIRED_HEADSET
+					| GBAUDIO_DEVICE_OUT_WIRED_HEADPHONE);
+		module->ip_devices |= GBAUDIO_DEVICE_IN_WIRED_HEADSET;
 		break;
 	case snd_soc_dapm_mic:
 		*dw = (struct snd_soc_dapm_widget)
 			SND_SOC_DAPM_MIC(w->name, gbcodec_event_int_mic);
+		module->ip_devices |= GBAUDIO_DEVICE_IN_BUILTIN_MIC;
 		break;
 	case snd_soc_dapm_output:
 		*dw = (struct snd_soc_dapm_widget)SND_SOC_DAPM_OUTPUT(w->name);

commit 64a7e2cceb75ccabaec713944a95511605751b29
Author: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
Date:   Tue Mar 29 16:32:36 2016 +0530

    greybus: audio: Added jack support to audio module
    
    Register jack with ASoC sound card in case audio module
    populates it via codec FW. Currently, only a single jack
    with 4 buttons can be registered for each module.
    
    Signed-off-by: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
    Reviewed-by: Mark Greer <mgreer@animalcreek.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/audio_topology.c b/drivers/staging/greybus/audio_topology.c
index 9e36fb27faf8..79161c1b74ce 100644
--- a/drivers/staging/greybus/audio_topology.c
+++ b/drivers/staging/greybus/audio_topology.c
@@ -669,6 +669,7 @@ static int gbaudio_tplg_create_widget(struct gbaudio_module_info *module,
 	case snd_soc_dapm_hp:
 		*dw = (struct snd_soc_dapm_widget)
 			SND_SOC_DAPM_HP(w->name, gbcodec_event_hp);
+		module->num_jacks++;
 		break;
 	case snd_soc_dapm_mic:
 		*dw = (struct snd_soc_dapm_widget)

commit 6da549ec851117293a07e64f97170f7dc9d55578
Author: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
Date:   Tue Mar 29 16:32:35 2016 +0530

    greybus: audio: Fix widget pointer update during control parsing
    
    widget pointer was incorrectly modfied while parsing kcontrol
    
    Signed-off-by: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
    Reviewed-by: Mark Greer <mgreer@animalcreek.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/audio_topology.c b/drivers/staging/greybus/audio_topology.c
index 4901348a2ada..9e36fb27faf8 100644
--- a/drivers/staging/greybus/audio_topology.c
+++ b/drivers/staging/greybus/audio_topology.c
@@ -834,7 +834,7 @@ static int gbaudio_tplg_process_widgets(struct gbaudio_module_info *module,
 		list_add(&widget->list, &module->widget_list);
 		ncontrols = curr->ncontrols;
 		curr++;
-		curr += ncontrols * sizeof(struct gb_audio_control);
+		curr = (void *)curr + ncontrols*sizeof(struct gb_audio_control);
 	}
 	module->dapm_widgets = dapm_widgets;
 

commit 6dd67645f22cfeb55a32e9a08c92deb297d06935
Author: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
Date:   Tue Mar 29 23:31:41 2016 +0530

    greybus: audio: Use single codec driver registration
    
    We have single I2S port via APB1 for communication with all
    audio modules. Thus, we should register single codec driver
    and manage all individual audio modules internally within
    this driver.
    
    Signed-off-by: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
    Reviewed-by: Mark Greer <mark.greer@animalcreek.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/audio_topology.c b/drivers/staging/greybus/audio_topology.c
index 1651c14c87ba..4901348a2ada 100644
--- a/drivers/staging/greybus/audio_topology.c
+++ b/drivers/staging/greybus/audio_topology.c
@@ -25,7 +25,32 @@ struct gbaudio_ctl_pvt {
 	struct gb_audio_ctl_elem_info *info;
 };
 
-static const char *gbaudio_map_controlid(struct gbaudio_codec_info *gbcodec,
+static struct gbaudio_module_info *find_gb_module(
+					struct gbaudio_codec_info *codec,
+					char const *name)
+{
+	int dev_id, ret;
+	char begin[NAME_SIZE];
+	struct gbaudio_module_info *module;
+
+	if (!name)
+		return NULL;
+
+	ret = sscanf(name, "%s %d", begin, &dev_id);
+	dev_dbg(codec->dev, "%s:Find module#%d\n", __func__, dev_id);
+
+	mutex_lock(&codec->lock);
+	list_for_each_entry(module, &codec->module_list, list) {
+		if (module->dev_id == dev_id) {
+			mutex_unlock(&codec->lock);
+			return module;
+		}
+	}
+	mutex_unlock(&codec->lock);
+	return NULL;
+}
+
+static const char *gbaudio_map_controlid(struct gbaudio_module_info *module,
 					   __u8 control_id, __u8 index)
 {
 	struct gbaudio_control *control;
@@ -33,14 +58,14 @@ static const char *gbaudio_map_controlid(struct gbaudio_codec_info *gbcodec,
 	if (control_id == GBAUDIO_INVALID_ID)
 		return NULL;
 
-	list_for_each_entry(control, &gbcodec->codec_ctl_list, list) {
+	list_for_each_entry(control, &module->ctl_list, list) {
 		if (control->id == control_id) {
 			if (index == GBAUDIO_INVALID_ID)
 				return control->name;
 			return control->texts[index];
 		}
 	}
-	list_for_each_entry(control, &gbcodec->widget_ctl_list, list) {
+	list_for_each_entry(control, &module->widget_ctl_list, list) {
 		if (control->id == control_id) {
 			if (index == GBAUDIO_INVALID_ID)
 				return control->name;
@@ -50,34 +75,23 @@ static const char *gbaudio_map_controlid(struct gbaudio_codec_info *gbcodec,
 	return NULL;
 }
 
-static int gbaudio_map_widgetname(struct gbaudio_codec_info *gbcodec,
+static int gbaudio_map_widgetname(struct gbaudio_module_info *module,
 					  const char *name)
 {
 	struct gbaudio_widget *widget;
-	char widget_name[NAME_SIZE];
-	char prefix_name[NAME_SIZE];
-
-	snprintf(prefix_name, NAME_SIZE, "GB %d ", gbcodec->dev_id);
-	if (strncmp(name, prefix_name, strlen(prefix_name)))
-		return -EINVAL;
-
-	strlcpy(widget_name, name+strlen(prefix_name), NAME_SIZE);
-	dev_dbg(gbcodec->dev, "widget_name:%s, truncated widget_name:%s\n",
-		name, widget_name);
-
-	list_for_each_entry(widget, &gbcodec->widget_list, list) {
-		if (!strncmp(widget->name, widget_name, NAME_SIZE))
+	list_for_each_entry(widget, &module->widget_list, list) {
+		if (!strncmp(widget->name, name, NAME_SIZE))
 			return widget->id;
 	}
 	return -EINVAL;
 }
 
-static const char *gbaudio_map_widgetid(struct gbaudio_codec_info *gbcodec,
+static const char *gbaudio_map_widgetid(struct gbaudio_module_info *module,
 					  __u8 widget_id)
 {
 	struct gbaudio_widget *widget;
 
-	list_for_each_entry(widget, &gbcodec->widget_list, list) {
+	list_for_each_entry(widget, &module->widget_list, list) {
 		if (widget->id == widget_id)
 			return widget->name;
 	}
@@ -91,14 +105,16 @@ static int gbcodec_mixer_ctl_info(struct snd_kcontrol *kcontrol,
 	const char *name;
 	struct gbaudio_ctl_pvt *data;
 	struct gb_audio_ctl_elem_info *info;
+	struct gbaudio_module_info *module;
 	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
 	struct gbaudio_codec_info *gbcodec = snd_soc_codec_get_drvdata(codec);
 
+	dev_dbg(codec->dev, "Entered %s:%s\n", __func__, kcontrol->id.name);
 	data = (struct gbaudio_ctl_pvt *)kcontrol->private_value;
 	info = (struct gb_audio_ctl_elem_info *)data->info;
 
 	if (!info) {
-		dev_err(gbcodec->dev, "NULL info for %s\n", uinfo->id.name);
+		dev_err(module->dev, "NULL info for %s\n", uinfo->id.name);
 		return -EINVAL;
 	}
 
@@ -118,7 +134,10 @@ static int gbcodec_mixer_ctl_info(struct snd_kcontrol *kcontrol,
 		uinfo->value.enumerated.items = max;
 		if (uinfo->value.enumerated.item > max - 1)
 			uinfo->value.enumerated.item = max - 1;
-		name = gbaudio_map_controlid(gbcodec, data->ctl_id,
+		module = find_gb_module(gbcodec, kcontrol->id.name);
+		if (!module)
+			return -EINVAL;
+		name = gbaudio_map_controlid(module, data->ctl_id,
 					     uinfo->value.enumerated.item);
 		strlcpy(uinfo->value.enumerated.name, name, NAME_SIZE);
 		break;
@@ -137,16 +156,19 @@ static int gbcodec_mixer_ctl_get(struct snd_kcontrol *kcontrol,
 	struct gb_audio_ctl_elem_info *info;
 	struct gbaudio_ctl_pvt *data;
 	struct gb_audio_ctl_elem_value gbvalue;
+	struct gbaudio_module_info *module;
 	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
 	struct gbaudio_codec_info *gb = snd_soc_codec_get_drvdata(codec);
 
-	if (!atomic_read(&gb->is_connected))
-		return -ENODEV;
+	dev_dbg(codec->dev, "Entered %s:%s\n", __func__, kcontrol->id.name);
+	module = find_gb_module(gb, kcontrol->id.name);
+	if (!module)
+		return -EINVAL;
 
 	data = (struct gbaudio_ctl_pvt *)kcontrol->private_value;
 	info = (struct gb_audio_ctl_elem_info *)data->info;
 
-	ret = gb_audio_gb_get_control(gb->mgmt_connection, data->ctl_id,
+	ret = gb_audio_gb_get_control(module->mgmt_connection, data->ctl_id,
 				      GB_AUDIO_INVALID_INDEX, &gbvalue);
 	if (ret) {
 		dev_err(codec->dev, "%d:Error in %s for %s\n", ret, __func__,
@@ -187,11 +209,14 @@ static int gbcodec_mixer_ctl_put(struct snd_kcontrol *kcontrol,
 	struct gb_audio_ctl_elem_info *info;
 	struct gbaudio_ctl_pvt *data;
 	struct gb_audio_ctl_elem_value gbvalue;
+	struct gbaudio_module_info *module;
 	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
 	struct gbaudio_codec_info *gb = snd_soc_codec_get_drvdata(codec);
 
-	if (!atomic_read(&gb->is_connected))
-		return -ENODEV;
+	dev_dbg(codec->dev, "Entered %s:%s\n", __func__, kcontrol->id.name);
+	module = find_gb_module(gb, kcontrol->id.name);
+	if (!module)
+		return -EINVAL;
 
 	data = (struct gbaudio_ctl_pvt *)kcontrol->private_value;
 	info = (struct gb_audio_ctl_elem_info *)data->info;
@@ -223,7 +248,7 @@ static int gbcodec_mixer_ctl_put(struct snd_kcontrol *kcontrol,
 	if (ret)
 		return ret;
 
-	ret = gb_audio_gb_set_control(gb->mgmt_connection, data->ctl_id,
+	ret = gb_audio_gb_set_control(module->mgmt_connection, data->ctl_id,
 				      GB_AUDIO_INVALID_INDEX, &gbvalue);
 	if (ret) {
 		dev_err(codec->dev, "%d:Error in %s for %s\n", ret, __func__,
@@ -250,7 +275,11 @@ static int gbcodec_mixer_dapm_ctl_info(struct snd_kcontrol *kcontrol,
 	int platform_max, platform_min;
 	struct gbaudio_ctl_pvt *data;
 	struct gb_audio_ctl_elem_info *info;
+	struct snd_soc_dapm_widget_list *wlist = snd_kcontrol_chip(kcontrol);
+	struct snd_soc_dapm_widget *widget = wlist->widgets[0];
+	struct snd_soc_codec *codec = widget->codec;
 
+	dev_dbg(codec->dev, "Entered %s:%s\n", __func__, kcontrol->id.name);
 	data = (struct gbaudio_ctl_pvt *)kcontrol->private_value;
 	info = (struct gb_audio_ctl_elem_info *)data->info;
 
@@ -282,13 +311,16 @@ static int gbcodec_mixer_dapm_ctl_get(struct snd_kcontrol *kcontrol,
 	struct gb_audio_ctl_elem_info *info;
 	struct gbaudio_ctl_pvt *data;
 	struct gb_audio_ctl_elem_value gbvalue;
+	struct gbaudio_module_info *module;
 	struct snd_soc_dapm_widget_list *wlist = snd_kcontrol_chip(kcontrol);
 	struct snd_soc_dapm_widget *widget = wlist->widgets[0];
 	struct snd_soc_codec *codec = widget->codec;
 	struct gbaudio_codec_info *gb = snd_soc_codec_get_drvdata(codec);
 
-	if (!atomic_read(&gb->is_connected))
-		return -ENODEV;
+	dev_dbg(codec->dev, "Entered %s:%s\n", __func__, kcontrol->id.name);
+	module = find_gb_module(gb, kcontrol->id.name);
+	if (!module)
+		return -EINVAL;
 
 	data = (struct gbaudio_ctl_pvt *)kcontrol->private_value;
 	info = (struct gb_audio_ctl_elem_info *)data->info;
@@ -298,7 +330,7 @@ static int gbcodec_mixer_dapm_ctl_get(struct snd_kcontrol *kcontrol,
 			 "GB: Control '%s' is stereo, which is not supported\n",
 			 kcontrol->id.name);
 
-	ret = gb_audio_gb_get_control(gb->mgmt_connection, data->ctl_id,
+	ret = gb_audio_gb_get_control(module->mgmt_connection, data->ctl_id,
 				      GB_AUDIO_INVALID_INDEX, &gbvalue);
 	if (ret) {
 		dev_err(codec->dev, "%d:Error in %s for %s\n", ret, __func__,
@@ -319,13 +351,16 @@ static int gbcodec_mixer_dapm_ctl_put(struct snd_kcontrol *kcontrol,
 	struct gb_audio_ctl_elem_info *info;
 	struct gbaudio_ctl_pvt *data;
 	struct gb_audio_ctl_elem_value gbvalue;
+	struct gbaudio_module_info *module;
 	struct snd_soc_dapm_widget_list *wlist = snd_kcontrol_chip(kcontrol);
 	struct snd_soc_dapm_widget *widget = wlist->widgets[0];
 	struct snd_soc_codec *codec = widget->codec;
 	struct gbaudio_codec_info *gb = snd_soc_codec_get_drvdata(codec);
 
-	if (!atomic_read(&gb->is_connected))
-		return -ENODEV;
+	dev_dbg(codec->dev, "Entered %s:%s\n", __func__, kcontrol->id.name);
+	module = find_gb_module(gb, kcontrol->id.name);
+	if (!module)
+		return -EINVAL;
 
 	data = (struct gbaudio_ctl_pvt *)kcontrol->private_value;
 	info = (struct gb_audio_ctl_elem_info *)data->info;
@@ -352,7 +387,7 @@ static int gbcodec_mixer_dapm_ctl_put(struct snd_kcontrol *kcontrol,
 		}
 		gbvalue.value.integer_value[0] =
 			ucontrol->value.integer.value[0];
-		ret = gb_audio_gb_set_control(gb->mgmt_connection,
+		ret = gb_audio_gb_set_control(module->mgmt_connection,
 					      data->ctl_id,
 					      GB_AUDIO_INVALID_INDEX, &gbvalue);
 		if (ret) {
@@ -420,7 +455,7 @@ static int gbaudio_validate_kcontrol_count(struct gb_audio_widget *w)
 	return ret;
 }
 
-static int gbaudio_tplg_create_kcontrol(struct gbaudio_codec_info *gb,
+static int gbaudio_tplg_create_kcontrol(struct gbaudio_module_info *gb,
 					struct snd_kcontrol_new *kctl,
 					struct gb_audio_control *ctl)
 {
@@ -452,23 +487,23 @@ static int gbaudio_tplg_create_kcontrol(struct gbaudio_codec_info *gb,
 static const char * const gbtexts[] = {"Stereo", "Left", "Right"};
 
 static const SOC_ENUM_SINGLE_DECL(
-	gbcodec_apb1_rx_enum, GBCODEC_APB1_MUX_REG, 0, gbtexts);
+	module_apb1_rx_enum, GBCODEC_APB1_MUX_REG, 0, gbtexts);
 
 static const SOC_ENUM_SINGLE_DECL(
-	gbcodec_mic_enum, GBCODEC_APB1_MUX_REG, 4, gbtexts);
+	module_mic_enum, GBCODEC_APB1_MUX_REG, 4, gbtexts);
 
-static int gbaudio_tplg_create_enum_ctl(struct gbaudio_codec_info *gb,
+static int gbaudio_tplg_create_enum_ctl(struct gbaudio_module_info *gb,
 					struct snd_kcontrol_new *kctl,
 					struct gb_audio_control *ctl)
 {
 	switch (ctl->id) {
 	case 8:
 		*kctl = (struct snd_kcontrol_new)
-			SOC_DAPM_ENUM(ctl->name, gbcodec_apb1_rx_enum);
+			SOC_DAPM_ENUM(ctl->name, module_apb1_rx_enum);
 		break;
 	case 9:
 		*kctl = (struct snd_kcontrol_new)
-			SOC_DAPM_ENUM(ctl->name, gbcodec_mic_enum);
+			SOC_DAPM_ENUM(ctl->name, module_mic_enum);
 		break;
 	default:
 		return -EINVAL;
@@ -477,7 +512,7 @@ static int gbaudio_tplg_create_enum_ctl(struct gbaudio_codec_info *gb,
 	return 0;
 }
 
-static int gbaudio_tplg_create_mixer_ctl(struct gbaudio_codec_info *gb,
+static int gbaudio_tplg_create_mixer_ctl(struct gbaudio_module_info *gb,
 					     struct snd_kcontrol_new *kctl,
 					     struct gb_audio_control *ctl)
 {
@@ -498,7 +533,7 @@ static int gbaudio_tplg_create_mixer_ctl(struct gbaudio_codec_info *gb,
 	return 0;
 }
 
-static int gbaudio_tplg_create_wcontrol(struct gbaudio_codec_info *gb,
+static int gbaudio_tplg_create_wcontrol(struct gbaudio_module_info *gb,
 					     struct snd_kcontrol_new *kctl,
 					     struct gb_audio_control *ctl)
 {
@@ -532,11 +567,17 @@ static int gbaudio_widget_event(struct snd_soc_dapm_widget *w,
 	int ret;
 	struct snd_soc_codec *codec = w->codec;
 	struct gbaudio_codec_info *gbcodec = snd_soc_codec_get_drvdata(codec);
+	struct gbaudio_module_info *module;
 
 	dev_dbg(codec->dev, "%s %s %d\n", __func__, w->name, event);
 
+	/* Find relevant module */
+	module = find_gb_module(gbcodec, w->name);
+	if (!module)
+		return -EINVAL;
+
 	/* map name to widget id */
-	wid = gbaudio_map_widgetname(gbcodec, w->name);
+	wid = gbaudio_map_widgetname(module, w->name);
 	if (wid < 0) {
 		dev_err(codec->dev, "Invalid widget name:%s\n", w->name);
 		return -EINVAL;
@@ -544,10 +585,16 @@ static int gbaudio_widget_event(struct snd_soc_dapm_widget *w,
 
 	switch (event) {
 	case SND_SOC_DAPM_PRE_PMU:
-		ret = gb_audio_gb_enable_widget(gbcodec->mgmt_connection, wid);
+		ret = gb_audio_gb_enable_widget(module->mgmt_connection, wid);
+		if (!ret)
+			ret = gbaudio_module_update(gbcodec, w->name, module,
+						    1);
 		break;
 	case SND_SOC_DAPM_POST_PMD:
-		ret = gb_audio_gb_disable_widget(gbcodec->mgmt_connection, wid);
+		ret = gb_audio_gb_disable_widget(module->mgmt_connection, wid);
+		if (!ret)
+			ret = gbaudio_module_update(gbcodec, w->name, module,
+						    0);
 		break;
 	}
 	if (ret)
@@ -556,7 +603,7 @@ static int gbaudio_widget_event(struct snd_soc_dapm_widget *w,
 	return ret;
 }
 
-static int gbaudio_tplg_create_widget(struct gbaudio_codec_info *gbcodec,
+static int gbaudio_tplg_create_widget(struct gbaudio_module_info *module,
 				      struct snd_soc_dapm_widget *dw,
 				      struct gb_audio_widget *w)
 {
@@ -565,10 +612,11 @@ static int gbaudio_tplg_create_widget(struct gbaudio_codec_info *gbcodec,
 	struct gb_audio_control *curr;
 	struct gbaudio_control *control, *_control;
 	size_t size;
+	char temp_name[NAME_SIZE];
 
 	ret = gbaudio_validate_kcontrol_count(w);
 	if (ret) {
-		dev_err(gbcodec->dev, "Inavlid kcontrol count=%d for %s\n",
+		dev_err(module->dev, "Inavlid kcontrol count=%d for %s\n",
 			w->ncontrols, w->name);
 		return ret;
 	}
@@ -576,7 +624,7 @@ static int gbaudio_tplg_create_widget(struct gbaudio_codec_info *gbcodec,
 	/* allocate memory for kcontrol */
 	if (w->ncontrols) {
 		size = sizeof(struct snd_kcontrol_new) * w->ncontrols;
-		widget_kctls = devm_kzalloc(gbcodec->dev, size, GFP_KERNEL);
+		widget_kctls = devm_kzalloc(module->dev, size, GFP_KERNEL);
 		if (!widget_kctls)
 			return -ENOMEM;
 	}
@@ -584,15 +632,15 @@ static int gbaudio_tplg_create_widget(struct gbaudio_codec_info *gbcodec,
 	/* create relevant kcontrols */
 	for (i = 0; i < w->ncontrols; i++) {
 		curr = &w->ctl[i];
-		ret = gbaudio_tplg_create_wcontrol(gbcodec, &widget_kctls[i],
+		ret = gbaudio_tplg_create_wcontrol(module, &widget_kctls[i],
 						   curr);
 		if (ret) {
-			dev_err(gbcodec->dev,
+			dev_err(module->dev,
 				"%s:%d type widget_ctl not supported\n",
 				curr->name, curr->iface);
 			goto error;
 		}
-		control = devm_kzalloc(gbcodec->dev,
+		control = devm_kzalloc(module->dev,
 				       sizeof(struct gbaudio_control),
 				       GFP_KERNEL);
 		if (!control) {
@@ -604,11 +652,15 @@ static int gbaudio_tplg_create_widget(struct gbaudio_codec_info *gbcodec,
 		if (curr->info.type == GB_AUDIO_CTL_ELEM_TYPE_ENUMERATED)
 			control->texts = (const char * const *)
 				curr->info.value.enumerated.names;
-		list_add(&control->list, &gbcodec->widget_ctl_list);
-		dev_dbg(gbcodec->dev, "%s: control of type %d created\n",
+		list_add(&control->list, &module->widget_ctl_list);
+		dev_dbg(module->dev, "%s: control of type %d created\n",
 			widget_kctls[i].name, widget_kctls[i].iface);
 	}
 
+	/* Prefix dev_id to widget control_name */
+	strlcpy(temp_name, w->name, NAME_SIZE);
+	snprintf(w->name, NAME_SIZE, "GB %d %s", module->dev_id, temp_name);
+
 	switch (w->type) {
 	case snd_soc_dapm_spk:
 		*dw = (struct snd_soc_dapm_widget)
@@ -677,45 +729,19 @@ static int gbaudio_tplg_create_widget(struct gbaudio_codec_info *gbcodec,
 		goto error;
 	}
 
-	dev_dbg(gbcodec->dev, "%s: widget of type %d created\n", dw->name,
+	dev_dbg(module->dev, "%s: widget of type %d created\n", dw->name,
 		dw->id);
 	return 0;
 error:
-	list_for_each_entry_safe(control, _control, &gbcodec->widget_ctl_list,
+	list_for_each_entry_safe(control, _control, &module->widget_ctl_list,
 				 list) {
 		list_del(&control->list);
-		devm_kfree(gbcodec->dev, control);
+		devm_kfree(module->dev, control);
 	}
 	return ret;
 }
 
-static int gbaudio_tplg_create_dai(struct gbaudio_codec_info *gbcodec,
-				   struct snd_soc_dai_driver *gb_dai,
-				   struct gb_audio_dai *dai)
-{
-	/*
-	 * do not update name here,
-	 * append dev_id before assigning it here
-	 */
-
-	gb_dai->playback.stream_name = dai->playback.stream_name;
-	gb_dai->playback.channels_min = dai->playback.chan_min;
-	gb_dai->playback.channels_max = dai->playback.chan_max;
-	gb_dai->playback.formats = dai->playback.formats;
-	gb_dai->playback.rates = dai->playback.rates;
-	gb_dai->playback.sig_bits = dai->playback.sig_bits;
-
-	gb_dai->capture.stream_name = dai->capture.stream_name;
-	gb_dai->capture.channels_min = dai->capture.chan_min;
-	gb_dai->capture.channels_max = dai->capture.chan_max;
-	gb_dai->capture.formats = dai->capture.formats;
-	gb_dai->capture.rates = dai->capture.rates;
-	gb_dai->capture.sig_bits = dai->capture.sig_bits;
-
-	return 0;
-}
-
-static int gbaudio_tplg_process_kcontrols(struct gbaudio_codec_info *gbcodec,
+static int gbaudio_tplg_process_kcontrols(struct gbaudio_module_info *module,
 				   struct gb_audio_control *controls)
 {
 	int i, ret;
@@ -723,22 +749,23 @@ static int gbaudio_tplg_process_kcontrols(struct gbaudio_codec_info *gbcodec,
 	struct gb_audio_control *curr;
 	struct gbaudio_control *control, *_control;
 	size_t size;
+	char temp_name[NAME_SIZE];
 
-	size = sizeof(struct snd_kcontrol_new) * gbcodec->num_kcontrols;
-	dapm_kctls = devm_kzalloc(gbcodec->dev, size, GFP_KERNEL);
+	size = sizeof(struct snd_kcontrol_new) * module->num_controls;
+	dapm_kctls = devm_kzalloc(module->dev, size, GFP_KERNEL);
 	if (!dapm_kctls)
 		return -ENOMEM;
 
 	curr = controls;
-	for (i = 0; i < gbcodec->num_kcontrols; i++) {
-		ret = gbaudio_tplg_create_kcontrol(gbcodec, &dapm_kctls[i],
+	for (i = 0; i < module->num_controls; i++) {
+		ret = gbaudio_tplg_create_kcontrol(module, &dapm_kctls[i],
 						   curr);
 		if (ret) {
-			dev_err(gbcodec->dev, "%s:%d type not supported\n",
+			dev_err(module->dev, "%s:%d type not supported\n",
 				curr->name, curr->iface);
 			goto error;
 		}
-		control = devm_kzalloc(gbcodec->dev, sizeof(struct
+		control = devm_kzalloc(module->dev, sizeof(struct
 							   gbaudio_control),
 				      GFP_KERNEL);
 		if (!control) {
@@ -746,29 +773,33 @@ static int gbaudio_tplg_process_kcontrols(struct gbaudio_codec_info *gbcodec,
 			goto error;
 		}
 		control->id = curr->id;
+		/* Prefix dev_id to widget_name */
+		strlcpy(temp_name, curr->name, NAME_SIZE);
+		snprintf(curr->name, NAME_SIZE, "GB %d %s", module->dev_id,
+			 temp_name);
 		control->name = curr->name;
 		if (curr->info.type == GB_AUDIO_CTL_ELEM_TYPE_ENUMERATED)
 			control->texts = (const char * const *)
 				curr->info.value.enumerated.names;
-		list_add(&control->list, &gbcodec->codec_ctl_list);
-		dev_dbg(gbcodec->dev, "%d:%s created of type %d\n", curr->id,
+		list_add(&control->list, &module->ctl_list);
+		dev_dbg(module->dev, "%d:%s created of type %d\n", curr->id,
 			curr->name, curr->info.type);
 		curr++;
 	}
-	gbcodec->kctls = dapm_kctls;
+	module->controls = dapm_kctls;
 
 	return 0;
 error:
-	list_for_each_entry_safe(control, _control, &gbcodec->codec_ctl_list,
+	list_for_each_entry_safe(control, _control, &module->ctl_list,
 				 list) {
 		list_del(&control->list);
-		devm_kfree(gbcodec->dev, control);
+		devm_kfree(module->dev, control);
 	}
-	devm_kfree(gbcodec->dev, dapm_kctls);
+	devm_kfree(module->dev, dapm_kctls);
 	return ret;
 }
 
-static int gbaudio_tplg_process_widgets(struct gbaudio_codec_info *gbcodec,
+static int gbaudio_tplg_process_widgets(struct gbaudio_module_info *module,
 				   struct gb_audio_widget *widgets)
 {
 	int i, ret, ncontrols;
@@ -777,21 +808,21 @@ static int gbaudio_tplg_process_widgets(struct gbaudio_codec_info *gbcodec,
 	struct gbaudio_widget *widget, *_widget;
 	size_t size;
 
-	size = sizeof(struct snd_soc_dapm_widget) * gbcodec->num_dapm_widgets;
-	dapm_widgets = devm_kzalloc(gbcodec->dev, size, GFP_KERNEL);
+	size = sizeof(struct snd_soc_dapm_widget) * module->num_dapm_widgets;
+	dapm_widgets = devm_kzalloc(module->dev, size, GFP_KERNEL);
 	if (!dapm_widgets)
 		return -ENOMEM;
 
 	curr = widgets;
-	for (i = 0; i < gbcodec->num_dapm_widgets; i++) {
-		ret = gbaudio_tplg_create_widget(gbcodec, &dapm_widgets[i],
+	for (i = 0; i < module->num_dapm_widgets; i++) {
+		ret = gbaudio_tplg_create_widget(module, &dapm_widgets[i],
 						 curr);
 		if (ret) {
-			dev_err(gbcodec->dev, "%s:%d type not supported\n",
+			dev_err(module->dev, "%s:%d type not supported\n",
 				curr->name, curr->type);
 			goto error;
 		}
-		widget = devm_kzalloc(gbcodec->dev, sizeof(struct
+		widget = devm_kzalloc(module->dev, sizeof(struct
 							   gbaudio_widget),
 				      GFP_KERNEL);
 		if (!widget) {
@@ -800,69 +831,26 @@ static int gbaudio_tplg_process_widgets(struct gbaudio_codec_info *gbcodec,
 		}
 		widget->id = curr->id;
 		widget->name = curr->name;
-		list_add(&widget->list, &gbcodec->widget_list);
+		list_add(&widget->list, &module->widget_list);
 		ncontrols = curr->ncontrols;
 		curr++;
 		curr += ncontrols * sizeof(struct gb_audio_control);
 	}
-	gbcodec->widgets = dapm_widgets;
+	module->dapm_widgets = dapm_widgets;
 
 	return 0;
 
 error:
-	list_for_each_entry_safe(widget, _widget, &gbcodec->widget_list,
+	list_for_each_entry_safe(widget, _widget, &module->widget_list,
 				 list) {
 		list_del(&widget->list);
-		devm_kfree(gbcodec->dev, widget);
-	}
-	devm_kfree(gbcodec->dev, dapm_widgets);
-	return ret;
-}
-
-static int gbaudio_tplg_process_dais(struct gbaudio_codec_info *gbcodec,
-				   struct gb_audio_dai *dais)
-{
-	int i, ret;
-	struct snd_soc_dai_driver *gb_dais;
-	struct gb_audio_dai *curr;
-	size_t size;
-	char dai_name[NAME_SIZE];
-	struct gbaudio_dai *dai;
-
-	size = sizeof(struct snd_soc_dai_driver) * gbcodec->num_dais;
-	gb_dais = devm_kzalloc(gbcodec->dev, size, GFP_KERNEL);
-	if (!gb_dais)
-		return -ENOMEM;
-
-	curr = dais;
-	for (i = 0; i < gbcodec->num_dais; i++) {
-		ret = gbaudio_tplg_create_dai(gbcodec, &gb_dais[i], curr);
-		if (ret) {
-			dev_err(gbcodec->dev, "%s failed to create\n",
-				curr->name);
-			goto error;
-		}
-		/* append dev_id to dai_name */
-		snprintf(dai_name, NAME_SIZE, "%s.%d", curr->name,
-			 gbcodec->dev_id);
-		dai = gbaudio_find_dai(gbcodec, curr->data_cport, NULL);
-		if (!dai)
-			goto error;
-		strlcpy(dai->name, dai_name, NAME_SIZE);
-		dev_dbg(gbcodec->dev, "%s:DAI added\n", dai->name);
-		gb_dais[i].name = dai->name;
-		curr++;
+		devm_kfree(module->dev, widget);
 	}
-	gbcodec->dais = gb_dais;
-
-	return 0;
-
-error:
-	devm_kfree(gbcodec->dev, gb_dais);
+	devm_kfree(module->dev, dapm_widgets);
 	return ret;
 }
 
-static int gbaudio_tplg_process_routes(struct gbaudio_codec_info *gbcodec,
+static int gbaudio_tplg_process_routes(struct gbaudio_module_info *module,
 				   struct gb_audio_route *routes)
 {
 	int i, ret;
@@ -870,47 +858,47 @@ static int gbaudio_tplg_process_routes(struct gbaudio_codec_info *gbcodec,
 	struct gb_audio_route *curr;
 	size_t size;
 
-	size = sizeof(struct snd_soc_dapm_route) * gbcodec->num_dapm_routes;
-	dapm_routes = devm_kzalloc(gbcodec->dev, size, GFP_KERNEL);
+	size = sizeof(struct snd_soc_dapm_route) * module->num_dapm_routes;
+	dapm_routes = devm_kzalloc(module->dev, size, GFP_KERNEL);
 	if (!dapm_routes)
 		return -ENOMEM;
 
 
-	gbcodec->routes = dapm_routes;
+	module->dapm_routes = dapm_routes;
 	curr = routes;
 
-	for (i = 0; i < gbcodec->num_dapm_routes; i++) {
+	for (i = 0; i < module->num_dapm_routes; i++) {
 		dapm_routes->sink =
-			gbaudio_map_widgetid(gbcodec, curr->destination_id);
+			gbaudio_map_widgetid(module, curr->destination_id);
 		if (!dapm_routes->sink) {
-			dev_err(gbcodec->dev, "%d:%d:%d:%d - Invalid sink\n",
+			dev_err(module->dev, "%d:%d:%d:%d - Invalid sink\n",
 				curr->source_id, curr->destination_id,
 				curr->control_id, curr->index);
 			ret = -EINVAL;
 			goto error;
 		}
 		dapm_routes->source =
-			gbaudio_map_widgetid(gbcodec, curr->source_id);
+			gbaudio_map_widgetid(module, curr->source_id);
 		if (!dapm_routes->source) {
-			dev_err(gbcodec->dev, "%d:%d:%d:%d - Invalid source\n",
+			dev_err(module->dev, "%d:%d:%d:%d - Invalid source\n",
 				curr->source_id, curr->destination_id,
 				curr->control_id, curr->index);
 			ret = -EINVAL;
 			goto error;
 		}
 		dapm_routes->control =
-			gbaudio_map_controlid(gbcodec,
+			gbaudio_map_controlid(module,
 						      curr->control_id,
 						      curr->index);
 		if ((curr->control_id !=  GBAUDIO_INVALID_ID) &&
 		    !dapm_routes->control) {
-			dev_err(gbcodec->dev, "%d:%d:%d:%d - Invalid control\n",
+			dev_err(module->dev, "%d:%d:%d:%d - Invalid control\n",
 				curr->source_id, curr->destination_id,
 				curr->control_id, curr->index);
 			ret = -EINVAL;
 			goto error;
 		}
-		dev_dbg(gbcodec->dev, "Route {%s, %s, %s}\n", dapm_routes->sink,
+		dev_dbg(module->dev, "Route {%s, %s, %s}\n", dapm_routes->sink,
 			(dapm_routes->control) ? dapm_routes->control:"NULL",
 			dapm_routes->source);
 		dapm_routes++;
@@ -920,41 +908,39 @@ static int gbaudio_tplg_process_routes(struct gbaudio_codec_info *gbcodec,
 	return 0;
 
 error:
-	devm_kfree(gbcodec->dev, dapm_routes);
+	devm_kfree(module->dev, dapm_routes);
 	return ret;
 }
 
-static int gbaudio_tplg_process_header(struct gbaudio_codec_info *gbcodec,
+static int gbaudio_tplg_process_header(struct gbaudio_module_info *module,
 				 struct gb_audio_topology *tplg_data)
 {
 	/* fetch no. of kcontrols, widgets & routes */
-	gbcodec->num_dais = tplg_data->num_dais;
-	gbcodec->num_kcontrols = tplg_data->num_controls;
-	gbcodec->num_dapm_widgets = tplg_data->num_widgets;
-	gbcodec->num_dapm_routes = tplg_data->num_routes;
+	module->num_controls = tplg_data->num_controls;
+	module->num_dapm_widgets = tplg_data->num_widgets;
+	module->num_dapm_routes = tplg_data->num_routes;
 
 	/* update block offset */
-	gbcodec->dai_offset = (unsigned long)&tplg_data->data;
-	gbcodec->control_offset = gbcodec->dai_offset + tplg_data->size_dais;
-	gbcodec->widget_offset = gbcodec->control_offset +
+	module->dai_offset = (unsigned long)&tplg_data->data;
+	module->control_offset = module->dai_offset + tplg_data->size_dais;
+	module->widget_offset = module->control_offset +
 		tplg_data->size_controls;
-	gbcodec->route_offset = gbcodec->widget_offset +
+	module->route_offset = module->widget_offset +
 		tplg_data->size_widgets;
 
-	dev_dbg(gbcodec->dev, "DAI offset is 0x%lx\n", gbcodec->dai_offset);
-	dev_dbg(gbcodec->dev, "control offset is %lx\n",
-		gbcodec->control_offset);
-	dev_dbg(gbcodec->dev, "widget offset is %lx\n", gbcodec->widget_offset);
-	dev_dbg(gbcodec->dev, "route offset is %lx\n", gbcodec->route_offset);
+	dev_dbg(module->dev, "DAI offset is 0x%lx\n", module->dai_offset);
+	dev_dbg(module->dev, "control offset is %lx\n",
+		module->control_offset);
+	dev_dbg(module->dev, "widget offset is %lx\n", module->widget_offset);
+	dev_dbg(module->dev, "route offset is %lx\n", module->route_offset);
 
 	return 0;
 }
 
-int gbaudio_tplg_parse_data(struct gbaudio_codec_info *gbcodec,
+int gbaudio_tplg_parse_data(struct gbaudio_module_info *module,
 			       struct gb_audio_topology *tplg_data)
 {
 	int ret;
-	struct gb_audio_dai *dais;
 	struct gb_audio_control *controls;
 	struct gb_audio_widget *widgets;
 	struct gb_audio_route *routes;
@@ -962,90 +948,80 @@ int gbaudio_tplg_parse_data(struct gbaudio_codec_info *gbcodec,
 	if (!tplg_data)
 		return -EINVAL;
 
-	ret = gbaudio_tplg_process_header(gbcodec, tplg_data);
+	ret = gbaudio_tplg_process_header(module, tplg_data);
 	if (ret) {
-		dev_err(gbcodec->dev, "%d: Error in parsing topology header\n",
+		dev_err(module->dev, "%d: Error in parsing topology header\n",
 			ret);
 		return ret;
 	}
 
 	/* process control */
-	controls = (struct gb_audio_control *)gbcodec->control_offset;
-	ret = gbaudio_tplg_process_kcontrols(gbcodec, controls);
+	controls = (struct gb_audio_control *)module->control_offset;
+	ret = gbaudio_tplg_process_kcontrols(module, controls);
 	if (ret) {
-		dev_err(gbcodec->dev,
+		dev_err(module->dev,
 			"%d: Error in parsing controls data\n", ret);
 		return ret;
 	}
-	dev_dbg(gbcodec->dev, "Control parsing finished\n");
-
-	/* process DAI */
-	dais = (struct gb_audio_dai *)gbcodec->dai_offset;
-	ret = gbaudio_tplg_process_dais(gbcodec, dais);
-	if (ret) {
-		dev_err(gbcodec->dev,
-			"%d: Error in parsing DAIs data\n", ret);
-		return ret;
-	}
-	dev_dbg(gbcodec->dev, "DAI parsing finished\n");
+	dev_dbg(module->dev, "Control parsing finished\n");
 
 	/* process widgets */
-	widgets = (struct gb_audio_widget *)gbcodec->widget_offset;
-	ret = gbaudio_tplg_process_widgets(gbcodec, widgets);
+	widgets = (struct gb_audio_widget *)module->widget_offset;
+	ret = gbaudio_tplg_process_widgets(module, widgets);
 	if (ret) {
-		dev_err(gbcodec->dev,
+		dev_err(module->dev,
 			"%d: Error in parsing widgets data\n", ret);
 		return ret;
 	}
-	dev_dbg(gbcodec->dev, "Widget parsing finished\n");
+	dev_dbg(module->dev, "Widget parsing finished\n");
 
 	/* process route */
-	routes = (struct gb_audio_route *)gbcodec->route_offset;
-	ret = gbaudio_tplg_process_routes(gbcodec, routes);
+	routes = (struct gb_audio_route *)module->route_offset;
+	ret = gbaudio_tplg_process_routes(module, routes);
 	if (ret) {
-		dev_err(gbcodec->dev,
+		dev_err(module->dev,
 			"%d: Error in parsing routes data\n", ret);
 		return ret;
 	}
-	dev_dbg(gbcodec->dev, "Route parsing finished\n");
+	dev_dbg(module->dev, "Route parsing finished\n");
 
 	return ret;
 }
 
-void gbaudio_tplg_release(struct gbaudio_codec_info *gbcodec)
+void gbaudio_tplg_release(struct gbaudio_module_info *module)
 {
 	struct gbaudio_control *control, *_control;
 	struct gbaudio_widget *widget, *_widget;
 
-	if (!gbcodec->topology)
+	if (!module->topology)
 		return;
 
 	/* release kcontrols */
-	list_for_each_entry_safe(control, _control, &gbcodec->codec_ctl_list,
+	list_for_each_entry_safe(control, _control, &module->ctl_list,
 				 list) {
 		list_del(&control->list);
-		devm_kfree(gbcodec->dev, control);
+		devm_kfree(module->dev, control);
 	}
-	if (gbcodec->kctls)
-		devm_kfree(gbcodec->dev, gbcodec->kctls);
+	if (module->controls)
+		devm_kfree(module->dev, module->controls);
 
 	/* release widget controls */
-	list_for_each_entry_safe(control, _control, &gbcodec->widget_ctl_list,
+	list_for_each_entry_safe(control, _control, &module->widget_ctl_list,
 				 list) {
 		list_del(&control->list);
-		devm_kfree(gbcodec->dev, control);
+		devm_kfree(module->dev, control);
 	}
 
 	/* release widgets */
-	list_for_each_entry_safe(widget, _widget, &gbcodec->widget_list,
+	list_for_each_entry_safe(widget, _widget, &module->widget_list,
 				 list) {
 		list_del(&widget->list);
-		devm_kfree(gbcodec->dev, widget);
+		devm_kfree(module->dev, widget);
 	}
-	if (gbcodec->widgets)
-		devm_kfree(gbcodec->dev, gbcodec->widgets);
+	if (module->dapm_widgets)
+		devm_kfree(module->dev, module->dapm_widgets);
 
 	/* release routes */
-	if (gbcodec->routes)
-		devm_kfree(gbcodec->dev, gbcodec->routes);
+	if (module->dapm_routes)
+		devm_kfree(module->dev, module->dapm_routes);
 }

commit 3994e0b139c709047cdeb44b6c28cfb39f89f3f2
Author: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
Date:   Thu Jan 28 21:15:40 2016 +0530

    greybus: audio: use variable 'is_connected' to maintain module state
    
    there is race condition between _disconnect() request &
    stop_trigger() in case of abrupt module removal.
    And sometimes this can lead to deadlock while acquiring
    codec_info->lock.
    To avoid such situation, atomic variable is used to maintain
    codec connected state.
    During dai operations (trigger, shutdown, etc.), 'is_connected'
    variable is validated to avoid unnecessary lock acquire in
    case module already removed.
    
    Signed-off-by: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/audio_topology.c b/drivers/staging/greybus/audio_topology.c
index 5fab393130a5..1651c14c87ba 100644
--- a/drivers/staging/greybus/audio_topology.c
+++ b/drivers/staging/greybus/audio_topology.c
@@ -140,6 +140,9 @@ static int gbcodec_mixer_ctl_get(struct snd_kcontrol *kcontrol,
 	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
 	struct gbaudio_codec_info *gb = snd_soc_codec_get_drvdata(codec);
 
+	if (!atomic_read(&gb->is_connected))
+		return -ENODEV;
+
 	data = (struct gbaudio_ctl_pvt *)kcontrol->private_value;
 	info = (struct gb_audio_ctl_elem_info *)data->info;
 
@@ -187,6 +190,9 @@ static int gbcodec_mixer_ctl_put(struct snd_kcontrol *kcontrol,
 	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
 	struct gbaudio_codec_info *gb = snd_soc_codec_get_drvdata(codec);
 
+	if (!atomic_read(&gb->is_connected))
+		return -ENODEV;
+
 	data = (struct gbaudio_ctl_pvt *)kcontrol->private_value;
 	info = (struct gb_audio_ctl_elem_info *)data->info;
 
@@ -281,6 +287,9 @@ static int gbcodec_mixer_dapm_ctl_get(struct snd_kcontrol *kcontrol,
 	struct snd_soc_codec *codec = widget->codec;
 	struct gbaudio_codec_info *gb = snd_soc_codec_get_drvdata(codec);
 
+	if (!atomic_read(&gb->is_connected))
+		return -ENODEV;
+
 	data = (struct gbaudio_ctl_pvt *)kcontrol->private_value;
 	info = (struct gb_audio_ctl_elem_info *)data->info;
 
@@ -315,6 +324,9 @@ static int gbcodec_mixer_dapm_ctl_put(struct snd_kcontrol *kcontrol,
 	struct snd_soc_codec *codec = widget->codec;
 	struct gbaudio_codec_info *gb = snd_soc_codec_get_drvdata(codec);
 
+	if (!atomic_read(&gb->is_connected))
+		return -ENODEV;
+
 	data = (struct gbaudio_ctl_pvt *)kcontrol->private_value;
 	info = (struct gb_audio_ctl_elem_info *)data->info;
 

commit 796fad441cb248c1eac88bfb3a5929bb1a10fabb
Author: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
Date:   Thu Jan 28 21:15:39 2016 +0530

    greybus: audio: codec driver cleanup
    
    audio codec driver is now moved to bundle driver approach.
    This resolved many race conditions related to audio mgmt &
    data connection init/exit sequence.
    Thus, a lot of helper functions can now be safely removed.
    
    Signed-off-by: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/audio_topology.c b/drivers/staging/greybus/audio_topology.c
index 90d2148392ef..5fab393130a5 100644
--- a/drivers/staging/greybus/audio_topology.c
+++ b/drivers/staging/greybus/audio_topology.c
@@ -92,8 +92,7 @@ static int gbcodec_mixer_ctl_info(struct snd_kcontrol *kcontrol,
 	struct gbaudio_ctl_pvt *data;
 	struct gb_audio_ctl_elem_info *info;
 	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
-	struct gb_audio *audio = snd_soc_codec_get_drvdata(codec);
-	struct gbaudio_codec_info *gbcodec = audio->gbcodec;
+	struct gbaudio_codec_info *gbcodec = snd_soc_codec_get_drvdata(codec);
 
 	data = (struct gbaudio_ctl_pvt *)kcontrol->private_value;
 	info = (struct gb_audio_ctl_elem_info *)data->info;
@@ -139,8 +138,7 @@ static int gbcodec_mixer_ctl_get(struct snd_kcontrol *kcontrol,
 	struct gbaudio_ctl_pvt *data;
 	struct gb_audio_ctl_elem_value gbvalue;
 	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
-	struct gb_audio *audio = snd_soc_codec_get_drvdata(codec);
-	struct gbaudio_codec_info *gb = audio->gbcodec;
+	struct gbaudio_codec_info *gb = snd_soc_codec_get_drvdata(codec);
 
 	data = (struct gbaudio_ctl_pvt *)kcontrol->private_value;
 	info = (struct gb_audio_ctl_elem_info *)data->info;
@@ -187,8 +185,7 @@ static int gbcodec_mixer_ctl_put(struct snd_kcontrol *kcontrol,
 	struct gbaudio_ctl_pvt *data;
 	struct gb_audio_ctl_elem_value gbvalue;
 	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
-	struct gb_audio *audio = snd_soc_codec_get_drvdata(codec);
-	struct gbaudio_codec_info *gb = audio->gbcodec;
+	struct gbaudio_codec_info *gb = snd_soc_codec_get_drvdata(codec);
 
 	data = (struct gbaudio_ctl_pvt *)kcontrol->private_value;
 	info = (struct gb_audio_ctl_elem_info *)data->info;
@@ -282,8 +279,7 @@ static int gbcodec_mixer_dapm_ctl_get(struct snd_kcontrol *kcontrol,
 	struct snd_soc_dapm_widget_list *wlist = snd_kcontrol_chip(kcontrol);
 	struct snd_soc_dapm_widget *widget = wlist->widgets[0];
 	struct snd_soc_codec *codec = widget->codec;
-	struct gb_audio *audio = snd_soc_codec_get_drvdata(codec);
-	struct gbaudio_codec_info *gb = audio->gbcodec;
+	struct gbaudio_codec_info *gb = snd_soc_codec_get_drvdata(codec);
 
 	data = (struct gbaudio_ctl_pvt *)kcontrol->private_value;
 	info = (struct gb_audio_ctl_elem_info *)data->info;
@@ -317,8 +313,7 @@ static int gbcodec_mixer_dapm_ctl_put(struct snd_kcontrol *kcontrol,
 	struct snd_soc_dapm_widget_list *wlist = snd_kcontrol_chip(kcontrol);
 	struct snd_soc_dapm_widget *widget = wlist->widgets[0];
 	struct snd_soc_codec *codec = widget->codec;
-	struct gb_audio *audio = snd_soc_codec_get_drvdata(codec);
-	struct gbaudio_codec_info *gb = audio->gbcodec;
+	struct gbaudio_codec_info *gb = snd_soc_codec_get_drvdata(codec);
 
 	data = (struct gbaudio_ctl_pvt *)kcontrol->private_value;
 	info = (struct gb_audio_ctl_elem_info *)data->info;
@@ -524,8 +519,7 @@ static int gbaudio_widget_event(struct snd_soc_dapm_widget *w,
 	int wid;
 	int ret;
 	struct snd_soc_codec *codec = w->codec;
-	struct gb_audio *audio = snd_soc_codec_get_drvdata(codec);
-	struct gbaudio_codec_info *gbcodec = audio->gbcodec;
+	struct gbaudio_codec_info *gbcodec = snd_soc_codec_get_drvdata(codec);
 
 	dev_dbg(codec->dev, "%s %s %d\n", __func__, w->name, event);
 
@@ -819,9 +813,9 @@ static int gbaudio_tplg_process_dais(struct gbaudio_codec_info *gbcodec,
 	int i, ret;
 	struct snd_soc_dai_driver *gb_dais;
 	struct gb_audio_dai *curr;
-	struct gbaudio_dai *dai, *_dai;
 	size_t size;
 	char dai_name[NAME_SIZE];
+	struct gbaudio_dai *dai;
 
 	size = sizeof(struct snd_soc_dai_driver) * gbcodec->num_dais;
 	gb_dais = devm_kzalloc(gbcodec->dev, size, GFP_KERNEL);
@@ -839,10 +833,10 @@ static int gbaudio_tplg_process_dais(struct gbaudio_codec_info *gbcodec,
 		/* append dev_id to dai_name */
 		snprintf(dai_name, NAME_SIZE, "%s.%d", curr->name,
 			 gbcodec->dev_id);
-		dai = gbaudio_add_dai(gbcodec, curr->data_cport, NULL,
-				      dai_name);
+		dai = gbaudio_find_dai(gbcodec, curr->data_cport, NULL);
 		if (!dai)
 			goto error;
+		strlcpy(dai->name, dai_name, NAME_SIZE);
 		dev_dbg(gbcodec->dev, "%s:DAI added\n", dai->name);
 		gb_dais[i].name = dai->name;
 		curr++;
@@ -852,10 +846,6 @@ static int gbaudio_tplg_process_dais(struct gbaudio_codec_info *gbcodec,
 	return 0;
 
 error:
-	list_for_each_entry_safe(dai, _dai, &gbcodec->dai_list, list) {
-		list_del(&dai->list);
-		devm_kfree(gbcodec->dev, dai);
-	}
 	devm_kfree(gbcodec->dev, gb_dais);
 	return ret;
 }
@@ -948,68 +938,6 @@ static int gbaudio_tplg_process_header(struct gbaudio_codec_info *gbcodec,
 	return 0;
 }
 
-static struct gbaudio_dai *gbaudio_allocate_dai(struct gbaudio_codec_info *gb,
-					 int data_cport,
-					 struct gb_connection *connection,
-					 const char *name)
-{
-	struct gbaudio_dai *dai;
-
-	mutex_lock(&gb->lock);
-	dai = devm_kzalloc(gb->dev, sizeof(*dai), GFP_KERNEL);
-	if (!dai) {
-		dev_err(gb->dev, "%s:DAI Malloc failure\n", name);
-		mutex_unlock(&gb->lock);
-		return NULL;
-	}
-
-	dai->data_cport = data_cport;
-	dai->connection = connection;
-
-	/* update name */
-	if (name)
-		strlcpy(dai->name, name, NAME_SIZE);
-	list_add(&dai->list, &gb->dai_list);
-	dev_dbg(gb->dev, "%d:%s: DAI added\n", data_cport, dai->name);
-	mutex_unlock(&gb->lock);
-
-	return dai;
-}
-
-struct gbaudio_dai *gbaudio_add_dai(struct gbaudio_codec_info *gbcodec,
-				    int data_cport,
-				    struct gb_connection *connection,
-				    const char *name)
-{
-	struct gbaudio_dai *dai, *_dai;
-
-	/* FIXME need to take care for multiple DAIs */
-	mutex_lock(&gbcodec->lock);
-	if (list_empty(&gbcodec->dai_list)) {
-		mutex_unlock(&gbcodec->lock);
-		return gbaudio_allocate_dai(gbcodec, data_cport, connection,
-					    name);
-	}
-
-	list_for_each_entry_safe(dai, _dai, &gbcodec->dai_list, list) {
-		if (dai->data_cport == data_cport) {
-			if (connection)
-				dai->connection = connection;
-
-			if (name)
-				strlcpy(dai->name, name, NAME_SIZE);
-			dev_dbg(gbcodec->dev, "%d:%s: DAI updated\n",
-				data_cport, dai->name);
-			mutex_unlock(&gbcodec->lock);
-			return dai;
-		}
-	}
-
-	dev_err(gbcodec->dev, "%s:DAI not found\n", name);
-	mutex_unlock(&gbcodec->lock);
-	return NULL;
-}
-
 int gbaudio_tplg_parse_data(struct gbaudio_codec_info *gbcodec,
 			       struct gb_audio_topology *tplg_data)
 {
@@ -1074,7 +1002,6 @@ int gbaudio_tplg_parse_data(struct gbaudio_codec_info *gbcodec,
 
 void gbaudio_tplg_release(struct gbaudio_codec_info *gbcodec)
 {
-	struct gbaudio_dai *dai, *_dai;
 	struct gbaudio_control *control, *_control;
 	struct gbaudio_widget *widget, *_widget;
 
@@ -1109,12 +1036,4 @@ void gbaudio_tplg_release(struct gbaudio_codec_info *gbcodec)
 	/* release routes */
 	if (gbcodec->routes)
 		devm_kfree(gbcodec->dev, gbcodec->routes);
-
-	/* release DAIs */
-	mutex_lock(&gbcodec->lock);
-	list_for_each_entry_safe(dai, _dai, &gbcodec->dai_list, list) {
-		list_del(&dai->list);
-		devm_kfree(gbcodec->dev, dai);
-	}
-	mutex_unlock(&gbcodec->lock);
 }

commit 35e28794dcddf2eab1d53b9f3bf5a0eeee82e3c9
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Wed Jan 27 16:57:48 2016 +0530

    greybus: audio_codec: convert to bundle driver
    
    Convert the legacy audio management and data protocol drivers to a
    bundle driver.
    
    The Audio bundle driver can support a single management and any number
    of data cports, and so we expect multiple data cports to be present for
    the bundle during initialization.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Reviewed-by: Johan Hovold <johan@hovoldconsulting.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/audio_topology.c b/drivers/staging/greybus/audio_topology.c
index b18574e91b5f..90d2148392ef 100644
--- a/drivers/staging/greybus/audio_topology.c
+++ b/drivers/staging/greybus/audio_topology.c
@@ -92,7 +92,8 @@ static int gbcodec_mixer_ctl_info(struct snd_kcontrol *kcontrol,
 	struct gbaudio_ctl_pvt *data;
 	struct gb_audio_ctl_elem_info *info;
 	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
-	struct gbaudio_codec_info *gbcodec = snd_soc_codec_get_drvdata(codec);
+	struct gb_audio *audio = snd_soc_codec_get_drvdata(codec);
+	struct gbaudio_codec_info *gbcodec = audio->gbcodec;
 
 	data = (struct gbaudio_ctl_pvt *)kcontrol->private_value;
 	info = (struct gb_audio_ctl_elem_info *)data->info;
@@ -138,7 +139,8 @@ static int gbcodec_mixer_ctl_get(struct snd_kcontrol *kcontrol,
 	struct gbaudio_ctl_pvt *data;
 	struct gb_audio_ctl_elem_value gbvalue;
 	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
-	struct gbaudio_codec_info *gb = snd_soc_codec_get_drvdata(codec);
+	struct gb_audio *audio = snd_soc_codec_get_drvdata(codec);
+	struct gbaudio_codec_info *gb = audio->gbcodec;
 
 	data = (struct gbaudio_ctl_pvt *)kcontrol->private_value;
 	info = (struct gb_audio_ctl_elem_info *)data->info;
@@ -185,7 +187,8 @@ static int gbcodec_mixer_ctl_put(struct snd_kcontrol *kcontrol,
 	struct gbaudio_ctl_pvt *data;
 	struct gb_audio_ctl_elem_value gbvalue;
 	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
-	struct gbaudio_codec_info *gb = snd_soc_codec_get_drvdata(codec);
+	struct gb_audio *audio = snd_soc_codec_get_drvdata(codec);
+	struct gbaudio_codec_info *gb = audio->gbcodec;
 
 	data = (struct gbaudio_ctl_pvt *)kcontrol->private_value;
 	info = (struct gb_audio_ctl_elem_info *)data->info;
@@ -279,7 +282,8 @@ static int gbcodec_mixer_dapm_ctl_get(struct snd_kcontrol *kcontrol,
 	struct snd_soc_dapm_widget_list *wlist = snd_kcontrol_chip(kcontrol);
 	struct snd_soc_dapm_widget *widget = wlist->widgets[0];
 	struct snd_soc_codec *codec = widget->codec;
-	struct gbaudio_codec_info *gb = snd_soc_codec_get_drvdata(codec);
+	struct gb_audio *audio = snd_soc_codec_get_drvdata(codec);
+	struct gbaudio_codec_info *gb = audio->gbcodec;
 
 	data = (struct gbaudio_ctl_pvt *)kcontrol->private_value;
 	info = (struct gb_audio_ctl_elem_info *)data->info;
@@ -313,7 +317,8 @@ static int gbcodec_mixer_dapm_ctl_put(struct snd_kcontrol *kcontrol,
 	struct snd_soc_dapm_widget_list *wlist = snd_kcontrol_chip(kcontrol);
 	struct snd_soc_dapm_widget *widget = wlist->widgets[0];
 	struct snd_soc_codec *codec = widget->codec;
-	struct gbaudio_codec_info *gb = snd_soc_codec_get_drvdata(codec);
+	struct gb_audio *audio = snd_soc_codec_get_drvdata(codec);
+	struct gbaudio_codec_info *gb = audio->gbcodec;
 
 	data = (struct gbaudio_ctl_pvt *)kcontrol->private_value;
 	info = (struct gb_audio_ctl_elem_info *)data->info;
@@ -519,7 +524,8 @@ static int gbaudio_widget_event(struct snd_soc_dapm_widget *w,
 	int wid;
 	int ret;
 	struct snd_soc_codec *codec = w->codec;
-	struct gbaudio_codec_info *gbcodec = snd_soc_codec_get_drvdata(codec);
+	struct gb_audio *audio = snd_soc_codec_get_drvdata(codec);
+	struct gbaudio_codec_info *gbcodec = audio->gbcodec;
 
 	dev_dbg(codec->dev, "%s %s %d\n", __func__, w->name, event);
 

commit 538ecb5a05049fcd23043ed5c97e42c379e5ccb0
Author: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
Date:   Wed Jan 13 14:07:54 2016 -0700

    greybus: audio: cleanup unnecessary dev_err messages
    
    Replace unnecessary dev_err msg with dev_dbg.
    Same were added during development to trace topology
    parser progress.
    
    Signed-off-by: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
    Signed-off-by: Mark Greer <mgreer@animalcreek.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/audio_topology.c b/drivers/staging/greybus/audio_topology.c
index 8840a9c330de..b18574e91b5f 100644
--- a/drivers/staging/greybus/audio_topology.c
+++ b/drivers/staging/greybus/audio_topology.c
@@ -837,7 +837,7 @@ static int gbaudio_tplg_process_dais(struct gbaudio_codec_info *gbcodec,
 				      dai_name);
 		if (!dai)
 			goto error;
-		dev_err(gbcodec->dev, "%s:DAI added\n", dai->name);
+		dev_dbg(gbcodec->dev, "%s:DAI added\n", dai->name);
 		gb_dais[i].name = dai->name;
 		curr++;
 	}
@@ -1031,7 +1031,7 @@ int gbaudio_tplg_parse_data(struct gbaudio_codec_info *gbcodec,
 			"%d: Error in parsing controls data\n", ret);
 		return ret;
 	}
-	dev_err(gbcodec->dev, "Control parsing finished\n");
+	dev_dbg(gbcodec->dev, "Control parsing finished\n");
 
 	/* process DAI */
 	dais = (struct gb_audio_dai *)gbcodec->dai_offset;
@@ -1041,7 +1041,7 @@ int gbaudio_tplg_parse_data(struct gbaudio_codec_info *gbcodec,
 			"%d: Error in parsing DAIs data\n", ret);
 		return ret;
 	}
-	dev_err(gbcodec->dev, "DAI parsing finished\n");
+	dev_dbg(gbcodec->dev, "DAI parsing finished\n");
 
 	/* process widgets */
 	widgets = (struct gb_audio_widget *)gbcodec->widget_offset;
@@ -1051,7 +1051,7 @@ int gbaudio_tplg_parse_data(struct gbaudio_codec_info *gbcodec,
 			"%d: Error in parsing widgets data\n", ret);
 		return ret;
 	}
-	dev_err(gbcodec->dev, "Widget parsing finished\n");
+	dev_dbg(gbcodec->dev, "Widget parsing finished\n");
 
 	/* process route */
 	routes = (struct gb_audio_route *)gbcodec->route_offset;
@@ -1061,7 +1061,7 @@ int gbaudio_tplg_parse_data(struct gbaudio_codec_info *gbcodec,
 			"%d: Error in parsing routes data\n", ret);
 		return ret;
 	}
-	dev_err(gbcodec->dev, "Route parsing finished\n");
+	dev_dbg(gbcodec->dev, "Route parsing finished\n");
 
 	return ret;
 }

commit 6339d2322c47f4b8ebabf9daf0130328ed72648b
Author: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
Date:   Wed Jan 13 14:07:51 2016 -0700

    greybus: audio: Add topology parser for GB codec
    
    For each GB codec module inserted, DAPM widgets, kcontrols, routes
    and DAIs can be fetched through greybus in a binary chunk and parsed
    locally to create & populate DAPM graph for the specific module.
    
    It is required by each codec module to populate a minimum set of
    kcontrols with fixed names to support basic audio usecase.
    To support advanced features of codec module, the same can be polpulated
    with existing topology parser. However, to use them for different usecase
    separate mechanism (may be via MSP) is required to inform userspace about
    their configuration value & enable/disable sequence.
    
    ToDos:
    Currently, support for enumerated kcontrol/dapm control is hardcoded.
    Need to add complete logic within the parser.
    
    Signed-off-by: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
    Signed-off-by: Mark Greer <mgreer@animalcreek.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/audio_topology.c b/drivers/staging/greybus/audio_topology.c
new file mode 100644
index 000000000000..8840a9c330de
--- /dev/null
+++ b/drivers/staging/greybus/audio_topology.c
@@ -0,0 +1,1114 @@
+/*
+ * Greybus audio driver
+ * Copyright 2015-2016 Google Inc.
+ * Copyright 2015-2016 Linaro Ltd.
+ *
+ * Released under the GPLv2 only.
+ */
+
+#include "audio_codec.h"
+#include "greybus_protocols.h"
+
+#define GBAUDIO_INVALID_ID	0xFF
+
+/* mixer control */
+struct gb_mixer_control {
+	int min, max;
+	unsigned int reg, rreg, shift, rshift, invert;
+};
+
+struct gbaudio_ctl_pvt {
+	unsigned int ctl_id;
+	unsigned int data_cport;
+	unsigned int access;
+	unsigned int vcount;
+	struct gb_audio_ctl_elem_info *info;
+};
+
+static const char *gbaudio_map_controlid(struct gbaudio_codec_info *gbcodec,
+					   __u8 control_id, __u8 index)
+{
+	struct gbaudio_control *control;
+
+	if (control_id == GBAUDIO_INVALID_ID)
+		return NULL;
+
+	list_for_each_entry(control, &gbcodec->codec_ctl_list, list) {
+		if (control->id == control_id) {
+			if (index == GBAUDIO_INVALID_ID)
+				return control->name;
+			return control->texts[index];
+		}
+	}
+	list_for_each_entry(control, &gbcodec->widget_ctl_list, list) {
+		if (control->id == control_id) {
+			if (index == GBAUDIO_INVALID_ID)
+				return control->name;
+			return control->texts[index];
+		}
+	}
+	return NULL;
+}
+
+static int gbaudio_map_widgetname(struct gbaudio_codec_info *gbcodec,
+					  const char *name)
+{
+	struct gbaudio_widget *widget;
+	char widget_name[NAME_SIZE];
+	char prefix_name[NAME_SIZE];
+
+	snprintf(prefix_name, NAME_SIZE, "GB %d ", gbcodec->dev_id);
+	if (strncmp(name, prefix_name, strlen(prefix_name)))
+		return -EINVAL;
+
+	strlcpy(widget_name, name+strlen(prefix_name), NAME_SIZE);
+	dev_dbg(gbcodec->dev, "widget_name:%s, truncated widget_name:%s\n",
+		name, widget_name);
+
+	list_for_each_entry(widget, &gbcodec->widget_list, list) {
+		if (!strncmp(widget->name, widget_name, NAME_SIZE))
+			return widget->id;
+	}
+	return -EINVAL;
+}
+
+static const char *gbaudio_map_widgetid(struct gbaudio_codec_info *gbcodec,
+					  __u8 widget_id)
+{
+	struct gbaudio_widget *widget;
+
+	list_for_each_entry(widget, &gbcodec->widget_list, list) {
+		if (widget->id == widget_id)
+			return widget->name;
+	}
+	return NULL;
+}
+
+static int gbcodec_mixer_ctl_info(struct snd_kcontrol *kcontrol,
+		     struct snd_ctl_elem_info *uinfo)
+{
+	unsigned int max;
+	const char *name;
+	struct gbaudio_ctl_pvt *data;
+	struct gb_audio_ctl_elem_info *info;
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+	struct gbaudio_codec_info *gbcodec = snd_soc_codec_get_drvdata(codec);
+
+	data = (struct gbaudio_ctl_pvt *)kcontrol->private_value;
+	info = (struct gb_audio_ctl_elem_info *)data->info;
+
+	if (!info) {
+		dev_err(gbcodec->dev, "NULL info for %s\n", uinfo->id.name);
+		return -EINVAL;
+	}
+
+	/* update uinfo */
+	uinfo->access = data->access;
+	uinfo->count = data->vcount;
+	uinfo->type = (snd_ctl_elem_type_t)info->type;
+
+	switch (info->type) {
+	case GB_AUDIO_CTL_ELEM_TYPE_BOOLEAN:
+	case GB_AUDIO_CTL_ELEM_TYPE_INTEGER:
+		uinfo->value.integer.min = info->value.integer.min;
+		uinfo->value.integer.max = info->value.integer.max;
+		break;
+	case GB_AUDIO_CTL_ELEM_TYPE_ENUMERATED:
+		max = info->value.enumerated.items;
+		uinfo->value.enumerated.items = max;
+		if (uinfo->value.enumerated.item > max - 1)
+			uinfo->value.enumerated.item = max - 1;
+		name = gbaudio_map_controlid(gbcodec, data->ctl_id,
+					     uinfo->value.enumerated.item);
+		strlcpy(uinfo->value.enumerated.name, name, NAME_SIZE);
+		break;
+	default:
+		dev_err(codec->dev, "Invalid type: %d for %s:kcontrol\n",
+			info->type, kcontrol->id.name);
+		break;
+	}
+	return 0;
+}
+
+static int gbcodec_mixer_ctl_get(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	int ret;
+	struct gb_audio_ctl_elem_info *info;
+	struct gbaudio_ctl_pvt *data;
+	struct gb_audio_ctl_elem_value gbvalue;
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+	struct gbaudio_codec_info *gb = snd_soc_codec_get_drvdata(codec);
+
+	data = (struct gbaudio_ctl_pvt *)kcontrol->private_value;
+	info = (struct gb_audio_ctl_elem_info *)data->info;
+
+	ret = gb_audio_gb_get_control(gb->mgmt_connection, data->ctl_id,
+				      GB_AUDIO_INVALID_INDEX, &gbvalue);
+	if (ret) {
+		dev_err(codec->dev, "%d:Error in %s for %s\n", ret, __func__,
+			kcontrol->id.name);
+		return ret;
+	}
+
+	/* update ucontrol */
+	switch (info->type) {
+	case GB_AUDIO_CTL_ELEM_TYPE_BOOLEAN:
+	case GB_AUDIO_CTL_ELEM_TYPE_INTEGER:
+		ucontrol->value.integer.value[0] =
+			gbvalue.value.integer_value[0];
+		if (data->vcount == 2)
+			ucontrol->value.integer.value[1] =
+				gbvalue.value.integer_value[1];
+		break;
+	case GB_AUDIO_CTL_ELEM_TYPE_ENUMERATED:
+		ucontrol->value.enumerated.item[0] =
+			gbvalue.value.enumerated_item[0];
+		if (data->vcount == 2)
+			ucontrol->value.enumerated.item[1] =
+				gbvalue.value.enumerated_item[1];
+		break;
+	default:
+		dev_err(codec->dev, "Invalid type: %d for %s:kcontrol\n",
+			info->type, kcontrol->id.name);
+		ret = -EINVAL;
+		break;
+	}
+	return ret;
+}
+
+static int gbcodec_mixer_ctl_put(struct snd_kcontrol *kcontrol,
+			      struct snd_ctl_elem_value *ucontrol)
+{
+	int ret = 0;
+	struct gb_audio_ctl_elem_info *info;
+	struct gbaudio_ctl_pvt *data;
+	struct gb_audio_ctl_elem_value gbvalue;
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+	struct gbaudio_codec_info *gb = snd_soc_codec_get_drvdata(codec);
+
+	data = (struct gbaudio_ctl_pvt *)kcontrol->private_value;
+	info = (struct gb_audio_ctl_elem_info *)data->info;
+
+	/* update ucontrol */
+	switch (info->type) {
+	case GB_AUDIO_CTL_ELEM_TYPE_BOOLEAN:
+	case GB_AUDIO_CTL_ELEM_TYPE_INTEGER:
+		gbvalue.value.integer_value[0] =
+			ucontrol->value.integer.value[0];
+		if (data->vcount == 2)
+			gbvalue.value.integer_value[1] =
+				ucontrol->value.integer.value[1];
+		break;
+	case GB_AUDIO_CTL_ELEM_TYPE_ENUMERATED:
+		gbvalue.value.enumerated_item[0] =
+			ucontrol->value.enumerated.item[0];
+		if (data->vcount == 2)
+			gbvalue.value.enumerated_item[1] =
+				ucontrol->value.enumerated.item[1];
+		break;
+	default:
+		dev_err(codec->dev, "Invalid type: %d for %s:kcontrol\n",
+			info->type, kcontrol->id.name);
+		ret = -EINVAL;
+		break;
+	}
+
+	if (ret)
+		return ret;
+
+	ret = gb_audio_gb_set_control(gb->mgmt_connection, data->ctl_id,
+				      GB_AUDIO_INVALID_INDEX, &gbvalue);
+	if (ret) {
+		dev_err(codec->dev, "%d:Error in %s for %s\n", ret, __func__,
+			kcontrol->id.name);
+	}
+
+	return ret;
+}
+
+#define SOC_MIXER_GB(xname, kcount, data) \
+{	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, \
+	.count = kcount, .info = gbcodec_mixer_ctl_info, \
+	.get = gbcodec_mixer_ctl_get, .put = gbcodec_mixer_ctl_put, \
+	.private_value = (unsigned long)data }
+
+/*
+ * although below callback functions seems redundant to above functions.
+ * same are kept to allow provision for different handling in case
+ * of DAPM related sequencing, etc.
+ */
+static int gbcodec_mixer_dapm_ctl_info(struct snd_kcontrol *kcontrol,
+		     struct snd_ctl_elem_info *uinfo)
+{
+	int platform_max, platform_min;
+	struct gbaudio_ctl_pvt *data;
+	struct gb_audio_ctl_elem_info *info;
+
+	data = (struct gbaudio_ctl_pvt *)kcontrol->private_value;
+	info = (struct gb_audio_ctl_elem_info *)data->info;
+
+	/* update uinfo */
+	platform_max = info->value.integer.max;
+	platform_min = info->value.integer.min;
+
+	if (platform_max == 1 &&
+	    !strnstr(kcontrol->id.name, " Volume", NAME_SIZE))
+		uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
+	else
+		uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+
+	uinfo->count = data->vcount;
+	uinfo->value.integer.min = 0;
+	if (info->value.integer.min < 0 &&
+	    (uinfo->type == SNDRV_CTL_ELEM_TYPE_INTEGER))
+		uinfo->value.integer.max = platform_max - platform_min;
+	else
+		uinfo->value.integer.max = platform_max;
+
+	return 0;
+}
+
+static int gbcodec_mixer_dapm_ctl_get(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	int ret;
+	struct gb_audio_ctl_elem_info *info;
+	struct gbaudio_ctl_pvt *data;
+	struct gb_audio_ctl_elem_value gbvalue;
+	struct snd_soc_dapm_widget_list *wlist = snd_kcontrol_chip(kcontrol);
+	struct snd_soc_dapm_widget *widget = wlist->widgets[0];
+	struct snd_soc_codec *codec = widget->codec;
+	struct gbaudio_codec_info *gb = snd_soc_codec_get_drvdata(codec);
+
+	data = (struct gbaudio_ctl_pvt *)kcontrol->private_value;
+	info = (struct gb_audio_ctl_elem_info *)data->info;
+
+	if (data->vcount == 2)
+		dev_warn(widget->dapm->dev,
+			 "GB: Control '%s' is stereo, which is not supported\n",
+			 kcontrol->id.name);
+
+	ret = gb_audio_gb_get_control(gb->mgmt_connection, data->ctl_id,
+				      GB_AUDIO_INVALID_INDEX, &gbvalue);
+	if (ret) {
+		dev_err(codec->dev, "%d:Error in %s for %s\n", ret, __func__,
+			kcontrol->id.name);
+		return ret;
+	}
+	/* update ucontrol */
+	ucontrol->value.integer.value[0] = gbvalue.value.integer_value[0];
+
+	return ret;
+}
+
+static int gbcodec_mixer_dapm_ctl_put(struct snd_kcontrol *kcontrol,
+			      struct snd_ctl_elem_value *ucontrol)
+{
+	int ret, wi, max, connect;
+	unsigned int mask, val;
+	struct gb_audio_ctl_elem_info *info;
+	struct gbaudio_ctl_pvt *data;
+	struct gb_audio_ctl_elem_value gbvalue;
+	struct snd_soc_dapm_widget_list *wlist = snd_kcontrol_chip(kcontrol);
+	struct snd_soc_dapm_widget *widget = wlist->widgets[0];
+	struct snd_soc_codec *codec = widget->codec;
+	struct gbaudio_codec_info *gb = snd_soc_codec_get_drvdata(codec);
+
+	data = (struct gbaudio_ctl_pvt *)kcontrol->private_value;
+	info = (struct gb_audio_ctl_elem_info *)data->info;
+
+	if (data->vcount == 2)
+		dev_warn(widget->dapm->dev,
+			 "GB: Control '%s' is stereo, which is not supported\n",
+			 kcontrol->id.name);
+
+	max = info->value.integer.max;
+	mask = (1 << fls(max)) - 1;
+	val = (ucontrol->value.integer.value[0] & mask);
+	connect = !!val;
+
+	/* update ucontrol */
+	if (gbvalue.value.integer_value[0] != val) {
+		for (wi = 0; wi < wlist->num_widgets; wi++) {
+			widget = wlist->widgets[wi];
+
+			widget->value = val;
+			widget->dapm->update = NULL;
+			snd_soc_dapm_mixer_update_power(widget, kcontrol,
+							connect);
+		}
+		gbvalue.value.integer_value[0] =
+			ucontrol->value.integer.value[0];
+		ret = gb_audio_gb_set_control(gb->mgmt_connection,
+					      data->ctl_id,
+					      GB_AUDIO_INVALID_INDEX, &gbvalue);
+		if (ret) {
+			dev_err(codec->dev,
+				"%d:Error in %s for %s\n", ret, __func__,
+				kcontrol->id.name);
+		}
+	}
+
+	return ret;
+}
+
+#define SOC_DAPM_MIXER_GB(xname, kcount, data) \
+{	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, \
+	.count = kcount, .info = gbcodec_mixer_dapm_ctl_info, \
+	.get = gbcodec_mixer_dapm_ctl_get, .put = gbcodec_mixer_dapm_ctl_put, \
+	.private_value = (unsigned long)data}
+
+static int gbcodec_event_spk(struct snd_soc_dapm_widget *w,
+					struct snd_kcontrol *k, int event)
+{
+	/* Ensure GB speaker is connected */
+
+	return 0;
+}
+
+static int gbcodec_event_hp(struct snd_soc_dapm_widget *w,
+					struct snd_kcontrol *k, int event)
+{
+	/* Ensure GB module supports jack slot */
+
+	return 0;
+}
+
+static int gbcodec_event_int_mic(struct snd_soc_dapm_widget *w,
+					struct snd_kcontrol *k, int event)
+{
+	/* Ensure GB module supports jack slot */
+
+	return 0;
+}
+
+static int gbaudio_validate_kcontrol_count(struct gb_audio_widget *w)
+{
+	int ret = 0;
+
+	switch (w->type) {
+	case snd_soc_dapm_spk:
+	case snd_soc_dapm_hp:
+	case snd_soc_dapm_mic:
+	case snd_soc_dapm_output:
+	case snd_soc_dapm_input:
+		if (w->ncontrols)
+			ret = -EINVAL;
+		break;
+	case snd_soc_dapm_switch:
+	case snd_soc_dapm_mux:
+		if (w->ncontrols != 1)
+			ret = -EINVAL;
+		break;
+	default:
+		break;
+	}
+
+	return ret;
+}
+
+static int gbaudio_tplg_create_kcontrol(struct gbaudio_codec_info *gb,
+					struct snd_kcontrol_new *kctl,
+					struct gb_audio_control *ctl)
+{
+	struct gbaudio_ctl_pvt *ctldata;
+
+	switch (ctl->iface) {
+	case SNDRV_CTL_ELEM_IFACE_MIXER:
+		ctldata = devm_kzalloc(gb->dev, sizeof(struct gbaudio_ctl_pvt),
+				       GFP_KERNEL);
+		if (!ctldata)
+			return -ENOMEM;
+		ctldata->ctl_id = ctl->id;
+		ctldata->data_cport = ctl->data_cport;
+		ctldata->access = ctl->access;
+		ctldata->vcount = ctl->count_values;
+		ctldata->info = &ctl->info;
+		*kctl = (struct snd_kcontrol_new)
+			SOC_MIXER_GB(ctl->name, ctl->count, ctldata);
+		ctldata = NULL;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	dev_dbg(gb->dev, "%s:%d control created\n", ctl->name, ctl->id);
+	return 0;
+}
+
+static const char * const gbtexts[] = {"Stereo", "Left", "Right"};
+
+static const SOC_ENUM_SINGLE_DECL(
+	gbcodec_apb1_rx_enum, GBCODEC_APB1_MUX_REG, 0, gbtexts);
+
+static const SOC_ENUM_SINGLE_DECL(
+	gbcodec_mic_enum, GBCODEC_APB1_MUX_REG, 4, gbtexts);
+
+static int gbaudio_tplg_create_enum_ctl(struct gbaudio_codec_info *gb,
+					struct snd_kcontrol_new *kctl,
+					struct gb_audio_control *ctl)
+{
+	switch (ctl->id) {
+	case 8:
+		*kctl = (struct snd_kcontrol_new)
+			SOC_DAPM_ENUM(ctl->name, gbcodec_apb1_rx_enum);
+		break;
+	case 9:
+		*kctl = (struct snd_kcontrol_new)
+			SOC_DAPM_ENUM(ctl->name, gbcodec_mic_enum);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int gbaudio_tplg_create_mixer_ctl(struct gbaudio_codec_info *gb,
+					     struct snd_kcontrol_new *kctl,
+					     struct gb_audio_control *ctl)
+{
+	struct gbaudio_ctl_pvt *ctldata;
+
+	ctldata = devm_kzalloc(gb->dev, sizeof(struct gbaudio_ctl_pvt),
+			       GFP_KERNEL);
+	if (!ctldata)
+		return -ENOMEM;
+	ctldata->ctl_id = ctl->id;
+	ctldata->data_cport = ctl->data_cport;
+	ctldata->access = ctl->access;
+	ctldata->vcount = ctl->count_values;
+	ctldata->info = &ctl->info;
+	*kctl = (struct snd_kcontrol_new)
+		SOC_DAPM_MIXER_GB(ctl->name, ctl->count, ctldata);
+
+	return 0;
+}
+
+static int gbaudio_tplg_create_wcontrol(struct gbaudio_codec_info *gb,
+					     struct snd_kcontrol_new *kctl,
+					     struct gb_audio_control *ctl)
+{
+	int ret;
+
+	switch (ctl->iface) {
+	case SNDRV_CTL_ELEM_IFACE_MIXER:
+		switch (ctl->info.type) {
+		case GB_AUDIO_CTL_ELEM_TYPE_ENUMERATED:
+			ret = gbaudio_tplg_create_enum_ctl(gb, kctl, ctl);
+			break;
+		default:
+			ret = gbaudio_tplg_create_mixer_ctl(gb, kctl, ctl);
+			break;
+		}
+		break;
+	default:
+		return -EINVAL;
+
+	}
+
+	dev_dbg(gb->dev, "%s:%d DAPM control created, ret:%d\n", ctl->name,
+		ctl->id, ret);
+	return ret;
+}
+
+static int gbaudio_widget_event(struct snd_soc_dapm_widget *w,
+				struct snd_kcontrol *kcontrol, int event)
+{
+	int wid;
+	int ret;
+	struct snd_soc_codec *codec = w->codec;
+	struct gbaudio_codec_info *gbcodec = snd_soc_codec_get_drvdata(codec);
+
+	dev_dbg(codec->dev, "%s %s %d\n", __func__, w->name, event);
+
+	/* map name to widget id */
+	wid = gbaudio_map_widgetname(gbcodec, w->name);
+	if (wid < 0) {
+		dev_err(codec->dev, "Invalid widget name:%s\n", w->name);
+		return -EINVAL;
+	}
+
+	switch (event) {
+	case SND_SOC_DAPM_PRE_PMU:
+		ret = gb_audio_gb_enable_widget(gbcodec->mgmt_connection, wid);
+		break;
+	case SND_SOC_DAPM_POST_PMD:
+		ret = gb_audio_gb_disable_widget(gbcodec->mgmt_connection, wid);
+		break;
+	}
+	if (ret)
+		dev_err(codec->dev, "%d: widget, event:%d failed:%d\n", wid,
+			event, ret);
+	return ret;
+}
+
+static int gbaudio_tplg_create_widget(struct gbaudio_codec_info *gbcodec,
+				      struct snd_soc_dapm_widget *dw,
+				      struct gb_audio_widget *w)
+{
+	int i, ret;
+	struct snd_kcontrol_new *widget_kctls;
+	struct gb_audio_control *curr;
+	struct gbaudio_control *control, *_control;
+	size_t size;
+
+	ret = gbaudio_validate_kcontrol_count(w);
+	if (ret) {
+		dev_err(gbcodec->dev, "Inavlid kcontrol count=%d for %s\n",
+			w->ncontrols, w->name);
+		return ret;
+	}
+
+	/* allocate memory for kcontrol */
+	if (w->ncontrols) {
+		size = sizeof(struct snd_kcontrol_new) * w->ncontrols;
+		widget_kctls = devm_kzalloc(gbcodec->dev, size, GFP_KERNEL);
+		if (!widget_kctls)
+			return -ENOMEM;
+	}
+
+	/* create relevant kcontrols */
+	for (i = 0; i < w->ncontrols; i++) {
+		curr = &w->ctl[i];
+		ret = gbaudio_tplg_create_wcontrol(gbcodec, &widget_kctls[i],
+						   curr);
+		if (ret) {
+			dev_err(gbcodec->dev,
+				"%s:%d type widget_ctl not supported\n",
+				curr->name, curr->iface);
+			goto error;
+		}
+		control = devm_kzalloc(gbcodec->dev,
+				       sizeof(struct gbaudio_control),
+				       GFP_KERNEL);
+		if (!control) {
+			ret = -ENOMEM;
+			goto error;
+		}
+		control->id = curr->id;
+		control->name = curr->name;
+		if (curr->info.type == GB_AUDIO_CTL_ELEM_TYPE_ENUMERATED)
+			control->texts = (const char * const *)
+				curr->info.value.enumerated.names;
+		list_add(&control->list, &gbcodec->widget_ctl_list);
+		dev_dbg(gbcodec->dev, "%s: control of type %d created\n",
+			widget_kctls[i].name, widget_kctls[i].iface);
+	}
+
+	switch (w->type) {
+	case snd_soc_dapm_spk:
+		*dw = (struct snd_soc_dapm_widget)
+			SND_SOC_DAPM_SPK(w->name, gbcodec_event_spk);
+		break;
+	case snd_soc_dapm_hp:
+		*dw = (struct snd_soc_dapm_widget)
+			SND_SOC_DAPM_HP(w->name, gbcodec_event_hp);
+		break;
+	case snd_soc_dapm_mic:
+		*dw = (struct snd_soc_dapm_widget)
+			SND_SOC_DAPM_MIC(w->name, gbcodec_event_int_mic);
+		break;
+	case snd_soc_dapm_output:
+		*dw = (struct snd_soc_dapm_widget)SND_SOC_DAPM_OUTPUT(w->name);
+		break;
+	case snd_soc_dapm_input:
+		*dw = (struct snd_soc_dapm_widget)SND_SOC_DAPM_INPUT(w->name);
+		break;
+	case snd_soc_dapm_switch:
+		*dw = (struct snd_soc_dapm_widget)
+			SND_SOC_DAPM_SWITCH_E(w->name, SND_SOC_NOPM, 0, 0,
+					    widget_kctls, gbaudio_widget_event,
+					    SND_SOC_DAPM_PRE_PMU |
+					    SND_SOC_DAPM_POST_PMD);
+		break;
+	case snd_soc_dapm_pga:
+		*dw = (struct snd_soc_dapm_widget)
+			SND_SOC_DAPM_PGA_E(w->name, SND_SOC_NOPM, 0, 0, NULL, 0,
+					   gbaudio_widget_event,
+					   SND_SOC_DAPM_PRE_PMU |
+					   SND_SOC_DAPM_POST_PMD);
+		break;
+	case snd_soc_dapm_mixer:
+		*dw = (struct snd_soc_dapm_widget)
+			SND_SOC_DAPM_MIXER_E(w->name, SND_SOC_NOPM, 0, 0, NULL,
+					   0, gbaudio_widget_event,
+					   SND_SOC_DAPM_PRE_PMU |
+					   SND_SOC_DAPM_POST_PMD);
+		break;
+	case snd_soc_dapm_mux:
+		*dw = (struct snd_soc_dapm_widget)
+			SND_SOC_DAPM_MUX_E(w->name, SND_SOC_NOPM, 0, 0,
+					 widget_kctls, gbaudio_widget_event,
+					 SND_SOC_DAPM_PRE_PMU |
+					 SND_SOC_DAPM_POST_PMD);
+		break;
+	case snd_soc_dapm_aif_in:
+		*dw = (struct snd_soc_dapm_widget)
+			SND_SOC_DAPM_AIF_IN_E(w->name, w->sname, 0,
+					      SND_SOC_NOPM,
+					      0, 0, gbaudio_widget_event,
+					      SND_SOC_DAPM_PRE_PMU |
+					      SND_SOC_DAPM_POST_PMD);
+		break;
+	case snd_soc_dapm_aif_out:
+		*dw = (struct snd_soc_dapm_widget)
+			SND_SOC_DAPM_AIF_OUT_E(w->name, w->sname, 0,
+					       SND_SOC_NOPM,
+					       0, 0, gbaudio_widget_event,
+					       SND_SOC_DAPM_PRE_PMU |
+					       SND_SOC_DAPM_POST_PMD);
+		break;
+	default:
+		ret = -EINVAL;
+		goto error;
+	}
+
+	dev_dbg(gbcodec->dev, "%s: widget of type %d created\n", dw->name,
+		dw->id);
+	return 0;
+error:
+	list_for_each_entry_safe(control, _control, &gbcodec->widget_ctl_list,
+				 list) {
+		list_del(&control->list);
+		devm_kfree(gbcodec->dev, control);
+	}
+	return ret;
+}
+
+static int gbaudio_tplg_create_dai(struct gbaudio_codec_info *gbcodec,
+				   struct snd_soc_dai_driver *gb_dai,
+				   struct gb_audio_dai *dai)
+{
+	/*
+	 * do not update name here,
+	 * append dev_id before assigning it here
+	 */
+
+	gb_dai->playback.stream_name = dai->playback.stream_name;
+	gb_dai->playback.channels_min = dai->playback.chan_min;
+	gb_dai->playback.channels_max = dai->playback.chan_max;
+	gb_dai->playback.formats = dai->playback.formats;
+	gb_dai->playback.rates = dai->playback.rates;
+	gb_dai->playback.sig_bits = dai->playback.sig_bits;
+
+	gb_dai->capture.stream_name = dai->capture.stream_name;
+	gb_dai->capture.channels_min = dai->capture.chan_min;
+	gb_dai->capture.channels_max = dai->capture.chan_max;
+	gb_dai->capture.formats = dai->capture.formats;
+	gb_dai->capture.rates = dai->capture.rates;
+	gb_dai->capture.sig_bits = dai->capture.sig_bits;
+
+	return 0;
+}
+
+static int gbaudio_tplg_process_kcontrols(struct gbaudio_codec_info *gbcodec,
+				   struct gb_audio_control *controls)
+{
+	int i, ret;
+	struct snd_kcontrol_new *dapm_kctls;
+	struct gb_audio_control *curr;
+	struct gbaudio_control *control, *_control;
+	size_t size;
+
+	size = sizeof(struct snd_kcontrol_new) * gbcodec->num_kcontrols;
+	dapm_kctls = devm_kzalloc(gbcodec->dev, size, GFP_KERNEL);
+	if (!dapm_kctls)
+		return -ENOMEM;
+
+	curr = controls;
+	for (i = 0; i < gbcodec->num_kcontrols; i++) {
+		ret = gbaudio_tplg_create_kcontrol(gbcodec, &dapm_kctls[i],
+						   curr);
+		if (ret) {
+			dev_err(gbcodec->dev, "%s:%d type not supported\n",
+				curr->name, curr->iface);
+			goto error;
+		}
+		control = devm_kzalloc(gbcodec->dev, sizeof(struct
+							   gbaudio_control),
+				      GFP_KERNEL);
+		if (!control) {
+			ret = -ENOMEM;
+			goto error;
+		}
+		control->id = curr->id;
+		control->name = curr->name;
+		if (curr->info.type == GB_AUDIO_CTL_ELEM_TYPE_ENUMERATED)
+			control->texts = (const char * const *)
+				curr->info.value.enumerated.names;
+		list_add(&control->list, &gbcodec->codec_ctl_list);
+		dev_dbg(gbcodec->dev, "%d:%s created of type %d\n", curr->id,
+			curr->name, curr->info.type);
+		curr++;
+	}
+	gbcodec->kctls = dapm_kctls;
+
+	return 0;
+error:
+	list_for_each_entry_safe(control, _control, &gbcodec->codec_ctl_list,
+				 list) {
+		list_del(&control->list);
+		devm_kfree(gbcodec->dev, control);
+	}
+	devm_kfree(gbcodec->dev, dapm_kctls);
+	return ret;
+}
+
+static int gbaudio_tplg_process_widgets(struct gbaudio_codec_info *gbcodec,
+				   struct gb_audio_widget *widgets)
+{
+	int i, ret, ncontrols;
+	struct snd_soc_dapm_widget *dapm_widgets;
+	struct gb_audio_widget *curr;
+	struct gbaudio_widget *widget, *_widget;
+	size_t size;
+
+	size = sizeof(struct snd_soc_dapm_widget) * gbcodec->num_dapm_widgets;
+	dapm_widgets = devm_kzalloc(gbcodec->dev, size, GFP_KERNEL);
+	if (!dapm_widgets)
+		return -ENOMEM;
+
+	curr = widgets;
+	for (i = 0; i < gbcodec->num_dapm_widgets; i++) {
+		ret = gbaudio_tplg_create_widget(gbcodec, &dapm_widgets[i],
+						 curr);
+		if (ret) {
+			dev_err(gbcodec->dev, "%s:%d type not supported\n",
+				curr->name, curr->type);
+			goto error;
+		}
+		widget = devm_kzalloc(gbcodec->dev, sizeof(struct
+							   gbaudio_widget),
+				      GFP_KERNEL);
+		if (!widget) {
+			ret = -ENOMEM;
+			goto error;
+		}
+		widget->id = curr->id;
+		widget->name = curr->name;
+		list_add(&widget->list, &gbcodec->widget_list);
+		ncontrols = curr->ncontrols;
+		curr++;
+		curr += ncontrols * sizeof(struct gb_audio_control);
+	}
+	gbcodec->widgets = dapm_widgets;
+
+	return 0;
+
+error:
+	list_for_each_entry_safe(widget, _widget, &gbcodec->widget_list,
+				 list) {
+		list_del(&widget->list);
+		devm_kfree(gbcodec->dev, widget);
+	}
+	devm_kfree(gbcodec->dev, dapm_widgets);
+	return ret;
+}
+
+static int gbaudio_tplg_process_dais(struct gbaudio_codec_info *gbcodec,
+				   struct gb_audio_dai *dais)
+{
+	int i, ret;
+	struct snd_soc_dai_driver *gb_dais;
+	struct gb_audio_dai *curr;
+	struct gbaudio_dai *dai, *_dai;
+	size_t size;
+	char dai_name[NAME_SIZE];
+
+	size = sizeof(struct snd_soc_dai_driver) * gbcodec->num_dais;
+	gb_dais = devm_kzalloc(gbcodec->dev, size, GFP_KERNEL);
+	if (!gb_dais)
+		return -ENOMEM;
+
+	curr = dais;
+	for (i = 0; i < gbcodec->num_dais; i++) {
+		ret = gbaudio_tplg_create_dai(gbcodec, &gb_dais[i], curr);
+		if (ret) {
+			dev_err(gbcodec->dev, "%s failed to create\n",
+				curr->name);
+			goto error;
+		}
+		/* append dev_id to dai_name */
+		snprintf(dai_name, NAME_SIZE, "%s.%d", curr->name,
+			 gbcodec->dev_id);
+		dai = gbaudio_add_dai(gbcodec, curr->data_cport, NULL,
+				      dai_name);
+		if (!dai)
+			goto error;
+		dev_err(gbcodec->dev, "%s:DAI added\n", dai->name);
+		gb_dais[i].name = dai->name;
+		curr++;
+	}
+	gbcodec->dais = gb_dais;
+
+	return 0;
+
+error:
+	list_for_each_entry_safe(dai, _dai, &gbcodec->dai_list, list) {
+		list_del(&dai->list);
+		devm_kfree(gbcodec->dev, dai);
+	}
+	devm_kfree(gbcodec->dev, gb_dais);
+	return ret;
+}
+
+static int gbaudio_tplg_process_routes(struct gbaudio_codec_info *gbcodec,
+				   struct gb_audio_route *routes)
+{
+	int i, ret;
+	struct snd_soc_dapm_route *dapm_routes;
+	struct gb_audio_route *curr;
+	size_t size;
+
+	size = sizeof(struct snd_soc_dapm_route) * gbcodec->num_dapm_routes;
+	dapm_routes = devm_kzalloc(gbcodec->dev, size, GFP_KERNEL);
+	if (!dapm_routes)
+		return -ENOMEM;
+
+
+	gbcodec->routes = dapm_routes;
+	curr = routes;
+
+	for (i = 0; i < gbcodec->num_dapm_routes; i++) {
+		dapm_routes->sink =
+			gbaudio_map_widgetid(gbcodec, curr->destination_id);
+		if (!dapm_routes->sink) {
+			dev_err(gbcodec->dev, "%d:%d:%d:%d - Invalid sink\n",
+				curr->source_id, curr->destination_id,
+				curr->control_id, curr->index);
+			ret = -EINVAL;
+			goto error;
+		}
+		dapm_routes->source =
+			gbaudio_map_widgetid(gbcodec, curr->source_id);
+		if (!dapm_routes->source) {
+			dev_err(gbcodec->dev, "%d:%d:%d:%d - Invalid source\n",
+				curr->source_id, curr->destination_id,
+				curr->control_id, curr->index);
+			ret = -EINVAL;
+			goto error;
+		}
+		dapm_routes->control =
+			gbaudio_map_controlid(gbcodec,
+						      curr->control_id,
+						      curr->index);
+		if ((curr->control_id !=  GBAUDIO_INVALID_ID) &&
+		    !dapm_routes->control) {
+			dev_err(gbcodec->dev, "%d:%d:%d:%d - Invalid control\n",
+				curr->source_id, curr->destination_id,
+				curr->control_id, curr->index);
+			ret = -EINVAL;
+			goto error;
+		}
+		dev_dbg(gbcodec->dev, "Route {%s, %s, %s}\n", dapm_routes->sink,
+			(dapm_routes->control) ? dapm_routes->control:"NULL",
+			dapm_routes->source);
+		dapm_routes++;
+		curr++;
+	}
+
+	return 0;
+
+error:
+	devm_kfree(gbcodec->dev, dapm_routes);
+	return ret;
+}
+
+static int gbaudio_tplg_process_header(struct gbaudio_codec_info *gbcodec,
+				 struct gb_audio_topology *tplg_data)
+{
+	/* fetch no. of kcontrols, widgets & routes */
+	gbcodec->num_dais = tplg_data->num_dais;
+	gbcodec->num_kcontrols = tplg_data->num_controls;
+	gbcodec->num_dapm_widgets = tplg_data->num_widgets;
+	gbcodec->num_dapm_routes = tplg_data->num_routes;
+
+	/* update block offset */
+	gbcodec->dai_offset = (unsigned long)&tplg_data->data;
+	gbcodec->control_offset = gbcodec->dai_offset + tplg_data->size_dais;
+	gbcodec->widget_offset = gbcodec->control_offset +
+		tplg_data->size_controls;
+	gbcodec->route_offset = gbcodec->widget_offset +
+		tplg_data->size_widgets;
+
+	dev_dbg(gbcodec->dev, "DAI offset is 0x%lx\n", gbcodec->dai_offset);
+	dev_dbg(gbcodec->dev, "control offset is %lx\n",
+		gbcodec->control_offset);
+	dev_dbg(gbcodec->dev, "widget offset is %lx\n", gbcodec->widget_offset);
+	dev_dbg(gbcodec->dev, "route offset is %lx\n", gbcodec->route_offset);
+
+	return 0;
+}
+
+static struct gbaudio_dai *gbaudio_allocate_dai(struct gbaudio_codec_info *gb,
+					 int data_cport,
+					 struct gb_connection *connection,
+					 const char *name)
+{
+	struct gbaudio_dai *dai;
+
+	mutex_lock(&gb->lock);
+	dai = devm_kzalloc(gb->dev, sizeof(*dai), GFP_KERNEL);
+	if (!dai) {
+		dev_err(gb->dev, "%s:DAI Malloc failure\n", name);
+		mutex_unlock(&gb->lock);
+		return NULL;
+	}
+
+	dai->data_cport = data_cport;
+	dai->connection = connection;
+
+	/* update name */
+	if (name)
+		strlcpy(dai->name, name, NAME_SIZE);
+	list_add(&dai->list, &gb->dai_list);
+	dev_dbg(gb->dev, "%d:%s: DAI added\n", data_cport, dai->name);
+	mutex_unlock(&gb->lock);
+
+	return dai;
+}
+
+struct gbaudio_dai *gbaudio_add_dai(struct gbaudio_codec_info *gbcodec,
+				    int data_cport,
+				    struct gb_connection *connection,
+				    const char *name)
+{
+	struct gbaudio_dai *dai, *_dai;
+
+	/* FIXME need to take care for multiple DAIs */
+	mutex_lock(&gbcodec->lock);
+	if (list_empty(&gbcodec->dai_list)) {
+		mutex_unlock(&gbcodec->lock);
+		return gbaudio_allocate_dai(gbcodec, data_cport, connection,
+					    name);
+	}
+
+	list_for_each_entry_safe(dai, _dai, &gbcodec->dai_list, list) {
+		if (dai->data_cport == data_cport) {
+			if (connection)
+				dai->connection = connection;
+
+			if (name)
+				strlcpy(dai->name, name, NAME_SIZE);
+			dev_dbg(gbcodec->dev, "%d:%s: DAI updated\n",
+				data_cport, dai->name);
+			mutex_unlock(&gbcodec->lock);
+			return dai;
+		}
+	}
+
+	dev_err(gbcodec->dev, "%s:DAI not found\n", name);
+	mutex_unlock(&gbcodec->lock);
+	return NULL;
+}
+
+int gbaudio_tplg_parse_data(struct gbaudio_codec_info *gbcodec,
+			       struct gb_audio_topology *tplg_data)
+{
+	int ret;
+	struct gb_audio_dai *dais;
+	struct gb_audio_control *controls;
+	struct gb_audio_widget *widgets;
+	struct gb_audio_route *routes;
+
+	if (!tplg_data)
+		return -EINVAL;
+
+	ret = gbaudio_tplg_process_header(gbcodec, tplg_data);
+	if (ret) {
+		dev_err(gbcodec->dev, "%d: Error in parsing topology header\n",
+			ret);
+		return ret;
+	}
+
+	/* process control */
+	controls = (struct gb_audio_control *)gbcodec->control_offset;
+	ret = gbaudio_tplg_process_kcontrols(gbcodec, controls);
+	if (ret) {
+		dev_err(gbcodec->dev,
+			"%d: Error in parsing controls data\n", ret);
+		return ret;
+	}
+	dev_err(gbcodec->dev, "Control parsing finished\n");
+
+	/* process DAI */
+	dais = (struct gb_audio_dai *)gbcodec->dai_offset;
+	ret = gbaudio_tplg_process_dais(gbcodec, dais);
+	if (ret) {
+		dev_err(gbcodec->dev,
+			"%d: Error in parsing DAIs data\n", ret);
+		return ret;
+	}
+	dev_err(gbcodec->dev, "DAI parsing finished\n");
+
+	/* process widgets */
+	widgets = (struct gb_audio_widget *)gbcodec->widget_offset;
+	ret = gbaudio_tplg_process_widgets(gbcodec, widgets);
+	if (ret) {
+		dev_err(gbcodec->dev,
+			"%d: Error in parsing widgets data\n", ret);
+		return ret;
+	}
+	dev_err(gbcodec->dev, "Widget parsing finished\n");
+
+	/* process route */
+	routes = (struct gb_audio_route *)gbcodec->route_offset;
+	ret = gbaudio_tplg_process_routes(gbcodec, routes);
+	if (ret) {
+		dev_err(gbcodec->dev,
+			"%d: Error in parsing routes data\n", ret);
+		return ret;
+	}
+	dev_err(gbcodec->dev, "Route parsing finished\n");
+
+	return ret;
+}
+
+void gbaudio_tplg_release(struct gbaudio_codec_info *gbcodec)
+{
+	struct gbaudio_dai *dai, *_dai;
+	struct gbaudio_control *control, *_control;
+	struct gbaudio_widget *widget, *_widget;
+
+	if (!gbcodec->topology)
+		return;
+
+	/* release kcontrols */
+	list_for_each_entry_safe(control, _control, &gbcodec->codec_ctl_list,
+				 list) {
+		list_del(&control->list);
+		devm_kfree(gbcodec->dev, control);
+	}
+	if (gbcodec->kctls)
+		devm_kfree(gbcodec->dev, gbcodec->kctls);
+
+	/* release widget controls */
+	list_for_each_entry_safe(control, _control, &gbcodec->widget_ctl_list,
+				 list) {
+		list_del(&control->list);
+		devm_kfree(gbcodec->dev, control);
+	}
+
+	/* release widgets */
+	list_for_each_entry_safe(widget, _widget, &gbcodec->widget_list,
+				 list) {
+		list_del(&widget->list);
+		devm_kfree(gbcodec->dev, widget);
+	}
+	if (gbcodec->widgets)
+		devm_kfree(gbcodec->dev, gbcodec->widgets);
+
+	/* release routes */
+	if (gbcodec->routes)
+		devm_kfree(gbcodec->dev, gbcodec->routes);
+
+	/* release DAIs */
+	mutex_lock(&gbcodec->lock);
+	list_for_each_entry_safe(dai, _dai, &gbcodec->dai_list, list) {
+		list_del(&dai->list);
+		devm_kfree(gbcodec->dev, dai);
+	}
+	mutex_unlock(&gbcodec->lock);
+}
