commit ec0ad868173da8a75121f9dc116a5d5478ff614d
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Sun Aug 25 07:54:27 2019 +0200

    staging: greybus: move core include files to include/linux/greybus/
    
    With the goal of moving the core of the greybus code out of staging, the
    include files need to be moved to include/linux/greybus.h and
    include/linux/greybus/
    
    Cc: Vaibhav Hiremath <hvaibhav.linux@gmail.com>
    Cc: Johan Hovold <johan@kernel.org>
    Cc: Vaibhav Agarwal <vaibhav.sr@gmail.com>
    Cc: Rui Miguel Silva <rmfrfs@gmail.com>
    Cc: David Lin <dtwlin@gmail.com>
    Cc: "Bryan O'Donoghue" <pure.logic@nexus-software.ie>
    Cc: greybus-dev@lists.linaro.org
    Cc: devel@driverdev.osuosl.org
    Acked-by: Mark Greer <mgreer@animalcreek.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Acked-by: Alex Elder <elder@kernel.org>
    Link: https://lore.kernel.org/r/20190825055429.18547-8-gregkh@linuxfoundation.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/fw-download.c b/drivers/staging/greybus/fw-download.c
index d3b7cccbc10d..543692c567f9 100644
--- a/drivers/staging/greybus/fw-download.c
+++ b/drivers/staging/greybus/fw-download.c
@@ -10,8 +10,8 @@
 #include <linux/jiffies.h>
 #include <linux/mutex.h>
 #include <linux/workqueue.h>
+#include <linux/greybus.h>
 #include "firmware.h"
-#include "greybus.h"
 
 /* Estimated minimum buffer size, actual size can be smaller than this */
 #define MIN_FETCH_SIZE		512

commit 863dbc52e7f0e5acd7b4883f3933543a81c474c7
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Nov 7 14:58:42 2017 +0100

    staging: greybus: Remove redundant license text
    
    Now that the SPDX tag is in all greybus files, that identifies the
    license in a specific and legally-defined manner.  So the extra GPL text
    wording can be removed as it is no longer needed at all.
    
    This is done on a quest to remove the 700+ different ways that files in
    the kernel describe the GPL license text.  And there's unneeded stuff
    like the address (sometimes incorrect) for the FSF which is never
    needed.
    
    No copyright headers or other non-license-description text was removed.
    
    Cc: Vaibhav Hiremath <hvaibhav.linux@gmail.com>
    Reviewed-by: Alex Elder <elder@linaro.org>
    Acked-by: Vaibhav Agarwal <vaibhav.sr@gmail.com>
    Acked-by: David Lin <dtwlin@gmail.com>
    Acked-by: Johan Hovold <johan@kernel.org>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Acked-by: Mark Greer <mgreer@animalcreek.com>
    Acked-by: Rui Miguel Silva <rmfrfs@gmail.com>
    Acked-by: "Bryan O'Donoghue" <pure.logic@nexus-software.ie>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/fw-download.c b/drivers/staging/greybus/fw-download.c
index 5837402ade44..d3b7cccbc10d 100644
--- a/drivers/staging/greybus/fw-download.c
+++ b/drivers/staging/greybus/fw-download.c
@@ -4,8 +4,6 @@
  *
  * Copyright 2016 Google Inc.
  * Copyright 2016 Linaro Ltd.
- *
- * Released under the GPLv2 only.
  */
 
 #include <linux/firmware.h>

commit eb50fd3a22c770f36be275295b782f3ea52e3215
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Nov 7 14:58:41 2017 +0100

    staging: greybus: add SPDX identifiers to all greybus driver files
    
    It's good to have SPDX identifiers in all files to make it easier to
    audit the kernel tree for correct licenses.
    
    Update the drivers/staging/greybus files files with the correct SPDX
    license identifier based on the license text in the file itself.  The
    SPDX identifier is a legally binding shorthand, which can be used
    instead of the full boiler plate text.
    
    This work is based on a script and data from Thomas Gleixner, Philippe
    Ombredanne, and Kate Stewart.
    
    Cc: Vaibhav Hiremath <hvaibhav.linux@gmail.com>
    Cc: "Bryan O'Donoghue" <pure.logic@nexus-software.ie>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: Philippe Ombredanne <pombredanne@nexb.com>
    Acked-by: Vaibhav Agarwal <vaibhav.sr@gmail.com>
    Acked-by: David Lin <dtwlin@gmail.com>
    Reviewed-by: Alex Elder <elder@linaro.org>
    Acked-by: Johan Hovold <johan@kernel.org>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Acked-by: Mark Greer <mgreer@animalcreek.com>
    Acked-by: Rui Miguel Silva <rmfrfs@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/fw-download.c b/drivers/staging/greybus/fw-download.c
index 8a1a413c6cb3..5837402ade44 100644
--- a/drivers/staging/greybus/fw-download.c
+++ b/drivers/staging/greybus/fw-download.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * Greybus Firmware Download Protocol Driver.
  *

commit 461ab8077d573d4a35529572c774a71e5a898a84
Author: Gioh Kim <gi-oh.kim@profitbricks.com>
Date:   Thu Feb 9 17:30:11 2017 +0100

    staging: greybus: fix "line over 80 characters" coding style issues
    
    This patch fixes only obvious lines.
    There are still more issues.
    
    Signed-off-by: Gioh Kim <gi-oh.kim@profitbricks.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/fw-download.c b/drivers/staging/greybus/fw-download.c
index 2d7246887547..8a1a413c6cb3 100644
--- a/drivers/staging/greybus/fw-download.c
+++ b/drivers/staging/greybus/fw-download.c
@@ -130,7 +130,8 @@ static void free_firmware(struct fw_download *fw_download,
 static void fw_request_timedout(struct work_struct *work)
 {
 	struct delayed_work *dwork = to_delayed_work(work);
-	struct fw_request *fw_req = container_of(dwork, struct fw_request, dwork);
+	struct fw_request *fw_req = container_of(dwork,
+						 struct fw_request, dwork);
 	struct fw_download *fw_download = fw_req->fw_download;
 
 	dev_err(fw_download->parent,
@@ -239,7 +240,8 @@ static int fw_download_find_firmware(struct gb_operation *op)
 	tag = (const char *)request->firmware_tag;
 
 	/* firmware_tag must be null-terminated */
-	if (strnlen(tag, GB_FIRMWARE_TAG_MAX_SIZE) == GB_FIRMWARE_TAG_MAX_SIZE) {
+	if (strnlen(tag, GB_FIRMWARE_TAG_MAX_SIZE) ==
+	    GB_FIRMWARE_TAG_MAX_SIZE) {
 		dev_err(fw_download->parent,
 			"firmware-tag is not null-terminated\n");
 		return -EINVAL;

commit 0675363ac7ffe27a25bf237ce2bf1e084637a3a0
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Thu Aug 11 13:27:24 2016 -0700

    greybus: firmware: s/should/must
    
    Replace 'should' with 'must' to clear the expectation a bit more.
    
    Reported-by: Alex Elder <alex.elder@linaro.org>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/fw-download.c b/drivers/staging/greybus/fw-download.c
index 1c63256b96a6..2d7246887547 100644
--- a/drivers/staging/greybus/fw-download.c
+++ b/drivers/staging/greybus/fw-download.c
@@ -238,7 +238,7 @@ static int fw_download_find_firmware(struct gb_operation *op)
 	request = op->request->payload;
 	tag = (const char *)request->firmware_tag;
 
-	/* firmware_tag should be null-terminated */
+	/* firmware_tag must be null-terminated */
 	if (strnlen(tag, GB_FIRMWARE_TAG_MAX_SIZE) == GB_FIRMWARE_TAG_MAX_SIZE) {
 		dev_err(fw_download->parent,
 			"firmware-tag is not null-terminated\n");

commit b2abeaa10d5711e7730bb07120dd60ae27d7b930
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Thu Aug 11 13:27:23 2016 -0700

    greybus: firmware: s/_LEN/_SIZE
    
    Alex Elder pointed out that the macros also count the trailing NULL
    ('\0') character and so it should be using SIZE instead of LEN.
    
    This patch makes that change.
    
    Reported-by: Alex Elder <alex.elder@linaro.org>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/fw-download.c b/drivers/staging/greybus/fw-download.c
index 96c11aac4096..1c63256b96a6 100644
--- a/drivers/staging/greybus/fw-download.c
+++ b/drivers/staging/greybus/fw-download.c
@@ -23,7 +23,7 @@ struct fw_request {
 	u8			firmware_id;
 	bool			disabled;
 	bool			timedout;
-	char			name[FW_NAME_LEN];
+	char			name[FW_NAME_SIZE];
 	const struct firmware	*fw;
 	struct list_head	node;
 
@@ -239,7 +239,7 @@ static int fw_download_find_firmware(struct gb_operation *op)
 	tag = (const char *)request->firmware_tag;
 
 	/* firmware_tag should be null-terminated */
-	if (strnlen(tag, GB_FIRMWARE_TAG_MAX_LEN) == GB_FIRMWARE_TAG_MAX_LEN) {
+	if (strnlen(tag, GB_FIRMWARE_TAG_MAX_SIZE) == GB_FIRMWARE_TAG_MAX_SIZE) {
 		dev_err(fw_download->parent,
 			"firmware-tag is not null-terminated\n");
 		return -EINVAL;

commit 769cb83704db127119d063b55091f782007368e7
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Thu Aug 11 13:27:22 2016 -0700

    greybus: firmware: Remove extra parenthesis
    
    Remove the unnecessary parenthesis.
    
    Reported-by: Alex Elder <alex.elder@linaro.org>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/fw-download.c b/drivers/staging/greybus/fw-download.c
index 16de71cd9e33..96c11aac4096 100644
--- a/drivers/staging/greybus/fw-download.c
+++ b/drivers/staging/greybus/fw-download.c
@@ -236,7 +236,7 @@ static int fw_download_find_firmware(struct gb_operation *op)
 	}
 
 	request = op->request->payload;
-	tag = (const char *)(request->firmware_tag);
+	tag = (const char *)request->firmware_tag;
 
 	/* firmware_tag should be null-terminated */
 	if (strnlen(tag, GB_FIRMWARE_TAG_MAX_LEN) == GB_FIRMWARE_TAG_MAX_LEN) {

commit 295b5269d63841183257d9da9035dd3e3fde4200
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Wed Aug 10 10:48:31 2016 -0700

    greybus: firmware: use 'tag' instead of 'firmware_tag'
    
    We already have another direct pointer for this, use that instead.
    
    Testing Done: Compiled.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/fw-download.c b/drivers/staging/greybus/fw-download.c
index 41a45ecb62b6..16de71cd9e33 100644
--- a/drivers/staging/greybus/fw-download.c
+++ b/drivers/staging/greybus/fw-download.c
@@ -245,7 +245,7 @@ static int fw_download_find_firmware(struct gb_operation *op)
 		return -EINVAL;
 	}
 
-	fw_req = find_firmware(fw_download, request->firmware_tag);
+	fw_req = find_firmware(fw_download, tag);
 	if (IS_ERR(fw_req))
 		return PTR_ERR(fw_req);
 

commit 8a704565ebda9603c294aacebb34e47cd9d9a3a0
Author: Greg Kroah-Hartman <gregkh@google.com>
Date:   Wed Jul 20 10:11:37 2016 -0700

    greybus: move all firmware prefix strings to one place
    
    The firmware prefix is hard-coded in a few different places.  Put it all
    in one handy #define, for when/if we ever decide to change it in the
    future...
    
    Testing: 'strings gb-firmware.ko gb-bootrom.ko | grep ara_' produced the
             same output before and after this patch.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>
    Reviewed-by: Viresh Kumar <viresh.kumar@linaro.org>
    Acked-by: Sandeep Patil <sspatil@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/fw-download.c b/drivers/staging/greybus/fw-download.c
index 42cbbf4ac077..41a45ecb62b6 100644
--- a/drivers/staging/greybus/fw-download.c
+++ b/drivers/staging/greybus/fw-download.c
@@ -14,8 +14,6 @@
 #include "firmware.h"
 #include "greybus.h"
 
-/* Length of the string in format: ara_%08x_%08x_%08x_%08x_%s.tftf */
-#define FW_NAME_LEN		56
 /* Estimated minimum buffer size, actual size can be smaller than this */
 #define MIN_FETCH_SIZE		512
 /* Timeout, in jiffies, within which fetch or release firmware must be called */
@@ -182,7 +180,7 @@ static struct fw_request *find_firmware(struct fw_download *fw_download,
 	fw_req->firmware_id = ret;
 
 	snprintf(fw_req->name, sizeof(fw_req->name),
-		 "ara_%08x_%08x_%08x_%08x_%s.tftf",
+		 FW_NAME_PREFIX "%08x_%08x_%08x_%08x_%s.tftf",
 		 intf->ddbl1_manufacturer_id, intf->ddbl1_product_id,
 		 intf->vendor_id, intf->product_id, tag);
 

commit c6cc8e73eb188156494e061bdb93966b0c7d9443
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Mon May 9 10:59:01 2016 +0530

    greybus: fw-download: Replace timer with delayed-work
    
    The timeout-handlers need to call routines that can sleep and those
    can't be called from interrupt context. The timer-handler is called in
    interrupt context and so will hit a BUG() in vmalloc.c.
    
    This patch moves away from timers to delayed-work, whose timeout handler
    gets called in process context and can call the sleep-able routines
    safely.
    
    Note that this issue wasn't hit earlier when the initial patch for
    timeouts was implemented due to some issues in the build arche_420. But
    with the new build arche_440, the BUG started crashing the phone on
    timeouts and so this fix is required.
    
    Tested on EVT 1.5 by triggering fake timeouts, by not sending
    release-firmware request for example. This is tested with build
    arche_440.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/fw-download.c b/drivers/staging/greybus/fw-download.c
index 0ebea37e6778..42cbbf4ac077 100644
--- a/drivers/staging/greybus/fw-download.c
+++ b/drivers/staging/greybus/fw-download.c
@@ -10,7 +10,7 @@
 #include <linux/firmware.h>
 #include <linux/jiffies.h>
 #include <linux/mutex.h>
-#include <linux/timer.h>
+#include <linux/workqueue.h>
 #include "firmware.h"
 #include "greybus.h"
 
@@ -29,7 +29,7 @@ struct fw_request {
 	const struct firmware	*fw;
 	struct list_head	node;
 
-	struct timer_list	timer;
+	struct delayed_work	dwork;
 	/* Timeout, in jiffies, within which the firmware shall download */
 	unsigned long		release_timeout_j;
 	struct kref		kref;
@@ -129,9 +129,10 @@ static void free_firmware(struct fw_download *fw_download,
 	put_fw_req(fw_req);
 }
 
-static void fw_request_timedout(unsigned long data)
+static void fw_request_timedout(struct work_struct *work)
 {
-	struct fw_request *fw_req = (struct fw_request *)data;
+	struct delayed_work *dwork = to_delayed_work(work);
+	struct fw_request *fw_req = container_of(dwork, struct fw_request, dwork);
 	struct fw_download *fw_download = fw_req->fw_download;
 
 	dev_err(fw_download->parent,
@@ -207,11 +208,8 @@ static struct fw_request *find_firmware(struct fw_download *fw_download,
 	req_count = DIV_ROUND_UP(fw_req->fw->size, MIN_FETCH_SIZE);
 	fw_req->release_timeout_j = jiffies + req_count * NEXT_REQ_TIMEOUT_J;
 
-	init_timer(&fw_req->timer);
-	fw_req->timer.function = fw_request_timedout;
-	fw_req->timer.expires = jiffies + NEXT_REQ_TIMEOUT_J;
-	fw_req->timer.data = (unsigned long)fw_req;
-	add_timer(&fw_req->timer);
+	INIT_DELAYED_WORK(&fw_req->dwork, fw_request_timedout);
+	schedule_delayed_work(&fw_req->dwork, NEXT_REQ_TIMEOUT_J);
 
 	return fw_req;
 
@@ -300,8 +298,8 @@ static int fw_download_fetch_firmware(struct gb_operation *op)
 		return -EINVAL;
 	}
 
-	/* Make sure timer handler isn't running in parallel */
-	del_timer_sync(&fw_req->timer);
+	/* Make sure work handler isn't running in parallel */
+	cancel_delayed_work_sync(&fw_req->dwork);
 
 	/* We timed-out before reaching here ? */
 	if (fw_req->disabled) {
@@ -344,7 +342,7 @@ static int fw_download_fetch_firmware(struct gb_operation *op)
 		size);
 
 	/* Refresh timeout */
-	mod_timer(&fw_req->timer, jiffies + NEXT_REQ_TIMEOUT_J);
+	schedule_delayed_work(&fw_req->dwork, NEXT_REQ_TIMEOUT_J);
 
 put_fw:
 	put_fw_req(fw_req);
@@ -377,7 +375,7 @@ static int fw_download_release_firmware(struct gb_operation *op)
 		return -EINVAL;
 	}
 
-	del_timer_sync(&fw_req->timer);
+	cancel_delayed_work_sync(&fw_req->dwork);
 
 	free_firmware(fw_download, fw_req);
 	put_fw_req(fw_req);
@@ -459,7 +457,7 @@ void gb_fw_download_connection_exit(struct gb_connection *connection)
 
 	/* Release pending firmware packages */
 	list_for_each_entry_safe(fw_req, tmp, &fw_download->fw_requests, node) {
-		del_timer_sync(&fw_req->timer);
+		cancel_delayed_work_sync(&fw_req->dwork);
 		free_firmware(fw_download, fw_req);
 		put_fw_req(fw_req);
 	}

commit 69c8763eb883a331832b58e842fa0b01321ed9d6
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Thu May 5 15:33:20 2016 +0530

    greybus: fw-download: Introduce timeouts for firmware downloads
    
    As per greybus specification, the AP can apply, implementation
    dependent, timeouts for:
    
    - The time interval between the Find Firmware Response and the first
      Fetch Firmware Request.
    - The time interval between a Fetch Firmware Response and the next Fetch
      Firmware Request.
    - The time interval between a Fetch Firmware Response and the Release
      Firmware Request.
    - The time interval between the Find Firmware Response and the Release
      Firmware Request.
    
    This patch implements those timeouts.
    
    The timeout period for the first three cases is fixed to one-second and
    the timeout for the last one is finalized at runtime, dependent on the
    total size of the firmware.
    
    There can be two possible paths now, which may race for freeing or
    getting the 'struct fw_request'. They are:
    - Request handler: initiated from the Module side.
    - Timeout handler: initiated on timeout of the programmed timer.
    
    And so a mutex is added to avoid races.
    
    Every caller which needs to access the 'struct fw_request' increments
    the reference count, so that the structure doesn't get freed in
    parallel. Once the structure is freed and reference is put by all the
    users, the structure is freed.
    
    If we timeout while waiting for a request from the Module, the AP frees
    the 'struct fw_request', but does *not* free the request-id. This is
    done to guarantee that a delayed request from the Module for the expired
    id, doesn't get access to a new 'struct fw_request' allocated later with
    the same id.
    
    Tested with gbsim by hacking its code to delay the release request and
    indefinitely fetch the same section of the firmware package. Both timed
    out on the AP side and the 'struct fw_request' is free properly. Further
    requests work fine after few are timed out. And rmmod (followed by more
    similar testing) works just fine.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/fw-download.c b/drivers/staging/greybus/fw-download.c
index 6bd26180bca6..0ebea37e6778 100644
--- a/drivers/staging/greybus/fw-download.c
+++ b/drivers/staging/greybus/fw-download.c
@@ -8,18 +8,30 @@
  */
 
 #include <linux/firmware.h>
+#include <linux/jiffies.h>
+#include <linux/mutex.h>
+#include <linux/timer.h>
 #include "firmware.h"
 #include "greybus.h"
 
 /* Length of the string in format: ara_%08x_%08x_%08x_%08x_%s.tftf */
 #define FW_NAME_LEN		56
+/* Estimated minimum buffer size, actual size can be smaller than this */
+#define MIN_FETCH_SIZE		512
+/* Timeout, in jiffies, within which fetch or release firmware must be called */
+#define NEXT_REQ_TIMEOUT_J	msecs_to_jiffies(1000)
 
 struct fw_request {
 	u8			firmware_id;
+	bool			disabled;
+	bool			timedout;
 	char			name[FW_NAME_LEN];
 	const struct firmware	*fw;
 	struct list_head	node;
 
+	struct timer_list	timer;
+	/* Timeout, in jiffies, within which the firmware shall download */
+	unsigned long		release_timeout_j;
 	struct kref		kref;
 	struct fw_download	*fw_download;
 };
@@ -29,6 +41,7 @@ struct fw_download {
 	struct gb_connection	*connection;
 	struct list_head	fw_requests;
 	struct ida		id_map;
+	struct mutex		mutex;
 };
 
 static void fw_req_release(struct kref *kref)
@@ -39,50 +52,120 @@ static void fw_req_release(struct kref *kref)
 		fw_req->name);
 
 	release_firmware(fw_req->fw);
-	ida_simple_remove(&fw_req->fw_download->id_map, fw_req->firmware_id);
+
+	/*
+	 * The request timed out and the module may send a fetch-fw or
+	 * release-fw request later. Lets block the id we allocated for this
+	 * request, so that the AP doesn't refer to a later fw-request (with
+	 * same firmware_id) for the old timedout fw-request.
+	 *
+	 * NOTE:
+	 *
+	 * This also means that after 255 timeouts we will fail to service new
+	 * firmware downloads. But what else can we do in that case anyway? Lets
+	 * just hope that it never happens.
+	 */
+	if (!fw_req->timedout)
+		ida_simple_remove(&fw_req->fw_download->id_map,
+				  fw_req->firmware_id);
+
 	kfree(fw_req);
 }
 
+/*
+ * Incoming requests are serialized for a connection, and the only race possible
+ * is between the timeout handler freeing this and an incoming request.
+ *
+ * The operations on the fw-request list are protected by the mutex and
+ * get_fw_req() increments the reference count before returning a fw_req pointer
+ * to the users.
+ *
+ * free_firmware() also takes the mutex while removing an entry from the list,
+ * it guarantees that every user of fw_req has taken a kref-reference by now and
+ * we wouldn't have any new users.
+ *
+ * Once the last user drops the reference, the fw_req structure is freed.
+ */
+static void put_fw_req(struct fw_request *fw_req)
+{
+	kref_put(&fw_req->kref, fw_req_release);
+}
+
 /* Caller must call put_fw_req() after using struct fw_request */
 static struct fw_request *get_fw_req(struct fw_download *fw_download,
 				     u8 firmware_id)
 {
 	struct fw_request *fw_req;
 
+	mutex_lock(&fw_download->mutex);
+
 	list_for_each_entry(fw_req, &fw_download->fw_requests, node) {
 		if (fw_req->firmware_id == firmware_id) {
 			kref_get(&fw_req->kref);
-			return fw_req;
+			goto unlock;
 		}
 	}
 
-	return NULL;
-}
+	fw_req = NULL;
 
-/*
- * Incoming requests are serialized for a connection, and this will never be
- * racy.
- */
-static void put_fw_req(struct fw_request *fw_req)
-{
-	kref_put(&fw_req->kref, fw_req_release);
+unlock:
+	mutex_unlock(&fw_download->mutex);
+
+	return fw_req;
 }
 
 static void free_firmware(struct fw_download *fw_download,
 			  struct fw_request *fw_req)
 {
+	/* Already disabled from timeout handlers */
+	if (fw_req->disabled)
+		return;
+
+	mutex_lock(&fw_download->mutex);
 	list_del(&fw_req->node);
+	mutex_unlock(&fw_download->mutex);
 
+	fw_req->disabled = true;
 	put_fw_req(fw_req);
 }
 
+static void fw_request_timedout(unsigned long data)
+{
+	struct fw_request *fw_req = (struct fw_request *)data;
+	struct fw_download *fw_download = fw_req->fw_download;
+
+	dev_err(fw_download->parent,
+		"Timed out waiting for fetch / release firmware requests: %u\n",
+		fw_req->firmware_id);
+
+	fw_req->timedout = true;
+	free_firmware(fw_download, fw_req);
+}
+
+static int exceeds_release_timeout(struct fw_request *fw_req)
+{
+	struct fw_download *fw_download = fw_req->fw_download;
+
+	if (time_before(jiffies, fw_req->release_timeout_j))
+		return 0;
+
+	dev_err(fw_download->parent,
+		"Firmware download didn't finish in time, abort: %d\n",
+		fw_req->firmware_id);
+
+	fw_req->timedout = true;
+	free_firmware(fw_download, fw_req);
+
+	return -ETIMEDOUT;
+}
+
 /* This returns path of the firmware blob on the disk */
 static struct fw_request *find_firmware(struct fw_download *fw_download,
 					const char *tag)
 {
 	struct gb_interface *intf = fw_download->connection->bundle->intf;
 	struct fw_request *fw_req;
-	int ret;
+	int ret, req_count;
 
 	fw_req = kzalloc(sizeof(*fw_req), GFP_KERNEL);
 	if (!fw_req)
@@ -115,7 +198,20 @@ static struct fw_request *find_firmware(struct fw_download *fw_download,
 
 	fw_req->fw_download = fw_download;
 	kref_init(&fw_req->kref);
+
+	mutex_lock(&fw_download->mutex);
 	list_add(&fw_req->node, &fw_download->fw_requests);
+	mutex_unlock(&fw_download->mutex);
+
+	/* Timeout, in jiffies, within which firmware should get loaded */
+	req_count = DIV_ROUND_UP(fw_req->fw->size, MIN_FETCH_SIZE);
+	fw_req->release_timeout_j = jiffies + req_count * NEXT_REQ_TIMEOUT_J;
+
+	init_timer(&fw_req->timer);
+	fw_req->timer.function = fw_request_timedout;
+	fw_req->timer.expires = jiffies + NEXT_REQ_TIMEOUT_J;
+	fw_req->timer.data = (unsigned long)fw_req;
+	add_timer(&fw_req->timer);
 
 	return fw_req;
 
@@ -204,6 +300,24 @@ static int fw_download_fetch_firmware(struct gb_operation *op)
 		return -EINVAL;
 	}
 
+	/* Make sure timer handler isn't running in parallel */
+	del_timer_sync(&fw_req->timer);
+
+	/* We timed-out before reaching here ? */
+	if (fw_req->disabled) {
+		ret = -ETIMEDOUT;
+		goto put_fw;
+	}
+
+	/*
+	 * Firmware download must finish within a limited time interval. If it
+	 * doesn't, then we might have a buggy Module on the other side. Abort
+	 * download.
+	 */
+	ret = exceeds_release_timeout(fw_req);
+	if (ret)
+		goto put_fw;
+
 	fw = fw_req->fw;
 
 	if (offset >= fw->size || size > fw->size - offset) {
@@ -229,6 +343,9 @@ static int fw_download_fetch_firmware(struct gb_operation *op)
 		"responding with firmware (offs = %u, size = %u)\n", offset,
 		size);
 
+	/* Refresh timeout */
+	mod_timer(&fw_req->timer, jiffies + NEXT_REQ_TIMEOUT_J);
+
 put_fw:
 	put_fw_req(fw_req);
 
@@ -260,6 +377,8 @@ static int fw_download_release_firmware(struct gb_operation *op)
 		return -EINVAL;
 	}
 
+	del_timer_sync(&fw_req->timer);
+
 	free_firmware(fw_download, fw_req);
 	put_fw_req(fw_req);
 
@@ -303,6 +422,7 @@ int gb_fw_download_connection_init(struct gb_connection *connection)
 	ida_init(&fw_download->id_map);
 	gb_connection_set_data(connection, fw_download);
 	fw_download->connection = connection;
+	mutex_init(&fw_download->mutex);
 
 	ret = gb_connection_enable(connection);
 	if (ret)
@@ -328,9 +448,21 @@ void gb_fw_download_connection_exit(struct gb_connection *connection)
 	fw_download = gb_connection_get_data(connection);
 	gb_connection_disable(fw_download->connection);
 
+	/*
+	 * Make sure we have a reference to the pending requests, before they
+	 * are freed from the timeout handler.
+	 */
+	mutex_lock(&fw_download->mutex);
+	list_for_each_entry(fw_req, &fw_download->fw_requests, node)
+		kref_get(&fw_req->kref);
+	mutex_unlock(&fw_download->mutex);
+
 	/* Release pending firmware packages */
-	list_for_each_entry_safe(fw_req, tmp, &fw_download->fw_requests, node)
+	list_for_each_entry_safe(fw_req, tmp, &fw_download->fw_requests, node) {
+		del_timer_sync(&fw_req->timer);
 		free_firmware(fw_download, fw_req);
+		put_fw_req(fw_req);
+	}
 
 	ida_destroy(&fw_download->id_map);
 	kfree(fw_download);

commit f63a896e532b12f9104749b13861080981b64bad
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Thu May 5 15:33:19 2016 +0530

    greybus: fw-download: Manage firmware requests with kref
    
    This patch updates the fw-download core to manage firmware requests with
    kref. This is required for the next patch, which will introduce timeouts
    for firmware downloads.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/fw-download.c b/drivers/staging/greybus/fw-download.c
index e60abde2d704..6bd26180bca6 100644
--- a/drivers/staging/greybus/fw-download.c
+++ b/drivers/staging/greybus/fw-download.c
@@ -19,6 +19,9 @@ struct fw_request {
 	char			name[FW_NAME_LEN];
 	const struct firmware	*fw;
 	struct list_head	node;
+
+	struct kref		kref;
+	struct fw_download	*fw_download;
 };
 
 struct fw_download {
@@ -28,26 +31,49 @@ struct fw_download {
 	struct ida		id_map;
 };
 
-static struct fw_request *match_firmware(struct fw_download *fw_download,
-					 u8 firmware_id)
+static void fw_req_release(struct kref *kref)
+{
+	struct fw_request *fw_req = container_of(kref, struct fw_request, kref);
+
+	dev_dbg(fw_req->fw_download->parent, "firmware %s released\n",
+		fw_req->name);
+
+	release_firmware(fw_req->fw);
+	ida_simple_remove(&fw_req->fw_download->id_map, fw_req->firmware_id);
+	kfree(fw_req);
+}
+
+/* Caller must call put_fw_req() after using struct fw_request */
+static struct fw_request *get_fw_req(struct fw_download *fw_download,
+				     u8 firmware_id)
 {
 	struct fw_request *fw_req;
 
 	list_for_each_entry(fw_req, &fw_download->fw_requests, node) {
-		if (fw_req->firmware_id == firmware_id)
+		if (fw_req->firmware_id == firmware_id) {
+			kref_get(&fw_req->kref);
 			return fw_req;
+		}
 	}
 
 	return NULL;
 }
 
+/*
+ * Incoming requests are serialized for a connection, and this will never be
+ * racy.
+ */
+static void put_fw_req(struct fw_request *fw_req)
+{
+	kref_put(&fw_req->kref, fw_req_release);
+}
+
 static void free_firmware(struct fw_download *fw_download,
 			  struct fw_request *fw_req)
 {
 	list_del(&fw_req->node);
-	release_firmware(fw_req->fw);
-	ida_simple_remove(&fw_download->id_map, fw_req->firmware_id);
-	kfree(fw_req);
+
+	put_fw_req(fw_req);
 }
 
 /* This returns path of the firmware blob on the disk */
@@ -87,6 +113,8 @@ static struct fw_request *find_firmware(struct fw_download *fw_download,
 		goto err_free_id;
 	}
 
+	fw_req->fw_download = fw_download;
+	kref_init(&fw_req->kref);
 	list_add(&fw_req->node, &fw_download->fw_requests);
 
 	return fw_req;
@@ -155,6 +183,7 @@ static int fw_download_fetch_firmware(struct gb_operation *op)
 	const struct firmware *fw;
 	unsigned int offset, size;
 	u8 firmware_id;
+	int ret = 0;
 
 	if (op->request->payload_size != sizeof(*request)) {
 		dev_err(fw_download->parent,
@@ -168,7 +197,7 @@ static int fw_download_fetch_firmware(struct gb_operation *op)
 	size = le32_to_cpu(request->size);
 	firmware_id = request->firmware_id;
 
-	fw_req = match_firmware(fw_download, firmware_id);
+	fw_req = get_fw_req(fw_download, firmware_id);
 	if (!fw_req) {
 		dev_err(fw_download->parent,
 			"firmware not available for id: %02u\n", firmware_id);
@@ -181,14 +210,16 @@ static int fw_download_fetch_firmware(struct gb_operation *op)
 		dev_err(fw_download->parent,
 			"bad fetch firmware request (offs = %u, size = %u)\n",
 			offset, size);
-		return -EINVAL;
+		ret = -EINVAL;
+		goto put_fw;
 	}
 
 	if (!gb_operation_response_alloc(op, sizeof(*response) + size,
 					 GFP_KERNEL)) {
 		dev_err(fw_download->parent,
 			"error allocating fetch firmware response\n");
-		return -ENOMEM;
+		ret = -ENOMEM;
+		goto put_fw;
 	}
 
 	response = op->response->payload;
@@ -198,7 +229,10 @@ static int fw_download_fetch_firmware(struct gb_operation *op)
 		"responding with firmware (offs = %u, size = %u)\n", offset,
 		size);
 
-	return 0;
+put_fw:
+	put_fw_req(fw_req);
+
+	return ret;
 }
 
 static int fw_download_release_firmware(struct gb_operation *op)
@@ -219,7 +253,7 @@ static int fw_download_release_firmware(struct gb_operation *op)
 	request = op->request->payload;
 	firmware_id = request->firmware_id;
 
-	fw_req = match_firmware(fw_download, firmware_id);
+	fw_req = get_fw_req(fw_download, firmware_id);
 	if (!fw_req) {
 		dev_err(fw_download->parent,
 			"firmware not available for id: %02u\n", firmware_id);
@@ -227,6 +261,7 @@ static int fw_download_release_firmware(struct gb_operation *op)
 	}
 
 	free_firmware(fw_download, fw_req);
+	put_fw_req(fw_req);
 
 	dev_dbg(fw_download->parent, "release firmware\n");
 

commit 7557d0481bdeed86780c073e591df0330ec88a9e
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Mon May 2 10:51:49 2016 +0530

    greybus: fw-download: Create a macro for length of firmware file's name
    
    Create a macro representing the length of the firmware file's name and
    use that instead of using magic number in the code.
    
    Suggested-by: Greg Kroah-Hartman <gregkh@google.com>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/fw-download.c b/drivers/staging/greybus/fw-download.c
index 836b02b9d7c6..e60abde2d704 100644
--- a/drivers/staging/greybus/fw-download.c
+++ b/drivers/staging/greybus/fw-download.c
@@ -11,9 +11,12 @@
 #include "firmware.h"
 #include "greybus.h"
 
+/* Length of the string in format: ara_%08x_%08x_%08x_%08x_%s.tftf */
+#define FW_NAME_LEN		56
+
 struct fw_request {
 	u8			firmware_id;
-	char			name[56]; /* ara_%08x_%08x_%08x_%08x_%s.tftf */
+	char			name[FW_NAME_LEN];
 	const struct firmware	*fw;
 	struct list_head	node;
 };

commit cca22207673896262443c72f19b049552d65f88e
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Thu Apr 28 10:06:38 2016 +0530

    greybus: firmware: Add firmware-download protocol driver
    
    This patch adds Firmware Download Protocol support to firmware core,
    which allows an Interface to download a firmware package over Unipro.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Reviewed-by: Jun Li <li_jun@projectara.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/fw-download.c b/drivers/staging/greybus/fw-download.c
new file mode 100644
index 000000000000..836b02b9d7c6
--- /dev/null
+++ b/drivers/staging/greybus/fw-download.c
@@ -0,0 +1,299 @@
+/*
+ * Greybus Firmware Download Protocol Driver.
+ *
+ * Copyright 2016 Google Inc.
+ * Copyright 2016 Linaro Ltd.
+ *
+ * Released under the GPLv2 only.
+ */
+
+#include <linux/firmware.h>
+#include "firmware.h"
+#include "greybus.h"
+
+struct fw_request {
+	u8			firmware_id;
+	char			name[56]; /* ara_%08x_%08x_%08x_%08x_%s.tftf */
+	const struct firmware	*fw;
+	struct list_head	node;
+};
+
+struct fw_download {
+	struct device		*parent;
+	struct gb_connection	*connection;
+	struct list_head	fw_requests;
+	struct ida		id_map;
+};
+
+static struct fw_request *match_firmware(struct fw_download *fw_download,
+					 u8 firmware_id)
+{
+	struct fw_request *fw_req;
+
+	list_for_each_entry(fw_req, &fw_download->fw_requests, node) {
+		if (fw_req->firmware_id == firmware_id)
+			return fw_req;
+	}
+
+	return NULL;
+}
+
+static void free_firmware(struct fw_download *fw_download,
+			  struct fw_request *fw_req)
+{
+	list_del(&fw_req->node);
+	release_firmware(fw_req->fw);
+	ida_simple_remove(&fw_download->id_map, fw_req->firmware_id);
+	kfree(fw_req);
+}
+
+/* This returns path of the firmware blob on the disk */
+static struct fw_request *find_firmware(struct fw_download *fw_download,
+					const char *tag)
+{
+	struct gb_interface *intf = fw_download->connection->bundle->intf;
+	struct fw_request *fw_req;
+	int ret;
+
+	fw_req = kzalloc(sizeof(*fw_req), GFP_KERNEL);
+	if (!fw_req)
+		return ERR_PTR(-ENOMEM);
+
+	/* Allocate ids from 1 to 255 (u8-max), 0 is an invalid id */
+	ret = ida_simple_get(&fw_download->id_map, 1, 256, GFP_KERNEL);
+	if (ret < 0) {
+		dev_err(fw_download->parent,
+			"failed to allocate firmware id (%d)\n", ret);
+		goto err_free_req;
+	}
+	fw_req->firmware_id = ret;
+
+	snprintf(fw_req->name, sizeof(fw_req->name),
+		 "ara_%08x_%08x_%08x_%08x_%s.tftf",
+		 intf->ddbl1_manufacturer_id, intf->ddbl1_product_id,
+		 intf->vendor_id, intf->product_id, tag);
+
+	dev_info(fw_download->parent, "Requested firmware package '%s'\n",
+		 fw_req->name);
+
+	ret = request_firmware(&fw_req->fw, fw_req->name, fw_download->parent);
+	if (ret) {
+		dev_err(fw_download->parent,
+			"firmware request failed for %s (%d)\n", fw_req->name,
+			ret);
+		goto err_free_id;
+	}
+
+	list_add(&fw_req->node, &fw_download->fw_requests);
+
+	return fw_req;
+
+err_free_id:
+	ida_simple_remove(&fw_download->id_map, fw_req->firmware_id);
+err_free_req:
+	kfree(fw_req);
+
+	return ERR_PTR(ret);
+}
+
+static int fw_download_find_firmware(struct gb_operation *op)
+{
+	struct gb_connection *connection = op->connection;
+	struct fw_download *fw_download = gb_connection_get_data(connection);
+	struct gb_fw_download_find_firmware_request *request;
+	struct gb_fw_download_find_firmware_response *response;
+	struct fw_request *fw_req;
+	const char *tag;
+
+	if (op->request->payload_size != sizeof(*request)) {
+		dev_err(fw_download->parent,
+			"illegal size of find firmware request (%zu != %zu)\n",
+			op->request->payload_size, sizeof(*request));
+		return -EINVAL;
+	}
+
+	request = op->request->payload;
+	tag = (const char *)(request->firmware_tag);
+
+	/* firmware_tag should be null-terminated */
+	if (strnlen(tag, GB_FIRMWARE_TAG_MAX_LEN) == GB_FIRMWARE_TAG_MAX_LEN) {
+		dev_err(fw_download->parent,
+			"firmware-tag is not null-terminated\n");
+		return -EINVAL;
+	}
+
+	fw_req = find_firmware(fw_download, request->firmware_tag);
+	if (IS_ERR(fw_req))
+		return PTR_ERR(fw_req);
+
+	if (!gb_operation_response_alloc(op, sizeof(*response), GFP_KERNEL)) {
+		dev_err(fw_download->parent, "error allocating response\n");
+		free_firmware(fw_download, fw_req);
+		return -ENOMEM;
+	}
+
+	response = op->response->payload;
+	response->firmware_id = fw_req->firmware_id;
+	response->size = cpu_to_le32(fw_req->fw->size);
+
+	dev_dbg(fw_download->parent,
+		"firmware size is %zu bytes\n", fw_req->fw->size);
+
+	return 0;
+}
+
+static int fw_download_fetch_firmware(struct gb_operation *op)
+{
+	struct gb_connection *connection = op->connection;
+	struct fw_download *fw_download = gb_connection_get_data(connection);
+	struct gb_fw_download_fetch_firmware_request *request;
+	struct gb_fw_download_fetch_firmware_response *response;
+	struct fw_request *fw_req;
+	const struct firmware *fw;
+	unsigned int offset, size;
+	u8 firmware_id;
+
+	if (op->request->payload_size != sizeof(*request)) {
+		dev_err(fw_download->parent,
+			"Illegal size of fetch firmware request (%zu %zu)\n",
+			op->request->payload_size, sizeof(*request));
+		return -EINVAL;
+	}
+
+	request = op->request->payload;
+	offset = le32_to_cpu(request->offset);
+	size = le32_to_cpu(request->size);
+	firmware_id = request->firmware_id;
+
+	fw_req = match_firmware(fw_download, firmware_id);
+	if (!fw_req) {
+		dev_err(fw_download->parent,
+			"firmware not available for id: %02u\n", firmware_id);
+		return -EINVAL;
+	}
+
+	fw = fw_req->fw;
+
+	if (offset >= fw->size || size > fw->size - offset) {
+		dev_err(fw_download->parent,
+			"bad fetch firmware request (offs = %u, size = %u)\n",
+			offset, size);
+		return -EINVAL;
+	}
+
+	if (!gb_operation_response_alloc(op, sizeof(*response) + size,
+					 GFP_KERNEL)) {
+		dev_err(fw_download->parent,
+			"error allocating fetch firmware response\n");
+		return -ENOMEM;
+	}
+
+	response = op->response->payload;
+	memcpy(response->data, fw->data + offset, size);
+
+	dev_dbg(fw_download->parent,
+		"responding with firmware (offs = %u, size = %u)\n", offset,
+		size);
+
+	return 0;
+}
+
+static int fw_download_release_firmware(struct gb_operation *op)
+{
+	struct gb_connection *connection = op->connection;
+	struct fw_download *fw_download = gb_connection_get_data(connection);
+	struct gb_fw_download_release_firmware_request *request;
+	struct fw_request *fw_req;
+	u8 firmware_id;
+
+	if (op->request->payload_size != sizeof(*request)) {
+		dev_err(fw_download->parent,
+			"Illegal size of release firmware request (%zu %zu)\n",
+			op->request->payload_size, sizeof(*request));
+		return -EINVAL;
+	}
+
+	request = op->request->payload;
+	firmware_id = request->firmware_id;
+
+	fw_req = match_firmware(fw_download, firmware_id);
+	if (!fw_req) {
+		dev_err(fw_download->parent,
+			"firmware not available for id: %02u\n", firmware_id);
+		return -EINVAL;
+	}
+
+	free_firmware(fw_download, fw_req);
+
+	dev_dbg(fw_download->parent, "release firmware\n");
+
+	return 0;
+}
+
+int gb_fw_download_request_handler(struct gb_operation *op)
+{
+	u8 type = op->type;
+
+	switch (type) {
+	case GB_FW_DOWNLOAD_TYPE_FIND_FIRMWARE:
+		return fw_download_find_firmware(op);
+	case GB_FW_DOWNLOAD_TYPE_FETCH_FIRMWARE:
+		return fw_download_fetch_firmware(op);
+	case GB_FW_DOWNLOAD_TYPE_RELEASE_FIRMWARE:
+		return fw_download_release_firmware(op);
+	default:
+		dev_err(&op->connection->bundle->dev,
+			"unsupported request: %u\n", type);
+		return -EINVAL;
+	}
+}
+
+int gb_fw_download_connection_init(struct gb_connection *connection)
+{
+	struct fw_download *fw_download;
+	int ret;
+
+	if (!connection)
+		return 0;
+
+	fw_download = kzalloc(sizeof(*fw_download), GFP_KERNEL);
+	if (!fw_download)
+		return -ENOMEM;
+
+	fw_download->parent = &connection->bundle->dev;
+	INIT_LIST_HEAD(&fw_download->fw_requests);
+	ida_init(&fw_download->id_map);
+	gb_connection_set_data(connection, fw_download);
+	fw_download->connection = connection;
+
+	ret = gb_connection_enable(connection);
+	if (ret)
+		goto err_destroy_id_map;
+
+	return 0;
+
+err_destroy_id_map:
+	ida_destroy(&fw_download->id_map);
+	kfree(fw_download);
+
+	return ret;
+}
+
+void gb_fw_download_connection_exit(struct gb_connection *connection)
+{
+	struct fw_download *fw_download;
+	struct fw_request *fw_req, *tmp;
+
+	if (!connection)
+		return;
+
+	fw_download = gb_connection_get_data(connection);
+	gb_connection_disable(fw_download->connection);
+
+	/* Release pending firmware packages */
+	list_for_each_entry_safe(fw_req, tmp, &fw_download->fw_requests, node)
+		free_firmware(fw_download, fw_req);
+
+	ida_destroy(&fw_download->id_map);
+	kfree(fw_download);
+}
