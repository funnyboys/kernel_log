commit ec0ad868173da8a75121f9dc116a5d5478ff614d
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Sun Aug 25 07:54:27 2019 +0200

    staging: greybus: move core include files to include/linux/greybus/
    
    With the goal of moving the core of the greybus code out of staging, the
    include files need to be moved to include/linux/greybus.h and
    include/linux/greybus/
    
    Cc: Vaibhav Hiremath <hvaibhav.linux@gmail.com>
    Cc: Johan Hovold <johan@kernel.org>
    Cc: Vaibhav Agarwal <vaibhav.sr@gmail.com>
    Cc: Rui Miguel Silva <rmfrfs@gmail.com>
    Cc: David Lin <dtwlin@gmail.com>
    Cc: "Bryan O'Donoghue" <pure.logic@nexus-software.ie>
    Cc: greybus-dev@lists.linaro.org
    Cc: devel@driverdev.osuosl.org
    Acked-by: Mark Greer <mgreer@animalcreek.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Acked-by: Alex Elder <elder@kernel.org>
    Link: https://lore.kernel.org/r/20190825055429.18547-8-gregkh@linuxfoundation.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/bootrom.c b/drivers/staging/greybus/bootrom.c
index 402e6360834f..a8efb86de140 100644
--- a/drivers/staging/greybus/bootrom.c
+++ b/drivers/staging/greybus/bootrom.c
@@ -10,8 +10,8 @@
 #include <linux/jiffies.h>
 #include <linux/mutex.h>
 #include <linux/workqueue.h>
+#include <linux/greybus.h>
 
-#include "greybus.h"
 #include "firmware.h"
 
 /* Timeout, in jiffies, within which the next request must be received */

commit 8478c35a858c75bf2b00917009ba1b46c1b9b7b4
Author: Cristian Sicilia <sicilia.cristian@gmail.com>
Date:   Sun Nov 25 17:58:15 2018 +0100

    staging: greybus: Parenthesis alignment
    
    Some parameters are aligned with parentheses.
    Some parentheses was opened at end of line.
    
    Signed-off-by: Cristian Sicilia <sicilia.cristian@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/bootrom.c b/drivers/staging/greybus/bootrom.c
index e85ffae85dff..402e6360834f 100644
--- a/drivers/staging/greybus/bootrom.c
+++ b/drivers/staging/greybus/bootrom.c
@@ -86,7 +86,8 @@ static void gb_bootrom_timedout(struct work_struct *work)
 }
 
 static void gb_bootrom_set_timeout(struct gb_bootrom *bootrom,
-			enum next_request_type next, unsigned long timeout)
+				   enum next_request_type next,
+				   unsigned long timeout)
 {
 	bootrom->next_request = next;
 	schedule_delayed_work(&bootrom->dwork, msecs_to_jiffies(timeout));
@@ -175,7 +176,7 @@ static int find_firmware(struct gb_bootrom *bootrom, u8 stage)
 		 firmware_name);
 
 	rc = request_firmware(&bootrom->fw, firmware_name,
-		&connection->bundle->dev);
+			      &connection->bundle->dev);
 	if (rc) {
 		dev_err(&connection->bundle->dev,
 			"failed to find %s firmware (%d)\n", firmware_name, rc);
@@ -274,7 +275,7 @@ static int gb_bootrom_get_firmware(struct gb_operation *op)
 
 	if (offset >= fw->size || size > fw->size - offset) {
 		dev_warn(dev, "bad firmware request (offs = %u, size = %u)\n",
-				offset, size);
+			 offset, size);
 		ret = -EINVAL;
 		goto unlock;
 	}
@@ -387,15 +388,15 @@ static int gb_bootrom_get_version(struct gb_bootrom *bootrom)
 				sizeof(response));
 	if (ret) {
 		dev_err(&bundle->dev,
-				"failed to get protocol version: %d\n",
-				ret);
+			"failed to get protocol version: %d\n",
+			ret);
 		return ret;
 	}
 
 	if (response.major > request.major) {
 		dev_err(&bundle->dev,
-				"unsupported major protocol version (%u > %u)\n",
-				response.major, request.major);
+			"unsupported major protocol version (%u > %u)\n",
+			response.major, request.major);
 		return -ENOTSUPP;
 	}
 
@@ -403,13 +404,13 @@ static int gb_bootrom_get_version(struct gb_bootrom *bootrom)
 	bootrom->protocol_minor = response.minor;
 
 	dev_dbg(&bundle->dev, "%s - %u.%u\n", __func__, response.major,
-			response.minor);
+		response.minor);
 
 	return 0;
 }
 
 static int gb_bootrom_probe(struct gb_bundle *bundle,
-					const struct greybus_bundle_id *id)
+			    const struct greybus_bundle_id *id)
 {
 	struct greybus_descriptor_cport *cport_desc;
 	struct gb_connection *connection;
@@ -428,8 +429,8 @@ static int gb_bootrom_probe(struct gb_bundle *bundle,
 		return -ENOMEM;
 
 	connection = gb_connection_create(bundle,
-						le16_to_cpu(cport_desc->id),
-						gb_bootrom_request_handler);
+					  le16_to_cpu(cport_desc->id),
+					  gb_bootrom_request_handler);
 	if (IS_ERR(connection)) {
 		ret = PTR_ERR(connection);
 		goto err_free_bootrom;
@@ -466,7 +467,7 @@ static int gb_bootrom_probe(struct gb_bundle *bundle,
 				NULL, 0);
 	if (ret) {
 		dev_err(&connection->bundle->dev,
-				"failed to send AP READY: %d\n", ret);
+			"failed to send AP READY: %d\n", ret);
 		goto err_cancel_timeout;
 	}
 

commit 863dbc52e7f0e5acd7b4883f3933543a81c474c7
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Nov 7 14:58:42 2017 +0100

    staging: greybus: Remove redundant license text
    
    Now that the SPDX tag is in all greybus files, that identifies the
    license in a specific and legally-defined manner.  So the extra GPL text
    wording can be removed as it is no longer needed at all.
    
    This is done on a quest to remove the 700+ different ways that files in
    the kernel describe the GPL license text.  And there's unneeded stuff
    like the address (sometimes incorrect) for the FSF which is never
    needed.
    
    No copyright headers or other non-license-description text was removed.
    
    Cc: Vaibhav Hiremath <hvaibhav.linux@gmail.com>
    Reviewed-by: Alex Elder <elder@linaro.org>
    Acked-by: Vaibhav Agarwal <vaibhav.sr@gmail.com>
    Acked-by: David Lin <dtwlin@gmail.com>
    Acked-by: Johan Hovold <johan@kernel.org>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Acked-by: Mark Greer <mgreer@animalcreek.com>
    Acked-by: Rui Miguel Silva <rmfrfs@gmail.com>
    Acked-by: "Bryan O'Donoghue" <pure.logic@nexus-software.ie>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/bootrom.c b/drivers/staging/greybus/bootrom.c
index 6fd1ce76fa0e..e85ffae85dff 100644
--- a/drivers/staging/greybus/bootrom.c
+++ b/drivers/staging/greybus/bootrom.c
@@ -4,8 +4,6 @@
  *
  * Copyright 2016 Google Inc.
  * Copyright 2016 Linaro Ltd.
- *
- * Released under the GPLv2 only.
  */
 
 #include <linux/firmware.h>

commit eb50fd3a22c770f36be275295b782f3ea52e3215
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Nov 7 14:58:41 2017 +0100

    staging: greybus: add SPDX identifiers to all greybus driver files
    
    It's good to have SPDX identifiers in all files to make it easier to
    audit the kernel tree for correct licenses.
    
    Update the drivers/staging/greybus files files with the correct SPDX
    license identifier based on the license text in the file itself.  The
    SPDX identifier is a legally binding shorthand, which can be used
    instead of the full boiler plate text.
    
    This work is based on a script and data from Thomas Gleixner, Philippe
    Ombredanne, and Kate Stewart.
    
    Cc: Vaibhav Hiremath <hvaibhav.linux@gmail.com>
    Cc: "Bryan O'Donoghue" <pure.logic@nexus-software.ie>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: Philippe Ombredanne <pombredanne@nexb.com>
    Acked-by: Vaibhav Agarwal <vaibhav.sr@gmail.com>
    Acked-by: David Lin <dtwlin@gmail.com>
    Reviewed-by: Alex Elder <elder@linaro.org>
    Acked-by: Johan Hovold <johan@kernel.org>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Acked-by: Mark Greer <mgreer@animalcreek.com>
    Acked-by: Rui Miguel Silva <rmfrfs@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/bootrom.c b/drivers/staging/greybus/bootrom.c
index 06df0ce03150..6fd1ce76fa0e 100644
--- a/drivers/staging/greybus/bootrom.c
+++ b/drivers/staging/greybus/bootrom.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * BOOTROM Greybus driver.
  *

commit 461ab8077d573d4a35529572c774a71e5a898a84
Author: Gioh Kim <gi-oh.kim@profitbricks.com>
Date:   Thu Feb 9 17:30:11 2017 +0100

    staging: greybus: fix "line over 80 characters" coding style issues
    
    This patch fixes only obvious lines.
    There are still more issues.
    
    Signed-off-by: Gioh Kim <gi-oh.kim@profitbricks.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/bootrom.c b/drivers/staging/greybus/bootrom.c
index 5f90721bcc51..06df0ce03150 100644
--- a/drivers/staging/greybus/bootrom.c
+++ b/drivers/staging/greybus/bootrom.c
@@ -53,7 +53,8 @@ static void free_firmware(struct gb_bootrom *bootrom)
 static void gb_bootrom_timedout(struct work_struct *work)
 {
 	struct delayed_work *dwork = to_delayed_work(work);
-	struct gb_bootrom *bootrom = container_of(dwork, struct gb_bootrom, dwork);
+	struct gb_bootrom *bootrom = container_of(dwork,
+						  struct gb_bootrom, dwork);
 	struct device *dev = &bootrom->connection->bundle->dev;
 	const char *reason;
 
@@ -187,7 +188,8 @@ static int find_firmware(struct gb_bootrom *bootrom, u8 stage)
 static int gb_bootrom_firmware_size_request(struct gb_operation *op)
 {
 	struct gb_bootrom *bootrom = gb_connection_get_data(op->connection);
-	struct gb_bootrom_firmware_size_request *size_request = op->request->payload;
+	struct gb_bootrom_firmware_size_request *size_request =
+		op->request->payload;
 	struct gb_bootrom_firmware_size_response *size_response;
 	struct device *dev = &op->connection->bundle->dev;
 	int ret;
@@ -220,7 +222,8 @@ static int gb_bootrom_firmware_size_request(struct gb_operation *op)
 	size_response = op->response->payload;
 	size_response->size = cpu_to_le32(bootrom->fw->size);
 
-	dev_dbg(dev, "%s: firmware size %d bytes\n", __func__, size_response->size);
+	dev_dbg(dev, "%s: firmware size %d bytes\n",
+		__func__, size_response->size);
 
 unlock:
 	mutex_unlock(&bootrom->mutex);
@@ -287,8 +290,8 @@ static int gb_bootrom_get_firmware(struct gb_operation *op)
 	firmware_response = op->response->payload;
 	memcpy(firmware_response->data, fw->data + offset, size);
 
-	dev_dbg(dev, "responding with firmware (offs = %u, size = %u)\n", offset,
-		size);
+	dev_dbg(dev, "responding with firmware (offs = %u, size = %u)\n",
+		offset, size);
 
 unlock:
 	mutex_unlock(&bootrom->mutex);

commit 23931ffb9ac892a51cdef4eefdfc255e3f810a8b
Author: Johan Hovold <johan@hovoldconsulting.com>
Date:   Thu Jul 28 11:40:53 2016 +0200

    greybus: replace Ara references
    
    Replace all occurrences of the term "Ara" with "GMP" in core.
    
    Signed-off-by: Johan Hovold <johan@hovoldconsulting.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/bootrom.c b/drivers/staging/greybus/bootrom.c
index e7cfa80b6b0b..5f90721bcc51 100644
--- a/drivers/staging/greybus/bootrom.c
+++ b/drivers/staging/greybus/bootrom.c
@@ -114,7 +114,7 @@ static void bootrom_es2_fixup_vid_pid(struct gb_bootrom *bootrom)
 	struct gb_interface *intf = connection->bundle->intf;
 	int ret;
 
-	if (!(intf->quirks & GB_INTERFACE_QUIRK_NO_ARA_IDS))
+	if (!(intf->quirks & GB_INTERFACE_QUIRK_NO_GMP_IDS))
 		return;
 
 	ret = gb_operation_sync(connection, GB_BOOTROM_TYPE_GET_VID_PID,

commit 68793c4c8824a0b1e0cb89737c5919a0b10d70cf
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Fri Jul 22 14:13:44 2016 -0700

    greybus: bootrom: Rename download_firmware() as find_firmware()
    
    The download_firmware() function isn't downloading the firmware but just
    finding if one is available or not. The same applies to the error
    message printed by it.
    
    Replace 'download' with 'find' to make it sound better.
    
    Reported-by: Johan Hovold <johan@hovoldconsulting.com>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/bootrom.c b/drivers/staging/greybus/bootrom.c
index b90b25cadf5d..e7cfa80b6b0b 100644
--- a/drivers/staging/greybus/bootrom.c
+++ b/drivers/staging/greybus/bootrom.c
@@ -140,7 +140,7 @@ static void bootrom_es2_fixup_vid_pid(struct gb_bootrom *bootrom)
 }
 
 /* This returns path of the firmware blob on the disk */
-static int download_firmware(struct gb_bootrom *bootrom, u8 stage)
+static int find_firmware(struct gb_bootrom *bootrom, u8 stage)
 {
 	struct gb_connection *connection = bootrom->connection;
 	struct gb_interface *intf = connection->bundle->intf;
@@ -177,8 +177,8 @@ static int download_firmware(struct gb_bootrom *bootrom, u8 stage)
 	rc = request_firmware(&bootrom->fw, firmware_name,
 		&connection->bundle->dev);
 	if (rc) {
-		dev_err(&connection->bundle->dev, "failed to download %s firmware (%d)\n",
-			firmware_name, rc);
+		dev_err(&connection->bundle->dev,
+			"failed to find %s firmware (%d)\n", firmware_name, rc);
 	}
 
 	return rc;
@@ -205,7 +205,7 @@ static int gb_bootrom_firmware_size_request(struct gb_operation *op)
 
 	mutex_lock(&bootrom->mutex);
 
-	ret = download_firmware(bootrom, size_request->stage);
+	ret = find_firmware(bootrom, size_request->stage);
 	if (ret)
 		goto unlock;
 

commit 40d276ede92e85e4f414ac655c217e0bf5292cbb
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Fri Jul 22 14:13:43 2016 -0700

    greybus: bootrom: Create gb_bootrom_cancel_timeout()
    
    We set timeouts using gb_bootrom_set_timeout(), which hides the internal
    implementation, i.e. workqueues.
    
    While canceling timeouts, we do cancel_delayed_work_sync(), which
    exposes the internal implementation and doesn't look that clean.
    
    Create gb_bootrom_cancel_timeout() to hide the internal implementation
    here as well.
    
    Reviewed-by: Johan Hovold <johan@hovoldconsulting.com>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/bootrom.c b/drivers/staging/greybus/bootrom.c
index 7cc4d034c421..b90b25cadf5d 100644
--- a/drivers/staging/greybus/bootrom.c
+++ b/drivers/staging/greybus/bootrom.c
@@ -92,6 +92,11 @@ static void gb_bootrom_set_timeout(struct gb_bootrom *bootrom,
 	schedule_delayed_work(&bootrom->dwork, msecs_to_jiffies(timeout));
 }
 
+static void gb_bootrom_cancel_timeout(struct gb_bootrom *bootrom)
+{
+	cancel_delayed_work_sync(&bootrom->dwork);
+}
+
 /*
  * The es2 chip doesn't have VID/PID programmed into the hardware and we need to
  * hack that up to distinguish different modules and their firmware blobs.
@@ -188,7 +193,7 @@ static int gb_bootrom_firmware_size_request(struct gb_operation *op)
 	int ret;
 
 	/* Disable timeouts */
-	cancel_delayed_work_sync(&bootrom->dwork);
+	gb_bootrom_cancel_timeout(bootrom);
 
 	if (op->request->payload_size != sizeof(*size_request)) {
 		dev_err(dev, "%s: illegal size of firmware size request (%zu != %zu)\n",
@@ -242,7 +247,7 @@ static int gb_bootrom_get_firmware(struct gb_operation *op)
 	int ret = 0;
 
 	/* Disable timeouts */
-	cancel_delayed_work_sync(&bootrom->dwork);
+	gb_bootrom_cancel_timeout(bootrom);
 
 	if (op->request->payload_size != sizeof(*firmware_request)) {
 		dev_err(dev, "%s: Illegal size of get firmware request (%zu %zu)\n",
@@ -310,7 +315,7 @@ static int gb_bootrom_ready_to_boot(struct gb_operation *op)
 	int ret = 0;
 
 	/* Disable timeouts */
-	cancel_delayed_work_sync(&bootrom->dwork);
+	gb_bootrom_cancel_timeout(bootrom);
 
 	if (op->request->payload_size != sizeof(*rtb_request)) {
 		dev_err(dev, "%s: Illegal size of ready to boot request (%zu %zu)\n",
@@ -468,7 +473,7 @@ static int gb_bootrom_probe(struct gb_bundle *bundle,
 	return 0;
 
 err_cancel_timeout:
-	cancel_delayed_work_sync(&bootrom->dwork);
+	gb_bootrom_cancel_timeout(bootrom);
 err_connection_disable:
 	gb_connection_disable(connection);
 err_connection_destroy:
@@ -488,7 +493,7 @@ static void gb_bootrom_disconnect(struct gb_bundle *bundle)
 	gb_connection_disable(bootrom->connection);
 
 	/* Disable timeouts */
-	cancel_delayed_work_sync(&bootrom->dwork);
+	gb_bootrom_cancel_timeout(bootrom);
 
 	/*
 	 * Release firmware:

commit 6d9e6ffca4226007672800a6681c42cc877aab60
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Fri Jul 22 14:13:42 2016 -0700

    greybus: bootrom: Set timeout before sending AP_READY
    
    A special race is observed in the case where the phone boots with
    modules attached to it.
    
    In that case, the AP processes a later FIRMWARE_SIZE request from the
    bootrom, before processing the response to the earlier AP_READY request.
    And because of that, we set the timeout from gb_bootrom_probe() after
    trying to cancel it from gb_bootrom_firmware_size_request().
    
    And with that, if the firmware package isn't available for the kernel to
    directly read from, then we get a timeout print message like below:
    
    [   23.669764] bootrom 1-3.3.1: Firmware file 'ara_00000126_00001001_fffe0001_ffe5001a_s2l.tftf' requested
    [   24.680528] bootrom 1-3.3.1: Timed out waiting for Firmware Size Request from the Module
    
    Note that this doesn't happen if the module is inserted into the frame,
    after the phone is already booted.
    
    This behavior is the result of an earlier commit cdd1cb3f4943
    ("operation: add completion work queue").
    
    This perhaps happens only at boot time because the UNBOUND wq
    (connection->wq) gets a chance to run on other CPUs, while the BOUND wq
    (gb_operation_completion_wq) doesn't at that stage (24 seconds since
    boot).
    
    Setting the timeout before sending the AP_READY request fixes it for
    now.
    
    Reported-by: Johan Hovold <johan@hovoldconsulting.com>
    Reviewed-by: Johan Hovold <johan@hovoldconsulting.com>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/bootrom.c b/drivers/staging/greybus/bootrom.c
index c5b397145145..7cc4d034c421 100644
--- a/drivers/staging/greybus/bootrom.c
+++ b/drivers/staging/greybus/bootrom.c
@@ -450,23 +450,25 @@ static int gb_bootrom_probe(struct gb_bundle *bundle,
 	if (ret)
 		goto err_connection_disable;
 
+	/* Refresh timeout */
+	gb_bootrom_set_timeout(bootrom, NEXT_REQ_FIRMWARE_SIZE,
+			       NEXT_REQ_TIMEOUT_MS);
+
 	/* Tell bootrom we're ready. */
 	ret = gb_operation_sync(connection, GB_BOOTROM_TYPE_AP_READY, NULL, 0,
 				NULL, 0);
 	if (ret) {
 		dev_err(&connection->bundle->dev,
 				"failed to send AP READY: %d\n", ret);
-		goto err_connection_disable;
+		goto err_cancel_timeout;
 	}
 
-	/* Refresh timeout */
-	gb_bootrom_set_timeout(bootrom, NEXT_REQ_FIRMWARE_SIZE,
-			       NEXT_REQ_TIMEOUT_MS);
-
 	dev_dbg(&bundle->dev, "AP_READY sent\n");
 
 	return 0;
 
+err_cancel_timeout:
+	cancel_delayed_work_sync(&bootrom->dwork);
 err_connection_disable:
 	gb_connection_disable(connection);
 err_connection_destroy:

commit 2d6f1c29988c0f5b51949bb674fe9dcdb923c4a6
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Fri Jul 22 14:13:41 2016 -0700

    greybus: bootrom: Don't print duplicate error messages
    
    On failing to find a firmware image, we get these today:
    
    bootrom 1-3.3.1: Firmware request for ara_00000126_00001001_fffe0001_ffe5001a_s2l.tftf has failed : -12
    bootrom 1-3.3.1: gb_bootrom_firmware_size_request: failed to download firmware (-12)
    
    Which are more or less duplicate, as they print error for the same root
    cause.
    
    With this patch this is all we get now:
    
    bootrom 1-3.3.1: failed to download ara_00000126_00001001_fffe0001_ffe5001a_s2l.tftf firmware (-12)
    
    Reported-by: Johan Hovold <johan@hovoldconsulting.com>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/bootrom.c b/drivers/staging/greybus/bootrom.c
index d16f13e0cb8d..c5b397145145 100644
--- a/drivers/staging/greybus/bootrom.c
+++ b/drivers/staging/greybus/bootrom.c
@@ -171,10 +171,11 @@ static int download_firmware(struct gb_bootrom *bootrom, u8 stage)
 
 	rc = request_firmware(&bootrom->fw, firmware_name,
 		&connection->bundle->dev);
-	if (rc)
-		dev_err(&connection->bundle->dev,
-			"Firmware request for %s has failed : %d",
+	if (rc) {
+		dev_err(&connection->bundle->dev, "failed to download %s firmware (%d)\n",
 			firmware_name, rc);
+	}
+
 	return rc;
 }
 
@@ -200,11 +201,8 @@ static int gb_bootrom_firmware_size_request(struct gb_operation *op)
 	mutex_lock(&bootrom->mutex);
 
 	ret = download_firmware(bootrom, size_request->stage);
-	if (ret) {
-		dev_err(dev, "%s: failed to download firmware (%d)\n", __func__,
-			ret);
+	if (ret)
 		goto unlock;
-	}
 
 	if (!gb_operation_response_alloc(op, sizeof(*size_response),
 					 GFP_KERNEL)) {

commit cc90d6fce858cea167102380e57a63af2f75ec8b
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Fri Jul 22 14:13:40 2016 -0700

    greybus: bootrom: Skip setting timeout in failure path of size request
    
    The currently set value of next_request_type in the error path of
    gb_bootrom_firmware_size_request() is not correct, as it should have
    been NEXT_REQ_FIRMWARE_SIZE for the failure case (as we should be
    waiting for another similar request).
    
    But, if an error occurs in gb_bootrom_firmware_size_request(), then the
    ES3 bootrom will never be able to recover from it and send another
    request. And so there is no point waiting for another request and timing
    out.
    
    Skip doing that in error path.
    
    Reported-by: Johan Hovold <johan@hovoldconsulting.com>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/bootrom.c b/drivers/staging/greybus/bootrom.c
index 309e0a7c865a..d16f13e0cb8d 100644
--- a/drivers/staging/greybus/bootrom.c
+++ b/drivers/staging/greybus/bootrom.c
@@ -223,9 +223,11 @@ static int gb_bootrom_firmware_size_request(struct gb_operation *op)
 	mutex_unlock(&bootrom->mutex);
 
 queue_work:
-	/* Refresh timeout */
-	gb_bootrom_set_timeout(bootrom, NEXT_REQ_GET_FIRMWARE,
-			       NEXT_REQ_TIMEOUT_MS);
+	if (!ret) {
+		/* Refresh timeout */
+		gb_bootrom_set_timeout(bootrom, NEXT_REQ_GET_FIRMWARE,
+				       NEXT_REQ_TIMEOUT_MS);
+	}
 
 	return ret;
 }

commit 8a704565ebda9603c294aacebb34e47cd9d9a3a0
Author: Greg Kroah-Hartman <gregkh@google.com>
Date:   Wed Jul 20 10:11:37 2016 -0700

    greybus: move all firmware prefix strings to one place
    
    The firmware prefix is hard-coded in a few different places.  Put it all
    in one handy #define, for when/if we ever decide to change it in the
    future...
    
    Testing: 'strings gb-firmware.ko gb-bootrom.ko | grep ara_' produced the
             same output before and after this patch.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>
    Reviewed-by: Viresh Kumar <viresh.kumar@linaro.org>
    Acked-by: Sandeep Patil <sspatil@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/bootrom.c b/drivers/staging/greybus/bootrom.c
index 688184181e0c..309e0a7c865a 100644
--- a/drivers/staging/greybus/bootrom.c
+++ b/drivers/staging/greybus/bootrom.c
@@ -13,6 +13,7 @@
 #include <linux/workqueue.h>
 
 #include "greybus.h"
+#include "firmware.h"
 
 /* Timeout, in jiffies, within which the next request must be received */
 #define NEXT_REQ_TIMEOUT_MS	1000
@@ -157,7 +158,7 @@ static int download_firmware(struct gb_bootrom *bootrom, u8 stage)
 	 * XXX Name it properly..
 	 */
 	snprintf(firmware_name, sizeof(firmware_name),
-		 "ara_%08x_%08x_%08x_%08x_s2l.tftf",
+		 FW_NAME_PREFIX "%08x_%08x_%08x_%08x_s2l.tftf",
 		 intf->ddbl1_manufacturer_id, intf->ddbl1_product_id,
 		 intf->vendor_id, intf->product_id);
 

commit 56c78715eaaeba41317a82dc91a037cbbea16736
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Sat Jul 16 09:57:30 2016 -0700

    greybus: bootrom: Use "s2l" instead of boot stage in package name
    
    The S3 firmware and S3-BFU firmware images will be named like this going
    forward:
    
    S3: ara_00000126_00001001_fffe0001_ffe70018_s3f.tftf
    S3-BFU: ara_00000126_00001001_fffe0001_ffe70018_s3_bfu.tftf
    
    But the current naming for S2 loader image is:
    
    ara_00000126_00001001_fffe0001_ffe70018_02.tftf
    
    It makes sense to use similar encoding for all three packages and so it
    should be named as:
    
    ara_00000126_00001001_fffe0001_ffe70018_s2l.tftf
    
    Because the boot stage is passed from ES3 bootrom, we can't change its
    value now. But the string created to match the package name is created
    in bootrom.c and that is the only string we create from bootrom.c.
    
    Update bootrom.c to use "s2l" instead of "02" in the package name.
    
    Compile Tested only.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Tested-by: Karthik Ravi Shankar <karthikrs@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/bootrom.c b/drivers/staging/greybus/bootrom.c
index 84537a07ab7f..688184181e0c 100644
--- a/drivers/staging/greybus/bootrom.c
+++ b/drivers/staging/greybus/bootrom.c
@@ -138,21 +138,28 @@ static int download_firmware(struct gb_bootrom *bootrom, u8 stage)
 {
 	struct gb_connection *connection = bootrom->connection;
 	struct gb_interface *intf = connection->bundle->intf;
-	char firmware_name[48];
+	char firmware_name[49];
 	int rc;
 
 	/* Already have a firmware, free it */
 	free_firmware(bootrom);
 
+	/* Bootrom protocol is only supported for loading Stage 2 firmware */
+	if (stage != 2) {
+		dev_err(&connection->bundle->dev, "Invalid boot stage: %u\n",
+			stage);
+		return -EINVAL;
+	}
+
 	/*
 	 * Create firmware name
 	 *
 	 * XXX Name it properly..
 	 */
 	snprintf(firmware_name, sizeof(firmware_name),
-		 "ara_%08x_%08x_%08x_%08x_%02x.tftf",
+		 "ara_%08x_%08x_%08x_%08x_s2l.tftf",
 		 intf->ddbl1_manufacturer_id, intf->ddbl1_product_id,
-		 intf->vendor_id, intf->product_id, stage);
+		 intf->vendor_id, intf->product_id);
 
 	// FIXME:
 	// Turn to dev_dbg later after everyone has valid bootloaders with good

commit 326f98ac3168cf415f4e1681b3684614bcd79fd3
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Wed Jun 22 14:46:41 2016 +0530

    greybus: bootrom: Wait for 10 seconds for mode-switch
    
    The greybus SVC core handles events from the SVC serially today. In some
    cases the SVC operations may take too long, for example trying to
    activate a dummy interface. If another interface receives a mode-switch
    mailbox event in that time, the SVC core wouldn't be able to process it
    in quickly enough and bootrom driver will print following error:
    
    bootrom 1-3.3.1: Timed out waiting for Interface Mode Switch from the Module
    
    This can be reproduced easily by attaching a 2x2 module along with any
    other normal module like camera or speaker, and doing a unipro_reset
    from userspace.
    
    The logs suggest this time to be around 6-7 seconds in most of the
    cases. Attaching multiple modules with dummy interfaces may make this
    worst.
    
    Lets increase the timeout from 5 to 10 seconds for now, also add a FIXME
    for the same.
    
    Testing Done: Tested on EVT 2.0 with camera and a 2x2 module.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Tested-by: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
    Reviewed-by: Johan Hovold <johan@hovoldconsulting.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/bootrom.c b/drivers/staging/greybus/bootrom.c
index 70785d4b64a9..84537a07ab7f 100644
--- a/drivers/staging/greybus/bootrom.c
+++ b/drivers/staging/greybus/bootrom.c
@@ -17,6 +17,12 @@
 /* Timeout, in jiffies, within which the next request must be received */
 #define NEXT_REQ_TIMEOUT_MS	1000
 
+/*
+ * FIXME: Reduce this timeout once svc core handles parallel processing of
+ * events from the SVC, which are handled sequentially today.
+ */
+#define MODE_SWITCH_TIMEOUT_MS	10000
+
 enum next_request_type {
 	NEXT_REQ_FIRMWARE_SIZE,
 	NEXT_REQ_GET_FIRMWARE,
@@ -327,7 +333,7 @@ static int gb_bootrom_ready_to_boot(struct gb_operation *op)
 	 * connection. As that can take some time, increase the timeout a bit.
 	 */
 	gb_bootrom_set_timeout(bootrom, NEXT_REQ_MODE_SWITCH,
-			       5 * NEXT_REQ_TIMEOUT_MS);
+			       MODE_SWITCH_TIMEOUT_MS);
 
 	return ret;
 }

commit dbb8cfeba9cc22e091eaec3dfa34ae4c7dc4d241
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Wed Jun 22 14:46:40 2016 +0530

    greybus: bootrom: send timeout in milliseconds to gb_bootrom_set_timeout()
    
    Rename NEXT_REQ_TIMEOUT_J to NEXT_REQ_TIMEOUT_MS and store the timeout
    in milliseconds instead of jiffies.
    
    Suggested-by: Alex Elder <alex.elder@linaro.org>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Reviewed-by: Johan Hovold <johan@hovoldconsulting.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/bootrom.c b/drivers/staging/greybus/bootrom.c
index 6d79bc6388df..70785d4b64a9 100644
--- a/drivers/staging/greybus/bootrom.c
+++ b/drivers/staging/greybus/bootrom.c
@@ -15,7 +15,7 @@
 #include "greybus.h"
 
 /* Timeout, in jiffies, within which the next request must be received */
-#define NEXT_REQ_TIMEOUT_J	msecs_to_jiffies(1000)
+#define NEXT_REQ_TIMEOUT_MS	1000
 
 enum next_request_type {
 	NEXT_REQ_FIRMWARE_SIZE,
@@ -82,7 +82,7 @@ static void gb_bootrom_set_timeout(struct gb_bootrom *bootrom,
 			enum next_request_type next, unsigned long timeout)
 {
 	bootrom->next_request = next;
-	schedule_delayed_work(&bootrom->dwork, timeout);
+	schedule_delayed_work(&bootrom->dwork, msecs_to_jiffies(timeout));
 }
 
 /*
@@ -211,7 +211,7 @@ static int gb_bootrom_firmware_size_request(struct gb_operation *op)
 queue_work:
 	/* Refresh timeout */
 	gb_bootrom_set_timeout(bootrom, NEXT_REQ_GET_FIRMWARE,
-			       NEXT_REQ_TIMEOUT_J);
+			       NEXT_REQ_TIMEOUT_MS);
 
 	return ret;
 }
@@ -281,7 +281,7 @@ static int gb_bootrom_get_firmware(struct gb_operation *op)
 	else
 		next_request = NEXT_REQ_GET_FIRMWARE;
 
-	gb_bootrom_set_timeout(bootrom, next_request, NEXT_REQ_TIMEOUT_J);
+	gb_bootrom_set_timeout(bootrom, next_request, NEXT_REQ_TIMEOUT_MS);
 
 	return ret;
 }
@@ -327,7 +327,7 @@ static int gb_bootrom_ready_to_boot(struct gb_operation *op)
 	 * connection. As that can take some time, increase the timeout a bit.
 	 */
 	gb_bootrom_set_timeout(bootrom, NEXT_REQ_MODE_SWITCH,
-			       5 * NEXT_REQ_TIMEOUT_J);
+			       5 * NEXT_REQ_TIMEOUT_MS);
 
 	return ret;
 }
@@ -447,7 +447,7 @@ static int gb_bootrom_probe(struct gb_bundle *bundle,
 
 	/* Refresh timeout */
 	gb_bootrom_set_timeout(bootrom, NEXT_REQ_FIRMWARE_SIZE,
-			       NEXT_REQ_TIMEOUT_J);
+			       NEXT_REQ_TIMEOUT_MS);
 
 	dev_dbg(&bundle->dev, "AP_READY sent\n");
 

commit a4293e1d4e6416477976ee3bd248589d3fc4bb19
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Wed Jun 22 14:46:39 2016 +0530

    greybus: bootrom: Enhance timeout error message
    
    The timeout message is very generic today and there are several requests
    we can be timing out waiting for.
    
    Update bootrom driver to also track the next expected request and
    enhance the error message based on that to confirm the request we timed
    out waiting for.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Reviewed-by: Johan Hovold <johan@hovoldconsulting.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/bootrom.c b/drivers/staging/greybus/bootrom.c
index 2cebffab8d9d..6d79bc6388df 100644
--- a/drivers/staging/greybus/bootrom.c
+++ b/drivers/staging/greybus/bootrom.c
@@ -17,11 +17,19 @@
 /* Timeout, in jiffies, within which the next request must be received */
 #define NEXT_REQ_TIMEOUT_J	msecs_to_jiffies(1000)
 
+enum next_request_type {
+	NEXT_REQ_FIRMWARE_SIZE,
+	NEXT_REQ_GET_FIRMWARE,
+	NEXT_REQ_READY_TO_BOOT,
+	NEXT_REQ_MODE_SWITCH,
+};
+
 struct gb_bootrom {
 	struct gb_connection	*connection;
 	const struct firmware	*fw;
 	u8			protocol_major;
 	u8			protocol_minor;
+	enum next_request_type	next_request;
 	struct delayed_work	dwork;
 	struct mutex		mutex; /* Protects bootrom->fw */
 };
@@ -40,8 +48,28 @@ static void gb_bootrom_timedout(struct work_struct *work)
 	struct delayed_work *dwork = to_delayed_work(work);
 	struct gb_bootrom *bootrom = container_of(dwork, struct gb_bootrom, dwork);
 	struct device *dev = &bootrom->connection->bundle->dev;
+	const char *reason;
+
+	switch (bootrom->next_request) {
+	case NEXT_REQ_FIRMWARE_SIZE:
+		reason = "Firmware Size Request";
+		break;
+	case NEXT_REQ_GET_FIRMWARE:
+		reason = "Get Firmware Request";
+		break;
+	case NEXT_REQ_READY_TO_BOOT:
+		reason = "Ready to Boot Request";
+		break;
+	case NEXT_REQ_MODE_SWITCH:
+		reason = "Interface Mode Switch";
+		break;
+	default:
+		reason = NULL;
+		dev_err(dev, "Invalid next-request: %u", bootrom->next_request);
+		break;
+	}
 
-	dev_err(dev, "Timed out waiting for request from the Module\n");
+	dev_err(dev, "Timed out waiting for %s from the Module\n", reason);
 
 	mutex_lock(&bootrom->mutex);
 	free_firmware(bootrom);
@@ -50,6 +78,13 @@ static void gb_bootrom_timedout(struct work_struct *work)
 	/* TODO: Power-off Module ? */
 }
 
+static void gb_bootrom_set_timeout(struct gb_bootrom *bootrom,
+			enum next_request_type next, unsigned long timeout)
+{
+	bootrom->next_request = next;
+	schedule_delayed_work(&bootrom->dwork, timeout);
+}
+
 /*
  * The es2 chip doesn't have VID/PID programmed into the hardware and we need to
  * hack that up to distinguish different modules and their firmware blobs.
@@ -175,7 +210,8 @@ static int gb_bootrom_firmware_size_request(struct gb_operation *op)
 
 queue_work:
 	/* Refresh timeout */
-	schedule_delayed_work(&bootrom->dwork, NEXT_REQ_TIMEOUT_J);
+	gb_bootrom_set_timeout(bootrom, NEXT_REQ_GET_FIRMWARE,
+			       NEXT_REQ_TIMEOUT_J);
 
 	return ret;
 }
@@ -188,6 +224,7 @@ static int gb_bootrom_get_firmware(struct gb_operation *op)
 	struct gb_bootrom_get_firmware_response *firmware_response;
 	struct device *dev = &op->connection->bundle->dev;
 	unsigned int offset, size;
+	enum next_request_type next_request;
 	int ret = 0;
 
 	/* Disable timeouts */
@@ -239,7 +276,12 @@ static int gb_bootrom_get_firmware(struct gb_operation *op)
 
 queue_work:
 	/* Refresh timeout */
-	schedule_delayed_work(&bootrom->dwork, NEXT_REQ_TIMEOUT_J);
+	if (!ret && (offset + size == fw->size))
+		next_request = NEXT_REQ_READY_TO_BOOT;
+	else
+		next_request = NEXT_REQ_GET_FIRMWARE;
+
+	gb_bootrom_set_timeout(bootrom, next_request, NEXT_REQ_TIMEOUT_J);
 
 	return ret;
 }
@@ -284,7 +326,8 @@ static int gb_bootrom_ready_to_boot(struct gb_operation *op)
 	 * send a new hotplug request, which shall get rid of the bootrom
 	 * connection. As that can take some time, increase the timeout a bit.
 	 */
-	schedule_delayed_work(&bootrom->dwork, 5 * NEXT_REQ_TIMEOUT_J);
+	gb_bootrom_set_timeout(bootrom, NEXT_REQ_MODE_SWITCH,
+			       5 * NEXT_REQ_TIMEOUT_J);
 
 	return ret;
 }
@@ -403,7 +446,8 @@ static int gb_bootrom_probe(struct gb_bundle *bundle,
 	}
 
 	/* Refresh timeout */
-	schedule_delayed_work(&bootrom->dwork, NEXT_REQ_TIMEOUT_J);
+	gb_bootrom_set_timeout(bootrom, NEXT_REQ_FIRMWARE_SIZE,
+			       NEXT_REQ_TIMEOUT_J);
 
 	dev_dbg(&bundle->dev, "AP_READY sent\n");
 

commit aa62b5e49a596cad71a816fc36a4da6ad0c0cd0f
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Thu Jun 9 16:34:35 2016 +0530

    greybus: bootrom: Compile as a separate module
    
    User space doesn't break anymore with new greybus modules and its time
    to make bootrom a separate module.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/bootrom.c b/drivers/staging/greybus/bootrom.c
index f375a879242c..2cebffab8d9d 100644
--- a/drivers/staging/greybus/bootrom.c
+++ b/drivers/staging/greybus/bootrom.c
@@ -12,7 +12,6 @@
 #include <linux/mutex.h>
 #include <linux/workqueue.h>
 
-#include "bootrom.h"
 #include "greybus.h"
 
 /* Timeout, in jiffies, within which the next request must be received */
@@ -455,12 +454,6 @@ static struct greybus_driver gb_bootrom_driver = {
 	.id_table	= gb_bootrom_id_table,
 };
 
-int gb_bootrom_init(void)
-{
-	return greybus_register(&gb_bootrom_driver);
-}
+module_greybus_driver(gb_bootrom_driver);
 
-void gb_bootrom_exit(void)
-{
-	greybus_deregister(&gb_bootrom_driver);
-}
+MODULE_LICENSE("GPL v2");

commit a956d939af9e73d3375f52d5c5c63ab824e59c8b
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Mon May 9 10:59:00 2016 +0530

    greybus: bootrom: Implement timeouts to detect Module failures
    
    Its possible that the Module may fail to download the next stage
    firmware, or to jump into it and boot into the new personality.
    
    We have already seen examples of both of these cases on EVT 1.5.
    
    This patch implements timeouts in the bootrom bundle driver, which now
    expects the next request from the Module to be received at the AP within
    1 second of the previous request/response. The time interval can be
    increased later if required.
    
    The timeouts are added between:
    - AP_READY and FIRMWARE_SIZE operations
    - FIRMWARE_SIZE and GET_FIRMWARE operations
    - Two GET_FIRMWARE operations
    - GET_FIRMWARE and READY_TO_BOOT operations
    - READY_TO_BOOT operation and the call to the ->disconnect() event of
      the bootrom bundle (once the new hotplug request is received).
    
    The timeout for the last case is kept at 5 seconds right now (random
    value), as it may take a bit longer.
    
    Because 'bootrom->fw' can be accessed simultaneously (from timeout
    handler and incoming requests) and one of them can potentially free the
    '->fw' structure, a mutex is also added to take care of such races while
    accessing 'bootrom->fw' structure.
    
    Also note that the '!bootrom->fw' check is moved to free_firmware()
    routine.
    
    Note that this version uses delayed-work (instead of timers used in
    earlier attempt), as we need to call routines that can sleep from the
    timeout handler.
    
    Tested on EVT 1.5, by faking errors on certain requests, so that the
    bootrom doesn't send any more requests. Normal case is working just fine
    for audio and GP modules. This is tested with build arche_440.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/bootrom.c b/drivers/staging/greybus/bootrom.c
index cf750beb3403..f375a879242c 100644
--- a/drivers/staging/greybus/bootrom.c
+++ b/drivers/staging/greybus/bootrom.c
@@ -8,24 +8,49 @@
  */
 
 #include <linux/firmware.h>
+#include <linux/jiffies.h>
+#include <linux/mutex.h>
+#include <linux/workqueue.h>
 
 #include "bootrom.h"
 #include "greybus.h"
 
+/* Timeout, in jiffies, within which the next request must be received */
+#define NEXT_REQ_TIMEOUT_J	msecs_to_jiffies(1000)
 
 struct gb_bootrom {
 	struct gb_connection	*connection;
 	const struct firmware	*fw;
 	u8			protocol_major;
 	u8			protocol_minor;
+	struct delayed_work	dwork;
+	struct mutex		mutex; /* Protects bootrom->fw */
 };
 
 static void free_firmware(struct gb_bootrom *bootrom)
 {
+	if (!bootrom->fw)
+		return;
+
 	release_firmware(bootrom->fw);
 	bootrom->fw = NULL;
 }
 
+static void gb_bootrom_timedout(struct work_struct *work)
+{
+	struct delayed_work *dwork = to_delayed_work(work);
+	struct gb_bootrom *bootrom = container_of(dwork, struct gb_bootrom, dwork);
+	struct device *dev = &bootrom->connection->bundle->dev;
+
+	dev_err(dev, "Timed out waiting for request from the Module\n");
+
+	mutex_lock(&bootrom->mutex);
+	free_firmware(bootrom);
+	mutex_unlock(&bootrom->mutex);
+
+	/* TODO: Power-off Module ? */
+}
+
 /*
  * The es2 chip doesn't have VID/PID programmed into the hardware and we need to
  * hack that up to distinguish different modules and their firmware blobs.
@@ -77,8 +102,7 @@ static int download_firmware(struct gb_bootrom *bootrom, u8 stage)
 	int rc;
 
 	/* Already have a firmware, free it */
-	if (bootrom->fw)
-		free_firmware(bootrom);
+	free_firmware(bootrom);
 
 	/*
 	 * Create firmware name
@@ -114,25 +138,32 @@ static int gb_bootrom_firmware_size_request(struct gb_operation *op)
 	struct device *dev = &op->connection->bundle->dev;
 	int ret;
 
+	/* Disable timeouts */
+	cancel_delayed_work_sync(&bootrom->dwork);
+
 	if (op->request->payload_size != sizeof(*size_request)) {
 		dev_err(dev, "%s: illegal size of firmware size request (%zu != %zu)\n",
 			__func__, op->request->payload_size,
 			sizeof(*size_request));
-		return -EINVAL;
+		ret = -EINVAL;
+		goto queue_work;
 	}
 
+	mutex_lock(&bootrom->mutex);
+
 	ret = download_firmware(bootrom, size_request->stage);
 	if (ret) {
 		dev_err(dev, "%s: failed to download firmware (%d)\n", __func__,
 			ret);
-		return ret;
+		goto unlock;
 	}
 
 	if (!gb_operation_response_alloc(op, sizeof(*size_response),
 					 GFP_KERNEL)) {
 		dev_err(dev, "%s: error allocating response\n", __func__);
 		free_firmware(bootrom);
-		return -ENOMEM;
+		ret = -ENOMEM;
+		goto unlock;
 	}
 
 	size_response = op->response->payload;
@@ -140,28 +171,44 @@ static int gb_bootrom_firmware_size_request(struct gb_operation *op)
 
 	dev_dbg(dev, "%s: firmware size %d bytes\n", __func__, size_response->size);
 
-	return 0;
+unlock:
+	mutex_unlock(&bootrom->mutex);
+
+queue_work:
+	/* Refresh timeout */
+	schedule_delayed_work(&bootrom->dwork, NEXT_REQ_TIMEOUT_J);
+
+	return ret;
 }
 
 static int gb_bootrom_get_firmware(struct gb_operation *op)
 {
 	struct gb_bootrom *bootrom = gb_connection_get_data(op->connection);
-	const struct firmware *fw = bootrom->fw;
+	const struct firmware *fw;
 	struct gb_bootrom_get_firmware_request *firmware_request;
 	struct gb_bootrom_get_firmware_response *firmware_response;
 	struct device *dev = &op->connection->bundle->dev;
 	unsigned int offset, size;
+	int ret = 0;
+
+	/* Disable timeouts */
+	cancel_delayed_work_sync(&bootrom->dwork);
 
 	if (op->request->payload_size != sizeof(*firmware_request)) {
 		dev_err(dev, "%s: Illegal size of get firmware request (%zu %zu)\n",
 			__func__, op->request->payload_size,
 			sizeof(*firmware_request));
-		return -EINVAL;
+		ret = -EINVAL;
+		goto queue_work;
 	}
 
+	mutex_lock(&bootrom->mutex);
+
+	fw = bootrom->fw;
 	if (!fw) {
 		dev_err(dev, "%s: firmware not available\n", __func__);
-		return -EINVAL;
+		ret = -EINVAL;
+		goto unlock;
 	}
 
 	firmware_request = op->request->payload;
@@ -171,13 +218,15 @@ static int gb_bootrom_get_firmware(struct gb_operation *op)
 	if (offset >= fw->size || size > fw->size - offset) {
 		dev_warn(dev, "bad firmware request (offs = %u, size = %u)\n",
 				offset, size);
-		return -EINVAL;
+		ret = -EINVAL;
+		goto unlock;
 	}
 
 	if (!gb_operation_response_alloc(op, sizeof(*firmware_response) + size,
 					 GFP_KERNEL)) {
 		dev_err(dev, "%s: error allocating response\n", __func__);
-		return -ENOMEM;
+		ret = -ENOMEM;
+		goto unlock;
 	}
 
 	firmware_response = op->response->payload;
@@ -186,36 +235,59 @@ static int gb_bootrom_get_firmware(struct gb_operation *op)
 	dev_dbg(dev, "responding with firmware (offs = %u, size = %u)\n", offset,
 		size);
 
-	return 0;
+unlock:
+	mutex_unlock(&bootrom->mutex);
+
+queue_work:
+	/* Refresh timeout */
+	schedule_delayed_work(&bootrom->dwork, NEXT_REQ_TIMEOUT_J);
+
+	return ret;
 }
 
 static int gb_bootrom_ready_to_boot(struct gb_operation *op)
 {
 	struct gb_connection *connection = op->connection;
+	struct gb_bootrom *bootrom = gb_connection_get_data(connection);
 	struct gb_bootrom_ready_to_boot_request *rtb_request;
 	struct device *dev = &connection->bundle->dev;
 	u8 status;
+	int ret = 0;
+
+	/* Disable timeouts */
+	cancel_delayed_work_sync(&bootrom->dwork);
 
 	if (op->request->payload_size != sizeof(*rtb_request)) {
 		dev_err(dev, "%s: Illegal size of ready to boot request (%zu %zu)\n",
 			__func__, op->request->payload_size,
 			sizeof(*rtb_request));
-		return -EINVAL;
+		ret = -EINVAL;
+		goto queue_work;
 	}
 
 	rtb_request = op->request->payload;
 	status = rtb_request->status;
 
 	/* Return error if the blob was invalid */
-	if (status == GB_BOOTROM_BOOT_STATUS_INVALID)
-		return -EINVAL;
+	if (status == GB_BOOTROM_BOOT_STATUS_INVALID) {
+		ret = -EINVAL;
+		goto queue_work;
+	}
 
 	/*
 	 * XXX Should we return error for insecure firmware?
 	 */
 	dev_dbg(dev, "ready to boot: 0x%x, 0\n", status);
 
-	return 0;
+queue_work:
+	/*
+	 * Refresh timeout, the Interface shall load the new personality and
+	 * send a new hotplug request, which shall get rid of the bootrom
+	 * connection. As that can take some time, increase the timeout a bit.
+	 */
+	schedule_delayed_work(&bootrom->dwork, 5 * NEXT_REQ_TIMEOUT_J);
+
+	return ret;
 }
 
 static int gb_bootrom_request_handler(struct gb_operation *op)
@@ -304,6 +376,8 @@ static int gb_bootrom_probe(struct gb_bundle *bundle,
 
 	bootrom->connection = connection;
 
+	mutex_init(&bootrom->mutex);
+	INIT_DELAYED_WORK(&bootrom->dwork, gb_bootrom_timedout);
 	greybus_set_drvdata(bundle, bootrom);
 
 	ret = gb_connection_enable_tx(connection);
@@ -329,6 +403,9 @@ static int gb_bootrom_probe(struct gb_bundle *bundle,
 		goto err_connection_disable;
 	}
 
+	/* Refresh timeout */
+	schedule_delayed_work(&bootrom->dwork, NEXT_REQ_TIMEOUT_J);
+
 	dev_dbg(&bundle->dev, "AP_READY sent\n");
 
 	return 0;
@@ -351,9 +428,16 @@ static void gb_bootrom_disconnect(struct gb_bundle *bundle)
 
 	gb_connection_disable(bootrom->connection);
 
-	/* Release firmware */
-	if (bootrom->fw)
-		free_firmware(bootrom);
+	/* Disable timeouts */
+	cancel_delayed_work_sync(&bootrom->dwork);
+
+	/*
+	 * Release firmware:
+	 *
+	 * As the connection and the delayed work are already disabled, we don't
+	 * need to lock access to bootrom->fw here.
+	 */
+	free_firmware(bootrom);
 
 	gb_connection_destroy(bootrom->connection);
 	kfree(bootrom);

commit 03b4fa4b5dd9ecd11c27cdaeacf46453a948df5a
Author: Jeffrey Carlyle <jcarlyle@google.com>
Date:   Fri May 6 11:29:37 2016 -0700

    greybus: Revert "bootrom: Implement timeouts to detect Module failures"
    
    This reverts commit 571348253032a86e4f0102d4dfadd390d0ea7e64.
    
    With this patch gb_bootrom_timedout was getting called in interrupt
    context and then proceeding to call functions that might block. In
    practical terms, this was leading to a kernel BUG at mm/vmalloc.c:1650.
    
    Signed-off-by: Jeffrey Carlyle <jcarlyle@google.com>
    Acked-by: Johan Hovold <johan@hovoldconsulting.com>

diff --git a/drivers/staging/greybus/bootrom.c b/drivers/staging/greybus/bootrom.c
index baada45329a2..cf750beb3403 100644
--- a/drivers/staging/greybus/bootrom.c
+++ b/drivers/staging/greybus/bootrom.c
@@ -8,48 +8,24 @@
  */
 
 #include <linux/firmware.h>
-#include <linux/jiffies.h>
-#include <linux/mutex.h>
-#include <linux/timer.h>
 
 #include "bootrom.h"
 #include "greybus.h"
 
-/* Timeout, in jiffies, within which the next request must be received */
-#define NEXT_REQ_TIMEOUT_J	msecs_to_jiffies(1000)
 
 struct gb_bootrom {
 	struct gb_connection	*connection;
 	const struct firmware	*fw;
 	u8			protocol_major;
 	u8			protocol_minor;
-	struct timer_list	timer;
-	struct mutex		mutex; /* Protects bootrom->fw */
 };
 
 static void free_firmware(struct gb_bootrom *bootrom)
 {
-	if (!bootrom->fw)
-		return;
-
 	release_firmware(bootrom->fw);
 	bootrom->fw = NULL;
 }
 
-static void gb_bootrom_timedout(unsigned long data)
-{
-	struct gb_bootrom *bootrom = (struct gb_bootrom *)data;
-	struct device *dev = &bootrom->connection->bundle->dev;
-
-	dev_err(dev, "Timed out waiting for request from the Module\n");
-
-	mutex_lock(&bootrom->mutex);
-	free_firmware(bootrom);
-	mutex_unlock(&bootrom->mutex);
-
-	/* TODO: Power-off Module ? */
-}
-
 /*
  * The es2 chip doesn't have VID/PID programmed into the hardware and we need to
  * hack that up to distinguish different modules and their firmware blobs.
@@ -101,7 +77,8 @@ static int download_firmware(struct gb_bootrom *bootrom, u8 stage)
 	int rc;
 
 	/* Already have a firmware, free it */
-	free_firmware(bootrom);
+	if (bootrom->fw)
+		free_firmware(bootrom);
 
 	/*
 	 * Create firmware name
@@ -137,32 +114,25 @@ static int gb_bootrom_firmware_size_request(struct gb_operation *op)
 	struct device *dev = &op->connection->bundle->dev;
 	int ret;
 
-	/* Disable timeouts */
-	del_timer_sync(&bootrom->timer);
-
 	if (op->request->payload_size != sizeof(*size_request)) {
 		dev_err(dev, "%s: illegal size of firmware size request (%zu != %zu)\n",
 			__func__, op->request->payload_size,
 			sizeof(*size_request));
-		ret = -EINVAL;
-		goto mod_timer;
+		return -EINVAL;
 	}
 
-	mutex_lock(&bootrom->mutex);
-
 	ret = download_firmware(bootrom, size_request->stage);
 	if (ret) {
 		dev_err(dev, "%s: failed to download firmware (%d)\n", __func__,
 			ret);
-		goto unlock;
+		return ret;
 	}
 
 	if (!gb_operation_response_alloc(op, sizeof(*size_response),
 					 GFP_KERNEL)) {
 		dev_err(dev, "%s: error allocating response\n", __func__);
 		free_firmware(bootrom);
-		ret = -ENOMEM;
-		goto unlock;
+		return -ENOMEM;
 	}
 
 	size_response = op->response->payload;
@@ -170,44 +140,28 @@ static int gb_bootrom_firmware_size_request(struct gb_operation *op)
 
 	dev_dbg(dev, "%s: firmware size %d bytes\n", __func__, size_response->size);
 
-unlock:
-	mutex_unlock(&bootrom->mutex);
-
-mod_timer:
-	/* Refresh timeout */
-	mod_timer(&bootrom->timer, jiffies + NEXT_REQ_TIMEOUT_J);
-
-	return ret;
+	return 0;
 }
 
 static int gb_bootrom_get_firmware(struct gb_operation *op)
 {
 	struct gb_bootrom *bootrom = gb_connection_get_data(op->connection);
-	const struct firmware *fw;
+	const struct firmware *fw = bootrom->fw;
 	struct gb_bootrom_get_firmware_request *firmware_request;
 	struct gb_bootrom_get_firmware_response *firmware_response;
 	struct device *dev = &op->connection->bundle->dev;
 	unsigned int offset, size;
-	int ret = 0;
-
-	/* Disable timeouts */
-	del_timer_sync(&bootrom->timer);
 
 	if (op->request->payload_size != sizeof(*firmware_request)) {
 		dev_err(dev, "%s: Illegal size of get firmware request (%zu %zu)\n",
 			__func__, op->request->payload_size,
 			sizeof(*firmware_request));
-		ret = -EINVAL;
-		goto mod_timer;
+		return -EINVAL;
 	}
 
-	mutex_lock(&bootrom->mutex);
-
-	fw = bootrom->fw;
 	if (!fw) {
 		dev_err(dev, "%s: firmware not available\n", __func__);
-		ret = -EINVAL;
-		goto unlock;
+		return -EINVAL;
 	}
 
 	firmware_request = op->request->payload;
@@ -217,15 +171,13 @@ static int gb_bootrom_get_firmware(struct gb_operation *op)
 	if (offset >= fw->size || size > fw->size - offset) {
 		dev_warn(dev, "bad firmware request (offs = %u, size = %u)\n",
 				offset, size);
-		ret = -EINVAL;
-		goto unlock;
+		return -EINVAL;
 	}
 
 	if (!gb_operation_response_alloc(op, sizeof(*firmware_response) + size,
 					 GFP_KERNEL)) {
 		dev_err(dev, "%s: error allocating response\n", __func__);
-		ret = -ENOMEM;
-		goto unlock;
+		return -ENOMEM;
 	}
 
 	firmware_response = op->response->payload;
@@ -234,59 +186,36 @@ static int gb_bootrom_get_firmware(struct gb_operation *op)
 	dev_dbg(dev, "responding with firmware (offs = %u, size = %u)\n", offset,
 		size);
 
-unlock:
-	mutex_unlock(&bootrom->mutex);
-
-mod_timer:
-	/* Refresh timeout */
-	mod_timer(&bootrom->timer, jiffies + NEXT_REQ_TIMEOUT_J);
-
-	return ret;
+	return 0;
 }
 
 static int gb_bootrom_ready_to_boot(struct gb_operation *op)
 {
 	struct gb_connection *connection = op->connection;
-	struct gb_bootrom *bootrom = gb_connection_get_data(connection);
 	struct gb_bootrom_ready_to_boot_request *rtb_request;
 	struct device *dev = &connection->bundle->dev;
 	u8 status;
-	int ret = 0;
-
-	/* Disable timeouts */
-	del_timer_sync(&bootrom->timer);
 
 	if (op->request->payload_size != sizeof(*rtb_request)) {
 		dev_err(dev, "%s: Illegal size of ready to boot request (%zu %zu)\n",
 			__func__, op->request->payload_size,
 			sizeof(*rtb_request));
-		ret = -EINVAL;
-		goto mod_timer;
+		return -EINVAL;
 	}
 
 	rtb_request = op->request->payload;
 	status = rtb_request->status;
 
 	/* Return error if the blob was invalid */
-	if (status == GB_BOOTROM_BOOT_STATUS_INVALID) {
-		ret = -EINVAL;
-		goto mod_timer;
-	}
+	if (status == GB_BOOTROM_BOOT_STATUS_INVALID)
+		return -EINVAL;
 
 	/*
 	 * XXX Should we return error for insecure firmware?
 	 */
 	dev_dbg(dev, "ready to boot: 0x%x, 0\n", status);
 
-mod_timer:
-	/*
-	 * Refresh timeout, the Interface shall load the new personality and
-	 * send a new hotplug request, which shall get rid of the bootrom
-	 * connection. As that can take some time, increase the timeout a bit.
-	 */
-	mod_timer(&bootrom->timer, jiffies + 5 * NEXT_REQ_TIMEOUT_J);
-
-	return ret;
+	return 0;
 }
 
 static int gb_bootrom_request_handler(struct gb_operation *op)
@@ -375,11 +304,6 @@ static int gb_bootrom_probe(struct gb_bundle *bundle,
 
 	bootrom->connection = connection;
 
-	mutex_init(&bootrom->mutex);
-	init_timer(&bootrom->timer);
-	bootrom->timer.function = gb_bootrom_timedout;
-	bootrom->timer.data = (unsigned long)bootrom;
-
 	greybus_set_drvdata(bundle, bootrom);
 
 	ret = gb_connection_enable_tx(connection);
@@ -405,9 +329,6 @@ static int gb_bootrom_probe(struct gb_bundle *bundle,
 		goto err_connection_disable;
 	}
 
-	/* Refresh timeout */
-	mod_timer(&bootrom->timer, jiffies + NEXT_REQ_TIMEOUT_J);
-
 	dev_dbg(&bundle->dev, "AP_READY sent\n");
 
 	return 0;
@@ -430,16 +351,9 @@ static void gb_bootrom_disconnect(struct gb_bundle *bundle)
 
 	gb_connection_disable(bootrom->connection);
 
-	/* Disable timeouts */
-	del_timer_sync(&bootrom->timer);
-
-	/*
-	 * Release firmware:
-	 *
-	 * As the connection and the timer are already disabled, we don't need
-	 * to lock access to bootrom->fw here.
-	 */
-	free_firmware(bootrom);
+	/* Release firmware */
+	if (bootrom->fw)
+		free_firmware(bootrom);
 
 	gb_connection_destroy(bootrom->connection);
 	kfree(bootrom);

commit c81b1ec7853d083981b6edd1d7397d94b88dd597
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Tue May 3 16:13:12 2016 +0530

    greybus: bootrom: Implement timeouts to detect Module failures
    
    Its possible that the Module may fail to download the next stage
    firmware, or to jump into it and boot into the new personality.
    
    We have already seen examples of both of these cases on EVT 1.5.
    
    This patch implements timeouts in the bootrom bundle driver, which now
    expects the next request from the Module to be received at the AP within
    1 second of the previous request/response. The time interval can be
    increased later if required.
    
    The timeouts are added between:
    - AP_READY and FIRMWARE_SIZE operations
    - FIRMWARE_SIZE and GET_FIRMWARE operations
    - Two GET_FIRMWARE operations
    - GET_FIRMWARE and READY_TO_BOOT operations
    - READY_TO_BOOT operation and the call to the ->disconnect() event of
      the bootrom bundle (once the new hotplug request is received).
    
    The timeout for the last case is kept at 5 seconds right now (random
    value), as it may take a bit longer.
    
    Because 'bootrom->fw' can be accessed simultaneously (from timeout
    handler and incoming requests) and one of them can potentially free the
    '->fw' structure, a mutex is also added to take care of such races while
    accessing 'bootrom->fw' structure.
    
    Also note that the '!bootrom->fw' check is moved to free_firmware()
    routine.
    
    Tested on EVT 1.5, by faking errors on certain requests, so that the
    bootrom doesn't send any more requests. Normal case is working just
    fine for audio and GP modules.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/bootrom.c b/drivers/staging/greybus/bootrom.c
index cf750beb3403..baada45329a2 100644
--- a/drivers/staging/greybus/bootrom.c
+++ b/drivers/staging/greybus/bootrom.c
@@ -8,24 +8,48 @@
  */
 
 #include <linux/firmware.h>
+#include <linux/jiffies.h>
+#include <linux/mutex.h>
+#include <linux/timer.h>
 
 #include "bootrom.h"
 #include "greybus.h"
 
+/* Timeout, in jiffies, within which the next request must be received */
+#define NEXT_REQ_TIMEOUT_J	msecs_to_jiffies(1000)
 
 struct gb_bootrom {
 	struct gb_connection	*connection;
 	const struct firmware	*fw;
 	u8			protocol_major;
 	u8			protocol_minor;
+	struct timer_list	timer;
+	struct mutex		mutex; /* Protects bootrom->fw */
 };
 
 static void free_firmware(struct gb_bootrom *bootrom)
 {
+	if (!bootrom->fw)
+		return;
+
 	release_firmware(bootrom->fw);
 	bootrom->fw = NULL;
 }
 
+static void gb_bootrom_timedout(unsigned long data)
+{
+	struct gb_bootrom *bootrom = (struct gb_bootrom *)data;
+	struct device *dev = &bootrom->connection->bundle->dev;
+
+	dev_err(dev, "Timed out waiting for request from the Module\n");
+
+	mutex_lock(&bootrom->mutex);
+	free_firmware(bootrom);
+	mutex_unlock(&bootrom->mutex);
+
+	/* TODO: Power-off Module ? */
+}
+
 /*
  * The es2 chip doesn't have VID/PID programmed into the hardware and we need to
  * hack that up to distinguish different modules and their firmware blobs.
@@ -77,8 +101,7 @@ static int download_firmware(struct gb_bootrom *bootrom, u8 stage)
 	int rc;
 
 	/* Already have a firmware, free it */
-	if (bootrom->fw)
-		free_firmware(bootrom);
+	free_firmware(bootrom);
 
 	/*
 	 * Create firmware name
@@ -114,25 +137,32 @@ static int gb_bootrom_firmware_size_request(struct gb_operation *op)
 	struct device *dev = &op->connection->bundle->dev;
 	int ret;
 
+	/* Disable timeouts */
+	del_timer_sync(&bootrom->timer);
+
 	if (op->request->payload_size != sizeof(*size_request)) {
 		dev_err(dev, "%s: illegal size of firmware size request (%zu != %zu)\n",
 			__func__, op->request->payload_size,
 			sizeof(*size_request));
-		return -EINVAL;
+		ret = -EINVAL;
+		goto mod_timer;
 	}
 
+	mutex_lock(&bootrom->mutex);
+
 	ret = download_firmware(bootrom, size_request->stage);
 	if (ret) {
 		dev_err(dev, "%s: failed to download firmware (%d)\n", __func__,
 			ret);
-		return ret;
+		goto unlock;
 	}
 
 	if (!gb_operation_response_alloc(op, sizeof(*size_response),
 					 GFP_KERNEL)) {
 		dev_err(dev, "%s: error allocating response\n", __func__);
 		free_firmware(bootrom);
-		return -ENOMEM;
+		ret = -ENOMEM;
+		goto unlock;
 	}
 
 	size_response = op->response->payload;
@@ -140,28 +170,44 @@ static int gb_bootrom_firmware_size_request(struct gb_operation *op)
 
 	dev_dbg(dev, "%s: firmware size %d bytes\n", __func__, size_response->size);
 
-	return 0;
+unlock:
+	mutex_unlock(&bootrom->mutex);
+
+mod_timer:
+	/* Refresh timeout */
+	mod_timer(&bootrom->timer, jiffies + NEXT_REQ_TIMEOUT_J);
+
+	return ret;
 }
 
 static int gb_bootrom_get_firmware(struct gb_operation *op)
 {
 	struct gb_bootrom *bootrom = gb_connection_get_data(op->connection);
-	const struct firmware *fw = bootrom->fw;
+	const struct firmware *fw;
 	struct gb_bootrom_get_firmware_request *firmware_request;
 	struct gb_bootrom_get_firmware_response *firmware_response;
 	struct device *dev = &op->connection->bundle->dev;
 	unsigned int offset, size;
+	int ret = 0;
+
+	/* Disable timeouts */
+	del_timer_sync(&bootrom->timer);
 
 	if (op->request->payload_size != sizeof(*firmware_request)) {
 		dev_err(dev, "%s: Illegal size of get firmware request (%zu %zu)\n",
 			__func__, op->request->payload_size,
 			sizeof(*firmware_request));
-		return -EINVAL;
+		ret = -EINVAL;
+		goto mod_timer;
 	}
 
+	mutex_lock(&bootrom->mutex);
+
+	fw = bootrom->fw;
 	if (!fw) {
 		dev_err(dev, "%s: firmware not available\n", __func__);
-		return -EINVAL;
+		ret = -EINVAL;
+		goto unlock;
 	}
 
 	firmware_request = op->request->payload;
@@ -171,13 +217,15 @@ static int gb_bootrom_get_firmware(struct gb_operation *op)
 	if (offset >= fw->size || size > fw->size - offset) {
 		dev_warn(dev, "bad firmware request (offs = %u, size = %u)\n",
 				offset, size);
-		return -EINVAL;
+		ret = -EINVAL;
+		goto unlock;
 	}
 
 	if (!gb_operation_response_alloc(op, sizeof(*firmware_response) + size,
 					 GFP_KERNEL)) {
 		dev_err(dev, "%s: error allocating response\n", __func__);
-		return -ENOMEM;
+		ret = -ENOMEM;
+		goto unlock;
 	}
 
 	firmware_response = op->response->payload;
@@ -186,36 +234,59 @@ static int gb_bootrom_get_firmware(struct gb_operation *op)
 	dev_dbg(dev, "responding with firmware (offs = %u, size = %u)\n", offset,
 		size);
 
-	return 0;
+unlock:
+	mutex_unlock(&bootrom->mutex);
+
+mod_timer:
+	/* Refresh timeout */
+	mod_timer(&bootrom->timer, jiffies + NEXT_REQ_TIMEOUT_J);
+
+	return ret;
 }
 
 static int gb_bootrom_ready_to_boot(struct gb_operation *op)
 {
 	struct gb_connection *connection = op->connection;
+	struct gb_bootrom *bootrom = gb_connection_get_data(connection);
 	struct gb_bootrom_ready_to_boot_request *rtb_request;
 	struct device *dev = &connection->bundle->dev;
 	u8 status;
+	int ret = 0;
+
+	/* Disable timeouts */
+	del_timer_sync(&bootrom->timer);
 
 	if (op->request->payload_size != sizeof(*rtb_request)) {
 		dev_err(dev, "%s: Illegal size of ready to boot request (%zu %zu)\n",
 			__func__, op->request->payload_size,
 			sizeof(*rtb_request));
-		return -EINVAL;
+		ret = -EINVAL;
+		goto mod_timer;
 	}
 
 	rtb_request = op->request->payload;
 	status = rtb_request->status;
 
 	/* Return error if the blob was invalid */
-	if (status == GB_BOOTROM_BOOT_STATUS_INVALID)
-		return -EINVAL;
+	if (status == GB_BOOTROM_BOOT_STATUS_INVALID) {
+		ret = -EINVAL;
+		goto mod_timer;
+	}
 
 	/*
 	 * XXX Should we return error for insecure firmware?
 	 */
 	dev_dbg(dev, "ready to boot: 0x%x, 0\n", status);
 
-	return 0;
+mod_timer:
+	/*
+	 * Refresh timeout, the Interface shall load the new personality and
+	 * send a new hotplug request, which shall get rid of the bootrom
+	 * connection. As that can take some time, increase the timeout a bit.
+	 */
+	mod_timer(&bootrom->timer, jiffies + 5 * NEXT_REQ_TIMEOUT_J);
+
+	return ret;
 }
 
 static int gb_bootrom_request_handler(struct gb_operation *op)
@@ -304,6 +375,11 @@ static int gb_bootrom_probe(struct gb_bundle *bundle,
 
 	bootrom->connection = connection;
 
+	mutex_init(&bootrom->mutex);
+	init_timer(&bootrom->timer);
+	bootrom->timer.function = gb_bootrom_timedout;
+	bootrom->timer.data = (unsigned long)bootrom;
+
 	greybus_set_drvdata(bundle, bootrom);
 
 	ret = gb_connection_enable_tx(connection);
@@ -329,6 +405,9 @@ static int gb_bootrom_probe(struct gb_bundle *bundle,
 		goto err_connection_disable;
 	}
 
+	/* Refresh timeout */
+	mod_timer(&bootrom->timer, jiffies + NEXT_REQ_TIMEOUT_J);
+
 	dev_dbg(&bundle->dev, "AP_READY sent\n");
 
 	return 0;
@@ -351,9 +430,16 @@ static void gb_bootrom_disconnect(struct gb_bundle *bundle)
 
 	gb_connection_disable(bootrom->connection);
 
-	/* Release firmware */
-	if (bootrom->fw)
-		free_firmware(bootrom);
+	/* Disable timeouts */
+	del_timer_sync(&bootrom->timer);
+
+	/*
+	 * Release firmware:
+	 *
+	 * As the connection and the timer are already disabled, we don't need
+	 * to lock access to bootrom->fw here.
+	 */
+	free_firmware(bootrom);
 
 	gb_connection_destroy(bootrom->connection);
 	kfree(bootrom);

commit de86e251f87fbc22efc935911f570c97f9b95cac
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Thu Apr 21 08:13:01 2016 +0530

    greybus: bootrom: fix typo
    
    s/Firware/Firmware
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/bootrom.c b/drivers/staging/greybus/bootrom.c
index 3cbe9feff53d..cf750beb3403 100644
--- a/drivers/staging/greybus/bootrom.c
+++ b/drivers/staging/greybus/bootrom.c
@@ -101,7 +101,7 @@ static int download_firmware(struct gb_bootrom *bootrom, u8 stage)
 		&connection->bundle->dev);
 	if (rc)
 		dev_err(&connection->bundle->dev,
-			"Firware request for %s has failed : %d",
+			"Firmware request for %s has failed : %d",
 			firmware_name, rc);
 	return rc;
 }

commit 5a53e02eaf223c42c6ca8d9664c1191ea7c2b106
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Sun Apr 3 12:18:35 2016 +0530

    greybus: firmware: Rename to bootrom protocol
    
    Align with Greybus specifications and rename Firmware Protocol driver as
    Bootrom Protocol driver.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/bootrom.c b/drivers/staging/greybus/bootrom.c
new file mode 100644
index 000000000000..3cbe9feff53d
--- /dev/null
+++ b/drivers/staging/greybus/bootrom.c
@@ -0,0 +1,382 @@
+/*
+ * BOOTROM Greybus driver.
+ *
+ * Copyright 2016 Google Inc.
+ * Copyright 2016 Linaro Ltd.
+ *
+ * Released under the GPLv2 only.
+ */
+
+#include <linux/firmware.h>
+
+#include "bootrom.h"
+#include "greybus.h"
+
+
+struct gb_bootrom {
+	struct gb_connection	*connection;
+	const struct firmware	*fw;
+	u8			protocol_major;
+	u8			protocol_minor;
+};
+
+static void free_firmware(struct gb_bootrom *bootrom)
+{
+	release_firmware(bootrom->fw);
+	bootrom->fw = NULL;
+}
+
+/*
+ * The es2 chip doesn't have VID/PID programmed into the hardware and we need to
+ * hack that up to distinguish different modules and their firmware blobs.
+ *
+ * This fetches VID/PID (over bootrom protocol) for es2 chip only, when VID/PID
+ * already sent during hotplug are 0.
+ *
+ * Otherwise, we keep intf->vendor_id/product_id same as what's passed
+ * during hotplug.
+ */
+static void bootrom_es2_fixup_vid_pid(struct gb_bootrom *bootrom)
+{
+	struct gb_bootrom_get_vid_pid_response response;
+	struct gb_connection *connection = bootrom->connection;
+	struct gb_interface *intf = connection->bundle->intf;
+	int ret;
+
+	if (!(intf->quirks & GB_INTERFACE_QUIRK_NO_ARA_IDS))
+		return;
+
+	ret = gb_operation_sync(connection, GB_BOOTROM_TYPE_GET_VID_PID,
+				NULL, 0, &response, sizeof(response));
+	if (ret) {
+		dev_err(&connection->bundle->dev,
+			"Bootrom get vid/pid operation failed (%d)\n", ret);
+		return;
+	}
+
+	/*
+	 * NOTE: This is hacked, so that the same values of VID/PID can be used
+	 * by next firmware level as well. The uevent for bootrom will still
+	 * have VID/PID as 0, though after this point the sysfs files will start
+	 * showing the updated values. But yeah, that's a bit racy as the same
+	 * sysfs files would be showing 0 before this point.
+	 */
+	intf->vendor_id = le32_to_cpu(response.vendor_id);
+	intf->product_id = le32_to_cpu(response.product_id);
+
+	dev_dbg(&connection->bundle->dev, "Bootrom got vid (0x%x)/pid (0x%x)\n",
+		intf->vendor_id, intf->product_id);
+}
+
+/* This returns path of the firmware blob on the disk */
+static int download_firmware(struct gb_bootrom *bootrom, u8 stage)
+{
+	struct gb_connection *connection = bootrom->connection;
+	struct gb_interface *intf = connection->bundle->intf;
+	char firmware_name[48];
+	int rc;
+
+	/* Already have a firmware, free it */
+	if (bootrom->fw)
+		free_firmware(bootrom);
+
+	/*
+	 * Create firmware name
+	 *
+	 * XXX Name it properly..
+	 */
+	snprintf(firmware_name, sizeof(firmware_name),
+		 "ara_%08x_%08x_%08x_%08x_%02x.tftf",
+		 intf->ddbl1_manufacturer_id, intf->ddbl1_product_id,
+		 intf->vendor_id, intf->product_id, stage);
+
+	// FIXME:
+	// Turn to dev_dbg later after everyone has valid bootloaders with good
+	// ids, but leave this as dev_info for now to make it easier to track
+	// down "empty" vid/pid modules.
+	dev_info(&connection->bundle->dev, "Firmware file '%s' requested\n",
+		 firmware_name);
+
+	rc = request_firmware(&bootrom->fw, firmware_name,
+		&connection->bundle->dev);
+	if (rc)
+		dev_err(&connection->bundle->dev,
+			"Firware request for %s has failed : %d",
+			firmware_name, rc);
+	return rc;
+}
+
+static int gb_bootrom_firmware_size_request(struct gb_operation *op)
+{
+	struct gb_bootrom *bootrom = gb_connection_get_data(op->connection);
+	struct gb_bootrom_firmware_size_request *size_request = op->request->payload;
+	struct gb_bootrom_firmware_size_response *size_response;
+	struct device *dev = &op->connection->bundle->dev;
+	int ret;
+
+	if (op->request->payload_size != sizeof(*size_request)) {
+		dev_err(dev, "%s: illegal size of firmware size request (%zu != %zu)\n",
+			__func__, op->request->payload_size,
+			sizeof(*size_request));
+		return -EINVAL;
+	}
+
+	ret = download_firmware(bootrom, size_request->stage);
+	if (ret) {
+		dev_err(dev, "%s: failed to download firmware (%d)\n", __func__,
+			ret);
+		return ret;
+	}
+
+	if (!gb_operation_response_alloc(op, sizeof(*size_response),
+					 GFP_KERNEL)) {
+		dev_err(dev, "%s: error allocating response\n", __func__);
+		free_firmware(bootrom);
+		return -ENOMEM;
+	}
+
+	size_response = op->response->payload;
+	size_response->size = cpu_to_le32(bootrom->fw->size);
+
+	dev_dbg(dev, "%s: firmware size %d bytes\n", __func__, size_response->size);
+
+	return 0;
+}
+
+static int gb_bootrom_get_firmware(struct gb_operation *op)
+{
+	struct gb_bootrom *bootrom = gb_connection_get_data(op->connection);
+	const struct firmware *fw = bootrom->fw;
+	struct gb_bootrom_get_firmware_request *firmware_request;
+	struct gb_bootrom_get_firmware_response *firmware_response;
+	struct device *dev = &op->connection->bundle->dev;
+	unsigned int offset, size;
+
+	if (op->request->payload_size != sizeof(*firmware_request)) {
+		dev_err(dev, "%s: Illegal size of get firmware request (%zu %zu)\n",
+			__func__, op->request->payload_size,
+			sizeof(*firmware_request));
+		return -EINVAL;
+	}
+
+	if (!fw) {
+		dev_err(dev, "%s: firmware not available\n", __func__);
+		return -EINVAL;
+	}
+
+	firmware_request = op->request->payload;
+	offset = le32_to_cpu(firmware_request->offset);
+	size = le32_to_cpu(firmware_request->size);
+
+	if (offset >= fw->size || size > fw->size - offset) {
+		dev_warn(dev, "bad firmware request (offs = %u, size = %u)\n",
+				offset, size);
+		return -EINVAL;
+	}
+
+	if (!gb_operation_response_alloc(op, sizeof(*firmware_response) + size,
+					 GFP_KERNEL)) {
+		dev_err(dev, "%s: error allocating response\n", __func__);
+		return -ENOMEM;
+	}
+
+	firmware_response = op->response->payload;
+	memcpy(firmware_response->data, fw->data + offset, size);
+
+	dev_dbg(dev, "responding with firmware (offs = %u, size = %u)\n", offset,
+		size);
+
+	return 0;
+}
+
+static int gb_bootrom_ready_to_boot(struct gb_operation *op)
+{
+	struct gb_connection *connection = op->connection;
+	struct gb_bootrom_ready_to_boot_request *rtb_request;
+	struct device *dev = &connection->bundle->dev;
+	u8 status;
+
+	if (op->request->payload_size != sizeof(*rtb_request)) {
+		dev_err(dev, "%s: Illegal size of ready to boot request (%zu %zu)\n",
+			__func__, op->request->payload_size,
+			sizeof(*rtb_request));
+		return -EINVAL;
+	}
+
+	rtb_request = op->request->payload;
+	status = rtb_request->status;
+
+	/* Return error if the blob was invalid */
+	if (status == GB_BOOTROM_BOOT_STATUS_INVALID)
+		return -EINVAL;
+
+	/*
+	 * XXX Should we return error for insecure firmware?
+	 */
+	dev_dbg(dev, "ready to boot: 0x%x, 0\n", status);
+
+	return 0;
+}
+
+static int gb_bootrom_request_handler(struct gb_operation *op)
+{
+	u8 type = op->type;
+
+	switch (type) {
+	case GB_BOOTROM_TYPE_FIRMWARE_SIZE:
+		return gb_bootrom_firmware_size_request(op);
+	case GB_BOOTROM_TYPE_GET_FIRMWARE:
+		return gb_bootrom_get_firmware(op);
+	case GB_BOOTROM_TYPE_READY_TO_BOOT:
+		return gb_bootrom_ready_to_boot(op);
+	default:
+		dev_err(&op->connection->bundle->dev,
+			"unsupported request: %u\n", type);
+		return -EINVAL;
+	}
+}
+
+static int gb_bootrom_get_version(struct gb_bootrom *bootrom)
+{
+	struct gb_bundle *bundle = bootrom->connection->bundle;
+	struct gb_bootrom_version_request request;
+	struct gb_bootrom_version_response response;
+	int ret;
+
+	request.major = GB_BOOTROM_VERSION_MAJOR;
+	request.minor = GB_BOOTROM_VERSION_MINOR;
+
+	ret = gb_operation_sync(bootrom->connection,
+				GB_BOOTROM_TYPE_VERSION,
+				&request, sizeof(request), &response,
+				sizeof(response));
+	if (ret) {
+		dev_err(&bundle->dev,
+				"failed to get protocol version: %d\n",
+				ret);
+		return ret;
+	}
+
+	if (response.major > request.major) {
+		dev_err(&bundle->dev,
+				"unsupported major protocol version (%u > %u)\n",
+				response.major, request.major);
+		return -ENOTSUPP;
+	}
+
+	bootrom->protocol_major = response.major;
+	bootrom->protocol_minor = response.minor;
+
+	dev_dbg(&bundle->dev, "%s - %u.%u\n", __func__, response.major,
+			response.minor);
+
+	return 0;
+}
+
+static int gb_bootrom_probe(struct gb_bundle *bundle,
+					const struct greybus_bundle_id *id)
+{
+	struct greybus_descriptor_cport *cport_desc;
+	struct gb_connection *connection;
+	struct gb_bootrom *bootrom;
+	int ret;
+
+	if (bundle->num_cports != 1)
+		return -ENODEV;
+
+	cport_desc = &bundle->cport_desc[0];
+	if (cport_desc->protocol_id != GREYBUS_PROTOCOL_BOOTROM)
+		return -ENODEV;
+
+	bootrom = kzalloc(sizeof(*bootrom), GFP_KERNEL);
+	if (!bootrom)
+		return -ENOMEM;
+
+	connection = gb_connection_create(bundle,
+						le16_to_cpu(cport_desc->id),
+						gb_bootrom_request_handler);
+	if (IS_ERR(connection)) {
+		ret = PTR_ERR(connection);
+		goto err_free_bootrom;
+	}
+
+	gb_connection_set_data(connection, bootrom);
+
+	bootrom->connection = connection;
+
+	greybus_set_drvdata(bundle, bootrom);
+
+	ret = gb_connection_enable_tx(connection);
+	if (ret)
+		goto err_connection_destroy;
+
+	ret = gb_bootrom_get_version(bootrom);
+	if (ret)
+		goto err_connection_disable;
+
+	bootrom_es2_fixup_vid_pid(bootrom);
+
+	ret = gb_connection_enable(connection);
+	if (ret)
+		goto err_connection_disable;
+
+	/* Tell bootrom we're ready. */
+	ret = gb_operation_sync(connection, GB_BOOTROM_TYPE_AP_READY, NULL, 0,
+				NULL, 0);
+	if (ret) {
+		dev_err(&connection->bundle->dev,
+				"failed to send AP READY: %d\n", ret);
+		goto err_connection_disable;
+	}
+
+	dev_dbg(&bundle->dev, "AP_READY sent\n");
+
+	return 0;
+
+err_connection_disable:
+	gb_connection_disable(connection);
+err_connection_destroy:
+	gb_connection_destroy(connection);
+err_free_bootrom:
+	kfree(bootrom);
+
+	return ret;
+}
+
+static void gb_bootrom_disconnect(struct gb_bundle *bundle)
+{
+	struct gb_bootrom *bootrom = greybus_get_drvdata(bundle);
+
+	dev_dbg(&bundle->dev, "%s\n", __func__);
+
+	gb_connection_disable(bootrom->connection);
+
+	/* Release firmware */
+	if (bootrom->fw)
+		free_firmware(bootrom);
+
+	gb_connection_destroy(bootrom->connection);
+	kfree(bootrom);
+}
+
+static const struct greybus_bundle_id gb_bootrom_id_table[] = {
+	{ GREYBUS_DEVICE_CLASS(GREYBUS_CLASS_BOOTROM) },
+	{ }
+};
+
+static struct greybus_driver gb_bootrom_driver = {
+	.name		= "bootrom",
+	.probe		= gb_bootrom_probe,
+	.disconnect	= gb_bootrom_disconnect,
+	.id_table	= gb_bootrom_id_table,
+};
+
+int gb_bootrom_init(void)
+{
+	return greybus_register(&gb_bootrom_driver);
+}
+
+void gb_bootrom_exit(void)
+{
+	greybus_deregister(&gb_bootrom_driver);
+}
