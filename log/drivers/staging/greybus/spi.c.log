commit ec0ad868173da8a75121f9dc116a5d5478ff614d
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Sun Aug 25 07:54:27 2019 +0200

    staging: greybus: move core include files to include/linux/greybus/
    
    With the goal of moving the core of the greybus code out of staging, the
    include files need to be moved to include/linux/greybus.h and
    include/linux/greybus/
    
    Cc: Vaibhav Hiremath <hvaibhav.linux@gmail.com>
    Cc: Johan Hovold <johan@kernel.org>
    Cc: Vaibhav Agarwal <vaibhav.sr@gmail.com>
    Cc: Rui Miguel Silva <rmfrfs@gmail.com>
    Cc: David Lin <dtwlin@gmail.com>
    Cc: "Bryan O'Donoghue" <pure.logic@nexus-software.ie>
    Cc: greybus-dev@lists.linaro.org
    Cc: devel@driverdev.osuosl.org
    Acked-by: Mark Greer <mgreer@animalcreek.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Acked-by: Alex Elder <elder@kernel.org>
    Link: https://lore.kernel.org/r/20190825055429.18547-8-gregkh@linuxfoundation.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/spi.c b/drivers/staging/greybus/spi.c
index 47d896992b35..68e8d272db6d 100644
--- a/drivers/staging/greybus/spi.c
+++ b/drivers/staging/greybus/spi.c
@@ -7,8 +7,8 @@
  */
 
 #include <linux/module.h>
+#include <linux/greybus.h>
 
-#include "greybus.h"
 #include "gbphy.h"
 #include "spilib.h"
 

commit 863dbc52e7f0e5acd7b4883f3933543a81c474c7
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Nov 7 14:58:42 2017 +0100

    staging: greybus: Remove redundant license text
    
    Now that the SPDX tag is in all greybus files, that identifies the
    license in a specific and legally-defined manner.  So the extra GPL text
    wording can be removed as it is no longer needed at all.
    
    This is done on a quest to remove the 700+ different ways that files in
    the kernel describe the GPL license text.  And there's unneeded stuff
    like the address (sometimes incorrect) for the FSF which is never
    needed.
    
    No copyright headers or other non-license-description text was removed.
    
    Cc: Vaibhav Hiremath <hvaibhav.linux@gmail.com>
    Reviewed-by: Alex Elder <elder@linaro.org>
    Acked-by: Vaibhav Agarwal <vaibhav.sr@gmail.com>
    Acked-by: David Lin <dtwlin@gmail.com>
    Acked-by: Johan Hovold <johan@kernel.org>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Acked-by: Mark Greer <mgreer@animalcreek.com>
    Acked-by: Rui Miguel Silva <rmfrfs@gmail.com>
    Acked-by: "Bryan O'Donoghue" <pure.logic@nexus-software.ie>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/spi.c b/drivers/staging/greybus/spi.c
index f3fb00826b6e..47d896992b35 100644
--- a/drivers/staging/greybus/spi.c
+++ b/drivers/staging/greybus/spi.c
@@ -4,8 +4,6 @@
  *
  * Copyright 2014-2016 Google Inc.
  * Copyright 2014-2016 Linaro Ltd.
- *
- * Released under the GPLv2 only.
  */
 
 #include <linux/module.h>

commit eb50fd3a22c770f36be275295b782f3ea52e3215
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Nov 7 14:58:41 2017 +0100

    staging: greybus: add SPDX identifiers to all greybus driver files
    
    It's good to have SPDX identifiers in all files to make it easier to
    audit the kernel tree for correct licenses.
    
    Update the drivers/staging/greybus files files with the correct SPDX
    license identifier based on the license text in the file itself.  The
    SPDX identifier is a legally binding shorthand, which can be used
    instead of the full boiler plate text.
    
    This work is based on a script and data from Thomas Gleixner, Philippe
    Ombredanne, and Kate Stewart.
    
    Cc: Vaibhav Hiremath <hvaibhav.linux@gmail.com>
    Cc: "Bryan O'Donoghue" <pure.logic@nexus-software.ie>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: Philippe Ombredanne <pombredanne@nexb.com>
    Acked-by: Vaibhav Agarwal <vaibhav.sr@gmail.com>
    Acked-by: David Lin <dtwlin@gmail.com>
    Reviewed-by: Alex Elder <elder@linaro.org>
    Acked-by: Johan Hovold <johan@kernel.org>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Acked-by: Mark Greer <mgreer@animalcreek.com>
    Acked-by: Rui Miguel Silva <rmfrfs@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/spi.c b/drivers/staging/greybus/spi.c
index c893552b5c0b..f3fb00826b6e 100644
--- a/drivers/staging/greybus/spi.c
+++ b/drivers/staging/greybus/spi.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * SPI bridge PHY driver.
  *

commit 148e0b8f48a83008596876befe1d9aed256c8ea1
Author: Greg Kroah-Hartman <gregkh@google.com>
Date:   Thu Sep 8 16:06:27 2016 +0200

    staging: greybus: spi: remove KERNEL_VERSION checks
    
    No need to support older kernel versions in the Greybus SPI and spilib
    driver, so remove the checks as needed, we can now rely on all of the
    correct SPI core apis being present.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/spi.c b/drivers/staging/greybus/spi.c
index bb76b3c0118d..c893552b5c0b 100644
--- a/drivers/staging/greybus/spi.c
+++ b/drivers/staging/greybus/spi.c
@@ -13,26 +13,7 @@
 #include "gbphy.h"
 #include "spilib.h"
 
-#ifndef SPI_CORE_SUPPORT_PM
-static int gbphy_spi_prepare_transfer_hardware(struct device *dev)
-{
-	return gbphy_runtime_get_sync(to_gbphy_dev(dev));
-}
-
-static void gbphy_spi_unprepare_transfer_hardware(struct device *dev)
-{
-	gbphy_runtime_put_autosuspend(to_gbphy_dev(dev));
-}
-
-static struct spilib_ops __spilib_ops = {
-	.prepare_transfer_hardware = gbphy_spi_prepare_transfer_hardware,
-	.unprepare_transfer_hardware = gbphy_spi_unprepare_transfer_hardware,
-};
-
-static struct spilib_ops *spilib_ops = &__spilib_ops;
-#else
-static struct spilib_ops *spilib_ops = NULL;
-#endif
+static struct spilib_ops *spilib_ops;
 
 static int gb_spi_probe(struct gbphy_device *gbphy_dev,
 			const struct gbphy_device_id *id)

commit 92bcaddea3197e477bb37439805fcb5a2f9942d7
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Thu Jul 21 14:45:06 2016 -0700

    greybus: spilib: make spilib independent of gbphy
    
    spilib is used by multiple users currently (spi.c and fw-core.c) but
    commit aa52b62a0556 broke that hierarchy and introduced gbphy dependent
    code in spilib.
    
    This may have unreliable consequences as we are doing following
    operation unconditionally now:
    
            gbphy_dev = to_gbphy_dev(spi->parent);
            gbphy_runtime_get_sync(gbphy_dev);
    
    which may not go well when the parent is of type &bundle->dev
    (fw-core.c).
    
    This patch introduces spilib_ops and lets the users of the core register
    them. This shall have no functional change for the spi.c usecase and
    shall fix the unreliable results for the fw-core.c usecase.
    
    Tested by writing to mtd0 dev and verifying (with print messages) that
    the below routines are getting called for a gpbridge-test module.
    
    Fixes: aa52b62a0556 ("spi: Add runtime_pm support")
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/spi.c b/drivers/staging/greybus/spi.c
index 2e6e328bae9e..bb76b3c0118d 100644
--- a/drivers/staging/greybus/spi.c
+++ b/drivers/staging/greybus/spi.c
@@ -13,6 +13,27 @@
 #include "gbphy.h"
 #include "spilib.h"
 
+#ifndef SPI_CORE_SUPPORT_PM
+static int gbphy_spi_prepare_transfer_hardware(struct device *dev)
+{
+	return gbphy_runtime_get_sync(to_gbphy_dev(dev));
+}
+
+static void gbphy_spi_unprepare_transfer_hardware(struct device *dev)
+{
+	gbphy_runtime_put_autosuspend(to_gbphy_dev(dev));
+}
+
+static struct spilib_ops __spilib_ops = {
+	.prepare_transfer_hardware = gbphy_spi_prepare_transfer_hardware,
+	.unprepare_transfer_hardware = gbphy_spi_unprepare_transfer_hardware,
+};
+
+static struct spilib_ops *spilib_ops = &__spilib_ops;
+#else
+static struct spilib_ops *spilib_ops = NULL;
+#endif
+
 static int gb_spi_probe(struct gbphy_device *gbphy_dev,
 			const struct gbphy_device_id *id)
 {
@@ -29,7 +50,7 @@ static int gb_spi_probe(struct gbphy_device *gbphy_dev,
 	if (ret)
 		goto exit_connection_destroy;
 
-	ret = gb_spilib_master_init(connection, &gbphy_dev->dev);
+	ret = gb_spilib_master_init(connection, &gbphy_dev->dev, spilib_ops);
 	if (ret)
 		goto exit_connection_disable;
 

commit 4c615dcc6a9d910f8f68e4b57889b628e80165d4
Author: Axel Haslam <ahaslam@baylibre.com>
Date:   Thu Jul 14 15:13:00 2016 -0500

    greybus: spi: Add runtime_pm support
    
    Add runtime operations to the spi driver so that the
    module is woken up when an spi transfer is started
    and put back to sleep when the transfer is done.
    
    Testing Done: Let the module enter standby and initiate
    an spi operation. The operation wakes up the module
    and succeeds.
    
    Signed-off-by: Axel Haslam <ahaslam@baylibre.com>
    Signed-off-by: David Lin <dtwlin@google.com>
    Reviewed-by: Rui Miguel Silva <rui.silva@linaro.org>
    Signed-off-by: Alex Elder <elder@linaro.org>

diff --git a/drivers/staging/greybus/spi.c b/drivers/staging/greybus/spi.c
index a82337931c0d..2e6e328bae9e 100644
--- a/drivers/staging/greybus/spi.c
+++ b/drivers/staging/greybus/spi.c
@@ -35,6 +35,7 @@ static int gb_spi_probe(struct gbphy_device *gbphy_dev,
 
 	gb_gbphy_set_data(gbphy_dev, connection);
 
+	gbphy_runtime_put_autosuspend(gbphy_dev);
 	return 0;
 
 exit_connection_disable:
@@ -48,6 +49,11 @@ static int gb_spi_probe(struct gbphy_device *gbphy_dev,
 static void gb_spi_remove(struct gbphy_device *gbphy_dev)
 {
 	struct gb_connection *connection = gb_gbphy_get_data(gbphy_dev);
+	int ret;
+
+	ret = gbphy_runtime_get_sync(gbphy_dev);
+	if (ret)
+		gbphy_runtime_get_noresume(gbphy_dev);
 
 	gb_spilib_master_exit(connection);
 	gb_connection_disable(connection);

commit 64060fe95458f22bac7327b2ee8dc5ce9e488d44
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Mon May 30 11:31:53 2016 +0530

    greybus: gbphy: Remove protocol specific version handling
    
    We should be using the generic version handling at bundle level, instead
    of at protocol level for bridged PHY devices as well.
    
    The bundle version handling is already in place, though it is *not* used
    today as we haven't bumped the version of control protocol yet.
    
    Remove protocol specific handling for bridged PHY devices.
    
    Tested on EVT 1.5 with gpbridge-test module. No nuttx changes are
    required with this.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Reviewed-by: Johan Hovold <johan@hovoldconsulting.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/spi.c b/drivers/staging/greybus/spi.c
index 4f13efeeb91e..a82337931c0d 100644
--- a/drivers/staging/greybus/spi.c
+++ b/drivers/staging/greybus/spi.c
@@ -29,10 +29,6 @@ static int gb_spi_probe(struct gbphy_device *gbphy_dev,
 	if (ret)
 		goto exit_connection_destroy;
 
-	ret = gb_gbphy_get_version(connection);
-	if (ret)
-		goto exit_connection_disable;
-
 	ret = gb_spilib_master_init(connection, &gbphy_dev->dev);
 	if (ret)
 		goto exit_connection_disable;

commit e54b106dd1be50377fe8365392466e080b659ab6
Author: Sandeep Patil <patil_sandeep@projectara.com>
Date:   Thu May 19 08:52:39 2016 -0700

    greybus: gpbridge: rename 'gpbridge' to 'gbphy' everywhere
    
    The 'gpbridge' name didn't relaly reflect what the bus is; which
    is a bus for bridged-phy devices. So, rename all instances
    of 'gpbridge' to more appropriate 'gbphy'
    
    Testing Done:
    Build and boot tested. 'lsgb' will stop displaying 'GPBridge' devices
    until I change the library to reflect this change.
    
    Signed-off-by: Sandeep Patil <patil_sandeep@projectara.com>
    Suggested-by: Greg Kroah-Hartman <gregkh@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/spi.c b/drivers/staging/greybus/spi.c
index 1cf5f509363c..4f13efeeb91e 100644
--- a/drivers/staging/greybus/spi.c
+++ b/drivers/staging/greybus/spi.c
@@ -10,17 +10,17 @@
 #include <linux/module.h>
 
 #include "greybus.h"
-#include "gpbridge.h"
+#include "gbphy.h"
 #include "spilib.h"
 
-static int gb_spi_probe(struct gpbridge_device *gpbdev,
-			const struct gpbridge_device_id *id)
+static int gb_spi_probe(struct gbphy_device *gbphy_dev,
+			const struct gbphy_device_id *id)
 {
 	struct gb_connection *connection;
 	int ret;
 
-	connection = gb_connection_create(gpbdev->bundle,
-					  le16_to_cpu(gpbdev->cport_desc->id),
+	connection = gb_connection_create(gbphy_dev->bundle,
+					  le16_to_cpu(gbphy_dev->cport_desc->id),
 					  NULL);
 	if (IS_ERR(connection))
 		return PTR_ERR(connection);
@@ -29,15 +29,15 @@ static int gb_spi_probe(struct gpbridge_device *gpbdev,
 	if (ret)
 		goto exit_connection_destroy;
 
-	ret = gb_gpbridge_get_version(connection);
+	ret = gb_gbphy_get_version(connection);
 	if (ret)
 		goto exit_connection_disable;
 
-	ret = gb_spilib_master_init(connection, &gpbdev->dev);
+	ret = gb_spilib_master_init(connection, &gbphy_dev->dev);
 	if (ret)
 		goto exit_connection_disable;
 
-	gb_gpbridge_set_data(gpbdev, connection);
+	gb_gbphy_set_data(gbphy_dev, connection);
 
 	return 0;
 
@@ -49,27 +49,27 @@ static int gb_spi_probe(struct gpbridge_device *gpbdev,
 	return ret;
 }
 
-static void gb_spi_remove(struct gpbridge_device *gpbdev)
+static void gb_spi_remove(struct gbphy_device *gbphy_dev)
 {
-	struct gb_connection *connection = gb_gpbridge_get_data(gpbdev);
+	struct gb_connection *connection = gb_gbphy_get_data(gbphy_dev);
 
 	gb_spilib_master_exit(connection);
 	gb_connection_disable(connection);
 	gb_connection_destroy(connection);
 }
 
-static const struct gpbridge_device_id gb_spi_id_table[] = {
-	{ GPBRIDGE_PROTOCOL(GREYBUS_PROTOCOL_SPI) },
+static const struct gbphy_device_id gb_spi_id_table[] = {
+	{ GBPHY_PROTOCOL(GREYBUS_PROTOCOL_SPI) },
 	{ },
 };
-MODULE_DEVICE_TABLE(gpbridge, gb_spi_id_table);
+MODULE_DEVICE_TABLE(gbphy, gb_spi_id_table);
 
-static struct gpbridge_driver spi_driver = {
+static struct gbphy_driver spi_driver = {
 	.name		= "spi",
 	.probe		= gb_spi_probe,
 	.remove		= gb_spi_remove,
 	.id_table	= gb_spi_id_table,
 };
 
-module_gpbridge_driver(spi_driver);
+module_gbphy_driver(spi_driver);
 MODULE_LICENSE("GPL v2");

commit 8888b963743be7aad2a98bc165fb51150db5fd9f
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Sat May 14 23:42:20 2016 +0530

    greybus: spi: Separate out spilib from spi bridged PHY bundle driver
    
    spilib can be used by multiple bridge drivers implementing different
    bundle classes. Separate out bridged PHY bundle drivers parts.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Reviewed-by: Rui Miguel Silva <rui.silva@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/spi.c b/drivers/staging/greybus/spi.c
new file mode 100644
index 000000000000..1cf5f509363c
--- /dev/null
+++ b/drivers/staging/greybus/spi.c
@@ -0,0 +1,75 @@
+/*
+ * SPI bridge PHY driver.
+ *
+ * Copyright 2014-2016 Google Inc.
+ * Copyright 2014-2016 Linaro Ltd.
+ *
+ * Released under the GPLv2 only.
+ */
+
+#include <linux/module.h>
+
+#include "greybus.h"
+#include "gpbridge.h"
+#include "spilib.h"
+
+static int gb_spi_probe(struct gpbridge_device *gpbdev,
+			const struct gpbridge_device_id *id)
+{
+	struct gb_connection *connection;
+	int ret;
+
+	connection = gb_connection_create(gpbdev->bundle,
+					  le16_to_cpu(gpbdev->cport_desc->id),
+					  NULL);
+	if (IS_ERR(connection))
+		return PTR_ERR(connection);
+
+	ret = gb_connection_enable(connection);
+	if (ret)
+		goto exit_connection_destroy;
+
+	ret = gb_gpbridge_get_version(connection);
+	if (ret)
+		goto exit_connection_disable;
+
+	ret = gb_spilib_master_init(connection, &gpbdev->dev);
+	if (ret)
+		goto exit_connection_disable;
+
+	gb_gpbridge_set_data(gpbdev, connection);
+
+	return 0;
+
+exit_connection_disable:
+	gb_connection_disable(connection);
+exit_connection_destroy:
+	gb_connection_destroy(connection);
+
+	return ret;
+}
+
+static void gb_spi_remove(struct gpbridge_device *gpbdev)
+{
+	struct gb_connection *connection = gb_gpbridge_get_data(gpbdev);
+
+	gb_spilib_master_exit(connection);
+	gb_connection_disable(connection);
+	gb_connection_destroy(connection);
+}
+
+static const struct gpbridge_device_id gb_spi_id_table[] = {
+	{ GPBRIDGE_PROTOCOL(GREYBUS_PROTOCOL_SPI) },
+	{ },
+};
+MODULE_DEVICE_TABLE(gpbridge, gb_spi_id_table);
+
+static struct gpbridge_driver spi_driver = {
+	.name		= "spi",
+	.probe		= gb_spi_probe,
+	.remove		= gb_spi_remove,
+	.id_table	= gb_spi_id_table,
+};
+
+module_gpbridge_driver(spi_driver);
+MODULE_LICENSE("GPL v2");

commit 4c412921c78732f8f803a5906c97746ede5cf77c
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Sat May 14 23:42:19 2016 +0530

    greybus: spi: Restructure spi.c to share it with other bundle drivers
    
    This patch restructures spi.c as spilib core, so that the same logic can
    be reused for SPI connections implemented as part of different bundle
    types. This is required for Firmware Management Bundle.
    
    Note that the 'struct gb_protocol' and its callback aren't moved to
    a separate file in this commit to make its reviews easier. That will be
    done by a following patch.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Reviewed-by: Rui Miguel Silva <rui.silva@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/spi.c b/drivers/staging/greybus/spi.c
deleted file mode 100644
index 6cf18d179a75..000000000000
--- a/drivers/staging/greybus/spi.c
+++ /dev/null
@@ -1,563 +0,0 @@
-/*
- * SPI bridge driver for the Greybus "generic" SPI module.
- *
- * Copyright 2014-2015 Google Inc.
- * Copyright 2014-2015 Linaro Ltd.
- *
- * Released under the GPLv2 only.
- */
-
-#include <linux/bitops.h>
-#include <linux/kernel.h>
-#include <linux/module.h>
-#include <linux/slab.h>
-#include <linux/spi/spi.h>
-
-#include "greybus.h"
-#include "gpbridge.h"
-
-struct gb_spi {
-	struct gb_connection	*connection;
-	struct gpbridge_device	*gpbdev;
-	struct spi_transfer	*first_xfer;
-	struct spi_transfer	*last_xfer;
-	u32			rx_xfer_offset;
-	u32			tx_xfer_offset;
-	u32			last_xfer_size;
-	unsigned int		op_timeout;
-	u16			mode;
-	u16			flags;
-	u32			bits_per_word_mask;
-	u8			num_chipselect;
-	u32			min_speed_hz;
-	u32			max_speed_hz;
-};
-
-#define GB_SPI_STATE_MSG_DONE		((void *)0)
-#define GB_SPI_STATE_MSG_IDLE		((void *)1)
-#define GB_SPI_STATE_MSG_RUNNING	((void *)2)
-#define GB_SPI_STATE_OP_READY		((void *)3)
-#define GB_SPI_STATE_OP_DONE		((void *)4)
-#define GB_SPI_STATE_MSG_ERROR		((void *)-1)
-
-#define XFER_TIMEOUT_TOLERANCE		200
-
-static struct spi_master *get_master_from_spi(struct gb_spi *spi)
-{
-	return gb_connection_get_data(spi->connection);
-}
-
-static int tx_header_fit_operation(u32 tx_size, u32 count, size_t data_max)
-{
-	size_t headers_size;
-
-	data_max -= sizeof(struct gb_spi_transfer_request);
-	headers_size = (count + 1) * sizeof(struct gb_spi_transfer);
-
-	return tx_size + headers_size > data_max ? 0 : 1;
-}
-
-static size_t calc_rx_xfer_size(u32 rx_size, u32 *tx_xfer_size, u32 len,
-				size_t data_max)
-{
-	size_t rx_xfer_size;
-
-	data_max -= sizeof(struct gb_spi_transfer_response);
-
-	if (rx_size + len > data_max)
-		rx_xfer_size = data_max - rx_size;
-	else
-		rx_xfer_size = len;
-
-	/* if this is a write_read, for symmetry read the same as write */
-	if (*tx_xfer_size && rx_xfer_size > *tx_xfer_size)
-		rx_xfer_size = *tx_xfer_size;
-	if (*tx_xfer_size && rx_xfer_size < *tx_xfer_size)
-		*tx_xfer_size = rx_xfer_size;
-
-	return rx_xfer_size;
-}
-
-static size_t calc_tx_xfer_size(u32 tx_size, u32 count, size_t len,
-				size_t data_max)
-{
-	size_t headers_size;
-
-	data_max -= sizeof(struct gb_spi_transfer_request);
-	headers_size = (count + 1) * sizeof(struct gb_spi_transfer);
-
-	if (tx_size + headers_size + len > data_max)
-		return data_max - (tx_size + sizeof(struct gb_spi_transfer));
-
-	return len;
-}
-
-static void clean_xfer_state(struct gb_spi *spi)
-{
-	spi->first_xfer = NULL;
-	spi->last_xfer = NULL;
-	spi->rx_xfer_offset = 0;
-	spi->tx_xfer_offset = 0;
-	spi->last_xfer_size = 0;
-	spi->op_timeout = 0;
-}
-
-static int setup_next_xfer(struct gb_spi *spi, struct spi_message *msg)
-{
-	struct spi_transfer *last_xfer = spi->last_xfer;
-
-	if (msg->state != GB_SPI_STATE_OP_DONE)
-		return 0;
-
-	/*
-	 * if we transferred all content of the last transfer, reset values and
-	 * check if this was the last transfer in the message
-	 */
-	if ((spi->tx_xfer_offset + spi->last_xfer_size == last_xfer->len) ||
-	    (spi->rx_xfer_offset + spi->last_xfer_size == last_xfer->len)) {
-		spi->tx_xfer_offset = 0;
-		spi->rx_xfer_offset = 0;
-		spi->op_timeout = 0;
-		if (last_xfer == list_last_entry(&msg->transfers,
-						 struct spi_transfer,
-						 transfer_list))
-			msg->state = GB_SPI_STATE_MSG_DONE;
-		else
-			spi->first_xfer = list_next_entry(last_xfer,
-							  transfer_list);
-		return 0;
-	}
-
-	spi->first_xfer = last_xfer;
-	if (last_xfer->tx_buf)
-		spi->tx_xfer_offset += spi->last_xfer_size;
-
-	if (last_xfer->rx_buf)
-		spi->rx_xfer_offset += spi->last_xfer_size;
-
-	return 0;
-}
-
-static struct spi_transfer *get_next_xfer(struct spi_transfer *xfer,
-					  struct spi_message *msg)
-{
-	if (xfer == list_last_entry(&msg->transfers, struct spi_transfer,
-				    transfer_list))
-		return NULL;
-
-	return list_next_entry(xfer, transfer_list);
-}
-
-/* Routines to transfer data */
-static struct gb_operation *
-gb_spi_operation_create(struct gb_spi *spi, struct gb_connection *connection,
-			struct spi_message *msg)
-{
-	struct gb_spi_transfer_request *request;
-	struct spi_device *dev = msg->spi;
-	struct spi_transfer *xfer;
-	struct gb_spi_transfer *gb_xfer;
-	struct gb_operation *operation;
-	u32 tx_size = 0, rx_size = 0, count = 0, xfer_len = 0, request_size;
-	u32 tx_xfer_size = 0, rx_xfer_size = 0, len;
-	u32 total_len = 0;
-	unsigned int xfer_timeout;
-	size_t data_max;
-	void *tx_data;
-
-	data_max = gb_operation_get_payload_size_max(connection);
-	xfer = spi->first_xfer;
-
-	/* Find number of transfers queued and tx/rx length in the message */
-
-	while (msg->state != GB_SPI_STATE_OP_READY) {
-		msg->state = GB_SPI_STATE_MSG_RUNNING;
-		spi->last_xfer = xfer;
-
-		if (!xfer->tx_buf && !xfer->rx_buf) {
-			dev_err(&spi->gpbdev->dev,
-				"bufferless transfer, length %u\n", xfer->len);
-			msg->state = GB_SPI_STATE_MSG_ERROR;
-			return NULL;
-		}
-
-		tx_xfer_size = 0;
-		rx_xfer_size = 0;
-
-		if (xfer->tx_buf) {
-			len = xfer->len - spi->tx_xfer_offset;
-			if (!tx_header_fit_operation(tx_size, count, data_max))
-				break;
-			tx_xfer_size = calc_tx_xfer_size(tx_size, count,
-							 len, data_max);
-			spi->last_xfer_size = tx_xfer_size;
-		}
-
-		if (xfer->rx_buf) {
-			len = xfer->len - spi->rx_xfer_offset;
-			rx_xfer_size = calc_rx_xfer_size(rx_size, &tx_xfer_size,
-							 len, data_max);
-			spi->last_xfer_size = rx_xfer_size;
-		}
-
-		tx_size += tx_xfer_size;
-		rx_size += rx_xfer_size;
-
-		total_len += spi->last_xfer_size;
-		count++;
-
-		xfer = get_next_xfer(xfer, msg);
-		if (!xfer || total_len >= data_max)
-			msg->state = GB_SPI_STATE_OP_READY;
-	}
-
-	/*
-	 * In addition to space for all message descriptors we need
-	 * to have enough to hold all tx data.
-	 */
-	request_size = sizeof(*request);
-	request_size += count * sizeof(*gb_xfer);
-	request_size += tx_size;
-
-	/* Response consists only of incoming data */
-	operation = gb_operation_create(connection, GB_SPI_TYPE_TRANSFER,
-					request_size, rx_size, GFP_KERNEL);
-	if (!operation)
-		return NULL;
-
-	request = operation->request->payload;
-	request->count = cpu_to_le16(count);
-	request->mode = dev->mode;
-	request->chip_select = dev->chip_select;
-
-	gb_xfer = &request->transfers[0];
-	tx_data = gb_xfer + count;	/* place tx data after last gb_xfer */
-
-	/* Fill in the transfers array */
-	xfer = spi->first_xfer;
-	while (msg->state != GB_SPI_STATE_OP_DONE) {
-		if (xfer == spi->last_xfer)
-			xfer_len = spi->last_xfer_size;
-		else
-			xfer_len = xfer->len;
-
-		/* make sure we do not timeout in a slow transfer */
-		xfer_timeout = xfer_len * 8 * MSEC_PER_SEC / xfer->speed_hz;
-		xfer_timeout += GB_OPERATION_TIMEOUT_DEFAULT;
-
-		if (xfer_timeout > spi->op_timeout)
-			spi->op_timeout = xfer_timeout;
-
-		gb_xfer->speed_hz = cpu_to_le32(xfer->speed_hz);
-		gb_xfer->len = cpu_to_le32(xfer_len);
-		gb_xfer->delay_usecs = cpu_to_le16(xfer->delay_usecs);
-		gb_xfer->cs_change = xfer->cs_change;
-		gb_xfer->bits_per_word = xfer->bits_per_word;
-
-		/* Copy tx data */
-		if (xfer->tx_buf) {
-			gb_xfer->rdwr |= GB_SPI_XFER_WRITE;
-			memcpy(tx_data, xfer->tx_buf + spi->tx_xfer_offset,
-			       xfer_len);
-			tx_data += xfer_len;
-		}
-
-		if (xfer->rx_buf)
-			gb_xfer->rdwr |= GB_SPI_XFER_READ;
-
-		if (xfer == spi->last_xfer) {
-			msg->state = GB_SPI_STATE_OP_DONE;
-			continue;
-		}
-
-		gb_xfer++;
-		xfer = get_next_xfer(xfer, msg);
-	}
-
-	msg->actual_length += total_len;
-
-	return operation;
-}
-
-static void gb_spi_decode_response(struct gb_spi *spi, struct spi_message *msg,
-				   struct gb_spi_transfer_response *response)
-{
-	struct spi_transfer *xfer = spi->first_xfer;
-	void *rx_data = response->data;
-	u32 xfer_len;
-
-	while (xfer) {
-		/* Copy rx data */
-		if (xfer->rx_buf) {
-			if (xfer == spi->first_xfer)
-				xfer_len = xfer->len - spi->rx_xfer_offset;
-			else if (xfer == spi->last_xfer)
-				xfer_len = spi->last_xfer_size;
-			else
-				xfer_len = xfer->len;
-
-			memcpy(xfer->rx_buf + spi->rx_xfer_offset, rx_data,
-			       xfer_len);
-			rx_data += xfer_len;
-		}
-
-		if (xfer == spi->last_xfer)
-			break;
-
-		xfer = list_next_entry(xfer, transfer_list);
-	}
-}
-
-static int gb_spi_transfer_one_message(struct spi_master *master,
-				       struct spi_message *msg)
-{
-	struct gb_spi *spi = spi_master_get_devdata(master);
-	struct gb_connection *connection = spi->connection;
-	struct gb_spi_transfer_response *response;
-	struct gb_operation *operation;
-	int ret = 0;
-
-	spi->first_xfer = list_first_entry_or_null(&msg->transfers,
-						   struct spi_transfer,
-						   transfer_list);
-	if (!spi->first_xfer) {
-		ret = -ENOMEM;
-		goto out;
-	}
-
-	msg->state = GB_SPI_STATE_MSG_IDLE;
-
-	while (msg->state != GB_SPI_STATE_MSG_DONE &&
-	       msg->state != GB_SPI_STATE_MSG_ERROR) {
-		operation = gb_spi_operation_create(spi, connection, msg);
-		if (!operation) {
-			msg->state = GB_SPI_STATE_MSG_ERROR;
-			ret = -EINVAL;
-			continue;
-		}
-
-		ret = gb_operation_request_send_sync_timeout(operation,
-							     spi->op_timeout);
-		if (!ret) {
-			response = operation->response->payload;
-			if (response)
-				gb_spi_decode_response(spi, msg, response);
-		} else {
-			dev_err(&spi->gpbdev->dev,
-				"transfer operation failed: %d\n", ret);
-			msg->state = GB_SPI_STATE_MSG_ERROR;
-		}
-
-		gb_operation_put(operation);
-		setup_next_xfer(spi, msg);
-	}
-
-out:
-	msg->status = ret;
-	clean_xfer_state(spi);
-	spi_finalize_current_message(master);
-
-	return ret;
-}
-
-static int gb_spi_setup(struct spi_device *spi)
-{
-	/* Nothing to do for now */
-	return 0;
-}
-
-static void gb_spi_cleanup(struct spi_device *spi)
-{
-	/* Nothing to do for now */
-}
-
-
-/* Routines to get controller information */
-
-/*
- * Map Greybus spi mode bits/flags/bpw into Linux ones.
- * All bits are same for now and so these macro's return same values.
- */
-#define gb_spi_mode_map(mode) mode
-#define gb_spi_flags_map(flags) flags
-
-static int gb_spi_get_master_config(struct gb_spi *spi)
-{
-	struct gb_spi_master_config_response response;
-	u16 mode, flags;
-	int ret;
-
-	ret = gb_operation_sync(spi->connection, GB_SPI_TYPE_MASTER_CONFIG,
-				NULL, 0, &response, sizeof(response));
-	if (ret < 0)
-		return ret;
-
-	mode = le16_to_cpu(response.mode);
-	spi->mode = gb_spi_mode_map(mode);
-
-	flags = le16_to_cpu(response.flags);
-	spi->flags = gb_spi_flags_map(flags);
-
-	spi->bits_per_word_mask = le32_to_cpu(response.bits_per_word_mask);
-	spi->num_chipselect = response.num_chipselect;
-
-	spi->min_speed_hz = le32_to_cpu(response.min_speed_hz);
-	spi->max_speed_hz = le32_to_cpu(response.max_speed_hz);
-
-	return 0;
-}
-
-static int gb_spi_setup_device(struct gb_spi *spi, u8 cs)
-{
-	struct spi_master *master = get_master_from_spi(spi);
-	struct gb_spi_device_config_request request;
-	struct gb_spi_device_config_response response;
-	struct spi_board_info spi_board = { {0} };
-	struct spi_device *spidev;
-	int ret;
-	u8 dev_type;
-
-	request.chip_select = cs;
-
-	ret = gb_operation_sync(spi->connection, GB_SPI_TYPE_DEVICE_CONFIG,
-				&request, sizeof(request),
-				&response, sizeof(response));
-	if (ret < 0)
-		return ret;
-
-	dev_type = response.device_type;
-
-	if (dev_type == GB_SPI_SPI_DEV)
-		strlcpy(spi_board.modalias, SPI_DEV_MODALIAS,
-			sizeof(spi_board.modalias));
-	else if (dev_type == GB_SPI_SPI_NOR)
-		strlcpy(spi_board.modalias, SPI_NOR_MODALIAS,
-			sizeof(spi_board.modalias));
-	else if (dev_type == GB_SPI_SPI_MODALIAS)
-		memcpy(spi_board.modalias, response.name,
-		       sizeof(spi_board.modalias));
-	else
-		return -EINVAL;
-
-	spi_board.mode		= le16_to_cpu(response.mode);
-	spi_board.bus_num	= master->bus_num;
-	spi_board.chip_select	= cs;
-	spi_board.max_speed_hz	= le32_to_cpu(response.max_speed_hz);
-
-	spidev = spi_new_device(master, &spi_board);
-	if (!spidev)
-		return -EINVAL;
-
-	return 0;
-}
-
-static int gb_spi_probe(struct gpbridge_device *gpbdev,
-			const struct gpbridge_device_id *id)
-{
-	struct gb_connection *connection;
-	struct gb_spi *spi;
-	struct spi_master *master;
-	int ret;
-	u8 i;
-
-	/* Allocate master with space for data */
-	master = spi_alloc_master(&gpbdev->dev, sizeof(*spi));
-	if (!master) {
-		dev_err(&gpbdev->dev, "cannot alloc SPI master\n");
-		return -ENOMEM;
-	}
-
-	connection = gb_connection_create(gpbdev->bundle,
-					  le16_to_cpu(gpbdev->cport_desc->id),
-					  NULL);
-	if (IS_ERR(connection)) {
-		ret = PTR_ERR(connection);
-		goto exit_spi_put;
-	}
-
-	spi = spi_master_get_devdata(master);
-	spi->connection = connection;
-	gb_connection_set_data(connection, master);
-	spi->gpbdev = gpbdev;
-	gb_gpbridge_set_data(gpbdev, master);
-
-	ret = gb_connection_enable(connection);
-	if (ret)
-		goto exit_connection_destroy;
-
-	ret = gb_gpbridge_get_version(connection);
-	if (ret)
-		goto exit_connection_disable;
-
-	/* get master configuration */
-	ret = gb_spi_get_master_config(spi);
-	if (ret)
-		goto exit_connection_disable;
-
-	master->bus_num = -1; /* Allow spi-core to allocate it dynamically */
-	master->num_chipselect = spi->num_chipselect;
-	master->mode_bits = spi->mode;
-	master->flags = spi->flags;
-	master->bits_per_word_mask = spi->bits_per_word_mask;
-
-	/* Attach methods */
-	master->cleanup = gb_spi_cleanup;
-	master->setup = gb_spi_setup;
-	master->transfer_one_message = gb_spi_transfer_one_message;
-
-	ret = spi_register_master(master);
-	if (ret < 0)
-		goto exit_connection_disable;
-
-	/* now, fetch the devices configuration */
-	for (i = 0; i < spi->num_chipselect; i++) {
-		ret = gb_spi_setup_device(spi, i);
-		if (ret < 0) {
-			dev_err(&gpbdev->dev,
-				"failed to allocate spi device %d: %d\n",
-				i, ret);
-			goto exit_spi_unregister;
-		}
-	}
-
-	return ret;
-
-exit_spi_unregister:
-	spi_unregister_master(master);
-exit_connection_disable:
-	gb_connection_disable(connection);
-exit_connection_destroy:
-	gb_connection_destroy(connection);
-exit_spi_put:
-	spi_master_put(master);
-
-	return ret;
-}
-
-static void gb_spi_remove(struct gpbridge_device *gpbdev)
-{
-	struct spi_master *master = gb_gpbridge_get_data(gpbdev);
-	struct gb_spi *spi = spi_master_get_devdata(master);
-	struct gb_connection *connection = spi->connection;
-
-	spi_unregister_master(master);
-	gb_connection_disable(connection);
-	gb_connection_destroy(connection);
-	spi_master_put(master);
-}
-
-static const struct gpbridge_device_id gb_spi_id_table[] = {
-	{ GPBRIDGE_PROTOCOL(GREYBUS_PROTOCOL_SPI) },
-	{ },
-};
-MODULE_DEVICE_TABLE(gpbridge, gb_spi_id_table);
-
-static struct gpbridge_driver spi_driver = {
-	.name		= "spi",
-	.probe		= gb_spi_probe,
-	.remove		= gb_spi_remove,
-	.id_table	= gb_spi_id_table,
-};
-
-module_gpbridge_driver(spi_driver);
-MODULE_LICENSE("GPL v2");

commit bebc013bafed3cc42eada99da0a924e46b0cd0c3
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Mon May 9 18:15:10 2016 +0530

    greybus: spi: Create separate module
    
    Create separate module for spi gpbridge driver.
    
    Tested on EVT 1.5 by inserting GP test module, all the devices were
    enumerated correctly.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/spi.c b/drivers/staging/greybus/spi.c
index dc811b142432..6cf18d179a75 100644
--- a/drivers/staging/greybus/spi.c
+++ b/drivers/staging/greybus/spi.c
@@ -550,6 +550,7 @@ static const struct gpbridge_device_id gb_spi_id_table[] = {
 	{ GPBRIDGE_PROTOCOL(GREYBUS_PROTOCOL_SPI) },
 	{ },
 };
+MODULE_DEVICE_TABLE(gpbridge, gb_spi_id_table);
 
 static struct gpbridge_driver spi_driver = {
 	.name		= "spi",
@@ -557,4 +558,6 @@ static struct gpbridge_driver spi_driver = {
 	.remove		= gb_spi_remove,
 	.id_table	= gb_spi_id_table,
 };
-gb_gpbridge_builtin_driver(spi_driver);
+
+module_gpbridge_driver(spi_driver);
+MODULE_LICENSE("GPL v2");

commit ba3e67001b42626dec862410310d30db586074d5
Author: Greg Kroah-Hartman <gregkh@google.com>
Date:   Thu May 5 14:32:35 2016 +0530

    greybus: SPI: convert to a gpbridge driver
    
    This converts the SPI driver to be a gpbridge driver, moving it away
    from the "legacy" interface.
    
    Testing Done: Tested on gbsim.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>
    Signed-off-by: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
    [vaibhav.hiremath@linaro.org: 1.Changed code to retain init/exit fns of
    drivers. 2.Exit path fix. 3. Fixed review comments]
    Reviewed-by: Viresh Kumar <viresh.kumar@linaro.org>
    Tested-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/spi.c b/drivers/staging/greybus/spi.c
index ce706ed218e2..dc811b142432 100644
--- a/drivers/staging/greybus/spi.c
+++ b/drivers/staging/greybus/spi.c
@@ -18,6 +18,7 @@
 
 struct gb_spi {
 	struct gb_connection	*connection;
+	struct gpbridge_device	*gpbdev;
 	struct spi_transfer	*first_xfer;
 	struct spi_transfer	*last_xfer;
 	u32			rx_xfer_offset;
@@ -174,7 +175,7 @@ gb_spi_operation_create(struct gb_spi *spi, struct gb_connection *connection,
 		spi->last_xfer = xfer;
 
 		if (!xfer->tx_buf && !xfer->rx_buf) {
-			dev_err(&connection->bundle->dev,
+			dev_err(&spi->gpbdev->dev,
 				"bufferless transfer, length %u\n", xfer->len);
 			msg->state = GB_SPI_STATE_MSG_ERROR;
 			return NULL;
@@ -342,7 +343,7 @@ static int gb_spi_transfer_one_message(struct spi_master *master,
 			if (response)
 				gb_spi_decode_response(spi, msg, response);
 		} else {
-			dev_err(&connection->bundle->dev,
+			dev_err(&spi->gpbdev->dev,
 				"transfer operation failed: %d\n", ret);
 			msg->state = GB_SPI_STATE_MSG_ERROR;
 		}
@@ -450,28 +451,48 @@ static int gb_spi_setup_device(struct gb_spi *spi, u8 cs)
 	return 0;
 }
 
-static int gb_spi_connection_init(struct gb_connection *connection)
+static int gb_spi_probe(struct gpbridge_device *gpbdev,
+			const struct gpbridge_device_id *id)
 {
+	struct gb_connection *connection;
 	struct gb_spi *spi;
 	struct spi_master *master;
 	int ret;
 	u8 i;
 
 	/* Allocate master with space for data */
-	master = spi_alloc_master(&connection->bundle->dev, sizeof(*spi));
+	master = spi_alloc_master(&gpbdev->dev, sizeof(*spi));
 	if (!master) {
-		dev_err(&connection->bundle->dev, "cannot alloc SPI master\n");
+		dev_err(&gpbdev->dev, "cannot alloc SPI master\n");
 		return -ENOMEM;
 	}
 
+	connection = gb_connection_create(gpbdev->bundle,
+					  le16_to_cpu(gpbdev->cport_desc->id),
+					  NULL);
+	if (IS_ERR(connection)) {
+		ret = PTR_ERR(connection);
+		goto exit_spi_put;
+	}
+
 	spi = spi_master_get_devdata(master);
 	spi->connection = connection;
 	gb_connection_set_data(connection, master);
+	spi->gpbdev = gpbdev;
+	gb_gpbridge_set_data(gpbdev, master);
+
+	ret = gb_connection_enable(connection);
+	if (ret)
+		goto exit_connection_destroy;
+
+	ret = gb_gpbridge_get_version(connection);
+	if (ret)
+		goto exit_connection_disable;
 
 	/* get master configuration */
 	ret = gb_spi_get_master_config(spi);
 	if (ret)
-		goto out_put_master;
+		goto exit_connection_disable;
 
 	master->bus_num = -1; /* Allow spi-core to allocate it dynamically */
 	master->num_chipselect = spi->num_chipselect;
@@ -486,42 +507,54 @@ static int gb_spi_connection_init(struct gb_connection *connection)
 
 	ret = spi_register_master(master);
 	if (ret < 0)
-		goto out_put_master;
+		goto exit_connection_disable;
 
 	/* now, fetch the devices configuration */
 	for (i = 0; i < spi->num_chipselect; i++) {
 		ret = gb_spi_setup_device(spi, i);
 		if (ret < 0) {
-			dev_err(&connection->bundle->dev,
-				"failed to allocated spi device: %d\n", ret);
-			spi_unregister_master(master);
-			break;
+			dev_err(&gpbdev->dev,
+				"failed to allocate spi device %d: %d\n",
+				i, ret);
+			goto exit_spi_unregister;
 		}
 	}
 
 	return ret;
 
-out_put_master:
+exit_spi_unregister:
+	spi_unregister_master(master);
+exit_connection_disable:
+	gb_connection_disable(connection);
+exit_connection_destroy:
+	gb_connection_destroy(connection);
+exit_spi_put:
 	spi_master_put(master);
 
 	return ret;
 }
 
-static void gb_spi_connection_exit(struct gb_connection *connection)
+static void gb_spi_remove(struct gpbridge_device *gpbdev)
 {
-	struct spi_master *master = gb_connection_get_data(connection);
+	struct spi_master *master = gb_gpbridge_get_data(gpbdev);
+	struct gb_spi *spi = spi_master_get_devdata(master);
+	struct gb_connection *connection = spi->connection;
 
 	spi_unregister_master(master);
+	gb_connection_disable(connection);
+	gb_connection_destroy(connection);
+	spi_master_put(master);
 }
 
-static struct gb_protocol spi_protocol = {
-	.name			= "spi",
-	.id			= GREYBUS_PROTOCOL_SPI,
-	.major			= GB_SPI_VERSION_MAJOR,
-	.minor			= GB_SPI_VERSION_MINOR,
-	.connection_init	= gb_spi_connection_init,
-	.connection_exit	= gb_spi_connection_exit,
-	.request_recv		= NULL,
+static const struct gpbridge_device_id gb_spi_id_table[] = {
+	{ GPBRIDGE_PROTOCOL(GREYBUS_PROTOCOL_SPI) },
+	{ },
 };
 
-gb_builtin_protocol_driver(spi_protocol);
+static struct gpbridge_driver spi_driver = {
+	.name		= "spi",
+	.probe		= gb_spi_probe,
+	.remove		= gb_spi_remove,
+	.id_table	= gb_spi_id_table,
+};
+gb_gpbridge_builtin_driver(spi_driver);

commit d1d67714a4ece3c1438c9d7def324ee0424e7cbd
Author: Rui Miguel Silva <rui.silva@linaro.org>
Date:   Wed Apr 20 14:40:23 2016 +0100

    greybus: spi: use timeout request send operation
    
    When transfer speed is too slow (less than 17Khz) the operation can take
    longer than the default greybus timeout. Because of this we need to use
    the request_send_sync_timeout and calculate the correct timeout for each
    operation.
    
    Signed-off-by: Rui Miguel Silva <rui.silva@linaro.org>
    Tested-by: Philip Yang <philipy@bsquare.com>
    Tested-by: Axel Haslam <ahaslam@baylibre.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/spi.c b/drivers/staging/greybus/spi.c
index 0bae7f12ccf1..ce706ed218e2 100644
--- a/drivers/staging/greybus/spi.c
+++ b/drivers/staging/greybus/spi.c
@@ -23,6 +23,7 @@ struct gb_spi {
 	u32			rx_xfer_offset;
 	u32			tx_xfer_offset;
 	u32			last_xfer_size;
+	unsigned int		op_timeout;
 	u16			mode;
 	u16			flags;
 	u32			bits_per_word_mask;
@@ -38,6 +39,8 @@ struct gb_spi {
 #define GB_SPI_STATE_OP_DONE		((void *)4)
 #define GB_SPI_STATE_MSG_ERROR		((void *)-1)
 
+#define XFER_TIMEOUT_TOLERANCE		200
+
 static struct spi_master *get_master_from_spi(struct gb_spi *spi)
 {
 	return gb_connection_get_data(spi->connection);
@@ -95,6 +98,7 @@ static void clean_xfer_state(struct gb_spi *spi)
 	spi->rx_xfer_offset = 0;
 	spi->tx_xfer_offset = 0;
 	spi->last_xfer_size = 0;
+	spi->op_timeout = 0;
 }
 
 static int setup_next_xfer(struct gb_spi *spi, struct spi_message *msg)
@@ -112,6 +116,7 @@ static int setup_next_xfer(struct gb_spi *spi, struct spi_message *msg)
 	    (spi->rx_xfer_offset + spi->last_xfer_size == last_xfer->len)) {
 		spi->tx_xfer_offset = 0;
 		spi->rx_xfer_offset = 0;
+		spi->op_timeout = 0;
 		if (last_xfer == list_last_entry(&msg->transfers,
 						 struct spi_transfer,
 						 transfer_list))
@@ -155,6 +160,7 @@ gb_spi_operation_create(struct gb_spi *spi, struct gb_connection *connection,
 	u32 tx_size = 0, rx_size = 0, count = 0, xfer_len = 0, request_size;
 	u32 tx_xfer_size = 0, rx_xfer_size = 0, len;
 	u32 total_len = 0;
+	unsigned int xfer_timeout;
 	size_t data_max;
 	void *tx_data;
 
@@ -234,6 +240,13 @@ gb_spi_operation_create(struct gb_spi *spi, struct gb_connection *connection,
 		else
 			xfer_len = xfer->len;
 
+		/* make sure we do not timeout in a slow transfer */
+		xfer_timeout = xfer_len * 8 * MSEC_PER_SEC / xfer->speed_hz;
+		xfer_timeout += GB_OPERATION_TIMEOUT_DEFAULT;
+
+		if (xfer_timeout > spi->op_timeout)
+			spi->op_timeout = xfer_timeout;
+
 		gb_xfer->speed_hz = cpu_to_le32(xfer->speed_hz);
 		gb_xfer->len = cpu_to_le32(xfer_len);
 		gb_xfer->delay_usecs = cpu_to_le16(xfer->delay_usecs);
@@ -322,7 +335,8 @@ static int gb_spi_transfer_one_message(struct spi_master *master,
 			continue;
 		}
 
-		ret = gb_operation_request_send_sync(operation);
+		ret = gb_operation_request_send_sync_timeout(operation,
+							     spi->op_timeout);
 		if (!ret) {
 			response = operation->response->payload;
 			if (response)

commit 0928b2e4401cebd7fd2b8aebc41be60dbe4c2ef3
Author: Rui Miguel Silva <rui.silva@linaro.org>
Date:   Wed Apr 20 14:40:22 2016 +0100

    greybus: spi: fix message transfer over greybus
    
    The actual implementation of transfer_one_message have problems with
    some cases in the possible transfer options. We try to maximize the
    number of spi transfers in one greybus operation and need to save state
    until the full message is dispatch over greybus.
    
    Signed-off-by: Rui Miguel Silva <rui.silva@linaro.org>
    Tested-by: Philip Yang <philipy@bsquare.com>
    Tested-by: Axel Haslam <ahaslam@baylibre.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/spi.c b/drivers/staging/greybus/spi.c
index 12e8cd8b1655..0bae7f12ccf1 100644
--- a/drivers/staging/greybus/spi.c
+++ b/drivers/staging/greybus/spi.c
@@ -18,6 +18,11 @@
 
 struct gb_spi {
 	struct gb_connection	*connection;
+	struct spi_transfer	*first_xfer;
+	struct spi_transfer	*last_xfer;
+	u32			rx_xfer_offset;
+	u32			tx_xfer_offset;
+	u32			last_xfer_size;
 	u16			mode;
 	u16			flags;
 	u32			bits_per_word_mask;
@@ -26,6 +31,13 @@ struct gb_spi {
 	u32			max_speed_hz;
 };
 
+#define GB_SPI_STATE_MSG_DONE		((void *)0)
+#define GB_SPI_STATE_MSG_IDLE		((void *)1)
+#define GB_SPI_STATE_MSG_RUNNING	((void *)2)
+#define GB_SPI_STATE_OP_READY		((void *)3)
+#define GB_SPI_STATE_OP_DONE		((void *)4)
+#define GB_SPI_STATE_MSG_ERROR		((void *)-1)
+
 static struct spi_master *get_master_from_spi(struct gb_spi *spi)
 {
 	return gb_connection_get_data(spi->connection);
@@ -76,58 +88,120 @@ static size_t calc_tx_xfer_size(u32 tx_size, u32 count, size_t len,
 	return len;
 }
 
+static void clean_xfer_state(struct gb_spi *spi)
+{
+	spi->first_xfer = NULL;
+	spi->last_xfer = NULL;
+	spi->rx_xfer_offset = 0;
+	spi->tx_xfer_offset = 0;
+	spi->last_xfer_size = 0;
+}
+
+static int setup_next_xfer(struct gb_spi *spi, struct spi_message *msg)
+{
+	struct spi_transfer *last_xfer = spi->last_xfer;
+
+	if (msg->state != GB_SPI_STATE_OP_DONE)
+		return 0;
+
+	/*
+	 * if we transferred all content of the last transfer, reset values and
+	 * check if this was the last transfer in the message
+	 */
+	if ((spi->tx_xfer_offset + spi->last_xfer_size == last_xfer->len) ||
+	    (spi->rx_xfer_offset + spi->last_xfer_size == last_xfer->len)) {
+		spi->tx_xfer_offset = 0;
+		spi->rx_xfer_offset = 0;
+		if (last_xfer == list_last_entry(&msg->transfers,
+						 struct spi_transfer,
+						 transfer_list))
+			msg->state = GB_SPI_STATE_MSG_DONE;
+		else
+			spi->first_xfer = list_next_entry(last_xfer,
+							  transfer_list);
+		return 0;
+	}
+
+	spi->first_xfer = last_xfer;
+	if (last_xfer->tx_buf)
+		spi->tx_xfer_offset += spi->last_xfer_size;
+
+	if (last_xfer->rx_buf)
+		spi->rx_xfer_offset += spi->last_xfer_size;
+
+	return 0;
+}
+
+static struct spi_transfer *get_next_xfer(struct spi_transfer *xfer,
+					  struct spi_message *msg)
+{
+	if (xfer == list_last_entry(&msg->transfers, struct spi_transfer,
+				    transfer_list))
+		return NULL;
+
+	return list_next_entry(xfer, transfer_list);
+}
+
 /* Routines to transfer data */
 static struct gb_operation *
-gb_spi_operation_create(struct gb_connection *connection,
-			struct spi_message *msg, u32 *total_len)
+gb_spi_operation_create(struct gb_spi *spi, struct gb_connection *connection,
+			struct spi_message *msg)
 {
 	struct gb_spi_transfer_request *request;
 	struct spi_device *dev = msg->spi;
 	struct spi_transfer *xfer;
 	struct gb_spi_transfer *gb_xfer;
 	struct gb_operation *operation;
-	struct spi_transfer *last_xfer = NULL;
 	u32 tx_size = 0, rx_size = 0, count = 0, xfer_len = 0, request_size;
-	u32 tx_xfer_size = 0, rx_xfer_size = 0, last_xfer_size = 0;
+	u32 tx_xfer_size = 0, rx_xfer_size = 0, len;
+	u32 total_len = 0;
 	size_t data_max;
 	void *tx_data;
 
 	data_max = gb_operation_get_payload_size_max(connection);
+	xfer = spi->first_xfer;
 
 	/* Find number of transfers queued and tx/rx length in the message */
-	list_for_each_entry(xfer, &msg->transfers, transfer_list) {
+
+	while (msg->state != GB_SPI_STATE_OP_READY) {
+		msg->state = GB_SPI_STATE_MSG_RUNNING;
+		spi->last_xfer = xfer;
+
 		if (!xfer->tx_buf && !xfer->rx_buf) {
 			dev_err(&connection->bundle->dev,
 				"bufferless transfer, length %u\n", xfer->len);
+			msg->state = GB_SPI_STATE_MSG_ERROR;
 			return NULL;
 		}
-		last_xfer = xfer;
 
 		tx_xfer_size = 0;
 		rx_xfer_size = 0;
 
 		if (xfer->tx_buf) {
+			len = xfer->len - spi->tx_xfer_offset;
 			if (!tx_header_fit_operation(tx_size, count, data_max))
 				break;
 			tx_xfer_size = calc_tx_xfer_size(tx_size, count,
-							 xfer->len, data_max);
-			last_xfer_size = tx_xfer_size;
+							 len, data_max);
+			spi->last_xfer_size = tx_xfer_size;
 		}
 
 		if (xfer->rx_buf) {
+			len = xfer->len - spi->rx_xfer_offset;
 			rx_xfer_size = calc_rx_xfer_size(rx_size, &tx_xfer_size,
-							 xfer->len, data_max);
-			last_xfer_size = rx_xfer_size;
+							 len, data_max);
+			spi->last_xfer_size = rx_xfer_size;
 		}
 
 		tx_size += tx_xfer_size;
 		rx_size += rx_xfer_size;
 
-		*total_len += last_xfer_size;
+		total_len += spi->last_xfer_size;
 		count++;
 
-		if (xfer->len != last_xfer_size)
-			break;
+		xfer = get_next_xfer(xfer, msg);
+		if (!xfer || total_len >= data_max)
+			msg->state = GB_SPI_STATE_OP_READY;
 	}
 
 	/*
@@ -153,9 +227,10 @@ gb_spi_operation_create(struct gb_connection *connection,
 	tx_data = gb_xfer + count;	/* place tx data after last gb_xfer */
 
 	/* Fill in the transfers array */
-	list_for_each_entry(xfer, &msg->transfers, transfer_list) {
-		if (last_xfer && xfer == last_xfer)
-			xfer_len = last_xfer_size;
+	xfer = spi->first_xfer;
+	while (msg->state != GB_SPI_STATE_OP_DONE) {
+		if (xfer == spi->last_xfer)
+			xfer_len = spi->last_xfer_size;
 		else
 			xfer_len = xfer->len;
 
@@ -168,34 +243,54 @@ gb_spi_operation_create(struct gb_connection *connection,
 		/* Copy tx data */
 		if (xfer->tx_buf) {
 			gb_xfer->rdwr |= GB_SPI_XFER_WRITE;
-			memcpy(tx_data, xfer->tx_buf, xfer_len);
+			memcpy(tx_data, xfer->tx_buf + spi->tx_xfer_offset,
+			       xfer_len);
 			tx_data += xfer_len;
 		}
 
 		if (xfer->rx_buf)
 			gb_xfer->rdwr |= GB_SPI_XFER_READ;
 
-		if (last_xfer && xfer == last_xfer)
-			break;
+		if (xfer == spi->last_xfer) {
+			msg->state = GB_SPI_STATE_OP_DONE;
+			continue;
+		}
 
 		gb_xfer++;
+		xfer = get_next_xfer(xfer, msg);
 	}
 
+	msg->actual_length += total_len;
+
 	return operation;
 }
 
-static void gb_spi_decode_response(struct spi_message *msg,
+static void gb_spi_decode_response(struct gb_spi *spi, struct spi_message *msg,
 				   struct gb_spi_transfer_response *response)
 {
-	struct spi_transfer *xfer;
+	struct spi_transfer *xfer = spi->first_xfer;
 	void *rx_data = response->data;
+	u32 xfer_len;
 
-	list_for_each_entry(xfer, &msg->transfers, transfer_list) {
+	while (xfer) {
 		/* Copy rx data */
 		if (xfer->rx_buf) {
-			memcpy(xfer->rx_buf, rx_data, xfer->len);
-			rx_data += xfer->len;
+			if (xfer == spi->first_xfer)
+				xfer_len = xfer->len - spi->rx_xfer_offset;
+			else if (xfer == spi->last_xfer)
+				xfer_len = spi->last_xfer_size;
+			else
+				xfer_len = xfer->len;
+
+			memcpy(xfer->rx_buf + spi->rx_xfer_offset, rx_data,
+			       xfer_len);
+			rx_data += xfer_len;
 		}
+
+		if (xfer == spi->last_xfer)
+			break;
+
+		xfer = list_next_entry(xfer, transfer_list);
 	}
 }
 
@@ -206,27 +301,45 @@ static int gb_spi_transfer_one_message(struct spi_master *master,
 	struct gb_connection *connection = spi->connection;
 	struct gb_spi_transfer_response *response;
 	struct gb_operation *operation;
-	u32 len = 0;
-	int ret;
+	int ret = 0;
+
+	spi->first_xfer = list_first_entry_or_null(&msg->transfers,
+						   struct spi_transfer,
+						   transfer_list);
+	if (!spi->first_xfer) {
+		ret = -ENOMEM;
+		goto out;
+	}
 
-	operation = gb_spi_operation_create(connection, msg, &len);
-	if (!operation)
-		return -ENOMEM;
+	msg->state = GB_SPI_STATE_MSG_IDLE;
+
+	while (msg->state != GB_SPI_STATE_MSG_DONE &&
+	       msg->state != GB_SPI_STATE_MSG_ERROR) {
+		operation = gb_spi_operation_create(spi, connection, msg);
+		if (!operation) {
+			msg->state = GB_SPI_STATE_MSG_ERROR;
+			ret = -EINVAL;
+			continue;
+		}
 
-	ret = gb_operation_request_send_sync(operation);
-	if (!ret) {
-		response = operation->response->payload;
-		if (response)
-			gb_spi_decode_response(msg, response);
-	} else {
-		dev_err(&connection->bundle->dev,
+		ret = gb_operation_request_send_sync(operation);
+		if (!ret) {
+			response = operation->response->payload;
+			if (response)
+				gb_spi_decode_response(spi, msg, response);
+		} else {
+			dev_err(&connection->bundle->dev,
 				"transfer operation failed: %d\n", ret);
-	}
+			msg->state = GB_SPI_STATE_MSG_ERROR;
+		}
 
-	gb_operation_put(operation);
+		gb_operation_put(operation);
+		setup_next_xfer(spi, msg);
+	}
 
-	msg->actual_length = len;
-	msg->status = 0;
+out:
+	msg->status = ret;
+	clean_xfer_state(spi);
 	spi_finalize_current_message(master);
 
 	return ret;

commit 0ec306324423444d3ee0222708ef9de7f5586b93
Author: Greg Kroah-Hartman <gregkh@google.com>
Date:   Tue Mar 22 14:30:35 2016 -0400

    greybus: convert drivers to use connection->private set/get
    
    This converts all drivers to use the gb_connection_get_data() and
    gb_connection_set_data() functions to make it a bit more explicit as to
    what is going on.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>
    Reviewed-by: Alex Elder <elder@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/spi.c b/drivers/staging/greybus/spi.c
index 35714533a1ac..12e8cd8b1655 100644
--- a/drivers/staging/greybus/spi.c
+++ b/drivers/staging/greybus/spi.c
@@ -28,7 +28,7 @@ struct gb_spi {
 
 static struct spi_master *get_master_from_spi(struct gb_spi *spi)
 {
-	return spi->connection->private;
+	return gb_connection_get_data(spi->connection);
 }
 
 static int tx_header_fit_operation(u32 tx_size, u32 count, size_t data_max)
@@ -339,7 +339,7 @@ static int gb_spi_connection_init(struct gb_connection *connection)
 
 	spi = spi_master_get_devdata(master);
 	spi->connection = connection;
-	connection->private = master;
+	gb_connection_set_data(connection, master);
 
 	/* get master configuration */
 	ret = gb_spi_get_master_config(spi);
@@ -382,7 +382,7 @@ static int gb_spi_connection_init(struct gb_connection *connection)
 
 static void gb_spi_connection_exit(struct gb_connection *connection)
 {
-	struct spi_master *master = connection->private;
+	struct spi_master *master = gb_connection_get_data(connection);
 
 	spi_unregister_master(master);
 }

commit c7b07265046b5db56778dc8c2cfc9056413ec5ba
Author: Greg Kroah-Hartman <gregkh@google.com>
Date:   Sun Feb 28 14:42:54 2016 -0800

    greybus: gpbridge.h: move protocol init/exit prototypes
    
    Create gpbridge.h for the gpbridge-specific function prototypes, the
    rest of the greybus drivers don't care about them.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>
    Reviewed-by: Viresh Kumar <viresh.kumar@linaro.org>
    Reviewed-by: Johan Hovold <johan@hovoldconsulting.com>

diff --git a/drivers/staging/greybus/spi.c b/drivers/staging/greybus/spi.c
index 7689af0f63a9..35714533a1ac 100644
--- a/drivers/staging/greybus/spi.c
+++ b/drivers/staging/greybus/spi.c
@@ -14,6 +14,7 @@
 #include <linux/spi/spi.h>
 
 #include "greybus.h"
+#include "gpbridge.h"
 
 struct gb_spi {
 	struct gb_connection	*connection;

commit 5ef545fb8c22ab605f764ea467859572797dbc09
Author: Johan Hovold <johan@hovoldconsulting.com>
Date:   Thu Feb 11 13:52:50 2016 +0100

    greybus: spi: add bundle-device prefix to error messages
    
    Replace all pr_err with dev_err so we can tell what device (and driver)
    a message was for.
    
    Testing Done: Compiled
    
    Signed-off-by: Johan Hovold <johan@hovoldconsulting.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/spi.c b/drivers/staging/greybus/spi.c
index c00492cc632e..7689af0f63a9 100644
--- a/drivers/staging/greybus/spi.c
+++ b/drivers/staging/greybus/spi.c
@@ -218,7 +218,8 @@ static int gb_spi_transfer_one_message(struct spi_master *master,
 		if (response)
 			gb_spi_decode_response(msg, response);
 	} else {
-		pr_err("transfer operation failed (%d)\n", ret);
+		dev_err(&connection->bundle->dev,
+				"transfer operation failed: %d\n", ret);
 	}
 
 	gb_operation_put(operation);

commit 0273038df61349868d368dd9254eb629425a3378
Author: Rui Miguel Silva <rui.silva@linaro.org>
Date:   Tue Feb 2 14:23:16 2016 +0000

    greybus: spi: add device_type field to device config
    
    Add device_type field in device config operation to get the type of
    device and try to expose less the kernel internal over greybus.
    This include the spidev, spi-nor will fetch the correct nor id over
    jede and a modalias that will have the previous behavior (name will set
    the driver to be loaded).
    
    As at it, fix a trivial error path and return immediately.
    
    Tested: using gbsim and confirming that a spidev and mtd device were
    created.
    
    Signed-off-by: Rui Miguel Silva <rui.silva@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/spi.c b/drivers/staging/greybus/spi.c
index ad4a1d62587d..c00492cc632e 100644
--- a/drivers/staging/greybus/spi.c
+++ b/drivers/staging/greybus/spi.c
@@ -285,6 +285,7 @@ static int gb_spi_setup_device(struct gb_spi *spi, u8 cs)
 	struct spi_board_info spi_board = { {0} };
 	struct spi_device *spidev;
 	int ret;
+	u8 dev_type;
 
 	request.chip_select = cs;
 
@@ -294,7 +295,20 @@ static int gb_spi_setup_device(struct gb_spi *spi, u8 cs)
 	if (ret < 0)
 		return ret;
 
-	memcpy(spi_board.modalias, response.name, sizeof(spi_board.modalias));
+	dev_type = response.device_type;
+
+	if (dev_type == GB_SPI_SPI_DEV)
+		strlcpy(spi_board.modalias, SPI_DEV_MODALIAS,
+			sizeof(spi_board.modalias));
+	else if (dev_type == GB_SPI_SPI_NOR)
+		strlcpy(spi_board.modalias, SPI_NOR_MODALIAS,
+			sizeof(spi_board.modalias));
+	else if (dev_type == GB_SPI_SPI_MODALIAS)
+		memcpy(spi_board.modalias, response.name,
+		       sizeof(spi_board.modalias));
+	else
+		return -EINVAL;
+
 	spi_board.mode		= le16_to_cpu(response.mode);
 	spi_board.bus_num	= master->bus_num;
 	spi_board.chip_select	= cs;
@@ -302,7 +316,7 @@ static int gb_spi_setup_device(struct gb_spi *spi, u8 cs)
 
 	spidev = spi_new_device(master, &spi_board);
 	if (!spidev)
-		ret = -EINVAL;
+		return -EINVAL;
 
 	return 0;
 }

commit 65fabd1848f2ddd00a1af5a1eaeb4f95dcb25b77
Author: Rui Miguel Silva <rui.silva@linaro.org>
Date:   Tue Dec 15 19:09:57 2015 +0000

    greybus: spi: fix and cleanup spi devices handling
    
    Cleanup and remove the spi_devices from the greybus spi handling as they
    are not needed and they were completely misused.
    
    With this the gb_spi_init does not make sense to exist anymore, so just
    remove it and handle the master config directly from connection init.
    
    Signed-off-by: Rui Miguel Silva <rui.silva@linaro.org>
    Reported-by: Johan Hovold <johan@hovoldconsulting.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/spi.c b/drivers/staging/greybus/spi.c
index e49dc56495b5..ad4a1d62587d 100644
--- a/drivers/staging/greybus/spi.c
+++ b/drivers/staging/greybus/spi.c
@@ -23,7 +23,6 @@ struct gb_spi {
 	u8			num_chipselect;
 	u32			min_speed_hz;
 	u32			max_speed_hz;
-	struct spi_device	*spi_devices;
 };
 
 static struct spi_master *get_master_from_spi(struct gb_spi *spi)
@@ -284,7 +283,7 @@ static int gb_spi_setup_device(struct gb_spi *spi, u8 cs)
 	struct gb_spi_device_config_request request;
 	struct gb_spi_device_config_response response;
 	struct spi_board_info spi_board = { {0} };
-	struct spi_device *spidev = &spi->spi_devices[cs];
+	struct spi_device *spidev;
 	int ret;
 
 	request.chip_select = cs;
@@ -308,24 +307,6 @@ static int gb_spi_setup_device(struct gb_spi *spi, u8 cs)
 	return 0;
 }
 
-static int gb_spi_init(struct gb_spi *spi)
-{
-	int ret;
-
-	/* get master configuration */
-	ret = gb_spi_get_master_config(spi);
-	if (ret)
-		return ret;
-
-	spi->spi_devices = kcalloc(spi->num_chipselect,
-				   sizeof(struct spi_device), GFP_KERNEL);
-	if (!spi->spi_devices)
-		return -ENOMEM;
-
-	return ret;
-}
-
-
 static int gb_spi_connection_init(struct gb_connection *connection)
 {
 	struct gb_spi *spi;
@@ -344,7 +325,8 @@ static int gb_spi_connection_init(struct gb_connection *connection)
 	spi->connection = connection;
 	connection->private = master;
 
-	ret = gb_spi_init(spi);
+	/* get master configuration */
+	ret = gb_spi_get_master_config(spi);
 	if (ret)
 		goto out_put_master;
 

commit 4a0c4453e3f99335db3e7786b1a66e3b6cfa0653
Author: Rui Miguel Silva <rui.silva@linaro.org>
Date:   Tue Dec 15 19:09:56 2015 +0000

    greybus: spi: unregister master on device add fail
    
    When registering devices if any of it fail, just cleanup and release spi
    master.
    
    Signed-off-by: Rui Miguel Silva <rui.silva@linaro.org>
    Reported-by: Johan Hovold <johan@hovoldconsulting.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/spi.c b/drivers/staging/greybus/spi.c
index 6e1146d474df..e49dc56495b5 100644
--- a/drivers/staging/greybus/spi.c
+++ b/drivers/staging/greybus/spi.c
@@ -366,8 +366,12 @@ static int gb_spi_connection_init(struct gb_connection *connection)
 	/* now, fetch the devices configuration */
 	for (i = 0; i < spi->num_chipselect; i++) {
 		ret = gb_spi_setup_device(spi, i);
-		if (ret < 0)
+		if (ret < 0) {
+			dev_err(&connection->bundle->dev,
+				"failed to allocated spi device: %d\n", ret);
+			spi_unregister_master(master);
 			break;
+		}
 	}
 
 	return ret;

commit a92a2d46acd0bfb97ba409d9d663c270cb240715
Author: Rui Miguel Silva <rui.silva@linaro.org>
Date:   Tue Dec 15 19:09:55 2015 +0000

    greybus: spi: validate spi master register
    
    Check for error in registering spi master, even though the current code
    will fail a little more ahead when trying to register devices in the
    master.
    
    Signed-off-by: Rui Miguel Silva <rui.silva@linaro.org>
    Reported-by: Johan Hovold <johan@hovoldconsulting.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/spi.c b/drivers/staging/greybus/spi.c
index 41aa0ec1ced7..6e1146d474df 100644
--- a/drivers/staging/greybus/spi.c
+++ b/drivers/staging/greybus/spi.c
@@ -360,6 +360,8 @@ static int gb_spi_connection_init(struct gb_connection *connection)
 	master->transfer_one_message = gb_spi_transfer_one_message;
 
 	ret = spi_register_master(master);
+	if (ret < 0)
+		goto out_put_master;
 
 	/* now, fetch the devices configuration */
 	for (i = 0; i < spi->num_chipselect; i++) {

commit 5fbd1a0bcb02a2fda30849539dee0b91c4009c42
Author: Rui Miguel Silva <rui.silva@linaro.org>
Date:   Tue Dec 15 19:09:54 2015 +0000

    greybus: spi: rename label to undo operation
    
    Rename error path label to a more significant name related to the free
    operation done.
    
    Signed-off-by: Rui Miguel Silva <rui.silva@linaro.org>
    Reported-by: Johan Hovold <johan@hovoldconsulting.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/spi.c b/drivers/staging/greybus/spi.c
index 15886a27b347..41aa0ec1ced7 100644
--- a/drivers/staging/greybus/spi.c
+++ b/drivers/staging/greybus/spi.c
@@ -346,7 +346,7 @@ static int gb_spi_connection_init(struct gb_connection *connection)
 
 	ret = gb_spi_init(spi);
 	if (ret)
-		goto out_err;
+		goto out_put_master;
 
 	master->bus_num = -1; /* Allow spi-core to allocate it dynamically */
 	master->num_chipselect = spi->num_chipselect;
@@ -370,7 +370,7 @@ static int gb_spi_connection_init(struct gb_connection *connection)
 
 	return ret;
 
-out_err:
+out_put_master:
 	spi_master_put(master);
 
 	return ret;

commit 50014e0774b25666ebdeb537964527e0b9c95c13
Author: Rui Miguel Silva <rui.silva@linaro.org>
Date:   Thu Dec 10 14:24:58 2015 +0000

    greybus: spi: move chipselect to one byte size
    
    Fixed in the specification, some values for chipselect count and index
    were different in size, just fix that for all reference to chipselect
    and move all to one byte size and remove byte order operations.
    
    Signed-off-by: Rui Miguel Silva <rui.silva@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/spi.c b/drivers/staging/greybus/spi.c
index 094d6d8c4f34..15886a27b347 100644
--- a/drivers/staging/greybus/spi.c
+++ b/drivers/staging/greybus/spi.c
@@ -20,7 +20,7 @@ struct gb_spi {
 	u16			mode;
 	u16			flags;
 	u32			bits_per_word_mask;
-	u16			num_chipselect;
+	u8			num_chipselect;
 	u32			min_speed_hz;
 	u32			max_speed_hz;
 	struct spi_device	*spi_devices;
@@ -270,7 +270,7 @@ static int gb_spi_get_master_config(struct gb_spi *spi)
 	spi->flags = gb_spi_flags_map(flags);
 
 	spi->bits_per_word_mask = le32_to_cpu(response.bits_per_word_mask);
-	spi->num_chipselect = le16_to_cpu(response.num_chipselect);
+	spi->num_chipselect = response.num_chipselect;
 
 	spi->min_speed_hz = le32_to_cpu(response.min_speed_hz);
 	spi->max_speed_hz = le32_to_cpu(response.max_speed_hz);
@@ -278,7 +278,7 @@ static int gb_spi_get_master_config(struct gb_spi *spi)
 	return 0;
 }
 
-static int gb_spi_setup_device(struct gb_spi *spi, uint16_t cs)
+static int gb_spi_setup_device(struct gb_spi *spi, u8 cs)
 {
 	struct spi_master *master = get_master_from_spi(spi);
 	struct gb_spi_device_config_request request;
@@ -287,7 +287,7 @@ static int gb_spi_setup_device(struct gb_spi *spi, uint16_t cs)
 	struct spi_device *spidev = &spi->spi_devices[cs];
 	int ret;
 
-	request.chip_select = cpu_to_le16(cs);
+	request.chip_select = cs;
 
 	ret = gb_operation_sync(spi->connection, GB_SPI_TYPE_DEVICE_CONFIG,
 				&request, sizeof(request),
@@ -331,7 +331,7 @@ static int gb_spi_connection_init(struct gb_connection *connection)
 	struct gb_spi *spi;
 	struct spi_master *master;
 	int ret;
-	int i;
+	u8 i;
 
 	/* Allocate master with space for data */
 	master = spi_alloc_master(&connection->bundle->dev, sizeof(*spi));

commit 31bc2c9bcd3054b90322acf85a53aacbb9e29ee4
Author: Rui Miguel Silva <rui.silva@linaro.org>
Date:   Wed Dec 2 11:12:29 2015 +0000

    greybus: spi: fix transfers bigger than greybus payload
    
    Add helper functions calculate the tx and rx size possible that fit a
    greybus payload size and change the operation creation to adjust to that.
    
    Signed-off-by: Rui Miguel Silva <rui.silva@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/spi.c b/drivers/staging/greybus/spi.c
index 8e0e403795f4..094d6d8c4f34 100644
--- a/drivers/staging/greybus/spi.c
+++ b/drivers/staging/greybus/spi.c
@@ -31,6 +31,51 @@ static struct spi_master *get_master_from_spi(struct gb_spi *spi)
 	return spi->connection->private;
 }
 
+static int tx_header_fit_operation(u32 tx_size, u32 count, size_t data_max)
+{
+	size_t headers_size;
+
+	data_max -= sizeof(struct gb_spi_transfer_request);
+	headers_size = (count + 1) * sizeof(struct gb_spi_transfer);
+
+	return tx_size + headers_size > data_max ? 0 : 1;
+}
+
+static size_t calc_rx_xfer_size(u32 rx_size, u32 *tx_xfer_size, u32 len,
+				size_t data_max)
+{
+	size_t rx_xfer_size;
+
+	data_max -= sizeof(struct gb_spi_transfer_response);
+
+	if (rx_size + len > data_max)
+		rx_xfer_size = data_max - rx_size;
+	else
+		rx_xfer_size = len;
+
+	/* if this is a write_read, for symmetry read the same as write */
+	if (*tx_xfer_size && rx_xfer_size > *tx_xfer_size)
+		rx_xfer_size = *tx_xfer_size;
+	if (*tx_xfer_size && rx_xfer_size < *tx_xfer_size)
+		*tx_xfer_size = rx_xfer_size;
+
+	return rx_xfer_size;
+}
+
+static size_t calc_tx_xfer_size(u32 tx_size, u32 count, size_t len,
+				size_t data_max)
+{
+	size_t headers_size;
+
+	data_max -= sizeof(struct gb_spi_transfer_request);
+	headers_size = (count + 1) * sizeof(struct gb_spi_transfer);
+
+	if (tx_size + headers_size + len > data_max)
+		return data_max - (tx_size + sizeof(struct gb_spi_transfer));
+
+	return len;
+}
+
 /* Routines to transfer data */
 static struct gb_operation *
 gb_spi_operation_create(struct gb_connection *connection,
@@ -41,9 +86,14 @@ gb_spi_operation_create(struct gb_connection *connection,
 	struct spi_transfer *xfer;
 	struct gb_spi_transfer *gb_xfer;
 	struct gb_operation *operation;
-	u32 tx_size = 0, rx_size = 0, count = 0, request_size;
+	struct spi_transfer *last_xfer = NULL;
+	u32 tx_size = 0, rx_size = 0, count = 0, xfer_len = 0, request_size;
+	u32 tx_xfer_size = 0, rx_xfer_size = 0, last_xfer_size = 0;
+	size_t data_max;
 	void *tx_data;
 
+	data_max = gb_operation_get_payload_size_max(connection);
+
 	/* Find number of transfers queued and tx/rx length in the message */
 	list_for_each_entry(xfer, &msg->transfers, transfer_list) {
 		if (!xfer->tx_buf && !xfer->rx_buf) {
@@ -51,21 +101,33 @@ gb_spi_operation_create(struct gb_connection *connection,
 				"bufferless transfer, length %u\n", xfer->len);
 			return NULL;
 		}
+		last_xfer = xfer;
 
-		if (xfer->tx_buf)
-			tx_size += xfer->len;
-		if (xfer->rx_buf)
-			rx_size += xfer->len;
+		tx_xfer_size = 0;
+		rx_xfer_size = 0;
+
+		if (xfer->tx_buf) {
+			if (!tx_header_fit_operation(tx_size, count, data_max))
+				break;
+			tx_xfer_size = calc_tx_xfer_size(tx_size, count,
+							 xfer->len, data_max);
+			last_xfer_size = tx_xfer_size;
+		}
+
+		if (xfer->rx_buf) {
+			rx_xfer_size = calc_rx_xfer_size(rx_size, &tx_xfer_size,
+							 xfer->len, data_max);
+			last_xfer_size = rx_xfer_size;
+		}
+
+		tx_size += tx_xfer_size;
+		rx_size += rx_xfer_size;
 
-		*total_len += xfer->len;
+		*total_len += last_xfer_size;
 		count++;
-	}
 
-	/* Too many transfers ? */
-	if (count > (u32)U16_MAX) {
-		dev_err(&connection->bundle->dev,
-			"transfer count (%u) too big\n", count);
-		return NULL;
+		if (xfer->len != last_xfer_size)
+			break;
 	}
 
 	/*
@@ -92,20 +154,30 @@ gb_spi_operation_create(struct gb_connection *connection,
 
 	/* Fill in the transfers array */
 	list_for_each_entry(xfer, &msg->transfers, transfer_list) {
+		if (last_xfer && xfer == last_xfer)
+			xfer_len = last_xfer_size;
+		else
+			xfer_len = xfer->len;
+
 		gb_xfer->speed_hz = cpu_to_le32(xfer->speed_hz);
-		gb_xfer->len = cpu_to_le32(xfer->len);
+		gb_xfer->len = cpu_to_le32(xfer_len);
 		gb_xfer->delay_usecs = cpu_to_le16(xfer->delay_usecs);
 		gb_xfer->cs_change = xfer->cs_change;
 		gb_xfer->bits_per_word = xfer->bits_per_word;
 
 		/* Copy tx data */
 		if (xfer->tx_buf) {
-			memcpy(tx_data, xfer->tx_buf, xfer->len);
-			tx_data += xfer->len;
 			gb_xfer->rdwr |= GB_SPI_XFER_WRITE;
+			memcpy(tx_data, xfer->tx_buf, xfer_len);
+			tx_data += xfer_len;
 		}
+
 		if (xfer->rx_buf)
 			gb_xfer->rdwr |= GB_SPI_XFER_READ;
+
+		if (last_xfer && xfer == last_xfer)
+			break;
+
 		gb_xfer++;
 	}
 

commit b343f6afd7635c86e1c001f1623e07f218c694db
Author: Rui Miguel Silva <rui.silva@linaro.org>
Date:   Wed Dec 2 11:12:28 2015 +0000

    greybus: spi: add master and device config operations
    
    Add master and device config operations, one is to merge all the master
    operations and the device config will allow to fetch and add devices for
    each chip select.
    
    Signed-off-by: Rui Miguel Silva <rui.silva@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/spi.c b/drivers/staging/greybus/spi.c
index 1b9c97336451..8e0e403795f4 100644
--- a/drivers/staging/greybus/spi.c
+++ b/drivers/staging/greybus/spi.c
@@ -1,8 +1,8 @@
 /*
  * SPI bridge driver for the Greybus "generic" SPI module.
  *
- * Copyright 2014 Google Inc.
- * Copyright 2014 Linaro Ltd.
+ * Copyright 2014-2015 Google Inc.
+ * Copyright 2014-2015 Linaro Ltd.
  *
  * Released under the GPLv2 only.
  */
@@ -17,30 +17,20 @@
 
 struct gb_spi {
 	struct gb_connection	*connection;
-
-	/* Modes supported by spi controller */
 	u16			mode;
-	/* constraints of the spi controller */
 	u16			flags;
-
-	/*
-	 * copied from kernel:
-	 *
-	 * A mask indicating which values of bits_per_word are supported by the
-	 * controller. Bit n indicates that a bits_per_word n+1 is suported. If
-	 * set, the SPI core will reject any transfer with an unsupported
-	 * bits_per_word. If not set, this value is simply ignored, and it's up
-	 * to the individual driver to perform any validation.
-	 */
 	u32			bits_per_word_mask;
-
-	/*
-	 * chipselects will be integral to many controllers; some others might
-	 * use board-specific GPIOs.
-	 */
 	u16			num_chipselect;
+	u32			min_speed_hz;
+	u32			max_speed_hz;
+	struct spi_device	*spi_devices;
 };
 
+static struct spi_master *get_master_from_spi(struct gb_spi *spi)
+{
+	return spi->connection->private;
+}
+
 /* Routines to transfer data */
 static struct gb_operation *
 gb_spi_operation_create(struct gb_connection *connection,
@@ -181,7 +171,7 @@ static void gb_spi_cleanup(struct spi_device *spi)
 }
 
 
-/* Routines to get controller infomation */
+/* Routines to get controller information */
 
 /*
  * Map Greybus spi mode bits/flags/bpw into Linux ones.
@@ -190,103 +180,86 @@ static void gb_spi_cleanup(struct spi_device *spi)
 #define gb_spi_mode_map(mode) mode
 #define gb_spi_flags_map(flags) flags
 
-static int gb_spi_mode_operation(struct gb_spi *spi)
+static int gb_spi_get_master_config(struct gb_spi *spi)
 {
-	struct gb_spi_mode_response response;
-	u16 mode;
+	struct gb_spi_master_config_response response;
+	u16 mode, flags;
 	int ret;
 
-	ret = gb_operation_sync(spi->connection, GB_SPI_TYPE_MODE,
+	ret = gb_operation_sync(spi->connection, GB_SPI_TYPE_MASTER_CONFIG,
 				NULL, 0, &response, sizeof(response));
-	if (ret)
+	if (ret < 0)
 		return ret;
 
 	mode = le16_to_cpu(response.mode);
 	spi->mode = gb_spi_mode_map(mode);
 
-	return 0;
-}
-
-static int gb_spi_flags_operation(struct gb_spi *spi)
-{
-	struct gb_spi_flags_response response;
-	u16 flags;
-	int ret;
-
-	ret = gb_operation_sync(spi->connection, GB_SPI_TYPE_FLAGS,
-				NULL, 0, &response, sizeof(response));
-	if (ret)
-		return ret;
-
 	flags = le16_to_cpu(response.flags);
 	spi->flags = gb_spi_flags_map(flags);
 
-	return 0;
-}
-
-static int gb_spi_bpw_operation(struct gb_spi *spi)
-{
-	struct gb_spi_bpw_response response;
-	int ret;
-
-	ret = gb_operation_sync(spi->connection, GB_SPI_TYPE_BITS_PER_WORD_MASK,
-				NULL, 0, &response, sizeof(response));
-	if (ret)
-		return ret;
-
 	spi->bits_per_word_mask = le32_to_cpu(response.bits_per_word_mask);
+	spi->num_chipselect = le16_to_cpu(response.num_chipselect);
+
+	spi->min_speed_hz = le32_to_cpu(response.min_speed_hz);
+	spi->max_speed_hz = le32_to_cpu(response.max_speed_hz);
 
 	return 0;
 }
 
-static int gb_spi_chipselect_operation(struct gb_spi *spi)
+static int gb_spi_setup_device(struct gb_spi *spi, uint16_t cs)
 {
-	struct gb_spi_chipselect_response response;
+	struct spi_master *master = get_master_from_spi(spi);
+	struct gb_spi_device_config_request request;
+	struct gb_spi_device_config_response response;
+	struct spi_board_info spi_board = { {0} };
+	struct spi_device *spidev = &spi->spi_devices[cs];
 	int ret;
 
-	ret = gb_operation_sync(spi->connection, GB_SPI_TYPE_NUM_CHIPSELECT,
-				NULL, 0, &response, sizeof(response));
-	if (ret)
+	request.chip_select = cpu_to_le16(cs);
+
+	ret = gb_operation_sync(spi->connection, GB_SPI_TYPE_DEVICE_CONFIG,
+				&request, sizeof(request),
+				&response, sizeof(response));
+	if (ret < 0)
 		return ret;
 
-	spi->num_chipselect = le16_to_cpu(response.num_chipselect);
+	memcpy(spi_board.modalias, response.name, sizeof(spi_board.modalias));
+	spi_board.mode		= le16_to_cpu(response.mode);
+	spi_board.bus_num	= master->bus_num;
+	spi_board.chip_select	= cs;
+	spi_board.max_speed_hz	= le32_to_cpu(response.max_speed_hz);
+
+	spidev = spi_new_device(master, &spi_board);
+	if (!spidev)
+		ret = -EINVAL;
 
 	return 0;
 }
 
-/*
- * Initialize the spi device. This includes verifying we can support it (based
- * on the protocol version it advertises). If that's OK, we get and cached its
- * mode bits & flags.
- */
 static int gb_spi_init(struct gb_spi *spi)
 {
 	int ret;
 
-	/* mode never changes, just get it once */
-	ret = gb_spi_mode_operation(spi);
-	if (ret)
-		return ret;
-
-	/* flags never changes, just get it once */
-	ret = gb_spi_flags_operation(spi);
+	/* get master configuration */
+	ret = gb_spi_get_master_config(spi);
 	if (ret)
 		return ret;
 
-	/* total number of chipselects never changes, just get it once */
-	ret = gb_spi_chipselect_operation(spi);
-	if (ret)
-		return ret;
+	spi->spi_devices = kcalloc(spi->num_chipselect,
+				   sizeof(struct spi_device), GFP_KERNEL);
+	if (!spi->spi_devices)
+		return -ENOMEM;
 
-	/* bits-per-word-mask never changes, just get it once */
-	return gb_spi_bpw_operation(spi);
+	return ret;
 }
 
+
 static int gb_spi_connection_init(struct gb_connection *connection)
 {
 	struct gb_spi *spi;
 	struct spi_master *master;
 	int ret;
+	int i;
 
 	/* Allocate master with space for data */
 	master = spi_alloc_master(&connection->bundle->dev, sizeof(*spi));
@@ -315,8 +288,15 @@ static int gb_spi_connection_init(struct gb_connection *connection)
 	master->transfer_one_message = gb_spi_transfer_one_message;
 
 	ret = spi_register_master(master);
-	if (!ret)
-		return 0;
+
+	/* now, fetch the devices configuration */
+	for (i = 0; i < spi->num_chipselect; i++) {
+		ret = gb_spi_setup_device(spi, i);
+		if (ret < 0)
+			break;
+	}
+
+	return ret;
 
 out_err:
 	spi_master_put(master);

commit b455c84655d5bdfc5157d2100279e3ff2454b596
Author: Rui Miguel Silva <rui.silva@linaro.org>
Date:   Wed Dec 2 11:12:27 2015 +0000

    greybus: spi: add rdwr field to transfer descriptor
    
    Add read and/or write field to transfer descriptor to make it possible
    to identify the type of transfer.
    
    Signed-off-by: Rui Miguel Silva <rui.silva@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/spi.c b/drivers/staging/greybus/spi.c
index 33e86f9c3182..1b9c97336451 100644
--- a/drivers/staging/greybus/spi.c
+++ b/drivers/staging/greybus/spi.c
@@ -107,13 +107,16 @@ gb_spi_operation_create(struct gb_connection *connection,
 		gb_xfer->delay_usecs = cpu_to_le16(xfer->delay_usecs);
 		gb_xfer->cs_change = xfer->cs_change;
 		gb_xfer->bits_per_word = xfer->bits_per_word;
-		gb_xfer++;
 
 		/* Copy tx data */
 		if (xfer->tx_buf) {
 			memcpy(tx_data, xfer->tx_buf, xfer->len);
 			tx_data += xfer->len;
+			gb_xfer->rdwr |= GB_SPI_XFER_WRITE;
 		}
+		if (xfer->rx_buf)
+			gb_xfer->rdwr |= GB_SPI_XFER_READ;
+		gb_xfer++;
 	}
 
 	return operation;

commit 1cb9e38c8c17b16b2712aaf2ca4d3509f0fe9366
Author: Greg Kroah-Hartman <gregkh@google.com>
Date:   Wed Oct 14 11:15:38 2015 -0700

    greybus: spi: use the bundle struct device instead of the connector
    
    We are removing struct device from the gb_connection structure in the
    near future.  The gb_bundle structure's struct device should be used as
    a replacement.
    
    This patch moves the spi driver to use the bundle pointer instead of the
    connection pointer.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>
    Reviewed-by: Alex Elder <elder@linaro.org>

diff --git a/drivers/staging/greybus/spi.c b/drivers/staging/greybus/spi.c
index 393f28ad099b..33e86f9c3182 100644
--- a/drivers/staging/greybus/spi.c
+++ b/drivers/staging/greybus/spi.c
@@ -57,7 +57,7 @@ gb_spi_operation_create(struct gb_connection *connection,
 	/* Find number of transfers queued and tx/rx length in the message */
 	list_for_each_entry(xfer, &msg->transfers, transfer_list) {
 		if (!xfer->tx_buf && !xfer->rx_buf) {
-			dev_err(&connection->dev,
+			dev_err(&connection->bundle->dev,
 				"bufferless transfer, length %u\n", xfer->len);
 			return NULL;
 		}
@@ -73,8 +73,8 @@ gb_spi_operation_create(struct gb_connection *connection,
 
 	/* Too many transfers ? */
 	if (count > (u32)U16_MAX) {
-		dev_err(&connection->dev, "transfer count (%u) too big\n",
-			count);
+		dev_err(&connection->bundle->dev,
+			"transfer count (%u) too big\n", count);
 		return NULL;
 	}
 
@@ -286,9 +286,9 @@ static int gb_spi_connection_init(struct gb_connection *connection)
 	int ret;
 
 	/* Allocate master with space for data */
-	master = spi_alloc_master(&connection->dev, sizeof(*spi));
+	master = spi_alloc_master(&connection->bundle->dev, sizeof(*spi));
 	if (!master) {
-		dev_err(&connection->dev, "cannot alloc SPI master\n");
+		dev_err(&connection->bundle->dev, "cannot alloc SPI master\n");
 		return -ENOMEM;
 	}
 

commit 6ab1ce4d542ea1b5ffa40321e021d95de47880ea
Author: Johan Hovold <johan@hovoldconsulting.com>
Date:   Sat Sep 26 17:59:15 2015 -0700

    greybus: operation: remove gb_operation_destroy
    
    Remove legacy interface to "destroy" operations, which is now just a
    wrapper for gb_operation_put.
    
    The old interface name hides the fact that all operations are refcounted
    and may live on even after having "destroyed" them.
    
    Signed-off-by: Johan Hovold <johan@hovoldconsulting.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/spi.c b/drivers/staging/greybus/spi.c
index e5d216646b9c..393f28ad099b 100644
--- a/drivers/staging/greybus/spi.c
+++ b/drivers/staging/greybus/spi.c
@@ -156,7 +156,8 @@ static int gb_spi_transfer_one_message(struct spi_master *master,
 	} else {
 		pr_err("transfer operation failed (%d)\n", ret);
 	}
-	gb_operation_destroy(operation);
+
+	gb_operation_put(operation);
 
 	msg->actual_length = len;
 	msg->status = 0;

commit 2111134fe413311ea2e89c7ffc66abb68ada5982
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Fri Sep 4 15:10:09 2015 +0530

    greybus: spi: Allow spi-core to allocate bus numbers dynamically
    
    And that fixes these warnings generated with BDB:
    
    WARNING: at /home/viresh/ara/jetson-kernel-build/tegra/fs/sysfs/dir.c:530 sysfs_add_one+0xa4/0xb4()
    sysfs: cannot create duplicate filename '/class/spi_master/spi0'
    Modules linked in: gb_es2(O) gb_phy(O) greybus(O)
    CPU: 2 PID: 111 Comm: kworker/u8:3 Tainted: G        W  O 3.10.40-gf32f9c5ca7e8 #2
    Workqueue: events_unbound svc_process_hotplug [greybus]
    [<c0016844>] (unwind_backtrace+0x0/0x13c) from [<c0012fc4>] (show_stack+0x18/0x1c)
    [<c0012fc4>] (show_stack+0x18/0x1c) from [<c0067d4c>] (warn_slowpath_common+0x5c/0x74)
    [<c0067d4c>] (warn_slowpath_common+0x5c/0x74) from [<c0067d9c>] (warn_slowpath_fmt+0x38/0x48)
    [<c0067d9c>] (warn_slowpath_fmt+0x38/0x48) from [<c01bc218>] (sysfs_add_one+0xa4/0xb4)
    [<c01bc218>] (sysfs_add_one+0xa4/0xb4) from [<c01bcc24>] (sysfs_do_create_link_sd+0xc0/0x20c)
    [<c01bcc24>] (sysfs_do_create_link_sd+0xc0/0x20c) from [<c042e088>] (device_add+0x2e8/0x5f4)
    [<c042e088>] (device_add+0x2e8/0x5f4) from [<c04ae008>] (spi_register_master+0x15c/0x654)
    [<c04ae008>] (spi_register_master+0x15c/0x654) from [<bf015df4>] (gb_spi_connection_init+0x164/0x19c [gb_phy])
    [<bf015df4>] (gb_spi_connection_init+0x164/0x19c [gb_phy]) from [<bf002604>] (gb_connection_bind_protocol+0x160/0x1b4 [greybus])
    [<bf002604>] (gb_connection_bind_protocol+0x160/0x1b4 [greybus]) from [<bf002880>] (gb_connection_create_range+0x228/0x2fc [greybus])
    [<bf002880>] (gb_connection_create_range+0x228/0x2fc [greybus]) from [<bf002994>] (gb_connection_create+0x40/0x48 [greybus])
    [<bf002994>] (gb_connection_create+0x40/0x48 [greybus]) from [<bf000be0>] (gb_manifest_parse+0x61c/0x628 [greybus])
    [<bf000be0>] (gb_manifest_parse+0x61c/0x628 [greybus]) from [<bf0019ac>] (gb_interface_init+0x130/0x170 [greybus])
    [<bf0019ac>] (gb_interface_init+0x130/0x170 [greybus]) from [<bf003bf0>] (svc_process_hotplug+0x214/0x258 [greybus])
    [<bf003bf0>] (svc_process_hotplug+0x214/0x258 [greybus]) from [<c0087ecc>] (process_one_work+0x13c/0x454)
    [<c0087ecc>] (process_one_work+0x13c/0x454) from [<c0088c20>] (worker_thread+0x140/0x3dc)
    [<c0088c20>] (worker_thread+0x140/0x3dc) from [<c008f20c>] (kthread+0xe0/0xe4)
    [<c008f20c>] (kthread+0xe0/0xe4) from [<c000f098>] (ret_from_fork+0x14/0x20)
    
    Reported-by: Mitchell Tasman <tasman@leaflabs.com>
    Suggested-by: Johan Hovold <johan@hovoldconsulting.com>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Johan Hovold <johan@hovoldconsulting.com>

diff --git a/drivers/staging/greybus/spi.c b/drivers/staging/greybus/spi.c
index ef3cc33772f8..e5d216646b9c 100644
--- a/drivers/staging/greybus/spi.c
+++ b/drivers/staging/greybus/spi.c
@@ -299,7 +299,7 @@ static int gb_spi_connection_init(struct gb_connection *connection)
 	if (ret)
 		goto out_err;
 
-	master->bus_num = 0;		/* How do we get controller id here? */
+	master->bus_num = -1; /* Allow spi-core to allocate it dynamically */
 	master->num_chipselect = spi->num_chipselect;
 	master->mode_bits = spi->mode;
 	master->flags = spi->flags;

commit 3fb0c8f516e06cb3bc39610aeb1311b8376bdc61
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Tue Aug 11 07:36:10 2015 +0530

    greybus: spi: Drop get_version support
    
    This is done from a common place now, no need to replicate it.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/spi.c b/drivers/staging/greybus/spi.c
index 77d6bf0b7f13..ef3cc33772f8 100644
--- a/drivers/staging/greybus/spi.c
+++ b/drivers/staging/greybus/spi.c
@@ -17,8 +17,6 @@
 
 struct gb_spi {
 	struct gb_connection	*connection;
-	u8			version_major;
-	u8			version_minor;
 
 	/* Modes supported by spi controller */
 	u16			mode;
@@ -181,9 +179,6 @@ static void gb_spi_cleanup(struct spi_device *spi)
 
 /* Routines to get controller infomation */
 
-/* Define get_version() routine */
-define_get_version(gb_spi, SPI);
-
 /*
  * Map Greybus spi mode bits/flags/bpw into Linux ones.
  * All bits are same for now and so these macro's return same values.
@@ -264,11 +259,6 @@ static int gb_spi_init(struct gb_spi *spi)
 {
 	int ret;
 
-	/* First thing we need to do is check the version */
-	ret = get_version(spi);
-	if (ret)
-		return ret;
-
 	/* mode never changes, just get it once */
 	ret = gb_spi_mode_operation(spi);
 	if (ret)

commit 7549219d4ea0a9d8b78c3819dff8dcdb9db14eb1
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Sat Aug 8 10:25:38 2015 +0530

    greybus: spi: Use (already defined) major/minor macros
    
    We already have macros for these, use them instead of writing fixed
    values.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/spi.c b/drivers/staging/greybus/spi.c
index 306fb074c183..77d6bf0b7f13 100644
--- a/drivers/staging/greybus/spi.c
+++ b/drivers/staging/greybus/spi.c
@@ -340,8 +340,8 @@ static void gb_spi_connection_exit(struct gb_connection *connection)
 static struct gb_protocol spi_protocol = {
 	.name			= "spi",
 	.id			= GREYBUS_PROTOCOL_SPI,
-	.major			= 0,
-	.minor			= 1,
+	.major			= GB_SPI_VERSION_MAJOR,
+	.minor			= GB_SPI_VERSION_MINOR,
 	.connection_init	= gb_spi_connection_init,
 	.connection_exit	= gb_spi_connection_exit,
 	.request_recv		= NULL,

commit e420721b47ef5b0d521584d4efc89ff64bd0cd74
Author: Johan Hovold <johan@hovoldconsulting.com>
Date:   Wed Jul 1 12:37:22 2015 +0200

    greybus: operation: allow atomic operation allocations
    
    Add gfp mask argument to gb_operation_create to allow operations to be
    allocated in atomic context.
    
    Signed-off-by: Johan Hovold <johan@hovoldconsulting.com>
    Reviewed-by: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/spi.c b/drivers/staging/greybus/spi.c
index 374361889666..306fb074c183 100644
--- a/drivers/staging/greybus/spi.c
+++ b/drivers/staging/greybus/spi.c
@@ -90,7 +90,7 @@ gb_spi_operation_create(struct gb_connection *connection,
 
 	/* Response consists only of incoming data */
 	operation = gb_operation_create(connection, GB_SPI_TYPE_TRANSFER,
-					request_size, rx_size);
+					request_size, rx_size, GFP_KERNEL);
 	if (!operation)
 		return NULL;
 

commit e18822e3d02c8f296fe42e0e8bda7e2e626a4714
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Wed Jul 1 12:13:52 2015 +0530

    greybus: Rename gb_gpbridge_protocol_driver() as gb_builtin_protocol_driver()
    
    This macro is also required by core protocols like control and svc, and
    hence the 'gpbridge' name doesn't fit anymore.
    
    Lets call this macro gb_builtin_protocol_driver().
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Reviewed-by: Alex Elder <elder@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/spi.c b/drivers/staging/greybus/spi.c
index 78a7f85a4bf6..374361889666 100644
--- a/drivers/staging/greybus/spi.c
+++ b/drivers/staging/greybus/spi.c
@@ -347,4 +347,4 @@ static struct gb_protocol spi_protocol = {
 	.request_recv		= NULL,
 };
 
-gb_gpbridge_protocol_driver(spi_protocol);
+gb_builtin_protocol_driver(spi_protocol);

commit e9385e5d5ab64a0d05758d84f2980943d3f5f12d
Author: Alex Elder <elder@linaro.org>
Date:   Fri May 22 12:35:31 2015 -0500

    greybus: include "gpbridge.h" from "greybus.h"
    
    Avoid the need for all the source files to include "gpbridge.h"
    by just having "greybus.h" include it.
    
    Signed-off-by: Alex Elder <elder@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/spi.c b/drivers/staging/greybus/spi.c
index 430c3ad70a5a..78a7f85a4bf6 100644
--- a/drivers/staging/greybus/spi.c
+++ b/drivers/staging/greybus/spi.c
@@ -14,7 +14,6 @@
 #include <linux/spi/spi.h>
 
 #include "greybus.h"
-#include "gpbridge.h"
 
 struct gb_spi {
 	struct gb_connection	*connection;

commit bdac599c70409bbf48e77971e2b9ecc2a66ef151
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Wed May 20 17:20:10 2015 +0530

    greybus: Use gb_gpbridge_protocol_init()
    
    Start using gb_gpbridge_protocol_init() in gpbridge drivers.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Reviewed-by: Alex Elder <elder@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/spi.c b/drivers/staging/greybus/spi.c
index a8fb04ad15b5..430c3ad70a5a 100644
--- a/drivers/staging/greybus/spi.c
+++ b/drivers/staging/greybus/spi.c
@@ -348,12 +348,4 @@ static struct gb_protocol spi_protocol = {
 	.request_recv		= NULL,
 };
 
-int gb_spi_protocol_init(void)
-{
-	return gb_protocol_register(&spi_protocol);
-}
-
-void gb_spi_protocol_exit(void)
-{
-	gb_protocol_deregister(&spi_protocol);
-}
+gb_gpbridge_protocol_driver(spi_protocol);

commit 4890f31966a6991e7652f8a365ff59c1ba313c9d
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Wed May 20 16:33:57 2015 +0530

    greybus: spi: Move structure definitions into gpbridge.h
    
    In order to facilitate re-use of spi structures, split them out of
    independent files and add them into a shared gpbridge.h
    
    This will be a prereq to sharing these headers w/ gbsim.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/spi.c b/drivers/staging/greybus/spi.c
index 731639a810b2..a8fb04ad15b5 100644
--- a/drivers/staging/greybus/spi.c
+++ b/drivers/staging/greybus/spi.c
@@ -14,6 +14,7 @@
 #include <linux/spi/spi.h>
 
 #include "greybus.h"
+#include "gpbridge.h"
 
 struct gb_spi {
 	struct gb_connection	*connection;
@@ -43,89 +44,6 @@ struct gb_spi {
 	u16			num_chipselect;
 };
 
-/* Version of the Greybus spi protocol we support */
-#define GB_SPI_VERSION_MAJOR		0x00
-#define GB_SPI_VERSION_MINOR		0x01
-
-/* Should match up with modes in linux/spi/spi.h */
-#define GB_SPI_MODE_CPHA		0x01		/* clock phase */
-#define GB_SPI_MODE_CPOL		0x02		/* clock polarity */
-#define GB_SPI_MODE_MODE_0		(0|0)		/* (original MicroWire) */
-#define GB_SPI_MODE_MODE_1		(0|GB_SPI_MODE_CPHA)
-#define GB_SPI_MODE_MODE_2		(GB_SPI_MODE_CPOL|0)
-#define GB_SPI_MODE_MODE_3		(GB_SPI_MODE_CPOL|GB_SPI_MODE_CPHA)
-#define GB_SPI_MODE_CS_HIGH		0x04		/* chipselect active high? */
-#define GB_SPI_MODE_LSB_FIRST		0x08		/* per-word bits-on-wire */
-#define GB_SPI_MODE_3WIRE		0x10		/* SI/SO signals shared */
-#define GB_SPI_MODE_LOOP		0x20		/* loopback mode */
-#define GB_SPI_MODE_NO_CS		0x40		/* 1 dev/bus, no chipselect */
-#define GB_SPI_MODE_READY		0x80		/* slave pulls low to pause */
-
-/* Should match up with flags in linux/spi/spi.h */
-#define GB_SPI_FLAG_HALF_DUPLEX		BIT(0)		/* can't do full duplex */
-#define GB_SPI_FLAG_NO_RX		BIT(1)		/* can't do buffer read */
-#define GB_SPI_FLAG_NO_TX		BIT(2)		/* can't do buffer write */
-
-/* Greybus spi operation types */
-#define GB_SPI_TYPE_INVALID		0x00
-#define GB_SPI_TYPE_PROTOCOL_VERSION	0x01
-#define GB_SPI_TYPE_MODE		0x02
-#define GB_SPI_TYPE_FLAGS		0x03
-#define GB_SPI_TYPE_BITS_PER_WORD_MASK	0x04
-#define GB_SPI_TYPE_NUM_CHIPSELECT	0x05
-#define GB_SPI_TYPE_TRANSFER		0x06
-
-/* mode request has no payload */
-struct gb_spi_mode_response {
-	__le16	mode;
-};
-
-/* flags request has no payload */
-struct gb_spi_flags_response {
-	__le16	flags;
-};
-
-/* bits-per-word request has no payload */
-struct gb_spi_bpw_response {
-	__le32	bits_per_word_mask;
-};
-
-/* num-chipselects request has no payload */
-struct gb_spi_chipselect_response {
-	__le16	num_chipselect;
-};
-
-/**
- * struct gb_spi_transfer - a read/write buffer pair
- * @speed_hz: Select a speed other than the device default for this transfer. If
- *	0 the default (from @spi_device) is used.
- * @len: size of rx and tx buffers (in bytes)
- * @delay_usecs: microseconds to delay after this transfer before (optionally)
- * 	changing the chipselect status, then starting the next transfer or
- * 	completing this spi_message.
- * @cs_change: affects chipselect after this transfer completes
- * @bits_per_word: select a bits_per_word other than the device default for this
- *	transfer. If 0 the default (from @spi_device) is used.
- */
-struct gb_spi_transfer {
-	__le32		speed_hz;
-	__le32		len;
-	__le16		delay_usecs;
-	__u8		cs_change;
-	__u8		bits_per_word;
-};
-
-struct gb_spi_transfer_request {
-	__u8			chip_select;	/* of the spi device */
-	__u8			mode;		/* of the spi device */
-	__le16			count;
-	struct gb_spi_transfer	transfers[0];	/* trnasfer_count of these */
-};
-
-struct gb_spi_transfer_response {
-	__u8			data[0];	/* inbound data */
-};
-
 /* Routines to transfer data */
 static struct gb_operation *
 gb_spi_operation_create(struct gb_connection *connection,

commit 6d653370c0a67ff9b9b0d8249182d537859b528c
Author: Alex Elder <elder@linaro.org>
Date:   Thu May 7 13:03:52 2015 -0500

    greybus: eliminate extra response flag definitions
    
    All protocols use the same value to distinguish between request and
    response message types.  This is a requirement.
    
    Use GB_MESSAGE_TYPE_RESPONSE rather than GB_OPERATION_TYPE_RESPONSE
    for the name of the flag used to distiguish between request and
    response messages.
    
    Get rid of the redundant response flag definitions that are
    associated with specific protocols.
    
    Describe the symbolic values as "operation types" rather than
    "message types" where they are defined.  The message type for a
    request is the same as the operation type; the message type for a
    response is the operation type OR'd with GB_MESSAGE_TYPE_RESPONSE.
    
    Signed-off-by: Alex Elder <elder@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/spi.c b/drivers/staging/greybus/spi.c
index 639c9cdac516..731639a810b2 100644
--- a/drivers/staging/greybus/spi.c
+++ b/drivers/staging/greybus/spi.c
@@ -66,7 +66,7 @@ struct gb_spi {
 #define GB_SPI_FLAG_NO_RX		BIT(1)		/* can't do buffer read */
 #define GB_SPI_FLAG_NO_TX		BIT(2)		/* can't do buffer write */
 
-/* Greybus spi request types */
+/* Greybus spi operation types */
 #define GB_SPI_TYPE_INVALID		0x00
 #define GB_SPI_TYPE_PROTOCOL_VERSION	0x01
 #define GB_SPI_TYPE_MODE		0x02
@@ -74,7 +74,6 @@ struct gb_spi {
 #define GB_SPI_TYPE_BITS_PER_WORD_MASK	0x04
 #define GB_SPI_TYPE_NUM_CHIPSELECT	0x05
 #define GB_SPI_TYPE_TRANSFER		0x06
-#define GB_SPI_TYPE_RESPONSE		0x80	/* OR'd with rest */
 
 /* mode request has no payload */
 struct gb_spi_mode_response {

commit 25eb732954ee656edd92770f498d28f87086511b
Author: Johan Hovold <johan@hovoldconsulting.com>
Date:   Thu Mar 19 16:46:17 2015 +0100

    greybus: connection: replace custom error function with dev_err
    
    Remove custom connection error function and replace it with dev_err.
    
    The standard error function provides more information in the message
    prefix (e.g. includes the interface id), has a well-known semantics
    (e.g. does does not add newlines to messages), and is even somewhat
    shorter to type.
    
    Note that some uses of the custom function were already adding double
    newlines due to the non-standard semantics.
    
    Signed-off-by: Johan Hovold <johan@hovoldconsulting.com>
    Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>

diff --git a/drivers/staging/greybus/spi.c b/drivers/staging/greybus/spi.c
index ad0c179e51f5..639c9cdac516 100644
--- a/drivers/staging/greybus/spi.c
+++ b/drivers/staging/greybus/spi.c
@@ -143,9 +143,8 @@ gb_spi_operation_create(struct gb_connection *connection,
 	/* Find number of transfers queued and tx/rx length in the message */
 	list_for_each_entry(xfer, &msg->transfers, transfer_list) {
 		if (!xfer->tx_buf && !xfer->rx_buf) {
-			gb_connection_err(connection,
-					  "Bufferless transfer, length %u\n",
-					  xfer->len);
+			dev_err(&connection->dev,
+				"bufferless transfer, length %u\n", xfer->len);
 			return NULL;
 		}
 
@@ -160,8 +159,8 @@ gb_spi_operation_create(struct gb_connection *connection,
 
 	/* Too many transfers ? */
 	if (count > (u32)U16_MAX) {
-		gb_connection_err(connection, "transfer count (%u) too big",
-				  count);
+		dev_err(&connection->dev, "transfer count (%u) too big\n",
+			count);
 		return NULL;
 	}
 
@@ -382,7 +381,7 @@ static int gb_spi_connection_init(struct gb_connection *connection)
 	/* Allocate master with space for data */
 	master = spi_alloc_master(&connection->dev, sizeof(*spi));
 	if (!master) {
-		gb_connection_err(connection, "cannot alloc SPI master\n");
+		dev_err(&connection->dev, "cannot alloc SPI master\n");
 		return -ENOMEM;
 	}
 

commit f4e6c817b377833a725ba0be80c29fbb59ffd0f7
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Tue Jan 27 09:08:04 2015 +0530

    greybus: spi:fix sparse warnings
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>

diff --git a/drivers/staging/greybus/spi.c b/drivers/staging/greybus/spi.c
index 11859047ac31..ad0c179e51f5 100644
--- a/drivers/staging/greybus/spi.c
+++ b/drivers/staging/greybus/spi.c
@@ -180,7 +180,7 @@ gb_spi_operation_create(struct gb_connection *connection,
 		return NULL;
 
 	request = operation->request->payload;
-	request->count = count;
+	request->count = cpu_to_le16(count);
 	request->mode = dev->mode;
 	request->chip_select = dev->chip_select;
 
@@ -189,7 +189,7 @@ gb_spi_operation_create(struct gb_connection *connection,
 
 	/* Fill in the transfers array */
 	list_for_each_entry(xfer, &msg->transfers, transfer_list) {
-		gb_xfer->speed_hz = cpu_to_le16(xfer->speed_hz);
+		gb_xfer->speed_hz = cpu_to_le32(xfer->speed_hz);
 		gb_xfer->len = cpu_to_le32(xfer->len);
 		gb_xfer->delay_usecs = cpu_to_le16(xfer->delay_usecs);
 		gb_xfer->cs_change = xfer->cs_change;
@@ -335,7 +335,7 @@ static int gb_spi_chipselect_operation(struct gb_spi *spi)
 	if (ret)
 		return ret;
 
-	spi->num_chipselect = le32_to_cpu(response.num_chipselect);
+	spi->num_chipselect = le16_to_cpu(response.num_chipselect);
 
 	return 0;
 }

commit 15d651b0dba16a81285686bf52f4d5b1656362d8
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Fri Jan 23 13:07:45 2015 +0530

    greybus: spi: add bridged-PHY spi protocol driver
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>

diff --git a/drivers/staging/greybus/spi.c b/drivers/staging/greybus/spi.c
new file mode 100644
index 000000000000..11859047ac31
--- /dev/null
+++ b/drivers/staging/greybus/spi.c
@@ -0,0 +1,443 @@
+/*
+ * SPI bridge driver for the Greybus "generic" SPI module.
+ *
+ * Copyright 2014 Google Inc.
+ * Copyright 2014 Linaro Ltd.
+ *
+ * Released under the GPLv2 only.
+ */
+
+#include <linux/bitops.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/spi/spi.h>
+
+#include "greybus.h"
+
+struct gb_spi {
+	struct gb_connection	*connection;
+	u8			version_major;
+	u8			version_minor;
+
+	/* Modes supported by spi controller */
+	u16			mode;
+	/* constraints of the spi controller */
+	u16			flags;
+
+	/*
+	 * copied from kernel:
+	 *
+	 * A mask indicating which values of bits_per_word are supported by the
+	 * controller. Bit n indicates that a bits_per_word n+1 is suported. If
+	 * set, the SPI core will reject any transfer with an unsupported
+	 * bits_per_word. If not set, this value is simply ignored, and it's up
+	 * to the individual driver to perform any validation.
+	 */
+	u32			bits_per_word_mask;
+
+	/*
+	 * chipselects will be integral to many controllers; some others might
+	 * use board-specific GPIOs.
+	 */
+	u16			num_chipselect;
+};
+
+/* Version of the Greybus spi protocol we support */
+#define GB_SPI_VERSION_MAJOR		0x00
+#define GB_SPI_VERSION_MINOR		0x01
+
+/* Should match up with modes in linux/spi/spi.h */
+#define GB_SPI_MODE_CPHA		0x01		/* clock phase */
+#define GB_SPI_MODE_CPOL		0x02		/* clock polarity */
+#define GB_SPI_MODE_MODE_0		(0|0)		/* (original MicroWire) */
+#define GB_SPI_MODE_MODE_1		(0|GB_SPI_MODE_CPHA)
+#define GB_SPI_MODE_MODE_2		(GB_SPI_MODE_CPOL|0)
+#define GB_SPI_MODE_MODE_3		(GB_SPI_MODE_CPOL|GB_SPI_MODE_CPHA)
+#define GB_SPI_MODE_CS_HIGH		0x04		/* chipselect active high? */
+#define GB_SPI_MODE_LSB_FIRST		0x08		/* per-word bits-on-wire */
+#define GB_SPI_MODE_3WIRE		0x10		/* SI/SO signals shared */
+#define GB_SPI_MODE_LOOP		0x20		/* loopback mode */
+#define GB_SPI_MODE_NO_CS		0x40		/* 1 dev/bus, no chipselect */
+#define GB_SPI_MODE_READY		0x80		/* slave pulls low to pause */
+
+/* Should match up with flags in linux/spi/spi.h */
+#define GB_SPI_FLAG_HALF_DUPLEX		BIT(0)		/* can't do full duplex */
+#define GB_SPI_FLAG_NO_RX		BIT(1)		/* can't do buffer read */
+#define GB_SPI_FLAG_NO_TX		BIT(2)		/* can't do buffer write */
+
+/* Greybus spi request types */
+#define GB_SPI_TYPE_INVALID		0x00
+#define GB_SPI_TYPE_PROTOCOL_VERSION	0x01
+#define GB_SPI_TYPE_MODE		0x02
+#define GB_SPI_TYPE_FLAGS		0x03
+#define GB_SPI_TYPE_BITS_PER_WORD_MASK	0x04
+#define GB_SPI_TYPE_NUM_CHIPSELECT	0x05
+#define GB_SPI_TYPE_TRANSFER		0x06
+#define GB_SPI_TYPE_RESPONSE		0x80	/* OR'd with rest */
+
+/* mode request has no payload */
+struct gb_spi_mode_response {
+	__le16	mode;
+};
+
+/* flags request has no payload */
+struct gb_spi_flags_response {
+	__le16	flags;
+};
+
+/* bits-per-word request has no payload */
+struct gb_spi_bpw_response {
+	__le32	bits_per_word_mask;
+};
+
+/* num-chipselects request has no payload */
+struct gb_spi_chipselect_response {
+	__le16	num_chipselect;
+};
+
+/**
+ * struct gb_spi_transfer - a read/write buffer pair
+ * @speed_hz: Select a speed other than the device default for this transfer. If
+ *	0 the default (from @spi_device) is used.
+ * @len: size of rx and tx buffers (in bytes)
+ * @delay_usecs: microseconds to delay after this transfer before (optionally)
+ * 	changing the chipselect status, then starting the next transfer or
+ * 	completing this spi_message.
+ * @cs_change: affects chipselect after this transfer completes
+ * @bits_per_word: select a bits_per_word other than the device default for this
+ *	transfer. If 0 the default (from @spi_device) is used.
+ */
+struct gb_spi_transfer {
+	__le32		speed_hz;
+	__le32		len;
+	__le16		delay_usecs;
+	__u8		cs_change;
+	__u8		bits_per_word;
+};
+
+struct gb_spi_transfer_request {
+	__u8			chip_select;	/* of the spi device */
+	__u8			mode;		/* of the spi device */
+	__le16			count;
+	struct gb_spi_transfer	transfers[0];	/* trnasfer_count of these */
+};
+
+struct gb_spi_transfer_response {
+	__u8			data[0];	/* inbound data */
+};
+
+/* Routines to transfer data */
+static struct gb_operation *
+gb_spi_operation_create(struct gb_connection *connection,
+			struct spi_message *msg, u32 *total_len)
+{
+	struct gb_spi_transfer_request *request;
+	struct spi_device *dev = msg->spi;
+	struct spi_transfer *xfer;
+	struct gb_spi_transfer *gb_xfer;
+	struct gb_operation *operation;
+	u32 tx_size = 0, rx_size = 0, count = 0, request_size;
+	void *tx_data;
+
+	/* Find number of transfers queued and tx/rx length in the message */
+	list_for_each_entry(xfer, &msg->transfers, transfer_list) {
+		if (!xfer->tx_buf && !xfer->rx_buf) {
+			gb_connection_err(connection,
+					  "Bufferless transfer, length %u\n",
+					  xfer->len);
+			return NULL;
+		}
+
+		if (xfer->tx_buf)
+			tx_size += xfer->len;
+		if (xfer->rx_buf)
+			rx_size += xfer->len;
+
+		*total_len += xfer->len;
+		count++;
+	}
+
+	/* Too many transfers ? */
+	if (count > (u32)U16_MAX) {
+		gb_connection_err(connection, "transfer count (%u) too big",
+				  count);
+		return NULL;
+	}
+
+	/*
+	 * In addition to space for all message descriptors we need
+	 * to have enough to hold all tx data.
+	 */
+	request_size = sizeof(*request);
+	request_size += count * sizeof(*gb_xfer);
+	request_size += tx_size;
+
+	/* Response consists only of incoming data */
+	operation = gb_operation_create(connection, GB_SPI_TYPE_TRANSFER,
+					request_size, rx_size);
+	if (!operation)
+		return NULL;
+
+	request = operation->request->payload;
+	request->count = count;
+	request->mode = dev->mode;
+	request->chip_select = dev->chip_select;
+
+	gb_xfer = &request->transfers[0];
+	tx_data = gb_xfer + count;	/* place tx data after last gb_xfer */
+
+	/* Fill in the transfers array */
+	list_for_each_entry(xfer, &msg->transfers, transfer_list) {
+		gb_xfer->speed_hz = cpu_to_le16(xfer->speed_hz);
+		gb_xfer->len = cpu_to_le32(xfer->len);
+		gb_xfer->delay_usecs = cpu_to_le16(xfer->delay_usecs);
+		gb_xfer->cs_change = xfer->cs_change;
+		gb_xfer->bits_per_word = xfer->bits_per_word;
+		gb_xfer++;
+
+		/* Copy tx data */
+		if (xfer->tx_buf) {
+			memcpy(tx_data, xfer->tx_buf, xfer->len);
+			tx_data += xfer->len;
+		}
+	}
+
+	return operation;
+}
+
+static void gb_spi_decode_response(struct spi_message *msg,
+				   struct gb_spi_transfer_response *response)
+{
+	struct spi_transfer *xfer;
+	void *rx_data = response->data;
+
+	list_for_each_entry(xfer, &msg->transfers, transfer_list) {
+		/* Copy rx data */
+		if (xfer->rx_buf) {
+			memcpy(xfer->rx_buf, rx_data, xfer->len);
+			rx_data += xfer->len;
+		}
+	}
+}
+
+static int gb_spi_transfer_one_message(struct spi_master *master,
+				       struct spi_message *msg)
+{
+	struct gb_spi *spi = spi_master_get_devdata(master);
+	struct gb_connection *connection = spi->connection;
+	struct gb_spi_transfer_response *response;
+	struct gb_operation *operation;
+	u32 len = 0;
+	int ret;
+
+	operation = gb_spi_operation_create(connection, msg, &len);
+	if (!operation)
+		return -ENOMEM;
+
+	ret = gb_operation_request_send_sync(operation);
+	if (!ret) {
+		response = operation->response->payload;
+		if (response)
+			gb_spi_decode_response(msg, response);
+	} else {
+		pr_err("transfer operation failed (%d)\n", ret);
+	}
+	gb_operation_destroy(operation);
+
+	msg->actual_length = len;
+	msg->status = 0;
+	spi_finalize_current_message(master);
+
+	return ret;
+}
+
+static int gb_spi_setup(struct spi_device *spi)
+{
+	/* Nothing to do for now */
+	return 0;
+}
+
+static void gb_spi_cleanup(struct spi_device *spi)
+{
+	/* Nothing to do for now */
+}
+
+
+/* Routines to get controller infomation */
+
+/* Define get_version() routine */
+define_get_version(gb_spi, SPI);
+
+/*
+ * Map Greybus spi mode bits/flags/bpw into Linux ones.
+ * All bits are same for now and so these macro's return same values.
+ */
+#define gb_spi_mode_map(mode) mode
+#define gb_spi_flags_map(flags) flags
+
+static int gb_spi_mode_operation(struct gb_spi *spi)
+{
+	struct gb_spi_mode_response response;
+	u16 mode;
+	int ret;
+
+	ret = gb_operation_sync(spi->connection, GB_SPI_TYPE_MODE,
+				NULL, 0, &response, sizeof(response));
+	if (ret)
+		return ret;
+
+	mode = le16_to_cpu(response.mode);
+	spi->mode = gb_spi_mode_map(mode);
+
+	return 0;
+}
+
+static int gb_spi_flags_operation(struct gb_spi *spi)
+{
+	struct gb_spi_flags_response response;
+	u16 flags;
+	int ret;
+
+	ret = gb_operation_sync(spi->connection, GB_SPI_TYPE_FLAGS,
+				NULL, 0, &response, sizeof(response));
+	if (ret)
+		return ret;
+
+	flags = le16_to_cpu(response.flags);
+	spi->flags = gb_spi_flags_map(flags);
+
+	return 0;
+}
+
+static int gb_spi_bpw_operation(struct gb_spi *spi)
+{
+	struct gb_spi_bpw_response response;
+	int ret;
+
+	ret = gb_operation_sync(spi->connection, GB_SPI_TYPE_BITS_PER_WORD_MASK,
+				NULL, 0, &response, sizeof(response));
+	if (ret)
+		return ret;
+
+	spi->bits_per_word_mask = le32_to_cpu(response.bits_per_word_mask);
+
+	return 0;
+}
+
+static int gb_spi_chipselect_operation(struct gb_spi *spi)
+{
+	struct gb_spi_chipselect_response response;
+	int ret;
+
+	ret = gb_operation_sync(spi->connection, GB_SPI_TYPE_NUM_CHIPSELECT,
+				NULL, 0, &response, sizeof(response));
+	if (ret)
+		return ret;
+
+	spi->num_chipselect = le32_to_cpu(response.num_chipselect);
+
+	return 0;
+}
+
+/*
+ * Initialize the spi device. This includes verifying we can support it (based
+ * on the protocol version it advertises). If that's OK, we get and cached its
+ * mode bits & flags.
+ */
+static int gb_spi_init(struct gb_spi *spi)
+{
+	int ret;
+
+	/* First thing we need to do is check the version */
+	ret = get_version(spi);
+	if (ret)
+		return ret;
+
+	/* mode never changes, just get it once */
+	ret = gb_spi_mode_operation(spi);
+	if (ret)
+		return ret;
+
+	/* flags never changes, just get it once */
+	ret = gb_spi_flags_operation(spi);
+	if (ret)
+		return ret;
+
+	/* total number of chipselects never changes, just get it once */
+	ret = gb_spi_chipselect_operation(spi);
+	if (ret)
+		return ret;
+
+	/* bits-per-word-mask never changes, just get it once */
+	return gb_spi_bpw_operation(spi);
+}
+
+static int gb_spi_connection_init(struct gb_connection *connection)
+{
+	struct gb_spi *spi;
+	struct spi_master *master;
+	int ret;
+
+	/* Allocate master with space for data */
+	master = spi_alloc_master(&connection->dev, sizeof(*spi));
+	if (!master) {
+		gb_connection_err(connection, "cannot alloc SPI master\n");
+		return -ENOMEM;
+	}
+
+	spi = spi_master_get_devdata(master);
+	spi->connection = connection;
+	connection->private = master;
+
+	ret = gb_spi_init(spi);
+	if (ret)
+		goto out_err;
+
+	master->bus_num = 0;		/* How do we get controller id here? */
+	master->num_chipselect = spi->num_chipselect;
+	master->mode_bits = spi->mode;
+	master->flags = spi->flags;
+	master->bits_per_word_mask = spi->bits_per_word_mask;
+
+	/* Attach methods */
+	master->cleanup = gb_spi_cleanup;
+	master->setup = gb_spi_setup;
+	master->transfer_one_message = gb_spi_transfer_one_message;
+
+	ret = spi_register_master(master);
+	if (!ret)
+		return 0;
+
+out_err:
+	spi_master_put(master);
+
+	return ret;
+}
+
+static void gb_spi_connection_exit(struct gb_connection *connection)
+{
+	struct spi_master *master = connection->private;
+
+	spi_unregister_master(master);
+}
+
+static struct gb_protocol spi_protocol = {
+	.name			= "spi",
+	.id			= GREYBUS_PROTOCOL_SPI,
+	.major			= 0,
+	.minor			= 1,
+	.connection_init	= gb_spi_connection_init,
+	.connection_exit	= gb_spi_connection_exit,
+	.request_recv		= NULL,
+};
+
+int gb_spi_protocol_init(void)
+{
+	return gb_protocol_register(&spi_protocol);
+}
+
+void gb_spi_protocol_exit(void)
+{
+	gb_protocol_deregister(&spi_protocol);
+}
