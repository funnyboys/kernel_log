commit ec0ad868173da8a75121f9dc116a5d5478ff614d
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Sun Aug 25 07:54:27 2019 +0200

    staging: greybus: move core include files to include/linux/greybus/
    
    With the goal of moving the core of the greybus code out of staging, the
    include files need to be moved to include/linux/greybus.h and
    include/linux/greybus/
    
    Cc: Vaibhav Hiremath <hvaibhav.linux@gmail.com>
    Cc: Johan Hovold <johan@kernel.org>
    Cc: Vaibhav Agarwal <vaibhav.sr@gmail.com>
    Cc: Rui Miguel Silva <rmfrfs@gmail.com>
    Cc: David Lin <dtwlin@gmail.com>
    Cc: "Bryan O'Donoghue" <pure.logic@nexus-software.ie>
    Cc: greybus-dev@lists.linaro.org
    Cc: devel@driverdev.osuosl.org
    Acked-by: Mark Greer <mgreer@animalcreek.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Acked-by: Alex Elder <elder@kernel.org>
    Link: https://lore.kernel.org/r/20190825055429.18547-8-gregkh@linuxfoundation.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/fw-management.c b/drivers/staging/greybus/fw-management.c
index 71aec14f8181..687c6405c65b 100644
--- a/drivers/staging/greybus/fw-management.c
+++ b/drivers/staging/greybus/fw-management.c
@@ -13,10 +13,10 @@
 #include <linux/idr.h>
 #include <linux/ioctl.h>
 #include <linux/uaccess.h>
+#include <linux/greybus.h>
 
 #include "firmware.h"
 #include "greybus_firmware.h"
-#include "greybus.h"
 
 #define FW_MGMT_TIMEOUT_MS		1000
 

commit 863dbc52e7f0e5acd7b4883f3933543a81c474c7
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Nov 7 14:58:42 2017 +0100

    staging: greybus: Remove redundant license text
    
    Now that the SPDX tag is in all greybus files, that identifies the
    license in a specific and legally-defined manner.  So the extra GPL text
    wording can be removed as it is no longer needed at all.
    
    This is done on a quest to remove the 700+ different ways that files in
    the kernel describe the GPL license text.  And there's unneeded stuff
    like the address (sometimes incorrect) for the FSF which is never
    needed.
    
    No copyright headers or other non-license-description text was removed.
    
    Cc: Vaibhav Hiremath <hvaibhav.linux@gmail.com>
    Reviewed-by: Alex Elder <elder@linaro.org>
    Acked-by: Vaibhav Agarwal <vaibhav.sr@gmail.com>
    Acked-by: David Lin <dtwlin@gmail.com>
    Acked-by: Johan Hovold <johan@kernel.org>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Acked-by: Mark Greer <mgreer@animalcreek.com>
    Acked-by: Rui Miguel Silva <rmfrfs@gmail.com>
    Acked-by: "Bryan O'Donoghue" <pure.logic@nexus-software.ie>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/fw-management.c b/drivers/staging/greybus/fw-management.c
index 768badb754f9..71aec14f8181 100644
--- a/drivers/staging/greybus/fw-management.c
+++ b/drivers/staging/greybus/fw-management.c
@@ -4,8 +4,6 @@
  *
  * Copyright 2016 Google Inc.
  * Copyright 2016 Linaro Ltd.
- *
- * Released under the GPLv2 only.
  */
 
 #include <linux/cdev.h>

commit eb50fd3a22c770f36be275295b782f3ea52e3215
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Nov 7 14:58:41 2017 +0100

    staging: greybus: add SPDX identifiers to all greybus driver files
    
    It's good to have SPDX identifiers in all files to make it easier to
    audit the kernel tree for correct licenses.
    
    Update the drivers/staging/greybus files files with the correct SPDX
    license identifier based on the license text in the file itself.  The
    SPDX identifier is a legally binding shorthand, which can be used
    instead of the full boiler plate text.
    
    This work is based on a script and data from Thomas Gleixner, Philippe
    Ombredanne, and Kate Stewart.
    
    Cc: Vaibhav Hiremath <hvaibhav.linux@gmail.com>
    Cc: "Bryan O'Donoghue" <pure.logic@nexus-software.ie>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: Philippe Ombredanne <pombredanne@nexb.com>
    Acked-by: Vaibhav Agarwal <vaibhav.sr@gmail.com>
    Acked-by: David Lin <dtwlin@gmail.com>
    Reviewed-by: Alex Elder <elder@linaro.org>
    Acked-by: Johan Hovold <johan@kernel.org>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Acked-by: Mark Greer <mgreer@animalcreek.com>
    Acked-by: Rui Miguel Silva <rmfrfs@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/fw-management.c b/drivers/staging/greybus/fw-management.c
index 3cd6cf0a656b..768badb754f9 100644
--- a/drivers/staging/greybus/fw-management.c
+++ b/drivers/staging/greybus/fw-management.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * Greybus Firmware Management Protocol Driver.
  *

commit b2abeaa10d5711e7730bb07120dd60ae27d7b930
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Thu Aug 11 13:27:23 2016 -0700

    greybus: firmware: s/_LEN/_SIZE
    
    Alex Elder pointed out that the macros also count the trailing NULL
    ('\0') character and so it should be using SIZE instead of LEN.
    
    This patch makes that change.
    
    Reported-by: Alex Elder <alex.elder@linaro.org>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/fw-management.c b/drivers/staging/greybus/fw-management.c
index 7cbe71d581ac..3cd6cf0a656b 100644
--- a/drivers/staging/greybus/fw-management.c
+++ b/drivers/staging/greybus/fw-management.c
@@ -122,16 +122,16 @@ static int fw_mgmt_interface_fw_version_operation(struct fw_mgmt *fw_mgmt,
 	fw_info->minor = le16_to_cpu(response.minor);
 
 	strncpy(fw_info->firmware_tag, response.firmware_tag,
-		GB_FIRMWARE_TAG_MAX_LEN);
+		GB_FIRMWARE_TAG_MAX_SIZE);
 
 	/*
 	 * The firmware-tag should be NULL terminated, otherwise throw error but
 	 * don't fail.
 	 */
-	if (fw_info->firmware_tag[GB_FIRMWARE_TAG_MAX_LEN - 1] != '\0') {
+	if (fw_info->firmware_tag[GB_FIRMWARE_TAG_MAX_SIZE - 1] != '\0') {
 		dev_err(fw_mgmt->parent,
 			"fw-version: firmware-tag is not NULL terminated\n");
-		fw_info->firmware_tag[GB_FIRMWARE_TAG_MAX_LEN - 1] = '\0';
+		fw_info->firmware_tag[GB_FIRMWARE_TAG_MAX_SIZE - 1] = '\0';
 	}
 
 	return 0;
@@ -151,13 +151,13 @@ static int fw_mgmt_load_and_validate_operation(struct fw_mgmt *fw_mgmt,
 	}
 
 	request.load_method = load_method;
-	strncpy(request.firmware_tag, tag, GB_FIRMWARE_TAG_MAX_LEN);
+	strncpy(request.firmware_tag, tag, GB_FIRMWARE_TAG_MAX_SIZE);
 
 	/*
 	 * The firmware-tag should be NULL terminated, otherwise throw error and
 	 * fail.
 	 */
-	if (request.firmware_tag[GB_FIRMWARE_TAG_MAX_LEN - 1] != '\0') {
+	if (request.firmware_tag[GB_FIRMWARE_TAG_MAX_SIZE - 1] != '\0') {
 		dev_err(fw_mgmt->parent, "load-and-validate: firmware-tag is not NULL terminated\n");
 		return -EINVAL;
 	}
@@ -249,13 +249,13 @@ static int fw_mgmt_backend_fw_version_operation(struct fw_mgmt *fw_mgmt,
 	int ret;
 
 	strncpy(request.firmware_tag, fw_info->firmware_tag,
-		GB_FIRMWARE_TAG_MAX_LEN);
+		GB_FIRMWARE_TAG_MAX_SIZE);
 
 	/*
 	 * The firmware-tag should be NULL terminated, otherwise throw error and
 	 * fail.
 	 */
-	if (request.firmware_tag[GB_FIRMWARE_TAG_MAX_LEN - 1] != '\0') {
+	if (request.firmware_tag[GB_FIRMWARE_TAG_MAX_SIZE - 1] != '\0') {
 		dev_err(fw_mgmt->parent, "backend-version: firmware-tag is not NULL terminated\n");
 		return -EINVAL;
 	}
@@ -302,13 +302,13 @@ static int fw_mgmt_backend_fw_update_operation(struct fw_mgmt *fw_mgmt,
 	struct gb_fw_mgmt_backend_fw_update_request request;
 	int ret;
 
-	strncpy(request.firmware_tag, tag, GB_FIRMWARE_TAG_MAX_LEN);
+	strncpy(request.firmware_tag, tag, GB_FIRMWARE_TAG_MAX_SIZE);
 
 	/*
 	 * The firmware-tag should be NULL terminated, otherwise throw error and
 	 * fail.
 	 */
-	if (request.firmware_tag[GB_FIRMWARE_TAG_MAX_LEN - 1] != '\0') {
+	if (request.firmware_tag[GB_FIRMWARE_TAG_MAX_SIZE - 1] != '\0') {
 		dev_err(fw_mgmt->parent, "backend-update: firmware-tag is not NULL terminated\n");
 		return -EINVAL;
 	}

commit 5e10f0047a1b79e6c8ac1ee0e9a0165e7d0bc7d6
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Mon Jul 25 14:38:08 2016 -0700

    greybus: firmware: Add 'status' byte to backend fw version response
    
    The backend processor may not be ready to return the version of firmware
    it is running by the time AP requests for it. The greybus specification
    is updated to return 1-byte 'status' to return the error type, RETRY is
    one of them.
    
    This patch implements that in greybus now.
    
    Note that the version structure was common across interface and backend
    version requests earlier, but that is changing as well.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/fw-management.c b/drivers/staging/greybus/fw-management.c
index 642a393bd15f..7cbe71d581ac 100644
--- a/drivers/staging/greybus/fw-management.c
+++ b/drivers/staging/greybus/fw-management.c
@@ -103,7 +103,7 @@ static struct fw_mgmt *get_fw_mgmt(struct cdev *cdev)
 }
 
 static int fw_mgmt_interface_fw_version_operation(struct fw_mgmt *fw_mgmt,
-		struct fw_mgmt_ioc_get_fw *fw_info)
+		struct fw_mgmt_ioc_get_intf_version *fw_info)
 {
 	struct gb_connection *connection = fw_mgmt->connection;
 	struct gb_fw_mgmt_interface_fw_version_response response;
@@ -241,7 +241,7 @@ static int fw_mgmt_interface_fw_loaded_operation(struct gb_operation *op)
 }
 
 static int fw_mgmt_backend_fw_version_operation(struct fw_mgmt *fw_mgmt,
-		struct fw_mgmt_ioc_get_fw *fw_info)
+		struct fw_mgmt_ioc_get_backend_version *fw_info)
 {
 	struct gb_connection *connection = fw_mgmt->connection;
 	struct gb_fw_mgmt_backend_fw_version_request request;
@@ -269,8 +269,29 @@ static int fw_mgmt_backend_fw_version_operation(struct fw_mgmt *fw_mgmt,
 		return ret;
 	}
 
-	fw_info->major = le16_to_cpu(response.major);
-	fw_info->minor = le16_to_cpu(response.minor);
+	fw_info->status = response.status;
+
+	/* Reset version as that should be non-zero only for success case */
+	fw_info->major = 0;
+	fw_info->minor = 0;
+
+	switch (fw_info->status) {
+	case GB_FW_BACKEND_VERSION_STATUS_SUCCESS:
+		fw_info->major = le16_to_cpu(response.major);
+		fw_info->minor = le16_to_cpu(response.minor);
+		break;
+	case GB_FW_BACKEND_VERSION_STATUS_NOT_AVAILABLE:
+	case GB_FW_BACKEND_VERSION_STATUS_RETRY:
+		break;
+	case GB_FW_BACKEND_VERSION_STATUS_NOT_SUPPORTED:
+		dev_err(fw_mgmt->parent,
+			"Firmware with tag %s is not supported by Interface\n",
+			fw_info->firmware_tag);
+		break;
+	default:
+		dev_err(fw_mgmt->parent, "Invalid status received: %u\n",
+			fw_info->status);
+	}
 
 	return 0;
 }
@@ -387,7 +408,8 @@ static int fw_mgmt_release(struct inode *inode, struct file *file)
 static int fw_mgmt_ioctl(struct fw_mgmt *fw_mgmt, unsigned int cmd,
 			 void __user *buf)
 {
-	struct fw_mgmt_ioc_get_fw fw_info;
+	struct fw_mgmt_ioc_get_intf_version intf_fw_info;
+	struct fw_mgmt_ioc_get_backend_version backend_fw_info;
 	struct fw_mgmt_ioc_intf_load_and_validate intf_load;
 	struct fw_mgmt_ioc_backend_fw_update backend_update;
 	unsigned int timeout;
@@ -399,23 +421,27 @@ static int fw_mgmt_ioctl(struct fw_mgmt *fw_mgmt, unsigned int cmd,
 
 	switch (cmd) {
 	case FW_MGMT_IOC_GET_INTF_FW:
-		ret = fw_mgmt_interface_fw_version_operation(fw_mgmt, &fw_info);
+		ret = fw_mgmt_interface_fw_version_operation(fw_mgmt,
+							     &intf_fw_info);
 		if (ret)
 			return ret;
 
-		if (copy_to_user(buf, &fw_info, sizeof(fw_info)))
+		if (copy_to_user(buf, &intf_fw_info, sizeof(intf_fw_info)))
 			return -EFAULT;
 
 		return 0;
 	case FW_MGMT_IOC_GET_BACKEND_FW:
-		if (copy_from_user(&fw_info, buf, sizeof(fw_info)))
+		if (copy_from_user(&backend_fw_info, buf,
+				   sizeof(backend_fw_info)))
 			return -EFAULT;
 
-		ret = fw_mgmt_backend_fw_version_operation(fw_mgmt, &fw_info);
+		ret = fw_mgmt_backend_fw_version_operation(fw_mgmt,
+							   &backend_fw_info);
 		if (ret)
 			return ret;
 
-		if (copy_to_user(buf, &fw_info, sizeof(fw_info)))
+		if (copy_to_user(buf, &backend_fw_info,
+				 sizeof(backend_fw_info)))
 			return -EFAULT;
 
 		return 0;

commit 911415ae6ee29cb76e018e8df8715c743a3a3d63
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Mon Jul 25 14:38:07 2016 -0700

    greybus: firmware: Add new status types for backend updated request
    
    The specification got updated with two more status values, add their
    support in greybus.
    
    As retry isn't really an error, skip printing error messages for it as
    well.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/fw-management.c b/drivers/staging/greybus/fw-management.c
index 2efe65cfd612..642a393bd15f 100644
--- a/drivers/staging/greybus/fw-management.c
+++ b/drivers/staging/greybus/fw-management.c
@@ -350,7 +350,8 @@ static int fw_mgmt_backend_fw_updated_operation(struct gb_operation *op)
 	fw_mgmt->backend_fw_request_id = 0;
 	fw_mgmt->backend_fw_status = request->status;
 
-	if (fw_mgmt->backend_fw_status != GB_FW_BACKEND_FW_STATUS_SUCCESS)
+	if ((fw_mgmt->backend_fw_status != GB_FW_BACKEND_FW_STATUS_SUCCESS) &&
+	    (fw_mgmt->backend_fw_status != GB_FW_BACKEND_FW_STATUS_RETRY))
 		dev_err(fw_mgmt->parent,
 			"failed to load backend firmware: %02x\n",
 			fw_mgmt->backend_fw_status);

commit c57fbb404af28eda44d0590ede8812b889a89b8c
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Tue Jul 26 13:41:02 2016 -0700

    greybus: firmware: Add runtime PM support
    
    This patch implements runtime PM support for firmware management bundle.
    This guarantees that the bundle will be active, while the AP or the
    Module is trying to exchange any operations over any of the CPorts.
    
    - Firmware Management CPort:
    
      Runtime PM get/put calls are placed around the ioctl calls, which are
      all implemented as blocking ioctls.
    
    - Component Authentication CPort:
    
      Runtime PM get/put calls are placed around the ioctl calls, which are
      all implemented as blocking ioctls.
    
    - SPI:
    
      Uses the interface provided by spilib.c and runtime PM get/put are
      called around connection usage.
    
    - firmware-download:
    
      This is the most tricky one. All operations on this CPort are
      initiated from the Module and not from the AP. And the AP needs to do
      runtime_pm_get() before any request is received over this CPort.
    
      The module doesn't send any request over this connection, unless the
      AP has requested the module over firmware management CPort to download
      a firmware package over firmware download CPort.
    
      And so the runtime PM get/put calls around the ioctls in
      fw-management.c are sufficient to handle the firmware management CPort
      as well.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/fw-management.c b/drivers/staging/greybus/fw-management.c
index ccd9d7c91416..2efe65cfd612 100644
--- a/drivers/staging/greybus/fw-management.c
+++ b/drivers/staging/greybus/fw-management.c
@@ -507,6 +507,7 @@ static long fw_mgmt_ioctl_unlocked(struct file *file, unsigned int cmd,
 				   unsigned long arg)
 {
 	struct fw_mgmt *fw_mgmt = file->private_data;
+	struct gb_bundle *bundle = fw_mgmt->connection->bundle;
 	int ret = -ENODEV;
 
 	/*
@@ -522,8 +523,13 @@ static long fw_mgmt_ioctl_unlocked(struct file *file, unsigned int cmd,
 	 * new operations.
 	 */
 	mutex_lock(&fw_mgmt->mutex);
-	if (!fw_mgmt->disabled)
-		ret = fw_mgmt_ioctl(fw_mgmt, cmd, (void __user *)arg);
+	if (!fw_mgmt->disabled) {
+		ret = gb_pm_runtime_get_sync(bundle);
+		if (!ret) {
+			ret = fw_mgmt_ioctl(fw_mgmt, cmd, (void __user *)arg);
+			gb_pm_runtime_put_autosuspend(bundle);
+		}
+	}
 	mutex_unlock(&fw_mgmt->mutex);
 
 	return ret;

commit 4ee48a5ecb7a3af272ac2c6cd6a0865b95a3d5f2
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Wed Jun 15 15:58:22 2016 +0530

    greybus: firmware: prefix char-device with 'gb-'
    
    This will make it consistent with any other character devices we have
    for greybus and let us identify greybus character devices easily.
    
    Compiled tested only.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/fw-management.c b/drivers/staging/greybus/fw-management.c
index c9c28fc15492..ccd9d7c91416 100644
--- a/drivers/staging/greybus/fw-management.c
+++ b/drivers/staging/greybus/fw-management.c
@@ -599,7 +599,7 @@ int gb_fw_mgmt_connection_init(struct gb_connection *connection)
 	/* Add a soft link to the previously added char-dev within the bundle */
 	fw_mgmt->class_device = device_create(fw_mgmt_class, fw_mgmt->parent,
 					      fw_mgmt->dev_num, NULL,
-					      "fw-mgmt-%d", minor);
+					      "gb-fw-mgmt-%d", minor);
 	if (IS_ERR(fw_mgmt->class_device)) {
 		ret = PTR_ERR(fw_mgmt->class_device);
 		goto err_del_cdev;

commit 68ee90c29ea4068e03ad637af07f6ad7c27da544
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Mon May 30 14:32:09 2016 +0530

    greybus: Add comment about the mode_switch_started flag
    
    Add a comment to describe the purpose of the flag.
    
    Suggested-by: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Reviewed-by: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/fw-management.c b/drivers/staging/greybus/fw-management.c
index 22dcad2ebc15..c9c28fc15492 100644
--- a/drivers/staging/greybus/fw-management.c
+++ b/drivers/staging/greybus/fw-management.c
@@ -482,6 +482,11 @@ static int fw_mgmt_ioctl(struct fw_mgmt *fw_mgmt, unsigned int cmd,
 			return -EPERM;
 		}
 
+		/*
+		 * Disallow new ioctls as the fw-core bundle driver is going to
+		 * get disconnected soon and the character device will get
+		 * removed.
+		 */
 		fw_mgmt->mode_switch_started = true;
 
 		ret = gb_interface_request_mode_switch(fw_mgmt->connection->intf);

commit c92c1d026b1e13f20fee3350975a4986608ff84a
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Mon May 30 13:05:08 2016 +0530

    greybus: fw-mgmt: Add hooks to do mode-switch
    
    This is the last step to required to finish the mode switch story.  That
    is, call the hook provided by Interface layer to accomplish mode switch.
    
    Tested on EVT 1.5 with gpbridge-test module.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Tested-by: Karthik Ravi Shankar <karthikrs@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/fw-management.c b/drivers/staging/greybus/fw-management.c
index da36de313a2c..22dcad2ebc15 100644
--- a/drivers/staging/greybus/fw-management.c
+++ b/drivers/staging/greybus/fw-management.c
@@ -484,7 +484,14 @@ static int fw_mgmt_ioctl(struct fw_mgmt *fw_mgmt, unsigned int cmd,
 
 		fw_mgmt->mode_switch_started = true;
 
-		/* FIXME: Initiate mode-switch from here */
+		ret = gb_interface_request_mode_switch(fw_mgmt->connection->intf);
+		if (ret) {
+			dev_err(fw_mgmt->parent, "Mode-switch failed: %d\n",
+				ret);
+			fw_mgmt->mode_switch_started = false;
+			return ret;
+		}
+
 		return 0;
 	default:
 		return -ENOTTY;

commit d72b5810cba5fd6f77f22742df1cb4a3c473cd6b
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Thu May 19 18:26:27 2016 +0530

    greybus: fw-management: Fix error message's text
    
    Just reword it to make it sound better.
    
    Compile tested.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Reviewed-by: Johan Hovold <johan@hovoldconsulting.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/fw-management.c b/drivers/staging/greybus/fw-management.c
index 96758f417d7b..da36de313a2c 100644
--- a/drivers/staging/greybus/fw-management.c
+++ b/drivers/staging/greybus/fw-management.c
@@ -352,7 +352,7 @@ static int fw_mgmt_backend_fw_updated_operation(struct gb_operation *op)
 
 	if (fw_mgmt->backend_fw_status != GB_FW_BACKEND_FW_STATUS_SUCCESS)
 		dev_err(fw_mgmt->parent,
-			"failed to backend load firmware, status:%02x\n",
+			"failed to load backend firmware: %02x\n",
 			fw_mgmt->backend_fw_status);
 
 	complete(&fw_mgmt->completion);

commit 79b140fe2b6f2db8c4a4a45bde6065fc34b24e77
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Mon May 16 07:49:43 2016 +0530

    greybus: fw-management: Fix 'make check' warnings
    
    Fix below warnings observed with 'make check'.
    
    ~/ara/greybus/fw-management.c:438:33: warning: incorrect type in assignment (different base types)
    ~/ara/greybus/fw-management.c:438:33:    expected unsigned short [unsigned] [addressable] [assigned] [usertype] major
    ~/ara/greybus/fw-management.c:438:33:    got restricted __le16 [usertype] <noident>
    ~/ara/greybus/fw-management.c:439:33: warning: incorrect type in assignment (different base types)
    ~/ara/greybus/fw-management.c:439:33:    expected unsigned short [unsigned] [addressable] [assigned] [usertype] minor
    ~/ara/greybus/fw-management.c:439:33:    got restricted __le16 [usertype] <noident>
    
    Reported-by: Greg Kroah-Hartman <gregkh@google.com>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Reviewed-by: Alex Elder <elder@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/fw-management.c b/drivers/staging/greybus/fw-management.c
index 0c73f1e5cab3..96758f417d7b 100644
--- a/drivers/staging/greybus/fw-management.c
+++ b/drivers/staging/greybus/fw-management.c
@@ -434,8 +434,8 @@ static int fw_mgmt_ioctl(struct fw_mgmt *fw_mgmt, unsigned int cmd,
 		}
 
 		intf_load.status = fw_mgmt->intf_fw_status;
-		intf_load.major = cpu_to_le16(fw_mgmt->intf_fw_major);
-		intf_load.minor = cpu_to_le16(fw_mgmt->intf_fw_minor);
+		intf_load.major = fw_mgmt->intf_fw_major;
+		intf_load.minor = fw_mgmt->intf_fw_minor;
 
 		if (copy_to_user(buf, &intf_load, sizeof(intf_load)))
 			return -EFAULT;

commit 96ba6740099b1f1a2732c86204d2931cda11d638
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Sat May 14 23:42:23 2016 +0530

    greybus: fw-management: Free fw-mgmt only after all users are gone
    
    The fw-management driver rightly destroys the char device on
    connection-exit, but that doesn't guarantee that all of the users of the
    device are gone.
    
    Userspace may still be holding file-descriptor of the char device and
    can initiate new ioctl operations. And that *will* lead to kernel crash.
    
    To avoid this issue, manage struct users with kref, manage a list of
    'struct fw-mgmt' and start using the structure only after getting its
    kref incremented.
    
    The important part is the routine get_fw_mgmt(), which increments the
    reference to the struct before returning it to the caller. The list of
    fw-mgmt structs in protected with a mutex to avoid any races around
    that.
    
    The kref is incremented once the char device is opened and dropped only
    when it is closed.
    
    Reported-by: Johan Hovold <johan@hovoldconsulting.com>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/fw-management.c b/drivers/staging/greybus/fw-management.c
index 7c2226ab5d5c..0c73f1e5cab3 100644
--- a/drivers/staging/greybus/fw-management.c
+++ b/drivers/staging/greybus/fw-management.c
@@ -24,6 +24,9 @@
 struct fw_mgmt {
 	struct device		*parent;
 	struct gb_connection	*connection;
+	struct kref		kref;
+	struct list_head	node;
+
 	/* Common id-map for interface and backend firmware requests */
 	struct ida		id_map;
 	struct mutex		mutex;
@@ -32,6 +35,7 @@ struct fw_mgmt {
 	struct device		*class_device;
 	dev_t			dev_num;
 	unsigned int		timeout_jiffies;
+	bool			disabled; /* connection getting disabled */
 
 	/* Interface Firmware specific fields */
 	bool			mode_switch_started;
@@ -55,6 +59,48 @@ struct fw_mgmt {
 static struct class *fw_mgmt_class;
 static dev_t fw_mgmt_dev_num;
 static DEFINE_IDA(fw_mgmt_minors_map);
+static LIST_HEAD(fw_mgmt_list);
+static DEFINE_MUTEX(list_mutex);
+
+static void fw_mgmt_kref_release(struct kref *kref)
+{
+	struct fw_mgmt *fw_mgmt = container_of(kref, struct fw_mgmt, kref);
+
+	ida_destroy(&fw_mgmt->id_map);
+	kfree(fw_mgmt);
+}
+
+/*
+ * All users of fw_mgmt take a reference (from within list_mutex lock), before
+ * they get a pointer to play with. And the structure will be freed only after
+ * the last user has put the reference to it.
+ */
+static void put_fw_mgmt(struct fw_mgmt *fw_mgmt)
+{
+	kref_put(&fw_mgmt->kref, fw_mgmt_kref_release);
+}
+
+/* Caller must call put_fw_mgmt() after using struct fw_mgmt */
+static struct fw_mgmt *get_fw_mgmt(struct cdev *cdev)
+{
+	struct fw_mgmt *fw_mgmt;
+
+	mutex_lock(&list_mutex);
+
+	list_for_each_entry(fw_mgmt, &fw_mgmt_list, node) {
+		if (&fw_mgmt->cdev == cdev) {
+			kref_get(&fw_mgmt->kref);
+			goto unlock;
+		}
+	}
+
+	fw_mgmt = NULL;
+
+unlock:
+	mutex_unlock(&list_mutex);
+
+	return fw_mgmt;
+}
 
 static int fw_mgmt_interface_fw_version_operation(struct fw_mgmt *fw_mgmt,
 		struct fw_mgmt_ioc_get_fw *fw_info)
@@ -318,10 +364,22 @@ static int fw_mgmt_backend_fw_updated_operation(struct gb_operation *op)
 
 static int fw_mgmt_open(struct inode *inode, struct file *file)
 {
-	struct fw_mgmt *fw_mgmt = container_of(inode->i_cdev, struct fw_mgmt,
-					       cdev);
+	struct fw_mgmt *fw_mgmt = get_fw_mgmt(inode->i_cdev);
 
-	file->private_data = fw_mgmt;
+	/* fw_mgmt structure can't get freed until file descriptor is closed */
+	if (fw_mgmt) {
+		file->private_data = fw_mgmt;
+		return 0;
+	}
+
+	return -ENODEV;
+}
+
+static int fw_mgmt_release(struct inode *inode, struct file *file)
+{
+	struct fw_mgmt *fw_mgmt = file->private_data;
+
+	put_fw_mgmt(fw_mgmt);
 	return 0;
 }
 
@@ -437,18 +495,23 @@ static long fw_mgmt_ioctl_unlocked(struct file *file, unsigned int cmd,
 				   unsigned long arg)
 {
 	struct fw_mgmt *fw_mgmt = file->private_data;
-	int ret;
+	int ret = -ENODEV;
 
 	/*
-	 * Serialize ioctls
+	 * Serialize ioctls.
 	 *
 	 * We don't want the user to do few operations in parallel. For example,
 	 * updating Interface firmware in parallel for the same Interface. There
 	 * is no need to do things in parallel for speed and we can avoid having
-	 * complicated for now.
+	 * complicated code for now.
+	 *
+	 * This is also used to protect ->disabled, which is used to check if
+	 * the connection is getting disconnected, so that we don't start any
+	 * new operations.
 	 */
 	mutex_lock(&fw_mgmt->mutex);
-	ret = fw_mgmt_ioctl(fw_mgmt, cmd, (void __user *)arg);
+	if (!fw_mgmt->disabled)
+		ret = fw_mgmt_ioctl(fw_mgmt, cmd, (void __user *)arg);
 	mutex_unlock(&fw_mgmt->mutex);
 
 	return ret;
@@ -457,6 +520,7 @@ static long fw_mgmt_ioctl_unlocked(struct file *file, unsigned int cmd,
 static const struct file_operations fw_mgmt_fops = {
 	.owner		= THIS_MODULE,
 	.open		= fw_mgmt_open,
+	.release	= fw_mgmt_release,
 	.unlocked_ioctl	= fw_mgmt_ioctl_unlocked,
 };
 
@@ -496,10 +560,15 @@ int gb_fw_mgmt_connection_init(struct gb_connection *connection)
 	init_completion(&fw_mgmt->completion);
 	ida_init(&fw_mgmt->id_map);
 	mutex_init(&fw_mgmt->mutex);
+	kref_init(&fw_mgmt->kref);
+
+	mutex_lock(&list_mutex);
+	list_add(&fw_mgmt->node, &fw_mgmt_list);
+	mutex_unlock(&list_mutex);
 
 	ret = gb_connection_enable(connection);
 	if (ret)
-		goto err_destroy_ida;
+		goto err_list_del;
 
 	minor = ida_simple_get(&fw_mgmt_minors_map, 0, NUM_MINORS, GFP_KERNEL);
 	if (minor < 0) {
@@ -532,9 +601,12 @@ int gb_fw_mgmt_connection_init(struct gb_connection *connection)
 	ida_simple_remove(&fw_mgmt_minors_map, minor);
 err_connection_disable:
 	gb_connection_disable(connection);
-err_destroy_ida:
-	ida_destroy(&fw_mgmt->id_map);
-	kfree(fw_mgmt);
+err_list_del:
+	mutex_lock(&list_mutex);
+	list_del(&fw_mgmt->node);
+	mutex_unlock(&list_mutex);
+
+	put_fw_mgmt(fw_mgmt);
 
 	return ret;
 }
@@ -547,13 +619,33 @@ void gb_fw_mgmt_connection_exit(struct gb_connection *connection)
 		return;
 
 	fw_mgmt = gb_connection_get_data(connection);
+
 	device_destroy(fw_mgmt_class, fw_mgmt->dev_num);
 	cdev_del(&fw_mgmt->cdev);
 	ida_simple_remove(&fw_mgmt_minors_map, MINOR(fw_mgmt->dev_num));
+
+	/*
+	 * Disallow any new ioctl operations on the char device and wait for
+	 * existing ones to finish.
+	 */
+	mutex_lock(&fw_mgmt->mutex);
+	fw_mgmt->disabled = true;
+	mutex_unlock(&fw_mgmt->mutex);
+
+	/* All pending greybus operations should have finished by now */
 	gb_connection_disable(fw_mgmt->connection);
-	ida_destroy(&fw_mgmt->id_map);
 
-	kfree(fw_mgmt);
+	/* Disallow new users to get access to the fw_mgmt structure */
+	mutex_lock(&list_mutex);
+	list_del(&fw_mgmt->node);
+	mutex_unlock(&list_mutex);
+
+	/*
+	 * All current users of fw_mgmt would have taken a reference to it by
+	 * now, we can drop our reference and wait the last user will get
+	 * fw_mgmt freed.
+	 */
+	put_fw_mgmt(fw_mgmt);
 }
 
 int fw_mgmt_init(void)

commit 04f0e6ebd1a2ca3a1f1a356e9a07ef1797ef1b7c
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Sat May 14 23:42:22 2016 +0530

    greybus: fw-management: Add ioctl to initiate mode-switch
    
    Once the interface firmware is loaded successfully to a module,
    userspace can ask it to mode switch to the newly loaded firmware.
    
    This patch provides a new ioctl to initiate mode switch.
    
    Userspace can initiate a mode switch if it has previously loaded the
    interface firmware successfully, otherwise the firmware core rejects it.
    
    Also, once the mode-switch is initiated, disallow any more interactions
    from the userspace.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Tested-by: Karthik Ravi Shankar <karthikrs@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/fw-management.c b/drivers/staging/greybus/fw-management.c
index 2db5a11c5a1d..7c2226ab5d5c 100644
--- a/drivers/staging/greybus/fw-management.c
+++ b/drivers/staging/greybus/fw-management.c
@@ -34,6 +34,8 @@ struct fw_mgmt {
 	unsigned int		timeout_jiffies;
 
 	/* Interface Firmware specific fields */
+	bool			mode_switch_started;
+	bool			intf_fw_loaded;
 	u8			intf_fw_request_id;
 	u8			intf_fw_status;
 	u16			intf_fw_major;
@@ -123,6 +125,7 @@ static int fw_mgmt_load_and_validate_operation(struct fw_mgmt *fw_mgmt,
 	}
 
 	fw_mgmt->intf_fw_request_id = ret;
+	fw_mgmt->intf_fw_loaded = false;
 	request.request_id = ret;
 
 	ret = gb_operation_sync(fw_mgmt->connection,
@@ -183,6 +186,8 @@ static int fw_mgmt_interface_fw_loaded_operation(struct gb_operation *op)
 		dev_err(fw_mgmt->parent,
 			"failed to validate interface firmware, status:%02x\n",
 			fw_mgmt->intf_fw_status);
+	else
+		fw_mgmt->intf_fw_loaded = true;
 
 	complete(&fw_mgmt->completion);
 
@@ -329,6 +334,10 @@ static int fw_mgmt_ioctl(struct fw_mgmt *fw_mgmt, unsigned int cmd,
 	unsigned int timeout;
 	int ret;
 
+	/* Reject any operations after mode-switch has started */
+	if (fw_mgmt->mode_switch_started)
+		return -EBUSY;
+
 	switch (cmd) {
 	case FW_MGMT_IOC_GET_INTF_FW:
 		ret = fw_mgmt_interface_fw_version_operation(fw_mgmt, &fw_info);
@@ -407,6 +416,17 @@ static int fw_mgmt_ioctl(struct fw_mgmt *fw_mgmt, unsigned int cmd,
 
 		fw_mgmt->timeout_jiffies = msecs_to_jiffies(timeout);
 
+		return 0;
+	case FW_MGMT_IOC_MODE_SWITCH:
+		if (!fw_mgmt->intf_fw_loaded) {
+			dev_err(fw_mgmt->parent,
+				"Firmware not loaded for mode-switch\n");
+			return -EPERM;
+		}
+
+		fw_mgmt->mode_switch_started = true;
+
+		/* FIXME: Initiate mode-switch from here */
 		return 0;
 	default:
 		return -ENOTTY;

commit 013e665372733fafd08599f0fc58ff5f450e4694
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Sat May 14 23:42:21 2016 +0530

    greybus: fw-management: Add firmware-management protocol driver
    
    This patch adds Firmware Management Protocol support to firmware core,
    which allows the AP to manage firmware on an Interface.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Reviewed-by: Jun Li <li_jun@projectara.com>
    Tested-by: Karthik Ravi Shankar <karthikrs@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/fw-management.c b/drivers/staging/greybus/fw-management.c
new file mode 100644
index 000000000000..2db5a11c5a1d
--- /dev/null
+++ b/drivers/staging/greybus/fw-management.c
@@ -0,0 +1,564 @@
+/*
+ * Greybus Firmware Management Protocol Driver.
+ *
+ * Copyright 2016 Google Inc.
+ * Copyright 2016 Linaro Ltd.
+ *
+ * Released under the GPLv2 only.
+ */
+
+#include <linux/cdev.h>
+#include <linux/completion.h>
+#include <linux/firmware.h>
+#include <linux/fs.h>
+#include <linux/idr.h>
+#include <linux/ioctl.h>
+#include <linux/uaccess.h>
+
+#include "firmware.h"
+#include "greybus_firmware.h"
+#include "greybus.h"
+
+#define FW_MGMT_TIMEOUT_MS		1000
+
+struct fw_mgmt {
+	struct device		*parent;
+	struct gb_connection	*connection;
+	/* Common id-map for interface and backend firmware requests */
+	struct ida		id_map;
+	struct mutex		mutex;
+	struct completion	completion;
+	struct cdev		cdev;
+	struct device		*class_device;
+	dev_t			dev_num;
+	unsigned int		timeout_jiffies;
+
+	/* Interface Firmware specific fields */
+	u8			intf_fw_request_id;
+	u8			intf_fw_status;
+	u16			intf_fw_major;
+	u16			intf_fw_minor;
+
+	/* Backend Firmware specific fields */
+	u8			backend_fw_request_id;
+	u8			backend_fw_status;
+};
+
+/*
+ * Number of minor devices this driver supports.
+ * There will be exactly one required per Interface.
+ */
+#define NUM_MINORS		U8_MAX
+
+static struct class *fw_mgmt_class;
+static dev_t fw_mgmt_dev_num;
+static DEFINE_IDA(fw_mgmt_minors_map);
+
+static int fw_mgmt_interface_fw_version_operation(struct fw_mgmt *fw_mgmt,
+		struct fw_mgmt_ioc_get_fw *fw_info)
+{
+	struct gb_connection *connection = fw_mgmt->connection;
+	struct gb_fw_mgmt_interface_fw_version_response response;
+	int ret;
+
+	ret = gb_operation_sync(connection,
+				GB_FW_MGMT_TYPE_INTERFACE_FW_VERSION, NULL, 0,
+				&response, sizeof(response));
+	if (ret) {
+		dev_err(fw_mgmt->parent,
+			"failed to get interface firmware version (%d)\n", ret);
+		return ret;
+	}
+
+	fw_info->major = le16_to_cpu(response.major);
+	fw_info->minor = le16_to_cpu(response.minor);
+
+	strncpy(fw_info->firmware_tag, response.firmware_tag,
+		GB_FIRMWARE_TAG_MAX_LEN);
+
+	/*
+	 * The firmware-tag should be NULL terminated, otherwise throw error but
+	 * don't fail.
+	 */
+	if (fw_info->firmware_tag[GB_FIRMWARE_TAG_MAX_LEN - 1] != '\0') {
+		dev_err(fw_mgmt->parent,
+			"fw-version: firmware-tag is not NULL terminated\n");
+		fw_info->firmware_tag[GB_FIRMWARE_TAG_MAX_LEN - 1] = '\0';
+	}
+
+	return 0;
+}
+
+static int fw_mgmt_load_and_validate_operation(struct fw_mgmt *fw_mgmt,
+					       u8 load_method, const char *tag)
+{
+	struct gb_fw_mgmt_load_and_validate_fw_request request;
+	int ret;
+
+	if (load_method != GB_FW_LOAD_METHOD_UNIPRO &&
+	    load_method != GB_FW_LOAD_METHOD_INTERNAL) {
+		dev_err(fw_mgmt->parent,
+			"invalid load-method (%d)\n", load_method);
+		return -EINVAL;
+	}
+
+	request.load_method = load_method;
+	strncpy(request.firmware_tag, tag, GB_FIRMWARE_TAG_MAX_LEN);
+
+	/*
+	 * The firmware-tag should be NULL terminated, otherwise throw error and
+	 * fail.
+	 */
+	if (request.firmware_tag[GB_FIRMWARE_TAG_MAX_LEN - 1] != '\0') {
+		dev_err(fw_mgmt->parent, "load-and-validate: firmware-tag is not NULL terminated\n");
+		return -EINVAL;
+	}
+
+	/* Allocate ids from 1 to 255 (u8-max), 0 is an invalid id */
+	ret = ida_simple_get(&fw_mgmt->id_map, 1, 256, GFP_KERNEL);
+	if (ret < 0) {
+		dev_err(fw_mgmt->parent, "failed to allocate request id (%d)\n",
+			ret);
+		return ret;
+	}
+
+	fw_mgmt->intf_fw_request_id = ret;
+	request.request_id = ret;
+
+	ret = gb_operation_sync(fw_mgmt->connection,
+				GB_FW_MGMT_TYPE_LOAD_AND_VALIDATE_FW, &request,
+				sizeof(request), NULL, 0);
+	if (ret) {
+		ida_simple_remove(&fw_mgmt->id_map,
+				  fw_mgmt->intf_fw_request_id);
+		fw_mgmt->intf_fw_request_id = 0;
+		dev_err(fw_mgmt->parent,
+			"load and validate firmware request failed (%d)\n",
+			ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int fw_mgmt_interface_fw_loaded_operation(struct gb_operation *op)
+{
+	struct gb_connection *connection = op->connection;
+	struct fw_mgmt *fw_mgmt = gb_connection_get_data(connection);
+	struct gb_fw_mgmt_loaded_fw_request *request;
+
+	/* No pending load and validate request ? */
+	if (!fw_mgmt->intf_fw_request_id) {
+		dev_err(fw_mgmt->parent,
+			"unexpected firmware loaded request received\n");
+		return -ENODEV;
+	}
+
+	if (op->request->payload_size != sizeof(*request)) {
+		dev_err(fw_mgmt->parent, "illegal size of firmware loaded request (%zu != %zu)\n",
+			op->request->payload_size, sizeof(*request));
+		return -EINVAL;
+	}
+
+	request = op->request->payload;
+
+	/* Invalid request-id ? */
+	if (request->request_id != fw_mgmt->intf_fw_request_id) {
+		dev_err(fw_mgmt->parent, "invalid request id for firmware loaded request (%02u != %02u)\n",
+			fw_mgmt->intf_fw_request_id, request->request_id);
+		return -ENODEV;
+	}
+
+	ida_simple_remove(&fw_mgmt->id_map, fw_mgmt->intf_fw_request_id);
+	fw_mgmt->intf_fw_request_id = 0;
+	fw_mgmt->intf_fw_status = request->status;
+	fw_mgmt->intf_fw_major = le16_to_cpu(request->major);
+	fw_mgmt->intf_fw_minor = le16_to_cpu(request->minor);
+
+	if (fw_mgmt->intf_fw_status == GB_FW_LOAD_STATUS_FAILED)
+		dev_err(fw_mgmt->parent,
+			"failed to load interface firmware, status:%02x\n",
+			fw_mgmt->intf_fw_status);
+	else if (fw_mgmt->intf_fw_status == GB_FW_LOAD_STATUS_VALIDATION_FAILED)
+		dev_err(fw_mgmt->parent,
+			"failed to validate interface firmware, status:%02x\n",
+			fw_mgmt->intf_fw_status);
+
+	complete(&fw_mgmt->completion);
+
+	return 0;
+}
+
+static int fw_mgmt_backend_fw_version_operation(struct fw_mgmt *fw_mgmt,
+		struct fw_mgmt_ioc_get_fw *fw_info)
+{
+	struct gb_connection *connection = fw_mgmt->connection;
+	struct gb_fw_mgmt_backend_fw_version_request request;
+	struct gb_fw_mgmt_backend_fw_version_response response;
+	int ret;
+
+	strncpy(request.firmware_tag, fw_info->firmware_tag,
+		GB_FIRMWARE_TAG_MAX_LEN);
+
+	/*
+	 * The firmware-tag should be NULL terminated, otherwise throw error and
+	 * fail.
+	 */
+	if (request.firmware_tag[GB_FIRMWARE_TAG_MAX_LEN - 1] != '\0') {
+		dev_err(fw_mgmt->parent, "backend-version: firmware-tag is not NULL terminated\n");
+		return -EINVAL;
+	}
+
+	ret = gb_operation_sync(connection,
+				GB_FW_MGMT_TYPE_BACKEND_FW_VERSION, &request,
+				sizeof(request), &response, sizeof(response));
+	if (ret) {
+		dev_err(fw_mgmt->parent, "failed to get version of %s backend firmware (%d)\n",
+			fw_info->firmware_tag, ret);
+		return ret;
+	}
+
+	fw_info->major = le16_to_cpu(response.major);
+	fw_info->minor = le16_to_cpu(response.minor);
+
+	return 0;
+}
+
+static int fw_mgmt_backend_fw_update_operation(struct fw_mgmt *fw_mgmt,
+					       char *tag)
+{
+	struct gb_fw_mgmt_backend_fw_update_request request;
+	int ret;
+
+	strncpy(request.firmware_tag, tag, GB_FIRMWARE_TAG_MAX_LEN);
+
+	/*
+	 * The firmware-tag should be NULL terminated, otherwise throw error and
+	 * fail.
+	 */
+	if (request.firmware_tag[GB_FIRMWARE_TAG_MAX_LEN - 1] != '\0') {
+		dev_err(fw_mgmt->parent, "backend-update: firmware-tag is not NULL terminated\n");
+		return -EINVAL;
+	}
+
+	/* Allocate ids from 1 to 255 (u8-max), 0 is an invalid id */
+	ret = ida_simple_get(&fw_mgmt->id_map, 1, 256, GFP_KERNEL);
+	if (ret < 0) {
+		dev_err(fw_mgmt->parent, "failed to allocate request id (%d)\n",
+			ret);
+		return ret;
+	}
+
+	fw_mgmt->backend_fw_request_id = ret;
+	request.request_id = ret;
+
+	ret = gb_operation_sync(fw_mgmt->connection,
+				GB_FW_MGMT_TYPE_BACKEND_FW_UPDATE, &request,
+				sizeof(request), NULL, 0);
+	if (ret) {
+		ida_simple_remove(&fw_mgmt->id_map,
+				  fw_mgmt->backend_fw_request_id);
+		fw_mgmt->backend_fw_request_id = 0;
+		dev_err(fw_mgmt->parent,
+			"backend %s firmware update request failed (%d)\n", tag,
+			ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int fw_mgmt_backend_fw_updated_operation(struct gb_operation *op)
+{
+	struct gb_connection *connection = op->connection;
+	struct fw_mgmt *fw_mgmt = gb_connection_get_data(connection);
+	struct gb_fw_mgmt_backend_fw_updated_request *request;
+
+	/* No pending load and validate request ? */
+	if (!fw_mgmt->backend_fw_request_id) {
+		dev_err(fw_mgmt->parent, "unexpected backend firmware updated request received\n");
+		return -ENODEV;
+	}
+
+	if (op->request->payload_size != sizeof(*request)) {
+		dev_err(fw_mgmt->parent, "illegal size of backend firmware updated request (%zu != %zu)\n",
+			op->request->payload_size, sizeof(*request));
+		return -EINVAL;
+	}
+
+	request = op->request->payload;
+
+	/* Invalid request-id ? */
+	if (request->request_id != fw_mgmt->backend_fw_request_id) {
+		dev_err(fw_mgmt->parent, "invalid request id for backend firmware updated request (%02u != %02u)\n",
+			fw_mgmt->backend_fw_request_id, request->request_id);
+		return -ENODEV;
+	}
+
+	ida_simple_remove(&fw_mgmt->id_map, fw_mgmt->backend_fw_request_id);
+	fw_mgmt->backend_fw_request_id = 0;
+	fw_mgmt->backend_fw_status = request->status;
+
+	if (fw_mgmt->backend_fw_status != GB_FW_BACKEND_FW_STATUS_SUCCESS)
+		dev_err(fw_mgmt->parent,
+			"failed to backend load firmware, status:%02x\n",
+			fw_mgmt->backend_fw_status);
+
+	complete(&fw_mgmt->completion);
+
+	return 0;
+}
+
+/* Char device fops */
+
+static int fw_mgmt_open(struct inode *inode, struct file *file)
+{
+	struct fw_mgmt *fw_mgmt = container_of(inode->i_cdev, struct fw_mgmt,
+					       cdev);
+
+	file->private_data = fw_mgmt;
+	return 0;
+}
+
+static int fw_mgmt_ioctl(struct fw_mgmt *fw_mgmt, unsigned int cmd,
+			 void __user *buf)
+{
+	struct fw_mgmt_ioc_get_fw fw_info;
+	struct fw_mgmt_ioc_intf_load_and_validate intf_load;
+	struct fw_mgmt_ioc_backend_fw_update backend_update;
+	unsigned int timeout;
+	int ret;
+
+	switch (cmd) {
+	case FW_MGMT_IOC_GET_INTF_FW:
+		ret = fw_mgmt_interface_fw_version_operation(fw_mgmt, &fw_info);
+		if (ret)
+			return ret;
+
+		if (copy_to_user(buf, &fw_info, sizeof(fw_info)))
+			return -EFAULT;
+
+		return 0;
+	case FW_MGMT_IOC_GET_BACKEND_FW:
+		if (copy_from_user(&fw_info, buf, sizeof(fw_info)))
+			return -EFAULT;
+
+		ret = fw_mgmt_backend_fw_version_operation(fw_mgmt, &fw_info);
+		if (ret)
+			return ret;
+
+		if (copy_to_user(buf, &fw_info, sizeof(fw_info)))
+			return -EFAULT;
+
+		return 0;
+	case FW_MGMT_IOC_INTF_LOAD_AND_VALIDATE:
+		if (copy_from_user(&intf_load, buf, sizeof(intf_load)))
+			return -EFAULT;
+
+		ret = fw_mgmt_load_and_validate_operation(fw_mgmt,
+				intf_load.load_method, intf_load.firmware_tag);
+		if (ret)
+			return ret;
+
+		if (!wait_for_completion_timeout(&fw_mgmt->completion,
+						 fw_mgmt->timeout_jiffies)) {
+			dev_err(fw_mgmt->parent, "timed out waiting for firmware load and validation to finish\n");
+			return -ETIMEDOUT;
+		}
+
+		intf_load.status = fw_mgmt->intf_fw_status;
+		intf_load.major = cpu_to_le16(fw_mgmt->intf_fw_major);
+		intf_load.minor = cpu_to_le16(fw_mgmt->intf_fw_minor);
+
+		if (copy_to_user(buf, &intf_load, sizeof(intf_load)))
+			return -EFAULT;
+
+		return 0;
+	case FW_MGMT_IOC_INTF_BACKEND_FW_UPDATE:
+		if (copy_from_user(&backend_update, buf,
+				   sizeof(backend_update)))
+			return -EFAULT;
+
+		ret = fw_mgmt_backend_fw_update_operation(fw_mgmt,
+				backend_update.firmware_tag);
+		if (ret)
+			return ret;
+
+		if (!wait_for_completion_timeout(&fw_mgmt->completion,
+						 fw_mgmt->timeout_jiffies)) {
+			dev_err(fw_mgmt->parent, "timed out waiting for backend firmware update to finish\n");
+			return -ETIMEDOUT;
+		}
+
+		backend_update.status = fw_mgmt->backend_fw_status;
+
+		if (copy_to_user(buf, &backend_update, sizeof(backend_update)))
+			return -EFAULT;
+
+		return 0;
+	case FW_MGMT_IOC_SET_TIMEOUT_MS:
+		if (get_user(timeout, (unsigned int __user *)buf))
+			return -EFAULT;
+
+		if (!timeout) {
+			dev_err(fw_mgmt->parent, "timeout can't be zero\n");
+			return -EINVAL;
+		}
+
+		fw_mgmt->timeout_jiffies = msecs_to_jiffies(timeout);
+
+		return 0;
+	default:
+		return -ENOTTY;
+	}
+}
+
+static long fw_mgmt_ioctl_unlocked(struct file *file, unsigned int cmd,
+				   unsigned long arg)
+{
+	struct fw_mgmt *fw_mgmt = file->private_data;
+	int ret;
+
+	/*
+	 * Serialize ioctls
+	 *
+	 * We don't want the user to do few operations in parallel. For example,
+	 * updating Interface firmware in parallel for the same Interface. There
+	 * is no need to do things in parallel for speed and we can avoid having
+	 * complicated for now.
+	 */
+	mutex_lock(&fw_mgmt->mutex);
+	ret = fw_mgmt_ioctl(fw_mgmt, cmd, (void __user *)arg);
+	mutex_unlock(&fw_mgmt->mutex);
+
+	return ret;
+}
+
+static const struct file_operations fw_mgmt_fops = {
+	.owner		= THIS_MODULE,
+	.open		= fw_mgmt_open,
+	.unlocked_ioctl	= fw_mgmt_ioctl_unlocked,
+};
+
+int gb_fw_mgmt_request_handler(struct gb_operation *op)
+{
+	u8 type = op->type;
+
+	switch (type) {
+	case GB_FW_MGMT_TYPE_LOADED_FW:
+		return fw_mgmt_interface_fw_loaded_operation(op);
+	case GB_FW_MGMT_TYPE_BACKEND_FW_UPDATED:
+		return fw_mgmt_backend_fw_updated_operation(op);
+	default:
+		dev_err(&op->connection->bundle->dev,
+			"unsupported request: %u\n", type);
+		return -EINVAL;
+	}
+}
+
+int gb_fw_mgmt_connection_init(struct gb_connection *connection)
+{
+	struct fw_mgmt *fw_mgmt;
+	int ret, minor;
+
+	if (!connection)
+		return 0;
+
+	fw_mgmt = kzalloc(sizeof(*fw_mgmt), GFP_KERNEL);
+	if (!fw_mgmt)
+		return -ENOMEM;
+
+	fw_mgmt->parent = &connection->bundle->dev;
+	fw_mgmt->timeout_jiffies = msecs_to_jiffies(FW_MGMT_TIMEOUT_MS);
+	fw_mgmt->connection = connection;
+
+	gb_connection_set_data(connection, fw_mgmt);
+	init_completion(&fw_mgmt->completion);
+	ida_init(&fw_mgmt->id_map);
+	mutex_init(&fw_mgmt->mutex);
+
+	ret = gb_connection_enable(connection);
+	if (ret)
+		goto err_destroy_ida;
+
+	minor = ida_simple_get(&fw_mgmt_minors_map, 0, NUM_MINORS, GFP_KERNEL);
+	if (minor < 0) {
+		ret = minor;
+		goto err_connection_disable;
+	}
+
+	/* Add a char device to allow userspace to interact with fw-mgmt */
+	fw_mgmt->dev_num = MKDEV(MAJOR(fw_mgmt_dev_num), minor);
+	cdev_init(&fw_mgmt->cdev, &fw_mgmt_fops);
+
+	ret = cdev_add(&fw_mgmt->cdev, fw_mgmt->dev_num, 1);
+	if (ret)
+		goto err_remove_ida;
+
+	/* Add a soft link to the previously added char-dev within the bundle */
+	fw_mgmt->class_device = device_create(fw_mgmt_class, fw_mgmt->parent,
+					      fw_mgmt->dev_num, NULL,
+					      "fw-mgmt-%d", minor);
+	if (IS_ERR(fw_mgmt->class_device)) {
+		ret = PTR_ERR(fw_mgmt->class_device);
+		goto err_del_cdev;
+	}
+
+	return 0;
+
+err_del_cdev:
+	cdev_del(&fw_mgmt->cdev);
+err_remove_ida:
+	ida_simple_remove(&fw_mgmt_minors_map, minor);
+err_connection_disable:
+	gb_connection_disable(connection);
+err_destroy_ida:
+	ida_destroy(&fw_mgmt->id_map);
+	kfree(fw_mgmt);
+
+	return ret;
+}
+
+void gb_fw_mgmt_connection_exit(struct gb_connection *connection)
+{
+	struct fw_mgmt *fw_mgmt;
+
+	if (!connection)
+		return;
+
+	fw_mgmt = gb_connection_get_data(connection);
+	device_destroy(fw_mgmt_class, fw_mgmt->dev_num);
+	cdev_del(&fw_mgmt->cdev);
+	ida_simple_remove(&fw_mgmt_minors_map, MINOR(fw_mgmt->dev_num));
+	gb_connection_disable(fw_mgmt->connection);
+	ida_destroy(&fw_mgmt->id_map);
+
+	kfree(fw_mgmt);
+}
+
+int fw_mgmt_init(void)
+{
+	int ret;
+
+	fw_mgmt_class = class_create(THIS_MODULE, "gb_fw_mgmt");
+	if (IS_ERR(fw_mgmt_class))
+		return PTR_ERR(fw_mgmt_class);
+
+	ret = alloc_chrdev_region(&fw_mgmt_dev_num, 0, NUM_MINORS,
+				  "gb_fw_mgmt");
+	if (ret)
+		goto err_remove_class;
+
+	return 0;
+
+err_remove_class:
+	class_destroy(fw_mgmt_class);
+	return ret;
+}
+
+void fw_mgmt_exit(void)
+{
+	unregister_chrdev_region(fw_mgmt_dev_num, NUM_MINORS);
+	class_destroy(fw_mgmt_class);
+	ida_destroy(&fw_mgmt_minors_map);
+}
