commit f49c5f16e9454bc6381eb26adf3d23bc28a478df
Author: Simran Singhal <singhalsimran0@gmail.com>
Date:   Sun Mar 22 23:00:45 2020 +0530

    staging: greybus: tools: Fix braces {} style
    
    This patch fixes the check reported by checkpatch.pl
    for braces {} should be used on all arms of this statement.
    
    Signed-off-by: Simran Singhal <singhalsimran0@gmail.com>
    Reviewed-by: Alex Elder <elder@linaro.org>
    Link: https://lore.kernel.org/r/20200322173045.GA24700@simran-Inspiron-5558
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/tools/loopback_test.c b/drivers/staging/greybus/tools/loopback_test.c
index 69c6dce9be31..867bf289df2e 100644
--- a/drivers/staging/greybus/tools/loopback_test.c
+++ b/drivers/staging/greybus/tools/loopback_test.c
@@ -802,8 +802,9 @@ static void prepare_devices(struct loopback_test *t)
 			write_sysfs_val(t->devices[i].sysfs_entry,
 					"outstanding_operations_max",
 					t->async_outstanding_operations);
-		} else
+		} else {
 			write_sysfs_val(t->devices[i].sysfs_entry, "async", 0);
+		}
 	}
 }
 

commit ae62cf5eb2792d9a818c2d93728ed92119357017
Author: Johan Hovold <johan@kernel.org>
Date:   Thu Mar 12 12:01:51 2020 +0100

    staging: greybus: loopback_test: fix potential path truncations
    
    Newer GCC warns about possible truncations of two generated path names as
    we're concatenating the configurable sysfs and debugfs path prefixes
    with a filename and placing the results in buffers of the same size as
    the maximum length of the prefixes.
    
            snprintf(d->name, MAX_STR_LEN, "gb_loopback%u", dev_id);
    
            snprintf(d->sysfs_entry, MAX_SYSFS_PATH, "%s%s/",
                     t->sysfs_prefix, d->name);
    
            snprintf(d->debugfs_entry, MAX_SYSFS_PATH, "%sraw_latency_%s",
                     t->debugfs_prefix, d->name);
    
    Fix this by separating the maximum path length from the maximum prefix
    length and reducing the latter enough to fit the generated strings.
    
    Note that we also need to reduce the device-name buffer size as GCC
    isn't smart enough to figure out that we ever only used MAX_STR_LEN
    bytes of it.
    
    Fixes: 6b0658f68786 ("greybus: tools: Add tools directory to greybus repo and add loopback")
    Signed-off-by: Johan Hovold <johan@kernel.org>
    Link: https://lore.kernel.org/r/20200312110151.22028-4-johan@kernel.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/tools/loopback_test.c b/drivers/staging/greybus/tools/loopback_test.c
index d38bb4fbd6b9..69c6dce9be31 100644
--- a/drivers/staging/greybus/tools/loopback_test.c
+++ b/drivers/staging/greybus/tools/loopback_test.c
@@ -19,6 +19,7 @@
 #include <signal.h>
 
 #define MAX_NUM_DEVICES 10
+#define MAX_SYSFS_PREFIX 0x80
 #define MAX_SYSFS_PATH	0x200
 #define CSV_MAX_LINE	0x1000
 #define SYSFS_MAX_INT	0x20
@@ -67,7 +68,7 @@ struct loopback_results {
 };
 
 struct loopback_device {
-	char name[MAX_SYSFS_PATH];
+	char name[MAX_STR_LEN];
 	char sysfs_entry[MAX_SYSFS_PATH];
 	char debugfs_entry[MAX_SYSFS_PATH];
 	struct loopback_results results;
@@ -93,8 +94,8 @@ struct loopback_test {
 	int stop_all;
 	int poll_count;
 	char test_name[MAX_STR_LEN];
-	char sysfs_prefix[MAX_SYSFS_PATH];
-	char debugfs_prefix[MAX_SYSFS_PATH];
+	char sysfs_prefix[MAX_SYSFS_PREFIX];
+	char debugfs_prefix[MAX_SYSFS_PREFIX];
 	struct timespec poll_timeout;
 	struct loopback_device devices[MAX_NUM_DEVICES];
 	struct loopback_results aggregate_results;
@@ -907,10 +908,10 @@ int main(int argc, char *argv[])
 			t.iteration_max = atoi(optarg);
 			break;
 		case 'S':
-			snprintf(t.sysfs_prefix, MAX_SYSFS_PATH, "%s", optarg);
+			snprintf(t.sysfs_prefix, MAX_SYSFS_PREFIX, "%s", optarg);
 			break;
 		case 'D':
-			snprintf(t.debugfs_prefix, MAX_SYSFS_PATH, "%s", optarg);
+			snprintf(t.debugfs_prefix, MAX_SYSFS_PREFIX, "%s", optarg);
 			break;
 		case 'm':
 			t.mask = atol(optarg);
@@ -961,10 +962,10 @@ int main(int argc, char *argv[])
 	}
 
 	if (!strcmp(t.sysfs_prefix, ""))
-		snprintf(t.sysfs_prefix, MAX_SYSFS_PATH, "%s", sysfs_prefix);
+		snprintf(t.sysfs_prefix, MAX_SYSFS_PREFIX, "%s", sysfs_prefix);
 
 	if (!strcmp(t.debugfs_prefix, ""))
-		snprintf(t.debugfs_prefix, MAX_SYSFS_PATH, "%s", debugfs_prefix);
+		snprintf(t.debugfs_prefix, MAX_SYSFS_PREFIX, "%s", debugfs_prefix);
 
 	ret = find_loopback_devices(&t);
 	if (ret)

commit f16023834863932f95dfad13fac3fc47f77d2f29
Author: Johan Hovold <johan@kernel.org>
Date:   Thu Mar 12 12:01:50 2020 +0100

    staging: greybus: loopback_test: fix potential path truncation
    
    Newer GCC warns about a possible truncation of a generated sysfs path
    name as we're concatenating a directory path with a file name and
    placing the result in a buffer that is half the size of the maximum
    length of the directory path (which is user controlled).
    
    loopback_test.c: In function 'open_poll_files':
    loopback_test.c:651:31: warning: '%s' directive output may be truncated writing up to 511 bytes into a region of size 255 [-Wformat-truncation=]
      651 |   snprintf(buf, sizeof(buf), "%s%s", dev->sysfs_entry, "iteration_count");
          |                               ^~
    loopback_test.c:651:3: note: 'snprintf' output between 16 and 527 bytes into a destination of size 255
      651 |   snprintf(buf, sizeof(buf), "%s%s", dev->sysfs_entry, "iteration_count");
          |   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    
    Fix this by making sure the buffer is large enough the concatenated
    strings.
    
    Fixes: 6b0658f68786 ("greybus: tools: Add tools directory to greybus repo and add loopback")
    Fixes: 9250c0ee2626 ("greybus: Loopback_test: use poll instead of inotify")
    Signed-off-by: Johan Hovold <johan@kernel.org>
    Link: https://lore.kernel.org/r/20200312110151.22028-3-johan@kernel.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/tools/loopback_test.c b/drivers/staging/greybus/tools/loopback_test.c
index 41e1820d9ac9..d38bb4fbd6b9 100644
--- a/drivers/staging/greybus/tools/loopback_test.c
+++ b/drivers/staging/greybus/tools/loopback_test.c
@@ -637,7 +637,7 @@ int find_loopback_devices(struct loopback_test *t)
 static int open_poll_files(struct loopback_test *t)
 {
 	struct loopback_device *dev;
-	char buf[MAX_STR_LEN];
+	char buf[MAX_SYSFS_PATH + MAX_STR_LEN];
 	char dummy;
 	int fds_idx = 0;
 	int i;

commit 8f3675be4bda33adbdc1dd2ab3b6c76a7599a79e
Author: Johan Hovold <johan@kernel.org>
Date:   Thu Mar 12 12:01:49 2020 +0100

    staging: greybus: loopback_test: fix poll-mask build breakage
    
    A scripted conversion from userland POLL* to kernel EPOLL* constants
    mistakingly replaced the poll flags in the loopback_test tool, which
    therefore no longer builds.
    
    Fixes: a9a08845e9ac ("vfs: do bulk POLL* -> EPOLL* replacement")
    Cc: stable <stable@vger.kernel.org>     # 4.16
    Signed-off-by: Johan Hovold <johan@kernel.org>
    Link: https://lore.kernel.org/r/20200312110151.22028-2-johan@kernel.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/tools/loopback_test.c b/drivers/staging/greybus/tools/loopback_test.c
index ba6f905f26fa..41e1820d9ac9 100644
--- a/drivers/staging/greybus/tools/loopback_test.c
+++ b/drivers/staging/greybus/tools/loopback_test.c
@@ -655,7 +655,7 @@ static int open_poll_files(struct loopback_test *t)
 			goto err;
 		}
 		read(t->fds[fds_idx].fd, &dummy, 1);
-		t->fds[fds_idx].events = EPOLLERR|EPOLLPRI;
+		t->fds[fds_idx].events = POLLERR | POLLPRI;
 		t->fds[fds_idx].revents = 0;
 		fds_idx++;
 	}
@@ -748,7 +748,7 @@ static int wait_for_complete(struct loopback_test *t)
 		}
 
 		for (i = 0; i < t->poll_count; i++) {
-			if (t->fds[i].revents & EPOLLPRI) {
+			if (t->fds[i].revents & POLLPRI) {
 				/* Dummy read to clear the event */
 				read(t->fds[i].fd, &dummy, 1);
 				number_of_events++;

commit 137bfbd006b2aad72fa90b6fbe096f3a1db5b32a
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Sun Aug 25 07:54:22 2019 +0200

    staging: greybus: remove license "boilerplate"
    
    When the greybus drivers were converted to SPDX identifiers for the
    license text, some license boilerplate was not removed.  Clean this up
    by removing this unneeded text now.
    
    Cc: Johan Hovold <johan@kernel.org>
    Cc: Vaibhav Agarwal <vaibhav.sr@gmail.com>
    Cc: "Bryan O'Donoghue" <pure.logic@nexus-software.ie>
    Cc: greybus-dev@lists.linaro.org
    Cc: devel@driverdev.osuosl.org
    Acked-by: Mark Greer <mgreer@animalcreekk.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Acked-by: Alex Elder <elder@kernel.org>
    Link: https://lore.kernel.org/r/20190825055429.18547-3-gregkh@linuxfoundation.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/tools/loopback_test.c b/drivers/staging/greybus/tools/loopback_test.c
index cebc1d90a180..ba6f905f26fa 100644
--- a/drivers/staging/greybus/tools/loopback_test.c
+++ b/drivers/staging/greybus/tools/loopback_test.c
@@ -4,8 +4,6 @@
  *
  * Copyright 2015 Google Inc.
  * Copyright 2015 Linaro Ltd.
- *
- * Provided under the three clause BSD license found in the LICENSE file.
  */
 #include <errno.h>
 #include <fcntl.h>

commit 3c96993b1832c085f4e5905a3526c9523dd17357
Author: Nishka Dasgupta <nishkadg.linux@gmail.com>
Date:   Wed Jun 26 12:14:50 2019 +0530

    staging: greybus: tools: Remove function log_csv_error()
    
    Remove unused function log_csv_error.
    Issue found with Coccinelle.
    
    Signed-off-by: Nishka Dasgupta <nishkadg.linux@gmail.com>
    Reviewed-by: Bryan O'Donoghue <pure.logic@nexus-software.ie>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/tools/loopback_test.c b/drivers/staging/greybus/tools/loopback_test.c
index 2fa88092514d..cebc1d90a180 100644
--- a/drivers/staging/greybus/tools/loopback_test.c
+++ b/drivers/staging/greybus/tools/loopback_test.c
@@ -414,12 +414,6 @@ static int get_results(struct loopback_test *t)
 	return 0;
 }
 
-void log_csv_error(int len, int err)
-{
-	fprintf(stderr, "unable to write %d bytes to csv %s\n", len,
-		strerror(err));
-}
-
 int format_output(struct loopback_test *t,
 		  struct loopback_results *r,
 		  const char *dev_name,

commit 47bde229703f243dd33ae9d6a6daa2b43b9a9514
Author: Colin Ian King <colin.king@canonical.com>
Date:   Fri Sep 14 12:24:51 2018 +0100

    staging: greybus: fix spelling mistake "entires" -> "entries"
    
    Trivial fix to spelling mistake
    
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Reviewed-by: Alex Elder <elder@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/tools/loopback_test.c b/drivers/staging/greybus/tools/loopback_test.c
index b82e2befe935..2fa88092514d 100644
--- a/drivers/staging/greybus/tools/loopback_test.c
+++ b/drivers/staging/greybus/tools/loopback_test.c
@@ -192,7 +192,7 @@ void usage(void)
 	"   -t     must be one of the test names - sink, transfer or ping\n"
 	"   -i     iteration count - the number of iterations to run the test over\n"
 	" Optional arguments\n"
-	"   -S     sysfs location - location for greybus 'endo' entires default /sys/bus/greybus/devices/\n"
+	"   -S     sysfs location - location for greybus 'endo' entries default /sys/bus/greybus/devices/\n"
 	"   -D     debugfs location - location for loopback debugfs entries default /sys/kernel/debug/gb_loopback/\n"
 	"   -s     size of data packet to send during test - defaults to zero\n"
 	"   -m     mask - a bit mask of connections to include example: -m 8 = 4th connection -m 9 = 1st and 4th connection etc\n"

commit a9a08845e9acbd224e4ee466f5c1275ed50054e8
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Feb 11 14:34:03 2018 -0800

    vfs: do bulk POLL* -> EPOLL* replacement
    
    This is the mindless scripted replacement of kernel use of POLL*
    variables as described by Al, done by this script:
    
        for V in IN OUT PRI ERR RDNORM RDBAND WRNORM WRBAND HUP RDHUP NVAL MSG; do
            L=`git grep -l -w POLL$V | grep -v '^t' | grep -v /um/ | grep -v '^sa' | grep -v '/poll.h$'|grep -v '^D'`
            for f in $L; do sed -i "-es/^\([^\"]*\)\(\<POLL$V\>\)/\\1E\\2/" $f; done
        done
    
    with de-mangling cleanups yet to come.
    
    NOTE! On almost all architectures, the EPOLL* constants have the same
    values as the POLL* constants do.  But they keyword here is "almost".
    For various bad reasons they aren't the same, and epoll() doesn't
    actually work quite correctly in some cases due to this on Sparc et al.
    
    The next patch from Al will sort out the final differences, and we
    should be all done.
    
    Scripted-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/staging/greybus/tools/loopback_test.c b/drivers/staging/greybus/tools/loopback_test.c
index c51610ce24af..b82e2befe935 100644
--- a/drivers/staging/greybus/tools/loopback_test.c
+++ b/drivers/staging/greybus/tools/loopback_test.c
@@ -663,7 +663,7 @@ static int open_poll_files(struct loopback_test *t)
 			goto err;
 		}
 		read(t->fds[fds_idx].fd, &dummy, 1);
-		t->fds[fds_idx].events = POLLERR|POLLPRI;
+		t->fds[fds_idx].events = EPOLLERR|EPOLLPRI;
 		t->fds[fds_idx].revents = 0;
 		fds_idx++;
 	}
@@ -756,7 +756,7 @@ static int wait_for_complete(struct loopback_test *t)
 		}
 
 		for (i = 0; i < t->poll_count; i++) {
-			if (t->fds[i].revents & POLLPRI) {
+			if (t->fds[i].revents & EPOLLPRI) {
 				/* Dummy read to clear the event */
 				read(t->fds[i].fd, &dummy, 1);
 				number_of_events++;

commit eb50fd3a22c770f36be275295b782f3ea52e3215
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Nov 7 14:58:41 2017 +0100

    staging: greybus: add SPDX identifiers to all greybus driver files
    
    It's good to have SPDX identifiers in all files to make it easier to
    audit the kernel tree for correct licenses.
    
    Update the drivers/staging/greybus files files with the correct SPDX
    license identifier based on the license text in the file itself.  The
    SPDX identifier is a legally binding shorthand, which can be used
    instead of the full boiler plate text.
    
    This work is based on a script and data from Thomas Gleixner, Philippe
    Ombredanne, and Kate Stewart.
    
    Cc: Vaibhav Hiremath <hvaibhav.linux@gmail.com>
    Cc: "Bryan O'Donoghue" <pure.logic@nexus-software.ie>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: Philippe Ombredanne <pombredanne@nexb.com>
    Acked-by: Vaibhav Agarwal <vaibhav.sr@gmail.com>
    Acked-by: David Lin <dtwlin@gmail.com>
    Reviewed-by: Alex Elder <elder@linaro.org>
    Acked-by: Johan Hovold <johan@kernel.org>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Acked-by: Mark Greer <mgreer@animalcreek.com>
    Acked-by: Rui Miguel Silva <rmfrfs@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/tools/loopback_test.c b/drivers/staging/greybus/tools/loopback_test.c
index fbe589fca840..c51610ce24af 100644
--- a/drivers/staging/greybus/tools/loopback_test.c
+++ b/drivers/staging/greybus/tools/loopback_test.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: BSD-3-Clause
 /*
  * Loopback test application
  *

commit efd44cf468fe7e7ff9150dc52879426e0d0801eb
Author: Shreeya Patel <shreeya.patel23498@gmail.com>
Date:   Sat Jul 29 01:20:42 2017 +0530

    Staging: greybus: Match alignment with open parenthesis.
    
    Alignment should match with open parenthesis.
    This fixes the coding style issue.
    
    Signed-off-by: Shreeya Patel <shreeya.patel23498@gmail.com>
    Reviewed-by: Bryan O'Donoghue <pure.logic@nexus-software.ie>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/tools/loopback_test.c b/drivers/staging/greybus/tools/loopback_test.c
index d86bcce53e6b..fbe589fca840 100644
--- a/drivers/staging/greybus/tools/loopback_test.c
+++ b/drivers/staging/greybus/tools/loopback_test.c
@@ -420,10 +420,10 @@ void log_csv_error(int len, int err)
 }
 
 int format_output(struct loopback_test *t,
-			struct loopback_results *r,
-			const char *dev_name,
-			char *buf, int buf_len,
-			struct tm *tm)
+		  struct loopback_results *r,
+		  const char *dev_name,
+		  char *buf, int buf_len,
+		  struct tm *tm)
 {
 	int len = 0;
 
@@ -535,7 +535,7 @@ static int log_results(struct loopback_test *t)
 	 */
 	if (t->file_output && !t->porcelain) {
 		snprintf(file_name, sizeof(file_name), "%s_%d_%d.csv",
-			t->test_name, t->size, t->iteration_max);
+			 t->test_name, t->size, t->iteration_max);
 
 		fd = open(file_name, O_WRONLY | O_CREAT | O_APPEND, 0644);
 		if (fd < 0) {
@@ -549,8 +549,8 @@ static int log_results(struct loopback_test *t)
 			continue;
 
 		len = format_output(t, &t->devices[i].results,
-					t->devices[i].name,
-					data, sizeof(data), &tm);
+				    t->devices[i].name,
+				    data, sizeof(data), &tm);
 		if (t->file_output && !t->porcelain) {
 			ret = write(fd, data, len);
 			if (ret == -1)
@@ -562,7 +562,7 @@ static int log_results(struct loopback_test *t)
 
 	if (t->aggregate_output) {
 		len = format_output(t, &t->aggregate_results, "aggregate",
-					data, sizeof(data), &tm);
+				    data, sizeof(data), &tm);
 		if (t->file_output && !t->porcelain) {
 			ret = write(fd, data, len);
 			if (ret == -1)
@@ -623,14 +623,13 @@ int find_loopback_devices(struct loopback_test *t)
 		snprintf(d->name, MAX_STR_LEN, "gb_loopback%u", dev_id);
 
 		snprintf(d->sysfs_entry, MAX_SYSFS_PATH, "%s%s/",
-			t->sysfs_prefix, d->name);
+			 t->sysfs_prefix, d->name);
 
 		snprintf(d->debugfs_entry, MAX_SYSFS_PATH, "%sraw_latency_%s",
-			t->debugfs_prefix, d->name);
+			 t->debugfs_prefix, d->name);
 
 		if (t->debug)
-			printf("add %s %s\n", d->sysfs_entry,
-				d->debugfs_entry);
+			printf("add %s %s\n", d->sysfs_entry, d->debugfs_entry);
 	}
 
 	ret = 0;
@@ -803,16 +802,14 @@ static void prepare_devices(struct loopback_test *t)
 				t->iteration_max);
 
 		if (t->use_async) {
+			write_sysfs_val(t->devices[i].sysfs_entry, "async", 1);
 			write_sysfs_val(t->devices[i].sysfs_entry,
-				"async", 1);
+					"timeout", t->async_timeout);
 			write_sysfs_val(t->devices[i].sysfs_entry,
-				"timeout", t->async_timeout);
-			write_sysfs_val(t->devices[i].sysfs_entry,
-				"outstanding_operations_max",
-				t->async_outstanding_operations);
+					"outstanding_operations_max",
+					t->async_outstanding_operations);
 		} else
-			write_sysfs_val(t->devices[i].sysfs_entry,
-				"async", 0);
+			write_sysfs_val(t->devices[i].sysfs_entry, "async", 0);
 	}
 }
 

commit ac9735b9934efa5a7146671360663548b5427a75
Author: Aleksey Rybalkin <aleksey@rybalkin.org>
Date:   Mon Jul 3 23:27:15 2017 +0500

    staging: greybus: loopback_test: fix comment style issues
    
    According to checkpatch warning, block comments should align the * on
    each line. Also, preferred style for multi-line comments is starting the
    comment text after the second *.
    
    Signed-off-by: Aleksey Rybalkin <aleksey@rybalkin.org>
    Acked-by: Johan Hovold <johan@kernel.org>
    Reviewed-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/tools/loopback_test.c b/drivers/staging/greybus/tools/loopback_test.c
index 32a43693181c..d86bcce53e6b 100644
--- a/drivers/staging/greybus/tools/loopback_test.c
+++ b/drivers/staging/greybus/tools/loopback_test.c
@@ -528,11 +528,11 @@ static int log_results(struct loopback_test *t)
 	tm = *localtime(&local_time);
 
 	/*
-	* file name will test_name_size_iteration_max.csv
-	* every time the same test with the same parameters is run we will then
-	* append to the same CSV with datestamp - representing each test
-	* dataset.
-	*/
+	 * file name will test_name_size_iteration_max.csv
+	 * every time the same test with the same parameters is run we will then
+	 * append to the same CSV with datestamp - representing each test
+	 * dataset.
+	 */
 	if (t->file_output && !t->porcelain) {
 		snprintf(file_name, sizeof(file_name), "%s_%d_%d.csv",
 			t->test_name, t->size, t->iteration_max);
@@ -779,7 +779,8 @@ static void prepare_devices(struct loopback_test *t)
 {
 	int i;
 
-	/* Cancel any running tests on enabled devices. If
+	/*
+	 * Cancel any running tests on enabled devices. If
 	 * stop_all option is given, stop test on all devices.
 	 */
 	for (i = 0; i < t->device_count; i++)

commit 35fd2485d75702f58891bab7fe1c21f760e313fd
Author: Jonathan Bowie <eudjtb@gmail.com>
Date:   Wed Mar 1 02:46:30 2017 -0800

    staging: greybus: loop_backtest: fixed consistent spacing style issue
    
    Fixed incosistent spacing around arithmetic operator.
    
    Signed-off-by: Jonathan Bowie <eudjtb@gmail.com>
    Reviewed-by: Johan Hovold <johan@kernel.org>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/tools/loopback_test.c b/drivers/staging/greybus/tools/loopback_test.c
index f1edd4bc411e..32a43693181c 100644
--- a/drivers/staging/greybus/tools/loopback_test.c
+++ b/drivers/staging/greybus/tools/loopback_test.c
@@ -476,7 +476,7 @@ int format_output(struct loopback_test *t,
 			r->gbphy_firmware_latency_jitter);
 
 	} else {
-		len += snprintf(&buf[len], buf_len- len, ",%s,%s,%u,%u,%u",
+		len += snprintf(&buf[len], buf_len - len, ",%s,%s,%u,%u,%u",
 			t->test_name, dev_name, t->size, t->iteration_max,
 			r->error);
 

commit 6796cd84610a56beb7d3fa2818989727e4f26550
Author: sayli karnik <karniksayli1995@gmail.com>
Date:   Mon Feb 20 22:40:28 2017 +0530

    staging: greybus: loopback_test: Fix open error path
    
    Change array index from the loop bound variable to loop index.
    If a poll file fails to open for any intermediate device, all poll files with
    fds of devices from 0 upto that device must be closed in the open_poll_files()
    function. The current code only closes the poll file with the most recent fd
    allocated, and at times tries to close the same file multiple times.
    
    Detected by coccinelle:
    
    @@
    expression arr,ex1,ex2;
    @@
    
    for(ex1 = 0; ex1 < ex2; ex1++) { <...
      arr[
    - ex2
    + ex1
      ]
      ...> }
    
    Signed-off-by: sayli karnik <karniksayli1995@gmail.com>
    Reviewed-by: Johan Hovold <johan@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/tools/loopback_test.c b/drivers/staging/greybus/tools/loopback_test.c
index 1c01833d1f4e..f1edd4bc411e 100644
--- a/drivers/staging/greybus/tools/loopback_test.c
+++ b/drivers/staging/greybus/tools/loopback_test.c
@@ -674,7 +674,7 @@ static int open_poll_files(struct loopback_test *t)
 
 err:
 	for (i = 0; i < fds_idx; i++)
-		close(t->fds[fds_idx].fd);
+		close(t->fds[i].fd);
 
 	return -1;
 }

commit fea3860d7d69b0a82e0b96617258ffaf0ff250d4
Author: Gargi Sharma <gs051095@gmail.com>
Date:   Wed Feb 22 21:08:21 2017 +0530

    staging: greybus: loopback_test: fix device-name leak
    
    All the device names were being always leaked. Also,
    illegal free was being called upon namelist[n] which
    was coincidentally NULL. The pointer to dirent structures
    must be individually freed before freeing the pointer array.
    
    Coccinelle Script:
    @@
    expression arr,ex1,ex2;
    @@
    
    for(ex1 = 0; ex1 < ex2; ex1++) { <...
      arr[
    - ex2
    + ex1
      ]
      ...> }
    
    Signed-off-by: Gargi Sharma <gs051095@gmail.com>
    Reviewed by: Johan Hovold <johan@kernel.org>
    Acked-by: Julia Lawall <julia.lawall@lip6.fr>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/tools/loopback_test.c b/drivers/staging/greybus/tools/loopback_test.c
index 18d7a3d1f3c7..1c01833d1f4e 100644
--- a/drivers/staging/greybus/tools/loopback_test.c
+++ b/drivers/staging/greybus/tools/loopback_test.c
@@ -636,7 +636,7 @@ int find_loopback_devices(struct loopback_test *t)
 	ret = 0;
 done:
 	for (i = 0; i < n; i++)
-		free(namelist[n]);
+		free(namelist[i]);
 	free(namelist);
 baddir:
 	return ret;

commit e965af6bb9320cda34a346717c914e1b4054d0fe
Author: Igor Pylypiv <igor.pylypiv@gmail.com>
Date:   Wed Jan 18 18:21:23 2017 -0800

    staging: greybus: loopback_test: use octal permissions instead of symbolic
    
    checkpatch.pl warning:
    Symbolic permissions are not preferred. Consider using octal permissions.
    
    Signed-off-by: Igor Pylypiv <igor.pylypiv@gmail.com>
    Reviewed-by: Johan Hovold <johan@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/tools/loopback_test.c b/drivers/staging/greybus/tools/loopback_test.c
index 5312b2aa32f1..18d7a3d1f3c7 100644
--- a/drivers/staging/greybus/tools/loopback_test.c
+++ b/drivers/staging/greybus/tools/loopback_test.c
@@ -521,7 +521,6 @@ static int log_results(struct loopback_test *t)
 	int fd, i, len, ret;
 	struct tm tm;
 	time_t local_time;
-	mode_t mode = S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH;
 	char file_name[MAX_SYSFS_PATH];
 	char data[CSV_MAX_LINE];
 
@@ -538,7 +537,7 @@ static int log_results(struct loopback_test *t)
 		snprintf(file_name, sizeof(file_name), "%s_%d_%d.csv",
 			t->test_name, t->size, t->iteration_max);
 
-		fd = open(file_name, O_WRONLY | O_CREAT | O_APPEND, mode);
+		fd = open(file_name, O_WRONLY | O_CREAT | O_APPEND, 0644);
 		if (fd < 0) {
 			fprintf(stderr, "unable to open %s for appendation\n", file_name);
 			abort();

commit cbd8733cfd4d3a15b02fe5c8986f35cd75ab66ef
Author: Abdul Rauf <abdulraufmujahid@gmail.com>
Date:   Wed Jan 11 01:29:36 2017 +0000

    staging: greybus: loopback_test: fix checkpatch bad function definition error
    
    Fix the following Errors:
    Bad function definition - void abort() should probably be void abort(void)
    
    Signed-off-by: Abdul Rauf <abdulraufmujahid@gmail.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Acked-by: Johan Hovold <johan@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/tools/loopback_test.c b/drivers/staging/greybus/tools/loopback_test.c
index f7f4cd6fb55b..5312b2aa32f1 100644
--- a/drivers/staging/greybus/tools/loopback_test.c
+++ b/drivers/staging/greybus/tools/loopback_test.c
@@ -168,7 +168,7 @@ GET_AVG(latency_avg);
 GET_AVG(apbridge_unipro_latency_avg);
 GET_AVG(gbphy_firmware_latency_avg);
 
-void abort()
+void abort(void)
 {
 	_exit(1);
 }

commit 346bae656e4e1a471771590f1f4e16e9f9332d1d
Author: Ryan Lim <limryan@google.com>
Date:   Wed Jul 20 08:14:04 2016 -0700

    greybus: loopback_test: Add -f argument to cancel all tests
    
    To make sure tests on all devices, enabled or not, are cancelled,
    specify -f when starting new loopback test.
    
    Signed-off-by: Ryan Lim <limryan@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/tools/loopback_test.c b/drivers/staging/greybus/tools/loopback_test.c
index 412e6dca0d08..f7f4cd6fb55b 100644
--- a/drivers/staging/greybus/tools/loopback_test.c
+++ b/drivers/staging/greybus/tools/loopback_test.c
@@ -91,6 +91,7 @@ struct loopback_test {
 	int async_outstanding_operations;
 	int us_wait;
 	int file_output;
+	int stop_all;
 	int poll_count;
 	char test_name[MAX_STR_LEN];
 	char sysfs_prefix[MAX_SYSFS_PATH];
@@ -207,6 +208,7 @@ void usage(void)
 	"   -c     Max number of outstanding operations for async operations\n"
 	"   -w     Wait in uSec between operations\n"
 	"   -z     Enable output to a CSV file (incompatible with -p)\n"
+	"   -f     When starting new loopback test, stop currently running tests on all devices\n"
 	"Examples:\n"
 	"  Send 10000 transfers with a packet size of 128 bytes to all active connections\n"
 	"  loopback_test -t transfer -s 128 -i 10000 -S /sys/bus/greybus/devices/ -D /sys/kernel/debug/gb_loopback/\n"
@@ -778,9 +780,11 @@ static void prepare_devices(struct loopback_test *t)
 {
 	int i;
 
-	/* Cancel any running tests */
+	/* Cancel any running tests on enabled devices. If
+	 * stop_all option is given, stop test on all devices.
+	 */
 	for (i = 0; i < t->device_count; i++)
-		if (device_enabled(t, i))
+		if (t->stop_all || device_enabled(t, i))
 			write_sysfs_val(t->devices[i].sysfs_entry, "type", 0);
 
 
@@ -901,7 +905,7 @@ int main(int argc, char *argv[])
 	memset(&t, 0, sizeof(t));
 
 	while ((o = getopt(argc, argv,
-			   "t:s:i:S:D:m:v::d::r::p::a::l::x::o:O:c:w:z::")) != -1) {
+			   "t:s:i:S:D:m:v::d::r::p::a::l::x::o:O:c:w:z::f::")) != -1) {
 		switch (o) {
 		case 't':
 			snprintf(t.test_name, MAX_STR_LEN, "%s", optarg);
@@ -957,6 +961,9 @@ int main(int argc, char *argv[])
 		case 'z':
 			t.file_output = 1;
 			break;
+		case 'f':
+			t.stop_all = 1;
+			break;
 		default:
 			usage();
 			return -EINVAL;

commit bf32654a24441230fac32479b6a5ba8bbfc3b731
Author: Ryan Lim <limryan@google.com>
Date:   Wed Jul 20 08:14:03 2016 -0700

    greybus: loopback_test: Fix -z argument bug
    
    The -z argument was missing the break statement needed in the switch
    block and was not in the getopt list.
    
    Signed-off-by: Ryan Lim <limryan@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/tools/loopback_test.c b/drivers/staging/greybus/tools/loopback_test.c
index ec448920b8e9..412e6dca0d08 100644
--- a/drivers/staging/greybus/tools/loopback_test.c
+++ b/drivers/staging/greybus/tools/loopback_test.c
@@ -901,7 +901,7 @@ int main(int argc, char *argv[])
 	memset(&t, 0, sizeof(t));
 
 	while ((o = getopt(argc, argv,
-			   "t:s:i:S:D:m:v::d::r::p::a::l::x::o:c:w:O:")) != -1) {
+			   "t:s:i:S:D:m:v::d::r::p::a::l::x::o:O:c:w:z::")) != -1) {
 		switch (o) {
 		case 't':
 			snprintf(t.test_name, MAX_STR_LEN, "%s", optarg);
@@ -956,6 +956,7 @@ int main(int argc, char *argv[])
 			break;
 		case 'z':
 			t.file_output = 1;
+			break;
 		default:
 			usage();
 			return -EINVAL;

commit 2861e2079081a156b0b731e1f6acb2aaf5605c5e
Author: Ryan Lim <limryan@google.com>
Date:   Wed Jul 20 08:14:02 2016 -0700

    greybus: loopback_test: Cancel only the tests running on selected devices
    
    When starting a loopback test, it cancels all currently running tests on
    all loopback devices. When -m argument is given, which runs the test on
    specific loopback devices, only the tests running on the selected
    devices need to be cancelled before starting new tests.
    
    Signed-off-by: Ryan Lim <limryan@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/tools/loopback_test.c b/drivers/staging/greybus/tools/loopback_test.c
index 25035f666372..ec448920b8e9 100644
--- a/drivers/staging/greybus/tools/loopback_test.c
+++ b/drivers/staging/greybus/tools/loopback_test.c
@@ -780,7 +780,8 @@ static void prepare_devices(struct loopback_test *t)
 
 	/* Cancel any running tests */
 	for (i = 0; i < t->device_count; i++)
-		write_sysfs_val(t->devices[i].sysfs_entry, "type", 0);
+		if (device_enabled(t, i))
+			write_sysfs_val(t->devices[i].sysfs_entry, "type", 0);
 
 
 	for (i = 0; i < t->device_count; i++) {

commit b797c43271f77f1dfd25953d72245cb8d0b832fc
Author: Axel Haslam <ahaslam@baylibre.com>
Date:   Tue May 24 16:21:29 2016 +0200

    greybus: Fix loopback app after rename to gpphy
    
    commit 6d94670 gpbridge: rename 'gpbridge' to 'gbphy' everywhere
    missed renaming the loopback test app. So do it too.
    
    Testing done: complie and run loopback test
    
    Signed-off-by: Axel Haslam <ahaslam@baylibre.com>
    Reviewed-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/tools/loopback_test.c b/drivers/staging/greybus/tools/loopback_test.c
index d8ff1bc0878a..25035f666372 100644
--- a/drivers/staging/greybus/tools/loopback_test.c
+++ b/drivers/staging/greybus/tools/loopback_test.c
@@ -59,10 +59,10 @@ struct loopback_results {
 	uint32_t apbridge_unipro_latency_min;
 	uint32_t apbridge_unipro_latency_jitter;
 
-	float gpbridge_firmware_latency_avg;
-	uint32_t gpbridge_firmware_latency_max;
-	uint32_t gpbridge_firmware_latency_min;
-	uint32_t gpbridge_firmware_latency_jitter;
+	float gbphy_firmware_latency_avg;
+	uint32_t gbphy_firmware_latency_max;
+	uint32_t gbphy_firmware_latency_min;
+	uint32_t gbphy_firmware_latency_jitter;
 
 	uint32_t error;
 };
@@ -155,17 +155,17 @@ GET_MAX(throughput_max);
 GET_MAX(request_max);
 GET_MAX(latency_max);
 GET_MAX(apbridge_unipro_latency_max);
-GET_MAX(gpbridge_firmware_latency_max);
+GET_MAX(gbphy_firmware_latency_max);
 GET_MIN(throughput_min);
 GET_MIN(request_min);
 GET_MIN(latency_min);
 GET_MIN(apbridge_unipro_latency_min);
-GET_MIN(gpbridge_firmware_latency_min);
+GET_MIN(gbphy_firmware_latency_min);
 GET_AVG(throughput_avg);
 GET_AVG(request_avg);
 GET_AVG(latency_avg);
 GET_AVG(apbridge_unipro_latency_avg);
-GET_AVG(gpbridge_firmware_latency_avg);
+GET_AVG(gbphy_firmware_latency_avg);
 
 void abort()
 {
@@ -351,20 +351,20 @@ static int get_results(struct loopback_test *t)
 		r->apbridge_unipro_latency_avg =
 			read_sysfs_float(d->sysfs_entry, "apbridge_unipro_latency_avg");
 
-		r->gpbridge_firmware_latency_min =
-			read_sysfs_int(d->sysfs_entry, "gpbridge_firmware_latency_min");
-		r->gpbridge_firmware_latency_max =
-			read_sysfs_int(d->sysfs_entry, "gpbridge_firmware_latency_max");
-		r->gpbridge_firmware_latency_avg =
-			read_sysfs_float(d->sysfs_entry, "gpbridge_firmware_latency_avg");
+		r->gbphy_firmware_latency_min =
+			read_sysfs_int(d->sysfs_entry, "gbphy_firmware_latency_min");
+		r->gbphy_firmware_latency_max =
+			read_sysfs_int(d->sysfs_entry, "gbphy_firmware_latency_max");
+		r->gbphy_firmware_latency_avg =
+			read_sysfs_float(d->sysfs_entry, "gbphy_firmware_latency_avg");
 
 		r->request_jitter = r->request_max - r->request_min;
 		r->latency_jitter = r->latency_max - r->latency_min;
 		r->throughput_jitter = r->throughput_max - r->throughput_min;
 		r->apbridge_unipro_latency_jitter =
 			r->apbridge_unipro_latency_max - r->apbridge_unipro_latency_min;
-		r->gpbridge_firmware_latency_jitter =
-			r->gpbridge_firmware_latency_max - r->gpbridge_firmware_latency_min;
+		r->gbphy_firmware_latency_jitter =
+			r->gbphy_firmware_latency_max - r->gbphy_firmware_latency_min;
 
 	}
 
@@ -391,20 +391,20 @@ static int get_results(struct loopback_test *t)
 		r->apbridge_unipro_latency_avg =
 			get_apbridge_unipro_latency_avg_aggregate(t);
 
-		r->gpbridge_firmware_latency_min =
-			get_gpbridge_firmware_latency_min_aggregate(t);
-		r->gpbridge_firmware_latency_max =
-			get_gpbridge_firmware_latency_max_aggregate(t);
-		r->gpbridge_firmware_latency_avg =
-			get_gpbridge_firmware_latency_avg_aggregate(t);
+		r->gbphy_firmware_latency_min =
+			get_gbphy_firmware_latency_min_aggregate(t);
+		r->gbphy_firmware_latency_max =
+			get_gbphy_firmware_latency_max_aggregate(t);
+		r->gbphy_firmware_latency_avg =
+			get_gbphy_firmware_latency_avg_aggregate(t);
 
 		r->request_jitter = r->request_max - r->request_min;
 		r->latency_jitter = r->latency_max - r->latency_min;
 		r->throughput_jitter = r->throughput_max - r->throughput_min;
 		r->apbridge_unipro_latency_jitter =
 			r->apbridge_unipro_latency_max - r->apbridge_unipro_latency_min;
-		r->gpbridge_firmware_latency_jitter =
-			r->gpbridge_firmware_latency_max - r->gpbridge_firmware_latency_min;
+		r->gbphy_firmware_latency_jitter =
+			r->gbphy_firmware_latency_max - r->gbphy_firmware_latency_min;
 
 	}
 
@@ -467,11 +467,11 @@ int format_output(struct loopback_test *t,
 			r->apbridge_unipro_latency_jitter);
 
 		len += snprintf(&buf[len], buf_len - len,
-			" gpbridge-latency usec:\tmin=%u max=%u average=%f jitter=%u\n",
-			r->gpbridge_firmware_latency_min,
-			r->gpbridge_firmware_latency_max,
-			r->gpbridge_firmware_latency_avg,
-			r->gpbridge_firmware_latency_jitter);
+			" gbphy-latency usec:\tmin=%u max=%u average=%f jitter=%u\n",
+			r->gbphy_firmware_latency_min,
+			r->gbphy_firmware_latency_max,
+			r->gbphy_firmware_latency_avg,
+			r->gbphy_firmware_latency_jitter);
 
 	} else {
 		len += snprintf(&buf[len], buf_len- len, ",%s,%s,%u,%u,%u",
@@ -503,10 +503,10 @@ int format_output(struct loopback_test *t,
 			r->apbridge_unipro_latency_jitter);
 
 		len += snprintf(&buf[len], buf_len - len, ",%u,%u,%f,%u",
-			r->gpbridge_firmware_latency_min,
-			r->gpbridge_firmware_latency_max,
-			r->gpbridge_firmware_latency_avg,
-			r->gpbridge_firmware_latency_jitter);
+			r->gbphy_firmware_latency_min,
+			r->gbphy_firmware_latency_max,
+			r->gbphy_firmware_latency_avg,
+			r->gbphy_firmware_latency_jitter);
 	}
 
 	printf("\n%s\n", buf);

commit 3b90040de82a43ee0538d36b32c9fa4cbbab59c6
Author: Axel Haslam <ahaslam@baylibre.com>
Date:   Fri Mar 11 13:19:30 2016 +0100

    greybus: loopback_test: handle SIGINT signal
    
    Adding a default timeout may not be representative of every
    usecase for gb_loopback. Also, tests may continue to run
    on the driver in case of a timeout.
    
    To avoid adding a default timeout, handle SIGINT so that when the user
    presses ctrl-c the test are stoped. The user can still specify a timeout
    value with the -O option.
    
    Signed-off-by: Axel Haslam <ahaslam@baylibre.com>
    Reviewed-by: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/tools/loopback_test.c b/drivers/staging/greybus/tools/loopback_test.c
index ab40bcf8ca0a..d8ff1bc0878a 100644
--- a/drivers/staging/greybus/tools/loopback_test.c
+++ b/drivers/staging/greybus/tools/loopback_test.c
@@ -17,13 +17,13 @@
 #include <time.h>
 #include <unistd.h>
 #include <dirent.h>
+#include <signal.h>
 
 #define MAX_NUM_DEVICES 10
 #define MAX_SYSFS_PATH	0x200
 #define CSV_MAX_LINE	0x1000
 #define SYSFS_MAX_INT	0x20
 #define MAX_STR_LEN	255
-#define DEFAULT_POLL_TIMEOUT_SEC 30
 #define DEFAULT_ASYNC_TIMEOUT 200000
 
 struct dict {
@@ -88,7 +88,6 @@ struct loopback_test {
 	int list_devices;
 	int use_async;
 	int async_timeout;
-	int poll_timeout;
 	int async_outstanding_operations;
 	int us_wait;
 	int file_output;
@@ -96,6 +95,7 @@ struct loopback_test {
 	char test_name[MAX_STR_LEN];
 	char sysfs_prefix[MAX_SYSFS_PATH];
 	char debugfs_prefix[MAX_SYSFS_PATH];
+	struct timespec poll_timeout;
 	struct loopback_device devices[MAX_NUM_DEVICES];
 	struct loopback_results aggregate_results;
 	struct pollfd fds[MAX_NUM_DEVICES];
@@ -706,22 +706,51 @@ static int is_complete(struct loopback_test *t)
 	return 1;
 }
 
+static void stop_tests(struct loopback_test *t)
+{
+	int i;
+
+	for (i = 0; i < t->device_count; i++) {
+		if (!device_enabled(t, i))
+			continue;
+		write_sysfs_val(t->devices[i].sysfs_entry, "type", 0);
+	}
+}
+
+static void handler(int sig) { /* do nothing */  }
+
 static int wait_for_complete(struct loopback_test *t)
 {
 	int number_of_events = 0;
 	char dummy;
 	int ret;
 	int i;
+	struct timespec *ts = NULL;
+	struct sigaction sa;
+	sigset_t mask_old, mask;
+
+	sigemptyset(&mask);
+	sigemptyset(&mask_old);
+	sigaddset(&mask, SIGINT);
+	sigprocmask(SIG_BLOCK, &mask, &mask_old);
+
+	sa.sa_handler = handler;
+	sa.sa_flags = 0;
+	sigemptyset(&sa.sa_mask);
+	if (sigaction(SIGINT, &sa, NULL) == -1) {
+		fprintf(stderr, "sigaction error\n");
+		return -1;
+	}
+
+	if (t->poll_timeout.tv_sec != 0)
+		ts = &t->poll_timeout;
 
 	while (1) {
-		ret = poll(t->fds, t->poll_count, t->poll_timeout * 1000);
-		if (ret == 0) {
-			fprintf(stderr, "Poll timmed out!\n");
-			return -1;
-		}
 
-		if (ret < 0) {
-			fprintf(stderr, "Poll Error!\n");
+		ret = ppoll(t->fds, t->poll_count, ts, &mask_old);
+		if (ret <= 0) {
+			stop_tests(t);
+			fprintf(stderr, "Poll exit with errno %d\n", errno);
 			return -1;
 		}
 
@@ -861,6 +890,7 @@ static int sanity_check(struct loopback_test *t)
 
 	return 0;
 }
+
 int main(int argc, char *argv[])
 {
 	int o, ret;
@@ -915,7 +945,7 @@ int main(int argc, char *argv[])
 			t.async_timeout = atoi(optarg);
 			break;
 		case 'O':
-			t.poll_timeout = atoi(optarg);
+			t.poll_timeout.tv_sec = atoi(optarg);
 			break;
 		case 'c':
 			t.async_outstanding_operations = atoi(optarg);
@@ -955,9 +985,6 @@ int main(int argc, char *argv[])
 	if (t.async_timeout == 0)
 		t.async_timeout = DEFAULT_ASYNC_TIMEOUT;
 
-	if (t.poll_timeout == 0)
-		t.poll_timeout = DEFAULT_POLL_TIMEOUT_SEC;
-
 	loopback_run(&t);
 
 	return 0;

commit 4b82dd7be3d3ea62c634bda6bd01666912bc7e79
Author: Axel Haslam <ahaslam@baylibre.com>
Date:   Tue Mar 8 10:03:40 2016 +0100

    greybus: loopback_test: Use timeout argument
    
    Patch "c3b0a32 Loopback_test: use poll instead of inotify"
    added a optional argument for the user to specify a timeout value,
    but did not use this parameter in the actual poll function. The
    default of 30 seconds is always used.
    
    Fix this by actually using the the poll_timeout parameter so the user
    can run long tests.
    
    Signed-off-by: Axel Haslam <ahaslam@baylibre.com>
    Reviewed-by: Patrick Titiano <ptitiano@baylibre.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/tools/loopback_test.c b/drivers/staging/greybus/tools/loopback_test.c
index 0abe62390b1b..ab40bcf8ca0a 100644
--- a/drivers/staging/greybus/tools/loopback_test.c
+++ b/drivers/staging/greybus/tools/loopback_test.c
@@ -714,7 +714,7 @@ static int wait_for_complete(struct loopback_test *t)
 	int i;
 
 	while (1) {
-		ret = poll(t->fds, t->poll_count, DEFAULT_POLL_TIMEOUT_SEC * 1000);
+		ret = poll(t->fds, t->poll_count, t->poll_timeout * 1000);
 		if (ret == 0) {
 			fprintf(stderr, "Poll timmed out!\n");
 			return -1;

commit 9250c0ee2626d371753027b1b5ede697676de6d1
Author: Axel Haslam <ahaslam@baylibre.com>
Date:   Fri Feb 26 11:39:49 2016 +0100

    greybus: Loopback_test: use poll instead of inotify
    
    Inotify does not handle sysfs events, so use poll instead.
    
    The loopback kernel driver will send a notification when the test is
    complete. So, open a poll file descriptor for every enabled device,
    and after starting the test, wait for an event from each device.
    After all events are received, read the total number of iterations
    and make sure the test is complete.
    
    Also, add missing stdint header which was included in inotify.
    
    Signed-off-by: Axel Haslam <ahaslam@baylibre.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/tools/loopback_test.c b/drivers/staging/greybus/tools/loopback_test.c
index 6178354fbb74..0abe62390b1b 100644
--- a/drivers/staging/greybus/tools/loopback_test.c
+++ b/drivers/staging/greybus/tools/loopback_test.c
@@ -11,7 +11,8 @@
 #include <stdio.h>
 #include <string.h>
 #include <stdlib.h>
-#include <sys/inotify.h>
+#include <stdint.h>
+#include <poll.h>
 #include <sys/types.h>
 #include <time.h>
 #include <unistd.h>
@@ -22,8 +23,7 @@
 #define CSV_MAX_LINE	0x1000
 #define SYSFS_MAX_INT	0x20
 #define MAX_STR_LEN	255
-#define MAX_TIMEOUT_COUNT 5
-#define TIMEOUT_SEC 1
+#define DEFAULT_POLL_TIMEOUT_SEC 30
 #define DEFAULT_ASYNC_TIMEOUT 200000
 
 struct dict {
@@ -71,7 +71,6 @@ struct loopback_device {
 	char name[MAX_SYSFS_PATH];
 	char sysfs_entry[MAX_SYSFS_PATH];
 	char debugfs_entry[MAX_SYSFS_PATH];
-	int inotify_wd;
 	struct loopback_results results;
 };
 
@@ -86,19 +85,22 @@ struct loopback_test {
 	int aggregate_output;
 	int test_id;
 	int device_count;
-	int inotify_fd;
 	int list_devices;
 	int use_async;
 	int async_timeout;
+	int poll_timeout;
 	int async_outstanding_operations;
 	int us_wait;
 	int file_output;
+	int poll_count;
 	char test_name[MAX_STR_LEN];
 	char sysfs_prefix[MAX_SYSFS_PATH];
 	char debugfs_prefix[MAX_SYSFS_PATH];
 	struct loopback_device devices[MAX_NUM_DEVICES];
 	struct loopback_results aggregate_results;
+	struct pollfd fds[MAX_NUM_DEVICES];
 };
+
 struct loopback_test t;
 
 /* Helper macros to calculate the aggregate results for all devices */
@@ -201,6 +203,7 @@ void usage(void)
 	"   -l     list found loopback devices and exit\n"
 	"   -x     Async - Enable async transfers\n"
 	"   -o     Async Timeout - Timeout in uSec for async operations\n"
+	"   -O     Poll loop time out in seconds(max time a test is expected to last, default: 30sec)\n"
 	"   -c     Max number of outstanding operations for async operations\n"
 	"   -w     Wait in uSec between operations\n"
 	"   -z     Enable output to a CSV file (incompatible with -p)\n"
@@ -638,58 +641,51 @@ int find_loopback_devices(struct loopback_test *t)
 	return ret;
 }
 
-
-static int register_for_notification(struct loopback_test *t)
+static int open_poll_files(struct loopback_test *t)
 {
-	char buf[MAX_SYSFS_PATH];
+	struct loopback_device *dev;
+	char buf[MAX_STR_LEN];
+	char dummy;
+	int fds_idx = 0;
 	int i;
 
-	t->inotify_fd = inotify_init();
-	if (t->inotify_fd < 0) {
-		fprintf(stderr, "inotify_init fail %s\n", strerror(errno));
-		abort();
-	}
-
 	for (i = 0; i < t->device_count; i++) {
+		dev = &t->devices[i];
+
 		if (!device_enabled(t, i))
 			continue;
 
-		snprintf(buf, sizeof(buf), "%s%s", t->devices[i].sysfs_entry,
-			"iteration_count");
-
-		t->devices[i].inotify_wd = inotify_add_watch(t->inotify_fd,
-							buf, IN_MODIFY);
-		if (t->devices[i].inotify_wd < 0) {
-			fprintf(stderr, "inotify_add_watch %s fail %s\n",
-				buf, strerror(errno));
-			close(t->inotify_fd);
-			abort();
+		snprintf(buf, sizeof(buf), "%s%s", dev->sysfs_entry, "iteration_count");
+		t->fds[fds_idx].fd = open(buf, O_RDONLY);
+		if (t->fds[fds_idx].fd < 0) {
+			fprintf(stderr, "Error opening poll file!\n");
+			goto err;
 		}
+		read(t->fds[fds_idx].fd, &dummy, 1);
+		t->fds[fds_idx].events = POLLERR|POLLPRI;
+		t->fds[fds_idx].revents = 0;
+		fds_idx++;
 	}
 
+	t->poll_count = fds_idx;
+
 	return 0;
+
+err:
+	for (i = 0; i < fds_idx; i++)
+		close(t->fds[fds_idx].fd);
+
+	return -1;
 }
 
-static int unregister_for_notification(struct loopback_test *t)
+static int close_poll_files(struct loopback_test *t)
 {
 	int i;
-	int ret = 0;
-
-	for (i = 0; i < t->device_count; i++) {
-		if (!device_enabled(t, i))
-			continue;
-
-		ret = inotify_rm_watch(t->inotify_fd, t->devices[i].inotify_wd);
-		if (ret) {
-			fprintf(stderr, "inotify_rm_watch error.\n");
-			return ret;
-		}
-	}
+	for (i = 0; i < t->poll_count; i++)
+		close(t->fds[i].fd);
 
-	close(t->inotify_fd);
 	return 0;
 }
-
 static int is_complete(struct loopback_test *t)
 {
 	int iteration_count;
@@ -712,39 +708,38 @@ static int is_complete(struct loopback_test *t)
 
 static int wait_for_complete(struct loopback_test *t)
 {
-	int remaining_timeouts = MAX_TIMEOUT_COUNT;
-	char buf[MAX_SYSFS_PATH];
-	struct timeval timeout;
-	fd_set read_fds;
+	int number_of_events = 0;
+	char dummy;
 	int ret;
+	int i;
 
 	while (1) {
-		/* Wait for change */
-		timeout.tv_sec = TIMEOUT_SEC;
-		timeout.tv_usec = 0;
-		FD_ZERO(&read_fds);
-		FD_SET(t->inotify_fd, &read_fds);
-		ret = select(FD_SETSIZE, &read_fds, NULL, NULL, &timeout);
-		if (ret < 0) {
-			fprintf(stderr, "Select error.\n");
+		ret = poll(t->fds, t->poll_count, DEFAULT_POLL_TIMEOUT_SEC * 1000);
+		if (ret == 0) {
+			fprintf(stderr, "Poll timmed out!\n");
 			return -1;
 		}
 
-		/* timeout - test may be finished.*/
-		if (!FD_ISSET(t->inotify_fd, &read_fds)) {
-			remaining_timeouts--;
-
-			if (is_complete(t))
-				return 0;
+		if (ret < 0) {
+			fprintf(stderr, "Poll Error!\n");
+			return -1;
+		}
 
-			if (!remaining_timeouts) {
-				fprintf(stderr, "Too many timeouts\n");
-				return -1;
+		for (i = 0; i < t->poll_count; i++) {
+			if (t->fds[i].revents & POLLPRI) {
+				/* Dummy read to clear the event */
+				read(t->fds[i].fd, &dummy, 1);
+				number_of_events++;
 			}
-		} else {
-			/* read to clear the event */
-			ret = read(t->inotify_fd, buf, sizeof(buf));
 		}
+
+		if (number_of_events == t->poll_count)
+			break;
+	}
+
+	if (!is_complete(t)) {
+		fprintf(stderr, "Iteration count did not finish!\n");
+		return -1;
 	}
 
 	return 0;
@@ -820,17 +815,17 @@ void loopback_run(struct loopback_test *t)
 
 	prepare_devices(t);
 
-	ret = register_for_notification(t);
+	ret = open_poll_files(t);
 	if (ret)
 		goto err;
 
 	start(t);
 
-	sleep(1);
-
-	wait_for_complete(t);
+	ret = wait_for_complete(t);
+	close_poll_files(t);
+	if (ret)
+		goto err;
 
-	unregister_for_notification(t);
 
 	get_results(t);
 
@@ -875,7 +870,7 @@ int main(int argc, char *argv[])
 	memset(&t, 0, sizeof(t));
 
 	while ((o = getopt(argc, argv,
-			   "t:s:i:S:D:m:v::d::r::p::a::l::x::o:c:w:")) != -1) {
+			   "t:s:i:S:D:m:v::d::r::p::a::l::x::o:c:w:O:")) != -1) {
 		switch (o) {
 		case 't':
 			snprintf(t.test_name, MAX_STR_LEN, "%s", optarg);
@@ -919,6 +914,9 @@ int main(int argc, char *argv[])
 		case 'o':
 			t.async_timeout = atoi(optarg);
 			break;
+		case 'O':
+			t.poll_timeout = atoi(optarg);
+			break;
 		case 'c':
 			t.async_outstanding_operations = atoi(optarg);
 			break;
@@ -957,6 +955,9 @@ int main(int argc, char *argv[])
 	if (t.async_timeout == 0)
 		t.async_timeout = DEFAULT_ASYNC_TIMEOUT;
 
+	if (t.poll_timeout == 0)
+		t.poll_timeout = DEFAULT_POLL_TIMEOUT_SEC;
+
 	loopback_run(&t);
 
 	return 0;

commit 3f830562deade2ab6163f07ee6829158cc070ee4
Author: Axel Haslam <ahaslam@baylibre.com>
Date:   Fri Jan 29 11:34:19 2016 +0100

    greybus: loopback_test: Decrease the max number of devices
    
    Its unrealistic to expect 50 loopback devices,
    and the mask parameter can hold up to "int" anyways
    so decrease to max number of devices to sane value.
    
    Signed-off-by: Axel Haslam <ahaslam@baylibre.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/tools/loopback_test.c b/drivers/staging/greybus/tools/loopback_test.c
index e8d35bd95cc7..6178354fbb74 100644
--- a/drivers/staging/greybus/tools/loopback_test.c
+++ b/drivers/staging/greybus/tools/loopback_test.c
@@ -17,7 +17,7 @@
 #include <unistd.h>
 #include <dirent.h>
 
-#define MAX_NUM_DEVICES 50
+#define MAX_NUM_DEVICES 10
 #define MAX_SYSFS_PATH	0x200
 #define CSV_MAX_LINE	0x1000
 #define SYSFS_MAX_INT	0x20

commit 5bee760890aff6dfef8b50c5e4167e9cd003ee7b
Author: Axel Haslam <ahaslam@baylibre.com>
Date:   Tue Jan 26 21:26:02 2016 +0100

    greybus: loopback_test: make output to csv file a parameter option
    
    Its useful to get a CSV output on stdout for test frameworks to read
    and parse the results. However, a csv file is not always needed.
    
    Add the -z option to  create/append a csv file only when the user
    asks for it.
    
    Signed-off-by: Axel Haslam <ahaslam@baylibre.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/tools/loopback_test.c b/drivers/staging/greybus/tools/loopback_test.c
index 27c733d1c82e..e8d35bd95cc7 100644
--- a/drivers/staging/greybus/tools/loopback_test.c
+++ b/drivers/staging/greybus/tools/loopback_test.c
@@ -92,6 +92,7 @@ struct loopback_test {
 	int async_timeout;
 	int async_outstanding_operations;
 	int us_wait;
+	int file_output;
 	char test_name[MAX_STR_LEN];
 	char sysfs_prefix[MAX_SYSFS_PATH];
 	char debugfs_prefix[MAX_SYSFS_PATH];
@@ -202,6 +203,7 @@ void usage(void)
 	"   -o     Async Timeout - Timeout in uSec for async operations\n"
 	"   -c     Max number of outstanding operations for async operations\n"
 	"   -w     Wait in uSec between operations\n"
+	"   -z     Enable output to a CSV file (incompatible with -p)\n"
 	"Examples:\n"
 	"  Send 10000 transfers with a packet size of 128 bytes to all active connections\n"
 	"  loopback_test -t transfer -s 128 -i 10000 -S /sys/bus/greybus/devices/ -D /sys/kernel/debug/gb_loopback/\n"
@@ -527,7 +529,7 @@ static int log_results(struct loopback_test *t)
 	* append to the same CSV with datestamp - representing each test
 	* dataset.
 	*/
-	if (!t->porcelain) {
+	if (t->file_output && !t->porcelain) {
 		snprintf(file_name, sizeof(file_name), "%s_%d_%d.csv",
 			t->test_name, t->size, t->iteration_max);
 
@@ -545,7 +547,7 @@ static int log_results(struct loopback_test *t)
 		len = format_output(t, &t->devices[i].results,
 					t->devices[i].name,
 					data, sizeof(data), &tm);
-		if (!t->porcelain) {
+		if (t->file_output && !t->porcelain) {
 			ret = write(fd, data, len);
 			if (ret == -1)
 				fprintf(stderr, "unable to write %d bytes to csv.\n", len);
@@ -557,14 +559,14 @@ static int log_results(struct loopback_test *t)
 	if (t->aggregate_output) {
 		len = format_output(t, &t->aggregate_results, "aggregate",
 					data, sizeof(data), &tm);
-		if (!t->porcelain) {
+		if (t->file_output && !t->porcelain) {
 			ret = write(fd, data, len);
 			if (ret == -1)
 				fprintf(stderr, "unable to write %d bytes to csv.\n", len);
 		}
 	}
 
-	if (!t->porcelain)
+	if (t->file_output && !t->porcelain)
 		close(fd);
 
 	return 0;
@@ -923,6 +925,8 @@ int main(int argc, char *argv[])
 		case 'w':
 			t.us_wait = atoi(optarg);
 			break;
+		case 'z':
+			t.file_output = 1;
 		default:
 			usage();
 			return -EINVAL;

commit d5bc9607f749a241b2491f8f8b07986ba7655350
Author: Greg Kroah-Hartman <gregkh@google.com>
Date:   Tue Dec 15 13:57:22 2015 -0800

    greybus: loopback_test: null terminate the dict structure
    
    This lets us test for any number of entries, no need to do an
    ARRAY_SIZE-type comparison.  This fixes a build warning of comparing
    signed/unsigned values.)
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/tools/loopback_test.c b/drivers/staging/greybus/tools/loopback_test.c
index 5c2a9fcbd68b..27c733d1c82e 100644
--- a/drivers/staging/greybus/tools/loopback_test.c
+++ b/drivers/staging/greybus/tools/loopback_test.c
@@ -34,7 +34,8 @@ struct dict {
 static struct dict dict[] = {
 	{"ping", 2},
 	{"transfer", 3},
-	{"sink", 4}
+	{"sink", 4},
+	{NULL,}		/* list termination */
 };
 
 struct loopback_results {
@@ -805,7 +806,7 @@ void loopback_run(struct loopback_test *t)
 	int i;
 	int ret;
 
-	for (i = 0; i < sizeof(dict) / sizeof(struct dict); i++) {
+	for (i = 0; dict[i].name != NULL; i++) {
 		if (strstr(dict[i].name, t->test_name))
 			t->test_id = dict[i].type;
 	}

commit 6bfff1dcb2766ebef60a288601ff4cccbb1f6e54
Author: Greg Kroah-Hartman <gregkh@google.com>
Date:   Tue Dec 15 13:55:05 2015 -0800

    greybus: loopback_test: fix warning about signed/unsigned comparison
    
    We read an int, don't treat it as a unsigned value, especially when
    comparing it to a signed value.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/tools/loopback_test.c b/drivers/staging/greybus/tools/loopback_test.c
index 55b3102d5a6e..5c2a9fcbd68b 100644
--- a/drivers/staging/greybus/tools/loopback_test.c
+++ b/drivers/staging/greybus/tools/loopback_test.c
@@ -689,7 +689,7 @@ static int unregister_for_notification(struct loopback_test *t)
 
 static int is_complete(struct loopback_test *t)
 {
-	uint32_t iteration_count = 0;
+	int iteration_count;
 	int i;
 
 	for (i = 0; i < t->device_count; i++) {

commit 6b0658f68786110f41cd82558bd97447e4b14203
Author: Greg Kroah-Hartman <gregkh@google.com>
Date:   Tue Dec 15 12:46:22 2015 -0800

    greybus: tools: Add tools directory to greybus repo and add loopback
    
    Move the loopback test to the greybus main repo, as we will be adding
    more tests over time and it doesn't need to be burried in the gbsim
    repo.
    
    This moves the latest version from gbsim to this repo and fixes up the
    Makefile to be a bit more "smart" when building the code.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/tools/loopback_test.c b/drivers/staging/greybus/tools/loopback_test.c
new file mode 100644
index 000000000000..55b3102d5a6e
--- /dev/null
+++ b/drivers/staging/greybus/tools/loopback_test.c
@@ -0,0 +1,958 @@
+/*
+ * Loopback test application
+ *
+ * Copyright 2015 Google Inc.
+ * Copyright 2015 Linaro Ltd.
+ *
+ * Provided under the three clause BSD license found in the LICENSE file.
+ */
+#include <errno.h>
+#include <fcntl.h>
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <sys/inotify.h>
+#include <sys/types.h>
+#include <time.h>
+#include <unistd.h>
+#include <dirent.h>
+
+#define MAX_NUM_DEVICES 50
+#define MAX_SYSFS_PATH	0x200
+#define CSV_MAX_LINE	0x1000
+#define SYSFS_MAX_INT	0x20
+#define MAX_STR_LEN	255
+#define MAX_TIMEOUT_COUNT 5
+#define TIMEOUT_SEC 1
+#define DEFAULT_ASYNC_TIMEOUT 200000
+
+struct dict {
+	char *name;
+	int type;
+};
+
+static struct dict dict[] = {
+	{"ping", 2},
+	{"transfer", 3},
+	{"sink", 4}
+};
+
+struct loopback_results {
+	float latency_avg;
+	uint32_t latency_max;
+	uint32_t latency_min;
+	uint32_t latency_jitter;
+
+	float request_avg;
+	uint32_t request_max;
+	uint32_t request_min;
+	uint32_t request_jitter;
+
+	float throughput_avg;
+	uint32_t throughput_max;
+	uint32_t throughput_min;
+	uint32_t throughput_jitter;
+
+	float apbridge_unipro_latency_avg;
+	uint32_t apbridge_unipro_latency_max;
+	uint32_t apbridge_unipro_latency_min;
+	uint32_t apbridge_unipro_latency_jitter;
+
+	float gpbridge_firmware_latency_avg;
+	uint32_t gpbridge_firmware_latency_max;
+	uint32_t gpbridge_firmware_latency_min;
+	uint32_t gpbridge_firmware_latency_jitter;
+
+	uint32_t error;
+};
+
+struct loopback_device {
+	char name[MAX_SYSFS_PATH];
+	char sysfs_entry[MAX_SYSFS_PATH];
+	char debugfs_entry[MAX_SYSFS_PATH];
+	int inotify_wd;
+	struct loopback_results results;
+};
+
+struct loopback_test {
+	int verbose;
+	int debug;
+	int raw_data_dump;
+	int porcelain;
+	int mask;
+	int size;
+	int iteration_max;
+	int aggregate_output;
+	int test_id;
+	int device_count;
+	int inotify_fd;
+	int list_devices;
+	int use_async;
+	int async_timeout;
+	int async_outstanding_operations;
+	int us_wait;
+	char test_name[MAX_STR_LEN];
+	char sysfs_prefix[MAX_SYSFS_PATH];
+	char debugfs_prefix[MAX_SYSFS_PATH];
+	struct loopback_device devices[MAX_NUM_DEVICES];
+	struct loopback_results aggregate_results;
+};
+struct loopback_test t;
+
+/* Helper macros to calculate the aggregate results for all devices */
+static inline int device_enabled(struct loopback_test *t, int dev_idx);
+
+#define GET_MAX(field)							\
+static int get_##field##_aggregate(struct loopback_test *t)		\
+{									\
+	uint32_t max = 0;						\
+	int i;								\
+	for (i = 0; i < t->device_count; i++) {				\
+		if (!device_enabled(t, i))				\
+			continue;					\
+		if (t->devices[i].results.field > max)			\
+			max = t->devices[i].results.field;		\
+	}								\
+	return max;							\
+}									\
+
+#define GET_MIN(field)							\
+static int get_##field##_aggregate(struct loopback_test *t)		\
+{									\
+	uint32_t min = ~0;						\
+	int i;								\
+	for (i = 0; i < t->device_count; i++) {				\
+		if (!device_enabled(t, i))				\
+			continue;					\
+		if (t->devices[i].results.field < min)			\
+			min = t->devices[i].results.field;		\
+	}								\
+	return min;							\
+}									\
+
+#define GET_AVG(field)							\
+static int get_##field##_aggregate(struct loopback_test *t)		\
+{									\
+	uint32_t val = 0;						\
+	uint32_t count = 0;						\
+	int i;								\
+	for (i = 0; i < t->device_count; i++) {				\
+		if (!device_enabled(t, i))				\
+			continue;					\
+		count++;						\
+		val += t->devices[i].results.field;			\
+	}								\
+	if (count)							\
+		val /= count;						\
+	return val;							\
+}									\
+
+GET_MAX(throughput_max);
+GET_MAX(request_max);
+GET_MAX(latency_max);
+GET_MAX(apbridge_unipro_latency_max);
+GET_MAX(gpbridge_firmware_latency_max);
+GET_MIN(throughput_min);
+GET_MIN(request_min);
+GET_MIN(latency_min);
+GET_MIN(apbridge_unipro_latency_min);
+GET_MIN(gpbridge_firmware_latency_min);
+GET_AVG(throughput_avg);
+GET_AVG(request_avg);
+GET_AVG(latency_avg);
+GET_AVG(apbridge_unipro_latency_avg);
+GET_AVG(gpbridge_firmware_latency_avg);
+
+void abort()
+{
+	_exit(1);
+}
+
+void usage(void)
+{
+	fprintf(stderr, "Usage: loopback_test TEST [SIZE] ITERATIONS [SYSPATH] [DBGPATH]\n\n"
+	"  Run TEST for a number of ITERATIONS with operation data SIZE bytes\n"
+	"  TEST may be \'ping\' \'transfer\' or \'sink\'\n"
+	"  SIZE indicates the size of transfer <= greybus max payload bytes\n"
+	"  ITERATIONS indicates the number of times to execute TEST at SIZE bytes\n"
+	"             Note if ITERATIONS is set to zero then this utility will\n"
+	"             initiate an infinite (non terminating) test and exit\n"
+	"             without logging any metrics data\n"
+	"  SYSPATH indicates the sysfs path for the loopback greybus entries e.g.\n"
+	"          /sys/bus/greybus/devices\n"
+	"  DBGPATH indicates the debugfs path for the loopback greybus entries e.g.\n"
+	"          /sys/kernel/debug/gb_loopback/\n"
+	" Mandatory arguments\n"
+	"   -t     must be one of the test names - sink, transfer or ping\n"
+	"   -i     iteration count - the number of iterations to run the test over\n"
+	" Optional arguments\n"
+	"   -S     sysfs location - location for greybus 'endo' entires default /sys/bus/greybus/devices/\n"
+	"   -D     debugfs location - location for loopback debugfs entries default /sys/kernel/debug/gb_loopback/\n"
+	"   -s     size of data packet to send during test - defaults to zero\n"
+	"   -m     mask - a bit mask of connections to include example: -m 8 = 4th connection -m 9 = 1st and 4th connection etc\n"
+	"                 default is zero which means broadcast to all connections\n"
+	"   -v     verbose output\n"
+	"   -d     debug output\n"
+	"   -r     raw data output - when specified the full list of latency values are included in the output CSV\n"
+	"   -p     porcelain - when specified printout is in a user-friendly non-CSV format. This option suppresses writing to CSV file\n"
+	"   -a     aggregate - show aggregation of all enabled devices\n"
+	"   -l     list found loopback devices and exit\n"
+	"   -x     Async - Enable async transfers\n"
+	"   -o     Async Timeout - Timeout in uSec for async operations\n"
+	"   -c     Max number of outstanding operations for async operations\n"
+	"   -w     Wait in uSec between operations\n"
+	"Examples:\n"
+	"  Send 10000 transfers with a packet size of 128 bytes to all active connections\n"
+	"  loopback_test -t transfer -s 128 -i 10000 -S /sys/bus/greybus/devices/ -D /sys/kernel/debug/gb_loopback/\n"
+	"  loopback_test -t transfer -s 128 -i 10000 -m 0\n"
+	"  Send 10000 transfers with a packet size of 128 bytes to connection 1 and 4\n"
+	"  loopback_test -t transfer -s 128 -i 10000 -m 9\n"
+	"  loopback_test -t ping -s 0 128 -i -S /sys/bus/greybus/devices/ -D /sys/kernel/debug/gb_loopback/\n"
+	"  loopback_test -t sink -s 2030 -i 32768 -S /sys/bus/greybus/devices/ -D /sys/kernel/debug/gb_loopback/\n");
+	abort();
+}
+
+static inline int device_enabled(struct loopback_test *t, int dev_idx)
+{
+	if (!t->mask || (t->mask & (1 << dev_idx)))
+		return 1;
+
+	return 0;
+}
+
+static void show_loopback_devices(struct loopback_test *t)
+{
+	int i;
+
+	if (t->device_count == 0) {
+		printf("No loopback devices.\n");
+		return;
+	}
+
+	for (i = 0; i < t->device_count; i++)
+		printf("device[%d] = %s\n", i, t->devices[i].name);
+
+}
+
+int open_sysfs(const char *sys_pfx, const char *node, int flags)
+{
+	int fd;
+	char path[MAX_SYSFS_PATH];
+
+	snprintf(path, sizeof(path), "%s%s", sys_pfx, node);
+	fd = open(path, flags);
+	if (fd < 0) {
+		fprintf(stderr, "unable to open %s\n", path);
+		abort();
+	}
+	return fd;
+}
+
+int read_sysfs_int_fd(int fd, const char *sys_pfx, const char *node)
+{
+	char buf[SYSFS_MAX_INT];
+
+	if (read(fd, buf, sizeof(buf)) < 0) {
+		fprintf(stderr, "unable to read from %s%s %s\n", sys_pfx, node,
+			strerror(errno));
+		close(fd);
+		abort();
+	}
+	return atoi(buf);
+}
+
+float read_sysfs_float_fd(int fd, const char *sys_pfx, const char *node)
+{
+	char buf[SYSFS_MAX_INT];
+
+	if (read(fd, buf, sizeof(buf)) < 0) {
+
+		fprintf(stderr, "unable to read from %s%s %s\n", sys_pfx, node,
+			strerror(errno));
+		close(fd);
+		abort();
+	}
+	return atof(buf);
+}
+
+int read_sysfs_int(const char *sys_pfx, const char *node)
+{
+	int fd, val;
+
+	fd = open_sysfs(sys_pfx, node, O_RDONLY);
+	val = read_sysfs_int_fd(fd, sys_pfx, node);
+	close(fd);
+	return val;
+}
+
+float read_sysfs_float(const char *sys_pfx, const char *node)
+{
+	int fd;
+	float val;
+
+	fd = open_sysfs(sys_pfx, node, O_RDONLY);
+	val = read_sysfs_float_fd(fd, sys_pfx, node);
+	close(fd);
+	return val;
+}
+
+void write_sysfs_val(const char *sys_pfx, const char *node, int val)
+{
+	int fd, len;
+	char buf[SYSFS_MAX_INT];
+
+	fd = open_sysfs(sys_pfx, node, O_RDWR);
+	len = snprintf(buf, sizeof(buf), "%d", val);
+	if (write(fd, buf, len) < 0) {
+		fprintf(stderr, "unable to write to %s%s %s\n", sys_pfx, node,
+			strerror(errno));
+		close(fd);
+		abort();
+	}
+	close(fd);
+}
+
+static int get_results(struct loopback_test *t)
+{
+	struct loopback_device *d;
+	struct loopback_results *r;
+	int i;
+
+	for (i = 0; i < t->device_count; i++) {
+		if (!device_enabled(t, i))
+			continue;
+
+		d = &t->devices[i];
+		r = &d->results;
+
+		r->error = read_sysfs_int(d->sysfs_entry, "error");
+		r->request_min = read_sysfs_int(d->sysfs_entry, "requests_per_second_min");
+		r->request_max = read_sysfs_int(d->sysfs_entry, "requests_per_second_max");
+		r->request_avg = read_sysfs_float(d->sysfs_entry, "requests_per_second_avg");
+
+		r->latency_min = read_sysfs_int(d->sysfs_entry, "latency_min");
+		r->latency_max = read_sysfs_int(d->sysfs_entry, "latency_max");
+		r->latency_avg = read_sysfs_float(d->sysfs_entry, "latency_avg");
+
+		r->throughput_min = read_sysfs_int(d->sysfs_entry, "throughput_min");
+		r->throughput_max = read_sysfs_int(d->sysfs_entry, "throughput_max");
+		r->throughput_avg = read_sysfs_float(d->sysfs_entry, "throughput_avg");
+
+		r->apbridge_unipro_latency_min =
+			read_sysfs_int(d->sysfs_entry, "apbridge_unipro_latency_min");
+		r->apbridge_unipro_latency_max =
+			read_sysfs_int(d->sysfs_entry, "apbridge_unipro_latency_max");
+		r->apbridge_unipro_latency_avg =
+			read_sysfs_float(d->sysfs_entry, "apbridge_unipro_latency_avg");
+
+		r->gpbridge_firmware_latency_min =
+			read_sysfs_int(d->sysfs_entry, "gpbridge_firmware_latency_min");
+		r->gpbridge_firmware_latency_max =
+			read_sysfs_int(d->sysfs_entry, "gpbridge_firmware_latency_max");
+		r->gpbridge_firmware_latency_avg =
+			read_sysfs_float(d->sysfs_entry, "gpbridge_firmware_latency_avg");
+
+		r->request_jitter = r->request_max - r->request_min;
+		r->latency_jitter = r->latency_max - r->latency_min;
+		r->throughput_jitter = r->throughput_max - r->throughput_min;
+		r->apbridge_unipro_latency_jitter =
+			r->apbridge_unipro_latency_max - r->apbridge_unipro_latency_min;
+		r->gpbridge_firmware_latency_jitter =
+			r->gpbridge_firmware_latency_max - r->gpbridge_firmware_latency_min;
+
+	}
+
+	/*calculate the aggregate results of all enabled devices */
+	if (t->aggregate_output) {
+		r = &t->aggregate_results;
+
+		r->request_min = get_request_min_aggregate(t);
+		r->request_max = get_request_max_aggregate(t);
+		r->request_avg = get_request_avg_aggregate(t);
+
+		r->latency_min = get_latency_min_aggregate(t);
+		r->latency_max = get_latency_max_aggregate(t);
+		r->latency_avg = get_latency_avg_aggregate(t);
+
+		r->throughput_min = get_throughput_min_aggregate(t);
+		r->throughput_max = get_throughput_max_aggregate(t);
+		r->throughput_avg = get_throughput_avg_aggregate(t);
+
+		r->apbridge_unipro_latency_min =
+			get_apbridge_unipro_latency_min_aggregate(t);
+		r->apbridge_unipro_latency_max =
+			get_apbridge_unipro_latency_max_aggregate(t);
+		r->apbridge_unipro_latency_avg =
+			get_apbridge_unipro_latency_avg_aggregate(t);
+
+		r->gpbridge_firmware_latency_min =
+			get_gpbridge_firmware_latency_min_aggregate(t);
+		r->gpbridge_firmware_latency_max =
+			get_gpbridge_firmware_latency_max_aggregate(t);
+		r->gpbridge_firmware_latency_avg =
+			get_gpbridge_firmware_latency_avg_aggregate(t);
+
+		r->request_jitter = r->request_max - r->request_min;
+		r->latency_jitter = r->latency_max - r->latency_min;
+		r->throughput_jitter = r->throughput_max - r->throughput_min;
+		r->apbridge_unipro_latency_jitter =
+			r->apbridge_unipro_latency_max - r->apbridge_unipro_latency_min;
+		r->gpbridge_firmware_latency_jitter =
+			r->gpbridge_firmware_latency_max - r->gpbridge_firmware_latency_min;
+
+	}
+
+	return 0;
+}
+
+void log_csv_error(int len, int err)
+{
+	fprintf(stderr, "unable to write %d bytes to csv %s\n", len,
+		strerror(err));
+}
+
+int format_output(struct loopback_test *t,
+			struct loopback_results *r,
+			const char *dev_name,
+			char *buf, int buf_len,
+			struct tm *tm)
+{
+	int len = 0;
+
+	memset(buf, 0x00, buf_len);
+	len = snprintf(buf, buf_len, "%u-%u-%u %u:%u:%u",
+		       tm->tm_year + 1900, tm->tm_mon + 1, tm->tm_mday,
+		       tm->tm_hour, tm->tm_min, tm->tm_sec);
+
+	if (t->porcelain) {
+		len += snprintf(&buf[len], buf_len - len,
+			"\n test:\t\t\t%s\n path:\t\t\t%s\n size:\t\t\t%u\n iterations:\t\t%u\n errors:\t\t%u\n async:\t\t\t%s\n",
+			t->test_name,
+			dev_name,
+			t->size,
+			t->iteration_max,
+			r->error,
+			t->use_async ? "Enabled" : "Disabled");
+
+		len += snprintf(&buf[len], buf_len - len,
+			" requests per-sec:\tmin=%u, max=%u, average=%f, jitter=%u\n",
+			r->request_min,
+			r->request_max,
+			r->request_avg,
+			r->request_jitter);
+
+		len += snprintf(&buf[len], buf_len - len,
+			" ap-throughput B/s:\tmin=%u max=%u average=%f jitter=%u\n",
+			r->throughput_min,
+			r->throughput_max,
+			r->throughput_avg,
+			r->throughput_jitter);
+		len += snprintf(&buf[len], buf_len - len,
+			" ap-latency usec:\tmin=%u max=%u average=%f jitter=%u\n",
+			r->latency_min,
+			r->latency_max,
+			r->latency_avg,
+			r->latency_jitter);
+		len += snprintf(&buf[len], buf_len - len,
+			" apbridge-latency usec:\tmin=%u max=%u average=%f jitter=%u\n",
+			r->apbridge_unipro_latency_min,
+			r->apbridge_unipro_latency_max,
+			r->apbridge_unipro_latency_avg,
+			r->apbridge_unipro_latency_jitter);
+
+		len += snprintf(&buf[len], buf_len - len,
+			" gpbridge-latency usec:\tmin=%u max=%u average=%f jitter=%u\n",
+			r->gpbridge_firmware_latency_min,
+			r->gpbridge_firmware_latency_max,
+			r->gpbridge_firmware_latency_avg,
+			r->gpbridge_firmware_latency_jitter);
+
+	} else {
+		len += snprintf(&buf[len], buf_len- len, ",%s,%s,%u,%u,%u",
+			t->test_name, dev_name, t->size, t->iteration_max,
+			r->error);
+
+		len += snprintf(&buf[len], buf_len - len, ",%u,%u,%f,%u",
+			r->request_min,
+			r->request_max,
+			r->request_avg,
+			r->request_jitter);
+
+		len += snprintf(&buf[len], buf_len - len, ",%u,%u,%f,%u",
+			r->latency_min,
+			r->latency_max,
+			r->latency_avg,
+			r->latency_jitter);
+
+		len += snprintf(&buf[len], buf_len - len, ",%u,%u,%f,%u",
+			r->throughput_min,
+			r->throughput_max,
+			r->throughput_avg,
+			r->throughput_jitter);
+
+		len += snprintf(&buf[len], buf_len - len, ",%u,%u,%f,%u",
+			r->apbridge_unipro_latency_min,
+			r->apbridge_unipro_latency_max,
+			r->apbridge_unipro_latency_avg,
+			r->apbridge_unipro_latency_jitter);
+
+		len += snprintf(&buf[len], buf_len - len, ",%u,%u,%f,%u",
+			r->gpbridge_firmware_latency_min,
+			r->gpbridge_firmware_latency_max,
+			r->gpbridge_firmware_latency_avg,
+			r->gpbridge_firmware_latency_jitter);
+	}
+
+	printf("\n%s\n", buf);
+
+	return len;
+}
+
+static int log_results(struct loopback_test *t)
+{
+	int fd, i, len, ret;
+	struct tm tm;
+	time_t local_time;
+	mode_t mode = S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH;
+	char file_name[MAX_SYSFS_PATH];
+	char data[CSV_MAX_LINE];
+
+	local_time = time(NULL);
+	tm = *localtime(&local_time);
+
+	/*
+	* file name will test_name_size_iteration_max.csv
+	* every time the same test with the same parameters is run we will then
+	* append to the same CSV with datestamp - representing each test
+	* dataset.
+	*/
+	if (!t->porcelain) {
+		snprintf(file_name, sizeof(file_name), "%s_%d_%d.csv",
+			t->test_name, t->size, t->iteration_max);
+
+		fd = open(file_name, O_WRONLY | O_CREAT | O_APPEND, mode);
+		if (fd < 0) {
+			fprintf(stderr, "unable to open %s for appendation\n", file_name);
+			abort();
+		}
+
+	}
+	for (i = 0; i < t->device_count; i++) {
+		if (!device_enabled(t, i))
+			continue;
+
+		len = format_output(t, &t->devices[i].results,
+					t->devices[i].name,
+					data, sizeof(data), &tm);
+		if (!t->porcelain) {
+			ret = write(fd, data, len);
+			if (ret == -1)
+				fprintf(stderr, "unable to write %d bytes to csv.\n", len);
+		}
+
+	}
+
+
+	if (t->aggregate_output) {
+		len = format_output(t, &t->aggregate_results, "aggregate",
+					data, sizeof(data), &tm);
+		if (!t->porcelain) {
+			ret = write(fd, data, len);
+			if (ret == -1)
+				fprintf(stderr, "unable to write %d bytes to csv.\n", len);
+		}
+	}
+
+	if (!t->porcelain)
+		close(fd);
+
+	return 0;
+}
+
+int is_loopback_device(const char *path, const char *node)
+{
+	char file[MAX_SYSFS_PATH];
+
+	snprintf(file, MAX_SYSFS_PATH, "%s%s/iteration_count", path, node);
+	if (access(file, F_OK) == 0)
+		return 1;
+	return 0;
+}
+
+int find_loopback_devices(struct loopback_test *t)
+{
+	struct dirent **namelist;
+	int i, n, ret;
+	unsigned int dev_id;
+	struct loopback_device *d;
+
+	n = scandir(t->sysfs_prefix, &namelist, NULL, alphasort);
+	if (n < 0) {
+		perror("scandir");
+		ret = -ENODEV;
+		goto baddir;
+	}
+
+	/* Don't include '.' and '..' */
+	if (n <= 2) {
+		ret = -ENOMEM;
+		goto done;
+	}
+
+	for (i = 0; i < n; i++) {
+		ret = sscanf(namelist[i]->d_name, "gb_loopback%u", &dev_id);
+		if (ret != 1)
+			continue;
+
+		if (!is_loopback_device(t->sysfs_prefix, namelist[i]->d_name))
+			continue;
+
+		if (t->device_count == MAX_NUM_DEVICES) {
+			fprintf(stderr, "max number of devices reached!\n");
+			break;
+		}
+
+		d = &t->devices[t->device_count++];
+		snprintf(d->name, MAX_STR_LEN, "gb_loopback%u", dev_id);
+
+		snprintf(d->sysfs_entry, MAX_SYSFS_PATH, "%s%s/",
+			t->sysfs_prefix, d->name);
+
+		snprintf(d->debugfs_entry, MAX_SYSFS_PATH, "%sraw_latency_%s",
+			t->debugfs_prefix, d->name);
+
+		if (t->debug)
+			printf("add %s %s\n", d->sysfs_entry,
+				d->debugfs_entry);
+	}
+
+	ret = 0;
+done:
+	for (i = 0; i < n; i++)
+		free(namelist[n]);
+	free(namelist);
+baddir:
+	return ret;
+}
+
+
+static int register_for_notification(struct loopback_test *t)
+{
+	char buf[MAX_SYSFS_PATH];
+	int i;
+
+	t->inotify_fd = inotify_init();
+	if (t->inotify_fd < 0) {
+		fprintf(stderr, "inotify_init fail %s\n", strerror(errno));
+		abort();
+	}
+
+	for (i = 0; i < t->device_count; i++) {
+		if (!device_enabled(t, i))
+			continue;
+
+		snprintf(buf, sizeof(buf), "%s%s", t->devices[i].sysfs_entry,
+			"iteration_count");
+
+		t->devices[i].inotify_wd = inotify_add_watch(t->inotify_fd,
+							buf, IN_MODIFY);
+		if (t->devices[i].inotify_wd < 0) {
+			fprintf(stderr, "inotify_add_watch %s fail %s\n",
+				buf, strerror(errno));
+			close(t->inotify_fd);
+			abort();
+		}
+	}
+
+	return 0;
+}
+
+static int unregister_for_notification(struct loopback_test *t)
+{
+	int i;
+	int ret = 0;
+
+	for (i = 0; i < t->device_count; i++) {
+		if (!device_enabled(t, i))
+			continue;
+
+		ret = inotify_rm_watch(t->inotify_fd, t->devices[i].inotify_wd);
+		if (ret) {
+			fprintf(stderr, "inotify_rm_watch error.\n");
+			return ret;
+		}
+	}
+
+	close(t->inotify_fd);
+	return 0;
+}
+
+static int is_complete(struct loopback_test *t)
+{
+	uint32_t iteration_count = 0;
+	int i;
+
+	for (i = 0; i < t->device_count; i++) {
+		if (!device_enabled(t, i))
+			continue;
+
+		iteration_count = read_sysfs_int(t->devices[i].sysfs_entry,
+						 "iteration_count");
+
+		/* at least one device did not finish yet */
+		if (iteration_count != t->iteration_max)
+			return 0;
+	}
+
+	return 1;
+}
+
+static int wait_for_complete(struct loopback_test *t)
+{
+	int remaining_timeouts = MAX_TIMEOUT_COUNT;
+	char buf[MAX_SYSFS_PATH];
+	struct timeval timeout;
+	fd_set read_fds;
+	int ret;
+
+	while (1) {
+		/* Wait for change */
+		timeout.tv_sec = TIMEOUT_SEC;
+		timeout.tv_usec = 0;
+		FD_ZERO(&read_fds);
+		FD_SET(t->inotify_fd, &read_fds);
+		ret = select(FD_SETSIZE, &read_fds, NULL, NULL, &timeout);
+		if (ret < 0) {
+			fprintf(stderr, "Select error.\n");
+			return -1;
+		}
+
+		/* timeout - test may be finished.*/
+		if (!FD_ISSET(t->inotify_fd, &read_fds)) {
+			remaining_timeouts--;
+
+			if (is_complete(t))
+				return 0;
+
+			if (!remaining_timeouts) {
+				fprintf(stderr, "Too many timeouts\n");
+				return -1;
+			}
+		} else {
+			/* read to clear the event */
+			ret = read(t->inotify_fd, buf, sizeof(buf));
+		}
+	}
+
+	return 0;
+}
+
+static void prepare_devices(struct loopback_test *t)
+{
+	int i;
+
+	/* Cancel any running tests */
+	for (i = 0; i < t->device_count; i++)
+		write_sysfs_val(t->devices[i].sysfs_entry, "type", 0);
+
+
+	for (i = 0; i < t->device_count; i++) {
+		if (!device_enabled(t, i))
+			continue;
+
+		write_sysfs_val(t->devices[i].sysfs_entry, "us_wait",
+				t->us_wait);
+
+		/* Set operation size */
+		write_sysfs_val(t->devices[i].sysfs_entry, "size", t->size);
+
+		/* Set iterations */
+		write_sysfs_val(t->devices[i].sysfs_entry, "iteration_max",
+				t->iteration_max);
+
+		if (t->use_async) {
+			write_sysfs_val(t->devices[i].sysfs_entry,
+				"async", 1);
+			write_sysfs_val(t->devices[i].sysfs_entry,
+				"timeout", t->async_timeout);
+			write_sysfs_val(t->devices[i].sysfs_entry,
+				"outstanding_operations_max",
+				t->async_outstanding_operations);
+		} else
+			write_sysfs_val(t->devices[i].sysfs_entry,
+				"async", 0);
+	}
+}
+
+static int start(struct loopback_test *t)
+{
+	int i;
+
+	/* the test starts by writing test_id to the type file. */
+	for (i = 0; i < t->device_count; i++) {
+		if (!device_enabled(t, i))
+			continue;
+
+		write_sysfs_val(t->devices[i].sysfs_entry, "type", t->test_id);
+	}
+
+	return 0;
+}
+
+
+void loopback_run(struct loopback_test *t)
+{
+	int i;
+	int ret;
+
+	for (i = 0; i < sizeof(dict) / sizeof(struct dict); i++) {
+		if (strstr(dict[i].name, t->test_name))
+			t->test_id = dict[i].type;
+	}
+	if (!t->test_id) {
+		fprintf(stderr, "invalid test %s\n", t->test_name);
+		usage();
+		return;
+	}
+
+	prepare_devices(t);
+
+	ret = register_for_notification(t);
+	if (ret)
+		goto err;
+
+	start(t);
+
+	sleep(1);
+
+	wait_for_complete(t);
+
+	unregister_for_notification(t);
+
+	get_results(t);
+
+	log_results(t);
+
+	return;
+
+err:
+	printf("Error running test\n");
+	return;
+}
+
+static int sanity_check(struct loopback_test *t)
+{
+	int i;
+
+	if (t->device_count == 0) {
+		fprintf(stderr, "No loopback devices found\n");
+		return -1;
+	}
+
+	for (i = 0; i < MAX_NUM_DEVICES; i++) {
+		if (!device_enabled(t, i))
+			continue;
+
+		if (t->mask && !strcmp(t->devices[i].name, "")) {
+			fprintf(stderr, "Bad device mask %x\n", (1 << i));
+			return -1;
+		}
+
+	}
+
+
+	return 0;
+}
+int main(int argc, char *argv[])
+{
+	int o, ret;
+	char *sysfs_prefix = "/sys/class/gb_loopback/";
+	char *debugfs_prefix = "/sys/kernel/debug/gb_loopback/";
+
+	memset(&t, 0, sizeof(t));
+
+	while ((o = getopt(argc, argv,
+			   "t:s:i:S:D:m:v::d::r::p::a::l::x::o:c:w:")) != -1) {
+		switch (o) {
+		case 't':
+			snprintf(t.test_name, MAX_STR_LEN, "%s", optarg);
+			break;
+		case 's':
+			t.size = atoi(optarg);
+			break;
+		case 'i':
+			t.iteration_max = atoi(optarg);
+			break;
+		case 'S':
+			snprintf(t.sysfs_prefix, MAX_SYSFS_PATH, "%s", optarg);
+			break;
+		case 'D':
+			snprintf(t.debugfs_prefix, MAX_SYSFS_PATH, "%s", optarg);
+			break;
+		case 'm':
+			t.mask = atol(optarg);
+			break;
+		case 'v':
+			t.verbose = 1;
+			break;
+		case 'd':
+			t.debug = 1;
+			break;
+		case 'r':
+			t.raw_data_dump = 1;
+			break;
+		case 'p':
+			t.porcelain = 1;
+			break;
+		case 'a':
+			t.aggregate_output = 1;
+			break;
+		case 'l':
+			t.list_devices = 1;
+			break;
+		case 'x':
+			t.use_async = 1;
+			break;
+		case 'o':
+			t.async_timeout = atoi(optarg);
+			break;
+		case 'c':
+			t.async_outstanding_operations = atoi(optarg);
+			break;
+		case 'w':
+			t.us_wait = atoi(optarg);
+			break;
+		default:
+			usage();
+			return -EINVAL;
+		}
+	}
+
+	if (!strcmp(t.sysfs_prefix, ""))
+		snprintf(t.sysfs_prefix, MAX_SYSFS_PATH, "%s", sysfs_prefix);
+
+	if (!strcmp(t.debugfs_prefix, ""))
+		snprintf(t.debugfs_prefix, MAX_SYSFS_PATH, "%s", debugfs_prefix);
+
+	ret = find_loopback_devices(&t);
+	if (ret)
+		return ret;
+	ret = sanity_check(&t);
+	if (ret)
+		return ret;
+
+	if (t.list_devices) {
+		show_loopback_devices(&t);
+		return 0;
+	}
+
+	if (t.test_name[0] == '\0' || t.iteration_max == 0)
+		usage();
+
+	if (t.async_timeout == 0)
+		t.async_timeout = DEFAULT_ASYNC_TIMEOUT;
+
+	loopback_run(&t);
+
+	return 0;
+}
