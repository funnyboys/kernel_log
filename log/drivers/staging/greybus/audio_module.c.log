commit 8478c35a858c75bf2b00917009ba1b46c1b9b7b4
Author: Cristian Sicilia <sicilia.cristian@gmail.com>
Date:   Sun Nov 25 17:58:15 2018 +0100

    staging: greybus: Parenthesis alignment
    
    Some parameters are aligned with parentheses.
    Some parentheses was opened at end of line.
    
    Signed-off-by: Cristian Sicilia <sicilia.cristian@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/audio_module.c b/drivers/staging/greybus/audio_module.c
index d065334efa23..300a2b4f3fc7 100644
--- a/drivers/staging/greybus/audio_module.c
+++ b/drivers/staging/greybus/audio_module.c
@@ -18,7 +18,7 @@
  */
 
 static int gbaudio_request_jack(struct gbaudio_module_info *module,
-				  struct gb_audio_jack_event_request *req)
+				struct gb_audio_jack_event_request *req)
 {
 	int report;
 	struct snd_jack *jack = module->headset_jack.jack;
@@ -26,8 +26,8 @@ static int gbaudio_request_jack(struct gbaudio_module_info *module,
 
 	if (!jack) {
 		dev_err_ratelimited(module->dev,
-			"Invalid jack event received:type: %u, event: %u\n",
-			req->jack_attribute, req->event);
+				    "Invalid jack event received:type: %u, event: %u\n",
+				    req->jack_attribute, req->event);
 		return -EINVAL;
 	}
 
@@ -50,8 +50,8 @@ static int gbaudio_request_jack(struct gbaudio_module_info *module,
 	report = req->jack_attribute & module->jack_mask;
 	if (!report) {
 		dev_err_ratelimited(module->dev,
-			"Invalid jack event received:type: %u, event: %u\n",
-			req->jack_attribute, req->event);
+				    "Invalid jack event received:type: %u, event: %u\n",
+				    req->jack_attribute, req->event);
 		return -EINVAL;
 	}
 
@@ -74,8 +74,8 @@ static int gbaudio_request_button(struct gbaudio_module_info *module,
 
 	if (!btn_jack) {
 		dev_err_ratelimited(module->dev,
-			"Invalid button event received:type: %u, event: %u\n",
-			req->button_id, req->event);
+				    "Invalid button event received:type: %u, event: %u\n",
+				    req->button_id, req->event);
 		return -EINVAL;
 	}
 
@@ -210,8 +210,8 @@ static int gb_audio_add_data_connection(struct gbaudio_module_info *gbmodule,
 		return -ENOMEM;
 
 	connection = gb_connection_create_offloaded(bundle,
-					le16_to_cpu(cport_desc->id),
-					GB_CONNECTION_FLAG_CSD);
+						    le16_to_cpu(cport_desc->id),
+						    GB_CONNECTION_FLAG_CSD);
 	if (IS_ERR(connection)) {
 		devm_kfree(gbmodule->dev, dai);
 		return PTR_ERR(connection);
@@ -317,7 +317,7 @@ static int gb_audio_probe(struct gb_bundle *bundle,
 	ret = gbaudio_tplg_parse_data(gbmodule, topology);
 	if (ret) {
 		dev_err(dev, "%d:Error while parsing topology data\n",
-			  ret);
+			ret);
 		goto free_topology;
 	}
 	gbmodule->topology = topology;

commit 863dbc52e7f0e5acd7b4883f3933543a81c474c7
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Nov 7 14:58:42 2017 +0100

    staging: greybus: Remove redundant license text
    
    Now that the SPDX tag is in all greybus files, that identifies the
    license in a specific and legally-defined manner.  So the extra GPL text
    wording can be removed as it is no longer needed at all.
    
    This is done on a quest to remove the 700+ different ways that files in
    the kernel describe the GPL license text.  And there's unneeded stuff
    like the address (sometimes incorrect) for the FSF which is never
    needed.
    
    No copyright headers or other non-license-description text was removed.
    
    Cc: Vaibhav Hiremath <hvaibhav.linux@gmail.com>
    Reviewed-by: Alex Elder <elder@linaro.org>
    Acked-by: Vaibhav Agarwal <vaibhav.sr@gmail.com>
    Acked-by: David Lin <dtwlin@gmail.com>
    Acked-by: Johan Hovold <johan@kernel.org>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Acked-by: Mark Greer <mgreer@animalcreek.com>
    Acked-by: Rui Miguel Silva <rmfrfs@gmail.com>
    Acked-by: "Bryan O'Donoghue" <pure.logic@nexus-software.ie>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/audio_module.c b/drivers/staging/greybus/audio_module.c
index fb9bf23e4407..d065334efa23 100644
--- a/drivers/staging/greybus/audio_module.c
+++ b/drivers/staging/greybus/audio_module.c
@@ -3,8 +3,6 @@
  * Greybus audio driver
  * Copyright 2015 Google Inc.
  * Copyright 2015 Linaro Ltd.
- *
- * Released under the GPLv2 only.
  */
 #include <linux/kernel.h>
 #include <linux/module.h>

commit eb50fd3a22c770f36be275295b782f3ea52e3215
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Nov 7 14:58:41 2017 +0100

    staging: greybus: add SPDX identifiers to all greybus driver files
    
    It's good to have SPDX identifiers in all files to make it easier to
    audit the kernel tree for correct licenses.
    
    Update the drivers/staging/greybus files files with the correct SPDX
    license identifier based on the license text in the file itself.  The
    SPDX identifier is a legally binding shorthand, which can be used
    instead of the full boiler plate text.
    
    This work is based on a script and data from Thomas Gleixner, Philippe
    Ombredanne, and Kate Stewart.
    
    Cc: Vaibhav Hiremath <hvaibhav.linux@gmail.com>
    Cc: "Bryan O'Donoghue" <pure.logic@nexus-software.ie>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: Philippe Ombredanne <pombredanne@nexb.com>
    Acked-by: Vaibhav Agarwal <vaibhav.sr@gmail.com>
    Acked-by: David Lin <dtwlin@gmail.com>
    Reviewed-by: Alex Elder <elder@linaro.org>
    Acked-by: Johan Hovold <johan@kernel.org>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Acked-by: Mark Greer <mgreer@animalcreek.com>
    Acked-by: Rui Miguel Silva <rmfrfs@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/audio_module.c b/drivers/staging/greybus/audio_module.c
index 094c3be79b33..fb9bf23e4407 100644
--- a/drivers/staging/greybus/audio_module.c
+++ b/drivers/staging/greybus/audio_module.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * Greybus audio driver
  * Copyright 2015 Google Inc.

commit 055fb9ce92d59da9e8d1040b54ecd9b6fff439d7
Author: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
Date:   Wed Jan 18 22:51:53 2017 +0530

    staging: greybus: audio: Ensure proper byte order
    
    Proper byte order was completely disregarded for multi byte data shared
    between AP and module (and APB1). Fix this.
    
    Signed-off-by: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
    Signed-off-by: Vaibhav Agarwal <vaibhav.sr@gmail.com>
    Acked-by: Mark Greer <mgreer@animalcreek.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/audio_module.c b/drivers/staging/greybus/audio_module.c
index 17a9948b1ba1..094c3be79b33 100644
--- a/drivers/staging/greybus/audio_module.c
+++ b/drivers/staging/greybus/audio_module.c
@@ -134,7 +134,7 @@ static int gbaudio_request_stream(struct gbaudio_module_info *module,
 				  struct gb_audio_streaming_event_request *req)
 {
 	dev_warn(module->dev, "Audio Event received: cport: %u, event: %u\n",
-		 req->data_cport, req->event);
+		 le16_to_cpu(req->data_cport), req->event);
 
 	return 0;
 }

commit 3282998c8010f6eb42950d628f4df980da528b75
Author: Srikant Ritolia <s.ritolia@samsung.com>
Date:   Tue Dec 6 19:39:36 2016 +0530

    staging: greybus: audio_module: remove redundant OOM message
    
    All kmalloc-based functions print enough information on failure
    
    Signed-off-by: Srikant Ritolia <s.ritolia@samsung.com>
    Acked-by: Johan Hovold <johan@kernel.org>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/audio_module.c b/drivers/staging/greybus/audio_module.c
index 0269a1d31285..17a9948b1ba1 100644
--- a/drivers/staging/greybus/audio_module.c
+++ b/drivers/staging/greybus/audio_module.c
@@ -207,10 +207,8 @@ static int gb_audio_add_data_connection(struct gbaudio_module_info *gbmodule,
 	struct gbaudio_data_connection *dai;
 
 	dai = devm_kzalloc(gbmodule->dev, sizeof(*dai), GFP_KERNEL);
-	if (!dai) {
-		dev_err(gbmodule->dev, "DAI Malloc failure\n");
+	if (!dai)
 		return -ENOMEM;
-	}
 
 	connection = gb_connection_create_offloaded(bundle,
 					le16_to_cpu(cport_desc->id),

commit 49b9137a6002a06f7e44e59ece9b34fd1e4fca4c
Author: Pankaj Bharadiya <pankaj.bharadiya@gmail.com>
Date:   Mon Oct 17 14:42:36 2016 +0530

    staging: greybus: audio: remove redundant slot field
    
    gb_audio_manager_module_descriptor's intf_id field maintains the
    information about the interface on which module is connected hence
    having an extra slot field is redundant.
    
    Thus remove the slot field and its associated code.
    
    Signed-off-by: Pankaj Bharadiya <pankaj.bharadiya@gmail.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Reviewed-by: Vaibhav Agarwal <vaibhav.sr@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/audio_module.c b/drivers/staging/greybus/audio_module.c
index 45b2519322c3..0269a1d31285 100644
--- a/drivers/staging/greybus/audio_module.c
+++ b/drivers/staging/greybus/audio_module.c
@@ -345,7 +345,6 @@ static int gb_audio_probe(struct gb_bundle *bundle,
 	dev_dbg(dev, "Inform set_event:%d to above layer\n", 1);
 	/* prepare for the audio manager */
 	strlcpy(desc.name, gbmodule->name, GB_AUDIO_MANAGER_MODULE_NAME_LEN);
-	desc.slot = 1; /* todo */
 	desc.vid = 2; /* todo */
 	desc.pid = 3; /* todo */
 	desc.intf_id = gbmodule->dev_id;

commit d0af1bd5f6f44971bea2e45acfe07de629734a3e
Author: Pankaj Bharadiya <pankaj.bharadiya@gmail.com>
Date:   Sun Oct 16 15:29:14 2016 +0530

    staging: greybus: audio: Rename cport with intf_id
    
    gb_audio_manager_module_descriptor's cport field is actually used to
    manage and pass interface id to user space.
    
    Thus rename gb_audio_manager_module_descriptor's 'cport' field and
    few other things to avoid confusion.
    
    Signed-off-by: Pankaj Bharadiya <pankaj.bharadiya@gmail.com>
    Reviewed-by: Vaibhav Agarwal <vaibhav.sr@gmail.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/audio_module.c b/drivers/staging/greybus/audio_module.c
index ae1c0fa85752..45b2519322c3 100644
--- a/drivers/staging/greybus/audio_module.c
+++ b/drivers/staging/greybus/audio_module.c
@@ -348,7 +348,7 @@ static int gb_audio_probe(struct gb_bundle *bundle,
 	desc.slot = 1; /* todo */
 	desc.vid = 2; /* todo */
 	desc.pid = 3; /* todo */
-	desc.cport = gbmodule->dev_id;
+	desc.intf_id = gbmodule->dev_id;
 	desc.op_devices = gbmodule->op_devices;
 	desc.ip_devices = gbmodule->ip_devices;
 	gbmodule->manager_id = gb_audio_manager_add(&desc);

commit 948c6227e76ef2443b327a409dc8eced92b32bda
Author: Greg Kroah-Hartman <gregkh@google.com>
Date:   Fri Sep 9 09:47:01 2016 +0200

    staging: greybus: remove CONFIG_PM_RUNTIME from kernel_ver.h
    
    The last thing remaining in kernel_ver.h was the setting of
    CONFIG_PM_RUNTIME, which isn't needed in a in-tree implementation.  So
    remove the setting of this value, and the .h file entirely as that was
    the last thing left in it.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/audio_module.c b/drivers/staging/greybus/audio_module.c
index 411735df2bb4..ae1c0fa85752 100644
--- a/drivers/staging/greybus/audio_module.c
+++ b/drivers/staging/greybus/audio_module.c
@@ -421,7 +421,7 @@ static const struct greybus_bundle_id gb_audio_id_table[] = {
 };
 MODULE_DEVICE_TABLE(greybus, gb_audio_id_table);
 
-#ifdef CONFIG_PM_RUNTIME
+#ifdef CONFIG_PM
 static int gb_audio_suspend(struct device *dev)
 {
 	struct gb_bundle *bundle = to_gb_bundle(dev);

commit 6a57ddc97acb2a1d37ce94a237dc0fab2e5a3f5b
Author: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
Date:   Thu Sep 1 11:38:42 2016 +0530

    greybus: audio: Avoid reporting spurious button events
    
    Now jack-button are registered to snd framework based on capabilities
    populated by codec module's topology data. Thus, valid ids for button
    events can also vary for different modules. This patch modifies existing
    button reporting mechanism to avoid reporting spurious button events for
    invalid button ids.
    
    Signed-off-by: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
    Reviewed-by: Mark Greer <mgreer@animalcreek.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/audio_module.c b/drivers/staging/greybus/audio_module.c
index d3284ab1dacf..411735df2bb4 100644
--- a/drivers/staging/greybus/audio_module.c
+++ b/drivers/staging/greybus/audio_module.c
@@ -92,24 +92,27 @@ static int gbaudio_request_button(struct gbaudio_module_info *module,
 	}
 
 	report = module->button_status & module->button_mask;
+	soc_button_id = 0;
 
 	switch (req->button_id) {
 	case 1:
-		soc_button_id = SND_JACK_BTN_0;
+		soc_button_id = SND_JACK_BTN_0 & module->button_mask;
 		break;
 
 	case 2:
-		soc_button_id = SND_JACK_BTN_1;
+		soc_button_id = SND_JACK_BTN_1 & module->button_mask;
 		break;
 
 	case 3:
-		soc_button_id = SND_JACK_BTN_2;
+		soc_button_id = SND_JACK_BTN_2 & module->button_mask;
 		break;
 
 	case 4:
-		soc_button_id = SND_JACK_BTN_3;
+		soc_button_id = SND_JACK_BTN_3 & module->button_mask;
 		break;
-	default:
+	}
+
+	if (!soc_button_id) {
 		dev_err_ratelimited(module->dev,
 				    "Invalid button request received\n");
 		return -EINVAL;

commit cec89df44692fa8cff2a52542b11878ee49b0d69
Author: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
Date:   Thu Sep 1 11:38:41 2016 +0530

    greybus: audio: Report jack events conditionally
    
    Now jack & jack-buttons are registered to snd_jack framework based on
    the capability shared by module's topology data. Thus, jack events
    should be reported to above snd framework only in case corresponding
    jack type is registered. This patch adds additional checks to avoid
    reporting fake jack events.
    
    Signed-off-by: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
    Reviewed-by: Mark Greer <mgreer@animalcreek.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/audio_module.c b/drivers/staging/greybus/audio_module.c
index f764f007b543..d3284ab1dacf 100644
--- a/drivers/staging/greybus/audio_module.c
+++ b/drivers/staging/greybus/audio_module.c
@@ -21,7 +21,16 @@
 static int gbaudio_request_jack(struct gbaudio_module_info *module,
 				  struct gb_audio_jack_event_request *req)
 {
-	int report, button_status;
+	int report;
+	struct snd_jack *jack = module->headset_jack.jack;
+	struct snd_jack *btn_jack = module->button_jack.jack;
+
+	if (!jack) {
+		dev_err_ratelimited(module->dev,
+			"Invalid jack event received:type: %u, event: %u\n",
+			req->jack_attribute, req->event);
+		return -EINVAL;
+	}
 
 	dev_warn_ratelimited(module->dev,
 			     "Jack Event received: type: %u, event: %u\n",
@@ -29,19 +38,24 @@ static int gbaudio_request_jack(struct gbaudio_module_info *module,
 
 	if (req->event == GB_AUDIO_JACK_EVENT_REMOVAL) {
 		module->jack_type = 0;
-		button_status = module->button_status;
-		module->button_status = 0;
-		if (button_status)
+		if (btn_jack && module->button_status) {
 			snd_soc_jack_report(&module->button_jack, 0,
 					    module->button_mask);
+			module->button_status = 0;
+		}
 		snd_soc_jack_report(&module->headset_jack, 0,
 				    module->jack_mask);
 		return 0;
 	}
 
-	/* currently supports Headphone, Headset & Lineout only */
-	report &= ~module->jack_mask;
-	report |= req->jack_attribute & module->jack_mask;
+	report = req->jack_attribute & module->jack_mask;
+	if (!report) {
+		dev_err_ratelimited(module->dev,
+			"Invalid jack event received:type: %u, event: %u\n",
+			req->jack_attribute, req->event);
+		return -EINVAL;
+	}
+
 	if (module->jack_type)
 		dev_warn_ratelimited(module->dev,
 				     "Modifying jack from %d to %d\n",
@@ -57,6 +71,14 @@ static int gbaudio_request_button(struct gbaudio_module_info *module,
 				  struct gb_audio_button_event_request *req)
 {
 	int soc_button_id, report;
+	struct snd_jack *btn_jack = module->button_jack.jack;
+
+	if (!btn_jack) {
+		dev_err_ratelimited(module->dev,
+			"Invalid button event received:type: %u, event: %u\n",
+			req->button_id, req->event);
+		return -EINVAL;
+	}
 
 	dev_warn_ratelimited(module->dev,
 			     "Button Event received: id: %u, event: %u\n",

commit 847175e8e660045f9366e7efd091969e8f32cc0c
Author: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
Date:   Thu Sep 1 11:38:40 2016 +0530

    greybus: audio: Fetch jack_mask, button_mask from module's topology data
    
    Added extra fields namely jack_mask & button_mask for each module_info.
    These fields are required while registering jack & reporting jack
    events.
    
    Earlier, these were hard coded values assuming fixed capabilities say
    HEADSET, LINEOUT, etc. supported by GB-codec driver. Now these are
    computed dynamically based on module's jack capability shared via
    topology data.
    
    Signed-off-by: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
    Reviewed-by: Mark Greer <mgreer@animalcreek.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/audio_module.c b/drivers/staging/greybus/audio_module.c
index c2172719e687..f764f007b543 100644
--- a/drivers/staging/greybus/audio_module.c
+++ b/drivers/staging/greybus/audio_module.c
@@ -33,22 +33,22 @@ static int gbaudio_request_jack(struct gbaudio_module_info *module,
 		module->button_status = 0;
 		if (button_status)
 			snd_soc_jack_report(&module->button_jack, 0,
-					    GBCODEC_JACK_BUTTON_MASK);
+					    module->button_mask);
 		snd_soc_jack_report(&module->headset_jack, 0,
-				    GBCODEC_JACK_MASK);
+				    module->jack_mask);
 		return 0;
 	}
 
 	/* currently supports Headphone, Headset & Lineout only */
-	report &= ~GBCODEC_JACK_MASK;
-	report |= req->jack_attribute & GBCODEC_JACK_MASK;
+	report &= ~module->jack_mask;
+	report |= req->jack_attribute & module->jack_mask;
 	if (module->jack_type)
 		dev_warn_ratelimited(module->dev,
 				     "Modifying jack from %d to %d\n",
 				     module->jack_type, report);
 
 	module->jack_type = report;
-	snd_soc_jack_report(&module->headset_jack, report, GBCODEC_JACK_MASK);
+	snd_soc_jack_report(&module->headset_jack, report, module->jack_mask);
 
 	return 0;
 }
@@ -69,7 +69,7 @@ static int gbaudio_request_button(struct gbaudio_module_info *module,
 		return -EINVAL;
 	}
 
-	report = module->button_status & GBCODEC_JACK_BUTTON_MASK;
+	report = module->button_status & module->button_mask;
 
 	switch (req->button_id) {
 	case 1:
@@ -100,8 +100,7 @@ static int gbaudio_request_button(struct gbaudio_module_info *module,
 
 	module->button_status = report;
 
-	snd_soc_jack_report(&module->button_jack, report,
-			    GBCODEC_JACK_BUTTON_MASK);
+	snd_soc_jack_report(&module->button_jack, report, module->button_mask);
 
 	return 0;
 }

commit 956adf749d697decd9fb5f46aa0fbbc889f4dfe1
Author: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
Date:   Thu Aug 4 15:14:36 2016 +0530

    greybus: Remove unused field from data_connection
    
    Audio codec driver internally maintains a struct containing info about
    module's data connection. Remove unused field from this struct.
    
    Signed-off-by: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
    Reviewed-by: Mark Greer <mgreer@animalcreek.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/audio_module.c b/drivers/staging/greybus/audio_module.c
index 9632bc119f87..c2172719e687 100644
--- a/drivers/staging/greybus/audio_module.c
+++ b/drivers/staging/greybus/audio_module.c
@@ -197,8 +197,6 @@ static int gb_audio_add_data_connection(struct gbaudio_module_info *gbmodule,
 	}
 
 	greybus_set_drvdata(bundle, gbmodule);
-	/* dai->name should be same as codec->dai_name */
-	strlcpy(dai->name, "greybus-apb1", NAME_SIZE);
 	dai->id = 0;
 	dai->data_cport = connection->intf_cport_id;
 	dai->connection = connection;

commit b7e7dc0083d662c061dcd547c7dde4db24331ebc
Author: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
Date:   Thu Aug 4 15:14:34 2016 +0530

    greybus: audio: Add id to identify data connection
    
    Added id field to data connection struct. This is used to identify which
    data connection to use while enabling interface between module & APB.
    
    Signed-off-by: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
    Reviewed-by: Mark Greer <mgreer@animalcreek.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/audio_module.c b/drivers/staging/greybus/audio_module.c
index 7cf523e7f995..9632bc119f87 100644
--- a/drivers/staging/greybus/audio_module.c
+++ b/drivers/staging/greybus/audio_module.c
@@ -199,6 +199,7 @@ static int gb_audio_add_data_connection(struct gbaudio_module_info *gbmodule,
 	greybus_set_drvdata(bundle, gbmodule);
 	/* dai->name should be same as codec->dai_name */
 	strlcpy(dai->name, "greybus-apb1", NAME_SIZE);
+	dai->id = 0;
 	dai->data_cport = connection->intf_cport_id;
 	dai->connection = connection;
 	list_add(&dai->list, &gbmodule->data_list);

commit 6ba7fad430d6300b966800bc5d2c782e2baf6f1d
Author: David Lin <dtwlin@google.com>
Date:   Thu Jul 14 15:13:00 2016 -0500

    greybus: audio: add runtime pm support
    
    Add runtime pm support to audio protocol device class driver.
    
    Testing Done:
     - Use white speaker module and check the interface is autosuspended when
       it's idle and resumed when playback audio
    
    Signed-off-by: David Lin <dtwlin@google.com>
    Signed-off-by: Axel Haslam <ahaslam@baylibre.com>
    Reviewed-by: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
    Signed-off-by: Alex Elder <elder@linaro.org>

diff --git a/drivers/staging/greybus/audio_module.c b/drivers/staging/greybus/audio_module.c
index d87b9985a0e2..7cf523e7f995 100644
--- a/drivers/staging/greybus/audio_module.c
+++ b/drivers/staging/greybus/audio_module.c
@@ -332,6 +332,8 @@ static int gb_audio_probe(struct gb_bundle *bundle,
 
 	dev_dbg(dev, "Add GB Audio device:%s\n", gbmodule->name);
 
+	gb_pm_runtime_put_autosuspend(bundle);
+
 	return 0;
 
 disable_data_connection:
@@ -366,6 +368,8 @@ static void gb_audio_disconnect(struct gb_bundle *bundle)
 	struct gbaudio_module_info *gbmodule = greybus_get_drvdata(bundle);
 	struct gbaudio_data_connection *dai, *_dai;
 
+	gb_pm_runtime_get_sync(bundle);
+
 	/* cleanup module related resources first */
 	gbaudio_unregister_module(gbmodule);
 
@@ -394,11 +398,58 @@ static const struct greybus_bundle_id gb_audio_id_table[] = {
 };
 MODULE_DEVICE_TABLE(greybus, gb_audio_id_table);
 
+#ifdef CONFIG_PM_RUNTIME
+static int gb_audio_suspend(struct device *dev)
+{
+	struct gb_bundle *bundle = to_gb_bundle(dev);
+	struct gbaudio_module_info *gbmodule = greybus_get_drvdata(bundle);
+	struct gbaudio_data_connection *dai;
+
+	list_for_each_entry(dai, &gbmodule->data_list, list)
+		gb_connection_disable(dai->connection);
+
+	gb_connection_disable(gbmodule->mgmt_connection);
+
+	return 0;
+}
+
+static int gb_audio_resume(struct device *dev)
+{
+	struct gb_bundle *bundle = to_gb_bundle(dev);
+	struct gbaudio_module_info *gbmodule = greybus_get_drvdata(bundle);
+	struct gbaudio_data_connection *dai;
+	int ret;
+
+	ret = gb_connection_enable(gbmodule->mgmt_connection);
+	if (ret) {
+		dev_err(dev, "%d:Error while enabling mgmt connection\n", ret);
+		return ret;
+	}
+
+	list_for_each_entry(dai, &gbmodule->data_list, list) {
+		ret = gb_connection_enable(dai->connection);
+		if (ret) {
+			dev_err(dev,
+				"%d:Error while enabling %d:data connection\n",
+				ret, dai->data_cport);
+			return ret;
+		}
+	}
+
+	return 0;
+}
+#endif
+
+static const struct dev_pm_ops gb_audio_pm_ops = {
+	SET_RUNTIME_PM_OPS(gb_audio_suspend, gb_audio_resume, NULL)
+};
+
 static struct greybus_driver gb_audio_driver = {
 	.name		= "gb-audio",
 	.probe		= gb_audio_probe,
 	.disconnect	= gb_audio_disconnect,
 	.id_table	= gb_audio_id_table,
+	.driver.pm	= &gb_audio_pm_ops,
 };
 module_greybus_driver(gb_audio_driver);
 

commit 60fb3405c73ea0bbab942c699496123f9e987c04
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Fri Jun 10 14:59:07 2016 +0530

    greybus: Remove extra blank lines
    
    This patch removes few blank lines across the repository at places where
    two blank lines were present together or when a blank line is present at
    the start or end of a routine.
    
    Note that this doesn't remove most of them from greybus_protocols.h as
    they were added on purpose.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/audio_module.c b/drivers/staging/greybus/audio_module.c
index 81001329aad2..d87b9985a0e2 100644
--- a/drivers/staging/greybus/audio_module.c
+++ b/drivers/staging/greybus/audio_module.c
@@ -221,7 +221,6 @@ static int gb_audio_probe(struct gb_bundle *bundle,
 	int ret, i;
 	struct gb_audio_topology *topology;
 
-
 	/* There should be at least one Management and one Data cport */
 	if (bundle->num_cports < 2)
 		return -ENODEV;
@@ -367,7 +366,6 @@ static void gb_audio_disconnect(struct gb_bundle *bundle)
 	struct gbaudio_module_info *gbmodule = greybus_get_drvdata(bundle);
 	struct gbaudio_data_connection *dai, *_dai;
 
-
 	/* cleanup module related resources first */
 	gbaudio_unregister_module(gbmodule);
 

commit c6722ab5d3c3d23021dd32bd1ae569665ee2263b
Author: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
Date:   Fri Jun 10 12:59:11 2016 +0530

    greybus: audio: Ratelimit err messages in bundle, topology driver
    
    Earlier I have shared a patch to rate limit err messages in audio_codec
    driver. However, missed to include suggestion from Mark to do similar
    changes in audio bundle & topology parser as well. Doing it now.
    
    Testing Done: Compile tested
    
    Fixes: 4cb3d109e5fc ("audio: Ratelimit err messages")
    Signed-off-by: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
    Reviewed-by: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/audio_module.c b/drivers/staging/greybus/audio_module.c
index 95d2ddadeeab..81001329aad2 100644
--- a/drivers/staging/greybus/audio_module.c
+++ b/drivers/staging/greybus/audio_module.c
@@ -23,8 +23,9 @@ static int gbaudio_request_jack(struct gbaudio_module_info *module,
 {
 	int report, button_status;
 
-	dev_warn(module->dev, "Jack Event received: type: %u, event: %u\n",
-		 req->jack_attribute, req->event);
+	dev_warn_ratelimited(module->dev,
+			     "Jack Event received: type: %u, event: %u\n",
+			     req->jack_attribute, req->event);
 
 	if (req->event == GB_AUDIO_JACK_EVENT_REMOVAL) {
 		module->jack_type = 0;
@@ -42,8 +43,9 @@ static int gbaudio_request_jack(struct gbaudio_module_info *module,
 	report &= ~GBCODEC_JACK_MASK;
 	report |= req->jack_attribute & GBCODEC_JACK_MASK;
 	if (module->jack_type)
-		dev_warn(module->dev, "Modifying jack from %d to %d\n",
-			 module->jack_type, report);
+		dev_warn_ratelimited(module->dev,
+				     "Modifying jack from %d to %d\n",
+				     module->jack_type, report);
 
 	module->jack_type = report;
 	snd_soc_jack_report(&module->headset_jack, report, GBCODEC_JACK_MASK);
@@ -56,12 +58,14 @@ static int gbaudio_request_button(struct gbaudio_module_info *module,
 {
 	int soc_button_id, report;
 
-	dev_warn(module->dev, "Button Event received: id: %u, event: %u\n",
-		 req->button_id, req->event);
+	dev_warn_ratelimited(module->dev,
+			     "Button Event received: id: %u, event: %u\n",
+			     req->button_id, req->event);
 
 	/* currently supports 4 buttons only */
 	if (!module->jack_type) {
-		dev_err(module->dev, "Jack not present. Bogus event!!\n");
+		dev_err_ratelimited(module->dev,
+				    "Jack not present. Bogus event!!\n");
 		return -EINVAL;
 	}
 
@@ -84,7 +88,8 @@ static int gbaudio_request_button(struct gbaudio_module_info *module,
 		soc_button_id = SND_JACK_BTN_3;
 		break;
 	default:
-		dev_err(module->dev, "Invalid button request received\n");
+		dev_err_ratelimited(module->dev,
+				    "Invalid button request received\n");
 		return -EINVAL;
 	}
 
@@ -138,8 +143,8 @@ static int gbaudio_codec_request_handler(struct gb_operation *op)
 		break;
 
 	default:
-		dev_err(&connection->bundle->dev,
-			"Invalid Audio Event received\n");
+		dev_err_ratelimited(&connection->bundle->dev,
+				    "Invalid Audio Event received\n");
 		return -EINVAL;
 	}
 

commit 698282f659d7c657aad4e0a72ed33190f2332e04
Author: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
Date:   Fri Jun 3 17:45:30 2016 +0530

    greybus: audio: Report DISCONNECT event after resource cleanup.
    
    Reporting DISCONNECT event immediately on module removal causes
    race condition while re-populating mixer controls by above HAL. The
    original intent was to avoid any (invalid) mixer control modification
    request from above layer.
    
    Ideally, it should report 'MODULE_NOT_READY' on module plug-out and
    DISCONNECT after resource cleanup. This would involve changes in GB
    Audio manager and HAL layer.
    
    Since we already have a plan to remove GB Audio manager, I'm making this
    change in GB codec driver to avoid any race condition. Also, codec
    driver already ensures mixer control modifcations for disconnected
    modules are not triggered to AP Bridge audio FW & reported invalid.
    
    Signed-off-by: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
    Reviewed-by: Mark Greer <mgreer@animalcreek.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/audio_module.c b/drivers/staging/greybus/audio_module.c
index 53e84f5fafb0..95d2ddadeeab 100644
--- a/drivers/staging/greybus/audio_module.c
+++ b/drivers/staging/greybus/audio_module.c
@@ -363,10 +363,12 @@ static void gb_audio_disconnect(struct gb_bundle *bundle)
 	struct gbaudio_data_connection *dai, *_dai;
 
 
+	/* cleanup module related resources first */
+	gbaudio_unregister_module(gbmodule);
+
 	/* inform uevent to above layers */
 	gb_audio_manager_remove(gbmodule->manager_id);
 
-	gbaudio_unregister_module(gbmodule);
 	gbaudio_tplg_release(gbmodule);
 	kfree(gbmodule->topology);
 	gbmodule->topology = NULL;

commit 37f07c0c974d78bfcdc9f3267438c91163fc3ae5
Author: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
Date:   Mon May 23 23:31:14 2016 +0530

    greybus: audio: Fix memory leak
    
    Topology data pointer was mistakenly set to NULL before freeing it. Fix
    this.
    
    Fixes: 64a86d9ba850 ("audio: Add module specific driver")
    Signed-off-by: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
    Reviewed-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/audio_module.c b/drivers/staging/greybus/audio_module.c
index 57d3b0292231..53e84f5fafb0 100644
--- a/drivers/staging/greybus/audio_module.c
+++ b/drivers/staging/greybus/audio_module.c
@@ -368,8 +368,8 @@ static void gb_audio_disconnect(struct gb_bundle *bundle)
 
 	gbaudio_unregister_module(gbmodule);
 	gbaudio_tplg_release(gbmodule);
-	gbmodule->topology = NULL;
 	kfree(gbmodule->topology);
+	gbmodule->topology = NULL;
 	gb_connection_disable(gbmodule->mgmt_connection);
 	list_for_each_entry_safe(dai, _dai, &gbmodule->data_list, list) {
 		gb_connection_disable(dai->connection);

commit a8af16313d18ce75d56c256fdfefed53a0572d45
Author: Johan Hovold <johan@hovoldconsulting.com>
Date:   Wed May 11 10:17:58 2016 +0200

    greybus: audio: mark the data connection as offloaded
    
    Mark the data-connection as offloaded, that is, under control of the
    host device (AP-bridge).
    
    This prevents messages from being sent from or forwarded to the AP.
    
    Signed-off-by: Johan Hovold <johan@hovoldconsulting.com>
    Reviewed-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/audio_module.c b/drivers/staging/greybus/audio_module.c
index d2dd5b82ce41..57d3b0292231 100644
--- a/drivers/staging/greybus/audio_module.c
+++ b/drivers/staging/greybus/audio_module.c
@@ -146,15 +146,6 @@ static int gbaudio_codec_request_handler(struct gb_operation *op)
 	return ret;
 }
 
-static int gbaudio_data_connection_request_handler(struct gb_operation *op)
-{
-	struct gb_connection *connection = op->connection;
-
-	dev_warn(&connection->bundle->dev, "Audio Event received\n");
-
-	return 0;
-}
-
 static int gb_audio_add_mgmt_connection(struct gbaudio_module_info *gbmodule,
 				struct greybus_descriptor_cport *cport_desc,
 				struct gb_bundle *bundle)
@@ -192,9 +183,8 @@ static int gb_audio_add_data_connection(struct gbaudio_module_info *gbmodule,
 		return -ENOMEM;
 	}
 
-	connection = gb_connection_create_flags(bundle,
+	connection = gb_connection_create_offloaded(bundle,
 					le16_to_cpu(cport_desc->id),
-					gbaudio_data_connection_request_handler,
 					GB_CONNECTION_FLAG_CSD);
 	if (IS_ERR(connection)) {
 		devm_kfree(gbmodule->dev, dai);

commit 0634874a584e8bd875a83850c656e5adefc53bde
Author: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
Date:   Wed May 4 16:29:24 2016 +0530

    greybus: audio: Use standard API to set connections' private data
    
    Use standard API greybus_set_drvdata() while setting private
    data pointers for mgmt & data connection.
    
    Signed-off-by: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/audio_module.c b/drivers/staging/greybus/audio_module.c
index 27e5ff19dca6..d2dd5b82ce41 100644
--- a/drivers/staging/greybus/audio_module.c
+++ b/drivers/staging/greybus/audio_module.c
@@ -173,7 +173,7 @@ static int gb_audio_add_mgmt_connection(struct gbaudio_module_info *gbmodule,
 	if (IS_ERR(connection))
 		return PTR_ERR(connection);
 
-	connection->private = gbmodule;
+	greybus_set_drvdata(bundle, gbmodule);
 	gbmodule->mgmt_connection = connection;
 
 	return 0;
@@ -201,7 +201,7 @@ static int gb_audio_add_data_connection(struct gbaudio_module_info *gbmodule,
 		return PTR_ERR(connection);
 	}
 
-	connection->private = gbmodule;
+	greybus_set_drvdata(bundle, gbmodule);
 	/* dai->name should be same as codec->dai_name */
 	strlcpy(dai->name, "greybus-apb1", NAME_SIZE);
 	dai->data_cport = connection->intf_cport_id;

commit bb9986ef6b311fb3f4de2150bd050c1d9e1d9d65
Author: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
Date:   Wed May 4 16:29:22 2016 +0530

    greybus: audio: Reorganize sequence in GB audio bundle & codec driver
    
    Modify sequence of register_module & unregister_module in bundle
    driver. This would affect the uevent generated for above user
    space. Accordingly, we need to modify snd_soc_xxx sequence in
    register_module() in codec driver.
    
    Signed-off-by: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/audio_module.c b/drivers/staging/greybus/audio_module.c
index 3b763710ddf6..27e5ff19dca6 100644
--- a/drivers/staging/greybus/audio_module.c
+++ b/drivers/staging/greybus/audio_module.c
@@ -308,18 +308,22 @@ static int gb_audio_probe(struct gb_bundle *bundle,
 	}
 	gbmodule->topology = topology;
 
-	/* register module with gbcodec */
-	ret = gbaudio_register_module(gbmodule);
-	if (ret)
-		goto release_topology;
-
 	/* Initialize data connections */
 	list_for_each_entry(dai, &gbmodule->data_list, list) {
 		ret = gb_connection_enable(dai->connection);
-		if (ret)
+		if (ret) {
+			dev_err(dev,
+				"%d:Error while enabling %d:data connection\n",
+				ret, dai->data_cport);
 			goto disable_data_connection;
+		}
 	}
 
+	/* register module with gbcodec */
+	ret = gbaudio_register_module(gbmodule);
+	if (ret)
+		goto disable_data_connection;
+
 	/* inform above layer for uevent */
 	dev_dbg(dev, "Inform set_event:%d to above layer\n", 1);
 	/* prepare for the audio manager */
@@ -339,9 +343,6 @@ static int gb_audio_probe(struct gb_bundle *bundle,
 disable_data_connection:
 	list_for_each_entry_safe(dai, _dai, &gbmodule->data_list, list)
 		gb_connection_disable(dai->connection);
-	gbaudio_unregister_module(gbmodule);
-
-release_topology:
 	gbaudio_tplg_release(gbmodule);
 	gbmodule->topology = NULL;
 
@@ -371,11 +372,11 @@ static void gb_audio_disconnect(struct gb_bundle *bundle)
 	struct gbaudio_module_info *gbmodule = greybus_get_drvdata(bundle);
 	struct gbaudio_data_connection *dai, *_dai;
 
-	gbaudio_unregister_module(gbmodule);
 
 	/* inform uevent to above layers */
 	gb_audio_manager_remove(gbmodule->manager_id);
 
+	gbaudio_unregister_module(gbmodule);
 	gbaudio_tplg_release(gbmodule);
 	gbmodule->topology = NULL;
 	kfree(gbmodule->topology);

commit 852859ab8186e7a492fdec5db5ef219bf625c21a
Author: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
Date:   Wed May 4 16:29:21 2016 +0530

    greybus: audio: Remove redundant lock protection & is_connected field
    
    Each module maintains connected status & a lock to protect it.
    Using codec->lock we can safely serialize ASoC specific callbacks
    (in response to mixer_ctl update or dai_ops) and gb module
    disconnect. Thus is_connected field can be removed.
    
    Signed-off-by: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/audio_module.c b/drivers/staging/greybus/audio_module.c
index 1e29901024cd..3b763710ddf6 100644
--- a/drivers/staging/greybus/audio_module.c
+++ b/drivers/staging/greybus/audio_module.c
@@ -26,12 +26,10 @@ static int gbaudio_request_jack(struct gbaudio_module_info *module,
 	dev_warn(module->dev, "Jack Event received: type: %u, event: %u\n",
 		 req->jack_attribute, req->event);
 
-	mutex_lock(&module->lock);
 	if (req->event == GB_AUDIO_JACK_EVENT_REMOVAL) {
 		module->jack_type = 0;
 		button_status = module->button_status;
 		module->button_status = 0;
-		mutex_unlock(&module->lock);
 		if (button_status)
 			snd_soc_jack_report(&module->button_jack, 0,
 					    GBCODEC_JACK_BUTTON_MASK);
@@ -48,7 +46,6 @@ static int gbaudio_request_jack(struct gbaudio_module_info *module,
 			 module->jack_type, report);
 
 	module->jack_type = report;
-	mutex_unlock(&module->lock);
 	snd_soc_jack_report(&module->headset_jack, report, GBCODEC_JACK_MASK);
 
 	return 0;
@@ -63,10 +60,8 @@ static int gbaudio_request_button(struct gbaudio_module_info *module,
 		 req->button_id, req->event);
 
 	/* currently supports 4 buttons only */
-	mutex_lock(&module->lock);
 	if (!module->jack_type) {
 		dev_err(module->dev, "Jack not present. Bogus event!!\n");
-		mutex_unlock(&module->lock);
 		return -EINVAL;
 	}
 
@@ -100,8 +95,6 @@ static int gbaudio_request_button(struct gbaudio_module_info *module,
 
 	module->button_status = report;
 
-	mutex_unlock(&module->lock);
-
 	snd_soc_jack_report(&module->button_jack, report,
 			    GBCODEC_JACK_BUTTON_MASK);
 
@@ -247,7 +240,6 @@ static int gb_audio_probe(struct gb_bundle *bundle,
 		return -ENOMEM;
 
 	gbmodule->num_data_connections = bundle->num_cports - 1;
-	mutex_init(&gbmodule->lock);
 	INIT_LIST_HEAD(&gbmodule->data_list);
 	INIT_LIST_HEAD(&gbmodule->widget_list);
 	INIT_LIST_HEAD(&gbmodule->ctl_list);
@@ -327,7 +319,6 @@ static int gb_audio_probe(struct gb_bundle *bundle,
 		if (ret)
 			goto disable_data_connection;
 	}
-	gbmodule->is_connected = 1;
 
 	/* inform above layer for uevent */
 	dev_dbg(dev, "Inform set_event:%d to above layer\n", 1);

commit e6ab7a154c5dbfc0ad08bf1570efea22f2c7ee6c
Author: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
Date:   Wed May 4 16:29:20 2016 +0530

    greybus: audio: Cleanup GB Audio bundle driver.
    
    Remove unnecessary lock & list maintained in GB audio bundle
    driver
    
    Signed-off-by: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/audio_module.c b/drivers/staging/greybus/audio_module.c
index 05bda486f490..1e29901024cd 100644
--- a/drivers/staging/greybus/audio_module.c
+++ b/drivers/staging/greybus/audio_module.c
@@ -14,9 +14,6 @@
 #include "audio_apbridgea.h"
 #include "audio_manager.h"
 
-static DEFINE_MUTEX(gb_codec_list_lock);
-static LIST_HEAD(gb_codec_list);
-
 /*
  * gb_snd management functions
  */
@@ -241,16 +238,13 @@ static int gb_audio_probe(struct gb_bundle *bundle,
 	if (bundle->num_cports < 2)
 		return -ENODEV;
 
-	mutex_lock(&gb_codec_list_lock);
 	/*
 	 * There can be only one Management connection and any number of data
 	 * connections.
 	 */
 	gbmodule = devm_kzalloc(dev, sizeof(*gbmodule), GFP_KERNEL);
-	if (!gbmodule) {
-		mutex_unlock(&gb_codec_list_lock);
+	if (!gbmodule)
 		return -ENOMEM;
-	}
 
 	gbmodule->num_data_connections = bundle->num_cports - 1;
 	mutex_init(&gbmodule->lock);
@@ -348,7 +342,6 @@ static int gb_audio_probe(struct gb_bundle *bundle,
 	gbmodule->manager_id = gb_audio_manager_add(&desc);
 
 	dev_dbg(dev, "Add GB Audio device:%s\n", gbmodule->name);
-	mutex_unlock(&gb_codec_list_lock);
 
 	return 0;
 
@@ -378,7 +371,6 @@ static int gb_audio_probe(struct gb_bundle *bundle,
 		gb_connection_destroy(gbmodule->mgmt_connection);
 
 	devm_kfree(dev, gbmodule);
-	mutex_unlock(&gb_codec_list_lock);
 
 	return ret;
 }
@@ -388,8 +380,6 @@ static void gb_audio_disconnect(struct gb_bundle *bundle)
 	struct gbaudio_module_info *gbmodule = greybus_get_drvdata(bundle);
 	struct gbaudio_data_connection *dai, *_dai;
 
-	mutex_lock(&gb_codec_list_lock);
-
 	gbaudio_unregister_module(gbmodule);
 
 	/* inform uevent to above layers */
@@ -409,7 +399,6 @@ static void gb_audio_disconnect(struct gb_bundle *bundle)
 	gbmodule->mgmt_connection = NULL;
 
 	devm_kfree(&bundle->dev, gbmodule);
-	mutex_unlock(&gb_codec_list_lock);
 }
 
 static const struct greybus_bundle_id gb_audio_id_table[] = {

commit 05ab5f0daa524915176d170f3873b97ad10d7c43
Author: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
Date:   Wed Apr 13 09:53:39 2016 +0530

    greybus: audio: Identify jack type based on attributes reported
    
    Originally, idea was to use widget_type to identify jack_type.
    However, suggestive way is to identify jack based on jack
    attributes.
    
    Changes already exists in codec FW to report jack attributes.
    
    Signed-off-by: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
    Reviewed-by: Mark Greer <mgreer@animalcreek.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/audio_module.c b/drivers/staging/greybus/audio_module.c
index bdc5ec50b30b..05bda486f490 100644
--- a/drivers/staging/greybus/audio_module.c
+++ b/drivers/staging/greybus/audio_module.c
@@ -27,7 +27,7 @@ static int gbaudio_request_jack(struct gbaudio_module_info *module,
 	int report, button_status;
 
 	dev_warn(module->dev, "Jack Event received: type: %u, event: %u\n",
-		 req->widget_type, req->event);
+		 req->jack_attribute, req->event);
 
 	mutex_lock(&module->lock);
 	if (req->event == GB_AUDIO_JACK_EVENT_REMOVAL) {
@@ -43,18 +43,9 @@ static int gbaudio_request_jack(struct gbaudio_module_info *module,
 		return 0;
 	}
 
-	report &= ~GBCODEC_JACK_MASK;
 	/* currently supports Headphone, Headset & Lineout only */
-	if (req->widget_type && GB_AUDIO_WIDGET_TYPE_HP)
-		report |=  SND_JACK_HEADPHONE & GBCODEC_JACK_MASK;
-
-	if (req->widget_type && GB_AUDIO_WIDGET_TYPE_MIC)
-		report = SND_JACK_MICROPHONE & GBCODEC_JACK_MASK;
-
-	if (req->widget_type && GB_AUDIO_WIDGET_TYPE_LINE)
-		report = (report & GBCODEC_JACK_MASK) |
-			SND_JACK_LINEOUT | SND_JACK_LINEIN;
-
+	report &= ~GBCODEC_JACK_MASK;
+	report |= req->jack_attribute & GBCODEC_JACK_MASK;
 	if (module->jack_type)
 		dev_warn(module->dev, "Modifying jack from %d to %d\n",
 			 module->jack_type, report);

commit 2b8c2b51000e3d056f9aa27a64b93feabddf77a4
Author: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
Date:   Thu Apr 21 22:14:02 2016 +0530

    greybus: audio: Changes in response to ASoC cleanup
    
    Update Makefile in response to SND_SOC_DYNAMIC_DAILINK cflag
    removal.
    
    Update files for msm-dynamic-dailink.h header file removal.
    
    Update in response to API name changes. Also, acquire sound card
    controls_rwsem before adding kcontrols to avoid deadlock.
    
    Signed-off-by: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
    Reviewed-by: Mark Greer <mgreer@animalcreek.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/audio_module.c b/drivers/staging/greybus/audio_module.c
index dd43b6d5ae07..bdc5ec50b30b 100644
--- a/drivers/staging/greybus/audio_module.c
+++ b/drivers/staging/greybus/audio_module.c
@@ -9,7 +9,6 @@
 #include <linux/module.h>
 #include <sound/soc.h>
 #include <sound/pcm_params.h>
-#include <sound/msm-dynamic-dailink.h>
 
 #include "audio_codec.h"
 #include "audio_apbridgea.h"

commit 89de9a06213240b9266f9f368a867cf90d0024bf
Author: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
Date:   Wed Mar 30 13:23:56 2016 +0530

    greybus: audio: Update device type based on widget types
    
    Device type info shared to above HAL is currently hard coded
    to SPK only. Actual device type is identifed while parsing
    widget types from topology FW shared by codec module.
    
    Signed-off-by: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
    Reviewed-by: Mark Greer <mgreer@animalcreek.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/audio_module.c b/drivers/staging/greybus/audio_module.c
index a7f961f85e21..dd43b6d5ae07 100644
--- a/drivers/staging/greybus/audio_module.c
+++ b/drivers/staging/greybus/audio_module.c
@@ -353,8 +353,8 @@ static int gb_audio_probe(struct gb_bundle *bundle,
 	desc.vid = 2; /* todo */
 	desc.pid = 3; /* todo */
 	desc.cport = gbmodule->dev_id;
-	desc.op_devices = 0x2; /* todo */
-	desc.ip_devices = 0x0; /* todo */
+	desc.op_devices = gbmodule->op_devices;
+	desc.ip_devices = gbmodule->ip_devices;
 	gbmodule->manager_id = gb_audio_manager_add(&desc);
 
 	dev_dbg(dev, "Add GB Audio device:%s\n", gbmodule->name);

commit a9234bfd6cec4420b5bef29d77dce1f9cb0543e2
Author: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
Date:   Wed Mar 30 13:23:55 2016 +0530

    greybus: audio_manager: Split device type into i/p & o/p devices
    
    Currently, single field is used to report device type say SPK,
    MIC, HS, HP, etc. However above HAL expects separate fields for
    input & ouput device types.
    
    Signed-off-by: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
    Reviewed-by: Mark Greer <mgreer@animalcreek.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/audio_module.c b/drivers/staging/greybus/audio_module.c
index 9039aa63e040..a7f961f85e21 100644
--- a/drivers/staging/greybus/audio_module.c
+++ b/drivers/staging/greybus/audio_module.c
@@ -353,7 +353,8 @@ static int gb_audio_probe(struct gb_bundle *bundle,
 	desc.vid = 2; /* todo */
 	desc.pid = 3; /* todo */
 	desc.cport = gbmodule->dev_id;
-	desc.devices = 0x2; /* todo */
+	desc.op_devices = 0x2; /* todo */
+	desc.ip_devices = 0x0; /* todo */
 	gbmodule->manager_id = gb_audio_manager_add(&desc);
 
 	dev_dbg(dev, "Add GB Audio device:%s\n", gbmodule->name);

commit 64a7e2cceb75ccabaec713944a95511605751b29
Author: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
Date:   Tue Mar 29 16:32:36 2016 +0530

    greybus: audio: Added jack support to audio module
    
    Register jack with ASoC sound card in case audio module
    populates it via codec FW. Currently, only a single jack
    with 4 buttons can be registered for each module.
    
    Signed-off-by: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
    Reviewed-by: Mark Greer <mgreer@animalcreek.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/audio_module.c b/drivers/staging/greybus/audio_module.c
index 94fdadc67c18..9039aa63e040 100644
--- a/drivers/staging/greybus/audio_module.c
+++ b/drivers/staging/greybus/audio_module.c
@@ -22,18 +22,150 @@ static LIST_HEAD(gb_codec_list);
  * gb_snd management functions
  */
 
-static int gbaudio_codec_request_handler(struct gb_operation *op)
+static int gbaudio_request_jack(struct gbaudio_module_info *module,
+				  struct gb_audio_jack_event_request *req)
 {
-	struct gb_connection *connection = op->connection;
-	struct gb_audio_streaming_event_request *req = op->request->payload;
+	int report, button_status;
+
+	dev_warn(module->dev, "Jack Event received: type: %u, event: %u\n",
+		 req->widget_type, req->event);
+
+	mutex_lock(&module->lock);
+	if (req->event == GB_AUDIO_JACK_EVENT_REMOVAL) {
+		module->jack_type = 0;
+		button_status = module->button_status;
+		module->button_status = 0;
+		mutex_unlock(&module->lock);
+		if (button_status)
+			snd_soc_jack_report(&module->button_jack, 0,
+					    GBCODEC_JACK_BUTTON_MASK);
+		snd_soc_jack_report(&module->headset_jack, 0,
+				    GBCODEC_JACK_MASK);
+		return 0;
+	}
+
+	report &= ~GBCODEC_JACK_MASK;
+	/* currently supports Headphone, Headset & Lineout only */
+	if (req->widget_type && GB_AUDIO_WIDGET_TYPE_HP)
+		report |=  SND_JACK_HEADPHONE & GBCODEC_JACK_MASK;
+
+	if (req->widget_type && GB_AUDIO_WIDGET_TYPE_MIC)
+		report = SND_JACK_MICROPHONE & GBCODEC_JACK_MASK;
+
+	if (req->widget_type && GB_AUDIO_WIDGET_TYPE_LINE)
+		report = (report & GBCODEC_JACK_MASK) |
+			SND_JACK_LINEOUT | SND_JACK_LINEIN;
+
+	if (module->jack_type)
+		dev_warn(module->dev, "Modifying jack from %d to %d\n",
+			 module->jack_type, report);
+
+	module->jack_type = report;
+	mutex_unlock(&module->lock);
+	snd_soc_jack_report(&module->headset_jack, report, GBCODEC_JACK_MASK);
+
+	return 0;
+}
+
+static int gbaudio_request_button(struct gbaudio_module_info *module,
+				  struct gb_audio_button_event_request *req)
+{
+	int soc_button_id, report;
+
+	dev_warn(module->dev, "Button Event received: id: %u, event: %u\n",
+		 req->button_id, req->event);
+
+	/* currently supports 4 buttons only */
+	mutex_lock(&module->lock);
+	if (!module->jack_type) {
+		dev_err(module->dev, "Jack not present. Bogus event!!\n");
+		mutex_unlock(&module->lock);
+		return -EINVAL;
+	}
+
+	report = module->button_status & GBCODEC_JACK_BUTTON_MASK;
+
+	switch (req->button_id) {
+	case 1:
+		soc_button_id = SND_JACK_BTN_0;
+		break;
+
+	case 2:
+		soc_button_id = SND_JACK_BTN_1;
+		break;
 
-	dev_warn(&connection->bundle->dev,
-		 "Audio Event received: cport: %u, event: %u\n",
+	case 3:
+		soc_button_id = SND_JACK_BTN_2;
+		break;
+
+	case 4:
+		soc_button_id = SND_JACK_BTN_3;
+		break;
+	default:
+		dev_err(module->dev, "Invalid button request received\n");
+		return -EINVAL;
+	}
+
+	if (req->event == GB_AUDIO_BUTTON_EVENT_PRESS)
+		report = report | soc_button_id;
+	else
+		report = report & ~soc_button_id;
+
+	module->button_status = report;
+
+	mutex_unlock(&module->lock);
+
+	snd_soc_jack_report(&module->button_jack, report,
+			    GBCODEC_JACK_BUTTON_MASK);
+
+	return 0;
+}
+
+static int gbaudio_request_stream(struct gbaudio_module_info *module,
+				  struct gb_audio_streaming_event_request *req)
+{
+	dev_warn(module->dev, "Audio Event received: cport: %u, event: %u\n",
 		 req->data_cport, req->event);
 
 	return 0;
 }
 
+static int gbaudio_codec_request_handler(struct gb_operation *op)
+{
+	struct gb_connection *connection = op->connection;
+	struct gbaudio_module_info *module =
+		greybus_get_drvdata(connection->bundle);
+	struct gb_operation_msg_hdr *header = op->request->header;
+	struct gb_audio_streaming_event_request *stream_req;
+	struct gb_audio_jack_event_request *jack_req;
+	struct gb_audio_button_event_request *button_req;
+	int ret;
+
+	switch (header->type) {
+	case GB_AUDIO_TYPE_STREAMING_EVENT:
+		stream_req = op->request->payload;
+		ret = gbaudio_request_stream(module, stream_req);
+		break;
+
+	case GB_AUDIO_TYPE_JACK_EVENT:
+		jack_req = op->request->payload;
+		ret = gbaudio_request_jack(module, jack_req);
+		break;
+
+	case GB_AUDIO_TYPE_BUTTON_EVENT:
+		button_req = op->request->payload;
+		ret = gbaudio_request_button(module, button_req);
+		break;
+
+	default:
+		dev_err(&connection->bundle->dev,
+			"Invalid Audio Event received\n");
+		return -EINVAL;
+	}
+
+	return ret;
+}
+
 static int gbaudio_data_connection_request_handler(struct gb_operation *op)
 {
 	struct gb_connection *connection = op->connection;

commit 5793227cb037e4fddf1dc869b0e0abcc22646f6b
Author: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
Date:   Tue Mar 29 23:31:42 2016 +0530

    greybus: audio: Add module specific driver
    
    Use seperate driver to process GB Audio modules plugged-in.
    It'll use helper function register_module to attach itself
    to gbaudio-codec driver.
    
    Signed-off-by: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
    Reviewed-by: Mark Greer <mark.greer@animalcreek.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/audio_module.c b/drivers/staging/greybus/audio_module.c
new file mode 100644
index 000000000000..94fdadc67c18
--- /dev/null
+++ b/drivers/staging/greybus/audio_module.c
@@ -0,0 +1,309 @@
+/*
+ * Greybus audio driver
+ * Copyright 2015 Google Inc.
+ * Copyright 2015 Linaro Ltd.
+ *
+ * Released under the GPLv2 only.
+ */
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <sound/soc.h>
+#include <sound/pcm_params.h>
+#include <sound/msm-dynamic-dailink.h>
+
+#include "audio_codec.h"
+#include "audio_apbridgea.h"
+#include "audio_manager.h"
+
+static DEFINE_MUTEX(gb_codec_list_lock);
+static LIST_HEAD(gb_codec_list);
+
+/*
+ * gb_snd management functions
+ */
+
+static int gbaudio_codec_request_handler(struct gb_operation *op)
+{
+	struct gb_connection *connection = op->connection;
+	struct gb_audio_streaming_event_request *req = op->request->payload;
+
+	dev_warn(&connection->bundle->dev,
+		 "Audio Event received: cport: %u, event: %u\n",
+		 req->data_cport, req->event);
+
+	return 0;
+}
+
+static int gbaudio_data_connection_request_handler(struct gb_operation *op)
+{
+	struct gb_connection *connection = op->connection;
+
+	dev_warn(&connection->bundle->dev, "Audio Event received\n");
+
+	return 0;
+}
+
+static int gb_audio_add_mgmt_connection(struct gbaudio_module_info *gbmodule,
+				struct greybus_descriptor_cport *cport_desc,
+				struct gb_bundle *bundle)
+{
+	struct gb_connection *connection;
+
+	/* Management Cport */
+	if (gbmodule->mgmt_connection) {
+		dev_err(&bundle->dev,
+			"Can't have multiple Management connections\n");
+		return -ENODEV;
+	}
+
+	connection = gb_connection_create(bundle, le16_to_cpu(cport_desc->id),
+					  gbaudio_codec_request_handler);
+	if (IS_ERR(connection))
+		return PTR_ERR(connection);
+
+	connection->private = gbmodule;
+	gbmodule->mgmt_connection = connection;
+
+	return 0;
+}
+
+static int gb_audio_add_data_connection(struct gbaudio_module_info *gbmodule,
+				struct greybus_descriptor_cport *cport_desc,
+				struct gb_bundle *bundle)
+{
+	struct gb_connection *connection;
+	struct gbaudio_data_connection *dai;
+
+	dai = devm_kzalloc(gbmodule->dev, sizeof(*dai), GFP_KERNEL);
+	if (!dai) {
+		dev_err(gbmodule->dev, "DAI Malloc failure\n");
+		return -ENOMEM;
+	}
+
+	connection = gb_connection_create_flags(bundle,
+					le16_to_cpu(cport_desc->id),
+					gbaudio_data_connection_request_handler,
+					GB_CONNECTION_FLAG_CSD);
+	if (IS_ERR(connection)) {
+		devm_kfree(gbmodule->dev, dai);
+		return PTR_ERR(connection);
+	}
+
+	connection->private = gbmodule;
+	/* dai->name should be same as codec->dai_name */
+	strlcpy(dai->name, "greybus-apb1", NAME_SIZE);
+	dai->data_cport = connection->intf_cport_id;
+	dai->connection = connection;
+	list_add(&dai->list, &gbmodule->data_list);
+
+	return 0;
+}
+
+/*
+ * This is the basic hook get things initialized and registered w/ gb
+ */
+
+static int gb_audio_probe(struct gb_bundle *bundle,
+			  const struct greybus_bundle_id *id)
+{
+	struct device *dev = &bundle->dev;
+	struct gbaudio_module_info *gbmodule;
+	struct greybus_descriptor_cport *cport_desc;
+	struct gb_audio_manager_module_descriptor desc;
+	struct gbaudio_data_connection *dai, *_dai;
+	int ret, i;
+	struct gb_audio_topology *topology;
+
+
+	/* There should be at least one Management and one Data cport */
+	if (bundle->num_cports < 2)
+		return -ENODEV;
+
+	mutex_lock(&gb_codec_list_lock);
+	/*
+	 * There can be only one Management connection and any number of data
+	 * connections.
+	 */
+	gbmodule = devm_kzalloc(dev, sizeof(*gbmodule), GFP_KERNEL);
+	if (!gbmodule) {
+		mutex_unlock(&gb_codec_list_lock);
+		return -ENOMEM;
+	}
+
+	gbmodule->num_data_connections = bundle->num_cports - 1;
+	mutex_init(&gbmodule->lock);
+	INIT_LIST_HEAD(&gbmodule->data_list);
+	INIT_LIST_HEAD(&gbmodule->widget_list);
+	INIT_LIST_HEAD(&gbmodule->ctl_list);
+	INIT_LIST_HEAD(&gbmodule->widget_ctl_list);
+	gbmodule->dev = dev;
+	snprintf(gbmodule->name, NAME_SIZE, "%s.%s", dev->driver->name,
+		 dev_name(dev));
+	greybus_set_drvdata(bundle, gbmodule);
+
+	/* Create all connections */
+	for (i = 0; i < bundle->num_cports; i++) {
+		cport_desc = &bundle->cport_desc[i];
+
+		switch (cport_desc->protocol_id) {
+		case GREYBUS_PROTOCOL_AUDIO_MGMT:
+			ret = gb_audio_add_mgmt_connection(gbmodule, cport_desc,
+							   bundle);
+			if (ret)
+				goto destroy_connections;
+			break;
+		case GREYBUS_PROTOCOL_AUDIO_DATA:
+			ret = gb_audio_add_data_connection(gbmodule, cport_desc,
+							   bundle);
+			if (ret)
+				goto destroy_connections;
+			break;
+		default:
+			dev_err(dev, "Unsupported protocol: 0x%02x\n",
+				cport_desc->protocol_id);
+			ret = -ENODEV;
+			goto destroy_connections;
+		}
+	}
+
+	/* There must be a management cport */
+	if (!gbmodule->mgmt_connection) {
+		ret = -EINVAL;
+		dev_err(dev, "Missing management connection\n");
+		goto destroy_connections;
+	}
+
+	/* Initialize management connection */
+	ret = gb_connection_enable(gbmodule->mgmt_connection);
+	if (ret) {
+		dev_err(dev, "%d: Error while enabling mgmt connection\n", ret);
+		goto destroy_connections;
+	}
+	gbmodule->dev_id = gbmodule->mgmt_connection->intf->interface_id;
+
+	/*
+	 * FIXME: malloc for topology happens via audio_gb driver
+	 * should be done within codec driver itself
+	 */
+	ret = gb_audio_gb_get_topology(gbmodule->mgmt_connection, &topology);
+	if (ret) {
+		dev_err(dev, "%d:Error while fetching topology\n", ret);
+		goto disable_connection;
+	}
+
+	/* process topology data */
+	ret = gbaudio_tplg_parse_data(gbmodule, topology);
+	if (ret) {
+		dev_err(dev, "%d:Error while parsing topology data\n",
+			  ret);
+		goto free_topology;
+	}
+	gbmodule->topology = topology;
+
+	/* register module with gbcodec */
+	ret = gbaudio_register_module(gbmodule);
+	if (ret)
+		goto release_topology;
+
+	/* Initialize data connections */
+	list_for_each_entry(dai, &gbmodule->data_list, list) {
+		ret = gb_connection_enable(dai->connection);
+		if (ret)
+			goto disable_data_connection;
+	}
+	gbmodule->is_connected = 1;
+
+	/* inform above layer for uevent */
+	dev_dbg(dev, "Inform set_event:%d to above layer\n", 1);
+	/* prepare for the audio manager */
+	strlcpy(desc.name, gbmodule->name, GB_AUDIO_MANAGER_MODULE_NAME_LEN);
+	desc.slot = 1; /* todo */
+	desc.vid = 2; /* todo */
+	desc.pid = 3; /* todo */
+	desc.cport = gbmodule->dev_id;
+	desc.devices = 0x2; /* todo */
+	gbmodule->manager_id = gb_audio_manager_add(&desc);
+
+	dev_dbg(dev, "Add GB Audio device:%s\n", gbmodule->name);
+	mutex_unlock(&gb_codec_list_lock);
+
+	return 0;
+
+disable_data_connection:
+	list_for_each_entry_safe(dai, _dai, &gbmodule->data_list, list)
+		gb_connection_disable(dai->connection);
+	gbaudio_unregister_module(gbmodule);
+
+release_topology:
+	gbaudio_tplg_release(gbmodule);
+	gbmodule->topology = NULL;
+
+free_topology:
+	kfree(topology);
+
+disable_connection:
+	gb_connection_disable(gbmodule->mgmt_connection);
+
+destroy_connections:
+	list_for_each_entry_safe(dai, _dai, &gbmodule->data_list, list) {
+		gb_connection_destroy(dai->connection);
+		list_del(&dai->list);
+		devm_kfree(dev, dai);
+	}
+
+	if (gbmodule->mgmt_connection)
+		gb_connection_destroy(gbmodule->mgmt_connection);
+
+	devm_kfree(dev, gbmodule);
+	mutex_unlock(&gb_codec_list_lock);
+
+	return ret;
+}
+
+static void gb_audio_disconnect(struct gb_bundle *bundle)
+{
+	struct gbaudio_module_info *gbmodule = greybus_get_drvdata(bundle);
+	struct gbaudio_data_connection *dai, *_dai;
+
+	mutex_lock(&gb_codec_list_lock);
+
+	gbaudio_unregister_module(gbmodule);
+
+	/* inform uevent to above layers */
+	gb_audio_manager_remove(gbmodule->manager_id);
+
+	gbaudio_tplg_release(gbmodule);
+	gbmodule->topology = NULL;
+	kfree(gbmodule->topology);
+	gb_connection_disable(gbmodule->mgmt_connection);
+	list_for_each_entry_safe(dai, _dai, &gbmodule->data_list, list) {
+		gb_connection_disable(dai->connection);
+		gb_connection_destroy(dai->connection);
+		list_del(&dai->list);
+		devm_kfree(gbmodule->dev, dai);
+	}
+	gb_connection_destroy(gbmodule->mgmt_connection);
+	gbmodule->mgmt_connection = NULL;
+
+	devm_kfree(&bundle->dev, gbmodule);
+	mutex_unlock(&gb_codec_list_lock);
+}
+
+static const struct greybus_bundle_id gb_audio_id_table[] = {
+	{ GREYBUS_DEVICE_CLASS(GREYBUS_CLASS_AUDIO) },
+	{ }
+};
+MODULE_DEVICE_TABLE(greybus, gb_audio_id_table);
+
+static struct greybus_driver gb_audio_driver = {
+	.name		= "gb-audio",
+	.probe		= gb_audio_probe,
+	.disconnect	= gb_audio_disconnect,
+	.id_table	= gb_audio_id_table,
+};
+module_greybus_driver(gb_audio_driver);
+
+MODULE_DESCRIPTION("Greybus Audio module driver");
+MODULE_AUTHOR("Vaibhav Agarwal <vaibhav.agarwal@linaro.org>");
+MODULE_LICENSE("GPL v2");
+MODULE_ALIAS("platform:gbaudio-module");
