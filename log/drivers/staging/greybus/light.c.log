commit 9bb086e5ba9495ac150fbbcc5c8c2bccc06261dd
Author: Chen Zhou <chenzhou10@huawei.com>
Date:   Wed Apr 1 11:00:17 2020 +0800

    staging: greybus: fix a missing-check bug in gb_lights_light_config()
    
    In gb_lights_light_config(), 'light->name' is allocated by kstrndup().
    It returns NULL when fails, add check for it.
    
    Signed-off-by: Chen Zhou <chenzhou10@huawei.com>
    Acked-by: Rui Miguel Silva <rmfrfs@gmail.com>
    Link: https://lore.kernel.org/r/20200401030017.100274-1-chenzhou10@huawei.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/light.c b/drivers/staging/greybus/light.c
index d6ba25f21d80..d2672b65c3f4 100644
--- a/drivers/staging/greybus/light.c
+++ b/drivers/staging/greybus/light.c
@@ -1026,7 +1026,8 @@ static int gb_lights_light_config(struct gb_lights *glights, u8 id)
 
 	light->channels_count = conf.channel_count;
 	light->name = kstrndup(conf.name, NAMES_MAX, GFP_KERNEL);
-
+	if (!light->name)
+		return -ENOMEM;
 	light->channels = kcalloc(light->channels_count,
 				  sizeof(struct gb_channel), GFP_KERNEL);
 	if (!light->channels)

commit 329101244f214952606359d254ae883b7109e1a5
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Thu Aug 29 15:28:39 2019 +0300

    staging: greybus: light: fix a couple double frees
    
    The problem is in gb_lights_request_handler().  If we get a request to
    change the config then we release the light with gb_lights_light_release()
    and re-allocated it.  However, if the allocation fails part way through
    then we call gb_lights_light_release() again.  This can lead to a couple
    different double frees where we haven't cleared out the original values:
    
            gb_lights_light_v4l2_unregister(light);
            ...
            kfree(light->channels);
            kfree(light->name);
    
    I also made a small change to how we set "light->channels_count = 0;".
    The original code handled this part fine and did not cause a use after
    free but it was sort of complicated to read.
    
    Fixes: 2870b52bae4c ("greybus: lights: add lights implementation")
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Acked-by: Rui Miguel Silva <rmfrfs@gmail.com>
    Link: https://lore.kernel.org/r/20190829122839.GA20116@mwanda
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/light.c b/drivers/staging/greybus/light.c
index b3b1b253d112..d6ba25f21d80 100644
--- a/drivers/staging/greybus/light.c
+++ b/drivers/staging/greybus/light.c
@@ -1096,21 +1096,21 @@ static void gb_lights_channel_release(struct gb_channel *channel)
 static void gb_lights_light_release(struct gb_light *light)
 {
 	int i;
-	int count;
 
 	light->ready = false;
 
-	count = light->channels_count;
-
 	if (light->has_flash)
 		gb_lights_light_v4l2_unregister(light);
+	light->has_flash = false;
 
-	for (i = 0; i < count; i++) {
+	for (i = 0; i < light->channels_count; i++)
 		gb_lights_channel_release(&light->channels[i]);
-		light->channels_count--;
-	}
+	light->channels_count = 0;
+
 	kfree(light->channels);
+	light->channels = NULL;
 	kfree(light->name);
+	light->name = NULL;
 }
 
 static void gb_lights_release(struct gb_lights *glights)

commit ec0ad868173da8a75121f9dc116a5d5478ff614d
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Sun Aug 25 07:54:27 2019 +0200

    staging: greybus: move core include files to include/linux/greybus/
    
    With the goal of moving the core of the greybus code out of staging, the
    include files need to be moved to include/linux/greybus.h and
    include/linux/greybus/
    
    Cc: Vaibhav Hiremath <hvaibhav.linux@gmail.com>
    Cc: Johan Hovold <johan@kernel.org>
    Cc: Vaibhav Agarwal <vaibhav.sr@gmail.com>
    Cc: Rui Miguel Silva <rmfrfs@gmail.com>
    Cc: David Lin <dtwlin@gmail.com>
    Cc: "Bryan O'Donoghue" <pure.logic@nexus-software.ie>
    Cc: greybus-dev@lists.linaro.org
    Cc: devel@driverdev.osuosl.org
    Acked-by: Mark Greer <mgreer@animalcreek.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Acked-by: Alex Elder <elder@kernel.org>
    Link: https://lore.kernel.org/r/20190825055429.18547-8-gregkh@linuxfoundation.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/light.c b/drivers/staging/greybus/light.c
index 010ae1e9c7fb..b3b1b253d112 100644
--- a/drivers/staging/greybus/light.c
+++ b/drivers/staging/greybus/light.c
@@ -11,11 +11,9 @@
 #include <linux/led-class-flash.h>
 #include <linux/module.h>
 #include <linux/slab.h>
+#include <linux/greybus.h>
 #include <media/v4l2-flash-led-class.h>
 
-#include "greybus.h"
-#include "greybus_protocols.h"
-
 #define NAMES_MAX	32
 
 struct gb_channel {

commit 863dbc52e7f0e5acd7b4883f3933543a81c474c7
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Nov 7 14:58:42 2017 +0100

    staging: greybus: Remove redundant license text
    
    Now that the SPDX tag is in all greybus files, that identifies the
    license in a specific and legally-defined manner.  So the extra GPL text
    wording can be removed as it is no longer needed at all.
    
    This is done on a quest to remove the 700+ different ways that files in
    the kernel describe the GPL license text.  And there's unneeded stuff
    like the address (sometimes incorrect) for the FSF which is never
    needed.
    
    No copyright headers or other non-license-description text was removed.
    
    Cc: Vaibhav Hiremath <hvaibhav.linux@gmail.com>
    Reviewed-by: Alex Elder <elder@linaro.org>
    Acked-by: Vaibhav Agarwal <vaibhav.sr@gmail.com>
    Acked-by: David Lin <dtwlin@gmail.com>
    Acked-by: Johan Hovold <johan@kernel.org>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Acked-by: Mark Greer <mgreer@animalcreek.com>
    Acked-by: Rui Miguel Silva <rmfrfs@gmail.com>
    Acked-by: "Bryan O'Donoghue" <pure.logic@nexus-software.ie>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/light.c b/drivers/staging/greybus/light.c
index 51bf9e28aac4..010ae1e9c7fb 100644
--- a/drivers/staging/greybus/light.c
+++ b/drivers/staging/greybus/light.c
@@ -4,8 +4,6 @@
  *
  * Copyright 2015 Google Inc.
  * Copyright 2015 Linaro Ltd.
- *
- * Released under the GPLv2 only.
  */
 
 #include <linux/kernel.h>

commit eb50fd3a22c770f36be275295b782f3ea52e3215
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Nov 7 14:58:41 2017 +0100

    staging: greybus: add SPDX identifiers to all greybus driver files
    
    It's good to have SPDX identifiers in all files to make it easier to
    audit the kernel tree for correct licenses.
    
    Update the drivers/staging/greybus files files with the correct SPDX
    license identifier based on the license text in the file itself.  The
    SPDX identifier is a legally binding shorthand, which can be used
    instead of the full boiler plate text.
    
    This work is based on a script and data from Thomas Gleixner, Philippe
    Ombredanne, and Kate Stewart.
    
    Cc: Vaibhav Hiremath <hvaibhav.linux@gmail.com>
    Cc: "Bryan O'Donoghue" <pure.logic@nexus-software.ie>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: Philippe Ombredanne <pombredanne@nexb.com>
    Acked-by: Vaibhav Agarwal <vaibhav.sr@gmail.com>
    Acked-by: David Lin <dtwlin@gmail.com>
    Reviewed-by: Alex Elder <elder@linaro.org>
    Acked-by: Johan Hovold <johan@kernel.org>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Acked-by: Mark Greer <mgreer@animalcreek.com>
    Acked-by: Rui Miguel Silva <rmfrfs@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/light.c b/drivers/staging/greybus/light.c
index d7da475f9d33..51bf9e28aac4 100644
--- a/drivers/staging/greybus/light.c
+++ b/drivers/staging/greybus/light.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * Greybus Lights protocol driver.
  *

commit 1cd5929ab675b285e2179ec33cb0fef185aaabd1
Author: Arvind Yadav <arvind.yadav.cs@gmail.com>
Date:   Sat Sep 23 13:39:15 2017 +0530

    staging: greybus: light: remove unnecessary error check
    
    It is not necessary to check return value of gb_lights_channel_flash_config.
    gb_lights_channel_config returns both successful and error value.
    
    Signed-off-by: Arvind Yadav <arvind.yadav.cs@gmail.com>
    Reviewed-by: Rui Miguel Silva <rmfrfs@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/light.c b/drivers/staging/greybus/light.c
index 0f538b8c3a07..d7da475f9d33 100644
--- a/drivers/staging/greybus/light.c
+++ b/drivers/staging/greybus/light.c
@@ -1000,11 +1000,7 @@ static int gb_lights_channel_config(struct gb_light *light,
 
 	light->has_flash = true;
 
-	ret = gb_lights_channel_flash_config(channel);
-	if (ret < 0)
-		return ret;
-
-	return ret;
+	return gb_lights_channel_flash_config(channel);
 }
 
 static int gb_lights_light_config(struct gb_lights *glights, u8 id)

commit 04820da21050b35eed68aa046115d810163ead0c
Author: Arvind Yadav <arvind.yadav.cs@gmail.com>
Date:   Sat Sep 23 13:25:30 2017 +0530

    staging: greybus: light: Release memory obtained by kasprintf
    
    Free memory region, if gb_lights_channel_config is not successful.
    
    Signed-off-by: Arvind Yadav <arvind.yadav.cs@gmail.com>
    Reviewed-by: Rui Miguel Silva <rmfrfs@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/light.c b/drivers/staging/greybus/light.c
index 3f4148c92308..0f538b8c3a07 100644
--- a/drivers/staging/greybus/light.c
+++ b/drivers/staging/greybus/light.c
@@ -925,6 +925,8 @@ static void __gb_lights_led_unregister(struct gb_channel *channel)
 		return;
 
 	led_classdev_unregister(cdev);
+	kfree(cdev->name);
+	cdev->name = NULL;
 	channel->led = NULL;
 }
 

commit 503dd28af108888c505e8d6a86f4acf5eb20f3b7
Author: Sakari Ailus <sakari.ailus@linux.intel.com>
Date:   Tue Jul 18 09:26:59 2017 -0400

    media: v4l2-flash-led-class: Create separate sub-devices for indicators
    
    The V4L2 flash interface allows controlling multiple LEDs through a single
    sub-devices if, and only if, these LEDs are of different types. This
    approach scales badly for flash controllers that drive multiple flash LEDs
    or for LED specific associations. Essentially, the original assumption of a
    LED driver chip that drives a single flash LED and an indicator LED is no
    longer valid.
    
    Address the matter by registering one sub-device per LED.
    
    Signed-off-by: Sakari Ailus <sakari.ailus@linux.intel.com>
    Reviewed-by: Jacek Anaszewski <jacek.anaszewski@gmail.com>
    Acked-by: Pavel Machek <pavel@ucw.cz>
    Reviewed-by: Rui Miguel Silva <rmfrfs@gmail.com> (for greybus/light)
    Acked-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/staging/greybus/light.c b/drivers/staging/greybus/light.c
index 81469d087e74..3f4148c92308 100644
--- a/drivers/staging/greybus/light.c
+++ b/drivers/staging/greybus/light.c
@@ -58,6 +58,7 @@ struct gb_light {
 	bool			ready;
 #if IS_REACHABLE(CONFIG_V4L2_FLASH_LED_CLASS)
 	struct v4l2_flash	*v4l2_flash;
+	struct v4l2_flash	*v4l2_flash_ind;
 #endif
 };
 
@@ -534,7 +535,7 @@ static int gb_lights_light_v4l2_register(struct gb_light *light)
 {
 	struct gb_connection *connection = get_conn_from_light(light);
 	struct device *dev = &connection->bundle->dev;
-	struct v4l2_flash_config sd_cfg = { {0} };
+	struct v4l2_flash_config sd_cfg = { {0} }, sd_cfg_ind = { {0} };
 	struct led_classdev_flash *fled;
 	struct led_classdev *iled = NULL;
 	struct gb_channel *channel_torch, *channel_ind, *channel_flash;
@@ -542,12 +543,12 @@ static int gb_lights_light_v4l2_register(struct gb_light *light)
 	channel_torch = get_channel_from_mode(light, GB_CHANNEL_MODE_TORCH);
 	if (channel_torch)
 		__gb_lights_channel_v4l2_config(&channel_torch->intensity_uA,
-						&sd_cfg.torch_intensity);
+						&sd_cfg.intensity);
 
 	channel_ind = get_channel_from_mode(light, GB_CHANNEL_MODE_INDICATOR);
 	if (channel_ind) {
 		__gb_lights_channel_v4l2_config(&channel_ind->intensity_uA,
-						&sd_cfg.indicator_intensity);
+						&sd_cfg_ind.intensity);
 		iled = &channel_ind->fled.led_cdev;
 	}
 
@@ -557,6 +558,8 @@ static int gb_lights_light_v4l2_register(struct gb_light *light)
 	fled = &channel_flash->fled;
 
 	snprintf(sd_cfg.dev_name, sizeof(sd_cfg.dev_name), "%s", light->name);
+	snprintf(sd_cfg_ind.dev_name, sizeof(sd_cfg_ind.dev_name),
+		 "%s indicator", light->name);
 
 	/* Set the possible values to faults, in our case all faults */
 	sd_cfg.flash_faults = LED_FAULT_OVER_VOLTAGE | LED_FAULT_TIMEOUT |
@@ -565,16 +568,26 @@ static int gb_lights_light_v4l2_register(struct gb_light *light)
 		LED_FAULT_UNDER_VOLTAGE | LED_FAULT_INPUT_VOLTAGE |
 		LED_FAULT_LED_OVER_TEMPERATURE;
 
-	light->v4l2_flash = v4l2_flash_init(dev, NULL, fled, iled,
-					    &v4l2_flash_ops, &sd_cfg);
+	light->v4l2_flash = v4l2_flash_init(dev, NULL, fled, &v4l2_flash_ops,
+					    &sd_cfg);
 	if (IS_ERR(light->v4l2_flash))
 		return PTR_ERR(light->v4l2_flash);
 
+	if (channel_ind) {
+		light->v4l2_flash_ind =
+			v4l2_flash_indicator_init(dev, NULL, iled, &sd_cfg_ind);
+		if (IS_ERR(light->v4l2_flash_ind)) {
+			v4l2_flash_release(light->v4l2_flash);
+			return PTR_ERR(light->v4l2_flash_ind);
+		}
+	}
+
 	return 0;
 }
 
 static void gb_lights_light_v4l2_unregister(struct gb_light *light)
 {
+	v4l2_flash_release(light->v4l2_flash_ind);
 	v4l2_flash_release(light->v4l2_flash);
 }
 #else

commit 428359cbfe086f43cb84b7ab7b48e7e7862700e2
Author: Rui Miguel Silva <rmfrfs@gmail.com>
Date:   Wed Aug 2 12:52:57 2017 -0400

    media: staging: greybus: light: fix memory leak in v4l2 register
    
    We are allocating memory for the v4l2 flash configuration structure and
    leak it in the normal path. Just use the stack for this as we do not
    use it outside of this function.
    
    Also use IS_ERR() instead of IS_ERR_OR_NULL() to check return value from
    v4l2_flash_init() for it never returns NULL.
    
    Fixes: 2870b52bae4c ("greybus: lights: add lights implementation")
    
    Reported-by: Sakari Ailus <sakari.ailus@linux.intel.com>
    Signed-off-by: Rui Miguel Silva <rmfrfs@gmail.com>
    Reviewed-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Sakari Ailus <sakari.ailus@linux.intel.com>
    Acked-by: Hans Verkuil <hans.verkuil@cisco.com>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/staging/greybus/light.c b/drivers/staging/greybus/light.c
index 129ceed39829..81469d087e74 100644
--- a/drivers/staging/greybus/light.c
+++ b/drivers/staging/greybus/light.c
@@ -534,25 +534,20 @@ static int gb_lights_light_v4l2_register(struct gb_light *light)
 {
 	struct gb_connection *connection = get_conn_from_light(light);
 	struct device *dev = &connection->bundle->dev;
-	struct v4l2_flash_config *sd_cfg;
+	struct v4l2_flash_config sd_cfg = { {0} };
 	struct led_classdev_flash *fled;
 	struct led_classdev *iled = NULL;
 	struct gb_channel *channel_torch, *channel_ind, *channel_flash;
-	int ret = 0;
-
-	sd_cfg = kcalloc(1, sizeof(*sd_cfg), GFP_KERNEL);
-	if (!sd_cfg)
-		return -ENOMEM;
 
 	channel_torch = get_channel_from_mode(light, GB_CHANNEL_MODE_TORCH);
 	if (channel_torch)
 		__gb_lights_channel_v4l2_config(&channel_torch->intensity_uA,
-						&sd_cfg->torch_intensity);
+						&sd_cfg.torch_intensity);
 
 	channel_ind = get_channel_from_mode(light, GB_CHANNEL_MODE_INDICATOR);
 	if (channel_ind) {
 		__gb_lights_channel_v4l2_config(&channel_ind->intensity_uA,
-						&sd_cfg->indicator_intensity);
+						&sd_cfg.indicator_intensity);
 		iled = &channel_ind->fled.led_cdev;
 	}
 
@@ -561,27 +556,21 @@ static int gb_lights_light_v4l2_register(struct gb_light *light)
 
 	fled = &channel_flash->fled;
 
-	snprintf(sd_cfg->dev_name, sizeof(sd_cfg->dev_name), "%s", light->name);
+	snprintf(sd_cfg.dev_name, sizeof(sd_cfg.dev_name), "%s", light->name);
 
 	/* Set the possible values to faults, in our case all faults */
-	sd_cfg->flash_faults = LED_FAULT_OVER_VOLTAGE | LED_FAULT_TIMEOUT |
+	sd_cfg.flash_faults = LED_FAULT_OVER_VOLTAGE | LED_FAULT_TIMEOUT |
 		LED_FAULT_OVER_TEMPERATURE | LED_FAULT_SHORT_CIRCUIT |
 		LED_FAULT_OVER_CURRENT | LED_FAULT_INDICATOR |
 		LED_FAULT_UNDER_VOLTAGE | LED_FAULT_INPUT_VOLTAGE |
 		LED_FAULT_LED_OVER_TEMPERATURE;
 
 	light->v4l2_flash = v4l2_flash_init(dev, NULL, fled, iled,
-					    &v4l2_flash_ops, sd_cfg);
-	if (IS_ERR_OR_NULL(light->v4l2_flash)) {
-		ret = PTR_ERR(light->v4l2_flash);
-		goto out_free;
-	}
+					    &v4l2_flash_ops, &sd_cfg);
+	if (IS_ERR(light->v4l2_flash))
+		return PTR_ERR(light->v4l2_flash);
 
-	return ret;
-
-out_free:
-	kfree(sd_cfg);
-	return ret;
+	return 0;
 }
 
 static void gb_lights_light_v4l2_unregister(struct gb_light *light)

commit 85f7ff9702bcc5e899bd0bf6b6e383ecb2ac436a
Author: Sakari Ailus <sakari.ailus@linux.intel.com>
Date:   Fri Jun 2 05:30:02 2017 -0400

    media: v4l2-flash: Use led_classdev instead of led_classdev_flash for indicator
    
    The V4L2 flash class initialisation expects struct led_classdev_flash that
    describes an indicator but only uses struct led_classdev which is a field
    iled_cdev in the struct. Use struct iled_cdev only.
    
    Signed-off-by: Sakari Ailus <sakari.ailus@linux.intel.com>
    Reviewed-by: Jacek Anaszewski <jacek.anaszewski@gmail.com>
    Reviewed-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/staging/greybus/light.c b/drivers/staging/greybus/light.c
index 861a249e6ef1..129ceed39829 100644
--- a/drivers/staging/greybus/light.c
+++ b/drivers/staging/greybus/light.c
@@ -536,7 +536,7 @@ static int gb_lights_light_v4l2_register(struct gb_light *light)
 	struct device *dev = &connection->bundle->dev;
 	struct v4l2_flash_config *sd_cfg;
 	struct led_classdev_flash *fled;
-	struct led_classdev_flash *iled = NULL;
+	struct led_classdev *iled = NULL;
 	struct gb_channel *channel_torch, *channel_ind, *channel_flash;
 	int ret = 0;
 
@@ -553,7 +553,7 @@ static int gb_lights_light_v4l2_register(struct gb_light *light)
 	if (channel_ind) {
 		__gb_lights_channel_v4l2_config(&channel_ind->intensity_uA,
 						&sd_cfg->indicator_intensity);
-		iled = &channel_ind->fled;
+		iled = &channel_ind->fled.led_cdev;
 	}
 
 	channel_flash = get_channel_from_mode(light, GB_CHANNEL_MODE_FLASH);

commit 3036d0e226b04f10fbce1fd5263c735e4c1d9ffa
Author: Karthik Tummala <karthik@techveda.org>
Date:   Mon May 8 18:05:55 2017 +0530

    Staging: greybus: light: Prefer kcalloc over kzalloc
    
    Fixed following checkpatch.pl warning:
     * WARNING: Prefer kcalloc over kzalloc with multiply
    
    Instead of specifying no.of bytes * size as argument
    in kzalloc, prefer kcalloc.
    
    Signed-off-by: Karthik Tummala <karthik@techveda.org>
    Reviewed-by: Rui Miguel Silva <rmfrfs@gmail.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    
    Changes for v2:
    - Changed subject line & fixed typo as suggested by
      Rui Miguel Silva
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/light.c b/drivers/staging/greybus/light.c
index 16813628eda1..861a249e6ef1 100644
--- a/drivers/staging/greybus/light.c
+++ b/drivers/staging/greybus/light.c
@@ -1030,7 +1030,7 @@ static int gb_lights_light_config(struct gb_lights *glights, u8 id)
 	light->channels_count = conf.channel_count;
 	light->name = kstrndup(conf.name, NAMES_MAX, GFP_KERNEL);
 
-	light->channels = kzalloc(light->channels_count *
+	light->channels = kcalloc(light->channels_count,
 				  sizeof(struct gb_channel), GFP_KERNEL);
 	if (!light->channels)
 		return -ENOMEM;
@@ -1167,7 +1167,7 @@ static int gb_lights_create_all(struct gb_lights *glights)
 	if (ret < 0)
 		goto out;
 
-	glights->lights = kzalloc(glights->lights_count *
+	glights->lights = kcalloc(glights->lights_count,
 				  sizeof(struct gb_light), GFP_KERNEL);
 	if (!glights->lights) {
 		ret = -ENOMEM;

commit 6163904e0102f6bf06077893e3930aa08f6e62f5
Author: Darryl T. Agostinelli <dagostinelli@gmail.com>
Date:   Wed Apr 12 20:36:14 2017 -0500

    staging: greybus: light.c: Remove include linux/version.h
    
    Fixes:
    $ make versioncheck | grep staging
    ./drivers/staging/greybus/light.c: 15 linux/version.h not needed.
    
    Signed-off-by: Darryl T. Agostinelli <dagostinelli@gmail.com>
    Reviewed-by: Rui Miguel Silva <rmfrfs@gmail.com>
    Reviewed-by: Alex Elder <elder@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/light.c b/drivers/staging/greybus/light.c
index 8dffd8a7e762..16813628eda1 100644
--- a/drivers/staging/greybus/light.c
+++ b/drivers/staging/greybus/light.c
@@ -12,7 +12,6 @@
 #include <linux/led-class-flash.h>
 #include <linux/module.h>
 #include <linux/slab.h>
-#include <linux/version.h>
 #include <media/v4l2-flash-led-class.h>
 
 #include "greybus.h"

commit 5cf62679153ed7014d6952bb6a5094b3ee31428d
Author: Rui Miguel Silva <rmfrfs@gmail.com>
Date:   Fri Sep 30 18:26:55 2016 +0100

    staging: greybus: light: check the correct value of delay_on
    
    When checking the value of delay_on to set the channel as active, it was
    checked the pointer and not the value, as it should be.
    
    Fixes: cc43368a3c ("greybus: lights: Control runtime pm suspend/resume on AP side")
    
    Signed-off-by: Rui Miguel Silva <rmfrfs@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/light.c b/drivers/staging/greybus/light.c
index 80dc4a9d9a0e..8dffd8a7e762 100644
--- a/drivers/staging/greybus/light.c
+++ b/drivers/staging/greybus/light.c
@@ -483,7 +483,7 @@ static int gb_blink_set(struct led_classdev *cdev, unsigned long *delay_on,
 	if (ret < 0)
 		goto out_pm_put;
 
-	if (delay_on)
+	if (*delay_on)
 		channel->active = true;
 	else
 		channel->active = false;

commit dc875c77900dba5d177f9219492fd60c046feec8
Author: Rui Miguel Silva <rmfrfs@gmail.com>
Date:   Fri Sep 30 19:24:33 2016 +0100

    staging: greybus: light: check delay_{on|off} before use
    
    Even though we trust leds core that the pointers should be valid, we are
    safer to check delay_{on|off} before use.
    
    Also, this avoid a smatch warning:
    drivers/staging/greybus/light.c:484 gb_blink_set()
    warn: variable dereferenced before check 'delay_on' (see line 476)
    
    Signed-off-by: Rui Miguel Silva <rmfrfs@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/light.c b/drivers/staging/greybus/light.c
index f3cd48521af0..80dc4a9d9a0e 100644
--- a/drivers/staging/greybus/light.c
+++ b/drivers/staging/greybus/light.c
@@ -463,6 +463,9 @@ static int gb_blink_set(struct led_classdev *cdev, unsigned long *delay_on,
 	if (channel->releasing)
 		return -ESHUTDOWN;
 
+	if (!delay_on || !delay_off)
+		return -EINVAL;
+
 	mutex_lock(&channel->lock);
 	ret = gb_pm_runtime_get_sync(bundle);
 	if (ret < 0)

commit 3855eeec1a47cace93acd5ff89fb3c9bd593d307
Author: Rui Miguel Silva <rmfrfs@gmail.com>
Date:   Fri Sep 30 19:24:32 2016 +0100

    staging: greybus: light: fix attributes allocation
    
    Fix allocation of attributes with the correct size, this also fix smatch
    warning:
    
    drivers/staging/greybus/light.c:293 channel_attr_groups_set()
    warn: double check that we're allocating correct size: 8 vs 16
    
    Signed-off-by: Rui Miguel Silva <rmfrfs@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/light.c b/drivers/staging/greybus/light.c
index b2847feb7e86..f3cd48521af0 100644
--- a/drivers/staging/greybus/light.c
+++ b/drivers/staging/greybus/light.c
@@ -290,8 +290,7 @@ static int channel_attr_groups_set(struct gb_channel *channel,
 		return 0;
 
 	/* Set attributes based in the channel flags */
-	channel->attrs = kcalloc(size + 1, sizeof(**channel->attrs),
-				 GFP_KERNEL);
+	channel->attrs = kcalloc(size + 1, sizeof(*channel->attrs), GFP_KERNEL);
 	if (!channel->attrs)
 		return -ENOMEM;
 	channel->attr_group = kcalloc(1, sizeof(*channel->attr_group),

commit a7af2fe6d1baa45e73531fb994444fa0f59d8f62
Author: Rui Miguel Silva <rui.silva@linaro.org>
Date:   Thu Sep 8 17:17:48 2016 +0100

    staging: greybus: light: remove KERNEL_VERSION checks
    
    No need to support older kernel versions in the Greybus Light driver, so
    remove the checks as needed, we can now rely on all of the correct LED
    core apis being present. And compile only if flash and v4l2 flash is
    reachable.
    
    Signed-off-by: Rui Miguel Silva <rui.silva@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/light.c b/drivers/staging/greybus/light.c
index 71db077765f7..b2847feb7e86 100644
--- a/drivers/staging/greybus/light.c
+++ b/drivers/staging/greybus/light.c
@@ -9,9 +9,11 @@
 
 #include <linux/kernel.h>
 #include <linux/leds.h>
+#include <linux/led-class-flash.h>
 #include <linux/module.h>
 #include <linux/slab.h>
 #include <linux/version.h>
+#include <media/v4l2-flash-led-class.h>
 
 #include "greybus.h"
 #include "greybus_protocols.h"
@@ -30,11 +32,8 @@ struct gb_channel {
 	struct attribute		**attrs;
 	struct attribute_group		*attr_group;
 	const struct attribute_group	**attr_groups;
-#ifndef LED_HAVE_SET_BLOCKING
-	struct work_struct		work_brightness_set;
-#endif
 	struct led_classdev		*led;
-#ifdef LED_HAVE_FLASH
+#if IS_REACHABLE(CONFIG_LEDS_CLASS_FLASH)
 	struct led_classdev_flash	fled;
 	struct led_flash_setting	intensity_uA;
 	struct led_flash_setting	timeout_us;
@@ -58,7 +57,7 @@ struct gb_light {
 	struct gb_channel	*channels;
 	bool			has_flash;
 	bool			ready;
-#ifdef V4L2_HAVE_FLASH
+#if IS_REACHABLE(CONFIG_V4L2_FLASH_LED_CLASS)
 	struct v4l2_flash	*v4l2_flash;
 #endif
 };
@@ -88,7 +87,7 @@ static bool is_channel_flash(struct gb_channel *channel)
 				   | GB_CHANNEL_MODE_INDICATOR));
 }
 
-#ifdef LED_HAVE_FLASH
+#if IS_REACHABLE(CONFIG_LEDS_CLASS_FLASH)
 static struct gb_channel *get_channel_from_cdev(struct led_classdev *cdev)
 {
 	struct led_classdev_flash *fled_cdev = lcdev_to_flcdev(cdev);
@@ -157,7 +156,7 @@ static int __gb_lights_flash_brightness_set(struct gb_channel *channel)
 
 	return __gb_lights_flash_intensity_set(channel, intensity);
 }
-#else /* LED_HAVE_FLASH */
+#else
 static struct gb_channel *get_channel_from_cdev(struct led_classdev *cdev)
 {
 	return container_of(cdev, struct gb_channel, cled);
@@ -172,12 +171,11 @@ static int __gb_lights_flash_brightness_set(struct gb_channel *channel)
 {
 	return 0;
 }
-#endif /* !LED_HAVE_FLASH */
+#endif
 
 static int gb_lights_color_set(struct gb_channel *channel, u32 color);
 static int gb_lights_fade_set(struct gb_channel *channel);
 
-#ifdef LED_HAVE_LOCK
 static void led_lock(struct led_classdev *cdev)
 {
 	mutex_lock(&cdev->led_access);
@@ -187,15 +185,6 @@ static void led_unlock(struct led_classdev *cdev)
 {
 	mutex_unlock(&cdev->led_access);
 }
-#else
-static void led_lock(struct led_classdev *cdev)
-{
-}
-
-static void led_unlock(struct led_classdev *cdev)
-{
-}
-#endif /* !LED_HAVE_LOCK */
 
 #define gb_lights_fade_attr(__dir)					\
 static ssize_t fade_##__dir##_show(struct device *dev,			\
@@ -444,39 +433,6 @@ static int __gb_lights_brightness_set(struct gb_channel *channel)
 	return ret;
 }
 
-#ifndef LED_HAVE_SET_BLOCKING
-static void gb_brightness_set_work(struct work_struct *work)
-{
-	struct gb_channel *channel = container_of(work, struct gb_channel,
-						  work_brightness_set);
-
-	__gb_lights_brightness_set(channel);
-}
-
-#ifdef LED_HAVE_SET_SYNC
-static int gb_brightness_set_sync(struct led_classdev *cdev,
-				  enum led_brightness value)
-{
-	struct gb_channel *channel = get_channel_from_cdev(cdev);
-
-	channel->led->brightness = value;
-
-	return __gb_lights_brightness_set(channel);
-}
-#endif
-
-static void gb_brightness_set(struct led_classdev *cdev,
-			      enum led_brightness value)
-{
-	struct gb_channel *channel = get_channel_from_cdev(cdev);
-
-	if (channel->releasing)
-		return;
-
-	cdev->brightness = value;
-	schedule_work(&channel->work_brightness_set);
-}
-#else /* LED_HAVE_SET_BLOCKING */
 static int gb_brightness_set(struct led_classdev *cdev,
 			     enum led_brightness value)
 {
@@ -486,7 +442,6 @@ static int gb_brightness_set(struct led_classdev *cdev,
 
 	return __gb_lights_brightness_set(channel);
 }
-#endif
 
 static enum led_brightness gb_brightness_get(struct led_classdev *cdev)
 
@@ -554,22 +509,13 @@ static void gb_lights_led_operations_set(struct gb_channel *channel,
 					 struct led_classdev *cdev)
 {
 	cdev->brightness_get = gb_brightness_get;
-#ifdef LED_HAVE_SET_SYNC
-	cdev->brightness_set_sync = gb_brightness_set_sync;
-#endif
-#ifdef LED_HAVE_SET_BLOCKING
 	cdev->brightness_set_blocking = gb_brightness_set;
-#endif
-#ifndef LED_HAVE_SET_BLOCKING
-	cdev->brightness_set = gb_brightness_set;
-	INIT_WORK(&channel->work_brightness_set, gb_brightness_set_work);
-#endif
 
 	if (channel->flags & GB_LIGHT_CHANNEL_BLINK)
 		cdev->blink_set = gb_blink_set;
 }
 
-#ifdef V4L2_HAVE_FLASH
+#if IS_REACHABLE(CONFIG_V4L2_FLASH_LED_CLASS)
 /* V4L2 specific helpers */
 static const struct v4l2_flash_ops v4l2_flash_ops;
 
@@ -655,7 +601,7 @@ static void gb_lights_light_v4l2_unregister(struct gb_light *light)
 }
 #endif
 
-#ifdef LED_HAVE_FLASH
+#if IS_REACHABLE(CONFIG_LEDS_CLASS_FLASH)
 /* Flash specific operations */
 static int gb_lights_flash_intensity_set(struct led_classdev_flash *fcdev,
 					 u32 brightness)
@@ -936,7 +882,7 @@ static void __gb_lights_flash_led_unregister(struct gb_channel *channel)
 {
 }
 
-#endif /* LED_HAVE_FLASH */
+#endif
 
 static int __gb_lights_led_register(struct gb_channel *channel)
 {
@@ -1132,9 +1078,6 @@ static int gb_lights_light_register(struct gb_light *light)
 
 static void gb_lights_channel_free(struct gb_channel *channel)
 {
-#ifndef LED_HAVE_SET_BLOCKING
-	flush_work(&channel->work_brightness_set);
-#endif
 	kfree(channel->attrs);
 	kfree(channel->attr_group);
 	kfree(channel->attr_groups);

commit cc43368a3cde151739ad20cbf71139530bd53f1a
Author: Kris Huang <huang_kris@projectara.com>
Date:   Thu Aug 25 16:57:14 2016 +0800

    greybus: lights: Control runtime pm suspend/resume on AP side
    
    According to runtime pm architecture, the kernel side driver should be
    as smart as needed to know when the module is idle or active, so that it can
    issue the suspend/resume operations to the firmware side at the right time.
    To add logics prevents AP from issuing the suspend request to the firmware
    when a channel turning to active state, and put it to suspend if the state
    is going to inactive with still holding a reference.
    
    Testing Done: Compiled and verified on EVT2 and gpbridge-test module
                  with device class daughter board.
    
    Signed-off-by: Kris Huang <huang_kris@projectara.com>
    Reviewed-by: Rui Miguel Silva <rui.silva@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/light.c b/drivers/staging/greybus/light.c
index 85bf5559f6fb..71db077765f7 100644
--- a/drivers/staging/greybus/light.c
+++ b/drivers/staging/greybus/light.c
@@ -45,6 +45,8 @@ struct gb_channel {
 	bool				is_registered;
 	bool				releasing;
 	bool				strobe_state;
+	bool				active;
+	struct mutex			lock;
 };
 
 struct gb_light {
@@ -384,11 +386,15 @@ static int __gb_lights_led_brightness_set(struct gb_channel *channel)
 	struct gb_lights_set_brightness_request req;
 	struct gb_connection *connection = get_conn_from_channel(channel);
 	struct gb_bundle *bundle = connection->bundle;
+	bool old_active;
 	int ret;
 
+	mutex_lock(&channel->lock);
 	ret = gb_pm_runtime_get_sync(bundle);
 	if (ret < 0)
-		return ret;
+		goto out_unlock;
+
+	old_active = channel->active;
 
 	req.light_id = channel->light->id;
 	req.channel_id = channel->id;
@@ -396,8 +402,29 @@ static int __gb_lights_led_brightness_set(struct gb_channel *channel)
 
 	ret = gb_operation_sync(connection, GB_LIGHTS_TYPE_SET_BRIGHTNESS,
 				&req, sizeof(req), NULL, 0);
+	if (ret < 0)
+		goto out_pm_put;
+
+	if (channel->led->brightness)
+		channel->active = true;
+	else
+		channel->active = false;
 
+	/* we need to keep module alive when turning to active state */
+	if (!old_active && channel->active)
+		goto out_unlock;
+
+	/*
+	 * on the other hand if going to inactive we still hold a reference and
+	 * need to put it, so we could go to suspend.
+	 */
+	if (old_active && !channel->active)
+		gb_pm_runtime_put_autosuspend(bundle);
+
+out_pm_put:
 	gb_pm_runtime_put_autosuspend(bundle);
+out_unlock:
+	mutex_unlock(&channel->lock);
 
 	return ret;
 }
@@ -476,14 +503,18 @@ static int gb_blink_set(struct led_classdev *cdev, unsigned long *delay_on,
 	struct gb_connection *connection = get_conn_from_channel(channel);
 	struct gb_bundle *bundle = connection->bundle;
 	struct gb_lights_blink_request req;
+	bool old_active;
 	int ret;
 
 	if (channel->releasing)
 		return -ESHUTDOWN;
 
+	mutex_lock(&channel->lock);
 	ret = gb_pm_runtime_get_sync(bundle);
 	if (ret < 0)
-		return ret;
+		goto out_unlock;
+
+	old_active = channel->active;
 
 	req.light_id = channel->light->id;
 	req.channel_id = channel->id;
@@ -492,8 +523,29 @@ static int gb_blink_set(struct led_classdev *cdev, unsigned long *delay_on,
 
 	ret = gb_operation_sync(connection, GB_LIGHTS_TYPE_SET_BLINK, &req,
 				sizeof(req), NULL, 0);
+	if (ret < 0)
+		goto out_pm_put;
+
+	if (delay_on)
+		channel->active = true;
+	else
+		channel->active = false;
+
+	/* we need to keep module alive when turning to active state */
+	if (!old_active && channel->active)
+		goto out_unlock;
 
+	/*
+	 * on the other hand if going to inactive we still hold a reference and
+	 * need to put it, so we could go to suspend.
+	 */
+	if (old_active && !channel->active)
+		gb_pm_runtime_put_autosuspend(bundle);
+
+out_pm_put:
 	gb_pm_runtime_put_autosuspend(bundle);
+out_unlock:
+	mutex_unlock(&channel->lock);
 
 	return ret;
 }
@@ -1061,6 +1113,8 @@ static int gb_lights_light_register(struct gb_light *light)
 		ret = gb_lights_channel_register(&light->channels[i]);
 		if (ret < 0)
 			return ret;
+
+		mutex_init(&light->channels[i].lock);
 	}
 
 	light->ready = true;
@@ -1086,6 +1140,7 @@ static void gb_lights_channel_free(struct gb_channel *channel)
 	kfree(channel->attr_groups);
 	kfree(channel->color_name);
 	kfree(channel->mode_name);
+	mutex_destroy(&channel->lock);
 }
 
 static void gb_lights_channel_release(struct gb_channel *channel)

commit 0e352343c2e371ad618d8850f542e9ca230e3aa6
Author: David Lin <dtwlin@google.com>
Date:   Mon Aug 22 15:51:11 2016 -0700

    greybus: light: fix incorrect led attribute files allocation
    
    Fix incorrect attribute size when the channel supports fader, as well as
    fixing the issue that the attribute list is not null terminated.
    
    Testing Done:
     - Verified by setting brightness and color on red/green/blue leds
       of the device class test board.
    
    Signed-off-by: David Lin <dtwlin@google.com>
    Reviewed-by: Rui Miguel Silva <rui.silva@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/light.c b/drivers/staging/greybus/light.c
index a57d59339bd6..85bf5559f6fb 100644
--- a/drivers/staging/greybus/light.c
+++ b/drivers/staging/greybus/light.c
@@ -293,13 +293,14 @@ static int channel_attr_groups_set(struct gb_channel *channel,
 	if (channel->flags & GB_LIGHT_CHANNEL_MULTICOLOR)
 		size++;
 	if (channel->flags & GB_LIGHT_CHANNEL_FADER)
-		size++;
+		size += 2;
 
 	if (!size)
 		return 0;
 
 	/* Set attributes based in the channel flags */
-	channel->attrs = kcalloc(size, sizeof(**channel->attrs), GFP_KERNEL);
+	channel->attrs = kcalloc(size + 1, sizeof(**channel->attrs),
+				 GFP_KERNEL);
 	if (!channel->attrs)
 		return -ENOMEM;
 	channel->attr_group = kcalloc(1, sizeof(*channel->attr_group),

commit 811b1f58610d219610c223a1d63031171a079a7c
Author: Kris Huang <huang_kris@projectara.com>
Date:   Tue Aug 9 11:28:37 2016 +0800

    greybus: lights: enable multi color LED support
    
    A backport (commit 79c4de08c0e5a26b04a4ac9e6543dad6379f0b40) was
    applied in kernel which adding attribute-group support in led-class.
    Remove the LED_HAVE_GROUPS flag check entirely that allow led
    drivers to create custom attributes like color/fade_in/fade_out.
    
    Testing Done: Compiled and verified on EVT2 and gpbridge-test module
                  with device class daughter board.
    
    Signed-off-by: Kris Huang <huang_kris@projectara.com>
    Reviewed-by: Rui Miguel Silva <rui.silva@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/light.c b/drivers/staging/greybus/light.c
index fb41b0b1a98c..a57d59339bd6 100644
--- a/drivers/staging/greybus/light.c
+++ b/drivers/staging/greybus/light.c
@@ -172,7 +172,6 @@ static int __gb_lights_flash_brightness_set(struct gb_channel *channel)
 }
 #endif /* !LED_HAVE_FLASH */
 
-#ifdef LED_HAVE_GROUPS
 static int gb_lights_color_set(struct gb_channel *channel, u32 color);
 static int gb_lights_fade_set(struct gb_channel *channel);
 
@@ -378,13 +377,6 @@ static int gb_lights_color_set(struct gb_channel *channel, u32 color)
 
 	return ret;
 }
-#else /* LED_HAVE_GROUPS */
-static int channel_attr_groups_set(struct gb_channel *channel,
-				   struct led_classdev *cdev)
-{
-	return 0;
-}
-#endif /* !LED_HAVE_GROUPS */
 
 static int __gb_lights_led_brightness_set(struct gb_channel *channel)
 {

commit 9141ad8773f4f6ebb8cd9fa376d9497fa7e73374
Author: Kris Huang <huang_kris@projectara.com>
Date:   Fri Aug 5 12:59:08 2016 +0800

    greybus: lights: Add runtime pm support
    
    Modify Lights greybus driver to support runtime PM framework.
    The suspend and resume function have been tested with gpbridge-test
    image by sysfs. Lights functions work well on suspend/resume.
    
    Testing Done: Compiled and verified on EVT2 and gpbridge-test module
                  with device class daughter board.
    
    Signed-off-by: Kris Huang <huang_kris@projectara.com>
    Reviewed-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/light.c b/drivers/staging/greybus/light.c
index 3d42a5dafee9..fb41b0b1a98c 100644
--- a/drivers/staging/greybus/light.c
+++ b/drivers/staging/greybus/light.c
@@ -117,17 +117,27 @@ static int __gb_lights_flash_intensity_set(struct gb_channel *channel,
 					   u32 intensity)
 {
 	struct gb_connection *connection = get_conn_from_channel(channel);
+	struct gb_bundle *bundle = connection->bundle;
 	struct gb_lights_set_flash_intensity_request req;
+	int ret;
 
 	if (channel->releasing)
 		return -ESHUTDOWN;
 
+	ret = gb_pm_runtime_get_sync(bundle);
+	if (ret < 0)
+		return ret;
+
 	req.light_id = channel->light->id;
 	req.channel_id = channel->id;
 	req.intensity_uA = cpu_to_le32(intensity);
 
-	return gb_operation_sync(connection, GB_LIGHTS_TYPE_SET_FLASH_INTENSITY,
-				 &req, sizeof(req), NULL, 0);
+	ret = gb_operation_sync(connection, GB_LIGHTS_TYPE_SET_FLASH_INTENSITY,
+				&req, sizeof(req), NULL, 0);
+
+	gb_pm_runtime_put_autosuspend(bundle);
+
+	return ret;
 }
 
 static int __gb_lights_flash_brightness_set(struct gb_channel *channel)
@@ -321,32 +331,52 @@ static int channel_attr_groups_set(struct gb_channel *channel,
 static int gb_lights_fade_set(struct gb_channel *channel)
 {
 	struct gb_connection *connection = get_conn_from_channel(channel);
+	struct gb_bundle *bundle = connection->bundle;
 	struct gb_lights_set_fade_request req;
+	int ret;
 
 	if (channel->releasing)
 		return -ESHUTDOWN;
 
+	ret = gb_pm_runtime_get_sync(bundle);
+	if (ret < 0)
+		return ret;
+
 	req.light_id = channel->light->id;
 	req.channel_id = channel->id;
 	req.fade_in = channel->fade_in;
 	req.fade_out = channel->fade_out;
-	return gb_operation_sync(connection, GB_LIGHTS_TYPE_SET_FADE,
-				 &req, sizeof(req), NULL, 0);
+	ret = gb_operation_sync(connection, GB_LIGHTS_TYPE_SET_FADE,
+				&req, sizeof(req), NULL, 0);
+
+	gb_pm_runtime_put_autosuspend(bundle);
+
+	return ret;
 }
 
 static int gb_lights_color_set(struct gb_channel *channel, u32 color)
 {
 	struct gb_connection *connection = get_conn_from_channel(channel);
+	struct gb_bundle *bundle = connection->bundle;
 	struct gb_lights_set_color_request req;
+	int ret;
 
 	if (channel->releasing)
 		return -ESHUTDOWN;
 
+	ret = gb_pm_runtime_get_sync(bundle);
+	if (ret < 0)
+		return ret;
+
 	req.light_id = channel->light->id;
 	req.channel_id = channel->id;
 	req.color = cpu_to_le32(color);
-	return gb_operation_sync(connection, GB_LIGHTS_TYPE_SET_COLOR,
-				 &req, sizeof(req), NULL, 0);
+	ret = gb_operation_sync(connection, GB_LIGHTS_TYPE_SET_COLOR,
+				&req, sizeof(req), NULL, 0);
+
+	gb_pm_runtime_put_autosuspend(bundle);
+
+	return ret;
 }
 #else /* LED_HAVE_GROUPS */
 static int channel_attr_groups_set(struct gb_channel *channel,
@@ -360,13 +390,23 @@ static int __gb_lights_led_brightness_set(struct gb_channel *channel)
 {
 	struct gb_lights_set_brightness_request req;
 	struct gb_connection *connection = get_conn_from_channel(channel);
+	struct gb_bundle *bundle = connection->bundle;
+	int ret;
+
+	ret = gb_pm_runtime_get_sync(bundle);
+	if (ret < 0)
+		return ret;
 
 	req.light_id = channel->light->id;
 	req.channel_id = channel->id;
 	req.brightness = (u8)channel->led->brightness;
 
-	return gb_operation_sync(connection, GB_LIGHTS_TYPE_SET_BRIGHTNESS,
-				 &req, sizeof(req), NULL, 0);
+	ret = gb_operation_sync(connection, GB_LIGHTS_TYPE_SET_BRIGHTNESS,
+				&req, sizeof(req), NULL, 0);
+
+	gb_pm_runtime_put_autosuspend(bundle);
+
+	return ret;
 }
 
 static int __gb_lights_brightness_set(struct gb_channel *channel)
@@ -441,18 +481,28 @@ static int gb_blink_set(struct led_classdev *cdev, unsigned long *delay_on,
 {
 	struct gb_channel *channel = get_channel_from_cdev(cdev);
 	struct gb_connection *connection = get_conn_from_channel(channel);
+	struct gb_bundle *bundle = connection->bundle;
 	struct gb_lights_blink_request req;
+	int ret;
 
 	if (channel->releasing)
 		return -ESHUTDOWN;
 
+	ret = gb_pm_runtime_get_sync(bundle);
+	if (ret < 0)
+		return ret;
+
 	req.light_id = channel->light->id;
 	req.channel_id = channel->id;
 	req.time_on_ms = cpu_to_le16(*delay_on);
 	req.time_off_ms = cpu_to_le16(*delay_off);
 
-	return gb_operation_sync(connection, GB_LIGHTS_TYPE_SET_BLINK, &req,
-				 sizeof(req), NULL, 0);
+	ret = gb_operation_sync(connection, GB_LIGHTS_TYPE_SET_BLINK, &req,
+				sizeof(req), NULL, 0);
+
+	gb_pm_runtime_put_autosuspend(bundle);
+
+	return ret;
 }
 
 static void gb_lights_led_operations_set(struct gb_channel *channel,
@@ -592,23 +642,29 @@ static int gb_lights_flash_strobe_set(struct led_classdev_flash *fcdev,
 	struct gb_channel *channel = container_of(fcdev, struct gb_channel,
 						  fled);
 	struct gb_connection *connection = get_conn_from_channel(channel);
+	struct gb_bundle *bundle = connection->bundle;
 	struct gb_lights_set_flash_strobe_request req;
 	int ret;
 
 	if (channel->releasing)
 		return -ESHUTDOWN;
 
+	ret = gb_pm_runtime_get_sync(bundle);
+	if (ret < 0)
+		return ret;
+
 	req.light_id = channel->light->id;
 	req.channel_id = channel->id;
 	req.state = state ? 1 : 0;
 
 	ret = gb_operation_sync(connection, GB_LIGHTS_TYPE_SET_FLASH_STROBE,
 				&req, sizeof(req), NULL, 0);
-	if (ret < 0)
-		return ret;
-	channel->strobe_state = state;
+	if (!ret)
+		channel->strobe_state = state;
 
-	return 0;
+	gb_pm_runtime_put_autosuspend(bundle);
+
+	return ret;
 }
 
 static int gb_lights_flash_strobe_get(struct led_classdev_flash *fcdev,
@@ -627,23 +683,29 @@ static int gb_lights_flash_timeout_set(struct led_classdev_flash *fcdev,
 	struct gb_channel *channel = container_of(fcdev, struct gb_channel,
 						  fled);
 	struct gb_connection *connection = get_conn_from_channel(channel);
+	struct gb_bundle *bundle = connection->bundle;
 	struct gb_lights_set_flash_timeout_request req;
 	int ret;
 
 	if (channel->releasing)
 		return -ESHUTDOWN;
 
+	ret = gb_pm_runtime_get_sync(bundle);
+	if (ret < 0)
+		return ret;
+
 	req.light_id = channel->light->id;
 	req.channel_id = channel->id;
 	req.timeout_us = cpu_to_le32(timeout);
 
 	ret = gb_operation_sync(connection, GB_LIGHTS_TYPE_SET_FLASH_TIMEOUT,
 				&req, sizeof(req), NULL, 0);
-	if (ret < 0)
-		return ret;
-	fcdev->timeout.val = timeout;
+	if (!ret)
+		fcdev->timeout.val = timeout;
 
-	return 0;
+	gb_pm_runtime_put_autosuspend(bundle);
+
+	return ret;
 }
 
 static int gb_lights_flash_fault_get(struct led_classdev_flash *fcdev,
@@ -652,6 +714,7 @@ static int gb_lights_flash_fault_get(struct led_classdev_flash *fcdev,
 	struct gb_channel *channel = container_of(fcdev, struct gb_channel,
 						  fled);
 	struct gb_connection *connection = get_conn_from_channel(channel);
+	struct gb_bundle *bundle = connection->bundle;
 	struct gb_lights_get_flash_fault_request req;
 	struct gb_lights_get_flash_fault_response resp;
 	int ret;
@@ -659,17 +722,21 @@ static int gb_lights_flash_fault_get(struct led_classdev_flash *fcdev,
 	if (channel->releasing)
 		return -ESHUTDOWN;
 
+	ret = gb_pm_runtime_get_sync(bundle);
+	if (ret < 0)
+		return ret;
+
 	req.light_id = channel->light->id;
 	req.channel_id = channel->id;
 
 	ret = gb_operation_sync(connection, GB_LIGHTS_TYPE_GET_FLASH_FAULT,
 				&req, sizeof(req), &resp, sizeof(resp));
-	if (ret < 0)
-		return ret;
+	if (!ret)
+		*fault = le32_to_cpu(resp.fault);
 
-	*fault = le32_to_cpu(resp.fault);
+	gb_pm_runtime_put_autosuspend(bundle);
 
-	return 0;
+	return ret;
 }
 
 static const struct led_flash_ops gb_lights_flash_ops = {
@@ -1258,6 +1325,8 @@ static int gb_lights_probe(struct gb_bundle *bundle,
 	if (ret < 0)
 		goto error_connection_disable;
 
+	gb_pm_runtime_put_autosuspend(bundle);
+
 	return 0;
 
 error_connection_disable:
@@ -1273,6 +1342,9 @@ static void gb_lights_disconnect(struct gb_bundle *bundle)
 {
 	struct gb_lights *glights = greybus_get_drvdata(bundle);
 
+	if (gb_pm_runtime_get_sync(bundle))
+		gb_pm_runtime_get_noresume(bundle);
+
 	gb_connection_disable(glights->connection);
 	gb_connection_destroy(glights->connection);
 

commit 957ccca08a990888e2a8f057dee646b8f37b1660
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Wed Jun 29 13:42:26 2016 -0700

    greybus: light: Initialize mutex before using it
    
    Light protocol driver is suffering from the same issue that was fixed in
    camera driver earlier (commit a7c3b0c3c8da).
    
    Big cleanup function is used instead of fine grained control in the
    error path, and in one of the cases the mutex was found uninitialized
    and so the oops seen in SW-6752.
    
    Initialize the mutex before any code can access it.
    
    Compile tested only.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Reviewed-by: Rui Miguel Silva <rui.silva@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/light.c b/drivers/staging/greybus/light.c
index 78fb8a9f6a48..3d42a5dafee9 100644
--- a/drivers/staging/greybus/light.c
+++ b/drivers/staging/greybus/light.c
@@ -1221,6 +1221,8 @@ static int gb_lights_probe(struct gb_bundle *bundle,
 	if (!glights)
 		return -ENOMEM;
 
+	mutex_init(&glights->lights_lock);
+
 	connection = gb_connection_create(bundle, le16_to_cpu(cport_desc->id),
 					  gb_lights_request_handler);
 	if (IS_ERR(connection)) {
@@ -1231,8 +1233,6 @@ static int gb_lights_probe(struct gb_bundle *bundle,
 	glights->connection = connection;
 	gb_connection_set_data(connection, glights);
 
-	mutex_init(&glights->lights_lock);
-
 	greybus_set_drvdata(bundle, glights);
 
 	/* We aren't ready to receive an incoming request yet */

commit d97fca12e92d3179554baf4db42611e5fe56aeed
Author: Alex Elder <elder@linaro.org>
Date:   Tue May 24 13:34:50 2016 -0500

    greybus: fix pointless null check
    
    Coccinelle points out that a call in gb_lights_channel_free() to
    flush_work() is passed which is always non-null.   Prior to the
    call, there is an unnecessary check to see if that address is null.
    Get rid of the test.
    
    Signed-off-by: Alex Elder <elder@linaro.org>
    Reviewed-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/light.c b/drivers/staging/greybus/light.c
index 8b71ed3df318..78fb8a9f6a48 100644
--- a/drivers/staging/greybus/light.c
+++ b/drivers/staging/greybus/light.c
@@ -1019,8 +1019,7 @@ static int gb_lights_light_register(struct gb_light *light)
 static void gb_lights_channel_free(struct gb_channel *channel)
 {
 #ifndef LED_HAVE_SET_BLOCKING
-	if (&channel->work_brightness_set)
-		flush_work(&channel->work_brightness_set);
+	flush_work(&channel->work_brightness_set);
 #endif
 	kfree(channel->attrs);
 	kfree(channel->attr_group);

commit 0ec306324423444d3ee0222708ef9de7f5586b93
Author: Greg Kroah-Hartman <gregkh@google.com>
Date:   Tue Mar 22 14:30:35 2016 -0400

    greybus: convert drivers to use connection->private set/get
    
    This converts all drivers to use the gb_connection_get_data() and
    gb_connection_set_data() functions to make it a bit more explicit as to
    what is going on.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>
    Reviewed-by: Alex Elder <elder@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/light.c b/drivers/staging/greybus/light.c
index 47d4ac4533bc..8b71ed3df318 100644
--- a/drivers/staging/greybus/light.c
+++ b/drivers/staging/greybus/light.c
@@ -1154,7 +1154,7 @@ static int gb_lights_request_handler(struct gb_operation *op)
 {
 	struct gb_connection *connection = op->connection;
 	struct device *dev = &connection->bundle->dev;
-	struct gb_lights *glights = connection->private;
+	struct gb_lights *glights = gb_connection_get_data(connection);
 	struct gb_light *light;
 	struct gb_message *request;
 	struct gb_lights_event_request *payload;
@@ -1230,7 +1230,7 @@ static int gb_lights_probe(struct gb_bundle *bundle,
 	}
 
 	glights->connection = connection;
-	connection->private = glights;
+	gb_connection_set_data(connection, glights);
 
 	mutex_init(&glights->lights_lock);
 

commit bf9deb29e2b3c5dbc97ce559325f4faa0bad5022
Author: Rui Miguel Silva <rui.silva@linaro.org>
Date:   Thu Feb 25 18:05:09 2016 +0000

    greybus: lights: remove unnecessary check
    
    lights can never be NULL at that point since lights_count must be different than
    zero, and we need only to validate the light_id.
    
    Reported-by: Johan Hovold <johan@hovoldconsulting.com>
    Signed-off-by: Rui Miguel Silva <rui.silva@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/light.c b/drivers/staging/greybus/light.c
index 17877f7e2ee4..47d4ac4533bc 100644
--- a/drivers/staging/greybus/light.c
+++ b/drivers/staging/greybus/light.c
@@ -1178,7 +1178,7 @@ static int gb_lights_request_handler(struct gb_operation *op)
 	payload = request->payload;
 	light_id = payload->light_id;
 
-	if (light_id >= glights->lights_count || !glights->lights ||
+	if (light_id >= glights->lights_count ||
 	    !glights->lights[light_id].ready) {
 		dev_err(dev, "Event received for unconfigured light id: %d\n",
 			light_id);

commit c6ad27a98ce5f9718c7235cf02de2055897f56d5
Author: Rui Miguel Silva <rui.silva@linaro.org>
Date:   Wed Feb 17 14:32:53 2016 +0000

    greybus: lights: fix check for configured lights
    
    The validation for a complete configured light is wrong and it is
    reworked to make sure that only when the light is ready, will handle
    request events.
    
    Signed-off-by: Rui Miguel Silva <rui.silva@linaro.org>
    Reported-by: Johan Hovold <johan@hovoldconsulting.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/light.c b/drivers/staging/greybus/light.c
index 4c46d149cb7d..17877f7e2ee4 100644
--- a/drivers/staging/greybus/light.c
+++ b/drivers/staging/greybus/light.c
@@ -55,6 +55,7 @@ struct gb_light {
 	u8			channels_count;
 	struct gb_channel	*channels;
 	bool			has_flash;
+	bool			ready;
 #ifdef V4L2_HAVE_FLASH
 	struct v4l2_flash	*v4l2_flash;
 #endif
@@ -1002,6 +1003,8 @@ static int gb_lights_light_register(struct gb_light *light)
 			return ret;
 	}
 
+	light->ready = true;
+
 	if (light->has_flash) {
 		ret = gb_lights_light_v4l2_register(light);
 		if (ret < 0) {
@@ -1040,6 +1043,7 @@ static void gb_lights_light_release(struct gb_light *light)
 	int i;
 	int count;
 
+	light->ready = false;
 
 	count = light->channels_count;
 
@@ -1174,7 +1178,8 @@ static int gb_lights_request_handler(struct gb_operation *op)
 	payload = request->payload;
 	light_id = payload->light_id;
 
-	if (light_id >= glights->lights_count || !&glights->lights[light_id]) {
+	if (light_id >= glights->lights_count || !glights->lights ||
+	    !glights->lights[light_id].ready) {
 		dev_err(dev, "Event received for unconfigured light id: %d\n",
 			light_id);
 		return -EINVAL;

commit 137f717942c9cff82484ee90647881d9c524178f
Author: Rui Miguel Silva <rui.silva@linaro.org>
Date:   Wed Feb 17 14:32:52 2016 +0000

    greybus: lights: remove has_flash on failure
    
    If register to v4l2 fails just mark the light as not having flash so in
    release we do not try to unregister.
    
    Signed-off-by: Rui Miguel Silva <rui.silva@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/light.c b/drivers/staging/greybus/light.c
index 6c5b9994457c..4c46d149cb7d 100644
--- a/drivers/staging/greybus/light.c
+++ b/drivers/staging/greybus/light.c
@@ -1004,8 +1004,10 @@ static int gb_lights_light_register(struct gb_light *light)
 
 	if (light->has_flash) {
 		ret = gb_lights_light_v4l2_register(light);
-		if (ret < 0)
+		if (ret < 0) {
+			light->has_flash = false;
 			return ret;
+		}
 	}
 
 	return 0;

commit 492331435465977407e43865c19e34918cd90a66
Author: Rui Miguel Silva <rui.silva@linaro.org>
Date:   Wed Feb 17 14:32:51 2016 +0000

    greybus: lights: remove unnecessary checks
    
    We do not need to check for channels and lights as they can never be
    NULL as a big memory array elements.
    
    Signed-off-by: Rui Miguel Silva <rui.silva@linaro.org>
    Reported-by: Johan Hovold <johan@hovoldconsulting.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/light.c b/drivers/staging/greybus/light.c
index 70fcade451dc..6c5b9994457c 100644
--- a/drivers/staging/greybus/light.c
+++ b/drivers/staging/greybus/light.c
@@ -1026,9 +1026,6 @@ static void gb_lights_channel_free(struct gb_channel *channel)
 
 static void gb_lights_channel_release(struct gb_channel *channel)
 {
-	if (!channel)
-		return;
-
 	channel->releasing = true;
 
 	gb_lights_channel_unregister(channel);
@@ -1041,8 +1038,6 @@ static void gb_lights_light_release(struct gb_light *light)
 	int i;
 	int count;
 
-	if (!light)
-		return;
 
 	count = light->channels_count;
 

commit 69564dfeacf0728b60e3b2c85b357bc63213116c
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Fri Feb 12 16:08:31 2016 +0530

    greybus: lights: convert to bundle driver
    
    Convert the legacy lights protocol driver to a bundle driver.
    
    This also fixes a potential crash should a (malicious) module have sent
    an early request before the private data had been initialised.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Reviewed-by: Johan Hovold <johan@hovoldconsulting.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/light.c b/drivers/staging/greybus/light.c
index c1ad6b11bc16..70fcade451dc 100644
--- a/drivers/staging/greybus/light.c
+++ b/drivers/staging/greybus/light.c
@@ -1149,7 +1149,7 @@ static int gb_lights_register_all(struct gb_lights *glights)
 	return ret;
 }
 
-static int gb_lights_event_recv(u8 type, struct gb_operation *op)
+static int gb_lights_request_handler(struct gb_operation *op)
 {
 	struct gb_connection *connection = op->connection;
 	struct device *dev = &connection->bundle->dev;
@@ -1161,8 +1161,8 @@ static int gb_lights_event_recv(u8 type, struct gb_operation *op)
 	u8 light_id;
 	u8 event;
 
-	if (type != GB_LIGHTS_TYPE_EVENT) {
-		dev_err(dev, "Unsupported unsolicited event: %u\n", type);
+	if (op->type != GB_LIGHTS_TYPE_EVENT) {
+		dev_err(dev, "Unsupported unsolicited event: %u\n", op->type);
 		return -EINVAL;
 	}
 
@@ -1201,57 +1201,95 @@ static int gb_lights_event_recv(u8 type, struct gb_operation *op)
 	return ret;
 }
 
-static int gb_lights_connection_init(struct gb_connection *connection)
+static int gb_lights_probe(struct gb_bundle *bundle,
+			   const struct greybus_bundle_id *id)
 {
+	struct greybus_descriptor_cport *cport_desc;
+	struct gb_connection *connection;
 	struct gb_lights *glights;
 	int ret;
 
+	if (bundle->num_cports != 1)
+		return -ENODEV;
+
+	cport_desc = &bundle->cport_desc[0];
+	if (cport_desc->protocol_id != GREYBUS_PROTOCOL_LIGHTS)
+		return -ENODEV;
+
 	glights = kzalloc(sizeof(*glights), GFP_KERNEL);
 	if (!glights)
 		return -ENOMEM;
 
+	connection = gb_connection_create(bundle, le16_to_cpu(cport_desc->id),
+					  gb_lights_request_handler);
+	if (IS_ERR(connection)) {
+		ret = PTR_ERR(connection);
+		goto out;
+	}
+
 	glights->connection = connection;
 	connection->private = glights;
 
 	mutex_init(&glights->lights_lock);
 
+	greybus_set_drvdata(bundle, glights);
+
+	/* We aren't ready to receive an incoming request yet */
+	ret = gb_connection_enable_tx(connection);
+	if (ret)
+		goto error_connection_destroy;
+
 	/*
 	 * Setup all the lights devices over this connection, if anything goes
 	 * wrong tear down all lights
 	 */
 	ret = gb_lights_create_all(glights);
 	if (ret < 0)
-		goto out;
+		goto error_connection_disable;
+
+	/* We are ready to receive an incoming request now, enable RX as well */
+	ret = gb_connection_enable(connection);
+	if (ret)
+		goto error_connection_disable;
 
 	/* Enable & register lights */
 	ret = gb_lights_register_all(glights);
 	if (ret < 0)
-		goto out;
+		goto error_connection_disable;
 
 	return 0;
 
+error_connection_disable:
+	gb_connection_disable(connection);
+error_connection_destroy:
+	gb_connection_destroy(connection);
 out:
 	gb_lights_release(glights);
 	return ret;
 }
 
-static void gb_lights_connection_exit(struct gb_connection *connection)
+static void gb_lights_disconnect(struct gb_bundle *bundle)
 {
-	struct gb_lights *glights = connection->private;
+	struct gb_lights *glights = greybus_get_drvdata(bundle);
+
+	gb_connection_disable(glights->connection);
+	gb_connection_destroy(glights->connection);
 
 	gb_lights_release(glights);
 }
 
-static struct gb_protocol lights_protocol = {
-	.name			= "lights",
-	.id			= GREYBUS_PROTOCOL_LIGHTS,
-	.major			= GB_LIGHTS_VERSION_MAJOR,
-	.minor			= GB_LIGHTS_VERSION_MINOR,
-	.connection_init	= gb_lights_connection_init,
-	.connection_exit	= gb_lights_connection_exit,
-	.request_recv		= gb_lights_event_recv,
+static const struct greybus_bundle_id gb_lights_id_table[] = {
+	{ GREYBUS_DEVICE_CLASS(GREYBUS_CLASS_LIGHTS) },
+	{ }
 };
+MODULE_DEVICE_TABLE(greybus, gb_lights_id_table);
 
-gb_protocol_driver(&lights_protocol);
+static struct greybus_driver gb_lights_driver = {
+	.name		= "lights",
+	.probe		= gb_lights_probe,
+	.disconnect	= gb_lights_disconnect,
+	.id_table	= gb_lights_id_table,
+};
+module_greybus_driver(gb_lights_driver);
 
 MODULE_LICENSE("GPL v2");

commit 6ce0eed783bd6b507fb029323d30d0e9a9d38da2
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Fri Feb 12 16:08:30 2016 +0530

    greybus: lights: Break light setup into two parts
    
    This breaks the light setup routine into two parts, the first one
    allocates all the necessary resources and the second on registers lights
    to the required frameworks.
    
    This is required to enable only TX on the connection, until we have
    allocated all the resources, otherwise the request handler might get
    called for partially initialized structures.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Reviewed-by: Rui Miguel Silva <rui.silva@linaro.org>
    Reviewed-by: Johan Hovold <johan@hovoldconsulting.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/light.c b/drivers/staging/greybus/light.c
index 3488bbd58198..c1ad6b11bc16 100644
--- a/drivers/staging/greybus/light.c
+++ b/drivers/staging/greybus/light.c
@@ -983,6 +983,14 @@ static int gb_lights_light_config(struct gb_lights *glights, u8 id)
 			return ret;
 	}
 
+	return 0;
+}
+
+static int gb_lights_light_register(struct gb_light *light)
+{
+	int ret;
+	int i;
+
 	/*
 	 * Then, if everything went ok in getting configurations, we register
 	 * the classdev, flash classdev and v4l2 subsystem, if a flash device is
@@ -1089,7 +1097,7 @@ static int gb_lights_get_count(struct gb_lights *glights)
 	return 0;
 }
 
-static int gb_lights_setup(struct gb_lights *glights)
+static int gb_lights_create_all(struct gb_lights *glights)
 {
 	struct gb_connection *connection = glights->connection;
 	int ret;
@@ -1121,11 +1129,32 @@ static int gb_lights_setup(struct gb_lights *glights)
 	return ret;
 }
 
+static int gb_lights_register_all(struct gb_lights *glights)
+{
+	struct gb_connection *connection = glights->connection;
+	int ret = 0;
+	int i;
+
+	mutex_lock(&glights->lights_lock);
+	for (i = 0; i < glights->lights_count; i++) {
+		ret = gb_lights_light_register(&glights->lights[i]);
+		if (ret < 0) {
+			dev_err(&connection->bundle->dev,
+				"Fail to enable lights device\n");
+			break;
+		}
+	}
+
+	mutex_unlock(&glights->lights_lock);
+	return ret;
+}
+
 static int gb_lights_event_recv(u8 type, struct gb_operation *op)
 {
 	struct gb_connection *connection = op->connection;
 	struct device *dev = &connection->bundle->dev;
 	struct gb_lights *glights = connection->private;
+	struct gb_light *light;
 	struct gb_message *request;
 	struct gb_lights_event_request *payload;
 	int ret =  0;
@@ -1157,11 +1186,15 @@ static int gb_lights_event_recv(u8 type, struct gb_operation *op)
 	event = payload->event;
 
 	if (event & GB_LIGHTS_LIGHT_CONFIG) {
+		light = &glights->lights[light_id];
+
 		mutex_lock(&glights->lights_lock);
-		gb_lights_light_release(&glights->lights[light_id]);
+		gb_lights_light_release(light);
 		ret = gb_lights_light_config(glights, light_id);
+		if (!ret)
+			ret = gb_lights_light_register(light);
 		if (ret < 0)
-			gb_lights_light_release(&glights->lights[light_id]);
+			gb_lights_light_release(light);
 		mutex_unlock(&glights->lights_lock);
 	}
 
@@ -1186,7 +1219,12 @@ static int gb_lights_connection_init(struct gb_connection *connection)
 	 * Setup all the lights devices over this connection, if anything goes
 	 * wrong tear down all lights
 	 */
-	ret = gb_lights_setup(glights);
+	ret = gb_lights_create_all(glights);
+	if (ret < 0)
+		goto out;
+
+	/* Enable & register lights */
+	ret = gb_lights_register_all(glights);
 	if (ret < 0)
 		goto out;
 

commit 9c06c6a2b9ec4cfa78a4cf5ab123bfca0285e083
Author: Rui Miguel Silva <rui.silva@linaro.org>
Date:   Tue Jan 12 14:35:49 2016 +0000

    greybus: lights: remove sync operation and work queue
    
    In kernel v4.5 there is a change in LED api, which remove the need for
    individual work queue and rename the set_sync operation to set_blocking.
    This patch add the handling of this case and avoid compilation failure
    for this kernel versions.
    
    Signed-off-by: Rui Miguel Silva <rui.silva@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/light.c b/drivers/staging/greybus/light.c
index 153c4f5479f0..3488bbd58198 100644
--- a/drivers/staging/greybus/light.c
+++ b/drivers/staging/greybus/light.c
@@ -30,7 +30,9 @@ struct gb_channel {
 	struct attribute		**attrs;
 	struct attribute_group		*attr_group;
 	const struct attribute_group	**attr_groups;
+#ifndef LED_HAVE_SET_BLOCKING
 	struct work_struct		work_brightness_set;
+#endif
 	struct led_classdev		*led;
 #ifdef LED_HAVE_FLASH
 	struct led_classdev_flash	fled;
@@ -381,6 +383,7 @@ static int __gb_lights_brightness_set(struct gb_channel *channel)
 	return ret;
 }
 
+#ifndef LED_HAVE_SET_BLOCKING
 static void gb_brightness_set_work(struct work_struct *work)
 {
 	struct gb_channel *channel = container_of(work, struct gb_channel,
@@ -412,6 +415,17 @@ static void gb_brightness_set(struct led_classdev *cdev,
 	cdev->brightness = value;
 	schedule_work(&channel->work_brightness_set);
 }
+#else /* LED_HAVE_SET_BLOCKING */
+static int gb_brightness_set(struct led_classdev *cdev,
+			     enum led_brightness value)
+{
+	struct gb_channel *channel = get_channel_from_cdev(cdev);
+
+	channel->led->brightness = value;
+
+	return __gb_lights_brightness_set(channel);
+}
+#endif
 
 static enum led_brightness gb_brightness_get(struct led_classdev *cdev)
 
@@ -443,12 +457,17 @@ static int gb_blink_set(struct led_classdev *cdev, unsigned long *delay_on,
 static void gb_lights_led_operations_set(struct gb_channel *channel,
 					 struct led_classdev *cdev)
 {
-	cdev->brightness_set = gb_brightness_set;
 	cdev->brightness_get = gb_brightness_get;
 #ifdef LED_HAVE_SET_SYNC
 	cdev->brightness_set_sync = gb_brightness_set_sync;
 #endif
+#ifdef LED_HAVE_SET_BLOCKING
+	cdev->brightness_set_blocking = gb_brightness_set;
+#endif
+#ifndef LED_HAVE_SET_BLOCKING
+	cdev->brightness_set = gb_brightness_set;
 	INIT_WORK(&channel->work_brightness_set, gb_brightness_set_work);
+#endif
 
 	if (channel->flags & GB_LIGHT_CHANNEL_BLINK)
 		cdev->blink_set = gb_blink_set;
@@ -986,8 +1005,10 @@ static int gb_lights_light_config(struct gb_lights *glights, u8 id)
 
 static void gb_lights_channel_free(struct gb_channel *channel)
 {
+#ifndef LED_HAVE_SET_BLOCKING
 	if (&channel->work_brightness_set)
 		flush_work(&channel->work_brightness_set);
+#endif
 	kfree(channel->attrs);
 	kfree(channel->attr_group);
 	kfree(channel->attr_groups);

commit 1700507d8c1b3578152c8afa8062a66e78e3a4bb
Author: Rui Miguel Silva <rui.silva@linaro.org>
Date:   Thu Dec 3 16:07:49 2015 +0000

    greybus: lights: default value for v4l2 flash controls
    
    V4l2 flash will return erro ERANGE if val(which is the default value)
    is not defined. Just set it to the max value reported by the module.
    
    Signed-off-by: Rui Miguel Silva <rui.silva@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/light.c b/drivers/staging/greybus/light.c
index c49cc7ea4b28..153c4f5479f0 100644
--- a/drivers/staging/greybus/light.c
+++ b/drivers/staging/greybus/light.c
@@ -702,6 +702,7 @@ static int __gb_lights_flash_led_register(struct gb_channel *channel)
 	fset->min = channel->intensity_uA.min;
 	fset->max = channel->intensity_uA.max;
 	fset->step = channel->intensity_uA.step;
+	fset->val = channel->intensity_uA.max;
 
 	/* Only the flash mode have the timeout constraints settings */
 	if (channel->mode & GB_CHANNEL_MODE_FLASH) {
@@ -709,6 +710,7 @@ static int __gb_lights_flash_led_register(struct gb_channel *channel)
 		fset->min = channel->timeout_us.min;
 		fset->max = channel->timeout_us.max;
 		fset->step = channel->timeout_us.step;
+		fset->val = channel->timeout_us.max;
 	}
 
 	/*

commit d644181fe60f4fcfca7e9e9e9b0503993e391e69
Author: Rui Miguel Silva <rui.silva@linaro.org>
Date:   Thu Dec 3 16:07:48 2015 +0000

    greybus: lights: avoid channel torch double free
    
    When attaching torch to a flash we release the channel torch resources,
    but afterwards we do it again when releasing all the channels.
    Just free all the resource at channel release.
    
    Signed-off-by: Rui Miguel Silva <rui.silva@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/light.c b/drivers/staging/greybus/light.c
index 01dcf18c9601..c49cc7ea4b28 100644
--- a/drivers/staging/greybus/light.c
+++ b/drivers/staging/greybus/light.c
@@ -681,9 +681,6 @@ static int __gb_lights_channel_torch_attach(struct gb_channel *channel,
 	kfree(channel->led->name);
 	channel->led->name = name;
 
-	/* free original torch channel resources */
-	gb_lights_channel_free(channel_torch);
-
 	channel_torch->led = channel->led;
 
 	return 0;

commit 3f85c787b74c26f3816017e64288af907f291462
Author: Rui Miguel Silva <rui.silva@linaro.org>
Date:   Thu Dec 3 16:07:47 2015 +0000

    greybus: lights: add v4l2 flash operations
    
    We do not implement any of the v4l2 flash operations, as the default
    ones are ok for now, however the init needs anything define, if not it
    will return an error. So, just define it and have an error free v4l2
    flash init.
    
    Signed-off-by: Rui Miguel Silva <rui.silva@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/light.c b/drivers/staging/greybus/light.c
index 3723a2ce29b3..01dcf18c9601 100644
--- a/drivers/staging/greybus/light.c
+++ b/drivers/staging/greybus/light.c
@@ -456,6 +456,8 @@ static void gb_lights_led_operations_set(struct gb_channel *channel,
 
 #ifdef V4L2_HAVE_FLASH
 /* V4L2 specific helpers */
+static const struct v4l2_flash_ops v4l2_flash_ops;
+
 static void __gb_lights_channel_v4l2_config(struct led_flash_setting *channel_s,
 					    struct led_flash_setting *v4l2_s)
 {
@@ -507,7 +509,7 @@ static int gb_lights_light_v4l2_register(struct gb_light *light)
 		LED_FAULT_LED_OVER_TEMPERATURE;
 
 	light->v4l2_flash = v4l2_flash_init(dev, NULL, fled, iled,
-					    NULL, sd_cfg);
+					    &v4l2_flash_ops, sd_cfg);
 	if (IS_ERR_OR_NULL(light->v4l2_flash)) {
 		ret = PTR_ERR(light->v4l2_flash);
 		goto out_free;

commit f865734d3cf58cc9aba3f58962fbca7b97fe47d4
Author: Johan Hovold <johan@hovoldconsulting.com>
Date:   Wed Nov 11 10:07:04 2015 +0100

    greybus: light: fix class-device parent
    
    Greybus bundle drivers should register their class devices as children
    to the bundle device that they bind to.
    
    Signed-off-by: Johan Hovold <johan@hovoldconsulting.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/light.c b/drivers/staging/greybus/light.c
index 664be973fa96..3723a2ce29b3 100644
--- a/drivers/staging/greybus/light.c
+++ b/drivers/staging/greybus/light.c
@@ -724,8 +724,7 @@ static int __gb_lights_flash_led_register(struct gb_channel *channel)
 			goto fail;
 	}
 
-	ret = led_classdev_flash_register(&connection->bundle->intf->dev,
-					  fled);
+	ret = led_classdev_flash_register(&connection->bundle->dev, fled);
 	if (ret < 0)
 		goto fail;
 
@@ -812,8 +811,7 @@ static int __gb_lights_led_register(struct gb_channel *channel)
 	struct led_classdev *cdev = get_channel_cdev(channel);
 	int ret;
 
-	ret = led_classdev_register(&connection->bundle->intf->dev,
-				    cdev);
+	ret = led_classdev_register(&connection->bundle->dev, cdev);
 	if (ret < 0)
 		channel->led = NULL;
 	else

commit 5fd18b37c6a718d9daf8719ac81e4aa67ded4106
Author: Greg Kroah-Hartman <gregkh@google.com>
Date:   Wed Oct 14 11:19:09 2015 -0700

    greybus: light : use the bundle struct device instead of the connector
    
    We are removing struct device from the gb_connection structure in the
    near future.  The gb_bundle structure's struct device should be used as
    a replacement.
    
    This patch moves the light driver to use the bundle pointer instead of
    the connection pointer.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>
    Reviewed-by: Alex Elder <elder@linaro.org>

diff --git a/drivers/staging/greybus/light.c b/drivers/staging/greybus/light.c
index e8ef7f5c37a0..664be973fa96 100644
--- a/drivers/staging/greybus/light.c
+++ b/drivers/staging/greybus/light.c
@@ -469,7 +469,7 @@ static void __gb_lights_channel_v4l2_config(struct led_flash_setting *channel_s,
 static int gb_lights_light_v4l2_register(struct gb_light *light)
 {
 	struct gb_connection *connection = get_conn_from_light(light);
-	struct device *dev = &connection->dev;
+	struct device *dev = &connection->bundle->dev;
 	struct v4l2_flash_config *sd_cfg;
 	struct led_classdev_flash *fled;
 	struct led_classdev_flash *iled = NULL;
@@ -529,7 +529,7 @@ static int gb_lights_light_v4l2_register(struct gb_light *light)
 {
 	struct gb_connection *connection = get_conn_from_light(light);
 
-	dev_err(&connection->dev, "no support for v4l2 subdevices\n");
+	dev_err(&connection->bundle->dev, "no support for v4l2 subdevices\n");
 	return 0;
 }
 
@@ -791,7 +791,7 @@ static int gb_lights_channel_flash_config(struct gb_channel *channel)
 {
 	struct gb_connection *connection = get_conn_from_channel(channel);
 
-	dev_err(&connection->dev, "no support for flash devices\n");
+	dev_err(&connection->bundle->dev, "no support for flash devices\n");
 	return 0;
 }
 
@@ -1090,7 +1090,7 @@ static int gb_lights_setup(struct gb_lights *glights)
 	for (i = 0; i < glights->lights_count; i++) {
 		ret = gb_lights_light_config(glights, i);
 		if (ret < 0) {
-			dev_err(&connection->dev,
+			dev_err(&connection->bundle->dev,
 				"Fail to configure lights device\n");
 			goto out;
 		}
@@ -1104,6 +1104,7 @@ static int gb_lights_setup(struct gb_lights *glights)
 static int gb_lights_event_recv(u8 type, struct gb_operation *op)
 {
 	struct gb_connection *connection = op->connection;
+	struct device *dev = &connection->bundle->dev;
 	struct gb_lights *glights = connection->private;
 	struct gb_message *request;
 	struct gb_lights_event_request *payload;
@@ -1112,16 +1113,14 @@ static int gb_lights_event_recv(u8 type, struct gb_operation *op)
 	u8 event;
 
 	if (type != GB_LIGHTS_TYPE_EVENT) {
-		dev_err(&connection->dev,
-			"Unsupported unsolicited event: %u\n", type);
+		dev_err(dev, "Unsupported unsolicited event: %u\n", type);
 		return -EINVAL;
 	}
 
 	request = op->request;
 
 	if (request->payload_size < sizeof(*payload)) {
-		dev_err(&connection->dev,
-			"Wrong event size received (%zu < %zu)\n",
+		dev_err(dev, "Wrong event size received (%zu < %zu)\n",
 			request->payload_size, sizeof(*payload));
 		return -EINVAL;
 	}
@@ -1130,8 +1129,7 @@ static int gb_lights_event_recv(u8 type, struct gb_operation *op)
 	light_id = payload->light_id;
 
 	if (light_id >= glights->lights_count || !&glights->lights[light_id]) {
-		dev_err(&connection->dev,
-			"Event received for unconfigured light id: %d\n",
+		dev_err(dev, "Event received for unconfigured light id: %d\n",
 			light_id);
 		return -EINVAL;
 	}

commit 2870b52bae4c81823ffcb3ed2b0626fb39d64f48
Author: Rui Miguel Silva <rui.silva@linaro.org>
Date:   Fri Aug 14 13:58:19 2015 +0100

    greybus: lights: add lights implementation
    
    This patch adds lights implementation for Greybus Lights class, it
    allows multiplexing of lights devices using the same connection. Also
    adds two sysfs entries to led class (color, fade) which are commonly
    used in several existing LED devices.
    
    It support 2 major class of devices (normal LED and flash type), for
    the first it registers to led_classdev, for the latest it registers in
    the led_classdev_flash and v4l2_flash, depending on the support of the
    kernel version.
    
    Each Module can have N light devices attach and each light can have
    multiple channel associated:
    glights
       |->light0
       |     |->channel0
       |     |->channel1
       |     | ....
       |     |->channeln
       |->...
       |->lightn
             |->channel0
             |->channel1
             | ....
             |->channeln
    
    Signed-off-by: Rui Miguel Silva <rui.silva@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/light.c b/drivers/staging/greybus/light.c
new file mode 100644
index 000000000000..e8ef7f5c37a0
--- /dev/null
+++ b/drivers/staging/greybus/light.c
@@ -0,0 +1,1201 @@
+/*
+ * Greybus Lights protocol driver.
+ *
+ * Copyright 2015 Google Inc.
+ * Copyright 2015 Linaro Ltd.
+ *
+ * Released under the GPLv2 only.
+ */
+
+#include <linux/kernel.h>
+#include <linux/leds.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/version.h>
+
+#include "greybus.h"
+#include "greybus_protocols.h"
+
+#define NAMES_MAX	32
+
+struct gb_channel {
+	u8				id;
+	u32				flags;
+	u32				color;
+	char				*color_name;
+	u8				fade_in;
+	u8				fade_out;
+	u32				mode;
+	char				*mode_name;
+	struct attribute		**attrs;
+	struct attribute_group		*attr_group;
+	const struct attribute_group	**attr_groups;
+	struct work_struct		work_brightness_set;
+	struct led_classdev		*led;
+#ifdef LED_HAVE_FLASH
+	struct led_classdev_flash	fled;
+	struct led_flash_setting	intensity_uA;
+	struct led_flash_setting	timeout_us;
+#else
+	struct led_classdev		cled;
+#endif
+	struct gb_light			*light;
+	bool				is_registered;
+	bool				releasing;
+	bool				strobe_state;
+};
+
+struct gb_light {
+	u8			id;
+	char			*name;
+	struct gb_lights	*glights;
+	u32			flags;
+	u8			channels_count;
+	struct gb_channel	*channels;
+	bool			has_flash;
+#ifdef V4L2_HAVE_FLASH
+	struct v4l2_flash	*v4l2_flash;
+#endif
+};
+
+struct gb_lights {
+	struct gb_connection	*connection;
+	u8			lights_count;
+	struct gb_light		*lights;
+	struct mutex		lights_lock;
+};
+
+static void gb_lights_channel_free(struct gb_channel *channel);
+
+static struct gb_connection *get_conn_from_channel(struct gb_channel *channel)
+{
+	return channel->light->glights->connection;
+}
+
+static struct gb_connection *get_conn_from_light(struct gb_light *light)
+{
+	return light->glights->connection;
+}
+
+static bool is_channel_flash(struct gb_channel *channel)
+{
+	return !!(channel->mode & (GB_CHANNEL_MODE_FLASH | GB_CHANNEL_MODE_TORCH
+				   | GB_CHANNEL_MODE_INDICATOR));
+}
+
+#ifdef LED_HAVE_FLASH
+static struct gb_channel *get_channel_from_cdev(struct led_classdev *cdev)
+{
+	struct led_classdev_flash *fled_cdev = lcdev_to_flcdev(cdev);
+
+	return container_of(fled_cdev, struct gb_channel, fled);
+}
+
+static struct led_classdev *get_channel_cdev(struct gb_channel *channel)
+{
+	return &channel->fled.led_cdev;
+}
+
+static struct gb_channel *get_channel_from_mode(struct gb_light *light,
+						u32 mode)
+{
+	struct gb_channel *channel = NULL;
+	int i;
+
+	for (i = 0; i < light->channels_count; i++) {
+		channel = &light->channels[i];
+		if (channel && channel->mode == mode)
+			break;
+	}
+	return channel;
+}
+
+static int __gb_lights_flash_intensity_set(struct gb_channel *channel,
+					   u32 intensity)
+{
+	struct gb_connection *connection = get_conn_from_channel(channel);
+	struct gb_lights_set_flash_intensity_request req;
+
+	if (channel->releasing)
+		return -ESHUTDOWN;
+
+	req.light_id = channel->light->id;
+	req.channel_id = channel->id;
+	req.intensity_uA = cpu_to_le32(intensity);
+
+	return gb_operation_sync(connection, GB_LIGHTS_TYPE_SET_FLASH_INTENSITY,
+				 &req, sizeof(req), NULL, 0);
+}
+
+static int __gb_lights_flash_brightness_set(struct gb_channel *channel)
+{
+	u32 intensity;
+
+	/* If the channel is flash we need to get the attached torch channel */
+	if (channel->mode & GB_CHANNEL_MODE_FLASH)
+		channel = get_channel_from_mode(channel->light,
+						GB_CHANNEL_MODE_TORCH);
+
+	/* For not flash we need to convert brightness to intensity */
+	intensity = channel->intensity_uA.min +
+			(channel->intensity_uA.step * channel->led->brightness);
+
+	return __gb_lights_flash_intensity_set(channel, intensity);
+}
+#else /* LED_HAVE_FLASH */
+static struct gb_channel *get_channel_from_cdev(struct led_classdev *cdev)
+{
+	return container_of(cdev, struct gb_channel, cled);
+}
+
+static struct led_classdev *get_channel_cdev(struct gb_channel *channel)
+{
+	return &channel->cled;
+}
+
+static int __gb_lights_flash_brightness_set(struct gb_channel *channel)
+{
+	return 0;
+}
+#endif /* !LED_HAVE_FLASH */
+
+#ifdef LED_HAVE_GROUPS
+static int gb_lights_color_set(struct gb_channel *channel, u32 color);
+static int gb_lights_fade_set(struct gb_channel *channel);
+
+#ifdef LED_HAVE_LOCK
+static void led_lock(struct led_classdev *cdev)
+{
+	mutex_lock(&cdev->led_access);
+}
+
+static void led_unlock(struct led_classdev *cdev)
+{
+	mutex_unlock(&cdev->led_access);
+}
+#else
+static void led_lock(struct led_classdev *cdev)
+{
+}
+
+static void led_unlock(struct led_classdev *cdev)
+{
+}
+#endif /* !LED_HAVE_LOCK */
+
+#define gb_lights_fade_attr(__dir)					\
+static ssize_t fade_##__dir##_show(struct device *dev,			\
+				   struct device_attribute *attr,	\
+				   char *buf)				\
+{									\
+	struct led_classdev *cdev = dev_get_drvdata(dev);		\
+	struct gb_channel *channel = get_channel_from_cdev(cdev);	\
+									\
+	return sprintf(buf, "%u\n", channel->fade_##__dir);		\
+}									\
+									\
+static ssize_t fade_##__dir##_store(struct device *dev,			\
+				    struct device_attribute *attr,	\
+				    const char *buf, size_t size)	\
+{									\
+	struct led_classdev *cdev = dev_get_drvdata(dev);		\
+	struct gb_channel *channel = get_channel_from_cdev(cdev);	\
+	u8 fade;							\
+	int ret;							\
+									\
+	led_lock(cdev);							\
+	if (led_sysfs_is_disabled(cdev)) {				\
+		ret = -EBUSY;						\
+		goto unlock;						\
+	}								\
+									\
+	ret = kstrtou8(buf, 0, &fade);					\
+	if (ret < 0) {							\
+		dev_err(dev, "could not parse fade value %d\n", ret);	\
+		goto unlock;						\
+	}								\
+	if (channel->fade_##__dir == fade)				\
+		goto unlock;						\
+	channel->fade_##__dir = fade;					\
+									\
+	ret = gb_lights_fade_set(channel);				\
+	if (ret < 0)							\
+		goto unlock;						\
+									\
+	ret = size;							\
+unlock:									\
+	led_unlock(cdev);						\
+	return ret;							\
+}									\
+static DEVICE_ATTR_RW(fade_##__dir)
+
+gb_lights_fade_attr(in);
+gb_lights_fade_attr(out);
+
+static ssize_t color_show(struct device *dev, struct device_attribute *attr,
+			  char *buf)
+{
+	struct led_classdev *cdev = dev_get_drvdata(dev);
+	struct gb_channel *channel = get_channel_from_cdev(cdev);
+
+	return sprintf(buf, "0x%08x\n", channel->color);
+}
+
+static ssize_t color_store(struct device *dev, struct device_attribute *attr,
+			   const char *buf, size_t size)
+{
+	struct led_classdev *cdev = dev_get_drvdata(dev);
+	struct gb_channel *channel = get_channel_from_cdev(cdev);
+	u32 color;
+	int ret;
+
+	led_lock(cdev);
+	if (led_sysfs_is_disabled(cdev)) {
+		ret = -EBUSY;
+		goto unlock;
+	}
+	ret = kstrtou32(buf, 0, &color);
+	if (ret < 0) {
+		dev_err(dev, "could not parse color value %d\n", ret);
+		goto unlock;
+	}
+
+	ret = gb_lights_color_set(channel, color);
+	if (ret < 0)
+		goto unlock;
+
+	channel->color = color;
+	ret = size;
+unlock:
+	led_unlock(cdev);
+	return ret;
+}
+static DEVICE_ATTR_RW(color);
+
+static int channel_attr_groups_set(struct gb_channel *channel,
+				   struct led_classdev *cdev)
+{
+	int attr = 0;
+	int size = 0;
+
+	if (channel->flags & GB_LIGHT_CHANNEL_MULTICOLOR)
+		size++;
+	if (channel->flags & GB_LIGHT_CHANNEL_FADER)
+		size++;
+
+	if (!size)
+		return 0;
+
+	/* Set attributes based in the channel flags */
+	channel->attrs = kcalloc(size, sizeof(**channel->attrs), GFP_KERNEL);
+	if (!channel->attrs)
+		return -ENOMEM;
+	channel->attr_group = kcalloc(1, sizeof(*channel->attr_group),
+				      GFP_KERNEL);
+	if (!channel->attr_group)
+		return -ENOMEM;
+	channel->attr_groups = kcalloc(2, sizeof(*channel->attr_groups),
+				       GFP_KERNEL);
+	if (!channel->attr_groups)
+		return -ENOMEM;
+
+	if (channel->flags & GB_LIGHT_CHANNEL_MULTICOLOR)
+		channel->attrs[attr++] = &dev_attr_color.attr;
+	if (channel->flags & GB_LIGHT_CHANNEL_FADER) {
+		channel->attrs[attr++] = &dev_attr_fade_in.attr;
+		channel->attrs[attr++] = &dev_attr_fade_out.attr;
+	}
+
+	channel->attr_group->attrs = channel->attrs;
+
+	channel->attr_groups[0] = channel->attr_group;
+
+	cdev->groups = channel->attr_groups;
+
+	return 0;
+}
+
+static int gb_lights_fade_set(struct gb_channel *channel)
+{
+	struct gb_connection *connection = get_conn_from_channel(channel);
+	struct gb_lights_set_fade_request req;
+
+	if (channel->releasing)
+		return -ESHUTDOWN;
+
+	req.light_id = channel->light->id;
+	req.channel_id = channel->id;
+	req.fade_in = channel->fade_in;
+	req.fade_out = channel->fade_out;
+	return gb_operation_sync(connection, GB_LIGHTS_TYPE_SET_FADE,
+				 &req, sizeof(req), NULL, 0);
+}
+
+static int gb_lights_color_set(struct gb_channel *channel, u32 color)
+{
+	struct gb_connection *connection = get_conn_from_channel(channel);
+	struct gb_lights_set_color_request req;
+
+	if (channel->releasing)
+		return -ESHUTDOWN;
+
+	req.light_id = channel->light->id;
+	req.channel_id = channel->id;
+	req.color = cpu_to_le32(color);
+	return gb_operation_sync(connection, GB_LIGHTS_TYPE_SET_COLOR,
+				 &req, sizeof(req), NULL, 0);
+}
+#else /* LED_HAVE_GROUPS */
+static int channel_attr_groups_set(struct gb_channel *channel,
+				   struct led_classdev *cdev)
+{
+	return 0;
+}
+#endif /* !LED_HAVE_GROUPS */
+
+static int __gb_lights_led_brightness_set(struct gb_channel *channel)
+{
+	struct gb_lights_set_brightness_request req;
+	struct gb_connection *connection = get_conn_from_channel(channel);
+
+	req.light_id = channel->light->id;
+	req.channel_id = channel->id;
+	req.brightness = (u8)channel->led->brightness;
+
+	return gb_operation_sync(connection, GB_LIGHTS_TYPE_SET_BRIGHTNESS,
+				 &req, sizeof(req), NULL, 0);
+}
+
+static int __gb_lights_brightness_set(struct gb_channel *channel)
+{
+	int ret;
+
+	if (channel->releasing)
+		return 0;
+
+	if (is_channel_flash(channel))
+		ret = __gb_lights_flash_brightness_set(channel);
+	else
+		ret = __gb_lights_led_brightness_set(channel);
+
+	return ret;
+}
+
+static void gb_brightness_set_work(struct work_struct *work)
+{
+	struct gb_channel *channel = container_of(work, struct gb_channel,
+						  work_brightness_set);
+
+	__gb_lights_brightness_set(channel);
+}
+
+#ifdef LED_HAVE_SET_SYNC
+static int gb_brightness_set_sync(struct led_classdev *cdev,
+				  enum led_brightness value)
+{
+	struct gb_channel *channel = get_channel_from_cdev(cdev);
+
+	channel->led->brightness = value;
+
+	return __gb_lights_brightness_set(channel);
+}
+#endif
+
+static void gb_brightness_set(struct led_classdev *cdev,
+			      enum led_brightness value)
+{
+	struct gb_channel *channel = get_channel_from_cdev(cdev);
+
+	if (channel->releasing)
+		return;
+
+	cdev->brightness = value;
+	schedule_work(&channel->work_brightness_set);
+}
+
+static enum led_brightness gb_brightness_get(struct led_classdev *cdev)
+
+{
+	struct gb_channel *channel = get_channel_from_cdev(cdev);
+
+	return channel->led->brightness;
+}
+
+static int gb_blink_set(struct led_classdev *cdev, unsigned long *delay_on,
+			unsigned long *delay_off)
+{
+	struct gb_channel *channel = get_channel_from_cdev(cdev);
+	struct gb_connection *connection = get_conn_from_channel(channel);
+	struct gb_lights_blink_request req;
+
+	if (channel->releasing)
+		return -ESHUTDOWN;
+
+	req.light_id = channel->light->id;
+	req.channel_id = channel->id;
+	req.time_on_ms = cpu_to_le16(*delay_on);
+	req.time_off_ms = cpu_to_le16(*delay_off);
+
+	return gb_operation_sync(connection, GB_LIGHTS_TYPE_SET_BLINK, &req,
+				 sizeof(req), NULL, 0);
+}
+
+static void gb_lights_led_operations_set(struct gb_channel *channel,
+					 struct led_classdev *cdev)
+{
+	cdev->brightness_set = gb_brightness_set;
+	cdev->brightness_get = gb_brightness_get;
+#ifdef LED_HAVE_SET_SYNC
+	cdev->brightness_set_sync = gb_brightness_set_sync;
+#endif
+	INIT_WORK(&channel->work_brightness_set, gb_brightness_set_work);
+
+	if (channel->flags & GB_LIGHT_CHANNEL_BLINK)
+		cdev->blink_set = gb_blink_set;
+}
+
+#ifdef V4L2_HAVE_FLASH
+/* V4L2 specific helpers */
+static void __gb_lights_channel_v4l2_config(struct led_flash_setting *channel_s,
+					    struct led_flash_setting *v4l2_s)
+{
+	v4l2_s->min = channel_s->min;
+	v4l2_s->max = channel_s->max;
+	v4l2_s->step = channel_s->step;
+	/* For v4l2 val is the default value */
+	v4l2_s->val = channel_s->max;
+}
+
+static int gb_lights_light_v4l2_register(struct gb_light *light)
+{
+	struct gb_connection *connection = get_conn_from_light(light);
+	struct device *dev = &connection->dev;
+	struct v4l2_flash_config *sd_cfg;
+	struct led_classdev_flash *fled;
+	struct led_classdev_flash *iled = NULL;
+	struct gb_channel *channel_torch, *channel_ind, *channel_flash;
+	int ret = 0;
+
+	sd_cfg = kcalloc(1, sizeof(*sd_cfg), GFP_KERNEL);
+	if (!sd_cfg)
+		return -ENOMEM;
+
+	channel_torch = get_channel_from_mode(light, GB_CHANNEL_MODE_TORCH);
+	if (channel_torch)
+		__gb_lights_channel_v4l2_config(&channel_torch->intensity_uA,
+						&sd_cfg->torch_intensity);
+
+	channel_ind = get_channel_from_mode(light, GB_CHANNEL_MODE_INDICATOR);
+	if (channel_ind) {
+		__gb_lights_channel_v4l2_config(&channel_ind->intensity_uA,
+						&sd_cfg->indicator_intensity);
+		iled = &channel_ind->fled;
+	}
+
+	channel_flash = get_channel_from_mode(light, GB_CHANNEL_MODE_FLASH);
+	WARN_ON(!channel_flash);
+
+	fled = &channel_flash->fled;
+
+	snprintf(sd_cfg->dev_name, sizeof(sd_cfg->dev_name), "%s", light->name);
+
+	/* Set the possible values to faults, in our case all faults */
+	sd_cfg->flash_faults = LED_FAULT_OVER_VOLTAGE | LED_FAULT_TIMEOUT |
+		LED_FAULT_OVER_TEMPERATURE | LED_FAULT_SHORT_CIRCUIT |
+		LED_FAULT_OVER_CURRENT | LED_FAULT_INDICATOR |
+		LED_FAULT_UNDER_VOLTAGE | LED_FAULT_INPUT_VOLTAGE |
+		LED_FAULT_LED_OVER_TEMPERATURE;
+
+	light->v4l2_flash = v4l2_flash_init(dev, NULL, fled, iled,
+					    NULL, sd_cfg);
+	if (IS_ERR_OR_NULL(light->v4l2_flash)) {
+		ret = PTR_ERR(light->v4l2_flash);
+		goto out_free;
+	}
+
+	return ret;
+
+out_free:
+	kfree(sd_cfg);
+	return ret;
+}
+
+static void gb_lights_light_v4l2_unregister(struct gb_light *light)
+{
+	v4l2_flash_release(light->v4l2_flash);
+}
+#else
+static int gb_lights_light_v4l2_register(struct gb_light *light)
+{
+	struct gb_connection *connection = get_conn_from_light(light);
+
+	dev_err(&connection->dev, "no support for v4l2 subdevices\n");
+	return 0;
+}
+
+static void gb_lights_light_v4l2_unregister(struct gb_light *light)
+{
+}
+#endif
+
+#ifdef LED_HAVE_FLASH
+/* Flash specific operations */
+static int gb_lights_flash_intensity_set(struct led_classdev_flash *fcdev,
+					 u32 brightness)
+{
+	struct gb_channel *channel = container_of(fcdev, struct gb_channel,
+						  fled);
+	int ret;
+
+	ret = __gb_lights_flash_intensity_set(channel, brightness);
+	if (ret < 0)
+		return ret;
+
+	fcdev->brightness.val = brightness;
+
+	return 0;
+}
+
+static int gb_lights_flash_intensity_get(struct led_classdev_flash *fcdev,
+					 u32 *brightness)
+{
+	*brightness = fcdev->brightness.val;
+
+	return 0;
+}
+
+static int gb_lights_flash_strobe_set(struct led_classdev_flash *fcdev,
+				      bool state)
+{
+	struct gb_channel *channel = container_of(fcdev, struct gb_channel,
+						  fled);
+	struct gb_connection *connection = get_conn_from_channel(channel);
+	struct gb_lights_set_flash_strobe_request req;
+	int ret;
+
+	if (channel->releasing)
+		return -ESHUTDOWN;
+
+	req.light_id = channel->light->id;
+	req.channel_id = channel->id;
+	req.state = state ? 1 : 0;
+
+	ret = gb_operation_sync(connection, GB_LIGHTS_TYPE_SET_FLASH_STROBE,
+				&req, sizeof(req), NULL, 0);
+	if (ret < 0)
+		return ret;
+	channel->strobe_state = state;
+
+	return 0;
+}
+
+static int gb_lights_flash_strobe_get(struct led_classdev_flash *fcdev,
+				      bool *state)
+{
+	struct gb_channel *channel = container_of(fcdev, struct gb_channel,
+						  fled);
+
+	*state = channel->strobe_state;
+	return 0;
+}
+
+static int gb_lights_flash_timeout_set(struct led_classdev_flash *fcdev,
+				       u32 timeout)
+{
+	struct gb_channel *channel = container_of(fcdev, struct gb_channel,
+						  fled);
+	struct gb_connection *connection = get_conn_from_channel(channel);
+	struct gb_lights_set_flash_timeout_request req;
+	int ret;
+
+	if (channel->releasing)
+		return -ESHUTDOWN;
+
+	req.light_id = channel->light->id;
+	req.channel_id = channel->id;
+	req.timeout_us = cpu_to_le32(timeout);
+
+	ret = gb_operation_sync(connection, GB_LIGHTS_TYPE_SET_FLASH_TIMEOUT,
+				&req, sizeof(req), NULL, 0);
+	if (ret < 0)
+		return ret;
+	fcdev->timeout.val = timeout;
+
+	return 0;
+}
+
+static int gb_lights_flash_fault_get(struct led_classdev_flash *fcdev,
+				     u32 *fault)
+{
+	struct gb_channel *channel = container_of(fcdev, struct gb_channel,
+						  fled);
+	struct gb_connection *connection = get_conn_from_channel(channel);
+	struct gb_lights_get_flash_fault_request req;
+	struct gb_lights_get_flash_fault_response resp;
+	int ret;
+
+	if (channel->releasing)
+		return -ESHUTDOWN;
+
+	req.light_id = channel->light->id;
+	req.channel_id = channel->id;
+
+	ret = gb_operation_sync(connection, GB_LIGHTS_TYPE_GET_FLASH_FAULT,
+				&req, sizeof(req), &resp, sizeof(resp));
+	if (ret < 0)
+		return ret;
+
+	*fault = le32_to_cpu(resp.fault);
+
+	return 0;
+}
+
+static const struct led_flash_ops gb_lights_flash_ops = {
+	.flash_brightness_set	= gb_lights_flash_intensity_set,
+	.flash_brightness_get	= gb_lights_flash_intensity_get,
+	.strobe_set		= gb_lights_flash_strobe_set,
+	.strobe_get		= gb_lights_flash_strobe_get,
+	.timeout_set		= gb_lights_flash_timeout_set,
+	.fault_get		= gb_lights_flash_fault_get,
+};
+
+static int __gb_lights_channel_torch_attach(struct gb_channel *channel,
+					    struct gb_channel *channel_torch)
+{
+	char *name;
+
+	/* we can only attach torch to a flash channel */
+	if (!(channel->mode & GB_CHANNEL_MODE_FLASH))
+		return 0;
+
+	/* Move torch brightness to the destination */
+	channel->led->max_brightness = channel_torch->led->max_brightness;
+
+	/* append mode name to flash name */
+	name = kasprintf(GFP_KERNEL, "%s_%s", channel->led->name,
+			 channel_torch->mode_name);
+	if (!name)
+		return -ENOMEM;
+	kfree(channel->led->name);
+	channel->led->name = name;
+
+	/* free original torch channel resources */
+	gb_lights_channel_free(channel_torch);
+
+	channel_torch->led = channel->led;
+
+	return 0;
+}
+
+static int __gb_lights_flash_led_register(struct gb_channel *channel)
+{
+	struct gb_connection *connection = get_conn_from_channel(channel);
+	struct led_classdev_flash *fled = &channel->fled;
+	struct led_flash_setting *fset;
+	struct gb_channel *channel_torch;
+	int ret;
+
+	fled->ops = &gb_lights_flash_ops;
+
+	fled->led_cdev.flags |= LED_DEV_CAP_FLASH;
+
+	fset = &fled->brightness;
+	fset->min = channel->intensity_uA.min;
+	fset->max = channel->intensity_uA.max;
+	fset->step = channel->intensity_uA.step;
+
+	/* Only the flash mode have the timeout constraints settings */
+	if (channel->mode & GB_CHANNEL_MODE_FLASH) {
+		fset = &fled->timeout;
+		fset->min = channel->timeout_us.min;
+		fset->max = channel->timeout_us.max;
+		fset->step = channel->timeout_us.step;
+	}
+
+	/*
+	 * If light have torch mode channel, this channel will be the led
+	 * classdev of the registered above flash classdev
+	 */
+	channel_torch = get_channel_from_mode(channel->light,
+					      GB_CHANNEL_MODE_TORCH);
+	if (channel_torch) {
+		ret = __gb_lights_channel_torch_attach(channel, channel_torch);
+		if (ret < 0)
+			goto fail;
+	}
+
+	ret = led_classdev_flash_register(&connection->bundle->intf->dev,
+					  fled);
+	if (ret < 0)
+		goto fail;
+
+	channel->is_registered = true;
+	return 0;
+fail:
+	channel->led = NULL;
+	return ret;
+}
+
+static void __gb_lights_flash_led_unregister(struct gb_channel *channel)
+{
+	if (!channel->is_registered)
+		return;
+
+	led_classdev_flash_unregister(&channel->fled);
+}
+
+static int gb_lights_channel_flash_config(struct gb_channel *channel)
+{
+	struct gb_connection *connection = get_conn_from_channel(channel);
+	struct gb_lights_get_channel_flash_config_request req;
+	struct gb_lights_get_channel_flash_config_response conf;
+	struct led_flash_setting *fset;
+	int ret;
+
+	req.light_id = channel->light->id;
+	req.channel_id = channel->id;
+
+	ret = gb_operation_sync(connection,
+				GB_LIGHTS_TYPE_GET_CHANNEL_FLASH_CONFIG,
+				&req, sizeof(req), &conf, sizeof(conf));
+	if (ret < 0)
+		return ret;
+
+	/*
+	 * Intensity constraints for flash related modes: flash, torch,
+	 * indicator.  They will be needed for v4l2 registration.
+	 */
+	fset = &channel->intensity_uA;
+	fset->min = le32_to_cpu(conf.intensity_min_uA);
+	fset->max = le32_to_cpu(conf.intensity_max_uA);
+	fset->step = le32_to_cpu(conf.intensity_step_uA);
+
+	/*
+	 * On flash type, max brightness is set as the number of intensity steps
+	 * available.
+	 */
+	channel->led->max_brightness = (fset->max - fset->min) / fset->step;
+
+	/* Only the flash mode have the timeout constraints settings */
+	if (channel->mode & GB_CHANNEL_MODE_FLASH) {
+		fset = &channel->timeout_us;
+		fset->min = le32_to_cpu(conf.timeout_min_us);
+		fset->max = le32_to_cpu(conf.timeout_max_us);
+		fset->step = le32_to_cpu(conf.timeout_step_us);
+	}
+
+	return 0;
+}
+#else
+static int gb_lights_channel_flash_config(struct gb_channel *channel)
+{
+	struct gb_connection *connection = get_conn_from_channel(channel);
+
+	dev_err(&connection->dev, "no support for flash devices\n");
+	return 0;
+}
+
+static int __gb_lights_flash_led_register(struct gb_channel *channel)
+{
+	return 0;
+}
+
+static void __gb_lights_flash_led_unregister(struct gb_channel *channel)
+{
+}
+
+#endif /* LED_HAVE_FLASH */
+
+static int __gb_lights_led_register(struct gb_channel *channel)
+{
+	struct gb_connection *connection = get_conn_from_channel(channel);
+	struct led_classdev *cdev = get_channel_cdev(channel);
+	int ret;
+
+	ret = led_classdev_register(&connection->bundle->intf->dev,
+				    cdev);
+	if (ret < 0)
+		channel->led = NULL;
+	else
+		channel->is_registered = true;
+	return ret;
+}
+
+static int gb_lights_channel_register(struct gb_channel *channel)
+{
+	/* Normal LED channel, just register in led classdev and we are done */
+	if (!is_channel_flash(channel))
+		return __gb_lights_led_register(channel);
+
+	/*
+	 * Flash Type need more work, register flash classdev, indicator as
+	 * flash classdev, torch will be led classdev of the flash classdev.
+	 */
+	if (!(channel->mode & GB_CHANNEL_MODE_TORCH))
+		return __gb_lights_flash_led_register(channel);
+
+	return 0;
+}
+
+static void __gb_lights_led_unregister(struct gb_channel *channel)
+{
+	struct led_classdev *cdev = get_channel_cdev(channel);
+
+	if (!channel->is_registered)
+		return;
+
+	led_classdev_unregister(cdev);
+	channel->led = NULL;
+}
+
+static void gb_lights_channel_unregister(struct gb_channel *channel)
+{
+	/* The same as register, handle channels differently */
+	if (!is_channel_flash(channel)) {
+		__gb_lights_led_unregister(channel);
+		return;
+	}
+
+	if (channel->mode & GB_CHANNEL_MODE_TORCH)
+		__gb_lights_led_unregister(channel);
+	else
+		__gb_lights_flash_led_unregister(channel);
+}
+
+static int gb_lights_channel_config(struct gb_light *light,
+				    struct gb_channel *channel)
+{
+	struct gb_lights_get_channel_config_response conf;
+	struct gb_lights_get_channel_config_request req;
+	struct gb_connection *connection = get_conn_from_light(light);
+	struct led_classdev *cdev = get_channel_cdev(channel);
+	char *name;
+	int ret;
+
+	req.light_id = light->id;
+	req.channel_id = channel->id;
+
+	ret = gb_operation_sync(connection, GB_LIGHTS_TYPE_GET_CHANNEL_CONFIG,
+				&req, sizeof(req), &conf, sizeof(conf));
+	if (ret < 0)
+		return ret;
+
+	channel->light = light;
+	channel->mode = le32_to_cpu(conf.mode);
+	channel->flags = le32_to_cpu(conf.flags);
+	channel->color = le32_to_cpu(conf.color);
+	channel->color_name = kstrndup(conf.color_name, NAMES_MAX, GFP_KERNEL);
+	if (!channel->color_name)
+		return -ENOMEM;
+	channel->mode_name = kstrndup(conf.mode_name, NAMES_MAX, GFP_KERNEL);
+	if (!channel->mode_name)
+		return -ENOMEM;
+
+	channel->led = cdev;
+
+	name = kasprintf(GFP_KERNEL, "%s:%s:%s", light->name,
+			 channel->color_name, channel->mode_name);
+	if (!name)
+		return -ENOMEM;
+
+	cdev->name = name;
+
+	cdev->max_brightness = conf.max_brightness;
+
+	ret = channel_attr_groups_set(channel, cdev);
+	if (ret < 0)
+		return ret;
+
+	gb_lights_led_operations_set(channel, cdev);
+
+	/*
+	 * If it is not a flash related channel (flash, torch or indicator) we
+	 * are done here. If not, continue and fetch flash related
+	 * configurations.
+	 */
+	if (!is_channel_flash(channel))
+		return ret;
+
+	light->has_flash = true;
+
+	ret = gb_lights_channel_flash_config(channel);
+	if (ret < 0)
+		return ret;
+
+	return ret;
+}
+
+static int gb_lights_light_config(struct gb_lights *glights, u8 id)
+{
+	struct gb_light *light = &glights->lights[id];
+	struct gb_lights_get_light_config_request req;
+	struct gb_lights_get_light_config_response conf;
+	int ret;
+	int i;
+
+	light->glights = glights;
+	light->id = id;
+
+	req.id = id;
+
+	ret = gb_operation_sync(glights->connection,
+				GB_LIGHTS_TYPE_GET_LIGHT_CONFIG,
+				&req, sizeof(req), &conf, sizeof(conf));
+	if (ret < 0)
+		return ret;
+
+	if (!conf.channel_count)
+		return -EINVAL;
+	if (!strlen(conf.name))
+		return -EINVAL;
+
+	light->channels_count = conf.channel_count;
+	light->name = kstrndup(conf.name, NAMES_MAX, GFP_KERNEL);
+
+	light->channels = kzalloc(light->channels_count *
+				  sizeof(struct gb_channel), GFP_KERNEL);
+	if (!light->channels)
+		return -ENOMEM;
+
+	/* First we collect all the configurations for all channels */
+	for (i = 0; i < light->channels_count; i++) {
+		light->channels[i].id = i;
+		ret = gb_lights_channel_config(light, &light->channels[i]);
+		if (ret < 0)
+			return ret;
+	}
+
+	/*
+	 * Then, if everything went ok in getting configurations, we register
+	 * the classdev, flash classdev and v4l2 subsystem, if a flash device is
+	 * found.
+	 */
+	for (i = 0; i < light->channels_count; i++) {
+		ret = gb_lights_channel_register(&light->channels[i]);
+		if (ret < 0)
+			return ret;
+	}
+
+	if (light->has_flash) {
+		ret = gb_lights_light_v4l2_register(light);
+		if (ret < 0)
+			return ret;
+	}
+
+	return 0;
+}
+
+static void gb_lights_channel_free(struct gb_channel *channel)
+{
+	if (&channel->work_brightness_set)
+		flush_work(&channel->work_brightness_set);
+	kfree(channel->attrs);
+	kfree(channel->attr_group);
+	kfree(channel->attr_groups);
+	kfree(channel->color_name);
+	kfree(channel->mode_name);
+}
+
+static void gb_lights_channel_release(struct gb_channel *channel)
+{
+	if (!channel)
+		return;
+
+	channel->releasing = true;
+
+	gb_lights_channel_unregister(channel);
+
+	gb_lights_channel_free(channel);
+}
+
+static void gb_lights_light_release(struct gb_light *light)
+{
+	int i;
+	int count;
+
+	if (!light)
+		return;
+
+	count = light->channels_count;
+
+	if (light->has_flash)
+		gb_lights_light_v4l2_unregister(light);
+
+	for (i = 0; i < count; i++) {
+		gb_lights_channel_release(&light->channels[i]);
+		light->channels_count--;
+	}
+	kfree(light->channels);
+	kfree(light->name);
+}
+
+static void gb_lights_release(struct gb_lights *glights)
+{
+	int i;
+
+	if (!glights)
+		return;
+
+	mutex_lock(&glights->lights_lock);
+	if (!glights->lights)
+		goto free_glights;
+
+	for (i = 0; i < glights->lights_count; i++)
+		gb_lights_light_release(&glights->lights[i]);
+
+	kfree(glights->lights);
+
+free_glights:
+	mutex_unlock(&glights->lights_lock);
+	mutex_destroy(&glights->lights_lock);
+	kfree(glights);
+}
+
+static int gb_lights_get_count(struct gb_lights *glights)
+{
+	struct gb_lights_get_lights_response resp;
+	int ret;
+
+	ret = gb_operation_sync(glights->connection, GB_LIGHTS_TYPE_GET_LIGHTS,
+				NULL, 0, &resp, sizeof(resp));
+	if (ret < 0)
+		return ret;
+
+	if (!resp.lights_count)
+		return -EINVAL;
+
+	glights->lights_count = resp.lights_count;
+
+	return 0;
+}
+
+static int gb_lights_setup(struct gb_lights *glights)
+{
+	struct gb_connection *connection = glights->connection;
+	int ret;
+	int i;
+
+	mutex_lock(&glights->lights_lock);
+	ret = gb_lights_get_count(glights);
+	if (ret < 0)
+		goto out;
+
+	glights->lights = kzalloc(glights->lights_count *
+				  sizeof(struct gb_light), GFP_KERNEL);
+	if (!glights->lights) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	for (i = 0; i < glights->lights_count; i++) {
+		ret = gb_lights_light_config(glights, i);
+		if (ret < 0) {
+			dev_err(&connection->dev,
+				"Fail to configure lights device\n");
+			goto out;
+		}
+	}
+
+out:
+	mutex_unlock(&glights->lights_lock);
+	return ret;
+}
+
+static int gb_lights_event_recv(u8 type, struct gb_operation *op)
+{
+	struct gb_connection *connection = op->connection;
+	struct gb_lights *glights = connection->private;
+	struct gb_message *request;
+	struct gb_lights_event_request *payload;
+	int ret =  0;
+	u8 light_id;
+	u8 event;
+
+	if (type != GB_LIGHTS_TYPE_EVENT) {
+		dev_err(&connection->dev,
+			"Unsupported unsolicited event: %u\n", type);
+		return -EINVAL;
+	}
+
+	request = op->request;
+
+	if (request->payload_size < sizeof(*payload)) {
+		dev_err(&connection->dev,
+			"Wrong event size received (%zu < %zu)\n",
+			request->payload_size, sizeof(*payload));
+		return -EINVAL;
+	}
+
+	payload = request->payload;
+	light_id = payload->light_id;
+
+	if (light_id >= glights->lights_count || !&glights->lights[light_id]) {
+		dev_err(&connection->dev,
+			"Event received for unconfigured light id: %d\n",
+			light_id);
+		return -EINVAL;
+	}
+
+	event = payload->event;
+
+	if (event & GB_LIGHTS_LIGHT_CONFIG) {
+		mutex_lock(&glights->lights_lock);
+		gb_lights_light_release(&glights->lights[light_id]);
+		ret = gb_lights_light_config(glights, light_id);
+		if (ret < 0)
+			gb_lights_light_release(&glights->lights[light_id]);
+		mutex_unlock(&glights->lights_lock);
+	}
+
+	return ret;
+}
+
+static int gb_lights_connection_init(struct gb_connection *connection)
+{
+	struct gb_lights *glights;
+	int ret;
+
+	glights = kzalloc(sizeof(*glights), GFP_KERNEL);
+	if (!glights)
+		return -ENOMEM;
+
+	glights->connection = connection;
+	connection->private = glights;
+
+	mutex_init(&glights->lights_lock);
+
+	/*
+	 * Setup all the lights devices over this connection, if anything goes
+	 * wrong tear down all lights
+	 */
+	ret = gb_lights_setup(glights);
+	if (ret < 0)
+		goto out;
+
+	return 0;
+
+out:
+	gb_lights_release(glights);
+	return ret;
+}
+
+static void gb_lights_connection_exit(struct gb_connection *connection)
+{
+	struct gb_lights *glights = connection->private;
+
+	gb_lights_release(glights);
+}
+
+static struct gb_protocol lights_protocol = {
+	.name			= "lights",
+	.id			= GREYBUS_PROTOCOL_LIGHTS,
+	.major			= GB_LIGHTS_VERSION_MAJOR,
+	.minor			= GB_LIGHTS_VERSION_MINOR,
+	.connection_init	= gb_lights_connection_init,
+	.connection_exit	= gb_lights_connection_exit,
+	.request_recv		= gb_lights_event_recv,
+};
+
+gb_protocol_driver(&lights_protocol);
+
+MODULE_LICENSE("GPL v2");
