commit c2312ff575fcaed96889d5bb5392afcc604c9442
Merge: a3975dea1696 9cb1fd0efd19
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon May 25 09:11:19 2020 +0200

    Merge 5.7-rc7 into staging-next
    
    We need the staging/iio fixes in here as well.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 6064aeefa88c7c1bbb44737db55c5ff83f47718f
Author: Johan Hovold <johan@kernel.org>
Date:   Thu May 14 09:05:48 2020 +0200

    staging: greybus: uart: replace driver line-coding struct
    
    Drop the driver version of the line-coding request and use the protocol
    definition directly as was originally intended instead.
    
    This specifically avoids having the two versions of what is supposed to
    be the same struct ever getting out of sync.
    
    Note that this has in fact already happened once when the protocol
    definition had its implicit padding removed while the driver struct
    wasn't updated. The fact that we used the size of the then larger driver
    struct when memcpying its content to the stack didn't exactly make
    things better. A later addition of a flow-control field incidentally
    made the structures match again.
    
    Signed-off-by: Johan Hovold <johan@kernel.org>
    Link: https://lore.kernel.org/r/20200514070548.4423-1-johan@kernel.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/uart.c b/drivers/staging/greybus/uart.c
index 55c51143bb09..84de56800a21 100644
--- a/drivers/staging/greybus/uart.c
+++ b/drivers/staging/greybus/uart.c
@@ -40,14 +40,6 @@
 #define GB_UART_FIRMWARE_CREDITS	4096
 #define GB_UART_CREDIT_WAIT_TIMEOUT_MSEC	10000
 
-struct gb_tty_line_coding {
-	__le32	rate;
-	__u8	format;
-	__u8	parity;
-	__u8	data_bits;
-	__u8	flow_control;
-};
-
 struct gb_tty {
 	struct gbphy_device *gbphy_dev;
 	struct tty_port port;
@@ -66,7 +58,7 @@ struct gb_tty {
 	struct mutex mutex;
 	u8 ctrlin;	/* input control lines */
 	u8 ctrlout;	/* output control lines */
-	struct gb_tty_line_coding line_coding;
+	struct gb_uart_set_line_coding_request line_coding;
 	struct work_struct tx_work;
 	struct kfifo write_fifo;
 	bool close_pending;
@@ -288,12 +280,9 @@ static void  gb_uart_tx_write_work(struct work_struct *work)
 
 static int send_line_coding(struct gb_tty *tty)
 {
-	struct gb_uart_set_line_coding_request request;
-
-	memcpy(&request, &tty->line_coding,
-	       sizeof(tty->line_coding));
 	return gb_operation_sync(tty->connection, GB_UART_TYPE_SET_LINE_CODING,
-				 &request, sizeof(request), NULL, 0);
+				 &tty->line_coding, sizeof(tty->line_coding),
+				 NULL, 0);
 }
 
 static int send_control(struct gb_tty *gb_tty, u8 control)
@@ -493,9 +482,9 @@ static int gb_tty_break_ctl(struct tty_struct *tty, int state)
 static void gb_tty_set_termios(struct tty_struct *tty,
 			       struct ktermios *termios_old)
 {
+	struct gb_uart_set_line_coding_request newline;
 	struct gb_tty *gb_tty = tty->driver_data;
 	struct ktermios *termios = &tty->termios;
-	struct gb_tty_line_coding newline;
 	u8 newctrl = gb_tty->ctrlout;
 
 	newline.rate = cpu_to_le32(tty_get_baud_rate(tty));

commit 34625c1931f8204c234c532b446b9f53c69f4b68
Author: Oscar Carter <oscar.carter@gmx.com>
Date:   Sun May 10 12:14:26 2020 +0200

    staging: greybus: Fix uninitialized scalar variable
    
    In the "gb_tty_set_termios" function the "newline" variable is declared
    but not initialized. So the "flow_control" member is not initialized and
    the OR / AND operations with itself results in an undefined value in
    this member.
    
    The purpose of the code is to set the flow control type, so remove the
    OR / AND self operator and set the value directly.
    
    Addresses-Coverity-ID: 1374016 ("Uninitialized scalar variable")
    Fixes: e55c25206d5c9 ("greybus: uart: Handle CRTSCTS flag in termios")
    Signed-off-by: Oscar Carter <oscar.carter@gmx.com>
    Cc: stable <stable@vger.kernel.org>
    Link: https://lore.kernel.org/r/20200510101426.23631-1-oscar.carter@gmx.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/uart.c b/drivers/staging/greybus/uart.c
index 55c51143bb09..4ffb334cd5cd 100644
--- a/drivers/staging/greybus/uart.c
+++ b/drivers/staging/greybus/uart.c
@@ -537,9 +537,9 @@ static void gb_tty_set_termios(struct tty_struct *tty,
 	}
 
 	if (C_CRTSCTS(tty) && C_BAUD(tty) != B0)
-		newline.flow_control |= GB_SERIAL_AUTO_RTSCTS_EN;
+		newline.flow_control = GB_SERIAL_AUTO_RTSCTS_EN;
 	else
-		newline.flow_control &= ~GB_SERIAL_AUTO_RTSCTS_EN;
+		newline.flow_control = 0;
 
 	if (memcmp(&gb_tty->line_coding, &newline, sizeof(newline))) {
 		memcpy(&gb_tty->line_coding, &newline, sizeof(newline));

commit ec0ad868173da8a75121f9dc116a5d5478ff614d
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Sun Aug 25 07:54:27 2019 +0200

    staging: greybus: move core include files to include/linux/greybus/
    
    With the goal of moving the core of the greybus code out of staging, the
    include files need to be moved to include/linux/greybus.h and
    include/linux/greybus/
    
    Cc: Vaibhav Hiremath <hvaibhav.linux@gmail.com>
    Cc: Johan Hovold <johan@kernel.org>
    Cc: Vaibhav Agarwal <vaibhav.sr@gmail.com>
    Cc: Rui Miguel Silva <rmfrfs@gmail.com>
    Cc: David Lin <dtwlin@gmail.com>
    Cc: "Bryan O'Donoghue" <pure.logic@nexus-software.ie>
    Cc: greybus-dev@lists.linaro.org
    Cc: devel@driverdev.osuosl.org
    Acked-by: Mark Greer <mgreer@animalcreek.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Acked-by: Alex Elder <elder@kernel.org>
    Link: https://lore.kernel.org/r/20190825055429.18547-8-gregkh@linuxfoundation.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/uart.c b/drivers/staging/greybus/uart.c
index b3bffe91ae99..55c51143bb09 100644
--- a/drivers/staging/greybus/uart.c
+++ b/drivers/staging/greybus/uart.c
@@ -28,8 +28,8 @@
 #include <linux/kfifo.h>
 #include <linux/workqueue.h>
 #include <linux/completion.h>
+#include <linux/greybus.h>
 
-#include "greybus.h"
 #include "gbphy.h"
 
 #define GB_NUM_MINORS	16	/* 16 is more than enough */

commit 327f27696303127e207e1379330b65a1268e0063
Author: Ioannis Valasakis <code@wizofe.uk>
Date:   Fri Nov 9 13:54:23 2018 +0000

    staging: greybus: remove space before tab
    
    Remove extra space before a tab character.
    Reported by checkpatch.
    
    Signed-off-by: Ioannis Valasakis <code@wizofe.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/uart.c b/drivers/staging/greybus/uart.c
index 3313cb0b60af..b3bffe91ae99 100644
--- a/drivers/staging/greybus/uart.c
+++ b/drivers/staging/greybus/uart.c
@@ -805,8 +805,8 @@ static const struct tty_operations gb_ops = {
 	.tiocmget =		gb_tty_tiocmget,
 	.tiocmset =		gb_tty_tiocmset,
 	.get_icount =		gb_tty_get_icount,
-	.set_serial = 		set_serial_info,
-	.get_serial = 		get_serial_info,
+	.set_serial =		set_serial_info,
+	.get_serial =		get_serial_info,
 };
 
 static const struct tty_port_operations gb_port_ops = {

commit 0aad5ad563c878fcb981cdbb52b4221bc0036e59
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Tue Sep 11 21:58:45 2018 -0400

    greybus/uart: switch to ->[sg]et_serial()
    
    Reviewed-by: Johan Hovold <johan@kernel.org>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/drivers/staging/greybus/uart.c b/drivers/staging/greybus/uart.c
index 8a006323c3c1..3313cb0b60af 100644
--- a/drivers/staging/greybus/uart.c
+++ b/drivers/staging/greybus/uart.c
@@ -616,40 +616,33 @@ static void gb_tty_unthrottle(struct tty_struct *tty)
 	}
 }
 
-static int get_serial_info(struct gb_tty *gb_tty,
-			   struct serial_struct __user *info)
+static int get_serial_info(struct tty_struct *tty,
+			   struct serial_struct *ss)
 {
-	struct serial_struct tmp;
-
-	memset(&tmp, 0, sizeof(tmp));
-	tmp.type = PORT_16550A;
-	tmp.line = gb_tty->minor;
-	tmp.xmit_fifo_size = 16;
-	tmp.baud_base = 9600;
-	tmp.close_delay = gb_tty->port.close_delay / 10;
-	tmp.closing_wait =
+	struct gb_tty *gb_tty = tty->driver_data;
+
+	ss->type = PORT_16550A;
+	ss->line = gb_tty->minor;
+	ss->xmit_fifo_size = 16;
+	ss->baud_base = 9600;
+	ss->close_delay = gb_tty->port.close_delay / 10;
+	ss->closing_wait =
 		gb_tty->port.closing_wait == ASYNC_CLOSING_WAIT_NONE ?
 		ASYNC_CLOSING_WAIT_NONE : gb_tty->port.closing_wait / 10;
-
-	if (copy_to_user(info, &tmp, sizeof(tmp)))
-		return -EFAULT;
 	return 0;
 }
 
-static int set_serial_info(struct gb_tty *gb_tty,
-			   struct serial_struct __user *newinfo)
+static int set_serial_info(struct tty_struct *tty,
+			   struct serial_struct *ss)
 {
-	struct serial_struct new_serial;
+	struct gb_tty *gb_tty = tty->driver_data;
 	unsigned int closing_wait;
 	unsigned int close_delay;
 	int retval = 0;
 
-	if (copy_from_user(&new_serial, newinfo, sizeof(new_serial)))
-		return -EFAULT;
-
-	close_delay = new_serial.close_delay * 10;
-	closing_wait = new_serial.closing_wait == ASYNC_CLOSING_WAIT_NONE ?
-			ASYNC_CLOSING_WAIT_NONE : new_serial.closing_wait * 10;
+	close_delay = ss->close_delay * 10;
+	closing_wait = ss->closing_wait == ASYNC_CLOSING_WAIT_NONE ?
+			ASYNC_CLOSING_WAIT_NONE : ss->closing_wait * 10;
 
 	mutex_lock(&gb_tty->port.mutex);
 	if (!capable(CAP_SYS_ADMIN)) {
@@ -728,12 +721,6 @@ static int gb_tty_ioctl(struct tty_struct *tty, unsigned int cmd,
 	struct gb_tty *gb_tty = tty->driver_data;
 
 	switch (cmd) {
-	case TIOCGSERIAL:
-		return get_serial_info(gb_tty,
-				       (struct serial_struct __user *)arg);
-	case TIOCSSERIAL:
-		return set_serial_info(gb_tty,
-				       (struct serial_struct __user *)arg);
 	case TIOCMIWAIT:
 		return wait_serial_change(gb_tty, arg);
 	}
@@ -818,6 +805,8 @@ static const struct tty_operations gb_ops = {
 	.tiocmget =		gb_tty_tiocmget,
 	.tiocmset =		gb_tty_tiocmset,
 	.get_icount =		gb_tty_get_icount,
+	.set_serial = 		set_serial_info,
+	.get_serial = 		get_serial_info,
 };
 
 static const struct tty_port_operations gb_port_ops = {

commit 863dbc52e7f0e5acd7b4883f3933543a81c474c7
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Nov 7 14:58:42 2017 +0100

    staging: greybus: Remove redundant license text
    
    Now that the SPDX tag is in all greybus files, that identifies the
    license in a specific and legally-defined manner.  So the extra GPL text
    wording can be removed as it is no longer needed at all.
    
    This is done on a quest to remove the 700+ different ways that files in
    the kernel describe the GPL license text.  And there's unneeded stuff
    like the address (sometimes incorrect) for the FSF which is never
    needed.
    
    No copyright headers or other non-license-description text was removed.
    
    Cc: Vaibhav Hiremath <hvaibhav.linux@gmail.com>
    Reviewed-by: Alex Elder <elder@linaro.org>
    Acked-by: Vaibhav Agarwal <vaibhav.sr@gmail.com>
    Acked-by: David Lin <dtwlin@gmail.com>
    Acked-by: Johan Hovold <johan@kernel.org>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Acked-by: Mark Greer <mgreer@animalcreek.com>
    Acked-by: Rui Miguel Silva <rmfrfs@gmail.com>
    Acked-by: "Bryan O'Donoghue" <pure.logic@nexus-software.ie>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/uart.c b/drivers/staging/greybus/uart.c
index c4126c480c3c..8a006323c3c1 100644
--- a/drivers/staging/greybus/uart.c
+++ b/drivers/staging/greybus/uart.c
@@ -5,8 +5,6 @@
  * Copyright 2014 Google Inc.
  * Copyright 2014 Linaro Ltd.
  *
- * Released under the GPLv2 only.
- *
  * Heavily based on drivers/usb/class/cdc-acm.c and
  * drivers/usb/serial/usb-serial.c.
  */

commit eb50fd3a22c770f36be275295b782f3ea52e3215
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Nov 7 14:58:41 2017 +0100

    staging: greybus: add SPDX identifiers to all greybus driver files
    
    It's good to have SPDX identifiers in all files to make it easier to
    audit the kernel tree for correct licenses.
    
    Update the drivers/staging/greybus files files with the correct SPDX
    license identifier based on the license text in the file itself.  The
    SPDX identifier is a legally binding shorthand, which can be used
    instead of the full boiler plate text.
    
    This work is based on a script and data from Thomas Gleixner, Philippe
    Ombredanne, and Kate Stewart.
    
    Cc: Vaibhav Hiremath <hvaibhav.linux@gmail.com>
    Cc: "Bryan O'Donoghue" <pure.logic@nexus-software.ie>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: Philippe Ombredanne <pombredanne@nexb.com>
    Acked-by: Vaibhav Agarwal <vaibhav.sr@gmail.com>
    Acked-by: David Lin <dtwlin@gmail.com>
    Reviewed-by: Alex Elder <elder@linaro.org>
    Acked-by: Johan Hovold <johan@kernel.org>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Acked-by: Mark Greer <mgreer@animalcreek.com>
    Acked-by: Rui Miguel Silva <rmfrfs@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/uart.c b/drivers/staging/greybus/uart.c
index c6d01b800d3c..c4126c480c3c 100644
--- a/drivers/staging/greybus/uart.c
+++ b/drivers/staging/greybus/uart.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * UART driver for the Greybus "generic" UART module.
  *

commit 4330887f2e7406b671549db58f3cf7d76baa52cd
Author: Darryl T. Agostinelli <dagostinelli@gmail.com>
Date:   Wed Apr 12 20:36:15 2017 -0500

    staging: greybus: uart.c: Remove include linux/serial.h
    
    $ make includecheck | grep staging
    ./drivers/staging/greybus/uart.c: linux/serial.h is included more than once.
    
    Signed-off-by: Darryl T. Agostinelli <dagostinelli@gmail.com>
    Reviewed-by: Alex Elder <elder@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/uart.c b/drivers/staging/greybus/uart.c
index b72693e300c1..c6d01b800d3c 100644
--- a/drivers/staging/greybus/uart.c
+++ b/drivers/staging/greybus/uart.c
@@ -23,7 +23,6 @@
 #include <linux/serial.h>
 #include <linux/tty_driver.h>
 #include <linux/tty_flip.h>
-#include <linux/serial.h>
 #include <linux/idr.h>
 #include <linux/fs.h>
 #include <linux/kdev_t.h>

commit 4452b090a18ead601e9e7c543c2f4acd5821d888
Author: simran singhal <singhalsimran0@gmail.com>
Date:   Sat Mar 4 23:11:00 2017 +0530

    staging: greybus: Replace "is is" with "is"
    
    This patch replace "is is " with "is". The replacement couldn't be
    automated because sometimes the first "is" was meant to be another
    word.
    
    Signed-off-by: simran singhal <singhalsimran0@gmail.com>
    Acked-by: Julia Lawall <julia.lawall@lip6.fr>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/uart.c b/drivers/staging/greybus/uart.c
index 43255e2e9276..b72693e300c1 100644
--- a/drivers/staging/greybus/uart.c
+++ b/drivers/staging/greybus/uart.c
@@ -34,7 +34,7 @@
 #include "greybus.h"
 #include "gbphy.h"
 
-#define GB_NUM_MINORS	16	/* 16 is is more than enough */
+#define GB_NUM_MINORS	16	/* 16 is more than enough */
 #define GB_NAME		"ttyGB"
 
 #define GB_UART_WRITE_FIFO_SIZE		PAGE_SIZE

commit 174cd4b1e5fbd0d74c68cf3a74f5bd4923485512
Author: Ingo Molnar <mingo@kernel.org>
Date:   Thu Feb 2 19:15:33 2017 +0100

    sched/headers: Prepare to move signal wakeup & sigpending methods from <linux/sched.h> into <linux/sched/signal.h>
    
    Fix up affected files that include this signal functionality via sched.h.
    
    Acked-by: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Mike Galbraith <efault@gmx.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/drivers/staging/greybus/uart.c b/drivers/staging/greybus/uart.c
index ab0dbf5cab5a..43255e2e9276 100644
--- a/drivers/staging/greybus/uart.c
+++ b/drivers/staging/greybus/uart.c
@@ -14,7 +14,7 @@
 #include <linux/kernel.h>
 #include <linux/errno.h>
 #include <linux/module.h>
-#include <linux/sched.h>
+#include <linux/sched/signal.h>
 #include <linux/wait.h>
 #include <linux/slab.h>
 #include <linux/uaccess.h>

commit 461ab8077d573d4a35529572c774a71e5a898a84
Author: Gioh Kim <gi-oh.kim@profitbricks.com>
Date:   Thu Feb 9 17:30:11 2017 +0100

    staging: greybus: fix "line over 80 characters" coding style issues
    
    This patch fixes only obvious lines.
    There are still more issues.
    
    Signed-off-by: Gioh Kim <gi-oh.kim@profitbricks.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/uart.c b/drivers/staging/greybus/uart.c
index 248ad6661a02..ab0dbf5cab5a 100644
--- a/drivers/staging/greybus/uart.c
+++ b/drivers/staging/greybus/uart.c
@@ -629,8 +629,9 @@ static int get_serial_info(struct gb_tty *gb_tty,
 	tmp.xmit_fifo_size = 16;
 	tmp.baud_base = 9600;
 	tmp.close_delay = gb_tty->port.close_delay / 10;
-	tmp.closing_wait = gb_tty->port.closing_wait == ASYNC_CLOSING_WAIT_NONE ?
-				ASYNC_CLOSING_WAIT_NONE : gb_tty->port.closing_wait / 10;
+	tmp.closing_wait =
+		gb_tty->port.closing_wait == ASYNC_CLOSING_WAIT_NONE ?
+		ASYNC_CLOSING_WAIT_NONE : gb_tty->port.closing_wait / 10;
 
 	if (copy_to_user(info, &tmp, sizeof(tmp)))
 		return -EFAULT;
@@ -999,7 +1000,8 @@ static int gb_tty_init(void)
 	gb_tty_driver->subtype = SERIAL_TYPE_NORMAL;
 	gb_tty_driver->flags = TTY_DRIVER_REAL_RAW | TTY_DRIVER_DYNAMIC_DEV;
 	gb_tty_driver->init_termios = tty_std_termios;
-	gb_tty_driver->init_termios.c_cflag = B9600 | CS8 | CREAD | HUPCL | CLOCAL;
+	gb_tty_driver->init_termios.c_cflag = B9600 | CS8 |
+		CREAD | HUPCL | CLOCAL;
 	tty_set_operations(gb_tty_driver, &gb_ops);
 
 	retval = tty_register_driver(gb_tty_driver);

commit 414850d9ce650bf75576126e52948595e3bbf871
Author: Johan Hovold <johan@kernel.org>
Date:   Wed Jan 25 18:07:52 2017 +0100

    staging: greybus: uart: fix TIOCGSERIAL flags
    
    This driver does not have a low-latency mode and should not report
    anything else.
    
    Also drop the skip-test flag which isn't used either.
    
    Signed-off-by: Johan Hovold <johan@kernel.org>
    Reviewed-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/uart.c b/drivers/staging/greybus/uart.c
index 6d39f4a04754..248ad6661a02 100644
--- a/drivers/staging/greybus/uart.c
+++ b/drivers/staging/greybus/uart.c
@@ -624,7 +624,6 @@ static int get_serial_info(struct gb_tty *gb_tty,
 	struct serial_struct tmp;
 
 	memset(&tmp, 0, sizeof(tmp));
-	tmp.flags = ASYNC_LOW_LATENCY | ASYNC_SKIP_TEST;
 	tmp.type = PORT_16550A;
 	tmp.line = gb_tty->minor;
 	tmp.xmit_fifo_size = 16;

commit 424a4b595e35df700314ca528ea91483edef9636
Author: Johan Hovold <johan@kernel.org>
Date:   Tue Nov 8 13:31:19 2016 +0100

    staging: greybus: use get_icount tty operation
    
    Use the tty get_icount operation instead of implementing TIOCGICOUNT
    directly.
    
    Signed-off-by: Johan Hovold <johan@kernel.org>
    Reviewed-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/uart.c b/drivers/staging/greybus/uart.c
index 35755f70d5a2..6d39f4a04754 100644
--- a/drivers/staging/greybus/uart.c
+++ b/drivers/staging/greybus/uart.c
@@ -708,25 +708,20 @@ static int wait_serial_change(struct gb_tty *gb_tty, unsigned long arg)
 	return retval;
 }
 
-static int get_serial_usage(struct gb_tty *gb_tty,
-			    struct serial_icounter_struct __user *count)
+static int gb_tty_get_icount(struct tty_struct *tty,
+			     struct serial_icounter_struct *icount)
 {
-	struct serial_icounter_struct icount;
-	int retval = 0;
-
-	memset(&icount, 0, sizeof(icount));
-	icount.dsr = gb_tty->iocount.dsr;
-	icount.rng = gb_tty->iocount.rng;
-	icount.dcd = gb_tty->iocount.dcd;
-	icount.frame = gb_tty->iocount.frame;
-	icount.overrun = gb_tty->iocount.overrun;
-	icount.parity = gb_tty->iocount.parity;
-	icount.brk = gb_tty->iocount.brk;
+	struct gb_tty *gb_tty = tty->driver_data;
 
-	if (copy_to_user(count, &icount, sizeof(icount)) > 0)
-		retval = -EFAULT;
+	icount->dsr = gb_tty->iocount.dsr;
+	icount->rng = gb_tty->iocount.rng;
+	icount->dcd = gb_tty->iocount.dcd;
+	icount->frame = gb_tty->iocount.frame;
+	icount->overrun = gb_tty->iocount.overrun;
+	icount->parity = gb_tty->iocount.parity;
+	icount->brk = gb_tty->iocount.brk;
 
-	return retval;
+	return 0;
 }
 
 static int gb_tty_ioctl(struct tty_struct *tty, unsigned int cmd,
@@ -743,9 +738,6 @@ static int gb_tty_ioctl(struct tty_struct *tty, unsigned int cmd,
 				       (struct serial_struct __user *)arg);
 	case TIOCMIWAIT:
 		return wait_serial_change(gb_tty, arg);
-	case TIOCGICOUNT:
-		return get_serial_usage(gb_tty,
-					(struct serial_icounter_struct __user *)arg);
 	}
 
 	return -ENOIOCTLCMD;
@@ -827,6 +819,7 @@ static const struct tty_operations gb_ops = {
 	.set_termios =		gb_tty_set_termios,
 	.tiocmget =		gb_tty_tiocmget,
 	.tiocmset =		gb_tty_tiocmset,
+	.get_icount =		gb_tty_get_icount,
 };
 
 static const struct tty_port_operations gb_port_ops = {

commit 4dfc109c7118ed8e2806c5395b9e9dd8f851f992
Author: Johan Hovold <johan@kernel.org>
Date:   Tue Nov 8 13:31:18 2016 +0100

    staging: greybus: uart: fix invalid user-pointer check
    
    Drop invalid user-pointer check from TIOCGSERIAL handler.
    
    A NULL-pointer can be valid in user space and copy_to_user() takes care
    of sanity checking.
    
    Signed-off-by: Johan Hovold <johan@kernel.org>
    Reviewed-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/uart.c b/drivers/staging/greybus/uart.c
index c1f6abb57dc3..35755f70d5a2 100644
--- a/drivers/staging/greybus/uart.c
+++ b/drivers/staging/greybus/uart.c
@@ -623,9 +623,6 @@ static int get_serial_info(struct gb_tty *gb_tty,
 {
 	struct serial_struct tmp;
 
-	if (!info)
-		return -EINVAL;
-
 	memset(&tmp, 0, sizeof(tmp));
 	tmp.flags = ASYNC_LOW_LATENCY | ASYNC_SKIP_TEST;
 	tmp.type = PORT_16550A;

commit bdc065666a591fddc4e55cbdcd6c7b02f289b5ff
Merge: 32774ef3e4bb a909d3e63699
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Sun Oct 30 06:38:44 2016 -0400

    Merge 4.9-rc3 into staging-next
    
    This resolves a merge issue with
    drivers/staging/iio/accel/sca3000_core.c and we want the fixes all in
    here as well.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 4d79f43191305b8382ae90147a34487b347b0509
Author: Bhumika Goyal <bhumirks@gmail.com>
Date:   Sat Oct 15 12:28:01 2016 +0530

    Staging: greybus: uart: constify tty_port_operations structure
    
    Declare tty_port_operations structure as const as it is only stored in
    the ops field of a tty_port structure which is a field of a gb_tty
    structure. The ops field is of type const struct tty_port_operations *,
    so tty_port_operations structures having this property can be
    declared as const.
    Done using Coccinelle:
    
    @r1 disable optional_qualifier @
    identifier i;
    position p;
    @@
    static struct tty_port_operations i@p = {...};
    
    @ok1@
    identifier r1.i;
    position p;
    struct gb_tty q;
    @@
    q.port.ops=&i@p
    
    @bad@
    position p!={r1.p,ok1.p};
    identifier r1.i;
    @@
    i@p
    
    @depends on !bad disable optional_qualifier@
    identifier r1.i;
    @@
    static
    +const
    struct tty_port_operations i={...};
    
    @depends on !bad disable optional_qualifier@
    identifier r1.i;
    @@
    +const
    struct tty_port_operations i;
    
    File size before:
       text    data     bss     dec     hex filename
       7646     512      56    8214    2016 drivers/staging/greybus/uart.o
    
    File size after:
       text    data     bss     dec     hex filename
       7710     448      56    8214    2016 drivers/staging/greybus/uart.o
    
    Signed-off-by: Bhumika Goyal <bhumirks@gmail.com>
    Acked-by: Johan Hovold <johan@kernel.org>
    Reviewed-by: David Lin <dtwlin@gmail.com>
    Acked-by: Julia Lawall <julia.lawall@lip6.fr>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/uart.c b/drivers/staging/greybus/uart.c
index 5ee7954bd9f9..8162886bcaed 100644
--- a/drivers/staging/greybus/uart.c
+++ b/drivers/staging/greybus/uart.c
@@ -832,7 +832,7 @@ static const struct tty_operations gb_ops = {
 	.tiocmset =		gb_tty_tiocmset,
 };
 
-static struct tty_port_operations gb_port_ops = {
+static const struct tty_port_operations gb_port_ops = {
 	.dtr_rts =		gb_tty_dtr_rts,
 	.activate =		gb_tty_port_activate,
 	.shutdown =		gb_tty_port_shutdown,

commit 4fa589126f23243bd998a464cb6158d343eb6a89
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Wed Oct 12 08:02:22 2016 +0530

    Staging: greybus: uart: Use gbphy_dev->dev instead of bundle->dev
    
    Some of the print messages are using the incorrect device pointer, fix
    them.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Acked-by: Johan Hovold <johan@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/uart.c b/drivers/staging/greybus/uart.c
index 5ee7954bd9f9..2633d2bfb1b4 100644
--- a/drivers/staging/greybus/uart.c
+++ b/drivers/staging/greybus/uart.c
@@ -888,7 +888,7 @@ static int gb_uart_probe(struct gbphy_device *gbphy_dev,
 	minor = alloc_minor(gb_tty);
 	if (minor < 0) {
 		if (minor == -ENOSPC) {
-			dev_err(&connection->bundle->dev,
+			dev_err(&gbphy_dev->dev,
 				"no more free minor numbers\n");
 			retval = -ENODEV;
 		} else {

commit 319b78c3c4842a6f079bca8950248803fa67b38f
Author: Chaehyun Lim <chaehyun.lim@gmail.com>
Date:   Thu Sep 22 10:56:44 2016 +0900

    staging: greybus: uart.c: fix alignment to match open parenthesis
    
    Fixes checkpatch.pl warning:
    CHECK: Alignment should match open parenthesis
    
    Signed-off-by: Chaehyun Lim <chaehyun.lim@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/uart.c b/drivers/staging/greybus/uart.c
index a3c753b74f2b..5ee7954bd9f9 100644
--- a/drivers/staging/greybus/uart.c
+++ b/drivers/staging/greybus/uart.c
@@ -93,8 +93,8 @@ static int gb_uart_receive_data_handler(struct gb_operation *op)
 
 	if (request->payload_size < sizeof(*receive_data)) {
 		dev_err(&gb_tty->gbphy_dev->dev,
-				"short receive-data request received (%zu < %zu)\n",
-				request->payload_size, sizeof(*receive_data));
+			"short receive-data request received (%zu < %zu)\n",
+			request->payload_size, sizeof(*receive_data));
 		return -EINVAL;
 	}
 
@@ -103,9 +103,9 @@ static int gb_uart_receive_data_handler(struct gb_operation *op)
 
 	if (recv_data_size != request->payload_size - sizeof(*receive_data)) {
 		dev_err(&gb_tty->gbphy_dev->dev,
-				"malformed receive-data request received (%u != %zu)\n",
-				recv_data_size,
-				request->payload_size - sizeof(*receive_data));
+			"malformed receive-data request received (%u != %zu)\n",
+			recv_data_size,
+			request->payload_size - sizeof(*receive_data));
 		return -EINVAL;
 	}
 
@@ -145,8 +145,8 @@ static int gb_uart_serial_state_handler(struct gb_operation *op)
 
 	if (request->payload_size < sizeof(*serial_state)) {
 		dev_err(&gb_tty->gbphy_dev->dev,
-				"short serial-state event received (%zu < %zu)\n",
-				request->payload_size, sizeof(*serial_state));
+			"short serial-state event received (%zu < %zu)\n",
+			request->payload_size, sizeof(*serial_state));
 		return -EINVAL;
 	}
 
@@ -168,9 +168,9 @@ static int gb_uart_receive_credits_handler(struct gb_operation *op)
 
 	if (request->payload_size < sizeof(*credit_request)) {
 		dev_err(&gb_tty->gbphy_dev->dev,
-				"short receive_credits event received (%zu < %zu)\n",
-				request->payload_size,
-				sizeof(*credit_request));
+			"short receive_credits event received (%zu < %zu)\n",
+			request->payload_size,
+			sizeof(*credit_request));
 		return -EINVAL;
 	}
 
@@ -253,8 +253,8 @@ static void  gb_uart_tx_write_work(struct work_struct *work)
 			send_size = gb_tty->credits;
 
 		send_size = kfifo_out_peek(&gb_tty->write_fifo,
-					&request->data[0],
-					send_size);
+					   &request->data[0],
+					   send_size);
 		if (!send_size) {
 			spin_unlock_irqrestore(&gb_tty->write_lock, flags);
 			break;
@@ -446,7 +446,7 @@ static int gb_tty_write(struct tty_struct *tty, const unsigned char *buf,
 	struct gb_tty *gb_tty = tty->driver_data;
 
 	count =  kfifo_in_spinlocked(&gb_tty->write_fifo, buf, count,
-					&gb_tty->write_lock);
+				     &gb_tty->write_lock);
 	if (count && !gb_tty->close_pending)
 		schedule_work(&gb_tty->tx_work);
 
@@ -878,7 +878,7 @@ static int gb_uart_probe(struct gbphy_device *gbphy_dev,
 	INIT_WORK(&gb_tty->tx_work, gb_uart_tx_write_work);
 
 	retval = kfifo_alloc(&gb_tty->write_fifo, GB_UART_WRITE_FIFO_SIZE,
-				GFP_KERNEL);
+			     GFP_KERNEL);
 	if (retval)
 		goto exit_buf_free;
 

commit 26746a360394158850c494dd89d9d4f2d276b032
Author: Chaehyun Lim <chaehyun.lim@gmail.com>
Date:   Thu Sep 22 10:56:43 2016 +0900

    staging: greybus: uart.c: change 'unsigned' to 'unsigned int'
    
    Fixes checkpatch.pl warning:
    WARNING: Prefer 'unsigned int' to bare use of 'unsigned'
    
    Signed-off-by: Chaehyun Lim <chaehyun.lim@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/uart.c b/drivers/staging/greybus/uart.c
index 01aeed1b3a9c..a3c753b74f2b 100644
--- a/drivers/staging/greybus/uart.c
+++ b/drivers/staging/greybus/uart.c
@@ -350,7 +350,7 @@ static int gb_uart_flush(struct gb_tty *gb_tty, u8 flags)
 				 &request, sizeof(request), NULL, 0);
 }
 
-static struct gb_tty *get_gb_by_minor(unsigned minor)
+static struct gb_tty *get_gb_by_minor(unsigned int minor)
 {
 	struct gb_tty *gb_tty;
 

commit 22b8708725c20ce57d79e51a7e98628b382420a4
Author: Axel Haslam <haslam_axel@projectara.com>
Date:   Thu Jul 14 15:13:00 2016 -0500

    greybus: uart: Add runtime pm support
    
    This adds runtime pm support for the uart driver.
    
    Testing Done: Using the test daughter board, let
    the gpb bridge enter standby and do a uart transfer
    operation.
    
    Signed-off-by: Axel Haslam <haslam_axel@projectara.com>
    Signed-off-by: David Lin <dtwlin@google.com>
    Reviewed-by: Johan Hovold <johan@hovoldconsulting.com>
    Signed-off-by: Alex Elder <elder@linaro.org>

diff --git a/drivers/staging/greybus/uart.c b/drivers/staging/greybus/uart.c
index 6260569b2f25..01aeed1b3a9c 100644
--- a/drivers/staging/greybus/uart.c
+++ b/drivers/staging/greybus/uart.c
@@ -771,6 +771,16 @@ static void gb_tty_dtr_rts(struct tty_port *port, int on)
 	send_control(gb_tty, newctrl);
 }
 
+static int gb_tty_port_activate(struct tty_port *port,
+				struct tty_struct *tty)
+{
+	struct gb_tty *gb_tty;
+
+	gb_tty = container_of(port, struct gb_tty, port);
+
+	return gbphy_runtime_get_sync(gb_tty->gbphy_dev);
+}
+
 static void gb_tty_port_shutdown(struct tty_port *port)
 {
 	struct gb_tty *gb_tty;
@@ -800,6 +810,8 @@ static void gb_tty_port_shutdown(struct tty_port *port)
 
 out:
 	gb_tty->close_pending = false;
+
+	gbphy_runtime_put_autosuspend(gb_tty->gbphy_dev);
 }
 
 static const struct tty_operations gb_ops = {
@@ -822,6 +834,7 @@ static const struct tty_operations gb_ops = {
 
 static struct tty_port_operations gb_port_ops = {
 	.dtr_rts =		gb_tty_dtr_rts,
+	.activate =		gb_tty_port_activate,
 	.shutdown =		gb_tty_port_shutdown,
 };
 
@@ -922,6 +935,7 @@ static int gb_uart_probe(struct gbphy_device *gbphy_dev,
 		goto exit_connection_disable;
 	}
 
+	gbphy_runtime_put_autosuspend(gbphy_dev);
 	return 0;
 
 exit_connection_disable:
@@ -945,6 +959,11 @@ static void gb_uart_remove(struct gbphy_device *gbphy_dev)
 	struct gb_tty *gb_tty = gb_gbphy_get_data(gbphy_dev);
 	struct gb_connection *connection = gb_tty->connection;
 	struct tty_struct *tty;
+	int ret;
+
+	ret = gbphy_runtime_get_sync(gbphy_dev);
+	if (ret)
+		gbphy_runtime_get_noresume(gbphy_dev);
 
 	mutex_lock(&gb_tty->mutex);
 	gb_tty->disconnected = true;

commit 2aae92bdc25325cfd782cc76842a4302540958f2
Author: Johan Hovold <johan@hovoldconsulting.com>
Date:   Mon Jun 27 20:07:12 2016 +0200

    greybus: Revert "greybus: uart: don't use spin_lock_irq()"
    
    This reverts commit bd3c4aa99dc23449699432e0744bcb5af7afa98c.
    
    Someone decided that all use of spin_lock_irq was to be considered a bug
    and went on a search-and-replace type "bug-fixing" spree last week.
    
    This is however just plain wrong. Using spin_lock_irq is perfectly fine
    in paths were interrupts have not been disabled, and this is in fact
    even preferred over the lazy approach of always using spin_lock_irqsave
    instead of understanding the code that is being written or modified.
    
    All current uses of spin_lock_irq have already been vetted in this
    respect. Also note that it is only used in functions that may sleep,
    that is, in functions that must not be called with interrupts disabled
    in the first place.
    
    Signed-off-by: Johan Hovold <johan@hovoldconsulting.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/uart.c b/drivers/staging/greybus/uart.c
index 80896385c1cb..6260569b2f25 100644
--- a/drivers/staging/greybus/uart.c
+++ b/drivers/staging/greybus/uart.c
@@ -674,7 +674,6 @@ static int set_serial_info(struct gb_tty *gb_tty,
 static int wait_serial_change(struct gb_tty *gb_tty, unsigned long arg)
 {
 	int retval = 0;
-	unsigned long flags;
 	DECLARE_WAITQUEUE(wait, current);
 	struct async_icount old;
 	struct async_icount new;
@@ -683,11 +682,11 @@ static int wait_serial_change(struct gb_tty *gb_tty, unsigned long arg)
 		return -EINVAL;
 
 	do {
-		spin_lock_irqsave(&gb_tty->read_lock, flags);
+		spin_lock_irq(&gb_tty->read_lock);
 		old = gb_tty->oldcount;
 		new = gb_tty->iocount;
 		gb_tty->oldcount = new;
-		spin_unlock_irqrestore(&gb_tty->read_lock, flags);
+		spin_unlock_irq(&gb_tty->read_lock);
 
 		if ((arg & TIOCM_DSR) && (old.dsr != new.dsr))
 			break;

commit e9f80f3363542b645a5ceb0509273eda1d0e4eab
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Thu Jun 23 23:23:06 2016 +0530

    greybus: uart: don't use spin_lock_irq()
    
    spin_[un]lock_irq() routines should be used carefully as they things can
    go wrong, if they are mixed with spin_lock_irqsave() or other variants.
    
    The main problem is that spin_[un]lock_irq() routines doesn't check if
    the IRQs are already disabled/enabled on the local CPU and so
    spin_unlock_irq() will forcefully enable interrupts for example.
    
    This may not work well, if some other code was relying on interrupts
    being disabled.
    
    Use spin_lock_irqsave() and spin_unlock_restore() instead.
    
    This patch doesn't claim that it fixes the JIRA completely, but
    the issue was harder to reproduce for some iterations after this, which
    was quite easy to reproduce earlier on.
    
    Tested on EVT 2.0 with lots of debug patches to kernel and greybus.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/uart.c b/drivers/staging/greybus/uart.c
index 6260569b2f25..80896385c1cb 100644
--- a/drivers/staging/greybus/uart.c
+++ b/drivers/staging/greybus/uart.c
@@ -674,6 +674,7 @@ static int set_serial_info(struct gb_tty *gb_tty,
 static int wait_serial_change(struct gb_tty *gb_tty, unsigned long arg)
 {
 	int retval = 0;
+	unsigned long flags;
 	DECLARE_WAITQUEUE(wait, current);
 	struct async_icount old;
 	struct async_icount new;
@@ -682,11 +683,11 @@ static int wait_serial_change(struct gb_tty *gb_tty, unsigned long arg)
 		return -EINVAL;
 
 	do {
-		spin_lock_irq(&gb_tty->read_lock);
+		spin_lock_irqsave(&gb_tty->read_lock, flags);
 		old = gb_tty->oldcount;
 		new = gb_tty->iocount;
 		gb_tty->oldcount = new;
-		spin_unlock_irq(&gb_tty->read_lock);
+		spin_unlock_irqrestore(&gb_tty->read_lock, flags);
 
 		if ((arg & TIOCM_DSR) && (old.dsr != new.dsr))
 			break;

commit 19cdabcf0ba92ddd87bdb86f8e3ceaae2dd6f8bb
Author: Greg Kroah-Hartman <gregkh@google.com>
Date:   Thu Jun 23 14:20:02 2016 -0700

    greybus: Revert "greybus: don't use spin_lock_irq()"
    
    This reverts commit 469fbe5da0229edcb42aa08bef8e10feaa37e6d7.
    
    It isn't correct in places.
    
    Reported-by: Gjorgji Rosikopulos <rosikopulos_gjorgji@projectara.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/uart.c b/drivers/staging/greybus/uart.c
index 80896385c1cb..6260569b2f25 100644
--- a/drivers/staging/greybus/uart.c
+++ b/drivers/staging/greybus/uart.c
@@ -674,7 +674,6 @@ static int set_serial_info(struct gb_tty *gb_tty,
 static int wait_serial_change(struct gb_tty *gb_tty, unsigned long arg)
 {
 	int retval = 0;
-	unsigned long flags;
 	DECLARE_WAITQUEUE(wait, current);
 	struct async_icount old;
 	struct async_icount new;
@@ -683,11 +682,11 @@ static int wait_serial_change(struct gb_tty *gb_tty, unsigned long arg)
 		return -EINVAL;
 
 	do {
-		spin_lock_irqsave(&gb_tty->read_lock, flags);
+		spin_lock_irq(&gb_tty->read_lock);
 		old = gb_tty->oldcount;
 		new = gb_tty->iocount;
 		gb_tty->oldcount = new;
-		spin_unlock_irqrestore(&gb_tty->read_lock, flags);
+		spin_unlock_irq(&gb_tty->read_lock);
 
 		if ((arg & TIOCM_DSR) && (old.dsr != new.dsr))
 			break;

commit 5e2b63915cb6f1e86f9515342cfcfb28cd82c5b0
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Thu Jun 23 23:23:06 2016 +0530

    greybus: don't use spin_lock_irq()
    
    spin_[un]lock_irq() routines should be used carefully as they things can
    go wrong, if they are mixed with spin_lock_irqsave() or other variants.
    
    The main problem is that spin_[un]lock_irq() routines doesn't check if
    the IRQs are already disabled/enabled on the local CPU and so
    spin_unlock_irq() will forcefully enable interrupts for example.
    
    This may not work well, if some other code was relying on interrupts
    being disabled.
    
    Use spin_lock_irqsave() and spin_unlock_restore() instead.
    
    This patch doesn't claim that it fixes the JIRA completely, but
    the issue was harder to reproduce for some iterations after this, which
    was quite easy to reproduce earlier on.
    
    Tested on EVT 2.0 with lots of debug patches to kernel and greybus.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Reviewed-by: Jeffrey Carlyle <jcarlyle@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/uart.c b/drivers/staging/greybus/uart.c
index 6260569b2f25..80896385c1cb 100644
--- a/drivers/staging/greybus/uart.c
+++ b/drivers/staging/greybus/uart.c
@@ -674,6 +674,7 @@ static int set_serial_info(struct gb_tty *gb_tty,
 static int wait_serial_change(struct gb_tty *gb_tty, unsigned long arg)
 {
 	int retval = 0;
+	unsigned long flags;
 	DECLARE_WAITQUEUE(wait, current);
 	struct async_icount old;
 	struct async_icount new;
@@ -682,11 +683,11 @@ static int wait_serial_change(struct gb_tty *gb_tty, unsigned long arg)
 		return -EINVAL;
 
 	do {
-		spin_lock_irq(&gb_tty->read_lock);
+		spin_lock_irqsave(&gb_tty->read_lock, flags);
 		old = gb_tty->oldcount;
 		new = gb_tty->iocount;
 		gb_tty->oldcount = new;
-		spin_unlock_irq(&gb_tty->read_lock);
+		spin_unlock_irqrestore(&gb_tty->read_lock, flags);
 
 		if ((arg & TIOCM_DSR) && (old.dsr != new.dsr))
 			break;

commit 60fb3405c73ea0bbab942c699496123f9e987c04
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Fri Jun 10 14:59:07 2016 +0530

    greybus: Remove extra blank lines
    
    This patch removes few blank lines across the repository at places where
    two blank lines were present together or when a blank line is present at
    the start or end of a routine.
    
    Note that this doesn't remove most of them from greybus_protocols.h as
    they were added on purpose.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/uart.c b/drivers/staging/greybus/uart.c
index 7460bdbd0a1a..6260569b2f25 100644
--- a/drivers/staging/greybus/uart.c
+++ b/drivers/staging/greybus/uart.c
@@ -597,7 +597,6 @@ static void gb_tty_throttle(struct tty_struct *tty)
 		gb_tty->ctrlout &= ~GB_UART_CTRL_RTS;
 		retval = send_control(gb_tty, gb_tty->ctrlout);
 	}
-
 }
 
 static void gb_tty_unthrottle(struct tty_struct *tty)
@@ -710,7 +709,6 @@ static int wait_serial_change(struct gb_tty *gb_tty, unsigned long arg)
 	} while (!retval);
 
 	return retval;
-
 }
 
 static int get_serial_usage(struct gb_tty *gb_tty,
@@ -924,7 +922,6 @@ static int gb_uart_probe(struct gbphy_device *gbphy_dev,
 		goto exit_connection_disable;
 	}
 
-
 	return 0;
 
 exit_connection_disable:

commit 6db9cc68d7f9cea440293af4225a7b7f22d1d86d
Author: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
Date:   Fri Jun 10 17:33:03 2016 +0100

    greybus: uart: Fix minor number leak
    
    On the gb_uart_remove() path we are forgetting to do a release_minor()
    leading to a minor number leak. This is a simple one-line fix.
    
    Tested on EVT 2.0
    
    Signed-off-by: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/uart.c b/drivers/staging/greybus/uart.c
index d1611abf8ccd..7460bdbd0a1a 100644
--- a/drivers/staging/greybus/uart.c
+++ b/drivers/staging/greybus/uart.c
@@ -969,6 +969,7 @@ static void gb_uart_remove(struct gbphy_device *gbphy_dev)
 	gb_connection_disable(connection);
 	tty_port_destroy(&gb_tty->port);
 	gb_connection_destroy(connection);
+	release_minor(gb_tty);
 	kfifo_free(&gb_tty->write_fifo);
 	kfree(gb_tty->buffer);
 	kfree(gb_tty);

commit 64060fe95458f22bac7327b2ee8dc5ce9e488d44
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Mon May 30 11:31:53 2016 +0530

    greybus: gbphy: Remove protocol specific version handling
    
    We should be using the generic version handling at bundle level, instead
    of at protocol level for bridged PHY devices as well.
    
    The bundle version handling is already in place, though it is *not* used
    today as we haven't bumped the version of control protocol yet.
    
    Remove protocol specific handling for bridged PHY devices.
    
    Tested on EVT 1.5 with gpbridge-test module. No nuttx changes are
    required with this.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Reviewed-by: Johan Hovold <johan@hovoldconsulting.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/uart.c b/drivers/staging/greybus/uart.c
index a2fca3b3358e..d1611abf8ccd 100644
--- a/drivers/staging/greybus/uart.c
+++ b/drivers/staging/greybus/uart.c
@@ -904,10 +904,6 @@ static int gb_uart_probe(struct gbphy_device *gbphy_dev,
 	if (retval)
 		goto exit_release_minor;
 
-	retval = gb_gbphy_get_version(connection);
-	if (retval)
-		goto exit_connection_disable;
-
 	send_control(gb_tty, gb_tty->ctrlout);
 
 	/* initialize the uart to be 9600n81 */

commit 5dad5c314b686ca84aa5477462fcfd2b1abcba46
Author: Axel Haslam <ahaslam@baylibre.com>
Date:   Tue May 31 14:36:13 2016 +0200

    greybus: uart: wait for credits on shutdown
    
    We should try to wait until all credits are accounted
    for before returning from shutdown.
    
    For this purpose add a helper function that will
    wait on completion, and call it form the shutdown.
    This helper will also be useful when "wait until sent" is
    implemented.
    
    Signed-off-by: Axel Haslam <ahaslam@baylibre.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/uart.c b/drivers/staging/greybus/uart.c
index 7dc9f9b873b1..a2fca3b3358e 100644
--- a/drivers/staging/greybus/uart.c
+++ b/drivers/staging/greybus/uart.c
@@ -29,6 +29,7 @@
 #include <linux/kdev_t.h>
 #include <linux/kfifo.h>
 #include <linux/workqueue.h>
+#include <linux/completion.h>
 
 #include "greybus.h"
 #include "gbphy.h"
@@ -39,6 +40,7 @@
 #define GB_UART_WRITE_FIFO_SIZE		PAGE_SIZE
 #define GB_UART_WRITE_ROOM_MARGIN	1	/* leave some space in fifo */
 #define GB_UART_FIRMWARE_CREDITS	4096
+#define GB_UART_CREDIT_WAIT_TIMEOUT_MSEC	10000
 
 struct gb_tty_line_coding {
 	__le32	rate;
@@ -71,6 +73,7 @@ struct gb_tty {
 	struct kfifo write_fifo;
 	bool close_pending;
 	unsigned int credits;
+	struct completion credits_complete;
 };
 
 static struct tty_driver *gb_tty_driver;
@@ -197,6 +200,9 @@ static int gb_uart_receive_credits_handler(struct gb_operation *op)
 	 */
 	tty_port_tty_wakeup(&gb_tty->port);
 
+	if (gb_tty->credits == GB_UART_FIRMWARE_CREDITS)
+		complete(&gb_tty->credits_complete);
+
 	return ret;
 }
 
@@ -317,6 +323,24 @@ static int send_break(struct gb_tty *gb_tty, u8 state)
 				 &request, sizeof(request), NULL, 0);
 }
 
+static int gb_uart_wait_for_all_credits(struct gb_tty *gb_tty)
+{
+	int ret;
+
+	if (gb_tty->credits == GB_UART_FIRMWARE_CREDITS)
+		return 0;
+
+	ret = wait_for_completion_timeout(&gb_tty->credits_complete,
+			msecs_to_jiffies(GB_UART_CREDIT_WAIT_TIMEOUT_MSEC));
+	if (!ret) {
+		dev_err(&gb_tty->gbphy_dev->dev,
+			"time out waiting for credits\n");
+		return -ETIMEDOUT;
+	}
+
+	return 0;
+}
+
 static int gb_uart_flush(struct gb_tty *gb_tty, u8 flags)
 {
 	struct gb_uart_serial_flush_request request;
@@ -765,12 +789,18 @@ static void gb_tty_port_shutdown(struct tty_port *port)
 	kfifo_reset_out(&gb_tty->write_fifo);
 	spin_unlock_irqrestore(&gb_tty->write_lock, flags);
 
+	if (gb_tty->credits == GB_UART_FIRMWARE_CREDITS)
+		goto out;
+
 	ret = gb_uart_flush(gb_tty, GB_SERIAL_FLAG_FLUSH_TRANSMITTER);
 	if (ret) {
 		dev_err(&gb_tty->gbphy_dev->dev,
 			"error flushing transmitter: %d\n", ret);
 	}
 
+	gb_uart_wait_for_all_credits(gb_tty);
+
+out:
 	gb_tty->close_pending = false;
 }
 
@@ -842,6 +872,7 @@ static int gb_uart_probe(struct gbphy_device *gbphy_dev,
 		goto exit_buf_free;
 
 	gb_tty->credits = GB_UART_FIRMWARE_CREDITS;
+	init_completion(&gb_tty->credits_complete);
 
 	minor = alloc_minor(gb_tty);
 	if (minor < 0) {

commit 2b3b87f056b276b688cb0429faf682cac33dbf7b
Author: Axel Haslam <ahaslam@baylibre.com>
Date:   Tue May 31 14:36:12 2016 +0200

    greybus: uart: Implement flush_buffer
    
    Data may be held pening in the hardware because of flow
    control mechanisms. When the port is closed, we need to flush
    all data that was not sent.
    
    For this, use the greybus message GB_UART_TYPE_FLUSH_FIFOS
    which will flush all data queued on the module but not
    yet sent on the data line.
    
    Suggested-by: Johan Hovold <johan@hovoldconsulting.com>
    Signed-off-by: Axel Haslam <ahaslam@baylibre.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/uart.c b/drivers/staging/greybus/uart.c
index 14b3e9d06e9c..7dc9f9b873b1 100644
--- a/drivers/staging/greybus/uart.c
+++ b/drivers/staging/greybus/uart.c
@@ -317,6 +317,14 @@ static int send_break(struct gb_tty *gb_tty, u8 state)
 				 &request, sizeof(request), NULL, 0);
 }
 
+static int gb_uart_flush(struct gb_tty *gb_tty, u8 flags)
+{
+	struct gb_uart_serial_flush_request request;
+
+	request.flags = flags;
+	return gb_operation_sync(gb_tty->connection, GB_UART_TYPE_FLUSH_FIFOS,
+				 &request, sizeof(request), NULL, 0);
+}
 
 static struct gb_tty *get_gb_by_minor(unsigned minor)
 {
@@ -745,6 +753,7 @@ static void gb_tty_port_shutdown(struct tty_port *port)
 {
 	struct gb_tty *gb_tty;
 	unsigned long flags;
+	int ret;
 
 	gb_tty = container_of(port, struct gb_tty, port);
 
@@ -756,6 +765,12 @@ static void gb_tty_port_shutdown(struct tty_port *port)
 	kfifo_reset_out(&gb_tty->write_fifo);
 	spin_unlock_irqrestore(&gb_tty->write_lock, flags);
 
+	ret = gb_uart_flush(gb_tty, GB_SERIAL_FLAG_FLUSH_TRANSMITTER);
+	if (ret) {
+		dev_err(&gb_tty->gbphy_dev->dev,
+			"error flushing transmitter: %d\n", ret);
+	}
+
 	gb_tty->close_pending = false;
 }
 

commit a8bc00fb88037e0107a0682478f47396a073be5c
Author: Axel Haslam <ahaslam@baylibre.com>
Date:   Tue May 31 14:36:11 2016 +0200

    greybus: uart: Add credits based tracking for transmit path
    
    To avoid polling the firmware for space, a credit based system
    is implemented.
    
    The host will keep track of how many credits (bytes) it has
    sent to the firmware, and stop sending data when the quota
    is filled.
    
    The host will be informed that the firmware has more
    room for data when it handles the receive_credits request
    message from the firmware, and will continue to write data
    as credits become available.
    
    The firmware and the host may implement an algorithm to aggregate
    credits, and avoid extra greybus traffic.
    
    Suggested-by: Johan Hovold <johan@hovoldconsulting.com>
    Signed-off-by: Axel Haslam <ahaslam@baylibre.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/uart.c b/drivers/staging/greybus/uart.c
index 09fae9ae22bb..14b3e9d06e9c 100644
--- a/drivers/staging/greybus/uart.c
+++ b/drivers/staging/greybus/uart.c
@@ -38,6 +38,7 @@
 
 #define GB_UART_WRITE_FIFO_SIZE		PAGE_SIZE
 #define GB_UART_WRITE_ROOM_MARGIN	1	/* leave some space in fifo */
+#define GB_UART_FIRMWARE_CREDITS	4096
 
 struct gb_tty_line_coding {
 	__le32	rate;
@@ -69,6 +70,7 @@ struct gb_tty {
 	struct work_struct tx_work;
 	struct kfifo write_fifo;
 	bool close_pending;
+	unsigned int credits;
 };
 
 static struct tty_driver *gb_tty_driver;
@@ -151,6 +153,53 @@ static int gb_uart_serial_state_handler(struct gb_operation *op)
 	return 0;
 }
 
+static int gb_uart_receive_credits_handler(struct gb_operation *op)
+{
+	struct gb_connection *connection = op->connection;
+	struct gb_tty *gb_tty = gb_connection_get_data(connection);
+	struct gb_message *request = op->request;
+	struct gb_uart_receive_credits_request *credit_request;
+	unsigned long flags;
+	unsigned int incoming_credits;
+	int ret = 0;
+
+	if (request->payload_size < sizeof(*credit_request)) {
+		dev_err(&gb_tty->gbphy_dev->dev,
+				"short receive_credits event received (%zu < %zu)\n",
+				request->payload_size,
+				sizeof(*credit_request));
+		return -EINVAL;
+	}
+
+	credit_request = request->payload;
+	incoming_credits = le16_to_cpu(credit_request->count);
+
+	spin_lock_irqsave(&gb_tty->write_lock, flags);
+	gb_tty->credits += incoming_credits;
+	if (gb_tty->credits > GB_UART_FIRMWARE_CREDITS) {
+		gb_tty->credits -= incoming_credits;
+		ret = -EINVAL;
+	}
+	spin_unlock_irqrestore(&gb_tty->write_lock, flags);
+
+	if (ret) {
+		dev_err(&gb_tty->gbphy_dev->dev,
+			"invalid number of incoming credits: %d\n",
+			incoming_credits);
+		return ret;
+	}
+
+	if (!gb_tty->close_pending)
+		schedule_work(&gb_tty->tx_work);
+
+	/*
+	 * the port the tty layer may be waiting for credits
+	 */
+	tty_port_tty_wakeup(&gb_tty->port);
+
+	return ret;
+}
+
 static int gb_uart_request_handler(struct gb_operation *op)
 {
 	struct gb_connection *connection = op->connection;
@@ -165,6 +214,9 @@ static int gb_uart_request_handler(struct gb_operation *op)
 	case GB_UART_TYPE_SERIAL_STATE:
 		ret = gb_uart_serial_state_handler(op);
 		break;
+	case GB_UART_TYPE_RECEIVE_CREDITS:
+		ret = gb_uart_receive_credits_handler(op);
+		break;
 	default:
 		dev_err(&gb_tty->gbphy_dev->dev,
 			"unsupported unsolicited request: 0x%02x\n", type);
@@ -190,14 +242,19 @@ static void  gb_uart_tx_write_work(struct work_struct *work)
 			break;
 
 		spin_lock_irqsave(&gb_tty->write_lock, flags);
+		send_size = gb_tty->buffer_payload_max;
+		if (send_size > gb_tty->credits)
+			send_size = gb_tty->credits;
+
 		send_size = kfifo_out_peek(&gb_tty->write_fifo,
 					&request->data[0],
-					gb_tty->buffer_payload_max);
+					send_size);
 		if (!send_size) {
 			spin_unlock_irqrestore(&gb_tty->write_lock, flags);
 			break;
 		}
 
+		gb_tty->credits -= send_size;
 		spin_unlock_irqrestore(&gb_tty->write_lock, flags);
 
 		request->size = cpu_to_le16(send_size);
@@ -208,6 +265,9 @@ static void  gb_uart_tx_write_work(struct work_struct *work)
 		if (ret) {
 			dev_err(&gb_tty->gbphy_dev->dev,
 				"send data error: %d\n", ret);
+			spin_lock_irqsave(&gb_tty->write_lock, flags);
+			gb_tty->credits += send_size;
+			spin_unlock_irqrestore(&gb_tty->write_lock, flags);
 			if (!gb_tty->close_pending)
 				schedule_work(work);
 			return;
@@ -386,6 +446,8 @@ static int gb_tty_chars_in_buffer(struct tty_struct *tty)
 
 	spin_lock_irqsave(&gb_tty->write_lock, flags);
 	chars = kfifo_len(&gb_tty->write_fifo);
+	if (gb_tty->credits < GB_UART_FIRMWARE_CREDITS)
+		chars += GB_UART_FIRMWARE_CREDITS - gb_tty->credits;
 	spin_unlock_irqrestore(&gb_tty->write_lock, flags);
 
 	return chars;
@@ -764,6 +826,8 @@ static int gb_uart_probe(struct gbphy_device *gbphy_dev,
 	if (retval)
 		goto exit_buf_free;
 
+	gb_tty->credits = GB_UART_FIRMWARE_CREDITS;
+
 	minor = alloc_minor(gb_tty);
 	if (minor < 0) {
 		if (minor == -ENOSPC) {

commit 8d6fbe9bf9947ee875c222a2e33d5977e2d052f2
Author: Axel Haslam <ahaslam@baylibre.com>
Date:   Tue May 31 14:36:10 2016 +0200

    greybus: uart: Use a fifo to send data to the modules
    
    The firmware now buffers data instead of blocking while the transfer
    is sent, and the write operation cannot sleep.
    
    Instead of using gb_transfer_sync (which sleeps) in the write callback,
    buffer data in a fifo and send it from from a work queue.
    
    The write_room callback will will report 1 byte less that what is really
    available in the fifo, to leave space for extra characters that may
    be added by the tty layer.
    
    Signed-off-by: Axel Haslam <ahaslam@baylibre.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/uart.c b/drivers/staging/greybus/uart.c
index c257fbf40b79..09fae9ae22bb 100644
--- a/drivers/staging/greybus/uart.c
+++ b/drivers/staging/greybus/uart.c
@@ -27,6 +27,8 @@
 #include <linux/idr.h>
 #include <linux/fs.h>
 #include <linux/kdev_t.h>
+#include <linux/kfifo.h>
+#include <linux/workqueue.h>
 
 #include "greybus.h"
 #include "gbphy.h"
@@ -34,6 +36,9 @@
 #define GB_NUM_MINORS	16	/* 16 is is more than enough */
 #define GB_NAME		"ttyGB"
 
+#define GB_UART_WRITE_FIFO_SIZE		PAGE_SIZE
+#define GB_UART_WRITE_ROOM_MARGIN	1	/* leave some space in fifo */
+
 struct gb_tty_line_coding {
 	__le32	rate;
 	__u8	format;
@@ -61,6 +66,9 @@ struct gb_tty {
 	u8 ctrlin;	/* input control lines */
 	u8 ctrlout;	/* output control lines */
 	struct gb_tty_line_coding line_coding;
+	struct work_struct tx_work;
+	struct kfifo write_fifo;
+	bool close_pending;
 };
 
 static struct tty_driver *gb_tty_driver;
@@ -166,25 +174,52 @@ static int gb_uart_request_handler(struct gb_operation *op)
 	return ret;
 }
 
-static int send_data(struct gb_tty *tty, u16 size, const u8 *data)
+static void  gb_uart_tx_write_work(struct work_struct *work)
 {
 	struct gb_uart_send_data_request *request;
+	struct gb_tty *gb_tty;
+	unsigned long flags;
+	unsigned int send_size;
 	int ret;
 
-	if (!data || !size)
-		return 0;
+	gb_tty = container_of(work, struct gb_tty, tx_work);
+	request = gb_tty->buffer;
 
-	if (size > tty->buffer_payload_max)
-		size = tty->buffer_payload_max;
-	request = tty->buffer;
-	request->size = cpu_to_le16(size);
-	memcpy(&request->data[0], data, size);
-	ret = gb_operation_sync(tty->connection, GB_UART_TYPE_SEND_DATA,
-				request, sizeof(*request) + size, NULL, 0);
-	if (ret)
-		return ret;
-	else
-		return size;
+	while (1) {
+		if (gb_tty->close_pending)
+			break;
+
+		spin_lock_irqsave(&gb_tty->write_lock, flags);
+		send_size = kfifo_out_peek(&gb_tty->write_fifo,
+					&request->data[0],
+					gb_tty->buffer_payload_max);
+		if (!send_size) {
+			spin_unlock_irqrestore(&gb_tty->write_lock, flags);
+			break;
+		}
+
+		spin_unlock_irqrestore(&gb_tty->write_lock, flags);
+
+		request->size = cpu_to_le16(send_size);
+		ret = gb_operation_sync(gb_tty->connection,
+					GB_UART_TYPE_SEND_DATA,
+					request, sizeof(*request) + send_size,
+					NULL, 0);
+		if (ret) {
+			dev_err(&gb_tty->gbphy_dev->dev,
+				"send data error: %d\n", ret);
+			if (!gb_tty->close_pending)
+				schedule_work(work);
+			return;
+		}
+
+		spin_lock_irqsave(&gb_tty->write_lock, flags);
+		ret = kfifo_out(&gb_tty->write_fifo, &request->data[0],
+				send_size);
+		spin_unlock_irqrestore(&gb_tty->write_lock, flags);
+
+		tty_port_tty_wakeup(&gb_tty->port);
+	}
 }
 
 static int send_line_coding(struct gb_tty *tty)
@@ -318,19 +353,42 @@ static int gb_tty_write(struct tty_struct *tty, const unsigned char *buf,
 {
 	struct gb_tty *gb_tty = tty->driver_data;
 
-	return send_data(gb_tty, count, buf);
+	count =  kfifo_in_spinlocked(&gb_tty->write_fifo, buf, count,
+					&gb_tty->write_lock);
+	if (count && !gb_tty->close_pending)
+		schedule_work(&gb_tty->tx_work);
+
+	return count;
 }
 
 static int gb_tty_write_room(struct tty_struct *tty)
 {
 	struct gb_tty *gb_tty = tty->driver_data;
+	unsigned long flags;
+	int room;
+
+	spin_lock_irqsave(&gb_tty->write_lock, flags);
+	room = kfifo_avail(&gb_tty->write_fifo);
+	spin_unlock_irqrestore(&gb_tty->write_lock, flags);
+
+	room -= GB_UART_WRITE_ROOM_MARGIN;
+	if (room < 0)
+		return 0;
 
-	return gb_tty->buffer_payload_max;
+	return room;
 }
 
 static int gb_tty_chars_in_buffer(struct tty_struct *tty)
 {
-	return 0;
+	struct gb_tty *gb_tty = tty->driver_data;
+	unsigned long flags;
+	int chars;
+
+	spin_lock_irqsave(&gb_tty->write_lock, flags);
+	chars = kfifo_len(&gb_tty->write_fifo);
+	spin_unlock_irqrestore(&gb_tty->write_lock, flags);
+
+	return chars;
 }
 
 static int gb_tty_break_ctl(struct tty_struct *tty, int state)
@@ -621,6 +679,24 @@ static void gb_tty_dtr_rts(struct tty_port *port, int on)
 	send_control(gb_tty, newctrl);
 }
 
+static void gb_tty_port_shutdown(struct tty_port *port)
+{
+	struct gb_tty *gb_tty;
+	unsigned long flags;
+
+	gb_tty = container_of(port, struct gb_tty, port);
+
+	gb_tty->close_pending = true;
+
+	cancel_work_sync(&gb_tty->tx_work);
+
+	spin_lock_irqsave(&gb_tty->write_lock, flags);
+	kfifo_reset_out(&gb_tty->write_fifo);
+	spin_unlock_irqrestore(&gb_tty->write_lock, flags);
+
+	gb_tty->close_pending = false;
+}
+
 static const struct tty_operations gb_ops = {
 	.install =		gb_tty_install,
 	.open =			gb_tty_open,
@@ -641,6 +717,7 @@ static const struct tty_operations gb_ops = {
 
 static struct tty_port_operations gb_port_ops = {
 	.dtr_rts =		gb_tty_dtr_rts,
+	.shutdown =		gb_tty_port_shutdown,
 };
 
 static int gb_uart_probe(struct gbphy_device *gbphy_dev,
@@ -680,6 +757,13 @@ static int gb_uart_probe(struct gbphy_device *gbphy_dev,
 		goto exit_connection_destroy;
 	}
 
+	INIT_WORK(&gb_tty->tx_work, gb_uart_tx_write_work);
+
+	retval = kfifo_alloc(&gb_tty->write_fifo, GB_UART_WRITE_FIFO_SIZE,
+				GFP_KERNEL);
+	if (retval)
+		goto exit_buf_free;
+
 	minor = alloc_minor(gb_tty);
 	if (minor < 0) {
 		if (minor == -ENOSPC) {
@@ -689,7 +773,7 @@ static int gb_uart_probe(struct gbphy_device *gbphy_dev,
 		} else {
 			retval = minor;
 		}
-		goto exit_buf_free;
+		goto exit_kfifo_free;
 	}
 
 	gb_tty->minor = minor;
@@ -741,6 +825,8 @@ static int gb_uart_probe(struct gbphy_device *gbphy_dev,
 	gb_connection_disable(connection);
 exit_release_minor:
 	release_minor(gb_tty);
+exit_kfifo_free:
+	kfifo_free(&gb_tty->write_fifo);
 exit_buf_free:
 	kfree(gb_tty->buffer);
 exit_connection_destroy:
@@ -777,6 +863,7 @@ static void gb_uart_remove(struct gbphy_device *gbphy_dev)
 	gb_connection_disable(connection);
 	tty_port_destroy(&gb_tty->port);
 	gb_connection_destroy(connection);
+	kfifo_free(&gb_tty->write_fifo);
 	kfree(gb_tty->buffer);
 	kfree(gb_tty);
 }

commit 219ffcf3a51d0e0d8464d42db01e1e745a0d690f
Author: Axel Haslam <ahaslam@baylibre.com>
Date:   Tue May 31 14:36:09 2016 +0200

    greybus: uart: Implement dtr_rts callback.
    
    Dtr_dts allows the tty layer to set the flow control lines
    to the correct state during open and close.
    
    Note that locking for newctrl is missing throughout the
    driver and will be addressed on a separate patch.
    
    Suggested-and-reviewed-by: Johan Hovold <johan@hovoldconsulting.com>
    Signed-off-by: Axel Haslam <ahaslam@baylibre.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/uart.c b/drivers/staging/greybus/uart.c
index 44d8b9ad183a..c257fbf40b79 100644
--- a/drivers/staging/greybus/uart.c
+++ b/drivers/staging/greybus/uart.c
@@ -604,6 +604,22 @@ static int gb_tty_ioctl(struct tty_struct *tty, unsigned int cmd,
 	return -ENOIOCTLCMD;
 }
 
+static void gb_tty_dtr_rts(struct tty_port *port, int on)
+{
+	struct gb_tty *gb_tty;
+	u8 newctrl;
+
+	gb_tty = container_of(port, struct gb_tty, port);
+	newctrl = gb_tty->ctrlout;
+
+	if (on)
+		newctrl |= (GB_UART_CTRL_DTR | GB_UART_CTRL_RTS);
+	else
+		newctrl &= ~(GB_UART_CTRL_DTR | GB_UART_CTRL_RTS);
+
+	gb_tty->ctrlout = newctrl;
+	send_control(gb_tty, newctrl);
+}
 
 static const struct tty_operations gb_ops = {
 	.install =		gb_tty_install,
@@ -623,7 +639,9 @@ static const struct tty_operations gb_ops = {
 	.tiocmset =		gb_tty_tiocmset,
 };
 
-static struct tty_port_operations null_ops = { };
+static struct tty_port_operations gb_port_ops = {
+	.dtr_rts =		gb_tty_dtr_rts,
+};
 
 static int gb_uart_probe(struct gbphy_device *gbphy_dev,
 			 const struct gbphy_device_id *id)
@@ -681,7 +699,7 @@ static int gb_uart_probe(struct gbphy_device *gbphy_dev,
 	mutex_init(&gb_tty->mutex);
 
 	tty_port_init(&gb_tty->port);
-	gb_tty->port.ops = &null_ops;
+	gb_tty->port.ops = &gb_port_ops;
 
 	gb_tty->connection = connection;
 	gb_tty->gbphy_dev = gbphy_dev;

commit e55c25206d5c99b12443eec37b4832d6817170ba
Author: Axel Haslam <ahaslam@baylibre.com>
Date:   Tue May 31 14:36:08 2016 +0200

    greybus: uart: Handle CRTSCTS flag in termios
    
    Handle the CRTSCTS flag in set_termios, so that auto
    flow control can be turned off. For this, add a new flag
    in the line coding request specifically for this purpose.
    
    Reviewed-by: Johan Hovold <johan@hovoldconsulting.com>
    Signed-off-by: Axel Haslam <ahaslam@baylibre.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/uart.c b/drivers/staging/greybus/uart.c
index 5d8f4e8095d9..44d8b9ad183a 100644
--- a/drivers/staging/greybus/uart.c
+++ b/drivers/staging/greybus/uart.c
@@ -39,6 +39,7 @@ struct gb_tty_line_coding {
 	__u8	format;
 	__u8	parity;
 	__u8	data_bits;
+	__u8	flow_control;
 };
 
 struct gb_tty {
@@ -375,9 +376,9 @@ static void gb_tty_set_termios(struct tty_struct *tty,
 
 	if (C_BAUD(tty) == B0) {
 		newline.rate = gb_tty->line_coding.rate;
-		newctrl &= ~GB_UART_CTRL_DTR;
+		newctrl &= ~(GB_UART_CTRL_DTR | GB_UART_CTRL_RTS);
 	} else if (termios_old && (termios_old->c_cflag & CBAUD) == B0) {
-		newctrl |= GB_UART_CTRL_DTR;
+		newctrl |= (GB_UART_CTRL_DTR | GB_UART_CTRL_RTS);
 	}
 
 	if (newctrl != gb_tty->ctrlout) {
@@ -385,6 +386,11 @@ static void gb_tty_set_termios(struct tty_struct *tty,
 		send_control(gb_tty, newctrl);
 	}
 
+	if (C_CRTSCTS(tty) && C_BAUD(tty) != B0)
+		newline.flow_control |= GB_SERIAL_AUTO_RTSCTS_EN;
+	else
+		newline.flow_control &= ~GB_SERIAL_AUTO_RTSCTS_EN;
+
 	if (memcmp(&gb_tty->line_coding, &newline, sizeof(newline))) {
 		memcpy(&gb_tty->line_coding, &newline, sizeof(newline));
 		send_line_coding(gb_tty);

commit e54b106dd1be50377fe8365392466e080b659ab6
Author: Sandeep Patil <patil_sandeep@projectara.com>
Date:   Thu May 19 08:52:39 2016 -0700

    greybus: gpbridge: rename 'gpbridge' to 'gbphy' everywhere
    
    The 'gpbridge' name didn't relaly reflect what the bus is; which
    is a bus for bridged-phy devices. So, rename all instances
    of 'gpbridge' to more appropriate 'gbphy'
    
    Testing Done:
    Build and boot tested. 'lsgb' will stop displaying 'GPBridge' devices
    until I change the library to reflect this change.
    
    Signed-off-by: Sandeep Patil <patil_sandeep@projectara.com>
    Suggested-by: Greg Kroah-Hartman <gregkh@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/uart.c b/drivers/staging/greybus/uart.c
index 75fa527acf15..5d8f4e8095d9 100644
--- a/drivers/staging/greybus/uart.c
+++ b/drivers/staging/greybus/uart.c
@@ -29,7 +29,7 @@
 #include <linux/kdev_t.h>
 
 #include "greybus.h"
-#include "gpbridge.h"
+#include "gbphy.h"
 
 #define GB_NUM_MINORS	16	/* 16 is is more than enough */
 #define GB_NAME		"ttyGB"
@@ -42,7 +42,7 @@ struct gb_tty_line_coding {
 };
 
 struct gb_tty {
-	struct gpbridge_device *gpbdev;
+	struct gbphy_device *gbphy_dev;
 	struct tty_port port;
 	void *buffer;
 	size_t buffer_payload_max;
@@ -78,7 +78,7 @@ static int gb_uart_receive_data_handler(struct gb_operation *op)
 	unsigned long tty_flags = TTY_NORMAL;
 
 	if (request->payload_size < sizeof(*receive_data)) {
-		dev_err(&gb_tty->gpbdev->dev,
+		dev_err(&gb_tty->gbphy_dev->dev,
 				"short receive-data request received (%zu < %zu)\n",
 				request->payload_size, sizeof(*receive_data));
 		return -EINVAL;
@@ -88,7 +88,7 @@ static int gb_uart_receive_data_handler(struct gb_operation *op)
 	recv_data_size = le16_to_cpu(receive_data->size);
 
 	if (recv_data_size != request->payload_size - sizeof(*receive_data)) {
-		dev_err(&gb_tty->gpbdev->dev,
+		dev_err(&gb_tty->gbphy_dev->dev,
 				"malformed receive-data request received (%u != %zu)\n",
 				recv_data_size,
 				request->payload_size - sizeof(*receive_data));
@@ -113,7 +113,7 @@ static int gb_uart_receive_data_handler(struct gb_operation *op)
 	count = tty_insert_flip_string_fixed_flag(port, receive_data->data,
 						  tty_flags, recv_data_size);
 	if (count != recv_data_size) {
-		dev_err(&gb_tty->gpbdev->dev,
+		dev_err(&gb_tty->gbphy_dev->dev,
 			"UART: RX 0x%08x bytes only wrote 0x%08x\n",
 			recv_data_size, count);
 	}
@@ -130,7 +130,7 @@ static int gb_uart_serial_state_handler(struct gb_operation *op)
 	struct gb_uart_serial_state_request *serial_state;
 
 	if (request->payload_size < sizeof(*serial_state)) {
-		dev_err(&gb_tty->gpbdev->dev,
+		dev_err(&gb_tty->gbphy_dev->dev,
 				"short serial-state event received (%zu < %zu)\n",
 				request->payload_size, sizeof(*serial_state));
 		return -EINVAL;
@@ -157,7 +157,7 @@ static int gb_uart_request_handler(struct gb_operation *op)
 		ret = gb_uart_serial_state_handler(op);
 		break;
 	default:
-		dev_err(&gb_tty->gpbdev->dev,
+		dev_err(&gb_tty->gbphy_dev->dev,
 			"unsupported unsolicited request: 0x%02x\n", type);
 		ret = -EINVAL;
 	}
@@ -211,7 +211,7 @@ static int send_break(struct gb_tty *gb_tty, u8 state)
 	struct gb_uart_set_break_request request;
 
 	if ((state != 0) && (state != 1)) {
-		dev_err(&gb_tty->gpbdev->dev,
+		dev_err(&gb_tty->gbphy_dev->dev,
 			"invalid break state of %d\n", state);
 		return -EINVAL;
 	}
@@ -619,8 +619,8 @@ static const struct tty_operations gb_ops = {
 
 static struct tty_port_operations null_ops = { };
 
-static int gb_uart_probe(struct gpbridge_device *gpbdev,
-			 const struct gpbridge_device_id *id)
+static int gb_uart_probe(struct gbphy_device *gbphy_dev,
+			 const struct gbphy_device_id *id)
 {
 	struct gb_connection *connection;
 	size_t max_payload;
@@ -633,8 +633,8 @@ static int gb_uart_probe(struct gpbridge_device *gpbdev,
 	if (!gb_tty)
 		return -ENOMEM;
 
-	connection = gb_connection_create(gpbdev->bundle,
-					  le16_to_cpu(gpbdev->cport_desc->id),
+	connection = gb_connection_create(gbphy_dev->bundle,
+					  le16_to_cpu(gbphy_dev->cport_desc->id),
 					  gb_uart_request_handler);
 	if (IS_ERR(connection)) {
 		retval = PTR_ERR(connection);
@@ -678,15 +678,15 @@ static int gb_uart_probe(struct gpbridge_device *gpbdev,
 	gb_tty->port.ops = &null_ops;
 
 	gb_tty->connection = connection;
-	gb_tty->gpbdev = gpbdev;
+	gb_tty->gbphy_dev = gbphy_dev;
 	gb_connection_set_data(connection, gb_tty);
-	gb_gpbridge_set_data(gpbdev, gb_tty);
+	gb_gbphy_set_data(gbphy_dev, gb_tty);
 
 	retval = gb_connection_enable_tx(connection);
 	if (retval)
 		goto exit_release_minor;
 
-	retval = gb_gpbridge_get_version(connection);
+	retval = gb_gbphy_get_version(connection);
 	if (retval)
 		goto exit_connection_disable;
 
@@ -704,7 +704,7 @@ static int gb_uart_probe(struct gpbridge_device *gpbdev,
 		goto exit_connection_disable;
 
 	tty_dev = tty_port_register_device(&gb_tty->port, gb_tty_driver, minor,
-					   &gpbdev->dev);
+					   &gbphy_dev->dev);
 	if (IS_ERR(tty_dev)) {
 		retval = PTR_ERR(tty_dev);
 		goto exit_connection_disable;
@@ -727,9 +727,9 @@ static int gb_uart_probe(struct gpbridge_device *gpbdev,
 	return retval;
 }
 
-static void gb_uart_remove(struct gpbridge_device *gpbdev)
+static void gb_uart_remove(struct gbphy_device *gbphy_dev)
 {
-	struct gb_tty *gb_tty = gb_gpbridge_get_data(gpbdev);
+	struct gb_tty *gb_tty = gb_gbphy_get_data(gbphy_dev);
 	struct gb_connection *connection = gb_tty->connection;
 	struct tty_struct *tty;
 
@@ -800,13 +800,13 @@ static void gb_tty_exit(void)
 	idr_destroy(&tty_minors);
 }
 
-static const struct gpbridge_device_id gb_uart_id_table[] = {
-	{ GPBRIDGE_PROTOCOL(GREYBUS_PROTOCOL_UART) },
+static const struct gbphy_device_id gb_uart_id_table[] = {
+	{ GBPHY_PROTOCOL(GREYBUS_PROTOCOL_UART) },
 	{ },
 };
-MODULE_DEVICE_TABLE(gpbridge, gb_uart_id_table);
+MODULE_DEVICE_TABLE(gbphy, gb_uart_id_table);
 
-static struct gpbridge_driver uart_driver = {
+static struct gbphy_driver uart_driver = {
 	.name		= "uart",
 	.probe		= gb_uart_probe,
 	.remove		= gb_uart_remove,
@@ -821,7 +821,7 @@ static int gb_uart_driver_init(void)
 	if (ret)
 		return ret;
 
-	ret = gb_gpbridge_register(&uart_driver);
+	ret = gb_gbphy_register(&uart_driver);
 	if (ret) {
 		gb_tty_exit();
 		return ret;
@@ -833,7 +833,7 @@ module_init(gb_uart_driver_init);
 
 static void gb_uart_driver_exit(void)
 {
-	gb_gpbridge_deregister(&uart_driver);
+	gb_gbphy_deregister(&uart_driver);
 	gb_tty_exit();
 }
 

commit 9bc63b7ff56f7a1cad5dbf062d1d5dd7a81d7d93
Author: Axel Haslam <ahaslam@baylibre.com>
Date:   Mon May 16 17:39:32 2016 +0200

    greybus: uart fix missing negation on DTR setting
    
    The unset the DTR flag is missing "~"
    
    Signed-off-by: Axel Haslam <ahaslam@baylibre.com>
    Reviewed-by: Johan Hovold <johan@hovoldconsulting.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/uart.c b/drivers/staging/greybus/uart.c
index aa28ce5c4fb0..75fa527acf15 100644
--- a/drivers/staging/greybus/uart.c
+++ b/drivers/staging/greybus/uart.c
@@ -375,7 +375,7 @@ static void gb_tty_set_termios(struct tty_struct *tty,
 
 	if (C_BAUD(tty) == B0) {
 		newline.rate = gb_tty->line_coding.rate;
-		newctrl &= GB_UART_CTRL_DTR;
+		newctrl &= ~GB_UART_CTRL_DTR;
 	} else if (termios_old && (termios_old->c_cflag & CBAUD) == B0) {
 		newctrl |= GB_UART_CTRL_DTR;
 	}

commit 66b9e09e28b0c32d9b071fc9084bbb8880b88d74
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Mon May 9 18:15:11 2016 +0530

    greybus: uart: Create separate module
    
    Create separate module for uart gpbridge driver.
    
    Tested on EVT 1.5 by inserting GP test module, all the devices were
    enumerated correctly.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/uart.c b/drivers/staging/greybus/uart.c
index 0d8fcb55d9aa..aa28ce5c4fb0 100644
--- a/drivers/staging/greybus/uart.c
+++ b/drivers/staging/greybus/uart.c
@@ -804,6 +804,7 @@ static const struct gpbridge_device_id gb_uart_id_table[] = {
 	{ GPBRIDGE_PROTOCOL(GREYBUS_PROTOCOL_UART) },
 	{ },
 };
+MODULE_DEVICE_TABLE(gpbridge, gb_uart_id_table);
 
 static struct gpbridge_driver uart_driver = {
 	.name		= "uart",
@@ -812,7 +813,7 @@ static struct gpbridge_driver uart_driver = {
 	.id_table	= gb_uart_id_table,
 };
 
-int gb_uart_driver_init(void)
+static int gb_uart_driver_init(void)
 {
 	int ret;
 
@@ -828,9 +829,13 @@ int gb_uart_driver_init(void)
 
 	return 0;
 }
+module_init(gb_uart_driver_init);
 
-void gb_uart_driver_exit(void)
+static void gb_uart_driver_exit(void)
 {
 	gb_gpbridge_deregister(&uart_driver);
 	gb_tty_exit();
 }
+
+module_exit(gb_uart_driver_exit);
+MODULE_LICENSE("GPL v2");

commit 73d292d8381d9c384796c876ba752ccd18a09d1f
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Thu May 5 14:32:38 2016 +0530

    greybus: uart: Kill reference_count hack
    
    This was done long back and was probably the best bet then, but it looks
    really bad to have it this way now.
    
    Kill the hack and implement proper driver init()/exit() routines to do
    the same thing.
    
    Tested using gbsim by hotplugging uart manifest and removing it later.
    Also tried removing the gb-phy module to test the exit path properly.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/uart.c b/drivers/staging/greybus/uart.c
index eb83c04d7b69..0d8fcb55d9aa 100644
--- a/drivers/staging/greybus/uart.c
+++ b/drivers/staging/greybus/uart.c
@@ -65,7 +65,6 @@ struct gb_tty {
 static struct tty_driver *gb_tty_driver;
 static DEFINE_IDR(tty_minors);
 static DEFINE_MUTEX(table_lock);
-static atomic_t reference_count = ATOMIC_INIT(0);
 
 static int gb_uart_receive_data_handler(struct gb_operation *op)
 {
@@ -553,6 +552,7 @@ static int wait_serial_change(struct gb_tty *gb_tty, unsigned long arg)
 	} while (!retval);
 
 	return retval;
+
 }
 
 static int get_serial_usage(struct gb_tty *gb_tty,
@@ -619,9 +619,6 @@ static const struct tty_operations gb_ops = {
 
 static struct tty_port_operations null_ops = { };
 
-static int gb_tty_init(void);
-static void gb_tty_exit(void);
-
 static int gb_uart_probe(struct gpbridge_device *gpbdev,
 			 const struct gpbridge_device_id *id)
 {
@@ -632,20 +629,9 @@ static int gb_uart_probe(struct gpbridge_device *gpbdev,
 	int retval;
 	int minor;
 
-	/* First time here, initialize the tty structures */
-	if (atomic_inc_return(&reference_count) == 1) {
-		retval = gb_tty_init();
-		if (retval) {
-			atomic_dec(&reference_count);
-			return retval;
-		}
-	}
-
 	gb_tty = kzalloc(sizeof(*gb_tty), GFP_KERNEL);
-	if (!gb_tty) {
-		retval = -ENOMEM;
-		goto exit_tty;
-	}
+	if (!gb_tty)
+		return -ENOMEM;
 
 	connection = gb_connection_create(gpbdev->bundle,
 					  le16_to_cpu(gpbdev->cport_desc->id),
@@ -737,9 +723,6 @@ static int gb_uart_probe(struct gpbridge_device *gpbdev,
 	gb_connection_destroy(connection);
 exit_tty_free:
 	kfree(gb_tty);
-exit_tty:
-	if (atomic_dec_return(&reference_count) == 0)
-		gb_tty_exit();
 
 	return retval;
 }
@@ -772,10 +755,6 @@ static void gb_uart_remove(struct gpbridge_device *gpbdev)
 	gb_connection_destroy(connection);
 	kfree(gb_tty->buffer);
 	kfree(gb_tty);
-
-	/* If last device is gone, tear down the tty structures */
-	if (atomic_dec_return(&reference_count) == 0)
-		gb_tty_exit();
 }
 
 static int gb_tty_init(void)
@@ -832,4 +811,26 @@ static struct gpbridge_driver uart_driver = {
 	.remove		= gb_uart_remove,
 	.id_table	= gb_uart_id_table,
 };
-gb_gpbridge_builtin_driver(uart_driver);
+
+int gb_uart_driver_init(void)
+{
+	int ret;
+
+	ret = gb_tty_init();
+	if (ret)
+		return ret;
+
+	ret = gb_gpbridge_register(&uart_driver);
+	if (ret) {
+		gb_tty_exit();
+		return ret;
+	}
+
+	return 0;
+}
+
+void gb_uart_driver_exit(void)
+{
+	gb_gpbridge_deregister(&uart_driver);
+	gb_tty_exit();
+}

commit 7dbe1f497b445ead3a6c5f0895d002960a2b07f2
Author: Greg Kroah-Hartman <gregkh@google.com>
Date:   Thu May 5 14:32:30 2016 +0530

    greybus: UART: convert to a gpbridge driver
    
    This converts the UART driver to be a gpbridge driver, moving it away
    from the "legacy" interface.
    
    Testing Done: Tested on gbsim.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>
    Signed-off-by: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
    [vaibhav.hiremath@linaro.org: 1.Changed code to retain init/exit fns of
    drivers. 2.Exit path fix. 3. Fixed review comments]
    Reviewed-by: Viresh Kumar <viresh.kumar@linaro.org>
    Tested-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/uart.c b/drivers/staging/greybus/uart.c
index be718918c135..eb83c04d7b69 100644
--- a/drivers/staging/greybus/uart.c
+++ b/drivers/staging/greybus/uart.c
@@ -42,6 +42,7 @@ struct gb_tty_line_coding {
 };
 
 struct gb_tty {
+	struct gpbridge_device *gpbdev;
 	struct tty_port port;
 	void *buffer;
 	size_t buffer_payload_max;
@@ -78,7 +79,7 @@ static int gb_uart_receive_data_handler(struct gb_operation *op)
 	unsigned long tty_flags = TTY_NORMAL;
 
 	if (request->payload_size < sizeof(*receive_data)) {
-		dev_err(&connection->bundle->dev,
+		dev_err(&gb_tty->gpbdev->dev,
 				"short receive-data request received (%zu < %zu)\n",
 				request->payload_size, sizeof(*receive_data));
 		return -EINVAL;
@@ -88,7 +89,7 @@ static int gb_uart_receive_data_handler(struct gb_operation *op)
 	recv_data_size = le16_to_cpu(receive_data->size);
 
 	if (recv_data_size != request->payload_size - sizeof(*receive_data)) {
-		dev_err(&connection->bundle->dev,
+		dev_err(&gb_tty->gpbdev->dev,
 				"malformed receive-data request received (%u != %zu)\n",
 				recv_data_size,
 				request->payload_size - sizeof(*receive_data));
@@ -113,7 +114,7 @@ static int gb_uart_receive_data_handler(struct gb_operation *op)
 	count = tty_insert_flip_string_fixed_flag(port, receive_data->data,
 						  tty_flags, recv_data_size);
 	if (count != recv_data_size) {
-		dev_err(&connection->bundle->dev,
+		dev_err(&gb_tty->gpbdev->dev,
 			"UART: RX 0x%08x bytes only wrote 0x%08x\n",
 			recv_data_size, count);
 	}
@@ -130,7 +131,7 @@ static int gb_uart_serial_state_handler(struct gb_operation *op)
 	struct gb_uart_serial_state_request *serial_state;
 
 	if (request->payload_size < sizeof(*serial_state)) {
-		dev_err(&connection->bundle->dev,
+		dev_err(&gb_tty->gpbdev->dev,
 				"short serial-state event received (%zu < %zu)\n",
 				request->payload_size, sizeof(*serial_state));
 		return -EINVAL;
@@ -142,9 +143,11 @@ static int gb_uart_serial_state_handler(struct gb_operation *op)
 	return 0;
 }
 
-static int gb_uart_request_recv(u8 type, struct gb_operation *op)
+static int gb_uart_request_handler(struct gb_operation *op)
 {
 	struct gb_connection *connection = op->connection;
+	struct gb_tty *gb_tty = gb_connection_get_data(connection);
+	int type = op->type;
 	int ret;
 
 	switch (type) {
@@ -155,7 +158,7 @@ static int gb_uart_request_recv(u8 type, struct gb_operation *op)
 		ret = gb_uart_serial_state_handler(op);
 		break;
 	default:
-		dev_err(&connection->bundle->dev,
+		dev_err(&gb_tty->gpbdev->dev,
 			"unsupported unsolicited request: 0x%02x\n", type);
 		ret = -EINVAL;
 	}
@@ -209,7 +212,7 @@ static int send_break(struct gb_tty *gb_tty, u8 state)
 	struct gb_uart_set_break_request request;
 
 	if ((state != 0) && (state != 1)) {
-		dev_err(&gb_tty->connection->bundle->dev,
+		dev_err(&gb_tty->gpbdev->dev,
 			"invalid break state of %d\n", state);
 		return -EINVAL;
 	}
@@ -619,8 +622,10 @@ static struct tty_port_operations null_ops = { };
 static int gb_tty_init(void);
 static void gb_tty_exit(void);
 
-static int gb_uart_connection_init(struct gb_connection *connection)
+static int gb_uart_probe(struct gpbridge_device *gpbdev,
+			 const struct gpbridge_device_id *id)
 {
+	struct gb_connection *connection;
 	size_t max_payload;
 	struct gb_tty *gb_tty;
 	struct device *tty_dev;
@@ -639,13 +644,21 @@ static int gb_uart_connection_init(struct gb_connection *connection)
 	gb_tty = kzalloc(sizeof(*gb_tty), GFP_KERNEL);
 	if (!gb_tty) {
 		retval = -ENOMEM;
-		goto error_alloc;
+		goto exit_tty;
+	}
+
+	connection = gb_connection_create(gpbdev->bundle,
+					  le16_to_cpu(gpbdev->cport_desc->id),
+					  gb_uart_request_handler);
+	if (IS_ERR(connection)) {
+		retval = PTR_ERR(connection);
+		goto exit_tty_free;
 	}
 
 	max_payload = gb_operation_get_payload_size_max(connection);
 	if (max_payload < sizeof(struct gb_uart_send_data_request)) {
 		retval = -EINVAL;
-		goto error_payload;
+		goto exit_connection_destroy;
 	}
 
 	gb_tty->buffer_payload_max = max_payload -
@@ -654,22 +667,19 @@ static int gb_uart_connection_init(struct gb_connection *connection)
 	gb_tty->buffer = kzalloc(gb_tty->buffer_payload_max, GFP_KERNEL);
 	if (!gb_tty->buffer) {
 		retval = -ENOMEM;
-		goto error_payload;
+		goto exit_connection_destroy;
 	}
 
-	gb_tty->connection = connection;
-	gb_connection_set_data(connection, gb_tty);
-
 	minor = alloc_minor(gb_tty);
 	if (minor < 0) {
 		if (minor == -ENOSPC) {
 			dev_err(&connection->bundle->dev,
 				"no more free minor numbers\n");
 			retval = -ENODEV;
-			goto error_minor;
+		} else {
+			retval = minor;
 		}
-		retval = minor;
-		goto error_minor;
+		goto exit_buf_free;
 	}
 
 	gb_tty->minor = minor;
@@ -681,6 +691,19 @@ static int gb_uart_connection_init(struct gb_connection *connection)
 	tty_port_init(&gb_tty->port);
 	gb_tty->port.ops = &null_ops;
 
+	gb_tty->connection = connection;
+	gb_tty->gpbdev = gpbdev;
+	gb_connection_set_data(connection, gb_tty);
+	gb_gpbridge_set_data(gpbdev, gb_tty);
+
+	retval = gb_connection_enable_tx(connection);
+	if (retval)
+		goto exit_release_minor;
+
+	retval = gb_gpbridge_get_version(connection);
+	if (retval)
+		goto exit_connection_disable;
+
 	send_control(gb_tty, gb_tty->ctrlout);
 
 	/* initialize the uart to be 9600n81 */
@@ -690,41 +713,47 @@ static int gb_uart_connection_init(struct gb_connection *connection)
 	gb_tty->line_coding.data_bits = 8;
 	send_line_coding(gb_tty);
 
+	retval = gb_connection_enable(connection);
+	if (retval)
+		goto exit_connection_disable;
+
 	tty_dev = tty_port_register_device(&gb_tty->port, gb_tty_driver, minor,
-					   &connection->bundle->dev);
+					   &gpbdev->dev);
 	if (IS_ERR(tty_dev)) {
 		retval = PTR_ERR(tty_dev);
-		goto error;
+		goto exit_connection_disable;
 	}
 
+
 	return 0;
-error:
-	tty_port_destroy(&gb_tty->port);
+
+exit_connection_disable:
+	gb_connection_disable(connection);
+exit_release_minor:
 	release_minor(gb_tty);
-error_minor:
-	gb_connection_set_data(connection, NULL);
+exit_buf_free:
 	kfree(gb_tty->buffer);
-error_payload:
+exit_connection_destroy:
+	gb_connection_destroy(connection);
+exit_tty_free:
 	kfree(gb_tty);
-error_alloc:
+exit_tty:
 	if (atomic_dec_return(&reference_count) == 0)
 		gb_tty_exit();
+
 	return retval;
 }
 
-static void gb_uart_connection_exit(struct gb_connection *connection)
+static void gb_uart_remove(struct gpbridge_device *gpbdev)
 {
-	struct gb_tty *gb_tty = gb_connection_get_data(connection);
+	struct gb_tty *gb_tty = gb_gpbridge_get_data(gpbdev);
+	struct gb_connection *connection = gb_tty->connection;
 	struct tty_struct *tty;
 
-	if (!gb_tty)
-		return;
-
 	mutex_lock(&gb_tty->mutex);
 	gb_tty->disconnected = true;
 
 	wake_up_all(&gb_tty->wioctl);
-	gb_connection_set_data(connection, NULL);
 	mutex_unlock(&gb_tty->mutex);
 
 	tty = tty_port_tty_get(&gb_tty->port);
@@ -732,13 +761,15 @@ static void gb_uart_connection_exit(struct gb_connection *connection)
 		tty_vhangup(tty);
 		tty_kref_put(tty);
 	}
-	/* FIXME - stop all traffic */
 
+	gb_connection_disable_rx(connection);
 	tty_unregister_device(gb_tty_driver, gb_tty->minor);
 
 	/* FIXME - free transmit / receive buffers */
 
+	gb_connection_disable(connection);
 	tty_port_destroy(&gb_tty->port);
+	gb_connection_destroy(connection);
 	kfree(gb_tty->buffer);
 	kfree(gb_tty);
 
@@ -790,14 +821,15 @@ static void gb_tty_exit(void)
 	idr_destroy(&tty_minors);
 }
 
-static struct gb_protocol uart_protocol = {
-	.name			= "uart",
-	.id			= GREYBUS_PROTOCOL_UART,
-	.major			= GB_UART_VERSION_MAJOR,
-	.minor			= GB_UART_VERSION_MINOR,
-	.connection_init	= gb_uart_connection_init,
-	.connection_exit	= gb_uart_connection_exit,
-	.request_recv		= gb_uart_request_recv,
+static const struct gpbridge_device_id gb_uart_id_table[] = {
+	{ GPBRIDGE_PROTOCOL(GREYBUS_PROTOCOL_UART) },
+	{ },
 };
 
-gb_builtin_protocol_driver(uart_protocol);
+static struct gpbridge_driver uart_driver = {
+	.name		= "uart",
+	.probe		= gb_uart_probe,
+	.remove		= gb_uart_remove,
+	.id_table	= gb_uart_id_table,
+};
+gb_gpbridge_builtin_driver(uart_driver);

commit b4b1b7eda9fe0d5a399d9095b2e8d5657726538c
Author: Axel Haslam <ahaslam@baylibre.com>
Date:   Wed Apr 20 20:47:20 2016 +0200

    greybus: uart: Update line coding settings only when needed
    
    The check for line coding changed should use memcmp and not memcpy.
    
    Testing done: trivial
    
    Reviewed-by: Johan Hovold <johan@hovoldconsulting.com>
    Signed-off-by: Axel Haslam <ahaslam@baylibre.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/uart.c b/drivers/staging/greybus/uart.c
index c580fe06f554..be718918c135 100644
--- a/drivers/staging/greybus/uart.c
+++ b/drivers/staging/greybus/uart.c
@@ -383,7 +383,7 @@ static void gb_tty_set_termios(struct tty_struct *tty,
 		send_control(gb_tty, newctrl);
 	}
 
-	if (memcpy(&gb_tty->line_coding, &newline, sizeof(newline))) {
+	if (memcmp(&gb_tty->line_coding, &newline, sizeof(newline))) {
 		memcpy(&gb_tty->line_coding, &newline, sizeof(newline));
 		send_line_coding(gb_tty);
 	}

commit 0ec306324423444d3ee0222708ef9de7f5586b93
Author: Greg Kroah-Hartman <gregkh@google.com>
Date:   Tue Mar 22 14:30:35 2016 -0400

    greybus: convert drivers to use connection->private set/get
    
    This converts all drivers to use the gb_connection_get_data() and
    gb_connection_set_data() functions to make it a bit more explicit as to
    what is going on.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>
    Reviewed-by: Alex Elder <elder@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/uart.c b/drivers/staging/greybus/uart.c
index d169c55b4552..c580fe06f554 100644
--- a/drivers/staging/greybus/uart.c
+++ b/drivers/staging/greybus/uart.c
@@ -69,7 +69,7 @@ static atomic_t reference_count = ATOMIC_INIT(0);
 static int gb_uart_receive_data_handler(struct gb_operation *op)
 {
 	struct gb_connection *connection = op->connection;
-	struct gb_tty *gb_tty = connection->private;
+	struct gb_tty *gb_tty = gb_connection_get_data(connection);
 	struct tty_port *port = &gb_tty->port;
 	struct gb_message *request = op->request;
 	struct gb_uart_recv_data_request *receive_data;
@@ -125,7 +125,7 @@ static int gb_uart_receive_data_handler(struct gb_operation *op)
 static int gb_uart_serial_state_handler(struct gb_operation *op)
 {
 	struct gb_connection *connection = op->connection;
-	struct gb_tty *gb_tty = connection->private;
+	struct gb_tty *gb_tty = gb_connection_get_data(connection);
 	struct gb_message *request = op->request;
 	struct gb_uart_serial_state_request *serial_state;
 
@@ -658,7 +658,7 @@ static int gb_uart_connection_init(struct gb_connection *connection)
 	}
 
 	gb_tty->connection = connection;
-	connection->private = gb_tty;
+	gb_connection_set_data(connection, gb_tty);
 
 	minor = alloc_minor(gb_tty);
 	if (minor < 0) {
@@ -702,7 +702,7 @@ static int gb_uart_connection_init(struct gb_connection *connection)
 	tty_port_destroy(&gb_tty->port);
 	release_minor(gb_tty);
 error_minor:
-	connection->private = NULL;
+	gb_connection_set_data(connection, NULL);
 	kfree(gb_tty->buffer);
 error_payload:
 	kfree(gb_tty);
@@ -714,7 +714,7 @@ static int gb_uart_connection_init(struct gb_connection *connection)
 
 static void gb_uart_connection_exit(struct gb_connection *connection)
 {
-	struct gb_tty *gb_tty = connection->private;
+	struct gb_tty *gb_tty = gb_connection_get_data(connection);
 	struct tty_struct *tty;
 
 	if (!gb_tty)
@@ -724,7 +724,7 @@ static void gb_uart_connection_exit(struct gb_connection *connection)
 	gb_tty->disconnected = true;
 
 	wake_up_all(&gb_tty->wioctl);
-	connection->private = NULL;
+	gb_connection_set_data(connection, NULL);
 	mutex_unlock(&gb_tty->mutex);
 
 	tty = tty_port_tty_get(&gb_tty->port);

commit c7b07265046b5db56778dc8c2cfc9056413ec5ba
Author: Greg Kroah-Hartman <gregkh@google.com>
Date:   Sun Feb 28 14:42:54 2016 -0800

    greybus: gpbridge.h: move protocol init/exit prototypes
    
    Create gpbridge.h for the gpbridge-specific function prototypes, the
    rest of the greybus drivers don't care about them.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>
    Reviewed-by: Viresh Kumar <viresh.kumar@linaro.org>
    Reviewed-by: Johan Hovold <johan@hovoldconsulting.com>

diff --git a/drivers/staging/greybus/uart.c b/drivers/staging/greybus/uart.c
index 0685cdcb510d..d169c55b4552 100644
--- a/drivers/staging/greybus/uart.c
+++ b/drivers/staging/greybus/uart.c
@@ -29,6 +29,7 @@
 #include <linux/kdev_t.h>
 
 #include "greybus.h"
+#include "gpbridge.h"
 
 #define GB_NUM_MINORS	16	/* 16 is is more than enough */
 #define GB_NAME		"ttyGB"

commit c5f338c4a040d7d6eefc560f3ee5cdb6ede03b74
Author: Johan Hovold <johan@hovoldconsulting.com>
Date:   Wed Feb 24 16:11:51 2016 +0100

    greybus: uart: fix incomplete receive-data sanity checks
    
    Fix incomplete receive-data sanity checks.
    
    The payload size was never verified before parsing the uart header and
    neither was the uart-header data size verified against the actual
    payload size, something which could lead to information leaks when
    passing data beyond the payload buffer to the tty layer.
    
    Also remove the incorrect check against the maximum (tx-buffer) payload
    size.
    
    Reviewed-by: Rui Miguel Silva <rui.silva@linaro.org>
    Signed-off-by: Johan Hovold <johan@hovoldconsulting.com>
    Reviewed-by: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/uart.c b/drivers/staging/greybus/uart.c
index c09a76bee269..0685cdcb510d 100644
--- a/drivers/staging/greybus/uart.c
+++ b/drivers/staging/greybus/uart.c
@@ -65,18 +65,36 @@ static DEFINE_IDR(tty_minors);
 static DEFINE_MUTEX(table_lock);
 static atomic_t reference_count = ATOMIC_INIT(0);
 
-static int gb_uart_receive_data(struct gb_tty *gb_tty,
-				struct gb_connection *connection,
-				struct gb_uart_recv_data_request *receive_data)
+static int gb_uart_receive_data_handler(struct gb_operation *op)
 {
+	struct gb_connection *connection = op->connection;
+	struct gb_tty *gb_tty = connection->private;
 	struct tty_port *port = &gb_tty->port;
+	struct gb_message *request = op->request;
+	struct gb_uart_recv_data_request *receive_data;
 	u16 recv_data_size;
 	int count;
 	unsigned long tty_flags = TTY_NORMAL;
 
-	count = gb_tty->buffer_payload_max - sizeof(*receive_data);
+	if (request->payload_size < sizeof(*receive_data)) {
+		dev_err(&connection->bundle->dev,
+				"short receive-data request received (%zu < %zu)\n",
+				request->payload_size, sizeof(*receive_data));
+		return -EINVAL;
+	}
+
+	receive_data = op->request->payload;
 	recv_data_size = le16_to_cpu(receive_data->size);
-	if (!recv_data_size || recv_data_size > count)
+
+	if (recv_data_size != request->payload_size - sizeof(*receive_data)) {
+		dev_err(&connection->bundle->dev,
+				"malformed receive-data request received (%u != %zu)\n",
+				recv_data_size,
+				request->payload_size - sizeof(*receive_data));
+		return -EINVAL;
+	}
+
+	if (!recv_data_size)
 		return -EINVAL;
 
 	if (receive_data->flags) {
@@ -126,14 +144,11 @@ static int gb_uart_serial_state_handler(struct gb_operation *op)
 static int gb_uart_request_recv(u8 type, struct gb_operation *op)
 {
 	struct gb_connection *connection = op->connection;
-	struct gb_tty *gb_tty = connection->private;
-	struct gb_message *request = op->request;
 	int ret;
 
 	switch (type) {
 	case GB_UART_TYPE_RECEIVE_DATA:
-		ret = gb_uart_receive_data(gb_tty, connection,
-					   request->payload);
+		ret = gb_uart_receive_data_handler(op);
 		break;
 	case GB_UART_TYPE_SERIAL_STATE:
 		ret = gb_uart_serial_state_handler(op);

commit cb7f00ba5f581ca2f0848dd2ed77f1b9d793c648
Author: Johan Hovold <johan@hovoldconsulting.com>
Date:   Wed Feb 24 16:11:50 2016 +0100

    greybus: uart: add missing serial-state sanity check
    
    Add dedicated serial-state request handler and add the missing sanity
    check on the incoming request.
    
    Reviewed-by: Rui Miguel Silva <rui.silva@linaro.org>
    Signed-off-by: Johan Hovold <johan@hovoldconsulting.com>
    Reviewed-by: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/uart.c b/drivers/staging/greybus/uart.c
index 60617cb69a5a..c09a76bee269 100644
--- a/drivers/staging/greybus/uart.c
+++ b/drivers/staging/greybus/uart.c
@@ -103,13 +103,32 @@ static int gb_uart_receive_data(struct gb_tty *gb_tty,
 	return 0;
 }
 
-static int gb_uart_request_recv(u8 type, struct gb_operation *op)
+static int gb_uart_serial_state_handler(struct gb_operation *op)
 {
 	struct gb_connection *connection = op->connection;
 	struct gb_tty *gb_tty = connection->private;
 	struct gb_message *request = op->request;
 	struct gb_uart_serial_state_request *serial_state;
-	int ret = 0;
+
+	if (request->payload_size < sizeof(*serial_state)) {
+		dev_err(&connection->bundle->dev,
+				"short serial-state event received (%zu < %zu)\n",
+				request->payload_size, sizeof(*serial_state));
+		return -EINVAL;
+	}
+
+	serial_state = request->payload;
+	gb_tty->ctrlin = serial_state->control;
+
+	return 0;
+}
+
+static int gb_uart_request_recv(u8 type, struct gb_operation *op)
+{
+	struct gb_connection *connection = op->connection;
+	struct gb_tty *gb_tty = connection->private;
+	struct gb_message *request = op->request;
+	int ret;
 
 	switch (type) {
 	case GB_UART_TYPE_RECEIVE_DATA:
@@ -117,8 +136,7 @@ static int gb_uart_request_recv(u8 type, struct gb_operation *op)
 					   request->payload);
 		break;
 	case GB_UART_TYPE_SERIAL_STATE:
-		serial_state = request->payload;
-		gb_tty->ctrlin = serial_state->control;
+		ret = gb_uart_serial_state_handler(op);
 		break;
 	default:
 		dev_err(&connection->bundle->dev,

commit 066f950c65c206c1a1a2f72f2c80134177ea3999
Author: Johan Hovold <johan@hovoldconsulting.com>
Date:   Wed Feb 24 16:11:49 2016 +0100

    greybus: uart: add max-payload sanity check
    
    Let's be well behaved and add a sanity check on the maximum greybus
    payload size to avoid underflow on the calculated buffer size.
    
    Reviewed-by: Rui Miguel Silva <rui.silva@linaro.org>
    Signed-off-by: Johan Hovold <johan@hovoldconsulting.com>
    Reviewed-by: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/uart.c b/drivers/staging/greybus/uart.c
index 52cc9d581ca4..60617cb69a5a 100644
--- a/drivers/staging/greybus/uart.c
+++ b/drivers/staging/greybus/uart.c
@@ -587,6 +587,7 @@ static void gb_tty_exit(void);
 
 static int gb_uart_connection_init(struct gb_connection *connection)
 {
+	size_t max_payload;
 	struct gb_tty *gb_tty;
 	struct device *tty_dev;
 	int retval;
@@ -607,8 +608,13 @@ static int gb_uart_connection_init(struct gb_connection *connection)
 		goto error_alloc;
 	}
 
-	gb_tty->buffer_payload_max =
-		gb_operation_get_payload_size_max(connection) -
+	max_payload = gb_operation_get_payload_size_max(connection);
+	if (max_payload < sizeof(struct gb_uart_send_data_request)) {
+		retval = -EINVAL;
+		goto error_payload;
+	}
+
+	gb_tty->buffer_payload_max = max_payload -
 			sizeof(struct gb_uart_send_data_request);
 
 	gb_tty->buffer = kzalloc(gb_tty->buffer_payload_max, GFP_KERNEL);

commit 7f29aded453e0392391b831c196583c274ec2cfd
Author: Greg Kroah-Hartman <gregkh@google.com>
Date:   Mon Feb 22 18:14:46 2016 -0800

    greybus: uart: properly calculate max buffer size
    
    We forgot to count the size of the uart send data message header when
    calculating the maximum size of the buffer that the uart driver could
    send in one chunk.
    
    This fixes the math and makes the variable a size_t to match the return
    value of the call to gb_operation_get_payload_size_max();
    
    Reported-by: Axel Haslam <ahaslam@baylibre.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>
    Tested-by: Axel Haslam <ahaslam@baylibre.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/uart.c b/drivers/staging/greybus/uart.c
index 46cce8c82412..52cc9d581ca4 100644
--- a/drivers/staging/greybus/uart.c
+++ b/drivers/staging/greybus/uart.c
@@ -43,7 +43,7 @@ struct gb_tty_line_coding {
 struct gb_tty {
 	struct tty_port port;
 	void *buffer;
-	u32 buffer_payload_max;
+	size_t buffer_payload_max;
 	struct gb_connection *connection;
 	u16 cport_id;
 	unsigned int minor;
@@ -608,11 +608,8 @@ static int gb_uart_connection_init(struct gb_connection *connection)
 	}
 
 	gb_tty->buffer_payload_max =
-		gb_operation_get_payload_size_max(connection);
-	if (!gb_tty->buffer_payload_max) {
-		retval = -EINVAL;
-		goto error_payload;
-	}
+		gb_operation_get_payload_size_max(connection) -
+			sizeof(struct gb_uart_send_data_request);
 
 	gb_tty->buffer = kzalloc(gb_tty->buffer_payload_max, GFP_KERNEL);
 	if (!gb_tty->buffer) {

commit 9d4bb6c9183f1283158bbb00ebf65ec4cf18ee33
Author: Rui Miguel Silva <rui.silva@linaro.org>
Date:   Fri Feb 5 13:50:37 2016 +0000

    greybus: uart: fix double free of tty port
    
    When inserting and removing a module with a UART protocol defined a
    double free of the tty_port would happen and that would generate a lot
    of kernel oops in different places related to memory corruption.
    
    Signed-off-by: Rui Miguel Silva <rui.silva@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/uart.c b/drivers/staging/greybus/uart.c
index 1ba8476ce982..46cce8c82412 100644
--- a/drivers/staging/greybus/uart.c
+++ b/drivers/staging/greybus/uart.c
@@ -701,7 +701,6 @@ static void gb_uart_connection_exit(struct gb_connection *connection)
 
 	/* FIXME - free transmit / receive buffers */
 
-	tty_port_put(&gb_tty->port);
 	tty_port_destroy(&gb_tty->port);
 	kfree(gb_tty->buffer);
 	kfree(gb_tty);

commit b933fa4a40962c77254405a5274c8927f53b5074
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Fri Dec 4 21:30:10 2015 +0530

    greybus: Prefix hexadecimal values with 0x while printing them
    
    To clearly specify the base for printed values, prefix hexadecimal
    values with 0x.
    
    Suggested-by: Johan Hovold <johan@hovoldconsulting.com>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Reviewed-by: Johan Hovold <johan@hovoldconsulting.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/uart.c b/drivers/staging/greybus/uart.c
index ec978a451b17..1ba8476ce982 100644
--- a/drivers/staging/greybus/uart.c
+++ b/drivers/staging/greybus/uart.c
@@ -122,7 +122,7 @@ static int gb_uart_request_recv(u8 type, struct gb_operation *op)
 		break;
 	default:
 		dev_err(&connection->bundle->dev,
-			"unsupported unsolicited request: %02x\n", type);
+			"unsupported unsolicited request: 0x%02x\n", type);
 		ret = -EINVAL;
 	}
 

commit 4f30bf3aef416ce6870a6da68e42957aeb4edb76
Author: Greg Kroah-Hartman <gregkh@google.com>
Date:   Wed Oct 14 11:15:12 2015 -0700

    greybus: uart: use the bundle struct device instead of the connector
    
    We are removing struct device from the gb_connection structure in the
    near future.  The gb_bundle structure's struct device should be used as
    a replacement.
    
    This patch moves the uart driver to use the bundle pointer instead of
    the connection pointer.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>
    Reviewed-by: Alex Elder <elder@linaro.org>

diff --git a/drivers/staging/greybus/uart.c b/drivers/staging/greybus/uart.c
index 9e8bf6f4b8d7..ec978a451b17 100644
--- a/drivers/staging/greybus/uart.c
+++ b/drivers/staging/greybus/uart.c
@@ -94,7 +94,7 @@ static int gb_uart_receive_data(struct gb_tty *gb_tty,
 	count = tty_insert_flip_string_fixed_flag(port, receive_data->data,
 						  tty_flags, recv_data_size);
 	if (count != recv_data_size) {
-		dev_err(&connection->dev,
+		dev_err(&connection->bundle->dev,
 			"UART: RX 0x%08x bytes only wrote 0x%08x\n",
 			recv_data_size, count);
 	}
@@ -121,7 +121,7 @@ static int gb_uart_request_recv(u8 type, struct gb_operation *op)
 		gb_tty->ctrlin = serial_state->control;
 		break;
 	default:
-		dev_err(&connection->dev,
+		dev_err(&connection->bundle->dev,
 			"unsupported unsolicited request: %02x\n", type);
 		ret = -EINVAL;
 	}
@@ -175,7 +175,7 @@ static int send_break(struct gb_tty *gb_tty, u8 state)
 	struct gb_uart_set_break_request request;
 
 	if ((state != 0) && (state != 1)) {
-		dev_err(&gb_tty->connection->dev,
+		dev_err(&gb_tty->connection->bundle->dev,
 			"invalid break state of %d\n", state);
 		return -EINVAL;
 	}
@@ -626,7 +626,7 @@ static int gb_uart_connection_init(struct gb_connection *connection)
 	minor = alloc_minor(gb_tty);
 	if (minor < 0) {
 		if (minor == -ENOSPC) {
-			dev_err(&connection->dev,
+			dev_err(&connection->bundle->dev,
 				"no more free minor numbers\n");
 			retval = -ENODEV;
 			goto error_minor;
@@ -654,7 +654,7 @@ static int gb_uart_connection_init(struct gb_connection *connection)
 	send_line_coding(gb_tty);
 
 	tty_dev = tty_port_register_device(&gb_tty->port, gb_tty_driver, minor,
-					   &connection->dev);
+					   &connection->bundle->dev);
 	if (IS_ERR(tty_dev)) {
 		retval = PTR_ERR(tty_dev);
 		goto error;

commit a94e14486477b5738061ac09ab69025985c1eda5
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Tue Aug 11 07:36:11 2015 +0530

    greybus: uart: Drop get_version support
    
    This is done from a common place now, no need to replicate it.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/uart.c b/drivers/staging/greybus/uart.c
index 7a51c7c792c9..9e8bf6f4b8d7 100644
--- a/drivers/staging/greybus/uart.c
+++ b/drivers/staging/greybus/uart.c
@@ -55,8 +55,6 @@ struct gb_tty {
 	struct async_icount oldcount;
 	wait_queue_head_t wioctl;
 	struct mutex mutex;
-	u8 version_major;
-	u8 version_minor;
 	u8 ctrlin;	/* input control lines */
 	u8 ctrlout;	/* output control lines */
 	struct gb_tty_line_coding line_coding;
@@ -67,9 +65,6 @@ static DEFINE_IDR(tty_minors);
 static DEFINE_MUTEX(table_lock);
 static atomic_t reference_count = ATOMIC_INIT(0);
 
-/* Define get_version() routine */
-define_get_version(gb_tty, UART);
-
 static int gb_uart_receive_data(struct gb_tty *gb_tty,
 				struct gb_connection *connection,
 				struct gb_uart_recv_data_request *receive_data)
@@ -628,21 +623,16 @@ static int gb_uart_connection_init(struct gb_connection *connection)
 	gb_tty->connection = connection;
 	connection->private = gb_tty;
 
-	/* Check for compatible protocol version */
-	retval = get_version(gb_tty);
-	if (retval)
-		goto error_version;
-
 	minor = alloc_minor(gb_tty);
 	if (minor < 0) {
 		if (minor == -ENOSPC) {
 			dev_err(&connection->dev,
 				"no more free minor numbers\n");
 			retval = -ENODEV;
-			goto error_version;
+			goto error_minor;
 		}
 		retval = minor;
-		goto error_version;
+		goto error_minor;
 	}
 
 	gb_tty->minor = minor;
@@ -674,7 +664,7 @@ static int gb_uart_connection_init(struct gb_connection *connection)
 error:
 	tty_port_destroy(&gb_tty->port);
 	release_minor(gb_tty);
-error_version:
+error_minor:
 	connection->private = NULL;
 	kfree(gb_tty->buffer);
 error_payload:

commit 9475fb5c5ad1d61a37c2bd47fb94dcf55b59aaf2
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Sat Aug 8 10:25:39 2015 +0530

    greybus: uart: Use (already defined) major/minor macros
    
    We already have macros for these, use them instead of writing fixed
    values.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/uart.c b/drivers/staging/greybus/uart.c
index 0166c4cdb451..7a51c7c792c9 100644
--- a/drivers/staging/greybus/uart.c
+++ b/drivers/staging/greybus/uart.c
@@ -767,8 +767,8 @@ static void gb_tty_exit(void)
 static struct gb_protocol uart_protocol = {
 	.name			= "uart",
 	.id			= GREYBUS_PROTOCOL_UART,
-	.major			= 0,
-	.minor			= 1,
+	.major			= GB_UART_VERSION_MAJOR,
+	.minor			= GB_UART_VERSION_MINOR,
 	.connection_init	= gb_uart_connection_init,
 	.connection_exit	= gb_uart_connection_exit,
 	.request_recv		= gb_uart_request_recv,

commit a5192032a2a9475c837c2b4b6fc3df02d617c7b0
Author: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
Date:   Tue Jul 14 02:10:18 2015 +0100

    greybus: uart: fix typo in defintion
    
    Fixing needless redefinition of operation types in gbsim reveals this typo
    GB_UART_TYPE_SET_BREAK -> GB_UART_TYPE_SEND_BREAK. This patch should be
    applied in lock-step to the patch to gbsim 'gbsim/uart: remove unnecessary
    redefinition of operation types' since gbsim does not contain the typo.
    
    Signed-off-by: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/uart.c b/drivers/staging/greybus/uart.c
index 3932f8667d31..0166c4cdb451 100644
--- a/drivers/staging/greybus/uart.c
+++ b/drivers/staging/greybus/uart.c
@@ -186,7 +186,7 @@ static int send_break(struct gb_tty *gb_tty, u8 state)
 	}
 
 	request.state = state;
-	return gb_operation_sync(gb_tty->connection, GB_UART_TYPE_SET_BREAK,
+	return gb_operation_sync(gb_tty->connection, GB_UART_TYPE_SEND_BREAK,
 				 &request, sizeof(request), NULL, 0);
 }
 

commit 5c1ac6945526c76258869c8c04632ab5ae61bdab
Author: Greg Kroah-Hartman <gregkh@google.com>
Date:   Wed Jul 8 10:44:09 2015 -0700

    greybus: properly cleanup ida and idr structures when shutting down
    
    idr and ida structures have internal memory allocated that needs to be
    freed when modules are removed.  So call the proper idr_destroy() or
    ida_destroy() functions on the module exit path to free the memory.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>
    Reviewed-by: Alex Elder <elder@linaro.org>

diff --git a/drivers/staging/greybus/uart.c b/drivers/staging/greybus/uart.c
index e2a456f8105c..3932f8667d31 100644
--- a/drivers/staging/greybus/uart.c
+++ b/drivers/staging/greybus/uart.c
@@ -761,6 +761,7 @@ static void gb_tty_exit(void)
 {
 	tty_unregister_driver(gb_tty_driver);
 	put_tty_driver(gb_tty_driver);
+	idr_destroy(&tty_minors);
 }
 
 static struct gb_protocol uart_protocol = {

commit e18822e3d02c8f296fe42e0e8bda7e2e626a4714
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Wed Jul 1 12:13:52 2015 +0530

    greybus: Rename gb_gpbridge_protocol_driver() as gb_builtin_protocol_driver()
    
    This macro is also required by core protocols like control and svc, and
    hence the 'gpbridge' name doesn't fit anymore.
    
    Lets call this macro gb_builtin_protocol_driver().
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Reviewed-by: Alex Elder <elder@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/uart.c b/drivers/staging/greybus/uart.c
index 7abcd1c05bda..e2a456f8105c 100644
--- a/drivers/staging/greybus/uart.c
+++ b/drivers/staging/greybus/uart.c
@@ -773,4 +773,4 @@ static struct gb_protocol uart_protocol = {
 	.request_recv		= gb_uart_request_recv,
 };
 
-gb_gpbridge_protocol_driver(uart_protocol);
+gb_builtin_protocol_driver(uart_protocol);

commit ba4b099ca8e30b064d06bf9fc3f1a2bbcb8e1818
Author: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
Date:   Mon Jun 29 18:09:15 2015 +0100

    greybus: uart: Update UART to reflect field size changes
    
    The greybus UART protocol specification was updated to reduce the size of
    the control field in serial-state-request and line-state-request. This
    patch updates the kernel protocol driver to reflect the specification
    changes. Once applied gbsim changes will be also be updated automatically
    since gbsim depends on the header being modified directly.
    
    Signed-off-by: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/uart.c b/drivers/staging/greybus/uart.c
index 73e3c992e103..7abcd1c05bda 100644
--- a/drivers/staging/greybus/uart.c
+++ b/drivers/staging/greybus/uart.c
@@ -57,8 +57,8 @@ struct gb_tty {
 	struct mutex mutex;
 	u8 version_major;
 	u8 version_minor;
-	unsigned int ctrlin;	/* input control lines */
-	unsigned int ctrlout;	/* output control lines */
+	u8 ctrlin;	/* input control lines */
+	u8 ctrlout;	/* output control lines */
 	struct gb_tty_line_coding line_coding;
 };
 
@@ -123,7 +123,7 @@ static int gb_uart_request_recv(u8 type, struct gb_operation *op)
 		break;
 	case GB_UART_TYPE_SERIAL_STATE:
 		serial_state = request->payload;
-		gb_tty->ctrlin = le16_to_cpu(serial_state->control);
+		gb_tty->ctrlin = serial_state->control;
 		break;
 	default:
 		dev_err(&connection->dev,
@@ -165,11 +165,11 @@ static int send_line_coding(struct gb_tty *tty)
 				 &request, sizeof(request), NULL, 0);
 }
 
-static int send_control(struct gb_tty *gb_tty, u16 control)
+static int send_control(struct gb_tty *gb_tty, u8 control)
 {
 	struct gb_uart_set_control_line_state_request request;
 
-	request.control = cpu_to_le16(control);
+	request.control = control;
 	return gb_operation_sync(gb_tty->connection,
 				 GB_UART_TYPE_SET_CONTROL_LINE_STATE,
 				 &request, sizeof(request), NULL, 0);
@@ -314,7 +314,7 @@ static void gb_tty_set_termios(struct tty_struct *tty,
 	struct gb_tty *gb_tty = tty->driver_data;
 	struct ktermios *termios = &tty->termios;
 	struct gb_tty_line_coding newline;
-	int newctrl = gb_tty->ctrlout;
+	u8 newctrl = gb_tty->ctrlout;
 
 	newline.rate = cpu_to_le32(tty_get_baud_rate(tty));
 	newline.format = termios->c_cflag & CSTOPB ?
@@ -376,7 +376,7 @@ static int gb_tty_tiocmset(struct tty_struct *tty, unsigned int set,
 			   unsigned int clear)
 {
 	struct gb_tty *gb_tty = tty->driver_data;
-	unsigned int newctrl = gb_tty->ctrlout;
+	u8 newctrl = gb_tty->ctrlout;
 
 	set = (set & TIOCM_DTR ? GB_UART_CTRL_DTR : 0) |
 	      (set & TIOCM_RTS ? GB_UART_CTRL_RTS : 0);

commit 4c025cf4168fe679b8a56eed210349458a142d07
Author: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
Date:   Mon Jun 29 18:09:14 2015 +0100

    greybus: uart: Add support for UART error signals
    
    After reviewing the UART specification for greybus break, parity, framing
    and over-run errors were moved to the receive-data message. This patch
    implements that specification change in the UART protocol driver. Matching
    code in gbsim has been tested with this change.
    
    Signed-off-by: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/uart.c b/drivers/staging/greybus/uart.c
index 3b06cd46694b..73e3c992e103 100644
--- a/drivers/staging/greybus/uart.c
+++ b/drivers/staging/greybus/uart.c
@@ -70,35 +70,56 @@ static atomic_t reference_count = ATOMIC_INIT(0);
 /* Define get_version() routine */
 define_get_version(gb_tty, UART);
 
+static int gb_uart_receive_data(struct gb_tty *gb_tty,
+				struct gb_connection *connection,
+				struct gb_uart_recv_data_request *receive_data)
+{
+	struct tty_port *port = &gb_tty->port;
+	u16 recv_data_size;
+	int count;
+	unsigned long tty_flags = TTY_NORMAL;
+
+	count = gb_tty->buffer_payload_max - sizeof(*receive_data);
+	recv_data_size = le16_to_cpu(receive_data->size);
+	if (!recv_data_size || recv_data_size > count)
+		return -EINVAL;
+
+	if (receive_data->flags) {
+		if (receive_data->flags & GB_UART_RECV_FLAG_BREAK)
+			tty_flags = TTY_BREAK;
+		else if (receive_data->flags & GB_UART_RECV_FLAG_PARITY)
+			tty_flags = TTY_PARITY;
+		else if (receive_data->flags & GB_UART_RECV_FLAG_FRAMING)
+			tty_flags = TTY_FRAME;
+
+		/* overrun is special, not associated with a char */
+		if (receive_data->flags & GB_UART_RECV_FLAG_OVERRUN)
+			tty_insert_flip_char(port, 0, TTY_OVERRUN);
+	}
+	count = tty_insert_flip_string_fixed_flag(port, receive_data->data,
+						  tty_flags, recv_data_size);
+	if (count != recv_data_size) {
+		dev_err(&connection->dev,
+			"UART: RX 0x%08x bytes only wrote 0x%08x\n",
+			recv_data_size, count);
+	}
+	if (count)
+		tty_flip_buffer_push(port);
+	return 0;
+}
+
 static int gb_uart_request_recv(u8 type, struct gb_operation *op)
 {
 	struct gb_connection *connection = op->connection;
 	struct gb_tty *gb_tty = connection->private;
 	struct gb_message *request = op->request;
-	struct gb_uart_recv_data_request *receive_data;
 	struct gb_uart_serial_state_request *serial_state;
-	struct tty_port *port = &gb_tty->port;
-	u16 recv_data_size;
-	int count;
 	int ret = 0;
 
 	switch (type) {
 	case GB_UART_TYPE_RECEIVE_DATA:
-		receive_data = request->payload;
-		count = gb_tty->buffer_payload_max - sizeof(*receive_data);
-		recv_data_size = le16_to_cpu(receive_data->size);
-		if (!recv_data_size || recv_data_size > count)
-			return -EINVAL;
-
-		count = tty_insert_flip_string(port, receive_data->data,
-					       recv_data_size);
-		if (count != recv_data_size) {
-			dev_err(&connection->dev,
-				"UART: RX 0x%08x bytes only wrote 0x%08x\n",
-				recv_data_size, count);
-		}
-		if (count)
-			tty_flip_buffer_push(port);
+		ret = gb_uart_receive_data(gb_tty, connection,
+					   request->payload);
 		break;
 	case GB_UART_TYPE_SERIAL_STATE:
 		serial_state = request->payload;

commit 3ee2266c720520dd2bcf90974f184a22d6e53d06
Author: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
Date:   Tue Jun 16 11:28:11 2015 +0100

    greybus: uart: Latch modem control signals for tciomget
    
    Latch signals coming from UART module for
    - GB_UART_CTRL_DCD
    - GB_UART_CTRL_DSR
    - GB_UART_CTRL_RI
    
    Signed-off-by: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/uart.c b/drivers/staging/greybus/uart.c
index 20928702a5b2..3b06cd46694b 100644
--- a/drivers/staging/greybus/uart.c
+++ b/drivers/staging/greybus/uart.c
@@ -102,7 +102,7 @@ static int gb_uart_request_recv(u8 type, struct gb_operation *op)
 		break;
 	case GB_UART_TYPE_SERIAL_STATE:
 		serial_state = request->payload;
-		/* TODO: Parse state change and translate to tty API. */
+		gb_tty->ctrlin = le16_to_cpu(serial_state->control);
 		break;
 	default:
 		dev_err(&connection->dev,

commit 55a8e3550364a35bc5d40fa0e445049a5df62627
Author: Phong Tran <tranmanphong@gmail.com>
Date:   Wed Jun 10 21:03:17 2015 +0700

    greybus: uart: fix the clean up while uart initiates connection unsucessfully
    
    There is lack of unregister and free the tty driver.
    This patch fixes it.
    
    Signed-off-by: Phong Tran <tranmanphong@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/uart.c b/drivers/staging/greybus/uart.c
index 7e94632a581b..20928702a5b2 100644
--- a/drivers/staging/greybus/uart.c
+++ b/drivers/staging/greybus/uart.c
@@ -586,20 +586,22 @@ static int gb_uart_connection_init(struct gb_connection *connection)
 	}
 
 	gb_tty = kzalloc(sizeof(*gb_tty), GFP_KERNEL);
-	if (!gb_tty)
-		return -ENOMEM;
+	if (!gb_tty) {
+		retval = -ENOMEM;
+		goto error_alloc;
+	}
 
 	gb_tty->buffer_payload_max =
 		gb_operation_get_payload_size_max(connection);
 	if (!gb_tty->buffer_payload_max) {
-		kfree(gb_tty);
-		return -EINVAL;
+		retval = -EINVAL;
+		goto error_payload;
 	}
 
 	gb_tty->buffer = kzalloc(gb_tty->buffer_payload_max, GFP_KERNEL);
 	if (!gb_tty->buffer) {
-		kfree(gb_tty);
-		return -ENOMEM;
+		retval = -ENOMEM;
+		goto error_payload;
 	}
 
 	gb_tty->connection = connection;
@@ -654,7 +656,11 @@ static int gb_uart_connection_init(struct gb_connection *connection)
 error_version:
 	connection->private = NULL;
 	kfree(gb_tty->buffer);
+error_payload:
 	kfree(gb_tty);
+error_alloc:
+	if (atomic_dec_return(&reference_count) == 0)
+		gb_tty_exit();
 	return retval;
 }
 

commit 61b65a394cdbf5ed9117ad0da184a3f90a9b914a
Author: Phong Tran <tranmanphong@gmail.com>
Date:   Tue Jun 9 20:28:18 2015 +0700

    greybus: uart: remove the redundant unregister chrdev
    
    The unregister_chrdev_region() does twice here.
    The chrdev region was unregistered
    inside tty_unregister_driver().
    
    Signed-off-by: Phong Tran <tranmanphong@gmail.com>
    Reviewed-by: Alex Elder <elder@linaro.org>
    Reviewed-by: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/uart.c b/drivers/staging/greybus/uart.c
index 6db49930cf40..7e94632a581b 100644
--- a/drivers/staging/greybus/uart.c
+++ b/drivers/staging/greybus/uart.c
@@ -732,12 +732,8 @@ static int gb_tty_init(void)
 
 static void gb_tty_exit(void)
 {
-	int major = MAJOR(gb_tty_driver->major);
-	int minor = gb_tty_driver->minor_start;
-
 	tty_unregister_driver(gb_tty_driver);
 	put_tty_driver(gb_tty_driver);
-	unregister_chrdev_region(MKDEV(major, minor), GB_NUM_MINORS);
 }
 
 static struct gb_protocol uart_protocol = {

commit 81c3a77207450cb4187e8af700797e7d3209a568
Author: Alex Elder <elder@linaro.org>
Date:   Mon Jun 8 12:05:12 2015 -0500

    greybus: uart: properly interpret receive data size
    
    In gb_uart_request_recv(), the receive data size is in little-endian
    format.  Do the proper byte swapping of that value before using it.
    Found by "make check".
    
    Signed-off-by: Alex Elder <elder@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/uart.c b/drivers/staging/greybus/uart.c
index 37bb2e2ddf59..6db49930cf40 100644
--- a/drivers/staging/greybus/uart.c
+++ b/drivers/staging/greybus/uart.c
@@ -78,6 +78,7 @@ static int gb_uart_request_recv(u8 type, struct gb_operation *op)
 	struct gb_uart_recv_data_request *receive_data;
 	struct gb_uart_serial_state_request *serial_state;
 	struct tty_port *port = &gb_tty->port;
+	u16 recv_data_size;
 	int count;
 	int ret = 0;
 
@@ -85,15 +86,16 @@ static int gb_uart_request_recv(u8 type, struct gb_operation *op)
 	case GB_UART_TYPE_RECEIVE_DATA:
 		receive_data = request->payload;
 		count = gb_tty->buffer_payload_max - sizeof(*receive_data);
-		if (!receive_data->size || receive_data->size > count)
+		recv_data_size = le16_to_cpu(receive_data->size);
+		if (!recv_data_size || recv_data_size > count)
 			return -EINVAL;
 
 		count = tty_insert_flip_string(port, receive_data->data,
-					       receive_data->size);
-		if (count != receive_data->size) {
+					       recv_data_size);
+		if (count != recv_data_size) {
 			dev_err(&connection->dev,
 				"UART: RX 0x%08x bytes only wrote 0x%08x\n",
-				receive_data->size, count);
+				recv_data_size, count);
 		}
 		if (count)
 			tty_flip_buffer_push(port);

commit 62229a1bda8abdc54dabada79798885f4f2da79c
Author: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
Date:   Tue Jun 2 13:40:51 2015 +0100

    greybus: uart: Remove magic numbers make struct gb_tty variable names consistent
    
    Use defines for the data format command.
    Tidy up naming of gb_tty variables.
    
    Signed-off-by: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/uart.c b/drivers/staging/greybus/uart.c
index 2d19d397fb72..37bb2e2ddf59 100644
--- a/drivers/staging/greybus/uart.c
+++ b/drivers/staging/greybus/uart.c
@@ -142,28 +142,28 @@ static int send_line_coding(struct gb_tty *tty)
 				 &request, sizeof(request), NULL, 0);
 }
 
-static int send_control(struct gb_tty *tty, u16 control)
+static int send_control(struct gb_tty *gb_tty, u16 control)
 {
 	struct gb_uart_set_control_line_state_request request;
 
 	request.control = cpu_to_le16(control);
-	return gb_operation_sync(tty->connection,
+	return gb_operation_sync(gb_tty->connection,
 				 GB_UART_TYPE_SET_CONTROL_LINE_STATE,
 				 &request, sizeof(request), NULL, 0);
 }
 
-static int send_break(struct gb_tty *tty, u8 state)
+static int send_break(struct gb_tty *gb_tty, u8 state)
 {
 	struct gb_uart_set_break_request request;
 
 	if ((state != 0) && (state != 1)) {
-		dev_err(&tty->connection->dev,
+		dev_err(&gb_tty->connection->dev,
 			"invalid break state of %d\n", state);
 		return -EINVAL;
 	}
 
 	request.state = state;
-	return gb_operation_sync(tty->connection, GB_UART_TYPE_SET_BREAK,
+	return gb_operation_sync(gb_tty->connection, GB_UART_TYPE_SET_BREAK,
 				 &request, sizeof(request), NULL, 0);
 }
 
@@ -294,7 +294,8 @@ static void gb_tty_set_termios(struct tty_struct *tty,
 	int newctrl = gb_tty->ctrlout;
 
 	newline.rate = cpu_to_le32(tty_get_baud_rate(tty));
-	newline.format = termios->c_cflag & CSTOPB ? 2 : 0;
+	newline.format = termios->c_cflag & CSTOPB ?
+				GB_SERIAL_2_STOP_BITS : GB_SERIAL_1_STOP_BITS;
 	newline.parity = termios->c_cflag & PARENB ?
 				(termios->c_cflag & PARODD ? 1 : 2) +
 				(termios->c_cflag & CMSPAR ? 2 : 0) : 0;

commit 1c087015b9ee80829a6e34e36715c668493eb607
Author: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
Date:   Tue Jun 2 13:40:50 2015 +0100

    greybus: uart: Add gb_uart_request_recv for receiving async UART data
    
    gb_uart_request_recv job in life is to process unsolicited greybus
    mesages from the UART.
    Hook the incoming UART data and pass to the TTY layer.
    Line-state changes still TBD.
    
    Signed-off-by: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/uart.c b/drivers/staging/greybus/uart.c
index ed03ba44933b..2d19d397fb72 100644
--- a/drivers/staging/greybus/uart.c
+++ b/drivers/staging/greybus/uart.c
@@ -70,6 +70,47 @@ static atomic_t reference_count = ATOMIC_INIT(0);
 /* Define get_version() routine */
 define_get_version(gb_tty, UART);
 
+static int gb_uart_request_recv(u8 type, struct gb_operation *op)
+{
+	struct gb_connection *connection = op->connection;
+	struct gb_tty *gb_tty = connection->private;
+	struct gb_message *request = op->request;
+	struct gb_uart_recv_data_request *receive_data;
+	struct gb_uart_serial_state_request *serial_state;
+	struct tty_port *port = &gb_tty->port;
+	int count;
+	int ret = 0;
+
+	switch (type) {
+	case GB_UART_TYPE_RECEIVE_DATA:
+		receive_data = request->payload;
+		count = gb_tty->buffer_payload_max - sizeof(*receive_data);
+		if (!receive_data->size || receive_data->size > count)
+			return -EINVAL;
+
+		count = tty_insert_flip_string(port, receive_data->data,
+					       receive_data->size);
+		if (count != receive_data->size) {
+			dev_err(&connection->dev,
+				"UART: RX 0x%08x bytes only wrote 0x%08x\n",
+				receive_data->size, count);
+		}
+		if (count)
+			tty_flip_buffer_push(port);
+		break;
+	case GB_UART_TYPE_SERIAL_STATE:
+		serial_state = request->payload;
+		/* TODO: Parse state change and translate to tty API. */
+		break;
+	default:
+		dev_err(&connection->dev,
+			"unsupported unsolicited request: %02x\n", type);
+		ret = -EINVAL;
+	}
+
+	return ret;
+}
+
 static int send_data(struct gb_tty *tty, u16 size, const u8 *data)
 {
 	struct gb_uart_send_data_request *request;
@@ -703,7 +744,7 @@ static struct gb_protocol uart_protocol = {
 	.minor			= 1,
 	.connection_init	= gb_uart_connection_init,
 	.connection_exit	= gb_uart_connection_exit,
-	.request_recv		= NULL,	/* FIXME we have 2 types of requests!!! */
+	.request_recv		= gb_uart_request_recv,
 };
 
 gb_gpbridge_protocol_driver(uart_protocol);

commit dd1c64ede97f163e5ab2fdebfe3f4095f4638120
Author: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
Date:   Tue Jun 2 13:40:49 2015 +0100

    greybus: uart: kmalloc for send_data once only
    
    Make kmalloc for the send buffer a one time alloc based on the MTU for
    a given greybus link.
    
    The write_room for an gb_operation_sync then will be the size of the
    buffer we use for a single operation.
    
    Signed-off-by: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/uart.c b/drivers/staging/greybus/uart.c
index 928b83dbecf7..ed03ba44933b 100644
--- a/drivers/staging/greybus/uart.c
+++ b/drivers/staging/greybus/uart.c
@@ -42,6 +42,8 @@ struct gb_tty_line_coding {
 
 struct gb_tty {
 	struct tty_port port;
+	void *buffer;
+	u32 buffer_payload_max;
 	struct gb_connection *connection;
 	u16 cport_id;
 	unsigned int minor;
@@ -76,15 +78,13 @@ static int send_data(struct gb_tty *tty, u16 size, const u8 *data)
 	if (!data || !size)
 		return 0;
 
-	request = kmalloc(sizeof(*request) + size, GFP_KERNEL);
-	if (!request)
-		return -ENOMEM;
-
+	if (size > tty->buffer_payload_max)
+		size = tty->buffer_payload_max;
+	request = tty->buffer;
 	request->size = cpu_to_le16(size);
 	memcpy(&request->data[0], data, size);
 	ret = gb_operation_sync(tty->connection, GB_UART_TYPE_SEND_DATA,
 				request, sizeof(*request) + size, NULL, 0);
-	kfree(request);
 	if (ret)
 		return ret;
 	else
@@ -227,17 +227,13 @@ static int gb_tty_write(struct tty_struct *tty, const unsigned char *buf,
 
 static int gb_tty_write_room(struct tty_struct *tty)
 {
-//	struct gb_tty *gb_tty = tty->driver_data;
+	struct gb_tty *gb_tty = tty->driver_data;
 
-	// FIXME - how much do we want to say we have room for?
-	return 0;
+	return gb_tty->buffer_payload_max;
 }
 
 static int gb_tty_chars_in_buffer(struct tty_struct *tty)
 {
-//	struct gb_tty *gb_tty = tty->driver_data;
-
-	// FIXME - how many left to send?
 	return 0;
 }
 
@@ -549,6 +545,19 @@ static int gb_uart_connection_init(struct gb_connection *connection)
 	if (!gb_tty)
 		return -ENOMEM;
 
+	gb_tty->buffer_payload_max =
+		gb_operation_get_payload_size_max(connection);
+	if (!gb_tty->buffer_payload_max) {
+		kfree(gb_tty);
+		return -EINVAL;
+	}
+
+	gb_tty->buffer = kzalloc(gb_tty->buffer_payload_max, GFP_KERNEL);
+	if (!gb_tty->buffer) {
+		kfree(gb_tty);
+		return -ENOMEM;
+	}
+
 	gb_tty->connection = connection;
 	connection->private = gb_tty;
 
@@ -600,6 +609,7 @@ static int gb_uart_connection_init(struct gb_connection *connection)
 	release_minor(gb_tty);
 error_version:
 	connection->private = NULL;
+	kfree(gb_tty->buffer);
 	kfree(gb_tty);
 	return retval;
 }
@@ -632,6 +642,7 @@ static void gb_uart_connection_exit(struct gb_connection *connection)
 
 	tty_port_put(&gb_tty->port);
 	tty_port_destroy(&gb_tty->port);
+	kfree(gb_tty->buffer);
 	kfree(gb_tty);
 
 	/* If last device is gone, tear down the tty structures */

commit 563bd79b2ddd12dd9da89635dc218d6c706a4130
Author: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
Date:   Tue Jun 2 13:40:48 2015 +0100

    greybus: uart: send_data should return size or error
    
    gb_operation_sync returns 0 on success but the calling function
    expects the number of bytes written on success or a negative errno
    
    Signed-off-by: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/uart.c b/drivers/staging/greybus/uart.c
index c47667d0bec5..928b83dbecf7 100644
--- a/drivers/staging/greybus/uart.c
+++ b/drivers/staging/greybus/uart.c
@@ -71,7 +71,7 @@ define_get_version(gb_tty, UART);
 static int send_data(struct gb_tty *tty, u16 size, const u8 *data)
 {
 	struct gb_uart_send_data_request *request;
-	int retval;
+	int ret;
 
 	if (!data || !size)
 		return 0;
@@ -82,11 +82,13 @@ static int send_data(struct gb_tty *tty, u16 size, const u8 *data)
 
 	request->size = cpu_to_le16(size);
 	memcpy(&request->data[0], data, size);
-	retval = gb_operation_sync(tty->connection, GB_UART_TYPE_SEND_DATA,
-				   request, sizeof(*request) + size, NULL, 0);
-
+	ret = gb_operation_sync(tty->connection, GB_UART_TYPE_SEND_DATA,
+				request, sizeof(*request) + size, NULL, 0);
 	kfree(request);
-	return retval;
+	if (ret)
+		return ret;
+	else
+		return size;
 }
 
 static int send_line_coding(struct gb_tty *tty)

commit f95ad78c72e72bcc922e75b80b35c6e9549b9d72
Author: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
Date:   Tue Jun 2 13:40:47 2015 +0100

    greybus: uart: Update uart.c to register tty ports
    
    For each new UART connection we need to do a tty_port_init else
    we'll crash when trying to access the tty mutex later on.
    Base the TTY major/minor numbers on non-zero values.
    Supply an empty operations structure for the newly regitered port.
    
    Signed-off-by: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/uart.c b/drivers/staging/greybus/uart.c
index 4cad629e3cb2..c47667d0bec5 100644
--- a/drivers/staging/greybus/uart.c
+++ b/drivers/staging/greybus/uart.c
@@ -522,6 +522,7 @@ static const struct tty_operations gb_ops = {
 	.tiocmset =		gb_tty_tiocmset,
 };
 
+static struct tty_port_operations null_ops = { };
 
 static int gb_tty_init(void);
 static void gb_tty_exit(void);
@@ -545,6 +546,7 @@ static int gb_uart_connection_init(struct gb_connection *connection)
 	gb_tty = kzalloc(sizeof(*gb_tty), GFP_KERNEL);
 	if (!gb_tty)
 		return -ENOMEM;
+
 	gb_tty->connection = connection;
 	connection->private = gb_tty;
 
@@ -571,6 +573,9 @@ static int gb_uart_connection_init(struct gb_connection *connection)
 	init_waitqueue_head(&gb_tty->wioctl);
 	mutex_init(&gb_tty->mutex);
 
+	tty_port_init(&gb_tty->port);
+	gb_tty->port.ops = &null_ops;
+
 	send_control(gb_tty, gb_tty->ctrlout);
 
 	/* initialize the uart to be 9600n81 */
@@ -589,6 +594,7 @@ static int gb_uart_connection_init(struct gb_connection *connection)
 
 	return 0;
 error:
+	tty_port_destroy(&gb_tty->port);
 	release_minor(gb_tty);
 error_version:
 	connection->private = NULL;
@@ -623,7 +629,7 @@ static void gb_uart_connection_exit(struct gb_connection *connection)
 	/* FIXME - free transmit / receive buffers */
 
 	tty_port_put(&gb_tty->port);
-
+	tty_port_destroy(&gb_tty->port);
 	kfree(gb_tty);
 
 	/* If last device is gone, tear down the tty structures */

commit f5537d46cb2e062ca4a67ac86168b2bff9895615
Author: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
Date:   Tue Jun 2 13:40:46 2015 +0100

    greybus: uart: Reduce UART count from 255 to 16
    
    Arbitrary number 255 is both not aligned and probably too big.
    Move the UART count down to 16 which is still large but, more realistic.
    8 may be too few for future testing setups, 16 should accomodate any.
    
    Signed-off-by: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/uart.c b/drivers/staging/greybus/uart.c
index 673eec4fe963..4cad629e3cb2 100644
--- a/drivers/staging/greybus/uart.c
+++ b/drivers/staging/greybus/uart.c
@@ -30,7 +30,7 @@
 
 #include "greybus.h"
 
-#define GB_NUM_MINORS	255	/* 255 is enough for anyone... */
+#define GB_NUM_MINORS	16	/* 16 is is more than enough */
 #define GB_NAME		"ttyGB"
 
 struct gb_tty_line_coding {

commit 11fca140c92555f299808968061e81deb7c11821
Author: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
Date:   Tue Jun 2 13:40:45 2015 +0100

    greybus: uart: Tidy naming convention to more closely match spec
    
    Update tabs and naming of structures to match the naming used in the greybus
    specification more closely.
    
    Signed-off-by: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/uart.c b/drivers/staging/greybus/uart.c
index a4c0127687b7..673eec4fe963 100644
--- a/drivers/staging/greybus/uart.c
+++ b/drivers/staging/greybus/uart.c
@@ -33,6 +33,13 @@
 #define GB_NUM_MINORS	255	/* 255 is enough for anyone... */
 #define GB_NAME		"ttyGB"
 
+struct gb_tty_line_coding {
+	__le32	rate;
+	__u8	format;
+	__u8	parity;
+	__u8	data_bits;
+};
+
 struct gb_tty {
 	struct tty_port port;
 	struct gb_connection *connection;
@@ -50,10 +57,9 @@ struct gb_tty {
 	u8 version_minor;
 	unsigned int ctrlin;	/* input control lines */
 	unsigned int ctrlout;	/* output control lines */
-	struct gb_serial_line_coding line_coding;
+	struct gb_tty_line_coding line_coding;
 };
 
-
 static struct tty_driver *gb_tty_driver;
 static DEFINE_IDR(tty_minors);
 static DEFINE_MUTEX(table_lock);
@@ -87,7 +93,7 @@ static int send_line_coding(struct gb_tty *tty)
 {
 	struct gb_uart_set_line_coding_request request;
 
-	memcpy(&request.line_coding, &tty->line_coding,
+	memcpy(&request, &tty->line_coding,
 	       sizeof(tty->line_coding));
 	return gb_operation_sync(tty->connection, GB_UART_TYPE_SET_LINE_CODING,
 				 &request, sizeof(request), NULL, 0);
@@ -245,7 +251,7 @@ static void gb_tty_set_termios(struct tty_struct *tty,
 {
 	struct gb_tty *gb_tty = tty->driver_data;
 	struct ktermios *termios = &tty->termios;
-	struct gb_serial_line_coding newline;
+	struct gb_tty_line_coding newline;
 	int newctrl = gb_tty->ctrlout;
 
 	newline.rate = cpu_to_le32(tty_get_baud_rate(tty));
@@ -256,17 +262,17 @@ static void gb_tty_set_termios(struct tty_struct *tty,
 
 	switch (termios->c_cflag & CSIZE) {
 	case CS5:
-		newline.data = 5;
+		newline.data_bits = 5;
 		break;
 	case CS6:
-		newline.data = 6;
+		newline.data_bits = 6;
 		break;
 	case CS7:
-		newline.data = 7;
+		newline.data_bits = 7;
 		break;
 	case CS8:
 	default:
-		newline.data = 8;
+		newline.data_bits = 8;
 		break;
 	}
 
@@ -571,7 +577,7 @@ static int gb_uart_connection_init(struct gb_connection *connection)
 	gb_tty->line_coding.rate = cpu_to_le32(9600);
 	gb_tty->line_coding.format = GB_SERIAL_1_STOP_BITS;
 	gb_tty->line_coding.parity = GB_SERIAL_NO_PARITY;
-	gb_tty->line_coding.data = 8;
+	gb_tty->line_coding.data_bits = 8;
 	send_line_coding(gb_tty);
 
 	tty_dev = tty_port_register_device(&gb_tty->port, gb_tty_driver, minor,

commit 4ef53485c3d2d7a36c163c0409c8e3eb324a70d4
Author: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
Date:   Tue Jun 2 13:40:44 2015 +0100

    greybus: uart: Move UART protocol structs/defines to greybus_protocols.h
    
    gbsim depends on the structures and defines in greybus_protocols.h
    generally in order to simulate firmware. Move UART defines into this
    header to facilitate.
    
    Signed-off-by: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/uart.c b/drivers/staging/greybus/uart.c
index 590bc9f5d0be..a4c0127687b7 100644
--- a/drivers/staging/greybus/uart.c
+++ b/drivers/staging/greybus/uart.c
@@ -33,72 +33,6 @@
 #define GB_NUM_MINORS	255	/* 255 is enough for anyone... */
 #define GB_NAME		"ttyGB"
 
-/* Version of the Greybus PWM protocol we support */
-#define GB_UART_VERSION_MAJOR		0x00
-#define GB_UART_VERSION_MINOR		0x01
-
-/* Greybus UART operation types */
-#define GB_UART_TYPE_INVALID			0x00
-#define GB_UART_TYPE_PROTOCOL_VERSION		0x01
-#define GB_UART_TYPE_SEND_DATA			0x02
-#define GB_UART_TYPE_RECEIVE_DATA		0x03	/* Unsolicited data */
-#define GB_UART_TYPE_SET_LINE_CODING		0x04
-#define GB_UART_TYPE_SET_CONTROL_LINE_STATE	0x05
-#define GB_UART_TYPE_SET_BREAK			0x06
-#define GB_UART_TYPE_SERIAL_STATE		0x07	/* Unsolicited data */
-
-struct gb_uart_send_data_request {
-	__le16	size;
-	__u8	data[0];
-};
-
-struct gb_serial_line_coding {
-	__le32	rate;
-	__u8	format;
-#define GB_SERIAL_1_STOP_BITS		0
-#define GB_SERIAL_1_5_STOP_BITS		1
-#define GB_SERIAL_2_STOP_BITS		2
-
-	__u8	parity;
-#define GB_SERIAL_NO_PARITY		0
-#define GB_SERIAL_ODD_PARITY		1
-#define GB_SERIAL_EVEN_PARITY		2
-#define GB_SERIAL_MARK_PARITY		3
-#define GB_SERIAL_SPACE_PARITY		4
-
-	__u8	data;
-};
-
-struct gb_uart_set_line_coding_request {
-	struct gb_serial_line_coding	line_coding;
-};
-
-/* output control lines */
-#define GB_UART_CTRL_DTR		0x01
-#define GB_UART_CTRL_RTS		0x02
-
-struct gb_uart_set_control_line_state_request {
-	__le16	control;
-};
-
-struct gb_uart_set_break_request {
-	__u8	state;
-};
-
-/* input control lines and line errors */
-#define GB_UART_CTRL_DCD		0x01
-#define GB_UART_CTRL_DSR		0x02
-#define GB_UART_CTRL_BRK		0x04
-#define GB_UART_CTRL_RI			0x08
-
-#define GB_UART_CTRL_FRAMING		0x10
-#define GB_UART_CTRL_PARITY		0x20
-#define GB_UART_CTRL_OVERRUN		0x40
-
-struct gb_uart_serial_state_request {
-	__u16	control;
-};
-
 struct gb_tty {
 	struct tty_port port;
 	struct gb_connection *connection;

commit 55f2291142efa42acab362bf71b52e03bd275a42
Author: Phong Tran <tranmanphong@gmail.com>
Date:   Mon Jun 1 22:19:45 2015 +0700

    greybus: uart: Fix the memory leak in connection init
    
    If alloc minor is error, gb_tty should free.
    
    Signed-off-by: Phong Tran <tranmanphong@gmail.com>
    Reviewed-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/uart.c b/drivers/staging/greybus/uart.c
index 47de9698f50c..590bc9f5d0be 100644
--- a/drivers/staging/greybus/uart.c
+++ b/drivers/staging/greybus/uart.c
@@ -618,9 +618,11 @@ static int gb_uart_connection_init(struct gb_connection *connection)
 		if (minor == -ENOSPC) {
 			dev_err(&connection->dev,
 				"no more free minor numbers\n");
-			return -ENODEV;
+			retval = -ENODEV;
+			goto error_version;
 		}
-		return minor;
+		retval = minor;
+		goto error_version;
 	}
 
 	gb_tty->minor = minor;

commit bdac599c70409bbf48e77971e2b9ecc2a66ef151
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Wed May 20 17:20:10 2015 +0530

    greybus: Use gb_gpbridge_protocol_init()
    
    Start using gb_gpbridge_protocol_init() in gpbridge drivers.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Reviewed-by: Alex Elder <elder@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/uart.c b/drivers/staging/greybus/uart.c
index 35ab3cad5714..47de9698f50c 100644
--- a/drivers/staging/greybus/uart.c
+++ b/drivers/staging/greybus/uart.c
@@ -745,12 +745,4 @@ static struct gb_protocol uart_protocol = {
 	.request_recv		= NULL,	/* FIXME we have 2 types of requests!!! */
 };
 
-int gb_uart_protocol_init(void)
-{
-	return gb_protocol_register(&uart_protocol);
-}
-
-void gb_uart_protocol_exit(void)
-{
-	gb_protocol_deregister(&uart_protocol);
-}
+gb_gpbridge_protocol_driver(uart_protocol);

commit 6d653370c0a67ff9b9b0d8249182d537859b528c
Author: Alex Elder <elder@linaro.org>
Date:   Thu May 7 13:03:52 2015 -0500

    greybus: eliminate extra response flag definitions
    
    All protocols use the same value to distinguish between request and
    response message types.  This is a requirement.
    
    Use GB_MESSAGE_TYPE_RESPONSE rather than GB_OPERATION_TYPE_RESPONSE
    for the name of the flag used to distiguish between request and
    response messages.
    
    Get rid of the redundant response flag definitions that are
    associated with specific protocols.
    
    Describe the symbolic values as "operation types" rather than
    "message types" where they are defined.  The message type for a
    request is the same as the operation type; the message type for a
    response is the operation type OR'd with GB_MESSAGE_TYPE_RESPONSE.
    
    Signed-off-by: Alex Elder <elder@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/uart.c b/drivers/staging/greybus/uart.c
index 51e4f7bad47f..35ab3cad5714 100644
--- a/drivers/staging/greybus/uart.c
+++ b/drivers/staging/greybus/uart.c
@@ -37,7 +37,7 @@
 #define GB_UART_VERSION_MAJOR		0x00
 #define GB_UART_VERSION_MINOR		0x01
 
-/* Greybus UART request types */
+/* Greybus UART operation types */
 #define GB_UART_TYPE_INVALID			0x00
 #define GB_UART_TYPE_PROTOCOL_VERSION		0x01
 #define GB_UART_TYPE_SEND_DATA			0x02
@@ -46,7 +46,6 @@
 #define GB_UART_TYPE_SET_CONTROL_LINE_STATE	0x05
 #define GB_UART_TYPE_SET_BREAK			0x06
 #define GB_UART_TYPE_SERIAL_STATE		0x07	/* Unsolicited data */
-#define GB_UART_TYPE_RESPONSE			0x80	/* OR'd with rest */
 
 struct gb_uart_send_data_request {
 	__le16	size;

commit afcf8c715e7cb615dad484913b70c714594ce159
Author: Johan Hovold <johan@hovoldconsulting.com>
Date:   Tue Mar 17 18:24:30 2015 +0100

    greybus: uart: remove packed-attribute from line-coding struct
    
    Remove packed-attribute from line-coding struct, whose members are all
    naturally aligned.
    
    Signed-off-by: Johan Hovold <johan@hovoldconsulting.com>
    Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>

diff --git a/drivers/staging/greybus/uart.c b/drivers/staging/greybus/uart.c
index 575ca568a4f1..51e4f7bad47f 100644
--- a/drivers/staging/greybus/uart.c
+++ b/drivers/staging/greybus/uart.c
@@ -68,7 +68,7 @@ struct gb_serial_line_coding {
 #define GB_SERIAL_SPACE_PARITY		4
 
 	__u8	data;
-} __attribute__ ((packed));
+};
 
 struct gb_uart_set_line_coding_request {
 	struct gb_serial_line_coding	line_coding;

commit 89210f64bae6bd6bba90d9e08d1b88b4ba103f59
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Wed Jan 21 18:12:37 2015 +0530

    greybus: remove unused version-response structs
    
    These aren't used anymore and so can be removed.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Reviewed-by: Alex Elder <elder@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>

diff --git a/drivers/staging/greybus/uart.c b/drivers/staging/greybus/uart.c
index d0669ae2d4c1..575ca568a4f1 100644
--- a/drivers/staging/greybus/uart.c
+++ b/drivers/staging/greybus/uart.c
@@ -48,11 +48,6 @@
 #define GB_UART_TYPE_SERIAL_STATE		0x07	/* Unsolicited data */
 #define GB_UART_TYPE_RESPONSE			0x80	/* OR'd with rest */
 
-struct gb_uart_proto_version_response {
-	__u8	major;
-	__u8	minor;
-};
-
 struct gb_uart_send_data_request {
 	__le16	size;
 	__u8	data[0];

commit 36e79dec96f652110ae2b06bfcf9e67e1b770787
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Wed Jan 21 18:12:36 2015 +0530

    greybus: create get_version() routines with the help of a macro
    
    This gets rid of lots of duplication of code.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Reviewed-by: Alex Elder <elder@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>

diff --git a/drivers/staging/greybus/uart.c b/drivers/staging/greybus/uart.c
index 543c88992b0d..d0669ae2d4c1 100644
--- a/drivers/staging/greybus/uart.c
+++ b/drivers/staging/greybus/uart.c
@@ -131,33 +131,8 @@ static DEFINE_IDR(tty_minors);
 static DEFINE_MUTEX(table_lock);
 static atomic_t reference_count = ATOMIC_INIT(0);
 
-/*
- * This request only uses the connection field, and if successful,
- * fills in the major and minor protocol version of the target.
- */
-static int get_version(struct gb_tty *tty)
-{
-	struct gb_uart_proto_version_response response;
-	int ret;
-
-	ret = gb_operation_sync(tty->connection,
-				GB_UART_TYPE_PROTOCOL_VERSION,
-				NULL, 0, &response, sizeof(response));
-	if (ret)
-		return ret;
-
-	if (response.major > GB_UART_VERSION_MAJOR) {
-		pr_err("unsupported major version (%hhu > %hhu)\n",
-			response.major, GB_UART_VERSION_MAJOR);
-		return -ENOTSUPP;
-	}
-	tty->version_major = response.major;
-	tty->version_minor = response.minor;
-
-	pr_debug("%s: version_major = %u version_minor = %u\n",
-		__func__, tty->version_major, tty->version_minor);
-	return 0;
-}
+/* Define get_version() routine */
+define_get_version(gb_tty, UART);
 
 static int send_data(struct gb_tty *tty, u16 size, const u8 *data)
 {

commit 530430b717f02843fe1f2e77e6f52a41e05d6c3a
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Wed Jan 21 18:12:35 2015 +0530

    greybus: uart: s/REQ/TYPE
    
    Request type for all other protocols is defined like: GB_<protocol>_TYPE_<operation>,
    but for UART is like: GB_<protocol>_REQ_<operation>.
    
    Replace REQ with TYPE to make it consistent. It will also be useful in a later
    patch that creates get_version() routines with the help of a macro.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Reviewed-by: Alex Elder <elder@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>

diff --git a/drivers/staging/greybus/uart.c b/drivers/staging/greybus/uart.c
index 032062019d20..543c88992b0d 100644
--- a/drivers/staging/greybus/uart.c
+++ b/drivers/staging/greybus/uart.c
@@ -38,14 +38,14 @@
 #define GB_UART_VERSION_MINOR		0x01
 
 /* Greybus UART request types */
-#define GB_UART_REQ_INVALID			0x00
-#define GB_UART_REQ_PROTOCOL_VERSION		0x01
-#define GB_UART_REQ_SEND_DATA			0x02
-#define GB_UART_REQ_RECEIVE_DATA		0x03	/* Unsolicited data */
-#define GB_UART_REQ_SET_LINE_CODING		0x04
-#define GB_UART_REQ_SET_CONTROL_LINE_STATE	0x05
-#define GB_UART_REQ_SET_BREAK			0x06
-#define GB_UART_REQ_SERIAL_STATE		0x07	/* Unsolicited data */
+#define GB_UART_TYPE_INVALID			0x00
+#define GB_UART_TYPE_PROTOCOL_VERSION		0x01
+#define GB_UART_TYPE_SEND_DATA			0x02
+#define GB_UART_TYPE_RECEIVE_DATA		0x03	/* Unsolicited data */
+#define GB_UART_TYPE_SET_LINE_CODING		0x04
+#define GB_UART_TYPE_SET_CONTROL_LINE_STATE	0x05
+#define GB_UART_TYPE_SET_BREAK			0x06
+#define GB_UART_TYPE_SERIAL_STATE		0x07	/* Unsolicited data */
 #define GB_UART_TYPE_RESPONSE			0x80	/* OR'd with rest */
 
 struct gb_uart_proto_version_response {
@@ -141,7 +141,7 @@ static int get_version(struct gb_tty *tty)
 	int ret;
 
 	ret = gb_operation_sync(tty->connection,
-				GB_UART_REQ_PROTOCOL_VERSION,
+				GB_UART_TYPE_PROTOCOL_VERSION,
 				NULL, 0, &response, sizeof(response));
 	if (ret)
 		return ret;
@@ -173,7 +173,7 @@ static int send_data(struct gb_tty *tty, u16 size, const u8 *data)
 
 	request->size = cpu_to_le16(size);
 	memcpy(&request->data[0], data, size);
-	retval = gb_operation_sync(tty->connection, GB_UART_REQ_SEND_DATA,
+	retval = gb_operation_sync(tty->connection, GB_UART_TYPE_SEND_DATA,
 				   request, sizeof(*request) + size, NULL, 0);
 
 	kfree(request);
@@ -186,7 +186,7 @@ static int send_line_coding(struct gb_tty *tty)
 
 	memcpy(&request.line_coding, &tty->line_coding,
 	       sizeof(tty->line_coding));
-	return gb_operation_sync(tty->connection, GB_UART_REQ_SET_LINE_CODING,
+	return gb_operation_sync(tty->connection, GB_UART_TYPE_SET_LINE_CODING,
 				 &request, sizeof(request), NULL, 0);
 }
 
@@ -196,7 +196,7 @@ static int send_control(struct gb_tty *tty, u16 control)
 
 	request.control = cpu_to_le16(control);
 	return gb_operation_sync(tty->connection,
-				 GB_UART_REQ_SET_CONTROL_LINE_STATE,
+				 GB_UART_TYPE_SET_CONTROL_LINE_STATE,
 				 &request, sizeof(request), NULL, 0);
 }
 
@@ -211,7 +211,7 @@ static int send_break(struct gb_tty *tty, u8 state)
 	}
 
 	request.state = state;
-	return gb_operation_sync(tty->connection, GB_UART_REQ_SET_BREAK,
+	return gb_operation_sync(tty->connection, GB_UART_TYPE_SET_BREAK,
 				 &request, sizeof(request), NULL, 0);
 }
 

commit 5357cf323110ee4a3f4a12870618eca28672c7b9
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Wed Jan 21 16:10:40 2015 +0530

    greybus: Remove "-gb" suffix from .c files
    
    Some files are prefixed with "gb-" and some are suffixed with "-gb". The
    rationale behind the first one is that the modules would be named so, i.e.
    gb-*.ko. But there is no reason to keep the "-gb" suffix in the second case.
    
    Remove the unnecessary suffix.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Reviewed-by: Alex Elder <elder@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>

diff --git a/drivers/staging/greybus/uart.c b/drivers/staging/greybus/uart.c
new file mode 100644
index 000000000000..032062019d20
--- /dev/null
+++ b/drivers/staging/greybus/uart.c
@@ -0,0 +1,787 @@
+/*
+ * UART driver for the Greybus "generic" UART module.
+ *
+ * Copyright 2014 Google Inc.
+ * Copyright 2014 Linaro Ltd.
+ *
+ * Released under the GPLv2 only.
+ *
+ * Heavily based on drivers/usb/class/cdc-acm.c and
+ * drivers/usb/serial/usb-serial.c.
+ */
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/module.h>
+#include <linux/sched.h>
+#include <linux/wait.h>
+#include <linux/slab.h>
+#include <linux/uaccess.h>
+#include <linux/mutex.h>
+#include <linux/tty.h>
+#include <linux/serial.h>
+#include <linux/tty_driver.h>
+#include <linux/tty_flip.h>
+#include <linux/serial.h>
+#include <linux/idr.h>
+#include <linux/fs.h>
+#include <linux/kdev_t.h>
+
+#include "greybus.h"
+
+#define GB_NUM_MINORS	255	/* 255 is enough for anyone... */
+#define GB_NAME		"ttyGB"
+
+/* Version of the Greybus PWM protocol we support */
+#define GB_UART_VERSION_MAJOR		0x00
+#define GB_UART_VERSION_MINOR		0x01
+
+/* Greybus UART request types */
+#define GB_UART_REQ_INVALID			0x00
+#define GB_UART_REQ_PROTOCOL_VERSION		0x01
+#define GB_UART_REQ_SEND_DATA			0x02
+#define GB_UART_REQ_RECEIVE_DATA		0x03	/* Unsolicited data */
+#define GB_UART_REQ_SET_LINE_CODING		0x04
+#define GB_UART_REQ_SET_CONTROL_LINE_STATE	0x05
+#define GB_UART_REQ_SET_BREAK			0x06
+#define GB_UART_REQ_SERIAL_STATE		0x07	/* Unsolicited data */
+#define GB_UART_TYPE_RESPONSE			0x80	/* OR'd with rest */
+
+struct gb_uart_proto_version_response {
+	__u8	major;
+	__u8	minor;
+};
+
+struct gb_uart_send_data_request {
+	__le16	size;
+	__u8	data[0];
+};
+
+struct gb_serial_line_coding {
+	__le32	rate;
+	__u8	format;
+#define GB_SERIAL_1_STOP_BITS		0
+#define GB_SERIAL_1_5_STOP_BITS		1
+#define GB_SERIAL_2_STOP_BITS		2
+
+	__u8	parity;
+#define GB_SERIAL_NO_PARITY		0
+#define GB_SERIAL_ODD_PARITY		1
+#define GB_SERIAL_EVEN_PARITY		2
+#define GB_SERIAL_MARK_PARITY		3
+#define GB_SERIAL_SPACE_PARITY		4
+
+	__u8	data;
+} __attribute__ ((packed));
+
+struct gb_uart_set_line_coding_request {
+	struct gb_serial_line_coding	line_coding;
+};
+
+/* output control lines */
+#define GB_UART_CTRL_DTR		0x01
+#define GB_UART_CTRL_RTS		0x02
+
+struct gb_uart_set_control_line_state_request {
+	__le16	control;
+};
+
+struct gb_uart_set_break_request {
+	__u8	state;
+};
+
+/* input control lines and line errors */
+#define GB_UART_CTRL_DCD		0x01
+#define GB_UART_CTRL_DSR		0x02
+#define GB_UART_CTRL_BRK		0x04
+#define GB_UART_CTRL_RI			0x08
+
+#define GB_UART_CTRL_FRAMING		0x10
+#define GB_UART_CTRL_PARITY		0x20
+#define GB_UART_CTRL_OVERRUN		0x40
+
+struct gb_uart_serial_state_request {
+	__u16	control;
+};
+
+struct gb_tty {
+	struct tty_port port;
+	struct gb_connection *connection;
+	u16 cport_id;
+	unsigned int minor;
+	unsigned char clocal;
+	bool disconnected;
+	spinlock_t read_lock;
+	spinlock_t write_lock;
+	struct async_icount iocount;
+	struct async_icount oldcount;
+	wait_queue_head_t wioctl;
+	struct mutex mutex;
+	u8 version_major;
+	u8 version_minor;
+	unsigned int ctrlin;	/* input control lines */
+	unsigned int ctrlout;	/* output control lines */
+	struct gb_serial_line_coding line_coding;
+};
+
+
+static struct tty_driver *gb_tty_driver;
+static DEFINE_IDR(tty_minors);
+static DEFINE_MUTEX(table_lock);
+static atomic_t reference_count = ATOMIC_INIT(0);
+
+/*
+ * This request only uses the connection field, and if successful,
+ * fills in the major and minor protocol version of the target.
+ */
+static int get_version(struct gb_tty *tty)
+{
+	struct gb_uart_proto_version_response response;
+	int ret;
+
+	ret = gb_operation_sync(tty->connection,
+				GB_UART_REQ_PROTOCOL_VERSION,
+				NULL, 0, &response, sizeof(response));
+	if (ret)
+		return ret;
+
+	if (response.major > GB_UART_VERSION_MAJOR) {
+		pr_err("unsupported major version (%hhu > %hhu)\n",
+			response.major, GB_UART_VERSION_MAJOR);
+		return -ENOTSUPP;
+	}
+	tty->version_major = response.major;
+	tty->version_minor = response.minor;
+
+	pr_debug("%s: version_major = %u version_minor = %u\n",
+		__func__, tty->version_major, tty->version_minor);
+	return 0;
+}
+
+static int send_data(struct gb_tty *tty, u16 size, const u8 *data)
+{
+	struct gb_uart_send_data_request *request;
+	int retval;
+
+	if (!data || !size)
+		return 0;
+
+	request = kmalloc(sizeof(*request) + size, GFP_KERNEL);
+	if (!request)
+		return -ENOMEM;
+
+	request->size = cpu_to_le16(size);
+	memcpy(&request->data[0], data, size);
+	retval = gb_operation_sync(tty->connection, GB_UART_REQ_SEND_DATA,
+				   request, sizeof(*request) + size, NULL, 0);
+
+	kfree(request);
+	return retval;
+}
+
+static int send_line_coding(struct gb_tty *tty)
+{
+	struct gb_uart_set_line_coding_request request;
+
+	memcpy(&request.line_coding, &tty->line_coding,
+	       sizeof(tty->line_coding));
+	return gb_operation_sync(tty->connection, GB_UART_REQ_SET_LINE_CODING,
+				 &request, sizeof(request), NULL, 0);
+}
+
+static int send_control(struct gb_tty *tty, u16 control)
+{
+	struct gb_uart_set_control_line_state_request request;
+
+	request.control = cpu_to_le16(control);
+	return gb_operation_sync(tty->connection,
+				 GB_UART_REQ_SET_CONTROL_LINE_STATE,
+				 &request, sizeof(request), NULL, 0);
+}
+
+static int send_break(struct gb_tty *tty, u8 state)
+{
+	struct gb_uart_set_break_request request;
+
+	if ((state != 0) && (state != 1)) {
+		dev_err(&tty->connection->dev,
+			"invalid break state of %d\n", state);
+		return -EINVAL;
+	}
+
+	request.state = state;
+	return gb_operation_sync(tty->connection, GB_UART_REQ_SET_BREAK,
+				 &request, sizeof(request), NULL, 0);
+}
+
+
+static struct gb_tty *get_gb_by_minor(unsigned minor)
+{
+	struct gb_tty *gb_tty;
+
+	mutex_lock(&table_lock);
+	gb_tty = idr_find(&tty_minors, minor);
+	if (gb_tty) {
+		mutex_lock(&gb_tty->mutex);
+		if (gb_tty->disconnected) {
+			mutex_unlock(&gb_tty->mutex);
+			gb_tty = NULL;
+		} else {
+			tty_port_get(&gb_tty->port);
+			mutex_unlock(&gb_tty->mutex);
+		}
+	}
+	mutex_unlock(&table_lock);
+	return gb_tty;
+}
+
+static int alloc_minor(struct gb_tty *gb_tty)
+{
+	int minor;
+
+	mutex_lock(&table_lock);
+	minor = idr_alloc(&tty_minors, gb_tty, 0, GB_NUM_MINORS, GFP_KERNEL);
+	mutex_unlock(&table_lock);
+	if (minor >= 0)
+		gb_tty->minor = minor;
+	return minor;
+}
+
+static void release_minor(struct gb_tty *gb_tty)
+{
+	int minor = gb_tty->minor;
+
+	gb_tty->minor = 0;	/* Maybe should use an invalid value instead */
+	mutex_lock(&table_lock);
+	idr_remove(&tty_minors, minor);
+	mutex_unlock(&table_lock);
+}
+
+static int gb_tty_install(struct tty_driver *driver, struct tty_struct *tty)
+{
+	struct gb_tty *gb_tty;
+	int retval;
+
+	gb_tty = get_gb_by_minor(tty->index);
+	if (!gb_tty)
+		return -ENODEV;
+
+	retval = tty_standard_install(driver, tty);
+	if (retval)
+		goto error;
+
+	tty->driver_data = gb_tty;
+	return 0;
+error:
+	tty_port_put(&gb_tty->port);
+	return retval;
+}
+
+static int gb_tty_open(struct tty_struct *tty, struct file *file)
+{
+	struct gb_tty *gb_tty = tty->driver_data;
+
+	return tty_port_open(&gb_tty->port, tty, file);
+}
+
+static void gb_tty_close(struct tty_struct *tty, struct file *file)
+{
+	struct gb_tty *gb_tty = tty->driver_data;
+
+	tty_port_close(&gb_tty->port, tty, file);
+}
+
+static void gb_tty_cleanup(struct tty_struct *tty)
+{
+	struct gb_tty *gb_tty = tty->driver_data;
+
+	tty_port_put(&gb_tty->port);
+}
+
+static void gb_tty_hangup(struct tty_struct *tty)
+{
+	struct gb_tty *gb_tty = tty->driver_data;
+
+	tty_port_hangup(&gb_tty->port);
+}
+
+static int gb_tty_write(struct tty_struct *tty, const unsigned char *buf,
+			int count)
+{
+	struct gb_tty *gb_tty = tty->driver_data;
+
+	return send_data(gb_tty, count, buf);
+}
+
+static int gb_tty_write_room(struct tty_struct *tty)
+{
+//	struct gb_tty *gb_tty = tty->driver_data;
+
+	// FIXME - how much do we want to say we have room for?
+	return 0;
+}
+
+static int gb_tty_chars_in_buffer(struct tty_struct *tty)
+{
+//	struct gb_tty *gb_tty = tty->driver_data;
+
+	// FIXME - how many left to send?
+	return 0;
+}
+
+static int gb_tty_break_ctl(struct tty_struct *tty, int state)
+{
+	struct gb_tty *gb_tty = tty->driver_data;
+
+	return send_break(gb_tty, state ? 1 : 0);
+}
+
+static void gb_tty_set_termios(struct tty_struct *tty,
+			       struct ktermios *termios_old)
+{
+	struct gb_tty *gb_tty = tty->driver_data;
+	struct ktermios *termios = &tty->termios;
+	struct gb_serial_line_coding newline;
+	int newctrl = gb_tty->ctrlout;
+
+	newline.rate = cpu_to_le32(tty_get_baud_rate(tty));
+	newline.format = termios->c_cflag & CSTOPB ? 2 : 0;
+	newline.parity = termios->c_cflag & PARENB ?
+				(termios->c_cflag & PARODD ? 1 : 2) +
+				(termios->c_cflag & CMSPAR ? 2 : 0) : 0;
+
+	switch (termios->c_cflag & CSIZE) {
+	case CS5:
+		newline.data = 5;
+		break;
+	case CS6:
+		newline.data = 6;
+		break;
+	case CS7:
+		newline.data = 7;
+		break;
+	case CS8:
+	default:
+		newline.data = 8;
+		break;
+	}
+
+	/* FIXME: needs to clear unsupported bits in the termios */
+	gb_tty->clocal = ((termios->c_cflag & CLOCAL) != 0);
+
+	if (C_BAUD(tty) == B0) {
+		newline.rate = gb_tty->line_coding.rate;
+		newctrl &= GB_UART_CTRL_DTR;
+	} else if (termios_old && (termios_old->c_cflag & CBAUD) == B0) {
+		newctrl |= GB_UART_CTRL_DTR;
+	}
+
+	if (newctrl != gb_tty->ctrlout) {
+		gb_tty->ctrlout = newctrl;
+		send_control(gb_tty, newctrl);
+	}
+
+	if (memcpy(&gb_tty->line_coding, &newline, sizeof(newline))) {
+		memcpy(&gb_tty->line_coding, &newline, sizeof(newline));
+		send_line_coding(gb_tty);
+	}
+}
+
+static int gb_tty_tiocmget(struct tty_struct *tty)
+{
+	struct gb_tty *gb_tty = tty->driver_data;
+
+	return (gb_tty->ctrlout & GB_UART_CTRL_DTR ? TIOCM_DTR : 0) |
+	       (gb_tty->ctrlout & GB_UART_CTRL_RTS ? TIOCM_RTS : 0) |
+	       (gb_tty->ctrlin  & GB_UART_CTRL_DSR ? TIOCM_DSR : 0) |
+	       (gb_tty->ctrlin  & GB_UART_CTRL_RI  ? TIOCM_RI  : 0) |
+	       (gb_tty->ctrlin  & GB_UART_CTRL_DCD ? TIOCM_CD  : 0) |
+	       TIOCM_CTS;
+}
+
+static int gb_tty_tiocmset(struct tty_struct *tty, unsigned int set,
+			   unsigned int clear)
+{
+	struct gb_tty *gb_tty = tty->driver_data;
+	unsigned int newctrl = gb_tty->ctrlout;
+
+	set = (set & TIOCM_DTR ? GB_UART_CTRL_DTR : 0) |
+	      (set & TIOCM_RTS ? GB_UART_CTRL_RTS : 0);
+	clear = (clear & TIOCM_DTR ? GB_UART_CTRL_DTR : 0) |
+		(clear & TIOCM_RTS ? GB_UART_CTRL_RTS : 0);
+
+	newctrl = (newctrl & ~clear) | set;
+	if (gb_tty->ctrlout == newctrl)
+		return 0;
+
+	gb_tty->ctrlout = newctrl;
+	return send_control(gb_tty, newctrl);
+}
+
+static void gb_tty_throttle(struct tty_struct *tty)
+{
+	struct gb_tty *gb_tty = tty->driver_data;
+	unsigned char stop_char;
+	int retval;
+
+	if (I_IXOFF(tty)) {
+		stop_char = STOP_CHAR(tty);
+		retval = gb_tty_write(tty, &stop_char, 1);
+		if (retval <= 0)
+			return;
+	}
+
+	if (tty->termios.c_cflag & CRTSCTS) {
+		gb_tty->ctrlout &= ~GB_UART_CTRL_RTS;
+		retval = send_control(gb_tty, gb_tty->ctrlout);
+	}
+
+}
+
+static void gb_tty_unthrottle(struct tty_struct *tty)
+{
+	struct gb_tty *gb_tty = tty->driver_data;
+	unsigned char start_char;
+	int retval;
+
+	if (I_IXOFF(tty)) {
+		start_char = START_CHAR(tty);
+		retval = gb_tty_write(tty, &start_char, 1);
+		if (retval <= 0)
+			return;
+	}
+
+	if (tty->termios.c_cflag & CRTSCTS) {
+		gb_tty->ctrlout |= GB_UART_CTRL_RTS;
+		retval = send_control(gb_tty, gb_tty->ctrlout);
+	}
+}
+
+static int get_serial_info(struct gb_tty *gb_tty,
+			   struct serial_struct __user *info)
+{
+	struct serial_struct tmp;
+
+	if (!info)
+		return -EINVAL;
+
+	memset(&tmp, 0, sizeof(tmp));
+	tmp.flags = ASYNC_LOW_LATENCY | ASYNC_SKIP_TEST;
+	tmp.type = PORT_16550A;
+	tmp.line = gb_tty->minor;
+	tmp.xmit_fifo_size = 16;
+	tmp.baud_base = 9600;
+	tmp.close_delay = gb_tty->port.close_delay / 10;
+	tmp.closing_wait = gb_tty->port.closing_wait == ASYNC_CLOSING_WAIT_NONE ?
+				ASYNC_CLOSING_WAIT_NONE : gb_tty->port.closing_wait / 10;
+
+	if (copy_to_user(info, &tmp, sizeof(tmp)))
+		return -EFAULT;
+	return 0;
+}
+
+static int set_serial_info(struct gb_tty *gb_tty,
+			   struct serial_struct __user *newinfo)
+{
+	struct serial_struct new_serial;
+	unsigned int closing_wait;
+	unsigned int close_delay;
+	int retval = 0;
+
+	if (copy_from_user(&new_serial, newinfo, sizeof(new_serial)))
+		return -EFAULT;
+
+	close_delay = new_serial.close_delay * 10;
+	closing_wait = new_serial.closing_wait == ASYNC_CLOSING_WAIT_NONE ?
+			ASYNC_CLOSING_WAIT_NONE : new_serial.closing_wait * 10;
+
+	mutex_lock(&gb_tty->port.mutex);
+	if (!capable(CAP_SYS_ADMIN)) {
+		if ((close_delay != gb_tty->port.close_delay) ||
+		    (closing_wait != gb_tty->port.closing_wait))
+			retval = -EPERM;
+		else
+			retval = -EOPNOTSUPP;
+	} else {
+		gb_tty->port.close_delay = close_delay;
+		gb_tty->port.closing_wait = closing_wait;
+	}
+	mutex_unlock(&gb_tty->port.mutex);
+	return retval;
+}
+
+static int wait_serial_change(struct gb_tty *gb_tty, unsigned long arg)
+{
+	int retval = 0;
+	DECLARE_WAITQUEUE(wait, current);
+	struct async_icount old;
+	struct async_icount new;
+
+	if (!(arg & (TIOCM_DSR | TIOCM_RI | TIOCM_CD)))
+		return -EINVAL;
+
+	do {
+		spin_lock_irq(&gb_tty->read_lock);
+		old = gb_tty->oldcount;
+		new = gb_tty->iocount;
+		gb_tty->oldcount = new;
+		spin_unlock_irq(&gb_tty->read_lock);
+
+		if ((arg & TIOCM_DSR) && (old.dsr != new.dsr))
+			break;
+		if ((arg & TIOCM_CD) && (old.dcd != new.dcd))
+			break;
+		if ((arg & TIOCM_RI) && (old.rng != new.rng))
+			break;
+
+		add_wait_queue(&gb_tty->wioctl, &wait);
+		set_current_state(TASK_INTERRUPTIBLE);
+		schedule();
+		remove_wait_queue(&gb_tty->wioctl, &wait);
+		if (gb_tty->disconnected) {
+			if (arg & TIOCM_CD)
+				break;
+			retval = -ENODEV;
+		} else if (signal_pending(current)) {
+			retval = -ERESTARTSYS;
+		}
+	} while (!retval);
+
+	return retval;
+}
+
+static int get_serial_usage(struct gb_tty *gb_tty,
+			    struct serial_icounter_struct __user *count)
+{
+	struct serial_icounter_struct icount;
+	int retval = 0;
+
+	memset(&icount, 0, sizeof(icount));
+	icount.dsr = gb_tty->iocount.dsr;
+	icount.rng = gb_tty->iocount.rng;
+	icount.dcd = gb_tty->iocount.dcd;
+	icount.frame = gb_tty->iocount.frame;
+	icount.overrun = gb_tty->iocount.overrun;
+	icount.parity = gb_tty->iocount.parity;
+	icount.brk = gb_tty->iocount.brk;
+
+	if (copy_to_user(count, &icount, sizeof(icount)) > 0)
+		retval = -EFAULT;
+
+	return retval;
+}
+
+static int gb_tty_ioctl(struct tty_struct *tty, unsigned int cmd,
+			unsigned long arg)
+{
+	struct gb_tty *gb_tty = tty->driver_data;
+
+	switch (cmd) {
+	case TIOCGSERIAL:
+		return get_serial_info(gb_tty,
+				       (struct serial_struct __user *)arg);
+	case TIOCSSERIAL:
+		return set_serial_info(gb_tty,
+				       (struct serial_struct __user *)arg);
+	case TIOCMIWAIT:
+		return wait_serial_change(gb_tty, arg);
+	case TIOCGICOUNT:
+		return get_serial_usage(gb_tty,
+					(struct serial_icounter_struct __user *)arg);
+	}
+
+	return -ENOIOCTLCMD;
+}
+
+
+static const struct tty_operations gb_ops = {
+	.install =		gb_tty_install,
+	.open =			gb_tty_open,
+	.close =		gb_tty_close,
+	.cleanup =		gb_tty_cleanup,
+	.hangup =		gb_tty_hangup,
+	.write =		gb_tty_write,
+	.write_room =		gb_tty_write_room,
+	.ioctl =		gb_tty_ioctl,
+	.throttle =		gb_tty_throttle,
+	.unthrottle =		gb_tty_unthrottle,
+	.chars_in_buffer =	gb_tty_chars_in_buffer,
+	.break_ctl =		gb_tty_break_ctl,
+	.set_termios =		gb_tty_set_termios,
+	.tiocmget =		gb_tty_tiocmget,
+	.tiocmset =		gb_tty_tiocmset,
+};
+
+
+static int gb_tty_init(void);
+static void gb_tty_exit(void);
+
+static int gb_uart_connection_init(struct gb_connection *connection)
+{
+	struct gb_tty *gb_tty;
+	struct device *tty_dev;
+	int retval;
+	int minor;
+
+	/* First time here, initialize the tty structures */
+	if (atomic_inc_return(&reference_count) == 1) {
+		retval = gb_tty_init();
+		if (retval) {
+			atomic_dec(&reference_count);
+			return retval;
+		}
+	}
+
+	gb_tty = kzalloc(sizeof(*gb_tty), GFP_KERNEL);
+	if (!gb_tty)
+		return -ENOMEM;
+	gb_tty->connection = connection;
+	connection->private = gb_tty;
+
+	/* Check for compatible protocol version */
+	retval = get_version(gb_tty);
+	if (retval)
+		goto error_version;
+
+	minor = alloc_minor(gb_tty);
+	if (minor < 0) {
+		if (minor == -ENOSPC) {
+			dev_err(&connection->dev,
+				"no more free minor numbers\n");
+			return -ENODEV;
+		}
+		return minor;
+	}
+
+	gb_tty->minor = minor;
+	spin_lock_init(&gb_tty->write_lock);
+	spin_lock_init(&gb_tty->read_lock);
+	init_waitqueue_head(&gb_tty->wioctl);
+	mutex_init(&gb_tty->mutex);
+
+	send_control(gb_tty, gb_tty->ctrlout);
+
+	/* initialize the uart to be 9600n81 */
+	gb_tty->line_coding.rate = cpu_to_le32(9600);
+	gb_tty->line_coding.format = GB_SERIAL_1_STOP_BITS;
+	gb_tty->line_coding.parity = GB_SERIAL_NO_PARITY;
+	gb_tty->line_coding.data = 8;
+	send_line_coding(gb_tty);
+
+	tty_dev = tty_port_register_device(&gb_tty->port, gb_tty_driver, minor,
+					   &connection->dev);
+	if (IS_ERR(tty_dev)) {
+		retval = PTR_ERR(tty_dev);
+		goto error;
+	}
+
+	return 0;
+error:
+	release_minor(gb_tty);
+error_version:
+	connection->private = NULL;
+	kfree(gb_tty);
+	return retval;
+}
+
+static void gb_uart_connection_exit(struct gb_connection *connection)
+{
+	struct gb_tty *gb_tty = connection->private;
+	struct tty_struct *tty;
+
+	if (!gb_tty)
+		return;
+
+	mutex_lock(&gb_tty->mutex);
+	gb_tty->disconnected = true;
+
+	wake_up_all(&gb_tty->wioctl);
+	connection->private = NULL;
+	mutex_unlock(&gb_tty->mutex);
+
+	tty = tty_port_tty_get(&gb_tty->port);
+	if (tty) {
+		tty_vhangup(tty);
+		tty_kref_put(tty);
+	}
+	/* FIXME - stop all traffic */
+
+	tty_unregister_device(gb_tty_driver, gb_tty->minor);
+
+	/* FIXME - free transmit / receive buffers */
+
+	tty_port_put(&gb_tty->port);
+
+	kfree(gb_tty);
+
+	/* If last device is gone, tear down the tty structures */
+	if (atomic_dec_return(&reference_count) == 0)
+		gb_tty_exit();
+}
+
+static int gb_tty_init(void)
+{
+	int retval = 0;
+
+	gb_tty_driver = tty_alloc_driver(GB_NUM_MINORS, 0);
+	if (IS_ERR(gb_tty_driver)) {
+		pr_err("Can not allocate tty driver\n");
+		retval = -ENOMEM;
+		goto fail_unregister_dev;
+	}
+
+	gb_tty_driver->driver_name = "gb";
+	gb_tty_driver->name = GB_NAME;
+	gb_tty_driver->major = 0;
+	gb_tty_driver->minor_start = 0;
+	gb_tty_driver->type = TTY_DRIVER_TYPE_SERIAL;
+	gb_tty_driver->subtype = SERIAL_TYPE_NORMAL;
+	gb_tty_driver->flags = TTY_DRIVER_REAL_RAW | TTY_DRIVER_DYNAMIC_DEV;
+	gb_tty_driver->init_termios = tty_std_termios;
+	gb_tty_driver->init_termios.c_cflag = B9600 | CS8 | CREAD | HUPCL | CLOCAL;
+	tty_set_operations(gb_tty_driver, &gb_ops);
+
+	retval = tty_register_driver(gb_tty_driver);
+	if (retval) {
+		pr_err("Can not register tty driver: %d\n", retval);
+		goto fail_put_gb_tty;
+	}
+
+	return 0;
+
+fail_put_gb_tty:
+	put_tty_driver(gb_tty_driver);
+fail_unregister_dev:
+	return retval;
+}
+
+static void gb_tty_exit(void)
+{
+	int major = MAJOR(gb_tty_driver->major);
+	int minor = gb_tty_driver->minor_start;
+
+	tty_unregister_driver(gb_tty_driver);
+	put_tty_driver(gb_tty_driver);
+	unregister_chrdev_region(MKDEV(major, minor), GB_NUM_MINORS);
+}
+
+static struct gb_protocol uart_protocol = {
+	.name			= "uart",
+	.id			= GREYBUS_PROTOCOL_UART,
+	.major			= 0,
+	.minor			= 1,
+	.connection_init	= gb_uart_connection_init,
+	.connection_exit	= gb_uart_connection_exit,
+	.request_recv		= NULL,	/* FIXME we have 2 types of requests!!! */
+};
+
+int gb_uart_protocol_init(void)
+{
+	return gb_protocol_register(&uart_protocol);
+}
+
+void gb_uart_protocol_exit(void)
+{
+	gb_protocol_deregister(&uart_protocol);
+}
