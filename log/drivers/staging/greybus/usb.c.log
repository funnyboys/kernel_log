commit ec0ad868173da8a75121f9dc116a5d5478ff614d
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Sun Aug 25 07:54:27 2019 +0200

    staging: greybus: move core include files to include/linux/greybus/
    
    With the goal of moving the core of the greybus code out of staging, the
    include files need to be moved to include/linux/greybus.h and
    include/linux/greybus/
    
    Cc: Vaibhav Hiremath <hvaibhav.linux@gmail.com>
    Cc: Johan Hovold <johan@kernel.org>
    Cc: Vaibhav Agarwal <vaibhav.sr@gmail.com>
    Cc: Rui Miguel Silva <rmfrfs@gmail.com>
    Cc: David Lin <dtwlin@gmail.com>
    Cc: "Bryan O'Donoghue" <pure.logic@nexus-software.ie>
    Cc: greybus-dev@lists.linaro.org
    Cc: devel@driverdev.osuosl.org
    Acked-by: Mark Greer <mgreer@animalcreek.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Acked-by: Alex Elder <elder@kernel.org>
    Link: https://lore.kernel.org/r/20190825055429.18547-8-gregkh@linuxfoundation.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/usb.c b/drivers/staging/greybus/usb.c
index 1c246c73a085..8e9d9d59a357 100644
--- a/drivers/staging/greybus/usb.c
+++ b/drivers/staging/greybus/usb.c
@@ -10,8 +10,8 @@
 #include <linux/slab.h>
 #include <linux/usb.h>
 #include <linux/usb/hcd.h>
+#include <linux/greybus.h>
 
-#include "greybus.h"
 #include "gbphy.h"
 
 /* Greybus USB request types */

commit 863dbc52e7f0e5acd7b4883f3933543a81c474c7
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Nov 7 14:58:42 2017 +0100

    staging: greybus: Remove redundant license text
    
    Now that the SPDX tag is in all greybus files, that identifies the
    license in a specific and legally-defined manner.  So the extra GPL text
    wording can be removed as it is no longer needed at all.
    
    This is done on a quest to remove the 700+ different ways that files in
    the kernel describe the GPL license text.  And there's unneeded stuff
    like the address (sometimes incorrect) for the FSF which is never
    needed.
    
    No copyright headers or other non-license-description text was removed.
    
    Cc: Vaibhav Hiremath <hvaibhav.linux@gmail.com>
    Reviewed-by: Alex Elder <elder@linaro.org>
    Acked-by: Vaibhav Agarwal <vaibhav.sr@gmail.com>
    Acked-by: David Lin <dtwlin@gmail.com>
    Acked-by: Johan Hovold <johan@kernel.org>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Acked-by: Mark Greer <mgreer@animalcreek.com>
    Acked-by: Rui Miguel Silva <rmfrfs@gmail.com>
    Acked-by: "Bryan O'Donoghue" <pure.logic@nexus-software.ie>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/usb.c b/drivers/staging/greybus/usb.c
index 4fde518d9b14..1c246c73a085 100644
--- a/drivers/staging/greybus/usb.c
+++ b/drivers/staging/greybus/usb.c
@@ -4,9 +4,6 @@
  *
  * Copyright 2014 Google Inc.
  * Copyright 2014 Linaro Ltd.
- *
- * Released under the GPLv2 only.
- *
  */
 #include <linux/kernel.h>
 #include <linux/module.h>

commit eb50fd3a22c770f36be275295b782f3ea52e3215
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Nov 7 14:58:41 2017 +0100

    staging: greybus: add SPDX identifiers to all greybus driver files
    
    It's good to have SPDX identifiers in all files to make it easier to
    audit the kernel tree for correct licenses.
    
    Update the drivers/staging/greybus files files with the correct SPDX
    license identifier based on the license text in the file itself.  The
    SPDX identifier is a legally binding shorthand, which can be used
    instead of the full boiler plate text.
    
    This work is based on a script and data from Thomas Gleixner, Philippe
    Ombredanne, and Kate Stewart.
    
    Cc: Vaibhav Hiremath <hvaibhav.linux@gmail.com>
    Cc: "Bryan O'Donoghue" <pure.logic@nexus-software.ie>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: Philippe Ombredanne <pombredanne@nexb.com>
    Acked-by: Vaibhav Agarwal <vaibhav.sr@gmail.com>
    Acked-by: David Lin <dtwlin@gmail.com>
    Reviewed-by: Alex Elder <elder@linaro.org>
    Acked-by: Johan Hovold <johan@kernel.org>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Acked-by: Mark Greer <mgreer@animalcreek.com>
    Acked-by: Rui Miguel Silva <rmfrfs@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/usb.c b/drivers/staging/greybus/usb.c
index f93a76d02de6..4fde518d9b14 100644
--- a/drivers/staging/greybus/usb.c
+++ b/drivers/staging/greybus/usb.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * USB host driver for the Greybus "generic" USB module.
  *

commit bea1e0f817fb94cf466da123e41a9bca489f25b1
Author: Julia Lawall <Julia.Lawall@lip6.fr>
Date:   Fri Jul 28 22:41:57 2017 +0200

    greybus: usb: constify hc_driver structures
    
    The hc_driver structure is only passed as the first argument to
    usb_create_hcd, which is declared as const.  Thus the hc_driver structure
    itself can be const.
    
    Done with the help of Coccinelle.
    
    Signed-off-by: Julia Lawall <Julia.Lawall@lip6.fr>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/usb.c b/drivers/staging/greybus/usb.c
index ccadda084b76..f93a76d02de6 100644
--- a/drivers/staging/greybus/usb.c
+++ b/drivers/staging/greybus/usb.c
@@ -139,7 +139,7 @@ static int hub_control(struct usb_hcd *hcd, u16 typeReq, u16 wValue, u16 wIndex,
 	return ret;
 }
 
-static struct hc_driver usb_gb_hc_driver = {
+static const struct hc_driver usb_gb_hc_driver = {
 	.description = "greybus-hcd",
 	.product_desc = "Greybus USB Host Controller",
 	.hcd_priv_size = sizeof(struct gb_usb_device),

commit 64060fe95458f22bac7327b2ee8dc5ce9e488d44
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Mon May 30 11:31:53 2016 +0530

    greybus: gbphy: Remove protocol specific version handling
    
    We should be using the generic version handling at bundle level, instead
    of at protocol level for bridged PHY devices as well.
    
    The bundle version handling is already in place, though it is *not* used
    today as we haven't bumped the version of control protocol yet.
    
    Remove protocol specific handling for bridged PHY devices.
    
    Tested on EVT 1.5 with gpbridge-test module. No nuttx changes are
    required with this.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Reviewed-by: Johan Hovold <johan@hovoldconsulting.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/usb.c b/drivers/staging/greybus/usb.c
index e5ba34ac7643..ccadda084b76 100644
--- a/drivers/staging/greybus/usb.c
+++ b/drivers/staging/greybus/usb.c
@@ -190,10 +190,6 @@ static int gb_usb_probe(struct gbphy_device *gbphy_dev,
 	if (retval)
 		goto exit_connection_destroy;
 
-	retval = gb_gbphy_get_version(connection);
-	if (retval)
-		goto exit_connection_disable;
-
 	/*
 	 * FIXME: The USB bridged-PHY protocol driver depends on changes to
 	 *        USB core which are not yet upstream.

commit 5e569115e9b9d4af631589b9d9cc5227a660b008
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Mon May 30 11:31:52 2016 +0530

    greybus: Remove unused VERSION specific macros
    
    We don't use these anymore. Drop them.
    
    Note that some macro's specific to bridged PHY devices aren't removed in
    the patch, as gbsim will break otherwise. They will be removed
    separately.
    
    Compile tested.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/usb.c b/drivers/staging/greybus/usb.c
index 7ed6a60c1d56..e5ba34ac7643 100644
--- a/drivers/staging/greybus/usb.c
+++ b/drivers/staging/greybus/usb.c
@@ -16,10 +16,6 @@
 #include "greybus.h"
 #include "gbphy.h"
 
-/* Version of the Greybus USB protocol we support */
-#define GB_USB_VERSION_MAJOR		0x00
-#define GB_USB_VERSION_MINOR		0x01
-
 /* Greybus USB request types */
 #define GB_USB_TYPE_HCD_START		0x02
 #define GB_USB_TYPE_HCD_STOP		0x03

commit e54b106dd1be50377fe8365392466e080b659ab6
Author: Sandeep Patil <patil_sandeep@projectara.com>
Date:   Thu May 19 08:52:39 2016 -0700

    greybus: gpbridge: rename 'gpbridge' to 'gbphy' everywhere
    
    The 'gpbridge' name didn't relaly reflect what the bus is; which
    is a bus for bridged-phy devices. So, rename all instances
    of 'gpbridge' to more appropriate 'gbphy'
    
    Testing Done:
    Build and boot tested. 'lsgb' will stop displaying 'GPBridge' devices
    until I change the library to reflect this change.
    
    Signed-off-by: Sandeep Patil <patil_sandeep@projectara.com>
    Suggested-by: Greg Kroah-Hartman <gregkh@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/usb.c b/drivers/staging/greybus/usb.c
index 2f68a1b49e3c..7ed6a60c1d56 100644
--- a/drivers/staging/greybus/usb.c
+++ b/drivers/staging/greybus/usb.c
@@ -14,7 +14,7 @@
 #include <linux/usb/hcd.h>
 
 #include "greybus.h"
-#include "gpbridge.h"
+#include "gbphy.h"
 
 /* Version of the Greybus USB protocol we support */
 #define GB_USB_VERSION_MAJOR		0x00
@@ -38,7 +38,7 @@ struct gb_usb_hub_control_response {
 
 struct gb_usb_device {
 	struct gb_connection *connection;
-	struct gpbridge_device *gpbdev;
+	struct gbphy_device *gbphy_dev;
 };
 
 static inline struct gb_usb_device *to_gb_usb_device(struct usb_hcd *hcd)
@@ -59,7 +59,7 @@ static void hcd_stop(struct usb_hcd *hcd)
 	ret = gb_operation_sync(dev->connection, GB_USB_TYPE_HCD_STOP,
 				NULL, 0, NULL, 0);
 	if (ret)
-		dev_err(&dev->gpbdev->dev, "HCD stop failed '%d'\n", ret);
+		dev_err(&dev->gbphy_dev->dev, "HCD stop failed '%d'\n", ret);
 }
 
 static int hcd_start(struct usb_hcd *hcd)
@@ -71,7 +71,7 @@ static int hcd_start(struct usb_hcd *hcd)
 	ret = gb_operation_sync(dev->connection, GB_USB_TYPE_HCD_START,
 				NULL, 0, NULL, 0);
 	if (ret) {
-		dev_err(&dev->gpbdev->dev, "HCD start failed '%d'\n", ret);
+		dev_err(&dev->gbphy_dev->dev, "HCD start failed '%d'\n", ret);
 		return ret;
 	}
 
@@ -161,11 +161,11 @@ static struct hc_driver usb_gb_hc_driver = {
 	.hub_control = hub_control,
 };
 
-static int gb_usb_probe(struct gpbridge_device *gpbdev,
-			const struct gpbridge_device_id *id)
+static int gb_usb_probe(struct gbphy_device *gbphy_dev,
+			const struct gbphy_device_id *id)
 {
 	struct gb_connection *connection;
-	struct device *dev = &gpbdev->dev;
+	struct device *dev = &gbphy_dev->dev;
 	struct gb_usb_device *gb_usb_dev;
 	struct usb_hcd *hcd;
 	int retval;
@@ -174,8 +174,8 @@ static int gb_usb_probe(struct gpbridge_device *gpbdev,
 	if (!hcd)
 		return -ENOMEM;
 
-	connection = gb_connection_create(gpbdev->bundle,
-					  le16_to_cpu(gpbdev->cport_desc->id),
+	connection = gb_connection_create(gbphy_dev->bundle,
+					  le16_to_cpu(gbphy_dev->cport_desc->id),
 					  NULL);
 	if (IS_ERR(connection)) {
 		retval = PTR_ERR(connection);
@@ -185,8 +185,8 @@ static int gb_usb_probe(struct gpbridge_device *gpbdev,
 	gb_usb_dev = to_gb_usb_device(hcd);
 	gb_usb_dev->connection = connection;
 	gb_connection_set_data(connection, gb_usb_dev);
-	gb_usb_dev->gpbdev = gpbdev;
-	gb_gpbridge_set_data(gpbdev, gb_usb_dev);
+	gb_usb_dev->gbphy_dev = gbphy_dev;
+	gb_gbphy_set_data(gbphy_dev, gb_usb_dev);
 
 	hcd->has_tt = 1;
 
@@ -194,7 +194,7 @@ static int gb_usb_probe(struct gpbridge_device *gpbdev,
 	if (retval)
 		goto exit_connection_destroy;
 
-	retval = gb_gpbridge_get_version(connection);
+	retval = gb_gbphy_get_version(connection);
 	if (retval)
 		goto exit_connection_disable;
 
@@ -226,9 +226,9 @@ static int gb_usb_probe(struct gpbridge_device *gpbdev,
 	return retval;
 }
 
-static void gb_usb_remove(struct gpbridge_device *gpbdev)
+static void gb_usb_remove(struct gbphy_device *gbphy_dev)
 {
-	struct gb_usb_device *gb_usb_dev = gb_gpbridge_get_data(gpbdev);
+	struct gb_usb_device *gb_usb_dev = gb_gbphy_get_data(gbphy_dev);
 	struct gb_connection *connection = gb_usb_dev->connection;
 	struct usb_hcd *hcd = gb_usb_device_to_hcd(gb_usb_dev);
 
@@ -238,18 +238,18 @@ static void gb_usb_remove(struct gpbridge_device *gpbdev)
 	usb_put_hcd(hcd);
 }
 
-static const struct gpbridge_device_id gb_usb_id_table[] = {
-	{ GPBRIDGE_PROTOCOL(GREYBUS_PROTOCOL_USB) },
+static const struct gbphy_device_id gb_usb_id_table[] = {
+	{ GBPHY_PROTOCOL(GREYBUS_PROTOCOL_USB) },
 	{ },
 };
-MODULE_DEVICE_TABLE(gpbridge, gb_usb_id_table);
+MODULE_DEVICE_TABLE(gbphy, gb_usb_id_table);
 
-static struct gpbridge_driver usb_driver = {
+static struct gbphy_driver usb_driver = {
 	.name		= "usb",
 	.probe		= gb_usb_probe,
 	.remove		= gb_usb_remove,
 	.id_table	= gb_usb_id_table,
 };
 
-module_gpbridge_driver(usb_driver);
+module_gbphy_driver(usb_driver);
 MODULE_LICENSE("GPL v2");

commit ea7c47771ba13e143b3c328af8e03a1c45045cf0
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Mon May 9 18:15:12 2016 +0530

    greybus: usb: Create separate module
    
    Create separate module for usb gpbridge driver.
    
    Tested on EVT 1.5 by inserting GP test module, all the devices were
    enumerated correctly.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/usb.c b/drivers/staging/greybus/usb.c
index 2b4789bde0c2..2f68a1b49e3c 100644
--- a/drivers/staging/greybus/usb.c
+++ b/drivers/staging/greybus/usb.c
@@ -242,6 +242,7 @@ static const struct gpbridge_device_id gb_usb_id_table[] = {
 	{ GPBRIDGE_PROTOCOL(GREYBUS_PROTOCOL_USB) },
 	{ },
 };
+MODULE_DEVICE_TABLE(gpbridge, gb_usb_id_table);
 
 static struct gpbridge_driver usb_driver = {
 	.name		= "usb",
@@ -249,4 +250,6 @@ static struct gpbridge_driver usb_driver = {
 	.remove		= gb_usb_remove,
 	.id_table	= gb_usb_id_table,
 };
-gb_gpbridge_builtin_driver(usb_driver);
+
+module_gpbridge_driver(usb_driver);
+MODULE_LICENSE("GPL v2");

commit 4dda7e96cfc6474d88682547180a9e42687c5a6e
Author: Greg Kroah-Hartman <gregkh@google.com>
Date:   Thu May 5 14:32:36 2016 +0530

    greybus: USB: convert to a gpbridge driver
    
    This converts the USB driver to be a gpbridge driver, moving it away
    from the "legacy" interface.
    
    It's not like this code even does anything at the moment, how much
    trouble could we cause with this change?  :)
    
    Testing Done: Tested on gbsim.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>
    Signed-off-by: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
    [vaibhav.hiremath@linaro.org: 1.Changed code to retain init/exit fns of
    drivers. 2.Exit path fix. 3. Fixed review comments]
    Reviewed-by: Viresh Kumar <viresh.kumar@linaro.org>
    Tested-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/usb.c b/drivers/staging/greybus/usb.c
index 25a6c7e5e5ba..2b4789bde0c2 100644
--- a/drivers/staging/greybus/usb.c
+++ b/drivers/staging/greybus/usb.c
@@ -38,6 +38,7 @@ struct gb_usb_hub_control_response {
 
 struct gb_usb_device {
 	struct gb_connection *connection;
+	struct gpbridge_device *gpbdev;
 };
 
 static inline struct gb_usb_device *to_gb_usb_device(struct usb_hcd *hcd)
@@ -58,8 +59,7 @@ static void hcd_stop(struct usb_hcd *hcd)
 	ret = gb_operation_sync(dev->connection, GB_USB_TYPE_HCD_STOP,
 				NULL, 0, NULL, 0);
 	if (ret)
-		dev_err(&dev->connection->bundle->dev,
-			"HCD stop failed '%d'\n", ret);
+		dev_err(&dev->gpbdev->dev, "HCD stop failed '%d'\n", ret);
 }
 
 static int hcd_start(struct usb_hcd *hcd)
@@ -71,8 +71,7 @@ static int hcd_start(struct usb_hcd *hcd)
 	ret = gb_operation_sync(dev->connection, GB_USB_TYPE_HCD_START,
 				NULL, 0, NULL, 0);
 	if (ret) {
-		dev_err(&dev->connection->bundle->dev,
-			"HCD start failed '%d'\n", ret);
+		dev_err(&dev->gpbdev->dev, "HCD start failed '%d'\n", ret);
 		return ret;
 	}
 
@@ -162,24 +161,43 @@ static struct hc_driver usb_gb_hc_driver = {
 	.hub_control = hub_control,
 };
 
-static int gb_usb_connection_init(struct gb_connection *connection)
+static int gb_usb_probe(struct gpbridge_device *gpbdev,
+			const struct gpbridge_device_id *id)
 {
-	struct device *dev = &connection->bundle->dev;
+	struct gb_connection *connection;
+	struct device *dev = &gpbdev->dev;
 	struct gb_usb_device *gb_usb_dev;
 	struct usb_hcd *hcd;
-
 	int retval;
 
 	hcd = usb_create_hcd(&usb_gb_hc_driver, dev, dev_name(dev));
 	if (!hcd)
 		return -ENOMEM;
 
+	connection = gb_connection_create(gpbdev->bundle,
+					  le16_to_cpu(gpbdev->cport_desc->id),
+					  NULL);
+	if (IS_ERR(connection)) {
+		retval = PTR_ERR(connection);
+		goto exit_usb_put;
+	}
+
 	gb_usb_dev = to_gb_usb_device(hcd);
 	gb_usb_dev->connection = connection;
 	gb_connection_set_data(connection, gb_usb_dev);
+	gb_usb_dev->gpbdev = gpbdev;
+	gb_gpbridge_set_data(gpbdev, gb_usb_dev);
 
 	hcd->has_tt = 1;
 
+	retval = gb_connection_enable(connection);
+	if (retval)
+		goto exit_connection_destroy;
+
+	retval = gb_gpbridge_get_version(connection);
+	if (retval)
+		goto exit_connection_disable;
+
 	/*
 	 * FIXME: The USB bridged-PHY protocol driver depends on changes to
 	 *        USB core which are not yet upstream.
@@ -189,38 +207,46 @@ static int gb_usb_connection_init(struct gb_connection *connection)
 	if (1) {
 		dev_warn(dev, "USB protocol disabled\n");
 		retval = -EPROTONOSUPPORT;
-		goto err_put_hcd;
+		goto exit_connection_disable;
 	}
 
 	retval = usb_add_hcd(hcd, 0, 0);
 	if (retval)
-		goto err_put_hcd;
+		goto exit_connection_disable;
 
 	return 0;
 
-err_put_hcd:
+exit_connection_disable:
+	gb_connection_disable(connection);
+exit_connection_destroy:
+	gb_connection_destroy(connection);
+exit_usb_put:
 	usb_put_hcd(hcd);
 
 	return retval;
 }
 
-static void gb_usb_connection_exit(struct gb_connection *connection)
+static void gb_usb_remove(struct gpbridge_device *gpbdev)
 {
-	struct gb_usb_device *gb_usb_dev = gb_connection_get_data(connection);
+	struct gb_usb_device *gb_usb_dev = gb_gpbridge_get_data(gpbdev);
+	struct gb_connection *connection = gb_usb_dev->connection;
 	struct usb_hcd *hcd = gb_usb_device_to_hcd(gb_usb_dev);
 
 	usb_remove_hcd(hcd);
+	gb_connection_disable(connection);
+	gb_connection_destroy(connection);
 	usb_put_hcd(hcd);
 }
 
-static struct gb_protocol usb_protocol = {
-	.name			= "usb",
-	.id			= GREYBUS_PROTOCOL_USB,
-	.major			= GB_USB_VERSION_MAJOR,
-	.minor			= GB_USB_VERSION_MINOR,
-	.connection_init	= gb_usb_connection_init,
-	.connection_exit	= gb_usb_connection_exit,
-	.request_recv		= NULL,	/* FIXME we have requests!!! */
+static const struct gpbridge_device_id gb_usb_id_table[] = {
+	{ GPBRIDGE_PROTOCOL(GREYBUS_PROTOCOL_USB) },
+	{ },
 };
 
-gb_builtin_protocol_driver(usb_protocol);
+static struct gpbridge_driver usb_driver = {
+	.name		= "usb",
+	.probe		= gb_usb_probe,
+	.remove		= gb_usb_remove,
+	.id_table	= gb_usb_id_table,
+};
+gb_gpbridge_builtin_driver(usb_driver);

commit 0ec306324423444d3ee0222708ef9de7f5586b93
Author: Greg Kroah-Hartman <gregkh@google.com>
Date:   Tue Mar 22 14:30:35 2016 -0400

    greybus: convert drivers to use connection->private set/get
    
    This converts all drivers to use the gb_connection_get_data() and
    gb_connection_set_data() functions to make it a bit more explicit as to
    what is going on.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>
    Reviewed-by: Alex Elder <elder@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/usb.c b/drivers/staging/greybus/usb.c
index 0cfc00f39b46..25a6c7e5e5ba 100644
--- a/drivers/staging/greybus/usb.c
+++ b/drivers/staging/greybus/usb.c
@@ -176,7 +176,7 @@ static int gb_usb_connection_init(struct gb_connection *connection)
 
 	gb_usb_dev = to_gb_usb_device(hcd);
 	gb_usb_dev->connection = connection;
-	connection->private = gb_usb_dev;
+	gb_connection_set_data(connection, gb_usb_dev);
 
 	hcd->has_tt = 1;
 
@@ -206,7 +206,7 @@ static int gb_usb_connection_init(struct gb_connection *connection)
 
 static void gb_usb_connection_exit(struct gb_connection *connection)
 {
-	struct gb_usb_device *gb_usb_dev = connection->private;
+	struct gb_usb_device *gb_usb_dev = gb_connection_get_data(connection);
 	struct usb_hcd *hcd = gb_usb_device_to_hcd(gb_usb_dev);
 
 	usb_remove_hcd(hcd);

commit c7b07265046b5db56778dc8c2cfc9056413ec5ba
Author: Greg Kroah-Hartman <gregkh@google.com>
Date:   Sun Feb 28 14:42:54 2016 -0800

    greybus: gpbridge.h: move protocol init/exit prototypes
    
    Create gpbridge.h for the gpbridge-specific function prototypes, the
    rest of the greybus drivers don't care about them.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>
    Reviewed-by: Viresh Kumar <viresh.kumar@linaro.org>
    Reviewed-by: Johan Hovold <johan@hovoldconsulting.com>

diff --git a/drivers/staging/greybus/usb.c b/drivers/staging/greybus/usb.c
index 6647868b4960..0cfc00f39b46 100644
--- a/drivers/staging/greybus/usb.c
+++ b/drivers/staging/greybus/usb.c
@@ -14,6 +14,7 @@
 #include <linux/usb/hcd.h>
 
 #include "greybus.h"
+#include "gpbridge.h"
 
 /* Version of the Greybus USB protocol we support */
 #define GB_USB_VERSION_MAJOR		0x00

commit dfdc6e12c8a3b1bc0c123abeb3679208b31a19f6
Author: Greg Kroah-Hartman <gregkh@google.com>
Date:   Wed Oct 14 11:20:00 2015 -0700

    greybus: usb: use the bundle struct device instead of the connector
    
    We are removing struct device from the gb_connection structure in the
    near future.  The gb_bundle structure's struct device should be used as
    a replacement.
    
    This patch moves the usb driver to use the bundle pointer instead of the
    connection pointer.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>
    Reviewed-by: Alex Elder <elder@linaro.org>

diff --git a/drivers/staging/greybus/usb.c b/drivers/staging/greybus/usb.c
index 2133d0d25f25..6647868b4960 100644
--- a/drivers/staging/greybus/usb.c
+++ b/drivers/staging/greybus/usb.c
@@ -57,7 +57,8 @@ static void hcd_stop(struct usb_hcd *hcd)
 	ret = gb_operation_sync(dev->connection, GB_USB_TYPE_HCD_STOP,
 				NULL, 0, NULL, 0);
 	if (ret)
-		dev_err(&dev->connection->dev, "HCD stop failed '%d'\n", ret);
+		dev_err(&dev->connection->bundle->dev,
+			"HCD stop failed '%d'\n", ret);
 }
 
 static int hcd_start(struct usb_hcd *hcd)
@@ -69,7 +70,8 @@ static int hcd_start(struct usb_hcd *hcd)
 	ret = gb_operation_sync(dev->connection, GB_USB_TYPE_HCD_START,
 				NULL, 0, NULL, 0);
 	if (ret) {
-		dev_err(&dev->connection->dev, "HCD start failed '%d'\n", ret);
+		dev_err(&dev->connection->bundle->dev,
+			"HCD start failed '%d'\n", ret);
 		return ret;
 	}
 
@@ -161,7 +163,7 @@ static struct hc_driver usb_gb_hc_driver = {
 
 static int gb_usb_connection_init(struct gb_connection *connection)
 {
-	struct device *dev = &connection->dev;
+	struct device *dev = &connection->bundle->dev;
 	struct gb_usb_device *gb_usb_dev;
 	struct usb_hcd *hcd;
 
@@ -184,7 +186,7 @@ static int gb_usb_connection_init(struct gb_connection *connection)
 	 *        Disable for now.
 	 */
 	if (1) {
-		dev_warn(&connection->dev, "USB protocol disabled\n");
+		dev_warn(dev, "USB protocol disabled\n");
 		retval = -EPROTONOSUPPORT;
 		goto err_put_hcd;
 	}

commit 0a12a187fdaa90108a681423a7f1e8ef135a1544
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Tue Aug 11 07:36:12 2015 +0530

    greybus: usb: Drop get_version support
    
    This is done from a common place now, no need to replicate it.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/usb.c b/drivers/staging/greybus/usb.c
index 80c42b20adda..2133d0d25f25 100644
--- a/drivers/staging/greybus/usb.c
+++ b/drivers/staging/greybus/usb.c
@@ -20,8 +20,6 @@
 #define GB_USB_VERSION_MINOR		0x01
 
 /* Greybus USB request types */
-#define GB_USB_TYPE_INVALID		0x00
-#define GB_USB_TYPE_PROTOCOL_VERSION	0x01
 #define GB_USB_TYPE_HCD_START		0x02
 #define GB_USB_TYPE_HCD_STOP		0x03
 #define GB_USB_TYPE_HUB_CONTROL		0x04
@@ -39,9 +37,6 @@ struct gb_usb_hub_control_response {
 
 struct gb_usb_device {
 	struct gb_connection *connection;
-
-	u8 version_major;
-	u8 version_minor;
 };
 
 static inline struct gb_usb_device *to_gb_usb_device(struct usb_hcd *hcd)
@@ -54,9 +49,6 @@ static inline struct usb_hcd *gb_usb_device_to_hcd(struct gb_usb_device *dev)
 	return container_of((void *)dev, struct usb_hcd, hcd_priv);
 }
 
-/* Define get_version() routine */
-define_get_version(gb_usb_device, USB);
-
 static void hcd_stop(struct usb_hcd *hcd)
 {
 	struct gb_usb_device *dev = to_gb_usb_device(hcd);
@@ -183,11 +175,6 @@ static int gb_usb_connection_init(struct gb_connection *connection)
 	gb_usb_dev->connection = connection;
 	connection->private = gb_usb_dev;
 
-	/* Check for compatible protocol version */
-	retval = get_version(gb_usb_dev);
-	if (retval)
-		goto err_put_hcd;
-
 	hcd->has_tt = 1;
 
 	/*

commit f514b5c31435909960fe32e309d7417c52629cc1
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Sat Aug 8 10:25:40 2015 +0530

    greybus: usb: Use (already defined) major/minor macros
    
    We already have macros for these, use them instead of writing fixed
    values.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/usb.c b/drivers/staging/greybus/usb.c
index 50173b96f712..80c42b20adda 100644
--- a/drivers/staging/greybus/usb.c
+++ b/drivers/staging/greybus/usb.c
@@ -226,8 +226,8 @@ static void gb_usb_connection_exit(struct gb_connection *connection)
 static struct gb_protocol usb_protocol = {
 	.name			= "usb",
 	.id			= GREYBUS_PROTOCOL_USB,
-	.major			= 0,
-	.minor			= 1,
+	.major			= GB_USB_VERSION_MAJOR,
+	.minor			= GB_USB_VERSION_MINOR,
 	.connection_init	= gb_usb_connection_init,
 	.connection_exit	= gb_usb_connection_exit,
 	.request_recv		= NULL,	/* FIXME we have requests!!! */

commit a96493560cd16095fd00a936bfa9de8614bab842
Author: Johan Hovold <johan@hovoldconsulting.com>
Date:   Thu Jul 30 20:30:41 2015 +0200

    greybus: usb: disable protocol driver
    
    The USB bridged-PHY protocol driver currently depends on changes to USB
    core that are not yet upstream.
    
    Disable for now.
    
    Signed-off-by: Johan Hovold <johan@hovoldconsulting.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/usb.c b/drivers/staging/greybus/usb.c
index 17a5d7a5a824..50173b96f712 100644
--- a/drivers/staging/greybus/usb.c
+++ b/drivers/staging/greybus/usb.c
@@ -190,6 +190,18 @@ static int gb_usb_connection_init(struct gb_connection *connection)
 
 	hcd->has_tt = 1;
 
+	/*
+	 * FIXME: The USB bridged-PHY protocol driver depends on changes to
+	 *        USB core which are not yet upstream.
+	 *
+	 *        Disable for now.
+	 */
+	if (1) {
+		dev_warn(&connection->dev, "USB protocol disabled\n");
+		retval = -EPROTONOSUPPORT;
+		goto err_put_hcd;
+	}
+
 	retval = usb_add_hcd(hcd, 0, 0);
 	if (retval)
 		goto err_put_hcd;

commit a422ecd28eb03eca86d2445d8d690402e183838b
Author: Johan Hovold <johan@hovoldconsulting.com>
Date:   Thu Jul 30 20:30:40 2015 +0200

    greybus: usb: implement hub_control callback
    
    Implement the hub_control callback.
    
    Signed-off-by: Johan Hovold <johan@hovoldconsulting.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/usb.c b/drivers/staging/greybus/usb.c
index 151e49f8e4ab..17a5d7a5a824 100644
--- a/drivers/staging/greybus/usb.c
+++ b/drivers/staging/greybus/usb.c
@@ -110,21 +110,41 @@ static int hub_status_data(struct usb_hcd *hcd, char *buf)
 static int hub_control(struct usb_hcd *hcd, u16 typeReq, u16 wValue, u16 wIndex,
 		       char *buf, u16 wLength)
 {
-	struct gb_usb_hub_control_request request;
 	struct gb_usb_device *dev = to_gb_usb_device(hcd);
+	struct gb_operation *operation;
+	struct gb_usb_hub_control_request *request;
+	struct gb_usb_hub_control_response *response;
+	size_t response_size;
 	int ret;
 
-	request.typeReq = cpu_to_le16(typeReq);
-	request.wValue = cpu_to_le16(wValue);
-	request.wIndex = cpu_to_le16(wIndex);
-	request.wLength = cpu_to_le16(wLength);
-
-	// FIXME - buf needs to come back in struct gb_usb_hub_control_response
-	// for some types of requests, depending on typeReq.  Do we do this in a
-	// "generic" way, or only ask for a response for the ones we "know" need
-	// a response (a small subset of all valid typeReq, thankfully.)
-	ret = gb_operation_sync(dev->connection, GB_USB_TYPE_HUB_CONTROL,
-				&request, sizeof(request), NULL, 0);
+	/* FIXME: handle unspecified lengths */
+	response_size = sizeof(*response) + wLength;
+
+	operation = gb_operation_create(dev->connection,
+					GB_USB_TYPE_HUB_CONTROL,
+					sizeof(*request),
+					response_size,
+					GFP_KERNEL);
+	if (!operation)
+		return -ENOMEM;
+
+	request = operation->request->payload;
+	request->typeReq = cpu_to_le16(typeReq);
+	request->wValue = cpu_to_le16(wValue);
+	request->wIndex = cpu_to_le16(wIndex);
+	request->wLength = cpu_to_le16(wLength);
+
+	ret = gb_operation_request_send_sync(operation);
+	if (ret)
+		goto out;
+
+	if (wLength) {
+		/* Greybus core has verified response size */
+		response = operation->response->payload;
+		memcpy(buf, response->buf, wLength);
+	}
+out:
+	gb_operation_put(operation);
 
 	return ret;
 }

commit b1e4a1f8519aebfbf99bee8b3839498f6645e2d7
Author: Johan Hovold <johan@hovoldconsulting.com>
Date:   Thu Jul 30 20:30:39 2015 +0200

    greybus: usb: fix hc_driver fields
    
    Fix hc_driver description, product_desc and flags fields.
    
    Signed-off-by: Johan Hovold <johan@hovoldconsulting.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/usb.c b/drivers/staging/greybus/usb.c
index 1ba731e6bfad..151e49f8e4ab 100644
--- a/drivers/staging/greybus/usb.c
+++ b/drivers/staging/greybus/usb.c
@@ -130,11 +130,12 @@ static int hub_control(struct usb_hcd *hcd, u16 typeReq, u16 wValue, u16 wIndex,
 }
 
 static struct hc_driver usb_gb_hc_driver = {
-	.description = "greybus_usb",
-	.product_desc = "GB-Bridge USB Controller", /* TODO: Get this from GPB ?*/
-	.flags = HCD_MEMORY | HCD_USB2, /* FIXME: Get this from GPB */
+	.description = "greybus-hcd",
+	.product_desc = "Greybus USB Host Controller",
 	.hcd_priv_size = sizeof(struct gb_usb_device),
 
+	.flags = HCD_USB2,
+
 	.start = hcd_start,
 	.stop = hcd_stop,
 

commit cc9bd53eb1bf50e265a8f8741a624bf67851f5c0
Author: Johan Hovold <johan@hovoldconsulting.com>
Date:   Thu Jul 30 20:30:38 2015 +0200

    greybus: usb: fix hcd allocation, deregistration and deallocation
    
    Fix allocation, deregistration and deallocation of USB HCD, and update
    the hcd_priv helper functions.
    
    The HCD private data was not allocated correctly, something which would
    lead to a crash when accessed in hcd_start. The HCD was neither
    reregistered or deallocated on connection tear down.
    
    Signed-off-by: Johan Hovold <johan@hovoldconsulting.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/usb.c b/drivers/staging/greybus/usb.c
index 2a146d77ecda..1ba731e6bfad 100644
--- a/drivers/staging/greybus/usb.c
+++ b/drivers/staging/greybus/usb.c
@@ -40,12 +40,19 @@ struct gb_usb_hub_control_response {
 struct gb_usb_device {
 	struct gb_connection *connection;
 
-	struct usb_hcd *hcd;
 	u8 version_major;
 	u8 version_minor;
 };
 
-#define to_gb_usb_device(d) ((struct gb_usb_device*) d->hcd_priv)
+static inline struct gb_usb_device *to_gb_usb_device(struct usb_hcd *hcd)
+{
+	return (struct gb_usb_device *)hcd->hcd_priv;
+}
+
+static inline struct usb_hcd *gb_usb_device_to_hcd(struct gb_usb_device *dev)
+{
+	return container_of((void *)dev, struct usb_hcd, hcd_priv);
+}
 
 /* Define get_version() routine */
 define_get_version(gb_usb_device, USB);
@@ -143,45 +150,44 @@ static int gb_usb_connection_init(struct gb_connection *connection)
 {
 	struct device *dev = &connection->dev;
 	struct gb_usb_device *gb_usb_dev;
+	struct usb_hcd *hcd;
 
 	int retval;
 
-	gb_usb_dev = kzalloc(sizeof(*gb_usb_dev), GFP_KERNEL);
-	if (!gb_usb_dev)
+	hcd = usb_create_hcd(&usb_gb_hc_driver, dev, dev_name(dev));
+	if (!hcd)
 		return -ENOMEM;
 
+	gb_usb_dev = to_gb_usb_device(hcd);
 	gb_usb_dev->connection = connection;
 	connection->private = gb_usb_dev;
 
 	/* Check for compatible protocol version */
 	retval = get_version(gb_usb_dev);
 	if (retval)
-		goto error_create_hcd;
-
-	gb_usb_dev->hcd = usb_create_hcd(&usb_gb_hc_driver, dev, dev_name(dev));
-	if (!gb_usb_dev->hcd) {
-		retval = -ENODEV;
-		goto error_create_hcd;
-	}
+		goto err_put_hcd;
 
-	gb_usb_dev->hcd->has_tt = 1;
-	gb_usb_dev->hcd->hcd_priv[0] = (unsigned long) gb_usb_dev;
+	hcd->has_tt = 1;
 
-	retval = usb_add_hcd(gb_usb_dev->hcd, 0, 0);
+	retval = usb_add_hcd(hcd, 0, 0);
 	if (retval)
-		goto error_add_hcd;
+		goto err_put_hcd;
 
 	return 0;
-error_add_hcd:
-	usb_put_hcd(gb_usb_dev->hcd);
-error_create_hcd:
-	kfree(gb_usb_dev);
+
+err_put_hcd:
+	usb_put_hcd(hcd);
+
 	return retval;
 }
 
 static void gb_usb_connection_exit(struct gb_connection *connection)
 {
-	// FIXME - tear everything down!
+	struct gb_usb_device *gb_usb_dev = connection->private;
+	struct usb_hcd *hcd = gb_usb_device_to_hcd(gb_usb_dev);
+
+	usb_remove_hcd(hcd);
+	usb_put_hcd(hcd);
 }
 
 static struct gb_protocol usb_protocol = {

commit 583804f7137737e07e69eaed2904cf043f226a83
Author: Johan Hovold <johan@hovoldconsulting.com>
Date:   Thu Jul 30 20:30:37 2015 +0200

    greybus: usb: renumber operation types
    
    Renumber the current operation types.
    
    NOTE: Protocol change.
    
    Signed-off-by: Johan Hovold <johan@hovoldconsulting.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/usb.c b/drivers/staging/greybus/usb.c
index 04c8783eb061..2a146d77ecda 100644
--- a/drivers/staging/greybus/usb.c
+++ b/drivers/staging/greybus/usb.c
@@ -22,9 +22,9 @@
 /* Greybus USB request types */
 #define GB_USB_TYPE_INVALID		0x00
 #define GB_USB_TYPE_PROTOCOL_VERSION	0x01
-#define GB_USB_TYPE_HCD_STOP		0x02
-#define GB_USB_TYPE_HCD_START		0x03
-#define GB_USB_TYPE_HUB_CONTROL		0x07
+#define GB_USB_TYPE_HCD_START		0x02
+#define GB_USB_TYPE_HCD_STOP		0x03
+#define GB_USB_TYPE_HUB_CONTROL		0x04
 
 struct gb_usb_hub_control_request {
 	__le16 typeReq;

commit 3a6b5aeec771205d35f28616a610d9ed5d2c49b2
Author: Johan Hovold <johan@hovoldconsulting.com>
Date:   Thu Jul 30 20:30:36 2015 +0200

    greybus: usb: clean up driver
    
    Remove unused, broken or unneeded code and constructs.
    
    Signed-off-by: Johan Hovold <johan@hovoldconsulting.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/usb.c b/drivers/staging/greybus/usb.c
index e49fffdca53b..04c8783eb061 100644
--- a/drivers/staging/greybus/usb.c
+++ b/drivers/staging/greybus/usb.c
@@ -24,32 +24,7 @@
 #define GB_USB_TYPE_PROTOCOL_VERSION	0x01
 #define GB_USB_TYPE_HCD_STOP		0x02
 #define GB_USB_TYPE_HCD_START		0x03
-#define GB_USB_TYPE_URB_ENQUEUE		0x04
-#define GB_USB_TYPE_URB_DEQUEUE		0x05
-#define GB_USB_TYPE_ENDPOINT_DISABLE	0x06
 #define GB_USB_TYPE_HUB_CONTROL		0x07
-#define GB_USB_TYPE_GET_FRAME_NUMBER	0x08
-#define GB_USB_TYPE_HUB_STATUS_DATA	0x09
-
-struct gb_usb_urb_enqueue_request {
-	__le32 pipe;
-	__le32 transfer_flags;
-	__le32 transfer_buffer_length;
-	__le32 maxpacket;
-	__le32 interval;
-	__le64 hcpriv_ep;
-	__le32 number_of_packets;
-	u8 setup_packet[8];
-	u8 payload[0];
-};
-
-struct gb_usb_urb_dequeue_request {
-	__le64 hcpriv_ep;
-};
-
-struct gb_usb_endpoint_disable_request {
-	__le64	hcpriv;
-};
 
 struct gb_usb_hub_control_request {
 	__le16 typeReq;
@@ -62,22 +37,6 @@ struct gb_usb_hub_control_response {
 	u8 buf[0];
 };
 
-struct gb_usb_header {
-	__le16	size;
-	__le16	id;
-	__u8	type;
-};
-
-struct gb_usb_hub_status {
-	__le32 status;
-	__le16 buf_size;
-	u8 buf[0];
-};
-
-static struct gb_usb_hub_status *hub_status;	// FIXME!!!
-static DEFINE_SPINLOCK(hub_status_lock);
-static atomic_t frame_number;			// FIXME!!!
-
 struct gb_usb_device {
 	struct gb_connection *connection;
 
@@ -123,83 +82,22 @@ static int hcd_start(struct usb_hcd *hcd)
 
 static int urb_enqueue(struct usb_hcd *hcd, struct urb *urb, gfp_t mem_flags)
 {
-	struct gb_usb_device *dev = to_gb_usb_device(hcd);
-	struct gb_usb_urb_enqueue_request *request;
-	struct gb_operation *operation;
-	int ret;
-
-	operation = gb_operation_create(dev->connection,
-					GB_USB_TYPE_URB_ENQUEUE,
-					sizeof(*request) +
-					urb->transfer_buffer_length, 0,
-					GFP_KERNEL);
-	if (!operation)
-		return -ENODEV;
-
-	request = operation->request->payload;
-	request->pipe = cpu_to_le32(urb->pipe);
-	request->transfer_flags = cpu_to_le32(urb->transfer_flags);
-	request->transfer_buffer_length = cpu_to_le32(urb->transfer_buffer_length);
-	request->interval = cpu_to_le32(urb->interval);
-	request->hcpriv_ep = cpu_to_le64((unsigned long)urb->ep->hcpriv);
-	request->number_of_packets = cpu_to_le32(urb->number_of_packets);
-
-	memcpy(request->setup_packet, urb->setup_packet, 8);
-	memcpy(&request->payload, urb->transfer_buffer,
-	       urb->transfer_buffer_length);
-
-	ret = gb_operation_request_send_sync(operation);
-	gb_operation_destroy(operation);
-
-	return ret;
+	return -ENXIO;
 }
 
 static int urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int status)
 {
-	struct gb_usb_device *dev = to_gb_usb_device(hcd);
-	struct gb_usb_urb_dequeue_request request;
-	int ret;
-
-	urb->ep->hcpriv = NULL;
-	request.hcpriv_ep = cpu_to_le64((unsigned long)urb->hcpriv);
-	ret = gb_operation_sync(dev->connection, GB_USB_TYPE_URB_DEQUEUE,
-				&request, sizeof(request), NULL, 0);
-	urb->hcpriv = NULL;
-	return ret;
-}
-
-static void endpoint_disable(struct usb_hcd *hcd, struct usb_host_endpoint *ep)
-{
-	struct gb_usb_device *dev = to_gb_usb_device(hcd);
-	struct gb_usb_endpoint_disable_request request;
-	int ret;
-
-	request.hcpriv = cpu_to_le64((unsigned long)ep->hcpriv);
-	ret = gb_operation_sync(dev->connection, GB_USB_TYPE_ENDPOINT_DISABLE,
-				&request, sizeof(request), NULL, 0);
-	ep->hcpriv = NULL;
-}
-
-static void endpoint_reset(struct usb_hcd *hcd, struct usb_host_endpoint *ep)
-{
+	return -ENXIO;
 }
 
 static int get_frame_number(struct usb_hcd *hcd)
 {
-	return atomic_read(&frame_number);
+	return 0;
 }
 
 static int hub_status_data(struct usb_hcd *hcd, char *buf)
 {
-	int retval;
-	unsigned long flags;
-
-	spin_lock_irqsave(&hub_status_lock, flags);
-	memcpy(buf, hub_status->buf, le16_to_cpu(hub_status->buf_size));
-	retval = le32_to_cpu(hub_status->status);
-	spin_unlock_irqrestore(&hub_status_lock, flags);
-
-	return retval;
+	return 0;
 }
 
 static int hub_control(struct usb_hcd *hcd, u16 typeReq, u16 wValue, u16 wIndex,
@@ -232,82 +130,15 @@ static struct hc_driver usb_gb_hc_driver = {
 
 	.start = hcd_start,
 	.stop = hcd_stop,
+
 	.urb_enqueue = urb_enqueue,
 	.urb_dequeue = urb_dequeue,
-	.endpoint_disable = endpoint_disable,
-	.endpoint_reset = endpoint_reset,
+
 	.get_frame_number = get_frame_number,
 	.hub_status_data = hub_status_data,
 	.hub_control = hub_control,
 };
 
-#if 0
-static inline void gb_usb_handle_get_frame_number(struct gbuf *gbuf)
-{
-	__le32 frame_num;
-	const size_t packet_size = sizeof(struct gb_usb_header) +
-				   sizeof(frame_num);
-	struct gb_usb_header* hdr = gbuf->transfer_buffer;
-
-	if (le16_to_cpu(hdr->size) != packet_size) {
-		pr_err("%s(): dropping packet too small\n", __func__);
-		return;
-	}
-
-	frame_num = (__le32) ((char*) gbuf->transfer_buffer +
-			      sizeof(struct gb_usb_header));
-	atomic_set(&frame_number, le32_to_cpu(frame_num));
-}
-
-static inline void gb_usb_handle_hubs_status_data(struct gbuf *gbuf)
-{
-	struct gb_usb_hub_status *new_hubstatus, *hubstatus;
-	struct gb_usb_header* hdr = gbuf->transfer_buffer;
-	const size_t min_packet_size = sizeof(struct gb_usb_header) +
-				       sizeof(struct gb_usb_hub_status);
-	unsigned long flags;
-
-	if (le16_to_cpu(hdr->size) < min_packet_size) {
-		pr_err("%s(): dropping packet too small\n", __func__);
-		return;
-	}
-
-	hubstatus = (struct gb_usb_hub_status*) ((char*) gbuf->transfer_buffer
-						+ sizeof(struct gb_usb_header));
-
-	if (le16_to_cpu(hdr->size) != min_packet_size + hubstatus->buf_size) {
-		pr_err("%s(): invalid packet size, dropping packet\n",
-		       __func__);
-		return;
-	}
-
-	new_hubstatus = kmalloc(hubstatus->buf_size, GFP_KERNEL);
-	memcpy(&new_hubstatus, hubstatus, hubstatus->buf_size);
-
-	spin_lock_irqsave(&hub_status_lock, flags);
-	hubstatus = hub_status;
-	hub_status = new_hubstatus;
-	spin_unlock_irqrestore(&hub_status_lock, flags);
-
-	kfree(hubstatus);
-}
-
-static void gb_usb_in_handler(struct gbuf *gbuf)
-{
-	struct gb_usb_header* hdr = gbuf->transfer_buffer;
-
-	switch (hdr->type) {
-		case GB_USB_TYPE_GET_FRAME_NUMBER:
-			gb_usb_handle_get_frame_number(gbuf);
-			break;
-
-		case GB_USB_TYPE_HUB_STATUS_DATA:
-			gb_usb_handle_hubs_status_data(gbuf);
-			break;
-	}
-}
-#endif
-
 static int gb_usb_connection_init(struct gb_connection *connection)
 {
 	struct device *dev = &connection->dev;

commit e420721b47ef5b0d521584d4efc89ff64bd0cd74
Author: Johan Hovold <johan@hovoldconsulting.com>
Date:   Wed Jul 1 12:37:22 2015 +0200

    greybus: operation: allow atomic operation allocations
    
    Add gfp mask argument to gb_operation_create to allow operations to be
    allocated in atomic context.
    
    Signed-off-by: Johan Hovold <johan@hovoldconsulting.com>
    Reviewed-by: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/usb.c b/drivers/staging/greybus/usb.c
index 888f514921b6..e49fffdca53b 100644
--- a/drivers/staging/greybus/usb.c
+++ b/drivers/staging/greybus/usb.c
@@ -131,7 +131,8 @@ static int urb_enqueue(struct usb_hcd *hcd, struct urb *urb, gfp_t mem_flags)
 	operation = gb_operation_create(dev->connection,
 					GB_USB_TYPE_URB_ENQUEUE,
 					sizeof(*request) +
-					urb->transfer_buffer_length, 0);
+					urb->transfer_buffer_length, 0,
+					GFP_KERNEL);
 	if (!operation)
 		return -ENODEV;
 

commit e18822e3d02c8f296fe42e0e8bda7e2e626a4714
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Wed Jul 1 12:13:52 2015 +0530

    greybus: Rename gb_gpbridge_protocol_driver() as gb_builtin_protocol_driver()
    
    This macro is also required by core protocols like control and svc, and
    hence the 'gpbridge' name doesn't fit anymore.
    
    Lets call this macro gb_builtin_protocol_driver().
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Reviewed-by: Alex Elder <elder@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/usb.c b/drivers/staging/greybus/usb.c
index 609b7cc66768..888f514921b6 100644
--- a/drivers/staging/greybus/usb.c
+++ b/drivers/staging/greybus/usb.c
@@ -362,4 +362,4 @@ static struct gb_protocol usb_protocol = {
 	.request_recv		= NULL,	/* FIXME we have requests!!! */
 };
 
-gb_gpbridge_protocol_driver(usb_protocol);
+gb_builtin_protocol_driver(usb_protocol);

commit bdac599c70409bbf48e77971e2b9ecc2a66ef151
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Wed May 20 17:20:10 2015 +0530

    greybus: Use gb_gpbridge_protocol_init()
    
    Start using gb_gpbridge_protocol_init() in gpbridge drivers.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Reviewed-by: Alex Elder <elder@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/usb.c b/drivers/staging/greybus/usb.c
index ea9784171352..609b7cc66768 100644
--- a/drivers/staging/greybus/usb.c
+++ b/drivers/staging/greybus/usb.c
@@ -362,12 +362,4 @@ static struct gb_protocol usb_protocol = {
 	.request_recv		= NULL,	/* FIXME we have requests!!! */
 };
 
-int gb_usb_protocol_init(void)
-{
-	return gb_protocol_register(&usb_protocol);
-}
-
-void gb_usb_protocol_exit(void)
-{
-	gb_protocol_deregister(&usb_protocol);
-}
+gb_gpbridge_protocol_driver(usb_protocol);

commit c020d568f5630d38b72b61a97a4d04f1428b9771
Author: Johan Hovold <johan@hovoldconsulting.com>
Date:   Thu Mar 19 16:46:13 2015 +0100

    greybus: usb: silence compiler warning
    
    This driver is being rewritten, but let's silence a pointer-to-int-cast
    compiler warning meanwhile.
    
    Signed-off-by: Johan Hovold <johan@hovoldconsulting.com>
    Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>

diff --git a/drivers/staging/greybus/usb.c b/drivers/staging/greybus/usb.c
index ff4556fb7dd5..ea9784171352 100644
--- a/drivers/staging/greybus/usb.c
+++ b/drivers/staging/greybus/usb.c
@@ -140,7 +140,7 @@ static int urb_enqueue(struct usb_hcd *hcd, struct urb *urb, gfp_t mem_flags)
 	request->transfer_flags = cpu_to_le32(urb->transfer_flags);
 	request->transfer_buffer_length = cpu_to_le32(urb->transfer_buffer_length);
 	request->interval = cpu_to_le32(urb->interval);
-	request->hcpriv_ep = cpu_to_le64(urb->ep->hcpriv);
+	request->hcpriv_ep = cpu_to_le64((unsigned long)urb->ep->hcpriv);
 	request->number_of_packets = cpu_to_le32(urb->number_of_packets);
 
 	memcpy(request->setup_packet, urb->setup_packet, 8);
@@ -160,7 +160,7 @@ static int urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int status)
 	int ret;
 
 	urb->ep->hcpriv = NULL;
-	request.hcpriv_ep = cpu_to_le64(urb->hcpriv);
+	request.hcpriv_ep = cpu_to_le64((unsigned long)urb->hcpriv);
 	ret = gb_operation_sync(dev->connection, GB_USB_TYPE_URB_DEQUEUE,
 				&request, sizeof(request), NULL, 0);
 	urb->hcpriv = NULL;
@@ -173,7 +173,7 @@ static void endpoint_disable(struct usb_hcd *hcd, struct usb_host_endpoint *ep)
 	struct gb_usb_endpoint_disable_request request;
 	int ret;
 
-	request.hcpriv = cpu_to_le64(ep->hcpriv);
+	request.hcpriv = cpu_to_le64((unsigned long)ep->hcpriv);
 	ret = gb_operation_sync(dev->connection, GB_USB_TYPE_ENDPOINT_DISABLE,
 				&request, sizeof(request), NULL, 0);
 	ep->hcpriv = NULL;

commit 89210f64bae6bd6bba90d9e08d1b88b4ba103f59
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Wed Jan 21 18:12:37 2015 +0530

    greybus: remove unused version-response structs
    
    These aren't used anymore and so can be removed.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Reviewed-by: Alex Elder <elder@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>

diff --git a/drivers/staging/greybus/usb.c b/drivers/staging/greybus/usb.c
index c66d7681d4b3..ff4556fb7dd5 100644
--- a/drivers/staging/greybus/usb.c
+++ b/drivers/staging/greybus/usb.c
@@ -31,11 +31,6 @@
 #define GB_USB_TYPE_GET_FRAME_NUMBER	0x08
 #define GB_USB_TYPE_HUB_STATUS_DATA	0x09
 
-struct gb_usb_proto_version_response {
-	__u8	major;
-	__u8	minor;
-};
-
 struct gb_usb_urb_enqueue_request {
 	__le32 pipe;
 	__le32 transfer_flags;

commit 36e79dec96f652110ae2b06bfcf9e67e1b770787
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Wed Jan 21 18:12:36 2015 +0530

    greybus: create get_version() routines with the help of a macro
    
    This gets rid of lots of duplication of code.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Reviewed-by: Alex Elder <elder@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>

diff --git a/drivers/staging/greybus/usb.c b/drivers/staging/greybus/usb.c
index 010ef9ee831f..c66d7681d4b3 100644
--- a/drivers/staging/greybus/usb.c
+++ b/drivers/staging/greybus/usb.c
@@ -93,26 +93,8 @@ struct gb_usb_device {
 
 #define to_gb_usb_device(d) ((struct gb_usb_device*) d->hcd_priv)
 
-static int get_version(struct gb_usb_device *dev)
-{
-	struct gb_usb_proto_version_response response;
-	int ret;
-
-	ret = gb_operation_sync(dev->connection,
-				GB_USB_TYPE_PROTOCOL_VERSION,
-				NULL, 0, &response, sizeof(response));
-	if (ret)
-		return ret;
-
-	if (response.major > GB_USB_VERSION_MAJOR) {
-		pr_err("unsupported major version (%hhu > %hhu)\n",
-			response.major, GB_USB_VERSION_MAJOR);
-		return -ENOTSUPP;
-	}
-	dev->version_major = response.major;
-	dev->version_minor = response.minor;
-	return 0;
-}
+/* Define get_version() routine */
+define_get_version(gb_usb_device, USB);
 
 static void hcd_stop(struct usb_hcd *hcd)
 {

commit 5357cf323110ee4a3f4a12870618eca28672c7b9
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Wed Jan 21 16:10:40 2015 +0530

    greybus: Remove "-gb" suffix from .c files
    
    Some files are prefixed with "gb-" and some are suffixed with "-gb". The
    rationale behind the first one is that the modules would be named so, i.e.
    gb-*.ko. But there is no reason to keep the "-gb" suffix in the second case.
    
    Remove the unnecessary suffix.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Reviewed-by: Alex Elder <elder@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>

diff --git a/drivers/staging/greybus/usb.c b/drivers/staging/greybus/usb.c
new file mode 100644
index 000000000000..010ef9ee831f
--- /dev/null
+++ b/drivers/staging/greybus/usb.c
@@ -0,0 +1,396 @@
+/*
+ * USB host driver for the Greybus "generic" USB module.
+ *
+ * Copyright 2014 Google Inc.
+ * Copyright 2014 Linaro Ltd.
+ *
+ * Released under the GPLv2 only.
+ *
+ */
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/usb.h>
+#include <linux/usb/hcd.h>
+
+#include "greybus.h"
+
+/* Version of the Greybus USB protocol we support */
+#define GB_USB_VERSION_MAJOR		0x00
+#define GB_USB_VERSION_MINOR		0x01
+
+/* Greybus USB request types */
+#define GB_USB_TYPE_INVALID		0x00
+#define GB_USB_TYPE_PROTOCOL_VERSION	0x01
+#define GB_USB_TYPE_HCD_STOP		0x02
+#define GB_USB_TYPE_HCD_START		0x03
+#define GB_USB_TYPE_URB_ENQUEUE		0x04
+#define GB_USB_TYPE_URB_DEQUEUE		0x05
+#define GB_USB_TYPE_ENDPOINT_DISABLE	0x06
+#define GB_USB_TYPE_HUB_CONTROL		0x07
+#define GB_USB_TYPE_GET_FRAME_NUMBER	0x08
+#define GB_USB_TYPE_HUB_STATUS_DATA	0x09
+
+struct gb_usb_proto_version_response {
+	__u8	major;
+	__u8	minor;
+};
+
+struct gb_usb_urb_enqueue_request {
+	__le32 pipe;
+	__le32 transfer_flags;
+	__le32 transfer_buffer_length;
+	__le32 maxpacket;
+	__le32 interval;
+	__le64 hcpriv_ep;
+	__le32 number_of_packets;
+	u8 setup_packet[8];
+	u8 payload[0];
+};
+
+struct gb_usb_urb_dequeue_request {
+	__le64 hcpriv_ep;
+};
+
+struct gb_usb_endpoint_disable_request {
+	__le64	hcpriv;
+};
+
+struct gb_usb_hub_control_request {
+	__le16 typeReq;
+	__le16 wValue;
+	__le16 wIndex;
+	__le16 wLength;
+};
+
+struct gb_usb_hub_control_response {
+	u8 buf[0];
+};
+
+struct gb_usb_header {
+	__le16	size;
+	__le16	id;
+	__u8	type;
+};
+
+struct gb_usb_hub_status {
+	__le32 status;
+	__le16 buf_size;
+	u8 buf[0];
+};
+
+static struct gb_usb_hub_status *hub_status;	// FIXME!!!
+static DEFINE_SPINLOCK(hub_status_lock);
+static atomic_t frame_number;			// FIXME!!!
+
+struct gb_usb_device {
+	struct gb_connection *connection;
+
+	struct usb_hcd *hcd;
+	u8 version_major;
+	u8 version_minor;
+};
+
+#define to_gb_usb_device(d) ((struct gb_usb_device*) d->hcd_priv)
+
+static int get_version(struct gb_usb_device *dev)
+{
+	struct gb_usb_proto_version_response response;
+	int ret;
+
+	ret = gb_operation_sync(dev->connection,
+				GB_USB_TYPE_PROTOCOL_VERSION,
+				NULL, 0, &response, sizeof(response));
+	if (ret)
+		return ret;
+
+	if (response.major > GB_USB_VERSION_MAJOR) {
+		pr_err("unsupported major version (%hhu > %hhu)\n",
+			response.major, GB_USB_VERSION_MAJOR);
+		return -ENOTSUPP;
+	}
+	dev->version_major = response.major;
+	dev->version_minor = response.minor;
+	return 0;
+}
+
+static void hcd_stop(struct usb_hcd *hcd)
+{
+	struct gb_usb_device *dev = to_gb_usb_device(hcd);
+	int ret;
+
+	ret = gb_operation_sync(dev->connection, GB_USB_TYPE_HCD_STOP,
+				NULL, 0, NULL, 0);
+	if (ret)
+		dev_err(&dev->connection->dev, "HCD stop failed '%d'\n", ret);
+}
+
+static int hcd_start(struct usb_hcd *hcd)
+{
+	struct usb_bus *bus = hcd_to_bus(hcd);
+	struct gb_usb_device *dev = to_gb_usb_device(hcd);
+	int ret;
+
+	ret = gb_operation_sync(dev->connection, GB_USB_TYPE_HCD_START,
+				NULL, 0, NULL, 0);
+	if (ret) {
+		dev_err(&dev->connection->dev, "HCD start failed '%d'\n", ret);
+		return ret;
+	}
+
+	hcd->state = HC_STATE_RUNNING;
+	if (bus->root_hub)
+		usb_hcd_resume_root_hub(hcd);
+	return 0;
+}
+
+static int urb_enqueue(struct usb_hcd *hcd, struct urb *urb, gfp_t mem_flags)
+{
+	struct gb_usb_device *dev = to_gb_usb_device(hcd);
+	struct gb_usb_urb_enqueue_request *request;
+	struct gb_operation *operation;
+	int ret;
+
+	operation = gb_operation_create(dev->connection,
+					GB_USB_TYPE_URB_ENQUEUE,
+					sizeof(*request) +
+					urb->transfer_buffer_length, 0);
+	if (!operation)
+		return -ENODEV;
+
+	request = operation->request->payload;
+	request->pipe = cpu_to_le32(urb->pipe);
+	request->transfer_flags = cpu_to_le32(urb->transfer_flags);
+	request->transfer_buffer_length = cpu_to_le32(urb->transfer_buffer_length);
+	request->interval = cpu_to_le32(urb->interval);
+	request->hcpriv_ep = cpu_to_le64(urb->ep->hcpriv);
+	request->number_of_packets = cpu_to_le32(urb->number_of_packets);
+
+	memcpy(request->setup_packet, urb->setup_packet, 8);
+	memcpy(&request->payload, urb->transfer_buffer,
+	       urb->transfer_buffer_length);
+
+	ret = gb_operation_request_send_sync(operation);
+	gb_operation_destroy(operation);
+
+	return ret;
+}
+
+static int urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int status)
+{
+	struct gb_usb_device *dev = to_gb_usb_device(hcd);
+	struct gb_usb_urb_dequeue_request request;
+	int ret;
+
+	urb->ep->hcpriv = NULL;
+	request.hcpriv_ep = cpu_to_le64(urb->hcpriv);
+	ret = gb_operation_sync(dev->connection, GB_USB_TYPE_URB_DEQUEUE,
+				&request, sizeof(request), NULL, 0);
+	urb->hcpriv = NULL;
+	return ret;
+}
+
+static void endpoint_disable(struct usb_hcd *hcd, struct usb_host_endpoint *ep)
+{
+	struct gb_usb_device *dev = to_gb_usb_device(hcd);
+	struct gb_usb_endpoint_disable_request request;
+	int ret;
+
+	request.hcpriv = cpu_to_le64(ep->hcpriv);
+	ret = gb_operation_sync(dev->connection, GB_USB_TYPE_ENDPOINT_DISABLE,
+				&request, sizeof(request), NULL, 0);
+	ep->hcpriv = NULL;
+}
+
+static void endpoint_reset(struct usb_hcd *hcd, struct usb_host_endpoint *ep)
+{
+}
+
+static int get_frame_number(struct usb_hcd *hcd)
+{
+	return atomic_read(&frame_number);
+}
+
+static int hub_status_data(struct usb_hcd *hcd, char *buf)
+{
+	int retval;
+	unsigned long flags;
+
+	spin_lock_irqsave(&hub_status_lock, flags);
+	memcpy(buf, hub_status->buf, le16_to_cpu(hub_status->buf_size));
+	retval = le32_to_cpu(hub_status->status);
+	spin_unlock_irqrestore(&hub_status_lock, flags);
+
+	return retval;
+}
+
+static int hub_control(struct usb_hcd *hcd, u16 typeReq, u16 wValue, u16 wIndex,
+		       char *buf, u16 wLength)
+{
+	struct gb_usb_hub_control_request request;
+	struct gb_usb_device *dev = to_gb_usb_device(hcd);
+	int ret;
+
+	request.typeReq = cpu_to_le16(typeReq);
+	request.wValue = cpu_to_le16(wValue);
+	request.wIndex = cpu_to_le16(wIndex);
+	request.wLength = cpu_to_le16(wLength);
+
+	// FIXME - buf needs to come back in struct gb_usb_hub_control_response
+	// for some types of requests, depending on typeReq.  Do we do this in a
+	// "generic" way, or only ask for a response for the ones we "know" need
+	// a response (a small subset of all valid typeReq, thankfully.)
+	ret = gb_operation_sync(dev->connection, GB_USB_TYPE_HUB_CONTROL,
+				&request, sizeof(request), NULL, 0);
+
+	return ret;
+}
+
+static struct hc_driver usb_gb_hc_driver = {
+	.description = "greybus_usb",
+	.product_desc = "GB-Bridge USB Controller", /* TODO: Get this from GPB ?*/
+	.flags = HCD_MEMORY | HCD_USB2, /* FIXME: Get this from GPB */
+	.hcd_priv_size = sizeof(struct gb_usb_device),
+
+	.start = hcd_start,
+	.stop = hcd_stop,
+	.urb_enqueue = urb_enqueue,
+	.urb_dequeue = urb_dequeue,
+	.endpoint_disable = endpoint_disable,
+	.endpoint_reset = endpoint_reset,
+	.get_frame_number = get_frame_number,
+	.hub_status_data = hub_status_data,
+	.hub_control = hub_control,
+};
+
+#if 0
+static inline void gb_usb_handle_get_frame_number(struct gbuf *gbuf)
+{
+	__le32 frame_num;
+	const size_t packet_size = sizeof(struct gb_usb_header) +
+				   sizeof(frame_num);
+	struct gb_usb_header* hdr = gbuf->transfer_buffer;
+
+	if (le16_to_cpu(hdr->size) != packet_size) {
+		pr_err("%s(): dropping packet too small\n", __func__);
+		return;
+	}
+
+	frame_num = (__le32) ((char*) gbuf->transfer_buffer +
+			      sizeof(struct gb_usb_header));
+	atomic_set(&frame_number, le32_to_cpu(frame_num));
+}
+
+static inline void gb_usb_handle_hubs_status_data(struct gbuf *gbuf)
+{
+	struct gb_usb_hub_status *new_hubstatus, *hubstatus;
+	struct gb_usb_header* hdr = gbuf->transfer_buffer;
+	const size_t min_packet_size = sizeof(struct gb_usb_header) +
+				       sizeof(struct gb_usb_hub_status);
+	unsigned long flags;
+
+	if (le16_to_cpu(hdr->size) < min_packet_size) {
+		pr_err("%s(): dropping packet too small\n", __func__);
+		return;
+	}
+
+	hubstatus = (struct gb_usb_hub_status*) ((char*) gbuf->transfer_buffer
+						+ sizeof(struct gb_usb_header));
+
+	if (le16_to_cpu(hdr->size) != min_packet_size + hubstatus->buf_size) {
+		pr_err("%s(): invalid packet size, dropping packet\n",
+		       __func__);
+		return;
+	}
+
+	new_hubstatus = kmalloc(hubstatus->buf_size, GFP_KERNEL);
+	memcpy(&new_hubstatus, hubstatus, hubstatus->buf_size);
+
+	spin_lock_irqsave(&hub_status_lock, flags);
+	hubstatus = hub_status;
+	hub_status = new_hubstatus;
+	spin_unlock_irqrestore(&hub_status_lock, flags);
+
+	kfree(hubstatus);
+}
+
+static void gb_usb_in_handler(struct gbuf *gbuf)
+{
+	struct gb_usb_header* hdr = gbuf->transfer_buffer;
+
+	switch (hdr->type) {
+		case GB_USB_TYPE_GET_FRAME_NUMBER:
+			gb_usb_handle_get_frame_number(gbuf);
+			break;
+
+		case GB_USB_TYPE_HUB_STATUS_DATA:
+			gb_usb_handle_hubs_status_data(gbuf);
+			break;
+	}
+}
+#endif
+
+static int gb_usb_connection_init(struct gb_connection *connection)
+{
+	struct device *dev = &connection->dev;
+	struct gb_usb_device *gb_usb_dev;
+
+	int retval;
+
+	gb_usb_dev = kzalloc(sizeof(*gb_usb_dev), GFP_KERNEL);
+	if (!gb_usb_dev)
+		return -ENOMEM;
+
+	gb_usb_dev->connection = connection;
+	connection->private = gb_usb_dev;
+
+	/* Check for compatible protocol version */
+	retval = get_version(gb_usb_dev);
+	if (retval)
+		goto error_create_hcd;
+
+	gb_usb_dev->hcd = usb_create_hcd(&usb_gb_hc_driver, dev, dev_name(dev));
+	if (!gb_usb_dev->hcd) {
+		retval = -ENODEV;
+		goto error_create_hcd;
+	}
+
+	gb_usb_dev->hcd->has_tt = 1;
+	gb_usb_dev->hcd->hcd_priv[0] = (unsigned long) gb_usb_dev;
+
+	retval = usb_add_hcd(gb_usb_dev->hcd, 0, 0);
+	if (retval)
+		goto error_add_hcd;
+
+	return 0;
+error_add_hcd:
+	usb_put_hcd(gb_usb_dev->hcd);
+error_create_hcd:
+	kfree(gb_usb_dev);
+	return retval;
+}
+
+static void gb_usb_connection_exit(struct gb_connection *connection)
+{
+	// FIXME - tear everything down!
+}
+
+static struct gb_protocol usb_protocol = {
+	.name			= "usb",
+	.id			= GREYBUS_PROTOCOL_USB,
+	.major			= 0,
+	.minor			= 1,
+	.connection_init	= gb_usb_connection_init,
+	.connection_exit	= gb_usb_connection_exit,
+	.request_recv		= NULL,	/* FIXME we have requests!!! */
+};
+
+int gb_usb_protocol_init(void)
+{
+	return gb_protocol_register(&usb_protocol);
+}
+
+void gb_usb_protocol_exit(void)
+{
+	gb_protocol_deregister(&usb_protocol);
+}
