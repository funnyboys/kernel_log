commit ec0ad868173da8a75121f9dc116a5d5478ff614d
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Sun Aug 25 07:54:27 2019 +0200

    staging: greybus: move core include files to include/linux/greybus/
    
    With the goal of moving the core of the greybus code out of staging, the
    include files need to be moved to include/linux/greybus.h and
    include/linux/greybus/
    
    Cc: Vaibhav Hiremath <hvaibhav.linux@gmail.com>
    Cc: Johan Hovold <johan@kernel.org>
    Cc: Vaibhav Agarwal <vaibhav.sr@gmail.com>
    Cc: Rui Miguel Silva <rmfrfs@gmail.com>
    Cc: David Lin <dtwlin@gmail.com>
    Cc: "Bryan O'Donoghue" <pure.logic@nexus-software.ie>
    Cc: greybus-dev@lists.linaro.org
    Cc: devel@driverdev.osuosl.org
    Acked-by: Mark Greer <mgreer@animalcreek.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Acked-by: Alex Elder <elder@kernel.org>
    Link: https://lore.kernel.org/r/20190825055429.18547-8-gregkh@linuxfoundation.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/fw-core.c b/drivers/staging/greybus/fw-core.c
index 388866d92f5b..57bebf24636b 100644
--- a/drivers/staging/greybus/fw-core.c
+++ b/drivers/staging/greybus/fw-core.c
@@ -8,8 +8,8 @@
 #define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
 
 #include <linux/firmware.h>
+#include <linux/greybus.h>
 #include "firmware.h"
-#include "greybus.h"
 #include "spilib.h"
 
 struct gb_fw_core {

commit 863dbc52e7f0e5acd7b4883f3933543a81c474c7
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Nov 7 14:58:42 2017 +0100

    staging: greybus: Remove redundant license text
    
    Now that the SPDX tag is in all greybus files, that identifies the
    license in a specific and legally-defined manner.  So the extra GPL text
    wording can be removed as it is no longer needed at all.
    
    This is done on a quest to remove the 700+ different ways that files in
    the kernel describe the GPL license text.  And there's unneeded stuff
    like the address (sometimes incorrect) for the FSF which is never
    needed.
    
    No copyright headers or other non-license-description text was removed.
    
    Cc: Vaibhav Hiremath <hvaibhav.linux@gmail.com>
    Reviewed-by: Alex Elder <elder@linaro.org>
    Acked-by: Vaibhav Agarwal <vaibhav.sr@gmail.com>
    Acked-by: David Lin <dtwlin@gmail.com>
    Acked-by: Johan Hovold <johan@kernel.org>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Acked-by: Mark Greer <mgreer@animalcreek.com>
    Acked-by: Rui Miguel Silva <rmfrfs@gmail.com>
    Acked-by: "Bryan O'Donoghue" <pure.logic@nexus-software.ie>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/fw-core.c b/drivers/staging/greybus/fw-core.c
index d9d337ba2073..388866d92f5b 100644
--- a/drivers/staging/greybus/fw-core.c
+++ b/drivers/staging/greybus/fw-core.c
@@ -4,8 +4,6 @@
  *
  * Copyright 2016 Google Inc.
  * Copyright 2016 Linaro Ltd.
- *
- * Released under the GPLv2 only.
  */
 #define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
 

commit eb50fd3a22c770f36be275295b782f3ea52e3215
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Nov 7 14:58:41 2017 +0100

    staging: greybus: add SPDX identifiers to all greybus driver files
    
    It's good to have SPDX identifiers in all files to make it easier to
    audit the kernel tree for correct licenses.
    
    Update the drivers/staging/greybus files files with the correct SPDX
    license identifier based on the license text in the file itself.  The
    SPDX identifier is a legally binding shorthand, which can be used
    instead of the full boiler plate text.
    
    This work is based on a script and data from Thomas Gleixner, Philippe
    Ombredanne, and Kate Stewart.
    
    Cc: Vaibhav Hiremath <hvaibhav.linux@gmail.com>
    Cc: "Bryan O'Donoghue" <pure.logic@nexus-software.ie>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: Philippe Ombredanne <pombredanne@nexb.com>
    Acked-by: Vaibhav Agarwal <vaibhav.sr@gmail.com>
    Acked-by: David Lin <dtwlin@gmail.com>
    Reviewed-by: Alex Elder <elder@linaro.org>
    Acked-by: Johan Hovold <johan@kernel.org>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Acked-by: Mark Greer <mgreer@animalcreek.com>
    Acked-by: Rui Miguel Silva <rmfrfs@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/fw-core.c b/drivers/staging/greybus/fw-core.c
index 454a98957ba5..d9d337ba2073 100644
--- a/drivers/staging/greybus/fw-core.c
+++ b/drivers/staging/greybus/fw-core.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * Greybus Firmware Core Bundle Driver.
  *

commit 148e0b8f48a83008596876befe1d9aed256c8ea1
Author: Greg Kroah-Hartman <gregkh@google.com>
Date:   Thu Sep 8 16:06:27 2016 +0200

    staging: greybus: spi: remove KERNEL_VERSION checks
    
    No need to support older kernel versions in the Greybus SPI and spilib
    driver, so remove the checks as needed, we can now rely on all of the
    correct SPI core apis being present.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/fw-core.c b/drivers/staging/greybus/fw-core.c
index a7e4a8c24d22..454a98957ba5 100644
--- a/drivers/staging/greybus/fw-core.c
+++ b/drivers/staging/greybus/fw-core.c
@@ -20,26 +20,7 @@ struct gb_fw_core {
 	struct gb_connection	*cap_connection;
 };
 
-#ifndef SPI_CORE_SUPPORT_PM
-static int fw_spi_prepare_transfer_hardware(struct device *dev)
-{
-	return gb_pm_runtime_get_sync(to_gb_bundle(dev));
-}
-
-static void fw_spi_unprepare_transfer_hardware(struct device *dev)
-{
-	gb_pm_runtime_put_autosuspend(to_gb_bundle(dev));
-}
-
-static struct spilib_ops __spilib_ops = {
-	.prepare_transfer_hardware = fw_spi_prepare_transfer_hardware,
-	.unprepare_transfer_hardware = fw_spi_unprepare_transfer_hardware,
-};
-
-static struct spilib_ops *spilib_ops = &__spilib_ops;
-#else
-static struct spilib_ops *spilib_ops = NULL;
-#endif
+static struct spilib_ops *spilib_ops;
 
 struct gb_connection *to_fw_mgmt_connection(struct device *dev)
 {

commit 0c543f9bb2dfa4239a601bff70e66020c2daec59
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Tue Jul 26 13:41:04 2016 -0700

    greybus: interface: Add quirk for no PM for S2 Loader
    
    S2 Loader doesn't support runtime PM operations currently and we will
    fail to suspend/resume the bundle for firmware management protocols.
    
    Once that happens, the bundle and its connections will be pretty much
    useless as we would have tried to disable/enable all connections during
    such an operation and the S2 loader doesn't expect the connections to go
    away during normal operation (except in the case of mode-switch).
    
    This patch defines a new quirk GB_INTERFACE_QUIRK_NO_PM and uses a new
    interface init status value (GB_INIT_S2_LOADER_INITIALIZED) which will
    be advertised by S2 Loader now in the init status.
    
    After detecting the currently running stage as S2 Loader, the kernel
    wouldn't attempt suspending or resuming the bundle.
    
    Reviewed-by: David Lin <dtwlin@google.com>
    Reviewed-by: Johan Hovold <johan@hovoldconsulting.com>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/fw-core.c b/drivers/staging/greybus/fw-core.c
index 56296db0b509..a7e4a8c24d22 100644
--- a/drivers/staging/greybus/fw-core.c
+++ b/drivers/staging/greybus/fw-core.c
@@ -228,7 +228,9 @@ static int gb_fw_core_probe(struct gb_bundle *bundle,
 
 	greybus_set_drvdata(bundle, fw_core);
 
-	gb_pm_runtime_put_autosuspend(bundle);
+	/* FIXME: Remove this after S2 Loader gets runtime PM support */
+	if (!(bundle->intf->quirks & GB_INTERFACE_QUIRK_NO_PM))
+		gb_pm_runtime_put_autosuspend(bundle);
 
 	return 0;
 
@@ -251,9 +253,12 @@ static void gb_fw_core_disconnect(struct gb_bundle *bundle)
 	struct gb_fw_core *fw_core = greybus_get_drvdata(bundle);
 	int ret;
 
-	ret = gb_pm_runtime_get_sync(bundle);
-	if (ret)
-		gb_pm_runtime_get_noresume(bundle);
+	/* FIXME: Remove this after S2 Loader gets runtime PM support */
+	if (!(bundle->intf->quirks & GB_INTERFACE_QUIRK_NO_PM)) {
+		ret = gb_pm_runtime_get_sync(bundle);
+		if (ret)
+			gb_pm_runtime_get_noresume(bundle);
+	}
 
 	gb_fw_mgmt_connection_exit(fw_core->mgmt_connection);
 	gb_cap_connection_exit(fw_core->cap_connection);

commit c57fbb404af28eda44d0590ede8812b889a89b8c
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Tue Jul 26 13:41:02 2016 -0700

    greybus: firmware: Add runtime PM support
    
    This patch implements runtime PM support for firmware management bundle.
    This guarantees that the bundle will be active, while the AP or the
    Module is trying to exchange any operations over any of the CPorts.
    
    - Firmware Management CPort:
    
      Runtime PM get/put calls are placed around the ioctl calls, which are
      all implemented as blocking ioctls.
    
    - Component Authentication CPort:
    
      Runtime PM get/put calls are placed around the ioctl calls, which are
      all implemented as blocking ioctls.
    
    - SPI:
    
      Uses the interface provided by spilib.c and runtime PM get/put are
      called around connection usage.
    
    - firmware-download:
    
      This is the most tricky one. All operations on this CPort are
      initiated from the Module and not from the AP. And the AP needs to do
      runtime_pm_get() before any request is received over this CPort.
    
      The module doesn't send any request over this connection, unless the
      AP has requested the module over firmware management CPort to download
      a firmware package over firmware download CPort.
    
      And so the runtime PM get/put calls around the ioctls in
      fw-management.c are sufficient to handle the firmware management CPort
      as well.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/fw-core.c b/drivers/staging/greybus/fw-core.c
index 19f92fb0331b..56296db0b509 100644
--- a/drivers/staging/greybus/fw-core.c
+++ b/drivers/staging/greybus/fw-core.c
@@ -20,6 +20,27 @@ struct gb_fw_core {
 	struct gb_connection	*cap_connection;
 };
 
+#ifndef SPI_CORE_SUPPORT_PM
+static int fw_spi_prepare_transfer_hardware(struct device *dev)
+{
+	return gb_pm_runtime_get_sync(to_gb_bundle(dev));
+}
+
+static void fw_spi_unprepare_transfer_hardware(struct device *dev)
+{
+	gb_pm_runtime_put_autosuspend(to_gb_bundle(dev));
+}
+
+static struct spilib_ops __spilib_ops = {
+	.prepare_transfer_hardware = fw_spi_prepare_transfer_hardware,
+	.unprepare_transfer_hardware = fw_spi_unprepare_transfer_hardware,
+};
+
+static struct spilib_ops *spilib_ops = &__spilib_ops;
+#else
+static struct spilib_ops *spilib_ops = NULL;
+#endif
+
 struct gb_connection *to_fw_mgmt_connection(struct device *dev)
 {
 	struct gb_fw_core *fw_core = dev_get_drvdata(dev);
@@ -38,7 +59,8 @@ static int gb_fw_spi_connection_init(struct gb_connection *connection)
 	if (ret)
 		return ret;
 
-	ret = gb_spilib_master_init(connection, &connection->bundle->dev, NULL);
+	ret = gb_spilib_master_init(connection, &connection->bundle->dev,
+				    spilib_ops);
 	if (ret) {
 		gb_connection_disable(connection);
 		return ret;
@@ -206,6 +228,8 @@ static int gb_fw_core_probe(struct gb_bundle *bundle,
 
 	greybus_set_drvdata(bundle, fw_core);
 
+	gb_pm_runtime_put_autosuspend(bundle);
+
 	return 0;
 
 err_exit_connections:
@@ -225,6 +249,11 @@ static int gb_fw_core_probe(struct gb_bundle *bundle,
 static void gb_fw_core_disconnect(struct gb_bundle *bundle)
 {
 	struct gb_fw_core *fw_core = greybus_get_drvdata(bundle);
+	int ret;
+
+	ret = gb_pm_runtime_get_sync(bundle);
+	if (ret)
+		gb_pm_runtime_get_noresume(bundle);
 
 	gb_fw_mgmt_connection_exit(fw_core->mgmt_connection);
 	gb_cap_connection_exit(fw_core->cap_connection);

commit 92bcaddea3197e477bb37439805fcb5a2f9942d7
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Thu Jul 21 14:45:06 2016 -0700

    greybus: spilib: make spilib independent of gbphy
    
    spilib is used by multiple users currently (spi.c and fw-core.c) but
    commit aa52b62a0556 broke that hierarchy and introduced gbphy dependent
    code in spilib.
    
    This may have unreliable consequences as we are doing following
    operation unconditionally now:
    
            gbphy_dev = to_gbphy_dev(spi->parent);
            gbphy_runtime_get_sync(gbphy_dev);
    
    which may not go well when the parent is of type &bundle->dev
    (fw-core.c).
    
    This patch introduces spilib_ops and lets the users of the core register
    them. This shall have no functional change for the spi.c usecase and
    shall fix the unreliable results for the fw-core.c usecase.
    
    Tested by writing to mtd0 dev and verifying (with print messages) that
    the below routines are getting called for a gpbridge-test module.
    
    Fixes: aa52b62a0556 ("spi: Add runtime_pm support")
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/fw-core.c b/drivers/staging/greybus/fw-core.c
index 963973242be0..19f92fb0331b 100644
--- a/drivers/staging/greybus/fw-core.c
+++ b/drivers/staging/greybus/fw-core.c
@@ -38,7 +38,7 @@ static int gb_fw_spi_connection_init(struct gb_connection *connection)
 	if (ret)
 		return ret;
 
-	ret = gb_spilib_master_init(connection, &connection->bundle->dev);
+	ret = gb_spilib_master_init(connection, &connection->bundle->dev, NULL);
 	if (ret) {
 		gb_connection_disable(connection);
 		return ret;

commit e3eda54d0b5fef23957cc4f586f4b44fd223c881
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Thu Jun 30 10:54:00 2016 -0500

    greybus: Add Component Authentication Protocol support
    
    This patch adds Component Authentication Protocol support in greybus.
    The purpose of the CAP protocol is to authenticate the Module hardware,
    and it can only be used when it is present as part of the
    firmware-management bundle, on a separate CPort.
    
    Compile tested only.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Reviewed-by: Jun Li <li_jun@projectara.com>
    Tested-by: Jun Li <li_jun@projectara.com>
    Signed-off-by: Alex Elder <elder@linaro.org>

diff --git a/drivers/staging/greybus/fw-core.c b/drivers/staging/greybus/fw-core.c
index 33941efe13ea..963973242be0 100644
--- a/drivers/staging/greybus/fw-core.c
+++ b/drivers/staging/greybus/fw-core.c
@@ -17,6 +17,7 @@ struct gb_fw_core {
 	struct gb_connection	*download_connection;
 	struct gb_connection	*mgmt_connection;
 	struct gb_connection	*spi_connection;
+	struct gb_connection	*cap_connection;
 };
 
 struct gb_connection *to_fw_mgmt_connection(struct device *dev)
@@ -134,6 +135,24 @@ static int gb_fw_core_probe(struct gb_bundle *bundle,
 				fw_core->spi_connection = connection;
 			}
 
+			break;
+		case GREYBUS_PROTOCOL_AUTHENTICATION:
+			/* Disallow multiple CAP CPorts */
+			if (fw_core->cap_connection) {
+				dev_err(&bundle->dev, "multiple Authentication CPorts found\n");
+				ret = -EINVAL;
+				goto err_destroy_connections;
+			}
+
+			connection = gb_connection_create(bundle, cport_id,
+							  NULL);
+			if (IS_ERR(connection)) {
+				dev_err(&bundle->dev, "failed to create Authentication connection (%ld)\n",
+					PTR_ERR(connection));
+			} else {
+				fw_core->cap_connection = connection;
+			}
+
 			break;
 		default:
 			dev_err(&bundle->dev, "invalid protocol id (0x%02x)\n",
@@ -168,6 +187,15 @@ static int gb_fw_core_probe(struct gb_bundle *bundle,
 		fw_core->spi_connection = NULL;
 	}
 
+	ret = gb_cap_connection_init(fw_core->cap_connection);
+	if (ret) {
+		/* We may still be able to work with the Interface */
+		dev_err(&bundle->dev, "failed to initialize CAP connection, disable it (%d)\n",
+			ret);
+		gb_connection_destroy(fw_core->cap_connection);
+		fw_core->cap_connection = NULL;
+	}
+
 	ret = gb_fw_mgmt_connection_init(fw_core->mgmt_connection);
 	if (ret) {
 		/* We may still be able to work with the Interface */
@@ -181,10 +209,12 @@ static int gb_fw_core_probe(struct gb_bundle *bundle,
 	return 0;
 
 err_exit_connections:
+	gb_cap_connection_exit(fw_core->cap_connection);
 	gb_fw_spi_connection_exit(fw_core->spi_connection);
 	gb_fw_download_connection_exit(fw_core->download_connection);
 err_destroy_connections:
 	gb_connection_destroy(fw_core->mgmt_connection);
+	gb_connection_destroy(fw_core->cap_connection);
 	gb_connection_destroy(fw_core->spi_connection);
 	gb_connection_destroy(fw_core->download_connection);
 	kfree(fw_core);
@@ -197,10 +227,12 @@ static void gb_fw_core_disconnect(struct gb_bundle *bundle)
 	struct gb_fw_core *fw_core = greybus_get_drvdata(bundle);
 
 	gb_fw_mgmt_connection_exit(fw_core->mgmt_connection);
+	gb_cap_connection_exit(fw_core->cap_connection);
 	gb_fw_spi_connection_exit(fw_core->spi_connection);
 	gb_fw_download_connection_exit(fw_core->download_connection);
 
 	gb_connection_destroy(fw_core->mgmt_connection);
+	gb_connection_destroy(fw_core->cap_connection);
 	gb_connection_destroy(fw_core->spi_connection);
 	gb_connection_destroy(fw_core->download_connection);
 
@@ -229,19 +261,32 @@ static int fw_core_init(void)
 		return ret;
 	}
 
-	ret = greybus_register(&gb_fw_core_driver);
+	ret = cap_init();
 	if (ret) {
-		fw_mgmt_exit();
-		return ret;
+		pr_err("Failed to initialize component authentication core (%d)\n",
+		       ret);
+		goto fw_mgmt_exit;
 	}
 
+	ret = greybus_register(&gb_fw_core_driver);
+	if (ret)
+		goto cap_exit;
+
 	return 0;
+
+cap_exit:
+	cap_exit();
+fw_mgmt_exit:
+	fw_mgmt_exit();
+
+	return ret;
 }
 module_init(fw_core_init);
 
 static void __exit fw_core_exit(void)
 {
 	greybus_deregister(&gb_fw_core_driver);
+	cap_exit();
 	fw_mgmt_exit();
 }
 module_exit(fw_core_exit);

commit 825f79ae7620fa98586c4d2504030eca96d55c59
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Thu May 19 18:27:25 2016 +0530

    greybus: fw-core: destroy connections on error
    
    In one of the error cases we aren't destroying the connections created
    earlier. Fix it.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/fw-core.c b/drivers/staging/greybus/fw-core.c
index 90d32227a490..33941efe13ea 100644
--- a/drivers/staging/greybus/fw-core.c
+++ b/drivers/staging/greybus/fw-core.c
@@ -139,7 +139,7 @@ static int gb_fw_core_probe(struct gb_bundle *bundle,
 			dev_err(&bundle->dev, "invalid protocol id (0x%02x)\n",
 				protocol_id);
 			ret = -EINVAL;
-			goto err_free_fw_core;
+			goto err_destroy_connections;
 		}
 	}
 
@@ -187,7 +187,6 @@ static int gb_fw_core_probe(struct gb_bundle *bundle,
 	gb_connection_destroy(fw_core->mgmt_connection);
 	gb_connection_destroy(fw_core->spi_connection);
 	gb_connection_destroy(fw_core->download_connection);
-err_free_fw_core:
 	kfree(fw_core);
 
 	return ret;

commit e2386c9327ab30288f995fc23fb97a3f21b08787
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Sat May 14 23:42:24 2016 +0530

    greybus: firmware: Add SPI protocol support
    
    This patch adds SPI Protocol support to firmware core, which allows the
    AP to access an SPI flash memory present with an Interface.
    
    Tested by using the API from fw-management driver and compiling it.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/fw-core.c b/drivers/staging/greybus/fw-core.c
index 0a456c547c52..90d32227a490 100644
--- a/drivers/staging/greybus/fw-core.c
+++ b/drivers/staging/greybus/fw-core.c
@@ -11,10 +11,12 @@
 #include <linux/firmware.h>
 #include "firmware.h"
 #include "greybus.h"
+#include "spilib.h"
 
 struct gb_fw_core {
 	struct gb_connection	*download_connection;
 	struct gb_connection	*mgmt_connection;
+	struct gb_connection	*spi_connection;
 };
 
 struct gb_connection *to_fw_mgmt_connection(struct device *dev)
@@ -24,6 +26,35 @@ struct gb_connection *to_fw_mgmt_connection(struct device *dev)
 	return fw_core->mgmt_connection;
 }
 
+static int gb_fw_spi_connection_init(struct gb_connection *connection)
+{
+	int ret;
+
+	if (!connection)
+		return 0;
+
+	ret = gb_connection_enable(connection);
+	if (ret)
+		return ret;
+
+	ret = gb_spilib_master_init(connection, &connection->bundle->dev);
+	if (ret) {
+		gb_connection_disable(connection);
+		return ret;
+	}
+
+	return 0;
+}
+
+static void gb_fw_spi_connection_exit(struct gb_connection *connection)
+{
+	if (!connection)
+		return;
+
+	gb_spilib_master_exit(connection);
+	gb_connection_disable(connection);
+}
+
 static int gb_fw_core_probe(struct gb_bundle *bundle,
 			    const struct greybus_bundle_id *id)
 {
@@ -84,6 +115,25 @@ static int gb_fw_core_probe(struct gb_bundle *bundle,
 				fw_core->download_connection = connection;
 			}
 
+			break;
+		case GREYBUS_PROTOCOL_SPI:
+			/* Disallow multiple SPI CPorts */
+			if (fw_core->spi_connection) {
+				dev_err(&bundle->dev,
+					"multiple SPI CPorts found\n");
+				ret = -EINVAL;
+				goto err_destroy_connections;
+			}
+
+			connection = gb_connection_create(bundle, cport_id,
+							  NULL);
+			if (IS_ERR(connection)) {
+				dev_err(&bundle->dev, "failed to create SPI connection (%ld)\n",
+					PTR_ERR(connection));
+			} else {
+				fw_core->spi_connection = connection;
+			}
+
 			break;
 		default:
 			dev_err(&bundle->dev, "invalid protocol id (0x%02x)\n",
@@ -109,6 +159,15 @@ static int gb_fw_core_probe(struct gb_bundle *bundle,
 		fw_core->download_connection = NULL;
 	}
 
+	ret = gb_fw_spi_connection_init(fw_core->spi_connection);
+	if (ret) {
+		/* We may still be able to work with the Interface */
+		dev_err(&bundle->dev, "failed to initialize SPI connection, disable it (%d)\n",
+			ret);
+		gb_connection_destroy(fw_core->spi_connection);
+		fw_core->spi_connection = NULL;
+	}
+
 	ret = gb_fw_mgmt_connection_init(fw_core->mgmt_connection);
 	if (ret) {
 		/* We may still be able to work with the Interface */
@@ -122,9 +181,11 @@ static int gb_fw_core_probe(struct gb_bundle *bundle,
 	return 0;
 
 err_exit_connections:
+	gb_fw_spi_connection_exit(fw_core->spi_connection);
 	gb_fw_download_connection_exit(fw_core->download_connection);
 err_destroy_connections:
 	gb_connection_destroy(fw_core->mgmt_connection);
+	gb_connection_destroy(fw_core->spi_connection);
 	gb_connection_destroy(fw_core->download_connection);
 err_free_fw_core:
 	kfree(fw_core);
@@ -137,9 +198,11 @@ static void gb_fw_core_disconnect(struct gb_bundle *bundle)
 	struct gb_fw_core *fw_core = greybus_get_drvdata(bundle);
 
 	gb_fw_mgmt_connection_exit(fw_core->mgmt_connection);
+	gb_fw_spi_connection_exit(fw_core->spi_connection);
 	gb_fw_download_connection_exit(fw_core->download_connection);
 
 	gb_connection_destroy(fw_core->mgmt_connection);
+	gb_connection_destroy(fw_core->spi_connection);
 	gb_connection_destroy(fw_core->download_connection);
 
 	kfree(fw_core);

commit 013e665372733fafd08599f0fc58ff5f450e4694
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Sat May 14 23:42:21 2016 +0530

    greybus: fw-management: Add firmware-management protocol driver
    
    This patch adds Firmware Management Protocol support to firmware core,
    which allows the AP to manage firmware on an Interface.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Reviewed-by: Jun Li <li_jun@projectara.com>
    Tested-by: Karthik Ravi Shankar <karthikrs@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/fw-core.c b/drivers/staging/greybus/fw-core.c
index a6865276855a..0a456c547c52 100644
--- a/drivers/staging/greybus/fw-core.c
+++ b/drivers/staging/greybus/fw-core.c
@@ -17,6 +17,13 @@ struct gb_fw_core {
 	struct gb_connection	*mgmt_connection;
 };
 
+struct gb_connection *to_fw_mgmt_connection(struct device *dev)
+{
+	struct gb_fw_core *fw_core = dev_get_drvdata(dev);
+
+	return fw_core->mgmt_connection;
+}
+
 static int gb_fw_core_probe(struct gb_bundle *bundle,
 			    const struct greybus_bundle_id *id)
 {
@@ -48,7 +55,7 @@ static int gb_fw_core_probe(struct gb_bundle *bundle,
 			}
 
 			connection = gb_connection_create(bundle, cport_id,
-							  NULL);
+						gb_fw_mgmt_request_handler);
 			if (IS_ERR(connection)) {
 				ret = PTR_ERR(connection);
 				dev_err(&bundle->dev,
@@ -102,13 +109,23 @@ static int gb_fw_core_probe(struct gb_bundle *bundle,
 		fw_core->download_connection = NULL;
 	}
 
+	ret = gb_fw_mgmt_connection_init(fw_core->mgmt_connection);
+	if (ret) {
+		/* We may still be able to work with the Interface */
+		dev_err(&bundle->dev, "failed to initialize firmware management connection, disable it (%d)\n",
+			ret);
+		goto err_exit_connections;
+	}
+
 	greybus_set_drvdata(bundle, fw_core);
 
 	return 0;
 
+err_exit_connections:
+	gb_fw_download_connection_exit(fw_core->download_connection);
 err_destroy_connections:
-	gb_connection_destroy(fw_core->download_connection);
 	gb_connection_destroy(fw_core->mgmt_connection);
+	gb_connection_destroy(fw_core->download_connection);
 err_free_fw_core:
 	kfree(fw_core);
 
@@ -119,9 +136,11 @@ static void gb_fw_core_disconnect(struct gb_bundle *bundle)
 {
 	struct gb_fw_core *fw_core = greybus_get_drvdata(bundle);
 
+	gb_fw_mgmt_connection_exit(fw_core->mgmt_connection);
 	gb_fw_download_connection_exit(fw_core->download_connection);
-	gb_connection_destroy(fw_core->download_connection);
+
 	gb_connection_destroy(fw_core->mgmt_connection);
+	gb_connection_destroy(fw_core->download_connection);
 
 	kfree(fw_core);
 }
@@ -140,13 +159,28 @@ static struct greybus_driver gb_fw_core_driver = {
 
 static int fw_core_init(void)
 {
-	return greybus_register(&gb_fw_core_driver);
+	int ret;
+
+	ret = fw_mgmt_init();
+	if (ret) {
+		pr_err("Failed to initialize fw-mgmt core (%d)\n", ret);
+		return ret;
+	}
+
+	ret = greybus_register(&gb_fw_core_driver);
+	if (ret) {
+		fw_mgmt_exit();
+		return ret;
+	}
+
+	return 0;
 }
 module_init(fw_core_init);
 
 static void __exit fw_core_exit(void)
 {
 	greybus_deregister(&gb_fw_core_driver);
+	fw_mgmt_exit();
 }
 module_exit(fw_core_exit);
 

commit cca22207673896262443c72f19b049552d65f88e
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Thu Apr 28 10:06:38 2016 +0530

    greybus: firmware: Add firmware-download protocol driver
    
    This patch adds Firmware Download Protocol support to firmware core,
    which allows an Interface to download a firmware package over Unipro.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Reviewed-by: Jun Li <li_jun@projectara.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/fw-core.c b/drivers/staging/greybus/fw-core.c
index 4720d595cc2b..a6865276855a 100644
--- a/drivers/staging/greybus/fw-core.c
+++ b/drivers/staging/greybus/fw-core.c
@@ -9,9 +9,11 @@
 #define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
 
 #include <linux/firmware.h>
+#include "firmware.h"
 #include "greybus.h"
 
 struct gb_fw_core {
+	struct gb_connection	*download_connection;
 	struct gb_connection	*mgmt_connection;
 };
 
@@ -52,10 +54,29 @@ static int gb_fw_core_probe(struct gb_bundle *bundle,
 				dev_err(&bundle->dev,
 					"failed to create management connection (%d)\n",
 					ret);
-				goto err_free_fw_core;
+				goto err_destroy_connections;
 			}
 
 			fw_core->mgmt_connection = connection;
+			break;
+		case GREYBUS_PROTOCOL_FW_DOWNLOAD:
+			/* Disallow multiple Firmware Download CPorts */
+			if (fw_core->download_connection) {
+				dev_err(&bundle->dev,
+					"multiple download CPorts found\n");
+				ret = -EINVAL;
+				goto err_destroy_connections;
+			}
+
+			connection = gb_connection_create(bundle, cport_id,
+						gb_fw_download_request_handler);
+			if (IS_ERR(connection)) {
+				dev_err(&bundle->dev, "failed to create download connection (%ld)\n",
+					PTR_ERR(connection));
+			} else {
+				fw_core->download_connection = connection;
+			}
+
 			break;
 		default:
 			dev_err(&bundle->dev, "invalid protocol id (0x%02x)\n",
@@ -69,7 +90,16 @@ static int gb_fw_core_probe(struct gb_bundle *bundle,
 	if (!fw_core->mgmt_connection) {
 		dev_err(&bundle->dev, "missing management connection\n");
 		ret = -ENODEV;
-		goto err_free_fw_core;
+		goto err_destroy_connections;
+	}
+
+	ret = gb_fw_download_connection_init(fw_core->download_connection);
+	if (ret) {
+		/* We may still be able to work with the Interface */
+		dev_err(&bundle->dev, "failed to initialize firmware download connection, disable it (%d)\n",
+			ret);
+		gb_connection_destroy(fw_core->download_connection);
+		fw_core->download_connection = NULL;
 	}
 
 	greybus_set_drvdata(bundle, fw_core);
@@ -77,6 +107,7 @@ static int gb_fw_core_probe(struct gb_bundle *bundle,
 	return 0;
 
 err_destroy_connections:
+	gb_connection_destroy(fw_core->download_connection);
 	gb_connection_destroy(fw_core->mgmt_connection);
 err_free_fw_core:
 	kfree(fw_core);
@@ -88,6 +119,8 @@ static void gb_fw_core_disconnect(struct gb_bundle *bundle)
 {
 	struct gb_fw_core *fw_core = greybus_get_drvdata(bundle);
 
+	gb_fw_download_connection_exit(fw_core->download_connection);
+	gb_connection_destroy(fw_core->download_connection);
 	gb_connection_destroy(fw_core->mgmt_connection);
 
 	kfree(fw_core);

commit 9e04fb7b1627ad55b63c4e0927f696ecb1a2563a
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Tue Apr 26 10:20:49 2016 +0530

    greybus: firmware: Add firmware management bundle driver
    
    All firmware packages on the Modules or Interfaces are now managed by a
    special Firmware Management Protocol. The Interface Manifest shall
    at least contain the Firmware Management Bundle and a Firmware
    Management Protocol CPort within it.
    
    The bundle may contain additional CPorts based on the extra
    functionality required to manage firmware packages.
    
    For example, this is how the Firmware Management Bundle of the Interface
    Manifest may look like:
    
            ; Firmware Management Bundle (Bundle 1):
            [bundle-descriptor 1]
            class = 0x16
    
            ; (Mandatory) Firmware Management Protocol on CPort 1
            [cport-descriptor 1]
            bundle = 1
            protocol = 0x18
    
            ; (Optional) Firmware Download Protocol on CPort 2
            [cport-descriptor 2]
            bundle = 1
            protocol = 0x17
    
            ; (Optional) SPI protocol on CPort 3
            [cport-descriptor 3]
            bundle = 1
            protocol = 0x0b
    
            ; (Optional) Component Authentication Protocol (CAP) on CPort 4
            [cport-descriptor 4]
            bundle = 1
            protocol = 0xXX //TBD
    
    This patch adds the basic firmware-management bundle driver, which just
    creates a firmware-management connection. Support for individual
    protocols will be added separately.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/fw-core.c b/drivers/staging/greybus/fw-core.c
new file mode 100644
index 000000000000..4720d595cc2b
--- /dev/null
+++ b/drivers/staging/greybus/fw-core.c
@@ -0,0 +1,123 @@
+/*
+ * Greybus Firmware Core Bundle Driver.
+ *
+ * Copyright 2016 Google Inc.
+ * Copyright 2016 Linaro Ltd.
+ *
+ * Released under the GPLv2 only.
+ */
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+
+#include <linux/firmware.h>
+#include "greybus.h"
+
+struct gb_fw_core {
+	struct gb_connection	*mgmt_connection;
+};
+
+static int gb_fw_core_probe(struct gb_bundle *bundle,
+			    const struct greybus_bundle_id *id)
+{
+	struct greybus_descriptor_cport *cport_desc;
+	struct gb_connection *connection;
+	struct gb_fw_core *fw_core;
+	int ret, i;
+	u16 cport_id;
+	u8 protocol_id;
+
+	fw_core = kzalloc(sizeof(*fw_core), GFP_KERNEL);
+	if (!fw_core)
+		return -ENOMEM;
+
+	/* Parse CPorts and create connections */
+	for (i = 0; i < bundle->num_cports; i++) {
+		cport_desc = &bundle->cport_desc[i];
+		cport_id = le16_to_cpu(cport_desc->id);
+		protocol_id = cport_desc->protocol_id;
+
+		switch (protocol_id) {
+		case GREYBUS_PROTOCOL_FW_MANAGEMENT:
+			/* Disallow multiple Firmware Management CPorts */
+			if (fw_core->mgmt_connection) {
+				dev_err(&bundle->dev,
+					"multiple management CPorts found\n");
+				ret = -EINVAL;
+				goto err_destroy_connections;
+			}
+
+			connection = gb_connection_create(bundle, cport_id,
+							  NULL);
+			if (IS_ERR(connection)) {
+				ret = PTR_ERR(connection);
+				dev_err(&bundle->dev,
+					"failed to create management connection (%d)\n",
+					ret);
+				goto err_free_fw_core;
+			}
+
+			fw_core->mgmt_connection = connection;
+			break;
+		default:
+			dev_err(&bundle->dev, "invalid protocol id (0x%02x)\n",
+				protocol_id);
+			ret = -EINVAL;
+			goto err_free_fw_core;
+		}
+	}
+
+	/* Firmware Management connection is mandatory */
+	if (!fw_core->mgmt_connection) {
+		dev_err(&bundle->dev, "missing management connection\n");
+		ret = -ENODEV;
+		goto err_free_fw_core;
+	}
+
+	greybus_set_drvdata(bundle, fw_core);
+
+	return 0;
+
+err_destroy_connections:
+	gb_connection_destroy(fw_core->mgmt_connection);
+err_free_fw_core:
+	kfree(fw_core);
+
+	return ret;
+}
+
+static void gb_fw_core_disconnect(struct gb_bundle *bundle)
+{
+	struct gb_fw_core *fw_core = greybus_get_drvdata(bundle);
+
+	gb_connection_destroy(fw_core->mgmt_connection);
+
+	kfree(fw_core);
+}
+
+static const struct greybus_bundle_id gb_fw_core_id_table[] = {
+	{ GREYBUS_DEVICE_CLASS(GREYBUS_CLASS_FW_MANAGEMENT) },
+	{ }
+};
+
+static struct greybus_driver gb_fw_core_driver = {
+	.name		= "gb-firmware",
+	.probe		= gb_fw_core_probe,
+	.disconnect	= gb_fw_core_disconnect,
+	.id_table	= gb_fw_core_id_table,
+};
+
+static int fw_core_init(void)
+{
+	return greybus_register(&gb_fw_core_driver);
+}
+module_init(fw_core_init);
+
+static void __exit fw_core_exit(void)
+{
+	greybus_deregister(&gb_fw_core_driver);
+}
+module_exit(fw_core_exit);
+
+MODULE_ALIAS("greybus:firmware");
+MODULE_AUTHOR("Viresh Kumar <viresh.kumar@linaro.org>");
+MODULE_DESCRIPTION("Greybus Firmware Bundle Driver");
+MODULE_LICENSE("GPL v2");
