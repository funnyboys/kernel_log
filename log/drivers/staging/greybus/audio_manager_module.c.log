commit 8478c35a858c75bf2b00917009ba1b46c1b9b7b4
Author: Cristian Sicilia <sicilia.cristian@gmail.com>
Date:   Sun Nov 25 17:58:15 2018 +0100

    staging: greybus: Parenthesis alignment
    
    Some parameters are aligned with parentheses.
    Some parentheses was opened at end of line.
    
    Signed-off-by: Cristian Sicilia <sicilia.cristian@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/audio_manager_module.c b/drivers/staging/greybus/audio_manager_module.c
index 52342e832e3b..2bfd804183c4 100644
--- a/drivers/staging/greybus/audio_manager_module.c
+++ b/drivers/staging/greybus/audio_manager_module.c
@@ -25,8 +25,8 @@ struct gb_audio_manager_module_attribute {
 			 const char *buf, size_t count);
 };
 
-static ssize_t gb_audio_module_attr_show(
-	struct kobject *kobj, struct attribute *attr, char *buf)
+static ssize_t gb_audio_module_attr_show(struct kobject *kobj,
+					 struct attribute *attr, char *buf)
 {
 	struct gb_audio_manager_module_attribute *attribute;
 	struct gb_audio_manager_module *module;

commit 863dbc52e7f0e5acd7b4883f3933543a81c474c7
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Nov 7 14:58:42 2017 +0100

    staging: greybus: Remove redundant license text
    
    Now that the SPDX tag is in all greybus files, that identifies the
    license in a specific and legally-defined manner.  So the extra GPL text
    wording can be removed as it is no longer needed at all.
    
    This is done on a quest to remove the 700+ different ways that files in
    the kernel describe the GPL license text.  And there's unneeded stuff
    like the address (sometimes incorrect) for the FSF which is never
    needed.
    
    No copyright headers or other non-license-description text was removed.
    
    Cc: Vaibhav Hiremath <hvaibhav.linux@gmail.com>
    Reviewed-by: Alex Elder <elder@linaro.org>
    Acked-by: Vaibhav Agarwal <vaibhav.sr@gmail.com>
    Acked-by: David Lin <dtwlin@gmail.com>
    Acked-by: Johan Hovold <johan@kernel.org>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Acked-by: Mark Greer <mgreer@animalcreek.com>
    Acked-by: Rui Miguel Silva <rmfrfs@gmail.com>
    Acked-by: "Bryan O'Donoghue" <pure.logic@nexus-software.ie>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/audio_manager_module.c b/drivers/staging/greybus/audio_manager_module.c
index 9fbfe394e11c..52342e832e3b 100644
--- a/drivers/staging/greybus/audio_manager_module.c
+++ b/drivers/staging/greybus/audio_manager_module.c
@@ -3,8 +3,6 @@
  * Greybus operations
  *
  * Copyright 2015-2016 Google Inc.
- *
- * Released under the GPLv2 only.
  */
 
 #include <linux/slab.h>

commit eb50fd3a22c770f36be275295b782f3ea52e3215
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Nov 7 14:58:41 2017 +0100

    staging: greybus: add SPDX identifiers to all greybus driver files
    
    It's good to have SPDX identifiers in all files to make it easier to
    audit the kernel tree for correct licenses.
    
    Update the drivers/staging/greybus files files with the correct SPDX
    license identifier based on the license text in the file itself.  The
    SPDX identifier is a legally binding shorthand, which can be used
    instead of the full boiler plate text.
    
    This work is based on a script and data from Thomas Gleixner, Philippe
    Ombredanne, and Kate Stewart.
    
    Cc: Vaibhav Hiremath <hvaibhav.linux@gmail.com>
    Cc: "Bryan O'Donoghue" <pure.logic@nexus-software.ie>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: Philippe Ombredanne <pombredanne@nexb.com>
    Acked-by: Vaibhav Agarwal <vaibhav.sr@gmail.com>
    Acked-by: David Lin <dtwlin@gmail.com>
    Reviewed-by: Alex Elder <elder@linaro.org>
    Acked-by: Johan Hovold <johan@kernel.org>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Acked-by: Mark Greer <mgreer@animalcreek.com>
    Acked-by: Rui Miguel Silva <rmfrfs@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/audio_manager_module.c b/drivers/staging/greybus/audio_manager_module.c
index adc16977452d..9fbfe394e11c 100644
--- a/drivers/staging/greybus/audio_manager_module.c
+++ b/drivers/staging/greybus/audio_manager_module.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * Greybus operations
  *

commit 49b9137a6002a06f7e44e59ece9b34fd1e4fca4c
Author: Pankaj Bharadiya <pankaj.bharadiya@gmail.com>
Date:   Mon Oct 17 14:42:36 2016 +0530

    staging: greybus: audio: remove redundant slot field
    
    gb_audio_manager_module_descriptor's intf_id field maintains the
    information about the interface on which module is connected hence
    having an extra slot field is redundant.
    
    Thus remove the slot field and its associated code.
    
    Signed-off-by: Pankaj Bharadiya <pankaj.bharadiya@gmail.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Reviewed-by: Vaibhav Agarwal <vaibhav.sr@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/audio_manager_module.c b/drivers/staging/greybus/audio_manager_module.c
index 2bf40a90368d..adc16977452d 100644
--- a/drivers/staging/greybus/audio_manager_module.c
+++ b/drivers/staging/greybus/audio_manager_module.c
@@ -81,16 +81,6 @@ static ssize_t gb_audio_module_name_show(
 static struct gb_audio_manager_module_attribute gb_audio_module_name_attribute =
 	__ATTR(name, 0664, gb_audio_module_name_show, NULL);
 
-static ssize_t gb_audio_module_slot_show(
-	struct gb_audio_manager_module *module,
-	struct gb_audio_manager_module_attribute *attr, char *buf)
-{
-	return sprintf(buf, "%d", module->desc.slot);
-}
-
-static struct gb_audio_manager_module_attribute gb_audio_module_slot_attribute =
-	__ATTR(slot, 0664, gb_audio_module_slot_show, NULL);
-
 static ssize_t gb_audio_module_vid_show(
 	struct gb_audio_manager_module *module,
 	struct gb_audio_manager_module_attribute *attr, char *buf)
@@ -146,7 +136,6 @@ static struct gb_audio_manager_module_attribute
 
 static struct attribute *gb_audio_module_default_attrs[] = {
 	&gb_audio_module_name_attribute.attr,
-	&gb_audio_module_slot_attribute.attr,
 	&gb_audio_module_vid_attribute.attr,
 	&gb_audio_module_pid_attribute.attr,
 	&gb_audio_module_intf_id_attribute.attr,
@@ -164,7 +153,6 @@ static struct kobj_type gb_audio_module_type = {
 static void send_add_uevent(struct gb_audio_manager_module *module)
 {
 	char name_string[128];
-	char slot_string[64];
 	char vid_string[64];
 	char pid_string[64];
 	char intf_id_string[64];
@@ -173,7 +161,6 @@ static void send_add_uevent(struct gb_audio_manager_module *module)
 
 	char *envp[] = {
 		name_string,
-		slot_string,
 		vid_string,
 		pid_string,
 		intf_id_string,
@@ -183,7 +170,6 @@ static void send_add_uevent(struct gb_audio_manager_module *module)
 	};
 
 	snprintf(name_string, 128, "NAME=%s", module->desc.name);
-	snprintf(slot_string, 64, "SLOT=%d", module->desc.slot);
 	snprintf(vid_string, 64, "VID=%d", module->desc.vid);
 	snprintf(pid_string, 64, "PID=%d", module->desc.pid);
 	snprintf(intf_id_string, 64, "INTF_ID=%d", module->desc.intf_id);
@@ -246,10 +232,9 @@ int gb_audio_manager_module_create(
 
 void gb_audio_manager_module_dump(struct gb_audio_manager_module *module)
 {
-	pr_info("audio module #%d name=%s slot=%d vid=%d pid=%d intf_id=%d i/p devices=0x%X o/p devices=0x%X\n",
+	pr_info("audio module #%d name=%s vid=%d pid=%d intf_id=%d i/p devices=0x%X o/p devices=0x%X\n",
 		module->id,
 		module->desc.name,
-		module->desc.slot,
 		module->desc.vid,
 		module->desc.pid,
 		module->desc.intf_id,

commit d0af1bd5f6f44971bea2e45acfe07de629734a3e
Author: Pankaj Bharadiya <pankaj.bharadiya@gmail.com>
Date:   Sun Oct 16 15:29:14 2016 +0530

    staging: greybus: audio: Rename cport with intf_id
    
    gb_audio_manager_module_descriptor's cport field is actually used to
    manage and pass interface id to user space.
    
    Thus rename gb_audio_manager_module_descriptor's 'cport' field and
    few other things to avoid confusion.
    
    Signed-off-by: Pankaj Bharadiya <pankaj.bharadiya@gmail.com>
    Reviewed-by: Vaibhav Agarwal <vaibhav.sr@gmail.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/audio_manager_module.c b/drivers/staging/greybus/audio_manager_module.c
index a10e96ad79c1..2bf40a90368d 100644
--- a/drivers/staging/greybus/audio_manager_module.c
+++ b/drivers/staging/greybus/audio_manager_module.c
@@ -111,16 +111,16 @@ static ssize_t gb_audio_module_pid_show(
 static struct gb_audio_manager_module_attribute gb_audio_module_pid_attribute =
 	__ATTR(pid, 0664, gb_audio_module_pid_show, NULL);
 
-static ssize_t gb_audio_module_cport_show(
+static ssize_t gb_audio_module_intf_id_show(
 	struct gb_audio_manager_module *module,
 	struct gb_audio_manager_module_attribute *attr, char *buf)
 {
-	return sprintf(buf, "%d", module->desc.cport);
+	return sprintf(buf, "%d", module->desc.intf_id);
 }
 
 static struct gb_audio_manager_module_attribute
-					gb_audio_module_cport_attribute =
-	__ATTR(cport, 0664, gb_audio_module_cport_show, NULL);
+					gb_audio_module_intf_id_attribute =
+	__ATTR(intf_id, 0664, gb_audio_module_intf_id_show, NULL);
 
 static ssize_t gb_audio_module_ip_devices_show(
 	struct gb_audio_manager_module *module,
@@ -149,7 +149,7 @@ static struct attribute *gb_audio_module_default_attrs[] = {
 	&gb_audio_module_slot_attribute.attr,
 	&gb_audio_module_vid_attribute.attr,
 	&gb_audio_module_pid_attribute.attr,
-	&gb_audio_module_cport_attribute.attr,
+	&gb_audio_module_intf_id_attribute.attr,
 	&gb_audio_module_ip_devices_attribute.attr,
 	&gb_audio_module_op_devices_attribute.attr,
 	NULL,   /* need to NULL terminate the list of attributes */
@@ -167,7 +167,7 @@ static void send_add_uevent(struct gb_audio_manager_module *module)
 	char slot_string[64];
 	char vid_string[64];
 	char pid_string[64];
-	char cport_string[64];
+	char intf_id_string[64];
 	char ip_devices_string[64];
 	char op_devices_string[64];
 
@@ -176,7 +176,7 @@ static void send_add_uevent(struct gb_audio_manager_module *module)
 		slot_string,
 		vid_string,
 		pid_string,
-		cport_string,
+		intf_id_string,
 		ip_devices_string,
 		op_devices_string,
 		NULL
@@ -186,7 +186,7 @@ static void send_add_uevent(struct gb_audio_manager_module *module)
 	snprintf(slot_string, 64, "SLOT=%d", module->desc.slot);
 	snprintf(vid_string, 64, "VID=%d", module->desc.vid);
 	snprintf(pid_string, 64, "PID=%d", module->desc.pid);
-	snprintf(cport_string, 64, "CPORT=%d", module->desc.cport);
+	snprintf(intf_id_string, 64, "INTF_ID=%d", module->desc.intf_id);
 	snprintf(ip_devices_string, 64, "I/P DEVICES=0x%X",
 		 module->desc.ip_devices);
 	snprintf(op_devices_string, 64, "O/P DEVICES=0x%X",
@@ -246,13 +246,13 @@ int gb_audio_manager_module_create(
 
 void gb_audio_manager_module_dump(struct gb_audio_manager_module *module)
 {
-	pr_info("audio module #%d name=%s slot=%d vid=%d pid=%d cport=%d i/p devices=0x%X o/p devices=0x%X\n",
+	pr_info("audio module #%d name=%s slot=%d vid=%d pid=%d intf_id=%d i/p devices=0x%X o/p devices=0x%X\n",
 		module->id,
 		module->desc.name,
 		module->desc.slot,
 		module->desc.vid,
 		module->desc.pid,
-		module->desc.cport,
+		module->desc.intf_id,
 		module->desc.ip_devices,
 		module->desc.op_devices);
 }

commit a9234bfd6cec4420b5bef29d77dce1f9cb0543e2
Author: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
Date:   Wed Mar 30 13:23:55 2016 +0530

    greybus: audio_manager: Split device type into i/p & o/p devices
    
    Currently, single field is used to report device type say SPK,
    MIC, HS, HP, etc. However above HAL expects separate fields for
    input & ouput device types.
    
    Signed-off-by: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
    Reviewed-by: Mark Greer <mgreer@animalcreek.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/audio_manager_module.c b/drivers/staging/greybus/audio_manager_module.c
index e5cffa362671..a10e96ad79c1 100644
--- a/drivers/staging/greybus/audio_manager_module.c
+++ b/drivers/staging/greybus/audio_manager_module.c
@@ -122,16 +122,27 @@ static struct gb_audio_manager_module_attribute
 					gb_audio_module_cport_attribute =
 	__ATTR(cport, 0664, gb_audio_module_cport_show, NULL);
 
-static ssize_t gb_audio_module_devices_show(
+static ssize_t gb_audio_module_ip_devices_show(
 	struct gb_audio_manager_module *module,
 	struct gb_audio_manager_module_attribute *attr, char *buf)
 {
-	return sprintf(buf, "0x%X", module->desc.devices);
+	return sprintf(buf, "0x%X", module->desc.ip_devices);
 }
 
 static struct gb_audio_manager_module_attribute
-					gb_audio_module_devices_attribute =
-	__ATTR(devices, 0664, gb_audio_module_devices_show, NULL);
+					gb_audio_module_ip_devices_attribute =
+	__ATTR(ip_devices, 0664, gb_audio_module_ip_devices_show, NULL);
+
+static ssize_t gb_audio_module_op_devices_show(
+	struct gb_audio_manager_module *module,
+	struct gb_audio_manager_module_attribute *attr, char *buf)
+{
+	return sprintf(buf, "0x%X", module->desc.op_devices);
+}
+
+static struct gb_audio_manager_module_attribute
+					gb_audio_module_op_devices_attribute =
+	__ATTR(op_devices, 0664, gb_audio_module_op_devices_show, NULL);
 
 static struct attribute *gb_audio_module_default_attrs[] = {
 	&gb_audio_module_name_attribute.attr,
@@ -139,7 +150,8 @@ static struct attribute *gb_audio_module_default_attrs[] = {
 	&gb_audio_module_vid_attribute.attr,
 	&gb_audio_module_pid_attribute.attr,
 	&gb_audio_module_cport_attribute.attr,
-	&gb_audio_module_devices_attribute.attr,
+	&gb_audio_module_ip_devices_attribute.attr,
+	&gb_audio_module_op_devices_attribute.attr,
 	NULL,   /* need to NULL terminate the list of attributes */
 };
 
@@ -156,7 +168,8 @@ static void send_add_uevent(struct gb_audio_manager_module *module)
 	char vid_string[64];
 	char pid_string[64];
 	char cport_string[64];
-	char devices_string[64];
+	char ip_devices_string[64];
+	char op_devices_string[64];
 
 	char *envp[] = {
 		name_string,
@@ -164,7 +177,8 @@ static void send_add_uevent(struct gb_audio_manager_module *module)
 		vid_string,
 		pid_string,
 		cport_string,
-		devices_string,
+		ip_devices_string,
+		op_devices_string,
 		NULL
 	};
 
@@ -173,7 +187,10 @@ static void send_add_uevent(struct gb_audio_manager_module *module)
 	snprintf(vid_string, 64, "VID=%d", module->desc.vid);
 	snprintf(pid_string, 64, "PID=%d", module->desc.pid);
 	snprintf(cport_string, 64, "CPORT=%d", module->desc.cport);
-	snprintf(devices_string, 64, "DEVICES=0x%X", module->desc.devices);
+	snprintf(ip_devices_string, 64, "I/P DEVICES=0x%X",
+		 module->desc.ip_devices);
+	snprintf(op_devices_string, 64, "O/P DEVICES=0x%X",
+		 module->desc.op_devices);
 
 	kobject_uevent_env(&module->kobj, KOBJ_ADD, envp);
 }
@@ -229,12 +246,13 @@ int gb_audio_manager_module_create(
 
 void gb_audio_manager_module_dump(struct gb_audio_manager_module *module)
 {
-	pr_info("audio module #%d name=%s slot=%d vid=%d pid=%d cport=%d devices=0x%X\n",
+	pr_info("audio module #%d name=%s slot=%d vid=%d pid=%d cport=%d i/p devices=0x%X o/p devices=0x%X\n",
 		module->id,
 		module->desc.name,
 		module->desc.slot,
 		module->desc.vid,
 		module->desc.pid,
 		module->desc.cport,
-		module->desc.devices);
+		module->desc.ip_devices,
+		module->desc.op_devices);
 }

commit 8db00736d365b75d6af5dfd4a2673a1453fff4b7
Author: Svetlin Ankov <ankov_svetlin@projectara.com>
Date:   Wed Jan 13 14:07:48 2016 -0700

    greybus: audio: Add Audio Manager
    
    This is a simple module that keeps a list of connected GB audio
    modules.
    
    Whenever a device is attached, an appropriate uevent is sent to
    userspace:
    
        UDEV  [4941.803215] add      /kernel/gb_audio_manager/0 (gb_audio_manager)
        ACTION=add
        CPORT=99
        DEVICES=0x10
        DEVPATH=/kernel/gb_audio_manager/0
        NAME=naim
        PID=64
        SEQNUM=1828
        SLOT=2
        SUBSYSTEM=gb_audio_manager
        USEC_INITIALIZED=802416
        VID=128
    
    And whenever removed:
    
        UDEV  [4941.836588] remove   /kernel/gb_audio_manager/0 (gb_audio_manager)
        ACTION=remove
        DEVPATH=/kernel/gb_audio_manager/0
        SEQNUM=1833
        SUBSYSTEM=gb_audio_manager
        USEC_INITIALIZED=835681
    
    The API consists of functions for adding, removing and inspecting
    added device module descriptions (struct gb_audio_module):
    
        int                         gb_audio_manager_add(struct gb_audio_module_descriptor *desc);
        int                         gb_audio_manager_remove(int id);
        int                         gb_audio_manager_remove_all(void);
        struct  gb_audio_module*    gb_audio_manager_get_module(int id);
        void                        gb_audio_manager_put_module(struct gb_audio_module *module);
        int                         gb_audio_manager_dump_module(int id);
        void                        gb_audio_manager_dump_all(void);
    
    Devices can be inspected through sysfs in /sys/kernel/gb_audio_manager/{id}/*
    
    If GB_AUDIO_MANAGER_SYSFS is exported as 'true', managing devices can be done
    via the SYSFS as well. For instance:
    
        echo name=naim slot=2 vid=128 pid=64 cport=99 devices=0x10 > /sys/kernel/gb_audio_manager/add
        echo all > /sys/kernel/gb_audio_manager/dump
        echo 2 > /sys/kernel/gb_audio_manager/dump
        echo 2 > /sys/kernel/gb_audio_manager/remove
    
    Signed-off-by: Svetlin Ankov <ankov_svetlin@projectara.com>
    Signed-off-by: Mark Greer <mgreer@animalcreek.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/audio_manager_module.c b/drivers/staging/greybus/audio_manager_module.c
new file mode 100644
index 000000000000..e5cffa362671
--- /dev/null
+++ b/drivers/staging/greybus/audio_manager_module.c
@@ -0,0 +1,240 @@
+/*
+ * Greybus operations
+ *
+ * Copyright 2015-2016 Google Inc.
+ *
+ * Released under the GPLv2 only.
+ */
+
+#include <linux/slab.h>
+
+#include "audio_manager.h"
+#include "audio_manager_private.h"
+
+#define to_gb_audio_module_attr(x)	\
+		container_of(x, struct gb_audio_manager_module_attribute, attr)
+#define to_gb_audio_module(x)		\
+		container_of(x, struct gb_audio_manager_module, kobj)
+
+struct gb_audio_manager_module_attribute {
+	struct attribute attr;
+	ssize_t (*show)(struct gb_audio_manager_module *module,
+			struct gb_audio_manager_module_attribute *attr,
+			char *buf);
+	ssize_t (*store)(struct gb_audio_manager_module *module,
+			 struct gb_audio_manager_module_attribute *attr,
+			 const char *buf, size_t count);
+};
+
+static ssize_t gb_audio_module_attr_show(
+	struct kobject *kobj, struct attribute *attr, char *buf)
+{
+	struct gb_audio_manager_module_attribute *attribute;
+	struct gb_audio_manager_module *module;
+
+	attribute = to_gb_audio_module_attr(attr);
+	module = to_gb_audio_module(kobj);
+
+	if (!attribute->show)
+		return -EIO;
+
+	return attribute->show(module, attribute, buf);
+}
+
+static ssize_t gb_audio_module_attr_store(struct kobject *kobj,
+					  struct attribute *attr,
+					  const char *buf, size_t len)
+{
+	struct gb_audio_manager_module_attribute *attribute;
+	struct gb_audio_manager_module *module;
+
+	attribute = to_gb_audio_module_attr(attr);
+	module = to_gb_audio_module(kobj);
+
+	if (!attribute->store)
+		return -EIO;
+
+	return attribute->store(module, attribute, buf, len);
+}
+
+static const struct sysfs_ops gb_audio_module_sysfs_ops = {
+	.show = gb_audio_module_attr_show,
+	.store = gb_audio_module_attr_store,
+};
+
+static void gb_audio_module_release(struct kobject *kobj)
+{
+	struct gb_audio_manager_module *module = to_gb_audio_module(kobj);
+
+	pr_info("Destroying audio module #%d\n", module->id);
+	/* TODO -> delete from list */
+	kfree(module);
+}
+
+static ssize_t gb_audio_module_name_show(
+	struct gb_audio_manager_module *module,
+	struct gb_audio_manager_module_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%s", module->desc.name);
+}
+
+static struct gb_audio_manager_module_attribute gb_audio_module_name_attribute =
+	__ATTR(name, 0664, gb_audio_module_name_show, NULL);
+
+static ssize_t gb_audio_module_slot_show(
+	struct gb_audio_manager_module *module,
+	struct gb_audio_manager_module_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d", module->desc.slot);
+}
+
+static struct gb_audio_manager_module_attribute gb_audio_module_slot_attribute =
+	__ATTR(slot, 0664, gb_audio_module_slot_show, NULL);
+
+static ssize_t gb_audio_module_vid_show(
+	struct gb_audio_manager_module *module,
+	struct gb_audio_manager_module_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d", module->desc.vid);
+}
+
+static struct gb_audio_manager_module_attribute gb_audio_module_vid_attribute =
+	__ATTR(vid, 0664, gb_audio_module_vid_show, NULL);
+
+static ssize_t gb_audio_module_pid_show(
+	struct gb_audio_manager_module *module,
+	struct gb_audio_manager_module_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d", module->desc.pid);
+}
+
+static struct gb_audio_manager_module_attribute gb_audio_module_pid_attribute =
+	__ATTR(pid, 0664, gb_audio_module_pid_show, NULL);
+
+static ssize_t gb_audio_module_cport_show(
+	struct gb_audio_manager_module *module,
+	struct gb_audio_manager_module_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d", module->desc.cport);
+}
+
+static struct gb_audio_manager_module_attribute
+					gb_audio_module_cport_attribute =
+	__ATTR(cport, 0664, gb_audio_module_cport_show, NULL);
+
+static ssize_t gb_audio_module_devices_show(
+	struct gb_audio_manager_module *module,
+	struct gb_audio_manager_module_attribute *attr, char *buf)
+{
+	return sprintf(buf, "0x%X", module->desc.devices);
+}
+
+static struct gb_audio_manager_module_attribute
+					gb_audio_module_devices_attribute =
+	__ATTR(devices, 0664, gb_audio_module_devices_show, NULL);
+
+static struct attribute *gb_audio_module_default_attrs[] = {
+	&gb_audio_module_name_attribute.attr,
+	&gb_audio_module_slot_attribute.attr,
+	&gb_audio_module_vid_attribute.attr,
+	&gb_audio_module_pid_attribute.attr,
+	&gb_audio_module_cport_attribute.attr,
+	&gb_audio_module_devices_attribute.attr,
+	NULL,   /* need to NULL terminate the list of attributes */
+};
+
+static struct kobj_type gb_audio_module_type = {
+	.sysfs_ops = &gb_audio_module_sysfs_ops,
+	.release = gb_audio_module_release,
+	.default_attrs = gb_audio_module_default_attrs,
+};
+
+static void send_add_uevent(struct gb_audio_manager_module *module)
+{
+	char name_string[128];
+	char slot_string[64];
+	char vid_string[64];
+	char pid_string[64];
+	char cport_string[64];
+	char devices_string[64];
+
+	char *envp[] = {
+		name_string,
+		slot_string,
+		vid_string,
+		pid_string,
+		cport_string,
+		devices_string,
+		NULL
+	};
+
+	snprintf(name_string, 128, "NAME=%s", module->desc.name);
+	snprintf(slot_string, 64, "SLOT=%d", module->desc.slot);
+	snprintf(vid_string, 64, "VID=%d", module->desc.vid);
+	snprintf(pid_string, 64, "PID=%d", module->desc.pid);
+	snprintf(cport_string, 64, "CPORT=%d", module->desc.cport);
+	snprintf(devices_string, 64, "DEVICES=0x%X", module->desc.devices);
+
+	kobject_uevent_env(&module->kobj, KOBJ_ADD, envp);
+}
+
+int gb_audio_manager_module_create(
+	struct gb_audio_manager_module **module,
+	struct kset *manager_kset,
+	int id, struct gb_audio_manager_module_descriptor *desc)
+{
+	int err;
+	struct gb_audio_manager_module *m;
+
+	m = kzalloc(sizeof(*m), GFP_ATOMIC);
+	if (!m)
+		return -ENOMEM;
+
+	/* Initialize the node */
+	INIT_LIST_HEAD(&m->list);
+
+	/* Set the module id */
+	m->id = id;
+
+	/* Copy the provided descriptor */
+	memcpy(&m->desc, desc, sizeof(*desc));
+
+	/* set the kset */
+	m->kobj.kset = manager_kset;
+
+	/*
+	 * Initialize and add the kobject to the kernel.  All the default files
+	 * will be created here.  As we have already specified a kset for this
+	 * kobject, we don't have to set a parent for the kobject, the kobject
+	 * will be placed beneath that kset automatically.
+	 */
+	err = kobject_init_and_add(&m->kobj, &gb_audio_module_type, NULL, "%d",
+				   id);
+	if (err) {
+		pr_err("failed initializing kobject for audio module #%d\n",
+		       id);
+		kobject_put(&m->kobj);
+		return err;
+	}
+
+	/*
+	 * Notify the object was created
+	 */
+	send_add_uevent(m);
+
+	*module = m;
+	pr_info("Created audio module #%d\n", id);
+	return 0;
+}
+
+void gb_audio_manager_module_dump(struct gb_audio_manager_module *module)
+{
+	pr_info("audio module #%d name=%s slot=%d vid=%d pid=%d cport=%d devices=0x%X\n",
+		module->id,
+		module->desc.name,
+		module->desc.slot,
+		module->desc.vid,
+		module->desc.pid,
+		module->desc.cport,
+		module->desc.devices);
+}
