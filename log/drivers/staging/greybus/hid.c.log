commit c42f736332a43e7cec61f582909036b5addc707a
Author: Dan Jessie <dtjessie@gmail.com>
Date:   Sat Mar 28 18:21:35 2020 -0400

    staging: greybus: hid: remove braces {} around single statement block
    
    This patch fixes the checkpatch.pl warning:
    
    WARNING: braces {} are not necessary for single statement blocks
    
    This is the only instance of the problem noted by
    checkpatch.pl in staging: greybus.
    
    Signed-off-by: Dan Jessie <dtjessie@gmail.com>
    Reviewed-by: Alex Elder <elder@linaro.org>
    Link: https://lore.kernel.org/r/20200328222134.19344-1-dtjessie@gmail.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/hid.c b/drivers/staging/greybus/hid.c
index 04bfd9110502..ed706f39e87a 100644
--- a/drivers/staging/greybus/hid.c
+++ b/drivers/staging/greybus/hid.c
@@ -290,9 +290,8 @@ static int gb_hid_parse(struct hid_device *hid)
 	}
 
 	rdesc = kzalloc(rsize, GFP_KERNEL);
-	if (!rdesc) {
+	if (!rdesc)
 		return -ENOMEM;
-	}
 
 	ret = gb_hid_get_report_desc(ghid, rdesc);
 	if (ret) {

commit ec0ad868173da8a75121f9dc116a5d5478ff614d
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Sun Aug 25 07:54:27 2019 +0200

    staging: greybus: move core include files to include/linux/greybus/
    
    With the goal of moving the core of the greybus code out of staging, the
    include files need to be moved to include/linux/greybus.h and
    include/linux/greybus/
    
    Cc: Vaibhav Hiremath <hvaibhav.linux@gmail.com>
    Cc: Johan Hovold <johan@kernel.org>
    Cc: Vaibhav Agarwal <vaibhav.sr@gmail.com>
    Cc: Rui Miguel Silva <rmfrfs@gmail.com>
    Cc: David Lin <dtwlin@gmail.com>
    Cc: "Bryan O'Donoghue" <pure.logic@nexus-software.ie>
    Cc: greybus-dev@lists.linaro.org
    Cc: devel@driverdev.osuosl.org
    Acked-by: Mark Greer <mgreer@animalcreek.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Acked-by: Alex Elder <elder@kernel.org>
    Link: https://lore.kernel.org/r/20190825055429.18547-8-gregkh@linuxfoundation.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/hid.c b/drivers/staging/greybus/hid.c
index 8ab810bf5716..04bfd9110502 100644
--- a/drivers/staging/greybus/hid.c
+++ b/drivers/staging/greybus/hid.c
@@ -12,8 +12,7 @@
 #include <linux/module.h>
 #include <linux/mutex.h>
 #include <linux/slab.h>
-
-#include "greybus.h"
+#include <linux/greybus.h>
 
 /* Greybus HID device's structure */
 struct gb_hid {

commit 591ad6f1af1b418b1aebf69ae4e2e86b8eb2b0ad
Author: Sanjana Sanikommu <sanjana99reddy99@gmail.com>
Date:   Sun Mar 31 21:34:02 2019 +0530

    staging: greybus: hid: Remove print following unsuccessful kmalloc
    
    Challenge suggested by Coccinelle
    Remove print statement following unsuccessful kmalloc when there
    is not enough memory. Kmalloc and variants normally produce a
    backtrace in such a case. Hence, a print statement is not necessary.
    
    Found using the following Coccinelle semantic patch:
    @@
    identifier i,print;
    constant char [] c;
    @@
    
    i = (\(kmalloc\|devm_kzalloc\|kmalloc_array\|
    devm_ioremap\|usb_alloc_urb\|alloc_netdev\|dev_alloc_skb\|
    kzalloc\|kcalloc\|kmem_cache_alloc\|kmem_cache_zalloc\|
       kmem_cache_alloc_node\|kmalloc_node\|kzalloc_node\)(...));
    (
    if (i == NULL)
    {
    -print(...,c,...);
    ...when any
    }
    |
    if (!i)
    {
    -print(...,c,...);
    ...when any
    }
    )
    
    Signed-off-by: Sanjana Sanikommu <sanjana99reddy99@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/hid.c b/drivers/staging/greybus/hid.c
index 0b72e1b9d325..8ab810bf5716 100644
--- a/drivers/staging/greybus/hid.c
+++ b/drivers/staging/greybus/hid.c
@@ -292,7 +292,6 @@ static int gb_hid_parse(struct hid_device *hid)
 
 	rdesc = kzalloc(rsize, GFP_KERNEL);
 	if (!rdesc) {
-		dbg_hid("couldn't allocate rdesc memory\n");
 		return -ENOMEM;
 	}
 

commit 8478c35a858c75bf2b00917009ba1b46c1b9b7b4
Author: Cristian Sicilia <sicilia.cristian@gmail.com>
Date:   Sun Nov 25 17:58:15 2018 +0100

    staging: greybus: Parenthesis alignment
    
    Some parameters are aligned with parentheses.
    Some parentheses was opened at end of line.
    
    Signed-off-by: Cristian Sicilia <sicilia.cristian@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/hid.c b/drivers/staging/greybus/hid.c
index 04053ff075a6..0b72e1b9d325 100644
--- a/drivers/staging/greybus/hid.c
+++ b/drivers/staging/greybus/hid.c
@@ -49,8 +49,8 @@ static int gb_hid_get_report_desc(struct gb_hid *ghid, char *rdesc)
 		return ret;
 
 	ret = gb_operation_sync(ghid->connection, GB_HID_TYPE_GET_REPORT_DESC,
-				 NULL, 0, rdesc,
-				 le16_to_cpu(ghid->hdesc.wReportDescLength));
+				NULL, 0, rdesc,
+				le16_to_cpu(ghid->hdesc.wReportDescLength));
 
 	gb_pm_runtime_put_autosuspend(ghid->bundle);
 
@@ -86,7 +86,7 @@ static int gb_hid_get_report(struct gb_hid *ghid, u8 report_type, u8 report_id,
 	request.report_id = report_id;
 
 	ret = gb_operation_sync(ghid->connection, GB_HID_TYPE_GET_REPORT,
-				 &request, sizeof(request), buf, len);
+				&request, sizeof(request), buf, len);
 
 	gb_pm_runtime_put_autosuspend(ghid->bundle);
 
@@ -211,11 +211,13 @@ static void gb_hid_init_reports(struct gb_hid *ghid)
 	struct hid_report *report;
 
 	list_for_each_entry(report,
-		&hid->report_enum[HID_INPUT_REPORT].report_list, list)
+			    &hid->report_enum[HID_INPUT_REPORT].report_list,
+			    list)
 		gb_hid_init_report(ghid, report);
 
 	list_for_each_entry(report,
-		&hid->report_enum[HID_FEATURE_REPORT].report_list, list)
+			    &hid->report_enum[HID_FEATURE_REPORT].report_list,
+			    list)
 		gb_hid_init_report(ghid, report);
 }
 
@@ -259,8 +261,8 @@ static int __gb_hid_output_raw_report(struct hid_device *hid, __u8 *buf,
 }
 
 static int gb_hid_raw_request(struct hid_device *hid, unsigned char reportnum,
-			       __u8 *buf, size_t len, unsigned char rtype,
-			       int reqtype)
+			      __u8 *buf, size_t len, unsigned char rtype,
+			      int reqtype)
 {
 	switch (reqtype) {
 	case HID_REQ_GET_REPORT:
@@ -440,7 +442,7 @@ static int gb_hid_probe(struct gb_bundle *bundle,
 		return -ENOMEM;
 
 	connection = gb_connection_create(bundle, le16_to_cpu(cport_desc->id),
-						gb_hid_request_handler);
+					  gb_hid_request_handler);
 	if (IS_ERR(connection)) {
 		ret = PTR_ERR(connection);
 		goto err_free_ghid;

commit 863dbc52e7f0e5acd7b4883f3933543a81c474c7
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Nov 7 14:58:42 2017 +0100

    staging: greybus: Remove redundant license text
    
    Now that the SPDX tag is in all greybus files, that identifies the
    license in a specific and legally-defined manner.  So the extra GPL text
    wording can be removed as it is no longer needed at all.
    
    This is done on a quest to remove the 700+ different ways that files in
    the kernel describe the GPL license text.  And there's unneeded stuff
    like the address (sometimes incorrect) for the FSF which is never
    needed.
    
    No copyright headers or other non-license-description text was removed.
    
    Cc: Vaibhav Hiremath <hvaibhav.linux@gmail.com>
    Reviewed-by: Alex Elder <elder@linaro.org>
    Acked-by: Vaibhav Agarwal <vaibhav.sr@gmail.com>
    Acked-by: David Lin <dtwlin@gmail.com>
    Acked-by: Johan Hovold <johan@kernel.org>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Acked-by: Mark Greer <mgreer@animalcreek.com>
    Acked-by: Rui Miguel Silva <rmfrfs@gmail.com>
    Acked-by: "Bryan O'Donoghue" <pure.logic@nexus-software.ie>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/hid.c b/drivers/staging/greybus/hid.c
index 538d5cd140ca..04053ff075a6 100644
--- a/drivers/staging/greybus/hid.c
+++ b/drivers/staging/greybus/hid.c
@@ -4,8 +4,6 @@
  *
  * Copyright 2014 Google Inc.
  * Copyright 2014 Linaro Ltd.
- *
- * Released under the GPLv2 only.
  */
 
 #include <linux/bitops.h>

commit eb50fd3a22c770f36be275295b782f3ea52e3215
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Nov 7 14:58:41 2017 +0100

    staging: greybus: add SPDX identifiers to all greybus driver files
    
    It's good to have SPDX identifiers in all files to make it easier to
    audit the kernel tree for correct licenses.
    
    Update the drivers/staging/greybus files files with the correct SPDX
    license identifier based on the license text in the file itself.  The
    SPDX identifier is a legally binding shorthand, which can be used
    instead of the full boiler plate text.
    
    This work is based on a script and data from Thomas Gleixner, Philippe
    Ombredanne, and Kate Stewart.
    
    Cc: Vaibhav Hiremath <hvaibhav.linux@gmail.com>
    Cc: "Bryan O'Donoghue" <pure.logic@nexus-software.ie>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: Philippe Ombredanne <pombredanne@nexb.com>
    Acked-by: Vaibhav Agarwal <vaibhav.sr@gmail.com>
    Acked-by: David Lin <dtwlin@gmail.com>
    Reviewed-by: Alex Elder <elder@linaro.org>
    Acked-by: Johan Hovold <johan@kernel.org>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Acked-by: Mark Greer <mgreer@animalcreek.com>
    Acked-by: Rui Miguel Silva <rmfrfs@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/hid.c b/drivers/staging/greybus/hid.c
index 465101bbab69..538d5cd140ca 100644
--- a/drivers/staging/greybus/hid.c
+++ b/drivers/staging/greybus/hid.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * HID class driver for the Greybus.
  *

commit d9d2401f59355264a435c723aadee5b84b75881b
Author: Dmitry Torokhov <dmitry.torokhov@gmail.com>
Date:   Tue Jun 6 23:59:37 2017 -0700

    greybus: hid: remove custom locking from gb_hid_open/close
    
    Now that HID core enforces serialization of transport driver open/close
    calls we can remove custom locking from greybus hid driver.
    
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Reviewed-by: Andy Shevchenko <andy.shevchenko@gmail.com>
    Reviewed-by: Benjamin Tissoires <benjamin.tissoires@redhat.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/staging/greybus/hid.c b/drivers/staging/greybus/hid.c
index 730d746fc4c2..465101bbab69 100644
--- a/drivers/staging/greybus/hid.c
+++ b/drivers/staging/greybus/hid.c
@@ -32,8 +32,6 @@ struct gb_hid {
 	char				*inbuf;
 };
 
-static DEFINE_MUTEX(gb_hid_open_mutex);
-
 /* Routines to get controller's information over greybus */
 
 /* Operations performed on greybus */
@@ -346,19 +344,14 @@ static void gb_hid_stop(struct hid_device *hid)
 static int gb_hid_open(struct hid_device *hid)
 {
 	struct gb_hid *ghid = hid->driver_data;
-	int ret = 0;
-
-	mutex_lock(&gb_hid_open_mutex);
-	if (!hid->open++) {
-		ret = gb_hid_set_power(ghid, GB_HID_TYPE_PWR_ON);
-		if (ret < 0)
-			hid->open--;
-		else
-			set_bit(GB_HID_STARTED, &ghid->flags);
-	}
-	mutex_unlock(&gb_hid_open_mutex);
+	int ret;
 
-	return ret;
+	ret = gb_hid_set_power(ghid, GB_HID_TYPE_PWR_ON);
+	if (ret < 0)
+		return ret;
+
+	set_bit(GB_HID_STARTED, &ghid->flags);
+	return 0;
 }
 
 static void gb_hid_close(struct hid_device *hid)
@@ -366,21 +359,13 @@ static void gb_hid_close(struct hid_device *hid)
 	struct gb_hid *ghid = hid->driver_data;
 	int ret;
 
-	/*
-	 * Protecting hid->open to make sure we don't restart data acquistion
-	 * due to a resumption we no longer care about..
-	 */
-	mutex_lock(&gb_hid_open_mutex);
-	if (!--hid->open) {
-		clear_bit(GB_HID_STARTED, &ghid->flags);
-
-		/* Save some power */
-		ret = gb_hid_set_power(ghid, GB_HID_TYPE_PWR_OFF);
-		if (ret)
-			dev_err(&ghid->connection->bundle->dev,
-				"failed to power off (%d)\n", ret);
-	}
-	mutex_unlock(&gb_hid_open_mutex);
+	clear_bit(GB_HID_STARTED, &ghid->flags);
+
+	/* Save some power */
+	ret = gb_hid_set_power(ghid, GB_HID_TYPE_PWR_OFF);
+	if (ret)
+		dev_err(&ghid->connection->bundle->dev,
+			"failed to power off (%d)\n", ret);
 }
 
 static int gb_hid_power(struct hid_device *hid, int lvl)

commit be21106d67db9ad3c66e48c8efdcf1bc08be45a4
Author: Greg Kroah-Hartman <gregkh@google.com>
Date:   Thu Sep 8 15:46:38 2016 +0200

    staging: greybus: hid: remove KERNEL_VERSION checks
    
    No need to support older kernel versions in the Greybus HID driver, so
    remove the checks as needed, we can now rely on all of the "new" apis
    being present.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/hid.c b/drivers/staging/greybus/hid.c
index b558c811b7a1..730d746fc4c2 100644
--- a/drivers/staging/greybus/hid.c
+++ b/drivers/staging/greybus/hid.c
@@ -277,23 +277,6 @@ static int gb_hid_raw_request(struct hid_device *hid, unsigned char reportnum,
 	}
 }
 
-#if LINUX_VERSION_CODE < KERNEL_VERSION(3,15,0)
-static int gb_hid_get_raw_report(struct hid_device *hid,
-				   unsigned char reportnum, __u8 *buf,
-				   size_t len, unsigned char rtype)
-{
-	return gb_hid_raw_request(hid, reportnum, buf, len, rtype,
-				  HID_REQ_GET_REPORT);
-}
-
-static int gb_hid_output_raw_report(struct hid_device *hid, __u8 *buf,
-				    size_t len, unsigned char rtype)
-{
-	return gb_hid_raw_request(hid, buf[0], buf, len, rtype,
-				  HID_REQ_SET_REPORT);
-}
-#endif
-
 /* HID Callbacks */
 static int gb_hid_parse(struct hid_device *hid)
 {
@@ -422,9 +405,7 @@ static struct hid_ll_driver gb_hid_ll_driver = {
 	.open = gb_hid_open,
 	.close = gb_hid_close,
 	.power = gb_hid_power,
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,15,0)
 	.raw_request = gb_hid_raw_request,
-#endif
 };
 
 static int gb_hid_init(struct gb_hid *ghid)
@@ -444,10 +425,6 @@ static int gb_hid_init(struct gb_hid *ghid)
 	hid->driver_data = ghid;
 	hid->ll_driver = &gb_hid_ll_driver;
 	hid->dev.parent = &ghid->connection->bundle->dev;
-#if LINUX_VERSION_CODE < KERNEL_VERSION(3,15,0)
-	hid->hid_get_raw_report = gb_hid_get_raw_report;
-	hid->hid_output_raw_report = gb_hid_output_raw_report;
-#endif
 //	hid->bus = BUS_GREYBUS; /* Need a bustype for GREYBUS in <linux/input.h> */
 
 	/* Set HID device's name */

commit 43c85a09b12cd3e782ae237be9903fef4559cc0d
Author: Philip Yang <yang_philip@projectara.com>
Date:   Sat Jul 23 05:48:14 2016 +0800

    greybus: HID: Add runtime pm support
    
    Modify HID greybus driver to support runtime PM framework.
    The suspend and resume fucntion have been test with tutorial-hid,
    e-ink-display and gpbridge-test image by sysfs resume, all HID
    buttons work well on suspend/resume.
    
    Testing Done: Compiled and verified on EVT2, DB3.5, GPB test module
                  with daughter board, Red module.
    
    Signed-off-by: Philip Yang <yang_philip@projectara.com>
    Reviewed-by: David Lin <dtwlin@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/hid.c b/drivers/staging/greybus/hid.c
index ca0c94949c6b..b558c811b7a1 100644
--- a/drivers/staging/greybus/hid.c
+++ b/drivers/staging/greybus/hid.c
@@ -18,6 +18,7 @@
 
 /* Greybus HID device's structure */
 struct gb_hid {
+	struct gb_bundle *bundle;
 	struct gb_connection		*connection;
 
 	struct hid_device		*hid;
@@ -44,26 +45,55 @@ static int gb_hid_get_desc(struct gb_hid *ghid)
 
 static int gb_hid_get_report_desc(struct gb_hid *ghid, char *rdesc)
 {
-	return gb_operation_sync(ghid->connection, GB_HID_TYPE_GET_REPORT_DESC,
+	int ret;
+
+	ret = gb_pm_runtime_get_sync(ghid->bundle);
+	if (ret)
+		return ret;
+
+	ret = gb_operation_sync(ghid->connection, GB_HID_TYPE_GET_REPORT_DESC,
 				 NULL, 0, rdesc,
 				 le16_to_cpu(ghid->hdesc.wReportDescLength));
+
+	gb_pm_runtime_put_autosuspend(ghid->bundle);
+
+	return ret;
 }
 
 static int gb_hid_set_power(struct gb_hid *ghid, int type)
 {
-	return gb_operation_sync(ghid->connection, type, NULL, 0, NULL, 0);
+	int ret;
+
+	ret = gb_pm_runtime_get_sync(ghid->bundle);
+	if (ret)
+		return ret;
+
+	ret = gb_operation_sync(ghid->connection, type, NULL, 0, NULL, 0);
+
+	gb_pm_runtime_put_autosuspend(ghid->bundle);
+
+	return ret;
 }
 
 static int gb_hid_get_report(struct gb_hid *ghid, u8 report_type, u8 report_id,
 			     unsigned char *buf, int len)
 {
 	struct gb_hid_get_report_request request;
+	int ret;
+
+	ret = gb_pm_runtime_get_sync(ghid->bundle);
+	if (ret)
+		return ret;
 
 	request.report_type = report_type;
 	request.report_id = report_id;
 
-	return gb_operation_sync(ghid->connection, GB_HID_TYPE_GET_REPORT,
+	ret = gb_operation_sync(ghid->connection, GB_HID_TYPE_GET_REPORT,
 				 &request, sizeof(request), buf, len);
+
+	gb_pm_runtime_put_autosuspend(ghid->bundle);
+
+	return ret;
 }
 
 static int gb_hid_set_report(struct gb_hid *ghid, u8 report_type, u8 report_id,
@@ -73,11 +103,17 @@ static int gb_hid_set_report(struct gb_hid *ghid, u8 report_type, u8 report_id,
 	struct gb_operation *operation;
 	int ret, size = sizeof(*request) + len - 1;
 
+	ret = gb_pm_runtime_get_sync(ghid->bundle);
+	if (ret)
+		return ret;
+
 	operation = gb_operation_create(ghid->connection,
 					GB_HID_TYPE_SET_REPORT, size, 0,
 					GFP_KERNEL);
-	if (!operation)
+	if (!operation) {
+		gb_pm_runtime_put_autosuspend(ghid->bundle);
 		return -ENOMEM;
+	}
 
 	request = operation->request->payload;
 	request->report_type = report_type;
@@ -93,6 +129,7 @@ static int gb_hid_set_report(struct gb_hid *ghid, u8 report_type, u8 report_id,
 	}
 
 	gb_operation_put(operation);
+	gb_pm_runtime_put_autosuspend(ghid->bundle);
 
 	return ret;
 }
@@ -458,6 +495,7 @@ static int gb_hid_probe(struct gb_bundle *bundle,
 	}
 
 	ghid->hid = hid;
+	ghid->bundle = bundle;
 
 	greybus_set_drvdata(bundle, ghid);
 
@@ -475,6 +513,8 @@ static int gb_hid_probe(struct gb_bundle *bundle,
 		goto err_connection_disable;
 	}
 
+	gb_pm_runtime_put_autosuspend(bundle);
+
 	return 0;
 
 err_connection_disable:
@@ -493,6 +533,9 @@ static void gb_hid_disconnect(struct gb_bundle *bundle)
 {
 	struct gb_hid *ghid = greybus_get_drvdata(bundle);
 
+	if (gb_pm_runtime_get_sync(bundle))
+		gb_pm_runtime_get_noresume(bundle);
+
 	hid_destroy_device(ghid->hid);
 	gb_connection_disable(ghid->connection);
 	gb_connection_destroy(ghid->connection);

commit 60fb3405c73ea0bbab942c699496123f9e987c04
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Fri Jun 10 14:59:07 2016 +0530

    greybus: Remove extra blank lines
    
    This patch removes few blank lines across the repository at places where
    two blank lines were present together or when a blank line is present at
    the start or end of a routine.
    
    Note that this doesn't remove most of them from greybus_protocols.h as
    they were added on purpose.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/hid.c b/drivers/staging/greybus/hid.c
index fd4a7e096450..ca0c94949c6b 100644
--- a/drivers/staging/greybus/hid.c
+++ b/drivers/staging/greybus/hid.c
@@ -116,7 +116,6 @@ static int gb_hid_request_handler(struct gb_operation *op)
 	return 0;
 }
 
-
 static int gb_hid_report_len(struct hid_report *report)
 {
 	return ((report->size - 1) >> 3) + 1 +

commit 0ec306324423444d3ee0222708ef9de7f5586b93
Author: Greg Kroah-Hartman <gregkh@google.com>
Date:   Tue Mar 22 14:30:35 2016 -0400

    greybus: convert drivers to use connection->private set/get
    
    This converts all drivers to use the gb_connection_get_data() and
    gb_connection_set_data() functions to make it a bit more explicit as to
    what is going on.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>
    Reviewed-by: Alex Elder <elder@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/hid.c b/drivers/staging/greybus/hid.c
index 6ef151f61ffc..fd4a7e096450 100644
--- a/drivers/staging/greybus/hid.c
+++ b/drivers/staging/greybus/hid.c
@@ -100,7 +100,7 @@ static int gb_hid_set_report(struct gb_hid *ghid, u8 report_type, u8 report_id,
 static int gb_hid_request_handler(struct gb_operation *op)
 {
 	struct gb_connection *connection = op->connection;
-	struct gb_hid *ghid = connection->private;
+	struct gb_hid *ghid = gb_connection_get_data(connection);
 	struct gb_hid_input_report_request *request = op->request->payload;
 
 	if (op->type != GB_HID_TYPE_IRQ_EVENT) {
@@ -449,7 +449,7 @@ static int gb_hid_probe(struct gb_bundle *bundle,
 		goto err_free_ghid;
 	}
 
-	connection->private = ghid;
+	gb_connection_set_data(connection, ghid);
 	ghid->connection = connection;
 
 	hid = hid_allocate_device();

commit 9b22f155beb4e5a71f86710034b478ec43af9c43
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Fri Feb 26 16:44:19 2016 +0530

    greybus: hid: Replace WARN_ON() with dev_err()
    
    WARN_ON() is a bit harsh here, as we just failed to power-off the HID
    device while it is getting removed.
    
    Replace it with dev_err().
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Reviewed-by: Johan Hovold <johan@hovoldconsulting.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/hid.c b/drivers/staging/greybus/hid.c
index 601ee6fc81d5..6ef151f61ffc 100644
--- a/drivers/staging/greybus/hid.c
+++ b/drivers/staging/greybus/hid.c
@@ -345,6 +345,7 @@ static int gb_hid_open(struct hid_device *hid)
 static void gb_hid_close(struct hid_device *hid)
 {
 	struct gb_hid *ghid = hid->driver_data;
+	int ret;
 
 	/*
 	 * Protecting hid->open to make sure we don't restart data acquistion
@@ -355,7 +356,10 @@ static void gb_hid_close(struct hid_device *hid)
 		clear_bit(GB_HID_STARTED, &ghid->flags);
 
 		/* Save some power */
-		WARN_ON(gb_hid_set_power(ghid, GB_HID_TYPE_PWR_OFF));
+		ret = gb_hid_set_power(ghid, GB_HID_TYPE_PWR_OFF);
+		if (ret)
+			dev_err(&ghid->connection->bundle->dev,
+				"failed to power off (%d)\n", ret);
 	}
 	mutex_unlock(&gb_hid_open_mutex);
 }

commit b22b7104d5930ed4aae2c8494b8f95f20a85d66b
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Mon Feb 29 12:19:50 2016 +0530

    greybus: hid: Don't disable connection-tx before destroying hid-device
    
    hid_destroy_device() can potentially call callbacks defined in struct
    hid_ll_driver, which may initiate few greybus operations.
    
    And so connection (tx) should be kept enabled until the hid-device isn't
    destroyed.
    
    Reported-by: Jiss Kuruvila <jkuruvila@google.com>
    Reported-by: Laurent Pinchart <laurent.pinchart@linaro.org>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Reviewed-by: Johan Hovold <johan@hovoldconsulting.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/hid.c b/drivers/staging/greybus/hid.c
index 4db337cf7acc..601ee6fc81d5 100644
--- a/drivers/staging/greybus/hid.c
+++ b/drivers/staging/greybus/hid.c
@@ -490,8 +490,8 @@ static void gb_hid_disconnect(struct gb_bundle *bundle)
 {
 	struct gb_hid *ghid = greybus_get_drvdata(bundle);
 
-	gb_connection_disable(ghid->connection);
 	hid_destroy_device(ghid->hid);
+	gb_connection_disable(ghid->connection);
 	gb_connection_destroy(ghid->connection);
 	kfree(ghid);
 }

commit 4324282d90cb02e041753240780c516f9cfe5b10
Author: Johan Hovold <johan@hovoldconsulting.com>
Date:   Thu Jan 21 17:34:23 2016 +0100

    greybus: hid: convert to bundle driver
    
    Convert the legacy HID protocol driver to a bundle driver.
    
    This also fixes a potential crash should a (malicious) module have sent
    an early request before the private data had been initialised.
    
    Reviewed-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Johan Hovold <johan@hovoldconsulting.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/hid.c b/drivers/staging/greybus/hid.c
index 51657b06ea73..4db337cf7acc 100644
--- a/drivers/staging/greybus/hid.c
+++ b/drivers/staging/greybus/hid.c
@@ -97,13 +97,13 @@ static int gb_hid_set_report(struct gb_hid *ghid, u8 report_type, u8 report_id,
 	return ret;
 }
 
-static int gb_hid_irq_handler(u8 type, struct gb_operation *op)
+static int gb_hid_request_handler(struct gb_operation *op)
 {
 	struct gb_connection *connection = op->connection;
 	struct gb_hid *ghid = connection->private;
 	struct gb_hid_input_report_request *request = op->request->payload;
 
-	if (type != GB_HID_TYPE_IRQ_EVENT) {
+	if (op->type != GB_HID_TYPE_IRQ_EVENT) {
 		dev_err(&connection->bundle->dev,
 			"unsupported unsolicited request\n");
 		return -EINVAL;
@@ -418,64 +418,96 @@ static int gb_hid_init(struct gb_hid *ghid)
 	return 0;
 }
 
-static int gb_hid_connection_init(struct gb_connection *connection)
+static int gb_hid_probe(struct gb_bundle *bundle,
+			const struct greybus_bundle_id *id)
 {
+	struct greybus_descriptor_cport *cport_desc;
+	struct gb_connection *connection;
 	struct hid_device *hid;
 	struct gb_hid *ghid;
 	int ret;
 
+	if (bundle->num_cports != 1)
+		return -ENODEV;
+
+	cport_desc = &bundle->cport_desc[0];
+	if (cport_desc->protocol_id != GREYBUS_PROTOCOL_HID)
+		return -ENODEV;
+
 	ghid = kzalloc(sizeof(*ghid), GFP_KERNEL);
 	if (!ghid)
 		return -ENOMEM;
 
-	hid = hid_allocate_device();
-	if (IS_ERR(hid)) {
-		ret = PTR_ERR(hid);
+	connection = gb_connection_create(bundle, le16_to_cpu(cport_desc->id),
+						gb_hid_request_handler);
+	if (IS_ERR(connection)) {
+		ret = PTR_ERR(connection);
 		goto err_free_ghid;
 	}
 
 	connection->private = ghid;
 	ghid->connection = connection;
+
+	hid = hid_allocate_device();
+	if (IS_ERR(hid)) {
+		ret = PTR_ERR(hid);
+		goto err_connection_destroy;
+	}
+
 	ghid->hid = hid;
 
-	ret = gb_hid_init(ghid);
+	greybus_set_drvdata(bundle, ghid);
+
+	ret = gb_connection_enable(connection);
 	if (ret)
 		goto err_destroy_hid;
 
+	ret = gb_hid_init(ghid);
+	if (ret)
+		goto err_connection_disable;
+
 	ret = hid_add_device(hid);
 	if (ret) {
 		hid_err(hid, "can't add hid device: %d\n", ret);
-		goto err_destroy_hid;
+		goto err_connection_disable;
 	}
 
 	return 0;
 
+err_connection_disable:
+	gb_connection_disable(connection);
 err_destroy_hid:
 	hid_destroy_device(hid);
+err_connection_destroy:
+	gb_connection_destroy(connection);
 err_free_ghid:
 	kfree(ghid);
 
 	return ret;
 }
 
-static void gb_hid_connection_exit(struct gb_connection *connection)
+static void gb_hid_disconnect(struct gb_bundle *bundle)
 {
-	struct gb_hid *ghid = connection->private;
+	struct gb_hid *ghid = greybus_get_drvdata(bundle);
 
+	gb_connection_disable(ghid->connection);
 	hid_destroy_device(ghid->hid);
+	gb_connection_destroy(ghid->connection);
 	kfree(ghid);
 }
 
-static struct gb_protocol hid_protocol = {
-	.name			= "hid",
-	.id			= GREYBUS_PROTOCOL_HID,
-	.major			= GB_HID_VERSION_MAJOR,
-	.minor			= GB_HID_VERSION_MINOR,
-	.connection_init	= gb_hid_connection_init,
-	.connection_exit	= gb_hid_connection_exit,
-	.request_recv		= gb_hid_irq_handler,
+static const struct greybus_bundle_id gb_hid_id_table[] = {
+	{ GREYBUS_DEVICE_CLASS(GREYBUS_CLASS_HID) },
+	{ }
 };
+MODULE_DEVICE_TABLE(greybus, gb_hid_id_table);
 
-gb_protocol_driver(&hid_protocol);
+static struct greybus_driver gb_hid_driver = {
+	.name		= "hid",
+	.probe		= gb_hid_probe,
+	.disconnect	= gb_hid_disconnect,
+	.id_table	= gb_hid_id_table,
+};
+module_greybus_driver(gb_hid_driver);
 
 MODULE_LICENSE("GPL v2");

commit 5dd8cc5370dbf68f17ed9443be6bcc54afbef204
Author: Johan Hovold <johan@hovoldconsulting.com>
Date:   Thu Jan 21 17:34:22 2016 +0100

    greybus: hid: clean up init error paths
    
    Separate success and error paths more clearly.
    
    Reviewed-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Johan Hovold <johan@hovoldconsulting.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/hid.c b/drivers/staging/greybus/hid.c
index f45b444716ba..51657b06ea73 100644
--- a/drivers/staging/greybus/hid.c
+++ b/drivers/staging/greybus/hid.c
@@ -431,7 +431,7 @@ static int gb_hid_connection_init(struct gb_connection *connection)
 	hid = hid_allocate_device();
 	if (IS_ERR(hid)) {
 		ret = PTR_ERR(hid);
-		goto free_ghid;
+		goto err_free_ghid;
 	}
 
 	connection->private = ghid;
@@ -440,17 +440,19 @@ static int gb_hid_connection_init(struct gb_connection *connection)
 
 	ret = gb_hid_init(ghid);
 	if (ret)
-		goto destroy_hid;
+		goto err_destroy_hid;
 
 	ret = hid_add_device(hid);
-	if (!ret)
-		return 0;
+	if (ret) {
+		hid_err(hid, "can't add hid device: %d\n", ret);
+		goto err_destroy_hid;
+	}
 
-	hid_err(hid, "can't add hid device: %d\n", ret);
+	return 0;
 
-destroy_hid:
+err_destroy_hid:
 	hid_destroy_device(hid);
-free_ghid:
+err_free_ghid:
 	kfree(ghid);
 
 	return ret;

commit 2f3db927cdf7627aa5359ff46c80ab72f7971980
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Fri Dec 4 21:30:09 2015 +0530

    greybus: don't use %h and %hh for printing short and char variables
    
    Because the width of our fields is already known, we can use %0Nx (for
    hex) to print N bytes and %u (for unsigned decimal), instead of using %h
    and %hh, which isn't that readable.
    
    This patch makes following changes:
    - s/%hx/%04x
    - s/%04hx/%04x
    - s/%hhx/%02x
    - s/%02hhx/%02x
    - s/%hhu/%u
    - s/%hu/%u
    - s/%x/%02x for u8 value (only at a single place)
    
    Suggested-by: Johan Hovold <johan@hovoldconsulting.com>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Reviewed-by: Johan Hovold <johan@hovoldconsulting.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/hid.c b/drivers/staging/greybus/hid.c
index 2adcb1c47d2e..f45b444716ba 100644
--- a/drivers/staging/greybus/hid.c
+++ b/drivers/staging/greybus/hid.c
@@ -411,7 +411,7 @@ static int gb_hid_init(struct gb_hid *ghid)
 //	hid->bus = BUS_GREYBUS; /* Need a bustype for GREYBUS in <linux/input.h> */
 
 	/* Set HID device's name */
-	snprintf(hid->name, sizeof(hid->name), "%s %04hX:%04hX",
+	snprintf(hid->name, sizeof(hid->name), "%s %04X:%04X",
 		 dev_name(&ghid->connection->bundle->dev),
 		 hid->vendor, hid->product);
 

commit c9e9de26f912bc0e5bca6a5168e7d5d427d2b2ee
Author: Greg Kroah-Hartman <gregkh@google.com>
Date:   Wed Nov 4 20:46:14 2015 -0800

    greybus: hid: hid should not be part of the bridged-phy driver.
    
    HID is a stand-alone greybus protocol, not part of the bridged-phy
    protocols, so make it a stand-alone kernel module.
    
    Note, some hard-coded android init script might need to be changed to
    load the gb-hid.ko kernel module now.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>
    Reviewed-by: Viresh Kumar <viresh.kumar@linaro.org>

diff --git a/drivers/staging/greybus/hid.c b/drivers/staging/greybus/hid.c
index 3ac9c1049f1d..2adcb1c47d2e 100644
--- a/drivers/staging/greybus/hid.c
+++ b/drivers/staging/greybus/hid.c
@@ -474,4 +474,6 @@ static struct gb_protocol hid_protocol = {
 	.request_recv		= gb_hid_irq_handler,
 };
 
-gb_builtin_protocol_driver(hid_protocol);
+gb_protocol_driver(&hid_protocol);
+
+MODULE_LICENSE("GPL v2");

commit b2a637d72df790dbb8550627903c93ec8df4e9f7
Author: Greg Kroah-Hartman <gregkh@google.com>
Date:   Wed Oct 14 11:16:24 2015 -0700

    greybus: hid: use the bundle struct device instead of the connector
    
    We are removing struct device from the gb_connection structure in the
    near future.  The gb_bundle structure's struct device should be used as
    a replacement.
    
    This patch moves the hid driver to use the bundle pointer instead of the
    connection pointer.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>
    Reviewed-by: Alex Elder <elder@linaro.org>

diff --git a/drivers/staging/greybus/hid.c b/drivers/staging/greybus/hid.c
index a2f0612076d5..3ac9c1049f1d 100644
--- a/drivers/staging/greybus/hid.c
+++ b/drivers/staging/greybus/hid.c
@@ -86,7 +86,7 @@ static int gb_hid_set_report(struct gb_hid *ghid, u8 report_type, u8 report_id,
 
 	ret = gb_operation_request_send_sync(operation);
 	if (ret) {
-		dev_err(&operation->connection->dev,
+		dev_err(&operation->connection->bundle->dev,
 			"failed to set report: %d\n", ret);
 	} else {
 		ret = len;
@@ -104,7 +104,7 @@ static int gb_hid_irq_handler(u8 type, struct gb_operation *op)
 	struct gb_hid_input_report_request *request = op->request->payload;
 
 	if (type != GB_HID_TYPE_IRQ_EVENT) {
-		dev_err(&connection->dev,
+		dev_err(&connection->bundle->dev,
 			"unsupported unsolicited request\n");
 		return -EINVAL;
 	}
@@ -403,7 +403,7 @@ static int gb_hid_init(struct gb_hid *ghid)
 
 	hid->driver_data = ghid;
 	hid->ll_driver = &gb_hid_ll_driver;
-	hid->dev.parent = &ghid->connection->dev;
+	hid->dev.parent = &ghid->connection->bundle->dev;
 #if LINUX_VERSION_CODE < KERNEL_VERSION(3,15,0)
 	hid->hid_get_raw_report = gb_hid_get_raw_report;
 	hid->hid_output_raw_report = gb_hid_output_raw_report;
@@ -412,7 +412,8 @@ static int gb_hid_init(struct gb_hid *ghid)
 
 	/* Set HID device's name */
 	snprintf(hid->name, sizeof(hid->name), "%s %04hX:%04hX",
-		 dev_name(&ghid->connection->dev), hid->vendor, hid->product);
+		 dev_name(&ghid->connection->bundle->dev),
+		 hid->vendor, hid->product);
 
 	return 0;
 }

commit 6ab1ce4d542ea1b5ffa40321e021d95de47880ea
Author: Johan Hovold <johan@hovoldconsulting.com>
Date:   Sat Sep 26 17:59:15 2015 -0700

    greybus: operation: remove gb_operation_destroy
    
    Remove legacy interface to "destroy" operations, which is now just a
    wrapper for gb_operation_put.
    
    The old interface name hides the fact that all operations are refcounted
    and may live on even after having "destroyed" them.
    
    Signed-off-by: Johan Hovold <johan@hovoldconsulting.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/hid.c b/drivers/staging/greybus/hid.c
index 0044b844c3e9..a2f0612076d5 100644
--- a/drivers/staging/greybus/hid.c
+++ b/drivers/staging/greybus/hid.c
@@ -92,7 +92,8 @@ static int gb_hid_set_report(struct gb_hid *ghid, u8 report_type, u8 report_id,
 		ret = len;
 	}
 
-	gb_operation_destroy(operation);
+	gb_operation_put(operation);
+
 	return ret;
 }
 

commit 51aee043ecdb890bbfd33e4cb3b73269ee8371e3
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Wed Aug 12 11:51:11 2015 +0530

    greybus: hid: Move request/response structure/definitions to greybus_protocols.h
    
    These must be exposed to external modules, like gbsim. Move them to
    greybus_protocols.h file.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/hid.c b/drivers/staging/greybus/hid.c
index 887dbac8c117..0044b844c3e9 100644
--- a/drivers/staging/greybus/hid.c
+++ b/drivers/staging/greybus/hid.c
@@ -16,55 +16,6 @@
 
 #include "greybus.h"
 
-/* Version of the Greybus hid protocol we support */
-#define GB_HID_VERSION_MAJOR		0x00
-#define GB_HID_VERSION_MINOR		0x01
-
-/* Greybus HID operation types */
-#define GB_HID_TYPE_INVALID		0x00
-#define GB_HID_TYPE_PROTOCOL_VERSION	0x01
-#define GB_HID_TYPE_GET_DESC		0x02
-#define GB_HID_TYPE_GET_REPORT_DESC	0x03
-#define GB_HID_TYPE_PWR_ON		0x04
-#define GB_HID_TYPE_PWR_OFF		0x05
-#define GB_HID_TYPE_GET_REPORT		0x06
-#define GB_HID_TYPE_SET_REPORT		0x07
-#define GB_HID_TYPE_IRQ_EVENT		0x08
-
-/* Report type */
-#define GB_HID_INPUT_REPORT		0
-#define GB_HID_OUTPUT_REPORT		1
-#define GB_HID_FEATURE_REPORT		2
-
-/* Different request/response structures */
-/* HID get descriptor response */
-struct gb_hid_desc_response {
-	__u8				bLength;
-	__le16				wReportDescLength;
-	__le16				bcdHID;
-	__le16				wProductID;
-	__le16				wVendorID;
-	__u8				bCountryCode;
-} __packed;
-
-/* HID get report request/response */
-struct gb_hid_get_report_request {
-	__u8				report_type;
-	__u8				report_id;
-};
-
-/* HID set report request */
-struct gb_hid_set_report_request {
-	__u8				report_type;
-	__u8				report_id;
-	__u8				report[0];
-};
-
-/* HID input report request, via interrupt pipe */
-struct gb_hid_input_report_request {
-	__u8				report[0];
-};
-
 /* Greybus HID device's structure */
 struct gb_hid {
 	struct gb_connection		*connection;

commit 2dad338c9c28f464c9717e9d0391997b649e3acd
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Tue Aug 11 07:36:04 2015 +0530

    greybus: hid: Drop get_version support
    
    This is done from a common place now, no need to replicate it.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/hid.c b/drivers/staging/greybus/hid.c
index 0baed865b760..887dbac8c117 100644
--- a/drivers/staging/greybus/hid.c
+++ b/drivers/staging/greybus/hid.c
@@ -68,8 +68,6 @@ struct gb_hid_input_report_request {
 /* Greybus HID device's structure */
 struct gb_hid {
 	struct gb_connection		*connection;
-	u8				version_major;
-	u8				version_minor;
 
 	struct hid_device		*hid;
 	struct gb_hid_desc_response	hdesc;
@@ -86,9 +84,6 @@ static DEFINE_MUTEX(gb_hid_open_mutex);
 
 /* Routines to get controller's information over greybus */
 
-/* Define get_version() routine */
-define_get_version(gb_hid, HID);
-
 /* Operations performed on greybus */
 static int gb_hid_get_desc(struct gb_hid *ghid)
 {
@@ -445,10 +440,6 @@ static int gb_hid_init(struct gb_hid *ghid)
 	struct hid_device *hid = ghid->hid;
 	int ret;
 
-	ret = get_version(ghid);
-	if (ret)
-		return ret;
-
 	ret = gb_hid_get_desc(ghid);
 	if (ret)
 		return ret;

commit 34ec36457f360fd2930fbf6e4cdfd6f7bc4d98c1
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Sat Aug 8 10:25:35 2015 +0530

    greybus: hid: Use (already defined) major/minor macros
    
    We already have macros for these, use them instead of writing fixed
    values.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/hid.c b/drivers/staging/greybus/hid.c
index d423f8eb145e..0baed865b760 100644
--- a/drivers/staging/greybus/hid.c
+++ b/drivers/staging/greybus/hid.c
@@ -523,8 +523,8 @@ static void gb_hid_connection_exit(struct gb_connection *connection)
 static struct gb_protocol hid_protocol = {
 	.name			= "hid",
 	.id			= GREYBUS_PROTOCOL_HID,
-	.major			= 0,
-	.minor			= 1,
+	.major			= GB_HID_VERSION_MAJOR,
+	.minor			= GB_HID_VERSION_MINOR,
 	.connection_init	= gb_hid_connection_init,
 	.connection_exit	= gb_hid_connection_exit,
 	.request_recv		= gb_hid_irq_handler,

commit d79ae495e2ddb2b6f39376c4eed080dbc1b074d5
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Sat Aug 8 10:25:32 2015 +0530

    greybus: hid: spell fix (s/infomation/information)
    
    Minor spell fix.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/hid.c b/drivers/staging/greybus/hid.c
index a367fd5fad70..d423f8eb145e 100644
--- a/drivers/staging/greybus/hid.c
+++ b/drivers/staging/greybus/hid.c
@@ -84,7 +84,7 @@ struct gb_hid {
 
 static DEFINE_MUTEX(gb_hid_open_mutex);
 
-/* Routines to get controller's infomation over greybus */
+/* Routines to get controller's information over greybus */
 
 /* Define get_version() routine */
 define_get_version(gb_hid, HID);

commit e420721b47ef5b0d521584d4efc89ff64bd0cd74
Author: Johan Hovold <johan@hovoldconsulting.com>
Date:   Wed Jul 1 12:37:22 2015 +0200

    greybus: operation: allow atomic operation allocations
    
    Add gfp mask argument to gb_operation_create to allow operations to be
    allocated in atomic context.
    
    Signed-off-by: Johan Hovold <johan@hovoldconsulting.com>
    Reviewed-by: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/hid.c b/drivers/staging/greybus/hid.c
index 1214b7a0a631..a367fd5fad70 100644
--- a/drivers/staging/greybus/hid.c
+++ b/drivers/staging/greybus/hid.c
@@ -128,7 +128,8 @@ static int gb_hid_set_report(struct gb_hid *ghid, u8 report_type, u8 report_id,
 	int ret, size = sizeof(*request) + len - 1;
 
 	operation = gb_operation_create(ghid->connection,
-					GB_HID_TYPE_SET_REPORT, size, 0);
+					GB_HID_TYPE_SET_REPORT, size, 0,
+					GFP_KERNEL);
 	if (!operation)
 		return -ENOMEM;
 

commit e18822e3d02c8f296fe42e0e8bda7e2e626a4714
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Wed Jul 1 12:13:52 2015 +0530

    greybus: Rename gb_gpbridge_protocol_driver() as gb_builtin_protocol_driver()
    
    This macro is also required by core protocols like control and svc, and
    hence the 'gpbridge' name doesn't fit anymore.
    
    Lets call this macro gb_builtin_protocol_driver().
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Reviewed-by: Alex Elder <elder@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/hid.c b/drivers/staging/greybus/hid.c
index 2f6e68c1be88..1214b7a0a631 100644
--- a/drivers/staging/greybus/hid.c
+++ b/drivers/staging/greybus/hid.c
@@ -529,4 +529,4 @@ static struct gb_protocol hid_protocol = {
 	.request_recv		= gb_hid_irq_handler,
 };
 
-gb_gpbridge_protocol_driver(hid_protocol);
+gb_builtin_protocol_driver(hid_protocol);

commit bdac599c70409bbf48e77971e2b9ecc2a66ef151
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Wed May 20 17:20:10 2015 +0530

    greybus: Use gb_gpbridge_protocol_init()
    
    Start using gb_gpbridge_protocol_init() in gpbridge drivers.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Reviewed-by: Alex Elder <elder@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/hid.c b/drivers/staging/greybus/hid.c
index 00dc7e57f4a4..2f6e68c1be88 100644
--- a/drivers/staging/greybus/hid.c
+++ b/drivers/staging/greybus/hid.c
@@ -529,12 +529,4 @@ static struct gb_protocol hid_protocol = {
 	.request_recv		= gb_hid_irq_handler,
 };
 
-int gb_hid_protocol_init(void)
-{
-	return gb_protocol_register(&hid_protocol);
-}
-
-void gb_hid_protocol_exit(void)
-{
-	gb_protocol_deregister(&hid_protocol);
-}
+gb_gpbridge_protocol_driver(hid_protocol);

commit 6d653370c0a67ff9b9b0d8249182d537859b528c
Author: Alex Elder <elder@linaro.org>
Date:   Thu May 7 13:03:52 2015 -0500

    greybus: eliminate extra response flag definitions
    
    All protocols use the same value to distinguish between request and
    response message types.  This is a requirement.
    
    Use GB_MESSAGE_TYPE_RESPONSE rather than GB_OPERATION_TYPE_RESPONSE
    for the name of the flag used to distiguish between request and
    response messages.
    
    Get rid of the redundant response flag definitions that are
    associated with specific protocols.
    
    Describe the symbolic values as "operation types" rather than
    "message types" where they are defined.  The message type for a
    request is the same as the operation type; the message type for a
    response is the operation type OR'd with GB_MESSAGE_TYPE_RESPONSE.
    
    Signed-off-by: Alex Elder <elder@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/hid.c b/drivers/staging/greybus/hid.c
index 556cf9b0fe93..00dc7e57f4a4 100644
--- a/drivers/staging/greybus/hid.c
+++ b/drivers/staging/greybus/hid.c
@@ -20,7 +20,7 @@
 #define GB_HID_VERSION_MAJOR		0x00
 #define GB_HID_VERSION_MINOR		0x01
 
-/* Greybus HID request types */
+/* Greybus HID operation types */
 #define GB_HID_TYPE_INVALID		0x00
 #define GB_HID_TYPE_PROTOCOL_VERSION	0x01
 #define GB_HID_TYPE_GET_DESC		0x02
@@ -30,7 +30,6 @@
 #define GB_HID_TYPE_GET_REPORT		0x06
 #define GB_HID_TYPE_SET_REPORT		0x07
 #define GB_HID_TYPE_IRQ_EVENT		0x08
-#define GB_HID_TYPE_RESPONSE		0x80	/* OR'd with rest */
 
 /* Report type */
 #define GB_HID_INPUT_REPORT		0

commit 581baacd33b087e4f7322f42ca8f336f7f0acc4d
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Fri Apr 3 12:00:48 2015 +0530

    greybus: hid: Use payload-size to get report size
    
    Report size isn't passed as first two bytes of the report according to
    USB-HID spec. Get it from payload-size.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Reviewed-by: Johan Hovold <johan@hovoldconsulting.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/hid.c b/drivers/staging/greybus/hid.c
index 5935aa6c6334..556cf9b0fe93 100644
--- a/drivers/staging/greybus/hid.c
+++ b/drivers/staging/greybus/hid.c
@@ -155,7 +155,6 @@ static int gb_hid_irq_handler(u8 type, struct gb_operation *op)
 	struct gb_connection *connection = op->connection;
 	struct gb_hid *ghid = connection->private;
 	struct gb_hid_input_report_request *request = op->request->payload;
-	int size;
 
 	if (type != GB_HID_TYPE_IRQ_EVENT) {
 		dev_err(&connection->dev,
@@ -163,24 +162,9 @@ static int gb_hid_irq_handler(u8 type, struct gb_operation *op)
 		return -EINVAL;
 	}
 
-	if (op->request->payload_size < 2) {
-		dev_err(&connection->dev, "short report received\n");
-		return -EINVAL;
-	}
-
-	/*
-	 * FIXME: add report size to Greybus HID protocol if we need to parse
-	 *        it here.
-	 */
-	size = request->report[0] | request->report[1] << 8;
-	if (size < 2 || size > op->request->payload_size - 2) {
-		dev_err(&connection->dev, "bad report size: %d\n", size);
-		return -EINVAL;
-	}
-
 	if (test_bit(GB_HID_STARTED, &ghid->flags))
 		hid_input_report(ghid->hid, HID_INPUT_REPORT,
-				 request->report + 2, size - 2, 1);
+				 request->report, op->request->payload_size, 1);
 
 	return 0;
 }

commit 973ccfd62686a2331f43b0053de052d958f50d31
Author: Johan Hovold <johan@hovoldconsulting.com>
Date:   Fri Mar 27 12:45:49 2015 +0100

    greybus: operation: refactor response handling
    
    Send response to incoming requests from the operation request handler
    rather than in every protocol request_recv callback.
    
    This simplifies request_recv error handling and allows for further code
    reuse.
    
    Note that if we ever get protocols that need to hold off sending
    responses we could implement this by letting them return a special
    value (after acquiring the necessary operation references) to suppress
    the response from being sent by greybus core.
    
    Signed-off-by: Johan Hovold <johan@hovoldconsulting.com>
    Reviewed-by: Alex Elder <elder@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>

diff --git a/drivers/staging/greybus/hid.c b/drivers/staging/greybus/hid.c
index cc5708ddf068..5935aa6c6334 100644
--- a/drivers/staging/greybus/hid.c
+++ b/drivers/staging/greybus/hid.c
@@ -150,25 +150,22 @@ static int gb_hid_set_report(struct gb_hid *ghid, u8 report_type, u8 report_id,
 	return ret;
 }
 
-static void gb_hid_irq_handler(u8 type, struct gb_operation *op)
+static int gb_hid_irq_handler(u8 type, struct gb_operation *op)
 {
 	struct gb_connection *connection = op->connection;
 	struct gb_hid *ghid = connection->private;
 	struct gb_hid_input_report_request *request = op->request->payload;
-	int status;
-	int ret, size;
+	int size;
 
 	if (type != GB_HID_TYPE_IRQ_EVENT) {
 		dev_err(&connection->dev,
 			"unsupported unsolicited request\n");
-		status = -EINVAL;
-		goto send_response;
+		return -EINVAL;
 	}
 
 	if (op->request->payload_size < 2) {
 		dev_err(&connection->dev, "short report received\n");
-		status = -EINVAL;
-		goto send_response;
+		return -EINVAL;
 	}
 
 	/*
@@ -178,22 +175,14 @@ static void gb_hid_irq_handler(u8 type, struct gb_operation *op)
 	size = request->report[0] | request->report[1] << 8;
 	if (size < 2 || size > op->request->payload_size - 2) {
 		dev_err(&connection->dev, "bad report size: %d\n", size);
-		status = -EINVAL;
-		goto send_response;
+		return -EINVAL;
 	}
 
 	if (test_bit(GB_HID_STARTED, &ghid->flags))
 		hid_input_report(ghid->hid, HID_INPUT_REPORT,
 				 request->report + 2, size - 2, 1);
 
-	status = 0;
-send_response:
-	ret = gb_operation_response_send(op, status);
-	if (ret) {
-		dev_err(&connection->dev,
-			"failed to send response status %d: %d\n",
-			status, ret);
-	}
+	return 0;
 }
 
 

commit d0eb755aeef092f27b3dd2a4c90616f613541f56
Author: Johan Hovold <johan@hovoldconsulting.com>
Date:   Fri Mar 27 12:45:48 2015 +0100

    greybus: hid: fix missing response on request errors
    
    Send response also to incoming requests that cannot be fulfilled.
    
    Signed-off-by: Johan Hovold <johan@hovoldconsulting.com>
    Reviewed-by: Alex Elder <elder@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>

diff --git a/drivers/staging/greybus/hid.c b/drivers/staging/greybus/hid.c
index 8e32dfcd1131..cc5708ddf068 100644
--- a/drivers/staging/greybus/hid.c
+++ b/drivers/staging/greybus/hid.c
@@ -155,17 +155,20 @@ static void gb_hid_irq_handler(u8 type, struct gb_operation *op)
 	struct gb_connection *connection = op->connection;
 	struct gb_hid *ghid = connection->private;
 	struct gb_hid_input_report_request *request = op->request->payload;
+	int status;
 	int ret, size;
 
 	if (type != GB_HID_TYPE_IRQ_EVENT) {
 		dev_err(&connection->dev,
 			"unsupported unsolicited request\n");
-		return;
+		status = -EINVAL;
+		goto send_response;
 	}
 
 	if (op->request->payload_size < 2) {
 		dev_err(&connection->dev, "short report received\n");
-		return;
+		status = -EINVAL;
+		goto send_response;
 	}
 
 	/*
@@ -175,18 +178,21 @@ static void gb_hid_irq_handler(u8 type, struct gb_operation *op)
 	size = request->report[0] | request->report[1] << 8;
 	if (size < 2 || size > op->request->payload_size - 2) {
 		dev_err(&connection->dev, "bad report size: %d\n", size);
-		return;
+		status = -EINVAL;
+		goto send_response;
 	}
 
 	if (test_bit(GB_HID_STARTED, &ghid->flags))
 		hid_input_report(ghid->hid, HID_INPUT_REPORT,
 				 request->report + 2, size - 2, 1);
 
-	ret = gb_operation_response_send(op, 0);
+	status = 0;
+send_response:
+	ret = gb_operation_response_send(op, status);
 	if (ret) {
 		dev_err(&connection->dev,
 			"failed to send response status %d: %d\n",
-			0, ret);
+			status, ret);
 	}
 }
 

commit 382145beb4a4bb057f17d5b411546b6b56fbacd1
Author: Johan Hovold <johan@hovoldconsulting.com>
Date:   Fri Mar 27 12:45:47 2015 +0100

    greybus: hid: fix missing input verification of report events
    
    Add minimal verification of incoming report size, before using it to
    determine what buffer and size to pass on to HID core.
    
    Add comment about protocol needing to be revisited. If we are going to
    be parsing the report data received, then those fields have to be
    defined in the Greybus specification at least.
    
    Signed-off-by: Johan Hovold <johan@hovoldconsulting.com>
    Reviewed-by: Alex Elder <elder@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>

diff --git a/drivers/staging/greybus/hid.c b/drivers/staging/greybus/hid.c
index a225813bc477..8e32dfcd1131 100644
--- a/drivers/staging/greybus/hid.c
+++ b/drivers/staging/greybus/hid.c
@@ -168,8 +168,12 @@ static void gb_hid_irq_handler(u8 type, struct gb_operation *op)
 		return;
 	}
 
+	/*
+	 * FIXME: add report size to Greybus HID protocol if we need to parse
+	 *        it here.
+	 */
 	size = request->report[0] | request->report[1] << 8;
-	if (!size) {
+	if (size < 2 || size > op->request->payload_size - 2) {
 		dev_err(&connection->dev, "bad report size: %d\n", size);
 		return;
 	}

commit 36257f6b4e7671cb12f98d91a6ffdeabdc254d0c
Author: Johan Hovold <johan@hovoldconsulting.com>
Date:   Fri Mar 27 12:45:46 2015 +0100

    greybus: hid: fix null-deref on short report requests
    
    Make sure to verify the length of incoming requests before trying to
    parse the request buffer, which can even be NULL on empty requests.
    
    Signed-off-by: Johan Hovold <johan@hovoldconsulting.com>
    Reviewed-by: Alex Elder <elder@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>

diff --git a/drivers/staging/greybus/hid.c b/drivers/staging/greybus/hid.c
index f0da387476b8..a225813bc477 100644
--- a/drivers/staging/greybus/hid.c
+++ b/drivers/staging/greybus/hid.c
@@ -163,6 +163,11 @@ static void gb_hid_irq_handler(u8 type, struct gb_operation *op)
 		return;
 	}
 
+	if (op->request->payload_size < 2) {
+		dev_err(&connection->dev, "short report received\n");
+		return;
+	}
+
 	size = request->report[0] | request->report[1] << 8;
 	if (!size) {
 		dev_err(&connection->dev, "bad report size: %d\n", size);

commit ecf47ab9c5ca1427baea7ab6d3226502d967f19d
Author: Johan Hovold <johan@hovoldconsulting.com>
Date:   Fri Mar 27 12:45:45 2015 +0100

    greybus: hid: fix success response being sent on errors
    
    Make sure to only send a success response if we did not detect any
    errors.
    
    Signed-off-by: Johan Hovold <johan@hovoldconsulting.com>
    Reviewed-by: Alex Elder <elder@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>

diff --git a/drivers/staging/greybus/hid.c b/drivers/staging/greybus/hid.c
index 9734c7b35cc2..f0da387476b8 100644
--- a/drivers/staging/greybus/hid.c
+++ b/drivers/staging/greybus/hid.c
@@ -163,13 +163,6 @@ static void gb_hid_irq_handler(u8 type, struct gb_operation *op)
 		return;
 	}
 
-	ret = gb_operation_response_send(op, 0);
-	if (ret) {
-		dev_err(&connection->dev,
-			"failed to send response status %d: %d\n",
-			0, ret);
-	}
-
 	size = request->report[0] | request->report[1] << 8;
 	if (!size) {
 		dev_err(&connection->dev, "bad report size: %d\n", size);
@@ -179,6 +172,13 @@ static void gb_hid_irq_handler(u8 type, struct gb_operation *op)
 	if (test_bit(GB_HID_STARTED, &ghid->flags))
 		hid_input_report(ghid->hid, HID_INPUT_REPORT,
 				 request->report + 2, size - 2, 1);
+
+	ret = gb_operation_response_send(op, 0);
+	if (ret) {
+		dev_err(&connection->dev,
+			"failed to send response status %d: %d\n",
+			0, ret);
+	}
 }
 
 

commit b67f2d13db21de2fc948d6f7090fe2b9bae5d5bd
Author: Johan Hovold <johan@hovoldconsulting.com>
Date:   Fri Mar 27 12:45:44 2015 +0100

    greybus: hid: replace pr_err with dev_err
    
    Replace pr_err with dev_err and clean up error messages somewhat.
    
    Signed-off-by: Johan Hovold <johan@hovoldconsulting.com>
    Reviewed-by: Alex Elder <elder@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>

diff --git a/drivers/staging/greybus/hid.c b/drivers/staging/greybus/hid.c
index fe05a08aa7f2..9734c7b35cc2 100644
--- a/drivers/staging/greybus/hid.c
+++ b/drivers/staging/greybus/hid.c
@@ -139,10 +139,12 @@ static int gb_hid_set_report(struct gb_hid *ghid, u8 report_type, u8 report_id,
 	memcpy(request->report, buf, len);
 
 	ret = gb_operation_request_send_sync(operation);
-	if (ret)
-		pr_err("%s: operation failed (%d)\n", __func__, ret);
-	else
+	if (ret) {
+		dev_err(&operation->connection->dev,
+			"failed to set report: %d\n", ret);
+	} else {
 		ret = len;
+	}
 
 	gb_operation_destroy(operation);
 	return ret;
@@ -156,18 +158,21 @@ static void gb_hid_irq_handler(u8 type, struct gb_operation *op)
 	int ret, size;
 
 	if (type != GB_HID_TYPE_IRQ_EVENT) {
-		pr_err("unsupported unsolicited request\n");
+		dev_err(&connection->dev,
+			"unsupported unsolicited request\n");
 		return;
 	}
 
 	ret = gb_operation_response_send(op, 0);
-	if (ret)
-		pr_err("%s: error %d sending response status %d\n", __func__,
-		       ret, 0);
+	if (ret) {
+		dev_err(&connection->dev,
+			"failed to send response status %d: %d\n",
+			0, ret);
+	}
 
 	size = request->report[0] | request->report[1] << 8;
 	if (!size) {
-		pr_err("%s: size can't be zero.\n", __func__);
+		dev_err(&connection->dev, "bad report size: %d\n", size);
 		return;
 	}
 

commit 292cca99fb9c04888880de4ea9a1984ffcc4e7bd
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Wed Mar 18 11:41:39 2015 +0530

    greybus: hid: don't support OUTPUT report over interrupt channel
    
    There is no interrupt channel as such and so no need to support
    ->output_report().
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>

diff --git a/drivers/staging/greybus/hid.c b/drivers/staging/greybus/hid.c
index 17ca476c2568..fe05a08aa7f2 100644
--- a/drivers/staging/greybus/hid.c
+++ b/drivers/staging/greybus/hid.c
@@ -28,9 +28,8 @@
 #define GB_HID_TYPE_PWR_ON		0x04
 #define GB_HID_TYPE_PWR_OFF		0x05
 #define GB_HID_TYPE_GET_REPORT		0x06
-#define GB_HID_TYPE_SET_REPORT		0x07	/* Feature or Output, via control pipe */
-#define GB_HID_TYPE_OUTPUT_REPORT	0x08	/* Output report via interrupt pipe */
-#define GB_HID_TYPE_IRQ_EVENT		0x09
+#define GB_HID_TYPE_SET_REPORT		0x07
+#define GB_HID_TYPE_IRQ_EVENT		0x08
 #define GB_HID_TYPE_RESPONSE		0x80	/* OR'd with rest */
 
 /* Report type */
@@ -122,21 +121,15 @@ static int gb_hid_get_report(struct gb_hid *ghid, u8 report_type, u8 report_id,
 				 &request, sizeof(request), buf, len);
 }
 
-/*
- * @raw: true: use SET_REPORT HID command, false: send plain OUTPUT report.
- *
- * Use SET_REPORT for feature reports or if the device does not support the
- * output plain report.
- */
 static int gb_hid_set_report(struct gb_hid *ghid, u8 report_type, u8 report_id,
-			     unsigned char *buf, int len, int raw)
+			     unsigned char *buf, int len)
 {
 	struct gb_hid_set_report_request *request;
 	struct gb_operation *operation;
 	int ret, size = sizeof(*request) + len - 1;
-	int type = raw ? GB_HID_TYPE_SET_REPORT : GB_HID_TYPE_OUTPUT_REPORT;
 
-	operation = gb_operation_create(ghid->connection, type, size, 0);
+	operation = gb_operation_create(ghid->connection,
+					GB_HID_TYPE_SET_REPORT, size, 0);
 	if (!operation)
 		return -ENOMEM;
 
@@ -271,8 +264,7 @@ static int __gb_hid_get_raw_report(struct hid_device *hid,
 }
 
 static int __gb_hid_output_raw_report(struct hid_device *hid, __u8 *buf,
-				      size_t len, unsigned char report_type,
-				      bool raw)
+				      size_t len, unsigned char report_type)
 {
 	struct gb_hid *ghid = hid->driver_data;
 	int report_id = buf[0];
@@ -286,7 +278,7 @@ static int __gb_hid_output_raw_report(struct hid_device *hid, __u8 *buf,
 		len--;
 	}
 
-	ret = gb_hid_set_report(ghid, report_type, report_id, buf, len, raw);
+	ret = gb_hid_set_report(ghid, report_type, report_id, buf, len);
 	if (report_id && ret >= 0)
 		ret++; /* add report_id to the number of transfered bytes */
 
@@ -303,21 +295,13 @@ static int gb_hid_raw_request(struct hid_device *hid, unsigned char reportnum,
 	case HID_REQ_SET_REPORT:
 		if (buf[0] != reportnum)
 			return -EINVAL;
-		return __gb_hid_output_raw_report(hid, buf, len, rtype, true);
+		return __gb_hid_output_raw_report(hid, buf, len, rtype);
 	default:
 		return -EIO;
 	}
 }
 
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,15,0)
-static int gb_hid_output_report(struct hid_device *hid, __u8 *buf, size_t len)
-{
-	return __gb_hid_output_raw_report(hid, buf, len, HID_OUTPUT_REPORT,
-					  false);
-}
-
-#else
-
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,15,0)
 static int gb_hid_get_raw_report(struct hid_device *hid,
 				   unsigned char reportnum, __u8 *buf,
 				   size_t len, unsigned char rtype)
@@ -459,7 +443,6 @@ static struct hid_ll_driver gb_hid_ll_driver = {
 	.close = gb_hid_close,
 	.power = gb_hid_power,
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(3,15,0)
-	.output_report = gb_hid_output_report,
 	.raw_request = gb_hid_raw_request,
 #endif
 };

commit 96eab779e1985fd0b39426d288d3af38e3bce50c
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Mon Mar 16 16:49:37 2015 +0530

    greybus: hid: add HID class driver
    
    This adds HID transport layer driver for Greybus. Most of the stuff is
    implemented, but is untested.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>

diff --git a/drivers/staging/greybus/hid.c b/drivers/staging/greybus/hid.c
new file mode 100644
index 000000000000..17ca476c2568
--- /dev/null
+++ b/drivers/staging/greybus/hid.c
@@ -0,0 +1,565 @@
+/*
+ * HID class driver for the Greybus.
+ *
+ * Copyright 2014 Google Inc.
+ * Copyright 2014 Linaro Ltd.
+ *
+ * Released under the GPLv2 only.
+ */
+
+#include <linux/bitops.h>
+#include <linux/hid.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/mutex.h>
+#include <linux/slab.h>
+
+#include "greybus.h"
+
+/* Version of the Greybus hid protocol we support */
+#define GB_HID_VERSION_MAJOR		0x00
+#define GB_HID_VERSION_MINOR		0x01
+
+/* Greybus HID request types */
+#define GB_HID_TYPE_INVALID		0x00
+#define GB_HID_TYPE_PROTOCOL_VERSION	0x01
+#define GB_HID_TYPE_GET_DESC		0x02
+#define GB_HID_TYPE_GET_REPORT_DESC	0x03
+#define GB_HID_TYPE_PWR_ON		0x04
+#define GB_HID_TYPE_PWR_OFF		0x05
+#define GB_HID_TYPE_GET_REPORT		0x06
+#define GB_HID_TYPE_SET_REPORT		0x07	/* Feature or Output, via control pipe */
+#define GB_HID_TYPE_OUTPUT_REPORT	0x08	/* Output report via interrupt pipe */
+#define GB_HID_TYPE_IRQ_EVENT		0x09
+#define GB_HID_TYPE_RESPONSE		0x80	/* OR'd with rest */
+
+/* Report type */
+#define GB_HID_INPUT_REPORT		0
+#define GB_HID_OUTPUT_REPORT		1
+#define GB_HID_FEATURE_REPORT		2
+
+/* Different request/response structures */
+/* HID get descriptor response */
+struct gb_hid_desc_response {
+	__u8				bLength;
+	__le16				wReportDescLength;
+	__le16				bcdHID;
+	__le16				wProductID;
+	__le16				wVendorID;
+	__u8				bCountryCode;
+} __packed;
+
+/* HID get report request/response */
+struct gb_hid_get_report_request {
+	__u8				report_type;
+	__u8				report_id;
+};
+
+/* HID set report request */
+struct gb_hid_set_report_request {
+	__u8				report_type;
+	__u8				report_id;
+	__u8				report[0];
+};
+
+/* HID input report request, via interrupt pipe */
+struct gb_hid_input_report_request {
+	__u8				report[0];
+};
+
+/* Greybus HID device's structure */
+struct gb_hid {
+	struct gb_connection		*connection;
+	u8				version_major;
+	u8				version_minor;
+
+	struct hid_device		*hid;
+	struct gb_hid_desc_response	hdesc;
+
+	unsigned long			flags;
+#define GB_HID_STARTED			0x01
+#define GB_HID_READ_PENDING		0x04
+
+	unsigned int			bufsize;
+	char				*inbuf;
+};
+
+static DEFINE_MUTEX(gb_hid_open_mutex);
+
+/* Routines to get controller's infomation over greybus */
+
+/* Define get_version() routine */
+define_get_version(gb_hid, HID);
+
+/* Operations performed on greybus */
+static int gb_hid_get_desc(struct gb_hid *ghid)
+{
+	return gb_operation_sync(ghid->connection, GB_HID_TYPE_GET_DESC, NULL,
+				 0, &ghid->hdesc, sizeof(ghid->hdesc));
+}
+
+static int gb_hid_get_report_desc(struct gb_hid *ghid, char *rdesc)
+{
+	return gb_operation_sync(ghid->connection, GB_HID_TYPE_GET_REPORT_DESC,
+				 NULL, 0, rdesc,
+				 le16_to_cpu(ghid->hdesc.wReportDescLength));
+}
+
+static int gb_hid_set_power(struct gb_hid *ghid, int type)
+{
+	return gb_operation_sync(ghid->connection, type, NULL, 0, NULL, 0);
+}
+
+static int gb_hid_get_report(struct gb_hid *ghid, u8 report_type, u8 report_id,
+			     unsigned char *buf, int len)
+{
+	struct gb_hid_get_report_request request;
+
+	request.report_type = report_type;
+	request.report_id = report_id;
+
+	return gb_operation_sync(ghid->connection, GB_HID_TYPE_GET_REPORT,
+				 &request, sizeof(request), buf, len);
+}
+
+/*
+ * @raw: true: use SET_REPORT HID command, false: send plain OUTPUT report.
+ *
+ * Use SET_REPORT for feature reports or if the device does not support the
+ * output plain report.
+ */
+static int gb_hid_set_report(struct gb_hid *ghid, u8 report_type, u8 report_id,
+			     unsigned char *buf, int len, int raw)
+{
+	struct gb_hid_set_report_request *request;
+	struct gb_operation *operation;
+	int ret, size = sizeof(*request) + len - 1;
+	int type = raw ? GB_HID_TYPE_SET_REPORT : GB_HID_TYPE_OUTPUT_REPORT;
+
+	operation = gb_operation_create(ghid->connection, type, size, 0);
+	if (!operation)
+		return -ENOMEM;
+
+	request = operation->request->payload;
+	request->report_type = report_type;
+	request->report_id = report_id;
+	memcpy(request->report, buf, len);
+
+	ret = gb_operation_request_send_sync(operation);
+	if (ret)
+		pr_err("%s: operation failed (%d)\n", __func__, ret);
+	else
+		ret = len;
+
+	gb_operation_destroy(operation);
+	return ret;
+}
+
+static void gb_hid_irq_handler(u8 type, struct gb_operation *op)
+{
+	struct gb_connection *connection = op->connection;
+	struct gb_hid *ghid = connection->private;
+	struct gb_hid_input_report_request *request = op->request->payload;
+	int ret, size;
+
+	if (type != GB_HID_TYPE_IRQ_EVENT) {
+		pr_err("unsupported unsolicited request\n");
+		return;
+	}
+
+	ret = gb_operation_response_send(op, 0);
+	if (ret)
+		pr_err("%s: error %d sending response status %d\n", __func__,
+		       ret, 0);
+
+	size = request->report[0] | request->report[1] << 8;
+	if (!size) {
+		pr_err("%s: size can't be zero.\n", __func__);
+		return;
+	}
+
+	if (test_bit(GB_HID_STARTED, &ghid->flags))
+		hid_input_report(ghid->hid, HID_INPUT_REPORT,
+				 request->report + 2, size - 2, 1);
+}
+
+
+static int gb_hid_report_len(struct hid_report *report)
+{
+	return ((report->size - 1) >> 3) + 1 +
+		report->device->report_enum[report->type].numbered;
+}
+
+static void gb_hid_find_max_report(struct hid_device *hid, unsigned int type,
+				   unsigned int *max)
+{
+	struct hid_report *report;
+	unsigned int size;
+
+	list_for_each_entry(report, &hid->report_enum[type].report_list, list) {
+		size = gb_hid_report_len(report);
+		if (*max < size)
+			*max = size;
+	}
+}
+
+static void gb_hid_free_buffers(struct gb_hid *ghid)
+{
+	kfree(ghid->inbuf);
+	ghid->inbuf = NULL;
+	ghid->bufsize = 0;
+}
+
+static int gb_hid_alloc_buffers(struct gb_hid *ghid, size_t bufsize)
+{
+	ghid->inbuf = kzalloc(bufsize, GFP_KERNEL);
+	if (!ghid->inbuf)
+		return -ENOMEM;
+
+	ghid->bufsize = bufsize;
+
+	return 0;
+}
+
+/* Routines dealing with reports */
+static void gb_hid_init_report(struct gb_hid *ghid, struct hid_report *report)
+{
+	unsigned int size;
+
+	size = gb_hid_report_len(report);
+	if (gb_hid_get_report(ghid, report->type, report->id, ghid->inbuf,
+			      size))
+		return;
+
+	/*
+	 * hid->driver_lock is held as we are in probe function,
+	 * we just need to setup the input fields, so using
+	 * hid_report_raw_event is safe.
+	 */
+	hid_report_raw_event(ghid->hid, report->type, ghid->inbuf, size, 1);
+}
+
+static void gb_hid_init_reports(struct gb_hid *ghid)
+{
+	struct hid_device *hid = ghid->hid;
+	struct hid_report *report;
+
+	list_for_each_entry(report,
+		&hid->report_enum[HID_INPUT_REPORT].report_list, list)
+		gb_hid_init_report(ghid, report);
+
+	list_for_each_entry(report,
+		&hid->report_enum[HID_FEATURE_REPORT].report_list, list)
+		gb_hid_init_report(ghid, report);
+}
+
+static int __gb_hid_get_raw_report(struct hid_device *hid,
+		unsigned char report_number, __u8 *buf, size_t count,
+		unsigned char report_type)
+{
+	struct gb_hid *ghid = hid->driver_data;
+	int ret;
+
+	if (report_type == HID_OUTPUT_REPORT)
+		return -EINVAL;
+
+	ret = gb_hid_get_report(ghid, report_type, report_number, buf, count);
+	if (!ret)
+		ret = count;
+
+	return ret;
+}
+
+static int __gb_hid_output_raw_report(struct hid_device *hid, __u8 *buf,
+				      size_t len, unsigned char report_type,
+				      bool raw)
+{
+	struct gb_hid *ghid = hid->driver_data;
+	int report_id = buf[0];
+	int ret;
+
+	if (report_type == HID_INPUT_REPORT)
+		return -EINVAL;
+
+	if (report_id) {
+		buf++;
+		len--;
+	}
+
+	ret = gb_hid_set_report(ghid, report_type, report_id, buf, len, raw);
+	if (report_id && ret >= 0)
+		ret++; /* add report_id to the number of transfered bytes */
+
+	return 0;
+}
+
+static int gb_hid_raw_request(struct hid_device *hid, unsigned char reportnum,
+			       __u8 *buf, size_t len, unsigned char rtype,
+			       int reqtype)
+{
+	switch (reqtype) {
+	case HID_REQ_GET_REPORT:
+		return __gb_hid_get_raw_report(hid, reportnum, buf, len, rtype);
+	case HID_REQ_SET_REPORT:
+		if (buf[0] != reportnum)
+			return -EINVAL;
+		return __gb_hid_output_raw_report(hid, buf, len, rtype, true);
+	default:
+		return -EIO;
+	}
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,15,0)
+static int gb_hid_output_report(struct hid_device *hid, __u8 *buf, size_t len)
+{
+	return __gb_hid_output_raw_report(hid, buf, len, HID_OUTPUT_REPORT,
+					  false);
+}
+
+#else
+
+static int gb_hid_get_raw_report(struct hid_device *hid,
+				   unsigned char reportnum, __u8 *buf,
+				   size_t len, unsigned char rtype)
+{
+	return gb_hid_raw_request(hid, reportnum, buf, len, rtype,
+				  HID_REQ_GET_REPORT);
+}
+
+static int gb_hid_output_raw_report(struct hid_device *hid, __u8 *buf,
+				    size_t len, unsigned char rtype)
+{
+	return gb_hid_raw_request(hid, buf[0], buf, len, rtype,
+				  HID_REQ_SET_REPORT);
+}
+#endif
+
+/* HID Callbacks */
+static int gb_hid_parse(struct hid_device *hid)
+{
+	struct gb_hid *ghid = hid->driver_data;
+	unsigned int rsize;
+	char *rdesc;
+	int ret;
+
+	rsize = le16_to_cpu(ghid->hdesc.wReportDescLength);
+	if (!rsize || rsize > HID_MAX_DESCRIPTOR_SIZE) {
+		dbg_hid("weird size of report descriptor (%u)\n", rsize);
+		return -EINVAL;
+	}
+
+	rdesc = kzalloc(rsize, GFP_KERNEL);
+	if (!rdesc) {
+		dbg_hid("couldn't allocate rdesc memory\n");
+		return -ENOMEM;
+	}
+
+	ret = gb_hid_get_report_desc(ghid, rdesc);
+	if (ret) {
+		hid_err(hid, "reading report descriptor failed\n");
+		goto free_rdesc;
+	}
+
+	ret = hid_parse_report(hid, rdesc, rsize);
+	if (ret)
+		dbg_hid("parsing report descriptor failed\n");
+
+free_rdesc:
+	kfree(rdesc);
+
+	return ret;
+}
+
+static int gb_hid_start(struct hid_device *hid)
+{
+	struct gb_hid *ghid = hid->driver_data;
+	unsigned int bufsize = HID_MIN_BUFFER_SIZE;
+	int ret;
+
+	gb_hid_find_max_report(hid, HID_INPUT_REPORT, &bufsize);
+	gb_hid_find_max_report(hid, HID_OUTPUT_REPORT, &bufsize);
+	gb_hid_find_max_report(hid, HID_FEATURE_REPORT, &bufsize);
+
+	if (bufsize > HID_MAX_BUFFER_SIZE)
+		bufsize = HID_MAX_BUFFER_SIZE;
+
+	ret = gb_hid_alloc_buffers(ghid, bufsize);
+	if (ret)
+		return ret;
+
+	if (!(hid->quirks & HID_QUIRK_NO_INIT_REPORTS))
+		gb_hid_init_reports(ghid);
+
+	return 0;
+}
+
+static void gb_hid_stop(struct hid_device *hid)
+{
+	struct gb_hid *ghid = hid->driver_data;
+
+	gb_hid_free_buffers(ghid);
+}
+
+static int gb_hid_open(struct hid_device *hid)
+{
+	struct gb_hid *ghid = hid->driver_data;
+	int ret = 0;
+
+	mutex_lock(&gb_hid_open_mutex);
+	if (!hid->open++) {
+		ret = gb_hid_set_power(ghid, GB_HID_TYPE_PWR_ON);
+		if (ret < 0)
+			hid->open--;
+		else
+			set_bit(GB_HID_STARTED, &ghid->flags);
+	}
+	mutex_unlock(&gb_hid_open_mutex);
+
+	return ret;
+}
+
+static void gb_hid_close(struct hid_device *hid)
+{
+	struct gb_hid *ghid = hid->driver_data;
+
+	/*
+	 * Protecting hid->open to make sure we don't restart data acquistion
+	 * due to a resumption we no longer care about..
+	 */
+	mutex_lock(&gb_hid_open_mutex);
+	if (!--hid->open) {
+		clear_bit(GB_HID_STARTED, &ghid->flags);
+
+		/* Save some power */
+		WARN_ON(gb_hid_set_power(ghid, GB_HID_TYPE_PWR_OFF));
+	}
+	mutex_unlock(&gb_hid_open_mutex);
+}
+
+static int gb_hid_power(struct hid_device *hid, int lvl)
+{
+	struct gb_hid *ghid = hid->driver_data;
+
+	switch (lvl) {
+	case PM_HINT_FULLON:
+		return gb_hid_set_power(ghid, GB_HID_TYPE_PWR_ON);
+	case PM_HINT_NORMAL:
+		return gb_hid_set_power(ghid, GB_HID_TYPE_PWR_OFF);
+	}
+
+	return 0;
+}
+
+/* HID structure to pass callbacks */
+static struct hid_ll_driver gb_hid_ll_driver = {
+	.parse = gb_hid_parse,
+	.start = gb_hid_start,
+	.stop = gb_hid_stop,
+	.open = gb_hid_open,
+	.close = gb_hid_close,
+	.power = gb_hid_power,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,15,0)
+	.output_report = gb_hid_output_report,
+	.raw_request = gb_hid_raw_request,
+#endif
+};
+
+static int gb_hid_init(struct gb_hid *ghid)
+{
+	struct hid_device *hid = ghid->hid;
+	int ret;
+
+	ret = get_version(ghid);
+	if (ret)
+		return ret;
+
+	ret = gb_hid_get_desc(ghid);
+	if (ret)
+		return ret;
+
+	hid->version = le16_to_cpu(ghid->hdesc.bcdHID);
+	hid->vendor = le16_to_cpu(ghid->hdesc.wVendorID);
+	hid->product = le16_to_cpu(ghid->hdesc.wProductID);
+	hid->country = ghid->hdesc.bCountryCode;
+
+	hid->driver_data = ghid;
+	hid->ll_driver = &gb_hid_ll_driver;
+	hid->dev.parent = &ghid->connection->dev;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,15,0)
+	hid->hid_get_raw_report = gb_hid_get_raw_report;
+	hid->hid_output_raw_report = gb_hid_output_raw_report;
+#endif
+//	hid->bus = BUS_GREYBUS; /* Need a bustype for GREYBUS in <linux/input.h> */
+
+	/* Set HID device's name */
+	snprintf(hid->name, sizeof(hid->name), "%s %04hX:%04hX",
+		 dev_name(&ghid->connection->dev), hid->vendor, hid->product);
+
+	return 0;
+}
+
+static int gb_hid_connection_init(struct gb_connection *connection)
+{
+	struct hid_device *hid;
+	struct gb_hid *ghid;
+	int ret;
+
+	ghid = kzalloc(sizeof(*ghid), GFP_KERNEL);
+	if (!ghid)
+		return -ENOMEM;
+
+	hid = hid_allocate_device();
+	if (IS_ERR(hid)) {
+		ret = PTR_ERR(hid);
+		goto free_ghid;
+	}
+
+	connection->private = ghid;
+	ghid->connection = connection;
+	ghid->hid = hid;
+
+	ret = gb_hid_init(ghid);
+	if (ret)
+		goto destroy_hid;
+
+	ret = hid_add_device(hid);
+	if (!ret)
+		return 0;
+
+	hid_err(hid, "can't add hid device: %d\n", ret);
+
+destroy_hid:
+	hid_destroy_device(hid);
+free_ghid:
+	kfree(ghid);
+
+	return ret;
+}
+
+static void gb_hid_connection_exit(struct gb_connection *connection)
+{
+	struct gb_hid *ghid = connection->private;
+
+	hid_destroy_device(ghid->hid);
+	kfree(ghid);
+}
+
+static struct gb_protocol hid_protocol = {
+	.name			= "hid",
+	.id			= GREYBUS_PROTOCOL_HID,
+	.major			= 0,
+	.minor			= 1,
+	.connection_init	= gb_hid_connection_init,
+	.connection_exit	= gb_hid_connection_exit,
+	.request_recv		= gb_hid_irq_handler,
+};
+
+int gb_hid_protocol_init(void)
+{
+	return gb_protocol_register(&hid_protocol);
+}
+
+void gb_hid_protocol_exit(void)
+{
+	gb_protocol_deregister(&hid_protocol);
+}
