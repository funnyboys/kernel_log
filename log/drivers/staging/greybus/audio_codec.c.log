commit faeeeea89670b39c7afa2cc567c3917c511608c4
Author: zhong jiang <zhongjiang@huawei.com>
Date:   Wed Sep 12 11:40:28 2018 +0800

    staging: remove unneeded static set .owner field in platform_driver
    
    platform_driver_register will set the .owner field. So it is safe
    to remove the redundant assignment.
    
    The issue is detected with the help of Coccinelle.
    
    Signed-off-by: zhong jiang <zhongjiang@huawei.com>
    Acked-by: Vaibhav Agarwal <vaibhav.sr@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/audio_codec.c b/drivers/staging/greybus/audio_codec.c
index 35acd55ca5ab..08746c85dea6 100644
--- a/drivers/staging/greybus/audio_codec.c
+++ b/drivers/staging/greybus/audio_codec.c
@@ -1087,7 +1087,6 @@ static const struct of_device_id greybus_asoc_machine_of_match[]  = {
 static struct platform_driver gbaudio_codec_driver = {
 	.driver = {
 		.name = "apb-dummy-codec",
-		.owner = THIS_MODULE,
 #ifdef CONFIG_PM
 		.pm = &gbaudio_codec_pm_ops,
 #endif

commit 6236015fd2f1b2767b72efe95a1fc3d5a590f092
Author: Kamal Heib <kamalheib1@gmail.com>
Date:   Wed Jan 17 16:52:29 2018 +0200

    staging: greybus: audio_codec.c: Prefer kernel type 'u32' over 'uint32_t'
    
    Fix the following errors found by checkpatch.pl:
    CHECK: Prefer kernel type 'u32' over 'uint32_t'
    
    Signed-off-by: Kamal Heib <kamalheib1@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/audio_codec.c b/drivers/staging/greybus/audio_codec.c
index fa16a893449f..35acd55ca5ab 100644
--- a/drivers/staging/greybus/audio_codec.c
+++ b/drivers/staging/greybus/audio_codec.c
@@ -47,7 +47,7 @@ static int gbaudio_module_enable_tx(struct gbaudio_codec_info *codec,
 	int module_state, ret = 0;
 	u16 data_cport, i2s_port, cportid;
 	u8 sig_bits, channels;
-	uint32_t format, rate;
+	u32 format, rate;
 	struct gbaudio_data_connection *data;
 	struct gbaudio_stream_params *params;
 
@@ -182,7 +182,7 @@ static int gbaudio_module_enable_rx(struct gbaudio_codec_info *codec,
 	int module_state, ret = 0;
 	u16 data_cport, i2s_port, cportid;
 	u8 sig_bits, channels;
-	uint32_t format, rate;
+	u32 format, rate;
 	struct gbaudio_data_connection *data;
 	struct gbaudio_stream_params *params;
 
@@ -412,7 +412,7 @@ static int gbcodec_hw_params(struct snd_pcm_substream *substream,
 {
 	int ret;
 	u8 sig_bits, channels;
-	uint32_t format, rate;
+	u32 format, rate;
 	struct gbaudio_module_info *module;
 	struct gbaudio_data_connection *data;
 	struct gb_bundle *bundle;

commit 6a4dd600eb2f289422a366d2fcf1dc0dd974c71b
Author: Kamal Heib <kamalheib1@gmail.com>
Date:   Wed Jan 17 16:52:28 2018 +0200

    staging: greybus: audio_codec.c: Logical continuations should be on the previous line
    
    Fix the following error found by checkpatch.pl:
    CHECK: Logical continuations should be on the previous line
    
    Signed-off-by: Kamal Heib <kamalheib1@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/audio_codec.c b/drivers/staging/greybus/audio_codec.c
index 6b920113b918..fa16a893449f 100644
--- a/drivers/staging/greybus/audio_codec.c
+++ b/drivers/staging/greybus/audio_codec.c
@@ -841,8 +841,8 @@ int gbaudio_register_module(struct gbaudio_module_info *module)
 		 * from codec->jack_list
 		 */
 		list_for_each_entry(jack, &codec->jack_list, list) {
-			if ((jack == &module->headset_jack)
-			    || (jack == &module->button_jack))
+			if ((jack == &module->headset_jack) ||
+			    (jack == &module->button_jack))
 				snd_device_register(codec->card->snd_card,
 						    jack->jack);
 		}

commit 0c3ba27becd8f6264bbe98d1f1747385749e496c
Author: Kamal Heib <kamalheib1@gmail.com>
Date:   Wed Jan 17 16:52:27 2018 +0200

    staging: greybus: audio_codec.c: Space required around ':'
    
    Space is required when using the question mark operator around ':'
    
    Signed-off-by: Kamal Heib <kamalheib1@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/audio_codec.c b/drivers/staging/greybus/audio_codec.c
index 98ddb7e5b78b..6b920113b918 100644
--- a/drivers/staging/greybus/audio_codec.c
+++ b/drivers/staging/greybus/audio_codec.c
@@ -319,7 +319,7 @@ int gbaudio_module_update(struct gbaudio_codec_info *codec,
 	char intf_name[NAME_SIZE], dir[NAME_SIZE];
 
 	dev_dbg(module->dev, "%s:Module update %s sequence\n", w->name,
-		enable ? "Enable":"Disable");
+		enable ? "Enable" : "Disable");
 
 	if ((w->id != snd_soc_dapm_aif_in) && (w->id != snd_soc_dapm_aif_out)) {
 		dev_dbg(codec->dev, "No action required for %s\n", w->name);
@@ -588,7 +588,7 @@ static int gbcodec_mute_stream(struct snd_soc_dai *dai, int mute, int stream)
 	struct gbaudio_stream_params *params;
 
 	dev_dbg(dai->dev, "Mute:%d, Direction:%s\n", mute,
-		stream ? "CAPTURE":"PLAYBACK");
+		stream ? "CAPTURE" : "PLAYBACK");
 
 	mutex_lock(&codec->lock);
 

commit 15f24ca42b560d14c7e9924d953985ddb728a8cd
Author: Kamal Heib <kamalheib1@gmail.com>
Date:   Wed Jan 17 16:52:26 2018 +0200

    staging: greybus: audio_codec.c: Cleanup blank lines
    
    Remove the blank lines.
    
    Signed-off-by: Kamal Heib <kamalheib1@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/audio_codec.c b/drivers/staging/greybus/audio_codec.c
index c4b6584eb1be..98ddb7e5b78b 100644
--- a/drivers/staging/greybus/audio_codec.c
+++ b/drivers/staging/greybus/audio_codec.c
@@ -587,7 +587,6 @@ static int gbcodec_mute_stream(struct snd_soc_dai *dai, int mute, int stream)
 	struct gbaudio_codec_info *codec = dev_get_drvdata(dai->dev);
 	struct gbaudio_stream_params *params;
 
-
 	dev_dbg(dai->dev, "Mute:%d, Direction:%s\n", mute,
 		stream ? "CAPTURE":"PLAYBACK");
 
@@ -907,7 +906,6 @@ static void gbaudio_codec_clean_data_rx(struct gbaudio_data_connection *data)
 	data->state[1] = GBAUDIO_CODEC_SHUTDOWN;
 }
 
-
 static void gbaudio_codec_cleanup(struct gbaudio_module_info *module)
 {
 	struct gbaudio_data_connection *data;
@@ -923,7 +921,6 @@ static void gbaudio_codec_cleanup(struct gbaudio_module_info *module)
 
 		if (cap_state > GBAUDIO_CODEC_SHUTDOWN)
 			gbaudio_codec_clean_data_rx(data);
-
 	}
 }
 

commit c688bd9adca36fabde52f8ac0e6b99a02953fc8b
Author: Kamal Heib <kamalheib1@gmail.com>
Date:   Wed Jan 17 16:52:25 2018 +0200

    staging: greybus: audio_codec.c: Fix alignment should match open parenthesis
    
    Cleanup "Alignment should match open parenthesis" checkpatch.pl errors.
    
    Signed-off-by: Kamal Heib <kamalheib1@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/audio_codec.c b/drivers/staging/greybus/audio_codec.c
index fdb9e83cc34b..c4b6584eb1be 100644
--- a/drivers/staging/greybus/audio_codec.c
+++ b/drivers/staging/greybus/audio_codec.c
@@ -567,7 +567,7 @@ static int gbcodec_prepare(struct snd_pcm_substream *substream,
 	if (ret) {
 		mutex_unlock(&codec->lock);
 		dev_err_ratelimited(dai->dev, "set_data_size failed:%d\n",
-				     ret);
+				    ret);
 		return ret;
 	}
 
@@ -827,7 +827,7 @@ int gbaudio_register_module(struct gbaudio_module_info *module)
 					  module->num_dapm_widgets);
 	if (module->controls)
 		snd_soc_add_codec_controls(codec, module->controls,
-				     module->num_controls);
+					   module->num_controls);
 	if (module->dapm_routes)
 		snd_soc_dapm_add_routes(&codec->dapm, module->dapm_routes,
 					module->num_dapm_routes);
@@ -972,7 +972,7 @@ void gbaudio_unregister_module(struct gbaudio_module_info *module)
 		dev_dbg(codec->dev, "Removing %d controls\n",
 			module->num_controls);
 		snd_soc_remove_codec_controls(codec, module->controls,
-					  module->num_controls);
+					      module->num_controls);
 	}
 	if (module->dapm_widgets) {
 		dev_dbg(codec->dev, "Removing %d widgets\n",

commit 863dbc52e7f0e5acd7b4883f3933543a81c474c7
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Nov 7 14:58:42 2017 +0100

    staging: greybus: Remove redundant license text
    
    Now that the SPDX tag is in all greybus files, that identifies the
    license in a specific and legally-defined manner.  So the extra GPL text
    wording can be removed as it is no longer needed at all.
    
    This is done on a quest to remove the 700+ different ways that files in
    the kernel describe the GPL license text.  And there's unneeded stuff
    like the address (sometimes incorrect) for the FSF which is never
    needed.
    
    No copyright headers or other non-license-description text was removed.
    
    Cc: Vaibhav Hiremath <hvaibhav.linux@gmail.com>
    Reviewed-by: Alex Elder <elder@linaro.org>
    Acked-by: Vaibhav Agarwal <vaibhav.sr@gmail.com>
    Acked-by: David Lin <dtwlin@gmail.com>
    Acked-by: Johan Hovold <johan@kernel.org>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Acked-by: Mark Greer <mgreer@animalcreek.com>
    Acked-by: Rui Miguel Silva <rmfrfs@gmail.com>
    Acked-by: "Bryan O'Donoghue" <pure.logic@nexus-software.ie>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/audio_codec.c b/drivers/staging/greybus/audio_codec.c
index 813a3636fb52..fdb9e83cc34b 100644
--- a/drivers/staging/greybus/audio_codec.c
+++ b/drivers/staging/greybus/audio_codec.c
@@ -3,8 +3,6 @@
  * APBridge ALSA SoC dummy codec driver
  * Copyright 2016 Google Inc.
  * Copyright 2016 Linaro Ltd.
- *
- * Released under the GPLv2 only.
  */
 #include <linux/kernel.h>
 #include <linux/module.h>

commit eb50fd3a22c770f36be275295b782f3ea52e3215
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Nov 7 14:58:41 2017 +0100

    staging: greybus: add SPDX identifiers to all greybus driver files
    
    It's good to have SPDX identifiers in all files to make it easier to
    audit the kernel tree for correct licenses.
    
    Update the drivers/staging/greybus files files with the correct SPDX
    license identifier based on the license text in the file itself.  The
    SPDX identifier is a legally binding shorthand, which can be used
    instead of the full boiler plate text.
    
    This work is based on a script and data from Thomas Gleixner, Philippe
    Ombredanne, and Kate Stewart.
    
    Cc: Vaibhav Hiremath <hvaibhav.linux@gmail.com>
    Cc: "Bryan O'Donoghue" <pure.logic@nexus-software.ie>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: Philippe Ombredanne <pombredanne@nexb.com>
    Acked-by: Vaibhav Agarwal <vaibhav.sr@gmail.com>
    Acked-by: David Lin <dtwlin@gmail.com>
    Reviewed-by: Alex Elder <elder@linaro.org>
    Acked-by: Johan Hovold <johan@kernel.org>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Acked-by: Mark Greer <mgreer@animalcreek.com>
    Acked-by: Rui Miguel Silva <rmfrfs@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/audio_codec.c b/drivers/staging/greybus/audio_codec.c
index a6d01f0761f3..813a3636fb52 100644
--- a/drivers/staging/greybus/audio_codec.c
+++ b/drivers/staging/greybus/audio_codec.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * APBridge ALSA SoC dummy codec driver
  * Copyright 2016 Google Inc.

commit ccc5d98ae06a6da39c68db2338ce7902765b79f9
Author: Arvind Yadav <arvind.yadav.cs@gmail.com>
Date:   Mon Aug 21 10:28:24 2017 +0530

    staging: greybus: audio: constify snd_soc_dai_ops structures
    
    snd_soc_dai_ops are not supposed to change at runtime. All functions
    working with snd_soc_dai_ops provided by <sound/soc-dai.h> work with
    const snd_soc_dai_ops. So mark the non-const structs as const.
    
    Signed-off-by: Arvind Yadav <arvind.yadav.cs@gmail.com>
    Acked-by: Mark Greer <mgreer@animalcreek.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/audio_codec.c b/drivers/staging/greybus/audio_codec.c
index 25c8bb4cb0de..a6d01f0761f3 100644
--- a/drivers/staging/greybus/audio_codec.c
+++ b/drivers/staging/greybus/audio_codec.c
@@ -674,7 +674,7 @@ static int gbcodec_mute_stream(struct snd_soc_dai *dai, int mute, int stream)
 	return ret;
 }
 
-static struct snd_soc_dai_ops gbcodec_dai_ops = {
+static const struct snd_soc_dai_ops gbcodec_dai_ops = {
 	.startup = gbcodec_startup,
 	.shutdown = gbcodec_shutdown,
 	.hw_params = gbcodec_hw_params,

commit 461ab8077d573d4a35529572c774a71e5a898a84
Author: Gioh Kim <gi-oh.kim@profitbricks.com>
Date:   Thu Feb 9 17:30:11 2017 +0100

    staging: greybus: fix "line over 80 characters" coding style issues
    
    This patch fixes only obvious lines.
    There are still more issues.
    
    Signed-off-by: Gioh Kim <gi-oh.kim@profitbricks.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/audio_codec.c b/drivers/staging/greybus/audio_codec.c
index 30941f9e380d..25c8bb4cb0de 100644
--- a/drivers/staging/greybus/audio_codec.c
+++ b/drivers/staging/greybus/audio_codec.c
@@ -838,7 +838,10 @@ int gbaudio_register_module(struct gbaudio_module_info *module)
 		snd_soc_dapm_link_component_dai_widgets(codec->card,
 							&codec->dapm);
 #ifdef CONFIG_SND_JACK
-		/* register jack devices for this module from codec->jack_list */
+		/*
+		 * register jack devices for this module
+		 * from codec->jack_list
+		 */
 		list_for_each_entry(jack, &codec->jack_list, list) {
 			if ((jack == &module->headset_jack)
 			    || (jack == &module->button_jack))

commit 96249da9ce2f33e16eb6b2ef812ea590d734057d
Author: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
Date:   Wed Jan 18 22:51:52 2017 +0530

    staging: greybus: audio: Cleanup junk codec registers
    
    Dummy codec register were initially added while populating dummy codec
    mixer controls until module topology parser was available. Now, these
    dummy registers are nowhere used and thus can be safely removed.
    
    Since ASoC framework requires a valid callback for both read & write
    register APIS, currently empty placeholders are kept to avoid panic.
    
    Later, register mapping logic can be defined:
    1. Assuming fixed number of maximum modules connected and register bits
    corresponds to basic info of each module OR
    2. With a logic to dynamically grow register_cache_size based on codec
    modules added/removed.
    
    Signed-off-by: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
    Signed-off-by: Vaibhav Agarwal <vaibhav.sr@gmail.com>
    Acked-by: Mark Greer <mgreer@animalcreek.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/audio_codec.c b/drivers/staging/greybus/audio_codec.c
index b9d66278ff87..30941f9e380d 100644
--- a/drivers/staging/greybus/audio_codec.c
+++ b/drivers/staging/greybus/audio_codec.c
@@ -1026,47 +1026,16 @@ static int gbcodec_remove(struct snd_soc_codec *codec)
 	return 0;
 }
 
-static u8 gbcodec_reg[GBCODEC_REG_COUNT] = {
-	[GBCODEC_CTL_REG] = GBCODEC_CTL_REG_DEFAULT,
-	[GBCODEC_MUTE_REG] = GBCODEC_MUTE_REG_DEFAULT,
-	[GBCODEC_PB_LVOL_REG] = GBCODEC_PB_VOL_REG_DEFAULT,
-	[GBCODEC_PB_RVOL_REG] = GBCODEC_PB_VOL_REG_DEFAULT,
-	[GBCODEC_CAP_LVOL_REG] = GBCODEC_CAP_VOL_REG_DEFAULT,
-	[GBCODEC_CAP_RVOL_REG] = GBCODEC_CAP_VOL_REG_DEFAULT,
-	[GBCODEC_APB1_MUX_REG] = GBCODEC_APB1_MUX_REG_DEFAULT,
-	[GBCODEC_APB2_MUX_REG] = GBCODEC_APB2_MUX_REG_DEFAULT,
-};
-
 static int gbcodec_write(struct snd_soc_codec *codec, unsigned int reg,
 			 unsigned int value)
 {
-	int ret = 0;
-
-	if (reg == SND_SOC_NOPM)
-		return 0;
-
-	BUG_ON(reg >= GBCODEC_REG_COUNT);
-
-	gbcodec_reg[reg] = value;
-	dev_dbg(codec->dev, "reg[%d] = 0x%x\n", reg, value);
-
-	return ret;
+	return 0;
 }
 
 static unsigned int gbcodec_read(struct snd_soc_codec *codec,
 				 unsigned int reg)
 {
-	unsigned int val = 0;
-
-	if (reg == SND_SOC_NOPM)
-		return 0;
-
-	BUG_ON(reg >= GBCODEC_REG_COUNT);
-
-	val = gbcodec_reg[reg];
-	dev_dbg(codec->dev, "reg[%d] = 0x%x\n", reg, val);
-
-	return val;
+	return 0;
 }
 
 static struct snd_soc_codec_driver soc_codec_dev_gbaudio = {
@@ -1076,10 +1045,6 @@ static struct snd_soc_codec_driver soc_codec_dev_gbaudio = {
 	.read = gbcodec_read,
 	.write = gbcodec_write,
 
-	.reg_cache_size = GBCODEC_REG_COUNT,
-	.reg_cache_default = gbcodec_reg_defaults,
-	.reg_word_size = 1,
-
 	.idle_bias_off = true,
 	.ignore_pmdown_time = 1,
 };

commit 1023ab9c3800e58581b546b510e6d3d813535bce
Author: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
Date:   Wed Jan 18 22:51:51 2017 +0530

    staging: greybus: audio: Initialize sig_bits before configuring hwparams
    
    Uninitialized variable sig_bits was used while configuring stream params
    for codec module. These params are used to configure PCM settings for
    APBridgeA.
    
    Usually, this is dependent on codec capability and thus populated via
    codec dai_driver definition. In our case, it is fixed to 16 based on the
    data format, container supported.
    
    Signed-off-by: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
    Signed-off-by: Vaibhav Agarwal <vaibhav.sr@gmail.com>
    Acked-by: Mark Greer <mgreer@animalcreek.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/audio_codec.c b/drivers/staging/greybus/audio_codec.c
index f8862c6d7102..b9d66278ff87 100644
--- a/drivers/staging/greybus/audio_codec.c
+++ b/drivers/staging/greybus/audio_codec.c
@@ -496,6 +496,11 @@ static int gbcodec_hw_params(struct snd_pcm_substream *substream,
 
 	gb_pm_runtime_put_noidle(bundle);
 
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		sig_bits = dai->driver->playback.sig_bits;
+	else
+		sig_bits = dai->driver->capture.sig_bits;
+
 	params->state = GBAUDIO_CODEC_HWPARAMS;
 	params->format = format;
 	params->rate = rate;
@@ -689,6 +694,7 @@ static struct snd_soc_dai_driver gbaudio_dai[] = {
 			.rate_min = 48000,
 			.channels_min = 1,
 			.channels_max = 2,
+			.sig_bits = 16,
 		},
 		.capture = {
 			.stream_name = "I2S 0 Capture",
@@ -698,6 +704,7 @@ static struct snd_soc_dai_driver gbaudio_dai[] = {
 			.rate_min = 48000,
 			.channels_min = 1,
 			.channels_max = 2,
+			.sig_bits = 16,
 		},
 		.ops = &gbcodec_dai_ops,
 	},

commit 3f98afe0b6d6d8d7a72461f9b13da122fe08d20e
Author: Elise Lennion <elise.lennion@gmail.com>
Date:   Thu Oct 13 19:40:04 2016 -0300

    staging: greybus: audio_codec: Remove useless return statement.
    
    Remove return statement that is immediately followed by the function
    closing bracket.
    
    Signed-off-by: Elise Lennion <elise.lennion@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/audio_codec.c b/drivers/staging/greybus/audio_codec.c
index 1bdf84925d22..f8862c6d7102 100644
--- a/drivers/staging/greybus/audio_codec.c
+++ b/drivers/staging/greybus/audio_codec.c
@@ -405,7 +405,6 @@ static void gbcodec_shutdown(struct snd_pcm_substream *substream,
 	params->state = GBAUDIO_CODEC_SHUTDOWN;
 	mutex_unlock(&codec->lock);
 	pm_relax(dai->dev);
-	return;
 }
 
 static int gbcodec_hw_params(struct snd_pcm_substream *substream,

commit 9ae7a47f7f3226c3782418e63f833f8b298266af
Author: Chase Metzger <chasemetzger15@gmail.com>
Date:   Sun Oct 9 15:26:33 2016 -0700

    drivers: staging: greybus: audio_codec.c: Fixed CHECKS for brace issues
    
    Added braces to else statement where checkpatch complained.
    
    Signed-off-by: Chase Metzger <chasemetzger15@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/audio_codec.c b/drivers/staging/greybus/audio_codec.c
index 8a0744b58a32..1bdf84925d22 100644
--- a/drivers/staging/greybus/audio_codec.c
+++ b/drivers/staging/greybus/audio_codec.c
@@ -655,8 +655,10 @@ static int gbcodec_mute_stream(struct snd_soc_dai *dai, int mute, int stream)
 			ret = gb_audio_apbridgea_shutdown_rx(data->connection,
 							     0);
 		params->state = GBAUDIO_CODEC_STOP;
-	} else
+	} else {
 		ret = -EINVAL;
+	}
+
 	if (ret)
 		dev_err_ratelimited(dai->dev,
 				    "%s:Error during %s %s stream:%d\n",

commit 33111574550b210f4841591a3938283ffdf91d01
Author: Richard Groux <rgroux@sauron-mordor.net>
Date:   Wed Sep 21 19:05:31 2016 +0200

    staging: greybus: audio_codec.c: code indent should use tabs where possible
    
    Minor error spotted by checkpatch.pl in greybus
    code indent should use tabs where possible
    
    Signed-off-by: Richard Groux <rgroux@sauron-mordor.net>
    Reviewed-by: Alex Elder <elder@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/audio_codec.c b/drivers/staging/greybus/audio_codec.c
index 0e8e4e96252f..8a0744b58a32 100644
--- a/drivers/staging/greybus/audio_codec.c
+++ b/drivers/staging/greybus/audio_codec.c
@@ -1008,7 +1008,7 @@ static int gbcodec_probe(struct snd_soc_codec *codec)
 	snd_soc_codec_set_drvdata(codec, info);
 	gbcodec = info;
 
-        device_init_wakeup(codec->dev, 1);
+	device_init_wakeup(codec->dev, 1);
 	return 0;
 }
 

commit 0c8d9c73e6c99efdd5f76e5cbfb90e553130e729
Author: Richard Groux <rgroux@sauron-mordor.net>
Date:   Wed Sep 21 19:05:29 2016 +0200

    staging: greybus: audio_codec.c: space required before the open brace
    
    Minor error spotted by checkpatch.pl in greybus
    space required before the open brace '{'
    
    Signed-off-by: Richard Groux <rgroux@sauron-mordor.net>
    Reviewed-by: Alex Elder <elder@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/audio_codec.c b/drivers/staging/greybus/audio_codec.c
index 5ce2542a2fa0..0e8e4e96252f 100644
--- a/drivers/staging/greybus/audio_codec.c
+++ b/drivers/staging/greybus/audio_codec.c
@@ -322,7 +322,7 @@ int gbaudio_module_update(struct gbaudio_codec_info *codec,
 	dev_dbg(module->dev, "%s:Module update %s sequence\n", w->name,
 		enable ? "Enable":"Disable");
 
-	if ((w->id != snd_soc_dapm_aif_in) && (w->id != snd_soc_dapm_aif_out)){
+	if ((w->id != snd_soc_dapm_aif_in) && (w->id != snd_soc_dapm_aif_out)) {
 		dev_dbg(codec->dev, "No action required for %s\n", w->name);
 		return 0;
 	}

commit 79cb2b26f54e8831342f3598393bb894e15c01f6
Author: Chaehyun Lim <chaehyun.lim@gmail.com>
Date:   Tue Sep 20 09:47:30 2016 +0900

    staging: greybus: use preferred kernel type u16
    
    As suggested by checkpatch.pl:
    
    CHECK: Prefer kernel type 'u16' over 'uint16_t'
    
    Signed-off-by: Chaehyun Lim <chaehyun.lim@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/audio_codec.c b/drivers/staging/greybus/audio_codec.c
index c9e198957f07..5ce2542a2fa0 100644
--- a/drivers/staging/greybus/audio_codec.c
+++ b/drivers/staging/greybus/audio_codec.c
@@ -46,7 +46,7 @@ static int gbaudio_module_enable_tx(struct gbaudio_codec_info *codec,
 				    struct gbaudio_module_info *module, int id)
 {
 	int module_state, ret = 0;
-	uint16_t data_cport, i2s_port, cportid;
+	u16 data_cport, i2s_port, cportid;
 	u8 sig_bits, channels;
 	uint32_t format, rate;
 	struct gbaudio_data_connection *data;
@@ -131,7 +131,7 @@ static int gbaudio_module_enable_tx(struct gbaudio_codec_info *codec,
 static int gbaudio_module_disable_tx(struct gbaudio_module_info *module, int id)
 {
 	int ret;
-	uint16_t data_cport, cportid, i2s_port;
+	u16 data_cport, cportid, i2s_port;
 	int module_state;
 	struct gbaudio_data_connection *data;
 
@@ -181,7 +181,7 @@ static int gbaudio_module_enable_rx(struct gbaudio_codec_info *codec,
 				    struct gbaudio_module_info *module, int id)
 {
 	int module_state, ret = 0;
-	uint16_t data_cport, i2s_port, cportid;
+	u16 data_cport, i2s_port, cportid;
 	u8 sig_bits, channels;
 	uint32_t format, rate;
 	struct gbaudio_data_connection *data;
@@ -266,7 +266,7 @@ static int gbaudio_module_enable_rx(struct gbaudio_codec_info *codec,
 static int gbaudio_module_disable_rx(struct gbaudio_module_info *module, int id)
 {
 	int ret;
-	uint16_t data_cport, cportid, i2s_port;
+	u16 data_cport, cportid, i2s_port;
 	int module_state;
 	struct gbaudio_data_connection *data;
 
@@ -855,7 +855,7 @@ EXPORT_SYMBOL(gbaudio_register_module);
 
 static void gbaudio_codec_clean_data_tx(struct gbaudio_data_connection *data)
 {
-	uint16_t i2s_port, cportid;
+	u16 i2s_port, cportid;
 	int ret;
 
 	if (list_is_singular(&gbcodec->module_list)) {
@@ -877,7 +877,7 @@ static void gbaudio_codec_clean_data_tx(struct gbaudio_data_connection *data)
 
 static void gbaudio_codec_clean_data_rx(struct gbaudio_data_connection *data)
 {
-	uint16_t i2s_port, cportid;
+	u16 i2s_port, cportid;
 	int ret;
 
 	if (list_is_singular(&gbcodec->module_list)) {

commit 31959392c7db09c13af07dcdc409d306aaa03d4f
Author: Chaehyun Lim <chaehyun.lim@gmail.com>
Date:   Tue Sep 20 09:47:29 2016 +0900

    staging: greybus: use preferred kernel type u8
    
    As suggested by checkpatch.pl:
    
    CHECK: Prefer kernel type 'u8' over 'uint8_t'
    
    Signed-off-by: Chaehyun Lim <chaehyun.lim@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/audio_codec.c b/drivers/staging/greybus/audio_codec.c
index 2f70295e0094..c9e198957f07 100644
--- a/drivers/staging/greybus/audio_codec.c
+++ b/drivers/staging/greybus/audio_codec.c
@@ -47,7 +47,7 @@ static int gbaudio_module_enable_tx(struct gbaudio_codec_info *codec,
 {
 	int module_state, ret = 0;
 	uint16_t data_cport, i2s_port, cportid;
-	uint8_t sig_bits, channels;
+	u8 sig_bits, channels;
 	uint32_t format, rate;
 	struct gbaudio_data_connection *data;
 	struct gbaudio_stream_params *params;
@@ -182,7 +182,7 @@ static int gbaudio_module_enable_rx(struct gbaudio_codec_info *codec,
 {
 	int module_state, ret = 0;
 	uint16_t data_cport, i2s_port, cportid;
-	uint8_t sig_bits, channels;
+	u8 sig_bits, channels;
 	uint32_t format, rate;
 	struct gbaudio_data_connection *data;
 	struct gbaudio_stream_params *params;
@@ -413,7 +413,7 @@ static int gbcodec_hw_params(struct snd_pcm_substream *substream,
 			     struct snd_soc_dai *dai)
 {
 	int ret;
-	uint8_t sig_bits, channels;
+	u8 sig_bits, channels;
 	uint32_t format, rate;
 	struct gbaudio_module_info *module;
 	struct gbaudio_data_connection *data;

commit 847175e8e660045f9366e7efd091969e8f32cc0c
Author: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
Date:   Thu Sep 1 11:38:40 2016 +0530

    greybus: audio: Fetch jack_mask, button_mask from module's topology data
    
    Added extra fields namely jack_mask & button_mask for each module_info.
    These fields are required while registering jack & reporting jack
    events.
    
    Earlier, these were hard coded values assuming fixed capabilities say
    HEADSET, LINEOUT, etc. supported by GB-codec driver. Now these are
    computed dynamically based on module's jack capability shared via
    topology data.
    
    Signed-off-by: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
    Reviewed-by: Mark Greer <mgreer@animalcreek.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/audio_codec.c b/drivers/staging/greybus/audio_codec.c
index 810ac6269cff..2f70295e0094 100644
--- a/drivers/staging/greybus/audio_codec.c
+++ b/drivers/staging/greybus/audio_codec.c
@@ -707,50 +707,72 @@ static int gbaudio_init_jack(struct gbaudio_module_info *module,
 {
 	int ret;
 
+	if (!module->jack_mask)
+		return 0;
+
 	snprintf(module->jack_name, NAME_SIZE, "GB %d Headset Jack",
 		 module->dev_id);
-	ret = snd_soc_jack_new(codec, module->jack_name, GBCODEC_JACK_MASK,
+	ret = snd_soc_jack_new(codec, module->jack_name, module->jack_mask,
 			       &module->headset_jack);
 	if (ret) {
 		dev_err(module->dev, "Failed to create new jack\n");
 		return ret;
 	}
 
+	if (!module->button_mask)
+		return 0;
+
 	snprintf(module->button_name, NAME_SIZE, "GB %d Button Jack",
 		 module->dev_id);
-	ret = snd_soc_jack_new(codec, module->button_name,
-			       GBCODEC_JACK_BUTTON_MASK, &module->button_jack);
+	ret = snd_soc_jack_new(codec, module->button_name, module->button_mask,
+			       &module->button_jack);
 	if (ret) {
 		dev_err(module->dev, "Failed to create button jack\n");
 		return ret;
 	}
 
-	ret = snd_jack_set_key(module->button_jack.jack, SND_JACK_BTN_0,
-			       KEY_MEDIA);
-	if (ret) {
-		dev_err(module->dev, "Failed to set BTN_0\n");
-		return ret;
+	/*
+	 * Currently, max 4 buttons are supported with following key mapping
+	 * BTN_0 = KEY_MEDIA
+	 * BTN_1 = KEY_VOICECOMMAND
+	 * BTN_2 = KEY_VOLUMEUP
+	 * BTN_3 = KEY_VOLUMEDOWN
+	 */
+
+	if (module->button_mask & SND_JACK_BTN_0) {
+		ret = snd_jack_set_key(module->button_jack.jack, SND_JACK_BTN_0,
+				       KEY_MEDIA);
+		if (ret) {
+			dev_err(module->dev, "Failed to set BTN_0\n");
+			return ret;
+		}
 	}
 
-	ret = snd_jack_set_key(module->button_jack.jack, SND_JACK_BTN_1,
-			       KEY_VOICECOMMAND);
-	if (ret) {
-		dev_err(module->dev, "Failed to set BTN_1\n");
-		return ret;
+	if (module->button_mask & SND_JACK_BTN_1) {
+		ret = snd_jack_set_key(module->button_jack.jack, SND_JACK_BTN_1,
+				       KEY_VOICECOMMAND);
+		if (ret) {
+			dev_err(module->dev, "Failed to set BTN_1\n");
+			return ret;
+		}
 	}
 
-	ret = snd_jack_set_key(module->button_jack.jack, SND_JACK_BTN_2,
-			       KEY_VOLUMEUP);
-	if (ret) {
-		dev_err(module->dev, "Failed to set BTN_2\n");
-		return ret;
+	if (module->button_mask & SND_JACK_BTN_2) {
+		ret = snd_jack_set_key(module->button_jack.jack, SND_JACK_BTN_2,
+				       KEY_VOLUMEUP);
+		if (ret) {
+			dev_err(module->dev, "Failed to set BTN_2\n");
+			return ret;
+		}
 	}
 
-	ret = snd_jack_set_key(module->button_jack.jack, SND_JACK_BTN_3,
-			       KEY_VOLUMEDOWN);
-	if (ret) {
-		dev_err(module->dev, "Failed to set BTN_0\n");
-		return ret;
+	if (module->button_mask & SND_JACK_BTN_3) {
+		ret = snd_jack_set_key(module->button_jack.jack, SND_JACK_BTN_3,
+				       KEY_VOLUMEDOWN);
+		if (ret) {
+			dev_err(module->dev, "Failed to set BTN_0\n");
+			return ret;
+		}
 	}
 
 	/* FIXME

commit 79c222bcb72789456076a26a9bad2acc62cb2cdc
Author: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
Date:   Thu Sep 1 11:38:38 2016 +0530

    greybus: audio: Remove unnecessary num_jack field from module_info
    
    snd_jack will be registered based on real capabilities shared by
    module's FW instead of parsing widgets and register it with fixed
    capabilities. Remove module_info->num_jack, since it is no more
    required.
    
    Signed-off-by: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
    Reviewed-by: Mark Greer <mgreer@animalcreek.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/audio_codec.c b/drivers/staging/greybus/audio_codec.c
index 6ebde18a5a53..810ac6269cff 100644
--- a/drivers/staging/greybus/audio_codec.c
+++ b/drivers/staging/greybus/audio_codec.c
@@ -707,15 +707,6 @@ static int gbaudio_init_jack(struct gbaudio_module_info *module,
 {
 	int ret;
 
-	if (!module->num_jacks)
-		return 0;
-
-	/* register jack(s) in case any */
-	if (module->num_jacks > 1) {
-		dev_err(module->dev, "Currently supports max=1 jack\n");
-		return -EINVAL;
-	}
-
 	snprintf(module->jack_name, NAME_SIZE, "GB %d Headset Jack",
 		 module->dev_id);
 	ret = snd_soc_jack_new(codec, module->jack_name, GBCODEC_JACK_MASK,

commit f0ec8cd5eb49e0360ce6ba865d5f2267b28d1f84
Author: Mark Greer <mgreer@animalcreek.com>
Date:   Sat Aug 20 16:25:06 2016 -0700

    greybus: audio: Fix incorrect direction value when enabling RX
    
    The direction value passed to gb_audio_apbridgea_register_cport()
    in the gbaudio_module_enable_rx() routine is TX and not RX like
    it should be so fix it.
    
    Testing Done: Recorded microphone data from a headset.
    
    Signed-off-by: Mark Greer <mgreer@animalcreek.com>
    Fixes: c80e7c6fafa5 ("audio: Split helper APIs based on stream direction")
    Tested-by: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
    Reviewd-by: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/audio_codec.c b/drivers/staging/greybus/audio_codec.c
index 3eb3d2cf014a..6ebde18a5a53 100644
--- a/drivers/staging/greybus/audio_codec.c
+++ b/drivers/staging/greybus/audio_codec.c
@@ -207,7 +207,7 @@ static int gbaudio_module_enable_rx(struct gbaudio_codec_info *codec,
 		cportid = data->connection->hd_cport_id;
 		ret = gb_audio_apbridgea_register_cport(data->connection,
 						i2s_port, cportid,
-						AUDIO_APBRIDGEA_DIRECTION_TX);
+						AUDIO_APBRIDGEA_DIRECTION_RX);
 		if (ret) {
 			dev_err_ratelimited(module->dev,
 					    "reg_cport failed:%d\n", ret);

commit 33cc283928249b2230a6519a2303fe30161cf788
Author: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
Date:   Fri Aug 5 18:16:30 2016 +0530

    greybus: audio: Report jack removal along with module removal
    
    For GB module with jack slot supported, headset/headphone can still
    be inserted at the time of module removal. In this case, above layer is
    unaware about jack removal event which happened due to module removal.
    This may lead to inconsistent state in above HAL layer.  Fix this by
    reporting jack removal event explicitly.
    
    Signed-off-by: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
    Reviewed-by: Mark Greer <mgreer@animalcreek.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/audio_codec.c b/drivers/staging/greybus/audio_codec.c
index cf86f51a83a2..3eb3d2cf014a 100644
--- a/drivers/staging/greybus/audio_codec.c
+++ b/drivers/staging/greybus/audio_codec.c
@@ -909,6 +909,7 @@ void gbaudio_unregister_module(struct gbaudio_module_info *module)
 	struct snd_soc_codec *codec = gbcodec->codec;
 	struct snd_card *card = codec->card->snd_card;
 	struct snd_soc_jack *jack, *next_j;
+	int mask;
 
 	dev_dbg(codec->dev, "Unregister %s module\n", module->name);
 
@@ -922,8 +923,16 @@ void gbaudio_unregister_module(struct gbaudio_module_info *module)
 #ifdef CONFIG_SND_JACK
 	/* free jack devices for this module from codec->jack_list */
 	list_for_each_entry_safe(jack, next_j, &codec->jack_list, list) {
-		if ((jack == &module->headset_jack)
-		    || (jack == &module->button_jack)) {
+		if (jack == &module->headset_jack)
+			mask = GBCODEC_JACK_MASK;
+		else if (jack == &module->button_jack)
+			mask = GBCODEC_JACK_BUTTON_MASK;
+		else
+			mask = 0;
+		if (mask) {
+			dev_dbg(module->dev, "Report %s removal\n",
+				jack->jack->id);
+			snd_soc_jack_report(jack, 0, mask);
 			snd_device_free(codec->card->snd_card, jack->jack);
 			list_del(&jack->list);
 		}

commit 591c45227a77505f111dd42347b2ad09b60ed131
Author: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
Date:   Thu Aug 4 15:14:39 2016 +0530

    greybus: audio: Maintain module stream state for each data connection
    
    For SPK module, each data connection corresponds to codec DAI. Now
    stream state is maintained for each DAI. So, need to maintain stream
    state for each DAI/data connection for individual module as well.
    
    Signed-off-by: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
    Reviewed-by: Mark Greer <mgreer@animalcreek.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/audio_codec.c b/drivers/staging/greybus/audio_codec.c
index e1ad685b00dc..cf86f51a83a2 100644
--- a/drivers/staging/greybus/audio_codec.c
+++ b/drivers/staging/greybus/audio_codec.c
@@ -52,14 +52,13 @@ static int gbaudio_module_enable_tx(struct gbaudio_codec_info *codec,
 	struct gbaudio_data_connection *data;
 	struct gbaudio_stream_params *params;
 
-	module_state = module->ctrlstate[SNDRV_PCM_STREAM_PLAYBACK];
-
 	/* find the dai */
 	data = find_data(module, id);
 	if (!data) {
 		dev_err(module->dev, "%d:DATA connection missing\n", id);
 		return -ENODEV;
 	}
+	module_state = data->state[SNDRV_PCM_STREAM_PLAYBACK];
 
 	params = find_dai_stream_params(codec, id, SNDRV_PCM_STREAM_PLAYBACK);
 	if (!params) {
@@ -79,7 +78,7 @@ static int gbaudio_module_enable_tx(struct gbaudio_codec_info *codec,
 					    "reg_cport failed:%d\n", ret);
 			return ret;
 		}
-		module->ctrlstate[SNDRV_PCM_STREAM_PLAYBACK] =
+		data->state[SNDRV_PCM_STREAM_PLAYBACK] =
 			GBAUDIO_CODEC_STARTUP;
 		dev_dbg(module->dev, "Dynamic Register %d DAI\n", cportid);
 	}
@@ -98,7 +97,7 @@ static int gbaudio_module_enable_tx(struct gbaudio_codec_info *codec,
 					    ret);
 			return ret;
 		}
-		module->ctrlstate[SNDRV_PCM_STREAM_PLAYBACK] =
+		data->state[SNDRV_PCM_STREAM_PLAYBACK] =
 			GBAUDIO_CODEC_HWPARAMS;
 		dev_dbg(module->dev, "Dynamic hw_params %d DAI\n", data_cport);
 	}
@@ -121,7 +120,7 @@ static int gbaudio_module_enable_tx(struct gbaudio_codec_info *codec,
 					    "activate_tx failed:%d\n", ret);
 			return ret;
 		}
-		module->ctrlstate[SNDRV_PCM_STREAM_PLAYBACK] =
+		data->state[SNDRV_PCM_STREAM_PLAYBACK] =
 			GBAUDIO_CODEC_PREPARE;
 		dev_dbg(module->dev, "Dynamic prepare %d DAI\n", data_cport);
 	}
@@ -136,19 +135,13 @@ static int gbaudio_module_disable_tx(struct gbaudio_module_info *module, int id)
 	int module_state;
 	struct gbaudio_data_connection *data;
 
-	module_state = module->ctrlstate[SNDRV_PCM_STREAM_PLAYBACK];
-
-	if (module_state == GBAUDIO_CODEC_SHUTDOWN) {
-		dev_dbg(module->dev, "module already configured\n");
-		return 0;
-	}
-
 	/* find the dai */
 	data = find_data(module, id);
 	if (!data) {
 		dev_err(module->dev, "%d:DATA connection missing\n", id);
 		return -ENODEV;
 	}
+	module_state = data->state[SNDRV_PCM_STREAM_PLAYBACK];
 
 	if (module_state > GBAUDIO_CODEC_HWPARAMS) {
 		data_cport = data->connection->intf_cport_id;
@@ -160,7 +153,7 @@ static int gbaudio_module_disable_tx(struct gbaudio_module_info *module, int id)
 			return ret;
 		}
 		dev_dbg(module->dev, "Dynamic deactivate %d DAI\n", data_cport);
-		module->ctrlstate[SNDRV_PCM_STREAM_PLAYBACK] =
+		data->state[SNDRV_PCM_STREAM_PLAYBACK] =
 			GBAUDIO_CODEC_HWPARAMS;
 	}
 
@@ -177,7 +170,7 @@ static int gbaudio_module_disable_tx(struct gbaudio_module_info *module, int id)
 			return ret;
 		}
 		dev_dbg(module->dev, "Dynamic Unregister %d DAI\n", cportid);
-		module->ctrlstate[SNDRV_PCM_STREAM_PLAYBACK] =
+		data->state[SNDRV_PCM_STREAM_PLAYBACK] =
 			GBAUDIO_CODEC_SHUTDOWN;
 	}
 
@@ -194,14 +187,13 @@ static int gbaudio_module_enable_rx(struct gbaudio_codec_info *codec,
 	struct gbaudio_data_connection *data;
 	struct gbaudio_stream_params *params;
 
-	module_state = module->ctrlstate[SNDRV_PCM_STREAM_CAPTURE];
-
 	/* find the dai */
 	data = find_data(module, id);
 	if (!data) {
 		dev_err(module->dev, "%d:DATA connection missing\n", id);
 		return -ENODEV;
 	}
+	module_state = data->state[SNDRV_PCM_STREAM_CAPTURE];
 
 	params = find_dai_stream_params(codec, id, SNDRV_PCM_STREAM_CAPTURE);
 	if (!params) {
@@ -221,7 +213,7 @@ static int gbaudio_module_enable_rx(struct gbaudio_codec_info *codec,
 					    "reg_cport failed:%d\n", ret);
 			return ret;
 		}
-		module->ctrlstate[SNDRV_PCM_STREAM_CAPTURE] =
+		data->state[SNDRV_PCM_STREAM_CAPTURE] =
 			GBAUDIO_CODEC_STARTUP;
 		dev_dbg(module->dev, "Dynamic Register %d DAI\n", cportid);
 	}
@@ -240,7 +232,7 @@ static int gbaudio_module_enable_rx(struct gbaudio_codec_info *codec,
 					    ret);
 			return ret;
 		}
-		module->ctrlstate[SNDRV_PCM_STREAM_CAPTURE] =
+		data->state[SNDRV_PCM_STREAM_CAPTURE] =
 			GBAUDIO_CODEC_HWPARAMS;
 		dev_dbg(module->dev, "Dynamic hw_params %d DAI\n", data_cport);
 	}
@@ -263,7 +255,7 @@ static int gbaudio_module_enable_rx(struct gbaudio_codec_info *codec,
 					    "activate_rx failed:%d\n", ret);
 			return ret;
 		}
-		module->ctrlstate[SNDRV_PCM_STREAM_CAPTURE] =
+		data->state[SNDRV_PCM_STREAM_CAPTURE] =
 			GBAUDIO_CODEC_PREPARE;
 		dev_dbg(module->dev, "Dynamic prepare %d DAI\n", data_cport);
 	}
@@ -278,20 +270,13 @@ static int gbaudio_module_disable_rx(struct gbaudio_module_info *module, int id)
 	int module_state;
 	struct gbaudio_data_connection *data;
 
-	module_state = module->ctrlstate[SNDRV_PCM_STREAM_CAPTURE];
-
-	if (module_state == GBAUDIO_CODEC_SHUTDOWN) {
-		dev_dbg(module->dev, "%s: module already configured\n",
-			module->name);
-		return 0;
-	}
-
 	/* find the dai */
 	data = find_data(module, id);
 	if (!data) {
 		dev_err(module->dev, "%d:DATA connection missing\n", id);
 		return -ENODEV;
 	}
+	module_state = data->state[SNDRV_PCM_STREAM_CAPTURE];
 
 	if (module_state > GBAUDIO_CODEC_HWPARAMS) {
 		data_cport = data->connection->intf_cport_id;
@@ -303,7 +288,7 @@ static int gbaudio_module_disable_rx(struct gbaudio_module_info *module, int id)
 			return ret;
 		}
 		dev_dbg(module->dev, "Dynamic deactivate %d DAI\n", data_cport);
-		module->ctrlstate[SNDRV_PCM_STREAM_CAPTURE] =
+		data->state[SNDRV_PCM_STREAM_CAPTURE] =
 			GBAUDIO_CODEC_HWPARAMS;
 	}
 
@@ -320,7 +305,7 @@ static int gbaudio_module_disable_rx(struct gbaudio_module_info *module, int id)
 			return ret;
 		}
 		dev_dbg(module->dev, "Dynamic Unregister %d DAI\n", cportid);
-		module->ctrlstate[SNDRV_PCM_STREAM_CAPTURE] =
+		data->state[SNDRV_PCM_STREAM_CAPTURE] =
 			GBAUDIO_CODEC_SHUTDOWN;
 	}
 
@@ -855,68 +840,67 @@ int gbaudio_register_module(struct gbaudio_module_info *module)
 }
 EXPORT_SYMBOL(gbaudio_register_module);
 
-static void gbaudio_codec_cleanup(struct gbaudio_module_info *module)
+static void gbaudio_codec_clean_data_tx(struct gbaudio_data_connection *data)
 {
-	struct gbaudio_data_connection *data;
-	int pb_state = gbcodec->stream[0].state;
-	int cap_state = gbcodec->stream[1].state;
+	uint16_t i2s_port, cportid;
 	int ret;
+
+	if (list_is_singular(&gbcodec->module_list)) {
+		ret = gb_audio_apbridgea_stop_tx(data->connection, 0);
+		if (ret)
+			return;
+		ret = gb_audio_apbridgea_shutdown_tx(data->connection,
+						     0);
+		if (ret)
+			return;
+	}
+	i2s_port = 0;	/* fixed for now */
+	cportid = data->connection->hd_cport_id;
+	ret = gb_audio_apbridgea_unregister_cport(data->connection,
+						  i2s_port, cportid,
+						  AUDIO_APBRIDGEA_DIRECTION_TX);
+	data->state[0] = GBAUDIO_CODEC_SHUTDOWN;
+}
+
+static void gbaudio_codec_clean_data_rx(struct gbaudio_data_connection *data)
+{
 	uint16_t i2s_port, cportid;
+	int ret;
 
-	/* locks already acquired */
-	if (!pb_state && !cap_state)
-		return;
+	if (list_is_singular(&gbcodec->module_list)) {
+		ret = gb_audio_apbridgea_stop_rx(data->connection, 0);
+		if (ret)
+			return;
+		ret = gb_audio_apbridgea_shutdown_rx(data->connection,
+						     0);
+		if (ret)
+			return;
+	}
+	i2s_port = 0;	/* fixed for now */
+	cportid = data->connection->hd_cport_id;
+	ret = gb_audio_apbridgea_unregister_cport(data->connection,
+						  i2s_port, cportid,
+						  AUDIO_APBRIDGEA_DIRECTION_RX);
+	data->state[1] = GBAUDIO_CODEC_SHUTDOWN;
+}
+
+
+static void gbaudio_codec_cleanup(struct gbaudio_module_info *module)
+{
+	struct gbaudio_data_connection *data;
+	int pb_state, cap_state;
 
 	dev_dbg(gbcodec->dev, "%s: removed, cleanup APBridge\n", module->name);
-	if (pb_state == GBAUDIO_CODEC_START) {
-		/* cleanup PB path, only APBridge specific */
-		data = find_data(module, 1);
-		if (!data) {
-			dev_err(gbcodec->dev, "%s: Missing data pointer\n",
-				__func__);
-			return;
-		}
+	list_for_each_entry(data, &module->data_list, list) {
+		pb_state = data->state[0];
+		cap_state = data->state[1];
 
-		if (list_is_singular(&gbcodec->module_list)) {
-			ret = gb_audio_apbridgea_stop_tx(data->connection, 0);
-			if (ret)
-				return;
-			ret = gb_audio_apbridgea_shutdown_tx(data->connection,
-							     0);
-			if (ret)
-				return;
-		}
-		i2s_port = 0;	/* fixed for now */
-		cportid = data->connection->hd_cport_id;
-		ret = gb_audio_apbridgea_unregister_cport(data->connection,
-						i2s_port, cportid,
-						AUDIO_APBRIDGEA_DIRECTION_TX);
-		module->ctrlstate[0] = GBAUDIO_CODEC_SHUTDOWN;
-	}
+		if (pb_state > GBAUDIO_CODEC_SHUTDOWN)
+			gbaudio_codec_clean_data_tx(data);
+
+		if (cap_state > GBAUDIO_CODEC_SHUTDOWN)
+			gbaudio_codec_clean_data_rx(data);
 
-	if (cap_state == GBAUDIO_CODEC_START) {
-		/* cleanup CAP path, only APBridge specific */
-		data = find_data(module, 1);
-		if (!data) {
-			dev_err(gbcodec->dev, "%s: Missing data pointer\n",
-				__func__);
-			return;
-		}
-		if (list_is_singular(&gbcodec->module_list)) {
-			ret = gb_audio_apbridgea_stop_rx(data->connection, 0);
-			if (ret)
-				return;
-			ret = gb_audio_apbridgea_shutdown_rx(data->connection,
-							     0);
-			if (ret)
-				return;
-		}
-		i2s_port = 0;	/* fixed for now */
-		cportid = data->connection->hd_cport_id;
-		ret = gb_audio_apbridgea_unregister_cport(data->connection,
-						i2s_port, cportid,
-						AUDIO_APBRIDGEA_DIRECTION_RX);
-		module->ctrlstate[1] = GBAUDIO_CODEC_SHUTDOWN;
 	}
 }
 

commit 19866603be2ad58735f82511f3d5f680e61479ea
Author: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
Date:   Thu Aug 4 15:14:38 2016 +0530

    greybus: audio: Maintain runtime stream params for each DAI
    
    Runtime streams are required while configuring GB module plugged-in
    during active stream. Currently, it is maintained for single stream.
    However, this should be maintained for a stream corresponding to each
    DAI. Fix this!
    
    Signed-off-by: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
    Reviewed-by: Mark Greer <mgreer@animalcreek.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/audio_codec.c b/drivers/staging/greybus/audio_codec.c
index 9f050bd95c7c..e1ad685b00dc 100644
--- a/drivers/staging/greybus/audio_codec.c
+++ b/drivers/staging/greybus/audio_codec.c
@@ -30,6 +30,18 @@ find_data(struct gbaudio_module_info *module, int id)
 	return NULL;
 }
 
+static struct gbaudio_stream_params *
+find_dai_stream_params(struct gbaudio_codec_info *codec, int id, int stream)
+{
+	struct gbaudio_codec_dai *dai;
+
+	list_for_each_entry(dai, &codec->dai_list, list) {
+		if (dai->id == id)
+			return &dai->params[stream];
+	}
+	return NULL;
+}
+
 static int gbaudio_module_enable_tx(struct gbaudio_codec_info *codec,
 				    struct gbaudio_module_info *module, int id)
 {
@@ -38,13 +50,7 @@ static int gbaudio_module_enable_tx(struct gbaudio_codec_info *codec,
 	uint8_t sig_bits, channels;
 	uint32_t format, rate;
 	struct gbaudio_data_connection *data;
-	const char *dai_name;
-
-	dai_name = codec->stream[SNDRV_PCM_STREAM_PLAYBACK].dai_name;
-	format = codec->stream[SNDRV_PCM_STREAM_PLAYBACK].format;
-	channels = codec->stream[SNDRV_PCM_STREAM_PLAYBACK].channels;
-	rate = codec->stream[SNDRV_PCM_STREAM_PLAYBACK].rate;
-	sig_bits = codec->stream[SNDRV_PCM_STREAM_PLAYBACK].sig_bits;
+	struct gbaudio_stream_params *params;
 
 	module_state = module->ctrlstate[SNDRV_PCM_STREAM_PLAYBACK];
 
@@ -55,6 +61,12 @@ static int gbaudio_module_enable_tx(struct gbaudio_codec_info *codec,
 		return -ENODEV;
 	}
 
+	params = find_dai_stream_params(codec, id, SNDRV_PCM_STREAM_PLAYBACK);
+	if (!params) {
+		dev_err(codec->dev, "Failed to fetch dai_stream pointer\n");
+		return -EINVAL;
+	}
+
 	/* register cport */
 	if (module_state < GBAUDIO_CODEC_STARTUP) {
 		i2s_port = 0;	/* fixed for now */
@@ -69,12 +81,15 @@ static int gbaudio_module_enable_tx(struct gbaudio_codec_info *codec,
 		}
 		module->ctrlstate[SNDRV_PCM_STREAM_PLAYBACK] =
 			GBAUDIO_CODEC_STARTUP;
-		dev_dbg(module->dev, "Dynamic Register %s:%d DAI\n", dai_name,
-			cportid);
+		dev_dbg(module->dev, "Dynamic Register %d DAI\n", cportid);
 	}
 
 	/* hw_params */
 	if (module_state < GBAUDIO_CODEC_HWPARAMS) {
+		format = params->format;
+		channels = params->channels;
+		rate = params->rate;
+		sig_bits = params->sig_bits;
 		data_cport = data->connection->intf_cport_id;
 		ret = gb_audio_gb_set_pcm(module->mgmt_connection, data_cport,
 					  format, rate, channels, sig_bits);
@@ -85,8 +100,7 @@ static int gbaudio_module_enable_tx(struct gbaudio_codec_info *codec,
 		}
 		module->ctrlstate[SNDRV_PCM_STREAM_PLAYBACK] =
 			GBAUDIO_CODEC_HWPARAMS;
-		dev_dbg(module->dev, "Dynamic hw_params %s:%d DAI\n", dai_name,
-			data_cport);
+		dev_dbg(module->dev, "Dynamic hw_params %d DAI\n", data_cport);
 	}
 
 	/* prepare */
@@ -109,8 +123,7 @@ static int gbaudio_module_enable_tx(struct gbaudio_codec_info *codec,
 		}
 		module->ctrlstate[SNDRV_PCM_STREAM_PLAYBACK] =
 			GBAUDIO_CODEC_PREPARE;
-		dev_dbg(module->dev, "Dynamic prepare %s:%d DAI\n", dai_name,
-			data_cport);
+		dev_dbg(module->dev, "Dynamic prepare %d DAI\n", data_cport);
 	}
 
 	return 0;
@@ -179,13 +192,8 @@ static int gbaudio_module_enable_rx(struct gbaudio_codec_info *codec,
 	uint8_t sig_bits, channels;
 	uint32_t format, rate;
 	struct gbaudio_data_connection *data;
-	const char *dai_name;
+	struct gbaudio_stream_params *params;
 
-	dai_name = codec->stream[SNDRV_PCM_STREAM_CAPTURE].dai_name;
-	format = codec->stream[SNDRV_PCM_STREAM_CAPTURE].format;
-	channels = codec->stream[SNDRV_PCM_STREAM_CAPTURE].channels;
-	rate = codec->stream[SNDRV_PCM_STREAM_CAPTURE].rate;
-	sig_bits = codec->stream[SNDRV_PCM_STREAM_CAPTURE].sig_bits;
 	module_state = module->ctrlstate[SNDRV_PCM_STREAM_CAPTURE];
 
 	/* find the dai */
@@ -195,6 +203,12 @@ static int gbaudio_module_enable_rx(struct gbaudio_codec_info *codec,
 		return -ENODEV;
 	}
 
+	params = find_dai_stream_params(codec, id, SNDRV_PCM_STREAM_CAPTURE);
+	if (!params) {
+		dev_err(codec->dev, "Failed to fetch dai_stream pointer\n");
+		return -EINVAL;
+	}
+
 	/* register cport */
 	if (module_state < GBAUDIO_CODEC_STARTUP) {
 		i2s_port = 0;	/* fixed for now */
@@ -209,12 +223,15 @@ static int gbaudio_module_enable_rx(struct gbaudio_codec_info *codec,
 		}
 		module->ctrlstate[SNDRV_PCM_STREAM_CAPTURE] =
 			GBAUDIO_CODEC_STARTUP;
-		dev_dbg(module->dev, "Dynamic Register %s:%d DAI\n", dai_name,
-			cportid);
+		dev_dbg(module->dev, "Dynamic Register %d DAI\n", cportid);
 	}
 
 	/* hw_params */
 	if (module_state < GBAUDIO_CODEC_HWPARAMS) {
+		format = params->format;
+		channels = params->channels;
+		rate = params->rate;
+		sig_bits = params->sig_bits;
 		data_cport = data->connection->intf_cport_id;
 		ret = gb_audio_gb_set_pcm(module->mgmt_connection, data_cport,
 					  format, rate, channels, sig_bits);
@@ -225,8 +242,7 @@ static int gbaudio_module_enable_rx(struct gbaudio_codec_info *codec,
 		}
 		module->ctrlstate[SNDRV_PCM_STREAM_CAPTURE] =
 			GBAUDIO_CODEC_HWPARAMS;
-		dev_dbg(module->dev, "Dynamic hw_params %s:%d DAI\n", dai_name,
-			data_cport);
+		dev_dbg(module->dev, "Dynamic hw_params %d DAI\n", data_cport);
 	}
 
 	/* prepare */
@@ -249,8 +265,7 @@ static int gbaudio_module_enable_rx(struct gbaudio_codec_info *codec,
 		}
 		module->ctrlstate[SNDRV_PCM_STREAM_CAPTURE] =
 			GBAUDIO_CODEC_PREPARE;
-		dev_dbg(module->dev, "Dynamic prepare %s:%d DAI\n", dai_name,
-			data_cport);
+		dev_dbg(module->dev, "Dynamic prepare %d DAI\n", data_cport);
 	}
 
 	return 0;
@@ -361,6 +376,7 @@ static int gbcodec_startup(struct snd_pcm_substream *substream,
 			   struct snd_soc_dai *dai)
 {
 	struct gbaudio_codec_info *codec = dev_get_drvdata(dai->dev);
+	struct gbaudio_stream_params *params;
 
 	mutex_lock(&codec->lock);
 
@@ -370,8 +386,13 @@ static int gbcodec_startup(struct snd_pcm_substream *substream,
 		return -ENODEV;
 	}
 
-	codec->stream[substream->stream].state = GBAUDIO_CODEC_STARTUP;
-	codec->stream[substream->stream].dai_name = dai->name;
+	params = find_dai_stream_params(codec, dai->id, substream->stream);
+	if (!params) {
+		dev_err(codec->dev, "Failed to fetch dai_stream pointer\n");
+		mutex_unlock(&codec->lock);
+		return -EINVAL;
+	}
+	params->state = GBAUDIO_CODEC_STARTUP;
 	mutex_unlock(&codec->lock);
 	/* to prevent suspend in case of active audio */
 	pm_stay_awake(dai->dev);
@@ -383,14 +404,20 @@ static void gbcodec_shutdown(struct snd_pcm_substream *substream,
 			     struct snd_soc_dai *dai)
 {
 	struct gbaudio_codec_info *codec = dev_get_drvdata(dai->dev);
+	struct gbaudio_stream_params *params;
 
 	mutex_lock(&codec->lock);
 
 	if (list_empty(&codec->module_list))
 		dev_info(codec->dev, "No codec module available during shutdown\n");
 
-	codec->stream[substream->stream].state = GBAUDIO_CODEC_SHUTDOWN;
-	codec->stream[substream->stream].dai_name = NULL;
+	params = find_dai_stream_params(codec, dai->id, substream->stream);
+	if (!params) {
+		dev_err(codec->dev, "Failed to fetch dai_stream pointer\n");
+		mutex_unlock(&codec->lock);
+		return;
+	}
+	params->state = GBAUDIO_CODEC_SHUTDOWN;
 	mutex_unlock(&codec->lock);
 	pm_relax(dai->dev);
 	return;
@@ -407,6 +434,7 @@ static int gbcodec_hw_params(struct snd_pcm_substream *substream,
 	struct gbaudio_data_connection *data;
 	struct gb_bundle *bundle;
 	struct gbaudio_codec_info *codec = dev_get_drvdata(dai->dev);
+	struct gbaudio_stream_params *params;
 
 	mutex_lock(&codec->lock);
 
@@ -457,6 +485,13 @@ static int gbcodec_hw_params(struct snd_pcm_substream *substream,
 		return -EINVAL;
 	}
 
+	params = find_dai_stream_params(codec, dai->id, substream->stream);
+	if (!params) {
+		dev_err(codec->dev, "Failed to fetch dai_stream pointer\n");
+		mutex_unlock(&codec->lock);
+		return -EINVAL;
+	}
+
 	bundle = to_gb_bundle(module->dev);
 	ret = gb_pm_runtime_get_sync(bundle);
 	if (ret) {
@@ -477,11 +512,11 @@ static int gbcodec_hw_params(struct snd_pcm_substream *substream,
 
 	gb_pm_runtime_put_noidle(bundle);
 
-	codec->stream[substream->stream].state = GBAUDIO_CODEC_HWPARAMS;
-	codec->stream[substream->stream].format = format;
-	codec->stream[substream->stream].rate = rate;
-	codec->stream[substream->stream].channels = channels;
-	codec->stream[substream->stream].sig_bits = sig_bits;
+	params->state = GBAUDIO_CODEC_HWPARAMS;
+	params->format = format;
+	params->rate = rate;
+	params->channels = channels;
+	params->sig_bits = sig_bits;
 
 	mutex_unlock(&codec->lock);
 	return 0;
@@ -495,6 +530,7 @@ static int gbcodec_prepare(struct snd_pcm_substream *substream,
 	struct gbaudio_data_connection *data;
 	struct gb_bundle *bundle;
 	struct gbaudio_codec_info *codec = dev_get_drvdata(dai->dev);
+	struct gbaudio_stream_params *params;
 
 	mutex_lock(&codec->lock);
 
@@ -516,6 +552,13 @@ static int gbcodec_prepare(struct snd_pcm_substream *substream,
 		return -ENODEV;
 	}
 
+	params = find_dai_stream_params(codec, dai->id, substream->stream);
+	if (!params) {
+		dev_err(codec->dev, "Failed to fetch dai_stream pointer\n");
+		mutex_unlock(&codec->lock);
+		return -EINVAL;
+	}
+
 	bundle = to_gb_bundle(module->dev);
 	ret = gb_pm_runtime_get_sync(bundle);
 	if (ret) {
@@ -542,7 +585,7 @@ static int gbcodec_prepare(struct snd_pcm_substream *substream,
 
 	gb_pm_runtime_put_noidle(bundle);
 
-	codec->stream[substream->stream].state = GBAUDIO_CODEC_PREPARE;
+	params->state = GBAUDIO_CODEC_PREPARE;
 	mutex_unlock(&codec->lock);
 	return 0;
 }
@@ -554,16 +597,25 @@ static int gbcodec_mute_stream(struct snd_soc_dai *dai, int mute, int stream)
 	struct gbaudio_module_info *module;
 	struct gb_bundle *bundle;
 	struct gbaudio_codec_info *codec = dev_get_drvdata(dai->dev);
+	struct gbaudio_stream_params *params;
 
 
 	dev_dbg(dai->dev, "Mute:%d, Direction:%s\n", mute,
 		stream ? "CAPTURE":"PLAYBACK");
 
 	mutex_lock(&codec->lock);
+
+	params = find_dai_stream_params(codec, dai->id, stream);
+	if (!params) {
+		dev_err(codec->dev, "Failed to fetch dai_stream pointer\n");
+		mutex_unlock(&codec->lock);
+		return -EINVAL;
+	}
+
 	if (list_empty(&codec->module_list)) {
 		dev_err(codec->dev, "No codec module available\n");
 		if (mute) {
-			codec->stream[stream].state = GBAUDIO_CODEC_STOP;
+			params->state = GBAUDIO_CODEC_STOP;
 			ret = 0;
 		} else {
 			ret = -ENODEV;
@@ -598,26 +650,26 @@ static int gbcodec_mute_stream(struct snd_soc_dai *dai, int mute, int stream)
 		if (!ret)
 			ret = gb_audio_apbridgea_start_tx(data->connection,
 							  0, 0);
-		codec->stream[stream].state = GBAUDIO_CODEC_START;
+		params->state = GBAUDIO_CODEC_START;
 	} else if (!mute && stream) {/* start capture */
 		ret = gb_audio_apbridgea_prepare_rx(data->connection,
 						    0);
 		if (!ret)
 			ret = gb_audio_apbridgea_start_rx(data->connection,
 							  0);
-		codec->stream[stream].state = GBAUDIO_CODEC_START;
+		params->state = GBAUDIO_CODEC_START;
 	} else if (mute && !stream) {/* stop playback */
 		ret = gb_audio_apbridgea_stop_tx(data->connection, 0);
 		if (!ret)
 			ret = gb_audio_apbridgea_shutdown_tx(data->connection,
 							     0);
-		codec->stream[stream].state = GBAUDIO_CODEC_STOP;
+		params->state = GBAUDIO_CODEC_STOP;
 	} else if (mute && stream) {/* stop capture */
 		ret = gb_audio_apbridgea_stop_rx(data->connection, 0);
 		if (!ret)
 			ret = gb_audio_apbridgea_shutdown_rx(data->connection,
 							     0);
-		codec->stream[stream].state = GBAUDIO_CODEC_STOP;
+		params->state = GBAUDIO_CODEC_STOP;
 	} else
 		ret = -EINVAL;
 	if (ret)
@@ -639,6 +691,32 @@ static struct snd_soc_dai_ops gbcodec_dai_ops = {
 	.mute_stream = gbcodec_mute_stream,
 };
 
+static struct snd_soc_dai_driver gbaudio_dai[] = {
+	{
+		.name = "apb-i2s0",
+		.id = 0,
+		.playback = {
+			.stream_name = "I2S 0 Playback",
+			.rates = SNDRV_PCM_RATE_48000,
+			.formats = SNDRV_PCM_FORMAT_S16_LE,
+			.rate_max = 48000,
+			.rate_min = 48000,
+			.channels_min = 1,
+			.channels_max = 2,
+		},
+		.capture = {
+			.stream_name = "I2S 0 Capture",
+			.rates = SNDRV_PCM_RATE_48000,
+			.formats = SNDRV_PCM_FORMAT_S16_LE,
+			.rate_max = 48000,
+			.rate_min = 48000,
+			.channels_min = 1,
+			.channels_max = 2,
+		},
+		.ops = &gbcodec_dai_ops,
+	},
+};
+
 static int gbaudio_init_jack(struct gbaudio_module_info *module,
 			     struct snd_soc_codec *codec)
 {
@@ -898,7 +976,9 @@ EXPORT_SYMBOL(gbaudio_unregister_module);
  */
 static int gbcodec_probe(struct snd_soc_codec *codec)
 {
+	int i;
 	struct gbaudio_codec_info *info;
+	struct gbaudio_codec_dai *dai;
 
 	info = devm_kzalloc(codec->dev, sizeof(*info), GFP_KERNEL);
 	if (!info)
@@ -907,6 +987,17 @@ static int gbcodec_probe(struct snd_soc_codec *codec)
 	info->dev = codec->dev;
 	INIT_LIST_HEAD(&info->module_list);
 	mutex_init(&info->lock);
+	INIT_LIST_HEAD(&info->dai_list);
+
+	/* init dai_list used to maintain runtime stream info */
+	for (i = 0; i < ARRAY_SIZE(gbaudio_dai); i++) {
+		dai = devm_kzalloc(codec->dev, sizeof(*dai), GFP_KERNEL);
+		if (!dai)
+			return -ENOMEM;
+		dai->id = gbaudio_dai[i].id;
+		list_add(&dai->list, &info->dai_list);
+	}
+
 	info->codec = codec;
 	snd_soc_codec_set_drvdata(codec, info);
 	gbcodec = info;
@@ -964,32 +1055,6 @@ static unsigned int gbcodec_read(struct snd_soc_codec *codec,
 	return val;
 }
 
-static struct snd_soc_dai_driver gbaudio_dai[] = {
-	{
-		.name = "apb-i2s0",
-		.id = 0,
-		.playback = {
-			.stream_name = "I2S 0 Playback",
-			.rates = SNDRV_PCM_RATE_48000,
-			.formats = SNDRV_PCM_FORMAT_S16_LE,
-			.rate_max = 48000,
-			.rate_min = 48000,
-			.channels_min = 1,
-			.channels_max = 2,
-		},
-		.capture = {
-			.stream_name = "I2S 0 Capture",
-			.rates = SNDRV_PCM_RATE_48000,
-			.formats = SNDRV_PCM_FORMAT_S16_LE,
-			.rate_max = 48000,
-			.rate_min = 48000,
-			.channels_min = 1,
-			.channels_max = 2,
-		},
-		.ops = &gbcodec_dai_ops,
-	},
-};
-
 static struct snd_soc_codec_driver soc_codec_dev_gbaudio = {
 	.probe	= gbcodec_probe,
 	.remove	= gbcodec_remove,

commit c388ae769699262bd48da1d529bbed731c2de559
Author: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
Date:   Thu Aug 4 15:14:37 2016 +0530

    greybus: audio: Update pm runtime support in dai_ops callback
    
    Ensure pm runtime get_sync/put protection in codec_dai ops callback
    functions before accessing apbridge.
    
    Signed-off-by: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
    Reviewed-by: Mark Greer <mgreer@animalcreek.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/audio_codec.c b/drivers/staging/greybus/audio_codec.c
index b64aca523d53..9f050bd95c7c 100644
--- a/drivers/staging/greybus/audio_codec.c
+++ b/drivers/staging/greybus/audio_codec.c
@@ -405,6 +405,7 @@ static int gbcodec_hw_params(struct snd_pcm_substream *substream,
 	uint32_t format, rate;
 	struct gbaudio_module_info *module;
 	struct gbaudio_data_connection *data;
+	struct gb_bundle *bundle;
 	struct gbaudio_codec_info *codec = dev_get_drvdata(dai->dev);
 
 	mutex_lock(&codec->lock);
@@ -456,6 +457,13 @@ static int gbcodec_hw_params(struct snd_pcm_substream *substream,
 		return -EINVAL;
 	}
 
+	bundle = to_gb_bundle(module->dev);
+	ret = gb_pm_runtime_get_sync(bundle);
+	if (ret) {
+		mutex_unlock(&codec->lock);
+		return ret;
+	}
+
 	ret = gb_audio_apbridgea_set_config(data->connection, 0,
 					    AUDIO_APBRIDGEA_PCM_FMT_16,
 					    AUDIO_APBRIDGEA_PCM_RATE_48000,
@@ -466,6 +474,9 @@ static int gbcodec_hw_params(struct snd_pcm_substream *substream,
 		mutex_unlock(&codec->lock);
 		return ret;
 	}
+
+	gb_pm_runtime_put_noidle(bundle);
+
 	codec->stream[substream->stream].state = GBAUDIO_CODEC_HWPARAMS;
 	codec->stream[substream->stream].format = format;
 	codec->stream[substream->stream].rate = rate;
@@ -482,6 +493,7 @@ static int gbcodec_prepare(struct snd_pcm_substream *substream,
 	int ret;
 	struct gbaudio_module_info *module;
 	struct gbaudio_data_connection *data;
+	struct gb_bundle *bundle;
 	struct gbaudio_codec_info *codec = dev_get_drvdata(dai->dev);
 
 	mutex_lock(&codec->lock);
@@ -504,6 +516,13 @@ static int gbcodec_prepare(struct snd_pcm_substream *substream,
 		return -ENODEV;
 	}
 
+	bundle = to_gb_bundle(module->dev);
+	ret = gb_pm_runtime_get_sync(bundle);
+	if (ret) {
+		mutex_unlock(&codec->lock);
+		return ret;
+	}
+
 	switch (substream->stream) {
 	case SNDRV_PCM_STREAM_PLAYBACK:
 		ret = gb_audio_apbridgea_set_tx_data_size(data->connection, 0,
@@ -521,6 +540,8 @@ static int gbcodec_prepare(struct snd_pcm_substream *substream,
 		return ret;
 	}
 
+	gb_pm_runtime_put_noidle(bundle);
+
 	codec->stream[substream->stream].state = GBAUDIO_CODEC_PREPARE;
 	mutex_unlock(&codec->lock);
 	return 0;
@@ -531,6 +552,7 @@ static int gbcodec_mute_stream(struct snd_soc_dai *dai, int mute, int stream)
 	int ret;
 	struct gbaudio_data_connection *data;
 	struct gbaudio_module_info *module;
+	struct gb_bundle *bundle;
 	struct gbaudio_codec_info *codec = dev_get_drvdata(dai->dev);
 
 
@@ -563,6 +585,13 @@ static int gbcodec_mute_stream(struct snd_soc_dai *dai, int mute, int stream)
 		return -ENODEV;
 	}
 
+	bundle = to_gb_bundle(module->dev);
+	ret = gb_pm_runtime_get_sync(bundle);
+	if (ret) {
+		mutex_unlock(&codec->lock);
+		return ret;
+	}
+
 	if (!mute && !stream) {/* start playback */
 		ret = gb_audio_apbridgea_prepare_tx(data->connection,
 						    0);
@@ -597,6 +626,7 @@ static int gbcodec_mute_stream(struct snd_soc_dai *dai, int mute, int stream)
 				    module->name, mute ? "Mute" : "Unmute",
 				    stream ? "Capture" : "Playback", ret);
 
+	gb_pm_runtime_put_noidle(bundle);
 	mutex_unlock(&codec->lock);
 	return ret;
 }

commit 60e7327d54b270eeadc120b6202af50856548376
Author: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
Date:   Thu Aug 4 15:14:35 2016 +0530

    greybus: audio: Find data connection based on id
    
    Currently we are using dai->name to identify data connection from list
    for a module. Now since we are enabling data path based on widget,
    dai->name might be invalid by the time driver receives disable request
    for a widget. So, use id fetched from AIF widget->sname to identify data
    connection for a module.
    
    Signed-off-by: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
    Reviewed-by: Mark Greer <mgreer@animalcreek.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/audio_codec.c b/drivers/staging/greybus/audio_codec.c
index 3067c1a7ab39..b64aca523d53 100644
--- a/drivers/staging/greybus/audio_codec.c
+++ b/drivers/staging/greybus/audio_codec.c
@@ -19,19 +19,19 @@
 static struct gbaudio_codec_info *gbcodec;
 
 static struct gbaudio_data_connection *
-find_data(struct gbaudio_module_info *module, const char *name)
+find_data(struct gbaudio_module_info *module, int id)
 {
 	struct gbaudio_data_connection *data;
 
 	list_for_each_entry(data, &module->data_list, list) {
-		if (name && !strncmp(data->name, name, NAME_SIZE))
+		if (id == data->id)
 			return data;
 	}
 	return NULL;
 }
 
 static int gbaudio_module_enable_tx(struct gbaudio_codec_info *codec,
-				    struct gbaudio_module_info *module)
+				    struct gbaudio_module_info *module, int id)
 {
 	int module_state, ret = 0;
 	uint16_t data_cport, i2s_port, cportid;
@@ -49,9 +49,9 @@ static int gbaudio_module_enable_tx(struct gbaudio_codec_info *codec,
 	module_state = module->ctrlstate[SNDRV_PCM_STREAM_PLAYBACK];
 
 	/* find the dai */
-	data = find_data(module, dai_name);
+	data = find_data(module, id);
 	if (!data) {
-		dev_err(module->dev, "%s:DATA connection missing\n", dai_name);
+		dev_err(module->dev, "%d:DATA connection missing\n", id);
 		return -ENODEV;
 	}
 
@@ -116,16 +116,13 @@ static int gbaudio_module_enable_tx(struct gbaudio_codec_info *codec,
 	return 0;
 }
 
-static int gbaudio_module_disable_tx(struct gbaudio_codec_info *codec,
-				     struct gbaudio_module_info *module)
+static int gbaudio_module_disable_tx(struct gbaudio_module_info *module, int id)
 {
 	int ret;
 	uint16_t data_cport, cportid, i2s_port;
 	int module_state;
 	struct gbaudio_data_connection *data;
-	const char *dai_name;
 
-	dai_name = codec->stream[SNDRV_PCM_STREAM_PLAYBACK].dai_name;
 	module_state = module->ctrlstate[SNDRV_PCM_STREAM_PLAYBACK];
 
 	if (module_state == GBAUDIO_CODEC_SHUTDOWN) {
@@ -134,9 +131,9 @@ static int gbaudio_module_disable_tx(struct gbaudio_codec_info *codec,
 	}
 
 	/* find the dai */
-	data = find_data(module, dai_name);
+	data = find_data(module, id);
 	if (!data) {
-		dev_err(module->dev, "%s:DATA connection missing\n", dai_name);
+		dev_err(module->dev, "%d:DATA connection missing\n", id);
 		return -ENODEV;
 	}
 
@@ -149,8 +146,7 @@ static int gbaudio_module_disable_tx(struct gbaudio_codec_info *codec,
 					    "deactivate_tx failed:%d\n", ret);
 			return ret;
 		}
-		dev_dbg(module->dev, "Dynamic deactivate %s:%d DAI\n", dai_name,
-			data_cport);
+		dev_dbg(module->dev, "Dynamic deactivate %d DAI\n", data_cport);
 		module->ctrlstate[SNDRV_PCM_STREAM_PLAYBACK] =
 			GBAUDIO_CODEC_HWPARAMS;
 	}
@@ -167,8 +163,7 @@ static int gbaudio_module_disable_tx(struct gbaudio_codec_info *codec,
 					    ret);
 			return ret;
 		}
-		dev_dbg(module->dev, "Dynamic Unregister %s:%d DAI\n", dai_name,
-			cportid);
+		dev_dbg(module->dev, "Dynamic Unregister %d DAI\n", cportid);
 		module->ctrlstate[SNDRV_PCM_STREAM_PLAYBACK] =
 			GBAUDIO_CODEC_SHUTDOWN;
 	}
@@ -177,7 +172,7 @@ static int gbaudio_module_disable_tx(struct gbaudio_codec_info *codec,
 }
 
 static int gbaudio_module_enable_rx(struct gbaudio_codec_info *codec,
-				    struct gbaudio_module_info *module)
+				    struct gbaudio_module_info *module, int id)
 {
 	int module_state, ret = 0;
 	uint16_t data_cport, i2s_port, cportid;
@@ -194,9 +189,9 @@ static int gbaudio_module_enable_rx(struct gbaudio_codec_info *codec,
 	module_state = module->ctrlstate[SNDRV_PCM_STREAM_CAPTURE];
 
 	/* find the dai */
-	data = find_data(module, dai_name);
+	data = find_data(module, id);
 	if (!data) {
-		dev_err(module->dev, "%s:DATA connection missing\n", dai_name);
+		dev_err(module->dev, "%d:DATA connection missing\n", id);
 		return -ENODEV;
 	}
 
@@ -261,16 +256,13 @@ static int gbaudio_module_enable_rx(struct gbaudio_codec_info *codec,
 	return 0;
 }
 
-static int gbaudio_module_disable_rx(struct gbaudio_codec_info *codec,
-				     struct gbaudio_module_info *module)
+static int gbaudio_module_disable_rx(struct gbaudio_module_info *module, int id)
 {
 	int ret;
 	uint16_t data_cport, cportid, i2s_port;
 	int module_state;
 	struct gbaudio_data_connection *data;
-	const char *dai_name;
 
-	dai_name = codec->stream[SNDRV_PCM_STREAM_CAPTURE].dai_name;
 	module_state = module->ctrlstate[SNDRV_PCM_STREAM_CAPTURE];
 
 	if (module_state == GBAUDIO_CODEC_SHUTDOWN) {
@@ -280,9 +272,9 @@ static int gbaudio_module_disable_rx(struct gbaudio_codec_info *codec,
 	}
 
 	/* find the dai */
-	data = find_data(module, dai_name);
+	data = find_data(module, id);
 	if (!data) {
-		dev_err(module->dev, "%s:DATA connection missing\n", dai_name);
+		dev_err(module->dev, "%d:DATA connection missing\n", id);
 		return -ENODEV;
 	}
 
@@ -295,8 +287,7 @@ static int gbaudio_module_disable_rx(struct gbaudio_codec_info *codec,
 					    "deactivate_rx failed:%d\n", ret);
 			return ret;
 		}
-		dev_dbg(module->dev, "Dynamic deactivate %s:%d DAI\n", dai_name,
-			data_cport);
+		dev_dbg(module->dev, "Dynamic deactivate %d DAI\n", data_cport);
 		module->ctrlstate[SNDRV_PCM_STREAM_CAPTURE] =
 			GBAUDIO_CODEC_HWPARAMS;
 	}
@@ -313,8 +304,7 @@ static int gbaudio_module_disable_rx(struct gbaudio_codec_info *codec,
 					    ret);
 			return ret;
 		}
-		dev_dbg(module->dev, "Dynamic Unregister %s:%d DAI\n", dai_name,
-			cportid);
+		dev_dbg(module->dev, "Dynamic Unregister %d DAI\n", cportid);
 		module->ctrlstate[SNDRV_PCM_STREAM_CAPTURE] =
 			GBAUDIO_CODEC_SHUTDOWN;
 	}
@@ -326,28 +316,36 @@ int gbaudio_module_update(struct gbaudio_codec_info *codec,
 			  struct snd_soc_dapm_widget *w,
 			  struct gbaudio_module_info *module, int enable)
 {
-	int ret = 0;
-	const char *w_name = w->name;
+	int dai_id, ret;
+	char intf_name[NAME_SIZE], dir[NAME_SIZE];
 
-	dev_dbg(module->dev, "%s:Module update %s sequence\n", w_name,
+	dev_dbg(module->dev, "%s:Module update %s sequence\n", w->name,
 		enable ? "Enable":"Disable");
 
 	if ((w->id != snd_soc_dapm_aif_in) && (w->id != snd_soc_dapm_aif_out)){
-		dev_dbg(codec->dev, "No action required for %s\n", w_name);
+		dev_dbg(codec->dev, "No action required for %s\n", w->name);
 		return 0;
 	}
 
+	/* parse dai_id from AIF widget's stream_name */
+	ret = sscanf(w->sname, "%s %d %s", intf_name, &dai_id, dir);
+	if (ret < 3) {
+		dev_err(codec->dev, "Error while parsing dai_id for %s\n",
+			w->name);
+		return -EINVAL;
+	}
+
 	mutex_lock(&codec->lock);
 	if (w->id == snd_soc_dapm_aif_in) {
 		if (enable)
-			ret = gbaudio_module_enable_tx(codec, module);
+			ret = gbaudio_module_enable_tx(codec, module, dai_id);
 		else
-			ret = gbaudio_module_disable_tx(codec, module);
+			ret = gbaudio_module_disable_tx(module, dai_id);
 	} else if (w->id == snd_soc_dapm_aif_out) {
 		if (enable)
-			ret = gbaudio_module_enable_rx(codec, module);
+			ret = gbaudio_module_enable_rx(codec, module, dai_id);
 		else
-			ret = gbaudio_module_disable_rx(codec, module);
+			ret = gbaudio_module_disable_rx(module, dai_id);
 	}
 
 	mutex_unlock(&codec->lock);
@@ -447,7 +445,7 @@ static int gbcodec_hw_params(struct snd_pcm_substream *substream,
 
 	/* find the data connection */
 	list_for_each_entry(module, &codec->module_list, list) {
-		data = find_data(module, dai->name);
+		data = find_data(module, dai->id);
 		if (data)
 			break;
 	}
@@ -496,7 +494,7 @@ static int gbcodec_prepare(struct snd_pcm_substream *substream,
 
 	list_for_each_entry(module, &codec->module_list, list) {
 		/* find the dai */
-		data = find_data(module, dai->name);
+		data = find_data(module, dai->id);
 		if (data)
 			break;
 	}
@@ -554,7 +552,7 @@ static int gbcodec_mute_stream(struct snd_soc_dai *dai, int mute, int stream)
 
 	list_for_each_entry(module, &codec->module_list, list) {
 		/* find the dai */
-		data = find_data(module, dai->name);
+		data = find_data(module, dai->id);
 		if (data)
 			break;
 	}
@@ -764,7 +762,7 @@ static void gbaudio_codec_cleanup(struct gbaudio_module_info *module)
 	dev_dbg(gbcodec->dev, "%s: removed, cleanup APBridge\n", module->name);
 	if (pb_state == GBAUDIO_CODEC_START) {
 		/* cleanup PB path, only APBridge specific */
-		data = find_data(module, gbcodec->stream[0].dai_name);
+		data = find_data(module, 1);
 		if (!data) {
 			dev_err(gbcodec->dev, "%s: Missing data pointer\n",
 				__func__);
@@ -790,7 +788,7 @@ static void gbaudio_codec_cleanup(struct gbaudio_module_info *module)
 
 	if (cap_state == GBAUDIO_CODEC_START) {
 		/* cleanup CAP path, only APBridge specific */
-		data = find_data(module, gbcodec->stream[1].dai_name);
+		data = find_data(module, 1);
 		if (!data) {
 			dev_err(gbcodec->dev, "%s: Missing data pointer\n",
 				__func__);

commit 487dcbd6ba46548f8f24dbd75423785ec8153712
Author: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
Date:   Thu Aug 4 15:14:33 2016 +0530

    greybus: audio: Use AIF widget to enable path between module & APB
    
    Currently, SPK Amp switch is used to identify when to enable data path
    between module and APB. With headset, other switch controls added, it is
    not possible to use this switch to control data path. Instead path
    should be established based on AIF widget.
    
    Signed-off-by: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
    Reviewed-by: Mark Greer <mgreer@animalcreek.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/audio_codec.c b/drivers/staging/greybus/audio_codec.c
index e2a0c16397cd..3067c1a7ab39 100644
--- a/drivers/staging/greybus/audio_codec.c
+++ b/drivers/staging/greybus/audio_codec.c
@@ -30,16 +30,6 @@ find_data(struct gbaudio_module_info *module, const char *name)
 	return NULL;
 }
 
-static int find_stream(const char *name)
-{
-	int stream = 0;
-
-	if (strnstr(name, "SPK Amp", NAME_SIZE))
-		stream |= GB_PLAYBACK;
-
-	return stream;
-}
-
 static int gbaudio_module_enable_tx(struct gbaudio_codec_info *codec,
 				    struct gbaudio_module_info *module)
 {
@@ -336,33 +326,30 @@ int gbaudio_module_update(struct gbaudio_codec_info *codec,
 			  struct snd_soc_dapm_widget *w,
 			  struct gbaudio_module_info *module, int enable)
 {
-	int stream, ret = 0;
+	int ret = 0;
 	const char *w_name = w->name;
 
 	dev_dbg(module->dev, "%s:Module update %s sequence\n", w_name,
 		enable ? "Enable":"Disable");
 
-	stream = find_stream(w_name);
-	if (!stream) {
+	if ((w->id != snd_soc_dapm_aif_in) && (w->id != snd_soc_dapm_aif_out)){
 		dev_dbg(codec->dev, "No action required for %s\n", w_name);
 		return 0;
 	}
 
 	mutex_lock(&codec->lock);
-	if (stream & GB_PLAYBACK) {
+	if (w->id == snd_soc_dapm_aif_in) {
 		if (enable)
 			ret = gbaudio_module_enable_tx(codec, module);
 		else
 			ret = gbaudio_module_disable_tx(codec, module);
-	}
-
-	/* check if capture active */
-	if (stream & GB_CAPTURE) {
+	} else if (w->id == snd_soc_dapm_aif_out) {
 		if (enable)
 			ret = gbaudio_module_enable_rx(codec, module);
 		else
 			ret = gbaudio_module_disable_rx(codec, module);
 	}
+
 	mutex_unlock(&codec->lock);
 
 	return ret;

commit 4ffca62a051c3e1722bcaf6a367b419e6e5e40e0
Author: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
Date:   Thu Aug 4 15:14:32 2016 +0530

    greybus: audio: Update parameters for gbaudio_module_update API
    
    Earlier, module path was enabled based on module's control switch e.g.
    'SPK Amp switch'.  Thus widget's name was sufficient to parse and
    identify the direction. Now individual modules' path will be enabled
    based on AIF widget status. So, it is required to get complete widget
    details, say w->type is used to identify direction (playback/capture)
    and w->sname is used to identify module's DATA connection used for
    communication via greybus.
    
    Signed-off-by: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
    Reviewed-by: Mark Greer <mgreer@animalcreek.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/audio_codec.c b/drivers/staging/greybus/audio_codec.c
index a6f843784f2f..e2a0c16397cd 100644
--- a/drivers/staging/greybus/audio_codec.c
+++ b/drivers/staging/greybus/audio_codec.c
@@ -333,10 +333,11 @@ static int gbaudio_module_disable_rx(struct gbaudio_codec_info *codec,
 }
 
 int gbaudio_module_update(struct gbaudio_codec_info *codec,
-				 const char *w_name,
-				 struct gbaudio_module_info *module, int enable)
+			  struct snd_soc_dapm_widget *w,
+			  struct gbaudio_module_info *module, int enable)
 {
 	int stream, ret = 0;
+	const char *w_name = w->name;
 
 	dev_dbg(module->dev, "%s:Module update %s sequence\n", w_name,
 		enable ? "Enable":"Disable");

commit 1568159868f6b6c4ab17aa28ef4d5d4fc02317f1
Author: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
Date:   Thu Aug 4 15:14:31 2016 +0530

    greybus: audio: Update dai_driver table with appropriate fields
    
    Currently, the stream name for the DAI driver is generically set to "GB
    Audio Playback" and "GB Audio Capture". This is OK since we use a single
    interface on APB1 but that could change in the future.  Update the DAI
    driver table entries to properly reflect the interface used.
    
    Signed-off-by: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
    Reviewed-by: Mark Greer <mgreer@animalcreek.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/audio_codec.c b/drivers/staging/greybus/audio_codec.c
index 70b9a797afc8..a6f843784f2f 100644
--- a/drivers/staging/greybus/audio_codec.c
+++ b/drivers/staging/greybus/audio_codec.c
@@ -950,10 +950,10 @@ static unsigned int gbcodec_read(struct snd_soc_codec *codec,
 
 static struct snd_soc_dai_driver gbaudio_dai[] = {
 	{
-		.name = "greybus-apb1",
+		.name = "apb-i2s0",
 		.id = 0,
 		.playback = {
-			.stream_name = "GB Audio Playback",
+			.stream_name = "I2S 0 Playback",
 			.rates = SNDRV_PCM_RATE_48000,
 			.formats = SNDRV_PCM_FORMAT_S16_LE,
 			.rate_max = 48000,
@@ -962,7 +962,7 @@ static struct snd_soc_dai_driver gbaudio_dai[] = {
 			.channels_max = 2,
 		},
 		.capture = {
-			.stream_name = "GB Audio Capture",
+			.stream_name = "I2S 0 Capture",
 			.rates = SNDRV_PCM_RATE_48000,
 			.formats = SNDRV_PCM_FORMAT_S16_LE,
 			.rate_max = 48000,

commit aaef32a6cc552d50b86fcf9c5b2105f08c048cdc
Author: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
Date:   Thu Aug 4 15:14:30 2016 +0530

    greybus: audio: Split helper APIs based on stream direction
    
    Now, module is enabled/disabled based on widget event only and not
    during startup/shutdown callbacks. Thus, we needn't compare codec_state
    in enable/disable module helper APIs. Also, these can be further
    simplified based on stream direction.
    
    Signed-off-by: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
    Reviewed-by: Mark Greer <mgreer@animalcreek.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/audio_codec.c b/drivers/staging/greybus/audio_codec.c
index 0bcd3d455f0c..70b9a797afc8 100644
--- a/drivers/staging/greybus/audio_codec.c
+++ b/drivers/staging/greybus/audio_codec.c
@@ -40,239 +40,296 @@ static int find_stream(const char *name)
 	return stream;
 }
 
-static int gbaudio_module_disable(struct gbaudio_codec_info *codec,
-				  struct gbaudio_module_info *module,
-				  int dir)
+static int gbaudio_module_enable_tx(struct gbaudio_codec_info *codec,
+				    struct gbaudio_module_info *module)
 {
-	int ret = 0;
-	uint16_t data_cport, cportid, i2s_port;
-	int codec_state, module_state;
+	int module_state, ret = 0;
+	uint16_t data_cport, i2s_port, cportid;
+	uint8_t sig_bits, channels;
+	uint32_t format, rate;
 	struct gbaudio_data_connection *data;
 	const char *dai_name;
 
-	mutex_lock(&codec->lock);
+	dai_name = codec->stream[SNDRV_PCM_STREAM_PLAYBACK].dai_name;
+	format = codec->stream[SNDRV_PCM_STREAM_PLAYBACK].format;
+	channels = codec->stream[SNDRV_PCM_STREAM_PLAYBACK].channels;
+	rate = codec->stream[SNDRV_PCM_STREAM_PLAYBACK].rate;
+	sig_bits = codec->stream[SNDRV_PCM_STREAM_PLAYBACK].sig_bits;
 
-	codec_state = codec->stream[dir].state;
-	if (codec_state == GBAUDIO_CODEC_SHUTDOWN) {
-		mutex_unlock(&codec->lock);
-		return 0;
+	module_state = module->ctrlstate[SNDRV_PCM_STREAM_PLAYBACK];
+
+	/* find the dai */
+	data = find_data(module, dai_name);
+	if (!data) {
+		dev_err(module->dev, "%s:DATA connection missing\n", dai_name);
+		return -ENODEV;
+	}
+
+	/* register cport */
+	if (module_state < GBAUDIO_CODEC_STARTUP) {
+		i2s_port = 0;	/* fixed for now */
+		cportid = data->connection->hd_cport_id;
+		ret = gb_audio_apbridgea_register_cport(data->connection,
+						i2s_port, cportid,
+						AUDIO_APBRIDGEA_DIRECTION_TX);
+		if (ret) {
+			dev_err_ratelimited(module->dev,
+					    "reg_cport failed:%d\n", ret);
+			return ret;
+		}
+		module->ctrlstate[SNDRV_PCM_STREAM_PLAYBACK] =
+			GBAUDIO_CODEC_STARTUP;
+		dev_dbg(module->dev, "Dynamic Register %s:%d DAI\n", dai_name,
+			cportid);
+	}
+
+	/* hw_params */
+	if (module_state < GBAUDIO_CODEC_HWPARAMS) {
+		data_cport = data->connection->intf_cport_id;
+		ret = gb_audio_gb_set_pcm(module->mgmt_connection, data_cport,
+					  format, rate, channels, sig_bits);
+		if (ret) {
+			dev_err_ratelimited(module->dev, "set_pcm failed:%d\n",
+					    ret);
+			return ret;
+		}
+		module->ctrlstate[SNDRV_PCM_STREAM_PLAYBACK] =
+			GBAUDIO_CODEC_HWPARAMS;
+		dev_dbg(module->dev, "Dynamic hw_params %s:%d DAI\n", dai_name,
+			data_cport);
+	}
+
+	/* prepare */
+	if (module_state < GBAUDIO_CODEC_PREPARE) {
+		data_cport = data->connection->intf_cport_id;
+		ret = gb_audio_gb_set_tx_data_size(module->mgmt_connection,
+						   data_cport, 192);
+		if (ret) {
+			dev_err_ratelimited(module->dev,
+					    "set_tx_data_size failed:%d\n",
+					    ret);
+			return ret;
+		}
+		ret = gb_audio_gb_activate_tx(module->mgmt_connection,
+					      data_cport);
+		if (ret) {
+			dev_err_ratelimited(module->dev,
+					    "activate_tx failed:%d\n", ret);
+			return ret;
+		}
+		module->ctrlstate[SNDRV_PCM_STREAM_PLAYBACK] =
+			GBAUDIO_CODEC_PREPARE;
+		dev_dbg(module->dev, "Dynamic prepare %s:%d DAI\n", dai_name,
+			data_cport);
 	}
 
-	dai_name = codec->stream[dir].dai_name;
+	return 0;
+}
+
+static int gbaudio_module_disable_tx(struct gbaudio_codec_info *codec,
+				     struct gbaudio_module_info *module)
+{
+	int ret;
+	uint16_t data_cport, cportid, i2s_port;
+	int module_state;
+	struct gbaudio_data_connection *data;
+	const char *dai_name;
+
+	dai_name = codec->stream[SNDRV_PCM_STREAM_PLAYBACK].dai_name;
+	module_state = module->ctrlstate[SNDRV_PCM_STREAM_PLAYBACK];
 
-	module_state = module->ctrlstate[dir];
 	if (module_state == GBAUDIO_CODEC_SHUTDOWN) {
-		dev_dbg(codec->dev, "%s: module already configured\n",
-			module->name);
-		mutex_unlock(&codec->lock);
+		dev_dbg(module->dev, "module already configured\n");
 		return 0;
 	}
 
 	/* find the dai */
 	data = find_data(module, dai_name);
 	if (!data) {
-		dev_err(codec->dev, "%s:%s DATA connection missing\n",
-			dai_name, module->name);
-		mutex_unlock(&codec->lock);
+		dev_err(module->dev, "%s:DATA connection missing\n", dai_name);
 		return -ENODEV;
 	}
-	if (codec_state > GBAUDIO_CODEC_HWPARAMS) {
+
+	if (module_state > GBAUDIO_CODEC_HWPARAMS) {
 		data_cport = data->connection->intf_cport_id;
-		switch(dir) {
-		case SNDRV_PCM_STREAM_CAPTURE:
-			ret = gb_audio_gb_deactivate_rx(
-						module->mgmt_connection,
-						data_cport);
-			break;
-		case SNDRV_PCM_STREAM_PLAYBACK:
-			ret = gb_audio_gb_deactivate_tx(
-						module->mgmt_connection,
+		ret = gb_audio_gb_deactivate_tx(module->mgmt_connection,
 						data_cport);
-			break;
-		default:
-			ret = -EINVAL;
-		}
 		if (ret) {
-			dev_err_ratelimited(codec->dev, "deactivate for %s failed:%d\n",
-				module->name, ret);
-			goto func_exit;
+			dev_err_ratelimited(module->dev,
+					    "deactivate_tx failed:%d\n", ret);
+			return ret;
 		}
-		dev_dbg(codec->dev, "Dynamic deactivate %s:%d DAI\n", dai_name,
+		dev_dbg(module->dev, "Dynamic deactivate %s:%d DAI\n", dai_name,
 			data_cport);
+		module->ctrlstate[SNDRV_PCM_STREAM_PLAYBACK] =
+			GBAUDIO_CODEC_HWPARAMS;
 	}
-	if (codec_state > GBAUDIO_CODEC_SHUTDOWN) {
+
+	if (module_state > GBAUDIO_CODEC_SHUTDOWN) {
+		i2s_port = 0;	/* fixed for now */
 		cportid = data->connection->hd_cport_id;
-		switch(dir) {
-		case SNDRV_PCM_STREAM_CAPTURE:
-			ret = gb_audio_apbridgea_unregister_cport(
-						data->connection,
-						i2s_port, cportid,
-						AUDIO_APBRIDGEA_DIRECTION_RX);
-			break;
-		case SNDRV_PCM_STREAM_PLAYBACK:
-			ret = gb_audio_apbridgea_unregister_cport(
-						data->connection,
+		ret = gb_audio_apbridgea_unregister_cport(data->connection,
 						i2s_port, cportid,
 						AUDIO_APBRIDGEA_DIRECTION_TX);
-			break;
-		default:
-			ret = -EINVAL;
-		}
 		if (ret) {
-			dev_err_ratelimited(codec->dev, "unregister_cport for %s failed:%d\n",
-				module->name, ret);
-			goto func_exit;
+			dev_err_ratelimited(module->dev,
+					    "unregister_cport failed:%d\n",
+					    ret);
+			return ret;
 		}
-		dev_dbg(codec->dev, "Dynamic Unregister %s:%d DAI\n", dai_name,
+		dev_dbg(module->dev, "Dynamic Unregister %s:%d DAI\n", dai_name,
 			cportid);
+		module->ctrlstate[SNDRV_PCM_STREAM_PLAYBACK] =
+			GBAUDIO_CODEC_SHUTDOWN;
 	}
-	module->ctrlstate[dir] = GBAUDIO_CODEC_SHUTDOWN;
 
-func_exit:
-	mutex_unlock(&codec->lock);
-	return ret;
+	return 0;
 }
 
-static int gbaudio_module_enable(struct gbaudio_codec_info *codec,
-				 struct gbaudio_module_info *module, int dir)
+static int gbaudio_module_enable_rx(struct gbaudio_codec_info *codec,
+				    struct gbaudio_module_info *module)
 {
-	int ret = 0;
-	__u16 i2s_port, cportid;
-	int codec_state, module_state;
-	uint16_t data_cport;
+	int module_state, ret = 0;
+	uint16_t data_cport, i2s_port, cportid;
 	uint8_t sig_bits, channels;
 	uint32_t format, rate;
 	struct gbaudio_data_connection *data;
 	const char *dai_name;
 
-	mutex_lock(&codec->lock);
-
-	codec_state = codec->stream[dir].state;
-	if (codec_state == GBAUDIO_CODEC_SHUTDOWN) {
-		mutex_unlock(&codec->lock);
-		return 0;
-	}
-
-	dai_name = codec->stream[dir].dai_name;
-	format = codec->stream[dir].format;
-	channels = codec->stream[dir].channels;
-	rate = codec->stream[dir].rate;
-	sig_bits = codec->stream[dir].sig_bits;
-
-	module_state = module->ctrlstate[dir];
-	if (module_state == codec_state) {
-		dev_dbg(codec->dev, "%s: module already configured\n",
-			module->name);
-		mutex_unlock(&codec->lock);
-		return 0;
-	}
+	dai_name = codec->stream[SNDRV_PCM_STREAM_CAPTURE].dai_name;
+	format = codec->stream[SNDRV_PCM_STREAM_CAPTURE].format;
+	channels = codec->stream[SNDRV_PCM_STREAM_CAPTURE].channels;
+	rate = codec->stream[SNDRV_PCM_STREAM_CAPTURE].rate;
+	sig_bits = codec->stream[SNDRV_PCM_STREAM_CAPTURE].sig_bits;
+	module_state = module->ctrlstate[SNDRV_PCM_STREAM_CAPTURE];
 
 	/* find the dai */
 	data = find_data(module, dai_name);
 	if (!data) {
-		dev_err(codec->dev, "%s:%s DATA connection missing\n",
-			dai_name, module->name);
-		mutex_unlock(&codec->lock);
+		dev_err(module->dev, "%s:DATA connection missing\n", dai_name);
 		return -ENODEV;
 	}
 
 	/* register cport */
-	if (module_state < codec_state) {
+	if (module_state < GBAUDIO_CODEC_STARTUP) {
 		i2s_port = 0;	/* fixed for now */
 		cportid = data->connection->hd_cport_id;
-		switch(dir) {
-		case SNDRV_PCM_STREAM_CAPTURE:
-				ret = gb_audio_apbridgea_register_cport(
-						data->connection,
-						i2s_port, cportid,
-						AUDIO_APBRIDGEA_DIRECTION_RX);
-				break;
-		case SNDRV_PCM_STREAM_PLAYBACK:
-				ret = gb_audio_apbridgea_register_cport(
-						data->connection,
+		ret = gb_audio_apbridgea_register_cport(data->connection,
 						i2s_port, cportid,
 						AUDIO_APBRIDGEA_DIRECTION_TX);
-				break;
-		default:
-				ret = -EINVAL;
-		}
 		if (ret) {
-			dev_err_ratelimited(codec->dev, "reg_cport for %s\n", module->name);
-			goto func_exit;
+			dev_err_ratelimited(module->dev,
+					    "reg_cport failed:%d\n", ret);
+			return ret;
 		}
-		module_state = GBAUDIO_CODEC_STARTUP;
-		dev_dbg(codec->dev, "Dynamic Register %s:%d DAI\n", dai_name,
+		module->ctrlstate[SNDRV_PCM_STREAM_CAPTURE] =
+			GBAUDIO_CODEC_STARTUP;
+		dev_dbg(module->dev, "Dynamic Register %s:%d DAI\n", dai_name,
 			cportid);
 	}
 
 	/* hw_params */
-	if (module_state < codec_state) {
+	if (module_state < GBAUDIO_CODEC_HWPARAMS) {
 		data_cport = data->connection->intf_cport_id;
 		ret = gb_audio_gb_set_pcm(module->mgmt_connection, data_cport,
 					  format, rate, channels, sig_bits);
 		if (ret) {
-			dev_err_ratelimited(codec->dev, "set_pcm for %s\n", module->name);
-			goto func_exit;
+			dev_err_ratelimited(module->dev, "set_pcm failed:%d\n",
+					    ret);
+			return ret;
 		}
-		module_state = GBAUDIO_CODEC_HWPARAMS;
-		dev_dbg(codec->dev, "Dynamic hw_params %s:%d DAI\n", dai_name,
+		module->ctrlstate[SNDRV_PCM_STREAM_CAPTURE] =
+			GBAUDIO_CODEC_HWPARAMS;
+		dev_dbg(module->dev, "Dynamic hw_params %s:%d DAI\n", dai_name,
 			data_cport);
 	}
 
 	/* prepare */
-	if (module_state < codec_state) {
+	if (module_state < GBAUDIO_CODEC_PREPARE) {
 		data_cport = data->connection->intf_cport_id;
-		switch(dir) {
-		case SNDRV_PCM_STREAM_CAPTURE:
-			ret = gb_audio_gb_set_rx_data_size(
-						module->mgmt_connection,
-						data_cport, 192);
-			if (ret) {
-				dev_err_ratelimited(codec->dev,
-					"set_rx_data_size for %s\n",
-					module->name);
-				goto func_exit;
-			}
-			ret = gb_audio_gb_activate_rx(module->mgmt_connection,
-						      data_cport);
-			if (ret) {
-				dev_err_ratelimited(codec->dev, "activate_rx for %s\n",
-					module->name);
-				goto func_exit;
-			}
-			break;
-		case SNDRV_PCM_STREAM_PLAYBACK:
-			ret = gb_audio_gb_set_tx_data_size(
-						module->mgmt_connection,
-						data_cport, 192);
-			if (ret) {
-				dev_err_ratelimited(codec->dev,
-					"set_tx_data_size for %s\n",
-					module->name);
-				goto func_exit;
-			}
-			ret = gb_audio_gb_activate_tx(module->mgmt_connection,
-						      data_cport);
-			if (ret) {
-				dev_err_ratelimited(codec->dev, "activate_tx for %s\n",
-					module->name);
-				goto func_exit;
-			}
-			break;
-		default:
-			dev_err(codec->dev, "Inavlid stream direction\n");
-			ret = -EINVAL;
-			goto func_exit;
+		ret = gb_audio_gb_set_rx_data_size(module->mgmt_connection,
+						   data_cport, 192);
+		if (ret) {
+			dev_err_ratelimited(module->dev,
+					    "set_rx_data_size failed:%d\n",
+					    ret);
+			return ret;
 		}
-		module_state = GBAUDIO_CODEC_PREPARE;
-		dev_dbg(codec->dev, "Dynamic prepare %s:%d DAI\n", dai_name,
+		ret = gb_audio_gb_activate_rx(module->mgmt_connection,
+					      data_cport);
+		if (ret) {
+			dev_err_ratelimited(module->dev,
+					    "activate_rx failed:%d\n", ret);
+			return ret;
+		}
+		module->ctrlstate[SNDRV_PCM_STREAM_CAPTURE] =
+			GBAUDIO_CODEC_PREPARE;
+		dev_dbg(module->dev, "Dynamic prepare %s:%d DAI\n", dai_name,
 			data_cport);
 	}
 
-func_exit:
-	module->ctrlstate[dir] = module_state;
-	mutex_unlock(&codec->lock);
-	return ret;
+	return 0;
+}
+
+static int gbaudio_module_disable_rx(struct gbaudio_codec_info *codec,
+				     struct gbaudio_module_info *module)
+{
+	int ret;
+	uint16_t data_cport, cportid, i2s_port;
+	int module_state;
+	struct gbaudio_data_connection *data;
+	const char *dai_name;
+
+	dai_name = codec->stream[SNDRV_PCM_STREAM_CAPTURE].dai_name;
+	module_state = module->ctrlstate[SNDRV_PCM_STREAM_CAPTURE];
+
+	if (module_state == GBAUDIO_CODEC_SHUTDOWN) {
+		dev_dbg(module->dev, "%s: module already configured\n",
+			module->name);
+		return 0;
+	}
+
+	/* find the dai */
+	data = find_data(module, dai_name);
+	if (!data) {
+		dev_err(module->dev, "%s:DATA connection missing\n", dai_name);
+		return -ENODEV;
+	}
+
+	if (module_state > GBAUDIO_CODEC_HWPARAMS) {
+		data_cport = data->connection->intf_cport_id;
+		ret = gb_audio_gb_deactivate_rx(module->mgmt_connection,
+						data_cport);
+		if (ret) {
+			dev_err_ratelimited(module->dev,
+					    "deactivate_rx failed:%d\n", ret);
+			return ret;
+		}
+		dev_dbg(module->dev, "Dynamic deactivate %s:%d DAI\n", dai_name,
+			data_cport);
+		module->ctrlstate[SNDRV_PCM_STREAM_CAPTURE] =
+			GBAUDIO_CODEC_HWPARAMS;
+	}
+
+	if (module_state > GBAUDIO_CODEC_SHUTDOWN) {
+		i2s_port = 0;	/* fixed for now */
+		cportid = data->connection->hd_cport_id;
+		ret = gb_audio_apbridgea_unregister_cport(data->connection,
+						i2s_port, cportid,
+						AUDIO_APBRIDGEA_DIRECTION_RX);
+		if (ret) {
+			dev_err_ratelimited(module->dev,
+					    "unregister_cport failed:%d\n",
+					    ret);
+			return ret;
+		}
+		dev_dbg(module->dev, "Dynamic Unregister %s:%d DAI\n", dai_name,
+			cportid);
+		module->ctrlstate[SNDRV_PCM_STREAM_CAPTURE] =
+			GBAUDIO_CODEC_SHUTDOWN;
+	}
+
+	return 0;
 }
 
 int gbaudio_module_update(struct gbaudio_codec_info *codec,
@@ -280,9 +337,8 @@ int gbaudio_module_update(struct gbaudio_codec_info *codec,
 				 struct gbaudio_module_info *module, int enable)
 {
 	int stream, ret = 0;
-	int pb_state, cap_state;
 
-	dev_dbg(module->dev, "Module update %s sequence\n",
+	dev_dbg(module->dev, "%s:Module update %s sequence\n", w_name,
 		enable ? "Enable":"Disable");
 
 	stream = find_stream(w_name);
@@ -291,27 +347,22 @@ int gbaudio_module_update(struct gbaudio_codec_info *codec,
 		return 0;
 	}
 
-	/* check if playback active */
-	pb_state = codec->stream[SNDRV_PCM_STREAM_PLAYBACK].state;
-	if ((stream & GB_PLAYBACK) && (pb_state > GBAUDIO_CODEC_SHUTDOWN)) {
+	mutex_lock(&codec->lock);
+	if (stream & GB_PLAYBACK) {
 		if (enable)
-			ret = gbaudio_module_enable(codec, module,
-						    SNDRV_PCM_STREAM_PLAYBACK);
+			ret = gbaudio_module_enable_tx(codec, module);
 		else
-			ret = gbaudio_module_disable(codec, module,
-						     SNDRV_PCM_STREAM_PLAYBACK);
+			ret = gbaudio_module_disable_tx(codec, module);
 	}
 
 	/* check if capture active */
-	cap_state = codec->stream[SNDRV_PCM_STREAM_CAPTURE].state;
-	if ((stream & GB_CAPTURE) && (cap_state > GBAUDIO_CODEC_SHUTDOWN)) {
+	if (stream & GB_CAPTURE) {
 		if (enable)
-			ret = gbaudio_module_enable(codec, module,
-						    SNDRV_PCM_STREAM_CAPTURE);
+			ret = gbaudio_module_enable_rx(codec, module);
 		else
-			ret = gbaudio_module_disable(codec, module,
-						     SNDRV_PCM_STREAM_CAPTURE);
+			ret = gbaudio_module_disable_rx(codec, module);
 	}
+	mutex_unlock(&codec->lock);
 
 	return ret;
 }

commit ce9413062f8e2366916beebbfa8e73c6ff1a2c8c
Author: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
Date:   Thu Aug 4 15:14:29 2016 +0530

    greybus: audio: Enable audio path based on control switch state only
    
    As per current implementation, audio data is played from each individual
    SPK module connected to endo frame. This is not a valid requirement in
    case of capture/headset path. So, provide a mechanism to enable
    individual module path based on it's control switch state.
    
    Signed-off-by: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
    Reviewed-by: Mark Greer <mgreer@animalcreek.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/audio_codec.c b/drivers/staging/greybus/audio_codec.c
index 9b98e9c282da..0bcd3d455f0c 100644
--- a/drivers/staging/greybus/audio_codec.c
+++ b/drivers/staging/greybus/audio_codec.c
@@ -323,11 +323,6 @@ EXPORT_SYMBOL(gbaudio_module_update);
 static int gbcodec_startup(struct snd_pcm_substream *substream,
 			   struct snd_soc_dai *dai)
 {
-	int ret = 0;
-	__u16 i2s_port, cportid;
-	int state;
-	struct gbaudio_data_connection *data;
-	struct gbaudio_module_info *module;
 	struct gbaudio_codec_info *codec = dev_get_drvdata(dai->dev);
 
 	mutex_lock(&codec->lock);
@@ -338,164 +333,26 @@ static int gbcodec_startup(struct snd_pcm_substream *substream,
 		return -ENODEV;
 	}
 
-	state = codec->stream[substream->stream].state;
-	list_for_each_entry(module, &codec->module_list, list) {
-		/* find the dai */
-		data = find_data(module, dai->name);
-		if (!data) {
-			dev_err(dai->dev, "%s:%s DATA connection missing\n",
-				dai->name, module->name);
-			continue;
-		}
-
-		/* register cport */
-		i2s_port = 0;	/* fixed for now */
-		cportid = data->connection->hd_cport_id;
-		switch (substream->stream) {
-		case SNDRV_PCM_STREAM_CAPTURE:
-			ret = gb_audio_apbridgea_register_cport(
-						data->connection,
-						i2s_port, cportid,
-						AUDIO_APBRIDGEA_DIRECTION_RX);
-			break;
-		case SNDRV_PCM_STREAM_PLAYBACK:
-			ret = gb_audio_apbridgea_register_cport(
-						data->connection,
-						i2s_port, cportid,
-						AUDIO_APBRIDGEA_DIRECTION_TX);
-			break;
-		default:
-			dev_err(dai->dev, "Inavlid stream\n");
-			mutex_unlock(&codec->lock);
-			return -EINVAL;
-		}
-		dev_dbg(dai->dev, "Register %s:%d DAI, ret:%d\n", dai->name,
-			cportid, ret);
-		state = GBAUDIO_CODEC_STARTUP;
-		module->ctrlstate[substream->stream] = state;
-		dev_dbg(dai->dev, "%s: state:%d\n", module->name, state);
-	}
-	codec->stream[substream->stream].state = state;
+	codec->stream[substream->stream].state = GBAUDIO_CODEC_STARTUP;
 	codec->stream[substream->stream].dai_name = dai->name;
 	mutex_unlock(&codec->lock);
 	/* to prevent suspend in case of active audio */
 	pm_stay_awake(dai->dev);
 
-	return ret;
-}
-
-static int gbmodule_shutdown_tx(struct gbaudio_module_info *module,
-				struct gbaudio_data_connection *data,
-				int codec_state, struct device *dev)
-{
-	int ret, module_state;
-	__u16 i2s_port, cportid;
-
-	module_state = module->ctrlstate[0];
-	if (module_state == GBAUDIO_CODEC_SHUTDOWN) {
-		dev_dbg(dev, "%s: module already configured\n",
-			module->name);
-		return 0;
-	}
-
-	/* deactivate */
-	cportid = data->connection->intf_cport_id;
-	if (module_state >= GBAUDIO_CODEC_PREPARE) {
-		ret = gb_audio_gb_deactivate_tx(module->mgmt_connection,
-						cportid);
-		if (ret)
-			return ret;
-	}
-
-	/* unregister cport */
-	i2s_port = 0;	/* fixed for now */
-	cportid = data->connection->hd_cport_id;
-	ret = gb_audio_apbridgea_unregister_cport(data->connection, i2s_port,
-						  cportid,
-						  AUDIO_APBRIDGEA_DIRECTION_TX);
-
-	return ret;
-}
-
-static int gbmodule_shutdown_rx(struct gbaudio_module_info *module,
-				struct gbaudio_data_connection *data,
-				int codec_state, struct device *dev)
-{
-	int ret, module_state;
-	__u16 i2s_port, cportid;
-
-	module_state = module->ctrlstate[1];
-	if (module_state == GBAUDIO_CODEC_SHUTDOWN) {
-		dev_dbg(dev, "%s: module already configured\n",
-			module->name);
-		return 0;
-	}
-
-	/* deactivate */
-	cportid = data->connection->intf_cport_id;
-	if (module_state >= GBAUDIO_CODEC_PREPARE) {
-		ret = gb_audio_gb_deactivate_rx(module->mgmt_connection,
-						cportid);
-		if (ret)
-			return ret;
-	}
-
-	/* unregister cport */
-	i2s_port = 0;	/* fixed for now */
-	cportid = data->connection->hd_cport_id;
-	ret = gb_audio_apbridgea_unregister_cport(data->connection, i2s_port,
-						  cportid,
-						  AUDIO_APBRIDGEA_DIRECTION_RX);
-
-	return ret;
+	return 0;
 }
 
 static void gbcodec_shutdown(struct snd_pcm_substream *substream,
 			     struct snd_soc_dai *dai)
 {
-	int ret, state;
-	struct gbaudio_module_info *module;
-	struct gbaudio_data_connection *data;
 	struct gbaudio_codec_info *codec = dev_get_drvdata(dai->dev);
 
 	mutex_lock(&codec->lock);
 
-	if (list_empty(&codec->module_list)) {
-		dev_err(codec->dev, "No codec module available\n");
-		codec->stream[substream->stream].state = GBAUDIO_CODEC_SHUTDOWN;
-		codec->stream[substream->stream].dai_name = NULL;
-		mutex_unlock(&codec->lock);
-		pm_relax(dai->dev);
-		return;
-	}
+	if (list_empty(&codec->module_list))
+		dev_info(codec->dev, "No codec module available during shutdown\n");
 
-	state = codec->stream[substream->stream].state;
-	list_for_each_entry(module, &codec->module_list, list) {
-		/* find the dai */
-		data = find_data(module, dai->name);
-		if (!data) {
-			dev_err(dai->dev, "%s:%s DATA connection missing\n",
-				dai->name, module->name);
-			continue;
-		}
-
-		switch (substream->stream) {
-		case SNDRV_PCM_STREAM_PLAYBACK:
-			ret = gbmodule_shutdown_tx(module, data, state,
-						   dai->dev);
-			break;
-		case SNDRV_PCM_STREAM_CAPTURE:
-			ret = gbmodule_shutdown_rx(module, data, state,
-						   dai->dev);
-			break;
-		}
-		dev_dbg(dai->dev, "Unregister %s DAI, ret:%d\n", dai->name,
-			ret);
-		state = GBAUDIO_CODEC_SHUTDOWN;
-		module->ctrlstate[substream->stream] = state;
-		dev_dbg(dai->dev, "%s: state:%d\n", module->name, state);
-	}
-	codec->stream[substream->stream].state = state;
+	codec->stream[substream->stream].state = GBAUDIO_CODEC_SHUTDOWN;
 	codec->stream[substream->stream].dai_name = NULL;
 	mutex_unlock(&codec->lock);
 	pm_relax(dai->dev);
@@ -509,10 +366,8 @@ static int gbcodec_hw_params(struct snd_pcm_substream *substream,
 	int ret;
 	uint8_t sig_bits, channels;
 	uint32_t format, rate;
-	uint16_t data_cport;
 	struct gbaudio_module_info *module;
 	struct gbaudio_data_connection *data;
-	int state;
 	struct gbaudio_codec_info *codec = dev_get_drvdata(dai->dev);
 
 	mutex_lock(&codec->lock);
@@ -551,122 +406,37 @@ static int gbcodec_hw_params(struct snd_pcm_substream *substream,
 	}
 	format = GB_AUDIO_PCM_FMT_S16_LE;
 
-	state = codec->stream[substream->stream].state;
+	/* find the data connection */
 	list_for_each_entry(module, &codec->module_list, list) {
-		/* find the data connection */
 		data = find_data(module, dai->name);
-		if (!data) {
-			dev_err(dai->dev, "%s:%s DATA connection missing\n",
-				dai->name, module->name);
-			continue;
-		}
-
-		data_cport = data->connection->intf_cport_id;
-		/* XXX check impact of sig_bit
-		 * it should not change ideally
-		 */
-		dev_dbg(dai->dev,
-			"cport:%d, rate:%d, channel %d, format %d, sig_bits:%d\n",
-			data_cport, rate, channels, format, sig_bits);
-		ret = gb_audio_gb_set_pcm(module->mgmt_connection, data_cport,
-					  format, rate, channels, sig_bits);
-		if (ret) {
-			dev_err_ratelimited(dai->dev, "%d: Error during set_pcm\n", ret);
-			goto func_exit;
-		}
-		if (state < GBAUDIO_CODEC_HWPARAMS) {
-			ret = gb_audio_apbridgea_set_config(data->connection, 0,
-						AUDIO_APBRIDGEA_PCM_FMT_16,
-						AUDIO_APBRIDGEA_PCM_RATE_48000,
-						6144000);
-			if (ret) {
-				dev_err_ratelimited(dai->dev,
-					"%d: Error during set_config\n", ret);
-				goto func_exit;
-			}
-		}
-		state = GBAUDIO_CODEC_HWPARAMS;
-		module->ctrlstate[substream->stream] = state;
-		dev_dbg(dai->dev, "%s: state:%d\n", module->name, state);
+		if (data)
+			break;
 	}
-	codec->stream[substream->stream].state = state;
-	codec->stream[substream->stream].format = format;
-	codec->stream[substream->stream].rate = rate;
-	codec->stream[substream->stream].channels = channels;
-	codec->stream[substream->stream].sig_bits = sig_bits;
-
-func_exit:
-	mutex_unlock(&codec->lock);
-	return ret;
-}
-
-static int gbmodule_prepare_tx(struct gbaudio_module_info *module,
-			       struct gbaudio_data_connection *data,
-			       int codec_state, struct device *dev)
-{
-	int ret;
-	uint16_t data_cport;
 
-	data_cport = data->connection->intf_cport_id;
-	ret = gb_audio_gb_set_tx_data_size(module->mgmt_connection, data_cport,
-					   192);
-	if (ret) {
-		dev_err_ratelimited(dev, "%d:Error during set_tx_data_size, cport:%d\n",
-			ret, data_cport);
-		return ret;
-	}
-	if (codec_state < GBAUDIO_CODEC_PREPARE) {
-		ret = gb_audio_apbridgea_set_tx_data_size(data->connection, 0,
-							  192);
-		if (ret) {
-			dev_err_ratelimited(dev,
-				"%d:Error during apbridgea set_tx_data_size, cport\n",
-				ret);
-			return ret;
-		}
+	if (!data) {
+		dev_err(dai->dev, "DATA connection missing\n");
+		mutex_unlock(&codec->lock);
+		return -EINVAL;
 	}
-	ret = gb_audio_gb_activate_tx(module->mgmt_connection,
-				      data_cport);
-	if (ret)
-		dev_err_ratelimited(dev, "%s:Error during activate stream,%d\n",
-			module->name, ret);
-
-	return ret;
-}
-
-static int gbmodule_prepare_rx(struct gbaudio_module_info *module,
-			       struct gbaudio_data_connection *data,
-			       int codec_state, struct device *dev)
-{
-	int ret;
-	uint16_t data_cport;
 
-	data_cport = data->connection->intf_cport_id;
-
-	ret = gb_audio_gb_set_rx_data_size(module->mgmt_connection, data_cport,
-					   192);
+	ret = gb_audio_apbridgea_set_config(data->connection, 0,
+					    AUDIO_APBRIDGEA_PCM_FMT_16,
+					    AUDIO_APBRIDGEA_PCM_RATE_48000,
+					    6144000);
 	if (ret) {
-		dev_err_ratelimited(dev, "%d:Error during set_rx_data_size, cport:%d\n",
-			ret, data_cport);
+		dev_err_ratelimited(dai->dev, "%d: Error during set_config\n",
+				    ret);
+		mutex_unlock(&codec->lock);
 		return ret;
 	}
-	if (codec_state < GBAUDIO_CODEC_PREPARE) {
-		ret = gb_audio_apbridgea_set_rx_data_size(data->connection, 0,
-							  192);
-		if (ret) {
-			dev_err_ratelimited(dev,
-				"%d:Error during apbridgea_set_rx_data_size\n",
-				ret);
-			return ret;
-		}
-	}
-	ret = gb_audio_gb_activate_rx(module->mgmt_connection,
-				      data_cport);
-	if (ret)
-		dev_err_ratelimited(dev, "%s:Error during activate stream,%d\n",
-			module->name, ret);
+	codec->stream[substream->stream].state = GBAUDIO_CODEC_HWPARAMS;
+	codec->stream[substream->stream].format = format;
+	codec->stream[substream->stream].rate = rate;
+	codec->stream[substream->stream].channels = channels;
+	codec->stream[substream->stream].sig_bits = sig_bits;
 
-	return ret;
+	mutex_unlock(&codec->lock);
+	return 0;
 }
 
 static int gbcodec_prepare(struct snd_pcm_substream *substream,
@@ -674,7 +444,6 @@ static int gbcodec_prepare(struct snd_pcm_substream *substream,
 {
 	int ret;
 	struct gbaudio_module_info *module;
-	int state;
 	struct gbaudio_data_connection *data;
 	struct gbaudio_codec_info *codec = dev_get_drvdata(dai->dev);
 
@@ -686,41 +455,38 @@ static int gbcodec_prepare(struct snd_pcm_substream *substream,
 		return -ENODEV;
 	}
 
-	state = codec->stream[substream->stream].state;
 	list_for_each_entry(module, &codec->module_list, list) {
 		/* find the dai */
 		data = find_data(module, dai->name);
-		if (!data) {
-			dev_err(dai->dev, "%s:%s DATA connection missing\n",
-				dai->name, module->name);
-			continue;
-		}
-
-		switch (substream->stream) {
-		case SNDRV_PCM_STREAM_PLAYBACK:
-			ret = gbmodule_prepare_tx(module, data, state,
-						  dai->dev);
-			break;
-		case SNDRV_PCM_STREAM_CAPTURE:
-			ret = gbmodule_prepare_rx(module, data, state,
-						  dai->dev);
+		if (data)
 			break;
-		}
-		if (ret == -ENODEV)
-			continue;
-		if (ret) {
-			goto func_exit;
-		}
+	}
+	if (!data) {
+		dev_err(dai->dev, "DATA connection missing\n");
+		mutex_unlock(&codec->lock);
+		return -ENODEV;
+	}
 
-		state = GBAUDIO_CODEC_PREPARE;
-		module->ctrlstate[substream->stream] = state;
-		dev_dbg(dai->dev, "%s: state:%d\n", module->name, state);
+	switch (substream->stream) {
+	case SNDRV_PCM_STREAM_PLAYBACK:
+		ret = gb_audio_apbridgea_set_tx_data_size(data->connection, 0,
+							  192);
+		break;
+	case SNDRV_PCM_STREAM_CAPTURE:
+		ret = gb_audio_apbridgea_set_rx_data_size(data->connection, 0,
+							  192);
+		break;
+	}
+	if (ret) {
+		mutex_unlock(&codec->lock);
+		dev_err_ratelimited(dai->dev, "set_data_size failed:%d\n",
+				     ret);
+		return ret;
 	}
-	codec->stream[substream->stream].state = state;
 
-func_exit:
+	codec->stream[substream->stream].state = GBAUDIO_CODEC_PREPARE;
 	mutex_unlock(&codec->lock);
-	return ret;
+	return 0;
 }
 
 static int gbcodec_mute_stream(struct snd_soc_dai *dai, int mute, int stream)

commit 90579d4b577154606a54cab9771e15a41867b79b
Author: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
Date:   Thu Aug 4 15:14:28 2016 +0530

    greybus: audio: Remove un-necessary goto statement
    
    For most of the helper functions, goto statement is widely used.  It was
    originally used with an intent of single exit point for the function
    with some cleanup required. This is no more the case. So, simplify code
    by avoiding un-necessary gotos.
    
    Signed-off-by: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
    Reviewed-by: Mark Greer <mgreer@animalcreek.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/audio_codec.c b/drivers/staging/greybus/audio_codec.c
index d7679e6bc364..9b98e9c282da 100644
--- a/drivers/staging/greybus/audio_codec.c
+++ b/drivers/staging/greybus/audio_codec.c
@@ -64,7 +64,8 @@ static int gbaudio_module_disable(struct gbaudio_codec_info *codec,
 	if (module_state == GBAUDIO_CODEC_SHUTDOWN) {
 		dev_dbg(codec->dev, "%s: module already configured\n",
 			module->name);
-		goto func_exit;
+		mutex_unlock(&codec->lock);
+		return 0;
 	}
 
 	/* find the dai */
@@ -72,8 +73,8 @@ static int gbaudio_module_disable(struct gbaudio_codec_info *codec,
 	if (!data) {
 		dev_err(codec->dev, "%s:%s DATA connection missing\n",
 			dai_name, module->name);
-		ret = -ENODEV;
-		goto func_exit;
+		mutex_unlock(&codec->lock);
+		return -ENODEV;
 	}
 	if (codec_state > GBAUDIO_CODEC_HWPARAMS) {
 		data_cport = data->connection->intf_cport_id;
@@ -162,7 +163,8 @@ static int gbaudio_module_enable(struct gbaudio_codec_info *codec,
 	if (module_state == codec_state) {
 		dev_dbg(codec->dev, "%s: module already configured\n",
 			module->name);
-		goto func_exit;
+		mutex_unlock(&codec->lock);
+		return 0;
 	}
 
 	/* find the dai */
@@ -170,8 +172,8 @@ static int gbaudio_module_enable(struct gbaudio_codec_info *codec,
 	if (!data) {
 		dev_err(codec->dev, "%s:%s DATA connection missing\n",
 			dai_name, module->name);
-		ret = -ENODEV;
-		goto func_exit;
+		mutex_unlock(&codec->lock);
+		return -ENODEV;
 	}
 
 	/* register cport */
@@ -754,8 +756,8 @@ static int gbcodec_mute_stream(struct snd_soc_dai *dai, int mute, int stream)
 	if (!data) {
 		dev_err(dai->dev, "%s:%s DATA connection missing\n",
 			dai->name, module->name);
-		ret = -ENODEV;
-		goto func_exit;
+		mutex_unlock(&codec->lock);
+		return -ENODEV;
 	}
 
 	if (!mute && !stream) {/* start playback */
@@ -792,9 +794,8 @@ static int gbcodec_mute_stream(struct snd_soc_dai *dai, int mute, int stream)
 				    module->name, mute ? "Mute" : "Unmute",
 				    stream ? "Capture" : "Playback", ret);
 
-func_exit:
 	mutex_unlock(&codec->lock);
-	return 0;
+	return ret;
 }
 
 static struct snd_soc_dai_ops gbcodec_dai_ops = {

commit 098dfaf45e76442d032207d2023930c685ab7c2e
Author: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
Date:   Fri Jul 22 09:41:30 2016 +0530

    greybus: audio: Avoid using ARA keyword
    
    It is suggested to avoid using ARA keyword externally. So we need to
    update GB codec driver. Also, codec name is currently set to 'gb-codec'.
    However, it makes more sense to name it as apb-dummy-codec, since it is
    used to control various audio modules connected to APB via greybus.
    
    Signed-off-by: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
    Reviewed-by: Mark Greer <mgreer@animalcreek.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/audio_codec.c b/drivers/staging/greybus/audio_codec.c
index 9c7bec737875..d7679e6bc364 100644
--- a/drivers/staging/greybus/audio_codec.c
+++ b/drivers/staging/greybus/audio_codec.c
@@ -1,5 +1,5 @@
 /*
- * audio codec driver
+ * APBridge ALSA SoC dummy codec driver
  * Copyright 2016 Google Inc.
  * Copyright 2016 Linaro Ltd.
  *
@@ -1203,13 +1203,13 @@ static int gbaudio_codec_remove(struct platform_device *pdev)
 }
 
 static const struct of_device_id greybus_asoc_machine_of_match[]  = {
-	{ .compatible = "qcom,ara-codec", },
+	{ .compatible = "toshiba,apb-dummy-codec", },
 	{},
 };
 
 static struct platform_driver gbaudio_codec_driver = {
 	.driver = {
-		.name = "gb-codec",
+		.name = "apb-dummy-codec",
 		.owner = THIS_MODULE,
 #ifdef CONFIG_PM
 		.pm = &gbaudio_codec_pm_ops,
@@ -1221,7 +1221,7 @@ static struct platform_driver gbaudio_codec_driver = {
 };
 module_platform_driver(gbaudio_codec_driver);
 
-MODULE_DESCRIPTION("Greybus codec driver");
+MODULE_DESCRIPTION("APBridge ALSA SoC dummy codec driver");
 MODULE_AUTHOR("Vaibhav Agarwal <vaibhav.agarwal@linaro.org>");
 MODULE_LICENSE("GPL v2");
-MODULE_ALIAS("platform:gbaudio-codec");
+MODULE_ALIAS("platform:apb-dummy-codec");

commit 12ce523147e485fc605599f7ec94fbbc6be0fc01
Author: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
Date:   Tue Jul 12 04:56:00 2016 -0500

    greybus: audio: Maintain proper codec state during shutdown sequence.
    
    During shutdown sequence, in case all modules are already removed,
    codec state is not updated. Though it's not causing any harm for now,
    but it's good to maintain proper codec state. Fix this.
    
    Signed-off-by: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
    Reviewed-by: Mark Greer <mgreer@animalcreek.com>
    Signed-off-by: Alex Elder <elder@linaro.org>

diff --git a/drivers/staging/greybus/audio_codec.c b/drivers/staging/greybus/audio_codec.c
index 5e05375bb71e..9c7bec737875 100644
--- a/drivers/staging/greybus/audio_codec.c
+++ b/drivers/staging/greybus/audio_codec.c
@@ -460,6 +460,8 @@ static void gbcodec_shutdown(struct snd_pcm_substream *substream,
 
 	if (list_empty(&codec->module_list)) {
 		dev_err(codec->dev, "No codec module available\n");
+		codec->stream[substream->stream].state = GBAUDIO_CODEC_SHUTDOWN;
+		codec->stream[substream->stream].dai_name = NULL;
 		mutex_unlock(&codec->lock);
 		pm_relax(dai->dev);
 		return;
@@ -733,8 +735,14 @@ static int gbcodec_mute_stream(struct snd_soc_dai *dai, int mute, int stream)
 	mutex_lock(&codec->lock);
 	if (list_empty(&codec->module_list)) {
 		dev_err(codec->dev, "No codec module available\n");
+		if (mute) {
+			codec->stream[stream].state = GBAUDIO_CODEC_STOP;
+			ret = 0;
+		} else {
+			ret = -ENODEV;
+		}
 		mutex_unlock(&codec->lock);
-		return -ENODEV;
+		return ret;
 	}
 
 	list_for_each_entry(module, &codec->module_list, list) {

commit cf1caac6cd7c1fa25de304925f6b239380797a46
Author: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
Date:   Tue Jul 12 04:56:00 2016 -0500

    greybus: audio: Fix incorrect codec state modification
    
    In case module is removed dynamically with ongoing playback, during
    module cleanup codec state is mistakenly modified. State should be
    modified for module only. Fix this.
    
    Fixes: 76414cb499b7 ("audio: Use single codec driver
    registration")
    
    Signed-off-by: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
    Reviewed-by: Mark Greer <mgreer@animalcreek.com>
    Signed-off-by: Alex Elder <elder@linaro.org>

diff --git a/drivers/staging/greybus/audio_codec.c b/drivers/staging/greybus/audio_codec.c
index 3c5a5aeeef8a..5e05375bb71e 100644
--- a/drivers/staging/greybus/audio_codec.c
+++ b/drivers/staging/greybus/audio_codec.c
@@ -971,7 +971,7 @@ static void gbaudio_codec_cleanup(struct gbaudio_module_info *module)
 		ret = gb_audio_apbridgea_unregister_cport(data->connection,
 						i2s_port, cportid,
 						AUDIO_APBRIDGEA_DIRECTION_TX);
-		gbcodec->stream[0].state = GBAUDIO_CODEC_SHUTDOWN;
+		module->ctrlstate[0] = GBAUDIO_CODEC_SHUTDOWN;
 	}
 
 	if (cap_state == GBAUDIO_CODEC_START) {
@@ -996,7 +996,7 @@ static void gbaudio_codec_cleanup(struct gbaudio_module_info *module)
 		ret = gb_audio_apbridgea_unregister_cport(data->connection,
 						i2s_port, cportid,
 						AUDIO_APBRIDGEA_DIRECTION_RX);
-		gbcodec->stream[1].state = GBAUDIO_CODEC_SHUTDOWN;
+		module->ctrlstate[1] = GBAUDIO_CODEC_SHUTDOWN;
 	}
 }
 

commit 9e138dd479cb1f924a3d78e13e6ba5668db73acc
Author: David Lin <dtwlin@google.com>
Date:   Fri Jun 24 13:52:43 2016 -0700

    greybus: audio: remove the unnecessary return statement
    
    The return statement immediately after the BUG_ON of the gbcodec_write()
    call is added by mistake. It's not causing any errors right now due to
    that gbcodec_reg is currently not being used.
    
    Testing Done:
    - Audio playback on EVT2
    
    Signed-off-by: David Lin <dtwlin@google.com>
    Reviewed-by: Mark Greer <mgreer@animalcreek.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/audio_codec.c b/drivers/staging/greybus/audio_codec.c
index 45e12b1d8627..3c5a5aeeef8a 100644
--- a/drivers/staging/greybus/audio_codec.c
+++ b/drivers/staging/greybus/audio_codec.c
@@ -1099,7 +1099,6 @@ static int gbcodec_write(struct snd_soc_codec *codec, unsigned int reg,
 		return 0;
 
 	BUG_ON(reg >= GBCODEC_REG_COUNT);
-		return 0;
 
 	gbcodec_reg[reg] = value;
 	dev_dbg(codec->dev, "reg[%d] = 0x%x\n", reg, value);

commit 60fb3405c73ea0bbab942c699496123f9e987c04
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Fri Jun 10 14:59:07 2016 +0530

    greybus: Remove extra blank lines
    
    This patch removes few blank lines across the repository at places where
    two blank lines were present together or when a blank line is present at
    the start or end of a routine.
    
    Note that this doesn't remove most of them from greybus_protocols.h as
    they were added on purpose.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/audio_codec.c b/drivers/staging/greybus/audio_codec.c
index 2feac6beea57..45e12b1d8627 100644
--- a/drivers/staging/greybus/audio_codec.c
+++ b/drivers/staging/greybus/audio_codec.c
@@ -1164,7 +1164,6 @@ static struct snd_soc_codec_driver soc_codec_dev_gbaudio = {
 	.ignore_pmdown_time = 1,
 };
 
-
 #ifdef CONFIG_PM
 static int gbaudio_codec_suspend(struct device *dev)
 {

commit f2b6303d4505b5b046691a936c346a0e376cd9f3
Author: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
Date:   Thu Jun 9 09:30:40 2016 +0530

    greybus: Remove apbridgea_shutdown_xx sequence if already done
    
    While reordering gb_deactivate sequence to avoid protocol error this was
    mistakenly added even during shutdown_tx/rx. It is supposed to be done
    immediately after stop_tx and only once.
    
    Fixes: 739f25d5f490 ("audio: Reorder gb_deactivate sequence to avoid protocol error")
    Signed-off-by: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
    Reviewed-by: Mark Greer <mgreer@animalcreek.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/audio_codec.c b/drivers/staging/greybus/audio_codec.c
index 334469345f87..2feac6beea57 100644
--- a/drivers/staging/greybus/audio_codec.c
+++ b/drivers/staging/greybus/audio_codec.c
@@ -396,12 +396,6 @@ static int gbmodule_shutdown_tx(struct gbaudio_module_info *module,
 		return 0;
 	}
 
-	if (codec_state == GBAUDIO_CODEC_STOP) {
-		ret = gb_audio_apbridgea_shutdown_tx(data->connection, 0);
-		if (ret)
-			return ret;
-	}
-
 	/* deactivate */
 	cportid = data->connection->intf_cport_id;
 	if (module_state >= GBAUDIO_CODEC_PREPARE) {
@@ -435,12 +429,6 @@ static int gbmodule_shutdown_rx(struct gbaudio_module_info *module,
 		return 0;
 	}
 
-	if (codec_state == GBAUDIO_CODEC_STOP) {
-		ret = gb_audio_apbridgea_shutdown_rx(data->connection, 0);
-		if (ret)
-			return ret;
-	}
-
 	/* deactivate */
 	cportid = data->connection->intf_cport_id;
 	if (module_state >= GBAUDIO_CODEC_PREPARE) {

commit 27c243cf5fcf4b3bb525f1f3f15ed8db91199507
Author: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
Date:   Thu Jun 9 09:30:39 2016 +0530

    greybus: Use mute_stream callback to initiate GB data xfer
    
    Currently trigger callback is used to start/stop greybus tx/rx
    path. This works well for almost all scenario except few
    specially handled usecases by Android Audio subsystem.
    
    In case of Music playback followed by Incoming ringtone, above
    layer tries to trigger_pause from one FE dailink and start a
    fresh playback via different FE dailink. Since, same BE dailink
    is used for both cases, an invalid state transition is requested
    i.e. from PAUSE->START. This fails & thus causes ringtone playback
    failure. With built-in codec, trigger callback is not required to
    initiate data xfer unlike gb-codec driver.
    
    This state transition should be handled in Android layer, but
    since it can lead to multiple side effects for various usecase
    we are trying to avoid trigger callback in gbcodec driver as well.
    
    Signed-off-by: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
    Reviewed-by: Mark Greer <mgreer@animalcreek.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/audio_codec.c b/drivers/staging/greybus/audio_codec.c
index 975d2e86b113..334469345f87 100644
--- a/drivers/staging/greybus/audio_codec.c
+++ b/drivers/staging/greybus/audio_codec.c
@@ -731,54 +731,24 @@ static int gbcodec_prepare(struct snd_pcm_substream *substream,
 	return ret;
 }
 
-static int gbcodec_trigger(struct snd_pcm_substream *substream, int cmd,
-		struct snd_soc_dai *dai)
+static int gbcodec_mute_stream(struct snd_soc_dai *dai, int mute, int stream)
 {
 	int ret;
-	int tx, rx, start, stop;
 	struct gbaudio_data_connection *data;
 	struct gbaudio_module_info *module;
 	struct gbaudio_codec_info *codec = dev_get_drvdata(dai->dev);
 
+
+	dev_dbg(dai->dev, "Mute:%d, Direction:%s\n", mute,
+		stream ? "CAPTURE":"PLAYBACK");
+
 	mutex_lock(&codec->lock);
 	if (list_empty(&codec->module_list)) {
 		dev_err(codec->dev, "No codec module available\n");
 		mutex_unlock(&codec->lock);
-		if (cmd == SNDRV_PCM_TRIGGER_STOP)
-			return 0;
 		return -ENODEV;
 	}
 
-	tx = rx = start = stop = 0;
-	switch (cmd) {
-	case SNDRV_PCM_TRIGGER_START:
-	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
-		start = 1;
-		break;
-	case SNDRV_PCM_TRIGGER_STOP:
-	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
-		stop = 1;
-		break;
-	default:
-		dev_err(dai->dev, "Invalid tigger cmd:%d\n", cmd);
-		ret = -EINVAL;
-		goto func_exit;
-	}
-
-	switch (substream->stream) {
-	case SNDRV_PCM_STREAM_CAPTURE:
-		rx = 1;
-		break;
-	case SNDRV_PCM_STREAM_PLAYBACK:
-		tx = 1;
-		break;
-	default:
-		dev_err(dai->dev, "Invalid stream type:%d\n",
-			substream->stream);
-		ret = -EINVAL;
-		goto func_exit;
-	}
-
 	list_for_each_entry(module, &codec->module_list, list) {
 		/* find the dai */
 		data = find_data(module, dai->name);
@@ -791,50 +761,43 @@ static int gbcodec_trigger(struct snd_pcm_substream *substream, int cmd,
 		ret = -ENODEV;
 		goto func_exit;
 	}
-	if (start && tx) {
+
+	if (!mute && !stream) {/* start playback */
 		ret = gb_audio_apbridgea_prepare_tx(data->connection,
 						    0);
 		if (!ret)
 			ret = gb_audio_apbridgea_start_tx(data->connection,
 							  0, 0);
-		codec->stream[substream->stream].state = GBAUDIO_CODEC_START;
-	} else if (start && rx) {
+		codec->stream[stream].state = GBAUDIO_CODEC_START;
+	} else if (!mute && stream) {/* start capture */
 		ret = gb_audio_apbridgea_prepare_rx(data->connection,
 						    0);
 		if (!ret)
 			ret = gb_audio_apbridgea_start_rx(data->connection,
 							  0);
-		codec->stream[substream->stream].state = GBAUDIO_CODEC_START;
-	} else if (stop && tx) {
+		codec->stream[stream].state = GBAUDIO_CODEC_START;
+	} else if (mute && !stream) {/* stop playback */
 		ret = gb_audio_apbridgea_stop_tx(data->connection, 0);
 		if (!ret)
 			ret = gb_audio_apbridgea_shutdown_tx(data->connection,
 							     0);
-		codec->stream[substream->stream].state = GBAUDIO_CODEC_STOP;
-	} else if (stop && rx) {
+		codec->stream[stream].state = GBAUDIO_CODEC_STOP;
+	} else if (mute && stream) {/* stop capture */
 		ret = gb_audio_apbridgea_stop_rx(data->connection, 0);
 		if (!ret)
 			ret = gb_audio_apbridgea_shutdown_rx(data->connection,
 							     0);
-		codec->stream[substream->stream].state = GBAUDIO_CODEC_STOP;
+		codec->stream[stream].state = GBAUDIO_CODEC_STOP;
 	} else
 		ret = -EINVAL;
 	if (ret)
-		dev_err_ratelimited(dai->dev, "%s:Error during %s stream:%d\n",
-			module->name, start ? "Start" : "Stop", ret);
+		dev_err_ratelimited(dai->dev,
+				    "%s:Error during %s %s stream:%d\n",
+				    module->name, mute ? "Mute" : "Unmute",
+				    stream ? "Capture" : "Playback", ret);
 
 func_exit:
 	mutex_unlock(&codec->lock);
-	return ret;
-}
-
-static int gbcodec_set_dai_fmt(struct snd_soc_dai *dai, unsigned int fmt)
-{
-	return 0;
-}
-
-static int gbcodec_digital_mute(struct snd_soc_dai *dai, int mute)
-{
 	return 0;
 }
 
@@ -842,10 +805,8 @@ static struct snd_soc_dai_ops gbcodec_dai_ops = {
 	.startup = gbcodec_startup,
 	.shutdown = gbcodec_shutdown,
 	.hw_params = gbcodec_hw_params,
-	.trigger = gbcodec_trigger,
 	.prepare = gbcodec_prepare,
-	.set_fmt = gbcodec_set_dai_fmt,
-	.digital_mute = gbcodec_digital_mute,
+	.mute_stream = gbcodec_mute_stream,
 };
 
 static int gbaudio_init_jack(struct gbaudio_module_info *module,

commit 4d27574cd354bc47758268c2e32a0a47b7aacfc0
Author: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
Date:   Wed Jun 8 20:33:26 2016 +0530

    greybus: audio: Ratelimit err messages
    
    In case of audio mgmt connection failure, GB requests would fail giving
    an error message within the driver and reporting error. However there is
    no error handling in above HAL and it'll keep on triggering similar
    request via GB codec driver. This may overflood serial console. In one
    of the instance it locked CPU for >10sec and caused a watchdog bite.
    Thus ratelimit those error messages.
    
    Testing Done: compile tested
    
    Signed-off-by: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/audio_codec.c b/drivers/staging/greybus/audio_codec.c
index 23dde708c76f..975d2e86b113 100644
--- a/drivers/staging/greybus/audio_codec.c
+++ b/drivers/staging/greybus/audio_codec.c
@@ -92,7 +92,7 @@ static int gbaudio_module_disable(struct gbaudio_codec_info *codec,
 			ret = -EINVAL;
 		}
 		if (ret) {
-			dev_err(codec->dev, "deactivate for %s failed:%d\n",
+			dev_err_ratelimited(codec->dev, "deactivate for %s failed:%d\n",
 				module->name, ret);
 			goto func_exit;
 		}
@@ -118,7 +118,7 @@ static int gbaudio_module_disable(struct gbaudio_codec_info *codec,
 			ret = -EINVAL;
 		}
 		if (ret) {
-			dev_err(codec->dev, "unregister_cport for %s failed:%d\n",
+			dev_err_ratelimited(codec->dev, "unregister_cport for %s failed:%d\n",
 				module->name, ret);
 			goto func_exit;
 		}
@@ -195,7 +195,7 @@ static int gbaudio_module_enable(struct gbaudio_codec_info *codec,
 				ret = -EINVAL;
 		}
 		if (ret) {
-			dev_err(codec->dev, "reg_cport for %s\n", module->name);
+			dev_err_ratelimited(codec->dev, "reg_cport for %s\n", module->name);
 			goto func_exit;
 		}
 		module_state = GBAUDIO_CODEC_STARTUP;
@@ -209,7 +209,7 @@ static int gbaudio_module_enable(struct gbaudio_codec_info *codec,
 		ret = gb_audio_gb_set_pcm(module->mgmt_connection, data_cport,
 					  format, rate, channels, sig_bits);
 		if (ret) {
-			dev_err(codec->dev, "set_pcm for %s\n", module->name);
+			dev_err_ratelimited(codec->dev, "set_pcm for %s\n", module->name);
 			goto func_exit;
 		}
 		module_state = GBAUDIO_CODEC_HWPARAMS;
@@ -226,7 +226,7 @@ static int gbaudio_module_enable(struct gbaudio_codec_info *codec,
 						module->mgmt_connection,
 						data_cport, 192);
 			if (ret) {
-				dev_err(codec->dev,
+				dev_err_ratelimited(codec->dev,
 					"set_rx_data_size for %s\n",
 					module->name);
 				goto func_exit;
@@ -234,7 +234,7 @@ static int gbaudio_module_enable(struct gbaudio_codec_info *codec,
 			ret = gb_audio_gb_activate_rx(module->mgmt_connection,
 						      data_cport);
 			if (ret) {
-				dev_err(codec->dev, "activate_rx for %s\n",
+				dev_err_ratelimited(codec->dev, "activate_rx for %s\n",
 					module->name);
 				goto func_exit;
 			}
@@ -244,7 +244,7 @@ static int gbaudio_module_enable(struct gbaudio_codec_info *codec,
 						module->mgmt_connection,
 						data_cport, 192);
 			if (ret) {
-				dev_err(codec->dev,
+				dev_err_ratelimited(codec->dev,
 					"set_tx_data_size for %s\n",
 					module->name);
 				goto func_exit;
@@ -252,7 +252,7 @@ static int gbaudio_module_enable(struct gbaudio_codec_info *codec,
 			ret = gb_audio_gb_activate_tx(module->mgmt_connection,
 						      data_cport);
 			if (ret) {
-				dev_err(codec->dev, "activate_tx for %s\n",
+				dev_err_ratelimited(codec->dev, "activate_tx for %s\n",
 					module->name);
 				goto func_exit;
 			}
@@ -579,7 +579,7 @@ static int gbcodec_hw_params(struct snd_pcm_substream *substream,
 		ret = gb_audio_gb_set_pcm(module->mgmt_connection, data_cport,
 					  format, rate, channels, sig_bits);
 		if (ret) {
-			dev_err(dai->dev, "%d: Error during set_pcm\n", ret);
+			dev_err_ratelimited(dai->dev, "%d: Error during set_pcm\n", ret);
 			goto func_exit;
 		}
 		if (state < GBAUDIO_CODEC_HWPARAMS) {
@@ -588,7 +588,7 @@ static int gbcodec_hw_params(struct snd_pcm_substream *substream,
 						AUDIO_APBRIDGEA_PCM_RATE_48000,
 						6144000);
 			if (ret) {
-				dev_err(dai->dev,
+				dev_err_ratelimited(dai->dev,
 					"%d: Error during set_config\n", ret);
 				goto func_exit;
 			}
@@ -619,7 +619,7 @@ static int gbmodule_prepare_tx(struct gbaudio_module_info *module,
 	ret = gb_audio_gb_set_tx_data_size(module->mgmt_connection, data_cport,
 					   192);
 	if (ret) {
-		dev_err(dev, "%d:Error during set_tx_data_size, cport:%d\n",
+		dev_err_ratelimited(dev, "%d:Error during set_tx_data_size, cport:%d\n",
 			ret, data_cport);
 		return ret;
 	}
@@ -627,7 +627,7 @@ static int gbmodule_prepare_tx(struct gbaudio_module_info *module,
 		ret = gb_audio_apbridgea_set_tx_data_size(data->connection, 0,
 							  192);
 		if (ret) {
-			dev_err(dev,
+			dev_err_ratelimited(dev,
 				"%d:Error during apbridgea set_tx_data_size, cport\n",
 				ret);
 			return ret;
@@ -636,7 +636,7 @@ static int gbmodule_prepare_tx(struct gbaudio_module_info *module,
 	ret = gb_audio_gb_activate_tx(module->mgmt_connection,
 				      data_cport);
 	if (ret)
-		dev_err(dev, "%s:Error during activate stream,%d\n",
+		dev_err_ratelimited(dev, "%s:Error during activate stream,%d\n",
 			module->name, ret);
 
 	return ret;
@@ -654,7 +654,7 @@ static int gbmodule_prepare_rx(struct gbaudio_module_info *module,
 	ret = gb_audio_gb_set_rx_data_size(module->mgmt_connection, data_cport,
 					   192);
 	if (ret) {
-		dev_err(dev, "%d:Error during set_rx_data_size, cport:%d\n",
+		dev_err_ratelimited(dev, "%d:Error during set_rx_data_size, cport:%d\n",
 			ret, data_cport);
 		return ret;
 	}
@@ -662,7 +662,7 @@ static int gbmodule_prepare_rx(struct gbaudio_module_info *module,
 		ret = gb_audio_apbridgea_set_rx_data_size(data->connection, 0,
 							  192);
 		if (ret) {
-			dev_err(dev,
+			dev_err_ratelimited(dev,
 				"%d:Error during apbridgea_set_rx_data_size\n",
 				ret);
 			return ret;
@@ -671,7 +671,7 @@ static int gbmodule_prepare_rx(struct gbaudio_module_info *module,
 	ret = gb_audio_gb_activate_rx(module->mgmt_connection,
 				      data_cport);
 	if (ret)
-		dev_err(dev, "%s:Error during activate stream,%d\n",
+		dev_err_ratelimited(dev, "%s:Error during activate stream,%d\n",
 			module->name, ret);
 
 	return ret;
@@ -820,7 +820,7 @@ static int gbcodec_trigger(struct snd_pcm_substream *substream, int cmd,
 	} else
 		ret = -EINVAL;
 	if (ret)
-		dev_err(dai->dev, "%s:Error during %s stream:%d\n",
+		dev_err_ratelimited(dai->dev, "%s:Error during %s stream:%d\n",
 			module->name, start ? "Start" : "Stop", ret);
 
 func_exit:

commit c188fdc8176a8cb18b5d81cccac590311251208e
Author: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
Date:   Wed May 4 16:29:23 2016 +0530

    greybus: audio: Reduce codec->lock granularity
    
    Earlier codec->lock protects almost complete register/unregister
    module function. This can be reduced to specific operations.
    
    Signed-off-by: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/audio_codec.c b/drivers/staging/greybus/audio_codec.c
index dbcff218badd..23dde708c76f 100644
--- a/drivers/staging/greybus/audio_codec.c
+++ b/drivers/staging/greybus/audio_codec.c
@@ -933,20 +933,17 @@ int gbaudio_register_module(struct gbaudio_module_info *module)
 	card = codec->card->snd_card;
 
 	down_write(&card->controls_rwsem);
-	mutex_lock(&gbcodec->lock);
 
 	if (module->num_dais) {
 		dev_err(gbcodec->dev,
 			"%d:DAIs not supported via gbcodec driver\n",
 			module->num_dais);
-		mutex_unlock(&gbcodec->lock);
 		up_write(&card->controls_rwsem);
 		return -EINVAL;
 	}
 
 	ret = gbaudio_init_jack(module, codec);
 	if (ret) {
-		mutex_unlock(&gbcodec->lock);
 		up_write(&card->controls_rwsem);
 		return ret;
 	}
@@ -976,12 +973,14 @@ int gbaudio_register_module(struct gbaudio_module_info *module)
 #endif
 	}
 
+	mutex_lock(&gbcodec->lock);
 	list_add(&module->list, &gbcodec->module_list);
+	mutex_unlock(&gbcodec->lock);
+
 	if (codec->card->instantiated)
 		ret = snd_soc_dapm_new_widgets(&codec->dapm);
 	dev_dbg(codec->dev, "Registered %s module\n", module->name);
 
-	mutex_unlock(&gbcodec->lock);
 	up_write(&card->controls_rwsem);
 	return ret;
 }
@@ -1065,6 +1064,7 @@ void gbaudio_unregister_module(struct gbaudio_module_info *module)
 	gbaudio_codec_cleanup(module);
 	list_del(&module->list);
 	dev_dbg(codec->dev, "Process Unregister %s module\n", module->name);
+	mutex_unlock(&gbcodec->lock);
 
 #ifdef CONFIG_SND_JACK
 	/* free jack devices for this module from codec->jack_list */
@@ -1098,7 +1098,6 @@ void gbaudio_unregister_module(struct gbaudio_module_info *module)
 
 	dev_dbg(codec->dev, "Unregistered %s module\n", module->name);
 
-	mutex_unlock(&gbcodec->lock);
 	up_write(&card->controls_rwsem);
 }
 EXPORT_SYMBOL(gbaudio_unregister_module);

commit bb9986ef6b311fb3f4de2150bd050c1d9e1d9d65
Author: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
Date:   Wed May 4 16:29:22 2016 +0530

    greybus: audio: Reorganize sequence in GB audio bundle & codec driver
    
    Modify sequence of register_module & unregister_module in bundle
    driver. This would affect the uevent generated for above user
    space. Accordingly, we need to modify snd_soc_xxx sequence in
    register_module() in codec driver.
    
    Signed-off-by: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/audio_codec.c b/drivers/staging/greybus/audio_codec.c
index c50720ee30fe..dbcff218badd 100644
--- a/drivers/staging/greybus/audio_codec.c
+++ b/drivers/staging/greybus/audio_codec.c
@@ -963,27 +963,27 @@ int gbaudio_register_module(struct gbaudio_module_info *module)
 
 	/* card already instantiated, create widgets here only */
 	if (codec->card->instantiated) {
-		ret = snd_soc_dapm_new_widgets(&codec->dapm);
-		if (!ret)
-			snd_soc_dapm_link_component_dai_widgets(codec->card,
-								&codec->dapm);
-	}
-
+		snd_soc_dapm_link_component_dai_widgets(codec->card,
+							&codec->dapm);
 #ifdef CONFIG_SND_JACK
-	/* register jack devices for this module from codec->jack_list */
-	list_for_each_entry(jack, &codec->jack_list, list) {
-		if ((jack == &module->headset_jack)
-		    || (jack == &module->button_jack))
-			snd_device_register(codec->card->snd_card, jack->jack);
-	}
+		/* register jack devices for this module from codec->jack_list */
+		list_for_each_entry(jack, &codec->jack_list, list) {
+			if ((jack == &module->headset_jack)
+			    || (jack == &module->button_jack))
+				snd_device_register(codec->card->snd_card,
+						    jack->jack);
+		}
 #endif
+	}
 
 	list_add(&module->list, &gbcodec->module_list);
+	if (codec->card->instantiated)
+		ret = snd_soc_dapm_new_widgets(&codec->dapm);
 	dev_dbg(codec->dev, "Registered %s module\n", module->name);
 
 	mutex_unlock(&gbcodec->lock);
 	up_write(&card->controls_rwsem);
-	return 0;
+	return ret;
 }
 EXPORT_SYMBOL(gbaudio_register_module);
 
@@ -1060,11 +1060,10 @@ void gbaudio_unregister_module(struct gbaudio_module_info *module)
 
 	dev_dbg(codec->dev, "Unregister %s module\n", module->name);
 
-	/* complete widget processing, if ongoing */
-	snd_soc_dapm_sync(&codec->dapm);
-
 	down_write(&card->controls_rwsem);
 	mutex_lock(&gbcodec->lock);
+	gbaudio_codec_cleanup(module);
+	list_del(&module->list);
 	dev_dbg(codec->dev, "Process Unregister %s module\n", module->name);
 
 #ifdef CONFIG_SND_JACK
@@ -1078,8 +1077,6 @@ void gbaudio_unregister_module(struct gbaudio_module_info *module)
 	}
 #endif
 
-	gbaudio_codec_cleanup(module);
-
 	if (module->dapm_routes) {
 		dev_dbg(codec->dev, "Removing %d routes\n",
 			module->num_dapm_routes);
@@ -1099,7 +1096,6 @@ void gbaudio_unregister_module(struct gbaudio_module_info *module)
 					   module->num_dapm_widgets);
 	}
 
-	list_del(&module->list);
 	dev_dbg(codec->dev, "Unregistered %s module\n", module->name);
 
 	mutex_unlock(&gbcodec->lock);

commit 852859ab8186e7a492fdec5db5ef219bf625c21a
Author: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
Date:   Wed May 4 16:29:21 2016 +0530

    greybus: audio: Remove redundant lock protection & is_connected field
    
    Each module maintains connected status & a lock to protect it.
    Using codec->lock we can safely serialize ASoC specific callbacks
    (in response to mixer_ctl update or dai_ops) and gb module
    disconnect. Thus is_connected field can be removed.
    
    Signed-off-by: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/audio_codec.c b/drivers/staging/greybus/audio_codec.c
index 7a9abbf0ed5a..c50720ee30fe 100644
--- a/drivers/staging/greybus/audio_codec.c
+++ b/drivers/staging/greybus/audio_codec.c
@@ -60,7 +60,6 @@ static int gbaudio_module_disable(struct gbaudio_codec_info *codec,
 
 	dai_name = codec->stream[dir].dai_name;
 
-	mutex_lock(&module->lock);
 	module_state = module->ctrlstate[dir];
 	if (module_state == GBAUDIO_CODEC_SHUTDOWN) {
 		dev_dbg(codec->dev, "%s: module already configured\n",
@@ -129,7 +128,6 @@ static int gbaudio_module_disable(struct gbaudio_codec_info *codec,
 	module->ctrlstate[dir] = GBAUDIO_CODEC_SHUTDOWN;
 
 func_exit:
-	mutex_unlock(&module->lock);
 	mutex_unlock(&codec->lock);
 	return ret;
 }
@@ -160,7 +158,6 @@ static int gbaudio_module_enable(struct gbaudio_codec_info *codec,
 	rate = codec->stream[dir].rate;
 	sig_bits = codec->stream[dir].sig_bits;
 
-	mutex_lock(&module->lock);
 	module_state = module->ctrlstate[dir];
 	if (module_state == codec_state) {
 		dev_dbg(codec->dev, "%s: module already configured\n",
@@ -272,7 +269,6 @@ static int gbaudio_module_enable(struct gbaudio_codec_info *codec,
 
 func_exit:
 	module->ctrlstate[dir] = module_state;
-	mutex_unlock(&module->lock);
 	mutex_unlock(&codec->lock);
 	return ret;
 }
@@ -342,18 +338,11 @@ static int gbcodec_startup(struct snd_pcm_substream *substream,
 
 	state = codec->stream[substream->stream].state;
 	list_for_each_entry(module, &codec->module_list, list) {
-		mutex_lock(&module->lock);
-		if (!module->is_connected) {
-			mutex_unlock(&module->lock);
-			continue;
-		}
-
 		/* find the dai */
 		data = find_data(module, dai->name);
 		if (!data) {
 			dev_err(dai->dev, "%s:%s DATA connection missing\n",
 				dai->name, module->name);
-			mutex_unlock(&module->lock);
 			continue;
 		}
 
@@ -375,7 +364,6 @@ static int gbcodec_startup(struct snd_pcm_substream *substream,
 			break;
 		default:
 			dev_err(dai->dev, "Inavlid stream\n");
-			mutex_unlock(&module->lock);
 			mutex_unlock(&codec->lock);
 			return -EINVAL;
 		}
@@ -384,7 +372,6 @@ static int gbcodec_startup(struct snd_pcm_substream *substream,
 		state = GBAUDIO_CODEC_STARTUP;
 		module->ctrlstate[substream->stream] = state;
 		dev_dbg(dai->dev, "%s: state:%d\n", module->name, state);
-		mutex_unlock(&module->lock);
 	}
 	codec->stream[substream->stream].state = state;
 	codec->stream[substream->stream].dai_name = dai->name;
@@ -492,19 +479,11 @@ static void gbcodec_shutdown(struct snd_pcm_substream *substream,
 
 	state = codec->stream[substream->stream].state;
 	list_for_each_entry(module, &codec->module_list, list) {
-		mutex_lock(&module->lock);
-		if (!module->is_connected) {
-			dev_err(dai->dev, "%s:%s module not connected\n",
-				__func__, module->name);
-			mutex_unlock(&module->lock);
-			continue;
-		}
 		/* find the dai */
 		data = find_data(module, dai->name);
 		if (!data) {
 			dev_err(dai->dev, "%s:%s DATA connection missing\n",
 				dai->name, module->name);
-			mutex_unlock(&module->lock);
 			continue;
 		}
 
@@ -523,7 +502,6 @@ static void gbcodec_shutdown(struct snd_pcm_substream *substream,
 		state = GBAUDIO_CODEC_SHUTDOWN;
 		module->ctrlstate[substream->stream] = state;
 		dev_dbg(dai->dev, "%s: state:%d\n", module->name, state);
-		mutex_unlock(&module->lock);
 	}
 	codec->stream[substream->stream].state = state;
 	codec->stream[substream->stream].dai_name = NULL;
@@ -583,21 +561,11 @@ static int gbcodec_hw_params(struct snd_pcm_substream *substream,
 
 	state = codec->stream[substream->stream].state;
 	list_for_each_entry(module, &codec->module_list, list) {
-		mutex_lock(&module->lock);
-		if (!module->is_connected) {
-			dev_err(dai->dev, "%s:%s module not connected\n",
-				__func__, module->name);
-			ret = -ENODEV;
-			mutex_unlock(&module->lock);
-			continue;
-		}
-
 		/* find the data connection */
 		data = find_data(module, dai->name);
 		if (!data) {
 			dev_err(dai->dev, "%s:%s DATA connection missing\n",
 				dai->name, module->name);
-			mutex_unlock(&module->lock);
 			continue;
 		}
 
@@ -612,7 +580,6 @@ static int gbcodec_hw_params(struct snd_pcm_substream *substream,
 					  format, rate, channels, sig_bits);
 		if (ret) {
 			dev_err(dai->dev, "%d: Error during set_pcm\n", ret);
-			mutex_unlock(&module->lock);
 			goto func_exit;
 		}
 		if (state < GBAUDIO_CODEC_HWPARAMS) {
@@ -623,14 +590,12 @@ static int gbcodec_hw_params(struct snd_pcm_substream *substream,
 			if (ret) {
 				dev_err(dai->dev,
 					"%d: Error during set_config\n", ret);
-				mutex_unlock(&module->lock);
 				goto func_exit;
 			}
 		}
 		state = GBAUDIO_CODEC_HWPARAMS;
 		module->ctrlstate[substream->stream] = state;
 		dev_dbg(dai->dev, "%s: state:%d\n", module->name, state);
-		mutex_unlock(&module->lock);
 	}
 	codec->stream[substream->stream].state = state;
 	codec->stream[substream->stream].format = format;
@@ -731,18 +696,11 @@ static int gbcodec_prepare(struct snd_pcm_substream *substream,
 
 	state = codec->stream[substream->stream].state;
 	list_for_each_entry(module, &codec->module_list, list) {
-		mutex_lock(&module->lock);
-		if (!module->is_connected) {
-			mutex_unlock(&module->lock);
-			continue;
-		}
-
 		/* find the dai */
 		data = find_data(module, dai->name);
 		if (!data) {
 			dev_err(dai->dev, "%s:%s DATA connection missing\n",
 				dai->name, module->name);
-			mutex_unlock(&module->lock);
 			continue;
 		}
 
@@ -759,14 +717,12 @@ static int gbcodec_prepare(struct snd_pcm_substream *substream,
 		if (ret == -ENODEV)
 			continue;
 		if (ret) {
-			mutex_unlock(&module->lock);
 			goto func_exit;
 		}
 
 		state = GBAUDIO_CODEC_PREPARE;
 		module->ctrlstate[substream->stream] = state;
 		dev_dbg(dai->dev, "%s: state:%d\n", module->name, state);
-		mutex_unlock(&module->lock);
 	}
 	codec->stream[substream->stream].state = state;
 
@@ -824,12 +780,6 @@ static int gbcodec_trigger(struct snd_pcm_substream *substream, int cmd,
 	}
 
 	list_for_each_entry(module, &codec->module_list, list) {
-		mutex_lock(&module->lock);
-		if (!module->is_connected) {
-			mutex_unlock(&module->lock);
-			continue;
-		}
-
 		/* find the dai */
 		data = find_data(module, dai->name);
 		if (data)
@@ -839,7 +789,6 @@ static int gbcodec_trigger(struct snd_pcm_substream *substream, int cmd,
 		dev_err(dai->dev, "%s:%s DATA connection missing\n",
 			dai->name, module->name);
 		ret = -ENODEV;
-		mutex_unlock(&module->lock);
 		goto func_exit;
 	}
 	if (start && tx) {
@@ -873,7 +822,6 @@ static int gbcodec_trigger(struct snd_pcm_substream *substream, int cmd,
 	if (ret)
 		dev_err(dai->dev, "%s:Error during %s stream:%d\n",
 			module->name, start ? "Start" : "Stop", ret);
-	mutex_unlock(&module->lock);
 
 func_exit:
 	mutex_unlock(&codec->lock);
@@ -1118,7 +1066,6 @@ void gbaudio_unregister_module(struct gbaudio_module_info *module)
 	down_write(&card->controls_rwsem);
 	mutex_lock(&gbcodec->lock);
 	dev_dbg(codec->dev, "Process Unregister %s module\n", module->name);
-	mutex_lock(&module->lock);
 
 #ifdef CONFIG_SND_JACK
 	/* free jack devices for this module from codec->jack_list */
@@ -1133,7 +1080,6 @@ void gbaudio_unregister_module(struct gbaudio_module_info *module)
 
 	gbaudio_codec_cleanup(module);
 
-	module->is_connected = 0;
 	if (module->dapm_routes) {
 		dev_dbg(codec->dev, "Removing %d routes\n",
 			module->num_dapm_routes);
@@ -1153,8 +1099,6 @@ void gbaudio_unregister_module(struct gbaudio_module_info *module)
 					   module->num_dapm_widgets);
 	}
 
-	mutex_unlock(&module->lock);
-
 	list_del(&module->list);
 	dev_dbg(codec->dev, "Unregistered %s module\n", module->name);
 

commit 54e9070b24def1dfaf07e78fee6ea18f7ff57bcc
Author: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
Date:   Sat Apr 23 20:04:05 2016 +0530

    greybus: audio: Reorder gb_deactivate sequence to avoid protocol error
    
    gb_activate_tx/rx is triggered from _prepare() & gb_deactivate
    from shutdown(). This may cause protocol error in case shutdown
    executes without _prepare due to some hw_params failure.
    
    Also, reorganise _prepare & _shutdown calls to make it more
    readable & cleaner.
    
    Signed-off-by: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
    Reviewed-by: Mark Greer <mgreer@animalcreek.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/audio_codec.c b/drivers/staging/greybus/audio_codec.c
index a2b81ba78196..7a9abbf0ed5a 100644
--- a/drivers/staging/greybus/audio_codec.c
+++ b/drivers/staging/greybus/audio_codec.c
@@ -395,12 +395,88 @@ static int gbcodec_startup(struct snd_pcm_substream *substream,
 	return ret;
 }
 
+static int gbmodule_shutdown_tx(struct gbaudio_module_info *module,
+				struct gbaudio_data_connection *data,
+				int codec_state, struct device *dev)
+{
+	int ret, module_state;
+	__u16 i2s_port, cportid;
+
+	module_state = module->ctrlstate[0];
+	if (module_state == GBAUDIO_CODEC_SHUTDOWN) {
+		dev_dbg(dev, "%s: module already configured\n",
+			module->name);
+		return 0;
+	}
+
+	if (codec_state == GBAUDIO_CODEC_STOP) {
+		ret = gb_audio_apbridgea_shutdown_tx(data->connection, 0);
+		if (ret)
+			return ret;
+	}
+
+	/* deactivate */
+	cportid = data->connection->intf_cport_id;
+	if (module_state >= GBAUDIO_CODEC_PREPARE) {
+		ret = gb_audio_gb_deactivate_tx(module->mgmt_connection,
+						cportid);
+		if (ret)
+			return ret;
+	}
+
+	/* unregister cport */
+	i2s_port = 0;	/* fixed for now */
+	cportid = data->connection->hd_cport_id;
+	ret = gb_audio_apbridgea_unregister_cport(data->connection, i2s_port,
+						  cportid,
+						  AUDIO_APBRIDGEA_DIRECTION_TX);
+
+	return ret;
+}
+
+static int gbmodule_shutdown_rx(struct gbaudio_module_info *module,
+				struct gbaudio_data_connection *data,
+				int codec_state, struct device *dev)
+{
+	int ret, module_state;
+	__u16 i2s_port, cportid;
+
+	module_state = module->ctrlstate[1];
+	if (module_state == GBAUDIO_CODEC_SHUTDOWN) {
+		dev_dbg(dev, "%s: module already configured\n",
+			module->name);
+		return 0;
+	}
+
+	if (codec_state == GBAUDIO_CODEC_STOP) {
+		ret = gb_audio_apbridgea_shutdown_rx(data->connection, 0);
+		if (ret)
+			return ret;
+	}
+
+	/* deactivate */
+	cportid = data->connection->intf_cport_id;
+	if (module_state >= GBAUDIO_CODEC_PREPARE) {
+		ret = gb_audio_gb_deactivate_rx(module->mgmt_connection,
+						cportid);
+		if (ret)
+			return ret;
+	}
+
+	/* unregister cport */
+	i2s_port = 0;	/* fixed for now */
+	cportid = data->connection->hd_cport_id;
+	ret = gb_audio_apbridgea_unregister_cport(data->connection, i2s_port,
+						  cportid,
+						  AUDIO_APBRIDGEA_DIRECTION_RX);
+
+	return ret;
+}
+
 static void gbcodec_shutdown(struct snd_pcm_substream *substream,
 			     struct snd_soc_dai *dai)
 {
-	int ret;
-	__u16 i2s_port, cportid;
-	int state, module_state;
+	int ret, state;
 	struct gbaudio_module_info *module;
 	struct gbaudio_data_connection *data;
 	struct gbaudio_codec_info *codec = dev_get_drvdata(dai->dev);
@@ -423,14 +499,6 @@ static void gbcodec_shutdown(struct snd_pcm_substream *substream,
 			mutex_unlock(&module->lock);
 			continue;
 		}
-		module_state = module->ctrlstate[substream->stream];
-		if (module_state == GBAUDIO_CODEC_SHUTDOWN) {
-			dev_dbg(codec->dev, "%s: module already configured\n",
-				module->name);
-			mutex_unlock(&module->lock);
-			continue;
-		}
-
 		/* find the dai */
 		data = find_data(module, dai->name);
 		if (!data) {
@@ -440,32 +508,18 @@ static void gbcodec_shutdown(struct snd_pcm_substream *substream,
 			continue;
 		}
 
-		/* deactivate */
-		cportid = data->connection->intf_cport_id;
 		switch (substream->stream) {
-		case SNDRV_PCM_STREAM_CAPTURE:
-			ret = gb_audio_gb_deactivate_rx(module->mgmt_connection,
-							cportid);
-			/* unregister cport */
-			i2s_port = 0;	/* fixed for now */
-			cportid = data->connection->hd_cport_id;
-			ret = gb_audio_apbridgea_unregister_cport(
-					data->connection, i2s_port, cportid,
-					AUDIO_APBRIDGEA_DIRECTION_RX);
-			break;
 		case SNDRV_PCM_STREAM_PLAYBACK:
-			ret = gb_audio_gb_deactivate_tx(module->mgmt_connection,
-							cportid);
-			/* unregister cport */
-			i2s_port = 0;	/* fixed for now */
-			cportid = data->connection->hd_cport_id;
-			ret = gb_audio_apbridgea_unregister_cport(
-					data->connection, i2s_port, cportid,
-					AUDIO_APBRIDGEA_DIRECTION_TX);
+			ret = gbmodule_shutdown_tx(module, data, state,
+						   dai->dev);
+			break;
+		case SNDRV_PCM_STREAM_CAPTURE:
+			ret = gbmodule_shutdown_rx(module, data, state,
+						   dai->dev);
 			break;
 		}
-		dev_dbg(dai->dev, "Unregister %s:%d DAI, ret:%d\n", dai->name,
-			cportid, ret);
+		dev_dbg(dai->dev, "Unregister %s DAI, ret:%d\n", dai->name,
+			ret);
 		state = GBAUDIO_CODEC_SHUTDOWN;
 		module->ctrlstate[substream->stream] = state;
 		dev_dbg(dai->dev, "%s: state:%d\n", module->name, state);
@@ -589,14 +643,82 @@ static int gbcodec_hw_params(struct snd_pcm_substream *substream,
 	return ret;
 }
 
+static int gbmodule_prepare_tx(struct gbaudio_module_info *module,
+			       struct gbaudio_data_connection *data,
+			       int codec_state, struct device *dev)
+{
+	int ret;
+	uint16_t data_cport;
+
+	data_cport = data->connection->intf_cport_id;
+	ret = gb_audio_gb_set_tx_data_size(module->mgmt_connection, data_cport,
+					   192);
+	if (ret) {
+		dev_err(dev, "%d:Error during set_tx_data_size, cport:%d\n",
+			ret, data_cport);
+		return ret;
+	}
+	if (codec_state < GBAUDIO_CODEC_PREPARE) {
+		ret = gb_audio_apbridgea_set_tx_data_size(data->connection, 0,
+							  192);
+		if (ret) {
+			dev_err(dev,
+				"%d:Error during apbridgea set_tx_data_size, cport\n",
+				ret);
+			return ret;
+		}
+	}
+	ret = gb_audio_gb_activate_tx(module->mgmt_connection,
+				      data_cport);
+	if (ret)
+		dev_err(dev, "%s:Error during activate stream,%d\n",
+			module->name, ret);
+
+	return ret;
+}
+
+static int gbmodule_prepare_rx(struct gbaudio_module_info *module,
+			       struct gbaudio_data_connection *data,
+			       int codec_state, struct device *dev)
+{
+	int ret;
+	uint16_t data_cport;
+
+	data_cport = data->connection->intf_cport_id;
+
+	ret = gb_audio_gb_set_rx_data_size(module->mgmt_connection, data_cport,
+					   192);
+	if (ret) {
+		dev_err(dev, "%d:Error during set_rx_data_size, cport:%d\n",
+			ret, data_cport);
+		return ret;
+	}
+	if (codec_state < GBAUDIO_CODEC_PREPARE) {
+		ret = gb_audio_apbridgea_set_rx_data_size(data->connection, 0,
+							  192);
+		if (ret) {
+			dev_err(dev,
+				"%d:Error during apbridgea_set_rx_data_size\n",
+				ret);
+			return ret;
+		}
+	}
+	ret = gb_audio_gb_activate_rx(module->mgmt_connection,
+				      data_cport);
+	if (ret)
+		dev_err(dev, "%s:Error during activate stream,%d\n",
+			module->name, ret);
+
+	return ret;
+}
+
 static int gbcodec_prepare(struct snd_pcm_substream *substream,
 			   struct snd_soc_dai *dai)
 {
 	int ret;
-	uint16_t data_cport;
-	struct gbaudio_data_connection *data;
 	struct gbaudio_module_info *module;
 	int state;
+	struct gbaudio_data_connection *data;
 	struct gbaudio_codec_info *codec = dev_get_drvdata(dai->dev);
 
 	mutex_lock(&codec->lock);
@@ -623,71 +745,24 @@ static int gbcodec_prepare(struct snd_pcm_substream *substream,
 			mutex_unlock(&module->lock);
 			continue;
 		}
-		/* deactivate rx/tx */
-		data_cport = data->connection->intf_cport_id;
 
 		switch (substream->stream) {
-		case SNDRV_PCM_STREAM_CAPTURE:
-			ret = gb_audio_gb_set_rx_data_size(
-						module->mgmt_connection,
-						data_cport, 192);
-			if (ret) {
-				dev_err(dai->dev,
-					"%d:Error during set_rx_data_size, cport:%d\n",
-					ret, data_cport);
-				mutex_unlock(&module->lock);
-				goto func_exit;
-			}
-			if (state < GBAUDIO_CODEC_PREPARE) {
-				ret = gb_audio_apbridgea_set_rx_data_size(
-							data->connection, 0,
-							192);
-				if (ret) {
-					dev_err(dai->dev,
-				"%d:Error during apbridgea_set_rx_data_size\n",
-				ret);
-					mutex_unlock(&module->lock);
-					goto func_exit;
-				}
-			}
-			ret = gb_audio_gb_activate_rx(module->mgmt_connection,
-						      data_cport);
-			if (ret)
-				dev_err(dai->dev,
-					"%s:Error during activate stream,%d\n",
-					module->name, ret);
-			break;
 		case SNDRV_PCM_STREAM_PLAYBACK:
-			ret = gb_audio_gb_set_tx_data_size(
-						module->mgmt_connection,
-						data_cport, 192);
-			if (ret) {
-				dev_err(dai->dev,
-					"%d:Error during module set_tx_data_size, cport:%d\n",
-					ret, data_cport);
-				mutex_unlock(&module->lock);
-				goto func_exit;
-			}
-			if (state < GBAUDIO_CODEC_PREPARE) {
-				ret = gb_audio_apbridgea_set_tx_data_size(
-							data->connection, 0,
-							192);
-				if (ret) {
-					dev_err(dai->dev,
-						"%d:Error during apbridgea set_tx_data_size, cport\n",
-						ret);
-					mutex_unlock(&module->lock);
-					goto func_exit;
-				}
-			}
-			ret = gb_audio_gb_activate_tx(module->mgmt_connection,
-						      data_cport);
-			if (ret)
-				dev_err(dai->dev,
-					"%s:Error during activate stream,%d\n",
-					module->name, ret);
+			ret = gbmodule_prepare_tx(module, data, state,
+						  dai->dev);
+			break;
+		case SNDRV_PCM_STREAM_CAPTURE:
+			ret = gbmodule_prepare_rx(module, data, state,
+						  dai->dev);
 			break;
 		}
+		if (ret == -ENODEV)
+			continue;
+		if (ret) {
+			mutex_unlock(&module->lock);
+			goto func_exit;
+		}
+
 		state = GBAUDIO_CODEC_PREPARE;
 		module->ctrlstate[substream->stream] = state;
 		dev_dbg(dai->dev, "%s: state:%d\n", module->name, state);
@@ -697,7 +772,7 @@ static int gbcodec_prepare(struct snd_pcm_substream *substream,
 
 func_exit:
 	mutex_unlock(&codec->lock);
-	return 0;
+	return ret;
 }
 
 static int gbcodec_trigger(struct snd_pcm_substream *substream, int cmd,

commit 2b8c2b51000e3d056f9aa27a64b93feabddf77a4
Author: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
Date:   Thu Apr 21 22:14:02 2016 +0530

    greybus: audio: Changes in response to ASoC cleanup
    
    Update Makefile in response to SND_SOC_DYNAMIC_DAILINK cflag
    removal.
    
    Update files for msm-dynamic-dailink.h header file removal.
    
    Update in response to API name changes. Also, acquire sound card
    controls_rwsem before adding kcontrols to avoid deadlock.
    
    Signed-off-by: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
    Reviewed-by: Mark Greer <mgreer@animalcreek.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/audio_codec.c b/drivers/staging/greybus/audio_codec.c
index 20feea1c64d3..a2b81ba78196 100644
--- a/drivers/staging/greybus/audio_codec.c
+++ b/drivers/staging/greybus/audio_codec.c
@@ -898,6 +898,7 @@ int gbaudio_register_module(struct gbaudio_module_info *module)
 {
 	int ret;
 	struct snd_soc_codec *codec;
+	struct snd_card *card;
 	struct snd_soc_jack *jack = NULL;
 
 	if (!gbcodec) {
@@ -906,6 +907,9 @@ int gbaudio_register_module(struct gbaudio_module_info *module)
 	}
 
 	codec = gbcodec->codec;
+	card = codec->card->snd_card;
+
+	down_write(&card->controls_rwsem);
 	mutex_lock(&gbcodec->lock);
 
 	if (module->num_dais) {
@@ -913,12 +917,14 @@ int gbaudio_register_module(struct gbaudio_module_info *module)
 			"%d:DAIs not supported via gbcodec driver\n",
 			module->num_dais);
 		mutex_unlock(&gbcodec->lock);
+		up_write(&card->controls_rwsem);
 		return -EINVAL;
 	}
 
 	ret = gbaudio_init_jack(module, codec);
 	if (ret) {
 		mutex_unlock(&gbcodec->lock);
+		up_write(&card->controls_rwsem);
 		return ret;
 	}
 
@@ -936,7 +942,7 @@ int gbaudio_register_module(struct gbaudio_module_info *module)
 	if (codec->card->instantiated) {
 		ret = snd_soc_dapm_new_widgets(&codec->dapm);
 		if (!ret)
-			snd_soc_dapm_link_dai_widgets_component(codec->card,
+			snd_soc_dapm_link_component_dai_widgets(codec->card,
 								&codec->dapm);
 	}
 
@@ -953,6 +959,7 @@ int gbaudio_register_module(struct gbaudio_module_info *module)
 	dev_dbg(codec->dev, "Registered %s module\n", module->name);
 
 	mutex_unlock(&gbcodec->lock);
+	up_write(&card->controls_rwsem);
 	return 0;
 }
 EXPORT_SYMBOL(gbaudio_register_module);
@@ -1061,7 +1068,7 @@ void gbaudio_unregister_module(struct gbaudio_module_info *module)
 	if (module->controls) {
 		dev_dbg(codec->dev, "Removing %d controls\n",
 			module->num_controls);
-		soc_remove_codec_controls(codec, module->controls,
+		snd_soc_remove_codec_controls(codec, module->controls,
 					  module->num_controls);
 	}
 	if (module->dapm_widgets) {

commit d7ed7cbfe695d0a77613b305bed0483a1c9569ca
Author: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
Date:   Mon Apr 25 17:18:17 2016 +0530

    greybus: audio: acquire wakelock during active playback
    
    This change was missed while merging original patch
    commit-id: 53c765c33f4a69c31027ec012e717d303bd4feca
    Thus submitting it again.
    
    Signed-off-by: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/audio_codec.c b/drivers/staging/greybus/audio_codec.c
index 9ed35c4da280..20feea1c64d3 100644
--- a/drivers/staging/greybus/audio_codec.c
+++ b/drivers/staging/greybus/audio_codec.c
@@ -410,6 +410,7 @@ static void gbcodec_shutdown(struct snd_pcm_substream *substream,
 	if (list_empty(&codec->module_list)) {
 		dev_err(codec->dev, "No codec module available\n");
 		mutex_unlock(&codec->lock);
+		pm_relax(dai->dev);
 		return;
 	}
 

commit f2bf63a365425fa7df56c4e1dbe5a6bb29680324
Author: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
Date:   Fri Apr 22 11:13:19 2016 -0700

    greybus: audio: acquire wakelock during active playback
    
    use pm_stay_awake & pm_relax to avoid suspend sequence during
    active playback
    
    testing Done:
    Music Playback ongoing
    $ cat /sys/devices/soc.0/qcom,ara-codec.82/power/wakeup_active
    1
    Music Playback stopped
    $ cat /sys/devices/soc.0/qcom,ara-codec.82/power/wakeup_active
    0
    
    Tested-by: David Lin <dtwlin@google.com>
    Reviewed-by: David Lin <dtwlin@google.com>
    Reviewed-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Akash Choudhari <akashtc@google.com>
    Signed-off-by: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>

diff --git a/drivers/staging/greybus/audio_codec.c b/drivers/staging/greybus/audio_codec.c
index ba3bd36f0c0a..9ed35c4da280 100644
--- a/drivers/staging/greybus/audio_codec.c
+++ b/drivers/staging/greybus/audio_codec.c
@@ -7,6 +7,7 @@
  */
 #include <linux/kernel.h>
 #include <linux/module.h>
+#include <linux/pm_runtime.h>
 #include <sound/soc.h>
 #include <sound/pcm_params.h>
 #include <uapi/linux/input.h>
@@ -388,6 +389,8 @@ static int gbcodec_startup(struct snd_pcm_substream *substream,
 	codec->stream[substream->stream].state = state;
 	codec->stream[substream->stream].dai_name = dai->name;
 	mutex_unlock(&codec->lock);
+	/* to prevent suspend in case of active audio */
+	pm_stay_awake(dai->dev);
 
 	return ret;
 }
@@ -470,6 +473,7 @@ static void gbcodec_shutdown(struct snd_pcm_substream *substream,
 	codec->stream[substream->stream].state = state;
 	codec->stream[substream->stream].dai_name = NULL;
 	mutex_unlock(&codec->lock);
+	pm_relax(dai->dev);
 	return;
 }
 
@@ -1094,7 +1098,7 @@ static int gbcodec_probe(struct snd_soc_codec *codec)
 	snd_soc_codec_set_drvdata(codec, info);
 	gbcodec = info;
 
-	/* Empty function for now */
+        device_init_wakeup(codec->dev, 1);
 	return 0;
 }
 

commit 36460e8a895d1f7209c5a0d7c6a87b2ecc68cc4c
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Thu Apr 21 08:11:57 2016 +0530

    greybus: audio-codec: Staticize few routines to fix build warnings
    
    This fixes below warnings ..
    
    greybus/audio_codec.c:20:32: warning: symbol 'find_data' was not declared. Should it be static?
    greybus/audio_codec.c:955:6: warning: symbol 'gbaudio_codec_cleanup' was not declared. Should it be static?
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Reviewed-by: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/audio_codec.c b/drivers/staging/greybus/audio_codec.c
index 2c6142d9817a..ba3bd36f0c0a 100644
--- a/drivers/staging/greybus/audio_codec.c
+++ b/drivers/staging/greybus/audio_codec.c
@@ -17,8 +17,8 @@
 
 static struct gbaudio_codec_info *gbcodec;
 
-struct gbaudio_data_connection *find_data(struct gbaudio_module_info *module,
-					  const char *name)
+static struct gbaudio_data_connection *
+find_data(struct gbaudio_module_info *module, const char *name)
 {
 	struct gbaudio_data_connection *data;
 
@@ -952,7 +952,7 @@ int gbaudio_register_module(struct gbaudio_module_info *module)
 }
 EXPORT_SYMBOL(gbaudio_register_module);
 
-void gbaudio_codec_cleanup(struct gbaudio_module_info *module)
+static void gbaudio_codec_cleanup(struct gbaudio_module_info *module)
 {
 	struct gbaudio_data_connection *data;
 	int pb_state = gbcodec->stream[0].state;

commit 094c4302c11889683af54525221ca68f64c1a358
Author: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
Date:   Tue Mar 29 16:32:37 2016 +0530

    greybus: audio: Add I2S_RX path related settings
    
    Capture path related settings during startup, perpare &
    hwparams were earlier missing.
    
    Signed-off-by: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
    Reviewed-by: Mark Greer <mgreer@animalcreek.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/audio_codec.c b/drivers/staging/greybus/audio_codec.c
index 66a954806cf5..2c6142d9817a 100644
--- a/drivers/staging/greybus/audio_codec.c
+++ b/drivers/staging/greybus/audio_codec.c
@@ -72,16 +72,27 @@ static int gbaudio_module_disable(struct gbaudio_codec_info *codec,
 	if (!data) {
 		dev_err(codec->dev, "%s:%s DATA connection missing\n",
 			dai_name, module->name);
-		mutex_unlock(&module->lock);
-		mutex_unlock(&codec->lock);
-		return -ENODEV;
+		ret = -ENODEV;
+		goto func_exit;
 	}
 	if (codec_state > GBAUDIO_CODEC_HWPARAMS) {
 		data_cport = data->connection->intf_cport_id;
-		ret = gb_audio_gb_deactivate_tx(module->mgmt_connection,
+		switch(dir) {
+		case SNDRV_PCM_STREAM_CAPTURE:
+			ret = gb_audio_gb_deactivate_rx(
+						module->mgmt_connection,
+						data_cport);
+			break;
+		case SNDRV_PCM_STREAM_PLAYBACK:
+			ret = gb_audio_gb_deactivate_tx(
+						module->mgmt_connection,
 						data_cport);
+			break;
+		default:
+			ret = -EINVAL;
+		}
 		if (ret) {
-			dev_err(codec->dev, "deactivate_tx for %s failed:%d\n",
+			dev_err(codec->dev, "deactivate for %s failed:%d\n",
 				module->name, ret);
 			goto func_exit;
 		}
@@ -90,9 +101,22 @@ static int gbaudio_module_disable(struct gbaudio_codec_info *codec,
 	}
 	if (codec_state > GBAUDIO_CODEC_SHUTDOWN) {
 		cportid = data->connection->hd_cport_id;
-		ret = gb_audio_apbridgea_unregister_cport(data->connection,
+		switch(dir) {
+		case SNDRV_PCM_STREAM_CAPTURE:
+			ret = gb_audio_apbridgea_unregister_cport(
+						data->connection,
+						i2s_port, cportid,
+						AUDIO_APBRIDGEA_DIRECTION_RX);
+			break;
+		case SNDRV_PCM_STREAM_PLAYBACK:
+			ret = gb_audio_apbridgea_unregister_cport(
+						data->connection,
 						i2s_port, cportid,
 						AUDIO_APBRIDGEA_DIRECTION_TX);
+			break;
+		default:
+			ret = -EINVAL;
+		}
 		if (ret) {
 			dev_err(codec->dev, "unregister_cport for %s failed:%d\n",
 				module->name, ret);
@@ -148,18 +172,30 @@ static int gbaudio_module_enable(struct gbaudio_codec_info *codec,
 	if (!data) {
 		dev_err(codec->dev, "%s:%s DATA connection missing\n",
 			dai_name, module->name);
-		mutex_unlock(&module->lock);
-		mutex_unlock(&codec->lock);
-		return -ENODEV;
+		ret = -ENODEV;
+		goto func_exit;
 	}
 
 	/* register cport */
 	if (module_state < codec_state) {
 		i2s_port = 0;	/* fixed for now */
 		cportid = data->connection->hd_cport_id;
-		ret = gb_audio_apbridgea_register_cport(data->connection,
+		switch(dir) {
+		case SNDRV_PCM_STREAM_CAPTURE:
+				ret = gb_audio_apbridgea_register_cport(
+						data->connection,
+						i2s_port, cportid,
+						AUDIO_APBRIDGEA_DIRECTION_RX);
+				break;
+		case SNDRV_PCM_STREAM_PLAYBACK:
+				ret = gb_audio_apbridgea_register_cport(
+						data->connection,
 						i2s_port, cportid,
 						AUDIO_APBRIDGEA_DIRECTION_TX);
+				break;
+		default:
+				ret = -EINVAL;
+		}
 		if (ret) {
 			dev_err(codec->dev, "reg_cport for %s\n", module->name);
 			goto func_exit;
@@ -186,18 +222,46 @@ static int gbaudio_module_enable(struct gbaudio_codec_info *codec,
 	/* prepare */
 	if (module_state < codec_state) {
 		data_cport = data->connection->intf_cport_id;
-		ret = gb_audio_gb_set_tx_data_size(module->mgmt_connection,
-						   data_cport, 192);
-		if (ret) {
-			dev_err(codec->dev, "set_tx_data_size for %s\n",
-				module->name);
-			goto func_exit;
-		}
-		ret = gb_audio_gb_activate_tx(module->mgmt_connection,
-					      data_cport);
-		if (ret) {
-			dev_err(codec->dev, "activate_tx for %s\n",
-				module->name);
+		switch(dir) {
+		case SNDRV_PCM_STREAM_CAPTURE:
+			ret = gb_audio_gb_set_rx_data_size(
+						module->mgmt_connection,
+						data_cport, 192);
+			if (ret) {
+				dev_err(codec->dev,
+					"set_rx_data_size for %s\n",
+					module->name);
+				goto func_exit;
+			}
+			ret = gb_audio_gb_activate_rx(module->mgmt_connection,
+						      data_cport);
+			if (ret) {
+				dev_err(codec->dev, "activate_rx for %s\n",
+					module->name);
+				goto func_exit;
+			}
+			break;
+		case SNDRV_PCM_STREAM_PLAYBACK:
+			ret = gb_audio_gb_set_tx_data_size(
+						module->mgmt_connection,
+						data_cport, 192);
+			if (ret) {
+				dev_err(codec->dev,
+					"set_tx_data_size for %s\n",
+					module->name);
+				goto func_exit;
+			}
+			ret = gb_audio_gb_activate_tx(module->mgmt_connection,
+						      data_cport);
+			if (ret) {
+				dev_err(codec->dev, "activate_tx for %s\n",
+					module->name);
+				goto func_exit;
+			}
+			break;
+		default:
+			dev_err(codec->dev, "Inavlid stream direction\n");
+			ret = -EINVAL;
 			goto func_exit;
 		}
 		module_state = GBAUDIO_CODEC_PREPARE;
@@ -217,7 +281,7 @@ int gbaudio_module_update(struct gbaudio_codec_info *codec,
 				 struct gbaudio_module_info *module, int enable)
 {
 	int stream, ret = 0;
-	int pb_state;
+	int pb_state, cap_state;
 
 	dev_dbg(module->dev, "Module update %s sequence\n",
 		enable ? "Enable":"Disable");
@@ -239,12 +303,16 @@ int gbaudio_module_update(struct gbaudio_codec_info *codec,
 						     SNDRV_PCM_STREAM_PLAYBACK);
 	}
 
-	/* TBD
-	 * check if capture active
-	 * cap_state = codec->stream[SNDRV_PCM_STREAM_CAPTURE].state;
-	 * if ((stream & GB_CAPTURE) && (cap_state > GBAUDIO_CODEC_SHUTDOWN))
-	 *
-	 */
+	/* check if capture active */
+	cap_state = codec->stream[SNDRV_PCM_STREAM_CAPTURE].state;
+	if ((stream & GB_CAPTURE) && (cap_state > GBAUDIO_CODEC_SHUTDOWN)) {
+		if (enable)
+			ret = gbaudio_module_enable(codec, module,
+						    SNDRV_PCM_STREAM_CAPTURE);
+		else
+			ret = gbaudio_module_disable(codec, module,
+						     SNDRV_PCM_STREAM_CAPTURE);
+	}
 
 	return ret;
 }
@@ -291,9 +359,25 @@ static int gbcodec_startup(struct snd_pcm_substream *substream,
 		/* register cport */
 		i2s_port = 0;	/* fixed for now */
 		cportid = data->connection->hd_cport_id;
-		ret = gb_audio_apbridgea_register_cport(data->connection,
+		switch (substream->stream) {
+		case SNDRV_PCM_STREAM_CAPTURE:
+			ret = gb_audio_apbridgea_register_cport(
+						data->connection,
+						i2s_port, cportid,
+						AUDIO_APBRIDGEA_DIRECTION_RX);
+			break;
+		case SNDRV_PCM_STREAM_PLAYBACK:
+			ret = gb_audio_apbridgea_register_cport(
+						data->connection,
 						i2s_port, cportid,
 						AUDIO_APBRIDGEA_DIRECTION_TX);
+			break;
+		default:
+			dev_err(dai->dev, "Inavlid stream\n");
+			mutex_unlock(&module->lock);
+			mutex_unlock(&codec->lock);
+			return -EINVAL;
+		}
 		dev_dbg(dai->dev, "Register %s:%d DAI, ret:%d\n", dai->name,
 			cportid, ret);
 		state = GBAUDIO_CODEC_STARTUP;

commit 64a7e2cceb75ccabaec713944a95511605751b29
Author: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
Date:   Tue Mar 29 16:32:36 2016 +0530

    greybus: audio: Added jack support to audio module
    
    Register jack with ASoC sound card in case audio module
    populates it via codec FW. Currently, only a single jack
    with 4 buttons can be registered for each module.
    
    Signed-off-by: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
    Reviewed-by: Mark Greer <mgreer@animalcreek.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/audio_codec.c b/drivers/staging/greybus/audio_codec.c
index 803bab20cf0c..66a954806cf5 100644
--- a/drivers/staging/greybus/audio_codec.c
+++ b/drivers/staging/greybus/audio_codec.c
@@ -9,6 +9,7 @@
 #include <linux/module.h>
 #include <sound/soc.h>
 #include <sound/pcm_params.h>
+#include <uapi/linux/input.h>
 
 #include "audio_codec.h"
 #include "audio_apbridgea.h"
@@ -735,10 +736,80 @@ static struct snd_soc_dai_ops gbcodec_dai_ops = {
 	.digital_mute = gbcodec_digital_mute,
 };
 
+static int gbaudio_init_jack(struct gbaudio_module_info *module,
+			     struct snd_soc_codec *codec)
+{
+	int ret;
+
+	if (!module->num_jacks)
+		return 0;
+
+	/* register jack(s) in case any */
+	if (module->num_jacks > 1) {
+		dev_err(module->dev, "Currently supports max=1 jack\n");
+		return -EINVAL;
+	}
+
+	snprintf(module->jack_name, NAME_SIZE, "GB %d Headset Jack",
+		 module->dev_id);
+	ret = snd_soc_jack_new(codec, module->jack_name, GBCODEC_JACK_MASK,
+			       &module->headset_jack);
+	if (ret) {
+		dev_err(module->dev, "Failed to create new jack\n");
+		return ret;
+	}
+
+	snprintf(module->button_name, NAME_SIZE, "GB %d Button Jack",
+		 module->dev_id);
+	ret = snd_soc_jack_new(codec, module->button_name,
+			       GBCODEC_JACK_BUTTON_MASK, &module->button_jack);
+	if (ret) {
+		dev_err(module->dev, "Failed to create button jack\n");
+		return ret;
+	}
+
+	ret = snd_jack_set_key(module->button_jack.jack, SND_JACK_BTN_0,
+			       KEY_MEDIA);
+	if (ret) {
+		dev_err(module->dev, "Failed to set BTN_0\n");
+		return ret;
+	}
+
+	ret = snd_jack_set_key(module->button_jack.jack, SND_JACK_BTN_1,
+			       KEY_VOICECOMMAND);
+	if (ret) {
+		dev_err(module->dev, "Failed to set BTN_1\n");
+		return ret;
+	}
+
+	ret = snd_jack_set_key(module->button_jack.jack, SND_JACK_BTN_2,
+			       KEY_VOLUMEUP);
+	if (ret) {
+		dev_err(module->dev, "Failed to set BTN_2\n");
+		return ret;
+	}
+
+	ret = snd_jack_set_key(module->button_jack.jack, SND_JACK_BTN_3,
+			       KEY_VOLUMEDOWN);
+	if (ret) {
+		dev_err(module->dev, "Failed to set BTN_0\n");
+		return ret;
+	}
+
+	/* FIXME
+	 * verify if this is really required
+	set_bit(INPUT_PROP_NO_DUMMY_RELEASE,
+		module->button_jack.jack->input_dev->propbit);
+	*/
+
+	return 0;
+}
+
 int gbaudio_register_module(struct gbaudio_module_info *module)
 {
 	int ret;
 	struct snd_soc_codec *codec;
+	struct snd_soc_jack *jack = NULL;
 
 	if (!gbcodec) {
 		dev_err(module->dev, "GB Codec not yet probed\n");
@@ -756,6 +827,12 @@ int gbaudio_register_module(struct gbaudio_module_info *module)
 		return -EINVAL;
 	}
 
+	ret = gbaudio_init_jack(module, codec);
+	if (ret) {
+		mutex_unlock(&gbcodec->lock);
+		return ret;
+	}
+
 	if (module->dapm_widgets)
 		snd_soc_dapm_new_controls(&codec->dapm, module->dapm_widgets,
 					  module->num_dapm_widgets);
@@ -774,6 +851,15 @@ int gbaudio_register_module(struct gbaudio_module_info *module)
 								&codec->dapm);
 	}
 
+#ifdef CONFIG_SND_JACK
+	/* register jack devices for this module from codec->jack_list */
+	list_for_each_entry(jack, &codec->jack_list, list) {
+		if ((jack == &module->headset_jack)
+		    || (jack == &module->button_jack))
+			snd_device_register(codec->card->snd_card, jack->jack);
+	}
+#endif
+
 	list_add(&module->list, &gbcodec->module_list);
 	dev_dbg(codec->dev, "Registered %s module\n", module->name);
 
@@ -851,6 +937,7 @@ void gbaudio_unregister_module(struct gbaudio_module_info *module)
 {
 	struct snd_soc_codec *codec = gbcodec->codec;
 	struct snd_card *card = codec->card->snd_card;
+	struct snd_soc_jack *jack, *next_j;
 
 	dev_dbg(codec->dev, "Unregister %s module\n", module->name);
 
@@ -862,6 +949,17 @@ void gbaudio_unregister_module(struct gbaudio_module_info *module)
 	dev_dbg(codec->dev, "Process Unregister %s module\n", module->name);
 	mutex_lock(&module->lock);
 
+#ifdef CONFIG_SND_JACK
+	/* free jack devices for this module from codec->jack_list */
+	list_for_each_entry_safe(jack, next_j, &codec->jack_list, list) {
+		if ((jack == &module->headset_jack)
+		    || (jack == &module->button_jack)) {
+			snd_device_free(codec->card->snd_card, jack->jack);
+			list_del(&jack->list);
+		}
+	}
+#endif
+
 	gbaudio_codec_cleanup(module);
 
 	module->is_connected = 0;

commit d764212f73cf270f10b041d8e26a8eb1ee7d4909
Author: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
Date:   Tue Mar 29 23:31:43 2016 +0530

    greybus: audio: fix to resolve multiple audio module playback issue
    
    Cleanup APBridge sequence only in case of last module plugged-out.
    For other modules, unregister cportid is sufficient.
    
    Signed-off-by: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
    Reviewed-by: Mark Greer <mark.greer@animalcreek.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/audio_codec.c b/drivers/staging/greybus/audio_codec.c
index ab24ec8c5ab8..803bab20cf0c 100644
--- a/drivers/staging/greybus/audio_codec.c
+++ b/drivers/staging/greybus/audio_codec.c
@@ -794,6 +794,7 @@ void gbaudio_codec_cleanup(struct gbaudio_module_info *module)
 	if (!pb_state && !cap_state)
 		return;
 
+	dev_dbg(gbcodec->dev, "%s: removed, cleanup APBridge\n", module->name);
 	if (pb_state == GBAUDIO_CODEC_START) {
 		/* cleanup PB path, only APBridge specific */
 		data = find_data(module, gbcodec->stream[0].dai_name);
@@ -802,12 +803,16 @@ void gbaudio_codec_cleanup(struct gbaudio_module_info *module)
 				__func__);
 			return;
 		}
-		ret = gb_audio_apbridgea_stop_tx(data->connection, 0);
-		if (ret)
-			return;
-		ret = gb_audio_apbridgea_shutdown_tx(data->connection, 0);
-		if (ret)
-			return;
+
+		if (list_is_singular(&gbcodec->module_list)) {
+			ret = gb_audio_apbridgea_stop_tx(data->connection, 0);
+			if (ret)
+				return;
+			ret = gb_audio_apbridgea_shutdown_tx(data->connection,
+							     0);
+			if (ret)
+				return;
+		}
 		i2s_port = 0;	/* fixed for now */
 		cportid = data->connection->hd_cport_id;
 		ret = gb_audio_apbridgea_unregister_cport(data->connection,
@@ -824,12 +829,15 @@ void gbaudio_codec_cleanup(struct gbaudio_module_info *module)
 				__func__);
 			return;
 		}
-		ret = gb_audio_apbridgea_stop_rx(data->connection, 0);
-		if (ret)
-			return;
-		ret = gb_audio_apbridgea_shutdown_rx(data->connection, 0);
-		if (ret)
-			return;
+		if (list_is_singular(&gbcodec->module_list)) {
+			ret = gb_audio_apbridgea_stop_rx(data->connection, 0);
+			if (ret)
+				return;
+			ret = gb_audio_apbridgea_shutdown_rx(data->connection,
+							     0);
+			if (ret)
+				return;
+		}
 		i2s_port = 0;	/* fixed for now */
 		cportid = data->connection->hd_cport_id;
 		ret = gb_audio_apbridgea_unregister_cport(data->connection,
@@ -854,10 +862,7 @@ void gbaudio_unregister_module(struct gbaudio_module_info *module)
 	dev_dbg(codec->dev, "Process Unregister %s module\n", module->name);
 	mutex_lock(&module->lock);
 
-	if (list_is_last(&module->list, &gbcodec->module_list)) {
-		dev_dbg(codec->dev, "Last module removed, cleanup APBridge\n");
-		gbaudio_codec_cleanup(module);
-	}
+	gbaudio_codec_cleanup(module);
 
 	module->is_connected = 0;
 	if (module->dapm_routes) {

commit 6dd67645f22cfeb55a32e9a08c92deb297d06935
Author: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
Date:   Tue Mar 29 23:31:41 2016 +0530

    greybus: audio: Use single codec driver registration
    
    We have single I2S port via APB1 for communication with all
    audio modules. Thus, we should register single codec driver
    and manage all individual audio modules internally within
    this driver.
    
    Signed-off-by: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
    Reviewed-by: Mark Greer <mark.greer@animalcreek.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/audio_codec.c b/drivers/staging/greybus/audio_codec.c
index 30b381ab8a1f..ab24ec8c5ab8 100644
--- a/drivers/staging/greybus/audio_codec.c
+++ b/drivers/staging/greybus/audio_codec.c
@@ -1,7 +1,7 @@
 /*
- * Greybus audio driver
- * Copyright 2015 Google Inc.
- * Copyright 2015 Linaro Ltd.
+ * audio codec driver
+ * Copyright 2016 Google Inc.
+ * Copyright 2016 Linaro Ltd.
  *
  * Released under the GPLv2 only.
  */
@@ -9,128 +9,382 @@
 #include <linux/module.h>
 #include <sound/soc.h>
 #include <sound/pcm_params.h>
-#include <sound/msm-dynamic-dailink.h>
 
 #include "audio_codec.h"
 #include "audio_apbridgea.h"
 #include "audio_manager.h"
 
-static DEFINE_MUTEX(gb_codec_list_lock);
-static LIST_HEAD(gb_codec_list);
+static struct gbaudio_codec_info *gbcodec;
 
-struct gbaudio_dai *gbaudio_find_dai(struct gbaudio_codec_info *gbcodec,
-				     int data_cport, const char *name)
+struct gbaudio_data_connection *find_data(struct gbaudio_module_info *module,
+					  const char *name)
 {
-	struct gbaudio_dai *dai;
+	struct gbaudio_data_connection *data;
 
-	list_for_each_entry(dai, &gbcodec->dai_list, list) {
-		if (name && !strncmp(dai->name, name, NAME_SIZE))
-			return dai;
-		if ((data_cport != -1) && (dai->data_cport == data_cport))
-			return dai;
+	list_for_each_entry(data, &module->data_list, list) {
+		if (name && !strncmp(data->name, name, NAME_SIZE))
+			return data;
 	}
 	return NULL;
 }
 
-/*
- * codec DAI ops
- */
-static int gbcodec_startup(struct snd_pcm_substream *substream,
-			   struct snd_soc_dai *dai)
+static int find_stream(const char *name)
 {
-	int ret;
-	__u16 i2s_port, cportid;
+	int stream = 0;
+
+	if (strnstr(name, "SPK Amp", NAME_SIZE))
+		stream |= GB_PLAYBACK;
+
+	return stream;
+}
+
+static int gbaudio_module_disable(struct gbaudio_codec_info *codec,
+				  struct gbaudio_module_info *module,
+				  int dir)
+{
+	int ret = 0;
+	uint16_t data_cport, cportid, i2s_port;
+	int codec_state, module_state;
+	struct gbaudio_data_connection *data;
+	const char *dai_name;
+
+	mutex_lock(&codec->lock);
+
+	codec_state = codec->stream[dir].state;
+	if (codec_state == GBAUDIO_CODEC_SHUTDOWN) {
+		mutex_unlock(&codec->lock);
+		return 0;
+	}
+
+	dai_name = codec->stream[dir].dai_name;
 
-	struct gbaudio_dai *gb_dai;
-	struct gbaudio_codec_info *gb = dev_get_drvdata(dai->dev);
+	mutex_lock(&module->lock);
+	module_state = module->ctrlstate[dir];
+	if (module_state == GBAUDIO_CODEC_SHUTDOWN) {
+		dev_dbg(codec->dev, "%s: module already configured\n",
+			module->name);
+		goto func_exit;
+	}
 
-	if (!atomic_read(&gb->is_connected))
+	/* find the dai */
+	data = find_data(module, dai_name);
+	if (!data) {
+		dev_err(codec->dev, "%s:%s DATA connection missing\n",
+			dai_name, module->name);
+		mutex_unlock(&module->lock);
+		mutex_unlock(&codec->lock);
 		return -ENODEV;
+	}
+	if (codec_state > GBAUDIO_CODEC_HWPARAMS) {
+		data_cport = data->connection->intf_cport_id;
+		ret = gb_audio_gb_deactivate_tx(module->mgmt_connection,
+						data_cport);
+		if (ret) {
+			dev_err(codec->dev, "deactivate_tx for %s failed:%d\n",
+				module->name, ret);
+			goto func_exit;
+		}
+		dev_dbg(codec->dev, "Dynamic deactivate %s:%d DAI\n", dai_name,
+			data_cport);
+	}
+	if (codec_state > GBAUDIO_CODEC_SHUTDOWN) {
+		cportid = data->connection->hd_cport_id;
+		ret = gb_audio_apbridgea_unregister_cport(data->connection,
+						i2s_port, cportid,
+						AUDIO_APBRIDGEA_DIRECTION_TX);
+		if (ret) {
+			dev_err(codec->dev, "unregister_cport for %s failed:%d\n",
+				module->name, ret);
+			goto func_exit;
+		}
+		dev_dbg(codec->dev, "Dynamic Unregister %s:%d DAI\n", dai_name,
+			cportid);
+	}
+	module->ctrlstate[dir] = GBAUDIO_CODEC_SHUTDOWN;
+
+func_exit:
+	mutex_unlock(&module->lock);
+	mutex_unlock(&codec->lock);
+	return ret;
+}
+
+static int gbaudio_module_enable(struct gbaudio_codec_info *codec,
+				 struct gbaudio_module_info *module, int dir)
+{
+	int ret = 0;
+	__u16 i2s_port, cportid;
+	int codec_state, module_state;
+	uint16_t data_cport;
+	uint8_t sig_bits, channels;
+	uint32_t format, rate;
+	struct gbaudio_data_connection *data;
+	const char *dai_name;
+
+	mutex_lock(&codec->lock);
+
+	codec_state = codec->stream[dir].state;
+	if (codec_state == GBAUDIO_CODEC_SHUTDOWN) {
+		mutex_unlock(&codec->lock);
+		return 0;
+	}
+
+	dai_name = codec->stream[dir].dai_name;
+	format = codec->stream[dir].format;
+	channels = codec->stream[dir].channels;
+	rate = codec->stream[dir].rate;
+	sig_bits = codec->stream[dir].sig_bits;
+
+	mutex_lock(&module->lock);
+	module_state = module->ctrlstate[dir];
+	if (module_state == codec_state) {
+		dev_dbg(codec->dev, "%s: module already configured\n",
+			module->name);
+		goto func_exit;
+	}
 
 	/* find the dai */
-	mutex_lock(&gb->lock);
-	gb_dai = gbaudio_find_dai(gb, -1, dai->name);
-	if (!gb_dai) {
-		dev_err(dai->dev, "%s: DAI not registered\n", dai->name);
-		mutex_unlock(&gb->lock);
-		return -EINVAL;
+	data = find_data(module, dai_name);
+	if (!data) {
+		dev_err(codec->dev, "%s:%s DATA connection missing\n",
+			dai_name, module->name);
+		mutex_unlock(&module->lock);
+		mutex_unlock(&codec->lock);
+		return -ENODEV;
 	}
 
 	/* register cport */
-	i2s_port = 0;	/* fixed for now */
-	cportid = gb_dai->connection->hd_cport_id;
-	ret = gb_audio_apbridgea_register_cport(gb_dai->connection, i2s_port,
-						cportid,
+	if (module_state < codec_state) {
+		i2s_port = 0;	/* fixed for now */
+		cportid = data->connection->hd_cport_id;
+		ret = gb_audio_apbridgea_register_cport(data->connection,
+						i2s_port, cportid,
 						AUDIO_APBRIDGEA_DIRECTION_TX);
-	dev_dbg(dai->dev, "Register %s:%d DAI, ret:%d\n", dai->name, cportid,
-		ret);
+		if (ret) {
+			dev_err(codec->dev, "reg_cport for %s\n", module->name);
+			goto func_exit;
+		}
+		module_state = GBAUDIO_CODEC_STARTUP;
+		dev_dbg(codec->dev, "Dynamic Register %s:%d DAI\n", dai_name,
+			cportid);
+	}
+
+	/* hw_params */
+	if (module_state < codec_state) {
+		data_cport = data->connection->intf_cport_id;
+		ret = gb_audio_gb_set_pcm(module->mgmt_connection, data_cport,
+					  format, rate, channels, sig_bits);
+		if (ret) {
+			dev_err(codec->dev, "set_pcm for %s\n", module->name);
+			goto func_exit;
+		}
+		module_state = GBAUDIO_CODEC_HWPARAMS;
+		dev_dbg(codec->dev, "Dynamic hw_params %s:%d DAI\n", dai_name,
+			data_cport);
+	}
 
-	if (!ret)
-		atomic_inc(&gb_dai->users);
-	mutex_unlock(&gb->lock);
+	/* prepare */
+	if (module_state < codec_state) {
+		data_cport = data->connection->intf_cport_id;
+		ret = gb_audio_gb_set_tx_data_size(module->mgmt_connection,
+						   data_cport, 192);
+		if (ret) {
+			dev_err(codec->dev, "set_tx_data_size for %s\n",
+				module->name);
+			goto func_exit;
+		}
+		ret = gb_audio_gb_activate_tx(module->mgmt_connection,
+					      data_cport);
+		if (ret) {
+			dev_err(codec->dev, "activate_tx for %s\n",
+				module->name);
+			goto func_exit;
+		}
+		module_state = GBAUDIO_CODEC_PREPARE;
+		dev_dbg(codec->dev, "Dynamic prepare %s:%d DAI\n", dai_name,
+			data_cport);
+	}
 
+func_exit:
+	module->ctrlstate[dir] = module_state;
+	mutex_unlock(&module->lock);
+	mutex_unlock(&codec->lock);
 	return ret;
 }
 
-static void gbcodec_shutdown(struct snd_pcm_substream *substream,
-			     struct snd_soc_dai *dai)
+int gbaudio_module_update(struct gbaudio_codec_info *codec,
+				 const char *w_name,
+				 struct gbaudio_module_info *module, int enable)
 {
-	int ret;
-	__u16 i2s_port, cportid;
+	int stream, ret = 0;
+	int pb_state;
 
-	struct gbaudio_dai *gb_dai;
-	struct gbaudio_codec_info *gb = dev_get_drvdata(dai->dev);
+	dev_dbg(module->dev, "Module update %s sequence\n",
+		enable ? "Enable":"Disable");
 
-	/* find the dai */
-	gb_dai = gbaudio_find_dai(gb, -1, dai->name);
-	if (!gb_dai) {
-		dev_err(dai->dev, "%s: DAI not registered\n", dai->name);
-		goto func_exit;
+	stream = find_stream(w_name);
+	if (!stream) {
+		dev_dbg(codec->dev, "No action required for %s\n", w_name);
+		return 0;
 	}
 
-	atomic_dec(&gb_dai->users);
+	/* check if playback active */
+	pb_state = codec->stream[SNDRV_PCM_STREAM_PLAYBACK].state;
+	if ((stream & GB_PLAYBACK) && (pb_state > GBAUDIO_CODEC_SHUTDOWN)) {
+		if (enable)
+			ret = gbaudio_module_enable(codec, module,
+						    SNDRV_PCM_STREAM_PLAYBACK);
+		else
+			ret = gbaudio_module_disable(codec, module,
+						     SNDRV_PCM_STREAM_PLAYBACK);
+	}
 
-	if (!atomic_read(&gb->is_connected)) {
-		if (!atomic_read(&gb_dai->users))
-			wake_up_interruptible(&gb_dai->wait_queue);
-		return;
+	/* TBD
+	 * check if capture active
+	 * cap_state = codec->stream[SNDRV_PCM_STREAM_CAPTURE].state;
+	 * if ((stream & GB_CAPTURE) && (cap_state > GBAUDIO_CODEC_SHUTDOWN))
+	 *
+	 */
+
+	return ret;
+}
+EXPORT_SYMBOL(gbaudio_module_update);
+
+/*
+ * codec DAI ops
+ */
+static int gbcodec_startup(struct snd_pcm_substream *substream,
+			   struct snd_soc_dai *dai)
+{
+	int ret = 0;
+	__u16 i2s_port, cportid;
+	int state;
+	struct gbaudio_data_connection *data;
+	struct gbaudio_module_info *module;
+	struct gbaudio_codec_info *codec = dev_get_drvdata(dai->dev);
+
+	mutex_lock(&codec->lock);
+
+	if (list_empty(&codec->module_list)) {
+		dev_err(codec->dev, "No codec module available\n");
+		mutex_unlock(&codec->lock);
+		return -ENODEV;
 	}
 
-	mutex_lock(&gb->lock);
-	/* deactivate rx/tx */
-	cportid = gb_dai->connection->intf_cport_id;
+	state = codec->stream[substream->stream].state;
+	list_for_each_entry(module, &codec->module_list, list) {
+		mutex_lock(&module->lock);
+		if (!module->is_connected) {
+			mutex_unlock(&module->lock);
+			continue;
+		}
 
-	switch (substream->stream) {
-	case SNDRV_PCM_STREAM_CAPTURE:
-		ret = gb_audio_gb_deactivate_rx(gb->mgmt_connection, cportid);
-		break;
-	case SNDRV_PCM_STREAM_PLAYBACK:
-		ret = gb_audio_gb_deactivate_tx(gb->mgmt_connection, cportid);
-		break;
-	default:
-		dev_err(dai->dev, "Invalid stream type during shutdown\n");
-		goto func_exit;
+		/* find the dai */
+		data = find_data(module, dai->name);
+		if (!data) {
+			dev_err(dai->dev, "%s:%s DATA connection missing\n",
+				dai->name, module->name);
+			mutex_unlock(&module->lock);
+			continue;
+		}
+
+		/* register cport */
+		i2s_port = 0;	/* fixed for now */
+		cportid = data->connection->hd_cport_id;
+		ret = gb_audio_apbridgea_register_cport(data->connection,
+						i2s_port, cportid,
+						AUDIO_APBRIDGEA_DIRECTION_TX);
+		dev_dbg(dai->dev, "Register %s:%d DAI, ret:%d\n", dai->name,
+			cportid, ret);
+		state = GBAUDIO_CODEC_STARTUP;
+		module->ctrlstate[substream->stream] = state;
+		dev_dbg(dai->dev, "%s: state:%d\n", module->name, state);
+		mutex_unlock(&module->lock);
 	}
+	codec->stream[substream->stream].state = state;
+	codec->stream[substream->stream].dai_name = dai->name;
+	mutex_unlock(&codec->lock);
 
-	if (ret)
-		dev_err(dai->dev, "%d:Error during deactivate\n", ret);
+	return ret;
+}
 
-	/* un register cport */
-	i2s_port = 0;	/* fixed for now */
-	ret = gb_audio_apbridgea_unregister_cport(gb_dai->connection, i2s_port,
-					gb_dai->connection->hd_cport_id,
-					AUDIO_APBRIDGEA_DIRECTION_TX);
+static void gbcodec_shutdown(struct snd_pcm_substream *substream,
+			     struct snd_soc_dai *dai)
+{
+	int ret;
+	__u16 i2s_port, cportid;
+	int state, module_state;
+	struct gbaudio_module_info *module;
+	struct gbaudio_data_connection *data;
+	struct gbaudio_codec_info *codec = dev_get_drvdata(dai->dev);
 
-	dev_dbg(dai->dev, "Unregister %s:%d DAI, ret:%d\n", dai->name,
-		gb_dai->connection->hd_cport_id, ret);
-func_exit:
-	mutex_unlock(&gb->lock);
+	mutex_lock(&codec->lock);
 
-	/*
-	if (!atomic_read(&gb_dai->users))
-		wake_up_interruptible(&gb_dai->wait_queue);
-		*/
+	if (list_empty(&codec->module_list)) {
+		dev_err(codec->dev, "No codec module available\n");
+		mutex_unlock(&codec->lock);
+		return;
+	}
+
+	state = codec->stream[substream->stream].state;
+	list_for_each_entry(module, &codec->module_list, list) {
+		mutex_lock(&module->lock);
+		if (!module->is_connected) {
+			dev_err(dai->dev, "%s:%s module not connected\n",
+				__func__, module->name);
+			mutex_unlock(&module->lock);
+			continue;
+		}
+		module_state = module->ctrlstate[substream->stream];
+		if (module_state == GBAUDIO_CODEC_SHUTDOWN) {
+			dev_dbg(codec->dev, "%s: module already configured\n",
+				module->name);
+			mutex_unlock(&module->lock);
+			continue;
+		}
+
+		/* find the dai */
+		data = find_data(module, dai->name);
+		if (!data) {
+			dev_err(dai->dev, "%s:%s DATA connection missing\n",
+				dai->name, module->name);
+			mutex_unlock(&module->lock);
+			continue;
+		}
 
+		/* deactivate */
+		cportid = data->connection->intf_cport_id;
+		switch (substream->stream) {
+		case SNDRV_PCM_STREAM_CAPTURE:
+			ret = gb_audio_gb_deactivate_rx(module->mgmt_connection,
+							cportid);
+			/* unregister cport */
+			i2s_port = 0;	/* fixed for now */
+			cportid = data->connection->hd_cport_id;
+			ret = gb_audio_apbridgea_unregister_cport(
+					data->connection, i2s_port, cportid,
+					AUDIO_APBRIDGEA_DIRECTION_RX);
+			break;
+		case SNDRV_PCM_STREAM_PLAYBACK:
+			ret = gb_audio_gb_deactivate_tx(module->mgmt_connection,
+							cportid);
+			/* unregister cport */
+			i2s_port = 0;	/* fixed for now */
+			cportid = data->connection->hd_cport_id;
+			ret = gb_audio_apbridgea_unregister_cport(
+					data->connection, i2s_port, cportid,
+					AUDIO_APBRIDGEA_DIRECTION_TX);
+			break;
+		}
+		dev_dbg(dai->dev, "Unregister %s:%d DAI, ret:%d\n", dai->name,
+			cportid, ret);
+		state = GBAUDIO_CODEC_SHUTDOWN;
+		module->ctrlstate[substream->stream] = state;
+		dev_dbg(dai->dev, "%s: state:%d\n", module->name, state);
+		mutex_unlock(&module->lock);
+	}
+	codec->stream[substream->stream].state = state;
+	codec->stream[substream->stream].dai_name = NULL;
+	mutex_unlock(&codec->lock);
 	return;
 }
 
@@ -142,19 +396,17 @@ static int gbcodec_hw_params(struct snd_pcm_substream *substream,
 	uint8_t sig_bits, channels;
 	uint32_t format, rate;
 	uint16_t data_cport;
-	struct gbaudio_dai *gb_dai;
-	struct gbaudio_codec_info *gb = dev_get_drvdata(dai->dev);
+	struct gbaudio_module_info *module;
+	struct gbaudio_data_connection *data;
+	int state;
+	struct gbaudio_codec_info *codec = dev_get_drvdata(dai->dev);
 
-	if (!atomic_read(&gb->is_connected))
-		return -ENODEV;
+	mutex_lock(&codec->lock);
 
-	/* find the dai */
-	mutex_lock(&gb->lock);
-	gb_dai = gbaudio_find_dai(gb, -1, dai->name);
-	if (!gb_dai) {
-		dev_err(dai->dev, "%s: DAI not registered\n", dai->name);
-		ret = -EINVAL;
-		goto func_exit;
+	if (list_empty(&codec->module_list)) {
+		dev_err(codec->dev, "No codec module available\n");
+		mutex_unlock(&codec->lock);
+		return -ENODEV;
 	}
 
 	/*
@@ -164,54 +416,86 @@ static int gbcodec_hw_params(struct snd_pcm_substream *substream,
 	if (params_channels(hwparams) != 2) {
 		dev_err(dai->dev, "Invalid channel count:%d\n",
 			params_channels(hwparams));
-		ret = -EINVAL;
-		goto func_exit;
+		mutex_unlock(&codec->lock);
+		return -EINVAL;
 	}
 	channels = params_channels(hwparams);
 
 	if (params_rate(hwparams) != 48000) {
 		dev_err(dai->dev, "Invalid sampling rate:%d\n",
 			params_rate(hwparams));
-		ret = -EINVAL;
-		goto func_exit;
+		mutex_unlock(&codec->lock);
+		return -EINVAL;
 	}
 	rate = GB_AUDIO_PCM_RATE_48000;
 
 	if (params_format(hwparams) != SNDRV_PCM_FORMAT_S16_LE) {
 		dev_err(dai->dev, "Invalid format:%d\n",
 			params_format(hwparams));
-		ret = -EINVAL;
-		goto func_exit;
+		mutex_unlock(&codec->lock);
+		return -EINVAL;
 	}
 	format = GB_AUDIO_PCM_FMT_S16_LE;
 
-	data_cport = gb_dai->connection->intf_cport_id;
-	/* XXX check impact of sig_bit
-	 * it should not change ideally
-	 */
+	state = codec->stream[substream->stream].state;
+	list_for_each_entry(module, &codec->module_list, list) {
+		mutex_lock(&module->lock);
+		if (!module->is_connected) {
+			dev_err(dai->dev, "%s:%s module not connected\n",
+				__func__, module->name);
+			ret = -ENODEV;
+			mutex_unlock(&module->lock);
+			continue;
+		}
 
-	dev_dbg(dai->dev, "cport:%d, rate:%d, channel %d, format %d, sig_bits:%d\n",
-		data_cport, rate, channels, format, sig_bits);
-	ret = gb_audio_gb_set_pcm(gb->mgmt_connection, data_cport, format,
-				  rate, channels, sig_bits);
-	if (ret) {
-		dev_err(dai->dev, "%d: Error during set_pcm\n", ret);
-		goto func_exit;
+		/* find the data connection */
+		data = find_data(module, dai->name);
+		if (!data) {
+			dev_err(dai->dev, "%s:%s DATA connection missing\n",
+				dai->name, module->name);
+			mutex_unlock(&module->lock);
+			continue;
+		}
+
+		data_cport = data->connection->intf_cport_id;
+		/* XXX check impact of sig_bit
+		 * it should not change ideally
+		 */
+		dev_dbg(dai->dev,
+			"cport:%d, rate:%d, channel %d, format %d, sig_bits:%d\n",
+			data_cport, rate, channels, format, sig_bits);
+		ret = gb_audio_gb_set_pcm(module->mgmt_connection, data_cport,
+					  format, rate, channels, sig_bits);
+		if (ret) {
+			dev_err(dai->dev, "%d: Error during set_pcm\n", ret);
+			mutex_unlock(&module->lock);
+			goto func_exit;
+		}
+		if (state < GBAUDIO_CODEC_HWPARAMS) {
+			ret = gb_audio_apbridgea_set_config(data->connection, 0,
+						AUDIO_APBRIDGEA_PCM_FMT_16,
+						AUDIO_APBRIDGEA_PCM_RATE_48000,
+						6144000);
+			if (ret) {
+				dev_err(dai->dev,
+					"%d: Error during set_config\n", ret);
+				mutex_unlock(&module->lock);
+				goto func_exit;
+			}
+		}
+		state = GBAUDIO_CODEC_HWPARAMS;
+		module->ctrlstate[substream->stream] = state;
+		dev_dbg(dai->dev, "%s: state:%d\n", module->name, state);
+		mutex_unlock(&module->lock);
 	}
+	codec->stream[substream->stream].state = state;
+	codec->stream[substream->stream].format = format;
+	codec->stream[substream->stream].rate = rate;
+	codec->stream[substream->stream].channels = channels;
+	codec->stream[substream->stream].sig_bits = sig_bits;
 
-	/*
-	 * XXX need to check if
-	 * set config is always required
-	 * check for mclk_freq as well
-	 */
-	ret = gb_audio_apbridgea_set_config(gb_dai->connection, 0,
-					    AUDIO_APBRIDGEA_PCM_FMT_16,
-					    AUDIO_APBRIDGEA_PCM_RATE_48000,
-					    6144000);
-	if (ret)
-		dev_err(dai->dev, "%d: Error during set_config\n", ret);
 func_exit:
-	mutex_unlock(&gb->lock);
+	mutex_unlock(&codec->lock);
 	return ret;
 }
 
@@ -220,76 +504,110 @@ static int gbcodec_prepare(struct snd_pcm_substream *substream,
 {
 	int ret;
 	uint16_t data_cport;
-	struct gbaudio_dai *gb_dai;
-	struct gbaudio_codec_info *gb = dev_get_drvdata(dai->dev);
+	struct gbaudio_data_connection *data;
+	struct gbaudio_module_info *module;
+	int state;
+	struct gbaudio_codec_info *codec = dev_get_drvdata(dai->dev);
 
-	if (!atomic_read(&gb->is_connected))
-		return -ENODEV;
+	mutex_lock(&codec->lock);
 
-	/* find the dai */
-	mutex_lock(&gb->lock);
-	gb_dai = gbaudio_find_dai(gb, -1, dai->name);
-	if (!gb_dai) {
-		dev_err(dai->dev, "%s: DAI not registered\n", dai->name);
-		ret = -EINVAL;
-		goto func_exit;
+	if (list_empty(&codec->module_list)) {
+		dev_err(codec->dev, "No codec module available\n");
+		mutex_unlock(&codec->lock);
+		return -ENODEV;
 	}
 
-	/* deactivate rx/tx */
-	data_cport = gb_dai->connection->intf_cport_id;
+	state = codec->stream[substream->stream].state;
+	list_for_each_entry(module, &codec->module_list, list) {
+		mutex_lock(&module->lock);
+		if (!module->is_connected) {
+			mutex_unlock(&module->lock);
+			continue;
+		}
 
-	switch (substream->stream) {
-	case SNDRV_PCM_STREAM_CAPTURE:
-		ret = gb_audio_gb_set_rx_data_size(gb->mgmt_connection,
-						   data_cport, 192);
-		if (ret) {
-			dev_err(dai->dev,
-				"%d:Error during set_rx_data_size, cport:%d\n",
-				ret, data_cport);
-			goto func_exit;
+		/* find the dai */
+		data = find_data(module, dai->name);
+		if (!data) {
+			dev_err(dai->dev, "%s:%s DATA connection missing\n",
+				dai->name, module->name);
+			mutex_unlock(&module->lock);
+			continue;
 		}
-		ret = gb_audio_apbridgea_set_rx_data_size(gb_dai->connection, 0,
-							  192);
-		if (ret) {
-			dev_err(dai->dev,
+		/* deactivate rx/tx */
+		data_cport = data->connection->intf_cport_id;
+
+		switch (substream->stream) {
+		case SNDRV_PCM_STREAM_CAPTURE:
+			ret = gb_audio_gb_set_rx_data_size(
+						module->mgmt_connection,
+						data_cport, 192);
+			if (ret) {
+				dev_err(dai->dev,
+					"%d:Error during set_rx_data_size, cport:%d\n",
+					ret, data_cport);
+				mutex_unlock(&module->lock);
+				goto func_exit;
+			}
+			if (state < GBAUDIO_CODEC_PREPARE) {
+				ret = gb_audio_apbridgea_set_rx_data_size(
+							data->connection, 0,
+							192);
+				if (ret) {
+					dev_err(dai->dev,
 				"%d:Error during apbridgea_set_rx_data_size\n",
 				ret);
-			goto func_exit;
-		}
-		ret = gb_audio_gb_activate_rx(gb->mgmt_connection, data_cport);
-		break;
-	case SNDRV_PCM_STREAM_PLAYBACK:
-		ret = gb_audio_gb_set_tx_data_size(gb->mgmt_connection,
-						   data_cport, 192);
-		if (ret) {
-			dev_err(dai->dev,
-				"%d:Error during module set_tx_data_size, cport:%d\n",
-				ret, data_cport);
-			goto func_exit;
-		}
-		ret = gb_audio_apbridgea_set_tx_data_size(gb_dai->connection, 0,
-							  192);
-		if (ret) {
-			dev_err(dai->dev,
-				"%d:Error during apbridgea set_tx_data_size, cport\n",
-				ret);
-			goto func_exit;
+					mutex_unlock(&module->lock);
+					goto func_exit;
+				}
+			}
+			ret = gb_audio_gb_activate_rx(module->mgmt_connection,
+						      data_cport);
+			if (ret)
+				dev_err(dai->dev,
+					"%s:Error during activate stream,%d\n",
+					module->name, ret);
+			break;
+		case SNDRV_PCM_STREAM_PLAYBACK:
+			ret = gb_audio_gb_set_tx_data_size(
+						module->mgmt_connection,
+						data_cport, 192);
+			if (ret) {
+				dev_err(dai->dev,
+					"%d:Error during module set_tx_data_size, cport:%d\n",
+					ret, data_cport);
+				mutex_unlock(&module->lock);
+				goto func_exit;
+			}
+			if (state < GBAUDIO_CODEC_PREPARE) {
+				ret = gb_audio_apbridgea_set_tx_data_size(
+							data->connection, 0,
+							192);
+				if (ret) {
+					dev_err(dai->dev,
+						"%d:Error during apbridgea set_tx_data_size, cport\n",
+						ret);
+					mutex_unlock(&module->lock);
+					goto func_exit;
+				}
+			}
+			ret = gb_audio_gb_activate_tx(module->mgmt_connection,
+						      data_cport);
+			if (ret)
+				dev_err(dai->dev,
+					"%s:Error during activate stream,%d\n",
+					module->name, ret);
+			break;
 		}
-		ret = gb_audio_gb_activate_tx(gb->mgmt_connection, data_cport);
-		break;
-	default:
-		dev_err(dai->dev, "Invalid stream type %d during prepare\n",
-			substream->stream);
-		ret = -EINVAL;
-		goto func_exit;
+		state = GBAUDIO_CODEC_PREPARE;
+		module->ctrlstate[substream->stream] = state;
+		dev_dbg(dai->dev, "%s: state:%d\n", module->name, state);
+		mutex_unlock(&module->lock);
 	}
-
-	if (ret)
-		dev_err(dai->dev, "%d: Error during activate stream\n", ret);
+	codec->stream[substream->stream].state = state;
 
 func_exit:
-	mutex_unlock(&gb->lock);
-	return ret;
+	mutex_unlock(&codec->lock);
+	return 0;
 }
 
 static int gbcodec_trigger(struct snd_pcm_substream *substream, int cmd,
@@ -297,24 +615,19 @@ static int gbcodec_trigger(struct snd_pcm_substream *substream, int cmd,
 {
 	int ret;
 	int tx, rx, start, stop;
-	struct gbaudio_dai *gb_dai;
-	struct gbaudio_codec_info *gb = dev_get_drvdata(dai->dev);
-
-	if (!atomic_read(&gb->is_connected)) {
+	struct gbaudio_data_connection *data;
+	struct gbaudio_module_info *module;
+	struct gbaudio_codec_info *codec = dev_get_drvdata(dai->dev);
+
+	mutex_lock(&codec->lock);
+	if (list_empty(&codec->module_list)) {
+		dev_err(codec->dev, "No codec module available\n");
+		mutex_unlock(&codec->lock);
 		if (cmd == SNDRV_PCM_TRIGGER_STOP)
 			return 0;
 		return -ENODEV;
 	}
 
-	/* find the dai */
-	mutex_lock(&gb->lock);
-	gb_dai = gbaudio_find_dai(gb, -1, dai->name);
-	if (!gb_dai) {
-		dev_err(dai->dev, "%s: DAI not registered\n", dai->name);
-		ret = -EINVAL;
-		goto func_exit;
-	}
-
 	tx = rx = start = stop = 0;
 	switch (cmd) {
 	case SNDRV_PCM_TRIGGER_START:
@@ -345,47 +658,60 @@ static int gbcodec_trigger(struct snd_pcm_substream *substream, int cmd,
 		goto func_exit;
 	}
 
+	list_for_each_entry(module, &codec->module_list, list) {
+		mutex_lock(&module->lock);
+		if (!module->is_connected) {
+			mutex_unlock(&module->lock);
+			continue;
+		}
+
+		/* find the dai */
+		data = find_data(module, dai->name);
+		if (data)
+			break;
+	}
+	if (!data) {
+		dev_err(dai->dev, "%s:%s DATA connection missing\n",
+			dai->name, module->name);
+		ret = -ENODEV;
+		mutex_unlock(&module->lock);
+		goto func_exit;
+	}
 	if (start && tx) {
-		ret = gb_audio_apbridgea_prepare_tx(gb_dai->connection, 0);
+		ret = gb_audio_apbridgea_prepare_tx(data->connection,
+						    0);
 		if (!ret)
-			ret = gb_audio_apbridgea_start_tx(gb_dai->connection, 0,
-							  0);
-	}
-
-	else if (start && rx) {
-		ret = gb_audio_apbridgea_prepare_rx(gb_dai->connection, 0);
+			ret = gb_audio_apbridgea_start_tx(data->connection,
+							  0, 0);
+		codec->stream[substream->stream].state = GBAUDIO_CODEC_START;
+	} else if (start && rx) {
+		ret = gb_audio_apbridgea_prepare_rx(data->connection,
+						    0);
 		if (!ret)
-			ret = gb_audio_apbridgea_start_rx(gb_dai->connection,
+			ret = gb_audio_apbridgea_start_rx(data->connection,
 							  0);
-	}
-
-	else if (stop && tx) {
-		ret = gb_audio_apbridgea_stop_tx(gb_dai->connection, 0);
+		codec->stream[substream->stream].state = GBAUDIO_CODEC_START;
+	} else if (stop && tx) {
+		ret = gb_audio_apbridgea_stop_tx(data->connection, 0);
 		if (!ret)
-			ret = gb_audio_apbridgea_shutdown_tx(gb_dai->connection,
+			ret = gb_audio_apbridgea_shutdown_tx(data->connection,
 							     0);
-	}
-
-	else if (stop && rx) {
-		ret = gb_audio_apbridgea_stop_rx(gb_dai->connection, 0);
+		codec->stream[substream->stream].state = GBAUDIO_CODEC_STOP;
+	} else if (stop && rx) {
+		ret = gb_audio_apbridgea_stop_rx(data->connection, 0);
 		if (!ret)
-			ret = gb_audio_apbridgea_shutdown_rx(gb_dai->connection,
+			ret = gb_audio_apbridgea_shutdown_rx(data->connection,
 							     0);
-	}
-
-	else
+		codec->stream[substream->stream].state = GBAUDIO_CODEC_STOP;
+	} else
 		ret = -EINVAL;
-
 	if (ret)
-		dev_err(dai->dev, "%d:Error during %s stream\n", ret,
-			start ? "Start" : "Stop");
-
-	/* in case device removed, return 0 for stop trigger */
-	if (stop && (ret == -ENODEV))
-		ret = 0;
+		dev_err(dai->dev, "%s:Error during %s stream:%d\n",
+			module->name, start ? "Start" : "Stop", ret);
+	mutex_unlock(&module->lock);
 
 func_exit:
-	mutex_unlock(&gb->lock);
+	mutex_unlock(&codec->lock);
 	return ret;
 }
 
@@ -409,476 +735,325 @@ static struct snd_soc_dai_ops gbcodec_dai_ops = {
 	.digital_mute = gbcodec_digital_mute,
 };
 
-/*
- * codec driver ops
- */
-static int gbcodec_probe(struct snd_soc_codec *codec)
+int gbaudio_register_module(struct gbaudio_module_info *module)
 {
-	/* Empty function for now */
-	return 0;
-}
+	int ret;
+	struct snd_soc_codec *codec;
 
-static int gbcodec_remove(struct snd_soc_codec *codec)
-{
-	/* Empty function for now */
-	return 0;
-}
+	if (!gbcodec) {
+		dev_err(module->dev, "GB Codec not yet probed\n");
+		return -EAGAIN;
+	}
 
-static int gbcodec_write(struct snd_soc_codec *codec, unsigned int reg,
-			 unsigned int value)
-{
-	int ret = 0;
-	struct gbaudio_codec_info *gbcodec = snd_soc_codec_get_drvdata(codec);
-	u8 *gbcodec_reg = gbcodec->reg;
+	codec = gbcodec->codec;
+	mutex_lock(&gbcodec->lock);
 
-	if (reg == SND_SOC_NOPM)
-		return 0;
+	if (module->num_dais) {
+		dev_err(gbcodec->dev,
+			"%d:DAIs not supported via gbcodec driver\n",
+			module->num_dais);
+		mutex_unlock(&gbcodec->lock);
+		return -EINVAL;
+	}
 
-	if (reg >= GBCODEC_REG_COUNT)
-		return 0;
+	if (module->dapm_widgets)
+		snd_soc_dapm_new_controls(&codec->dapm, module->dapm_widgets,
+					  module->num_dapm_widgets);
+	if (module->controls)
+		snd_soc_add_codec_controls(codec, module->controls,
+				     module->num_controls);
+	if (module->dapm_routes)
+		snd_soc_dapm_add_routes(&codec->dapm, module->dapm_routes,
+					module->num_dapm_routes);
+
+	/* card already instantiated, create widgets here only */
+	if (codec->card->instantiated) {
+		ret = snd_soc_dapm_new_widgets(&codec->dapm);
+		if (!ret)
+			snd_soc_dapm_link_dai_widgets_component(codec->card,
+								&codec->dapm);
+	}
 
-	gbcodec_reg[reg] = value;
-	dev_dbg(codec->dev, "reg[%d] = 0x%x\n", reg, value);
+	list_add(&module->list, &gbcodec->module_list);
+	dev_dbg(codec->dev, "Registered %s module\n", module->name);
 
-	return ret;
+	mutex_unlock(&gbcodec->lock);
+	return 0;
 }
+EXPORT_SYMBOL(gbaudio_register_module);
 
-static unsigned int gbcodec_read(struct snd_soc_codec *codec,
-				 unsigned int reg)
+void gbaudio_codec_cleanup(struct gbaudio_module_info *module)
 {
-	unsigned int val = 0;
-
-	struct gbaudio_codec_info *gbcodec = snd_soc_codec_get_drvdata(codec);
-	u8 *gbcodec_reg = gbcodec->reg;
-
-	if (reg == SND_SOC_NOPM)
-		return 0;
-
-	if (reg >= GBCODEC_REG_COUNT)
-		return 0;
-
-	val = gbcodec_reg[reg];
-	dev_dbg(codec->dev, "reg[%d] = 0x%x\n", reg, val);
-
-	return val;
-}
+	struct gbaudio_data_connection *data;
+	int pb_state = gbcodec->stream[0].state;
+	int cap_state = gbcodec->stream[1].state;
+	int ret;
+	uint16_t i2s_port, cportid;
 
-/*
- * gb_snd management functions
- */
+	/* locks already acquired */
+	if (!pb_state && !cap_state)
+		return;
 
-/* XXX
- * since BE DAI path is not yet properly closed from above layer,
- * dsp dai.mi2s_dai_data.status_mask is still set to STATUS_PORT_STARTED
- * this causes immediate playback/capture to fail in case relevant mixer
- * control is not turned OFF
- * user need to try once again after failure to recover DSP state.
- */
-static void gb_audio_cleanup(struct gbaudio_codec_info *gb)
-{
-	int cportid, ret, timeout_result;
-	struct gbaudio_dai *gb_dai;
-	struct gb_connection *connection;
-	long timeout = msecs_to_jiffies(50);	/* 50ms */
-	struct device *dev = gb->dev;
-
-	list_for_each_entry(gb_dai, &gb->dai_list, list) {
-		/*
-		 * In case of BE dailink, need to deactivate APBridge
-		 * manually
-		 */
-		if (atomic_read(&gb_dai->users)) {
-			/* schedule a wait event */
-			timeout_result =
-				wait_event_interruptible_timeout(
-						gb_dai->wait_queue,
-						!atomic_read(&gb_dai->users),
-						timeout);
-			if (!timeout_result)
-				dev_warn(dev, "%s:DAI still in use.\n",
-					 gb_dai->name);
-
-			connection = gb_dai->connection;
-			/* PB active */
-			ret = gb_audio_apbridgea_stop_tx(connection, 0);
-			if (ret)
-				dev_info(dev, "%d:Failed during APBridge stop_tx\n",
-					 ret);
-			ret = gb_audio_apbridgea_shutdown_tx(connection, 0);
-			if (ret)
-				dev_info(dev, "%d:Failed during APBridge shutdown_tx\n",
-					 ret);
-			cportid = connection->intf_cport_id;
-			ret = gb_audio_gb_deactivate_tx(gb->mgmt_connection,
-							cportid);
-			if (ret)
-				dev_info(dev,
-					 "%d:Failed during deactivate_tx\n",
-					 ret);
-			cportid = connection->hd_cport_id;
-			ret = gb_audio_apbridgea_unregister_cport(connection, 0,
-						cportid,
+	if (pb_state == GBAUDIO_CODEC_START) {
+		/* cleanup PB path, only APBridge specific */
+		data = find_data(module, gbcodec->stream[0].dai_name);
+		if (!data) {
+			dev_err(gbcodec->dev, "%s: Missing data pointer\n",
+				__func__);
+			return;
+		}
+		ret = gb_audio_apbridgea_stop_tx(data->connection, 0);
+		if (ret)
+			return;
+		ret = gb_audio_apbridgea_shutdown_tx(data->connection, 0);
+		if (ret)
+			return;
+		i2s_port = 0;	/* fixed for now */
+		cportid = data->connection->hd_cport_id;
+		ret = gb_audio_apbridgea_unregister_cport(data->connection,
+						i2s_port, cportid,
 						AUDIO_APBRIDGEA_DIRECTION_TX);
-			if (ret)
-				dev_info(dev, "%d:Failed during unregister cport\n",
-					 ret);
+		gbcodec->stream[0].state = GBAUDIO_CODEC_SHUTDOWN;
+	}
+
+	if (cap_state == GBAUDIO_CODEC_START) {
+		/* cleanup CAP path, only APBridge specific */
+		data = find_data(module, gbcodec->stream[1].dai_name);
+		if (!data) {
+			dev_err(gbcodec->dev, "%s: Missing data pointer\n",
+				__func__);
+			return;
 		}
+		ret = gb_audio_apbridgea_stop_rx(data->connection, 0);
+		if (ret)
+			return;
+		ret = gb_audio_apbridgea_shutdown_rx(data->connection, 0);
+		if (ret)
+			return;
+		i2s_port = 0;	/* fixed for now */
+		cportid = data->connection->hd_cport_id;
+		ret = gb_audio_apbridgea_unregister_cport(data->connection,
+						i2s_port, cportid,
+						AUDIO_APBRIDGEA_DIRECTION_RX);
+		gbcodec->stream[1].state = GBAUDIO_CODEC_SHUTDOWN;
 	}
 }
 
-static int gbaudio_register_codec(struct gbaudio_codec_info *gbcodec)
+void gbaudio_unregister_module(struct gbaudio_module_info *module)
 {
-	int ret, i;
-	struct device *dev = gbcodec->dev;
-	struct gb_connection *connection = gbcodec->mgmt_connection;
-	struct snd_soc_codec_driver *soc_codec_dev_gbcodec;
-	/*
-	 * FIXME: malloc for topology happens via audio_gb driver
-	 * should be done within codec driver itself
-	 */
-	struct gb_audio_topology *topology;
+	struct snd_soc_codec *codec = gbcodec->codec;
+	struct snd_card *card = codec->card->snd_card;
 
-	soc_codec_dev_gbcodec = devm_kzalloc(gbcodec->dev,
-					     sizeof(*soc_codec_dev_gbcodec),
-					     GFP_KERNEL);
-	if (!soc_codec_dev_gbcodec) {
-		dev_err(gbcodec->dev, "Malloc failed for codec_driver\n");
-		return -ENOMEM;
-	}
+	dev_dbg(codec->dev, "Unregister %s module\n", module->name);
 
-	ret = gb_connection_enable(connection);
-	if (ret) {
-		dev_err(dev, "%d: Error while enabling mgmt connection\n", ret);
-		return ret;
-	}
+	/* complete widget processing, if ongoing */
+	snd_soc_dapm_sync(&codec->dapm);
 
-	gbcodec->dev_id = connection->intf->interface_id;
-	/* fetch topology data */
-	ret = gb_audio_gb_get_topology(connection, &topology);
-	if (ret) {
-		dev_err(dev, "%d:Error while fetching topology\n", ret);
-		goto tplg_fetch_err;
-	}
+	down_write(&card->controls_rwsem);
+	mutex_lock(&gbcodec->lock);
+	dev_dbg(codec->dev, "Process Unregister %s module\n", module->name);
+	mutex_lock(&module->lock);
 
-	/* process topology data */
-	ret = gbaudio_tplg_parse_data(gbcodec, topology);
-	if (ret) {
-		dev_err(dev, "%d:Error while parsing topology data\n",
-			  ret);
-		goto tplg_parse_err;
+	if (list_is_last(&module->list, &gbcodec->module_list)) {
+		dev_dbg(codec->dev, "Last module removed, cleanup APBridge\n");
+		gbaudio_codec_cleanup(module);
 	}
-	gbcodec->topology = topology;
-
-	/* update codec info */
-	soc_codec_dev_gbcodec->probe = gbcodec_probe,
-	soc_codec_dev_gbcodec->remove = gbcodec_remove,
-
-	soc_codec_dev_gbcodec->read = gbcodec_read,
-	soc_codec_dev_gbcodec->write = gbcodec_write,
-
-	soc_codec_dev_gbcodec->reg_cache_size = GBCODEC_REG_COUNT,
-	soc_codec_dev_gbcodec->reg_cache_default = gbcodec_reg_defaults,
-	soc_codec_dev_gbcodec->reg_word_size = 1,
 
-	soc_codec_dev_gbcodec->idle_bias_off = true,
-	soc_codec_dev_gbcodec->ignore_pmdown_time = 1,
-
-	soc_codec_dev_gbcodec->controls = gbcodec->kctls;
-	soc_codec_dev_gbcodec->num_controls = gbcodec->num_kcontrols;
-	soc_codec_dev_gbcodec->dapm_widgets = gbcodec->widgets;
-	soc_codec_dev_gbcodec->num_dapm_widgets = gbcodec->num_dapm_widgets;
-	soc_codec_dev_gbcodec->dapm_routes = gbcodec->routes;
-	soc_codec_dev_gbcodec->num_dapm_routes = gbcodec->num_dapm_routes;
-
-	/* update DAI info */
-	for (i = 0; i < gbcodec->num_dais; i++)
-		gbcodec->dais[i].ops = &gbcodec_dai_ops;
-
-	/* register codec */
-	ret = snd_soc_register_codec(dev, soc_codec_dev_gbcodec,
-				     gbcodec->dais, 1);
-	if (ret) {
-		dev_err(dev, "%d:Failed to register codec\n", ret);
-		goto codec_reg_err;
+	module->is_connected = 0;
+	if (module->dapm_routes) {
+		dev_dbg(codec->dev, "Removing %d routes\n",
+			module->num_dapm_routes);
+		snd_soc_dapm_del_routes(&codec->dapm, module->dapm_routes,
+					module->num_dapm_routes);
 	}
-
-	/* update DAI links in response to this codec */
-	ret = msm8994_add_dailink("msm8994-tomtom-mtp-snd-card", gbcodec->name,
-				  gbcodec->dais[0].name, 1);
-	if (ret) {
-		dev_err(dev, "%d: Failed to add DAI links\n", ret);
-		goto add_dailink_err;
+	if (module->controls) {
+		dev_dbg(codec->dev, "Removing %d controls\n",
+			module->num_controls);
+		soc_remove_codec_controls(codec, module->controls,
+					  module->num_controls);
+	}
+	if (module->dapm_widgets) {
+		dev_dbg(codec->dev, "Removing %d widgets\n",
+			module->num_dapm_widgets);
+		snd_soc_dapm_free_controls(&codec->dapm, module->dapm_widgets,
+					   module->num_dapm_widgets);
 	}
-	gbcodec->num_dai_links = 1;
 
-	return 0;
+	mutex_unlock(&module->lock);
 
-add_dailink_err:
-	snd_soc_unregister_codec(dev);
-codec_reg_err:
-	gbaudio_tplg_release(gbcodec);
-	gbcodec->topology = NULL;
-tplg_parse_err:
-	kfree(topology);
-tplg_fetch_err:
-	gb_connection_disable(gbcodec->mgmt_connection);
-	return ret;
-}
+	list_del(&module->list);
+	dev_dbg(codec->dev, "Unregistered %s module\n", module->name);
 
-static void gbaudio_unregister_codec(struct gbaudio_codec_info *gbcodec)
-{
-	gb_audio_cleanup(gbcodec);
-	msm8994_remove_dailink("msm8994-tomtom-mtp-snd-card", gbcodec->name,
-			       gbcodec->dais[0].name, 1);
-	snd_soc_unregister_codec(gbcodec->dev);
-	gbaudio_tplg_release(gbcodec);
-	kfree(gbcodec->topology);
-	gb_connection_disable(gbcodec->mgmt_connection);
+	mutex_unlock(&gbcodec->lock);
+	up_write(&card->controls_rwsem);
 }
+EXPORT_SYMBOL(gbaudio_unregister_module);
 
-static int gbaudio_codec_request_handler(struct gb_operation *op)
+/*
+ * codec driver ops
+ */
+static int gbcodec_probe(struct snd_soc_codec *codec)
 {
-	struct gb_connection *connection = op->connection;
-	struct gb_audio_streaming_event_request *req = op->request->payload;
+	struct gbaudio_codec_info *info;
+
+	info = devm_kzalloc(codec->dev, sizeof(*info), GFP_KERNEL);
+	if (!info)
+		return -ENOMEM;
 
-	dev_warn(&connection->bundle->dev,
-		 "Audio Event received: cport: %u, event: %u\n",
-		 req->data_cport, req->event);
+	info->dev = codec->dev;
+	INIT_LIST_HEAD(&info->module_list);
+	mutex_init(&info->lock);
+	info->codec = codec;
+	snd_soc_codec_set_drvdata(codec, info);
+	gbcodec = info;
 
+	/* Empty function for now */
 	return 0;
 }
 
-static int gbaudio_dai_request_handler(struct gb_operation *op)
+static int gbcodec_remove(struct snd_soc_codec *codec)
 {
-	struct gb_connection *connection = op->connection;
-
-	dev_warn(&connection->bundle->dev, "Audio Event received\n");
-
+	/* Empty function for now */
 	return 0;
 }
 
-static int gb_audio_add_mgmt_connection(struct gbaudio_codec_info *gbcodec,
-				struct greybus_descriptor_cport *cport_desc,
-				struct gb_bundle *bundle)
+static u8 gbcodec_reg[GBCODEC_REG_COUNT] = {
+	[GBCODEC_CTL_REG] = GBCODEC_CTL_REG_DEFAULT,
+	[GBCODEC_MUTE_REG] = GBCODEC_MUTE_REG_DEFAULT,
+	[GBCODEC_PB_LVOL_REG] = GBCODEC_PB_VOL_REG_DEFAULT,
+	[GBCODEC_PB_RVOL_REG] = GBCODEC_PB_VOL_REG_DEFAULT,
+	[GBCODEC_CAP_LVOL_REG] = GBCODEC_CAP_VOL_REG_DEFAULT,
+	[GBCODEC_CAP_RVOL_REG] = GBCODEC_CAP_VOL_REG_DEFAULT,
+	[GBCODEC_APB1_MUX_REG] = GBCODEC_APB1_MUX_REG_DEFAULT,
+	[GBCODEC_APB2_MUX_REG] = GBCODEC_APB2_MUX_REG_DEFAULT,
+};
+
+static int gbcodec_write(struct snd_soc_codec *codec, unsigned int reg,
+			 unsigned int value)
 {
-	struct gb_connection *connection;
+	int ret = 0;
 
-	/* Management Cport */
-	if (gbcodec->mgmt_connection) {
-		dev_err(&bundle->dev,
-			"Can't have multiple Management connections\n");
-		return -ENODEV;
-	}
+	if (reg == SND_SOC_NOPM)
+		return 0;
 
-	connection = gb_connection_create(bundle, le16_to_cpu(cport_desc->id),
-					  gbaudio_codec_request_handler);
-	if (IS_ERR(connection))
-		return PTR_ERR(connection);
+	BUG_ON(reg >= GBCODEC_REG_COUNT);
+		return 0;
 
-	gb_connection_set_data(connection, gbcodec);
-	gbcodec->mgmt_connection = connection;
+	gbcodec_reg[reg] = value;
+	dev_dbg(codec->dev, "reg[%d] = 0x%x\n", reg, value);
 
-	return 0;
+	return ret;
 }
 
-static int gb_audio_add_data_connection(struct gbaudio_codec_info *gbcodec,
-				struct greybus_descriptor_cport *cport_desc,
-				struct gb_bundle *bundle)
+static unsigned int gbcodec_read(struct snd_soc_codec *codec,
+				 unsigned int reg)
 {
-	struct gb_connection *connection;
-	struct gbaudio_dai *dai;
+	unsigned int val = 0;
 
-	dai = devm_kzalloc(gbcodec->dev, sizeof(*dai), GFP_KERNEL);
-	if (!dai) {
-		dev_err(gbcodec->dev, "DAI Malloc failure\n");
-		return -ENOMEM;
-	}
+	if (reg == SND_SOC_NOPM)
+		return 0;
 
-	connection = gb_connection_create_flags(bundle,
-						le16_to_cpu(cport_desc->id),
-						gbaudio_dai_request_handler,
-						GB_CONNECTION_FLAG_CSD);
-	if (IS_ERR(connection)) {
-		devm_kfree(gbcodec->dev, dai);
-		return PTR_ERR(connection);
-	}
+	BUG_ON(reg >= GBCODEC_REG_COUNT);
 
-	gb_connection_set_data(connection, gbcodec);
-	atomic_set(&dai->users, 0);
-	init_waitqueue_head(&dai->wait_queue);
-	dai->data_cport = connection->intf_cport_id;
-	dai->connection = connection;
-	list_add(&dai->list, &gbcodec->dai_list);
+	val = gbcodec_reg[reg];
+	dev_dbg(codec->dev, "reg[%d] = 0x%x\n", reg, val);
 
-	return 0;
+	return val;
 }
-/*
- * This is the basic hook get things initialized and registered w/ gb
- */
 
-static int gb_audio_probe(struct gb_bundle *bundle,
-			  const struct greybus_bundle_id *id)
-{
-	struct device *dev = &bundle->dev;
-	struct gbaudio_codec_info *gbcodec;
-	struct greybus_descriptor_cport *cport_desc;
-	struct gb_audio_manager_module_descriptor desc;
-	struct gbaudio_dai *dai, *_dai;
-	int ret, i;
-
-	/* There should be at least one Management and one Data cport */
-	if (bundle->num_cports < 2)
-		return -ENODEV;
+static struct snd_soc_dai_driver gbaudio_dai[] = {
+	{
+		.name = "greybus-apb1",
+		.id = 0,
+		.playback = {
+			.stream_name = "GB Audio Playback",
+			.rates = SNDRV_PCM_RATE_48000,
+			.formats = SNDRV_PCM_FORMAT_S16_LE,
+			.rate_max = 48000,
+			.rate_min = 48000,
+			.channels_min = 1,
+			.channels_max = 2,
+		},
+		.capture = {
+			.stream_name = "GB Audio Capture",
+			.rates = SNDRV_PCM_RATE_48000,
+			.formats = SNDRV_PCM_FORMAT_S16_LE,
+			.rate_max = 48000,
+			.rate_min = 48000,
+			.channels_min = 1,
+			.channels_max = 2,
+		},
+		.ops = &gbcodec_dai_ops,
+	},
+};
 
-	mutex_lock(&gb_codec_list_lock);
-	/*
-	 * There can be only one Management connection and any number of data
-	 * connections.
-	 */
-	gbcodec = devm_kzalloc(dev, sizeof(*gbcodec), GFP_KERNEL);
-	if (!gbcodec) {
-		mutex_unlock(&gb_codec_list_lock);
-		return -ENOMEM;
-	}
+static struct snd_soc_codec_driver soc_codec_dev_gbaudio = {
+	.probe	= gbcodec_probe,
+	.remove	= gbcodec_remove,
 
-	gbcodec->num_data_connections = bundle->num_cports - 1;
-	mutex_init(&gbcodec->lock);
-	INIT_LIST_HEAD(&gbcodec->dai_list);
-	INIT_LIST_HEAD(&gbcodec->widget_list);
-	INIT_LIST_HEAD(&gbcodec->codec_ctl_list);
-	INIT_LIST_HEAD(&gbcodec->widget_ctl_list);
-	gbcodec->dev = dev;
-	snprintf(gbcodec->name, NAME_SIZE, "%s.%s", dev->driver->name,
-		 dev_name(dev));
-	greybus_set_drvdata(bundle, gbcodec);
-
-	/* Create all connections */
-	for (i = 0; i < bundle->num_cports; i++) {
-		cport_desc = &bundle->cport_desc[i];
-
-		switch (cport_desc->protocol_id) {
-		case GREYBUS_PROTOCOL_AUDIO_MGMT:
-			ret = gb_audio_add_mgmt_connection(gbcodec, cport_desc,
-							   bundle);
-			if (ret)
-				goto destroy_connections;
-			break;
-		case GREYBUS_PROTOCOL_AUDIO_DATA:
-			ret = gb_audio_add_data_connection(gbcodec, cport_desc,
-							   bundle);
-			if (ret)
-				goto destroy_connections;
-			break;
-		default:
-			dev_err(dev, "Unsupported protocol: 0x%02x\n",
-				cport_desc->protocol_id);
-			ret = -ENODEV;
-			goto destroy_connections;
-		}
-	}
+	.read = gbcodec_read,
+	.write = gbcodec_write,
 
-	/* There must be a management cport */
-	if (!gbcodec->mgmt_connection) {
-		ret = -EINVAL;
-		dev_err(dev, "Missing management connection\n");
-		goto destroy_connections;
-	}
+	.reg_cache_size = GBCODEC_REG_COUNT,
+	.reg_cache_default = gbcodec_reg_defaults,
+	.reg_word_size = 1,
 
-	/* Initialize management connection */
-	ret = gbaudio_register_codec(gbcodec);
-	if (ret)
-		goto destroy_connections;
-
-	/* Initialize data connections */
-	list_for_each_entry(dai, &gbcodec->dai_list, list) {
-		ret = gb_connection_enable(dai->connection);
-		if (ret)
-			goto remove_dai;
-	}
-
-	/* inform above layer for uevent */
-	dev_dbg(dev, "Inform set_event:%d to above layer\n", 1);
-	/* prepare for the audio manager */
-	strlcpy(desc.name, gbcodec->name, GB_AUDIO_MANAGER_MODULE_NAME_LEN);
-	desc.slot = 1; /* todo */
-	desc.vid = 2; /* todo */
-	desc.pid = 3; /* todo */
-	desc.cport = gbcodec->dev_id;
-	desc.devices = 0x2; /* todo */
-	gbcodec->manager_id = gb_audio_manager_add(&desc);
+	.idle_bias_off = true,
+	.ignore_pmdown_time = 1,
+};
 
-	atomic_set(&gbcodec->is_connected, 1);
-	list_add_tail(&gbcodec->list, &gb_codec_list);
-	dev_dbg(dev, "Add GB Audio device:%s\n", gbcodec->name);
-	mutex_unlock(&gb_codec_list_lock);
 
+#ifdef CONFIG_PM
+static int gbaudio_codec_suspend(struct device *dev)
+{
+	dev_dbg(dev, "%s: suspend\n", __func__);
 	return 0;
-
-remove_dai:
-	list_for_each_entry_safe(dai, _dai, &gbcodec->dai_list, list)
-		gb_connection_disable(dai->connection);
-
-	gbaudio_unregister_codec(gbcodec);
-destroy_connections:
-	list_for_each_entry_safe(dai, _dai, &gbcodec->dai_list, list) {
-		gb_connection_destroy(dai->connection);
-		list_del(&dai->list);
-		devm_kfree(dev, dai);
-	}
-
-	if (gbcodec->mgmt_connection)
-		gb_connection_destroy(gbcodec->mgmt_connection);
-
-	devm_kfree(dev, gbcodec);
-	mutex_unlock(&gb_codec_list_lock);
-
-	return ret;
 }
 
-static void gb_audio_disconnect(struct gb_bundle *bundle)
+static int gbaudio_codec_resume(struct device *dev)
 {
-	struct gbaudio_codec_info *gbcodec = greybus_get_drvdata(bundle);
-	struct gbaudio_dai *dai, *_dai;
+	dev_dbg(dev, "%s: resume\n", __func__);
+	return 0;
+}
 
-	mutex_lock(&gb_codec_list_lock);
-	atomic_set(&gbcodec->is_connected, 0);
-	/* inform uevent to above layers */
-	gb_audio_manager_remove(gbcodec->manager_id);
+static const struct dev_pm_ops gbaudio_codec_pm_ops = {
+	.suspend	= gbaudio_codec_suspend,
+	.resume		= gbaudio_codec_resume,
+};
+#endif
 
-	mutex_lock(&gbcodec->lock);
-	list_for_each_entry_safe(dai, _dai, &gbcodec->dai_list, list)
-		gb_connection_disable(dai->connection);
-	gbaudio_unregister_codec(gbcodec);
-
-	list_for_each_entry_safe(dai, _dai, &gbcodec->dai_list, list) {
-		gb_connection_destroy(dai->connection);
-		list_del(&dai->list);
-		devm_kfree(gbcodec->dev, dai);
-	}
-	gb_connection_destroy(gbcodec->mgmt_connection);
-	gbcodec->mgmt_connection = NULL;
-	list_del(&gbcodec->list);
-	mutex_unlock(&gbcodec->lock);
+static int gbaudio_codec_probe(struct platform_device *pdev)
+{
+	return snd_soc_register_codec(&pdev->dev, &soc_codec_dev_gbaudio,
+			gbaudio_dai, ARRAY_SIZE(gbaudio_dai));
+}
 
-	devm_kfree(&bundle->dev, gbcodec);
-	mutex_unlock(&gb_codec_list_lock);
+static int gbaudio_codec_remove(struct platform_device *pdev)
+{
+	snd_soc_unregister_codec(&pdev->dev);
+	return 0;
 }
 
-static const struct greybus_bundle_id gb_audio_id_table[] = {
-	{ GREYBUS_DEVICE_CLASS(GREYBUS_CLASS_AUDIO) },
-	{ }
+static const struct of_device_id greybus_asoc_machine_of_match[]  = {
+	{ .compatible = "qcom,ara-codec", },
+	{},
 };
-MODULE_DEVICE_TABLE(greybus, gb_audio_id_table);
 
-static struct greybus_driver gb_audio_driver = {
-	.name		= "gb-audio",
-	.probe		= gb_audio_probe,
-	.disconnect	= gb_audio_disconnect,
-	.id_table	= gb_audio_id_table,
+static struct platform_driver gbaudio_codec_driver = {
+	.driver = {
+		.name = "gb-codec",
+		.owner = THIS_MODULE,
+#ifdef CONFIG_PM
+		.pm = &gbaudio_codec_pm_ops,
+#endif
+		.of_match_table = greybus_asoc_machine_of_match,
+	},
+	.probe = gbaudio_codec_probe,
+	.remove = gbaudio_codec_remove,
 };
-module_greybus_driver(gb_audio_driver);
+module_platform_driver(gbaudio_codec_driver);
 
-MODULE_DESCRIPTION("Greybus Audio codec driver");
+MODULE_DESCRIPTION("Greybus codec driver");
 MODULE_AUTHOR("Vaibhav Agarwal <vaibhav.agarwal@linaro.org>");
 MODULE_LICENSE("GPL v2");
 MODULE_ALIAS("platform:gbaudio-codec");

commit 0ec306324423444d3ee0222708ef9de7f5586b93
Author: Greg Kroah-Hartman <gregkh@google.com>
Date:   Tue Mar 22 14:30:35 2016 -0400

    greybus: convert drivers to use connection->private set/get
    
    This converts all drivers to use the gb_connection_get_data() and
    gb_connection_set_data() functions to make it a bit more explicit as to
    what is going on.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>
    Reviewed-by: Alex Elder <elder@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/audio_codec.c b/drivers/staging/greybus/audio_codec.c
index 025dd53507b7..30b381ab8a1f 100644
--- a/drivers/staging/greybus/audio_codec.c
+++ b/drivers/staging/greybus/audio_codec.c
@@ -675,7 +675,7 @@ static int gb_audio_add_mgmt_connection(struct gbaudio_codec_info *gbcodec,
 	if (IS_ERR(connection))
 		return PTR_ERR(connection);
 
-	connection->private = gbcodec;
+	gb_connection_set_data(connection, gbcodec);
 	gbcodec->mgmt_connection = connection;
 
 	return 0;
@@ -703,7 +703,7 @@ static int gb_audio_add_data_connection(struct gbaudio_codec_info *gbcodec,
 		return PTR_ERR(connection);
 	}
 
-	connection->private = gbcodec;
+	gb_connection_set_data(connection, gbcodec);
 	atomic_set(&dai->users, 0);
 	init_waitqueue_head(&dai->wait_queue);
 	dai->data_cport = connection->intf_cport_id;

commit 309520ec93f7190c0c3d22d613825a0835a8600f
Author: Mark Greer <mgreer@animalcreek.com>
Date:   Thu Mar 17 10:32:37 2016 -0700

    greybus: audio: Use CSD instead of E2EFC for audio data connections
    
    There is no reason to use end-to-end flow control for Greybus
    audio data connections so disable it and enable Controlled
    Segment Dropping (CSD).
    
    Testing Done: Played music using audio modules on an EVT1.5.
    
    CC: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
    CC: Johan Hovold <johan@hovoldconsulting.com>
    Signed-off-by: Mark Greer <mgreer@animalcreek.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/audio_codec.c b/drivers/staging/greybus/audio_codec.c
index d7cae772dbf5..025dd53507b7 100644
--- a/drivers/staging/greybus/audio_codec.c
+++ b/drivers/staging/greybus/audio_codec.c
@@ -694,8 +694,10 @@ static int gb_audio_add_data_connection(struct gbaudio_codec_info *gbcodec,
 		return -ENOMEM;
 	}
 
-	connection = gb_connection_create(bundle, le16_to_cpu(cport_desc->id),
-					  gbaudio_dai_request_handler);
+	connection = gb_connection_create_flags(bundle,
+						le16_to_cpu(cport_desc->id),
+						gbaudio_dai_request_handler,
+						GB_CONNECTION_FLAG_CSD);
 	if (IS_ERR(connection)) {
 		devm_kfree(gbcodec->dev, dai);
 		return PTR_ERR(connection);

commit 5bbe14b7acc2a00f51b23812ffc596577d94e80b
Author: Mark Greer <mgreer@animalcreek.com>
Date:   Mon Feb 29 15:31:02 2016 -0700

    greybus: audio: Split start and stop APBridgeA requests
    
    Provide finer-grained control of the audio streaming on APB1 by
    splitting the transmit/receive start and stop requests into prepare,
    start, stop, and shutdown.
    
    CC: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
    Signed-off-by: Mark Greer <mgreer@animalcreek.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/audio_codec.c b/drivers/staging/greybus/audio_codec.c
index 5e29694139f7..d7cae772dbf5 100644
--- a/drivers/staging/greybus/audio_codec.c
+++ b/drivers/staging/greybus/audio_codec.c
@@ -345,17 +345,33 @@ static int gbcodec_trigger(struct snd_pcm_substream *substream, int cmd,
 		goto func_exit;
 	}
 
-	if (start && tx)
-		ret = gb_audio_apbridgea_start_tx(gb_dai->connection, 0, 0);
+	if (start && tx) {
+		ret = gb_audio_apbridgea_prepare_tx(gb_dai->connection, 0);
+		if (!ret)
+			ret = gb_audio_apbridgea_start_tx(gb_dai->connection, 0,
+							  0);
+	}
 
-	else if (start && rx)
-		ret = gb_audio_apbridgea_start_rx(gb_dai->connection, 0);
+	else if (start && rx) {
+		ret = gb_audio_apbridgea_prepare_rx(gb_dai->connection, 0);
+		if (!ret)
+			ret = gb_audio_apbridgea_start_rx(gb_dai->connection,
+							  0);
+	}
 
-	else if (stop && tx)
+	else if (stop && tx) {
 		ret = gb_audio_apbridgea_stop_tx(gb_dai->connection, 0);
+		if (!ret)
+			ret = gb_audio_apbridgea_shutdown_tx(gb_dai->connection,
+							     0);
+	}
 
-	else if (stop && rx)
+	else if (stop && rx) {
 		ret = gb_audio_apbridgea_stop_rx(gb_dai->connection, 0);
+		if (!ret)
+			ret = gb_audio_apbridgea_shutdown_rx(gb_dai->connection,
+							     0);
+	}
 
 	else
 		ret = -EINVAL;
@@ -488,6 +504,10 @@ static void gb_audio_cleanup(struct gbaudio_codec_info *gb)
 			if (ret)
 				dev_info(dev, "%d:Failed during APBridge stop_tx\n",
 					 ret);
+			ret = gb_audio_apbridgea_shutdown_tx(connection, 0);
+			if (ret)
+				dev_info(dev, "%d:Failed during APBridge shutdown_tx\n",
+					 ret);
 			cportid = connection->intf_cport_id;
 			ret = gb_audio_gb_deactivate_tx(gb->mgmt_connection,
 							cportid);

commit 4a8e519902e73c833fb57f69bc194c2274dcdc30
Author: Mark Greer <mgreer@animalcreek.com>
Date:   Fri Feb 26 17:04:36 2016 -0700

    greybus: audio: Register CPorts for specific directions
    
    Currently, it is assumed that all audio data CPorts registered on
    APB1 are used for transmitting audio data.  That may not always be
    true like when a microphone is connected but no speakers.  Also,
    the current special protocol lacks a way to tell APB1 whether the CPort
    being registered is for transmitting, receiving, or both.
    
    Fix by adding a 'direction' field to the register and unregister CPort
    requests and define bits indicating which direction (or both) audio
    data will go on that CPort.
    
    Signed-off-by: Mark Greer <mgreer@animalcreek.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/audio_codec.c b/drivers/staging/greybus/audio_codec.c
index d820116dd196..5e29694139f7 100644
--- a/drivers/staging/greybus/audio_codec.c
+++ b/drivers/staging/greybus/audio_codec.c
@@ -60,7 +60,8 @@ static int gbcodec_startup(struct snd_pcm_substream *substream,
 	i2s_port = 0;	/* fixed for now */
 	cportid = gb_dai->connection->hd_cport_id;
 	ret = gb_audio_apbridgea_register_cport(gb_dai->connection, i2s_port,
-						cportid);
+						cportid,
+						AUDIO_APBRIDGEA_DIRECTION_TX);
 	dev_dbg(dai->dev, "Register %s:%d DAI, ret:%d\n", dai->name, cportid,
 		ret);
 
@@ -117,7 +118,8 @@ static void gbcodec_shutdown(struct snd_pcm_substream *substream,
 	/* un register cport */
 	i2s_port = 0;	/* fixed for now */
 	ret = gb_audio_apbridgea_unregister_cport(gb_dai->connection, i2s_port,
-					gb_dai->connection->hd_cport_id);
+					gb_dai->connection->hd_cport_id,
+					AUDIO_APBRIDGEA_DIRECTION_TX);
 
 	dev_dbg(dai->dev, "Unregister %s:%d DAI, ret:%d\n", dai->name,
 		gb_dai->connection->hd_cport_id, ret);
@@ -495,7 +497,8 @@ static void gb_audio_cleanup(struct gbaudio_codec_info *gb)
 					 ret);
 			cportid = connection->hd_cport_id;
 			ret = gb_audio_apbridgea_unregister_cport(connection, 0,
-								  cportid);
+						cportid,
+						AUDIO_APBRIDGEA_DIRECTION_TX);
 			if (ret)
 				dev_info(dev, "%d:Failed during unregister cport\n",
 					 ret);

commit b07868bda2fb61b784dc260dd075d84ac994d599
Author: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
Date:   Tue Feb 16 22:16:33 2016 +0530

    greybus: audio: return success for stop trigger if device removed
    
    In case GB codec module is already removed, no action is required
    at the HW level. Thus, report SUCCESS to above layer.
    
    Reporting error to above layer will cause repeated trials and won't
    allow to update DPCM connections.
    
    Signed-off-by: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
    Reviewed-by: Mark Greer <mgreer@animalcreek.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/audio_codec.c b/drivers/staging/greybus/audio_codec.c
index 25b1042d3c77..d820116dd196 100644
--- a/drivers/staging/greybus/audio_codec.c
+++ b/drivers/staging/greybus/audio_codec.c
@@ -362,6 +362,10 @@ static int gbcodec_trigger(struct snd_pcm_substream *substream, int cmd,
 		dev_err(dai->dev, "%d:Error during %s stream\n", ret,
 			start ? "Start" : "Stop");
 
+	/* in case device removed, return 0 for stop trigger */
+	if (stop && (ret == -ENODEV))
+		ret = 0;
+
 func_exit:
 	mutex_unlock(&gb->lock);
 	return ret;

commit 29386f058a758f5ef6e8a522101fcbfd0ef07a19
Author: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
Date:   Tue Feb 16 00:27:28 2016 +0530

    greybus: audio: schedule workqueue to perform codec cleanup on module removal
    
    In response to codec module removal, user space is reported about
    the event. In response to this, ALSA layer will update DAPM route
    and cleanup DAPM states.
    As a fallback mechanism, kernel can cleanup the DAPM state for codec
    module. But, this would cause immediate playback (first trial) to fail,
    since DSP is still in inconsistent state.
    To avoid such situation, a workqueue is scheduled for codec cleanup
    with timeout=50ms.
    Thus, normally it is expected from above layers to update routes and
    perform cleanup. However, fallback mechanism still holds good after
    50ms.
    
    Signed-off-by: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
    Reviewed-by: Mark Greer <mgreer@animalcreek.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/audio_codec.c b/drivers/staging/greybus/audio_codec.c
index cabe289b9324..25b1042d3c77 100644
--- a/drivers/staging/greybus/audio_codec.c
+++ b/drivers/staging/greybus/audio_codec.c
@@ -80,11 +80,7 @@ static void gbcodec_shutdown(struct snd_pcm_substream *substream,
 	struct gbaudio_dai *gb_dai;
 	struct gbaudio_codec_info *gb = dev_get_drvdata(dai->dev);
 
-	if (!atomic_read(&gb->is_connected))
-		return;
-
 	/* find the dai */
-	mutex_lock(&gb->lock);
 	gb_dai = gbaudio_find_dai(gb, -1, dai->name);
 	if (!gb_dai) {
 		dev_err(dai->dev, "%s: DAI not registered\n", dai->name);
@@ -93,6 +89,13 @@ static void gbcodec_shutdown(struct snd_pcm_substream *substream,
 
 	atomic_dec(&gb_dai->users);
 
+	if (!atomic_read(&gb->is_connected)) {
+		if (!atomic_read(&gb_dai->users))
+			wake_up_interruptible(&gb_dai->wait_queue);
+		return;
+	}
+
+	mutex_lock(&gb->lock);
 	/* deactivate rx/tx */
 	cportid = gb_dai->connection->intf_cport_id;
 
@@ -121,6 +124,11 @@ static void gbcodec_shutdown(struct snd_pcm_substream *substream,
 func_exit:
 	mutex_unlock(&gb->lock);
 
+	/*
+	if (!atomic_read(&gb_dai->users))
+		wake_up_interruptible(&gb_dai->wait_queue);
+		*/
+
 	return;
 }
 
@@ -290,8 +298,11 @@ static int gbcodec_trigger(struct snd_pcm_substream *substream, int cmd,
 	struct gbaudio_dai *gb_dai;
 	struct gbaudio_codec_info *gb = dev_get_drvdata(dai->dev);
 
-	if (!atomic_read(&gb->is_connected))
+	if (!atomic_read(&gb->is_connected)) {
+		if (cmd == SNDRV_PCM_TRIGGER_STOP)
+			return 0;
 		return -ENODEV;
+	}
 
 	/* find the dai */
 	mutex_lock(&gb->lock);
@@ -443,9 +454,10 @@ static unsigned int gbcodec_read(struct snd_soc_codec *codec,
  */
 static void gb_audio_cleanup(struct gbaudio_codec_info *gb)
 {
-	int cportid, ret;
+	int cportid, ret, timeout_result;
 	struct gbaudio_dai *gb_dai;
 	struct gb_connection *connection;
+	long timeout = msecs_to_jiffies(50);	/* 50ms */
 	struct device *dev = gb->dev;
 
 	list_for_each_entry(gb_dai, &gb->dai_list, list) {
@@ -454,6 +466,16 @@ static void gb_audio_cleanup(struct gbaudio_codec_info *gb)
 		 * manually
 		 */
 		if (atomic_read(&gb_dai->users)) {
+			/* schedule a wait event */
+			timeout_result =
+				wait_event_interruptible_timeout(
+						gb_dai->wait_queue,
+						!atomic_read(&gb_dai->users),
+						timeout);
+			if (!timeout_result)
+				dev_warn(dev, "%s:DAI still in use.\n",
+					 gb_dai->name);
+
 			connection = gb_dai->connection;
 			/* PB active */
 			ret = gb_audio_apbridgea_stop_tx(connection, 0);
@@ -473,7 +495,6 @@ static void gb_audio_cleanup(struct gbaudio_codec_info *gb)
 			if (ret)
 				dev_info(dev, "%d:Failed during unregister cport\n",
 					 ret);
-			atomic_dec(&gb_dai->users);
 		}
 	}
 }
@@ -655,6 +676,7 @@ static int gb_audio_add_data_connection(struct gbaudio_codec_info *gbcodec,
 
 	connection->private = gbcodec;
 	atomic_set(&dai->users, 0);
+	init_waitqueue_head(&dai->wait_queue);
 	dai->data_cport = connection->intf_cport_id;
 	dai->connection = connection;
 	list_add(&dai->list, &gbcodec->dai_list);

commit b19df7b9950cd8c1212dcc775dffcdaace391db3
Author: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
Date:   Tue Feb 16 00:27:27 2016 +0530

    greybus: audio: Enable support for multiple codec modules
    
    Update params, sequence in response to changes in msm8994
    helper APIs
    
    Signed-off-by: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
    Reviewed-by: Mark Greer <mgreer@animalcreek.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/audio_codec.c b/drivers/staging/greybus/audio_codec.c
index c05ab4fb8754..cabe289b9324 100644
--- a/drivers/staging/greybus/audio_codec.c
+++ b/drivers/staging/greybus/audio_codec.c
@@ -430,65 +430,6 @@ static unsigned int gbcodec_read(struct snd_soc_codec *codec,
 	return val;
 }
 
-static struct snd_soc_codec_driver soc_codec_dev_gbcodec = {
-	.probe = gbcodec_probe,
-	.remove = gbcodec_remove,
-
-	.read = gbcodec_read,
-	.write = gbcodec_write,
-
-	.reg_cache_size = GBCODEC_REG_COUNT,
-	.reg_cache_default = gbcodec_reg_defaults,
-	.reg_word_size = 1,
-
-	.idle_bias_off = true,
-	.ignore_pmdown_time = 1,
-};
-
-/*
- * GB codec DAI link related
- */
-static struct snd_soc_dai_link gbaudio_dailink = {
-	.name = "PRI_MI2S_RX",
-	.stream_name = "Primary MI2S Playback",
-	.platform_name = "msm-pcm-routing",
-	.cpu_dai_name = "msm-dai-q6-mi2s.0",
-	.no_pcm = 1,
-	.be_id = 34,
-};
-
-static int gbaudio_add_dailinks(struct gbaudio_codec_info *gbcodec)
-{
-	int ret, i;
-	char *dai_link_name;
-	struct snd_soc_dai_link *dailink;
-	struct device *dev = gbcodec->dev;
-
-	dailink = &gbaudio_dailink;
-	dailink->codec_name = gbcodec->name;
-
-	/* FIXME
-	 * allocate memory for DAI links based on count.
-	 * currently num_dai_links=1, so using static struct
-	 */
-	gbcodec->num_dai_links = 1;
-
-	for (i = 0; i < gbcodec->num_dai_links; i++) {
-		gbcodec->dailink_name[i] = dai_link_name =
-			devm_kzalloc(dev, NAME_SIZE, GFP_KERNEL);
-		snprintf(dai_link_name, NAME_SIZE, "GB %d.%d PRI_MI2S_RX",
-			 gbcodec->dev_id, i);
-		dailink->name = dai_link_name;
-		dailink->codec_dai_name = gbcodec->dais[i].name;
-	}
-
-	ret = msm8994_add_dailink("msm8994-tomtom-mtp-snd-card", dailink, 1);
-	if (ret)
-		dev_err(dev, "%d:Error while adding DAI link\n", ret);
-
-	return ret;
-}
-
 /*
  * gb_snd management functions
  */
@@ -542,12 +483,21 @@ static int gbaudio_register_codec(struct gbaudio_codec_info *gbcodec)
 	int ret, i;
 	struct device *dev = gbcodec->dev;
 	struct gb_connection *connection = gbcodec->mgmt_connection;
+	struct snd_soc_codec_driver *soc_codec_dev_gbcodec;
 	/*
 	 * FIXME: malloc for topology happens via audio_gb driver
 	 * should be done within codec driver itself
 	 */
 	struct gb_audio_topology *topology;
 
+	soc_codec_dev_gbcodec = devm_kzalloc(gbcodec->dev,
+					     sizeof(*soc_codec_dev_gbcodec),
+					     GFP_KERNEL);
+	if (!soc_codec_dev_gbcodec) {
+		dev_err(gbcodec->dev, "Malloc failed for codec_driver\n");
+		return -ENOMEM;
+	}
+
 	ret = gb_connection_enable(connection);
 	if (ret) {
 		dev_err(dev, "%d: Error while enabling mgmt connection\n", ret);
@@ -572,19 +522,32 @@ static int gbaudio_register_codec(struct gbaudio_codec_info *gbcodec)
 	gbcodec->topology = topology;
 
 	/* update codec info */
-	soc_codec_dev_gbcodec.controls = gbcodec->kctls;
-	soc_codec_dev_gbcodec.num_controls = gbcodec->num_kcontrols;
-	soc_codec_dev_gbcodec.dapm_widgets = gbcodec->widgets;
-	soc_codec_dev_gbcodec.num_dapm_widgets = gbcodec->num_dapm_widgets;
-	soc_codec_dev_gbcodec.dapm_routes = gbcodec->routes;
-	soc_codec_dev_gbcodec.num_dapm_routes = gbcodec->num_dapm_routes;
+	soc_codec_dev_gbcodec->probe = gbcodec_probe,
+	soc_codec_dev_gbcodec->remove = gbcodec_remove,
+
+	soc_codec_dev_gbcodec->read = gbcodec_read,
+	soc_codec_dev_gbcodec->write = gbcodec_write,
+
+	soc_codec_dev_gbcodec->reg_cache_size = GBCODEC_REG_COUNT,
+	soc_codec_dev_gbcodec->reg_cache_default = gbcodec_reg_defaults,
+	soc_codec_dev_gbcodec->reg_word_size = 1,
+
+	soc_codec_dev_gbcodec->idle_bias_off = true,
+	soc_codec_dev_gbcodec->ignore_pmdown_time = 1,
+
+	soc_codec_dev_gbcodec->controls = gbcodec->kctls;
+	soc_codec_dev_gbcodec->num_controls = gbcodec->num_kcontrols;
+	soc_codec_dev_gbcodec->dapm_widgets = gbcodec->widgets;
+	soc_codec_dev_gbcodec->num_dapm_widgets = gbcodec->num_dapm_widgets;
+	soc_codec_dev_gbcodec->dapm_routes = gbcodec->routes;
+	soc_codec_dev_gbcodec->num_dapm_routes = gbcodec->num_dapm_routes;
 
 	/* update DAI info */
 	for (i = 0; i < gbcodec->num_dais; i++)
 		gbcodec->dais[i].ops = &gbcodec_dai_ops;
 
 	/* register codec */
-	ret = snd_soc_register_codec(dev, &soc_codec_dev_gbcodec,
+	ret = snd_soc_register_codec(dev, soc_codec_dev_gbcodec,
 				     gbcodec->dais, 1);
 	if (ret) {
 		dev_err(dev, "%d:Failed to register codec\n", ret);
@@ -592,11 +555,13 @@ static int gbaudio_register_codec(struct gbaudio_codec_info *gbcodec)
 	}
 
 	/* update DAI links in response to this codec */
-	ret = gbaudio_add_dailinks(gbcodec);
+	ret = msm8994_add_dailink("msm8994-tomtom-mtp-snd-card", gbcodec->name,
+				  gbcodec->dais[0].name, 1);
 	if (ret) {
 		dev_err(dev, "%d: Failed to add DAI links\n", ret);
 		goto add_dailink_err;
 	}
+	gbcodec->num_dai_links = 1;
 
 	return 0;
 
@@ -615,8 +580,8 @@ static int gbaudio_register_codec(struct gbaudio_codec_info *gbcodec)
 static void gbaudio_unregister_codec(struct gbaudio_codec_info *gbcodec)
 {
 	gb_audio_cleanup(gbcodec);
-	msm8994_remove_dailink("msm8994-tomtom-mtp-snd-card", &gbaudio_dailink,
-			       1);
+	msm8994_remove_dailink("msm8994-tomtom-mtp-snd-card", gbcodec->name,
+			       gbcodec->dais[0].name, 1);
 	snd_soc_unregister_codec(gbcodec->dev);
 	gbaudio_tplg_release(gbcodec);
 	kfree(gbcodec->topology);
@@ -792,7 +757,7 @@ static int gb_audio_probe(struct gb_bundle *bundle,
 	gbcodec->manager_id = gb_audio_manager_add(&desc);
 
 	atomic_set(&gbcodec->is_connected, 1);
-	list_add(&gbcodec->list, &gb_codec_list);
+	list_add_tail(&gbcodec->list, &gb_codec_list);
 	dev_dbg(dev, "Add GB Audio device:%s\n", gbcodec->name);
 	mutex_unlock(&gb_codec_list_lock);
 
@@ -826,7 +791,6 @@ static void gb_audio_disconnect(struct gb_bundle *bundle)
 
 	mutex_lock(&gb_codec_list_lock);
 	atomic_set(&gbcodec->is_connected, 0);
-	list_del(&gbcodec->list);
 	/* inform uevent to above layers */
 	gb_audio_manager_remove(gbcodec->manager_id);
 
@@ -842,6 +806,7 @@ static void gb_audio_disconnect(struct gb_bundle *bundle)
 	}
 	gb_connection_destroy(gbcodec->mgmt_connection);
 	gbcodec->mgmt_connection = NULL;
+	list_del(&gbcodec->list);
 	mutex_unlock(&gbcodec->lock);
 
 	devm_kfree(&bundle->dev, gbcodec);

commit 3994e0b139c709047cdeb44b6c28cfb39f89f3f2
Author: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
Date:   Thu Jan 28 21:15:40 2016 +0530

    greybus: audio: use variable 'is_connected' to maintain module state
    
    there is race condition between _disconnect() request &
    stop_trigger() in case of abrupt module removal.
    And sometimes this can lead to deadlock while acquiring
    codec_info->lock.
    To avoid such situation, atomic variable is used to maintain
    codec connected state.
    During dai operations (trigger, shutdown, etc.), 'is_connected'
    variable is validated to avoid unnecessary lock acquire in
    case module already removed.
    
    Signed-off-by: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/audio_codec.c b/drivers/staging/greybus/audio_codec.c
index ad28c10fa154..c05ab4fb8754 100644
--- a/drivers/staging/greybus/audio_codec.c
+++ b/drivers/staging/greybus/audio_codec.c
@@ -44,6 +44,9 @@ static int gbcodec_startup(struct snd_pcm_substream *substream,
 	struct gbaudio_dai *gb_dai;
 	struct gbaudio_codec_info *gb = dev_get_drvdata(dai->dev);
 
+	if (!atomic_read(&gb->is_connected))
+		return -ENODEV;
+
 	/* find the dai */
 	mutex_lock(&gb->lock);
 	gb_dai = gbaudio_find_dai(gb, -1, dai->name);
@@ -77,6 +80,9 @@ static void gbcodec_shutdown(struct snd_pcm_substream *substream,
 	struct gbaudio_dai *gb_dai;
 	struct gbaudio_codec_info *gb = dev_get_drvdata(dai->dev);
 
+	if (!atomic_read(&gb->is_connected))
+		return;
+
 	/* find the dai */
 	mutex_lock(&gb->lock);
 	gb_dai = gbaudio_find_dai(gb, -1, dai->name);
@@ -129,6 +135,9 @@ static int gbcodec_hw_params(struct snd_pcm_substream *substream,
 	struct gbaudio_dai *gb_dai;
 	struct gbaudio_codec_info *gb = dev_get_drvdata(dai->dev);
 
+	if (!atomic_read(&gb->is_connected))
+		return -ENODEV;
+
 	/* find the dai */
 	mutex_lock(&gb->lock);
 	gb_dai = gbaudio_find_dai(gb, -1, dai->name);
@@ -204,6 +213,9 @@ static int gbcodec_prepare(struct snd_pcm_substream *substream,
 	struct gbaudio_dai *gb_dai;
 	struct gbaudio_codec_info *gb = dev_get_drvdata(dai->dev);
 
+	if (!atomic_read(&gb->is_connected))
+		return -ENODEV;
+
 	/* find the dai */
 	mutex_lock(&gb->lock);
 	gb_dai = gbaudio_find_dai(gb, -1, dai->name);
@@ -278,6 +290,9 @@ static int gbcodec_trigger(struct snd_pcm_substream *substream, int cmd,
 	struct gbaudio_dai *gb_dai;
 	struct gbaudio_codec_info *gb = dev_get_drvdata(dai->dev);
 
+	if (!atomic_read(&gb->is_connected))
+		return -ENODEV;
+
 	/* find the dai */
 	mutex_lock(&gb->lock);
 	gb_dai = gbaudio_find_dai(gb, -1, dai->name);
@@ -776,6 +791,7 @@ static int gb_audio_probe(struct gb_bundle *bundle,
 	desc.devices = 0x2; /* todo */
 	gbcodec->manager_id = gb_audio_manager_add(&desc);
 
+	atomic_set(&gbcodec->is_connected, 1);
 	list_add(&gbcodec->list, &gb_codec_list);
 	dev_dbg(dev, "Add GB Audio device:%s\n", gbcodec->name);
 	mutex_unlock(&gb_codec_list_lock);
@@ -809,6 +825,7 @@ static void gb_audio_disconnect(struct gb_bundle *bundle)
 	struct gbaudio_dai *dai, *_dai;
 
 	mutex_lock(&gb_codec_list_lock);
+	atomic_set(&gbcodec->is_connected, 0);
 	list_del(&gbcodec->list);
 	/* inform uevent to above layers */
 	gb_audio_manager_remove(gbcodec->manager_id);

commit 796fad441cb248c1eac88bfb3a5929bb1a10fabb
Author: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
Date:   Thu Jan 28 21:15:39 2016 +0530

    greybus: audio: codec driver cleanup
    
    audio codec driver is now moved to bundle driver approach.
    This resolved many race conditions related to audio mgmt &
    data connection init/exit sequence.
    Thus, a lot of helper functions can now be safely removed.
    
    Signed-off-by: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/audio_codec.c b/drivers/staging/greybus/audio_codec.c
index b43b5432d7a6..ad28c10fa154 100644
--- a/drivers/staging/greybus/audio_codec.c
+++ b/drivers/staging/greybus/audio_codec.c
@@ -18,30 +18,38 @@
 static DEFINE_MUTEX(gb_codec_list_lock);
 static LIST_HEAD(gb_codec_list);
 
+struct gbaudio_dai *gbaudio_find_dai(struct gbaudio_codec_info *gbcodec,
+				     int data_cport, const char *name)
+{
+	struct gbaudio_dai *dai;
+
+	list_for_each_entry(dai, &gbcodec->dai_list, list) {
+		if (name && !strncmp(dai->name, name, NAME_SIZE))
+			return dai;
+		if ((data_cport != -1) && (dai->data_cport == data_cport))
+			return dai;
+	}
+	return NULL;
+}
+
 /*
  * codec DAI ops
  */
 static int gbcodec_startup(struct snd_pcm_substream *substream,
 			   struct snd_soc_dai *dai)
 {
-	int ret, found;
+	int ret;
 	__u16 i2s_port, cportid;
 
 	struct gbaudio_dai *gb_dai;
-	struct gb_audio *audio = dev_get_drvdata(dai->dev);
-	struct gbaudio_codec_info *gb = audio->gbcodec;
+	struct gbaudio_codec_info *gb = dev_get_drvdata(dai->dev);
 
 	/* find the dai */
-	found = 0;
-	list_for_each_entry(gb_dai, &gb->dai_list, list) {
-		if (!strncmp(gb_dai->name, dai->name, NAME_SIZE)) {
-			found = 1;
-			break;
-		}
-	}
-
-	if (!found) {
+	mutex_lock(&gb->lock);
+	gb_dai = gbaudio_find_dai(gb, -1, dai->name);
+	if (!gb_dai) {
 		dev_err(dai->dev, "%s: DAI not registered\n", dai->name);
+		mutex_unlock(&gb->lock);
 		return -EINVAL;
 	}
 
@@ -54,7 +62,8 @@ static int gbcodec_startup(struct snd_pcm_substream *substream,
 		ret);
 
 	if (!ret)
-		atomic_inc(&gb->users);
+		atomic_inc(&gb_dai->users);
+	mutex_unlock(&gb->lock);
 
 	return ret;
 }
@@ -62,28 +71,21 @@ static int gbcodec_startup(struct snd_pcm_substream *substream,
 static void gbcodec_shutdown(struct snd_pcm_substream *substream,
 			     struct snd_soc_dai *dai)
 {
-	int ret, found;
+	int ret;
 	__u16 i2s_port, cportid;
 
 	struct gbaudio_dai *gb_dai;
-	struct gb_audio *audio = dev_get_drvdata(dai->dev);
-	struct gbaudio_codec_info *gb = audio->gbcodec;
+	struct gbaudio_codec_info *gb = dev_get_drvdata(dai->dev);
 
 	/* find the dai */
-	found = 0;
-	list_for_each_entry(gb_dai, &gb->dai_list, list) {
-		if (!strncmp(gb_dai->name, dai->name, NAME_SIZE)) {
-			found = 1;
-			break;
-		}
-	}
-
-	if (!found) {
+	mutex_lock(&gb->lock);
+	gb_dai = gbaudio_find_dai(gb, -1, dai->name);
+	if (!gb_dai) {
 		dev_err(dai->dev, "%s: DAI not registered\n", dai->name);
-		return;
+		goto func_exit;
 	}
 
-	atomic_dec(&gb->users);
+	atomic_dec(&gb_dai->users);
 
 	/* deactivate rx/tx */
 	cportid = gb_dai->connection->intf_cport_id;
@@ -97,7 +99,7 @@ static void gbcodec_shutdown(struct snd_pcm_substream *substream,
 		break;
 	default:
 		dev_err(dai->dev, "Invalid stream type during shutdown\n");
-		return;
+		goto func_exit;
 	}
 
 	if (ret)
@@ -110,6 +112,8 @@ static void gbcodec_shutdown(struct snd_pcm_substream *substream,
 
 	dev_dbg(dai->dev, "Unregister %s:%d DAI, ret:%d\n", dai->name,
 		gb_dai->connection->hd_cport_id, ret);
+func_exit:
+	mutex_unlock(&gb->lock);
 
 	return;
 }
@@ -118,26 +122,20 @@ static int gbcodec_hw_params(struct snd_pcm_substream *substream,
 			     struct snd_pcm_hw_params *hwparams,
 			     struct snd_soc_dai *dai)
 {
-	int ret, found;
+	int ret;
 	uint8_t sig_bits, channels;
 	uint32_t format, rate;
 	uint16_t data_cport;
 	struct gbaudio_dai *gb_dai;
-	struct gb_audio *audio = dev_get_drvdata(dai->dev);
-	struct gbaudio_codec_info *gb = audio->gbcodec;
+	struct gbaudio_codec_info *gb = dev_get_drvdata(dai->dev);
 
 	/* find the dai */
-	found = 0;
-	list_for_each_entry(gb_dai, &gb->dai_list, list) {
-		if (!strncmp(gb_dai->name, dai->name, NAME_SIZE)) {
-			found = 1;
-			break;
-		}
-	}
-
-	if (!found) {
+	mutex_lock(&gb->lock);
+	gb_dai = gbaudio_find_dai(gb, -1, dai->name);
+	if (!gb_dai) {
 		dev_err(dai->dev, "%s: DAI not registered\n", dai->name);
-		return -EINVAL;
+		ret = -EINVAL;
+		goto func_exit;
 	}
 
 	/*
@@ -147,21 +145,24 @@ static int gbcodec_hw_params(struct snd_pcm_substream *substream,
 	if (params_channels(hwparams) != 2) {
 		dev_err(dai->dev, "Invalid channel count:%d\n",
 			params_channels(hwparams));
-		return -EINVAL;
+		ret = -EINVAL;
+		goto func_exit;
 	}
 	channels = params_channels(hwparams);
 
 	if (params_rate(hwparams) != 48000) {
 		dev_err(dai->dev, "Invalid sampling rate:%d\n",
 			params_rate(hwparams));
-		return -EINVAL;
+		ret = -EINVAL;
+		goto func_exit;
 	}
 	rate = GB_AUDIO_PCM_RATE_48000;
 
 	if (params_format(hwparams) != SNDRV_PCM_FORMAT_S16_LE) {
 		dev_err(dai->dev, "Invalid format:%d\n",
 			params_format(hwparams));
-		return -EINVAL;
+		ret = -EINVAL;
+		goto func_exit;
 	}
 	format = GB_AUDIO_PCM_FMT_S16_LE;
 
@@ -176,7 +177,7 @@ static int gbcodec_hw_params(struct snd_pcm_substream *substream,
 				  rate, channels, sig_bits);
 	if (ret) {
 		dev_err(dai->dev, "%d: Error during set_pcm\n", ret);
-		return ret;
+		goto func_exit;
 	}
 
 	/*
@@ -190,31 +191,26 @@ static int gbcodec_hw_params(struct snd_pcm_substream *substream,
 					    6144000);
 	if (ret)
 		dev_err(dai->dev, "%d: Error during set_config\n", ret);
-
+func_exit:
+	mutex_unlock(&gb->lock);
 	return ret;
 }
 
 static int gbcodec_prepare(struct snd_pcm_substream *substream,
 			   struct snd_soc_dai *dai)
 {
-	int ret, found;
+	int ret;
 	uint16_t data_cport;
 	struct gbaudio_dai *gb_dai;
-	struct gb_audio *audio = dev_get_drvdata(dai->dev);
-	struct gbaudio_codec_info *gb = audio->gbcodec;
+	struct gbaudio_codec_info *gb = dev_get_drvdata(dai->dev);
 
 	/* find the dai */
-	found = 0;
-	list_for_each_entry(gb_dai, &gb->dai_list, list) {
-		if (!strncmp(gb_dai->name, dai->name, NAME_SIZE)) {
-			found = 1;
-			break;
-		}
-	}
-
-	if (!found) {
+	mutex_lock(&gb->lock);
+	gb_dai = gbaudio_find_dai(gb, -1, dai->name);
+	if (!gb_dai) {
 		dev_err(dai->dev, "%s: DAI not registered\n", dai->name);
-		return -EINVAL;
+		ret = -EINVAL;
+		goto func_exit;
 	}
 
 	/* deactivate rx/tx */
@@ -228,7 +224,7 @@ static int gbcodec_prepare(struct snd_pcm_substream *substream,
 			dev_err(dai->dev,
 				"%d:Error during set_rx_data_size, cport:%d\n",
 				ret, data_cport);
-			return ret;
+			goto func_exit;
 		}
 		ret = gb_audio_apbridgea_set_rx_data_size(gb_dai->connection, 0,
 							  192);
@@ -236,7 +232,7 @@ static int gbcodec_prepare(struct snd_pcm_substream *substream,
 			dev_err(dai->dev,
 				"%d:Error during apbridgea_set_rx_data_size\n",
 				ret);
-			return ret;
+			goto func_exit;
 		}
 		ret = gb_audio_gb_activate_rx(gb->mgmt_connection, data_cport);
 		break;
@@ -247,7 +243,7 @@ static int gbcodec_prepare(struct snd_pcm_substream *substream,
 			dev_err(dai->dev,
 				"%d:Error during module set_tx_data_size, cport:%d\n",
 				ret, data_cport);
-			return ret;
+			goto func_exit;
 		}
 		ret = gb_audio_apbridgea_set_tx_data_size(gb_dai->connection, 0,
 							  192);
@@ -255,43 +251,40 @@ static int gbcodec_prepare(struct snd_pcm_substream *substream,
 			dev_err(dai->dev,
 				"%d:Error during apbridgea set_tx_data_size, cport\n",
 				ret);
-			return ret;
+			goto func_exit;
 		}
 		ret = gb_audio_gb_activate_tx(gb->mgmt_connection, data_cport);
 		break;
 	default:
 		dev_err(dai->dev, "Invalid stream type %d during prepare\n",
 			substream->stream);
-		return -EINVAL;
+		ret = -EINVAL;
+		goto func_exit;
 	}
 
 	if (ret)
 		dev_err(dai->dev, "%d: Error during activate stream\n", ret);
 
+func_exit:
+	mutex_unlock(&gb->lock);
 	return ret;
 }
 
 static int gbcodec_trigger(struct snd_pcm_substream *substream, int cmd,
 		struct snd_soc_dai *dai)
 {
-	int ret, found;
+	int ret;
 	int tx, rx, start, stop;
 	struct gbaudio_dai *gb_dai;
-	struct gb_audio *audio = dev_get_drvdata(dai->dev);
-	struct gbaudio_codec_info *gb = audio->gbcodec;
+	struct gbaudio_codec_info *gb = dev_get_drvdata(dai->dev);
 
 	/* find the dai */
-	found = 0;
-	list_for_each_entry(gb_dai, &gb->dai_list, list) {
-		if (!strncmp(gb_dai->name, dai->name, NAME_SIZE)) {
-			found = 1;
-			break;
-		}
-	}
-
-	if (!found) {
+	mutex_lock(&gb->lock);
+	gb_dai = gbaudio_find_dai(gb, -1, dai->name);
+	if (!gb_dai) {
 		dev_err(dai->dev, "%s: DAI not registered\n", dai->name);
-		return -EINVAL;
+		ret = -EINVAL;
+		goto func_exit;
 	}
 
 	tx = rx = start = stop = 0;
@@ -306,7 +299,8 @@ static int gbcodec_trigger(struct snd_pcm_substream *substream, int cmd,
 		break;
 	default:
 		dev_err(dai->dev, "Invalid tigger cmd:%d\n", cmd);
-		return -EINVAL;
+		ret = -EINVAL;
+		goto func_exit;
 	}
 
 	switch (substream->stream) {
@@ -319,7 +313,8 @@ static int gbcodec_trigger(struct snd_pcm_substream *substream, int cmd,
 	default:
 		dev_err(dai->dev, "Invalid stream type:%d\n",
 			substream->stream);
-		return -EINVAL;
+		ret = -EINVAL;
+		goto func_exit;
 	}
 
 	if (start && tx)
@@ -341,6 +336,8 @@ static int gbcodec_trigger(struct snd_pcm_substream *substream, int cmd,
 		dev_err(dai->dev, "%d:Error during %s stream\n", ret,
 			start ? "Start" : "Stop");
 
+func_exit:
+	mutex_unlock(&gb->lock);
 	return ret;
 }
 
@@ -383,8 +380,7 @@ static int gbcodec_write(struct snd_soc_codec *codec, unsigned int reg,
 			 unsigned int value)
 {
 	int ret = 0;
-	struct gb_audio *audio = snd_soc_codec_get_drvdata(codec);
-	struct gbaudio_codec_info *gbcodec = audio->gbcodec;
+	struct gbaudio_codec_info *gbcodec = snd_soc_codec_get_drvdata(codec);
 	u8 *gbcodec_reg = gbcodec->reg;
 
 	if (reg == SND_SOC_NOPM)
@@ -404,8 +400,7 @@ static unsigned int gbcodec_read(struct snd_soc_codec *codec,
 {
 	unsigned int val = 0;
 
-	struct gb_audio *audio = snd_soc_codec_get_drvdata(codec);
-	struct gbaudio_codec_info *gbcodec = audio->gbcodec;
+	struct gbaudio_codec_info *gbcodec = snd_soc_codec_get_drvdata(codec);
 	u8 *gbcodec_reg = gbcodec->reg;
 
 	if (reg == SND_SOC_NOPM)
@@ -447,28 +442,15 @@ static struct snd_soc_dai_link gbaudio_dailink = {
 	.be_id = 34,
 };
 
-static void gbaudio_remove_dailinks(struct gbaudio_codec_info *gbcodec)
-{
-	int i;
-
-	for (i = 0; i < gbcodec->num_dai_links; i++) {
-		dev_dbg(gbcodec->dev, "Remove %s: DAI link\n",
-			gbcodec->dailink_name[i]);
-		devm_kfree(gbcodec->dev, gbcodec->dailink_name[i]);
-		gbcodec->dailink_name[i] = NULL;
-	}
-	gbcodec->num_dai_links = 0;
-}
-
 static int gbaudio_add_dailinks(struct gbaudio_codec_info *gbcodec)
 {
 	int ret, i;
 	char *dai_link_name;
-	struct snd_soc_dai_link *dai;
+	struct snd_soc_dai_link *dailink;
 	struct device *dev = gbcodec->dev;
 
-	dai = &gbaudio_dailink;
-	dai->codec_name = gbcodec->name;
+	dailink = &gbaudio_dailink;
+	dailink->codec_name = gbcodec->name;
 
 	/* FIXME
 	 * allocate memory for DAI links based on count.
@@ -481,98 +463,20 @@ static int gbaudio_add_dailinks(struct gbaudio_codec_info *gbcodec)
 			devm_kzalloc(dev, NAME_SIZE, GFP_KERNEL);
 		snprintf(dai_link_name, NAME_SIZE, "GB %d.%d PRI_MI2S_RX",
 			 gbcodec->dev_id, i);
-		dai->name = dai_link_name;
-		dai->codec_dai_name = gbcodec->dais[i].name;
+		dailink->name = dai_link_name;
+		dailink->codec_dai_name = gbcodec->dais[i].name;
 	}
 
-	ret = msm8994_add_dailink("msm8994-tomtom-mtp-snd-card", dai, 1);
-	if (ret) {
+	ret = msm8994_add_dailink("msm8994-tomtom-mtp-snd-card", dailink, 1);
+	if (ret)
 		dev_err(dev, "%d:Error while adding DAI link\n", ret);
-		goto err_dai_link;
-	}
 
 	return ret;
-
-err_dai_link:
-	gbcodec->num_dai_links = i;
-	gbaudio_remove_dailinks(gbcodec);
-	return ret;
 }
 
 /*
  * gb_snd management functions
  */
-static struct gbaudio_codec_info *gbaudio_find_codec(struct device *dev,
-						     int dev_id)
-{
-	struct gbaudio_codec_info *tmp, *ret;
-
-	mutex_lock(&gb_codec_list_lock);
-	list_for_each_entry_safe(ret, tmp, &gb_codec_list, list) {
-		dev_dbg(dev, "%d:device found\n", ret->dev_id);
-		if (ret->dev_id == dev_id) {
-			mutex_unlock(&gb_codec_list_lock);
-			return ret;
-		}
-	}
-	mutex_unlock(&gb_codec_list_lock);
-	return NULL;
-}
-
-static struct gbaudio_codec_info *gbaudio_get_codec(struct device *dev,
-						    int dev_id)
-{
-	struct gbaudio_codec_info *gbcodec;
-	struct gb_audio *audio = dev_get_drvdata(dev);
-
-	gbcodec = gbaudio_find_codec(dev, dev_id);
-	if (gbcodec)
-		return gbcodec;
-
-	gbcodec = devm_kzalloc(dev, sizeof(*gbcodec), GFP_KERNEL);
-	if (!gbcodec)
-		return NULL;
-
-	mutex_init(&gbcodec->lock);
-	INIT_LIST_HEAD(&gbcodec->dai_list);
-	INIT_LIST_HEAD(&gbcodec->widget_list);
-	INIT_LIST_HEAD(&gbcodec->codec_ctl_list);
-	INIT_LIST_HEAD(&gbcodec->widget_ctl_list);
-	gbcodec->dev_id = dev_id;
-	audio->gbcodec = gbcodec;
-	gbcodec->dev = dev;
-	snprintf(gbcodec->name, NAME_SIZE, "%s.%s", dev->driver->name,
-		 dev_name(dev));
-
-	mutex_lock(&gb_codec_list_lock);
-	list_add(&gbcodec->list, &gb_codec_list);
-	mutex_unlock(&gb_codec_list_lock);
-	dev_dbg(dev, "%d:%s Added to codec list\n", gbcodec->dev_id,
-		gbcodec->name);
-
-	return gbcodec;
-}
-
-static void gbaudio_free_codec(struct device *dev,
-			       struct gbaudio_codec_info *gbcodec)
-{
-	struct gb_audio *audio = dev_get_drvdata(dev);
-
-	mutex_lock(&gb_codec_list_lock);
-	if (!gbcodec->mgmt_connection &&
-			list_empty(&gbcodec->dai_list)) {
-		list_del(&gbcodec->list);
-		mutex_unlock(&gb_codec_list_lock);
-		audio->gbcodec = NULL;
-		devm_kfree(dev, gbcodec);
-	} else {
-		mutex_unlock(&gb_codec_list_lock);
-	}
-}
-
-/*
- * This is the basic hook get things initialized and registered w/ gb
- */
 
 /* XXX
  * since BE DAI path is not yet properly closed from above layer,
@@ -593,7 +497,7 @@ static void gb_audio_cleanup(struct gbaudio_codec_info *gb)
 		 * In case of BE dailink, need to deactivate APBridge
 		 * manually
 		 */
-		if (gbaudio_dailink.no_pcm && atomic_read(&gb->users)) {
+		if (atomic_read(&gb_dai->users)) {
 			connection = gb_dai->connection;
 			/* PB active */
 			ret = gb_audio_apbridgea_stop_tx(connection, 0);
@@ -613,38 +517,34 @@ static void gb_audio_cleanup(struct gbaudio_codec_info *gb)
 			if (ret)
 				dev_info(dev, "%d:Failed during unregister cport\n",
 					 ret);
-			atomic_dec(&gb->users);
+			atomic_dec(&gb_dai->users);
 		}
 	}
 }
 
-static int gbaudio_codec_probe(struct gb_connection *connection)
+static int gbaudio_register_codec(struct gbaudio_codec_info *gbcodec)
 {
 	int ret, i;
-	struct gbaudio_codec_info *gbcodec;
+	struct device *dev = gbcodec->dev;
+	struct gb_connection *connection = gbcodec->mgmt_connection;
+	/*
+	 * FIXME: malloc for topology happens via audio_gb driver
+	 * should be done within codec driver itself
+	 */
 	struct gb_audio_topology *topology;
-	struct gb_audio_manager_module_descriptor desc;
-	struct device *dev = &connection->bundle->dev;
-	int dev_id = connection->intf->interface_id;
-
-	dev_dbg(dev, "Add device:%d:%s\n", dev_id, dev_name(dev));
-	/* get gbcodec data */
-	gbcodec = gbaudio_get_codec(dev, dev_id);
-	if (!gbcodec)
-		return -ENOMEM;
-
-	gbcodec->mgmt_connection = connection;
 
 	ret = gb_connection_enable(connection);
-	if (ret)
-		goto base_error;
+	if (ret) {
+		dev_err(dev, "%d: Error while enabling mgmt connection\n", ret);
+		return ret;
+	}
 
+	gbcodec->dev_id = connection->intf->interface_id;
 	/* fetch topology data */
 	ret = gb_audio_gb_get_topology(connection, &topology);
 	if (ret) {
-		dev_err(gbcodec->dev,
-			"%d:Error while fetching topology\n", ret);
-		goto err_connection_disable;
+		dev_err(dev, "%d:Error while fetching topology\n", ret);
+		goto tplg_fetch_err;
 	}
 
 	/* process topology data */
@@ -652,7 +552,7 @@ static int gbaudio_codec_probe(struct gb_connection *connection)
 	if (ret) {
 		dev_err(dev, "%d:Error while parsing topology data\n",
 			  ret);
-		goto topology_error;
+		goto tplg_parse_err;
 	}
 	gbcodec->topology = topology;
 
@@ -673,100 +573,39 @@ static int gbaudio_codec_probe(struct gb_connection *connection)
 				     gbcodec->dais, 1);
 	if (ret) {
 		dev_err(dev, "%d:Failed to register codec\n", ret);
-		goto parse_error;
+		goto codec_reg_err;
 	}
 
 	/* update DAI links in response to this codec */
 	ret = gbaudio_add_dailinks(gbcodec);
 	if (ret) {
 		dev_err(dev, "%d: Failed to add DAI links\n", ret);
-		goto codec_reg_error;
+		goto add_dailink_err;
 	}
 
-	/* set registered flag */
-	mutex_lock(&gbcodec->lock);
-	gbcodec->codec_registered = 1;
-
-	/* codec cleanup related */
-	atomic_set(&gbcodec->users, 0);
-
-	/* inform above layer for uevent */
-	if (!gbcodec->set_uevent &&
-	    (gbcodec->dai_added == gbcodec->num_dais)) {
-		dev_dbg(dev, "Inform set_event:%d to above layer\n", 1);
-		/* prepare for the audio manager */
-		strlcpy(desc.name, gbcodec->name,
-			GB_AUDIO_MANAGER_MODULE_NAME_LEN); /* todo */
-		desc.slot = 1; /* todo */
-		desc.vid = 2; /* todo */
-		desc.pid = 3; /* todo */
-		desc.cport = gbcodec->dev_id;
-		desc.devices = 0x2; /* todo */
-		gbcodec->manager_id = gb_audio_manager_add(&desc);
-		gbcodec->set_uevent = 1;
-	}
-	mutex_unlock(&gbcodec->lock);
-
-	return ret;
+	return 0;
 
-codec_reg_error:
+add_dailink_err:
 	snd_soc_unregister_codec(dev);
-	dev->driver = NULL;
-parse_error:
+codec_reg_err:
 	gbaudio_tplg_release(gbcodec);
 	gbcodec->topology = NULL;
-topology_error:
+tplg_parse_err:
 	kfree(topology);
-err_connection_disable:
-	gb_connection_disable(connection);
-base_error:
-	gbcodec->mgmt_connection = NULL;
-	gbaudio_free_codec(dev, gbcodec);
+tplg_fetch_err:
+	gb_connection_disable(gbcodec->mgmt_connection);
 	return ret;
 }
 
-static void gbaudio_codec_remove(struct gb_connection *connection)
+static void gbaudio_unregister_codec(struct gbaudio_codec_info *gbcodec)
 {
-	struct gbaudio_codec_info *gbcodec;
-	struct device *dev = &connection->bundle->dev;
-	int dev_id = connection->intf->interface_id;
-
-	dev_dbg(dev, "Remove device:%d:%s\n", dev_id, dev_name(dev));
-
-	/* get gbcodec data */
-	gbcodec = gbaudio_find_codec(dev, dev_id);
-	if (!gbcodec)
-		return;
-
-	/* inform uevent to above layers */
-	mutex_lock(&gbcodec->lock);
-	if (gbcodec->set_uevent) {
-		/* notify the audio manager */
-		dev_dbg(dev, "Inform set_event:%d to above layer\n", 0);
-		gb_audio_manager_remove(gbcodec->manager_id);
-		gbcodec->set_uevent = 0;
-	}
-	mutex_unlock(&gbcodec->lock);
-
-	if (atomic_read(&gbcodec->users)) {
-		dev_err(dev, "Cleanup Error: BE stream not yet closed\n");
-		gb_audio_cleanup(gbcodec);
-	}
-
+	gb_audio_cleanup(gbcodec);
 	msm8994_remove_dailink("msm8994-tomtom-mtp-snd-card", &gbaudio_dailink,
 			       1);
-	gbaudio_remove_dailinks(gbcodec);
-
-	snd_soc_unregister_codec(dev);
-	dev->driver = NULL;
+	snd_soc_unregister_codec(gbcodec->dev);
 	gbaudio_tplg_release(gbcodec);
 	kfree(gbcodec->topology);
-	gb_connection_disable(connection);
-	gbcodec->mgmt_connection = NULL;
-	mutex_lock(&gbcodec->lock);
-	gbcodec->codec_registered = 0;
-	mutex_unlock(&gbcodec->lock);
-	gbaudio_free_codec(dev, gbcodec);
+	gb_connection_disable(gbcodec->mgmt_connection);
 }
 
 static int gbaudio_codec_request_handler(struct gb_operation *op)
@@ -781,93 +620,6 @@ static int gbaudio_codec_request_handler(struct gb_operation *op)
 	return 0;
 }
 
-static int gbaudio_dai_probe(struct gb_connection *connection)
-{
-	struct gbaudio_dai *dai;
-	struct device *dev = &connection->bundle->dev;
-	int dev_id = connection->intf->interface_id;
-	struct gbaudio_codec_info *gbcodec;
-	struct gb_audio_manager_module_descriptor desc;
-	int ret;
-
-	dev_dbg(dev, "Add DAI device:%d:%s\n", dev_id, dev_name(dev));
-
-	/* get gbcodec data */
-	gbcodec = gbaudio_get_codec(dev, dev_id);
-	if (!gbcodec)
-		return -ENOMEM;
-
-	ret = gb_connection_enable(connection);
-	if (ret)
-		goto err_free_codec;
-
-	/* add/update dai_list*/
-	dai = gbaudio_add_dai(gbcodec, connection->intf_cport_id, connection,
-			       NULL);
-	if (!dai) {
-		ret = -ENOMEM;
-		goto err_connection_disable;
-	}
-
-	/* update dai_added count */
-	mutex_lock(&gbcodec->lock);
-	gbcodec->dai_added++;
-
-	/* inform above layer for uevent */
-	if (!gbcodec->set_uevent && gbcodec->codec_registered &&
-	    (gbcodec->dai_added == gbcodec->num_dais)) {
-		/* prepare for the audio manager */
-		dev_dbg(dev, "Inform set_event:%d to above layer\n", 1);
-		strlcpy(desc.name, gbcodec->name,
-			GB_AUDIO_MANAGER_MODULE_NAME_LEN); /* todo */
-		desc.slot = 1; /* todo */
-		desc.vid = 2; /* todo */
-		desc.pid = 3; /* todo */
-		desc.cport = gbcodec->dev_id;
-		desc.devices = 0x2; /* todo */
-		gbcodec->manager_id = gb_audio_manager_add(&desc);
-		gbcodec->set_uevent = 1;
-	}
-	mutex_unlock(&gbcodec->lock);
-
-	return 0;
-
-err_connection_disable:
-	gb_connection_disable(connection);
-err_free_codec:
-	gbaudio_free_codec(dev, gbcodec);
-	return ret;
-}
-
-static void gbaudio_dai_remove(struct gb_connection *connection)
-{
-	struct device *dev = &connection->bundle->dev;
-	int dev_id = connection->intf->interface_id;
-	struct gbaudio_codec_info *gbcodec;
-
-	dev_dbg(dev, "Remove DAI device:%d:%s\n", dev_id, dev_name(dev));
-
-	/* get gbcodec data */
-	gbcodec = gbaudio_find_codec(dev, dev_id);
-	if (!gbcodec)
-		return;
-
-	/* inform uevent to above layers */
-	mutex_lock(&gbcodec->lock);
-	if (gbcodec->set_uevent) {
-		/* notify the audio manager */
-		dev_dbg(dev, "Inform set_event:%d to above layer\n", 0);
-		gb_audio_manager_remove(gbcodec->manager_id);
-		gbcodec->set_uevent = 0;
-	}
-	/* update dai_added count */
-	gbcodec->dai_added--;
-	mutex_unlock(&gbcodec->lock);
-
-	gb_connection_disable(connection);
-	gbaudio_free_codec(dev, gbcodec);
-}
-
 static int gbaudio_dai_request_handler(struct gb_operation *op)
 {
 	struct gb_connection *connection = op->connection;
@@ -877,14 +629,14 @@ static int gbaudio_dai_request_handler(struct gb_operation *op)
 	return 0;
 }
 
-static int gb_audio_add_mgmt_connection(struct gb_audio *audio,
+static int gb_audio_add_mgmt_connection(struct gbaudio_codec_info *gbcodec,
 				struct greybus_descriptor_cport *cport_desc,
 				struct gb_bundle *bundle)
 {
 	struct gb_connection *connection;
 
 	/* Management Cport */
-	if (audio->mgmt_connection) {
+	if (gbcodec->mgmt_connection) {
 		dev_err(&bundle->dev,
 			"Can't have multiple Management connections\n");
 		return -ENODEV;
@@ -895,74 +647,99 @@ static int gb_audio_add_mgmt_connection(struct gb_audio *audio,
 	if (IS_ERR(connection))
 		return PTR_ERR(connection);
 
-	connection->private = audio;
-	audio->mgmt_connection = connection;
+	connection->private = gbcodec;
+	gbcodec->mgmt_connection = connection;
 
 	return 0;
 }
 
-static int gb_audio_add_data_connection(struct gb_audio *audio,
+static int gb_audio_add_data_connection(struct gbaudio_codec_info *gbcodec,
 				struct greybus_descriptor_cport *cport_desc,
-				struct gb_bundle *bundle, int index)
+				struct gb_bundle *bundle)
 {
 	struct gb_connection *connection;
+	struct gbaudio_dai *dai;
+
+	dai = devm_kzalloc(gbcodec->dev, sizeof(*dai), GFP_KERNEL);
+	if (!dai) {
+		dev_err(gbcodec->dev, "DAI Malloc failure\n");
+		return -ENOMEM;
+	}
 
 	connection = gb_connection_create(bundle, le16_to_cpu(cport_desc->id),
 					  gbaudio_dai_request_handler);
-	if (IS_ERR(connection))
+	if (IS_ERR(connection)) {
+		devm_kfree(gbcodec->dev, dai);
 		return PTR_ERR(connection);
+	}
 
-	connection->private = audio;
-	audio->data_connection[index] = connection;
+	connection->private = gbcodec;
+	atomic_set(&dai->users, 0);
+	dai->data_cport = connection->intf_cport_id;
+	dai->connection = connection;
+	list_add(&dai->list, &gbcodec->dai_list);
 
 	return 0;
 }
+/*
+ * This is the basic hook get things initialized and registered w/ gb
+ */
 
 static int gb_audio_probe(struct gb_bundle *bundle,
 			  const struct greybus_bundle_id *id)
 {
+	struct device *dev = &bundle->dev;
+	struct gbaudio_codec_info *gbcodec;
 	struct greybus_descriptor_cport *cport_desc;
-	struct gb_audio *audio;
+	struct gb_audio_manager_module_descriptor desc;
+	struct gbaudio_dai *dai, *_dai;
 	int ret, i;
-	int count = bundle->num_cports - 1;
 
 	/* There should be at least one Management and one Data cport */
 	if (bundle->num_cports < 2)
 		return -ENODEV;
 
+	mutex_lock(&gb_codec_list_lock);
 	/*
 	 * There can be only one Management connection and any number of data
 	 * connections.
 	 */
-	audio = kzalloc(sizeof(*audio) +
-			count * sizeof(*audio->data_connection), GFP_KERNEL);
-	if (!audio)
+	gbcodec = devm_kzalloc(dev, sizeof(*gbcodec), GFP_KERNEL);
+	if (!gbcodec) {
+		mutex_unlock(&gb_codec_list_lock);
 		return -ENOMEM;
+	}
 
-	audio->num_data_connections = count;
-	greybus_set_drvdata(bundle, audio);
+	gbcodec->num_data_connections = bundle->num_cports - 1;
+	mutex_init(&gbcodec->lock);
+	INIT_LIST_HEAD(&gbcodec->dai_list);
+	INIT_LIST_HEAD(&gbcodec->widget_list);
+	INIT_LIST_HEAD(&gbcodec->codec_ctl_list);
+	INIT_LIST_HEAD(&gbcodec->widget_ctl_list);
+	gbcodec->dev = dev;
+	snprintf(gbcodec->name, NAME_SIZE, "%s.%s", dev->driver->name,
+		 dev_name(dev));
+	greybus_set_drvdata(bundle, gbcodec);
 
 	/* Create all connections */
-	for (count = 0, i = 0; i < bundle->num_cports; i++) {
+	for (i = 0; i < bundle->num_cports; i++) {
 		cport_desc = &bundle->cport_desc[i];
 
 		switch (cport_desc->protocol_id) {
 		case GREYBUS_PROTOCOL_AUDIO_MGMT:
-			ret = gb_audio_add_mgmt_connection(audio, cport_desc,
+			ret = gb_audio_add_mgmt_connection(gbcodec, cport_desc,
 							   bundle);
 			if (ret)
 				goto destroy_connections;
 			break;
 		case GREYBUS_PROTOCOL_AUDIO_DATA:
-			ret = gb_audio_add_data_connection(audio, cport_desc,
-							   bundle, count);
+			ret = gb_audio_add_data_connection(gbcodec, cport_desc,
+							   bundle);
 			if (ret)
 				goto destroy_connections;
-
-			count++;
 			break;
 		default:
-			dev_err(&bundle->dev, "Unsupported protocol: 0x%02x\n",
+			dev_err(dev, "Unsupported protocol: 0x%02x\n",
 				cport_desc->protocol_id);
 			ret = -ENODEV;
 			goto destroy_connections;
@@ -970,57 +747,88 @@ static int gb_audio_probe(struct gb_bundle *bundle,
 	}
 
 	/* There must be a management cport */
-	if (!audio->mgmt_connection) {
+	if (!gbcodec->mgmt_connection) {
 		ret = -EINVAL;
-		dev_err(&bundle->dev, "Missing management connection\n");
+		dev_err(dev, "Missing management connection\n");
 		goto destroy_connections;
 	}
 
 	/* Initialize management connection */
-	ret = gbaudio_codec_probe(audio->mgmt_connection);
+	ret = gbaudio_register_codec(gbcodec);
 	if (ret)
 		goto destroy_connections;
 
 	/* Initialize data connections */
-	for (i = 0; i < audio->num_data_connections; i++) {
-		ret = gbaudio_dai_probe(audio->data_connection[i]);
+	list_for_each_entry(dai, &gbcodec->dai_list, list) {
+		ret = gb_connection_enable(dai->connection);
 		if (ret)
 			goto remove_dai;
 	}
 
+	/* inform above layer for uevent */
+	dev_dbg(dev, "Inform set_event:%d to above layer\n", 1);
+	/* prepare for the audio manager */
+	strlcpy(desc.name, gbcodec->name, GB_AUDIO_MANAGER_MODULE_NAME_LEN);
+	desc.slot = 1; /* todo */
+	desc.vid = 2; /* todo */
+	desc.pid = 3; /* todo */
+	desc.cport = gbcodec->dev_id;
+	desc.devices = 0x2; /* todo */
+	gbcodec->manager_id = gb_audio_manager_add(&desc);
+
+	list_add(&gbcodec->list, &gb_codec_list);
+	dev_dbg(dev, "Add GB Audio device:%s\n", gbcodec->name);
+	mutex_unlock(&gb_codec_list_lock);
+
 	return 0;
 
 remove_dai:
-	while (i--)
-		gbaudio_dai_remove(audio->data_connection[i]);
+	list_for_each_entry_safe(dai, _dai, &gbcodec->dai_list, list)
+		gb_connection_disable(dai->connection);
 
-	gbaudio_codec_remove(audio->mgmt_connection);
+	gbaudio_unregister_codec(gbcodec);
 destroy_connections:
-	while (count--)
-		gb_connection_destroy(audio->data_connection[count]);
+	list_for_each_entry_safe(dai, _dai, &gbcodec->dai_list, list) {
+		gb_connection_destroy(dai->connection);
+		list_del(&dai->list);
+		devm_kfree(dev, dai);
+	}
 
-	if (audio->mgmt_connection)
-		gb_connection_destroy(audio->mgmt_connection);
+	if (gbcodec->mgmt_connection)
+		gb_connection_destroy(gbcodec->mgmt_connection);
 
-	kfree(audio);
+	devm_kfree(dev, gbcodec);
+	mutex_unlock(&gb_codec_list_lock);
 
 	return ret;
 }
 
 static void gb_audio_disconnect(struct gb_bundle *bundle)
 {
-	struct gb_audio *audio = greybus_get_drvdata(bundle);
-	int i;
+	struct gbaudio_codec_info *gbcodec = greybus_get_drvdata(bundle);
+	struct gbaudio_dai *dai, *_dai;
 
-	for (i = audio->num_data_connections - 1; i >= 0; i--) {
-		gbaudio_dai_remove(audio->data_connection[i]);
-		gb_connection_destroy(audio->data_connection[i]);
-	}
+	mutex_lock(&gb_codec_list_lock);
+	list_del(&gbcodec->list);
+	/* inform uevent to above layers */
+	gb_audio_manager_remove(gbcodec->manager_id);
 
-	gbaudio_codec_remove(audio->mgmt_connection);
-	gb_connection_destroy(audio->mgmt_connection);
+	mutex_lock(&gbcodec->lock);
+	list_for_each_entry_safe(dai, _dai, &gbcodec->dai_list, list)
+		gb_connection_disable(dai->connection);
+	gbaudio_unregister_codec(gbcodec);
 
-	kfree(audio);
+	list_for_each_entry_safe(dai, _dai, &gbcodec->dai_list, list) {
+		gb_connection_destroy(dai->connection);
+		list_del(&dai->list);
+		devm_kfree(gbcodec->dev, dai);
+	}
+	gb_connection_destroy(gbcodec->mgmt_connection);
+	gbcodec->mgmt_connection = NULL;
+	mutex_unlock(&gbcodec->lock);
+
+	devm_kfree(&bundle->dev, gbcodec);
+	mutex_unlock(&gb_codec_list_lock);
 }
 
 static const struct greybus_bundle_id gb_audio_id_table[] = {

commit 3b710ec06e00ce041606678b25f9c82e95fde813
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Wed Jan 27 11:17:00 2016 +0530

    greybus: audio: Rename Audio class and remove the unused one
    
    There should be a single class macro for Audio and two protocol macros.
    Rename class with value 0x12 as GREYBUS_CLASS_AUDIO and remove the other
    unused class GREYBUS_CLASS_AUDIO_DATA.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Reviewed-by: Johan Hovold <johan@hovoldconsulting.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/audio_codec.c b/drivers/staging/greybus/audio_codec.c
index b2feba8cee14..b43b5432d7a6 100644
--- a/drivers/staging/greybus/audio_codec.c
+++ b/drivers/staging/greybus/audio_codec.c
@@ -1024,7 +1024,7 @@ static void gb_audio_disconnect(struct gb_bundle *bundle)
 }
 
 static const struct greybus_bundle_id gb_audio_id_table[] = {
-	{ GREYBUS_DEVICE_CLASS(GREYBUS_CLASS_AUDIO_MGMT) },
+	{ GREYBUS_DEVICE_CLASS(GREYBUS_CLASS_AUDIO) },
 	{ }
 };
 MODULE_DEVICE_TABLE(greybus, gb_audio_id_table);

commit 35e28794dcddf2eab1d53b9f3bf5a0eeee82e3c9
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Wed Jan 27 16:57:48 2016 +0530

    greybus: audio_codec: convert to bundle driver
    
    Convert the legacy audio management and data protocol drivers to a
    bundle driver.
    
    The Audio bundle driver can support a single management and any number
    of data cports, and so we expect multiple data cports to be present for
    the bundle during initialization.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Reviewed-by: Johan Hovold <johan@hovoldconsulting.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/audio_codec.c b/drivers/staging/greybus/audio_codec.c
index 5fef49552813..b2feba8cee14 100644
--- a/drivers/staging/greybus/audio_codec.c
+++ b/drivers/staging/greybus/audio_codec.c
@@ -15,9 +15,6 @@
 #include "audio_apbridgea.h"
 #include "audio_manager.h"
 
-#define GB_AUDIO_MGMT_DRIVER_NAME	"gb_audio_mgmt"
-#define GB_AUDIO_DATA_DRIVER_NAME	"gb_audio_data"
-
 static DEFINE_MUTEX(gb_codec_list_lock);
 static LIST_HEAD(gb_codec_list);
 
@@ -31,8 +28,8 @@ static int gbcodec_startup(struct snd_pcm_substream *substream,
 	__u16 i2s_port, cportid;
 
 	struct gbaudio_dai *gb_dai;
-	struct gbaudio_codec_info *gb =
-		(struct gbaudio_codec_info *)dev_get_drvdata(dai->dev);
+	struct gb_audio *audio = dev_get_drvdata(dai->dev);
+	struct gbaudio_codec_info *gb = audio->gbcodec;
 
 	/* find the dai */
 	found = 0;
@@ -69,8 +66,8 @@ static void gbcodec_shutdown(struct snd_pcm_substream *substream,
 	__u16 i2s_port, cportid;
 
 	struct gbaudio_dai *gb_dai;
-	struct gbaudio_codec_info *gb =
-		(struct gbaudio_codec_info *)dev_get_drvdata(dai->dev);
+	struct gb_audio *audio = dev_get_drvdata(dai->dev);
+	struct gbaudio_codec_info *gb = audio->gbcodec;
 
 	/* find the dai */
 	found = 0;
@@ -126,8 +123,8 @@ static int gbcodec_hw_params(struct snd_pcm_substream *substream,
 	uint32_t format, rate;
 	uint16_t data_cport;
 	struct gbaudio_dai *gb_dai;
-	struct gbaudio_codec_info *gb =
-		(struct gbaudio_codec_info *)dev_get_drvdata(dai->dev);
+	struct gb_audio *audio = dev_get_drvdata(dai->dev);
+	struct gbaudio_codec_info *gb = audio->gbcodec;
 
 	/* find the dai */
 	found = 0;
@@ -203,8 +200,8 @@ static int gbcodec_prepare(struct snd_pcm_substream *substream,
 	int ret, found;
 	uint16_t data_cport;
 	struct gbaudio_dai *gb_dai;
-	struct gbaudio_codec_info *gb =
-		(struct gbaudio_codec_info *)dev_get_drvdata(dai->dev);
+	struct gb_audio *audio = dev_get_drvdata(dai->dev);
+	struct gbaudio_codec_info *gb = audio->gbcodec;
 
 	/* find the dai */
 	found = 0;
@@ -280,8 +277,8 @@ static int gbcodec_trigger(struct snd_pcm_substream *substream, int cmd,
 	int ret, found;
 	int tx, rx, start, stop;
 	struct gbaudio_dai *gb_dai;
-	struct gbaudio_codec_info *gb =
-		(struct gbaudio_codec_info *)dev_get_drvdata(dai->dev);
+	struct gb_audio *audio = dev_get_drvdata(dai->dev);
+	struct gbaudio_codec_info *gb = audio->gbcodec;
 
 	/* find the dai */
 	found = 0;
@@ -386,7 +383,8 @@ static int gbcodec_write(struct snd_soc_codec *codec, unsigned int reg,
 			 unsigned int value)
 {
 	int ret = 0;
-	struct gbaudio_codec_info *gbcodec = snd_soc_codec_get_drvdata(codec);
+	struct gb_audio *audio = snd_soc_codec_get_drvdata(codec);
+	struct gbaudio_codec_info *gbcodec = audio->gbcodec;
 	u8 *gbcodec_reg = gbcodec->reg;
 
 	if (reg == SND_SOC_NOPM)
@@ -406,7 +404,8 @@ static unsigned int gbcodec_read(struct snd_soc_codec *codec,
 {
 	unsigned int val = 0;
 
-	struct gbaudio_codec_info *gbcodec = snd_soc_codec_get_drvdata(codec);
+	struct gb_audio *audio = snd_soc_codec_get_drvdata(codec);
+	struct gbaudio_codec_info *gbcodec = audio->gbcodec;
 	u8 *gbcodec_reg = gbcodec->reg;
 
 	if (reg == SND_SOC_NOPM)
@@ -524,6 +523,7 @@ static struct gbaudio_codec_info *gbaudio_get_codec(struct device *dev,
 						    int dev_id)
 {
 	struct gbaudio_codec_info *gbcodec;
+	struct gb_audio *audio = dev_get_drvdata(dev);
 
 	gbcodec = gbaudio_find_codec(dev, dev_id);
 	if (gbcodec)
@@ -539,7 +539,7 @@ static struct gbaudio_codec_info *gbaudio_get_codec(struct device *dev,
 	INIT_LIST_HEAD(&gbcodec->codec_ctl_list);
 	INIT_LIST_HEAD(&gbcodec->widget_ctl_list);
 	gbcodec->dev_id = dev_id;
-	dev_set_drvdata(dev, gbcodec);
+	audio->gbcodec = gbcodec;
 	gbcodec->dev = dev;
 	snprintf(gbcodec->name, NAME_SIZE, "%s.%s", dev->driver->name,
 		 dev_name(dev));
@@ -556,12 +556,14 @@ static struct gbaudio_codec_info *gbaudio_get_codec(struct device *dev,
 static void gbaudio_free_codec(struct device *dev,
 			       struct gbaudio_codec_info *gbcodec)
 {
+	struct gb_audio *audio = dev_get_drvdata(dev);
+
 	mutex_lock(&gb_codec_list_lock);
 	if (!gbcodec->mgmt_connection &&
 			list_empty(&gbcodec->dai_list)) {
 		list_del(&gbcodec->list);
 		mutex_unlock(&gb_codec_list_lock);
-		dev_set_drvdata(dev, NULL);
+		audio->gbcodec = NULL;
 		devm_kfree(dev, gbcodec);
 	} else {
 		mutex_unlock(&gb_codec_list_lock);
@@ -633,12 +635,16 @@ static int gbaudio_codec_probe(struct gb_connection *connection)
 
 	gbcodec->mgmt_connection = connection;
 
+	ret = gb_connection_enable(connection);
+	if (ret)
+		goto base_error;
+
 	/* fetch topology data */
 	ret = gb_audio_gb_get_topology(connection, &topology);
 	if (ret) {
 		dev_err(gbcodec->dev,
 			"%d:Error while fetching topology\n", ret);
-		goto base_error;
+		goto err_connection_disable;
 	}
 
 	/* process topology data */
@@ -711,6 +717,8 @@ static int gbaudio_codec_probe(struct gb_connection *connection)
 	gbcodec->topology = NULL;
 topology_error:
 	kfree(topology);
+err_connection_disable:
+	gb_connection_disable(connection);
 base_error:
 	gbcodec->mgmt_connection = NULL;
 	gbaudio_free_codec(dev, gbcodec);
@@ -753,6 +761,7 @@ static void gbaudio_codec_remove(struct gb_connection *connection)
 	dev->driver = NULL;
 	gbaudio_tplg_release(gbcodec);
 	kfree(gbcodec->topology);
+	gb_connection_disable(connection);
 	gbcodec->mgmt_connection = NULL;
 	mutex_lock(&gbcodec->lock);
 	gbcodec->codec_registered = 0;
@@ -760,7 +769,7 @@ static void gbaudio_codec_remove(struct gb_connection *connection)
 	gbaudio_free_codec(dev, gbcodec);
 }
 
-static int gbaudio_codec_report_event_recv(u8 type, struct gb_operation *op)
+static int gbaudio_codec_request_handler(struct gb_operation *op)
 {
 	struct gb_connection *connection = op->connection;
 	struct gb_audio_streaming_event_request *req = op->request->payload;
@@ -772,22 +781,12 @@ static int gbaudio_codec_report_event_recv(u8 type, struct gb_operation *op)
 	return 0;
 }
 
-static struct gb_protocol gb_audio_mgmt_protocol = {
-	.name			= GB_AUDIO_MGMT_DRIVER_NAME,
-	.id			= GREYBUS_PROTOCOL_AUDIO_MGMT,
-	.major			= 0,
-	.minor			= 1,
-	.connection_init	= gbaudio_codec_probe,
-	.connection_exit	= gbaudio_codec_remove,
-	.request_recv		= gbaudio_codec_report_event_recv,
-};
-
 static int gbaudio_dai_probe(struct gb_connection *connection)
 {
 	struct gbaudio_dai *dai;
 	struct device *dev = &connection->bundle->dev;
 	int dev_id = connection->intf->interface_id;
-	struct gbaudio_codec_info *gbcodec = dev_get_drvdata(dev);
+	struct gbaudio_codec_info *gbcodec;
 	struct gb_audio_manager_module_descriptor desc;
 	int ret;
 
@@ -798,12 +797,16 @@ static int gbaudio_dai_probe(struct gb_connection *connection)
 	if (!gbcodec)
 		return -ENOMEM;
 
+	ret = gb_connection_enable(connection);
+	if (ret)
+		goto err_free_codec;
+
 	/* add/update dai_list*/
 	dai = gbaudio_add_dai(gbcodec, connection->intf_cport_id, connection,
 			       NULL);
 	if (!dai) {
 		ret = -ENOMEM;
-		goto err_free_codec;
+		goto err_connection_disable;
 	}
 
 	/* update dai_added count */
@@ -829,6 +832,8 @@ static int gbaudio_dai_probe(struct gb_connection *connection)
 
 	return 0;
 
+err_connection_disable:
+	gb_connection_disable(connection);
 err_free_codec:
 	gbaudio_free_codec(dev, gbcodec);
 	return ret;
@@ -859,10 +864,11 @@ static void gbaudio_dai_remove(struct gb_connection *connection)
 	gbcodec->dai_added--;
 	mutex_unlock(&gbcodec->lock);
 
+	gb_connection_disable(connection);
 	gbaudio_free_codec(dev, gbcodec);
 }
 
-static int gbaudio_dai_report_event_recv(u8 type, struct gb_operation *op)
+static int gbaudio_dai_request_handler(struct gb_operation *op)
 {
 	struct gb_connection *connection = op->connection;
 
@@ -871,50 +877,165 @@ static int gbaudio_dai_report_event_recv(u8 type, struct gb_operation *op)
 	return 0;
 }
 
-static struct gb_protocol gb_audio_data_protocol = {
-	.name			= GB_AUDIO_DATA_DRIVER_NAME,
-	.id			= GREYBUS_PROTOCOL_AUDIO_DATA,
-	.major			= 0,
-	.minor			= 1,
-	.connection_init	= gbaudio_dai_probe,
-	.connection_exit	= gbaudio_dai_remove,
-	.request_recv		= gbaudio_dai_report_event_recv,
-};
+static int gb_audio_add_mgmt_connection(struct gb_audio *audio,
+				struct greybus_descriptor_cport *cport_desc,
+				struct gb_bundle *bundle)
+{
+	struct gb_connection *connection;
 
-/*
- * This is the basic hook get things initialized and registered w/ gb
- */
+	/* Management Cport */
+	if (audio->mgmt_connection) {
+		dev_err(&bundle->dev,
+			"Can't have multiple Management connections\n");
+		return -ENODEV;
+	}
+
+	connection = gb_connection_create(bundle, le16_to_cpu(cport_desc->id),
+					  gbaudio_codec_request_handler);
+	if (IS_ERR(connection))
+		return PTR_ERR(connection);
+
+	connection->private = audio;
+	audio->mgmt_connection = connection;
+
+	return 0;
+}
+
+static int gb_audio_add_data_connection(struct gb_audio *audio,
+				struct greybus_descriptor_cport *cport_desc,
+				struct gb_bundle *bundle, int index)
+{
+	struct gb_connection *connection;
+
+	connection = gb_connection_create(bundle, le16_to_cpu(cport_desc->id),
+					  gbaudio_dai_request_handler);
+	if (IS_ERR(connection))
+		return PTR_ERR(connection);
+
+	connection->private = audio;
+	audio->data_connection[index] = connection;
+
+	return 0;
+}
 
-static int __init gb_audio_protocol_init(void)
+static int gb_audio_probe(struct gb_bundle *bundle,
+			  const struct greybus_bundle_id *id)
 {
-	int err;
+	struct greybus_descriptor_cport *cport_desc;
+	struct gb_audio *audio;
+	int ret, i;
+	int count = bundle->num_cports - 1;
+
+	/* There should be at least one Management and one Data cport */
+	if (bundle->num_cports < 2)
+		return -ENODEV;
 
-	err = gb_protocol_register(&gb_audio_mgmt_protocol);
-	if (err) {
-		pr_err("Can't register i2s mgmt protocol driver: %d\n", -err);
-		return err;
+	/*
+	 * There can be only one Management connection and any number of data
+	 * connections.
+	 */
+	audio = kzalloc(sizeof(*audio) +
+			count * sizeof(*audio->data_connection), GFP_KERNEL);
+	if (!audio)
+		return -ENOMEM;
+
+	audio->num_data_connections = count;
+	greybus_set_drvdata(bundle, audio);
+
+	/* Create all connections */
+	for (count = 0, i = 0; i < bundle->num_cports; i++) {
+		cport_desc = &bundle->cport_desc[i];
+
+		switch (cport_desc->protocol_id) {
+		case GREYBUS_PROTOCOL_AUDIO_MGMT:
+			ret = gb_audio_add_mgmt_connection(audio, cport_desc,
+							   bundle);
+			if (ret)
+				goto destroy_connections;
+			break;
+		case GREYBUS_PROTOCOL_AUDIO_DATA:
+			ret = gb_audio_add_data_connection(audio, cport_desc,
+							   bundle, count);
+			if (ret)
+				goto destroy_connections;
+
+			count++;
+			break;
+		default:
+			dev_err(&bundle->dev, "Unsupported protocol: 0x%02x\n",
+				cport_desc->protocol_id);
+			ret = -ENODEV;
+			goto destroy_connections;
+		}
 	}
 
-	err = gb_protocol_register(&gb_audio_data_protocol);
-	if (err) {
-		pr_err("Can't register Audio protocol driver: %d\n", -err);
-		goto err_unregister_audio_mgmt;
+	/* There must be a management cport */
+	if (!audio->mgmt_connection) {
+		ret = -EINVAL;
+		dev_err(&bundle->dev, "Missing management connection\n");
+		goto destroy_connections;
+	}
+
+	/* Initialize management connection */
+	ret = gbaudio_codec_probe(audio->mgmt_connection);
+	if (ret)
+		goto destroy_connections;
+
+	/* Initialize data connections */
+	for (i = 0; i < audio->num_data_connections; i++) {
+		ret = gbaudio_dai_probe(audio->data_connection[i]);
+		if (ret)
+			goto remove_dai;
 	}
 
 	return 0;
 
-err_unregister_audio_mgmt:
-	gb_protocol_deregister(&gb_audio_mgmt_protocol);
-	return err;
+remove_dai:
+	while (i--)
+		gbaudio_dai_remove(audio->data_connection[i]);
+
+	gbaudio_codec_remove(audio->mgmt_connection);
+destroy_connections:
+	while (count--)
+		gb_connection_destroy(audio->data_connection[count]);
+
+	if (audio->mgmt_connection)
+		gb_connection_destroy(audio->mgmt_connection);
+
+	kfree(audio);
+
+	return ret;
 }
-module_init(gb_audio_protocol_init);
 
-static void __exit gb_audio_protocol_exit(void)
+static void gb_audio_disconnect(struct gb_bundle *bundle)
 {
-	gb_protocol_deregister(&gb_audio_data_protocol);
-	gb_protocol_deregister(&gb_audio_mgmt_protocol);
+	struct gb_audio *audio = greybus_get_drvdata(bundle);
+	int i;
+
+	for (i = audio->num_data_connections - 1; i >= 0; i--) {
+		gbaudio_dai_remove(audio->data_connection[i]);
+		gb_connection_destroy(audio->data_connection[i]);
+	}
+
+	gbaudio_codec_remove(audio->mgmt_connection);
+	gb_connection_destroy(audio->mgmt_connection);
+
+	kfree(audio);
 }
-module_exit(gb_audio_protocol_exit);
+
+static const struct greybus_bundle_id gb_audio_id_table[] = {
+	{ GREYBUS_DEVICE_CLASS(GREYBUS_CLASS_AUDIO_MGMT) },
+	{ }
+};
+MODULE_DEVICE_TABLE(greybus, gb_audio_id_table);
+
+static struct greybus_driver gb_audio_driver = {
+	.name		= "gb-audio",
+	.probe		= gb_audio_probe,
+	.disconnect	= gb_audio_disconnect,
+	.id_table	= gb_audio_id_table,
+};
+module_greybus_driver(gb_audio_driver);
 
 MODULE_DESCRIPTION("Greybus Audio codec driver");
 MODULE_AUTHOR("Vaibhav Agarwal <vaibhav.agarwal@linaro.org>");

commit 4b27be1223b048322398e04fcebef7f85c0dac0d
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Wed Jan 27 11:16:58 2016 +0530

    greybus: audio_codec: Free gccodec on dia probe failure
    
    We aren't freeing the codec, that we allocated before failing to probe
    the connection. Free it.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Reviewed-by: Johan Hovold <johan@hovoldconsulting.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/audio_codec.c b/drivers/staging/greybus/audio_codec.c
index a7ccaaad5281..5fef49552813 100644
--- a/drivers/staging/greybus/audio_codec.c
+++ b/drivers/staging/greybus/audio_codec.c
@@ -789,6 +789,7 @@ static int gbaudio_dai_probe(struct gb_connection *connection)
 	int dev_id = connection->intf->interface_id;
 	struct gbaudio_codec_info *gbcodec = dev_get_drvdata(dev);
 	struct gb_audio_manager_module_descriptor desc;
+	int ret;
 
 	dev_dbg(dev, "Add DAI device:%d:%s\n", dev_id, dev_name(dev));
 
@@ -800,8 +801,10 @@ static int gbaudio_dai_probe(struct gb_connection *connection)
 	/* add/update dai_list*/
 	dai = gbaudio_add_dai(gbcodec, connection->intf_cport_id, connection,
 			       NULL);
-	if (!dai)
-		return -ENOMEM;
+	if (!dai) {
+		ret = -ENOMEM;
+		goto err_free_codec;
+	}
 
 	/* update dai_added count */
 	mutex_lock(&gbcodec->lock);
@@ -825,6 +828,10 @@ static int gbaudio_dai_probe(struct gb_connection *connection)
 	mutex_unlock(&gbcodec->lock);
 
 	return 0;
+
+err_free_codec:
+	gbaudio_free_codec(dev, gbcodec);
+	return ret;
 }
 
 static void gbaudio_dai_remove(struct gb_connection *connection)

commit 2df6396160b019d992241e2db8a6d5a15f654e69
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Wed Jan 27 11:16:57 2016 +0530

    greybus: audio_codec: Free gccodec on codec probe failure
    
    We aren't freeing the codec, that we allocated before failing to probe
    the connection. Free it.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Reviewed-by: Johan Hovold <johan@hovoldconsulting.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/audio_codec.c b/drivers/staging/greybus/audio_codec.c
index 1f39c9cd1aee..a7ccaaad5281 100644
--- a/drivers/staging/greybus/audio_codec.c
+++ b/drivers/staging/greybus/audio_codec.c
@@ -713,6 +713,7 @@ static int gbaudio_codec_probe(struct gb_connection *connection)
 	kfree(topology);
 base_error:
 	gbcodec->mgmt_connection = NULL;
+	gbaudio_free_codec(dev, gbcodec);
 	return ret;
 }
 

commit a547deb5105b583138e74e882b1e2aae1f76dc9c
Author: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
Date:   Thu Jan 21 22:33:13 2016 +0530

    greybus: audio_codec: update codec_name as per driver->name
    
    Originally, driver->name was not poluated from GB and thus
    manually set from audio_codec driver as a hack.
    This is no more required.
    Another patch already removes that hack.
    
    Now, with new driver->name as "legacy.<id-bundle.interface>"
    codec is registered with different name.
    So, during DAI link registration as well it needs modification.
    
    Signed-off-by: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/audio_codec.c b/drivers/staging/greybus/audio_codec.c
index 5c02b6534ab2..1f39c9cd1aee 100644
--- a/drivers/staging/greybus/audio_codec.c
+++ b/drivers/staging/greybus/audio_codec.c
@@ -541,7 +541,8 @@ static struct gbaudio_codec_info *gbaudio_get_codec(struct device *dev,
 	gbcodec->dev_id = dev_id;
 	dev_set_drvdata(dev, gbcodec);
 	gbcodec->dev = dev;
-	strlcpy(gbcodec->name, dev_name(dev), NAME_SIZE);
+	snprintf(gbcodec->name, NAME_SIZE, "%s.%s", dev->driver->name,
+		 dev_name(dev));
 
 	mutex_lock(&gb_codec_list_lock);
 	list_add(&gbcodec->list, &gb_codec_list);

commit 4b874134284b1dbb340f063fe0cf5141ffd416b1
Author: Greg Kroah-Hartman <gregkh@google.com>
Date:   Wed Jan 20 14:41:40 2016 -0800

    greybus: audio_codec: Don't be tricky with the driver model
    
    With the recent changes by Johan to the driver model of the greybus
    code, the audio_codec no longer should need to provide a "dummy" driver
    when registering the codec.  In fact, having it there causes the greybus
    core to crash when inserting the module.  Removing it all fixes the
    crash.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/audio_codec.c b/drivers/staging/greybus/audio_codec.c
index 79f2baf607f4..5c02b6534ab2 100644
--- a/drivers/staging/greybus/audio_codec.c
+++ b/drivers/staging/greybus/audio_codec.c
@@ -571,13 +571,6 @@ static void gbaudio_free_codec(struct device *dev,
  * This is the basic hook get things initialized and registered w/ gb
  */
 
-/*
- * GB codec module driver ops
- */
-struct device_driver gb_codec_driver = {
-	.owner = THIS_MODULE,
-};
-
 /* XXX
  * since BE DAI path is not yet properly closed from above layer,
  * dsp dai.mi2s_dai_data.status_mask is still set to STATUS_PORT_STARTED
@@ -625,7 +618,6 @@ static void gb_audio_cleanup(struct gbaudio_codec_info *gb)
 static int gbaudio_codec_probe(struct gb_connection *connection)
 {
 	int ret, i;
-	char *driver_name;
 	struct gbaudio_codec_info *gbcodec;
 	struct gb_audio_topology *topology;
 	struct gb_audio_manager_module_descriptor desc;
@@ -669,13 +661,6 @@ static int gbaudio_codec_probe(struct gb_connection *connection)
 	for (i = 0; i < gbcodec->num_dais; i++)
 		gbcodec->dais[i].ops = &gbcodec_dai_ops;
 
-	/* FIXME */
-	driver_name = devm_kzalloc(dev, NAME_SIZE, GFP_KERNEL);
-	strlcpy(driver_name, gbcodec->name, NAME_SIZE);
-	gb_codec_driver.name = strsep(&driver_name, ".");
-	dev_dbg(dev, "driver.name:%s\n", gb_codec_driver.name);
-	dev->driver = &gb_codec_driver;
-
 	/* register codec */
 	ret = snd_soc_register_codec(dev, &soc_codec_dev_gbcodec,
 				     gbcodec->dais, 1);

commit 83ec628386aee5e14fe1be3e27e84124dfa7b165
Author: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
Date:   Wed Jan 13 14:07:56 2016 -0700

    greybus: audio: Enable codec module detection on different slots
    
    driver_name associated with dev_name was hard coded earlier.
    This limits, audio codec module to be detected on Port#5 only.
    
    Now, driver_name is generated dynamically based on dev_name.
    This enables codec module detection on any 1x2 slot.
    
    Also, Update dev_id based on slot number, instead of bundle->id.
    bundle->id is not unique for multiple modules added, thus now
    using slot number for unique identification.
    
    Signed-off-by: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
    Signed-off-by: Mark Greer <mgreer@animalcreek.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/audio_codec.c b/drivers/staging/greybus/audio_codec.c
index 2b4fcbedd161..79f2baf607f4 100644
--- a/drivers/staging/greybus/audio_codec.c
+++ b/drivers/staging/greybus/audio_codec.c
@@ -575,7 +575,6 @@ static void gbaudio_free_codec(struct device *dev,
  * GB codec module driver ops
  */
 struct device_driver gb_codec_driver = {
-	.name = "1-8",
 	.owner = THIS_MODULE,
 };
 
@@ -626,11 +625,12 @@ static void gb_audio_cleanup(struct gbaudio_codec_info *gb)
 static int gbaudio_codec_probe(struct gb_connection *connection)
 {
 	int ret, i;
+	char *driver_name;
 	struct gbaudio_codec_info *gbcodec;
 	struct gb_audio_topology *topology;
 	struct gb_audio_manager_module_descriptor desc;
 	struct device *dev = &connection->bundle->dev;
-	int dev_id = connection->bundle->id;
+	int dev_id = connection->intf->interface_id;
 
 	dev_dbg(dev, "Add device:%d:%s\n", dev_id, dev_name(dev));
 	/* get gbcodec data */
@@ -670,6 +670,10 @@ static int gbaudio_codec_probe(struct gb_connection *connection)
 		gbcodec->dais[i].ops = &gbcodec_dai_ops;
 
 	/* FIXME */
+	driver_name = devm_kzalloc(dev, NAME_SIZE, GFP_KERNEL);
+	strlcpy(driver_name, gbcodec->name, NAME_SIZE);
+	gb_codec_driver.name = strsep(&driver_name, ".");
+	dev_dbg(dev, "driver.name:%s\n", gb_codec_driver.name);
 	dev->driver = &gb_codec_driver;
 
 	/* register codec */
@@ -730,7 +734,7 @@ static void gbaudio_codec_remove(struct gb_connection *connection)
 {
 	struct gbaudio_codec_info *gbcodec;
 	struct device *dev = &connection->bundle->dev;
-	int dev_id = connection->bundle->id;
+	int dev_id = connection->intf->interface_id;
 
 	dev_dbg(dev, "Remove device:%d:%s\n", dev_id, dev_name(dev));
 
@@ -795,7 +799,7 @@ static int gbaudio_dai_probe(struct gb_connection *connection)
 {
 	struct gbaudio_dai *dai;
 	struct device *dev = &connection->bundle->dev;
-	int dev_id = connection->bundle->id;
+	int dev_id = connection->intf->interface_id;
 	struct gbaudio_codec_info *gbcodec = dev_get_drvdata(dev);
 	struct gb_audio_manager_module_descriptor desc;
 
@@ -839,7 +843,7 @@ static int gbaudio_dai_probe(struct gb_connection *connection)
 static void gbaudio_dai_remove(struct gb_connection *connection)
 {
 	struct device *dev = &connection->bundle->dev;
-	int dev_id = connection->bundle->id;
+	int dev_id = connection->intf->interface_id;
 	struct gbaudio_codec_info *gbcodec;
 
 	dev_dbg(dev, "Remove DAI device:%d:%s\n", dev_id, dev_name(dev));

commit 25de3491f11064845a45606fa5828a200ecf8c53
Author: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
Date:   Wed Jan 13 14:07:55 2016 -0700

    greybus: audio: Cleanup GB protocol connections in case of abrupt codec removal
    
    We need to clean up GB protocl connections, otherwise successive
    codec insertions fails repeatedly.
    
    NOTE: As per suggestion, since codec is already removed, one should
    not trigger any GB command. It'll cause a delay of atleast TIMEOUT
    value.
    HOwever, failing to cleanup GB protocol, causes successive module
    insertion to fail
    
    Signed-off-by: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
    Signed-off-by: Mark Greer <mgreer@animalcreek.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/audio_codec.c b/drivers/staging/greybus/audio_codec.c
index 93906c8128de..2b4fcbedd161 100644
--- a/drivers/staging/greybus/audio_codec.c
+++ b/drivers/staging/greybus/audio_codec.c
@@ -56,6 +56,9 @@ static int gbcodec_startup(struct snd_pcm_substream *substream,
 	dev_dbg(dai->dev, "Register %s:%d DAI, ret:%d\n", dai->name, cportid,
 		ret);
 
+	if (!ret)
+		atomic_inc(&gb->users);
+
 	return ret;
 }
 
@@ -83,6 +86,8 @@ static void gbcodec_shutdown(struct snd_pcm_substream *substream,
 		return;
 	}
 
+	atomic_dec(&gb->users);
+
 	/* deactivate rx/tx */
 	cportid = gb_dai->connection->intf_cport_id;
 
@@ -428,6 +433,7 @@ static struct snd_soc_codec_driver soc_codec_dev_gbcodec = {
 	.reg_word_size = 1,
 
 	.idle_bias_off = true,
+	.ignore_pmdown_time = 1,
 };
 
 /*
@@ -573,6 +579,50 @@ struct device_driver gb_codec_driver = {
 	.owner = THIS_MODULE,
 };
 
+/* XXX
+ * since BE DAI path is not yet properly closed from above layer,
+ * dsp dai.mi2s_dai_data.status_mask is still set to STATUS_PORT_STARTED
+ * this causes immediate playback/capture to fail in case relevant mixer
+ * control is not turned OFF
+ * user need to try once again after failure to recover DSP state.
+ */
+static void gb_audio_cleanup(struct gbaudio_codec_info *gb)
+{
+	int cportid, ret;
+	struct gbaudio_dai *gb_dai;
+	struct gb_connection *connection;
+	struct device *dev = gb->dev;
+
+	list_for_each_entry(gb_dai, &gb->dai_list, list) {
+		/*
+		 * In case of BE dailink, need to deactivate APBridge
+		 * manually
+		 */
+		if (gbaudio_dailink.no_pcm && atomic_read(&gb->users)) {
+			connection = gb_dai->connection;
+			/* PB active */
+			ret = gb_audio_apbridgea_stop_tx(connection, 0);
+			if (ret)
+				dev_info(dev, "%d:Failed during APBridge stop_tx\n",
+					 ret);
+			cportid = connection->intf_cport_id;
+			ret = gb_audio_gb_deactivate_tx(gb->mgmt_connection,
+							cportid);
+			if (ret)
+				dev_info(dev,
+					 "%d:Failed during deactivate_tx\n",
+					 ret);
+			cportid = connection->hd_cport_id;
+			ret = gb_audio_apbridgea_unregister_cport(connection, 0,
+								  cportid);
+			if (ret)
+				dev_info(dev, "%d:Failed during unregister cport\n",
+					 ret);
+			atomic_dec(&gb->users);
+		}
+	}
+}
+
 static int gbaudio_codec_probe(struct gb_connection *connection)
 {
 	int ret, i;
@@ -641,6 +691,9 @@ static int gbaudio_codec_probe(struct gb_connection *connection)
 	mutex_lock(&gbcodec->lock);
 	gbcodec->codec_registered = 1;
 
+	/* codec cleanup related */
+	atomic_set(&gbcodec->users, 0);
+
 	/* inform above layer for uevent */
 	if (!gbcodec->set_uevent &&
 	    (gbcodec->dai_added == gbcodec->num_dais)) {
@@ -696,6 +749,11 @@ static void gbaudio_codec_remove(struct gb_connection *connection)
 	}
 	mutex_unlock(&gbcodec->lock);
 
+	if (atomic_read(&gbcodec->users)) {
+		dev_err(dev, "Cleanup Error: BE stream not yet closed\n");
+		gb_audio_cleanup(gbcodec);
+	}
+
 	msm8994_remove_dailink("msm8994-tomtom-mtp-snd-card", &gbaudio_dailink,
 			       1);
 	gbaudio_remove_dailinks(gbcodec);

commit 17247da52ee8694429e089f452dd14f4dbda9f06
Author: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
Date:   Wed Jan 13 14:07:53 2016 -0700

    greybus: audio: Report uevent on GB codec module insertion/removal
    
    GB-Audio-manager module is currently used to report uevent
    to above layer in response to any codec module inserted or
    removed.
    
    Signed-off-by: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
    Signed-off-by: Mark Greer <mgreer@animalcreek.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/audio_codec.c b/drivers/staging/greybus/audio_codec.c
index a03caa09a68a..93906c8128de 100644
--- a/drivers/staging/greybus/audio_codec.c
+++ b/drivers/staging/greybus/audio_codec.c
@@ -13,6 +13,7 @@
 
 #include "audio_codec.h"
 #include "audio_apbridgea.h"
+#include "audio_manager.h"
 
 #define GB_AUDIO_MGMT_DRIVER_NAME	"gb_audio_mgmt"
 #define GB_AUDIO_DATA_DRIVER_NAME	"gb_audio_data"
@@ -577,6 +578,7 @@ static int gbaudio_codec_probe(struct gb_connection *connection)
 	int ret, i;
 	struct gbaudio_codec_info *gbcodec;
 	struct gb_audio_topology *topology;
+	struct gb_audio_manager_module_descriptor desc;
 	struct device *dev = &connection->bundle->dev;
 	int dev_id = connection->bundle->id;
 
@@ -639,6 +641,21 @@ static int gbaudio_codec_probe(struct gb_connection *connection)
 	mutex_lock(&gbcodec->lock);
 	gbcodec->codec_registered = 1;
 
+	/* inform above layer for uevent */
+	if (!gbcodec->set_uevent &&
+	    (gbcodec->dai_added == gbcodec->num_dais)) {
+		dev_dbg(dev, "Inform set_event:%d to above layer\n", 1);
+		/* prepare for the audio manager */
+		strlcpy(desc.name, gbcodec->name,
+			GB_AUDIO_MANAGER_MODULE_NAME_LEN); /* todo */
+		desc.slot = 1; /* todo */
+		desc.vid = 2; /* todo */
+		desc.pid = 3; /* todo */
+		desc.cport = gbcodec->dev_id;
+		desc.devices = 0x2; /* todo */
+		gbcodec->manager_id = gb_audio_manager_add(&desc);
+		gbcodec->set_uevent = 1;
+	}
 	mutex_unlock(&gbcodec->lock);
 
 	return ret;
@@ -669,6 +686,16 @@ static void gbaudio_codec_remove(struct gb_connection *connection)
 	if (!gbcodec)
 		return;
 
+	/* inform uevent to above layers */
+	mutex_lock(&gbcodec->lock);
+	if (gbcodec->set_uevent) {
+		/* notify the audio manager */
+		dev_dbg(dev, "Inform set_event:%d to above layer\n", 0);
+		gb_audio_manager_remove(gbcodec->manager_id);
+		gbcodec->set_uevent = 0;
+	}
+	mutex_unlock(&gbcodec->lock);
+
 	msm8994_remove_dailink("msm8994-tomtom-mtp-snd-card", &gbaudio_dailink,
 			       1);
 	gbaudio_remove_dailinks(gbcodec);
@@ -712,6 +739,7 @@ static int gbaudio_dai_probe(struct gb_connection *connection)
 	struct device *dev = &connection->bundle->dev;
 	int dev_id = connection->bundle->id;
 	struct gbaudio_codec_info *gbcodec = dev_get_drvdata(dev);
+	struct gb_audio_manager_module_descriptor desc;
 
 	dev_dbg(dev, "Add DAI device:%d:%s\n", dev_id, dev_name(dev));
 
@@ -729,6 +757,22 @@ static int gbaudio_dai_probe(struct gb_connection *connection)
 	/* update dai_added count */
 	mutex_lock(&gbcodec->lock);
 	gbcodec->dai_added++;
+
+	/* inform above layer for uevent */
+	if (!gbcodec->set_uevent && gbcodec->codec_registered &&
+	    (gbcodec->dai_added == gbcodec->num_dais)) {
+		/* prepare for the audio manager */
+		dev_dbg(dev, "Inform set_event:%d to above layer\n", 1);
+		strlcpy(desc.name, gbcodec->name,
+			GB_AUDIO_MANAGER_MODULE_NAME_LEN); /* todo */
+		desc.slot = 1; /* todo */
+		desc.vid = 2; /* todo */
+		desc.pid = 3; /* todo */
+		desc.cport = gbcodec->dev_id;
+		desc.devices = 0x2; /* todo */
+		gbcodec->manager_id = gb_audio_manager_add(&desc);
+		gbcodec->set_uevent = 1;
+	}
 	mutex_unlock(&gbcodec->lock);
 
 	return 0;
@@ -749,6 +793,12 @@ static void gbaudio_dai_remove(struct gb_connection *connection)
 
 	/* inform uevent to above layers */
 	mutex_lock(&gbcodec->lock);
+	if (gbcodec->set_uevent) {
+		/* notify the audio manager */
+		dev_dbg(dev, "Inform set_event:%d to above layer\n", 0);
+		gb_audio_manager_remove(gbcodec->manager_id);
+		gbcodec->set_uevent = 0;
+	}
 	/* update dai_added count */
 	gbcodec->dai_added--;
 	mutex_unlock(&gbcodec->lock);

commit b7f0088df7369bafc5029be7c0085961904086fc
Author: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
Date:   Wed Jan 13 14:07:52 2016 -0700

    greybus: audio: Add GB Audio class protocol functionality in GB codec DAI ops
    
    GB Audio class driver provides APIs to configure GB codec module.
    This patch adds relevant operations in DAI ops callback functions to
    configure codec module as per DAPM sequence triggered.
    
    Signed-off-by: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
    Signed-off-by: Mark Greer <mgreer@animalcreek.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/audio_codec.c b/drivers/staging/greybus/audio_codec.c
index 239a9b6b947c..a03caa09a68a 100644
--- a/drivers/staging/greybus/audio_codec.c
+++ b/drivers/staging/greybus/audio_codec.c
@@ -12,6 +12,7 @@
 #include <sound/msm-dynamic-dailink.h>
 
 #include "audio_codec.h"
+#include "audio_apbridgea.h"
 
 #define GB_AUDIO_MGMT_DRIVER_NAME	"gb_audio_mgmt"
 #define GB_AUDIO_DATA_DRIVER_NAME	"gb_audio_data"
@@ -19,28 +20,325 @@
 static DEFINE_MUTEX(gb_codec_list_lock);
 static LIST_HEAD(gb_codec_list);
 
+/*
+ * codec DAI ops
+ */
 static int gbcodec_startup(struct snd_pcm_substream *substream,
 			   struct snd_soc_dai *dai)
 {
-	return 0;
+	int ret, found;
+	__u16 i2s_port, cportid;
+
+	struct gbaudio_dai *gb_dai;
+	struct gbaudio_codec_info *gb =
+		(struct gbaudio_codec_info *)dev_get_drvdata(dai->dev);
+
+	/* find the dai */
+	found = 0;
+	list_for_each_entry(gb_dai, &gb->dai_list, list) {
+		if (!strncmp(gb_dai->name, dai->name, NAME_SIZE)) {
+			found = 1;
+			break;
+		}
+	}
+
+	if (!found) {
+		dev_err(dai->dev, "%s: DAI not registered\n", dai->name);
+		return -EINVAL;
+	}
+
+	/* register cport */
+	i2s_port = 0;	/* fixed for now */
+	cportid = gb_dai->connection->hd_cport_id;
+	ret = gb_audio_apbridgea_register_cport(gb_dai->connection, i2s_port,
+						cportid);
+	dev_dbg(dai->dev, "Register %s:%d DAI, ret:%d\n", dai->name, cportid,
+		ret);
+
+	return ret;
 }
 
 static void gbcodec_shutdown(struct snd_pcm_substream *substream,
 			     struct snd_soc_dai *dai)
 {
+	int ret, found;
+	__u16 i2s_port, cportid;
+
+	struct gbaudio_dai *gb_dai;
+	struct gbaudio_codec_info *gb =
+		(struct gbaudio_codec_info *)dev_get_drvdata(dai->dev);
+
+	/* find the dai */
+	found = 0;
+	list_for_each_entry(gb_dai, &gb->dai_list, list) {
+		if (!strncmp(gb_dai->name, dai->name, NAME_SIZE)) {
+			found = 1;
+			break;
+		}
+	}
+
+	if (!found) {
+		dev_err(dai->dev, "%s: DAI not registered\n", dai->name);
+		return;
+	}
+
+	/* deactivate rx/tx */
+	cportid = gb_dai->connection->intf_cport_id;
+
+	switch (substream->stream) {
+	case SNDRV_PCM_STREAM_CAPTURE:
+		ret = gb_audio_gb_deactivate_rx(gb->mgmt_connection, cportid);
+		break;
+	case SNDRV_PCM_STREAM_PLAYBACK:
+		ret = gb_audio_gb_deactivate_tx(gb->mgmt_connection, cportid);
+		break;
+	default:
+		dev_err(dai->dev, "Invalid stream type during shutdown\n");
+		return;
+	}
+
+	if (ret)
+		dev_err(dai->dev, "%d:Error during deactivate\n", ret);
+
+	/* un register cport */
+	i2s_port = 0;	/* fixed for now */
+	ret = gb_audio_apbridgea_unregister_cport(gb_dai->connection, i2s_port,
+					gb_dai->connection->hd_cport_id);
+
+	dev_dbg(dai->dev, "Unregister %s:%d DAI, ret:%d\n", dai->name,
+		gb_dai->connection->hd_cport_id, ret);
+
+	return;
 }
 
 static int gbcodec_hw_params(struct snd_pcm_substream *substream,
 			     struct snd_pcm_hw_params *hwparams,
 			     struct snd_soc_dai *dai)
 {
-	return 0;
+	int ret, found;
+	uint8_t sig_bits, channels;
+	uint32_t format, rate;
+	uint16_t data_cport;
+	struct gbaudio_dai *gb_dai;
+	struct gbaudio_codec_info *gb =
+		(struct gbaudio_codec_info *)dev_get_drvdata(dai->dev);
+
+	/* find the dai */
+	found = 0;
+	list_for_each_entry(gb_dai, &gb->dai_list, list) {
+		if (!strncmp(gb_dai->name, dai->name, NAME_SIZE)) {
+			found = 1;
+			break;
+		}
+	}
+
+	if (!found) {
+		dev_err(dai->dev, "%s: DAI not registered\n", dai->name);
+		return -EINVAL;
+	}
+
+	/*
+	 * assuming, currently only 48000 Hz, 16BIT_LE, stereo
+	 * is supported, validate params before configuring codec
+	 */
+	if (params_channels(hwparams) != 2) {
+		dev_err(dai->dev, "Invalid channel count:%d\n",
+			params_channels(hwparams));
+		return -EINVAL;
+	}
+	channels = params_channels(hwparams);
+
+	if (params_rate(hwparams) != 48000) {
+		dev_err(dai->dev, "Invalid sampling rate:%d\n",
+			params_rate(hwparams));
+		return -EINVAL;
+	}
+	rate = GB_AUDIO_PCM_RATE_48000;
+
+	if (params_format(hwparams) != SNDRV_PCM_FORMAT_S16_LE) {
+		dev_err(dai->dev, "Invalid format:%d\n",
+			params_format(hwparams));
+		return -EINVAL;
+	}
+	format = GB_AUDIO_PCM_FMT_S16_LE;
+
+	data_cport = gb_dai->connection->intf_cport_id;
+	/* XXX check impact of sig_bit
+	 * it should not change ideally
+	 */
+
+	dev_dbg(dai->dev, "cport:%d, rate:%d, channel %d, format %d, sig_bits:%d\n",
+		data_cport, rate, channels, format, sig_bits);
+	ret = gb_audio_gb_set_pcm(gb->mgmt_connection, data_cport, format,
+				  rate, channels, sig_bits);
+	if (ret) {
+		dev_err(dai->dev, "%d: Error during set_pcm\n", ret);
+		return ret;
+	}
+
+	/*
+	 * XXX need to check if
+	 * set config is always required
+	 * check for mclk_freq as well
+	 */
+	ret = gb_audio_apbridgea_set_config(gb_dai->connection, 0,
+					    AUDIO_APBRIDGEA_PCM_FMT_16,
+					    AUDIO_APBRIDGEA_PCM_RATE_48000,
+					    6144000);
+	if (ret)
+		dev_err(dai->dev, "%d: Error during set_config\n", ret);
+
+	return ret;
 }
 
 static int gbcodec_prepare(struct snd_pcm_substream *substream,
 			   struct snd_soc_dai *dai)
 {
-	return 0;
+	int ret, found;
+	uint16_t data_cport;
+	struct gbaudio_dai *gb_dai;
+	struct gbaudio_codec_info *gb =
+		(struct gbaudio_codec_info *)dev_get_drvdata(dai->dev);
+
+	/* find the dai */
+	found = 0;
+	list_for_each_entry(gb_dai, &gb->dai_list, list) {
+		if (!strncmp(gb_dai->name, dai->name, NAME_SIZE)) {
+			found = 1;
+			break;
+		}
+	}
+
+	if (!found) {
+		dev_err(dai->dev, "%s: DAI not registered\n", dai->name);
+		return -EINVAL;
+	}
+
+	/* deactivate rx/tx */
+	data_cport = gb_dai->connection->intf_cport_id;
+
+	switch (substream->stream) {
+	case SNDRV_PCM_STREAM_CAPTURE:
+		ret = gb_audio_gb_set_rx_data_size(gb->mgmt_connection,
+						   data_cport, 192);
+		if (ret) {
+			dev_err(dai->dev,
+				"%d:Error during set_rx_data_size, cport:%d\n",
+				ret, data_cport);
+			return ret;
+		}
+		ret = gb_audio_apbridgea_set_rx_data_size(gb_dai->connection, 0,
+							  192);
+		if (ret) {
+			dev_err(dai->dev,
+				"%d:Error during apbridgea_set_rx_data_size\n",
+				ret);
+			return ret;
+		}
+		ret = gb_audio_gb_activate_rx(gb->mgmt_connection, data_cport);
+		break;
+	case SNDRV_PCM_STREAM_PLAYBACK:
+		ret = gb_audio_gb_set_tx_data_size(gb->mgmt_connection,
+						   data_cport, 192);
+		if (ret) {
+			dev_err(dai->dev,
+				"%d:Error during module set_tx_data_size, cport:%d\n",
+				ret, data_cport);
+			return ret;
+		}
+		ret = gb_audio_apbridgea_set_tx_data_size(gb_dai->connection, 0,
+							  192);
+		if (ret) {
+			dev_err(dai->dev,
+				"%d:Error during apbridgea set_tx_data_size, cport\n",
+				ret);
+			return ret;
+		}
+		ret = gb_audio_gb_activate_tx(gb->mgmt_connection, data_cport);
+		break;
+	default:
+		dev_err(dai->dev, "Invalid stream type %d during prepare\n",
+			substream->stream);
+		return -EINVAL;
+	}
+
+	if (ret)
+		dev_err(dai->dev, "%d: Error during activate stream\n", ret);
+
+	return ret;
+}
+
+static int gbcodec_trigger(struct snd_pcm_substream *substream, int cmd,
+		struct snd_soc_dai *dai)
+{
+	int ret, found;
+	int tx, rx, start, stop;
+	struct gbaudio_dai *gb_dai;
+	struct gbaudio_codec_info *gb =
+		(struct gbaudio_codec_info *)dev_get_drvdata(dai->dev);
+
+	/* find the dai */
+	found = 0;
+	list_for_each_entry(gb_dai, &gb->dai_list, list) {
+		if (!strncmp(gb_dai->name, dai->name, NAME_SIZE)) {
+			found = 1;
+			break;
+		}
+	}
+
+	if (!found) {
+		dev_err(dai->dev, "%s: DAI not registered\n", dai->name);
+		return -EINVAL;
+	}
+
+	tx = rx = start = stop = 0;
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		start = 1;
+		break;
+	case SNDRV_PCM_TRIGGER_STOP:
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		stop = 1;
+		break;
+	default:
+		dev_err(dai->dev, "Invalid tigger cmd:%d\n", cmd);
+		return -EINVAL;
+	}
+
+	switch (substream->stream) {
+	case SNDRV_PCM_STREAM_CAPTURE:
+		rx = 1;
+		break;
+	case SNDRV_PCM_STREAM_PLAYBACK:
+		tx = 1;
+		break;
+	default:
+		dev_err(dai->dev, "Invalid stream type:%d\n",
+			substream->stream);
+		return -EINVAL;
+	}
+
+	if (start && tx)
+		ret = gb_audio_apbridgea_start_tx(gb_dai->connection, 0, 0);
+
+	else if (start && rx)
+		ret = gb_audio_apbridgea_start_rx(gb_dai->connection, 0);
+
+	else if (stop && tx)
+		ret = gb_audio_apbridgea_stop_tx(gb_dai->connection, 0);
+
+	else if (stop && rx)
+		ret = gb_audio_apbridgea_stop_rx(gb_dai->connection, 0);
+
+	else
+		ret = -EINVAL;
+
+	if (ret)
+		dev_err(dai->dev, "%d:Error during %s stream\n", ret,
+			start ? "Start" : "Stop");
+
+	return ret;
 }
 
 static int gbcodec_set_dai_fmt(struct snd_soc_dai *dai, unsigned int fmt)
@@ -57,6 +355,7 @@ static struct snd_soc_dai_ops gbcodec_dai_ops = {
 	.startup = gbcodec_startup,
 	.shutdown = gbcodec_shutdown,
 	.hw_params = gbcodec_hw_params,
+	.trigger = gbcodec_trigger,
 	.prepare = gbcodec_prepare,
 	.set_fmt = gbcodec_set_dai_fmt,
 	.digital_mute = gbcodec_digital_mute,

commit 6339d2322c47f4b8ebabf9daf0130328ed72648b
Author: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
Date:   Wed Jan 13 14:07:51 2016 -0700

    greybus: audio: Add topology parser for GB codec
    
    For each GB codec module inserted, DAPM widgets, kcontrols, routes
    and DAIs can be fetched through greybus in a binary chunk and parsed
    locally to create & populate DAPM graph for the specific module.
    
    It is required by each codec module to populate a minimum set of
    kcontrols with fixed names to support basic audio usecase.
    To support advanced features of codec module, the same can be polpulated
    with existing topology parser. However, to use them for different usecase
    separate mechanism (may be via MSP) is required to inform userspace about
    their configuration value & enable/disable sequence.
    
    ToDos:
    Currently, support for enumerated kcontrol/dapm control is hardcoded.
    Need to add complete logic within the parser.
    
    Signed-off-by: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
    Signed-off-by: Mark Greer <mgreer@animalcreek.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/audio_codec.c b/drivers/staging/greybus/audio_codec.c
index fd94042d3f33..239a9b6b947c 100644
--- a/drivers/staging/greybus/audio_codec.c
+++ b/drivers/staging/greybus/audio_codec.c
@@ -19,124 +19,6 @@
 static DEFINE_MUTEX(gb_codec_list_lock);
 static LIST_HEAD(gb_codec_list);
 
-static int gbcodec_event_spk(struct snd_soc_dapm_widget *w,
-					struct snd_kcontrol *k, int event)
-{
-	/* Ensure GB speaker is connected */
-
-	return 0;
-}
-
-static int gbcodec_event_hp(struct snd_soc_dapm_widget *w,
-					struct snd_kcontrol *k, int event)
-{
-	/* Ensure GB module supports jack slot */
-
-	return 0;
-}
-
-static int gbcodec_event_int_mic(struct snd_soc_dapm_widget *w,
-					struct snd_kcontrol *k, int event)
-{
-	/* Ensure GB module supports jack slot */
-
-	return 0;
-}
-
-static const struct snd_kcontrol_new gbcodec_snd_controls[] = {
-	SOC_DOUBLE("Playback Mute", GBCODEC_MUTE_REG, 0, 1, 1, 1),
-	SOC_DOUBLE("Capture Mute", GBCODEC_MUTE_REG, 4, 5, 1, 1),
-	SOC_DOUBLE_R("Playback Volume", GBCODEC_PB_LVOL_REG,
-		     GBCODEC_PB_RVOL_REG, 0, 127, 0),
-	SOC_DOUBLE_R("Capture Volume", GBCODEC_CAP_LVOL_REG,
-		     GBCODEC_CAP_RVOL_REG, 0, 127, 0),
-};
-
-static const struct snd_kcontrol_new spk_amp_ctl =
-	SOC_DAPM_SINGLE("Switch", GBCODEC_CTL_REG, 0, 1, 0);
-
-static const struct snd_kcontrol_new hp_amp_ctl =
-	SOC_DAPM_SINGLE("Switch", GBCODEC_CTL_REG, 1, 1, 0);
-
-static const struct snd_kcontrol_new mic_adc_ctl =
-	SOC_DAPM_SINGLE("Switch", GBCODEC_CTL_REG, 4, 1, 0);
-
-/* APB1-GBSPK source */
-static const char * const gbcodec_apb1_src[] = {"Stereo", "Left", "Right"};
-
-static const SOC_ENUM_SINGLE_DECL(
-	gbcodec_apb1_rx_enum, GBCODEC_APB1_MUX_REG, 0, gbcodec_apb1_src);
-
-static const struct snd_kcontrol_new gbcodec_apb1_rx_mux =
-	SOC_DAPM_ENUM("APB1 source", gbcodec_apb1_rx_enum);
-
-static const SOC_ENUM_SINGLE_DECL(
-	gbcodec_mic_enum, GBCODEC_APB1_MUX_REG, 4, gbcodec_apb1_src);
-
-static const struct snd_kcontrol_new gbcodec_mic_mux =
-	SOC_DAPM_ENUM("MIC source", gbcodec_mic_enum);
-
-static const struct snd_soc_dapm_widget gbcodec_dapm_widgets[] = {
-	SND_SOC_DAPM_SPK("Spk", gbcodec_event_spk),
-	SND_SOC_DAPM_SPK("HP", gbcodec_event_hp),
-	SND_SOC_DAPM_MIC("Int Mic", gbcodec_event_int_mic),
-
-	SND_SOC_DAPM_OUTPUT("SPKOUT"),
-	SND_SOC_DAPM_OUTPUT("HPOUT"),
-
-	SND_SOC_DAPM_INPUT("MIC"),
-	SND_SOC_DAPM_INPUT("HSMIC"),
-
-	SND_SOC_DAPM_SWITCH("SPK Amp", SND_SOC_NOPM, 0, 0, &spk_amp_ctl),
-	SND_SOC_DAPM_SWITCH("HP Amp", SND_SOC_NOPM, 0, 0, &hp_amp_ctl),
-	SND_SOC_DAPM_SWITCH("MIC ADC", SND_SOC_NOPM, 0, 0, &mic_adc_ctl),
-
-	SND_SOC_DAPM_PGA("SPK DAC", SND_SOC_NOPM, 0, 0, NULL, 0),
-	SND_SOC_DAPM_PGA("HP DAC", SND_SOC_NOPM, 0, 0, NULL, 0),
-
-	SND_SOC_DAPM_MIXER("SPK Mixer", SND_SOC_NOPM, 0, 0, NULL, 0),
-	SND_SOC_DAPM_MIXER("HP Mixer", SND_SOC_NOPM, 0, 0, NULL, 0),
-	SND_SOC_DAPM_MIXER("APB1_TX Mixer", SND_SOC_NOPM, 0, 0, NULL, 0),
-
-	SND_SOC_DAPM_MUX("APB1_RX Mux", SND_SOC_NOPM, 0, 0,
-			 &gbcodec_apb1_rx_mux),
-	SND_SOC_DAPM_MUX("MIC Mux", SND_SOC_NOPM, 0, 0, &gbcodec_mic_mux),
-
-	SND_SOC_DAPM_AIF_IN("APB1RX", "APBridgeA1 Playback", 0, SND_SOC_NOPM, 0,
-			    0),
-	SND_SOC_DAPM_AIF_OUT("APB1TX", "APBridgeA1 Capture", 0, SND_SOC_NOPM, 0,
-			     0),
-};
-
-static const struct snd_soc_dapm_route gbcodec_dapm_routes[] = {
-	/* Playback path */
-	{"Spk", NULL, "SPKOUT"},
-	{"SPKOUT", NULL, "SPK Amp"},
-	{"SPK Amp", "Switch", "SPK DAC"},
-	{"SPK DAC", NULL, "SPK Mixer"},
-
-	{"HP", NULL, "HPOUT"},
-	{"HPOUT", NULL, "HP Amp"},
-	{"HP Amp", "Switch", "HP DAC"},
-	{"HP DAC", NULL, "HP Mixer"},
-
-	{"SPK Mixer", NULL, "APB1_RX Mux"},
-	{"HP Mixer", NULL, "APB1_RX Mux"},
-
-	{"APB1_RX Mux", "Left", "APB1RX"},
-	{"APB1_RX Mux", "Right", "APB1RX"},
-	{"APB1_RX Mux", "Stereo", "APB1RX"},
-
-	/* Capture path */
-	{"MIC", NULL, "Int Mic"},
-	{"MIC", NULL, "MIC Mux"},
-	{"MIC Mux", "Left", "MIC ADC"},
-	{"MIC Mux", "Right", "MIC ADC"},
-	{"MIC Mux", "Stereo", "MIC ADC"},
-	{"MIC ADC", "Switch", "APB1_TX Mixer"},
-	{"APB1_TX Mixer", NULL, "APB1TX"}
-};
-
 static int gbcodec_startup(struct snd_pcm_substream *substream,
 			   struct snd_soc_dai *dai)
 {
@@ -180,24 +62,9 @@ static struct snd_soc_dai_ops gbcodec_dai_ops = {
 	.digital_mute = gbcodec_digital_mute,
 };
 
-static struct snd_soc_dai_driver gbcodec_dai = {
-		.playback = {
-			.stream_name = "APBridgeA1 Playback",
-			.channels_min = 1,
-			.channels_max = 2,
-			.rates = SNDRV_PCM_RATE_48000 | SNDRV_PCM_RATE_44100,
-			.formats = SNDRV_PCM_FMTBIT_S16_LE,
-		},
-		.capture = {
-			.stream_name = "APBridgeA1 Capture",
-			.channels_min = 2,
-			.channels_max = 2,
-			.rates = SNDRV_PCM_RATE_48000 | SNDRV_PCM_RATE_44100,
-			.formats = SNDRV_PCM_FMTBIT_S16_LE,
-		},
-		.ops = &gbcodec_dai_ops,
-};
-
+/*
+ * codec driver ops
+ */
 static int gbcodec_probe(struct snd_soc_codec *codec)
 {
 	/* Empty function for now */
@@ -261,13 +128,6 @@ static struct snd_soc_codec_driver soc_codec_dev_gbcodec = {
 	.reg_word_size = 1,
 
 	.idle_bias_off = true,
-
-	.controls = gbcodec_snd_controls,
-	.num_controls = ARRAY_SIZE(gbcodec_snd_controls),
-	.dapm_widgets = gbcodec_dapm_widgets,
-	.num_dapm_widgets = ARRAY_SIZE(gbcodec_dapm_widgets),
-	.dapm_routes = gbcodec_dapm_routes,
-	.num_dapm_routes = ARRAY_SIZE(gbcodec_dapm_routes),
 };
 
 /*
@@ -369,6 +229,9 @@ static struct gbaudio_codec_info *gbaudio_get_codec(struct device *dev,
 
 	mutex_init(&gbcodec->lock);
 	INIT_LIST_HEAD(&gbcodec->dai_list);
+	INIT_LIST_HEAD(&gbcodec->widget_list);
+	INIT_LIST_HEAD(&gbcodec->codec_ctl_list);
+	INIT_LIST_HEAD(&gbcodec->widget_ctl_list);
 	gbcodec->dev_id = dev_id;
 	dev_set_drvdata(dev, gbcodec);
 	gbcodec->dev = dev;
@@ -412,8 +275,9 @@ struct device_driver gb_codec_driver = {
 
 static int gbaudio_codec_probe(struct gb_connection *connection)
 {
-	int ret;
+	int ret, i;
 	struct gbaudio_codec_info *gbcodec;
+	struct gb_audio_topology *topology;
 	struct device *dev = &connection->bundle->dev;
 	int dev_id = connection->bundle->id;
 
@@ -425,8 +289,35 @@ static int gbaudio_codec_probe(struct gb_connection *connection)
 
 	gbcodec->mgmt_connection = connection;
 
+	/* fetch topology data */
+	ret = gb_audio_gb_get_topology(connection, &topology);
+	if (ret) {
+		dev_err(gbcodec->dev,
+			"%d:Error while fetching topology\n", ret);
+		goto base_error;
+	}
+
+	/* process topology data */
+	ret = gbaudio_tplg_parse_data(gbcodec, topology);
+	if (ret) {
+		dev_err(dev, "%d:Error while parsing topology data\n",
+			  ret);
+		goto topology_error;
+	}
+	gbcodec->topology = topology;
+
+	/* update codec info */
+	soc_codec_dev_gbcodec.controls = gbcodec->kctls;
+	soc_codec_dev_gbcodec.num_controls = gbcodec->num_kcontrols;
+	soc_codec_dev_gbcodec.dapm_widgets = gbcodec->widgets;
+	soc_codec_dev_gbcodec.num_dapm_widgets = gbcodec->num_dapm_widgets;
+	soc_codec_dev_gbcodec.dapm_routes = gbcodec->routes;
+	soc_codec_dev_gbcodec.num_dapm_routes = gbcodec->num_dapm_routes;
+
 	/* update DAI info */
-	gbcodec->dais = &gbcodec_dai;
+	for (i = 0; i < gbcodec->num_dais; i++)
+		gbcodec->dais[i].ops = &gbcodec_dai_ops;
+
 	/* FIXME */
 	dev->driver = &gb_codec_driver;
 
@@ -435,7 +326,7 @@ static int gbaudio_codec_probe(struct gb_connection *connection)
 				     gbcodec->dais, 1);
 	if (ret) {
 		dev_err(dev, "%d:Failed to register codec\n", ret);
-		goto base_error;
+		goto parse_error;
 	}
 
 	/* update DAI links in response to this codec */
@@ -455,8 +346,13 @@ static int gbaudio_codec_probe(struct gb_connection *connection)
 
 codec_reg_error:
 	snd_soc_unregister_codec(dev);
-base_error:
 	dev->driver = NULL;
+parse_error:
+	gbaudio_tplg_release(gbcodec);
+	gbcodec->topology = NULL;
+topology_error:
+	kfree(topology);
+base_error:
 	gbcodec->mgmt_connection = NULL;
 	return ret;
 }
@@ -480,6 +376,8 @@ static void gbaudio_codec_remove(struct gb_connection *connection)
 
 	snd_soc_unregister_codec(dev);
 	dev->driver = NULL;
+	gbaudio_tplg_release(gbcodec);
+	kfree(gbcodec->topology);
 	gbcodec->mgmt_connection = NULL;
 	mutex_lock(&gbcodec->lock);
 	gbcodec->codec_registered = 0;
@@ -509,68 +407,6 @@ static struct gb_protocol gb_audio_mgmt_protocol = {
 	.request_recv		= gbaudio_codec_report_event_recv,
 };
 
-static struct gbaudio_dai *gbaudio_allocate_dai(struct gbaudio_codec_info *gb,
-					 int data_cport,
-					 struct gb_connection *connection,
-					 const char *name)
-{
-	struct gbaudio_dai *dai;
-
-	mutex_lock(&gb->lock);
-	dai = devm_kzalloc(gb->dev, sizeof(*dai), GFP_KERNEL);
-	if (!dai) {
-		dev_err(gb->dev, "%s:DAI Malloc failure\n", name);
-		mutex_unlock(&gb->lock);
-		return NULL;
-	}
-
-	dai->data_cport = data_cport;
-	dai->connection = connection;
-
-	/* update name */
-	if (name)
-		strlcpy(dai->name, name, NAME_SIZE);
-	list_add(&dai->list, &gb->dai_list);
-	dev_dbg(gb->dev, "%d:%s: DAI added\n", data_cport, dai->name);
-	mutex_unlock(&gb->lock);
-
-	return dai;
-}
-
-struct gbaudio_dai *gbaudio_add_dai(struct gbaudio_codec_info *gbcodec,
-				    int data_cport,
-				    struct gb_connection *connection,
-				    const char *name)
-{
-	struct gbaudio_dai *dai, *_dai;
-
-	/* FIXME need to take care for multiple DAIs */
-	mutex_lock(&gbcodec->lock);
-	if (list_empty(&gbcodec->dai_list)) {
-		mutex_unlock(&gbcodec->lock);
-		return gbaudio_allocate_dai(gbcodec, data_cport, connection,
-					    name);
-	}
-
-	list_for_each_entry_safe(dai, _dai, &gbcodec->dai_list, list) {
-		if (dai->data_cport == data_cport) {
-			if (connection)
-				dai->connection = connection;
-
-			if (name)
-				strlcpy(dai->name, name, NAME_SIZE);
-			dev_dbg(gbcodec->dev, "%d:%s: DAI updated\n",
-				data_cport, dai->name);
-			mutex_unlock(&gbcodec->lock);
-			return dai;
-		}
-	}
-
-	dev_err(gbcodec->dev, "%s:DAI not found\n", name);
-	mutex_unlock(&gbcodec->lock);
-	return NULL;
-}
-
 static int gbaudio_dai_probe(struct gb_connection *connection)
 {
 	struct gbaudio_dai *dai;

commit 2a70e49f9183d72287e84ac4d6a4080e3f2a6475
Author: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
Date:   Wed Jan 13 14:07:50 2016 -0700

    greybus: audio: Use greybus connection device for codec registration
    
    Use GB Audio mgmt, data protocol ids to register codec module with
    GB protocol. And in response to mgmt->connection_init(), register
    GB codec driver with ASoC.
    
    Now, using msm8994  machine to register DAI link dynamically on
    codec insertion.
    
    ToDos:
    - snd_soc_register_codec() uses driver->name to identify device id.
      However, for GB device, .driver{} is not yet populated by GB core.
      Thus, defining dummy structure within codec driver. This should
      come from GB core itself.
      Even existing .driver{} may cause problem in case of multiple
      modules inserted or inserted at a different slot.
    - Fix logic for gbcodec->dais & gbcodec->dailinks. Current
      implementation contains some hard coded data with assumption of
      count=1.
    - Evaluate definition of 'gbaudio_dailink.be_id' in case of multiple
      DAI links.
    
    Signed-off-by: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
    Signed-off-by: Mark Greer <mgreer@animalcreek.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/audio_codec.c b/drivers/staging/greybus/audio_codec.c
index 826604ae64df..fd94042d3f33 100644
--- a/drivers/staging/greybus/audio_codec.c
+++ b/drivers/staging/greybus/audio_codec.c
@@ -5,10 +5,20 @@
  *
  * Released under the GPLv2 only.
  */
+#include <linux/kernel.h>
 #include <linux/module.h>
+#include <sound/soc.h>
+#include <sound/pcm_params.h>
+#include <sound/msm-dynamic-dailink.h>
 
 #include "audio_codec.h"
 
+#define GB_AUDIO_MGMT_DRIVER_NAME	"gb_audio_mgmt"
+#define GB_AUDIO_DATA_DRIVER_NAME	"gb_audio_data"
+
+static DEFINE_MUTEX(gb_codec_list_lock);
+static LIST_HEAD(gb_codec_list);
+
 static int gbcodec_event_spk(struct snd_soc_dapm_widget *w,
 					struct snd_kcontrol *k, int event)
 {
@@ -190,10 +200,7 @@ static struct snd_soc_dai_driver gbcodec_dai = {
 
 static int gbcodec_probe(struct snd_soc_codec *codec)
 {
-	struct gbaudio_codec_info *gbcodec = snd_soc_codec_get_drvdata(codec);
-
-	gbcodec->codec = codec;
-
+	/* Empty function for now */
 	return 0;
 }
 
@@ -263,53 +270,412 @@ static struct snd_soc_codec_driver soc_codec_dev_gbcodec = {
 	.num_dapm_routes = ARRAY_SIZE(gbcodec_dapm_routes),
 };
 
-static int gbaudio_codec_probe(struct platform_device *pdev)
+/*
+ * GB codec DAI link related
+ */
+static struct snd_soc_dai_link gbaudio_dailink = {
+	.name = "PRI_MI2S_RX",
+	.stream_name = "Primary MI2S Playback",
+	.platform_name = "msm-pcm-routing",
+	.cpu_dai_name = "msm-dai-q6-mi2s.0",
+	.no_pcm = 1,
+	.be_id = 34,
+};
+
+static void gbaudio_remove_dailinks(struct gbaudio_codec_info *gbcodec)
+{
+	int i;
+
+	for (i = 0; i < gbcodec->num_dai_links; i++) {
+		dev_dbg(gbcodec->dev, "Remove %s: DAI link\n",
+			gbcodec->dailink_name[i]);
+		devm_kfree(gbcodec->dev, gbcodec->dailink_name[i]);
+		gbcodec->dailink_name[i] = NULL;
+	}
+	gbcodec->num_dai_links = 0;
+}
+
+static int gbaudio_add_dailinks(struct gbaudio_codec_info *gbcodec)
+{
+	int ret, i;
+	char *dai_link_name;
+	struct snd_soc_dai_link *dai;
+	struct device *dev = gbcodec->dev;
+
+	dai = &gbaudio_dailink;
+	dai->codec_name = gbcodec->name;
+
+	/* FIXME
+	 * allocate memory for DAI links based on count.
+	 * currently num_dai_links=1, so using static struct
+	 */
+	gbcodec->num_dai_links = 1;
+
+	for (i = 0; i < gbcodec->num_dai_links; i++) {
+		gbcodec->dailink_name[i] = dai_link_name =
+			devm_kzalloc(dev, NAME_SIZE, GFP_KERNEL);
+		snprintf(dai_link_name, NAME_SIZE, "GB %d.%d PRI_MI2S_RX",
+			 gbcodec->dev_id, i);
+		dai->name = dai_link_name;
+		dai->codec_dai_name = gbcodec->dais[i].name;
+	}
+
+	ret = msm8994_add_dailink("msm8994-tomtom-mtp-snd-card", dai, 1);
+	if (ret) {
+		dev_err(dev, "%d:Error while adding DAI link\n", ret);
+		goto err_dai_link;
+	}
+
+	return ret;
+
+err_dai_link:
+	gbcodec->num_dai_links = i;
+	gbaudio_remove_dailinks(gbcodec);
+	return ret;
+}
+
+/*
+ * gb_snd management functions
+ */
+static struct gbaudio_codec_info *gbaudio_find_codec(struct device *dev,
+						     int dev_id)
+{
+	struct gbaudio_codec_info *tmp, *ret;
+
+	mutex_lock(&gb_codec_list_lock);
+	list_for_each_entry_safe(ret, tmp, &gb_codec_list, list) {
+		dev_dbg(dev, "%d:device found\n", ret->dev_id);
+		if (ret->dev_id == dev_id) {
+			mutex_unlock(&gb_codec_list_lock);
+			return ret;
+		}
+	}
+	mutex_unlock(&gb_codec_list_lock);
+	return NULL;
+}
+
+static struct gbaudio_codec_info *gbaudio_get_codec(struct device *dev,
+						    int dev_id)
+{
+	struct gbaudio_codec_info *gbcodec;
+
+	gbcodec = gbaudio_find_codec(dev, dev_id);
+	if (gbcodec)
+		return gbcodec;
+
+	gbcodec = devm_kzalloc(dev, sizeof(*gbcodec), GFP_KERNEL);
+	if (!gbcodec)
+		return NULL;
+
+	mutex_init(&gbcodec->lock);
+	INIT_LIST_HEAD(&gbcodec->dai_list);
+	gbcodec->dev_id = dev_id;
+	dev_set_drvdata(dev, gbcodec);
+	gbcodec->dev = dev;
+	strlcpy(gbcodec->name, dev_name(dev), NAME_SIZE);
+
+	mutex_lock(&gb_codec_list_lock);
+	list_add(&gbcodec->list, &gb_codec_list);
+	mutex_unlock(&gb_codec_list_lock);
+	dev_dbg(dev, "%d:%s Added to codec list\n", gbcodec->dev_id,
+		gbcodec->name);
+
+	return gbcodec;
+}
+
+static void gbaudio_free_codec(struct device *dev,
+			       struct gbaudio_codec_info *gbcodec)
+{
+	mutex_lock(&gb_codec_list_lock);
+	if (!gbcodec->mgmt_connection &&
+			list_empty(&gbcodec->dai_list)) {
+		list_del(&gbcodec->list);
+		mutex_unlock(&gb_codec_list_lock);
+		dev_set_drvdata(dev, NULL);
+		devm_kfree(dev, gbcodec);
+	} else {
+		mutex_unlock(&gb_codec_list_lock);
+	}
+}
+
+/*
+ * This is the basic hook get things initialized and registered w/ gb
+ */
+
+/*
+ * GB codec module driver ops
+ */
+struct device_driver gb_codec_driver = {
+	.name = "1-8",
+	.owner = THIS_MODULE,
+};
+
+static int gbaudio_codec_probe(struct gb_connection *connection)
 {
 	int ret;
 	struct gbaudio_codec_info *gbcodec;
-	char dai_name[NAME_SIZE];
+	struct device *dev = &connection->bundle->dev;
+	int dev_id = connection->bundle->id;
 
-	gbcodec = devm_kzalloc(&pdev->dev, sizeof(struct gbaudio_codec_info),
-			       GFP_KERNEL);
+	dev_dbg(dev, "Add device:%d:%s\n", dev_id, dev_name(dev));
+	/* get gbcodec data */
+	gbcodec = gbaudio_get_codec(dev, dev_id);
 	if (!gbcodec)
 		return -ENOMEM;
-	platform_set_drvdata(pdev, gbcodec);
 
-	snprintf(dai_name, NAME_SIZE, "%s.%d", "gbcodec_pcm", pdev->id);
-	gbcodec_dai.name = dai_name;
+	gbcodec->mgmt_connection = connection;
+
+	/* update DAI info */
+	gbcodec->dais = &gbcodec_dai;
+	/* FIXME */
+	dev->driver = &gb_codec_driver;
+
+	/* register codec */
+	ret = snd_soc_register_codec(dev, &soc_codec_dev_gbcodec,
+				     gbcodec->dais, 1);
+	if (ret) {
+		dev_err(dev, "%d:Failed to register codec\n", ret);
+		goto base_error;
+	}
+
+	/* update DAI links in response to this codec */
+	ret = gbaudio_add_dailinks(gbcodec);
+	if (ret) {
+		dev_err(dev, "%d: Failed to add DAI links\n", ret);
+		goto codec_reg_error;
+	}
+
+	/* set registered flag */
+	mutex_lock(&gbcodec->lock);
+	gbcodec->codec_registered = 1;
 
-	ret = snd_soc_register_codec(&pdev->dev, &soc_codec_dev_gbcodec,
-				     &gbcodec_dai, 1);
-	if (!ret)
-		gbcodec->registered = 1;
+	mutex_unlock(&gbcodec->lock);
 
 	return ret;
+
+codec_reg_error:
+	snd_soc_unregister_codec(dev);
+base_error:
+	dev->driver = NULL;
+	gbcodec->mgmt_connection = NULL;
+	return ret;
 }
 
-static const struct of_device_id gbcodec_of_match[] = {
-	{ .compatible = "greybus,codec", },
-	{},
+static void gbaudio_codec_remove(struct gb_connection *connection)
+{
+	struct gbaudio_codec_info *gbcodec;
+	struct device *dev = &connection->bundle->dev;
+	int dev_id = connection->bundle->id;
+
+	dev_dbg(dev, "Remove device:%d:%s\n", dev_id, dev_name(dev));
+
+	/* get gbcodec data */
+	gbcodec = gbaudio_find_codec(dev, dev_id);
+	if (!gbcodec)
+		return;
+
+	msm8994_remove_dailink("msm8994-tomtom-mtp-snd-card", &gbaudio_dailink,
+			       1);
+	gbaudio_remove_dailinks(gbcodec);
+
+	snd_soc_unregister_codec(dev);
+	dev->driver = NULL;
+	gbcodec->mgmt_connection = NULL;
+	mutex_lock(&gbcodec->lock);
+	gbcodec->codec_registered = 0;
+	mutex_unlock(&gbcodec->lock);
+	gbaudio_free_codec(dev, gbcodec);
+}
+
+static int gbaudio_codec_report_event_recv(u8 type, struct gb_operation *op)
+{
+	struct gb_connection *connection = op->connection;
+	struct gb_audio_streaming_event_request *req = op->request->payload;
+
+	dev_warn(&connection->bundle->dev,
+		 "Audio Event received: cport: %u, event: %u\n",
+		 req->data_cport, req->event);
+
+	return 0;
+}
+
+static struct gb_protocol gb_audio_mgmt_protocol = {
+	.name			= GB_AUDIO_MGMT_DRIVER_NAME,
+	.id			= GREYBUS_PROTOCOL_AUDIO_MGMT,
+	.major			= 0,
+	.minor			= 1,
+	.connection_init	= gbaudio_codec_probe,
+	.connection_exit	= gbaudio_codec_remove,
+	.request_recv		= gbaudio_codec_report_event_recv,
 };
 
-static int gbaudio_codec_remove(struct platform_device *pdev)
+static struct gbaudio_dai *gbaudio_allocate_dai(struct gbaudio_codec_info *gb,
+					 int data_cport,
+					 struct gb_connection *connection,
+					 const char *name)
+{
+	struct gbaudio_dai *dai;
+
+	mutex_lock(&gb->lock);
+	dai = devm_kzalloc(gb->dev, sizeof(*dai), GFP_KERNEL);
+	if (!dai) {
+		dev_err(gb->dev, "%s:DAI Malloc failure\n", name);
+		mutex_unlock(&gb->lock);
+		return NULL;
+	}
+
+	dai->data_cport = data_cport;
+	dai->connection = connection;
+
+	/* update name */
+	if (name)
+		strlcpy(dai->name, name, NAME_SIZE);
+	list_add(&dai->list, &gb->dai_list);
+	dev_dbg(gb->dev, "%d:%s: DAI added\n", data_cport, dai->name);
+	mutex_unlock(&gb->lock);
+
+	return dai;
+}
+
+struct gbaudio_dai *gbaudio_add_dai(struct gbaudio_codec_info *gbcodec,
+				    int data_cport,
+				    struct gb_connection *connection,
+				    const char *name)
+{
+	struct gbaudio_dai *dai, *_dai;
+
+	/* FIXME need to take care for multiple DAIs */
+	mutex_lock(&gbcodec->lock);
+	if (list_empty(&gbcodec->dai_list)) {
+		mutex_unlock(&gbcodec->lock);
+		return gbaudio_allocate_dai(gbcodec, data_cport, connection,
+					    name);
+	}
+
+	list_for_each_entry_safe(dai, _dai, &gbcodec->dai_list, list) {
+		if (dai->data_cport == data_cport) {
+			if (connection)
+				dai->connection = connection;
+
+			if (name)
+				strlcpy(dai->name, name, NAME_SIZE);
+			dev_dbg(gbcodec->dev, "%d:%s: DAI updated\n",
+				data_cport, dai->name);
+			mutex_unlock(&gbcodec->lock);
+			return dai;
+		}
+	}
+
+	dev_err(gbcodec->dev, "%s:DAI not found\n", name);
+	mutex_unlock(&gbcodec->lock);
+	return NULL;
+}
+
+static int gbaudio_dai_probe(struct gb_connection *connection)
 {
-	snd_soc_unregister_codec(&pdev->dev);
+	struct gbaudio_dai *dai;
+	struct device *dev = &connection->bundle->dev;
+	int dev_id = connection->bundle->id;
+	struct gbaudio_codec_info *gbcodec = dev_get_drvdata(dev);
+
+	dev_dbg(dev, "Add DAI device:%d:%s\n", dev_id, dev_name(dev));
+
+	/* get gbcodec data */
+	gbcodec = gbaudio_get_codec(dev, dev_id);
+	if (!gbcodec)
+		return -ENOMEM;
+
+	/* add/update dai_list*/
+	dai = gbaudio_add_dai(gbcodec, connection->intf_cport_id, connection,
+			       NULL);
+	if (!dai)
+		return -ENOMEM;
+
+	/* update dai_added count */
+	mutex_lock(&gbcodec->lock);
+	gbcodec->dai_added++;
+	mutex_unlock(&gbcodec->lock);
 
 	return 0;
 }
 
-static struct platform_driver gbaudio_codec_driver = {
-	.driver = {
-		.name = "gbaudio-codec",
-		.owner = THIS_MODULE,
-		.of_match_table = gbcodec_of_match,
-	},
-	.probe = gbaudio_codec_probe,
-	.remove   = gbaudio_codec_remove,
+static void gbaudio_dai_remove(struct gb_connection *connection)
+{
+	struct device *dev = &connection->bundle->dev;
+	int dev_id = connection->bundle->id;
+	struct gbaudio_codec_info *gbcodec;
+
+	dev_dbg(dev, "Remove DAI device:%d:%s\n", dev_id, dev_name(dev));
+
+	/* get gbcodec data */
+	gbcodec = gbaudio_find_codec(dev, dev_id);
+	if (!gbcodec)
+		return;
+
+	/* inform uevent to above layers */
+	mutex_lock(&gbcodec->lock);
+	/* update dai_added count */
+	gbcodec->dai_added--;
+	mutex_unlock(&gbcodec->lock);
+
+	gbaudio_free_codec(dev, gbcodec);
+}
+
+static int gbaudio_dai_report_event_recv(u8 type, struct gb_operation *op)
+{
+	struct gb_connection *connection = op->connection;
+
+	dev_warn(&connection->bundle->dev, "Audio Event received\n");
+
+	return 0;
+}
+
+static struct gb_protocol gb_audio_data_protocol = {
+	.name			= GB_AUDIO_DATA_DRIVER_NAME,
+	.id			= GREYBUS_PROTOCOL_AUDIO_DATA,
+	.major			= 0,
+	.minor			= 1,
+	.connection_init	= gbaudio_dai_probe,
+	.connection_exit	= gbaudio_dai_remove,
+	.request_recv		= gbaudio_dai_report_event_recv,
 };
-module_platform_driver(gbaudio_codec_driver);
 
-MODULE_DESCRIPTION("Greybus Audio virtual codec driver");
+/*
+ * This is the basic hook get things initialized and registered w/ gb
+ */
+
+static int __init gb_audio_protocol_init(void)
+{
+	int err;
+
+	err = gb_protocol_register(&gb_audio_mgmt_protocol);
+	if (err) {
+		pr_err("Can't register i2s mgmt protocol driver: %d\n", -err);
+		return err;
+	}
+
+	err = gb_protocol_register(&gb_audio_data_protocol);
+	if (err) {
+		pr_err("Can't register Audio protocol driver: %d\n", -err);
+		goto err_unregister_audio_mgmt;
+	}
+
+	return 0;
+
+err_unregister_audio_mgmt:
+	gb_protocol_deregister(&gb_audio_mgmt_protocol);
+	return err;
+}
+module_init(gb_audio_protocol_init);
+
+static void __exit gb_audio_protocol_exit(void)
+{
+	gb_protocol_deregister(&gb_audio_data_protocol);
+	gb_protocol_deregister(&gb_audio_mgmt_protocol);
+}
+module_exit(gb_audio_protocol_exit);
+
+MODULE_DESCRIPTION("Greybus Audio codec driver");
 MODULE_AUTHOR("Vaibhav Agarwal <vaibhav.agarwal@linaro.org>");
 MODULE_LICENSE("GPL v2");
 MODULE_ALIAS("platform:gbaudio-codec");

commit 7885342cc2727e2e9acae1597ebc88bedfea8464
Author: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
Date:   Wed Jan 13 14:07:49 2016 -0700

    greybus: audio: Build audio module conditionally
    
    Added CONFIG_XXX flag check before compiling audio module.
    Once we add dynamic DAI link registration from audio driver,
    this check wil be required to avoid compilation failures with
    other kernel revisions.
    
    Also, renamed header file to better align with .c file name.
    
    Signed-off-by: Vaibhav Agarwal <vaibhav.agarwal@linaro.org>
    Signed-off-by: Mark Greer <mgreer@animalcreek.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/audio_codec.c b/drivers/staging/greybus/audio_codec.c
index 2bc23095ffd0..826604ae64df 100644
--- a/drivers/staging/greybus/audio_codec.c
+++ b/drivers/staging/greybus/audio_codec.c
@@ -7,7 +7,7 @@
  */
 #include <linux/module.h>
 
-#include "audio.h"
+#include "audio_codec.h"
 
 static int gbcodec_event_spk(struct snd_soc_dapm_widget *w,
 					struct snd_kcontrol *k, int event)

commit fd8f9e12e2a3bb945959cd294768b265fb97480b
Author: Mark Greer <mgreer@animalcreek.com>
Date:   Wed Jan 13 14:07:44 2016 -0700

    greybus: audio: Use underscore in file name
    
    For consistency with most other files in the Greybus repository,
    change 'audio-codec.c' to use an underscore instead of a hyphen
    in its name.
    
    Signed-off-by: Mark Greer <mgreer@animalcreek.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/audio_codec.c b/drivers/staging/greybus/audio_codec.c
new file mode 100644
index 000000000000..2bc23095ffd0
--- /dev/null
+++ b/drivers/staging/greybus/audio_codec.c
@@ -0,0 +1,315 @@
+/*
+ * Greybus audio driver
+ * Copyright 2015 Google Inc.
+ * Copyright 2015 Linaro Ltd.
+ *
+ * Released under the GPLv2 only.
+ */
+#include <linux/module.h>
+
+#include "audio.h"
+
+static int gbcodec_event_spk(struct snd_soc_dapm_widget *w,
+					struct snd_kcontrol *k, int event)
+{
+	/* Ensure GB speaker is connected */
+
+	return 0;
+}
+
+static int gbcodec_event_hp(struct snd_soc_dapm_widget *w,
+					struct snd_kcontrol *k, int event)
+{
+	/* Ensure GB module supports jack slot */
+
+	return 0;
+}
+
+static int gbcodec_event_int_mic(struct snd_soc_dapm_widget *w,
+					struct snd_kcontrol *k, int event)
+{
+	/* Ensure GB module supports jack slot */
+
+	return 0;
+}
+
+static const struct snd_kcontrol_new gbcodec_snd_controls[] = {
+	SOC_DOUBLE("Playback Mute", GBCODEC_MUTE_REG, 0, 1, 1, 1),
+	SOC_DOUBLE("Capture Mute", GBCODEC_MUTE_REG, 4, 5, 1, 1),
+	SOC_DOUBLE_R("Playback Volume", GBCODEC_PB_LVOL_REG,
+		     GBCODEC_PB_RVOL_REG, 0, 127, 0),
+	SOC_DOUBLE_R("Capture Volume", GBCODEC_CAP_LVOL_REG,
+		     GBCODEC_CAP_RVOL_REG, 0, 127, 0),
+};
+
+static const struct snd_kcontrol_new spk_amp_ctl =
+	SOC_DAPM_SINGLE("Switch", GBCODEC_CTL_REG, 0, 1, 0);
+
+static const struct snd_kcontrol_new hp_amp_ctl =
+	SOC_DAPM_SINGLE("Switch", GBCODEC_CTL_REG, 1, 1, 0);
+
+static const struct snd_kcontrol_new mic_adc_ctl =
+	SOC_DAPM_SINGLE("Switch", GBCODEC_CTL_REG, 4, 1, 0);
+
+/* APB1-GBSPK source */
+static const char * const gbcodec_apb1_src[] = {"Stereo", "Left", "Right"};
+
+static const SOC_ENUM_SINGLE_DECL(
+	gbcodec_apb1_rx_enum, GBCODEC_APB1_MUX_REG, 0, gbcodec_apb1_src);
+
+static const struct snd_kcontrol_new gbcodec_apb1_rx_mux =
+	SOC_DAPM_ENUM("APB1 source", gbcodec_apb1_rx_enum);
+
+static const SOC_ENUM_SINGLE_DECL(
+	gbcodec_mic_enum, GBCODEC_APB1_MUX_REG, 4, gbcodec_apb1_src);
+
+static const struct snd_kcontrol_new gbcodec_mic_mux =
+	SOC_DAPM_ENUM("MIC source", gbcodec_mic_enum);
+
+static const struct snd_soc_dapm_widget gbcodec_dapm_widgets[] = {
+	SND_SOC_DAPM_SPK("Spk", gbcodec_event_spk),
+	SND_SOC_DAPM_SPK("HP", gbcodec_event_hp),
+	SND_SOC_DAPM_MIC("Int Mic", gbcodec_event_int_mic),
+
+	SND_SOC_DAPM_OUTPUT("SPKOUT"),
+	SND_SOC_DAPM_OUTPUT("HPOUT"),
+
+	SND_SOC_DAPM_INPUT("MIC"),
+	SND_SOC_DAPM_INPUT("HSMIC"),
+
+	SND_SOC_DAPM_SWITCH("SPK Amp", SND_SOC_NOPM, 0, 0, &spk_amp_ctl),
+	SND_SOC_DAPM_SWITCH("HP Amp", SND_SOC_NOPM, 0, 0, &hp_amp_ctl),
+	SND_SOC_DAPM_SWITCH("MIC ADC", SND_SOC_NOPM, 0, 0, &mic_adc_ctl),
+
+	SND_SOC_DAPM_PGA("SPK DAC", SND_SOC_NOPM, 0, 0, NULL, 0),
+	SND_SOC_DAPM_PGA("HP DAC", SND_SOC_NOPM, 0, 0, NULL, 0),
+
+	SND_SOC_DAPM_MIXER("SPK Mixer", SND_SOC_NOPM, 0, 0, NULL, 0),
+	SND_SOC_DAPM_MIXER("HP Mixer", SND_SOC_NOPM, 0, 0, NULL, 0),
+	SND_SOC_DAPM_MIXER("APB1_TX Mixer", SND_SOC_NOPM, 0, 0, NULL, 0),
+
+	SND_SOC_DAPM_MUX("APB1_RX Mux", SND_SOC_NOPM, 0, 0,
+			 &gbcodec_apb1_rx_mux),
+	SND_SOC_DAPM_MUX("MIC Mux", SND_SOC_NOPM, 0, 0, &gbcodec_mic_mux),
+
+	SND_SOC_DAPM_AIF_IN("APB1RX", "APBridgeA1 Playback", 0, SND_SOC_NOPM, 0,
+			    0),
+	SND_SOC_DAPM_AIF_OUT("APB1TX", "APBridgeA1 Capture", 0, SND_SOC_NOPM, 0,
+			     0),
+};
+
+static const struct snd_soc_dapm_route gbcodec_dapm_routes[] = {
+	/* Playback path */
+	{"Spk", NULL, "SPKOUT"},
+	{"SPKOUT", NULL, "SPK Amp"},
+	{"SPK Amp", "Switch", "SPK DAC"},
+	{"SPK DAC", NULL, "SPK Mixer"},
+
+	{"HP", NULL, "HPOUT"},
+	{"HPOUT", NULL, "HP Amp"},
+	{"HP Amp", "Switch", "HP DAC"},
+	{"HP DAC", NULL, "HP Mixer"},
+
+	{"SPK Mixer", NULL, "APB1_RX Mux"},
+	{"HP Mixer", NULL, "APB1_RX Mux"},
+
+	{"APB1_RX Mux", "Left", "APB1RX"},
+	{"APB1_RX Mux", "Right", "APB1RX"},
+	{"APB1_RX Mux", "Stereo", "APB1RX"},
+
+	/* Capture path */
+	{"MIC", NULL, "Int Mic"},
+	{"MIC", NULL, "MIC Mux"},
+	{"MIC Mux", "Left", "MIC ADC"},
+	{"MIC Mux", "Right", "MIC ADC"},
+	{"MIC Mux", "Stereo", "MIC ADC"},
+	{"MIC ADC", "Switch", "APB1_TX Mixer"},
+	{"APB1_TX Mixer", NULL, "APB1TX"}
+};
+
+static int gbcodec_startup(struct snd_pcm_substream *substream,
+			   struct snd_soc_dai *dai)
+{
+	return 0;
+}
+
+static void gbcodec_shutdown(struct snd_pcm_substream *substream,
+			     struct snd_soc_dai *dai)
+{
+}
+
+static int gbcodec_hw_params(struct snd_pcm_substream *substream,
+			     struct snd_pcm_hw_params *hwparams,
+			     struct snd_soc_dai *dai)
+{
+	return 0;
+}
+
+static int gbcodec_prepare(struct snd_pcm_substream *substream,
+			   struct snd_soc_dai *dai)
+{
+	return 0;
+}
+
+static int gbcodec_set_dai_fmt(struct snd_soc_dai *dai, unsigned int fmt)
+{
+	return 0;
+}
+
+static int gbcodec_digital_mute(struct snd_soc_dai *dai, int mute)
+{
+	return 0;
+}
+
+static struct snd_soc_dai_ops gbcodec_dai_ops = {
+	.startup = gbcodec_startup,
+	.shutdown = gbcodec_shutdown,
+	.hw_params = gbcodec_hw_params,
+	.prepare = gbcodec_prepare,
+	.set_fmt = gbcodec_set_dai_fmt,
+	.digital_mute = gbcodec_digital_mute,
+};
+
+static struct snd_soc_dai_driver gbcodec_dai = {
+		.playback = {
+			.stream_name = "APBridgeA1 Playback",
+			.channels_min = 1,
+			.channels_max = 2,
+			.rates = SNDRV_PCM_RATE_48000 | SNDRV_PCM_RATE_44100,
+			.formats = SNDRV_PCM_FMTBIT_S16_LE,
+		},
+		.capture = {
+			.stream_name = "APBridgeA1 Capture",
+			.channels_min = 2,
+			.channels_max = 2,
+			.rates = SNDRV_PCM_RATE_48000 | SNDRV_PCM_RATE_44100,
+			.formats = SNDRV_PCM_FMTBIT_S16_LE,
+		},
+		.ops = &gbcodec_dai_ops,
+};
+
+static int gbcodec_probe(struct snd_soc_codec *codec)
+{
+	struct gbaudio_codec_info *gbcodec = snd_soc_codec_get_drvdata(codec);
+
+	gbcodec->codec = codec;
+
+	return 0;
+}
+
+static int gbcodec_remove(struct snd_soc_codec *codec)
+{
+	/* Empty function for now */
+	return 0;
+}
+
+static int gbcodec_write(struct snd_soc_codec *codec, unsigned int reg,
+			 unsigned int value)
+{
+	int ret = 0;
+	struct gbaudio_codec_info *gbcodec = snd_soc_codec_get_drvdata(codec);
+	u8 *gbcodec_reg = gbcodec->reg;
+
+	if (reg == SND_SOC_NOPM)
+		return 0;
+
+	if (reg >= GBCODEC_REG_COUNT)
+		return 0;
+
+	gbcodec_reg[reg] = value;
+	dev_dbg(codec->dev, "reg[%d] = 0x%x\n", reg, value);
+
+	return ret;
+}
+
+static unsigned int gbcodec_read(struct snd_soc_codec *codec,
+				 unsigned int reg)
+{
+	unsigned int val = 0;
+
+	struct gbaudio_codec_info *gbcodec = snd_soc_codec_get_drvdata(codec);
+	u8 *gbcodec_reg = gbcodec->reg;
+
+	if (reg == SND_SOC_NOPM)
+		return 0;
+
+	if (reg >= GBCODEC_REG_COUNT)
+		return 0;
+
+	val = gbcodec_reg[reg];
+	dev_dbg(codec->dev, "reg[%d] = 0x%x\n", reg, val);
+
+	return val;
+}
+
+static struct snd_soc_codec_driver soc_codec_dev_gbcodec = {
+	.probe = gbcodec_probe,
+	.remove = gbcodec_remove,
+
+	.read = gbcodec_read,
+	.write = gbcodec_write,
+
+	.reg_cache_size = GBCODEC_REG_COUNT,
+	.reg_cache_default = gbcodec_reg_defaults,
+	.reg_word_size = 1,
+
+	.idle_bias_off = true,
+
+	.controls = gbcodec_snd_controls,
+	.num_controls = ARRAY_SIZE(gbcodec_snd_controls),
+	.dapm_widgets = gbcodec_dapm_widgets,
+	.num_dapm_widgets = ARRAY_SIZE(gbcodec_dapm_widgets),
+	.dapm_routes = gbcodec_dapm_routes,
+	.num_dapm_routes = ARRAY_SIZE(gbcodec_dapm_routes),
+};
+
+static int gbaudio_codec_probe(struct platform_device *pdev)
+{
+	int ret;
+	struct gbaudio_codec_info *gbcodec;
+	char dai_name[NAME_SIZE];
+
+	gbcodec = devm_kzalloc(&pdev->dev, sizeof(struct gbaudio_codec_info),
+			       GFP_KERNEL);
+	if (!gbcodec)
+		return -ENOMEM;
+	platform_set_drvdata(pdev, gbcodec);
+
+	snprintf(dai_name, NAME_SIZE, "%s.%d", "gbcodec_pcm", pdev->id);
+	gbcodec_dai.name = dai_name;
+
+	ret = snd_soc_register_codec(&pdev->dev, &soc_codec_dev_gbcodec,
+				     &gbcodec_dai, 1);
+	if (!ret)
+		gbcodec->registered = 1;
+
+	return ret;
+}
+
+static const struct of_device_id gbcodec_of_match[] = {
+	{ .compatible = "greybus,codec", },
+	{},
+};
+
+static int gbaudio_codec_remove(struct platform_device *pdev)
+{
+	snd_soc_unregister_codec(&pdev->dev);
+
+	return 0;
+}
+
+static struct platform_driver gbaudio_codec_driver = {
+	.driver = {
+		.name = "gbaudio-codec",
+		.owner = THIS_MODULE,
+		.of_match_table = gbcodec_of_match,
+	},
+	.probe = gbaudio_codec_probe,
+	.remove   = gbaudio_codec_remove,
+};
+module_platform_driver(gbaudio_codec_driver);
+
+MODULE_DESCRIPTION("Greybus Audio virtual codec driver");
+MODULE_AUTHOR("Vaibhav Agarwal <vaibhav.agarwal@linaro.org>");
+MODULE_LICENSE("GPL v2");
+MODULE_ALIAS("platform:gbaudio-codec");
