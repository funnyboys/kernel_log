commit 1be64c7963f89afbd6f96f27effea20900650dfe
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Fri May 8 13:29:02 2020 +0200

    mmc: host: Drop redundant MMC_CAP_ERASE
    
    The MMC_CAP_ERASE bit is no longer used by the mmc core as erase, discard
    and trim operations are now always supported. Therefore, drop the bit and
    move all mmc hosts away from using it.
    
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Reviewed-by: Rui Miguel Silva <rmfrfs@gmail.com>
    Link: https://lore.kernel.org/r/20200508112902.23575-1-ulf.hansson@linaro.org
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/staging/greybus/sdio.c b/drivers/staging/greybus/sdio.c
index c4b16bb5c1a4..0939f4a4c963 100644
--- a/drivers/staging/greybus/sdio.c
+++ b/drivers/staging/greybus/sdio.c
@@ -67,7 +67,6 @@ static void _gb_sdio_set_host_caps(struct gb_sdio_host *host, u32 r)
 		((r & GB_SDIO_CAP_8_BIT_DATA) ? MMC_CAP_8_BIT_DATA : 0) |
 		((r & GB_SDIO_CAP_MMC_HS) ? MMC_CAP_MMC_HIGHSPEED : 0) |
 		((r & GB_SDIO_CAP_SD_HS) ? MMC_CAP_SD_HIGHSPEED : 0) |
-		((r & GB_SDIO_CAP_ERASE) ? MMC_CAP_ERASE : 0) |
 		((r & GB_SDIO_CAP_1_2V_DDR) ? MMC_CAP_1_2V_DDR : 0) |
 		((r & GB_SDIO_CAP_1_8V_DDR) ? MMC_CAP_1_8V_DDR : 0) |
 		((r & GB_SDIO_CAP_POWER_OFF_CARD) ? MMC_CAP_POWER_OFF_CARD : 0) |

commit a389087ee9f195fcf2f31cd771e9ec5f02c16650
Author: Ulf Hansson <ulf.hansson@linaro.org>
Date:   Tue Apr 14 18:14:13 2020 +0200

    staging: greybus: sdio: Respect the cmd->busy_timeout from the mmc core
    
    Using a fixed 1s timeout for all commands is a bit problematic.
    
    For some commands it means waiting longer than needed for the timeout to
    expire, which may not a big issue, but still. For other commands, like for
    an erase (CMD38) that uses a R1B response, may require longer timeouts than
    1s. In these cases, we may end up treating the command as it failed, while
    it just needed some more time to complete successfully.
    
    Fix the problem by respecting the cmd->busy_timeout, which is provided by
    the mmc core.
    
    Cc: Rui Miguel Silva <rmfrfs@gmail.com>
    Cc: Johan Hovold <johan@kernel.org>
    Cc: Alex Elder <elder@kernel.org>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: greybus-dev@lists.linaro.org
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
    Acked-by: Rui Miguel Silva <rmfrfs@gmail.com>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Link: https://lore.kernel.org/r/20200414161413.3036-20-ulf.hansson@linaro.org
    Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>

diff --git a/drivers/staging/greybus/sdio.c b/drivers/staging/greybus/sdio.c
index 68c5718be827..c4b16bb5c1a4 100644
--- a/drivers/staging/greybus/sdio.c
+++ b/drivers/staging/greybus/sdio.c
@@ -411,6 +411,7 @@ static int gb_sdio_command(struct gb_sdio_host *host, struct mmc_command *cmd)
 	struct gb_sdio_command_request request = {0};
 	struct gb_sdio_command_response response;
 	struct mmc_data *data = host->mrq->data;
+	unsigned int timeout_ms;
 	u8 cmd_flags;
 	u8 cmd_type;
 	int i;
@@ -469,9 +470,12 @@ static int gb_sdio_command(struct gb_sdio_host *host, struct mmc_command *cmd)
 		request.data_blksz = cpu_to_le16(data->blksz);
 	}
 
-	ret = gb_operation_sync(host->connection, GB_SDIO_TYPE_COMMAND,
-				&request, sizeof(request), &response,
-				sizeof(response));
+	timeout_ms = cmd->busy_timeout ? cmd->busy_timeout :
+		GB_OPERATION_TIMEOUT_DEFAULT;
+
+	ret = gb_operation_sync_timeout(host->connection, GB_SDIO_TYPE_COMMAND,
+					&request, sizeof(request), &response,
+					sizeof(response), timeout_ms);
 	if (ret < 0)
 		goto out;
 

commit ec0ad868173da8a75121f9dc116a5d5478ff614d
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Sun Aug 25 07:54:27 2019 +0200

    staging: greybus: move core include files to include/linux/greybus/
    
    With the goal of moving the core of the greybus code out of staging, the
    include files need to be moved to include/linux/greybus.h and
    include/linux/greybus/
    
    Cc: Vaibhav Hiremath <hvaibhav.linux@gmail.com>
    Cc: Johan Hovold <johan@kernel.org>
    Cc: Vaibhav Agarwal <vaibhav.sr@gmail.com>
    Cc: Rui Miguel Silva <rmfrfs@gmail.com>
    Cc: David Lin <dtwlin@gmail.com>
    Cc: "Bryan O'Donoghue" <pure.logic@nexus-software.ie>
    Cc: greybus-dev@lists.linaro.org
    Cc: devel@driverdev.osuosl.org
    Acked-by: Mark Greer <mgreer@animalcreek.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Acked-by: Alex Elder <elder@kernel.org>
    Link: https://lore.kernel.org/r/20190825055429.18547-8-gregkh@linuxfoundation.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/sdio.c b/drivers/staging/greybus/sdio.c
index a097a8916b3b..68c5718be827 100644
--- a/drivers/staging/greybus/sdio.c
+++ b/drivers/staging/greybus/sdio.c
@@ -12,8 +12,8 @@
 #include <linux/mmc/mmc.h>
 #include <linux/scatterlist.h>
 #include <linux/workqueue.h>
+#include <linux/greybus.h>
 
-#include "greybus.h"
 #include "gbphy.h"
 
 struct gb_sdio_host {

commit 52012642a599d5ea090e99d6213ea736237ca7a6
Author: Sanjana Sanikommu <sanjana99reddy99@gmail.com>
Date:   Thu Mar 21 22:01:08 2019 +0530

    staging: greybus: sdio.c: Remove unncessary paranthesis.
    
    Challenge suggested by coccinelle.
    Remove unnecessary parathesis around the right hand of
    assignment using the below script.
    
    @@
    binary operator op = {==,!=,&&,||,>=,<=,&,|};
    expression l, r, t;
    @@
    
    (
    l = (r op t)
    |
    l =
    -(
    r
    -)
    )
    
    Signed-off-by: Sanjana Sanikommu <sanjana99reddy99@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/sdio.c b/drivers/staging/greybus/sdio.c
index 38e85033fc4b..a097a8916b3b 100644
--- a/drivers/staging/greybus/sdio.c
+++ b/drivers/staging/greybus/sdio.c
@@ -275,7 +275,7 @@ static int _gb_sdio_send(struct gb_sdio_host *host, struct mmc_data *data,
 		return -ENOMEM;
 
 	request = operation->request->payload;
-	request->data_flags = (data->flags >> 8);
+	request->data_flags = data->flags >> 8;
 	request->data_blocks = cpu_to_le16(nblocks);
 	request->data_blksz = cpu_to_le16(data->blksz);
 
@@ -329,7 +329,7 @@ static int _gb_sdio_recv(struct gb_sdio_host *host, struct mmc_data *data,
 		return -ENOMEM;
 
 	request = operation->request->payload;
-	request->data_flags = (data->flags >> 8);
+	request->data_flags = data->flags >> 8;
 	request->data_blocks = cpu_to_le16(nblocks);
 	request->data_blksz = cpu_to_le16(data->blksz);
 
@@ -602,9 +602,9 @@ static void gb_mmc_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)
 		vdd = 1 << (ios->vdd - GB_SDIO_VDD_SHIFT);
 	request.vdd = cpu_to_le32(vdd);
 
-	request.bus_mode = (ios->bus_mode == MMC_BUSMODE_OPENDRAIN ?
+	request.bus_mode = ios->bus_mode == MMC_BUSMODE_OPENDRAIN ?
 			    GB_SDIO_BUSMODE_OPENDRAIN :
-			    GB_SDIO_BUSMODE_PUSHPULL);
+			    GB_SDIO_BUSMODE_PUSHPULL;
 
 	switch (ios->power_mode) {
 	case MMC_POWER_OFF:

commit 863dbc52e7f0e5acd7b4883f3933543a81c474c7
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Nov 7 14:58:42 2017 +0100

    staging: greybus: Remove redundant license text
    
    Now that the SPDX tag is in all greybus files, that identifies the
    license in a specific and legally-defined manner.  So the extra GPL text
    wording can be removed as it is no longer needed at all.
    
    This is done on a quest to remove the 700+ different ways that files in
    the kernel describe the GPL license text.  And there's unneeded stuff
    like the address (sometimes incorrect) for the FSF which is never
    needed.
    
    No copyright headers or other non-license-description text was removed.
    
    Cc: Vaibhav Hiremath <hvaibhav.linux@gmail.com>
    Reviewed-by: Alex Elder <elder@linaro.org>
    Acked-by: Vaibhav Agarwal <vaibhav.sr@gmail.com>
    Acked-by: David Lin <dtwlin@gmail.com>
    Acked-by: Johan Hovold <johan@kernel.org>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Acked-by: Mark Greer <mgreer@animalcreek.com>
    Acked-by: Rui Miguel Silva <rmfrfs@gmail.com>
    Acked-by: "Bryan O'Donoghue" <pure.logic@nexus-software.ie>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/sdio.c b/drivers/staging/greybus/sdio.c
index a81e0f4286ef..38e85033fc4b 100644
--- a/drivers/staging/greybus/sdio.c
+++ b/drivers/staging/greybus/sdio.c
@@ -4,8 +4,6 @@
  *
  * Copyright 2014-2015 Google Inc.
  * Copyright 2014-2015 Linaro Ltd.
- *
- * Released under the GPLv2 only.
  */
 
 #include <linux/kernel.h>

commit eb50fd3a22c770f36be275295b782f3ea52e3215
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Nov 7 14:58:41 2017 +0100

    staging: greybus: add SPDX identifiers to all greybus driver files
    
    It's good to have SPDX identifiers in all files to make it easier to
    audit the kernel tree for correct licenses.
    
    Update the drivers/staging/greybus files files with the correct SPDX
    license identifier based on the license text in the file itself.  The
    SPDX identifier is a legally binding shorthand, which can be used
    instead of the full boiler plate text.
    
    This work is based on a script and data from Thomas Gleixner, Philippe
    Ombredanne, and Kate Stewart.
    
    Cc: Vaibhav Hiremath <hvaibhav.linux@gmail.com>
    Cc: "Bryan O'Donoghue" <pure.logic@nexus-software.ie>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: Philippe Ombredanne <pombredanne@nexb.com>
    Acked-by: Vaibhav Agarwal <vaibhav.sr@gmail.com>
    Acked-by: David Lin <dtwlin@gmail.com>
    Reviewed-by: Alex Elder <elder@linaro.org>
    Acked-by: Johan Hovold <johan@kernel.org>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Acked-by: Mark Greer <mgreer@animalcreek.com>
    Acked-by: Rui Miguel Silva <rmfrfs@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/sdio.c b/drivers/staging/greybus/sdio.c
index 101ca5097fc9..a81e0f4286ef 100644
--- a/drivers/staging/greybus/sdio.c
+++ b/drivers/staging/greybus/sdio.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * SD/MMC Greybus driver.
  *

commit 946d7c78a07e78bcfb9e47d123e3f0c216bc3c74
Author: Franck Demathieu <fdemathieu@gmail.com>
Date:   Wed Jan 25 18:38:01 2017 +0100

    staging: greybus: sdio: Prefer u32 over uint32_t
    
    It fixes the following issue reported by checkpatch.pl:
    Prefer kernel type 'u32' over 'uint32_t'
    
    Signed-off-by: Franck Demathieu <fdemathieu@gmail.com>
    Acked-by: Rui Miguel Silva <rmfrfs@gmail.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/sdio.c b/drivers/staging/greybus/sdio.c
index 66b37ea29ef0..101ca5097fc9 100644
--- a/drivers/staging/greybus/sdio.c
+++ b/drivers/staging/greybus/sdio.c
@@ -52,7 +52,7 @@ struct gb_sdio_host {
 
 static inline bool single_op(struct mmc_command *cmd)
 {
-	uint32_t opcode = cmd->opcode;
+	u32 opcode = cmd->opcode;
 
 	return opcode == MMC_WRITE_BLOCK ||
 	       opcode == MMC_READ_SINGLE_BLOCK;

commit db1a4194c84d56a43d17d7f99f04feef311e7a32
Author: Rahul Krishnan <mrahul.krishnan@gmail.com>
Date:   Fri Nov 18 20:45:25 2016 +0530

    staging: Greybus: Remove unnecessary braces for single statement block
    
    This patch fixes the following checkpath.pl warning
    WARNING: braces {} are not necessary for single statement blocks
    
    Signed-off-by: Rahul Krishnan <mrahul.krishnan@gmail.com>
    Reviewed-by: Rui Miguel Silva <rmfrfs@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/sdio.c b/drivers/staging/greybus/sdio.c
index 5649ef1e379d..66b37ea29ef0 100644
--- a/drivers/staging/greybus/sdio.c
+++ b/drivers/staging/greybus/sdio.c
@@ -191,9 +191,8 @@ static int _gb_sdio_process_events(struct gb_sdio_host *host, u8 event)
 		state_changed = 1;
 	}
 
-	if (event & GB_SDIO_WP) {
+	if (event & GB_SDIO_WP)
 		host->read_only = true;
-	}
 
 	if (state_changed) {
 		dev_info(mmc_dev(host->mmc), "card %s now event\n",

commit 85a42dc8676c2ea15fb44715eef85a7a419254a0
Author: Rui Miguel Silva <rmfrfs@gmail.com>
Date:   Fri Sep 30 19:24:31 2016 +0100

    staging: greybus: sdio: fix cmd_flags check for none response
    
    When checking for command flags field if response is not available we
    really need to compare it with the right define and not bitwise AND it.
    
    smatch warn:
            drivers/staging/greybus/sdio.c:481 gb_sdio_command()
            warn: bitwise AND condition is false here
    
    Reported-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Rui Miguel Silva <rmfrfs@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/sdio.c b/drivers/staging/greybus/sdio.c
index c7133b1c7fd8..5649ef1e379d 100644
--- a/drivers/staging/greybus/sdio.c
+++ b/drivers/staging/greybus/sdio.c
@@ -478,7 +478,7 @@ static int gb_sdio_command(struct gb_sdio_host *host, struct mmc_command *cmd)
 		goto out;
 
 	/* no response expected */
-	if (cmd_flags & GB_SDIO_RSP_NONE)
+	if (cmd_flags == GB_SDIO_RSP_NONE)
 		goto out;
 
 	/* long response expected */

commit 2064ae5741f49a3e8c178680390eb296592562c1
Author: Rui Miguel Silva <rui.silva@linaro.org>
Date:   Thu Sep 8 17:17:49 2016 +0100

    staging: greybus: sdio: remove KERNEL_VERSION checks
    
    No need to support older kernel versions in the Greybus SDIO driver, so
    remove the checks as needed, we can now rely on all of the correct SDIO
    core apis being present.
    
    Signed-off-by: Rui Miguel Silva <rui.silva@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/sdio.c b/drivers/staging/greybus/sdio.c
index 99b997904edd..c7133b1c7fd8 100644
--- a/drivers/staging/greybus/sdio.c
+++ b/drivers/staging/greybus/sdio.c
@@ -46,6 +46,10 @@ struct gb_sdio_host {
 /* kernel vdd starts at 0x80 and we need to translate to greybus ones 0x01 */
 #define GB_SDIO_VDD_SHIFT	8
 
+#ifndef MMC_CAP2_CORE_RUNTIME_PM
+#define MMC_CAP2_CORE_RUNTIME_PM	0
+#endif
+
 static inline bool single_op(struct mmc_command *cmd)
 {
 	uint32_t opcode = cmd->opcode;
@@ -78,10 +82,8 @@ static void _gb_sdio_set_host_caps(struct gb_sdio_host *host, u32 r)
 		((r & GB_SDIO_CAP_DRIVER_TYPE_D) ? MMC_CAP_DRIVER_TYPE_D : 0);
 
 	caps2 = ((r & GB_SDIO_CAP_HS200_1_2V) ? MMC_CAP2_HS200_1_2V_SDR : 0) |
-#ifdef MMC_HS400_SUPPORTED
 		((r & GB_SDIO_CAP_HS400_1_2V) ? MMC_CAP2_HS400_1_2V : 0) |
 		((r & GB_SDIO_CAP_HS400_1_8V) ? MMC_CAP2_HS400_1_8V : 0) |
-#endif
 		((r & GB_SDIO_CAP_HS200_1_8V) ? MMC_CAP2_HS200_1_8V_SDR : 0);
 
 	host->mmc->caps = caps;
@@ -617,11 +619,9 @@ static void gb_mmc_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)
 	case MMC_POWER_ON:
 		power_mode = GB_SDIO_POWER_ON;
 		break;
-#ifdef MMC_POWER_UNDEFINED_SUPPORTED
 	case MMC_POWER_UNDEFINED:
 		power_mode = GB_SDIO_POWER_UNDEFINED;
 		break;
-#endif
 	}
 	request.power_mode = power_mode;
 
@@ -665,19 +665,15 @@ static void gb_mmc_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)
 	case MMC_TIMING_UHS_DDR50:
 		timing = GB_SDIO_TIMING_UHS_DDR50;
 		break;
-#ifdef MMC_DDR52_DEFINED
 	case MMC_TIMING_MMC_DDR52:
 		timing = GB_SDIO_TIMING_MMC_DDR52;
 		break;
-#endif
 	case MMC_TIMING_MMC_HS200:
 		timing = GB_SDIO_TIMING_MMC_HS200;
 		break;
-#ifdef MMC_HS400_SUPPORTED
 	case MMC_TIMING_MMC_HS400:
 		timing = GB_SDIO_TIMING_MMC_HS400;
 		break;
-#endif
 	}
 	request.timing = timing;
 

commit 7434564ca130552f3f873d0a7e87286a16890c32
Author: Greg Kroah-Hartman <gregkh@google.com>
Date:   Thu Sep 8 16:10:50 2016 +0200

    staging: greybus: sdio: fix min() type check
    
    The 0-day bot pointed out a type difference in one min() call, so fix it
    up by being explicit about the type being compared.
    
    Reported-by: kbuild test robot <fengguang.wu@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/sdio.c b/drivers/staging/greybus/sdio.c
index a78d9e4a0321..99b997904edd 100644
--- a/drivers/staging/greybus/sdio.c
+++ b/drivers/staging/greybus/sdio.c
@@ -136,7 +136,7 @@ static int gb_sdio_get_caps(struct gb_sdio_host *host)
 	data_max = min(data_max - sizeof(struct gb_sdio_transfer_request),
 		       data_max - sizeof(struct gb_sdio_transfer_response));
 
-	blksz = min(le16_to_cpu(response.max_blk_size), data_max);
+	blksz = min_t(u16, le16_to_cpu(response.max_blk_size), data_max);
 	blksz = max_t(u32, 512, blksz);
 
 	mmc->max_blk_size = rounddown_pow_of_two(blksz);

commit afbf72505be3da3bb7563e3e403020a3ba62f4f7
Author: Rui Miguel Silva <rui.silva@linaro.org>
Date:   Tue Aug 9 23:35:35 2016 +0100

    greybus: sdio: increase maximum segment size
    
    Adjust maximum segment size of the sg list to meet the maximum request
    size, this will allow to have less segments which increase the
    performance of data movement during transfer operations.
    
    Test Done: using mmc_test with best-case read/write performance and see
    that only one segment is used and that the results are better (288KiB vs
    300KiB in read operation).
    
    Signed-off-by: Rui Miguel Silva <rui.silva@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/sdio.c b/drivers/staging/greybus/sdio.c
index 3d3599a8b077..a78d9e4a0321 100644
--- a/drivers/staging/greybus/sdio.c
+++ b/drivers/staging/greybus/sdio.c
@@ -802,11 +802,11 @@ static int gb_sdio_probe(struct gbphy_device *gbphy_dev,
 
 	mmc->ops = &gb_sdio_ops;
 
-	/* for now we just make a map 1:1 between max blocks and segments */
 	mmc->max_segs = host->mmc->max_blk_count;
-	mmc->max_seg_size = host->mmc->max_blk_size;
 
+	/* for now we make a map 1:1 between max request and segment size */
 	mmc->max_req_size = mmc->max_blk_size * mmc->max_blk_count;
+	mmc->max_seg_size = mmc->max_req_size;
 
 	mutex_init(&host->lock);
 	spin_lock_init(&host->xfer);

commit 8f3972f78f3ac52833fb781cbb689af39fc8b0f1
Author: Jackson Chang <chang_jackson@projectara.com>
Date:   Fri Aug 5 10:22:02 2016 +0800

    greybus: SDIO: Add runtime pm support
    
    Modify SDIO greybus driver to support runtime PM framework.
    To enable SDIO runtime PM, it needs to remove MMC_CAP_NEEDS_POLL
    and add MMC_CAP2_CORE_RUNTIME_PM in set_host_caps().
    The suspend function and resume function have been tested
    with micron-sdio image by sysfs. SDIO functions work well
    on suspend/resume.
    
    Testing Done: Compiled and verified on EVT2.0 + Micron ARA
                  SD module with USB connector
    
    Signed-off-by: Jackson Chang <chang_jackson@projectara.com>
    Reviewed-by: Rui Miguel Silva <rui.silva@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/sdio.c b/drivers/staging/greybus/sdio.c
index ad448c6388bb..3d3599a8b077 100644
--- a/drivers/staging/greybus/sdio.c
+++ b/drivers/staging/greybus/sdio.c
@@ -84,8 +84,8 @@ static void _gb_sdio_set_host_caps(struct gb_sdio_host *host, u32 r)
 #endif
 		((r & GB_SDIO_CAP_HS200_1_8V) ? MMC_CAP2_HS200_1_8V_SDR : 0);
 
-	host->mmc->caps = caps | MMC_CAP_NEEDS_POLL;
-	host->mmc->caps2 = caps2;
+	host->mmc->caps = caps;
+	host->mmc->caps2 = caps2 | MMC_CAP2_CORE_RUNTIME_PM;
 
 	if (caps & MMC_CAP_NONREMOVABLE)
 		host->card_present = true;
@@ -239,8 +239,18 @@ static int gb_sdio_request_handler(struct gb_operation *op)
 static int gb_sdio_set_ios(struct gb_sdio_host *host,
 			   struct gb_sdio_set_ios_request *request)
 {
-	return gb_operation_sync(host->connection, GB_SDIO_TYPE_SET_IOS,
-				 request, sizeof(*request), NULL, 0);
+	int ret;
+
+	ret = gbphy_runtime_get_sync(host->gbphy_dev);
+	if (ret)
+		return ret;
+
+	ret = gb_operation_sync(host->connection, GB_SDIO_TYPE_SET_IOS, request,
+				sizeof(*request), NULL, 0);
+
+	gbphy_runtime_put_autosuspend(host->gbphy_dev);
+
+	return ret;
 }
 
 static int _gb_sdio_send(struct gb_sdio_host *host, struct mmc_data *data,
@@ -489,10 +499,15 @@ static void gb_sdio_mrq_work(struct work_struct *work)
 
 	host = container_of(work, struct gb_sdio_host, mrqwork);
 
+	ret = gbphy_runtime_get_sync(host->gbphy_dev);
+	if (ret)
+		return;
+
 	mutex_lock(&host->lock);
 	mrq = host->mrq;
 	if (!mrq) {
 		mutex_unlock(&host->lock);
+		gbphy_runtime_put_autosuspend(host->gbphy_dev);
 		dev_err(mmc_dev(host->mmc), "mmc request is NULL");
 		return;
 	}
@@ -528,6 +543,7 @@ static void gb_sdio_mrq_work(struct work_struct *work)
 	host->mrq = NULL;
 	mutex_unlock(&host->lock);
 	mmc_request_done(host->mmc, mrq);
+	gbphy_runtime_put_autosuspend(host->gbphy_dev);
 }
 
 static void gb_mmc_request(struct mmc_host *mmc, struct mmc_request *mrq)
@@ -813,6 +829,8 @@ static int gb_sdio_probe(struct gbphy_device *gbphy_dev,
 	ret = _gb_sdio_process_events(host, host->queued_events);
 	host->queued_events = 0;
 
+	gbphy_runtime_put_autosuspend(gbphy_dev);
+
 	return ret;
 
 exit_wq_destroy:
@@ -832,6 +850,11 @@ static void gb_sdio_remove(struct gbphy_device *gbphy_dev)
 	struct gb_sdio_host *host = gb_gbphy_get_data(gbphy_dev);
 	struct gb_connection *connection = host->connection;
 	struct mmc_host *mmc;
+	int ret;
+
+	ret = gbphy_runtime_get_sync(gbphy_dev);
+	if (ret)
+		gbphy_runtime_get_noresume(gbphy_dev);
 
 	mutex_lock(&host->lock);
 	host->removed = true;

commit d53cc1c37e5a4006fb23df8e54dc4a50e01732d9
Author: Rui Miguel Silva <rui.silva@linaro.org>
Date:   Tue Jul 19 15:41:30 2016 +0100

    greybus: sdio: add switch voltage operation
    
    Core sd/mmc needs the start_signal_voltage_switch operation to be
    defined to issue a voltage switch command. So, we define it here even
    though we do not need to take in action on it, since all voltage control
    is done in the Module.
    
    Signed-off-by: Rui Miguel Silva <rui.silva@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/sdio.c b/drivers/staging/greybus/sdio.c
index 5e5de04047c1..ad448c6388bb 100644
--- a/drivers/staging/greybus/sdio.c
+++ b/drivers/staging/greybus/sdio.c
@@ -734,11 +734,17 @@ static int gb_mmc_get_cd(struct mmc_host *mmc)
 	return host->card_present;
 }
 
+static int gb_mmc_switch_voltage(struct mmc_host *mmc, struct mmc_ios *ios)
+{
+	return 0;
+}
+
 static const struct mmc_host_ops gb_sdio_ops = {
 	.request	= gb_mmc_request,
 	.set_ios	= gb_mmc_set_ios,
 	.get_ro		= gb_mmc_get_ro,
 	.get_cd		= gb_mmc_get_cd,
+	.start_signal_voltage_switch	= gb_mmc_switch_voltage,
 };
 
 static int gb_sdio_probe(struct gbphy_device *gbphy_dev,

commit 484a4d667751148654277a3ec93b8f0a327da29d
Author: Rui Miguel Silva <rui.silva@linaro.org>
Date:   Tue Jul 19 15:41:29 2016 +0100

    greybus: sdio: convert vdd kernel values to greybus
    
    We need to convert vdd kernel values to greybus ones. And we get this by
    shifting the kernel values by 8.
    
    Signed-off-by: Rui Miguel Silva <rui.silva@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/sdio.c b/drivers/staging/greybus/sdio.c
index 8d2de7d96eb4..5e5de04047c1 100644
--- a/drivers/staging/greybus/sdio.c
+++ b/drivers/staging/greybus/sdio.c
@@ -43,6 +43,9 @@ struct gb_sdio_host {
 #define GB_SDIO_RSP_R1B		(GB_SDIO_RSP_PRESENT | GB_SDIO_RSP_CRC | \
 				 GB_SDIO_RSP_OPCODE | GB_SDIO_RSP_BUSY)
 
+/* kernel vdd starts at 0x80 and we need to translate to greybus ones 0x01 */
+#define GB_SDIO_VDD_SHIFT	8
+
 static inline bool single_op(struct mmc_command *cmd)
 {
 	uint32_t opcode = cmd->opcode;
@@ -574,10 +577,14 @@ static void gb_mmc_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)
 	u8 timing;
 	u8 signal_voltage;
 	u8 drv_type;
+	u32 vdd = 0;
 
 	mutex_lock(&host->lock);
 	request.clock = cpu_to_le32(ios->clock);
-	request.vdd = cpu_to_le32(1 << ios->vdd);
+
+	if (ios->vdd)
+		vdd = 1 << (ios->vdd - GB_SDIO_VDD_SHIFT);
+	request.vdd = cpu_to_le32(vdd);
 
 	request.bus_mode = (ios->bus_mode == MMC_BUSMODE_OPENDRAIN ?
 			    GB_SDIO_BUSMODE_OPENDRAIN :

commit e3b090ea954ed6f8de295511b4e533e2ef425a0f
Author: Rui Miguel Silva <rui.silva@linaro.org>
Date:   Tue Jun 21 16:56:16 2016 +0100

    greybus: sdio: avoid extra memory operation at data transfer
    
    Right now greybus sdio uses the greybus operation_sync to transfer data,
    this will imply an extra memcpy at greybus core that we can avoid.
    
    Also with this change we remove the need for an extra buffer to store
    intermediate copy.
    
    So, let us create the operation and do the memory operations in the sdio
    driver.
    
    Signed-off-by: Rui Miguel Silva <rui.silva@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/sdio.c b/drivers/staging/greybus/sdio.c
index a270517c90c8..8d2de7d96eb4 100644
--- a/drivers/staging/greybus/sdio.c
+++ b/drivers/staging/greybus/sdio.c
@@ -24,7 +24,6 @@ struct gb_sdio_host {
 	struct mmc_request	*mrq;
 	struct mutex		lock;	/* lock for this host */
 	size_t			data_max;
-	void			*xfer_buffer;
 	spinlock_t		xfer;	/* lock to cancel ongoing transfer */
 	bool			xfer_stop;
 	struct workqueue_struct	*mrq_workqueue;
@@ -245,7 +244,8 @@ static int _gb_sdio_send(struct gb_sdio_host *host, struct mmc_data *data,
 			 size_t len, u16 nblocks, off_t skip)
 {
 	struct gb_sdio_transfer_request *request;
-	struct gb_sdio_transfer_response response;
+	struct gb_sdio_transfer_response *response;
+	struct gb_operation *operation;
 	struct scatterlist *sg = data->sg;
 	unsigned int sg_len = data->sg_len;
 	size_t copied;
@@ -255,39 +255,51 @@ static int _gb_sdio_send(struct gb_sdio_host *host, struct mmc_data *data,
 
 	WARN_ON(len > host->data_max);
 
-	request = host->xfer_buffer;
+	operation = gb_operation_create(host->connection, GB_SDIO_TYPE_TRANSFER,
+					len + sizeof(*request),
+					sizeof(*response), GFP_KERNEL);
+	if (!operation)
+		return -ENOMEM;
+
+	request = operation->request->payload;
 	request->data_flags = (data->flags >> 8);
 	request->data_blocks = cpu_to_le16(nblocks);
 	request->data_blksz = cpu_to_le16(data->blksz);
 
 	copied = sg_pcopy_to_buffer(sg, sg_len, &request->data[0], len, skip);
 
-	if (copied != len)
-		return -EINVAL;
+	if (copied != len) {
+		ret = -EINVAL;
+		goto err_put_operation;
+	}
 
-	ret = gb_operation_sync(host->connection, GB_SDIO_TYPE_TRANSFER,
-				request, len + sizeof(*request),
-				&response, sizeof(response));
+	ret = gb_operation_request_send_sync(operation);
 	if (ret < 0)
-		return ret;
+		goto err_put_operation;
 
-	send_blocks = le16_to_cpu(response.data_blocks);
-	send_blksz = le16_to_cpu(response.data_blksz);
+	response = operation->response->payload;
+
+	send_blocks = le16_to_cpu(response->data_blocks);
+	send_blksz = le16_to_cpu(response->data_blksz);
 
 	if (len != send_blksz * send_blocks) {
 		dev_err(mmc_dev(host->mmc), "send: size received: %zu != %d\n",
 			len, send_blksz * send_blocks);
-		return -EINVAL;
+		ret = -EINVAL;
 	}
 
+err_put_operation:
+	gb_operation_put(operation);
+
 	return ret;
 }
 
 static int _gb_sdio_recv(struct gb_sdio_host *host, struct mmc_data *data,
 			 size_t len, u16 nblocks, off_t skip)
 {
-	struct gb_sdio_transfer_request request;
+	struct gb_sdio_transfer_request *request;
 	struct gb_sdio_transfer_response *response;
+	struct gb_operation *operation;
 	struct scatterlist *sg = data->sg;
 	unsigned int sg_len = data->sg_len;
 	size_t copied;
@@ -297,33 +309,41 @@ static int _gb_sdio_recv(struct gb_sdio_host *host, struct mmc_data *data,
 
 	WARN_ON(len > host->data_max);
 
-	request.data_flags = (data->flags >> 8);
-	request.data_blocks = cpu_to_le16(nblocks);
-	request.data_blksz = cpu_to_le16(data->blksz);
+	operation = gb_operation_create(host->connection, GB_SDIO_TYPE_TRANSFER,
+					sizeof(*request),
+					len + sizeof(*response), GFP_KERNEL);
+	if (!operation)
+		return -ENOMEM;
 
-	response = host->xfer_buffer;
+	request = operation->request->payload;
+	request->data_flags = (data->flags >> 8);
+	request->data_blocks = cpu_to_le16(nblocks);
+	request->data_blksz = cpu_to_le16(data->blksz);
 
-	ret = gb_operation_sync(host->connection, GB_SDIO_TYPE_TRANSFER,
-				&request, sizeof(request), response, len +
-				sizeof(*response));
+	ret = gb_operation_request_send_sync(operation);
 	if (ret < 0)
-		return ret;
+		goto err_put_operation;
 
+	response = operation->response->payload;
 	recv_blocks = le16_to_cpu(response->data_blocks);
 	recv_blksz = le16_to_cpu(response->data_blksz);
 
 	if (len != recv_blksz * recv_blocks) {
 		dev_err(mmc_dev(host->mmc), "recv: size received: %d != %zu\n",
 			recv_blksz * recv_blocks, len);
-		return -EINVAL;
+		ret = -EINVAL;
+		goto err_put_operation;
 	}
 
 	copied = sg_pcopy_from_buffer(sg, sg_len, &response->data[0], len,
 				      skip);
 	if (copied != len)
-		return -EINVAL;
+		ret = -EINVAL;
 
-	return 0;
+err_put_operation:
+	gb_operation_put(operation);
+
+	return ret;
 }
 
 static int gb_sdio_transfer(struct gb_sdio_host *host, struct mmc_data *data)
@@ -720,7 +740,6 @@ static int gb_sdio_probe(struct gbphy_device *gbphy_dev,
 	struct gb_connection *connection;
 	struct mmc_host *mmc;
 	struct gb_sdio_host *host;
-	size_t max_buffer;
 	int ret = 0;
 
 	mmc = mmc_alloc_host(sizeof(*host), &gbphy_dev->dev);
@@ -760,19 +779,13 @@ static int gb_sdio_probe(struct gbphy_device *gbphy_dev,
 
 	mmc->max_req_size = mmc->max_blk_size * mmc->max_blk_count;
 
-	max_buffer = gb_operation_get_payload_size_max(host->connection);
-	host->xfer_buffer = kzalloc(max_buffer, GFP_KERNEL);
-	if (!host->xfer_buffer) {
-		ret = -ENOMEM;
-		goto exit_connection_disable;
-	}
 	mutex_init(&host->lock);
 	spin_lock_init(&host->xfer);
 	host->mrq_workqueue = alloc_workqueue("mmc-%s", 0, 1,
 					      dev_name(&gbphy_dev->dev));
 	if (!host->mrq_workqueue) {
 		ret = -ENOMEM;
-		goto exit_buf_free;
+		goto exit_connection_disable;
 	}
 	INIT_WORK(&host->mrqwork, gb_sdio_mrq_work);
 
@@ -791,8 +804,6 @@ static int gb_sdio_probe(struct gbphy_device *gbphy_dev,
 
 exit_wq_destroy:
 	destroy_workqueue(host->mrq_workqueue);
-exit_buf_free:
-	kfree(host->xfer_buffer);
 exit_connection_disable:
 	gb_connection_disable(connection);
 exit_connection_destroy:
@@ -821,7 +832,6 @@ static void gb_sdio_remove(struct gbphy_device *gbphy_dev)
 	mmc_remove_host(mmc);
 	gb_connection_disable(connection);
 	gb_connection_destroy(connection);
-	kfree(host->xfer_buffer);
 	mmc_free_host(mmc);
 }
 

commit 64060fe95458f22bac7327b2ee8dc5ce9e488d44
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Mon May 30 11:31:53 2016 +0530

    greybus: gbphy: Remove protocol specific version handling
    
    We should be using the generic version handling at bundle level, instead
    of at protocol level for bridged PHY devices as well.
    
    The bundle version handling is already in place, though it is *not* used
    today as we haven't bumped the version of control protocol yet.
    
    Remove protocol specific handling for bridged PHY devices.
    
    Tested on EVT 1.5 with gpbridge-test module. No nuttx changes are
    required with this.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Reviewed-by: Johan Hovold <johan@hovoldconsulting.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/sdio.c b/drivers/staging/greybus/sdio.c
index bdcc86923c54..a270517c90c8 100644
--- a/drivers/staging/greybus/sdio.c
+++ b/drivers/staging/greybus/sdio.c
@@ -748,10 +748,6 @@ static int gb_sdio_probe(struct gbphy_device *gbphy_dev,
 	if (ret)
 		goto exit_connection_destroy;
 
-	ret = gb_gbphy_get_version(connection);
-	if (ret)
-		goto exit_connection_disable;
-
 	ret = gb_sdio_get_caps(host);
 	if (ret < 0)
 		goto exit_connection_disable;

commit ebc9e3750d3112e3a84fe65386cb0e5deb994e18
Author: Alex Elder <elder@linaro.org>
Date:   Tue May 24 13:34:48 2016 -0500

    greybus: fix unbalanced mutex
    
    Running "make coccicheck" on the Greybus code reports that
    gb_mmc_get_ro() and gb_mmc_get_cd() can return without releasing
    the mutex it acquired if there's an error.  Fix this.
    
    Signed-off-by: Alex Elder <elder@linaro.org>
    Reviewed-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/sdio.c b/drivers/staging/greybus/sdio.c
index 4d4cfdf8edb6..bdcc86923c54 100644
--- a/drivers/staging/greybus/sdio.c
+++ b/drivers/staging/greybus/sdio.c
@@ -684,9 +684,12 @@ static int gb_mmc_get_ro(struct mmc_host *mmc)
 	struct gb_sdio_host *host = mmc_priv(mmc);
 
 	mutex_lock(&host->lock);
-	if (host->removed)
+	if (host->removed) {
+		mutex_unlock(&host->lock);
 		return -ESHUTDOWN;
+	}
 	mutex_unlock(&host->lock);
+
 	return host->read_only;
 }
 
@@ -695,9 +698,12 @@ static int gb_mmc_get_cd(struct mmc_host *mmc)
 	struct gb_sdio_host *host = mmc_priv(mmc);
 
 	mutex_lock(&host->lock);
-	if (host->removed)
+	if (host->removed) {
+		mutex_unlock(&host->lock);
 		return -ESHUTDOWN;
+	}
 	mutex_unlock(&host->lock);
+
 	return host->card_present;
 }
 

commit e54b106dd1be50377fe8365392466e080b659ab6
Author: Sandeep Patil <patil_sandeep@projectara.com>
Date:   Thu May 19 08:52:39 2016 -0700

    greybus: gpbridge: rename 'gpbridge' to 'gbphy' everywhere
    
    The 'gpbridge' name didn't relaly reflect what the bus is; which
    is a bus for bridged-phy devices. So, rename all instances
    of 'gpbridge' to more appropriate 'gbphy'
    
    Testing Done:
    Build and boot tested. 'lsgb' will stop displaying 'GPBridge' devices
    until I change the library to reflect this change.
    
    Signed-off-by: Sandeep Patil <patil_sandeep@projectara.com>
    Suggested-by: Greg Kroah-Hartman <gregkh@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/sdio.c b/drivers/staging/greybus/sdio.c
index 7f063b4e4942..4d4cfdf8edb6 100644
--- a/drivers/staging/greybus/sdio.c
+++ b/drivers/staging/greybus/sdio.c
@@ -15,11 +15,11 @@
 #include <linux/workqueue.h>
 
 #include "greybus.h"
-#include "gpbridge.h"
+#include "gbphy.h"
 
 struct gb_sdio_host {
 	struct gb_connection	*connection;
-	struct gpbridge_device	*gpbdev;
+	struct gbphy_device	*gbphy_dev;
 	struct mmc_host		*mmc;
 	struct mmc_request	*mrq;
 	struct mutex		lock;	/* lock for this host */
@@ -708,8 +708,8 @@ static const struct mmc_host_ops gb_sdio_ops = {
 	.get_cd		= gb_mmc_get_cd,
 };
 
-static int gb_sdio_probe(struct gpbridge_device *gpbdev,
-			 const struct gpbridge_device_id *id)
+static int gb_sdio_probe(struct gbphy_device *gbphy_dev,
+			 const struct gbphy_device_id *id)
 {
 	struct gb_connection *connection;
 	struct mmc_host *mmc;
@@ -717,12 +717,12 @@ static int gb_sdio_probe(struct gpbridge_device *gpbdev,
 	size_t max_buffer;
 	int ret = 0;
 
-	mmc = mmc_alloc_host(sizeof(*host), &gpbdev->dev);
+	mmc = mmc_alloc_host(sizeof(*host), &gbphy_dev->dev);
 	if (!mmc)
 		return -ENOMEM;
 
-	connection = gb_connection_create(gpbdev->bundle,
-					  le16_to_cpu(gpbdev->cport_desc->id),
+	connection = gb_connection_create(gbphy_dev->bundle,
+					  le16_to_cpu(gbphy_dev->cport_desc->id),
 					  gb_sdio_request_handler);
 	if (IS_ERR(connection)) {
 		ret = PTR_ERR(connection);
@@ -735,14 +735,14 @@ static int gb_sdio_probe(struct gpbridge_device *gpbdev,
 
 	host->connection = connection;
 	gb_connection_set_data(connection, host);
-	host->gpbdev = gpbdev;
-	gb_gpbridge_set_data(gpbdev, host);
+	host->gbphy_dev = gbphy_dev;
+	gb_gbphy_set_data(gbphy_dev, host);
 
 	ret = gb_connection_enable_tx(connection);
 	if (ret)
 		goto exit_connection_destroy;
 
-	ret = gb_gpbridge_get_version(connection);
+	ret = gb_gbphy_get_version(connection);
 	if (ret)
 		goto exit_connection_disable;
 
@@ -767,7 +767,7 @@ static int gb_sdio_probe(struct gpbridge_device *gpbdev,
 	mutex_init(&host->lock);
 	spin_lock_init(&host->xfer);
 	host->mrq_workqueue = alloc_workqueue("mmc-%s", 0, 1,
-					      dev_name(&gpbdev->dev));
+					      dev_name(&gbphy_dev->dev));
 	if (!host->mrq_workqueue) {
 		ret = -ENOMEM;
 		goto exit_buf_free;
@@ -801,9 +801,9 @@ static int gb_sdio_probe(struct gpbridge_device *gpbdev,
 	return ret;
 }
 
-static void gb_sdio_remove(struct gpbridge_device *gpbdev)
+static void gb_sdio_remove(struct gbphy_device *gbphy_dev)
 {
-	struct gb_sdio_host *host = gb_gpbridge_get_data(gpbdev);
+	struct gb_sdio_host *host = gb_gbphy_get_data(gbphy_dev);
 	struct gb_connection *connection = host->connection;
 	struct mmc_host *mmc;
 
@@ -823,18 +823,18 @@ static void gb_sdio_remove(struct gpbridge_device *gpbdev)
 	mmc_free_host(mmc);
 }
 
-static const struct gpbridge_device_id gb_sdio_id_table[] = {
-	{ GPBRIDGE_PROTOCOL(GREYBUS_PROTOCOL_SDIO) },
+static const struct gbphy_device_id gb_sdio_id_table[] = {
+	{ GBPHY_PROTOCOL(GREYBUS_PROTOCOL_SDIO) },
 	{ },
 };
-MODULE_DEVICE_TABLE(gpbridge, gb_sdio_id_table);
+MODULE_DEVICE_TABLE(gbphy, gb_sdio_id_table);
 
-static struct gpbridge_driver sdio_driver = {
+static struct gbphy_driver sdio_driver = {
 	.name		= "sdio",
 	.probe		= gb_sdio_probe,
 	.remove		= gb_sdio_remove,
 	.id_table	= gb_sdio_id_table,
 };
 
-module_gpbridge_driver(sdio_driver);
+module_gbphy_driver(sdio_driver);
 MODULE_LICENSE("GPL v2");

commit 3d64730e119480062ffd2d94c49532fbf3dbb217
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Mon May 9 18:15:09 2016 +0530

    greybus: sdio: Create separate module
    
    Create separate module for sdio gpbridge driver.
    
    Tested on EVT 1.5 by inserting GP test module, all the devices were
    enumerated correctly.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/sdio.c b/drivers/staging/greybus/sdio.c
index 8ee4d4c5e73d..7f063b4e4942 100644
--- a/drivers/staging/greybus/sdio.c
+++ b/drivers/staging/greybus/sdio.c
@@ -827,6 +827,7 @@ static const struct gpbridge_device_id gb_sdio_id_table[] = {
 	{ GPBRIDGE_PROTOCOL(GREYBUS_PROTOCOL_SDIO) },
 	{ },
 };
+MODULE_DEVICE_TABLE(gpbridge, gb_sdio_id_table);
 
 static struct gpbridge_driver sdio_driver = {
 	.name		= "sdio",
@@ -834,4 +835,6 @@ static struct gpbridge_driver sdio_driver = {
 	.remove		= gb_sdio_remove,
 	.id_table	= gb_sdio_id_table,
 };
-gb_gpbridge_builtin_driver(sdio_driver);
+
+module_gpbridge_driver(sdio_driver);
+MODULE_LICENSE("GPL v2");

commit dcd2086aa87e274e2f2f96eae449a27548637dd9
Author: Greg Kroah-Hartman <gregkh@google.com>
Date:   Thu May 5 14:32:34 2016 +0530

    greybus: SDIO: convert to a gpbridge driver
    
    This converts the SDIO driver to be a gpbridge driver, moving it away
    from the "legacy" interface.
    
    Testing Done: Tested on gbsim.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>
    Signed-off-by: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
    [vaibhav.hiremath@linaro.org: 1.Changed code to retain init/exit fns of
    drivers. 2.Exit path fix. 3. Fixed review comments]
    Reviewed-by: Viresh Kumar <viresh.kumar@linaro.org>
    Tested-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/sdio.c b/drivers/staging/greybus/sdio.c
index d4cbcb972e94..8ee4d4c5e73d 100644
--- a/drivers/staging/greybus/sdio.c
+++ b/drivers/staging/greybus/sdio.c
@@ -19,6 +19,7 @@
 
 struct gb_sdio_host {
 	struct gb_connection	*connection;
+	struct gpbridge_device	*gpbdev;
 	struct mmc_host		*mmc;
 	struct mmc_request	*mrq;
 	struct mutex		lock;	/* lock for this host */
@@ -199,11 +200,12 @@ static int _gb_sdio_process_events(struct gb_sdio_host *host, u8 event)
 	return 0;
 }
 
-static int gb_sdio_event_recv(u8 type, struct gb_operation *op)
+static int gb_sdio_request_handler(struct gb_operation *op)
 {
 	struct gb_sdio_host *host = gb_connection_get_data(op->connection);
 	struct gb_message *request;
 	struct gb_sdio_event_request *payload;
+	u8 type = op->type;
 	int ret =  0;
 	u8 event;
 
@@ -706,27 +708,47 @@ static const struct mmc_host_ops gb_sdio_ops = {
 	.get_cd		= gb_mmc_get_cd,
 };
 
-static int gb_sdio_connection_init(struct gb_connection *connection)
+static int gb_sdio_probe(struct gpbridge_device *gpbdev,
+			 const struct gpbridge_device_id *id)
 {
+	struct gb_connection *connection;
 	struct mmc_host *mmc;
 	struct gb_sdio_host *host;
 	size_t max_buffer;
 	int ret = 0;
 
-	mmc = mmc_alloc_host(sizeof(*host), &connection->bundle->dev);
+	mmc = mmc_alloc_host(sizeof(*host), &gpbdev->dev);
 	if (!mmc)
 		return -ENOMEM;
 
+	connection = gb_connection_create(gpbdev->bundle,
+					  le16_to_cpu(gpbdev->cport_desc->id),
+					  gb_sdio_request_handler);
+	if (IS_ERR(connection)) {
+		ret = PTR_ERR(connection);
+		goto exit_mmc_free;
+	}
+
 	host = mmc_priv(mmc);
 	host->mmc = mmc;
 	host->removed = true;
 
 	host->connection = connection;
 	gb_connection_set_data(connection, host);
+	host->gpbdev = gpbdev;
+	gb_gpbridge_set_data(gpbdev, host);
+
+	ret = gb_connection_enable_tx(connection);
+	if (ret)
+		goto exit_connection_destroy;
+
+	ret = gb_gpbridge_get_version(connection);
+	if (ret)
+		goto exit_connection_disable;
 
 	ret = gb_sdio_get_caps(host);
 	if (ret < 0)
-		goto free_mmc;
+		goto exit_connection_disable;
 
 	mmc->ops = &gb_sdio_ops;
 
@@ -740,45 +762,50 @@ static int gb_sdio_connection_init(struct gb_connection *connection)
 	host->xfer_buffer = kzalloc(max_buffer, GFP_KERNEL);
 	if (!host->xfer_buffer) {
 		ret = -ENOMEM;
-		goto free_mmc;
+		goto exit_connection_disable;
 	}
 	mutex_init(&host->lock);
 	spin_lock_init(&host->xfer);
 	host->mrq_workqueue = alloc_workqueue("mmc-%s", 0, 1,
-					      dev_name(&connection->bundle->dev));
+					      dev_name(&gpbdev->dev));
 	if (!host->mrq_workqueue) {
 		ret = -ENOMEM;
-		goto free_buffer;
+		goto exit_buf_free;
 	}
 	INIT_WORK(&host->mrqwork, gb_sdio_mrq_work);
 
+	ret = gb_connection_enable(connection);
+	if (ret)
+		goto exit_wq_destroy;
+
 	ret = mmc_add_host(mmc);
 	if (ret < 0)
-		goto free_work;
+		goto exit_wq_destroy;
 	host->removed = false;
 	ret = _gb_sdio_process_events(host, host->queued_events);
 	host->queued_events = 0;
 
 	return ret;
 
-free_work:
+exit_wq_destroy:
 	destroy_workqueue(host->mrq_workqueue);
-free_buffer:
+exit_buf_free:
 	kfree(host->xfer_buffer);
-free_mmc:
-	gb_connection_set_data(connection, NULL);
+exit_connection_disable:
+	gb_connection_disable(connection);
+exit_connection_destroy:
+	gb_connection_destroy(connection);
+exit_mmc_free:
 	mmc_free_host(mmc);
 
 	return ret;
 }
 
-static void gb_sdio_connection_exit(struct gb_connection *connection)
+static void gb_sdio_remove(struct gpbridge_device *gpbdev)
 {
+	struct gb_sdio_host *host = gb_gpbridge_get_data(gpbdev);
+	struct gb_connection *connection = host->connection;
 	struct mmc_host *mmc;
-	struct gb_sdio_host *host = gb_connection_get_data(connection);
-
-	if (!host)
-		return;
 
 	mutex_lock(&host->lock);
 	host->removed = true;
@@ -788,19 +815,23 @@ static void gb_sdio_connection_exit(struct gb_connection *connection)
 
 	flush_workqueue(host->mrq_workqueue);
 	destroy_workqueue(host->mrq_workqueue);
+	gb_connection_disable_rx(connection);
 	mmc_remove_host(mmc);
+	gb_connection_disable(connection);
+	gb_connection_destroy(connection);
 	kfree(host->xfer_buffer);
 	mmc_free_host(mmc);
 }
 
-static struct gb_protocol sdio_protocol = {
-	.name			= "sdio",
-	.id			= GREYBUS_PROTOCOL_SDIO,
-	.major			= GB_SDIO_VERSION_MAJOR,
-	.minor			= GB_SDIO_VERSION_MINOR,
-	.connection_init	= gb_sdio_connection_init,
-	.connection_exit	= gb_sdio_connection_exit,
-	.request_recv		= gb_sdio_event_recv,
+static const struct gpbridge_device_id gb_sdio_id_table[] = {
+	{ GPBRIDGE_PROTOCOL(GREYBUS_PROTOCOL_SDIO) },
+	{ },
 };
 
-gb_builtin_protocol_driver(sdio_protocol);
+static struct gpbridge_driver sdio_driver = {
+	.name		= "sdio",
+	.probe		= gb_sdio_probe,
+	.remove		= gb_sdio_remove,
+	.id_table	= gb_sdio_id_table,
+};
+gb_gpbridge_builtin_driver(sdio_driver);

commit 0ec306324423444d3ee0222708ef9de7f5586b93
Author: Greg Kroah-Hartman <gregkh@google.com>
Date:   Tue Mar 22 14:30:35 2016 -0400

    greybus: convert drivers to use connection->private set/get
    
    This converts all drivers to use the gb_connection_get_data() and
    gb_connection_set_data() functions to make it a bit more explicit as to
    what is going on.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>
    Reviewed-by: Alex Elder <elder@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/sdio.c b/drivers/staging/greybus/sdio.c
index 9a20f0e0363d..d4cbcb972e94 100644
--- a/drivers/staging/greybus/sdio.c
+++ b/drivers/staging/greybus/sdio.c
@@ -201,15 +201,14 @@ static int _gb_sdio_process_events(struct gb_sdio_host *host, u8 event)
 
 static int gb_sdio_event_recv(u8 type, struct gb_operation *op)
 {
-	struct gb_connection *connection = op->connection;
-	struct gb_sdio_host *host = connection->private;
+	struct gb_sdio_host *host = gb_connection_get_data(op->connection);
 	struct gb_message *request;
 	struct gb_sdio_event_request *payload;
 	int ret =  0;
 	u8 event;
 
 	if (type != GB_SDIO_TYPE_EVENT) {
-		dev_err(&connection->bundle->dev,
+		dev_err(mmc_dev(host->mmc),
 			"unsupported unsolicited event: %u\n", type);
 		return -EINVAL;
 	}
@@ -723,7 +722,7 @@ static int gb_sdio_connection_init(struct gb_connection *connection)
 	host->removed = true;
 
 	host->connection = connection;
-	connection->private = host;
+	gb_connection_set_data(connection, host);
 
 	ret = gb_sdio_get_caps(host);
 	if (ret < 0)
@@ -767,7 +766,7 @@ static int gb_sdio_connection_init(struct gb_connection *connection)
 free_buffer:
 	kfree(host->xfer_buffer);
 free_mmc:
-	connection->private = NULL;
+	gb_connection_set_data(connection, NULL);
 	mmc_free_host(mmc);
 
 	return ret;
@@ -776,7 +775,7 @@ static int gb_sdio_connection_init(struct gb_connection *connection)
 static void gb_sdio_connection_exit(struct gb_connection *connection)
 {
 	struct mmc_host *mmc;
-	struct gb_sdio_host *host = connection->private;
+	struct gb_sdio_host *host = gb_connection_get_data(connection);
 
 	if (!host)
 		return;
@@ -784,7 +783,7 @@ static void gb_sdio_connection_exit(struct gb_connection *connection)
 	mutex_lock(&host->lock);
 	host->removed = true;
 	mmc = host->mmc;
-	connection->private = NULL;
+	gb_connection_set_data(connection, NULL);
 	mutex_unlock(&host->lock);
 
 	flush_workqueue(host->mrq_workqueue);

commit c7b07265046b5db56778dc8c2cfc9056413ec5ba
Author: Greg Kroah-Hartman <gregkh@google.com>
Date:   Sun Feb 28 14:42:54 2016 -0800

    greybus: gpbridge.h: move protocol init/exit prototypes
    
    Create gpbridge.h for the gpbridge-specific function prototypes, the
    rest of the greybus drivers don't care about them.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>
    Reviewed-by: Viresh Kumar <viresh.kumar@linaro.org>
    Reviewed-by: Johan Hovold <johan@hovoldconsulting.com>

diff --git a/drivers/staging/greybus/sdio.c b/drivers/staging/greybus/sdio.c
index da9093738d4a..9a20f0e0363d 100644
--- a/drivers/staging/greybus/sdio.c
+++ b/drivers/staging/greybus/sdio.c
@@ -15,6 +15,7 @@
 #include <linux/workqueue.h>
 
 #include "greybus.h"
+#include "gpbridge.h"
 
 struct gb_sdio_host {
 	struct gb_connection	*connection;

commit b933fa4a40962c77254405a5274c8927f53b5074
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Fri Dec 4 21:30:10 2015 +0530

    greybus: Prefix hexadecimal values with 0x while printing them
    
    To clearly specify the base for printed values, prefix hexadecimal
    values with 0x.
    
    Suggested-by: Johan Hovold <johan@hovoldconsulting.com>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Reviewed-by: Johan Hovold <johan@hovoldconsulting.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/sdio.c b/drivers/staging/greybus/sdio.c
index beb35747a4f8..da9093738d4a 100644
--- a/drivers/staging/greybus/sdio.c
+++ b/drivers/staging/greybus/sdio.c
@@ -398,7 +398,7 @@ static int gb_sdio_command(struct gb_sdio_host *host, struct mmc_command *cmd)
 		cmd_flags = GB_SDIO_RSP_R3_R4;
 		break;
 	default:
-		dev_err(mmc_dev(host->mmc), "cmd flag invalid %04x\n",
+		dev_err(mmc_dev(host->mmc), "cmd flag invalid 0x%04x\n",
 			mmc_resp_type(cmd));
 		ret = -EINVAL;
 		goto out;
@@ -418,7 +418,7 @@ static int gb_sdio_command(struct gb_sdio_host *host, struct mmc_command *cmd)
 		cmd_type = GB_SDIO_CMD_ADTC;
 		break;
 	default:
-		dev_err(mmc_dev(host->mmc), "cmd type invalid %04x\n",
+		dev_err(mmc_dev(host->mmc), "cmd type invalid 0x%04x\n",
 			mmc_cmd_type(cmd));
 		ret = -EINVAL;
 		goto out;

commit b6789ee55b99fbc26aa16e4f485397e86498bf51
Author: Rui Miguel Silva <rui.silva@linaro.org>
Date:   Thu Oct 15 23:56:52 2015 +0100

    greybus: sdio: some cleanups in command function
    
    Some cleanups in gb_sdio_command function, ret does not need to be
    initialize and mrq is already pointing to request, no need to get it
    from host.
    
    Signed-off-by: Rui Miguel Silva <rui.silva@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/sdio.c b/drivers/staging/greybus/sdio.c
index 201cfe534459..beb35747a4f8 100644
--- a/drivers/staging/greybus/sdio.c
+++ b/drivers/staging/greybus/sdio.c
@@ -379,7 +379,7 @@ static int gb_sdio_command(struct gb_sdio_host *host, struct mmc_command *cmd)
 	u8 cmd_flags;
 	u8 cmd_type;
 	int i;
-	int ret = 0;
+	int ret;
 
 	switch (mmc_resp_type(cmd)) {
 	case MMC_RSP_NONE:
@@ -488,7 +488,7 @@ static void gb_sdio_mrq_work(struct work_struct *work)
 		goto done;
 
 	if (mrq->data) {
-		ret = gb_sdio_transfer(host, host->mrq->data);
+		ret = gb_sdio_transfer(host, mrq->data);
 		if (ret < 0)
 			goto done;
 	}

commit 10ed1938767ec90a264b73b337ec17a0a674847a
Author: Rui Miguel Silva <rui.silva@linaro.org>
Date:   Thu Oct 15 23:56:51 2015 +0100

    greybus: sdio: send data block details at command request
    
    If SDIO request include data to be transfer send details (data blocks
    and block size) in command request, as it seems some controllers need
    this info prior to set the registers correctly.
    
    Signed-off-by: Rui Miguel Silva <rui.silva@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/sdio.c b/drivers/staging/greybus/sdio.c
index b5e4af379e7b..201cfe534459 100644
--- a/drivers/staging/greybus/sdio.c
+++ b/drivers/staging/greybus/sdio.c
@@ -373,8 +373,9 @@ static int gb_sdio_transfer(struct gb_sdio_host *host, struct mmc_data *data)
 
 static int gb_sdio_command(struct gb_sdio_host *host, struct mmc_command *cmd)
 {
-	struct gb_sdio_command_request request;
+	struct gb_sdio_command_request request = {0};
 	struct gb_sdio_command_response response;
+	struct mmc_data *data = host->mrq->data;
 	u8 cmd_flags;
 	u8 cmd_type;
 	int i;
@@ -427,6 +428,11 @@ static int gb_sdio_command(struct gb_sdio_host *host, struct mmc_command *cmd)
 	request.cmd_flags = cmd_flags;
 	request.cmd_type = cmd_type;
 	request.cmd_arg = cpu_to_le32(cmd->arg);
+	/* some controllers need to know at command time data details */
+	if (data) {
+		request.data_blocks = cpu_to_le16(data->blocks);
+		request.data_blksz = cpu_to_le16(data->blksz);
+	}
 
 	ret = gb_operation_sync(host->connection, GB_SDIO_TYPE_COMMAND,
 				&request, sizeof(request), &response,

commit 61c80575b90797bb3e74e2e2510eaa376bc8e4cb
Author: Greg Kroah-Hartman <gregkh@google.com>
Date:   Wed Oct 14 11:19:42 2015 -0700

    greybus: sdio: use the bundle struct device instead of the connector
    
    We are removing struct device from the gb_connection structure in the
    near future.  The gb_bundle structure's struct device should be used as
    a replacement.
    
    This patch moves the sdio driver to use the bundle pointer instead of
    the connection pointer.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>
    Reviewed-by: Alex Elder <elder@linaro.org>

diff --git a/drivers/staging/greybus/sdio.c b/drivers/staging/greybus/sdio.c
index aaca70e19e4a..b5e4af379e7b 100644
--- a/drivers/staging/greybus/sdio.c
+++ b/drivers/staging/greybus/sdio.c
@@ -208,7 +208,7 @@ static int gb_sdio_event_recv(u8 type, struct gb_operation *op)
 	u8 event;
 
 	if (type != GB_SDIO_TYPE_EVENT) {
-		dev_err(&connection->dev,
+		dev_err(&connection->bundle->dev,
 			"unsupported unsolicited event: %u\n", type);
 		return -EINVAL;
 	}
@@ -707,7 +707,7 @@ static int gb_sdio_connection_init(struct gb_connection *connection)
 	size_t max_buffer;
 	int ret = 0;
 
-	mmc = mmc_alloc_host(sizeof(*host), &connection->dev);
+	mmc = mmc_alloc_host(sizeof(*host), &connection->bundle->dev);
 	if (!mmc)
 		return -ENOMEM;
 
@@ -739,7 +739,7 @@ static int gb_sdio_connection_init(struct gb_connection *connection)
 	mutex_init(&host->lock);
 	spin_lock_init(&host->xfer);
 	host->mrq_workqueue = alloc_workqueue("mmc-%s", 0, 1,
-						dev_name(&connection->dev));
+					      dev_name(&connection->bundle->dev));
 	if (!host->mrq_workqueue) {
 		ret = -ENOMEM;
 		goto free_buffer;

commit f064b872e7a0ee48d5d33278aeb30ffa7ee1c5f5
Author: Rui Miguel Silva <rui.silva@linaro.org>
Date:   Thu Oct 8 12:10:54 2015 +0100

    greybus: sdio: clarify operator precedence
    
    When translating capabilities from greybus to mmc values add some
    parentheses to clarify operation precedence and avoid static analyses
    warnings.
    
    [sdio.c:81]: (style) Clarify calculation precedence for '&' and '?'
    
    Signed-off-by: Rui Miguel Silva <rui.silva@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/sdio.c b/drivers/staging/greybus/sdio.c
index 21a7b67e1417..aaca70e19e4a 100644
--- a/drivers/staging/greybus/sdio.c
+++ b/drivers/staging/greybus/sdio.c
@@ -55,30 +55,30 @@ static void _gb_sdio_set_host_caps(struct gb_sdio_host *host, u32 r)
 	u32 caps = 0;
 	u32 caps2 = 0;
 
-	caps = (r & GB_SDIO_CAP_NONREMOVABLE ? MMC_CAP_NONREMOVABLE : 0) |
-		(r & GB_SDIO_CAP_4_BIT_DATA ? MMC_CAP_4_BIT_DATA : 0) |
-		(r & GB_SDIO_CAP_8_BIT_DATA ? MMC_CAP_8_BIT_DATA : 0) |
-		(r & GB_SDIO_CAP_MMC_HS ? MMC_CAP_MMC_HIGHSPEED : 0) |
-		(r & GB_SDIO_CAP_SD_HS ? MMC_CAP_SD_HIGHSPEED : 0) |
-		(r & GB_SDIO_CAP_ERASE ? MMC_CAP_ERASE : 0) |
-		(r & GB_SDIO_CAP_1_2V_DDR ? MMC_CAP_1_2V_DDR : 0) |
-		(r & GB_SDIO_CAP_1_8V_DDR ? MMC_CAP_1_8V_DDR : 0) |
-		(r & GB_SDIO_CAP_POWER_OFF_CARD ? MMC_CAP_POWER_OFF_CARD : 0) |
-		(r & GB_SDIO_CAP_UHS_SDR12 ? MMC_CAP_UHS_SDR12 : 0) |
-		(r & GB_SDIO_CAP_UHS_SDR25 ? MMC_CAP_UHS_SDR25 : 0) |
-		(r & GB_SDIO_CAP_UHS_SDR50 ? MMC_CAP_UHS_SDR50 : 0) |
-		(r & GB_SDIO_CAP_UHS_SDR104 ? MMC_CAP_UHS_SDR104 : 0) |
-		(r & GB_SDIO_CAP_UHS_DDR50 ? MMC_CAP_UHS_DDR50 : 0) |
-		(r & GB_SDIO_CAP_DRIVER_TYPE_A ? MMC_CAP_DRIVER_TYPE_A : 0) |
-		(r & GB_SDIO_CAP_DRIVER_TYPE_C ? MMC_CAP_DRIVER_TYPE_C : 0) |
-		(r & GB_SDIO_CAP_DRIVER_TYPE_D ? MMC_CAP_DRIVER_TYPE_D : 0);
-
-	caps2 = (r & GB_SDIO_CAP_HS200_1_2V ? MMC_CAP2_HS200_1_2V_SDR : 0) |
+	caps = ((r & GB_SDIO_CAP_NONREMOVABLE) ? MMC_CAP_NONREMOVABLE : 0) |
+		((r & GB_SDIO_CAP_4_BIT_DATA) ? MMC_CAP_4_BIT_DATA : 0) |
+		((r & GB_SDIO_CAP_8_BIT_DATA) ? MMC_CAP_8_BIT_DATA : 0) |
+		((r & GB_SDIO_CAP_MMC_HS) ? MMC_CAP_MMC_HIGHSPEED : 0) |
+		((r & GB_SDIO_CAP_SD_HS) ? MMC_CAP_SD_HIGHSPEED : 0) |
+		((r & GB_SDIO_CAP_ERASE) ? MMC_CAP_ERASE : 0) |
+		((r & GB_SDIO_CAP_1_2V_DDR) ? MMC_CAP_1_2V_DDR : 0) |
+		((r & GB_SDIO_CAP_1_8V_DDR) ? MMC_CAP_1_8V_DDR : 0) |
+		((r & GB_SDIO_CAP_POWER_OFF_CARD) ? MMC_CAP_POWER_OFF_CARD : 0) |
+		((r & GB_SDIO_CAP_UHS_SDR12) ? MMC_CAP_UHS_SDR12 : 0) |
+		((r & GB_SDIO_CAP_UHS_SDR25) ? MMC_CAP_UHS_SDR25 : 0) |
+		((r & GB_SDIO_CAP_UHS_SDR50) ? MMC_CAP_UHS_SDR50 : 0) |
+		((r & GB_SDIO_CAP_UHS_SDR104) ? MMC_CAP_UHS_SDR104 : 0) |
+		((r & GB_SDIO_CAP_UHS_DDR50) ? MMC_CAP_UHS_DDR50 : 0) |
+		((r & GB_SDIO_CAP_DRIVER_TYPE_A) ? MMC_CAP_DRIVER_TYPE_A : 0) |
+		((r & GB_SDIO_CAP_DRIVER_TYPE_C) ? MMC_CAP_DRIVER_TYPE_C : 0) |
+		((r & GB_SDIO_CAP_DRIVER_TYPE_D) ? MMC_CAP_DRIVER_TYPE_D : 0);
+
+	caps2 = ((r & GB_SDIO_CAP_HS200_1_2V) ? MMC_CAP2_HS200_1_2V_SDR : 0) |
 #ifdef MMC_HS400_SUPPORTED
-		(r & GB_SDIO_CAP_HS400_1_2V ? MMC_CAP2_HS400_1_2V : 0) |
-		(r & GB_SDIO_CAP_HS400_1_8V ? MMC_CAP2_HS400_1_8V : 0) |
+		((r & GB_SDIO_CAP_HS400_1_2V) ? MMC_CAP2_HS400_1_2V : 0) |
+		((r & GB_SDIO_CAP_HS400_1_8V) ? MMC_CAP2_HS400_1_8V : 0) |
 #endif
-		(r & GB_SDIO_CAP_HS200_1_8V ? MMC_CAP2_HS200_1_8V_SDR : 0);
+		((r & GB_SDIO_CAP_HS200_1_8V) ? MMC_CAP2_HS200_1_8V_SDR : 0);
 
 	host->mmc->caps = caps | MMC_CAP_NEEDS_POLL;
 	host->mmc->caps2 = caps2;

commit dcb8d8d3e1f929e155cc262d9fbe060f94c02e35
Author: Rui Miguel Silva <rui.silva@linaro.org>
Date:   Thu Oct 8 12:10:53 2015 +0100

    greybus: sdio: convert greybus ocr values to mmc ones
    
    It was missing the translation between the ocr vdd values of greybus to
    mmc_core values. This would make the detection of range voltage fail.
    
    mmc: host doesn't support card's voltages
    
    Signed-off-by: Rui Miguel Silva <rui.silva@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/sdio.c b/drivers/staging/greybus/sdio.c
index e5e3b77a2d15..21a7b67e1417 100644
--- a/drivers/staging/greybus/sdio.c
+++ b/drivers/staging/greybus/sdio.c
@@ -87,12 +87,35 @@ static void _gb_sdio_set_host_caps(struct gb_sdio_host *host, u32 r)
 		host->card_present = true;
 }
 
+static u32 _gb_sdio_get_host_ocr(u32 ocr)
+{
+	return (((ocr & GB_SDIO_VDD_165_195) ? MMC_VDD_165_195 : 0) |
+		((ocr & GB_SDIO_VDD_20_21) ? MMC_VDD_20_21 : 0) |
+		((ocr & GB_SDIO_VDD_21_22) ? MMC_VDD_21_22 : 0) |
+		((ocr & GB_SDIO_VDD_22_23) ? MMC_VDD_22_23 : 0) |
+		((ocr & GB_SDIO_VDD_23_24) ? MMC_VDD_23_24 : 0) |
+		((ocr & GB_SDIO_VDD_24_25) ? MMC_VDD_24_25 : 0) |
+		((ocr & GB_SDIO_VDD_25_26) ? MMC_VDD_25_26 : 0) |
+		((ocr & GB_SDIO_VDD_26_27) ? MMC_VDD_26_27 : 0) |
+		((ocr & GB_SDIO_VDD_27_28) ? MMC_VDD_27_28 : 0) |
+		((ocr & GB_SDIO_VDD_28_29) ? MMC_VDD_28_29 : 0) |
+		((ocr & GB_SDIO_VDD_29_30) ? MMC_VDD_29_30 : 0) |
+		((ocr & GB_SDIO_VDD_30_31) ? MMC_VDD_30_31 : 0) |
+		((ocr & GB_SDIO_VDD_31_32) ? MMC_VDD_31_32 : 0) |
+		((ocr & GB_SDIO_VDD_32_33) ? MMC_VDD_32_33 : 0) |
+		((ocr & GB_SDIO_VDD_33_34) ? MMC_VDD_33_34 : 0) |
+		((ocr & GB_SDIO_VDD_34_35) ? MMC_VDD_34_35 : 0) |
+		((ocr & GB_SDIO_VDD_35_36) ? MMC_VDD_35_36 : 0)
+		);
+}
+
 static int gb_sdio_get_caps(struct gb_sdio_host *host)
 {
 	struct gb_sdio_get_caps_response response;
 	struct mmc_host *mmc = host->mmc;
 	u16 data_max;
 	u32 blksz;
+	u32 ocr;
 	u32 r;
 	int ret;
 
@@ -117,7 +140,8 @@ static int gb_sdio_get_caps(struct gb_sdio_host *host)
 	host->data_max = data_max;
 
 	/* get ocr supported values */
-	mmc->ocr_avail = le32_to_cpu(response.ocr);
+	ocr = _gb_sdio_get_host_ocr(le32_to_cpu(response.ocr));
+	mmc->ocr_avail = ocr;
 	mmc->ocr_avail_sdio = mmc->ocr_avail;
 	mmc->ocr_avail_sd = mmc->ocr_avail;
 	mmc->ocr_avail_mmc = mmc->ocr_avail;

commit 6cac7dc3aaaef8161ac80c5980cec10427996abf
Author: Rui Miguel Silva <rui.silva@linaro.org>
Date:   Thu Oct 8 12:10:52 2015 +0100

    greybus: sdio: fix card removable detection
    
    In kernel versions bellow 3.15, the mmc_card_is_removable helper
    function has an extra check used for a suspend/resume hack. This made
    the gd_sdio_process_event to behave badly handling the module card
    insert event in that versions.
    
    So, just test bit the flag that we need, instead of using the helper
    function. This way will work in all kernel versions.
    
    Signed-off-by: Rui Miguel Silva <rui.silva@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/sdio.c b/drivers/staging/greybus/sdio.c
index ff68956108bf..e5e3b77a2d15 100644
--- a/drivers/staging/greybus/sdio.c
+++ b/drivers/staging/greybus/sdio.c
@@ -144,7 +144,7 @@ static int _gb_sdio_process_events(struct gb_sdio_host *host, u8 event)
 	u8 state_changed = 0;
 
 	if (event & GB_SDIO_CARD_INSERTED) {
-		if (!mmc_card_is_removable(host->mmc))
+		if (host->mmc->caps & MMC_CAP_NONREMOVABLE)
 			return 0;
 		if (host->card_present)
 			return 0;
@@ -153,7 +153,7 @@ static int _gb_sdio_process_events(struct gb_sdio_host *host, u8 event)
 	}
 
 	if (event & GB_SDIO_CARD_REMOVED) {
-		if (!mmc_card_is_removable(host->mmc))
+		if (host->mmc->caps & MMC_CAP_NONREMOVABLE)
 			return 0;
 		if (!(host->card_present))
 			return 0;

commit e0f875c336f792d4c2b0d09436426724ae14713e
Author: Rui Miguel Silva <rui.silva@linaro.org>
Date:   Thu Oct 8 12:10:51 2015 +0100

    greybus: sdio: add field to get_caps response
    
    Frequency maximum and minimum are needed to complete the configuration
    of the controller. Add them to get_caps response operation.
    
    Signed-off-by: Rui Miguel Silva <rui.silva@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/sdio.c b/drivers/staging/greybus/sdio.c
index bfa1181074d6..ff68956108bf 100644
--- a/drivers/staging/greybus/sdio.c
+++ b/drivers/staging/greybus/sdio.c
@@ -122,6 +122,10 @@ static int gb_sdio_get_caps(struct gb_sdio_host *host)
 	mmc->ocr_avail_sd = mmc->ocr_avail;
 	mmc->ocr_avail_mmc = mmc->ocr_avail;
 
+	/* get frequency range values */
+	mmc->f_min = le32_to_cpu(response.f_min);
+	mmc->f_max = le32_to_cpu(response.f_max);
+
 	return 0;
 }
 

commit b9154df5cfd2d4cc180f425f0b26e095ce1ffdbc
Author: Johan Hovold <johan@hovoldconsulting.com>
Date:   Mon Sep 14 20:19:04 2015 +0200

    greybus: sdio: fix work-queue leak and use-after-free
    
    A single global work-queue pointer was used for the per-connection
    workqueue, something which would lead to memory leaks and all sorts of
    bad things if there are ever more than one SDIO connection in a system.
    
    Also add the missing error handling when allocating the queue.
    
    Signed-off-by: Johan Hovold <johan@hovoldconsulting.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/sdio.c b/drivers/staging/greybus/sdio.c
index 14617e31782e..bfa1181074d6 100644
--- a/drivers/staging/greybus/sdio.c
+++ b/drivers/staging/greybus/sdio.c
@@ -25,6 +25,7 @@ struct gb_sdio_host {
 	void			*xfer_buffer;
 	spinlock_t		xfer;	/* lock to cancel ongoing transfer */
 	bool			xfer_stop;
+	struct workqueue_struct	*mrq_workqueue;
 	struct work_struct	mrqwork;
 	u8			queued_events;
 	bool			removed;
@@ -32,7 +33,6 @@ struct gb_sdio_host {
 	bool			read_only;
 };
 
-static struct workqueue_struct *gb_sdio_mrq_workqueue;
 
 #define GB_SDIO_RSP_R1_R5_R6_R7	(GB_SDIO_RSP_PRESENT | GB_SDIO_RSP_CRC | \
 				 GB_SDIO_RSP_OPCODE)
@@ -497,7 +497,7 @@ static void gb_mmc_request(struct mmc_host *mmc, struct mmc_request *mrq)
 		goto out;
 	}
 
-	queue_work(gb_sdio_mrq_workqueue, &host->mrqwork);
+	queue_work(host->mrq_workqueue, &host->mrqwork);
 
 	mutex_unlock(&host->lock);
 	return;
@@ -710,7 +710,12 @@ static int gb_sdio_connection_init(struct gb_connection *connection)
 	}
 	mutex_init(&host->lock);
 	spin_lock_init(&host->xfer);
-	gb_sdio_mrq_workqueue = alloc_workqueue("gb_sdio_mrq", 0, 1);
+	host->mrq_workqueue = alloc_workqueue("mmc-%s", 0, 1,
+						dev_name(&connection->dev));
+	if (!host->mrq_workqueue) {
+		ret = -ENOMEM;
+		goto free_buffer;
+	}
 	INIT_WORK(&host->mrqwork, gb_sdio_mrq_work);
 
 	ret = mmc_add_host(mmc);
@@ -723,9 +728,9 @@ static int gb_sdio_connection_init(struct gb_connection *connection)
 	return ret;
 
 free_work:
-	destroy_workqueue(gb_sdio_mrq_workqueue);
+	destroy_workqueue(host->mrq_workqueue);
+free_buffer:
 	kfree(host->xfer_buffer);
-
 free_mmc:
 	connection->private = NULL;
 	mmc_free_host(mmc);
@@ -747,8 +752,8 @@ static void gb_sdio_connection_exit(struct gb_connection *connection)
 	connection->private = NULL;
 	mutex_unlock(&host->lock);
 
-	flush_workqueue(gb_sdio_mrq_workqueue);
-	destroy_workqueue(gb_sdio_mrq_workqueue);
+	flush_workqueue(host->mrq_workqueue);
+	destroy_workqueue(host->mrq_workqueue);
 	mmc_remove_host(mmc);
 	kfree(host->xfer_buffer);
 	mmc_free_host(mmc);

commit e5265266ec6360702feb6ff69d1aec9e318ae1f6
Author: Johan Hovold <johan@hovoldconsulting.com>
Date:   Mon Sep 14 20:19:03 2015 +0200

    greybus: sdio: fix tear-down use-after-free
    
    The mmc-driver private data must not be accessed after mmc_free_host()
    has released it.
    
    Signed-off-by: Johan Hovold <johan@hovoldconsulting.com>
    Reviewed-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/sdio.c b/drivers/staging/greybus/sdio.c
index 24b2e3152fa1..14617e31782e 100644
--- a/drivers/staging/greybus/sdio.c
+++ b/drivers/staging/greybus/sdio.c
@@ -750,8 +750,8 @@ static void gb_sdio_connection_exit(struct gb_connection *connection)
 	flush_workqueue(gb_sdio_mrq_workqueue);
 	destroy_workqueue(gb_sdio_mrq_workqueue);
 	mmc_remove_host(mmc);
-	mmc_free_host(mmc);
 	kfree(host->xfer_buffer);
+	mmc_free_host(mmc);
 }
 
 static struct gb_protocol sdio_protocol = {

commit 7071ca1df5e26949e6a24684f52d45ca18f07077
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Tue Aug 11 07:36:09 2015 +0530

    greybus: sdio: Drop get_version support
    
    This is done from a common place now, no need to replicate it.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/sdio.c b/drivers/staging/greybus/sdio.c
index 345cffff7db0..24b2e3152fa1 100644
--- a/drivers/staging/greybus/sdio.c
+++ b/drivers/staging/greybus/sdio.c
@@ -18,8 +18,6 @@
 
 struct gb_sdio_host {
 	struct gb_connection	*connection;
-	u8			version_major;
-	u8			version_minor;
 	struct mmc_host		*mmc;
 	struct mmc_request	*mrq;
 	struct mutex		lock;	/* lock for this host */
@@ -36,9 +34,6 @@ struct gb_sdio_host {
 
 static struct workqueue_struct *gb_sdio_mrq_workqueue;
 
-/* Define get_version() routine */
-define_get_version(gb_sdio_host, SDIO);
-
 #define GB_SDIO_RSP_R1_R5_R6_R7	(GB_SDIO_RSP_PRESENT | GB_SDIO_RSP_CRC | \
 				 GB_SDIO_RSP_OPCODE)
 #define GB_SDIO_RSP_R3_R4	(GB_SDIO_RSP_PRESENT)
@@ -695,10 +690,6 @@ static int gb_sdio_connection_init(struct gb_connection *connection)
 	host->connection = connection;
 	connection->private = host;
 
-	ret = get_version(host);
-	if (ret < 0)
-		goto free_mmc;
-
 	ret = gb_sdio_get_caps(host);
 	if (ret < 0)
 		goto free_mmc;

commit f1f6fa44ae49e91c0a5fe9e0c6e5614e6aa22283
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Sat Aug 8 08:09:32 2015 +0530

    greybus: sdio: error out only for smaller payloads received
    
    != was used in place of <, while comparing expected and actual payload
    size. The module may be running a higher version of the protocol and
    might have some extra fields (towards the end) in the structure, and the
    AP needs to ignore them.
    
    This also updates the print (expected-payload-size <
    actual-payload-size), when the size doesn't match for requests received
    by the module. This gives more details required for debugging.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/sdio.c b/drivers/staging/greybus/sdio.c
index a709bd64f824..345cffff7db0 100644
--- a/drivers/staging/greybus/sdio.c
+++ b/drivers/staging/greybus/sdio.c
@@ -192,8 +192,9 @@ static int gb_sdio_event_recv(u8 type, struct gb_operation *op)
 
 	request = op->request;
 
-	if (request->payload_size != sizeof(*payload)) {
-		dev_err(mmc_dev(host->mmc), "wrong event size received\n");
+	if (request->payload_size < sizeof(*payload)) {
+		dev_err(mmc_dev(host->mmc), "wrong event size received (%zu < %zu)\n",
+			request->payload_size, sizeof(*payload));
 		return -EINVAL;
 	}
 

commit 9ddf133371fd87ddf543e8b26389ca26f2d9fc3c
Author: Rui Miguel Silva <rui.silva@linaro.org>
Date:   Thu Jul 2 19:11:37 2015 +0100

    greybus: sdio: fix transfer buffer handling and blocks counting
    
    Fix copy to/from scatterlist destination buffer offset, fix
    calculation of blocks to be transfer and make a more verbose out of
    error when the blocks receive/send do not match.
    
    Signed-off-by: Rui Miguel Silva <rui.silva@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/sdio.c b/drivers/staging/greybus/sdio.c
index 33d5fe69ed63..a709bd64f824 100644
--- a/drivers/staging/greybus/sdio.c
+++ b/drivers/staging/greybus/sdio.c
@@ -234,22 +234,25 @@ static int _gb_sdio_send(struct gb_sdio_host *host, struct mmc_data *data,
 	request->data_blocks = cpu_to_le16(nblocks);
 	request->data_blksz = cpu_to_le16(data->blksz);
 
-	copied = sg_pcopy_to_buffer(sg, sg_len, &request->data[0] + skip, len,
-				    skip);
+	copied = sg_pcopy_to_buffer(sg, sg_len, &request->data[0], len, skip);
 
 	if (copied != len)
 		return -EINVAL;
 
 	ret = gb_operation_sync(host->connection, GB_SDIO_TYPE_TRANSFER,
-				request, len, &response, sizeof(response));
+				request, len + sizeof(*request),
+				&response, sizeof(response));
 	if (ret < 0)
 		return ret;
 
 	send_blocks = le16_to_cpu(response.data_blocks);
 	send_blksz = le16_to_cpu(response.data_blksz);
 
-	if (len != send_blksz * send_blocks)
+	if (len != send_blksz * send_blocks) {
+		dev_err(mmc_dev(host->mmc), "send: size received: %zu != %d\n",
+			len, send_blksz * send_blocks);
 		return -EINVAL;
+	}
 
 	return ret;
 }
@@ -275,18 +278,22 @@ static int _gb_sdio_recv(struct gb_sdio_host *host, struct mmc_data *data,
 	response = host->xfer_buffer;
 
 	ret = gb_operation_sync(host->connection, GB_SDIO_TYPE_TRANSFER,
-				&request, sizeof(request), response, len);
+				&request, sizeof(request), response, len +
+				sizeof(*response));
 	if (ret < 0)
 		return ret;
 
 	recv_blocks = le16_to_cpu(response->data_blocks);
 	recv_blksz = le16_to_cpu(response->data_blksz);
 
-	if (len != recv_blksz * recv_blocks)
+	if (len != recv_blksz * recv_blocks) {
+		dev_err(mmc_dev(host->mmc), "recv: size received: %d != %zu\n",
+			recv_blksz * recv_blocks, len);
 		return -EINVAL;
+	}
 
-	copied = sg_pcopy_from_buffer(sg, sg_len, &response->data[0] + skip,
-				      len, skip);
+	copied = sg_pcopy_from_buffer(sg, sg_len, &response->data[0], len,
+				      skip);
 	if (copied != len)
 		return -EINVAL;
 
@@ -318,7 +325,7 @@ static int gb_sdio_transfer(struct gb_sdio_host *host, struct mmc_data *data)
 		}
 		spin_unlock(&host->xfer);
 		len = min(left, host->data_max);
-		nblocks = do_div(len, data->blksz);
+		nblocks = len / data->blksz;
 		len = nblocks * data->blksz;
 
 		if (data->flags & MMC_DATA_READ) {

commit f85451d8f58cd6df8643838b249016449f4d6218
Author: Rui Miguel Silva <rui.silva@linaro.org>
Date:   Thu Jul 2 19:11:36 2015 +0100

    greybus: sdio: add need poll to host caps
    
    As we do not have, yet, a event callback to notify core about changes
    we add the MMC_CAP_NEEDS_POLL capability to the rest of the caps
    received from the module.
    
    Signed-off-by: Rui Miguel Silva <rui.silva@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/sdio.c b/drivers/staging/greybus/sdio.c
index 544dbda82460..33d5fe69ed63 100644
--- a/drivers/staging/greybus/sdio.c
+++ b/drivers/staging/greybus/sdio.c
@@ -85,7 +85,7 @@ static void _gb_sdio_set_host_caps(struct gb_sdio_host *host, u32 r)
 #endif
 		(r & GB_SDIO_CAP_HS200_1_8V ? MMC_CAP2_HS200_1_8V_SDR : 0);
 
-	host->mmc->caps = caps;
+	host->mmc->caps = caps | MMC_CAP_NEEDS_POLL;
 	host->mmc->caps2 = caps2;
 
 	if (caps & MMC_CAP_NONREMOVABLE)

commit 73f4a5217968d51d9685732512d268c71b78a347
Author: Rui Miguel Silva <rui.silva@linaro.org>
Date:   Thu Jul 2 19:11:35 2015 +0100

    greybus: sdio: check number of blocks in transfer
    
    Before initiating a transfers, check if the command (for single block)
    match the number of blocks in the request.
    
    While at it, fix also a missing break.
    
    Signed-off-by: Rui Miguel Silva <rui.silva@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/sdio.c b/drivers/staging/greybus/sdio.c
index 8e7b7ba341dc..544dbda82460 100644
--- a/drivers/staging/greybus/sdio.c
+++ b/drivers/staging/greybus/sdio.c
@@ -47,6 +47,14 @@ define_get_version(gb_sdio_host, SDIO);
 #define GB_SDIO_RSP_R1B		(GB_SDIO_RSP_PRESENT | GB_SDIO_RSP_CRC | \
 				 GB_SDIO_RSP_OPCODE | GB_SDIO_RSP_BUSY)
 
+static inline bool single_op(struct mmc_command *cmd)
+{
+	uint32_t opcode = cmd->opcode;
+
+	return opcode == MMC_WRITE_BLOCK ||
+	       opcode == MMC_READ_SINGLE_BLOCK;
+}
+
 static void _gb_sdio_set_host_caps(struct gb_sdio_host *host, u32 r)
 {
 	u32 caps = 0;
@@ -292,6 +300,11 @@ static int gb_sdio_transfer(struct gb_sdio_host *host, struct mmc_data *data)
 	int ret = 0;
 	u16 nblocks;
 
+	if (single_op(data->mrq->cmd) && data->blocks > 1) {
+		ret = -ETIMEDOUT;
+		goto out;
+	}
+
 	left = data->blksz * data->blocks;
 
 	while (left) {
@@ -351,6 +364,7 @@ static int gb_sdio_command(struct gb_sdio_host *host, struct mmc_command *cmd)
 		break;
 	case MMC_RSP_R3:
 		cmd_flags = GB_SDIO_RSP_R3_R4;
+		break;
 	default:
 		dev_err(mmc_dev(host->mmc), "cmd flag invalid %04x\n",
 			mmc_resp_type(cmd));

commit 882edf59fcfa400547bdb509e67f2266471f838d
Author: Rui Miguel Silva <rui.silva@linaro.org>
Date:   Thu Jul 2 19:11:34 2015 +0100

    greybus: sdio: pass only data pointer to tranfer funtion
    
    No need to pass the all request to the transfer related funtctions.
    
    Signed-off-by: Rui Miguel Silva <rui.silva@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/sdio.c b/drivers/staging/greybus/sdio.c
index 8dd833eb9301..8e7b7ba341dc 100644
--- a/drivers/staging/greybus/sdio.c
+++ b/drivers/staging/greybus/sdio.c
@@ -285,9 +285,8 @@ static int _gb_sdio_recv(struct gb_sdio_host *host, struct mmc_data *data,
 	return 0;
 }
 
-static int gb_sdio_transfer(struct gb_sdio_host *host, struct mmc_request *mrq)
+static int gb_sdio_transfer(struct gb_sdio_host *host, struct mmc_data *data)
 {
-	struct mmc_data *data = mrq->data;
 	size_t left, len;
 	off_t skip = 0;
 	int ret = 0;
@@ -438,7 +437,7 @@ static void gb_sdio_mrq_work(struct work_struct *work)
 		goto done;
 
 	if (mrq->data) {
-		ret = gb_sdio_transfer(host, host->mrq);
+		ret = gb_sdio_transfer(host, host->mrq->data);
 		if (ret < 0)
 			goto done;
 	}

commit 7a5cd5aea29a6fa0d99fb3b667b96b8d5f4e596c
Author: Rui Miguel Silva <rui.silva@linaro.org>
Date:   Thu Jul 2 19:11:33 2015 +0100

    greybus: sdio: fix call to stop command if no data exist
    
    If data is not available the stop command could dereference NULL.
    Fetch the stop command directly from the request instead.
    
    Signed-off-by: Rui Miguel Silva <rui.silva@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/sdio.c b/drivers/staging/greybus/sdio.c
index f6adf0908d2e..8dd833eb9301 100644
--- a/drivers/staging/greybus/sdio.c
+++ b/drivers/staging/greybus/sdio.c
@@ -443,8 +443,8 @@ static void gb_sdio_mrq_work(struct work_struct *work)
 			goto done;
 	}
 
-	if (mrq->data->stop) {
-		ret = gb_sdio_command(host, mrq->data->stop);
+	if (mrq->stop) {
+		ret = gb_sdio_command(host, mrq->stop);
 		if (ret < 0)
 			goto done;
 	}

commit 08ccc9be680debdeb9eb2dcaa83c5fc7cd71f487
Author: Rui Miguel Silva <rui.silva@linaro.org>
Date:   Thu Jul 2 19:11:32 2015 +0100

    greybus: sdio: fix return of get_cd and get_ro
    
    Functions were returning the wrong flag for the expected value. Swap
    them.
    
    Signed-off-by: Rui Miguel Silva <rui.silva@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/sdio.c b/drivers/staging/greybus/sdio.c
index 53cb46f6f7c8..f6adf0908d2e 100644
--- a/drivers/staging/greybus/sdio.c
+++ b/drivers/staging/greybus/sdio.c
@@ -635,7 +635,7 @@ static int gb_mmc_get_ro(struct mmc_host *mmc)
 	if (host->removed)
 		return -ESHUTDOWN;
 	mutex_unlock(&host->lock);
-	return host->card_present;
+	return host->read_only;
 }
 
 static int gb_mmc_get_cd(struct mmc_host *mmc)
@@ -646,7 +646,7 @@ static int gb_mmc_get_cd(struct mmc_host *mmc)
 	if (host->removed)
 		return -ESHUTDOWN;
 	mutex_unlock(&host->lock);
-	return host->read_only;
+	return host->card_present;
 }
 
 static const struct mmc_host_ops gb_sdio_ops = {

commit c36d31cbc57635f7e66176d84d7b8688796a01d3
Author: Rui Miguel Silva <rui.silva@linaro.org>
Date:   Thu Jul 2 19:11:31 2015 +0100

    greybus: sdio: rework of event handler
    
    Between the time connection with module is up and the host is added,
    we can receive events (card inserted/removed, write protection
    switch), so until the setup is complete we queue the events received
    and handle them after.
    
    Signed-off-by: Rui Miguel Silva <rui.silva@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/sdio.c b/drivers/staging/greybus/sdio.c
index e842cae7a5bd..53cb46f6f7c8 100644
--- a/drivers/staging/greybus/sdio.c
+++ b/drivers/staging/greybus/sdio.c
@@ -28,6 +28,7 @@ struct gb_sdio_host {
 	spinlock_t		xfer;	/* lock to cancel ongoing transfer */
 	bool			xfer_stop;
 	struct work_struct	mrqwork;
+	u8			queued_events;
 	bool			removed;
 	bool			card_present;
 	bool			read_only;
@@ -121,54 +122,40 @@ static int gb_sdio_get_caps(struct gb_sdio_host *host)
 	return 0;
 }
 
-static int gb_sdio_event_recv(u8 type, struct gb_operation *op)
+static void _gb_queue_event(struct gb_sdio_host *host, u8 event)
 {
-	struct gb_connection *connection = op->connection;
-	struct gb_sdio_host *host = connection->private;
-	struct gb_message *request;
-	struct gb_sdio_event_request *payload;
-	u8 state_changed = 0;
-	u8 event;
-
-	if (type != GB_SDIO_TYPE_EVENT) {
-		dev_err(&connection->dev,
-			"unsupported unsolicited event: %u\n", type);
-		return -EINVAL;
-	}
-
-	request = op->request;
+	if (event & GB_SDIO_CARD_INSERTED)
+		host->queued_events &= ~GB_SDIO_CARD_REMOVED;
+	else if (event & GB_SDIO_CARD_REMOVED)
+		host->queued_events &= ~GB_SDIO_CARD_INSERTED;
 
-	if (request->payload_size != sizeof(*payload)) {
-		dev_err(mmc_dev(host->mmc), "wrong event size received\n");
-		return -EINVAL;
-	}
+	host->queued_events |= event;
+}
 
-	payload = request->payload;
-	event = payload->event;
+static int _gb_sdio_process_events(struct gb_sdio_host *host, u8 event)
+{
+	u8 state_changed = 0;
 
-	switch (event) {
-	case GB_SDIO_CARD_INSERTED:
+	if (event & GB_SDIO_CARD_INSERTED) {
 		if (!mmc_card_is_removable(host->mmc))
 			return 0;
 		if (host->card_present)
 			return 0;
 		host->card_present = true;
 		state_changed = 1;
-		break;
-	case GB_SDIO_CARD_REMOVED:
+	}
+
+	if (event & GB_SDIO_CARD_REMOVED) {
 		if (!mmc_card_is_removable(host->mmc))
 			return 0;
 		if (!(host->card_present))
 			return 0;
 		host->card_present = false;
 		state_changed = 1;
-		break;
-	case GB_SDIO_WP:
+	}
+
+	if (event & GB_SDIO_WP) {
 		host->read_only = true;
-		break;
-	default:
-		dev_err(mmc_dev(host->mmc), "wrong event received %d\n", event);
-		return -EINVAL;
 	}
 
 	if (state_changed) {
@@ -180,6 +167,39 @@ static int gb_sdio_event_recv(u8 type, struct gb_operation *op)
 	return 0;
 }
 
+static int gb_sdio_event_recv(u8 type, struct gb_operation *op)
+{
+	struct gb_connection *connection = op->connection;
+	struct gb_sdio_host *host = connection->private;
+	struct gb_message *request;
+	struct gb_sdio_event_request *payload;
+	int ret =  0;
+	u8 event;
+
+	if (type != GB_SDIO_TYPE_EVENT) {
+		dev_err(&connection->dev,
+			"unsupported unsolicited event: %u\n", type);
+		return -EINVAL;
+	}
+
+	request = op->request;
+
+	if (request->payload_size != sizeof(*payload)) {
+		dev_err(mmc_dev(host->mmc), "wrong event size received\n");
+		return -EINVAL;
+	}
+
+	payload = request->payload;
+	event = payload->event;
+
+	if (host->removed)
+		_gb_queue_event(host, event);
+	else
+		ret = _gb_sdio_process_events(host, event);
+
+	return ret;
+}
+
 static int gb_sdio_set_ios(struct gb_sdio_host *host,
 			   struct gb_sdio_set_ios_request *request)
 {
@@ -649,6 +669,7 @@ static int gb_sdio_connection_init(struct gb_connection *connection)
 
 	host = mmc_priv(mmc);
 	host->mmc = mmc;
+	host->removed = true;
 
 	host->connection = connection;
 	connection->private = host;
@@ -683,6 +704,9 @@ static int gb_sdio_connection_init(struct gb_connection *connection)
 	ret = mmc_add_host(mmc);
 	if (ret < 0)
 		goto free_work;
+	host->removed = false;
+	ret = _gb_sdio_process_events(host, host->queued_events);
+	host->queued_events = 0;
 
 	return ret;
 

commit ef0cc0ec8d80a18c83aec41321ebeba639cfa09a
Author: Rui Miguel Silva <rui.silva@linaro.org>
Date:   Thu Jul 2 19:11:30 2015 +0100

    greybus: sdio: split cmd_flags to there meaning
    
    Instead of using values in the command cmd_flags field use the real
    flags in a bit mask.
    
    Signed-off-by: Rui Miguel Silva <rui.silva@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/sdio.c b/drivers/staging/greybus/sdio.c
index f028e14fc918..e842cae7a5bd 100644
--- a/drivers/staging/greybus/sdio.c
+++ b/drivers/staging/greybus/sdio.c
@@ -38,6 +38,14 @@ static struct workqueue_struct *gb_sdio_mrq_workqueue;
 /* Define get_version() routine */
 define_get_version(gb_sdio_host, SDIO);
 
+#define GB_SDIO_RSP_R1_R5_R6_R7	(GB_SDIO_RSP_PRESENT | GB_SDIO_RSP_CRC | \
+				 GB_SDIO_RSP_OPCODE)
+#define GB_SDIO_RSP_R3_R4	(GB_SDIO_RSP_PRESENT)
+#define GB_SDIO_RSP_R2		(GB_SDIO_RSP_PRESENT | GB_SDIO_RSP_CRC | \
+				 GB_SDIO_RSP_136)
+#define GB_SDIO_RSP_R1B		(GB_SDIO_RSP_PRESENT | GB_SDIO_RSP_CRC | \
+				 GB_SDIO_RSP_OPCODE | GB_SDIO_RSP_BUSY)
+
 static void _gb_sdio_set_host_caps(struct gb_sdio_host *host, u32 r)
 {
 	u32 caps = 0;

commit e18822e3d02c8f296fe42e0e8bda7e2e626a4714
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Wed Jul 1 12:13:52 2015 +0530

    greybus: Rename gb_gpbridge_protocol_driver() as gb_builtin_protocol_driver()
    
    This macro is also required by core protocols like control and svc, and
    hence the 'gpbridge' name doesn't fit anymore.
    
    Lets call this macro gb_builtin_protocol_driver().
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Reviewed-by: Alex Elder <elder@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/sdio.c b/drivers/staging/greybus/sdio.c
index 30ebd42da287..f028e14fc918 100644
--- a/drivers/staging/greybus/sdio.c
+++ b/drivers/staging/greybus/sdio.c
@@ -720,4 +720,4 @@ static struct gb_protocol sdio_protocol = {
 	.request_recv		= gb_sdio_event_recv,
 };
 
-gb_gpbridge_protocol_driver(sdio_protocol);
+gb_builtin_protocol_driver(sdio_protocol);

commit 93a99e8a105aeaec432995196c21ffedcd0c0cad
Author: Phong Tran <tranmanphong@gmail.com>
Date:   Fri Jun 26 21:05:13 2015 +0700

    greybus: sdio: correct the usage of mmc request in work queues handler
    
    The mmc request should assigned before use. Then
    It should avoid freeing before using in mmc_request_done().
    
    Signed-off-by: Phong Tran <tranmanphong@gmail.com>
    Reviewed-by: Rui Miguel Silva <rui.silva@linaro.org>
    Reviewed-by: Mark Greer <mgreer@animalcreek.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/sdio.c b/drivers/staging/greybus/sdio.c
index cf12592d3468..30ebd42da287 100644
--- a/drivers/staging/greybus/sdio.c
+++ b/drivers/staging/greybus/sdio.c
@@ -387,13 +387,18 @@ static void gb_sdio_mrq_work(struct work_struct *work)
 	host = container_of(work, struct gb_sdio_host, mrqwork);
 
 	mutex_lock(&host->lock);
+	mrq = host->mrq;
+	if (!mrq) {
+		mutex_unlock(&host->lock);
+		dev_err(mmc_dev(host->mmc), "mmc request is NULL");
+		return;
+	}
+
 	if (host->removed) {
 		mrq->cmd->error = -ESHUTDOWN;
 		goto done;
 	}
 
-	mrq = host->mrq;
-
 	if (mrq->sbc) {
 		ret = gb_sdio_command(host, mrq->sbc);
 		if (ret < 0)
@@ -417,7 +422,7 @@ static void gb_sdio_mrq_work(struct work_struct *work)
 	}
 
 done:
-	mrq = NULL;
+	host->mrq = NULL;
 	mutex_unlock(&host->lock);
 	mmc_request_done(host->mmc, mrq);
 }

commit 9b86bdf96ef79e5e286628cb2e3ea6639db71904
Author: Phong Tran <tranmanphong@gmail.com>
Date:   Fri Jun 26 21:05:12 2015 +0700

    greybus: sdio: change the order of remove and free mmc host
    
    The mmc host should be removed frist. Then it
    will be freed.
    
    Signed-off-by: Phong Tran <tranmanphong@gmail.com>
    Reviewed-by: Rui Miguel Silva <rui.silva@linaro.org>
    Reviewed-by: Mark Greer <mgreer@animalcreek.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/sdio.c b/drivers/staging/greybus/sdio.c
index 16abf7cafd90..cf12592d3468 100644
--- a/drivers/staging/greybus/sdio.c
+++ b/drivers/staging/greybus/sdio.c
@@ -700,8 +700,8 @@ static void gb_sdio_connection_exit(struct gb_connection *connection)
 
 	flush_workqueue(gb_sdio_mrq_workqueue);
 	destroy_workqueue(gb_sdio_mrq_workqueue);
-	mmc_free_host(mmc);
 	mmc_remove_host(mmc);
+	mmc_free_host(mmc);
 	kfree(host->xfer_buffer);
 }
 

commit 5656ab99a0ff9136613ab1da509ccd6d7652d173
Author: Rui Miguel Silva <rui.silva@linaro.org>
Date:   Wed Jun 24 23:20:26 2015 +0100

    greybus: sdio: fix defines for older kernels
    
    Some of the options for mmc host, are not defined in older kernels.
    MMC_CAP2_HS400_1_2V, MMC_CAP2_HS400_1_8V, MMC_TIMING_MMC_DDR52 and
    MMC_TIMING_MMC_HS400.
    
    To not use them for older versions.
    
    Signed-off-by: Rui Miguel Silva <rui.silva@linaro.org>
    Tested-by: Mark Greer <mgreer@animalcreek.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/sdio.c b/drivers/staging/greybus/sdio.c
index 1fd17c89b100..16abf7cafd90 100644
--- a/drivers/staging/greybus/sdio.c
+++ b/drivers/staging/greybus/sdio.c
@@ -62,9 +62,11 @@ static void _gb_sdio_set_host_caps(struct gb_sdio_host *host, u32 r)
 		(r & GB_SDIO_CAP_DRIVER_TYPE_D ? MMC_CAP_DRIVER_TYPE_D : 0);
 
 	caps2 = (r & GB_SDIO_CAP_HS200_1_2V ? MMC_CAP2_HS200_1_2V_SDR : 0) |
-		(r & GB_SDIO_CAP_HS200_1_8V ? MMC_CAP2_HS200_1_8V_SDR : 0) |
+#ifdef MMC_HS400_SUPPORTED
 		(r & GB_SDIO_CAP_HS400_1_2V ? MMC_CAP2_HS400_1_2V : 0) |
-		(r & GB_SDIO_CAP_HS400_1_8V ? MMC_CAP2_HS400_1_8V : 0);
+		(r & GB_SDIO_CAP_HS400_1_8V ? MMC_CAP2_HS400_1_8V : 0) |
+#endif
+		(r & GB_SDIO_CAP_HS200_1_8V ? MMC_CAP2_HS200_1_8V_SDR : 0);
 
 	host->mmc->caps = caps;
 	host->mmc->caps2 = caps2;
@@ -478,6 +480,7 @@ static void gb_mmc_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)
 
 	switch (ios->power_mode) {
 	case MMC_POWER_OFF:
+	default:
 		power_mode = GB_SDIO_POWER_OFF;
 		break;
 	case MMC_POWER_UP:
@@ -486,10 +489,11 @@ static void gb_mmc_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)
 	case MMC_POWER_ON:
 		power_mode = GB_SDIO_POWER_ON;
 		break;
+#ifdef MMC_POWER_UNDEFINED_SUPPORTED
 	case MMC_POWER_UNDEFINED:
-	default:
 		power_mode = GB_SDIO_POWER_UNDEFINED;
 		break;
+#endif
 	}
 	request.power_mode = power_mode;
 
@@ -533,15 +537,19 @@ static void gb_mmc_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)
 	case MMC_TIMING_UHS_DDR50:
 		timing = GB_SDIO_TIMING_UHS_DDR50;
 		break;
+#ifdef MMC_DDR52_DEFINED
 	case MMC_TIMING_MMC_DDR52:
 		timing = GB_SDIO_TIMING_MMC_DDR52;
 		break;
+#endif
 	case MMC_TIMING_MMC_HS200:
 		timing = GB_SDIO_TIMING_MMC_HS200;
 		break;
+#ifdef MMC_HS400_SUPPORTED
 	case MMC_TIMING_MMC_HS400:
 		timing = GB_SDIO_TIMING_MMC_HS400;
 		break;
+#endif
 	}
 	request.timing = timing;
 

commit 3b6ecd6de6b4d8aad200d256b0c09d536a15df29
Author: Rui Miguel Silva <rui.silva@linaro.org>
Date:   Mon Jun 22 14:03:52 2015 +0100

    greybus: sdio: extend sdio implementation
    
    Extend sdio implementation, as it for now it was basically stubs.
    
    This implementation is compile tested only since there is no fw or
    simulation support yet.
    Next step is to add sdio support to gbsim and test it with success
    using the mmc_test facility.
    
    Signed-off-by: Rui Miguel Silva <rui.silva@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/sdio.c b/drivers/staging/greybus/sdio.c
index 9a0348c62478..1fd17c89b100 100644
--- a/drivers/staging/greybus/sdio.c
+++ b/drivers/staging/greybus/sdio.c
@@ -1,51 +1,626 @@
 /*
  * SD/MMC Greybus driver.
  *
- * Copyright 2014 Google Inc.
- * Copyright 2014 Linaro Ltd.
+ * Copyright 2014-2015 Google Inc.
+ * Copyright 2014-2015 Linaro Ltd.
  *
  * Released under the GPLv2 only.
  */
 
 #include <linux/kernel.h>
-#include <linux/slab.h>
+#include <linux/mmc/core.h>
 #include <linux/mmc/host.h>
+#include <linux/mmc/mmc.h>
+#include <linux/scatterlist.h>
+#include <linux/workqueue.h>
 
 #include "greybus.h"
 
 struct gb_sdio_host {
-	struct gb_connection *connection;
-	struct mmc_host	*mmc;
-	struct mmc_request *mrq;
-	// FIXME - some lock?
+	struct gb_connection	*connection;
+	u8			version_major;
+	u8			version_minor;
+	struct mmc_host		*mmc;
+	struct mmc_request	*mrq;
+	struct mutex		lock;	/* lock for this host */
+	size_t			data_max;
+	void			*xfer_buffer;
+	spinlock_t		xfer;	/* lock to cancel ongoing transfer */
+	bool			xfer_stop;
+	struct work_struct	mrqwork;
+	bool			removed;
+	bool			card_present;
+	bool			read_only;
 };
 
-static void gb_sd_request(struct mmc_host *mmc, struct mmc_request *mrq)
+static struct workqueue_struct *gb_sdio_mrq_workqueue;
+
+/* Define get_version() routine */
+define_get_version(gb_sdio_host, SDIO);
+
+static void _gb_sdio_set_host_caps(struct gb_sdio_host *host, u32 r)
 {
-	// FIXME - do something here...
+	u32 caps = 0;
+	u32 caps2 = 0;
+
+	caps = (r & GB_SDIO_CAP_NONREMOVABLE ? MMC_CAP_NONREMOVABLE : 0) |
+		(r & GB_SDIO_CAP_4_BIT_DATA ? MMC_CAP_4_BIT_DATA : 0) |
+		(r & GB_SDIO_CAP_8_BIT_DATA ? MMC_CAP_8_BIT_DATA : 0) |
+		(r & GB_SDIO_CAP_MMC_HS ? MMC_CAP_MMC_HIGHSPEED : 0) |
+		(r & GB_SDIO_CAP_SD_HS ? MMC_CAP_SD_HIGHSPEED : 0) |
+		(r & GB_SDIO_CAP_ERASE ? MMC_CAP_ERASE : 0) |
+		(r & GB_SDIO_CAP_1_2V_DDR ? MMC_CAP_1_2V_DDR : 0) |
+		(r & GB_SDIO_CAP_1_8V_DDR ? MMC_CAP_1_8V_DDR : 0) |
+		(r & GB_SDIO_CAP_POWER_OFF_CARD ? MMC_CAP_POWER_OFF_CARD : 0) |
+		(r & GB_SDIO_CAP_UHS_SDR12 ? MMC_CAP_UHS_SDR12 : 0) |
+		(r & GB_SDIO_CAP_UHS_SDR25 ? MMC_CAP_UHS_SDR25 : 0) |
+		(r & GB_SDIO_CAP_UHS_SDR50 ? MMC_CAP_UHS_SDR50 : 0) |
+		(r & GB_SDIO_CAP_UHS_SDR104 ? MMC_CAP_UHS_SDR104 : 0) |
+		(r & GB_SDIO_CAP_UHS_DDR50 ? MMC_CAP_UHS_DDR50 : 0) |
+		(r & GB_SDIO_CAP_DRIVER_TYPE_A ? MMC_CAP_DRIVER_TYPE_A : 0) |
+		(r & GB_SDIO_CAP_DRIVER_TYPE_C ? MMC_CAP_DRIVER_TYPE_C : 0) |
+		(r & GB_SDIO_CAP_DRIVER_TYPE_D ? MMC_CAP_DRIVER_TYPE_D : 0);
+
+	caps2 = (r & GB_SDIO_CAP_HS200_1_2V ? MMC_CAP2_HS200_1_2V_SDR : 0) |
+		(r & GB_SDIO_CAP_HS200_1_8V ? MMC_CAP2_HS200_1_8V_SDR : 0) |
+		(r & GB_SDIO_CAP_HS400_1_2V ? MMC_CAP2_HS400_1_2V : 0) |
+		(r & GB_SDIO_CAP_HS400_1_8V ? MMC_CAP2_HS400_1_8V : 0);
+
+	host->mmc->caps = caps;
+	host->mmc->caps2 = caps2;
+
+	if (caps & MMC_CAP_NONREMOVABLE)
+		host->card_present = true;
 }
 
-static void gb_sd_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)
+static int gb_sdio_get_caps(struct gb_sdio_host *host)
 {
-	// FIXME - do something here...
+	struct gb_sdio_get_caps_response response;
+	struct mmc_host *mmc = host->mmc;
+	u16 data_max;
+	u32 blksz;
+	u32 r;
+	int ret;
+
+	ret = gb_operation_sync(host->connection, GB_SDIO_TYPE_GET_CAPABILITIES,
+				NULL, 0, &response, sizeof(response));
+	if (ret < 0)
+		return ret;
+	r = le32_to_cpu(response.caps);
+
+	_gb_sdio_set_host_caps(host, r);
+
+	/* get the max block size that could fit our payload */
+	data_max = gb_operation_get_payload_size_max(host->connection);
+	data_max = min(data_max - sizeof(struct gb_sdio_transfer_request),
+		       data_max - sizeof(struct gb_sdio_transfer_response));
+
+	blksz = min(le16_to_cpu(response.max_blk_size), data_max);
+	blksz = max_t(u32, 512, blksz);
+
+	mmc->max_blk_size = rounddown_pow_of_two(blksz);
+	mmc->max_blk_count = le16_to_cpu(response.max_blk_count);
+	host->data_max = data_max;
+
+	/* get ocr supported values */
+	mmc->ocr_avail = le32_to_cpu(response.ocr);
+	mmc->ocr_avail_sdio = mmc->ocr_avail;
+	mmc->ocr_avail_sd = mmc->ocr_avail;
+	mmc->ocr_avail_mmc = mmc->ocr_avail;
+
+	return 0;
 }
 
-static int gb_sd_get_ro(struct mmc_host *mmc)
+static int gb_sdio_event_recv(u8 type, struct gb_operation *op)
 {
-	// FIXME - do something here...
+	struct gb_connection *connection = op->connection;
+	struct gb_sdio_host *host = connection->private;
+	struct gb_message *request;
+	struct gb_sdio_event_request *payload;
+	u8 state_changed = 0;
+	u8 event;
+
+	if (type != GB_SDIO_TYPE_EVENT) {
+		dev_err(&connection->dev,
+			"unsupported unsolicited event: %u\n", type);
+		return -EINVAL;
+	}
+
+	request = op->request;
+
+	if (request->payload_size != sizeof(*payload)) {
+		dev_err(mmc_dev(host->mmc), "wrong event size received\n");
+		return -EINVAL;
+	}
+
+	payload = request->payload;
+	event = payload->event;
+
+	switch (event) {
+	case GB_SDIO_CARD_INSERTED:
+		if (!mmc_card_is_removable(host->mmc))
+			return 0;
+		if (host->card_present)
+			return 0;
+		host->card_present = true;
+		state_changed = 1;
+		break;
+	case GB_SDIO_CARD_REMOVED:
+		if (!mmc_card_is_removable(host->mmc))
+			return 0;
+		if (!(host->card_present))
+			return 0;
+		host->card_present = false;
+		state_changed = 1;
+		break;
+	case GB_SDIO_WP:
+		host->read_only = true;
+		break;
+	default:
+		dev_err(mmc_dev(host->mmc), "wrong event received %d\n", event);
+		return -EINVAL;
+	}
+
+	if (state_changed) {
+		dev_info(mmc_dev(host->mmc), "card %s now event\n",
+			 (host->card_present ?  "inserted" : "removed"));
+		mmc_detect_change(host->mmc, 0);
+	}
+
 	return 0;
 }
 
-static const struct mmc_host_ops gb_sd_ops = {
-	.request	= gb_sd_request,
-	.set_ios	= gb_sd_set_ios,
-	.get_ro		= gb_sd_get_ro,
+static int gb_sdio_set_ios(struct gb_sdio_host *host,
+			   struct gb_sdio_set_ios_request *request)
+{
+	return gb_operation_sync(host->connection, GB_SDIO_TYPE_SET_IOS,
+				 request, sizeof(*request), NULL, 0);
+}
+
+static int _gb_sdio_send(struct gb_sdio_host *host, struct mmc_data *data,
+			 size_t len, u16 nblocks, off_t skip)
+{
+	struct gb_sdio_transfer_request *request;
+	struct gb_sdio_transfer_response response;
+	struct scatterlist *sg = data->sg;
+	unsigned int sg_len = data->sg_len;
+	size_t copied;
+	u16 send_blksz;
+	u16 send_blocks;
+	int ret;
+
+	WARN_ON(len > host->data_max);
+
+	request = host->xfer_buffer;
+	request->data_flags = (data->flags >> 8);
+	request->data_blocks = cpu_to_le16(nblocks);
+	request->data_blksz = cpu_to_le16(data->blksz);
+
+	copied = sg_pcopy_to_buffer(sg, sg_len, &request->data[0] + skip, len,
+				    skip);
+
+	if (copied != len)
+		return -EINVAL;
+
+	ret = gb_operation_sync(host->connection, GB_SDIO_TYPE_TRANSFER,
+				request, len, &response, sizeof(response));
+	if (ret < 0)
+		return ret;
+
+	send_blocks = le16_to_cpu(response.data_blocks);
+	send_blksz = le16_to_cpu(response.data_blksz);
+
+	if (len != send_blksz * send_blocks)
+		return -EINVAL;
+
+	return ret;
+}
+
+static int _gb_sdio_recv(struct gb_sdio_host *host, struct mmc_data *data,
+			 size_t len, u16 nblocks, off_t skip)
+{
+	struct gb_sdio_transfer_request request;
+	struct gb_sdio_transfer_response *response;
+	struct scatterlist *sg = data->sg;
+	unsigned int sg_len = data->sg_len;
+	size_t copied;
+	u16 recv_blksz;
+	u16 recv_blocks;
+	int ret;
+
+	WARN_ON(len > host->data_max);
+
+	request.data_flags = (data->flags >> 8);
+	request.data_blocks = cpu_to_le16(nblocks);
+	request.data_blksz = cpu_to_le16(data->blksz);
+
+	response = host->xfer_buffer;
+
+	ret = gb_operation_sync(host->connection, GB_SDIO_TYPE_TRANSFER,
+				&request, sizeof(request), response, len);
+	if (ret < 0)
+		return ret;
+
+	recv_blocks = le16_to_cpu(response->data_blocks);
+	recv_blksz = le16_to_cpu(response->data_blksz);
+
+	if (len != recv_blksz * recv_blocks)
+		return -EINVAL;
+
+	copied = sg_pcopy_from_buffer(sg, sg_len, &response->data[0] + skip,
+				      len, skip);
+	if (copied != len)
+		return -EINVAL;
+
+	return 0;
+}
+
+static int gb_sdio_transfer(struct gb_sdio_host *host, struct mmc_request *mrq)
+{
+	struct mmc_data *data = mrq->data;
+	size_t left, len;
+	off_t skip = 0;
+	int ret = 0;
+	u16 nblocks;
+
+	left = data->blksz * data->blocks;
+
+	while (left) {
+		/* check is a stop transmission is pending */
+		spin_lock(&host->xfer);
+		if (host->xfer_stop) {
+			host->xfer_stop = false;
+			spin_unlock(&host->xfer);
+			ret = -EINTR;
+			goto out;
+		}
+		spin_unlock(&host->xfer);
+		len = min(left, host->data_max);
+		nblocks = do_div(len, data->blksz);
+		len = nblocks * data->blksz;
+
+		if (data->flags & MMC_DATA_READ) {
+			ret = _gb_sdio_recv(host, data, len, nblocks, skip);
+			if (ret < 0)
+				goto out;
+		} else {
+			ret = _gb_sdio_send(host, data, len, nblocks, skip);
+			if (ret < 0)
+				goto out;
+		}
+		data->bytes_xfered += len;
+		left -= len;
+		skip += len;
+	}
+
+out:
+	data->error = ret;
+	return ret;
+}
+
+static int gb_sdio_command(struct gb_sdio_host *host, struct mmc_command *cmd)
+{
+	struct gb_sdio_command_request request;
+	struct gb_sdio_command_response response;
+	u8 cmd_flags;
+	u8 cmd_type;
+	int i;
+	int ret = 0;
+
+	switch (mmc_resp_type(cmd)) {
+	case MMC_RSP_NONE:
+		cmd_flags = GB_SDIO_RSP_NONE;
+		break;
+	case MMC_RSP_R1:
+		cmd_flags = GB_SDIO_RSP_R1_R5_R6_R7;
+		break;
+	case MMC_RSP_R1B:
+		cmd_flags = GB_SDIO_RSP_R1B;
+		break;
+	case MMC_RSP_R2:
+		cmd_flags = GB_SDIO_RSP_R2;
+		break;
+	case MMC_RSP_R3:
+		cmd_flags = GB_SDIO_RSP_R3_R4;
+	default:
+		dev_err(mmc_dev(host->mmc), "cmd flag invalid %04x\n",
+			mmc_resp_type(cmd));
+		ret = -EINVAL;
+		goto out;
+	}
+
+	switch (mmc_cmd_type(cmd)) {
+	case MMC_CMD_BC:
+		cmd_type = GB_SDIO_CMD_BC;
+		break;
+	case MMC_CMD_BCR:
+		cmd_type = GB_SDIO_CMD_BCR;
+		break;
+	case MMC_CMD_AC:
+		cmd_type = GB_SDIO_CMD_AC;
+		break;
+	case MMC_CMD_ADTC:
+		cmd_type = GB_SDIO_CMD_ADTC;
+		break;
+	default:
+		dev_err(mmc_dev(host->mmc), "cmd type invalid %04x\n",
+			mmc_cmd_type(cmd));
+		ret = -EINVAL;
+		goto out;
+	}
+
+	request.cmd = cmd->opcode;
+	request.cmd_flags = cmd_flags;
+	request.cmd_type = cmd_type;
+	request.cmd_arg = cpu_to_le32(cmd->arg);
+
+	ret = gb_operation_sync(host->connection, GB_SDIO_TYPE_COMMAND,
+				&request, sizeof(request), &response,
+				sizeof(response));
+	if (ret < 0)
+		goto out;
+
+	/* no response expected */
+	if (cmd_flags & GB_SDIO_RSP_NONE)
+		goto out;
+
+	/* long response expected */
+	if (cmd_flags & GB_SDIO_RSP_R2)
+		for (i = 0; i < 4; i++)
+			cmd->resp[i] = le32_to_cpu(response.resp[i]);
+	else
+		cmd->resp[0] = le32_to_cpu(response.resp[0]);
+
+out:
+	cmd->error = ret;
+	return ret;
+}
+
+static void gb_sdio_mrq_work(struct work_struct *work)
+{
+	struct gb_sdio_host *host;
+	struct mmc_request *mrq;
+	int ret;
+
+	host = container_of(work, struct gb_sdio_host, mrqwork);
+
+	mutex_lock(&host->lock);
+	if (host->removed) {
+		mrq->cmd->error = -ESHUTDOWN;
+		goto done;
+	}
+
+	mrq = host->mrq;
+
+	if (mrq->sbc) {
+		ret = gb_sdio_command(host, mrq->sbc);
+		if (ret < 0)
+			goto done;
+	}
+
+	ret = gb_sdio_command(host, mrq->cmd);
+	if (ret < 0)
+		goto done;
+
+	if (mrq->data) {
+		ret = gb_sdio_transfer(host, host->mrq);
+		if (ret < 0)
+			goto done;
+	}
+
+	if (mrq->data->stop) {
+		ret = gb_sdio_command(host, mrq->data->stop);
+		if (ret < 0)
+			goto done;
+	}
+
+done:
+	mrq = NULL;
+	mutex_unlock(&host->lock);
+	mmc_request_done(host->mmc, mrq);
+}
+
+static void gb_mmc_request(struct mmc_host *mmc, struct mmc_request *mrq)
+{
+	struct gb_sdio_host *host = mmc_priv(mmc);
+	struct mmc_command *cmd = mrq->cmd;
+
+	/* Check if it is a cancel to ongoing transfer */
+	if (cmd->opcode == MMC_STOP_TRANSMISSION) {
+		spin_lock(&host->xfer);
+		host->xfer_stop = true;
+		spin_unlock(&host->xfer);
+	}
+
+	mutex_lock(&host->lock);
+
+	WARN_ON(host->mrq);
+	host->mrq = mrq;
+
+	if (host->removed) {
+		mrq->cmd->error = -ESHUTDOWN;
+		goto out;
+	}
+	if (!host->card_present) {
+		mrq->cmd->error = -ENOMEDIUM;
+		goto out;
+	}
+
+	queue_work(gb_sdio_mrq_workqueue, &host->mrqwork);
+
+	mutex_unlock(&host->lock);
+	return;
+
+out:
+	host->mrq = NULL;
+	mutex_unlock(&host->lock);
+	mmc_request_done(mmc, mrq);
+}
+
+static void gb_mmc_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)
+{
+	struct gb_sdio_host *host = mmc_priv(mmc);
+	struct gb_sdio_set_ios_request request;
+	int ret;
+	u8 power_mode;
+	u8 bus_width;
+	u8 timing;
+	u8 signal_voltage;
+	u8 drv_type;
+
+	mutex_lock(&host->lock);
+	request.clock = cpu_to_le32(ios->clock);
+	request.vdd = cpu_to_le32(1 << ios->vdd);
+
+	request.bus_mode = (ios->bus_mode == MMC_BUSMODE_OPENDRAIN ?
+			    GB_SDIO_BUSMODE_OPENDRAIN :
+			    GB_SDIO_BUSMODE_PUSHPULL);
+
+	switch (ios->power_mode) {
+	case MMC_POWER_OFF:
+		power_mode = GB_SDIO_POWER_OFF;
+		break;
+	case MMC_POWER_UP:
+		power_mode = GB_SDIO_POWER_UP;
+		break;
+	case MMC_POWER_ON:
+		power_mode = GB_SDIO_POWER_ON;
+		break;
+	case MMC_POWER_UNDEFINED:
+	default:
+		power_mode = GB_SDIO_POWER_UNDEFINED;
+		break;
+	}
+	request.power_mode = power_mode;
+
+	switch (ios->bus_width) {
+	case MMC_BUS_WIDTH_1:
+		bus_width = GB_SDIO_BUS_WIDTH_1;
+		break;
+	case MMC_BUS_WIDTH_4:
+	default:
+		bus_width = GB_SDIO_BUS_WIDTH_4;
+		break;
+	case MMC_BUS_WIDTH_8:
+		bus_width = GB_SDIO_BUS_WIDTH_8;
+		break;
+	}
+	request.bus_width = bus_width;
+
+	switch (ios->timing) {
+	case MMC_TIMING_LEGACY:
+	default:
+		timing = GB_SDIO_TIMING_LEGACY;
+		break;
+	case MMC_TIMING_MMC_HS:
+		timing = GB_SDIO_TIMING_MMC_HS;
+		break;
+	case MMC_TIMING_SD_HS:
+		timing = GB_SDIO_TIMING_SD_HS;
+		break;
+	case MMC_TIMING_UHS_SDR12:
+		timing = GB_SDIO_TIMING_UHS_SDR12;
+		break;
+	case MMC_TIMING_UHS_SDR25:
+		timing = GB_SDIO_TIMING_UHS_SDR25;
+		break;
+	case MMC_TIMING_UHS_SDR50:
+		timing = GB_SDIO_TIMING_UHS_SDR50;
+		break;
+	case MMC_TIMING_UHS_SDR104:
+		timing = GB_SDIO_TIMING_UHS_SDR104;
+		break;
+	case MMC_TIMING_UHS_DDR50:
+		timing = GB_SDIO_TIMING_UHS_DDR50;
+		break;
+	case MMC_TIMING_MMC_DDR52:
+		timing = GB_SDIO_TIMING_MMC_DDR52;
+		break;
+	case MMC_TIMING_MMC_HS200:
+		timing = GB_SDIO_TIMING_MMC_HS200;
+		break;
+	case MMC_TIMING_MMC_HS400:
+		timing = GB_SDIO_TIMING_MMC_HS400;
+		break;
+	}
+	request.timing = timing;
+
+	switch (ios->signal_voltage) {
+	case MMC_SIGNAL_VOLTAGE_330:
+		signal_voltage = GB_SDIO_SIGNAL_VOLTAGE_330;
+		break;
+	case MMC_SIGNAL_VOLTAGE_180:
+	default:
+		signal_voltage = GB_SDIO_SIGNAL_VOLTAGE_180;
+		break;
+	case MMC_SIGNAL_VOLTAGE_120:
+		signal_voltage = GB_SDIO_SIGNAL_VOLTAGE_120;
+		break;
+	}
+	request.signal_voltage = signal_voltage;
+
+	switch (ios->drv_type) {
+	case MMC_SET_DRIVER_TYPE_A:
+		drv_type = GB_SDIO_SET_DRIVER_TYPE_A;
+		break;
+	case MMC_SET_DRIVER_TYPE_C:
+		drv_type = GB_SDIO_SET_DRIVER_TYPE_C;
+		break;
+	case MMC_SET_DRIVER_TYPE_D:
+		drv_type = GB_SDIO_SET_DRIVER_TYPE_D;
+		break;
+	case MMC_SET_DRIVER_TYPE_B:
+	default:
+		drv_type = GB_SDIO_SET_DRIVER_TYPE_B;
+		break;
+	}
+	request.drv_type = drv_type;
+
+	ret = gb_sdio_set_ios(host, &request);
+	if (ret < 0)
+		goto out;
+
+	memcpy(&mmc->ios, ios, sizeof(mmc->ios));
+
+out:
+	mutex_unlock(&host->lock);
+}
+
+static int gb_mmc_get_ro(struct mmc_host *mmc)
+{
+	struct gb_sdio_host *host = mmc_priv(mmc);
+
+	mutex_lock(&host->lock);
+	if (host->removed)
+		return -ESHUTDOWN;
+	mutex_unlock(&host->lock);
+	return host->card_present;
+}
+
+static int gb_mmc_get_cd(struct mmc_host *mmc)
+{
+	struct gb_sdio_host *host = mmc_priv(mmc);
+
+	mutex_lock(&host->lock);
+	if (host->removed)
+		return -ESHUTDOWN;
+	mutex_unlock(&host->lock);
+	return host->read_only;
+}
+
+static const struct mmc_host_ops gb_sdio_ops = {
+	.request	= gb_mmc_request,
+	.set_ios	= gb_mmc_set_ios,
+	.get_ro		= gb_mmc_get_ro,
+	.get_cd		= gb_mmc_get_cd,
 };
 
 static int gb_sdio_connection_init(struct gb_connection *connection)
 {
 	struct mmc_host *mmc;
 	struct gb_sdio_host *host;
+	size_t max_buffer;
+	int ret = 0;
 
 	mmc = mmc_alloc_host(sizeof(*host), &connection->dev);
 	if (!mmc)
@@ -54,38 +629,82 @@ static int gb_sdio_connection_init(struct gb_connection *connection)
 	host = mmc_priv(mmc);
 	host->mmc = mmc;
 
-	mmc->ops = &gb_sd_ops;
-	// FIXME - set up size limits we can handle.
-	// FIXME - register the host controller.
-
 	host->connection = connection;
 	connection->private = host;
-	return 0;
+
+	ret = get_version(host);
+	if (ret < 0)
+		goto free_mmc;
+
+	ret = gb_sdio_get_caps(host);
+	if (ret < 0)
+		goto free_mmc;
+
+	mmc->ops = &gb_sdio_ops;
+
+	/* for now we just make a map 1:1 between max blocks and segments */
+	mmc->max_segs = host->mmc->max_blk_count;
+	mmc->max_seg_size = host->mmc->max_blk_size;
+
+	mmc->max_req_size = mmc->max_blk_size * mmc->max_blk_count;
+
+	max_buffer = gb_operation_get_payload_size_max(host->connection);
+	host->xfer_buffer = kzalloc(max_buffer, GFP_KERNEL);
+	if (!host->xfer_buffer) {
+		ret = -ENOMEM;
+		goto free_mmc;
+	}
+	mutex_init(&host->lock);
+	spin_lock_init(&host->xfer);
+	gb_sdio_mrq_workqueue = alloc_workqueue("gb_sdio_mrq", 0, 1);
+	INIT_WORK(&host->mrqwork, gb_sdio_mrq_work);
+
+	ret = mmc_add_host(mmc);
+	if (ret < 0)
+		goto free_work;
+
+	return ret;
+
+free_work:
+	destroy_workqueue(gb_sdio_mrq_workqueue);
+	kfree(host->xfer_buffer);
+
+free_mmc:
+	connection->private = NULL;
+	mmc_free_host(mmc);
+
+	return ret;
 }
 
 static void gb_sdio_connection_exit(struct gb_connection *connection)
 {
 	struct mmc_host *mmc;
-	struct gb_sdio_host *host;
+	struct gb_sdio_host *host = connection->private;
 
-	host = connection->private;
 	if (!host)
 		return;
 
+	mutex_lock(&host->lock);
+	host->removed = true;
 	mmc = host->mmc;
-	mmc_remove_host(mmc);
-	mmc_free_host(mmc);
 	connection->private = NULL;
+	mutex_unlock(&host->lock);
+
+	flush_workqueue(gb_sdio_mrq_workqueue);
+	destroy_workqueue(gb_sdio_mrq_workqueue);
+	mmc_free_host(mmc);
+	mmc_remove_host(mmc);
+	kfree(host->xfer_buffer);
 }
 
 static struct gb_protocol sdio_protocol = {
 	.name			= "sdio",
 	.id			= GREYBUS_PROTOCOL_SDIO,
-	.major			= 0,
-	.minor			= 1,
+	.major			= GB_SDIO_VERSION_MAJOR,
+	.minor			= GB_SDIO_VERSION_MINOR,
 	.connection_init	= gb_sdio_connection_init,
 	.connection_exit	= gb_sdio_connection_exit,
-	.request_recv		= NULL,	/* no incoming requests */
+	.request_recv		= gb_sdio_event_recv,
 };
 
 gb_gpbridge_protocol_driver(sdio_protocol);

commit bdac599c70409bbf48e77971e2b9ecc2a66ef151
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Wed May 20 17:20:10 2015 +0530

    greybus: Use gb_gpbridge_protocol_init()
    
    Start using gb_gpbridge_protocol_init() in gpbridge drivers.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Reviewed-by: Alex Elder <elder@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/sdio.c b/drivers/staging/greybus/sdio.c
index d324846d09ab..9a0348c62478 100644
--- a/drivers/staging/greybus/sdio.c
+++ b/drivers/staging/greybus/sdio.c
@@ -88,12 +88,4 @@ static struct gb_protocol sdio_protocol = {
 	.request_recv		= NULL,	/* no incoming requests */
 };
 
-int gb_sdio_protocol_init(void)
-{
-	return gb_protocol_register(&sdio_protocol);
-}
-
-void gb_sdio_protocol_exit(void)
-{
-	gb_protocol_deregister(&sdio_protocol);
-}
+gb_gpbridge_protocol_driver(sdio_protocol);

commit 5357cf323110ee4a3f4a12870618eca28672c7b9
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Wed Jan 21 16:10:40 2015 +0530

    greybus: Remove "-gb" suffix from .c files
    
    Some files are prefixed with "gb-" and some are suffixed with "-gb". The
    rationale behind the first one is that the modules would be named so, i.e.
    gb-*.ko. But there is no reason to keep the "-gb" suffix in the second case.
    
    Remove the unnecessary suffix.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Reviewed-by: Alex Elder <elder@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>

diff --git a/drivers/staging/greybus/sdio.c b/drivers/staging/greybus/sdio.c
new file mode 100644
index 000000000000..d324846d09ab
--- /dev/null
+++ b/drivers/staging/greybus/sdio.c
@@ -0,0 +1,99 @@
+/*
+ * SD/MMC Greybus driver.
+ *
+ * Copyright 2014 Google Inc.
+ * Copyright 2014 Linaro Ltd.
+ *
+ * Released under the GPLv2 only.
+ */
+
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/mmc/host.h>
+
+#include "greybus.h"
+
+struct gb_sdio_host {
+	struct gb_connection *connection;
+	struct mmc_host	*mmc;
+	struct mmc_request *mrq;
+	// FIXME - some lock?
+};
+
+static void gb_sd_request(struct mmc_host *mmc, struct mmc_request *mrq)
+{
+	// FIXME - do something here...
+}
+
+static void gb_sd_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)
+{
+	// FIXME - do something here...
+}
+
+static int gb_sd_get_ro(struct mmc_host *mmc)
+{
+	// FIXME - do something here...
+	return 0;
+}
+
+static const struct mmc_host_ops gb_sd_ops = {
+	.request	= gb_sd_request,
+	.set_ios	= gb_sd_set_ios,
+	.get_ro		= gb_sd_get_ro,
+};
+
+static int gb_sdio_connection_init(struct gb_connection *connection)
+{
+	struct mmc_host *mmc;
+	struct gb_sdio_host *host;
+
+	mmc = mmc_alloc_host(sizeof(*host), &connection->dev);
+	if (!mmc)
+		return -ENOMEM;
+
+	host = mmc_priv(mmc);
+	host->mmc = mmc;
+
+	mmc->ops = &gb_sd_ops;
+	// FIXME - set up size limits we can handle.
+	// FIXME - register the host controller.
+
+	host->connection = connection;
+	connection->private = host;
+	return 0;
+}
+
+static void gb_sdio_connection_exit(struct gb_connection *connection)
+{
+	struct mmc_host *mmc;
+	struct gb_sdio_host *host;
+
+	host = connection->private;
+	if (!host)
+		return;
+
+	mmc = host->mmc;
+	mmc_remove_host(mmc);
+	mmc_free_host(mmc);
+	connection->private = NULL;
+}
+
+static struct gb_protocol sdio_protocol = {
+	.name			= "sdio",
+	.id			= GREYBUS_PROTOCOL_SDIO,
+	.major			= 0,
+	.minor			= 1,
+	.connection_init	= gb_sdio_connection_init,
+	.connection_exit	= gb_sdio_connection_exit,
+	.request_recv		= NULL,	/* no incoming requests */
+};
+
+int gb_sdio_protocol_init(void)
+{
+	return gb_protocol_register(&sdio_protocol);
+}
+
+void gb_sdio_protocol_exit(void)
+{
+	gb_protocol_deregister(&sdio_protocol);
+}
