commit 66d93d7ff9c4d1f8a35519a62e3bacbbdd93b6e8
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Mar 6 14:24:13 2020 +0100

    staging: greybus: Fix the irq API abuse
    
    Nothing outside of low level architecture code is supposed to look up
    interrupt descriptors and fiddle with them.
    
    Replace the open coded abuse by calling generic_handle_irq().
    
    This still does not explain why and in which context this connection
    magic is injecting interrupts in the first place and why this is correct
    and safe, but at least the API abuse is gone.
    
    Fixes: 036aad9d0224 ("greybus: gpio: add interrupt handling support")
    Fixes: 2611ebef8322 ("greybus: gpio: don't call irq-flow handler directly")
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Johan Hovold <johan@kernel.org>
    Link: https://lore.kernel.org/r/87o8t9boqq.fsf@nanos.tec.linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/gpio.c b/drivers/staging/greybus/gpio.c
index 1ff34abd5692..36d99f9e419e 100644
--- a/drivers/staging/greybus/gpio.c
+++ b/drivers/staging/greybus/gpio.c
@@ -364,8 +364,7 @@ static int gb_gpio_request_handler(struct gb_operation *op)
 	struct gb_message *request;
 	struct gb_gpio_irq_event_request *event;
 	u8 type = op->type;
-	int irq;
-	struct irq_desc *desc;
+	int irq, ret;
 
 	if (type != GB_GPIO_TYPE_IRQ_EVENT) {
 		dev_err(dev, "unsupported unsolicited request: %u\n", type);
@@ -391,17 +390,15 @@ static int gb_gpio_request_handler(struct gb_operation *op)
 		dev_err(dev, "failed to find IRQ\n");
 		return -EINVAL;
 	}
-	desc = irq_to_desc(irq);
-	if (!desc) {
-		dev_err(dev, "failed to look up irq\n");
-		return -EINVAL;
-	}
 
 	local_irq_disable();
-	generic_handle_irq_desc(desc);
+	ret = generic_handle_irq(irq);
 	local_irq_enable();
 
-	return 0;
+	if (ret)
+		dev_err(dev, "failed to invoke irq handler\n");
+
+	return ret;
 }
 
 static int gb_gpio_request(struct gpio_chip *chip, unsigned int offset)

commit ec0ad868173da8a75121f9dc116a5d5478ff614d
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Sun Aug 25 07:54:27 2019 +0200

    staging: greybus: move core include files to include/linux/greybus/
    
    With the goal of moving the core of the greybus code out of staging, the
    include files need to be moved to include/linux/greybus.h and
    include/linux/greybus/
    
    Cc: Vaibhav Hiremath <hvaibhav.linux@gmail.com>
    Cc: Johan Hovold <johan@kernel.org>
    Cc: Vaibhav Agarwal <vaibhav.sr@gmail.com>
    Cc: Rui Miguel Silva <rmfrfs@gmail.com>
    Cc: David Lin <dtwlin@gmail.com>
    Cc: "Bryan O'Donoghue" <pure.logic@nexus-software.ie>
    Cc: greybus-dev@lists.linaro.org
    Cc: devel@driverdev.osuosl.org
    Acked-by: Mark Greer <mgreer@animalcreek.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Acked-by: Alex Elder <elder@kernel.org>
    Link: https://lore.kernel.org/r/20190825055429.18547-8-gregkh@linuxfoundation.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/gpio.c b/drivers/staging/greybus/gpio.c
index 3151004d26fb..1ff34abd5692 100644
--- a/drivers/staging/greybus/gpio.c
+++ b/drivers/staging/greybus/gpio.c
@@ -13,8 +13,8 @@
 #include <linux/irqdomain.h>
 #include <linux/gpio/driver.h>
 #include <linux/mutex.h>
+#include <linux/greybus.h>
 
-#include "greybus.h"
 #include "gbphy.h"
 
 struct gb_gpio_line {

commit e28dd69ee81be1ce44cc96a61a2172fc503944a4
Author: Nishad Kamdar <nishadkamdar@gmail.com>
Date:   Mon Jan 14 20:26:16 2019 +0530

    staging: greybus: gpio: switch GPIO portions to use GPIOLIB_IRQCHIP
    
    Convert the GPIO driver to use the GPIO irqchip library
    GPIOLIB_IRQCHIP instead of reimplementing the same.
    
    Reviewed-by: Johan Hovold <johan@kernel.org>
    Signed-off-by: Nishad Kamdar <nishadkamdar@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/gpio.c b/drivers/staging/greybus/gpio.c
index e110681e6f86..3151004d26fb 100644
--- a/drivers/staging/greybus/gpio.c
+++ b/drivers/staging/greybus/gpio.c
@@ -9,9 +9,9 @@
 #include <linux/kernel.h>
 #include <linux/module.h>
 #include <linux/slab.h>
-#include <linux/gpio.h>
 #include <linux/irq.h>
 #include <linux/irqdomain.h>
+#include <linux/gpio/driver.h>
 #include <linux/mutex.h>
 
 #include "greybus.h"
@@ -39,11 +39,6 @@ struct gb_gpio_controller {
 
 	struct gpio_chip	chip;
 	struct irq_chip		irqc;
-	struct irq_chip		*irqchip;
-	struct irq_domain	*irqdomain;
-	unsigned int		irq_base;
-	irq_flow_handler_t	irq_handler;
-	unsigned int		irq_default_type;
 	struct mutex		irq_lock;
 };
 #define gpio_chip_to_gb_gpio_controller(chip) \
@@ -391,7 +386,7 @@ static int gb_gpio_request_handler(struct gb_operation *op)
 		return -EINVAL;
 	}
 
-	irq = irq_find_mapping(ggc->irqdomain, event->which);
+	irq = irq_find_mapping(ggc->chip.irq.domain, event->which);
 	if (!irq) {
 		dev_err(dev, "failed to find IRQ\n");
 		return -EINVAL;
@@ -506,135 +501,6 @@ static int gb_gpio_controller_setup(struct gb_gpio_controller *ggc)
 	return ret;
 }
 
-/**
- * gb_gpio_irq_map() - maps an IRQ into a GB gpio irqchip
- * @d: the irqdomain used by this irqchip
- * @irq: the global irq number used by this GB gpio irqchip irq
- * @hwirq: the local IRQ/GPIO line offset on this GB gpio
- *
- * This function will set up the mapping for a certain IRQ line on a
- * GB gpio by assigning the GB gpio as chip data, and using the irqchip
- * stored inside the GB gpio.
- */
-static int gb_gpio_irq_map(struct irq_domain *domain, unsigned int irq,
-			   irq_hw_number_t hwirq)
-{
-	struct gpio_chip *chip = domain->host_data;
-	struct gb_gpio_controller *ggc = gpio_chip_to_gb_gpio_controller(chip);
-
-	irq_set_chip_data(irq, ggc);
-	irq_set_chip_and_handler(irq, ggc->irqchip, ggc->irq_handler);
-	irq_set_noprobe(irq);
-	/*
-	 * No set-up of the hardware will happen if IRQ_TYPE_NONE
-	 * is passed as default type.
-	 */
-	if (ggc->irq_default_type != IRQ_TYPE_NONE)
-		irq_set_irq_type(irq, ggc->irq_default_type);
-
-	return 0;
-}
-
-static void gb_gpio_irq_unmap(struct irq_domain *d, unsigned int irq)
-{
-	irq_set_chip_and_handler(irq, NULL, NULL);
-	irq_set_chip_data(irq, NULL);
-}
-
-static const struct irq_domain_ops gb_gpio_domain_ops = {
-	.map	= gb_gpio_irq_map,
-	.unmap	= gb_gpio_irq_unmap,
-};
-
-/**
- * gb_gpio_irqchip_remove() - removes an irqchip added to a gb_gpio_controller
- * @ggc: the gb_gpio_controller to remove the irqchip from
- *
- * This is called only from gb_gpio_remove()
- */
-static void gb_gpio_irqchip_remove(struct gb_gpio_controller *ggc)
-{
-	unsigned int offset;
-
-	/* Remove all IRQ mappings and delete the domain */
-	if (ggc->irqdomain) {
-		for (offset = 0; offset < (ggc->line_max + 1); offset++)
-			irq_dispose_mapping(irq_find_mapping(ggc->irqdomain,
-							     offset));
-		irq_domain_remove(ggc->irqdomain);
-	}
-
-	if (ggc->irqchip)
-		ggc->irqchip = NULL;
-}
-
-/**
- * gb_gpio_irqchip_add() - adds an irqchip to a gpio chip
- * @chip: the gpio chip to add the irqchip to
- * @irqchip: the irqchip to add to the adapter
- * @first_irq: if not dynamically assigned, the base (first) IRQ to
- * allocate gpio irqs from
- * @handler: the irq handler to use (often a predefined irq core function)
- * @type: the default type for IRQs on this irqchip, pass IRQ_TYPE_NONE
- * to have the core avoid setting up any default type in the hardware.
- *
- * This function closely associates a certain irqchip with a certain
- * gpio chip, providing an irq domain to translate the local IRQs to
- * global irqs, and making sure that the gpio chip
- * is passed as chip data to all related functions. Driver callbacks
- * need to use container_of() to get their local state containers back
- * from the gpio chip passed as chip data. An irqdomain will be stored
- * in the gpio chip that shall be used by the driver to handle IRQ number
- * translation. The gpio chip will need to be initialized and registered
- * before calling this function.
- */
-static int gb_gpio_irqchip_add(struct gpio_chip *chip,
-			       struct irq_chip *irqchip,
-			       unsigned int first_irq,
-			       irq_flow_handler_t handler,
-			       unsigned int type)
-{
-	struct gb_gpio_controller *ggc;
-	unsigned int offset;
-	unsigned int irq_base;
-
-	if (!chip || !irqchip)
-		return -EINVAL;
-
-	ggc = gpio_chip_to_gb_gpio_controller(chip);
-
-	ggc->irqchip = irqchip;
-	ggc->irq_handler = handler;
-	ggc->irq_default_type = type;
-	ggc->irqdomain = irq_domain_add_simple(NULL,
-					       ggc->line_max + 1, first_irq,
-					       &gb_gpio_domain_ops, chip);
-	if (!ggc->irqdomain) {
-		ggc->irqchip = NULL;
-		return -EINVAL;
-	}
-
-	/*
-	 * Prepare the mapping since the irqchip shall be orthogonal to
-	 * any gpio calls. If the first_irq was zero, this is
-	 * necessary to allocate descriptors for all IRQs.
-	 */
-	for (offset = 0; offset < (ggc->line_max + 1); offset++) {
-		irq_base = irq_create_mapping(ggc->irqdomain, offset);
-		if (offset == 0)
-			ggc->irq_base = irq_base;
-	}
-
-	return 0;
-}
-
-static int gb_gpio_to_irq(struct gpio_chip *chip, unsigned int offset)
-{
-	struct gb_gpio_controller *ggc = gpio_chip_to_gb_gpio_controller(chip);
-
-	return irq_find_mapping(ggc->irqdomain, offset);
-}
-
 static int gb_gpio_probe(struct gbphy_device *gbphy_dev,
 			 const struct gbphy_device_id *id)
 {
@@ -694,7 +560,6 @@ static int gb_gpio_probe(struct gbphy_device *gbphy_dev,
 	gpio->get = gb_gpio_get;
 	gpio->set = gb_gpio_set;
 	gpio->set_config = gb_gpio_set_config;
-	gpio->to_irq = gb_gpio_to_irq;
 	gpio->base = -1;		/* Allocate base dynamically */
 	gpio->ngpio = ggc->line_max + 1;
 	gpio->can_sleep = true;
@@ -703,24 +568,24 @@ static int gb_gpio_probe(struct gbphy_device *gbphy_dev,
 	if (ret)
 		goto exit_line_free;
 
-	ret = gb_gpio_irqchip_add(gpio, irqc, 0,
-				  handle_level_irq, IRQ_TYPE_NONE);
+	ret = gpiochip_add(gpio);
 	if (ret) {
-		dev_err(&gbphy_dev->dev, "failed to add irq chip: %d\n", ret);
+		dev_err(&gbphy_dev->dev, "failed to add gpio chip: %d\n", ret);
 		goto exit_line_free;
 	}
 
-	ret = gpiochip_add(gpio);
+	ret = gpiochip_irqchip_add(gpio, irqc, 0, handle_level_irq,
+				   IRQ_TYPE_NONE);
 	if (ret) {
-		dev_err(&gbphy_dev->dev, "failed to add gpio chip: %d\n", ret);
-		goto exit_gpio_irqchip_remove;
+		dev_err(&gbphy_dev->dev, "failed to add irq chip: %d\n", ret);
+		goto exit_gpiochip_remove;
 	}
 
 	gbphy_runtime_put_autosuspend(gbphy_dev);
 	return 0;
 
-exit_gpio_irqchip_remove:
-	gb_gpio_irqchip_remove(ggc);
+exit_gpiochip_remove:
+	gpiochip_remove(gpio);
 exit_line_free:
 	kfree(ggc->lines);
 exit_connection_disable:
@@ -744,7 +609,6 @@ static void gb_gpio_remove(struct gbphy_device *gbphy_dev)
 
 	gb_connection_disable_rx(connection);
 	gpiochip_remove(&ggc->chip);
-	gb_gpio_irqchip_remove(ggc);
 	gb_connection_disable(connection);
 	gb_connection_destroy(connection);
 	kfree(ggc->lines);

commit 8478c35a858c75bf2b00917009ba1b46c1b9b7b4
Author: Cristian Sicilia <sicilia.cristian@gmail.com>
Date:   Sun Nov 25 17:58:15 2018 +0100

    staging: greybus: Parenthesis alignment
    
    Some parameters are aligned with parentheses.
    Some parentheses was opened at end of line.
    
    Signed-off-by: Cristian Sicilia <sicilia.cristian@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/gpio.c b/drivers/staging/greybus/gpio.c
index b1d4698019a1..e110681e6f86 100644
--- a/drivers/staging/greybus/gpio.c
+++ b/drivers/staging/greybus/gpio.c
@@ -74,7 +74,7 @@ static int gb_gpio_activate_operation(struct gb_gpio_controller *ggc, u8 which)
 
 	request.which = which;
 	ret = gb_operation_sync(ggc->connection, GB_GPIO_TYPE_ACTIVATE,
-				 &request, sizeof(request), NULL, 0);
+				&request, sizeof(request), NULL, 0);
 	if (ret) {
 		gbphy_runtime_put_autosuspend(gbphy_dev);
 		return ret;
@@ -86,7 +86,7 @@ static int gb_gpio_activate_operation(struct gb_gpio_controller *ggc, u8 which)
 }
 
 static void gb_gpio_deactivate_operation(struct gb_gpio_controller *ggc,
-					u8 which)
+					 u8 which)
 {
 	struct gbphy_device *gbphy_dev = ggc->gbphy_dev;
 	struct device *dev = &gbphy_dev->dev;
@@ -95,7 +95,7 @@ static void gb_gpio_deactivate_operation(struct gb_gpio_controller *ggc,
 
 	request.which = which;
 	ret = gb_operation_sync(ggc->connection, GB_GPIO_TYPE_DEACTIVATE,
-				 &request, sizeof(request), NULL, 0);
+				&request, sizeof(request), NULL, 0);
 	if (ret) {
 		dev_err(dev, "failed to deactivate gpio %u\n", which);
 		goto out_pm_put;
@@ -108,7 +108,7 @@ static void gb_gpio_deactivate_operation(struct gb_gpio_controller *ggc,
 }
 
 static int gb_gpio_get_direction_operation(struct gb_gpio_controller *ggc,
-					u8 which)
+					   u8 which)
 {
 	struct device *dev = &ggc->gbphy_dev->dev;
 	struct gb_gpio_get_direction_request request;
@@ -133,7 +133,7 @@ static int gb_gpio_get_direction_operation(struct gb_gpio_controller *ggc,
 }
 
 static int gb_gpio_direction_in_operation(struct gb_gpio_controller *ggc,
-					u8 which)
+					  u8 which)
 {
 	struct gb_gpio_direction_in_request request;
 	int ret;
@@ -147,7 +147,7 @@ static int gb_gpio_direction_in_operation(struct gb_gpio_controller *ggc,
 }
 
 static int gb_gpio_direction_out_operation(struct gb_gpio_controller *ggc,
-					u8 which, bool value_high)
+					   u8 which, bool value_high)
 {
 	struct gb_gpio_direction_out_request request;
 	int ret;
@@ -162,7 +162,7 @@ static int gb_gpio_direction_out_operation(struct gb_gpio_controller *ggc,
 }
 
 static int gb_gpio_get_value_operation(struct gb_gpio_controller *ggc,
-					u8 which)
+				       u8 which)
 {
 	struct device *dev = &ggc->gbphy_dev->dev;
 	struct gb_gpio_get_value_request request;
@@ -214,7 +214,7 @@ static void gb_gpio_set_value_operation(struct gb_gpio_controller *ggc,
 }
 
 static int gb_gpio_set_debounce_operation(struct gb_gpio_controller *ggc,
-					u8 which, u16 debounce_usec)
+					  u8 which, u16 debounce_usec)
 {
 	struct gb_gpio_set_debounce_request request;
 	int ret;
@@ -257,7 +257,7 @@ static void _gb_gpio_irq_unmask(struct gb_gpio_controller *ggc, u8 hwirq)
 }
 
 static void _gb_gpio_irq_set_type(struct gb_gpio_controller *ggc,
-					u8 hwirq, u8 type)
+				  u8 hwirq, u8 type)
 {
 	struct device *dev = &ggc->gbphy_dev->dev;
 	struct gb_gpio_irq_type_request request;
@@ -589,10 +589,10 @@ static void gb_gpio_irqchip_remove(struct gb_gpio_controller *ggc)
  * before calling this function.
  */
 static int gb_gpio_irqchip_add(struct gpio_chip *chip,
-			 struct irq_chip *irqchip,
-			 unsigned int first_irq,
-			 irq_flow_handler_t handler,
-			 unsigned int type)
+			       struct irq_chip *irqchip,
+			       unsigned int first_irq,
+			       irq_flow_handler_t handler,
+			       unsigned int type)
 {
 	struct gb_gpio_controller *ggc;
 	unsigned int offset;
@@ -607,8 +607,8 @@ static int gb_gpio_irqchip_add(struct gpio_chip *chip,
 	ggc->irq_handler = handler;
 	ggc->irq_default_type = type;
 	ggc->irqdomain = irq_domain_add_simple(NULL,
-					ggc->line_max + 1, first_irq,
-					&gb_gpio_domain_ops, chip);
+					       ggc->line_max + 1, first_irq,
+					       &gb_gpio_domain_ops, chip);
 	if (!ggc->irqdomain) {
 		ggc->irqchip = NULL;
 		return -EINVAL;
@@ -648,9 +648,10 @@ static int gb_gpio_probe(struct gbphy_device *gbphy_dev,
 	if (!ggc)
 		return -ENOMEM;
 
-	connection = gb_connection_create(gbphy_dev->bundle,
-					  le16_to_cpu(gbphy_dev->cport_desc->id),
-					  gb_gpio_request_handler);
+	connection =
+		gb_connection_create(gbphy_dev->bundle,
+				     le16_to_cpu(gbphy_dev->cport_desc->id),
+				     gb_gpio_request_handler);
 	if (IS_ERR(connection)) {
 		ret = PTR_ERR(connection);
 		goto exit_ggc_free;
@@ -703,7 +704,7 @@ static int gb_gpio_probe(struct gbphy_device *gbphy_dev,
 		goto exit_line_free;
 
 	ret = gb_gpio_irqchip_add(gpio, irqc, 0,
-				   handle_level_irq, IRQ_TYPE_NONE);
+				  handle_level_irq, IRQ_TYPE_NONE);
 	if (ret) {
 		dev_err(&gbphy_dev->dev, "failed to add irq chip: %d\n", ret);
 		goto exit_line_free;

commit 863dbc52e7f0e5acd7b4883f3933543a81c474c7
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Nov 7 14:58:42 2017 +0100

    staging: greybus: Remove redundant license text
    
    Now that the SPDX tag is in all greybus files, that identifies the
    license in a specific and legally-defined manner.  So the extra GPL text
    wording can be removed as it is no longer needed at all.
    
    This is done on a quest to remove the 700+ different ways that files in
    the kernel describe the GPL license text.  And there's unneeded stuff
    like the address (sometimes incorrect) for the FSF which is never
    needed.
    
    No copyright headers or other non-license-description text was removed.
    
    Cc: Vaibhav Hiremath <hvaibhav.linux@gmail.com>
    Reviewed-by: Alex Elder <elder@linaro.org>
    Acked-by: Vaibhav Agarwal <vaibhav.sr@gmail.com>
    Acked-by: David Lin <dtwlin@gmail.com>
    Acked-by: Johan Hovold <johan@kernel.org>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Acked-by: Mark Greer <mgreer@animalcreek.com>
    Acked-by: Rui Miguel Silva <rmfrfs@gmail.com>
    Acked-by: "Bryan O'Donoghue" <pure.logic@nexus-software.ie>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/gpio.c b/drivers/staging/greybus/gpio.c
index 3997c5cb0e6e..b1d4698019a1 100644
--- a/drivers/staging/greybus/gpio.c
+++ b/drivers/staging/greybus/gpio.c
@@ -4,8 +4,6 @@
  *
  * Copyright 2014 Google Inc.
  * Copyright 2014 Linaro Ltd.
- *
- * Released under the GPLv2 only.
  */
 
 #include <linux/kernel.h>

commit eb50fd3a22c770f36be275295b782f3ea52e3215
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Nov 7 14:58:41 2017 +0100

    staging: greybus: add SPDX identifiers to all greybus driver files
    
    It's good to have SPDX identifiers in all files to make it easier to
    audit the kernel tree for correct licenses.
    
    Update the drivers/staging/greybus files files with the correct SPDX
    license identifier based on the license text in the file itself.  The
    SPDX identifier is a legally binding shorthand, which can be used
    instead of the full boiler plate text.
    
    This work is based on a script and data from Thomas Gleixner, Philippe
    Ombredanne, and Kate Stewart.
    
    Cc: Vaibhav Hiremath <hvaibhav.linux@gmail.com>
    Cc: "Bryan O'Donoghue" <pure.logic@nexus-software.ie>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: Philippe Ombredanne <pombredanne@nexb.com>
    Acked-by: Vaibhav Agarwal <vaibhav.sr@gmail.com>
    Acked-by: David Lin <dtwlin@gmail.com>
    Reviewed-by: Alex Elder <elder@linaro.org>
    Acked-by: Johan Hovold <johan@kernel.org>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Acked-by: Mark Greer <mgreer@animalcreek.com>
    Acked-by: Rui Miguel Silva <rmfrfs@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/gpio.c b/drivers/staging/greybus/gpio.c
index ee5f998b174f..3997c5cb0e6e 100644
--- a/drivers/staging/greybus/gpio.c
+++ b/drivers/staging/greybus/gpio.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * GPIO Greybus driver.
  *

commit caa59428971d5ad81d19512365c9ba580d83268c
Merge: b2064617c74f 0a441275018b
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Feb 22 12:14:01 2017 -0800

    Merge tag 'staging-4.11-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/staging
    
    Pull staging/iio driver updates from Greg KH:
     "Here is the big staging and iio driver patchsets for 4.11-rc1.
    
      We almost broke even this time around, with only a few thousand lines
      added overall, as we removed the old and obsolete i4l code, but added
      some new drivers for the RPi platform, as well as adding some new IIO
      drivers.
    
      All of these have been in linux-next for a while with no reported
      issues"
    
    * tag 'staging-4.11-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/staging: (669 commits)
      Staging: vc04_services: Fix the "space prohibited" code style errors
      Staging: vc04_services: Fix the "wrong indent" code style errors
      staging: octeon: Use net_device_stats from struct net_device
      Staging: rtl8192u: ieee80211: ieee80211.h - style fix
      Staging: rtl8192u: ieee80211: ieee80211_tx.c - style fix
      Staging: rtl8192u: ieee80211: rtl819x_BAProc.c - style fix
      Staging: rtl8192u: ieee80211: ieee80211_module.c - style fix
      Staging: rtl8192u: ieee80211: rtl819x_TSProc.c - style fix
      Staging: rtl8192u: r8192U.h - style fix
      Staging: rtl8192u: r8192U_core.c - style fix
      Staging: rtl8192u: r819xU_cmdpkt.c - style fix
      staging: rtl8192u: blank lines aren't necessary before a close brace '}'
      staging: rtl8192u: Adding space after enum and struct definition
      staging: rtl8192u: Adding space after struct definition
      Staging: ks7010: Add required and preferred spaces around operators
      Staging: ks7010: ks*: Remove redundant blank lines
      Staging: ks7010: ks*: Add missing blank lines after declarations
      staging: visorbus, replace init_timer with setup_timer
      staging: vt6656: rxtx.c Removed multiple dereferencing
      staging: vt6656: Alignment match open parenthesis
      ...

commit 461ab8077d573d4a35529572c774a71e5a898a84
Author: Gioh Kim <gi-oh.kim@profitbricks.com>
Date:   Thu Feb 9 17:30:11 2017 +0100

    staging: greybus: fix "line over 80 characters" coding style issues
    
    This patch fixes only obvious lines.
    There are still more issues.
    
    Signed-off-by: Gioh Kim <gi-oh.kim@profitbricks.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/gpio.c b/drivers/staging/greybus/gpio.c
index 558550cfe687..0eabfe1135b5 100644
--- a/drivers/staging/greybus/gpio.c
+++ b/drivers/staging/greybus/gpio.c
@@ -557,7 +557,8 @@ static void gb_gpio_irqchip_remove(struct gb_gpio_controller *ggc)
 	/* Remove all IRQ mappings and delete the domain */
 	if (ggc->irqdomain) {
 		for (offset = 0; offset < (ggc->line_max + 1); offset++)
-			irq_dispose_mapping(irq_find_mapping(ggc->irqdomain, offset));
+			irq_dispose_mapping(irq_find_mapping(ggc->irqdomain,
+							     offset));
 		irq_domain_remove(ggc->irqdomain);
 	}
 

commit 2956b5d94a76b596fa5057c2b3ca915cb27d7652
Author: Mika Westerberg <mika.westerberg@linux.intel.com>
Date:   Mon Jan 23 15:34:34 2017 +0300

    pinctrl / gpio: Introduce .set_config() callback for GPIO chips
    
    Currently we already have two pin configuration related callbacks
    available for GPIO chips .set_single_ended() and .set_debounce(). In
    future we expect to have even more, which does not scale well if we need
    to add yet another callback to the GPIO chip structure for each possible
    configuration parameter.
    
    Better solution is to reuse what we already have available in the
    generic pinconf.
    
    To support this, we introduce a new .set_config() callback for GPIO
    chips. The callback takes a single packed pin configuration value as
    parameter. This can then be extended easily beyond what is currently
    supported by just adding new types to the generic pinconf enum.
    
    If the GPIO driver is backed up by a pinctrl driver the GPIO driver can
    just assign gpiochip_generic_config() (introduced in this patch) to
    .set_config and that will take care configuration requests are directed
    to the pinctrl driver.
    
    We then convert the existing drivers over .set_config() and finally
    remove the .set_single_ended() and .set_debounce() callbacks.
    
    Suggested-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/drivers/staging/greybus/gpio.c b/drivers/staging/greybus/gpio.c
index 250caa00de5e..51384bdde450 100644
--- a/drivers/staging/greybus/gpio.c
+++ b/drivers/staging/greybus/gpio.c
@@ -474,17 +474,20 @@ static void gb_gpio_set(struct gpio_chip *chip, unsigned offset, int value)
 	gb_gpio_set_value_operation(ggc, (u8)offset, !!value);
 }
 
-static int gb_gpio_set_debounce(struct gpio_chip *chip, unsigned offset,
-					unsigned debounce)
+static int gb_gpio_set_config(struct gpio_chip *chip, unsigned offset,
+			      unsigned long config)
 {
 	struct gb_gpio_controller *ggc = gpio_chip_to_gb_gpio_controller(chip);
-	u16 usec;
+	u32 debounce;
 
+	if (pinconf_to_config_param(config) != PIN_CONFIG_INPUT_DEBOUNCE)
+		return -ENOTSUPP;
+
+	debounce = pinconf_to_config_argument(config);
 	if (debounce > U16_MAX)
 		return -EINVAL;
-	usec = (u16)debounce;
 
-	return gb_gpio_set_debounce_operation(ggc, (u8)offset, usec);
+	return gb_gpio_set_debounce_operation(ggc, (u8)offset, (u16)debounce);
 }
 
 static int gb_gpio_controller_setup(struct gb_gpio_controller *ggc)
@@ -689,7 +692,7 @@ static int gb_gpio_probe(struct gbphy_device *gbphy_dev,
 	gpio->direction_output = gb_gpio_direction_output;
 	gpio->get = gb_gpio_get;
 	gpio->set = gb_gpio_set;
-	gpio->set_debounce = gb_gpio_set_debounce;
+	gpio->set_config = gb_gpio_set_config;
 	gpio->to_irq = gb_gpio_to_irq;
 	gpio->base = -1;		/* Allocate base dynamically */
 	gpio->ngpio = ggc->line_max + 1;

commit 1d3dfbd1dd34bd373140d43e4bc827c3c480d3a9
Author: Roman Sommer <roman.sommer@fau.de>
Date:   Fri Jan 13 21:54:51 2017 +0100

    staging: greybus: fix checkpatch unsigned warnings
    
    Fix checkpatch warnings for parameter type unsigned in greybus.
    Note that this patch does not fix all checkpatch warnings for the
    affected files.
    
    Signed-off-by: Christian Bewermeyer <christian.bewermeyer@fau.de>
    Signed-off-by: Roman Sommer <roman.sommer@fau.de>
    Reviewed-by: Johan Hovold <johan@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/gpio.c b/drivers/staging/greybus/gpio.c
index 250caa00de5e..558550cfe687 100644
--- a/drivers/staging/greybus/gpio.c
+++ b/drivers/staging/greybus/gpio.c
@@ -410,21 +410,21 @@ static int gb_gpio_request_handler(struct gb_operation *op)
 	return 0;
 }
 
-static int gb_gpio_request(struct gpio_chip *chip, unsigned offset)
+static int gb_gpio_request(struct gpio_chip *chip, unsigned int offset)
 {
 	struct gb_gpio_controller *ggc = gpio_chip_to_gb_gpio_controller(chip);
 
 	return gb_gpio_activate_operation(ggc, (u8)offset);
 }
 
-static void gb_gpio_free(struct gpio_chip *chip, unsigned offset)
+static void gb_gpio_free(struct gpio_chip *chip, unsigned int offset)
 {
 	struct gb_gpio_controller *ggc = gpio_chip_to_gb_gpio_controller(chip);
 
 	gb_gpio_deactivate_operation(ggc, (u8)offset);
 }
 
-static int gb_gpio_get_direction(struct gpio_chip *chip, unsigned offset)
+static int gb_gpio_get_direction(struct gpio_chip *chip, unsigned int offset)
 {
 	struct gb_gpio_controller *ggc = gpio_chip_to_gb_gpio_controller(chip);
 	u8 which;
@@ -438,22 +438,22 @@ static int gb_gpio_get_direction(struct gpio_chip *chip, unsigned offset)
 	return ggc->lines[which].direction ? 1 : 0;
 }
 
-static int gb_gpio_direction_input(struct gpio_chip *chip, unsigned offset)
+static int gb_gpio_direction_input(struct gpio_chip *chip, unsigned int offset)
 {
 	struct gb_gpio_controller *ggc = gpio_chip_to_gb_gpio_controller(chip);
 
 	return gb_gpio_direction_in_operation(ggc, (u8)offset);
 }
 
-static int gb_gpio_direction_output(struct gpio_chip *chip, unsigned offset,
-					int value)
+static int gb_gpio_direction_output(struct gpio_chip *chip, unsigned int offset,
+				    int value)
 {
 	struct gb_gpio_controller *ggc = gpio_chip_to_gb_gpio_controller(chip);
 
 	return gb_gpio_direction_out_operation(ggc, (u8)offset, !!value);
 }
 
-static int gb_gpio_get(struct gpio_chip *chip, unsigned offset)
+static int gb_gpio_get(struct gpio_chip *chip, unsigned int offset)
 {
 	struct gb_gpio_controller *ggc = gpio_chip_to_gb_gpio_controller(chip);
 	u8 which;
@@ -467,15 +467,15 @@ static int gb_gpio_get(struct gpio_chip *chip, unsigned offset)
 	return ggc->lines[which].value;
 }
 
-static void gb_gpio_set(struct gpio_chip *chip, unsigned offset, int value)
+static void gb_gpio_set(struct gpio_chip *chip, unsigned int offset, int value)
 {
 	struct gb_gpio_controller *ggc = gpio_chip_to_gb_gpio_controller(chip);
 
 	gb_gpio_set_value_operation(ggc, (u8)offset, !!value);
 }
 
-static int gb_gpio_set_debounce(struct gpio_chip *chip, unsigned offset,
-					unsigned debounce)
+static int gb_gpio_set_debounce(struct gpio_chip *chip, unsigned int offset,
+				unsigned int debounce)
 {
 	struct gb_gpio_controller *ggc = gpio_chip_to_gb_gpio_controller(chip);
 	u16 usec;
@@ -593,7 +593,7 @@ static int gb_gpio_irqchip_add(struct gpio_chip *chip,
 {
 	struct gb_gpio_controller *ggc;
 	unsigned int offset;
-	unsigned irq_base;
+	unsigned int irq_base;
 
 	if (!chip || !irqchip)
 		return -EINVAL;
@@ -625,7 +625,7 @@ static int gb_gpio_irqchip_add(struct gpio_chip *chip,
 	return 0;
 }
 
-static int gb_gpio_to_irq(struct gpio_chip *chip, unsigned offset)
+static int gb_gpio_to_irq(struct gpio_chip *chip, unsigned int offset)
 {
 	struct gb_gpio_controller *ggc = gpio_chip_to_gb_gpio_controller(chip);
 

commit 039bea844016ae85eaf195bf25266b5eb028a319
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Wed Oct 12 08:02:21 2016 +0530

    Staging: greybus: gpio: Use gbphy_dev->dev instead of bundle->dev
    
    Some of the print messages are using the incorrect device pointer, fix
    them.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Acked-by: Johan Hovold <johan@kernel.org>
    Reviewed-by: Rui Miguel Silva <rmfrfs@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/gpio.c b/drivers/staging/greybus/gpio.c
index 5e06e4229e42..250caa00de5e 100644
--- a/drivers/staging/greybus/gpio.c
+++ b/drivers/staging/greybus/gpio.c
@@ -702,15 +702,13 @@ static int gb_gpio_probe(struct gbphy_device *gbphy_dev,
 	ret = gb_gpio_irqchip_add(gpio, irqc, 0,
 				   handle_level_irq, IRQ_TYPE_NONE);
 	if (ret) {
-		dev_err(&connection->bundle->dev,
-			"failed to add irq chip: %d\n", ret);
+		dev_err(&gbphy_dev->dev, "failed to add irq chip: %d\n", ret);
 		goto exit_line_free;
 	}
 
 	ret = gpiochip_add(gpio);
 	if (ret) {
-		dev_err(&connection->bundle->dev,
-			"failed to add gpio chip: %d\n", ret);
+		dev_err(&gbphy_dev->dev, "failed to add gpio chip: %d\n", ret);
 		goto exit_gpio_irqchip_remove;
 	}
 

commit 3d7f3588553a9ee392aa1abb5a3e8fd4b1ba8f5e
Author: Chase Metzger <chasemetzger15@gmail.com>
Date:   Sun Sep 25 13:35:47 2016 -0700

    drivers/staging/greybus: gpio.c - Fixed a checkpatch generated warning
    
    Removed braces for single line if statement.
    
    Signed-off-by: Chase Metzger <chasemetzger15@gmail.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/gpio.c b/drivers/staging/greybus/gpio.c
index ea8234abf185..5e06e4229e42 100644
--- a/drivers/staging/greybus/gpio.c
+++ b/drivers/staging/greybus/gpio.c
@@ -561,9 +561,8 @@ static void gb_gpio_irqchip_remove(struct gb_gpio_controller *ggc)
 		irq_domain_remove(ggc->irqdomain);
 	}
 
-	if (ggc->irqchip) {
+	if (ggc->irqchip)
 		ggc->irqchip = NULL;
-	}
 }
 
 /**

commit b14bb976260077415047737a0032f89275622c96
Author: Greg Kroah-Hartman <gregkh@google.com>
Date:   Thu Sep 8 15:52:06 2016 +0200

    staging: greybus: gpio: remove KERNEL_VERSION checks
    
    No need to support older kernel versions in the Greybus GPIO driver, so
    remove the checks as needed, we can now rely on all of the correct
    GPIO core apis being present.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/gpio.c b/drivers/staging/greybus/gpio.c
index 294e2f52f1d4..ea8234abf185 100644
--- a/drivers/staging/greybus/gpio.c
+++ b/drivers/staging/greybus/gpio.c
@@ -404,11 +404,7 @@ static int gb_gpio_request_handler(struct gb_operation *op)
 	}
 
 	local_irq_disable();
-#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 3, 0)
-	generic_handle_irq_desc(irq, desc);
-#else
 	generic_handle_irq_desc(desc);
-#endif
 	local_irq_enable();
 
 	return 0;
@@ -684,11 +680,7 @@ static int gb_gpio_probe(struct gbphy_device *gbphy_dev,
 	gpio = &ggc->chip;
 
 	gpio->label = "greybus_gpio";
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 5, 0)
 	gpio->parent = &gbphy_dev->dev;
-#else
-	gpio->dev = &gbphy_dev->dev;
-#endif
 	gpio->owner = THIS_MODULE;
 
 	gpio->request = gb_gpio_request;
@@ -750,7 +742,7 @@ static void gb_gpio_remove(struct gbphy_device *gbphy_dev)
 		gbphy_runtime_get_noresume(gbphy_dev);
 
 	gb_connection_disable_rx(connection);
-	gb_gpiochip_remove(&ggc->chip);
+	gpiochip_remove(&ggc->chip);
 	gb_gpio_irqchip_remove(ggc);
 	gb_connection_disable(connection);
 	gb_connection_destroy(connection);

commit 88f6ba61f25bfe6eb92cb8f511b0879cdfbb64d3
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Wed Aug 3 15:52:10 2016 -0700

    greybus: gpio: create irqdomain before registering gpio controller
    
    If a gpio line is getting used for an irq, gpio core will create
    /proc/irq/X/gpiolib/ directory for it. This directory gets removed while
    the gpio controller is unregistered.
    
    In case of greybus, gb_gpio_irqchip_add() creates an irqdomain and
    creates irq mappings for the gpio lines. Currently they are added after
    registering the gpio controller and removed before the gpio controller
    is removed. On the removal path, while the core tries to remove the irq
    directory (/proc/irq/X), it finds that the irq is still getting used and
    a "gpiolib" directory is present within it and so it gives this warning:
    
    Steps to reproduce:
    
        $ cd /sys/class/gpio
        $ echo X > export
        $ echo both > gpioX/edge
        $ echo <interface-number> > /sys/bus/greybus/devices/1-svc/intf_eject
    
    [  139.171436] ------------[ cut here ]------------
    [  139.171468] WARNING: at /home/vireshk/all/work/repos/ara/arche/kernel/arche/fs/proc/generic.c:552 remove_proc_entry+0x154/0x188()
    [  139.171476] remove_proc_entry: removing non-empty directory 'irq/683', leaking at least 'gpiolib'
    [  139.171589] Modules linked in: gb_vibrator(O) gb_usb(O) gb_uart(O) gb_spi(O) gb_sdio(O) gb_raw(O) gb_pwm(O) gb_power_supply(O) gb_loopback(O) gb_log(O) gb_light(O) gb_i2c(O) gb_hid(O) gb_gpio(O) gb_gbphy(O) gb_firmware(O) gb_spilib(O) gb_es2(O) gb_camera(O) gb_bootrom(O) gb_audio_module(O) gb_audio_manager(O) gb_audio_codec(O) gb_audio_gb(O) gb_audio_apbridgea(O) gb_arche(O) greybus(O)
    [  139.171605] CPU: 1 PID: 280 Comm: kworker/u16:4 Tainted: G        W  O 3.10.83-g9771b10cbeed #107
    [  139.171652] Workqueue: greybus1:svc gb_svc_intf_set_power_mode [greybus]
    [  139.171657] Call trace:
    [  139.171677] [<ffffffc000207b40>] dump_backtrace+0x0/0x268
    [  139.171689] [<ffffffc000207db8>] show_stack+0x10/0x1c
    [  139.171707] [<ffffffc000ccad78>] dump_stack+0x1c/0x28
    [  139.171723] [<ffffffc00021f9dc>] warn_slowpath_common+0x74/0x9c
    [  139.171735] [<ffffffc00021fa60>] warn_slowpath_fmt+0x5c/0x80
    [  139.171747] [<ffffffc00035fa38>] remove_proc_entry+0x150/0x188
    [  139.171763] [<ffffffc00027464c>] unregister_irq_proc+0xb4/0xdc
    [  139.171779] [<ffffffc00026e3f4>] free_desc+0x2c/0x70
    [  139.171791] [<ffffffc00026e48c>] irq_free_descs+0x54/0x9c
    [  139.171802] [<ffffffc000273448>] irq_dispose_mapping+0x54/0x64
    [  139.171814] [<ffffffbffc0621e8>] 0xffffffbffc0621e8
    [  139.171825] [<ffffffbffc05e01c>] 0xffffffbffc05e01c
    [  139.171843] [<ffffffc0005d4e30>] __device_release_driver+0x90/0xe4
    [  139.171854] [<ffffffc0005d4ea4>] device_release_driver+0x20/0x38
    [  139.171867] [<ffffffc0005d4634>] bus_remove_device+0x12c/0x148
    [  139.171878] [<ffffffc0005d1cb0>] device_del+0x108/0x16c
    [  139.171888] [<ffffffc0005d1d64>] device_unregister+0x50/0x68
    [  139.171901] [<ffffffbffc05e2bc>] gb_gbphy_deregister_driver+0xf0/0x4ec [gb_gbphy]
    [  139.171924] [<ffffffbffc0014c4>] greybus_disabled+0x14c4/0x1760 [greybus]
    [  139.171936] [<ffffffc0005d4e30>] __device_release_driver+0x90/0xe4
    [  139.171948] [<ffffffc0005d4ea4>] device_release_driver+0x20/0x38
    [  139.171959] [<ffffffc0005d4634>] bus_remove_device+0x12c/0x148
    [  139.171969] [<ffffffc0005d1cb0>] device_del+0x108/0x16c
    [  139.171992] [<ffffffbffc004cec>] gb_bundle_destroy+0x7c/0x1b0 [greybus]
    [  139.172017] [<ffffffbffc004074>] gb_interface_disable+0xb4/0x178 [greybus]
    [  139.172040] [<ffffffbffc002ae4>] gb_module_del+0x5c/0xf8 [greybus]
    [  139.172063] [<ffffffbffc008418>] gb_svc_intf_set_power_mode+0xea0/0xfe8 [greybus]
    [  139.172078] [<ffffffc00023888c>] process_one_work+0x268/0x3c8
    [  139.172089] [<ffffffc000239a64>] worker_thread+0x204/0x358
    [  139.172108] [<ffffffc00023f43c>] kthread+0xb8/0xc4
    [  139.172114] ---[ end trace 6fa3314e8c6157ca ]---
    
    Also note that registering the gpio controller before creating irqdomain
    is incorrect as well and may lead to kernel panic, as a gpio may get
    requested as an interrupt source right after the controller is
    registered, and the greybus gpio driver wouldn't be fully ready by then.
    
    This patch changes the sequence in both probe() and remove() to fix it.
    
    Fixes: 426e88a47d39 ("greybus: gpio: add interrupt handling support")
    Reported-by: David Hsu <davidhsu@google.com>
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/gpio.c b/drivers/staging/greybus/gpio.c
index 8fa9998b4c3d..294e2f52f1d4 100644
--- a/drivers/staging/greybus/gpio.c
+++ b/drivers/staging/greybus/gpio.c
@@ -708,26 +708,26 @@ static int gb_gpio_probe(struct gbphy_device *gbphy_dev,
 	if (ret)
 		goto exit_line_free;
 
-	ret = gpiochip_add(gpio);
+	ret = gb_gpio_irqchip_add(gpio, irqc, 0,
+				   handle_level_irq, IRQ_TYPE_NONE);
 	if (ret) {
 		dev_err(&connection->bundle->dev,
-			"failed to add gpio chip: %d\n", ret);
+			"failed to add irq chip: %d\n", ret);
 		goto exit_line_free;
 	}
 
-	ret = gb_gpio_irqchip_add(gpio, irqc, 0,
-				   handle_level_irq, IRQ_TYPE_NONE);
+	ret = gpiochip_add(gpio);
 	if (ret) {
 		dev_err(&connection->bundle->dev,
-			"failed to add irq chip: %d\n", ret);
-		goto exit_gpiochip_remove;
+			"failed to add gpio chip: %d\n", ret);
+		goto exit_gpio_irqchip_remove;
 	}
 
 	gbphy_runtime_put_autosuspend(gbphy_dev);
 	return 0;
 
-exit_gpiochip_remove:
-	gb_gpiochip_remove(gpio);
+exit_gpio_irqchip_remove:
+	gb_gpio_irqchip_remove(ggc);
 exit_line_free:
 	kfree(ggc->lines);
 exit_connection_disable:
@@ -750,8 +750,8 @@ static void gb_gpio_remove(struct gbphy_device *gbphy_dev)
 		gbphy_runtime_get_noresume(gbphy_dev);
 
 	gb_connection_disable_rx(connection);
-	gb_gpio_irqchip_remove(ggc);
 	gb_gpiochip_remove(&ggc->chip);
+	gb_gpio_irqchip_remove(ggc);
 	gb_connection_disable(connection);
 	gb_connection_destroy(connection);
 	kfree(ggc->lines);

commit 993dc992f2e415adf9ddc69476ebaefda6af1043
Author: Axel Haslam <haslam_axel@projectara.com>
Date:   Thu Jul 14 15:13:00 2016 -0500

    greybus: gpio: Add runtime_pm suppourt
    
    Add runtime pm support for the gpio driver.
    Since there is no remote wakeup support, the
    module will not suspend as long as a gpio is
    requested.
    
    Maybe an optimization could be made, to allow suspend
    if all the requested gpios are in output mode, since
    the bridge should maintain the state of the gpio
    during suspend.
    
    Testing Done: using the test board, let the
    gpbrige enter standby and request a gpio.
    
    Signed-off-by: Axel Haslam <haslam_axel@projectara.com>
    Signed-off-by: David Lin <dtwlin@google.com>
    Reviewed-by: Johan Hovold <johan@hovoldconsulting.com>
    Signed-off-by: Alex Elder <elder@linaro.org>

diff --git a/drivers/staging/greybus/gpio.c b/drivers/staging/greybus/gpio.c
index deae2658c7a8..8fa9998b4c3d 100644
--- a/drivers/staging/greybus/gpio.c
+++ b/drivers/staging/greybus/gpio.c
@@ -66,20 +66,31 @@ static int gb_gpio_line_count_operation(struct gb_gpio_controller *ggc)
 static int gb_gpio_activate_operation(struct gb_gpio_controller *ggc, u8 which)
 {
 	struct gb_gpio_activate_request request;
+	struct gbphy_device *gbphy_dev = ggc->gbphy_dev;
 	int ret;
 
+	ret = gbphy_runtime_get_sync(gbphy_dev);
+	if (ret)
+		return ret;
+
 	request.which = which;
 	ret = gb_operation_sync(ggc->connection, GB_GPIO_TYPE_ACTIVATE,
 				 &request, sizeof(request), NULL, 0);
-	if (!ret)
-		ggc->lines[which].active = true;
-	return ret;
+	if (ret) {
+		gbphy_runtime_put_autosuspend(gbphy_dev);
+		return ret;
+	}
+
+	ggc->lines[which].active = true;
+
+	return 0;
 }
 
 static void gb_gpio_deactivate_operation(struct gb_gpio_controller *ggc,
 					u8 which)
 {
-	struct device *dev = &ggc->gbphy_dev->dev;
+	struct gbphy_device *gbphy_dev = ggc->gbphy_dev;
+	struct device *dev = &gbphy_dev->dev;
 	struct gb_gpio_deactivate_request request;
 	int ret;
 
@@ -88,10 +99,13 @@ static void gb_gpio_deactivate_operation(struct gb_gpio_controller *ggc,
 				 &request, sizeof(request), NULL, 0);
 	if (ret) {
 		dev_err(dev, "failed to deactivate gpio %u\n", which);
-		return;
+		goto out_pm_put;
 	}
 
 	ggc->lines[which].active = false;
+
+out_pm_put:
+	gbphy_runtime_put_autosuspend(gbphy_dev);
 }
 
 static int gb_gpio_get_direction_operation(struct gb_gpio_controller *ggc,
@@ -709,6 +723,7 @@ static int gb_gpio_probe(struct gbphy_device *gbphy_dev,
 		goto exit_gpiochip_remove;
 	}
 
+	gbphy_runtime_put_autosuspend(gbphy_dev);
 	return 0;
 
 exit_gpiochip_remove:
@@ -728,6 +743,11 @@ static void gb_gpio_remove(struct gbphy_device *gbphy_dev)
 {
 	struct gb_gpio_controller *ggc = gb_gbphy_get_data(gbphy_dev);
 	struct gb_connection *connection = ggc->connection;
+	int ret;
+
+	ret = gbphy_runtime_get_sync(gbphy_dev);
+	if (ret)
+		gbphy_runtime_get_noresume(gbphy_dev);
 
 	gb_connection_disable_rx(connection);
 	gb_gpio_irqchip_remove(ggc);

commit 60fb3405c73ea0bbab942c699496123f9e987c04
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Fri Jun 10 14:59:07 2016 +0530

    greybus: Remove extra blank lines
    
    This patch removes few blank lines across the repository at places where
    two blank lines were present together or when a blank line is present at
    the start or end of a routine.
    
    Note that this doesn't remove most of them from greybus_protocols.h as
    they were added on purpose.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/gpio.c b/drivers/staging/greybus/gpio.c
index f60cc1da9f05..deae2658c7a8 100644
--- a/drivers/staging/greybus/gpio.c
+++ b/drivers/staging/greybus/gpio.c
@@ -556,7 +556,6 @@ static void gb_gpio_irqchip_remove(struct gb_gpio_controller *ggc)
 	}
 }
 
-
 /**
  * gb_gpio_irqchip_add() - adds an irqchip to a gpio chip
  * @chip: the gpio chip to add the irqchip to

commit 64060fe95458f22bac7327b2ee8dc5ce9e488d44
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Mon May 30 11:31:53 2016 +0530

    greybus: gbphy: Remove protocol specific version handling
    
    We should be using the generic version handling at bundle level, instead
    of at protocol level for bridged PHY devices as well.
    
    The bundle version handling is already in place, though it is *not* used
    today as we haven't bumped the version of control protocol yet.
    
    Remove protocol specific handling for bridged PHY devices.
    
    Tested on EVT 1.5 with gpbridge-test module. No nuttx changes are
    required with this.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Reviewed-by: Johan Hovold <johan@hovoldconsulting.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/gpio.c b/drivers/staging/greybus/gpio.c
index e1ad6802630a..f60cc1da9f05 100644
--- a/drivers/staging/greybus/gpio.c
+++ b/drivers/staging/greybus/gpio.c
@@ -654,10 +654,6 @@ static int gb_gpio_probe(struct gbphy_device *gbphy_dev,
 	if (ret)
 		goto exit_connection_destroy;
 
-	ret = gb_gbphy_get_version(connection);
-	if (ret)
-		goto exit_connection_disable;
-
 	ret = gb_gpio_controller_setup(ggc);
 	if (ret)
 		goto exit_connection_disable;

commit e54b106dd1be50377fe8365392466e080b659ab6
Author: Sandeep Patil <patil_sandeep@projectara.com>
Date:   Thu May 19 08:52:39 2016 -0700

    greybus: gpbridge: rename 'gpbridge' to 'gbphy' everywhere
    
    The 'gpbridge' name didn't relaly reflect what the bus is; which
    is a bus for bridged-phy devices. So, rename all instances
    of 'gpbridge' to more appropriate 'gbphy'
    
    Testing Done:
    Build and boot tested. 'lsgb' will stop displaying 'GPBridge' devices
    until I change the library to reflect this change.
    
    Signed-off-by: Sandeep Patil <patil_sandeep@projectara.com>
    Suggested-by: Greg Kroah-Hartman <gregkh@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/gpio.c b/drivers/staging/greybus/gpio.c
index adb213fd81b6..e1ad6802630a 100644
--- a/drivers/staging/greybus/gpio.c
+++ b/drivers/staging/greybus/gpio.c
@@ -16,7 +16,7 @@
 #include <linux/mutex.h>
 
 #include "greybus.h"
-#include "gpbridge.h"
+#include "gbphy.h"
 
 struct gb_gpio_line {
 	/* The following has to be an array of line_max entries */
@@ -33,7 +33,7 @@ struct gb_gpio_line {
 };
 
 struct gb_gpio_controller {
-	struct gpbridge_device	*gpbdev;
+	struct gbphy_device	*gbphy_dev;
 	struct gb_connection	*connection;
 	u8			line_max;	/* max line number */
 	struct gb_gpio_line	*lines;
@@ -79,7 +79,7 @@ static int gb_gpio_activate_operation(struct gb_gpio_controller *ggc, u8 which)
 static void gb_gpio_deactivate_operation(struct gb_gpio_controller *ggc,
 					u8 which)
 {
-	struct device *dev = &ggc->gpbdev->dev;
+	struct device *dev = &ggc->gbphy_dev->dev;
 	struct gb_gpio_deactivate_request request;
 	int ret;
 
@@ -97,7 +97,7 @@ static void gb_gpio_deactivate_operation(struct gb_gpio_controller *ggc,
 static int gb_gpio_get_direction_operation(struct gb_gpio_controller *ggc,
 					u8 which)
 {
-	struct device *dev = &ggc->gpbdev->dev;
+	struct device *dev = &ggc->gbphy_dev->dev;
 	struct gb_gpio_get_direction_request request;
 	struct gb_gpio_get_direction_response response;
 	int ret;
@@ -151,7 +151,7 @@ static int gb_gpio_direction_out_operation(struct gb_gpio_controller *ggc,
 static int gb_gpio_get_value_operation(struct gb_gpio_controller *ggc,
 					u8 which)
 {
-	struct device *dev = &ggc->gpbdev->dev;
+	struct device *dev = &ggc->gbphy_dev->dev;
 	struct gb_gpio_get_value_request request;
 	struct gb_gpio_get_value_response response;
 	int ret;
@@ -178,7 +178,7 @@ static int gb_gpio_get_value_operation(struct gb_gpio_controller *ggc,
 static void gb_gpio_set_value_operation(struct gb_gpio_controller *ggc,
 					u8 which, bool value_high)
 {
-	struct device *dev = &ggc->gpbdev->dev;
+	struct device *dev = &ggc->gbphy_dev->dev;
 	struct gb_gpio_set_value_request request;
 	int ret;
 
@@ -217,7 +217,7 @@ static int gb_gpio_set_debounce_operation(struct gb_gpio_controller *ggc,
 
 static void _gb_gpio_irq_mask(struct gb_gpio_controller *ggc, u8 hwirq)
 {
-	struct device *dev = &ggc->gpbdev->dev;
+	struct device *dev = &ggc->gbphy_dev->dev;
 	struct gb_gpio_irq_mask_request request;
 	int ret;
 
@@ -231,7 +231,7 @@ static void _gb_gpio_irq_mask(struct gb_gpio_controller *ggc, u8 hwirq)
 
 static void _gb_gpio_irq_unmask(struct gb_gpio_controller *ggc, u8 hwirq)
 {
-	struct device *dev = &ggc->gpbdev->dev;
+	struct device *dev = &ggc->gbphy_dev->dev;
 	struct gb_gpio_irq_unmask_request request;
 	int ret;
 
@@ -246,7 +246,7 @@ static void _gb_gpio_irq_unmask(struct gb_gpio_controller *ggc, u8 hwirq)
 static void _gb_gpio_irq_set_type(struct gb_gpio_controller *ggc,
 					u8 hwirq, u8 type)
 {
-	struct device *dev = &ggc->gpbdev->dev;
+	struct device *dev = &ggc->gbphy_dev->dev;
 	struct gb_gpio_irq_type_request request;
 	int ret;
 
@@ -285,7 +285,7 @@ static int gb_gpio_irq_set_type(struct irq_data *d, unsigned int type)
 	struct gpio_chip *chip = irq_data_to_gpio_chip(d);
 	struct gb_gpio_controller *ggc = gpio_chip_to_gb_gpio_controller(chip);
 	struct gb_gpio_line *line = &ggc->lines[d->hwirq];
-	struct device *dev = &ggc->gpbdev->dev;
+	struct device *dev = &ggc->gbphy_dev->dev;
 	u8 irq_type;
 
 	switch (type) {
@@ -352,7 +352,7 @@ static int gb_gpio_request_handler(struct gb_operation *op)
 {
 	struct gb_connection *connection = op->connection;
 	struct gb_gpio_controller *ggc = gb_connection_get_data(connection);
-	struct device *dev = &ggc->gpbdev->dev;
+	struct device *dev = &ggc->gbphy_dev->dev;
 	struct gb_message *request;
 	struct gb_gpio_irq_event_request *event;
 	u8 type = op->type;
@@ -624,8 +624,8 @@ static int gb_gpio_to_irq(struct gpio_chip *chip, unsigned offset)
 	return irq_find_mapping(ggc->irqdomain, offset);
 }
 
-static int gb_gpio_probe(struct gpbridge_device *gpbdev,
-			 const struct gpbridge_device_id *id)
+static int gb_gpio_probe(struct gbphy_device *gbphy_dev,
+			 const struct gbphy_device_id *id)
 {
 	struct gb_connection *connection;
 	struct gb_gpio_controller *ggc;
@@ -637,8 +637,8 @@ static int gb_gpio_probe(struct gpbridge_device *gpbdev,
 	if (!ggc)
 		return -ENOMEM;
 
-	connection = gb_connection_create(gpbdev->bundle,
-					  le16_to_cpu(gpbdev->cport_desc->id),
+	connection = gb_connection_create(gbphy_dev->bundle,
+					  le16_to_cpu(gbphy_dev->cport_desc->id),
 					  gb_gpio_request_handler);
 	if (IS_ERR(connection)) {
 		ret = PTR_ERR(connection);
@@ -647,14 +647,14 @@ static int gb_gpio_probe(struct gpbridge_device *gpbdev,
 
 	ggc->connection = connection;
 	gb_connection_set_data(connection, ggc);
-	ggc->gpbdev = gpbdev;
-	gb_gpbridge_set_data(gpbdev, ggc);
+	ggc->gbphy_dev = gbphy_dev;
+	gb_gbphy_set_data(gbphy_dev, ggc);
 
 	ret = gb_connection_enable_tx(connection);
 	if (ret)
 		goto exit_connection_destroy;
 
-	ret = gb_gpbridge_get_version(connection);
+	ret = gb_gbphy_get_version(connection);
 	if (ret)
 		goto exit_connection_disable;
 
@@ -676,9 +676,9 @@ static int gb_gpio_probe(struct gpbridge_device *gpbdev,
 
 	gpio->label = "greybus_gpio";
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 5, 0)
-	gpio->parent = &gpbdev->dev;
+	gpio->parent = &gbphy_dev->dev;
 #else
-	gpio->dev = &gpbdev->dev;
+	gpio->dev = &gbphy_dev->dev;
 #endif
 	gpio->owner = THIS_MODULE;
 
@@ -729,9 +729,9 @@ static int gb_gpio_probe(struct gpbridge_device *gpbdev,
 	return ret;
 }
 
-static void gb_gpio_remove(struct gpbridge_device *gpbdev)
+static void gb_gpio_remove(struct gbphy_device *gbphy_dev)
 {
-	struct gb_gpio_controller *ggc = gb_gpbridge_get_data(gpbdev);
+	struct gb_gpio_controller *ggc = gb_gbphy_get_data(gbphy_dev);
 	struct gb_connection *connection = ggc->connection;
 
 	gb_connection_disable_rx(connection);
@@ -743,18 +743,18 @@ static void gb_gpio_remove(struct gpbridge_device *gpbdev)
 	kfree(ggc);
 }
 
-static const struct gpbridge_device_id gb_gpio_id_table[] = {
-	{ GPBRIDGE_PROTOCOL(GREYBUS_PROTOCOL_GPIO) },
+static const struct gbphy_device_id gb_gpio_id_table[] = {
+	{ GBPHY_PROTOCOL(GREYBUS_PROTOCOL_GPIO) },
 	{ },
 };
-MODULE_DEVICE_TABLE(gpbridge, gb_gpio_id_table);
+MODULE_DEVICE_TABLE(gbphy, gb_gpio_id_table);
 
-static struct gpbridge_driver gpio_driver = {
+static struct gbphy_driver gpio_driver = {
 	.name		= "gpio",
 	.probe		= gb_gpio_probe,
 	.remove		= gb_gpio_remove,
 	.id_table	= gb_gpio_id_table,
 };
 
-module_gpbridge_driver(gpio_driver);
+module_gbphy_driver(gpio_driver);
 MODULE_LICENSE("GPL v2");

commit 7c0925eb57785190be3d9f3d173fefb3d791cba0
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Mon May 9 18:15:06 2016 +0530

    greybus: gpio: Create separate module
    
    Create separate module for gpio gpbridge driver.
    
    Tested on EVT 1.5 by inserting GP test module, all the devices were
    enumerated correctly.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/gpio.c b/drivers/staging/greybus/gpio.c
index 4f0695b2b20e..adb213fd81b6 100644
--- a/drivers/staging/greybus/gpio.c
+++ b/drivers/staging/greybus/gpio.c
@@ -747,6 +747,7 @@ static const struct gpbridge_device_id gb_gpio_id_table[] = {
 	{ GPBRIDGE_PROTOCOL(GREYBUS_PROTOCOL_GPIO) },
 	{ },
 };
+MODULE_DEVICE_TABLE(gpbridge, gb_gpio_id_table);
 
 static struct gpbridge_driver gpio_driver = {
 	.name		= "gpio",
@@ -754,4 +755,6 @@ static struct gpbridge_driver gpio_driver = {
 	.remove		= gb_gpio_remove,
 	.id_table	= gb_gpio_id_table,
 };
-gb_gpbridge_builtin_driver(gpio_driver);
+
+module_gpbridge_driver(gpio_driver);
+MODULE_LICENSE("GPL v2");

commit 315bea0e9605a2f506606bdb2a531149a022394d
Author: Greg Kroah-Hartman <gregkh@google.com>
Date:   Thu May 5 14:32:33 2016 +0530

    greybus: GPIO: convert to a gpbridge driver
    
    This converts the GPIO driver to be a gpbridge driver, moving it away
    from the "legacy" interface.
    
    Testing Done: Tested on gbsim.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>
    Signed-off-by: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
    [vaibhav.hiremath@linaro.org: 1.Changed code to retain init/exit fns of
    drivers. 2.Exit path fix. 3. Fixed review comments]
    Reviewed-by: Viresh Kumar <viresh.kumar@linaro.org>
    Tested-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/gpio.c b/drivers/staging/greybus/gpio.c
index 440ff44c8524..4f0695b2b20e 100644
--- a/drivers/staging/greybus/gpio.c
+++ b/drivers/staging/greybus/gpio.c
@@ -33,6 +33,7 @@ struct gb_gpio_line {
 };
 
 struct gb_gpio_controller {
+	struct gpbridge_device	*gpbdev;
 	struct gb_connection	*connection;
 	u8			line_max;	/* max line number */
 	struct gb_gpio_line	*lines;
@@ -78,7 +79,7 @@ static int gb_gpio_activate_operation(struct gb_gpio_controller *ggc, u8 which)
 static void gb_gpio_deactivate_operation(struct gb_gpio_controller *ggc,
 					u8 which)
 {
-	struct device *dev = &ggc->connection->bundle->dev;
+	struct device *dev = &ggc->gpbdev->dev;
 	struct gb_gpio_deactivate_request request;
 	int ret;
 
@@ -96,7 +97,7 @@ static void gb_gpio_deactivate_operation(struct gb_gpio_controller *ggc,
 static int gb_gpio_get_direction_operation(struct gb_gpio_controller *ggc,
 					u8 which)
 {
-	struct device *dev = &ggc->connection->bundle->dev;
+	struct device *dev = &ggc->gpbdev->dev;
 	struct gb_gpio_get_direction_request request;
 	struct gb_gpio_get_direction_response response;
 	int ret;
@@ -150,7 +151,7 @@ static int gb_gpio_direction_out_operation(struct gb_gpio_controller *ggc,
 static int gb_gpio_get_value_operation(struct gb_gpio_controller *ggc,
 					u8 which)
 {
-	struct device *dev = &ggc->connection->bundle->dev;
+	struct device *dev = &ggc->gpbdev->dev;
 	struct gb_gpio_get_value_request request;
 	struct gb_gpio_get_value_response response;
 	int ret;
@@ -177,7 +178,7 @@ static int gb_gpio_get_value_operation(struct gb_gpio_controller *ggc,
 static void gb_gpio_set_value_operation(struct gb_gpio_controller *ggc,
 					u8 which, bool value_high)
 {
-	struct device *dev = &ggc->connection->bundle->dev;
+	struct device *dev = &ggc->gpbdev->dev;
 	struct gb_gpio_set_value_request request;
 	int ret;
 
@@ -216,7 +217,7 @@ static int gb_gpio_set_debounce_operation(struct gb_gpio_controller *ggc,
 
 static void _gb_gpio_irq_mask(struct gb_gpio_controller *ggc, u8 hwirq)
 {
-	struct device *dev = &ggc->connection->bundle->dev;
+	struct device *dev = &ggc->gpbdev->dev;
 	struct gb_gpio_irq_mask_request request;
 	int ret;
 
@@ -230,7 +231,7 @@ static void _gb_gpio_irq_mask(struct gb_gpio_controller *ggc, u8 hwirq)
 
 static void _gb_gpio_irq_unmask(struct gb_gpio_controller *ggc, u8 hwirq)
 {
-	struct device *dev = &ggc->connection->bundle->dev;
+	struct device *dev = &ggc->gpbdev->dev;
 	struct gb_gpio_irq_unmask_request request;
 	int ret;
 
@@ -245,7 +246,7 @@ static void _gb_gpio_irq_unmask(struct gb_gpio_controller *ggc, u8 hwirq)
 static void _gb_gpio_irq_set_type(struct gb_gpio_controller *ggc,
 					u8 hwirq, u8 type)
 {
-	struct device *dev = &ggc->connection->bundle->dev;
+	struct device *dev = &ggc->gpbdev->dev;
 	struct gb_gpio_irq_type_request request;
 	int ret;
 
@@ -284,7 +285,7 @@ static int gb_gpio_irq_set_type(struct irq_data *d, unsigned int type)
 	struct gpio_chip *chip = irq_data_to_gpio_chip(d);
 	struct gb_gpio_controller *ggc = gpio_chip_to_gb_gpio_controller(chip);
 	struct gb_gpio_line *line = &ggc->lines[d->hwirq];
-	struct device *dev = &ggc->connection->bundle->dev;
+	struct device *dev = &ggc->gpbdev->dev;
 	u8 irq_type;
 
 	switch (type) {
@@ -347,13 +348,14 @@ static void gb_gpio_irq_bus_sync_unlock(struct irq_data *d)
 	mutex_unlock(&ggc->irq_lock);
 }
 
-static int gb_gpio_request_recv(u8 type, struct gb_operation *op)
+static int gb_gpio_request_handler(struct gb_operation *op)
 {
 	struct gb_connection *connection = op->connection;
-	struct device *dev = &connection->bundle->dev;
 	struct gb_gpio_controller *ggc = gb_connection_get_data(connection);
+	struct device *dev = &ggc->gpbdev->dev;
 	struct gb_message *request;
 	struct gb_gpio_irq_event_request *event;
+	u8 type = op->type;
 	int irq;
 	struct irq_desc *desc;
 
@@ -622,8 +624,10 @@ static int gb_gpio_to_irq(struct gpio_chip *chip, unsigned offset)
 	return irq_find_mapping(ggc->irqdomain, offset);
 }
 
-static int gb_gpio_connection_init(struct gb_connection *connection)
+static int gb_gpio_probe(struct gpbridge_device *gpbdev,
+			 const struct gpbridge_device_id *id)
 {
+	struct gb_connection *connection;
 	struct gb_gpio_controller *ggc;
 	struct gpio_chip *gpio;
 	struct irq_chip *irqc;
@@ -632,12 +636,31 @@ static int gb_gpio_connection_init(struct gb_connection *connection)
 	ggc = kzalloc(sizeof(*ggc), GFP_KERNEL);
 	if (!ggc)
 		return -ENOMEM;
+
+	connection = gb_connection_create(gpbdev->bundle,
+					  le16_to_cpu(gpbdev->cport_desc->id),
+					  gb_gpio_request_handler);
+	if (IS_ERR(connection)) {
+		ret = PTR_ERR(connection);
+		goto exit_ggc_free;
+	}
+
 	ggc->connection = connection;
 	gb_connection_set_data(connection, ggc);
+	ggc->gpbdev = gpbdev;
+	gb_gpbridge_set_data(gpbdev, ggc);
+
+	ret = gb_connection_enable_tx(connection);
+	if (ret)
+		goto exit_connection_destroy;
+
+	ret = gb_gpbridge_get_version(connection);
+	if (ret)
+		goto exit_connection_disable;
 
 	ret = gb_gpio_controller_setup(ggc);
 	if (ret)
-		goto err_free_controller;
+		goto exit_connection_disable;
 
 	irqc = &ggc->irqc;
 	irqc->irq_mask = gb_gpio_irq_mask;
@@ -653,9 +676,9 @@ static int gb_gpio_connection_init(struct gb_connection *connection)
 
 	gpio->label = "greybus_gpio";
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 5, 0)
-	gpio->parent = &connection->bundle->dev;
+	gpio->parent = &gpbdev->dev;
 #else
-	gpio->dev = &connection->bundle->dev;
+	gpio->dev = &gpbdev->dev;
 #endif
 	gpio->owner = THIS_MODULE;
 
@@ -672,11 +695,15 @@ static int gb_gpio_connection_init(struct gb_connection *connection)
 	gpio->ngpio = ggc->line_max + 1;
 	gpio->can_sleep = true;
 
+	ret = gb_connection_enable(connection);
+	if (ret)
+		goto exit_line_free;
+
 	ret = gpiochip_add(gpio);
 	if (ret) {
 		dev_err(&connection->bundle->dev,
 			"failed to add gpio chip: %d\n", ret);
-		goto err_free_lines;
+		goto exit_line_free;
 	}
 
 	ret = gb_gpio_irqchip_add(gpio, irqc, 0,
@@ -684,42 +711,47 @@ static int gb_gpio_connection_init(struct gb_connection *connection)
 	if (ret) {
 		dev_err(&connection->bundle->dev,
 			"failed to add irq chip: %d\n", ret);
-		goto irqchip_err;
+		goto exit_gpiochip_remove;
 	}
 
 	return 0;
 
-irqchip_err:
+exit_gpiochip_remove:
 	gb_gpiochip_remove(gpio);
-err_free_lines:
+exit_line_free:
 	kfree(ggc->lines);
-err_free_controller:
+exit_connection_disable:
+	gb_connection_disable(connection);
+exit_connection_destroy:
+	gb_connection_destroy(connection);
+exit_ggc_free:
 	kfree(ggc);
 	return ret;
 }
 
-static void gb_gpio_connection_exit(struct gb_connection *connection)
+static void gb_gpio_remove(struct gpbridge_device *gpbdev)
 {
-	struct gb_gpio_controller *ggc = gb_connection_get_data(connection);
-
-	if (!ggc)
-		return;
+	struct gb_gpio_controller *ggc = gb_gpbridge_get_data(gpbdev);
+	struct gb_connection *connection = ggc->connection;
 
+	gb_connection_disable_rx(connection);
 	gb_gpio_irqchip_remove(ggc);
 	gb_gpiochip_remove(&ggc->chip);
-	/* kref_put(ggc->connection) */
+	gb_connection_disable(connection);
+	gb_connection_destroy(connection);
 	kfree(ggc->lines);
 	kfree(ggc);
 }
 
-static struct gb_protocol gpio_protocol = {
-	.name			= "gpio",
-	.id			= GREYBUS_PROTOCOL_GPIO,
-	.major			= GB_GPIO_VERSION_MAJOR,
-	.minor			= GB_GPIO_VERSION_MINOR,
-	.connection_init	= gb_gpio_connection_init,
-	.connection_exit	= gb_gpio_connection_exit,
-	.request_recv		= gb_gpio_request_recv,
+static const struct gpbridge_device_id gb_gpio_id_table[] = {
+	{ GPBRIDGE_PROTOCOL(GREYBUS_PROTOCOL_GPIO) },
+	{ },
 };
 
-gb_builtin_protocol_driver(gpio_protocol);
+static struct gpbridge_driver gpio_driver = {
+	.name		= "gpio",
+	.probe		= gb_gpio_probe,
+	.remove		= gb_gpio_remove,
+	.id_table	= gb_gpio_id_table,
+};
+gb_gpbridge_builtin_driver(gpio_driver);

commit 0ec306324423444d3ee0222708ef9de7f5586b93
Author: Greg Kroah-Hartman <gregkh@google.com>
Date:   Tue Mar 22 14:30:35 2016 -0400

    greybus: convert drivers to use connection->private set/get
    
    This converts all drivers to use the gb_connection_get_data() and
    gb_connection_set_data() functions to make it a bit more explicit as to
    what is going on.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>
    Reviewed-by: Alex Elder <elder@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/gpio.c b/drivers/staging/greybus/gpio.c
index 7b2cb5d81e54..440ff44c8524 100644
--- a/drivers/staging/greybus/gpio.c
+++ b/drivers/staging/greybus/gpio.c
@@ -351,7 +351,7 @@ static int gb_gpio_request_recv(u8 type, struct gb_operation *op)
 {
 	struct gb_connection *connection = op->connection;
 	struct device *dev = &connection->bundle->dev;
-	struct gb_gpio_controller *ggc = connection->private;
+	struct gb_gpio_controller *ggc = gb_connection_get_data(connection);
 	struct gb_message *request;
 	struct gb_gpio_irq_event_request *event;
 	int irq;
@@ -633,7 +633,7 @@ static int gb_gpio_connection_init(struct gb_connection *connection)
 	if (!ggc)
 		return -ENOMEM;
 	ggc->connection = connection;
-	connection->private = ggc;
+	gb_connection_set_data(connection, ggc);
 
 	ret = gb_gpio_controller_setup(ggc);
 	if (ret)
@@ -700,7 +700,7 @@ static int gb_gpio_connection_init(struct gb_connection *connection)
 
 static void gb_gpio_connection_exit(struct gb_connection *connection)
 {
-	struct gb_gpio_controller *ggc = connection->private;
+	struct gb_gpio_controller *ggc = gb_connection_get_data(connection);
 
 	if (!ggc)
 		return;

commit c7b07265046b5db56778dc8c2cfc9056413ec5ba
Author: Greg Kroah-Hartman <gregkh@google.com>
Date:   Sun Feb 28 14:42:54 2016 -0800

    greybus: gpbridge.h: move protocol init/exit prototypes
    
    Create gpbridge.h for the gpbridge-specific function prototypes, the
    rest of the greybus drivers don't care about them.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>
    Reviewed-by: Viresh Kumar <viresh.kumar@linaro.org>
    Reviewed-by: Johan Hovold <johan@hovoldconsulting.com>

diff --git a/drivers/staging/greybus/gpio.c b/drivers/staging/greybus/gpio.c
index e7dd99444ea2..7b2cb5d81e54 100644
--- a/drivers/staging/greybus/gpio.c
+++ b/drivers/staging/greybus/gpio.c
@@ -16,6 +16,7 @@
 #include <linux/mutex.h>
 
 #include "greybus.h"
+#include "gpbridge.h"
 
 struct gb_gpio_line {
 	/* The following has to be an array of line_max entries */

commit bb80c76448b2463a1ecfe622df4f7b3c5fb39cdf
Author: Greg Kroah-Hartman <gregkh@google.com>
Date:   Tue Feb 23 22:51:45 2016 -0800

    greybus: gpio: handle api changes for 4.5 kernel release
    
    In kernel version 4.5, struct gpio_chip renamed the field 'dev' to
    'parent' so handle this properly.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>
    Reviewed-by: Johan Hovold <johan@hovoldconsulting.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/gpio.c b/drivers/staging/greybus/gpio.c
index ec375c0475d9..e7dd99444ea2 100644
--- a/drivers/staging/greybus/gpio.c
+++ b/drivers/staging/greybus/gpio.c
@@ -651,7 +651,11 @@ static int gb_gpio_connection_init(struct gb_connection *connection)
 	gpio = &ggc->chip;
 
 	gpio->label = "greybus_gpio";
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 5, 0)
+	gpio->parent = &connection->bundle->dev;
+#else
 	gpio->dev = &connection->bundle->dev;
+#endif
 	gpio->owner = THIS_MODULE;
 
 	gpio->request = gb_gpio_request;

commit 7a6396d9ce81564b09d91586b29fdd02e6814c28
Author: Greg Kroah-Hartman <gregkh@google.com>
Date:   Tue Feb 23 22:51:23 2016 -0800

    greybus: gpio: use bundle device for error messages
    
    Use the bundle device directly in gpio error messages instead of the
    gpio device, as they are the same pointer.  This will make future gpio
    api changes much easier to handle.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>
    Reviewed-by: Johan Hovold <johan@hovoldconsulting.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/gpio.c b/drivers/staging/greybus/gpio.c
index 5830dc9b87f3..ec375c0475d9 100644
--- a/drivers/staging/greybus/gpio.c
+++ b/drivers/staging/greybus/gpio.c
@@ -77,6 +77,7 @@ static int gb_gpio_activate_operation(struct gb_gpio_controller *ggc, u8 which)
 static void gb_gpio_deactivate_operation(struct gb_gpio_controller *ggc,
 					u8 which)
 {
+	struct device *dev = &ggc->connection->bundle->dev;
 	struct gb_gpio_deactivate_request request;
 	int ret;
 
@@ -84,8 +85,7 @@ static void gb_gpio_deactivate_operation(struct gb_gpio_controller *ggc,
 	ret = gb_operation_sync(ggc->connection, GB_GPIO_TYPE_DEACTIVATE,
 				 &request, sizeof(request), NULL, 0);
 	if (ret) {
-		dev_err(ggc->chip.dev, "failed to deactivate gpio %u\n",
-			which);
+		dev_err(dev, "failed to deactivate gpio %u\n", which);
 		return;
 	}
 
@@ -95,6 +95,7 @@ static void gb_gpio_deactivate_operation(struct gb_gpio_controller *ggc,
 static int gb_gpio_get_direction_operation(struct gb_gpio_controller *ggc,
 					u8 which)
 {
+	struct device *dev = &ggc->connection->bundle->dev;
 	struct gb_gpio_get_direction_request request;
 	struct gb_gpio_get_direction_response response;
 	int ret;
@@ -109,8 +110,7 @@ static int gb_gpio_get_direction_operation(struct gb_gpio_controller *ggc,
 
 	direction = response.direction;
 	if (direction && direction != 1) {
-		dev_warn(ggc->chip.dev,
-			 "gpio %u direction was %u (should be 0 or 1)\n",
+		dev_warn(dev, "gpio %u direction was %u (should be 0 or 1)\n",
 			 which, direction);
 	}
 	ggc->lines[which].direction = direction ? 1 : 0;
@@ -149,6 +149,7 @@ static int gb_gpio_direction_out_operation(struct gb_gpio_controller *ggc,
 static int gb_gpio_get_value_operation(struct gb_gpio_controller *ggc,
 					u8 which)
 {
+	struct device *dev = &ggc->connection->bundle->dev;
 	struct gb_gpio_get_value_request request;
 	struct gb_gpio_get_value_response response;
 	int ret;
@@ -159,15 +160,13 @@ static int gb_gpio_get_value_operation(struct gb_gpio_controller *ggc,
 				&request, sizeof(request),
 				&response, sizeof(response));
 	if (ret) {
-		dev_err(ggc->chip.dev, "failed to get value of gpio %u\n",
-			which);
+		dev_err(dev, "failed to get value of gpio %u\n", which);
 		return ret;
 	}
 
 	value = response.value;
 	if (value && value != 1) {
-		dev_warn(ggc->chip.dev,
-			 "gpio %u value was %u (should be 0 or 1)\n",
+		dev_warn(dev, "gpio %u value was %u (should be 0 or 1)\n",
 			 which, value);
 	}
 	ggc->lines[which].value = value ? 1 : 0;
@@ -177,12 +176,13 @@ static int gb_gpio_get_value_operation(struct gb_gpio_controller *ggc,
 static void gb_gpio_set_value_operation(struct gb_gpio_controller *ggc,
 					u8 which, bool value_high)
 {
+	struct device *dev = &ggc->connection->bundle->dev;
 	struct gb_gpio_set_value_request request;
 	int ret;
 
 	if (ggc->lines[which].direction == 1) {
-		dev_warn(ggc->chip.dev,
-			 "refusing to set value of input gpio %u\n", which);
+		dev_warn(dev, "refusing to set value of input gpio %u\n",
+			 which);
 		return;
 	}
 
@@ -191,8 +191,7 @@ static void gb_gpio_set_value_operation(struct gb_gpio_controller *ggc,
 	ret = gb_operation_sync(ggc->connection, GB_GPIO_TYPE_SET_VALUE,
 				&request, sizeof(request), NULL, 0);
 	if (ret) {
-		dev_err(ggc->chip.dev, "failed to set value of gpio %u\n",
-			which);
+		dev_err(dev, "failed to set value of gpio %u\n", which);
 		return;
 	}
 
@@ -216,6 +215,7 @@ static int gb_gpio_set_debounce_operation(struct gb_gpio_controller *ggc,
 
 static void _gb_gpio_irq_mask(struct gb_gpio_controller *ggc, u8 hwirq)
 {
+	struct device *dev = &ggc->connection->bundle->dev;
 	struct gb_gpio_irq_mask_request request;
 	int ret;
 
@@ -224,11 +224,12 @@ static void _gb_gpio_irq_mask(struct gb_gpio_controller *ggc, u8 hwirq)
 				GB_GPIO_TYPE_IRQ_MASK,
 				&request, sizeof(request), NULL, 0);
 	if (ret)
-		dev_err(ggc->chip.dev, "failed to mask irq: %d\n", ret);
+		dev_err(dev, "failed to mask irq: %d\n", ret);
 }
 
 static void _gb_gpio_irq_unmask(struct gb_gpio_controller *ggc, u8 hwirq)
 {
+	struct device *dev = &ggc->connection->bundle->dev;
 	struct gb_gpio_irq_unmask_request request;
 	int ret;
 
@@ -237,12 +238,13 @@ static void _gb_gpio_irq_unmask(struct gb_gpio_controller *ggc, u8 hwirq)
 				GB_GPIO_TYPE_IRQ_UNMASK,
 				&request, sizeof(request), NULL, 0);
 	if (ret)
-		dev_err(ggc->chip.dev, "failed to unmask irq: %d\n", ret);
+		dev_err(dev, "failed to unmask irq: %d\n", ret);
 }
 
 static void _gb_gpio_irq_set_type(struct gb_gpio_controller *ggc,
 					u8 hwirq, u8 type)
 {
+	struct device *dev = &ggc->connection->bundle->dev;
 	struct gb_gpio_irq_type_request request;
 	int ret;
 
@@ -253,7 +255,7 @@ static void _gb_gpio_irq_set_type(struct gb_gpio_controller *ggc,
 				GB_GPIO_TYPE_IRQ_TYPE,
 				&request, sizeof(request), NULL, 0);
 	if (ret)
-		dev_err(ggc->chip.dev, "failed to set irq type: %d\n", ret);
+		dev_err(dev, "failed to set irq type: %d\n", ret);
 }
 
 static void gb_gpio_irq_mask(struct irq_data *d)
@@ -281,6 +283,7 @@ static int gb_gpio_irq_set_type(struct irq_data *d, unsigned int type)
 	struct gpio_chip *chip = irq_data_to_gpio_chip(d);
 	struct gb_gpio_controller *ggc = gpio_chip_to_gb_gpio_controller(chip);
 	struct gb_gpio_line *line = &ggc->lines[d->hwirq];
+	struct device *dev = &ggc->connection->bundle->dev;
 	u8 irq_type;
 
 	switch (type) {
@@ -303,7 +306,7 @@ static int gb_gpio_irq_set_type(struct irq_data *d, unsigned int type)
 		irq_type = GB_GPIO_IRQ_TYPE_LEVEL_HIGH;
 		break;
 	default:
-		dev_err(chip->dev, "unsupported irq type: %u\n", type);
+		dev_err(dev, "unsupported irq type: %u\n", type);
 		return -EINVAL;
 	}
 
@@ -346,6 +349,7 @@ static void gb_gpio_irq_bus_sync_unlock(struct irq_data *d)
 static int gb_gpio_request_recv(u8 type, struct gb_operation *op)
 {
 	struct gb_connection *connection = op->connection;
+	struct device *dev = &connection->bundle->dev;
 	struct gb_gpio_controller *ggc = connection->private;
 	struct gb_message *request;
 	struct gb_gpio_irq_event_request *event;
@@ -353,33 +357,32 @@ static int gb_gpio_request_recv(u8 type, struct gb_operation *op)
 	struct irq_desc *desc;
 
 	if (type != GB_GPIO_TYPE_IRQ_EVENT) {
-		dev_err(&connection->bundle->dev,
-			"unsupported unsolicited request: %u\n", type);
+		dev_err(dev, "unsupported unsolicited request: %u\n", type);
 		return -EINVAL;
 	}
 
 	request = op->request;
 
 	if (request->payload_size < sizeof(*event)) {
-		dev_err(ggc->chip.dev, "short event received (%zu < %zu)\n",
+		dev_err(dev, "short event received (%zu < %zu)\n",
 			request->payload_size, sizeof(*event));
 		return -EINVAL;
 	}
 
 	event = request->payload;
 	if (event->which > ggc->line_max) {
-		dev_err(ggc->chip.dev, "invalid hw irq: %d\n", event->which);
+		dev_err(dev, "invalid hw irq: %d\n", event->which);
 		return -EINVAL;
 	}
 
 	irq = irq_find_mapping(ggc->irqdomain, event->which);
 	if (!irq) {
-		dev_err(ggc->chip.dev, "failed to find IRQ\n");
+		dev_err(dev, "failed to find IRQ\n");
 		return -EINVAL;
 	}
 	desc = irq_to_desc(irq);
 	if (!desc) {
-		dev_err(ggc->chip.dev, "failed to look up irq\n");
+		dev_err(dev, "failed to look up irq\n");
 		return -EINVAL;
 	}
 

commit c7eb46e459f2a05fa52656ae9d767aa498482ecf
Author: Greg Kroah-Hartman <gregkh@google.com>
Date:   Wed Oct 14 11:17:55 2015 -0700

    greybus: gpio: use the bundle struct device instead of the connector
    
    We are removing struct device from the gb_connection structure in the
    near future.  The gb_bundle structure's struct device should be used as
    a replacement.
    
    This patch moves the gpio driver to use the bundle pointer instead of
    the connection pointer.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>
    Reviewed-by: Alex Elder <elder@linaro.org>

diff --git a/drivers/staging/greybus/gpio.c b/drivers/staging/greybus/gpio.c
index 5ac859e1c290..5830dc9b87f3 100644
--- a/drivers/staging/greybus/gpio.c
+++ b/drivers/staging/greybus/gpio.c
@@ -353,7 +353,7 @@ static int gb_gpio_request_recv(u8 type, struct gb_operation *op)
 	struct irq_desc *desc;
 
 	if (type != GB_GPIO_TYPE_IRQ_EVENT) {
-		dev_err(&connection->dev,
+		dev_err(&connection->bundle->dev,
 			"unsupported unsolicited request: %u\n", type);
 		return -EINVAL;
 	}
@@ -648,7 +648,7 @@ static int gb_gpio_connection_init(struct gb_connection *connection)
 	gpio = &ggc->chip;
 
 	gpio->label = "greybus_gpio";
-	gpio->dev = &connection->dev;
+	gpio->dev = &connection->bundle->dev;
 	gpio->owner = THIS_MODULE;
 
 	gpio->request = gb_gpio_request;
@@ -666,15 +666,16 @@ static int gb_gpio_connection_init(struct gb_connection *connection)
 
 	ret = gpiochip_add(gpio);
 	if (ret) {
-		dev_err(&connection->dev, "failed to add gpio chip: %d\n",
-			ret);
+		dev_err(&connection->bundle->dev,
+			"failed to add gpio chip: %d\n", ret);
 		goto err_free_lines;
 	}
 
 	ret = gb_gpio_irqchip_add(gpio, irqc, 0,
 				   handle_level_irq, IRQ_TYPE_NONE);
 	if (ret) {
-		dev_err(&connection->dev, "failed to add irq chip: %d\n", ret);
+		dev_err(&connection->bundle->dev,
+			"failed to add irq chip: %d\n", ret);
 		goto irqchip_err;
 	}
 

commit 0010245e2c6e431f24c1d80521866f963e148c03
Author: Johan Hovold <johan@hovoldconsulting.com>
Date:   Tue Oct 13 11:27:58 2015 +0200

    greybus: gpio: handle set_irq_flags api change
    
    The ARM-specific set_irq_flags helper has been removed in 4.3. Instead
    of doing conditional compilation on the kernel version to avoid build
    breakages, simply use the genirq interface directly.
    
    Suggested-by: Rob Herring <rob.herring@linaro.org>
    Signed-off-by: Johan Hovold <johan@hovoldconsulting.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/gpio.c b/drivers/staging/greybus/gpio.c
index 6c653ad2f578..5ac859e1c290 100644
--- a/drivers/staging/greybus/gpio.c
+++ b/drivers/staging/greybus/gpio.c
@@ -506,11 +506,7 @@ static int gb_gpio_irq_map(struct irq_domain *domain, unsigned int irq,
 
 	irq_set_chip_data(irq, ggc);
 	irq_set_chip_and_handler(irq, ggc->irqchip, ggc->irq_handler);
-#ifdef CONFIG_ARM
-	set_irq_flags(irq, IRQF_VALID);
-#else
 	irq_set_noprobe(irq);
-#endif
 	/*
 	 * No set-up of the hardware will happen if IRQ_TYPE_NONE
 	 * is passed as default type.
@@ -523,9 +519,6 @@ static int gb_gpio_irq_map(struct irq_domain *domain, unsigned int irq,
 
 static void gb_gpio_irq_unmap(struct irq_domain *d, unsigned int irq)
 {
-#ifdef CONFIG_ARM
-	set_irq_flags(irq, 0);
-#endif
 	irq_set_chip_and_handler(irq, NULL, NULL);
 	irq_set_chip_data(irq, NULL);
 }

commit 3c9426ad27840e2d1175e3b090cba98f539c10c6
Author: Rui Miguel Silva <rui.silva@linaro.org>
Date:   Wed Sep 30 11:11:57 2015 +0100

    greybus: gpio: fix generic_handle_irq_desc api change
    
    The generic_handle_irq_desc api only have changed in 4.3.0, so check
    against the correct version, if not will break builds for 4.2.x.
    
    Fixes: e7895cfc476 ("gpio: handle api change in generic_handle_irq_desc()")
    Signed-off-by: Rui Miguel Silva <rui.silva@linaro.org>
    Reviewed-by: Johan Hovold <johan@hovoldconsulting.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/gpio.c b/drivers/staging/greybus/gpio.c
index c41812ad7415..6c653ad2f578 100644
--- a/drivers/staging/greybus/gpio.c
+++ b/drivers/staging/greybus/gpio.c
@@ -384,7 +384,7 @@ static int gb_gpio_request_recv(u8 type, struct gb_operation *op)
 	}
 
 	local_irq_disable();
-#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 2, 0)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 3, 0)
 	generic_handle_irq_desc(irq, desc);
 #else
 	generic_handle_irq_desc(desc);

commit 4ee144170a74c990eea2ccec46ab438bc233d2d8
Author: Greg Kroah-Hartman <gregkh@google.com>
Date:   Tue Sep 29 20:39:17 2015 +0200

    greybus: gpio: handle api change in generic_handle_irq_desc()
    
    generic_handle_irq_desc changed the api in the 4.2 kernel, so fix up the
    gpio driver to handle this properly to keep it working.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/gpio.c b/drivers/staging/greybus/gpio.c
index 6a04a1be573a..c41812ad7415 100644
--- a/drivers/staging/greybus/gpio.c
+++ b/drivers/staging/greybus/gpio.c
@@ -384,7 +384,11 @@ static int gb_gpio_request_recv(u8 type, struct gb_operation *op)
 	}
 
 	local_irq_disable();
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 2, 0)
 	generic_handle_irq_desc(irq, desc);
+#else
+	generic_handle_irq_desc(desc);
+#endif
 	local_irq_enable();
 
 	return 0;

commit 03490fdbe745a6af23527df32e6ceab4b5749a8f
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Tue Aug 11 07:36:03 2015 +0530

    greybus: gpio: Drop get_version support
    
    This is done from a common place now, no need to replicate it.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/gpio.c b/drivers/staging/greybus/gpio.c
index a5db014eaaf2..6a04a1be573a 100644
--- a/drivers/staging/greybus/gpio.c
+++ b/drivers/staging/greybus/gpio.c
@@ -33,8 +33,6 @@ struct gb_gpio_line {
 
 struct gb_gpio_controller {
 	struct gb_connection	*connection;
-	u8			version_major;
-	u8			version_minor;
 	u8			line_max;	/* max line number */
 	struct gb_gpio_line	*lines;
 
@@ -51,9 +49,6 @@ struct gb_gpio_controller {
 	container_of(chip, struct gb_gpio_controller, chip)
 #define irq_data_to_gpio_chip(d) (d->domain->host_data)
 
-/* Define get_version() routine */
-define_get_version(gb_gpio_controller, GPIO);
-
 static int gb_gpio_line_count_operation(struct gb_gpio_controller *ggc)
 {
 	struct gb_gpio_line_count_response response;
@@ -476,11 +471,6 @@ static int gb_gpio_controller_setup(struct gb_gpio_controller *ggc)
 {
 	int ret;
 
-	/* First thing we need to do is check the version */
-	ret = get_version(ggc);
-	if (ret)
-		return ret;
-
 	/* Now find out how many lines there are */
 	ret = gb_gpio_line_count_operation(ggc);
 	if (ret)

commit 8590ed30be0d3164073d90d1bcf728dd776487c4
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Sat Aug 8 10:25:34 2015 +0530

    greybus: gpio: Use (already defined) major/minor macros
    
    We already have macros for these, use them instead of writing fixed
    values.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/gpio.c b/drivers/staging/greybus/gpio.c
index caee9d19d723..a5db014eaaf2 100644
--- a/drivers/staging/greybus/gpio.c
+++ b/drivers/staging/greybus/gpio.c
@@ -719,8 +719,8 @@ static void gb_gpio_connection_exit(struct gb_connection *connection)
 static struct gb_protocol gpio_protocol = {
 	.name			= "gpio",
 	.id			= GREYBUS_PROTOCOL_GPIO,
-	.major			= 0,
-	.minor			= 1,
+	.major			= GB_GPIO_VERSION_MAJOR,
+	.minor			= GB_GPIO_VERSION_MINOR,
 	.connection_init	= gb_gpio_connection_init,
 	.connection_exit	= gb_gpio_connection_exit,
 	.request_recv		= gb_gpio_request_recv,

commit 782c3b732889b5fbce796a4b548d47a43e4d8c42
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Thu Aug 6 12:44:51 2015 +0530

    greybus: gpio: Print expected/actual payload size on mismatch
    
    Print (expected-payload-size actual-payload-size), when the size doesn't
    match for requests received by the module. This gives more details
    required for debugging the issue.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Reviewed-by: Alex Elder <elder@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/gpio.c b/drivers/staging/greybus/gpio.c
index 6539530a178c..caee9d19d723 100644
--- a/drivers/staging/greybus/gpio.c
+++ b/drivers/staging/greybus/gpio.c
@@ -366,7 +366,8 @@ static int gb_gpio_request_recv(u8 type, struct gb_operation *op)
 	request = op->request;
 
 	if (request->payload_size < sizeof(*event)) {
-		dev_err(ggc->chip.dev, "short event received\n");
+		dev_err(ggc->chip.dev, "short event received (%zu < %zu)\n",
+			request->payload_size, sizeof(*event));
 		return -EINVAL;
 	}
 

commit e18822e3d02c8f296fe42e0e8bda7e2e626a4714
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Wed Jul 1 12:13:52 2015 +0530

    greybus: Rename gb_gpbridge_protocol_driver() as gb_builtin_protocol_driver()
    
    This macro is also required by core protocols like control and svc, and
    hence the 'gpbridge' name doesn't fit anymore.
    
    Lets call this macro gb_builtin_protocol_driver().
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Reviewed-by: Alex Elder <elder@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/gpio.c b/drivers/staging/greybus/gpio.c
index 95909149eba2..6539530a178c 100644
--- a/drivers/staging/greybus/gpio.c
+++ b/drivers/staging/greybus/gpio.c
@@ -725,4 +725,4 @@ static struct gb_protocol gpio_protocol = {
 	.request_recv		= gb_gpio_request_recv,
 };
 
-gb_gpbridge_protocol_driver(gpio_protocol);
+gb_builtin_protocol_driver(gpio_protocol);

commit 7ba864a19f97f06b0a685b083449b7278b635823
Author: Johan Hovold <johan@hovoldconsulting.com>
Date:   Thu May 28 19:03:34 2015 +0200

    greybus: gpio: add irq-type defines
    
    Add Greybus GPIO IRQ-type defines rather than rely on the current
    Linux implementation.
    
    Signed-off-by: Johan Hovold <johan@hovoldconsulting.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/gpio.c b/drivers/staging/greybus/gpio.c
index 8dad9e579881..95909149eba2 100644
--- a/drivers/staging/greybus/gpio.c
+++ b/drivers/staging/greybus/gpio.c
@@ -286,21 +286,33 @@ static int gb_gpio_irq_set_type(struct irq_data *d, unsigned int type)
 	struct gpio_chip *chip = irq_data_to_gpio_chip(d);
 	struct gb_gpio_controller *ggc = gpio_chip_to_gb_gpio_controller(chip);
 	struct gb_gpio_line *line = &ggc->lines[d->hwirq];
+	u8 irq_type;
 
 	switch (type) {
 	case IRQ_TYPE_NONE:
+		irq_type = GB_GPIO_IRQ_TYPE_NONE;
+		break;
 	case IRQ_TYPE_EDGE_RISING:
+		irq_type = GB_GPIO_IRQ_TYPE_EDGE_RISING;
+		break;
 	case IRQ_TYPE_EDGE_FALLING:
+		irq_type = GB_GPIO_IRQ_TYPE_EDGE_FALLING;
+		break;
 	case IRQ_TYPE_EDGE_BOTH:
+		irq_type = GB_GPIO_IRQ_TYPE_EDGE_BOTH;
+		break;
 	case IRQ_TYPE_LEVEL_LOW:
+		irq_type = GB_GPIO_IRQ_TYPE_LEVEL_LOW;
+		break;
 	case IRQ_TYPE_LEVEL_HIGH:
+		irq_type = GB_GPIO_IRQ_TYPE_LEVEL_HIGH;
 		break;
 	default:
 		dev_err(chip->dev, "unsupported irq type: %u\n", type);
 		return -EINVAL;
 	}
 
-	line->irq_type = type;
+	line->irq_type = irq_type;
 	line->irq_type_pending = true;
 
 	return 0;

commit 1409c4d6a841b00f3b4bdf010808a81eda6b7727
Author: Johan Hovold <johan@hovoldconsulting.com>
Date:   Tue May 26 15:29:25 2015 +0200

    greybus: gpio: fix interrupt protocol
    
    The current interrupt implementation uses the simple irq-flow handler,
    which means that the interrupt subsystem makes no irq-chip callbacks
    when handling an interrupt. Specifically, no end-of-interrupt message is
    sent when the threaded handler has run. This means that we may currently
    re-enable an interrupt before it has been serviced (i.e. the irq-event
    operation may complete before the threaded handler has run).
    
    The simple flow handler also silently drops a second interrupt arriving
    while a handler is running. This means that we may lose a second edge
    interrupt with the current firmware.
    
    Switch to a new one-shot interrupt protocol, where the primary handler
    (firmware) always masks and acks an interrupt before sending an event to
    the AP. The AP is responsible for unmasking the interrupt when it has
    been handled. By having the firmware ack an edge interrupt before
    sending the event, a second edge interrupt will no longer get lost.
    
    This one-shot protocol can be implemented in the kernel by using the
    level irq-flow handler, one-shot interrupts with threaded handlers and
    bus-lock synchronisation for slow buses. Note that the same flow handler
    is used for both edge and level interrupts.
    
    Signed-off-by: Johan Hovold <johan@hovoldconsulting.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/gpio.c b/drivers/staging/greybus/gpio.c
index 6cf3bb151f61..8dad9e579881 100644
--- a/drivers/staging/greybus/gpio.c
+++ b/drivers/staging/greybus/gpio.c
@@ -672,7 +672,7 @@ static int gb_gpio_connection_init(struct gb_connection *connection)
 	}
 
 	ret = gb_gpio_irqchip_add(gpio, irqc, 0,
-				   handle_simple_irq, IRQ_TYPE_NONE);
+				   handle_level_irq, IRQ_TYPE_NONE);
 	if (ret) {
 		dev_err(&connection->dev, "failed to add irq chip: %d\n", ret);
 		goto irqchip_err;

commit 25f11ed965bb57b6e25d5464a8cd8b3657319056
Author: Johan Hovold <johan@hovoldconsulting.com>
Date:   Tue May 26 15:29:24 2015 +0200

    greybus: gpio: fix atomic sleep when using interrupts
    
    The irq-chip callbacks are made in atomic context where we must not do
    any synchronous greybus operations.
    
    Fix the current gpio-interrupt implementation by using the bus-lock
    functionality provided by the irq subsystem.
    
    Signed-off-by: Johan Hovold <johan@hovoldconsulting.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/gpio.c b/drivers/staging/greybus/gpio.c
index 0220a9f1ff9c..6cf3bb151f61 100644
--- a/drivers/staging/greybus/gpio.c
+++ b/drivers/staging/greybus/gpio.c
@@ -13,6 +13,8 @@
 #include <linux/gpio.h>
 #include <linux/irq.h>
 #include <linux/irqdomain.h>
+#include <linux/mutex.h>
+
 #include "greybus.h"
 
 struct gb_gpio_line {
@@ -22,6 +24,11 @@ struct gb_gpio_line {
 				direction: 1,	/* 0 = output, 1 = input */
 				value:     1;	/* 0 = low, 1 = high */
 	u16			debounce_usec;
+
+	u8			irq_type;
+	bool			irq_type_pending;
+	bool			masked;
+	bool			masked_pending;
 };
 
 struct gb_gpio_controller {
@@ -38,6 +45,7 @@ struct gb_gpio_controller {
 	unsigned int		irq_base;
 	irq_flow_handler_t	irq_handler;
 	unsigned int		irq_default_type;
+	struct mutex		irq_lock;
 };
 #define gpio_chip_to_gb_gpio_controller(chip) \
 	container_of(chip, struct gb_gpio_controller, chip)
@@ -211,68 +219,121 @@ static int gb_gpio_set_debounce_operation(struct gb_gpio_controller *ggc,
 	return ret;
 }
 
-static void gb_gpio_irq_mask(struct irq_data *d)
+static void _gb_gpio_irq_mask(struct gb_gpio_controller *ggc, u8 hwirq)
 {
-	struct gpio_chip *chip = irq_data_to_gpio_chip(d);
-	struct gb_gpio_controller *ggc = gpio_chip_to_gb_gpio_controller(chip);
 	struct gb_gpio_irq_mask_request request;
 	int ret;
 
-	request.which = d->hwirq;
+	request.which = hwirq;
 	ret = gb_operation_sync(ggc->connection,
 				GB_GPIO_TYPE_IRQ_MASK,
 				&request, sizeof(request), NULL, 0);
 	if (ret)
-		dev_err(chip->dev, "failed to mask irq: %d\n", ret);
+		dev_err(ggc->chip.dev, "failed to mask irq: %d\n", ret);
 }
 
-static void gb_gpio_irq_unmask(struct irq_data *d)
+static void _gb_gpio_irq_unmask(struct gb_gpio_controller *ggc, u8 hwirq)
 {
-	struct gpio_chip *chip = irq_data_to_gpio_chip(d);
-	struct gb_gpio_controller *ggc = gpio_chip_to_gb_gpio_controller(chip);
 	struct gb_gpio_irq_unmask_request request;
 	int ret;
 
-	request.which = d->hwirq;
+	request.which = hwirq;
 	ret = gb_operation_sync(ggc->connection,
 				GB_GPIO_TYPE_IRQ_UNMASK,
 				&request, sizeof(request), NULL, 0);
 	if (ret)
-		dev_err(chip->dev, "failed to unmask irq: %d\n", ret);
+		dev_err(ggc->chip.dev, "failed to unmask irq: %d\n", ret);
 }
 
-static int gb_gpio_irq_set_type(struct irq_data *d, unsigned int type)
+static void _gb_gpio_irq_set_type(struct gb_gpio_controller *ggc,
+					u8 hwirq, u8 type)
 {
-	struct gpio_chip *chip = irq_data_to_gpio_chip(d);
-	struct gb_gpio_controller *ggc = gpio_chip_to_gb_gpio_controller(chip);
 	struct gb_gpio_irq_type_request request;
-	int ret = 0;
+	int ret;
 
-	request.which = d->hwirq;
+	request.which = hwirq;
 	request.type = type;
 
+	ret = gb_operation_sync(ggc->connection,
+				GB_GPIO_TYPE_IRQ_TYPE,
+				&request, sizeof(request), NULL, 0);
+	if (ret)
+		dev_err(ggc->chip.dev, "failed to set irq type: %d\n", ret);
+}
+
+static void gb_gpio_irq_mask(struct irq_data *d)
+{
+	struct gpio_chip *chip = irq_data_to_gpio_chip(d);
+	struct gb_gpio_controller *ggc = gpio_chip_to_gb_gpio_controller(chip);
+	struct gb_gpio_line *line = &ggc->lines[d->hwirq];
+
+	line->masked = true;
+	line->masked_pending = true;
+}
+
+static void gb_gpio_irq_unmask(struct irq_data *d)
+{
+	struct gpio_chip *chip = irq_data_to_gpio_chip(d);
+	struct gb_gpio_controller *ggc = gpio_chip_to_gb_gpio_controller(chip);
+	struct gb_gpio_line *line = &ggc->lines[d->hwirq];
+
+	line->masked = false;
+	line->masked_pending = true;
+}
+
+static int gb_gpio_irq_set_type(struct irq_data *d, unsigned int type)
+{
+	struct gpio_chip *chip = irq_data_to_gpio_chip(d);
+	struct gb_gpio_controller *ggc = gpio_chip_to_gb_gpio_controller(chip);
+	struct gb_gpio_line *line = &ggc->lines[d->hwirq];
+
 	switch (type) {
 	case IRQ_TYPE_NONE:
-		break;
 	case IRQ_TYPE_EDGE_RISING:
 	case IRQ_TYPE_EDGE_FALLING:
 	case IRQ_TYPE_EDGE_BOTH:
 	case IRQ_TYPE_LEVEL_LOW:
 	case IRQ_TYPE_LEVEL_HIGH:
-		ret = gb_operation_sync(ggc->connection,
-					GB_GPIO_TYPE_IRQ_TYPE,
-					&request, sizeof(request), NULL, 0);
-		if (ret) {
-			dev_err(chip->dev, "failed to set irq type: %d\n",
-				ret);
-		}
 		break;
 	default:
 		dev_err(chip->dev, "unsupported irq type: %u\n", type);
-		ret = -EINVAL;
+		return -EINVAL;
 	}
 
-	return ret;
+	line->irq_type = type;
+	line->irq_type_pending = true;
+
+	return 0;
+}
+
+static void gb_gpio_irq_bus_lock(struct irq_data *d)
+{
+	struct gpio_chip *chip = irq_data_to_gpio_chip(d);
+	struct gb_gpio_controller *ggc = gpio_chip_to_gb_gpio_controller(chip);
+
+	mutex_lock(&ggc->irq_lock);
+}
+
+static void gb_gpio_irq_bus_sync_unlock(struct irq_data *d)
+{
+	struct gpio_chip *chip = irq_data_to_gpio_chip(d);
+	struct gb_gpio_controller *ggc = gpio_chip_to_gb_gpio_controller(chip);
+	struct gb_gpio_line *line = &ggc->lines[d->hwirq];
+
+	if (line->irq_type_pending) {
+		_gb_gpio_irq_set_type(ggc, d->hwirq, line->irq_type);
+		line->irq_type_pending = false;
+	}
+
+	if (line->masked_pending) {
+		if (line->masked)
+			_gb_gpio_irq_mask(ggc, d->hwirq);
+		else
+			_gb_gpio_irq_unmask(ggc, d->hwirq);
+		line->masked_pending = false;
+	}
+
+	mutex_unlock(&ggc->irq_lock);
 }
 
 static int gb_gpio_request_recv(u8 type, struct gb_operation *op)
@@ -578,8 +639,12 @@ static int gb_gpio_connection_init(struct gb_connection *connection)
 	irqc->irq_mask = gb_gpio_irq_mask;
 	irqc->irq_unmask = gb_gpio_irq_unmask;
 	irqc->irq_set_type = gb_gpio_irq_set_type;
+	irqc->irq_bus_lock = gb_gpio_irq_bus_lock;
+	irqc->irq_bus_sync_unlock = gb_gpio_irq_bus_sync_unlock;
 	irqc->name = "greybus_gpio";
 
+	mutex_init(&ggc->irq_lock);
+
 	gpio = &ggc->chip;
 
 	gpio->label = "greybus_gpio";

commit 0cb918d72d8f76b1189a63cefedbc5cb4dad9d54
Author: Johan Hovold <johan@hovoldconsulting.com>
Date:   Tue May 26 15:29:23 2015 +0200

    greybus: gpio: rename irq mask and unmask callbacks
    
    Rename irq mask and unmask functions to match the callback names.
    
    Signed-off-by: Johan Hovold <johan@hovoldconsulting.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/gpio.c b/drivers/staging/greybus/gpio.c
index 15cc0ea4e3a5..0220a9f1ff9c 100644
--- a/drivers/staging/greybus/gpio.c
+++ b/drivers/staging/greybus/gpio.c
@@ -211,7 +211,7 @@ static int gb_gpio_set_debounce_operation(struct gb_gpio_controller *ggc,
 	return ret;
 }
 
-static void gb_gpio_mask_irq(struct irq_data *d)
+static void gb_gpio_irq_mask(struct irq_data *d)
 {
 	struct gpio_chip *chip = irq_data_to_gpio_chip(d);
 	struct gb_gpio_controller *ggc = gpio_chip_to_gb_gpio_controller(chip);
@@ -226,7 +226,7 @@ static void gb_gpio_mask_irq(struct irq_data *d)
 		dev_err(chip->dev, "failed to mask irq: %d\n", ret);
 }
 
-static void gb_gpio_unmask_irq(struct irq_data *d)
+static void gb_gpio_irq_unmask(struct irq_data *d)
 {
 	struct gpio_chip *chip = irq_data_to_gpio_chip(d);
 	struct gb_gpio_controller *ggc = gpio_chip_to_gb_gpio_controller(chip);
@@ -575,8 +575,8 @@ static int gb_gpio_connection_init(struct gb_connection *connection)
 		goto err_free_controller;
 
 	irqc = &ggc->irqc;
-	irqc->irq_mask = gb_gpio_mask_irq;
-	irqc->irq_unmask = gb_gpio_unmask_irq;
+	irqc->irq_mask = gb_gpio_irq_mask;
+	irqc->irq_unmask = gb_gpio_irq_unmask;
 	irqc->irq_set_type = gb_gpio_irq_set_type;
 	irqc->name = "greybus_gpio";
 

commit ec762115a5006db8549b3582f7f19849f7cf4ab4
Author: Johan Hovold <johan@hovoldconsulting.com>
Date:   Tue May 26 15:29:22 2015 +0200

    greybus: gpio: use irq-domain lookups
    
    Use irq_find_mapping directly rather than go through the legacy gpio
    interface.
    
    Signed-off-by: Johan Hovold <johan@hovoldconsulting.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/gpio.c b/drivers/staging/greybus/gpio.c
index 526dd7e73a2f..15cc0ea4e3a5 100644
--- a/drivers/staging/greybus/gpio.c
+++ b/drivers/staging/greybus/gpio.c
@@ -303,9 +303,9 @@ static int gb_gpio_request_recv(u8 type, struct gb_operation *op)
 		return -EINVAL;
 	}
 
-	irq = gpio_to_irq(ggc->chip.base + event->which);
-	if (irq < 0) {
-		dev_err(ggc->chip.dev, "failed to map irq\n");
+	irq = irq_find_mapping(ggc->irqdomain, event->which);
+	if (!irq) {
+		dev_err(ggc->chip.dev, "failed to find IRQ\n");
 		return -EINVAL;
 	}
 	desc = irq_to_desc(irq);

commit 2611ebef8322fc12dc3c6b0ec869f1902aa25626
Author: Johan Hovold <johan@hovoldconsulting.com>
Date:   Tue May 26 15:29:21 2015 +0200

    greybus: gpio: don't call irq-flow handler directly
    
    Use generic_handle_irq_desc rather than call a hardcoded irq-flow
    handler directly.
    
    Signed-off-by: Johan Hovold <johan@hovoldconsulting.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/gpio.c b/drivers/staging/greybus/gpio.c
index c570f62046f5..526dd7e73a2f 100644
--- a/drivers/staging/greybus/gpio.c
+++ b/drivers/staging/greybus/gpio.c
@@ -314,9 +314,8 @@ static int gb_gpio_request_recv(u8 type, struct gb_operation *op)
 		return -EINVAL;
 	}
 
-	/* Dispatch interrupt */
 	local_irq_disable();
-	handle_simple_irq(irq, desc);
+	generic_handle_irq_desc(irq, desc);
 	local_irq_enable();
 
 	return 0;

commit b8e3ffebac09b29ad4cc0bdbcafbbd77b3278685
Author: Johan Hovold <johan@hovoldconsulting.com>
Date:   Tue May 26 15:29:20 2015 +0200

    greybus: gpio: remove unused irq-ack operation
    
    Remove unused irq-ack operation, which has never been called and does
    not make sense for message-signalled interrupts over slow buses.
    
    Signed-off-by: Johan Hovold <johan@hovoldconsulting.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/gpio.c b/drivers/staging/greybus/gpio.c
index 0191bb809968..c570f62046f5 100644
--- a/drivers/staging/greybus/gpio.c
+++ b/drivers/staging/greybus/gpio.c
@@ -211,21 +211,6 @@ static int gb_gpio_set_debounce_operation(struct gb_gpio_controller *ggc,
 	return ret;
 }
 
-static void gb_gpio_ack_irq(struct irq_data *d)
-{
-	struct gpio_chip *chip = irq_data_to_gpio_chip(d);
-	struct gb_gpio_controller *ggc = gpio_chip_to_gb_gpio_controller(chip);
-	struct gb_gpio_irq_ack_request request;
-	int ret;
-
-	request.which = d->hwirq;
-	ret = gb_operation_sync(ggc->connection,
-				GB_GPIO_TYPE_IRQ_ACK,
-				&request, sizeof(request), NULL, 0);
-	if (ret)
-		dev_err(chip->dev, "failed to ack irq: %d\n", ret);
-}
-
 static void gb_gpio_mask_irq(struct irq_data *d)
 {
 	struct gpio_chip *chip = irq_data_to_gpio_chip(d);
@@ -591,7 +576,6 @@ static int gb_gpio_connection_init(struct gb_connection *connection)
 		goto err_free_controller;
 
 	irqc = &ggc->irqc;
-	irqc->irq_ack = gb_gpio_ack_irq;
 	irqc->irq_mask = gb_gpio_mask_irq;
 	irqc->irq_unmask = gb_gpio_unmask_irq;
 	irqc->irq_set_type = gb_gpio_irq_set_type;

commit c8d1ad8013681eeb2dc8dac405db3b95284adc1d
Author: Johan Hovold <johan@hovoldconsulting.com>
Date:   Tue May 26 15:29:19 2015 +0200

    greybus: gpio: fix debugfs output
    
    Fix debugfs output by removing the unimplemented, custom dbg_show
    callback. The default implementation is perfectly sufficient.
    
    Signed-off-by: Johan Hovold <johan@hovoldconsulting.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/gpio.c b/drivers/staging/greybus/gpio.c
index 6e5fe5b3db39..0191bb809968 100644
--- a/drivers/staging/greybus/gpio.c
+++ b/drivers/staging/greybus/gpio.c
@@ -414,11 +414,6 @@ static int gb_gpio_set_debounce(struct gpio_chip *chip, unsigned offset,
 	return gb_gpio_set_debounce_operation(ggc, (u8)offset, usec);
 }
 
-static void gb_gpio_dbg_show(struct seq_file *s, struct gpio_chip *chip)
-{
-	return;	/* XXX */
-}
-
 static int gb_gpio_controller_setup(struct gb_gpio_controller *ggc)
 {
 	int ret;
@@ -616,7 +611,6 @@ static int gb_gpio_connection_init(struct gb_connection *connection)
 	gpio->get = gb_gpio_get;
 	gpio->set = gb_gpio_set;
 	gpio->set_debounce = gb_gpio_set_debounce;
-	gpio->dbg_show = gb_gpio_dbg_show;
 	gpio->to_irq = gb_gpio_to_irq;
 	gpio->base = -1;		/* Allocate base dynamically */
 	gpio->ngpio = ggc->line_max + 1;

commit e9385e5d5ab64a0d05758d84f2980943d3f5f12d
Author: Alex Elder <elder@linaro.org>
Date:   Fri May 22 12:35:31 2015 -0500

    greybus: include "gpbridge.h" from "greybus.h"
    
    Avoid the need for all the source files to include "gpbridge.h"
    by just having "greybus.h" include it.
    
    Signed-off-by: Alex Elder <elder@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/gpio.c b/drivers/staging/greybus/gpio.c
index 871f2d0558b0..6e5fe5b3db39 100644
--- a/drivers/staging/greybus/gpio.c
+++ b/drivers/staging/greybus/gpio.c
@@ -14,7 +14,6 @@
 #include <linux/irq.h>
 #include <linux/irqdomain.h>
 #include "greybus.h"
-#include "gpbridge.h"
 
 struct gb_gpio_line {
 	/* The following has to be an array of line_max entries */

commit bdac599c70409bbf48e77971e2b9ecc2a66ef151
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Wed May 20 17:20:10 2015 +0530

    greybus: Use gb_gpbridge_protocol_init()
    
    Start using gb_gpbridge_protocol_init() in gpbridge drivers.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Reviewed-by: Alex Elder <elder@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/gpio.c b/drivers/staging/greybus/gpio.c
index 6a4a0f2a835d..871f2d0558b0 100644
--- a/drivers/staging/greybus/gpio.c
+++ b/drivers/staging/greybus/gpio.c
@@ -672,12 +672,4 @@ static struct gb_protocol gpio_protocol = {
 	.request_recv		= gb_gpio_request_recv,
 };
 
-int gb_gpio_protocol_init(void)
-{
-	return gb_protocol_register(&gpio_protocol);
-}
-
-void gb_gpio_protocol_exit(void)
-{
-	gb_protocol_deregister(&gpio_protocol);
-}
+gb_gpbridge_protocol_driver(gpio_protocol);

commit 8de925b973263694edcb13aa30f2fe0273163c0f
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Wed May 20 16:32:28 2015 +0530

    greybus: gpio: fix tab/space mistake
    
    Spaces were present in place of tab. Fix that.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/gpio.c b/drivers/staging/greybus/gpio.c
index 5ed1895e8701..6a4a0f2a835d 100644
--- a/drivers/staging/greybus/gpio.c
+++ b/drivers/staging/greybus/gpio.c
@@ -282,7 +282,7 @@ static int gb_gpio_irq_set_type(struct irq_data *d, unsigned int type)
 			dev_err(chip->dev, "failed to set irq type: %d\n",
 				ret);
 		}
-                break;
+		break;
 	default:
 		dev_err(chip->dev, "unsupported irq type: %u\n", type);
 		ret = -EINVAL;

commit 453bbea807345db3faab8f4a432b4b1b2b245a27
Author: John Stultz <john.stultz@linaro.org>
Date:   Thu Apr 9 16:01:31 2015 -0700

    greybus: Move briged phy structure definitions into gpbridge.h
    
    In order to facilitate re-use of the gpio, i2c, pwm and i2s
    structures, split them out of independent files and add
    them into a shared gpbridge.h
    
    This will be a prereq to sharing these headers w/ gbsim.
    
    Cc: Alex Elder <alex.elder@linaro.org>
    Cc: Greg Kroah-Hartman <gregkh@google.com>
    CC: Johan Hovold <johan@hovoldconsulting.com>
    Signed-off-by: John Stultz <john.stultz@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/gpio.c b/drivers/staging/greybus/gpio.c
index 20917bf6479f..5ed1895e8701 100644
--- a/drivers/staging/greybus/gpio.c
+++ b/drivers/staging/greybus/gpio.c
@@ -14,6 +14,7 @@
 #include <linux/irq.h>
 #include <linux/irqdomain.h>
 #include "greybus.h"
+#include "gpbridge.h"
 
 struct gb_gpio_line {
 	/* The following has to be an array of line_max entries */
@@ -43,110 +44,6 @@ struct gb_gpio_controller {
 	container_of(chip, struct gb_gpio_controller, chip)
 #define irq_data_to_gpio_chip(d) (d->domain->host_data)
 
-/* Version of the Greybus GPIO protocol we support */
-#define	GB_GPIO_VERSION_MAJOR		0x00
-#define	GB_GPIO_VERSION_MINOR		0x01
-
-/* Greybus GPIO request types */
-#define	GB_GPIO_TYPE_INVALID		0x00
-#define	GB_GPIO_TYPE_PROTOCOL_VERSION	0x01
-#define	GB_GPIO_TYPE_LINE_COUNT		0x02
-#define	GB_GPIO_TYPE_ACTIVATE		0x03
-#define	GB_GPIO_TYPE_DEACTIVATE		0x04
-#define	GB_GPIO_TYPE_GET_DIRECTION	0x05
-#define	GB_GPIO_TYPE_DIRECTION_IN	0x06
-#define	GB_GPIO_TYPE_DIRECTION_OUT	0x07
-#define	GB_GPIO_TYPE_GET_VALUE		0x08
-#define	GB_GPIO_TYPE_SET_VALUE		0x09
-#define	GB_GPIO_TYPE_SET_DEBOUNCE	0x0a
-#define GB_GPIO_TYPE_IRQ_TYPE		0x0b
-#define GB_GPIO_TYPE_IRQ_ACK		0x0c
-#define GB_GPIO_TYPE_IRQ_MASK		0x0d
-#define GB_GPIO_TYPE_IRQ_UNMASK		0x0e
-#define GB_GPIO_TYPE_IRQ_EVENT		0x0f
-#define	GB_GPIO_TYPE_RESPONSE		0x80	/* OR'd with rest */
-
-#define	GB_GPIO_DEBOUNCE_USEC_DEFAULT	0	/* microseconds */
-
-/* line count request has no payload */
-struct gb_gpio_line_count_response {
-	__u8	count;
-};
-
-struct gb_gpio_activate_request {
-	__u8	which;
-};
-/* activate response has no payload */
-
-struct gb_gpio_deactivate_request {
-	__u8	which;
-};
-/* deactivate response has no payload */
-
-struct gb_gpio_get_direction_request {
-	__u8	which;
-};
-struct gb_gpio_get_direction_response {
-	__u8	direction;
-};
-
-struct gb_gpio_direction_in_request {
-	__u8	which;
-};
-/* direction in response has no payload */
-
-struct gb_gpio_direction_out_request {
-	__u8	which;
-	__u8	value;
-};
-/* direction out response has no payload */
-
-struct gb_gpio_get_value_request {
-	__u8	which;
-};
-struct gb_gpio_get_value_response {
-	__u8	value;
-};
-
-struct gb_gpio_set_value_request {
-	__u8	which;
-	__u8	value;
-};
-/* set value response has no payload */
-
-struct gb_gpio_set_debounce_request {
-	__u8	which;
-	__le16	usec __packed;
-};
-/* debounce response has no payload */
-
-struct gb_gpio_irq_type_request {
-	__u8	which;
-	__u8	type;
-};
-/* irq type response has no payload */
-
-struct gb_gpio_irq_mask_request {
-	__u8	which;
-};
-/* irq mask response has no payload */
-
-struct gb_gpio_irq_unmask_request {
-	__u8	which;
-};
-/* irq unmask response has no payload */
-
-struct gb_gpio_irq_ack_request {
-	__u8	which;
-};
-/* irq ack response has no payload */
-
-/* irq event requests originate on another module and are handled on the AP */
-struct gb_gpio_irq_event_request {
-	__u8	which;
-};
-/* irq event response has no payload */
-
 /* Define get_version() routine */
 define_get_version(gb_gpio_controller, GPIO);
 

commit 973ccfd62686a2331f43b0053de052d958f50d31
Author: Johan Hovold <johan@hovoldconsulting.com>
Date:   Fri Mar 27 12:45:49 2015 +0100

    greybus: operation: refactor response handling
    
    Send response to incoming requests from the operation request handler
    rather than in every protocol request_recv callback.
    
    This simplifies request_recv error handling and allows for further code
    reuse.
    
    Note that if we ever get protocols that need to hold off sending
    responses we could implement this by letting them return a special
    value (after acquiring the necessary operation references) to suppress
    the response from being sent by greybus core.
    
    Signed-off-by: Johan Hovold <johan@hovoldconsulting.com>
    Reviewed-by: Alex Elder <elder@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>

diff --git a/drivers/staging/greybus/gpio.c b/drivers/staging/greybus/gpio.c
index 9a34fc5a52b8..20917bf6479f 100644
--- a/drivers/staging/greybus/gpio.c
+++ b/drivers/staging/greybus/gpio.c
@@ -394,7 +394,7 @@ static int gb_gpio_irq_set_type(struct irq_data *d, unsigned int type)
 	return ret;
 }
 
-static void gb_gpio_request_recv(u8 type, struct gb_operation *op)
+static int gb_gpio_request_recv(u8 type, struct gb_operation *op)
 {
 	struct gb_connection *connection = op->connection;
 	struct gb_gpio_controller *ggc = connection->private;
@@ -402,41 +402,35 @@ static void gb_gpio_request_recv(u8 type, struct gb_operation *op)
 	struct gb_gpio_irq_event_request *event;
 	int irq;
 	struct irq_desc *desc;
-	int ret;
-	int status;
 
 	if (type != GB_GPIO_TYPE_IRQ_EVENT) {
 		dev_err(&connection->dev,
 			"unsupported unsolicited request: %u\n", type);
-		status = -EINVAL;
-		goto send_response;
+		return -EINVAL;
 	}
 
 	request = op->request;
 
 	if (request->payload_size < sizeof(*event)) {
 		dev_err(ggc->chip.dev, "short event received\n");
-		status = -EINVAL;
-		goto send_response;
+		return -EINVAL;
 	}
 
 	event = request->payload;
 	if (event->which > ggc->line_max) {
 		dev_err(ggc->chip.dev, "invalid hw irq: %d\n", event->which);
-		status = -EINVAL;
-		goto send_response;
+		return -EINVAL;
 	}
+
 	irq = gpio_to_irq(ggc->chip.base + event->which);
 	if (irq < 0) {
 		dev_err(ggc->chip.dev, "failed to map irq\n");
-		status = -EINVAL;
-		goto send_response;
+		return -EINVAL;
 	}
 	desc = irq_to_desc(irq);
 	if (!desc) {
 		dev_err(ggc->chip.dev, "failed to look up irq\n");
-		status = -EINVAL;
-		goto send_response;
+		return -EINVAL;
 	}
 
 	/* Dispatch interrupt */
@@ -444,14 +438,7 @@ static void gb_gpio_request_recv(u8 type, struct gb_operation *op)
 	handle_simple_irq(irq, desc);
 	local_irq_enable();
 
-	status = 0;
-send_response:
-	ret = gb_operation_response_send(op, status);
-	if (ret) {
-		dev_err(ggc->chip.dev,
-			"failed to send response status %d: %d\n",
-			status, ret);
-	}
+	return 0;
 }
 
 static int gb_gpio_request(struct gpio_chip *chip, unsigned offset)

commit fef96a226eca4eae4aea1657ebcf5b013d6e48b6
Author: Johan Hovold <johan@hovoldconsulting.com>
Date:   Fri Mar 27 12:45:43 2015 +0100

    greybus: gpio: fix missing response on request errors
    
    Send response also to incoming requests that cannot be fulfilled.
    
    Signed-off-by: Johan Hovold <johan@hovoldconsulting.com>
    Reviewed-by: Alex Elder <elder@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>

diff --git a/drivers/staging/greybus/gpio.c b/drivers/staging/greybus/gpio.c
index 0500a6f58526..9a34fc5a52b8 100644
--- a/drivers/staging/greybus/gpio.c
+++ b/drivers/staging/greybus/gpio.c
@@ -396,43 +396,47 @@ static int gb_gpio_irq_set_type(struct irq_data *d, unsigned int type)
 
 static void gb_gpio_request_recv(u8 type, struct gb_operation *op)
 {
-	struct gb_gpio_controller *ggc;
 	struct gb_connection *connection = op->connection;
+	struct gb_gpio_controller *ggc = connection->private;
 	struct gb_message *request;
 	struct gb_gpio_irq_event_request *event;
 	int irq;
 	struct irq_desc *desc;
 	int ret;
+	int status;
 
 	if (type != GB_GPIO_TYPE_IRQ_EVENT) {
 		dev_err(&connection->dev,
 			"unsupported unsolicited request: %u\n", type);
-		return;
+		status = -EINVAL;
+		goto send_response;
 	}
 
-	ggc = connection->private;
-
 	request = op->request;
 
 	if (request->payload_size < sizeof(*event)) {
 		dev_err(ggc->chip.dev, "short event received\n");
-		return;
+		status = -EINVAL;
+		goto send_response;
 	}
 
 	event = request->payload;
 	if (event->which > ggc->line_max) {
 		dev_err(ggc->chip.dev, "invalid hw irq: %d\n", event->which);
-		return;
+		status = -EINVAL;
+		goto send_response;
 	}
 	irq = gpio_to_irq(ggc->chip.base + event->which);
 	if (irq < 0) {
 		dev_err(ggc->chip.dev, "failed to map irq\n");
-		return;
+		status = -EINVAL;
+		goto send_response;
 	}
 	desc = irq_to_desc(irq);
 	if (!desc) {
 		dev_err(ggc->chip.dev, "failed to look up irq\n");
-		return;
+		status = -EINVAL;
+		goto send_response;
 	}
 
 	/* Dispatch interrupt */
@@ -440,10 +444,13 @@ static void gb_gpio_request_recv(u8 type, struct gb_operation *op)
 	handle_simple_irq(irq, desc);
 	local_irq_enable();
 
-	ret = gb_operation_response_send(op, 0);
+	status = 0;
+send_response:
+	ret = gb_operation_response_send(op, status);
 	if (ret) {
 		dev_err(ggc->chip.dev,
-			"failed to send response status %d: %d\n", 0, ret);
+			"failed to send response status %d: %d\n",
+			status, ret);
 	}
 }
 

commit 244b5a2344bce5d9675e02da65b24e026926348c
Author: Johan Hovold <johan@hovoldconsulting.com>
Date:   Fri Mar 27 12:45:42 2015 +0100

    greybus: gpio: fix null-deref on unexpected irq requests
    
    Fix null-pointer dereference on failure to look up irq due to missing
    error handling.
    
    Signed-off-by: Johan Hovold <johan@hovoldconsulting.com>
    Reviewed-by: Alex Elder <elder@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>

diff --git a/drivers/staging/greybus/gpio.c b/drivers/staging/greybus/gpio.c
index 7dc675d7bd5b..0500a6f58526 100644
--- a/drivers/staging/greybus/gpio.c
+++ b/drivers/staging/greybus/gpio.c
@@ -425,7 +425,15 @@ static void gb_gpio_request_recv(u8 type, struct gb_operation *op)
 		return;
 	}
 	irq = gpio_to_irq(ggc->chip.base + event->which);
+	if (irq < 0) {
+		dev_err(ggc->chip.dev, "failed to map irq\n");
+		return;
+	}
 	desc = irq_to_desc(irq);
+	if (!desc) {
+		dev_err(ggc->chip.dev, "failed to look up irq\n");
+		return;
+	}
 
 	/* Dispatch interrupt */
 	local_irq_disable();

commit 1842dd8b7bc7d713d3c252a501411b5009b3987d
Author: Johan Hovold <johan@hovoldconsulting.com>
Date:   Fri Mar 27 12:45:41 2015 +0100

    greybus: gpio: fix null-deref on short irq requests
    
    Make sure to verify the length of incoming requests before trying to
    parse the request buffer, which can even be NULL on empty requests.
    
    Signed-off-by: Johan Hovold <johan@hovoldconsulting.com>
    Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>

diff --git a/drivers/staging/greybus/gpio.c b/drivers/staging/greybus/gpio.c
index 2bac28ec7f85..7dc675d7bd5b 100644
--- a/drivers/staging/greybus/gpio.c
+++ b/drivers/staging/greybus/gpio.c
@@ -413,6 +413,12 @@ static void gb_gpio_request_recv(u8 type, struct gb_operation *op)
 	ggc = connection->private;
 
 	request = op->request;
+
+	if (request->payload_size < sizeof(*event)) {
+		dev_err(ggc->chip.dev, "short event received\n");
+		return;
+	}
+
 	event = request->payload;
 	if (event->which > ggc->line_max) {
 		dev_err(ggc->chip.dev, "invalid hw irq: %d\n", event->which);

commit 792c17e64383340a75579cdfc6b9b6d2b1647b43
Author: Johan Hovold <johan@hovoldconsulting.com>
Date:   Thu Mar 19 16:55:23 2015 +0100

    greybus: gpio: add error messages to callbacks not propagating errors
    
    Add error messages on failures to deactivate, set and get operation
    handlers as any errors would not be detected by the upper layers (either
    because the callbacks are declared void or expected to return a boolean
    value).
    
    Signed-off-by: Johan Hovold <johan@hovoldconsulting.com>
    Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>

diff --git a/drivers/staging/greybus/gpio.c b/drivers/staging/greybus/gpio.c
index 7e51840cd262..2bac28ec7f85 100644
--- a/drivers/staging/greybus/gpio.c
+++ b/drivers/staging/greybus/gpio.c
@@ -184,8 +184,13 @@ static void gb_gpio_deactivate_operation(struct gb_gpio_controller *ggc,
 	request.which = which;
 	ret = gb_operation_sync(ggc->connection, GB_GPIO_TYPE_DEACTIVATE,
 				 &request, sizeof(request), NULL, 0);
-	if (!ret)
-		ggc->lines[which].active = false;
+	if (ret) {
+		dev_err(ggc->chip.dev, "failed to deactivate gpio %u\n",
+			which);
+		return;
+	}
+
+	ggc->lines[which].active = false;
 }
 
 static int gb_gpio_get_direction_operation(struct gb_gpio_controller *ggc,
@@ -254,8 +259,11 @@ static int gb_gpio_get_value_operation(struct gb_gpio_controller *ggc,
 	ret = gb_operation_sync(ggc->connection, GB_GPIO_TYPE_GET_VALUE,
 				&request, sizeof(request),
 				&response, sizeof(response));
-	if (ret)
+	if (ret) {
+		dev_err(ggc->chip.dev, "failed to get value of gpio %u\n",
+			which);
 		return ret;
+	}
 
 	value = response.value;
 	if (value && value != 1) {
@@ -283,8 +291,13 @@ static void gb_gpio_set_value_operation(struct gb_gpio_controller *ggc,
 	request.value = value_high ? 1 : 0;
 	ret = gb_operation_sync(ggc->connection, GB_GPIO_TYPE_SET_VALUE,
 				&request, sizeof(request), NULL, 0);
-	if (!ret)
-		ggc->lines[which].value = request.value;
+	if (ret) {
+		dev_err(ggc->chip.dev, "failed to set value of gpio %u\n",
+			which);
+		return;
+	}
+
+	ggc->lines[which].value = request.value;
 }
 
 static int gb_gpio_set_debounce_operation(struct gb_gpio_controller *ggc,

commit 7bfa0781406f9df6cb20ce5134faa19d34cb4e18
Author: Johan Hovold <johan@hovoldconsulting.com>
Date:   Thu Mar 19 16:55:22 2015 +0100

    greybus: gpio: refuse to set value of input pins
    
    Add warning and refuse to set output value for pin configured as input,
    as the result of such an operation is undefined.
    
    Remove incorrect todo-comment suggesting that the driver could
    implicitly switch direction as part of the call.
    
    Signed-off-by: Johan Hovold <johan@hovoldconsulting.com>
    Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>

diff --git a/drivers/staging/greybus/gpio.c b/drivers/staging/greybus/gpio.c
index b18fb7e12a5b..7e51840cd262 100644
--- a/drivers/staging/greybus/gpio.c
+++ b/drivers/staging/greybus/gpio.c
@@ -273,14 +273,18 @@ static void gb_gpio_set_value_operation(struct gb_gpio_controller *ggc,
 	struct gb_gpio_set_value_request request;
 	int ret;
 
+	if (ggc->lines[which].direction == 1) {
+		dev_warn(ggc->chip.dev,
+			 "refusing to set value of input gpio %u\n", which);
+		return;
+	}
+
 	request.which = which;
 	request.value = value_high ? 1 : 0;
 	ret = gb_operation_sync(ggc->connection, GB_GPIO_TYPE_SET_VALUE,
 				&request, sizeof(request), NULL, 0);
-	if (!ret) {
-		/* XXX should this set direction to out? */
+	if (!ret)
 		ggc->lines[which].value = request.value;
-	}
 }
 
 static int gb_gpio_set_debounce_operation(struct gb_gpio_controller *ggc,

commit 64d2f4e5f94a95b23532efcbc3c955b5086bd890
Author: Johan Hovold <johan@hovoldconsulting.com>
Date:   Thu Mar 19 16:51:17 2015 +0100

    greybus: gpio: clean up line-state allocation
    
    Clean up allocation of line-state array.
    
    Signed-off-by: Johan Hovold <johan@hovoldconsulting.com>
    Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>

diff --git a/drivers/staging/greybus/gpio.c b/drivers/staging/greybus/gpio.c
index a9153a85b011..b18fb7e12a5b 100644
--- a/drivers/staging/greybus/gpio.c
+++ b/drivers/staging/greybus/gpio.c
@@ -500,8 +500,6 @@ static void gb_gpio_dbg_show(struct seq_file *s, struct gpio_chip *chip)
 
 static int gb_gpio_controller_setup(struct gb_gpio_controller *ggc)
 {
-	u32 line_count;
-	size_t size;
 	int ret;
 
 	/* First thing we need to do is check the version */
@@ -514,9 +512,8 @@ static int gb_gpio_controller_setup(struct gb_gpio_controller *ggc)
 	if (ret)
 		return ret;
 
-	line_count = (u32)ggc->line_max + 1;
-	size = line_count * sizeof(*ggc->lines);
-	ggc->lines = kzalloc(size, GFP_KERNEL);
+	ggc->lines = kcalloc(ggc->line_max + 1, sizeof(*ggc->lines),
+			     GFP_KERNEL);
 	if (!ggc->lines)
 		return -ENOMEM;
 

commit e5032d8511cdb0b7b594863effa2c2a685beaaa5
Author: Johan Hovold <johan@hovoldconsulting.com>
Date:   Thu Mar 19 16:51:16 2015 +0100

    greybus: gpio: use dev_err and dev_warn
    
    Use the more informative dev_err and dev_warn for messages, and make the
    messages more uniform.
    
    Signed-off-by: Johan Hovold <johan@hovoldconsulting.com>
    Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>

diff --git a/drivers/staging/greybus/gpio.c b/drivers/staging/greybus/gpio.c
index acc8f395fc6b..a9153a85b011 100644
--- a/drivers/staging/greybus/gpio.c
+++ b/drivers/staging/greybus/gpio.c
@@ -204,9 +204,11 @@ static int gb_gpio_get_direction_operation(struct gb_gpio_controller *ggc,
 		return ret;
 
 	direction = response.direction;
-	if (direction && direction != 1)
-		pr_warn("gpio %u direction was %u (should be 0 or 1)\n",
-			which, direction);
+	if (direction && direction != 1) {
+		dev_warn(ggc->chip.dev,
+			 "gpio %u direction was %u (should be 0 or 1)\n",
+			 which, direction);
+	}
 	ggc->lines[which].direction = direction ? 1 : 0;
 	return 0;
 }
@@ -256,9 +258,11 @@ static int gb_gpio_get_value_operation(struct gb_gpio_controller *ggc,
 		return ret;
 
 	value = response.value;
-	if (value && value != 1)
-		pr_warn("gpio %u value was %u (should be 0 or 1)\n",
-			which, value);
+	if (value && value != 1) {
+		dev_warn(ggc->chip.dev,
+			 "gpio %u value was %u (should be 0 or 1)\n",
+			 which, value);
+	}
 	ggc->lines[which].value = value ? 1 : 0;
 	return 0;
 }
@@ -306,7 +310,7 @@ static void gb_gpio_ack_irq(struct irq_data *d)
 				GB_GPIO_TYPE_IRQ_ACK,
 				&request, sizeof(request), NULL, 0);
 	if (ret)
-		pr_err("irq ack operation failed (%d)\n", ret);
+		dev_err(chip->dev, "failed to ack irq: %d\n", ret);
 }
 
 static void gb_gpio_mask_irq(struct irq_data *d)
@@ -321,7 +325,7 @@ static void gb_gpio_mask_irq(struct irq_data *d)
 				GB_GPIO_TYPE_IRQ_MASK,
 				&request, sizeof(request), NULL, 0);
 	if (ret)
-		pr_err("irq mask operation failed (%d)\n", ret);
+		dev_err(chip->dev, "failed to mask irq: %d\n", ret);
 }
 
 static void gb_gpio_unmask_irq(struct irq_data *d)
@@ -336,7 +340,7 @@ static void gb_gpio_unmask_irq(struct irq_data *d)
 				GB_GPIO_TYPE_IRQ_UNMASK,
 				&request, sizeof(request), NULL, 0);
 	if (ret)
-		pr_err("irq unmask operation failed (%d)\n", ret);
+		dev_err(chip->dev, "failed to unmask irq: %d\n", ret);
 }
 
 static int gb_gpio_irq_set_type(struct irq_data *d, unsigned int type)
@@ -360,11 +364,13 @@ static int gb_gpio_irq_set_type(struct irq_data *d, unsigned int type)
 		ret = gb_operation_sync(ggc->connection,
 					GB_GPIO_TYPE_IRQ_TYPE,
 					&request, sizeof(request), NULL, 0);
-		if (ret)
-			pr_err("irq type operation failed (%d)\n", ret);
+		if (ret) {
+			dev_err(chip->dev, "failed to set irq type: %d\n",
+				ret);
+		}
                 break;
 	default:
-		pr_err("No such irq type %d", type);
+		dev_err(chip->dev, "unsupported irq type: %u\n", type);
 		ret = -EINVAL;
 	}
 
@@ -374,7 +380,7 @@ static int gb_gpio_irq_set_type(struct irq_data *d, unsigned int type)
 static void gb_gpio_request_recv(u8 type, struct gb_operation *op)
 {
 	struct gb_gpio_controller *ggc;
-	struct gb_connection *connection;
+	struct gb_connection *connection = op->connection;
 	struct gb_message *request;
 	struct gb_gpio_irq_event_request *event;
 	int irq;
@@ -382,17 +388,17 @@ static void gb_gpio_request_recv(u8 type, struct gb_operation *op)
 	int ret;
 
 	if (type != GB_GPIO_TYPE_IRQ_EVENT) {
-		pr_err("unsupported unsolicited request\n");
+		dev_err(&connection->dev,
+			"unsupported unsolicited request: %u\n", type);
 		return;
 	}
 
-	connection = op->connection;
 	ggc = connection->private;
 
 	request = op->request;
 	event = request->payload;
 	if (event->which > ggc->line_max) {
-		pr_err("Unsupported hw irq %d\n", event->which);
+		dev_err(ggc->chip.dev, "invalid hw irq: %d\n", event->which);
 		return;
 	}
 	irq = gpio_to_irq(ggc->chip.base + event->which);
@@ -404,8 +410,10 @@ static void gb_gpio_request_recv(u8 type, struct gb_operation *op)
 	local_irq_enable();
 
 	ret = gb_operation_response_send(op, 0);
-	if (ret)
-		pr_err("error %d sending response status %d\n", ret, 0);
+	if (ret) {
+		dev_err(ggc->chip.dev,
+			"failed to send response status %d: %d\n", 0, ret);
+	}
 }
 
 static int gb_gpio_request(struct gpio_chip *chip, unsigned offset)
@@ -698,14 +706,15 @@ static int gb_gpio_connection_init(struct gb_connection *connection)
 
 	ret = gpiochip_add(gpio);
 	if (ret) {
-		pr_err("Failed to register GPIO\n");
+		dev_err(&connection->dev, "failed to add gpio chip: %d\n",
+			ret);
 		goto err_free_lines;
 	}
 
 	ret = gb_gpio_irqchip_add(gpio, irqc, 0,
 				   handle_simple_irq, IRQ_TYPE_NONE);
 	if (ret) {
-		pr_err("Couldn't add irqchip to Greybus GPIO controller %d\n", ret);
+		dev_err(&connection->dev, "failed to add irq chip: %d\n", ret);
 		goto irqchip_err;
 	}
 

commit 86c6816158d79228162b6dc2e759e3769dd3ab09
Author: Johan Hovold <johan@hovoldconsulting.com>
Date:   Thu Mar 19 16:51:15 2015 +0100

    greybus: gpio: fix error handling
    
    Make sure to propagate any errors detected up the call chain.
    
    This specifically means that we will detect failed connection init,
    something which is now handled more gracefully by greybus core.
    
    Signed-off-by: Johan Hovold <johan@hovoldconsulting.com>
    Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>

diff --git a/drivers/staging/greybus/gpio.c b/drivers/staging/greybus/gpio.c
index d19427409696..acc8f395fc6b 100644
--- a/drivers/staging/greybus/gpio.c
+++ b/drivers/staging/greybus/gpio.c
@@ -175,7 +175,7 @@ static int gb_gpio_activate_operation(struct gb_gpio_controller *ggc, u8 which)
 	return ret;
 }
 
-static int gb_gpio_deactivate_operation(struct gb_gpio_controller *ggc,
+static void gb_gpio_deactivate_operation(struct gb_gpio_controller *ggc,
 					u8 which)
 {
 	struct gb_gpio_deactivate_request request;
@@ -186,7 +186,6 @@ static int gb_gpio_deactivate_operation(struct gb_gpio_controller *ggc,
 				 &request, sizeof(request), NULL, 0);
 	if (!ret)
 		ggc->lines[which].active = false;
-	return ret;
 }
 
 static int gb_gpio_get_direction_operation(struct gb_gpio_controller *ggc,
@@ -264,7 +263,7 @@ static int gb_gpio_get_value_operation(struct gb_gpio_controller *ggc,
 	return 0;
 }
 
-static int gb_gpio_set_value_operation(struct gb_gpio_controller *ggc,
+static void gb_gpio_set_value_operation(struct gb_gpio_controller *ggc,
 					u8 which, bool value_high)
 {
 	struct gb_gpio_set_value_request request;
@@ -278,7 +277,6 @@ static int gb_gpio_set_value_operation(struct gb_gpio_controller *ggc,
 		/* XXX should this set direction to out? */
 		ggc->lines[which].value = request.value;
 	}
-	return ret;
 }
 
 static int gb_gpio_set_debounce_operation(struct gb_gpio_controller *ggc,
@@ -413,22 +411,15 @@ static void gb_gpio_request_recv(u8 type, struct gb_operation *op)
 static int gb_gpio_request(struct gpio_chip *chip, unsigned offset)
 {
 	struct gb_gpio_controller *ggc = gpio_chip_to_gb_gpio_controller(chip);
-	int ret;
 
-	ret = gb_gpio_activate_operation(ggc, (u8)offset);
-	if (ret)
-		;	/* return ret; */
-	return 0;
+	return gb_gpio_activate_operation(ggc, (u8)offset);
 }
 
 static void gb_gpio_free(struct gpio_chip *chip, unsigned offset)
 {
 	struct gb_gpio_controller *ggc = gpio_chip_to_gb_gpio_controller(chip);
-	int ret;
 
-	ret = gb_gpio_deactivate_operation(ggc, (u8)offset);
-	if (ret)
-		;	/* return ret; */
+	gb_gpio_deactivate_operation(ggc, (u8)offset);
 }
 
 static int gb_gpio_get_direction(struct gpio_chip *chip, unsigned offset)
@@ -440,31 +431,24 @@ static int gb_gpio_get_direction(struct gpio_chip *chip, unsigned offset)
 	which = (u8)offset;
 	ret = gb_gpio_get_direction_operation(ggc, which);
 	if (ret)
-		;	/* return ret; */
+		return ret;
+
 	return ggc->lines[which].direction ? 1 : 0;
 }
 
 static int gb_gpio_direction_input(struct gpio_chip *chip, unsigned offset)
 {
 	struct gb_gpio_controller *ggc = gpio_chip_to_gb_gpio_controller(chip);
-	int ret;
 
-	ret = gb_gpio_direction_in_operation(ggc, (u8)offset);
-	if (ret)
-		;	/* return ret; */
-	return 0;
+	return gb_gpio_direction_in_operation(ggc, (u8)offset);
 }
 
 static int gb_gpio_direction_output(struct gpio_chip *chip, unsigned offset,
 					int value)
 {
 	struct gb_gpio_controller *ggc = gpio_chip_to_gb_gpio_controller(chip);
-	int ret;
 
-	ret = gb_gpio_direction_out_operation(ggc, (u8)offset, !!value);
-	if (ret)
-		;	/* return ret; */
-	return 0;
+	return gb_gpio_direction_out_operation(ggc, (u8)offset, !!value);
 }
 
 static int gb_gpio_get(struct gpio_chip *chip, unsigned offset)
@@ -477,17 +461,15 @@ static int gb_gpio_get(struct gpio_chip *chip, unsigned offset)
 	ret = gb_gpio_get_value_operation(ggc, which);
 	if (ret)
 		return ret;
+
 	return ggc->lines[which].value;
 }
 
 static void gb_gpio_set(struct gpio_chip *chip, unsigned offset, int value)
 {
 	struct gb_gpio_controller *ggc = gpio_chip_to_gb_gpio_controller(chip);
-	int ret;
 
-	ret = gb_gpio_set_value_operation(ggc, (u8)offset, !!value);
-	if (ret)
-		;	/* return ret; */
+	gb_gpio_set_value_operation(ggc, (u8)offset, !!value);
 }
 
 static int gb_gpio_set_debounce(struct gpio_chip *chip, unsigned offset,
@@ -495,16 +477,12 @@ static int gb_gpio_set_debounce(struct gpio_chip *chip, unsigned offset,
 {
 	struct gb_gpio_controller *ggc = gpio_chip_to_gb_gpio_controller(chip);
 	u16 usec;
-	int ret;
 
 	if (debounce > U16_MAX)
 		return -EINVAL;
 	usec = (u16)debounce;
-	ret = gb_gpio_set_debounce_operation(ggc, (u8)offset, usec);
-	if (ret)
-		;	/* return ret; */
 
-	return 0;	/* XXX */
+	return gb_gpio_set_debounce_operation(ggc, (u8)offset, usec);
 }
 
 static void gb_gpio_dbg_show(struct seq_file *s, struct gpio_chip *chip)
@@ -521,12 +499,13 @@ static int gb_gpio_controller_setup(struct gb_gpio_controller *ggc)
 	/* First thing we need to do is check the version */
 	ret = get_version(ggc);
 	if (ret)
-		;	/* return ret; */
+		return ret;
 
 	/* Now find out how many lines there are */
 	ret = gb_gpio_line_count_operation(ggc);
 	if (ret)
-		;	/* return ret; */
+		return ret;
+
 	line_count = (u32)ggc->line_max + 1;
 	size = line_count * sizeof(*ggc->lines);
 	ggc->lines = kzalloc(size, GFP_KERNEL);

commit 8aff1aceb28dd692a35f628479357896551ab4e9
Author: Johan Hovold <johan@hovoldconsulting.com>
Date:   Thu Mar 19 16:51:14 2015 +0100

    greybus: gpio: make gb_gpio_controller pointer naming consistent
    
    Rename all struct gb_gpio_controller-pointer variables "ggc" for
    consistency and readability reason.
    
    This also fixes a bunch of lines that exceeded the 80 columns limit.
    
    Signed-off-by: Johan Hovold <johan@hovoldconsulting.com>
    Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>

diff --git a/drivers/staging/greybus/gpio.c b/drivers/staging/greybus/gpio.c
index e0a871d37655..d19427409696 100644
--- a/drivers/staging/greybus/gpio.c
+++ b/drivers/staging/greybus/gpio.c
@@ -412,10 +412,10 @@ static void gb_gpio_request_recv(u8 type, struct gb_operation *op)
 
 static int gb_gpio_request(struct gpio_chip *chip, unsigned offset)
 {
-	struct gb_gpio_controller *gb_gpio_controller = gpio_chip_to_gb_gpio_controller(chip);
+	struct gb_gpio_controller *ggc = gpio_chip_to_gb_gpio_controller(chip);
 	int ret;
 
-	ret = gb_gpio_activate_operation(gb_gpio_controller, (u8)offset);
+	ret = gb_gpio_activate_operation(ggc, (u8)offset);
 	if (ret)
 		;	/* return ret; */
 	return 0;
@@ -423,33 +423,33 @@ static int gb_gpio_request(struct gpio_chip *chip, unsigned offset)
 
 static void gb_gpio_free(struct gpio_chip *chip, unsigned offset)
 {
-	struct gb_gpio_controller *gb_gpio_controller = gpio_chip_to_gb_gpio_controller(chip);
+	struct gb_gpio_controller *ggc = gpio_chip_to_gb_gpio_controller(chip);
 	int ret;
 
-	ret = gb_gpio_deactivate_operation(gb_gpio_controller, (u8)offset);
+	ret = gb_gpio_deactivate_operation(ggc, (u8)offset);
 	if (ret)
 		;	/* return ret; */
 }
 
 static int gb_gpio_get_direction(struct gpio_chip *chip, unsigned offset)
 {
-	struct gb_gpio_controller *gb_gpio_controller = gpio_chip_to_gb_gpio_controller(chip);
+	struct gb_gpio_controller *ggc = gpio_chip_to_gb_gpio_controller(chip);
 	u8 which;
 	int ret;
 
 	which = (u8)offset;
-	ret = gb_gpio_get_direction_operation(gb_gpio_controller, which);
+	ret = gb_gpio_get_direction_operation(ggc, which);
 	if (ret)
 		;	/* return ret; */
-	return gb_gpio_controller->lines[which].direction ? 1 : 0;
+	return ggc->lines[which].direction ? 1 : 0;
 }
 
 static int gb_gpio_direction_input(struct gpio_chip *chip, unsigned offset)
 {
-	struct gb_gpio_controller *gb_gpio_controller = gpio_chip_to_gb_gpio_controller(chip);
+	struct gb_gpio_controller *ggc = gpio_chip_to_gb_gpio_controller(chip);
 	int ret;
 
-	ret = gb_gpio_direction_in_operation(gb_gpio_controller, (u8)offset);
+	ret = gb_gpio_direction_in_operation(ggc, (u8)offset);
 	if (ret)
 		;	/* return ret; */
 	return 0;
@@ -458,10 +458,10 @@ static int gb_gpio_direction_input(struct gpio_chip *chip, unsigned offset)
 static int gb_gpio_direction_output(struct gpio_chip *chip, unsigned offset,
 					int value)
 {
-	struct gb_gpio_controller *gb_gpio_controller = gpio_chip_to_gb_gpio_controller(chip);
+	struct gb_gpio_controller *ggc = gpio_chip_to_gb_gpio_controller(chip);
 	int ret;
 
-	ret = gb_gpio_direction_out_operation(gb_gpio_controller, (u8)offset, !!value);
+	ret = gb_gpio_direction_out_operation(ggc, (u8)offset, !!value);
 	if (ret)
 		;	/* return ret; */
 	return 0;
@@ -469,23 +469,23 @@ static int gb_gpio_direction_output(struct gpio_chip *chip, unsigned offset,
 
 static int gb_gpio_get(struct gpio_chip *chip, unsigned offset)
 {
-	struct gb_gpio_controller *gb_gpio_controller = gpio_chip_to_gb_gpio_controller(chip);
+	struct gb_gpio_controller *ggc = gpio_chip_to_gb_gpio_controller(chip);
 	u8 which;
 	int ret;
 
 	which = (u8)offset;
-	ret = gb_gpio_get_value_operation(gb_gpio_controller, which);
+	ret = gb_gpio_get_value_operation(ggc, which);
 	if (ret)
 		return ret;
-	return gb_gpio_controller->lines[which].value;
+	return ggc->lines[which].value;
 }
 
 static void gb_gpio_set(struct gpio_chip *chip, unsigned offset, int value)
 {
-	struct gb_gpio_controller *gb_gpio_controller = gpio_chip_to_gb_gpio_controller(chip);
+	struct gb_gpio_controller *ggc = gpio_chip_to_gb_gpio_controller(chip);
 	int ret;
 
-	ret = gb_gpio_set_value_operation(gb_gpio_controller, (u8)offset, !!value);
+	ret = gb_gpio_set_value_operation(ggc, (u8)offset, !!value);
 	if (ret)
 		;	/* return ret; */
 }
@@ -493,14 +493,14 @@ static void gb_gpio_set(struct gpio_chip *chip, unsigned offset, int value)
 static int gb_gpio_set_debounce(struct gpio_chip *chip, unsigned offset,
 					unsigned debounce)
 {
-	struct gb_gpio_controller *gb_gpio_controller = gpio_chip_to_gb_gpio_controller(chip);
+	struct gb_gpio_controller *ggc = gpio_chip_to_gb_gpio_controller(chip);
 	u16 usec;
 	int ret;
 
 	if (debounce > U16_MAX)
 		return -EINVAL;
 	usec = (u16)debounce;
-	ret = gb_gpio_set_debounce_operation(gb_gpio_controller, (u8)offset, usec);
+	ret = gb_gpio_set_debounce_operation(ggc, (u8)offset, usec);
 	if (ret)
 		;	/* return ret; */
 
@@ -512,25 +512,25 @@ static void gb_gpio_dbg_show(struct seq_file *s, struct gpio_chip *chip)
 	return;	/* XXX */
 }
 
-static int gb_gpio_controller_setup(struct gb_gpio_controller *gb_gpio_controller)
+static int gb_gpio_controller_setup(struct gb_gpio_controller *ggc)
 {
 	u32 line_count;
 	size_t size;
 	int ret;
 
 	/* First thing we need to do is check the version */
-	ret = get_version(gb_gpio_controller);
+	ret = get_version(ggc);
 	if (ret)
 		;	/* return ret; */
 
 	/* Now find out how many lines there are */
-	ret = gb_gpio_line_count_operation(gb_gpio_controller);
+	ret = gb_gpio_line_count_operation(ggc);
 	if (ret)
 		;	/* return ret; */
-	line_count = (u32)gb_gpio_controller->line_max + 1;
-	size = line_count * sizeof(*gb_gpio_controller->lines);
-	gb_gpio_controller->lines = kzalloc(size, GFP_KERNEL);
-	if (!gb_gpio_controller->lines)
+	line_count = (u32)ggc->line_max + 1;
+	size = line_count * sizeof(*ggc->lines);
+	ggc->lines = kzalloc(size, GFP_KERNEL);
+	if (!ggc->lines)
 		return -ENOMEM;
 
 	return ret;
@@ -675,29 +675,29 @@ static int gb_gpio_to_irq(struct gpio_chip *chip, unsigned offset)
 
 static int gb_gpio_connection_init(struct gb_connection *connection)
 {
-	struct gb_gpio_controller *gb_gpio_controller;
+	struct gb_gpio_controller *ggc;
 	struct gpio_chip *gpio;
 	struct irq_chip *irqc;
 	int ret;
 
-	gb_gpio_controller = kzalloc(sizeof(*gb_gpio_controller), GFP_KERNEL);
-	if (!gb_gpio_controller)
+	ggc = kzalloc(sizeof(*ggc), GFP_KERNEL);
+	if (!ggc)
 		return -ENOMEM;
-	gb_gpio_controller->connection = connection;
-	connection->private = gb_gpio_controller;
+	ggc->connection = connection;
+	connection->private = ggc;
 
-	ret = gb_gpio_controller_setup(gb_gpio_controller);
+	ret = gb_gpio_controller_setup(ggc);
 	if (ret)
 		goto err_free_controller;
 
-	irqc = &gb_gpio_controller->irqc;
+	irqc = &ggc->irqc;
 	irqc->irq_ack = gb_gpio_ack_irq;
 	irqc->irq_mask = gb_gpio_mask_irq;
 	irqc->irq_unmask = gb_gpio_unmask_irq;
 	irqc->irq_set_type = gb_gpio_irq_set_type;
 	irqc->name = "greybus_gpio";
 
-	gpio = &gb_gpio_controller->chip;
+	gpio = &ggc->chip;
 
 	gpio->label = "greybus_gpio";
 	gpio->dev = &connection->dev;
@@ -714,7 +714,7 @@ static int gb_gpio_connection_init(struct gb_connection *connection)
 	gpio->dbg_show = gb_gpio_dbg_show;
 	gpio->to_irq = gb_gpio_to_irq;
 	gpio->base = -1;		/* Allocate base dynamically */
-	gpio->ngpio = gb_gpio_controller->line_max + 1;
+	gpio->ngpio = ggc->line_max + 1;
 	gpio->can_sleep = true;
 
 	ret = gpiochip_add(gpio);
@@ -735,24 +735,24 @@ static int gb_gpio_connection_init(struct gb_connection *connection)
 irqchip_err:
 	gb_gpiochip_remove(gpio);
 err_free_lines:
-	kfree(gb_gpio_controller->lines);
+	kfree(ggc->lines);
 err_free_controller:
-	kfree(gb_gpio_controller);
+	kfree(ggc);
 	return ret;
 }
 
 static void gb_gpio_connection_exit(struct gb_connection *connection)
 {
-	struct gb_gpio_controller *gb_gpio_controller = connection->private;
+	struct gb_gpio_controller *ggc = connection->private;
 
-	if (!gb_gpio_controller)
+	if (!ggc)
 		return;
 
-	gb_gpio_irqchip_remove(gb_gpio_controller);
-	gb_gpiochip_remove(&gb_gpio_controller->chip);
-	/* kref_put(gb_gpio_controller->connection) */
-	kfree(gb_gpio_controller->lines);
-	kfree(gb_gpio_controller);
+	gb_gpio_irqchip_remove(ggc);
+	gb_gpiochip_remove(&ggc->chip);
+	/* kref_put(ggc->connection) */
+	kfree(ggc->lines);
+	kfree(ggc);
 }
 
 static struct gb_protocol gpio_protocol = {

commit bda7e2d1126f20c57f175c37c26c42b41ee4b64f
Author: Johan Hovold <johan@hovoldconsulting.com>
Date:   Thu Mar 19 16:51:13 2015 +0100

    greybus: gpio: remove unnecessary explicit cast
    
    Remove unnecessary explicit cast of line value.
    
    Signed-off-by: Johan Hovold <johan@hovoldconsulting.com>
    Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>

diff --git a/drivers/staging/greybus/gpio.c b/drivers/staging/greybus/gpio.c
index 8384ad17e9be..e0a871d37655 100644
--- a/drivers/staging/greybus/gpio.c
+++ b/drivers/staging/greybus/gpio.c
@@ -477,7 +477,7 @@ static int gb_gpio_get(struct gpio_chip *chip, unsigned offset)
 	ret = gb_gpio_get_value_operation(gb_gpio_controller, which);
 	if (ret)
 		return ret;
-	return (int)gb_gpio_controller->lines[which].value;
+	return gb_gpio_controller->lines[which].value;
 }
 
 static void gb_gpio_set(struct gpio_chip *chip, unsigned offset, int value)

commit 83d9cddb85a0cc7497012846567d16add52916d4
Author: Johan Hovold <johan@hovoldconsulting.com>
Date:   Thu Mar 19 16:51:12 2015 +0100

    greybus: gpio: remove overly defensive argument verification
    
    Remove overly defensive argument verification in gpio-chip callbacks. We
    should trust gpiolib to get this right (or we would not even get any
    callback) just like the other gpio drivers do.
    
    Signed-off-by: Johan Hovold <johan@hovoldconsulting.com>
    Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>

diff --git a/drivers/staging/greybus/gpio.c b/drivers/staging/greybus/gpio.c
index a1bf1430fced..8384ad17e9be 100644
--- a/drivers/staging/greybus/gpio.c
+++ b/drivers/staging/greybus/gpio.c
@@ -415,8 +415,6 @@ static int gb_gpio_request(struct gpio_chip *chip, unsigned offset)
 	struct gb_gpio_controller *gb_gpio_controller = gpio_chip_to_gb_gpio_controller(chip);
 	int ret;
 
-	if (offset >= chip->ngpio)
-		return -EINVAL;
 	ret = gb_gpio_activate_operation(gb_gpio_controller, (u8)offset);
 	if (ret)
 		;	/* return ret; */
@@ -428,11 +426,6 @@ static void gb_gpio_free(struct gpio_chip *chip, unsigned offset)
 	struct gb_gpio_controller *gb_gpio_controller = gpio_chip_to_gb_gpio_controller(chip);
 	int ret;
 
-	if (offset >= chip->ngpio) {
-		pr_err("bad offset %u supplied (must be 0..%u)\n",
-			offset, chip->ngpio - 1);
-		return;
-	}
 	ret = gb_gpio_deactivate_operation(gb_gpio_controller, (u8)offset);
 	if (ret)
 		;	/* return ret; */
@@ -444,8 +437,6 @@ static int gb_gpio_get_direction(struct gpio_chip *chip, unsigned offset)
 	u8 which;
 	int ret;
 
-	if (offset >= chip->ngpio)
-		return -EINVAL;
 	which = (u8)offset;
 	ret = gb_gpio_get_direction_operation(gb_gpio_controller, which);
 	if (ret)
@@ -458,8 +449,6 @@ static int gb_gpio_direction_input(struct gpio_chip *chip, unsigned offset)
 	struct gb_gpio_controller *gb_gpio_controller = gpio_chip_to_gb_gpio_controller(chip);
 	int ret;
 
-	if (offset >= chip->ngpio)
-		return -EINVAL;
 	ret = gb_gpio_direction_in_operation(gb_gpio_controller, (u8)offset);
 	if (ret)
 		;	/* return ret; */
@@ -472,8 +461,6 @@ static int gb_gpio_direction_output(struct gpio_chip *chip, unsigned offset,
 	struct gb_gpio_controller *gb_gpio_controller = gpio_chip_to_gb_gpio_controller(chip);
 	int ret;
 
-	if (offset >= chip->ngpio)
-		return -EINVAL;
 	ret = gb_gpio_direction_out_operation(gb_gpio_controller, (u8)offset, !!value);
 	if (ret)
 		;	/* return ret; */
@@ -486,8 +473,6 @@ static int gb_gpio_get(struct gpio_chip *chip, unsigned offset)
 	u8 which;
 	int ret;
 
-	if (offset >= chip->ngpio)
-		return -EINVAL;
 	which = (u8)offset;
 	ret = gb_gpio_get_value_operation(gb_gpio_controller, which);
 	if (ret)
@@ -500,11 +485,6 @@ static void gb_gpio_set(struct gpio_chip *chip, unsigned offset, int value)
 	struct gb_gpio_controller *gb_gpio_controller = gpio_chip_to_gb_gpio_controller(chip);
 	int ret;
 
-	if (offset < 0 || offset >= chip->ngpio) {
-		pr_err("bad offset %u supplied (must be 0..%u)\n",
-			offset, chip->ngpio - 1);
-		return;
-	}
 	ret = gb_gpio_set_value_operation(gb_gpio_controller, (u8)offset, !!value);
 	if (ret)
 		;	/* return ret; */
@@ -517,8 +497,6 @@ static int gb_gpio_set_debounce(struct gpio_chip *chip, unsigned offset,
 	u16 usec;
 	int ret;
 
-	if (offset >= chip->ngpio)
-		return -EINVAL;
 	if (debounce > U16_MAX)
 		return -EINVAL;
 	usec = (u16)debounce;

commit 65f5a5f1614d1a3dab375588f5fd03590c87215b
Author: Johan Hovold <johan@hovoldconsulting.com>
Date:   Thu Mar 19 16:51:11 2015 +0100

    greybus: gpio: remove redundant argument verification
    
    Remove redundant verification of gpio numbers (which have already been
    verified in the gpio-chip callbacks) from greybus-operation helpers.
    
    Signed-off-by: Johan Hovold <johan@hovoldconsulting.com>
    Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>

diff --git a/drivers/staging/greybus/gpio.c b/drivers/staging/greybus/gpio.c
index 6a493d4758b4..a1bf1430fced 100644
--- a/drivers/staging/greybus/gpio.c
+++ b/drivers/staging/greybus/gpio.c
@@ -167,9 +167,6 @@ static int gb_gpio_activate_operation(struct gb_gpio_controller *ggc, u8 which)
 	struct gb_gpio_activate_request request;
 	int ret;
 
-	if (which > ggc->line_max)
-		return -EINVAL;
-
 	request.which = which;
 	ret = gb_operation_sync(ggc->connection, GB_GPIO_TYPE_ACTIVATE,
 				 &request, sizeof(request), NULL, 0);
@@ -184,9 +181,6 @@ static int gb_gpio_deactivate_operation(struct gb_gpio_controller *ggc,
 	struct gb_gpio_deactivate_request request;
 	int ret;
 
-	if (which > ggc->line_max)
-		return -EINVAL;
-
 	request.which = which;
 	ret = gb_operation_sync(ggc->connection, GB_GPIO_TYPE_DEACTIVATE,
 				 &request, sizeof(request), NULL, 0);
@@ -203,9 +197,6 @@ static int gb_gpio_get_direction_operation(struct gb_gpio_controller *ggc,
 	int ret;
 	u8 direction;
 
-	if (which > ggc->line_max)
-		return -EINVAL;
-
 	request.which = which;
 	ret = gb_operation_sync(ggc->connection, GB_GPIO_TYPE_GET_DIRECTION,
 				&request, sizeof(request),
@@ -227,9 +218,6 @@ static int gb_gpio_direction_in_operation(struct gb_gpio_controller *ggc,
 	struct gb_gpio_direction_in_request request;
 	int ret;
 
-	if (which > ggc->line_max)
-		return -EINVAL;
-
 	request.which = which;
 	ret = gb_operation_sync(ggc->connection, GB_GPIO_TYPE_DIRECTION_IN,
 				&request, sizeof(request), NULL, 0);
@@ -244,9 +232,6 @@ static int gb_gpio_direction_out_operation(struct gb_gpio_controller *ggc,
 	struct gb_gpio_direction_out_request request;
 	int ret;
 
-	if (which > ggc->line_max)
-		return -EINVAL;
-
 	request.which = which;
 	request.value = value_high ? 1 : 0;
 	ret = gb_operation_sync(ggc->connection, GB_GPIO_TYPE_DIRECTION_OUT,
@@ -264,9 +249,6 @@ static int gb_gpio_get_value_operation(struct gb_gpio_controller *ggc,
 	int ret;
 	u8 value;
 
-	if (which > ggc->line_max)
-		return -EINVAL;
-
 	request.which = which;
 	ret = gb_operation_sync(ggc->connection, GB_GPIO_TYPE_GET_VALUE,
 				&request, sizeof(request),
@@ -288,9 +270,6 @@ static int gb_gpio_set_value_operation(struct gb_gpio_controller *ggc,
 	struct gb_gpio_set_value_request request;
 	int ret;
 
-	if (which > ggc->line_max)
-		return -EINVAL;
-
 	request.which = which;
 	request.value = value_high ? 1 : 0;
 	ret = gb_operation_sync(ggc->connection, GB_GPIO_TYPE_SET_VALUE,
@@ -308,9 +287,6 @@ static int gb_gpio_set_debounce_operation(struct gb_gpio_controller *ggc,
 	struct gb_gpio_set_debounce_request request;
 	int ret;
 
-	if (which > ggc->line_max)
-		return -EINVAL;
-
 	request.which = which;
 	request.usec = cpu_to_le16(debounce_usec);
 	ret = gb_operation_sync(ggc->connection, GB_GPIO_TYPE_SET_DEBOUNCE,

commit 56c2da1873d68b96458064a306e5bb4c50ccdb5d
Author: Johan Hovold <johan@hovoldconsulting.com>
Date:   Thu Mar 19 16:51:10 2015 +0100

    greybus: gpio: remove incorrect todo comments
    
    The module reference count is incremented by gpiolib when a gpio is
    requested, and the driver callbacks certainly do sleep.
    
    Signed-off-by: Johan Hovold <johan@hovoldconsulting.com>
    Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>

diff --git a/drivers/staging/greybus/gpio.c b/drivers/staging/greybus/gpio.c
index f75dd40033af..6a493d4758b4 100644
--- a/drivers/staging/greybus/gpio.c
+++ b/drivers/staging/greybus/gpio.c
@@ -747,7 +747,7 @@ static int gb_gpio_connection_init(struct gb_connection *connection)
 
 	gpio->label = "greybus_gpio";
 	gpio->dev = &connection->dev;
-	gpio->owner = THIS_MODULE;	/* XXX Module get? */
+	gpio->owner = THIS_MODULE;
 
 	gpio->request = gb_gpio_request;
 	gpio->free = gb_gpio_free;
@@ -761,7 +761,7 @@ static int gb_gpio_connection_init(struct gb_connection *connection)
 	gpio->to_irq = gb_gpio_to_irq;
 	gpio->base = -1;		/* Allocate base dynamically */
 	gpio->ngpio = gb_gpio_controller->line_max + 1;
-	gpio->can_sleep = true;		/* XXX */
+	gpio->can_sleep = true;
 
 	ret = gpiochip_add(gpio);
 	if (ret) {

commit c2a66106867343b5c5f017ccc724ba1c1aa9b540
Author: Johan Hovold <johan@hovoldconsulting.com>
Date:   Thu Mar 19 16:51:09 2015 +0100

    greybus: gpio: fix truncated debounce times
    
    Fix set_debounce, which silently truncated the time argument to 255us
    even though we support 16-bit values.
    
    Also remove the unnecessary explicit cast when verifying the argument.
    
    Signed-off-by: Johan Hovold <johan@hovoldconsulting.com>
    Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>

diff --git a/drivers/staging/greybus/gpio.c b/drivers/staging/greybus/gpio.c
index 458565a7afb8..f75dd40033af 100644
--- a/drivers/staging/greybus/gpio.c
+++ b/drivers/staging/greybus/gpio.c
@@ -543,9 +543,9 @@ static int gb_gpio_set_debounce(struct gpio_chip *chip, unsigned offset,
 
 	if (offset >= chip->ngpio)
 		return -EINVAL;
-	if (debounce > (unsigned int)U16_MAX)
+	if (debounce > U16_MAX)
 		return -EINVAL;
-	usec = (u8)debounce;
+	usec = (u16)debounce;
 	ret = gb_gpio_set_debounce_operation(gb_gpio_controller, (u8)offset, usec);
 	if (ret)
 		;	/* return ret; */

commit fcc4356de4601c83530928e05b041e4ac678fd6a
Author: Johan Hovold <johan@hovoldconsulting.com>
Date:   Tue Mar 17 18:24:28 2015 +0100

    greybus: gpio: fix set-debounce request alignment
    
    Fix alignment of the usec-field in the set-debounce request, which
    should follow the which-field without any inserted padding.
    
    Signed-off-by: Johan Hovold <johan@hovoldconsulting.com>
    Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>

diff --git a/drivers/staging/greybus/gpio.c b/drivers/staging/greybus/gpio.c
index 4af5050edea0..458565a7afb8 100644
--- a/drivers/staging/greybus/gpio.c
+++ b/drivers/staging/greybus/gpio.c
@@ -116,7 +116,7 @@ struct gb_gpio_set_value_request {
 
 struct gb_gpio_set_debounce_request {
 	__u8	which;
-	__le16	usec;
+	__le16	usec __packed;
 };
 /* debounce response has no payload */
 

commit d1b20d72ae01a2846ed4cad7bfef0bea717ffb68
Author: Alexandre Bailon <abailon@baylibre.com>
Date:   Mon Mar 2 17:32:43 2015 +0100

    greybus: gpio.c: fix a bad irq number
    
    When it receive an interrupt, the function gb_gpio_request_recv doesn't
    use the good gpio number to get the irq number. Then, the expected irq is never fired.
    
    Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>

diff --git a/drivers/staging/greybus/gpio.c b/drivers/staging/greybus/gpio.c
index 81901bdd9477..4af5050edea0 100644
--- a/drivers/staging/greybus/gpio.c
+++ b/drivers/staging/greybus/gpio.c
@@ -421,7 +421,7 @@ static void gb_gpio_request_recv(u8 type, struct gb_operation *op)
 		pr_err("Unsupported hw irq %d\n", event->which);
 		return;
 	}
-	irq = gpio_to_irq(ggc->irq_base + event->which);
+	irq = gpio_to_irq(ggc->chip.base + event->which);
 	desc = irq_to_desc(irq);
 
 	/* Dispatch interrupt */

commit 35a64f2c492867e5e404b7620c5784603caae8f1
Author: Johan Hovold <johan@hovoldconsulting.com>
Date:   Fri Feb 13 14:58:04 2015 +0800

    greybus: gpio: fix memory leaks at init and exit
    
    Fix three related memory leaks in the init an exit callbacks, where the
    gpio-lines array was never freed at all and the controller data wasn't
    freed in the init error path.
    
    Signed-off-by: Johan Hovold <johan@hovoldconsulting.com>
    Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>

diff --git a/drivers/staging/greybus/gpio.c b/drivers/staging/greybus/gpio.c
index a55327c17c79..81901bdd9477 100644
--- a/drivers/staging/greybus/gpio.c
+++ b/drivers/staging/greybus/gpio.c
@@ -734,7 +734,7 @@ static int gb_gpio_connection_init(struct gb_connection *connection)
 
 	ret = gb_gpio_controller_setup(gb_gpio_controller);
 	if (ret)
-		goto out_err;
+		goto err_free_controller;
 
 	irqc = &gb_gpio_controller->irqc;
 	irqc->irq_ack = gb_gpio_ack_irq;
@@ -766,7 +766,7 @@ static int gb_gpio_connection_init(struct gb_connection *connection)
 	ret = gpiochip_add(gpio);
 	if (ret) {
 		pr_err("Failed to register GPIO\n");
-		goto out_err;
+		goto err_free_lines;
 	}
 
 	ret = gb_gpio_irqchip_add(gpio, irqc, 0,
@@ -780,7 +780,9 @@ static int gb_gpio_connection_init(struct gb_connection *connection)
 
 irqchip_err:
 	gb_gpiochip_remove(gpio);
-out_err:
+err_free_lines:
+	kfree(gb_gpio_controller->lines);
+err_free_controller:
 	kfree(gb_gpio_controller);
 	return ret;
 }
@@ -795,6 +797,7 @@ static void gb_gpio_connection_exit(struct gb_connection *connection)
 	gb_gpio_irqchip_remove(gb_gpio_controller);
 	gb_gpiochip_remove(&gb_gpio_controller->chip);
 	/* kref_put(gb_gpio_controller->connection) */
+	kfree(gb_gpio_controller->lines);
 	kfree(gb_gpio_controller);
 }
 

commit 036aad9d0224f6f29c08abe102df709a27f68c17
Author: Matt Porter <mporter@linaro.org>
Date:   Tue Feb 17 10:48:23 2015 -0500

    greybus: gpio: add interrupt handling support
    
    Adds gpio interrupt handling support using an irqchip/irqdomain
    instantiation inside the GB GPIO driver. This implementation works
    on older kernels such as 3.10 that do not have the gpiolib irqchip
    helpers. Any line on a Greybus gpiochip may be configured as an
    interrupt. Once configured, IRQ event messages received from a
    module fire off the registered interrupt handler.
    
    Signed-off-by: Matt Porter <mporter@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>

diff --git a/drivers/staging/greybus/gpio.c b/drivers/staging/greybus/gpio.c
index 85d89b86d5f7..a55327c17c79 100644
--- a/drivers/staging/greybus/gpio.c
+++ b/drivers/staging/greybus/gpio.c
@@ -11,6 +11,8 @@
 #include <linux/module.h>
 #include <linux/slab.h>
 #include <linux/gpio.h>
+#include <linux/irq.h>
+#include <linux/irqdomain.h>
 #include "greybus.h"
 
 struct gb_gpio_line {
@@ -30,9 +32,16 @@ struct gb_gpio_controller {
 	struct gb_gpio_line	*lines;
 
 	struct gpio_chip	chip;
+	struct irq_chip		irqc;
+	struct irq_chip		*irqchip;
+	struct irq_domain	*irqdomain;
+	unsigned int		irq_base;
+	irq_flow_handler_t	irq_handler;
+	unsigned int		irq_default_type;
 };
 #define gpio_chip_to_gb_gpio_controller(chip) \
 	container_of(chip, struct gb_gpio_controller, chip)
+#define irq_data_to_gpio_chip(d) (d->domain->host_data)
 
 /* Version of the Greybus GPIO protocol we support */
 #define	GB_GPIO_VERSION_MAJOR		0x00
@@ -50,6 +59,11 @@ struct gb_gpio_controller {
 #define	GB_GPIO_TYPE_GET_VALUE		0x08
 #define	GB_GPIO_TYPE_SET_VALUE		0x09
 #define	GB_GPIO_TYPE_SET_DEBOUNCE	0x0a
+#define GB_GPIO_TYPE_IRQ_TYPE		0x0b
+#define GB_GPIO_TYPE_IRQ_ACK		0x0c
+#define GB_GPIO_TYPE_IRQ_MASK		0x0d
+#define GB_GPIO_TYPE_IRQ_UNMASK		0x0e
+#define GB_GPIO_TYPE_IRQ_EVENT		0x0f
 #define	GB_GPIO_TYPE_RESPONSE		0x80	/* OR'd with rest */
 
 #define	GB_GPIO_DEBOUNCE_USEC_DEFAULT	0	/* microseconds */
@@ -106,6 +120,32 @@ struct gb_gpio_set_debounce_request {
 };
 /* debounce response has no payload */
 
+struct gb_gpio_irq_type_request {
+	__u8	which;
+	__u8	type;
+};
+/* irq type response has no payload */
+
+struct gb_gpio_irq_mask_request {
+	__u8	which;
+};
+/* irq mask response has no payload */
+
+struct gb_gpio_irq_unmask_request {
+	__u8	which;
+};
+/* irq unmask response has no payload */
+
+struct gb_gpio_irq_ack_request {
+	__u8	which;
+};
+/* irq ack response has no payload */
+
+/* irq event requests originate on another module and are handled on the AP */
+struct gb_gpio_irq_event_request {
+	__u8	which;
+};
+/* irq event response has no payload */
 
 /* Define get_version() routine */
 define_get_version(gb_gpio_controller, GPIO);
@@ -280,6 +320,120 @@ static int gb_gpio_set_debounce_operation(struct gb_gpio_controller *ggc,
 	return ret;
 }
 
+static void gb_gpio_ack_irq(struct irq_data *d)
+{
+	struct gpio_chip *chip = irq_data_to_gpio_chip(d);
+	struct gb_gpio_controller *ggc = gpio_chip_to_gb_gpio_controller(chip);
+	struct gb_gpio_irq_ack_request request;
+	int ret;
+
+	request.which = d->hwirq;
+	ret = gb_operation_sync(ggc->connection,
+				GB_GPIO_TYPE_IRQ_ACK,
+				&request, sizeof(request), NULL, 0);
+	if (ret)
+		pr_err("irq ack operation failed (%d)\n", ret);
+}
+
+static void gb_gpio_mask_irq(struct irq_data *d)
+{
+	struct gpio_chip *chip = irq_data_to_gpio_chip(d);
+	struct gb_gpio_controller *ggc = gpio_chip_to_gb_gpio_controller(chip);
+	struct gb_gpio_irq_mask_request request;
+	int ret;
+
+	request.which = d->hwirq;
+	ret = gb_operation_sync(ggc->connection,
+				GB_GPIO_TYPE_IRQ_MASK,
+				&request, sizeof(request), NULL, 0);
+	if (ret)
+		pr_err("irq mask operation failed (%d)\n", ret);
+}
+
+static void gb_gpio_unmask_irq(struct irq_data *d)
+{
+	struct gpio_chip *chip = irq_data_to_gpio_chip(d);
+	struct gb_gpio_controller *ggc = gpio_chip_to_gb_gpio_controller(chip);
+	struct gb_gpio_irq_unmask_request request;
+	int ret;
+
+	request.which = d->hwirq;
+	ret = gb_operation_sync(ggc->connection,
+				GB_GPIO_TYPE_IRQ_UNMASK,
+				&request, sizeof(request), NULL, 0);
+	if (ret)
+		pr_err("irq unmask operation failed (%d)\n", ret);
+}
+
+static int gb_gpio_irq_set_type(struct irq_data *d, unsigned int type)
+{
+	struct gpio_chip *chip = irq_data_to_gpio_chip(d);
+	struct gb_gpio_controller *ggc = gpio_chip_to_gb_gpio_controller(chip);
+	struct gb_gpio_irq_type_request request;
+	int ret = 0;
+
+	request.which = d->hwirq;
+	request.type = type;
+
+	switch (type) {
+	case IRQ_TYPE_NONE:
+		break;
+	case IRQ_TYPE_EDGE_RISING:
+	case IRQ_TYPE_EDGE_FALLING:
+	case IRQ_TYPE_EDGE_BOTH:
+	case IRQ_TYPE_LEVEL_LOW:
+	case IRQ_TYPE_LEVEL_HIGH:
+		ret = gb_operation_sync(ggc->connection,
+					GB_GPIO_TYPE_IRQ_TYPE,
+					&request, sizeof(request), NULL, 0);
+		if (ret)
+			pr_err("irq type operation failed (%d)\n", ret);
+                break;
+	default:
+		pr_err("No such irq type %d", type);
+		ret = -EINVAL;
+	}
+
+	return ret;
+}
+
+static void gb_gpio_request_recv(u8 type, struct gb_operation *op)
+{
+	struct gb_gpio_controller *ggc;
+	struct gb_connection *connection;
+	struct gb_message *request;
+	struct gb_gpio_irq_event_request *event;
+	int irq;
+	struct irq_desc *desc;
+	int ret;
+
+	if (type != GB_GPIO_TYPE_IRQ_EVENT) {
+		pr_err("unsupported unsolicited request\n");
+		return;
+	}
+
+	connection = op->connection;
+	ggc = connection->private;
+
+	request = op->request;
+	event = request->payload;
+	if (event->which > ggc->line_max) {
+		pr_err("Unsupported hw irq %d\n", event->which);
+		return;
+	}
+	irq = gpio_to_irq(ggc->irq_base + event->which);
+	desc = irq_to_desc(irq);
+
+	/* Dispatch interrupt */
+	local_irq_disable();
+	handle_simple_irq(irq, desc);
+	local_irq_enable();
+
+	ret = gb_operation_response_send(op, 0);
+	if (ret)
+		pr_err("error %d sending response status %d\n", ret, 0);
+}
+
 static int gb_gpio_request(struct gpio_chip *chip, unsigned offset)
 {
 	struct gb_gpio_controller *gb_gpio_controller = gpio_chip_to_gb_gpio_controller(chip);
@@ -399,14 +553,6 @@ static int gb_gpio_set_debounce(struct gpio_chip *chip, unsigned offset,
 	return 0;	/* XXX */
 }
 
-static int gb_gpio_to_irq(struct gpio_chip *chip, unsigned offset)
-{
-	if (offset >= chip->ngpio)
-		return -EINVAL;
-
-	return 0;	/* XXX */
-}
-
 static void gb_gpio_dbg_show(struct seq_file *s, struct gpio_chip *chip)
 {
 	return;	/* XXX */
@@ -436,10 +582,148 @@ static int gb_gpio_controller_setup(struct gb_gpio_controller *gb_gpio_controlle
 	return ret;
 }
 
+/**
+ * gb_gpio_irq_map() - maps an IRQ into a GB gpio irqchip
+ * @d: the irqdomain used by this irqchip
+ * @irq: the global irq number used by this GB gpio irqchip irq
+ * @hwirq: the local IRQ/GPIO line offset on this GB gpio
+ *
+ * This function will set up the mapping for a certain IRQ line on a
+ * GB gpio by assigning the GB gpio as chip data, and using the irqchip
+ * stored inside the GB gpio.
+ */
+static int gb_gpio_irq_map(struct irq_domain *domain, unsigned int irq,
+			   irq_hw_number_t hwirq)
+{
+	struct gpio_chip *chip = domain->host_data;
+	struct gb_gpio_controller *ggc = gpio_chip_to_gb_gpio_controller(chip);
+
+	irq_set_chip_data(irq, ggc);
+	irq_set_chip_and_handler(irq, ggc->irqchip, ggc->irq_handler);
+#ifdef CONFIG_ARM
+	set_irq_flags(irq, IRQF_VALID);
+#else
+	irq_set_noprobe(irq);
+#endif
+	/*
+	 * No set-up of the hardware will happen if IRQ_TYPE_NONE
+	 * is passed as default type.
+	 */
+	if (ggc->irq_default_type != IRQ_TYPE_NONE)
+		irq_set_irq_type(irq, ggc->irq_default_type);
+
+	return 0;
+}
+
+static void gb_gpio_irq_unmap(struct irq_domain *d, unsigned int irq)
+{
+#ifdef CONFIG_ARM
+	set_irq_flags(irq, 0);
+#endif
+	irq_set_chip_and_handler(irq, NULL, NULL);
+	irq_set_chip_data(irq, NULL);
+}
+
+static const struct irq_domain_ops gb_gpio_domain_ops = {
+	.map	= gb_gpio_irq_map,
+	.unmap	= gb_gpio_irq_unmap,
+};
+
+/**
+ * gb_gpio_irqchip_remove() - removes an irqchip added to a gb_gpio_controller
+ * @ggc: the gb_gpio_controller to remove the irqchip from
+ *
+ * This is called only from gb_gpio_remove()
+ */
+static void gb_gpio_irqchip_remove(struct gb_gpio_controller *ggc)
+{
+	unsigned int offset;
+
+	/* Remove all IRQ mappings and delete the domain */
+	if (ggc->irqdomain) {
+		for (offset = 0; offset < (ggc->line_max + 1); offset++)
+			irq_dispose_mapping(irq_find_mapping(ggc->irqdomain, offset));
+		irq_domain_remove(ggc->irqdomain);
+	}
+
+	if (ggc->irqchip) {
+		ggc->irqchip = NULL;
+	}
+}
+
+
+/**
+ * gb_gpio_irqchip_add() - adds an irqchip to a gpio chip
+ * @chip: the gpio chip to add the irqchip to
+ * @irqchip: the irqchip to add to the adapter
+ * @first_irq: if not dynamically assigned, the base (first) IRQ to
+ * allocate gpio irqs from
+ * @handler: the irq handler to use (often a predefined irq core function)
+ * @type: the default type for IRQs on this irqchip, pass IRQ_TYPE_NONE
+ * to have the core avoid setting up any default type in the hardware.
+ *
+ * This function closely associates a certain irqchip with a certain
+ * gpio chip, providing an irq domain to translate the local IRQs to
+ * global irqs, and making sure that the gpio chip
+ * is passed as chip data to all related functions. Driver callbacks
+ * need to use container_of() to get their local state containers back
+ * from the gpio chip passed as chip data. An irqdomain will be stored
+ * in the gpio chip that shall be used by the driver to handle IRQ number
+ * translation. The gpio chip will need to be initialized and registered
+ * before calling this function.
+ */
+static int gb_gpio_irqchip_add(struct gpio_chip *chip,
+			 struct irq_chip *irqchip,
+			 unsigned int first_irq,
+			 irq_flow_handler_t handler,
+			 unsigned int type)
+{
+	struct gb_gpio_controller *ggc;
+	unsigned int offset;
+	unsigned irq_base;
+
+	if (!chip || !irqchip)
+		return -EINVAL;
+
+	ggc = gpio_chip_to_gb_gpio_controller(chip);
+
+	ggc->irqchip = irqchip;
+	ggc->irq_handler = handler;
+	ggc->irq_default_type = type;
+	ggc->irqdomain = irq_domain_add_simple(NULL,
+					ggc->line_max + 1, first_irq,
+					&gb_gpio_domain_ops, chip);
+	if (!ggc->irqdomain) {
+		ggc->irqchip = NULL;
+		return -EINVAL;
+	}
+
+	/*
+	 * Prepare the mapping since the irqchip shall be orthogonal to
+	 * any gpio calls. If the first_irq was zero, this is
+	 * necessary to allocate descriptors for all IRQs.
+	 */
+	for (offset = 0; offset < (ggc->line_max + 1); offset++) {
+		irq_base = irq_create_mapping(ggc->irqdomain, offset);
+		if (offset == 0)
+			ggc->irq_base = irq_base;
+	}
+
+	return 0;
+}
+
+static int gb_gpio_to_irq(struct gpio_chip *chip, unsigned offset)
+{
+	struct gb_gpio_controller *ggc = gpio_chip_to_gb_gpio_controller(chip);
+
+	return irq_find_mapping(ggc->irqdomain, offset);
+}
+
 static int gb_gpio_connection_init(struct gb_connection *connection)
 {
 	struct gb_gpio_controller *gb_gpio_controller;
 	struct gpio_chip *gpio;
+	struct irq_chip *irqc;
 	int ret;
 
 	gb_gpio_controller = kzalloc(sizeof(*gb_gpio_controller), GFP_KERNEL);
@@ -452,9 +736,17 @@ static int gb_gpio_connection_init(struct gb_connection *connection)
 	if (ret)
 		goto out_err;
 
+	irqc = &gb_gpio_controller->irqc;
+	irqc->irq_ack = gb_gpio_ack_irq;
+	irqc->irq_mask = gb_gpio_mask_irq;
+	irqc->irq_unmask = gb_gpio_unmask_irq;
+	irqc->irq_set_type = gb_gpio_irq_set_type;
+	irqc->name = "greybus_gpio";
+
 	gpio = &gb_gpio_controller->chip;
 
 	gpio->label = "greybus_gpio";
+	gpio->dev = &connection->dev;
 	gpio->owner = THIS_MODULE;	/* XXX Module get? */
 
 	gpio->request = gb_gpio_request;
@@ -465,9 +757,8 @@ static int gb_gpio_connection_init(struct gb_connection *connection)
 	gpio->get = gb_gpio_get;
 	gpio->set = gb_gpio_set;
 	gpio->set_debounce = gb_gpio_set_debounce;
-	gpio->to_irq = gb_gpio_to_irq;
 	gpio->dbg_show = gb_gpio_dbg_show;
-
+	gpio->to_irq = gb_gpio_to_irq;
 	gpio->base = -1;		/* Allocate base dynamically */
 	gpio->ngpio = gb_gpio_controller->line_max + 1;
 	gpio->can_sleep = true;		/* XXX */
@@ -475,10 +766,20 @@ static int gb_gpio_connection_init(struct gb_connection *connection)
 	ret = gpiochip_add(gpio);
 	if (ret) {
 		pr_err("Failed to register GPIO\n");
-		return ret;
+		goto out_err;
+	}
+
+	ret = gb_gpio_irqchip_add(gpio, irqc, 0,
+				   handle_simple_irq, IRQ_TYPE_NONE);
+	if (ret) {
+		pr_err("Couldn't add irqchip to Greybus GPIO controller %d\n", ret);
+		goto irqchip_err;
 	}
 
 	return 0;
+
+irqchip_err:
+	gb_gpiochip_remove(gpio);
 out_err:
 	kfree(gb_gpio_controller);
 	return ret;
@@ -491,6 +792,7 @@ static void gb_gpio_connection_exit(struct gb_connection *connection)
 	if (!gb_gpio_controller)
 		return;
 
+	gb_gpio_irqchip_remove(gb_gpio_controller);
 	gb_gpiochip_remove(&gb_gpio_controller->chip);
 	/* kref_put(gb_gpio_controller->connection) */
 	kfree(gb_gpio_controller);
@@ -503,7 +805,7 @@ static struct gb_protocol gpio_protocol = {
 	.minor			= 1,
 	.connection_init	= gb_gpio_connection_init,
 	.connection_exit	= gb_gpio_connection_exit,
-	.request_recv		= NULL,	/* no incoming requests */
+	.request_recv		= gb_gpio_request_recv,
 };
 
 int gb_gpio_protocol_init(void)

commit 89210f64bae6bd6bba90d9e08d1b88b4ba103f59
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Wed Jan 21 18:12:37 2015 +0530

    greybus: remove unused version-response structs
    
    These aren't used anymore and so can be removed.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Reviewed-by: Alex Elder <elder@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>

diff --git a/drivers/staging/greybus/gpio.c b/drivers/staging/greybus/gpio.c
index a93583341811..85d89b86d5f7 100644
--- a/drivers/staging/greybus/gpio.c
+++ b/drivers/staging/greybus/gpio.c
@@ -54,12 +54,6 @@ struct gb_gpio_controller {
 
 #define	GB_GPIO_DEBOUNCE_USEC_DEFAULT	0	/* microseconds */
 
-/* version request has no payload */
-struct gb_gpio_proto_version_response {
-	__u8	major;
-	__u8	minor;
-};
-
 /* line count request has no payload */
 struct gb_gpio_line_count_response {
 	__u8	count;

commit 36e79dec96f652110ae2b06bfcf9e67e1b770787
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Wed Jan 21 18:12:36 2015 +0530

    greybus: create get_version() routines with the help of a macro
    
    This gets rid of lots of duplication of code.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Reviewed-by: Alex Elder <elder@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>

diff --git a/drivers/staging/greybus/gpio.c b/drivers/staging/greybus/gpio.c
index 4997588e2617..a93583341811 100644
--- a/drivers/staging/greybus/gpio.c
+++ b/drivers/staging/greybus/gpio.c
@@ -113,29 +113,8 @@ struct gb_gpio_set_debounce_request {
 /* debounce response has no payload */
 
 
-/*
- * This request only uses the connection field, and if successful,
- * fills in the major and minor protocol version of the target.
- */
-static int gb_gpio_proto_version_operation(struct gb_gpio_controller *ggc)
-{
-	struct gb_gpio_proto_version_response response;
-	int ret;
-
-	ret = gb_operation_sync(ggc->connection, GB_GPIO_TYPE_PROTOCOL_VERSION,
-				NULL, 0, &response, sizeof(response));
-	if (ret)
-		return ret;
-
-	if (response.major > GB_GPIO_VERSION_MAJOR) {
-		pr_err("unsupported major version (%hhu > %hhu)\n",
-			response.major, GB_GPIO_VERSION_MAJOR);
-		return -ENOTSUPP;
-	}
-	ggc->version_major = response.major;
-	ggc->version_minor = response.minor;
-	return 0;
-}
+/* Define get_version() routine */
+define_get_version(gb_gpio_controller, GPIO);
 
 static int gb_gpio_line_count_operation(struct gb_gpio_controller *ggc)
 {
@@ -446,7 +425,7 @@ static int gb_gpio_controller_setup(struct gb_gpio_controller *gb_gpio_controlle
 	int ret;
 
 	/* First thing we need to do is check the version */
-	ret = gb_gpio_proto_version_operation(gb_gpio_controller);
+	ret = get_version(gb_gpio_controller);
 	if (ret)
 		;	/* return ret; */
 

commit 5357cf323110ee4a3f4a12870618eca28672c7b9
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Wed Jan 21 16:10:40 2015 +0530

    greybus: Remove "-gb" suffix from .c files
    
    Some files are prefixed with "gb-" and some are suffixed with "-gb". The
    rationale behind the first one is that the modules would be named so, i.e.
    gb-*.ko. But there is no reason to keep the "-gb" suffix in the second case.
    
    Remove the unnecessary suffix.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Reviewed-by: Alex Elder <elder@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>

diff --git a/drivers/staging/greybus/gpio.c b/drivers/staging/greybus/gpio.c
new file mode 100644
index 000000000000..4997588e2617
--- /dev/null
+++ b/drivers/staging/greybus/gpio.c
@@ -0,0 +1,544 @@
+/*
+ * GPIO Greybus driver.
+ *
+ * Copyright 2014 Google Inc.
+ * Copyright 2014 Linaro Ltd.
+ *
+ * Released under the GPLv2 only.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/gpio.h>
+#include "greybus.h"
+
+struct gb_gpio_line {
+	/* The following has to be an array of line_max entries */
+	/* --> make them just a flags field */
+	u8			active:    1,
+				direction: 1,	/* 0 = output, 1 = input */
+				value:     1;	/* 0 = low, 1 = high */
+	u16			debounce_usec;
+};
+
+struct gb_gpio_controller {
+	struct gb_connection	*connection;
+	u8			version_major;
+	u8			version_minor;
+	u8			line_max;	/* max line number */
+	struct gb_gpio_line	*lines;
+
+	struct gpio_chip	chip;
+};
+#define gpio_chip_to_gb_gpio_controller(chip) \
+	container_of(chip, struct gb_gpio_controller, chip)
+
+/* Version of the Greybus GPIO protocol we support */
+#define	GB_GPIO_VERSION_MAJOR		0x00
+#define	GB_GPIO_VERSION_MINOR		0x01
+
+/* Greybus GPIO request types */
+#define	GB_GPIO_TYPE_INVALID		0x00
+#define	GB_GPIO_TYPE_PROTOCOL_VERSION	0x01
+#define	GB_GPIO_TYPE_LINE_COUNT		0x02
+#define	GB_GPIO_TYPE_ACTIVATE		0x03
+#define	GB_GPIO_TYPE_DEACTIVATE		0x04
+#define	GB_GPIO_TYPE_GET_DIRECTION	0x05
+#define	GB_GPIO_TYPE_DIRECTION_IN	0x06
+#define	GB_GPIO_TYPE_DIRECTION_OUT	0x07
+#define	GB_GPIO_TYPE_GET_VALUE		0x08
+#define	GB_GPIO_TYPE_SET_VALUE		0x09
+#define	GB_GPIO_TYPE_SET_DEBOUNCE	0x0a
+#define	GB_GPIO_TYPE_RESPONSE		0x80	/* OR'd with rest */
+
+#define	GB_GPIO_DEBOUNCE_USEC_DEFAULT	0	/* microseconds */
+
+/* version request has no payload */
+struct gb_gpio_proto_version_response {
+	__u8	major;
+	__u8	minor;
+};
+
+/* line count request has no payload */
+struct gb_gpio_line_count_response {
+	__u8	count;
+};
+
+struct gb_gpio_activate_request {
+	__u8	which;
+};
+/* activate response has no payload */
+
+struct gb_gpio_deactivate_request {
+	__u8	which;
+};
+/* deactivate response has no payload */
+
+struct gb_gpio_get_direction_request {
+	__u8	which;
+};
+struct gb_gpio_get_direction_response {
+	__u8	direction;
+};
+
+struct gb_gpio_direction_in_request {
+	__u8	which;
+};
+/* direction in response has no payload */
+
+struct gb_gpio_direction_out_request {
+	__u8	which;
+	__u8	value;
+};
+/* direction out response has no payload */
+
+struct gb_gpio_get_value_request {
+	__u8	which;
+};
+struct gb_gpio_get_value_response {
+	__u8	value;
+};
+
+struct gb_gpio_set_value_request {
+	__u8	which;
+	__u8	value;
+};
+/* set value response has no payload */
+
+struct gb_gpio_set_debounce_request {
+	__u8	which;
+	__le16	usec;
+};
+/* debounce response has no payload */
+
+
+/*
+ * This request only uses the connection field, and if successful,
+ * fills in the major and minor protocol version of the target.
+ */
+static int gb_gpio_proto_version_operation(struct gb_gpio_controller *ggc)
+{
+	struct gb_gpio_proto_version_response response;
+	int ret;
+
+	ret = gb_operation_sync(ggc->connection, GB_GPIO_TYPE_PROTOCOL_VERSION,
+				NULL, 0, &response, sizeof(response));
+	if (ret)
+		return ret;
+
+	if (response.major > GB_GPIO_VERSION_MAJOR) {
+		pr_err("unsupported major version (%hhu > %hhu)\n",
+			response.major, GB_GPIO_VERSION_MAJOR);
+		return -ENOTSUPP;
+	}
+	ggc->version_major = response.major;
+	ggc->version_minor = response.minor;
+	return 0;
+}
+
+static int gb_gpio_line_count_operation(struct gb_gpio_controller *ggc)
+{
+	struct gb_gpio_line_count_response response;
+	int ret;
+
+	ret = gb_operation_sync(ggc->connection, GB_GPIO_TYPE_LINE_COUNT,
+				NULL, 0, &response, sizeof(response));
+	if (!ret)
+		ggc->line_max = response.count;
+	return ret;
+}
+
+static int gb_gpio_activate_operation(struct gb_gpio_controller *ggc, u8 which)
+{
+	struct gb_gpio_activate_request request;
+	int ret;
+
+	if (which > ggc->line_max)
+		return -EINVAL;
+
+	request.which = which;
+	ret = gb_operation_sync(ggc->connection, GB_GPIO_TYPE_ACTIVATE,
+				 &request, sizeof(request), NULL, 0);
+	if (!ret)
+		ggc->lines[which].active = true;
+	return ret;
+}
+
+static int gb_gpio_deactivate_operation(struct gb_gpio_controller *ggc,
+					u8 which)
+{
+	struct gb_gpio_deactivate_request request;
+	int ret;
+
+	if (which > ggc->line_max)
+		return -EINVAL;
+
+	request.which = which;
+	ret = gb_operation_sync(ggc->connection, GB_GPIO_TYPE_DEACTIVATE,
+				 &request, sizeof(request), NULL, 0);
+	if (!ret)
+		ggc->lines[which].active = false;
+	return ret;
+}
+
+static int gb_gpio_get_direction_operation(struct gb_gpio_controller *ggc,
+					u8 which)
+{
+	struct gb_gpio_get_direction_request request;
+	struct gb_gpio_get_direction_response response;
+	int ret;
+	u8 direction;
+
+	if (which > ggc->line_max)
+		return -EINVAL;
+
+	request.which = which;
+	ret = gb_operation_sync(ggc->connection, GB_GPIO_TYPE_GET_DIRECTION,
+				&request, sizeof(request),
+				&response, sizeof(response));
+	if (ret)
+		return ret;
+
+	direction = response.direction;
+	if (direction && direction != 1)
+		pr_warn("gpio %u direction was %u (should be 0 or 1)\n",
+			which, direction);
+	ggc->lines[which].direction = direction ? 1 : 0;
+	return 0;
+}
+
+static int gb_gpio_direction_in_operation(struct gb_gpio_controller *ggc,
+					u8 which)
+{
+	struct gb_gpio_direction_in_request request;
+	int ret;
+
+	if (which > ggc->line_max)
+		return -EINVAL;
+
+	request.which = which;
+	ret = gb_operation_sync(ggc->connection, GB_GPIO_TYPE_DIRECTION_IN,
+				&request, sizeof(request), NULL, 0);
+	if (!ret)
+		ggc->lines[which].direction = 1;
+	return ret;
+}
+
+static int gb_gpio_direction_out_operation(struct gb_gpio_controller *ggc,
+					u8 which, bool value_high)
+{
+	struct gb_gpio_direction_out_request request;
+	int ret;
+
+	if (which > ggc->line_max)
+		return -EINVAL;
+
+	request.which = which;
+	request.value = value_high ? 1 : 0;
+	ret = gb_operation_sync(ggc->connection, GB_GPIO_TYPE_DIRECTION_OUT,
+				&request, sizeof(request), NULL, 0);
+	if (!ret)
+		ggc->lines[which].direction = 0;
+	return ret;
+}
+
+static int gb_gpio_get_value_operation(struct gb_gpio_controller *ggc,
+					u8 which)
+{
+	struct gb_gpio_get_value_request request;
+	struct gb_gpio_get_value_response response;
+	int ret;
+	u8 value;
+
+	if (which > ggc->line_max)
+		return -EINVAL;
+
+	request.which = which;
+	ret = gb_operation_sync(ggc->connection, GB_GPIO_TYPE_GET_VALUE,
+				&request, sizeof(request),
+				&response, sizeof(response));
+	if (ret)
+		return ret;
+
+	value = response.value;
+	if (value && value != 1)
+		pr_warn("gpio %u value was %u (should be 0 or 1)\n",
+			which, value);
+	ggc->lines[which].value = value ? 1 : 0;
+	return 0;
+}
+
+static int gb_gpio_set_value_operation(struct gb_gpio_controller *ggc,
+					u8 which, bool value_high)
+{
+	struct gb_gpio_set_value_request request;
+	int ret;
+
+	if (which > ggc->line_max)
+		return -EINVAL;
+
+	request.which = which;
+	request.value = value_high ? 1 : 0;
+	ret = gb_operation_sync(ggc->connection, GB_GPIO_TYPE_SET_VALUE,
+				&request, sizeof(request), NULL, 0);
+	if (!ret) {
+		/* XXX should this set direction to out? */
+		ggc->lines[which].value = request.value;
+	}
+	return ret;
+}
+
+static int gb_gpio_set_debounce_operation(struct gb_gpio_controller *ggc,
+					u8 which, u16 debounce_usec)
+{
+	struct gb_gpio_set_debounce_request request;
+	int ret;
+
+	if (which > ggc->line_max)
+		return -EINVAL;
+
+	request.which = which;
+	request.usec = cpu_to_le16(debounce_usec);
+	ret = gb_operation_sync(ggc->connection, GB_GPIO_TYPE_SET_DEBOUNCE,
+				&request, sizeof(request), NULL, 0);
+	if (!ret)
+		ggc->lines[which].debounce_usec = debounce_usec;
+	return ret;
+}
+
+static int gb_gpio_request(struct gpio_chip *chip, unsigned offset)
+{
+	struct gb_gpio_controller *gb_gpio_controller = gpio_chip_to_gb_gpio_controller(chip);
+	int ret;
+
+	if (offset >= chip->ngpio)
+		return -EINVAL;
+	ret = gb_gpio_activate_operation(gb_gpio_controller, (u8)offset);
+	if (ret)
+		;	/* return ret; */
+	return 0;
+}
+
+static void gb_gpio_free(struct gpio_chip *chip, unsigned offset)
+{
+	struct gb_gpio_controller *gb_gpio_controller = gpio_chip_to_gb_gpio_controller(chip);
+	int ret;
+
+	if (offset >= chip->ngpio) {
+		pr_err("bad offset %u supplied (must be 0..%u)\n",
+			offset, chip->ngpio - 1);
+		return;
+	}
+	ret = gb_gpio_deactivate_operation(gb_gpio_controller, (u8)offset);
+	if (ret)
+		;	/* return ret; */
+}
+
+static int gb_gpio_get_direction(struct gpio_chip *chip, unsigned offset)
+{
+	struct gb_gpio_controller *gb_gpio_controller = gpio_chip_to_gb_gpio_controller(chip);
+	u8 which;
+	int ret;
+
+	if (offset >= chip->ngpio)
+		return -EINVAL;
+	which = (u8)offset;
+	ret = gb_gpio_get_direction_operation(gb_gpio_controller, which);
+	if (ret)
+		;	/* return ret; */
+	return gb_gpio_controller->lines[which].direction ? 1 : 0;
+}
+
+static int gb_gpio_direction_input(struct gpio_chip *chip, unsigned offset)
+{
+	struct gb_gpio_controller *gb_gpio_controller = gpio_chip_to_gb_gpio_controller(chip);
+	int ret;
+
+	if (offset >= chip->ngpio)
+		return -EINVAL;
+	ret = gb_gpio_direction_in_operation(gb_gpio_controller, (u8)offset);
+	if (ret)
+		;	/* return ret; */
+	return 0;
+}
+
+static int gb_gpio_direction_output(struct gpio_chip *chip, unsigned offset,
+					int value)
+{
+	struct gb_gpio_controller *gb_gpio_controller = gpio_chip_to_gb_gpio_controller(chip);
+	int ret;
+
+	if (offset >= chip->ngpio)
+		return -EINVAL;
+	ret = gb_gpio_direction_out_operation(gb_gpio_controller, (u8)offset, !!value);
+	if (ret)
+		;	/* return ret; */
+	return 0;
+}
+
+static int gb_gpio_get(struct gpio_chip *chip, unsigned offset)
+{
+	struct gb_gpio_controller *gb_gpio_controller = gpio_chip_to_gb_gpio_controller(chip);
+	u8 which;
+	int ret;
+
+	if (offset >= chip->ngpio)
+		return -EINVAL;
+	which = (u8)offset;
+	ret = gb_gpio_get_value_operation(gb_gpio_controller, which);
+	if (ret)
+		return ret;
+	return (int)gb_gpio_controller->lines[which].value;
+}
+
+static void gb_gpio_set(struct gpio_chip *chip, unsigned offset, int value)
+{
+	struct gb_gpio_controller *gb_gpio_controller = gpio_chip_to_gb_gpio_controller(chip);
+	int ret;
+
+	if (offset < 0 || offset >= chip->ngpio) {
+		pr_err("bad offset %u supplied (must be 0..%u)\n",
+			offset, chip->ngpio - 1);
+		return;
+	}
+	ret = gb_gpio_set_value_operation(gb_gpio_controller, (u8)offset, !!value);
+	if (ret)
+		;	/* return ret; */
+}
+
+static int gb_gpio_set_debounce(struct gpio_chip *chip, unsigned offset,
+					unsigned debounce)
+{
+	struct gb_gpio_controller *gb_gpio_controller = gpio_chip_to_gb_gpio_controller(chip);
+	u16 usec;
+	int ret;
+
+	if (offset >= chip->ngpio)
+		return -EINVAL;
+	if (debounce > (unsigned int)U16_MAX)
+		return -EINVAL;
+	usec = (u8)debounce;
+	ret = gb_gpio_set_debounce_operation(gb_gpio_controller, (u8)offset, usec);
+	if (ret)
+		;	/* return ret; */
+
+	return 0;	/* XXX */
+}
+
+static int gb_gpio_to_irq(struct gpio_chip *chip, unsigned offset)
+{
+	if (offset >= chip->ngpio)
+		return -EINVAL;
+
+	return 0;	/* XXX */
+}
+
+static void gb_gpio_dbg_show(struct seq_file *s, struct gpio_chip *chip)
+{
+	return;	/* XXX */
+}
+
+static int gb_gpio_controller_setup(struct gb_gpio_controller *gb_gpio_controller)
+{
+	u32 line_count;
+	size_t size;
+	int ret;
+
+	/* First thing we need to do is check the version */
+	ret = gb_gpio_proto_version_operation(gb_gpio_controller);
+	if (ret)
+		;	/* return ret; */
+
+	/* Now find out how many lines there are */
+	ret = gb_gpio_line_count_operation(gb_gpio_controller);
+	if (ret)
+		;	/* return ret; */
+	line_count = (u32)gb_gpio_controller->line_max + 1;
+	size = line_count * sizeof(*gb_gpio_controller->lines);
+	gb_gpio_controller->lines = kzalloc(size, GFP_KERNEL);
+	if (!gb_gpio_controller->lines)
+		return -ENOMEM;
+
+	return ret;
+}
+
+static int gb_gpio_connection_init(struct gb_connection *connection)
+{
+	struct gb_gpio_controller *gb_gpio_controller;
+	struct gpio_chip *gpio;
+	int ret;
+
+	gb_gpio_controller = kzalloc(sizeof(*gb_gpio_controller), GFP_KERNEL);
+	if (!gb_gpio_controller)
+		return -ENOMEM;
+	gb_gpio_controller->connection = connection;
+	connection->private = gb_gpio_controller;
+
+	ret = gb_gpio_controller_setup(gb_gpio_controller);
+	if (ret)
+		goto out_err;
+
+	gpio = &gb_gpio_controller->chip;
+
+	gpio->label = "greybus_gpio";
+	gpio->owner = THIS_MODULE;	/* XXX Module get? */
+
+	gpio->request = gb_gpio_request;
+	gpio->free = gb_gpio_free;
+	gpio->get_direction = gb_gpio_get_direction;
+	gpio->direction_input = gb_gpio_direction_input;
+	gpio->direction_output = gb_gpio_direction_output;
+	gpio->get = gb_gpio_get;
+	gpio->set = gb_gpio_set;
+	gpio->set_debounce = gb_gpio_set_debounce;
+	gpio->to_irq = gb_gpio_to_irq;
+	gpio->dbg_show = gb_gpio_dbg_show;
+
+	gpio->base = -1;		/* Allocate base dynamically */
+	gpio->ngpio = gb_gpio_controller->line_max + 1;
+	gpio->can_sleep = true;		/* XXX */
+
+	ret = gpiochip_add(gpio);
+	if (ret) {
+		pr_err("Failed to register GPIO\n");
+		return ret;
+	}
+
+	return 0;
+out_err:
+	kfree(gb_gpio_controller);
+	return ret;
+}
+
+static void gb_gpio_connection_exit(struct gb_connection *connection)
+{
+	struct gb_gpio_controller *gb_gpio_controller = connection->private;
+
+	if (!gb_gpio_controller)
+		return;
+
+	gb_gpiochip_remove(&gb_gpio_controller->chip);
+	/* kref_put(gb_gpio_controller->connection) */
+	kfree(gb_gpio_controller);
+}
+
+static struct gb_protocol gpio_protocol = {
+	.name			= "gpio",
+	.id			= GREYBUS_PROTOCOL_GPIO,
+	.major			= 0,
+	.minor			= 1,
+	.connection_init	= gb_gpio_connection_init,
+	.connection_exit	= gb_gpio_connection_exit,
+	.request_recv		= NULL,	/* no incoming requests */
+};
+
+int gb_gpio_protocol_init(void)
+{
+	return gb_protocol_register(&gpio_protocol);
+}
+
+void gb_gpio_protocol_exit(void)
+{
+	gb_protocol_deregister(&gpio_protocol);
+}
