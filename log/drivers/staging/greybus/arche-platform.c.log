commit ec0ad868173da8a75121f9dc116a5d5478ff614d
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Sun Aug 25 07:54:27 2019 +0200

    staging: greybus: move core include files to include/linux/greybus/
    
    With the goal of moving the core of the greybus code out of staging, the
    include files need to be moved to include/linux/greybus.h and
    include/linux/greybus/
    
    Cc: Vaibhav Hiremath <hvaibhav.linux@gmail.com>
    Cc: Johan Hovold <johan@kernel.org>
    Cc: Vaibhav Agarwal <vaibhav.sr@gmail.com>
    Cc: Rui Miguel Silva <rmfrfs@gmail.com>
    Cc: David Lin <dtwlin@gmail.com>
    Cc: "Bryan O'Donoghue" <pure.logic@nexus-software.ie>
    Cc: greybus-dev@lists.linaro.org
    Cc: devel@driverdev.osuosl.org
    Acked-by: Mark Greer <mgreer@animalcreek.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Acked-by: Alex Elder <elder@kernel.org>
    Link: https://lore.kernel.org/r/20190825055429.18547-8-gregkh@linuxfoundation.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/arche-platform.c b/drivers/staging/greybus/arche-platform.c
index 6eb842040c22..eebf0deb39f5 100644
--- a/drivers/staging/greybus/arche-platform.c
+++ b/drivers/staging/greybus/arche-platform.c
@@ -19,8 +19,8 @@
 #include <linux/irq.h>
 #include <linux/suspend.h>
 #include <linux/time.h>
+#include <linux/greybus.h>
 #include "arche_platform.h"
-#include "greybus.h"
 
 #if IS_ENABLED(CONFIG_USB_HSIC_USB3613)
 #include <linux/usb/usb3613.h>

commit 4207b5870da5b79a7831cbead2cb60daeab7d64f
Author: Nishad Kamdar <nishadkamdar@gmail.com>
Date:   Mon Jan 14 20:28:59 2019 +0530

    staging: greybus: arche-platform: Switch to the gpio descriptor interface
    
    Use the gpiod interface instead of the deprecated old non-descriptor
    interface while continuing to ignore gpio flags from device tree in
    "svc_reset_onoff()" for now.
    
    Reviewed-by: Johan Hovold <johan@kernel.org>
    Signed-off-by: Nishad Kamdar <nishadkamdar@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/arche-platform.c b/drivers/staging/greybus/arche-platform.c
index 4c36e88766e7..6eb842040c22 100644
--- a/drivers/staging/greybus/arche-platform.c
+++ b/drivers/staging/greybus/arche-platform.c
@@ -8,10 +8,9 @@
 
 #include <linux/clk.h>
 #include <linux/delay.h>
-#include <linux/gpio.h>
+#include <linux/gpio/consumer.h>
 #include <linux/init.h>
 #include <linux/module.h>
-#include <linux/of_gpio.h>
 #include <linux/of_platform.h>
 #include <linux/pinctrl/consumer.h>
 #include <linux/platform_device.h>
@@ -45,14 +44,14 @@ enum svc_wakedetect_state {
 
 struct arche_platform_drvdata {
 	/* Control GPIO signals to and from AP <=> SVC */
-	int svc_reset_gpio;
+	struct gpio_desc *svc_reset;
 	bool is_reset_act_hi;
-	int svc_sysboot_gpio;
-	int wake_detect_gpio; /* bi-dir,maps to WAKE_MOD & WAKE_FRAME signals */
+	struct gpio_desc *svc_sysboot;
+	struct gpio_desc *wake_detect; /* bi-dir,maps to WAKE_MOD & WAKE_FRAME signals */
 
 	enum arche_platform_state state;
 
-	int svc_refclk_req;
+	struct gpio_desc *svc_refclk_req;
 	struct clk *svc_ref_clk;
 
 	struct pinctrl *pinctrl;
@@ -85,9 +84,9 @@ static void arche_platform_set_wake_detect_state(
 	arche_pdata->wake_detect_state = state;
 }
 
-static inline void svc_reset_onoff(unsigned int gpio, bool onoff)
+static inline void svc_reset_onoff(struct gpio_desc *gpio, bool onoff)
 {
-	gpio_set_value(gpio, onoff);
+	gpiod_set_raw_value(gpio, onoff);
 }
 
 static int apb_cold_boot(struct device *dev, void *data)
@@ -116,7 +115,6 @@ static int apb_poweroff(struct device *dev, void *data)
 static void arche_platform_wd_irq_en(struct arche_platform_drvdata *arche_pdata)
 {
 	/* Enable interrupt here, to read event back from SVC */
-	gpio_direction_input(arche_pdata->wake_detect_gpio);
 	enable_irq(arche_pdata->wake_detect_irq);
 }
 
@@ -160,7 +158,7 @@ static irqreturn_t arche_platform_wd_irq(int irq, void *devid)
 
 	spin_lock_irqsave(&arche_pdata->wake_lock, flags);
 
-	if (gpio_get_value(arche_pdata->wake_detect_gpio)) {
+	if (gpiod_get_value(arche_pdata->wake_detect)) {
 		/* wake/detect rising */
 
 		/*
@@ -224,10 +222,9 @@ arche_platform_coldboot_seq(struct arche_platform_drvdata *arche_pdata)
 
 	dev_info(arche_pdata->dev, "Booting from cold boot state\n");
 
-	svc_reset_onoff(arche_pdata->svc_reset_gpio,
-			arche_pdata->is_reset_act_hi);
+	svc_reset_onoff(arche_pdata->svc_reset, arche_pdata->is_reset_act_hi);
 
-	gpio_set_value(arche_pdata->svc_sysboot_gpio, 0);
+	gpiod_set_value(arche_pdata->svc_sysboot, 0);
 	usleep_range(100, 200);
 
 	ret = clk_prepare_enable(arche_pdata->svc_ref_clk);
@@ -238,8 +235,7 @@ arche_platform_coldboot_seq(struct arche_platform_drvdata *arche_pdata)
 	}
 
 	/* bring SVC out of reset */
-	svc_reset_onoff(arche_pdata->svc_reset_gpio,
-			!arche_pdata->is_reset_act_hi);
+	svc_reset_onoff(arche_pdata->svc_reset, !arche_pdata->is_reset_act_hi);
 
 	arche_platform_set_state(arche_pdata, ARCHE_PLATFORM_STATE_ACTIVE);
 
@@ -259,10 +255,9 @@ arche_platform_fw_flashing_seq(struct arche_platform_drvdata *arche_pdata)
 
 	dev_info(arche_pdata->dev, "Switching to FW flashing state\n");
 
-	svc_reset_onoff(arche_pdata->svc_reset_gpio,
-			arche_pdata->is_reset_act_hi);
+	svc_reset_onoff(arche_pdata->svc_reset, arche_pdata->is_reset_act_hi);
 
-	gpio_set_value(arche_pdata->svc_sysboot_gpio, 1);
+	gpiod_set_value(arche_pdata->svc_sysboot, 1);
 
 	usleep_range(100, 200);
 
@@ -273,8 +268,7 @@ arche_platform_fw_flashing_seq(struct arche_platform_drvdata *arche_pdata)
 		return ret;
 	}
 
-	svc_reset_onoff(arche_pdata->svc_reset_gpio,
-			!arche_pdata->is_reset_act_hi);
+	svc_reset_onoff(arche_pdata->svc_reset,	!arche_pdata->is_reset_act_hi);
 
 	arche_platform_set_state(arche_pdata, ARCHE_PLATFORM_STATE_FW_FLASHING);
 
@@ -305,8 +299,7 @@ arche_platform_poweroff_seq(struct arche_platform_drvdata *arche_pdata)
 	clk_disable_unprepare(arche_pdata->svc_ref_clk);
 
 	/* As part of exit, put APB back in reset state */
-	svc_reset_onoff(arche_pdata->svc_reset_gpio,
-			arche_pdata->is_reset_act_hi);
+	svc_reset_onoff(arche_pdata->svc_reset,	arche_pdata->is_reset_act_hi);
 
 	arche_platform_set_state(arche_pdata, ARCHE_PLATFORM_STATE_OFF);
 }
@@ -435,6 +428,7 @@ static int arche_platform_probe(struct platform_device *pdev)
 	struct device *dev = &pdev->dev;
 	struct device_node *np = dev->of_node;
 	int ret;
+	unsigned int flags;
 
 	arche_pdata = devm_kzalloc(&pdev->dev, sizeof(*arche_pdata),
 				   GFP_KERNEL);
@@ -444,61 +438,33 @@ static int arche_platform_probe(struct platform_device *pdev)
 	/* setup svc reset gpio */
 	arche_pdata->is_reset_act_hi = of_property_read_bool(np,
 							     "svc,reset-active-high");
-	arche_pdata->svc_reset_gpio = of_get_named_gpio(np,
-							"svc,reset-gpio",
-							0);
-	if (!gpio_is_valid(arche_pdata->svc_reset_gpio)) {
-		dev_err(dev, "failed to get reset-gpio\n");
-		return arche_pdata->svc_reset_gpio;
-	}
-	ret = devm_gpio_request(dev, arche_pdata->svc_reset_gpio, "svc-reset");
-	if (ret) {
-		dev_err(dev, "failed to request svc-reset gpio:%d\n", ret);
-		return ret;
-	}
-	ret = gpio_direction_output(arche_pdata->svc_reset_gpio,
-				    arche_pdata->is_reset_act_hi);
-	if (ret) {
-		dev_err(dev, "failed to set svc-reset gpio dir:%d\n", ret);
+	if (arche_pdata->is_reset_act_hi)
+		flags = GPIOD_OUT_HIGH;
+	else
+		flags = GPIOD_OUT_LOW;
+
+	arche_pdata->svc_reset = devm_gpiod_get(dev, "svc,reset", flags);
+	if (IS_ERR(arche_pdata->svc_reset)) {
+		ret = PTR_ERR(arche_pdata->svc_reset);
+		dev_err(dev, "failed to request svc-reset GPIO: %d\n", ret);
 		return ret;
 	}
 	arche_platform_set_state(arche_pdata, ARCHE_PLATFORM_STATE_OFF);
 
-	arche_pdata->svc_sysboot_gpio = of_get_named_gpio(np,
-							  "svc,sysboot-gpio",
-							  0);
-	if (!gpio_is_valid(arche_pdata->svc_sysboot_gpio)) {
-		dev_err(dev, "failed to get sysboot gpio\n");
-		return arche_pdata->svc_sysboot_gpio;
-	}
-	ret = devm_gpio_request(dev, arche_pdata->svc_sysboot_gpio, "sysboot0");
-	if (ret) {
-		dev_err(dev, "failed to request sysboot0 gpio:%d\n", ret);
-		return ret;
-	}
-	ret = gpio_direction_output(arche_pdata->svc_sysboot_gpio, 0);
-	if (ret) {
-		dev_err(dev, "failed to set svc-reset gpio dir:%d\n", ret);
+	arche_pdata->svc_sysboot = devm_gpiod_get(dev, "svc,sysboot",
+						  GPIOD_OUT_LOW);
+	if (IS_ERR(arche_pdata->svc_sysboot)) {
+		ret = PTR_ERR(arche_pdata->svc_sysboot);
+		dev_err(dev, "failed to request sysboot0 GPIO: %d\n", ret);
 		return ret;
 	}
 
 	/* setup the clock request gpio first */
-	arche_pdata->svc_refclk_req = of_get_named_gpio(np,
-							"svc,refclk-req-gpio",
-							0);
-	if (!gpio_is_valid(arche_pdata->svc_refclk_req)) {
-		dev_err(dev, "failed to get svc clock-req gpio\n");
-		return arche_pdata->svc_refclk_req;
-	}
-	ret = devm_gpio_request(dev, arche_pdata->svc_refclk_req,
-				"svc-clk-req");
-	if (ret) {
-		dev_err(dev, "failed to request svc-clk-req gpio: %d\n", ret);
-		return ret;
-	}
-	ret = gpio_direction_input(arche_pdata->svc_refclk_req);
-	if (ret) {
-		dev_err(dev, "failed to set svc-clk-req gpio dir :%d\n", ret);
+	arche_pdata->svc_refclk_req = devm_gpiod_get(dev, "svc,refclk-req",
+						     GPIOD_IN);
+	if (IS_ERR(arche_pdata->svc_refclk_req)) {
+		ret = PTR_ERR(arche_pdata->svc_refclk_req);
+		dev_err(dev, "failed to request svc-clk-req GPIO: %d\n", ret);
 		return ret;
 	}
 
@@ -515,19 +481,11 @@ static int arche_platform_probe(struct platform_device *pdev)
 	arche_pdata->num_apbs = of_get_child_count(np);
 	dev_dbg(dev, "Number of APB's available - %d\n", arche_pdata->num_apbs);
 
-	arche_pdata->wake_detect_gpio = of_get_named_gpio(np,
-							  "svc,wake-detect-gpio",
-							  0);
-	if (arche_pdata->wake_detect_gpio < 0) {
-		dev_err(dev, "failed to get wake detect gpio\n");
-		return arche_pdata->wake_detect_gpio;
-	}
-
-	ret = devm_gpio_request(dev, arche_pdata->wake_detect_gpio,
-				"wake detect");
-	if (ret) {
-		dev_err(dev, "Failed requesting wake_detect gpio %d\n",
-			arche_pdata->wake_detect_gpio);
+	arche_pdata->wake_detect = devm_gpiod_get(dev, "svc,wake-detect",
+						  GPIOD_IN);
+	if (IS_ERR(arche_pdata->wake_detect)) {
+		ret = PTR_ERR(arche_pdata->wake_detect);
+		dev_err(dev, "Failed requesting wake_detect GPIO: %d\n", ret);
 		return ret;
 	}
 
@@ -538,7 +496,7 @@ static int arche_platform_probe(struct platform_device *pdev)
 	spin_lock_init(&arche_pdata->wake_lock);
 	mutex_init(&arche_pdata->platform_state_mutex);
 	arche_pdata->wake_detect_irq =
-		gpio_to_irq(arche_pdata->wake_detect_gpio);
+		gpiod_to_irq(arche_pdata->wake_detect);
 
 	ret = devm_request_threaded_irq(dev, arche_pdata->wake_detect_irq,
 					arche_platform_wd_irq,

commit a2e63709b53312002009c564460af34520c62f98
Author: Arvind Yadav <arvind.yadav.cs@gmail.com>
Date:   Sat Apr 28 10:05:39 2018 +0530

    staging: greybus: Use gpio_is_valid()
    
    Replace the manual validity checks for the GPIO with the
    gpio_is_valid().
    
    Signed-off-by: Arvind Yadav <arvind.yadav.cs@gmail.com>
    Reviewed-by: Alex Elder <elder@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/arche-platform.c b/drivers/staging/greybus/arche-platform.c
index 8fe8b6e35432..4c36e88766e7 100644
--- a/drivers/staging/greybus/arche-platform.c
+++ b/drivers/staging/greybus/arche-platform.c
@@ -447,7 +447,7 @@ static int arche_platform_probe(struct platform_device *pdev)
 	arche_pdata->svc_reset_gpio = of_get_named_gpio(np,
 							"svc,reset-gpio",
 							0);
-	if (arche_pdata->svc_reset_gpio < 0) {
+	if (!gpio_is_valid(arche_pdata->svc_reset_gpio)) {
 		dev_err(dev, "failed to get reset-gpio\n");
 		return arche_pdata->svc_reset_gpio;
 	}
@@ -467,7 +467,7 @@ static int arche_platform_probe(struct platform_device *pdev)
 	arche_pdata->svc_sysboot_gpio = of_get_named_gpio(np,
 							  "svc,sysboot-gpio",
 							  0);
-	if (arche_pdata->svc_sysboot_gpio < 0) {
+	if (!gpio_is_valid(arche_pdata->svc_sysboot_gpio)) {
 		dev_err(dev, "failed to get sysboot gpio\n");
 		return arche_pdata->svc_sysboot_gpio;
 	}
@@ -486,7 +486,7 @@ static int arche_platform_probe(struct platform_device *pdev)
 	arche_pdata->svc_refclk_req = of_get_named_gpio(np,
 							"svc,refclk-req-gpio",
 							0);
-	if (arche_pdata->svc_refclk_req < 0) {
+	if (!gpio_is_valid(arche_pdata->svc_refclk_req)) {
 		dev_err(dev, "failed to get svc clock-req gpio\n");
 		return arche_pdata->svc_refclk_req;
 	}

commit 1dab154ef1a44933a07c0968ecd34b194ff260eb
Author: Wolfram Sang <wsa+renesas@sang-engineering.com>
Date:   Thu Apr 19 16:06:17 2018 +0200

    staging: greybus: simplify getting .drvdata
    
    We should get drvdata from struct device directly. Going via
    platform_device is an unneeded step back and forth.
    
    Signed-off-by: Wolfram Sang <wsa+renesas@sang-engineering.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Acked-by: Johan Hovold <johan@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/arche-platform.c b/drivers/staging/greybus/arche-platform.c
index 83254a72a7bb..8fe8b6e35432 100644
--- a/drivers/staging/greybus/arche-platform.c
+++ b/drivers/staging/greybus/arche-platform.c
@@ -315,8 +315,7 @@ static ssize_t state_store(struct device *dev,
 			   struct device_attribute *attr,
 			   const char *buf, size_t count)
 {
-	struct platform_device *pdev = to_platform_device(dev);
-	struct arche_platform_drvdata *arche_pdata = platform_get_drvdata(pdev);
+	struct arche_platform_drvdata *arche_pdata = dev_get_drvdata(dev);
 	int ret = 0;
 
 	mutex_lock(&arche_pdata->platform_state_mutex);

commit 07df5b7c94c266481e341031a6a8293345a0a87c
Author: Kamal Heib <kamalheib1@gmail.com>
Date:   Sun Dec 17 19:56:27 2017 +0200

    staging: greybus: arche-platform.c: Fix alignment should match open parenthesis
    
    Fix "alignment should match open parenthesis" checkpatch.pl error.
    
    Signed-off-by: Kamal Heib <kamalheib1@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/arche-platform.c b/drivers/staging/greybus/arche-platform.c
index ace4eb365c0e..83254a72a7bb 100644
--- a/drivers/staging/greybus/arche-platform.c
+++ b/drivers/staging/greybus/arche-platform.c
@@ -233,7 +233,7 @@ arche_platform_coldboot_seq(struct arche_platform_drvdata *arche_pdata)
 	ret = clk_prepare_enable(arche_pdata->svc_ref_clk);
 	if (ret) {
 		dev_err(arche_pdata->dev, "failed to enable svc_ref_clk: %d\n",
-				ret);
+			ret);
 		return ret;
 	}
 
@@ -269,7 +269,7 @@ arche_platform_fw_flashing_seq(struct arche_platform_drvdata *arche_pdata)
 	ret = clk_prepare_enable(arche_pdata->svc_ref_clk);
 	if (ret) {
 		dev_err(arche_pdata->dev, "failed to enable svc_ref_clk: %d\n",
-				ret);
+			ret);
 		return ret;
 	}
 
@@ -312,7 +312,8 @@ arche_platform_poweroff_seq(struct arche_platform_drvdata *arche_pdata)
 }
 
 static ssize_t state_store(struct device *dev,
-		struct device_attribute *attr, const char *buf, size_t count)
+			   struct device_attribute *attr,
+			   const char *buf, size_t count)
 {
 	struct platform_device *pdev = to_platform_device(dev);
 	struct arche_platform_drvdata *arche_pdata = platform_get_drvdata(pdev);
@@ -376,7 +377,7 @@ static ssize_t state_store(struct device *dev,
 }
 
 static ssize_t state_show(struct device *dev,
-		struct device_attribute *attr, char *buf)
+			  struct device_attribute *attr, char *buf)
 {
 	struct arche_platform_drvdata *arche_pdata = dev_get_drvdata(dev);
 
@@ -443,7 +444,7 @@ static int arche_platform_probe(struct platform_device *pdev)
 
 	/* setup svc reset gpio */
 	arche_pdata->is_reset_act_hi = of_property_read_bool(np,
-					"svc,reset-active-high");
+							     "svc,reset-active-high");
 	arche_pdata->svc_reset_gpio = of_get_named_gpio(np,
 							"svc,reset-gpio",
 							0);
@@ -457,7 +458,7 @@ static int arche_platform_probe(struct platform_device *pdev)
 		return ret;
 	}
 	ret = gpio_direction_output(arche_pdata->svc_reset_gpio,
-					arche_pdata->is_reset_act_hi);
+				    arche_pdata->is_reset_act_hi);
 	if (ret) {
 		dev_err(dev, "failed to set svc-reset gpio dir:%d\n", ret);
 		return ret;
@@ -465,7 +466,8 @@ static int arche_platform_probe(struct platform_device *pdev)
 	arche_platform_set_state(arche_pdata, ARCHE_PLATFORM_STATE_OFF);
 
 	arche_pdata->svc_sysboot_gpio = of_get_named_gpio(np,
-					"svc,sysboot-gpio", 0);
+							  "svc,sysboot-gpio",
+							  0);
 	if (arche_pdata->svc_sysboot_gpio < 0) {
 		dev_err(dev, "failed to get sysboot gpio\n");
 		return arche_pdata->svc_sysboot_gpio;
@@ -483,7 +485,8 @@ static int arche_platform_probe(struct platform_device *pdev)
 
 	/* setup the clock request gpio first */
 	arche_pdata->svc_refclk_req = of_get_named_gpio(np,
-					"svc,refclk-req-gpio", 0);
+							"svc,refclk-req-gpio",
+							0);
 	if (arche_pdata->svc_refclk_req < 0) {
 		dev_err(dev, "failed to get svc clock-req gpio\n");
 		return arche_pdata->svc_refclk_req;
@@ -525,7 +528,7 @@ static int arche_platform_probe(struct platform_device *pdev)
 				"wake detect");
 	if (ret) {
 		dev_err(dev, "Failed requesting wake_detect gpio %d\n",
-				arche_pdata->wake_detect_gpio);
+			arche_pdata->wake_detect_gpio);
 		return ret;
 	}
 

commit 863dbc52e7f0e5acd7b4883f3933543a81c474c7
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Nov 7 14:58:42 2017 +0100

    staging: greybus: Remove redundant license text
    
    Now that the SPDX tag is in all greybus files, that identifies the
    license in a specific and legally-defined manner.  So the extra GPL text
    wording can be removed as it is no longer needed at all.
    
    This is done on a quest to remove the 700+ different ways that files in
    the kernel describe the GPL license text.  And there's unneeded stuff
    like the address (sometimes incorrect) for the FSF which is never
    needed.
    
    No copyright headers or other non-license-description text was removed.
    
    Cc: Vaibhav Hiremath <hvaibhav.linux@gmail.com>
    Reviewed-by: Alex Elder <elder@linaro.org>
    Acked-by: Vaibhav Agarwal <vaibhav.sr@gmail.com>
    Acked-by: David Lin <dtwlin@gmail.com>
    Acked-by: Johan Hovold <johan@kernel.org>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Acked-by: Mark Greer <mgreer@animalcreek.com>
    Acked-by: Rui Miguel Silva <rmfrfs@gmail.com>
    Acked-by: "Bryan O'Donoghue" <pure.logic@nexus-software.ie>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/arche-platform.c b/drivers/staging/greybus/arche-platform.c
index 28c874ff16a7..ace4eb365c0e 100644
--- a/drivers/staging/greybus/arche-platform.c
+++ b/drivers/staging/greybus/arche-platform.c
@@ -4,8 +4,6 @@
  *
  * Copyright 2014-2015 Google Inc.
  * Copyright 2014-2015 Linaro Ltd.
- *
- * Released under the GPLv2 only.
  */
 
 #include <linux/clk.h>

commit eb50fd3a22c770f36be275295b782f3ea52e3215
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Nov 7 14:58:41 2017 +0100

    staging: greybus: add SPDX identifiers to all greybus driver files
    
    It's good to have SPDX identifiers in all files to make it easier to
    audit the kernel tree for correct licenses.
    
    Update the drivers/staging/greybus files files with the correct SPDX
    license identifier based on the license text in the file itself.  The
    SPDX identifier is a legally binding shorthand, which can be used
    instead of the full boiler plate text.
    
    This work is based on a script and data from Thomas Gleixner, Philippe
    Ombredanne, and Kate Stewart.
    
    Cc: Vaibhav Hiremath <hvaibhav.linux@gmail.com>
    Cc: "Bryan O'Donoghue" <pure.logic@nexus-software.ie>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: Philippe Ombredanne <pombredanne@nexb.com>
    Acked-by: Vaibhav Agarwal <vaibhav.sr@gmail.com>
    Acked-by: David Lin <dtwlin@gmail.com>
    Reviewed-by: Alex Elder <elder@linaro.org>
    Acked-by: Johan Hovold <johan@kernel.org>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Acked-by: Mark Greer <mgreer@animalcreek.com>
    Acked-by: Rui Miguel Silva <rmfrfs@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/arche-platform.c b/drivers/staging/greybus/arche-platform.c
index 21ac92d0f533..28c874ff16a7 100644
--- a/drivers/staging/greybus/arche-platform.c
+++ b/drivers/staging/greybus/arche-platform.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * Arche Platform driver to enable Unipro link.
  *

commit 4a27e3e09d2f846905163eb967884a1efb8e6462
Author: Eames Trinh <eamestrinh@gmail.com>
Date:   Tue Aug 22 00:11:37 2017 +0200

    Staging: greybus: Fix spelling error in comment
    
    Fixed a spelling error.
    
    Signed-off-by: Eames Trinh <eamestrinh@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/arche-platform.c b/drivers/staging/greybus/arche-platform.c
index 4837aca41389..21ac92d0f533 100644
--- a/drivers/staging/greybus/arche-platform.c
+++ b/drivers/staging/greybus/arche-platform.c
@@ -196,7 +196,7 @@ static irqreturn_t arche_platform_wd_irq(int irq, void *devid)
 		if (arche_pdata->wake_detect_state == WD_STATE_IDLE) {
 			arche_pdata->wake_detect_start = jiffies;
 			/*
-			 * In the begining, when wake/detect goes low
+			 * In the beginning, when wake/detect goes low
 			 * (first time), we assume it is meant for coldboot
 			 * and set the flag. If wake/detect line stays low
 			 * beyond 30msec, then it is coldboot else fallback

commit 100330ecc465477e882181e17dd3bb09ac14ae51
Author: Amitoj Kaur Chawla <amitoj1606@gmail.com>
Date:   Wed Jul 26 23:19:07 2017 -0400

    staging: greybus: Remove unnecessary platform_set_drvdata
    
    Unnecessary platform_set_drvdata() has been removed since the driver
    core clears the driver data to NULL after device release or on
    probe failure. There is no need to manually clear the device
    driver data to NULL.
    
    The Coccinelle semantic patch used to make this change is as follows:
    //<smpl>
    @@
    struct platform_device *pdev;
    @@
    - platform_set_drvdata(pdev, NULL);
    //</smpl>
    
    Signed-off-by: Amitoj Kaur Chawla <amitoj1606@gmail.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/arche-platform.c b/drivers/staging/greybus/arche-platform.c
index 625990400fa9..4837aca41389 100644
--- a/drivers/staging/greybus/arche-platform.c
+++ b/drivers/staging/greybus/arche-platform.c
@@ -610,7 +610,6 @@ static int arche_platform_remove(struct platform_device *pdev)
 	device_remove_file(&pdev->dev, &dev_attr_state);
 	device_for_each_child(&pdev->dev, NULL, arche_remove_child);
 	arche_platform_poweroff_seq(arche_pdata);
-	platform_set_drvdata(pdev, NULL);
 
 	if (usb3613_hub_mode_ctrl(false))
 		dev_warn(arche_pdata->dev, "failed to control hub device\n");

commit bf766625aed67ce2b97e6e86d49260cc72e688b0
Author: Mitchell Tasman <tasman@leaflabs.com>
Date:   Mon Jul 10 23:14:44 2017 -0400

    staging: greybus: arche: wrap over-length lines
    
    Adjust formatting of several comments to keep line length within
    the 80 column limit preferred by the Linux kernel coding style.
    
    Signed-off-by: Mitchell Tasman <tasman@leaflabs.com>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/arche-platform.c b/drivers/staging/greybus/arche-platform.c
index eced2d26467b..625990400fa9 100644
--- a/drivers/staging/greybus/arche-platform.c
+++ b/drivers/staging/greybus/arche-platform.c
@@ -176,7 +176,10 @@ static irqreturn_t arche_platform_wd_irq(int irq, void *devid)
 				arche_platform_set_wake_detect_state(arche_pdata,
 								     WD_STATE_IDLE);
 			} else {
-				/* Check we are not in middle of irq thread already */
+				/*
+				 * Check we are not in middle of irq thread
+				 * already
+				 */
 				if (arche_pdata->wake_detect_state !=
 						WD_STATE_COLDBOOT_START) {
 					arche_platform_set_wake_detect_state(arche_pdata,
@@ -657,12 +660,14 @@ static SIMPLE_DEV_PM_OPS(arche_platform_pm_ops,
 			arche_platform_resume);
 
 static const struct of_device_id arche_platform_of_match[] = {
-	{ .compatible = "google,arche-platform", }, /* Use PID/VID of SVC device */
+	/* Use PID/VID of SVC device */
+	{ .compatible = "google,arche-platform", },
 	{ },
 };
 
 static const struct of_device_id arche_combined_id[] = {
-	{ .compatible = "google,arche-platform", }, /* Use PID/VID of SVC device */
+	/* Use PID/VID of SVC device */
+	{ .compatible = "google,arche-platform", },
 	{ .compatible = "usbffff,2", },
 	{ },
 };

commit 0687090acf0d0bee585fa0ec29cf5b1fd48cefee
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Thu May 18 15:28:00 2017 +0200

    staging: greybus: mark PM functions as __maybe_unused
    
    Enabling the arche platform for compile testing showed a harmless
    warning with CONFIG_PM=n:
    
    drivers/staging/greybus/arche-platform.c:632:12: error: 'arche_platform_resume' defined but not used [-Werror=unused-function]
    drivers/staging/greybus/arche-platform.c:618:12: error: 'arche_platform_suspend' defined but not used [-Werror=unused-function]
    
    This marks the functions as __maybe_unused to shut up the warnings.
    
    Fixes: 2eccd4aa19fc ("staging: greybus: enable compile testing of arche driver")
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Johan Hovold <johan@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/arche-platform.c b/drivers/staging/greybus/arche-platform.c
index 5bce5e039596..eced2d26467b 100644
--- a/drivers/staging/greybus/arche-platform.c
+++ b/drivers/staging/greybus/arche-platform.c
@@ -615,7 +615,7 @@ static int arche_platform_remove(struct platform_device *pdev)
 	return 0;
 }
 
-static int arche_platform_suspend(struct device *dev)
+static __maybe_unused int arche_platform_suspend(struct device *dev)
 {
 	/*
 	 * If timing profile premits, we may shutdown bridge
@@ -629,7 +629,7 @@ static int arche_platform_suspend(struct device *dev)
 	return 0;
 }
 
-static int arche_platform_resume(struct device *dev)
+static __maybe_unused int arche_platform_resume(struct device *dev)
 {
 	/*
 	 * Atleast for ES2 we have to meet the delay requirement between

commit 2eccd4aa19fc88e48e4be4d86f271a266d95e6d0
Author: Johan Hovold <johan@kernel.org>
Date:   Tue May 16 10:01:39 2017 +0200

    staging: greybus: enable compile testing of arche driver
    
    Add Arche platform-driver config option and allow the driver to be
    compile tested also without the out-of-tree usb3613 driver.
    
    Signed-off-by: Johan Hovold <johan@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/arche-platform.c b/drivers/staging/greybus/arche-platform.c
index 9e644bfe2ae0..5bce5e039596 100644
--- a/drivers/staging/greybus/arche-platform.c
+++ b/drivers/staging/greybus/arche-platform.c
@@ -24,7 +24,14 @@
 #include "arche_platform.h"
 #include "greybus.h"
 
+#if IS_ENABLED(CONFIG_USB_HSIC_USB3613)
 #include <linux/usb/usb3613.h>
+#else
+static inline int usb3613_hub_mode_ctrl(bool unused)
+{
+	return 0;
+}
+#endif
 
 #define WD_COLDBOOT_PULSE_WIDTH_MS	30
 

commit 1e029b836108d0b68ba574482604247c97cb4757
Author: Johan Hovold <johan@kernel.org>
Date:   Tue May 16 10:01:38 2017 +0200

    staging: greybus: arche: remove timesync remains
    
    Remove the remaining timesync bits that were left in the arche platform
    driver and which prevented the driver from being compiled.
    
    Fixes: bdfb95c4baab ("staging: greybus: remove timesync protocol support")
    Signed-off-by: Johan Hovold <johan@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/arche-platform.c b/drivers/staging/greybus/arche-platform.c
index aac1145f1983..9e644bfe2ae0 100644
--- a/drivers/staging/greybus/arche-platform.c
+++ b/drivers/staging/greybus/arche-platform.c
@@ -35,7 +35,6 @@ enum svc_wakedetect_state {
 	WD_STATE_STANDBYBOOT_TRIG,	/* As of now not used ?? */
 	WD_STATE_COLDBOOT_START,	/* Cold boot process started */
 	WD_STATE_STANDBYBOOT_START,	/* Not used */
-	WD_STATE_TIMESYNC,
 };
 
 struct arche_platform_drvdata {
@@ -59,26 +58,12 @@ struct arche_platform_drvdata {
 	int wake_detect_irq;
 	spinlock_t wake_lock;			/* Protect wake_detect_state */
 	struct mutex platform_state_mutex;	/* Protect state */
-	wait_queue_head_t wq;			/* WQ for arche_pdata->state */
 	unsigned long wake_detect_start;
 	struct notifier_block pm_notifier;
 
 	struct device *dev;
-	struct gb_timesync_svc *timesync_svc_pdata;
 };
 
-static int arche_apb_bootret_assert(struct device *dev, void *data)
-{
-	apb_bootret_assert(dev);
-	return 0;
-}
-
-static int arche_apb_bootret_deassert(struct device *dev, void *data)
-{
-	apb_bootret_deassert(dev);
-	return 0;
-}
-
 /* Requires calling context to hold arche_pdata->platform_state_mutex */
 static void arche_platform_set_state(struct arche_platform_drvdata *arche_pdata,
 				     enum arche_platform_state state)
@@ -86,112 +71,6 @@ static void arche_platform_set_state(struct arche_platform_drvdata *arche_pdata,
 	arche_pdata->state = state;
 }
 
-/*
- * arche_platform_change_state: Change the operational state
- *
- * This exported function allows external drivers to change the state
- * of the arche-platform driver.
- * Note that this function only supports transitions between two states
- * with limited functionality.
- *
- *  - ARCHE_PLATFORM_STATE_TIME_SYNC:
- *    Once set, allows timesync operations between SVC <=> AP and makes
- *    sure that arche-platform driver ignores any subsequent events/pulses
- *    from SVC over wake/detect.
- *
- *  - ARCHE_PLATFORM_STATE_ACTIVE:
- *    Puts back driver to active state, where any pulse from SVC on wake/detect
- *    line would trigger either cold/standby boot.
- *    Note: Transition request from this function does not trigger cold/standby
- *          boot. It just puts back driver book keeping variable back to ACTIVE
- *          state and restores the interrupt.
- *
- * Returns -ENODEV if device not found, -EAGAIN if the driver cannot currently
- * satisfy the requested state-transition or -EINVAL for all other
- * state-transition requests.
- */
-int arche_platform_change_state(enum arche_platform_state state,
-				struct gb_timesync_svc *timesync_svc_pdata)
-{
-	struct arche_platform_drvdata *arche_pdata;
-	struct platform_device *pdev;
-	struct device_node *np;
-	int ret = -EAGAIN;
-	unsigned long flags;
-
-	np = of_find_compatible_node(NULL, NULL, "google,arche-platform");
-	if (!np) {
-		pr_err("google,arche-platform device node not found\n");
-		return -ENODEV;
-	}
-
-	pdev = of_find_device_by_node(np);
-	if (!pdev) {
-		pr_err("arche-platform device not found\n");
-		of_node_put(np);
-		return -ENODEV;
-	}
-
-	arche_pdata = platform_get_drvdata(pdev);
-
-	mutex_lock(&arche_pdata->platform_state_mutex);
-	spin_lock_irqsave(&arche_pdata->wake_lock, flags);
-
-	if (arche_pdata->state == state) {
-		ret = 0;
-		goto exit;
-	}
-
-	switch (state) {
-	case ARCHE_PLATFORM_STATE_TIME_SYNC:
-		if (arche_pdata->state != ARCHE_PLATFORM_STATE_ACTIVE) {
-			ret = -EINVAL;
-			goto exit;
-		}
-		if (arche_pdata->wake_detect_state != WD_STATE_IDLE) {
-			dev_err(arche_pdata->dev,
-				"driver busy with wake/detect line ops\n");
-			goto  exit;
-		}
-		device_for_each_child(arche_pdata->dev, NULL,
-				      arche_apb_bootret_assert);
-		arche_pdata->wake_detect_state = WD_STATE_TIMESYNC;
-		break;
-	case ARCHE_PLATFORM_STATE_ACTIVE:
-		if (arche_pdata->state != ARCHE_PLATFORM_STATE_TIME_SYNC) {
-			ret = -EINVAL;
-			goto exit;
-		}
-		device_for_each_child(arche_pdata->dev, NULL,
-				      arche_apb_bootret_deassert);
-		arche_pdata->wake_detect_state = WD_STATE_IDLE;
-		break;
-	case ARCHE_PLATFORM_STATE_OFF:
-	case ARCHE_PLATFORM_STATE_STANDBY:
-	case ARCHE_PLATFORM_STATE_FW_FLASHING:
-		dev_err(arche_pdata->dev, "busy, request to retry later\n");
-		goto exit;
-	default:
-		ret = -EINVAL;
-		dev_err(arche_pdata->dev,
-			"invalid state transition request\n");
-		goto exit;
-	}
-	arche_pdata->timesync_svc_pdata = timesync_svc_pdata;
-	arche_platform_set_state(arche_pdata, state);
-	if (state == ARCHE_PLATFORM_STATE_ACTIVE)
-		wake_up(&arche_pdata->wq);
-
-	ret = 0;
-exit:
-	spin_unlock_irqrestore(&arche_pdata->wake_lock, flags);
-	mutex_unlock(&arche_pdata->platform_state_mutex);
-	put_device(&pdev->dev);
-	of_node_put(np);
-	return ret;
-}
-EXPORT_SYMBOL_GPL(arche_platform_change_state);
-
 /* Requires arche_pdata->wake_lock is held by calling context */
 static void arche_platform_set_wake_detect_state(
 				struct arche_platform_drvdata *arche_pdata,
@@ -275,11 +154,6 @@ static irqreturn_t arche_platform_wd_irq(int irq, void *devid)
 
 	spin_lock_irqsave(&arche_pdata->wake_lock, flags);
 
-	if (arche_pdata->wake_detect_state == WD_STATE_TIMESYNC) {
-		gb_timesync_irq(arche_pdata->timesync_svc_pdata);
-		goto exit;
-	}
-
 	if (gpio_get_value(arche_pdata->wake_detect_gpio)) {
 		/* wake/detect rising */
 
@@ -323,7 +197,6 @@ static irqreturn_t arche_platform_wd_irq(int irq, void *devid)
 		}
 	}
 
-exit:
 	spin_unlock_irqrestore(&arche_pdata->wake_lock, flags);
 
 	return IRQ_HANDLED;
@@ -436,17 +309,7 @@ static ssize_t state_store(struct device *dev,
 	struct arche_platform_drvdata *arche_pdata = platform_get_drvdata(pdev);
 	int ret = 0;
 
-retry:
 	mutex_lock(&arche_pdata->platform_state_mutex);
-	if (arche_pdata->state == ARCHE_PLATFORM_STATE_TIME_SYNC) {
-		mutex_unlock(&arche_pdata->platform_state_mutex);
-		ret = wait_event_interruptible(
-			arche_pdata->wq,
-			arche_pdata->state != ARCHE_PLATFORM_STATE_TIME_SYNC);
-		if (ret)
-			return ret;
-		goto retry;
-	}
 
 	if (sysfs_streq(buf, "off")) {
 		if (arche_pdata->state == ARCHE_PLATFORM_STATE_OFF)
@@ -517,8 +380,6 @@ static ssize_t state_show(struct device *dev,
 		return sprintf(buf, "standby\n");
 	case ARCHE_PLATFORM_STATE_FW_FLASHING:
 		return sprintf(buf, "fw_flashing\n");
-	case ARCHE_PLATFORM_STATE_TIME_SYNC:
-		return sprintf(buf, "time_sync\n");
 	default:
 		return sprintf(buf, "unknown state\n");
 	}
@@ -665,7 +526,6 @@ static int arche_platform_probe(struct platform_device *pdev)
 
 	spin_lock_init(&arche_pdata->wake_lock);
 	mutex_init(&arche_pdata->platform_state_mutex);
-	init_waitqueue_head(&arche_pdata->wq);
 	arche_pdata->wake_detect_irq =
 		gpio_to_irq(arche_pdata->wake_detect_gpio);
 
@@ -701,9 +561,6 @@ static int arche_platform_probe(struct platform_device *pdev)
 		goto err_device_remove;
 	}
 
-	/* Register callback pointer */
-	arche_platform_change_state_cb = arche_platform_change_state;
-
 	/* Explicitly power off if requested */
 	if (!of_property_read_bool(pdev->dev.of_node, "arche,init-off")) {
 		mutex_lock(&arche_pdata->platform_state_mutex);

commit 461ab8077d573d4a35529572c774a71e5a898a84
Author: Gioh Kim <gi-oh.kim@profitbricks.com>
Date:   Thu Feb 9 17:30:11 2017 +0100

    staging: greybus: fix "line over 80 characters" coding style issues
    
    This patch fixes only obvious lines.
    There are still more issues.
    
    Signed-off-by: Gioh Kim <gi-oh.kim@profitbricks.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/arche-platform.c b/drivers/staging/greybus/arche-platform.c
index 338c2d3ee842..aac1145f1983 100644
--- a/drivers/staging/greybus/arche-platform.c
+++ b/drivers/staging/greybus/arche-platform.c
@@ -312,9 +312,11 @@ static irqreturn_t arche_platform_wd_irq(int irq, void *devid)
 		if (arche_pdata->wake_detect_state == WD_STATE_IDLE) {
 			arche_pdata->wake_detect_start = jiffies;
 			/*
-			 * In the begining, when wake/detect goes low (first time), we assume
-			 * it is meant for coldboot and set the flag. If wake/detect line stays low
-			 * beyond 30msec, then it is coldboot else fallback to standby boot.
+			 * In the begining, when wake/detect goes low
+			 * (first time), we assume it is meant for coldboot
+			 * and set the flag. If wake/detect line stays low
+			 * beyond 30msec, then it is coldboot else fallback
+			 * to standby boot.
 			 */
 			arche_platform_set_wake_detect_state(arche_pdata,
 							     WD_STATE_BOOT_INIT);
@@ -330,7 +332,8 @@ static irqreturn_t arche_platform_wd_irq(int irq, void *devid)
 /*
  * Requires arche_pdata->platform_state_mutex to be held
  */
-static int arche_platform_coldboot_seq(struct arche_platform_drvdata *arche_pdata)
+static int
+arche_platform_coldboot_seq(struct arche_platform_drvdata *arche_pdata)
 {
 	int ret;
 
@@ -364,7 +367,8 @@ static int arche_platform_coldboot_seq(struct arche_platform_drvdata *arche_pdat
 /*
  * Requires arche_pdata->platform_state_mutex to be held
  */
-static int arche_platform_fw_flashing_seq(struct arche_platform_drvdata *arche_pdata)
+static int
+arche_platform_fw_flashing_seq(struct arche_platform_drvdata *arche_pdata)
 {
 	int ret;
 
@@ -398,7 +402,8 @@ static int arche_platform_fw_flashing_seq(struct arche_platform_drvdata *arche_p
 /*
  * Requires arche_pdata->platform_state_mutex to be held
  */
-static void arche_platform_poweroff_seq(struct arche_platform_drvdata *arche_pdata)
+static void
+arche_platform_poweroff_seq(struct arche_platform_drvdata *arche_pdata)
 {
 	unsigned long flags;
 
@@ -561,14 +566,17 @@ static int arche_platform_probe(struct platform_device *pdev)
 	struct device_node *np = dev->of_node;
 	int ret;
 
-	arche_pdata = devm_kzalloc(&pdev->dev, sizeof(*arche_pdata), GFP_KERNEL);
+	arche_pdata = devm_kzalloc(&pdev->dev, sizeof(*arche_pdata),
+				   GFP_KERNEL);
 	if (!arche_pdata)
 		return -ENOMEM;
 
 	/* setup svc reset gpio */
 	arche_pdata->is_reset_act_hi = of_property_read_bool(np,
 					"svc,reset-active-high");
-	arche_pdata->svc_reset_gpio = of_get_named_gpio(np, "svc,reset-gpio", 0);
+	arche_pdata->svc_reset_gpio = of_get_named_gpio(np,
+							"svc,reset-gpio",
+							0);
 	if (arche_pdata->svc_reset_gpio < 0) {
 		dev_err(dev, "failed to get reset-gpio\n");
 		return arche_pdata->svc_reset_gpio;
@@ -610,7 +618,8 @@ static int arche_platform_probe(struct platform_device *pdev)
 		dev_err(dev, "failed to get svc clock-req gpio\n");
 		return arche_pdata->svc_refclk_req;
 	}
-	ret = devm_gpio_request(dev, arche_pdata->svc_refclk_req, "svc-clk-req");
+	ret = devm_gpio_request(dev, arche_pdata->svc_refclk_req,
+				"svc-clk-req");
 	if (ret) {
 		dev_err(dev, "failed to request svc-clk-req gpio: %d\n", ret);
 		return ret;
@@ -634,13 +643,16 @@ static int arche_platform_probe(struct platform_device *pdev)
 	arche_pdata->num_apbs = of_get_child_count(np);
 	dev_dbg(dev, "Number of APB's available - %d\n", arche_pdata->num_apbs);
 
-	arche_pdata->wake_detect_gpio = of_get_named_gpio(np, "svc,wake-detect-gpio", 0);
+	arche_pdata->wake_detect_gpio = of_get_named_gpio(np,
+							  "svc,wake-detect-gpio",
+							  0);
 	if (arche_pdata->wake_detect_gpio < 0) {
 		dev_err(dev, "failed to get wake detect gpio\n");
 		return arche_pdata->wake_detect_gpio;
 	}
 
-	ret = devm_gpio_request(dev, arche_pdata->wake_detect_gpio, "wake detect");
+	ret = devm_gpio_request(dev, arche_pdata->wake_detect_gpio,
+				"wake detect");
 	if (ret) {
 		dev_err(dev, "Failed requesting wake_detect gpio %d\n",
 				arche_pdata->wake_detect_gpio);
@@ -658,10 +670,11 @@ static int arche_platform_probe(struct platform_device *pdev)
 		gpio_to_irq(arche_pdata->wake_detect_gpio);
 
 	ret = devm_request_threaded_irq(dev, arche_pdata->wake_detect_irq,
-			arche_platform_wd_irq,
-			arche_platform_wd_irq_thread,
-			IRQF_TRIGGER_FALLING | IRQF_TRIGGER_RISING | IRQF_ONESHOT,
-			dev_name(dev), arche_pdata);
+					arche_platform_wd_irq,
+					arche_platform_wd_irq_thread,
+					IRQF_TRIGGER_FALLING |
+					IRQF_TRIGGER_RISING | IRQF_ONESHOT,
+					dev_name(dev), arche_pdata);
 	if (ret) {
 		dev_err(dev, "failed to request wake detect IRQ %d\n", ret);
 		return ret;

commit ce0347c2b089eb6ad6c14ab628a0ba5eb42f1492
Merge: abbdc56b17d6 a25f0944ba9b
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon Nov 14 08:53:56 2016 +0100

    Merge 4.9-rc5 into staging-next
    
    We want the staging/iio fixes in here as well to resolve issues and
    merge problems.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit d9966f1de990577b49903061cfcea2d1e85353fb
Author: Johan Hovold <johan@kernel.org>
Date:   Tue Nov 1 11:55:02 2016 +0100

    staging: greybus: arche-platform: fix device reference leak
    
    Make sure to drop the device reference taken by of_find_device_by_node()
    before returning from arche_platform_change_state().
    
    Note that this code is expected to be removed, but let's fix up the leak
    nonetheless.
    
    Fixes: 886aba558b9e ("greybus: arche-platform: Export fn to allow...")
    Signed-off-by: Johan Hovold <johan@kernel.org>
    Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
    Reviewed-by: Vaibhav Hiremath <hvaibhav.linux@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/arche-platform.c b/drivers/staging/greybus/arche-platform.c
index 34307ac3f255..d33d6fe078ad 100644
--- a/drivers/staging/greybus/arche-platform.c
+++ b/drivers/staging/greybus/arche-platform.c
@@ -186,6 +186,7 @@ int arche_platform_change_state(enum arche_platform_state state,
 exit:
 	spin_unlock_irqrestore(&arche_pdata->wake_lock, flags);
 	mutex_unlock(&arche_pdata->platform_state_mutex);
+	put_device(&pdev->dev);
 	of_node_put(np);
 	return ret;
 }

commit bdc065666a591fddc4e55cbdcd6c7b02f289b5ff
Merge: 32774ef3e4bb a909d3e63699
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Sun Oct 30 06:38:44 2016 -0400

    Merge 4.9-rc3 into staging-next
    
    This resolves a merge issue with
    drivers/staging/iio/accel/sca3000_core.c and we want the fixes all in
    here as well.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 25633d1f5dd7ea35c77aae12c039a80e46abec01
Author: Wei Yongjun <weiyongjun1@huawei.com>
Date:   Mon Oct 17 16:37:20 2016 +0000

    greybus: arche-platform: Add missing of_node_put() in arche_platform_change_state()
    
    This node pointer is returned by of_find_compatible_node() with
    refcount incremented in this function. of_node_put() on it before
    exitting this function.
    
    This is detected by Coccinelle semantic patch.
    
    Signed-off-by: Wei Yongjun <weiyongjun1@huawei.com>
    Acked-by: Johan Hovold <johan@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/arche-platform.c b/drivers/staging/greybus/arche-platform.c
index e36ee984485b..34307ac3f255 100644
--- a/drivers/staging/greybus/arche-platform.c
+++ b/drivers/staging/greybus/arche-platform.c
@@ -128,6 +128,7 @@ int arche_platform_change_state(enum arche_platform_state state,
 	pdev = of_find_device_by_node(np);
 	if (!pdev) {
 		pr_err("arche-platform device not found\n");
+		of_node_put(np);
 		return -ENODEV;
 	}
 

commit cf3ba55dca149b0525063a9c6127d0407e4fe8a8
Author: Elise Lennion <elise.lennion@gmail.com>
Date:   Wed Oct 12 14:16:34 2016 -0300

    staging: greybus: arche-platform: Format block comments.
    
    Fix checkpatch warning:
    
    WARNING: Block comments use a trailing */ on a separate line
    
    Signed-off-by: Elise Lennion <elise.lennion@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/arche-platform.c b/drivers/staging/greybus/arche-platform.c
index e36ee984485b..a850f6bd84c1 100644
--- a/drivers/staging/greybus/arche-platform.c
+++ b/drivers/staging/greybus/arche-platform.c
@@ -455,7 +455,8 @@ static ssize_t state_store(struct device *dev,
 			goto exit;
 
 		/* First we want to make sure we power off everything
-		 * and then activate back again */
+		 * and then activate back again
+		 */
 		device_for_each_child(arche_pdata->dev, NULL, apb_poweroff);
 		arche_platform_poweroff_seq(arche_pdata);
 

commit cdcffc0cdf553500dca22d93e3a87e2e0848aa83
Author: Eva Rachel Retuya <eraretuya@gmail.com>
Date:   Thu Sep 22 23:33:34 2016 +0800

    staging: greybus: arche-platform: declare struct of_device_id as const
    
    Declare the arrays 'arche_platform_of_match' and 'arche_combined_id' as const.
    
    'arche_platform_of_match' is only stored in the .of_match_table field of a
    device_driver structure, which is declared as const.
    
    'arche_combined_id' is passed to MODULE_DEVICE_TABLE. This macro does not
    modify the array and therefore the array can be declared as const. Checkpatch
    pointed out both issues.
    
    WARNING: struct of_device_id should be normally const
    
    Signed-off-by: Eva Rachel Retuya <eraretuya@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/arche-platform.c b/drivers/staging/greybus/arche-platform.c
index d6b36099d8ea..e36ee984485b 100644
--- a/drivers/staging/greybus/arche-platform.c
+++ b/drivers/staging/greybus/arche-platform.c
@@ -776,12 +776,12 @@ static SIMPLE_DEV_PM_OPS(arche_platform_pm_ops,
 			arche_platform_suspend,
 			arche_platform_resume);
 
-static struct of_device_id arche_platform_of_match[] = {
+static const struct of_device_id arche_platform_of_match[] = {
 	{ .compatible = "google,arche-platform", }, /* Use PID/VID of SVC device */
 	{ },
 };
 
-static struct of_device_id arche_combined_id[] = {
+static const struct of_device_id arche_combined_id[] = {
 	{ .compatible = "google,arche-platform", }, /* Use PID/VID of SVC device */
 	{ .compatible = "usbffff,2", },
 	{ },

commit 5a420d15d15b0eb46672578baa268675c63962f7
Author: Eva Rachel Retuya <eraretuya@gmail.com>
Date:   Wed Sep 21 13:07:04 2016 +0800

    staging: greybus: arche-platform: compress return logic into one line
    
    Modify return statement to use the value being returned directly instead of
    assigning it first to 'ret' and returning this variable. Coccinelle semantic
    patch used:
    
    @@
    expression e;
    local idexpression ret;
    @@
    
    -ret =
    +return
            e;
    -return ret;
    
    Signed-off-by: Eva Rachel Retuya <eraretuya@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/greybus/arche-platform.c b/drivers/staging/greybus/arche-platform.c
index 9d9048e6aed3..d6b36099d8ea 100644
--- a/drivers/staging/greybus/arche-platform.c
+++ b/drivers/staging/greybus/arche-platform.c
@@ -634,8 +634,7 @@ static int arche_platform_probe(struct platform_device *pdev)
 	arche_pdata->wake_detect_gpio = of_get_named_gpio(np, "svc,wake-detect-gpio", 0);
 	if (arche_pdata->wake_detect_gpio < 0) {
 		dev_err(dev, "failed to get wake detect gpio\n");
-		ret = arche_pdata->wake_detect_gpio;
-		return ret;
+		return arche_pdata->wake_detect_gpio;
 	}
 
 	ret = devm_gpio_request(dev, arche_pdata->wake_detect_gpio, "wake detect");

commit 921dbe52b40b2573d9a0e8337c768930bef25fb4
Author: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
Date:   Thu Jul 28 13:47:37 2016 +0530

    greybus: arche-platform: Add support for SPI bus sharing for Mihi
    
    In case of Mihi, SPI bus is shared between APB1 and APB2
    SPI ROMs, so their FW flashing must be sequential and
    arche-platform driver should make sure that they are mutual
    exclusive in nature.
    
    So this patch adds certain restrictions to the user of the
    arche-platform driver,
    
     - User can no longer flash APB1 and APB2 SPI ROM in parallel
     - SPI bus becomes an resource, so user must claim it by moving
       respective APB device into FW_FLASHING mode and release it
       by exiting FW_FLASHING mode. User can exit FW_FLASHING mode by
       switching to any other modes (ACTIVE, OFF, STANDBY).
     - If APB1 is in FW_FLASHING mode, APB2 can no longer enter into
       FW_FLASHING mode. User will get -EBUSY.
    
    Having said that, while APB1 is into FW_FLASHING mode,
    APB2 can independently boot from its own SPI ROM.
    
    Testing Done: Tested by simulating usecase on EVT2.
     - Made sure that APB1 and APB2 FW_FLASHING mode is mutual exclusive
       in nature. Confirmed that an attempt on second device return -EBUSY.
     - Added simulating code, where printed state of dummy gpio for
       spi-en and verified that it shows right pin status for both APBs
    
    Signed-off-by: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/arche-platform.c b/drivers/staging/greybus/arche-platform.c
index adec1fdcb5bb..9d9048e6aed3 100644
--- a/drivers/staging/greybus/arche-platform.c
+++ b/drivers/staging/greybus/arche-platform.c
@@ -215,18 +215,6 @@ static int apb_cold_boot(struct device *dev, void *data)
 	return 0;
 }
 
-static int apb_fw_flashing_state(struct device *dev, void *data)
-{
-	int ret;
-
-	ret = apb_ctrl_fw_flashing(dev);
-	if (ret)
-		dev_warn(dev, "failed to switch to fw flashing state\n");
-
-	/*Child nodes are independent, so do not exit coldboot operation */
-	return 0;
-}
-
 static int apb_poweroff(struct device *dev, void *data)
 {
 	apb_ctrl_poweroff(dev);
@@ -485,17 +473,18 @@ static ssize_t state_store(struct device *dev,
 		if (arche_pdata->state == ARCHE_PLATFORM_STATE_FW_FLASHING)
 			goto exit;
 
-		/* First we want to make sure we power off everything
-		 * and then enter FW flashing state */
-		device_for_each_child(arche_pdata->dev, NULL, apb_poweroff);
-
+		/*
+		 * Here we only control SVC.
+		 *
+		 * In case of FW_FLASHING mode we do not want to control
+		 * APBs, as in case of V2, SPI bus is shared between both
+		 * the APBs. So let user chose which APB he wants to flash.
+		 */
 		arche_platform_poweroff_seq(arche_pdata);
 
 		ret = arche_platform_fw_flashing_seq(arche_pdata);
 		if (ret)
 			goto exit;
-
-		device_for_each_child(arche_pdata->dev, NULL, apb_fw_flashing_state);
 	} else {
 		dev_err(arche_pdata->dev, "unknown state\n");
 		ret = -EINVAL;

commit 8ef0b5383110977d81746cd0b09c3877d51c3a67
Author: Vaibhav Hiremath <hiremath_vaibhav@projectara.com>
Date:   Wed Aug 3 17:15:38 2016 +0530

    greybus: arche-platform: Reset SVC & APB only if turned off by SUSPEND_PREPARE
    
    There is possible race condition in arche platform driver for
    maintaining of ->state field, when shared with timesync driver.
    
    Assume device booted fine, all connected modules have been enumerated
    correctly. As part of suspend-resume operation we have pm_notifier
    callback, where we turn off SVC & APB and coldboot on resume.
    In the process of resume, all modules gets enumerated again, and
    timesync driver does come into picture everytime.
    So when timesync driver requests arche-platform to change the state
    to TIMESYNC and in the middle of sync operation, if suspend gets
    triggered, then execution lands into arche-platform->pm_notifier callback,
    leading to race condition in the driver, where it checks for (state != ACTIVE)
    in PM_SUSPEND_PREPARE and returns, but in PM_POST_SUSPEND it just simply
    coldboots SVC & APB, which would inbalance all resources (including IRQ).
    
    So we need a add check in PM_POST_SUSPEND, to make sure that, we only
    coldboot devices if they are in to off state,
    i.e. if (state != OFF) then return.
    
    Testing Done: Done regressive suspend/resume testing on EVT2 platform.
    Note that, I some time hit issue.
    
    Signed-off-by: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/arche-platform.c b/drivers/staging/greybus/arche-platform.c
index cbe8bdcabceb..adec1fdcb5bb 100644
--- a/drivers/staging/greybus/arche-platform.c
+++ b/drivers/staging/greybus/arche-platform.c
@@ -548,6 +548,9 @@ static int arche_platform_pm_notifier(struct notifier_block *notifier,
 		arche_platform_poweroff_seq(arche_pdata);
 		break;
 	case PM_POST_SUSPEND:
+		if (arche_pdata->state != ARCHE_PLATFORM_STATE_OFF)
+			break;
+
 		arche_platform_wd_irq_en(arche_pdata);
 		arche_platform_coldboot_seq(arche_pdata);
 		break;

commit d29b67d44a7cf6d02e7319c0e5a4b729a0aa00e7
Author: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
Date:   Tue Jul 19 13:31:46 2016 +0530

    greybus: arche-platform: Add support for init-off feature
    
    Disable wake_detect interrupt after request
    
    As part of SW-4344/SW-7061, now we are enabling FW flashing
    to all builds. That means check for need of FW upgrade is
    going to be present in all builds, and moving to FW_FlASHING
    mode from active is heavy operation; so the idea here is
    simplify this process and save the boot time due to switching
    back-n-forth between ACTIVE<=>FW_FLASHING modes.
    
    So we decided to put unipro into OFF state by default on boot,
    which can be changed through DT property. If arche-platform
    device node has "arche,init-off" property set, then unipro
    will be in OFF state on boot. User can bring it back by
    
     # echo active > /sys/devices/arche_platform*/state
    
    And to simply the exit code of probe() fn the
    arche_platform_coldboot_seq() has been shifted to the
    bottom of the _probe() fn.
    
    Testing Done: Tested on EVT2 platform, with and without
    "arche,init-off" property, multiple times.
    Note: I am seeing SW-7128, which is not related to these changes.
    
    Signed-off-by: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
    Tested-by: Michael Scott <michael.scott@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/arche-platform.c b/drivers/staging/greybus/arche-platform.c
index af784204973f..cbe8bdcabceb 100644
--- a/drivers/staging/greybus/arche-platform.c
+++ b/drivers/staging/greybus/arche-platform.c
@@ -672,8 +672,7 @@ static int arche_platform_probe(struct platform_device *pdev)
 		dev_err(dev, "failed to request wake detect IRQ %d\n", ret);
 		return ret;
 	}
-
-	gpio_direction_input(arche_pdata->wake_detect_gpio);
+	disable_irq(arche_pdata->wake_detect_irq);
 
 	ret = device_create_file(dev, &dev_attr_state);
 	if (ret) {
@@ -681,38 +680,41 @@ static int arche_platform_probe(struct platform_device *pdev)
 		return ret;
 	}
 
-	mutex_lock(&arche_pdata->platform_state_mutex);
-	ret = arche_platform_coldboot_seq(arche_pdata);
-	if (ret) {
-		dev_err(dev, "Failed to cold boot svc %d\n", ret);
-		goto err_coldboot;
-	}
-
 	ret = of_platform_populate(np, NULL, NULL, dev);
 	if (ret) {
 		dev_err(dev, "failed to populate child nodes %d\n", ret);
-		goto err_populate;
+		goto err_device_remove;
 	}
 
 	arche_pdata->pm_notifier.notifier_call = arche_platform_pm_notifier;
 	ret = register_pm_notifier(&arche_pdata->pm_notifier);
-	mutex_unlock(&arche_pdata->platform_state_mutex);
 
 	if (ret) {
 		dev_err(dev, "failed to register pm notifier %d\n", ret);
-		goto err_populate;
+		goto err_device_remove;
 	}
 
 	/* Register callback pointer */
 	arche_platform_change_state_cb = arche_platform_change_state;
 
+	/* Explicitly power off if requested */
+	if (!of_property_read_bool(pdev->dev.of_node, "arche,init-off")) {
+		mutex_lock(&arche_pdata->platform_state_mutex);
+		ret = arche_platform_coldboot_seq(arche_pdata);
+		if (ret) {
+			dev_err(dev, "Failed to cold boot svc %d\n", ret);
+			goto err_coldboot;
+		}
+		arche_platform_wd_irq_en(arche_pdata);
+		mutex_unlock(&arche_pdata->platform_state_mutex);
+	}
+
 	dev_info(dev, "Device registered successfully\n");
 	return 0;
 
-err_populate:
-	arche_platform_poweroff_seq(arche_pdata);
 err_coldboot:
 	mutex_unlock(&arche_pdata->platform_state_mutex);
+err_device_remove:
 	device_remove_file(&pdev->dev, &dev_attr_state);
 	return ret;
 }

commit 1f77b363bef417e28d8556a11c9a82f3e6cf24f0
Author: David Lin <dtwlin@google.com>
Date:   Tue Jul 12 17:41:21 2016 -0700

    greybus: hd: arche-platform: implement greybus shutdown
    
    Implement platform driver shutdown callback to perform proper greybus
    shutdown so that the userspace unipro_shutdown service that shuts down
    the APB/SVC abruptly can be removed. The shutdown callback in
    arche-platform will first remove SVC so that all the Interface can be
    Deactivated in a sequence according to the spec before powering off the
    APB:
    
    Before:
     -> Arche/APB power off
     -> SoC power off
    
    After this patch:
     -> HD shutdown
         -> SVC shutdown
             -> Module shutdown
                 -> Interface shutdown
                     -> Bundle shutdown
     -> Arche/APB power off
     -> SoC power off
    
    Testing Done:
     - Observe all Interfaces are deactivated in the log during shutdown
     - Measure power off current and make sure no regression
    
    Signed-off-by: David Lin <dtwlin@google.com>
    Reviewed-by: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
    Reviewed-by: Johan Hovold <johan@hovoldconsulting.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/arche-platform.c b/drivers/staging/greybus/arche-platform.c
index 31c952454cff..af784204973f 100644
--- a/drivers/staging/greybus/arche-platform.c
+++ b/drivers/staging/greybus/arche-platform.c
@@ -770,6 +770,15 @@ static int arche_platform_resume(struct device *dev)
 	return 0;
 }
 
+static void arche_platform_shutdown(struct platform_device *pdev)
+{
+	struct arche_platform_drvdata *arche_pdata = platform_get_drvdata(pdev);
+
+	arche_platform_poweroff_seq(arche_pdata);
+
+	usb3613_hub_mode_ctrl(false);
+}
+
 static SIMPLE_DEV_PM_OPS(arche_platform_pm_ops,
 			arche_platform_suspend,
 			arche_platform_resume);
@@ -789,6 +798,7 @@ MODULE_DEVICE_TABLE(of, arche_combined_id);
 static struct platform_driver arche_platform_device_driver = {
 	.probe		= arche_platform_probe,
 	.remove		= arche_platform_remove,
+	.shutdown	= arche_platform_shutdown,
 	.driver		= {
 		.name	= "arche-platform-ctrl",
 		.pm	= &arche_platform_pm_ops,

commit 970dc85bd95d931def5926ae81b5aa84ef14fb7c
Author: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
Date:   Sun Jun 5 14:03:26 2016 +0100

    greybus: timesync: Add timesync core driver
    
    This patch adds the core timesync functionality.
    
    0. arche-platform.c/arche-apb-ctrl.c
       Modifies the platform layer to hook the incoming TIME_SYNC signal up to
       the timesync strobe IRQ handler. If the arche-platform driver can't
       satisfy the request for the wake-detect line, it will return -EAGAIN and
       the calling work-queue must reschedule the attempt to get exclusive
       access to the wake-detect pin logic. A private data field is added to
       the arche-platform driver to enable passing of a timesync pointer to the
       ISR responsible for synchronizing time.
    
    1. timesync.c
       A new file added which contains all of the logic associated with sending
       greybus commands to SVC, APBx or Interfaces to enable, disable and
       disseminate timing information.
    
    2. timesync_platform.c
       Any platform/arch specific code goes into timesync_platform.c.
       Originally the idea was to keep the x86 and ARM arch dependencies in a
       timesync_platform_arch.c file - however with further refinement that's
       currently not necessary however just-in-case it becomes necessary to
       resuscitate arch or platform specific methods for accessing timer
       resources that access shouldn't be part of the core timesync.c logic and
       so for the moment we access these timer resources through a thin access
       layer in timesync_platform.c. Expect this to go away long term ideally.
    
    Signed-off-by: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
    Acked-by: Alex Elder <elder@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/arche-platform.c b/drivers/staging/greybus/arche-platform.c
index f47ea4670d25..31c952454cff 100644
--- a/drivers/staging/greybus/arche-platform.c
+++ b/drivers/staging/greybus/arche-platform.c
@@ -22,6 +22,7 @@
 #include <linux/suspend.h>
 #include <linux/time.h>
 #include "arche_platform.h"
+#include "greybus.h"
 
 #include <linux/usb/usb3613.h>
 
@@ -34,6 +35,7 @@ enum svc_wakedetect_state {
 	WD_STATE_STANDBYBOOT_TRIG,	/* As of now not used ?? */
 	WD_STATE_COLDBOOT_START,	/* Cold boot process started */
 	WD_STATE_STANDBYBOOT_START,	/* Not used */
+	WD_STATE_TIMESYNC,
 };
 
 struct arche_platform_drvdata {
@@ -57,13 +59,27 @@ struct arche_platform_drvdata {
 	int wake_detect_irq;
 	spinlock_t wake_lock;			/* Protect wake_detect_state */
 	struct mutex platform_state_mutex;	/* Protect state */
+	wait_queue_head_t wq;			/* WQ for arche_pdata->state */
 	unsigned long wake_detect_start;
 	struct notifier_block pm_notifier;
 
 	struct device *dev;
+	struct gb_timesync_svc *timesync_svc_pdata;
 };
 
-/* Requires calling context to hold arche_pdata->spinlock */
+static int arche_apb_bootret_assert(struct device *dev, void *data)
+{
+	apb_bootret_assert(dev);
+	return 0;
+}
+
+static int arche_apb_bootret_deassert(struct device *dev, void *data)
+{
+	apb_bootret_deassert(dev);
+	return 0;
+}
+
+/* Requires calling context to hold arche_pdata->platform_state_mutex */
 static void arche_platform_set_state(struct arche_platform_drvdata *arche_pdata,
 				     enum arche_platform_state state)
 {
@@ -94,7 +110,8 @@ static void arche_platform_set_state(struct arche_platform_drvdata *arche_pdata,
  * satisfy the requested state-transition or -EINVAL for all other
  * state-transition requests.
  */
-int arche_platform_change_state(enum arche_platform_state state)
+int arche_platform_change_state(enum arche_platform_state state,
+				struct gb_timesync_svc *timesync_svc_pdata)
 {
 	struct arche_platform_drvdata *arche_pdata;
 	struct platform_device *pdev;
@@ -118,11 +135,6 @@ int arche_platform_change_state(enum arche_platform_state state)
 
 	mutex_lock(&arche_pdata->platform_state_mutex);
 	spin_lock_irqsave(&arche_pdata->wake_lock, flags);
-	if (arche_pdata->wake_detect_state != WD_STATE_IDLE) {
-		dev_err(arche_pdata->dev,
-			"driver busy with wake/detect line ops\n");
-		goto  exit;
-	}
 
 	if (arche_pdata->state == state) {
 		ret = 0;
@@ -131,10 +143,27 @@ int arche_platform_change_state(enum arche_platform_state state)
 
 	switch (state) {
 	case ARCHE_PLATFORM_STATE_TIME_SYNC:
-		disable_irq(arche_pdata->wake_detect_irq);
+		if (arche_pdata->state != ARCHE_PLATFORM_STATE_ACTIVE) {
+			ret = -EINVAL;
+			goto exit;
+		}
+		if (arche_pdata->wake_detect_state != WD_STATE_IDLE) {
+			dev_err(arche_pdata->dev,
+				"driver busy with wake/detect line ops\n");
+			goto  exit;
+		}
+		device_for_each_child(arche_pdata->dev, NULL,
+				      arche_apb_bootret_assert);
+		arche_pdata->wake_detect_state = WD_STATE_TIMESYNC;
 		break;
 	case ARCHE_PLATFORM_STATE_ACTIVE:
-		enable_irq(arche_pdata->wake_detect_irq);
+		if (arche_pdata->state != ARCHE_PLATFORM_STATE_TIME_SYNC) {
+			ret = -EINVAL;
+			goto exit;
+		}
+		device_for_each_child(arche_pdata->dev, NULL,
+				      arche_apb_bootret_deassert);
+		arche_pdata->wake_detect_state = WD_STATE_IDLE;
 		break;
 	case ARCHE_PLATFORM_STATE_OFF:
 	case ARCHE_PLATFORM_STATE_STANDBY:
@@ -147,7 +176,11 @@ int arche_platform_change_state(enum arche_platform_state state)
 			"invalid state transition request\n");
 		goto exit;
 	}
+	arche_pdata->timesync_svc_pdata = timesync_svc_pdata;
 	arche_platform_set_state(arche_pdata, state);
+	if (state == ARCHE_PLATFORM_STATE_ACTIVE)
+		wake_up(&arche_pdata->wq);
+
 	ret = 0;
 exit:
 	spin_unlock_irqrestore(&arche_pdata->wake_lock, flags);
@@ -252,6 +285,11 @@ static irqreturn_t arche_platform_wd_irq(int irq, void *devid)
 
 	spin_lock_irqsave(&arche_pdata->wake_lock, flags);
 
+	if (arche_pdata->wake_detect_state == WD_STATE_TIMESYNC) {
+		gb_timesync_irq(arche_pdata->timesync_svc_pdata);
+		goto exit;
+	}
+
 	if (gpio_get_value(arche_pdata->wake_detect_gpio)) {
 		/* wake/detect rising */
 
@@ -293,6 +331,7 @@ static irqreturn_t arche_platform_wd_irq(int irq, void *devid)
 		}
 	}
 
+exit:
 	spin_unlock_irqrestore(&arche_pdata->wake_lock, flags);
 
 	return IRQ_HANDLED;
@@ -402,7 +441,17 @@ static ssize_t state_store(struct device *dev,
 	struct arche_platform_drvdata *arche_pdata = platform_get_drvdata(pdev);
 	int ret = 0;
 
+retry:
 	mutex_lock(&arche_pdata->platform_state_mutex);
+	if (arche_pdata->state == ARCHE_PLATFORM_STATE_TIME_SYNC) {
+		mutex_unlock(&arche_pdata->platform_state_mutex);
+		ret = wait_event_interruptible(
+			arche_pdata->wq,
+			arche_pdata->state != ARCHE_PLATFORM_STATE_TIME_SYNC);
+		if (ret)
+			return ret;
+		goto retry;
+	}
 
 	if (sysfs_streq(buf, "off")) {
 		if (arche_pdata->state == ARCHE_PLATFORM_STATE_OFF)
@@ -610,6 +659,7 @@ static int arche_platform_probe(struct platform_device *pdev)
 
 	spin_lock_init(&arche_pdata->wake_lock);
 	mutex_init(&arche_pdata->platform_state_mutex);
+	init_waitqueue_head(&arche_pdata->wq);
 	arche_pdata->wake_detect_irq =
 		gpio_to_irq(arche_pdata->wake_detect_gpio);
 
@@ -653,6 +703,9 @@ static int arche_platform_probe(struct platform_device *pdev)
 		goto err_populate;
 	}
 
+	/* Register callback pointer */
+	arche_platform_change_state_cb = arche_platform_change_state;
+
 	dev_info(dev, "Device registered successfully\n");
 	return 0;
 

commit 7a867d149f0c0cb9184a38f83704d37439a17f3e
Author: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
Date:   Tue May 24 18:32:04 2016 +0530

    greybus: arche-platform: Enable SVC clock during FW_FLASHING state
    
    The issue is, as part of kernel-only build we started seeing
    failures in SVC FW flashing. It was reproducible easily in kernel-only
    build, but never observed on Android build.
    
    During debugging, there were couple of observations,
    
    1. If SVC clock enabled and disables (which is REFCLK_MAIN), then SVC FW
       flashing works.
    2. If we do not switch SVC to HSE (external clock source) it works.
       Recently, SVC code has been updated to switch HSE clock, so removing
       it (remove/skip rcc_switch_ara_pll() fn) would use internal clock only.
    
    As per STM32 spec, for flashing through USART we do not need
    to enable HSE, but the above observation contradicts with it.
    
    There is still something missing in terms of understanding of how STM32
    device functions as far as Flashing is concerned. There is something
    hidden in HW, which probably still need to identify.
    
    So as a interim solution we will enable clock for FW_FLASHING state,
    which seems to be fixing the issue here.
    
    Testing Done: Tested on EVT1.5 with arche6.0 and kernel-only build.
    
    Signed-off-by: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
    Tested-by: Michael Scott <michael.scott@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/arche-platform.c b/drivers/staging/greybus/arche-platform.c
index 58b370774399..f47ea4670d25 100644
--- a/drivers/staging/greybus/arche-platform.c
+++ b/drivers/staging/greybus/arche-platform.c
@@ -337,6 +337,8 @@ static int arche_platform_coldboot_seq(struct arche_platform_drvdata *arche_pdat
  */
 static int arche_platform_fw_flashing_seq(struct arche_platform_drvdata *arche_pdata)
 {
+	int ret;
+
 	if (arche_pdata->state == ARCHE_PLATFORM_STATE_FW_FLASHING)
 		return 0;
 
@@ -348,6 +350,14 @@ static int arche_platform_fw_flashing_seq(struct arche_platform_drvdata *arche_p
 	gpio_set_value(arche_pdata->svc_sysboot_gpio, 1);
 
 	usleep_range(100, 200);
+
+	ret = clk_prepare_enable(arche_pdata->svc_ref_clk);
+	if (ret) {
+		dev_err(arche_pdata->dev, "failed to enable svc_ref_clk: %d\n",
+				ret);
+		return ret;
+	}
+
 	svc_reset_onoff(arche_pdata->svc_reset_gpio,
 			!arche_pdata->is_reset_act_hi);
 
@@ -374,10 +384,10 @@ static void arche_platform_poweroff_seq(struct arche_platform_drvdata *arche_pda
 		arche_platform_set_wake_detect_state(arche_pdata,
 						     WD_STATE_IDLE);
 		spin_unlock_irqrestore(&arche_pdata->wake_lock, flags);
-
-		clk_disable_unprepare(arche_pdata->svc_ref_clk);
 	}
 
+	clk_disable_unprepare(arche_pdata->svc_ref_clk);
+
 	/* As part of exit, put APB back in reset state */
 	svc_reset_onoff(arche_pdata->svc_reset_gpio,
 			arche_pdata->is_reset_act_hi);

commit 0b1283e33f7a38645c9d060ce2e2b24a44e3b125
Author: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
Date:   Tue May 24 18:32:03 2016 +0530

    greybus: arche-platform: Enter ACTIVE state only from OFF state
    
    Make sure that, transition to active state happens only from OFF state.
    Instead of imposing the restriction to user-space, driver internally
    switches to OFF state and then to ACTIVE state.
    
    Testing Done: Tested on EVT1.5 platform.
    
    Signed-off-by: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
    Tested-by: Michael Scott <michael.scott@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/arche-platform.c b/drivers/staging/greybus/arche-platform.c
index a8e36e1141fd..58b370774399 100644
--- a/drivers/staging/greybus/arche-platform.c
+++ b/drivers/staging/greybus/arche-platform.c
@@ -407,8 +407,15 @@ static ssize_t state_store(struct device *dev,
 		if (arche_pdata->state == ARCHE_PLATFORM_STATE_ACTIVE)
 			goto exit;
 
+		/* First we want to make sure we power off everything
+		 * and then activate back again */
+		device_for_each_child(arche_pdata->dev, NULL, apb_poweroff);
+		arche_platform_poweroff_seq(arche_pdata);
+
 		arche_platform_wd_irq_en(arche_pdata);
 		ret = arche_platform_coldboot_seq(arche_pdata);
+		if (ret)
+			goto exit;
 
 	} else if (sysfs_streq(buf, "standby")) {
 		if (arche_pdata->state == ARCHE_PLATFORM_STATE_STANDBY)

commit c61a8b49846ecc11f7959f573b9548f859bc73a5
Author: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
Date:   Tue May 24 18:32:02 2016 +0530

    greybus: arche-platform: Make fw_flashing_seq() return error
    
    Make arche_platform_fw_flashing_seq() return error value, needed
    later when we add clock enable support for FW flashing.
    
    Testing Done: Tested on EVT1.5 platform.
    
    Signed-off-by: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
    Tested-by: Michael Scott <michael.scott@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/arche-platform.c b/drivers/staging/greybus/arche-platform.c
index 4af34988e197..a8e36e1141fd 100644
--- a/drivers/staging/greybus/arche-platform.c
+++ b/drivers/staging/greybus/arche-platform.c
@@ -335,10 +335,10 @@ static int arche_platform_coldboot_seq(struct arche_platform_drvdata *arche_pdat
 /*
  * Requires arche_pdata->platform_state_mutex to be held
  */
-static void arche_platform_fw_flashing_seq(struct arche_platform_drvdata *arche_pdata)
+static int arche_platform_fw_flashing_seq(struct arche_platform_drvdata *arche_pdata)
 {
 	if (arche_pdata->state == ARCHE_PLATFORM_STATE_FW_FLASHING)
-		return;
+		return 0;
 
 	dev_info(arche_pdata->dev, "Switching to FW flashing state\n");
 
@@ -353,6 +353,7 @@ static void arche_platform_fw_flashing_seq(struct arche_platform_drvdata *arche_
 
 	arche_platform_set_state(arche_pdata, ARCHE_PLATFORM_STATE_FW_FLASHING);
 
+	return 0;
 }
 
 /*
@@ -424,7 +425,9 @@ static ssize_t state_store(struct device *dev,
 
 		arche_platform_poweroff_seq(arche_pdata);
 
-		arche_platform_fw_flashing_seq(arche_pdata);
+		ret = arche_platform_fw_flashing_seq(arche_pdata);
+		if (ret)
+			goto exit;
 
 		device_for_each_child(arche_pdata->dev, NULL, apb_fw_flashing_state);
 	} else {

commit d7be800f7ae9398055509b3a83d0ea3118e9277f
Author: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
Date:   Mon May 23 15:01:08 2016 +0100

    greybus: Fix unbalanced irq_enable() backtrace
    
    Tip-of-tree is exhibiting a backtrace when loading-up the set of greybus
    kernel modules due to calling arche_platform_wd_irq_en() directly after a
    call to devm_request_threaded_irq().
    
    At the point we call arch_platform_wd_irq_en() the relevant IRQ will
    already be enabled. What we want to do in this situation is configure the
    GPIO line as an input. This patch fixes the backtrace by supplanting
    arche_platform_wd_irq_en() with
    gpio_direction_input(arche_pdata->wake_detect_gpio) in
    arche_platform_probe().
    
    WARNING: at msm-ara-3.10/kernel/irq/manage.c:457 __enable_irq+0x74/0xc0()
    Unbalanced enable for IRQ 687
    Modules linked in: gb_arche(O+) gb_camera(O) gb_es2(O) gb_vibrator(O)
    gb_raw(O) gb_power_supply(O) gb_loopback(O) gb_light(O) gb_hid(O)
    greybus(O)
    CPU: 0 PID: 415 Comm: insmod Tainted: G        W  O 3.10.78-g2a4dec8 #65
    Call trace:
    [<ffffffc000206adc>] dump_backtrace+0x0/0x248
    [<ffffffc000206d34>] show_stack+0x10/0x1c
    [<ffffffc000c6c698>] dump_stack+0x1c/0x28
    [<ffffffc00021c95c>] warn_slowpath_common+0x74/0x9c
    [<ffffffc00021c9d0>] warn_slowpath_fmt+0x4c/0x58
    [<ffffffc000269d7c>] __enable_irq+0x70/0xc0
    [<ffffffc000269e34>] enable_irq+0x68/0x7c
    [<ffffffbffc0609b4>] arche_platform_probe+0x3b4/0x4f4 [gb_arche]
    [<ffffffc0005ace30>] platform_drv_probe+0x14/0x20
    [<ffffffc0005ab980>] driver_probe_device+0x160/0x374
    [<ffffffc0005abc40>] __driver_attach+0x60/0x90
    [<ffffffc0005aa768>] bus_for_each_dev+0x74/0x94
    [<ffffffc0005ab2c4>] driver_attach+0x1c/0x28
    [<ffffffc0005aae74>] bus_add_driver+0x124/0x248
    [<ffffffc0005ac270>] driver_register+0x94/0x110
    [<ffffffc0005ad3c4>] platform_driver_register+0x58/0x64
    [<ffffffbffc065020>] $x+0x20/0x58 [gb_arche]
    [<ffffffc0002007dc>] do_one_initcall+0xb0/0x14c
    [<ffffffc00028252c>] load_module+0x19d0/0x1b18
    [<ffffffc00028278c>] SyS_init_module+0x118/0x130
    
    Signed-off-by: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
    Reviewed-by: Vaibhav Hiremath <vaibhav.hiermath@linaro.org>
    Tested-by: Rui Miguel Silva <rui.silva@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/arche-platform.c b/drivers/staging/greybus/arche-platform.c
index bc450770771f..4af34988e197 100644
--- a/drivers/staging/greybus/arche-platform.c
+++ b/drivers/staging/greybus/arche-platform.c
@@ -603,7 +603,7 @@ static int arche_platform_probe(struct platform_device *pdev)
 		return ret;
 	}
 
-	arche_platform_wd_irq_en(arche_pdata);
+	gpio_direction_input(arche_pdata->wake_detect_gpio);
 
 	ret = device_create_file(dev, &dev_attr_state);
 	if (ret) {

commit 7ba535ec69ff670976e69adeec24dac2b65560ee
Author: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
Date:   Tue May 17 22:39:47 2016 +0530

    greybus: arche-platform: Rename assert_wakedetect=>arche_platform_wd_irq_en
    
    Now, since AP module does not send any signal to SVC, so it
    automatically restricts the wake/detect gpio to input.
    So rename assert_wakedetect() fn to arche_platform_wd_irq_en(),
    as per implementation.
    
    Testing Done: Tested on EVT1.5 platform.
    
    Signed-off-by: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
    Reviewed-by: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/arche-platform.c b/drivers/staging/greybus/arche-platform.c
index c02ff58ddefe..bc450770771f 100644
--- a/drivers/staging/greybus/arche-platform.c
+++ b/drivers/staging/greybus/arche-platform.c
@@ -205,7 +205,7 @@ static int apb_poweroff(struct device *dev, void *data)
 	return 0;
 }
 
-static void assert_wakedetect(struct arche_platform_drvdata *arche_pdata)
+static void arche_platform_wd_irq_en(struct arche_platform_drvdata *arche_pdata)
 {
 	/* Enable interrupt here, to read event back from SVC */
 	gpio_direction_input(arche_pdata->wake_detect_gpio);
@@ -406,7 +406,7 @@ static ssize_t state_store(struct device *dev,
 		if (arche_pdata->state == ARCHE_PLATFORM_STATE_ACTIVE)
 			goto exit;
 
-		assert_wakedetect(arche_pdata);
+		arche_platform_wd_irq_en(arche_pdata);
 		ret = arche_platform_coldboot_seq(arche_pdata);
 
 	} else if (sysfs_streq(buf, "standby")) {
@@ -479,7 +479,7 @@ static int arche_platform_pm_notifier(struct notifier_block *notifier,
 		arche_platform_poweroff_seq(arche_pdata);
 		break;
 	case PM_POST_SUSPEND:
-		assert_wakedetect(arche_pdata);
+		arche_platform_wd_irq_en(arche_pdata);
 		arche_platform_coldboot_seq(arche_pdata);
 		break;
 	default:
@@ -603,7 +603,7 @@ static int arche_platform_probe(struct platform_device *pdev)
 		return ret;
 	}
 
-	assert_wakedetect(arche_pdata);
+	arche_platform_wd_irq_en(arche_pdata);
 
 	ret = device_create_file(dev, &dev_attr_state);
 	if (ret) {

commit 16fd976c392bf2e9b88531e842d8d255bccddc98
Author: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
Date:   Tue May 17 22:39:46 2016 +0530

    greybus: arche-platform: Do not assert wake/detect signal to SVC
    
    With new definition of AP module boot flow (from HotPlug camp),
    AP is not supposed to send any wake/detect signal to SVC, instead,
    during boot SVC would straight away send wake_out pulse on wake/detect
    line.
    Note that, pin configuration of wake/detect line would be set to
    active-high by default, so wake/detect line would always stay high,
    unless SVC drives it. AP module uses wake/detect line strictly in input
    mode.
    
    Testing Done: Tested on EVT1.5 platform.
    
    Note: We are yet to decide on PM support for APBx, so we may need to
    generate/handshake with SVC over wake/detect line in the future. As of
    now, follow the implementation and add stuff as and when they come.
    
    Signed-off-by: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/arche-platform.c b/drivers/staging/greybus/arche-platform.c
index e3854349b36c..c02ff58ddefe 100644
--- a/drivers/staging/greybus/arche-platform.c
+++ b/drivers/staging/greybus/arche-platform.c
@@ -207,9 +207,6 @@ static int apb_poweroff(struct device *dev, void *data)
 
 static void assert_wakedetect(struct arche_platform_drvdata *arche_pdata)
 {
-	/* Assert wake/detect = Detect event from AP */
-	gpio_direction_output(arche_pdata->wake_detect_gpio, 1);
-
 	/* Enable interrupt here, to read event back from SVC */
 	gpio_direction_input(arche_pdata->wake_detect_gpio);
 	enable_irq(arche_pdata->wake_detect_irq);
@@ -371,9 +368,7 @@ static void arche_platform_poweroff_seq(struct arche_platform_drvdata *arche_pda
 	/* If in fw_flashing mode, then no need to repeate things again */
 	if (arche_pdata->state != ARCHE_PLATFORM_STATE_FW_FLASHING) {
 		disable_irq(arche_pdata->wake_detect_irq);
-		/* Send disconnect/detach event to SVC */
-		gpio_direction_output(arche_pdata->wake_detect_gpio, 0);
-		usleep_range(100, 200);
+
 		spin_lock_irqsave(&arche_pdata->wake_lock, flags);
 		arche_platform_set_wake_detect_state(arche_pdata,
 						     WD_STATE_IDLE);
@@ -411,9 +406,9 @@ static ssize_t state_store(struct device *dev,
 		if (arche_pdata->state == ARCHE_PLATFORM_STATE_ACTIVE)
 			goto exit;
 
+		assert_wakedetect(arche_pdata);
 		ret = arche_platform_coldboot_seq(arche_pdata);
 
-		assert_wakedetect(arche_pdata);
 	} else if (sysfs_streq(buf, "standby")) {
 		if (arche_pdata->state == ARCHE_PLATFORM_STATE_STANDBY)
 			goto exit;
@@ -484,8 +479,8 @@ static int arche_platform_pm_notifier(struct notifier_block *notifier,
 		arche_platform_poweroff_seq(arche_pdata);
 		break;
 	case PM_POST_SUSPEND:
-		arche_platform_coldboot_seq(arche_pdata);
 		assert_wakedetect(arche_pdata);
+		arche_platform_coldboot_seq(arche_pdata);
 		break;
 	default:
 		break;
@@ -588,8 +583,7 @@ static int arche_platform_probe(struct platform_device *pdev)
 				arche_pdata->wake_detect_gpio);
 		return ret;
 	}
-	/* deassert wake detect */
-	gpio_direction_output(arche_pdata->wake_detect_gpio, 0);
+
 	arche_platform_set_wake_detect_state(arche_pdata, WD_STATE_IDLE);
 
 	arche_pdata->dev = &pdev->dev;
@@ -608,8 +602,8 @@ static int arche_platform_probe(struct platform_device *pdev)
 		dev_err(dev, "failed to request wake detect IRQ %d\n", ret);
 		return ret;
 	}
-	/* Enable it only after  sending wake/detect event */
-	disable_irq(arche_pdata->wake_detect_irq);
+
+	assert_wakedetect(arche_pdata);
 
 	ret = device_create_file(dev, &dev_attr_state);
 	if (ret) {
@@ -630,8 +624,6 @@ static int arche_platform_probe(struct platform_device *pdev)
 		goto err_populate;
 	}
 
-	assert_wakedetect(arche_pdata);
-
 	arche_pdata->pm_notifier.notifier_call = arche_platform_pm_notifier;
 	ret = register_pm_notifier(&arche_pdata->pm_notifier);
 	mutex_unlock(&arche_pdata->platform_state_mutex);

commit a974f469ff097f8f6e242f3ef5b26ba3604fbaf2
Author: Sandeep Patil <sspatil@google.com>
Date:   Fri May 13 12:00:56 2016 -0700

    greybus: arche-platform: Fix the MODULE_LICENSE to match with header
    
    The header calls out the license to be GPL v2, while the module declares
    itself as "GPL"
    
    Testing Done: Trivial
    
    Signed-off-by: Sandeep Patil <sspatil@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/arche-platform.c b/drivers/staging/greybus/arche-platform.c
index 83d823cf5232..e3854349b36c 100644
--- a/drivers/staging/greybus/arche-platform.c
+++ b/drivers/staging/greybus/arche-platform.c
@@ -754,6 +754,6 @@ static void __exit arche_exit(void)
 }
 module_exit(arche_exit);
 
-MODULE_LICENSE("GPL");
+MODULE_LICENSE("GPL v2");
 MODULE_AUTHOR("Vaibhav Hiremath <vaibhav.hiremath@linaro.org>");
 MODULE_DESCRIPTION("Arche Platform Driver");

commit c4058b7926a44387b1d2480be0f209edb74e7f1c
Author: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
Date:   Thu May 5 15:34:59 2016 +0100

    greybus: arche-platform: Rework platform/wd-line state transition logic
    
    This patch simplifies and improves the readability of the internal state
    transition logic of arche platform driver state transition logic by:
    
    1. Making a dedicated function to state-transition the platform code.
    2. Condense the decision to swtich states down to a single switch
       statement instead of four separate if/else clauses.
    
    Signed-off-by: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
    Suggested-by: Alex Elder <elder@linaro.org>
    Reviewed-by: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/arche-platform.c b/drivers/staging/greybus/arche-platform.c
index 4eceec39ae99..83d823cf5232 100644
--- a/drivers/staging/greybus/arche-platform.c
+++ b/drivers/staging/greybus/arche-platform.c
@@ -63,6 +63,13 @@ struct arche_platform_drvdata {
 	struct device *dev;
 };
 
+/* Requires calling context to hold arche_pdata->spinlock */
+static void arche_platform_set_state(struct arche_platform_drvdata *arche_pdata,
+				     enum arche_platform_state state)
+{
+	arche_pdata->state = state;
+}
+
 /*
  * arche_platform_change_state: Change the operational state
  *
@@ -122,22 +129,26 @@ int arche_platform_change_state(enum arche_platform_state state)
 		goto exit;
 	}
 
-	if (arche_pdata->state == ARCHE_PLATFORM_STATE_OFF ||
-	    arche_pdata->state == ARCHE_PLATFORM_STATE_STANDBY ||
-	    arche_pdata->state == ARCHE_PLATFORM_STATE_FW_FLASHING) {
-		dev_err(arche_pdata->dev, "busy, request to retry later\n");
-		goto exit;
-	}
-
-	if (state == ARCHE_PLATFORM_STATE_TIME_SYNC) {
+	switch (state) {
+	case ARCHE_PLATFORM_STATE_TIME_SYNC:
 		disable_irq(arche_pdata->wake_detect_irq);
-		arche_pdata->state = ARCHE_PLATFORM_STATE_TIME_SYNC;
-	} else if (state == ARCHE_PLATFORM_STATE_ACTIVE) {
-		arche_pdata->state = ARCHE_PLATFORM_STATE_ACTIVE;
+		break;
+	case ARCHE_PLATFORM_STATE_ACTIVE:
 		enable_irq(arche_pdata->wake_detect_irq);
-	} else {
-		dev_err(arche_pdata->dev, "invalid state transition request\n");
+		break;
+	case ARCHE_PLATFORM_STATE_OFF:
+	case ARCHE_PLATFORM_STATE_STANDBY:
+	case ARCHE_PLATFORM_STATE_FW_FLASHING:
+		dev_err(arche_pdata->dev, "busy, request to retry later\n");
+		goto exit;
+	default:
+		ret = -EINVAL;
+		dev_err(arche_pdata->dev,
+			"invalid state transition request\n");
+		goto exit;
 	}
+	arche_platform_set_state(arche_pdata, state);
+	ret = 0;
 exit:
 	spin_unlock_irqrestore(&arche_pdata->wake_lock, flags);
 	mutex_unlock(&arche_pdata->platform_state_mutex);
@@ -146,6 +157,14 @@ int arche_platform_change_state(enum arche_platform_state state)
 }
 EXPORT_SYMBOL_GPL(arche_platform_change_state);
 
+/* Requires arche_pdata->wake_lock is held by calling context */
+static void arche_platform_set_wake_detect_state(
+				struct arche_platform_drvdata *arche_pdata,
+				enum svc_wakedetect_state state)
+{
+	arche_pdata->wake_detect_state = state;
+}
+
 static inline void svc_reset_onoff(unsigned int gpio, bool onoff)
 {
 	gpio_set_value(gpio, onoff);
@@ -208,7 +227,8 @@ static irqreturn_t arche_platform_wd_irq_thread(int irq, void *devid)
 		return IRQ_HANDLED;
 	}
 
-	arche_pdata->wake_detect_state = WD_STATE_COLDBOOT_START;
+	arche_platform_set_wake_detect_state(arche_pdata,
+					     WD_STATE_COLDBOOT_START);
 	spin_unlock_irqrestore(&arche_pdata->wake_lock, flags);
 
 	/* It should complete power cycle, so first make sure it is poweroff */
@@ -222,7 +242,7 @@ static irqreturn_t arche_platform_wd_irq_thread(int irq, void *devid)
 		dev_warn(arche_pdata->dev, "failed to control hub device\n");
 
 	spin_lock_irqsave(&arche_pdata->wake_lock, flags);
-	arche_pdata->wake_detect_state = WD_STATE_IDLE;
+	arche_platform_set_wake_detect_state(arche_pdata, WD_STATE_IDLE);
 	spin_unlock_irqrestore(&arche_pdata->wake_lock, flags);
 
 	return IRQ_HANDLED;
@@ -247,13 +267,14 @@ static irqreturn_t arche_platform_wd_irq(int irq, void *devid)
 			if (time_before(jiffies,
 					arche_pdata->wake_detect_start +
 					msecs_to_jiffies(WD_COLDBOOT_PULSE_WIDTH_MS))) {
-				arche_pdata->wake_detect_state = WD_STATE_IDLE;
+				arche_platform_set_wake_detect_state(arche_pdata,
+								     WD_STATE_IDLE);
 			} else {
 				/* Check we are not in middle of irq thread already */
 				if (arche_pdata->wake_detect_state !=
 						WD_STATE_COLDBOOT_START) {
-					arche_pdata->wake_detect_state =
-						WD_STATE_COLDBOOT_TRIG;
+					arche_platform_set_wake_detect_state(arche_pdata,
+									     WD_STATE_COLDBOOT_TRIG);
 					spin_unlock_irqrestore(
 						&arche_pdata->wake_lock,
 						flags);
@@ -270,7 +291,8 @@ static irqreturn_t arche_platform_wd_irq(int irq, void *devid)
 			 * it is meant for coldboot and set the flag. If wake/detect line stays low
 			 * beyond 30msec, then it is coldboot else fallback to standby boot.
 			 */
-			arche_pdata->wake_detect_state = WD_STATE_BOOT_INIT;
+			arche_platform_set_wake_detect_state(arche_pdata,
+							     WD_STATE_BOOT_INIT);
 		}
 	}
 
@@ -308,7 +330,7 @@ static int arche_platform_coldboot_seq(struct arche_platform_drvdata *arche_pdat
 	svc_reset_onoff(arche_pdata->svc_reset_gpio,
 			!arche_pdata->is_reset_act_hi);
 
-	arche_pdata->state = ARCHE_PLATFORM_STATE_ACTIVE;
+	arche_platform_set_state(arche_pdata, ARCHE_PLATFORM_STATE_ACTIVE);
 
 	return 0;
 }
@@ -332,7 +354,7 @@ static void arche_platform_fw_flashing_seq(struct arche_platform_drvdata *arche_
 	svc_reset_onoff(arche_pdata->svc_reset_gpio,
 			!arche_pdata->is_reset_act_hi);
 
-	arche_pdata->state = ARCHE_PLATFORM_STATE_FW_FLASHING;
+	arche_platform_set_state(arche_pdata, ARCHE_PLATFORM_STATE_FW_FLASHING);
 
 }
 
@@ -353,7 +375,8 @@ static void arche_platform_poweroff_seq(struct arche_platform_drvdata *arche_pda
 		gpio_direction_output(arche_pdata->wake_detect_gpio, 0);
 		usleep_range(100, 200);
 		spin_lock_irqsave(&arche_pdata->wake_lock, flags);
-		arche_pdata->wake_detect_state = WD_STATE_IDLE;
+		arche_platform_set_wake_detect_state(arche_pdata,
+						     WD_STATE_IDLE);
 		spin_unlock_irqrestore(&arche_pdata->wake_lock, flags);
 
 		clk_disable_unprepare(arche_pdata->svc_ref_clk);
@@ -363,7 +386,7 @@ static void arche_platform_poweroff_seq(struct arche_platform_drvdata *arche_pda
 	svc_reset_onoff(arche_pdata->svc_reset_gpio,
 			arche_pdata->is_reset_act_hi);
 
-	arche_pdata->state = ARCHE_PLATFORM_STATE_OFF;
+	arche_platform_set_state(arche_pdata, ARCHE_PLATFORM_STATE_OFF);
 }
 
 static ssize_t state_store(struct device *dev,
@@ -502,7 +525,7 @@ static int arche_platform_probe(struct platform_device *pdev)
 		dev_err(dev, "failed to set svc-reset gpio dir:%d\n", ret);
 		return ret;
 	}
-	arche_pdata->state = ARCHE_PLATFORM_STATE_OFF;
+	arche_platform_set_state(arche_pdata, ARCHE_PLATFORM_STATE_OFF);
 
 	arche_pdata->svc_sysboot_gpio = of_get_named_gpio(np,
 					"svc,sysboot-gpio", 0);
@@ -567,7 +590,7 @@ static int arche_platform_probe(struct platform_device *pdev)
 	}
 	/* deassert wake detect */
 	gpio_direction_output(arche_pdata->wake_detect_gpio, 0);
-	arche_pdata->wake_detect_state = WD_STATE_IDLE;
+	arche_platform_set_wake_detect_state(arche_pdata, WD_STATE_IDLE);
 
 	arche_pdata->dev = &pdev->dev;
 

commit 886aba558b9e63c7025cabfaff8ca17f9fc02985
Author: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
Date:   Thu May 5 15:34:58 2016 +0100

    greybus: arche-platform: Export fn to allow timesync driver to change the state
    
    With the addition of the timesync driver and looking at the hardware
    interfaces we have, its clear we need to add a new arche-platform state.
    
    This patch adds ARCHE_PLATFORM_STATE_TIME_SYNC to the arche-platform driver
    to facilitate transition to the TIME_SYNC state if-and-only-if the
    arche-platform driver is in the ACTIVE state.
    
    This is mainly needed as wake/detect lines are shared between TIMESYNC
    operation and basic control functionality of APBs. So during TIMESYNC
    we want to make sure that the events on wake/detect lines are
    ignored by the arche-platform APB reset logic.
    
    This patch adds one exported function, which can be invoked from
    timesync driver code, allowing, switching between
    ARCHE_PLATFORM_STATE_TIME_SYNC <=> ARCHE_PLATFORM_STATE_ACTIVE states.
    
    [ bryan.odonoghue@linaro.org: Added mutex, massaged commit text ]
    
    Reviewed-by: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
    Signed-off-by: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
    Signed-off-by: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
    Suggested-by: Alex Elder <elder@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/arche-platform.c b/drivers/staging/greybus/arche-platform.c
index 9a117176ad50..4eceec39ae99 100644
--- a/drivers/staging/greybus/arche-platform.c
+++ b/drivers/staging/greybus/arche-platform.c
@@ -55,13 +55,97 @@ struct arche_platform_drvdata {
 
 	enum svc_wakedetect_state wake_detect_state;
 	int wake_detect_irq;
-	spinlock_t wake_lock;	/* Protect wake_detect_state */
+	spinlock_t wake_lock;			/* Protect wake_detect_state */
+	struct mutex platform_state_mutex;	/* Protect state */
 	unsigned long wake_detect_start;
 	struct notifier_block pm_notifier;
 
 	struct device *dev;
 };
 
+/*
+ * arche_platform_change_state: Change the operational state
+ *
+ * This exported function allows external drivers to change the state
+ * of the arche-platform driver.
+ * Note that this function only supports transitions between two states
+ * with limited functionality.
+ *
+ *  - ARCHE_PLATFORM_STATE_TIME_SYNC:
+ *    Once set, allows timesync operations between SVC <=> AP and makes
+ *    sure that arche-platform driver ignores any subsequent events/pulses
+ *    from SVC over wake/detect.
+ *
+ *  - ARCHE_PLATFORM_STATE_ACTIVE:
+ *    Puts back driver to active state, where any pulse from SVC on wake/detect
+ *    line would trigger either cold/standby boot.
+ *    Note: Transition request from this function does not trigger cold/standby
+ *          boot. It just puts back driver book keeping variable back to ACTIVE
+ *          state and restores the interrupt.
+ *
+ * Returns -ENODEV if device not found, -EAGAIN if the driver cannot currently
+ * satisfy the requested state-transition or -EINVAL for all other
+ * state-transition requests.
+ */
+int arche_platform_change_state(enum arche_platform_state state)
+{
+	struct arche_platform_drvdata *arche_pdata;
+	struct platform_device *pdev;
+	struct device_node *np;
+	int ret = -EAGAIN;
+	unsigned long flags;
+
+	np = of_find_compatible_node(NULL, NULL, "google,arche-platform");
+	if (!np) {
+		pr_err("google,arche-platform device node not found\n");
+		return -ENODEV;
+	}
+
+	pdev = of_find_device_by_node(np);
+	if (!pdev) {
+		pr_err("arche-platform device not found\n");
+		return -ENODEV;
+	}
+
+	arche_pdata = platform_get_drvdata(pdev);
+
+	mutex_lock(&arche_pdata->platform_state_mutex);
+	spin_lock_irqsave(&arche_pdata->wake_lock, flags);
+	if (arche_pdata->wake_detect_state != WD_STATE_IDLE) {
+		dev_err(arche_pdata->dev,
+			"driver busy with wake/detect line ops\n");
+		goto  exit;
+	}
+
+	if (arche_pdata->state == state) {
+		ret = 0;
+		goto exit;
+	}
+
+	if (arche_pdata->state == ARCHE_PLATFORM_STATE_OFF ||
+	    arche_pdata->state == ARCHE_PLATFORM_STATE_STANDBY ||
+	    arche_pdata->state == ARCHE_PLATFORM_STATE_FW_FLASHING) {
+		dev_err(arche_pdata->dev, "busy, request to retry later\n");
+		goto exit;
+	}
+
+	if (state == ARCHE_PLATFORM_STATE_TIME_SYNC) {
+		disable_irq(arche_pdata->wake_detect_irq);
+		arche_pdata->state = ARCHE_PLATFORM_STATE_TIME_SYNC;
+	} else if (state == ARCHE_PLATFORM_STATE_ACTIVE) {
+		arche_pdata->state = ARCHE_PLATFORM_STATE_ACTIVE;
+		enable_irq(arche_pdata->wake_detect_irq);
+	} else {
+		dev_err(arche_pdata->dev, "invalid state transition request\n");
+	}
+exit:
+	spin_unlock_irqrestore(&arche_pdata->wake_lock, flags);
+	mutex_unlock(&arche_pdata->platform_state_mutex);
+	of_node_put(np);
+	return ret;
+}
+EXPORT_SYMBOL_GPL(arche_platform_change_state);
+
 static inline void svc_reset_onoff(unsigned int gpio, bool onoff)
 {
 	gpio_set_value(gpio, onoff);
@@ -195,6 +279,9 @@ static irqreturn_t arche_platform_wd_irq(int irq, void *devid)
 	return IRQ_HANDLED;
 }
 
+/*
+ * Requires arche_pdata->platform_state_mutex to be held
+ */
 static int arche_platform_coldboot_seq(struct arche_platform_drvdata *arche_pdata)
 {
 	int ret;
@@ -226,6 +313,9 @@ static int arche_platform_coldboot_seq(struct arche_platform_drvdata *arche_pdat
 	return 0;
 }
 
+/*
+ * Requires arche_pdata->platform_state_mutex to be held
+ */
 static void arche_platform_fw_flashing_seq(struct arche_platform_drvdata *arche_pdata)
 {
 	if (arche_pdata->state == ARCHE_PLATFORM_STATE_FW_FLASHING)
@@ -246,6 +336,9 @@ static void arche_platform_fw_flashing_seq(struct arche_platform_drvdata *arche_
 
 }
 
+/*
+ * Requires arche_pdata->platform_state_mutex to be held
+ */
 static void arche_platform_poweroff_seq(struct arche_platform_drvdata *arche_pdata)
 {
 	unsigned long flags;
@@ -280,9 +373,11 @@ static ssize_t state_store(struct device *dev,
 	struct arche_platform_drvdata *arche_pdata = platform_get_drvdata(pdev);
 	int ret = 0;
 
+	mutex_lock(&arche_pdata->platform_state_mutex);
+
 	if (sysfs_streq(buf, "off")) {
 		if (arche_pdata->state == ARCHE_PLATFORM_STATE_OFF)
-			return count;
+			goto exit;
 
 		/*  If SVC goes down, bring down APB's as well */
 		device_for_each_child(arche_pdata->dev, NULL, apb_poweroff);
@@ -291,19 +386,19 @@ static ssize_t state_store(struct device *dev,
 
 	} else if (sysfs_streq(buf, "active")) {
 		if (arche_pdata->state == ARCHE_PLATFORM_STATE_ACTIVE)
-			return count;
+			goto exit;
 
 		ret = arche_platform_coldboot_seq(arche_pdata);
 
 		assert_wakedetect(arche_pdata);
 	} else if (sysfs_streq(buf, "standby")) {
 		if (arche_pdata->state == ARCHE_PLATFORM_STATE_STANDBY)
-			return count;
+			goto exit;
 
 		dev_warn(arche_pdata->dev, "standby state not supported\n");
 	} else if (sysfs_streq(buf, "fw_flashing")) {
 		if (arche_pdata->state == ARCHE_PLATFORM_STATE_FW_FLASHING)
-			return count;
+			goto exit;
 
 		/* First we want to make sure we power off everything
 		 * and then enter FW flashing state */
@@ -319,6 +414,8 @@ static ssize_t state_store(struct device *dev,
 		ret = -EINVAL;
 	}
 
+exit:
+	mutex_unlock(&arche_pdata->platform_state_mutex);
 	return ret ? ret : count;
 }
 
@@ -336,6 +433,8 @@ static ssize_t state_show(struct device *dev,
 		return sprintf(buf, "standby\n");
 	case ARCHE_PLATFORM_STATE_FW_FLASHING:
 		return sprintf(buf, "fw_flashing\n");
+	case ARCHE_PLATFORM_STATE_TIME_SYNC:
+		return sprintf(buf, "time_sync\n");
 	default:
 		return sprintf(buf, "unknown state\n");
 	}
@@ -349,11 +448,15 @@ static int arche_platform_pm_notifier(struct notifier_block *notifier,
 	struct arche_platform_drvdata *arche_pdata =
 		container_of(notifier, struct arche_platform_drvdata,
 			     pm_notifier);
+	int ret = NOTIFY_DONE;
 
+	mutex_lock(&arche_pdata->platform_state_mutex);
 	switch (pm_event) {
 	case PM_SUSPEND_PREPARE:
-		if (arche_pdata->state != ARCHE_PLATFORM_STATE_ACTIVE)
-			return NOTIFY_STOP;
+		if (arche_pdata->state != ARCHE_PLATFORM_STATE_ACTIVE) {
+			ret = NOTIFY_STOP;
+			break;
+		}
 		device_for_each_child(arche_pdata->dev, NULL, apb_poweroff);
 		arche_platform_poweroff_seq(arche_pdata);
 		break;
@@ -364,8 +467,9 @@ static int arche_platform_pm_notifier(struct notifier_block *notifier,
 	default:
 		break;
 	}
+	mutex_unlock(&arche_pdata->platform_state_mutex);
 
-	return NOTIFY_DONE;
+	return ret;
 }
 
 static int arche_platform_probe(struct platform_device *pdev)
@@ -468,6 +572,7 @@ static int arche_platform_probe(struct platform_device *pdev)
 	arche_pdata->dev = &pdev->dev;
 
 	spin_lock_init(&arche_pdata->wake_lock);
+	mutex_init(&arche_pdata->platform_state_mutex);
 	arche_pdata->wake_detect_irq =
 		gpio_to_irq(arche_pdata->wake_detect_gpio);
 
@@ -489,6 +594,7 @@ static int arche_platform_probe(struct platform_device *pdev)
 		return ret;
 	}
 
+	mutex_lock(&arche_pdata->platform_state_mutex);
 	ret = arche_platform_coldboot_seq(arche_pdata);
 	if (ret) {
 		dev_err(dev, "Failed to cold boot svc %d\n", ret);
@@ -505,6 +611,8 @@ static int arche_platform_probe(struct platform_device *pdev)
 
 	arche_pdata->pm_notifier.notifier_call = arche_platform_pm_notifier;
 	ret = register_pm_notifier(&arche_pdata->pm_notifier);
+	mutex_unlock(&arche_pdata->platform_state_mutex);
+
 	if (ret) {
 		dev_err(dev, "failed to register pm notifier %d\n", ret);
 		goto err_populate;
@@ -516,6 +624,7 @@ static int arche_platform_probe(struct platform_device *pdev)
 err_populate:
 	arche_platform_poweroff_seq(arche_pdata);
 err_coldboot:
+	mutex_unlock(&arche_pdata->platform_state_mutex);
 	device_remove_file(&pdev->dev, &dev_attr_state);
 	return ret;
 }

commit 6c1ca56d85377498bec760064c02e33f4678a2dd
Author: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
Date:   Thu May 5 15:34:57 2016 +0100

    greybus: arche-platform: Rename spinlock variable lock => wake_detect_lock
    
    With addition of exported function, required for TIMESYNC operation,
    we need more locking mechanism for driver state, so to avoid confusion
    rename existing spinlock variable to its appropriate name.
    
    Testing Done: Tested on DB3.5 platform.
    
    Signed-off-by: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
    Signed-off-by: Bryan O'Donoghue <bryan.odonoghue@linaro.org>
    Reviewed-by: Alex Elder <elder@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/arche-platform.c b/drivers/staging/greybus/arche-platform.c
index d1083cfbc081..9a117176ad50 100644
--- a/drivers/staging/greybus/arche-platform.c
+++ b/drivers/staging/greybus/arche-platform.c
@@ -55,7 +55,7 @@ struct arche_platform_drvdata {
 
 	enum svc_wakedetect_state wake_detect_state;
 	int wake_detect_irq;
-	spinlock_t lock;
+	spinlock_t wake_lock;	/* Protect wake_detect_state */
 	unsigned long wake_detect_start;
 	struct notifier_block pm_notifier;
 
@@ -117,15 +117,15 @@ static irqreturn_t arche_platform_wd_irq_thread(int irq, void *devid)
 	struct arche_platform_drvdata *arche_pdata = devid;
 	unsigned long flags;
 
-	spin_lock_irqsave(&arche_pdata->lock, flags);
+	spin_lock_irqsave(&arche_pdata->wake_lock, flags);
 	if (arche_pdata->wake_detect_state != WD_STATE_COLDBOOT_TRIG) {
 		/* Something is wrong */
-		spin_unlock_irqrestore(&arche_pdata->lock, flags);
+		spin_unlock_irqrestore(&arche_pdata->wake_lock, flags);
 		return IRQ_HANDLED;
 	}
 
 	arche_pdata->wake_detect_state = WD_STATE_COLDBOOT_START;
-	spin_unlock_irqrestore(&arche_pdata->lock, flags);
+	spin_unlock_irqrestore(&arche_pdata->wake_lock, flags);
 
 	/* It should complete power cycle, so first make sure it is poweroff */
 	device_for_each_child(arche_pdata->dev, NULL, apb_poweroff);
@@ -137,9 +137,9 @@ static irqreturn_t arche_platform_wd_irq_thread(int irq, void *devid)
 	if (usb3613_hub_mode_ctrl(true))
 		dev_warn(arche_pdata->dev, "failed to control hub device\n");
 
-	spin_lock_irqsave(&arche_pdata->lock, flags);
+	spin_lock_irqsave(&arche_pdata->wake_lock, flags);
 	arche_pdata->wake_detect_state = WD_STATE_IDLE;
-	spin_unlock_irqrestore(&arche_pdata->lock, flags);
+	spin_unlock_irqrestore(&arche_pdata->wake_lock, flags);
 
 	return IRQ_HANDLED;
 }
@@ -149,7 +149,7 @@ static irqreturn_t arche_platform_wd_irq(int irq, void *devid)
 	struct arche_platform_drvdata *arche_pdata = devid;
 	unsigned long flags;
 
-	spin_lock_irqsave(&arche_pdata->lock, flags);
+	spin_lock_irqsave(&arche_pdata->wake_lock, flags);
 
 	if (gpio_get_value(arche_pdata->wake_detect_gpio)) {
 		/* wake/detect rising */
@@ -170,7 +170,9 @@ static irqreturn_t arche_platform_wd_irq(int irq, void *devid)
 						WD_STATE_COLDBOOT_START) {
 					arche_pdata->wake_detect_state =
 						WD_STATE_COLDBOOT_TRIG;
-					spin_unlock_irqrestore(&arche_pdata->lock, flags);
+					spin_unlock_irqrestore(
+						&arche_pdata->wake_lock,
+						flags);
 					return IRQ_WAKE_THREAD;
 				}
 			}
@@ -188,7 +190,7 @@ static irqreturn_t arche_platform_wd_irq(int irq, void *devid)
 		}
 	}
 
-	spin_unlock_irqrestore(&arche_pdata->lock, flags);
+	spin_unlock_irqrestore(&arche_pdata->wake_lock, flags);
 
 	return IRQ_HANDLED;
 }
@@ -257,9 +259,9 @@ static void arche_platform_poweroff_seq(struct arche_platform_drvdata *arche_pda
 		/* Send disconnect/detach event to SVC */
 		gpio_direction_output(arche_pdata->wake_detect_gpio, 0);
 		usleep_range(100, 200);
-		spin_lock_irqsave(&arche_pdata->lock, flags);
+		spin_lock_irqsave(&arche_pdata->wake_lock, flags);
 		arche_pdata->wake_detect_state = WD_STATE_IDLE;
-		spin_unlock_irqrestore(&arche_pdata->lock, flags);
+		spin_unlock_irqrestore(&arche_pdata->wake_lock, flags);
 
 		clk_disable_unprepare(arche_pdata->svc_ref_clk);
 	}
@@ -465,7 +467,7 @@ static int arche_platform_probe(struct platform_device *pdev)
 
 	arche_pdata->dev = &pdev->dev;
 
-	spin_lock_init(&arche_pdata->lock);
+	spin_lock_init(&arche_pdata->wake_lock);
 	arche_pdata->wake_detect_irq =
 		gpio_to_irq(arche_pdata->wake_detect_gpio);
 

commit 7b62b61c752a4700ecf11d63a7ec40aeb3cee66c
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Wed Apr 20 11:48:37 2016 +0530

    greybus: arche-ctrl: Don't expose driver internals to arche-platform driver
    
    We have chosen the *ugly* way of registering two platform drivers from
    the module_init() of only one of them, so that we can avoid having two
    separate modules for them.
    
    But we should still be doing this in a sane way. There is no need to
    expose internals of arche-ctrl to arche-platform, like PM-ops, probe,
    resume, id-table, etc. Just expose an init and a exit callback.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Reviewed-by: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/arche-platform.c b/drivers/staging/greybus/arche-platform.c
index 3ff4f69685bd..d1083cfbc081 100644
--- a/drivers/staging/greybus/arche-platform.c
+++ b/drivers/staging/greybus/arche-platform.c
@@ -580,11 +580,6 @@ static struct of_device_id arche_platform_of_match[] = {
 	{ },
 };
 
-static struct of_device_id arche_apb_ctrl_of_match[] = {
-	{ .compatible = "usbffff,2", },
-	{ },
-};
-
 static struct of_device_id arche_combined_id[] = {
 	{ .compatible = "google,arche-platform", }, /* Use PID/VID of SVC device */
 	{ .compatible = "usbffff,2", },
@@ -602,16 +597,6 @@ static struct platform_driver arche_platform_device_driver = {
 	}
 };
 
-static struct platform_driver arche_apb_ctrl_device_driver = {
-	.probe		= arche_apb_ctrl_probe,
-	.remove		= arche_apb_ctrl_remove,
-	.driver		= {
-		.name	= "arche-apb-ctrl",
-		.pm	= &arche_apb_ctrl_pm_ops,
-		.of_match_table = arche_apb_ctrl_of_match,
-	}
-};
-
 static int __init arche_init(void)
 {
 	int retval;
@@ -620,7 +605,7 @@ static int __init arche_init(void)
 	if (retval)
 		return retval;
 
-	retval = platform_driver_register(&arche_apb_ctrl_device_driver);
+	retval = arche_apb_init();
 	if (retval)
 		platform_driver_unregister(&arche_platform_device_driver);
 
@@ -630,7 +615,7 @@ module_init(arche_init);
 
 static void __exit arche_exit(void)
 {
-	platform_driver_unregister(&arche_apb_ctrl_device_driver);
+	arche_apb_exit();
 	platform_driver_unregister(&arche_platform_device_driver);
 }
 module_exit(arche_exit);

commit 9160b7c7652a80f48250bbdc151fa0af3ccf024f
Author: David Lin <dtwlin@google.com>
Date:   Sat Apr 16 01:15:15 2016 +0530

    greybus: arche-platform: Power-off unipro subsystem upon suspend
    
    Switch off APBs/SVC/Switch in the suspend call notifier. Note that
    this is an interim solution to enable fishfooding.
    
    Testing done:
     - Passed QA sanity test on EVT1.5
     - Suspend current measured at ~70mW
    
    Signed-off-by: David Lin <dtwlin@google.com>
    Signed-off-by: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
    [vaibhav.hiremath@linaro.org: Updated commit description]
    Tested-by: Sandeep Patil <sspatil@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/arche-platform.c b/drivers/staging/greybus/arche-platform.c
index 48cdb0fffcfc..3ff4f69685bd 100644
--- a/drivers/staging/greybus/arche-platform.c
+++ b/drivers/staging/greybus/arche-platform.c
@@ -19,6 +19,7 @@
 #include <linux/pm.h>
 #include <linux/interrupt.h>
 #include <linux/irq.h>
+#include <linux/suspend.h>
 #include <linux/time.h>
 #include "arche_platform.h"
 
@@ -56,6 +57,7 @@ struct arche_platform_drvdata {
 	int wake_detect_irq;
 	spinlock_t lock;
 	unsigned long wake_detect_start;
+	struct notifier_block pm_notifier;
 
 	struct device *dev;
 };
@@ -339,6 +341,31 @@ static ssize_t state_show(struct device *dev,
 
 static DEVICE_ATTR_RW(state);
 
+static int arche_platform_pm_notifier(struct notifier_block *notifier,
+				      unsigned long pm_event, void *unused)
+{
+	struct arche_platform_drvdata *arche_pdata =
+		container_of(notifier, struct arche_platform_drvdata,
+			     pm_notifier);
+
+	switch (pm_event) {
+	case PM_SUSPEND_PREPARE:
+		if (arche_pdata->state != ARCHE_PLATFORM_STATE_ACTIVE)
+			return NOTIFY_STOP;
+		device_for_each_child(arche_pdata->dev, NULL, apb_poweroff);
+		arche_platform_poweroff_seq(arche_pdata);
+		break;
+	case PM_POST_SUSPEND:
+		arche_platform_coldboot_seq(arche_pdata);
+		assert_wakedetect(arche_pdata);
+		break;
+	default:
+		break;
+	}
+
+	return NOTIFY_DONE;
+}
+
 static int arche_platform_probe(struct platform_device *pdev)
 {
 	struct arche_platform_drvdata *arche_pdata;
@@ -474,6 +501,13 @@ static int arche_platform_probe(struct platform_device *pdev)
 
 	assert_wakedetect(arche_pdata);
 
+	arche_pdata->pm_notifier.notifier_call = arche_platform_pm_notifier;
+	ret = register_pm_notifier(&arche_pdata->pm_notifier);
+	if (ret) {
+		dev_err(dev, "failed to register pm notifier %d\n", ret);
+		goto err_populate;
+	}
+
 	dev_info(dev, "Device registered successfully\n");
 	return 0;
 
@@ -497,6 +531,7 @@ static int arche_platform_remove(struct platform_device *pdev)
 {
 	struct arche_platform_drvdata *arche_pdata = platform_get_drvdata(pdev);
 
+	unregister_pm_notifier(&arche_pdata->pm_notifier);
 	device_remove_file(&pdev->dev, &dev_attr_state);
 	device_for_each_child(&pdev->dev, NULL, arche_remove_child);
 	arche_platform_poweroff_seq(arche_pdata);

commit a7ddda1f5aa47779071dd4c6f3a5e65c0086e49f
Author: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
Date:   Tue Apr 12 17:18:47 2016 +0530

    greybus: arche-platfrom: Get rid of 2sec delay in USB3613 configuration
    
    Earlier during boot sequence implementation, we had seen race between
    USb3613 and APB boot, and since APB boot time is ~2sec, we delayed
    USb3613 configuration for 2sec after APB deassertion of reset.
    
    This obviously won't work in the case of suspend/resume, where we would
    like to put APB into OFF state and coldboot in resume.
    
    With the latest FW changes, we do not see any race issue. I have done
    regression testing (> 50 iteration of reboot + unipro link up and down)
    without any issues.
    
    So lets get rid of the 2sec delay with this patch.
    
    Testing Done: Tested on EVT 1.5 platform.
    
    Signed-off-by: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
    Tested-by: David Lin <dtwlin@google.com>
    Reviewed-by: David Lin <dtwlin@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/arche-platform.c b/drivers/staging/greybus/arche-platform.c
index 3293661d876a..48cdb0fffcfc 100644
--- a/drivers/staging/greybus/arche-platform.c
+++ b/drivers/staging/greybus/arche-platform.c
@@ -52,7 +52,6 @@ struct arche_platform_drvdata {
 
 	int num_apbs;
 
-	struct delayed_work delayed_work;
 	enum svc_wakedetect_state wake_detect_state;
 	int wake_detect_irq;
 	spinlock_t lock;
@@ -101,24 +100,6 @@ static int apb_poweroff(struct device *dev, void *data)
 	return 0;
 }
 
-/**
- * hub_conf_delayed_work - Configures USB3613 device to HUB mode
- *
- * The idea here is to split the APB coldboot operation with slow HUB configuration,
- * so that driver response to wake/detect event can be met.
- * So expectation is, once code reaches here, means initial unipro linkup
- * between APB<->Switch was successful, so now just take it to AP.
- */
-static void hub_conf_delayed_work(struct work_struct *work)
-{
-	struct arche_platform_drvdata *arche_pdata =
-		container_of(work, struct arche_platform_drvdata, delayed_work.work);
-
-	/* Enable HUB3613 into HUB mode. */
-	if (usb3613_hub_mode_ctrl(true))
-		dev_warn(arche_pdata->dev, "failed to control hub device\n");
-}
-
 static void assert_wakedetect(struct arche_platform_drvdata *arche_pdata)
 {
 	/* Assert wake/detect = Detect event from AP */
@@ -150,9 +131,11 @@ static irqreturn_t arche_platform_wd_irq_thread(int irq, void *devid)
 	/* Bring APB out of reset: cold boot sequence */
 	device_for_each_child(arche_pdata->dev, NULL, apb_cold_boot);
 
+	/* Enable HUB3613 into HUB mode. */
+	if (usb3613_hub_mode_ctrl(true))
+		dev_warn(arche_pdata->dev, "failed to control hub device\n");
+
 	spin_lock_irqsave(&arche_pdata->lock, flags);
-	/* USB HUB configuration */
-	schedule_delayed_work(&arche_pdata->delayed_work, msecs_to_jiffies(2000));
 	arche_pdata->wake_detect_state = WD_STATE_IDLE;
 	spin_unlock_irqrestore(&arche_pdata->lock, flags);
 
@@ -178,8 +161,6 @@ static irqreturn_t arche_platform_wd_irq(int irq, void *devid)
 			if (time_before(jiffies,
 					arche_pdata->wake_detect_start +
 					msecs_to_jiffies(WD_COLDBOOT_PULSE_WIDTH_MS))) {
-				/* No harm with cancellation, even if not pending */
-				cancel_delayed_work(&arche_pdata->delayed_work);
 				arche_pdata->wake_detect_state = WD_STATE_IDLE;
 			} else {
 				/* Check we are not in middle of irq thread already */
@@ -196,8 +177,6 @@ static irqreturn_t arche_platform_wd_irq(int irq, void *devid)
 		/* wake/detect falling */
 		if (arche_pdata->wake_detect_state == WD_STATE_IDLE) {
 			arche_pdata->wake_detect_start = jiffies;
-			/* No harm with cancellation even if it is not pending*/
-			cancel_delayed_work(&arche_pdata->delayed_work);
 			/*
 			 * In the begining, when wake/detect goes low (first time), we assume
 			 * it is meant for coldboot and set the flag. If wake/detect line stays low
@@ -494,7 +473,6 @@ static int arche_platform_probe(struct platform_device *pdev)
 	}
 
 	assert_wakedetect(arche_pdata);
-	INIT_DELAYED_WORK(&arche_pdata->delayed_work, hub_conf_delayed_work);
 
 	dev_info(dev, "Device registered successfully\n");
 	return 0;
@@ -520,7 +498,6 @@ static int arche_platform_remove(struct platform_device *pdev)
 	struct arche_platform_drvdata *arche_pdata = platform_get_drvdata(pdev);
 
 	device_remove_file(&pdev->dev, &dev_attr_state);
-	cancel_delayed_work_sync(&arche_pdata->delayed_work);
 	device_for_each_child(&pdev->dev, NULL, arche_remove_child);
 	arche_platform_poweroff_seq(arche_pdata);
 	platform_set_drvdata(pdev, NULL);

commit 7fe9301422444a1fca71bb8c4c0673fb44eb0f2d
Author: David Lin <dtwlin@google.com>
Date:   Mon Mar 7 21:52:54 2016 -0800

    greybus: arche-platform: fix incorrect gpio variable type
    
    GPIO number obtained from of_get_named_gpio() should be signed to allow
    error handling.
    
    Testing Done:
    Built & booted on EVT1.5
    
    Signed-off-by: David Lin <dtwlin@google.com>
    Reviewed-by: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/arche-platform.c b/drivers/staging/greybus/arche-platform.c
index 64dd8a1ebe37..3293661d876a 100644
--- a/drivers/staging/greybus/arche-platform.c
+++ b/drivers/staging/greybus/arche-platform.c
@@ -44,7 +44,7 @@ struct arche_platform_drvdata {
 
 	enum arche_platform_state state;
 
-	unsigned int svc_refclk_req;
+	int svc_refclk_req;
 	struct clk *svc_ref_clk;
 
 	struct pinctrl *pinctrl;

commit e915ce48bae606b79150a4d799a30037604a93ed
Author: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
Date:   Thu Feb 25 16:45:45 2016 +0530

    greybus: arche-platform: Disable HUB3613 only in APB poweroff fn
    
    HUB3613 configuration, either disable (Standby mode) or enable (HUB mode)
    is related to APB. So it makes perfect sense to put both of them
    together in one function.
    
    HUB3613 enable happens only at one place, in hub_conf_delayed_work() fn,
    but disable is initiated from multiple places.
    Move all calls to usb3613_hub_mode_ctrl(false) to apb_poweroff().
    
    Testing Done: Tested on DB3.5 platform.
    
    Signed-off-by: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/arche-platform.c b/drivers/staging/greybus/arche-platform.c
index f44c34314127..64dd8a1ebe37 100644
--- a/drivers/staging/greybus/arche-platform.c
+++ b/drivers/staging/greybus/arche-platform.c
@@ -94,6 +94,10 @@ static int apb_poweroff(struct device *dev, void *data)
 {
 	apb_ctrl_poweroff(dev);
 
+	/* Enable HUB3613 into HUB mode. */
+	if (usb3613_hub_mode_ctrl(false))
+		dev_warn(dev, "failed to control hub device\n");
+
 	return 0;
 }
 
@@ -142,6 +146,7 @@ static irqreturn_t arche_platform_wd_irq_thread(int irq, void *devid)
 
 	/* It should complete power cycle, so first make sure it is poweroff */
 	device_for_each_child(arche_pdata->dev, NULL, apb_poweroff);
+
 	/* Bring APB out of reset: cold boot sequence */
 	device_for_each_child(arche_pdata->dev, NULL, apb_cold_boot);
 
@@ -301,10 +306,6 @@ static ssize_t state_store(struct device *dev,
 
 		arche_platform_poweroff_seq(arche_pdata);
 
-		ret = usb3613_hub_mode_ctrl(false);
-		if (ret)
-			dev_warn(arche_pdata->dev, "failed to control hub device\n");
-			/* TODO: Should we do anything more here ?? */
 	} else if (sysfs_streq(buf, "active")) {
 		if (arche_pdata->state == ARCHE_PLATFORM_STATE_ACTIVE)
 			return count;
@@ -327,11 +328,6 @@ static ssize_t state_store(struct device *dev,
 
 		arche_platform_poweroff_seq(arche_pdata);
 
-		ret = usb3613_hub_mode_ctrl(false);
-		if (ret)
-			dev_warn(arche_pdata->dev, "failed to control hub device\n");
-			/* TODO: Should we do anything more here ?? */
-
 		arche_platform_fw_flashing_seq(arche_pdata);
 
 		device_for_each_child(arche_pdata->dev, NULL, apb_fw_flashing_state);

commit ff788de0b41b960d7b4a650e167cfcc0d3f63644
Author: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
Date:   Thu Feb 25 16:45:44 2016 +0530

    greybus: arche-platform: Make sure APB power cycles on coldboot
    
    On first wake/detect pulse, everything works fine, as APB would be
    in poweroff state initially.
    But on subsequent wake/detect pulses, where APB is already in active
    state, internal function just returns doing nothing, as it finds that
    device is already in active state.
    
    So the solution would be to make sure that, whenever execution reaches
    to coldboot, make sure we power cycle it. Power off first, before
    powering on.
    
    Interrupt handler takes care of ignoring < 30msec pulses, so we should
    be safe here to power cycle APB.
    
    Testing Done: Testd on DB3.5 platform.
    
    Signed-off-by: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/arche-platform.c b/drivers/staging/greybus/arche-platform.c
index 21a84389bd3a..f44c34314127 100644
--- a/drivers/staging/greybus/arche-platform.c
+++ b/drivers/staging/greybus/arche-platform.c
@@ -140,6 +140,8 @@ static irqreturn_t arche_platform_wd_irq_thread(int irq, void *devid)
 	arche_pdata->wake_detect_state = WD_STATE_COLDBOOT_START;
 	spin_unlock_irqrestore(&arche_pdata->lock, flags);
 
+	/* It should complete power cycle, so first make sure it is poweroff */
+	device_for_each_child(arche_pdata->dev, NULL, apb_poweroff);
 	/* Bring APB out of reset: cold boot sequence */
 	device_for_each_child(arche_pdata->dev, NULL, apb_cold_boot);
 

commit d2320b2dbf95216e9aedf69345862f934ae55138
Author: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
Date:   Thu Feb 25 04:37:39 2016 +0530

    greybus: arche-platform: Disable wake/detect interrupt in poweroff
    
    In poweroff() fn, we are shutting down SVC, so disable interrupt
    as well.
    
    Testing Done: Tested on DB3.5 platform.
    
    Signed-off-by: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
    Reviewed-by: Michael Scott <michael.scott@linaro.org>
    Tested-by: Michael Scott <michael.scott@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/arche-platform.c b/drivers/staging/greybus/arche-platform.c
index 5b393eca7bba..21a84389bd3a 100644
--- a/drivers/staging/greybus/arche-platform.c
+++ b/drivers/staging/greybus/arche-platform.c
@@ -265,6 +265,7 @@ static void arche_platform_poweroff_seq(struct arche_platform_drvdata *arche_pda
 
 	/* If in fw_flashing mode, then no need to repeate things again */
 	if (arche_pdata->state != ARCHE_PLATFORM_STATE_FW_FLASHING) {
+		disable_irq(arche_pdata->wake_detect_irq);
 		/* Send disconnect/detach event to SVC */
 		gpio_direction_output(arche_pdata->wake_detect_gpio, 0);
 		usleep_range(100, 200);

commit 0786212d6c1514545f33554b7403ea10d8061eb7
Author: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
Date:   Thu Feb 25 04:37:38 2016 +0530

    greybus: arche-platform: Set direction of wake/detect gpio in poweroff fn
    
    With support of interrupt based mechanism, gpio is not longer set to
    output mode, so gpio_set_value won't work. So use
    gpio_direction_output() fn in poweroff(), while setting value on
    wake/detect line.
    
    Testing Done: Tested on DB3.5 platform.
    
    Signed-off-by: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
    Reviewed-by: Michael Scott <michael.scott@linaro.org>
    Tested-by: Michael Scott <michael.scott@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/arche-platform.c b/drivers/staging/greybus/arche-platform.c
index 87526b2bf0a9..5b393eca7bba 100644
--- a/drivers/staging/greybus/arche-platform.c
+++ b/drivers/staging/greybus/arche-platform.c
@@ -266,7 +266,7 @@ static void arche_platform_poweroff_seq(struct arche_platform_drvdata *arche_pda
 	/* If in fw_flashing mode, then no need to repeate things again */
 	if (arche_pdata->state != ARCHE_PLATFORM_STATE_FW_FLASHING) {
 		/* Send disconnect/detach event to SVC */
-		gpio_set_value(arche_pdata->wake_detect_gpio, 0);
+		gpio_direction_output(arche_pdata->wake_detect_gpio, 0);
 		usleep_range(100, 200);
 		spin_lock_irqsave(&arche_pdata->lock, flags);
 		arche_pdata->wake_detect_state = WD_STATE_IDLE;

commit 16fe18ca9ef0a3d806d33121a3a653138a1a6854
Author: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
Date:   Thu Feb 25 04:37:37 2016 +0530

    greybus: arche-platform: Assert wake/detect after SVC reset without delay
    
    Since now driver supports interrupt based mechanism to read events
    from SVC over wake/detect line, no need to delay wake/detect assertion.
    We can assert wake/detect after SVC reset deassertion, so during boot
    itself SVC will start sending wake_out pulses.
    
    Testing Done: Tested on DB3.5 platform.
    
    Signed-off-by: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
    Reviewed-by: Michael Scott <michael.scott@linaro.org>
    Tested-by: Michael Scott <michael.scott@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/arche-platform.c b/drivers/staging/greybus/arche-platform.c
index 83db892a8a5d..87526b2bf0a9 100644
--- a/drivers/staging/greybus/arche-platform.c
+++ b/drivers/staging/greybus/arche-platform.c
@@ -115,6 +115,16 @@ static void hub_conf_delayed_work(struct work_struct *work)
 		dev_warn(arche_pdata->dev, "failed to control hub device\n");
 }
 
+static void assert_wakedetect(struct arche_platform_drvdata *arche_pdata)
+{
+	/* Assert wake/detect = Detect event from AP */
+	gpio_direction_output(arche_pdata->wake_detect_gpio, 1);
+
+	/* Enable interrupt here, to read event back from SVC */
+	gpio_direction_input(arche_pdata->wake_detect_gpio);
+	enable_irq(arche_pdata->wake_detect_irq);
+}
+
 static irqreturn_t arche_platform_wd_irq_thread(int irq, void *devid)
 {
 	struct arche_platform_drvdata *arche_pdata = devid;
@@ -297,6 +307,8 @@ static ssize_t state_store(struct device *dev,
 			return count;
 
 		ret = arche_platform_coldboot_seq(arche_pdata);
+
+		assert_wakedetect(arche_pdata);
 	} else if (sysfs_streq(buf, "standby")) {
 		if (arche_pdata->state == ARCHE_PLATFORM_STATE_STANDBY)
 			return count;
@@ -482,6 +494,7 @@ static int arche_platform_probe(struct platform_device *pdev)
 		goto err_populate;
 	}
 
+	assert_wakedetect(arche_pdata);
 	INIT_DELAYED_WORK(&arche_pdata->delayed_work, hub_conf_delayed_work);
 
 	dev_info(dev, "Device registered successfully\n");

commit f760bbfb5c10952739fd0d39869cdd6a43844037
Author: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
Date:   Thu Feb 25 04:37:36 2016 +0530

    greybus: arche-platform: Enable interrupt support on wake/detect line
    
    This patch enabled interrupt support on events received over wake/detect
    line. The driver follows below state machine,
    
    Default: wake/detect line is high (WD_STATE_IDLE)
    On Falling edge:
      SVC initiates boot (either cold/standby).
      On ES3, > 30msec = coldboot, else standby boot.
      Driver moves to WD_STATE_BOOT_INIT
    On rising edge (> 30msec):
      SVC expects APB to coldboot
      Driver wakes irq thread which kicks off APB  coldboot
      (WD_STATE_COLDBOOT_TRIG)
    On rising edge (< 30msec):
      Driver ignores it, do nothing.
    
    After coldboot of APB, HUB configuration work is scheduled after 2 sec,
    allowing enough time for APB<->SVC/Switch to linkup (in multiple
    iterations)
    
    Testing Done: Tested on DB3.5 platform.
    
    Signed-off-by: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
    Reviewed-by: Michael Scott <michael.scott@linaro.org>
    Tested-by: Michael Scott <michael.scott@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/arche-platform.c b/drivers/staging/greybus/arche-platform.c
index dcc3844854c2..83db892a8a5d 100644
--- a/drivers/staging/greybus/arche-platform.c
+++ b/drivers/staging/greybus/arche-platform.c
@@ -17,10 +17,15 @@
 #include <linux/pinctrl/consumer.h>
 #include <linux/platform_device.h>
 #include <linux/pm.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/time.h>
 #include "arche_platform.h"
 
 #include <linux/usb/usb3613.h>
 
+#define WD_COLDBOOT_PULSE_WIDTH_MS	30
+
 enum svc_wakedetect_state {
 	WD_STATE_IDLE,			/* Default state = pulled high/low */
 	WD_STATE_BOOT_INIT,		/* WD = falling edge (low) */
@@ -49,6 +54,9 @@ struct arche_platform_drvdata {
 
 	struct delayed_work delayed_work;
 	enum svc_wakedetect_state wake_detect_state;
+	int wake_detect_irq;
+	spinlock_t lock;
+	unsigned long wake_detect_start;
 
 	struct device *dev;
 };
@@ -58,6 +66,18 @@ static inline void svc_reset_onoff(unsigned int gpio, bool onoff)
 	gpio_set_value(gpio, onoff);
 }
 
+static int apb_cold_boot(struct device *dev, void *data)
+{
+	int ret;
+
+	ret = apb_ctrl_coldboot(dev);
+	if (ret)
+		dev_warn(dev, "failed to coldboot\n");
+
+	/*Child nodes are independent, so do not exit coldboot operation */
+	return 0;
+}
+
 static int apb_fw_flashing_state(struct device *dev, void *data)
 {
 	int ret;
@@ -95,6 +115,86 @@ static void hub_conf_delayed_work(struct work_struct *work)
 		dev_warn(arche_pdata->dev, "failed to control hub device\n");
 }
 
+static irqreturn_t arche_platform_wd_irq_thread(int irq, void *devid)
+{
+	struct arche_platform_drvdata *arche_pdata = devid;
+	unsigned long flags;
+
+	spin_lock_irqsave(&arche_pdata->lock, flags);
+	if (arche_pdata->wake_detect_state != WD_STATE_COLDBOOT_TRIG) {
+		/* Something is wrong */
+		spin_unlock_irqrestore(&arche_pdata->lock, flags);
+		return IRQ_HANDLED;
+	}
+
+	arche_pdata->wake_detect_state = WD_STATE_COLDBOOT_START;
+	spin_unlock_irqrestore(&arche_pdata->lock, flags);
+
+	/* Bring APB out of reset: cold boot sequence */
+	device_for_each_child(arche_pdata->dev, NULL, apb_cold_boot);
+
+	spin_lock_irqsave(&arche_pdata->lock, flags);
+	/* USB HUB configuration */
+	schedule_delayed_work(&arche_pdata->delayed_work, msecs_to_jiffies(2000));
+	arche_pdata->wake_detect_state = WD_STATE_IDLE;
+	spin_unlock_irqrestore(&arche_pdata->lock, flags);
+
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t arche_platform_wd_irq(int irq, void *devid)
+{
+	struct arche_platform_drvdata *arche_pdata = devid;
+	unsigned long flags;
+
+	spin_lock_irqsave(&arche_pdata->lock, flags);
+
+	if (gpio_get_value(arche_pdata->wake_detect_gpio)) {
+		/* wake/detect rising */
+
+		/*
+		 * If wake/detect line goes high after low, within less than
+		 * 30msec, then standby boot sequence is initiated, which is not
+		 * supported/implemented as of now. So ignore it.
+		 */
+		if (arche_pdata->wake_detect_state == WD_STATE_BOOT_INIT) {
+			if (time_before(jiffies,
+					arche_pdata->wake_detect_start +
+					msecs_to_jiffies(WD_COLDBOOT_PULSE_WIDTH_MS))) {
+				/* No harm with cancellation, even if not pending */
+				cancel_delayed_work(&arche_pdata->delayed_work);
+				arche_pdata->wake_detect_state = WD_STATE_IDLE;
+			} else {
+				/* Check we are not in middle of irq thread already */
+				if (arche_pdata->wake_detect_state !=
+						WD_STATE_COLDBOOT_START) {
+					arche_pdata->wake_detect_state =
+						WD_STATE_COLDBOOT_TRIG;
+					spin_unlock_irqrestore(&arche_pdata->lock, flags);
+					return IRQ_WAKE_THREAD;
+				}
+			}
+		}
+	} else {
+		/* wake/detect falling */
+		if (arche_pdata->wake_detect_state == WD_STATE_IDLE) {
+			arche_pdata->wake_detect_start = jiffies;
+			/* No harm with cancellation even if it is not pending*/
+			cancel_delayed_work(&arche_pdata->delayed_work);
+			/*
+			 * In the begining, when wake/detect goes low (first time), we assume
+			 * it is meant for coldboot and set the flag. If wake/detect line stays low
+			 * beyond 30msec, then it is coldboot else fallback to standby boot.
+			 */
+			arche_pdata->wake_detect_state = WD_STATE_BOOT_INIT;
+		}
+	}
+
+	spin_unlock_irqrestore(&arche_pdata->lock, flags);
+
+	return IRQ_HANDLED;
+}
+
 static int arche_platform_coldboot_seq(struct arche_platform_drvdata *arche_pdata)
 {
 	int ret;
@@ -148,6 +248,8 @@ static void arche_platform_fw_flashing_seq(struct arche_platform_drvdata *arche_
 
 static void arche_platform_poweroff_seq(struct arche_platform_drvdata *arche_pdata)
 {
+	unsigned long flags;
+
 	if (arche_pdata->state == ARCHE_PLATFORM_STATE_OFF)
 		return;
 
@@ -156,7 +258,9 @@ static void arche_platform_poweroff_seq(struct arche_platform_drvdata *arche_pda
 		/* Send disconnect/detach event to SVC */
 		gpio_set_value(arche_pdata->wake_detect_gpio, 0);
 		usleep_range(100, 200);
+		spin_lock_irqsave(&arche_pdata->lock, flags);
 		arche_pdata->wake_detect_state = WD_STATE_IDLE;
+		spin_unlock_irqrestore(&arche_pdata->lock, flags);
 
 		clk_disable_unprepare(arche_pdata->svc_ref_clk);
 	}
@@ -344,6 +448,22 @@ static int arche_platform_probe(struct platform_device *pdev)
 
 	arche_pdata->dev = &pdev->dev;
 
+	spin_lock_init(&arche_pdata->lock);
+	arche_pdata->wake_detect_irq =
+		gpio_to_irq(arche_pdata->wake_detect_gpio);
+
+	ret = devm_request_threaded_irq(dev, arche_pdata->wake_detect_irq,
+			arche_platform_wd_irq,
+			arche_platform_wd_irq_thread,
+			IRQF_TRIGGER_FALLING | IRQF_TRIGGER_RISING | IRQF_ONESHOT,
+			dev_name(dev), arche_pdata);
+	if (ret) {
+		dev_err(dev, "failed to request wake detect IRQ %d\n", ret);
+		return ret;
+	}
+	/* Enable it only after  sending wake/detect event */
+	disable_irq(arche_pdata->wake_detect_irq);
+
 	ret = device_create_file(dev, &dev_attr_state);
 	if (ret) {
 		dev_err(dev, "failed to create state file in sysfs\n");

commit 685353c12ea33e99d1daba5b3721b9033cdbdb87
Author: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
Date:   Thu Feb 25 04:37:35 2016 +0530

    greybus: arche-platform: Add wake detect state based on functionality
    
    If driver needs to process wake/detect events from SVC, by enabling
    interrupt support on wake/detect event, it becomes easier to maintain
    state of wake/detect line based on functionality.
    
    Testing Done: Tested on DB3.5 platform.
    
    Signed-off-by: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
    Reviewed-by: Michael Scott <michael.scott@linaro.org>
    Tested-by: Michael Scott <michael.scott@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/arche-platform.c b/drivers/staging/greybus/arche-platform.c
index 50991a601731..dcc3844854c2 100644
--- a/drivers/staging/greybus/arche-platform.c
+++ b/drivers/staging/greybus/arche-platform.c
@@ -21,6 +21,15 @@
 
 #include <linux/usb/usb3613.h>
 
+enum svc_wakedetect_state {
+	WD_STATE_IDLE,			/* Default state = pulled high/low */
+	WD_STATE_BOOT_INIT,		/* WD = falling edge (low) */
+	WD_STATE_COLDBOOT_TRIG,		/* WD = rising edge (high), > 30msec */
+	WD_STATE_STANDBYBOOT_TRIG,	/* As of now not used ?? */
+	WD_STATE_COLDBOOT_START,	/* Cold boot process started */
+	WD_STATE_STANDBYBOOT_START,	/* Not used */
+};
+
 struct arche_platform_drvdata {
 	/* Control GPIO signals to and from AP <=> SVC */
 	int svc_reset_gpio;
@@ -39,6 +48,8 @@ struct arche_platform_drvdata {
 	int num_apbs;
 
 	struct delayed_work delayed_work;
+	enum svc_wakedetect_state wake_detect_state;
+
 	struct device *dev;
 };
 
@@ -145,6 +156,7 @@ static void arche_platform_poweroff_seq(struct arche_platform_drvdata *arche_pda
 		/* Send disconnect/detach event to SVC */
 		gpio_set_value(arche_pdata->wake_detect_gpio, 0);
 		usleep_range(100, 200);
+		arche_pdata->wake_detect_state = WD_STATE_IDLE;
 
 		clk_disable_unprepare(arche_pdata->svc_ref_clk);
 	}
@@ -328,6 +340,7 @@ static int arche_platform_probe(struct platform_device *pdev)
 	}
 	/* deassert wake detect */
 	gpio_direction_output(arche_pdata->wake_detect_gpio, 0);
+	arche_pdata->wake_detect_state = WD_STATE_IDLE;
 
 	arche_pdata->dev = &pdev->dev;
 

commit db5a3bca56584c0ae62dbe0b280333c75a813b0a
Author: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
Date:   Thu Feb 25 04:37:34 2016 +0530

    greybus: arche-platform: Convert delayed work to do only hub3613 configuration
    
    This is preparation of interrupt handling support, where APB coldboot
    and wake/detect handling will be handled as response to wake/detect
    interrupt.
    Due to slower I2C write operations in HUB configuration, it is important
    to separate HUB configuration, and probably delay it after APB is
    cold booted.
    
    Note that delayed work will be scheduled from interrupt handler,
    in following patches.
    
    To satisfy build (and bisect), remove apb_cold_boot() fn, which will be
    added back in the patch where it gets used again.
    
    Testing Done: Tested on DB3.5 platform.
    
    Signed-off-by: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
    Reviewed-by: Michael Scott <michael.scott@linaro.org>
    Tested-by: Michael Scott <michael.scott@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/arche-platform.c b/drivers/staging/greybus/arche-platform.c
index c99a375bbafb..50991a601731 100644
--- a/drivers/staging/greybus/arche-platform.c
+++ b/drivers/staging/greybus/arche-platform.c
@@ -47,18 +47,6 @@ static inline void svc_reset_onoff(unsigned int gpio, bool onoff)
 	gpio_set_value(gpio, onoff);
 }
 
-static int apb_cold_boot(struct device *dev, void *data)
-{
-	int ret;
-
-	ret = apb_ctrl_coldboot(dev);
-	if (ret)
-		dev_warn(dev, "failed to coldboot\n");
-
-	/*Child nodes are independent, so do not exit coldboot operation */
-	return 0;
-}
-
 static int apb_fw_flashing_state(struct device *dev, void *data)
 {
 	int ret;
@@ -79,50 +67,17 @@ static int apb_poweroff(struct device *dev, void *data)
 }
 
 /**
- * svc_delayed_work - Time to give SVC to boot.
+ * hub_conf_delayed_work - Configures USB3613 device to HUB mode
+ *
+ * The idea here is to split the APB coldboot operation with slow HUB configuration,
+ * so that driver response to wake/detect event can be met.
+ * So expectation is, once code reaches here, means initial unipro linkup
+ * between APB<->Switch was successful, so now just take it to AP.
  */
-static void svc_delayed_work(struct work_struct *work)
+static void hub_conf_delayed_work(struct work_struct *work)
 {
 	struct arche_platform_drvdata *arche_pdata =
 		container_of(work, struct arche_platform_drvdata, delayed_work.work);
-	int timeout = 50;
-
-	/*
-	 * 1.   SVC and AP boot independently, with AP<-->SVC wake/detect pin
-	 *      deasserted (LOW in this case)
-	 * 2.1. SVC allows 360 milliseconds to elapse after switch boots to work
-	 *      around bug described in ENG-330.
-	 * 2.2. AP asserts wake/detect pin (HIGH) (this can proceed in parallel with 2.1)
-	 * 3.   SVC detects assertion of wake/detect pin, and sends "wake out" signal to AP
-	 * 4.   AP receives "wake out" signal, takes AP Bridges through their power
-	 *      on reset sequence as defined in the bridge ASIC reference manuals
-	 * 5. AP takes USB3613 through its power on reset sequence
-	 * 6. AP enumerates AP Bridges
-	 */
-	gpio_set_value(arche_pdata->wake_detect_gpio, 1);
-	gpio_direction_input(arche_pdata->wake_detect_gpio);
-	do {
-		/* Read the wake_detect GPIO, for WAKE_OUT event from SVC */
-		if (gpio_get_value(arche_pdata->wake_detect_gpio) == 0)
-			break;
-
-		msleep(100);
-	} while(timeout--);
-
-	if (timeout < 0) {
-		/* FIXME: We may want to limit retries here */
-		dev_warn(arche_pdata->dev,
-			"Timed out on wake/detect, rescheduling handshake\n");
-		gpio_direction_output(arche_pdata->wake_detect_gpio, 0);
-		schedule_delayed_work(&arche_pdata->delayed_work, msecs_to_jiffies(2000));
-		return;
-	}
-
-	/* Bring APB out of reset: cold boot sequence */
-	device_for_each_child(arche_pdata->dev, NULL, apb_cold_boot);
-
-	/* re-assert wake_detect to confirm SVC WAKE_OUT */
-	gpio_direction_output(arche_pdata->wake_detect_gpio, 1);
 
 	/* Enable HUB3613 into HUB mode. */
 	if (usb3613_hub_mode_ctrl(true))
@@ -226,8 +181,6 @@ static ssize_t state_store(struct device *dev,
 			return count;
 
 		ret = arche_platform_coldboot_seq(arche_pdata);
-		/* Give enough time for SVC to boot and then handshake with SVC */
-		schedule_delayed_work(&arche_pdata->delayed_work, msecs_to_jiffies(2000));
 	} else if (sysfs_streq(buf, "standby")) {
 		if (arche_pdata->state == ARCHE_PLATFORM_STATE_STANDBY)
 			return count;
@@ -396,8 +349,7 @@ static int arche_platform_probe(struct platform_device *pdev)
 		goto err_populate;
 	}
 
-	INIT_DELAYED_WORK(&arche_pdata->delayed_work, svc_delayed_work);
-	schedule_delayed_work(&arche_pdata->delayed_work, msecs_to_jiffies(2000));
+	INIT_DELAYED_WORK(&arche_pdata->delayed_work, hub_conf_delayed_work);
 
 	dev_info(dev, "Device registered successfully\n");
 	return 0;

commit 6743a6fd963aba000b128fd0b5c420a8f4b0dcde
Author: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
Date:   Thu Feb 25 02:27:36 2016 +0530

    greybus: arche-platform: Fix exit path in probe fn
    
    If SVC coldboot fails or if of_platform_populate() fn fails,
    then state of device needs to be reverted.
    
    Importantly, if of_platform_populate() fails, then poweroff the SVC.
    
    Testing Done: Tested on DB3.5 platform.
    
    Signed-off-by: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
    Reviewed-by: Michael Scott <michael.scott@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/arche-platform.c b/drivers/staging/greybus/arche-platform.c
index efeafb373cf1..c99a375bbafb 100644
--- a/drivers/staging/greybus/arche-platform.c
+++ b/drivers/staging/greybus/arche-platform.c
@@ -387,13 +387,13 @@ static int arche_platform_probe(struct platform_device *pdev)
 	ret = arche_platform_coldboot_seq(arche_pdata);
 	if (ret) {
 		dev_err(dev, "Failed to cold boot svc %d\n", ret);
-		return ret;
+		goto err_coldboot;
 	}
 
 	ret = of_platform_populate(np, NULL, NULL, dev);
 	if (ret) {
 		dev_err(dev, "failed to populate child nodes %d\n", ret);
-		return ret;
+		goto err_populate;
 	}
 
 	INIT_DELAYED_WORK(&arche_pdata->delayed_work, svc_delayed_work);
@@ -401,6 +401,12 @@ static int arche_platform_probe(struct platform_device *pdev)
 
 	dev_info(dev, "Device registered successfully\n");
 	return 0;
+
+err_populate:
+	arche_platform_poweroff_seq(arche_pdata);
+err_coldboot:
+	device_remove_file(&pdev->dev, &dev_attr_state);
+	return ret;
 }
 
 static int arche_remove_child(struct device *dev, void *unused)

commit 25847ee7c9517f91323f9139713ebdc94c865a2e
Author: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
Date:   Mon Feb 22 17:27:25 2016 +0530

    greybus: arche-platform: Avoid doing same thing again in poweroff fn
    
    If user switches from fw_flashing => off mode, then we do not need
    to do same things again, for example, clk_disable and wake/detect event,
    as while switching to fw_flashing, driver makes sure that device goes
    to off state and then brings back in fw_flashing state.
    
    Testing Done: Tested on DB3.5 platform.
    
    Signed-off-by: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/arche-platform.c b/drivers/staging/greybus/arche-platform.c
index 2dc11fdc5b88..efeafb373cf1 100644
--- a/drivers/staging/greybus/arche-platform.c
+++ b/drivers/staging/greybus/arche-platform.c
@@ -185,11 +185,15 @@ static void arche_platform_poweroff_seq(struct arche_platform_drvdata *arche_pda
 	if (arche_pdata->state == ARCHE_PLATFORM_STATE_OFF)
 		return;
 
-	/* Send disconnect/detach event to SVC */
-	gpio_set_value(arche_pdata->wake_detect_gpio, 0);
-	usleep_range(100, 200);
+	/* If in fw_flashing mode, then no need to repeate things again */
+	if (arche_pdata->state != ARCHE_PLATFORM_STATE_FW_FLASHING) {
+		/* Send disconnect/detach event to SVC */
+		gpio_set_value(arche_pdata->wake_detect_gpio, 0);
+		usleep_range(100, 200);
+
+		clk_disable_unprepare(arche_pdata->svc_ref_clk);
+	}
 
-	clk_disable_unprepare(arche_pdata->svc_ref_clk);
 	/* As part of exit, put APB back in reset state */
 	svc_reset_onoff(arche_pdata->svc_reset_gpio,
 			arche_pdata->is_reset_act_hi);

commit 599159b6877e665b086d6e3092203c651b8a3952
Author: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
Date:   Mon Feb 22 17:27:24 2016 +0530

    greybus: arche-platform: Return immediately if in same state from state change fns
    
    Have a check inside all individual operational state change functions
    to check whether device is in same state, and if yes, then return
    immediately.
    
    Testing Done: Tested on DB3.5 platform
    
    Signed-off-by: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/arche-platform.c b/drivers/staging/greybus/arche-platform.c
index 591cf9dc5071..2dc11fdc5b88 100644
--- a/drivers/staging/greybus/arche-platform.c
+++ b/drivers/staging/greybus/arche-platform.c
@@ -133,6 +133,9 @@ static int arche_platform_coldboot_seq(struct arche_platform_drvdata *arche_pdat
 {
 	int ret;
 
+	if (arche_pdata->state == ARCHE_PLATFORM_STATE_ACTIVE)
+		return 0;
+
 	dev_info(arche_pdata->dev, "Booting from cold boot state\n");
 
 	svc_reset_onoff(arche_pdata->svc_reset_gpio,
@@ -159,6 +162,9 @@ static int arche_platform_coldboot_seq(struct arche_platform_drvdata *arche_pdat
 
 static void arche_platform_fw_flashing_seq(struct arche_platform_drvdata *arche_pdata)
 {
+	if (arche_pdata->state == ARCHE_PLATFORM_STATE_FW_FLASHING)
+		return;
+
 	dev_info(arche_pdata->dev, "Switching to FW flashing state\n");
 
 	svc_reset_onoff(arche_pdata->svc_reset_gpio,
@@ -176,6 +182,9 @@ static void arche_platform_fw_flashing_seq(struct arche_platform_drvdata *arche_
 
 static void arche_platform_poweroff_seq(struct arche_platform_drvdata *arche_pdata)
 {
+	if (arche_pdata->state == ARCHE_PLATFORM_STATE_OFF)
+		return;
+
 	/* Send disconnect/detach event to SVC */
 	gpio_set_value(arche_pdata->wake_detect_gpio, 0);
 	usleep_range(100, 200);

commit ad4d3f95c9a25590da8b2b71dbbad838b80bf7dc
Author: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
Date:   Sat Feb 13 02:04:20 2016 +0530

    greybus: arche-platform: Control usb3613 from arche-platform
    
    USB3613 hub driver exports control function, which allows caller
    to switch the mode of operation of hub device.
    As we know that, we have dependency between HUB3613 and APB's where,
    HUB supposed to enter into HUB only after APB's brought out of reset.
    
    Until now, we had all userspace driver sequences to control this,
    but now since we are moving all resource management strictly to the
    driver, it makes sense (even though it looks hacky) to enable control
    of hub3613 from arche-platform driver.
    
    Note that, there is another discussion where, the hub.connect IO pin may
    get interfaced with MSM gpio, at that time, we can get rid of this hack
    and replace it with gpio control.
    
    Testing Done: Tested on EVT1.2 and DB3.5 platform.
    
    Signed-off-by: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/arche-platform.c b/drivers/staging/greybus/arche-platform.c
index 1fd806f6580d..591cf9dc5071 100644
--- a/drivers/staging/greybus/arche-platform.c
+++ b/drivers/staging/greybus/arche-platform.c
@@ -19,6 +19,8 @@
 #include <linux/pm.h>
 #include "arche_platform.h"
 
+#include <linux/usb/usb3613.h>
+
 struct arche_platform_drvdata {
 	/* Control GPIO signals to and from AP <=> SVC */
 	int svc_reset_gpio;
@@ -121,6 +123,10 @@ static void svc_delayed_work(struct work_struct *work)
 
 	/* re-assert wake_detect to confirm SVC WAKE_OUT */
 	gpio_direction_output(arche_pdata->wake_detect_gpio, 1);
+
+	/* Enable HUB3613 into HUB mode. */
+	if (usb3613_hub_mode_ctrl(true))
+		dev_warn(arche_pdata->dev, "failed to control hub device\n");
 }
 
 static int arche_platform_coldboot_seq(struct arche_platform_drvdata *arche_pdata)
@@ -197,6 +203,11 @@ static ssize_t state_store(struct device *dev,
 		device_for_each_child(arche_pdata->dev, NULL, apb_poweroff);
 
 		arche_platform_poweroff_seq(arche_pdata);
+
+		ret = usb3613_hub_mode_ctrl(false);
+		if (ret)
+			dev_warn(arche_pdata->dev, "failed to control hub device\n");
+			/* TODO: Should we do anything more here ?? */
 	} else if (sysfs_streq(buf, "active")) {
 		if (arche_pdata->state == ARCHE_PLATFORM_STATE_ACTIVE)
 			return count;
@@ -219,6 +230,11 @@ static ssize_t state_store(struct device *dev,
 
 		arche_platform_poweroff_seq(arche_pdata);
 
+		ret = usb3613_hub_mode_ctrl(false);
+		if (ret)
+			dev_warn(arche_pdata->dev, "failed to control hub device\n");
+			/* TODO: Should we do anything more here ?? */
+
 		arche_platform_fw_flashing_seq(arche_pdata);
 
 		device_for_each_child(arche_pdata->dev, NULL, apb_fw_flashing_state);
@@ -393,6 +409,9 @@ static int arche_platform_remove(struct platform_device *pdev)
 	arche_platform_poweroff_seq(arche_pdata);
 	platform_set_drvdata(pdev, NULL);
 
+	if (usb3613_hub_mode_ctrl(false))
+		dev_warn(arche_pdata->dev, "failed to control hub device\n");
+		/* TODO: Should we do anything more here ?? */
 	return 0;
 }
 

commit b03249390806c48921e1a538673276ebfcb645b7
Author: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
Date:   Sat Feb 13 02:04:18 2016 +0530

    greybus: arche-platform: Do not export any gpios
    
    With addition of operational state in driver, user/developer
    can switch to FW flashing state through sysfs. So no need to
    export any gpios to userspace now.
    
    Testing Done: Tested on EVT1.2 and DB3.5 platform
    
    Signed-off-by: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/arche-platform.c b/drivers/staging/greybus/arche-platform.c
index 037e14206059..1fd806f6580d 100644
--- a/drivers/staging/greybus/arche-platform.c
+++ b/drivers/staging/greybus/arche-platform.c
@@ -123,19 +123,6 @@ static void svc_delayed_work(struct work_struct *work)
 	gpio_direction_output(arche_pdata->wake_detect_gpio, 1);
 }
 
-/* Export gpio's to user space */
-static void export_gpios(struct arche_platform_drvdata *arche_pdata)
-{
-	gpio_export(arche_pdata->svc_reset_gpio, false);
-	gpio_export(arche_pdata->svc_sysboot_gpio, false);
-}
-
-static void unexport_gpios(struct arche_platform_drvdata *arche_pdata)
-{
-	gpio_unexport(arche_pdata->svc_reset_gpio);
-	gpio_unexport(arche_pdata->svc_sysboot_gpio);
-}
-
 static int arche_platform_coldboot_seq(struct arche_platform_drvdata *arche_pdata)
 {
 	int ret;
@@ -383,8 +370,6 @@ static int arche_platform_probe(struct platform_device *pdev)
 	INIT_DELAYED_WORK(&arche_pdata->delayed_work, svc_delayed_work);
 	schedule_delayed_work(&arche_pdata->delayed_work, msecs_to_jiffies(2000));
 
-	export_gpios(arche_pdata);
-
 	dev_info(dev, "Device registered successfully\n");
 	return 0;
 }
@@ -407,7 +392,6 @@ static int arche_platform_remove(struct platform_device *pdev)
 	device_for_each_child(&pdev->dev, NULL, arche_remove_child);
 	arche_platform_poweroff_seq(arche_pdata);
 	platform_set_drvdata(pdev, NULL);
-	unexport_gpios(arche_pdata);
 
 	return 0;
 }

commit fd60ac585607979e37b64ecec8afb898f9ad6a85
Author: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
Date:   Sat Feb 13 02:04:17 2016 +0530

    greybus: arche-platform: Fix boot, poweroff and fw_flashing seq with APBs
    
    Now SVC driver has an access to APBs operational functions
    (coldboot, standby_boot, fw_flashing and poweroff), SVC driver
    can control APB's as per below rules,
    
     - If SVC goes down (poweroff state), it will also power off APBs
       and vice a versa for all operational states.
     - On boot, SVC will probe/populate APB device, but will not coldboot
       it. APBs will coldboot only after handshaking with SVC over
       wake/detect line.
       Note that, both APBs share same wake/detect line.
    
    So from user/developer perspective, it is highly recommended that
    they should use arche-platform interfaces, instead of individual
    apb interface,
    
     # echo [off/active/standby/fw_flashing] > /sys/devices/arche_platform.*/state
    
    Note: 'standby' mode is not supported as of now.
    
    Testing Done: Testd on EVT1.2 and DB3.5 platform.
    
    Signed-off-by: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/arche-platform.c b/drivers/staging/greybus/arche-platform.c
index 3e6432f0f1bc..037e14206059 100644
--- a/drivers/staging/greybus/arche-platform.c
+++ b/drivers/staging/greybus/arche-platform.c
@@ -45,6 +45,37 @@ static inline void svc_reset_onoff(unsigned int gpio, bool onoff)
 	gpio_set_value(gpio, onoff);
 }
 
+static int apb_cold_boot(struct device *dev, void *data)
+{
+	int ret;
+
+	ret = apb_ctrl_coldboot(dev);
+	if (ret)
+		dev_warn(dev, "failed to coldboot\n");
+
+	/*Child nodes are independent, so do not exit coldboot operation */
+	return 0;
+}
+
+static int apb_fw_flashing_state(struct device *dev, void *data)
+{
+	int ret;
+
+	ret = apb_ctrl_fw_flashing(dev);
+	if (ret)
+		dev_warn(dev, "failed to switch to fw flashing state\n");
+
+	/*Child nodes are independent, so do not exit coldboot operation */
+	return 0;
+}
+
+static int apb_poweroff(struct device *dev, void *data)
+{
+	apb_ctrl_poweroff(dev);
+
+	return 0;
+}
+
 /**
  * svc_delayed_work - Time to give SVC to boot.
  */
@@ -52,10 +83,7 @@ static void svc_delayed_work(struct work_struct *work)
 {
 	struct arche_platform_drvdata *arche_pdata =
 		container_of(work, struct arche_platform_drvdata, delayed_work.work);
-	struct device *dev = arche_pdata->dev;
-	struct device_node *np = dev->of_node;
 	int timeout = 50;
-	int ret;
 
 	/*
 	 * 1.   SVC and AP boot independently, with AP<-->SVC wake/detect pin
@@ -79,18 +107,20 @@ static void svc_delayed_work(struct work_struct *work)
 		msleep(100);
 	} while(timeout--);
 
-	if (timeout >= 0) {
-		ret = of_platform_populate(np, NULL, NULL, dev);
-		if (!ret) {
-			/* re-assert wake_detect to confirm SVC WAKE_OUT */
-			gpio_direction_output(arche_pdata->wake_detect_gpio, 1);
-			return;
-		}
+	if (timeout < 0) {
+		/* FIXME: We may want to limit retries here */
+		dev_warn(arche_pdata->dev,
+			"Timed out on wake/detect, rescheduling handshake\n");
+		gpio_direction_output(arche_pdata->wake_detect_gpio, 0);
+		schedule_delayed_work(&arche_pdata->delayed_work, msecs_to_jiffies(2000));
+		return;
 	}
 
-	/* FIXME: We may want to limit retries here */
-	gpio_direction_output(arche_pdata->wake_detect_gpio, 0);
-	schedule_delayed_work(&arche_pdata->delayed_work, msecs_to_jiffies(2000));
+	/* Bring APB out of reset: cold boot sequence */
+	device_for_each_child(arche_pdata->dev, NULL, apb_cold_boot);
+
+	/* re-assert wake_detect to confirm SVC WAKE_OUT */
+	gpio_direction_output(arche_pdata->wake_detect_gpio, 1);
 }
 
 /* Export gpio's to user space */
@@ -176,12 +206,17 @@ static ssize_t state_store(struct device *dev,
 		if (arche_pdata->state == ARCHE_PLATFORM_STATE_OFF)
 			return count;
 
+		/*  If SVC goes down, bring down APB's as well */
+		device_for_each_child(arche_pdata->dev, NULL, apb_poweroff);
+
 		arche_platform_poweroff_seq(arche_pdata);
 	} else if (sysfs_streq(buf, "active")) {
 		if (arche_pdata->state == ARCHE_PLATFORM_STATE_ACTIVE)
 			return count;
 
 		ret = arche_platform_coldboot_seq(arche_pdata);
+		/* Give enough time for SVC to boot and then handshake with SVC */
+		schedule_delayed_work(&arche_pdata->delayed_work, msecs_to_jiffies(2000));
 	} else if (sysfs_streq(buf, "standby")) {
 		if (arche_pdata->state == ARCHE_PLATFORM_STATE_STANDBY)
 			return count;
@@ -193,8 +228,13 @@ static ssize_t state_store(struct device *dev,
 
 		/* First we want to make sure we power off everything
 		 * and then enter FW flashing state */
+		device_for_each_child(arche_pdata->dev, NULL, apb_poweroff);
+
 		arche_platform_poweroff_seq(arche_pdata);
+
 		arche_platform_fw_flashing_seq(arche_pdata);
+
+		device_for_each_child(arche_pdata->dev, NULL, apb_fw_flashing_state);
 	} else {
 		dev_err(arche_pdata->dev, "unknown state\n");
 		ret = -EINVAL;
@@ -321,8 +361,6 @@ static int arche_platform_probe(struct platform_device *pdev)
 	gpio_direction_output(arche_pdata->wake_detect_gpio, 0);
 
 	arche_pdata->dev = &pdev->dev;
-	INIT_DELAYED_WORK(&arche_pdata->delayed_work, svc_delayed_work);
-	schedule_delayed_work(&arche_pdata->delayed_work, msecs_to_jiffies(2000));
 
 	ret = device_create_file(dev, &dev_attr_state);
 	if (ret) {
@@ -336,6 +374,15 @@ static int arche_platform_probe(struct platform_device *pdev)
 		return ret;
 	}
 
+	ret = of_platform_populate(np, NULL, NULL, dev);
+	if (ret) {
+		dev_err(dev, "failed to populate child nodes %d\n", ret);
+		return ret;
+	}
+
+	INIT_DELAYED_WORK(&arche_pdata->delayed_work, svc_delayed_work);
+	schedule_delayed_work(&arche_pdata->delayed_work, msecs_to_jiffies(2000));
+
 	export_gpios(arche_pdata);
 
 	dev_info(dev, "Device registered successfully\n");

commit 7691fed20e7301bd89b04d38f88262c83279817a
Author: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
Date:   Sat Feb 13 02:04:08 2016 +0530

    greybus: arche-platform: Introduce FW_FLASHING state
    
    Introduce FW_FLASHING state to arche-platform driver, to enable
    user space to flash/upgrade SVC firmware.
    
    Command to enter into flashing state:
    
      # echo fw_flashing > /sys/devices/arche_platform.*/state
    
    Testing Done: Tested on EVT1.2 and DB3.5 platform.
    
    Signed-off-by: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/arche-platform.c b/drivers/staging/greybus/arche-platform.c
index 1dd2b08225c4..3e6432f0f1bc 100644
--- a/drivers/staging/greybus/arche-platform.c
+++ b/drivers/staging/greybus/arche-platform.c
@@ -134,6 +134,23 @@ static int arche_platform_coldboot_seq(struct arche_platform_drvdata *arche_pdat
 	return 0;
 }
 
+static void arche_platform_fw_flashing_seq(struct arche_platform_drvdata *arche_pdata)
+{
+	dev_info(arche_pdata->dev, "Switching to FW flashing state\n");
+
+	svc_reset_onoff(arche_pdata->svc_reset_gpio,
+			arche_pdata->is_reset_act_hi);
+
+	gpio_set_value(arche_pdata->svc_sysboot_gpio, 1);
+
+	usleep_range(100, 200);
+	svc_reset_onoff(arche_pdata->svc_reset_gpio,
+			!arche_pdata->is_reset_act_hi);
+
+	arche_pdata->state = ARCHE_PLATFORM_STATE_FW_FLASHING;
+
+}
+
 static void arche_platform_poweroff_seq(struct arche_platform_drvdata *arche_pdata)
 {
 	/* Send disconnect/detach event to SVC */
@@ -170,6 +187,14 @@ static ssize_t state_store(struct device *dev,
 			return count;
 
 		dev_warn(arche_pdata->dev, "standby state not supported\n");
+	} else if (sysfs_streq(buf, "fw_flashing")) {
+		if (arche_pdata->state == ARCHE_PLATFORM_STATE_FW_FLASHING)
+			return count;
+
+		/* First we want to make sure we power off everything
+		 * and then enter FW flashing state */
+		arche_platform_poweroff_seq(arche_pdata);
+		arche_platform_fw_flashing_seq(arche_pdata);
 	} else {
 		dev_err(arche_pdata->dev, "unknown state\n");
 		ret = -EINVAL;
@@ -190,6 +215,8 @@ static ssize_t state_show(struct device *dev,
 		return sprintf(buf, "active\n");
 	case ARCHE_PLATFORM_STATE_STANDBY:
 		return sprintf(buf, "standby\n");
+	case ARCHE_PLATFORM_STATE_FW_FLASHING:
+		return sprintf(buf, "fw_flashing\n");
 	default:
 		return sprintf(buf, "unknown state\n");
 	}

commit 2923c58eb5acb019e6781dc05662b896e14339f6
Author: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
Date:   Sat Feb 13 02:04:07 2016 +0530

    greybus: arche_platform: Add sysfs to allow user to change state
    
    This patch introduces sysfs interface for the user space to enable
    operational state change of the driver.
    Currently, driver supports, 'off', 'active' and 'standby'
    
    Note that, driver doesn't do anything for standby state as of today.
    
    To see the current state
    
          # cat /sys/devices/arche_platform.*/state
    
    And to change the state
          # echo [off/active/standby] > /sys/devices/arche_platform.*/state
    
    Testing Done: Tested on EVT1.2 and DB3.5 platform.
    
    Signed-off-by: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/arche-platform.c b/drivers/staging/greybus/arche-platform.c
index b2f3919f7cb3..1dd2b08225c4 100644
--- a/drivers/staging/greybus/arche-platform.c
+++ b/drivers/staging/greybus/arche-platform.c
@@ -148,6 +148,55 @@ static void arche_platform_poweroff_seq(struct arche_platform_drvdata *arche_pda
 	arche_pdata->state = ARCHE_PLATFORM_STATE_OFF;
 }
 
+static ssize_t state_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct arche_platform_drvdata *arche_pdata = platform_get_drvdata(pdev);
+	int ret = 0;
+
+	if (sysfs_streq(buf, "off")) {
+		if (arche_pdata->state == ARCHE_PLATFORM_STATE_OFF)
+			return count;
+
+		arche_platform_poweroff_seq(arche_pdata);
+	} else if (sysfs_streq(buf, "active")) {
+		if (arche_pdata->state == ARCHE_PLATFORM_STATE_ACTIVE)
+			return count;
+
+		ret = arche_platform_coldboot_seq(arche_pdata);
+	} else if (sysfs_streq(buf, "standby")) {
+		if (arche_pdata->state == ARCHE_PLATFORM_STATE_STANDBY)
+			return count;
+
+		dev_warn(arche_pdata->dev, "standby state not supported\n");
+	} else {
+		dev_err(arche_pdata->dev, "unknown state\n");
+		ret = -EINVAL;
+	}
+
+	return ret ? ret : count;
+}
+
+static ssize_t state_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct arche_platform_drvdata *arche_pdata = dev_get_drvdata(dev);
+
+	switch (arche_pdata->state) {
+	case ARCHE_PLATFORM_STATE_OFF:
+		return sprintf(buf, "off\n");
+	case ARCHE_PLATFORM_STATE_ACTIVE:
+		return sprintf(buf, "active\n");
+	case ARCHE_PLATFORM_STATE_STANDBY:
+		return sprintf(buf, "standby\n");
+	default:
+		return sprintf(buf, "unknown state\n");
+	}
+}
+
+static DEVICE_ATTR_RW(state);
+
 static int arche_platform_probe(struct platform_device *pdev)
 {
 	struct arche_platform_drvdata *arche_pdata;
@@ -248,6 +297,12 @@ static int arche_platform_probe(struct platform_device *pdev)
 	INIT_DELAYED_WORK(&arche_pdata->delayed_work, svc_delayed_work);
 	schedule_delayed_work(&arche_pdata->delayed_work, msecs_to_jiffies(2000));
 
+	ret = device_create_file(dev, &dev_attr_state);
+	if (ret) {
+		dev_err(dev, "failed to create state file in sysfs\n");
+		return ret;
+	}
+
 	ret = arche_platform_coldboot_seq(arche_pdata);
 	if (ret) {
 		dev_err(dev, "Failed to cold boot svc %d\n", ret);
@@ -273,6 +328,7 @@ static int arche_platform_remove(struct platform_device *pdev)
 {
 	struct arche_platform_drvdata *arche_pdata = platform_get_drvdata(pdev);
 
+	device_remove_file(&pdev->dev, &dev_attr_state);
 	cancel_delayed_work_sync(&arche_pdata->delayed_work);
 	device_for_each_child(&pdev->dev, NULL, arche_remove_child);
 	arche_platform_poweroff_seq(arche_pdata);

commit b4c95fca6a9dd8ac2242a451e53781d5313b8c1d
Author: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
Date:   Sat Feb 13 02:04:06 2016 +0530

    greybus: arche-platform: Pull wake/detect low in poweroff
    
    When SVC goes down, make sure that wake/detect is also pulled low.
    Note that this is not the criteria for SVC poweroff, but it is required
    to have right state on wake/detect line before powering off.
    And on next boot, the boot-sequence code would take care of
    handshaking with SVC.
    
    Tested-on: Tested on EVT1.2 and DB3.5 platform.
    
    Signed-off-by: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/arche-platform.c b/drivers/staging/greybus/arche-platform.c
index 1336fc4194c7..b2f3919f7cb3 100644
--- a/drivers/staging/greybus/arche-platform.c
+++ b/drivers/staging/greybus/arche-platform.c
@@ -136,6 +136,10 @@ static int arche_platform_coldboot_seq(struct arche_platform_drvdata *arche_pdat
 
 static void arche_platform_poweroff_seq(struct arche_platform_drvdata *arche_pdata)
 {
+	/* Send disconnect/detach event to SVC */
+	gpio_set_value(arche_pdata->wake_detect_gpio, 0);
+	usleep_range(100, 200);
+
 	clk_disable_unprepare(arche_pdata->svc_ref_clk);
 	/* As part of exit, put APB back in reset state */
 	svc_reset_onoff(arche_pdata->svc_reset_gpio,

commit e74d04a5810233a95cb7a556165817d378b89e44
Author: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
Date:   Sat Feb 13 02:04:05 2016 +0530

    greybus: arche-platform: Add state variable to driver data
    
    This is preparation for operational state support.
    So in order to provide operational state transitions, driver needs to
    maintain state. So add 'enum arche_platform_state' variable to
    'struct arche_platform_drvdata'
    
    Testing Done: Tested on EVT1.2 and DB3.5 platform.
    
    Signed-off-by: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/arche-platform.c b/drivers/staging/greybus/arche-platform.c
index 48ab1eb24d63..1336fc4194c7 100644
--- a/drivers/staging/greybus/arche-platform.c
+++ b/drivers/staging/greybus/arche-platform.c
@@ -26,6 +26,8 @@ struct arche_platform_drvdata {
 	int svc_sysboot_gpio;
 	int wake_detect_gpio; /* bi-dir,maps to WAKE_MOD & WAKE_FRAME signals */
 
+	enum arche_platform_state state;
+
 	unsigned int svc_refclk_req;
 	struct clk *svc_ref_clk;
 
@@ -127,6 +129,8 @@ static int arche_platform_coldboot_seq(struct arche_platform_drvdata *arche_pdat
 	svc_reset_onoff(arche_pdata->svc_reset_gpio,
 			!arche_pdata->is_reset_act_hi);
 
+	arche_pdata->state = ARCHE_PLATFORM_STATE_ACTIVE;
+
 	return 0;
 }
 
@@ -136,6 +140,8 @@ static void arche_platform_poweroff_seq(struct arche_platform_drvdata *arche_pda
 	/* As part of exit, put APB back in reset state */
 	svc_reset_onoff(arche_pdata->svc_reset_gpio,
 			arche_pdata->is_reset_act_hi);
+
+	arche_pdata->state = ARCHE_PLATFORM_STATE_OFF;
 }
 
 static int arche_platform_probe(struct platform_device *pdev)
@@ -168,6 +174,7 @@ static int arche_platform_probe(struct platform_device *pdev)
 		dev_err(dev, "failed to set svc-reset gpio dir:%d\n", ret);
 		return ret;
 	}
+	arche_pdata->state = ARCHE_PLATFORM_STATE_OFF;
 
 	arche_pdata->svc_sysboot_gpio = of_get_named_gpio(np,
 					"svc,sysboot-gpio", 0);

commit 5993e2bfd848538b1f3e8e3de6412f76e600c69f
Author: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
Date:   Sat Feb 13 02:04:04 2016 +0530

    greybus: arche-platform: Rename cleanup fn to poweroff_seq
    
    In sync with operational states, rename arche_platform_cleanup() fn
    to arche_platform_poweroff_seq() fn.
    
    Testing Done: Tested on EVT1.2 and DB3.5 platform.
    
    Signed-off-by: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/arche-platform.c b/drivers/staging/greybus/arche-platform.c
index 3b7974dad12a..48ab1eb24d63 100644
--- a/drivers/staging/greybus/arche-platform.c
+++ b/drivers/staging/greybus/arche-platform.c
@@ -130,7 +130,7 @@ static int arche_platform_coldboot_seq(struct arche_platform_drvdata *arche_pdat
 	return 0;
 }
 
-static void arche_platform_cleanup(struct arche_platform_drvdata *arche_pdata)
+static void arche_platform_poweroff_seq(struct arche_platform_drvdata *arche_pdata)
 {
 	clk_disable_unprepare(arche_pdata->svc_ref_clk);
 	/* As part of exit, put APB back in reset state */
@@ -264,7 +264,7 @@ static int arche_platform_remove(struct platform_device *pdev)
 
 	cancel_delayed_work_sync(&arche_pdata->delayed_work);
 	device_for_each_child(&pdev->dev, NULL, arche_remove_child);
-	arche_platform_cleanup(arche_pdata);
+	arche_platform_poweroff_seq(arche_pdata);
 	platform_set_drvdata(pdev, NULL);
 	unexport_gpios(arche_pdata);
 

commit 49e6e04bb44e4f3bf2c6d3c2c096257da2cb54ff
Author: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
Date:   Sat Feb 13 01:15:11 2016 +0530

    greybus: arche-platform: Cancel delayed_work in driver remove fn
    
    This is a bug fix, where as part of cleanup, delayed work was not
    canceled in driver remove function. So fix it.
    
    Testing Done: Tested on EVT1.2 and DB3.5 platform.
    
    Signed-off-by: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/arche-platform.c b/drivers/staging/greybus/arche-platform.c
index f3674301a2e6..3b7974dad12a 100644
--- a/drivers/staging/greybus/arche-platform.c
+++ b/drivers/staging/greybus/arche-platform.c
@@ -262,6 +262,7 @@ static int arche_platform_remove(struct platform_device *pdev)
 {
 	struct arche_platform_drvdata *arche_pdata = platform_get_drvdata(pdev);
 
+	cancel_delayed_work_sync(&arche_pdata->delayed_work);
 	device_for_each_child(&pdev->dev, NULL, arche_remove_child);
 	arche_platform_cleanup(arche_pdata);
 	platform_set_drvdata(pdev, NULL);

commit 758ca99de9961036675048e1487713e801b184db
Author: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
Date:   Sat Feb 13 02:04:03 2016 +0530

    greybus: arche-platform: Introduce coldboot_seq fn
    
    This is preparation for support for different operational states
    (defined by arche_platform_state) in the driver, to enable
    user/developer to dynamically configure the state.
    
    arche_platform_coldboot_seq() fn will be responsible for
    rebooting SVC device.
    
    Testing Done: Tested on EVT1.2 and DB3.5 platform
    
    Signed-off-by: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/arche-platform.c b/drivers/staging/greybus/arche-platform.c
index 65c8f718dd86..f3674301a2e6 100644
--- a/drivers/staging/greybus/arche-platform.c
+++ b/drivers/staging/greybus/arche-platform.c
@@ -104,6 +104,32 @@ static void unexport_gpios(struct arche_platform_drvdata *arche_pdata)
 	gpio_unexport(arche_pdata->svc_sysboot_gpio);
 }
 
+static int arche_platform_coldboot_seq(struct arche_platform_drvdata *arche_pdata)
+{
+	int ret;
+
+	dev_info(arche_pdata->dev, "Booting from cold boot state\n");
+
+	svc_reset_onoff(arche_pdata->svc_reset_gpio,
+			arche_pdata->is_reset_act_hi);
+
+	gpio_set_value(arche_pdata->svc_sysboot_gpio, 0);
+	usleep_range(100, 200);
+
+	ret = clk_prepare_enable(arche_pdata->svc_ref_clk);
+	if (ret) {
+		dev_err(arche_pdata->dev, "failed to enable svc_ref_clk: %d\n",
+				ret);
+		return ret;
+	}
+
+	/* bring SVC out of reset */
+	svc_reset_onoff(arche_pdata->svc_reset_gpio,
+			!arche_pdata->is_reset_act_hi);
+
+	return 0;
+}
+
 static void arche_platform_cleanup(struct arche_platform_drvdata *arche_pdata)
 {
 	clk_disable_unprepare(arche_pdata->svc_ref_clk);
@@ -185,11 +211,6 @@ static int arche_platform_probe(struct platform_device *pdev)
 		dev_err(dev, "failed to get svc_ref_clk: %d\n", ret);
 		return ret;
 	}
-	ret = clk_prepare_enable(arche_pdata->svc_ref_clk);
-	if (ret) {
-		dev_err(dev, "failed to enable svc_ref_clk: %d\n", ret);
-		return ret;
-	}
 
 	platform_set_drvdata(pdev, arche_pdata);
 
@@ -200,34 +221,32 @@ static int arche_platform_probe(struct platform_device *pdev)
 	if (arche_pdata->wake_detect_gpio < 0) {
 		dev_err(dev, "failed to get wake detect gpio\n");
 		ret = arche_pdata->wake_detect_gpio;
-		goto exit;
+		return ret;
 	}
 
 	ret = devm_gpio_request(dev, arche_pdata->wake_detect_gpio, "wake detect");
 	if (ret) {
 		dev_err(dev, "Failed requesting wake_detect gpio %d\n",
 				arche_pdata->wake_detect_gpio);
-		goto exit;
+		return ret;
 	}
 	/* deassert wake detect */
 	gpio_direction_output(arche_pdata->wake_detect_gpio, 0);
 
-	/* bring SVC out of reset */
-	svc_reset_onoff(arche_pdata->svc_reset_gpio,
-			!arche_pdata->is_reset_act_hi);
-
 	arche_pdata->dev = &pdev->dev;
 	INIT_DELAYED_WORK(&arche_pdata->delayed_work, svc_delayed_work);
 	schedule_delayed_work(&arche_pdata->delayed_work, msecs_to_jiffies(2000));
 
+	ret = arche_platform_coldboot_seq(arche_pdata);
+	if (ret) {
+		dev_err(dev, "Failed to cold boot svc %d\n", ret);
+		return ret;
+	}
+
 	export_gpios(arche_pdata);
 
 	dev_info(dev, "Device registered successfully\n");
 	return 0;
-
-exit:
-	arche_platform_cleanup(arche_pdata);
-	return ret;
 }
 
 static int arche_remove_child(struct device *dev, void *unused)

commit a3043d9e717ace89a34352e57d88c70584f9c768
Author: Michael Scott <michael.scott@linaro.org>
Date:   Wed Jan 27 16:41:01 2016 -0800

    greybus: arche-platform: reduce wait between WAKE_OUT checks
    
    SVC WAKE_OUT loop is estimated 400ms during which wake_detect line
    is pulled low for AP detection.  On AP side we have 500ms delay
    between checks.  To avoid timing issues, reduce delay between
    checks and raise total # of checks so that overall time for sequence
    is the same.
    
    Testing Done:
    - Used for DB3.5/EVT1.5 hardware during bringup
    - Regression tested on DB3.1+ES2, DB3.1+ES3
    
    Signed-off-by: Michael Scott <michael.scott@linaro.org>
    Reviewed-by: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
    Tested-by: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/arche-platform.c b/drivers/staging/greybus/arche-platform.c
index f18cec624f78..65c8f718dd86 100644
--- a/drivers/staging/greybus/arche-platform.c
+++ b/drivers/staging/greybus/arche-platform.c
@@ -52,7 +52,7 @@ static void svc_delayed_work(struct work_struct *work)
 		container_of(work, struct arche_platform_drvdata, delayed_work.work);
 	struct device *dev = arche_pdata->dev;
 	struct device_node *np = dev->of_node;
-	int timeout = 10;
+	int timeout = 50;
 	int ret;
 
 	/*
@@ -74,7 +74,7 @@ static void svc_delayed_work(struct work_struct *work)
 		if (gpio_get_value(arche_pdata->wake_detect_gpio) == 0)
 			break;
 
-		msleep(500);
+		msleep(100);
 	} while(timeout--);
 
 	if (timeout >= 0) {

commit 1e83ee3321447679eb327fed90f366ef18411778
Author: Michael Scott <michael.scott@linaro.org>
Date:   Wed Jan 27 16:41:00 2016 -0800

    greybus: arche-platform: assert wake-detect to complete WAKE_OUT event
    
    After SVC generates WAKE_OUT (pulling wake-detect pin low) and APB is
    brought out of reset, we need to assert wake-detect again to complete
    SVC WAKE_OUT logic.
    
    Testing Done:
    - Used for DB3.5/EVT1.5 hardware during bringup
    - Regression tested on DB3.1+ES2, DB3.1+ES3
    
    Signed-off-by: Michael Scott <michael.scott@linaro.org>
    Reviewed-by: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
    Tested-by: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/arche-platform.c b/drivers/staging/greybus/arche-platform.c
index b6fb90e9c7dc..f18cec624f78 100644
--- a/drivers/staging/greybus/arche-platform.c
+++ b/drivers/staging/greybus/arche-platform.c
@@ -79,9 +79,11 @@ static void svc_delayed_work(struct work_struct *work)
 
 	if (timeout >= 0) {
 		ret = of_platform_populate(np, NULL, NULL, dev);
-		if (!ret)
-			/* Should we set wake_detect gpio to output again? */
+		if (!ret) {
+			/* re-assert wake_detect to confirm SVC WAKE_OUT */
+			gpio_direction_output(arche_pdata->wake_detect_gpio, 1);
 			return;
+		}
 	}
 
 	/* FIXME: We may want to limit retries here */

commit 9e1aef82af47edd1697449ca8be5fd3c1c58b9bb
Author: Michael Scott <michael.scott@linaro.org>
Date:   Wed Jan 27 16:40:59 2016 -0800

    greybus: arche-platform: bring SVC out of reset later in probe
    
    Move SVC deassert reset to after wake-detect pin has been pulled
    low in probe.  Otherwise, SVC may trigger WAKE_OUT based on a
    default high signal.
    
    Testing Done:
    - Used for DB3.5/EVT1.5 hardware during bringup
    - Regression tested on DB3.1+ES2, DB3.1+ES3
    
    Signed-off-by: Michael Scott <michael.scott@linaro.org>
    Reviewed-by: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
    Tested-by: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/arche-platform.c b/drivers/staging/greybus/arche-platform.c
index 4e49be837b0e..b6fb90e9c7dc 100644
--- a/drivers/staging/greybus/arche-platform.c
+++ b/drivers/staging/greybus/arche-platform.c
@@ -191,10 +191,6 @@ static int arche_platform_probe(struct platform_device *pdev)
 
 	platform_set_drvdata(pdev, arche_pdata);
 
-	/* bring SVC out of reset */
-	svc_reset_onoff(arche_pdata->svc_reset_gpio,
-			!arche_pdata->is_reset_act_hi);
-
 	arche_pdata->num_apbs = of_get_child_count(np);
 	dev_dbg(dev, "Number of APB's available - %d\n", arche_pdata->num_apbs);
 
@@ -214,6 +210,10 @@ static int arche_platform_probe(struct platform_device *pdev)
 	/* deassert wake detect */
 	gpio_direction_output(arche_pdata->wake_detect_gpio, 0);
 
+	/* bring SVC out of reset */
+	svc_reset_onoff(arche_pdata->svc_reset_gpio,
+			!arche_pdata->is_reset_act_hi);
+
 	arche_pdata->dev = &pdev->dev;
 	INIT_DELAYED_WORK(&arche_pdata->delayed_work, svc_delayed_work);
 	schedule_delayed_work(&arche_pdata->delayed_work, msecs_to_jiffies(2000));

commit 057aad29f9dec26d49671c6744d070edb8594174
Author: Michael Scott <michael.scott@linaro.org>
Date:   Wed Jan 27 16:40:58 2016 -0800

    greybus: arche-platform: ensure wake-detect pin is deasserted
    
    During DB3.5 bringup, it was noted that wake_detect signal was not
    properly generating SVC edge IRQ.  To ensure signal goes from low
    to high correctly, let's bring signal low (regardless of default
    pin state).
    
    Testing Done:
    - Used for DB3.5/EVT1.5 hardware during bringup
    - Regression tested on DB3.1+ES2, DB3.1+ES3
    
    Signed-off-by: Michael Scott <michael.scott@linaro.org>
    Reviewed-by: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
    Tested-by: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/arche-platform.c b/drivers/staging/greybus/arche-platform.c
index b5596ec4409c..4e49be837b0e 100644
--- a/drivers/staging/greybus/arche-platform.c
+++ b/drivers/staging/greybus/arche-platform.c
@@ -211,6 +211,8 @@ static int arche_platform_probe(struct platform_device *pdev)
 				arche_pdata->wake_detect_gpio);
 		goto exit;
 	}
+	/* deassert wake detect */
+	gpio_direction_output(arche_pdata->wake_detect_gpio, 0);
 
 	arche_pdata->dev = &pdev->dev;
 	INIT_DELAYED_WORK(&arche_pdata->delayed_work, svc_delayed_work);

commit d8b16338df9bcef1fa0a047bd3e8d2e922dc5bb8
Author: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
Date:   Tue Jan 26 07:23:29 2016 +0530

    greybus: arche-platform: Disable clock as part of driver remove
    
    As part of driver remove (cleanup) function, disable the clock for both
    SVC, APB1 & APB2.
    
    Testing Done:
    Tested on EVT1 platform with Connect=>disconnect=>connect
    iteration, almost close to 100 iterations have passed (demo branch).
    And also tested with kernel-only build.
    
    Signed-off-by: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/arche-platform.c b/drivers/staging/greybus/arche-platform.c
index d12fa0e16a4b..b5596ec4409c 100644
--- a/drivers/staging/greybus/arche-platform.c
+++ b/drivers/staging/greybus/arche-platform.c
@@ -104,6 +104,7 @@ static void unexport_gpios(struct arche_platform_drvdata *arche_pdata)
 
 static void arche_platform_cleanup(struct arche_platform_drvdata *arche_pdata)
 {
+	clk_disable_unprepare(arche_pdata->svc_ref_clk);
 	/* As part of exit, put APB back in reset state */
 	svc_reset_onoff(arche_pdata->svc_reset_gpio,
 			arche_pdata->is_reset_act_hi);

commit a463fc1533c9ea2edc99306b31c74f472c62d690
Author: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
Date:   Mon Jan 11 17:41:24 2016 +0530

    greybus: arche-platform: Add wake/detect support along with handshaking with AP
    
    Add wake_detect support to arche-platform driver which is responsible
    for SVC control. This patch also adds code for handshaking between
    AP <=> SVC. The sequence is,
    
    1.   AP boots
         To keep compatibility between DB3 and EVT platform, SVC will be
         help in reset and AP driver would release it at appropriate time.
             wake/detect pin (WD8A) = Low
             reset (SVC/APB1/APB2) = Asserted (as per polarity)
    2.   AP Driver gets inserted
      2.1. AP will deassert reset to SVC (following power on sequence)
      2.2. SVC allows 360 milliseconds to elapse after switch boots to work
           around bug described in ENG-330.
      2.3. AP asserts wake/detect pin (WD8A = HIGH)
    3.   SVC detects assertion of wake/detect pin, and sends "wake out" signal to AP
    4.   AP receives "wake out" signal, takes AP Bridges through their power
         on reset sequence as defined in the bridge ASIC reference manuals
    5.   AP takes USB3613 through its power on reset sequence
    6.   AP should enumerates AP Bridges
    
    Note: ISR has been deliberately removed (not merged) as we are still
    not sure how it will be used, in runtime usage context. Driver as such
    doesn't do anything for runtime assert-n-deassert of reset to SVC/APB's,
    it just simply offloads it to user by exporting required gpio's.
    The exported gpio's are required for FW flashing from user space.
    When it comes to usersace manipulated control sequence, user has to manage.
    
    Signed-off-by: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
    Tested-by: Michael Scott <michael.scott@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/arche-platform.c b/drivers/staging/greybus/arche-platform.c
index 94e6f5dc6315..d12fa0e16a4b 100644
--- a/drivers/staging/greybus/arche-platform.c
+++ b/drivers/staging/greybus/arche-platform.c
@@ -8,6 +8,7 @@
  */
 
 #include <linux/clk.h>
+#include <linux/delay.h>
 #include <linux/gpio.h>
 #include <linux/init.h>
 #include <linux/module.h>
@@ -23,6 +24,7 @@ struct arche_platform_drvdata {
 	int svc_reset_gpio;
 	bool is_reset_act_hi;
 	int svc_sysboot_gpio;
+	int wake_detect_gpio; /* bi-dir,maps to WAKE_MOD & WAKE_FRAME signals */
 
 	unsigned int svc_refclk_req;
 	struct clk *svc_ref_clk;
@@ -31,6 +33,9 @@ struct arche_platform_drvdata {
 	struct pinctrl_state *pin_default;
 
 	int num_apbs;
+
+	struct delayed_work delayed_work;
+	struct device *dev;
 };
 
 static inline void svc_reset_onoff(unsigned int gpio, bool onoff)
@@ -38,6 +43,52 @@ static inline void svc_reset_onoff(unsigned int gpio, bool onoff)
 	gpio_set_value(gpio, onoff);
 }
 
+/**
+ * svc_delayed_work - Time to give SVC to boot.
+ */
+static void svc_delayed_work(struct work_struct *work)
+{
+	struct arche_platform_drvdata *arche_pdata =
+		container_of(work, struct arche_platform_drvdata, delayed_work.work);
+	struct device *dev = arche_pdata->dev;
+	struct device_node *np = dev->of_node;
+	int timeout = 10;
+	int ret;
+
+	/*
+	 * 1.   SVC and AP boot independently, with AP<-->SVC wake/detect pin
+	 *      deasserted (LOW in this case)
+	 * 2.1. SVC allows 360 milliseconds to elapse after switch boots to work
+	 *      around bug described in ENG-330.
+	 * 2.2. AP asserts wake/detect pin (HIGH) (this can proceed in parallel with 2.1)
+	 * 3.   SVC detects assertion of wake/detect pin, and sends "wake out" signal to AP
+	 * 4.   AP receives "wake out" signal, takes AP Bridges through their power
+	 *      on reset sequence as defined in the bridge ASIC reference manuals
+	 * 5. AP takes USB3613 through its power on reset sequence
+	 * 6. AP enumerates AP Bridges
+	 */
+	gpio_set_value(arche_pdata->wake_detect_gpio, 1);
+	gpio_direction_input(arche_pdata->wake_detect_gpio);
+	do {
+		/* Read the wake_detect GPIO, for WAKE_OUT event from SVC */
+		if (gpio_get_value(arche_pdata->wake_detect_gpio) == 0)
+			break;
+
+		msleep(500);
+	} while(timeout--);
+
+	if (timeout >= 0) {
+		ret = of_platform_populate(np, NULL, NULL, dev);
+		if (!ret)
+			/* Should we set wake_detect gpio to output again? */
+			return;
+	}
+
+	/* FIXME: We may want to limit retries here */
+	gpio_direction_output(arche_pdata->wake_detect_gpio, 0);
+	schedule_delayed_work(&arche_pdata->delayed_work, msecs_to_jiffies(2000));
+}
+
 /* Export gpio's to user space */
 static void export_gpios(struct arche_platform_drvdata *arche_pdata)
 {
@@ -146,18 +197,32 @@ static int arche_platform_probe(struct platform_device *pdev)
 	arche_pdata->num_apbs = of_get_child_count(np);
 	dev_dbg(dev, "Number of APB's available - %d\n", arche_pdata->num_apbs);
 
-	/* probe all childs here */
-	ret = of_platform_populate(np, NULL, NULL, dev);
+	arche_pdata->wake_detect_gpio = of_get_named_gpio(np, "svc,wake-detect-gpio", 0);
+	if (arche_pdata->wake_detect_gpio < 0) {
+		dev_err(dev, "failed to get wake detect gpio\n");
+		ret = arche_pdata->wake_detect_gpio;
+		goto exit;
+	}
+
+	ret = devm_gpio_request(dev, arche_pdata->wake_detect_gpio, "wake detect");
 	if (ret) {
-		arche_platform_cleanup(arche_pdata);
-		dev_err(dev, "no child node found\n");
-		return ret;
+		dev_err(dev, "Failed requesting wake_detect gpio %d\n",
+				arche_pdata->wake_detect_gpio);
+		goto exit;
 	}
 
+	arche_pdata->dev = &pdev->dev;
+	INIT_DELAYED_WORK(&arche_pdata->delayed_work, svc_delayed_work);
+	schedule_delayed_work(&arche_pdata->delayed_work, msecs_to_jiffies(2000));
+
 	export_gpios(arche_pdata);
 
 	dev_info(dev, "Device registered successfully\n");
 	return 0;
+
+exit:
+	arche_platform_cleanup(arche_pdata);
+	return ret;
 }
 
 static int arche_remove_child(struct device *dev, void *unused)

commit 3b858df01fe936bbd329ecf13c3a3d81486f1f16
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Mon Jan 11 11:29:17 2016 +0530

    greybus: arche: Remove unwanted headers and rearrange others
    
    This removes few unwanted headers related to irq, interrupt, regulator,
    spinlock, etc.
    
    Also arrange the rest in alphabetical order to make it more readable.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Reviewed-by: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/arche-platform.c b/drivers/staging/greybus/arche-platform.c
index 52c79ae792f4..94e6f5dc6315 100644
--- a/drivers/staging/greybus/arche-platform.c
+++ b/drivers/staging/greybus/arche-platform.c
@@ -7,22 +7,15 @@
  * Released under the GPLv2 only.
  */
 
-#include <linux/module.h>
-#include <linux/init.h>
-#include <linux/interrupt.h>
-#include <linux/irq.h>
-#include <linux/sched.h>
-#include <linux/pm.h>
-#include <linux/delay.h>
-#include <linux/platform_device.h>
-#include <linux/gpio.h>
 #include <linux/clk.h>
-#include <linux/of_platform.h>
+#include <linux/gpio.h>
+#include <linux/init.h>
+#include <linux/module.h>
 #include <linux/of_gpio.h>
-#include <linux/of_irq.h>
-#include <linux/spinlock.h>
-#include <linux/regulator/consumer.h>
+#include <linux/of_platform.h>
 #include <linux/pinctrl/consumer.h>
+#include <linux/platform_device.h>
+#include <linux/pm.h>
 #include "arche_platform.h"
 
 struct arche_platform_drvdata {

commit f1f251b59b6db97c42d7d746727072cb37604494
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Mon Jan 11 11:29:07 2016 +0530

    greybus: arche-platform: propagate errors returned by gpiolib
    
    Propagate errors returned by of_get_named_gpio() instead of sending
    -ENODEV.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Reviewed-by: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/arche-platform.c b/drivers/staging/greybus/arche-platform.c
index 93ecd8c8bed7..52c79ae792f4 100644
--- a/drivers/staging/greybus/arche-platform.c
+++ b/drivers/staging/greybus/arche-platform.c
@@ -82,7 +82,7 @@ static int arche_platform_probe(struct platform_device *pdev)
 	arche_pdata->svc_reset_gpio = of_get_named_gpio(np, "svc,reset-gpio", 0);
 	if (arche_pdata->svc_reset_gpio < 0) {
 		dev_err(dev, "failed to get reset-gpio\n");
-		return -ENODEV;
+		return arche_pdata->svc_reset_gpio;
 	}
 	ret = devm_gpio_request(dev, arche_pdata->svc_reset_gpio, "svc-reset");
 	if (ret) {
@@ -100,7 +100,7 @@ static int arche_platform_probe(struct platform_device *pdev)
 					"svc,sysboot-gpio", 0);
 	if (arche_pdata->svc_sysboot_gpio < 0) {
 		dev_err(dev, "failed to get sysboot gpio\n");
-		return -ENODEV;
+		return arche_pdata->svc_sysboot_gpio;
 	}
 	ret = devm_gpio_request(dev, arche_pdata->svc_sysboot_gpio, "sysboot0");
 	if (ret) {
@@ -118,7 +118,7 @@ static int arche_platform_probe(struct platform_device *pdev)
 					"svc,refclk-req-gpio", 0);
 	if (arche_pdata->svc_refclk_req < 0) {
 		dev_err(dev, "failed to get svc clock-req gpio\n");
-		return -ENODEV;
+		return arche_pdata->svc_refclk_req;
 	}
 	ret = devm_gpio_request(dev, arche_pdata->svc_refclk_req, "svc-clk-req");
 	if (ret) {

commit 140741ec6384435b1a0f89042a2a6dac8e2eebd2
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Mon Jan 11 11:29:06 2016 +0530

    greybus: arche-platform: svc_reset_gpio can't be invalid in arche_platform_cleanup()
    
    svc_reset_gpio is guaranteed to be valid in arche_platform_cleanup. Drop
    the useless check.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Reviewed-by: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/arche-platform.c b/drivers/staging/greybus/arche-platform.c
index 67bbd71ec3d1..93ecd8c8bed7 100644
--- a/drivers/staging/greybus/arche-platform.c
+++ b/drivers/staging/greybus/arche-platform.c
@@ -61,9 +61,8 @@ static void unexport_gpios(struct arche_platform_drvdata *arche_pdata)
 static void arche_platform_cleanup(struct arche_platform_drvdata *arche_pdata)
 {
 	/* As part of exit, put APB back in reset state */
-	if (gpio_is_valid(arche_pdata->svc_reset_gpio))
-		svc_reset_onoff(arche_pdata->svc_reset_gpio,
-				arche_pdata->is_reset_act_hi);
+	svc_reset_onoff(arche_pdata->svc_reset_gpio,
+			arche_pdata->is_reset_act_hi);
 }
 
 static int arche_platform_probe(struct platform_device *pdev)

commit 72a8c24b6dcae46c4e8c37c1b1d1adb6e6b8a72f
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Mon Jan 11 11:29:05 2016 +0530

    greybus: arche-platform: Put APB in reset if of_platform_populate() fails
    
    The current implementation around of_platform_populate() is not so
    great. On error, we first print an error message, followed by a success
    message and finally we return an error.
    
    And over that we don't undo what we did initially.
    
    This patch puts the APB back into reset and create a separate error
    path to make things clear.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Reviewed-by: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/arche-platform.c b/drivers/staging/greybus/arche-platform.c
index 93d90b2dc866..67bbd71ec3d1 100644
--- a/drivers/staging/greybus/arche-platform.c
+++ b/drivers/staging/greybus/arche-platform.c
@@ -156,13 +156,16 @@ static int arche_platform_probe(struct platform_device *pdev)
 
 	/* probe all childs here */
 	ret = of_platform_populate(np, NULL, NULL, dev);
-	if (ret)
+	if (ret) {
+		arche_platform_cleanup(arche_pdata);
 		dev_err(dev, "no child node found\n");
+		return ret;
+	}
 
 	export_gpios(arche_pdata);
 
 	dev_info(dev, "Device registered successfully\n");
-	return ret;
+	return 0;
 }
 
 static int arche_remove_child(struct device *dev, void *unused)

commit 8adf71d1b43aa1c449d22dd8e6f6c29957872a7f
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Mon Jan 11 11:29:04 2016 +0530

    greybus: arche-platform: Export GPIOs after populating APBs
    
    Populating APBs operation can potentially fail and it would be better if
    we export the GPIOs towards then end of the routine, so that we don't
    need to unexport them on error cases.
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Reviewed-by: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/arche-platform.c b/drivers/staging/greybus/arche-platform.c
index 259473cd506d..93d90b2dc866 100644
--- a/drivers/staging/greybus/arche-platform.c
+++ b/drivers/staging/greybus/arche-platform.c
@@ -154,13 +154,13 @@ static int arche_platform_probe(struct platform_device *pdev)
 	arche_pdata->num_apbs = of_get_child_count(np);
 	dev_dbg(dev, "Number of APB's available - %d\n", arche_pdata->num_apbs);
 
-	export_gpios(arche_pdata);
-
 	/* probe all childs here */
 	ret = of_platform_populate(np, NULL, NULL, dev);
 	if (ret)
 		dev_err(dev, "no child node found\n");
 
+	export_gpios(arche_pdata);
+
 	dev_info(dev, "Device registered successfully\n");
 	return ret;
 }

commit 73658f2a285dd8b53160355e619fcb59db3bb98a
Author: Viresh Kumar <viresh.kumar@linaro.org>
Date:   Mon Jan 11 11:29:03 2016 +0530

    greybus: arche-platform: arche_pdata is guaranteed to be valid
    
    arche_pdata is guaranteed to be valid in arche_platform_remove().
    
    Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
    Reviewed-by: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/arche-platform.c b/drivers/staging/greybus/arche-platform.c
index e6fe0156e128..259473cd506d 100644
--- a/drivers/staging/greybus/arche-platform.c
+++ b/drivers/staging/greybus/arche-platform.c
@@ -179,10 +179,7 @@ static int arche_platform_remove(struct platform_device *pdev)
 	struct arche_platform_drvdata *arche_pdata = platform_get_drvdata(pdev);
 
 	device_for_each_child(&pdev->dev, NULL, arche_remove_child);
-
-	if (arche_pdata)
-		arche_platform_cleanup(arche_pdata);
-
+	arche_platform_cleanup(arche_pdata);
 	platform_set_drvdata(pdev, NULL);
 	unexport_gpios(arche_pdata);
 

commit 6da86df3a4aa6dfbb9af350df4a908a7a9254be0
Author: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
Date:   Wed Jan 6 11:31:20 2016 +0530

    greybus: arche-platform: Export gpio (reset & sys_boot) to user
    
    In order to allow user to flash the firmware to,
    
    SVC:
    user need to assert the reset first, set sysboot pin and
    deassert reset. And then issue a flashing command.
    
    And APB:
    User need to assert the reset first, and then issue flashing
    command.
    
    So this patch exports the gpio's to user.
    
    Signed-off-by: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/arche-platform.c b/drivers/staging/greybus/arche-platform.c
index 50699520834f..e6fe0156e128 100644
--- a/drivers/staging/greybus/arche-platform.c
+++ b/drivers/staging/greybus/arche-platform.c
@@ -45,6 +45,19 @@ static inline void svc_reset_onoff(unsigned int gpio, bool onoff)
 	gpio_set_value(gpio, onoff);
 }
 
+/* Export gpio's to user space */
+static void export_gpios(struct arche_platform_drvdata *arche_pdata)
+{
+	gpio_export(arche_pdata->svc_reset_gpio, false);
+	gpio_export(arche_pdata->svc_sysboot_gpio, false);
+}
+
+static void unexport_gpios(struct arche_platform_drvdata *arche_pdata)
+{
+	gpio_unexport(arche_pdata->svc_reset_gpio);
+	gpio_unexport(arche_pdata->svc_sysboot_gpio);
+}
+
 static void arche_platform_cleanup(struct arche_platform_drvdata *arche_pdata)
 {
 	/* As part of exit, put APB back in reset state */
@@ -141,6 +154,8 @@ static int arche_platform_probe(struct platform_device *pdev)
 	arche_pdata->num_apbs = of_get_child_count(np);
 	dev_dbg(dev, "Number of APB's available - %d\n", arche_pdata->num_apbs);
 
+	export_gpios(arche_pdata);
+
 	/* probe all childs here */
 	ret = of_platform_populate(np, NULL, NULL, dev);
 	if (ret)
@@ -169,6 +184,7 @@ static int arche_platform_remove(struct platform_device *pdev)
 		arche_platform_cleanup(arche_pdata);
 
 	platform_set_drvdata(pdev, NULL);
+	unexport_gpios(arche_pdata);
 
 	return 0;
 }

commit 1e5dd1f8279a8a934b9df7adec47b944fe6b10f4
Author: Greg Kroah-Hartman <gregkh@google.com>
Date:   Wed Dec 30 13:38:33 2015 -0800

    greybus: arche-platform: merge arche-apb-ctrl and arche-platform
    
    No need to have two separate arche platform drivers, that's just crazy,
    so merge them both together to be only one kernel module.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>
    Reviewed-by: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
    Tested-by: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>

diff --git a/drivers/staging/greybus/arche-platform.c b/drivers/staging/greybus/arche-platform.c
index 697180d36acc..50699520834f 100644
--- a/drivers/staging/greybus/arche-platform.c
+++ b/drivers/staging/greybus/arche-platform.c
@@ -23,6 +23,7 @@
 #include <linux/spinlock.h>
 #include <linux/regulator/consumer.h>
 #include <linux/pinctrl/consumer.h>
+#include "arche_platform.h"
 
 struct arche_platform_drvdata {
 	/* Control GPIO signals to and from AP <=> SVC */
@@ -208,7 +209,18 @@ static struct of_device_id arche_platform_of_match[] = {
 	{ .compatible = "google,arche-platform", }, /* Use PID/VID of SVC device */
 	{ },
 };
-MODULE_DEVICE_TABLE(of, arche_platform_of_match);
+
+static struct of_device_id arche_apb_ctrl_of_match[] = {
+	{ .compatible = "usbffff,2", },
+	{ },
+};
+
+static struct of_device_id arche_combined_id[] = {
+	{ .compatible = "google,arche-platform", }, /* Use PID/VID of SVC device */
+	{ .compatible = "usbffff,2", },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, arche_combined_id);
 
 static struct platform_driver arche_platform_device_driver = {
 	.probe		= arche_platform_probe,
@@ -216,11 +228,42 @@ static struct platform_driver arche_platform_device_driver = {
 	.driver		= {
 		.name	= "arche-platform-ctrl",
 		.pm	= &arche_platform_pm_ops,
-		.of_match_table = of_match_ptr(arche_platform_of_match),
+		.of_match_table = arche_platform_of_match,
 	}
 };
 
-module_platform_driver(arche_platform_device_driver);
+static struct platform_driver arche_apb_ctrl_device_driver = {
+	.probe		= arche_apb_ctrl_probe,
+	.remove		= arche_apb_ctrl_remove,
+	.driver		= {
+		.name	= "arche-apb-ctrl",
+		.pm	= &arche_apb_ctrl_pm_ops,
+		.of_match_table = arche_apb_ctrl_of_match,
+	}
+};
+
+static int __init arche_init(void)
+{
+	int retval;
+
+	retval = platform_driver_register(&arche_platform_device_driver);
+	if (retval)
+		return retval;
+
+	retval = platform_driver_register(&arche_apb_ctrl_device_driver);
+	if (retval)
+		platform_driver_unregister(&arche_platform_device_driver);
+
+	return retval;
+}
+module_init(arche_init);
+
+static void __exit arche_exit(void)
+{
+	platform_driver_unregister(&arche_apb_ctrl_device_driver);
+	platform_driver_unregister(&arche_platform_device_driver);
+}
+module_exit(arche_exit);
 
 MODULE_LICENSE("GPL");
 MODULE_AUTHOR("Vaibhav Hiremath <vaibhav.hiremath@linaro.org>");

commit bc142bbb4ceba0891db6bf36cfb7be13c9a2dd72
Author: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
Date:   Mon Dec 28 20:06:32 2015 +0530

    greybus: arche_platform: Remove child's platform device as part of _remove() fn
    
    It seems we need to delete platform_dev of all childs explicitly,
    in _remove() fn callback of parent driver.
    There were some discussions about having of_platform_unpopulate(),
    but it never made it to mainline.
    
    https://lkml.org/lkml/2013/7/19/615
    
    There are some drivers which are removing platform_dev explicitly,
    as done in this patch.
    
    Note that, without this, multiple insmod-rmmod won't work, as I see
    driver probe gets invoked twice and leads to failure of probe.
    
    Signed-off-by: Vaibhav Hiremath <hiremath_vaibhav@projectara.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/arche-platform.c b/drivers/staging/greybus/arche-platform.c
index 7d90f5dee1d3..697180d36acc 100644
--- a/drivers/staging/greybus/arche-platform.c
+++ b/drivers/staging/greybus/arche-platform.c
@@ -149,10 +149,21 @@ static int arche_platform_probe(struct platform_device *pdev)
 	return ret;
 }
 
+static int arche_remove_child(struct device *dev, void *unused)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+
+	platform_device_unregister(pdev);
+
+	return 0;
+}
+
 static int arche_platform_remove(struct platform_device *pdev)
 {
 	struct arche_platform_drvdata *arche_pdata = platform_get_drvdata(pdev);
 
+	device_for_each_child(&pdev->dev, NULL, arche_remove_child);
+
 	if (arche_pdata)
 		arche_platform_cleanup(arche_pdata);
 

commit 7fa60654752bd4fbbe1e35e310a4bc96b6a3dec3
Author: Vaibhav Hiremath <hiremath_vaibhav@projectara.com>
Date:   Wed Dec 16 16:29:18 2015 +0530

    greybus: arche-platform: Rename db3-platform to arche-platform
    
    With multiple platforms getting rolled into ara,
    db3 name is confusing. And this driver is applicable
    to all arche platforms, so make sense to rename it to
    arche-platform.c. Also rename all internal functions
    accordingly.
    
    Signed-off-by: Vaibhav Hiremath <vaibhav.hiremath@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@google.com>

diff --git a/drivers/staging/greybus/arche-platform.c b/drivers/staging/greybus/arche-platform.c
new file mode 100644
index 000000000000..7d90f5dee1d3
--- /dev/null
+++ b/drivers/staging/greybus/arche-platform.c
@@ -0,0 +1,216 @@
+/*
+ * Arche Platform driver to enable Unipro link.
+ *
+ * Copyright 2014-2015 Google Inc.
+ * Copyright 2014-2015 Linaro Ltd.
+ *
+ * Released under the GPLv2 only.
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/sched.h>
+#include <linux/pm.h>
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+#include <linux/gpio.h>
+#include <linux/clk.h>
+#include <linux/of_platform.h>
+#include <linux/of_gpio.h>
+#include <linux/of_irq.h>
+#include <linux/spinlock.h>
+#include <linux/regulator/consumer.h>
+#include <linux/pinctrl/consumer.h>
+
+struct arche_platform_drvdata {
+	/* Control GPIO signals to and from AP <=> SVC */
+	int svc_reset_gpio;
+	bool is_reset_act_hi;
+	int svc_sysboot_gpio;
+
+	unsigned int svc_refclk_req;
+	struct clk *svc_ref_clk;
+
+	struct pinctrl *pinctrl;
+	struct pinctrl_state *pin_default;
+
+	int num_apbs;
+};
+
+static inline void svc_reset_onoff(unsigned int gpio, bool onoff)
+{
+	gpio_set_value(gpio, onoff);
+}
+
+static void arche_platform_cleanup(struct arche_platform_drvdata *arche_pdata)
+{
+	/* As part of exit, put APB back in reset state */
+	if (gpio_is_valid(arche_pdata->svc_reset_gpio))
+		svc_reset_onoff(arche_pdata->svc_reset_gpio,
+				arche_pdata->is_reset_act_hi);
+}
+
+static int arche_platform_probe(struct platform_device *pdev)
+{
+	struct arche_platform_drvdata *arche_pdata;
+	struct device *dev = &pdev->dev;
+	struct device_node *np = dev->of_node;
+	int ret;
+
+	arche_pdata = devm_kzalloc(&pdev->dev, sizeof(*arche_pdata), GFP_KERNEL);
+	if (!arche_pdata)
+		return -ENOMEM;
+
+	/* setup svc reset gpio */
+	arche_pdata->is_reset_act_hi = of_property_read_bool(np,
+					"svc,reset-active-high");
+	arche_pdata->svc_reset_gpio = of_get_named_gpio(np, "svc,reset-gpio", 0);
+	if (arche_pdata->svc_reset_gpio < 0) {
+		dev_err(dev, "failed to get reset-gpio\n");
+		return -ENODEV;
+	}
+	ret = devm_gpio_request(dev, arche_pdata->svc_reset_gpio, "svc-reset");
+	if (ret) {
+		dev_err(dev, "failed to request svc-reset gpio:%d\n", ret);
+		return ret;
+	}
+	ret = gpio_direction_output(arche_pdata->svc_reset_gpio,
+					arche_pdata->is_reset_act_hi);
+	if (ret) {
+		dev_err(dev, "failed to set svc-reset gpio dir:%d\n", ret);
+		return ret;
+	}
+
+	arche_pdata->svc_sysboot_gpio = of_get_named_gpio(np,
+					"svc,sysboot-gpio", 0);
+	if (arche_pdata->svc_sysboot_gpio < 0) {
+		dev_err(dev, "failed to get sysboot gpio\n");
+		return -ENODEV;
+	}
+	ret = devm_gpio_request(dev, arche_pdata->svc_sysboot_gpio, "sysboot0");
+	if (ret) {
+		dev_err(dev, "failed to request sysboot0 gpio:%d\n", ret);
+		return ret;
+	}
+	ret = gpio_direction_output(arche_pdata->svc_sysboot_gpio, 0);
+	if (ret) {
+		dev_err(dev, "failed to set svc-reset gpio dir:%d\n", ret);
+		return ret;
+	}
+
+	/* setup the clock request gpio first */
+	arche_pdata->svc_refclk_req = of_get_named_gpio(np,
+					"svc,refclk-req-gpio", 0);
+	if (arche_pdata->svc_refclk_req < 0) {
+		dev_err(dev, "failed to get svc clock-req gpio\n");
+		return -ENODEV;
+	}
+	ret = devm_gpio_request(dev, arche_pdata->svc_refclk_req, "svc-clk-req");
+	if (ret) {
+		dev_err(dev, "failed to request svc-clk-req gpio: %d\n", ret);
+		return ret;
+	}
+	ret = gpio_direction_input(arche_pdata->svc_refclk_req);
+	if (ret) {
+		dev_err(dev, "failed to set svc-clk-req gpio dir :%d\n", ret);
+		return ret;
+	}
+
+	/* setup refclk2 to follow the pin */
+	arche_pdata->svc_ref_clk = devm_clk_get(dev, "svc_ref_clk");
+	if (IS_ERR(arche_pdata->svc_ref_clk)) {
+		ret = PTR_ERR(arche_pdata->svc_ref_clk);
+		dev_err(dev, "failed to get svc_ref_clk: %d\n", ret);
+		return ret;
+	}
+	ret = clk_prepare_enable(arche_pdata->svc_ref_clk);
+	if (ret) {
+		dev_err(dev, "failed to enable svc_ref_clk: %d\n", ret);
+		return ret;
+	}
+
+	platform_set_drvdata(pdev, arche_pdata);
+
+	/* bring SVC out of reset */
+	svc_reset_onoff(arche_pdata->svc_reset_gpio,
+			!arche_pdata->is_reset_act_hi);
+
+	arche_pdata->num_apbs = of_get_child_count(np);
+	dev_dbg(dev, "Number of APB's available - %d\n", arche_pdata->num_apbs);
+
+	/* probe all childs here */
+	ret = of_platform_populate(np, NULL, NULL, dev);
+	if (ret)
+		dev_err(dev, "no child node found\n");
+
+	dev_info(dev, "Device registered successfully\n");
+	return ret;
+}
+
+static int arche_platform_remove(struct platform_device *pdev)
+{
+	struct arche_platform_drvdata *arche_pdata = platform_get_drvdata(pdev);
+
+	if (arche_pdata)
+		arche_platform_cleanup(arche_pdata);
+
+	platform_set_drvdata(pdev, NULL);
+
+	return 0;
+}
+
+static int arche_platform_suspend(struct device *dev)
+{
+	/*
+	 * If timing profile premits, we may shutdown bridge
+	 * completely
+	 *
+	 * TODO: sequence ??
+	 *
+	 * Also, need to make sure we meet precondition for unipro suspend
+	 * Precondition: Definition ???
+	 */
+	return 0;
+}
+
+static int arche_platform_resume(struct device *dev)
+{
+	/*
+	 * Atleast for ES2 we have to meet the delay requirement between
+	 * unipro switch and AP bridge init, depending on whether bridge is in
+	 * OFF state or standby state.
+	 *
+	 * Based on whether bridge is in standby or OFF state we may have to
+	 * assert multiple signals. Please refer to WDM spec, for more info.
+	 *
+	 */
+	return 0;
+}
+
+static SIMPLE_DEV_PM_OPS(arche_platform_pm_ops,
+			arche_platform_suspend,
+			arche_platform_resume);
+
+static struct of_device_id arche_platform_of_match[] = {
+	{ .compatible = "google,arche-platform", }, /* Use PID/VID of SVC device */
+	{ },
+};
+MODULE_DEVICE_TABLE(of, arche_platform_of_match);
+
+static struct platform_driver arche_platform_device_driver = {
+	.probe		= arche_platform_probe,
+	.remove		= arche_platform_remove,
+	.driver		= {
+		.name	= "arche-platform-ctrl",
+		.pm	= &arche_platform_pm_ops,
+		.of_match_table = of_match_ptr(arche_platform_of_match),
+	}
+};
+
+module_platform_driver(arche_platform_device_driver);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Vaibhav Hiremath <vaibhav.hiremath@linaro.org>");
+MODULE_DESCRIPTION("Arche Platform Driver");
