commit a7265633683c71e96fee5e5f21909c8e63932d1b
Author: Wentao Cai <etsai042@gmail.com>
Date:   Wed Mar 20 00:09:01 2019 -0700

    Staging: unisys: Correct malformed SPDX-License-Identifier
    
    Correct SPDX-License-Identifier comment characters to silence
    checkpatch.pl warning:
    WARNING: Missing or malformed SPDX-License-Identifier tag in line 1
    
    Signed-off-by: Wentao Cai <etsai042@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/unisys/include/iochannel.h b/drivers/staging/unisys/include/iochannel.h
index 45c785d80ce4..9ef812c0bc42 100644
--- a/drivers/staging/unisys/include/iochannel.h
+++ b/drivers/staging/unisys/include/iochannel.h
@@ -1,4 +1,4 @@
-// SPDX-License-Identifier: GPL-2.0+
+/* SPDX-License-Identifier: GPL-2.0+ */
 /*
  * Copyright (C) 2010 - 2016 UNISYS CORPORATION
  * All rights reserved.

commit 93d3ad90c2d470804b16f79e7e872408747d3e77
Author: David Kershner <david.kershner@unisys.com>
Date:   Thu Dec 7 12:11:07 2017 -0500

    drivers: visorbus: move driver out of staging
    
    Move the visorbus driver out of staging (drivers/staging/unisys/visorbus)
    and to drivers/visorbus. Modify the configuration and makefiles so they
    now reference the new location. The s-Par header file visorbus.h that is
    referenced by all s-Par drivers, is being moved into include/linux.
    
    Signed-off-by: David Kershner <david.kershner@unisys.com>
    Reviewed-by: Tim Sell <timothy.sell@unisys.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/unisys/include/iochannel.h b/drivers/staging/unisys/include/iochannel.h
index 9023cf56625d..45c785d80ce4 100644
--- a/drivers/staging/unisys/include/iochannel.h
+++ b/drivers/staging/unisys/include/iochannel.h
@@ -33,8 +33,7 @@
 
 #include <linux/uuid.h>
 #include <linux/skbuff.h>
-
-#include "visorbus.h"
+#include <linux/visorbus.h>
 
 /*
  * Must increment these whenever you insert or delete fields within this channel

commit f09177adbe3e72dff2965a066eda1d243301727b
Author: David Kershner <david.kershner@unisys.com>
Date:   Wed Dec 6 11:05:27 2017 -0500

    staging: unisys: combine visorchannel.h and visorbus.h
    
    Combine the include files visorchannel.h and visorbus.h so that only one
    include file is needed for the .c files.
    
    Reported-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: David Kershner <david.kershner@unisys.com>
    Reviewed-by: Tim Sell <timothy.sell@unisys.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/unisys/include/iochannel.h b/drivers/staging/unisys/include/iochannel.h
index a3c87544bf96..9023cf56625d 100644
--- a/drivers/staging/unisys/include/iochannel.h
+++ b/drivers/staging/unisys/include/iochannel.h
@@ -34,7 +34,7 @@
 #include <linux/uuid.h>
 #include <linux/skbuff.h>
 
-#include "visorchannel.h"
+#include "visorbus.h"
 
 /*
  * Must increment these whenever you insert or delete fields within this channel

commit 2baffb7205e0f4da158cabcf1116e4422af188a6
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Nov 7 14:58:49 2017 +0100

    staging: unisys: Remove redundant license text
    
    Now that the SPDX tag is in all unisys driver files, that identifies the
    license in a specific and legally-defined manner.  So the extra GPL text
    wording can be removed as it is no longer needed at all.
    
    This is done on a quest to remove the 700+ different ways that files in
    the kernel describe the GPL license text.  And there's unneeded stuff
    like the address (sometimes incorrect) for the FSF which is never
    needed.
    
    No copyright headers or other non-license-description text was removed.
    
    Cc: David Kershner <david.kershner@unisys.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/unisys/include/iochannel.h b/drivers/staging/unisys/include/iochannel.h
index 6fc40f9cc768..a3c87544bf96 100644
--- a/drivers/staging/unisys/include/iochannel.h
+++ b/drivers/staging/unisys/include/iochannel.h
@@ -2,17 +2,6 @@
 /*
  * Copyright (C) 2010 - 2016 UNISYS CORPORATION
  * All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or (at
- * your option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, GOOD TITLE or
- * NON INFRINGEMENT.  See the GNU General Public License for more
- * details.
  */
 
 #ifndef __IOCHANNEL_H__

commit 184e7e4a1166db0bd66267ae82c1557c4976ccd9
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Nov 7 14:58:48 2017 +0100

    staging: unisys: fix up some SPDX tags
    
    One .h file was missing a SPDX tag, and another one was wrong after
    looking at the text of the license itself, so fix both of these issues
    up at the same time.
    
    Cc: David Kershner <david.kershner@unisys.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: Philippe Ombredanne <pombredanne@nexb.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/unisys/include/iochannel.h b/drivers/staging/unisys/include/iochannel.h
index bac5a04a9c28..6fc40f9cc768 100644
--- a/drivers/staging/unisys/include/iochannel.h
+++ b/drivers/staging/unisys/include/iochannel.h
@@ -1,4 +1,4 @@
-// SPDX-License-Identifier: GPL-2.0
+// SPDX-License-Identifier: GPL-2.0+
 /*
  * Copyright (C) 2010 - 2016 UNISYS CORPORATION
  * All rights reserved.

commit b79c0f4f5cc15cdf2b84b3431fa36c65b92260cc
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Nov 7 14:58:47 2017 +0100

    staging: unisys: add SPDX identifiers to all unisys driver files
    
    It's good to have SPDX identifiers in all files to make it easier to
    audit the kernel tree for correct licenses.
    
    Update the drivers/staging/unisys files files with the correct SPDX
    license identifier based on the license text in the file itself.  The
    SPDX identifier is a legally binding shorthand, which can be used
    instead of the full boiler plate text.
    
    This work is based on a script and data from Thomas Gleixner, Philippe
    Ombredanne, and Kate Stewart.
    
    Cc: David Kershner <david.kershner@unisys.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: Philippe Ombredanne <pombredanne@nexb.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/unisys/include/iochannel.h b/drivers/staging/unisys/include/iochannel.h
index 5cd407ca2251..bac5a04a9c28 100644
--- a/drivers/staging/unisys/include/iochannel.h
+++ b/drivers/staging/unisys/include/iochannel.h
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * Copyright (C) 2010 - 2016 UNISYS CORPORATION
  * All rights reserved.

commit e8ffed837f6ddc7055d06c69e3ef78b53d39a6f2
Author: David Binder <david.binder@unisys.com>
Date:   Wed Sep 27 13:14:40 2017 -0400

    staging: unisys: include: Rename channel.h to visorchannel.h
    
    In order to avoid a potential conflict with other drivers that define a
    channel.h file, the s-Par channel.h file is renamed in accordance with the
    surrounding driver-set namespace.
    
    Signed-off-by: David Binder <david.binder@unisys.com>
    Signed-off-by: David Kershner <david.kershner@unisys.com>
    Reviewed-by: Tim Sell <timothy.sell@unisys.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/unisys/include/iochannel.h b/drivers/staging/unisys/include/iochannel.h
index 69dd9c3391aa..5cd407ca2251 100644
--- a/drivers/staging/unisys/include/iochannel.h
+++ b/drivers/staging/unisys/include/iochannel.h
@@ -44,7 +44,7 @@
 #include <linux/uuid.h>
 #include <linux/skbuff.h>
 
-#include "channel.h"
+#include "visorchannel.h"
 
 /*
  * Must increment these whenever you insert or delete fields within this channel

commit b11dffc48186d0bd5617f0428b832a580a7930c9
Author: David Kershner <david.kershner@unisys.com>
Date:   Wed Sep 27 13:14:34 2017 -0400

    staging: unisys: include: consolidate a comment
    
    Use all 80 characters of the line to consolidate a comment.
    
    Signed-off-by: David Kershner <david.kershner@unisys.com>
    Reviewed-by: Tim Sell <timothy.sell@unisys.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/unisys/include/iochannel.h b/drivers/staging/unisys/include/iochannel.h
index a70760f48566..69dd9c3391aa 100644
--- a/drivers/staging/unisys/include/iochannel.h
+++ b/drivers/staging/unisys/include/iochannel.h
@@ -348,10 +348,9 @@ struct sense_data {
  *		    the start of the NETWORK LAYER HEADER.
  *
  * NOTE:
- * The full packet is described in frags but the ethernet header is
- * separately kept in ethhdr so that uisnic doesn't have "MAP" the
- * guest memory to get to the header. uisnic needs ethhdr to
- * determine how to route the packet.
+ * The full packet is described in frags but the ethernet header is separately
+ * kept in ethhdr so that uisnic doesn't have "MAP" the guest memory to get to
+ * the header. uisnic needs ethhdr to determine how to route the packet.
  */
 struct net_pkt_xmt {
 	int len;

commit 7126395e607ca122aed1f2bcced3075756bb1a54
Author: David Kershner <david.kershner@unisys.com>
Date:   Wed Aug 30 13:36:08 2017 -0400

    staging: unisys: use the kernel min define
    
    The kernel already provides a min function, we should be using that
    instead of creating our own MINNUM.
    
    Reviewed-by: Sameer Wadgaonkar <sameer.wadgaonkar@unisys.com>
    Signed-off-by: David Kershner <david.kershner@unisys.com>
    Reviewed-by: Tim Sell <timothy.sell@unisys.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/unisys/include/iochannel.h b/drivers/staging/unisys/include/iochannel.h
index 956294734f25..a70760f48566 100644
--- a/drivers/staging/unisys/include/iochannel.h
+++ b/drivers/staging/unisys/include/iochannel.h
@@ -61,9 +61,6 @@
  * IO Partition is defined below.
  */
 
-/* Defines and enums. */
-#define MINNUM(a, b) (((a) < (b)) ? (a) : (b))
-
 /*
  * Define the two queues per data channel between iopart and ioguestparts.
  *	IOCHAN_TO_IOPART -- used by guest to 'insert' signals to iopart.

commit 17d3208c3fda752a4e15ba3549d7a1d88f47b0b2
Author: David Binder <david.binder@unisys.com>
Date:   Tue Aug 22 13:27:32 2017 -0400

    staging: unisys: include: iochannel.h: Add proper copyright statement
    
    Adds the proper Unisys copyright statement to the top of iochannel.h.
    
    Signed-off-by: David Binder <david.binder@unisys.com>
    Signed-off-by: David Kershner <david.kershner@unisys.com>
    Reviewed-by: Tim Sell <timothy.sell@unisys.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/unisys/include/iochannel.h b/drivers/staging/unisys/include/iochannel.h
index 8a8d4c12d90c..956294734f25 100644
--- a/drivers/staging/unisys/include/iochannel.h
+++ b/drivers/staging/unisys/include/iochannel.h
@@ -1,5 +1,19 @@
-/* Copyright (C) 2010 - 2016 UNISYS CORPORATION */
-/* All rights reserved. */
+/*
+ * Copyright (C) 2010 - 2016 UNISYS CORPORATION
+ * All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or (at
+ * your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, GOOD TITLE or
+ * NON INFRINGEMENT.  See the GNU General Public License for more
+ * details.
+ */
+
 #ifndef __IOCHANNEL_H__
 #define __IOCHANNEL_H__
 

commit df47f0ae9878567bdd33e36f424e3dde0aa88464
Author: David Kershner <david.kershner@unisys.com>
Date:   Tue Aug 22 13:27:07 2017 -0400

    staging: unisys: include: iochannel.h: Update comments for #defines
    
    Cleaned up some #defines to make the beginning of the file read easier.
    
    Reviewed-by: Sameer Wadgaonkar <sameer.wadgaonkar@unisys.com>
    Signed-off-by: David Kershner <david.kershner@unisys.com>
    Reviewed-by: Tim Sell <timothy.sell@unisys.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/unisys/include/iochannel.h b/drivers/staging/unisys/include/iochannel.h
index a77d5ab8dbe5..8a8d4c12d90c 100644
--- a/drivers/staging/unisys/include/iochannel.h
+++ b/drivers/staging/unisys/include/iochannel.h
@@ -50,12 +50,12 @@
 /* Defines and enums. */
 #define MINNUM(a, b) (((a) < (b)) ? (a) : (b))
 
-/* Define the two queues per data channel between iopart and ioguestparts. */
-
-/* Used by ioguestpart to 'insert' signals to iopart. */
+/*
+ * Define the two queues per data channel between iopart and ioguestparts.
+ *	IOCHAN_TO_IOPART -- used by guest to 'insert' signals to iopart.
+ *	IOCHAN_FROM_IOPART -- used by guest to 'remove' signals from IO part.
+ */
 #define IOCHAN_TO_IOPART 0
-
-/* Used by ioguestpart to 'remove' signals from iopart, same previous queue. */
 #define IOCHAN_FROM_IOPART 1
 
 /* Size of cdb - i.e., SCSI cmnd */

commit 264f19b30b29bb99a655d99dfc0dc310f050cff8
Author: David Kershner <david.kershner@unisys.com>
Date:   Tue Aug 22 13:27:16 2017 -0400

    staging: unisys: include: iochannel needs to include skbuff
    
    The iochannel.h header file references ETH_HLEN which is defined in
    skbuff. Removed it from visorhba since it was no longer needed.
    
    Reviewed-by: Sameer Wadgaonkar <sameer.wadgaonkar@unisys.com>
    Signed-off-by: David Kershner <david.kershner@unisys.com>
    Reviewed-by: Tim Sell <timothy.sell@unisys.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/unisys/include/iochannel.h b/drivers/staging/unisys/include/iochannel.h
index 065e07e36979..a77d5ab8dbe5 100644
--- a/drivers/staging/unisys/include/iochannel.h
+++ b/drivers/staging/unisys/include/iochannel.h
@@ -28,6 +28,7 @@
  */
 
 #include <linux/uuid.h>
+#include <linux/skbuff.h>
 
 #include "channel.h"
 

commit a941c5b76adb55b741f8f7a744e642322c3ec212
Author: David Kershner <david.kershner@unisys.com>
Date:   Tue Aug 22 13:27:08 2017 -0400

    staging: unisys: include: Remove unused vdiskmgmt commands
    
    The vdisk task management commands are no longer used by s-Par, this
    patch removes the definitions for them.
    
    Reviewed-by: Sameer Wadgaonkar <sameer.wadgaonkar@unisys.com>
    Signed-off-by: David Kershner <david.kershner@unisys.com>
    Reviewed-by: Tim Sell <timothy.sell@unisys.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/unisys/include/iochannel.h b/drivers/staging/unisys/include/iochannel.h
index ca9d6f9718ea..065e07e36979 100644
--- a/drivers/staging/unisys/include/iochannel.h
+++ b/drivers/staging/unisys/include/iochannel.h
@@ -498,36 +498,6 @@ struct uiscmdrsp_disknotify {
 	u32 channel, id, lun;
 } __packed;
 
-/*
- * struct uiscmdrsp_vdiskmgmt - The following is used by virthba/vSCSI to send
- *				the Acquire/Release commands to the IOVM.
- * @enum vdisktype:	 The type of task.
- * @struct vdest:	 The vdisk for which this task mgmt is generated.
- * @handle:		 This is a handle that the guest has saved off for its
- *			 own use. It's value is preserved by iopart and returned
- *			 as in the task mgmt rsp.
- * @notify_handle:	 For Linux guests, this is a pointer to wait_queue_head
- *			 that a thread is waiting on to see if the tskmgmt
- *			 command has completed. When the rsp is received by
- *			 guest, the thread receiving the response uses this to
- *			 notify the thread waiting for taskmgmt command
- *			 completion. It's value is preserved by iopart and
- *			 returned as in the task mgmt rsp.
- * @notifyresult_handle: Handle to the location in guest where the result of the
- *			 taskmgmt command (result field) is saved to when the
- *			 response is handled. It's value is preserved by iopart
- *			 and returned as in the task mgmt rsp.
- * @result: Result of taskmgmt command - set by IOPart.
- */
-struct uiscmdrsp_vdiskmgmt {
-	enum vdisk_mgmt_types vdisktype;
-	struct uisscsi_dest vdest;
-	u64 handle;
-	u64 notify_handle;
-	u64 notifyresult_handle;
-	char result;
-} __packed;
-
 /* Keeping cmd and rsp info in one structure for now cmd rsp packet for SCSI */
 struct uiscmdrsp {
 	char cmdtype;
@@ -536,13 +506,11 @@ struct uiscmdrsp {
 #define CMD_NET_TYPE	      2
 #define CMD_SCSITASKMGMT_TYPE 3
 #define CMD_NOTIFYGUEST_TYPE  4
-#define CMD_VDISKMGMT_TYPE    5
 	union {
 		struct uiscmdrsp_scsi scsi;
 		struct uiscmdrsp_net net;
 		struct uiscmdrsp_scsitaskmgmt scsitaskmgmt;
 		struct uiscmdrsp_disknotify disknotify;
-		struct uiscmdrsp_vdiskmgmt vdiskmgmt;
 	};
 	/* Send the response when the cmd is done (scsi and scsittaskmgmt). */
 	void *private_data;

commit d4999465c9170cec76f0b6d571480c48df3900dd
Author: David Kershner <david.kershner@unisys.com>
Date:   Tue Aug 22 13:27:05 2017 -0400

    staging: unisys: include: Remove unused #define MAXNUM
    
    The MAXNUM #define was not being used, and it shouldn't be used.
    Remove it.
    
    Reviewed-by: Sameer Wadgaonkar <sameer.wadgaonkar@unisys.com>
    Signed-off-by: David Kershner <david.kershner@unisys.com>
    Reviewed-by: Tim Sell <timothy.sell@unisys.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/unisys/include/iochannel.h b/drivers/staging/unisys/include/iochannel.h
index 53259d611bd3..ca9d6f9718ea 100644
--- a/drivers/staging/unisys/include/iochannel.h
+++ b/drivers/staging/unisys/include/iochannel.h
@@ -48,7 +48,6 @@
 
 /* Defines and enums. */
 #define MINNUM(a, b) (((a) < (b)) ? (a) : (b))
-#define MAXNUM(a, b) (((a) > (b)) ? (a) : (b))
 
 /* Define the two queues per data channel between iopart and ioguestparts. */
 

commit 55515a30d2e583908145817df2fdf31fa04b4401
Author: Steven Matthews <steven.matthews@unisys.com>
Date:   Tue Aug 22 13:27:02 2017 -0400

    staging: unisys: include: fix improper use of dma_data_direction
    
    Replace use of standard Linux dma_data_direction with a Unisys-
    specific uis_dma_data_direction and provide a function to convert
    from the latter to the former.  This is necessary because Unisys
    s-Par depends on the exact format of this field in multiple OSs
    and languages, and so using the standard version creates an
    unnecessary dependency between the kernel and s-Par.
    
    Signed-off-by: Steven Matthews <steven.matthews@unisys.com>
    Signed-off-by: David Kershner <david.kershner@unisys.com>
    Reviewed-by: Tim Sell <timothy.sell@unisys.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/unisys/include/iochannel.h b/drivers/staging/unisys/include/iochannel.h
index d2ef70549fab..53259d611bd3 100644
--- a/drivers/staging/unisys/include/iochannel.h
+++ b/drivers/staging/unisys/include/iochannel.h
@@ -28,7 +28,7 @@
  */
 
 #include <linux/uuid.h>
-#include <linux/dma-direction.h>
+
 #include "channel.h"
 
 /*
@@ -60,6 +60,15 @@
 
 /* Size of cdb - i.e., SCSI cmnd */
 #define MAX_CMND_SIZE 16
+
+/* Unisys-specific DMA direction values */
+enum uis_dma_data_direction {
+	UIS_DMA_BIDIRECTIONAL = 0,
+	UIS_DMA_TO_DEVICE = 1,
+	UIS_DMA_FROM_DEVICE = 2,
+	UIS_DMA_NONE = 3
+};
+
 #define MAX_SENSE_SIZE 64
 #define MAX_PHYS_INFO 64
 
@@ -182,7 +191,7 @@ struct vhba_config_max {
  * @bufflen:		Length of data to be transferred out or in.
  * @guest_phys_entries:	Number of entries in scatter-gather list.
  * @struct gpi_list:	Physical address information for each fragment.
- * @enum data_dir:	Direction of the data, if any.
+ * @data_dir:		Direction of the data, if any.
  * @struct vdest:	Identifies the virtual hba, id, channel, lun to which
  *			cmd was sent.
  * @linuxstat:		Original Linux status used by Linux vdisk.
@@ -205,7 +214,7 @@ struct uiscmdrsp_scsi {
 	u32 bufflen;
 	u16 guest_phys_entries;
 	struct guest_phys_info gpi_list[MAX_PHYS_INFO];
-	enum dma_data_direction data_dir;
+	u32 data_dir;
 	struct uisscsi_dest vdest;
 	/* Needed to queue the rsp back to cmd originator. */
 	int linuxstat;

commit b32c5cb84fd0c4539227b5973d378111e35bd9c5
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Tue Aug 22 13:26:54 2017 -0400

    staging: unisys: Switch to use new generic UUID API
    
    There are new types and helpers that are supposed to be used in new code.
    
    As a preparation to get rid of legacy types and API functions do
    the conversion here.
    
    While here, re-indent couple of lines to increase readability.
    
    Cc: David Kershner <david.kershner@unisys.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: sparmaintainer@unisys.com
    Cc: devel@driverdev.osuosl.org
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: David Kershner <david.kershner@unisys.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/unisys/include/iochannel.h b/drivers/staging/unisys/include/iochannel.h
index 40eb7d559bf7..d2ef70549fab 100644
--- a/drivers/staging/unisys/include/iochannel.h
+++ b/drivers/staging/unisys/include/iochannel.h
@@ -562,7 +562,7 @@ struct iochannel_vnic {
 	/* 4 bytes */
 	u32 mtu;
 	/* 16 bytes */
-	uuid_le zone_uuid;
+	guid_t zone_guid;
 } __packed;
 
 /*

commit 30f82e1ce55bbcf5037853397ba61e2161035a57
Author: Zohaib Javed <zohaib.javed@gmail.com>
Date:   Tue Aug 22 13:26:52 2017 -0400

    staging: unisys: include: iochannel.h: Removed unused DEFINE
    
    Removed unused #define GPI_ENTRIES_PER_PAGE
    
    Signed-off-by: Zohaib Javed <zohaib.javed@gmail.com>
    Signed-off-by: David Kershner <david.kershner@unisys.com>
    Reviewed-by: David Binder <david.binder@unisys.com>
    Reviewed-by: Tim Sell <timothy.sell@unisys.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/unisys/include/iochannel.h b/drivers/staging/unisys/include/iochannel.h
index 80b9ef3ceb0c..40eb7d559bf7 100644
--- a/drivers/staging/unisys/include/iochannel.h
+++ b/drivers/staging/unisys/include/iochannel.h
@@ -133,8 +133,6 @@ struct guest_phys_info {
 	u64 length;
 } __packed;
 
-#define GPI_ENTRIES_PER_PAGE (PAGE_SIZE / sizeof(struct guest_phys_info))
-
 /*
  * struct uisscsi_dest
  * @channel: Bus number.

commit 7cfcd381252308e222af718421405595b1741a2c
Author: Charles Daniels <cdaniels@fastmail.com>
Date:   Mon Jul 17 16:17:16 2017 -0400

    staging: unisys: include: Remove COVER macro from channel.h
    
    Replaced the one and only call to COVER in iochannel.h.
    
    Signed-off-by: Charles Daniels <cdaniels@fastmail.com>
    Signed-off-by: David Kershner <david.kershner@unisys.com>
    Reviewed-by: David Binder <david.binder@unisys.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/unisys/include/iochannel.h b/drivers/staging/unisys/include/iochannel.h
index 425edb6ca43e..80b9ef3ceb0c 100644
--- a/drivers/staging/unisys/include/iochannel.h
+++ b/drivers/staging/unisys/include/iochannel.h
@@ -587,7 +587,7 @@ struct visor_io_channel {
 } __packed;
 
 /* INLINE functions for initializing and accessing I/O data channels. */
-#define SIZEOF_CMDRSP (COVER(sizeof(struct uiscmdrsp), 64))
+#define SIZEOF_CMDRSP (64 * DIV_ROUND_UP(sizeof(struct uiscmdrsp), 64))
 
 /* Use 4K page sizes when passing page info between Guest and IOPartition. */
 #define PI_PAGE_SIZE 0x1000

commit 790627cdde51bb94aa33a8f480c89946bc336528
Author: Sameer Wadgaonkar <sameer.wadgaonkar@unisys.com>
Date:   Mon Jul 17 16:17:01 2017 -0400

    staging: unisys: include: Remove unused CHANNEL_OK defines.
    
    The VISOR_VNIC_CHANNEL_OK_CLIENT and VISOR_HBA_CHANNEL_OK_CLIENT macros
    were not being used. They can be removed.
    
    Signed-off-by: Sameer Wadgaonkar <sameer.wadgaonkar@unisys.com>
    Signed-off-by: David Kershner <david.kershner@unisys.com>
    Reviewed-by: David Binder <david.binder@unisys.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/unisys/include/iochannel.h b/drivers/staging/unisys/include/iochannel.h
index 1a3d82da5769..425edb6ca43e 100644
--- a/drivers/staging/unisys/include/iochannel.h
+++ b/drivers/staging/unisys/include/iochannel.h
@@ -41,18 +41,6 @@
 #define VISOR_VHBA_CHANNEL_VERSIONID 2
 #define VISOR_VNIC_CHANNEL_VERSIONID 2
 
-#define VISOR_VHBA_CHANNEL_OK_CLIENT(ch) \
-	(visor_check_channel(ch, visor_vhba_channel_uuid, \
-			     "vhba", MIN_IO_CHANNEL_SIZE, \
-			     VISOR_VHBA_CHANNEL_VERSIONID, \
-			     VISOR_CHANNEL_SIGNATURE))
-
-#define VISOR_VNIC_CHANNEL_OK_CLIENT(ch) \
-	(visor_check_channel(ch, visor_vnic_channel_uuid, \
-			     "vnic", MIN_IO_CHANNEL_SIZE, \
-			     VISOR_VNIC_CHANNEL_VERSIONID, \
-			     VISOR_CHANNEL_SIGNATURE))
-
 /*
  * Everything necessary to handle SCSI & NIC traffic between Guest Partition and
  * IO Partition is defined below.

commit 0f6b44ad89090960e823deb710f9f2422e43f51c
Author: Sameer Wadgaonkar <sameer.wadgaonkar@unisys.com>
Date:   Mon Jul 17 16:17:00 2017 -0400

    staging: unisys: remove unused define VISOR_VSWITCH_CHANNEL_VERSIONID
    
    The VSWITCH channel is not used in Linux guests, so remove the VERSIONID.
    
    Signed-off-by: Sameer Wadgaonkar <sameer.wadgaonkar@unisys.com>
    Signed-off-by: David Kershner <david.kershner@unisys.com>
    Reviewed-by: David Binder <david.binder@unisys.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/unisys/include/iochannel.h b/drivers/staging/unisys/include/iochannel.h
index c39451beb754..1a3d82da5769 100644
--- a/drivers/staging/unisys/include/iochannel.h
+++ b/drivers/staging/unisys/include/iochannel.h
@@ -40,7 +40,6 @@
  */
 #define VISOR_VHBA_CHANNEL_VERSIONID 2
 #define VISOR_VNIC_CHANNEL_VERSIONID 2
-#define VISOR_VSWITCH_CHANNEL_VERSIONID 1
 
 #define VISOR_VHBA_CHANNEL_OK_CLIENT(ch) \
 	(visor_check_channel(ch, visor_vhba_channel_uuid, \

commit 0330a357fffd6cbb87672fa4052f2ec9a55b0050
Author: Alex Curtin <alexander.curtin@unisys.com>
Date:   Mon Jul 17 16:16:54 2017 -0400

    staging: unisys: include: iochannel.h: removed VISOR_VSWITCH_CHANNEL_SIGNATURE
    
    VISOR_VSWITCH_CHANNEL_SIGNATURE is a redundant definition that points to
    VISOR_CHANNEL_SIGNATURE. It wasn't being used, so it has been removed.
    
    Signed-off-by: Alex Curtin <alexander.curtin@unisys.com>
    Signed-off-by: David Kershner <david.kershner@unisys.com>
    Reviewed-by: David Binder <david.binder@unisys.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/unisys/include/iochannel.h b/drivers/staging/unisys/include/iochannel.h
index 8a8676284353..c39451beb754 100644
--- a/drivers/staging/unisys/include/iochannel.h
+++ b/drivers/staging/unisys/include/iochannel.h
@@ -31,8 +31,6 @@
 #include <linux/dma-direction.h>
 #include "channel.h"
 
-#define VISOR_VSWITCH_CHANNEL_SIGNATURE VISOR_CHANNEL_SIGNATURE
-
 /*
  * Must increment these whenever you insert or delete fields within this channel
  * struct. Also increment whenever you change the meaning of fields within this

commit b4459db6337e2ac2904b3be7546aa9192eb8bd29
Author: Alex Curtin <alexander.curtin@unisys.com>
Date:   Mon Jul 17 16:16:53 2017 -0400

    staging: unisys: include: iochannel.h: removed VISOR_VNIC_CHANNEL_SIGNATURE
    
    VISOR_VNIC_CHANNEL_SIGNATURE is a redundant definition that points to
    VISOR_CHANNEL_SIGNATURE. This replaces that definition with
    VISOR_CHANNEL_SIGNATURE.
    
    Signed-off-by: Alex Curtin <alexander.curtin@unisys.com>
    Signed-off-by: David Kershner <david.kershner@unisys.com>
    Reviewed-by: David Binder <david.binder@unisys.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/unisys/include/iochannel.h b/drivers/staging/unisys/include/iochannel.h
index 797db9f1d384..8a8676284353 100644
--- a/drivers/staging/unisys/include/iochannel.h
+++ b/drivers/staging/unisys/include/iochannel.h
@@ -31,7 +31,6 @@
 #include <linux/dma-direction.h>
 #include "channel.h"
 
-#define VISOR_VNIC_CHANNEL_SIGNATURE VISOR_CHANNEL_SIGNATURE
 #define VISOR_VSWITCH_CHANNEL_SIGNATURE VISOR_CHANNEL_SIGNATURE
 
 /*
@@ -55,7 +54,7 @@
 	(visor_check_channel(ch, visor_vnic_channel_uuid, \
 			     "vnic", MIN_IO_CHANNEL_SIZE, \
 			     VISOR_VNIC_CHANNEL_VERSIONID, \
-			     VISOR_VNIC_CHANNEL_SIGNATURE))
+			     VISOR_CHANNEL_SIGNATURE))
 
 /*
  * Everything necessary to handle SCSI & NIC traffic between Guest Partition and

commit c1e1c4d1011d003546fef13a65bae16b4d50e279
Author: Alex Curtin <alexander.curtin@unisys.com>
Date:   Mon Jul 17 16:16:52 2017 -0400

    staging: unisys: include: iochannel.h: removed VISOR_VHBA_CHANNEL_SIGNATURE
    
    VISOR_VHBA_CHANNEL_SIGNATURE is a redundant definition that points to
    VISOR_CHANNEL_SIGNATURE. This replaces that definition with
    VISOR_CHANNEL_SIGNATURE.
    
    Signed-off-by: Alex Curtin <alexander.curtin@unisys.com>
    Signed-off-by: David Kershner <david.kershner@unisys.com>
    Reviewed-by: David Binder <david.binder@unisys.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/unisys/include/iochannel.h b/drivers/staging/unisys/include/iochannel.h
index 12849bbc4525..797db9f1d384 100644
--- a/drivers/staging/unisys/include/iochannel.h
+++ b/drivers/staging/unisys/include/iochannel.h
@@ -31,7 +31,6 @@
 #include <linux/dma-direction.h>
 #include "channel.h"
 
-#define VISOR_VHBA_CHANNEL_SIGNATURE VISOR_CHANNEL_SIGNATURE
 #define VISOR_VNIC_CHANNEL_SIGNATURE VISOR_CHANNEL_SIGNATURE
 #define VISOR_VSWITCH_CHANNEL_SIGNATURE VISOR_CHANNEL_SIGNATURE
 
@@ -50,7 +49,7 @@
 	(visor_check_channel(ch, visor_vhba_channel_uuid, \
 			     "vhba", MIN_IO_CHANNEL_SIZE, \
 			     VISOR_VHBA_CHANNEL_VERSIONID, \
-			     VISOR_VHBA_CHANNEL_SIGNATURE))
+			     VISOR_CHANNEL_SIGNATURE))
 
 #define VISOR_VNIC_CHANNEL_OK_CLIENT(ch) \
 	(visor_check_channel(ch, visor_vnic_channel_uuid, \

commit 2d15800d4b8e115047e059bb6e546aa3559f75c1
Author: David Binder <david.binder@unisys.com>
Date:   Fri Jun 30 15:43:20 2017 -0400

    staging: unisys: include: iochannel.h: Adjust whitespace usage
    
    Adjusts spacing and removes unnecessary blank lines to create a more
    uniform coding style.
    
    Signed-off-by: David Binder <david.binder@unisys.com>
    Signed-off-by: David Kershner <david.kershner@unisys.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/unisys/include/iochannel.h b/drivers/staging/unisys/include/iochannel.h
index 5212c191df25..12849bbc4525 100644
--- a/drivers/staging/unisys/include/iochannel.h
+++ b/drivers/staging/unisys/include/iochannel.h
@@ -7,9 +7,7 @@
  * Everything needed for IOPart-GuestPart communication is define in
  * this file. Note: Everything is OS-independent because this file is
  * used by Windows, Linux and possible EFI drivers.
- */
-
-/*
+ *
  * Communication flow between the IOPart and GuestPart uses the channel headers
  * channel state. The following states are currently being used:
  *       UNINIT(All Zeroes), CHANNEL_ATTACHING, CHANNEL_ATTACHED, CHANNEL_OPENED
@@ -30,7 +28,6 @@
  */
 
 #include <linux/uuid.h>
-
 #include <linux/dma-direction.h>
 #include "channel.h"
 
@@ -80,9 +77,7 @@
 
 /* Size of cdb - i.e., SCSI cmnd */
 #define MAX_CMND_SIZE 16
-
 #define MAX_SENSE_SIZE 64
-
 #define MAX_PHYS_INFO 64
 
 /*
@@ -245,9 +240,7 @@ struct uiscmdrsp_scsi {
 /*
  * Defines to support sending correct inquiry result when no disk is
  * configured.
- */
-
-/*
+ *
  * From SCSI SPC2 -
  *
  * If the target is not capable of supporting a device on this logical unit, the

commit 946726ef0a6b68cb087c1259e890bd0c18e39397
Author: David Binder <david.binder@unisys.com>
Date:   Fri Jun 30 15:43:15 2017 -0400

    staging: unisys: include: Fix spelling mistake
    
    Fixes minor spelling mistake: stired -> stored.
    
    Signed-off-by: David Binder <david.binder@unisys.com>
    Signed-off-by: David Kershner <david.kershner@unisys.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/unisys/include/iochannel.h b/drivers/staging/unisys/include/iochannel.h
index d79261047c30..5212c191df25 100644
--- a/drivers/staging/unisys/include/iochannel.h
+++ b/drivers/staging/unisys/include/iochannel.h
@@ -184,7 +184,7 @@ struct vhba_wwnn {
  *		 is often determined by the resource of the hba.
  *		 e.g Max scatter gather list length * page size / sector size.
  *
- * WARNING: Values stired in this structure must contain maximum counts (not
+ * WARNING: Values stored in this structure must contain maximum counts (not
  * maximum values).
  *
  * 20 bytes

commit 6cf6e5e64532b2c6e4c77ffa235e295c4f35b0f7
Author: Sameer Wadgaonkar <sameer.wadgaonkar@unisys.com>
Date:   Fri Jun 30 15:43:10 2017 -0400

    staging: unisys: include: iochannel.h: fixed comment formatting issues
    
    Removed comments from the right side of the lines.
    
    Added kernel-doc like comments and cleaned up the inline comments in the
    structures.
    
    Signed-off-by: Sameer Wadgaonkar <sameer.wadgaonkar@unisys.com>
    Signed-off-by: David Kershner <david.kershner@unisys.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/unisys/include/iochannel.h b/drivers/staging/unisys/include/iochannel.h
index c7cb3fbde7b2..d79261047c30 100644
--- a/drivers/staging/unisys/include/iochannel.h
+++ b/drivers/staging/unisys/include/iochannel.h
@@ -71,8 +71,10 @@
 #define MAXNUM(a, b) (((a) > (b)) ? (a) : (b))
 
 /* Define the two queues per data channel between iopart and ioguestparts. */
+
 /* Used by ioguestpart to 'insert' signals to iopart. */
 #define IOCHAN_TO_IOPART 0
+
 /* Used by ioguestpart to 'remove' signals from iopart, same previous queue. */
 #define IOCHAN_FROM_IOPART 1
 
@@ -83,46 +85,45 @@
 
 #define MAX_PHYS_INFO 64
 
-/* Various types of network packets that can be sent in cmdrsp. */
+/*
+ * enum net_types - Various types of network packets that can be sent in cmdrsp.
+ * @NET_RCV_POST:	Submit buffer to hold receiving incoming packet.
+ * @NET_RCV:		visornic -> uisnic. Incoming packet received.
+ * @NET_XMIT:		uisnic -> visornic. For outgoing packet.
+ * @NET_XMIT_DONE:	visornic -> uisnic. Outgoing packet xmitted.
+ * @NET_RCV_ENBDIS:	uisnic -> visornic. Enable/Disable packet reception.
+ * @NET_RCV_ENBDIS_ACK:	visornic -> uisnic. Acknowledge enable/disable packet.
+ * @NET_RCV_PROMISC:	uisnic -> visornic. Enable/Disable promiscuous mode.
+ * @NET_CONNECT_STATUS:	visornic -> uisnic. Indicate the loss or restoration of
+ *			a network connection.
+ * @NET_MACADDR:	uisnic -> visornic. Indicates the client has requested
+ *			to update it's MAC address.
+ * @NET_MACADDR_ACK:	MAC address acknowledge.
+ */
 enum net_types {
-	NET_RCV_POST = 0,	/*
-				 * Submit buffer to hold receiving
-				 * incoming packet
-				 */
-	/* visornic -> uisnic */
-	NET_RCV,		/* incoming packet received */
-	/* uisnic -> visornic */
-	NET_XMIT,		/* for outgoing net packets */
-	/* visornic -> uisnic */
-	NET_XMIT_DONE,		/* outgoing packet xmitted */
-	/* uisnic -> visornic */
-	NET_RCV_ENBDIS,		/* enable/disable packet reception */
-	/* visornic -> uisnic */
-	NET_RCV_ENBDIS_ACK,	/* acknowledge enable/disable packet */
-				/* reception */
-	/* uisnic -> visornic */
-	NET_RCV_PROMISC,	/* enable/disable promiscuous mode */
-	/* visornic -> uisnic */
-	NET_CONNECT_STATUS,	/*
-				 * indicate the loss or restoration of a network
-				 * connection
-				 */
-	/* uisnic -> visornic */
-	NET_MACADDR,		/*
-				 * Indicates the client has requested to update
-				 * it's MAC address
-				 */
-	NET_MACADDR_ACK,	/* MAC address acknowledge */
-
+	NET_RCV_POST = 0,
+	NET_RCV,
+	NET_XMIT,
+	NET_XMIT_DONE,
+	NET_RCV_ENBDIS,
+	NET_RCV_ENBDIS_ACK,
+	/* Reception */
+	NET_RCV_PROMISC,
+	NET_CONNECT_STATUS,
+	NET_MACADDR,
+	NET_MACADDR_ACK,
 };
 
-#define ETH_MIN_DATA_SIZE 46	/* minimum eth data size */
+/* Minimum eth data size */
+#define ETH_MIN_DATA_SIZE 46
 #define ETH_MIN_PACKET_SIZE (ETH_HLEN + ETH_MIN_DATA_SIZE)
 
-#define VISOR_ETH_MAX_MTU 16384	/* maximum data size */
+/* Maximum data size */
+#define VISOR_ETH_MAX_MTU 16384
 
 #ifndef MAX_MACADDR_LEN
-#define MAX_MACADDR_LEN 6	/* number of bytes in MAC address */
+/* Number of bytes in MAC address */
+#define MAX_MACADDR_LEN 6
 #endif
 
 /* Various types of scsi task mgmt commands. */
@@ -156,10 +157,16 @@ struct guest_phys_info {
 
 #define GPI_ENTRIES_PER_PAGE (PAGE_SIZE / sizeof(struct guest_phys_info))
 
+/*
+ * struct uisscsi_dest
+ * @channel: Bus number.
+ * @id:      Target number.
+ * @lun:     Logical unit number.
+ */
 struct uisscsi_dest {
-	u32 channel;	/* channel == bus number */
-	u32 id;		/* id == target number */
-	u32 lun;	/* lun == logical unit number */
+	u32 channel;
+	u32 id;
+	u32 lun;
 } __packed;
 
 struct vhba_wwnn {
@@ -168,53 +175,71 @@ struct vhba_wwnn {
 } __packed;
 
 /*
+ * struct vhba_config_max
+ * @max_channel: Maximum channel for devices attached to this bus.
+ * @max_id:	 Maximum SCSI ID for devices attached to bus.
+ * @max_lun:	 Maximum SCSI LUN for devices attached to bus.
+ * @cmd_per_lun: Maximum number of outstanding commands per LUN.
+ * @max_io_size: Maximum io size for devices attached to this bus. Max io size
+ *		 is often determined by the resource of the hba.
+ *		 e.g Max scatter gather list length * page size / sector size.
+ *
  * WARNING: Values stired in this structure must contain maximum counts (not
  * maximum values).
+ *
+ * 20 bytes
  */
-struct vhba_config_max {/* 20 bytes */
-	u32 max_channel;/* maximum channel for devices attached to this bus */
-	u32 max_id;	/* maximum SCSI ID for devices attached to bus */
-	u32 max_lun;	/* maximum SCSI LUN for devices attached to bus */
-	u32 cmd_per_lun;/* maximum number of outstanding commands per LUN */
-	u32 max_io_size;/* maximum io size for devices attached to this bus */
-	/* max io size is often determined by the resource of the hba. e.g */
-	/* max scatter gather list length * page size / sector size */
+struct vhba_config_max {
+	u32 max_channel;
+	u32 max_id;
+	u32 max_lun;
+	u32 cmd_per_lun;
+	u32 max_io_size;
 } __packed;
 
+/*
+ * struct uiscmdrsp_scsi
+ *
+ * @handle:		The handle to the cmd that was received. Send it back as
+ *			is in the rsp packet.
+ * @cmnd:		The cdb for the command.
+ * @bufflen:		Length of data to be transferred out or in.
+ * @guest_phys_entries:	Number of entries in scatter-gather list.
+ * @struct gpi_list:	Physical address information for each fragment.
+ * @enum data_dir:	Direction of the data, if any.
+ * @struct vdest:	Identifies the virtual hba, id, channel, lun to which
+ *			cmd was sent.
+ * @linuxstat:		Original Linux status used by Linux vdisk.
+ * @scsistat:		The scsi status.
+ * @addlstat:		Non-scsi status.
+ * @sensebuf:		Sense info in case cmd failed. sensebuf holds the
+ *			sense_data struct. See sense_data struct for more
+ *			details.
+ * @*vdisk:		Pointer to the vdisk to clean up when IO completes.
+ * @no_disk_result:	Used to return no disk inquiry result when
+ *			no_disk_result is set to 1
+ *			scsi.scsistat is SAM_STAT_GOOD
+ *			scsi.addlstat is 0
+ *			scsi.linuxstat is SAM_STAT_GOOD
+ *			That is, there is NO error.
+ */
 struct uiscmdrsp_scsi {
-	u64 handle;		/* the handle to the cmd that was received */
-				/* send it back as is in the rsp packet.  */
-	u8 cmnd[MAX_CMND_SIZE];	/* the cdb for the command */
-	u32 bufflen;		/* length of data to be transferred out or in */
-	u16 guest_phys_entries;	/* Number of entries in scatter-gather list */
-	struct guest_phys_info gpi_list[MAX_PHYS_INFO];	/* physical address
-							 * information for each
-							 * fragment
-							 */
-	enum dma_data_direction data_dir; /* direction of the data, if any */
-	struct uisscsi_dest vdest;	/* identifies the virtual hba, id, */
-					/* channel, lun to which cmd was sent */
-
+	u64 handle;
+	u8 cmnd[MAX_CMND_SIZE];
+	u32 bufflen;
+	u16 guest_phys_entries;
+	struct guest_phys_info gpi_list[MAX_PHYS_INFO];
+	enum dma_data_direction data_dir;
+	struct uisscsi_dest vdest;
 	/* Needed to queue the rsp back to cmd originator. */
-	int linuxstat;		/* original Linux status used by Linux vdisk */
-	u8 scsistat;		/* the scsi status */
-	u8 addlstat;		/* non-scsi status */
+	int linuxstat;
+	u8 scsistat;
+	u8 addlstat;
 #define ADDL_SEL_TIMEOUT 4
-
 	/* The following fields are need to determine the result of command. */
-	 u8 sensebuf[MAX_SENSE_SIZE];	/* sense info in case cmd failed; */
-	/* sensebuf holds the sense_data struct; */
-	/* See sense_data struct for more details. */
-	void *vdisk; /* Pointer to the vdisk to clean up when IO completes. */
+	u8 sensebuf[MAX_SENSE_SIZE];
+	void *vdisk;
 	int no_disk_result;
-	/*
-	 * Used to return no disk inquiry result
-	 * when no_disk_result is set to 1,
-	 * scsi.scsistat is SAM_STAT_GOOD
-	 * scsi.addlstat is 0
-	 * scsi.linuxstat is SAM_STAT_GOOD
-	 * That is, there is NO error.
-	 */
 } __packed;
 
 /*
@@ -234,22 +259,35 @@ struct uiscmdrsp_scsi {
  * connected to this logical unit.
  */
 
-#define DEV_NOT_CAPABLE 0x7f	/*
-				 * peripheral qualifier of 0x3
-				 * peripheral type of 0x1f
-				 * specifies no device but target present
-				 */
-
-#define DEV_DISK_CAPABLE_NOT_PRESENT 0x20	/* peripheral qualifier of 0x1
-						 * peripheral type of 0 - disk
-						 * Specifies device capable, but
-						 * not present
-						 */
+/*
+ * Peripheral qualifier of 0x3
+ * Peripheral type of 0x1f
+ * Specifies no device but target present
+ */
+#define DEV_NOT_CAPABLE 0x7f
+/*
+ * Peripheral qualifier of 0x1
+ * Peripheral type of 0 - disk
+ * Specifies device capable, but not present
+ */
+#define DEV_DISK_CAPABLE_NOT_PRESENT 0x20
+/* HiSup = 1; shows support for report luns must be returned for lun 0. */
+#define DEV_HISUPPORT 0x10
 
-#define DEV_HISUPPORT 0x10	/*
-				 * HiSup = 1; shows support for report luns
-				 * must be returned for lun 0.
-				 */
+/*
+ * Peripheral qualifier of 0x3
+ * Peripheral type of 0x1f
+ * Specifies no device but target present
+ */
+#define DEV_NOT_CAPABLE 0x7f
+/*
+ * Peripheral qualifier of 0x1
+ * Peripheral type of 0 - disk
+ * Specifies device capable, but not present
+ */
+#define DEV_DISK_CAPABLE_NOT_PRESENT 0x20
+/* HiSup = 1; shows support for report luns must be returned for lun 0. */
+#define DEV_HISUPPORT 0x10
 
 /*
  * NOTE: Linux code assumes inquiry contains 36 bytes. Without checking length
@@ -258,11 +296,12 @@ struct uiscmdrsp_scsi {
  * inquiry result.
  */
 #define NO_DISK_INQUIRY_RESULT_LEN 36
-
-#define MIN_INQUIRY_RESULT_LEN 5 /* 5 bytes minimum for inquiry result */
+/* 5 bytes minimum for inquiry result */
+#define MIN_INQUIRY_RESULT_LEN 5
 
 /* SCSI device version for no disk inquiry result */
-#define SCSI_SPC2_VER 4	/* indicates SCSI SPC2 (SPC3 is 5) */
+/* indicates SCSI SPC2 (SPC3 is 5) */
+#define SCSI_SPC2_VER 4
 
 /* Struct and Defines to support sense information. */
 
@@ -297,35 +336,48 @@ struct sense_data {
 	u8 sense_key_specific[3];
 } __packed;
 
+/*
+ * struct net_pkt_xmt
+ * @len:		    Full length of data in the packet.
+ * @num_frags:		    Number of fragments in frags containing data.
+ * @struct phys_info frags: Physical page information.
+ * @ethhdr:		    The ethernet header.
+ * @struct lincsum:	    These are needed for csum at uisnic end.
+ *      @valid:	    1 = struct is valid - else ignore.
+ *      @hrawoffv:  1 = hwrafoff is valid.
+ *      @nhrawoffv: 1 = nhwrafoff is valid.
+ *      @protocol:  Specifies packet protocol.
+ *      @csum:	    Value used to set skb->csum at IOPart.
+ *      @hrawoff:   Value used to set skb->h.raw at IOPart. hrawoff points to
+ *		    the start of the TRANSPORT LAYER HEADER.
+ *      @nhrawoff:  Value used to set skb->nh.raw at IOPart. nhrawoff points to
+ *		    the start of the NETWORK LAYER HEADER.
+ *
+ * NOTE:
+ * The full packet is described in frags but the ethernet header is
+ * separately kept in ethhdr so that uisnic doesn't have "MAP" the
+ * guest memory to get to the header. uisnic needs ethhdr to
+ * determine how to route the packet.
+ */
 struct net_pkt_xmt {
-	int len;	/* full length of data in the packet */
-	int num_frags;	/* number of fragments in frags containing data */
-	struct phys_info frags[MAX_PHYS_INFO];	/* physical page information */
-	char ethhdr[ETH_HLEN];	/* the ethernet header  */
+	int len;
+	int num_frags;
+	struct phys_info frags[MAX_PHYS_INFO];
+	char ethhdr[ETH_HLEN];
 	struct {
-		/* These are needed for csum at uisnic end */
-		u8 valid;	/* 1 = struct is valid - else ignore */
-		u8 hrawoffv;	/* 1 = hwrafoff is valid */
-		u8 nhrawoffv;	/* 1 = nhwrafoff is valid */
-		__be16 protocol;	/* specifies packet protocol */
-		__wsum csum;	/* value used to set skb->csum at IOPart */
-		u32 hrawoff;	/* value used to set skb->h.raw at IOPart */
-		/* hrawoff points to the start of the TRANSPORT LAYER HEADER */
-		u32 nhrawoff;	/* value used to set skb->nh.raw at IOPart */
-		/* nhrawoff points to the start of the NETWORK LAYER HEADER */
+		u8 valid;
+		u8 hrawoffv;
+		u8 nhrawoffv;
+		__be16 protocol;
+		__wsum csum;
+		u32 hrawoff;
+		u32 nhrawoff;
 	} lincsum;
-
-	    /*
-	     * NOTE:
-	     * The full packet is described in frags but the ethernet header is
-	     * separately kept in ethhdr so that uisnic doesn't have "MAP" the
-	     * guest memory to get to the header. uisnic needs ethhdr to
-	     * determine how to route the packet.
-	     */
 } __packed;
 
 struct net_pkt_xmtdone {
-	u32 xmt_done_result; /* result of NET_XMIT */
+	/* Result of NET_XMIT */
+	u32 xmt_done_result;
 } __packed;
 
 /*
@@ -341,14 +393,12 @@ struct net_pkt_xmtdone {
 	((VISOR_ETH_MAX_MTU + ETH_HLEN + RCVPOST_BUF_SIZE - 1) \
 	 / RCVPOST_BUF_SIZE)
 
-/*
- * rcv buf size must be large enough to include ethernet data len + ethernet
+/* rcv buf size must be large enough to include ethernet data len + ethernet
  * header len - we are choosing 2K because it is guaranteed to be describable.
  */
 struct net_pkt_rcvpost {
 	/* Physical page information for the single fragment 2K rcv buf */
 	struct phys_info frag;
-
 	/*
 	 * Ensures that receive posts are returned to the adapter which we sent
 	 * them from originally.
@@ -358,143 +408,148 @@ struct net_pkt_rcvpost {
 } __packed;
 
 /*
+ * struct net_pkt_rcv
+ * @rcv_done_len:	Length of the received data.
+ * @numrcvbufs:		Contains the incoming data. Guest side MUST chain these
+ *			together.
+ * @*rcvbuf:		List of chained rcvbufa. Each entry is a receive buffer
+ *			provided by NET_RCV_POST. NOTE: First rcvbuf in the
+ *			chain will also be provided in net.buf.
+ * @unique_num:
+ * @rcvs_dropped_delta:
+ *
  * The number of rcvbuf that can be chained is based on max mtu and size of each
  * rcvbuf.
  */
 struct net_pkt_rcv {
-	u32 rcv_done_len; /* length of received data */
-
-	/*
-	 * numrcvbufs: contain the incoming data; guest side MUST chain these
-	 * together.
-	 */
+	u32 rcv_done_len;
 	u8 numrcvbufs;
-
-	void *rcvbuf[MAX_NET_RCV_CHAIN]; /* list of chained rcvbufs */
-
-	/* Each entry is a receive buffer provided by NET_RCV_POST. */
-	/* NOTE: first rcvbuf in the chain will also be provided in net.buf. */
+	void *rcvbuf[MAX_NET_RCV_CHAIN];
 	u64 unique_num;
 	u32 rcvs_dropped_delta;
 } __packed;
 
 struct net_pkt_enbdis {
 	void *context;
-	u16 enable; /* 1 = enable, 0 = disable */
+	/* 1 = enable, 0 = disable */
+	u16 enable;
 } __packed;
 
 struct net_pkt_macaddr {
 	void *context;
-	u8 macaddr[MAX_MACADDR_LEN]; /* 6 bytes */
+	/* 6 bytes */
+	u8 macaddr[MAX_MACADDR_LEN];
 } __packed;
 
-/* cmd rsp packet used for VNIC network traffic  */
+/*
+ * struct uiscmdrsp_net - cmd rsp packet used for VNIC network traffic.
+ * @enum type:
+ * @*buf:
+ * @union:
+ *	@struct xmt:	 Used for NET_XMIT.
+ *	@struct xmtdone: Used for NET_XMIT_DONE.
+ *	@struct rcvpost: Used for NET_RCV_POST.
+ *	@struct rcv:	 Used for NET_RCV.
+ *	@struct enbdis:	 Used for NET_RCV_ENBDIS, NET_RCV_ENBDIS_ACK,
+ *			 NET_RCV_PROMSIC, and NET_CONNECT_STATUS.
+ *	@struct macaddr:
+ */
 struct uiscmdrsp_net {
 	enum net_types type;
 	void *buf;
 	union {
-		struct net_pkt_xmt xmt;		/* used for NET_XMIT */
-		struct net_pkt_xmtdone xmtdone;	/* used for NET_XMIT_DONE */
-		struct net_pkt_rcvpost rcvpost;	/* used for NET_RCV_POST */
-		struct net_pkt_rcv rcv;		/* used for NET_RCV */
-		struct net_pkt_enbdis enbdis;	/* used for NET_RCV_ENBDIS, */
-						/* NET_RCV_ENBDIS_ACK,  */
-						/* NET_RCV_PROMSIC, */
-						/* and NET_CONNECT_STATUS */
+		struct net_pkt_xmt xmt;
+		struct net_pkt_xmtdone xmtdone;
+		struct net_pkt_rcvpost rcvpost;
+		struct net_pkt_rcv rcv;
+		struct net_pkt_enbdis enbdis;
 		struct net_pkt_macaddr macaddr;
 	};
 } __packed;
 
+/*
+ * struct uiscmdrsp_scsitaskmgmt
+ * @enum tasktype:	 The type of task.
+ * @struct vdest:	 The vdisk for which this task mgmt is generated.
+ * @handle:		 This is a handle that the guest has saved off for its
+ *			 own use. The handle value is preserved by iopart and
+ *			 returned as in task mgmt rsp.
+ * @notify_handle:	 For Linux guests, this is a pointer to wait_queue_head
+ *			 that a thread is waiting on to see if the taskmgmt
+ *			 command has completed. When the rsp is received by
+ *			 guest, the thread receiving the response uses this to
+ *			 notify the thread waiting for taskmgmt command
+ *			 completion. It's value is preserved by iopart and
+ *			 returned as in the task mgmt rsp.
+ * @notifyresult_handle: This is a handle to the location in the guest where
+ *			 the result of the taskmgmt command (result field) is
+ *			 saved to when the response is handled. It's value is
+ *			 preserved by iopart and returned as is in the task mgmt
+ *			 rsp.
+ * @result:		 Result of taskmgmt command - set by IOPart.
+ */
 struct uiscmdrsp_scsitaskmgmt {
-	/* The type of task. */
 	enum task_mgmt_types tasktype;
-
-	/* The vdisk for which this task mgmt is generated. */
 	struct uisscsi_dest vdest;
-
-	/*
-	 * This is a handle that the guest has saved off for its own use.
-	 * The handle value is preserved by iopart and returned as in task
-	 * mgmt rsp.
-	 */
 	u64 handle;
-
-	/*
-	 * For Linux guests, this is a pointer to wait_queue_head that a
-	 * thread is waiting on to see if the taskmgmt command has completed.
-	 * When the rsp is received by guest, the thread receiving the
-	 * response uses this to notify the thread waiting for taskmgmt
-	 * command completion. It's value is preserved by iopart and returned
-	 * as in the task mgmt rsp.
-	 */
 	u64 notify_handle;
-
-	/*
-	 * This is a handle to the location in the guest where the result of
-	 * the taskmgmt command (result field) is saved to when the response
-	 * is handled. It's value is preserved by iopart and returned as in
-	 * the task mgmt rsp.
-	 */
 	u64 notifyresult_handle;
-
-	/* Result of taskmgmt command - set by IOPart - values are: */
 	char result;
 
 #define TASK_MGMT_FAILED 0
 } __packed;
 
-/* Used by uissd to send disk add/remove notifications to Guest. */
-/* Note that the vHba pointer is not used by the Client/Guest side. */
+/*
+ * struct uiscmdrsp_disknotify - Used by uissd to send disk add/remove
+ *				 notifications to Guest.
+ * @add:     0-remove, 1-add.
+ * @*v_hba:  Channel info to route msg.
+ * @channel: SCSI Path of Disk to added or removed.
+ * @id:	     SCSI Path of Disk to added or removed.
+ * @lun:     SCSI Path of Disk to added or removed.
+ *
+ * Note that the vHba pointer is not used by the Client/Guest side.
+ */
 struct uiscmdrsp_disknotify {
-	u8 add;			/* 0-remove, 1-add */
-	void *v_hba;		/* channel info to route msg */
-	u32 channel, id, lun;	/* SCSI Path of Disk to added or removed */
+	u8 add;
+	void *v_hba;
+	u32 channel, id, lun;
 } __packed;
 
 /*
- * The following is used by virthba/vSCSI to send the Acquire/Release commands
- * to the IOVM.
+ * struct uiscmdrsp_vdiskmgmt - The following is used by virthba/vSCSI to send
+ *				the Acquire/Release commands to the IOVM.
+ * @enum vdisktype:	 The type of task.
+ * @struct vdest:	 The vdisk for which this task mgmt is generated.
+ * @handle:		 This is a handle that the guest has saved off for its
+ *			 own use. It's value is preserved by iopart and returned
+ *			 as in the task mgmt rsp.
+ * @notify_handle:	 For Linux guests, this is a pointer to wait_queue_head
+ *			 that a thread is waiting on to see if the tskmgmt
+ *			 command has completed. When the rsp is received by
+ *			 guest, the thread receiving the response uses this to
+ *			 notify the thread waiting for taskmgmt command
+ *			 completion. It's value is preserved by iopart and
+ *			 returned as in the task mgmt rsp.
+ * @notifyresult_handle: Handle to the location in guest where the result of the
+ *			 taskmgmt command (result field) is saved to when the
+ *			 response is handled. It's value is preserved by iopart
+ *			 and returned as in the task mgmt rsp.
+ * @result: Result of taskmgmt command - set by IOPart.
  */
 struct uiscmdrsp_vdiskmgmt {
-	/* The type of task */
 	enum vdisk_mgmt_types vdisktype;
-
-	/* The vdisk for which this task mgmt is generated */
 	struct uisscsi_dest vdest;
-
-	/*
-	 * This is a handle that the guest has saved off for its own use. It's
-	 * value is preserved by iopart and returned as in the task mgmt rsp.
-	 */
 	u64 handle;
-
-	/*
-	 * For Linux guests, this is a pointer to wait_queue_head that a
-	 * thread is waiting on to see if the tskmgmt command has completed.
-	 * When the rsp is received by guest, the thread receiving the
-	 * response uses this to notify the thread waiting for taskmgmt
-	 * command completion. It's value is preserved by iopart and returned
-	 * as in the task mgmt rsp.
-	 */
 	u64 notify_handle;
-
-	/*
-	 * Handle to the location in guest where the result of the
-	 * taskmgmt command (result field) is saved to when the response
-	 * is handled. It's value is preserved by iopart and returned as in
-	 * the task mgmt rsp.
-	 */
 	u64 notifyresult_handle;
-
-	/* Result of taskmgmt command - set by IOPart - values are: */
 	char result;
 } __packed;
 
 /* Keeping cmd and rsp info in one structure for now cmd rsp packet for SCSI */
 struct uiscmdrsp {
 	char cmdtype;
-
-/* Describes what type of information is in the struct */
+	/* Describes what type of information is in the struct */
 #define CMD_SCSI_TYPE	      1
 #define CMD_NET_TYPE	      2
 #define CMD_SCSITASKMGMT_TYPE 3
@@ -509,21 +564,33 @@ struct uiscmdrsp {
 	};
 	/* Send the response when the cmd is done (scsi and scsittaskmgmt). */
 	void *private_data;
-	struct uiscmdrsp *next;	/* General Purpose Queue Link */
-	struct uiscmdrsp *activeQ_next;	/* Pointer to the nextactive commands */
-	struct uiscmdrsp *activeQ_prev;	/* Pointer to the prevactive commands */
+	/* General Purpose Queue Link */
+	struct uiscmdrsp *next;
+	/* Pointer to the nextactive commands */
+	struct uiscmdrsp *activeQ_next;
+	/* Pointer to the prevactive commands */
+	struct uiscmdrsp *activeQ_prev;
 } __packed;
 
+/* total = 28 bytes */
 struct iochannel_vhba {
-	struct vhba_wwnn wwnn;		/* 8 bytes */
-	struct vhba_config_max max;	/* 20 bytes */
-} __packed;				/* total = 28 bytes */
+	/* 8 bytes */
+	struct vhba_wwnn wwnn;
+	/* 20 bytes */
+	struct vhba_config_max max;
+} __packed;
+
 struct iochannel_vnic {
-	u8 macaddr[6];			/* 6 bytes */
-	u32 num_rcv_bufs;		/* 4 bytes */
-	u32 mtu;			/* 4 bytes */
-	uuid_le zone_uuid;		/* 16 bytes */
+	/* 6 bytes */
+	u8 macaddr[6];
+	/* 4 bytes */
+	u32 num_rcv_bufs;
+	/* 4 bytes */
+	u32 mtu;
+	/* 16 bytes */
+	uuid_le zone_uuid;
 } __packed;
+
 /*
  * This is just the header of the IO channel. It is assumed that directly after
  * this header there is a large region of memory which contains the command and
@@ -550,4 +617,5 @@ struct visor_io_channel {
 #define PI_PAGE_SIZE 0x1000
 #define PI_PAGE_MASK 0x0FFF
 
-#endif /* __IOCHANNEL_H__ */
+/* __IOCHANNEL_H__ */
+#endif

commit 172f4c367c7239b2390302402cb360ad94fcac4a
Author: Sameer Wadgaonkar <sameer.wadgaonkar@unisys.com>
Date:   Fri May 19 16:17:57 2017 -0400

    staging: unisys: include: renamed structure spar_io_channel_protocol in iochannel.h to match driver namespace
    
    Renamed structure spar_io_channel_protocol to visor_io_channel and
    changed "visor bus" to "visorbus" in a comment in visornic_main.c
    and visorhba_main.c.
    
    Signed-off-by: Sameer Wadgaonkar <sameer.wadgaonkar@unisys.com>
    Signed-off-by: David Kershner <david.kershner@unisys.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/unisys/include/iochannel.h b/drivers/staging/unisys/include/iochannel.h
index 1365cb4a00f6..c7cb3fbde7b2 100644
--- a/drivers/staging/unisys/include/iochannel.h
+++ b/drivers/staging/unisys/include/iochannel.h
@@ -529,7 +529,7 @@ struct iochannel_vnic {
  * this header there is a large region of memory which contains the command and
  * response queues as specified in cmd_q and rsp_q SIGNAL_QUEUE_HEADERS.
  */
-struct spar_io_channel_protocol {
+struct visor_io_channel {
 	struct channel_header channel_header;
 	struct signal_queue_header cmd_q;
 	struct signal_queue_header rsp_q;

commit 68646323cd08e9dae69ea3a0bf58d31fc0963e35
Author: Sameer Wadgaonkar <sameer.wadgaonkar@unisys.com>
Date:   Fri May 19 16:17:56 2017 -0400

    staging: unisys: include: renamed #defines in iochannel.h to match driver namespace
    
    Renamed #defines
    * ULTRA_VHBA_CHANNEL_PROTOCOL_SIGNATURE to
                    VISOR_VHBA_CHANNEL_SIGNATURE
    * ULTRA_VNIC_CHANNEL_PROTOCOL_SIGNATURE to
                    VISOR_VNIC_CHANNEL_SIGNATURE
    * ULTRA_VSWITCH_CHANNEL_PROTOCOL_SIGNATURE to
                    VISOR_VSWITCH_CHANNEL_SIGNATURE
    * ULTRA_VHBA_CHANNEL_PROTOCOL_VERSIONID to
                    VISOR_VHBA_CHANNEL_VERSIONID
    * ULTRA_VNIC_CHANNEL_PROTOCOL_VERSIONID to
                    VISOR_VNIC_CHANNEL_VERSIONID
    * ULTRA_VSWITCH_CHANNEL_PROTOCOL_VERSIONID to
                    VISOR_VSWITCH_CHANNEL_VERSIONID
    * SPAR_VHBA_CHANNEL_OK_CLIENT to VISOR_VHBA_CHANNEL_OK_CLIENT
    * SPAR_VNIC_CHANNEL_OK_CLIENT to VISOR_VNIC_CHANNEL_OK_CLIENT
    
    Signed-off-by: Sameer Wadgaonkar <sameer.wadgaonkar@unisys.com>
    Signed-off-by: David Kershner <david.kershner@unisys.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/unisys/include/iochannel.h b/drivers/staging/unisys/include/iochannel.h
index d57b18023aac..1365cb4a00f6 100644
--- a/drivers/staging/unisys/include/iochannel.h
+++ b/drivers/staging/unisys/include/iochannel.h
@@ -34,9 +34,9 @@
 #include <linux/dma-direction.h>
 #include "channel.h"
 
-#define ULTRA_VHBA_CHANNEL_PROTOCOL_SIGNATURE VISOR_CHANNEL_SIGNATURE
-#define ULTRA_VNIC_CHANNEL_PROTOCOL_SIGNATURE VISOR_CHANNEL_SIGNATURE
-#define ULTRA_VSWITCH_CHANNEL_PROTOCOL_SIGNATURE VISOR_CHANNEL_SIGNATURE
+#define VISOR_VHBA_CHANNEL_SIGNATURE VISOR_CHANNEL_SIGNATURE
+#define VISOR_VNIC_CHANNEL_SIGNATURE VISOR_CHANNEL_SIGNATURE
+#define VISOR_VSWITCH_CHANNEL_SIGNATURE VISOR_CHANNEL_SIGNATURE
 
 /*
  * Must increment these whenever you insert or delete fields within this channel
@@ -45,21 +45,21 @@
  * usually add fields to the END of the channel struct without needing to
  * increment this.
  */
-#define ULTRA_VHBA_CHANNEL_PROTOCOL_VERSIONID 2
-#define ULTRA_VNIC_CHANNEL_PROTOCOL_VERSIONID 2
-#define ULTRA_VSWITCH_CHANNEL_PROTOCOL_VERSIONID 1
+#define VISOR_VHBA_CHANNEL_VERSIONID 2
+#define VISOR_VNIC_CHANNEL_VERSIONID 2
+#define VISOR_VSWITCH_CHANNEL_VERSIONID 1
 
-#define SPAR_VHBA_CHANNEL_OK_CLIENT(ch) \
+#define VISOR_VHBA_CHANNEL_OK_CLIENT(ch) \
 	(visor_check_channel(ch, visor_vhba_channel_uuid, \
-			    "vhba", MIN_IO_CHANNEL_SIZE,	\
-			    ULTRA_VHBA_CHANNEL_PROTOCOL_VERSIONID, \
-			    ULTRA_VHBA_CHANNEL_PROTOCOL_SIGNATURE))
+			     "vhba", MIN_IO_CHANNEL_SIZE, \
+			     VISOR_VHBA_CHANNEL_VERSIONID, \
+			     VISOR_VHBA_CHANNEL_SIGNATURE))
 
-#define SPAR_VNIC_CHANNEL_OK_CLIENT(ch) \
+#define VISOR_VNIC_CHANNEL_OK_CLIENT(ch) \
 	(visor_check_channel(ch, visor_vnic_channel_uuid, \
-			    "vnic", MIN_IO_CHANNEL_SIZE,	\
-			    ULTRA_VNIC_CHANNEL_PROTOCOL_VERSIONID, \
-			    ULTRA_VNIC_CHANNEL_PROTOCOL_SIGNATURE))
+			     "vnic", MIN_IO_CHANNEL_SIZE, \
+			     VISOR_VNIC_CHANNEL_VERSIONID, \
+			     VISOR_VNIC_CHANNEL_SIGNATURE))
 
 /*
  * Everything necessary to handle SCSI & NIC traffic between Guest Partition and

commit c75ebe5e30a0e1ed7ffacd4e45798ff98eca4e86
Author: Sameer Wadgaonkar <sameer.wadgaonkar@unisys.com>
Date:   Fri May 19 16:17:55 2017 -0400

    staging: unisys: include: renamed #defines in channel.h to match driver namespace
    
    Renamed #defines
    * ULTRA_CHANNEL_PROTOCOL_SIGNATURE to
                    VISOR_CHANNEL_SIGNATURE
    * SPAR_CHANNEL_SERVER_READY to
                    VISOR_CHANNEL_SERVER_READY
    * ULTRA_VALID_CHANNELCLI_TRANSITION
                    VISOR_VALID_CHANNELCLI_TRANSITION
    * ULTRA_CLIERRORBOOT_THROTTLEMSG_DISABLED to
                    VISOR_CLIERRORBOOT_THROTTLEMSG_DISABLED
    * ULTRA_CLIERRORBOOT_THROTTLEMSG_NOTATTACHED to
                    VISOR_CLIERRORBOOT_THROTTLEMSG_NOTATTACHED
    * ULTRA_CLIERRORBOOT_THROTTLEMSG_BUSY to
                    VISOR_CLIERRORBOOT_THROTTLEMSG_BUSY
    * ULTRA_IO_DRIVER_ENABLES_INTS to
                    VISOR_DRIVER_ENABLES_INTS
    * ULTRA_IO_CHANNEL_IS_POLLING to
                    VISOR_CHANNEL_IS_POLLING
    * ULTRA_IO_IOVM_IS_OK_WITH_DRIVER_DISABLING_INTS to
                    VISOR_IOVM_OK_DRIVER_DISABLING_INTS
    * ULTRA_IO_DRIVER_DISABLES_INTS to
                    VISOR_DRIVER_DISABLES_INTS
    * ULTRA_IO_DRIVER_SUPPORTS_ENHANCED_RCVBUF_CHECKING to
                    VISOR_DRIVER_ENHANCED_RCVBUF_CHECKING
    * ULTRA_CHANNEL_ENABLE_INTS to
                    VISOR_CHANNEL_ENABLE_INTS
    * SPAR_VHBA_CHANNEL_PROTOCOL_UUID to VISOR_VHBA_CHANNEL_UUID
    * SPAR_VHBA_CHANNEL_PROTOCOL_UUID_STR to
                    VISOR_VHBA_CHANNEL_UUID_STR
    * SPAR_VNIC_CHANNEL_PROTOCOL_UUID to VISOR_VNIC_CHANNEL_UUID
    * SPAR_VNIC_CHANNEL_PROTOCOL_UUID_STR to
                    VISOR_VNIC_CHANNEL_UUID_STR
    * SPAR_SIOVM_UUID to VISOR_SIOVM_UUID
    
    Signed-off-by: Sameer Wadgaonkar <sameer.wadgaonkar@unisys.com>
    Signed-off-by: David Kershner <david.kershner@unisys.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/unisys/include/iochannel.h b/drivers/staging/unisys/include/iochannel.h
index ce0e2e2008cf..d57b18023aac 100644
--- a/drivers/staging/unisys/include/iochannel.h
+++ b/drivers/staging/unisys/include/iochannel.h
@@ -34,10 +34,9 @@
 #include <linux/dma-direction.h>
 #include "channel.h"
 
-#define ULTRA_VHBA_CHANNEL_PROTOCOL_SIGNATURE ULTRA_CHANNEL_PROTOCOL_SIGNATURE
-#define ULTRA_VNIC_CHANNEL_PROTOCOL_SIGNATURE ULTRA_CHANNEL_PROTOCOL_SIGNATURE
-#define ULTRA_VSWITCH_CHANNEL_PROTOCOL_SIGNATURE \
-	ULTRA_CHANNEL_PROTOCOL_SIGNATURE
+#define ULTRA_VHBA_CHANNEL_PROTOCOL_SIGNATURE VISOR_CHANNEL_SIGNATURE
+#define ULTRA_VNIC_CHANNEL_PROTOCOL_SIGNATURE VISOR_CHANNEL_SIGNATURE
+#define ULTRA_VSWITCH_CHANNEL_PROTOCOL_SIGNATURE VISOR_CHANNEL_SIGNATURE
 
 /*
  * Must increment these whenever you insert or delete fields within this channel
@@ -51,13 +50,13 @@
 #define ULTRA_VSWITCH_CHANNEL_PROTOCOL_VERSIONID 1
 
 #define SPAR_VHBA_CHANNEL_OK_CLIENT(ch) \
-	(visor_check_channel(ch, spar_vhba_channel_protocol_uuid, \
+	(visor_check_channel(ch, visor_vhba_channel_uuid, \
 			    "vhba", MIN_IO_CHANNEL_SIZE,	\
 			    ULTRA_VHBA_CHANNEL_PROTOCOL_VERSIONID, \
 			    ULTRA_VHBA_CHANNEL_PROTOCOL_SIGNATURE))
 
 #define SPAR_VNIC_CHANNEL_OK_CLIENT(ch) \
-	(visor_check_channel(ch, spar_vnic_channel_protocol_uuid, \
+	(visor_check_channel(ch, visor_vnic_channel_uuid, \
 			    "vnic", MIN_IO_CHANNEL_SIZE,	\
 			    ULTRA_VNIC_CHANNEL_PROTOCOL_VERSIONID, \
 			    ULTRA_VNIC_CHANNEL_PROTOCOL_SIGNATURE))

commit 315dfc84d11f3624a684a426dcf8535367bbe130
Author: Sameer Wadgaonkar <sameer.wadgaonkar@unisys.com>
Date:   Fri May 19 16:17:54 2017 -0400

    staging: unisys: include: renamed function spar_check_channel in channel.h to match driver namespace
    
    Renamed function spar_check_channel() to visor_check_channel().
    
    Signed-off-by: Sameer Wadgaonkar <sameer.wadgaonkar@unisys.com>
    Signed-off-by: David Kershner <david.kershner@unisys.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/unisys/include/iochannel.h b/drivers/staging/unisys/include/iochannel.h
index 9bde848a321c..ce0e2e2008cf 100644
--- a/drivers/staging/unisys/include/iochannel.h
+++ b/drivers/staging/unisys/include/iochannel.h
@@ -51,13 +51,13 @@
 #define ULTRA_VSWITCH_CHANNEL_PROTOCOL_VERSIONID 1
 
 #define SPAR_VHBA_CHANNEL_OK_CLIENT(ch) \
-	(spar_check_channel(ch, spar_vhba_channel_protocol_uuid, \
+	(visor_check_channel(ch, spar_vhba_channel_protocol_uuid, \
 			    "vhba", MIN_IO_CHANNEL_SIZE,	\
 			    ULTRA_VHBA_CHANNEL_PROTOCOL_VERSIONID, \
 			    ULTRA_VHBA_CHANNEL_PROTOCOL_SIGNATURE))
 
 #define SPAR_VNIC_CHANNEL_OK_CLIENT(ch) \
-	(spar_check_channel(ch, spar_vnic_channel_protocol_uuid, \
+	(visor_check_channel(ch, spar_vnic_channel_protocol_uuid, \
 			    "vnic", MIN_IO_CHANNEL_SIZE,	\
 			    ULTRA_VNIC_CHANNEL_PROTOCOL_VERSIONID, \
 			    ULTRA_VNIC_CHANNEL_PROTOCOL_SIGNATURE))

commit 3659955a644c1de08bce69587c5b651d8759c5b5
Author: David Kershner <david.kershner@unisys.com>
Date:   Tue Mar 28 09:34:42 2017 -0400

    staging: unisys: remove client from spar_check_channel
    
    We only have one version of spar_check_channel, get rid of the client
    at the end and help save space.
    
    Signed-off-by: David Kershner <david.kershner@unisys.com>
    Reviewed-by: Reviewed-by: Tim Sell <timothy.sell@unisys.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/unisys/include/iochannel.h b/drivers/staging/unisys/include/iochannel.h
index 5d8a500550f6..9bde848a321c 100644
--- a/drivers/staging/unisys/include/iochannel.h
+++ b/drivers/staging/unisys/include/iochannel.h
@@ -51,16 +51,16 @@
 #define ULTRA_VSWITCH_CHANNEL_PROTOCOL_VERSIONID 1
 
 #define SPAR_VHBA_CHANNEL_OK_CLIENT(ch) \
-	(spar_check_channel_client(ch, spar_vhba_channel_protocol_uuid, \
-				   "vhba", MIN_IO_CHANNEL_SIZE,	\
-				   ULTRA_VHBA_CHANNEL_PROTOCOL_VERSIONID, \
-				   ULTRA_VHBA_CHANNEL_PROTOCOL_SIGNATURE))
+	(spar_check_channel(ch, spar_vhba_channel_protocol_uuid, \
+			    "vhba", MIN_IO_CHANNEL_SIZE,	\
+			    ULTRA_VHBA_CHANNEL_PROTOCOL_VERSIONID, \
+			    ULTRA_VHBA_CHANNEL_PROTOCOL_SIGNATURE))
 
 #define SPAR_VNIC_CHANNEL_OK_CLIENT(ch) \
-	(spar_check_channel_client(ch, spar_vnic_channel_protocol_uuid, \
-				   "vnic", MIN_IO_CHANNEL_SIZE,	\
-				   ULTRA_VNIC_CHANNEL_PROTOCOL_VERSIONID, \
-				   ULTRA_VNIC_CHANNEL_PROTOCOL_SIGNATURE))
+	(spar_check_channel(ch, spar_vnic_channel_protocol_uuid, \
+			    "vnic", MIN_IO_CHANNEL_SIZE,	\
+			    ULTRA_VNIC_CHANNEL_PROTOCOL_VERSIONID, \
+			    ULTRA_VNIC_CHANNEL_PROTOCOL_SIGNATURE))
 
 /*
  * Everything necessary to handle SCSI & NIC traffic between Guest Partition and

commit 31a9f6450b30fd221da3d1bf0513ae37fc2ff30b
Author: David Binder <david.binder@unisys.com>
Date:   Fri Mar 17 11:27:25 2017 -0400

    staging: unisys: include: iochannel.h: Fix #define formatting
    
    In an effort to create a more uniform coding style within the Unisys
    s-Par driver set, this patch adjusts the formatting of all #define
    directives within this source file to match the following template,
    and thereby eliminate irregular usage of whitespace:
    Reviewed-by: Tim Sell <timothy.sell@unisys.com>
    
    The amount of whitespace used between the <token> and the <value> is
    dependent on what is needed to make the surrounding #define directives
    as uniform as possible.
    
    Signed-off-by: David Binder <david.binder@unisys.com>
    Signed-off-by: David Kershner <david.kershner@unisys.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/unisys/include/iochannel.h b/drivers/staging/unisys/include/iochannel.h
index 0b61fd719356..5d8a500550f6 100644
--- a/drivers/staging/unisys/include/iochannel.h
+++ b/drivers/staging/unisys/include/iochannel.h
@@ -50,13 +50,13 @@
 #define ULTRA_VNIC_CHANNEL_PROTOCOL_VERSIONID 2
 #define ULTRA_VSWITCH_CHANNEL_PROTOCOL_VERSIONID 1
 
-#define SPAR_VHBA_CHANNEL_OK_CLIENT(ch)			\
+#define SPAR_VHBA_CHANNEL_OK_CLIENT(ch) \
 	(spar_check_channel_client(ch, spar_vhba_channel_protocol_uuid, \
 				   "vhba", MIN_IO_CHANNEL_SIZE,	\
 				   ULTRA_VHBA_CHANNEL_PROTOCOL_VERSIONID, \
 				   ULTRA_VHBA_CHANNEL_PROTOCOL_SIGNATURE))
 
-#define SPAR_VNIC_CHANNEL_OK_CLIENT(ch)			\
+#define SPAR_VNIC_CHANNEL_OK_CLIENT(ch) \
 	(spar_check_channel_client(ch, spar_vnic_channel_protocol_uuid, \
 				   "vnic", MIN_IO_CHANNEL_SIZE,	\
 				   ULTRA_VNIC_CHANNEL_PROTOCOL_VERSIONID, \
@@ -200,7 +200,7 @@ struct uiscmdrsp_scsi {
 	int linuxstat;		/* original Linux status used by Linux vdisk */
 	u8 scsistat;		/* the scsi status */
 	u8 addlstat;		/* non-scsi status */
-#define ADDL_SEL_TIMEOUT	4
+#define ADDL_SEL_TIMEOUT 4
 
 	/* The following fields are need to determine the result of command. */
 	 u8 sensebuf[MAX_SENSE_SIZE];	/* sense info in case cmd failed; */
@@ -340,7 +340,7 @@ struct net_pkt_xmtdone {
 #define RCVPOST_BUF_SIZE 4032
 #define MAX_NET_RCV_CHAIN \
 	((VISOR_ETH_MAX_MTU + ETH_HLEN + RCVPOST_BUF_SIZE - 1) \
-	/ RCVPOST_BUF_SIZE)
+	 / RCVPOST_BUF_SIZE)
 
 /*
  * rcv buf size must be large enough to include ethernet data len + ethernet
@@ -441,7 +441,7 @@ struct uiscmdrsp_scsitaskmgmt {
 	/* Result of taskmgmt command - set by IOPart - values are: */
 	char result;
 
-#define TASK_MGMT_FAILED  0
+#define TASK_MGMT_FAILED 0
 } __packed;
 
 /* Used by uissd to send disk add/remove notifications to Guest. */
@@ -496,11 +496,11 @@ struct uiscmdrsp {
 	char cmdtype;
 
 /* Describes what type of information is in the struct */
-#define CMD_SCSI_TYPE		1
-#define CMD_NET_TYPE		2
-#define CMD_SCSITASKMGMT_TYPE	3
-#define CMD_NOTIFYGUEST_TYPE	4
-#define CMD_VDISKMGMT_TYPE	5
+#define CMD_SCSI_TYPE	      1
+#define CMD_NET_TYPE	      2
+#define CMD_SCSITASKMGMT_TYPE 3
+#define CMD_NOTIFYGUEST_TYPE  4
+#define CMD_VDISKMGMT_TYPE    5
 	union {
 		struct uiscmdrsp_scsi scsi;
 		struct uiscmdrsp_net net;
@@ -548,7 +548,7 @@ struct spar_io_channel_protocol {
 #define SIZEOF_CMDRSP (COVER(sizeof(struct uiscmdrsp), 64))
 
 /* Use 4K page sizes when passing page info between Guest and IOPartition. */
-#define PI_PAGE_SIZE  0x1000
-#define PI_PAGE_MASK  0x0FFF
+#define PI_PAGE_SIZE 0x1000
+#define PI_PAGE_MASK 0x0FFF
 
 #endif /* __IOCHANNEL_H__ */

commit ea0d207564e3211658ceba9736dcca76bd8276b7
Author: David Binder <david.binder@unisys.com>
Date:   Fri Mar 17 11:27:06 2017 -0400

    staging: unisys: visornic: Move function to appropriate location
    
    Move function add_physinfo_entries() to visornic_main.c, which is the
    only function where it is used.
    
    Signed-off-by: David Binder <david.binder@unisys.com>
    Signed-off-by: David Kershner <david.kershner@unisys.com>
    Reviewed-by: Tim Sell <timothy.sell@unisys.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/unisys/include/iochannel.h b/drivers/staging/unisys/include/iochannel.h
index 53fed6d58da3..0b61fd719356 100644
--- a/drivers/staging/unisys/include/iochannel.h
+++ b/drivers/staging/unisys/include/iochannel.h
@@ -551,41 +551,4 @@ struct spar_io_channel_protocol {
 #define PI_PAGE_SIZE  0x1000
 #define PI_PAGE_MASK  0x0FFF
 
-/* Returns next non-zero index on success or 0 on failure (i.e. out of room). */
-static inline u16
-add_physinfo_entries(u64 inp_pfn, u16 inp_off, u32 inp_len, u16 index,
-		     u16 max_pi_arr_entries, struct phys_info pi_arr[])
-{
-	u32 len;
-	u16 i, firstlen;
-
-	firstlen = PI_PAGE_SIZE - inp_off;
-	if (inp_len <= firstlen) {
-		/* The input entry spans only one page - add as is. */
-		if (index >= max_pi_arr_entries)
-			return 0;
-		pi_arr[index].pi_pfn = inp_pfn;
-		pi_arr[index].pi_off = (u16)inp_off;
-		pi_arr[index].pi_len = (u16)inp_len;
-		return index + 1;
-	}
-
-	/* This entry spans multiple pages. */
-	for (len = inp_len, i = 0; len;
-		len -= pi_arr[index + i].pi_len, i++) {
-		if (index + i >= max_pi_arr_entries)
-			return 0;
-		pi_arr[index + i].pi_pfn = inp_pfn + i;
-		if (i == 0) {
-			pi_arr[index].pi_off = inp_off;
-			pi_arr[index].pi_len = firstlen;
-		} else {
-			pi_arr[index + i].pi_off = 0;
-			pi_arr[index + i].pi_len =
-			    (u16)MINNUM(len, (u32)PI_PAGE_SIZE);
-		}
-	}
-	return index + i;
-}
-
 #endif /* __IOCHANNEL_H__ */

commit 392064a0c1253fd648fe7d2d7b879ed841306ea6
Author: David Binder <david.binder@unisys.com>
Date:   Fri Mar 17 11:27:05 2017 -0400

    staging: unisys: include: Change out-of-date references
    
    Replace references to virtpci to visornic in iochannel.h.
    
    Signed-off-by: David Binder <david.binder@unisys.com>
    Signed-off-by: David Kershner <david.kershner@unisys.com>
    Reviewed-by: Tim Sell <timothy.sell@unisys.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/unisys/include/iochannel.h b/drivers/staging/unisys/include/iochannel.h
index 41e5b4e0a532..53fed6d58da3 100644
--- a/drivers/staging/unisys/include/iochannel.h
+++ b/drivers/staging/unisys/include/iochannel.h
@@ -92,11 +92,11 @@ enum net_types {
 				 */
 	/* visornic -> uisnic */
 	NET_RCV,		/* incoming packet received */
-	/* uisnic -> virtpci */
+	/* uisnic -> visornic */
 	NET_XMIT,		/* for outgoing net packets */
 	/* visornic -> uisnic */
 	NET_XMIT_DONE,		/* outgoing packet xmitted */
-	/* uisnic -> virtpci */
+	/* uisnic -> visornic */
 	NET_RCV_ENBDIS,		/* enable/disable packet reception */
 	/* visornic -> uisnic */
 	NET_RCV_ENBDIS_ACK,	/* acknowledge enable/disable packet */

commit 5b6d458e87e1a1937cab15b6d44eff2ae9ed8b55
Author: Andrea Ghittino <aghittino@gmail.com>
Date:   Sat Mar 4 18:20:50 2017 +0100

    staging: unisys: fix sparse warnings
    
    Sparse generates two warnings related to incorrect type in assignment.
    This patch changes the types in the struct defined in unisys
    
    Signed-off-by: Andrea Ghittino <aghittino@gmail.com>
    Acked-by: David Kershner <david.kershner@unisys.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/unisys/include/iochannel.h b/drivers/staging/unisys/include/iochannel.h
index 54f490090a59..41e5b4e0a532 100644
--- a/drivers/staging/unisys/include/iochannel.h
+++ b/drivers/staging/unisys/include/iochannel.h
@@ -308,8 +308,8 @@ struct net_pkt_xmt {
 		u8 valid;	/* 1 = struct is valid - else ignore */
 		u8 hrawoffv;	/* 1 = hwrafoff is valid */
 		u8 nhrawoffv;	/* 1 = nhwrafoff is valid */
-		u16 protocol;	/* specifies packet protocol */
-		u32 csum;	/* value used to set skb->csum at IOPart */
+		__be16 protocol;	/* specifies packet protocol */
+		__wsum csum;	/* value used to set skb->csum at IOPart */
 		u32 hrawoff;	/* value used to set skb->h.raw at IOPart */
 		/* hrawoff points to the start of the TRANSPORT LAYER HEADER */
 		u32 nhrawoff;	/* value used to set skb->nh.raw at IOPart */

commit 72cca7baf4fba777b8ab770b902cf2e08941773f
Merge: 5266e70335da 3e0f9b2ca8e4
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Dec 13 11:35:00 2016 -0800

    Merge tag 'staging-4.10-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/staging
    
    Pull staging/IIO updates from Greg KH:
     "Here's the "big" staging/iio pull request for 4.10-rc1.
    
      Not as big as 4.9 was, but still just over a thousand changes. We
      almost broke even of lines added vs. removed, as the slicoss driver
      was removed (got a "clean" driver for the same hardware through the
      netdev tree), and some iio drivers were also dropped, but I think we
      ended up adding a few thousand lines to the source tree in the end.
      Other than that it's a lot of minor fixes all over the place, nothing
      major stands out at all.
    
      All of these have been in linux-next for a while. There will be a
      merge conflict with Al's vfs tree in the lustre code, but the
      resolution for that should be pretty simple, that too has been in
      linux-next"
    
    * tag 'staging-4.10-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/staging: (1002 commits)
      staging: comedi: comedidev.h: Document usage of 'detach' handler
      staging: fsl-mc: remove unnecessary info prints from bus driver
      staging: fsl-mc: add sysfs ABI doc
      staging/lustre/o2iblnd: Fix misspelled attemps->attempts
      staging/lustre/o2iblnd: Fix misspelling intialized->intialized
      staging/lustre: Convert all bare unsigned to unsigned int
      staging/lustre/socklnd: Fix whitespace problem
      staging/lustre/o2iblnd: Add missing space
      staging/lustre/lnetselftest: Fix potential integer overflow
      staging: greybus: audio_module: remove redundant OOM message
      staging: dgnc: Fix lines longer than 80 characters
      staging: dgnc: fix blank line after '{' warnings.
      staging/android: remove Sync Framework tasks from TODO
      staging/lustre/osc: Revert erroneous list_for_each_entry_safe use
      staging: slicoss: remove the staging driver
      staging: lustre: libcfs: remove lnet upcall code
      staging: lustre: remove set but unused variables
      staging: lustre: osc: set lock data for readahead lock
      staging: lustre: import: don't reconnect during connect interpret
      staging: lustre: clio: remove mtime check in vvp_io_fault_start()
      ...

commit b18f9c676f939038c4e61b40ba7d3e8e2a640a5f
Author: Erik Arfvidson <erik.arfvidson@unisys.com>
Date:   Mon Nov 21 12:15:41 2016 -0500

    staging: unisys: include: fix pound defines
    
    The purpose of this patch is to add style consistency and
    beautify the entire file. This patch removes unused pound defines
    and cleans up spacing and tabbing of pound defines.
    
    Signed-off-by: Erik Arfvidson <erik.arfvidson@unisys.com>
    Signed-off-by: David Kershner <david.kershner@unisys.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/unisys/include/iochannel.h b/drivers/staging/unisys/include/iochannel.h
index eeca16ecbe84..c43da782f37e 100644
--- a/drivers/staging/unisys/include/iochannel.h
+++ b/drivers/staging/unisys/include/iochannel.h
@@ -117,12 +117,12 @@ enum net_types {
 
 };
 
-#define		ETH_HEADER_SIZE 14	/* size of ethernet header */
+#define ETH_HEADER_SIZE 14	/* size of ethernet header */
 
-#define		ETH_MIN_DATA_SIZE 46	/* minimum eth data size */
-#define		ETH_MIN_PACKET_SIZE (ETH_HEADER_SIZE + ETH_MIN_DATA_SIZE)
+#define ETH_MIN_DATA_SIZE 46	/* minimum eth data size */
+#define ETH_MIN_PACKET_SIZE (ETH_HEADER_SIZE + ETH_MIN_DATA_SIZE)
 
-#define		ETH_MAX_MTU 16384	/* maximum data size */
+#define ETH_MAX_MTU 16384	/* maximum data size */
 
 #ifndef MAX_MACADDR_LEN
 #define MAX_MACADDR_LEN 6	/* number of bytes in MAC address */
@@ -491,8 +491,6 @@ struct uiscmdrsp_vdiskmgmt {
 
 	/* Result of taskmgmt command - set by IOPart - values are: */
 	char result;
-
-#define VDISK_MGMT_FAILED  0
 } __packed;
 
 /* Keeping cmd and rsp info in one structure for now cmd rsp packet for SCSI */
@@ -549,12 +547,8 @@ struct spar_io_channel_protocol {
 } __packed;
 
 /* INLINE functions for initializing and accessing I/O data channels. */
-#define SIZEOF_PROTOCOL (COVER(sizeof(struct spar_io_channel_protocol), 64))
 #define SIZEOF_CMDRSP (COVER(sizeof(struct uiscmdrsp), 64))
 
-#define MIN_IO_CHANNEL_SIZE COVER(SIZEOF_PROTOCOL + \
-				  2 * MIN_NUMSIGNALS * SIZEOF_CMDRSP, 4096)
-
 /* Use 4K page sizes when passing page info between Guest and IOPartition. */
 #define PI_PAGE_SIZE  0x1000
 #define PI_PAGE_MASK  0x0FFF

commit 209e3500ef7bf9414eb21c86027712d57229c6b8
Author: Erik Arfvidson <erik.arfvidson@unisys.com>
Date:   Mon Nov 21 12:15:40 2016 -0500

    staging: unisys: include: fixed iochannel.h comments
    
    The purpose of this patch is to add style consistency and beautify the
    entire file.
    
    Grammar:
    Uppercased beginning of new sentences/paragraphs
    Missing ' and .
    Fixed several comments using prefix phrase "as is in" to "as in"
    Standard Grammar
    
    Comments:
    Fixed comments to follow the multiline styling
    All comments are now either same line or above variable/definitions
    Removed nested slash-star comments
    Removed a random comment left by accident
    Aligned star comments
    
    Signed-off-by: Erik Arfvidson <erik.arfvidson@unisys.com>
    Signed-off-by: David Kershner <david.kershner@unisys.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/unisys/include/iochannel.h b/drivers/staging/unisys/include/iochannel.h
index cba4433bcd51..eeca16ecbe84 100644
--- a/drivers/staging/unisys/include/iochannel.h
+++ b/drivers/staging/unisys/include/iochannel.h
@@ -1,20 +1,20 @@
-/* Copyright (C) 2010 - 2013 UNISYS CORPORATION */
+/* Copyright (C) 2010 - 2016 UNISYS CORPORATION */
 /* All rights reserved. */
 #ifndef __IOCHANNEL_H__
 #define __IOCHANNEL_H__
 
 /*
  * Everything needed for IOPart-GuestPart communication is define in
- * this file.  Note: Everything is OS-independent because this file is
+ * this file. Note: Everything is OS-independent because this file is
  * used by Windows, Linux and possible EFI drivers.
  */
 
 /*
  * Communication flow between the IOPart and GuestPart uses the channel headers
- * channel state.  The following states are currently being used:
+ * channel state. The following states are currently being used:
  *       UNINIT(All Zeroes), CHANNEL_ATTACHING, CHANNEL_ATTACHED, CHANNEL_OPENED
  *
- * additional states will be used later.  No locking is needed to switch between
+ * Additional states will be used later. No locking is needed to switch between
  * states due to the following rules:
  *
  *      1.  IOPart is only the only partition allowed to change from UNIT
@@ -39,10 +39,11 @@
 #define ULTRA_VSWITCH_CHANNEL_PROTOCOL_SIGNATURE \
 	ULTRA_CHANNEL_PROTOCOL_SIGNATURE
 
-/* Must increment these whenever you insert or delete fields within this channel
- * struct.  Also increment whenever you change the meaning of fields within this
- * channel struct so as to break pre-existing software.  Note that you can
- * usually add fields to the END of the channel struct withOUT needing to
+/*
+ * Must increment these whenever you insert or delete fields within this channel
+ * struct. Also increment whenever you change the meaning of fields within this
+ * channel struct so as to break pre-existing software. Note that you can
+ * usually add fields to the END of the channel struct without needing to
  * increment this.
  */
 #define ULTRA_VHBA_CHANNEL_PROTOCOL_VERSIONID 2
@@ -70,46 +71,49 @@
 #define MINNUM(a, b) (((a) < (b)) ? (a) : (b))
 #define MAXNUM(a, b) (((a) > (b)) ? (a) : (b))
 
-/* define the two queues per data channel between iopart and ioguestparts */
-/* used by ioguestpart to 'insert' signals to iopart */
+/* Define the two queues per data channel between iopart and ioguestparts. */
+/* Used by ioguestpart to 'insert' signals to iopart. */
 #define IOCHAN_TO_IOPART 0
-/* used by ioguestpart to 'remove' signals from iopart, same previous queue */
+/* Used by ioguestpart to 'remove' signals from iopart, same previous queue. */
 #define IOCHAN_FROM_IOPART 1
 
-/* size of cdb - i.e., scsi cmnd */
+/* Size of cdb - i.e., SCSI cmnd */
 #define MAX_CMND_SIZE 16
 
 #define MAX_SENSE_SIZE 64
 
 #define MAX_PHYS_INFO 64
 
-/* various types of network packets that can be sent in cmdrsp */
+/* Various types of network packets that can be sent in cmdrsp. */
 enum net_types {
-	NET_RCV_POST = 0,	/* submit buffer to hold receiving
+	NET_RCV_POST = 0,	/*
+				 * Submit buffer to hold receiving
 				 * incoming packet
 				 */
-	/* virtnic -> uisnic */
+	/* visornic -> uisnic */
 	NET_RCV,		/* incoming packet received */
 	/* uisnic -> virtpci */
 	NET_XMIT,		/* for outgoing net packets */
-	/* virtnic -> uisnic */
+	/* visornic -> uisnic */
 	NET_XMIT_DONE,		/* outgoing packet xmitted */
 	/* uisnic -> virtpci */
 	NET_RCV_ENBDIS,		/* enable/disable packet reception */
-	/* virtnic -> uisnic */
+	/* visornic -> uisnic */
 	NET_RCV_ENBDIS_ACK,	/* acknowledge enable/disable packet */
 				/* reception */
-	/* uisnic -> virtnic */
+	/* uisnic -> visornic */
 	NET_RCV_PROMISC,	/* enable/disable promiscuous mode */
-	/* virtnic -> uisnic */
-	NET_CONNECT_STATUS,	/* indicate the loss or restoration of a network
+	/* visornic -> uisnic */
+	NET_CONNECT_STATUS,	/*
+				 * indicate the loss or restoration of a network
 				 * connection
 				 */
-	/* uisnic -> virtnic */
-	NET_MACADDR,		/* indicates the client has requested to update
-				 * its MAC addr
+	/* uisnic -> visornic */
+	NET_MACADDR,		/*
+				 * Indicates the client has requested to update
+				 * it's MAC address
 				 */
-	NET_MACADDR_ACK,	/* MAC address */
+	NET_MACADDR_ACK,	/* MAC address acknowledge */
 
 };
 
@@ -122,9 +126,9 @@ enum net_types {
 
 #ifndef MAX_MACADDR_LEN
 #define MAX_MACADDR_LEN 6	/* number of bytes in MAC address */
-#endif				/* MAX_MACADDR_LEN */
+#endif
 
-/* various types of scsi task mgmt commands  */
+/* Various types of scsi task mgmt commands. */
 enum task_mgmt_types {
 	TASK_MGMT_ABORT_TASK = 1,
 	TASK_MGMT_BUS_RESET,
@@ -132,7 +136,7 @@ enum task_mgmt_types {
 	TASK_MGMT_TARGET_RESET,
 };
 
-/* various types of vdisk mgmt commands  */
+/* Various types of vdisk mgmt commands. */
 enum vdisk_mgmt_types {
 	VDISK_MGMT_ACQUIRE = 1,
 	VDISK_MGMT_RELEASE,
@@ -146,7 +150,7 @@ struct phys_info {
 
 #define MIN_NUMSIGNALS 64
 
-/* structs with pragma pack  */
+/* Structs with pragma pack. */
 
 struct guest_phys_info {
 	u64 address;
@@ -156,9 +160,9 @@ struct guest_phys_info {
 #define GPI_ENTRIES_PER_PAGE (PAGE_SIZE / sizeof(struct guest_phys_info))
 
 struct uisscsi_dest {
-	u32 channel;		/* channel == bus number */
-	u32 id;			/* id == target number */
-	u32 lun;		/* lun == logical unit number */
+	u32 channel;	/* channel == bus number */
+	u32 id;		/* id == target number */
+	u32 lun;	/* lun == logical unit number */
 } __packed;
 
 struct vhba_wwnn {
@@ -166,7 +170,8 @@ struct vhba_wwnn {
 	u32 wwnn2;
 } __packed;
 
-/* WARNING: Values stired in this structure must contain maximum counts (not
+/*
+ * WARNING: Values stired in this structure must contain maximum counts (not
  * maximum values).
  */
 struct vhba_config_max {/* 20 bytes */
@@ -189,23 +194,24 @@ struct uiscmdrsp_scsi {
 							 * information for each
 							 * fragment
 							 */
-	enum dma_data_direction  data_dir; /* direction of the data, if any */
+	enum dma_data_direction data_dir; /* direction of the data, if any */
 	struct uisscsi_dest vdest;	/* identifies the virtual hba, id, */
 					/* channel, lun to which cmd was sent */
 
-	/* Needed to queue the rsp back to cmd originator */
-	int linuxstat;		/* original Linux status used by linux vdisk */
+	/* Needed to queue the rsp back to cmd originator. */
+	int linuxstat;		/* original Linux status used by Linux vdisk */
 	u8 scsistat;		/* the scsi status */
 	u8 addlstat;		/* non-scsi status */
 #define ADDL_SEL_TIMEOUT	4
 
-	/* the following fields are need to determine the result of command */
+	/* The following fields are need to determine the result of command. */
 	 u8 sensebuf[MAX_SENSE_SIZE];	/* sense info in case cmd failed; */
-	/* it holds the sense_data struct; */
-	/* see that struct for details. */
-	void *vdisk; /* pointer to the vdisk to clean up when IO completes. */
+	/* sensebuf holds the sense_data struct; */
+	/* See sense_data struct for more details. */
+	void *vdisk; /* Pointer to the vdisk to clean up when IO completes. */
 	int no_disk_result;
-	/* used to return no disk inquiry result
+	/*
+	 * Used to return no disk inquiry result
 	 * when no_disk_result is set to 1,
 	 * scsi.scsistat is SAM_STAT_GOOD
 	 * scsi.addlstat is 0
@@ -214,35 +220,44 @@ struct uiscmdrsp_scsi {
 	 */
 } __packed;
 
-/* Defines to support sending correct inquiry result when no disk is
+/*
+ * Defines to support sending correct inquiry result when no disk is
  * configured.
  */
 
-/* From SCSI SPC2 -
+/*
+ * From SCSI SPC2 -
  *
  * If the target is not capable of supporting a device on this logical unit, the
  * device server shall set this field to 7Fh (PERIPHERAL QUALIFIER set to 011b
  * and PERIPHERAL DEVICE TYPE set to 1Fh).
  *
- *The device server is capable of supporting the specified peripheral device
- *type on this logical unit. However, the physical device is not currently
- *connected to this logical unit.
+ * The device server is capable of supporting the specified peripheral device
+ * type on this logical unit. However, the physical device is not currently
+ * connected to this logical unit.
  */
 
-#define DEV_NOT_CAPABLE 0x7f	/* peripheral qualifier of 0x3  */
-				/* peripheral type of 0x1f */
-				/* specifies no device but target present */
+#define DEV_NOT_CAPABLE 0x7f	/*
+				 * peripheral qualifier of 0x3
+				 * peripheral type of 0x1f
+				 * specifies no device but target present
+				 */
 
-#define DEV_DISK_CAPABLE_NOT_PRESENT 0x20 /* peripheral qualifier of 0x1 */
-    /* peripheral type of 0 - disk */
-    /* specifies device capable, but not present */
+#define DEV_DISK_CAPABLE_NOT_PRESENT 0x20	/* peripheral qualifier of 0x1
+						 * peripheral type of 0 - disk
+						 * Specifies device capable, but
+						 * not present
+						 */
 
-#define DEV_HISUPPORT 0x10	/* HiSup = 1; shows support for report luns */
-				/* must be returned for lun 0. */
+#define DEV_HISUPPORT 0x10	/*
+				 * HiSup = 1; shows support for report luns
+				 * must be returned for lun 0.
+				 */
 
-/* NOTE: Linux code assumes inquiry contains 36 bytes. Without checking length
- * in buf[4] some linux code accesses bytes beyond 5 to retrieve vendor, product
- * & revision.  Yikes! So let us always send back 36 bytes, the minimum for
+/*
+ * NOTE: Linux code assumes inquiry contains 36 bytes. Without checking length
+ * in buf[4] some Linux code accesses bytes beyond 5 to retrieve vendor, product
+ * and revision. Yikes! So let us always send back 36 bytes, the minimum for
  * inquiry result.
  */
 #define NO_DISK_INQUIRY_RESULT_LEN 36
@@ -250,11 +265,12 @@ struct uiscmdrsp_scsi {
 #define MIN_INQUIRY_RESULT_LEN 5 /* 5 bytes minimum for inquiry result */
 
 /* SCSI device version for no disk inquiry result */
-#define SCSI_SPC2_VER 4		/* indicates SCSI SPC2 (SPC3 is 5) */
+#define SCSI_SPC2_VER 4	/* indicates SCSI SPC2 (SPC3 is 5) */
 
-/* Struct & Defines to support sense information. */
+/* Struct and Defines to support sense information. */
 
-/* The following struct is returned in sensebuf field in uiscmdrsp_scsi.  It is
+/*
+ * The following struct is returned in sensebuf field in uiscmdrsp_scsi. It is
  * initialized in exactly the manner that is recommended in Windows (hence the
  * odd values).
  * When set, these fields will have the following values:
@@ -290,7 +306,7 @@ struct net_pkt_xmt {
 	struct phys_info frags[MAX_PHYS_INFO];	/* physical page information */
 	char ethhdr[ETH_HEADER_SIZE];	/* the ethernet header  */
 	struct {
-		/* these are needed for csum at uisnic end */
+		/* These are needed for csum at uisnic end */
 		u8 valid;	/* 1 = struct is valid - else ignore */
 		u8 hrawoffv;	/* 1 = hwrafoff is valid */
 		u8 nhrawoffv;	/* 1 = nhwrafoff is valid */
@@ -302,7 +318,8 @@ struct net_pkt_xmt {
 		/* nhrawoff points to the start of the NETWORK LAYER HEADER */
 	} lincsum;
 
-	    /* **** NOTE ****
+	    /*
+	     * NOTE:
 	     * The full packet is described in frags but the ethernet header is
 	     * separately kept in ethhdr so that uisnic doesn't have "MAP" the
 	     * guest memory to get to the header. uisnic needs ethhdr to
@@ -311,14 +328,15 @@ struct net_pkt_xmt {
 } __packed;
 
 struct net_pkt_xmtdone {
-	u32 xmt_done_result;	/* result of NET_XMIT */
+	u32 xmt_done_result; /* result of NET_XMIT */
 } __packed;
 
-/* RCVPOST_BUF_SIZe must be at most page_size(4096) - cache_line_size (64) The
+/*
+ * RCVPOST_BUF_SIZE must be at most page_size(4096) - cache_line_size (64) The
  * reason is because dev_skb_alloc which is used to generate RCV_POST skbs in
- * virtnic requires that there is "overhead" in the buffer, and pads 16 bytes. I
- * prefer to use 1 full cache line size for "overhead" so that transfers are
- * better.  IOVM requires that a buffer be represented by 1 phys_info structure
+ * visornic requires that there is "overhead" in the buffer, and pads 16 bytes.
+ * Use 1 full cache line size for "overhead" so that transfers are optimized.
+ * IOVM requires that a buffer be represented by 1 phys_info structure
  * which can only cover page_size.
  */
 #define RCVPOST_BUF_SIZE 4032
@@ -326,26 +344,38 @@ struct net_pkt_xmtdone {
 	((ETH_MAX_MTU + ETH_HEADER_SIZE + RCVPOST_BUF_SIZE - 1) \
 	/ RCVPOST_BUF_SIZE)
 
+/*
+ * rcv buf size must be large enough to include ethernet data len + ethernet
+ * header len - we are choosing 2K because it is guaranteed to be describable.
+ */
 struct net_pkt_rcvpost {
-	    /* rcv buf size must be large enough to include ethernet data len +
-	     * ethernet header len - we are choosing 2K because it is guaranteed
-	     * to be describable
-	     */
-	    struct phys_info frag;	/* physical page information for the */
-					/* single fragment 2K rcv buf */
-	    u64 unique_num;
-	    /* unique_num ensure that receive posts are returned to */
-	    /* the Adapter which we sent them originally. */
+	/* Physical page information for the single fragment 2K rcv buf */
+	struct phys_info frag;
+
+	/*
+	 * Ensures that receive posts are returned to the adapter which we sent
+	 * them from originally.
+	 */
+	u64 unique_num;
+
 } __packed;
 
+/*
+ * The number of rcvbuf that can be chained is based on max mtu and size of each
+ * rcvbuf.
+ */
 struct net_pkt_rcv {
-	/* the number of receive buffers that can be chained  */
-	/* is based on max mtu and size of each rcv buf */
-	u32 rcv_done_len;	/* length of received data */
-	u8 numrcvbufs;		/* number of receive buffers that contain the */
-	/* incoming data; guest end MUST chain these together. */
-	void *rcvbuf[MAX_NET_RCV_CHAIN];	/* list of chained rcvbufs */
-	/* each entry is a receive buffer provided by NET_RCV_POST. */
+	u32 rcv_done_len; /* length of received data */
+
+	/*
+	 * numrcvbufs: contain the incoming data; guest side MUST chain these
+	 * together.
+	 */
+	u8 numrcvbufs;
+
+	void *rcvbuf[MAX_NET_RCV_CHAIN]; /* list of chained rcvbufs */
+
+	/* Each entry is a receive buffer provided by NET_RCV_POST. */
 	/* NOTE: first rcvbuf in the chain will also be provided in net.buf. */
 	u64 unique_num;
 	u32 rcvs_dropped_delta;
@@ -353,12 +383,12 @@ struct net_pkt_rcv {
 
 struct net_pkt_enbdis {
 	void *context;
-	u16 enable;		/* 1 = enable, 0 = disable */
+	u16 enable; /* 1 = enable, 0 = disable */
 } __packed;
 
 struct net_pkt_macaddr {
 	void *context;
-	u8 macaddr[MAX_MACADDR_LEN];	/* 6 bytes */
+	u8 macaddr[MAX_MACADDR_LEN]; /* 6 bytes */
 } __packed;
 
 /* cmd rsp packet used for VNIC network traffic  */
@@ -379,41 +409,44 @@ struct uiscmdrsp_net {
 } __packed;
 
 struct uiscmdrsp_scsitaskmgmt {
+	/* The type of task. */
 	enum task_mgmt_types tasktype;
 
-	    /* the type of task */
+	/* The vdisk for which this task mgmt is generated. */
 	struct uisscsi_dest vdest;
 
-	    /* the vdisk for which this task mgmt is generated */
+	/*
+	 * This is a handle that the guest has saved off for its own use.
+	 * The handle value is preserved by iopart and returned as in task
+	 * mgmt rsp.
+	 */
 	u64 handle;
 
-	    /* This is a handle that the guest has saved off for its own use.
-	     * Its value is preserved by iopart & returned as is in the task
-	     * mgmt rsp.
-	     */
+	/*
+	 * For Linux guests, this is a pointer to wait_queue_head that a
+	 * thread is waiting on to see if the taskmgmt command has completed.
+	 * When the rsp is received by guest, the thread receiving the
+	 * response uses this to notify the thread waiting for taskmgmt
+	 * command completion. It's value is preserved by iopart and returned
+	 * as in the task mgmt rsp.
+	 */
 	u64 notify_handle;
 
-	   /* For linux guests, this is a pointer to wait_queue_head that a
-	    * thread is waiting on to see if the taskmgmt command has completed.
-	    * When the rsp is received by guest, the thread receiving the
-	    * response uses this to notify the thread waiting for taskmgmt
-	    * command completion.  Its value is preserved by iopart & returned
-	    * as is in the task mgmt rsp.
-	    */
+	/*
+	 * This is a handle to the location in the guest where the result of
+	 * the taskmgmt command (result field) is saved to when the response
+	 * is handled. It's value is preserved by iopart and returned as in
+	 * the task mgmt rsp.
+	 */
 	u64 notifyresult_handle;
 
-	    /* this is a handle to location in guest where the result of the
-	     * taskmgmt command (result field) is to saved off when the response
-	     * is handled.  Its value is preserved by iopart & returned as is in
-	     * the task mgmt rsp.
-	     */
+	/* Result of taskmgmt command - set by IOPart - values are: */
 	char result;
 
-	    /* result of taskmgmt command - set by IOPart - values are: */
 #define TASK_MGMT_FAILED  0
 } __packed;
 
-/* Used by uissd to send disk add/remove notifications to Guest */
+/* Used by uissd to send disk add/remove notifications to Guest. */
 /* Note that the vHba pointer is not used by the Client/Guest side. */
 struct uiscmdrsp_disknotify {
 	u8 add;			/* 0-remove, 1-add */
@@ -421,49 +454,52 @@ struct uiscmdrsp_disknotify {
 	u32 channel, id, lun;	/* SCSI Path of Disk to added or removed */
 } __packed;
 
-/* The following is used by virthba/vSCSI to send the Acquire/Release commands
+/*
+ * The following is used by virthba/vSCSI to send the Acquire/Release commands
  * to the IOVM.
  */
 struct uiscmdrsp_vdiskmgmt {
+	/* The type of task */
 	enum vdisk_mgmt_types vdisktype;
 
-	    /* the type of task */
+	/* The vdisk for which this task mgmt is generated */
 	struct uisscsi_dest vdest;
 
-	    /* the vdisk for which this task mgmt is generated */
+	/*
+	 * This is a handle that the guest has saved off for its own use. It's
+	 * value is preserved by iopart and returned as in the task mgmt rsp.
+	 */
 	u64 handle;
 
-	    /* This is a handle that the guest has saved off for its own use.
-	     * Its value is preserved by iopart & returned as is in the task
-	     * mgmt rsp.
-	     */
+	/*
+	 * For Linux guests, this is a pointer to wait_queue_head that a
+	 * thread is waiting on to see if the tskmgmt command has completed.
+	 * When the rsp is received by guest, the thread receiving the
+	 * response uses this to notify the thread waiting for taskmgmt
+	 * command completion. It's value is preserved by iopart and returned
+	 * as in the task mgmt rsp.
+	 */
 	u64 notify_handle;
 
-	    /* For linux guests, this is a pointer to wait_queue_head that a
-	     * thread is waiting on to see if the tskmgmt command has completed.
-	     * When the rsp is received by guest, the thread receiving the
-	     * response uses this to notify the thread waiting for taskmgmt
-	     * command completion.  Its value is preserved by iopart & returned
-	     * as is in the task mgmt rsp.
-	     */
+	/*
+	 * Handle to the location in guest where the result of the
+	 * taskmgmt command (result field) is saved to when the response
+	 * is handled. It's value is preserved by iopart and returned as in
+	 * the task mgmt rsp.
+	 */
 	u64 notifyresult_handle;
 
-	    /* this is a handle to location in guest where the result of the
-	     * taskmgmt command (result field) is to saved off when the response
-	     * is handled.  Its value is preserved by iopart & returned as is in
-	     * the task mgmt rsp.
-	     */
+	/* Result of taskmgmt command - set by IOPart - values are: */
 	char result;
 
-	    /* result of taskmgmt command - set by IOPart - values are: */
 #define VDISK_MGMT_FAILED  0
 } __packed;
 
-/* keeping cmd & rsp info in one structure for now cmd rsp packet for scsi */
+/* Keeping cmd and rsp info in one structure for now cmd rsp packet for SCSI */
 struct uiscmdrsp {
 	char cmdtype;
 
-/* describes what type of information is in the struct */
+/* Describes what type of information is in the struct */
 #define CMD_SCSI_TYPE		1
 #define CMD_NET_TYPE		2
 #define CMD_SCSITASKMGMT_TYPE	3
@@ -476,11 +512,11 @@ struct uiscmdrsp {
 		struct uiscmdrsp_disknotify disknotify;
 		struct uiscmdrsp_vdiskmgmt vdiskmgmt;
 	};
-	void *private_data;	/* send the response when the cmd is */
-				/* done (scsi & scsittaskmgmt). */
+	/* Send the response when the cmd is done (scsi and scsittaskmgmt). */
+	void *private_data;
 	struct uiscmdrsp *next;	/* General Purpose Queue Link */
-	struct uiscmdrsp *activeQ_next;	/* Used to track active commands */
-	struct uiscmdrsp *activeQ_prev;	/* Used to track active commands */
+	struct uiscmdrsp *activeQ_next;	/* Pointer to the nextactive commands */
+	struct uiscmdrsp *activeQ_prev;	/* Pointer to the prevactive commands */
 } __packed;
 
 struct iochannel_vhba {
@@ -493,7 +529,8 @@ struct iochannel_vnic {
 	u32 mtu;			/* 4 bytes */
 	uuid_le zone_uuid;		/* 16 bytes */
 } __packed;
-/* This is just the header of the IO channel.  It is assumed that directly after
+/*
+ * This is just the header of the IO channel. It is assumed that directly after
  * this header there is a large region of memory which contains the command and
  * response queues as specified in cmd_q and rsp_q SIGNAL_QUEUE_HEADERS.
  */
@@ -507,31 +544,23 @@ struct spar_io_channel_protocol {
 	} __packed;
 
 #define MAX_CLIENTSTRING_LEN 1024
-	/* client_string is NULL termimated so holds max -1 bytes */
+	/* client_string is NULL termimated so holds max-1 bytes */
 	 u8 client_string[MAX_CLIENTSTRING_LEN];
 } __packed;
 
-/* INLINE functions for initializing and accessing I/O data channels */
+/* INLINE functions for initializing and accessing I/O data channels. */
 #define SIZEOF_PROTOCOL (COVER(sizeof(struct spar_io_channel_protocol), 64))
 #define SIZEOF_CMDRSP (COVER(sizeof(struct uiscmdrsp), 64))
 
 #define MIN_IO_CHANNEL_SIZE COVER(SIZEOF_PROTOCOL + \
 				  2 * MIN_NUMSIGNALS * SIZEOF_CMDRSP, 4096)
 
-/*
- * INLINE function for expanding a guest's pfn-off-size into multiple 4K page
- * pfn-off-size entires.
- */
-
-/* use 4K page sizes when we it comes to passing page information between */
-/* Guest and IOPartition. */
+/* Use 4K page sizes when passing page info between Guest and IOPartition. */
 #define PI_PAGE_SIZE  0x1000
 #define PI_PAGE_MASK  0x0FFF
 
-/* returns next non-zero index on success or zero on failure (i.e. out of
- * room)
- */
-static inline  u16
+/* Returns next non-zero index on success or 0 on failure (i.e. out of room). */
+static inline u16
 add_physinfo_entries(u64 inp_pfn, u16 inp_off, u32 inp_len, u16 index,
 		     u16 max_pi_arr_entries, struct phys_info pi_arr[])
 {
@@ -540,7 +569,7 @@ add_physinfo_entries(u64 inp_pfn, u16 inp_off, u32 inp_len, u16 index,
 
 	firstlen = PI_PAGE_SIZE - inp_off;
 	if (inp_len <= firstlen) {
-		/* the input entry spans only one page - add as is */
+		/* The input entry spans only one page - add as is. */
 		if (index >= max_pi_arr_entries)
 			return 0;
 		pi_arr[index].pi_pfn = inp_pfn;
@@ -549,7 +578,7 @@ add_physinfo_entries(u64 inp_pfn, u16 inp_off, u32 inp_len, u16 index,
 		return index + 1;
 	}
 
-	/* this entry spans multiple pages */
+	/* This entry spans multiple pages. */
 	for (len = inp_len, i = 0; len;
 		len -= pi_arr[index + i].pi_len, i++) {
 		if (index + i >= max_pi_arr_entries)
@@ -567,4 +596,4 @@ add_physinfo_entries(u64 inp_pfn, u16 inp_off, u32 inp_len, u16 index,
 	return index + i;
 }
 
-#endif				/* __IOCHANNEL_H__ */
+#endif /* __IOCHANNEL_H__ */

commit d0c2c9973ecd267307543526ae93855e3a3e4b23
Author: Jarod Wilson <jarod@redhat.com>
Date:   Thu Oct 20 13:55:21 2016 -0400

    net: use core MTU range checking in virt drivers
    
    hyperv_net:
    - set min/max_mtu, per Haiyang, after rndis_filter_device_add
    
    virtio_net:
    - set min/max_mtu
    - remove virtnet_change_mtu
    
    vmxnet3:
    - set min/max_mtu
    
    xen-netback:
    - min_mtu = 0, max_mtu = 65517
    
    xen-netfront:
    - min_mtu = 0, max_mtu = 65535
    
    unisys/visor:
    - clean up defines a little to not clash with network core or add
      redundat definitions
    
    CC: netdev@vger.kernel.org
    CC: virtualization@lists.linux-foundation.org
    CC: "K. Y. Srinivasan" <kys@microsoft.com>
    CC: Haiyang Zhang <haiyangz@microsoft.com>
    CC: "Michael S. Tsirkin" <mst@redhat.com>
    CC: Shrikrishna Khare <skhare@vmware.com>
    CC: "VMware, Inc." <pv-drivers@vmware.com>
    CC: Wei Liu <wei.liu2@citrix.com>
    CC: Paul Durrant <paul.durrant@citrix.com>
    CC: David Kershner <david.kershner@unisys.com>
    Signed-off-by: Jarod Wilson <jarod@redhat.com>
    Reviewed-by: Haiyang Zhang <haiyangz@microsoft.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/staging/unisys/include/iochannel.h b/drivers/staging/unisys/include/iochannel.h
index cba4433bcd51..9081b3f8779c 100644
--- a/drivers/staging/unisys/include/iochannel.h
+++ b/drivers/staging/unisys/include/iochannel.h
@@ -113,12 +113,10 @@ enum net_types {
 
 };
 
-#define		ETH_HEADER_SIZE 14	/* size of ethernet header */
-
 #define		ETH_MIN_DATA_SIZE 46	/* minimum eth data size */
-#define		ETH_MIN_PACKET_SIZE (ETH_HEADER_SIZE + ETH_MIN_DATA_SIZE)
+#define		ETH_MIN_PACKET_SIZE (ETH_HLEN + ETH_MIN_DATA_SIZE)
 
-#define		ETH_MAX_MTU 16384	/* maximum data size */
+#define		VISOR_ETH_MAX_MTU 16384	/* maximum data size */
 
 #ifndef MAX_MACADDR_LEN
 #define MAX_MACADDR_LEN 6	/* number of bytes in MAC address */
@@ -288,7 +286,7 @@ struct net_pkt_xmt {
 	int len;	/* full length of data in the packet */
 	int num_frags;	/* number of fragments in frags containing data */
 	struct phys_info frags[MAX_PHYS_INFO];	/* physical page information */
-	char ethhdr[ETH_HEADER_SIZE];	/* the ethernet header  */
+	char ethhdr[ETH_HLEN];	/* the ethernet header  */
 	struct {
 		/* these are needed for csum at uisnic end */
 		u8 valid;	/* 1 = struct is valid - else ignore */
@@ -323,7 +321,7 @@ struct net_pkt_xmtdone {
  */
 #define RCVPOST_BUF_SIZE 4032
 #define MAX_NET_RCV_CHAIN \
-	((ETH_MAX_MTU + ETH_HEADER_SIZE + RCVPOST_BUF_SIZE - 1) \
+	((VISOR_ETH_MAX_MTU + ETH_HLEN + RCVPOST_BUF_SIZE - 1) \
 	/ RCVPOST_BUF_SIZE)
 
 struct net_pkt_rcvpost {

commit d6d0c6f444a82a792cef1be5860255bd1cae93bb
Author: David Binder <david.binder@unisys.com>
Date:   Fri Sep 2 16:41:33 2016 -0400

    staging: unisys: visorbus: Merge channel_guid.h with channel.h
    
    Merges the contents of channel_guid.h with channel.h, as the former was
    not a proper header file. Therefore, the channel_guid.h is no longer
    needed.
    
    Signed-off-by: David Binder <david.binder@unisys.com>
    Signed-off-by: David Kershner <david.kershner@unisys.com>
    Reviewed-by: Tim Sell <Timothy.Sell@unisys.com>
    Reported-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/unisys/include/iochannel.h b/drivers/staging/unisys/include/iochannel.h
index 5ccf81485d72..cba4433bcd51 100644
--- a/drivers/staging/unisys/include/iochannel.h
+++ b/drivers/staging/unisys/include/iochannel.h
@@ -33,7 +33,6 @@
 
 #include <linux/dma-direction.h>
 #include "channel.h"
-#include "channel_guid.h"
 
 #define ULTRA_VHBA_CHANNEL_PROTOCOL_SIGNATURE ULTRA_CHANNEL_PROTOCOL_SIGNATURE
 #define ULTRA_VNIC_CHANNEL_PROTOCOL_SIGNATURE ULTRA_CHANNEL_PROTOCOL_SIGNATURE

commit 9136d04fe9255522c4c8ef5124be899906de7dd1
Author: Alexander Curtin <alexander.curtin@unisys.com>
Date:   Fri May 6 13:11:15 2016 -0400

    staging: unisys: visorhba: replace functionlike macro with function
    
    The `set_no_disk_inquiry_request` function now uses the correct min
    macro. Also I removed an unnecessary conditional.
    
    Get rid of u8 casts, u32 len, and u32 lun (which is actually defined
    as a u64 in the scsidev->lun field from whence it originated).
    
    Signed-off-by: Alexander Curtin <alexander.curtin@unisys.com>
    Signed-off-by: Tim Sell <Timothy.Sell@unisys.com>
    Signed-off-by: Erik Arfvidson <erik.arfvidson@unisys.com>
    Signed-off-by: David Kershner <david.kershner@unisys.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/unisys/include/iochannel.h b/drivers/staging/unisys/include/iochannel.h
index 880d9f04cbcf..5ccf81485d72 100644
--- a/drivers/staging/unisys/include/iochannel.h
+++ b/drivers/staging/unisys/include/iochannel.h
@@ -253,48 +253,6 @@ struct uiscmdrsp_scsi {
 /* SCSI device version for no disk inquiry result */
 #define SCSI_SPC2_VER 4		/* indicates SCSI SPC2 (SPC3 is 5) */
 
-/* Windows and Linux want different things for a non-existent lun. So, we'll let
- * caller pass in the peripheral qualifier and type.
- * NOTE:[4] SCSI returns (n-4); so we return length-1-4 or length-5.
- */
-
-#define SET_NO_DISK_INQUIRY_RESULT(buf, len, lun, lun0notpresent, notpresent) \
-	do {								\
-		memset(buf, 0,						\
-		       MINNUM(len,					\
-			      (unsigned int)NO_DISK_INQUIRY_RESULT_LEN)); \
-		buf[2] = (u8)SCSI_SPC2_VER;				\
-		if (lun == 0) {						\
-			buf[0] = (u8)lun0notpresent;			\
-			buf[3] = (u8)DEV_HISUPPORT;			\
-		} else							\
-			buf[0] = (u8)notpresent;			\
-		buf[4] = (u8)(						\
-			MINNUM(len,					\
-			       (unsigned int)NO_DISK_INQUIRY_RESULT_LEN) - 5);\
-		if (len >= NO_DISK_INQUIRY_RESULT_LEN) {		\
-			buf[8] = 'D';					\
-			buf[9] = 'E';					\
-			buf[10] = 'L';					\
-			buf[11] = 'L';					\
-			buf[16] = 'P';					\
-			buf[17] = 'S';					\
-			buf[18] = 'E';					\
-			buf[19] = 'U';					\
-			buf[20] = 'D';					\
-			buf[21] = 'O';					\
-			buf[22] = ' ';					\
-			buf[23] = 'D';					\
-			buf[24] = 'E';					\
-			buf[25] = 'V';					\
-			buf[26] = 'I';					\
-			buf[27] = 'C';					\
-			buf[28] = 'E';					\
-			buf[30] = ' ';					\
-			buf[31] = '.';					\
-		}							\
-	} while (0)
-
 /* Struct & Defines to support sense information. */
 
 /* The following struct is returned in sensebuf field in uiscmdrsp_scsi.  It is

commit 785d43077f855ef710aa765273d3355efa7c82fe
Author: David Kershner <david.kershner@unisys.com>
Date:   Wed Feb 24 13:30:38 2016 -0500

    staging: unisys: iochannel.h add_phys_info needs u64 pfn
    
    The pfn field in the channel is 64 bits, the parameter being passed
    should be 64 bits as well.
    
    Signed-off-by: David Kershner <david.kershner@unisys.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/unisys/include/iochannel.h b/drivers/staging/unisys/include/iochannel.h
index 42356a29383d..880d9f04cbcf 100644
--- a/drivers/staging/unisys/include/iochannel.h
+++ b/drivers/staging/unisys/include/iochannel.h
@@ -575,7 +575,7 @@ struct spar_io_channel_protocol {
  * room)
  */
 static inline  u16
-add_physinfo_entries(u32 inp_pfn, u16 inp_off, u32 inp_len, u16 index,
+add_physinfo_entries(u64 inp_pfn, u16 inp_off, u32 inp_len, u16 index,
 		     u16 max_pi_arr_entries, struct phys_info pi_arr[])
 {
 	u32 len;

commit 12bfed88f492357e2a2bb9c3048c381f581be3b7
Author: David Kershner <david.kershner@unisys.com>
Date:   Wed Feb 24 13:30:37 2016 -0500

    staging: unisys: iochannel.h: fix inconsistent indenting
    
    Smatch complained about inconsistent indenting. This patch addresses it.
    
    Signed-off-by: David Kershner <david.kershner@unisys.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/unisys/include/iochannel.h b/drivers/staging/unisys/include/iochannel.h
index 162ca187a66b..42356a29383d 100644
--- a/drivers/staging/unisys/include/iochannel.h
+++ b/drivers/staging/unisys/include/iochannel.h
@@ -589,21 +589,19 @@ add_physinfo_entries(u32 inp_pfn, u16 inp_off, u32 inp_len, u16 index,
 		pi_arr[index].pi_pfn = inp_pfn;
 		pi_arr[index].pi_off = (u16)inp_off;
 		pi_arr[index].pi_len = (u16)inp_len;
-		    return index + 1;
+		return index + 1;
 	}
 
-	    /* this entry spans multiple pages */
-	    for (len = inp_len, i = 0; len;
-		 len -= pi_arr[index + i].pi_len, i++) {
+	/* this entry spans multiple pages */
+	for (len = inp_len, i = 0; len;
+		len -= pi_arr[index + i].pi_len, i++) {
 		if (index + i >= max_pi_arr_entries)
 			return 0;
 		pi_arr[index + i].pi_pfn = inp_pfn + i;
 		if (i == 0) {
 			pi_arr[index].pi_off = inp_off;
 			pi_arr[index].pi_len = firstlen;
-		}
-
-		else {
+		} else {
 			pi_arr[index + i].pi_off = 0;
 			pi_arr[index + i].pi_len =
 			    (u16)MINNUM(len, (u32)PI_PAGE_SIZE);

commit 0678eb1e4e0de2eaf40a28243bb9f227ae4ff49e
Author: Erik Arfvidson <erik.arfvidson@unisys.com>
Date:   Tue Nov 17 13:34:51 2015 -0500

    staging: unisys: iochannel fix trailing */
    
    Fixed last warning message from checkpatch.pl by removing the
    wordiness of the comment
    
    Signed-off-by: Erik Arfvidson <erik.arfvidson@unisys.com>
    Signed-off-by: Benjamin Romer <benjamin.romer@unisys.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/unisys/include/iochannel.h b/drivers/staging/unisys/include/iochannel.h
index 36664ccc08df..162ca187a66b 100644
--- a/drivers/staging/unisys/include/iochannel.h
+++ b/drivers/staging/unisys/include/iochannel.h
@@ -566,8 +566,7 @@ struct spar_io_channel_protocol {
  * pfn-off-size entires.
  */
 
-/* we deal with 4K page sizes when we it comes to passing page information
- * between */
+/* use 4K page sizes when we it comes to passing page information between */
 /* Guest and IOPartition. */
 #define PI_PAGE_SIZE  0x1000
 #define PI_PAGE_MASK  0x0FFF

commit c06a278344ad5024e44d962ce9aa2ed945f0d1cf
Author: Erik Arfvidson <erik.arfvidson@unisys.com>
Date:   Tue Nov 17 13:34:50 2015 -0500

    staging: unisys: iochannel fix spacing around operators
    
    This patch fixes check warning from checkpatch.pl in the macro definition
    CHECK: spaces preferred around that '+' (ctx:VxV)
    
    Signed-off-by: Erik Arfvidson <erik.arfvidson@unisys.com>
    Signed-off-by: Benjamin Romer <benjamin.romer@unisys.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/unisys/include/iochannel.h b/drivers/staging/unisys/include/iochannel.h
index ec04576fe20c..36664ccc08df 100644
--- a/drivers/staging/unisys/include/iochannel.h
+++ b/drivers/staging/unisys/include/iochannel.h
@@ -366,7 +366,8 @@ struct net_pkt_xmtdone {
  */
 #define RCVPOST_BUF_SIZE 4032
 #define MAX_NET_RCV_CHAIN \
-	((ETH_MAX_MTU+ETH_HEADER_SIZE + RCVPOST_BUF_SIZE-1) / RCVPOST_BUF_SIZE)
+	((ETH_MAX_MTU + ETH_HEADER_SIZE + RCVPOST_BUF_SIZE - 1) \
+	/ RCVPOST_BUF_SIZE)
 
 struct net_pkt_rcvpost {
 	    /* rcv buf size must be large enough to include ethernet data len +

commit 71c3c5a8ef37ab21397516caca778238874dc3dd
Author: Erik Arfvidson <erik.arfvidson@unisys.com>
Date:   Tue Nov 17 13:34:49 2015 -0500

    staging: unisys: iochannel.h remove redundant comments
    
    iochannel cleanup redudant comments in function declarations.
    
    Signed-off-by: Erik Arfvidson <erik.arfvidson@unisys.com>
    Signed-off-by: Benjamin Romer <benjamin.romer@unisys.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/unisys/include/iochannel.h b/drivers/staging/unisys/include/iochannel.h
index 457fe3d46478..ec04576fe20c 100644
--- a/drivers/staging/unisys/include/iochannel.h
+++ b/drivers/staging/unisys/include/iochannel.h
@@ -575,18 +575,8 @@ struct spar_io_channel_protocol {
  * room)
  */
 static inline  u16
-add_physinfo_entries(u32 inp_pfn,	/* input - specifies the pfn to be used
-					 * to add entries */
-		     u16 inp_off,	/* input - specifies the off to be used
-					 * to add entries */
-		     u32 inp_len,	/* input - specifies the len to be used
-					 * to add entries */
-		     u16 index,		/* input - index in array at which new
-					 * entries are added */
-		     u16 max_pi_arr_entries,	/* input - specifies the maximum
-						 * entries pi_arr can hold */
-		     struct phys_info pi_arr[]) /* input & output - array to
-						  * which entries are added */
+add_physinfo_entries(u32 inp_pfn, u16 inp_off, u32 inp_len, u16 index,
+		     u16 max_pi_arr_entries, struct phys_info pi_arr[])
 {
 	u32 len;
 	u16 i, firstlen;

commit 79c07e9c1f3948757c30fa630c66903da2a247ec
Author: Erik Arfvidson <erik.arfvidson@unisys.com>
Date:   Tue Nov 17 13:34:48 2015 -0500

    staging: unisys: iochannel fix block comments
    
    This patch fixes warning messages from checkpatch.pl specifically:
    WARNING: Block comments use a trailing */ on a separate lines
    
    Signed-off-by: Erik Arfvidson <erik.arfvidson@unisys.com>
    Signed-off-by: Benjamin Romer <benjamin.romer@unisys.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/unisys/include/iochannel.h b/drivers/staging/unisys/include/iochannel.h
index 14e656ff73ec..457fe3d46478 100644
--- a/drivers/staging/unisys/include/iochannel.h
+++ b/drivers/staging/unisys/include/iochannel.h
@@ -6,7 +6,8 @@
 /*
  * Everything needed for IOPart-GuestPart communication is define in
  * this file.  Note: Everything is OS-independent because this file is
- * used by Windows, Linux and possible EFI drivers.  */
+ * used by Windows, Linux and possible EFI drivers.
+ */
 
 /*
  * Communication flow between the IOPart and GuestPart uses the channel headers
@@ -66,21 +67,15 @@
  * IO Partition is defined below.
  */
 
-/*
- * Defines and enums.
- */
-
+/* Defines and enums. */
 #define MINNUM(a, b) (((a) < (b)) ? (a) : (b))
 #define MAXNUM(a, b) (((a) > (b)) ? (a) : (b))
 
-/* these define the two queues per data channel between iopart and
- * ioguestparts
- */
-#define IOCHAN_TO_IOPART 0 /* used by ioguestpart to 'insert' signals to
-			    * iopart */
-
-#define IOCHAN_FROM_IOPART 1 /* used by ioguestpart to 'remove' signals from
-			      * iopart - same queue as previous queue */
+/* define the two queues per data channel between iopart and ioguestparts */
+/* used by ioguestpart to 'insert' signals to iopart */
+#define IOCHAN_TO_IOPART 0
+/* used by ioguestpart to 'remove' signals from iopart, same previous queue */
+#define IOCHAN_FROM_IOPART 1
 
 /* size of cdb - i.e., scsi cmnd */
 #define MAX_CMND_SIZE 16
@@ -92,26 +87,29 @@
 /* various types of network packets that can be sent in cmdrsp */
 enum net_types {
 	NET_RCV_POST = 0,	/* submit buffer to hold receiving
-				 * incoming packet */
+				 * incoming packet
+				 */
 	/* virtnic -> uisnic */
 	NET_RCV,		/* incoming packet received */
 	/* uisnic -> virtpci */
-	NET_XMIT,		/* for outgoing net packets      */
+	NET_XMIT,		/* for outgoing net packets */
 	/* virtnic -> uisnic */
 	NET_XMIT_DONE,		/* outgoing packet xmitted */
 	/* uisnic -> virtpci */
 	NET_RCV_ENBDIS,		/* enable/disable packet reception */
 	/* virtnic -> uisnic */
-	NET_RCV_ENBDIS_ACK,	/* acknowledge enable/disable packet
-				 * reception */
+	NET_RCV_ENBDIS_ACK,	/* acknowledge enable/disable packet */
+				/* reception */
 	/* uisnic -> virtnic */
 	NET_RCV_PROMISC,	/* enable/disable promiscuous mode */
 	/* virtnic -> uisnic */
 	NET_CONNECT_STATUS,	/* indicate the loss or restoration of a network
-				 * connection */
+				 * connection
+				 */
 	/* uisnic -> virtnic */
 	NET_MACADDR,		/* indicates the client has requested to update
-				 * its MAC addr */
+				 * its MAC addr
+				 */
 	NET_MACADDR_ACK,	/* MAC address */
 
 };
@@ -170,51 +168,43 @@ struct vhba_wwnn {
 } __packed;
 
 /* WARNING: Values stired in this structure must contain maximum counts (not
- * maximum values). */
-struct vhba_config_max {	/* 20 bytes */
-	u32 max_channel;	/* maximum channel for devices attached to this
-				 * bus */
-	u32 max_id;		/* maximum SCSI ID for devices attached to this
-				 * bus */
-	u32 max_lun;		/* maximum SCSI LUN for devices attached to this
-				 * bus */
-	u32 cmd_per_lun;	/* maximum number of outstanding commands per
-				 * lun that are allowed at one time */
-	u32 max_io_size;	/* maximum io size for devices attached to this
-				 * bus */
+ * maximum values).
+ */
+struct vhba_config_max {/* 20 bytes */
+	u32 max_channel;/* maximum channel for devices attached to this bus */
+	u32 max_id;	/* maximum SCSI ID for devices attached to bus */
+	u32 max_lun;	/* maximum SCSI LUN for devices attached to bus */
+	u32 cmd_per_lun;/* maximum number of outstanding commands per LUN */
+	u32 max_io_size;/* maximum io size for devices attached to this bus */
 	/* max io size is often determined by the resource of the hba. e.g */
 	/* max scatter gather list length * page size / sector size */
 } __packed;
 
 struct uiscmdrsp_scsi {
-	u64 handle;		/* the handle to the cmd that was received -
-				 * send it back as is in the rsp packet.  */
+	u64 handle;		/* the handle to the cmd that was received */
+				/* send it back as is in the rsp packet.  */
 	u8 cmnd[MAX_CMND_SIZE];	/* the cdb for the command */
 	u32 bufflen;		/* length of data to be transferred out or in */
-	u16 guest_phys_entries;	/* Number of entries in scatter-gather (sg)
-				 * list */
+	u16 guest_phys_entries;	/* Number of entries in scatter-gather list */
 	struct guest_phys_info gpi_list[MAX_PHYS_INFO];	/* physical address
 							 * information for each
-							 * fragment */
+							 * fragment
+							 */
 	enum dma_data_direction  data_dir; /* direction of the data, if any */
-	struct uisscsi_dest vdest;	/* identifies the virtual hba, id,
-					 * channel, lun to which cmd was sent */
+	struct uisscsi_dest vdest;	/* identifies the virtual hba, id, */
+					/* channel, lun to which cmd was sent */
 
-	    /* the following fields are needed to queue the rsp back to cmd
-	     * originator */
-	int linuxstat;		/* the original Linux status - for use by linux
-				 * vdisk code */
+	/* Needed to queue the rsp back to cmd originator */
+	int linuxstat;		/* original Linux status used by linux vdisk */
 	u8 scsistat;		/* the scsi status */
-	u8 addlstat;		/* non-scsi status - covers cases like timeout
-				 * needed by windows guests */
+	u8 addlstat;		/* non-scsi status */
 #define ADDL_SEL_TIMEOUT	4
 
 	/* the following fields are need to determine the result of command */
 	 u8 sensebuf[MAX_SENSE_SIZE];	/* sense info in case cmd failed; */
 	/* it holds the sense_data struct; */
 	/* see that struct for details. */
-	void *vdisk; /* contains pointer to the vdisk so that we can clean up
-		      * when the IO completes. */
+	void *vdisk; /* pointer to the vdisk to clean up when IO completes. */
 	int no_disk_result;
 	/* used to return no disk inquiry result
 	 * when no_disk_result is set to 1,
@@ -258,15 +248,15 @@ struct uiscmdrsp_scsi {
  */
 #define NO_DISK_INQUIRY_RESULT_LEN 36
 
-#define MIN_INQUIRY_RESULT_LEN 5 /* we need at least 5 bytes minimum for inquiry
-				  * result */
+#define MIN_INQUIRY_RESULT_LEN 5 /* 5 bytes minimum for inquiry result */
 
 /* SCSI device version for no disk inquiry result */
 #define SCSI_SPC2_VER 4		/* indicates SCSI SPC2 (SPC3 is 5) */
 
 /* Windows and Linux want different things for a non-existent lun. So, we'll let
  * caller pass in the peripheral qualifier and type.
- * NOTE:[4] SCSI returns (n-4); so we return length-1-4 or length-5. */
+ * NOTE:[4] SCSI returns (n-4); so we return length-1-4 or length-5.
+ */
 
 #define SET_NO_DISK_INQUIRY_RESULT(buf, len, lun, lun0notpresent, notpresent) \
 	do {								\
@@ -305,9 +295,7 @@ struct uiscmdrsp_scsi {
 		}							\
 	} while (0)
 
-/*
- * Struct & Defines to support sense information.
- */
+/* Struct & Defines to support sense information. */
 
 /* The following struct is returned in sensebuf field in uiscmdrsp_scsi.  It is
  * initialized in exactly the manner that is recommended in Windows (hence the
@@ -342,13 +330,11 @@ struct sense_data {
 struct net_pkt_xmt {
 	int len;	/* full length of data in the packet */
 	int num_frags;	/* number of fragments in frags containing data */
-	struct phys_info frags[MAX_PHYS_INFO];	/* physical page information for
-						 * each fragment */
+	struct phys_info frags[MAX_PHYS_INFO];	/* physical page information */
 	char ethhdr[ETH_HEADER_SIZE];	/* the ethernet header  */
 	struct {
-		    /* these are needed for csum at uisnic end */
-		u8 valid;	/* 1 = rest of this struct is valid - else
-				 * ignore */
+		/* these are needed for csum at uisnic end */
+		u8 valid;	/* 1 = struct is valid - else ignore */
 		u8 hrawoffv;	/* 1 = hwrafoff is valid */
 		u8 nhrawoffv;	/* 1 = nhwrafoff is valid */
 		u16 protocol;	/* specifies packet protocol */
@@ -385,11 +371,12 @@ struct net_pkt_xmtdone {
 struct net_pkt_rcvpost {
 	    /* rcv buf size must be large enough to include ethernet data len +
 	     * ethernet header len - we are choosing 2K because it is guaranteed
-	     * to be describable */
-	    struct phys_info frag;	/* physical page information for the
-					 * single fragment 2K rcv buf */
-	    u64 unique_num;		/* This is used to make sure that
-					 * receive posts are returned to  */
+	     * to be describable
+	     */
+	    struct phys_info frag;	/* physical page information for the */
+					/* single fragment 2K rcv buf */
+	    u64 unique_num;
+	    /* unique_num ensure that receive posts are returned to */
 	    /* the Adapter which we sent them originally. */
 } __packed;
 
@@ -399,8 +386,7 @@ struct net_pkt_rcv {
 	u32 rcv_done_len;	/* length of received data */
 	u8 numrcvbufs;		/* number of receive buffers that contain the */
 	/* incoming data; guest end MUST chain these together. */
-	void *rcvbuf[MAX_NET_RCV_CHAIN];	/* the list of receive buffers
-						 * that must be chained; */
+	void *rcvbuf[MAX_NET_RCV_CHAIN];	/* list of chained rcvbufs */
 	/* each entry is a receive buffer provided by NET_RCV_POST. */
 	/* NOTE: first rcvbuf in the chain will also be provided in net.buf. */
 	u64 unique_num;
@@ -469,18 +455,17 @@ struct uiscmdrsp_scsitaskmgmt {
 #define TASK_MGMT_FAILED  0
 } __packed;
 
-/* The following is used by uissd to send disk add/remove notifications to
- * Guest */
+/* Used by uissd to send disk add/remove notifications to Guest */
 /* Note that the vHba pointer is not used by the Client/Guest side. */
 struct uiscmdrsp_disknotify {
 	u8 add;			/* 0-remove, 1-add */
-	void *v_hba;		/* Pointer to vhba_info for channel info to
-				 * route msg */
+	void *v_hba;		/* channel info to route msg */
 	u32 channel, id, lun;	/* SCSI Path of Disk to added or removed */
 } __packed;
 
 /* The following is used by virthba/vSCSI to send the Acquire/Release commands
- * to the IOVM. */
+ * to the IOVM.
+ */
 struct uiscmdrsp_vdiskmgmt {
 	enum vdisk_mgmt_types vdisktype;
 
@@ -533,8 +518,8 @@ struct uiscmdrsp {
 		struct uiscmdrsp_disknotify disknotify;
 		struct uiscmdrsp_vdiskmgmt vdiskmgmt;
 	};
-	void *private_data;	/* used to send the response when the cmd is
-				 * done (scsi & scsittaskmgmt). */
+	void *private_data;	/* send the response when the cmd is */
+				/* done (scsi & scsittaskmgmt). */
 	struct uiscmdrsp *next;	/* General Purpose Queue Link */
 	struct uiscmdrsp *activeQ_next;	/* Used to track active commands */
 	struct uiscmdrsp *activeQ_prev;	/* Used to track active commands */
@@ -564,15 +549,11 @@ struct spar_io_channel_protocol {
 	} __packed;
 
 #define MAX_CLIENTSTRING_LEN 1024
-	 u8 client_string[MAX_CLIENTSTRING_LEN];/* NULL terminated - so holds
-						 * max - 1 bytes */
+	/* client_string is NULL termimated so holds max -1 bytes */
+	 u8 client_string[MAX_CLIENTSTRING_LEN];
 } __packed;
 
-
-/*
- * INLINE functions for initializing and accessing I/O data channels
- */
-
+/* INLINE functions for initializing and accessing I/O data channels */
 #define SIZEOF_PROTOCOL (COVER(sizeof(struct spar_io_channel_protocol), 64))
 #define SIZEOF_CMDRSP (COVER(sizeof(struct uiscmdrsp), 64))
 

commit d2c3506be646a495a4e3f1d1ce9540916703c244
Author: David Kershner <david.kershner@unisys.com>
Date:   Thu Sep 24 11:00:40 2015 -0400

    staging: unisys: Add s-Par visorhba
    
    This driver create a host bus adapter device when s-Par sends a
    device create message to create a storage adapter on the visorbus.
    When the message is received by visorbus, the visorhba_probe function
    is called and the hba device is created and managed by the visorhba
    driver.
    
    Signed-off-by: Erik Arfvidson <erik.arfvidson@unisys.com>
    Signed-off-by: Benjamin Romer <benjamin.romer@unisys.com>
    Signed-off-by: David Kershner <david.kershner@unisys.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/unisys/include/iochannel.h b/drivers/staging/unisys/include/iochannel.h
index a559812342dc..14e656ff73ec 100644
--- a/drivers/staging/unisys/include/iochannel.h
+++ b/drivers/staging/unisys/include/iochannel.h
@@ -147,6 +147,10 @@ struct phys_info {
 	u16 pi_len;
 } __packed;
 
+#define MIN_NUMSIGNALS 64
+
+/* structs with pragma pack  */
+
 struct guest_phys_info {
 	u64 address;
 	u64 length;
@@ -183,7 +187,7 @@ struct vhba_config_max {	/* 20 bytes */
 } __packed;
 
 struct uiscmdrsp_scsi {
-	void *scsicmd;		/* the handle to the cmd that was received -
+	u64 handle;		/* the handle to the cmd that was received -
 				 * send it back as is in the rsp packet.  */
 	u8 cmnd[MAX_CMND_SIZE];	/* the cdb for the command */
 	u32 bufflen;		/* length of data to be transferred out or in */
@@ -437,24 +441,22 @@ struct uiscmdrsp_scsitaskmgmt {
 	struct uisscsi_dest vdest;
 
 	    /* the vdisk for which this task mgmt is generated */
-	void *scsicmd;
+	u64 handle;
 
-	    /* This is some handle that the guest has saved off for its own use.
+	    /* This is a handle that the guest has saved off for its own use.
 	     * Its value is preserved by iopart & returned as is in the task
 	     * mgmt rsp.
 	     */
-	void *notify;
+	u64 notify_handle;
 
 	   /* For linux guests, this is a pointer to wait_queue_head that a
 	    * thread is waiting on to see if the taskmgmt command has completed.
-	    * For windows guests, this is a pointer to a location that a waiting
-	    * thread is testing to see if the taskmgmt command has completed.
 	    * When the rsp is received by guest, the thread receiving the
 	    * response uses this to notify the thread waiting for taskmgmt
 	    * command completion.  Its value is preserved by iopart & returned
 	    * as is in the task mgmt rsp.
 	    */
-	void *notifyresult;
+	u64 notifyresult_handle;
 
 	    /* this is a handle to location in guest where the result of the
 	     * taskmgmt command (result field) is to saved off when the response
@@ -486,24 +488,22 @@ struct uiscmdrsp_vdiskmgmt {
 	struct uisscsi_dest vdest;
 
 	    /* the vdisk for which this task mgmt is generated */
-	void *scsicmd;
+	u64 handle;
 
-	    /* This is some handle that the guest has saved off for its own use.
+	    /* This is a handle that the guest has saved off for its own use.
 	     * Its value is preserved by iopart & returned as is in the task
 	     * mgmt rsp.
 	     */
-	void *notify;
+	u64 notify_handle;
 
 	    /* For linux guests, this is a pointer to wait_queue_head that a
 	     * thread is waiting on to see if the tskmgmt command has completed.
-	     * For win32 guests, this is a pointer to a location that a waiting
-	     * thread is testing to see if the taskmgmt command has completed.
 	     * When the rsp is received by guest, the thread receiving the
 	     * response uses this to notify the thread waiting for taskmgmt
 	     * command completion.  Its value is preserved by iopart & returned
 	     * as is in the task mgmt rsp.
 	     */
-	void *notifyresult;
+	u64 notifyresult_handle;
 
 	    /* this is a handle to location in guest where the result of the
 	     * taskmgmt command (result field) is to saved off when the response

commit dbb9d619941ad57dbe3c6667764e1eccd5ee5f1b
Author: David Kershner <david.kershner@unisys.com>
Date:   Mon Jun 15 23:31:58 2015 -0400

    staging: unisys: define structures outside of iochannel
    
    During testing with visornic the offset of num_rcv_bufs
    was being reported at 188 instead of 186. The vnic structure
    starts at 180 and the macaddr is only 6 bytes long.
    
    When I defined and packed the structures outside of the struct
    and then referenced them in the struct the correct offset
    was generated.
    
    Signed-off-by: David Kershner <david.kershner@unisys.com>
    Signed-off-by: Benjamin Romer <benjamin.romer@unisys.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/unisys/include/iochannel.h b/drivers/staging/unisys/include/iochannel.h
index 64a581a4b4e4..a559812342dc 100644
--- a/drivers/staging/unisys/include/iochannel.h
+++ b/drivers/staging/unisys/include/iochannel.h
@@ -540,6 +540,16 @@ struct uiscmdrsp {
 	struct uiscmdrsp *activeQ_prev;	/* Used to track active commands */
 } __packed;
 
+struct iochannel_vhba {
+	struct vhba_wwnn wwnn;		/* 8 bytes */
+	struct vhba_config_max max;	/* 20 bytes */
+} __packed;				/* total = 28 bytes */
+struct iochannel_vnic {
+	u8 macaddr[6];			/* 6 bytes */
+	u32 num_rcv_bufs;		/* 4 bytes */
+	u32 mtu;			/* 4 bytes */
+	uuid_le zone_uuid;		/* 16 bytes */
+} __packed;
 /* This is just the header of the IO channel.  It is assumed that directly after
  * this header there is a large region of memory which contains the command and
  * response queues as specified in cmd_q and rsp_q SIGNAL_QUEUE_HEADERS.
@@ -549,17 +559,9 @@ struct spar_io_channel_protocol {
 	struct signal_queue_header cmd_q;
 	struct signal_queue_header rsp_q;
 	union {
-		struct {
-			struct vhba_wwnn wwnn;		/* 8 bytes */
-			struct vhba_config_max max;	/* 20 bytes */
-		} vhba;					/* total = 28 bytes */
-		struct {
-			u8 macaddr[MAX_MACADDR_LEN];	/* 6 bytes */
-			u32 num_rcv_bufs;		/* 4 bytes */
-			u32 mtu;			/* 4 bytes */
-			uuid_le zone_uuid;		/* 16 bytes */
-		} vnic;					/* total = 30 bytes */
-	};
+		struct iochannel_vhba vhba;
+		struct iochannel_vnic vnic;
+	} __packed;
 
 #define MAX_CLIENTSTRING_LEN 1024
 	 u8 client_string[MAX_CLIENTSTRING_LEN];/* NULL terminated - so holds

commit 2c13087194700b16aada1a9112fad5b3861ac9fb
Author: David Kershner <david.kershner@unisys.com>
Date:   Fri Jun 12 23:12:35 2015 -0400

    staging: unisys: cleanup iochannel includes
    
    The iochannel.h file no longer needs to include
    conttrolvmchannel.h, vbuschannel.h and vmcallinterfaces.h.
    
    Signed-off-by: David Kershner <david.kershner@unisys.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/unisys/include/iochannel.h b/drivers/staging/unisys/include/iochannel.h
index 538036d378fb..64a581a4b4e4 100644
--- a/drivers/staging/unisys/include/iochannel.h
+++ b/drivers/staging/unisys/include/iochannel.h
@@ -30,13 +30,7 @@
 
 #include <linux/uuid.h>
 
-#include "vmcallinterface.h"
-
-#define _ULTRA_CONTROLVM_CHANNEL_INLINE_
 #include <linux/dma-direction.h>
-#include "controlvmchannel.h"
-#include "vbuschannel.h"
-#undef _ULTRA_CONTROLVM_CHANNEL_INLINE_
 #include "channel.h"
 #include "channel_guid.h"
 

commit 5e54654c41bfb9216b551fd3a3891c2da60eadae
Author: David Kershner <david.kershner@unisys.com>
Date:   Fri Jun 12 16:46:07 2015 -0400

    staging: unisys: convert pack pragma to __packed
    
    It was noticed that iochannel.h was still using pragmas to
    pack the datastructures, should be using __packed instead.
    
    Signed-off-by: David Kershner <david.kershner@unisys.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/unisys/include/iochannel.h b/drivers/staging/unisys/include/iochannel.h
index ee28cdc1c703..538036d378fb 100644
--- a/drivers/staging/unisys/include/iochannel.h
+++ b/drivers/staging/unisys/include/iochannel.h
@@ -147,23 +147,16 @@ enum vdisk_mgmt_types {
 	VDISK_MGMT_RELEASE,
 };
 
-/* structs with pragma pack  */
-
 struct phys_info {
 	u64 pi_pfn;
 	u16 pi_off;
 	u16 pi_len;
 } __packed;
 
-/* ///////////// BEGIN PRAGMA PACK PUSH 1 ///////////////////////// */
-/* ///////////// ONLY STRUCT TYPE SHOULD BE BELOW */
-
-#pragma pack(push, 1)
-
 struct guest_phys_info {
 	u64 address;
 	u64 length;
-};
+} __packed;
 
 #define GPI_ENTRIES_PER_PAGE (PAGE_SIZE / sizeof(struct guest_phys_info))
 
@@ -171,12 +164,12 @@ struct uisscsi_dest {
 	u32 channel;		/* channel == bus number */
 	u32 id;			/* id == target number */
 	u32 lun;		/* lun == logical unit number */
-};
+} __packed;
 
 struct vhba_wwnn {
 	u32 wwnn1;
 	u32 wwnn2;
-};
+} __packed;
 
 /* WARNING: Values stired in this structure must contain maximum counts (not
  * maximum values). */
@@ -193,7 +186,7 @@ struct vhba_config_max {	/* 20 bytes */
 				 * bus */
 	/* max io size is often determined by the resource of the hba. e.g */
 	/* max scatter gather list length * page size / sector size */
-};
+} __packed;
 
 struct uiscmdrsp_scsi {
 	void *scsicmd;		/* the handle to the cmd that was received -
@@ -232,7 +225,7 @@ struct uiscmdrsp_scsi {
 	 * scsi.linuxstat is SAM_STAT_GOOD
 	 * That is, there is NO error.
 	 */
-};
+} __packed;
 
 /* Defines to support sending correct inquiry result when no disk is
  * configured.
@@ -346,7 +339,7 @@ struct sense_data {
 	u8 additional_sense_code_qualifier;
 	u8 fru_code;
 	u8 sense_key_specific[3];
-};
+} __packed;
 
 struct net_pkt_xmt {
 	int len;	/* full length of data in the packet */
@@ -374,11 +367,11 @@ struct net_pkt_xmt {
 	     * guest memory to get to the header. uisnic needs ethhdr to
 	     * determine how to route the packet.
 	     */
-};
+} __packed;
 
 struct net_pkt_xmtdone {
 	u32 xmt_done_result;	/* result of NET_XMIT */
-};
+} __packed;
 
 /* RCVPOST_BUF_SIZe must be at most page_size(4096) - cache_line_size (64) The
  * reason is because dev_skb_alloc which is used to generate RCV_POST skbs in
@@ -400,7 +393,7 @@ struct net_pkt_rcvpost {
 	    u64 unique_num;		/* This is used to make sure that
 					 * receive posts are returned to  */
 	    /* the Adapter which we sent them originally. */
-};
+} __packed;
 
 struct net_pkt_rcv {
 	/* the number of receive buffers that can be chained  */
@@ -414,17 +407,17 @@ struct net_pkt_rcv {
 	/* NOTE: first rcvbuf in the chain will also be provided in net.buf. */
 	u64 unique_num;
 	u32 rcvs_dropped_delta;
-};
+} __packed;
 
 struct net_pkt_enbdis {
 	void *context;
 	u16 enable;		/* 1 = enable, 0 = disable */
-};
+} __packed;
 
 struct net_pkt_macaddr {
 	void *context;
 	u8 macaddr[MAX_MACADDR_LEN];	/* 6 bytes */
-};
+} __packed;
 
 /* cmd rsp packet used for VNIC network traffic  */
 struct uiscmdrsp_net {
@@ -441,7 +434,7 @@ struct uiscmdrsp_net {
 						/* and NET_CONNECT_STATUS */
 		struct net_pkt_macaddr macaddr;
 	};
-};
+} __packed;
 
 struct uiscmdrsp_scsitaskmgmt {
 	enum task_mgmt_types tasktype;
@@ -478,7 +471,7 @@ struct uiscmdrsp_scsitaskmgmt {
 
 	    /* result of taskmgmt command - set by IOPart - values are: */
 #define TASK_MGMT_FAILED  0
-};
+} __packed;
 
 /* The following is used by uissd to send disk add/remove notifications to
  * Guest */
@@ -488,7 +481,7 @@ struct uiscmdrsp_disknotify {
 	void *v_hba;		/* Pointer to vhba_info for channel info to
 				 * route msg */
 	u32 channel, id, lun;	/* SCSI Path of Disk to added or removed */
-};
+} __packed;
 
 /* The following is used by virthba/vSCSI to send the Acquire/Release commands
  * to the IOVM. */
@@ -527,7 +520,7 @@ struct uiscmdrsp_vdiskmgmt {
 
 	    /* result of taskmgmt command - set by IOPart - values are: */
 #define VDISK_MGMT_FAILED  0
-};
+} __packed;
 
 /* keeping cmd & rsp info in one structure for now cmd rsp packet for scsi */
 struct uiscmdrsp {
@@ -551,7 +544,7 @@ struct uiscmdrsp {
 	struct uiscmdrsp *next;	/* General Purpose Queue Link */
 	struct uiscmdrsp *activeQ_next;	/* Used to track active commands */
 	struct uiscmdrsp *activeQ_prev;	/* Used to track active commands */
-};
+} __packed;
 
 /* This is just the header of the IO channel.  It is assumed that directly after
  * this header there is a large region of memory which contains the command and
@@ -577,10 +570,8 @@ struct spar_io_channel_protocol {
 #define MAX_CLIENTSTRING_LEN 1024
 	 u8 client_string[MAX_CLIENTSTRING_LEN];/* NULL terminated - so holds
 						 * max - 1 bytes */
-};
+} __packed;
 
-#pragma pack(pop)
-/* ///////////// END PRAGMA PACK PUSH 1 /////////////////////////// */
 
 /*
  * INLINE functions for initializing and accessing I/O data channels

commit c20a99f8c38f41ce875bfea829ca0dd603f1d11b
Author: David Kershner <david.kershner@unisys.com>
Date:   Fri Jun 12 16:46:06 2015 -0400

    staging: unisys: Move phys_info to iochannel.h
    
    This moves phys_info to iochannel.h. It is only
    used by iochannel.h and is not needed in
    vmcallinterfaces.h.
    
    Signed-off-by: David Kershner <david.kershner@unisys.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/unisys/include/iochannel.h b/drivers/staging/unisys/include/iochannel.h
index cbb58757e76a..ee28cdc1c703 100644
--- a/drivers/staging/unisys/include/iochannel.h
+++ b/drivers/staging/unisys/include/iochannel.h
@@ -149,6 +149,12 @@ enum vdisk_mgmt_types {
 
 /* structs with pragma pack  */
 
+struct phys_info {
+	u64 pi_pfn;
+	u16 pi_off;
+	u16 pi_len;
+} __packed;
+
 /* ///////////// BEGIN PRAGMA PACK PUSH 1 ///////////////////////// */
 /* ///////////// ONLY STRUCT TYPE SHOULD BE BELOW */
 

commit a2713631515c2be2d43595ac20e8944b298b1801
Author: David Kershner <david.kershner@unisys.com>
Date:   Wed May 13 13:22:07 2015 -0400

    staging: unisys: Move files out of common-spar
    
    Move last three files out of common-spar
    
    iochannel.h --> include (will be used by visorhba and visornic)
    version.h --> moved to include
    controlvmcompletionstatus.h --> moved to visorbus, part of
                    controlvmchannel.h
    
    Signed-off-by: David Kershner <david.kershner@unisys.com>
    Signed-off-by: Benjamin Romer <benjamin.romer@unisys.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/unisys/include/iochannel.h b/drivers/staging/unisys/include/iochannel.h
new file mode 100644
index 000000000000..cbb58757e76a
--- /dev/null
+++ b/drivers/staging/unisys/include/iochannel.h
@@ -0,0 +1,651 @@
+/* Copyright (C) 2010 - 2013 UNISYS CORPORATION */
+/* All rights reserved. */
+#ifndef __IOCHANNEL_H__
+#define __IOCHANNEL_H__
+
+/*
+ * Everything needed for IOPart-GuestPart communication is define in
+ * this file.  Note: Everything is OS-independent because this file is
+ * used by Windows, Linux and possible EFI drivers.  */
+
+/*
+ * Communication flow between the IOPart and GuestPart uses the channel headers
+ * channel state.  The following states are currently being used:
+ *       UNINIT(All Zeroes), CHANNEL_ATTACHING, CHANNEL_ATTACHED, CHANNEL_OPENED
+ *
+ * additional states will be used later.  No locking is needed to switch between
+ * states due to the following rules:
+ *
+ *      1.  IOPart is only the only partition allowed to change from UNIT
+ *      2.  IOPart is only the only partition allowed to change from
+ *		CHANNEL_ATTACHING
+ *      3.  GuestPart is only the only partition allowed to change from
+ *		CHANNEL_ATTACHED
+ *
+ * The state changes are the following: IOPart sees the channel is in UNINIT,
+ *        UNINIT -> CHANNEL_ATTACHING (performed only by IOPart)
+ *        CHANNEL_ATTACHING -> CHANNEL_ATTACHED (performed only by IOPart)
+ *        CHANNEL_ATTACHED -> CHANNEL_OPENED (performed only by GuestPart)
+ */
+
+#include <linux/uuid.h>
+
+#include "vmcallinterface.h"
+
+#define _ULTRA_CONTROLVM_CHANNEL_INLINE_
+#include <linux/dma-direction.h>
+#include "controlvmchannel.h"
+#include "vbuschannel.h"
+#undef _ULTRA_CONTROLVM_CHANNEL_INLINE_
+#include "channel.h"
+#include "channel_guid.h"
+
+#define ULTRA_VHBA_CHANNEL_PROTOCOL_SIGNATURE ULTRA_CHANNEL_PROTOCOL_SIGNATURE
+#define ULTRA_VNIC_CHANNEL_PROTOCOL_SIGNATURE ULTRA_CHANNEL_PROTOCOL_SIGNATURE
+#define ULTRA_VSWITCH_CHANNEL_PROTOCOL_SIGNATURE \
+	ULTRA_CHANNEL_PROTOCOL_SIGNATURE
+
+/* Must increment these whenever you insert or delete fields within this channel
+ * struct.  Also increment whenever you change the meaning of fields within this
+ * channel struct so as to break pre-existing software.  Note that you can
+ * usually add fields to the END of the channel struct withOUT needing to
+ * increment this.
+ */
+#define ULTRA_VHBA_CHANNEL_PROTOCOL_VERSIONID 2
+#define ULTRA_VNIC_CHANNEL_PROTOCOL_VERSIONID 2
+#define ULTRA_VSWITCH_CHANNEL_PROTOCOL_VERSIONID 1
+
+#define SPAR_VHBA_CHANNEL_OK_CLIENT(ch)			\
+	(spar_check_channel_client(ch, spar_vhba_channel_protocol_uuid, \
+				   "vhba", MIN_IO_CHANNEL_SIZE,	\
+				   ULTRA_VHBA_CHANNEL_PROTOCOL_VERSIONID, \
+				   ULTRA_VHBA_CHANNEL_PROTOCOL_SIGNATURE))
+
+#define SPAR_VNIC_CHANNEL_OK_CLIENT(ch)			\
+	(spar_check_channel_client(ch, spar_vnic_channel_protocol_uuid, \
+				   "vnic", MIN_IO_CHANNEL_SIZE,	\
+				   ULTRA_VNIC_CHANNEL_PROTOCOL_VERSIONID, \
+				   ULTRA_VNIC_CHANNEL_PROTOCOL_SIGNATURE))
+
+/*
+ * Everything necessary to handle SCSI & NIC traffic between Guest Partition and
+ * IO Partition is defined below.
+ */
+
+/*
+ * Defines and enums.
+ */
+
+#define MINNUM(a, b) (((a) < (b)) ? (a) : (b))
+#define MAXNUM(a, b) (((a) > (b)) ? (a) : (b))
+
+/* these define the two queues per data channel between iopart and
+ * ioguestparts
+ */
+#define IOCHAN_TO_IOPART 0 /* used by ioguestpart to 'insert' signals to
+			    * iopart */
+
+#define IOCHAN_FROM_IOPART 1 /* used by ioguestpart to 'remove' signals from
+			      * iopart - same queue as previous queue */
+
+/* size of cdb - i.e., scsi cmnd */
+#define MAX_CMND_SIZE 16
+
+#define MAX_SENSE_SIZE 64
+
+#define MAX_PHYS_INFO 64
+
+/* various types of network packets that can be sent in cmdrsp */
+enum net_types {
+	NET_RCV_POST = 0,	/* submit buffer to hold receiving
+				 * incoming packet */
+	/* virtnic -> uisnic */
+	NET_RCV,		/* incoming packet received */
+	/* uisnic -> virtpci */
+	NET_XMIT,		/* for outgoing net packets      */
+	/* virtnic -> uisnic */
+	NET_XMIT_DONE,		/* outgoing packet xmitted */
+	/* uisnic -> virtpci */
+	NET_RCV_ENBDIS,		/* enable/disable packet reception */
+	/* virtnic -> uisnic */
+	NET_RCV_ENBDIS_ACK,	/* acknowledge enable/disable packet
+				 * reception */
+	/* uisnic -> virtnic */
+	NET_RCV_PROMISC,	/* enable/disable promiscuous mode */
+	/* virtnic -> uisnic */
+	NET_CONNECT_STATUS,	/* indicate the loss or restoration of a network
+				 * connection */
+	/* uisnic -> virtnic */
+	NET_MACADDR,		/* indicates the client has requested to update
+				 * its MAC addr */
+	NET_MACADDR_ACK,	/* MAC address */
+
+};
+
+#define		ETH_HEADER_SIZE 14	/* size of ethernet header */
+
+#define		ETH_MIN_DATA_SIZE 46	/* minimum eth data size */
+#define		ETH_MIN_PACKET_SIZE (ETH_HEADER_SIZE + ETH_MIN_DATA_SIZE)
+
+#define		ETH_MAX_MTU 16384	/* maximum data size */
+
+#ifndef MAX_MACADDR_LEN
+#define MAX_MACADDR_LEN 6	/* number of bytes in MAC address */
+#endif				/* MAX_MACADDR_LEN */
+
+/* various types of scsi task mgmt commands  */
+enum task_mgmt_types {
+	TASK_MGMT_ABORT_TASK = 1,
+	TASK_MGMT_BUS_RESET,
+	TASK_MGMT_LUN_RESET,
+	TASK_MGMT_TARGET_RESET,
+};
+
+/* various types of vdisk mgmt commands  */
+enum vdisk_mgmt_types {
+	VDISK_MGMT_ACQUIRE = 1,
+	VDISK_MGMT_RELEASE,
+};
+
+/* structs with pragma pack  */
+
+/* ///////////// BEGIN PRAGMA PACK PUSH 1 ///////////////////////// */
+/* ///////////// ONLY STRUCT TYPE SHOULD BE BELOW */
+
+#pragma pack(push, 1)
+
+struct guest_phys_info {
+	u64 address;
+	u64 length;
+};
+
+#define GPI_ENTRIES_PER_PAGE (PAGE_SIZE / sizeof(struct guest_phys_info))
+
+struct uisscsi_dest {
+	u32 channel;		/* channel == bus number */
+	u32 id;			/* id == target number */
+	u32 lun;		/* lun == logical unit number */
+};
+
+struct vhba_wwnn {
+	u32 wwnn1;
+	u32 wwnn2;
+};
+
+/* WARNING: Values stired in this structure must contain maximum counts (not
+ * maximum values). */
+struct vhba_config_max {	/* 20 bytes */
+	u32 max_channel;	/* maximum channel for devices attached to this
+				 * bus */
+	u32 max_id;		/* maximum SCSI ID for devices attached to this
+				 * bus */
+	u32 max_lun;		/* maximum SCSI LUN for devices attached to this
+				 * bus */
+	u32 cmd_per_lun;	/* maximum number of outstanding commands per
+				 * lun that are allowed at one time */
+	u32 max_io_size;	/* maximum io size for devices attached to this
+				 * bus */
+	/* max io size is often determined by the resource of the hba. e.g */
+	/* max scatter gather list length * page size / sector size */
+};
+
+struct uiscmdrsp_scsi {
+	void *scsicmd;		/* the handle to the cmd that was received -
+				 * send it back as is in the rsp packet.  */
+	u8 cmnd[MAX_CMND_SIZE];	/* the cdb for the command */
+	u32 bufflen;		/* length of data to be transferred out or in */
+	u16 guest_phys_entries;	/* Number of entries in scatter-gather (sg)
+				 * list */
+	struct guest_phys_info gpi_list[MAX_PHYS_INFO];	/* physical address
+							 * information for each
+							 * fragment */
+	enum dma_data_direction  data_dir; /* direction of the data, if any */
+	struct uisscsi_dest vdest;	/* identifies the virtual hba, id,
+					 * channel, lun to which cmd was sent */
+
+	    /* the following fields are needed to queue the rsp back to cmd
+	     * originator */
+	int linuxstat;		/* the original Linux status - for use by linux
+				 * vdisk code */
+	u8 scsistat;		/* the scsi status */
+	u8 addlstat;		/* non-scsi status - covers cases like timeout
+				 * needed by windows guests */
+#define ADDL_SEL_TIMEOUT	4
+
+	/* the following fields are need to determine the result of command */
+	 u8 sensebuf[MAX_SENSE_SIZE];	/* sense info in case cmd failed; */
+	/* it holds the sense_data struct; */
+	/* see that struct for details. */
+	void *vdisk; /* contains pointer to the vdisk so that we can clean up
+		      * when the IO completes. */
+	int no_disk_result;
+	/* used to return no disk inquiry result
+	 * when no_disk_result is set to 1,
+	 * scsi.scsistat is SAM_STAT_GOOD
+	 * scsi.addlstat is 0
+	 * scsi.linuxstat is SAM_STAT_GOOD
+	 * That is, there is NO error.
+	 */
+};
+
+/* Defines to support sending correct inquiry result when no disk is
+ * configured.
+ */
+
+/* From SCSI SPC2 -
+ *
+ * If the target is not capable of supporting a device on this logical unit, the
+ * device server shall set this field to 7Fh (PERIPHERAL QUALIFIER set to 011b
+ * and PERIPHERAL DEVICE TYPE set to 1Fh).
+ *
+ *The device server is capable of supporting the specified peripheral device
+ *type on this logical unit. However, the physical device is not currently
+ *connected to this logical unit.
+ */
+
+#define DEV_NOT_CAPABLE 0x7f	/* peripheral qualifier of 0x3  */
+				/* peripheral type of 0x1f */
+				/* specifies no device but target present */
+
+#define DEV_DISK_CAPABLE_NOT_PRESENT 0x20 /* peripheral qualifier of 0x1 */
+    /* peripheral type of 0 - disk */
+    /* specifies device capable, but not present */
+
+#define DEV_HISUPPORT 0x10	/* HiSup = 1; shows support for report luns */
+				/* must be returned for lun 0. */
+
+/* NOTE: Linux code assumes inquiry contains 36 bytes. Without checking length
+ * in buf[4] some linux code accesses bytes beyond 5 to retrieve vendor, product
+ * & revision.  Yikes! So let us always send back 36 bytes, the minimum for
+ * inquiry result.
+ */
+#define NO_DISK_INQUIRY_RESULT_LEN 36
+
+#define MIN_INQUIRY_RESULT_LEN 5 /* we need at least 5 bytes minimum for inquiry
+				  * result */
+
+/* SCSI device version for no disk inquiry result */
+#define SCSI_SPC2_VER 4		/* indicates SCSI SPC2 (SPC3 is 5) */
+
+/* Windows and Linux want different things for a non-existent lun. So, we'll let
+ * caller pass in the peripheral qualifier and type.
+ * NOTE:[4] SCSI returns (n-4); so we return length-1-4 or length-5. */
+
+#define SET_NO_DISK_INQUIRY_RESULT(buf, len, lun, lun0notpresent, notpresent) \
+	do {								\
+		memset(buf, 0,						\
+		       MINNUM(len,					\
+			      (unsigned int)NO_DISK_INQUIRY_RESULT_LEN)); \
+		buf[2] = (u8)SCSI_SPC2_VER;				\
+		if (lun == 0) {						\
+			buf[0] = (u8)lun0notpresent;			\
+			buf[3] = (u8)DEV_HISUPPORT;			\
+		} else							\
+			buf[0] = (u8)notpresent;			\
+		buf[4] = (u8)(						\
+			MINNUM(len,					\
+			       (unsigned int)NO_DISK_INQUIRY_RESULT_LEN) - 5);\
+		if (len >= NO_DISK_INQUIRY_RESULT_LEN) {		\
+			buf[8] = 'D';					\
+			buf[9] = 'E';					\
+			buf[10] = 'L';					\
+			buf[11] = 'L';					\
+			buf[16] = 'P';					\
+			buf[17] = 'S';					\
+			buf[18] = 'E';					\
+			buf[19] = 'U';					\
+			buf[20] = 'D';					\
+			buf[21] = 'O';					\
+			buf[22] = ' ';					\
+			buf[23] = 'D';					\
+			buf[24] = 'E';					\
+			buf[25] = 'V';					\
+			buf[26] = 'I';					\
+			buf[27] = 'C';					\
+			buf[28] = 'E';					\
+			buf[30] = ' ';					\
+			buf[31] = '.';					\
+		}							\
+	} while (0)
+
+/*
+ * Struct & Defines to support sense information.
+ */
+
+/* The following struct is returned in sensebuf field in uiscmdrsp_scsi.  It is
+ * initialized in exactly the manner that is recommended in Windows (hence the
+ * odd values).
+ * When set, these fields will have the following values:
+ * ErrorCode = 0x70		indicates current error
+ * Valid = 1			indicates sense info is valid
+ * SenseKey			contains sense key as defined by SCSI specs.
+ * AdditionalSenseCode		contains sense key as defined by SCSI specs.
+ * AdditionalSenseCodeQualifier	contains qualifier to sense code as defined by
+ *				scsi docs.
+ * AdditionalSenseLength	contains will be sizeof(sense_data)-8=10.
+ */
+struct sense_data {
+	u8 errorcode:7;
+	u8 valid:1;
+	u8 segment_number;
+	u8 sense_key:4;
+	u8 reserved:1;
+	u8 incorrect_length:1;
+	u8 end_of_media:1;
+	u8 file_mark:1;
+	u8 information[4];
+	u8 additional_sense_length;
+	u8 command_specific_information[4];
+	u8 additional_sense_code;
+	u8 additional_sense_code_qualifier;
+	u8 fru_code;
+	u8 sense_key_specific[3];
+};
+
+struct net_pkt_xmt {
+	int len;	/* full length of data in the packet */
+	int num_frags;	/* number of fragments in frags containing data */
+	struct phys_info frags[MAX_PHYS_INFO];	/* physical page information for
+						 * each fragment */
+	char ethhdr[ETH_HEADER_SIZE];	/* the ethernet header  */
+	struct {
+		    /* these are needed for csum at uisnic end */
+		u8 valid;	/* 1 = rest of this struct is valid - else
+				 * ignore */
+		u8 hrawoffv;	/* 1 = hwrafoff is valid */
+		u8 nhrawoffv;	/* 1 = nhwrafoff is valid */
+		u16 protocol;	/* specifies packet protocol */
+		u32 csum;	/* value used to set skb->csum at IOPart */
+		u32 hrawoff;	/* value used to set skb->h.raw at IOPart */
+		/* hrawoff points to the start of the TRANSPORT LAYER HEADER */
+		u32 nhrawoff;	/* value used to set skb->nh.raw at IOPart */
+		/* nhrawoff points to the start of the NETWORK LAYER HEADER */
+	} lincsum;
+
+	    /* **** NOTE ****
+	     * The full packet is described in frags but the ethernet header is
+	     * separately kept in ethhdr so that uisnic doesn't have "MAP" the
+	     * guest memory to get to the header. uisnic needs ethhdr to
+	     * determine how to route the packet.
+	     */
+};
+
+struct net_pkt_xmtdone {
+	u32 xmt_done_result;	/* result of NET_XMIT */
+};
+
+/* RCVPOST_BUF_SIZe must be at most page_size(4096) - cache_line_size (64) The
+ * reason is because dev_skb_alloc which is used to generate RCV_POST skbs in
+ * virtnic requires that there is "overhead" in the buffer, and pads 16 bytes. I
+ * prefer to use 1 full cache line size for "overhead" so that transfers are
+ * better.  IOVM requires that a buffer be represented by 1 phys_info structure
+ * which can only cover page_size.
+ */
+#define RCVPOST_BUF_SIZE 4032
+#define MAX_NET_RCV_CHAIN \
+	((ETH_MAX_MTU+ETH_HEADER_SIZE + RCVPOST_BUF_SIZE-1) / RCVPOST_BUF_SIZE)
+
+struct net_pkt_rcvpost {
+	    /* rcv buf size must be large enough to include ethernet data len +
+	     * ethernet header len - we are choosing 2K because it is guaranteed
+	     * to be describable */
+	    struct phys_info frag;	/* physical page information for the
+					 * single fragment 2K rcv buf */
+	    u64 unique_num;		/* This is used to make sure that
+					 * receive posts are returned to  */
+	    /* the Adapter which we sent them originally. */
+};
+
+struct net_pkt_rcv {
+	/* the number of receive buffers that can be chained  */
+	/* is based on max mtu and size of each rcv buf */
+	u32 rcv_done_len;	/* length of received data */
+	u8 numrcvbufs;		/* number of receive buffers that contain the */
+	/* incoming data; guest end MUST chain these together. */
+	void *rcvbuf[MAX_NET_RCV_CHAIN];	/* the list of receive buffers
+						 * that must be chained; */
+	/* each entry is a receive buffer provided by NET_RCV_POST. */
+	/* NOTE: first rcvbuf in the chain will also be provided in net.buf. */
+	u64 unique_num;
+	u32 rcvs_dropped_delta;
+};
+
+struct net_pkt_enbdis {
+	void *context;
+	u16 enable;		/* 1 = enable, 0 = disable */
+};
+
+struct net_pkt_macaddr {
+	void *context;
+	u8 macaddr[MAX_MACADDR_LEN];	/* 6 bytes */
+};
+
+/* cmd rsp packet used for VNIC network traffic  */
+struct uiscmdrsp_net {
+	enum net_types type;
+	void *buf;
+	union {
+		struct net_pkt_xmt xmt;		/* used for NET_XMIT */
+		struct net_pkt_xmtdone xmtdone;	/* used for NET_XMIT_DONE */
+		struct net_pkt_rcvpost rcvpost;	/* used for NET_RCV_POST */
+		struct net_pkt_rcv rcv;		/* used for NET_RCV */
+		struct net_pkt_enbdis enbdis;	/* used for NET_RCV_ENBDIS, */
+						/* NET_RCV_ENBDIS_ACK,  */
+						/* NET_RCV_PROMSIC, */
+						/* and NET_CONNECT_STATUS */
+		struct net_pkt_macaddr macaddr;
+	};
+};
+
+struct uiscmdrsp_scsitaskmgmt {
+	enum task_mgmt_types tasktype;
+
+	    /* the type of task */
+	struct uisscsi_dest vdest;
+
+	    /* the vdisk for which this task mgmt is generated */
+	void *scsicmd;
+
+	    /* This is some handle that the guest has saved off for its own use.
+	     * Its value is preserved by iopart & returned as is in the task
+	     * mgmt rsp.
+	     */
+	void *notify;
+
+	   /* For linux guests, this is a pointer to wait_queue_head that a
+	    * thread is waiting on to see if the taskmgmt command has completed.
+	    * For windows guests, this is a pointer to a location that a waiting
+	    * thread is testing to see if the taskmgmt command has completed.
+	    * When the rsp is received by guest, the thread receiving the
+	    * response uses this to notify the thread waiting for taskmgmt
+	    * command completion.  Its value is preserved by iopart & returned
+	    * as is in the task mgmt rsp.
+	    */
+	void *notifyresult;
+
+	    /* this is a handle to location in guest where the result of the
+	     * taskmgmt command (result field) is to saved off when the response
+	     * is handled.  Its value is preserved by iopart & returned as is in
+	     * the task mgmt rsp.
+	     */
+	char result;
+
+	    /* result of taskmgmt command - set by IOPart - values are: */
+#define TASK_MGMT_FAILED  0
+};
+
+/* The following is used by uissd to send disk add/remove notifications to
+ * Guest */
+/* Note that the vHba pointer is not used by the Client/Guest side. */
+struct uiscmdrsp_disknotify {
+	u8 add;			/* 0-remove, 1-add */
+	void *v_hba;		/* Pointer to vhba_info for channel info to
+				 * route msg */
+	u32 channel, id, lun;	/* SCSI Path of Disk to added or removed */
+};
+
+/* The following is used by virthba/vSCSI to send the Acquire/Release commands
+ * to the IOVM. */
+struct uiscmdrsp_vdiskmgmt {
+	enum vdisk_mgmt_types vdisktype;
+
+	    /* the type of task */
+	struct uisscsi_dest vdest;
+
+	    /* the vdisk for which this task mgmt is generated */
+	void *scsicmd;
+
+	    /* This is some handle that the guest has saved off for its own use.
+	     * Its value is preserved by iopart & returned as is in the task
+	     * mgmt rsp.
+	     */
+	void *notify;
+
+	    /* For linux guests, this is a pointer to wait_queue_head that a
+	     * thread is waiting on to see if the tskmgmt command has completed.
+	     * For win32 guests, this is a pointer to a location that a waiting
+	     * thread is testing to see if the taskmgmt command has completed.
+	     * When the rsp is received by guest, the thread receiving the
+	     * response uses this to notify the thread waiting for taskmgmt
+	     * command completion.  Its value is preserved by iopart & returned
+	     * as is in the task mgmt rsp.
+	     */
+	void *notifyresult;
+
+	    /* this is a handle to location in guest where the result of the
+	     * taskmgmt command (result field) is to saved off when the response
+	     * is handled.  Its value is preserved by iopart & returned as is in
+	     * the task mgmt rsp.
+	     */
+	char result;
+
+	    /* result of taskmgmt command - set by IOPart - values are: */
+#define VDISK_MGMT_FAILED  0
+};
+
+/* keeping cmd & rsp info in one structure for now cmd rsp packet for scsi */
+struct uiscmdrsp {
+	char cmdtype;
+
+/* describes what type of information is in the struct */
+#define CMD_SCSI_TYPE		1
+#define CMD_NET_TYPE		2
+#define CMD_SCSITASKMGMT_TYPE	3
+#define CMD_NOTIFYGUEST_TYPE	4
+#define CMD_VDISKMGMT_TYPE	5
+	union {
+		struct uiscmdrsp_scsi scsi;
+		struct uiscmdrsp_net net;
+		struct uiscmdrsp_scsitaskmgmt scsitaskmgmt;
+		struct uiscmdrsp_disknotify disknotify;
+		struct uiscmdrsp_vdiskmgmt vdiskmgmt;
+	};
+	void *private_data;	/* used to send the response when the cmd is
+				 * done (scsi & scsittaskmgmt). */
+	struct uiscmdrsp *next;	/* General Purpose Queue Link */
+	struct uiscmdrsp *activeQ_next;	/* Used to track active commands */
+	struct uiscmdrsp *activeQ_prev;	/* Used to track active commands */
+};
+
+/* This is just the header of the IO channel.  It is assumed that directly after
+ * this header there is a large region of memory which contains the command and
+ * response queues as specified in cmd_q and rsp_q SIGNAL_QUEUE_HEADERS.
+ */
+struct spar_io_channel_protocol {
+	struct channel_header channel_header;
+	struct signal_queue_header cmd_q;
+	struct signal_queue_header rsp_q;
+	union {
+		struct {
+			struct vhba_wwnn wwnn;		/* 8 bytes */
+			struct vhba_config_max max;	/* 20 bytes */
+		} vhba;					/* total = 28 bytes */
+		struct {
+			u8 macaddr[MAX_MACADDR_LEN];	/* 6 bytes */
+			u32 num_rcv_bufs;		/* 4 bytes */
+			u32 mtu;			/* 4 bytes */
+			uuid_le zone_uuid;		/* 16 bytes */
+		} vnic;					/* total = 30 bytes */
+	};
+
+#define MAX_CLIENTSTRING_LEN 1024
+	 u8 client_string[MAX_CLIENTSTRING_LEN];/* NULL terminated - so holds
+						 * max - 1 bytes */
+};
+
+#pragma pack(pop)
+/* ///////////// END PRAGMA PACK PUSH 1 /////////////////////////// */
+
+/*
+ * INLINE functions for initializing and accessing I/O data channels
+ */
+
+#define SIZEOF_PROTOCOL (COVER(sizeof(struct spar_io_channel_protocol), 64))
+#define SIZEOF_CMDRSP (COVER(sizeof(struct uiscmdrsp), 64))
+
+#define MIN_IO_CHANNEL_SIZE COVER(SIZEOF_PROTOCOL + \
+				  2 * MIN_NUMSIGNALS * SIZEOF_CMDRSP, 4096)
+
+/*
+ * INLINE function for expanding a guest's pfn-off-size into multiple 4K page
+ * pfn-off-size entires.
+ */
+
+/* we deal with 4K page sizes when we it comes to passing page information
+ * between */
+/* Guest and IOPartition. */
+#define PI_PAGE_SIZE  0x1000
+#define PI_PAGE_MASK  0x0FFF
+
+/* returns next non-zero index on success or zero on failure (i.e. out of
+ * room)
+ */
+static inline  u16
+add_physinfo_entries(u32 inp_pfn,	/* input - specifies the pfn to be used
+					 * to add entries */
+		     u16 inp_off,	/* input - specifies the off to be used
+					 * to add entries */
+		     u32 inp_len,	/* input - specifies the len to be used
+					 * to add entries */
+		     u16 index,		/* input - index in array at which new
+					 * entries are added */
+		     u16 max_pi_arr_entries,	/* input - specifies the maximum
+						 * entries pi_arr can hold */
+		     struct phys_info pi_arr[]) /* input & output - array to
+						  * which entries are added */
+{
+	u32 len;
+	u16 i, firstlen;
+
+	firstlen = PI_PAGE_SIZE - inp_off;
+	if (inp_len <= firstlen) {
+		/* the input entry spans only one page - add as is */
+		if (index >= max_pi_arr_entries)
+			return 0;
+		pi_arr[index].pi_pfn = inp_pfn;
+		pi_arr[index].pi_off = (u16)inp_off;
+		pi_arr[index].pi_len = (u16)inp_len;
+		    return index + 1;
+	}
+
+	    /* this entry spans multiple pages */
+	    for (len = inp_len, i = 0; len;
+		 len -= pi_arr[index + i].pi_len, i++) {
+		if (index + i >= max_pi_arr_entries)
+			return 0;
+		pi_arr[index + i].pi_pfn = inp_pfn + i;
+		if (i == 0) {
+			pi_arr[index].pi_off = inp_off;
+			pi_arr[index].pi_len = firstlen;
+		}
+
+		else {
+			pi_arr[index + i].pi_off = 0;
+			pi_arr[index + i].pi_len =
+			    (u16)MINNUM(len, (u32)PI_PAGE_SIZE);
+		}
+	}
+	return index + i;
+}
+
+#endif				/* __IOCHANNEL_H__ */
