commit 1f9d6a3d2ebcf1791f4e0f2eb7c96f2197e2205a
Author: Gustavo A. R. Silva <gustavo@embeddedor.com>
Date:   Tue Feb 11 15:17:22 2020 -0600

    staging: unisys: visorinput: Replace zero-length array with flexible-array member
    
    The current codebase makes use of the zero-length array language
    extension to the C90 standard, but the preferred mechanism to declare
    variable-length types such as these ones is a flexible array member[1][2],
    introduced in C99:
    
    struct foo {
            int stuff;
            struct boo array[];
    };
    
    By making use of the mechanism above, we will get a compiler warning
    in case the flexible array does not occur last in the structure, which
    will help us prevent some kind of undefined behavior bugs from being
    inadvertenly introduced[3] to the codebase from now on.
    
    This issue was found with the help of Coccinelle.
    
    [1] https://gcc.gnu.org/onlinedocs/gcc/Zero-Length.html
    [2] https://github.com/KSPP/linux/issues/21
    [3] commit 76497732932f ("cxgb3/l2t: Fix undefined behaviour")
    
    Signed-off-by: Gustavo A. R. Silva <gustavo@embeddedor.com>
    Link: https://lore.kernel.org/r/20200211211722.GA1640@embeddedor
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/unisys/visorinput/visorinput.c b/drivers/staging/unisys/visorinput/visorinput.c
index 9693fb559052..6d202cba8575 100644
--- a/drivers/staging/unisys/visorinput/visorinput.c
+++ b/drivers/staging/unisys/visorinput/visorinput.c
@@ -111,7 +111,7 @@ struct visorinput_devdata {
 	/* size of following array */
 	unsigned int keycode_table_bytes;
 	/* for keyboard devices: visorkbd_keycode[] + visorkbd_ext_keycode[] */
-	unsigned char keycode_table[0];
+	unsigned char keycode_table[];
 };
 
 static const guid_t visor_keyboard_channel_guid = VISOR_KEYBOARD_CHANNEL_GUID;

commit 43a1b9b2ca0a56535442ae57dac0a53c955331e2
Author: David Kershner <david.kershner@unisys.com>
Date:   Wed Jan 31 11:41:17 2018 -0500

    staging: unisys: visorinput: use the full 80 characters of the screen
    
    Several of the comments in the code were not using the full 80 characters
    of the screen. This patch combines the lines to make full use of the
    screen.
    
    Signed-off-by: David Kershner <david.kershner@unisys.com>
    Reviewed-by: Tim Sell <timothy.sell@unisys.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/unisys/visorinput/visorinput.c b/drivers/staging/unisys/visorinput/visorinput.c
index aae3fe5c4c9e..9693fb559052 100644
--- a/drivers/staging/unisys/visorinput/visorinput.c
+++ b/drivers/staging/unisys/visorinput/visorinput.c
@@ -97,9 +97,9 @@ enum visorinput_dev_type {
 };
 
 /*
- * This is the private data that we store for each device.
- * A pointer to this struct is maintained via
- * dev_get_drvdata() / dev_set_drvdata() for each struct device.
+ * This is the private data that we store for each device. A pointer to this
+ * struct is maintained via dev_get_drvdata() / dev_set_drvdata() for each
+ * struct device.
  */
 struct visorinput_devdata {
 	struct visor_device *dev;
@@ -270,10 +270,9 @@ static int visorinput_open(struct input_dev *visorinput_dev)
 	dev_dbg(&visorinput_dev->dev, "%s opened\n", __func__);
 
 	/*
-	 * If we're not paused, really enable interrupts.
-	 * Regardless of whether we are paused, set a flag indicating
-	 * interrupts should be enabled so when we resume, interrupts
-	 * will really be enabled.
+	 * If we're not paused, really enable interrupts. Regardless of whether
+	 * we are paused, set a flag indicating interrupts should be enabled so
+	 * when we resume, interrupts will really be enabled.
 	 */
 	mutex_lock(&devdata->lock_visor_dev);
 	devdata->interrupts_enabled = true;
@@ -299,10 +298,9 @@ static void visorinput_close(struct input_dev *visorinput_dev)
 	dev_dbg(&visorinput_dev->dev, "%s closed\n", __func__);
 
 	/*
-	 * If we're not paused, really disable interrupts.
-	 * Regardless of whether we are paused, set a flag indicating
-	 * interrupts should be disabled so when we resume we will
-	 * not re-enable them.
+	 * If we're not paused, really disable interrupts. Regardless of
+	 * whether we are paused, set a flag indicating interrupts should be
+	 * disabled so when we resume we will not re-enable them.
 	 */
 	mutex_lock(&devdata->lock_visor_dev);
 	devdata->interrupts_enabled = false;
@@ -315,9 +313,9 @@ static void visorinput_close(struct input_dev *visorinput_dev)
 }
 
 /*
- * setup_client_keyboard() initializes and returns a Linux input node that
- * we can use to deliver keyboard inputs to Linux.  We of course do this when
- * we see keyboard inputs coming in on a keyboard channel.
+ * setup_client_keyboard() initializes and returns a Linux input node that we
+ * can use to deliver keyboard inputs to Linux.  We of course do this when we
+ * see keyboard inputs coming in on a keyboard channel.
  */
 static struct input_dev *setup_client_keyboard(void *devdata,
 					       unsigned char *keycode_table)
@@ -424,9 +422,9 @@ static struct visorinput_devdata *devdata_create(struct visor_device *dev,
 	devdata->paused = true;
 
 	/*
-	 * This is an input device in a client guest partition,
-	 * so we need to create whatever input nodes are necessary to
-	 * deliver our inputs to the guest OS.
+	 * This is an input device in a client guest partition, so we need to
+	 * create whatever input nodes are necessary to deliver our inputs to
+	 * the guest OS.
 	 */
 	switch (dtype) {
 	case visorinput_keyboard:
@@ -463,10 +461,9 @@ static struct visorinput_devdata *devdata_create(struct visor_device *dev,
 
 	/*
 	 * Device struct is completely set up now, with the exception of
-	 * visorinput_dev being registered.
-	 * We need to unlock before we register the device, because this
-	 * can cause an on-stack call of visorinput_open(), which would
-	 * deadlock if we had the lock.
+	 * visorinput_dev being registered. We need to unlock before we
+	 * register the device, because this can cause an on-stack call of
+	 * visorinput_open(), which would deadlock if we had the lock.
 	 */
 	if (input_register_device(devdata->visorinput_dev)) {
 		input_free_device(devdata->visorinput_dev);
@@ -475,9 +472,9 @@ static struct visorinput_devdata *devdata_create(struct visor_device *dev,
 
 	mutex_lock(&devdata->lock_visor_dev);
 	/*
-	 * Establish calls to visorinput_channel_interrupt() if that is
-	 * the desired state that we've kept track of in interrupts_enabled
-	 * while the device was being created.
+	 * Establish calls to visorinput_channel_interrupt() if that is the
+	 * desired state that we've kept track of in interrupts_enabled while
+	 * the device was being created.
 	 */
 	devdata->paused = false;
 	if (devdata->interrupts_enabled)
@@ -528,8 +525,8 @@ static void visorinput_remove(struct visor_device *dev)
 	visorbus_disable_channel_interrupts(dev);
 
 	/*
-	 * due to above, at this time no thread of execution will be
-	 * in visorinput_channel_interrupt()
+	 * due to above, at this time no thread of execution will be in
+	 * visorinput_channel_interrupt()
 	 */
 
 	dev_set_drvdata(&dev->device, NULL);
@@ -572,9 +569,8 @@ static void handle_locking_key(struct input_dev *visorinput_dev, int keycode,
 }
 
 /*
- * <scancode> is either a 1-byte scancode, or an extended 16-bit scancode
- * with 0xE0 in the low byte and the extended scancode value in the next
- * higher byte.
+ * <scancode> is either a 1-byte scancode, or an extended 16-bit scancode with
+ * 0xE0 in the low byte and the extended scancode value in the next higher byte.
  */
 static int scancode_to_keycode(int scancode)
 {
@@ -715,8 +711,8 @@ static int visorinput_pause(struct visor_device *dev,
 		visorbus_disable_channel_interrupts(dev);
 
 	/*
-	 * due to above, at this time no thread of execution will be
-	 * in visorinput_channel_interrupt()
+	 * due to above, at this time no thread of execution will be in
+	 * visorinput_channel_interrupt()
 	 */
 	devdata->paused = true;
 	complete_func(dev, 0);
@@ -746,9 +742,9 @@ static int visorinput_resume(struct visor_device *dev,
 	complete_func(dev, 0);
 
 	/*
-	 * Re-establish calls to visorinput_channel_interrupt() if that is
-	 * the desired state that we've kept track of in interrupts_enabled
-	 * while the device was paused.
+	 * Re-establish calls to visorinput_channel_interrupt() if that is the
+	 * desired state that we've kept track of in interrupts_enabled while
+	 * the device was paused.
 	 */
 	if (devdata->interrupts_enabled)
 		visorbus_enable_channel_interrupts(dev);

commit 20a36e2983545fd48118b25ffec1285718912e2e
Author: David Kershner <david.kershner@unisys.com>
Date:   Wed Jan 31 11:41:16 2018 -0500

    staging: unisys: visorinput: Fix spacing after open paranthesis
    
    Checkpatch was giving errors about an open parenthesis being the last thing
    on a line. This patch cleans up some names and removes the checkpatch
    warnings.
    
    Signed-off-by: David Kershner <david.kershner@unisys.com>
    Reviewed-by: Tim Sell <timothy.sell@unisys.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/unisys/visorinput/visorinput.c b/drivers/staging/unisys/visorinput/visorinput.c
index 634b16b8ebbc..aae3fe5c4c9e 100644
--- a/drivers/staging/unisys/visorinput/visorinput.c
+++ b/drivers/staging/unisys/visorinput/visorinput.c
@@ -91,7 +91,7 @@ struct visor_input_channel_data {
 	};
 } __packed;
 
-enum visorinput_device_type {
+enum visorinput_dev_type {
 	visorinput_keyboard,
 	visorinput_mouse,
 };
@@ -397,16 +397,15 @@ static struct input_dev *setup_client_mouse(void *devdata, unsigned int xres,
 	return visorinput_dev;
 }
 
-static struct visorinput_devdata *devdata_create(
-					struct visor_device *dev,
-					enum visorinput_device_type devtype)
+static struct visorinput_devdata *devdata_create(struct visor_device *dev,
+						 enum visorinput_dev_type dtype)
 {
 	struct visorinput_devdata *devdata = NULL;
 	unsigned int extra_bytes = 0;
 	unsigned int size, xres, yres, err;
 	struct visor_input_channel_data data;
 
-	if (devtype == visorinput_keyboard)
+	if (dtype == visorinput_keyboard)
 		/* allocate room for devdata->keycode_table, filled in below */
 		extra_bytes = KEYCODE_TABLE_BYTES * 2;
 	devdata = kzalloc(sizeof(*devdata) + extra_bytes, GFP_KERNEL);
@@ -429,7 +428,7 @@ static struct visorinput_devdata *devdata_create(
 	 * so we need to create whatever input nodes are necessary to
 	 * deliver our inputs to the guest OS.
 	 */
-	switch (devtype) {
+	switch (dtype) {
 	case visorinput_keyboard:
 		devdata->keycode_table_bytes = extra_bytes;
 		memcpy(devdata->keycode_table, visorkbd_keycode,
@@ -497,17 +496,17 @@ static struct visorinput_devdata *devdata_create(
 static int visorinput_probe(struct visor_device *dev)
 {
 	const guid_t *guid;
-	enum visorinput_device_type devtype;
+	enum visorinput_dev_type dtype;
 
 	guid = visorchannel_get_guid(dev->visorchannel);
 	if (guid_equal(guid, &visor_mouse_channel_guid))
-		devtype = visorinput_mouse;
+		dtype = visorinput_mouse;
 	else if (guid_equal(guid, &visor_keyboard_channel_guid))
-		devtype = visorinput_keyboard;
+		dtype = visorinput_keyboard;
 	else
 		return -ENODEV;
 	visorbus_disable_channel_interrupts(dev);
-	if (!devdata_create(dev, devtype))
+	if (!devdata_create(dev, dtype))
 		return -ENOMEM;
 	return 0;
 }

commit c52e07ce2b4ff12faad734f40d4134e4b54bb232
Author: David Kershner <david.kershner@unisys.com>
Date:   Wed Jan 31 11:41:15 2018 -0500

    staging: unisys: visorinput: combine ultrainputreport.h with visorinput.c
    
    The file ultrainputreport.h was just being used by visorinput.c. Move the
    definitions into visorinput.c and get rid of the file.
    
    Signed-off-by: David Kershner <david.kershner@unisys.com>
    Reviewed-by: Tim Sell <timothy.sell@unisys.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/unisys/visorinput/visorinput.c b/drivers/staging/unisys/visorinput/visorinput.c
index 99730409bd7f..634b16b8ebbc 100644
--- a/drivers/staging/unisys/visorinput/visorinput.c
+++ b/drivers/staging/unisys/visorinput/visorinput.c
@@ -18,7 +18,36 @@
 #include <linux/uuid.h>
 #include <linux/visorbus.h>
 
-#include "ultrainputreport.h"
+/* These defines identify mouse and keyboard activity which is specified by the
+ * firmware to the host using the cmsimpleinput protocol.  @ingroup coretypes
+ */
+/* only motion; arg1=x, arg2=y */
+#define INPUTACTION_XY_MOTION 1
+
+/* arg1: 1=left,2=center,3=right */
+#define INPUTACTION_MOUSE_BUTTON_DOWN 2
+#define INPUTACTION_MOUSE_BUTTON_UP 3
+#define INPUTACTION_MOUSE_BUTTON_CLICK 4
+#define INPUTACTION_MOUSE_BUTTON_DCLICK 5
+
+/* arg1: wheel rotation away from/toward user */
+#define INPUTACTION_WHEEL_ROTATE_AWAY 6
+#define INPUTACTION_WHEEL_ROTATE_TOWARD 7
+
+/* arg1: scancode, as follows: If arg1 <= 0xff, it's a 1-byte scancode and arg1
+ *	 is that scancode. If arg1 > 0xff, it's a 2-byte scanecode, with the 1st
+ *	 byte in the low 8 bits, and the 2nd byte in the high 8 bits.
+ *	 E.g., the right ALT key would appear as x'38e0'.
+ */
+#define INPUTACTION_KEY_DOWN 64
+#define INPUTACTION_KEY_UP 65
+#define INPUTACTION_KEY_DOWN_UP 67
+
+/* arg1: scancode (in same format as inputaction_keyDown); MUST refer to one of
+ *	 the locking keys, like capslock, numlock, or scrolllock.
+ * arg2: 1 iff locking key should be in the LOCKED position (e.g., light is ON)
+ */
+#define INPUTACTION_SET_LOCKING_KEY_STATE 66
 
 /* Keyboard channel {c73416d0-b0b8-44af-b304-9d2ae99f1b3d} */
 #define VISOR_KEYBOARD_CHANNEL_GUID \
@@ -36,6 +65,18 @@
 #define PIXELS_DOWN_DEFAULT   768
 #define KEYCODE_TABLE_BYTES   256
 
+struct visor_inputactivity {
+	u16 action;
+	u16 arg1;
+	u16 arg2;
+	u16 arg3;
+} __packed;
+
+struct visor_inputreport {
+	u64 seq_no;
+	struct visor_inputactivity activity;
+} __packed;
+
 /* header of keyboard/mouse channels */
 struct visor_input_channel_data {
 	u32 n_input_reports;

commit 385a9cb3471c79289a1ee90dd2c381405d3615d9
Author: Tim Sell <Timothy.Sell@unisys.com>
Date:   Wed Jan 31 11:41:12 2018 -0500

    staging: unisys: visorinput: remove need for 'depends on FB'
    
    Previously, we used a hack to determine the max x,y resolution of the
    visor virtual mouse: we just looked at the resolution of the
    first-registered framebuffer device, using the currently-valid assumption
    that in a Unisys s-Par guest environment the video will be provided by an
    efifb framebuffer device.
    
    This hack has been removed, by instead determining the default mouse
    resolution by looking at fields within the visor mouse channel memory,
    mouse.x_res and mouse.y_res.  If these fields are 0, a default resolution
    of 1024x768 is assumed.
    
    Signed-off-by: Tim Sell <Timothy.Sell@unisys.com>
    Signed-off-by: David Kershner <david.kershner@unisys.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/unisys/visorinput/visorinput.c b/drivers/staging/unisys/visorinput/visorinput.c
index d8048e48658f..99730409bd7f 100644
--- a/drivers/staging/unisys/visorinput/visorinput.c
+++ b/drivers/staging/unisys/visorinput/visorinput.c
@@ -32,10 +32,24 @@
 		  0x81, 0xc3, 0x61, 0xab, 0xcd, 0xbd, 0xbd, 0x87)
 #define VISOR_MOUSE_CHANNEL_GUID_STR "addf07d4-94a9-46e2-81c3-61abcdbdbd87"
 
-#define PIXELS_ACROSS_DEFAULT 800
-#define PIXELS_DOWN_DEFAULT   600
+#define PIXELS_ACROSS_DEFAULT 1024
+#define PIXELS_DOWN_DEFAULT   768
 #define KEYCODE_TABLE_BYTES   256
 
+/* header of keyboard/mouse channels */
+struct visor_input_channel_data {
+	u32 n_input_reports;
+	union {
+		struct {
+			u16 x_res;
+			u16 y_res;
+		} mouse;
+		struct {
+			u32 flags;
+		} keyboard;
+	};
+} __packed;
+
 enum visorinput_device_type {
 	visorinput_keyboard,
 	visorinput_mouse,
@@ -306,10 +320,9 @@ static struct input_dev *setup_client_keyboard(void *devdata,
 	return visorinput_dev;
 }
 
-static struct input_dev *setup_client_mouse(void *devdata)
+static struct input_dev *setup_client_mouse(void *devdata, unsigned int xres,
+					    unsigned int yres)
 {
-	int xres, yres;
-	struct fb_info *fb0;
 	struct input_dev *visorinput_dev = input_allocate_device();
 
 	if (!visorinput_dev)
@@ -327,14 +340,10 @@ static struct input_dev *setup_client_mouse(void *devdata)
 	set_bit(BTN_RIGHT, visorinput_dev->keybit);
 	set_bit(BTN_MIDDLE, visorinput_dev->keybit);
 
-	if (registered_fb[0]) {
-		fb0 = registered_fb[0];
-		xres = fb0->var.xres_virtual;
-		yres = fb0->var.yres_virtual;
-	} else {
+	if (xres == 0)
 		xres = PIXELS_ACROSS_DEFAULT;
+	if (yres == 0)
 		yres = PIXELS_DOWN_DEFAULT;
-	}
 	input_set_abs_params(visorinput_dev, ABS_X, 0, xres, 0, 0);
 	input_set_abs_params(visorinput_dev, ABS_Y, 0, yres, 0, 0);
 
@@ -353,6 +362,8 @@ static struct visorinput_devdata *devdata_create(
 {
 	struct visorinput_devdata *devdata = NULL;
 	unsigned int extra_bytes = 0;
+	unsigned int size, xres, yres, err;
+	struct visor_input_channel_data data;
 
 	if (devtype == visorinput_keyboard)
 		/* allocate room for devdata->keycode_table, filled in below */
@@ -390,7 +401,15 @@ static struct visorinput_devdata *devdata_create(
 			goto cleanups_register;
 		break;
 	case visorinput_mouse:
-		devdata->visorinput_dev = setup_client_mouse(devdata);
+		size = sizeof(struct visor_input_channel_data);
+		err = visorbus_read_channel(dev, sizeof(struct channel_header),
+					    &data, size);
+		if (err)
+			goto cleanups_register;
+		xres = data.mouse.x_res;
+		yres = data.mouse.y_res;
+		devdata->visorinput_dev = setup_client_mouse(devdata, xres,
+							     yres);
 		if (!devdata->visorinput_dev)
 			goto cleanups_register;
 		break;

commit 93d3ad90c2d470804b16f79e7e872408747d3e77
Author: David Kershner <david.kershner@unisys.com>
Date:   Thu Dec 7 12:11:07 2017 -0500

    drivers: visorbus: move driver out of staging
    
    Move the visorbus driver out of staging (drivers/staging/unisys/visorbus)
    and to drivers/visorbus. Modify the configuration and makefiles so they
    now reference the new location. The s-Par header file visorbus.h that is
    referenced by all s-Par drivers, is being moved into include/linux.
    
    Signed-off-by: David Kershner <david.kershner@unisys.com>
    Reviewed-by: Tim Sell <timothy.sell@unisys.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/unisys/visorinput/visorinput.c b/drivers/staging/unisys/visorinput/visorinput.c
index dabc5b44208e..d8048e48658f 100644
--- a/drivers/staging/unisys/visorinput/visorinput.c
+++ b/drivers/staging/unisys/visorinput/visorinput.c
@@ -16,8 +16,8 @@
 #include <linux/kernel.h>
 #include <linux/module.h>
 #include <linux/uuid.h>
+#include <linux/visorbus.h>
 
-#include "visorbus.h"
 #include "ultrainputreport.h"
 
 /* Keyboard channel {c73416d0-b0b8-44af-b304-9d2ae99f1b3d} */

commit 2baffb7205e0f4da158cabcf1116e4422af188a6
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Nov 7 14:58:49 2017 +0100

    staging: unisys: Remove redundant license text
    
    Now that the SPDX tag is in all unisys driver files, that identifies the
    license in a specific and legally-defined manner.  So the extra GPL text
    wording can be removed as it is no longer needed at all.
    
    This is done on a quest to remove the 700+ different ways that files in
    the kernel describe the GPL license text.  And there's unneeded stuff
    like the address (sometimes incorrect) for the FSF which is never
    needed.
    
    No copyright headers or other non-license-description text was removed.
    
    Cc: David Kershner <david.kershner@unisys.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/unisys/visorinput/visorinput.c b/drivers/staging/unisys/visorinput/visorinput.c
index 11de40821f92..dabc5b44208e 100644
--- a/drivers/staging/unisys/visorinput/visorinput.c
+++ b/drivers/staging/unisys/visorinput/visorinput.c
@@ -2,16 +2,6 @@
 /*
  * Copyright (C) 2011 - 2015 UNISYS CORPORATION
  * All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, GOOD TITLE or
- * NON INFRINGEMENT.  See the GNU General Public License for more
- * details.
  */
 
 /*

commit b79c0f4f5cc15cdf2b84b3431fa36c65b92260cc
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Nov 7 14:58:47 2017 +0100

    staging: unisys: add SPDX identifiers to all unisys driver files
    
    It's good to have SPDX identifiers in all files to make it easier to
    audit the kernel tree for correct licenses.
    
    Update the drivers/staging/unisys files files with the correct SPDX
    license identifier based on the license text in the file itself.  The
    SPDX identifier is a legally binding shorthand, which can be used
    instead of the full boiler plate text.
    
    This work is based on a script and data from Thomas Gleixner, Philippe
    Ombredanne, and Kate Stewart.
    
    Cc: David Kershner <david.kershner@unisys.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: Philippe Ombredanne <pombredanne@nexb.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/unisys/visorinput/visorinput.c b/drivers/staging/unisys/visorinput/visorinput.c
index 450f003743c0..11de40821f92 100644
--- a/drivers/staging/unisys/visorinput/visorinput.c
+++ b/drivers/staging/unisys/visorinput/visorinput.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * Copyright (C) 2011 - 2015 UNISYS CORPORATION
  * All rights reserved.

commit cb3b5dccca9d011f764de139f88a1db3b9d21d82
Author: Sameer Wadgaonkar <sameer.wadgaonkar@unisys.com>
Date:   Wed Sep 27 13:14:43 2017 -0400

    staging: unisys: check the whole channel instead of just guid for match
    
    Validate that the channel contents match the channel type that we are
    matching.
    
    Signed-off-by: Sameer Wadgaonkar <sameer.wadgaonkar@unisys.com>
    Signed-off-by: David Kershner <david.kershner@unisys.com>
    Reviewed-by: Tim Sell <timothy.sell@unisys.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/unisys/visorinput/visorinput.c b/drivers/staging/unisys/visorinput/visorinput.c
index 1b58663709e6..450f003743c0 100644
--- a/drivers/staging/unisys/visorinput/visorinput.c
+++ b/drivers/staging/unisys/visorinput/visorinput.c
@@ -712,8 +712,9 @@ static int visorinput_resume(struct visor_device *dev,
 
 /* GUIDS for all channel types supported by this driver. */
 static struct visor_channeltype_descriptor visorinput_channel_types[] = {
-	{ VISOR_KEYBOARD_CHANNEL_GUID, "keyboard"},
-	{ VISOR_MOUSE_CHANNEL_GUID, "mouse"},
+	{ VISOR_KEYBOARD_CHANNEL_GUID, "keyboard",
+	  sizeof(struct channel_header), 0 },
+	{ VISOR_MOUSE_CHANNEL_GUID, "mouse", sizeof(struct channel_header), 0 },
 	{}
 };
 

commit eb6eb1e14d9900d39660d0313eb01791fcdaf2b3
Author: David Kershner <david.kershner@unisys.com>
Date:   Wed Sep 27 13:14:29 2017 -0400

    staging: unisys: only include a file where it is used.
    
    The header file visorbus.h included several linux headers that were
    used by the source files that include it. Move the includes to the
    files that actually use them.
    
    Signed-off-by: David Kershner <david.kershner@unisys.com>
    Reviewed-by: Tim Sell <timothy.sell@unisys.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/unisys/visorinput/visorinput.c b/drivers/staging/unisys/visorinput/visorinput.c
index 9d8cbc52de8b..1b58663709e6 100644
--- a/drivers/staging/unisys/visorinput/visorinput.c
+++ b/drivers/staging/unisys/visorinput/visorinput.c
@@ -23,6 +23,7 @@
 #include <linux/fb.h>
 #include <linux/input.h>
 #include <linux/kernel.h>
+#include <linux/module.h>
 #include <linux/uuid.h>
 
 #include "visorbus.h"

commit b21bb6d483a6973f8fd034e3aebcce42e64c3463
Author: Alex Briskin <br.shurik@gmail.com>
Date:   Fri Aug 25 19:25:06 2017 +0300

    staging: unisys: visorinput: Add module_driver driver registration
    
    1. Remove module_init()/module_exit() macroes and
    visorbus_register_visor_driver/visorbus_unregister_visor_driver
    functions.
    2. Replace with a short module_driver macro
    
    Signed-off-by: Alex Briskin <br.shurik@gmail.com>
    Acked-by: David Kershner <david.kershner@unisys.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/unisys/visorinput/visorinput.c b/drivers/staging/unisys/visorinput/visorinput.c
index 26f0b9bd09d9..9d8cbc52de8b 100644
--- a/drivers/staging/unisys/visorinput/visorinput.c
+++ b/drivers/staging/unisys/visorinput/visorinput.c
@@ -727,18 +727,8 @@ static struct visor_driver visorinput_driver = {
 	.resume = visorinput_resume,
 };
 
-static int visorinput_init(void)
-{
-	return visorbus_register_visor_driver(&visorinput_driver);
-}
-
-static void visorinput_cleanup(void)
-{
-	visorbus_unregister_visor_driver(&visorinput_driver);
-}
-
-module_init(visorinput_init);
-module_exit(visorinput_cleanup);
+module_driver(visorinput_driver, visorbus_register_visor_driver,
+	      visorbus_unregister_visor_driver);
 
 MODULE_DEVICE_TABLE(visorbus, visorinput_channel_types);
 

commit 81d3817e857e77ee38cebaa72bcd23ec8bfd785d
Author: David Binder <david.binder@unisys.com>
Date:   Tue Aug 22 13:27:28 2017 -0400

    staging: unisys: visorinput: visorinput.c: Remove filename in top comment
    
    Removes unnecessary filename in the top file comment.
    
    Signed-off-by: David Binder <david.binder@unisys.com>
    Signed-off-by: David Kershner <david.kershner@unisys.com>
    Reviewed-by: Tim Sell <timothy.sell@unisys.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/unisys/visorinput/visorinput.c b/drivers/staging/unisys/visorinput/visorinput.c
index d3d9c77def6d..26f0b9bd09d9 100644
--- a/drivers/staging/unisys/visorinput/visorinput.c
+++ b/drivers/staging/unisys/visorinput/visorinput.c
@@ -1,5 +1,4 @@
-/* visorinput.c
- *
+/*
  * Copyright (C) 2011 - 2015 UNISYS CORPORATION
  * All rights reserved.
  *

commit 8c3f22c28c9f1da65b79f030f4b44c72318cf1aa
Author: David Kershner <david.kershner@unisys.com>
Date:   Tue Aug 22 13:27:17 2017 -0400

    staging: unisys: visorinput: Get rid of unused includes
    
    Cleanups caused us to not need to include a bunch of headers, got rid of
    them.
    
    Reviewed-by: Sameer Wadgaonkar <sameer.wadgaonkar@unisys.com>
    Signed-off-by: David Kershner <david.kershner@unisys.com>
    Reviewed-by: Tim Sell <timothy.sell@unisys.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/unisys/visorinput/visorinput.c b/drivers/staging/unisys/visorinput/visorinput.c
index 3cfeefe23a8a..d3d9c77def6d 100644
--- a/drivers/staging/unisys/visorinput/visorinput.c
+++ b/drivers/staging/unisys/visorinput/visorinput.c
@@ -21,11 +21,8 @@
  * standard way the Linux expects for input drivers.
  */
 
-#include <linux/buffer_head.h>
 #include <linux/fb.h>
-#include <linux/fs.h>
 #include <linux/input.h>
-#include <linux/uaccess.h>
 #include <linux/kernel.h>
 #include <linux/uuid.h>
 

commit b32c5cb84fd0c4539227b5973d378111e35bd9c5
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Tue Aug 22 13:26:54 2017 -0400

    staging: unisys: Switch to use new generic UUID API
    
    There are new types and helpers that are supposed to be used in new code.
    
    As a preparation to get rid of legacy types and API functions do
    the conversion here.
    
    While here, re-indent couple of lines to increase readability.
    
    Cc: David Kershner <david.kershner@unisys.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: sparmaintainer@unisys.com
    Cc: devel@driverdev.osuosl.org
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: David Kershner <david.kershner@unisys.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/unisys/visorinput/visorinput.c b/drivers/staging/unisys/visorinput/visorinput.c
index 65060e9b6132..3cfeefe23a8a 100644
--- a/drivers/staging/unisys/visorinput/visorinput.c
+++ b/drivers/staging/unisys/visorinput/visorinput.c
@@ -33,16 +33,16 @@
 #include "ultrainputreport.h"
 
 /* Keyboard channel {c73416d0-b0b8-44af-b304-9d2ae99f1b3d} */
-#define VISOR_KEYBOARD_CHANNEL_UUID \
-	UUID_LE(0xc73416d0, 0xb0b8, 0x44af, \
-		0xb3, 0x4, 0x9d, 0x2a, 0xe9, 0x9f, 0x1b, 0x3d)
-#define VISOR_KEYBOARD_CHANNEL_UUID_STR "c73416d0-b0b8-44af-b304-9d2ae99f1b3d"
+#define VISOR_KEYBOARD_CHANNEL_GUID \
+	GUID_INIT(0xc73416d0, 0xb0b8, 0x44af, \
+		  0xb3, 0x4, 0x9d, 0x2a, 0xe9, 0x9f, 0x1b, 0x3d)
+#define VISOR_KEYBOARD_CHANNEL_GUID_STR "c73416d0-b0b8-44af-b304-9d2ae99f1b3d"
 
 /* Mouse channel {addf07d4-94a9-46e2-81c3-61abcdbdbd87} */
-#define VISOR_MOUSE_CHANNEL_UUID \
-	UUID_LE(0xaddf07d4, 0x94a9, 0x46e2, \
-		0x81, 0xc3, 0x61, 0xab, 0xcd, 0xbd, 0xbd, 0x87)
-#define VISOR_MOUSE_CHANNEL_UUID_STR "addf07d4-94a9-46e2-81c3-61abcdbdbd87"
+#define VISOR_MOUSE_CHANNEL_GUID \
+	GUID_INIT(0xaddf07d4, 0x94a9, 0x46e2, \
+		  0x81, 0xc3, 0x61, 0xab, 0xcd, 0xbd, 0xbd, 0x87)
+#define VISOR_MOUSE_CHANNEL_GUID_STR "addf07d4-94a9-46e2-81c3-61abcdbdbd87"
 
 #define PIXELS_ACROSS_DEFAULT 800
 #define PIXELS_DOWN_DEFAULT   600
@@ -71,8 +71,8 @@ struct visorinput_devdata {
 	unsigned char keycode_table[0];
 };
 
-static const uuid_le visor_keyboard_channel_uuid = VISOR_KEYBOARD_CHANNEL_UUID;
-static const uuid_le visor_mouse_channel_uuid = VISOR_MOUSE_CHANNEL_UUID;
+static const guid_t visor_keyboard_channel_guid = VISOR_KEYBOARD_CHANNEL_GUID;
+static const guid_t visor_mouse_channel_guid = VISOR_MOUSE_CHANNEL_GUID;
 
 /*
  * Borrowed from drivers/input/keyboard/atakbd.c
@@ -448,13 +448,13 @@ static struct visorinput_devdata *devdata_create(
 
 static int visorinput_probe(struct visor_device *dev)
 {
-	uuid_le guid;
+	const guid_t *guid;
 	enum visorinput_device_type devtype;
 
-	guid = visorchannel_get_uuid(dev->visorchannel);
-	if (uuid_le_cmp(guid, visor_mouse_channel_uuid) == 0)
+	guid = visorchannel_get_guid(dev->visorchannel);
+	if (guid_equal(guid, &visor_mouse_channel_guid))
 		devtype = visorinput_mouse;
-	else if (uuid_le_cmp(guid, visor_keyboard_channel_uuid) == 0)
+	else if (guid_equal(guid, &visor_keyboard_channel_guid))
 		devtype = visorinput_keyboard;
 	else
 		return -ENODEV;
@@ -715,9 +715,9 @@ static int visorinput_resume(struct visor_device *dev,
 
 /* GUIDS for all channel types supported by this driver. */
 static struct visor_channeltype_descriptor visorinput_channel_types[] = {
-	{ VISOR_KEYBOARD_CHANNEL_UUID, "keyboard"},
-	{ VISOR_MOUSE_CHANNEL_UUID, "mouse"},
-	{ NULL_UUID_LE, NULL }
+	{ VISOR_KEYBOARD_CHANNEL_GUID, "keyboard"},
+	{ VISOR_MOUSE_CHANNEL_GUID, "mouse"},
+	{}
 };
 
 static struct visor_driver visorinput_driver = {
@@ -750,5 +750,5 @@ MODULE_AUTHOR("Unisys");
 MODULE_LICENSE("GPL");
 MODULE_DESCRIPTION("s-Par human input driver for virtual keyboard/mouse");
 
-MODULE_ALIAS("visorbus:" VISOR_MOUSE_CHANNEL_UUID_STR);
-MODULE_ALIAS("visorbus:" VISOR_KEYBOARD_CHANNEL_UUID_STR);
+MODULE_ALIAS("visorbus:" VISOR_MOUSE_CHANNEL_GUID_STR);
+MODULE_ALIAS("visorbus:" VISOR_KEYBOARD_CHANNEL_GUID_STR);

commit 4f4205ed31c7054e28bda22c81dcc05d1e9bb7cf
Author: Charles Daniels <cdaniels@fastmail.com>
Date:   Mon Jul 17 16:17:20 2017 -0400

    staging: unisys: visorinput: fix multi-line function definition
    
    Fixed incorrect function declaration style in visorinput/visorinput.c
    by placing the function names on the same line as the return.
    
    Signed-off-by: Charles Daniels <cdaniels@fastmail.com>
    Signed-off-by: David Kershner <david.kershner@unisys.com>
    Reviewed-by: David Binder <david.binder@unisys.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/unisys/visorinput/visorinput.c b/drivers/staging/unisys/visorinput/visorinput.c
index 761e56b32444..65060e9b6132 100644
--- a/drivers/staging/unisys/visorinput/visorinput.c
+++ b/drivers/staging/unisys/visorinput/visorinput.c
@@ -276,9 +276,8 @@ static void visorinput_close(struct input_dev *visorinput_dev)
  * we can use to deliver keyboard inputs to Linux.  We of course do this when
  * we see keyboard inputs coming in on a keyboard channel.
  */
-static struct input_dev *
-setup_client_keyboard(void *devdata,  /* opaque on purpose */
-		      unsigned char *keycode_table)
+static struct input_dev *setup_client_keyboard(void *devdata,
+					       unsigned char *keycode_table)
 
 {
 	int i;
@@ -319,8 +318,7 @@ setup_client_keyboard(void *devdata,  /* opaque on purpose */
 	return visorinput_dev;
 }
 
-static struct input_dev *
-setup_client_mouse(void *devdata /* opaque on purpose */)
+static struct input_dev *setup_client_mouse(void *devdata)
 {
 	int xres, yres;
 	struct fb_info *fb0;
@@ -361,8 +359,9 @@ setup_client_mouse(void *devdata /* opaque on purpose */)
 	return visorinput_dev;
 }
 
-static struct visorinput_devdata *
-devdata_create(struct visor_device *dev, enum visorinput_device_type devtype)
+static struct visorinput_devdata *devdata_create(
+					struct visor_device *dev,
+					enum visorinput_device_type devtype)
 {
 	struct visorinput_devdata *devdata = NULL;
 	unsigned int extra_bytes = 0;
@@ -447,8 +446,7 @@ devdata_create(struct visor_device *dev, enum visorinput_device_type devtype)
 	return NULL;
 }
 
-static int
-visorinput_probe(struct visor_device *dev)
+static int visorinput_probe(struct visor_device *dev)
 {
 	uuid_le guid;
 	enum visorinput_device_type devtype;
@@ -466,15 +464,13 @@ visorinput_probe(struct visor_device *dev)
 	return 0;
 }
 
-static void
-unregister_client_input(struct input_dev *visorinput_dev)
+static void unregister_client_input(struct input_dev *visorinput_dev)
 {
 	if (visorinput_dev)
 		input_unregister_device(visorinput_dev);
 }
 
-static void
-visorinput_remove(struct visor_device *dev)
+static void visorinput_remove(struct visor_device *dev)
 {
 	struct visorinput_devdata *devdata = dev_get_drvdata(&dev->device);
 
@@ -500,9 +496,8 @@ visorinput_remove(struct visor_device *dev)
  * Make it so the current locking state of the locking key indicated by
  * <keycode> is as indicated by <desired_state> (1=locked, 0=unlocked).
  */
-static void
-handle_locking_key(struct input_dev *visorinput_dev,
-		   int keycode, int desired_state)
+static void handle_locking_key(struct input_dev *visorinput_dev, int keycode,
+			       int desired_state)
 {
 	int led;
 
@@ -534,8 +529,7 @@ handle_locking_key(struct input_dev *visorinput_dev,
  * with 0xE0 in the low byte and the extended scancode value in the next
  * higher byte.
  */
-static int
-scancode_to_keycode(int scancode)
+static int scancode_to_keycode(int scancode)
 {
 	if (scancode > 0xff)
 		return visorkbd_ext_keycode[(scancode >> 8) & 0xff];
@@ -543,8 +537,7 @@ scancode_to_keycode(int scancode)
 	return visorkbd_keycode[scancode];
 }
 
-static int
-calc_button(int x)
+static int calc_button(int x)
 {
 	switch (x) {
 	case 1:
@@ -563,8 +556,7 @@ calc_button(int x)
  * client guest partition.  It is called periodically so we can obtain inputs
  * from the channel, and deliver them to the guest OS.
  */
-static void
-visorinput_channel_interrupt(struct visor_device *dev)
+static void visorinput_channel_interrupt(struct visor_device *dev)
 {
 	struct visor_inputreport r;
 	int scancode, keycode;
@@ -656,9 +648,8 @@ visorinput_channel_interrupt(struct visor_device *dev)
 	}
 }
 
-static int
-visorinput_pause(struct visor_device *dev,
-		 visorbus_state_complete_func complete_func)
+static int visorinput_pause(struct visor_device *dev,
+			    visorbus_state_complete_func complete_func)
 {
 	int rc;
 	struct visorinput_devdata *devdata = dev_get_drvdata(&dev->device);
@@ -689,9 +680,8 @@ visorinput_pause(struct visor_device *dev,
 	return rc;
 }
 
-static int
-visorinput_resume(struct visor_device *dev,
-		  visorbus_state_complete_func complete_func)
+static int visorinput_resume(struct visor_device *dev,
+			     visorbus_state_complete_func complete_func)
 {
 	int rc;
 	struct visorinput_devdata *devdata = dev_get_drvdata(&dev->device);
@@ -741,14 +731,12 @@ static struct visor_driver visorinput_driver = {
 	.resume = visorinput_resume,
 };
 
-static int
-visorinput_init(void)
+static int visorinput_init(void)
 {
 	return visorbus_register_visor_driver(&visorinput_driver);
 }
 
-static void
-visorinput_cleanup(void)
+static void visorinput_cleanup(void)
 {
 	visorbus_unregister_visor_driver(&visorinput_driver);
 }

commit 3cc1db3d965c59867e6e0ad72b08bb972165bae0
Author: David Binder <david.binder@unisys.com>
Date:   Mon Jul 17 16:16:45 2017 -0400

    staging: unisys: visorinput: visorinput.c: Adjust whitespace usage
    
    Adjusts whitespace usage in order to create a more uniform coding style.
    
    Signed-off-by: David Binder <david.binder@unisys.com>
    Signed-off-by: David Kershner <david.kershner@unisys.com>
    Reviewed-by: David Binder <david.binder@unisys.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/unisys/visorinput/visorinput.c b/drivers/staging/unisys/visorinput/visorinput.c
index c15f28fccdbe..761e56b32444 100644
--- a/drivers/staging/unisys/visorinput/visorinput.c
+++ b/drivers/staging/unisys/visorinput/visorinput.c
@@ -261,7 +261,6 @@ static void visorinput_close(struct input_dev *visorinput_dev)
 	 * interrupts should be disabled so when we resume we will
 	 * not re-enable them.
 	 */
-
 	mutex_lock(&devdata->lock_visor_dev);
 	devdata->interrupts_enabled = false;
 	if (devdata->paused)
@@ -283,9 +282,8 @@ setup_client_keyboard(void *devdata,  /* opaque on purpose */
 
 {
 	int i;
-	struct input_dev *visorinput_dev;
+	struct input_dev *visorinput_dev = input_allocate_device();
 
-	visorinput_dev = input_allocate_device();
 	if (!visorinput_dev)
 		return NULL;
 
@@ -324,11 +322,10 @@ setup_client_keyboard(void *devdata,  /* opaque on purpose */
 static struct input_dev *
 setup_client_mouse(void *devdata /* opaque on purpose */)
 {
-	struct input_dev *visorinput_dev = NULL;
 	int xres, yres;
 	struct fb_info *fb0;
+	struct input_dev *visorinput_dev = input_allocate_device();
 
-	visorinput_dev = input_allocate_device();
 	if (!visorinput_dev)
 		return NULL;
 
@@ -543,7 +540,7 @@ scancode_to_keycode(int scancode)
 	if (scancode > 0xff)
 		return visorkbd_ext_keycode[(scancode >> 8) & 0xff];
 
-	return  visorkbd_keycode[scancode];
+	return visorkbd_keycode[scancode];
 }
 
 static int
@@ -574,7 +571,6 @@ visorinput_channel_interrupt(struct visor_device *dev)
 	struct input_dev *visorinput_dev;
 	int xmotion, ymotion, button;
 	int i;
-
 	struct visorinput_devdata *devdata = dev_get_drvdata(&dev->device);
 
 	if (!devdata)
@@ -630,7 +626,6 @@ visorinput_channel_interrupt(struct visor_device *dev)
 			if (button < 0)
 				break;
 			input_report_key(visorinput_dev, button, 1);
-
 			input_sync(visorinput_dev);
 			input_report_key(visorinput_dev, button, 0);
 			input_sync(visorinput_dev);
@@ -685,7 +680,6 @@ visorinput_pause(struct visor_device *dev,
 	 * due to above, at this time no thread of execution will be
 	 * in visorinput_channel_interrupt()
 	 */
-
 	devdata->paused = true;
 	complete_func(dev, 0);
 	rc = 0;

commit 0c58bc0d3d3a752fd16cfca5429f1d7c49cb52e8
Author: Sameer Wadgaonkar <sameer.wadgaonkar@unisys.com>
Date:   Fri Jun 30 15:43:13 2017 -0400

    staging: unisys: visorinput: visorinput.c: fixed comment formatting issues
    
    Removed comments from the right side of the lines.
    
    Signed-off-by: Sameer Wadgaonkar <sameer.wadgaonkar@unisys.com>
    Signed-off-by: David Kershner <david.kershner@unisys.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/unisys/visorinput/visorinput.c b/drivers/staging/unisys/visorinput/visorinput.c
index 45bc340d4e9d..c15f28fccdbe 100644
--- a/drivers/staging/unisys/visorinput/visorinput.c
+++ b/drivers/staging/unisys/visorinput/visorinput.c
@@ -60,11 +60,13 @@ enum visorinput_device_type {
  */
 struct visorinput_devdata {
 	struct visor_device *dev;
-	struct mutex lock_visor_dev; /* lock for dev */
+	/* lock for dev */
+	struct mutex lock_visor_dev;
 	struct input_dev *visorinput_dev;
 	bool paused;
 	bool interrupts_enabled;
-	unsigned int keycode_table_bytes; /* size of following array */
+	/* size of following array */
+	unsigned int keycode_table_bytes;
 	/* for keyboard devices: visorkbd_keycode[] + visorkbd_ext_keycode[] */
 	unsigned char keycode_table[0];
 };
@@ -162,9 +164,8 @@ static const unsigned char visorkbd_keycode[KEYCODE_TABLE_BYTES] = {
 	[81] = KEY_KP3,
 	[82] = KEY_KP0,
 	[83] = KEY_KPDOT,
-	[86] = KEY_102ND, /* enables UK backslash+pipe key,
-			   * and FR lessthan+greaterthan key
-			   */
+	/* enables UK backslash+pipe key and FR lessthan+greaterthan key */
+	[86] = KEY_102ND,
 	[87] = KEY_F11,
 	[88] = KEY_F12,
 	[90] = KEY_KPLEFTPAREN,
@@ -302,7 +303,8 @@ setup_client_keyboard(void *devdata,  /* opaque on purpose */
 				    BIT_MASK(LED_SCROLLL) |
 				    BIT_MASK(LED_NUML);
 	visorinput_dev->keycode = keycode_table;
-	visorinput_dev->keycodesize = 1; /* sizeof(unsigned char) */
+	/* sizeof(unsigned char) */
+	visorinput_dev->keycodesize = 1;
 	visorinput_dev->keycodemax = KEYCODE_TABLE_BYTES;
 
 	for (i = 1; i < visorinput_dev->keycodemax; i++)
@@ -313,7 +315,8 @@ setup_client_keyboard(void *devdata,  /* opaque on purpose */
 
 	visorinput_dev->open = visorinput_open;
 	visorinput_dev->close = visorinput_close;
-	input_set_drvdata(visorinput_dev, devdata); /* pre input_register! */
+	/* pre input_register! */
+	input_set_drvdata(visorinput_dev, devdata);
 
 	return visorinput_dev;
 }
@@ -354,7 +357,8 @@ setup_client_mouse(void *devdata /* opaque on purpose */)
 
 	visorinput_dev->open = visorinput_open;
 	visorinput_dev->close = visorinput_close;
-	input_set_drvdata(visorinput_dev, devdata); /* pre input_register! */
+	/* pre input_register! */
+	input_set_drvdata(visorinput_dev, devdata);
 	input_set_capability(visorinput_dev, EV_REL, REL_WHEEL);
 
 	return visorinput_dev;

commit bac41a2f682f1e9f8e3aec889ed481d92cc7dadf
Author: Sameer Wadgaonkar <sameer.wadgaonkar@unisys.com>
Date:   Fri May 19 16:17:53 2017 -0400

    staging: unisys: visorinput: removed enum in ultrainputreport.h to match driver namespace
    
    Removed enum ultra_inputaction in ultrainputreport.h and changed
    elements to #defnes.
    
    Signed-off-by: Sameer Wadgaonkar <sameer.wadgaonkar@unisys.com>
    Signed-off-by: David Kershner <david.kershner@unisys.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/unisys/visorinput/visorinput.c b/drivers/staging/unisys/visorinput/visorinput.c
index 4eaaa76f2347..45bc340d4e9d 100644
--- a/drivers/staging/unisys/visorinput/visorinput.c
+++ b/drivers/staging/unisys/visorinput/visorinput.c
@@ -582,46 +582,46 @@ visorinput_channel_interrupt(struct visor_device *dev)
 		scancode = r.activity.arg1;
 		keycode = scancode_to_keycode(scancode);
 		switch (r.activity.action) {
-		case inputaction_key_down:
+		case INPUTACTION_KEY_DOWN:
 			input_report_key(visorinput_dev, keycode, 1);
 			input_sync(visorinput_dev);
 			break;
-		case inputaction_key_up:
+		case INPUTACTION_KEY_UP:
 			input_report_key(visorinput_dev, keycode, 0);
 			input_sync(visorinput_dev);
 			break;
-		case inputaction_key_down_up:
+		case INPUTACTION_KEY_DOWN_UP:
 			input_report_key(visorinput_dev, keycode, 1);
 			input_sync(visorinput_dev);
 			input_report_key(visorinput_dev, keycode, 0);
 			input_sync(visorinput_dev);
 			break;
-		case inputaction_set_locking_key_state:
+		case INPUTACTION_SET_LOCKING_KEY_STATE:
 			handle_locking_key(visorinput_dev, keycode,
 					   r.activity.arg2);
 			break;
-		case inputaction_xy_motion:
+		case INPUTACTION_XY_MOTION:
 			xmotion = r.activity.arg1;
 			ymotion = r.activity.arg2;
 			input_report_abs(visorinput_dev, ABS_X, xmotion);
 			input_report_abs(visorinput_dev, ABS_Y, ymotion);
 			input_sync(visorinput_dev);
 			break;
-		case inputaction_mouse_button_down:
+		case INPUTACTION_MOUSE_BUTTON_DOWN:
 			button = calc_button(r.activity.arg1);
 			if (button < 0)
 				break;
 			input_report_key(visorinput_dev, button, 1);
 			input_sync(visorinput_dev);
 			break;
-		case inputaction_mouse_button_up:
+		case INPUTACTION_MOUSE_BUTTON_UP:
 			button = calc_button(r.activity.arg1);
 			if (button < 0)
 				break;
 			input_report_key(visorinput_dev, button, 0);
 			input_sync(visorinput_dev);
 			break;
-		case inputaction_mouse_button_click:
+		case INPUTACTION_MOUSE_BUTTON_CLICK:
 			button = calc_button(r.activity.arg1);
 			if (button < 0)
 				break;
@@ -631,7 +631,7 @@ visorinput_channel_interrupt(struct visor_device *dev)
 			input_report_key(visorinput_dev, button, 0);
 			input_sync(visorinput_dev);
 			break;
-		case inputaction_mouse_button_dclick:
+		case INPUTACTION_MOUSE_BUTTON_DCLICK:
 			button = calc_button(r.activity.arg1);
 			if (button < 0)
 				break;
@@ -642,11 +642,11 @@ visorinput_channel_interrupt(struct visor_device *dev)
 				input_sync(visorinput_dev);
 			}
 			break;
-		case inputaction_wheel_rotate_away:
+		case INPUTACTION_WHEEL_ROTATE_AWAY:
 			input_report_rel(visorinput_dev, REL_WHEEL, 1);
 			input_sync(visorinput_dev);
 			break;
-		case inputaction_wheel_rotate_toward:
+		case INPUTACTION_WHEEL_ROTATE_TOWARD:
 			input_report_rel(visorinput_dev, REL_WHEEL, -1);
 			input_sync(visorinput_dev);
 			break;

commit c2093c804cf72266fbd35ce4edcfcbe36ef0cc9a
Author: Sameer Wadgaonkar <sameer.wadgaonkar@unisys.com>
Date:   Fri May 19 16:17:52 2017 -0400

    staging: unisys: visorinput: renamed structures in ultrainputreport.h to match driver namespace
    
    Renamed structures
    * ultra_inputactivity to visor_inputactivity
    * ultra_inputreport to visor_inputreport
    
    Signed-off-by: Sameer Wadgaonkar <sameer.wadgaonkar@unisys.com>
    Signed-off-by: David Kershner <david.kershner@unisys.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/unisys/visorinput/visorinput.c b/drivers/staging/unisys/visorinput/visorinput.c
index 2fc9ea1221e6..4eaaa76f2347 100644
--- a/drivers/staging/unisys/visorinput/visorinput.c
+++ b/drivers/staging/unisys/visorinput/visorinput.c
@@ -565,7 +565,7 @@ calc_button(int x)
 static void
 visorinput_channel_interrupt(struct visor_device *dev)
 {
-	struct ultra_inputreport r;
+	struct visor_inputreport r;
 	int scancode, keycode;
 	struct input_dev *visorinput_dev;
 	int xmotion, ymotion, button;

commit 785542c6606b986668787c0e819e61eed99edb31
Author: Sameer Wadgaonkar <sameer.wadgaonkar@unisys.com>
Date:   Fri May 19 16:17:51 2017 -0400

    staging: unisys: visorinput: renamed #defines in visorinput.c to match driver namespace
    
    Renamed #defines
    * SPAR_KEYBOARD_CHANNEL_PROTOCOL_UUID to
                    VISOR_KEYBOARD_CHANNEL_UUID
    * SPAR_KEYBOARD_CHANNEL_PROTOCOL_UUID_STR to
                    VISOR_KEYBOARD_CHANNEL_UUID_STR
    * SPAR_MOUSE_CHANNEL_PROTOCOL_UUID to
                    VISOR_MOUSE_CHANNEL_UUID
    * SPAR_MOUSE_CHANNEL_PROTOCOL_UUID_STR to
                    VISOR_MOUSE_CHANNEL_UUID_STR
    
    Signed-off-by: Sameer Wadgaonkar <sameer.wadgaonkar@unisys.com>
    Signed-off-by: David Kershner <david.kershner@unisys.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/unisys/visorinput/visorinput.c b/drivers/staging/unisys/visorinput/visorinput.c
index cdd35437f0a0..2fc9ea1221e6 100644
--- a/drivers/staging/unisys/visorinput/visorinput.c
+++ b/drivers/staging/unisys/visorinput/visorinput.c
@@ -33,17 +33,16 @@
 #include "ultrainputreport.h"
 
 /* Keyboard channel {c73416d0-b0b8-44af-b304-9d2ae99f1b3d} */
-#define SPAR_KEYBOARD_CHANNEL_PROTOCOL_UUID \
+#define VISOR_KEYBOARD_CHANNEL_UUID \
 	UUID_LE(0xc73416d0, 0xb0b8, 0x44af, \
 		0xb3, 0x4, 0x9d, 0x2a, 0xe9, 0x9f, 0x1b, 0x3d)
-#define SPAR_KEYBOARD_CHANNEL_PROTOCOL_UUID_STR "c73416d0-b0b8-44af-b304-9d2ae99f1b3d"
+#define VISOR_KEYBOARD_CHANNEL_UUID_STR "c73416d0-b0b8-44af-b304-9d2ae99f1b3d"
 
 /* Mouse channel {addf07d4-94a9-46e2-81c3-61abcdbdbd87} */
-#define SPAR_MOUSE_CHANNEL_PROTOCOL_UUID \
+#define VISOR_MOUSE_CHANNEL_UUID \
 	UUID_LE(0xaddf07d4, 0x94a9, 0x46e2, \
 		0x81, 0xc3, 0x61, 0xab, 0xcd, 0xbd, 0xbd, 0x87)
-#define SPAR_MOUSE_CHANNEL_PROTOCOL_UUID_STR \
-	"addf07d4-94a9-46e2-81c3-61abcdbdbd87"
+#define VISOR_MOUSE_CHANNEL_UUID_STR "addf07d4-94a9-46e2-81c3-61abcdbdbd87"
 
 #define PIXELS_ACROSS_DEFAULT 800
 #define PIXELS_DOWN_DEFAULT   600
@@ -70,10 +69,8 @@ struct visorinput_devdata {
 	unsigned char keycode_table[0];
 };
 
-static const uuid_le spar_keyboard_channel_protocol_uuid =
-	SPAR_KEYBOARD_CHANNEL_PROTOCOL_UUID;
-static const uuid_le spar_mouse_channel_protocol_uuid =
-	SPAR_MOUSE_CHANNEL_PROTOCOL_UUID;
+static const uuid_le visor_keyboard_channel_uuid = VISOR_KEYBOARD_CHANNEL_UUID;
+static const uuid_le visor_mouse_channel_uuid = VISOR_MOUSE_CHANNEL_UUID;
 
 /*
  * Borrowed from drivers/input/keyboard/atakbd.c
@@ -456,9 +453,9 @@ visorinput_probe(struct visor_device *dev)
 	enum visorinput_device_type devtype;
 
 	guid = visorchannel_get_uuid(dev->visorchannel);
-	if (uuid_le_cmp(guid, spar_mouse_channel_protocol_uuid) == 0)
+	if (uuid_le_cmp(guid, visor_mouse_channel_uuid) == 0)
 		devtype = visorinput_mouse;
-	else if (uuid_le_cmp(guid, spar_keyboard_channel_protocol_uuid) == 0)
+	else if (uuid_le_cmp(guid, visor_keyboard_channel_uuid) == 0)
 		devtype = visorinput_keyboard;
 	else
 		return -ENODEV;
@@ -730,8 +727,8 @@ visorinput_resume(struct visor_device *dev,
 
 /* GUIDS for all channel types supported by this driver. */
 static struct visor_channeltype_descriptor visorinput_channel_types[] = {
-	{ SPAR_KEYBOARD_CHANNEL_PROTOCOL_UUID, "keyboard"},
-	{ SPAR_MOUSE_CHANNEL_PROTOCOL_UUID, "mouse"},
+	{ VISOR_KEYBOARD_CHANNEL_UUID, "keyboard"},
+	{ VISOR_MOUSE_CHANNEL_UUID, "mouse"},
 	{ NULL_UUID_LE, NULL }
 };
 
@@ -767,5 +764,5 @@ MODULE_AUTHOR("Unisys");
 MODULE_LICENSE("GPL");
 MODULE_DESCRIPTION("s-Par human input driver for virtual keyboard/mouse");
 
-MODULE_ALIAS("visorbus:" SPAR_MOUSE_CHANNEL_PROTOCOL_UUID_STR);
-MODULE_ALIAS("visorbus:" SPAR_KEYBOARD_CHANNEL_PROTOCOL_UUID_STR);
+MODULE_ALIAS("visorbus:" VISOR_MOUSE_CHANNEL_UUID_STR);
+MODULE_ALIAS("visorbus:" VISOR_KEYBOARD_CHANNEL_UUID_STR);

commit b9b2c242fabcf5cb82cfe27d8ff20b7116cf391c
Author: David Binder <david.binder@unisys.com>
Date:   Fri Mar 17 11:27:23 2017 -0400

    staging: unisys: visorinput: visorinput.c: Fix #define formatting
    
    In an effort to create a more uniform coding style within the Unisys
    s-Par driver set, this patch adjusts the formatting of all #define
    directives within this source file to match the following template,
    and thereby eliminate irregular usage of whitespace:
    Reviewed-by: Tim Sell <timothy.sell@unisys.com>
    
    The amount of whitespace used between the <token> and the <value> is
    dependent on what is needed to make the surrounding #define directives
    as uniform as possible.
    
    Signed-off-by: David Binder <david.binder@unisys.com>
    Signed-off-by: David Kershner <david.kershner@unisys.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/unisys/visorinput/visorinput.c b/drivers/staging/unisys/visorinput/visorinput.c
index 3fc7d9e2db14..cdd35437f0a0 100644
--- a/drivers/staging/unisys/visorinput/visorinput.c
+++ b/drivers/staging/unisys/visorinput/visorinput.c
@@ -33,21 +33,21 @@
 #include "ultrainputreport.h"
 
 /* Keyboard channel {c73416d0-b0b8-44af-b304-9d2ae99f1b3d} */
-#define SPAR_KEYBOARD_CHANNEL_PROTOCOL_UUID				\
-	UUID_LE(0xc73416d0, 0xb0b8, 0x44af,				\
+#define SPAR_KEYBOARD_CHANNEL_PROTOCOL_UUID \
+	UUID_LE(0xc73416d0, 0xb0b8, 0x44af, \
 		0xb3, 0x4, 0x9d, 0x2a, 0xe9, 0x9f, 0x1b, 0x3d)
 #define SPAR_KEYBOARD_CHANNEL_PROTOCOL_UUID_STR "c73416d0-b0b8-44af-b304-9d2ae99f1b3d"
 
 /* Mouse channel {addf07d4-94a9-46e2-81c3-61abcdbdbd87} */
-#define SPAR_MOUSE_CHANNEL_PROTOCOL_UUID  \
+#define SPAR_MOUSE_CHANNEL_PROTOCOL_UUID \
 	UUID_LE(0xaddf07d4, 0x94a9, 0x46e2, \
 		0x81, 0xc3, 0x61, 0xab, 0xcd, 0xbd, 0xbd, 0x87)
 #define SPAR_MOUSE_CHANNEL_PROTOCOL_UUID_STR \
 	"addf07d4-94a9-46e2-81c3-61abcdbdbd87"
 
-#define PIXELS_ACROSS_DEFAULT	800
-#define PIXELS_DOWN_DEFAULT	600
-#define KEYCODE_TABLE_BYTES	256
+#define PIXELS_ACROSS_DEFAULT 800
+#define PIXELS_DOWN_DEFAULT   600
+#define KEYCODE_TABLE_BYTES   256
 
 enum visorinput_device_type {
 	visorinput_keyboard,

commit f1844d1bcd5cde311f01e68f974e04d5db3c4f9a
Author: David Binder <david.binder@unisys.com>
Date:   Fri Mar 17 11:27:08 2017 -0400

    staging: unisys: visorinput: Remove unnecessary usage of local variable
    
    Remove local variable on stack by directly returning the value in the
    array.
    
    Signed-off-by: David Binder <david.binder@unisys.com>
    Signed-off-by: David Kershner <david.kershner@unisys.com>
    Reviewed-by: Tim Sell <timothy.sell@unisys.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/unisys/visorinput/visorinput.c b/drivers/staging/unisys/visorinput/visorinput.c
index 949cce680b29..3fc7d9e2db14 100644
--- a/drivers/staging/unisys/visorinput/visorinput.c
+++ b/drivers/staging/unisys/visorinput/visorinput.c
@@ -539,13 +539,10 @@ handle_locking_key(struct input_dev *visorinput_dev,
 static int
 scancode_to_keycode(int scancode)
 {
-	int keycode;
-
 	if (scancode > 0xff)
-		keycode = visorkbd_ext_keycode[(scancode >> 8) & 0xff];
-	else
-		keycode = visorkbd_keycode[scancode];
-	return keycode;
+		return visorkbd_ext_keycode[(scancode >> 8) & 0xff];
+
+	return  visorkbd_keycode[scancode];
 }
 
 static int

commit a4e93a694877b68b88eb6e06442ad904809eef51
Author: David Binder <david.binder@unisys.com>
Date:   Thu Nov 3 11:44:29 2016 -0400

    staging: unisys: visorinput: Add default conditions to case statements
    
    This commit adds a default condition to those case statements that do not
    already have one. This is done to provide both a logical covering of all
    conditions, as well as to maintain uniformity with the rest of the Unisys
    driver set.
    
    Signed-off-by: David Binder <david.binder@unisys.com>
    Signed-off-by: David Kershner <david.kershner@unisys.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/unisys/visorinput/visorinput.c b/drivers/staging/unisys/visorinput/visorinput.c
index 6f94b646f7c5..949cce680b29 100644
--- a/drivers/staging/unisys/visorinput/visorinput.c
+++ b/drivers/staging/unisys/visorinput/visorinput.c
@@ -409,6 +409,9 @@ devdata_create(struct visor_device *dev, enum visorinput_device_type devtype)
 		if (!devdata->visorinput_dev)
 			goto cleanups_register;
 		break;
+	default:
+		/* No other input devices supported */
+		break;
 	}
 
 	dev_set_drvdata(&dev->device, devdata);
@@ -653,6 +656,9 @@ visorinput_channel_interrupt(struct visor_device *dev)
 			input_report_rel(visorinput_dev, REL_WHEEL, -1);
 			input_sync(visorinput_dev);
 			break;
+		default:
+			/* Unsupported input action */
+			break;
 		}
 	}
 }

commit f621a96850c262b7de42bd06eae4edd5bfd099d8
Author: David Binder <david.binder@unisys.com>
Date:   Mon Sep 26 11:03:48 2016 -0400

    staging: unisys: visorbus: Convert visorchannel_signalremove() return val
    
    Per Documentation/CodingStyle, function names that convey an action or an
    imperative command should return an integer. This commit converts the
    visorbus API function, visorchannel_signalremove(), to returning integer
    values. All uses of this function are updated accordingly.
    
    Signed-off-by: David Binder <david.binder@unisys.com>
    Signed-off-by: David Kershner <david.kershner@unisys.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/unisys/visorinput/visorinput.c b/drivers/staging/unisys/visorinput/visorinput.c
index aa44414f4bce..6f94b646f7c5 100644
--- a/drivers/staging/unisys/visorinput/visorinput.c
+++ b/drivers/staging/unisys/visorinput/visorinput.c
@@ -581,7 +581,7 @@ visorinput_channel_interrupt(struct visor_device *dev)
 
 	visorinput_dev = devdata->visorinput_dev;
 
-	while (visorchannel_signalremove(dev->visorchannel, 0, &r)) {
+	while (!visorchannel_signalremove(dev->visorchannel, 0, &r)) {
 		scancode = r.activity.arg1;
 		keycode = scancode_to_keycode(scancode);
 		switch (r.activity.action) {

commit bff8c1a1604a73ce0e6d5182e441b97be563fcd4
Author: Jon Frisch <jon.frisch@unisys.com>
Date:   Mon Sep 26 11:03:46 2016 -0400

    staging: unisys: make MODULE_DESCRIPTIONs consistent
    
    This patch ensures that consistent verbiage is used in the
    MODULE_DESCRIPTION text (reported by 'modinfo') for all of
    the Unisys s-Par drivers.
    
    Signed-off-by: Jon Frisch <jon.frisch@unisys.com>
    Signed-off-by: David Kershner <david.kershner@unisys.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/unisys/visorinput/visorinput.c b/drivers/staging/unisys/visorinput/visorinput.c
index afdf2b503b82..aa44414f4bce 100644
--- a/drivers/staging/unisys/visorinput/visorinput.c
+++ b/drivers/staging/unisys/visorinput/visorinput.c
@@ -762,7 +762,7 @@ MODULE_DEVICE_TABLE(visorbus, visorinput_channel_types);
 
 MODULE_AUTHOR("Unisys");
 MODULE_LICENSE("GPL");
-MODULE_DESCRIPTION("s-Par human input driver for guest Linux");
+MODULE_DESCRIPTION("s-Par human input driver for virtual keyboard/mouse");
 
 MODULE_ALIAS("visorbus:" SPAR_MOUSE_CHANNEL_PROTOCOL_UUID_STR);
 MODULE_ALIAS("visorbus:" SPAR_KEYBOARD_CHANNEL_PROTOCOL_UUID_STR);

commit 87932da6d3fe706be83033a421bd353f3606c7c7
Author: Jon Frisch <jon.frisch@unisys.com>
Date:   Mon Sep 26 11:03:43 2016 -0400

    staging: unisys: visorinput: remove driver version from visorinput.c
    
    This patch removes the driver version and the version.h include
    from visorinput.c
    
    Signed-off-by: Jon Frisch <jon.frisch@unisys.com>
    Reported-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: David Kershner <david.kershner@unisys.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/unisys/visorinput/visorinput.c b/drivers/staging/unisys/visorinput/visorinput.c
index 4e0b26d2b6f7..afdf2b503b82 100644
--- a/drivers/staging/unisys/visorinput/visorinput.c
+++ b/drivers/staging/unisys/visorinput/visorinput.c
@@ -29,7 +29,6 @@
 #include <linux/kernel.h>
 #include <linux/uuid.h>
 
-#include "version.h"
 #include "visorbus.h"
 #include "ultrainputreport.h"
 
@@ -764,7 +763,6 @@ MODULE_DEVICE_TABLE(visorbus, visorinput_channel_types);
 MODULE_AUTHOR("Unisys");
 MODULE_LICENSE("GPL");
 MODULE_DESCRIPTION("s-Par human input driver for guest Linux");
-MODULE_VERSION(VERSION);
 
 MODULE_ALIAS("visorbus:" SPAR_MOUSE_CHANNEL_PROTOCOL_UUID_STR);
 MODULE_ALIAS("visorbus:" SPAR_KEYBOARD_CHANNEL_PROTOCOL_UUID_STR);

commit e82ed633eb814f25861d8942ed33881e4b36d5c4
Author: Jon Frisch <jon.frisch@unisys.com>
Date:   Mon Sep 26 11:03:41 2016 -0400

    staging: unisys: remove driver version from struct visor_driver
    
    This patch removes the all instances of the driver version from
    struct visor_driver. This includes removing version, vertag
    (a human readable version string of the driver version) and
    version_attr from struct visor_driver. This resulted in removing the
    bus attributes and driver attributes which only contained the driver
    version. The utsname function is used to replace the driver version
    with the kernel version in bus_device_info_init().
    
    Signed-off-by: Jon Frisch <jon.frisch@unisys.com>
    Reported-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: David Kershner <david.kershner@unisys.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/unisys/visorinput/visorinput.c b/drivers/staging/unisys/visorinput/visorinput.c
index 641cdab34449..4e0b26d2b6f7 100644
--- a/drivers/staging/unisys/visorinput/visorinput.c
+++ b/drivers/staging/unisys/visorinput/visorinput.c
@@ -735,7 +735,6 @@ static struct visor_channeltype_descriptor visorinput_channel_types[] = {
 
 static struct visor_driver visorinput_driver = {
 	.name = "visorinput",
-	.vertag = NULL,
 	.owner = THIS_MODULE,
 	.channel_types = visorinput_channel_types,
 	.probe = visorinput_probe,

commit d7cbd9f6c4cdb379ebd04cda9cfce1bbf6442e26
Author: Bryan Thompson <bryan.thompson@unisys.com>
Date:   Fri Sep 2 16:41:34 2016 -0400

    staging: unisys: visorinput: Update visorinput.c includes
    
    Remove unnecessary channel.h include from visorinput.c.
    
    Signed-off-by: Bryan Thompson <bryan.thompson@unisys.com>
    Signed-off-by: David Kershner <david.kershner@unisys.com>
    Reviewed-by: Tim Sell <Timothy.Sell@unisys.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/unisys/visorinput/visorinput.c b/drivers/staging/unisys/visorinput/visorinput.c
index 2aff9457b7e6..641cdab34449 100644
--- a/drivers/staging/unisys/visorinput/visorinput.c
+++ b/drivers/staging/unisys/visorinput/visorinput.c
@@ -31,7 +31,6 @@
 
 #include "version.h"
 #include "visorbus.h"
-#include "channel.h"
 #include "ultrainputreport.h"
 
 /* Keyboard channel {c73416d0-b0b8-44af-b304-9d2ae99f1b3d} */

commit 8dfb8fdbd2d1dd4facef6eef24a26b6bc1b33191
Author: Tim Sell <Timothy.Sell@unisys.com>
Date:   Fri Jun 10 21:48:26 2016 -0400

    staging: unisys: visorinput: make lock_visor_dev a mutex
    
    Since lock_visor_dev is a binary semaphore it makes more sense to
    use a mutex lock.
    
    Signed-off-by: Tim Sell <Timothy.Sell@unisys.com>
    Signed-off-by: David Kershner <david.kershner@unisys.com>
    Acked-By: Neil Horman <nhorman@tuxdriver.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/unisys/visorinput/visorinput.c b/drivers/staging/unisys/visorinput/visorinput.c
index c13e69841319..2aff9457b7e6 100644
--- a/drivers/staging/unisys/visorinput/visorinput.c
+++ b/drivers/staging/unisys/visorinput/visorinput.c
@@ -63,7 +63,7 @@ enum visorinput_device_type {
  */
 struct visorinput_devdata {
 	struct visor_device *dev;
-	struct rw_semaphore lock_visor_dev; /* lock for dev */
+	struct mutex lock_visor_dev; /* lock for dev */
 	struct input_dev *visorinput_dev;
 	bool paused;
 	bool interrupts_enabled;
@@ -236,14 +236,14 @@ static int visorinput_open(struct input_dev *visorinput_dev)
 	 * interrupts should be enabled so when we resume, interrupts
 	 * will really be enabled.
 	 */
-	down_write(&devdata->lock_visor_dev);
+	mutex_lock(&devdata->lock_visor_dev);
 	devdata->interrupts_enabled = true;
 	if (devdata->paused)
 		goto out_unlock;
 	visorbus_enable_channel_interrupts(devdata->dev);
 
 out_unlock:
-	up_write(&devdata->lock_visor_dev);
+	mutex_unlock(&devdata->lock_visor_dev);
 	return 0;
 }
 
@@ -266,14 +266,14 @@ static void visorinput_close(struct input_dev *visorinput_dev)
 	 * not re-enable them.
 	 */
 
-	down_write(&devdata->lock_visor_dev);
+	mutex_lock(&devdata->lock_visor_dev);
 	devdata->interrupts_enabled = false;
 	if (devdata->paused)
 		goto out_unlock;
 	visorbus_disable_channel_interrupts(devdata->dev);
 
 out_unlock:
-	up_write(&devdata->lock_visor_dev);
+	mutex_unlock(&devdata->lock_visor_dev);
 }
 
 /*
@@ -377,8 +377,8 @@ devdata_create(struct visor_device *dev, enum visorinput_device_type devtype)
 	devdata = kzalloc(sizeof(*devdata) + extra_bytes, GFP_KERNEL);
 	if (!devdata)
 		return NULL;
-	init_rwsem(&devdata->lock_visor_dev);
-	down_write(&devdata->lock_visor_dev);
+	mutex_init(&devdata->lock_visor_dev);
+	mutex_lock(&devdata->lock_visor_dev);
 	devdata->dev = dev;
 
 	/*
@@ -414,7 +414,7 @@ devdata_create(struct visor_device *dev, enum visorinput_device_type devtype)
 	}
 
 	dev_set_drvdata(&dev->device, devdata);
-	up_write(&devdata->lock_visor_dev);
+	mutex_unlock(&devdata->lock_visor_dev);
 
 	/*
 	 * Device struct is completely set up now, with the exception of
@@ -428,7 +428,7 @@ devdata_create(struct visor_device *dev, enum visorinput_device_type devtype)
 		goto err_kfree_devdata;
 	}
 
-	down_write(&devdata->lock_visor_dev);
+	mutex_lock(&devdata->lock_visor_dev);
 	/*
 	 * Establish calls to visorinput_channel_interrupt() if that is
 	 * the desired state that we've kept track of in interrupts_enabled
@@ -437,12 +437,12 @@ devdata_create(struct visor_device *dev, enum visorinput_device_type devtype)
 	devdata->paused = false;
 	if (devdata->interrupts_enabled)
 		visorbus_enable_channel_interrupts(dev);
-	up_write(&devdata->lock_visor_dev);
+	mutex_unlock(&devdata->lock_visor_dev);
 
 	return devdata;
 
 cleanups_register:
-	up_write(&devdata->lock_visor_dev);
+	mutex_unlock(&devdata->lock_visor_dev);
 err_kfree_devdata:
 	kfree(devdata);
 	return NULL;
@@ -482,7 +482,7 @@ visorinput_remove(struct visor_device *dev)
 	if (!devdata)
 		return;
 
-	down_write(&devdata->lock_visor_dev);
+	mutex_lock(&devdata->lock_visor_dev);
 	visorbus_disable_channel_interrupts(dev);
 
 	/*
@@ -491,7 +491,7 @@ visorinput_remove(struct visor_device *dev)
 	 */
 
 	dev_set_drvdata(&dev->device, NULL);
-	up_write(&devdata->lock_visor_dev);
+	mutex_unlock(&devdata->lock_visor_dev);
 
 	unregister_client_input(devdata->visorinput_dev);
 	kfree(devdata);
@@ -671,7 +671,7 @@ visorinput_pause(struct visor_device *dev,
 		goto out;
 	}
 
-	down_write(&devdata->lock_visor_dev);
+	mutex_lock(&devdata->lock_visor_dev);
 	if (devdata->paused) {
 		rc = -EBUSY;
 		goto out_locked;
@@ -688,7 +688,7 @@ visorinput_pause(struct visor_device *dev,
 	complete_func(dev, 0);
 	rc = 0;
 out_locked:
-	up_write(&devdata->lock_visor_dev);
+	mutex_unlock(&devdata->lock_visor_dev);
 out:
 	return rc;
 }
@@ -704,7 +704,7 @@ visorinput_resume(struct visor_device *dev,
 		rc = -ENODEV;
 		goto out;
 	}
-	down_write(&devdata->lock_visor_dev);
+	mutex_lock(&devdata->lock_visor_dev);
 	if (!devdata->paused) {
 		rc = -EBUSY;
 		goto out_locked;
@@ -722,7 +722,7 @@ visorinput_resume(struct visor_device *dev,
 
 	rc = 0;
 out_locked:
-	up_write(&devdata->lock_visor_dev);
+	mutex_unlock(&devdata->lock_visor_dev);
 out:
 	return rc;
 }

commit 24ce1b66619c499f5913eac5debf9170f7a9dcc3
Author: Tim Sell <Timothy.Sell@unisys.com>
Date:   Fri Jun 10 21:48:25 2016 -0400

    staging: unisys: visorinput: ensure proper locking wrt creation & ints
    
    Ensure we properly lock between visorinput_channel_interrupt(),
    visorinput_open(), and devdata_create().  We now guarantee that:
    
    * interrupts will be disabled and remain disabled during device creation,
      by setting 'paused = true' across device creation
    
    * we canNOT get into visorinput_open() until the device structure is
      totally initialized, by delaying the input_register_device() until the
      end of device initialization
    
    We also now ensure that lock_visor_dev is held across updates of devdata
    state, to ensure state consistency.
    
    Signed-off-by: Tim Sell <Timothy.Sell@unisys.com>
    Signed-off-by: David Kershner <david.kershner@unisys.com>
    Acked-By: Neil Horman <nhorman@tuxdriver.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/unisys/visorinput/visorinput.c b/drivers/staging/unisys/visorinput/visorinput.c
index f633985fd583..c13e69841319 100644
--- a/drivers/staging/unisys/visorinput/visorinput.c
+++ b/drivers/staging/unisys/visorinput/visorinput.c
@@ -277,16 +277,16 @@ static void visorinput_close(struct input_dev *visorinput_dev)
 }
 
 /*
- * register_client_keyboard() initializes and returns a Linux input node that
+ * setup_client_keyboard() initializes and returns a Linux input node that
  * we can use to deliver keyboard inputs to Linux.  We of course do this when
  * we see keyboard inputs coming in on a keyboard channel.
  */
 static struct input_dev *
-register_client_keyboard(void *devdata,  /* opaque on purpose */
-			 unsigned char *keycode_table)
+setup_client_keyboard(void *devdata,  /* opaque on purpose */
+		      unsigned char *keycode_table)
 
 {
-	int i, error;
+	int i;
 	struct input_dev *visorinput_dev;
 
 	visorinput_dev = input_allocate_device();
@@ -320,18 +320,12 @@ register_client_keyboard(void *devdata,  /* opaque on purpose */
 	visorinput_dev->close = visorinput_close;
 	input_set_drvdata(visorinput_dev, devdata); /* pre input_register! */
 
-	error = input_register_device(visorinput_dev);
-	if (error) {
-		input_free_device(visorinput_dev);
-		return NULL;
-	}
 	return visorinput_dev;
 }
 
 static struct input_dev *
-register_client_mouse(void *devdata /* opaque on purpose */)
+setup_client_mouse(void *devdata /* opaque on purpose */)
 {
-	int error;
 	struct input_dev *visorinput_dev = NULL;
 	int xres, yres;
 	struct fb_info *fb0;
@@ -366,13 +360,6 @@ register_client_mouse(void *devdata /* opaque on purpose */)
 	visorinput_dev->open = visorinput_open;
 	visorinput_dev->close = visorinput_close;
 	input_set_drvdata(visorinput_dev, devdata); /* pre input_register! */
-
-	error = input_register_device(visorinput_dev);
-	if (error) {
-		input_free_device(visorinput_dev);
-		return NULL;
-	}
-
 	input_set_capability(visorinput_dev, EV_REL, REL_WHEEL);
 
 	return visorinput_dev;
@@ -390,8 +377,18 @@ devdata_create(struct visor_device *dev, enum visorinput_device_type devtype)
 	devdata = kzalloc(sizeof(*devdata) + extra_bytes, GFP_KERNEL);
 	if (!devdata)
 		return NULL;
+	init_rwsem(&devdata->lock_visor_dev);
+	down_write(&devdata->lock_visor_dev);
 	devdata->dev = dev;
 
+	/*
+	 * visorinput_open() can be called as soon as input_register_device()
+	 * happens, and that will enable channel interrupts.  Setting paused
+	 * prevents us from getting into visorinput_channel_interrupt() prior
+	 * to the device structure being totally initialized.
+	 */
+	devdata->paused = true;
+
 	/*
 	 * This is an input device in a client guest partition,
 	 * so we need to create whatever input nodes are necessary to
@@ -404,23 +401,49 @@ devdata_create(struct visor_device *dev, enum visorinput_device_type devtype)
 		       KEYCODE_TABLE_BYTES);
 		memcpy(devdata->keycode_table + KEYCODE_TABLE_BYTES,
 		       visorkbd_ext_keycode, KEYCODE_TABLE_BYTES);
-		devdata->visorinput_dev = register_client_keyboard
+		devdata->visorinput_dev = setup_client_keyboard
 			(devdata, devdata->keycode_table);
 		if (!devdata->visorinput_dev)
 			goto cleanups_register;
 		break;
 	case visorinput_mouse:
-		devdata->visorinput_dev = register_client_mouse(devdata);
+		devdata->visorinput_dev = setup_client_mouse(devdata);
 		if (!devdata->visorinput_dev)
 			goto cleanups_register;
 		break;
 	}
 
-	init_rwsem(&devdata->lock_visor_dev);
+	dev_set_drvdata(&dev->device, devdata);
+	up_write(&devdata->lock_visor_dev);
+
+	/*
+	 * Device struct is completely set up now, with the exception of
+	 * visorinput_dev being registered.
+	 * We need to unlock before we register the device, because this
+	 * can cause an on-stack call of visorinput_open(), which would
+	 * deadlock if we had the lock.
+	 */
+	if (input_register_device(devdata->visorinput_dev)) {
+		input_free_device(devdata->visorinput_dev);
+		goto err_kfree_devdata;
+	}
+
+	down_write(&devdata->lock_visor_dev);
+	/*
+	 * Establish calls to visorinput_channel_interrupt() if that is
+	 * the desired state that we've kept track of in interrupts_enabled
+	 * while the device was being created.
+	 */
+	devdata->paused = false;
+	if (devdata->interrupts_enabled)
+		visorbus_enable_channel_interrupts(dev);
+	up_write(&devdata->lock_visor_dev);
 
 	return devdata;
 
 cleanups_register:
+	up_write(&devdata->lock_visor_dev);
+err_kfree_devdata:
 	kfree(devdata);
 	return NULL;
 }
@@ -428,7 +451,6 @@ devdata_create(struct visor_device *dev, enum visorinput_device_type devtype)
 static int
 visorinput_probe(struct visor_device *dev)
 {
-	struct visorinput_devdata *devdata = NULL;
 	uuid_le guid;
 	enum visorinput_device_type devtype;
 
@@ -439,10 +461,9 @@ visorinput_probe(struct visor_device *dev)
 		devtype = visorinput_keyboard;
 	else
 		return -ENODEV;
-	devdata = devdata_create(dev, devtype);
-	if (!devdata)
+	visorbus_disable_channel_interrupts(dev);
+	if (!devdata_create(dev, devtype))
 		return -ENOMEM;
-	dev_set_drvdata(&dev->device, devdata);
 	return 0;
 }
 
@@ -461,6 +482,7 @@ visorinput_remove(struct visor_device *dev)
 	if (!devdata)
 		return;
 
+	down_write(&devdata->lock_visor_dev);
 	visorbus_disable_channel_interrupts(dev);
 
 	/*
@@ -469,6 +491,8 @@ visorinput_remove(struct visor_device *dev)
 	 */
 
 	dev_set_drvdata(&dev->device, NULL);
+	up_write(&devdata->lock_visor_dev);
+
 	unregister_client_input(devdata->visorinput_dev);
 	kfree(devdata);
 }

commit 83011b6cbe7c597c73b31c41021dc71f78dcef7b
Author: Tim Sell <Timothy.Sell@unisys.com>
Date:   Fri Jun 10 21:48:07 2016 -0400

    staging: unisys: visorinput: remove unnecessary locking
    
    Locking in the _interrupt() function is NOT necessary so long as we ensure
    that interrupts have been stopped whenever we need to pause or resume the
    device, which we now do.
    
    While a device is paused, we ensure that interrupts stay disabled, i.e.
    that the _interrupt() function will NOT be called, yet remember the desired
    state in devdata->interrupts_enabled if open() or close() are called are
    called while the device is paused.  Then when the device is resumed, we
    restore the actual state of interrupts (i.e., whether _interrupt() is going
    to be called or not) to the desired state in devdata->interrupts_enabled.
    
    Signed-off-by: Tim Sell <Timothy.Sell@unisys.com>
    Signed-off-by: David Kershner <david.kershner@unisys.com>
    Acked-By: Neil Horman <nhorman@tuxdriver.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/unisys/visorinput/visorinput.c b/drivers/staging/unisys/visorinput/visorinput.c
index d67cd76327c0..f633985fd583 100644
--- a/drivers/staging/unisys/visorinput/visorinput.c
+++ b/drivers/staging/unisys/visorinput/visorinput.c
@@ -66,6 +66,7 @@ struct visorinput_devdata {
 	struct rw_semaphore lock_visor_dev; /* lock for dev */
 	struct input_dev *visorinput_dev;
 	bool paused;
+	bool interrupts_enabled;
 	unsigned int keycode_table_bytes; /* size of following array */
 	/* for keyboard devices: visorkbd_keycode[] + visorkbd_ext_keycode[] */
 	unsigned char keycode_table[0];
@@ -228,7 +229,21 @@ static int visorinput_open(struct input_dev *visorinput_dev)
 		return -EINVAL;
 	}
 	dev_dbg(&visorinput_dev->dev, "%s opened\n", __func__);
+
+	/*
+	 * If we're not paused, really enable interrupts.
+	 * Regardless of whether we are paused, set a flag indicating
+	 * interrupts should be enabled so when we resume, interrupts
+	 * will really be enabled.
+	 */
+	down_write(&devdata->lock_visor_dev);
+	devdata->interrupts_enabled = true;
+	if (devdata->paused)
+		goto out_unlock;
 	visorbus_enable_channel_interrupts(devdata->dev);
+
+out_unlock:
+	up_write(&devdata->lock_visor_dev);
 	return 0;
 }
 
@@ -243,7 +258,22 @@ static void visorinput_close(struct input_dev *visorinput_dev)
 		return;
 	}
 	dev_dbg(&visorinput_dev->dev, "%s closed\n", __func__);
+
+	/*
+	 * If we're not paused, really disable interrupts.
+	 * Regardless of whether we are paused, set a flag indicating
+	 * interrupts should be disabled so when we resume we will
+	 * not re-enable them.
+	 */
+
+	down_write(&devdata->lock_visor_dev);
+	devdata->interrupts_enabled = false;
+	if (devdata->paused)
+		goto out_unlock;
 	visorbus_disable_channel_interrupts(devdata->dev);
+
+out_unlock:
+	up_write(&devdata->lock_visor_dev);
 }
 
 /*
@@ -438,10 +468,8 @@ visorinput_remove(struct visor_device *dev)
 	 * in visorinput_channel_interrupt()
 	 */
 
-	down_write(&devdata->lock_visor_dev);
 	dev_set_drvdata(&dev->device, NULL);
 	unregister_client_input(devdata->visorinput_dev);
-	up_write(&devdata->lock_visor_dev);
 	kfree(devdata);
 }
 
@@ -529,13 +557,7 @@ visorinput_channel_interrupt(struct visor_device *dev)
 	if (!devdata)
 		return;
 
-	down_write(&devdata->lock_visor_dev);
-	if (devdata->paused) /* don't touch device/channel when paused */
-		goto out_locked;
-
 	visorinput_dev = devdata->visorinput_dev;
-	if (!visorinput_dev)
-		goto out_locked;
 
 	while (visorchannel_signalremove(dev->visorchannel, 0, &r)) {
 		scancode = r.activity.arg1;
@@ -611,8 +633,6 @@ visorinput_channel_interrupt(struct visor_device *dev)
 			break;
 		}
 	}
-out_locked:
-	up_write(&devdata->lock_visor_dev);
 }
 
 static int
@@ -632,6 +652,14 @@ visorinput_pause(struct visor_device *dev,
 		rc = -EBUSY;
 		goto out_locked;
 	}
+	if (devdata->interrupts_enabled)
+		visorbus_disable_channel_interrupts(dev);
+
+	/*
+	 * due to above, at this time no thread of execution will be
+	 * in visorinput_channel_interrupt()
+	 */
+
 	devdata->paused = true;
 	complete_func(dev, 0);
 	rc = 0;
@@ -659,6 +687,15 @@ visorinput_resume(struct visor_device *dev,
 	}
 	devdata->paused = false;
 	complete_func(dev, 0);
+
+	/*
+	 * Re-establish calls to visorinput_channel_interrupt() if that is
+	 * the desired state that we've kept track of in interrupts_enabled
+	 * while the device was paused.
+	 */
+	if (devdata->interrupts_enabled)
+		visorbus_enable_channel_interrupts(dev);
+
 	rc = 0;
 out_locked:
 	up_write(&devdata->lock_visor_dev);

commit 2efffad3148838842ce4ddbcb719bd1d07905d0c
Author: Erik Arfvidson <erik.arfvidson@unisys.com>
Date:   Fri May 13 23:17:17 2016 -0400

    staging: unisys: visorinput change -1 return value
    
    This patch changes the vague -1 return value to -EINVAL
    
    Signed-off-by: Erik Arfvidson <erik.arfvidson@unisys.com>
    Signed-off-by: David Kershner <david.kershner@unisys.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/unisys/visorinput/visorinput.c b/drivers/staging/unisys/visorinput/visorinput.c
index 12a3570780fc..d67cd76327c0 100644
--- a/drivers/staging/unisys/visorinput/visorinput.c
+++ b/drivers/staging/unisys/visorinput/visorinput.c
@@ -506,7 +506,7 @@ calc_button(int x)
 	case 3:
 		return BTN_RIGHT;
 	default:
-		return -1;
+		return -EINVAL;
 	}
 }
 

commit 73ba8afe33e22b4bae26098add458bed3e666bc2
Author: Tim Sell <Timothy.Sell@unisys.com>
Date:   Fri May 6 13:11:21 2016 -0400

    staging: unisys: visorinput: handle_locking_key() simplifications
    
    By directly returning for the error-case, a test was eliminated.  Also,
    the old_state variable was removed as it was not necessary, and some
    redundant parens were removed.
    
    Signed-off-by: Tim Sell <Timothy.Sell@unisys.com>
    Signed-off-by: David Kershner <david.kershner@unisys.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/unisys/visorinput/visorinput.c b/drivers/staging/unisys/visorinput/visorinput.c
index dc94261b31f9..12a3570780fc 100644
--- a/drivers/staging/unisys/visorinput/visorinput.c
+++ b/drivers/staging/unisys/visorinput/visorinput.c
@@ -467,18 +467,14 @@ handle_locking_key(struct input_dev *visorinput_dev,
 		break;
 	default:
 		led = -1;
-		break;
+		return;
 	}
-	if (led >= 0) {
-		int old_state = (test_bit(led, visorinput_dev->led));
-
-		if (old_state != desired_state) {
-			input_report_key(visorinput_dev, keycode, 1);
-			input_sync(visorinput_dev);
-			input_report_key(visorinput_dev, keycode, 0);
-			input_sync(visorinput_dev);
-			__change_bit(led, visorinput_dev->led);
-		}
+	if (test_bit(led, visorinput_dev->led) != desired_state) {
+		input_report_key(visorinput_dev, keycode, 1);
+		input_sync(visorinput_dev);
+		input_report_key(visorinput_dev, keycode, 0);
+		input_sync(visorinput_dev);
+		__change_bit(led, visorinput_dev->led);
 	}
 }
 

commit 6fac083b8df8450af4550238faa104396ccecf13
Author: Tim Sell <Timothy.Sell@unisys.com>
Date:   Fri Apr 8 08:48:05 2016 -0400

    staging: unisys: visorinput: remove erroneous 'FIXME' comments
    
    These comments were mistakenly carried forward by a previous copy/paste.
    
    Signed-off-by: Tim Sell <Timothy.Sell@unisys.com>
    Signed-off-by: David Kershner <david.kershner@unisys.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/unisys/visorinput/visorinput.c b/drivers/staging/unisys/visorinput/visorinput.c
index 3299cf502aa0..dc94261b31f9 100644
--- a/drivers/staging/unisys/visorinput/visorinput.c
+++ b/drivers/staging/unisys/visorinput/visorinput.c
@@ -123,9 +123,9 @@ static const unsigned char visorkbd_keycode[KEYCODE_TABLE_BYTES] = {
 	[38] = KEY_L,
 	[39] = KEY_SEMICOLON,
 	[40] = KEY_APOSTROPHE,
-	[41] = KEY_GRAVE,	/* FIXME, '#' */
+	[41] = KEY_GRAVE,
 	[42] = KEY_LEFTSHIFT,
-	[43] = KEY_BACKSLASH,	/* FIXME, '~' */
+	[43] = KEY_BACKSLASH,
 	[44] = KEY_Z,
 	[45] = KEY_X,
 	[46] = KEY_C,
@@ -173,7 +173,7 @@ static const unsigned char visorkbd_keycode[KEYCODE_TABLE_BYTES] = {
 	[88] = KEY_F12,
 	[90] = KEY_KPLEFTPAREN,
 	[91] = KEY_KPRIGHTPAREN,
-	[92] = KEY_KPASTERISK,	/* FIXME */
+	[92] = KEY_KPASTERISK,
 	[93] = KEY_KPASTERISK,
 	[94] = KEY_KPPLUS,
 	[95] = KEY_HELP,

commit 4d12b5ee26e31b964b8918e7adde081103213b06
Author: Erik Arfvidson <erik.arfvidson@unisys.com>
Date:   Thu Mar 24 09:18:10 2016 -0400

    staging: unisys: remove visorinput.c double negative comparison
    
    This patch simply removes the double negative comparison for
    test_bit since test_bit already preforms this check.
    
    Signed-off-by: Erik Arfvidson <erik.arfvidson@unisys.com>
    Signed-off-by: David Kershner <david.kershner@unisys.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/unisys/visorinput/visorinput.c b/drivers/staging/unisys/visorinput/visorinput.c
index 13c0316112ac..3299cf502aa0 100644
--- a/drivers/staging/unisys/visorinput/visorinput.c
+++ b/drivers/staging/unisys/visorinput/visorinput.c
@@ -470,7 +470,7 @@ handle_locking_key(struct input_dev *visorinput_dev,
 		break;
 	}
 	if (led >= 0) {
-		int old_state = (test_bit(led, visorinput_dev->led) != 0);
+		int old_state = (test_bit(led, visorinput_dev->led));
 
 		if (old_state != desired_state) {
 			input_report_key(visorinput_dev, keycode, 1);

commit 7b50908a5eee25125023e22c5fed93f659bddd00
Author: Eva Rachel Retuya <eraretuya@gmail.com>
Date:   Sat Mar 5 23:16:17 2016 +0800

    staging: unisys: visorinput: convert pr_err() to dev_err()
    
    Replace pr_err() calls with respective dev_err() counterpart.
    Semantic patch used to detect and apply the transformation:
    
    @r exists@
    identifier f,s,i;
    position p;
    @@
    
    f(...,struct s *i,...) {
      <+...
      pr_err@p(...)
      ...+>
    }
    
    @s@
    identifier r.s, dev;
    @@
    
    struct s {
            ...
            struct device dev;
            ...
    };
    
    @t@
    identifier r.i, s.dev;
    expression fmt;
    position r.p;
    @@
    
    - pr_err@p(
    + dev_err(&i->dev,
                            fmt, ...);
    
    Signed-off-by: Eva Rachel Retuya <eraretuya@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/unisys/visorinput/visorinput.c b/drivers/staging/unisys/visorinput/visorinput.c
index 38d4d5b884df..13c0316112ac 100644
--- a/drivers/staging/unisys/visorinput/visorinput.c
+++ b/drivers/staging/unisys/visorinput/visorinput.c
@@ -222,8 +222,9 @@ static int visorinput_open(struct input_dev *visorinput_dev)
 	struct visorinput_devdata *devdata = input_get_drvdata(visorinput_dev);
 
 	if (!devdata) {
-		pr_err("%s input_get_drvdata(%p) returned NULL\n",
-		       __func__, visorinput_dev);
+		dev_err(&visorinput_dev->dev,
+			"%s input_get_drvdata(%p) returned NULL\n",
+			__func__, visorinput_dev);
 		return -EINVAL;
 	}
 	dev_dbg(&visorinput_dev->dev, "%s opened\n", __func__);
@@ -236,8 +237,9 @@ static void visorinput_close(struct input_dev *visorinput_dev)
 	struct visorinput_devdata *devdata = input_get_drvdata(visorinput_dev);
 
 	if (!devdata) {
-		pr_err("%s input_get_drvdata(%p) returned NULL\n",
-		       __func__, visorinput_dev);
+		dev_err(&visorinput_dev->dev,
+			"%s input_get_drvdata(%p) returned NULL\n",
+			__func__, visorinput_dev);
 		return;
 	}
 	dev_dbg(&visorinput_dev->dev, "%s closed\n", __func__);

commit 559b7d2444790415b8818d3154afba7e74f5925f
Author: Sudip Mukherjee <sudipm.mukherjee@gmail.com>
Date:   Mon Nov 16 20:16:45 2015 +0530

    staging: unisys: remove unused variable
    
    The variables op, sd and zmotion were never being used.
    
    Signed-off-by: Sudip Mukherjee <sudip@vectorindia.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/unisys/visorinput/visorinput.c b/drivers/staging/unisys/visorinput/visorinput.c
index 5c16f6634368..38d4d5b884df 100644
--- a/drivers/staging/unisys/visorinput/visorinput.c
+++ b/drivers/staging/unisys/visorinput/visorinput.c
@@ -523,7 +523,7 @@ visorinput_channel_interrupt(struct visor_device *dev)
 	struct ultra_inputreport r;
 	int scancode, keycode;
 	struct input_dev *visorinput_dev;
-	int xmotion, ymotion, zmotion, button;
+	int xmotion, ymotion, button;
 	int i;
 
 	struct visorinput_devdata *devdata = dev_get_drvdata(&dev->device);
@@ -604,12 +604,10 @@ visorinput_channel_interrupt(struct visor_device *dev)
 			}
 			break;
 		case inputaction_wheel_rotate_away:
-			zmotion = r.activity.arg1;
 			input_report_rel(visorinput_dev, REL_WHEEL, 1);
 			input_sync(visorinput_dev);
 			break;
 		case inputaction_wheel_rotate_toward:
-			zmotion = r.activity.arg1;
 			input_report_rel(visorinput_dev, REL_WHEEL, -1);
 			input_sync(visorinput_dev);
 			break;

commit 8d53d80b12c9683d51b8649a74b6c09ca0c15f8a
Author: Amitoj Kaur Chawla <amitoj1606@gmail.com>
Date:   Thu Oct 15 03:22:22 2015 +0530

    staging: unisys: Remove useless intialisation
    
    Remove intialisation of a variable that is immediately reassigned.
    
    The semantic patch used to find this is:
    
    // <smpl>
    @@
    type T;
    identifier x;
    constant C;
    expression e;
    @@
    
    T x
    - = C
     ;
    x = e;
    // </smpl>
    
    Signed-off-by: Amitoj Kaur Chawla <amitoj1606@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/unisys/visorinput/visorinput.c b/drivers/staging/unisys/visorinput/visorinput.c
index d23c12946b0b..5c16f6634368 100644
--- a/drivers/staging/unisys/visorinput/visorinput.c
+++ b/drivers/staging/unisys/visorinput/visorinput.c
@@ -255,7 +255,7 @@ register_client_keyboard(void *devdata,  /* opaque on purpose */
 
 {
 	int i, error;
-	struct input_dev *visorinput_dev = NULL;
+	struct input_dev *visorinput_dev;
 
 	visorinput_dev = input_allocate_device();
 	if (!visorinput_dev)

commit 7eb1f7a09bcc1c5f10241d85bee65e786558f171
Author: Tim Sell <Timothy.Sell@unisys.com>
Date:   Wed Oct 14 09:45:10 2015 -0400

    staging: unisys: visorinput: no need to track open count
    
    evdev_open_device() and evdev_close_device() (in evdev.c) already track
    the open count under lock, and will only call visorinput_open() on the
    first open and visorinput_close() on the last close.  So this patch
    removes the unnessary logic from visorinput, and the now-unused counter
    from the struct.
    
    Signed-off-by: Tim Sell <timothy.sell@unisys.com>
    Signed-off-by: Benjamin Romer <benjamin.romer@unisys.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/unisys/visorinput/visorinput.c b/drivers/staging/unisys/visorinput/visorinput.c
index 9fdaa9c8a269..d23c12946b0b 100644
--- a/drivers/staging/unisys/visorinput/visorinput.c
+++ b/drivers/staging/unisys/visorinput/visorinput.c
@@ -66,7 +66,6 @@ struct visorinput_devdata {
 	struct rw_semaphore lock_visor_dev; /* lock for dev */
 	struct input_dev *visorinput_dev;
 	bool paused;
-	unsigned int opened;
 	unsigned int keycode_table_bytes; /* size of following array */
 	/* for keyboard devices: visorkbd_keycode[] + visorkbd_ext_keycode[] */
 	unsigned char keycode_table[0];
@@ -227,11 +226,8 @@ static int visorinput_open(struct input_dev *visorinput_dev)
 		       __func__, visorinput_dev);
 		return -EINVAL;
 	}
-	devdata->opened++;
-	dev_dbg(&visorinput_dev->dev, "%s opened %d\n", __func__,
-		devdata->opened);
-	if (devdata->opened == 1)
-		visorbus_enable_channel_interrupts(devdata->dev);
+	dev_dbg(&visorinput_dev->dev, "%s opened\n", __func__);
+	visorbus_enable_channel_interrupts(devdata->dev);
 	return 0;
 }
 
@@ -244,14 +240,8 @@ static void visorinput_close(struct input_dev *visorinput_dev)
 		       __func__, visorinput_dev);
 		return;
 	}
-	if (devdata->opened) {
-		devdata->opened--;
-		dev_dbg(&visorinput_dev->dev, "%s closed %d\n", __func__,
-			devdata->opened);
-		if (devdata->opened == 0)
-			visorbus_disable_channel_interrupts(devdata->dev);
-	} else
-		dev_err(&visorinput_dev->dev, "%s not open\n", __func__);
+	dev_dbg(&visorinput_dev->dev, "%s closed\n", __func__);
+	visorbus_disable_channel_interrupts(devdata->dev);
 }
 
 /*

commit 1b756c43ce3b1696282670bd1de41d36e5205781
Author: Tim Sell <timothy.sell@unisys.com>
Date:   Fri Oct 16 10:06:47 2015 -0400

    staging: unisys: visorinput: fix comment format
    
    Fix the multi-line comment formatting in visorinput.c.
    
    Signed-off-by: Tim Sell <timothy.sell@unisys.com>
    Signed-off-by: Benjamin Romer <benjamin.romer@unisys.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/unisys/visorinput/visorinput.c b/drivers/staging/unisys/visorinput/visorinput.c
index 5f28c3d9ecfa..9fdaa9c8a269 100644
--- a/drivers/staging/unisys/visorinput/visorinput.c
+++ b/drivers/staging/unisys/visorinput/visorinput.c
@@ -168,7 +168,8 @@ static const unsigned char visorkbd_keycode[KEYCODE_TABLE_BYTES] = {
 	[82] = KEY_KP0,
 	[83] = KEY_KPDOT,
 	[86] = KEY_102ND, /* enables UK backslash+pipe key,
-			   * and FR lessthan+greaterthan key */
+			   * and FR lessthan+greaterthan key
+			   */
 	[87] = KEY_F11,
 	[88] = KEY_F12,
 	[90] = KEY_KPLEFTPAREN,

commit 8f94c5a6829c764cd1a4f8d497ffb201419bed85
Author: Tim Sell <Timothy.Sell@unisys.com>
Date:   Fri Oct 16 10:06:46 2015 -0400

    staging: unisys: visorinput: address checkpatch alignment issues
    
    Fix the alignment of function parameters to the parenthesis above.
    
    Signed-off-by: Tim Sell <Timothy.Sell@unisys.com>
    Signed-off-by: Benjamin Romer <benjamin.romer@unisys.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/unisys/visorinput/visorinput.c b/drivers/staging/unisys/visorinput/visorinput.c
index 058ee91c2671..5f28c3d9ecfa 100644
--- a/drivers/staging/unisys/visorinput/visorinput.c
+++ b/drivers/staging/unisys/visorinput/visorinput.c
@@ -630,7 +630,7 @@ visorinput_channel_interrupt(struct visor_device *dev)
 
 static int
 visorinput_pause(struct visor_device *dev,
-	       visorbus_state_complete_func complete_func)
+		 visorbus_state_complete_func complete_func)
 {
 	int rc;
 	struct visorinput_devdata *devdata = dev_get_drvdata(&dev->device);
@@ -656,7 +656,7 @@ visorinput_pause(struct visor_device *dev,
 
 static int
 visorinput_resume(struct visor_device *dev,
-		visorbus_state_complete_func complete_func)
+		  visorbus_state_complete_func complete_func)
 {
 	int rc;
 	struct visorinput_devdata *devdata = dev_get_drvdata(&dev->device);

commit 3d53fb9041d7d7bb8e1e1dd8b233cbed187933a7
Author: Shivani Bhardwaj <shivanib134@gmail.com>
Date:   Tue Oct 13 20:50:23 2015 +0530

    Staging: unisys: visorinput: Remove unused code
    
    Remove the code which is not used anywhere in the program.
    Semantic patch used:
    
    @@
    type T;
    identifier i;
    constant C;
    position p != e.p;
    @@
    
    - T i@p;
      <+... when != i
    - i = C;
      ...+>
    
    Signed-off-by: Shivani Bhardwaj <shivanib134@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/unisys/visorinput/visorinput.c b/drivers/staging/unisys/visorinput/visorinput.c
index 3a1b24fc4831..058ee91c2671 100644
--- a/drivers/staging/unisys/visorinput/visorinput.c
+++ b/drivers/staging/unisys/visorinput/visorinput.c
@@ -461,20 +461,16 @@ handle_locking_key(struct input_dev *visorinput_dev,
 		   int keycode, int desired_state)
 {
 	int led;
-	char *sled;
 
 	switch (keycode) {
 	case KEY_CAPSLOCK:
 		led = LED_CAPSL;
-		sled = "CAP";
 		break;
 	case KEY_SCROLLLOCK:
 		led = LED_SCROLLL;
-		sled = "SCR";
 		break;
 	case KEY_NUMLOCK:
 		led = LED_NUML;
-		sled = "NUM";
 		break;
 	default:
 		led = -1;

commit 464b577c8bf5a150638baee151d083790190c1b7
Author: Tim Sell <Timothy.Sell@unisys.com>
Date:   Fri Oct 2 13:19:25 2015 -0400

    staging: unisys: visorinput: remove extraneous do_key function
    
    do_key() is no longer needed.
    
    Signed-off-by: Tim Sell <Timothy.Sell@unisys.com>
    Signed-off-by: Benjamin Romer <benjamin.romer@unisys.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/unisys/visorinput/visorinput.c b/drivers/staging/unisys/visorinput/visorinput.c
index a002e072429b..3a1b24fc4831 100644
--- a/drivers/staging/unisys/visorinput/visorinput.c
+++ b/drivers/staging/unisys/visorinput/visorinput.c
@@ -452,12 +452,6 @@ visorinput_remove(struct visor_device *dev)
 	kfree(devdata);
 }
 
-static void
-do_key(struct input_dev *inpt, int keycode, int down)
-{
-	input_report_key(inpt, keycode, down);
-}
-
 /*
  * Make it so the current locking state of the locking key indicated by
  * <keycode> is as indicated by <desired_state> (1=locked, 0=unlocked).
@@ -490,9 +484,9 @@ handle_locking_key(struct input_dev *visorinput_dev,
 		int old_state = (test_bit(led, visorinput_dev->led) != 0);
 
 		if (old_state != desired_state) {
-			do_key(visorinput_dev, keycode, 1);
+			input_report_key(visorinput_dev, keycode, 1);
 			input_sync(visorinput_dev);
-			do_key(visorinput_dev, keycode, 0);
+			input_report_key(visorinput_dev, keycode, 0);
 			input_sync(visorinput_dev);
 			__change_bit(led, visorinput_dev->led);
 		}
@@ -563,17 +557,17 @@ visorinput_channel_interrupt(struct visor_device *dev)
 		keycode = scancode_to_keycode(scancode);
 		switch (r.activity.action) {
 		case inputaction_key_down:
-			do_key(visorinput_dev, keycode, 1);
+			input_report_key(visorinput_dev, keycode, 1);
 			input_sync(visorinput_dev);
 			break;
 		case inputaction_key_up:
-			do_key(visorinput_dev, keycode, 0);
+			input_report_key(visorinput_dev, keycode, 0);
 			input_sync(visorinput_dev);
 			break;
 		case inputaction_key_down_up:
-			do_key(visorinput_dev, keycode, 1);
+			input_report_key(visorinput_dev, keycode, 1);
 			input_sync(visorinput_dev);
-			do_key(visorinput_dev, keycode, 0);
+			input_report_key(visorinput_dev, keycode, 0);
 			input_sync(visorinput_dev);
 			break;
 		case inputaction_set_locking_key_state:

commit b4f033f2d01b6b7ab9273b8e93256673c235f5c8
Author: Tim Sell <Timothy.Sell@unisys.com>
Date:   Fri Oct 2 13:19:24 2015 -0400

    staging: unisys: visorinput: remove extraneous mouse logic
    
    Removes a cursor positioning hack that no longer seems to be required.
    
    Signed-off-by: Tim Sell <Timothy.Sell@unisys.com>
    Signed-off-by: Benjamin Romer <benjamin.romer@unisys.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/unisys/visorinput/visorinput.c b/drivers/staging/unisys/visorinput/visorinput.c
index 103f72b76332..a002e072429b 100644
--- a/drivers/staging/unisys/visorinput/visorinput.c
+++ b/drivers/staging/unisys/visorinput/visorinput.c
@@ -350,18 +350,6 @@ register_client_mouse(void *devdata /* opaque on purpose */)
 		return NULL;
 	}
 
-	/*
-	 * Sending top-left and bottom-right positions is ABSOLUTELY
-	 * REQUIRED if we want X to move the mouse to the exact points
-	 * we tell it.  I have NO IDEA why.
-	 */
-	input_report_abs(visorinput_dev, ABS_X, 0);
-	input_report_abs(visorinput_dev, ABS_Y, 0);
-	input_sync(visorinput_dev);
-	input_report_abs(visorinput_dev, ABS_X, xres - 1);
-	input_report_abs(visorinput_dev, ABS_Y, yres - 1);
-	input_sync(visorinput_dev);
-
 	input_set_capability(visorinput_dev, EV_REL, REL_WHEEL);
 
 	return visorinput_dev;

commit bc49496d2924d8fd5974053207d477d1bb6ba6ee
Author: Tim Sell <Timothy.Sell@unisys.com>
Date:   Fri Oct 2 13:19:23 2015 -0400

    staging: unisys: visorinput: register & use input_dev open() and close()
    
    Registration of visorinput_open() and visorinput_close() for each device
    allow us to eliminate unnecessary activity when nobody in user-land
    cares.
    
    Signed-off-by: Tim Sell <Timothy.Sell@unisys.com>
    Signed-off-by: Benjamin Romer <benjamin.romer@unisys.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/unisys/visorinput/visorinput.c b/drivers/staging/unisys/visorinput/visorinput.c
index d47cc2b643f8..103f72b76332 100644
--- a/drivers/staging/unisys/visorinput/visorinput.c
+++ b/drivers/staging/unisys/visorinput/visorinput.c
@@ -66,6 +66,7 @@ struct visorinput_devdata {
 	struct rw_semaphore lock_visor_dev; /* lock for dev */
 	struct input_dev *visorinput_dev;
 	bool paused;
+	unsigned int opened;
 	unsigned int keycode_table_bytes; /* size of following array */
 	/* for keyboard devices: visorkbd_keycode[] + visorkbd_ext_keycode[] */
 	unsigned char keycode_table[0];
@@ -216,13 +217,50 @@ static const unsigned char visorkbd_ext_keycode[KEYCODE_TABLE_BYTES] = {
 	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,		    /* 0x70 */
 };
 
+static int visorinput_open(struct input_dev *visorinput_dev)
+{
+	struct visorinput_devdata *devdata = input_get_drvdata(visorinput_dev);
+
+	if (!devdata) {
+		pr_err("%s input_get_drvdata(%p) returned NULL\n",
+		       __func__, visorinput_dev);
+		return -EINVAL;
+	}
+	devdata->opened++;
+	dev_dbg(&visorinput_dev->dev, "%s opened %d\n", __func__,
+		devdata->opened);
+	if (devdata->opened == 1)
+		visorbus_enable_channel_interrupts(devdata->dev);
+	return 0;
+}
+
+static void visorinput_close(struct input_dev *visorinput_dev)
+{
+	struct visorinput_devdata *devdata = input_get_drvdata(visorinput_dev);
+
+	if (!devdata) {
+		pr_err("%s input_get_drvdata(%p) returned NULL\n",
+		       __func__, visorinput_dev);
+		return;
+	}
+	if (devdata->opened) {
+		devdata->opened--;
+		dev_dbg(&visorinput_dev->dev, "%s closed %d\n", __func__,
+			devdata->opened);
+		if (devdata->opened == 0)
+			visorbus_disable_channel_interrupts(devdata->dev);
+	} else
+		dev_err(&visorinput_dev->dev, "%s not open\n", __func__);
+}
+
 /*
  * register_client_keyboard() initializes and returns a Linux input node that
  * we can use to deliver keyboard inputs to Linux.  We of course do this when
  * we see keyboard inputs coming in on a keyboard channel.
  */
 static struct input_dev *
-register_client_keyboard(unsigned char *keycode_table)
+register_client_keyboard(void *devdata,  /* opaque on purpose */
+			 unsigned char *keycode_table)
 
 {
 	int i, error;
@@ -255,6 +293,10 @@ register_client_keyboard(unsigned char *keycode_table)
 		set_bit(keycode_table[i + KEYCODE_TABLE_BYTES],
 			visorinput_dev->keybit);
 
+	visorinput_dev->open = visorinput_open;
+	visorinput_dev->close = visorinput_close;
+	input_set_drvdata(visorinput_dev, devdata); /* pre input_register! */
+
 	error = input_register_device(visorinput_dev);
 	if (error) {
 		input_free_device(visorinput_dev);
@@ -264,7 +306,7 @@ register_client_keyboard(unsigned char *keycode_table)
 }
 
 static struct input_dev *
-register_client_mouse(void)
+register_client_mouse(void *devdata /* opaque on purpose */)
 {
 	int error;
 	struct input_dev *visorinput_dev = NULL;
@@ -298,6 +340,10 @@ register_client_mouse(void)
 	input_set_abs_params(visorinput_dev, ABS_X, 0, xres, 0, 0);
 	input_set_abs_params(visorinput_dev, ABS_Y, 0, yres, 0, 0);
 
+	visorinput_dev->open = visorinput_open;
+	visorinput_dev->close = visorinput_close;
+	input_set_drvdata(visorinput_dev, devdata); /* pre input_register! */
+
 	error = input_register_device(visorinput_dev);
 	if (error) {
 		input_free_device(visorinput_dev);
@@ -348,12 +394,12 @@ devdata_create(struct visor_device *dev, enum visorinput_device_type devtype)
 		memcpy(devdata->keycode_table + KEYCODE_TABLE_BYTES,
 		       visorkbd_ext_keycode, KEYCODE_TABLE_BYTES);
 		devdata->visorinput_dev = register_client_keyboard
-			(devdata->keycode_table);
+			(devdata, devdata->keycode_table);
 		if (!devdata->visorinput_dev)
 			goto cleanups_register;
 		break;
 	case visorinput_mouse:
-		devdata->visorinput_dev = register_client_mouse();
+		devdata->visorinput_dev = register_client_mouse(devdata);
 		if (!devdata->visorinput_dev)
 			goto cleanups_register;
 		break;
@@ -386,7 +432,6 @@ visorinput_probe(struct visor_device *dev)
 	if (!devdata)
 		return -ENOMEM;
 	dev_set_drvdata(&dev->device, devdata);
-	visorbus_enable_channel_interrupts(dev);
 	return 0;
 }
 

commit add282479665cfbe5767524630086871e12d49f1
Author: Tim Sell <Timothy.Sell@unisys.com>
Date:   Fri Oct 2 13:19:22 2015 -0400

    staging: unisys: visorinput: change input bus type to BUS_VIRTUAL (6)
    
    BUS_HOST wasn't really appropriate, so I changed to BUS_VIRTUAL, which is
    what virtio uses.
    
    Signed-off-by: Tim Sell <Timothy.Sell@unisys.com>
    Signed-off-by: Benjamin Romer <benjamin.romer@unisys.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/unisys/visorinput/visorinput.c b/drivers/staging/unisys/visorinput/visorinput.c
index adc2cc90aef3..d47cc2b643f8 100644
--- a/drivers/staging/unisys/visorinput/visorinput.c
+++ b/drivers/staging/unisys/visorinput/visorinput.c
@@ -234,7 +234,7 @@ register_client_keyboard(unsigned char *keycode_table)
 
 	visorinput_dev->name = "visor Keyboard";
 	visorinput_dev->phys = "visorkbd:input0";
-	visorinput_dev->id.bustype = BUS_HOST;
+	visorinput_dev->id.bustype = BUS_VIRTUAL;
 	visorinput_dev->id.vendor = 0x0001;
 	visorinput_dev->id.product = 0x0001;
 	visorinput_dev->id.version = 0x0100;
@@ -277,7 +277,7 @@ register_client_mouse(void)
 
 	visorinput_dev->name = "visor Mouse";
 	visorinput_dev->phys = "visormou:input0";
-	visorinput_dev->id.bustype = BUS_HOST;
+	visorinput_dev->id.bustype = BUS_VIRTUAL;
 	visorinput_dev->id.vendor = 0x0001;
 	visorinput_dev->id.product = 0x0002;
 	visorinput_dev->id.version = 0x0100;

commit ade7280ff53c000c87e416fcf466081990d62c9a
Author: Tim Sell <Timothy.Sell@unisys.com>
Date:   Fri Oct 2 13:19:21 2015 -0400

    staging: unisys: visorinput: comment tweaks - s/gizmo/input node/g
    
    Just a simple search and replace in the comments.
    
    Signed-off-by: Tim Sell <Timothy.Sell@unisys.com>
    Signed-off-by: Benjamin Romer <benjamin.romer@unisys.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/unisys/visorinput/visorinput.c b/drivers/staging/unisys/visorinput/visorinput.c
index 976effa531cc..adc2cc90aef3 100644
--- a/drivers/staging/unisys/visorinput/visorinput.c
+++ b/drivers/staging/unisys/visorinput/visorinput.c
@@ -217,8 +217,8 @@ static const unsigned char visorkbd_ext_keycode[KEYCODE_TABLE_BYTES] = {
 };
 
 /*
- * register_client_keyboard() initializes and returns a Linux gizmo that we
- * can use to deliver keyboard inputs to Linux.  We of course do this when
+ * register_client_keyboard() initializes and returns a Linux input node that
+ * we can use to deliver keyboard inputs to Linux.  We of course do this when
  * we see keyboard inputs coming in on a keyboard channel.
  */
 static struct input_dev *
@@ -337,7 +337,7 @@ devdata_create(struct visor_device *dev, enum visorinput_device_type devtype)
 
 	/*
 	 * This is an input device in a client guest partition,
-	 * so we need to create whatever gizmos are necessary to
+	 * so we need to create whatever input nodes are necessary to
 	 * deliver our inputs to the guest OS.
 	 */
 	switch (devtype) {

commit cb3690fe4e45649dad5cbec3f9aa451fc8bcd9c5
Author: Tim Sell <Timothy.Sell@unisys.com>
Date:   Fri Oct 2 13:19:20 2015 -0400

    staging: unisys: visorinput: correct code comments per kernel conventions
    
    Multi-line comments were modified to conform to kernel conventions:
    
        /*
         * multi-line
         * comments
         */
    
    doc-test /** */ for some comments was removed.
    
    Signed-off-by: Tim Sell <Timothy.Sell@unisys.com>
    Signed-off-by: Benjamin Romer <benjamin.romer@unisys.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/unisys/visorinput/visorinput.c b/drivers/staging/unisys/visorinput/visorinput.c
index 52d01e45f7dd..976effa531cc 100644
--- a/drivers/staging/unisys/visorinput/visorinput.c
+++ b/drivers/staging/unisys/visorinput/visorinput.c
@@ -14,7 +14,8 @@
  * details.
  */
 
-/* This driver lives in a generic guest Linux partition, and registers to
+/*
+ * This driver lives in a generic guest Linux partition, and registers to
  * receive keyboard and mouse channels from the visorbus driver.  It reads
  * inputs from such channels, and delivers it to the Linux OS in the
  * standard way the Linux expects for input drivers.
@@ -55,14 +56,14 @@ enum visorinput_device_type {
 	visorinput_mouse,
 };
 
-/*  This is the private data that we store for each device.
- *  A pointer to this struct is maintained via
- *  dev_get_drvdata() / dev_set_drvdata() for each struct device.
+/*
+ * This is the private data that we store for each device.
+ * A pointer to this struct is maintained via
+ * dev_get_drvdata() / dev_set_drvdata() for each struct device.
  */
 struct visorinput_devdata {
 	struct visor_device *dev;
-	/** lock for dev */
-	struct rw_semaphore lock_visor_dev;
+	struct rw_semaphore lock_visor_dev; /* lock for dev */
 	struct input_dev *visorinput_dev;
 	bool paused;
 	unsigned int keycode_table_bytes; /* size of following array */
@@ -75,8 +76,10 @@ static const uuid_le spar_keyboard_channel_protocol_uuid =
 static const uuid_le spar_mouse_channel_protocol_uuid =
 	SPAR_MOUSE_CHANNEL_PROTOCOL_UUID;
 
-/* Borrowed from drivers/input/keyboard/atakbd.c */
-/* This maps 1-byte scancodes to keycodes. */
+/*
+ * Borrowed from drivers/input/keyboard/atakbd.c
+ * This maps 1-byte scancodes to keycodes.
+ */
 static const unsigned char visorkbd_keycode[KEYCODE_TABLE_BYTES] = {
 	/* American layout */
 	[0] = KEY_GRAVE,
@@ -193,7 +196,8 @@ static const unsigned char visorkbd_keycode[KEYCODE_TABLE_BYTES] = {
 	[113] = KEY_MUTE
 };
 
-/* This maps the <xx> in extended scancodes of the form "0xE0 <xx>" into
+/*
+ * This maps the <xx> in extended scancodes of the form "0xE0 <xx>" into
  * keycodes.
  */
 static const unsigned char visorkbd_ext_keycode[KEYCODE_TABLE_BYTES] = {
@@ -212,7 +216,8 @@ static const unsigned char visorkbd_ext_keycode[KEYCODE_TABLE_BYTES] = {
 	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,		    /* 0x70 */
 };
 
-/* register_client_keyboard() initializes and returns a Linux gizmo that we
+/*
+ * register_client_keyboard() initializes and returns a Linux gizmo that we
  * can use to deliver keyboard inputs to Linux.  We of course do this when
  * we see keyboard inputs coming in on a keyboard channel.
  */
@@ -299,7 +304,8 @@ register_client_mouse(void)
 		return NULL;
 	}
 
-	/* Sending top-left and bottom-right positions is ABSOLUTELY
+	/*
+	 * Sending top-left and bottom-right positions is ABSOLUTELY
 	 * REQUIRED if we want X to move the mouse to the exact points
 	 * we tell it.  I have NO IDEA why.
 	 */
@@ -329,7 +335,8 @@ devdata_create(struct visor_device *dev, enum visorinput_device_type devtype)
 		return NULL;
 	devdata->dev = dev;
 
-	/* This is an input device in a client guest partition,
+	/*
+	 * This is an input device in a client guest partition,
 	 * so we need to create whatever gizmos are necessary to
 	 * deliver our inputs to the guest OS.
 	 */
@@ -400,9 +407,10 @@ visorinput_remove(struct visor_device *dev)
 
 	visorbus_disable_channel_interrupts(dev);
 
-	/* due to above, at this time no thread of execution will be
-	* in visorinput_channel_interrupt()
-	*/
+	/*
+	 * due to above, at this time no thread of execution will be
+	 * in visorinput_channel_interrupt()
+	 */
 
 	down_write(&devdata->lock_visor_dev);
 	dev_set_drvdata(&dev->device, NULL);
@@ -417,7 +425,8 @@ do_key(struct input_dev *inpt, int keycode, int down)
 	input_report_key(inpt, keycode, down);
 }
 
-/* Make it so the current locking state of the locking key indicated by
+/*
+ * Make it so the current locking state of the locking key indicated by
  * <keycode> is as indicated by <desired_state> (1=locked, 0=unlocked).
  */
 static void
@@ -457,7 +466,8 @@ handle_locking_key(struct input_dev *visorinput_dev,
 	}
 }
 
-/* <scancode> is either a 1-byte scancode, or an extended 16-bit scancode
+/*
+ * <scancode> is either a 1-byte scancode, or an extended 16-bit scancode
  * with 0xE0 in the low byte and the extended scancode value in the next
  * higher byte.
  */
@@ -488,7 +498,8 @@ calc_button(int x)
 	}
 }
 
-/* This is used only when this driver is active as an input driver in the
+/*
+ * This is used only when this driver is active as an input driver in the
  * client guest partition.  It is called periodically so we can obtain inputs
  * from the channel, and deliver them to the guest OS.
  */

commit f9bda156cfd22f8a6598729bac831308f6db7997
Author: Tim Sell <Timothy.Sell@unisys.com>
Date:   Fri Oct 2 13:19:19 2015 -0400

    staging: unisys: visorinput: make structs & arrays const where possible
    
    This also gave me a warning with the assignment:
    
        visorinput_dev->keycode = visorkbd_keycode;
    
    because input_dev->keycode is NOT static but visorkbd_keycode now is, so
    I went ahead and also added logic to stash away non-static copies of
    visorkbd_keycode[] and visorkbd_ext_keycode[] within visorinput_devdata,
    and use the copy to assign to visorinput_dev->keycode.  This change is
    also technically required, because user-space can remap keys, and we
    don't want this to be shared with the other keyboard devices running on
    the same system.
    
    Signed-off-by: Tim Sell <Timothy.Sell@unisys.com>
    Signed-off-by: Benjamin Romer <benjamin.romer@unisys.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/unisys/visorinput/visorinput.c b/drivers/staging/unisys/visorinput/visorinput.c
index a15924cfb380..52d01e45f7dd 100644
--- a/drivers/staging/unisys/visorinput/visorinput.c
+++ b/drivers/staging/unisys/visorinput/visorinput.c
@@ -48,6 +48,7 @@
 
 #define PIXELS_ACROSS_DEFAULT	800
 #define PIXELS_DOWN_DEFAULT	600
+#define KEYCODE_TABLE_BYTES	256
 
 enum visorinput_device_type {
 	visorinput_keyboard,
@@ -64,6 +65,9 @@ struct visorinput_devdata {
 	struct rw_semaphore lock_visor_dev;
 	struct input_dev *visorinput_dev;
 	bool paused;
+	unsigned int keycode_table_bytes; /* size of following array */
+	/* for keyboard devices: visorkbd_keycode[] + visorkbd_ext_keycode[] */
+	unsigned char keycode_table[0];
 };
 
 static const uuid_le spar_keyboard_channel_protocol_uuid =
@@ -73,7 +77,8 @@ static const uuid_le spar_mouse_channel_protocol_uuid =
 
 /* Borrowed from drivers/input/keyboard/atakbd.c */
 /* This maps 1-byte scancodes to keycodes. */
-static unsigned char visorkbd_keycode[256] = {	/* American layout */
+static const unsigned char visorkbd_keycode[KEYCODE_TABLE_BYTES] = {
+	/* American layout */
 	[0] = KEY_GRAVE,
 	[1] = KEY_ESC,
 	[2] = KEY_1,
@@ -191,7 +196,7 @@ static unsigned char visorkbd_keycode[256] = {	/* American layout */
 /* This maps the <xx> in extended scancodes of the form "0xE0 <xx>" into
  * keycodes.
  */
-static unsigned char visorkbd_ext_keycode[256] = {
+static const unsigned char visorkbd_ext_keycode[KEYCODE_TABLE_BYTES] = {
 	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,		    /* 0x00 */
 	0, 0, 0, 0, 0, 0, 0, 0,					    /* 0x10 */
 	0, 0, 0, 0, KEY_KPENTER, KEY_RIGHTCTRL, 0, 0,		    /* 0x18 */
@@ -212,7 +217,8 @@ static unsigned char visorkbd_ext_keycode[256] = {
  * we see keyboard inputs coming in on a keyboard channel.
  */
 static struct input_dev *
-register_client_keyboard(void)
+register_client_keyboard(unsigned char *keycode_table)
+
 {
 	int i, error;
 	struct input_dev *visorinput_dev = NULL;
@@ -234,15 +240,15 @@ register_client_keyboard(void)
 	visorinput_dev->ledbit[0] = BIT_MASK(LED_CAPSL) |
 				    BIT_MASK(LED_SCROLLL) |
 				    BIT_MASK(LED_NUML);
-	visorinput_dev->keycode = visorkbd_keycode;
-	visorinput_dev->keycodesize = sizeof(unsigned char);
-	visorinput_dev->keycodemax = ARRAY_SIZE(visorkbd_keycode);
-
-	for (i = 1; i < ARRAY_SIZE(visorkbd_keycode); i++)
-		set_bit(visorkbd_keycode[i], visorinput_dev->keybit);
+	visorinput_dev->keycode = keycode_table;
+	visorinput_dev->keycodesize = 1; /* sizeof(unsigned char) */
+	visorinput_dev->keycodemax = KEYCODE_TABLE_BYTES;
 
-	for (i = 1; i < ARRAY_SIZE(visorkbd_ext_keycode); i++)
-		set_bit(visorkbd_ext_keycode[i], visorinput_dev->keybit);
+	for (i = 1; i < visorinput_dev->keycodemax; i++)
+		set_bit(keycode_table[i], visorinput_dev->keybit);
+	for (i = 1; i < visorinput_dev->keycodemax; i++)
+		set_bit(keycode_table[i + KEYCODE_TABLE_BYTES],
+			visorinput_dev->keybit);
 
 	error = input_register_device(visorinput_dev);
 	if (error) {
@@ -313,8 +319,12 @@ static struct visorinput_devdata *
 devdata_create(struct visor_device *dev, enum visorinput_device_type devtype)
 {
 	struct visorinput_devdata *devdata = NULL;
+	unsigned int extra_bytes = 0;
 
-	devdata = kzalloc(sizeof(*devdata), GFP_KERNEL);
+	if (devtype == visorinput_keyboard)
+		/* allocate room for devdata->keycode_table, filled in below */
+		extra_bytes = KEYCODE_TABLE_BYTES * 2;
+	devdata = kzalloc(sizeof(*devdata) + extra_bytes, GFP_KERNEL);
 	if (!devdata)
 		return NULL;
 	devdata->dev = dev;
@@ -325,7 +335,13 @@ devdata_create(struct visor_device *dev, enum visorinput_device_type devtype)
 	 */
 	switch (devtype) {
 	case visorinput_keyboard:
-		devdata->visorinput_dev = register_client_keyboard();
+		devdata->keycode_table_bytes = extra_bytes;
+		memcpy(devdata->keycode_table, visorkbd_keycode,
+		       KEYCODE_TABLE_BYTES);
+		memcpy(devdata->keycode_table + KEYCODE_TABLE_BYTES,
+		       visorkbd_ext_keycode, KEYCODE_TABLE_BYTES);
+		devdata->visorinput_dev = register_client_keyboard
+			(devdata->keycode_table);
 		if (!devdata->visorinput_dev)
 			goto cleanups_register;
 		break;

commit b3d5d05dcc4ac1d349c51ea743092375701aa8e1
Author: Tim Sell <Timothy.Sell@unisys.com>
Date:   Fri Oct 2 13:19:17 2015 -0400

    staging: unisys: visorinput: re-order declarations for consistency
    
    In order to be more consistent with kernel conventions used elsewhere,
    I have re-ordered declarations in visorinput.c to follow this general
    order (where possible):
    * #defines
    * struct/enum/union declarations
    * static declarations (const if possible for all of them)
    * forward function declarations where absolutely necessary
    
    Exceptions were made for the static declarations like the driver
    declaration, given that it depends on previously-defined callbacks.
    So such declarations are at the end of visorinput.c.
    
    Signed-off-by: Tim Sell <Timothy.Sell@unisys.com>
    Signed-off-by: Benjamin Romer <benjamin.romer@unisys.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/unisys/visorinput/visorinput.c b/drivers/staging/unisys/visorinput/visorinput.c
index 4c5b594548d8..a15924cfb380 100644
--- a/drivers/staging/unisys/visorinput/visorinput.c
+++ b/drivers/staging/unisys/visorinput/visorinput.c
@@ -49,47 +49,6 @@
 #define PIXELS_ACROSS_DEFAULT	800
 #define PIXELS_DOWN_DEFAULT	600
 
-static const uuid_le spar_keyboard_channel_protocol_uuid =
-	SPAR_KEYBOARD_CHANNEL_PROTOCOL_UUID;
-static const uuid_le spar_mouse_channel_protocol_uuid =
-	SPAR_MOUSE_CHANNEL_PROTOCOL_UUID;
-static int visorinput_probe(struct visor_device *dev);
-static void visorinput_remove(struct visor_device *dev);
-static void visorinput_channel_interrupt(struct visor_device *dev);
-static int visorinput_pause(struct visor_device *dev,
-			  visorbus_state_complete_func complete_func);
-static int visorinput_resume(struct visor_device *dev,
-			   visorbus_state_complete_func complete_func);
-static struct input_dev *register_client_keyboard(void);
-static struct input_dev *register_client_mouse(void);
-static void unregister_client_input(struct input_dev *visorinput_dev);
-
-/* GUIDS for all channel types supported by this driver. */
-static struct visor_channeltype_descriptor visorinput_channel_types[] = {
-	{ SPAR_KEYBOARD_CHANNEL_PROTOCOL_UUID, "keyboard"},
-	{ SPAR_MOUSE_CHANNEL_PROTOCOL_UUID, "mouse"},
-	{ NULL_UUID_LE, NULL }
-};
-MODULE_DEVICE_TABLE(visorbus, visorinput_channel_types);
-MODULE_ALIAS("visorbus:" SPAR_MOUSE_CHANNEL_PROTOCOL_UUID_STR);
-MODULE_ALIAS("visorbus:" SPAR_KEYBOARD_CHANNEL_PROTOCOL_UUID_STR);
-
-/** This is used to tell the visor bus driver which types of visor devices
- *  we support, and what functions to call when a visor device that we support
- *  is attached or removed.
- */
-static struct visor_driver visorinput_driver = {
-	.name = "visorinput",
-	.vertag = NULL,
-	.owner = THIS_MODULE,
-	.channel_types = visorinput_channel_types,
-	.probe = visorinput_probe,
-	.remove = visorinput_remove,
-	.channel_interrupt = visorinput_channel_interrupt,
-	.pause = visorinput_pause,
-	.resume = visorinput_resume,
-};
-
 enum visorinput_device_type {
 	visorinput_keyboard,
 	visorinput_mouse,
@@ -107,6 +66,11 @@ struct visorinput_devdata {
 	bool paused;
 };
 
+static const uuid_le spar_keyboard_channel_protocol_uuid =
+	SPAR_KEYBOARD_CHANNEL_PROTOCOL_UUID;
+static const uuid_le spar_mouse_channel_protocol_uuid =
+	SPAR_MOUSE_CHANNEL_PROTOCOL_UUID;
+
 /* Borrowed from drivers/input/keyboard/atakbd.c */
 /* This maps 1-byte scancodes to keycodes. */
 static unsigned char visorkbd_keycode[256] = {	/* American layout */
@@ -243,92 +207,6 @@ static unsigned char visorkbd_ext_keycode[256] = {
 	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,		    /* 0x70 */
 };
 
-static struct visorinput_devdata *
-devdata_create(struct visor_device *dev, enum visorinput_device_type devtype)
-{
-	struct visorinput_devdata *devdata = NULL;
-
-	devdata = kzalloc(sizeof(*devdata), GFP_KERNEL);
-	if (!devdata)
-		return NULL;
-	devdata->dev = dev;
-
-	/* This is an input device in a client guest partition,
-	 * so we need to create whatever gizmos are necessary to
-	 * deliver our inputs to the guest OS.
-	 */
-	switch (devtype) {
-	case visorinput_keyboard:
-		devdata->visorinput_dev = register_client_keyboard();
-		if (!devdata->visorinput_dev)
-			goto cleanups_register;
-		break;
-	case visorinput_mouse:
-		devdata->visorinput_dev = register_client_mouse();
-		if (!devdata->visorinput_dev)
-			goto cleanups_register;
-		break;
-	}
-
-	init_rwsem(&devdata->lock_visor_dev);
-
-	return devdata;
-
-cleanups_register:
-	kfree(devdata);
-	return NULL;
-}
-
-static int
-visorinput_probe(struct visor_device *dev)
-{
-	struct visorinput_devdata *devdata = NULL;
-	uuid_le guid;
-	enum visorinput_device_type devtype;
-
-	guid = visorchannel_get_uuid(dev->visorchannel);
-	if (uuid_le_cmp(guid, spar_mouse_channel_protocol_uuid) == 0)
-		devtype = visorinput_mouse;
-	else if (uuid_le_cmp(guid, spar_keyboard_channel_protocol_uuid) == 0)
-		devtype = visorinput_keyboard;
-	else
-		return -ENODEV;
-	devdata = devdata_create(dev, devtype);
-	if (!devdata)
-		return -ENOMEM;
-	dev_set_drvdata(&dev->device, devdata);
-	visorbus_enable_channel_interrupts(dev);
-	return 0;
-}
-
-static void
-visorinput_remove(struct visor_device *dev)
-{
-	struct visorinput_devdata *devdata = dev_get_drvdata(&dev->device);
-
-	if (!devdata)
-		return;
-
-	visorbus_disable_channel_interrupts(dev);
-
-	/* due to above, at this time no thread of execution will be
-	* in visorinput_channel_interrupt()
-	*/
-
-	down_write(&devdata->lock_visor_dev);
-	dev_set_drvdata(&dev->device, NULL);
-	unregister_client_input(devdata->visorinput_dev);
-	up_write(&devdata->lock_visor_dev);
-	kfree(devdata);
-}
-
-static void
-unregister_client_input(struct input_dev *visorinput_dev)
-{
-	if (visorinput_dev)
-		input_unregister_device(visorinput_dev);
-}
-
 /* register_client_keyboard() initializes and returns a Linux gizmo that we
  * can use to deliver keyboard inputs to Linux.  We of course do this when
  * we see keyboard inputs coming in on a keyboard channel.
@@ -431,6 +309,92 @@ register_client_mouse(void)
 	return visorinput_dev;
 }
 
+static struct visorinput_devdata *
+devdata_create(struct visor_device *dev, enum visorinput_device_type devtype)
+{
+	struct visorinput_devdata *devdata = NULL;
+
+	devdata = kzalloc(sizeof(*devdata), GFP_KERNEL);
+	if (!devdata)
+		return NULL;
+	devdata->dev = dev;
+
+	/* This is an input device in a client guest partition,
+	 * so we need to create whatever gizmos are necessary to
+	 * deliver our inputs to the guest OS.
+	 */
+	switch (devtype) {
+	case visorinput_keyboard:
+		devdata->visorinput_dev = register_client_keyboard();
+		if (!devdata->visorinput_dev)
+			goto cleanups_register;
+		break;
+	case visorinput_mouse:
+		devdata->visorinput_dev = register_client_mouse();
+		if (!devdata->visorinput_dev)
+			goto cleanups_register;
+		break;
+	}
+
+	init_rwsem(&devdata->lock_visor_dev);
+
+	return devdata;
+
+cleanups_register:
+	kfree(devdata);
+	return NULL;
+}
+
+static int
+visorinput_probe(struct visor_device *dev)
+{
+	struct visorinput_devdata *devdata = NULL;
+	uuid_le guid;
+	enum visorinput_device_type devtype;
+
+	guid = visorchannel_get_uuid(dev->visorchannel);
+	if (uuid_le_cmp(guid, spar_mouse_channel_protocol_uuid) == 0)
+		devtype = visorinput_mouse;
+	else if (uuid_le_cmp(guid, spar_keyboard_channel_protocol_uuid) == 0)
+		devtype = visorinput_keyboard;
+	else
+		return -ENODEV;
+	devdata = devdata_create(dev, devtype);
+	if (!devdata)
+		return -ENOMEM;
+	dev_set_drvdata(&dev->device, devdata);
+	visorbus_enable_channel_interrupts(dev);
+	return 0;
+}
+
+static void
+unregister_client_input(struct input_dev *visorinput_dev)
+{
+	if (visorinput_dev)
+		input_unregister_device(visorinput_dev);
+}
+
+static void
+visorinput_remove(struct visor_device *dev)
+{
+	struct visorinput_devdata *devdata = dev_get_drvdata(&dev->device);
+
+	if (!devdata)
+		return;
+
+	visorbus_disable_channel_interrupts(dev);
+
+	/* due to above, at this time no thread of execution will be
+	* in visorinput_channel_interrupt()
+	*/
+
+	down_write(&devdata->lock_visor_dev);
+	dev_set_drvdata(&dev->device, NULL);
+	unregister_client_input(devdata->visorinput_dev);
+	up_write(&devdata->lock_visor_dev);
+	kfree(devdata);
+}
+
 static void
 do_key(struct input_dev *inpt, int keycode, int down)
 {
@@ -665,6 +629,25 @@ visorinput_resume(struct visor_device *dev,
 	return rc;
 }
 
+/* GUIDS for all channel types supported by this driver. */
+static struct visor_channeltype_descriptor visorinput_channel_types[] = {
+	{ SPAR_KEYBOARD_CHANNEL_PROTOCOL_UUID, "keyboard"},
+	{ SPAR_MOUSE_CHANNEL_PROTOCOL_UUID, "mouse"},
+	{ NULL_UUID_LE, NULL }
+};
+
+static struct visor_driver visorinput_driver = {
+	.name = "visorinput",
+	.vertag = NULL,
+	.owner = THIS_MODULE,
+	.channel_types = visorinput_channel_types,
+	.probe = visorinput_probe,
+	.remove = visorinput_remove,
+	.channel_interrupt = visorinput_channel_interrupt,
+	.pause = visorinput_pause,
+	.resume = visorinput_resume,
+};
+
 static int
 visorinput_init(void)
 {
@@ -680,7 +663,12 @@ visorinput_cleanup(void)
 module_init(visorinput_init);
 module_exit(visorinput_cleanup);
 
+MODULE_DEVICE_TABLE(visorbus, visorinput_channel_types);
+
 MODULE_AUTHOR("Unisys");
 MODULE_LICENSE("GPL");
 MODULE_DESCRIPTION("s-Par human input driver for guest Linux");
 MODULE_VERSION(VERSION);
+
+MODULE_ALIAS("visorbus:" SPAR_MOUSE_CHANNEL_PROTOCOL_UUID_STR);
+MODULE_ALIAS("visorbus:" SPAR_KEYBOARD_CHANNEL_PROTOCOL_UUID_STR);

commit dabf6c399e27e21db9f1b438467bb9b7cfc8b834
Author: Tim Sell <Timothy.Sell@unisys.com>
Date:   Fri Oct 2 13:19:16 2015 -0400

    staging: unisys: visorinput: subsume .h files directly into visorinput.c
    
    keyboardchannel.h and mousechannel.h are now included within
    visorinput.c directly.
    
    Signed-off-by: Tim Sell <Timothy.Sell@unisys.com>
    Signed-off-by: Benjamin Romer <benjamin.romer@unisys.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/unisys/visorinput/visorinput.c b/drivers/staging/unisys/visorinput/visorinput.c
index e1c328e402e3..4c5b594548d8 100644
--- a/drivers/staging/unisys/visorinput/visorinput.c
+++ b/drivers/staging/unisys/visorinput/visorinput.c
@@ -25,11 +25,26 @@
 #include <linux/fs.h>
 #include <linux/input.h>
 #include <linux/uaccess.h>
+#include <linux/kernel.h>
+#include <linux/uuid.h>
 
-#include "keyboardchannel.h"
-#include "mousechannel.h"
 #include "version.h"
 #include "visorbus.h"
+#include "channel.h"
+#include "ultrainputreport.h"
+
+/* Keyboard channel {c73416d0-b0b8-44af-b304-9d2ae99f1b3d} */
+#define SPAR_KEYBOARD_CHANNEL_PROTOCOL_UUID				\
+	UUID_LE(0xc73416d0, 0xb0b8, 0x44af,				\
+		0xb3, 0x4, 0x9d, 0x2a, 0xe9, 0x9f, 0x1b, 0x3d)
+#define SPAR_KEYBOARD_CHANNEL_PROTOCOL_UUID_STR "c73416d0-b0b8-44af-b304-9d2ae99f1b3d"
+
+/* Mouse channel {addf07d4-94a9-46e2-81c3-61abcdbdbd87} */
+#define SPAR_MOUSE_CHANNEL_PROTOCOL_UUID  \
+	UUID_LE(0xaddf07d4, 0x94a9, 0x46e2, \
+		0x81, 0xc3, 0x61, 0xab, 0xcd, 0xbd, 0xbd, 0x87)
+#define SPAR_MOUSE_CHANNEL_PROTOCOL_UUID_STR \
+	"addf07d4-94a9-46e2-81c3-61abcdbdbd87"
 
 #define PIXELS_ACROSS_DEFAULT	800
 #define PIXELS_DOWN_DEFAULT	600

commit 6ea9b6e6a78cec3e8cb2e77019795aa4a1c8c42c
Author: Tim Sell <Timothy.Sell@unisys.com>
Date:   Fri Oct 2 13:19:15 2015 -0400

    staging: unisys: visorhid: rename to visorinput
    
    This visorhid driver provides a Human Interface Device, but is not at all
    using HID, the protocol.  It's a plain input driver, so for clarity, it is
    being renamed to visorinput.
    
    Signed-off-by: Tim Sell <Timothy.Sell@unisys.com>
    Signed-off-by: Benjamin Romer <benjamin.romer@unisys.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/staging/unisys/visorinput/visorinput.c b/drivers/staging/unisys/visorinput/visorinput.c
new file mode 100644
index 000000000000..e1c328e402e3
--- /dev/null
+++ b/drivers/staging/unisys/visorinput/visorinput.c
@@ -0,0 +1,671 @@
+/* visorinput.c
+ *
+ * Copyright (C) 2011 - 2015 UNISYS CORPORATION
+ * All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, GOOD TITLE or
+ * NON INFRINGEMENT.  See the GNU General Public License for more
+ * details.
+ */
+
+/* This driver lives in a generic guest Linux partition, and registers to
+ * receive keyboard and mouse channels from the visorbus driver.  It reads
+ * inputs from such channels, and delivers it to the Linux OS in the
+ * standard way the Linux expects for input drivers.
+ */
+
+#include <linux/buffer_head.h>
+#include <linux/fb.h>
+#include <linux/fs.h>
+#include <linux/input.h>
+#include <linux/uaccess.h>
+
+#include "keyboardchannel.h"
+#include "mousechannel.h"
+#include "version.h"
+#include "visorbus.h"
+
+#define PIXELS_ACROSS_DEFAULT	800
+#define PIXELS_DOWN_DEFAULT	600
+
+static const uuid_le spar_keyboard_channel_protocol_uuid =
+	SPAR_KEYBOARD_CHANNEL_PROTOCOL_UUID;
+static const uuid_le spar_mouse_channel_protocol_uuid =
+	SPAR_MOUSE_CHANNEL_PROTOCOL_UUID;
+static int visorinput_probe(struct visor_device *dev);
+static void visorinput_remove(struct visor_device *dev);
+static void visorinput_channel_interrupt(struct visor_device *dev);
+static int visorinput_pause(struct visor_device *dev,
+			  visorbus_state_complete_func complete_func);
+static int visorinput_resume(struct visor_device *dev,
+			   visorbus_state_complete_func complete_func);
+static struct input_dev *register_client_keyboard(void);
+static struct input_dev *register_client_mouse(void);
+static void unregister_client_input(struct input_dev *visorinput_dev);
+
+/* GUIDS for all channel types supported by this driver. */
+static struct visor_channeltype_descriptor visorinput_channel_types[] = {
+	{ SPAR_KEYBOARD_CHANNEL_PROTOCOL_UUID, "keyboard"},
+	{ SPAR_MOUSE_CHANNEL_PROTOCOL_UUID, "mouse"},
+	{ NULL_UUID_LE, NULL }
+};
+MODULE_DEVICE_TABLE(visorbus, visorinput_channel_types);
+MODULE_ALIAS("visorbus:" SPAR_MOUSE_CHANNEL_PROTOCOL_UUID_STR);
+MODULE_ALIAS("visorbus:" SPAR_KEYBOARD_CHANNEL_PROTOCOL_UUID_STR);
+
+/** This is used to tell the visor bus driver which types of visor devices
+ *  we support, and what functions to call when a visor device that we support
+ *  is attached or removed.
+ */
+static struct visor_driver visorinput_driver = {
+	.name = "visorinput",
+	.vertag = NULL,
+	.owner = THIS_MODULE,
+	.channel_types = visorinput_channel_types,
+	.probe = visorinput_probe,
+	.remove = visorinput_remove,
+	.channel_interrupt = visorinput_channel_interrupt,
+	.pause = visorinput_pause,
+	.resume = visorinput_resume,
+};
+
+enum visorinput_device_type {
+	visorinput_keyboard,
+	visorinput_mouse,
+};
+
+/*  This is the private data that we store for each device.
+ *  A pointer to this struct is maintained via
+ *  dev_get_drvdata() / dev_set_drvdata() for each struct device.
+ */
+struct visorinput_devdata {
+	struct visor_device *dev;
+	/** lock for dev */
+	struct rw_semaphore lock_visor_dev;
+	struct input_dev *visorinput_dev;
+	bool paused;
+};
+
+/* Borrowed from drivers/input/keyboard/atakbd.c */
+/* This maps 1-byte scancodes to keycodes. */
+static unsigned char visorkbd_keycode[256] = {	/* American layout */
+	[0] = KEY_GRAVE,
+	[1] = KEY_ESC,
+	[2] = KEY_1,
+	[3] = KEY_2,
+	[4] = KEY_3,
+	[5] = KEY_4,
+	[6] = KEY_5,
+	[7] = KEY_6,
+	[8] = KEY_7,
+	[9] = KEY_8,
+	[10] = KEY_9,
+	[11] = KEY_0,
+	[12] = KEY_MINUS,
+	[13] = KEY_EQUAL,
+	[14] = KEY_BACKSPACE,
+	[15] = KEY_TAB,
+	[16] = KEY_Q,
+	[17] = KEY_W,
+	[18] = KEY_E,
+	[19] = KEY_R,
+	[20] = KEY_T,
+	[21] = KEY_Y,
+	[22] = KEY_U,
+	[23] = KEY_I,
+	[24] = KEY_O,
+	[25] = KEY_P,
+	[26] = KEY_LEFTBRACE,
+	[27] = KEY_RIGHTBRACE,
+	[28] = KEY_ENTER,
+	[29] = KEY_LEFTCTRL,
+	[30] = KEY_A,
+	[31] = KEY_S,
+	[32] = KEY_D,
+	[33] = KEY_F,
+	[34] = KEY_G,
+	[35] = KEY_H,
+	[36] = KEY_J,
+	[37] = KEY_K,
+	[38] = KEY_L,
+	[39] = KEY_SEMICOLON,
+	[40] = KEY_APOSTROPHE,
+	[41] = KEY_GRAVE,	/* FIXME, '#' */
+	[42] = KEY_LEFTSHIFT,
+	[43] = KEY_BACKSLASH,	/* FIXME, '~' */
+	[44] = KEY_Z,
+	[45] = KEY_X,
+	[46] = KEY_C,
+	[47] = KEY_V,
+	[48] = KEY_B,
+	[49] = KEY_N,
+	[50] = KEY_M,
+	[51] = KEY_COMMA,
+	[52] = KEY_DOT,
+	[53] = KEY_SLASH,
+	[54] = KEY_RIGHTSHIFT,
+	[55] = KEY_KPASTERISK,
+	[56] = KEY_LEFTALT,
+	[57] = KEY_SPACE,
+	[58] = KEY_CAPSLOCK,
+	[59] = KEY_F1,
+	[60] = KEY_F2,
+	[61] = KEY_F3,
+	[62] = KEY_F4,
+	[63] = KEY_F5,
+	[64] = KEY_F6,
+	[65] = KEY_F7,
+	[66] = KEY_F8,
+	[67] = KEY_F9,
+	[68] = KEY_F10,
+	[69] = KEY_NUMLOCK,
+	[70] = KEY_SCROLLLOCK,
+	[71] = KEY_KP7,
+	[72] = KEY_KP8,
+	[73] = KEY_KP9,
+	[74] = KEY_KPMINUS,
+	[75] = KEY_KP4,
+	[76] = KEY_KP5,
+	[77] = KEY_KP6,
+	[78] = KEY_KPPLUS,
+	[79] = KEY_KP1,
+	[80] = KEY_KP2,
+	[81] = KEY_KP3,
+	[82] = KEY_KP0,
+	[83] = KEY_KPDOT,
+	[86] = KEY_102ND, /* enables UK backslash+pipe key,
+			   * and FR lessthan+greaterthan key */
+	[87] = KEY_F11,
+	[88] = KEY_F12,
+	[90] = KEY_KPLEFTPAREN,
+	[91] = KEY_KPRIGHTPAREN,
+	[92] = KEY_KPASTERISK,	/* FIXME */
+	[93] = KEY_KPASTERISK,
+	[94] = KEY_KPPLUS,
+	[95] = KEY_HELP,
+	[96] = KEY_KPENTER,
+	[97] = KEY_RIGHTCTRL,
+	[98] = KEY_KPSLASH,
+	[99] = KEY_KPLEFTPAREN,
+	[100] = KEY_KPRIGHTPAREN,
+	[101] = KEY_KPSLASH,
+	[102] = KEY_HOME,
+	[103] = KEY_UP,
+	[104] = KEY_PAGEUP,
+	[105] = KEY_LEFT,
+	[106] = KEY_RIGHT,
+	[107] = KEY_END,
+	[108] = KEY_DOWN,
+	[109] = KEY_PAGEDOWN,
+	[110] = KEY_INSERT,
+	[111] = KEY_DELETE,
+	[112] = KEY_MACRO,
+	[113] = KEY_MUTE
+};
+
+/* This maps the <xx> in extended scancodes of the form "0xE0 <xx>" into
+ * keycodes.
+ */
+static unsigned char visorkbd_ext_keycode[256] = {
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,		    /* 0x00 */
+	0, 0, 0, 0, 0, 0, 0, 0,					    /* 0x10 */
+	0, 0, 0, 0, KEY_KPENTER, KEY_RIGHTCTRL, 0, 0,		    /* 0x18 */
+	0, 0, 0, 0, 0, 0, 0, 0,					    /* 0x20 */
+	KEY_RIGHTALT, 0, 0, 0, 0, 0, 0, 0,			    /* 0x28 */
+	0, 0, 0, 0, 0, 0, 0, 0,					    /* 0x30 */
+	KEY_RIGHTALT /* AltGr */, 0, 0, 0, 0, 0, 0, 0,		    /* 0x38 */
+	0, 0, 0, 0, 0, 0, 0, KEY_HOME,				    /* 0x40 */
+	KEY_UP, KEY_PAGEUP, 0, KEY_LEFT, 0, KEY_RIGHT, 0, KEY_END,  /* 0x48 */
+	KEY_DOWN, KEY_PAGEDOWN, KEY_INSERT, KEY_DELETE, 0, 0, 0, 0, /* 0x50 */
+	0, 0, 0, 0, 0, 0, 0, 0,					    /* 0x58 */
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,		    /* 0x60 */
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,		    /* 0x70 */
+};
+
+static struct visorinput_devdata *
+devdata_create(struct visor_device *dev, enum visorinput_device_type devtype)
+{
+	struct visorinput_devdata *devdata = NULL;
+
+	devdata = kzalloc(sizeof(*devdata), GFP_KERNEL);
+	if (!devdata)
+		return NULL;
+	devdata->dev = dev;
+
+	/* This is an input device in a client guest partition,
+	 * so we need to create whatever gizmos are necessary to
+	 * deliver our inputs to the guest OS.
+	 */
+	switch (devtype) {
+	case visorinput_keyboard:
+		devdata->visorinput_dev = register_client_keyboard();
+		if (!devdata->visorinput_dev)
+			goto cleanups_register;
+		break;
+	case visorinput_mouse:
+		devdata->visorinput_dev = register_client_mouse();
+		if (!devdata->visorinput_dev)
+			goto cleanups_register;
+		break;
+	}
+
+	init_rwsem(&devdata->lock_visor_dev);
+
+	return devdata;
+
+cleanups_register:
+	kfree(devdata);
+	return NULL;
+}
+
+static int
+visorinput_probe(struct visor_device *dev)
+{
+	struct visorinput_devdata *devdata = NULL;
+	uuid_le guid;
+	enum visorinput_device_type devtype;
+
+	guid = visorchannel_get_uuid(dev->visorchannel);
+	if (uuid_le_cmp(guid, spar_mouse_channel_protocol_uuid) == 0)
+		devtype = visorinput_mouse;
+	else if (uuid_le_cmp(guid, spar_keyboard_channel_protocol_uuid) == 0)
+		devtype = visorinput_keyboard;
+	else
+		return -ENODEV;
+	devdata = devdata_create(dev, devtype);
+	if (!devdata)
+		return -ENOMEM;
+	dev_set_drvdata(&dev->device, devdata);
+	visorbus_enable_channel_interrupts(dev);
+	return 0;
+}
+
+static void
+visorinput_remove(struct visor_device *dev)
+{
+	struct visorinput_devdata *devdata = dev_get_drvdata(&dev->device);
+
+	if (!devdata)
+		return;
+
+	visorbus_disable_channel_interrupts(dev);
+
+	/* due to above, at this time no thread of execution will be
+	* in visorinput_channel_interrupt()
+	*/
+
+	down_write(&devdata->lock_visor_dev);
+	dev_set_drvdata(&dev->device, NULL);
+	unregister_client_input(devdata->visorinput_dev);
+	up_write(&devdata->lock_visor_dev);
+	kfree(devdata);
+}
+
+static void
+unregister_client_input(struct input_dev *visorinput_dev)
+{
+	if (visorinput_dev)
+		input_unregister_device(visorinput_dev);
+}
+
+/* register_client_keyboard() initializes and returns a Linux gizmo that we
+ * can use to deliver keyboard inputs to Linux.  We of course do this when
+ * we see keyboard inputs coming in on a keyboard channel.
+ */
+static struct input_dev *
+register_client_keyboard(void)
+{
+	int i, error;
+	struct input_dev *visorinput_dev = NULL;
+
+	visorinput_dev = input_allocate_device();
+	if (!visorinput_dev)
+		return NULL;
+
+	visorinput_dev->name = "visor Keyboard";
+	visorinput_dev->phys = "visorkbd:input0";
+	visorinput_dev->id.bustype = BUS_HOST;
+	visorinput_dev->id.vendor = 0x0001;
+	visorinput_dev->id.product = 0x0001;
+	visorinput_dev->id.version = 0x0100;
+
+	visorinput_dev->evbit[0] = BIT_MASK(EV_KEY) |
+				   BIT_MASK(EV_REP) |
+				   BIT_MASK(EV_LED);
+	visorinput_dev->ledbit[0] = BIT_MASK(LED_CAPSL) |
+				    BIT_MASK(LED_SCROLLL) |
+				    BIT_MASK(LED_NUML);
+	visorinput_dev->keycode = visorkbd_keycode;
+	visorinput_dev->keycodesize = sizeof(unsigned char);
+	visorinput_dev->keycodemax = ARRAY_SIZE(visorkbd_keycode);
+
+	for (i = 1; i < ARRAY_SIZE(visorkbd_keycode); i++)
+		set_bit(visorkbd_keycode[i], visorinput_dev->keybit);
+
+	for (i = 1; i < ARRAY_SIZE(visorkbd_ext_keycode); i++)
+		set_bit(visorkbd_ext_keycode[i], visorinput_dev->keybit);
+
+	error = input_register_device(visorinput_dev);
+	if (error) {
+		input_free_device(visorinput_dev);
+		return NULL;
+	}
+	return visorinput_dev;
+}
+
+static struct input_dev *
+register_client_mouse(void)
+{
+	int error;
+	struct input_dev *visorinput_dev = NULL;
+	int xres, yres;
+	struct fb_info *fb0;
+
+	visorinput_dev = input_allocate_device();
+	if (!visorinput_dev)
+		return NULL;
+
+	visorinput_dev->name = "visor Mouse";
+	visorinput_dev->phys = "visormou:input0";
+	visorinput_dev->id.bustype = BUS_HOST;
+	visorinput_dev->id.vendor = 0x0001;
+	visorinput_dev->id.product = 0x0002;
+	visorinput_dev->id.version = 0x0100;
+
+	visorinput_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);
+	set_bit(BTN_LEFT, visorinput_dev->keybit);
+	set_bit(BTN_RIGHT, visorinput_dev->keybit);
+	set_bit(BTN_MIDDLE, visorinput_dev->keybit);
+
+	if (registered_fb[0]) {
+		fb0 = registered_fb[0];
+		xres = fb0->var.xres_virtual;
+		yres = fb0->var.yres_virtual;
+	} else {
+		xres = PIXELS_ACROSS_DEFAULT;
+		yres = PIXELS_DOWN_DEFAULT;
+	}
+	input_set_abs_params(visorinput_dev, ABS_X, 0, xres, 0, 0);
+	input_set_abs_params(visorinput_dev, ABS_Y, 0, yres, 0, 0);
+
+	error = input_register_device(visorinput_dev);
+	if (error) {
+		input_free_device(visorinput_dev);
+		return NULL;
+	}
+
+	/* Sending top-left and bottom-right positions is ABSOLUTELY
+	 * REQUIRED if we want X to move the mouse to the exact points
+	 * we tell it.  I have NO IDEA why.
+	 */
+	input_report_abs(visorinput_dev, ABS_X, 0);
+	input_report_abs(visorinput_dev, ABS_Y, 0);
+	input_sync(visorinput_dev);
+	input_report_abs(visorinput_dev, ABS_X, xres - 1);
+	input_report_abs(visorinput_dev, ABS_Y, yres - 1);
+	input_sync(visorinput_dev);
+
+	input_set_capability(visorinput_dev, EV_REL, REL_WHEEL);
+
+	return visorinput_dev;
+}
+
+static void
+do_key(struct input_dev *inpt, int keycode, int down)
+{
+	input_report_key(inpt, keycode, down);
+}
+
+/* Make it so the current locking state of the locking key indicated by
+ * <keycode> is as indicated by <desired_state> (1=locked, 0=unlocked).
+ */
+static void
+handle_locking_key(struct input_dev *visorinput_dev,
+		   int keycode, int desired_state)
+{
+	int led;
+	char *sled;
+
+	switch (keycode) {
+	case KEY_CAPSLOCK:
+		led = LED_CAPSL;
+		sled = "CAP";
+		break;
+	case KEY_SCROLLLOCK:
+		led = LED_SCROLLL;
+		sled = "SCR";
+		break;
+	case KEY_NUMLOCK:
+		led = LED_NUML;
+		sled = "NUM";
+		break;
+	default:
+		led = -1;
+		break;
+	}
+	if (led >= 0) {
+		int old_state = (test_bit(led, visorinput_dev->led) != 0);
+
+		if (old_state != desired_state) {
+			do_key(visorinput_dev, keycode, 1);
+			input_sync(visorinput_dev);
+			do_key(visorinput_dev, keycode, 0);
+			input_sync(visorinput_dev);
+			__change_bit(led, visorinput_dev->led);
+		}
+	}
+}
+
+/* <scancode> is either a 1-byte scancode, or an extended 16-bit scancode
+ * with 0xE0 in the low byte and the extended scancode value in the next
+ * higher byte.
+ */
+static int
+scancode_to_keycode(int scancode)
+{
+	int keycode;
+
+	if (scancode > 0xff)
+		keycode = visorkbd_ext_keycode[(scancode >> 8) & 0xff];
+	else
+		keycode = visorkbd_keycode[scancode];
+	return keycode;
+}
+
+static int
+calc_button(int x)
+{
+	switch (x) {
+	case 1:
+		return BTN_LEFT;
+	case 2:
+		return BTN_MIDDLE;
+	case 3:
+		return BTN_RIGHT;
+	default:
+		return -1;
+	}
+}
+
+/* This is used only when this driver is active as an input driver in the
+ * client guest partition.  It is called periodically so we can obtain inputs
+ * from the channel, and deliver them to the guest OS.
+ */
+static void
+visorinput_channel_interrupt(struct visor_device *dev)
+{
+	struct ultra_inputreport r;
+	int scancode, keycode;
+	struct input_dev *visorinput_dev;
+	int xmotion, ymotion, zmotion, button;
+	int i;
+
+	struct visorinput_devdata *devdata = dev_get_drvdata(&dev->device);
+
+	if (!devdata)
+		return;
+
+	down_write(&devdata->lock_visor_dev);
+	if (devdata->paused) /* don't touch device/channel when paused */
+		goto out_locked;
+
+	visorinput_dev = devdata->visorinput_dev;
+	if (!visorinput_dev)
+		goto out_locked;
+
+	while (visorchannel_signalremove(dev->visorchannel, 0, &r)) {
+		scancode = r.activity.arg1;
+		keycode = scancode_to_keycode(scancode);
+		switch (r.activity.action) {
+		case inputaction_key_down:
+			do_key(visorinput_dev, keycode, 1);
+			input_sync(visorinput_dev);
+			break;
+		case inputaction_key_up:
+			do_key(visorinput_dev, keycode, 0);
+			input_sync(visorinput_dev);
+			break;
+		case inputaction_key_down_up:
+			do_key(visorinput_dev, keycode, 1);
+			input_sync(visorinput_dev);
+			do_key(visorinput_dev, keycode, 0);
+			input_sync(visorinput_dev);
+			break;
+		case inputaction_set_locking_key_state:
+			handle_locking_key(visorinput_dev, keycode,
+					   r.activity.arg2);
+			break;
+		case inputaction_xy_motion:
+			xmotion = r.activity.arg1;
+			ymotion = r.activity.arg2;
+			input_report_abs(visorinput_dev, ABS_X, xmotion);
+			input_report_abs(visorinput_dev, ABS_Y, ymotion);
+			input_sync(visorinput_dev);
+			break;
+		case inputaction_mouse_button_down:
+			button = calc_button(r.activity.arg1);
+			if (button < 0)
+				break;
+			input_report_key(visorinput_dev, button, 1);
+			input_sync(visorinput_dev);
+			break;
+		case inputaction_mouse_button_up:
+			button = calc_button(r.activity.arg1);
+			if (button < 0)
+				break;
+			input_report_key(visorinput_dev, button, 0);
+			input_sync(visorinput_dev);
+			break;
+		case inputaction_mouse_button_click:
+			button = calc_button(r.activity.arg1);
+			if (button < 0)
+				break;
+			input_report_key(visorinput_dev, button, 1);
+
+			input_sync(visorinput_dev);
+			input_report_key(visorinput_dev, button, 0);
+			input_sync(visorinput_dev);
+			break;
+		case inputaction_mouse_button_dclick:
+			button = calc_button(r.activity.arg1);
+			if (button < 0)
+				break;
+			for (i = 0; i < 2; i++) {
+				input_report_key(visorinput_dev, button, 1);
+				input_sync(visorinput_dev);
+				input_report_key(visorinput_dev, button, 0);
+				input_sync(visorinput_dev);
+			}
+			break;
+		case inputaction_wheel_rotate_away:
+			zmotion = r.activity.arg1;
+			input_report_rel(visorinput_dev, REL_WHEEL, 1);
+			input_sync(visorinput_dev);
+			break;
+		case inputaction_wheel_rotate_toward:
+			zmotion = r.activity.arg1;
+			input_report_rel(visorinput_dev, REL_WHEEL, -1);
+			input_sync(visorinput_dev);
+			break;
+		}
+	}
+out_locked:
+	up_write(&devdata->lock_visor_dev);
+}
+
+static int
+visorinput_pause(struct visor_device *dev,
+	       visorbus_state_complete_func complete_func)
+{
+	int rc;
+	struct visorinput_devdata *devdata = dev_get_drvdata(&dev->device);
+
+	if (!devdata) {
+		rc = -ENODEV;
+		goto out;
+	}
+
+	down_write(&devdata->lock_visor_dev);
+	if (devdata->paused) {
+		rc = -EBUSY;
+		goto out_locked;
+	}
+	devdata->paused = true;
+	complete_func(dev, 0);
+	rc = 0;
+out_locked:
+	up_write(&devdata->lock_visor_dev);
+out:
+	return rc;
+}
+
+static int
+visorinput_resume(struct visor_device *dev,
+		visorbus_state_complete_func complete_func)
+{
+	int rc;
+	struct visorinput_devdata *devdata = dev_get_drvdata(&dev->device);
+
+	if (!devdata) {
+		rc = -ENODEV;
+		goto out;
+	}
+	down_write(&devdata->lock_visor_dev);
+	if (!devdata->paused) {
+		rc = -EBUSY;
+		goto out_locked;
+	}
+	devdata->paused = false;
+	complete_func(dev, 0);
+	rc = 0;
+out_locked:
+	up_write(&devdata->lock_visor_dev);
+out:
+	return rc;
+}
+
+static int
+visorinput_init(void)
+{
+	return visorbus_register_visor_driver(&visorinput_driver);
+}
+
+static void
+visorinput_cleanup(void)
+{
+	visorbus_unregister_visor_driver(&visorinput_driver);
+}
+
+module_init(visorinput_init);
+module_exit(visorinput_cleanup);
+
+MODULE_AUTHOR("Unisys");
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("s-Par human input driver for guest Linux");
+MODULE_VERSION(VERSION);
